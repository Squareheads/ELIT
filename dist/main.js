/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 69);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports) {

module.exports = require("path");

/***/ }),
/* 1 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var es5 = __webpack_require__(16);
var canEvaluate = typeof navigator == "undefined";

var errorObj = { e: {} };
var tryCatchTarget;
var globalObject = typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : undefined !== undefined ? undefined : null;

function tryCatcher() {
    try {
        var target = tryCatchTarget;
        tryCatchTarget = null;
        return target.apply(this, arguments);
    } catch (e) {
        errorObj.e = e;
        return errorObj;
    }
}
function tryCatch(fn) {
    tryCatchTarget = fn;
    return tryCatcher;
}

var inherits = function (Child, Parent) {
    var hasProp = {}.hasOwnProperty;

    function T() {
        this.constructor = Child;
        this.constructor$ = Parent;
        for (var propertyName in Parent.prototype) {
            if (hasProp.call(Parent.prototype, propertyName) && propertyName.charAt(propertyName.length - 1) !== "$") {
                this[propertyName + "$"] = Parent.prototype[propertyName];
            }
        }
    }
    T.prototype = Parent.prototype;
    Child.prototype = new T();
    return Child.prototype;
};

function isPrimitive(val) {
    return val == null || val === true || val === false || typeof val === "string" || typeof val === "number";
}

function isObject(value) {
    return typeof value === "function" || typeof value === "object" && value !== null;
}

function maybeWrapAsError(maybeError) {
    if (!isPrimitive(maybeError)) return maybeError;

    return new Error(safeToString(maybeError));
}

function withAppended(target, appendee) {
    var len = target.length;
    var ret = new Array(len + 1);
    var i;
    for (i = 0; i < len; ++i) {
        ret[i] = target[i];
    }
    ret[i] = appendee;
    return ret;
}

function getDataPropertyOrDefault(obj, key, defaultValue) {
    if (es5.isES5) {
        var desc = Object.getOwnPropertyDescriptor(obj, key);

        if (desc != null) {
            return desc.get == null && desc.set == null ? desc.value : defaultValue;
        }
    } else {
        return {}.hasOwnProperty.call(obj, key) ? obj[key] : undefined;
    }
}

function notEnumerableProp(obj, name, value) {
    if (isPrimitive(obj)) return obj;
    var descriptor = {
        value: value,
        configurable: true,
        enumerable: false,
        writable: true
    };
    es5.defineProperty(obj, name, descriptor);
    return obj;
}

function thrower(r) {
    throw r;
}

var inheritedDataKeys = function () {
    var excludedPrototypes = [Array.prototype, Object.prototype, Function.prototype];

    var isExcludedProto = function (val) {
        for (var i = 0; i < excludedPrototypes.length; ++i) {
            if (excludedPrototypes[i] === val) {
                return true;
            }
        }
        return false;
    };

    if (es5.isES5) {
        var getKeys = Object.getOwnPropertyNames;
        return function (obj) {
            var ret = [];
            var visitedKeys = Object.create(null);
            while (obj != null && !isExcludedProto(obj)) {
                var keys;
                try {
                    keys = getKeys(obj);
                } catch (e) {
                    return ret;
                }
                for (var i = 0; i < keys.length; ++i) {
                    var key = keys[i];
                    if (visitedKeys[key]) continue;
                    visitedKeys[key] = true;
                    var desc = Object.getOwnPropertyDescriptor(obj, key);
                    if (desc != null && desc.get == null && desc.set == null) {
                        ret.push(key);
                    }
                }
                obj = es5.getPrototypeOf(obj);
            }
            return ret;
        };
    } else {
        var hasProp = {}.hasOwnProperty;
        return function (obj) {
            if (isExcludedProto(obj)) return [];
            var ret = [];

            /*jshint forin:false */
            enumeration: for (var key in obj) {
                if (hasProp.call(obj, key)) {
                    ret.push(key);
                } else {
                    for (var i = 0; i < excludedPrototypes.length; ++i) {
                        if (hasProp.call(excludedPrototypes[i], key)) {
                            continue enumeration;
                        }
                    }
                    ret.push(key);
                }
            }
            return ret;
        };
    }
}();

var thisAssignmentPattern = /this\s*\.\s*\S+\s*=/;
function isClass(fn) {
    try {
        if (typeof fn === "function") {
            var keys = es5.names(fn.prototype);

            var hasMethods = es5.isES5 && keys.length > 1;
            var hasMethodsOtherThanConstructor = keys.length > 0 && !(keys.length === 1 && keys[0] === "constructor");
            var hasThisAssignmentAndStaticMethods = thisAssignmentPattern.test(fn + "") && es5.names(fn).length > 0;

            if (hasMethods || hasMethodsOtherThanConstructor || hasThisAssignmentAndStaticMethods) {
                return true;
            }
        }
        return false;
    } catch (e) {
        return false;
    }
}

function toFastProperties(obj) {
    /*jshint -W027,-W055,-W031*/
    function FakeConstructor() {}
    FakeConstructor.prototype = obj;
    var l = 8;
    while (l--) new FakeConstructor();
    return obj;
    eval(obj);
}

var rident = /^[a-z$_][a-z$_0-9]*$/i;
function isIdentifier(str) {
    return rident.test(str);
}

function filledRange(count, prefix, suffix) {
    var ret = new Array(count);
    for (var i = 0; i < count; ++i) {
        ret[i] = prefix + i + suffix;
    }
    return ret;
}

function safeToString(obj) {
    try {
        return obj + "";
    } catch (e) {
        return "[no string representation]";
    }
}

function isError(obj) {
    return obj instanceof Error || obj !== null && typeof obj === "object" && typeof obj.message === "string" && typeof obj.name === "string";
}

function markAsOriginatingFromRejection(e) {
    try {
        notEnumerableProp(e, "isOperational", true);
    } catch (ignore) {}
}

function originatesFromRejection(e) {
    if (e == null) return false;
    return e instanceof Error["__BluebirdErrorTypes__"].OperationalError || e["isOperational"] === true;
}

function canAttachTrace(obj) {
    return isError(obj) && es5.propertyIsWritable(obj, "stack");
}

var ensureErrorObject = function () {
    if (!("stack" in new Error())) {
        return function (value) {
            if (canAttachTrace(value)) return value;
            try {
                throw new Error(safeToString(value));
            } catch (err) {
                return err;
            }
        };
    } else {
        return function (value) {
            if (canAttachTrace(value)) return value;
            return new Error(safeToString(value));
        };
    }
}();

function classString(obj) {
    return {}.toString.call(obj);
}

function copyDescriptors(from, to, filter) {
    var keys = es5.names(from);
    for (var i = 0; i < keys.length; ++i) {
        var key = keys[i];
        if (filter(key)) {
            try {
                es5.defineProperty(to, key, es5.getDescriptor(from, key));
            } catch (ignore) {}
        }
    }
}

var asArray = function (v) {
    if (es5.isArray(v)) {
        return v;
    }
    return null;
};

if (typeof Symbol !== "undefined" && Symbol.iterator) {
    var ArrayFrom = typeof Array.from === "function" ? function (v) {
        return Array.from(v);
    } : function (v) {
        var ret = [];
        var it = v[Symbol.iterator]();
        var itResult;
        while (!(itResult = it.next()).done) {
            ret.push(itResult.value);
        }
        return ret;
    };

    asArray = function (v) {
        if (es5.isArray(v)) {
            return v;
        } else if (v != null && typeof v[Symbol.iterator] === "function") {
            return ArrayFrom(v);
        }
        return null;
    };
}

var isNode = typeof process !== "undefined" && classString(process).toLowerCase() === "[object process]";

var hasEnvVariables = typeof process !== "undefined" && typeof process.env !== "undefined";

function env(key) {
    return hasEnvVariables ? process.env[key] : undefined;
}

function getNativePromise() {
    if (typeof Promise === "function") {
        try {
            var promise = new Promise(function () {});
            if ({}.toString.call(promise) === "[object Promise]") {
                return Promise;
            }
        } catch (e) {}
    }
}

function domainBind(self, cb) {
    return self.bind(cb);
}

var ret = {
    isClass: isClass,
    isIdentifier: isIdentifier,
    inheritedDataKeys: inheritedDataKeys,
    getDataPropertyOrDefault: getDataPropertyOrDefault,
    thrower: thrower,
    isArray: es5.isArray,
    asArray: asArray,
    notEnumerableProp: notEnumerableProp,
    isPrimitive: isPrimitive,
    isObject: isObject,
    isError: isError,
    canEvaluate: canEvaluate,
    errorObj: errorObj,
    tryCatch: tryCatch,
    inherits: inherits,
    withAppended: withAppended,
    maybeWrapAsError: maybeWrapAsError,
    toFastProperties: toFastProperties,
    filledRange: filledRange,
    toString: safeToString,
    canAttachTrace: canAttachTrace,
    ensureErrorObject: ensureErrorObject,
    originatesFromRejection: originatesFromRejection,
    markAsOriginatingFromRejection: markAsOriginatingFromRejection,
    classString: classString,
    copyDescriptors: copyDescriptors,
    hasDevTools: typeof chrome !== "undefined" && chrome && typeof chrome.loadTimes === "function",
    isNode: isNode,
    hasEnvVariables: hasEnvVariables,
    env: env,
    global: globalObject,
    getNativePromise: getNativePromise,
    domainBind: domainBind
};
ret.isRecentNode = ret.isNode && function () {
    var version = process.versions.node.split(".").map(Number);
    return version[0] === 0 && version[1] > 10 || version[0] > 0;
}();

if (ret.isNode) ret.toFastProperties(process);

try {
    throw new Error();
} catch (e) {
    ret.lastLineError = e;
}
module.exports = ret;

/***/ }),
/* 2 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const BluebirdPromise = __webpack_require__(70)();
BluebirdPromise.config({
  longStackTraces: true
});
BluebirdPromise.default = BluebirdPromise;
module.exports = BluebirdPromise;

/***/ }),
/* 3 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _CancellationToken;

function _load_CancellationToken() {
    return _CancellationToken = __webpack_require__(40);
}

Object.defineProperty(exports, "CancellationToken", {
    enumerable: true,
    get: function () {
        return (_CancellationToken || _load_CancellationToken()).CancellationToken;
    }
});
Object.defineProperty(exports, "CancellationError", {
    enumerable: true,
    get: function () {
        return (_CancellationToken || _load_CancellationToken()).CancellationError;
    }
});

var _httpExecutor;

function _load_httpExecutor() {
    return _httpExecutor = __webpack_require__(42);
}

Object.defineProperty(exports, "HttpError", {
    enumerable: true,
    get: function () {
        return (_httpExecutor || _load_httpExecutor()).HttpError;
    }
});
Object.defineProperty(exports, "createHttpError", {
    enumerable: true,
    get: function () {
        return (_httpExecutor || _load_httpExecutor()).createHttpError;
    }
});
Object.defineProperty(exports, "HttpExecutor", {
    enumerable: true,
    get: function () {
        return (_httpExecutor || _load_httpExecutor()).HttpExecutor;
    }
});
Object.defineProperty(exports, "DigestTransform", {
    enumerable: true,
    get: function () {
        return (_httpExecutor || _load_httpExecutor()).DigestTransform;
    }
});
Object.defineProperty(exports, "safeGetHeader", {
    enumerable: true,
    get: function () {
        return (_httpExecutor || _load_httpExecutor()).safeGetHeader;
    }
});
Object.defineProperty(exports, "configureRequestOptions", {
    enumerable: true,
    get: function () {
        return (_httpExecutor || _load_httpExecutor()).configureRequestOptions;
    }
});
Object.defineProperty(exports, "configureRequestOptionsFromUrl", {
    enumerable: true,
    get: function () {
        return (_httpExecutor || _load_httpExecutor()).configureRequestOptionsFromUrl;
    }
});
Object.defineProperty(exports, "safeStringifyJson", {
    enumerable: true,
    get: function () {
        return (_httpExecutor || _load_httpExecutor()).safeStringifyJson;
    }
});
Object.defineProperty(exports, "parseJson", {
    enumerable: true,
    get: function () {
        return (_httpExecutor || _load_httpExecutor()).parseJson;
    }
});

var _publishOptions;

function _load_publishOptions() {
    return _publishOptions = __webpack_require__(131);
}

Object.defineProperty(exports, "getS3LikeProviderBaseUrl", {
    enumerable: true,
    get: function () {
        return (_publishOptions || _load_publishOptions()).getS3LikeProviderBaseUrl;
    }
});
Object.defineProperty(exports, "githubUrl", {
    enumerable: true,
    get: function () {
        return (_publishOptions || _load_publishOptions()).githubUrl;
    }
});

var _rfc2253Parser;

function _load_rfc2253Parser() {
    return _rfc2253Parser = __webpack_require__(132);
}

Object.defineProperty(exports, "parseDn", {
    enumerable: true,
    get: function () {
        return (_rfc2253Parser || _load_rfc2253Parser()).parseDn;
    }
});

var _uuid;

function _load_uuid() {
    return _uuid = __webpack_require__(133);
}

Object.defineProperty(exports, "UUID", {
    enumerable: true,
    get: function () {
        return (_uuid || _load_uuid()).UUID;
    }
});

var _ProgressCallbackTransform;

function _load_ProgressCallbackTransform() {
    return _ProgressCallbackTransform = __webpack_require__(52);
}

Object.defineProperty(exports, "ProgressCallbackTransform", {
    enumerable: true,
    get: function () {
        return (_ProgressCallbackTransform || _load_ProgressCallbackTransform()).ProgressCallbackTransform;
    }
});

var _xml;

function _load_xml() {
    return _xml = __webpack_require__(134);
}

Object.defineProperty(exports, "parseXml", {
    enumerable: true,
    get: function () {
        return (_xml || _load_xml()).parseXml;
    }
});
Object.defineProperty(exports, "XElement", {
    enumerable: true,
    get: function () {
        return (_xml || _load_xml()).XElement;
    }
});
exports.asArray = asArray;
exports.newError = newError;
function asArray(v) {
    if (v == null) {
        return [];
    } else if (Array.isArray(v)) {
        return v;
    } else {
        return [v];
    }
}
function newError(message, code) {
    const error = new Error(message);
    error.code = code;
    return error;
}
//# sourceMappingURL=index.js.map

/***/ }),
/* 4 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var YAMLException = __webpack_require__(21);

var TYPE_CONSTRUCTOR_OPTIONS = ['kind', 'resolve', 'construct', 'instanceOf', 'predicate', 'represent', 'defaultStyle', 'styleAliases'];

var YAML_NODE_KINDS = ['scalar', 'sequence', 'mapping'];

function compileStyleAliases(map) {
  var result = {};

  if (map !== null) {
    Object.keys(map).forEach(function (style) {
      map[style].forEach(function (alias) {
        result[String(alias)] = style;
      });
    });
  }

  return result;
}

function Type(tag, options) {
  options = options || {};

  Object.keys(options).forEach(function (name) {
    if (TYPE_CONSTRUCTOR_OPTIONS.indexOf(name) === -1) {
      throw new YAMLException('Unknown option "' + name + '" is met in definition of "' + tag + '" YAML type.');
    }
  });

  // TODO: Add tag format check.
  this.tag = tag;
  this.kind = options['kind'] || null;
  this.resolve = options['resolve'] || function () {
    return true;
  };
  this.construct = options['construct'] || function (data) {
    return data;
  };
  this.instanceOf = options['instanceOf'] || null;
  this.predicate = options['predicate'] || null;
  this.represent = options['represent'] || null;
  this.defaultStyle = options['defaultStyle'] || null;
  this.styleAliases = compileStyleAliases(options['styleAliases'] || null);

  if (YAML_NODE_KINDS.indexOf(this.kind) === -1) {
    throw new YAMLException('Unknown kind "' + this.kind + '" is specified for "' + tag + '" YAML type.');
  }
}

module.exports = Type;

/***/ }),
/* 5 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var fs = __webpack_require__(12);
var polyfills = __webpack_require__(109);
var legacy = __webpack_require__(111);
var queue = [];

var util = __webpack_require__(29);

function noop() {}

var debug = noop;
if (util.debuglog) debug = util.debuglog('gfs4');else if (/\bgfs4\b/i.test(process.env.NODE_DEBUG || '')) debug = function () {
  var m = util.format.apply(util, arguments);
  m = 'GFS4: ' + m.split(/\n/).join('\nGFS4: ');
  console.error(m);
};

if (/\bgfs4\b/i.test(process.env.NODE_DEBUG || '')) {
  process.on('exit', function () {
    debug(queue);
    __webpack_require__(46).equal(queue.length, 0);
  });
}

module.exports = patch(__webpack_require__(45));
if (process.env.TEST_GRACEFUL_FS_GLOBAL_PATCH) {
  module.exports = patch(fs);
}

// Always patch fs.close/closeSync, because we want to
// retry() whenever a close happens *anywhere* in the program.
// This is essential when multiple graceful-fs instances are
// in play at the same time.
module.exports.close = fs.close = function (fs$close) {
  return function (fd, cb) {
    return fs$close.call(fs, fd, function (err) {
      if (!err) retry();

      if (typeof cb === 'function') cb.apply(this, arguments);
    });
  };
}(fs.close);

module.exports.closeSync = fs.closeSync = function (fs$closeSync) {
  return function (fd) {
    // Note that graceful-fs also retries when fs.closeSync() fails.
    // Looks like a bug to me, although it's probably a harmless one.
    var rval = fs$closeSync.apply(fs, arguments);
    retry();
    return rval;
  };
}(fs.closeSync);

function patch(fs) {
  // Everything that references the open() function needs to be in here
  polyfills(fs);
  fs.gracefulify = patch;
  fs.FileReadStream = ReadStream; // Legacy name.
  fs.FileWriteStream = WriteStream; // Legacy name.
  fs.createReadStream = createReadStream;
  fs.createWriteStream = createWriteStream;
  var fs$readFile = fs.readFile;
  fs.readFile = readFile;
  function readFile(path, options, cb) {
    if (typeof options === 'function') cb = options, options = null;

    return go$readFile(path, options, cb);

    function go$readFile(path, options, cb) {
      return fs$readFile(path, options, function (err) {
        if (err && (err.code === 'EMFILE' || err.code === 'ENFILE')) enqueue([go$readFile, [path, options, cb]]);else {
          if (typeof cb === 'function') cb.apply(this, arguments);
          retry();
        }
      });
    }
  }

  var fs$writeFile = fs.writeFile;
  fs.writeFile = writeFile;
  function writeFile(path, data, options, cb) {
    if (typeof options === 'function') cb = options, options = null;

    return go$writeFile(path, data, options, cb);

    function go$writeFile(path, data, options, cb) {
      return fs$writeFile(path, data, options, function (err) {
        if (err && (err.code === 'EMFILE' || err.code === 'ENFILE')) enqueue([go$writeFile, [path, data, options, cb]]);else {
          if (typeof cb === 'function') cb.apply(this, arguments);
          retry();
        }
      });
    }
  }

  var fs$appendFile = fs.appendFile;
  if (fs$appendFile) fs.appendFile = appendFile;
  function appendFile(path, data, options, cb) {
    if (typeof options === 'function') cb = options, options = null;

    return go$appendFile(path, data, options, cb);

    function go$appendFile(path, data, options, cb) {
      return fs$appendFile(path, data, options, function (err) {
        if (err && (err.code === 'EMFILE' || err.code === 'ENFILE')) enqueue([go$appendFile, [path, data, options, cb]]);else {
          if (typeof cb === 'function') cb.apply(this, arguments);
          retry();
        }
      });
    }
  }

  var fs$readdir = fs.readdir;
  fs.readdir = readdir;
  function readdir(path, options, cb) {
    var args = [path];
    if (typeof options !== 'function') {
      args.push(options);
    } else {
      cb = options;
    }
    args.push(go$readdir$cb);

    return go$readdir(args);

    function go$readdir$cb(err, files) {
      if (files && files.sort) files.sort();

      if (err && (err.code === 'EMFILE' || err.code === 'ENFILE')) enqueue([go$readdir, [args]]);else {
        if (typeof cb === 'function') cb.apply(this, arguments);
        retry();
      }
    }
  }

  function go$readdir(args) {
    return fs$readdir.apply(fs, args);
  }

  if (process.version.substr(0, 4) === 'v0.8') {
    var legStreams = legacy(fs);
    ReadStream = legStreams.ReadStream;
    WriteStream = legStreams.WriteStream;
  }

  var fs$ReadStream = fs.ReadStream;
  ReadStream.prototype = Object.create(fs$ReadStream.prototype);
  ReadStream.prototype.open = ReadStream$open;

  var fs$WriteStream = fs.WriteStream;
  WriteStream.prototype = Object.create(fs$WriteStream.prototype);
  WriteStream.prototype.open = WriteStream$open;

  fs.ReadStream = ReadStream;
  fs.WriteStream = WriteStream;

  function ReadStream(path, options) {
    if (this instanceof ReadStream) return fs$ReadStream.apply(this, arguments), this;else return ReadStream.apply(Object.create(ReadStream.prototype), arguments);
  }

  function ReadStream$open() {
    var that = this;
    open(that.path, that.flags, that.mode, function (err, fd) {
      if (err) {
        if (that.autoClose) that.destroy();

        that.emit('error', err);
      } else {
        that.fd = fd;
        that.emit('open', fd);
        that.read();
      }
    });
  }

  function WriteStream(path, options) {
    if (this instanceof WriteStream) return fs$WriteStream.apply(this, arguments), this;else return WriteStream.apply(Object.create(WriteStream.prototype), arguments);
  }

  function WriteStream$open() {
    var that = this;
    open(that.path, that.flags, that.mode, function (err, fd) {
      if (err) {
        that.destroy();
        that.emit('error', err);
      } else {
        that.fd = fd;
        that.emit('open', fd);
      }
    });
  }

  function createReadStream(path, options) {
    return new ReadStream(path, options);
  }

  function createWriteStream(path, options) {
    return new WriteStream(path, options);
  }

  var fs$open = fs.open;
  fs.open = open;
  function open(path, flags, mode, cb) {
    if (typeof mode === 'function') cb = mode, mode = null;

    return go$open(path, flags, mode, cb);

    function go$open(path, flags, mode, cb) {
      return fs$open(path, flags, mode, function (err, fd) {
        if (err && (err.code === 'EMFILE' || err.code === 'ENFILE')) enqueue([go$open, [path, flags, mode, cb]]);else {
          if (typeof cb === 'function') cb.apply(this, arguments);
          retry();
        }
      });
    }
  }

  return fs;
}

function enqueue(elem) {
  debug('ENQUEUE', elem[0].name, elem[1]);
  queue.push(elem);
}

function retry() {
  var elem = queue.shift();
  if (elem) {
    debug('RETRY', elem[0].name, elem[1]);
    elem[0].apply(null, elem[1]);
  }
}

/***/ }),
/* 6 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.fromCallback = function (fn) {
  return Object.defineProperty(function () {
    if (typeof arguments[arguments.length - 1] === 'function') fn.apply(this, arguments);else {
      return new Promise((resolve, reject) => {
        arguments[arguments.length] = (err, res) => {
          if (err) return reject(err);
          resolve(res);
        };
        arguments.length++;
        fn.apply(this, arguments);
      });
    }
  }, 'name', { value: fn.name });
};

exports.fromPromise = function (fn) {
  return Object.defineProperty(function () {
    const cb = arguments[arguments.length - 1];
    if (typeof cb !== 'function') return fn.apply(this, arguments);else fn.apply(this, arguments).then(r => cb(null, r), cb);
  }, 'name', { value: fn.name });
};

/***/ }),
/* 7 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const u = __webpack_require__(6).fromCallback;
const mkdirs = u(__webpack_require__(113));
const mkdirsSync = __webpack_require__(114);

module.exports = {
  mkdirs: mkdirs,
  mkdirsSync: mkdirsSync,
  // alias
  mkdirp: mkdirs,
  mkdirpSync: mkdirsSync,
  ensureDir: mkdirs,
  ensureDirSync: mkdirsSync
};

/***/ }),
/* 8 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.UpdaterSignal = exports.UPDATE_DOWNLOADED = exports.DOWNLOAD_PROGRESS = exports.Provider = exports.CancellationToken = exports.NoOpLogger = exports.AppUpdater = undefined;

var _AppUpdater;

function _load_AppUpdater() {
    return _AppUpdater = __webpack_require__(27);
}

Object.defineProperty(exports, "AppUpdater", {
    enumerable: true,
    get: function () {
        return (_AppUpdater || _load_AppUpdater()).AppUpdater;
    }
});
Object.defineProperty(exports, "NoOpLogger", {
    enumerable: true,
    get: function () {
        return (_AppUpdater || _load_AppUpdater()).NoOpLogger;
    }
});

var _builderUtilRuntime;

function _load_builderUtilRuntime() {
    return _builderUtilRuntime = __webpack_require__(3);
}

Object.defineProperty(exports, "CancellationToken", {
    enumerable: true,
    get: function () {
        return (_builderUtilRuntime || _load_builderUtilRuntime()).CancellationToken;
    }
});

var _Provider;

function _load_Provider() {
    return _Provider = __webpack_require__(14);
}

Object.defineProperty(exports, "Provider", {
    enumerable: true,
    get: function () {
        return (_Provider || _load_Provider()).Provider;
    }
});
exports.getDefaultChannelName = getDefaultChannelName;
exports.getCustomChannelName = getCustomChannelName;
exports.getCurrentPlatform = getCurrentPlatform;
exports.isUseOldMacProvider = isUseOldMacProvider;
exports.getChannelFilename = getChannelFilename;
exports.newBaseUrl = newBaseUrl;
exports.newUrlFromBase = newUrlFromBase;

var _url;

function _load_url() {
    return _url = __webpack_require__(20);
}

// autoUpdater to mimic electron bundled autoUpdater
let _autoUpdater;
function _load_autoUpdater() {
    // tslint:disable:prefer-conditional-expression
    if (process.platform === "win32") {
        _autoUpdater = new (__webpack_require__(174).NsisUpdater)();
    } else if (process.platform === "darwin") {
        _autoUpdater = new (__webpack_require__(181).MacUpdater)();
    } else {
        _autoUpdater = new (__webpack_require__(182).AppImageUpdater)();
    }
    return _autoUpdater;
}
Object.defineProperty(exports, "autoUpdater", {
    enumerable: true,
    get: () => {
        return _autoUpdater || _load_autoUpdater();
    }
});
// due to historical reasons for windows we use channel name without platform specifier
function getDefaultChannelName() {
    return `latest${getChannelFilePrefix()}`;
}
function getChannelFilePrefix() {
    const currentPlatform = getCurrentPlatform();
    if (currentPlatform === "linux") {
        const arch = process.env.TEST_UPDATER_ARCH || process.arch;
        const archSuffix = arch === "x64" ? "" : `-${arch}`;
        return "-linux" + archSuffix;
    } else {
        return currentPlatform === "darwin" ? "-mac" : "";
    }
}
function getCustomChannelName(channel) {
    return `${channel}${getChannelFilePrefix()}`;
}
function getCurrentPlatform() {
    return process.env.TEST_UPDATER_PLATFORM || process.platform;
}
function isUseOldMacProvider() {
    // getCurrentPlatform() === "darwin"
    return false;
}
function getChannelFilename(channel) {
    return `${channel}.yml`;
}
const DOWNLOAD_PROGRESS = exports.DOWNLOAD_PROGRESS = "download-progress";
const UPDATE_DOWNLOADED = exports.UPDATE_DOWNLOADED = "update-downloaded";
class UpdaterSignal {
    constructor(emitter) {
        this.emitter = emitter;
    }
    /**
     * Emitted when an authenticating proxy is [asking for user credentials](https://github.com/electron/electron/blob/master/docs/api/client-request.md#event-login).
     */
    login(handler) {
        addHandler(this.emitter, "login", handler);
    }
    progress(handler) {
        addHandler(this.emitter, DOWNLOAD_PROGRESS, handler);
    }
    updateDownloaded(handler) {
        addHandler(this.emitter, UPDATE_DOWNLOADED, handler);
    }
    updateCancelled(handler) {
        addHandler(this.emitter, "update-cancelled", handler);
    }
}
exports.UpdaterSignal = UpdaterSignal;
const isLogEvent = false;
function addHandler(emitter, event, handler) {
    if (isLogEvent) {
        emitter.on(event, (...args) => {
            console.log("%s %s", event, args);
            handler.apply(null, args);
        });
    } else {
        emitter.on(event, handler);
    }
}
// if baseUrl path doesn't ends with /, this path will be not prepended to passed pathname for new URL(input, base)
/** @internal */
function newBaseUrl(url) {
    const result = new (_url || _load_url()).URL(url);
    if (!result.pathname.endsWith("/")) {
        result.pathname += "/";
    }
    return result;
}
/** @internal */
function newUrlFromBase(pathname, baseUrl) {
    const result = new (_url || _load_url()).URL(pathname, baseUrl);
    // search is not propagated
    if (!result.search && baseUrl.search) {
        result.search = baseUrl.search;
    }
    return result;
}
//# sourceMappingURL=main.js.map

/***/ }),
/* 9 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const fsExtra = __webpack_require__(107);
const Promise = __webpack_require__(2);

function makeFs(Promise) {
  const fs = Object.create(null);

  for (const methodName of Object.keys(fsExtra)) {
    const method = fsExtra[methodName];
    if (methodName === "createFile" || methodName === "mkdirp") {
      continue;
    }

    if (typeof method !== "function" || methodName.endsWith("Sync") || methodName.endsWith("Stream") || methodName.match(/^[A-Z]/) || methodName === "exists" || methodName === "watch" || methodName === "watchFile" || methodName === "unwatchFile") {
      fs[methodName] = method;
    } else {
      fs[methodName] = Promise.promisify(method);
    }
  }

  fs.createFile = fs.ensureFile;
  fs.mkdirp = fs.mkdirs;
  return fs;
}

module.exports = makeFs(Promise);

/***/ }),
/* 10 */
/***/ (function(module, exports) {

module.exports = require("electron");

/***/ }),
/* 11 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var es5 = __webpack_require__(16);
var Objectfreeze = es5.freeze;
var util = __webpack_require__(1);
var inherits = util.inherits;
var notEnumerableProp = util.notEnumerableProp;

function subError(nameProperty, defaultMessage) {
    function SubError(message) {
        if (!(this instanceof SubError)) return new SubError(message);
        notEnumerableProp(this, "message", typeof message === "string" ? message : defaultMessage);
        notEnumerableProp(this, "name", nameProperty);
        if (Error.captureStackTrace) {
            Error.captureStackTrace(this, this.constructor);
        } else {
            Error.call(this);
        }
    }
    inherits(SubError, Error);
    return SubError;
}

var _TypeError, _RangeError;
var Warning = subError("Warning", "warning");
var CancellationError = subError("CancellationError", "cancellation error");
var TimeoutError = subError("TimeoutError", "timeout error");
var AggregateError = subError("AggregateError", "aggregate error");
try {
    _TypeError = TypeError;
    _RangeError = RangeError;
} catch (e) {
    _TypeError = subError("TypeError", "type error");
    _RangeError = subError("RangeError", "range error");
}

var methods = ("join pop push shift unshift slice filter forEach some " + "every map indexOf lastIndexOf reduce reduceRight sort reverse").split(" ");

for (var i = 0; i < methods.length; ++i) {
    if (typeof Array.prototype[methods[i]] === "function") {
        AggregateError.prototype[methods[i]] = Array.prototype[methods[i]];
    }
}

es5.defineProperty(AggregateError.prototype, "length", {
    value: 0,
    configurable: false,
    writable: true,
    enumerable: true
});
AggregateError.prototype["isOperational"] = true;
var level = 0;
AggregateError.prototype.toString = function () {
    var indent = Array(level * 4 + 1).join(" ");
    var ret = "\n" + indent + "AggregateError of:" + "\n";
    level++;
    indent = Array(level * 4 + 1).join(" ");
    for (var i = 0; i < this.length; ++i) {
        var str = this[i] === this ? "[Circular AggregateError]" : this[i] + "";
        var lines = str.split("\n");
        for (var j = 0; j < lines.length; ++j) {
            lines[j] = indent + lines[j];
        }
        str = lines.join("\n");
        ret += str + "\n";
    }
    level--;
    return ret;
};

function OperationalError(message) {
    if (!(this instanceof OperationalError)) return new OperationalError(message);
    notEnumerableProp(this, "name", "OperationalError");
    notEnumerableProp(this, "message", message);
    this.cause = message;
    this["isOperational"] = true;

    if (message instanceof Error) {
        notEnumerableProp(this, "message", message.message);
        notEnumerableProp(this, "stack", message.stack);
    } else if (Error.captureStackTrace) {
        Error.captureStackTrace(this, this.constructor);
    }
}
inherits(OperationalError, Error);

var errorTypes = Error["__BluebirdErrorTypes__"];
if (!errorTypes) {
    errorTypes = Objectfreeze({
        CancellationError: CancellationError,
        TimeoutError: TimeoutError,
        OperationalError: OperationalError,
        RejectionError: OperationalError,
        AggregateError: AggregateError
    });
    es5.defineProperty(Error, "__BluebirdErrorTypes__", {
        value: errorTypes,
        writable: false,
        enumerable: false,
        configurable: false
    });
}

module.exports = {
    Error: Error,
    TypeError: _TypeError,
    RangeError: _RangeError,
    CancellationError: errorTypes.CancellationError,
    OperationalError: errorTypes.OperationalError,
    TimeoutError: errorTypes.TimeoutError,
    AggregateError: errorTypes.AggregateError,
    Warning: Warning
};

/***/ }),
/* 12 */
/***/ (function(module, exports) {

module.exports = require("fs");

/***/ }),
/* 13 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const u = __webpack_require__(6).fromPromise;
const fs = __webpack_require__(44);

function pathExists(path) {
  return fs.access(path).then(() => true).catch(() => false);
}

module.exports = {
  pathExists: u(pathExists),
  pathExistsSync: fs.existsSync
};

/***/ }),
/* 14 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Provider = undefined;
exports.findFile = findFile;
exports.parseUpdateInfo = parseUpdateInfo;
exports.getFileList = getFileList;
exports.resolveFiles = resolveFiles;

var _builderUtilRuntime;

function _load_builderUtilRuntime() {
    return _builderUtilRuntime = __webpack_require__(3);
}

var _jsYaml;

function _load_jsYaml() {
    return _jsYaml = __webpack_require__(31);
}

var _main;

function _load_main() {
    return _main = __webpack_require__(8);
}

class Provider {
    constructor(executor, useMultipleRangeRequest = true) {
        this.executor = executor;
        this.useMultipleRangeRequest = useMultipleRangeRequest;
    }
    get fileExtraDownloadHeaders() {
        return null;
    }
    setRequestHeaders(value) {
        this.requestHeaders = value;
    }
    httpRequest(url, headers, cancellationToken) {
        return this.executor.request(this.createRequestOptions(url, headers), cancellationToken);
    }
    createRequestOptions(url, headers) {
        const result = {};
        if (this.requestHeaders == null) {
            if (headers != null) {
                result.headers = headers;
            }
        } else {
            result.headers = headers == null ? this.requestHeaders : Object.assign({}, this.requestHeaders, headers);
        }
        result.protocol = url.protocol;
        result.hostname = url.hostname;
        if (url.port) {
            result.port = url.port;
        }
        result.path = url.pathname + url.search;
        return result;
    }
}
exports.Provider = Provider;
function findFile(files, extension, not) {
    if (files.length === 0) {
        throw (0, (_builderUtilRuntime || _load_builderUtilRuntime()).newError)("No files provided", "ERR_UPDATER_NO_FILES_PROVIDED");
    }
    const result = files.find(it => it.url.pathname.toLowerCase().endsWith(`.${extension}`));
    if (result != null) {
        return result;
    } else if (not == null) {
        return files[0];
    } else {
        return files.find(fileInfo => !not.some(ext => fileInfo.url.pathname.toLowerCase().endsWith(`.${ext}`)));
    }
}
function parseUpdateInfo(rawData, channelFile, channelFileUrl) {
    if (rawData == null) {
        throw (0, (_builderUtilRuntime || _load_builderUtilRuntime()).newError)(`Cannot parse update info from ${channelFile} in the latest release artifacts (${channelFileUrl}): rawData: null`, "ERR_UPDATER_INVALID_UPDATE_INFO");
    }
    let result;
    try {
        result = (0, (_jsYaml || _load_jsYaml()).safeLoad)(rawData);
    } catch (e) {
        throw (0, (_builderUtilRuntime || _load_builderUtilRuntime()).newError)(`Cannot parse update info from ${channelFile} in the latest release artifacts (${channelFileUrl}): ${e.stack || e.message}, rawData: ${rawData}`, "ERR_UPDATER_INVALID_UPDATE_INFO");
    }
    return result;
}
function getFileList(updateInfo) {
    const files = updateInfo.files;
    if (files != null && files.length > 0) {
        return files;
    }
    if (updateInfo.path != null) {
        return [{
            url: updateInfo.path,
            sha512: updateInfo.sha512
        }];
    } else {
        throw (0, (_builderUtilRuntime || _load_builderUtilRuntime()).newError)(`No files provided: ${(0, (_builderUtilRuntime || _load_builderUtilRuntime()).safeStringifyJson)(updateInfo)}`, "ERR_UPDATER_NO_FILES_PROVIDED");
    }
}
function resolveFiles(updateInfo, baseUrl, pathTransformer = p => p) {
    const files = getFileList(updateInfo);
    const result = files.map(fileInfo => {
        if (fileInfo.sha2 == null && fileInfo.sha512 == null) {
            throw (0, (_builderUtilRuntime || _load_builderUtilRuntime()).newError)(`Update info doesn't contain nor sha256 neither sha512 checksum: ${(0, (_builderUtilRuntime || _load_builderUtilRuntime()).safeStringifyJson)(fileInfo)}`, "ERR_UPDATER_NO_CHECKSUM");
        }
        return {
            url: (0, (_main || _load_main()).newUrlFromBase)(pathTransformer(fileInfo.url), baseUrl),
            info: fileInfo
        };
    });
    const packages = updateInfo.packages;
    const packageInfo = packages == null ? null : packages[process.arch] || packages.ia32;
    if (packageInfo != null) {
        result[0].packageInfo = Object.assign({}, packageInfo, { path: (0, (_main || _load_main()).newUrlFromBase)(pathTransformer(packageInfo.path), baseUrl).href });
    }
    return result;
}
//# sourceMappingURL=Provider.js.map

/***/ }),
/* 15 */
/***/ (function(module, exports) {

module.exports = require("os");

/***/ }),
/* 16 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var isES5 = function () {
    "use strict";

    return this === undefined;
}();

if (isES5) {
    module.exports = {
        freeze: Object.freeze,
        defineProperty: Object.defineProperty,
        getDescriptor: Object.getOwnPropertyDescriptor,
        keys: Object.keys,
        names: Object.getOwnPropertyNames,
        getPrototypeOf: Object.getPrototypeOf,
        isArray: Array.isArray,
        isES5: isES5,
        propertyIsWritable: function (obj, prop) {
            var descriptor = Object.getOwnPropertyDescriptor(obj, prop);
            return !!(!descriptor || descriptor.writable || descriptor.set);
        }
    };
} else {
    var has = {}.hasOwnProperty;
    var str = {}.toString;
    var proto = {}.constructor.prototype;

    var ObjectKeys = function (o) {
        var ret = [];
        for (var key in o) {
            if (has.call(o, key)) {
                ret.push(key);
            }
        }
        return ret;
    };

    var ObjectGetDescriptor = function (o, key) {
        return { value: o[key] };
    };

    var ObjectDefineProperty = function (o, key, desc) {
        o[key] = desc.value;
        return o;
    };

    var ObjectFreeze = function (obj) {
        return obj;
    };

    var ObjectGetPrototypeOf = function (obj) {
        try {
            return Object(obj).constructor.prototype;
        } catch (e) {
            return proto;
        }
    };

    var ArrayIsArray = function (obj) {
        try {
            return str.call(obj) === "[object Array]";
        } catch (e) {
            return false;
        }
    };

    module.exports = {
        isArray: ArrayIsArray,
        keys: ObjectKeys,
        names: ObjectKeys,
        defineProperty: ObjectDefineProperty,
        getDescriptor: ObjectGetDescriptor,
        freeze: ObjectFreeze,
        getPrototypeOf: ObjectGetPrototypeOf,
        isES5: isES5,
        propertyIsWritable: function () {
            return true;
        }
    };
}

/***/ }),
/* 17 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


function isNothing(subject) {
  return typeof subject === 'undefined' || subject === null;
}

function isObject(subject) {
  return typeof subject === 'object' && subject !== null;
}

function toArray(sequence) {
  if (Array.isArray(sequence)) return sequence;else if (isNothing(sequence)) return [];

  return [sequence];
}

function extend(target, source) {
  var index, length, key, sourceKeys;

  if (source) {
    sourceKeys = Object.keys(source);

    for (index = 0, length = sourceKeys.length; index < length; index += 1) {
      key = sourceKeys[index];
      target[key] = source[key];
    }
  }

  return target;
}

function repeat(string, count) {
  var result = '',
      cycle;

  for (cycle = 0; cycle < count; cycle += 1) {
    result += string;
  }

  return result;
}

function isNegativeZero(number) {
  return number === 0 && Number.NEGATIVE_INFINITY === 1 / number;
}

module.exports.isNothing = isNothing;
module.exports.isObject = isObject;
module.exports.toArray = toArray;
module.exports.repeat = repeat;
module.exports.isNegativeZero = isNegativeZero;
module.exports.extend = extend;

/***/ }),
/* 18 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/*eslint-disable max-len*/

var common = __webpack_require__(17);
var YAMLException = __webpack_require__(21);
var Type = __webpack_require__(4);

function compileList(schema, name, result) {
  var exclude = [];

  schema.include.forEach(function (includedSchema) {
    result = compileList(includedSchema, name, result);
  });

  schema[name].forEach(function (currentType) {
    result.forEach(function (previousType, previousIndex) {
      if (previousType.tag === currentType.tag && previousType.kind === currentType.kind) {
        exclude.push(previousIndex);
      }
    });

    result.push(currentType);
  });

  return result.filter(function (type, index) {
    return exclude.indexOf(index) === -1;
  });
}

function compileMap() /* lists... */{
  var result = {
    scalar: {},
    sequence: {},
    mapping: {},
    fallback: {}
  },
      index,
      length;

  function collectType(type) {
    result[type.kind][type.tag] = result['fallback'][type.tag] = type;
  }

  for (index = 0, length = arguments.length; index < length; index += 1) {
    arguments[index].forEach(collectType);
  }
  return result;
}

function Schema(definition) {
  this.include = definition.include || [];
  this.implicit = definition.implicit || [];
  this.explicit = definition.explicit || [];

  this.implicit.forEach(function (type) {
    if (type.loadKind && type.loadKind !== 'scalar') {
      throw new YAMLException('There is a non-scalar type in the implicit list of a schema. Implicit resolving of such types is not supported.');
    }
  });

  this.compiledImplicit = compileList(this, 'implicit', []);
  this.compiledExplicit = compileList(this, 'explicit', []);
  this.compiledTypeMap = compileMap(this.compiledImplicit, this.compiledExplicit);
}

Schema.DEFAULT = null;

Schema.create = function createSchema() {
  var schemas, types;

  switch (arguments.length) {
    case 1:
      schemas = Schema.DEFAULT;
      types = arguments[0];
      break;

    case 2:
      schemas = arguments[0];
      types = arguments[1];
      break;

    default:
      throw new YAMLException('Wrong number of arguments for Schema.create function');
  }

  schemas = common.toArray(schemas);
  types = common.toArray(types);

  if (!schemas.every(function (schema) {
    return schema instanceof Schema;
  })) {
    throw new YAMLException('Specified list of super schemas (or a single Schema object) contains a non-Schema object.');
  }

  if (!types.every(function (type) {
    return type instanceof Type;
  })) {
    throw new YAMLException('Specified list of YAML types (or a single Type object) contains a non-Type object.');
  }

  return new Schema({
    include: schemas,
    explicit: types
  });
};

module.exports = Schema;

/***/ }),
/* 19 */
/***/ (function(module, exports) {

module.exports = require("stream");

/***/ }),
/* 20 */
/***/ (function(module, exports) {

module.exports = require("url");

/***/ }),
/* 21 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// YAML error class. http://stackoverflow.com/questions/8458984
//


function YAMLException(reason, mark) {
  // Super constructor
  Error.call(this);

  this.name = 'YAMLException';
  this.reason = reason;
  this.mark = mark;
  this.message = (this.reason || '(unknown reason)') + (this.mark ? ' ' + this.mark.toString() : '');

  // Include stack trace in error object
  if (Error.captureStackTrace) {
    // Chrome and NodeJS
    Error.captureStackTrace(this, this.constructor);
  } else {
    // FF, IE 10+ and Safari 6+. Fallback for others
    this.stack = new Error().stack || '';
  }
}

// Inherit from Error
YAMLException.prototype = Object.create(Error.prototype);
YAMLException.prototype.constructor = YAMLException;

YAMLException.prototype.toString = function toString(compact) {
  var result = this.name + ': ';

  result += this.reason || '(unknown reason)';

  if (!compact && this.mark) {
    result += ' ' + this.mark.toString();
  }

  return result;
};

module.exports = YAMLException;

/***/ }),
/* 22 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// JS-YAML's default schema for `safeLoad` function.
// It is not described in the YAML specification.
//
// This schema is based on standard YAML's Core schema and includes most of
// extra types described at YAML tag repository. (http://yaml.org/type/)




var Schema = __webpack_require__(18);

module.exports = new Schema({
  include: [__webpack_require__(53)],
  implicit: [__webpack_require__(147), __webpack_require__(148)],
  explicit: [__webpack_require__(149), __webpack_require__(151), __webpack_require__(152), __webpack_require__(153)]
});

/***/ }),
/* 23 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/* -*- Mode: js; js-indent-level: 2; -*- */
/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */

/**
 * This is a helper function for getting values from parameter/options
 * objects.
 *
 * @param args The object we are extracting values from
 * @param name The name of the property we are getting.
 * @param defaultValue An optional value to return if the property is missing
 * from the object. If this is not specified and the property is missing, an
 * error will be thrown.
 */
function getArg(aArgs, aName, aDefaultValue) {
  if (aName in aArgs) {
    return aArgs[aName];
  } else if (arguments.length === 3) {
    return aDefaultValue;
  } else {
    throw new Error('"' + aName + '" is a required argument.');
  }
}
exports.getArg = getArg;

var urlRegexp = /^(?:([\w+\-.]+):)?\/\/(?:(\w+:\w+)@)?([\w.-]*)(?::(\d+))?(.*)$/;
var dataUrlRegexp = /^data:.+\,.+$/;

function urlParse(aUrl) {
  var match = aUrl.match(urlRegexp);
  if (!match) {
    return null;
  }
  return {
    scheme: match[1],
    auth: match[2],
    host: match[3],
    port: match[4],
    path: match[5]
  };
}
exports.urlParse = urlParse;

function urlGenerate(aParsedUrl) {
  var url = '';
  if (aParsedUrl.scheme) {
    url += aParsedUrl.scheme + ':';
  }
  url += '//';
  if (aParsedUrl.auth) {
    url += aParsedUrl.auth + '@';
  }
  if (aParsedUrl.host) {
    url += aParsedUrl.host;
  }
  if (aParsedUrl.port) {
    url += ":" + aParsedUrl.port;
  }
  if (aParsedUrl.path) {
    url += aParsedUrl.path;
  }
  return url;
}
exports.urlGenerate = urlGenerate;

/**
 * Normalizes a path, or the path portion of a URL:
 *
 * - Replaces consecutive slashes with one slash.
 * - Removes unnecessary '.' parts.
 * - Removes unnecessary '<dir>/..' parts.
 *
 * Based on code in the Node.js 'path' core module.
 *
 * @param aPath The path or url to normalize.
 */
function normalize(aPath) {
  var path = aPath;
  var url = urlParse(aPath);
  if (url) {
    if (!url.path) {
      return aPath;
    }
    path = url.path;
  }
  var isAbsolute = exports.isAbsolute(path);

  var parts = path.split(/\/+/);
  for (var part, up = 0, i = parts.length - 1; i >= 0; i--) {
    part = parts[i];
    if (part === '.') {
      parts.splice(i, 1);
    } else if (part === '..') {
      up++;
    } else if (up > 0) {
      if (part === '') {
        // The first part is blank if the path is absolute. Trying to go
        // above the root is a no-op. Therefore we can remove all '..' parts
        // directly after the root.
        parts.splice(i + 1, up);
        up = 0;
      } else {
        parts.splice(i, 2);
        up--;
      }
    }
  }
  path = parts.join('/');

  if (path === '') {
    path = isAbsolute ? '/' : '.';
  }

  if (url) {
    url.path = path;
    return urlGenerate(url);
  }
  return path;
}
exports.normalize = normalize;

/**
 * Joins two paths/URLs.
 *
 * @param aRoot The root path or URL.
 * @param aPath The path or URL to be joined with the root.
 *
 * - If aPath is a URL or a data URI, aPath is returned, unless aPath is a
 *   scheme-relative URL: Then the scheme of aRoot, if any, is prepended
 *   first.
 * - Otherwise aPath is a path. If aRoot is a URL, then its path portion
 *   is updated with the result and aRoot is returned. Otherwise the result
 *   is returned.
 *   - If aPath is absolute, the result is aPath.
 *   - Otherwise the two paths are joined with a slash.
 * - Joining for example 'http://' and 'www.example.com' is also supported.
 */
function join(aRoot, aPath) {
  if (aRoot === "") {
    aRoot = ".";
  }
  if (aPath === "") {
    aPath = ".";
  }
  var aPathUrl = urlParse(aPath);
  var aRootUrl = urlParse(aRoot);
  if (aRootUrl) {
    aRoot = aRootUrl.path || '/';
  }

  // `join(foo, '//www.example.org')`
  if (aPathUrl && !aPathUrl.scheme) {
    if (aRootUrl) {
      aPathUrl.scheme = aRootUrl.scheme;
    }
    return urlGenerate(aPathUrl);
  }

  if (aPathUrl || aPath.match(dataUrlRegexp)) {
    return aPath;
  }

  // `join('http://', 'www.example.com')`
  if (aRootUrl && !aRootUrl.host && !aRootUrl.path) {
    aRootUrl.host = aPath;
    return urlGenerate(aRootUrl);
  }

  var joined = aPath.charAt(0) === '/' ? aPath : normalize(aRoot.replace(/\/+$/, '') + '/' + aPath);

  if (aRootUrl) {
    aRootUrl.path = joined;
    return urlGenerate(aRootUrl);
  }
  return joined;
}
exports.join = join;

exports.isAbsolute = function (aPath) {
  return aPath.charAt(0) === '/' || urlRegexp.test(aPath);
};

/**
 * Make a path relative to a URL or another path.
 *
 * @param aRoot The root path or URL.
 * @param aPath The path or URL to be made relative to aRoot.
 */
function relative(aRoot, aPath) {
  if (aRoot === "") {
    aRoot = ".";
  }

  aRoot = aRoot.replace(/\/$/, '');

  // It is possible for the path to be above the root. In this case, simply
  // checking whether the root is a prefix of the path won't work. Instead, we
  // need to remove components from the root one by one, until either we find
  // a prefix that fits, or we run out of components to remove.
  var level = 0;
  while (aPath.indexOf(aRoot + '/') !== 0) {
    var index = aRoot.lastIndexOf("/");
    if (index < 0) {
      return aPath;
    }

    // If the only part of the root that is left is the scheme (i.e. http://,
    // file:///, etc.), one or more slashes (/), or simply nothing at all, we
    // have exhausted all components, so the path is not relative to the root.
    aRoot = aRoot.slice(0, index);
    if (aRoot.match(/^([^\/]+:\/)?\/*$/)) {
      return aPath;
    }

    ++level;
  }

  // Make sure we add a "../" for each component we removed from the root.
  return Array(level + 1).join("../") + aPath.substr(aRoot.length + 1);
}
exports.relative = relative;

var supportsNullProto = function () {
  var obj = Object.create(null);
  return !('__proto__' in obj);
}();

function identity(s) {
  return s;
}

/**
 * Because behavior goes wacky when you set `__proto__` on objects, we
 * have to prefix all the strings in our set with an arbitrary character.
 *
 * See https://github.com/mozilla/source-map/pull/31 and
 * https://github.com/mozilla/source-map/issues/30
 *
 * @param String aStr
 */
function toSetString(aStr) {
  if (isProtoString(aStr)) {
    return '$' + aStr;
  }

  return aStr;
}
exports.toSetString = supportsNullProto ? identity : toSetString;

function fromSetString(aStr) {
  if (isProtoString(aStr)) {
    return aStr.slice(1);
  }

  return aStr;
}
exports.fromSetString = supportsNullProto ? identity : fromSetString;

function isProtoString(s) {
  if (!s) {
    return false;
  }

  var length = s.length;

  if (length < 9 /* "__proto__".length */) {
      return false;
    }

  if (s.charCodeAt(length - 1) !== 95 /* '_' */ || s.charCodeAt(length - 2) !== 95 /* '_' */ || s.charCodeAt(length - 3) !== 111 /* 'o' */ || s.charCodeAt(length - 4) !== 116 /* 't' */ || s.charCodeAt(length - 5) !== 111 /* 'o' */ || s.charCodeAt(length - 6) !== 114 /* 'r' */ || s.charCodeAt(length - 7) !== 112 /* 'p' */ || s.charCodeAt(length - 8) !== 95 /* '_' */ || s.charCodeAt(length - 9) !== 95 /* '_' */) {
      return false;
    }

  for (var i = length - 10; i >= 0; i--) {
    if (s.charCodeAt(i) !== 36 /* '$' */) {
        return false;
      }
  }

  return true;
}

/**
 * Comparator between two mappings where the original positions are compared.
 *
 * Optionally pass in `true` as `onlyCompareGenerated` to consider two
 * mappings with the same original source/line/column, but different generated
 * line and column the same. Useful when searching for a mapping with a
 * stubbed out mapping.
 */
function compareByOriginalPositions(mappingA, mappingB, onlyCompareOriginal) {
  var cmp = strcmp(mappingA.source, mappingB.source);
  if (cmp !== 0) {
    return cmp;
  }

  cmp = mappingA.originalLine - mappingB.originalLine;
  if (cmp !== 0) {
    return cmp;
  }

  cmp = mappingA.originalColumn - mappingB.originalColumn;
  if (cmp !== 0 || onlyCompareOriginal) {
    return cmp;
  }

  cmp = mappingA.generatedColumn - mappingB.generatedColumn;
  if (cmp !== 0) {
    return cmp;
  }

  cmp = mappingA.generatedLine - mappingB.generatedLine;
  if (cmp !== 0) {
    return cmp;
  }

  return strcmp(mappingA.name, mappingB.name);
}
exports.compareByOriginalPositions = compareByOriginalPositions;

/**
 * Comparator between two mappings with deflated source and name indices where
 * the generated positions are compared.
 *
 * Optionally pass in `true` as `onlyCompareGenerated` to consider two
 * mappings with the same generated line and column, but different
 * source/name/original line and column the same. Useful when searching for a
 * mapping with a stubbed out mapping.
 */
function compareByGeneratedPositionsDeflated(mappingA, mappingB, onlyCompareGenerated) {
  var cmp = mappingA.generatedLine - mappingB.generatedLine;
  if (cmp !== 0) {
    return cmp;
  }

  cmp = mappingA.generatedColumn - mappingB.generatedColumn;
  if (cmp !== 0 || onlyCompareGenerated) {
    return cmp;
  }

  cmp = strcmp(mappingA.source, mappingB.source);
  if (cmp !== 0) {
    return cmp;
  }

  cmp = mappingA.originalLine - mappingB.originalLine;
  if (cmp !== 0) {
    return cmp;
  }

  cmp = mappingA.originalColumn - mappingB.originalColumn;
  if (cmp !== 0) {
    return cmp;
  }

  return strcmp(mappingA.name, mappingB.name);
}
exports.compareByGeneratedPositionsDeflated = compareByGeneratedPositionsDeflated;

function strcmp(aStr1, aStr2) {
  if (aStr1 === aStr2) {
    return 0;
  }

  if (aStr1 === null) {
    return 1; // aStr2 !== null
  }

  if (aStr2 === null) {
    return -1; // aStr1 !== null
  }

  if (aStr1 > aStr2) {
    return 1;
  }

  return -1;
}

/**
 * Comparator between two mappings with inflated source and name strings where
 * the generated positions are compared.
 */
function compareByGeneratedPositionsInflated(mappingA, mappingB) {
  var cmp = mappingA.generatedLine - mappingB.generatedLine;
  if (cmp !== 0) {
    return cmp;
  }

  cmp = mappingA.generatedColumn - mappingB.generatedColumn;
  if (cmp !== 0) {
    return cmp;
  }

  cmp = strcmp(mappingA.source, mappingB.source);
  if (cmp !== 0) {
    return cmp;
  }

  cmp = mappingA.originalLine - mappingB.originalLine;
  if (cmp !== 0) {
    return cmp;
  }

  cmp = mappingA.originalColumn - mappingB.originalColumn;
  if (cmp !== 0) {
    return cmp;
  }

  return strcmp(mappingA.name, mappingB.name);
}
exports.compareByGeneratedPositionsInflated = compareByGeneratedPositionsInflated;

/**
 * Strip any JSON XSSI avoidance prefix from the string (as documented
 * in the source maps specification), and then parse the string as
 * JSON.
 */
function parseSourceMapInput(str) {
  return JSON.parse(str.replace(/^\)]}'[^\n]*\n/, ''));
}
exports.parseSourceMapInput = parseSourceMapInput;

/**
 * Compute the URL of a source given the the source root, the source's
 * URL, and the source map's URL.
 */
function computeSourceURL(sourceRoot, sourceURL, sourceMapURL) {
  sourceURL = sourceURL || '';

  if (sourceRoot) {
    // This follows what Chrome does.
    if (sourceRoot[sourceRoot.length - 1] !== '/' && sourceURL[0] !== '/') {
      sourceRoot += '/';
    }
    // The spec says:
    //   Line 4: An optional source root, useful for relocating source
    //   files on a server or removing repeated values in the
    //   “sources” entry.  This value is prepended to the individual
    //   entries in the “source” field.
    sourceURL = sourceRoot + sourceURL;
  }

  // Historically, SourceMapConsumer did not take the sourceMapURL as
  // a parameter.  This mode is still somewhat supported, which is why
  // this code block is conditional.  However, it's preferable to pass
  // the source map URL to SourceMapConsumer, so that this function
  // can implement the source URL resolution algorithm as outlined in
  // the spec.  This block is basically the equivalent of:
  //    new URL(sourceURL, sourceMapURL).toString()
  // ... except it avoids using URL, which wasn't available in the
  // older releases of node still supported by this library.
  //
  // The spec says:
  //   If the sources are not absolute URLs after prepending of the
  //   “sourceRoot”, the sources are resolved relative to the
  //   SourceMap (like resolving script src in a html document).
  if (sourceMapURL) {
    var parsed = urlParse(sourceMapURL);
    if (!parsed) {
      throw new Error("sourceMapURL could not be parsed");
    }
    if (parsed.path) {
      // Strip the last path component, but keep the "/".
      var index = parsed.path.lastIndexOf('/');
      if (index >= 0) {
        parsed.path = parsed.path.substring(0, index + 1);
      }
    }
    sourceURL = join(urlGenerate(parsed), sourceURL);
  }

  return normalize(sourceURL);
}
exports.computeSourceURL = computeSourceURL;

/***/ }),
/* 24 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const u = __webpack_require__(6).fromCallback;
const rimraf = __webpack_require__(116);

module.exports = {
  remove: u(rimraf),
  removeSync: rimraf.sync
};

/***/ }),
/* 25 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// JS-YAML's default schema for `load` function.
// It is not described in the YAML specification.
//
// This schema is based on JS-YAML's default safe schema and includes
// JavaScript-specific types: !!js/undefined, !!js/regexp and !!js/function.
//
// Also this schema is used as default base schema at `Schema.create` function.




var Schema = __webpack_require__(18);

module.exports = Schema.DEFAULT = new Schema({
  include: [__webpack_require__(22)],
  explicit: [__webpack_require__(154), __webpack_require__(155), __webpack_require__(156)]
});

/***/ }),
/* 26 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const getFromEnv = parseInt(process.env.ELECTRON_IS_DEV, 10) === 1;
const isEnvSet = 'ELECTRON_IS_DEV' in process.env;

module.exports = isEnvSet ? getFromEnv : process.defaultApp || /node_modules[\\/]electron[\\/]/.test(process.execPath);

/***/ }),
/* 27 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.NoOpLogger = exports.AppUpdater = undefined;

var _bluebirdLst;

function _load_bluebirdLst() {
    return _bluebirdLst = __webpack_require__(2);
}

var _bluebirdLst2;

function _load_bluebirdLst2() {
    return _bluebirdLst2 = _interopRequireDefault(__webpack_require__(2));
}

var _builderUtilRuntime;

function _load_builderUtilRuntime() {
    return _builderUtilRuntime = __webpack_require__(3);
}

var _crypto;

function _load_crypto() {
    return _crypto = __webpack_require__(28);
}

var _electron;

function _load_electron() {
    return _electron = __webpack_require__(10);
}

var _electronIsDev;

function _load_electronIsDev() {
    return _electronIsDev = _interopRequireDefault(__webpack_require__(26));
}

var _events;

function _load_events() {
    return _events = __webpack_require__(41);
}

var _fsExtraP;

function _load_fsExtraP() {
    return _fsExtraP = __webpack_require__(9);
}

var _jsYaml;

function _load_jsYaml() {
    return _jsYaml = __webpack_require__(31);
}

var _lazyVal;

function _load_lazyVal() {
    return _lazyVal = __webpack_require__(159);
}

var _path = _interopRequireWildcard(__webpack_require__(0));

var _semver;

function _load_semver() {
    return _semver = __webpack_require__(55);
}

__webpack_require__(33);

var _electronHttpExecutor;

function _load_electronHttpExecutor() {
    return _electronHttpExecutor = __webpack_require__(169);
}

var _GenericProvider;

function _load_GenericProvider() {
    return _GenericProvider = __webpack_require__(59);
}

var _main;

function _load_main() {
    return _main = __webpack_require__(8);
}

var _providerFactory;

function _load_providerFactory() {
    return _providerFactory = __webpack_require__(170);
}

function _interopRequireWildcard(obj) {
    if (obj && obj.__esModule) {
        return obj;
    } else {
        var newObj = {};if (obj != null) {
            for (var key in obj) {
                if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key];
            }
        }newObj.default = obj;return newObj;
    }
}

function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
}

class AppUpdater extends (_events || _load_events()).EventEmitter {
    constructor(options, app) {
        super();
        /**
         * Whether to automatically download an update when it is found.
         */
        this.autoDownload = true;
        /**
         * *GitHub provider only.* Whether to allow update to pre-release versions. Defaults to `true` if application version contains prerelease components (e.g. `0.12.1-alpha.1`, here `alpha` is a prerelease component), otherwise `false`.
         *
         * If `true`, downgrade will be allowed (`allowDowngrade` will be set to `true`).
         */
        this.allowPrerelease = false;
        /**
         * *GitHub provider only.* Get all release notes (from current version to latest), not just the latest.
         * @default false
         */
        this.fullChangelog = false;
        /**
         * Whether to allow version downgrade (when a user from the beta channel wants to go back to the stable channel).
         * @default false
         */
        this.allowDowngrade = false;
        this._channel = null;
        this._logger = console;
        /**
         * For type safety you can use signals, e.g. `autoUpdater.signals.updateDownloaded(() => {})` instead of `autoUpdater.on('update-available', () => {})`
         */
        this.signals = new (_main || _load_main()).UpdaterSignal(this);
        this.updateAvailable = false;
        this.stagingUserIdPromise = new (_lazyVal || _load_lazyVal()).Lazy(() => this.getOrCreateStagingUserId());
        // public, allow to read old config for anyone
        this.configOnDisk = new (_lazyVal || _load_lazyVal()).Lazy(() => this.loadUpdateConfig());
        this.on("error", error => {
            this._logger.error(`Error: ${error.stack || error.message}`);
        });
        if (app != null || global.__test_app != null) {
            this.app = app || global.__test_app;
            this.untilAppReady = (_bluebirdLst2 || _load_bluebirdLst2()).default.resolve();
        } else {
            this.app = __webpack_require__(10).app;
            this.httpExecutor = new (_electronHttpExecutor || _load_electronHttpExecutor()).ElectronHttpExecutor((authInfo, callback) => this.emit("login", authInfo, callback));
            this.untilAppReady = new (_bluebirdLst2 || _load_bluebirdLst2()).default(resolve => {
                if (this.app.isReady()) {
                    resolve();
                } else {
                    this.app.on("ready", resolve);
                }
            });
        }
        const currentVersionString = this.app.getVersion();
        const currentVersion = (0, (_semver || _load_semver()).valid)(currentVersionString);
        if (currentVersion == null) {
            throw (0, (_builderUtilRuntime || _load_builderUtilRuntime()).newError)(`App version is not a valid semver version: "${currentVersionString}`, "ERR_UPDATER_INVALID_VERSION");
        }
        this.currentVersion = currentVersion;
        this.allowPrerelease = hasPrereleaseComponents(this.currentVersion);
        if (options != null) {
            this.setFeedURL(options);
        }
    }
    /**
     * Get the update channel. Not applicable for GitHub. Doesn't return `channel` from the update configuration, only if was previously set.
     */
    get channel() {
        return this._channel;
    }
    /**
     * Set the update channel. Not applicable for GitHub. Overrides `channel` in the update configuration.
     *
     * `allowDowngrade` will be automatically set to `true`. If this behavior is not suitable for you, simple set `allowDowngrade` explicitly after.
     */
    set channel(value) {
        if (this._channel != null) {
            if (typeof value !== "string") {
                throw (0, (_builderUtilRuntime || _load_builderUtilRuntime()).newError)(`Channel must be a string, but got: ${value}`, "ERR_UPDATER_INVALID_CHANNEL");
            } else if (value.length === 0) {
                throw (0, (_builderUtilRuntime || _load_builderUtilRuntime()).newError)(`Channel must be not an empty string`, "ERR_UPDATER_INVALID_CHANNEL");
            }
        }
        this._channel = value;
        this.allowDowngrade = true;
    }
    /**
     * The logger. You can pass [electron-log](https://github.com/megahertz/electron-log), [winston](https://github.com/winstonjs/winston) or another logger with the following interface: `{ info(), warn(), error() }`.
     * Set it to `null` if you would like to disable a logging feature.
     */
    get logger() {
        return this._logger;
    }
    set logger(value) {
        this._logger = value == null ? new NoOpLogger() : value;
    }
    /**
     * test only
     * @private
     */
    set updateConfigPath(value) {
        this.clientPromise = null;
        this._appUpdateConfigPath = value;
        this.configOnDisk = new (_lazyVal || _load_lazyVal()).Lazy(() => this.loadUpdateConfig());
    }
    get provider() {
        return this.clientPromise;
    }
    //noinspection JSMethodCanBeStatic,JSUnusedGlobalSymbols
    getFeedURL() {
        return "Deprecated. Do not use it.";
    }
    /**
     * Configure update provider. If value is `string`, [GenericServerOptions](/configuration/publish.md#genericserveroptions) will be set with value as `url`.
     * @param options If you want to override configuration in the `app-update.yml`.
     */
    setFeedURL(options) {
        // https://github.com/electron-userland/electron-builder/issues/1105
        let provider;
        if (typeof options === "string") {
            provider = new (_GenericProvider || _load_GenericProvider()).GenericProvider({ provider: "generic", url: options }, this);
        } else {
            provider = (0, (_providerFactory || _load_providerFactory()).createClient)(options, this);
        }
        this.clientPromise = Promise.resolve(provider);
    }
    /**
     * Asks the server whether there is an update.
     */
    checkForUpdates() {
        let checkForUpdatesPromise = this.checkForUpdatesPromise;
        if (checkForUpdatesPromise != null) {
            return checkForUpdatesPromise;
        }
        checkForUpdatesPromise = this._checkForUpdates();
        this.checkForUpdatesPromise = checkForUpdatesPromise;
        const nullizePromise = () => this.checkForUpdatesPromise = null;
        checkForUpdatesPromise.then(nullizePromise).catch(nullizePromise);
        return checkForUpdatesPromise;
    }
    checkForUpdatesAndNotify() {
        if ((_electronIsDev || _load_electronIsDev()).default) {
            return (_bluebirdLst2 || _load_bluebirdLst2()).default.resolve(null);
        }
        this.signals.updateDownloaded(it => {
            new (_electron || _load_electron()).Notification({
                title: "A new update is ready to install",
                body: `${this.app.getName()} version ${it.version} is downloaded and will be automatically installed on exit`
            }).show();
        });
        return this.checkForUpdates();
    }
    isStagingMatch(updateInfo) {
        var _this = this;

        return (0, (_bluebirdLst || _load_bluebirdLst()).coroutine)(function* () {
            const rawStagingPercentage = updateInfo.stagingPercentage;
            let stagingPercentage = rawStagingPercentage;
            if (stagingPercentage == null) {
                return true;
            }
            stagingPercentage = parseInt(stagingPercentage, 10);
            if (isNaN(stagingPercentage)) {
                _this._logger.warn(`Staging percentage is NaN: ${rawStagingPercentage}`);
                return true;
            }
            // convert from user 0-100 to internal 0-1
            stagingPercentage = stagingPercentage / 100;
            const stagingUserId = yield _this.stagingUserIdPromise.value;
            const val = (_builderUtilRuntime || _load_builderUtilRuntime()).UUID.parse(stagingUserId).readUInt32BE(12);
            const percentage = val / 0xFFFFFFFF;
            _this._logger.info(`Staging percentage: ${stagingPercentage}, percentage: ${percentage}, user id: ${stagingUserId}`);
            return percentage < stagingPercentage;
        })();
    }
    _checkForUpdates() {
        var _this2 = this;

        return (0, (_bluebirdLst || _load_bluebirdLst()).coroutine)(function* () {
            try {
                yield _this2.untilAppReady;
                _this2._logger.info("Checking for update");
                _this2.emit("checking-for-update");
                return yield _this2.doCheckForUpdates();
            } catch (e) {
                _this2.emit("error", e, `Cannot check for updates: ${(e.stack || e).toString()}`);
                throw e;
            }
        })();
    }
    computeFinalHeaders(headers) {
        if (this.requestHeaders != null) {
            Object.assign(headers, this.requestHeaders);
        }
        return headers;
    }
    doCheckForUpdates() {
        var _this3 = this;

        return (0, (_bluebirdLst || _load_bluebirdLst()).coroutine)(function* () {
            if (_this3.clientPromise == null) {
                _this3.clientPromise = _this3.configOnDisk.value.then(function (it) {
                    return (0, (_providerFactory || _load_providerFactory()).createClient)(it, _this3);
                });
            }
            const client = yield _this3.clientPromise;
            const stagingUserId = yield _this3.stagingUserIdPromise.value;
            client.setRequestHeaders(_this3.computeFinalHeaders({ "X-User-Staging-Id": stagingUserId }));
            const updateInfo = yield client.getLatestVersion();
            const latestVersion = (0, (_semver || _load_semver()).valid)(updateInfo.version);
            if (latestVersion == null) {
                throw (0, (_builderUtilRuntime || _load_builderUtilRuntime()).newError)(`Latest version (from update server) is not valid semver version: "${latestVersion}`, "ERR_UPDATER_INVALID_VERSION");
            }
            const isStagingMatch = yield _this3.isStagingMatch(updateInfo);
            if (!isStagingMatch || (_this3.allowDowngrade && !hasPrereleaseComponents(latestVersion) ? (0, (_semver || _load_semver()).eq)(latestVersion, _this3.currentVersion) : !(0, (_semver || _load_semver()).gt)(latestVersion, _this3.currentVersion))) {
                _this3.updateAvailable = false;
                _this3._logger.info(`Update for version ${_this3.currentVersion} is not available (latest version: ${updateInfo.version}, downgrade is ${_this3.allowDowngrade ? "allowed" : "disallowed"}.`);
                _this3.emit("update-not-available", updateInfo);
                return {
                    versionInfo: updateInfo,
                    updateInfo
                };
            }
            _this3.updateAvailable = true;
            _this3.updateInfo = updateInfo;
            _this3.onUpdateAvailable(updateInfo);
            const cancellationToken = new (_builderUtilRuntime || _load_builderUtilRuntime()).CancellationToken();
            //noinspection ES6MissingAwait
            return {
                versionInfo: updateInfo,
                updateInfo,
                cancellationToken,
                downloadPromise: _this3.autoDownload ? _this3.downloadUpdate(cancellationToken) : null
            };
        })();
    }
    onUpdateAvailable(updateInfo) {
        this._logger.info(`Found version ${updateInfo.version} (url: ${(0, (_builderUtilRuntime || _load_builderUtilRuntime()).asArray)(updateInfo.files).map(it => it.url).join(", ")})`);
        this.emit("update-available", updateInfo);
    }
    /**
     * Start downloading update manually. You can use this method if `autoDownload` option is set to `false`.
     * @returns {Promise<string>} Path to downloaded file.
     */
    downloadUpdate(cancellationToken = new (_builderUtilRuntime || _load_builderUtilRuntime()).CancellationToken()) {
        var _this4 = this;

        return (0, (_bluebirdLst || _load_bluebirdLst()).coroutine)(function* () {
            const updateInfo = _this4.updateInfo;
            if (updateInfo == null) {
                const error = new Error("Please check update first");
                _this4.dispatchError(error);
                throw error;
            }
            _this4._logger.info(`Downloading update from ${(0, (_builderUtilRuntime || _load_builderUtilRuntime()).asArray)(updateInfo.files).map(function (it) {
                return it.url;
            }).join(", ")}`);
            try {
                return yield _this4.doDownloadUpdate(updateInfo, cancellationToken);
            } catch (e) {
                _this4.dispatchError(e);
                throw e;
            }
        })();
    }
    dispatchError(e) {
        this.emit("error", e, (e.stack || e).toString());
    }
    loadUpdateConfig() {
        var _this5 = this;

        return (0, (_bluebirdLst || _load_bluebirdLst()).coroutine)(function* () {
            if (_this5._appUpdateConfigPath == null) {
                _this5._appUpdateConfigPath = (_electronIsDev || _load_electronIsDev()).default ? _path.join(_this5.app.getAppPath(), "dev-app-update.yml") : _path.join(process.resourcesPath, "app-update.yml");
            }
            return (0, (_jsYaml || _load_jsYaml()).safeLoad)((yield (0, (_fsExtraP || _load_fsExtraP()).readFile)(_this5._appUpdateConfigPath, "utf-8")));
        })();
    }
    /*** @private */
    computeRequestHeaders() {
        var _this6 = this;

        return (0, (_bluebirdLst || _load_bluebirdLst()).coroutine)(function* () {
            const fileExtraDownloadHeaders = (yield _this6.provider).fileExtraDownloadHeaders;
            if (fileExtraDownloadHeaders != null) {
                const requestHeaders = _this6.requestHeaders;
                return requestHeaders == null ? fileExtraDownloadHeaders : Object.assign({}, fileExtraDownloadHeaders, requestHeaders);
            }
            return _this6.computeFinalHeaders({ Accept: "*/*" });
        })();
    }
    getOrCreateStagingUserId() {
        var _this7 = this;

        return (0, (_bluebirdLst || _load_bluebirdLst()).coroutine)(function* () {
            const file = _path.join(_this7.app.getPath("userData"), ".updaterId");
            try {
                const id = yield (0, (_fsExtraP || _load_fsExtraP()).readFile)(file, "utf-8");
                if ((_builderUtilRuntime || _load_builderUtilRuntime()).UUID.check(id)) {
                    return id;
                } else {
                    _this7._logger.warn(`Staging user id file exists, but content was invalid: ${id}`);
                }
            } catch (e) {
                if (e.code !== "ENOENT") {
                    _this7._logger.warn(`Couldn't read staging user ID, creating a blank one: ${e}`);
                }
            }
            const id = (_builderUtilRuntime || _load_builderUtilRuntime()).UUID.v5((0, (_crypto || _load_crypto()).randomBytes)(4096), (_builderUtilRuntime || _load_builderUtilRuntime()).UUID.OID);
            _this7._logger.info(`Generated new staging user ID: ${id}`);
            try {
                yield (0, (_fsExtraP || _load_fsExtraP()).outputFile)(file, id);
            } catch (e) {
                _this7._logger.warn(`Couldn't write out staging user ID: ${e}`);
            }
            return id;
        })();
    }
}
exports.AppUpdater = AppUpdater;
function hasPrereleaseComponents(version) {
    const versionPrereleaseComponent = (0, (_semver || _load_semver()).prerelease)(version);
    return versionPrereleaseComponent != null && versionPrereleaseComponent.length > 0;
}
/** @private */
class NoOpLogger {
    info(message) {
        // ignore
    }
    warn(message) {
        // ignore
    }
    error(message) {
        // ignore
    }
}
exports.NoOpLogger = NoOpLogger; //# sourceMappingURL=AppUpdater.js.map

/***/ }),
/* 28 */
/***/ (function(module, exports) {

module.exports = require("crypto");

/***/ }),
/* 29 */
/***/ (function(module, exports) {

module.exports = require("util");

/***/ }),
/* 30 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const u = __webpack_require__(6).fromCallback;
const jsonFile = __webpack_require__(118);

module.exports = {
  // jsonfile exports
  readJson: u(jsonFile.readFile),
  readJsonSync: jsonFile.readFileSync,
  writeJson: u(jsonFile.writeFile),
  writeJsonSync: jsonFile.writeFileSync
};

/***/ }),
/* 31 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var yaml = __webpack_require__(137);

module.exports = yaml;

/***/ }),
/* 32 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Standard YAML's Failsafe schema.
// http://www.yaml.org/spec/1.2/spec.html#id2802346




var Schema = __webpack_require__(18);

module.exports = new Schema({
  explicit: [__webpack_require__(140), __webpack_require__(141), __webpack_require__(142)]
});

/***/ }),
/* 33 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__(160).install();

/***/ }),
/* 34 */
/***/ (function(module, exports) {

module.exports = require("child_process");

/***/ }),
/* 35 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.computeOperations = computeOperations;
var OperationKind = exports.OperationKind = undefined;
(function (OperationKind) {
    OperationKind[OperationKind["COPY"] = 0] = "COPY";
    OperationKind[OperationKind["DOWNLOAD"] = 1] = "DOWNLOAD";
})(OperationKind || (exports.OperationKind = OperationKind = {}));
function computeOperations(oldBlockMap, newBlockMap, logger) {
    const nameToOldBlocks = buildBlockFileMap(oldBlockMap.files);
    const nameToNewBlocks = buildBlockFileMap(newBlockMap.files);
    const oldEntryMap = buildEntryMap(oldBlockMap.files);
    let lastOperation = null;
    const operations = [];
    for (const blockMapFile of newBlockMap.files) {
        const name = blockMapFile.name;
        const oldEntry = oldEntryMap.get(name);
        if (oldEntry == null) {
            // new file
            operations.push({
                kind: OperationKind.DOWNLOAD,
                start: blockMapFile.offset,
                end: blockMapFile.offset + blockMapFile.sizes.reduce((accumulator, currentValue) => accumulator + currentValue)
            });
            continue;
        }
        const newFile = nameToNewBlocks.get(name);
        let changedBlockCount = 0;
        const { checksumToOffset: checksumToOldOffset, checksumToOldSize } = buildChecksumMap(nameToOldBlocks.get(name), oldEntry.offset);
        let newOffset = blockMapFile.offset;
        for (let i = 0; i < newFile.checksums.length; newOffset += newFile.sizes[i], i++) {
            const blockSize = newFile.sizes[i];
            const checksum = newFile.checksums[i];
            let oldOffset = checksumToOldOffset.get(checksum);
            if (oldOffset != null && checksumToOldSize.get(checksum) !== blockSize) {
                logger.warn(`Checksum ("${checksum}") matches, but size differs (old: ${checksumToOldSize.get(checksum)}, new: ${blockSize})`);
                oldOffset = null;
            }
            if (oldOffset == null) {
                changedBlockCount++;
                if (lastOperation == null || lastOperation.kind !== OperationKind.DOWNLOAD || lastOperation.end !== newOffset) {
                    lastOperation = {
                        kind: OperationKind.DOWNLOAD,
                        start: newOffset,
                        end: newOffset + blockSize
                    };
                    operations.push(lastOperation);
                } else {
                    lastOperation.end += blockSize;
                }
            } else if (lastOperation == null || lastOperation.kind !== OperationKind.COPY || lastOperation.end !== oldOffset) {
                lastOperation = {
                    kind: OperationKind.COPY,
                    start: oldOffset,
                    end: oldOffset + blockSize
                };
                operations.push(lastOperation);
            } else {
                lastOperation.end += blockSize;
            }
        }
        if (changedBlockCount > 0) {
            logger.info(`File${blockMapFile.name === "file" ? "" : " " + blockMapFile.name} has ${changedBlockCount} changed blocks`);
        }
    }
    return operations;
}
function buildChecksumMap(file, fileOffset) {
    const checksumToOffset = new Map();
    const checksumToSize = new Map();
    let offset = fileOffset;
    for (let i = 0; i < file.checksums.length; i++) {
        const checksum = file.checksums[i];
        const size = file.sizes[i];
        checksumToOffset.set(checksum, offset);
        checksumToSize.set(checksum, size);
        offset += size;
    }
    return { checksumToOffset, checksumToOldSize: checksumToSize };
}
function buildEntryMap(list) {
    const result = new Map();
    for (const item of list) {
        result.set(item.name, item);
    }
    return result;
}
function buildBlockFileMap(list) {
    const result = new Map();
    for (const item of list) {
        result.set(item.name, item);
    }
    return result;
}
//# sourceMappingURL=downloadPlanBuilder.js.map

/***/ }),
/* 36 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var format = __webpack_require__(37);
var originalConsole = __webpack_require__(68);

transport.level = 'silly';
transport.format = '[{h}:{i}:{s}.{ms}] [{level}] {text}';

module.exports = transport;

function transport(msg) {
  var text = format.format(msg, transport.format);
  if (originalConsole[msg.level]) {
    originalConsole[msg.level](text);
  } else {
    originalConsole.log(text);
  }
}

/***/ }),
/* 37 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var util = __webpack_require__(29);
var EOL = __webpack_require__(15).EOL;

module.exports = {
  format: format,
  formatTimeZone: formatTimeZone,
  pad: pad,
  stringifyArray: stringifyArray
};

function format(msg, formatter) {
  if (typeof formatter === 'function') {
    return formatter(msg);
  }

  var date = msg.date;

  return formatter.replace('{level}', msg.level).replace('{text}', stringifyArray(msg.data)).replace('{y}', date.getFullYear()).replace('{m}', pad(date.getMonth() + 1)).replace('{d}', pad(date.getDate())).replace('{h}', pad(date.getHours())).replace('{i}', pad(date.getMinutes())).replace('{s}', pad(date.getSeconds())).replace('{ms}', pad(date.getMilliseconds(), 3)).replace('{z}', formatTimeZone(date.getTimezoneOffset()));
}

function stringifyArray(data) {
  data = data.map(function formatErrors(arg) {
    return arg instanceof Error ? arg.stack + EOL : arg;
  });
  return util.format.apply(util, data);
}

function pad(number, zeros) {
  zeros = zeros || 2;
  return (new Array(zeros + 1).join('0') + number).substr(-zeros, zeros);
}

function formatTimeZone(minutesOffset) {
  var m = Math.abs(minutesOffset);
  return (minutesOffset >= 0 ? '-' : '+') + pad(Math.floor(m / 60)) + ':' + pad(m % 60);
}

/***/ }),
/* 38 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = function (NEXT_FILTER) {
    var util = __webpack_require__(1);
    var getKeys = __webpack_require__(16).keys;
    var tryCatch = util.tryCatch;
    var errorObj = util.errorObj;

    function catchFilter(instances, cb, promise) {
        return function (e) {
            var boundTo = promise._boundValue();
            predicateLoop: for (var i = 0; i < instances.length; ++i) {
                var item = instances[i];

                if (item === Error || item != null && item.prototype instanceof Error) {
                    if (e instanceof item) {
                        return tryCatch(cb).call(boundTo, e);
                    }
                } else if (typeof item === "function") {
                    var matchesPredicate = tryCatch(item).call(boundTo, e);
                    if (matchesPredicate === errorObj) {
                        return matchesPredicate;
                    } else if (matchesPredicate) {
                        return tryCatch(cb).call(boundTo, e);
                    }
                } else if (util.isObject(e)) {
                    var keys = getKeys(item);
                    for (var j = 0; j < keys.length; ++j) {
                        var key = keys[j];
                        if (item[key] != e[key]) {
                            continue predicateLoop;
                        }
                    }
                    return tryCatch(cb).call(boundTo, e);
                }
            }
            return NEXT_FILTER;
        };
    }

    return catchFilter;
};

/***/ }),
/* 39 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var util = __webpack_require__(1);
var maybeWrapAsError = util.maybeWrapAsError;
var errors = __webpack_require__(11);
var OperationalError = errors.OperationalError;
var es5 = __webpack_require__(16);

function isUntypedError(obj) {
    return obj instanceof Error && es5.getPrototypeOf(obj) === Error.prototype;
}

var rErrorKey = /^(?:name|message|stack|cause)$/;
function wrapAsOperationalError(obj) {
    var ret;
    if (isUntypedError(obj)) {
        ret = new OperationalError(obj);
        ret.name = obj.name;
        ret.message = obj.message;
        ret.stack = obj.stack;
        var keys = es5.keys(obj);
        for (var i = 0; i < keys.length; ++i) {
            var key = keys[i];
            if (!rErrorKey.test(key)) {
                ret[key] = obj[key];
            }
        }
        return ret;
    }
    util.markAsOriginatingFromRejection(obj);
    return obj;
}

function nodebackForPromise(promise, multiArgs) {
    return function (err, value) {
        if (promise === null) return;
        if (err) {
            var wrapped = wrapAsOperationalError(maybeWrapAsError(err));
            promise._attachExtraTrace(wrapped);
            promise._reject(wrapped);
        } else if (!multiArgs) {
            promise._fulfill(value);
        } else {
            var $_len = arguments.length;var args = new Array(Math.max($_len - 1, 0));for (var $_i = 1; $_i < $_len; ++$_i) {
                args[$_i - 1] = arguments[$_i];
            };
            promise._fulfill(args);
        }
        promise = null;
    };
}

module.exports = nodebackForPromise;

/***/ }),
/* 40 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.CancellationError = exports.CancellationToken = undefined;

var _bluebirdLst;

function _load_bluebirdLst() {
    return _bluebirdLst = _interopRequireDefault(__webpack_require__(2));
}

var _events;

function _load_events() {
    return _events = __webpack_require__(41);
}

function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
}

class CancellationToken extends (_events || _load_events()).EventEmitter {
    // babel cannot compile ... correctly for super calls
    constructor(parent) {
        super();
        this.parentCancelHandler = null;
        this._cancelled = false;
        if (parent != null) {
            this.parent = parent;
        }
    }
    get cancelled() {
        return this._cancelled || this._parent != null && this._parent.cancelled;
    }
    set parent(value) {
        this.removeParentCancelHandler();
        this._parent = value;
        this.parentCancelHandler = () => this.cancel();
        this._parent.onCancel(this.parentCancelHandler);
    }
    cancel() {
        this._cancelled = true;
        this.emit("cancel");
    }
    onCancel(handler) {
        if (this.cancelled) {
            handler();
        } else {
            this.once("cancel", handler);
        }
    }
    createPromise(callback) {
        if (this.cancelled) {
            return (_bluebirdLst || _load_bluebirdLst()).default.reject(new CancellationError());
        }
        let cancelHandler = null;
        return new (_bluebirdLst || _load_bluebirdLst()).default((resolve, reject) => {
            let addedCancelHandler = null;
            cancelHandler = () => {
                try {
                    if (addedCancelHandler != null) {
                        addedCancelHandler();
                        addedCancelHandler = null;
                    }
                } finally {
                    reject(new CancellationError());
                }
            };
            if (this.cancelled) {
                cancelHandler();
                return;
            }
            this.onCancel(cancelHandler);
            callback(resolve, reject, callback => {
                addedCancelHandler = callback;
            });
        }).finally(() => {
            if (cancelHandler != null) {
                this.removeListener("cancel", cancelHandler);
                cancelHandler = null;
            }
        });
    }
    removeParentCancelHandler() {
        const parent = this._parent;
        if (parent != null && this.parentCancelHandler != null) {
            parent.removeListener("cancel", this.parentCancelHandler);
            this.parentCancelHandler = null;
        }
    }
    dispose() {
        try {
            this.removeParentCancelHandler();
        } finally {
            this.removeAllListeners();
            this._parent = null;
        }
    }
}
exports.CancellationToken = CancellationToken;
class CancellationError extends Error {
    constructor() {
        super("Cancelled");
    }
}
exports.CancellationError = CancellationError; //# sourceMappingURL=CancellationToken.js.map

/***/ }),
/* 41 */
/***/ (function(module, exports) {

module.exports = require("events");

/***/ }),
/* 42 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.DigestTransform = exports.HttpExecutor = exports.HttpError = undefined;
exports.createHttpError = createHttpError;
exports.parseJson = parseJson;
exports.configureRequestOptionsFromUrl = configureRequestOptionsFromUrl;
exports.safeGetHeader = safeGetHeader;
exports.configureRequestOptions = configureRequestOptions;
exports.safeStringifyJson = safeStringifyJson;

var _crypto;

function _load_crypto() {
    return _crypto = __webpack_require__(28);
}

var _debug2 = _interopRequireDefault(__webpack_require__(100));

var _fsExtraP;

function _load_fsExtraP() {
    return _fsExtraP = __webpack_require__(9);
}

var _stream;

function _load_stream() {
    return _stream = __webpack_require__(19);
}

var _url;

function _load_url() {
    return _url = __webpack_require__(20);
}

var _CancellationToken;

function _load_CancellationToken() {
    return _CancellationToken = __webpack_require__(40);
}

var _index;

function _load_index() {
    return _index = __webpack_require__(3);
}

var _ProgressCallbackTransform;

function _load_ProgressCallbackTransform() {
    return _ProgressCallbackTransform = __webpack_require__(52);
}

function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
}

const debug = (0, _debug2.default)("electron-builder");
function createHttpError(response, description = null) {
    return new HttpError(response.statusCode || -1, `${response.statusCode} ${response.statusMessage}` + (description == null ? "" : "\n" + JSON.stringify(description, null, "  ")) + "\nHeaders: " + safeStringifyJson(response.headers), description);
}
const HTTP_STATUS_CODES = new Map([[429, "Too many requests"], [400, "Bad request"], [403, "Forbidden"], [404, "Not found"], [405, "Method not allowed"], [406, "Not acceptable"], [408, "Request timeout"], [413, "Request entity too large"], [500, "Internal server error"], [502, "Bad gateway"], [503, "Service unavailable"], [504, "Gateway timeout"], [505, "HTTP version not supported"]]);
class HttpError extends Error {
    constructor(statusCode, message = `HTTP error: ${HTTP_STATUS_CODES.get(statusCode) || statusCode}`, description = null) {
        super(message);
        this.statusCode = statusCode;
        this.description = description;
        this.name = "HttpError";
    }
}
exports.HttpError = HttpError;
function parseJson(result) {
    return result.then(it => it == null || it.length === 0 ? null : JSON.parse(it));
}
class HttpExecutor {
    constructor() {
        this.maxRedirects = 10;
    }
    request(options, cancellationToken = new (_CancellationToken || _load_CancellationToken()).CancellationToken(), data) {
        configureRequestOptions(options);
        const encodedData = data == null ? undefined : Buffer.from(JSON.stringify(data));
        if (encodedData != null) {
            options.method = "post";
            options.headers["Content-Type"] = "application/json";
            options.headers["Content-Length"] = encodedData.length;
        }
        return this.doApiRequest(options, cancellationToken, it => it.end(encodedData));
    }
    doApiRequest(options, cancellationToken, requestProcessor, redirectCount = 0) {
        if (debug.enabled) {
            debug(`Request: ${safeStringifyJson(options)}`);
        }
        return cancellationToken.createPromise((resolve, reject, onCancel) => {
            const request = this.doRequest(options, response => {
                try {
                    this.handleResponse(response, options, cancellationToken, resolve, reject, redirectCount, requestProcessor);
                } catch (e) {
                    reject(e);
                }
            });
            this.addErrorAndTimeoutHandlers(request, reject);
            this.addRedirectHandlers(request, options, reject, redirectCount, options => {
                this.doApiRequest(options, cancellationToken, requestProcessor, redirectCount).then(resolve).catch(reject);
            });
            requestProcessor(request, reject);
            onCancel(() => request.abort());
        });
    }
    // noinspection JSUnusedLocalSymbols
    addRedirectHandlers(request, options, reject, redirectCount, handler) {
        // not required for NodeJS
    }
    addErrorAndTimeoutHandlers(request, reject) {
        this.addTimeOutHandler(request, reject);
        request.on("error", reject);
        request.on("aborted", () => {
            reject(new Error("Request has been aborted by the server"));
        });
    }
    handleResponse(response, options, cancellationToken, resolve, reject, redirectCount, requestProcessor) {
        if (debug.enabled) {
            debug(`Response: ${response.statusCode} ${response.statusMessage}, request options: ${safeStringifyJson(options)}`);
        }
        // we handle any other >= 400 error on request end (read detailed message in the response body)
        if (response.statusCode === 404) {
            // error is clear, we don't need to read detailed error description
            reject(createHttpError(response, `method: ${options.method} url: ${options.protocol || "https:"}//${options.hostname}${options.path}

Please double check that your authentication token is correct. Due to security reasons actual status maybe not reported, but 404.
`));
            return;
        } else if (response.statusCode === 204) {
            // on DELETE request
            resolve();
            return;
        }
        const redirectUrl = safeGetHeader(response, "location");
        if (redirectUrl != null) {
            if (redirectCount > 10) {
                reject(new Error("Too many redirects (> 10)"));
                return;
            }
            this.doApiRequest(HttpExecutor.prepareRedirectUrlOptions(redirectUrl, options), cancellationToken, requestProcessor, redirectCount).then(resolve).catch(reject);
            return;
        }
        let data = "";
        response.setEncoding("utf8");
        response.on("data", chunk => data += chunk);
        response.on("end", () => {
            try {
                if (response.statusCode != null && response.statusCode >= 400) {
                    const contentType = safeGetHeader(response, "content-type");
                    const isJson = contentType != null && (Array.isArray(contentType) ? contentType.find(it => it.includes("json")) != null : contentType.includes("json"));
                    reject(createHttpError(response, isJson ? JSON.parse(data) : data));
                } else {
                    resolve(data.length === 0 ? null : data);
                }
            } catch (e) {
                reject(e);
            }
        });
    }
    doDownload(requestOptions, destination, redirectCount, options, callback, onCancel) {
        const request = this.doRequest(requestOptions, response => {
            if (response.statusCode >= 400) {
                callback(new Error(`Cannot download "${requestOptions.protocol || "https:"}//${requestOptions.hostname}${requestOptions.path}", status ${response.statusCode}: ${response.statusMessage}`));
                return;
            }
            const redirectUrl = safeGetHeader(response, "location");
            if (redirectUrl != null) {
                if (redirectCount < this.maxRedirects) {
                    this.doDownload(HttpExecutor.prepareRedirectUrlOptions(redirectUrl, requestOptions), destination, redirectCount++, options, callback, onCancel);
                } else {
                    callback(new Error(`Too many redirects (> ${this.maxRedirects})`));
                }
                return;
            }
            configurePipes(options, response, destination, callback, options.cancellationToken);
        });
        this.addErrorAndTimeoutHandlers(request, callback);
        this.addRedirectHandlers(request, requestOptions, callback, redirectCount, requestOptions => {
            this.doDownload(requestOptions, destination, redirectCount++, options, callback, onCancel);
        });
        onCancel(() => request.abort());
        request.end();
    }
    addTimeOutHandler(request, callback) {
        request.on("socket", socket => {
            socket.setTimeout(60 * 1000, () => {
                callback(new Error("Request timed out"));
                request.abort();
            });
        });
    }
    static prepareRedirectUrlOptions(redirectUrl, options) {
        const newOptions = configureRequestOptionsFromUrl(redirectUrl, Object.assign({}, options));
        if (newOptions.headers != null && newOptions.headers.Authorization != null && newOptions.headers.Authorization.startsWith("token")) {
            const parsedNewUrl = new (_url || _load_url()).URL(redirectUrl);
            if (parsedNewUrl.hostname.endsWith(".amazonaws.com")) {
                delete newOptions.headers.Authorization;
            }
        }
        return newOptions;
    }
}
exports.HttpExecutor = HttpExecutor;
function configureRequestOptionsFromUrl(url, options) {
    const parsedUrl = (0, (_url || _load_url()).parse)(url);
    options.protocol = parsedUrl.protocol;
    options.hostname = parsedUrl.hostname;
    if (parsedUrl.port == null) {
        if (options.port != null) {
            delete options.port;
        }
    } else {
        options.port = parsedUrl.port;
    }
    options.path = parsedUrl.path;
    return configureRequestOptions(options);
}
class DigestTransform extends (_stream || _load_stream()).Transform {
    constructor(expected, algorithm = "sha512", encoding = "base64") {
        super();
        this.expected = expected;
        this.algorithm = algorithm;
        this.encoding = encoding;
        this.isValidateOnEnd = true;
        this.digester = (0, (_crypto || _load_crypto()).createHash)(algorithm);
    }
    // noinspection JSUnusedGlobalSymbols
    get actual() {
        return this._actual;
    }
    // noinspection JSUnusedGlobalSymbols
    _transform(chunk, encoding, callback) {
        this.digester.update(chunk);
        callback(null, chunk);
    }
    // noinspection JSUnusedGlobalSymbols
    _flush(callback) {
        this._actual = this.digester.digest(this.encoding);
        if (this.isValidateOnEnd) {
            try {
                this.validate();
            } catch (e) {
                callback(e);
                return;
            }
        }
        callback(null);
    }
    validate() {
        if (this._actual == null) {
            throw (0, (_index || _load_index()).newError)("Not finished yet", "ERR_STREAM_NOT_FINISHED");
        }
        if (this._actual !== this.expected) {
            throw (0, (_index || _load_index()).newError)(`${this.algorithm} checksum mismatch, expected ${this.expected}, got ${this._actual}`, "ERR_CHECKSUM_MISMATCH");
        }
        return null;
    }
}
exports.DigestTransform = DigestTransform;
function checkSha2(sha2Header, sha2, callback) {
    if (sha2Header != null && sha2 != null) {
        // todo why bintray doesn't send this header always
        if (sha2Header == null) {
            callback(new Error("checksum is required, but server response doesn't contain X-Checksum-Sha2 header"));
            return false;
        } else if (sha2Header !== sha2) {
            callback(new Error(`checksum mismatch: expected ${sha2} but got ${sha2Header} (X-Checksum-Sha2 header)`));
            return false;
        }
    }
    return true;
}
function safeGetHeader(response, headerKey) {
    const value = response.headers[headerKey];
    if (value == null) {
        return null;
    } else if (Array.isArray(value)) {
        // electron API
        return value.length === 0 ? null : value[value.length - 1];
    } else {
        return value;
    }
}
function configurePipes(options, response, destination, callback, cancellationToken) {
    if (!checkSha2(safeGetHeader(response, "X-Checksum-Sha2"), options.sha2, callback)) {
        return;
    }
    const streams = [];
    if (options.onProgress != null) {
        const contentLength = safeGetHeader(response, "content-length");
        if (contentLength != null) {
            streams.push(new (_ProgressCallbackTransform || _load_ProgressCallbackTransform()).ProgressCallbackTransform(parseInt(contentLength, 10), options.cancellationToken, options.onProgress));
        }
    }
    const sha512 = options.sha512;
    if (sha512 != null) {
        streams.push(new DigestTransform(sha512, "sha512", sha512.length === 128 && !sha512.includes("+") && !sha512.includes("Z") && !sha512.includes("=") ? "hex" : "base64"));
    } else if (options.sha2 != null) {
        streams.push(new DigestTransform(options.sha2, "sha256", "hex"));
    }
    const fileOut = (0, (_fsExtraP || _load_fsExtraP()).createWriteStream)(destination);
    streams.push(fileOut);
    let lastStream = response;
    for (const stream of streams) {
        stream.on("error", error => {
            if (!cancellationToken.cancelled) {
                callback(error);
            }
        });
        lastStream = lastStream.pipe(stream);
    }
    fileOut.on("finish", () => {
        fileOut.close(callback);
    });
}
function configureRequestOptions(options, token, method) {
    if (method != null) {
        options.method = method;
    }
    let headers = options.headers;
    if (headers == null) {
        headers = {};
        options.headers = headers;
    }
    if (token != null) {
        headers.authorization = token.startsWith("Basic") ? token : `token ${token}`;
    }
    if (headers["User-Agent"] == null) {
        headers["User-Agent"] = "electron-builder";
    }
    if (method == null || method === "GET" || headers["Cache-Control"] == null) {
        headers["Cache-Control"] = "no-cache";
    }
    // do not specify for node (in any case we use https module)
    if (options.protocol == null && process.versions.electron != null) {
        options.protocol = "https:";
    }
    return options;
}
function safeStringifyJson(data, skippedNames) {
    return JSON.stringify(data, (name, value) => {
        if (name.endsWith("authorization") || name.endsWith("Password") || name.endsWith("PASSWORD") || name.endsWith("Token") || name.includes("password") || name.includes("token") || skippedNames != null && skippedNames.has(name)) {
            return "<stripped sensitive data>";
        }
        return value;
    }, 2);
}
//# sourceMappingURL=httpExecutor.js.map

/***/ }),
/* 43 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * This is the common logic for both the Node.js and web browser
 * implementations of `debug()`.
 *
 * Expose `debug()` as the module.
 */

exports = module.exports = createDebug.debug = createDebug['default'] = createDebug;
exports.coerce = coerce;
exports.disable = disable;
exports.enable = enable;
exports.enabled = enabled;
exports.humanize = __webpack_require__(102);

/**
 * Active `debug` instances.
 */
exports.instances = [];

/**
 * The currently active debug mode names, and names to skip.
 */

exports.names = [];
exports.skips = [];

/**
 * Map of special "%n" handling functions, for the debug "format" argument.
 *
 * Valid key names are a single, lower or upper-case letter, i.e. "n" and "N".
 */

exports.formatters = {};

/**
 * Select a color.
 * @param {String} namespace
 * @return {Number}
 * @api private
 */

function selectColor(namespace) {
  var hash = 0,
      i;

  for (i in namespace) {
    hash = (hash << 5) - hash + namespace.charCodeAt(i);
    hash |= 0; // Convert to 32bit integer
  }

  return exports.colors[Math.abs(hash) % exports.colors.length];
}

/**
 * Create a debugger with the given `namespace`.
 *
 * @param {String} namespace
 * @return {Function}
 * @api public
 */

function createDebug(namespace) {

  var prevTime;

  function debug() {
    // disabled?
    if (!debug.enabled) return;

    var self = debug;

    // set `diff` timestamp
    var curr = +new Date();
    var ms = curr - (prevTime || curr);
    self.diff = ms;
    self.prev = prevTime;
    self.curr = curr;
    prevTime = curr;

    // turn the `arguments` into a proper Array
    var args = new Array(arguments.length);
    for (var i = 0; i < args.length; i++) {
      args[i] = arguments[i];
    }

    args[0] = exports.coerce(args[0]);

    if ('string' !== typeof args[0]) {
      // anything else let's inspect with %O
      args.unshift('%O');
    }

    // apply any `formatters` transformations
    var index = 0;
    args[0] = args[0].replace(/%([a-zA-Z%])/g, function (match, format) {
      // if we encounter an escaped % then don't increase the array index
      if (match === '%%') return match;
      index++;
      var formatter = exports.formatters[format];
      if ('function' === typeof formatter) {
        var val = args[index];
        match = formatter.call(self, val);

        // now we need to remove `args[index]` since it's inlined in the `format`
        args.splice(index, 1);
        index--;
      }
      return match;
    });

    // apply env-specific formatting (colors, etc.)
    exports.formatArgs.call(self, args);

    var logFn = debug.log || exports.log || console.log.bind(console);
    logFn.apply(self, args);
  }

  debug.namespace = namespace;
  debug.enabled = exports.enabled(namespace);
  debug.useColors = exports.useColors();
  debug.color = selectColor(namespace);
  debug.destroy = destroy;

  // env-specific initialization logic for debug instances
  if ('function' === typeof exports.init) {
    exports.init(debug);
  }

  exports.instances.push(debug);

  return debug;
}

function destroy() {
  var index = exports.instances.indexOf(this);
  if (index !== -1) {
    exports.instances.splice(index, 1);
    return true;
  } else {
    return false;
  }
}

/**
 * Enables a debug mode by namespaces. This can include modes
 * separated by a colon and wildcards.
 *
 * @param {String} namespaces
 * @api public
 */

function enable(namespaces) {
  exports.save(namespaces);

  exports.names = [];
  exports.skips = [];

  var i;
  var split = (typeof namespaces === 'string' ? namespaces : '').split(/[\s,]+/);
  var len = split.length;

  for (i = 0; i < len; i++) {
    if (!split[i]) continue; // ignore empty strings
    namespaces = split[i].replace(/\*/g, '.*?');
    if (namespaces[0] === '-') {
      exports.skips.push(new RegExp('^' + namespaces.substr(1) + '$'));
    } else {
      exports.names.push(new RegExp('^' + namespaces + '$'));
    }
  }

  for (i = 0; i < exports.instances.length; i++) {
    var instance = exports.instances[i];
    instance.enabled = exports.enabled(instance.namespace);
  }
}

/**
 * Disable debug output.
 *
 * @api public
 */

function disable() {
  exports.enable('');
}

/**
 * Returns true if the given mode name is enabled, false otherwise.
 *
 * @param {String} name
 * @return {Boolean}
 * @api public
 */

function enabled(name) {
  if (name[name.length - 1] === '*') {
    return true;
  }
  var i, len;
  for (i = 0, len = exports.skips.length; i < len; i++) {
    if (exports.skips[i].test(name)) {
      return false;
    }
  }
  for (i = 0, len = exports.names.length; i < len; i++) {
    if (exports.names[i].test(name)) {
      return true;
    }
  }
  return false;
}

/**
 * Coerce `val`.
 *
 * @param {Mixed} val
 * @return {Mixed}
 * @api private
 */

function coerce(val) {
  if (val instanceof Error) return val.stack || val.message;
  return val;
}

/***/ }),
/* 44 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// This is adapted from https://github.com/normalize/mz
// Copyright (c) 2014-2016 Jonathan Ong me@jongleberry.com and Contributors
const u = __webpack_require__(6).fromCallback;
const fs = __webpack_require__(5);

const api = ['access', 'appendFile', 'chmod', 'chown', 'close', 'copyFile', 'fchmod', 'fchown', 'fdatasync', 'fstat', 'fsync', 'ftruncate', 'futimes', 'lchown', 'link', 'lstat', 'mkdir', 'mkdtemp', 'open', 'readFile', 'readdir', 'readlink', 'realpath', 'rename', 'rmdir', 'stat', 'symlink', 'truncate', 'unlink', 'utimes', 'writeFile'].filter(key => {
  // Some commands are not available on some systems. Ex:
  // fs.copyFile was added in Node.js v8.5.0
  // fs.mkdtemp was added in Node.js v5.10.0
  // fs.lchown is not available on at least some Linux
  return typeof fs[key] === 'function';
});

// Export all keys:
Object.keys(fs).forEach(key => {
  exports[key] = fs[key];
});

// Universalify async methods:
api.forEach(method => {
  exports[method] = u(fs[method]);
});

// We differ from mz/fs in that we still ship the old, broken, fs.exists()
// since we are a drop-in replacement for the native module
exports.exists = function (filename, callback) {
  if (typeof callback === 'function') {
    return fs.exists(filename, callback);
  }
  return new Promise(resolve => {
    return fs.exists(filename, resolve);
  });
};

// fs.read() & fs.write need special treatment due to multiple callback args

exports.read = function (fd, buffer, offset, length, position, callback) {
  if (typeof callback === 'function') {
    return fs.read(fd, buffer, offset, length, position, callback);
  }
  return new Promise((resolve, reject) => {
    fs.read(fd, buffer, offset, length, position, (err, bytesRead, buffer) => {
      if (err) return reject(err);
      resolve({ bytesRead, buffer });
    });
  });
};

// Function signature can be
// fs.write(fd, buffer[, offset[, length[, position]]], callback)
// OR
// fs.write(fd, string[, position[, encoding]], callback)
// so we need to handle both cases
exports.write = function (fd, buffer, a, b, c, callback) {
  if (typeof arguments[arguments.length - 1] === 'function') {
    return fs.write(fd, buffer, a, b, c, callback);
  }

  // Check for old, depricated fs.write(fd, string[, position[, encoding]], callback)
  if (typeof buffer === 'string') {
    return new Promise((resolve, reject) => {
      fs.write(fd, buffer, a, b, (err, bytesWritten, buffer) => {
        if (err) return reject(err);
        resolve({ bytesWritten, buffer });
      });
    });
  }

  return new Promise((resolve, reject) => {
    fs.write(fd, buffer, a, b, c, (err, bytesWritten, buffer) => {
      if (err) return reject(err);
      resolve({ bytesWritten, buffer });
    });
  });
};

/***/ }),
/* 45 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var fs = __webpack_require__(12);

module.exports = clone(fs);

function clone(obj) {
  if (obj === null || typeof obj !== 'object') return obj;

  if (obj instanceof Object) var copy = { __proto__: obj.__proto__ };else var copy = Object.create(null);

  Object.getOwnPropertyNames(obj).forEach(function (key) {
    Object.defineProperty(copy, key, Object.getOwnPropertyDescriptor(obj, key));
  });

  return copy;
}

/***/ }),
/* 46 */
/***/ (function(module, exports) {

module.exports = require("assert");

/***/ }),
/* 47 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const fs = __webpack_require__(5);
const path = __webpack_require__(0);
const mkdirp = __webpack_require__(7).mkdirs;
const pathExists = __webpack_require__(13).pathExists;
const utimes = __webpack_require__(49).utimesMillis;

const notExist = Symbol('notExist');
const existsReg = Symbol('existsReg');

function copy(src, dest, opts, cb) {
  if (typeof opts === 'function' && !cb) {
    cb = opts;
    opts = {};
  } else if (typeof opts === 'function') {
    opts = { filter: opts };
  }

  cb = cb || function () {};
  opts = opts || {};

  opts.clobber = 'clobber' in opts ? !!opts.clobber : true; // default to true for now
  opts.overwrite = 'overwrite' in opts ? !!opts.overwrite : opts.clobber; // overwrite falls back to clobber

  // Warn about using preserveTimestamps on 32-bit node
  if (opts.preserveTimestamps && process.arch === 'ia32') {
    console.warn(`fs-extra: Using the preserveTimestamps option in 32-bit node is not recommended;\n
    see https://github.com/jprichardson/node-fs-extra/issues/269`);
  }

  src = path.resolve(src);
  dest = path.resolve(dest);

  // don't allow src and dest to be the same
  if (src === dest) return cb(new Error('Source and destination must not be the same.'));

  if (opts.filter) return handleFilter(checkParentDir, src, dest, opts, cb);
  return checkParentDir(src, dest, opts, cb);
}

function checkParentDir(src, dest, opts, cb) {
  const destParent = path.dirname(dest);
  pathExists(destParent, (err, dirExists) => {
    if (err) return cb(err);
    if (dirExists) return startCopy(src, dest, opts, cb);
    mkdirp(destParent, err => {
      if (err) return cb(err);
      return startCopy(src, dest, opts, cb);
    });
  });
}

function startCopy(src, dest, opts, cb) {
  if (opts.filter) return handleFilter(getStats, src, dest, opts, cb);
  return getStats(src, dest, opts, cb);
}

function handleFilter(onInclude, src, dest, opts, cb) {
  Promise.resolve(opts.filter(src, dest)).then(include => {
    if (include) return onInclude(src, dest, opts, cb);
    return cb();
  }, error => cb(error));
}

function getStats(src, dest, opts, cb) {
  const stat = opts.dereference ? fs.stat : fs.lstat;
  stat(src, (err, st) => {
    if (err) return cb(err);

    if (st.isDirectory()) return onDir(st, src, dest, opts, cb);else if (st.isFile() || st.isCharacterDevice() || st.isBlockDevice()) return onFile(st, src, dest, opts, cb);else if (st.isSymbolicLink()) return onLink(src, dest, opts, cb);
  });
}

function onFile(srcStat, src, dest, opts, cb) {
  checkDest(dest, (err, resolvedPath) => {
    if (err) return cb(err);
    if (resolvedPath === notExist) {
      return copyFile(srcStat, src, dest, opts, cb);
    } else if (resolvedPath === existsReg) {
      return mayCopyFile(srcStat, src, dest, opts, cb);
    } else {
      if (src === resolvedPath) return cb();
      return mayCopyFile(srcStat, src, dest, opts, cb);
    }
  });
}

function mayCopyFile(srcStat, src, dest, opts, cb) {
  if (opts.overwrite) {
    fs.unlink(dest, err => {
      if (err) return cb(err);
      return copyFile(srcStat, src, dest, opts, cb);
    });
  } else if (opts.errorOnExist) {
    return cb(new Error(`'${dest}' already exists`));
  } else return cb();
}

function copyFile(srcStat, src, dest, opts, cb) {
  if (typeof fs.copyFile === 'function') {
    return fs.copyFile(src, dest, err => {
      if (err) return cb(err);
      return setDestModeAndTimestamps(srcStat, dest, opts, cb);
    });
  }
  return copyFileFallback(srcStat, src, dest, opts, cb);
}

function copyFileFallback(srcStat, src, dest, opts, cb) {
  const rs = fs.createReadStream(src);
  rs.on('error', err => cb(err)).once('open', () => {
    const ws = fs.createWriteStream(dest, { mode: srcStat.mode });
    ws.on('error', err => cb(err)).on('open', () => rs.pipe(ws)).once('close', () => setDestModeAndTimestamps(srcStat, dest, opts, cb));
  });
}

function setDestModeAndTimestamps(srcStat, dest, opts, cb) {
  fs.chmod(dest, srcStat.mode, err => {
    if (err) return cb(err);
    if (opts.preserveTimestamps) {
      return utimes(dest, srcStat.atime, srcStat.mtime, cb);
    }
    return cb();
  });
}

function onDir(srcStat, src, dest, opts, cb) {
  checkDest(dest, (err, resolvedPath) => {
    if (err) return cb(err);
    if (resolvedPath === notExist) {
      if (isSrcSubdir(src, dest)) {
        return cb(new Error(`Cannot copy '${src}' to a subdirectory of itself, '${dest}'.`));
      }
      return mkDirAndCopy(srcStat, src, dest, opts, cb);
    } else if (resolvedPath === existsReg) {
      if (isSrcSubdir(src, dest)) {
        return cb(new Error(`Cannot copy '${src}' to a subdirectory of itself, '${dest}'.`));
      }
      return mayCopyDir(src, dest, opts, cb);
    } else {
      if (src === resolvedPath) return cb();
      return copyDir(src, dest, opts, cb);
    }
  });
}

function mayCopyDir(src, dest, opts, cb) {
  fs.stat(dest, (err, st) => {
    if (err) return cb(err);
    if (!st.isDirectory()) {
      return cb(new Error(`Cannot overwrite non-directory '${dest}' with directory '${src}'.`));
    }
    return copyDir(src, dest, opts, cb);
  });
}

function mkDirAndCopy(srcStat, src, dest, opts, cb) {
  fs.mkdir(dest, srcStat.mode, err => {
    if (err) return cb(err);
    fs.chmod(dest, srcStat.mode, err => {
      if (err) return cb(err);
      return copyDir(src, dest, opts, cb);
    });
  });
}

function copyDir(src, dest, opts, cb) {
  fs.readdir(src, (err, items) => {
    if (err) return cb(err);
    return copyDirItems(items, src, dest, opts, cb);
  });
}

function copyDirItems(items, src, dest, opts, cb) {
  const item = items.pop();
  if (!item) return cb();
  startCopy(path.join(src, item), path.join(dest, item), opts, err => {
    if (err) return cb(err);
    return copyDirItems(items, src, dest, opts, cb);
  });
}

function onLink(src, dest, opts, cb) {
  fs.readlink(src, (err, resolvedSrcPath) => {
    if (err) return cb(err);

    if (opts.dereference) {
      resolvedSrcPath = path.resolve(process.cwd(), resolvedSrcPath);
    }

    checkDest(dest, (err, resolvedDestPath) => {
      if (err) return cb(err);

      if (resolvedDestPath === notExist || resolvedDestPath === existsReg) {
        // if dest already exists, fs throws error anyway,
        // so no need to guard against it here.
        return fs.symlink(resolvedSrcPath, dest, cb);
      } else {
        if (opts.dereference) {
          resolvedDestPath = path.resolve(process.cwd(), resolvedDestPath);
        }
        if (resolvedDestPath === resolvedSrcPath) return cb();

        // prevent copy if src is a subdir of dest since unlinking
        // dest in this case would result in removing src contents
        // and therefore a broken symlink would be created.
        fs.stat(dest, (err, st) => {
          if (err) return cb(err);
          if (st.isDirectory() && isSrcSubdir(resolvedDestPath, resolvedSrcPath)) {
            return cb(new Error(`Cannot overwrite '${resolvedDestPath}' with '${resolvedSrcPath}'.`));
          }
          return copyLink(resolvedSrcPath, dest, cb);
        });
      }
    });
  });
}

function copyLink(resolvedSrcPath, dest, cb) {
  fs.unlink(dest, err => {
    if (err) return cb(err);
    return fs.symlink(resolvedSrcPath, dest, cb);
  });
}

// check if dest exists and/or is a symlink
function checkDest(dest, cb) {
  fs.readlink(dest, (err, resolvedPath) => {
    if (err) {
      if (err.code === 'ENOENT') return cb(null, notExist);

      // dest exists and is a regular file or directory, Windows may throw UNKNOWN error.
      if (err.code === 'EINVAL' || err.code === 'UNKNOWN') return cb(null, existsReg);

      return cb(err);
    }
    return cb(null, resolvedPath); // dest exists and is a symlink
  });
}

// return true if dest is a subdir of src, otherwise false.
// extract dest base dir and check if that is the same as src basename
function isSrcSubdir(src, dest) {
  const baseDir = dest.split(path.dirname(src) + path.sep)[1];
  if (baseDir) {
    const destBasename = baseDir.split(path.sep)[0];
    if (destBasename) {
      return src !== dest && dest.indexOf(src) > -1 && destBasename === path.basename(src);
    }
    return false;
  }
  return false;
}

module.exports = copy;

/***/ }),
/* 48 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const path = __webpack_require__(0);

// get drive on windows
function getRootPath(p) {
  p = path.normalize(path.resolve(p)).split(path.sep);
  if (p.length > 0) return p[0];
  return null;
}

// http://stackoverflow.com/a/62888/10333 contains more accurate
// TODO: expand to include the rest
const INVALID_PATH_CHARS = /[<>:"|?*]/;

function invalidWin32Path(p) {
  const rp = getRootPath(p);
  p = p.replace(rp, '');
  return INVALID_PATH_CHARS.test(p);
}

module.exports = {
  getRootPath,
  invalidWin32Path
};

/***/ }),
/* 49 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const fs = __webpack_require__(5);
const os = __webpack_require__(15);
const path = __webpack_require__(0);

// HFS, ext{2,3}, FAT do not, Node.js v0.10 does not
function hasMillisResSync() {
  let tmpfile = path.join('millis-test-sync' + Date.now().toString() + Math.random().toString().slice(2));
  tmpfile = path.join(os.tmpdir(), tmpfile);

  // 550 millis past UNIX epoch
  const d = new Date(1435410243862);
  fs.writeFileSync(tmpfile, 'https://github.com/jprichardson/node-fs-extra/pull/141');
  const fd = fs.openSync(tmpfile, 'r+');
  fs.futimesSync(fd, d, d);
  fs.closeSync(fd);
  return fs.statSync(tmpfile).mtime > 1435410243000;
}

function hasMillisRes(callback) {
  let tmpfile = path.join('millis-test' + Date.now().toString() + Math.random().toString().slice(2));
  tmpfile = path.join(os.tmpdir(), tmpfile);

  // 550 millis past UNIX epoch
  const d = new Date(1435410243862);
  fs.writeFile(tmpfile, 'https://github.com/jprichardson/node-fs-extra/pull/141', err => {
    if (err) return callback(err);
    fs.open(tmpfile, 'r+', (err, fd) => {
      if (err) return callback(err);
      fs.futimes(fd, d, d, err => {
        if (err) return callback(err);
        fs.close(fd, err => {
          if (err) return callback(err);
          fs.stat(tmpfile, (err, stats) => {
            if (err) return callback(err);
            callback(null, stats.mtime > 1435410243000);
          });
        });
      });
    });
  });
}

function timeRemoveMillis(timestamp) {
  if (typeof timestamp === 'number') {
    return Math.floor(timestamp / 1000) * 1000;
  } else if (timestamp instanceof Date) {
    return new Date(Math.floor(timestamp.getTime() / 1000) * 1000);
  } else {
    throw new Error('fs-extra: timeRemoveMillis() unknown parameter type');
  }
}

function utimesMillis(path, atime, mtime, callback) {
  // if (!HAS_MILLIS_RES) return fs.utimes(path, atime, mtime, callback)
  fs.open(path, 'r+', (err, fd) => {
    if (err) return callback(err);
    fs.futimes(fd, atime, mtime, futimesErr => {
      fs.close(fd, closeErr => {
        if (callback) callback(futimesErr || closeErr);
      });
    });
  });
}

function utimesMillisSync(path, atime, mtime) {
  const fd = fs.openSync(path, 'r+');
  fs.futimesSync(fd, atime, mtime);
  return fs.closeSync(fd);
}

module.exports = {
  hasMillisRes,
  hasMillisResSync,
  timeRemoveMillis,
  utimesMillis,
  utimesMillisSync
};

/***/ }),
/* 50 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = {
  copySync: __webpack_require__(115)
};

/***/ }),
/* 51 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/* eslint-disable node/no-deprecated-api */
module.exports = function (size) {
  if (typeof Buffer.allocUnsafe === 'function') {
    try {
      return Buffer.allocUnsafe(size);
    } catch (e) {
      return new Buffer(size);
    }
  }
  return new Buffer(size);
};

/***/ }),
/* 52 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.ProgressCallbackTransform = undefined;

var _stream;

function _load_stream() {
    return _stream = __webpack_require__(19);
}

class ProgressCallbackTransform extends (_stream || _load_stream()).Transform {
    constructor(total, cancellationToken, onProgress) {
        super();
        this.total = total;
        this.cancellationToken = cancellationToken;
        this.onProgress = onProgress;
        this.start = Date.now();
        this.transferred = 0;
        this.delta = 0;
        this.nextUpdate = this.start + 1000;
    }
    _transform(chunk, encoding, callback) {
        if (this.cancellationToken.cancelled) {
            callback(new Error("Cancelled"), null);
            return;
        }
        this.transferred += chunk.length;
        this.delta += chunk.length;
        const now = Date.now();
        if (now >= this.nextUpdate && this.transferred !== this.total /* will be emitted on _flush */) {
                this.nextUpdate = now + 1000;
                this.onProgress({
                    total: this.total,
                    delta: this.delta,
                    transferred: this.transferred,
                    percent: this.transferred / this.total * 100,
                    bytesPerSecond: Math.round(this.transferred / ((now - this.start) / 1000))
                });
                this.delta = 0;
            }
        callback(null, chunk);
    }
    _flush(callback) {
        if (this.cancellationToken.cancelled) {
            callback(new Error("Cancelled"));
            return;
        }
        this.onProgress({
            total: this.total,
            delta: this.delta,
            transferred: this.total,
            percent: 100,
            bytesPerSecond: Math.round(this.transferred / ((Date.now() - this.start) / 1000))
        });
        this.delta = 0;
        callback(null);
    }
}
exports.ProgressCallbackTransform = ProgressCallbackTransform; //# sourceMappingURL=ProgressCallbackTransform.js.map

/***/ }),
/* 53 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Standard YAML's Core schema.
// http://www.yaml.org/spec/1.2/spec.html#id2804923
//
// NOTE: JS-YAML does not support schema-specific tag resolution restrictions.
// So, Core schema has no distinctions from JSON schema is JS-YAML.




var Schema = __webpack_require__(18);

module.exports = new Schema({
  include: [__webpack_require__(54)]
});

/***/ }),
/* 54 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Standard YAML's JSON schema.
// http://www.yaml.org/spec/1.2/spec.html#id2803231
//
// NOTE: JS-YAML does not support schema-specific tag resolution restrictions.
// So, this schema is not such strict as defined in the YAML specification.
// It allows numbers in binary notaion, use `Null` and `NULL` as `null`, etc.




var Schema = __webpack_require__(18);

module.exports = new Schema({
  include: [__webpack_require__(32)],
  implicit: [__webpack_require__(143), __webpack_require__(144), __webpack_require__(145), __webpack_require__(146)]
});

/***/ }),
/* 55 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports = module.exports = SemVer;

// The debug function is excluded entirely from the minified version.
/* nomin */var debug;
/* nomin */if (typeof process === 'object' &&
/* nomin */process.env &&
/* nomin */process.env.NODE_DEBUG &&
/* nomin *//\bsemver\b/i.test(process.env.NODE_DEBUG))
  /* nomin */debug = function () {
    /* nomin */var args = Array.prototype.slice.call(arguments, 0);
    /* nomin */args.unshift('SEMVER');
    /* nomin */console.log.apply(console, args);
    /* nomin */
  };
  /* nomin */else
  /* nomin */debug = function () {};

// Note: this is the semver.org version of the spec that it implements
// Not necessarily the package version of this code.
exports.SEMVER_SPEC_VERSION = '2.0.0';

var MAX_LENGTH = 256;
var MAX_SAFE_INTEGER = Number.MAX_SAFE_INTEGER || 9007199254740991;

// The actual regexps go on exports.re
var re = exports.re = [];
var src = exports.src = [];
var R = 0;

// The following Regular Expressions can be used for tokenizing,
// validating, and parsing SemVer version strings.

// ## Numeric Identifier
// A single `0`, or a non-zero digit followed by zero or more digits.

var NUMERICIDENTIFIER = R++;
src[NUMERICIDENTIFIER] = '0|[1-9]\\d*';
var NUMERICIDENTIFIERLOOSE = R++;
src[NUMERICIDENTIFIERLOOSE] = '[0-9]+';

// ## Non-numeric Identifier
// Zero or more digits, followed by a letter or hyphen, and then zero or
// more letters, digits, or hyphens.

var NONNUMERICIDENTIFIER = R++;
src[NONNUMERICIDENTIFIER] = '\\d*[a-zA-Z-][a-zA-Z0-9-]*';

// ## Main Version
// Three dot-separated numeric identifiers.

var MAINVERSION = R++;
src[MAINVERSION] = '(' + src[NUMERICIDENTIFIER] + ')\\.' + '(' + src[NUMERICIDENTIFIER] + ')\\.' + '(' + src[NUMERICIDENTIFIER] + ')';

var MAINVERSIONLOOSE = R++;
src[MAINVERSIONLOOSE] = '(' + src[NUMERICIDENTIFIERLOOSE] + ')\\.' + '(' + src[NUMERICIDENTIFIERLOOSE] + ')\\.' + '(' + src[NUMERICIDENTIFIERLOOSE] + ')';

// ## Pre-release Version Identifier
// A numeric identifier, or a non-numeric identifier.

var PRERELEASEIDENTIFIER = R++;
src[PRERELEASEIDENTIFIER] = '(?:' + src[NUMERICIDENTIFIER] + '|' + src[NONNUMERICIDENTIFIER] + ')';

var PRERELEASEIDENTIFIERLOOSE = R++;
src[PRERELEASEIDENTIFIERLOOSE] = '(?:' + src[NUMERICIDENTIFIERLOOSE] + '|' + src[NONNUMERICIDENTIFIER] + ')';

// ## Pre-release Version
// Hyphen, followed by one or more dot-separated pre-release version
// identifiers.

var PRERELEASE = R++;
src[PRERELEASE] = '(?:-(' + src[PRERELEASEIDENTIFIER] + '(?:\\.' + src[PRERELEASEIDENTIFIER] + ')*))';

var PRERELEASELOOSE = R++;
src[PRERELEASELOOSE] = '(?:-?(' + src[PRERELEASEIDENTIFIERLOOSE] + '(?:\\.' + src[PRERELEASEIDENTIFIERLOOSE] + ')*))';

// ## Build Metadata Identifier
// Any combination of digits, letters, or hyphens.

var BUILDIDENTIFIER = R++;
src[BUILDIDENTIFIER] = '[0-9A-Za-z-]+';

// ## Build Metadata
// Plus sign, followed by one or more period-separated build metadata
// identifiers.

var BUILD = R++;
src[BUILD] = '(?:\\+(' + src[BUILDIDENTIFIER] + '(?:\\.' + src[BUILDIDENTIFIER] + ')*))';

// ## Full Version String
// A main version, followed optionally by a pre-release version and
// build metadata.

// Note that the only major, minor, patch, and pre-release sections of
// the version string are capturing groups.  The build metadata is not a
// capturing group, because it should not ever be used in version
// comparison.

var FULL = R++;
var FULLPLAIN = 'v?' + src[MAINVERSION] + src[PRERELEASE] + '?' + src[BUILD] + '?';

src[FULL] = '^' + FULLPLAIN + '$';

// like full, but allows v1.2.3 and =1.2.3, which people do sometimes.
// also, 1.0.0alpha1 (prerelease without the hyphen) which is pretty
// common in the npm registry.
var LOOSEPLAIN = '[v=\\s]*' + src[MAINVERSIONLOOSE] + src[PRERELEASELOOSE] + '?' + src[BUILD] + '?';

var LOOSE = R++;
src[LOOSE] = '^' + LOOSEPLAIN + '$';

var GTLT = R++;
src[GTLT] = '((?:<|>)?=?)';

// Something like "2.*" or "1.2.x".
// Note that "x.x" is a valid xRange identifer, meaning "any version"
// Only the first item is strictly required.
var XRANGEIDENTIFIERLOOSE = R++;
src[XRANGEIDENTIFIERLOOSE] = src[NUMERICIDENTIFIERLOOSE] + '|x|X|\\*';
var XRANGEIDENTIFIER = R++;
src[XRANGEIDENTIFIER] = src[NUMERICIDENTIFIER] + '|x|X|\\*';

var XRANGEPLAIN = R++;
src[XRANGEPLAIN] = '[v=\\s]*(' + src[XRANGEIDENTIFIER] + ')' + '(?:\\.(' + src[XRANGEIDENTIFIER] + ')' + '(?:\\.(' + src[XRANGEIDENTIFIER] + ')' + '(?:' + src[PRERELEASE] + ')?' + src[BUILD] + '?' + ')?)?';

var XRANGEPLAINLOOSE = R++;
src[XRANGEPLAINLOOSE] = '[v=\\s]*(' + src[XRANGEIDENTIFIERLOOSE] + ')' + '(?:\\.(' + src[XRANGEIDENTIFIERLOOSE] + ')' + '(?:\\.(' + src[XRANGEIDENTIFIERLOOSE] + ')' + '(?:' + src[PRERELEASELOOSE] + ')?' + src[BUILD] + '?' + ')?)?';

var XRANGE = R++;
src[XRANGE] = '^' + src[GTLT] + '\\s*' + src[XRANGEPLAIN] + '$';
var XRANGELOOSE = R++;
src[XRANGELOOSE] = '^' + src[GTLT] + '\\s*' + src[XRANGEPLAINLOOSE] + '$';

// Tilde ranges.
// Meaning is "reasonably at or greater than"
var LONETILDE = R++;
src[LONETILDE] = '(?:~>?)';

var TILDETRIM = R++;
src[TILDETRIM] = '(\\s*)' + src[LONETILDE] + '\\s+';
re[TILDETRIM] = new RegExp(src[TILDETRIM], 'g');
var tildeTrimReplace = '$1~';

var TILDE = R++;
src[TILDE] = '^' + src[LONETILDE] + src[XRANGEPLAIN] + '$';
var TILDELOOSE = R++;
src[TILDELOOSE] = '^' + src[LONETILDE] + src[XRANGEPLAINLOOSE] + '$';

// Caret ranges.
// Meaning is "at least and backwards compatible with"
var LONECARET = R++;
src[LONECARET] = '(?:\\^)';

var CARETTRIM = R++;
src[CARETTRIM] = '(\\s*)' + src[LONECARET] + '\\s+';
re[CARETTRIM] = new RegExp(src[CARETTRIM], 'g');
var caretTrimReplace = '$1^';

var CARET = R++;
src[CARET] = '^' + src[LONECARET] + src[XRANGEPLAIN] + '$';
var CARETLOOSE = R++;
src[CARETLOOSE] = '^' + src[LONECARET] + src[XRANGEPLAINLOOSE] + '$';

// A simple gt/lt/eq thing, or just "" to indicate "any version"
var COMPARATORLOOSE = R++;
src[COMPARATORLOOSE] = '^' + src[GTLT] + '\\s*(' + LOOSEPLAIN + ')$|^$';
var COMPARATOR = R++;
src[COMPARATOR] = '^' + src[GTLT] + '\\s*(' + FULLPLAIN + ')$|^$';

// An expression to strip any whitespace between the gtlt and the thing
// it modifies, so that `> 1.2.3` ==> `>1.2.3`
var COMPARATORTRIM = R++;
src[COMPARATORTRIM] = '(\\s*)' + src[GTLT] + '\\s*(' + LOOSEPLAIN + '|' + src[XRANGEPLAIN] + ')';

// this one has to use the /g flag
re[COMPARATORTRIM] = new RegExp(src[COMPARATORTRIM], 'g');
var comparatorTrimReplace = '$1$2$3';

// Something like `1.2.3 - 1.2.4`
// Note that these all use the loose form, because they'll be
// checked against either the strict or loose comparator form
// later.
var HYPHENRANGE = R++;
src[HYPHENRANGE] = '^\\s*(' + src[XRANGEPLAIN] + ')' + '\\s+-\\s+' + '(' + src[XRANGEPLAIN] + ')' + '\\s*$';

var HYPHENRANGELOOSE = R++;
src[HYPHENRANGELOOSE] = '^\\s*(' + src[XRANGEPLAINLOOSE] + ')' + '\\s+-\\s+' + '(' + src[XRANGEPLAINLOOSE] + ')' + '\\s*$';

// Star ranges basically just allow anything at all.
var STAR = R++;
src[STAR] = '(<|>)?=?\\s*\\*';

// Compile to actual regexp objects.
// All are flag-free, unless they were created above with a flag.
for (var i = 0; i < R; i++) {
  debug(i, src[i]);
  if (!re[i]) re[i] = new RegExp(src[i]);
}

exports.parse = parse;
function parse(version, loose) {
  if (version instanceof SemVer) return version;

  if (typeof version !== 'string') return null;

  if (version.length > MAX_LENGTH) return null;

  var r = loose ? re[LOOSE] : re[FULL];
  if (!r.test(version)) return null;

  try {
    return new SemVer(version, loose);
  } catch (er) {
    return null;
  }
}

exports.valid = valid;
function valid(version, loose) {
  var v = parse(version, loose);
  return v ? v.version : null;
}

exports.clean = clean;
function clean(version, loose) {
  var s = parse(version.trim().replace(/^[=v]+/, ''), loose);
  return s ? s.version : null;
}

exports.SemVer = SemVer;

function SemVer(version, loose) {
  if (version instanceof SemVer) {
    if (version.loose === loose) return version;else version = version.version;
  } else if (typeof version !== 'string') {
    throw new TypeError('Invalid Version: ' + version);
  }

  if (version.length > MAX_LENGTH) throw new TypeError('version is longer than ' + MAX_LENGTH + ' characters');

  if (!(this instanceof SemVer)) return new SemVer(version, loose);

  debug('SemVer', version, loose);
  this.loose = loose;
  var m = version.trim().match(loose ? re[LOOSE] : re[FULL]);

  if (!m) throw new TypeError('Invalid Version: ' + version);

  this.raw = version;

  // these are actually numbers
  this.major = +m[1];
  this.minor = +m[2];
  this.patch = +m[3];

  if (this.major > MAX_SAFE_INTEGER || this.major < 0) throw new TypeError('Invalid major version');

  if (this.minor > MAX_SAFE_INTEGER || this.minor < 0) throw new TypeError('Invalid minor version');

  if (this.patch > MAX_SAFE_INTEGER || this.patch < 0) throw new TypeError('Invalid patch version');

  // numberify any prerelease numeric ids
  if (!m[4]) this.prerelease = [];else this.prerelease = m[4].split('.').map(function (id) {
    if (/^[0-9]+$/.test(id)) {
      var num = +id;
      if (num >= 0 && num < MAX_SAFE_INTEGER) return num;
    }
    return id;
  });

  this.build = m[5] ? m[5].split('.') : [];
  this.format();
}

SemVer.prototype.format = function () {
  this.version = this.major + '.' + this.minor + '.' + this.patch;
  if (this.prerelease.length) this.version += '-' + this.prerelease.join('.');
  return this.version;
};

SemVer.prototype.toString = function () {
  return this.version;
};

SemVer.prototype.compare = function (other) {
  debug('SemVer.compare', this.version, this.loose, other);
  if (!(other instanceof SemVer)) other = new SemVer(other, this.loose);

  return this.compareMain(other) || this.comparePre(other);
};

SemVer.prototype.compareMain = function (other) {
  if (!(other instanceof SemVer)) other = new SemVer(other, this.loose);

  return compareIdentifiers(this.major, other.major) || compareIdentifiers(this.minor, other.minor) || compareIdentifiers(this.patch, other.patch);
};

SemVer.prototype.comparePre = function (other) {
  if (!(other instanceof SemVer)) other = new SemVer(other, this.loose);

  // NOT having a prerelease is > having one
  if (this.prerelease.length && !other.prerelease.length) return -1;else if (!this.prerelease.length && other.prerelease.length) return 1;else if (!this.prerelease.length && !other.prerelease.length) return 0;

  var i = 0;
  do {
    var a = this.prerelease[i];
    var b = other.prerelease[i];
    debug('prerelease compare', i, a, b);
    if (a === undefined && b === undefined) return 0;else if (b === undefined) return 1;else if (a === undefined) return -1;else if (a === b) continue;else return compareIdentifiers(a, b);
  } while (++i);
};

// preminor will bump the version up to the next minor release, and immediately
// down to pre-release. premajor and prepatch work the same way.
SemVer.prototype.inc = function (release, identifier) {
  switch (release) {
    case 'premajor':
      this.prerelease.length = 0;
      this.patch = 0;
      this.minor = 0;
      this.major++;
      this.inc('pre', identifier);
      break;
    case 'preminor':
      this.prerelease.length = 0;
      this.patch = 0;
      this.minor++;
      this.inc('pre', identifier);
      break;
    case 'prepatch':
      // If this is already a prerelease, it will bump to the next version
      // drop any prereleases that might already exist, since they are not
      // relevant at this point.
      this.prerelease.length = 0;
      this.inc('patch', identifier);
      this.inc('pre', identifier);
      break;
    // If the input is a non-prerelease version, this acts the same as
    // prepatch.
    case 'prerelease':
      if (this.prerelease.length === 0) this.inc('patch', identifier);
      this.inc('pre', identifier);
      break;

    case 'major':
      // If this is a pre-major version, bump up to the same major version.
      // Otherwise increment major.
      // 1.0.0-5 bumps to 1.0.0
      // 1.1.0 bumps to 2.0.0
      if (this.minor !== 0 || this.patch !== 0 || this.prerelease.length === 0) this.major++;
      this.minor = 0;
      this.patch = 0;
      this.prerelease = [];
      break;
    case 'minor':
      // If this is a pre-minor version, bump up to the same minor version.
      // Otherwise increment minor.
      // 1.2.0-5 bumps to 1.2.0
      // 1.2.1 bumps to 1.3.0
      if (this.patch !== 0 || this.prerelease.length === 0) this.minor++;
      this.patch = 0;
      this.prerelease = [];
      break;
    case 'patch':
      // If this is not a pre-release version, it will increment the patch.
      // If it is a pre-release it will bump up to the same patch version.
      // 1.2.0-5 patches to 1.2.0
      // 1.2.0 patches to 1.2.1
      if (this.prerelease.length === 0) this.patch++;
      this.prerelease = [];
      break;
    // This probably shouldn't be used publicly.
    // 1.0.0 "pre" would become 1.0.0-0 which is the wrong direction.
    case 'pre':
      if (this.prerelease.length === 0) this.prerelease = [0];else {
        var i = this.prerelease.length;
        while (--i >= 0) {
          if (typeof this.prerelease[i] === 'number') {
            this.prerelease[i]++;
            i = -2;
          }
        }
        if (i === -1) // didn't increment anything
          this.prerelease.push(0);
      }
      if (identifier) {
        // 1.2.0-beta.1 bumps to 1.2.0-beta.2,
        // 1.2.0-beta.fooblz or 1.2.0-beta bumps to 1.2.0-beta.0
        if (this.prerelease[0] === identifier) {
          if (isNaN(this.prerelease[1])) this.prerelease = [identifier, 0];
        } else this.prerelease = [identifier, 0];
      }
      break;

    default:
      throw new Error('invalid increment argument: ' + release);
  }
  this.format();
  this.raw = this.version;
  return this;
};

exports.inc = inc;
function inc(version, release, loose, identifier) {
  if (typeof loose === 'string') {
    identifier = loose;
    loose = undefined;
  }

  try {
    return new SemVer(version, loose).inc(release, identifier).version;
  } catch (er) {
    return null;
  }
}

exports.diff = diff;
function diff(version1, version2) {
  if (eq(version1, version2)) {
    return null;
  } else {
    var v1 = parse(version1);
    var v2 = parse(version2);
    if (v1.prerelease.length || v2.prerelease.length) {
      for (var key in v1) {
        if (key === 'major' || key === 'minor' || key === 'patch') {
          if (v1[key] !== v2[key]) {
            return 'pre' + key;
          }
        }
      }
      return 'prerelease';
    }
    for (var key in v1) {
      if (key === 'major' || key === 'minor' || key === 'patch') {
        if (v1[key] !== v2[key]) {
          return key;
        }
      }
    }
  }
}

exports.compareIdentifiers = compareIdentifiers;

var numeric = /^[0-9]+$/;
function compareIdentifiers(a, b) {
  var anum = numeric.test(a);
  var bnum = numeric.test(b);

  if (anum && bnum) {
    a = +a;
    b = +b;
  }

  return anum && !bnum ? -1 : bnum && !anum ? 1 : a < b ? -1 : a > b ? 1 : 0;
}

exports.rcompareIdentifiers = rcompareIdentifiers;
function rcompareIdentifiers(a, b) {
  return compareIdentifiers(b, a);
}

exports.major = major;
function major(a, loose) {
  return new SemVer(a, loose).major;
}

exports.minor = minor;
function minor(a, loose) {
  return new SemVer(a, loose).minor;
}

exports.patch = patch;
function patch(a, loose) {
  return new SemVer(a, loose).patch;
}

exports.compare = compare;
function compare(a, b, loose) {
  return new SemVer(a, loose).compare(new SemVer(b, loose));
}

exports.compareLoose = compareLoose;
function compareLoose(a, b) {
  return compare(a, b, true);
}

exports.rcompare = rcompare;
function rcompare(a, b, loose) {
  return compare(b, a, loose);
}

exports.sort = sort;
function sort(list, loose) {
  return list.sort(function (a, b) {
    return exports.compare(a, b, loose);
  });
}

exports.rsort = rsort;
function rsort(list, loose) {
  return list.sort(function (a, b) {
    return exports.rcompare(a, b, loose);
  });
}

exports.gt = gt;
function gt(a, b, loose) {
  return compare(a, b, loose) > 0;
}

exports.lt = lt;
function lt(a, b, loose) {
  return compare(a, b, loose) < 0;
}

exports.eq = eq;
function eq(a, b, loose) {
  return compare(a, b, loose) === 0;
}

exports.neq = neq;
function neq(a, b, loose) {
  return compare(a, b, loose) !== 0;
}

exports.gte = gte;
function gte(a, b, loose) {
  return compare(a, b, loose) >= 0;
}

exports.lte = lte;
function lte(a, b, loose) {
  return compare(a, b, loose) <= 0;
}

exports.cmp = cmp;
function cmp(a, op, b, loose) {
  var ret;
  switch (op) {
    case '===':
      if (typeof a === 'object') a = a.version;
      if (typeof b === 'object') b = b.version;
      ret = a === b;
      break;
    case '!==':
      if (typeof a === 'object') a = a.version;
      if (typeof b === 'object') b = b.version;
      ret = a !== b;
      break;
    case '':case '=':case '==':
      ret = eq(a, b, loose);break;
    case '!=':
      ret = neq(a, b, loose);break;
    case '>':
      ret = gt(a, b, loose);break;
    case '>=':
      ret = gte(a, b, loose);break;
    case '<':
      ret = lt(a, b, loose);break;
    case '<=':
      ret = lte(a, b, loose);break;
    default:
      throw new TypeError('Invalid operator: ' + op);
  }
  return ret;
}

exports.Comparator = Comparator;
function Comparator(comp, loose) {
  if (comp instanceof Comparator) {
    if (comp.loose === loose) return comp;else comp = comp.value;
  }

  if (!(this instanceof Comparator)) return new Comparator(comp, loose);

  debug('comparator', comp, loose);
  this.loose = loose;
  this.parse(comp);

  if (this.semver === ANY) this.value = '';else this.value = this.operator + this.semver.version;

  debug('comp', this);
}

var ANY = {};
Comparator.prototype.parse = function (comp) {
  var r = this.loose ? re[COMPARATORLOOSE] : re[COMPARATOR];
  var m = comp.match(r);

  if (!m) throw new TypeError('Invalid comparator: ' + comp);

  this.operator = m[1];
  if (this.operator === '=') this.operator = '';

  // if it literally is just '>' or '' then allow anything.
  if (!m[2]) this.semver = ANY;else this.semver = new SemVer(m[2], this.loose);
};

Comparator.prototype.toString = function () {
  return this.value;
};

Comparator.prototype.test = function (version) {
  debug('Comparator.test', version, this.loose);

  if (this.semver === ANY) return true;

  if (typeof version === 'string') version = new SemVer(version, this.loose);

  return cmp(version, this.operator, this.semver, this.loose);
};

Comparator.prototype.intersects = function (comp, loose) {
  if (!(comp instanceof Comparator)) {
    throw new TypeError('a Comparator is required');
  }

  var rangeTmp;

  if (this.operator === '') {
    rangeTmp = new Range(comp.value, loose);
    return satisfies(this.value, rangeTmp, loose);
  } else if (comp.operator === '') {
    rangeTmp = new Range(this.value, loose);
    return satisfies(comp.semver, rangeTmp, loose);
  }

  var sameDirectionIncreasing = (this.operator === '>=' || this.operator === '>') && (comp.operator === '>=' || comp.operator === '>');
  var sameDirectionDecreasing = (this.operator === '<=' || this.operator === '<') && (comp.operator === '<=' || comp.operator === '<');
  var sameSemVer = this.semver.version === comp.semver.version;
  var differentDirectionsInclusive = (this.operator === '>=' || this.operator === '<=') && (comp.operator === '>=' || comp.operator === '<=');
  var oppositeDirectionsLessThan = cmp(this.semver, '<', comp.semver, loose) && (this.operator === '>=' || this.operator === '>') && (comp.operator === '<=' || comp.operator === '<');
  var oppositeDirectionsGreaterThan = cmp(this.semver, '>', comp.semver, loose) && (this.operator === '<=' || this.operator === '<') && (comp.operator === '>=' || comp.operator === '>');

  return sameDirectionIncreasing || sameDirectionDecreasing || sameSemVer && differentDirectionsInclusive || oppositeDirectionsLessThan || oppositeDirectionsGreaterThan;
};

exports.Range = Range;
function Range(range, loose) {
  if (range instanceof Range) {
    if (range.loose === loose) {
      return range;
    } else {
      return new Range(range.raw, loose);
    }
  }

  if (range instanceof Comparator) {
    return new Range(range.value, loose);
  }

  if (!(this instanceof Range)) return new Range(range, loose);

  this.loose = loose;

  // First, split based on boolean or ||
  this.raw = range;
  this.set = range.split(/\s*\|\|\s*/).map(function (range) {
    return this.parseRange(range.trim());
  }, this).filter(function (c) {
    // throw out any that are not relevant for whatever reason
    return c.length;
  });

  if (!this.set.length) {
    throw new TypeError('Invalid SemVer Range: ' + range);
  }

  this.format();
}

Range.prototype.format = function () {
  this.range = this.set.map(function (comps) {
    return comps.join(' ').trim();
  }).join('||').trim();
  return this.range;
};

Range.prototype.toString = function () {
  return this.range;
};

Range.prototype.parseRange = function (range) {
  var loose = this.loose;
  range = range.trim();
  debug('range', range, loose);
  // `1.2.3 - 1.2.4` => `>=1.2.3 <=1.2.4`
  var hr = loose ? re[HYPHENRANGELOOSE] : re[HYPHENRANGE];
  range = range.replace(hr, hyphenReplace);
  debug('hyphen replace', range);
  // `> 1.2.3 < 1.2.5` => `>1.2.3 <1.2.5`
  range = range.replace(re[COMPARATORTRIM], comparatorTrimReplace);
  debug('comparator trim', range, re[COMPARATORTRIM]);

  // `~ 1.2.3` => `~1.2.3`
  range = range.replace(re[TILDETRIM], tildeTrimReplace);

  // `^ 1.2.3` => `^1.2.3`
  range = range.replace(re[CARETTRIM], caretTrimReplace);

  // normalize spaces
  range = range.split(/\s+/).join(' ');

  // At this point, the range is completely trimmed and
  // ready to be split into comparators.

  var compRe = loose ? re[COMPARATORLOOSE] : re[COMPARATOR];
  var set = range.split(' ').map(function (comp) {
    return parseComparator(comp, loose);
  }).join(' ').split(/\s+/);
  if (this.loose) {
    // in loose mode, throw out any that are not valid comparators
    set = set.filter(function (comp) {
      return !!comp.match(compRe);
    });
  }
  set = set.map(function (comp) {
    return new Comparator(comp, loose);
  });

  return set;
};

Range.prototype.intersects = function (range, loose) {
  if (!(range instanceof Range)) {
    throw new TypeError('a Range is required');
  }

  return this.set.some(function (thisComparators) {
    return thisComparators.every(function (thisComparator) {
      return range.set.some(function (rangeComparators) {
        return rangeComparators.every(function (rangeComparator) {
          return thisComparator.intersects(rangeComparator, loose);
        });
      });
    });
  });
};

// Mostly just for testing and legacy API reasons
exports.toComparators = toComparators;
function toComparators(range, loose) {
  return new Range(range, loose).set.map(function (comp) {
    return comp.map(function (c) {
      return c.value;
    }).join(' ').trim().split(' ');
  });
}

// comprised of xranges, tildes, stars, and gtlt's at this point.
// already replaced the hyphen ranges
// turn into a set of JUST comparators.
function parseComparator(comp, loose) {
  debug('comp', comp);
  comp = replaceCarets(comp, loose);
  debug('caret', comp);
  comp = replaceTildes(comp, loose);
  debug('tildes', comp);
  comp = replaceXRanges(comp, loose);
  debug('xrange', comp);
  comp = replaceStars(comp, loose);
  debug('stars', comp);
  return comp;
}

function isX(id) {
  return !id || id.toLowerCase() === 'x' || id === '*';
}

// ~, ~> --> * (any, kinda silly)
// ~2, ~2.x, ~2.x.x, ~>2, ~>2.x ~>2.x.x --> >=2.0.0 <3.0.0
// ~2.0, ~2.0.x, ~>2.0, ~>2.0.x --> >=2.0.0 <2.1.0
// ~1.2, ~1.2.x, ~>1.2, ~>1.2.x --> >=1.2.0 <1.3.0
// ~1.2.3, ~>1.2.3 --> >=1.2.3 <1.3.0
// ~1.2.0, ~>1.2.0 --> >=1.2.0 <1.3.0
function replaceTildes(comp, loose) {
  return comp.trim().split(/\s+/).map(function (comp) {
    return replaceTilde(comp, loose);
  }).join(' ');
}

function replaceTilde(comp, loose) {
  var r = loose ? re[TILDELOOSE] : re[TILDE];
  return comp.replace(r, function (_, M, m, p, pr) {
    debug('tilde', comp, _, M, m, p, pr);
    var ret;

    if (isX(M)) ret = '';else if (isX(m)) ret = '>=' + M + '.0.0 <' + (+M + 1) + '.0.0';else if (isX(p))
      // ~1.2 == >=1.2.0 <1.3.0
      ret = '>=' + M + '.' + m + '.0 <' + M + '.' + (+m + 1) + '.0';else if (pr) {
      debug('replaceTilde pr', pr);
      if (pr.charAt(0) !== '-') pr = '-' + pr;
      ret = '>=' + M + '.' + m + '.' + p + pr + ' <' + M + '.' + (+m + 1) + '.0';
    } else
      // ~1.2.3 == >=1.2.3 <1.3.0
      ret = '>=' + M + '.' + m + '.' + p + ' <' + M + '.' + (+m + 1) + '.0';

    debug('tilde return', ret);
    return ret;
  });
}

// ^ --> * (any, kinda silly)
// ^2, ^2.x, ^2.x.x --> >=2.0.0 <3.0.0
// ^2.0, ^2.0.x --> >=2.0.0 <3.0.0
// ^1.2, ^1.2.x --> >=1.2.0 <2.0.0
// ^1.2.3 --> >=1.2.3 <2.0.0
// ^1.2.0 --> >=1.2.0 <2.0.0
function replaceCarets(comp, loose) {
  return comp.trim().split(/\s+/).map(function (comp) {
    return replaceCaret(comp, loose);
  }).join(' ');
}

function replaceCaret(comp, loose) {
  debug('caret', comp, loose);
  var r = loose ? re[CARETLOOSE] : re[CARET];
  return comp.replace(r, function (_, M, m, p, pr) {
    debug('caret', comp, _, M, m, p, pr);
    var ret;

    if (isX(M)) ret = '';else if (isX(m)) ret = '>=' + M + '.0.0 <' + (+M + 1) + '.0.0';else if (isX(p)) {
      if (M === '0') ret = '>=' + M + '.' + m + '.0 <' + M + '.' + (+m + 1) + '.0';else ret = '>=' + M + '.' + m + '.0 <' + (+M + 1) + '.0.0';
    } else if (pr) {
      debug('replaceCaret pr', pr);
      if (pr.charAt(0) !== '-') pr = '-' + pr;
      if (M === '0') {
        if (m === '0') ret = '>=' + M + '.' + m + '.' + p + pr + ' <' + M + '.' + m + '.' + (+p + 1);else ret = '>=' + M + '.' + m + '.' + p + pr + ' <' + M + '.' + (+m + 1) + '.0';
      } else ret = '>=' + M + '.' + m + '.' + p + pr + ' <' + (+M + 1) + '.0.0';
    } else {
      debug('no pr');
      if (M === '0') {
        if (m === '0') ret = '>=' + M + '.' + m + '.' + p + ' <' + M + '.' + m + '.' + (+p + 1);else ret = '>=' + M + '.' + m + '.' + p + ' <' + M + '.' + (+m + 1) + '.0';
      } else ret = '>=' + M + '.' + m + '.' + p + ' <' + (+M + 1) + '.0.0';
    }

    debug('caret return', ret);
    return ret;
  });
}

function replaceXRanges(comp, loose) {
  debug('replaceXRanges', comp, loose);
  return comp.split(/\s+/).map(function (comp) {
    return replaceXRange(comp, loose);
  }).join(' ');
}

function replaceXRange(comp, loose) {
  comp = comp.trim();
  var r = loose ? re[XRANGELOOSE] : re[XRANGE];
  return comp.replace(r, function (ret, gtlt, M, m, p, pr) {
    debug('xRange', comp, ret, gtlt, M, m, p, pr);
    var xM = isX(M);
    var xm = xM || isX(m);
    var xp = xm || isX(p);
    var anyX = xp;

    if (gtlt === '=' && anyX) gtlt = '';

    if (xM) {
      if (gtlt === '>' || gtlt === '<') {
        // nothing is allowed
        ret = '<0.0.0';
      } else {
        // nothing is forbidden
        ret = '*';
      }
    } else if (gtlt && anyX) {
      // replace X with 0
      if (xm) m = 0;
      if (xp) p = 0;

      if (gtlt === '>') {
        // >1 => >=2.0.0
        // >1.2 => >=1.3.0
        // >1.2.3 => >= 1.2.4
        gtlt = '>=';
        if (xm) {
          M = +M + 1;
          m = 0;
          p = 0;
        } else if (xp) {
          m = +m + 1;
          p = 0;
        }
      } else if (gtlt === '<=') {
        // <=0.7.x is actually <0.8.0, since any 0.7.x should
        // pass.  Similarly, <=7.x is actually <8.0.0, etc.
        gtlt = '<';
        if (xm) M = +M + 1;else m = +m + 1;
      }

      ret = gtlt + M + '.' + m + '.' + p;
    } else if (xm) {
      ret = '>=' + M + '.0.0 <' + (+M + 1) + '.0.0';
    } else if (xp) {
      ret = '>=' + M + '.' + m + '.0 <' + M + '.' + (+m + 1) + '.0';
    }

    debug('xRange return', ret);

    return ret;
  });
}

// Because * is AND-ed with everything else in the comparator,
// and '' means "any version", just remove the *s entirely.
function replaceStars(comp, loose) {
  debug('replaceStars', comp, loose);
  // Looseness is ignored here.  star is always as loose as it gets!
  return comp.trim().replace(re[STAR], '');
}

// This function is passed to string.replace(re[HYPHENRANGE])
// M, m, patch, prerelease, build
// 1.2 - 3.4.5 => >=1.2.0 <=3.4.5
// 1.2.3 - 3.4 => >=1.2.0 <3.5.0 Any 3.4.x will do
// 1.2 - 3.4 => >=1.2.0 <3.5.0
function hyphenReplace($0, from, fM, fm, fp, fpr, fb, to, tM, tm, tp, tpr, tb) {

  if (isX(fM)) from = '';else if (isX(fm)) from = '>=' + fM + '.0.0';else if (isX(fp)) from = '>=' + fM + '.' + fm + '.0';else from = '>=' + from;

  if (isX(tM)) to = '';else if (isX(tm)) to = '<' + (+tM + 1) + '.0.0';else if (isX(tp)) to = '<' + tM + '.' + (+tm + 1) + '.0';else if (tpr) to = '<=' + tM + '.' + tm + '.' + tp + '-' + tpr;else to = '<=' + to;

  return (from + ' ' + to).trim();
}

// if ANY of the sets match ALL of its comparators, then pass
Range.prototype.test = function (version) {
  if (!version) return false;

  if (typeof version === 'string') version = new SemVer(version, this.loose);

  for (var i = 0; i < this.set.length; i++) {
    if (testSet(this.set[i], version)) return true;
  }
  return false;
};

function testSet(set, version) {
  for (var i = 0; i < set.length; i++) {
    if (!set[i].test(version)) return false;
  }

  if (version.prerelease.length) {
    // Find the set of versions that are allowed to have prereleases
    // For example, ^1.2.3-pr.1 desugars to >=1.2.3-pr.1 <2.0.0
    // That should allow `1.2.3-pr.2` to pass.
    // However, `1.2.4-alpha.notready` should NOT be allowed,
    // even though it's within the range set by the comparators.
    for (var i = 0; i < set.length; i++) {
      debug(set[i].semver);
      if (set[i].semver === ANY) continue;

      if (set[i].semver.prerelease.length > 0) {
        var allowed = set[i].semver;
        if (allowed.major === version.major && allowed.minor === version.minor && allowed.patch === version.patch) return true;
      }
    }

    // Version has a -pre, but it's not one of the ones we like.
    return false;
  }

  return true;
}

exports.satisfies = satisfies;
function satisfies(version, range, loose) {
  try {
    range = new Range(range, loose);
  } catch (er) {
    return false;
  }
  return range.test(version);
}

exports.maxSatisfying = maxSatisfying;
function maxSatisfying(versions, range, loose) {
  var max = null;
  var maxSV = null;
  try {
    var rangeObj = new Range(range, loose);
  } catch (er) {
    return null;
  }
  versions.forEach(function (v) {
    if (rangeObj.test(v)) {
      // satisfies(v, range, loose)
      if (!max || maxSV.compare(v) === -1) {
        // compare(max, v, true)
        max = v;
        maxSV = new SemVer(max, loose);
      }
    }
  });
  return max;
}

exports.minSatisfying = minSatisfying;
function minSatisfying(versions, range, loose) {
  var min = null;
  var minSV = null;
  try {
    var rangeObj = new Range(range, loose);
  } catch (er) {
    return null;
  }
  versions.forEach(function (v) {
    if (rangeObj.test(v)) {
      // satisfies(v, range, loose)
      if (!min || minSV.compare(v) === 1) {
        // compare(min, v, true)
        min = v;
        minSV = new SemVer(min, loose);
      }
    }
  });
  return min;
}

exports.validRange = validRange;
function validRange(range, loose) {
  try {
    // Return '*' instead of '' so that truthiness works.
    // This will throw if it's invalid anyway
    return new Range(range, loose).range || '*';
  } catch (er) {
    return null;
  }
}

// Determine if version is less than all the versions possible in the range
exports.ltr = ltr;
function ltr(version, range, loose) {
  return outside(version, range, '<', loose);
}

// Determine if version is greater than all the versions possible in the range.
exports.gtr = gtr;
function gtr(version, range, loose) {
  return outside(version, range, '>', loose);
}

exports.outside = outside;
function outside(version, range, hilo, loose) {
  version = new SemVer(version, loose);
  range = new Range(range, loose);

  var gtfn, ltefn, ltfn, comp, ecomp;
  switch (hilo) {
    case '>':
      gtfn = gt;
      ltefn = lte;
      ltfn = lt;
      comp = '>';
      ecomp = '>=';
      break;
    case '<':
      gtfn = lt;
      ltefn = gte;
      ltfn = gt;
      comp = '<';
      ecomp = '<=';
      break;
    default:
      throw new TypeError('Must provide a hilo val of "<" or ">"');
  }

  // If it satisifes the range it is not outside
  if (satisfies(version, range, loose)) {
    return false;
  }

  // From now on, variable terms are as if we're in "gtr" mode.
  // but note that everything is flipped for the "ltr" function.

  for (var i = 0; i < range.set.length; ++i) {
    var comparators = range.set[i];

    var high = null;
    var low = null;

    comparators.forEach(function (comparator) {
      if (comparator.semver === ANY) {
        comparator = new Comparator('>=0.0.0');
      }
      high = high || comparator;
      low = low || comparator;
      if (gtfn(comparator.semver, high.semver, loose)) {
        high = comparator;
      } else if (ltfn(comparator.semver, low.semver, loose)) {
        low = comparator;
      }
    });

    // If the edge version comparator has a operator then our version
    // isn't outside it
    if (high.operator === comp || high.operator === ecomp) {
      return false;
    }

    // If the lowest version comparator has an operator and our version
    // is less than it then it isn't higher than the range
    if ((!low.operator || low.operator === comp) && ltefn(version, low.semver)) {
      return false;
    } else if (low.operator === ecomp && ltfn(version, low.semver)) {
      return false;
    }
  }
  return true;
}

exports.prerelease = prerelease;
function prerelease(version, loose) {
  var parsed = parse(version, loose);
  return parsed && parsed.prerelease.length ? parsed.prerelease : null;
}

exports.intersects = intersects;
function intersects(r1, r2, loose) {
  r1 = new Range(r1, loose);
  r2 = new Range(r2, loose);
  return r1.intersects(r2);
}

/***/ }),
/* 56 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/* -*- Mode: js; js-indent-level: 2; -*- */
/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */

var base64VLQ = __webpack_require__(57);
var util = __webpack_require__(23);
var ArraySet = __webpack_require__(58).ArraySet;
var MappingList = __webpack_require__(163).MappingList;

/**
 * An instance of the SourceMapGenerator represents a source map which is
 * being built incrementally. You may pass an object with the following
 * properties:
 *
 *   - file: The filename of the generated source.
 *   - sourceRoot: A root for all relative URLs in this source map.
 */
function SourceMapGenerator(aArgs) {
  if (!aArgs) {
    aArgs = {};
  }
  this._file = util.getArg(aArgs, 'file', null);
  this._sourceRoot = util.getArg(aArgs, 'sourceRoot', null);
  this._skipValidation = util.getArg(aArgs, 'skipValidation', false);
  this._sources = new ArraySet();
  this._names = new ArraySet();
  this._mappings = new MappingList();
  this._sourcesContents = null;
}

SourceMapGenerator.prototype._version = 3;

/**
 * Creates a new SourceMapGenerator based on a SourceMapConsumer
 *
 * @param aSourceMapConsumer The SourceMap.
 */
SourceMapGenerator.fromSourceMap = function SourceMapGenerator_fromSourceMap(aSourceMapConsumer) {
  var sourceRoot = aSourceMapConsumer.sourceRoot;
  var generator = new SourceMapGenerator({
    file: aSourceMapConsumer.file,
    sourceRoot: sourceRoot
  });
  aSourceMapConsumer.eachMapping(function (mapping) {
    var newMapping = {
      generated: {
        line: mapping.generatedLine,
        column: mapping.generatedColumn
      }
    };

    if (mapping.source != null) {
      newMapping.source = mapping.source;
      if (sourceRoot != null) {
        newMapping.source = util.relative(sourceRoot, newMapping.source);
      }

      newMapping.original = {
        line: mapping.originalLine,
        column: mapping.originalColumn
      };

      if (mapping.name != null) {
        newMapping.name = mapping.name;
      }
    }

    generator.addMapping(newMapping);
  });
  aSourceMapConsumer.sources.forEach(function (sourceFile) {
    var sourceRelative = sourceFile;
    if (sourceRoot !== null) {
      sourceRelative = util.relative(sourceRoot, sourceFile);
    }

    if (!generator._sources.has(sourceRelative)) {
      generator._sources.add(sourceRelative);
    }

    var content = aSourceMapConsumer.sourceContentFor(sourceFile);
    if (content != null) {
      generator.setSourceContent(sourceFile, content);
    }
  });
  return generator;
};

/**
 * Add a single mapping from original source line and column to the generated
 * source's line and column for this source map being created. The mapping
 * object should have the following properties:
 *
 *   - generated: An object with the generated line and column positions.
 *   - original: An object with the original line and column positions.
 *   - source: The original source file (relative to the sourceRoot).
 *   - name: An optional original token name for this mapping.
 */
SourceMapGenerator.prototype.addMapping = function SourceMapGenerator_addMapping(aArgs) {
  var generated = util.getArg(aArgs, 'generated');
  var original = util.getArg(aArgs, 'original', null);
  var source = util.getArg(aArgs, 'source', null);
  var name = util.getArg(aArgs, 'name', null);

  if (!this._skipValidation) {
    this._validateMapping(generated, original, source, name);
  }

  if (source != null) {
    source = String(source);
    if (!this._sources.has(source)) {
      this._sources.add(source);
    }
  }

  if (name != null) {
    name = String(name);
    if (!this._names.has(name)) {
      this._names.add(name);
    }
  }

  this._mappings.add({
    generatedLine: generated.line,
    generatedColumn: generated.column,
    originalLine: original != null && original.line,
    originalColumn: original != null && original.column,
    source: source,
    name: name
  });
};

/**
 * Set the source content for a source file.
 */
SourceMapGenerator.prototype.setSourceContent = function SourceMapGenerator_setSourceContent(aSourceFile, aSourceContent) {
  var source = aSourceFile;
  if (this._sourceRoot != null) {
    source = util.relative(this._sourceRoot, source);
  }

  if (aSourceContent != null) {
    // Add the source content to the _sourcesContents map.
    // Create a new _sourcesContents map if the property is null.
    if (!this._sourcesContents) {
      this._sourcesContents = Object.create(null);
    }
    this._sourcesContents[util.toSetString(source)] = aSourceContent;
  } else if (this._sourcesContents) {
    // Remove the source file from the _sourcesContents map.
    // If the _sourcesContents map is empty, set the property to null.
    delete this._sourcesContents[util.toSetString(source)];
    if (Object.keys(this._sourcesContents).length === 0) {
      this._sourcesContents = null;
    }
  }
};

/**
 * Applies the mappings of a sub-source-map for a specific source file to the
 * source map being generated. Each mapping to the supplied source file is
 * rewritten using the supplied source map. Note: The resolution for the
 * resulting mappings is the minimium of this map and the supplied map.
 *
 * @param aSourceMapConsumer The source map to be applied.
 * @param aSourceFile Optional. The filename of the source file.
 *        If omitted, SourceMapConsumer's file property will be used.
 * @param aSourceMapPath Optional. The dirname of the path to the source map
 *        to be applied. If relative, it is relative to the SourceMapConsumer.
 *        This parameter is needed when the two source maps aren't in the same
 *        directory, and the source map to be applied contains relative source
 *        paths. If so, those relative source paths need to be rewritten
 *        relative to the SourceMapGenerator.
 */
SourceMapGenerator.prototype.applySourceMap = function SourceMapGenerator_applySourceMap(aSourceMapConsumer, aSourceFile, aSourceMapPath) {
  var sourceFile = aSourceFile;
  // If aSourceFile is omitted, we will use the file property of the SourceMap
  if (aSourceFile == null) {
    if (aSourceMapConsumer.file == null) {
      throw new Error('SourceMapGenerator.prototype.applySourceMap requires either an explicit source file, ' + 'or the source map\'s "file" property. Both were omitted.');
    }
    sourceFile = aSourceMapConsumer.file;
  }
  var sourceRoot = this._sourceRoot;
  // Make "sourceFile" relative if an absolute Url is passed.
  if (sourceRoot != null) {
    sourceFile = util.relative(sourceRoot, sourceFile);
  }
  // Applying the SourceMap can add and remove items from the sources and
  // the names array.
  var newSources = new ArraySet();
  var newNames = new ArraySet();

  // Find mappings for the "sourceFile"
  this._mappings.unsortedForEach(function (mapping) {
    if (mapping.source === sourceFile && mapping.originalLine != null) {
      // Check if it can be mapped by the source map, then update the mapping.
      var original = aSourceMapConsumer.originalPositionFor({
        line: mapping.originalLine,
        column: mapping.originalColumn
      });
      if (original.source != null) {
        // Copy mapping
        mapping.source = original.source;
        if (aSourceMapPath != null) {
          mapping.source = util.join(aSourceMapPath, mapping.source);
        }
        if (sourceRoot != null) {
          mapping.source = util.relative(sourceRoot, mapping.source);
        }
        mapping.originalLine = original.line;
        mapping.originalColumn = original.column;
        if (original.name != null) {
          mapping.name = original.name;
        }
      }
    }

    var source = mapping.source;
    if (source != null && !newSources.has(source)) {
      newSources.add(source);
    }

    var name = mapping.name;
    if (name != null && !newNames.has(name)) {
      newNames.add(name);
    }
  }, this);
  this._sources = newSources;
  this._names = newNames;

  // Copy sourcesContents of applied map.
  aSourceMapConsumer.sources.forEach(function (sourceFile) {
    var content = aSourceMapConsumer.sourceContentFor(sourceFile);
    if (content != null) {
      if (aSourceMapPath != null) {
        sourceFile = util.join(aSourceMapPath, sourceFile);
      }
      if (sourceRoot != null) {
        sourceFile = util.relative(sourceRoot, sourceFile);
      }
      this.setSourceContent(sourceFile, content);
    }
  }, this);
};

/**
 * A mapping can have one of the three levels of data:
 *
 *   1. Just the generated position.
 *   2. The Generated position, original position, and original source.
 *   3. Generated and original position, original source, as well as a name
 *      token.
 *
 * To maintain consistency, we validate that any new mapping being added falls
 * in to one of these categories.
 */
SourceMapGenerator.prototype._validateMapping = function SourceMapGenerator_validateMapping(aGenerated, aOriginal, aSource, aName) {
  // When aOriginal is truthy but has empty values for .line and .column,
  // it is most likely a programmer error. In this case we throw a very
  // specific error message to try to guide them the right way.
  // For example: https://github.com/Polymer/polymer-bundler/pull/519
  if (aOriginal && typeof aOriginal.line !== 'number' && typeof aOriginal.column !== 'number') {
    throw new Error('original.line and original.column are not numbers -- you probably meant to omit ' + 'the original mapping entirely and only map the generated position. If so, pass ' + 'null for the original mapping instead of an object with empty or null values.');
  }

  if (aGenerated && 'line' in aGenerated && 'column' in aGenerated && aGenerated.line > 0 && aGenerated.column >= 0 && !aOriginal && !aSource && !aName) {
    // Case 1.
    return;
  } else if (aGenerated && 'line' in aGenerated && 'column' in aGenerated && aOriginal && 'line' in aOriginal && 'column' in aOriginal && aGenerated.line > 0 && aGenerated.column >= 0 && aOriginal.line > 0 && aOriginal.column >= 0 && aSource) {
    // Cases 2 and 3.
    return;
  } else {
    throw new Error('Invalid mapping: ' + JSON.stringify({
      generated: aGenerated,
      source: aSource,
      original: aOriginal,
      name: aName
    }));
  }
};

/**
 * Serialize the accumulated mappings in to the stream of base 64 VLQs
 * specified by the source map format.
 */
SourceMapGenerator.prototype._serializeMappings = function SourceMapGenerator_serializeMappings() {
  var previousGeneratedColumn = 0;
  var previousGeneratedLine = 1;
  var previousOriginalColumn = 0;
  var previousOriginalLine = 0;
  var previousName = 0;
  var previousSource = 0;
  var result = '';
  var next;
  var mapping;
  var nameIdx;
  var sourceIdx;

  var mappings = this._mappings.toArray();
  for (var i = 0, len = mappings.length; i < len; i++) {
    mapping = mappings[i];
    next = '';

    if (mapping.generatedLine !== previousGeneratedLine) {
      previousGeneratedColumn = 0;
      while (mapping.generatedLine !== previousGeneratedLine) {
        next += ';';
        previousGeneratedLine++;
      }
    } else {
      if (i > 0) {
        if (!util.compareByGeneratedPositionsInflated(mapping, mappings[i - 1])) {
          continue;
        }
        next += ',';
      }
    }

    next += base64VLQ.encode(mapping.generatedColumn - previousGeneratedColumn);
    previousGeneratedColumn = mapping.generatedColumn;

    if (mapping.source != null) {
      sourceIdx = this._sources.indexOf(mapping.source);
      next += base64VLQ.encode(sourceIdx - previousSource);
      previousSource = sourceIdx;

      // lines are stored 0-based in SourceMap spec version 3
      next += base64VLQ.encode(mapping.originalLine - 1 - previousOriginalLine);
      previousOriginalLine = mapping.originalLine - 1;

      next += base64VLQ.encode(mapping.originalColumn - previousOriginalColumn);
      previousOriginalColumn = mapping.originalColumn;

      if (mapping.name != null) {
        nameIdx = this._names.indexOf(mapping.name);
        next += base64VLQ.encode(nameIdx - previousName);
        previousName = nameIdx;
      }
    }

    result += next;
  }

  return result;
};

SourceMapGenerator.prototype._generateSourcesContent = function SourceMapGenerator_generateSourcesContent(aSources, aSourceRoot) {
  return aSources.map(function (source) {
    if (!this._sourcesContents) {
      return null;
    }
    if (aSourceRoot != null) {
      source = util.relative(aSourceRoot, source);
    }
    var key = util.toSetString(source);
    return Object.prototype.hasOwnProperty.call(this._sourcesContents, key) ? this._sourcesContents[key] : null;
  }, this);
};

/**
 * Externalize the source map.
 */
SourceMapGenerator.prototype.toJSON = function SourceMapGenerator_toJSON() {
  var map = {
    version: this._version,
    sources: this._sources.toArray(),
    names: this._names.toArray(),
    mappings: this._serializeMappings()
  };
  if (this._file != null) {
    map.file = this._file;
  }
  if (this._sourceRoot != null) {
    map.sourceRoot = this._sourceRoot;
  }
  if (this._sourcesContents) {
    map.sourcesContent = this._generateSourcesContent(map.sources, map.sourceRoot);
  }

  return map;
};

/**
 * Render the source map being generated to a string.
 */
SourceMapGenerator.prototype.toString = function SourceMapGenerator_toString() {
  return JSON.stringify(this.toJSON());
};

exports.SourceMapGenerator = SourceMapGenerator;

/***/ }),
/* 57 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/* -*- Mode: js; js-indent-level: 2; -*- */
/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 *
 * Based on the Base 64 VLQ implementation in Closure Compiler:
 * https://code.google.com/p/closure-compiler/source/browse/trunk/src/com/google/debugging/sourcemap/Base64VLQ.java
 *
 * Copyright 2011 The Closure Compiler Authors. All rights reserved.
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are
 * met:
 *
 *  * Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *  * Redistributions in binary form must reproduce the above
 *    copyright notice, this list of conditions and the following
 *    disclaimer in the documentation and/or other materials provided
 *    with the distribution.
 *  * Neither the name of Google Inc. nor the names of its
 *    contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

var base64 = __webpack_require__(162);

// A single base 64 digit can contain 6 bits of data. For the base 64 variable
// length quantities we use in the source map spec, the first bit is the sign,
// the next four bits are the actual value, and the 6th bit is the
// continuation bit. The continuation bit tells us whether there are more
// digits in this value following this digit.
//
//   Continuation
//   |    Sign
//   |    |
//   V    V
//   101011

var VLQ_BASE_SHIFT = 5;

// binary: 100000
var VLQ_BASE = 1 << VLQ_BASE_SHIFT;

// binary: 011111
var VLQ_BASE_MASK = VLQ_BASE - 1;

// binary: 100000
var VLQ_CONTINUATION_BIT = VLQ_BASE;

/**
 * Converts from a two-complement value to a value where the sign bit is
 * placed in the least significant bit.  For example, as decimals:
 *   1 becomes 2 (10 binary), -1 becomes 3 (11 binary)
 *   2 becomes 4 (100 binary), -2 becomes 5 (101 binary)
 */
function toVLQSigned(aValue) {
  return aValue < 0 ? (-aValue << 1) + 1 : (aValue << 1) + 0;
}

/**
 * Converts to a two-complement value from a value where the sign bit is
 * placed in the least significant bit.  For example, as decimals:
 *   2 (10 binary) becomes 1, 3 (11 binary) becomes -1
 *   4 (100 binary) becomes 2, 5 (101 binary) becomes -2
 */
function fromVLQSigned(aValue) {
  var isNegative = (aValue & 1) === 1;
  var shifted = aValue >> 1;
  return isNegative ? -shifted : shifted;
}

/**
 * Returns the base 64 VLQ encoded value.
 */
exports.encode = function base64VLQ_encode(aValue) {
  var encoded = "";
  var digit;

  var vlq = toVLQSigned(aValue);

  do {
    digit = vlq & VLQ_BASE_MASK;
    vlq >>>= VLQ_BASE_SHIFT;
    if (vlq > 0) {
      // There are still more digits in this value, so we must make sure the
      // continuation bit is marked.
      digit |= VLQ_CONTINUATION_BIT;
    }
    encoded += base64.encode(digit);
  } while (vlq > 0);

  return encoded;
};

/**
 * Decodes the next base 64 VLQ value from the given string and returns the
 * value and the rest of the string via the out parameter.
 */
exports.decode = function base64VLQ_decode(aStr, aIndex, aOutParam) {
  var strLen = aStr.length;
  var result = 0;
  var shift = 0;
  var continuation, digit;

  do {
    if (aIndex >= strLen) {
      throw new Error("Expected more digits in base 64 VLQ value.");
    }

    digit = base64.decode(aStr.charCodeAt(aIndex++));
    if (digit === -1) {
      throw new Error("Invalid base64 digit: " + aStr.charAt(aIndex - 1));
    }

    continuation = !!(digit & VLQ_CONTINUATION_BIT);
    digit &= VLQ_BASE_MASK;
    result = result + (digit << shift);
    shift += VLQ_BASE_SHIFT;
  } while (continuation);

  aOutParam.value = fromVLQSigned(result);
  aOutParam.rest = aIndex;
};

/***/ }),
/* 58 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/* -*- Mode: js; js-indent-level: 2; -*- */
/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */

var util = __webpack_require__(23);
var has = Object.prototype.hasOwnProperty;
var hasNativeMap = typeof Map !== "undefined";

/**
 * A data structure which is a combination of an array and a set. Adding a new
 * member is O(1), testing for membership is O(1), and finding the index of an
 * element is O(1). Removing elements from the set is not supported. Only
 * strings are supported for membership.
 */
function ArraySet() {
  this._array = [];
  this._set = hasNativeMap ? new Map() : Object.create(null);
}

/**
 * Static method for creating ArraySet instances from an existing array.
 */
ArraySet.fromArray = function ArraySet_fromArray(aArray, aAllowDuplicates) {
  var set = new ArraySet();
  for (var i = 0, len = aArray.length; i < len; i++) {
    set.add(aArray[i], aAllowDuplicates);
  }
  return set;
};

/**
 * Return how many unique items are in this ArraySet. If duplicates have been
 * added, than those do not count towards the size.
 *
 * @returns Number
 */
ArraySet.prototype.size = function ArraySet_size() {
  return hasNativeMap ? this._set.size : Object.getOwnPropertyNames(this._set).length;
};

/**
 * Add the given string to this set.
 *
 * @param String aStr
 */
ArraySet.prototype.add = function ArraySet_add(aStr, aAllowDuplicates) {
  var sStr = hasNativeMap ? aStr : util.toSetString(aStr);
  var isDuplicate = hasNativeMap ? this.has(aStr) : has.call(this._set, sStr);
  var idx = this._array.length;
  if (!isDuplicate || aAllowDuplicates) {
    this._array.push(aStr);
  }
  if (!isDuplicate) {
    if (hasNativeMap) {
      this._set.set(aStr, idx);
    } else {
      this._set[sStr] = idx;
    }
  }
};

/**
 * Is the given string a member of this set?
 *
 * @param String aStr
 */
ArraySet.prototype.has = function ArraySet_has(aStr) {
  if (hasNativeMap) {
    return this._set.has(aStr);
  } else {
    var sStr = util.toSetString(aStr);
    return has.call(this._set, sStr);
  }
};

/**
 * What is the index of the given string in the array?
 *
 * @param String aStr
 */
ArraySet.prototype.indexOf = function ArraySet_indexOf(aStr) {
  if (hasNativeMap) {
    var idx = this._set.get(aStr);
    if (idx >= 0) {
      return idx;
    }
  } else {
    var sStr = util.toSetString(aStr);
    if (has.call(this._set, sStr)) {
      return this._set[sStr];
    }
  }

  throw new Error('"' + aStr + '" is not in the set.');
};

/**
 * What is the element at the given index?
 *
 * @param Number aIdx
 */
ArraySet.prototype.at = function ArraySet_at(aIdx) {
  if (aIdx >= 0 && aIdx < this._array.length) {
    return this._array[aIdx];
  }
  throw new Error('No element indexed by ' + aIdx);
};

/**
 * Returns the array representation of this set (which has the proper indices
 * indicated by indexOf). Note that this is a copy of the internal array used
 * for storing the members so that no one can mess with internal state.
 */
ArraySet.prototype.toArray = function ArraySet_toArray() {
  return this._array.slice();
};

exports.ArraySet = ArraySet;

/***/ }),
/* 59 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.GenericProvider = undefined;

var _bluebirdLst;

function _load_bluebirdLst() {
    return _bluebirdLst = __webpack_require__(2);
}

var _builderUtilRuntime;

function _load_builderUtilRuntime() {
    return _builderUtilRuntime = __webpack_require__(3);
}

var _main;

function _load_main() {
    return _main = __webpack_require__(8);
}

var _Provider;

function _load_Provider() {
    return _Provider = __webpack_require__(14);
}

class GenericProvider extends (_main || _load_main()).Provider {
    constructor(configuration, updater, useMultipleRangeRequest = true) {
        super(updater.httpExecutor, useMultipleRangeRequest);
        this.configuration = configuration;
        this.updater = updater;
        this.baseUrl = (0, (_main || _load_main()).newBaseUrl)(this.configuration.url);
    }
    get channel() {
        const result = this.updater.channel || this.configuration.channel;
        return result == null ? (0, (_main || _load_main()).getDefaultChannelName)() : (0, (_main || _load_main()).getCustomChannelName)(result);
    }
    getLatestVersion() {
        var _this = this;

        return (0, (_bluebirdLst || _load_bluebirdLst()).coroutine)(function* () {
            let result;
            const channelFile = (0, (_main || _load_main()).getChannelFilename)(_this.channel);
            const channelUrl = (0, (_main || _load_main()).newUrlFromBase)(channelFile, _this.baseUrl);
            for (let attemptNumber = 0;; attemptNumber++) {
                try {
                    result = (0, (_Provider || _load_Provider()).parseUpdateInfo)((yield _this.httpRequest(channelUrl)), channelFile, channelUrl);
                    break;
                } catch (e) {
                    if (e instanceof (_builderUtilRuntime || _load_builderUtilRuntime()).HttpError && e.statusCode === 404) {
                        throw (0, (_builderUtilRuntime || _load_builderUtilRuntime()).newError)(`Cannot find channel "${channelFile}" update info: ${e.stack || e.message}`, "ERR_UPDATER_CHANNEL_FILE_NOT_FOUND");
                    } else if (e.code === "ECONNREFUSED") {
                        if (attemptNumber < 3) {
                            yield new Promise(function (resolve, reject) {
                                try {
                                    setTimeout(resolve, 1000 * attemptNumber);
                                } catch (e) {
                                    reject(e);
                                }
                            });
                            continue;
                        }
                    }
                    throw e;
                }
            }
            if ((0, (_main || _load_main()).isUseOldMacProvider)()) {
                result.releaseJsonUrl = channelUrl.href;
            }
            return result;
        })();
    }
    resolveFiles(updateInfo) {
        return (0, (_Provider || _load_Provider()).resolveFiles)(updateInfo, this.baseUrl);
    }
}
exports.GenericProvider = GenericProvider; //# sourceMappingURL=GenericProvider.js.map

/***/ }),
/* 60 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.GitHubProvider = exports.BaseGitHubProvider = undefined;

var _bluebirdLst;

function _load_bluebirdLst() {
    return _bluebirdLst = __webpack_require__(2);
}

exports.computeReleaseNotes = computeReleaseNotes;

var _builderUtilRuntime;

function _load_builderUtilRuntime() {
    return _builderUtilRuntime = __webpack_require__(3);
}

var _semver;

function _load_semver() {
    return _semver = _interopRequireWildcard(__webpack_require__(55));
}

var _main;

function _load_main() {
    return _main = __webpack_require__(8);
}

var _Provider;

function _load_Provider() {
    return _Provider = __webpack_require__(14);
}

function _interopRequireWildcard(obj) {
    if (obj && obj.__esModule) {
        return obj;
    } else {
        var newObj = {};if (obj != null) {
            for (var key in obj) {
                if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key];
            }
        }newObj.default = obj;return newObj;
    }
}

class BaseGitHubProvider extends (_main || _load_main()).Provider {
    constructor(options, defaultHost, executor) {
        super(executor, false /* because GitHib uses S3 */);
        this.options = options;
        this.baseUrl = (0, (_main || _load_main()).newBaseUrl)((0, (_builderUtilRuntime || _load_builderUtilRuntime()).githubUrl)(options, defaultHost));
    }
    computeGithubBasePath(result) {
        // https://github.com/electron-userland/electron-builder/issues/1903#issuecomment-320881211
        const host = this.options.host;
        return host != null && host !== "github.com" && host !== "api.github.com" ? `/api/v3${result}` : result;
    }
}
exports.BaseGitHubProvider = BaseGitHubProvider;
class GitHubProvider extends BaseGitHubProvider {
    constructor(options, updater, executor) {
        super(options, "github.com", executor);
        this.options = options;
        this.updater = updater;
    }
    getLatestVersion() {
        var _this = this;

        return (0, (_bluebirdLst || _load_bluebirdLst()).coroutine)(function* () {
            const basePath = _this.basePath;
            const cancellationToken = new (_builderUtilRuntime || _load_builderUtilRuntime()).CancellationToken();
            const feedXml = yield _this.httpRequest((0, (_main || _load_main()).newUrlFromBase)(`${basePath}.atom`, _this.baseUrl), {
                Accept: "application/xml, application/atom+xml, text/xml, */*"
            }, cancellationToken);
            const feed = (0, (_builderUtilRuntime || _load_builderUtilRuntime()).parseXml)(feedXml);
            const latestRelease = feed.element("entry", false, `No published versions on GitHub`);
            let version;
            try {
                if (_this.updater.allowPrerelease) {
                    // noinspection TypeScriptValidateJSTypes
                    version = latestRelease.element("link").attribute("href").match(/\/tag\/v?([^\/]+)$/)[1];
                } else {
                    version = yield _this.getLatestVersionString(basePath, cancellationToken);
                }
            } catch (e) {
                throw (0, (_builderUtilRuntime || _load_builderUtilRuntime()).newError)(`Cannot parse releases feed: ${e.stack || e.message},\nXML:\n${feedXml}`, "ERR_UPDATER_INVALID_RELEASE_FEED");
            }
            if (version == null) {
                throw (0, (_builderUtilRuntime || _load_builderUtilRuntime()).newError)(`No published versions on GitHub`, "ERR_UPDATER_NO_PUBLISHED_VERSIONS");
            }
            const channelFile = (0, (_main || _load_main()).getChannelFilename)((0, (_main || _load_main()).getDefaultChannelName)());
            const channelFileUrl = (0, (_main || _load_main()).newUrlFromBase)(_this.getBaseDownloadPath(version, channelFile), _this.baseUrl);
            const requestOptions = _this.createRequestOptions(channelFileUrl);
            let rawData;
            try {
                rawData = yield _this.executor.request(requestOptions, cancellationToken);
            } catch (e) {
                if (!_this.updater.allowPrerelease && e instanceof (_builderUtilRuntime || _load_builderUtilRuntime()).HttpError && e.statusCode === 404) {
                    throw (0, (_builderUtilRuntime || _load_builderUtilRuntime()).newError)(`Cannot find ${channelFile} in the latest release artifacts (${channelFileUrl}): ${e.stack || e.message}`, "ERR_UPDATER_CHANNEL_FILE_NOT_FOUND");
                }
                throw e;
            }
            const result = (0, (_Provider || _load_Provider()).parseUpdateInfo)(rawData, channelFile, channelFileUrl);
            if ((0, (_main || _load_main()).isUseOldMacProvider)()) {
                result.releaseJsonUrl = `${(0, (_builderUtilRuntime || _load_builderUtilRuntime()).githubUrl)(_this.options)}/${requestOptions.path}`;
            }
            if (result.releaseName == null) {
                result.releaseName = latestRelease.elementValueOrEmpty("title");
            }
            if (result.releaseNotes == null) {
                result.releaseNotes = computeReleaseNotes(_this.updater.currentVersion, _this.updater.fullChangelog, feed, latestRelease);
            }
            return result;
        })();
    }
    getLatestVersionString(basePath, cancellationToken) {
        var _this2 = this;

        return (0, (_bluebirdLst || _load_bluebirdLst()).coroutine)(function* () {
            const url = (0, (_main || _load_main()).newUrlFromBase)(`${basePath}/latest`, _this2.baseUrl);
            try {
                // do not use API to avoid limit
                const rawData = yield _this2.httpRequest(url, { Accept: "application/json" }, cancellationToken);
                if (rawData == null) {
                    return null;
                }
                const releaseInfo = JSON.parse(rawData);
                return releaseInfo.tag_name.startsWith("v") ? releaseInfo.tag_name.substring(1) : releaseInfo.tag_name;
            } catch (e) {
                throw (0, (_builderUtilRuntime || _load_builderUtilRuntime()).newError)(`Unable to find latest version on GitHub (${url}), please ensure a production release exists: ${e.stack || e.message}`, "ERR_UPDATER_LATEST_VERSION_NOT_FOUND");
            }
        })();
    }
    get basePath() {
        return this.computeGithubBasePath(`/${this.options.owner}/${this.options.repo}/releases`);
    }
    resolveFiles(updateInfo) {
        // still replace space to - due to backward compatibility
        return (0, (_Provider || _load_Provider()).resolveFiles)(updateInfo, this.baseUrl, p => this.getBaseDownloadPath(updateInfo.version, p.replace(/ /g, "-")));
    }
    getBaseDownloadPath(version, fileName) {
        return `${this.basePath}/download/${this.options.vPrefixedTagName === false ? "" : "v"}${version}/${fileName}`;
    }
}
exports.GitHubProvider = GitHubProvider;
function getNoteValue(parent) {
    const result = parent.elementValueOrEmpty("content");
    // GitHub reports empty notes as <content>No content.</content>
    return result === "No content." ? "" : result;
}
function computeReleaseNotes(currentVersion, isFullChangelog, feed, latestRelease) {
    if (!isFullChangelog) {
        return getNoteValue(latestRelease);
    }
    const releaseNotes = [];
    for (const release of feed.getElements("entry")) {
        // noinspection TypeScriptValidateJSTypes
        const versionRelease = release.element("link").attribute("href").match(/\/tag\/v?([^\/]+)$/)[1];
        if ((_semver || _load_semver()).lt(currentVersion, versionRelease)) {
            releaseNotes.push({
                version: versionRelease,
                note: getNoteValue(release)
            });
        }
    }
    return releaseNotes.sort((a, b) => (_semver || _load_semver()).rcompare(a.version, b.version));
}
//# sourceMappingURL=GitHubProvider.js.map

/***/ }),
/* 61 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.BaseUpdater = undefined;

var _bluebirdLst;

function _load_bluebirdLst() {
    return _bluebirdLst = __webpack_require__(2);
}

var _builderUtilRuntime;

function _load_builderUtilRuntime() {
    return _builderUtilRuntime = __webpack_require__(3);
}

var _fsExtraP;

function _load_fsExtraP() {
    return _fsExtraP = __webpack_require__(9);
}

var _os;

function _load_os() {
    return _os = __webpack_require__(15);
}

var _path = _interopRequireWildcard(__webpack_require__(0));

var _AppUpdater;

function _load_AppUpdater() {
    return _AppUpdater = __webpack_require__(27);
}

var _DownloadedUpdateHelper;

function _load_DownloadedUpdateHelper() {
    return _DownloadedUpdateHelper = __webpack_require__(175);
}

var _main;

function _load_main() {
    return _main = __webpack_require__(8);
}

function _interopRequireWildcard(obj) {
    if (obj && obj.__esModule) {
        return obj;
    } else {
        var newObj = {};if (obj != null) {
            for (var key in obj) {
                if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key];
            }
        }newObj.default = obj;return newObj;
    }
}

class BaseUpdater extends (_AppUpdater || _load_AppUpdater()).AppUpdater {
    constructor(options, app) {
        super(options, app);
        this.downloadedUpdateHelper = new (_DownloadedUpdateHelper || _load_DownloadedUpdateHelper()).DownloadedUpdateHelper();
        this.quitAndInstallCalled = false;
        this.quitHandlerAdded = false;
    }
    quitAndInstall(isSilent = false, isForceRunAfter = false) {
        this._logger.info(`Install on explicit quitAndInstall`);
        if (this.install(isSilent, isSilent ? isForceRunAfter : true)) {
            setImmediate(() => {
                this.app.quit();
            });
        }
    }
    executeDownload(downloadOptions, fileInfo, task) {
        var _this = this;

        return (0, (_bluebirdLst || _load_bluebirdLst()).coroutine)(function* () {
            if (_this.listenerCount((_main || _load_main()).DOWNLOAD_PROGRESS) > 0) {
                downloadOptions.onProgress = function (it) {
                    return _this.emit((_main || _load_main()).DOWNLOAD_PROGRESS, it);
                };
            }
            // use TEST_APP_TMP_DIR if defined and developer machine (must be not windows due to security reasons - we must not use env var in the production)
            const tempDir = yield (0, (_fsExtraP || _load_fsExtraP()).mkdtemp)(`${_path.join((process.platform === "darwin" ? process.env.TEST_APP_TMP_DIR : null) || (0, (_os || _load_os()).tmpdir)(), "up")}-`);
            const removeTempDirIfAny = function () {
                _this.downloadedUpdateHelper.clear();
                return (0, (_fsExtraP || _load_fsExtraP()).remove)(tempDir).catch(function () {
                    // ignored
                });
            };
            try {
                const destinationFile = _path.join(tempDir, _path.posix.basename(fileInfo.info.url));
                yield task(tempDir, destinationFile, removeTempDirIfAny);
                _this._logger.info(`New version ${_this.updateInfo.version} has been downloaded to ${destinationFile}`);
            } catch (e) {
                yield removeTempDirIfAny();
                if (e instanceof (_builderUtilRuntime || _load_builderUtilRuntime()).CancellationError) {
                    _this.emit("update-cancelled", _this.updateInfo);
                    _this._logger.info("Cancelled");
                }
                throw e;
            }
        })();
    }
    install(isSilent, isRunAfter) {
        if (this.quitAndInstallCalled) {
            this._logger.warn("install call ignored: quitAndInstallCalled is set to true");
            return false;
        }
        const installerPath = this.downloadedUpdateHelper.file;
        if (!this.updateAvailable || installerPath == null) {
            this.dispatchError(new Error("No update available, can't quit and install"));
            return false;
        }
        // prevent calling several times
        this.quitAndInstallCalled = true;
        try {
            this._logger.info(`Install: isSilent: ${isSilent}, isRunAfter: ${isRunAfter}`);
            return this.doInstall(installerPath, isSilent, isRunAfter);
        } catch (e) {
            this.dispatchError(e);
            return false;
        }
    }
    addQuitHandler() {
        if (this.quitHandlerAdded) {
            return;
        }
        this.quitHandlerAdded = true;
        this.app.once("quit", () => {
            if (!this.quitAndInstallCalled) {
                this._logger.info("Auto install update on quit");
                this.install(true, false);
            }
        });
    }
}
exports.BaseUpdater = BaseUpdater; //# sourceMappingURL=BaseUpdater.js.map

/***/ }),
/* 62 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.FileWithEmbeddedBlockMapDifferentialDownloader = undefined;

var _bluebirdLst;

function _load_bluebirdLst() {
    return _bluebirdLst = __webpack_require__(2);
}

var _blockMapApi;

function _load_blockMapApi() {
    return _blockMapApi = __webpack_require__(63);
}

var _DifferentialDownloader;

function _load_DifferentialDownloader() {
    return _DifferentialDownloader = __webpack_require__(65);
}

class FileWithEmbeddedBlockMapDifferentialDownloader extends (_DifferentialDownloader || _load_DifferentialDownloader()).DifferentialDownloader {
    download() {
        var _this = this;

        return (0, (_bluebirdLst || _load_bluebirdLst()).coroutine)(function* () {
            const packageInfo = _this.blockAwareFileInfo;
            const fileSize = packageInfo.size;
            const offset = fileSize - (packageInfo.blockMapSize + 4);
            _this.fileMetadataBuffer = yield _this.readRemoteBytes(offset, fileSize - 1);
            const newBlockMap = yield (0, (_DifferentialDownloader || _load_DifferentialDownloader()).readBlockMap)(_this.fileMetadataBuffer.slice(0, _this.fileMetadataBuffer.length - 4));
            yield _this.doDownload(JSON.parse((yield (0, (_blockMapApi || _load_blockMapApi()).readEmbeddedBlockMapData)(_this.options.oldFile))), newBlockMap);
        })();
    }
}
exports.FileWithEmbeddedBlockMapDifferentialDownloader = FileWithEmbeddedBlockMapDifferentialDownloader; //# sourceMappingURL=FileWithEmbeddedBlockMapDifferentialDownloader.js.map

/***/ }),
/* 63 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.readEmbeddedBlockMapData = exports.BLOCK_MAP_FILE_NAME = undefined;

var _bluebirdLst;

function _load_bluebirdLst() {
    return _bluebirdLst = __webpack_require__(2);
}

var _bluebirdLst2;

function _load_bluebirdLst2() {
    return _bluebirdLst2 = _interopRequireDefault(__webpack_require__(2));
}

let readEmbeddedBlockMapData = exports.readEmbeddedBlockMapData = (() => {
    var _ref = (0, (_bluebirdLst || _load_bluebirdLst()).coroutine)(function* (file) {
        const fd = yield (0, (_fsExtraP || _load_fsExtraP()).open)(file, "r");
        try {
            const fileSize = (yield (0, (_fsExtraP || _load_fsExtraP()).fstat)(fd)).size;
            const sizeBuffer = Buffer.allocUnsafe(4);
            yield (0, (_fsExtraP || _load_fsExtraP()).read)(fd, sizeBuffer, 0, sizeBuffer.length, fileSize - sizeBuffer.length);
            const dataBuffer = Buffer.allocUnsafe(sizeBuffer.readUInt32BE(0));
            yield (0, (_fsExtraP || _load_fsExtraP()).read)(fd, dataBuffer, 0, dataBuffer.length, fileSize - sizeBuffer.length - dataBuffer.length);
            yield (0, (_fsExtraP || _load_fsExtraP()).close)(fd);
            const inflateRaw = (_bluebirdLst2 || _load_bluebirdLst2()).default.promisify(__webpack_require__(64).inflateRaw);
            return (yield inflateRaw(dataBuffer)).toString();
        } catch (e) {
            yield (0, (_fsExtraP || _load_fsExtraP()).close)(fd);
            throw e;
        }
    });

    return function readEmbeddedBlockMapData(_x) {
        return _ref.apply(this, arguments);
    };
})();
//# sourceMappingURL=blockMapApi.js.map


var _fsExtraP;

function _load_fsExtraP() {
    return _fsExtraP = __webpack_require__(9);
}

function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
}

const BLOCK_MAP_FILE_NAME = exports.BLOCK_MAP_FILE_NAME = "_blockMap.blockmap";

/***/ }),
/* 64 */
/***/ (function(module, exports) {

module.exports = require("zlib");

/***/ }),
/* 65 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.readBlockMap = exports.DifferentialDownloader = exports.DifferentialDownloaderOptions = undefined;

var _bluebirdLst;

function _load_bluebirdLst() {
    return _bluebirdLst = __webpack_require__(2);
}

var _bluebirdLst2;

function _load_bluebirdLst2() {
    return _bluebirdLst2 = _interopRequireDefault(__webpack_require__(2));
}

let readBlockMap = exports.readBlockMap = (() => {
    var _ref = (0, (_bluebirdLst || _load_bluebirdLst()).coroutine)(function* (data) {
        return JSON.parse((yield inflateRaw(data)).toString());
    });

    return function readBlockMap(_x) {
        return _ref.apply(this, arguments);
    };
})();

var _builderUtilRuntime;

function _load_builderUtilRuntime() {
    return _builderUtilRuntime = __webpack_require__(3);
}

var _fsExtraP;

function _load_fsExtraP() {
    return _fsExtraP = __webpack_require__(9);
}

var _DataSplitter;

function _load_DataSplitter() {
    return _DataSplitter = __webpack_require__(66);
}

var _downloadPlanBuilder;

function _load_downloadPlanBuilder() {
    return _downloadPlanBuilder = __webpack_require__(35);
}

var _multipleRangeDownloader;

function _load_multipleRangeDownloader() {
    return _multipleRangeDownloader = __webpack_require__(178);
}

function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
}

const inflateRaw = (_bluebirdLst2 || _load_bluebirdLst2()).default.promisify(__webpack_require__(64).inflateRaw);
class DifferentialDownloaderOptions {}
exports.DifferentialDownloaderOptions = DifferentialDownloaderOptions;
class DifferentialDownloader {
    // noinspection TypeScriptAbstractClassConstructorCanBeMadeProtected
    constructor(blockAwareFileInfo, httpExecutor, options) {
        this.blockAwareFileInfo = blockAwareFileInfo;
        this.httpExecutor = httpExecutor;
        this.options = options;
        this.logger = options.logger;
        this.baseRequestOptions = (0, (_builderUtilRuntime || _load_builderUtilRuntime()).configureRequestOptionsFromUrl)(options.newUrl, {});
    }
    get signatureSize() {
        return 0;
    }
    createRequestOptions(method = "get", newUrl) {
        return Object.assign({}, newUrl == null ? this.baseRequestOptions : (0, (_builderUtilRuntime || _load_builderUtilRuntime()).configureRequestOptionsFromUrl)(newUrl, {}), { method, headers: Object.assign({}, this.options.requestHeaders, { Accept: "*/*" }) });
    }
    doDownload(oldBlockMap, newBlockMap) {
        // we don't check other metadata like compressionMethod - generic check that it is make sense to differentially update is suitable for it
        if (oldBlockMap.version !== newBlockMap.version) {
            throw new Error(`version is different (${oldBlockMap.version} - ${newBlockMap.version}), full download is required`);
        }
        const logger = this.logger;
        const operations = (0, (_downloadPlanBuilder || _load_downloadPlanBuilder()).computeOperations)(oldBlockMap, newBlockMap, logger);
        if (logger.debug != null) {
            logger.debug(JSON.stringify(operations, null, 2));
        }
        let downloadSize = 0;
        let copySize = 0;
        for (const operation of operations) {
            const length = operation.end - operation.start;
            if (operation.kind === (_downloadPlanBuilder || _load_downloadPlanBuilder()).OperationKind.DOWNLOAD) {
                downloadSize += length;
            } else {
                copySize += length;
            }
        }
        const newPackageSize = this.blockAwareFileInfo.size;
        if (downloadSize + copySize + (this.fileMetadataBuffer == null ? 0 : this.fileMetadataBuffer.length) + this.signatureSize !== newPackageSize) {
            throw new Error(`Internal error, size mismatch: downloadSize: ${downloadSize}, copySize: ${copySize}, newPackageSize: ${newPackageSize}`);
        }
        logger.info(`Full: ${formatBytes(newPackageSize)}, To download: ${formatBytes(downloadSize)} (${Math.round(downloadSize / (newPackageSize / 100))}%)`);
        return this.downloadFile(operations);
    }
    downloadFile(tasks) {
        var _this = this;

        return (0, (_bluebirdLst || _load_bluebirdLst()).coroutine)(function* () {
            const signature = _this.signatureSize === 0 ? null : yield _this.readRemoteBytes(0, _this.signatureSize - 1);
            const oldFileFd = yield (0, (_fsExtraP || _load_fsExtraP()).open)(_this.options.oldFile, "r");
            const newFileFd = yield (0, (_fsExtraP || _load_fsExtraP()).open)(_this.options.newFile, "w");
            const fileOut = (0, (_fsExtraP || _load_fsExtraP()).createWriteStream)(_this.options.newFile, { fd: newFileFd });
            yield new (_bluebirdLst2 || _load_bluebirdLst2()).default(function (resolve, reject) {
                const streams = [];
                const digestTransform = new (_builderUtilRuntime || _load_builderUtilRuntime()).DigestTransform(_this.blockAwareFileInfo.sha512);
                // to simply debug, do manual validation to allow file to be fully written
                digestTransform.isValidateOnEnd = false;
                streams.push(digestTransform);
                // noinspection JSArrowFunctionCanBeReplacedWithShorthand
                fileOut.on("finish", function () {
                    fileOut.close(function () {
                        try {
                            digestTransform.validate();
                        } catch (e) {
                            reject(e);
                            return;
                        }
                        resolve();
                    });
                });
                streams.push(fileOut);
                let lastStream = null;
                for (const stream of streams) {
                    stream.on("error", reject);
                    if (lastStream == null) {
                        lastStream = stream;
                    } else {
                        lastStream = lastStream.pipe(stream);
                    }
                }
                const firstStream = streams[0];
                let w;
                if (_this.options.useMultipleRangeRequest) {
                    w = (0, (_multipleRangeDownloader || _load_multipleRangeDownloader()).executeTasks)(_this, tasks, firstStream, oldFileFd, reject);
                } else {
                    let attemptCount = 0;
                    let actualUrl = null;
                    _this.logger.info(`Differential download: ${_this.options.newUrl}`);
                    w = function (index) {
                        if (index >= tasks.length) {
                            if (_this.fileMetadataBuffer != null) {
                                firstStream.write(_this.fileMetadataBuffer);
                            }
                            firstStream.end();
                            return;
                        }
                        const operation = tasks[index++];
                        if (operation.kind === (_downloadPlanBuilder || _load_downloadPlanBuilder()).OperationKind.COPY) {
                            (0, (_DataSplitter || _load_DataSplitter()).copyData)(operation, firstStream, oldFileFd, reject, function () {
                                return w(index);
                            });
                        } else {
                            const requestOptions = _this.createRequestOptions("get", actualUrl);
                            const range = `bytes=${operation.start}-${operation.end - 1}`;
                            requestOptions.headers.Range = range;
                            requestOptions.redirect = "manual";
                            const debug = _this.logger.debug;
                            if (debug != null) {
                                debug(`effective url: ${actualUrl == null ? "" : removeQuery(actualUrl)}, range: ${range}`);
                            }
                            const request = _this.httpExecutor.doRequest(requestOptions, function (response) {
                                // Electron net handles redirects automatically, our NodeJS test server doesn't use redirects - so, we don't check 3xx codes.
                                if (response.statusCode >= 400) {
                                    reject((0, (_builderUtilRuntime || _load_builderUtilRuntime()).createHttpError)(response));
                                }
                                response.pipe(firstStream, {
                                    end: false
                                });
                                response.once("end", function () {
                                    if (++attemptCount === 100) {
                                        attemptCount = 0;
                                        setTimeout(function () {
                                            return w(index);
                                        }, 1000);
                                    } else {
                                        w(index);
                                    }
                                });
                            });
                            request.on("redirect", function (statusCode, method, redirectUrl) {
                                _this.logger.info(`Redirect to ${removeQuery(redirectUrl)}`);
                                actualUrl = redirectUrl;
                                request.followRedirect();
                            });
                            _this.httpExecutor.addErrorAndTimeoutHandlers(request, reject);
                            request.end();
                        }
                    };
                }
                if (signature == null) {
                    w(0);
                } else {
                    firstStream.write(signature, function () {
                        return w(0);
                    });
                }
            }).then(function () {
                return (0, (_fsExtraP || _load_fsExtraP()).close)(oldFileFd);
            }).catch(function (error) {
                (0, (_fsExtraP || _load_fsExtraP()).closeSync)(oldFileFd);
                (0, (_fsExtraP || _load_fsExtraP()).closeSync)(newFileFd);
                throw error;
            });
        })();
    }
    readRemoteBytes(start, endInclusive) {
        var _this2 = this;

        return (0, (_bluebirdLst || _load_bluebirdLst()).coroutine)(function* () {
            const buffer = Buffer.allocUnsafe(endInclusive + 1 - start);
            const requestOptions = _this2.createRequestOptions();
            requestOptions.headers.Range = `bytes=${start}-${endInclusive}`;
            let position = 0;
            yield _this2.request(requestOptions, function (chunk) {
                chunk.copy(buffer, position);
                position += chunk.length;
            });
            return buffer;
        })();
    }
    request(requestOptions, dataHandler) {
        return new (_bluebirdLst2 || _load_bluebirdLst2()).default((resolve, reject) => {
            const request = this.httpExecutor.doRequest(requestOptions, response => {
                if (!(0, (_multipleRangeDownloader || _load_multipleRangeDownloader()).checkIsRangesSupported)(response, reject)) {
                    return;
                }
                response.on("data", dataHandler);
                response.on("end", () => resolve());
            });
            this.httpExecutor.addErrorAndTimeoutHandlers(request, reject);
            request.end();
        });
    }
}
exports.DifferentialDownloader = DifferentialDownloader;

function formatBytes(value, symbol = " KB") {
    return new Intl.NumberFormat("en").format((value / 1024).toFixed(2)) + symbol;
}
// safety
function removeQuery(url) {
    const index = url.indexOf("?");
    return index < 0 ? url : url.substring(0, index);
}
//# sourceMappingURL=DifferentialDownloader.js.map

/***/ }),
/* 66 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.DataSplitter = undefined;

var _bluebirdLst;

function _load_bluebirdLst() {
    return _bluebirdLst = __webpack_require__(2);
}

var _bluebirdLst2;

function _load_bluebirdLst2() {
    return _bluebirdLst2 = _interopRequireDefault(__webpack_require__(2));
}

exports.copyData = copyData;

var _builderUtilRuntime;

function _load_builderUtilRuntime() {
    return _builderUtilRuntime = __webpack_require__(3);
}

var _fsExtraP;

function _load_fsExtraP() {
    return _fsExtraP = __webpack_require__(9);
}

var _stream;

function _load_stream() {
    return _stream = __webpack_require__(19);
}

var _downloadPlanBuilder;

function _load_downloadPlanBuilder() {
    return _downloadPlanBuilder = __webpack_require__(35);
}

function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
}

const DOUBLE_CRLF = Buffer.from("\r\n\r\n");
var ReadState;
(function (ReadState) {
    ReadState[ReadState["INIT"] = 0] = "INIT";
    ReadState[ReadState["HEADER"] = 1] = "HEADER";
    ReadState[ReadState["BODY"] = 2] = "BODY";
})(ReadState || (ReadState = {}));
function copyData(task, out, oldFileFd, reject, resolve) {
    const readStream = (0, (_fsExtraP || _load_fsExtraP()).createReadStream)("", {
        fd: oldFileFd,
        autoClose: false,
        start: task.start,
        // end is inclusive
        end: task.end - 1
    });
    readStream.on("error", reject);
    readStream.once("end", resolve);
    readStream.pipe(out, {
        end: false
    });
}
class DataSplitter extends (_stream || _load_stream()).Writable {
    constructor(out, options, partIndexToTaskIndex, boundary, partIndexToLength, finishHandler) {
        super();
        this.out = out;
        this.options = options;
        this.partIndexToTaskIndex = partIndexToTaskIndex;
        this.partIndexToLength = partIndexToLength;
        this.finishHandler = finishHandler;
        this.partIndex = -1;
        this.headerListBuffer = null;
        this.readState = ReadState.INIT;
        this.ignoreByteCount = 0;
        this.remainingPartDataCount = 0;
        this.actualPartLength = 0;
        this.boundaryLength = boundary.length + 4; /* size of \r\n-- */
        // first chunk doesn't start with \r\n
        this.ignoreByteCount = this.boundaryLength - 2;
    }
    get isFinished() {
        return this.partIndex === this.partIndexToLength.length;
    }
    // noinspection JSUnusedGlobalSymbols
    _write(data, encoding, callback) {
        if (this.isFinished) {
            console.error(`Trailing ignored data: ${data.length} bytes`);
            return;
        }
        this.handleData(data).then(callback).catch(callback);
    }
    handleData(chunk) {
        var _this = this;

        return (0, (_bluebirdLst || _load_bluebirdLst()).coroutine)(function* () {
            let start = 0;
            if (_this.ignoreByteCount !== 0 && _this.remainingPartDataCount !== 0) {
                throw (0, (_builderUtilRuntime || _load_builderUtilRuntime()).newError)("Internal error", "ERR_DATA_SPLITTER_BYTE_COUNT_MISMATCH");
            }
            if (_this.ignoreByteCount > 0) {
                const toIgnore = Math.min(_this.ignoreByteCount, chunk.length);
                _this.ignoreByteCount -= toIgnore;
                start = toIgnore;
            } else if (_this.remainingPartDataCount > 0) {
                const toRead = Math.min(_this.remainingPartDataCount, chunk.length);
                _this.remainingPartDataCount -= toRead;
                yield _this.processPartData(chunk, 0, toRead);
                start = toRead;
            }
            if (start === chunk.length) {
                return;
            }
            if (_this.readState === ReadState.HEADER) {
                const headerListEnd = _this.searchHeaderListEnd(chunk, start);
                if (headerListEnd === -1) {
                    return;
                }
                start = headerListEnd;
                _this.readState = ReadState.BODY;
                // header list is ignored, we don't need it
                _this.headerListBuffer = null;
            }
            while (true) {
                if (_this.readState === ReadState.BODY) {
                    _this.readState = ReadState.INIT;
                } else {
                    _this.partIndex++;
                    let taskIndex = _this.partIndexToTaskIndex.get(_this.partIndex);
                    if (taskIndex == null) {
                        if (_this.isFinished) {
                            taskIndex = _this.options.end;
                        } else {
                            throw (0, (_builderUtilRuntime || _load_builderUtilRuntime()).newError)("taskIndex is null", "ERR_DATA_SPLITTER_TASK_INDEX_IS_NULL");
                        }
                    }
                    const prevTaskIndex = _this.partIndex === 0 ? _this.options.start : _this.partIndexToTaskIndex.get(_this.partIndex - 1) + 1 /* prev part is download, next maybe copy */;
                    if (prevTaskIndex < taskIndex) {
                        yield _this.copyExistingData(prevTaskIndex, taskIndex);
                    } else if (prevTaskIndex > taskIndex) {
                        throw (0, (_builderUtilRuntime || _load_builderUtilRuntime()).newError)("prevTaskIndex must be < taskIndex", "ERR_DATA_SPLITTER_TASK_INDEX_ASSERT_FAILED");
                    }
                    if (_this.isFinished) {
                        _this.onPartEnd();
                        _this.finishHandler();
                        return;
                    }
                    start = _this.searchHeaderListEnd(chunk, start);
                    if (start === -1) {
                        _this.readState = ReadState.HEADER;
                        return;
                    }
                }
                const partLength = _this.partIndexToLength[_this.partIndex];
                const end = start + partLength;
                const effectiveEnd = Math.min(end, chunk.length);
                yield _this.processPartStarted(chunk, start, effectiveEnd);
                _this.remainingPartDataCount = partLength - (effectiveEnd - start);
                if (_this.remainingPartDataCount > 0) {
                    return;
                }
                start = end + _this.boundaryLength;
                if (start >= chunk.length) {
                    _this.ignoreByteCount = _this.boundaryLength - (chunk.length - end);
                    return;
                }
            }
        })();
    }
    copyExistingData(index, end) {
        return new (_bluebirdLst2 || _load_bluebirdLst2()).default((resolve, reject) => {
            const w = () => {
                if (index === end) {
                    resolve();
                    return;
                }
                const task = this.options.tasks[index];
                if (task.kind !== (_downloadPlanBuilder || _load_downloadPlanBuilder()).OperationKind.COPY) {
                    reject(new Error("Task kind must be COPY"));
                    return;
                }
                copyData(task, this.out, this.options.oldFileFd, reject, () => {
                    index++;
                    w();
                });
            };
            w();
        });
    }
    searchHeaderListEnd(chunk, readOffset) {
        const headerListEnd = chunk.indexOf(DOUBLE_CRLF, readOffset);
        if (headerListEnd !== -1) {
            return headerListEnd + DOUBLE_CRLF.length;
        }
        // not all headers data were received, save to buffer
        const partialChunk = readOffset === 0 ? chunk : chunk.slice(readOffset);
        if (this.headerListBuffer == null) {
            this.headerListBuffer = partialChunk;
        } else {
            this.headerListBuffer = Buffer.concat([this.headerListBuffer, partialChunk]);
        }
        return -1;
    }
    onPartEnd() {
        const expectedLength = this.partIndexToLength[this.partIndex - 1];
        if (this.actualPartLength !== expectedLength) {
            throw (0, (_builderUtilRuntime || _load_builderUtilRuntime()).newError)(`Expected length: ${expectedLength} differs from actual: ${this.actualPartLength}`, "ERR_DATA_SPLITTER_LENGTH_MISMATCH");
        }
        this.actualPartLength = 0;
    }
    processPartStarted(data, start, end) {
        if (this.partIndex !== 0) {
            this.onPartEnd();
        }
        return this.processPartData(data, start, end);
    }
    processPartData(data, start, end) {
        this.actualPartLength += end - start;
        const out = this.out;
        if (out.write(start === 0 && data.length === end ? data : data.slice(start, end))) {
            return (_bluebirdLst2 || _load_bluebirdLst2()).default.resolve();
        } else {
            return new (_bluebirdLst2 || _load_bluebirdLst2()).default((resolve, reject) => {
                out.on("error", reject);
                out.once("drain", () => {
                    out.removeListener("error", reject);
                    resolve();
                });
            });
        }
    }
}
exports.DataSplitter = DataSplitter; //# sourceMappingURL=DataSplitter.js.map

/***/ }),
/* 67 */
/***/ (function(module, exports) {

module.exports = require("http");

/***/ }),
/* 68 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * Save console methods for using when originals are overridden
 */

module.exports = {
  context: console,
  error: console.error,
  warn: console.warn,
  info: console.info,
  verbose: console.verbose,
  debug: console.debug,
  silly: console.silly,
  log: console.log
};

/***/ }),
/* 69 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _electron = __webpack_require__(10);

var _electronIsDev = __webpack_require__(26);

var _electronIsDev2 = _interopRequireDefault(_electronIsDev);

var _electronUpdater = __webpack_require__(8);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

let mainWindow;
const log = __webpack_require__(183);
log.transports.file.level = 'debug';
function onReady() {
    mainWindow = new _electron.BrowserWindow({
        width: 800,
        height: 600,
        webPreferences: {
            webSecurity: false
        }
    });
    mainWindow.setTitle(__webpack_require__(193).name);
    const fileName = `file://${__dirname}/index.html`;
    mainWindow.loadURL(fileName);
    mainWindow.on('close', () => _electron.app.quit());
    if (_electronIsDev2.default) {
        mainWindow.webContents.openDevTools();
    }
    if (!_electronIsDev2.default) {
        configureAppUpdate();
        setTimeout(() => {
            performAppUpdate();
        }, 5000);
    }
}
_electron.app.on('ready', () => onReady());
_electron.app.on('window-all-closed', () => _electron.app.quit());
_electron.app.on('browser-window-created', function (_e, window) {
    window.setMenu(null);
});
_electron.ipcMain.on('theme', (_event, arg) => {
    mainWindow.webContents.send('theme', arg);
});
function performAppUpdate() {
    log.debug('sending updater checking-for-update');
    _electronUpdater.autoUpdater.autoDownload = false;
    _electronUpdater.autoUpdater.checkForUpdates();
}
function configureAppUpdate() {
    _electronUpdater.autoUpdater.logger = log;
    _electronUpdater.autoUpdater.on('checking-for-update', () => {
        log.debug('sending updater checking-for-update');
        mainWindow.webContents.send('updater', 'checking-for-update');
    });
    _electronUpdater.autoUpdater.on('update-available', info => {
        log.debug('sending updater update-available');
        mainWindow.webContents.send('updater', 'update-available', info);
    });
    _electronUpdater.autoUpdater.on('update-not-available', info => {
        log.debug('sending updater update-not-available');
        mainWindow.webContents.send('updater', 'update-not-available', info);
    });
    _electronUpdater.autoUpdater.on('error', err => {
        log.debug('sending updater error');
        mainWindow.webContents.send('updater', 'error', err);
    });
    _electronUpdater.autoUpdater.on('download-progress', progressObj => {
        log.debug('sending updater download-progress');
        mainWindow.webContents.send('updater', 'download-progress', progressObj);
    });
    _electronUpdater.autoUpdater.on('update-downloaded', info => {
        log.debug('sending updater update-downloaded');
        mainWindow.webContents.send('updater', 'update-downloaded', info);
    });
    _electron.ipcMain.on('updater', (_event, type) => {
        if (type === 'download') {
            _electronUpdater.autoUpdater.downloadUpdate();
        }
        if (type === 'install') {
            _electronUpdater.autoUpdater.quitAndInstall();
        }
    });
}

/***/ }),
/* 70 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = function () {
    var makeSelfResolutionError = function () {
        return new TypeError("circular promise resolution chain\u000a\u000a    See http://goo.gl/MqrFmX\u000a");
    };
    var reflectHandler = function () {
        return new Promise.PromiseInspection(this._target());
    };
    var apiRejection = function (msg) {
        return Promise.reject(new TypeError(msg));
    };
    function Proxyable() {}
    var UNDEFINED_BINDING = {};
    var util = __webpack_require__(1);

    var getDomain;
    if (util.isNode) {
        getDomain = function () {
            var ret = process.domain;
            if (ret === undefined) ret = null;
            return ret;
        };
    } else {
        getDomain = function () {
            return null;
        };
    }
    util.notEnumerableProp(Promise, "_getDomain", getDomain);

    var es5 = __webpack_require__(16);
    var Async = __webpack_require__(71);
    var async = new Async();
    es5.defineProperty(Promise, "_async", { value: async });
    var errors = __webpack_require__(11);
    var TypeError = Promise.TypeError = errors.TypeError;
    Promise.RangeError = errors.RangeError;
    var CancellationError = Promise.CancellationError = errors.CancellationError;
    Promise.TimeoutError = errors.TimeoutError;
    Promise.OperationalError = errors.OperationalError;
    Promise.RejectionError = errors.OperationalError;
    Promise.AggregateError = errors.AggregateError;
    var INTERNAL = function () {};
    var APPLY = {};
    var NEXT_FILTER = {};
    var tryConvertToPromise = __webpack_require__(74)(Promise, INTERNAL);
    var PromiseArray = __webpack_require__(75)(Promise, INTERNAL, tryConvertToPromise, apiRejection, Proxyable);
    var Context = __webpack_require__(76)(Promise);
    /*jshint unused:false*/
    var createContext = Context.create;
    var debug = __webpack_require__(77)(Promise, Context);
    var CapturedTrace = debug.CapturedTrace;
    var PassThroughHandlerContext = __webpack_require__(78)(Promise, tryConvertToPromise, NEXT_FILTER);
    var catchFilter = __webpack_require__(38)(NEXT_FILTER);
    var nodebackForPromise = __webpack_require__(39);
    var errorObj = util.errorObj;
    var tryCatch = util.tryCatch;
    function check(self, executor) {
        if (self == null || self.constructor !== Promise) {
            throw new TypeError("the promise constructor cannot be invoked directly\u000a\u000a    See http://goo.gl/MqrFmX\u000a");
        }
        if (typeof executor !== "function") {
            throw new TypeError("expecting a function but got " + util.classString(executor));
        }
    }

    function Promise(executor) {
        if (executor !== INTERNAL) {
            check(this, executor);
        }
        this._bitField = 0;
        this._fulfillmentHandler0 = undefined;
        this._rejectionHandler0 = undefined;
        this._promise0 = undefined;
        this._receiver0 = undefined;
        this._resolveFromExecutor(executor);
        this._promiseCreated();
        this._fireEvent("promiseCreated", this);
    }

    Promise.prototype.toString = function () {
        return "[object Promise]";
    };

    Promise.prototype.caught = Promise.prototype["catch"] = function (fn) {
        var len = arguments.length;
        if (len > 1) {
            var catchInstances = new Array(len - 1),
                j = 0,
                i;
            for (i = 0; i < len - 1; ++i) {
                var item = arguments[i];
                if (util.isObject(item)) {
                    catchInstances[j++] = item;
                } else {
                    return apiRejection("Catch statement predicate: " + "expecting an object but got " + util.classString(item));
                }
            }
            catchInstances.length = j;
            fn = arguments[i];
            return this.then(undefined, catchFilter(catchInstances, fn, this));
        }
        return this.then(undefined, fn);
    };

    Promise.prototype.reflect = function () {
        return this._then(reflectHandler, reflectHandler, undefined, this, undefined);
    };

    Promise.prototype.then = function (didFulfill, didReject) {
        if (debug.warnings() && arguments.length > 0 && typeof didFulfill !== "function" && typeof didReject !== "function") {
            var msg = ".then() only accepts functions but was passed: " + util.classString(didFulfill);
            if (arguments.length > 1) {
                msg += ", " + util.classString(didReject);
            }
            this._warn(msg);
        }
        return this._then(didFulfill, didReject, undefined, undefined, undefined);
    };

    Promise.prototype.done = function (didFulfill, didReject) {
        var promise = this._then(didFulfill, didReject, undefined, undefined, undefined);
        promise._setIsFinal();
    };

    Promise.prototype.spread = function (fn) {
        if (typeof fn !== "function") {
            return apiRejection("expecting a function but got " + util.classString(fn));
        }
        return this.all()._then(fn, undefined, undefined, APPLY, undefined);
    };

    Promise.prototype.toJSON = function () {
        var ret = {
            isFulfilled: false,
            isRejected: false,
            fulfillmentValue: undefined,
            rejectionReason: undefined
        };
        if (this.isFulfilled()) {
            ret.fulfillmentValue = this.value();
            ret.isFulfilled = true;
        } else if (this.isRejected()) {
            ret.rejectionReason = this.reason();
            ret.isRejected = true;
        }
        return ret;
    };

    Promise.prototype.all = function () {
        if (arguments.length > 0) {
            this._warn(".all() was passed arguments but it does not take any");
        }
        return new PromiseArray(this).promise();
    };

    Promise.prototype.error = function (fn) {
        return this.caught(util.originatesFromRejection, fn);
    };

    Promise.getNewLibraryCopy = module.exports;

    Promise.is = function (val) {
        return val instanceof Promise;
    };

    Promise.fromNode = Promise.fromCallback = function (fn) {
        var ret = new Promise(INTERNAL);
        ret._captureStackTrace();
        var multiArgs = arguments.length > 1 ? !!Object(arguments[1]).multiArgs : false;
        var result = tryCatch(fn)(nodebackForPromise(ret, multiArgs));
        if (result === errorObj) {
            ret._rejectCallback(result.e, true);
        }
        if (!ret._isFateSealed()) ret._setAsyncGuaranteed();
        return ret;
    };

    Promise.all = function (promises) {
        return new PromiseArray(promises).promise();
    };

    Promise.cast = function (obj) {
        var ret = tryConvertToPromise(obj);
        if (!(ret instanceof Promise)) {
            ret = new Promise(INTERNAL);
            ret._captureStackTrace();
            ret._setFulfilled();
            ret._rejectionHandler0 = obj;
        }
        return ret;
    };

    Promise.resolve = Promise.fulfilled = Promise.cast;

    Promise.reject = Promise.rejected = function (reason) {
        var ret = new Promise(INTERNAL);
        ret._captureStackTrace();
        ret._rejectCallback(reason, true);
        return ret;
    };

    Promise.setScheduler = function (fn) {
        if (typeof fn !== "function") {
            throw new TypeError("expecting a function but got " + util.classString(fn));
        }
        return async.setScheduler(fn);
    };

    Promise.prototype._then = function (didFulfill, didReject, _, receiver, internalData) {
        var haveInternalData = internalData !== undefined;
        var promise = haveInternalData ? internalData : new Promise(INTERNAL);
        var target = this._target();
        var bitField = target._bitField;

        if (!haveInternalData) {
            promise._propagateFrom(this, 3);
            promise._captureStackTrace();
            if (receiver === undefined && (this._bitField & 2097152) !== 0) {
                if (!((bitField & 50397184) === 0)) {
                    receiver = this._boundValue();
                } else {
                    receiver = target === this ? undefined : this._boundTo;
                }
            }
            this._fireEvent("promiseChained", this, promise);
        }

        var domain = getDomain();
        if (!((bitField & 50397184) === 0)) {
            var handler,
                value,
                settler = target._settlePromiseCtx;
            if ((bitField & 33554432) !== 0) {
                value = target._rejectionHandler0;
                handler = didFulfill;
            } else if ((bitField & 16777216) !== 0) {
                value = target._fulfillmentHandler0;
                handler = didReject;
                target._unsetRejectionIsUnhandled();
            } else {
                settler = target._settlePromiseLateCancellationObserver;
                value = new CancellationError("late cancellation observer");
                target._attachExtraTrace(value);
                handler = didReject;
            }

            async.invoke(settler, target, {
                handler: domain === null ? handler : typeof handler === "function" && util.domainBind(domain, handler),
                promise: promise,
                receiver: receiver,
                value: value
            });
        } else {
            target._addCallbacks(didFulfill, didReject, promise, receiver, domain);
        }

        return promise;
    };

    Promise.prototype._length = function () {
        return this._bitField & 65535;
    };

    Promise.prototype._isFateSealed = function () {
        return (this._bitField & 117506048) !== 0;
    };

    Promise.prototype._isFollowing = function () {
        return (this._bitField & 67108864) === 67108864;
    };

    Promise.prototype._setLength = function (len) {
        this._bitField = this._bitField & -65536 | len & 65535;
    };

    Promise.prototype._setFulfilled = function () {
        this._bitField = this._bitField | 33554432;
        this._fireEvent("promiseFulfilled", this);
    };

    Promise.prototype._setRejected = function () {
        this._bitField = this._bitField | 16777216;
        this._fireEvent("promiseRejected", this);
    };

    Promise.prototype._setFollowing = function () {
        this._bitField = this._bitField | 67108864;
        this._fireEvent("promiseResolved", this);
    };

    Promise.prototype._setIsFinal = function () {
        this._bitField = this._bitField | 4194304;
    };

    Promise.prototype._isFinal = function () {
        return (this._bitField & 4194304) > 0;
    };

    Promise.prototype._unsetCancelled = function () {
        this._bitField = this._bitField & ~65536;
    };

    Promise.prototype._setCancelled = function () {
        this._bitField = this._bitField | 65536;
        this._fireEvent("promiseCancelled", this);
    };

    Promise.prototype._setWillBeCancelled = function () {
        this._bitField = this._bitField | 8388608;
    };

    Promise.prototype._setAsyncGuaranteed = function () {
        if (async.hasCustomScheduler()) return;
        this._bitField = this._bitField | 134217728;
    };

    Promise.prototype._receiverAt = function (index) {
        var ret = index === 0 ? this._receiver0 : this[index * 4 - 4 + 3];
        if (ret === UNDEFINED_BINDING) {
            return undefined;
        } else if (ret === undefined && this._isBound()) {
            return this._boundValue();
        }
        return ret;
    };

    Promise.prototype._promiseAt = function (index) {
        return this[index * 4 - 4 + 2];
    };

    Promise.prototype._fulfillmentHandlerAt = function (index) {
        return this[index * 4 - 4 + 0];
    };

    Promise.prototype._rejectionHandlerAt = function (index) {
        return this[index * 4 - 4 + 1];
    };

    Promise.prototype._boundValue = function () {};

    Promise.prototype._migrateCallback0 = function (follower) {
        var bitField = follower._bitField;
        var fulfill = follower._fulfillmentHandler0;
        var reject = follower._rejectionHandler0;
        var promise = follower._promise0;
        var receiver = follower._receiverAt(0);
        if (receiver === undefined) receiver = UNDEFINED_BINDING;
        this._addCallbacks(fulfill, reject, promise, receiver, null);
    };

    Promise.prototype._migrateCallbackAt = function (follower, index) {
        var fulfill = follower._fulfillmentHandlerAt(index);
        var reject = follower._rejectionHandlerAt(index);
        var promise = follower._promiseAt(index);
        var receiver = follower._receiverAt(index);
        if (receiver === undefined) receiver = UNDEFINED_BINDING;
        this._addCallbacks(fulfill, reject, promise, receiver, null);
    };

    Promise.prototype._addCallbacks = function (fulfill, reject, promise, receiver, domain) {
        var index = this._length();

        if (index >= 65535 - 4) {
            index = 0;
            this._setLength(0);
        }

        if (index === 0) {
            this._promise0 = promise;
            this._receiver0 = receiver;
            if (typeof fulfill === "function") {
                this._fulfillmentHandler0 = domain === null ? fulfill : util.domainBind(domain, fulfill);
            }
            if (typeof reject === "function") {
                this._rejectionHandler0 = domain === null ? reject : util.domainBind(domain, reject);
            }
        } else {
            var base = index * 4 - 4;
            this[base + 2] = promise;
            this[base + 3] = receiver;
            if (typeof fulfill === "function") {
                this[base + 0] = domain === null ? fulfill : util.domainBind(domain, fulfill);
            }
            if (typeof reject === "function") {
                this[base + 1] = domain === null ? reject : util.domainBind(domain, reject);
            }
        }
        this._setLength(index + 1);
        return index;
    };

    Promise.prototype._proxy = function (proxyable, arg) {
        this._addCallbacks(undefined, undefined, arg, proxyable, null);
    };

    Promise.prototype._resolveCallback = function (value, shouldBind) {
        if ((this._bitField & 117506048) !== 0) return;
        if (value === this) return this._rejectCallback(makeSelfResolutionError(), false);
        var maybePromise = tryConvertToPromise(value, this);
        if (!(maybePromise instanceof Promise)) return this._fulfill(value);

        if (shouldBind) this._propagateFrom(maybePromise, 2);

        var promise = maybePromise._target();

        if (promise === this) {
            this._reject(makeSelfResolutionError());
            return;
        }

        var bitField = promise._bitField;
        if ((bitField & 50397184) === 0) {
            var len = this._length();
            if (len > 0) promise._migrateCallback0(this);
            for (var i = 1; i < len; ++i) {
                promise._migrateCallbackAt(this, i);
            }
            this._setFollowing();
            this._setLength(0);
            this._setFollowee(promise);
        } else if ((bitField & 33554432) !== 0) {
            this._fulfill(promise._value());
        } else if ((bitField & 16777216) !== 0) {
            this._reject(promise._reason());
        } else {
            var reason = new CancellationError("late cancellation observer");
            promise._attachExtraTrace(reason);
            this._reject(reason);
        }
    };

    Promise.prototype._rejectCallback = function (reason, synchronous, ignoreNonErrorWarnings) {
        var trace = util.ensureErrorObject(reason);
        var hasStack = trace === reason;
        if (!hasStack && !ignoreNonErrorWarnings && debug.warnings()) {
            var message = "a promise was rejected with a non-error: " + util.classString(reason);
            this._warn(message, true);
        }
        this._attachExtraTrace(trace, synchronous ? hasStack : false);
        this._reject(reason);
    };

    Promise.prototype._resolveFromExecutor = function (executor) {
        if (executor === INTERNAL) return;
        var promise = this;
        this._captureStackTrace();
        this._pushContext();
        var synchronous = true;
        var r = this._execute(executor, function (value) {
            promise._resolveCallback(value);
        }, function (reason) {
            promise._rejectCallback(reason, synchronous);
        });
        synchronous = false;
        this._popContext();

        if (r !== undefined) {
            promise._rejectCallback(r, true);
        }
    };

    Promise.prototype._settlePromiseFromHandler = function (handler, receiver, value, promise) {
        var bitField = promise._bitField;
        if ((bitField & 65536) !== 0) return;
        promise._pushContext();
        var x;
        if (receiver === APPLY) {
            if (!value || typeof value.length !== "number") {
                x = errorObj;
                x.e = new TypeError("cannot .spread() a non-array: " + util.classString(value));
            } else {
                x = tryCatch(handler).apply(this._boundValue(), value);
            }
        } else {
            x = tryCatch(handler).call(receiver, value);
        }
        var promiseCreated = promise._popContext();
        bitField = promise._bitField;
        if ((bitField & 65536) !== 0) return;

        if (x === NEXT_FILTER) {
            promise._reject(value);
        } else if (x === errorObj) {
            promise._rejectCallback(x.e, false);
        } else {
            debug.checkForgottenReturns(x, promiseCreated, "", promise, this);
            promise._resolveCallback(x);
        }
    };

    Promise.prototype._target = function () {
        var ret = this;
        while (ret._isFollowing()) ret = ret._followee();
        return ret;
    };

    Promise.prototype._followee = function () {
        return this._rejectionHandler0;
    };

    Promise.prototype._setFollowee = function (promise) {
        this._rejectionHandler0 = promise;
    };

    Promise.prototype._settlePromise = function (promise, handler, receiver, value) {
        var isPromise = promise instanceof Promise;
        var bitField = this._bitField;
        var asyncGuaranteed = (bitField & 134217728) !== 0;
        if ((bitField & 65536) !== 0) {
            if (isPromise) promise._invokeInternalOnCancel();

            if (receiver instanceof PassThroughHandlerContext && receiver.isFinallyHandler()) {
                receiver.cancelPromise = promise;
                if (tryCatch(handler).call(receiver, value) === errorObj) {
                    promise._reject(errorObj.e);
                }
            } else if (handler === reflectHandler) {
                promise._fulfill(reflectHandler.call(receiver));
            } else if (receiver instanceof Proxyable) {
                receiver._promiseCancelled(promise);
            } else if (isPromise || promise instanceof PromiseArray) {
                promise._cancel();
            } else {
                receiver.cancel();
            }
        } else if (typeof handler === "function") {
            if (!isPromise) {
                handler.call(receiver, value, promise);
            } else {
                if (asyncGuaranteed) promise._setAsyncGuaranteed();
                this._settlePromiseFromHandler(handler, receiver, value, promise);
            }
        } else if (receiver instanceof Proxyable) {
            if (!receiver._isResolved()) {
                if ((bitField & 33554432) !== 0) {
                    receiver._promiseFulfilled(value, promise);
                } else {
                    receiver._promiseRejected(value, promise);
                }
            }
        } else if (isPromise) {
            if (asyncGuaranteed) promise._setAsyncGuaranteed();
            if ((bitField & 33554432) !== 0) {
                promise._fulfill(value);
            } else {
                promise._reject(value);
            }
        }
    };

    Promise.prototype._settlePromiseLateCancellationObserver = function (ctx) {
        var handler = ctx.handler;
        var promise = ctx.promise;
        var receiver = ctx.receiver;
        var value = ctx.value;
        if (typeof handler === "function") {
            if (!(promise instanceof Promise)) {
                handler.call(receiver, value, promise);
            } else {
                this._settlePromiseFromHandler(handler, receiver, value, promise);
            }
        } else if (promise instanceof Promise) {
            promise._reject(value);
        }
    };

    Promise.prototype._settlePromiseCtx = function (ctx) {
        this._settlePromise(ctx.promise, ctx.handler, ctx.receiver, ctx.value);
    };

    Promise.prototype._settlePromise0 = function (handler, value, bitField) {
        var promise = this._promise0;
        var receiver = this._receiverAt(0);
        this._promise0 = undefined;
        this._receiver0 = undefined;
        this._settlePromise(promise, handler, receiver, value);
    };

    Promise.prototype._clearCallbackDataAtIndex = function (index) {
        var base = index * 4 - 4;
        this[base + 2] = this[base + 3] = this[base + 0] = this[base + 1] = undefined;
    };

    Promise.prototype._fulfill = function (value) {
        var bitField = this._bitField;
        if ((bitField & 117506048) >>> 16) return;
        if (value === this) {
            var err = makeSelfResolutionError();
            this._attachExtraTrace(err);
            return this._reject(err);
        }
        this._setFulfilled();
        this._rejectionHandler0 = value;

        if ((bitField & 65535) > 0) {
            if ((bitField & 134217728) !== 0) {
                this._settlePromises();
            } else {
                async.settlePromises(this);
            }
        }
    };

    Promise.prototype._reject = function (reason) {
        var bitField = this._bitField;
        if ((bitField & 117506048) >>> 16) return;
        this._setRejected();
        this._fulfillmentHandler0 = reason;

        if (this._isFinal()) {
            return async.fatalError(reason, util.isNode);
        }

        if ((bitField & 65535) > 0) {
            async.settlePromises(this);
        } else {
            this._ensurePossibleRejectionHandled();
        }
    };

    Promise.prototype._fulfillPromises = function (len, value) {
        for (var i = 1; i < len; i++) {
            var handler = this._fulfillmentHandlerAt(i);
            var promise = this._promiseAt(i);
            var receiver = this._receiverAt(i);
            this._clearCallbackDataAtIndex(i);
            this._settlePromise(promise, handler, receiver, value);
        }
    };

    Promise.prototype._rejectPromises = function (len, reason) {
        for (var i = 1; i < len; i++) {
            var handler = this._rejectionHandlerAt(i);
            var promise = this._promiseAt(i);
            var receiver = this._receiverAt(i);
            this._clearCallbackDataAtIndex(i);
            this._settlePromise(promise, handler, receiver, reason);
        }
    };

    Promise.prototype._settlePromises = function () {
        var bitField = this._bitField;
        var len = bitField & 65535;

        if (len > 0) {
            if ((bitField & 16842752) !== 0) {
                var reason = this._fulfillmentHandler0;
                this._settlePromise0(this._rejectionHandler0, reason, bitField);
                this._rejectPromises(len, reason);
            } else {
                var value = this._rejectionHandler0;
                this._settlePromise0(this._fulfillmentHandler0, value, bitField);
                this._fulfillPromises(len, value);
            }
            this._setLength(0);
        }
        this._clearCancellationData();
    };

    Promise.prototype._settledValue = function () {
        var bitField = this._bitField;
        if ((bitField & 33554432) !== 0) {
            return this._rejectionHandler0;
        } else if ((bitField & 16777216) !== 0) {
            return this._fulfillmentHandler0;
        }
    };

    function deferResolve(v) {
        this.promise._resolveCallback(v);
    }
    function deferReject(v) {
        this.promise._rejectCallback(v, false);
    }

    Promise.defer = Promise.pending = function () {
        debug.deprecated("Promise.defer", "new Promise");
        var promise = new Promise(INTERNAL);
        return {
            promise: promise,
            resolve: deferResolve,
            reject: deferReject
        };
    };

    util.notEnumerableProp(Promise, "_makeSelfResolutionError", makeSelfResolutionError);

    __webpack_require__(79)(Promise, INTERNAL, tryConvertToPromise, apiRejection, debug);
    __webpack_require__(80)(Promise, INTERNAL, tryConvertToPromise, debug);
    __webpack_require__(81)(Promise, PromiseArray, apiRejection, debug);
    __webpack_require__(82)(Promise);
    __webpack_require__(83)(Promise);
    __webpack_require__(84)(Promise, PromiseArray, tryConvertToPromise, INTERNAL, async, getDomain);
    Promise.Promise = Promise;
    Promise.version = "3.5.1";
    __webpack_require__(85)(Promise, PromiseArray, apiRejection, tryConvertToPromise, INTERNAL, debug);
    __webpack_require__(86)(Promise);
    __webpack_require__(87)(Promise, apiRejection, tryConvertToPromise, createContext, INTERNAL, debug);
    __webpack_require__(88)(Promise, INTERNAL, debug);
    __webpack_require__(89)(Promise, apiRejection, INTERNAL, tryConvertToPromise, Proxyable, debug);
    __webpack_require__(90)(Promise);
    __webpack_require__(91)(Promise, INTERNAL);
    __webpack_require__(92)(Promise, PromiseArray, tryConvertToPromise, apiRejection);
    __webpack_require__(93)(Promise, INTERNAL, tryConvertToPromise, apiRejection);
    __webpack_require__(94)(Promise, PromiseArray, apiRejection, tryConvertToPromise, INTERNAL, debug);
    __webpack_require__(95)(Promise, PromiseArray, debug);
    __webpack_require__(96)(Promise, PromiseArray, apiRejection);
    __webpack_require__(97)(Promise, INTERNAL);
    __webpack_require__(98)(Promise, INTERNAL);
    __webpack_require__(99)(Promise);

    util.toFastProperties(Promise);
    util.toFastProperties(Promise.prototype);
    function fillTypes(value) {
        var p = new Promise(INTERNAL);
        p._fulfillmentHandler0 = value;
        p._rejectionHandler0 = value;
        p._promise0 = value;
        p._receiver0 = value;
    }
    // Complete slack tracking, opt out of field-type tracking and           
    // stabilize map                                                         
    fillTypes({ a: 1 });
    fillTypes({ b: 2 });
    fillTypes({ c: 3 });
    fillTypes(1);
    fillTypes(function () {});
    fillTypes(undefined);
    fillTypes(false);
    fillTypes(new Promise(INTERNAL));
    debug.setBounds(Async.firstLineError, util.lastLineError);
    return Promise;
};

/***/ }),
/* 71 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var firstLineError;
try {
    throw new Error();
} catch (e) {
    firstLineError = e;
}
var schedule = __webpack_require__(72);
var Queue = __webpack_require__(73);
var util = __webpack_require__(1);

function Async() {
    this._customScheduler = false;
    this._isTickUsed = false;
    this._lateQueue = new Queue(16);
    this._normalQueue = new Queue(16);
    this._haveDrainedQueues = false;
    this._trampolineEnabled = true;
    var self = this;
    this.drainQueues = function () {
        self._drainQueues();
    };
    this._schedule = schedule;
}

Async.prototype.setScheduler = function (fn) {
    var prev = this._schedule;
    this._schedule = fn;
    this._customScheduler = true;
    return prev;
};

Async.prototype.hasCustomScheduler = function () {
    return this._customScheduler;
};

Async.prototype.enableTrampoline = function () {
    this._trampolineEnabled = true;
};

Async.prototype.disableTrampolineIfNecessary = function () {
    if (util.hasDevTools) {
        this._trampolineEnabled = false;
    }
};

Async.prototype.haveItemsQueued = function () {
    return this._isTickUsed || this._haveDrainedQueues;
};

Async.prototype.fatalError = function (e, isNode) {
    if (isNode) {
        process.stderr.write("Fatal " + (e instanceof Error ? e.stack : e) + "\n");
        process.exit(2);
    } else {
        this.throwLater(e);
    }
};

Async.prototype.throwLater = function (fn, arg) {
    if (arguments.length === 1) {
        arg = fn;
        fn = function () {
            throw arg;
        };
    }
    if (typeof setTimeout !== "undefined") {
        setTimeout(function () {
            fn(arg);
        }, 0);
    } else try {
        this._schedule(function () {
            fn(arg);
        });
    } catch (e) {
        throw new Error("No async scheduler available\u000a\u000a    See http://goo.gl/MqrFmX\u000a");
    }
};

function AsyncInvokeLater(fn, receiver, arg) {
    this._lateQueue.push(fn, receiver, arg);
    this._queueTick();
}

function AsyncInvoke(fn, receiver, arg) {
    this._normalQueue.push(fn, receiver, arg);
    this._queueTick();
}

function AsyncSettlePromises(promise) {
    this._normalQueue._pushOne(promise);
    this._queueTick();
}

if (!util.hasDevTools) {
    Async.prototype.invokeLater = AsyncInvokeLater;
    Async.prototype.invoke = AsyncInvoke;
    Async.prototype.settlePromises = AsyncSettlePromises;
} else {
    Async.prototype.invokeLater = function (fn, receiver, arg) {
        if (this._trampolineEnabled) {
            AsyncInvokeLater.call(this, fn, receiver, arg);
        } else {
            this._schedule(function () {
                setTimeout(function () {
                    fn.call(receiver, arg);
                }, 100);
            });
        }
    };

    Async.prototype.invoke = function (fn, receiver, arg) {
        if (this._trampolineEnabled) {
            AsyncInvoke.call(this, fn, receiver, arg);
        } else {
            this._schedule(function () {
                fn.call(receiver, arg);
            });
        }
    };

    Async.prototype.settlePromises = function (promise) {
        if (this._trampolineEnabled) {
            AsyncSettlePromises.call(this, promise);
        } else {
            this._schedule(function () {
                promise._settlePromises();
            });
        }
    };
}

Async.prototype._drainQueue = function (queue) {
    while (queue.length() > 0) {
        var fn = queue.shift();
        if (typeof fn !== "function") {
            fn._settlePromises();
            continue;
        }
        var receiver = queue.shift();
        var arg = queue.shift();
        fn.call(receiver, arg);
    }
};

Async.prototype._drainQueues = function () {
    this._drainQueue(this._normalQueue);
    this._reset();
    this._haveDrainedQueues = true;
    this._drainQueue(this._lateQueue);
};

Async.prototype._queueTick = function () {
    if (!this._isTickUsed) {
        this._isTickUsed = true;
        this._schedule(this.drainQueues);
    }
};

Async.prototype._reset = function () {
    this._isTickUsed = false;
};

module.exports = Async;
module.exports.firstLineError = firstLineError;

/***/ }),
/* 72 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var util = __webpack_require__(1);
var schedule;
var noAsyncScheduler = function () {
    throw new Error("No async scheduler available\u000a\u000a    See http://goo.gl/MqrFmX\u000a");
};
var NativePromise = util.getNativePromise();
if (util.isNode && typeof MutationObserver === "undefined") {
    var GlobalSetImmediate = global.setImmediate;
    var ProcessNextTick = process.nextTick;
    schedule = util.isRecentNode ? function (fn) {
        GlobalSetImmediate.call(global, fn);
    } : function (fn) {
        ProcessNextTick.call(process, fn);
    };
} else if (typeof NativePromise === "function" && typeof NativePromise.resolve === "function") {
    var nativePromise = NativePromise.resolve();
    schedule = function (fn) {
        nativePromise.then(fn);
    };
} else if (typeof MutationObserver !== "undefined" && !(typeof window !== "undefined" && window.navigator && (window.navigator.standalone || window.cordova))) {
    schedule = function () {
        var div = document.createElement("div");
        var opts = { attributes: true };
        var toggleScheduled = false;
        var div2 = document.createElement("div");
        var o2 = new MutationObserver(function () {
            div.classList.toggle("foo");
            toggleScheduled = false;
        });
        o2.observe(div2, opts);

        var scheduleToggle = function () {
            if (toggleScheduled) return;
            toggleScheduled = true;
            div2.classList.toggle("foo");
        };

        return function schedule(fn) {
            var o = new MutationObserver(function () {
                o.disconnect();
                fn();
            });
            o.observe(div, opts);
            scheduleToggle();
        };
    }();
} else if (typeof setImmediate !== "undefined") {
    schedule = function (fn) {
        setImmediate(fn);
    };
} else if (typeof setTimeout !== "undefined") {
    schedule = function (fn) {
        setTimeout(fn, 0);
    };
} else {
    schedule = noAsyncScheduler;
}
module.exports = schedule;

/***/ }),
/* 73 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


function arrayMove(src, srcIndex, dst, dstIndex, len) {
    for (var j = 0; j < len; ++j) {
        dst[j + dstIndex] = src[j + srcIndex];
        src[j + srcIndex] = void 0;
    }
}

function Queue(capacity) {
    this._capacity = capacity;
    this._length = 0;
    this._front = 0;
}

Queue.prototype._willBeOverCapacity = function (size) {
    return this._capacity < size;
};

Queue.prototype._pushOne = function (arg) {
    var length = this.length();
    this._checkCapacity(length + 1);
    var i = this._front + length & this._capacity - 1;
    this[i] = arg;
    this._length = length + 1;
};

Queue.prototype.push = function (fn, receiver, arg) {
    var length = this.length() + 3;
    if (this._willBeOverCapacity(length)) {
        this._pushOne(fn);
        this._pushOne(receiver);
        this._pushOne(arg);
        return;
    }
    var j = this._front + length - 3;
    this._checkCapacity(length);
    var wrapMask = this._capacity - 1;
    this[j + 0 & wrapMask] = fn;
    this[j + 1 & wrapMask] = receiver;
    this[j + 2 & wrapMask] = arg;
    this._length = length;
};

Queue.prototype.shift = function () {
    var front = this._front,
        ret = this[front];

    this[front] = undefined;
    this._front = front + 1 & this._capacity - 1;
    this._length--;
    return ret;
};

Queue.prototype.length = function () {
    return this._length;
};

Queue.prototype._checkCapacity = function (size) {
    if (this._capacity < size) {
        this._resizeTo(this._capacity << 1);
    }
};

Queue.prototype._resizeTo = function (capacity) {
    var oldCapacity = this._capacity;
    this._capacity = capacity;
    var front = this._front;
    var length = this._length;
    var moveItemsCount = front + length & oldCapacity - 1;
    arrayMove(this, 0, this, oldCapacity, moveItemsCount);
};

module.exports = Queue;

/***/ }),
/* 74 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = function (Promise, INTERNAL) {
    var util = __webpack_require__(1);
    var errorObj = util.errorObj;
    var isObject = util.isObject;

    function tryConvertToPromise(obj, context) {
        if (isObject(obj)) {
            if (obj instanceof Promise) return obj;
            var then = getThen(obj);
            if (then === errorObj) {
                if (context) context._pushContext();
                var ret = Promise.reject(then.e);
                if (context) context._popContext();
                return ret;
            } else if (typeof then === "function") {
                if (isAnyBluebirdPromise(obj)) {
                    var ret = new Promise(INTERNAL);
                    obj._then(ret._fulfill, ret._reject, undefined, ret, null);
                    return ret;
                }
                return doThenable(obj, then, context);
            }
        }
        return obj;
    }

    function doGetThen(obj) {
        return obj.then;
    }

    function getThen(obj) {
        try {
            return doGetThen(obj);
        } catch (e) {
            errorObj.e = e;
            return errorObj;
        }
    }

    var hasProp = {}.hasOwnProperty;
    function isAnyBluebirdPromise(obj) {
        try {
            return hasProp.call(obj, "_promise0");
        } catch (e) {
            return false;
        }
    }

    function doThenable(x, then, context) {
        var promise = new Promise(INTERNAL);
        var ret = promise;
        if (context) context._pushContext();
        promise._captureStackTrace();
        if (context) context._popContext();
        var synchronous = true;
        var result = util.tryCatch(then).call(x, resolve, reject);
        synchronous = false;

        if (promise && result === errorObj) {
            promise._rejectCallback(result.e, true, true);
            promise = null;
        }

        function resolve(value) {
            if (!promise) return;
            promise._resolveCallback(value);
            promise = null;
        }

        function reject(reason) {
            if (!promise) return;
            promise._rejectCallback(reason, synchronous, true);
            promise = null;
        }
        return ret;
    }

    return tryConvertToPromise;
};

/***/ }),
/* 75 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = function (Promise, INTERNAL, tryConvertToPromise, apiRejection, Proxyable) {
    var util = __webpack_require__(1);
    var isArray = util.isArray;

    function toResolutionValue(val) {
        switch (val) {
            case -2:
                return [];
            case -3:
                return {};
            case -6:
                return new Map();
        }
    }

    function PromiseArray(values) {
        var promise = this._promise = new Promise(INTERNAL);
        if (values instanceof Promise) {
            promise._propagateFrom(values, 3);
        }
        promise._setOnCancel(this);
        this._values = values;
        this._length = 0;
        this._totalResolved = 0;
        this._init(undefined, -2);
    }
    util.inherits(PromiseArray, Proxyable);

    PromiseArray.prototype.length = function () {
        return this._length;
    };

    PromiseArray.prototype.promise = function () {
        return this._promise;
    };

    PromiseArray.prototype._init = function init(_, resolveValueIfEmpty) {
        var values = tryConvertToPromise(this._values, this._promise);
        if (values instanceof Promise) {
            values = values._target();
            var bitField = values._bitField;
            ;
            this._values = values;

            if ((bitField & 50397184) === 0) {
                this._promise._setAsyncGuaranteed();
                return values._then(init, this._reject, undefined, this, resolveValueIfEmpty);
            } else if ((bitField & 33554432) !== 0) {
                values = values._value();
            } else if ((bitField & 16777216) !== 0) {
                return this._reject(values._reason());
            } else {
                return this._cancel();
            }
        }
        values = util.asArray(values);
        if (values === null) {
            var err = apiRejection("expecting an array or an iterable object but got " + util.classString(values)).reason();
            this._promise._rejectCallback(err, false);
            return;
        }

        if (values.length === 0) {
            if (resolveValueIfEmpty === -5) {
                this._resolveEmptyArray();
            } else {
                this._resolve(toResolutionValue(resolveValueIfEmpty));
            }
            return;
        }
        this._iterate(values);
    };

    PromiseArray.prototype._iterate = function (values) {
        var len = this.getActualLength(values.length);
        this._length = len;
        this._values = this.shouldCopyValues() ? new Array(len) : this._values;
        var result = this._promise;
        var isResolved = false;
        var bitField = null;
        for (var i = 0; i < len; ++i) {
            var maybePromise = tryConvertToPromise(values[i], result);

            if (maybePromise instanceof Promise) {
                maybePromise = maybePromise._target();
                bitField = maybePromise._bitField;
            } else {
                bitField = null;
            }

            if (isResolved) {
                if (bitField !== null) {
                    maybePromise.suppressUnhandledRejections();
                }
            } else if (bitField !== null) {
                if ((bitField & 50397184) === 0) {
                    maybePromise._proxy(this, i);
                    this._values[i] = maybePromise;
                } else if ((bitField & 33554432) !== 0) {
                    isResolved = this._promiseFulfilled(maybePromise._value(), i);
                } else if ((bitField & 16777216) !== 0) {
                    isResolved = this._promiseRejected(maybePromise._reason(), i);
                } else {
                    isResolved = this._promiseCancelled(i);
                }
            } else {
                isResolved = this._promiseFulfilled(maybePromise, i);
            }
        }
        if (!isResolved) result._setAsyncGuaranteed();
    };

    PromiseArray.prototype._isResolved = function () {
        return this._values === null;
    };

    PromiseArray.prototype._resolve = function (value) {
        this._values = null;
        this._promise._fulfill(value);
    };

    PromiseArray.prototype._cancel = function () {
        if (this._isResolved() || !this._promise._isCancellable()) return;
        this._values = null;
        this._promise._cancel();
    };

    PromiseArray.prototype._reject = function (reason) {
        this._values = null;
        this._promise._rejectCallback(reason, false);
    };

    PromiseArray.prototype._promiseFulfilled = function (value, index) {
        this._values[index] = value;
        var totalResolved = ++this._totalResolved;
        if (totalResolved >= this._length) {
            this._resolve(this._values);
            return true;
        }
        return false;
    };

    PromiseArray.prototype._promiseCancelled = function () {
        this._cancel();
        return true;
    };

    PromiseArray.prototype._promiseRejected = function (reason) {
        this._totalResolved++;
        this._reject(reason);
        return true;
    };

    PromiseArray.prototype._resultCancelled = function () {
        if (this._isResolved()) return;
        var values = this._values;
        this._cancel();
        if (values instanceof Promise) {
            values.cancel();
        } else {
            for (var i = 0; i < values.length; ++i) {
                if (values[i] instanceof Promise) {
                    values[i].cancel();
                }
            }
        }
    };

    PromiseArray.prototype.shouldCopyValues = function () {
        return true;
    };

    PromiseArray.prototype.getActualLength = function (len) {
        return len;
    };

    return PromiseArray;
};

/***/ }),
/* 76 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = function (Promise) {
    var longStackTraces = false;
    var contextStack = [];

    Promise.prototype._promiseCreated = function () {};
    Promise.prototype._pushContext = function () {};
    Promise.prototype._popContext = function () {
        return null;
    };
    Promise._peekContext = Promise.prototype._peekContext = function () {};

    function Context() {
        this._trace = new Context.CapturedTrace(peekContext());
    }
    Context.prototype._pushContext = function () {
        if (this._trace !== undefined) {
            this._trace._promiseCreated = null;
            contextStack.push(this._trace);
        }
    };

    Context.prototype._popContext = function () {
        if (this._trace !== undefined) {
            var trace = contextStack.pop();
            var ret = trace._promiseCreated;
            trace._promiseCreated = null;
            return ret;
        }
        return null;
    };

    function createContext() {
        if (longStackTraces) return new Context();
    }

    function peekContext() {
        var lastIndex = contextStack.length - 1;
        if (lastIndex >= 0) {
            return contextStack[lastIndex];
        }
        return undefined;
    }
    Context.CapturedTrace = null;
    Context.create = createContext;
    Context.deactivateLongStackTraces = function () {};
    Context.activateLongStackTraces = function () {
        var Promise_pushContext = Promise.prototype._pushContext;
        var Promise_popContext = Promise.prototype._popContext;
        var Promise_PeekContext = Promise._peekContext;
        var Promise_peekContext = Promise.prototype._peekContext;
        var Promise_promiseCreated = Promise.prototype._promiseCreated;
        Context.deactivateLongStackTraces = function () {
            Promise.prototype._pushContext = Promise_pushContext;
            Promise.prototype._popContext = Promise_popContext;
            Promise._peekContext = Promise_PeekContext;
            Promise.prototype._peekContext = Promise_peekContext;
            Promise.prototype._promiseCreated = Promise_promiseCreated;
            longStackTraces = false;
        };
        longStackTraces = true;
        Promise.prototype._pushContext = Context.prototype._pushContext;
        Promise.prototype._popContext = Context.prototype._popContext;
        Promise._peekContext = Promise.prototype._peekContext = peekContext;
        Promise.prototype._promiseCreated = function () {
            var ctx = this._peekContext();
            if (ctx && ctx._promiseCreated == null) ctx._promiseCreated = this;
        };
    };
    return Context;
};

/***/ }),
/* 77 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = function (Promise, Context) {
    var getDomain = Promise._getDomain;
    var async = Promise._async;
    var Warning = __webpack_require__(11).Warning;
    var util = __webpack_require__(1);
    var canAttachTrace = util.canAttachTrace;
    var unhandledRejectionHandled;
    var possiblyUnhandledRejection;
    var bluebirdFramePattern = /[\\\/]bluebird[\\\/]js[\\\/](release|debug|instrumented)/;
    var nodeFramePattern = /\((?:timers\.js):\d+:\d+\)/;
    var parseLinePattern = /[\/<\(](.+?):(\d+):(\d+)\)?\s*$/;
    var stackFramePattern = null;
    var formatStack = null;
    var indentStackFrames = false;
    var printWarning;
    var debugging = !!(util.env("BLUEBIRD_DEBUG") != 0 && (false || util.env("BLUEBIRD_DEBUG") || util.env("NODE_ENV") === "development"));

    var warnings = !!(util.env("BLUEBIRD_WARNINGS") != 0 && (debugging || util.env("BLUEBIRD_WARNINGS")));

    var longStackTraces = !!(util.env("BLUEBIRD_LONG_STACK_TRACES") != 0 && (debugging || util.env("BLUEBIRD_LONG_STACK_TRACES")));

    var wForgottenReturn = util.env("BLUEBIRD_W_FORGOTTEN_RETURN") != 0 && (warnings || !!util.env("BLUEBIRD_W_FORGOTTEN_RETURN"));

    Promise.prototype.suppressUnhandledRejections = function () {
        var target = this._target();
        target._bitField = target._bitField & ~1048576 | 524288;
    };

    Promise.prototype._ensurePossibleRejectionHandled = function () {
        if ((this._bitField & 524288) !== 0) return;
        this._setRejectionIsUnhandled();
        var self = this;
        setTimeout(function () {
            self._notifyUnhandledRejection();
        }, 1);
    };

    Promise.prototype._notifyUnhandledRejectionIsHandled = function () {
        fireRejectionEvent("rejectionHandled", unhandledRejectionHandled, undefined, this);
    };

    Promise.prototype._setReturnedNonUndefined = function () {
        this._bitField = this._bitField | 268435456;
    };

    Promise.prototype._returnedNonUndefined = function () {
        return (this._bitField & 268435456) !== 0;
    };

    Promise.prototype._notifyUnhandledRejection = function () {
        if (this._isRejectionUnhandled()) {
            var reason = this._settledValue();
            this._setUnhandledRejectionIsNotified();
            fireRejectionEvent("unhandledRejection", possiblyUnhandledRejection, reason, this);
        }
    };

    Promise.prototype._setUnhandledRejectionIsNotified = function () {
        this._bitField = this._bitField | 262144;
    };

    Promise.prototype._unsetUnhandledRejectionIsNotified = function () {
        this._bitField = this._bitField & ~262144;
    };

    Promise.prototype._isUnhandledRejectionNotified = function () {
        return (this._bitField & 262144) > 0;
    };

    Promise.prototype._setRejectionIsUnhandled = function () {
        this._bitField = this._bitField | 1048576;
    };

    Promise.prototype._unsetRejectionIsUnhandled = function () {
        this._bitField = this._bitField & ~1048576;
        if (this._isUnhandledRejectionNotified()) {
            this._unsetUnhandledRejectionIsNotified();
            this._notifyUnhandledRejectionIsHandled();
        }
    };

    Promise.prototype._isRejectionUnhandled = function () {
        return (this._bitField & 1048576) > 0;
    };

    Promise.prototype._warn = function (message, shouldUseOwnTrace, promise) {
        return warn(message, shouldUseOwnTrace, promise || this);
    };

    Promise.onPossiblyUnhandledRejection = function (fn) {
        var domain = getDomain();
        possiblyUnhandledRejection = typeof fn === "function" ? domain === null ? fn : util.domainBind(domain, fn) : undefined;
    };

    Promise.onUnhandledRejectionHandled = function (fn) {
        var domain = getDomain();
        unhandledRejectionHandled = typeof fn === "function" ? domain === null ? fn : util.domainBind(domain, fn) : undefined;
    };

    var disableLongStackTraces = function () {};
    Promise.longStackTraces = function () {
        if (async.haveItemsQueued() && !config.longStackTraces) {
            throw new Error("cannot enable long stack traces after promises have been created\u000a\u000a    See http://goo.gl/MqrFmX\u000a");
        }
        if (!config.longStackTraces && longStackTracesIsSupported()) {
            var Promise_captureStackTrace = Promise.prototype._captureStackTrace;
            var Promise_attachExtraTrace = Promise.prototype._attachExtraTrace;
            config.longStackTraces = true;
            disableLongStackTraces = function () {
                if (async.haveItemsQueued() && !config.longStackTraces) {
                    throw new Error("cannot enable long stack traces after promises have been created\u000a\u000a    See http://goo.gl/MqrFmX\u000a");
                }
                Promise.prototype._captureStackTrace = Promise_captureStackTrace;
                Promise.prototype._attachExtraTrace = Promise_attachExtraTrace;
                Context.deactivateLongStackTraces();
                async.enableTrampoline();
                config.longStackTraces = false;
            };
            Promise.prototype._captureStackTrace = longStackTracesCaptureStackTrace;
            Promise.prototype._attachExtraTrace = longStackTracesAttachExtraTrace;
            Context.activateLongStackTraces();
            async.disableTrampolineIfNecessary();
        }
    };

    Promise.hasLongStackTraces = function () {
        return config.longStackTraces && longStackTracesIsSupported();
    };

    var fireDomEvent = function () {
        try {
            if (typeof CustomEvent === "function") {
                var event = new CustomEvent("CustomEvent");
                util.global.dispatchEvent(event);
                return function (name, event) {
                    var domEvent = new CustomEvent(name.toLowerCase(), {
                        detail: event,
                        cancelable: true
                    });
                    return !util.global.dispatchEvent(domEvent);
                };
            } else if (typeof Event === "function") {
                var event = new Event("CustomEvent");
                util.global.dispatchEvent(event);
                return function (name, event) {
                    var domEvent = new Event(name.toLowerCase(), {
                        cancelable: true
                    });
                    domEvent.detail = event;
                    return !util.global.dispatchEvent(domEvent);
                };
            } else {
                var event = document.createEvent("CustomEvent");
                event.initCustomEvent("testingtheevent", false, true, {});
                util.global.dispatchEvent(event);
                return function (name, event) {
                    var domEvent = document.createEvent("CustomEvent");
                    domEvent.initCustomEvent(name.toLowerCase(), false, true, event);
                    return !util.global.dispatchEvent(domEvent);
                };
            }
        } catch (e) {}
        return function () {
            return false;
        };
    }();

    var fireGlobalEvent = function () {
        if (util.isNode) {
            return function () {
                return process.emit.apply(process, arguments);
            };
        } else {
            if (!util.global) {
                return function () {
                    return false;
                };
            }
            return function (name) {
                var methodName = "on" + name.toLowerCase();
                var method = util.global[methodName];
                if (!method) return false;
                method.apply(util.global, [].slice.call(arguments, 1));
                return true;
            };
        }
    }();

    function generatePromiseLifecycleEventObject(name, promise) {
        return { promise: promise };
    }

    var eventToObjectGenerator = {
        promiseCreated: generatePromiseLifecycleEventObject,
        promiseFulfilled: generatePromiseLifecycleEventObject,
        promiseRejected: generatePromiseLifecycleEventObject,
        promiseResolved: generatePromiseLifecycleEventObject,
        promiseCancelled: generatePromiseLifecycleEventObject,
        promiseChained: function (name, promise, child) {
            return { promise: promise, child: child };
        },
        warning: function (name, warning) {
            return { warning: warning };
        },
        unhandledRejection: function (name, reason, promise) {
            return { reason: reason, promise: promise };
        },
        rejectionHandled: generatePromiseLifecycleEventObject
    };

    var activeFireEvent = function (name) {
        var globalEventFired = false;
        try {
            globalEventFired = fireGlobalEvent.apply(null, arguments);
        } catch (e) {
            async.throwLater(e);
            globalEventFired = true;
        }

        var domEventFired = false;
        try {
            domEventFired = fireDomEvent(name, eventToObjectGenerator[name].apply(null, arguments));
        } catch (e) {
            async.throwLater(e);
            domEventFired = true;
        }

        return domEventFired || globalEventFired;
    };

    Promise.config = function (opts) {
        opts = Object(opts);
        if ("longStackTraces" in opts) {
            if (opts.longStackTraces) {
                Promise.longStackTraces();
            } else if (!opts.longStackTraces && Promise.hasLongStackTraces()) {
                disableLongStackTraces();
            }
        }
        if ("warnings" in opts) {
            var warningsOption = opts.warnings;
            config.warnings = !!warningsOption;
            wForgottenReturn = config.warnings;

            if (util.isObject(warningsOption)) {
                if ("wForgottenReturn" in warningsOption) {
                    wForgottenReturn = !!warningsOption.wForgottenReturn;
                }
            }
        }
        if ("cancellation" in opts && opts.cancellation && !config.cancellation) {
            if (async.haveItemsQueued()) {
                throw new Error("cannot enable cancellation after promises are in use");
            }
            Promise.prototype._clearCancellationData = cancellationClearCancellationData;
            Promise.prototype._propagateFrom = cancellationPropagateFrom;
            Promise.prototype._onCancel = cancellationOnCancel;
            Promise.prototype._setOnCancel = cancellationSetOnCancel;
            Promise.prototype._attachCancellationCallback = cancellationAttachCancellationCallback;
            Promise.prototype._execute = cancellationExecute;
            propagateFromFunction = cancellationPropagateFrom;
            config.cancellation = true;
        }
        if ("monitoring" in opts) {
            if (opts.monitoring && !config.monitoring) {
                config.monitoring = true;
                Promise.prototype._fireEvent = activeFireEvent;
            } else if (!opts.monitoring && config.monitoring) {
                config.monitoring = false;
                Promise.prototype._fireEvent = defaultFireEvent;
            }
        }
        return Promise;
    };

    function defaultFireEvent() {
        return false;
    }

    Promise.prototype._fireEvent = defaultFireEvent;
    Promise.prototype._execute = function (executor, resolve, reject) {
        try {
            executor(resolve, reject);
        } catch (e) {
            return e;
        }
    };
    Promise.prototype._onCancel = function () {};
    Promise.prototype._setOnCancel = function (handler) {
        ;
    };
    Promise.prototype._attachCancellationCallback = function (onCancel) {
        ;
    };
    Promise.prototype._captureStackTrace = function () {};
    Promise.prototype._attachExtraTrace = function () {};
    Promise.prototype._clearCancellationData = function () {};
    Promise.prototype._propagateFrom = function (parent, flags) {
        ;
        ;
    };

    function cancellationExecute(executor, resolve, reject) {
        var promise = this;
        try {
            executor(resolve, reject, function (onCancel) {
                if (typeof onCancel !== "function") {
                    throw new TypeError("onCancel must be a function, got: " + util.toString(onCancel));
                }
                promise._attachCancellationCallback(onCancel);
            });
        } catch (e) {
            return e;
        }
    }

    function cancellationAttachCancellationCallback(onCancel) {
        if (!this._isCancellable()) return this;

        var previousOnCancel = this._onCancel();
        if (previousOnCancel !== undefined) {
            if (util.isArray(previousOnCancel)) {
                previousOnCancel.push(onCancel);
            } else {
                this._setOnCancel([previousOnCancel, onCancel]);
            }
        } else {
            this._setOnCancel(onCancel);
        }
    }

    function cancellationOnCancel() {
        return this._onCancelField;
    }

    function cancellationSetOnCancel(onCancel) {
        this._onCancelField = onCancel;
    }

    function cancellationClearCancellationData() {
        this._cancellationParent = undefined;
        this._onCancelField = undefined;
    }

    function cancellationPropagateFrom(parent, flags) {
        if ((flags & 1) !== 0) {
            this._cancellationParent = parent;
            var branchesRemainingToCancel = parent._branchesRemainingToCancel;
            if (branchesRemainingToCancel === undefined) {
                branchesRemainingToCancel = 0;
            }
            parent._branchesRemainingToCancel = branchesRemainingToCancel + 1;
        }
        if ((flags & 2) !== 0 && parent._isBound()) {
            this._setBoundTo(parent._boundTo);
        }
    }

    function bindingPropagateFrom(parent, flags) {
        if ((flags & 2) !== 0 && parent._isBound()) {
            this._setBoundTo(parent._boundTo);
        }
    }
    var propagateFromFunction = bindingPropagateFrom;

    function boundValueFunction() {
        var ret = this._boundTo;
        if (ret !== undefined) {
            if (ret instanceof Promise) {
                if (ret.isFulfilled()) {
                    return ret.value();
                } else {
                    return undefined;
                }
            }
        }
        return ret;
    }

    function longStackTracesCaptureStackTrace() {
        this._trace = new CapturedTrace(this._peekContext());
    }

    function longStackTracesAttachExtraTrace(error, ignoreSelf) {
        if (canAttachTrace(error)) {
            var trace = this._trace;
            if (trace !== undefined) {
                if (ignoreSelf) trace = trace._parent;
            }
            if (trace !== undefined) {
                trace.attachExtraTrace(error);
            } else if (!error.__stackCleaned__) {
                var parsed = parseStackAndMessage(error);
                util.notEnumerableProp(error, "stack", parsed.message + "\n" + parsed.stack.join("\n"));
                util.notEnumerableProp(error, "__stackCleaned__", true);
            }
        }
    }

    function checkForgottenReturns(returnValue, promiseCreated, name, promise, parent) {
        if (returnValue === undefined && promiseCreated !== null && wForgottenReturn) {
            if (parent !== undefined && parent._returnedNonUndefined()) return;
            if ((promise._bitField & 65535) === 0) return;

            if (name) name = name + " ";
            var handlerLine = "";
            var creatorLine = "";
            if (promiseCreated._trace) {
                var traceLines = promiseCreated._trace.stack.split("\n");
                var stack = cleanStack(traceLines);
                for (var i = stack.length - 1; i >= 0; --i) {
                    var line = stack[i];
                    if (!nodeFramePattern.test(line)) {
                        var lineMatches = line.match(parseLinePattern);
                        if (lineMatches) {
                            handlerLine = "at " + lineMatches[1] + ":" + lineMatches[2] + ":" + lineMatches[3] + " ";
                        }
                        break;
                    }
                }

                if (stack.length > 0) {
                    var firstUserLine = stack[0];
                    for (var i = 0; i < traceLines.length; ++i) {

                        if (traceLines[i] === firstUserLine) {
                            if (i > 0) {
                                creatorLine = "\n" + traceLines[i - 1];
                            }
                            break;
                        }
                    }
                }
            }
            var msg = "a promise was created in a " + name + "handler " + handlerLine + "but was not returned from it, " + "see http://goo.gl/rRqMUw" + creatorLine;
            promise._warn(msg, true, promiseCreated);
        }
    }

    function deprecated(name, replacement) {
        var message = name + " is deprecated and will be removed in a future version.";
        if (replacement) message += " Use " + replacement + " instead.";
        return warn(message);
    }

    function warn(message, shouldUseOwnTrace, promise) {
        if (!config.warnings) return;
        var warning = new Warning(message);
        var ctx;
        if (shouldUseOwnTrace) {
            promise._attachExtraTrace(warning);
        } else if (config.longStackTraces && (ctx = Promise._peekContext())) {
            ctx.attachExtraTrace(warning);
        } else {
            var parsed = parseStackAndMessage(warning);
            warning.stack = parsed.message + "\n" + parsed.stack.join("\n");
        }

        if (!activeFireEvent("warning", warning)) {
            formatAndLogError(warning, "", true);
        }
    }

    function reconstructStack(message, stacks) {
        for (var i = 0; i < stacks.length - 1; ++i) {
            stacks[i].push("From previous event:");
            stacks[i] = stacks[i].join("\n");
        }
        if (i < stacks.length) {
            stacks[i] = stacks[i].join("\n");
        }
        return message + "\n" + stacks.join("\n");
    }

    function removeDuplicateOrEmptyJumps(stacks) {
        for (var i = 0; i < stacks.length; ++i) {
            if (stacks[i].length === 0 || i + 1 < stacks.length && stacks[i][0] === stacks[i + 1][0]) {
                stacks.splice(i, 1);
                i--;
            }
        }
    }

    function removeCommonRoots(stacks) {
        var current = stacks[0];
        for (var i = 1; i < stacks.length; ++i) {
            var prev = stacks[i];
            var currentLastIndex = current.length - 1;
            var currentLastLine = current[currentLastIndex];
            var commonRootMeetPoint = -1;

            for (var j = prev.length - 1; j >= 0; --j) {
                if (prev[j] === currentLastLine) {
                    commonRootMeetPoint = j;
                    break;
                }
            }

            for (var j = commonRootMeetPoint; j >= 0; --j) {
                var line = prev[j];
                if (current[currentLastIndex] === line) {
                    current.pop();
                    currentLastIndex--;
                } else {
                    break;
                }
            }
            current = prev;
        }
    }

    function cleanStack(stack) {
        var ret = [];
        for (var i = 0; i < stack.length; ++i) {
            var line = stack[i];
            var isTraceLine = "    (No stack trace)" === line || stackFramePattern.test(line);
            var isInternalFrame = isTraceLine && shouldIgnore(line);
            if (isTraceLine && !isInternalFrame) {
                if (indentStackFrames && line.charAt(0) !== " ") {
                    line = "    " + line;
                }
                ret.push(line);
            }
        }
        return ret;
    }

    function stackFramesAsArray(error) {
        var stack = error.stack.replace(/\s+$/g, "").split("\n");
        for (var i = 0; i < stack.length; ++i) {
            var line = stack[i];
            if ("    (No stack trace)" === line || stackFramePattern.test(line)) {
                break;
            }
        }
        if (i > 0 && error.name != "SyntaxError") {
            stack = stack.slice(i);
        }
        return stack;
    }

    function parseStackAndMessage(error) {
        var stack = error.stack;
        var message = error.toString();
        stack = typeof stack === "string" && stack.length > 0 ? stackFramesAsArray(error) : ["    (No stack trace)"];
        return {
            message: message,
            stack: error.name == "SyntaxError" ? stack : cleanStack(stack)
        };
    }

    function formatAndLogError(error, title, isSoft) {
        if (typeof console !== "undefined") {
            var message;
            if (util.isObject(error)) {
                var stack = error.stack;
                message = title + formatStack(stack, error);
            } else {
                message = title + String(error);
            }
            if (typeof printWarning === "function") {
                printWarning(message, isSoft);
            } else if (typeof console.log === "function" || typeof console.log === "object") {
                console.log(message);
            }
        }
    }

    function fireRejectionEvent(name, localHandler, reason, promise) {
        var localEventFired = false;
        try {
            if (typeof localHandler === "function") {
                localEventFired = true;
                if (name === "rejectionHandled") {
                    localHandler(promise);
                } else {
                    localHandler(reason, promise);
                }
            }
        } catch (e) {
            async.throwLater(e);
        }

        if (name === "unhandledRejection") {
            if (!activeFireEvent(name, reason, promise) && !localEventFired) {
                formatAndLogError(reason, "Unhandled rejection ");
            }
        } else {
            activeFireEvent(name, promise);
        }
    }

    function formatNonError(obj) {
        var str;
        if (typeof obj === "function") {
            str = "[function " + (obj.name || "anonymous") + "]";
        } else {
            str = obj && typeof obj.toString === "function" ? obj.toString() : util.toString(obj);
            var ruselessToString = /\[object [a-zA-Z0-9$_]+\]/;
            if (ruselessToString.test(str)) {
                try {
                    var newStr = JSON.stringify(obj);
                    str = newStr;
                } catch (e) {}
            }
            if (str.length === 0) {
                str = "(empty array)";
            }
        }
        return "(<" + snip(str) + ">, no stack trace)";
    }

    function snip(str) {
        var maxChars = 41;
        if (str.length < maxChars) {
            return str;
        }
        return str.substr(0, maxChars - 3) + "...";
    }

    function longStackTracesIsSupported() {
        return typeof captureStackTrace === "function";
    }

    var shouldIgnore = function () {
        return false;
    };
    var parseLineInfoRegex = /[\/<\(]([^:\/]+):(\d+):(?:\d+)\)?\s*$/;
    function parseLineInfo(line) {
        var matches = line.match(parseLineInfoRegex);
        if (matches) {
            return {
                fileName: matches[1],
                line: parseInt(matches[2], 10)
            };
        }
    }

    function setBounds(firstLineError, lastLineError) {
        if (!longStackTracesIsSupported()) return;
        var firstStackLines = firstLineError.stack.split("\n");
        var lastStackLines = lastLineError.stack.split("\n");
        var firstIndex = -1;
        var lastIndex = -1;
        var firstFileName;
        var lastFileName;
        for (var i = 0; i < firstStackLines.length; ++i) {
            var result = parseLineInfo(firstStackLines[i]);
            if (result) {
                firstFileName = result.fileName;
                firstIndex = result.line;
                break;
            }
        }
        for (var i = 0; i < lastStackLines.length; ++i) {
            var result = parseLineInfo(lastStackLines[i]);
            if (result) {
                lastFileName = result.fileName;
                lastIndex = result.line;
                break;
            }
        }
        if (firstIndex < 0 || lastIndex < 0 || !firstFileName || !lastFileName || firstFileName !== lastFileName || firstIndex >= lastIndex) {
            return;
        }

        shouldIgnore = function (line) {
            if (bluebirdFramePattern.test(line)) return true;
            var info = parseLineInfo(line);
            if (info) {
                if (info.fileName === firstFileName && firstIndex <= info.line && info.line <= lastIndex) {
                    return true;
                }
            }
            return false;
        };
    }

    function CapturedTrace(parent) {
        this._parent = parent;
        this._promisesCreated = 0;
        var length = this._length = 1 + (parent === undefined ? 0 : parent._length);
        captureStackTrace(this, CapturedTrace);
        if (length > 32) this.uncycle();
    }
    util.inherits(CapturedTrace, Error);
    Context.CapturedTrace = CapturedTrace;

    CapturedTrace.prototype.uncycle = function () {
        var length = this._length;
        if (length < 2) return;
        var nodes = [];
        var stackToIndex = {};

        for (var i = 0, node = this; node !== undefined; ++i) {
            nodes.push(node);
            node = node._parent;
        }
        length = this._length = i;
        for (var i = length - 1; i >= 0; --i) {
            var stack = nodes[i].stack;
            if (stackToIndex[stack] === undefined) {
                stackToIndex[stack] = i;
            }
        }
        for (var i = 0; i < length; ++i) {
            var currentStack = nodes[i].stack;
            var index = stackToIndex[currentStack];
            if (index !== undefined && index !== i) {
                if (index > 0) {
                    nodes[index - 1]._parent = undefined;
                    nodes[index - 1]._length = 1;
                }
                nodes[i]._parent = undefined;
                nodes[i]._length = 1;
                var cycleEdgeNode = i > 0 ? nodes[i - 1] : this;

                if (index < length - 1) {
                    cycleEdgeNode._parent = nodes[index + 1];
                    cycleEdgeNode._parent.uncycle();
                    cycleEdgeNode._length = cycleEdgeNode._parent._length + 1;
                } else {
                    cycleEdgeNode._parent = undefined;
                    cycleEdgeNode._length = 1;
                }
                var currentChildLength = cycleEdgeNode._length + 1;
                for (var j = i - 2; j >= 0; --j) {
                    nodes[j]._length = currentChildLength;
                    currentChildLength++;
                }
                return;
            }
        }
    };

    CapturedTrace.prototype.attachExtraTrace = function (error) {
        if (error.__stackCleaned__) return;
        this.uncycle();
        var parsed = parseStackAndMessage(error);
        var message = parsed.message;
        var stacks = [parsed.stack];

        var trace = this;
        while (trace !== undefined) {
            stacks.push(cleanStack(trace.stack.split("\n")));
            trace = trace._parent;
        }
        removeCommonRoots(stacks);
        removeDuplicateOrEmptyJumps(stacks);
        util.notEnumerableProp(error, "stack", reconstructStack(message, stacks));
        util.notEnumerableProp(error, "__stackCleaned__", true);
    };

    var captureStackTrace = function stackDetection() {
        var v8stackFramePattern = /^\s*at\s*/;
        var v8stackFormatter = function (stack, error) {
            if (typeof stack === "string") return stack;

            if (error.name !== undefined && error.message !== undefined) {
                return error.toString();
            }
            return formatNonError(error);
        };

        if (typeof Error.stackTraceLimit === "number" && typeof Error.captureStackTrace === "function") {
            Error.stackTraceLimit += 6;
            stackFramePattern = v8stackFramePattern;
            formatStack = v8stackFormatter;
            var captureStackTrace = Error.captureStackTrace;

            shouldIgnore = function (line) {
                return bluebirdFramePattern.test(line);
            };
            return function (receiver, ignoreUntil) {
                Error.stackTraceLimit += 6;
                captureStackTrace(receiver, ignoreUntil);
                Error.stackTraceLimit -= 6;
            };
        }
        var err = new Error();

        if (typeof err.stack === "string" && err.stack.split("\n")[0].indexOf("stackDetection@") >= 0) {
            stackFramePattern = /@/;
            formatStack = v8stackFormatter;
            indentStackFrames = true;
            return function captureStackTrace(o) {
                o.stack = new Error().stack;
            };
        }

        var hasStackAfterThrow;
        try {
            throw new Error();
        } catch (e) {
            hasStackAfterThrow = "stack" in e;
        }
        if (!("stack" in err) && hasStackAfterThrow && typeof Error.stackTraceLimit === "number") {
            stackFramePattern = v8stackFramePattern;
            formatStack = v8stackFormatter;
            return function captureStackTrace(o) {
                Error.stackTraceLimit += 6;
                try {
                    throw new Error();
                } catch (e) {
                    o.stack = e.stack;
                }
                Error.stackTraceLimit -= 6;
            };
        }

        formatStack = function (stack, error) {
            if (typeof stack === "string") return stack;

            if ((typeof error === "object" || typeof error === "function") && error.name !== undefined && error.message !== undefined) {
                return error.toString();
            }
            return formatNonError(error);
        };

        return null;
    }([]);

    if (typeof console !== "undefined" && typeof console.warn !== "undefined") {
        printWarning = function (message) {
            console.warn(message);
        };
        if (util.isNode && process.stderr.isTTY) {
            printWarning = function (message, isSoft) {
                var color = isSoft ? "\u001b[33m" : "\u001b[31m";
                console.warn(color + message + "\u001b[0m\n");
            };
        } else if (!util.isNode && typeof new Error().stack === "string") {
            printWarning = function (message, isSoft) {
                console.warn("%c" + message, isSoft ? "color: darkorange" : "color: red");
            };
        }
    }

    var config = {
        warnings: warnings,
        longStackTraces: false,
        cancellation: false,
        monitoring: false
    };

    if (longStackTraces) Promise.longStackTraces();

    return {
        longStackTraces: function () {
            return config.longStackTraces;
        },
        warnings: function () {
            return config.warnings;
        },
        cancellation: function () {
            return config.cancellation;
        },
        monitoring: function () {
            return config.monitoring;
        },
        propagateFromFunction: function () {
            return propagateFromFunction;
        },
        boundValueFunction: function () {
            return boundValueFunction;
        },
        checkForgottenReturns: checkForgottenReturns,
        setBounds: setBounds,
        warn: warn,
        deprecated: deprecated,
        CapturedTrace: CapturedTrace,
        fireDomEvent: fireDomEvent,
        fireGlobalEvent: fireGlobalEvent
    };
};

/***/ }),
/* 78 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = function (Promise, tryConvertToPromise, NEXT_FILTER) {
    var util = __webpack_require__(1);
    var CancellationError = Promise.CancellationError;
    var errorObj = util.errorObj;
    var catchFilter = __webpack_require__(38)(NEXT_FILTER);

    function PassThroughHandlerContext(promise, type, handler) {
        this.promise = promise;
        this.type = type;
        this.handler = handler;
        this.called = false;
        this.cancelPromise = null;
    }

    PassThroughHandlerContext.prototype.isFinallyHandler = function () {
        return this.type === 0;
    };

    function FinallyHandlerCancelReaction(finallyHandler) {
        this.finallyHandler = finallyHandler;
    }

    FinallyHandlerCancelReaction.prototype._resultCancelled = function () {
        checkCancel(this.finallyHandler);
    };

    function checkCancel(ctx, reason) {
        if (ctx.cancelPromise != null) {
            if (arguments.length > 1) {
                ctx.cancelPromise._reject(reason);
            } else {
                ctx.cancelPromise._cancel();
            }
            ctx.cancelPromise = null;
            return true;
        }
        return false;
    }

    function succeed() {
        return finallyHandler.call(this, this.promise._target()._settledValue());
    }
    function fail(reason) {
        if (checkCancel(this, reason)) return;
        errorObj.e = reason;
        return errorObj;
    }
    function finallyHandler(reasonOrValue) {
        var promise = this.promise;
        var handler = this.handler;

        if (!this.called) {
            this.called = true;
            var ret = this.isFinallyHandler() ? handler.call(promise._boundValue()) : handler.call(promise._boundValue(), reasonOrValue);
            if (ret === NEXT_FILTER) {
                return ret;
            } else if (ret !== undefined) {
                promise._setReturnedNonUndefined();
                var maybePromise = tryConvertToPromise(ret, promise);
                if (maybePromise instanceof Promise) {
                    if (this.cancelPromise != null) {
                        if (maybePromise._isCancelled()) {
                            var reason = new CancellationError("late cancellation observer");
                            promise._attachExtraTrace(reason);
                            errorObj.e = reason;
                            return errorObj;
                        } else if (maybePromise.isPending()) {
                            maybePromise._attachCancellationCallback(new FinallyHandlerCancelReaction(this));
                        }
                    }
                    return maybePromise._then(succeed, fail, undefined, this, undefined);
                }
            }
        }

        if (promise.isRejected()) {
            checkCancel(this);
            errorObj.e = reasonOrValue;
            return errorObj;
        } else {
            checkCancel(this);
            return reasonOrValue;
        }
    }

    Promise.prototype._passThrough = function (handler, type, success, fail) {
        if (typeof handler !== "function") return this.then();
        return this._then(success, fail, undefined, new PassThroughHandlerContext(this, type, handler), undefined);
    };

    Promise.prototype.lastly = Promise.prototype["finally"] = function (handler) {
        return this._passThrough(handler, 0, finallyHandler, finallyHandler);
    };

    Promise.prototype.tap = function (handler) {
        return this._passThrough(handler, 1, finallyHandler);
    };

    Promise.prototype.tapCatch = function (handlerOrPredicate) {
        var len = arguments.length;
        if (len === 1) {
            return this._passThrough(handlerOrPredicate, 1, undefined, finallyHandler);
        } else {
            var catchInstances = new Array(len - 1),
                j = 0,
                i;
            for (i = 0; i < len - 1; ++i) {
                var item = arguments[i];
                if (util.isObject(item)) {
                    catchInstances[j++] = item;
                } else {
                    return Promise.reject(new TypeError("tapCatch statement predicate: " + "expecting an object but got " + util.classString(item)));
                }
            }
            catchInstances.length = j;
            var handler = arguments[i];
            return this._passThrough(catchFilter(catchInstances, handler, this), 1, undefined, finallyHandler);
        }
    };

    return PassThroughHandlerContext;
};

/***/ }),
/* 79 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = function (Promise, INTERNAL, tryConvertToPromise, apiRejection, debug) {
    var util = __webpack_require__(1);
    var tryCatch = util.tryCatch;

    Promise.method = function (fn) {
        if (typeof fn !== "function") {
            throw new Promise.TypeError("expecting a function but got " + util.classString(fn));
        }
        return function () {
            var ret = new Promise(INTERNAL);
            ret._captureStackTrace();
            ret._pushContext();
            var value = tryCatch(fn).apply(this, arguments);
            var promiseCreated = ret._popContext();
            debug.checkForgottenReturns(value, promiseCreated, "Promise.method", ret);
            ret._resolveFromSyncValue(value);
            return ret;
        };
    };

    Promise.attempt = Promise["try"] = function (fn) {
        if (typeof fn !== "function") {
            return apiRejection("expecting a function but got " + util.classString(fn));
        }
        var ret = new Promise(INTERNAL);
        ret._captureStackTrace();
        ret._pushContext();
        var value;
        if (arguments.length > 1) {
            debug.deprecated("calling Promise.try with more than 1 argument");
            var arg = arguments[1];
            var ctx = arguments[2];
            value = util.isArray(arg) ? tryCatch(fn).apply(ctx, arg) : tryCatch(fn).call(ctx, arg);
        } else {
            value = tryCatch(fn)();
        }
        var promiseCreated = ret._popContext();
        debug.checkForgottenReturns(value, promiseCreated, "Promise.try", ret);
        ret._resolveFromSyncValue(value);
        return ret;
    };

    Promise.prototype._resolveFromSyncValue = function (value) {
        if (value === util.errorObj) {
            this._rejectCallback(value.e, false);
        } else {
            this._resolveCallback(value, true);
        }
    };
};

/***/ }),
/* 80 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = function (Promise, INTERNAL, tryConvertToPromise, debug) {
    var calledBind = false;
    var rejectThis = function (_, e) {
        this._reject(e);
    };

    var targetRejected = function (e, context) {
        context.promiseRejectionQueued = true;
        context.bindingPromise._then(rejectThis, rejectThis, null, this, e);
    };

    var bindingResolved = function (thisArg, context) {
        if ((this._bitField & 50397184) === 0) {
            this._resolveCallback(context.target);
        }
    };

    var bindingRejected = function (e, context) {
        if (!context.promiseRejectionQueued) this._reject(e);
    };

    Promise.prototype.bind = function (thisArg) {
        if (!calledBind) {
            calledBind = true;
            Promise.prototype._propagateFrom = debug.propagateFromFunction();
            Promise.prototype._boundValue = debug.boundValueFunction();
        }
        var maybePromise = tryConvertToPromise(thisArg);
        var ret = new Promise(INTERNAL);
        ret._propagateFrom(this, 1);
        var target = this._target();
        ret._setBoundTo(maybePromise);
        if (maybePromise instanceof Promise) {
            var context = {
                promiseRejectionQueued: false,
                promise: ret,
                target: target,
                bindingPromise: maybePromise
            };
            target._then(INTERNAL, targetRejected, undefined, ret, context);
            maybePromise._then(bindingResolved, bindingRejected, undefined, ret, context);
            ret._setOnCancel(maybePromise);
        } else {
            ret._resolveCallback(target);
        }
        return ret;
    };

    Promise.prototype._setBoundTo = function (obj) {
        if (obj !== undefined) {
            this._bitField = this._bitField | 2097152;
            this._boundTo = obj;
        } else {
            this._bitField = this._bitField & ~2097152;
        }
    };

    Promise.prototype._isBound = function () {
        return (this._bitField & 2097152) === 2097152;
    };

    Promise.bind = function (thisArg, value) {
        return Promise.resolve(value).bind(thisArg);
    };
};

/***/ }),
/* 81 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = function (Promise, PromiseArray, apiRejection, debug) {
    var util = __webpack_require__(1);
    var tryCatch = util.tryCatch;
    var errorObj = util.errorObj;
    var async = Promise._async;

    Promise.prototype["break"] = Promise.prototype.cancel = function () {
        if (!debug.cancellation()) return this._warn("cancellation is disabled");

        var promise = this;
        var child = promise;
        while (promise._isCancellable()) {
            if (!promise._cancelBy(child)) {
                if (child._isFollowing()) {
                    child._followee().cancel();
                } else {
                    child._cancelBranched();
                }
                break;
            }

            var parent = promise._cancellationParent;
            if (parent == null || !parent._isCancellable()) {
                if (promise._isFollowing()) {
                    promise._followee().cancel();
                } else {
                    promise._cancelBranched();
                }
                break;
            } else {
                if (promise._isFollowing()) promise._followee().cancel();
                promise._setWillBeCancelled();
                child = promise;
                promise = parent;
            }
        }
    };

    Promise.prototype._branchHasCancelled = function () {
        this._branchesRemainingToCancel--;
    };

    Promise.prototype._enoughBranchesHaveCancelled = function () {
        return this._branchesRemainingToCancel === undefined || this._branchesRemainingToCancel <= 0;
    };

    Promise.prototype._cancelBy = function (canceller) {
        if (canceller === this) {
            this._branchesRemainingToCancel = 0;
            this._invokeOnCancel();
            return true;
        } else {
            this._branchHasCancelled();
            if (this._enoughBranchesHaveCancelled()) {
                this._invokeOnCancel();
                return true;
            }
        }
        return false;
    };

    Promise.prototype._cancelBranched = function () {
        if (this._enoughBranchesHaveCancelled()) {
            this._cancel();
        }
    };

    Promise.prototype._cancel = function () {
        if (!this._isCancellable()) return;
        this._setCancelled();
        async.invoke(this._cancelPromises, this, undefined);
    };

    Promise.prototype._cancelPromises = function () {
        if (this._length() > 0) this._settlePromises();
    };

    Promise.prototype._unsetOnCancel = function () {
        this._onCancelField = undefined;
    };

    Promise.prototype._isCancellable = function () {
        return this.isPending() && !this._isCancelled();
    };

    Promise.prototype.isCancellable = function () {
        return this.isPending() && !this.isCancelled();
    };

    Promise.prototype._doInvokeOnCancel = function (onCancelCallback, internalOnly) {
        if (util.isArray(onCancelCallback)) {
            for (var i = 0; i < onCancelCallback.length; ++i) {
                this._doInvokeOnCancel(onCancelCallback[i], internalOnly);
            }
        } else if (onCancelCallback !== undefined) {
            if (typeof onCancelCallback === "function") {
                if (!internalOnly) {
                    var e = tryCatch(onCancelCallback).call(this._boundValue());
                    if (e === errorObj) {
                        this._attachExtraTrace(e.e);
                        async.throwLater(e.e);
                    }
                }
            } else {
                onCancelCallback._resultCancelled(this);
            }
        }
    };

    Promise.prototype._invokeOnCancel = function () {
        var onCancelCallback = this._onCancel();
        this._unsetOnCancel();
        async.invoke(this._doInvokeOnCancel, this, onCancelCallback);
    };

    Promise.prototype._invokeInternalOnCancel = function () {
        if (this._isCancellable()) {
            this._doInvokeOnCancel(this._onCancel(), true);
            this._unsetOnCancel();
        }
    };

    Promise.prototype._resultCancelled = function () {
        this.cancel();
    };
};

/***/ }),
/* 82 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = function (Promise) {
    function returner() {
        return this.value;
    }
    function thrower() {
        throw this.reason;
    }

    Promise.prototype["return"] = Promise.prototype.thenReturn = function (value) {
        if (value instanceof Promise) value.suppressUnhandledRejections();
        return this._then(returner, undefined, undefined, { value: value }, undefined);
    };

    Promise.prototype["throw"] = Promise.prototype.thenThrow = function (reason) {
        return this._then(thrower, undefined, undefined, { reason: reason }, undefined);
    };

    Promise.prototype.catchThrow = function (reason) {
        if (arguments.length <= 1) {
            return this._then(undefined, thrower, undefined, { reason: reason }, undefined);
        } else {
            var _reason = arguments[1];
            var handler = function () {
                throw _reason;
            };
            return this.caught(reason, handler);
        }
    };

    Promise.prototype.catchReturn = function (value) {
        if (arguments.length <= 1) {
            if (value instanceof Promise) value.suppressUnhandledRejections();
            return this._then(undefined, returner, undefined, { value: value }, undefined);
        } else {
            var _value = arguments[1];
            if (_value instanceof Promise) _value.suppressUnhandledRejections();
            var handler = function () {
                return _value;
            };
            return this.caught(value, handler);
        }
    };
};

/***/ }),
/* 83 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = function (Promise) {
    function PromiseInspection(promise) {
        if (promise !== undefined) {
            promise = promise._target();
            this._bitField = promise._bitField;
            this._settledValueField = promise._isFateSealed() ? promise._settledValue() : undefined;
        } else {
            this._bitField = 0;
            this._settledValueField = undefined;
        }
    }

    PromiseInspection.prototype._settledValue = function () {
        return this._settledValueField;
    };

    var value = PromiseInspection.prototype.value = function () {
        if (!this.isFulfilled()) {
            throw new TypeError("cannot get fulfillment value of a non-fulfilled promise\u000a\u000a    See http://goo.gl/MqrFmX\u000a");
        }
        return this._settledValue();
    };

    var reason = PromiseInspection.prototype.error = PromiseInspection.prototype.reason = function () {
        if (!this.isRejected()) {
            throw new TypeError("cannot get rejection reason of a non-rejected promise\u000a\u000a    See http://goo.gl/MqrFmX\u000a");
        }
        return this._settledValue();
    };

    var isFulfilled = PromiseInspection.prototype.isFulfilled = function () {
        return (this._bitField & 33554432) !== 0;
    };

    var isRejected = PromiseInspection.prototype.isRejected = function () {
        return (this._bitField & 16777216) !== 0;
    };

    var isPending = PromiseInspection.prototype.isPending = function () {
        return (this._bitField & 50397184) === 0;
    };

    var isResolved = PromiseInspection.prototype.isResolved = function () {
        return (this._bitField & 50331648) !== 0;
    };

    PromiseInspection.prototype.isCancelled = function () {
        return (this._bitField & 8454144) !== 0;
    };

    Promise.prototype.__isCancelled = function () {
        return (this._bitField & 65536) === 65536;
    };

    Promise.prototype._isCancelled = function () {
        return this._target().__isCancelled();
    };

    Promise.prototype.isCancelled = function () {
        return (this._target()._bitField & 8454144) !== 0;
    };

    Promise.prototype.isPending = function () {
        return isPending.call(this._target());
    };

    Promise.prototype.isRejected = function () {
        return isRejected.call(this._target());
    };

    Promise.prototype.isFulfilled = function () {
        return isFulfilled.call(this._target());
    };

    Promise.prototype.isResolved = function () {
        return isResolved.call(this._target());
    };

    Promise.prototype.value = function () {
        return value.call(this._target());
    };

    Promise.prototype.reason = function () {
        var target = this._target();
        target._unsetRejectionIsUnhandled();
        return reason.call(target);
    };

    Promise.prototype._value = function () {
        return this._settledValue();
    };

    Promise.prototype._reason = function () {
        this._unsetRejectionIsUnhandled();
        return this._settledValue();
    };

    Promise.PromiseInspection = PromiseInspection;
};

/***/ }),
/* 84 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = function (Promise, PromiseArray, tryConvertToPromise, INTERNAL, async, getDomain) {
    var util = __webpack_require__(1);
    var canEvaluate = util.canEvaluate;
    var tryCatch = util.tryCatch;
    var errorObj = util.errorObj;
    var reject;

    if (true) {
        if (canEvaluate) {
            var thenCallback = function (i) {
                return new Function("value", "holder", "                             \n\
            'use strict';                                                    \n\
            holder.pIndex = value;                                           \n\
            holder.checkFulfillment(this);                                   \n\
            ".replace(/Index/g, i));
            };

            var promiseSetter = function (i) {
                return new Function("promise", "holder", "                           \n\
            'use strict';                                                    \n\
            holder.pIndex = promise;                                         \n\
            ".replace(/Index/g, i));
            };

            var generateHolderClass = function (total) {
                var props = new Array(total);
                for (var i = 0; i < props.length; ++i) {
                    props[i] = "this.p" + (i + 1);
                }
                var assignment = props.join(" = ") + " = null;";
                var cancellationCode = "var promise;\n" + props.map(function (prop) {
                    return "                                                         \n\
                promise = " + prop + ";                                      \n\
                if (promise instanceof Promise) {                            \n\
                    promise.cancel();                                        \n\
                }                                                            \n\
            ";
                }).join("\n");
                var passedArguments = props.join(", ");
                var name = "Holder$" + total;

                var code = "return function(tryCatch, errorObj, Promise, async) {    \n\
            'use strict';                                                    \n\
            function [TheName](fn) {                                         \n\
                [TheProperties]                                              \n\
                this.fn = fn;                                                \n\
                this.asyncNeeded = true;                                     \n\
                this.now = 0;                                                \n\
            }                                                                \n\
                                                                             \n\
            [TheName].prototype._callFunction = function(promise) {          \n\
                promise._pushContext();                                      \n\
                var ret = tryCatch(this.fn)([ThePassedArguments]);           \n\
                promise._popContext();                                       \n\
                if (ret === errorObj) {                                      \n\
                    promise._rejectCallback(ret.e, false);                   \n\
                } else {                                                     \n\
                    promise._resolveCallback(ret);                           \n\
                }                                                            \n\
            };                                                               \n\
                                                                             \n\
            [TheName].prototype.checkFulfillment = function(promise) {       \n\
                var now = ++this.now;                                        \n\
                if (now === [TheTotal]) {                                    \n\
                    if (this.asyncNeeded) {                                  \n\
                        async.invoke(this._callFunction, this, promise);     \n\
                    } else {                                                 \n\
                        this._callFunction(promise);                         \n\
                    }                                                        \n\
                                                                             \n\
                }                                                            \n\
            };                                                               \n\
                                                                             \n\
            [TheName].prototype._resultCancelled = function() {              \n\
                [CancellationCode]                                           \n\
            };                                                               \n\
                                                                             \n\
            return [TheName];                                                \n\
        }(tryCatch, errorObj, Promise, async);                               \n\
        ";

                code = code.replace(/\[TheName\]/g, name).replace(/\[TheTotal\]/g, total).replace(/\[ThePassedArguments\]/g, passedArguments).replace(/\[TheProperties\]/g, assignment).replace(/\[CancellationCode\]/g, cancellationCode);

                return new Function("tryCatch", "errorObj", "Promise", "async", code)(tryCatch, errorObj, Promise, async);
            };

            var holderClasses = [];
            var thenCallbacks = [];
            var promiseSetters = [];

            for (var i = 0; i < 8; ++i) {
                holderClasses.push(generateHolderClass(i + 1));
                thenCallbacks.push(thenCallback(i + 1));
                promiseSetters.push(promiseSetter(i + 1));
            }

            reject = function (reason) {
                this._reject(reason);
            };
        }
    }

    Promise.join = function () {
        var last = arguments.length - 1;
        var fn;
        if (last > 0 && typeof arguments[last] === "function") {
            fn = arguments[last];
            if (true) {
                if (last <= 8 && canEvaluate) {
                    var ret = new Promise(INTERNAL);
                    ret._captureStackTrace();
                    var HolderClass = holderClasses[last - 1];
                    var holder = new HolderClass(fn);
                    var callbacks = thenCallbacks;

                    for (var i = 0; i < last; ++i) {
                        var maybePromise = tryConvertToPromise(arguments[i], ret);
                        if (maybePromise instanceof Promise) {
                            maybePromise = maybePromise._target();
                            var bitField = maybePromise._bitField;
                            ;
                            if ((bitField & 50397184) === 0) {
                                maybePromise._then(callbacks[i], reject, undefined, ret, holder);
                                promiseSetters[i](maybePromise, holder);
                                holder.asyncNeeded = false;
                            } else if ((bitField & 33554432) !== 0) {
                                callbacks[i].call(ret, maybePromise._value(), holder);
                            } else if ((bitField & 16777216) !== 0) {
                                ret._reject(maybePromise._reason());
                            } else {
                                ret._cancel();
                            }
                        } else {
                            callbacks[i].call(ret, maybePromise, holder);
                        }
                    }

                    if (!ret._isFateSealed()) {
                        if (holder.asyncNeeded) {
                            var domain = getDomain();
                            if (domain !== null) {
                                holder.fn = util.domainBind(domain, holder.fn);
                            }
                        }
                        ret._setAsyncGuaranteed();
                        ret._setOnCancel(holder);
                    }
                    return ret;
                }
            }
        }
        var $_len = arguments.length;var args = new Array($_len);for (var $_i = 0; $_i < $_len; ++$_i) {
            args[$_i] = arguments[$_i];
        };
        if (fn) args.pop();
        var ret = new PromiseArray(args).promise();
        return fn !== undefined ? ret.spread(fn) : ret;
    };
};

/***/ }),
/* 85 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = function (Promise, PromiseArray, apiRejection, tryConvertToPromise, INTERNAL, debug) {
    var getDomain = Promise._getDomain;
    var util = __webpack_require__(1);
    var tryCatch = util.tryCatch;
    var errorObj = util.errorObj;
    var async = Promise._async;

    function MappingPromiseArray(promises, fn, limit, _filter) {
        this.constructor$(promises);
        this._promise._captureStackTrace();
        var domain = getDomain();
        this._callback = domain === null ? fn : util.domainBind(domain, fn);
        this._preservedValues = _filter === INTERNAL ? new Array(this.length()) : null;
        this._limit = limit;
        this._inFlight = 0;
        this._queue = [];
        async.invoke(this._asyncInit, this, undefined);
    }
    util.inherits(MappingPromiseArray, PromiseArray);

    MappingPromiseArray.prototype._asyncInit = function () {
        this._init$(undefined, -2);
    };

    MappingPromiseArray.prototype._init = function () {};

    MappingPromiseArray.prototype._promiseFulfilled = function (value, index) {
        var values = this._values;
        var length = this.length();
        var preservedValues = this._preservedValues;
        var limit = this._limit;

        if (index < 0) {
            index = index * -1 - 1;
            values[index] = value;
            if (limit >= 1) {
                this._inFlight--;
                this._drainQueue();
                if (this._isResolved()) return true;
            }
        } else {
            if (limit >= 1 && this._inFlight >= limit) {
                values[index] = value;
                this._queue.push(index);
                return false;
            }
            if (preservedValues !== null) preservedValues[index] = value;

            var promise = this._promise;
            var callback = this._callback;
            var receiver = promise._boundValue();
            promise._pushContext();
            var ret = tryCatch(callback).call(receiver, value, index, length);
            var promiseCreated = promise._popContext();
            debug.checkForgottenReturns(ret, promiseCreated, preservedValues !== null ? "Promise.filter" : "Promise.map", promise);
            if (ret === errorObj) {
                this._reject(ret.e);
                return true;
            }

            var maybePromise = tryConvertToPromise(ret, this._promise);
            if (maybePromise instanceof Promise) {
                maybePromise = maybePromise._target();
                var bitField = maybePromise._bitField;
                ;
                if ((bitField & 50397184) === 0) {
                    if (limit >= 1) this._inFlight++;
                    values[index] = maybePromise;
                    maybePromise._proxy(this, (index + 1) * -1);
                    return false;
                } else if ((bitField & 33554432) !== 0) {
                    ret = maybePromise._value();
                } else if ((bitField & 16777216) !== 0) {
                    this._reject(maybePromise._reason());
                    return true;
                } else {
                    this._cancel();
                    return true;
                }
            }
            values[index] = ret;
        }
        var totalResolved = ++this._totalResolved;
        if (totalResolved >= length) {
            if (preservedValues !== null) {
                this._filter(values, preservedValues);
            } else {
                this._resolve(values);
            }
            return true;
        }
        return false;
    };

    MappingPromiseArray.prototype._drainQueue = function () {
        var queue = this._queue;
        var limit = this._limit;
        var values = this._values;
        while (queue.length > 0 && this._inFlight < limit) {
            if (this._isResolved()) return;
            var index = queue.pop();
            this._promiseFulfilled(values[index], index);
        }
    };

    MappingPromiseArray.prototype._filter = function (booleans, values) {
        var len = values.length;
        var ret = new Array(len);
        var j = 0;
        for (var i = 0; i < len; ++i) {
            if (booleans[i]) ret[j++] = values[i];
        }
        ret.length = j;
        this._resolve(ret);
    };

    MappingPromiseArray.prototype.preservedValues = function () {
        return this._preservedValues;
    };

    function map(promises, fn, options, _filter) {
        if (typeof fn !== "function") {
            return apiRejection("expecting a function but got " + util.classString(fn));
        }

        var limit = 0;
        if (options !== undefined) {
            if (typeof options === "object" && options !== null) {
                if (typeof options.concurrency !== "number") {
                    return Promise.reject(new TypeError("'concurrency' must be a number but it is " + util.classString(options.concurrency)));
                }
                limit = options.concurrency;
            } else {
                return Promise.reject(new TypeError("options argument must be an object but it is " + util.classString(options)));
            }
        }
        limit = typeof limit === "number" && isFinite(limit) && limit >= 1 ? limit : 0;
        return new MappingPromiseArray(promises, fn, limit, _filter).promise();
    }

    Promise.prototype.map = function (fn, options) {
        return map(this, fn, options, null);
    };

    Promise.map = function (promises, fn, options, _filter) {
        return map(promises, fn, options, _filter);
    };
};

/***/ }),
/* 86 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var cr = Object.create;
if (cr) {
    var callerCache = cr(null);
    var getterCache = cr(null);
    callerCache[" size"] = getterCache[" size"] = 0;
}

module.exports = function (Promise) {
    var util = __webpack_require__(1);
    var canEvaluate = util.canEvaluate;
    var isIdentifier = util.isIdentifier;

    var getMethodCaller;
    var getGetter;
    if (true) {
        var makeMethodCaller = function (methodName) {
            return new Function("ensureMethod", "                                    \n\
        return function(obj) {                                               \n\
            'use strict'                                                     \n\
            var len = this.length;                                           \n\
            ensureMethod(obj, 'methodName');                                 \n\
            switch(len) {                                                    \n\
                case 1: return obj.methodName(this[0]);                      \n\
                case 2: return obj.methodName(this[0], this[1]);             \n\
                case 3: return obj.methodName(this[0], this[1], this[2]);    \n\
                case 0: return obj.methodName();                             \n\
                default:                                                     \n\
                    return obj.methodName.apply(obj, this);                  \n\
            }                                                                \n\
        };                                                                   \n\
        ".replace(/methodName/g, methodName))(ensureMethod);
        };

        var makeGetter = function (propertyName) {
            return new Function("obj", "                                             \n\
        'use strict';                                                        \n\
        return obj.propertyName;                                             \n\
        ".replace("propertyName", propertyName));
        };

        var getCompiled = function (name, compiler, cache) {
            var ret = cache[name];
            if (typeof ret !== "function") {
                if (!isIdentifier(name)) {
                    return null;
                }
                ret = compiler(name);
                cache[name] = ret;
                cache[" size"]++;
                if (cache[" size"] > 512) {
                    var keys = Object.keys(cache);
                    for (var i = 0; i < 256; ++i) delete cache[keys[i]];
                    cache[" size"] = keys.length - 256;
                }
            }
            return ret;
        };

        getMethodCaller = function (name) {
            return getCompiled(name, makeMethodCaller, callerCache);
        };

        getGetter = function (name) {
            return getCompiled(name, makeGetter, getterCache);
        };
    }

    function ensureMethod(obj, methodName) {
        var fn;
        if (obj != null) fn = obj[methodName];
        if (typeof fn !== "function") {
            var message = "Object " + util.classString(obj) + " has no method '" + util.toString(methodName) + "'";
            throw new Promise.TypeError(message);
        }
        return fn;
    }

    function caller(obj) {
        var methodName = this.pop();
        var fn = ensureMethod(obj, methodName);
        return fn.apply(obj, this);
    }
    Promise.prototype.call = function (methodName) {
        var $_len = arguments.length;var args = new Array(Math.max($_len - 1, 0));for (var $_i = 1; $_i < $_len; ++$_i) {
            args[$_i - 1] = arguments[$_i];
        };
        if (true) {
            if (canEvaluate) {
                var maybeCaller = getMethodCaller(methodName);
                if (maybeCaller !== null) {
                    return this._then(maybeCaller, undefined, undefined, args, undefined);
                }
            }
        }
        args.push(methodName);
        return this._then(caller, undefined, undefined, args, undefined);
    };

    function namedGetter(obj) {
        return obj[this];
    }
    function indexedGetter(obj) {
        var index = +this;
        if (index < 0) index = Math.max(0, index + obj.length);
        return obj[index];
    }
    Promise.prototype.get = function (propertyName) {
        var isIndex = typeof propertyName === "number";
        var getter;
        if (!isIndex) {
            if (canEvaluate) {
                var maybeGetter = getGetter(propertyName);
                getter = maybeGetter !== null ? maybeGetter : namedGetter;
            } else {
                getter = namedGetter;
            }
        } else {
            getter = indexedGetter;
        }
        return this._then(getter, undefined, undefined, propertyName, undefined);
    };
};

/***/ }),
/* 87 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = function (Promise, apiRejection, tryConvertToPromise, createContext, INTERNAL, debug) {
    var util = __webpack_require__(1);
    var TypeError = __webpack_require__(11).TypeError;
    var inherits = __webpack_require__(1).inherits;
    var errorObj = util.errorObj;
    var tryCatch = util.tryCatch;
    var NULL = {};

    function thrower(e) {
        setTimeout(function () {
            throw e;
        }, 0);
    }

    function castPreservingDisposable(thenable) {
        var maybePromise = tryConvertToPromise(thenable);
        if (maybePromise !== thenable && typeof thenable._isDisposable === "function" && typeof thenable._getDisposer === "function" && thenable._isDisposable()) {
            maybePromise._setDisposable(thenable._getDisposer());
        }
        return maybePromise;
    }
    function dispose(resources, inspection) {
        var i = 0;
        var len = resources.length;
        var ret = new Promise(INTERNAL);
        function iterator() {
            if (i >= len) return ret._fulfill();
            var maybePromise = castPreservingDisposable(resources[i++]);
            if (maybePromise instanceof Promise && maybePromise._isDisposable()) {
                try {
                    maybePromise = tryConvertToPromise(maybePromise._getDisposer().tryDispose(inspection), resources.promise);
                } catch (e) {
                    return thrower(e);
                }
                if (maybePromise instanceof Promise) {
                    return maybePromise._then(iterator, thrower, null, null, null);
                }
            }
            iterator();
        }
        iterator();
        return ret;
    }

    function Disposer(data, promise, context) {
        this._data = data;
        this._promise = promise;
        this._context = context;
    }

    Disposer.prototype.data = function () {
        return this._data;
    };

    Disposer.prototype.promise = function () {
        return this._promise;
    };

    Disposer.prototype.resource = function () {
        if (this.promise().isFulfilled()) {
            return this.promise().value();
        }
        return NULL;
    };

    Disposer.prototype.tryDispose = function (inspection) {
        var resource = this.resource();
        var context = this._context;
        if (context !== undefined) context._pushContext();
        var ret = resource !== NULL ? this.doDispose(resource, inspection) : null;
        if (context !== undefined) context._popContext();
        this._promise._unsetDisposable();
        this._data = null;
        return ret;
    };

    Disposer.isDisposer = function (d) {
        return d != null && typeof d.resource === "function" && typeof d.tryDispose === "function";
    };

    function FunctionDisposer(fn, promise, context) {
        this.constructor$(fn, promise, context);
    }
    inherits(FunctionDisposer, Disposer);

    FunctionDisposer.prototype.doDispose = function (resource, inspection) {
        var fn = this.data();
        return fn.call(resource, resource, inspection);
    };

    function maybeUnwrapDisposer(value) {
        if (Disposer.isDisposer(value)) {
            this.resources[this.index]._setDisposable(value);
            return value.promise();
        }
        return value;
    }

    function ResourceList(length) {
        this.length = length;
        this.promise = null;
        this[length - 1] = null;
    }

    ResourceList.prototype._resultCancelled = function () {
        var len = this.length;
        for (var i = 0; i < len; ++i) {
            var item = this[i];
            if (item instanceof Promise) {
                item.cancel();
            }
        }
    };

    Promise.using = function () {
        var len = arguments.length;
        if (len < 2) return apiRejection("you must pass at least 2 arguments to Promise.using");
        var fn = arguments[len - 1];
        if (typeof fn !== "function") {
            return apiRejection("expecting a function but got " + util.classString(fn));
        }
        var input;
        var spreadArgs = true;
        if (len === 2 && Array.isArray(arguments[0])) {
            input = arguments[0];
            len = input.length;
            spreadArgs = false;
        } else {
            input = arguments;
            len--;
        }
        var resources = new ResourceList(len);
        for (var i = 0; i < len; ++i) {
            var resource = input[i];
            if (Disposer.isDisposer(resource)) {
                var disposer = resource;
                resource = resource.promise();
                resource._setDisposable(disposer);
            } else {
                var maybePromise = tryConvertToPromise(resource);
                if (maybePromise instanceof Promise) {
                    resource = maybePromise._then(maybeUnwrapDisposer, null, null, {
                        resources: resources,
                        index: i
                    }, undefined);
                }
            }
            resources[i] = resource;
        }

        var reflectedResources = new Array(resources.length);
        for (var i = 0; i < reflectedResources.length; ++i) {
            reflectedResources[i] = Promise.resolve(resources[i]).reflect();
        }

        var resultPromise = Promise.all(reflectedResources).then(function (inspections) {
            for (var i = 0; i < inspections.length; ++i) {
                var inspection = inspections[i];
                if (inspection.isRejected()) {
                    errorObj.e = inspection.error();
                    return errorObj;
                } else if (!inspection.isFulfilled()) {
                    resultPromise.cancel();
                    return;
                }
                inspections[i] = inspection.value();
            }
            promise._pushContext();

            fn = tryCatch(fn);
            var ret = spreadArgs ? fn.apply(undefined, inspections) : fn(inspections);
            var promiseCreated = promise._popContext();
            debug.checkForgottenReturns(ret, promiseCreated, "Promise.using", promise);
            return ret;
        });

        var promise = resultPromise.lastly(function () {
            var inspection = new Promise.PromiseInspection(resultPromise);
            return dispose(resources, inspection);
        });
        resources.promise = promise;
        promise._setOnCancel(resources);
        return promise;
    };

    Promise.prototype._setDisposable = function (disposer) {
        this._bitField = this._bitField | 131072;
        this._disposer = disposer;
    };

    Promise.prototype._isDisposable = function () {
        return (this._bitField & 131072) > 0;
    };

    Promise.prototype._getDisposer = function () {
        return this._disposer;
    };

    Promise.prototype._unsetDisposable = function () {
        this._bitField = this._bitField & ~131072;
        this._disposer = undefined;
    };

    Promise.prototype.disposer = function (fn) {
        if (typeof fn === "function") {
            return new FunctionDisposer(fn, this, createContext());
        }
        throw new TypeError();
    };
};

/***/ }),
/* 88 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = function (Promise, INTERNAL, debug) {
    var util = __webpack_require__(1);
    var TimeoutError = Promise.TimeoutError;

    function HandleWrapper(handle) {
        this.handle = handle;
    }

    HandleWrapper.prototype._resultCancelled = function () {
        clearTimeout(this.handle);
    };

    var afterValue = function (value) {
        return delay(+this).thenReturn(value);
    };
    var delay = Promise.delay = function (ms, value) {
        var ret;
        var handle;
        if (value !== undefined) {
            ret = Promise.resolve(value)._then(afterValue, null, null, ms, undefined);
            if (debug.cancellation() && value instanceof Promise) {
                ret._setOnCancel(value);
            }
        } else {
            ret = new Promise(INTERNAL);
            handle = setTimeout(function () {
                ret._fulfill();
            }, +ms);
            if (debug.cancellation()) {
                ret._setOnCancel(new HandleWrapper(handle));
            }
            ret._captureStackTrace();
        }
        ret._setAsyncGuaranteed();
        return ret;
    };

    Promise.prototype.delay = function (ms) {
        return delay(ms, this);
    };

    var afterTimeout = function (promise, message, parent) {
        var err;
        if (typeof message !== "string") {
            if (message instanceof Error) {
                err = message;
            } else {
                err = new TimeoutError("operation timed out");
            }
        } else {
            err = new TimeoutError(message);
        }
        util.markAsOriginatingFromRejection(err);
        promise._attachExtraTrace(err);
        promise._reject(err);

        if (parent != null) {
            parent.cancel();
        }
    };

    function successClear(value) {
        clearTimeout(this.handle);
        return value;
    }

    function failureClear(reason) {
        clearTimeout(this.handle);
        throw reason;
    }

    Promise.prototype.timeout = function (ms, message) {
        ms = +ms;
        var ret, parent;

        var handleWrapper = new HandleWrapper(setTimeout(function timeoutTimeout() {
            if (ret.isPending()) {
                afterTimeout(ret, message, parent);
            }
        }, ms));

        if (debug.cancellation()) {
            parent = this.then();
            ret = parent._then(successClear, failureClear, undefined, handleWrapper, undefined);
            ret._setOnCancel(handleWrapper);
        } else {
            ret = this._then(successClear, failureClear, undefined, handleWrapper, undefined);
        }

        return ret;
    };
};

/***/ }),
/* 89 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = function (Promise, apiRejection, INTERNAL, tryConvertToPromise, Proxyable, debug) {
    var errors = __webpack_require__(11);
    var TypeError = errors.TypeError;
    var util = __webpack_require__(1);
    var errorObj = util.errorObj;
    var tryCatch = util.tryCatch;
    var yieldHandlers = [];

    function promiseFromYieldHandler(value, yieldHandlers, traceParent) {
        for (var i = 0; i < yieldHandlers.length; ++i) {
            traceParent._pushContext();
            var result = tryCatch(yieldHandlers[i])(value);
            traceParent._popContext();
            if (result === errorObj) {
                traceParent._pushContext();
                var ret = Promise.reject(errorObj.e);
                traceParent._popContext();
                return ret;
            }
            var maybePromise = tryConvertToPromise(result, traceParent);
            if (maybePromise instanceof Promise) return maybePromise;
        }
        return null;
    }

    function PromiseSpawn(generatorFunction, receiver, yieldHandler, stack) {
        if (debug.cancellation()) {
            var internal = new Promise(INTERNAL);
            var _finallyPromise = this._finallyPromise = new Promise(INTERNAL);
            this._promise = internal.lastly(function () {
                return _finallyPromise;
            });
            internal._captureStackTrace();
            internal._setOnCancel(this);
        } else {
            var promise = this._promise = new Promise(INTERNAL);
            promise._captureStackTrace();
        }
        this._stack = stack;
        this._generatorFunction = generatorFunction;
        this._receiver = receiver;
        this._generator = undefined;
        this._yieldHandlers = typeof yieldHandler === "function" ? [yieldHandler].concat(yieldHandlers) : yieldHandlers;
        this._yieldedPromise = null;
        this._cancellationPhase = false;
    }
    util.inherits(PromiseSpawn, Proxyable);

    PromiseSpawn.prototype._isResolved = function () {
        return this._promise === null;
    };

    PromiseSpawn.prototype._cleanup = function () {
        this._promise = this._generator = null;
        if (debug.cancellation() && this._finallyPromise !== null) {
            this._finallyPromise._fulfill();
            this._finallyPromise = null;
        }
    };

    PromiseSpawn.prototype._promiseCancelled = function () {
        if (this._isResolved()) return;
        var implementsReturn = typeof this._generator["return"] !== "undefined";

        var result;
        if (!implementsReturn) {
            var reason = new Promise.CancellationError("generator .return() sentinel");
            Promise.coroutine.returnSentinel = reason;
            this._promise._attachExtraTrace(reason);
            this._promise._pushContext();
            result = tryCatch(this._generator["throw"]).call(this._generator, reason);
            this._promise._popContext();
        } else {
            this._promise._pushContext();
            result = tryCatch(this._generator["return"]).call(this._generator, undefined);
            this._promise._popContext();
        }
        this._cancellationPhase = true;
        this._yieldedPromise = null;
        this._continue(result);
    };

    PromiseSpawn.prototype._promiseFulfilled = function (value) {
        this._yieldedPromise = null;
        this._promise._pushContext();
        var result = tryCatch(this._generator.next).call(this._generator, value);
        this._promise._popContext();
        this._continue(result);
    };

    PromiseSpawn.prototype._promiseRejected = function (reason) {
        this._yieldedPromise = null;
        this._promise._attachExtraTrace(reason);
        this._promise._pushContext();
        var result = tryCatch(this._generator["throw"]).call(this._generator, reason);
        this._promise._popContext();
        this._continue(result);
    };

    PromiseSpawn.prototype._resultCancelled = function () {
        if (this._yieldedPromise instanceof Promise) {
            var promise = this._yieldedPromise;
            this._yieldedPromise = null;
            promise.cancel();
        }
    };

    PromiseSpawn.prototype.promise = function () {
        return this._promise;
    };

    PromiseSpawn.prototype._run = function () {
        this._generator = this._generatorFunction.call(this._receiver);
        this._receiver = this._generatorFunction = undefined;
        this._promiseFulfilled(undefined);
    };

    PromiseSpawn.prototype._continue = function (result) {
        var promise = this._promise;
        if (result === errorObj) {
            this._cleanup();
            if (this._cancellationPhase) {
                return promise.cancel();
            } else {
                return promise._rejectCallback(result.e, false);
            }
        }

        var value = result.value;
        if (result.done === true) {
            this._cleanup();
            if (this._cancellationPhase) {
                return promise.cancel();
            } else {
                return promise._resolveCallback(value);
            }
        } else {
            var maybePromise = tryConvertToPromise(value, this._promise);
            if (!(maybePromise instanceof Promise)) {
                maybePromise = promiseFromYieldHandler(maybePromise, this._yieldHandlers, this._promise);
                if (maybePromise === null) {
                    this._promiseRejected(new TypeError("A value %s was yielded that could not be treated as a promise\u000a\u000a    See http://goo.gl/MqrFmX\u000a\u000a".replace("%s", String(value)) + "From coroutine:\u000a" + this._stack.split("\n").slice(1, -7).join("\n")));
                    return;
                }
            }
            maybePromise = maybePromise._target();
            var bitField = maybePromise._bitField;
            ;
            if ((bitField & 50397184) === 0) {
                this._yieldedPromise = maybePromise;
                maybePromise._proxy(this, null);
            } else if ((bitField & 33554432) !== 0) {
                Promise._async.invoke(this._promiseFulfilled, this, maybePromise._value());
            } else if ((bitField & 16777216) !== 0) {
                Promise._async.invoke(this._promiseRejected, this, maybePromise._reason());
            } else {
                this._promiseCancelled();
            }
        }
    };

    Promise.coroutine = function (generatorFunction, options) {
        if (typeof generatorFunction !== "function") {
            throw new TypeError("generatorFunction must be a function\u000a\u000a    See http://goo.gl/MqrFmX\u000a");
        }
        var yieldHandler = Object(options).yieldHandler;
        var PromiseSpawn$ = PromiseSpawn;
        var stack = new Error().stack;
        return function () {
            var generator = generatorFunction.apply(this, arguments);
            var spawn = new PromiseSpawn$(undefined, undefined, yieldHandler, stack);
            var ret = spawn.promise();
            spawn._generator = generator;
            spawn._promiseFulfilled(undefined);
            return ret;
        };
    };

    Promise.coroutine.addYieldHandler = function (fn) {
        if (typeof fn !== "function") {
            throw new TypeError("expecting a function but got " + util.classString(fn));
        }
        yieldHandlers.push(fn);
    };

    Promise.spawn = function (generatorFunction) {
        debug.deprecated("Promise.spawn()", "Promise.coroutine()");
        if (typeof generatorFunction !== "function") {
            return apiRejection("generatorFunction must be a function\u000a\u000a    See http://goo.gl/MqrFmX\u000a");
        }
        var spawn = new PromiseSpawn(generatorFunction, this);
        var ret = spawn.promise();
        spawn._run(Promise.spawn);
        return ret;
    };
};

/***/ }),
/* 90 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = function (Promise) {
    var util = __webpack_require__(1);
    var async = Promise._async;
    var tryCatch = util.tryCatch;
    var errorObj = util.errorObj;

    function spreadAdapter(val, nodeback) {
        var promise = this;
        if (!util.isArray(val)) return successAdapter.call(promise, val, nodeback);
        var ret = tryCatch(nodeback).apply(promise._boundValue(), [null].concat(val));
        if (ret === errorObj) {
            async.throwLater(ret.e);
        }
    }

    function successAdapter(val, nodeback) {
        var promise = this;
        var receiver = promise._boundValue();
        var ret = val === undefined ? tryCatch(nodeback).call(receiver, null) : tryCatch(nodeback).call(receiver, null, val);
        if (ret === errorObj) {
            async.throwLater(ret.e);
        }
    }
    function errorAdapter(reason, nodeback) {
        var promise = this;
        if (!reason) {
            var newReason = new Error(reason + "");
            newReason.cause = reason;
            reason = newReason;
        }
        var ret = tryCatch(nodeback).call(promise._boundValue(), reason);
        if (ret === errorObj) {
            async.throwLater(ret.e);
        }
    }

    Promise.prototype.asCallback = Promise.prototype.nodeify = function (nodeback, options) {
        if (typeof nodeback == "function") {
            var adapter = successAdapter;
            if (options !== undefined && Object(options).spread) {
                adapter = spreadAdapter;
            }
            this._then(adapter, errorAdapter, undefined, this, nodeback);
        }
        return this;
    };
};

/***/ }),
/* 91 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = function (Promise, INTERNAL) {
    var THIS = {};
    var util = __webpack_require__(1);
    var nodebackForPromise = __webpack_require__(39);
    var withAppended = util.withAppended;
    var maybeWrapAsError = util.maybeWrapAsError;
    var canEvaluate = util.canEvaluate;
    var TypeError = __webpack_require__(11).TypeError;
    var defaultSuffix = "Async";
    var defaultPromisified = { __isPromisified__: true };
    var noCopyProps = ["arity", "length", "name", "arguments", "caller", "callee", "prototype", "__isPromisified__"];
    var noCopyPropsPattern = new RegExp("^(?:" + noCopyProps.join("|") + ")$");

    var defaultFilter = function (name) {
        return util.isIdentifier(name) && name.charAt(0) !== "_" && name !== "constructor";
    };

    function propsFilter(key) {
        return !noCopyPropsPattern.test(key);
    }

    function isPromisified(fn) {
        try {
            return fn.__isPromisified__ === true;
        } catch (e) {
            return false;
        }
    }

    function hasPromisified(obj, key, suffix) {
        var val = util.getDataPropertyOrDefault(obj, key + suffix, defaultPromisified);
        return val ? isPromisified(val) : false;
    }
    function checkValid(ret, suffix, suffixRegexp) {
        for (var i = 0; i < ret.length; i += 2) {
            var key = ret[i];
            if (suffixRegexp.test(key)) {
                var keyWithoutAsyncSuffix = key.replace(suffixRegexp, "");
                for (var j = 0; j < ret.length; j += 2) {
                    if (ret[j] === keyWithoutAsyncSuffix) {
                        throw new TypeError("Cannot promisify an API that has normal methods with '%s'-suffix\u000a\u000a    See http://goo.gl/MqrFmX\u000a".replace("%s", suffix));
                    }
                }
            }
        }
    }

    function promisifiableMethods(obj, suffix, suffixRegexp, filter) {
        var keys = util.inheritedDataKeys(obj);
        var ret = [];
        for (var i = 0; i < keys.length; ++i) {
            var key = keys[i];
            var value = obj[key];
            var passesDefaultFilter = filter === defaultFilter ? true : defaultFilter(key, value, obj);
            if (typeof value === "function" && !isPromisified(value) && !hasPromisified(obj, key, suffix) && filter(key, value, obj, passesDefaultFilter)) {
                ret.push(key, value);
            }
        }
        checkValid(ret, suffix, suffixRegexp);
        return ret;
    }

    var escapeIdentRegex = function (str) {
        return str.replace(/([$])/, "\\$");
    };

    var makeNodePromisifiedEval;
    if (true) {
        var switchCaseArgumentOrder = function (likelyArgumentCount) {
            var ret = [likelyArgumentCount];
            var min = Math.max(0, likelyArgumentCount - 1 - 3);
            for (var i = likelyArgumentCount - 1; i >= min; --i) {
                ret.push(i);
            }
            for (var i = likelyArgumentCount + 1; i <= 3; ++i) {
                ret.push(i);
            }
            return ret;
        };

        var argumentSequence = function (argumentCount) {
            return util.filledRange(argumentCount, "_arg", "");
        };

        var parameterDeclaration = function (parameterCount) {
            return util.filledRange(Math.max(parameterCount, 3), "_arg", "");
        };

        var parameterCount = function (fn) {
            if (typeof fn.length === "number") {
                return Math.max(Math.min(fn.length, 1023 + 1), 0);
            }
            return 0;
        };

        makeNodePromisifiedEval = function (callback, receiver, originalName, fn, _, multiArgs) {
            var newParameterCount = Math.max(0, parameterCount(fn) - 1);
            var argumentOrder = switchCaseArgumentOrder(newParameterCount);
            var shouldProxyThis = typeof callback === "string" || receiver === THIS;

            function generateCallForArgumentCount(count) {
                var args = argumentSequence(count).join(", ");
                var comma = count > 0 ? ", " : "";
                var ret;
                if (shouldProxyThis) {
                    ret = "ret = callback.call(this, {{args}}, nodeback); break;\n";
                } else {
                    ret = receiver === undefined ? "ret = callback({{args}}, nodeback); break;\n" : "ret = callback.call(receiver, {{args}}, nodeback); break;\n";
                }
                return ret.replace("{{args}}", args).replace(", ", comma);
            }

            function generateArgumentSwitchCase() {
                var ret = "";
                for (var i = 0; i < argumentOrder.length; ++i) {
                    ret += "case " + argumentOrder[i] + ":" + generateCallForArgumentCount(argumentOrder[i]);
                }

                ret += "                                                             \n\
        default:                                                             \n\
            var args = new Array(len + 1);                                   \n\
            var i = 0;                                                       \n\
            for (var i = 0; i < len; ++i) {                                  \n\
               args[i] = arguments[i];                                       \n\
            }                                                                \n\
            args[i] = nodeback;                                              \n\
            [CodeForCall]                                                    \n\
            break;                                                           \n\
        ".replace("[CodeForCall]", shouldProxyThis ? "ret = callback.apply(this, args);\n" : "ret = callback.apply(receiver, args);\n");
                return ret;
            }

            var getFunctionCode = typeof callback === "string" ? "this != null ? this['" + callback + "'] : fn" : "fn";
            var body = "'use strict';                                                \n\
        var ret = function (Parameters) {                                    \n\
            'use strict';                                                    \n\
            var len = arguments.length;                                      \n\
            var promise = new Promise(INTERNAL);                             \n\
            promise._captureStackTrace();                                    \n\
            var nodeback = nodebackForPromise(promise, " + multiArgs + ");   \n\
            var ret;                                                         \n\
            var callback = tryCatch([GetFunctionCode]);                      \n\
            switch(len) {                                                    \n\
                [CodeForSwitchCase]                                          \n\
            }                                                                \n\
            if (ret === errorObj) {                                          \n\
                promise._rejectCallback(maybeWrapAsError(ret.e), true, true);\n\
            }                                                                \n\
            if (!promise._isFateSealed()) promise._setAsyncGuaranteed();     \n\
            return promise;                                                  \n\
        };                                                                   \n\
        notEnumerableProp(ret, '__isPromisified__', true);                   \n\
        return ret;                                                          \n\
    ".replace("[CodeForSwitchCase]", generateArgumentSwitchCase()).replace("[GetFunctionCode]", getFunctionCode);
            body = body.replace("Parameters", parameterDeclaration(newParameterCount));
            return new Function("Promise", "fn", "receiver", "withAppended", "maybeWrapAsError", "nodebackForPromise", "tryCatch", "errorObj", "notEnumerableProp", "INTERNAL", body)(Promise, fn, receiver, withAppended, maybeWrapAsError, nodebackForPromise, util.tryCatch, util.errorObj, util.notEnumerableProp, INTERNAL);
        };
    }

    function makeNodePromisifiedClosure(callback, receiver, _, fn, __, multiArgs) {
        var defaultThis = function () {
            return this;
        }();
        var method = callback;
        if (typeof method === "string") {
            callback = fn;
        }
        function promisified() {
            var _receiver = receiver;
            if (receiver === THIS) _receiver = this;
            var promise = new Promise(INTERNAL);
            promise._captureStackTrace();
            var cb = typeof method === "string" && this !== defaultThis ? this[method] : callback;
            var fn = nodebackForPromise(promise, multiArgs);
            try {
                cb.apply(_receiver, withAppended(arguments, fn));
            } catch (e) {
                promise._rejectCallback(maybeWrapAsError(e), true, true);
            }
            if (!promise._isFateSealed()) promise._setAsyncGuaranteed();
            return promise;
        }
        util.notEnumerableProp(promisified, "__isPromisified__", true);
        return promisified;
    }

    var makeNodePromisified = canEvaluate ? makeNodePromisifiedEval : makeNodePromisifiedClosure;

    function promisifyAll(obj, suffix, filter, promisifier, multiArgs) {
        var suffixRegexp = new RegExp(escapeIdentRegex(suffix) + "$");
        var methods = promisifiableMethods(obj, suffix, suffixRegexp, filter);

        for (var i = 0, len = methods.length; i < len; i += 2) {
            var key = methods[i];
            var fn = methods[i + 1];
            var promisifiedKey = key + suffix;
            if (promisifier === makeNodePromisified) {
                obj[promisifiedKey] = makeNodePromisified(key, THIS, key, fn, suffix, multiArgs);
            } else {
                var promisified = promisifier(fn, function () {
                    return makeNodePromisified(key, THIS, key, fn, suffix, multiArgs);
                });
                util.notEnumerableProp(promisified, "__isPromisified__", true);
                obj[promisifiedKey] = promisified;
            }
        }
        util.toFastProperties(obj);
        return obj;
    }

    function promisify(callback, receiver, multiArgs) {
        return makeNodePromisified(callback, receiver, undefined, callback, null, multiArgs);
    }

    Promise.promisify = function (fn, options) {
        if (typeof fn !== "function") {
            throw new TypeError("expecting a function but got " + util.classString(fn));
        }
        if (isPromisified(fn)) {
            return fn;
        }
        options = Object(options);
        var receiver = options.context === undefined ? THIS : options.context;
        var multiArgs = !!options.multiArgs;
        var ret = promisify(fn, receiver, multiArgs);
        util.copyDescriptors(fn, ret, propsFilter);
        return ret;
    };

    Promise.promisifyAll = function (target, options) {
        if (typeof target !== "function" && typeof target !== "object") {
            throw new TypeError("the target of promisifyAll must be an object or a function\u000a\u000a    See http://goo.gl/MqrFmX\u000a");
        }
        options = Object(options);
        var multiArgs = !!options.multiArgs;
        var suffix = options.suffix;
        if (typeof suffix !== "string") suffix = defaultSuffix;
        var filter = options.filter;
        if (typeof filter !== "function") filter = defaultFilter;
        var promisifier = options.promisifier;
        if (typeof promisifier !== "function") promisifier = makeNodePromisified;

        if (!util.isIdentifier(suffix)) {
            throw new RangeError("suffix must be a valid identifier\u000a\u000a    See http://goo.gl/MqrFmX\u000a");
        }

        var keys = util.inheritedDataKeys(target);
        for (var i = 0; i < keys.length; ++i) {
            var value = target[keys[i]];
            if (keys[i] !== "constructor" && util.isClass(value)) {
                promisifyAll(value.prototype, suffix, filter, promisifier, multiArgs);
                promisifyAll(value, suffix, filter, promisifier, multiArgs);
            }
        }

        return promisifyAll(target, suffix, filter, promisifier, multiArgs);
    };
};

/***/ }),
/* 92 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = function (Promise, PromiseArray, tryConvertToPromise, apiRejection) {
    var util = __webpack_require__(1);
    var isObject = util.isObject;
    var es5 = __webpack_require__(16);
    var Es6Map;
    if (typeof Map === "function") Es6Map = Map;

    var mapToEntries = function () {
        var index = 0;
        var size = 0;

        function extractEntry(value, key) {
            this[index] = value;
            this[index + size] = key;
            index++;
        }

        return function mapToEntries(map) {
            size = map.size;
            index = 0;
            var ret = new Array(map.size * 2);
            map.forEach(extractEntry, ret);
            return ret;
        };
    }();

    var entriesToMap = function (entries) {
        var ret = new Es6Map();
        var length = entries.length / 2 | 0;
        for (var i = 0; i < length; ++i) {
            var key = entries[length + i];
            var value = entries[i];
            ret.set(key, value);
        }
        return ret;
    };

    function PropertiesPromiseArray(obj) {
        var isMap = false;
        var entries;
        if (Es6Map !== undefined && obj instanceof Es6Map) {
            entries = mapToEntries(obj);
            isMap = true;
        } else {
            var keys = es5.keys(obj);
            var len = keys.length;
            entries = new Array(len * 2);
            for (var i = 0; i < len; ++i) {
                var key = keys[i];
                entries[i] = obj[key];
                entries[i + len] = key;
            }
        }
        this.constructor$(entries);
        this._isMap = isMap;
        this._init$(undefined, isMap ? -6 : -3);
    }
    util.inherits(PropertiesPromiseArray, PromiseArray);

    PropertiesPromiseArray.prototype._init = function () {};

    PropertiesPromiseArray.prototype._promiseFulfilled = function (value, index) {
        this._values[index] = value;
        var totalResolved = ++this._totalResolved;
        if (totalResolved >= this._length) {
            var val;
            if (this._isMap) {
                val = entriesToMap(this._values);
            } else {
                val = {};
                var keyOffset = this.length();
                for (var i = 0, len = this.length(); i < len; ++i) {
                    val[this._values[i + keyOffset]] = this._values[i];
                }
            }
            this._resolve(val);
            return true;
        }
        return false;
    };

    PropertiesPromiseArray.prototype.shouldCopyValues = function () {
        return false;
    };

    PropertiesPromiseArray.prototype.getActualLength = function (len) {
        return len >> 1;
    };

    function props(promises) {
        var ret;
        var castValue = tryConvertToPromise(promises);

        if (!isObject(castValue)) {
            return apiRejection("cannot await properties of a non-object\u000a\u000a    See http://goo.gl/MqrFmX\u000a");
        } else if (castValue instanceof Promise) {
            ret = castValue._then(Promise.props, undefined, undefined, undefined, undefined);
        } else {
            ret = new PropertiesPromiseArray(castValue).promise();
        }

        if (castValue instanceof Promise) {
            ret._propagateFrom(castValue, 2);
        }
        return ret;
    }

    Promise.prototype.props = function () {
        return props(this);
    };

    Promise.props = function (promises) {
        return props(promises);
    };
};

/***/ }),
/* 93 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = function (Promise, INTERNAL, tryConvertToPromise, apiRejection) {
    var util = __webpack_require__(1);

    var raceLater = function (promise) {
        return promise.then(function (array) {
            return race(array, promise);
        });
    };

    function race(promises, parent) {
        var maybePromise = tryConvertToPromise(promises);

        if (maybePromise instanceof Promise) {
            return raceLater(maybePromise);
        } else {
            promises = util.asArray(promises);
            if (promises === null) return apiRejection("expecting an array or an iterable object but got " + util.classString(promises));
        }

        var ret = new Promise(INTERNAL);
        if (parent !== undefined) {
            ret._propagateFrom(parent, 3);
        }
        var fulfill = ret._fulfill;
        var reject = ret._reject;
        for (var i = 0, len = promises.length; i < len; ++i) {
            var val = promises[i];

            if (val === undefined && !(i in promises)) {
                continue;
            }

            Promise.cast(val)._then(fulfill, reject, undefined, ret, null);
        }
        return ret;
    }

    Promise.race = function (promises) {
        return race(promises, undefined);
    };

    Promise.prototype.race = function () {
        return race(this, undefined);
    };
};

/***/ }),
/* 94 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = function (Promise, PromiseArray, apiRejection, tryConvertToPromise, INTERNAL, debug) {
    var getDomain = Promise._getDomain;
    var util = __webpack_require__(1);
    var tryCatch = util.tryCatch;

    function ReductionPromiseArray(promises, fn, initialValue, _each) {
        this.constructor$(promises);
        var domain = getDomain();
        this._fn = domain === null ? fn : util.domainBind(domain, fn);
        if (initialValue !== undefined) {
            initialValue = Promise.resolve(initialValue);
            initialValue._attachCancellationCallback(this);
        }
        this._initialValue = initialValue;
        this._currentCancellable = null;
        if (_each === INTERNAL) {
            this._eachValues = Array(this._length);
        } else if (_each === 0) {
            this._eachValues = null;
        } else {
            this._eachValues = undefined;
        }
        this._promise._captureStackTrace();
        this._init$(undefined, -5);
    }
    util.inherits(ReductionPromiseArray, PromiseArray);

    ReductionPromiseArray.prototype._gotAccum = function (accum) {
        if (this._eachValues !== undefined && this._eachValues !== null && accum !== INTERNAL) {
            this._eachValues.push(accum);
        }
    };

    ReductionPromiseArray.prototype._eachComplete = function (value) {
        if (this._eachValues !== null) {
            this._eachValues.push(value);
        }
        return this._eachValues;
    };

    ReductionPromiseArray.prototype._init = function () {};

    ReductionPromiseArray.prototype._resolveEmptyArray = function () {
        this._resolve(this._eachValues !== undefined ? this._eachValues : this._initialValue);
    };

    ReductionPromiseArray.prototype.shouldCopyValues = function () {
        return false;
    };

    ReductionPromiseArray.prototype._resolve = function (value) {
        this._promise._resolveCallback(value);
        this._values = null;
    };

    ReductionPromiseArray.prototype._resultCancelled = function (sender) {
        if (sender === this._initialValue) return this._cancel();
        if (this._isResolved()) return;
        this._resultCancelled$();
        if (this._currentCancellable instanceof Promise) {
            this._currentCancellable.cancel();
        }
        if (this._initialValue instanceof Promise) {
            this._initialValue.cancel();
        }
    };

    ReductionPromiseArray.prototype._iterate = function (values) {
        this._values = values;
        var value;
        var i;
        var length = values.length;
        if (this._initialValue !== undefined) {
            value = this._initialValue;
            i = 0;
        } else {
            value = Promise.resolve(values[0]);
            i = 1;
        }

        this._currentCancellable = value;

        if (!value.isRejected()) {
            for (; i < length; ++i) {
                var ctx = {
                    accum: null,
                    value: values[i],
                    index: i,
                    length: length,
                    array: this
                };
                value = value._then(gotAccum, undefined, undefined, ctx, undefined);
            }
        }

        if (this._eachValues !== undefined) {
            value = value._then(this._eachComplete, undefined, undefined, this, undefined);
        }
        value._then(completed, completed, undefined, value, this);
    };

    Promise.prototype.reduce = function (fn, initialValue) {
        return reduce(this, fn, initialValue, null);
    };

    Promise.reduce = function (promises, fn, initialValue, _each) {
        return reduce(promises, fn, initialValue, _each);
    };

    function completed(valueOrReason, array) {
        if (this.isFulfilled()) {
            array._resolve(valueOrReason);
        } else {
            array._reject(valueOrReason);
        }
    }

    function reduce(promises, fn, initialValue, _each) {
        if (typeof fn !== "function") {
            return apiRejection("expecting a function but got " + util.classString(fn));
        }
        var array = new ReductionPromiseArray(promises, fn, initialValue, _each);
        return array.promise();
    }

    function gotAccum(accum) {
        this.accum = accum;
        this.array._gotAccum(accum);
        var value = tryConvertToPromise(this.value, this.array._promise);
        if (value instanceof Promise) {
            this.array._currentCancellable = value;
            return value._then(gotValue, undefined, undefined, this, undefined);
        } else {
            return gotValue.call(this, value);
        }
    }

    function gotValue(value) {
        var array = this.array;
        var promise = array._promise;
        var fn = tryCatch(array._fn);
        promise._pushContext();
        var ret;
        if (array._eachValues !== undefined) {
            ret = fn.call(promise._boundValue(), value, this.index, this.length);
        } else {
            ret = fn.call(promise._boundValue(), this.accum, value, this.index, this.length);
        }
        if (ret instanceof Promise) {
            array._currentCancellable = ret;
        }
        var promiseCreated = promise._popContext();
        debug.checkForgottenReturns(ret, promiseCreated, array._eachValues !== undefined ? "Promise.each" : "Promise.reduce", promise);
        return ret;
    }
};

/***/ }),
/* 95 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = function (Promise, PromiseArray, debug) {
    var PromiseInspection = Promise.PromiseInspection;
    var util = __webpack_require__(1);

    function SettledPromiseArray(values) {
        this.constructor$(values);
    }
    util.inherits(SettledPromiseArray, PromiseArray);

    SettledPromiseArray.prototype._promiseResolved = function (index, inspection) {
        this._values[index] = inspection;
        var totalResolved = ++this._totalResolved;
        if (totalResolved >= this._length) {
            this._resolve(this._values);
            return true;
        }
        return false;
    };

    SettledPromiseArray.prototype._promiseFulfilled = function (value, index) {
        var ret = new PromiseInspection();
        ret._bitField = 33554432;
        ret._settledValueField = value;
        return this._promiseResolved(index, ret);
    };
    SettledPromiseArray.prototype._promiseRejected = function (reason, index) {
        var ret = new PromiseInspection();
        ret._bitField = 16777216;
        ret._settledValueField = reason;
        return this._promiseResolved(index, ret);
    };

    Promise.settle = function (promises) {
        debug.deprecated(".settle()", ".reflect()");
        return new SettledPromiseArray(promises).promise();
    };

    Promise.prototype.settle = function () {
        return Promise.settle(this);
    };
};

/***/ }),
/* 96 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = function (Promise, PromiseArray, apiRejection) {
    var util = __webpack_require__(1);
    var RangeError = __webpack_require__(11).RangeError;
    var AggregateError = __webpack_require__(11).AggregateError;
    var isArray = util.isArray;
    var CANCELLATION = {};

    function SomePromiseArray(values) {
        this.constructor$(values);
        this._howMany = 0;
        this._unwrap = false;
        this._initialized = false;
    }
    util.inherits(SomePromiseArray, PromiseArray);

    SomePromiseArray.prototype._init = function () {
        if (!this._initialized) {
            return;
        }
        if (this._howMany === 0) {
            this._resolve([]);
            return;
        }
        this._init$(undefined, -5);
        var isArrayResolved = isArray(this._values);
        if (!this._isResolved() && isArrayResolved && this._howMany > this._canPossiblyFulfill()) {
            this._reject(this._getRangeError(this.length()));
        }
    };

    SomePromiseArray.prototype.init = function () {
        this._initialized = true;
        this._init();
    };

    SomePromiseArray.prototype.setUnwrap = function () {
        this._unwrap = true;
    };

    SomePromiseArray.prototype.howMany = function () {
        return this._howMany;
    };

    SomePromiseArray.prototype.setHowMany = function (count) {
        this._howMany = count;
    };

    SomePromiseArray.prototype._promiseFulfilled = function (value) {
        this._addFulfilled(value);
        if (this._fulfilled() === this.howMany()) {
            this._values.length = this.howMany();
            if (this.howMany() === 1 && this._unwrap) {
                this._resolve(this._values[0]);
            } else {
                this._resolve(this._values);
            }
            return true;
        }
        return false;
    };
    SomePromiseArray.prototype._promiseRejected = function (reason) {
        this._addRejected(reason);
        return this._checkOutcome();
    };

    SomePromiseArray.prototype._promiseCancelled = function () {
        if (this._values instanceof Promise || this._values == null) {
            return this._cancel();
        }
        this._addRejected(CANCELLATION);
        return this._checkOutcome();
    };

    SomePromiseArray.prototype._checkOutcome = function () {
        if (this.howMany() > this._canPossiblyFulfill()) {
            var e = new AggregateError();
            for (var i = this.length(); i < this._values.length; ++i) {
                if (this._values[i] !== CANCELLATION) {
                    e.push(this._values[i]);
                }
            }
            if (e.length > 0) {
                this._reject(e);
            } else {
                this._cancel();
            }
            return true;
        }
        return false;
    };

    SomePromiseArray.prototype._fulfilled = function () {
        return this._totalResolved;
    };

    SomePromiseArray.prototype._rejected = function () {
        return this._values.length - this.length();
    };

    SomePromiseArray.prototype._addRejected = function (reason) {
        this._values.push(reason);
    };

    SomePromiseArray.prototype._addFulfilled = function (value) {
        this._values[this._totalResolved++] = value;
    };

    SomePromiseArray.prototype._canPossiblyFulfill = function () {
        return this.length() - this._rejected();
    };

    SomePromiseArray.prototype._getRangeError = function (count) {
        var message = "Input array must contain at least " + this._howMany + " items but contains only " + count + " items";
        return new RangeError(message);
    };

    SomePromiseArray.prototype._resolveEmptyArray = function () {
        this._reject(this._getRangeError(0));
    };

    function some(promises, howMany) {
        if ((howMany | 0) !== howMany || howMany < 0) {
            return apiRejection("expecting a positive integer\u000a\u000a    See http://goo.gl/MqrFmX\u000a");
        }
        var ret = new SomePromiseArray(promises);
        var promise = ret.promise();
        ret.setHowMany(howMany);
        ret.init();
        return promise;
    }

    Promise.some = function (promises, howMany) {
        return some(promises, howMany);
    };

    Promise.prototype.some = function (howMany) {
        return some(this, howMany);
    };

    Promise._SomePromiseArray = SomePromiseArray;
};

/***/ }),
/* 97 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = function (Promise, INTERNAL) {
    var PromiseMap = Promise.map;

    Promise.prototype.filter = function (fn, options) {
        return PromiseMap(this, fn, options, INTERNAL);
    };

    Promise.filter = function (promises, fn, options) {
        return PromiseMap(promises, fn, options, INTERNAL);
    };
};

/***/ }),
/* 98 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = function (Promise, INTERNAL) {
    var PromiseReduce = Promise.reduce;
    var PromiseAll = Promise.all;

    function promiseAllThis() {
        return PromiseAll(this);
    }

    function PromiseMapSeries(promises, fn) {
        return PromiseReduce(promises, fn, INTERNAL, INTERNAL);
    }

    Promise.prototype.each = function (fn) {
        return PromiseReduce(this, fn, INTERNAL, 0)._then(promiseAllThis, undefined, undefined, this, undefined);
    };

    Promise.prototype.mapSeries = function (fn) {
        return PromiseReduce(this, fn, INTERNAL, INTERNAL);
    };

    Promise.each = function (promises, fn) {
        return PromiseReduce(promises, fn, INTERNAL, 0)._then(promiseAllThis, undefined, undefined, promises, undefined);
    };

    Promise.mapSeries = PromiseMapSeries;
};

/***/ }),
/* 99 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = function (Promise) {
    var SomePromiseArray = Promise._SomePromiseArray;
    function any(promises) {
        var ret = new SomePromiseArray(promises);
        var promise = ret.promise();
        ret.setHowMany(1);
        ret.setUnwrap();
        ret.init();
        return promise;
    }

    Promise.any = function (promises) {
        return any(promises);
    };

    Promise.prototype.any = function () {
        return any(this);
    };
};

/***/ }),
/* 100 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * Detect Electron renderer process, which is node, but we should
 * treat as a browser.
 */

if (typeof process === 'undefined' || process.type === 'renderer') {
  module.exports = __webpack_require__(101);
} else {
  module.exports = __webpack_require__(103);
}

/***/ }),
/* 101 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * This is the web browser implementation of `debug()`.
 *
 * Expose `debug()` as the module.
 */

exports = module.exports = __webpack_require__(43);
exports.log = log;
exports.formatArgs = formatArgs;
exports.save = save;
exports.load = load;
exports.useColors = useColors;
exports.storage = 'undefined' != typeof chrome && 'undefined' != typeof chrome.storage ? chrome.storage.local : localstorage();

/**
 * Colors.
 */

exports.colors = ['#0000CC', '#0000FF', '#0033CC', '#0033FF', '#0066CC', '#0066FF', '#0099CC', '#0099FF', '#00CC00', '#00CC33', '#00CC66', '#00CC99', '#00CCCC', '#00CCFF', '#3300CC', '#3300FF', '#3333CC', '#3333FF', '#3366CC', '#3366FF', '#3399CC', '#3399FF', '#33CC00', '#33CC33', '#33CC66', '#33CC99', '#33CCCC', '#33CCFF', '#6600CC', '#6600FF', '#6633CC', '#6633FF', '#66CC00', '#66CC33', '#9900CC', '#9900FF', '#9933CC', '#9933FF', '#99CC00', '#99CC33', '#CC0000', '#CC0033', '#CC0066', '#CC0099', '#CC00CC', '#CC00FF', '#CC3300', '#CC3333', '#CC3366', '#CC3399', '#CC33CC', '#CC33FF', '#CC6600', '#CC6633', '#CC9900', '#CC9933', '#CCCC00', '#CCCC33', '#FF0000', '#FF0033', '#FF0066', '#FF0099', '#FF00CC', '#FF00FF', '#FF3300', '#FF3333', '#FF3366', '#FF3399', '#FF33CC', '#FF33FF', '#FF6600', '#FF6633', '#FF9900', '#FF9933', '#FFCC00', '#FFCC33'];

/**
 * Currently only WebKit-based Web Inspectors, Firefox >= v31,
 * and the Firebug extension (any Firefox version) are known
 * to support "%c" CSS customizations.
 *
 * TODO: add a `localStorage` variable to explicitly enable/disable colors
 */

function useColors() {
  // NB: In an Electron preload script, document will be defined but not fully
  // initialized. Since we know we're in Chrome, we'll just detect this case
  // explicitly
  if (typeof window !== 'undefined' && window.process && window.process.type === 'renderer') {
    return true;
  }

  // Internet Explorer and Edge do not support colors.
  if (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
    return false;
  }

  // is webkit? http://stackoverflow.com/a/16459606/376773
  // document is undefined in react-native: https://github.com/facebook/react-native/pull/1632
  return typeof document !== 'undefined' && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance ||
  // is firebug? http://stackoverflow.com/a/398120/376773
  typeof window !== 'undefined' && window.console && (window.console.firebug || window.console.exception && window.console.table) ||
  // is firefox >= v31?
  // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
  typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31 ||
  // double check webkit in userAgent just in case we are in a worker
  typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
}

/**
 * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.
 */

exports.formatters.j = function (v) {
  try {
    return JSON.stringify(v);
  } catch (err) {
    return '[UnexpectedJSONParseError]: ' + err.message;
  }
};

/**
 * Colorize log arguments if enabled.
 *
 * @api public
 */

function formatArgs(args) {
  var useColors = this.useColors;

  args[0] = (useColors ? '%c' : '') + this.namespace + (useColors ? ' %c' : ' ') + args[0] + (useColors ? '%c ' : ' ') + '+' + exports.humanize(this.diff);

  if (!useColors) return;

  var c = 'color: ' + this.color;
  args.splice(1, 0, c, 'color: inherit');

  // the final "%c" is somewhat tricky, because there could be other
  // arguments passed either before or after the %c, so we need to
  // figure out the correct index to insert the CSS into
  var index = 0;
  var lastC = 0;
  args[0].replace(/%[a-zA-Z%]/g, function (match) {
    if ('%%' === match) return;
    index++;
    if ('%c' === match) {
      // we only are interested in the *last* %c
      // (the user may have provided their own)
      lastC = index;
    }
  });

  args.splice(lastC, 0, c);
}

/**
 * Invokes `console.log()` when available.
 * No-op when `console.log` is not a "function".
 *
 * @api public
 */

function log() {
  // this hackery is required for IE8/9, where
  // the `console.log` function doesn't have 'apply'
  return 'object' === typeof console && console.log && Function.prototype.apply.call(console.log, console, arguments);
}

/**
 * Save `namespaces`.
 *
 * @param {String} namespaces
 * @api private
 */

function save(namespaces) {
  try {
    if (null == namespaces) {
      exports.storage.removeItem('debug');
    } else {
      exports.storage.debug = namespaces;
    }
  } catch (e) {}
}

/**
 * Load `namespaces`.
 *
 * @return {String} returns the previously persisted debug modes
 * @api private
 */

function load() {
  var r;
  try {
    r = exports.storage.debug;
  } catch (e) {}

  // If debug isn't set in LS, and we're in Electron, try to load $DEBUG
  if (!r && typeof process !== 'undefined' && 'env' in process) {
    r = process.env.DEBUG;
  }

  return r;
}

/**
 * Enable namespaces listed in `localStorage.debug` initially.
 */

exports.enable(load());

/**
 * Localstorage attempts to return the localstorage.
 *
 * This is necessary because safari throws
 * when a user disables cookies/localstorage
 * and you attempt to access it.
 *
 * @return {LocalStorage}
 * @api private
 */

function localstorage() {
  try {
    return window.localStorage;
  } catch (e) {}
}

/***/ }),
/* 102 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * Helpers.
 */

var s = 1000;
var m = s * 60;
var h = m * 60;
var d = h * 24;
var y = d * 365.25;

/**
 * Parse or format the given `val`.
 *
 * Options:
 *
 *  - `long` verbose formatting [false]
 *
 * @param {String|Number} val
 * @param {Object} [options]
 * @throws {Error} throw an error if val is not a non-empty string or a number
 * @return {String|Number}
 * @api public
 */

module.exports = function (val, options) {
  options = options || {};
  var type = typeof val;
  if (type === 'string' && val.length > 0) {
    return parse(val);
  } else if (type === 'number' && isNaN(val) === false) {
    return options.long ? fmtLong(val) : fmtShort(val);
  }
  throw new Error('val is not a non-empty string or a valid number. val=' + JSON.stringify(val));
};

/**
 * Parse the given `str` and return milliseconds.
 *
 * @param {String} str
 * @return {Number}
 * @api private
 */

function parse(str) {
  str = String(str);
  if (str.length > 100) {
    return;
  }
  var match = /^((?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|years?|yrs?|y)?$/i.exec(str);
  if (!match) {
    return;
  }
  var n = parseFloat(match[1]);
  var type = (match[2] || 'ms').toLowerCase();
  switch (type) {
    case 'years':
    case 'year':
    case 'yrs':
    case 'yr':
    case 'y':
      return n * y;
    case 'days':
    case 'day':
    case 'd':
      return n * d;
    case 'hours':
    case 'hour':
    case 'hrs':
    case 'hr':
    case 'h':
      return n * h;
    case 'minutes':
    case 'minute':
    case 'mins':
    case 'min':
    case 'm':
      return n * m;
    case 'seconds':
    case 'second':
    case 'secs':
    case 'sec':
    case 's':
      return n * s;
    case 'milliseconds':
    case 'millisecond':
    case 'msecs':
    case 'msec':
    case 'ms':
      return n;
    default:
      return undefined;
  }
}

/**
 * Short format for `ms`.
 *
 * @param {Number} ms
 * @return {String}
 * @api private
 */

function fmtShort(ms) {
  if (ms >= d) {
    return Math.round(ms / d) + 'd';
  }
  if (ms >= h) {
    return Math.round(ms / h) + 'h';
  }
  if (ms >= m) {
    return Math.round(ms / m) + 'm';
  }
  if (ms >= s) {
    return Math.round(ms / s) + 's';
  }
  return ms + 'ms';
}

/**
 * Long format for `ms`.
 *
 * @param {Number} ms
 * @return {String}
 * @api private
 */

function fmtLong(ms) {
  return plural(ms, d, 'day') || plural(ms, h, 'hour') || plural(ms, m, 'minute') || plural(ms, s, 'second') || ms + ' ms';
}

/**
 * Pluralization helper.
 */

function plural(ms, n, name) {
  if (ms < n) {
    return;
  }
  if (ms < n * 1.5) {
    return Math.floor(ms / n) + ' ' + name;
  }
  return Math.ceil(ms / n) + ' ' + name + 's';
}

/***/ }),
/* 103 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * Module dependencies.
 */

var tty = __webpack_require__(104);
var util = __webpack_require__(29);

/**
 * This is the Node.js implementation of `debug()`.
 *
 * Expose `debug()` as the module.
 */

exports = module.exports = __webpack_require__(43);
exports.init = init;
exports.log = log;
exports.formatArgs = formatArgs;
exports.save = save;
exports.load = load;
exports.useColors = useColors;

/**
 * Colors.
 */

exports.colors = [6, 2, 3, 4, 5, 1];

try {
  var supportsColor = __webpack_require__(105);
  if (supportsColor && supportsColor.level >= 2) {
    exports.colors = [20, 21, 26, 27, 32, 33, 38, 39, 40, 41, 42, 43, 44, 45, 56, 57, 62, 63, 68, 69, 74, 75, 76, 77, 78, 79, 80, 81, 92, 93, 98, 99, 112, 113, 128, 129, 134, 135, 148, 149, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 178, 179, 184, 185, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 214, 215, 220, 221];
  }
} catch (err) {}
// swallow - we only care if `supports-color` is available; it doesn't have to be.


/**
 * Build up the default `inspectOpts` object from the environment variables.
 *
 *   $ DEBUG_COLORS=no DEBUG_DEPTH=10 DEBUG_SHOW_HIDDEN=enabled node script.js
 */

exports.inspectOpts = Object.keys(process.env).filter(function (key) {
  return (/^debug_/i.test(key)
  );
}).reduce(function (obj, key) {
  // camel-case
  var prop = key.substring(6).toLowerCase().replace(/_([a-z])/g, function (_, k) {
    return k.toUpperCase();
  });

  // coerce string value into JS value
  var val = process.env[key];
  if (/^(yes|on|true|enabled)$/i.test(val)) val = true;else if (/^(no|off|false|disabled)$/i.test(val)) val = false;else if (val === 'null') val = null;else val = Number(val);

  obj[prop] = val;
  return obj;
}, {});

/**
 * Is stdout a TTY? Colored output is enabled when `true`.
 */

function useColors() {
  return 'colors' in exports.inspectOpts ? Boolean(exports.inspectOpts.colors) : tty.isatty(process.stderr.fd);
}

/**
 * Map %o to `util.inspect()`, all on a single line.
 */

exports.formatters.o = function (v) {
  this.inspectOpts.colors = this.useColors;
  return util.inspect(v, this.inspectOpts).split('\n').map(function (str) {
    return str.trim();
  }).join(' ');
};

/**
 * Map %o to `util.inspect()`, allowing multiple lines if needed.
 */

exports.formatters.O = function (v) {
  this.inspectOpts.colors = this.useColors;
  return util.inspect(v, this.inspectOpts);
};

/**
 * Adds ANSI color escape codes if enabled.
 *
 * @api public
 */

function formatArgs(args) {
  var name = this.namespace;
  var useColors = this.useColors;

  if (useColors) {
    var c = this.color;
    var colorCode = '\u001b[3' + (c < 8 ? c : '8;5;' + c);
    var prefix = '  ' + colorCode + ';1m' + name + ' ' + '\u001b[0m';

    args[0] = prefix + args[0].split('\n').join('\n' + prefix);
    args.push(colorCode + 'm+' + exports.humanize(this.diff) + '\u001b[0m');
  } else {
    args[0] = getDate() + name + ' ' + args[0];
  }
}

function getDate() {
  if (exports.inspectOpts.hideDate) {
    return '';
  } else {
    return new Date().toISOString() + ' ';
  }
}

/**
 * Invokes `util.format()` with the specified arguments and writes to stderr.
 */

function log() {
  return process.stderr.write(util.format.apply(util, arguments) + '\n');
}

/**
 * Save `namespaces`.
 *
 * @param {String} namespaces
 * @api private
 */

function save(namespaces) {
  if (null == namespaces) {
    // If you set a process.env field to null or undefined, it gets cast to the
    // string 'null' or 'undefined'. Just delete instead.
    delete process.env.DEBUG;
  } else {
    process.env.DEBUG = namespaces;
  }
}

/**
 * Load `namespaces`.
 *
 * @return {String} returns the previously persisted debug modes
 * @api private
 */

function load() {
  return process.env.DEBUG;
}

/**
 * Init logic for `debug` instances.
 *
 * Create a new `inspectOpts` object in case `useColors` is set
 * differently for a particular `debug` instance.
 */

function init(debug) {
  debug.inspectOpts = {};

  var keys = Object.keys(exports.inspectOpts);
  for (var i = 0; i < keys.length; i++) {
    debug.inspectOpts[keys[i]] = exports.inspectOpts[keys[i]];
  }
}

/**
 * Enable namespaces listed in `process.env.DEBUG` initially.
 */

exports.enable(load());

/***/ }),
/* 104 */
/***/ (function(module, exports) {

module.exports = require("tty");

/***/ }),
/* 105 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const os = __webpack_require__(15);
const hasFlag = __webpack_require__(106);

const env = process.env;

const support = level => {
	if (level === 0) {
		return false;
	}

	return {
		level,
		hasBasic: true,
		has256: level >= 2,
		has16m: level >= 3
	};
};

let supportLevel = (() => {
	if (hasFlag('no-color') || hasFlag('no-colors') || hasFlag('color=false')) {
		return 0;
	}

	if (hasFlag('color=16m') || hasFlag('color=full') || hasFlag('color=truecolor')) {
		return 3;
	}

	if (hasFlag('color=256')) {
		return 2;
	}

	if (hasFlag('color') || hasFlag('colors') || hasFlag('color=true') || hasFlag('color=always')) {
		return 1;
	}

	if (process.stdout && !process.stdout.isTTY) {
		return 0;
	}

	if (process.platform === 'win32') {
		// Node.js 7.5.0 is the first version of Node.js to include a patch to
		// libuv that enables 256 color output on Windows. Anything earlier and it
		// won't work. However, here we target Node.js 8 at minimum as it is an LTS
		// release, and Node.js 7 is not. Windows 10 build 10586 is the first Windows
		// release that supports 256 colors.
		const osRelease = os.release().split('.');
		if (Number(process.versions.node.split('.')[0]) >= 8 && Number(osRelease[0]) >= 10 && Number(osRelease[2]) >= 10586) {
			return 2;
		}

		return 1;
	}

	if ('CI' in env) {
		if (['TRAVIS', 'CIRCLECI', 'APPVEYOR', 'GITLAB_CI'].some(sign => sign in env) || env.CI_NAME === 'codeship') {
			return 1;
		}

		return 0;
	}

	if ('TEAMCITY_VERSION' in env) {
		return (/^(9\.(0*[1-9]\d*)\.|\d{2,}\.)/.test(env.TEAMCITY_VERSION) ? 1 : 0
		);
	}

	if ('TERM_PROGRAM' in env) {
		const version = parseInt((env.TERM_PROGRAM_VERSION || '').split('.')[0], 10);

		switch (env.TERM_PROGRAM) {
			case 'iTerm.app':
				return version >= 3 ? 3 : 2;
			case 'Hyper':
				return 3;
			case 'Apple_Terminal':
				return 2;
			// No default
		}
	}

	if (/-256(color)?$/i.test(env.TERM)) {
		return 2;
	}

	if (/^screen|^xterm|^vt100|^rxvt|color|ansi|cygwin|linux/i.test(env.TERM)) {
		return 1;
	}

	if ('COLORTERM' in env) {
		return 1;
	}

	if (env.TERM === 'dumb') {
		return 0;
	}

	return 0;
})();

if ('FORCE_COLOR' in env) {
	supportLevel = parseInt(env.FORCE_COLOR, 10) === 0 ? 0 : supportLevel || 1;
}

module.exports = process && support(supportLevel);

/***/ }),
/* 106 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = function (flag, argv) {
	argv = argv || process.argv;

	var terminatorPos = argv.indexOf('--');
	var prefix = /^-{1,2}/.test(flag) ? '' : '--';
	var pos = argv.indexOf(prefix + flag);

	return pos !== -1 && (terminatorPos === -1 ? true : pos < terminatorPos);
};

/***/ }),
/* 107 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const assign = __webpack_require__(108);

const fs = {};

// Export graceful-fs:
assign(fs, __webpack_require__(44));
// Export extra methods:
assign(fs, __webpack_require__(112));
assign(fs, __webpack_require__(50));
assign(fs, __webpack_require__(7));
assign(fs, __webpack_require__(24));
assign(fs, __webpack_require__(117));
assign(fs, __webpack_require__(121));
assign(fs, __webpack_require__(122));
assign(fs, __webpack_require__(123));
assign(fs, __webpack_require__(124));
assign(fs, __webpack_require__(130));
assign(fs, __webpack_require__(13));

module.exports = fs;

/***/ }),
/* 108 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// simple mutable assign

function assign() {
  const args = [].slice.call(arguments).filter(i => i);
  const dest = args.shift();
  args.forEach(src => {
    Object.keys(src).forEach(key => {
      dest[key] = src[key];
    });
  });

  return dest;
}

module.exports = assign;

/***/ }),
/* 109 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var fs = __webpack_require__(45);
var constants = __webpack_require__(110);

var origCwd = process.cwd;
var cwd = null;

var platform = process.env.GRACEFUL_FS_PLATFORM || process.platform;

process.cwd = function () {
  if (!cwd) cwd = origCwd.call(process);
  return cwd;
};
try {
  process.cwd();
} catch (er) {}

var chdir = process.chdir;
process.chdir = function (d) {
  cwd = null;
  chdir.call(process, d);
};

module.exports = patch;

function patch(fs) {
  // (re-)implement some things that are known busted or missing.

  // lchmod, broken prior to 0.6.2
  // back-port the fix here.
  if (constants.hasOwnProperty('O_SYMLINK') && process.version.match(/^v0\.6\.[0-2]|^v0\.5\./)) {
    patchLchmod(fs);
  }

  // lutimes implementation, or no-op
  if (!fs.lutimes) {
    patchLutimes(fs);
  }

  // https://github.com/isaacs/node-graceful-fs/issues/4
  // Chown should not fail on einval or eperm if non-root.
  // It should not fail on enosys ever, as this just indicates
  // that a fs doesn't support the intended operation.

  fs.chown = chownFix(fs.chown);
  fs.fchown = chownFix(fs.fchown);
  fs.lchown = chownFix(fs.lchown);

  fs.chmod = chmodFix(fs.chmod);
  fs.fchmod = chmodFix(fs.fchmod);
  fs.lchmod = chmodFix(fs.lchmod);

  fs.chownSync = chownFixSync(fs.chownSync);
  fs.fchownSync = chownFixSync(fs.fchownSync);
  fs.lchownSync = chownFixSync(fs.lchownSync);

  fs.chmodSync = chmodFixSync(fs.chmodSync);
  fs.fchmodSync = chmodFixSync(fs.fchmodSync);
  fs.lchmodSync = chmodFixSync(fs.lchmodSync);

  fs.stat = statFix(fs.stat);
  fs.fstat = statFix(fs.fstat);
  fs.lstat = statFix(fs.lstat);

  fs.statSync = statFixSync(fs.statSync);
  fs.fstatSync = statFixSync(fs.fstatSync);
  fs.lstatSync = statFixSync(fs.lstatSync);

  // if lchmod/lchown do not exist, then make them no-ops
  if (!fs.lchmod) {
    fs.lchmod = function (path, mode, cb) {
      if (cb) process.nextTick(cb);
    };
    fs.lchmodSync = function () {};
  }
  if (!fs.lchown) {
    fs.lchown = function (path, uid, gid, cb) {
      if (cb) process.nextTick(cb);
    };
    fs.lchownSync = function () {};
  }

  // on Windows, A/V software can lock the directory, causing this
  // to fail with an EACCES or EPERM if the directory contains newly
  // created files.  Try again on failure, for up to 60 seconds.

  // Set the timeout this long because some Windows Anti-Virus, such as Parity
  // bit9, may lock files for up to a minute, causing npm package install
  // failures. Also, take care to yield the scheduler. Windows scheduling gives
  // CPU to a busy looping process, which can cause the program causing the lock
  // contention to be starved of CPU by node, so the contention doesn't resolve.
  if (platform === "win32") {
    fs.rename = function (fs$rename) {
      return function (from, to, cb) {
        var start = Date.now();
        var backoff = 0;
        fs$rename(from, to, function CB(er) {
          if (er && (er.code === "EACCES" || er.code === "EPERM") && Date.now() - start < 60000) {
            setTimeout(function () {
              fs.stat(to, function (stater, st) {
                if (stater && stater.code === "ENOENT") fs$rename(from, to, CB);else cb(er);
              });
            }, backoff);
            if (backoff < 100) backoff += 10;
            return;
          }
          if (cb) cb(er);
        });
      };
    }(fs.rename);
  }

  // if read() returns EAGAIN, then just try it again.
  fs.read = function (fs$read) {
    return function (fd, buffer, offset, length, position, callback_) {
      var callback;
      if (callback_ && typeof callback_ === 'function') {
        var eagCounter = 0;
        callback = function (er, _, __) {
          if (er && er.code === 'EAGAIN' && eagCounter < 10) {
            eagCounter++;
            return fs$read.call(fs, fd, buffer, offset, length, position, callback);
          }
          callback_.apply(this, arguments);
        };
      }
      return fs$read.call(fs, fd, buffer, offset, length, position, callback);
    };
  }(fs.read);

  fs.readSync = function (fs$readSync) {
    return function (fd, buffer, offset, length, position) {
      var eagCounter = 0;
      while (true) {
        try {
          return fs$readSync.call(fs, fd, buffer, offset, length, position);
        } catch (er) {
          if (er.code === 'EAGAIN' && eagCounter < 10) {
            eagCounter++;
            continue;
          }
          throw er;
        }
      }
    };
  }(fs.readSync);
}

function patchLchmod(fs) {
  fs.lchmod = function (path, mode, callback) {
    fs.open(path, constants.O_WRONLY | constants.O_SYMLINK, mode, function (err, fd) {
      if (err) {
        if (callback) callback(err);
        return;
      }
      // prefer to return the chmod error, if one occurs,
      // but still try to close, and report closing errors if they occur.
      fs.fchmod(fd, mode, function (err) {
        fs.close(fd, function (err2) {
          if (callback) callback(err || err2);
        });
      });
    });
  };

  fs.lchmodSync = function (path, mode) {
    var fd = fs.openSync(path, constants.O_WRONLY | constants.O_SYMLINK, mode);

    // prefer to return the chmod error, if one occurs,
    // but still try to close, and report closing errors if they occur.
    var threw = true;
    var ret;
    try {
      ret = fs.fchmodSync(fd, mode);
      threw = false;
    } finally {
      if (threw) {
        try {
          fs.closeSync(fd);
        } catch (er) {}
      } else {
        fs.closeSync(fd);
      }
    }
    return ret;
  };
}

function patchLutimes(fs) {
  if (constants.hasOwnProperty("O_SYMLINK")) {
    fs.lutimes = function (path, at, mt, cb) {
      fs.open(path, constants.O_SYMLINK, function (er, fd) {
        if (er) {
          if (cb) cb(er);
          return;
        }
        fs.futimes(fd, at, mt, function (er) {
          fs.close(fd, function (er2) {
            if (cb) cb(er || er2);
          });
        });
      });
    };

    fs.lutimesSync = function (path, at, mt) {
      var fd = fs.openSync(path, constants.O_SYMLINK);
      var ret;
      var threw = true;
      try {
        ret = fs.futimesSync(fd, at, mt);
        threw = false;
      } finally {
        if (threw) {
          try {
            fs.closeSync(fd);
          } catch (er) {}
        } else {
          fs.closeSync(fd);
        }
      }
      return ret;
    };
  } else {
    fs.lutimes = function (_a, _b, _c, cb) {
      if (cb) process.nextTick(cb);
    };
    fs.lutimesSync = function () {};
  }
}

function chmodFix(orig) {
  if (!orig) return orig;
  return function (target, mode, cb) {
    return orig.call(fs, target, mode, function (er) {
      if (chownErOk(er)) er = null;
      if (cb) cb.apply(this, arguments);
    });
  };
}

function chmodFixSync(orig) {
  if (!orig) return orig;
  return function (target, mode) {
    try {
      return orig.call(fs, target, mode);
    } catch (er) {
      if (!chownErOk(er)) throw er;
    }
  };
}

function chownFix(orig) {
  if (!orig) return orig;
  return function (target, uid, gid, cb) {
    return orig.call(fs, target, uid, gid, function (er) {
      if (chownErOk(er)) er = null;
      if (cb) cb.apply(this, arguments);
    });
  };
}

function chownFixSync(orig) {
  if (!orig) return orig;
  return function (target, uid, gid) {
    try {
      return orig.call(fs, target, uid, gid);
    } catch (er) {
      if (!chownErOk(er)) throw er;
    }
  };
}

function statFix(orig) {
  if (!orig) return orig;
  // Older versions of Node erroneously returned signed integers for
  // uid + gid.
  return function (target, cb) {
    return orig.call(fs, target, function (er, stats) {
      if (!stats) return cb.apply(this, arguments);
      if (stats.uid < 0) stats.uid += 0x100000000;
      if (stats.gid < 0) stats.gid += 0x100000000;
      if (cb) cb.apply(this, arguments);
    });
  };
}

function statFixSync(orig) {
  if (!orig) return orig;
  // Older versions of Node erroneously returned signed integers for
  // uid + gid.
  return function (target) {
    var stats = orig.call(fs, target);
    if (stats.uid < 0) stats.uid += 0x100000000;
    if (stats.gid < 0) stats.gid += 0x100000000;
    return stats;
  };
}

// ENOSYS means that the fs doesn't support the op. Just ignore
// that, because it doesn't matter.
//
// if there's no getuid, or if getuid() is something other
// than 0, and the error is EINVAL or EPERM, then just ignore
// it.
//
// This specific case is a silent failure in cp, install, tar,
// and most other unix tools that manage permissions.
//
// When running as root, or if other types of errors are
// encountered, then it's strict.
function chownErOk(er) {
  if (!er) return true;

  if (er.code === "ENOSYS") return true;

  var nonroot = !process.getuid || process.getuid() !== 0;
  if (nonroot) {
    if (er.code === "EINVAL" || er.code === "EPERM") return true;
  }

  return false;
}

/***/ }),
/* 110 */
/***/ (function(module, exports) {

module.exports = require("constants");

/***/ }),
/* 111 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var Stream = __webpack_require__(19).Stream;

module.exports = legacy;

function legacy(fs) {
  return {
    ReadStream: ReadStream,
    WriteStream: WriteStream
  };

  function ReadStream(path, options) {
    if (!(this instanceof ReadStream)) return new ReadStream(path, options);

    Stream.call(this);

    var self = this;

    this.path = path;
    this.fd = null;
    this.readable = true;
    this.paused = false;

    this.flags = 'r';
    this.mode = 438; /*=0666*/
    this.bufferSize = 64 * 1024;

    options = options || {};

    // Mixin options into this
    var keys = Object.keys(options);
    for (var index = 0, length = keys.length; index < length; index++) {
      var key = keys[index];
      this[key] = options[key];
    }

    if (this.encoding) this.setEncoding(this.encoding);

    if (this.start !== undefined) {
      if ('number' !== typeof this.start) {
        throw TypeError('start must be a Number');
      }
      if (this.end === undefined) {
        this.end = Infinity;
      } else if ('number' !== typeof this.end) {
        throw TypeError('end must be a Number');
      }

      if (this.start > this.end) {
        throw new Error('start must be <= end');
      }

      this.pos = this.start;
    }

    if (this.fd !== null) {
      process.nextTick(function () {
        self._read();
      });
      return;
    }

    fs.open(this.path, this.flags, this.mode, function (err, fd) {
      if (err) {
        self.emit('error', err);
        self.readable = false;
        return;
      }

      self.fd = fd;
      self.emit('open', fd);
      self._read();
    });
  }

  function WriteStream(path, options) {
    if (!(this instanceof WriteStream)) return new WriteStream(path, options);

    Stream.call(this);

    this.path = path;
    this.fd = null;
    this.writable = true;

    this.flags = 'w';
    this.encoding = 'binary';
    this.mode = 438; /*=0666*/
    this.bytesWritten = 0;

    options = options || {};

    // Mixin options into this
    var keys = Object.keys(options);
    for (var index = 0, length = keys.length; index < length; index++) {
      var key = keys[index];
      this[key] = options[key];
    }

    if (this.start !== undefined) {
      if ('number' !== typeof this.start) {
        throw TypeError('start must be a Number');
      }
      if (this.start < 0) {
        throw new Error('start must be >= zero');
      }

      this.pos = this.start;
    }

    this.busy = false;
    this._queue = [];

    if (this.fd === null) {
      this._open = fs.open;
      this._queue.push([this._open, this.path, this.flags, this.mode, undefined]);
      this.flush();
    }
  }
}

/***/ }),
/* 112 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const u = __webpack_require__(6).fromCallback;
module.exports = {
  copy: u(__webpack_require__(47))
};

/***/ }),
/* 113 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const fs = __webpack_require__(5);
const path = __webpack_require__(0);
const invalidWin32Path = __webpack_require__(48).invalidWin32Path;

const o777 = parseInt('0777', 8);

function mkdirs(p, opts, callback, made) {
  if (typeof opts === 'function') {
    callback = opts;
    opts = {};
  } else if (!opts || typeof opts !== 'object') {
    opts = { mode: opts };
  }

  if (process.platform === 'win32' && invalidWin32Path(p)) {
    const errInval = new Error(p + ' contains invalid WIN32 path characters.');
    errInval.code = 'EINVAL';
    return callback(errInval);
  }

  let mode = opts.mode;
  const xfs = opts.fs || fs;

  if (mode === undefined) {
    mode = o777 & ~process.umask();
  }
  if (!made) made = null;

  callback = callback || function () {};
  p = path.resolve(p);

  xfs.mkdir(p, mode, er => {
    if (!er) {
      made = made || p;
      return callback(null, made);
    }
    switch (er.code) {
      case 'ENOENT':
        if (path.dirname(p) === p) return callback(er);
        mkdirs(path.dirname(p), opts, (er, made) => {
          if (er) callback(er, made);else mkdirs(p, opts, callback, made);
        });
        break;

      // In the case of any other error, just see if there's a dir
      // there already.  If so, then hooray!  If not, then something
      // is borked.
      default:
        xfs.stat(p, (er2, stat) => {
          // if the stat fails, then that's super weird.
          // let the original error be the failure reason.
          if (er2 || !stat.isDirectory()) callback(er, made);else callback(null, made);
        });
        break;
    }
  });
}

module.exports = mkdirs;

/***/ }),
/* 114 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const fs = __webpack_require__(5);
const path = __webpack_require__(0);
const invalidWin32Path = __webpack_require__(48).invalidWin32Path;

const o777 = parseInt('0777', 8);

function mkdirsSync(p, opts, made) {
  if (!opts || typeof opts !== 'object') {
    opts = { mode: opts };
  }

  let mode = opts.mode;
  const xfs = opts.fs || fs;

  if (process.platform === 'win32' && invalidWin32Path(p)) {
    const errInval = new Error(p + ' contains invalid WIN32 path characters.');
    errInval.code = 'EINVAL';
    throw errInval;
  }

  if (mode === undefined) {
    mode = o777 & ~process.umask();
  }
  if (!made) made = null;

  p = path.resolve(p);

  try {
    xfs.mkdirSync(p, mode);
    made = made || p;
  } catch (err0) {
    switch (err0.code) {
      case 'ENOENT':
        if (path.dirname(p) === p) throw err0;
        made = mkdirsSync(path.dirname(p), opts, made);
        mkdirsSync(p, opts, made);
        break;

      // In the case of any other error, just see if there's a dir
      // there already.  If so, then hooray!  If not, then something
      // is borked.
      default:
        let stat;
        try {
          stat = xfs.statSync(p);
        } catch (err1) {
          throw err0;
        }
        if (!stat.isDirectory()) throw err0;
        break;
    }
  }

  return made;
}

module.exports = mkdirsSync;

/***/ }),
/* 115 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const fs = __webpack_require__(5);
const path = __webpack_require__(0);
const mkdirpSync = __webpack_require__(7).mkdirsSync;
const utimesSync = __webpack_require__(49).utimesMillisSync;

const notExist = Symbol('notExist');
const existsReg = Symbol('existsReg');

function copySync(src, dest, opts) {
  if (typeof opts === 'function') {
    opts = { filter: opts };
  }

  opts = opts || {};
  opts.clobber = 'clobber' in opts ? !!opts.clobber : true; // default to true for now
  opts.overwrite = 'overwrite' in opts ? !!opts.overwrite : opts.clobber; // overwrite falls back to clobber

  // Warn about using preserveTimestamps on 32-bit node
  if (opts.preserveTimestamps && process.arch === 'ia32') {
    console.warn(`fs-extra: Using the preserveTimestamps option in 32-bit node is not recommended;\n
    see https://github.com/jprichardson/node-fs-extra/issues/269`);
  }

  src = path.resolve(src);
  dest = path.resolve(dest);

  // don't allow src and dest to be the same
  if (src === dest) throw new Error('Source and destination must not be the same.');

  if (opts.filter && !opts.filter(src, dest)) return;

  const destParent = path.dirname(dest);
  if (!fs.existsSync(destParent)) mkdirpSync(destParent);
  return startCopy(src, dest, opts);
}

function startCopy(src, dest, opts) {
  if (opts.filter && !opts.filter(src, dest)) return;
  return getStats(src, dest, opts);
}

function getStats(src, dest, opts) {
  const statSync = opts.dereference ? fs.statSync : fs.lstatSync;
  const st = statSync(src);

  if (st.isDirectory()) return onDir(st, src, dest, opts);else if (st.isFile() || st.isCharacterDevice() || st.isBlockDevice()) return onFile(st, src, dest, opts);else if (st.isSymbolicLink()) return onLink(src, dest, opts);
}

function onFile(srcStat, src, dest, opts) {
  const resolvedPath = checkDest(dest);
  if (resolvedPath === notExist) {
    return copyFile(srcStat, src, dest, opts);
  } else if (resolvedPath === existsReg) {
    return mayCopyFile(srcStat, src, dest, opts);
  } else {
    if (src === resolvedPath) return;
    return mayCopyFile(srcStat, src, dest, opts);
  }
}

function mayCopyFile(srcStat, src, dest, opts) {
  if (opts.overwrite) {
    fs.unlinkSync(dest);
    return copyFile(srcStat, src, dest, opts);
  } else if (opts.errorOnExist) {
    throw new Error(`'${dest}' already exists`);
  }
}

function copyFile(srcStat, src, dest, opts) {
  if (typeof fs.copyFileSync === 'function') {
    fs.copyFileSync(src, dest);
    fs.chmodSync(dest, srcStat.mode);
    if (opts.preserveTimestamps) {
      return utimesSync(dest, srcStat.atime, srcStat.mtime);
    }
    return;
  }
  return copyFileFallback(srcStat, src, dest, opts);
}

function copyFileFallback(srcStat, src, dest, opts) {
  const BUF_LENGTH = 64 * 1024;
  const _buff = __webpack_require__(51)(BUF_LENGTH);

  const fdr = fs.openSync(src, 'r');
  const fdw = fs.openSync(dest, 'w', srcStat.mode);
  let bytesRead = 1;
  let pos = 0;

  while (bytesRead > 0) {
    bytesRead = fs.readSync(fdr, _buff, 0, BUF_LENGTH, pos);
    fs.writeSync(fdw, _buff, 0, bytesRead);
    pos += bytesRead;
  }

  if (opts.preserveTimestamps) fs.futimesSync(fdw, srcStat.atime, srcStat.mtime);

  fs.closeSync(fdr);
  fs.closeSync(fdw);
}

function onDir(srcStat, src, dest, opts) {
  const resolvedPath = checkDest(dest);
  if (resolvedPath === notExist) {
    if (isSrcSubdir(src, dest)) {
      throw new Error(`Cannot copy '${src}' to a subdirectory of itself, '${dest}'.`);
    }
    return mkDirAndCopy(srcStat, src, dest, opts);
  } else if (resolvedPath === existsReg) {
    if (isSrcSubdir(src, dest)) {
      throw new Error(`Cannot copy '${src}' to a subdirectory of itself, '${dest}'.`);
    }
    return mayCopyDir(src, dest, opts);
  } else {
    if (src === resolvedPath) return;
    return copyDir(src, dest, opts);
  }
}

function mayCopyDir(src, dest, opts) {
  if (!fs.statSync(dest).isDirectory()) {
    throw new Error(`Cannot overwrite non-directory '${dest}' with directory '${src}'.`);
  }
  return copyDir(src, dest, opts);
}

function mkDirAndCopy(srcStat, src, dest, opts) {
  fs.mkdirSync(dest, srcStat.mode);
  fs.chmodSync(dest, srcStat.mode);
  return copyDir(src, dest, opts);
}

function copyDir(src, dest, opts) {
  fs.readdirSync(src).forEach(item => {
    startCopy(path.join(src, item), path.join(dest, item), opts);
  });
}

function onLink(src, dest, opts) {
  let resolvedSrcPath = fs.readlinkSync(src);

  if (opts.dereference) {
    resolvedSrcPath = path.resolve(process.cwd(), resolvedSrcPath);
  }

  let resolvedDestPath = checkDest(dest);
  if (resolvedDestPath === notExist || resolvedDestPath === existsReg) {
    // if dest already exists, fs throws error anyway,
    // so no need to guard against it here.
    return fs.symlinkSync(resolvedSrcPath, dest);
  } else {
    if (opts.dereference) {
      resolvedDestPath = path.resolve(process.cwd(), resolvedDestPath);
    }
    if (resolvedDestPath === resolvedSrcPath) return;

    // prevent copy if src is a subdir of dest since unlinking
    // dest in this case would result in removing src contents
    // and therefore a broken symlink would be created.
    if (fs.statSync(dest).isDirectory() && isSrcSubdir(resolvedDestPath, resolvedSrcPath)) {
      throw new Error(`Cannot overwrite '${resolvedDestPath}' with '${resolvedSrcPath}'.`);
    }
    return copyLink(resolvedSrcPath, dest);
  }
}

function copyLink(resolvedSrcPath, dest) {
  fs.unlinkSync(dest);
  return fs.symlinkSync(resolvedSrcPath, dest);
}

// check if dest exists and/or is a symlink
function checkDest(dest) {
  let resolvedPath;
  try {
    resolvedPath = fs.readlinkSync(dest);
  } catch (err) {
    if (err.code === 'ENOENT') return notExist;

    // dest exists and is a regular file or directory, Windows may throw UNKNOWN error
    if (err.code === 'EINVAL' || err.code === 'UNKNOWN') return existsReg;

    throw err;
  }
  return resolvedPath; // dest exists and is a symlink
}

// return true if dest is a subdir of src, otherwise false.
// extract dest base dir and check if that is the same as src basename
function isSrcSubdir(src, dest) {
  const baseDir = dest.split(path.dirname(src) + path.sep)[1];
  if (baseDir) {
    const destBasename = baseDir.split(path.sep)[0];
    if (destBasename) {
      return src !== dest && dest.indexOf(src) > -1 && destBasename === path.basename(src);
    }
    return false;
  }
  return false;
}

module.exports = copySync;

/***/ }),
/* 116 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const fs = __webpack_require__(5);
const path = __webpack_require__(0);
const assert = __webpack_require__(46);

const isWindows = process.platform === 'win32';

function defaults(options) {
  const methods = ['unlink', 'chmod', 'stat', 'lstat', 'rmdir', 'readdir'];
  methods.forEach(m => {
    options[m] = options[m] || fs[m];
    m = m + 'Sync';
    options[m] = options[m] || fs[m];
  });

  options.maxBusyTries = options.maxBusyTries || 3;
}

function rimraf(p, options, cb) {
  let busyTries = 0;

  if (typeof options === 'function') {
    cb = options;
    options = {};
  }

  assert(p, 'rimraf: missing path');
  assert.equal(typeof p, 'string', 'rimraf: path should be a string');
  assert.equal(typeof cb, 'function', 'rimraf: callback function required');
  assert(options, 'rimraf: invalid options argument provided');
  assert.equal(typeof options, 'object', 'rimraf: options should be object');

  defaults(options);

  rimraf_(p, options, function CB(er) {
    if (er) {
      if ((er.code === 'EBUSY' || er.code === 'ENOTEMPTY' || er.code === 'EPERM') && busyTries < options.maxBusyTries) {
        busyTries++;
        let time = busyTries * 100;
        // try again, with the same exact callback as this one.
        return setTimeout(() => rimraf_(p, options, CB), time);
      }

      // already gone
      if (er.code === 'ENOENT') er = null;
    }

    cb(er);
  });
}

// Two possible strategies.
// 1. Assume it's a file.  unlink it, then do the dir stuff on EPERM or EISDIR
// 2. Assume it's a directory.  readdir, then do the file stuff on ENOTDIR
//
// Both result in an extra syscall when you guess wrong.  However, there
// are likely far more normal files in the world than directories.  This
// is based on the assumption that a the average number of files per
// directory is >= 1.
//
// If anyone ever complains about this, then I guess the strategy could
// be made configurable somehow.  But until then, YAGNI.
function rimraf_(p, options, cb) {
  assert(p);
  assert(options);
  assert(typeof cb === 'function');

  // sunos lets the root user unlink directories, which is... weird.
  // so we have to lstat here and make sure it's not a dir.
  options.lstat(p, (er, st) => {
    if (er && er.code === 'ENOENT') {
      return cb(null);
    }

    // Windows can EPERM on stat.  Life is suffering.
    if (er && er.code === 'EPERM' && isWindows) {
      return fixWinEPERM(p, options, er, cb);
    }

    if (st && st.isDirectory()) {
      return rmdir(p, options, er, cb);
    }

    options.unlink(p, er => {
      if (er) {
        if (er.code === 'ENOENT') {
          return cb(null);
        }
        if (er.code === 'EPERM') {
          return isWindows ? fixWinEPERM(p, options, er, cb) : rmdir(p, options, er, cb);
        }
        if (er.code === 'EISDIR') {
          return rmdir(p, options, er, cb);
        }
      }
      return cb(er);
    });
  });
}

function fixWinEPERM(p, options, er, cb) {
  assert(p);
  assert(options);
  assert(typeof cb === 'function');
  if (er) {
    assert(er instanceof Error);
  }

  options.chmod(p, 0o666, er2 => {
    if (er2) {
      cb(er2.code === 'ENOENT' ? null : er);
    } else {
      options.stat(p, (er3, stats) => {
        if (er3) {
          cb(er3.code === 'ENOENT' ? null : er);
        } else if (stats.isDirectory()) {
          rmdir(p, options, er, cb);
        } else {
          options.unlink(p, cb);
        }
      });
    }
  });
}

function fixWinEPERMSync(p, options, er) {
  let stats;

  assert(p);
  assert(options);
  if (er) {
    assert(er instanceof Error);
  }

  try {
    options.chmodSync(p, 0o666);
  } catch (er2) {
    if (er2.code === 'ENOENT') {
      return;
    } else {
      throw er;
    }
  }

  try {
    stats = options.statSync(p);
  } catch (er3) {
    if (er3.code === 'ENOENT') {
      return;
    } else {
      throw er;
    }
  }

  if (stats.isDirectory()) {
    rmdirSync(p, options, er);
  } else {
    options.unlinkSync(p);
  }
}

function rmdir(p, options, originalEr, cb) {
  assert(p);
  assert(options);
  if (originalEr) {
    assert(originalEr instanceof Error);
  }
  assert(typeof cb === 'function');

  // try to rmdir first, and only readdir on ENOTEMPTY or EEXIST (SunOS)
  // if we guessed wrong, and it's not a directory, then
  // raise the original error.
  options.rmdir(p, er => {
    if (er && (er.code === 'ENOTEMPTY' || er.code === 'EEXIST' || er.code === 'EPERM')) {
      rmkids(p, options, cb);
    } else if (er && er.code === 'ENOTDIR') {
      cb(originalEr);
    } else {
      cb(er);
    }
  });
}

function rmkids(p, options, cb) {
  assert(p);
  assert(options);
  assert(typeof cb === 'function');

  options.readdir(p, (er, files) => {
    if (er) return cb(er);

    let n = files.length;
    let errState;

    if (n === 0) return options.rmdir(p, cb);

    files.forEach(f => {
      rimraf(path.join(p, f), options, er => {
        if (errState) {
          return;
        }
        if (er) return cb(errState = er);
        if (--n === 0) {
          options.rmdir(p, cb);
        }
      });
    });
  });
}

// this looks simpler, and is strictly *faster*, but will
// tie up the JavaScript thread and fail on excessively
// deep directory trees.
function rimrafSync(p, options) {
  let st;

  options = options || {};
  defaults(options);

  assert(p, 'rimraf: missing path');
  assert.equal(typeof p, 'string', 'rimraf: path should be a string');
  assert(options, 'rimraf: missing options');
  assert.equal(typeof options, 'object', 'rimraf: options should be object');

  try {
    st = options.lstatSync(p);
  } catch (er) {
    if (er.code === 'ENOENT') {
      return;
    }

    // Windows can EPERM on stat.  Life is suffering.
    if (er.code === 'EPERM' && isWindows) {
      fixWinEPERMSync(p, options, er);
    }
  }

  try {
    // sunos lets the root user unlink directories, which is... weird.
    if (st && st.isDirectory()) {
      rmdirSync(p, options, null);
    } else {
      options.unlinkSync(p);
    }
  } catch (er) {
    if (er.code === 'ENOENT') {
      return;
    } else if (er.code === 'EPERM') {
      return isWindows ? fixWinEPERMSync(p, options, er) : rmdirSync(p, options, er);
    } else if (er.code !== 'EISDIR') {
      throw er;
    }
    rmdirSync(p, options, er);
  }
}

function rmdirSync(p, options, originalEr) {
  assert(p);
  assert(options);
  if (originalEr) {
    assert(originalEr instanceof Error);
  }

  try {
    options.rmdirSync(p);
  } catch (er) {
    if (er.code === 'ENOTDIR') {
      throw originalEr;
    } else if (er.code === 'ENOTEMPTY' || er.code === 'EEXIST' || er.code === 'EPERM') {
      rmkidsSync(p, options);
    } else if (er.code !== 'ENOENT') {
      throw er;
    }
  }
}

function rmkidsSync(p, options) {
  assert(p);
  assert(options);
  options.readdirSync(p).forEach(f => rimrafSync(path.join(p, f), options));

  // We only end up here once we got ENOTEMPTY at least once, and
  // at this point, we are guaranteed to have removed all the kids.
  // So, we know that it won't be ENOENT or ENOTDIR or anything else.
  // try really hard to delete stuff on windows, because it has a
  // PROFOUNDLY annoying habit of not closing handles promptly when
  // files are deleted, resulting in spurious ENOTEMPTY errors.
  const retries = isWindows ? 100 : 1;
  let i = 0;
  do {
    let threw = true;
    try {
      const ret = options.rmdirSync(p, options);
      threw = false;
      return ret;
    } finally {
      if (++i < retries && threw) continue; // eslint-disable-line
    }
  } while (true);
}

module.exports = rimraf;
rimraf.sync = rimrafSync;

/***/ }),
/* 117 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const u = __webpack_require__(6).fromCallback;
const jsonFile = __webpack_require__(30);

jsonFile.outputJson = u(__webpack_require__(119));
jsonFile.outputJsonSync = __webpack_require__(120);
// aliases
jsonFile.outputJSON = jsonFile.outputJson;
jsonFile.outputJSONSync = jsonFile.outputJsonSync;
jsonFile.writeJSON = jsonFile.writeJson;
jsonFile.writeJSONSync = jsonFile.writeJsonSync;
jsonFile.readJSON = jsonFile.readJson;
jsonFile.readJSONSync = jsonFile.readJsonSync;

module.exports = jsonFile;

/***/ }),
/* 118 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _fs;
try {
  _fs = __webpack_require__(5);
} catch (_) {
  _fs = __webpack_require__(12);
}

function readFile(file, options, callback) {
  if (callback == null) {
    callback = options;
    options = {};
  }

  if (typeof options === 'string') {
    options = { encoding: options };
  }

  options = options || {};
  var fs = options.fs || _fs;

  var shouldThrow = true;
  if ('throws' in options) {
    shouldThrow = options.throws;
  }

  fs.readFile(file, options, function (err, data) {
    if (err) return callback(err);

    data = stripBom(data);

    var obj;
    try {
      obj = JSON.parse(data, options ? options.reviver : null);
    } catch (err2) {
      if (shouldThrow) {
        err2.message = file + ': ' + err2.message;
        return callback(err2);
      } else {
        return callback(null, null);
      }
    }

    callback(null, obj);
  });
}

function readFileSync(file, options) {
  options = options || {};
  if (typeof options === 'string') {
    options = { encoding: options };
  }

  var fs = options.fs || _fs;

  var shouldThrow = true;
  if ('throws' in options) {
    shouldThrow = options.throws;
  }

  try {
    var content = fs.readFileSync(file, options);
    content = stripBom(content);
    return JSON.parse(content, options.reviver);
  } catch (err) {
    if (shouldThrow) {
      err.message = file + ': ' + err.message;
      throw err;
    } else {
      return null;
    }
  }
}

function stringify(obj, options) {
  var spaces;
  var EOL = '\n';
  if (typeof options === 'object' && options !== null) {
    if (options.spaces) {
      spaces = options.spaces;
    }
    if (options.EOL) {
      EOL = options.EOL;
    }
  }

  var str = JSON.stringify(obj, options ? options.replacer : null, spaces);

  return str.replace(/\n/g, EOL) + EOL;
}

function writeFile(file, obj, options, callback) {
  if (callback == null) {
    callback = options;
    options = {};
  }
  options = options || {};
  var fs = options.fs || _fs;

  var str = '';
  try {
    str = stringify(obj, options);
  } catch (err) {
    // Need to return whether a callback was passed or not
    if (callback) callback(err, null);
    return;
  }

  fs.writeFile(file, str, options, callback);
}

function writeFileSync(file, obj, options) {
  options = options || {};
  var fs = options.fs || _fs;

  var str = stringify(obj, options);
  // not sure if fs.writeFileSync returns anything, but just in case
  return fs.writeFileSync(file, str, options);
}

function stripBom(content) {
  // we do this because JSON.parse would convert it to a utf8 string if encoding wasn't specified
  if (Buffer.isBuffer(content)) content = content.toString('utf8');
  content = content.replace(/^\uFEFF/, '');
  return content;
}

var jsonfile = {
  readFile: readFile,
  readFileSync: readFileSync,
  writeFile: writeFile,
  writeFileSync: writeFileSync
};

module.exports = jsonfile;

/***/ }),
/* 119 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const path = __webpack_require__(0);
const mkdir = __webpack_require__(7);
const pathExists = __webpack_require__(13).pathExists;
const jsonFile = __webpack_require__(30);

function outputJson(file, data, options, callback) {
  if (typeof options === 'function') {
    callback = options;
    options = {};
  }

  const dir = path.dirname(file);

  pathExists(dir, (err, itDoes) => {
    if (err) return callback(err);
    if (itDoes) return jsonFile.writeJson(file, data, options, callback);

    mkdir.mkdirs(dir, err => {
      if (err) return callback(err);
      jsonFile.writeJson(file, data, options, callback);
    });
  });
}

module.exports = outputJson;

/***/ }),
/* 120 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const fs = __webpack_require__(5);
const path = __webpack_require__(0);
const mkdir = __webpack_require__(7);
const jsonFile = __webpack_require__(30);

function outputJsonSync(file, data, options) {
  const dir = path.dirname(file);

  if (!fs.existsSync(dir)) {
    mkdir.mkdirsSync(dir);
  }

  jsonFile.writeJsonSync(file, data, options);
}

module.exports = outputJsonSync;

/***/ }),
/* 121 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// most of this code was written by Andrew Kelley
// licensed under the BSD license: see
// https://github.com/andrewrk/node-mv/blob/master/package.json

// this needs a cleanup

const u = __webpack_require__(6).fromCallback;
const fs = __webpack_require__(5);
const copy = __webpack_require__(47);
const path = __webpack_require__(0);
const remove = __webpack_require__(24).remove;
const mkdirp = __webpack_require__(7).mkdirs;

function move(src, dest, options, callback) {
  if (typeof options === 'function') {
    callback = options;
    options = {};
  }

  const overwrite = options.overwrite || options.clobber || false;

  isSrcSubdir(src, dest, (err, itIs) => {
    if (err) return callback(err);
    if (itIs) return callback(new Error(`Cannot move '${src}' to a subdirectory of itself, '${dest}'.`));
    mkdirp(path.dirname(dest), err => {
      if (err) return callback(err);
      doRename();
    });
  });

  function doRename() {
    if (path.resolve(src) === path.resolve(dest)) {
      fs.access(src, callback);
    } else if (overwrite) {
      fs.rename(src, dest, err => {
        if (!err) return callback();

        if (err.code === 'ENOTEMPTY' || err.code === 'EEXIST') {
          remove(dest, err => {
            if (err) return callback(err);
            options.overwrite = false; // just overwriteed it, no need to do it again
            move(src, dest, options, callback);
          });
          return;
        }

        // weird Windows shit
        if (err.code === 'EPERM') {
          setTimeout(() => {
            remove(dest, err => {
              if (err) return callback(err);
              options.overwrite = false;
              move(src, dest, options, callback);
            });
          }, 200);
          return;
        }

        if (err.code !== 'EXDEV') return callback(err);
        moveAcrossDevice(src, dest, overwrite, callback);
      });
    } else {
      fs.link(src, dest, err => {
        if (err) {
          if (err.code === 'EXDEV' || err.code === 'EISDIR' || err.code === 'EPERM' || err.code === 'ENOTSUP') {
            return moveAcrossDevice(src, dest, overwrite, callback);
          }
          return callback(err);
        }
        return fs.unlink(src, callback);
      });
    }
  }
}

function moveAcrossDevice(src, dest, overwrite, callback) {
  fs.stat(src, (err, stat) => {
    if (err) return callback(err);

    if (stat.isDirectory()) {
      moveDirAcrossDevice(src, dest, overwrite, callback);
    } else {
      moveFileAcrossDevice(src, dest, overwrite, callback);
    }
  });
}

function moveFileAcrossDevice(src, dest, overwrite, callback) {
  const flags = overwrite ? 'w' : 'wx';
  const ins = fs.createReadStream(src);
  const outs = fs.createWriteStream(dest, { flags });

  ins.on('error', err => {
    ins.destroy();
    outs.destroy();
    outs.removeListener('close', onClose);

    // may want to create a directory but `out` line above
    // creates an empty file for us: See #108
    // don't care about error here
    fs.unlink(dest, () => {
      // note: `err` here is from the input stream errror
      if (err.code === 'EISDIR' || err.code === 'EPERM') {
        moveDirAcrossDevice(src, dest, overwrite, callback);
      } else {
        callback(err);
      }
    });
  });

  outs.on('error', err => {
    ins.destroy();
    outs.destroy();
    outs.removeListener('close', onClose);
    callback(err);
  });

  outs.once('close', onClose);
  ins.pipe(outs);

  function onClose() {
    fs.unlink(src, callback);
  }
}

function moveDirAcrossDevice(src, dest, overwrite, callback) {
  const options = {
    overwrite: false
  };

  if (overwrite) {
    remove(dest, err => {
      if (err) return callback(err);
      startCopy();
    });
  } else {
    startCopy();
  }

  function startCopy() {
    copy(src, dest, options, err => {
      if (err) return callback(err);
      remove(src, callback);
    });
  }
}

// return true if dest is a subdir of src, otherwise false.
// extract dest base dir and check if that is the same as src basename
function isSrcSubdir(src, dest, cb) {
  fs.stat(src, (err, st) => {
    if (err) return cb(err);
    if (st.isDirectory()) {
      const baseDir = dest.split(path.dirname(src) + path.sep)[1];
      if (baseDir) {
        const destBasename = baseDir.split(path.sep)[0];
        if (destBasename) return cb(null, src !== dest && dest.indexOf(src) > -1 && destBasename === path.basename(src));
        return cb(null, false);
      }
      return cb(null, false);
    }
    return cb(null, false);
  });
}

module.exports = {
  move: u(move)
};

/***/ }),
/* 122 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const fs = __webpack_require__(5);
const path = __webpack_require__(0);
const copySync = __webpack_require__(50).copySync;
const removeSync = __webpack_require__(24).removeSync;
const mkdirpSync = __webpack_require__(7).mkdirsSync;
const buffer = __webpack_require__(51);

function moveSync(src, dest, options) {
  options = options || {};
  const overwrite = options.overwrite || options.clobber || false;

  src = path.resolve(src);
  dest = path.resolve(dest);

  if (src === dest) return fs.accessSync(src);

  if (isSrcSubdir(src, dest)) throw new Error(`Cannot move '${src}' into itself '${dest}'.`);

  mkdirpSync(path.dirname(dest));
  tryRenameSync();

  function tryRenameSync() {
    if (overwrite) {
      try {
        return fs.renameSync(src, dest);
      } catch (err) {
        if (err.code === 'ENOTEMPTY' || err.code === 'EEXIST' || err.code === 'EPERM') {
          removeSync(dest);
          options.overwrite = false; // just overwriteed it, no need to do it again
          return moveSync(src, dest, options);
        }

        if (err.code !== 'EXDEV') throw err;
        return moveSyncAcrossDevice(src, dest, overwrite);
      }
    } else {
      try {
        fs.linkSync(src, dest);
        return fs.unlinkSync(src);
      } catch (err) {
        if (err.code === 'EXDEV' || err.code === 'EISDIR' || err.code === 'EPERM' || err.code === 'ENOTSUP') {
          return moveSyncAcrossDevice(src, dest, overwrite);
        }
        throw err;
      }
    }
  }
}

function moveSyncAcrossDevice(src, dest, overwrite) {
  const stat = fs.statSync(src);

  if (stat.isDirectory()) {
    return moveDirSyncAcrossDevice(src, dest, overwrite);
  } else {
    return moveFileSyncAcrossDevice(src, dest, overwrite);
  }
}

function moveFileSyncAcrossDevice(src, dest, overwrite) {
  const BUF_LENGTH = 64 * 1024;
  const _buff = buffer(BUF_LENGTH);

  const flags = overwrite ? 'w' : 'wx';

  const fdr = fs.openSync(src, 'r');
  const stat = fs.fstatSync(fdr);
  const fdw = fs.openSync(dest, flags, stat.mode);
  let bytesRead = 1;
  let pos = 0;

  while (bytesRead > 0) {
    bytesRead = fs.readSync(fdr, _buff, 0, BUF_LENGTH, pos);
    fs.writeSync(fdw, _buff, 0, bytesRead);
    pos += bytesRead;
  }

  fs.closeSync(fdr);
  fs.closeSync(fdw);
  return fs.unlinkSync(src);
}

function moveDirSyncAcrossDevice(src, dest, overwrite) {
  const options = {
    overwrite: false
  };

  if (overwrite) {
    removeSync(dest);
    tryCopySync();
  } else {
    tryCopySync();
  }

  function tryCopySync() {
    copySync(src, dest, options);
    return removeSync(src);
  }
}

// return true if dest is a subdir of src, otherwise false.
// extract dest base dir and check if that is the same as src basename
function isSrcSubdir(src, dest) {
  try {
    return fs.statSync(src).isDirectory() && src !== dest && dest.indexOf(src) > -1 && dest.split(path.dirname(src) + path.sep)[1].split(path.sep)[0] === path.basename(src);
  } catch (e) {
    return false;
  }
}

module.exports = {
  moveSync
};

/***/ }),
/* 123 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const u = __webpack_require__(6).fromCallback;
const fs = __webpack_require__(12);
const path = __webpack_require__(0);
const mkdir = __webpack_require__(7);
const remove = __webpack_require__(24);

const emptyDir = u(function emptyDir(dir, callback) {
  callback = callback || function () {};
  fs.readdir(dir, (err, items) => {
    if (err) return mkdir.mkdirs(dir, callback);

    items = items.map(item => path.join(dir, item));

    deleteItem();

    function deleteItem() {
      const item = items.pop();
      if (!item) return callback();
      remove.remove(item, err => {
        if (err) return callback(err);
        deleteItem();
      });
    }
  });
});

function emptyDirSync(dir) {
  let items;
  try {
    items = fs.readdirSync(dir);
  } catch (err) {
    return mkdir.mkdirsSync(dir);
  }

  items.forEach(item => {
    item = path.join(dir, item);
    remove.removeSync(item);
  });
}

module.exports = {
  emptyDirSync,
  emptydirSync: emptyDirSync,
  emptyDir,
  emptydir: emptyDir
};

/***/ }),
/* 124 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const file = __webpack_require__(125);
const link = __webpack_require__(126);
const symlink = __webpack_require__(127);

module.exports = {
  // file
  createFile: file.createFile,
  createFileSync: file.createFileSync,
  ensureFile: file.createFile,
  ensureFileSync: file.createFileSync,
  // link
  createLink: link.createLink,
  createLinkSync: link.createLinkSync,
  ensureLink: link.createLink,
  ensureLinkSync: link.createLinkSync,
  // symlink
  createSymlink: symlink.createSymlink,
  createSymlinkSync: symlink.createSymlinkSync,
  ensureSymlink: symlink.createSymlink,
  ensureSymlinkSync: symlink.createSymlinkSync
};

/***/ }),
/* 125 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const u = __webpack_require__(6).fromCallback;
const path = __webpack_require__(0);
const fs = __webpack_require__(5);
const mkdir = __webpack_require__(7);
const pathExists = __webpack_require__(13).pathExists;

function createFile(file, callback) {
  function makeFile() {
    fs.writeFile(file, '', err => {
      if (err) return callback(err);
      callback();
    });
  }

  fs.stat(file, (err, stats) => {
    // eslint-disable-line handle-callback-err
    if (!err && stats.isFile()) return callback();
    const dir = path.dirname(file);
    pathExists(dir, (err, dirExists) => {
      if (err) return callback(err);
      if (dirExists) return makeFile();
      mkdir.mkdirs(dir, err => {
        if (err) return callback(err);
        makeFile();
      });
    });
  });
}

function createFileSync(file) {
  let stats;
  try {
    stats = fs.statSync(file);
  } catch (e) {}
  if (stats && stats.isFile()) return;

  const dir = path.dirname(file);
  if (!fs.existsSync(dir)) {
    mkdir.mkdirsSync(dir);
  }

  fs.writeFileSync(file, '');
}

module.exports = {
  createFile: u(createFile),
  createFileSync
};

/***/ }),
/* 126 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const u = __webpack_require__(6).fromCallback;
const path = __webpack_require__(0);
const fs = __webpack_require__(5);
const mkdir = __webpack_require__(7);
const pathExists = __webpack_require__(13).pathExists;

function createLink(srcpath, dstpath, callback) {
  function makeLink(srcpath, dstpath) {
    fs.link(srcpath, dstpath, err => {
      if (err) return callback(err);
      callback(null);
    });
  }

  pathExists(dstpath, (err, destinationExists) => {
    if (err) return callback(err);
    if (destinationExists) return callback(null);
    fs.lstat(srcpath, (err, stat) => {
      if (err) {
        err.message = err.message.replace('lstat', 'ensureLink');
        return callback(err);
      }

      const dir = path.dirname(dstpath);
      pathExists(dir, (err, dirExists) => {
        if (err) return callback(err);
        if (dirExists) return makeLink(srcpath, dstpath);
        mkdir.mkdirs(dir, err => {
          if (err) return callback(err);
          makeLink(srcpath, dstpath);
        });
      });
    });
  });
}

function createLinkSync(srcpath, dstpath, callback) {
  const destinationExists = fs.existsSync(dstpath);
  if (destinationExists) return undefined;

  try {
    fs.lstatSync(srcpath);
  } catch (err) {
    err.message = err.message.replace('lstat', 'ensureLink');
    throw err;
  }

  const dir = path.dirname(dstpath);
  const dirExists = fs.existsSync(dir);
  if (dirExists) return fs.linkSync(srcpath, dstpath);
  mkdir.mkdirsSync(dir);

  return fs.linkSync(srcpath, dstpath);
}

module.exports = {
  createLink: u(createLink),
  createLinkSync
};

/***/ }),
/* 127 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const u = __webpack_require__(6).fromCallback;
const path = __webpack_require__(0);
const fs = __webpack_require__(5);
const _mkdirs = __webpack_require__(7);
const mkdirs = _mkdirs.mkdirs;
const mkdirsSync = _mkdirs.mkdirsSync;

const _symlinkPaths = __webpack_require__(128);
const symlinkPaths = _symlinkPaths.symlinkPaths;
const symlinkPathsSync = _symlinkPaths.symlinkPathsSync;

const _symlinkType = __webpack_require__(129);
const symlinkType = _symlinkType.symlinkType;
const symlinkTypeSync = _symlinkType.symlinkTypeSync;

const pathExists = __webpack_require__(13).pathExists;

function createSymlink(srcpath, dstpath, type, callback) {
  callback = typeof type === 'function' ? type : callback;
  type = typeof type === 'function' ? false : type;

  pathExists(dstpath, (err, destinationExists) => {
    if (err) return callback(err);
    if (destinationExists) return callback(null);
    symlinkPaths(srcpath, dstpath, (err, relative) => {
      if (err) return callback(err);
      srcpath = relative.toDst;
      symlinkType(relative.toCwd, type, (err, type) => {
        if (err) return callback(err);
        const dir = path.dirname(dstpath);
        pathExists(dir, (err, dirExists) => {
          if (err) return callback(err);
          if (dirExists) return fs.symlink(srcpath, dstpath, type, callback);
          mkdirs(dir, err => {
            if (err) return callback(err);
            fs.symlink(srcpath, dstpath, type, callback);
          });
        });
      });
    });
  });
}

function createSymlinkSync(srcpath, dstpath, type, callback) {
  callback = typeof type === 'function' ? type : callback;
  type = typeof type === 'function' ? false : type;

  const destinationExists = fs.existsSync(dstpath);
  if (destinationExists) return undefined;

  const relative = symlinkPathsSync(srcpath, dstpath);
  srcpath = relative.toDst;
  type = symlinkTypeSync(relative.toCwd, type);
  const dir = path.dirname(dstpath);
  const exists = fs.existsSync(dir);
  if (exists) return fs.symlinkSync(srcpath, dstpath, type);
  mkdirsSync(dir);
  return fs.symlinkSync(srcpath, dstpath, type);
}

module.exports = {
  createSymlink: u(createSymlink),
  createSymlinkSync
};

/***/ }),
/* 128 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const path = __webpack_require__(0);
const fs = __webpack_require__(5);
const pathExists = __webpack_require__(13).pathExists;

/**
 * Function that returns two types of paths, one relative to symlink, and one
 * relative to the current working directory. Checks if path is absolute or
 * relative. If the path is relative, this function checks if the path is
 * relative to symlink or relative to current working directory. This is an
 * initiative to find a smarter `srcpath` to supply when building symlinks.
 * This allows you to determine which path to use out of one of three possible
 * types of source paths. The first is an absolute path. This is detected by
 * `path.isAbsolute()`. When an absolute path is provided, it is checked to
 * see if it exists. If it does it's used, if not an error is returned
 * (callback)/ thrown (sync). The other two options for `srcpath` are a
 * relative url. By default Node's `fs.symlink` works by creating a symlink
 * using `dstpath` and expects the `srcpath` to be relative to the newly
 * created symlink. If you provide a `srcpath` that does not exist on the file
 * system it results in a broken symlink. To minimize this, the function
 * checks to see if the 'relative to symlink' source file exists, and if it
 * does it will use it. If it does not, it checks if there's a file that
 * exists that is relative to the current working directory, if does its used.
 * This preserves the expectations of the original fs.symlink spec and adds
 * the ability to pass in `relative to current working direcotry` paths.
 */

function symlinkPaths(srcpath, dstpath, callback) {
  if (path.isAbsolute(srcpath)) {
    return fs.lstat(srcpath, (err, stat) => {
      if (err) {
        err.message = err.message.replace('lstat', 'ensureSymlink');
        return callback(err);
      }
      return callback(null, {
        'toCwd': srcpath,
        'toDst': srcpath
      });
    });
  } else {
    const dstdir = path.dirname(dstpath);
    const relativeToDst = path.join(dstdir, srcpath);
    return pathExists(relativeToDst, (err, exists) => {
      if (err) return callback(err);
      if (exists) {
        return callback(null, {
          'toCwd': relativeToDst,
          'toDst': srcpath
        });
      } else {
        return fs.lstat(srcpath, (err, stat) => {
          if (err) {
            err.message = err.message.replace('lstat', 'ensureSymlink');
            return callback(err);
          }
          return callback(null, {
            'toCwd': srcpath,
            'toDst': path.relative(dstdir, srcpath)
          });
        });
      }
    });
  }
}

function symlinkPathsSync(srcpath, dstpath) {
  let exists;
  if (path.isAbsolute(srcpath)) {
    exists = fs.existsSync(srcpath);
    if (!exists) throw new Error('absolute srcpath does not exist');
    return {
      'toCwd': srcpath,
      'toDst': srcpath
    };
  } else {
    const dstdir = path.dirname(dstpath);
    const relativeToDst = path.join(dstdir, srcpath);
    exists = fs.existsSync(relativeToDst);
    if (exists) {
      return {
        'toCwd': relativeToDst,
        'toDst': srcpath
      };
    } else {
      exists = fs.existsSync(srcpath);
      if (!exists) throw new Error('relative srcpath does not exist');
      return {
        'toCwd': srcpath,
        'toDst': path.relative(dstdir, srcpath)
      };
    }
  }
}

module.exports = {
  symlinkPaths,
  symlinkPathsSync
};

/***/ }),
/* 129 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const fs = __webpack_require__(5);

function symlinkType(srcpath, type, callback) {
  callback = typeof type === 'function' ? type : callback;
  type = typeof type === 'function' ? false : type;
  if (type) return callback(null, type);
  fs.lstat(srcpath, (err, stats) => {
    if (err) return callback(null, 'file');
    type = stats && stats.isDirectory() ? 'dir' : 'file';
    callback(null, type);
  });
}

function symlinkTypeSync(srcpath, type) {
  let stats;

  if (type) return type;
  try {
    stats = fs.lstatSync(srcpath);
  } catch (e) {
    return 'file';
  }
  return stats && stats.isDirectory() ? 'dir' : 'file';
}

module.exports = {
  symlinkType,
  symlinkTypeSync
};

/***/ }),
/* 130 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const u = __webpack_require__(6).fromCallback;
const fs = __webpack_require__(5);
const path = __webpack_require__(0);
const mkdir = __webpack_require__(7);
const pathExists = __webpack_require__(13).pathExists;

function outputFile(file, data, encoding, callback) {
  if (typeof encoding === 'function') {
    callback = encoding;
    encoding = 'utf8';
  }

  const dir = path.dirname(file);
  pathExists(dir, (err, itDoes) => {
    if (err) return callback(err);
    if (itDoes) return fs.writeFile(file, data, encoding, callback);

    mkdir.mkdirs(dir, err => {
      if (err) return callback(err);

      fs.writeFile(file, data, encoding, callback);
    });
  });
}

function outputFileSync(file, data, encoding) {
  const dir = path.dirname(file);
  if (fs.existsSync(dir)) {
    return fs.writeFileSync.apply(fs, arguments);
  }
  mkdir.mkdirsSync(dir);
  fs.writeFileSync.apply(fs, arguments);
}

module.exports = {
  outputFile: u(outputFile),
  outputFileSync
};

/***/ }),
/* 131 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.githubUrl = githubUrl;
exports.getS3LikeProviderBaseUrl = getS3LikeProviderBaseUrl;
/** @private */
function githubUrl(options, defaultHost = "github.com") {
    return `${options.protocol || "https"}://${options.host || defaultHost}`;
}
function getS3LikeProviderBaseUrl(configuration) {
    const provider = configuration.provider;
    if (provider === "s3") {
        return s3Url(configuration);
    }
    if (provider === "spaces") {
        return spacesUrl(configuration);
    }
    throw new Error(`Not supported provider: ${provider}`);
}
function s3Url(options) {
    let url;
    if (options.endpoint != null) {
        url = `${options.endpoint}/${options.bucket}`;
    } else {
        if (!options.bucket.includes(".")) {
            if (options.region === "cn-north-1") {
                url = `https://${options.bucket}.s3.${options.region}.amazonaws.com.cn`;
            } else {
                url = `https://${options.bucket}.s3.amazonaws.com`;
            }
        } else {
            if (options.region == null) {
                throw new Error(`Bucket name "${options.bucket}" includes a dot, but S3 region is missing`);
            }
            // special case, see http://docs.aws.amazon.com/AmazonS3/latest/dev/UsingBucket.html#access-bucket-intro
            url = options.region === "us-east-1" ? `https://s3.amazonaws.com/${options.bucket}` : `https://s3-${options.region}.amazonaws.com/${options.bucket}`;
        }
    }
    if (options.path != null) {
        url += `/${options.path}`;
    }
    return url;
}
function spacesUrl(options) {
    if (options.name == null) {
        throw new Error(`name is missing`);
    }
    if (options.region == null) {
        throw new Error(`region is missing`);
    }
    let url = `https://${options.name}.${options.region}.digitaloceanspaces.com`;
    if (options.path != null) {
        url += `/${options.path}`;
    }
    return url;
}
//# sourceMappingURL=publishOptions.js.map

/***/ }),
/* 132 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.parseDn = parseDn;
function parseDn(seq) {
    let quoted = false;
    let key = null;
    let token = "";
    let nextNonSpace = 0;
    seq = seq.trim();
    const result = new Map();
    for (let i = 0; i <= seq.length; i++) {
        if (i === seq.length) {
            if (key !== null) {
                result.set(key, token);
            }
            break;
        }
        const ch = seq[i];
        if (quoted) {
            if (ch === '"') {
                quoted = false;
                continue;
            }
        } else {
            if (ch === '"') {
                quoted = true;
                continue;
            }
            if (ch === "\\") {
                i++;
                const ord = parseInt(seq.slice(i, i + 2), 16);
                if (Number.isNaN(ord)) {
                    token += seq[i];
                } else {
                    i++;
                    token += String.fromCharCode(ord);
                }
                continue;
            }
            if (key === null && ch === "=") {
                key = token;
                token = "";
                continue;
            }
            if (ch === "," || ch === ";" || ch === "+") {
                if (key !== null) {
                    result.set(key, token);
                }
                key = null;
                token = "";
                continue;
            }
        }
        if (ch === " " && !quoted) {
            if (token.length === 0) {
                continue;
            }
            if (i > nextNonSpace) {
                let j = i;
                while (seq[j] === " ") {
                    j++;
                }
                nextNonSpace = j;
            }
            if (nextNonSpace >= seq.length || seq[nextNonSpace] === "," || seq[nextNonSpace] === ";" || key === null && seq[nextNonSpace] === "=" || key !== null && seq[nextNonSpace] === "+") {
                i = nextNonSpace - 1;
                continue;
            }
        }
        token += ch;
    }
    return result;
}
//# sourceMappingURL=rfc2253Parser.js.map

/***/ }),
/* 133 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.nil = exports.UUID = undefined;

var _crypto;

function _load_crypto() {
    return _crypto = __webpack_require__(28);
}

var _index;

function _load_index() {
    return _index = __webpack_require__(3);
}

const invalidName = "options.name must be either a string or a Buffer";
const moreThan10000 = "can not generate more than 10000 UUIDs per second";
// Node ID according to rfc4122#section-4.5
const randomHost = (0, (_crypto || _load_crypto()).randomBytes)(16);
randomHost[0] = randomHost[0] | 0x01;
// randomize clockSeq initially, as per rfc4122#section-4.1.5
const seed = (0, (_crypto || _load_crypto()).randomBytes)(2);
let clockSeq = (seed[0] | seed[1] << 8) & 0x3fff;
// clock values
let lastMTime = 0;
let lastNTime = 0;
// lookup table hex to byte
const hex2byte = {};
// lookup table byte to hex
const byte2hex = [];
// populate lookup tables
for (let i = 0; i < 256; i++) {
    const hex = (i + 0x100).toString(16).substr(1);
    hex2byte[hex] = i;
    byte2hex[i] = hex;
}
// UUID class
class UUID {
    constructor(uuid) {
        const check = UUID.check(uuid);
        if (!check) {
            throw new Error("not a UUID");
        }
        this.version = check.version;
        if (check.format === "ascii") {
            this.ascii = uuid;
        } else {
            this.binary = uuid;
        }
    }
    static v1() {
        return uuidTimeBased(randomHost);
    }
    static v5(name, namespace) {
        return uuidNamed(name, "sha1", 0x50, namespace);
    }
    toString() {
        if (this.ascii == null) {
            this.ascii = stringify(this.binary);
        }
        return this.ascii;
    }
    toBuffer() {
        if (this.binary == null) {
            this.binary = UUID.parse(this.ascii);
        }
        return Buffer.from(this.binary);
    }
    inspect() {
        return `UUID v${this.version} ${this.toString()}`;
    }
    static check(uuid, offset = 0) {
        if (typeof uuid === "string") {
            uuid = uuid.toLowerCase();
            if (!/^[a-f0-9]{8}(\-[a-f0-9]{4}){3}\-([a-f0-9]{12})$/.test(uuid)) {
                return false;
            }
            if (uuid === "00000000-0000-0000-0000-000000000000") {
                return { version: undefined, variant: "nil", format: "ascii" };
            }
            return {
                version: (hex2byte[uuid[14] + uuid[15]] & 0xf0) >> 4,
                variant: getVariant((hex2byte[uuid[19] + uuid[20]] & 0xe0) >> 5),
                format: "ascii"
            };
        }
        if (Buffer.isBuffer(uuid)) {
            if (uuid.length < offset + 16) {
                return false;
            }
            let i = 0;
            for (; i < 16; i++) {
                if (uuid[offset + i] !== 0) {
                    break;
                }
            }
            if (i === 16) {
                return { version: undefined, variant: "nil", format: "binary" };
            }
            return {
                version: (uuid[offset + 6] & 0xf0) >> 4,
                variant: getVariant((uuid[offset + 8] & 0xe0) >> 5),
                format: "binary"
            };
        }
        throw (0, (_index || _load_index()).newError)("Unknown type of uuid", "ERR_UNKNOWN_UUID_TYPE");
    }
    // read stringified uuid into a Buffer
    static parse(input) {
        const buffer = Buffer.allocUnsafe(16);
        let j = 0;
        for (let i = 0; i < 16; i++) {
            buffer[i] = hex2byte[input[j++] + input[j++]];
            if (i === 3 || i === 5 || i === 7 || i === 9) {
                j += 1;
            }
        }
        return buffer;
    }
}
exports.UUID = UUID; // from rfc4122#appendix-C

UUID.URL = new UUID("6ba7b811-9dad-11d1-80b4-00c04fd430c8");
UUID.OID = UUID.parse("6ba7b812-9dad-11d1-80b4-00c04fd430c8");
// according to rfc4122#section-4.1.1
function getVariant(bits) {
    switch (bits) {
        case 0:
        case 1:
        case 3:
            return "ncs";
        case 4:
        case 5:
            return "rfc4122";
        case 6:
            return "microsoft";
        default:
            return "future";
    }
}
var UuidEncoding;
(function (UuidEncoding) {
    UuidEncoding[UuidEncoding["ASCII"] = 0] = "ASCII";
    UuidEncoding[UuidEncoding["BINARY"] = 1] = "BINARY";
    UuidEncoding[UuidEncoding["OBJECT"] = 2] = "OBJECT";
})(UuidEncoding || (UuidEncoding = {}));
// v1
function uuidTimeBased(nodeId, encoding = UuidEncoding.ASCII) {
    let mTime = Date.now();
    let nTime = lastNTime + 1;
    const delta = mTime - lastMTime + (nTime - lastNTime) / 10000;
    if (delta < 0) {
        clockSeq = clockSeq + 1 & 0x3fff;
        nTime = 0;
    } else if (mTime > lastMTime) {
        nTime = 0;
    } else if (nTime >= 10000) {
        return moreThan10000;
    }
    lastMTime = mTime;
    lastNTime = nTime;
    // unix timestamp to gregorian epoch as per rfc4122#section-4.5
    mTime += 12219292800000;
    const buffer = Buffer.allocUnsafe(16);
    const myClockSeq = clockSeq;
    const timeLow = ((mTime & 0xfffffff) * 10000 + nTime) % 0x100000000;
    const timeHigh = mTime / 0x100000000 * 10000 & 0xfffffff;
    buffer[0] = timeLow >>> 24 & 0xff;
    buffer[1] = timeLow >>> 16 & 0xff;
    buffer[2] = timeLow >>> 8 & 0xff;
    buffer[3] = timeLow & 0xff;
    buffer[4] = timeHigh >>> 8 & 0xff;
    buffer[5] = timeHigh & 0xff;
    buffer[6] = timeHigh >>> 24 & 0x0f | 0x10;
    buffer[7] = timeHigh >>> 16 & 0x3f | 0x80;
    buffer[8] = myClockSeq >>> 8;
    buffer[9] = myClockSeq & 0xff;
    let result;
    switch (encoding) {
        case UuidEncoding.BINARY:
            buffer[10] = nodeId[0];
            buffer[11] = nodeId[1];
            buffer[12] = nodeId[2];
            buffer[13] = nodeId[3];
            buffer[14] = nodeId[4];
            buffer[15] = nodeId[5];
            result = buffer;
            break;
        case UuidEncoding.OBJECT:
            buffer[10] = nodeId[0];
            buffer[11] = nodeId[1];
            buffer[12] = nodeId[2];
            buffer[13] = nodeId[3];
            buffer[14] = nodeId[4];
            buffer[15] = nodeId[5];
            result = new UUID(buffer);
            break;
        default:
            result = byte2hex[buffer[0]] + byte2hex[buffer[1]] + byte2hex[buffer[2]] + byte2hex[buffer[3]] + "-" + byte2hex[buffer[4]] + byte2hex[buffer[5]] + "-" + byte2hex[buffer[6]] + byte2hex[buffer[7]] + "-" + byte2hex[buffer[8]] + byte2hex[buffer[9]] + "-" + byte2hex[nodeId[0]] + byte2hex[nodeId[1]] + byte2hex[nodeId[2]] + byte2hex[nodeId[3]] + byte2hex[nodeId[4]] + byte2hex[nodeId[5]];
            break;
    }
    return result;
}
// v3 + v5
function uuidNamed(name, hashMethod, version, namespace, encoding = UuidEncoding.ASCII) {
    const hash = (0, (_crypto || _load_crypto()).createHash)(hashMethod);
    const nameIsNotAString = typeof name !== "string";
    if (nameIsNotAString && !Buffer.isBuffer(name)) {
        throw (0, (_index || _load_index()).newError)(invalidName, "ERR_INVALID_UUID_NAME");
    }
    hash.update(namespace);
    hash.update(name, nameIsNotAString ? "latin1" : "utf8");
    const buffer = hash.digest();
    let result;
    switch (encoding) {
        case UuidEncoding.BINARY:
            buffer[6] = buffer[6] & 0x0f | version;
            buffer[8] = buffer[8] & 0x3f | 0x80;
            result = buffer;
            break;
        case UuidEncoding.OBJECT:
            buffer[6] = buffer[6] & 0x0f | version;
            buffer[8] = buffer[8] & 0x3f | 0x80;
            result = new UUID(buffer);
            break;
        default:
            result = byte2hex[buffer[0]] + byte2hex[buffer[1]] + byte2hex[buffer[2]] + byte2hex[buffer[3]] + "-" + byte2hex[buffer[4]] + byte2hex[buffer[5]] + "-" + byte2hex[buffer[6] & 0x0f | version] + byte2hex[buffer[7]] + "-" + byte2hex[buffer[8] & 0x3f | 0x80] + byte2hex[buffer[9]] + "-" + byte2hex[buffer[10]] + byte2hex[buffer[11]] + byte2hex[buffer[12]] + byte2hex[buffer[13]] + byte2hex[buffer[14]] + byte2hex[buffer[15]];
            break;
    }
    return result;
}
function stringify(buffer) {
    return byte2hex[buffer[0]] + byte2hex[buffer[1]] + byte2hex[buffer[2]] + byte2hex[buffer[3]] + "-" + byte2hex[buffer[4]] + byte2hex[buffer[5]] + "-" + byte2hex[buffer[6]] + byte2hex[buffer[7]] + "-" + byte2hex[buffer[8]] + byte2hex[buffer[9]] + "-" + byte2hex[buffer[10]] + byte2hex[buffer[11]] + byte2hex[buffer[12]] + byte2hex[buffer[13]] + byte2hex[buffer[14]] + byte2hex[buffer[15]];
}
// according to rfc4122#section-4.1.7
const nil = exports.nil = new UUID("00000000-0000-0000-0000-000000000000");
// UUID.v4 = uuidRandom
// UUID.v4fast = uuidRandomFast
// UUID.v3 = function(options, callback) {
//     return uuidNamed("md5", 0x30, options, callback)
// } 
//# sourceMappingURL=uuid.js.map

/***/ }),
/* 134 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.XElement = undefined;
exports.parseXml = parseXml;

var _sax;

function _load_sax() {
    return _sax = _interopRequireWildcard(__webpack_require__(135));
}

var _index;

function _load_index() {
    return _index = __webpack_require__(3);
}

function _interopRequireWildcard(obj) {
    if (obj && obj.__esModule) {
        return obj;
    } else {
        var newObj = {};if (obj != null) {
            for (var key in obj) {
                if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key];
            }
        }newObj.default = obj;return newObj;
    }
}

class XElement {
    constructor(name) {
        this.name = name;
        this.value = "";
        this.attributes = null;
        this.isCData = false;
        this.elements = null;
        if (!name) {
            throw (0, (_index || _load_index()).newError)("Element name cannot be empty", "ERR_XML_ELEMENT_NAME_EMPTY");
        }
        if (!isValidName(name)) {
            throw (0, (_index || _load_index()).newError)(`Invalid element name: ${name}`, "ERR_XML_ELEMENT_INVALID_NAME");
        }
    }
    attribute(name) {
        const result = this.attributes === null ? null : this.attributes[name];
        if (result == null) {
            throw (0, (_index || _load_index()).newError)(`No attribute "${name}"`, "ERR_XML_MISSED_ATTRIBUTE");
        }
        return result;
    }
    removeAttribute(name) {
        if (this.attributes !== null) {
            delete this.attributes[name];
        }
    }
    element(name, ignoreCase = false, errorIfMissed = null) {
        const result = this.elementOrNull(name, ignoreCase);
        if (result === null) {
            throw (0, (_index || _load_index()).newError)(errorIfMissed || `No element "${name}"`, "ERR_XML_MISSED_ELEMENT");
        }
        return result;
    }
    elementOrNull(name, ignoreCase = false) {
        if (this.elements === null) {
            return null;
        }
        for (const element of this.elements) {
            if (isNameEquals(element, name, ignoreCase)) {
                return element;
            }
        }
        return null;
    }
    getElements(name, ignoreCase = false) {
        if (this.elements === null) {
            return [];
        }
        return this.elements.filter(it => isNameEquals(it, name, ignoreCase));
    }
    elementValueOrEmpty(name, ignoreCase = false) {
        const element = this.elementOrNull(name, ignoreCase);
        return element === null ? "" : element.value;
    }
}
exports.XElement = XElement;
const NAME_REG_EXP = new RegExp(/^[A-Za-z_][:A-Za-z0-9_-]*$/i);
function isValidName(name) {
    return NAME_REG_EXP.test(name);
}
function isNameEquals(element, name, ignoreCase) {
    const elementName = element.name;
    return elementName === name || ignoreCase === true && elementName.length === name.length && elementName.toLowerCase() === name.toLowerCase();
}
function parseXml(data) {
    let rootElement = null;
    const parser = (_sax || _load_sax()).parser(true, {});
    const elements = [];
    parser.onopentag = saxElement => {
        const element = new XElement(saxElement.name);
        element.attributes = saxElement.attributes;
        if (rootElement === null) {
            rootElement = element;
        } else {
            const parent = elements[elements.length - 1];
            if (parent.elements == null) {
                parent.elements = [];
            }
            parent.elements.push(element);
        }
        elements.push(element);
    };
    parser.onclosetag = () => {
        elements.pop();
    };
    parser.ontext = text => {
        if (elements.length > 0) {
            elements[elements.length - 1].value = text;
        }
    };
    parser.oncdata = cdata => {
        const element = elements[elements.length - 1];
        element.value = cdata;
        element.isCData = true;
    };
    parser.onerror = err => {
        throw err;
    };
    parser.write(data);
    return rootElement;
}
//# sourceMappingURL=xml.js.map

/***/ }),
/* 135 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


;(function (sax) {
  // wrapper for non-node envs
  sax.parser = function (strict, opt) {
    return new SAXParser(strict, opt);
  };
  sax.SAXParser = SAXParser;
  sax.SAXStream = SAXStream;
  sax.createStream = createStream;

  // When we pass the MAX_BUFFER_LENGTH position, start checking for buffer overruns.
  // When we check, schedule the next check for MAX_BUFFER_LENGTH - (max(buffer lengths)),
  // since that's the earliest that a buffer overrun could occur.  This way, checks are
  // as rare as required, but as often as necessary to ensure never crossing this bound.
  // Furthermore, buffers are only tested at most once per write(), so passing a very
  // large string into write() might have undesirable effects, but this is manageable by
  // the caller, so it is assumed to be safe.  Thus, a call to write() may, in the extreme
  // edge case, result in creating at most one complete copy of the string passed in.
  // Set to Infinity to have unlimited buffers.
  sax.MAX_BUFFER_LENGTH = 64 * 1024;

  var buffers = ['comment', 'sgmlDecl', 'textNode', 'tagName', 'doctype', 'procInstName', 'procInstBody', 'entity', 'attribName', 'attribValue', 'cdata', 'script'];

  sax.EVENTS = ['text', 'processinginstruction', 'sgmldeclaration', 'doctype', 'comment', 'opentagstart', 'attribute', 'opentag', 'closetag', 'opencdata', 'cdata', 'closecdata', 'error', 'end', 'ready', 'script', 'opennamespace', 'closenamespace'];

  function SAXParser(strict, opt) {
    if (!(this instanceof SAXParser)) {
      return new SAXParser(strict, opt);
    }

    var parser = this;
    clearBuffers(parser);
    parser.q = parser.c = '';
    parser.bufferCheckPosition = sax.MAX_BUFFER_LENGTH;
    parser.opt = opt || {};
    parser.opt.lowercase = parser.opt.lowercase || parser.opt.lowercasetags;
    parser.looseCase = parser.opt.lowercase ? 'toLowerCase' : 'toUpperCase';
    parser.tags = [];
    parser.closed = parser.closedRoot = parser.sawRoot = false;
    parser.tag = parser.error = null;
    parser.strict = !!strict;
    parser.noscript = !!(strict || parser.opt.noscript);
    parser.state = S.BEGIN;
    parser.strictEntities = parser.opt.strictEntities;
    parser.ENTITIES = parser.strictEntities ? Object.create(sax.XML_ENTITIES) : Object.create(sax.ENTITIES);
    parser.attribList = [];

    // namespaces form a prototype chain.
    // it always points at the current tag,
    // which protos to its parent tag.
    if (parser.opt.xmlns) {
      parser.ns = Object.create(rootNS);
    }

    // mostly just for error reporting
    parser.trackPosition = parser.opt.position !== false;
    if (parser.trackPosition) {
      parser.position = parser.line = parser.column = 0;
    }
    emit(parser, 'onready');
  }

  if (!Object.create) {
    Object.create = function (o) {
      function F() {}
      F.prototype = o;
      var newf = new F();
      return newf;
    };
  }

  if (!Object.keys) {
    Object.keys = function (o) {
      var a = [];
      for (var i in o) if (o.hasOwnProperty(i)) a.push(i);
      return a;
    };
  }

  function checkBufferLength(parser) {
    var maxAllowed = Math.max(sax.MAX_BUFFER_LENGTH, 10);
    var maxActual = 0;
    for (var i = 0, l = buffers.length; i < l; i++) {
      var len = parser[buffers[i]].length;
      if (len > maxAllowed) {
        // Text/cdata nodes can get big, and since they're buffered,
        // we can get here under normal conditions.
        // Avoid issues by emitting the text node now,
        // so at least it won't get any bigger.
        switch (buffers[i]) {
          case 'textNode':
            closeText(parser);
            break;

          case 'cdata':
            emitNode(parser, 'oncdata', parser.cdata);
            parser.cdata = '';
            break;

          case 'script':
            emitNode(parser, 'onscript', parser.script);
            parser.script = '';
            break;

          default:
            error(parser, 'Max buffer length exceeded: ' + buffers[i]);
        }
      }
      maxActual = Math.max(maxActual, len);
    }
    // schedule the next check for the earliest possible buffer overrun.
    var m = sax.MAX_BUFFER_LENGTH - maxActual;
    parser.bufferCheckPosition = m + parser.position;
  }

  function clearBuffers(parser) {
    for (var i = 0, l = buffers.length; i < l; i++) {
      parser[buffers[i]] = '';
    }
  }

  function flushBuffers(parser) {
    closeText(parser);
    if (parser.cdata !== '') {
      emitNode(parser, 'oncdata', parser.cdata);
      parser.cdata = '';
    }
    if (parser.script !== '') {
      emitNode(parser, 'onscript', parser.script);
      parser.script = '';
    }
  }

  SAXParser.prototype = {
    end: function () {
      end(this);
    },
    write: write,
    resume: function () {
      this.error = null;return this;
    },
    close: function () {
      return this.write(null);
    },
    flush: function () {
      flushBuffers(this);
    }
  };

  var Stream;
  try {
    Stream = __webpack_require__(19).Stream;
  } catch (ex) {
    Stream = function () {};
  }

  var streamWraps = sax.EVENTS.filter(function (ev) {
    return ev !== 'error' && ev !== 'end';
  });

  function createStream(strict, opt) {
    return new SAXStream(strict, opt);
  }

  function SAXStream(strict, opt) {
    if (!(this instanceof SAXStream)) {
      return new SAXStream(strict, opt);
    }

    Stream.apply(this);

    this._parser = new SAXParser(strict, opt);
    this.writable = true;
    this.readable = true;

    var me = this;

    this._parser.onend = function () {
      me.emit('end');
    };

    this._parser.onerror = function (er) {
      me.emit('error', er);

      // if didn't throw, then means error was handled.
      // go ahead and clear error, so we can write again.
      me._parser.error = null;
    };

    this._decoder = null;

    streamWraps.forEach(function (ev) {
      Object.defineProperty(me, 'on' + ev, {
        get: function () {
          return me._parser['on' + ev];
        },
        set: function (h) {
          if (!h) {
            me.removeAllListeners(ev);
            me._parser['on' + ev] = h;
            return h;
          }
          me.on(ev, h);
        },
        enumerable: true,
        configurable: false
      });
    });
  }

  SAXStream.prototype = Object.create(Stream.prototype, {
    constructor: {
      value: SAXStream
    }
  });

  SAXStream.prototype.write = function (data) {
    if (typeof Buffer === 'function' && typeof Buffer.isBuffer === 'function' && Buffer.isBuffer(data)) {
      if (!this._decoder) {
        var SD = __webpack_require__(136).StringDecoder;
        this._decoder = new SD('utf8');
      }
      data = this._decoder.write(data);
    }

    this._parser.write(data.toString());
    this.emit('data', data);
    return true;
  };

  SAXStream.prototype.end = function (chunk) {
    if (chunk && chunk.length) {
      this.write(chunk);
    }
    this._parser.end();
    return true;
  };

  SAXStream.prototype.on = function (ev, handler) {
    var me = this;
    if (!me._parser['on' + ev] && streamWraps.indexOf(ev) !== -1) {
      me._parser['on' + ev] = function () {
        var args = arguments.length === 1 ? [arguments[0]] : Array.apply(null, arguments);
        args.splice(0, 0, ev);
        me.emit.apply(me, args);
      };
    }

    return Stream.prototype.on.call(me, ev, handler);
  };

  // this really needs to be replaced with character classes.
  // XML allows all manner of ridiculous numbers and digits.
  var CDATA = '[CDATA[';
  var DOCTYPE = 'DOCTYPE';
  var XML_NAMESPACE = 'http://www.w3.org/XML/1998/namespace';
  var XMLNS_NAMESPACE = 'http://www.w3.org/2000/xmlns/';
  var rootNS = { xml: XML_NAMESPACE, xmlns: XMLNS_NAMESPACE

    // http://www.w3.org/TR/REC-xml/#NT-NameStartChar
    // This implementation works on strings, a single character at a time
    // as such, it cannot ever support astral-plane characters (10000-EFFFF)
    // without a significant breaking change to either this  parser, or the
    // JavaScript language.  Implementation of an emoji-capable xml parser
    // is left as an exercise for the reader.
  };var nameStart = /[:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]/;

  var nameBody = /[:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\u00B7\u0300-\u036F\u203F-\u2040.\d-]/;

  var entityStart = /[#:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]/;
  var entityBody = /[#:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\u00B7\u0300-\u036F\u203F-\u2040.\d-]/;

  function isWhitespace(c) {
    return c === ' ' || c === '\n' || c === '\r' || c === '\t';
  }

  function isQuote(c) {
    return c === '"' || c === '\'';
  }

  function isAttribEnd(c) {
    return c === '>' || isWhitespace(c);
  }

  function isMatch(regex, c) {
    return regex.test(c);
  }

  function notMatch(regex, c) {
    return !isMatch(regex, c);
  }

  var S = 0;
  sax.STATE = {
    BEGIN: S++, // leading byte order mark or whitespace
    BEGIN_WHITESPACE: S++, // leading whitespace
    TEXT: S++, // general stuff
    TEXT_ENTITY: S++, // &amp and such.
    OPEN_WAKA: S++, // <
    SGML_DECL: S++, // <!BLARG
    SGML_DECL_QUOTED: S++, // <!BLARG foo "bar
    DOCTYPE: S++, // <!DOCTYPE
    DOCTYPE_QUOTED: S++, // <!DOCTYPE "//blah
    DOCTYPE_DTD: S++, // <!DOCTYPE "//blah" [ ...
    DOCTYPE_DTD_QUOTED: S++, // <!DOCTYPE "//blah" [ "foo
    COMMENT_STARTING: S++, // <!-
    COMMENT: S++, // <!--
    COMMENT_ENDING: S++, // <!-- blah -
    COMMENT_ENDED: S++, // <!-- blah --
    CDATA: S++, // <![CDATA[ something
    CDATA_ENDING: S++, // ]
    CDATA_ENDING_2: S++, // ]]
    PROC_INST: S++, // <?hi
    PROC_INST_BODY: S++, // <?hi there
    PROC_INST_ENDING: S++, // <?hi "there" ?
    OPEN_TAG: S++, // <strong
    OPEN_TAG_SLASH: S++, // <strong /
    ATTRIB: S++, // <a
    ATTRIB_NAME: S++, // <a foo
    ATTRIB_NAME_SAW_WHITE: S++, // <a foo _
    ATTRIB_VALUE: S++, // <a foo=
    ATTRIB_VALUE_QUOTED: S++, // <a foo="bar
    ATTRIB_VALUE_CLOSED: S++, // <a foo="bar"
    ATTRIB_VALUE_UNQUOTED: S++, // <a foo=bar
    ATTRIB_VALUE_ENTITY_Q: S++, // <foo bar="&quot;"
    ATTRIB_VALUE_ENTITY_U: S++, // <foo bar=&quot
    CLOSE_TAG: S++, // </a
    CLOSE_TAG_SAW_WHITE: S++, // </a   >
    SCRIPT: S++, // <script> ...
    SCRIPT_ENDING: S++ // <script> ... <
  };

  sax.XML_ENTITIES = {
    'amp': '&',
    'gt': '>',
    'lt': '<',
    'quot': '"',
    'apos': "'"
  };

  sax.ENTITIES = {
    'amp': '&',
    'gt': '>',
    'lt': '<',
    'quot': '"',
    'apos': "'",
    'AElig': 198,
    'Aacute': 193,
    'Acirc': 194,
    'Agrave': 192,
    'Aring': 197,
    'Atilde': 195,
    'Auml': 196,
    'Ccedil': 199,
    'ETH': 208,
    'Eacute': 201,
    'Ecirc': 202,
    'Egrave': 200,
    'Euml': 203,
    'Iacute': 205,
    'Icirc': 206,
    'Igrave': 204,
    'Iuml': 207,
    'Ntilde': 209,
    'Oacute': 211,
    'Ocirc': 212,
    'Ograve': 210,
    'Oslash': 216,
    'Otilde': 213,
    'Ouml': 214,
    'THORN': 222,
    'Uacute': 218,
    'Ucirc': 219,
    'Ugrave': 217,
    'Uuml': 220,
    'Yacute': 221,
    'aacute': 225,
    'acirc': 226,
    'aelig': 230,
    'agrave': 224,
    'aring': 229,
    'atilde': 227,
    'auml': 228,
    'ccedil': 231,
    'eacute': 233,
    'ecirc': 234,
    'egrave': 232,
    'eth': 240,
    'euml': 235,
    'iacute': 237,
    'icirc': 238,
    'igrave': 236,
    'iuml': 239,
    'ntilde': 241,
    'oacute': 243,
    'ocirc': 244,
    'ograve': 242,
    'oslash': 248,
    'otilde': 245,
    'ouml': 246,
    'szlig': 223,
    'thorn': 254,
    'uacute': 250,
    'ucirc': 251,
    'ugrave': 249,
    'uuml': 252,
    'yacute': 253,
    'yuml': 255,
    'copy': 169,
    'reg': 174,
    'nbsp': 160,
    'iexcl': 161,
    'cent': 162,
    'pound': 163,
    'curren': 164,
    'yen': 165,
    'brvbar': 166,
    'sect': 167,
    'uml': 168,
    'ordf': 170,
    'laquo': 171,
    'not': 172,
    'shy': 173,
    'macr': 175,
    'deg': 176,
    'plusmn': 177,
    'sup1': 185,
    'sup2': 178,
    'sup3': 179,
    'acute': 180,
    'micro': 181,
    'para': 182,
    'middot': 183,
    'cedil': 184,
    'ordm': 186,
    'raquo': 187,
    'frac14': 188,
    'frac12': 189,
    'frac34': 190,
    'iquest': 191,
    'times': 215,
    'divide': 247,
    'OElig': 338,
    'oelig': 339,
    'Scaron': 352,
    'scaron': 353,
    'Yuml': 376,
    'fnof': 402,
    'circ': 710,
    'tilde': 732,
    'Alpha': 913,
    'Beta': 914,
    'Gamma': 915,
    'Delta': 916,
    'Epsilon': 917,
    'Zeta': 918,
    'Eta': 919,
    'Theta': 920,
    'Iota': 921,
    'Kappa': 922,
    'Lambda': 923,
    'Mu': 924,
    'Nu': 925,
    'Xi': 926,
    'Omicron': 927,
    'Pi': 928,
    'Rho': 929,
    'Sigma': 931,
    'Tau': 932,
    'Upsilon': 933,
    'Phi': 934,
    'Chi': 935,
    'Psi': 936,
    'Omega': 937,
    'alpha': 945,
    'beta': 946,
    'gamma': 947,
    'delta': 948,
    'epsilon': 949,
    'zeta': 950,
    'eta': 951,
    'theta': 952,
    'iota': 953,
    'kappa': 954,
    'lambda': 955,
    'mu': 956,
    'nu': 957,
    'xi': 958,
    'omicron': 959,
    'pi': 960,
    'rho': 961,
    'sigmaf': 962,
    'sigma': 963,
    'tau': 964,
    'upsilon': 965,
    'phi': 966,
    'chi': 967,
    'psi': 968,
    'omega': 969,
    'thetasym': 977,
    'upsih': 978,
    'piv': 982,
    'ensp': 8194,
    'emsp': 8195,
    'thinsp': 8201,
    'zwnj': 8204,
    'zwj': 8205,
    'lrm': 8206,
    'rlm': 8207,
    'ndash': 8211,
    'mdash': 8212,
    'lsquo': 8216,
    'rsquo': 8217,
    'sbquo': 8218,
    'ldquo': 8220,
    'rdquo': 8221,
    'bdquo': 8222,
    'dagger': 8224,
    'Dagger': 8225,
    'bull': 8226,
    'hellip': 8230,
    'permil': 8240,
    'prime': 8242,
    'Prime': 8243,
    'lsaquo': 8249,
    'rsaquo': 8250,
    'oline': 8254,
    'frasl': 8260,
    'euro': 8364,
    'image': 8465,
    'weierp': 8472,
    'real': 8476,
    'trade': 8482,
    'alefsym': 8501,
    'larr': 8592,
    'uarr': 8593,
    'rarr': 8594,
    'darr': 8595,
    'harr': 8596,
    'crarr': 8629,
    'lArr': 8656,
    'uArr': 8657,
    'rArr': 8658,
    'dArr': 8659,
    'hArr': 8660,
    'forall': 8704,
    'part': 8706,
    'exist': 8707,
    'empty': 8709,
    'nabla': 8711,
    'isin': 8712,
    'notin': 8713,
    'ni': 8715,
    'prod': 8719,
    'sum': 8721,
    'minus': 8722,
    'lowast': 8727,
    'radic': 8730,
    'prop': 8733,
    'infin': 8734,
    'ang': 8736,
    'and': 8743,
    'or': 8744,
    'cap': 8745,
    'cup': 8746,
    'int': 8747,
    'there4': 8756,
    'sim': 8764,
    'cong': 8773,
    'asymp': 8776,
    'ne': 8800,
    'equiv': 8801,
    'le': 8804,
    'ge': 8805,
    'sub': 8834,
    'sup': 8835,
    'nsub': 8836,
    'sube': 8838,
    'supe': 8839,
    'oplus': 8853,
    'otimes': 8855,
    'perp': 8869,
    'sdot': 8901,
    'lceil': 8968,
    'rceil': 8969,
    'lfloor': 8970,
    'rfloor': 8971,
    'lang': 9001,
    'rang': 9002,
    'loz': 9674,
    'spades': 9824,
    'clubs': 9827,
    'hearts': 9829,
    'diams': 9830
  };

  Object.keys(sax.ENTITIES).forEach(function (key) {
    var e = sax.ENTITIES[key];
    var s = typeof e === 'number' ? String.fromCharCode(e) : e;
    sax.ENTITIES[key] = s;
  });

  for (var s in sax.STATE) {
    sax.STATE[sax.STATE[s]] = s;
  }

  // shorthand
  S = sax.STATE;

  function emit(parser, event, data) {
    parser[event] && parser[event](data);
  }

  function emitNode(parser, nodeType, data) {
    if (parser.textNode) closeText(parser);
    emit(parser, nodeType, data);
  }

  function closeText(parser) {
    parser.textNode = textopts(parser.opt, parser.textNode);
    if (parser.textNode) emit(parser, 'ontext', parser.textNode);
    parser.textNode = '';
  }

  function textopts(opt, text) {
    if (opt.trim) text = text.trim();
    if (opt.normalize) text = text.replace(/\s+/g, ' ');
    return text;
  }

  function error(parser, er) {
    closeText(parser);
    if (parser.trackPosition) {
      er += '\nLine: ' + parser.line + '\nColumn: ' + parser.column + '\nChar: ' + parser.c;
    }
    er = new Error(er);
    parser.error = er;
    emit(parser, 'onerror', er);
    return parser;
  }

  function end(parser) {
    if (parser.sawRoot && !parser.closedRoot) strictFail(parser, 'Unclosed root tag');
    if (parser.state !== S.BEGIN && parser.state !== S.BEGIN_WHITESPACE && parser.state !== S.TEXT) {
      error(parser, 'Unexpected end');
    }
    closeText(parser);
    parser.c = '';
    parser.closed = true;
    emit(parser, 'onend');
    SAXParser.call(parser, parser.strict, parser.opt);
    return parser;
  }

  function strictFail(parser, message) {
    if (typeof parser !== 'object' || !(parser instanceof SAXParser)) {
      throw new Error('bad call to strictFail');
    }
    if (parser.strict) {
      error(parser, message);
    }
  }

  function newTag(parser) {
    if (!parser.strict) parser.tagName = parser.tagName[parser.looseCase]();
    var parent = parser.tags[parser.tags.length - 1] || parser;
    var tag = parser.tag = { name: parser.tagName, attributes: {}

      // will be overridden if tag contails an xmlns="foo" or xmlns:foo="bar"
    };if (parser.opt.xmlns) {
      tag.ns = parent.ns;
    }
    parser.attribList.length = 0;
    emitNode(parser, 'onopentagstart', tag);
  }

  function qname(name, attribute) {
    var i = name.indexOf(':');
    var qualName = i < 0 ? ['', name] : name.split(':');
    var prefix = qualName[0];
    var local = qualName[1];

    // <x "xmlns"="http://foo">
    if (attribute && name === 'xmlns') {
      prefix = 'xmlns';
      local = '';
    }

    return { prefix: prefix, local: local };
  }

  function attrib(parser) {
    if (!parser.strict) {
      parser.attribName = parser.attribName[parser.looseCase]();
    }

    if (parser.attribList.indexOf(parser.attribName) !== -1 || parser.tag.attributes.hasOwnProperty(parser.attribName)) {
      parser.attribName = parser.attribValue = '';
      return;
    }

    if (parser.opt.xmlns) {
      var qn = qname(parser.attribName, true);
      var prefix = qn.prefix;
      var local = qn.local;

      if (prefix === 'xmlns') {
        // namespace binding attribute. push the binding into scope
        if (local === 'xml' && parser.attribValue !== XML_NAMESPACE) {
          strictFail(parser, 'xml: prefix must be bound to ' + XML_NAMESPACE + '\n' + 'Actual: ' + parser.attribValue);
        } else if (local === 'xmlns' && parser.attribValue !== XMLNS_NAMESPACE) {
          strictFail(parser, 'xmlns: prefix must be bound to ' + XMLNS_NAMESPACE + '\n' + 'Actual: ' + parser.attribValue);
        } else {
          var tag = parser.tag;
          var parent = parser.tags[parser.tags.length - 1] || parser;
          if (tag.ns === parent.ns) {
            tag.ns = Object.create(parent.ns);
          }
          tag.ns[local] = parser.attribValue;
        }
      }

      // defer onattribute events until all attributes have been seen
      // so any new bindings can take effect. preserve attribute order
      // so deferred events can be emitted in document order
      parser.attribList.push([parser.attribName, parser.attribValue]);
    } else {
      // in non-xmlns mode, we can emit the event right away
      parser.tag.attributes[parser.attribName] = parser.attribValue;
      emitNode(parser, 'onattribute', {
        name: parser.attribName,
        value: parser.attribValue
      });
    }

    parser.attribName = parser.attribValue = '';
  }

  function openTag(parser, selfClosing) {
    if (parser.opt.xmlns) {
      // emit namespace binding events
      var tag = parser.tag;

      // add namespace info to tag
      var qn = qname(parser.tagName);
      tag.prefix = qn.prefix;
      tag.local = qn.local;
      tag.uri = tag.ns[qn.prefix] || '';

      if (tag.prefix && !tag.uri) {
        strictFail(parser, 'Unbound namespace prefix: ' + JSON.stringify(parser.tagName));
        tag.uri = qn.prefix;
      }

      var parent = parser.tags[parser.tags.length - 1] || parser;
      if (tag.ns && parent.ns !== tag.ns) {
        Object.keys(tag.ns).forEach(function (p) {
          emitNode(parser, 'onopennamespace', {
            prefix: p,
            uri: tag.ns[p]
          });
        });
      }

      // handle deferred onattribute events
      // Note: do not apply default ns to attributes:
      //   http://www.w3.org/TR/REC-xml-names/#defaulting
      for (var i = 0, l = parser.attribList.length; i < l; i++) {
        var nv = parser.attribList[i];
        var name = nv[0];
        var value = nv[1];
        var qualName = qname(name, true);
        var prefix = qualName.prefix;
        var local = qualName.local;
        var uri = prefix === '' ? '' : tag.ns[prefix] || '';
        var a = {
          name: name,
          value: value,
          prefix: prefix,
          local: local,
          uri: uri

          // if there's any attributes with an undefined namespace,
          // then fail on them now.
        };if (prefix && prefix !== 'xmlns' && !uri) {
          strictFail(parser, 'Unbound namespace prefix: ' + JSON.stringify(prefix));
          a.uri = prefix;
        }
        parser.tag.attributes[name] = a;
        emitNode(parser, 'onattribute', a);
      }
      parser.attribList.length = 0;
    }

    parser.tag.isSelfClosing = !!selfClosing;

    // process the tag
    parser.sawRoot = true;
    parser.tags.push(parser.tag);
    emitNode(parser, 'onopentag', parser.tag);
    if (!selfClosing) {
      // special case for <script> in non-strict mode.
      if (!parser.noscript && parser.tagName.toLowerCase() === 'script') {
        parser.state = S.SCRIPT;
      } else {
        parser.state = S.TEXT;
      }
      parser.tag = null;
      parser.tagName = '';
    }
    parser.attribName = parser.attribValue = '';
    parser.attribList.length = 0;
  }

  function closeTag(parser) {
    if (!parser.tagName) {
      strictFail(parser, 'Weird empty close tag.');
      parser.textNode += '</>';
      parser.state = S.TEXT;
      return;
    }

    if (parser.script) {
      if (parser.tagName !== 'script') {
        parser.script += '</' + parser.tagName + '>';
        parser.tagName = '';
        parser.state = S.SCRIPT;
        return;
      }
      emitNode(parser, 'onscript', parser.script);
      parser.script = '';
    }

    // first make sure that the closing tag actually exists.
    // <a><b></c></b></a> will close everything, otherwise.
    var t = parser.tags.length;
    var tagName = parser.tagName;
    if (!parser.strict) {
      tagName = tagName[parser.looseCase]();
    }
    var closeTo = tagName;
    while (t--) {
      var close = parser.tags[t];
      if (close.name !== closeTo) {
        // fail the first time in strict mode
        strictFail(parser, 'Unexpected close tag');
      } else {
        break;
      }
    }

    // didn't find it.  we already failed for strict, so just abort.
    if (t < 0) {
      strictFail(parser, 'Unmatched closing tag: ' + parser.tagName);
      parser.textNode += '</' + parser.tagName + '>';
      parser.state = S.TEXT;
      return;
    }
    parser.tagName = tagName;
    var s = parser.tags.length;
    while (s-- > t) {
      var tag = parser.tag = parser.tags.pop();
      parser.tagName = parser.tag.name;
      emitNode(parser, 'onclosetag', parser.tagName);

      var x = {};
      for (var i in tag.ns) {
        x[i] = tag.ns[i];
      }

      var parent = parser.tags[parser.tags.length - 1] || parser;
      if (parser.opt.xmlns && tag.ns !== parent.ns) {
        // remove namespace bindings introduced by tag
        Object.keys(tag.ns).forEach(function (p) {
          var n = tag.ns[p];
          emitNode(parser, 'onclosenamespace', { prefix: p, uri: n });
        });
      }
    }
    if (t === 0) parser.closedRoot = true;
    parser.tagName = parser.attribValue = parser.attribName = '';
    parser.attribList.length = 0;
    parser.state = S.TEXT;
  }

  function parseEntity(parser) {
    var entity = parser.entity;
    var entityLC = entity.toLowerCase();
    var num;
    var numStr = '';

    if (parser.ENTITIES[entity]) {
      return parser.ENTITIES[entity];
    }
    if (parser.ENTITIES[entityLC]) {
      return parser.ENTITIES[entityLC];
    }
    entity = entityLC;
    if (entity.charAt(0) === '#') {
      if (entity.charAt(1) === 'x') {
        entity = entity.slice(2);
        num = parseInt(entity, 16);
        numStr = num.toString(16);
      } else {
        entity = entity.slice(1);
        num = parseInt(entity, 10);
        numStr = num.toString(10);
      }
    }
    entity = entity.replace(/^0+/, '');
    if (isNaN(num) || numStr.toLowerCase() !== entity) {
      strictFail(parser, 'Invalid character entity');
      return '&' + parser.entity + ';';
    }

    return String.fromCodePoint(num);
  }

  function beginWhiteSpace(parser, c) {
    if (c === '<') {
      parser.state = S.OPEN_WAKA;
      parser.startTagPosition = parser.position;
    } else if (!isWhitespace(c)) {
      // have to process this as a text node.
      // weird, but happens.
      strictFail(parser, 'Non-whitespace before first tag.');
      parser.textNode = c;
      parser.state = S.TEXT;
    }
  }

  function charAt(chunk, i) {
    var result = '';
    if (i < chunk.length) {
      result = chunk.charAt(i);
    }
    return result;
  }

  function write(chunk) {
    var parser = this;
    if (this.error) {
      throw this.error;
    }
    if (parser.closed) {
      return error(parser, 'Cannot write after close. Assign an onready handler.');
    }
    if (chunk === null) {
      return end(parser);
    }
    if (typeof chunk === 'object') {
      chunk = chunk.toString();
    }
    var i = 0;
    var c = '';
    while (true) {
      c = charAt(chunk, i++);
      parser.c = c;

      if (!c) {
        break;
      }

      if (parser.trackPosition) {
        parser.position++;
        if (c === '\n') {
          parser.line++;
          parser.column = 0;
        } else {
          parser.column++;
        }
      }

      switch (parser.state) {
        case S.BEGIN:
          parser.state = S.BEGIN_WHITESPACE;
          if (c === '\uFEFF') {
            continue;
          }
          beginWhiteSpace(parser, c);
          continue;

        case S.BEGIN_WHITESPACE:
          beginWhiteSpace(parser, c);
          continue;

        case S.TEXT:
          if (parser.sawRoot && !parser.closedRoot) {
            var starti = i - 1;
            while (c && c !== '<' && c !== '&') {
              c = charAt(chunk, i++);
              if (c && parser.trackPosition) {
                parser.position++;
                if (c === '\n') {
                  parser.line++;
                  parser.column = 0;
                } else {
                  parser.column++;
                }
              }
            }
            parser.textNode += chunk.substring(starti, i - 1);
          }
          if (c === '<' && !(parser.sawRoot && parser.closedRoot && !parser.strict)) {
            parser.state = S.OPEN_WAKA;
            parser.startTagPosition = parser.position;
          } else {
            if (!isWhitespace(c) && (!parser.sawRoot || parser.closedRoot)) {
              strictFail(parser, 'Text data outside of root node.');
            }
            if (c === '&') {
              parser.state = S.TEXT_ENTITY;
            } else {
              parser.textNode += c;
            }
          }
          continue;

        case S.SCRIPT:
          // only non-strict
          if (c === '<') {
            parser.state = S.SCRIPT_ENDING;
          } else {
            parser.script += c;
          }
          continue;

        case S.SCRIPT_ENDING:
          if (c === '/') {
            parser.state = S.CLOSE_TAG;
          } else {
            parser.script += '<' + c;
            parser.state = S.SCRIPT;
          }
          continue;

        case S.OPEN_WAKA:
          // either a /, ?, !, or text is coming next.
          if (c === '!') {
            parser.state = S.SGML_DECL;
            parser.sgmlDecl = '';
          } else if (isWhitespace(c)) {
            // wait for it...
          } else if (isMatch(nameStart, c)) {
            parser.state = S.OPEN_TAG;
            parser.tagName = c;
          } else if (c === '/') {
            parser.state = S.CLOSE_TAG;
            parser.tagName = '';
          } else if (c === '?') {
            parser.state = S.PROC_INST;
            parser.procInstName = parser.procInstBody = '';
          } else {
            strictFail(parser, 'Unencoded <');
            // if there was some whitespace, then add that in.
            if (parser.startTagPosition + 1 < parser.position) {
              var pad = parser.position - parser.startTagPosition;
              c = new Array(pad).join(' ') + c;
            }
            parser.textNode += '<' + c;
            parser.state = S.TEXT;
          }
          continue;

        case S.SGML_DECL:
          if ((parser.sgmlDecl + c).toUpperCase() === CDATA) {
            emitNode(parser, 'onopencdata');
            parser.state = S.CDATA;
            parser.sgmlDecl = '';
            parser.cdata = '';
          } else if (parser.sgmlDecl + c === '--') {
            parser.state = S.COMMENT;
            parser.comment = '';
            parser.sgmlDecl = '';
          } else if ((parser.sgmlDecl + c).toUpperCase() === DOCTYPE) {
            parser.state = S.DOCTYPE;
            if (parser.doctype || parser.sawRoot) {
              strictFail(parser, 'Inappropriately located doctype declaration');
            }
            parser.doctype = '';
            parser.sgmlDecl = '';
          } else if (c === '>') {
            emitNode(parser, 'onsgmldeclaration', parser.sgmlDecl);
            parser.sgmlDecl = '';
            parser.state = S.TEXT;
          } else if (isQuote(c)) {
            parser.state = S.SGML_DECL_QUOTED;
            parser.sgmlDecl += c;
          } else {
            parser.sgmlDecl += c;
          }
          continue;

        case S.SGML_DECL_QUOTED:
          if (c === parser.q) {
            parser.state = S.SGML_DECL;
            parser.q = '';
          }
          parser.sgmlDecl += c;
          continue;

        case S.DOCTYPE:
          if (c === '>') {
            parser.state = S.TEXT;
            emitNode(parser, 'ondoctype', parser.doctype);
            parser.doctype = true; // just remember that we saw it.
          } else {
            parser.doctype += c;
            if (c === '[') {
              parser.state = S.DOCTYPE_DTD;
            } else if (isQuote(c)) {
              parser.state = S.DOCTYPE_QUOTED;
              parser.q = c;
            }
          }
          continue;

        case S.DOCTYPE_QUOTED:
          parser.doctype += c;
          if (c === parser.q) {
            parser.q = '';
            parser.state = S.DOCTYPE;
          }
          continue;

        case S.DOCTYPE_DTD:
          parser.doctype += c;
          if (c === ']') {
            parser.state = S.DOCTYPE;
          } else if (isQuote(c)) {
            parser.state = S.DOCTYPE_DTD_QUOTED;
            parser.q = c;
          }
          continue;

        case S.DOCTYPE_DTD_QUOTED:
          parser.doctype += c;
          if (c === parser.q) {
            parser.state = S.DOCTYPE_DTD;
            parser.q = '';
          }
          continue;

        case S.COMMENT:
          if (c === '-') {
            parser.state = S.COMMENT_ENDING;
          } else {
            parser.comment += c;
          }
          continue;

        case S.COMMENT_ENDING:
          if (c === '-') {
            parser.state = S.COMMENT_ENDED;
            parser.comment = textopts(parser.opt, parser.comment);
            if (parser.comment) {
              emitNode(parser, 'oncomment', parser.comment);
            }
            parser.comment = '';
          } else {
            parser.comment += '-' + c;
            parser.state = S.COMMENT;
          }
          continue;

        case S.COMMENT_ENDED:
          if (c !== '>') {
            strictFail(parser, 'Malformed comment');
            // allow <!-- blah -- bloo --> in non-strict mode,
            // which is a comment of " blah -- bloo "
            parser.comment += '--' + c;
            parser.state = S.COMMENT;
          } else {
            parser.state = S.TEXT;
          }
          continue;

        case S.CDATA:
          if (c === ']') {
            parser.state = S.CDATA_ENDING;
          } else {
            parser.cdata += c;
          }
          continue;

        case S.CDATA_ENDING:
          if (c === ']') {
            parser.state = S.CDATA_ENDING_2;
          } else {
            parser.cdata += ']' + c;
            parser.state = S.CDATA;
          }
          continue;

        case S.CDATA_ENDING_2:
          if (c === '>') {
            if (parser.cdata) {
              emitNode(parser, 'oncdata', parser.cdata);
            }
            emitNode(parser, 'onclosecdata');
            parser.cdata = '';
            parser.state = S.TEXT;
          } else if (c === ']') {
            parser.cdata += ']';
          } else {
            parser.cdata += ']]' + c;
            parser.state = S.CDATA;
          }
          continue;

        case S.PROC_INST:
          if (c === '?') {
            parser.state = S.PROC_INST_ENDING;
          } else if (isWhitespace(c)) {
            parser.state = S.PROC_INST_BODY;
          } else {
            parser.procInstName += c;
          }
          continue;

        case S.PROC_INST_BODY:
          if (!parser.procInstBody && isWhitespace(c)) {
            continue;
          } else if (c === '?') {
            parser.state = S.PROC_INST_ENDING;
          } else {
            parser.procInstBody += c;
          }
          continue;

        case S.PROC_INST_ENDING:
          if (c === '>') {
            emitNode(parser, 'onprocessinginstruction', {
              name: parser.procInstName,
              body: parser.procInstBody
            });
            parser.procInstName = parser.procInstBody = '';
            parser.state = S.TEXT;
          } else {
            parser.procInstBody += '?' + c;
            parser.state = S.PROC_INST_BODY;
          }
          continue;

        case S.OPEN_TAG:
          if (isMatch(nameBody, c)) {
            parser.tagName += c;
          } else {
            newTag(parser);
            if (c === '>') {
              openTag(parser);
            } else if (c === '/') {
              parser.state = S.OPEN_TAG_SLASH;
            } else {
              if (!isWhitespace(c)) {
                strictFail(parser, 'Invalid character in tag name');
              }
              parser.state = S.ATTRIB;
            }
          }
          continue;

        case S.OPEN_TAG_SLASH:
          if (c === '>') {
            openTag(parser, true);
            closeTag(parser);
          } else {
            strictFail(parser, 'Forward-slash in opening tag not followed by >');
            parser.state = S.ATTRIB;
          }
          continue;

        case S.ATTRIB:
          // haven't read the attribute name yet.
          if (isWhitespace(c)) {
            continue;
          } else if (c === '>') {
            openTag(parser);
          } else if (c === '/') {
            parser.state = S.OPEN_TAG_SLASH;
          } else if (isMatch(nameStart, c)) {
            parser.attribName = c;
            parser.attribValue = '';
            parser.state = S.ATTRIB_NAME;
          } else {
            strictFail(parser, 'Invalid attribute name');
          }
          continue;

        case S.ATTRIB_NAME:
          if (c === '=') {
            parser.state = S.ATTRIB_VALUE;
          } else if (c === '>') {
            strictFail(parser, 'Attribute without value');
            parser.attribValue = parser.attribName;
            attrib(parser);
            openTag(parser);
          } else if (isWhitespace(c)) {
            parser.state = S.ATTRIB_NAME_SAW_WHITE;
          } else if (isMatch(nameBody, c)) {
            parser.attribName += c;
          } else {
            strictFail(parser, 'Invalid attribute name');
          }
          continue;

        case S.ATTRIB_NAME_SAW_WHITE:
          if (c === '=') {
            parser.state = S.ATTRIB_VALUE;
          } else if (isWhitespace(c)) {
            continue;
          } else {
            strictFail(parser, 'Attribute without value');
            parser.tag.attributes[parser.attribName] = '';
            parser.attribValue = '';
            emitNode(parser, 'onattribute', {
              name: parser.attribName,
              value: ''
            });
            parser.attribName = '';
            if (c === '>') {
              openTag(parser);
            } else if (isMatch(nameStart, c)) {
              parser.attribName = c;
              parser.state = S.ATTRIB_NAME;
            } else {
              strictFail(parser, 'Invalid attribute name');
              parser.state = S.ATTRIB;
            }
          }
          continue;

        case S.ATTRIB_VALUE:
          if (isWhitespace(c)) {
            continue;
          } else if (isQuote(c)) {
            parser.q = c;
            parser.state = S.ATTRIB_VALUE_QUOTED;
          } else {
            strictFail(parser, 'Unquoted attribute value');
            parser.state = S.ATTRIB_VALUE_UNQUOTED;
            parser.attribValue = c;
          }
          continue;

        case S.ATTRIB_VALUE_QUOTED:
          if (c !== parser.q) {
            if (c === '&') {
              parser.state = S.ATTRIB_VALUE_ENTITY_Q;
            } else {
              parser.attribValue += c;
            }
            continue;
          }
          attrib(parser);
          parser.q = '';
          parser.state = S.ATTRIB_VALUE_CLOSED;
          continue;

        case S.ATTRIB_VALUE_CLOSED:
          if (isWhitespace(c)) {
            parser.state = S.ATTRIB;
          } else if (c === '>') {
            openTag(parser);
          } else if (c === '/') {
            parser.state = S.OPEN_TAG_SLASH;
          } else if (isMatch(nameStart, c)) {
            strictFail(parser, 'No whitespace between attributes');
            parser.attribName = c;
            parser.attribValue = '';
            parser.state = S.ATTRIB_NAME;
          } else {
            strictFail(parser, 'Invalid attribute name');
          }
          continue;

        case S.ATTRIB_VALUE_UNQUOTED:
          if (!isAttribEnd(c)) {
            if (c === '&') {
              parser.state = S.ATTRIB_VALUE_ENTITY_U;
            } else {
              parser.attribValue += c;
            }
            continue;
          }
          attrib(parser);
          if (c === '>') {
            openTag(parser);
          } else {
            parser.state = S.ATTRIB;
          }
          continue;

        case S.CLOSE_TAG:
          if (!parser.tagName) {
            if (isWhitespace(c)) {
              continue;
            } else if (notMatch(nameStart, c)) {
              if (parser.script) {
                parser.script += '</' + c;
                parser.state = S.SCRIPT;
              } else {
                strictFail(parser, 'Invalid tagname in closing tag.');
              }
            } else {
              parser.tagName = c;
            }
          } else if (c === '>') {
            closeTag(parser);
          } else if (isMatch(nameBody, c)) {
            parser.tagName += c;
          } else if (parser.script) {
            parser.script += '</' + parser.tagName;
            parser.tagName = '';
            parser.state = S.SCRIPT;
          } else {
            if (!isWhitespace(c)) {
              strictFail(parser, 'Invalid tagname in closing tag');
            }
            parser.state = S.CLOSE_TAG_SAW_WHITE;
          }
          continue;

        case S.CLOSE_TAG_SAW_WHITE:
          if (isWhitespace(c)) {
            continue;
          }
          if (c === '>') {
            closeTag(parser);
          } else {
            strictFail(parser, 'Invalid characters in closing tag');
          }
          continue;

        case S.TEXT_ENTITY:
        case S.ATTRIB_VALUE_ENTITY_Q:
        case S.ATTRIB_VALUE_ENTITY_U:
          var returnState;
          var buffer;
          switch (parser.state) {
            case S.TEXT_ENTITY:
              returnState = S.TEXT;
              buffer = 'textNode';
              break;

            case S.ATTRIB_VALUE_ENTITY_Q:
              returnState = S.ATTRIB_VALUE_QUOTED;
              buffer = 'attribValue';
              break;

            case S.ATTRIB_VALUE_ENTITY_U:
              returnState = S.ATTRIB_VALUE_UNQUOTED;
              buffer = 'attribValue';
              break;
          }

          if (c === ';') {
            parser[buffer] += parseEntity(parser);
            parser.entity = '';
            parser.state = returnState;
          } else if (isMatch(parser.entity.length ? entityBody : entityStart, c)) {
            parser.entity += c;
          } else {
            strictFail(parser, 'Invalid character in entity name');
            parser[buffer] += '&' + parser.entity + c;
            parser.entity = '';
            parser.state = returnState;
          }

          continue;

        default:
          throw new Error(parser, 'Unknown state: ' + parser.state);
      }
    } // while

    if (parser.position >= parser.bufferCheckPosition) {
      checkBufferLength(parser);
    }
    return parser;
  }

  /*! http://mths.be/fromcodepoint v0.1.0 by @mathias */
  /* istanbul ignore next */
  if (!String.fromCodePoint) {
    (function () {
      var stringFromCharCode = String.fromCharCode;
      var floor = Math.floor;
      var fromCodePoint = function () {
        var MAX_SIZE = 0x4000;
        var codeUnits = [];
        var highSurrogate;
        var lowSurrogate;
        var index = -1;
        var length = arguments.length;
        if (!length) {
          return '';
        }
        var result = '';
        while (++index < length) {
          var codePoint = Number(arguments[index]);
          if (!isFinite(codePoint) || // `NaN`, `+Infinity`, or `-Infinity`
          codePoint < 0 || // not a valid Unicode code point
          codePoint > 0x10FFFF || // not a valid Unicode code point
          floor(codePoint) !== codePoint // not an integer
          ) {
              throw RangeError('Invalid code point: ' + codePoint);
            }
          if (codePoint <= 0xFFFF) {
            // BMP code point
            codeUnits.push(codePoint);
          } else {
            // Astral code point; split in surrogate halves
            // http://mathiasbynens.be/notes/javascript-encoding#surrogate-formulae
            codePoint -= 0x10000;
            highSurrogate = (codePoint >> 10) + 0xD800;
            lowSurrogate = codePoint % 0x400 + 0xDC00;
            codeUnits.push(highSurrogate, lowSurrogate);
          }
          if (index + 1 === length || codeUnits.length > MAX_SIZE) {
            result += stringFromCharCode.apply(null, codeUnits);
            codeUnits.length = 0;
          }
        }
        return result;
      };
      /* istanbul ignore next */
      if (Object.defineProperty) {
        Object.defineProperty(String, 'fromCodePoint', {
          value: fromCodePoint,
          configurable: true,
          writable: true
        });
      } else {
        String.fromCodePoint = fromCodePoint;
      }
    })();
  }
})( false ? undefined.sax = {} : exports);

/***/ }),
/* 136 */
/***/ (function(module, exports) {

module.exports = require("string_decoder");

/***/ }),
/* 137 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var loader = __webpack_require__(138);
var dumper = __webpack_require__(158);

function deprecated(name) {
  return function () {
    throw new Error('Function ' + name + ' is deprecated and cannot be used.');
  };
}

module.exports.Type = __webpack_require__(4);
module.exports.Schema = __webpack_require__(18);
module.exports.FAILSAFE_SCHEMA = __webpack_require__(32);
module.exports.JSON_SCHEMA = __webpack_require__(54);
module.exports.CORE_SCHEMA = __webpack_require__(53);
module.exports.DEFAULT_SAFE_SCHEMA = __webpack_require__(22);
module.exports.DEFAULT_FULL_SCHEMA = __webpack_require__(25);
module.exports.load = loader.load;
module.exports.loadAll = loader.loadAll;
module.exports.safeLoad = loader.safeLoad;
module.exports.safeLoadAll = loader.safeLoadAll;
module.exports.dump = dumper.dump;
module.exports.safeDump = dumper.safeDump;
module.exports.YAMLException = __webpack_require__(21);

// Deprecated schema names from JS-YAML 2.0.x
module.exports.MINIMAL_SCHEMA = __webpack_require__(32);
module.exports.SAFE_SCHEMA = __webpack_require__(22);
module.exports.DEFAULT_SCHEMA = __webpack_require__(25);

// Deprecated functions from JS-YAML 1.x.x
module.exports.scan = deprecated('scan');
module.exports.parse = deprecated('parse');
module.exports.compose = deprecated('compose');
module.exports.addConstructor = deprecated('addConstructor');

/***/ }),
/* 138 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/*eslint-disable max-len,no-use-before-define*/

var common = __webpack_require__(17);
var YAMLException = __webpack_require__(21);
var Mark = __webpack_require__(139);
var DEFAULT_SAFE_SCHEMA = __webpack_require__(22);
var DEFAULT_FULL_SCHEMA = __webpack_require__(25);

var _hasOwnProperty = Object.prototype.hasOwnProperty;

var CONTEXT_FLOW_IN = 1;
var CONTEXT_FLOW_OUT = 2;
var CONTEXT_BLOCK_IN = 3;
var CONTEXT_BLOCK_OUT = 4;

var CHOMPING_CLIP = 1;
var CHOMPING_STRIP = 2;
var CHOMPING_KEEP = 3;

var PATTERN_NON_PRINTABLE = /[\x00-\x08\x0B\x0C\x0E-\x1F\x7F-\x84\x86-\x9F\uFFFE\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]/;
var PATTERN_NON_ASCII_LINE_BREAKS = /[\x85\u2028\u2029]/;
var PATTERN_FLOW_INDICATORS = /[,\[\]\{\}]/;
var PATTERN_TAG_HANDLE = /^(?:!|!!|![a-z\-]+!)$/i;
var PATTERN_TAG_URI = /^(?:!|[^,\[\]\{\}])(?:%[0-9a-f]{2}|[0-9a-z\-#;\/\?:@&=\+\$,_\.!~\*'\(\)\[\]])*$/i;

function is_EOL(c) {
  return c === 0x0A /* LF */ || c === 0x0D /* CR */;
}

function is_WHITE_SPACE(c) {
  return c === 0x09 /* Tab */ || c === 0x20 /* Space */;
}

function is_WS_OR_EOL(c) {
  return c === 0x09 /* Tab */ || c === 0x20 /* Space */ || c === 0x0A /* LF */ || c === 0x0D /* CR */;
}

function is_FLOW_INDICATOR(c) {
  return c === 0x2C /* , */ || c === 0x5B /* [ */ || c === 0x5D /* ] */ || c === 0x7B /* { */ || c === 0x7D /* } */;
}

function fromHexCode(c) {
  var lc;

  if (0x30 /* 0 */ <= c && c <= 0x39 /* 9 */) {
    return c - 0x30;
  }

  /*eslint-disable no-bitwise*/
  lc = c | 0x20;

  if (0x61 /* a */ <= lc && lc <= 0x66 /* f */) {
    return lc - 0x61 + 10;
  }

  return -1;
}

function escapedHexLen(c) {
  if (c === 0x78 /* x */) {
      return 2;
    }
  if (c === 0x75 /* u */) {
      return 4;
    }
  if (c === 0x55 /* U */) {
      return 8;
    }
  return 0;
}

function fromDecimalCode(c) {
  if (0x30 /* 0 */ <= c && c <= 0x39 /* 9 */) {
    return c - 0x30;
  }

  return -1;
}

function simpleEscapeSequence(c) {
  /* eslint-disable indent */
  return c === 0x30 /* 0 */ ? '\x00' : c === 0x61 /* a */ ? '\x07' : c === 0x62 /* b */ ? '\x08' : c === 0x74 /* t */ ? '\x09' : c === 0x09 /* Tab */ ? '\x09' : c === 0x6E /* n */ ? '\x0A' : c === 0x76 /* v */ ? '\x0B' : c === 0x66 /* f */ ? '\x0C' : c === 0x72 /* r */ ? '\x0D' : c === 0x65 /* e */ ? '\x1B' : c === 0x20 /* Space */ ? ' ' : c === 0x22 /* " */ ? '\x22' : c === 0x2F /* / */ ? '/' : c === 0x5C /* \ */ ? '\x5C' : c === 0x4E /* N */ ? '\x85' : c === 0x5F /* _ */ ? '\xA0' : c === 0x4C /* L */ ? '\u2028' : c === 0x50 /* P */ ? '\u2029' : '';
}

function charFromCodepoint(c) {
  if (c <= 0xFFFF) {
    return String.fromCharCode(c);
  }
  // Encode UTF-16 surrogate pair
  // https://en.wikipedia.org/wiki/UTF-16#Code_points_U.2B010000_to_U.2B10FFFF
  return String.fromCharCode((c - 0x010000 >> 10) + 0xD800, (c - 0x010000 & 0x03FF) + 0xDC00);
}

var simpleEscapeCheck = new Array(256); // integer, for fast access
var simpleEscapeMap = new Array(256);
for (var i = 0; i < 256; i++) {
  simpleEscapeCheck[i] = simpleEscapeSequence(i) ? 1 : 0;
  simpleEscapeMap[i] = simpleEscapeSequence(i);
}

function State(input, options) {
  this.input = input;

  this.filename = options['filename'] || null;
  this.schema = options['schema'] || DEFAULT_FULL_SCHEMA;
  this.onWarning = options['onWarning'] || null;
  this.legacy = options['legacy'] || false;
  this.json = options['json'] || false;
  this.listener = options['listener'] || null;

  this.implicitTypes = this.schema.compiledImplicit;
  this.typeMap = this.schema.compiledTypeMap;

  this.length = input.length;
  this.position = 0;
  this.line = 0;
  this.lineStart = 0;
  this.lineIndent = 0;

  this.documents = [];

  /*
  this.version;
  this.checkLineBreaks;
  this.tagMap;
  this.anchorMap;
  this.tag;
  this.anchor;
  this.kind;
  this.result;*/
}

function generateError(state, message) {
  return new YAMLException(message, new Mark(state.filename, state.input, state.position, state.line, state.position - state.lineStart));
}

function throwError(state, message) {
  throw generateError(state, message);
}

function throwWarning(state, message) {
  if (state.onWarning) {
    state.onWarning.call(null, generateError(state, message));
  }
}

var directiveHandlers = {

  YAML: function handleYamlDirective(state, name, args) {

    var match, major, minor;

    if (state.version !== null) {
      throwError(state, 'duplication of %YAML directive');
    }

    if (args.length !== 1) {
      throwError(state, 'YAML directive accepts exactly one argument');
    }

    match = /^([0-9]+)\.([0-9]+)$/.exec(args[0]);

    if (match === null) {
      throwError(state, 'ill-formed argument of the YAML directive');
    }

    major = parseInt(match[1], 10);
    minor = parseInt(match[2], 10);

    if (major !== 1) {
      throwError(state, 'unacceptable YAML version of the document');
    }

    state.version = args[0];
    state.checkLineBreaks = minor < 2;

    if (minor !== 1 && minor !== 2) {
      throwWarning(state, 'unsupported YAML version of the document');
    }
  },

  TAG: function handleTagDirective(state, name, args) {

    var handle, prefix;

    if (args.length !== 2) {
      throwError(state, 'TAG directive accepts exactly two arguments');
    }

    handle = args[0];
    prefix = args[1];

    if (!PATTERN_TAG_HANDLE.test(handle)) {
      throwError(state, 'ill-formed tag handle (first argument) of the TAG directive');
    }

    if (_hasOwnProperty.call(state.tagMap, handle)) {
      throwError(state, 'there is a previously declared suffix for "' + handle + '" tag handle');
    }

    if (!PATTERN_TAG_URI.test(prefix)) {
      throwError(state, 'ill-formed tag prefix (second argument) of the TAG directive');
    }

    state.tagMap[handle] = prefix;
  }
};

function captureSegment(state, start, end, checkJson) {
  var _position, _length, _character, _result;

  if (start < end) {
    _result = state.input.slice(start, end);

    if (checkJson) {
      for (_position = 0, _length = _result.length; _position < _length; _position += 1) {
        _character = _result.charCodeAt(_position);
        if (!(_character === 0x09 || 0x20 <= _character && _character <= 0x10FFFF)) {
          throwError(state, 'expected valid JSON character');
        }
      }
    } else if (PATTERN_NON_PRINTABLE.test(_result)) {
      throwError(state, 'the stream contains non-printable characters');
    }

    state.result += _result;
  }
}

function mergeMappings(state, destination, source, overridableKeys) {
  var sourceKeys, key, index, quantity;

  if (!common.isObject(source)) {
    throwError(state, 'cannot merge mappings; the provided source object is unacceptable');
  }

  sourceKeys = Object.keys(source);

  for (index = 0, quantity = sourceKeys.length; index < quantity; index += 1) {
    key = sourceKeys[index];

    if (!_hasOwnProperty.call(destination, key)) {
      destination[key] = source[key];
      overridableKeys[key] = true;
    }
  }
}

function storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, valueNode, startLine, startPos) {
  var index, quantity;

  keyNode = String(keyNode);

  if (_result === null) {
    _result = {};
  }

  if (keyTag === 'tag:yaml.org,2002:merge') {
    if (Array.isArray(valueNode)) {
      for (index = 0, quantity = valueNode.length; index < quantity; index += 1) {
        mergeMappings(state, _result, valueNode[index], overridableKeys);
      }
    } else {
      mergeMappings(state, _result, valueNode, overridableKeys);
    }
  } else {
    if (!state.json && !_hasOwnProperty.call(overridableKeys, keyNode) && _hasOwnProperty.call(_result, keyNode)) {
      state.line = startLine || state.line;
      state.position = startPos || state.position;
      throwError(state, 'duplicated mapping key');
    }
    _result[keyNode] = valueNode;
    delete overridableKeys[keyNode];
  }

  return _result;
}

function readLineBreak(state) {
  var ch;

  ch = state.input.charCodeAt(state.position);

  if (ch === 0x0A /* LF */) {
      state.position++;
    } else if (ch === 0x0D /* CR */) {
      state.position++;
      if (state.input.charCodeAt(state.position) === 0x0A /* LF */) {
          state.position++;
        }
    } else {
    throwError(state, 'a line break is expected');
  }

  state.line += 1;
  state.lineStart = state.position;
}

function skipSeparationSpace(state, allowComments, checkIndent) {
  var lineBreaks = 0,
      ch = state.input.charCodeAt(state.position);

  while (ch !== 0) {
    while (is_WHITE_SPACE(ch)) {
      ch = state.input.charCodeAt(++state.position);
    }

    if (allowComments && ch === 0x23 /* # */) {
        do {
          ch = state.input.charCodeAt(++state.position);
        } while (ch !== 0x0A /* LF */ && ch !== 0x0D /* CR */ && ch !== 0);
      }

    if (is_EOL(ch)) {
      readLineBreak(state);

      ch = state.input.charCodeAt(state.position);
      lineBreaks++;
      state.lineIndent = 0;

      while (ch === 0x20 /* Space */) {
        state.lineIndent++;
        ch = state.input.charCodeAt(++state.position);
      }
    } else {
      break;
    }
  }

  if (checkIndent !== -1 && lineBreaks !== 0 && state.lineIndent < checkIndent) {
    throwWarning(state, 'deficient indentation');
  }

  return lineBreaks;
}

function testDocumentSeparator(state) {
  var _position = state.position,
      ch;

  ch = state.input.charCodeAt(_position);

  // Condition state.position === state.lineStart is tested
  // in parent on each call, for efficiency. No needs to test here again.
  if ((ch === 0x2D /* - */ || ch === 0x2E /* . */) && ch === state.input.charCodeAt(_position + 1) && ch === state.input.charCodeAt(_position + 2)) {

    _position += 3;

    ch = state.input.charCodeAt(_position);

    if (ch === 0 || is_WS_OR_EOL(ch)) {
      return true;
    }
  }

  return false;
}

function writeFoldedLines(state, count) {
  if (count === 1) {
    state.result += ' ';
  } else if (count > 1) {
    state.result += common.repeat('\n', count - 1);
  }
}

function readPlainScalar(state, nodeIndent, withinFlowCollection) {
  var preceding,
      following,
      captureStart,
      captureEnd,
      hasPendingContent,
      _line,
      _lineStart,
      _lineIndent,
      _kind = state.kind,
      _result = state.result,
      ch;

  ch = state.input.charCodeAt(state.position);

  if (is_WS_OR_EOL(ch) || is_FLOW_INDICATOR(ch) || ch === 0x23 /* # */ || ch === 0x26 /* & */ || ch === 0x2A /* * */ || ch === 0x21 /* ! */ || ch === 0x7C /* | */ || ch === 0x3E /* > */ || ch === 0x27 /* ' */ || ch === 0x22 /* " */ || ch === 0x25 /* % */ || ch === 0x40 /* @ */ || ch === 0x60 /* ` */) {
      return false;
    }

  if (ch === 0x3F /* ? */ || ch === 0x2D /* - */) {
      following = state.input.charCodeAt(state.position + 1);

      if (is_WS_OR_EOL(following) || withinFlowCollection && is_FLOW_INDICATOR(following)) {
        return false;
      }
    }

  state.kind = 'scalar';
  state.result = '';
  captureStart = captureEnd = state.position;
  hasPendingContent = false;

  while (ch !== 0) {
    if (ch === 0x3A /* : */) {
        following = state.input.charCodeAt(state.position + 1);

        if (is_WS_OR_EOL(following) || withinFlowCollection && is_FLOW_INDICATOR(following)) {
          break;
        }
      } else if (ch === 0x23 /* # */) {
        preceding = state.input.charCodeAt(state.position - 1);

        if (is_WS_OR_EOL(preceding)) {
          break;
        }
      } else if (state.position === state.lineStart && testDocumentSeparator(state) || withinFlowCollection && is_FLOW_INDICATOR(ch)) {
      break;
    } else if (is_EOL(ch)) {
      _line = state.line;
      _lineStart = state.lineStart;
      _lineIndent = state.lineIndent;
      skipSeparationSpace(state, false, -1);

      if (state.lineIndent >= nodeIndent) {
        hasPendingContent = true;
        ch = state.input.charCodeAt(state.position);
        continue;
      } else {
        state.position = captureEnd;
        state.line = _line;
        state.lineStart = _lineStart;
        state.lineIndent = _lineIndent;
        break;
      }
    }

    if (hasPendingContent) {
      captureSegment(state, captureStart, captureEnd, false);
      writeFoldedLines(state, state.line - _line);
      captureStart = captureEnd = state.position;
      hasPendingContent = false;
    }

    if (!is_WHITE_SPACE(ch)) {
      captureEnd = state.position + 1;
    }

    ch = state.input.charCodeAt(++state.position);
  }

  captureSegment(state, captureStart, captureEnd, false);

  if (state.result) {
    return true;
  }

  state.kind = _kind;
  state.result = _result;
  return false;
}

function readSingleQuotedScalar(state, nodeIndent) {
  var ch, captureStart, captureEnd;

  ch = state.input.charCodeAt(state.position);

  if (ch !== 0x27 /* ' */) {
      return false;
    }

  state.kind = 'scalar';
  state.result = '';
  state.position++;
  captureStart = captureEnd = state.position;

  while ((ch = state.input.charCodeAt(state.position)) !== 0) {
    if (ch === 0x27 /* ' */) {
        captureSegment(state, captureStart, state.position, true);
        ch = state.input.charCodeAt(++state.position);

        if (ch === 0x27 /* ' */) {
            captureStart = state.position;
            state.position++;
            captureEnd = state.position;
          } else {
          return true;
        }
      } else if (is_EOL(ch)) {
      captureSegment(state, captureStart, captureEnd, true);
      writeFoldedLines(state, skipSeparationSpace(state, false, nodeIndent));
      captureStart = captureEnd = state.position;
    } else if (state.position === state.lineStart && testDocumentSeparator(state)) {
      throwError(state, 'unexpected end of the document within a single quoted scalar');
    } else {
      state.position++;
      captureEnd = state.position;
    }
  }

  throwError(state, 'unexpected end of the stream within a single quoted scalar');
}

function readDoubleQuotedScalar(state, nodeIndent) {
  var captureStart, captureEnd, hexLength, hexResult, tmp, ch;

  ch = state.input.charCodeAt(state.position);

  if (ch !== 0x22 /* " */) {
      return false;
    }

  state.kind = 'scalar';
  state.result = '';
  state.position++;
  captureStart = captureEnd = state.position;

  while ((ch = state.input.charCodeAt(state.position)) !== 0) {
    if (ch === 0x22 /* " */) {
        captureSegment(state, captureStart, state.position, true);
        state.position++;
        return true;
      } else if (ch === 0x5C /* \ */) {
        captureSegment(state, captureStart, state.position, true);
        ch = state.input.charCodeAt(++state.position);

        if (is_EOL(ch)) {
          skipSeparationSpace(state, false, nodeIndent);

          // TODO: rework to inline fn with no type cast?
        } else if (ch < 256 && simpleEscapeCheck[ch]) {
          state.result += simpleEscapeMap[ch];
          state.position++;
        } else if ((tmp = escapedHexLen(ch)) > 0) {
          hexLength = tmp;
          hexResult = 0;

          for (; hexLength > 0; hexLength--) {
            ch = state.input.charCodeAt(++state.position);

            if ((tmp = fromHexCode(ch)) >= 0) {
              hexResult = (hexResult << 4) + tmp;
            } else {
              throwError(state, 'expected hexadecimal character');
            }
          }

          state.result += charFromCodepoint(hexResult);

          state.position++;
        } else {
          throwError(state, 'unknown escape sequence');
        }

        captureStart = captureEnd = state.position;
      } else if (is_EOL(ch)) {
      captureSegment(state, captureStart, captureEnd, true);
      writeFoldedLines(state, skipSeparationSpace(state, false, nodeIndent));
      captureStart = captureEnd = state.position;
    } else if (state.position === state.lineStart && testDocumentSeparator(state)) {
      throwError(state, 'unexpected end of the document within a double quoted scalar');
    } else {
      state.position++;
      captureEnd = state.position;
    }
  }

  throwError(state, 'unexpected end of the stream within a double quoted scalar');
}

function readFlowCollection(state, nodeIndent) {
  var readNext = true,
      _line,
      _tag = state.tag,
      _result,
      _anchor = state.anchor,
      following,
      terminator,
      isPair,
      isExplicitPair,
      isMapping,
      overridableKeys = {},
      keyNode,
      keyTag,
      valueNode,
      ch;

  ch = state.input.charCodeAt(state.position);

  if (ch === 0x5B /* [ */) {
      terminator = 0x5D; /* ] */
      isMapping = false;
      _result = [];
    } else if (ch === 0x7B /* { */) {
      terminator = 0x7D; /* } */
      isMapping = true;
      _result = {};
    } else {
    return false;
  }

  if (state.anchor !== null) {
    state.anchorMap[state.anchor] = _result;
  }

  ch = state.input.charCodeAt(++state.position);

  while (ch !== 0) {
    skipSeparationSpace(state, true, nodeIndent);

    ch = state.input.charCodeAt(state.position);

    if (ch === terminator) {
      state.position++;
      state.tag = _tag;
      state.anchor = _anchor;
      state.kind = isMapping ? 'mapping' : 'sequence';
      state.result = _result;
      return true;
    } else if (!readNext) {
      throwError(state, 'missed comma between flow collection entries');
    }

    keyTag = keyNode = valueNode = null;
    isPair = isExplicitPair = false;

    if (ch === 0x3F /* ? */) {
        following = state.input.charCodeAt(state.position + 1);

        if (is_WS_OR_EOL(following)) {
          isPair = isExplicitPair = true;
          state.position++;
          skipSeparationSpace(state, true, nodeIndent);
        }
      }

    _line = state.line;
    composeNode(state, nodeIndent, CONTEXT_FLOW_IN, false, true);
    keyTag = state.tag;
    keyNode = state.result;
    skipSeparationSpace(state, true, nodeIndent);

    ch = state.input.charCodeAt(state.position);

    if ((isExplicitPair || state.line === _line) && ch === 0x3A /* : */) {
        isPair = true;
        ch = state.input.charCodeAt(++state.position);
        skipSeparationSpace(state, true, nodeIndent);
        composeNode(state, nodeIndent, CONTEXT_FLOW_IN, false, true);
        valueNode = state.result;
      }

    if (isMapping) {
      storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, valueNode);
    } else if (isPair) {
      _result.push(storeMappingPair(state, null, overridableKeys, keyTag, keyNode, valueNode));
    } else {
      _result.push(keyNode);
    }

    skipSeparationSpace(state, true, nodeIndent);

    ch = state.input.charCodeAt(state.position);

    if (ch === 0x2C /* , */) {
        readNext = true;
        ch = state.input.charCodeAt(++state.position);
      } else {
      readNext = false;
    }
  }

  throwError(state, 'unexpected end of the stream within a flow collection');
}

function readBlockScalar(state, nodeIndent) {
  var captureStart,
      folding,
      chomping = CHOMPING_CLIP,
      didReadContent = false,
      detectedIndent = false,
      textIndent = nodeIndent,
      emptyLines = 0,
      atMoreIndented = false,
      tmp,
      ch;

  ch = state.input.charCodeAt(state.position);

  if (ch === 0x7C /* | */) {
      folding = false;
    } else if (ch === 0x3E /* > */) {
      folding = true;
    } else {
    return false;
  }

  state.kind = 'scalar';
  state.result = '';

  while (ch !== 0) {
    ch = state.input.charCodeAt(++state.position);

    if (ch === 0x2B /* + */ || ch === 0x2D /* - */) {
        if (CHOMPING_CLIP === chomping) {
          chomping = ch === 0x2B /* + */ ? CHOMPING_KEEP : CHOMPING_STRIP;
        } else {
          throwError(state, 'repeat of a chomping mode identifier');
        }
      } else if ((tmp = fromDecimalCode(ch)) >= 0) {
      if (tmp === 0) {
        throwError(state, 'bad explicit indentation width of a block scalar; it cannot be less than one');
      } else if (!detectedIndent) {
        textIndent = nodeIndent + tmp - 1;
        detectedIndent = true;
      } else {
        throwError(state, 'repeat of an indentation width identifier');
      }
    } else {
      break;
    }
  }

  if (is_WHITE_SPACE(ch)) {
    do {
      ch = state.input.charCodeAt(++state.position);
    } while (is_WHITE_SPACE(ch));

    if (ch === 0x23 /* # */) {
        do {
          ch = state.input.charCodeAt(++state.position);
        } while (!is_EOL(ch) && ch !== 0);
      }
  }

  while (ch !== 0) {
    readLineBreak(state);
    state.lineIndent = 0;

    ch = state.input.charCodeAt(state.position);

    while ((!detectedIndent || state.lineIndent < textIndent) && ch === 0x20 /* Space */) {
      state.lineIndent++;
      ch = state.input.charCodeAt(++state.position);
    }

    if (!detectedIndent && state.lineIndent > textIndent) {
      textIndent = state.lineIndent;
    }

    if (is_EOL(ch)) {
      emptyLines++;
      continue;
    }

    // End of the scalar.
    if (state.lineIndent < textIndent) {

      // Perform the chomping.
      if (chomping === CHOMPING_KEEP) {
        state.result += common.repeat('\n', didReadContent ? 1 + emptyLines : emptyLines);
      } else if (chomping === CHOMPING_CLIP) {
        if (didReadContent) {
          // i.e. only if the scalar is not empty.
          state.result += '\n';
        }
      }

      // Break this `while` cycle and go to the funciton's epilogue.
      break;
    }

    // Folded style: use fancy rules to handle line breaks.
    if (folding) {

      // Lines starting with white space characters (more-indented lines) are not folded.
      if (is_WHITE_SPACE(ch)) {
        atMoreIndented = true;
        // except for the first content line (cf. Example 8.1)
        state.result += common.repeat('\n', didReadContent ? 1 + emptyLines : emptyLines);

        // End of more-indented block.
      } else if (atMoreIndented) {
        atMoreIndented = false;
        state.result += common.repeat('\n', emptyLines + 1);

        // Just one line break - perceive as the same line.
      } else if (emptyLines === 0) {
        if (didReadContent) {
          // i.e. only if we have already read some scalar content.
          state.result += ' ';
        }

        // Several line breaks - perceive as different lines.
      } else {
        state.result += common.repeat('\n', emptyLines);
      }

      // Literal style: just add exact number of line breaks between content lines.
    } else {
      // Keep all line breaks except the header line break.
      state.result += common.repeat('\n', didReadContent ? 1 + emptyLines : emptyLines);
    }

    didReadContent = true;
    detectedIndent = true;
    emptyLines = 0;
    captureStart = state.position;

    while (!is_EOL(ch) && ch !== 0) {
      ch = state.input.charCodeAt(++state.position);
    }

    captureSegment(state, captureStart, state.position, false);
  }

  return true;
}

function readBlockSequence(state, nodeIndent) {
  var _line,
      _tag = state.tag,
      _anchor = state.anchor,
      _result = [],
      following,
      detected = false,
      ch;

  if (state.anchor !== null) {
    state.anchorMap[state.anchor] = _result;
  }

  ch = state.input.charCodeAt(state.position);

  while (ch !== 0) {

    if (ch !== 0x2D /* - */) {
        break;
      }

    following = state.input.charCodeAt(state.position + 1);

    if (!is_WS_OR_EOL(following)) {
      break;
    }

    detected = true;
    state.position++;

    if (skipSeparationSpace(state, true, -1)) {
      if (state.lineIndent <= nodeIndent) {
        _result.push(null);
        ch = state.input.charCodeAt(state.position);
        continue;
      }
    }

    _line = state.line;
    composeNode(state, nodeIndent, CONTEXT_BLOCK_IN, false, true);
    _result.push(state.result);
    skipSeparationSpace(state, true, -1);

    ch = state.input.charCodeAt(state.position);

    if ((state.line === _line || state.lineIndent > nodeIndent) && ch !== 0) {
      throwError(state, 'bad indentation of a sequence entry');
    } else if (state.lineIndent < nodeIndent) {
      break;
    }
  }

  if (detected) {
    state.tag = _tag;
    state.anchor = _anchor;
    state.kind = 'sequence';
    state.result = _result;
    return true;
  }
  return false;
}

function readBlockMapping(state, nodeIndent, flowIndent) {
  var following,
      allowCompact,
      _line,
      _pos,
      _tag = state.tag,
      _anchor = state.anchor,
      _result = {},
      overridableKeys = {},
      keyTag = null,
      keyNode = null,
      valueNode = null,
      atExplicitKey = false,
      detected = false,
      ch;

  if (state.anchor !== null) {
    state.anchorMap[state.anchor] = _result;
  }

  ch = state.input.charCodeAt(state.position);

  while (ch !== 0) {
    following = state.input.charCodeAt(state.position + 1);
    _line = state.line; // Save the current line.
    _pos = state.position;

    //
    // Explicit notation case. There are two separate blocks:
    // first for the key (denoted by "?") and second for the value (denoted by ":")
    //
    if ((ch === 0x3F /* ? */ || ch === 0x3A /* : */) && is_WS_OR_EOL(following)) {

      if (ch === 0x3F /* ? */) {
          if (atExplicitKey) {
            storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, null);
            keyTag = keyNode = valueNode = null;
          }

          detected = true;
          atExplicitKey = true;
          allowCompact = true;
        } else if (atExplicitKey) {
        // i.e. 0x3A/* : */ === character after the explicit key.
        atExplicitKey = false;
        allowCompact = true;
      } else {
        throwError(state, 'incomplete explicit mapping pair; a key node is missed; or followed by a non-tabulated empty line');
      }

      state.position += 1;
      ch = following;

      //
      // Implicit notation case. Flow-style node as the key first, then ":", and the value.
      //
    } else if (composeNode(state, flowIndent, CONTEXT_FLOW_OUT, false, true)) {

      if (state.line === _line) {
        ch = state.input.charCodeAt(state.position);

        while (is_WHITE_SPACE(ch)) {
          ch = state.input.charCodeAt(++state.position);
        }

        if (ch === 0x3A /* : */) {
            ch = state.input.charCodeAt(++state.position);

            if (!is_WS_OR_EOL(ch)) {
              throwError(state, 'a whitespace character is expected after the key-value separator within a block mapping');
            }

            if (atExplicitKey) {
              storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, null);
              keyTag = keyNode = valueNode = null;
            }

            detected = true;
            atExplicitKey = false;
            allowCompact = false;
            keyTag = state.tag;
            keyNode = state.result;
          } else if (detected) {
          throwError(state, 'can not read an implicit mapping pair; a colon is missed');
        } else {
          state.tag = _tag;
          state.anchor = _anchor;
          return true; // Keep the result of `composeNode`.
        }
      } else if (detected) {
        throwError(state, 'can not read a block mapping entry; a multiline key may not be an implicit key');
      } else {
        state.tag = _tag;
        state.anchor = _anchor;
        return true; // Keep the result of `composeNode`.
      }
    } else {
        break; // Reading is done. Go to the epilogue.
      }

    //
    // Common reading code for both explicit and implicit notations.
    //
    if (state.line === _line || state.lineIndent > nodeIndent) {
      if (composeNode(state, nodeIndent, CONTEXT_BLOCK_OUT, true, allowCompact)) {
        if (atExplicitKey) {
          keyNode = state.result;
        } else {
          valueNode = state.result;
        }
      }

      if (!atExplicitKey) {
        storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, valueNode, _line, _pos);
        keyTag = keyNode = valueNode = null;
      }

      skipSeparationSpace(state, true, -1);
      ch = state.input.charCodeAt(state.position);
    }

    if (state.lineIndent > nodeIndent && ch !== 0) {
      throwError(state, 'bad indentation of a mapping entry');
    } else if (state.lineIndent < nodeIndent) {
      break;
    }
  }

  //
  // Epilogue.
  //

  // Special case: last mapping's node contains only the key in explicit notation.
  if (atExplicitKey) {
    storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, null);
  }

  // Expose the resulting mapping.
  if (detected) {
    state.tag = _tag;
    state.anchor = _anchor;
    state.kind = 'mapping';
    state.result = _result;
  }

  return detected;
}

function readTagProperty(state) {
  var _position,
      isVerbatim = false,
      isNamed = false,
      tagHandle,
      tagName,
      ch;

  ch = state.input.charCodeAt(state.position);

  if (ch !== 0x21 /* ! */) return false;

  if (state.tag !== null) {
    throwError(state, 'duplication of a tag property');
  }

  ch = state.input.charCodeAt(++state.position);

  if (ch === 0x3C /* < */) {
      isVerbatim = true;
      ch = state.input.charCodeAt(++state.position);
    } else if (ch === 0x21 /* ! */) {
      isNamed = true;
      tagHandle = '!!';
      ch = state.input.charCodeAt(++state.position);
    } else {
    tagHandle = '!';
  }

  _position = state.position;

  if (isVerbatim) {
    do {
      ch = state.input.charCodeAt(++state.position);
    } while (ch !== 0 && ch !== 0x3E /* > */);

    if (state.position < state.length) {
      tagName = state.input.slice(_position, state.position);
      ch = state.input.charCodeAt(++state.position);
    } else {
      throwError(state, 'unexpected end of the stream within a verbatim tag');
    }
  } else {
    while (ch !== 0 && !is_WS_OR_EOL(ch)) {

      if (ch === 0x21 /* ! */) {
          if (!isNamed) {
            tagHandle = state.input.slice(_position - 1, state.position + 1);

            if (!PATTERN_TAG_HANDLE.test(tagHandle)) {
              throwError(state, 'named tag handle cannot contain such characters');
            }

            isNamed = true;
            _position = state.position + 1;
          } else {
            throwError(state, 'tag suffix cannot contain exclamation marks');
          }
        }

      ch = state.input.charCodeAt(++state.position);
    }

    tagName = state.input.slice(_position, state.position);

    if (PATTERN_FLOW_INDICATORS.test(tagName)) {
      throwError(state, 'tag suffix cannot contain flow indicator characters');
    }
  }

  if (tagName && !PATTERN_TAG_URI.test(tagName)) {
    throwError(state, 'tag name cannot contain such characters: ' + tagName);
  }

  if (isVerbatim) {
    state.tag = tagName;
  } else if (_hasOwnProperty.call(state.tagMap, tagHandle)) {
    state.tag = state.tagMap[tagHandle] + tagName;
  } else if (tagHandle === '!') {
    state.tag = '!' + tagName;
  } else if (tagHandle === '!!') {
    state.tag = 'tag:yaml.org,2002:' + tagName;
  } else {
    throwError(state, 'undeclared tag handle "' + tagHandle + '"');
  }

  return true;
}

function readAnchorProperty(state) {
  var _position, ch;

  ch = state.input.charCodeAt(state.position);

  if (ch !== 0x26 /* & */) return false;

  if (state.anchor !== null) {
    throwError(state, 'duplication of an anchor property');
  }

  ch = state.input.charCodeAt(++state.position);
  _position = state.position;

  while (ch !== 0 && !is_WS_OR_EOL(ch) && !is_FLOW_INDICATOR(ch)) {
    ch = state.input.charCodeAt(++state.position);
  }

  if (state.position === _position) {
    throwError(state, 'name of an anchor node must contain at least one character');
  }

  state.anchor = state.input.slice(_position, state.position);
  return true;
}

function readAlias(state) {
  var _position, alias, ch;

  ch = state.input.charCodeAt(state.position);

  if (ch !== 0x2A /* * */) return false;

  ch = state.input.charCodeAt(++state.position);
  _position = state.position;

  while (ch !== 0 && !is_WS_OR_EOL(ch) && !is_FLOW_INDICATOR(ch)) {
    ch = state.input.charCodeAt(++state.position);
  }

  if (state.position === _position) {
    throwError(state, 'name of an alias node must contain at least one character');
  }

  alias = state.input.slice(_position, state.position);

  if (!state.anchorMap.hasOwnProperty(alias)) {
    throwError(state, 'unidentified alias "' + alias + '"');
  }

  state.result = state.anchorMap[alias];
  skipSeparationSpace(state, true, -1);
  return true;
}

function composeNode(state, parentIndent, nodeContext, allowToSeek, allowCompact) {
  var allowBlockStyles,
      allowBlockScalars,
      allowBlockCollections,
      indentStatus = 1,
      // 1: this>parent, 0: this=parent, -1: this<parent
  atNewLine = false,
      hasContent = false,
      typeIndex,
      typeQuantity,
      type,
      flowIndent,
      blockIndent;

  if (state.listener !== null) {
    state.listener('open', state);
  }

  state.tag = null;
  state.anchor = null;
  state.kind = null;
  state.result = null;

  allowBlockStyles = allowBlockScalars = allowBlockCollections = CONTEXT_BLOCK_OUT === nodeContext || CONTEXT_BLOCK_IN === nodeContext;

  if (allowToSeek) {
    if (skipSeparationSpace(state, true, -1)) {
      atNewLine = true;

      if (state.lineIndent > parentIndent) {
        indentStatus = 1;
      } else if (state.lineIndent === parentIndent) {
        indentStatus = 0;
      } else if (state.lineIndent < parentIndent) {
        indentStatus = -1;
      }
    }
  }

  if (indentStatus === 1) {
    while (readTagProperty(state) || readAnchorProperty(state)) {
      if (skipSeparationSpace(state, true, -1)) {
        atNewLine = true;
        allowBlockCollections = allowBlockStyles;

        if (state.lineIndent > parentIndent) {
          indentStatus = 1;
        } else if (state.lineIndent === parentIndent) {
          indentStatus = 0;
        } else if (state.lineIndent < parentIndent) {
          indentStatus = -1;
        }
      } else {
        allowBlockCollections = false;
      }
    }
  }

  if (allowBlockCollections) {
    allowBlockCollections = atNewLine || allowCompact;
  }

  if (indentStatus === 1 || CONTEXT_BLOCK_OUT === nodeContext) {
    if (CONTEXT_FLOW_IN === nodeContext || CONTEXT_FLOW_OUT === nodeContext) {
      flowIndent = parentIndent;
    } else {
      flowIndent = parentIndent + 1;
    }

    blockIndent = state.position - state.lineStart;

    if (indentStatus === 1) {
      if (allowBlockCollections && (readBlockSequence(state, blockIndent) || readBlockMapping(state, blockIndent, flowIndent)) || readFlowCollection(state, flowIndent)) {
        hasContent = true;
      } else {
        if (allowBlockScalars && readBlockScalar(state, flowIndent) || readSingleQuotedScalar(state, flowIndent) || readDoubleQuotedScalar(state, flowIndent)) {
          hasContent = true;
        } else if (readAlias(state)) {
          hasContent = true;

          if (state.tag !== null || state.anchor !== null) {
            throwError(state, 'alias node should not have any properties');
          }
        } else if (readPlainScalar(state, flowIndent, CONTEXT_FLOW_IN === nodeContext)) {
          hasContent = true;

          if (state.tag === null) {
            state.tag = '?';
          }
        }

        if (state.anchor !== null) {
          state.anchorMap[state.anchor] = state.result;
        }
      }
    } else if (indentStatus === 0) {
      // Special case: block sequences are allowed to have same indentation level as the parent.
      // http://www.yaml.org/spec/1.2/spec.html#id2799784
      hasContent = allowBlockCollections && readBlockSequence(state, blockIndent);
    }
  }

  if (state.tag !== null && state.tag !== '!') {
    if (state.tag === '?') {
      for (typeIndex = 0, typeQuantity = state.implicitTypes.length; typeIndex < typeQuantity; typeIndex += 1) {
        type = state.implicitTypes[typeIndex];

        // Implicit resolving is not allowed for non-scalar types, and '?'
        // non-specific tag is only assigned to plain scalars. So, it isn't
        // needed to check for 'kind' conformity.

        if (type.resolve(state.result)) {
          // `state.result` updated in resolver if matched
          state.result = type.construct(state.result);
          state.tag = type.tag;
          if (state.anchor !== null) {
            state.anchorMap[state.anchor] = state.result;
          }
          break;
        }
      }
    } else if (_hasOwnProperty.call(state.typeMap[state.kind || 'fallback'], state.tag)) {
      type = state.typeMap[state.kind || 'fallback'][state.tag];

      if (state.result !== null && type.kind !== state.kind) {
        throwError(state, 'unacceptable node kind for !<' + state.tag + '> tag; it should be "' + type.kind + '", not "' + state.kind + '"');
      }

      if (!type.resolve(state.result)) {
        // `state.result` updated in resolver if matched
        throwError(state, 'cannot resolve a node with !<' + state.tag + '> explicit tag');
      } else {
        state.result = type.construct(state.result);
        if (state.anchor !== null) {
          state.anchorMap[state.anchor] = state.result;
        }
      }
    } else {
      throwError(state, 'unknown tag !<' + state.tag + '>');
    }
  }

  if (state.listener !== null) {
    state.listener('close', state);
  }
  return state.tag !== null || state.anchor !== null || hasContent;
}

function readDocument(state) {
  var documentStart = state.position,
      _position,
      directiveName,
      directiveArgs,
      hasDirectives = false,
      ch;

  state.version = null;
  state.checkLineBreaks = state.legacy;
  state.tagMap = {};
  state.anchorMap = {};

  while ((ch = state.input.charCodeAt(state.position)) !== 0) {
    skipSeparationSpace(state, true, -1);

    ch = state.input.charCodeAt(state.position);

    if (state.lineIndent > 0 || ch !== 0x25 /* % */) {
        break;
      }

    hasDirectives = true;
    ch = state.input.charCodeAt(++state.position);
    _position = state.position;

    while (ch !== 0 && !is_WS_OR_EOL(ch)) {
      ch = state.input.charCodeAt(++state.position);
    }

    directiveName = state.input.slice(_position, state.position);
    directiveArgs = [];

    if (directiveName.length < 1) {
      throwError(state, 'directive name must not be less than one character in length');
    }

    while (ch !== 0) {
      while (is_WHITE_SPACE(ch)) {
        ch = state.input.charCodeAt(++state.position);
      }

      if (ch === 0x23 /* # */) {
          do {
            ch = state.input.charCodeAt(++state.position);
          } while (ch !== 0 && !is_EOL(ch));
          break;
        }

      if (is_EOL(ch)) break;

      _position = state.position;

      while (ch !== 0 && !is_WS_OR_EOL(ch)) {
        ch = state.input.charCodeAt(++state.position);
      }

      directiveArgs.push(state.input.slice(_position, state.position));
    }

    if (ch !== 0) readLineBreak(state);

    if (_hasOwnProperty.call(directiveHandlers, directiveName)) {
      directiveHandlers[directiveName](state, directiveName, directiveArgs);
    } else {
      throwWarning(state, 'unknown document directive "' + directiveName + '"');
    }
  }

  skipSeparationSpace(state, true, -1);

  if (state.lineIndent === 0 && state.input.charCodeAt(state.position) === 0x2D /* - */ && state.input.charCodeAt(state.position + 1) === 0x2D /* - */ && state.input.charCodeAt(state.position + 2) === 0x2D /* - */) {
      state.position += 3;
      skipSeparationSpace(state, true, -1);
    } else if (hasDirectives) {
    throwError(state, 'directives end mark is expected');
  }

  composeNode(state, state.lineIndent - 1, CONTEXT_BLOCK_OUT, false, true);
  skipSeparationSpace(state, true, -1);

  if (state.checkLineBreaks && PATTERN_NON_ASCII_LINE_BREAKS.test(state.input.slice(documentStart, state.position))) {
    throwWarning(state, 'non-ASCII line breaks are interpreted as content');
  }

  state.documents.push(state.result);

  if (state.position === state.lineStart && testDocumentSeparator(state)) {

    if (state.input.charCodeAt(state.position) === 0x2E /* . */) {
        state.position += 3;
        skipSeparationSpace(state, true, -1);
      }
    return;
  }

  if (state.position < state.length - 1) {
    throwError(state, 'end of the stream or a document separator is expected');
  } else {
    return;
  }
}

function loadDocuments(input, options) {
  input = String(input);
  options = options || {};

  if (input.length !== 0) {

    // Add tailing `\n` if not exists
    if (input.charCodeAt(input.length - 1) !== 0x0A /* LF */ && input.charCodeAt(input.length - 1) !== 0x0D /* CR */) {
        input += '\n';
      }

    // Strip BOM
    if (input.charCodeAt(0) === 0xFEFF) {
      input = input.slice(1);
    }
  }

  var state = new State(input, options);

  // Use 0 as string terminator. That significantly simplifies bounds check.
  state.input += '\0';

  while (state.input.charCodeAt(state.position) === 0x20 /* Space */) {
    state.lineIndent += 1;
    state.position += 1;
  }

  while (state.position < state.length - 1) {
    readDocument(state);
  }

  return state.documents;
}

function loadAll(input, iterator, options) {
  var documents = loadDocuments(input, options),
      index,
      length;

  if (typeof iterator !== 'function') {
    return documents;
  }

  for (index = 0, length = documents.length; index < length; index += 1) {
    iterator(documents[index]);
  }
}

function load(input, options) {
  var documents = loadDocuments(input, options);

  if (documents.length === 0) {
    /*eslint-disable no-undefined*/
    return undefined;
  } else if (documents.length === 1) {
    return documents[0];
  }
  throw new YAMLException('expected a single document in the stream, but found more');
}

function safeLoadAll(input, output, options) {
  if (typeof output === 'function') {
    loadAll(input, output, common.extend({ schema: DEFAULT_SAFE_SCHEMA }, options));
  } else {
    return loadAll(input, common.extend({ schema: DEFAULT_SAFE_SCHEMA }, options));
  }
}

function safeLoad(input, options) {
  return load(input, common.extend({ schema: DEFAULT_SAFE_SCHEMA }, options));
}

module.exports.loadAll = loadAll;
module.exports.load = load;
module.exports.safeLoadAll = safeLoadAll;
module.exports.safeLoad = safeLoad;

/***/ }),
/* 139 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var common = __webpack_require__(17);

function Mark(name, buffer, position, line, column) {
  this.name = name;
  this.buffer = buffer;
  this.position = position;
  this.line = line;
  this.column = column;
}

Mark.prototype.getSnippet = function getSnippet(indent, maxLength) {
  var head, start, tail, end, snippet;

  if (!this.buffer) return null;

  indent = indent || 4;
  maxLength = maxLength || 75;

  head = '';
  start = this.position;

  while (start > 0 && '\x00\r\n\x85\u2028\u2029'.indexOf(this.buffer.charAt(start - 1)) === -1) {
    start -= 1;
    if (this.position - start > maxLength / 2 - 1) {
      head = ' ... ';
      start += 5;
      break;
    }
  }

  tail = '';
  end = this.position;

  while (end < this.buffer.length && '\x00\r\n\x85\u2028\u2029'.indexOf(this.buffer.charAt(end)) === -1) {
    end += 1;
    if (end - this.position > maxLength / 2 - 1) {
      tail = ' ... ';
      end -= 5;
      break;
    }
  }

  snippet = this.buffer.slice(start, end);

  return common.repeat(' ', indent) + head + snippet + tail + '\n' + common.repeat(' ', indent + this.position - start + head.length) + '^';
};

Mark.prototype.toString = function toString(compact) {
  var snippet,
      where = '';

  if (this.name) {
    where += 'in "' + this.name + '" ';
  }

  where += 'at line ' + (this.line + 1) + ', column ' + (this.column + 1);

  if (!compact) {
    snippet = this.getSnippet();

    if (snippet) {
      where += ':\n' + snippet;
    }
  }

  return where;
};

module.exports = Mark;

/***/ }),
/* 140 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var Type = __webpack_require__(4);

module.exports = new Type('tag:yaml.org,2002:str', {
  kind: 'scalar',
  construct: function (data) {
    return data !== null ? data : '';
  }
});

/***/ }),
/* 141 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var Type = __webpack_require__(4);

module.exports = new Type('tag:yaml.org,2002:seq', {
  kind: 'sequence',
  construct: function (data) {
    return data !== null ? data : [];
  }
});

/***/ }),
/* 142 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var Type = __webpack_require__(4);

module.exports = new Type('tag:yaml.org,2002:map', {
  kind: 'mapping',
  construct: function (data) {
    return data !== null ? data : {};
  }
});

/***/ }),
/* 143 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var Type = __webpack_require__(4);

function resolveYamlNull(data) {
  if (data === null) return true;

  var max = data.length;

  return max === 1 && data === '~' || max === 4 && (data === 'null' || data === 'Null' || data === 'NULL');
}

function constructYamlNull() {
  return null;
}

function isNull(object) {
  return object === null;
}

module.exports = new Type('tag:yaml.org,2002:null', {
  kind: 'scalar',
  resolve: resolveYamlNull,
  construct: constructYamlNull,
  predicate: isNull,
  represent: {
    canonical: function () {
      return '~';
    },
    lowercase: function () {
      return 'null';
    },
    uppercase: function () {
      return 'NULL';
    },
    camelcase: function () {
      return 'Null';
    }
  },
  defaultStyle: 'lowercase'
});

/***/ }),
/* 144 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var Type = __webpack_require__(4);

function resolveYamlBoolean(data) {
  if (data === null) return false;

  var max = data.length;

  return max === 4 && (data === 'true' || data === 'True' || data === 'TRUE') || max === 5 && (data === 'false' || data === 'False' || data === 'FALSE');
}

function constructYamlBoolean(data) {
  return data === 'true' || data === 'True' || data === 'TRUE';
}

function isBoolean(object) {
  return Object.prototype.toString.call(object) === '[object Boolean]';
}

module.exports = new Type('tag:yaml.org,2002:bool', {
  kind: 'scalar',
  resolve: resolveYamlBoolean,
  construct: constructYamlBoolean,
  predicate: isBoolean,
  represent: {
    lowercase: function (object) {
      return object ? 'true' : 'false';
    },
    uppercase: function (object) {
      return object ? 'TRUE' : 'FALSE';
    },
    camelcase: function (object) {
      return object ? 'True' : 'False';
    }
  },
  defaultStyle: 'lowercase'
});

/***/ }),
/* 145 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var common = __webpack_require__(17);
var Type = __webpack_require__(4);

function isHexCode(c) {
  return 0x30 /* 0 */ <= c && c <= 0x39 /* 9 */ || 0x41 /* A */ <= c && c <= 0x46 /* F */ || 0x61 /* a */ <= c && c <= 0x66 /* f */;
}

function isOctCode(c) {
  return 0x30 /* 0 */ <= c && c <= 0x37 /* 7 */;
}

function isDecCode(c) {
  return 0x30 /* 0 */ <= c && c <= 0x39 /* 9 */;
}

function resolveYamlInteger(data) {
  if (data === null) return false;

  var max = data.length,
      index = 0,
      hasDigits = false,
      ch;

  if (!max) return false;

  ch = data[index];

  // sign
  if (ch === '-' || ch === '+') {
    ch = data[++index];
  }

  if (ch === '0') {
    // 0
    if (index + 1 === max) return true;
    ch = data[++index];

    // base 2, base 8, base 16

    if (ch === 'b') {
      // base 2
      index++;

      for (; index < max; index++) {
        ch = data[index];
        if (ch === '_') continue;
        if (ch !== '0' && ch !== '1') return false;
        hasDigits = true;
      }
      return hasDigits && ch !== '_';
    }

    if (ch === 'x') {
      // base 16
      index++;

      for (; index < max; index++) {
        ch = data[index];
        if (ch === '_') continue;
        if (!isHexCode(data.charCodeAt(index))) return false;
        hasDigits = true;
      }
      return hasDigits && ch !== '_';
    }

    // base 8
    for (; index < max; index++) {
      ch = data[index];
      if (ch === '_') continue;
      if (!isOctCode(data.charCodeAt(index))) return false;
      hasDigits = true;
    }
    return hasDigits && ch !== '_';
  }

  // base 10 (except 0) or base 60

  // value should not start with `_`;
  if (ch === '_') return false;

  for (; index < max; index++) {
    ch = data[index];
    if (ch === '_') continue;
    if (ch === ':') break;
    if (!isDecCode(data.charCodeAt(index))) {
      return false;
    }
    hasDigits = true;
  }

  // Should have digits and should not end with `_`
  if (!hasDigits || ch === '_') return false;

  // if !base60 - done;
  if (ch !== ':') return true;

  // base60 almost not used, no needs to optimize
  return (/^(:[0-5]?[0-9])+$/.test(data.slice(index))
  );
}

function constructYamlInteger(data) {
  var value = data,
      sign = 1,
      ch,
      base,
      digits = [];

  if (value.indexOf('_') !== -1) {
    value = value.replace(/_/g, '');
  }

  ch = value[0];

  if (ch === '-' || ch === '+') {
    if (ch === '-') sign = -1;
    value = value.slice(1);
    ch = value[0];
  }

  if (value === '0') return 0;

  if (ch === '0') {
    if (value[1] === 'b') return sign * parseInt(value.slice(2), 2);
    if (value[1] === 'x') return sign * parseInt(value, 16);
    return sign * parseInt(value, 8);
  }

  if (value.indexOf(':') !== -1) {
    value.split(':').forEach(function (v) {
      digits.unshift(parseInt(v, 10));
    });

    value = 0;
    base = 1;

    digits.forEach(function (d) {
      value += d * base;
      base *= 60;
    });

    return sign * value;
  }

  return sign * parseInt(value, 10);
}

function isInteger(object) {
  return Object.prototype.toString.call(object) === '[object Number]' && object % 1 === 0 && !common.isNegativeZero(object);
}

module.exports = new Type('tag:yaml.org,2002:int', {
  kind: 'scalar',
  resolve: resolveYamlInteger,
  construct: constructYamlInteger,
  predicate: isInteger,
  represent: {
    binary: function (object) {
      return '0b' + object.toString(2);
    },
    octal: function (object) {
      return '0' + object.toString(8);
    },
    decimal: function (object) {
      return object.toString(10);
    },
    hexadecimal: function (object) {
      return '0x' + object.toString(16).toUpperCase();
    }
  },
  defaultStyle: 'decimal',
  styleAliases: {
    binary: [2, 'bin'],
    octal: [8, 'oct'],
    decimal: [10, 'dec'],
    hexadecimal: [16, 'hex']
  }
});

/***/ }),
/* 146 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var common = __webpack_require__(17);
var Type = __webpack_require__(4);

var YAML_FLOAT_PATTERN = new RegExp(
// 2.5e4, 2.5 and integers
'^(?:[-+]?(?:0|[1-9][0-9_]*)(?:\\.[0-9_]*)?(?:[eE][-+]?[0-9]+)?' +
// .2e4, .2
// special case, seems not from spec
'|\\.[0-9_]+(?:[eE][-+]?[0-9]+)?' +
// 20:59
'|[-+]?[0-9][0-9_]*(?::[0-5]?[0-9])+\\.[0-9_]*' +
// .inf
'|[-+]?\\.(?:inf|Inf|INF)' +
// .nan
'|\\.(?:nan|NaN|NAN))$');

function resolveYamlFloat(data) {
  if (data === null) return false;

  if (!YAML_FLOAT_PATTERN.test(data) ||
  // Quick hack to not allow integers end with `_`
  // Probably should update regexp & check speed
  data[data.length - 1] === '_') {
    return false;
  }

  return true;
}

function constructYamlFloat(data) {
  var value, sign, base, digits;

  value = data.replace(/_/g, '').toLowerCase();
  sign = value[0] === '-' ? -1 : 1;
  digits = [];

  if ('+-'.indexOf(value[0]) >= 0) {
    value = value.slice(1);
  }

  if (value === '.inf') {
    return sign === 1 ? Number.POSITIVE_INFINITY : Number.NEGATIVE_INFINITY;
  } else if (value === '.nan') {
    return NaN;
  } else if (value.indexOf(':') >= 0) {
    value.split(':').forEach(function (v) {
      digits.unshift(parseFloat(v, 10));
    });

    value = 0.0;
    base = 1;

    digits.forEach(function (d) {
      value += d * base;
      base *= 60;
    });

    return sign * value;
  }
  return sign * parseFloat(value, 10);
}

var SCIENTIFIC_WITHOUT_DOT = /^[-+]?[0-9]+e/;

function representYamlFloat(object, style) {
  var res;

  if (isNaN(object)) {
    switch (style) {
      case 'lowercase':
        return '.nan';
      case 'uppercase':
        return '.NAN';
      case 'camelcase':
        return '.NaN';
    }
  } else if (Number.POSITIVE_INFINITY === object) {
    switch (style) {
      case 'lowercase':
        return '.inf';
      case 'uppercase':
        return '.INF';
      case 'camelcase':
        return '.Inf';
    }
  } else if (Number.NEGATIVE_INFINITY === object) {
    switch (style) {
      case 'lowercase':
        return '-.inf';
      case 'uppercase':
        return '-.INF';
      case 'camelcase':
        return '-.Inf';
    }
  } else if (common.isNegativeZero(object)) {
    return '-0.0';
  }

  res = object.toString(10);

  // JS stringifier can build scientific format without dots: 5e-100,
  // while YAML requres dot: 5.e-100. Fix it with simple hack

  return SCIENTIFIC_WITHOUT_DOT.test(res) ? res.replace('e', '.e') : res;
}

function isFloat(object) {
  return Object.prototype.toString.call(object) === '[object Number]' && (object % 1 !== 0 || common.isNegativeZero(object));
}

module.exports = new Type('tag:yaml.org,2002:float', {
  kind: 'scalar',
  resolve: resolveYamlFloat,
  construct: constructYamlFloat,
  predicate: isFloat,
  represent: representYamlFloat,
  defaultStyle: 'lowercase'
});

/***/ }),
/* 147 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var Type = __webpack_require__(4);

var YAML_DATE_REGEXP = new RegExp('^([0-9][0-9][0-9][0-9])' + // [1] year
'-([0-9][0-9])' + // [2] month
'-([0-9][0-9])$'); // [3] day

var YAML_TIMESTAMP_REGEXP = new RegExp('^([0-9][0-9][0-9][0-9])' + // [1] year
'-([0-9][0-9]?)' + // [2] month
'-([0-9][0-9]?)' + // [3] day
'(?:[Tt]|[ \\t]+)' + // ...
'([0-9][0-9]?)' + // [4] hour
':([0-9][0-9])' + // [5] minute
':([0-9][0-9])' + // [6] second
'(?:\\.([0-9]*))?' + // [7] fraction
'(?:[ \\t]*(Z|([-+])([0-9][0-9]?)' + // [8] tz [9] tz_sign [10] tz_hour
'(?::([0-9][0-9]))?))?$'); // [11] tz_minute

function resolveYamlTimestamp(data) {
  if (data === null) return false;
  if (YAML_DATE_REGEXP.exec(data) !== null) return true;
  if (YAML_TIMESTAMP_REGEXP.exec(data) !== null) return true;
  return false;
}

function constructYamlTimestamp(data) {
  var match,
      year,
      month,
      day,
      hour,
      minute,
      second,
      fraction = 0,
      delta = null,
      tz_hour,
      tz_minute,
      date;

  match = YAML_DATE_REGEXP.exec(data);
  if (match === null) match = YAML_TIMESTAMP_REGEXP.exec(data);

  if (match === null) throw new Error('Date resolve error');

  // match: [1] year [2] month [3] day

  year = +match[1];
  month = +match[2] - 1; // JS month starts with 0
  day = +match[3];

  if (!match[4]) {
    // no hour
    return new Date(Date.UTC(year, month, day));
  }

  // match: [4] hour [5] minute [6] second [7] fraction

  hour = +match[4];
  minute = +match[5];
  second = +match[6];

  if (match[7]) {
    fraction = match[7].slice(0, 3);
    while (fraction.length < 3) {
      // milli-seconds
      fraction += '0';
    }
    fraction = +fraction;
  }

  // match: [8] tz [9] tz_sign [10] tz_hour [11] tz_minute

  if (match[9]) {
    tz_hour = +match[10];
    tz_minute = +(match[11] || 0);
    delta = (tz_hour * 60 + tz_minute) * 60000; // delta in mili-seconds
    if (match[9] === '-') delta = -delta;
  }

  date = new Date(Date.UTC(year, month, day, hour, minute, second, fraction));

  if (delta) date.setTime(date.getTime() - delta);

  return date;
}

function representYamlTimestamp(object /*, style*/) {
  return object.toISOString();
}

module.exports = new Type('tag:yaml.org,2002:timestamp', {
  kind: 'scalar',
  resolve: resolveYamlTimestamp,
  construct: constructYamlTimestamp,
  instanceOf: Date,
  represent: representYamlTimestamp
});

/***/ }),
/* 148 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var Type = __webpack_require__(4);

function resolveYamlMerge(data) {
  return data === '<<' || data === null;
}

module.exports = new Type('tag:yaml.org,2002:merge', {
  kind: 'scalar',
  resolve: resolveYamlMerge
});

/***/ }),
/* 149 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var require;

/*eslint-disable no-bitwise*/

var NodeBuffer;

try {
  // A trick for browserified version, to not include `Buffer` shim
  var _require = require;
  NodeBuffer = __webpack_require__(150).Buffer;
} catch (__) {}

var Type = __webpack_require__(4);

// [ 64, 65, 66 ] -> [ padding, CR, LF ]
var BASE64_MAP = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\n\r';

function resolveYamlBinary(data) {
  if (data === null) return false;

  var code,
      idx,
      bitlen = 0,
      max = data.length,
      map = BASE64_MAP;

  // Convert one by one.
  for (idx = 0; idx < max; idx++) {
    code = map.indexOf(data.charAt(idx));

    // Skip CR/LF
    if (code > 64) continue;

    // Fail on illegal characters
    if (code < 0) return false;

    bitlen += 6;
  }

  // If there are any bits left, source was corrupted
  return bitlen % 8 === 0;
}

function constructYamlBinary(data) {
  var idx,
      tailbits,
      input = data.replace(/[\r\n=]/g, ''),
      // remove CR/LF & padding to simplify scan
  max = input.length,
      map = BASE64_MAP,
      bits = 0,
      result = [];

  // Collect by 6*4 bits (3 bytes)

  for (idx = 0; idx < max; idx++) {
    if (idx % 4 === 0 && idx) {
      result.push(bits >> 16 & 0xFF);
      result.push(bits >> 8 & 0xFF);
      result.push(bits & 0xFF);
    }

    bits = bits << 6 | map.indexOf(input.charAt(idx));
  }

  // Dump tail

  tailbits = max % 4 * 6;

  if (tailbits === 0) {
    result.push(bits >> 16 & 0xFF);
    result.push(bits >> 8 & 0xFF);
    result.push(bits & 0xFF);
  } else if (tailbits === 18) {
    result.push(bits >> 10 & 0xFF);
    result.push(bits >> 2 & 0xFF);
  } else if (tailbits === 12) {
    result.push(bits >> 4 & 0xFF);
  }

  // Wrap into Buffer for NodeJS and leave Array for browser
  if (NodeBuffer) {
    // Support node 6.+ Buffer API when available
    return NodeBuffer.from ? NodeBuffer.from(result) : new NodeBuffer(result);
  }

  return result;
}

function representYamlBinary(object /*, style*/) {
  var result = '',
      bits = 0,
      idx,
      tail,
      max = object.length,
      map = BASE64_MAP;

  // Convert every three bytes to 4 ASCII characters.

  for (idx = 0; idx < max; idx++) {
    if (idx % 3 === 0 && idx) {
      result += map[bits >> 18 & 0x3F];
      result += map[bits >> 12 & 0x3F];
      result += map[bits >> 6 & 0x3F];
      result += map[bits & 0x3F];
    }

    bits = (bits << 8) + object[idx];
  }

  // Dump tail

  tail = max % 3;

  if (tail === 0) {
    result += map[bits >> 18 & 0x3F];
    result += map[bits >> 12 & 0x3F];
    result += map[bits >> 6 & 0x3F];
    result += map[bits & 0x3F];
  } else if (tail === 2) {
    result += map[bits >> 10 & 0x3F];
    result += map[bits >> 4 & 0x3F];
    result += map[bits << 2 & 0x3F];
    result += map[64];
  } else if (tail === 1) {
    result += map[bits >> 2 & 0x3F];
    result += map[bits << 4 & 0x3F];
    result += map[64];
    result += map[64];
  }

  return result;
}

function isBinary(object) {
  return NodeBuffer && NodeBuffer.isBuffer(object);
}

module.exports = new Type('tag:yaml.org,2002:binary', {
  kind: 'scalar',
  resolve: resolveYamlBinary,
  construct: constructYamlBinary,
  predicate: isBinary,
  represent: representYamlBinary
});

/***/ }),
/* 150 */
/***/ (function(module, exports) {

module.exports = require("buffer");

/***/ }),
/* 151 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var Type = __webpack_require__(4);

var _hasOwnProperty = Object.prototype.hasOwnProperty;
var _toString = Object.prototype.toString;

function resolveYamlOmap(data) {
  if (data === null) return true;

  var objectKeys = [],
      index,
      length,
      pair,
      pairKey,
      pairHasKey,
      object = data;

  for (index = 0, length = object.length; index < length; index += 1) {
    pair = object[index];
    pairHasKey = false;

    if (_toString.call(pair) !== '[object Object]') return false;

    for (pairKey in pair) {
      if (_hasOwnProperty.call(pair, pairKey)) {
        if (!pairHasKey) pairHasKey = true;else return false;
      }
    }

    if (!pairHasKey) return false;

    if (objectKeys.indexOf(pairKey) === -1) objectKeys.push(pairKey);else return false;
  }

  return true;
}

function constructYamlOmap(data) {
  return data !== null ? data : [];
}

module.exports = new Type('tag:yaml.org,2002:omap', {
  kind: 'sequence',
  resolve: resolveYamlOmap,
  construct: constructYamlOmap
});

/***/ }),
/* 152 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var Type = __webpack_require__(4);

var _toString = Object.prototype.toString;

function resolveYamlPairs(data) {
  if (data === null) return true;

  var index,
      length,
      pair,
      keys,
      result,
      object = data;

  result = new Array(object.length);

  for (index = 0, length = object.length; index < length; index += 1) {
    pair = object[index];

    if (_toString.call(pair) !== '[object Object]') return false;

    keys = Object.keys(pair);

    if (keys.length !== 1) return false;

    result[index] = [keys[0], pair[keys[0]]];
  }

  return true;
}

function constructYamlPairs(data) {
  if (data === null) return [];

  var index,
      length,
      pair,
      keys,
      result,
      object = data;

  result = new Array(object.length);

  for (index = 0, length = object.length; index < length; index += 1) {
    pair = object[index];

    keys = Object.keys(pair);

    result[index] = [keys[0], pair[keys[0]]];
  }

  return result;
}

module.exports = new Type('tag:yaml.org,2002:pairs', {
  kind: 'sequence',
  resolve: resolveYamlPairs,
  construct: constructYamlPairs
});

/***/ }),
/* 153 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var Type = __webpack_require__(4);

var _hasOwnProperty = Object.prototype.hasOwnProperty;

function resolveYamlSet(data) {
  if (data === null) return true;

  var key,
      object = data;

  for (key in object) {
    if (_hasOwnProperty.call(object, key)) {
      if (object[key] !== null) return false;
    }
  }

  return true;
}

function constructYamlSet(data) {
  return data !== null ? data : {};
}

module.exports = new Type('tag:yaml.org,2002:set', {
  kind: 'mapping',
  resolve: resolveYamlSet,
  construct: constructYamlSet
});

/***/ }),
/* 154 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var Type = __webpack_require__(4);

function resolveJavascriptUndefined() {
  return true;
}

function constructJavascriptUndefined() {
  /*eslint-disable no-undefined*/
  return undefined;
}

function representJavascriptUndefined() {
  return '';
}

function isUndefined(object) {
  return typeof object === 'undefined';
}

module.exports = new Type('tag:yaml.org,2002:js/undefined', {
  kind: 'scalar',
  resolve: resolveJavascriptUndefined,
  construct: constructJavascriptUndefined,
  predicate: isUndefined,
  represent: representJavascriptUndefined
});

/***/ }),
/* 155 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var Type = __webpack_require__(4);

function resolveJavascriptRegExp(data) {
  if (data === null) return false;
  if (data.length === 0) return false;

  var regexp = data,
      tail = /\/([gim]*)$/.exec(data),
      modifiers = '';

  // if regexp starts with '/' it can have modifiers and must be properly closed
  // `/foo/gim` - modifiers tail can be maximum 3 chars
  if (regexp[0] === '/') {
    if (tail) modifiers = tail[1];

    if (modifiers.length > 3) return false;
    // if expression starts with /, is should be properly terminated
    if (regexp[regexp.length - modifiers.length - 1] !== '/') return false;
  }

  return true;
}

function constructJavascriptRegExp(data) {
  var regexp = data,
      tail = /\/([gim]*)$/.exec(data),
      modifiers = '';

  // `/foo/gim` - tail can be maximum 4 chars
  if (regexp[0] === '/') {
    if (tail) modifiers = tail[1];
    regexp = regexp.slice(1, regexp.length - modifiers.length - 1);
  }

  return new RegExp(regexp, modifiers);
}

function representJavascriptRegExp(object /*, style*/) {
  var result = '/' + object.source + '/';

  if (object.global) result += 'g';
  if (object.multiline) result += 'm';
  if (object.ignoreCase) result += 'i';

  return result;
}

function isRegExp(object) {
  return Object.prototype.toString.call(object) === '[object RegExp]';
}

module.exports = new Type('tag:yaml.org,2002:js/regexp', {
  kind: 'scalar',
  resolve: resolveJavascriptRegExp,
  construct: constructJavascriptRegExp,
  predicate: isRegExp,
  represent: representJavascriptRegExp
});

/***/ }),
/* 156 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var require;

var esprima;

// Browserified version does not have esprima
//
// 1. For node.js just require module as deps
// 2. For browser try to require mudule via external AMD system.
//    If not found - try to fallback to window.esprima. If not
//    found too - then fail to parse.
//
try {
  // workaround to exclude package from browserify list.
  var _require = require;
  esprima = __webpack_require__(157);
} catch (_) {
  /*global window */
  if (typeof window !== 'undefined') esprima = window.esprima;
}

var Type = __webpack_require__(4);

function resolveJavascriptFunction(data) {
  if (data === null) return false;

  try {
    var source = '(' + data + ')',
        ast = esprima.parse(source, { range: true });

    if (ast.type !== 'Program' || ast.body.length !== 1 || ast.body[0].type !== 'ExpressionStatement' || ast.body[0].expression.type !== 'FunctionExpression') {
      return false;
    }

    return true;
  } catch (err) {
    return false;
  }
}

function constructJavascriptFunction(data) {
  /*jslint evil:true*/

  var source = '(' + data + ')',
      ast = esprima.parse(source, { range: true }),
      params = [],
      body;

  if (ast.type !== 'Program' || ast.body.length !== 1 || ast.body[0].type !== 'ExpressionStatement' || ast.body[0].expression.type !== 'FunctionExpression') {
    throw new Error('Failed to resolve function');
  }

  ast.body[0].expression.params.forEach(function (param) {
    params.push(param.name);
  });

  body = ast.body[0].expression.body.range;

  // Esprima's ranges include the first '{' and the last '}' characters on
  // function expressions. So cut them out.
  /*eslint-disable no-new-func*/
  return new Function(params, source.slice(body[0] + 1, body[1] - 1));
}

function representJavascriptFunction(object /*, style*/) {
  return object.toString();
}

function isFunction(object) {
  return Object.prototype.toString.call(object) === '[object Function]';
}

module.exports = new Type('tag:yaml.org,2002:js/function', {
  kind: 'scalar',
  resolve: resolveJavascriptFunction,
  construct: constructJavascriptFunction,
  predicate: isFunction,
  represent: representJavascriptFunction
});

/***/ }),
/* 157 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


(function webpackUniversalModuleDefinition(root, factory) {
	/* istanbul ignore next */
	if (true) module.exports = factory();else if (typeof define === 'function' && define.amd) define([], factory);
	/* istanbul ignore next */
	else if (typeof exports === 'object') exports["esprima"] = factory();else root["esprima"] = factory();
})(undefined, function () {
	return (/******/function (modules) {
			// webpackBootstrap
			/******/ // The module cache
			/******/var installedModules = {};

			/******/ // The require function
			/******/function __webpack_require__(moduleId) {

				/******/ // Check if module is in cache
				/* istanbul ignore if */
				/******/if (installedModules[moduleId])
					/******/return installedModules[moduleId].exports;

				/******/ // Create a new module (and put it into the cache)
				/******/var module = installedModules[moduleId] = {
					/******/exports: {},
					/******/id: moduleId,
					/******/loaded: false
					/******/ };

				/******/ // Execute the module function
				/******/modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);

				/******/ // Flag the module as loaded
				/******/module.loaded = true;

				/******/ // Return the exports of the module
				/******/return module.exports;
				/******/
			}

			/******/ // expose the modules object (__webpack_modules__)
			/******/__webpack_require__.m = modules;

			/******/ // expose the module cache
			/******/__webpack_require__.c = installedModules;

			/******/ // __webpack_public_path__
			/******/__webpack_require__.p = "";

			/******/ // Load entry module and return exports
			/******/return __webpack_require__(0);
			/******/
		}(
		/************************************************************************/
		/******/[
		/* 0 */
		/***/function (module, exports, __webpack_require__) {

			"use strict";
			/*
     Copyright JS Foundation and other contributors, https://js.foundation/
   
     Redistribution and use in source and binary forms, with or without
     modification, are permitted provided that the following conditions are met:
   
       * Redistributions of source code must retain the above copyright
         notice, this list of conditions and the following disclaimer.
       * Redistributions in binary form must reproduce the above copyright
         notice, this list of conditions and the following disclaimer in the
         documentation and/or other materials provided with the distribution.
   
     THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
     AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
     IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
     ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY
     DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
     (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
     LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
     ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
     (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
     THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
   */

			Object.defineProperty(exports, "__esModule", { value: true });
			var comment_handler_1 = __webpack_require__(1);
			var jsx_parser_1 = __webpack_require__(3);
			var parser_1 = __webpack_require__(8);
			var tokenizer_1 = __webpack_require__(15);
			function parse(code, options, delegate) {
				var commentHandler = null;
				var proxyDelegate = function (node, metadata) {
					if (delegate) {
						delegate(node, metadata);
					}
					if (commentHandler) {
						commentHandler.visit(node, metadata);
					}
				};
				var parserDelegate = typeof delegate === 'function' ? proxyDelegate : null;
				var collectComment = false;
				if (options) {
					collectComment = typeof options.comment === 'boolean' && options.comment;
					var attachComment = typeof options.attachComment === 'boolean' && options.attachComment;
					if (collectComment || attachComment) {
						commentHandler = new comment_handler_1.CommentHandler();
						commentHandler.attach = attachComment;
						options.comment = true;
						parserDelegate = proxyDelegate;
					}
				}
				var isModule = false;
				if (options && typeof options.sourceType === 'string') {
					isModule = options.sourceType === 'module';
				}
				var parser;
				if (options && typeof options.jsx === 'boolean' && options.jsx) {
					parser = new jsx_parser_1.JSXParser(code, options, parserDelegate);
				} else {
					parser = new parser_1.Parser(code, options, parserDelegate);
				}
				var program = isModule ? parser.parseModule() : parser.parseScript();
				var ast = program;
				if (collectComment && commentHandler) {
					ast.comments = commentHandler.comments;
				}
				if (parser.config.tokens) {
					ast.tokens = parser.tokens;
				}
				if (parser.config.tolerant) {
					ast.errors = parser.errorHandler.errors;
				}
				return ast;
			}
			exports.parse = parse;
			function parseModule(code, options, delegate) {
				var parsingOptions = options || {};
				parsingOptions.sourceType = 'module';
				return parse(code, parsingOptions, delegate);
			}
			exports.parseModule = parseModule;
			function parseScript(code, options, delegate) {
				var parsingOptions = options || {};
				parsingOptions.sourceType = 'script';
				return parse(code, parsingOptions, delegate);
			}
			exports.parseScript = parseScript;
			function tokenize(code, options, delegate) {
				var tokenizer = new tokenizer_1.Tokenizer(code, options);
				var tokens;
				tokens = [];
				try {
					while (true) {
						var token = tokenizer.getNextToken();
						if (!token) {
							break;
						}
						if (delegate) {
							token = delegate(token);
						}
						tokens.push(token);
					}
				} catch (e) {
					tokenizer.errorHandler.tolerate(e);
				}
				if (tokenizer.errorHandler.tolerant) {
					tokens.errors = tokenizer.errors();
				}
				return tokens;
			}
			exports.tokenize = tokenize;
			var syntax_1 = __webpack_require__(2);
			exports.Syntax = syntax_1.Syntax;
			// Sync with *.json manifests.
			exports.version = '4.0.0';

			/***/
		},
		/* 1 */
		/***/function (module, exports, __webpack_require__) {

			"use strict";

			Object.defineProperty(exports, "__esModule", { value: true });
			var syntax_1 = __webpack_require__(2);
			var CommentHandler = function () {
				function CommentHandler() {
					this.attach = false;
					this.comments = [];
					this.stack = [];
					this.leading = [];
					this.trailing = [];
				}
				CommentHandler.prototype.insertInnerComments = function (node, metadata) {
					//  innnerComments for properties empty block
					//  `function a() {/** comments **\/}`
					if (node.type === syntax_1.Syntax.BlockStatement && node.body.length === 0) {
						var innerComments = [];
						for (var i = this.leading.length - 1; i >= 0; --i) {
							var entry = this.leading[i];
							if (metadata.end.offset >= entry.start) {
								innerComments.unshift(entry.comment);
								this.leading.splice(i, 1);
								this.trailing.splice(i, 1);
							}
						}
						if (innerComments.length) {
							node.innerComments = innerComments;
						}
					}
				};
				CommentHandler.prototype.findTrailingComments = function (metadata) {
					var trailingComments = [];
					if (this.trailing.length > 0) {
						for (var i = this.trailing.length - 1; i >= 0; --i) {
							var entry_1 = this.trailing[i];
							if (entry_1.start >= metadata.end.offset) {
								trailingComments.unshift(entry_1.comment);
							}
						}
						this.trailing.length = 0;
						return trailingComments;
					}
					var entry = this.stack[this.stack.length - 1];
					if (entry && entry.node.trailingComments) {
						var firstComment = entry.node.trailingComments[0];
						if (firstComment && firstComment.range[0] >= metadata.end.offset) {
							trailingComments = entry.node.trailingComments;
							delete entry.node.trailingComments;
						}
					}
					return trailingComments;
				};
				CommentHandler.prototype.findLeadingComments = function (metadata) {
					var leadingComments = [];
					var target;
					while (this.stack.length > 0) {
						var entry = this.stack[this.stack.length - 1];
						if (entry && entry.start >= metadata.start.offset) {
							target = entry.node;
							this.stack.pop();
						} else {
							break;
						}
					}
					if (target) {
						var count = target.leadingComments ? target.leadingComments.length : 0;
						for (var i = count - 1; i >= 0; --i) {
							var comment = target.leadingComments[i];
							if (comment.range[1] <= metadata.start.offset) {
								leadingComments.unshift(comment);
								target.leadingComments.splice(i, 1);
							}
						}
						if (target.leadingComments && target.leadingComments.length === 0) {
							delete target.leadingComments;
						}
						return leadingComments;
					}
					for (var i = this.leading.length - 1; i >= 0; --i) {
						var entry = this.leading[i];
						if (entry.start <= metadata.start.offset) {
							leadingComments.unshift(entry.comment);
							this.leading.splice(i, 1);
						}
					}
					return leadingComments;
				};
				CommentHandler.prototype.visitNode = function (node, metadata) {
					if (node.type === syntax_1.Syntax.Program && node.body.length > 0) {
						return;
					}
					this.insertInnerComments(node, metadata);
					var trailingComments = this.findTrailingComments(metadata);
					var leadingComments = this.findLeadingComments(metadata);
					if (leadingComments.length > 0) {
						node.leadingComments = leadingComments;
					}
					if (trailingComments.length > 0) {
						node.trailingComments = trailingComments;
					}
					this.stack.push({
						node: node,
						start: metadata.start.offset
					});
				};
				CommentHandler.prototype.visitComment = function (node, metadata) {
					var type = node.type[0] === 'L' ? 'Line' : 'Block';
					var comment = {
						type: type,
						value: node.value
					};
					if (node.range) {
						comment.range = node.range;
					}
					if (node.loc) {
						comment.loc = node.loc;
					}
					this.comments.push(comment);
					if (this.attach) {
						var entry = {
							comment: {
								type: type,
								value: node.value,
								range: [metadata.start.offset, metadata.end.offset]
							},
							start: metadata.start.offset
						};
						if (node.loc) {
							entry.comment.loc = node.loc;
						}
						node.type = type;
						this.leading.push(entry);
						this.trailing.push(entry);
					}
				};
				CommentHandler.prototype.visit = function (node, metadata) {
					if (node.type === 'LineComment') {
						this.visitComment(node, metadata);
					} else if (node.type === 'BlockComment') {
						this.visitComment(node, metadata);
					} else if (this.attach) {
						this.visitNode(node, metadata);
					}
				};
				return CommentHandler;
			}();
			exports.CommentHandler = CommentHandler;

			/***/
		},
		/* 2 */
		/***/function (module, exports) {

			"use strict";

			Object.defineProperty(exports, "__esModule", { value: true });
			exports.Syntax = {
				AssignmentExpression: 'AssignmentExpression',
				AssignmentPattern: 'AssignmentPattern',
				ArrayExpression: 'ArrayExpression',
				ArrayPattern: 'ArrayPattern',
				ArrowFunctionExpression: 'ArrowFunctionExpression',
				AwaitExpression: 'AwaitExpression',
				BlockStatement: 'BlockStatement',
				BinaryExpression: 'BinaryExpression',
				BreakStatement: 'BreakStatement',
				CallExpression: 'CallExpression',
				CatchClause: 'CatchClause',
				ClassBody: 'ClassBody',
				ClassDeclaration: 'ClassDeclaration',
				ClassExpression: 'ClassExpression',
				ConditionalExpression: 'ConditionalExpression',
				ContinueStatement: 'ContinueStatement',
				DoWhileStatement: 'DoWhileStatement',
				DebuggerStatement: 'DebuggerStatement',
				EmptyStatement: 'EmptyStatement',
				ExportAllDeclaration: 'ExportAllDeclaration',
				ExportDefaultDeclaration: 'ExportDefaultDeclaration',
				ExportNamedDeclaration: 'ExportNamedDeclaration',
				ExportSpecifier: 'ExportSpecifier',
				ExpressionStatement: 'ExpressionStatement',
				ForStatement: 'ForStatement',
				ForOfStatement: 'ForOfStatement',
				ForInStatement: 'ForInStatement',
				FunctionDeclaration: 'FunctionDeclaration',
				FunctionExpression: 'FunctionExpression',
				Identifier: 'Identifier',
				IfStatement: 'IfStatement',
				ImportDeclaration: 'ImportDeclaration',
				ImportDefaultSpecifier: 'ImportDefaultSpecifier',
				ImportNamespaceSpecifier: 'ImportNamespaceSpecifier',
				ImportSpecifier: 'ImportSpecifier',
				Literal: 'Literal',
				LabeledStatement: 'LabeledStatement',
				LogicalExpression: 'LogicalExpression',
				MemberExpression: 'MemberExpression',
				MetaProperty: 'MetaProperty',
				MethodDefinition: 'MethodDefinition',
				NewExpression: 'NewExpression',
				ObjectExpression: 'ObjectExpression',
				ObjectPattern: 'ObjectPattern',
				Program: 'Program',
				Property: 'Property',
				RestElement: 'RestElement',
				ReturnStatement: 'ReturnStatement',
				SequenceExpression: 'SequenceExpression',
				SpreadElement: 'SpreadElement',
				Super: 'Super',
				SwitchCase: 'SwitchCase',
				SwitchStatement: 'SwitchStatement',
				TaggedTemplateExpression: 'TaggedTemplateExpression',
				TemplateElement: 'TemplateElement',
				TemplateLiteral: 'TemplateLiteral',
				ThisExpression: 'ThisExpression',
				ThrowStatement: 'ThrowStatement',
				TryStatement: 'TryStatement',
				UnaryExpression: 'UnaryExpression',
				UpdateExpression: 'UpdateExpression',
				VariableDeclaration: 'VariableDeclaration',
				VariableDeclarator: 'VariableDeclarator',
				WhileStatement: 'WhileStatement',
				WithStatement: 'WithStatement',
				YieldExpression: 'YieldExpression'
			};

			/***/
		},
		/* 3 */
		/***/function (module, exports, __webpack_require__) {

			"use strict";
			/* istanbul ignore next */

			var __extends = this && this.__extends || function () {
				var extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function (d, b) {
					d.__proto__ = b;
				} || function (d, b) {
					for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
				};
				return function (d, b) {
					extendStatics(d, b);
					function __() {
						this.constructor = d;
					}
					d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
				};
			}();
			Object.defineProperty(exports, "__esModule", { value: true });
			var character_1 = __webpack_require__(4);
			var JSXNode = __webpack_require__(5);
			var jsx_syntax_1 = __webpack_require__(6);
			var Node = __webpack_require__(7);
			var parser_1 = __webpack_require__(8);
			var token_1 = __webpack_require__(13);
			var xhtml_entities_1 = __webpack_require__(14);
			token_1.TokenName[100 /* Identifier */] = 'JSXIdentifier';
			token_1.TokenName[101 /* Text */] = 'JSXText';
			// Fully qualified element name, e.g. <svg:path> returns "svg:path"
			function getQualifiedElementName(elementName) {
				var qualifiedName;
				switch (elementName.type) {
					case jsx_syntax_1.JSXSyntax.JSXIdentifier:
						var id = elementName;
						qualifiedName = id.name;
						break;
					case jsx_syntax_1.JSXSyntax.JSXNamespacedName:
						var ns = elementName;
						qualifiedName = getQualifiedElementName(ns.namespace) + ':' + getQualifiedElementName(ns.name);
						break;
					case jsx_syntax_1.JSXSyntax.JSXMemberExpression:
						var expr = elementName;
						qualifiedName = getQualifiedElementName(expr.object) + '.' + getQualifiedElementName(expr.property);
						break;
					/* istanbul ignore next */
					default:
						break;
				}
				return qualifiedName;
			}
			var JSXParser = function (_super) {
				__extends(JSXParser, _super);
				function JSXParser(code, options, delegate) {
					return _super.call(this, code, options, delegate) || this;
				}
				JSXParser.prototype.parsePrimaryExpression = function () {
					return this.match('<') ? this.parseJSXRoot() : _super.prototype.parsePrimaryExpression.call(this);
				};
				JSXParser.prototype.startJSX = function () {
					// Unwind the scanner before the lookahead token.
					this.scanner.index = this.startMarker.index;
					this.scanner.lineNumber = this.startMarker.line;
					this.scanner.lineStart = this.startMarker.index - this.startMarker.column;
				};
				JSXParser.prototype.finishJSX = function () {
					// Prime the next lookahead.
					this.nextToken();
				};
				JSXParser.prototype.reenterJSX = function () {
					this.startJSX();
					this.expectJSX('}');
					// Pop the closing '}' added from the lookahead.
					if (this.config.tokens) {
						this.tokens.pop();
					}
				};
				JSXParser.prototype.createJSXNode = function () {
					this.collectComments();
					return {
						index: this.scanner.index,
						line: this.scanner.lineNumber,
						column: this.scanner.index - this.scanner.lineStart
					};
				};
				JSXParser.prototype.createJSXChildNode = function () {
					return {
						index: this.scanner.index,
						line: this.scanner.lineNumber,
						column: this.scanner.index - this.scanner.lineStart
					};
				};
				JSXParser.prototype.scanXHTMLEntity = function (quote) {
					var result = '&';
					var valid = true;
					var terminated = false;
					var numeric = false;
					var hex = false;
					while (!this.scanner.eof() && valid && !terminated) {
						var ch = this.scanner.source[this.scanner.index];
						if (ch === quote) {
							break;
						}
						terminated = ch === ';';
						result += ch;
						++this.scanner.index;
						if (!terminated) {
							switch (result.length) {
								case 2:
									// e.g. '&#123;'
									numeric = ch === '#';
									break;
								case 3:
									if (numeric) {
										// e.g. '&#x41;'
										hex = ch === 'x';
										valid = hex || character_1.Character.isDecimalDigit(ch.charCodeAt(0));
										numeric = numeric && !hex;
									}
									break;
								default:
									valid = valid && !(numeric && !character_1.Character.isDecimalDigit(ch.charCodeAt(0)));
									valid = valid && !(hex && !character_1.Character.isHexDigit(ch.charCodeAt(0)));
									break;
							}
						}
					}
					if (valid && terminated && result.length > 2) {
						// e.g. '&#x41;' becomes just '#x41'
						var str = result.substr(1, result.length - 2);
						if (numeric && str.length > 1) {
							result = String.fromCharCode(parseInt(str.substr(1), 10));
						} else if (hex && str.length > 2) {
							result = String.fromCharCode(parseInt('0' + str.substr(1), 16));
						} else if (!numeric && !hex && xhtml_entities_1.XHTMLEntities[str]) {
							result = xhtml_entities_1.XHTMLEntities[str];
						}
					}
					return result;
				};
				// Scan the next JSX token. This replaces Scanner#lex when in JSX mode.
				JSXParser.prototype.lexJSX = function () {
					var cp = this.scanner.source.charCodeAt(this.scanner.index);
					// < > / : = { }
					if (cp === 60 || cp === 62 || cp === 47 || cp === 58 || cp === 61 || cp === 123 || cp === 125) {
						var value = this.scanner.source[this.scanner.index++];
						return {
							type: 7 /* Punctuator */
							, value: value,
							lineNumber: this.scanner.lineNumber,
							lineStart: this.scanner.lineStart,
							start: this.scanner.index - 1,
							end: this.scanner.index
						};
					}
					// " '
					if (cp === 34 || cp === 39) {
						var start = this.scanner.index;
						var quote = this.scanner.source[this.scanner.index++];
						var str = '';
						while (!this.scanner.eof()) {
							var ch = this.scanner.source[this.scanner.index++];
							if (ch === quote) {
								break;
							} else if (ch === '&') {
								str += this.scanXHTMLEntity(quote);
							} else {
								str += ch;
							}
						}
						return {
							type: 8 /* StringLiteral */
							, value: str,
							lineNumber: this.scanner.lineNumber,
							lineStart: this.scanner.lineStart,
							start: start,
							end: this.scanner.index
						};
					}
					// ... or .
					if (cp === 46) {
						var n1 = this.scanner.source.charCodeAt(this.scanner.index + 1);
						var n2 = this.scanner.source.charCodeAt(this.scanner.index + 2);
						var value = n1 === 46 && n2 === 46 ? '...' : '.';
						var start = this.scanner.index;
						this.scanner.index += value.length;
						return {
							type: 7 /* Punctuator */
							, value: value,
							lineNumber: this.scanner.lineNumber,
							lineStart: this.scanner.lineStart,
							start: start,
							end: this.scanner.index
						};
					}
					// `
					if (cp === 96) {
						// Only placeholder, since it will be rescanned as a real assignment expression.
						return {
							type: 10 /* Template */
							, value: '',
							lineNumber: this.scanner.lineNumber,
							lineStart: this.scanner.lineStart,
							start: this.scanner.index,
							end: this.scanner.index
						};
					}
					// Identifer can not contain backslash (char code 92).
					if (character_1.Character.isIdentifierStart(cp) && cp !== 92) {
						var start = this.scanner.index;
						++this.scanner.index;
						while (!this.scanner.eof()) {
							var ch = this.scanner.source.charCodeAt(this.scanner.index);
							if (character_1.Character.isIdentifierPart(ch) && ch !== 92) {
								++this.scanner.index;
							} else if (ch === 45) {
								// Hyphen (char code 45) can be part of an identifier.
								++this.scanner.index;
							} else {
								break;
							}
						}
						var id = this.scanner.source.slice(start, this.scanner.index);
						return {
							type: 100 /* Identifier */
							, value: id,
							lineNumber: this.scanner.lineNumber,
							lineStart: this.scanner.lineStart,
							start: start,
							end: this.scanner.index
						};
					}
					return this.scanner.lex();
				};
				JSXParser.prototype.nextJSXToken = function () {
					this.collectComments();
					this.startMarker.index = this.scanner.index;
					this.startMarker.line = this.scanner.lineNumber;
					this.startMarker.column = this.scanner.index - this.scanner.lineStart;
					var token = this.lexJSX();
					this.lastMarker.index = this.scanner.index;
					this.lastMarker.line = this.scanner.lineNumber;
					this.lastMarker.column = this.scanner.index - this.scanner.lineStart;
					if (this.config.tokens) {
						this.tokens.push(this.convertToken(token));
					}
					return token;
				};
				JSXParser.prototype.nextJSXText = function () {
					this.startMarker.index = this.scanner.index;
					this.startMarker.line = this.scanner.lineNumber;
					this.startMarker.column = this.scanner.index - this.scanner.lineStart;
					var start = this.scanner.index;
					var text = '';
					while (!this.scanner.eof()) {
						var ch = this.scanner.source[this.scanner.index];
						if (ch === '{' || ch === '<') {
							break;
						}
						++this.scanner.index;
						text += ch;
						if (character_1.Character.isLineTerminator(ch.charCodeAt(0))) {
							++this.scanner.lineNumber;
							if (ch === '\r' && this.scanner.source[this.scanner.index] === '\n') {
								++this.scanner.index;
							}
							this.scanner.lineStart = this.scanner.index;
						}
					}
					this.lastMarker.index = this.scanner.index;
					this.lastMarker.line = this.scanner.lineNumber;
					this.lastMarker.column = this.scanner.index - this.scanner.lineStart;
					var token = {
						type: 101 /* Text */
						, value: text,
						lineNumber: this.scanner.lineNumber,
						lineStart: this.scanner.lineStart,
						start: start,
						end: this.scanner.index
					};
					if (text.length > 0 && this.config.tokens) {
						this.tokens.push(this.convertToken(token));
					}
					return token;
				};
				JSXParser.prototype.peekJSXToken = function () {
					var state = this.scanner.saveState();
					this.scanner.scanComments();
					var next = this.lexJSX();
					this.scanner.restoreState(state);
					return next;
				};
				// Expect the next JSX token to match the specified punctuator.
				// If not, an exception will be thrown.
				JSXParser.prototype.expectJSX = function (value) {
					var token = this.nextJSXToken();
					if (token.type !== 7 /* Punctuator */ || token.value !== value) {
						this.throwUnexpectedToken(token);
					}
				};
				// Return true if the next JSX token matches the specified punctuator.
				JSXParser.prototype.matchJSX = function (value) {
					var next = this.peekJSXToken();
					return next.type === 7 /* Punctuator */ && next.value === value;
				};
				JSXParser.prototype.parseJSXIdentifier = function () {
					var node = this.createJSXNode();
					var token = this.nextJSXToken();
					if (token.type !== 100 /* Identifier */) {
							this.throwUnexpectedToken(token);
						}
					return this.finalize(node, new JSXNode.JSXIdentifier(token.value));
				};
				JSXParser.prototype.parseJSXElementName = function () {
					var node = this.createJSXNode();
					var elementName = this.parseJSXIdentifier();
					if (this.matchJSX(':')) {
						var namespace = elementName;
						this.expectJSX(':');
						var name_1 = this.parseJSXIdentifier();
						elementName = this.finalize(node, new JSXNode.JSXNamespacedName(namespace, name_1));
					} else if (this.matchJSX('.')) {
						while (this.matchJSX('.')) {
							var object = elementName;
							this.expectJSX('.');
							var property = this.parseJSXIdentifier();
							elementName = this.finalize(node, new JSXNode.JSXMemberExpression(object, property));
						}
					}
					return elementName;
				};
				JSXParser.prototype.parseJSXAttributeName = function () {
					var node = this.createJSXNode();
					var attributeName;
					var identifier = this.parseJSXIdentifier();
					if (this.matchJSX(':')) {
						var namespace = identifier;
						this.expectJSX(':');
						var name_2 = this.parseJSXIdentifier();
						attributeName = this.finalize(node, new JSXNode.JSXNamespacedName(namespace, name_2));
					} else {
						attributeName = identifier;
					}
					return attributeName;
				};
				JSXParser.prototype.parseJSXStringLiteralAttribute = function () {
					var node = this.createJSXNode();
					var token = this.nextJSXToken();
					if (token.type !== 8 /* StringLiteral */) {
							this.throwUnexpectedToken(token);
						}
					var raw = this.getTokenRaw(token);
					return this.finalize(node, new Node.Literal(token.value, raw));
				};
				JSXParser.prototype.parseJSXExpressionAttribute = function () {
					var node = this.createJSXNode();
					this.expectJSX('{');
					this.finishJSX();
					if (this.match('}')) {
						this.tolerateError('JSX attributes must only be assigned a non-empty expression');
					}
					var expression = this.parseAssignmentExpression();
					this.reenterJSX();
					return this.finalize(node, new JSXNode.JSXExpressionContainer(expression));
				};
				JSXParser.prototype.parseJSXAttributeValue = function () {
					return this.matchJSX('{') ? this.parseJSXExpressionAttribute() : this.matchJSX('<') ? this.parseJSXElement() : this.parseJSXStringLiteralAttribute();
				};
				JSXParser.prototype.parseJSXNameValueAttribute = function () {
					var node = this.createJSXNode();
					var name = this.parseJSXAttributeName();
					var value = null;
					if (this.matchJSX('=')) {
						this.expectJSX('=');
						value = this.parseJSXAttributeValue();
					}
					return this.finalize(node, new JSXNode.JSXAttribute(name, value));
				};
				JSXParser.prototype.parseJSXSpreadAttribute = function () {
					var node = this.createJSXNode();
					this.expectJSX('{');
					this.expectJSX('...');
					this.finishJSX();
					var argument = this.parseAssignmentExpression();
					this.reenterJSX();
					return this.finalize(node, new JSXNode.JSXSpreadAttribute(argument));
				};
				JSXParser.prototype.parseJSXAttributes = function () {
					var attributes = [];
					while (!this.matchJSX('/') && !this.matchJSX('>')) {
						var attribute = this.matchJSX('{') ? this.parseJSXSpreadAttribute() : this.parseJSXNameValueAttribute();
						attributes.push(attribute);
					}
					return attributes;
				};
				JSXParser.prototype.parseJSXOpeningElement = function () {
					var node = this.createJSXNode();
					this.expectJSX('<');
					var name = this.parseJSXElementName();
					var attributes = this.parseJSXAttributes();
					var selfClosing = this.matchJSX('/');
					if (selfClosing) {
						this.expectJSX('/');
					}
					this.expectJSX('>');
					return this.finalize(node, new JSXNode.JSXOpeningElement(name, selfClosing, attributes));
				};
				JSXParser.prototype.parseJSXBoundaryElement = function () {
					var node = this.createJSXNode();
					this.expectJSX('<');
					if (this.matchJSX('/')) {
						this.expectJSX('/');
						var name_3 = this.parseJSXElementName();
						this.expectJSX('>');
						return this.finalize(node, new JSXNode.JSXClosingElement(name_3));
					}
					var name = this.parseJSXElementName();
					var attributes = this.parseJSXAttributes();
					var selfClosing = this.matchJSX('/');
					if (selfClosing) {
						this.expectJSX('/');
					}
					this.expectJSX('>');
					return this.finalize(node, new JSXNode.JSXOpeningElement(name, selfClosing, attributes));
				};
				JSXParser.prototype.parseJSXEmptyExpression = function () {
					var node = this.createJSXChildNode();
					this.collectComments();
					this.lastMarker.index = this.scanner.index;
					this.lastMarker.line = this.scanner.lineNumber;
					this.lastMarker.column = this.scanner.index - this.scanner.lineStart;
					return this.finalize(node, new JSXNode.JSXEmptyExpression());
				};
				JSXParser.prototype.parseJSXExpressionContainer = function () {
					var node = this.createJSXNode();
					this.expectJSX('{');
					var expression;
					if (this.matchJSX('}')) {
						expression = this.parseJSXEmptyExpression();
						this.expectJSX('}');
					} else {
						this.finishJSX();
						expression = this.parseAssignmentExpression();
						this.reenterJSX();
					}
					return this.finalize(node, new JSXNode.JSXExpressionContainer(expression));
				};
				JSXParser.prototype.parseJSXChildren = function () {
					var children = [];
					while (!this.scanner.eof()) {
						var node = this.createJSXChildNode();
						var token = this.nextJSXText();
						if (token.start < token.end) {
							var raw = this.getTokenRaw(token);
							var child = this.finalize(node, new JSXNode.JSXText(token.value, raw));
							children.push(child);
						}
						if (this.scanner.source[this.scanner.index] === '{') {
							var container = this.parseJSXExpressionContainer();
							children.push(container);
						} else {
							break;
						}
					}
					return children;
				};
				JSXParser.prototype.parseComplexJSXElement = function (el) {
					var stack = [];
					while (!this.scanner.eof()) {
						el.children = el.children.concat(this.parseJSXChildren());
						var node = this.createJSXChildNode();
						var element = this.parseJSXBoundaryElement();
						if (element.type === jsx_syntax_1.JSXSyntax.JSXOpeningElement) {
							var opening = element;
							if (opening.selfClosing) {
								var child = this.finalize(node, new JSXNode.JSXElement(opening, [], null));
								el.children.push(child);
							} else {
								stack.push(el);
								el = { node: node, opening: opening, closing: null, children: [] };
							}
						}
						if (element.type === jsx_syntax_1.JSXSyntax.JSXClosingElement) {
							el.closing = element;
							var open_1 = getQualifiedElementName(el.opening.name);
							var close_1 = getQualifiedElementName(el.closing.name);
							if (open_1 !== close_1) {
								this.tolerateError('Expected corresponding JSX closing tag for %0', open_1);
							}
							if (stack.length > 0) {
								var child = this.finalize(el.node, new JSXNode.JSXElement(el.opening, el.children, el.closing));
								el = stack[stack.length - 1];
								el.children.push(child);
								stack.pop();
							} else {
								break;
							}
						}
					}
					return el;
				};
				JSXParser.prototype.parseJSXElement = function () {
					var node = this.createJSXNode();
					var opening = this.parseJSXOpeningElement();
					var children = [];
					var closing = null;
					if (!opening.selfClosing) {
						var el = this.parseComplexJSXElement({ node: node, opening: opening, closing: closing, children: children });
						children = el.children;
						closing = el.closing;
					}
					return this.finalize(node, new JSXNode.JSXElement(opening, children, closing));
				};
				JSXParser.prototype.parseJSXRoot = function () {
					// Pop the opening '<' added from the lookahead.
					if (this.config.tokens) {
						this.tokens.pop();
					}
					this.startJSX();
					var element = this.parseJSXElement();
					this.finishJSX();
					return element;
				};
				JSXParser.prototype.isStartOfExpression = function () {
					return _super.prototype.isStartOfExpression.call(this) || this.match('<');
				};
				return JSXParser;
			}(parser_1.Parser);
			exports.JSXParser = JSXParser;

			/***/
		},
		/* 4 */
		/***/function (module, exports) {

			"use strict";

			Object.defineProperty(exports, "__esModule", { value: true });
			// See also tools/generate-unicode-regex.js.
			var Regex = {
				// Unicode v8.0.0 NonAsciiIdentifierStart:
				NonAsciiIdentifierStart: /[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u05D0-\u05EA\u05F0-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u08A0-\u08B4\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C60\u0C61\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1877\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF5\u1CF6\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309B-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FD5\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AD\uA7B0-\uA7B7\uA7F7-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD40-\uDD74\uDE80-\uDE9C\uDEA0-\uDED0\uDF00-\uDF1F\uDF30-\uDF4A\uDF50-\uDF75\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00\uDE10-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE4\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2]|\uD804[\uDC03-\uDC37\uDC83-\uDCAF\uDCD0-\uDCE8\uDD03-\uDD26\uDD50-\uDD72\uDD76\uDD83-\uDDB2\uDDC1-\uDDC4\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE2B\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEDE\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3D\uDF50\uDF5D-\uDF61]|\uD805[\uDC80-\uDCAF\uDCC4\uDCC5\uDCC7\uDD80-\uDDAE\uDDD8-\uDDDB\uDE00-\uDE2F\uDE44\uDE80-\uDEAA\uDF00-\uDF19]|\uD806[\uDCA0-\uDCDF\uDCFF\uDEC0-\uDEF8]|\uD808[\uDC00-\uDF99]|\uD809[\uDC00-\uDC6E\uDC80-\uDD43]|[\uD80C\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDED0-\uDEED\uDF00-\uDF2F\uDF40-\uDF43\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDF00-\uDF44\uDF50\uDF93-\uDF9F]|\uD82C[\uDC00\uDC01]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB]|\uD83A[\uDC00-\uDCC4]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1]|\uD87E[\uDC00-\uDE1D]/,
				// Unicode v8.0.0 NonAsciiIdentifierPart:
				NonAsciiIdentifierPart: /[\xAA\xB5\xB7\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0300-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u0483-\u0487\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u05D0-\u05EA\u05F0-\u05F2\u0610-\u061A\u0620-\u0669\u066E-\u06D3\u06D5-\u06DC\u06DF-\u06E8\u06EA-\u06FC\u06FF\u0710-\u074A\u074D-\u07B1\u07C0-\u07F5\u07FA\u0800-\u082D\u0840-\u085B\u08A0-\u08B4\u08E3-\u0963\u0966-\u096F\u0971-\u0983\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BC-\u09C4\u09C7\u09C8\u09CB-\u09CE\u09D7\u09DC\u09DD\u09DF-\u09E3\u09E6-\u09F1\u0A01-\u0A03\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A59-\u0A5C\u0A5E\u0A66-\u0A75\u0A81-\u0A83\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABC-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AD0\u0AE0-\u0AE3\u0AE6-\u0AEF\u0AF9\u0B01-\u0B03\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3C-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B56\u0B57\u0B5C\u0B5D\u0B5F-\u0B63\u0B66-\u0B6F\u0B71\u0B82\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD0\u0BD7\u0BE6-\u0BEF\u0C00-\u0C03\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C58-\u0C5A\u0C60-\u0C63\u0C66-\u0C6F\u0C81-\u0C83\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBC-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CDE\u0CE0-\u0CE3\u0CE6-\u0CEF\u0CF1\u0CF2\u0D01-\u0D03\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D-\u0D44\u0D46-\u0D48\u0D4A-\u0D4E\u0D57\u0D5F-\u0D63\u0D66-\u0D6F\u0D7A-\u0D7F\u0D82\u0D83\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E01-\u0E3A\u0E40-\u0E4E\u0E50-\u0E59\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB9\u0EBB-\u0EBD\u0EC0-\u0EC4\u0EC6\u0EC8-\u0ECD\u0ED0-\u0ED9\u0EDC-\u0EDF\u0F00\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E-\u0F47\u0F49-\u0F6C\u0F71-\u0F84\u0F86-\u0F97\u0F99-\u0FBC\u0FC6\u1000-\u1049\u1050-\u109D\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u135D-\u135F\u1369-\u1371\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1714\u1720-\u1734\u1740-\u1753\u1760-\u176C\u176E-\u1770\u1772\u1773\u1780-\u17D3\u17D7\u17DC\u17DD\u17E0-\u17E9\u180B-\u180D\u1810-\u1819\u1820-\u1877\u1880-\u18AA\u18B0-\u18F5\u1900-\u191E\u1920-\u192B\u1930-\u193B\u1946-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u19D0-\u19DA\u1A00-\u1A1B\u1A20-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AA7\u1AB0-\u1ABD\u1B00-\u1B4B\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1BF3\u1C00-\u1C37\u1C40-\u1C49\u1C4D-\u1C7D\u1CD0-\u1CD2\u1CD4-\u1CF6\u1CF8\u1CF9\u1D00-\u1DF5\u1DFC-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u200C\u200D\u203F\u2040\u2054\u2071\u207F\u2090-\u209C\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D7F-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2DE0-\u2DFF\u3005-\u3007\u3021-\u302F\u3031-\u3035\u3038-\u303C\u3041-\u3096\u3099-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FD5\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA62B\uA640-\uA66F\uA674-\uA67D\uA67F-\uA6F1\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AD\uA7B0-\uA7B7\uA7F7-\uA827\uA840-\uA873\uA880-\uA8C4\uA8D0-\uA8D9\uA8E0-\uA8F7\uA8FB\uA8FD\uA900-\uA92D\uA930-\uA953\uA960-\uA97C\uA980-\uA9C0\uA9CF-\uA9D9\uA9E0-\uA9FE\uAA00-\uAA36\uAA40-\uAA4D\uAA50-\uAA59\uAA60-\uAA76\uAA7A-\uAAC2\uAADB-\uAADD\uAAE0-\uAAEF\uAAF2-\uAAF6\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABEA\uABEC\uABED\uABF0-\uABF9\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE00-\uFE0F\uFE20-\uFE2F\uFE33\uFE34\uFE4D-\uFE4F\uFE70-\uFE74\uFE76-\uFEFC\uFF10-\uFF19\uFF21-\uFF3A\uFF3F\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD40-\uDD74\uDDFD\uDE80-\uDE9C\uDEA0-\uDED0\uDEE0\uDF00-\uDF1F\uDF30-\uDF4A\uDF50-\uDF7A\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDCA0-\uDCA9\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00-\uDE03\uDE05\uDE06\uDE0C-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE38-\uDE3A\uDE3F\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE6\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2]|\uD804[\uDC00-\uDC46\uDC66-\uDC6F\uDC7F-\uDCBA\uDCD0-\uDCE8\uDCF0-\uDCF9\uDD00-\uDD34\uDD36-\uDD3F\uDD50-\uDD73\uDD76\uDD80-\uDDC4\uDDCA-\uDDCC\uDDD0-\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE37\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEEA\uDEF0-\uDEF9\uDF00-\uDF03\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3C-\uDF44\uDF47\uDF48\uDF4B-\uDF4D\uDF50\uDF57\uDF5D-\uDF63\uDF66-\uDF6C\uDF70-\uDF74]|\uD805[\uDC80-\uDCC5\uDCC7\uDCD0-\uDCD9\uDD80-\uDDB5\uDDB8-\uDDC0\uDDD8-\uDDDD\uDE00-\uDE40\uDE44\uDE50-\uDE59\uDE80-\uDEB7\uDEC0-\uDEC9\uDF00-\uDF19\uDF1D-\uDF2B\uDF30-\uDF39]|\uD806[\uDCA0-\uDCE9\uDCFF\uDEC0-\uDEF8]|\uD808[\uDC00-\uDF99]|\uD809[\uDC00-\uDC6E\uDC80-\uDD43]|[\uD80C\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDE60-\uDE69\uDED0-\uDEED\uDEF0-\uDEF4\uDF00-\uDF36\uDF40-\uDF43\uDF50-\uDF59\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDF00-\uDF44\uDF50-\uDF7E\uDF8F-\uDF9F]|\uD82C[\uDC00\uDC01]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99\uDC9D\uDC9E]|\uD834[\uDD65-\uDD69\uDD6D-\uDD72\uDD7B-\uDD82\uDD85-\uDD8B\uDDAA-\uDDAD\uDE42-\uDE44]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB\uDFCE-\uDFFF]|\uD836[\uDE00-\uDE36\uDE3B-\uDE6C\uDE75\uDE84\uDE9B-\uDE9F\uDEA1-\uDEAF]|\uD83A[\uDC00-\uDCC4\uDCD0-\uDCD6]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1]|\uD87E[\uDC00-\uDE1D]|\uDB40[\uDD00-\uDDEF]/
			};
			exports.Character = {
				/* tslint:disable:no-bitwise */
				fromCodePoint: function (cp) {
					return cp < 0x10000 ? String.fromCharCode(cp) : String.fromCharCode(0xD800 + (cp - 0x10000 >> 10)) + String.fromCharCode(0xDC00 + (cp - 0x10000 & 1023));
				},
				// https://tc39.github.io/ecma262/#sec-white-space
				isWhiteSpace: function (cp) {
					return cp === 0x20 || cp === 0x09 || cp === 0x0B || cp === 0x0C || cp === 0xA0 || cp >= 0x1680 && [0x1680, 0x2000, 0x2001, 0x2002, 0x2003, 0x2004, 0x2005, 0x2006, 0x2007, 0x2008, 0x2009, 0x200A, 0x202F, 0x205F, 0x3000, 0xFEFF].indexOf(cp) >= 0;
				},
				// https://tc39.github.io/ecma262/#sec-line-terminators
				isLineTerminator: function (cp) {
					return cp === 0x0A || cp === 0x0D || cp === 0x2028 || cp === 0x2029;
				},
				// https://tc39.github.io/ecma262/#sec-names-and-keywords
				isIdentifierStart: function (cp) {
					return cp === 0x24 || cp === 0x5F || cp >= 0x41 && cp <= 0x5A || cp >= 0x61 && cp <= 0x7A || cp === 0x5C || cp >= 0x80 && Regex.NonAsciiIdentifierStart.test(exports.Character.fromCodePoint(cp));
				},
				isIdentifierPart: function (cp) {
					return cp === 0x24 || cp === 0x5F || cp >= 0x41 && cp <= 0x5A || cp >= 0x61 && cp <= 0x7A || cp >= 0x30 && cp <= 0x39 || cp === 0x5C || cp >= 0x80 && Regex.NonAsciiIdentifierPart.test(exports.Character.fromCodePoint(cp));
				},
				// https://tc39.github.io/ecma262/#sec-literals-numeric-literals
				isDecimalDigit: function (cp) {
					return cp >= 0x30 && cp <= 0x39; // 0..9
				},
				isHexDigit: function (cp) {
					return cp >= 0x30 && cp <= 0x39 || cp >= 0x41 && cp <= 0x46 || cp >= 0x61 && cp <= 0x66; // a..f
				},
				isOctalDigit: function (cp) {
					return cp >= 0x30 && cp <= 0x37; // 0..7
				}
			};

			/***/
		},
		/* 5 */
		/***/function (module, exports, __webpack_require__) {

			"use strict";

			Object.defineProperty(exports, "__esModule", { value: true });
			var jsx_syntax_1 = __webpack_require__(6);
			/* tslint:disable:max-classes-per-file */
			var JSXClosingElement = function () {
				function JSXClosingElement(name) {
					this.type = jsx_syntax_1.JSXSyntax.JSXClosingElement;
					this.name = name;
				}
				return JSXClosingElement;
			}();
			exports.JSXClosingElement = JSXClosingElement;
			var JSXElement = function () {
				function JSXElement(openingElement, children, closingElement) {
					this.type = jsx_syntax_1.JSXSyntax.JSXElement;
					this.openingElement = openingElement;
					this.children = children;
					this.closingElement = closingElement;
				}
				return JSXElement;
			}();
			exports.JSXElement = JSXElement;
			var JSXEmptyExpression = function () {
				function JSXEmptyExpression() {
					this.type = jsx_syntax_1.JSXSyntax.JSXEmptyExpression;
				}
				return JSXEmptyExpression;
			}();
			exports.JSXEmptyExpression = JSXEmptyExpression;
			var JSXExpressionContainer = function () {
				function JSXExpressionContainer(expression) {
					this.type = jsx_syntax_1.JSXSyntax.JSXExpressionContainer;
					this.expression = expression;
				}
				return JSXExpressionContainer;
			}();
			exports.JSXExpressionContainer = JSXExpressionContainer;
			var JSXIdentifier = function () {
				function JSXIdentifier(name) {
					this.type = jsx_syntax_1.JSXSyntax.JSXIdentifier;
					this.name = name;
				}
				return JSXIdentifier;
			}();
			exports.JSXIdentifier = JSXIdentifier;
			var JSXMemberExpression = function () {
				function JSXMemberExpression(object, property) {
					this.type = jsx_syntax_1.JSXSyntax.JSXMemberExpression;
					this.object = object;
					this.property = property;
				}
				return JSXMemberExpression;
			}();
			exports.JSXMemberExpression = JSXMemberExpression;
			var JSXAttribute = function () {
				function JSXAttribute(name, value) {
					this.type = jsx_syntax_1.JSXSyntax.JSXAttribute;
					this.name = name;
					this.value = value;
				}
				return JSXAttribute;
			}();
			exports.JSXAttribute = JSXAttribute;
			var JSXNamespacedName = function () {
				function JSXNamespacedName(namespace, name) {
					this.type = jsx_syntax_1.JSXSyntax.JSXNamespacedName;
					this.namespace = namespace;
					this.name = name;
				}
				return JSXNamespacedName;
			}();
			exports.JSXNamespacedName = JSXNamespacedName;
			var JSXOpeningElement = function () {
				function JSXOpeningElement(name, selfClosing, attributes) {
					this.type = jsx_syntax_1.JSXSyntax.JSXOpeningElement;
					this.name = name;
					this.selfClosing = selfClosing;
					this.attributes = attributes;
				}
				return JSXOpeningElement;
			}();
			exports.JSXOpeningElement = JSXOpeningElement;
			var JSXSpreadAttribute = function () {
				function JSXSpreadAttribute(argument) {
					this.type = jsx_syntax_1.JSXSyntax.JSXSpreadAttribute;
					this.argument = argument;
				}
				return JSXSpreadAttribute;
			}();
			exports.JSXSpreadAttribute = JSXSpreadAttribute;
			var JSXText = function () {
				function JSXText(value, raw) {
					this.type = jsx_syntax_1.JSXSyntax.JSXText;
					this.value = value;
					this.raw = raw;
				}
				return JSXText;
			}();
			exports.JSXText = JSXText;

			/***/
		},
		/* 6 */
		/***/function (module, exports) {

			"use strict";

			Object.defineProperty(exports, "__esModule", { value: true });
			exports.JSXSyntax = {
				JSXAttribute: 'JSXAttribute',
				JSXClosingElement: 'JSXClosingElement',
				JSXElement: 'JSXElement',
				JSXEmptyExpression: 'JSXEmptyExpression',
				JSXExpressionContainer: 'JSXExpressionContainer',
				JSXIdentifier: 'JSXIdentifier',
				JSXMemberExpression: 'JSXMemberExpression',
				JSXNamespacedName: 'JSXNamespacedName',
				JSXOpeningElement: 'JSXOpeningElement',
				JSXSpreadAttribute: 'JSXSpreadAttribute',
				JSXText: 'JSXText'
			};

			/***/
		},
		/* 7 */
		/***/function (module, exports, __webpack_require__) {

			"use strict";

			Object.defineProperty(exports, "__esModule", { value: true });
			var syntax_1 = __webpack_require__(2);
			/* tslint:disable:max-classes-per-file */
			var ArrayExpression = function () {
				function ArrayExpression(elements) {
					this.type = syntax_1.Syntax.ArrayExpression;
					this.elements = elements;
				}
				return ArrayExpression;
			}();
			exports.ArrayExpression = ArrayExpression;
			var ArrayPattern = function () {
				function ArrayPattern(elements) {
					this.type = syntax_1.Syntax.ArrayPattern;
					this.elements = elements;
				}
				return ArrayPattern;
			}();
			exports.ArrayPattern = ArrayPattern;
			var ArrowFunctionExpression = function () {
				function ArrowFunctionExpression(params, body, expression) {
					this.type = syntax_1.Syntax.ArrowFunctionExpression;
					this.id = null;
					this.params = params;
					this.body = body;
					this.generator = false;
					this.expression = expression;
					this.async = false;
				}
				return ArrowFunctionExpression;
			}();
			exports.ArrowFunctionExpression = ArrowFunctionExpression;
			var AssignmentExpression = function () {
				function AssignmentExpression(operator, left, right) {
					this.type = syntax_1.Syntax.AssignmentExpression;
					this.operator = operator;
					this.left = left;
					this.right = right;
				}
				return AssignmentExpression;
			}();
			exports.AssignmentExpression = AssignmentExpression;
			var AssignmentPattern = function () {
				function AssignmentPattern(left, right) {
					this.type = syntax_1.Syntax.AssignmentPattern;
					this.left = left;
					this.right = right;
				}
				return AssignmentPattern;
			}();
			exports.AssignmentPattern = AssignmentPattern;
			var AsyncArrowFunctionExpression = function () {
				function AsyncArrowFunctionExpression(params, body, expression) {
					this.type = syntax_1.Syntax.ArrowFunctionExpression;
					this.id = null;
					this.params = params;
					this.body = body;
					this.generator = false;
					this.expression = expression;
					this.async = true;
				}
				return AsyncArrowFunctionExpression;
			}();
			exports.AsyncArrowFunctionExpression = AsyncArrowFunctionExpression;
			var AsyncFunctionDeclaration = function () {
				function AsyncFunctionDeclaration(id, params, body) {
					this.type = syntax_1.Syntax.FunctionDeclaration;
					this.id = id;
					this.params = params;
					this.body = body;
					this.generator = false;
					this.expression = false;
					this.async = true;
				}
				return AsyncFunctionDeclaration;
			}();
			exports.AsyncFunctionDeclaration = AsyncFunctionDeclaration;
			var AsyncFunctionExpression = function () {
				function AsyncFunctionExpression(id, params, body) {
					this.type = syntax_1.Syntax.FunctionExpression;
					this.id = id;
					this.params = params;
					this.body = body;
					this.generator = false;
					this.expression = false;
					this.async = true;
				}
				return AsyncFunctionExpression;
			}();
			exports.AsyncFunctionExpression = AsyncFunctionExpression;
			var AwaitExpression = function () {
				function AwaitExpression(argument) {
					this.type = syntax_1.Syntax.AwaitExpression;
					this.argument = argument;
				}
				return AwaitExpression;
			}();
			exports.AwaitExpression = AwaitExpression;
			var BinaryExpression = function () {
				function BinaryExpression(operator, left, right) {
					var logical = operator === '||' || operator === '&&';
					this.type = logical ? syntax_1.Syntax.LogicalExpression : syntax_1.Syntax.BinaryExpression;
					this.operator = operator;
					this.left = left;
					this.right = right;
				}
				return BinaryExpression;
			}();
			exports.BinaryExpression = BinaryExpression;
			var BlockStatement = function () {
				function BlockStatement(body) {
					this.type = syntax_1.Syntax.BlockStatement;
					this.body = body;
				}
				return BlockStatement;
			}();
			exports.BlockStatement = BlockStatement;
			var BreakStatement = function () {
				function BreakStatement(label) {
					this.type = syntax_1.Syntax.BreakStatement;
					this.label = label;
				}
				return BreakStatement;
			}();
			exports.BreakStatement = BreakStatement;
			var CallExpression = function () {
				function CallExpression(callee, args) {
					this.type = syntax_1.Syntax.CallExpression;
					this.callee = callee;
					this.arguments = args;
				}
				return CallExpression;
			}();
			exports.CallExpression = CallExpression;
			var CatchClause = function () {
				function CatchClause(param, body) {
					this.type = syntax_1.Syntax.CatchClause;
					this.param = param;
					this.body = body;
				}
				return CatchClause;
			}();
			exports.CatchClause = CatchClause;
			var ClassBody = function () {
				function ClassBody(body) {
					this.type = syntax_1.Syntax.ClassBody;
					this.body = body;
				}
				return ClassBody;
			}();
			exports.ClassBody = ClassBody;
			var ClassDeclaration = function () {
				function ClassDeclaration(id, superClass, body) {
					this.type = syntax_1.Syntax.ClassDeclaration;
					this.id = id;
					this.superClass = superClass;
					this.body = body;
				}
				return ClassDeclaration;
			}();
			exports.ClassDeclaration = ClassDeclaration;
			var ClassExpression = function () {
				function ClassExpression(id, superClass, body) {
					this.type = syntax_1.Syntax.ClassExpression;
					this.id = id;
					this.superClass = superClass;
					this.body = body;
				}
				return ClassExpression;
			}();
			exports.ClassExpression = ClassExpression;
			var ComputedMemberExpression = function () {
				function ComputedMemberExpression(object, property) {
					this.type = syntax_1.Syntax.MemberExpression;
					this.computed = true;
					this.object = object;
					this.property = property;
				}
				return ComputedMemberExpression;
			}();
			exports.ComputedMemberExpression = ComputedMemberExpression;
			var ConditionalExpression = function () {
				function ConditionalExpression(test, consequent, alternate) {
					this.type = syntax_1.Syntax.ConditionalExpression;
					this.test = test;
					this.consequent = consequent;
					this.alternate = alternate;
				}
				return ConditionalExpression;
			}();
			exports.ConditionalExpression = ConditionalExpression;
			var ContinueStatement = function () {
				function ContinueStatement(label) {
					this.type = syntax_1.Syntax.ContinueStatement;
					this.label = label;
				}
				return ContinueStatement;
			}();
			exports.ContinueStatement = ContinueStatement;
			var DebuggerStatement = function () {
				function DebuggerStatement() {
					this.type = syntax_1.Syntax.DebuggerStatement;
				}
				return DebuggerStatement;
			}();
			exports.DebuggerStatement = DebuggerStatement;
			var Directive = function () {
				function Directive(expression, directive) {
					this.type = syntax_1.Syntax.ExpressionStatement;
					this.expression = expression;
					this.directive = directive;
				}
				return Directive;
			}();
			exports.Directive = Directive;
			var DoWhileStatement = function () {
				function DoWhileStatement(body, test) {
					this.type = syntax_1.Syntax.DoWhileStatement;
					this.body = body;
					this.test = test;
				}
				return DoWhileStatement;
			}();
			exports.DoWhileStatement = DoWhileStatement;
			var EmptyStatement = function () {
				function EmptyStatement() {
					this.type = syntax_1.Syntax.EmptyStatement;
				}
				return EmptyStatement;
			}();
			exports.EmptyStatement = EmptyStatement;
			var ExportAllDeclaration = function () {
				function ExportAllDeclaration(source) {
					this.type = syntax_1.Syntax.ExportAllDeclaration;
					this.source = source;
				}
				return ExportAllDeclaration;
			}();
			exports.ExportAllDeclaration = ExportAllDeclaration;
			var ExportDefaultDeclaration = function () {
				function ExportDefaultDeclaration(declaration) {
					this.type = syntax_1.Syntax.ExportDefaultDeclaration;
					this.declaration = declaration;
				}
				return ExportDefaultDeclaration;
			}();
			exports.ExportDefaultDeclaration = ExportDefaultDeclaration;
			var ExportNamedDeclaration = function () {
				function ExportNamedDeclaration(declaration, specifiers, source) {
					this.type = syntax_1.Syntax.ExportNamedDeclaration;
					this.declaration = declaration;
					this.specifiers = specifiers;
					this.source = source;
				}
				return ExportNamedDeclaration;
			}();
			exports.ExportNamedDeclaration = ExportNamedDeclaration;
			var ExportSpecifier = function () {
				function ExportSpecifier(local, exported) {
					this.type = syntax_1.Syntax.ExportSpecifier;
					this.exported = exported;
					this.local = local;
				}
				return ExportSpecifier;
			}();
			exports.ExportSpecifier = ExportSpecifier;
			var ExpressionStatement = function () {
				function ExpressionStatement(expression) {
					this.type = syntax_1.Syntax.ExpressionStatement;
					this.expression = expression;
				}
				return ExpressionStatement;
			}();
			exports.ExpressionStatement = ExpressionStatement;
			var ForInStatement = function () {
				function ForInStatement(left, right, body) {
					this.type = syntax_1.Syntax.ForInStatement;
					this.left = left;
					this.right = right;
					this.body = body;
					this.each = false;
				}
				return ForInStatement;
			}();
			exports.ForInStatement = ForInStatement;
			var ForOfStatement = function () {
				function ForOfStatement(left, right, body) {
					this.type = syntax_1.Syntax.ForOfStatement;
					this.left = left;
					this.right = right;
					this.body = body;
				}
				return ForOfStatement;
			}();
			exports.ForOfStatement = ForOfStatement;
			var ForStatement = function () {
				function ForStatement(init, test, update, body) {
					this.type = syntax_1.Syntax.ForStatement;
					this.init = init;
					this.test = test;
					this.update = update;
					this.body = body;
				}
				return ForStatement;
			}();
			exports.ForStatement = ForStatement;
			var FunctionDeclaration = function () {
				function FunctionDeclaration(id, params, body, generator) {
					this.type = syntax_1.Syntax.FunctionDeclaration;
					this.id = id;
					this.params = params;
					this.body = body;
					this.generator = generator;
					this.expression = false;
					this.async = false;
				}
				return FunctionDeclaration;
			}();
			exports.FunctionDeclaration = FunctionDeclaration;
			var FunctionExpression = function () {
				function FunctionExpression(id, params, body, generator) {
					this.type = syntax_1.Syntax.FunctionExpression;
					this.id = id;
					this.params = params;
					this.body = body;
					this.generator = generator;
					this.expression = false;
					this.async = false;
				}
				return FunctionExpression;
			}();
			exports.FunctionExpression = FunctionExpression;
			var Identifier = function () {
				function Identifier(name) {
					this.type = syntax_1.Syntax.Identifier;
					this.name = name;
				}
				return Identifier;
			}();
			exports.Identifier = Identifier;
			var IfStatement = function () {
				function IfStatement(test, consequent, alternate) {
					this.type = syntax_1.Syntax.IfStatement;
					this.test = test;
					this.consequent = consequent;
					this.alternate = alternate;
				}
				return IfStatement;
			}();
			exports.IfStatement = IfStatement;
			var ImportDeclaration = function () {
				function ImportDeclaration(specifiers, source) {
					this.type = syntax_1.Syntax.ImportDeclaration;
					this.specifiers = specifiers;
					this.source = source;
				}
				return ImportDeclaration;
			}();
			exports.ImportDeclaration = ImportDeclaration;
			var ImportDefaultSpecifier = function () {
				function ImportDefaultSpecifier(local) {
					this.type = syntax_1.Syntax.ImportDefaultSpecifier;
					this.local = local;
				}
				return ImportDefaultSpecifier;
			}();
			exports.ImportDefaultSpecifier = ImportDefaultSpecifier;
			var ImportNamespaceSpecifier = function () {
				function ImportNamespaceSpecifier(local) {
					this.type = syntax_1.Syntax.ImportNamespaceSpecifier;
					this.local = local;
				}
				return ImportNamespaceSpecifier;
			}();
			exports.ImportNamespaceSpecifier = ImportNamespaceSpecifier;
			var ImportSpecifier = function () {
				function ImportSpecifier(local, imported) {
					this.type = syntax_1.Syntax.ImportSpecifier;
					this.local = local;
					this.imported = imported;
				}
				return ImportSpecifier;
			}();
			exports.ImportSpecifier = ImportSpecifier;
			var LabeledStatement = function () {
				function LabeledStatement(label, body) {
					this.type = syntax_1.Syntax.LabeledStatement;
					this.label = label;
					this.body = body;
				}
				return LabeledStatement;
			}();
			exports.LabeledStatement = LabeledStatement;
			var Literal = function () {
				function Literal(value, raw) {
					this.type = syntax_1.Syntax.Literal;
					this.value = value;
					this.raw = raw;
				}
				return Literal;
			}();
			exports.Literal = Literal;
			var MetaProperty = function () {
				function MetaProperty(meta, property) {
					this.type = syntax_1.Syntax.MetaProperty;
					this.meta = meta;
					this.property = property;
				}
				return MetaProperty;
			}();
			exports.MetaProperty = MetaProperty;
			var MethodDefinition = function () {
				function MethodDefinition(key, computed, value, kind, isStatic) {
					this.type = syntax_1.Syntax.MethodDefinition;
					this.key = key;
					this.computed = computed;
					this.value = value;
					this.kind = kind;
					this.static = isStatic;
				}
				return MethodDefinition;
			}();
			exports.MethodDefinition = MethodDefinition;
			var Module = function () {
				function Module(body) {
					this.type = syntax_1.Syntax.Program;
					this.body = body;
					this.sourceType = 'module';
				}
				return Module;
			}();
			exports.Module = Module;
			var NewExpression = function () {
				function NewExpression(callee, args) {
					this.type = syntax_1.Syntax.NewExpression;
					this.callee = callee;
					this.arguments = args;
				}
				return NewExpression;
			}();
			exports.NewExpression = NewExpression;
			var ObjectExpression = function () {
				function ObjectExpression(properties) {
					this.type = syntax_1.Syntax.ObjectExpression;
					this.properties = properties;
				}
				return ObjectExpression;
			}();
			exports.ObjectExpression = ObjectExpression;
			var ObjectPattern = function () {
				function ObjectPattern(properties) {
					this.type = syntax_1.Syntax.ObjectPattern;
					this.properties = properties;
				}
				return ObjectPattern;
			}();
			exports.ObjectPattern = ObjectPattern;
			var Property = function () {
				function Property(kind, key, computed, value, method, shorthand) {
					this.type = syntax_1.Syntax.Property;
					this.key = key;
					this.computed = computed;
					this.value = value;
					this.kind = kind;
					this.method = method;
					this.shorthand = shorthand;
				}
				return Property;
			}();
			exports.Property = Property;
			var RegexLiteral = function () {
				function RegexLiteral(value, raw, pattern, flags) {
					this.type = syntax_1.Syntax.Literal;
					this.value = value;
					this.raw = raw;
					this.regex = { pattern: pattern, flags: flags };
				}
				return RegexLiteral;
			}();
			exports.RegexLiteral = RegexLiteral;
			var RestElement = function () {
				function RestElement(argument) {
					this.type = syntax_1.Syntax.RestElement;
					this.argument = argument;
				}
				return RestElement;
			}();
			exports.RestElement = RestElement;
			var ReturnStatement = function () {
				function ReturnStatement(argument) {
					this.type = syntax_1.Syntax.ReturnStatement;
					this.argument = argument;
				}
				return ReturnStatement;
			}();
			exports.ReturnStatement = ReturnStatement;
			var Script = function () {
				function Script(body) {
					this.type = syntax_1.Syntax.Program;
					this.body = body;
					this.sourceType = 'script';
				}
				return Script;
			}();
			exports.Script = Script;
			var SequenceExpression = function () {
				function SequenceExpression(expressions) {
					this.type = syntax_1.Syntax.SequenceExpression;
					this.expressions = expressions;
				}
				return SequenceExpression;
			}();
			exports.SequenceExpression = SequenceExpression;
			var SpreadElement = function () {
				function SpreadElement(argument) {
					this.type = syntax_1.Syntax.SpreadElement;
					this.argument = argument;
				}
				return SpreadElement;
			}();
			exports.SpreadElement = SpreadElement;
			var StaticMemberExpression = function () {
				function StaticMemberExpression(object, property) {
					this.type = syntax_1.Syntax.MemberExpression;
					this.computed = false;
					this.object = object;
					this.property = property;
				}
				return StaticMemberExpression;
			}();
			exports.StaticMemberExpression = StaticMemberExpression;
			var Super = function () {
				function Super() {
					this.type = syntax_1.Syntax.Super;
				}
				return Super;
			}();
			exports.Super = Super;
			var SwitchCase = function () {
				function SwitchCase(test, consequent) {
					this.type = syntax_1.Syntax.SwitchCase;
					this.test = test;
					this.consequent = consequent;
				}
				return SwitchCase;
			}();
			exports.SwitchCase = SwitchCase;
			var SwitchStatement = function () {
				function SwitchStatement(discriminant, cases) {
					this.type = syntax_1.Syntax.SwitchStatement;
					this.discriminant = discriminant;
					this.cases = cases;
				}
				return SwitchStatement;
			}();
			exports.SwitchStatement = SwitchStatement;
			var TaggedTemplateExpression = function () {
				function TaggedTemplateExpression(tag, quasi) {
					this.type = syntax_1.Syntax.TaggedTemplateExpression;
					this.tag = tag;
					this.quasi = quasi;
				}
				return TaggedTemplateExpression;
			}();
			exports.TaggedTemplateExpression = TaggedTemplateExpression;
			var TemplateElement = function () {
				function TemplateElement(value, tail) {
					this.type = syntax_1.Syntax.TemplateElement;
					this.value = value;
					this.tail = tail;
				}
				return TemplateElement;
			}();
			exports.TemplateElement = TemplateElement;
			var TemplateLiteral = function () {
				function TemplateLiteral(quasis, expressions) {
					this.type = syntax_1.Syntax.TemplateLiteral;
					this.quasis = quasis;
					this.expressions = expressions;
				}
				return TemplateLiteral;
			}();
			exports.TemplateLiteral = TemplateLiteral;
			var ThisExpression = function () {
				function ThisExpression() {
					this.type = syntax_1.Syntax.ThisExpression;
				}
				return ThisExpression;
			}();
			exports.ThisExpression = ThisExpression;
			var ThrowStatement = function () {
				function ThrowStatement(argument) {
					this.type = syntax_1.Syntax.ThrowStatement;
					this.argument = argument;
				}
				return ThrowStatement;
			}();
			exports.ThrowStatement = ThrowStatement;
			var TryStatement = function () {
				function TryStatement(block, handler, finalizer) {
					this.type = syntax_1.Syntax.TryStatement;
					this.block = block;
					this.handler = handler;
					this.finalizer = finalizer;
				}
				return TryStatement;
			}();
			exports.TryStatement = TryStatement;
			var UnaryExpression = function () {
				function UnaryExpression(operator, argument) {
					this.type = syntax_1.Syntax.UnaryExpression;
					this.operator = operator;
					this.argument = argument;
					this.prefix = true;
				}
				return UnaryExpression;
			}();
			exports.UnaryExpression = UnaryExpression;
			var UpdateExpression = function () {
				function UpdateExpression(operator, argument, prefix) {
					this.type = syntax_1.Syntax.UpdateExpression;
					this.operator = operator;
					this.argument = argument;
					this.prefix = prefix;
				}
				return UpdateExpression;
			}();
			exports.UpdateExpression = UpdateExpression;
			var VariableDeclaration = function () {
				function VariableDeclaration(declarations, kind) {
					this.type = syntax_1.Syntax.VariableDeclaration;
					this.declarations = declarations;
					this.kind = kind;
				}
				return VariableDeclaration;
			}();
			exports.VariableDeclaration = VariableDeclaration;
			var VariableDeclarator = function () {
				function VariableDeclarator(id, init) {
					this.type = syntax_1.Syntax.VariableDeclarator;
					this.id = id;
					this.init = init;
				}
				return VariableDeclarator;
			}();
			exports.VariableDeclarator = VariableDeclarator;
			var WhileStatement = function () {
				function WhileStatement(test, body) {
					this.type = syntax_1.Syntax.WhileStatement;
					this.test = test;
					this.body = body;
				}
				return WhileStatement;
			}();
			exports.WhileStatement = WhileStatement;
			var WithStatement = function () {
				function WithStatement(object, body) {
					this.type = syntax_1.Syntax.WithStatement;
					this.object = object;
					this.body = body;
				}
				return WithStatement;
			}();
			exports.WithStatement = WithStatement;
			var YieldExpression = function () {
				function YieldExpression(argument, delegate) {
					this.type = syntax_1.Syntax.YieldExpression;
					this.argument = argument;
					this.delegate = delegate;
				}
				return YieldExpression;
			}();
			exports.YieldExpression = YieldExpression;

			/***/
		},
		/* 8 */
		/***/function (module, exports, __webpack_require__) {

			"use strict";

			Object.defineProperty(exports, "__esModule", { value: true });
			var assert_1 = __webpack_require__(9);
			var error_handler_1 = __webpack_require__(10);
			var messages_1 = __webpack_require__(11);
			var Node = __webpack_require__(7);
			var scanner_1 = __webpack_require__(12);
			var syntax_1 = __webpack_require__(2);
			var token_1 = __webpack_require__(13);
			var ArrowParameterPlaceHolder = 'ArrowParameterPlaceHolder';
			var Parser = function () {
				function Parser(code, options, delegate) {
					if (options === void 0) {
						options = {};
					}
					this.config = {
						range: typeof options.range === 'boolean' && options.range,
						loc: typeof options.loc === 'boolean' && options.loc,
						source: null,
						tokens: typeof options.tokens === 'boolean' && options.tokens,
						comment: typeof options.comment === 'boolean' && options.comment,
						tolerant: typeof options.tolerant === 'boolean' && options.tolerant
					};
					if (this.config.loc && options.source && options.source !== null) {
						this.config.source = String(options.source);
					}
					this.delegate = delegate;
					this.errorHandler = new error_handler_1.ErrorHandler();
					this.errorHandler.tolerant = this.config.tolerant;
					this.scanner = new scanner_1.Scanner(code, this.errorHandler);
					this.scanner.trackComment = this.config.comment;
					this.operatorPrecedence = {
						')': 0,
						';': 0,
						',': 0,
						'=': 0,
						']': 0,
						'||': 1,
						'&&': 2,
						'|': 3,
						'^': 4,
						'&': 5,
						'==': 6,
						'!=': 6,
						'===': 6,
						'!==': 6,
						'<': 7,
						'>': 7,
						'<=': 7,
						'>=': 7,
						'<<': 8,
						'>>': 8,
						'>>>': 8,
						'+': 9,
						'-': 9,
						'*': 11,
						'/': 11,
						'%': 11
					};
					this.lookahead = {
						type: 2 /* EOF */
						, value: '',
						lineNumber: this.scanner.lineNumber,
						lineStart: 0,
						start: 0,
						end: 0
					};
					this.hasLineTerminator = false;
					this.context = {
						isModule: false,
						await: false,
						allowIn: true,
						allowStrictDirective: true,
						allowYield: true,
						firstCoverInitializedNameError: null,
						isAssignmentTarget: false,
						isBindingElement: false,
						inFunctionBody: false,
						inIteration: false,
						inSwitch: false,
						labelSet: {},
						strict: false
					};
					this.tokens = [];
					this.startMarker = {
						index: 0,
						line: this.scanner.lineNumber,
						column: 0
					};
					this.lastMarker = {
						index: 0,
						line: this.scanner.lineNumber,
						column: 0
					};
					this.nextToken();
					this.lastMarker = {
						index: this.scanner.index,
						line: this.scanner.lineNumber,
						column: this.scanner.index - this.scanner.lineStart
					};
				}
				Parser.prototype.throwError = function (messageFormat) {
					var values = [];
					for (var _i = 1; _i < arguments.length; _i++) {
						values[_i - 1] = arguments[_i];
					}
					var args = Array.prototype.slice.call(arguments, 1);
					var msg = messageFormat.replace(/%(\d)/g, function (whole, idx) {
						assert_1.assert(idx < args.length, 'Message reference must be in range');
						return args[idx];
					});
					var index = this.lastMarker.index;
					var line = this.lastMarker.line;
					var column = this.lastMarker.column + 1;
					throw this.errorHandler.createError(index, line, column, msg);
				};
				Parser.prototype.tolerateError = function (messageFormat) {
					var values = [];
					for (var _i = 1; _i < arguments.length; _i++) {
						values[_i - 1] = arguments[_i];
					}
					var args = Array.prototype.slice.call(arguments, 1);
					var msg = messageFormat.replace(/%(\d)/g, function (whole, idx) {
						assert_1.assert(idx < args.length, 'Message reference must be in range');
						return args[idx];
					});
					var index = this.lastMarker.index;
					var line = this.scanner.lineNumber;
					var column = this.lastMarker.column + 1;
					this.errorHandler.tolerateError(index, line, column, msg);
				};
				// Throw an exception because of the token.
				Parser.prototype.unexpectedTokenError = function (token, message) {
					var msg = message || messages_1.Messages.UnexpectedToken;
					var value;
					if (token) {
						if (!message) {
							msg = token.type === 2 /* EOF */ ? messages_1.Messages.UnexpectedEOS : token.type === 3 /* Identifier */ ? messages_1.Messages.UnexpectedIdentifier : token.type === 6 /* NumericLiteral */ ? messages_1.Messages.UnexpectedNumber : token.type === 8 /* StringLiteral */ ? messages_1.Messages.UnexpectedString : token.type === 10 /* Template */ ? messages_1.Messages.UnexpectedTemplate : messages_1.Messages.UnexpectedToken;
							if (token.type === 4 /* Keyword */) {
									if (this.scanner.isFutureReservedWord(token.value)) {
										msg = messages_1.Messages.UnexpectedReserved;
									} else if (this.context.strict && this.scanner.isStrictModeReservedWord(token.value)) {
										msg = messages_1.Messages.StrictReservedWord;
									}
								}
						}
						value = token.value;
					} else {
						value = 'ILLEGAL';
					}
					msg = msg.replace('%0', value);
					if (token && typeof token.lineNumber === 'number') {
						var index = token.start;
						var line = token.lineNumber;
						var lastMarkerLineStart = this.lastMarker.index - this.lastMarker.column;
						var column = token.start - lastMarkerLineStart + 1;
						return this.errorHandler.createError(index, line, column, msg);
					} else {
						var index = this.lastMarker.index;
						var line = this.lastMarker.line;
						var column = this.lastMarker.column + 1;
						return this.errorHandler.createError(index, line, column, msg);
					}
				};
				Parser.prototype.throwUnexpectedToken = function (token, message) {
					throw this.unexpectedTokenError(token, message);
				};
				Parser.prototype.tolerateUnexpectedToken = function (token, message) {
					this.errorHandler.tolerate(this.unexpectedTokenError(token, message));
				};
				Parser.prototype.collectComments = function () {
					if (!this.config.comment) {
						this.scanner.scanComments();
					} else {
						var comments = this.scanner.scanComments();
						if (comments.length > 0 && this.delegate) {
							for (var i = 0; i < comments.length; ++i) {
								var e = comments[i];
								var node = void 0;
								node = {
									type: e.multiLine ? 'BlockComment' : 'LineComment',
									value: this.scanner.source.slice(e.slice[0], e.slice[1])
								};
								if (this.config.range) {
									node.range = e.range;
								}
								if (this.config.loc) {
									node.loc = e.loc;
								}
								var metadata = {
									start: {
										line: e.loc.start.line,
										column: e.loc.start.column,
										offset: e.range[0]
									},
									end: {
										line: e.loc.end.line,
										column: e.loc.end.column,
										offset: e.range[1]
									}
								};
								this.delegate(node, metadata);
							}
						}
					}
				};
				// From internal representation to an external structure
				Parser.prototype.getTokenRaw = function (token) {
					return this.scanner.source.slice(token.start, token.end);
				};
				Parser.prototype.convertToken = function (token) {
					var t = {
						type: token_1.TokenName[token.type],
						value: this.getTokenRaw(token)
					};
					if (this.config.range) {
						t.range = [token.start, token.end];
					}
					if (this.config.loc) {
						t.loc = {
							start: {
								line: this.startMarker.line,
								column: this.startMarker.column
							},
							end: {
								line: this.scanner.lineNumber,
								column: this.scanner.index - this.scanner.lineStart
							}
						};
					}
					if (token.type === 9 /* RegularExpression */) {
							var pattern = token.pattern;
							var flags = token.flags;
							t.regex = { pattern: pattern, flags: flags };
						}
					return t;
				};
				Parser.prototype.nextToken = function () {
					var token = this.lookahead;
					this.lastMarker.index = this.scanner.index;
					this.lastMarker.line = this.scanner.lineNumber;
					this.lastMarker.column = this.scanner.index - this.scanner.lineStart;
					this.collectComments();
					if (this.scanner.index !== this.startMarker.index) {
						this.startMarker.index = this.scanner.index;
						this.startMarker.line = this.scanner.lineNumber;
						this.startMarker.column = this.scanner.index - this.scanner.lineStart;
					}
					var next = this.scanner.lex();
					this.hasLineTerminator = token.lineNumber !== next.lineNumber;
					if (next && this.context.strict && next.type === 3 /* Identifier */) {
							if (this.scanner.isStrictModeReservedWord(next.value)) {
								next.type = 4 /* Keyword */;
							}
						}
					this.lookahead = next;
					if (this.config.tokens && next.type !== 2 /* EOF */) {
							this.tokens.push(this.convertToken(next));
						}
					return token;
				};
				Parser.prototype.nextRegexToken = function () {
					this.collectComments();
					var token = this.scanner.scanRegExp();
					if (this.config.tokens) {
						// Pop the previous token, '/' or '/='
						// This is added from the lookahead token.
						this.tokens.pop();
						this.tokens.push(this.convertToken(token));
					}
					// Prime the next lookahead.
					this.lookahead = token;
					this.nextToken();
					return token;
				};
				Parser.prototype.createNode = function () {
					return {
						index: this.startMarker.index,
						line: this.startMarker.line,
						column: this.startMarker.column
					};
				};
				Parser.prototype.startNode = function (token) {
					return {
						index: token.start,
						line: token.lineNumber,
						column: token.start - token.lineStart
					};
				};
				Parser.prototype.finalize = function (marker, node) {
					if (this.config.range) {
						node.range = [marker.index, this.lastMarker.index];
					}
					if (this.config.loc) {
						node.loc = {
							start: {
								line: marker.line,
								column: marker.column
							},
							end: {
								line: this.lastMarker.line,
								column: this.lastMarker.column
							}
						};
						if (this.config.source) {
							node.loc.source = this.config.source;
						}
					}
					if (this.delegate) {
						var metadata = {
							start: {
								line: marker.line,
								column: marker.column,
								offset: marker.index
							},
							end: {
								line: this.lastMarker.line,
								column: this.lastMarker.column,
								offset: this.lastMarker.index
							}
						};
						this.delegate(node, metadata);
					}
					return node;
				};
				// Expect the next token to match the specified punctuator.
				// If not, an exception will be thrown.
				Parser.prototype.expect = function (value) {
					var token = this.nextToken();
					if (token.type !== 7 /* Punctuator */ || token.value !== value) {
						this.throwUnexpectedToken(token);
					}
				};
				// Quietly expect a comma when in tolerant mode, otherwise delegates to expect().
				Parser.prototype.expectCommaSeparator = function () {
					if (this.config.tolerant) {
						var token = this.lookahead;
						if (token.type === 7 /* Punctuator */ && token.value === ',') {
							this.nextToken();
						} else if (token.type === 7 /* Punctuator */ && token.value === ';') {
							this.nextToken();
							this.tolerateUnexpectedToken(token);
						} else {
							this.tolerateUnexpectedToken(token, messages_1.Messages.UnexpectedToken);
						}
					} else {
						this.expect(',');
					}
				};
				// Expect the next token to match the specified keyword.
				// If not, an exception will be thrown.
				Parser.prototype.expectKeyword = function (keyword) {
					var token = this.nextToken();
					if (token.type !== 4 /* Keyword */ || token.value !== keyword) {
						this.throwUnexpectedToken(token);
					}
				};
				// Return true if the next token matches the specified punctuator.
				Parser.prototype.match = function (value) {
					return this.lookahead.type === 7 /* Punctuator */ && this.lookahead.value === value;
				};
				// Return true if the next token matches the specified keyword
				Parser.prototype.matchKeyword = function (keyword) {
					return this.lookahead.type === 4 /* Keyword */ && this.lookahead.value === keyword;
				};
				// Return true if the next token matches the specified contextual keyword
				// (where an identifier is sometimes a keyword depending on the context)
				Parser.prototype.matchContextualKeyword = function (keyword) {
					return this.lookahead.type === 3 /* Identifier */ && this.lookahead.value === keyword;
				};
				// Return true if the next token is an assignment operator
				Parser.prototype.matchAssign = function () {
					if (this.lookahead.type !== 7 /* Punctuator */) {
							return false;
						}
					var op = this.lookahead.value;
					return op === '=' || op === '*=' || op === '**=' || op === '/=' || op === '%=' || op === '+=' || op === '-=' || op === '<<=' || op === '>>=' || op === '>>>=' || op === '&=' || op === '^=' || op === '|=';
				};
				// Cover grammar support.
				//
				// When an assignment expression position starts with an left parenthesis, the determination of the type
				// of the syntax is to be deferred arbitrarily long until the end of the parentheses pair (plus a lookahead)
				// or the first comma. This situation also defers the determination of all the expressions nested in the pair.
				//
				// There are three productions that can be parsed in a parentheses pair that needs to be determined
				// after the outermost pair is closed. They are:
				//
				//   1. AssignmentExpression
				//   2. BindingElements
				//   3. AssignmentTargets
				//
				// In order to avoid exponential backtracking, we use two flags to denote if the production can be
				// binding element or assignment target.
				//
				// The three productions have the relationship:
				//
				//   BindingElements ⊆ AssignmentTargets ⊆ AssignmentExpression
				//
				// with a single exception that CoverInitializedName when used directly in an Expression, generates
				// an early error. Therefore, we need the third state, firstCoverInitializedNameError, to track the
				// first usage of CoverInitializedName and report it when we reached the end of the parentheses pair.
				//
				// isolateCoverGrammar function runs the given parser function with a new cover grammar context, and it does not
				// effect the current flags. This means the production the parser parses is only used as an expression. Therefore
				// the CoverInitializedName check is conducted.
				//
				// inheritCoverGrammar function runs the given parse function with a new cover grammar context, and it propagates
				// the flags outside of the parser. This means the production the parser parses is used as a part of a potential
				// pattern. The CoverInitializedName check is deferred.
				Parser.prototype.isolateCoverGrammar = function (parseFunction) {
					var previousIsBindingElement = this.context.isBindingElement;
					var previousIsAssignmentTarget = this.context.isAssignmentTarget;
					var previousFirstCoverInitializedNameError = this.context.firstCoverInitializedNameError;
					this.context.isBindingElement = true;
					this.context.isAssignmentTarget = true;
					this.context.firstCoverInitializedNameError = null;
					var result = parseFunction.call(this);
					if (this.context.firstCoverInitializedNameError !== null) {
						this.throwUnexpectedToken(this.context.firstCoverInitializedNameError);
					}
					this.context.isBindingElement = previousIsBindingElement;
					this.context.isAssignmentTarget = previousIsAssignmentTarget;
					this.context.firstCoverInitializedNameError = previousFirstCoverInitializedNameError;
					return result;
				};
				Parser.prototype.inheritCoverGrammar = function (parseFunction) {
					var previousIsBindingElement = this.context.isBindingElement;
					var previousIsAssignmentTarget = this.context.isAssignmentTarget;
					var previousFirstCoverInitializedNameError = this.context.firstCoverInitializedNameError;
					this.context.isBindingElement = true;
					this.context.isAssignmentTarget = true;
					this.context.firstCoverInitializedNameError = null;
					var result = parseFunction.call(this);
					this.context.isBindingElement = this.context.isBindingElement && previousIsBindingElement;
					this.context.isAssignmentTarget = this.context.isAssignmentTarget && previousIsAssignmentTarget;
					this.context.firstCoverInitializedNameError = previousFirstCoverInitializedNameError || this.context.firstCoverInitializedNameError;
					return result;
				};
				Parser.prototype.consumeSemicolon = function () {
					if (this.match(';')) {
						this.nextToken();
					} else if (!this.hasLineTerminator) {
						if (this.lookahead.type !== 2 /* EOF */ && !this.match('}')) {
							this.throwUnexpectedToken(this.lookahead);
						}
						this.lastMarker.index = this.startMarker.index;
						this.lastMarker.line = this.startMarker.line;
						this.lastMarker.column = this.startMarker.column;
					}
				};
				// https://tc39.github.io/ecma262/#sec-primary-expression
				Parser.prototype.parsePrimaryExpression = function () {
					var node = this.createNode();
					var expr;
					var token, raw;
					switch (this.lookahead.type) {
						case 3 /* Identifier */:
							if ((this.context.isModule || this.context.await) && this.lookahead.value === 'await') {
								this.tolerateUnexpectedToken(this.lookahead);
							}
							expr = this.matchAsyncFunction() ? this.parseFunctionExpression() : this.finalize(node, new Node.Identifier(this.nextToken().value));
							break;
						case 6 /* NumericLiteral */:
						case 8 /* StringLiteral */:
							if (this.context.strict && this.lookahead.octal) {
								this.tolerateUnexpectedToken(this.lookahead, messages_1.Messages.StrictOctalLiteral);
							}
							this.context.isAssignmentTarget = false;
							this.context.isBindingElement = false;
							token = this.nextToken();
							raw = this.getTokenRaw(token);
							expr = this.finalize(node, new Node.Literal(token.value, raw));
							break;
						case 1 /* BooleanLiteral */:
							this.context.isAssignmentTarget = false;
							this.context.isBindingElement = false;
							token = this.nextToken();
							raw = this.getTokenRaw(token);
							expr = this.finalize(node, new Node.Literal(token.value === 'true', raw));
							break;
						case 5 /* NullLiteral */:
							this.context.isAssignmentTarget = false;
							this.context.isBindingElement = false;
							token = this.nextToken();
							raw = this.getTokenRaw(token);
							expr = this.finalize(node, new Node.Literal(null, raw));
							break;
						case 10 /* Template */:
							expr = this.parseTemplateLiteral();
							break;
						case 7 /* Punctuator */:
							switch (this.lookahead.value) {
								case '(':
									this.context.isBindingElement = false;
									expr = this.inheritCoverGrammar(this.parseGroupExpression);
									break;
								case '[':
									expr = this.inheritCoverGrammar(this.parseArrayInitializer);
									break;
								case '{':
									expr = this.inheritCoverGrammar(this.parseObjectInitializer);
									break;
								case '/':
								case '/=':
									this.context.isAssignmentTarget = false;
									this.context.isBindingElement = false;
									this.scanner.index = this.startMarker.index;
									token = this.nextRegexToken();
									raw = this.getTokenRaw(token);
									expr = this.finalize(node, new Node.RegexLiteral(token.regex, raw, token.pattern, token.flags));
									break;
								default:
									expr = this.throwUnexpectedToken(this.nextToken());
							}
							break;
						case 4 /* Keyword */:
							if (!this.context.strict && this.context.allowYield && this.matchKeyword('yield')) {
								expr = this.parseIdentifierName();
							} else if (!this.context.strict && this.matchKeyword('let')) {
								expr = this.finalize(node, new Node.Identifier(this.nextToken().value));
							} else {
								this.context.isAssignmentTarget = false;
								this.context.isBindingElement = false;
								if (this.matchKeyword('function')) {
									expr = this.parseFunctionExpression();
								} else if (this.matchKeyword('this')) {
									this.nextToken();
									expr = this.finalize(node, new Node.ThisExpression());
								} else if (this.matchKeyword('class')) {
									expr = this.parseClassExpression();
								} else {
									expr = this.throwUnexpectedToken(this.nextToken());
								}
							}
							break;
						default:
							expr = this.throwUnexpectedToken(this.nextToken());
					}
					return expr;
				};
				// https://tc39.github.io/ecma262/#sec-array-initializer
				Parser.prototype.parseSpreadElement = function () {
					var node = this.createNode();
					this.expect('...');
					var arg = this.inheritCoverGrammar(this.parseAssignmentExpression);
					return this.finalize(node, new Node.SpreadElement(arg));
				};
				Parser.prototype.parseArrayInitializer = function () {
					var node = this.createNode();
					var elements = [];
					this.expect('[');
					while (!this.match(']')) {
						if (this.match(',')) {
							this.nextToken();
							elements.push(null);
						} else if (this.match('...')) {
							var element = this.parseSpreadElement();
							if (!this.match(']')) {
								this.context.isAssignmentTarget = false;
								this.context.isBindingElement = false;
								this.expect(',');
							}
							elements.push(element);
						} else {
							elements.push(this.inheritCoverGrammar(this.parseAssignmentExpression));
							if (!this.match(']')) {
								this.expect(',');
							}
						}
					}
					this.expect(']');
					return this.finalize(node, new Node.ArrayExpression(elements));
				};
				// https://tc39.github.io/ecma262/#sec-object-initializer
				Parser.prototype.parsePropertyMethod = function (params) {
					this.context.isAssignmentTarget = false;
					this.context.isBindingElement = false;
					var previousStrict = this.context.strict;
					var previousAllowStrictDirective = this.context.allowStrictDirective;
					this.context.allowStrictDirective = params.simple;
					var body = this.isolateCoverGrammar(this.parseFunctionSourceElements);
					if (this.context.strict && params.firstRestricted) {
						this.tolerateUnexpectedToken(params.firstRestricted, params.message);
					}
					if (this.context.strict && params.stricted) {
						this.tolerateUnexpectedToken(params.stricted, params.message);
					}
					this.context.strict = previousStrict;
					this.context.allowStrictDirective = previousAllowStrictDirective;
					return body;
				};
				Parser.prototype.parsePropertyMethodFunction = function () {
					var isGenerator = false;
					var node = this.createNode();
					var previousAllowYield = this.context.allowYield;
					this.context.allowYield = false;
					var params = this.parseFormalParameters();
					var method = this.parsePropertyMethod(params);
					this.context.allowYield = previousAllowYield;
					return this.finalize(node, new Node.FunctionExpression(null, params.params, method, isGenerator));
				};
				Parser.prototype.parsePropertyMethodAsyncFunction = function () {
					var node = this.createNode();
					var previousAllowYield = this.context.allowYield;
					var previousAwait = this.context.await;
					this.context.allowYield = false;
					this.context.await = true;
					var params = this.parseFormalParameters();
					var method = this.parsePropertyMethod(params);
					this.context.allowYield = previousAllowYield;
					this.context.await = previousAwait;
					return this.finalize(node, new Node.AsyncFunctionExpression(null, params.params, method));
				};
				Parser.prototype.parseObjectPropertyKey = function () {
					var node = this.createNode();
					var token = this.nextToken();
					var key;
					switch (token.type) {
						case 8 /* StringLiteral */:
						case 6 /* NumericLiteral */:
							if (this.context.strict && token.octal) {
								this.tolerateUnexpectedToken(token, messages_1.Messages.StrictOctalLiteral);
							}
							var raw = this.getTokenRaw(token);
							key = this.finalize(node, new Node.Literal(token.value, raw));
							break;
						case 3 /* Identifier */:
						case 1 /* BooleanLiteral */:
						case 5 /* NullLiteral */:
						case 4 /* Keyword */:
							key = this.finalize(node, new Node.Identifier(token.value));
							break;
						case 7 /* Punctuator */:
							if (token.value === '[') {
								key = this.isolateCoverGrammar(this.parseAssignmentExpression);
								this.expect(']');
							} else {
								key = this.throwUnexpectedToken(token);
							}
							break;
						default:
							key = this.throwUnexpectedToken(token);
					}
					return key;
				};
				Parser.prototype.isPropertyKey = function (key, value) {
					return key.type === syntax_1.Syntax.Identifier && key.name === value || key.type === syntax_1.Syntax.Literal && key.value === value;
				};
				Parser.prototype.parseObjectProperty = function (hasProto) {
					var node = this.createNode();
					var token = this.lookahead;
					var kind;
					var key = null;
					var value = null;
					var computed = false;
					var method = false;
					var shorthand = false;
					var isAsync = false;
					if (token.type === 3 /* Identifier */) {
							var id = token.value;
							this.nextToken();
							computed = this.match('[');
							isAsync = !this.hasLineTerminator && id === 'async' && !this.match(':') && !this.match('(') && !this.match('*');
							key = isAsync ? this.parseObjectPropertyKey() : this.finalize(node, new Node.Identifier(id));
						} else if (this.match('*')) {
						this.nextToken();
					} else {
						computed = this.match('[');
						key = this.parseObjectPropertyKey();
					}
					var lookaheadPropertyKey = this.qualifiedPropertyName(this.lookahead);
					if (token.type === 3 /* Identifier */ && !isAsync && token.value === 'get' && lookaheadPropertyKey) {
						kind = 'get';
						computed = this.match('[');
						key = this.parseObjectPropertyKey();
						this.context.allowYield = false;
						value = this.parseGetterMethod();
					} else if (token.type === 3 /* Identifier */ && !isAsync && token.value === 'set' && lookaheadPropertyKey) {
						kind = 'set';
						computed = this.match('[');
						key = this.parseObjectPropertyKey();
						value = this.parseSetterMethod();
					} else if (token.type === 7 /* Punctuator */ && token.value === '*' && lookaheadPropertyKey) {
						kind = 'init';
						computed = this.match('[');
						key = this.parseObjectPropertyKey();
						value = this.parseGeneratorMethod();
						method = true;
					} else {
						if (!key) {
							this.throwUnexpectedToken(this.lookahead);
						}
						kind = 'init';
						if (this.match(':') && !isAsync) {
							if (!computed && this.isPropertyKey(key, '__proto__')) {
								if (hasProto.value) {
									this.tolerateError(messages_1.Messages.DuplicateProtoProperty);
								}
								hasProto.value = true;
							}
							this.nextToken();
							value = this.inheritCoverGrammar(this.parseAssignmentExpression);
						} else if (this.match('(')) {
							value = isAsync ? this.parsePropertyMethodAsyncFunction() : this.parsePropertyMethodFunction();
							method = true;
						} else if (token.type === 3 /* Identifier */) {
								var id = this.finalize(node, new Node.Identifier(token.value));
								if (this.match('=')) {
									this.context.firstCoverInitializedNameError = this.lookahead;
									this.nextToken();
									shorthand = true;
									var init = this.isolateCoverGrammar(this.parseAssignmentExpression);
									value = this.finalize(node, new Node.AssignmentPattern(id, init));
								} else {
									shorthand = true;
									value = id;
								}
							} else {
							this.throwUnexpectedToken(this.nextToken());
						}
					}
					return this.finalize(node, new Node.Property(kind, key, computed, value, method, shorthand));
				};
				Parser.prototype.parseObjectInitializer = function () {
					var node = this.createNode();
					this.expect('{');
					var properties = [];
					var hasProto = { value: false };
					while (!this.match('}')) {
						properties.push(this.parseObjectProperty(hasProto));
						if (!this.match('}')) {
							this.expectCommaSeparator();
						}
					}
					this.expect('}');
					return this.finalize(node, new Node.ObjectExpression(properties));
				};
				// https://tc39.github.io/ecma262/#sec-template-literals
				Parser.prototype.parseTemplateHead = function () {
					assert_1.assert(this.lookahead.head, 'Template literal must start with a template head');
					var node = this.createNode();
					var token = this.nextToken();
					var raw = token.value;
					var cooked = token.cooked;
					return this.finalize(node, new Node.TemplateElement({ raw: raw, cooked: cooked }, token.tail));
				};
				Parser.prototype.parseTemplateElement = function () {
					if (this.lookahead.type !== 10 /* Template */) {
							this.throwUnexpectedToken();
						}
					var node = this.createNode();
					var token = this.nextToken();
					var raw = token.value;
					var cooked = token.cooked;
					return this.finalize(node, new Node.TemplateElement({ raw: raw, cooked: cooked }, token.tail));
				};
				Parser.prototype.parseTemplateLiteral = function () {
					var node = this.createNode();
					var expressions = [];
					var quasis = [];
					var quasi = this.parseTemplateHead();
					quasis.push(quasi);
					while (!quasi.tail) {
						expressions.push(this.parseExpression());
						quasi = this.parseTemplateElement();
						quasis.push(quasi);
					}
					return this.finalize(node, new Node.TemplateLiteral(quasis, expressions));
				};
				// https://tc39.github.io/ecma262/#sec-grouping-operator
				Parser.prototype.reinterpretExpressionAsPattern = function (expr) {
					switch (expr.type) {
						case syntax_1.Syntax.Identifier:
						case syntax_1.Syntax.MemberExpression:
						case syntax_1.Syntax.RestElement:
						case syntax_1.Syntax.AssignmentPattern:
							break;
						case syntax_1.Syntax.SpreadElement:
							expr.type = syntax_1.Syntax.RestElement;
							this.reinterpretExpressionAsPattern(expr.argument);
							break;
						case syntax_1.Syntax.ArrayExpression:
							expr.type = syntax_1.Syntax.ArrayPattern;
							for (var i = 0; i < expr.elements.length; i++) {
								if (expr.elements[i] !== null) {
									this.reinterpretExpressionAsPattern(expr.elements[i]);
								}
							}
							break;
						case syntax_1.Syntax.ObjectExpression:
							expr.type = syntax_1.Syntax.ObjectPattern;
							for (var i = 0; i < expr.properties.length; i++) {
								this.reinterpretExpressionAsPattern(expr.properties[i].value);
							}
							break;
						case syntax_1.Syntax.AssignmentExpression:
							expr.type = syntax_1.Syntax.AssignmentPattern;
							delete expr.operator;
							this.reinterpretExpressionAsPattern(expr.left);
							break;
						default:
							// Allow other node type for tolerant parsing.
							break;
					}
				};
				Parser.prototype.parseGroupExpression = function () {
					var expr;
					this.expect('(');
					if (this.match(')')) {
						this.nextToken();
						if (!this.match('=>')) {
							this.expect('=>');
						}
						expr = {
							type: ArrowParameterPlaceHolder,
							params: [],
							async: false
						};
					} else {
						var startToken = this.lookahead;
						var params = [];
						if (this.match('...')) {
							expr = this.parseRestElement(params);
							this.expect(')');
							if (!this.match('=>')) {
								this.expect('=>');
							}
							expr = {
								type: ArrowParameterPlaceHolder,
								params: [expr],
								async: false
							};
						} else {
							var arrow = false;
							this.context.isBindingElement = true;
							expr = this.inheritCoverGrammar(this.parseAssignmentExpression);
							if (this.match(',')) {
								var expressions = [];
								this.context.isAssignmentTarget = false;
								expressions.push(expr);
								while (this.lookahead.type !== 2 /* EOF */) {
									if (!this.match(',')) {
										break;
									}
									this.nextToken();
									if (this.match(')')) {
										this.nextToken();
										for (var i = 0; i < expressions.length; i++) {
											this.reinterpretExpressionAsPattern(expressions[i]);
										}
										arrow = true;
										expr = {
											type: ArrowParameterPlaceHolder,
											params: expressions,
											async: false
										};
									} else if (this.match('...')) {
										if (!this.context.isBindingElement) {
											this.throwUnexpectedToken(this.lookahead);
										}
										expressions.push(this.parseRestElement(params));
										this.expect(')');
										if (!this.match('=>')) {
											this.expect('=>');
										}
										this.context.isBindingElement = false;
										for (var i = 0; i < expressions.length; i++) {
											this.reinterpretExpressionAsPattern(expressions[i]);
										}
										arrow = true;
										expr = {
											type: ArrowParameterPlaceHolder,
											params: expressions,
											async: false
										};
									} else {
										expressions.push(this.inheritCoverGrammar(this.parseAssignmentExpression));
									}
									if (arrow) {
										break;
									}
								}
								if (!arrow) {
									expr = this.finalize(this.startNode(startToken), new Node.SequenceExpression(expressions));
								}
							}
							if (!arrow) {
								this.expect(')');
								if (this.match('=>')) {
									if (expr.type === syntax_1.Syntax.Identifier && expr.name === 'yield') {
										arrow = true;
										expr = {
											type: ArrowParameterPlaceHolder,
											params: [expr],
											async: false
										};
									}
									if (!arrow) {
										if (!this.context.isBindingElement) {
											this.throwUnexpectedToken(this.lookahead);
										}
										if (expr.type === syntax_1.Syntax.SequenceExpression) {
											for (var i = 0; i < expr.expressions.length; i++) {
												this.reinterpretExpressionAsPattern(expr.expressions[i]);
											}
										} else {
											this.reinterpretExpressionAsPattern(expr);
										}
										var parameters = expr.type === syntax_1.Syntax.SequenceExpression ? expr.expressions : [expr];
										expr = {
											type: ArrowParameterPlaceHolder,
											params: parameters,
											async: false
										};
									}
								}
								this.context.isBindingElement = false;
							}
						}
					}
					return expr;
				};
				// https://tc39.github.io/ecma262/#sec-left-hand-side-expressions
				Parser.prototype.parseArguments = function () {
					this.expect('(');
					var args = [];
					if (!this.match(')')) {
						while (true) {
							var expr = this.match('...') ? this.parseSpreadElement() : this.isolateCoverGrammar(this.parseAssignmentExpression);
							args.push(expr);
							if (this.match(')')) {
								break;
							}
							this.expectCommaSeparator();
							if (this.match(')')) {
								break;
							}
						}
					}
					this.expect(')');
					return args;
				};
				Parser.prototype.isIdentifierName = function (token) {
					return token.type === 3 /* Identifier */ || token.type === 4 /* Keyword */ || token.type === 1 /* BooleanLiteral */ || token.type === 5 /* NullLiteral */;
				};
				Parser.prototype.parseIdentifierName = function () {
					var node = this.createNode();
					var token = this.nextToken();
					if (!this.isIdentifierName(token)) {
						this.throwUnexpectedToken(token);
					}
					return this.finalize(node, new Node.Identifier(token.value));
				};
				Parser.prototype.parseNewExpression = function () {
					var node = this.createNode();
					var id = this.parseIdentifierName();
					assert_1.assert(id.name === 'new', 'New expression must start with `new`');
					var expr;
					if (this.match('.')) {
						this.nextToken();
						if (this.lookahead.type === 3 /* Identifier */ && this.context.inFunctionBody && this.lookahead.value === 'target') {
							var property = this.parseIdentifierName();
							expr = new Node.MetaProperty(id, property);
						} else {
							this.throwUnexpectedToken(this.lookahead);
						}
					} else {
						var callee = this.isolateCoverGrammar(this.parseLeftHandSideExpression);
						var args = this.match('(') ? this.parseArguments() : [];
						expr = new Node.NewExpression(callee, args);
						this.context.isAssignmentTarget = false;
						this.context.isBindingElement = false;
					}
					return this.finalize(node, expr);
				};
				Parser.prototype.parseAsyncArgument = function () {
					var arg = this.parseAssignmentExpression();
					this.context.firstCoverInitializedNameError = null;
					return arg;
				};
				Parser.prototype.parseAsyncArguments = function () {
					this.expect('(');
					var args = [];
					if (!this.match(')')) {
						while (true) {
							var expr = this.match('...') ? this.parseSpreadElement() : this.isolateCoverGrammar(this.parseAsyncArgument);
							args.push(expr);
							if (this.match(')')) {
								break;
							}
							this.expectCommaSeparator();
							if (this.match(')')) {
								break;
							}
						}
					}
					this.expect(')');
					return args;
				};
				Parser.prototype.parseLeftHandSideExpressionAllowCall = function () {
					var startToken = this.lookahead;
					var maybeAsync = this.matchContextualKeyword('async');
					var previousAllowIn = this.context.allowIn;
					this.context.allowIn = true;
					var expr;
					if (this.matchKeyword('super') && this.context.inFunctionBody) {
						expr = this.createNode();
						this.nextToken();
						expr = this.finalize(expr, new Node.Super());
						if (!this.match('(') && !this.match('.') && !this.match('[')) {
							this.throwUnexpectedToken(this.lookahead);
						}
					} else {
						expr = this.inheritCoverGrammar(this.matchKeyword('new') ? this.parseNewExpression : this.parsePrimaryExpression);
					}
					while (true) {
						if (this.match('.')) {
							this.context.isBindingElement = false;
							this.context.isAssignmentTarget = true;
							this.expect('.');
							var property = this.parseIdentifierName();
							expr = this.finalize(this.startNode(startToken), new Node.StaticMemberExpression(expr, property));
						} else if (this.match('(')) {
							var asyncArrow = maybeAsync && startToken.lineNumber === this.lookahead.lineNumber;
							this.context.isBindingElement = false;
							this.context.isAssignmentTarget = false;
							var args = asyncArrow ? this.parseAsyncArguments() : this.parseArguments();
							expr = this.finalize(this.startNode(startToken), new Node.CallExpression(expr, args));
							if (asyncArrow && this.match('=>')) {
								for (var i = 0; i < args.length; ++i) {
									this.reinterpretExpressionAsPattern(args[i]);
								}
								expr = {
									type: ArrowParameterPlaceHolder,
									params: args,
									async: true
								};
							}
						} else if (this.match('[')) {
							this.context.isBindingElement = false;
							this.context.isAssignmentTarget = true;
							this.expect('[');
							var property = this.isolateCoverGrammar(this.parseExpression);
							this.expect(']');
							expr = this.finalize(this.startNode(startToken), new Node.ComputedMemberExpression(expr, property));
						} else if (this.lookahead.type === 10 /* Template */ && this.lookahead.head) {
							var quasi = this.parseTemplateLiteral();
							expr = this.finalize(this.startNode(startToken), new Node.TaggedTemplateExpression(expr, quasi));
						} else {
							break;
						}
					}
					this.context.allowIn = previousAllowIn;
					return expr;
				};
				Parser.prototype.parseSuper = function () {
					var node = this.createNode();
					this.expectKeyword('super');
					if (!this.match('[') && !this.match('.')) {
						this.throwUnexpectedToken(this.lookahead);
					}
					return this.finalize(node, new Node.Super());
				};
				Parser.prototype.parseLeftHandSideExpression = function () {
					assert_1.assert(this.context.allowIn, 'callee of new expression always allow in keyword.');
					var node = this.startNode(this.lookahead);
					var expr = this.matchKeyword('super') && this.context.inFunctionBody ? this.parseSuper() : this.inheritCoverGrammar(this.matchKeyword('new') ? this.parseNewExpression : this.parsePrimaryExpression);
					while (true) {
						if (this.match('[')) {
							this.context.isBindingElement = false;
							this.context.isAssignmentTarget = true;
							this.expect('[');
							var property = this.isolateCoverGrammar(this.parseExpression);
							this.expect(']');
							expr = this.finalize(node, new Node.ComputedMemberExpression(expr, property));
						} else if (this.match('.')) {
							this.context.isBindingElement = false;
							this.context.isAssignmentTarget = true;
							this.expect('.');
							var property = this.parseIdentifierName();
							expr = this.finalize(node, new Node.StaticMemberExpression(expr, property));
						} else if (this.lookahead.type === 10 /* Template */ && this.lookahead.head) {
							var quasi = this.parseTemplateLiteral();
							expr = this.finalize(node, new Node.TaggedTemplateExpression(expr, quasi));
						} else {
							break;
						}
					}
					return expr;
				};
				// https://tc39.github.io/ecma262/#sec-update-expressions
				Parser.prototype.parseUpdateExpression = function () {
					var expr;
					var startToken = this.lookahead;
					if (this.match('++') || this.match('--')) {
						var node = this.startNode(startToken);
						var token = this.nextToken();
						expr = this.inheritCoverGrammar(this.parseUnaryExpression);
						if (this.context.strict && expr.type === syntax_1.Syntax.Identifier && this.scanner.isRestrictedWord(expr.name)) {
							this.tolerateError(messages_1.Messages.StrictLHSPrefix);
						}
						if (!this.context.isAssignmentTarget) {
							this.tolerateError(messages_1.Messages.InvalidLHSInAssignment);
						}
						var prefix = true;
						expr = this.finalize(node, new Node.UpdateExpression(token.value, expr, prefix));
						this.context.isAssignmentTarget = false;
						this.context.isBindingElement = false;
					} else {
						expr = this.inheritCoverGrammar(this.parseLeftHandSideExpressionAllowCall);
						if (!this.hasLineTerminator && this.lookahead.type === 7 /* Punctuator */) {
								if (this.match('++') || this.match('--')) {
									if (this.context.strict && expr.type === syntax_1.Syntax.Identifier && this.scanner.isRestrictedWord(expr.name)) {
										this.tolerateError(messages_1.Messages.StrictLHSPostfix);
									}
									if (!this.context.isAssignmentTarget) {
										this.tolerateError(messages_1.Messages.InvalidLHSInAssignment);
									}
									this.context.isAssignmentTarget = false;
									this.context.isBindingElement = false;
									var operator = this.nextToken().value;
									var prefix = false;
									expr = this.finalize(this.startNode(startToken), new Node.UpdateExpression(operator, expr, prefix));
								}
							}
					}
					return expr;
				};
				// https://tc39.github.io/ecma262/#sec-unary-operators
				Parser.prototype.parseAwaitExpression = function () {
					var node = this.createNode();
					this.nextToken();
					var argument = this.parseUnaryExpression();
					return this.finalize(node, new Node.AwaitExpression(argument));
				};
				Parser.prototype.parseUnaryExpression = function () {
					var expr;
					if (this.match('+') || this.match('-') || this.match('~') || this.match('!') || this.matchKeyword('delete') || this.matchKeyword('void') || this.matchKeyword('typeof')) {
						var node = this.startNode(this.lookahead);
						var token = this.nextToken();
						expr = this.inheritCoverGrammar(this.parseUnaryExpression);
						expr = this.finalize(node, new Node.UnaryExpression(token.value, expr));
						if (this.context.strict && expr.operator === 'delete' && expr.argument.type === syntax_1.Syntax.Identifier) {
							this.tolerateError(messages_1.Messages.StrictDelete);
						}
						this.context.isAssignmentTarget = false;
						this.context.isBindingElement = false;
					} else if (this.context.await && this.matchContextualKeyword('await')) {
						expr = this.parseAwaitExpression();
					} else {
						expr = this.parseUpdateExpression();
					}
					return expr;
				};
				Parser.prototype.parseExponentiationExpression = function () {
					var startToken = this.lookahead;
					var expr = this.inheritCoverGrammar(this.parseUnaryExpression);
					if (expr.type !== syntax_1.Syntax.UnaryExpression && this.match('**')) {
						this.nextToken();
						this.context.isAssignmentTarget = false;
						this.context.isBindingElement = false;
						var left = expr;
						var right = this.isolateCoverGrammar(this.parseExponentiationExpression);
						expr = this.finalize(this.startNode(startToken), new Node.BinaryExpression('**', left, right));
					}
					return expr;
				};
				// https://tc39.github.io/ecma262/#sec-exp-operator
				// https://tc39.github.io/ecma262/#sec-multiplicative-operators
				// https://tc39.github.io/ecma262/#sec-additive-operators
				// https://tc39.github.io/ecma262/#sec-bitwise-shift-operators
				// https://tc39.github.io/ecma262/#sec-relational-operators
				// https://tc39.github.io/ecma262/#sec-equality-operators
				// https://tc39.github.io/ecma262/#sec-binary-bitwise-operators
				// https://tc39.github.io/ecma262/#sec-binary-logical-operators
				Parser.prototype.binaryPrecedence = function (token) {
					var op = token.value;
					var precedence;
					if (token.type === 7 /* Punctuator */) {
							precedence = this.operatorPrecedence[op] || 0;
						} else if (token.type === 4 /* Keyword */) {
							precedence = op === 'instanceof' || this.context.allowIn && op === 'in' ? 7 : 0;
						} else {
						precedence = 0;
					}
					return precedence;
				};
				Parser.prototype.parseBinaryExpression = function () {
					var startToken = this.lookahead;
					var expr = this.inheritCoverGrammar(this.parseExponentiationExpression);
					var token = this.lookahead;
					var prec = this.binaryPrecedence(token);
					if (prec > 0) {
						this.nextToken();
						this.context.isAssignmentTarget = false;
						this.context.isBindingElement = false;
						var markers = [startToken, this.lookahead];
						var left = expr;
						var right = this.isolateCoverGrammar(this.parseExponentiationExpression);
						var stack = [left, token.value, right];
						var precedences = [prec];
						while (true) {
							prec = this.binaryPrecedence(this.lookahead);
							if (prec <= 0) {
								break;
							}
							// Reduce: make a binary expression from the three topmost entries.
							while (stack.length > 2 && prec <= precedences[precedences.length - 1]) {
								right = stack.pop();
								var operator = stack.pop();
								precedences.pop();
								left = stack.pop();
								markers.pop();
								var node = this.startNode(markers[markers.length - 1]);
								stack.push(this.finalize(node, new Node.BinaryExpression(operator, left, right)));
							}
							// Shift.
							stack.push(this.nextToken().value);
							precedences.push(prec);
							markers.push(this.lookahead);
							stack.push(this.isolateCoverGrammar(this.parseExponentiationExpression));
						}
						// Final reduce to clean-up the stack.
						var i = stack.length - 1;
						expr = stack[i];
						markers.pop();
						while (i > 1) {
							var node = this.startNode(markers.pop());
							var operator = stack[i - 1];
							expr = this.finalize(node, new Node.BinaryExpression(operator, stack[i - 2], expr));
							i -= 2;
						}
					}
					return expr;
				};
				// https://tc39.github.io/ecma262/#sec-conditional-operator
				Parser.prototype.parseConditionalExpression = function () {
					var startToken = this.lookahead;
					var expr = this.inheritCoverGrammar(this.parseBinaryExpression);
					if (this.match('?')) {
						this.nextToken();
						var previousAllowIn = this.context.allowIn;
						this.context.allowIn = true;
						var consequent = this.isolateCoverGrammar(this.parseAssignmentExpression);
						this.context.allowIn = previousAllowIn;
						this.expect(':');
						var alternate = this.isolateCoverGrammar(this.parseAssignmentExpression);
						expr = this.finalize(this.startNode(startToken), new Node.ConditionalExpression(expr, consequent, alternate));
						this.context.isAssignmentTarget = false;
						this.context.isBindingElement = false;
					}
					return expr;
				};
				// https://tc39.github.io/ecma262/#sec-assignment-operators
				Parser.prototype.checkPatternParam = function (options, param) {
					switch (param.type) {
						case syntax_1.Syntax.Identifier:
							this.validateParam(options, param, param.name);
							break;
						case syntax_1.Syntax.RestElement:
							this.checkPatternParam(options, param.argument);
							break;
						case syntax_1.Syntax.AssignmentPattern:
							this.checkPatternParam(options, param.left);
							break;
						case syntax_1.Syntax.ArrayPattern:
							for (var i = 0; i < param.elements.length; i++) {
								if (param.elements[i] !== null) {
									this.checkPatternParam(options, param.elements[i]);
								}
							}
							break;
						case syntax_1.Syntax.ObjectPattern:
							for (var i = 0; i < param.properties.length; i++) {
								this.checkPatternParam(options, param.properties[i].value);
							}
							break;
						default:
							break;
					}
					options.simple = options.simple && param instanceof Node.Identifier;
				};
				Parser.prototype.reinterpretAsCoverFormalsList = function (expr) {
					var params = [expr];
					var options;
					var asyncArrow = false;
					switch (expr.type) {
						case syntax_1.Syntax.Identifier:
							break;
						case ArrowParameterPlaceHolder:
							params = expr.params;
							asyncArrow = expr.async;
							break;
						default:
							return null;
					}
					options = {
						simple: true,
						paramSet: {}
					};
					for (var i = 0; i < params.length; ++i) {
						var param = params[i];
						if (param.type === syntax_1.Syntax.AssignmentPattern) {
							if (param.right.type === syntax_1.Syntax.YieldExpression) {
								if (param.right.argument) {
									this.throwUnexpectedToken(this.lookahead);
								}
								param.right.type = syntax_1.Syntax.Identifier;
								param.right.name = 'yield';
								delete param.right.argument;
								delete param.right.delegate;
							}
						} else if (asyncArrow && param.type === syntax_1.Syntax.Identifier && param.name === 'await') {
							this.throwUnexpectedToken(this.lookahead);
						}
						this.checkPatternParam(options, param);
						params[i] = param;
					}
					if (this.context.strict || !this.context.allowYield) {
						for (var i = 0; i < params.length; ++i) {
							var param = params[i];
							if (param.type === syntax_1.Syntax.YieldExpression) {
								this.throwUnexpectedToken(this.lookahead);
							}
						}
					}
					if (options.message === messages_1.Messages.StrictParamDupe) {
						var token = this.context.strict ? options.stricted : options.firstRestricted;
						this.throwUnexpectedToken(token, options.message);
					}
					return {
						simple: options.simple,
						params: params,
						stricted: options.stricted,
						firstRestricted: options.firstRestricted,
						message: options.message
					};
				};
				Parser.prototype.parseAssignmentExpression = function () {
					var expr;
					if (!this.context.allowYield && this.matchKeyword('yield')) {
						expr = this.parseYieldExpression();
					} else {
						var startToken = this.lookahead;
						var token = startToken;
						expr = this.parseConditionalExpression();
						if (token.type === 3 /* Identifier */ && token.lineNumber === this.lookahead.lineNumber && token.value === 'async') {
							if (this.lookahead.type === 3 /* Identifier */ || this.matchKeyword('yield')) {
								var arg = this.parsePrimaryExpression();
								this.reinterpretExpressionAsPattern(arg);
								expr = {
									type: ArrowParameterPlaceHolder,
									params: [arg],
									async: true
								};
							}
						}
						if (expr.type === ArrowParameterPlaceHolder || this.match('=>')) {
							// https://tc39.github.io/ecma262/#sec-arrow-function-definitions
							this.context.isAssignmentTarget = false;
							this.context.isBindingElement = false;
							var isAsync = expr.async;
							var list = this.reinterpretAsCoverFormalsList(expr);
							if (list) {
								if (this.hasLineTerminator) {
									this.tolerateUnexpectedToken(this.lookahead);
								}
								this.context.firstCoverInitializedNameError = null;
								var previousStrict = this.context.strict;
								var previousAllowStrictDirective = this.context.allowStrictDirective;
								this.context.allowStrictDirective = list.simple;
								var previousAllowYield = this.context.allowYield;
								var previousAwait = this.context.await;
								this.context.allowYield = true;
								this.context.await = isAsync;
								var node = this.startNode(startToken);
								this.expect('=>');
								var body = void 0;
								if (this.match('{')) {
									var previousAllowIn = this.context.allowIn;
									this.context.allowIn = true;
									body = this.parseFunctionSourceElements();
									this.context.allowIn = previousAllowIn;
								} else {
									body = this.isolateCoverGrammar(this.parseAssignmentExpression);
								}
								var expression = body.type !== syntax_1.Syntax.BlockStatement;
								if (this.context.strict && list.firstRestricted) {
									this.throwUnexpectedToken(list.firstRestricted, list.message);
								}
								if (this.context.strict && list.stricted) {
									this.tolerateUnexpectedToken(list.stricted, list.message);
								}
								expr = isAsync ? this.finalize(node, new Node.AsyncArrowFunctionExpression(list.params, body, expression)) : this.finalize(node, new Node.ArrowFunctionExpression(list.params, body, expression));
								this.context.strict = previousStrict;
								this.context.allowStrictDirective = previousAllowStrictDirective;
								this.context.allowYield = previousAllowYield;
								this.context.await = previousAwait;
							}
						} else {
							if (this.matchAssign()) {
								if (!this.context.isAssignmentTarget) {
									this.tolerateError(messages_1.Messages.InvalidLHSInAssignment);
								}
								if (this.context.strict && expr.type === syntax_1.Syntax.Identifier) {
									var id = expr;
									if (this.scanner.isRestrictedWord(id.name)) {
										this.tolerateUnexpectedToken(token, messages_1.Messages.StrictLHSAssignment);
									}
									if (this.scanner.isStrictModeReservedWord(id.name)) {
										this.tolerateUnexpectedToken(token, messages_1.Messages.StrictReservedWord);
									}
								}
								if (!this.match('=')) {
									this.context.isAssignmentTarget = false;
									this.context.isBindingElement = false;
								} else {
									this.reinterpretExpressionAsPattern(expr);
								}
								token = this.nextToken();
								var operator = token.value;
								var right = this.isolateCoverGrammar(this.parseAssignmentExpression);
								expr = this.finalize(this.startNode(startToken), new Node.AssignmentExpression(operator, expr, right));
								this.context.firstCoverInitializedNameError = null;
							}
						}
					}
					return expr;
				};
				// https://tc39.github.io/ecma262/#sec-comma-operator
				Parser.prototype.parseExpression = function () {
					var startToken = this.lookahead;
					var expr = this.isolateCoverGrammar(this.parseAssignmentExpression);
					if (this.match(',')) {
						var expressions = [];
						expressions.push(expr);
						while (this.lookahead.type !== 2 /* EOF */) {
							if (!this.match(',')) {
								break;
							}
							this.nextToken();
							expressions.push(this.isolateCoverGrammar(this.parseAssignmentExpression));
						}
						expr = this.finalize(this.startNode(startToken), new Node.SequenceExpression(expressions));
					}
					return expr;
				};
				// https://tc39.github.io/ecma262/#sec-block
				Parser.prototype.parseStatementListItem = function () {
					var statement;
					this.context.isAssignmentTarget = true;
					this.context.isBindingElement = true;
					if (this.lookahead.type === 4 /* Keyword */) {
							switch (this.lookahead.value) {
								case 'export':
									if (!this.context.isModule) {
										this.tolerateUnexpectedToken(this.lookahead, messages_1.Messages.IllegalExportDeclaration);
									}
									statement = this.parseExportDeclaration();
									break;
								case 'import':
									if (!this.context.isModule) {
										this.tolerateUnexpectedToken(this.lookahead, messages_1.Messages.IllegalImportDeclaration);
									}
									statement = this.parseImportDeclaration();
									break;
								case 'const':
									statement = this.parseLexicalDeclaration({ inFor: false });
									break;
								case 'function':
									statement = this.parseFunctionDeclaration();
									break;
								case 'class':
									statement = this.parseClassDeclaration();
									break;
								case 'let':
									statement = this.isLexicalDeclaration() ? this.parseLexicalDeclaration({ inFor: false }) : this.parseStatement();
									break;
								default:
									statement = this.parseStatement();
									break;
							}
						} else {
						statement = this.parseStatement();
					}
					return statement;
				};
				Parser.prototype.parseBlock = function () {
					var node = this.createNode();
					this.expect('{');
					var block = [];
					while (true) {
						if (this.match('}')) {
							break;
						}
						block.push(this.parseStatementListItem());
					}
					this.expect('}');
					return this.finalize(node, new Node.BlockStatement(block));
				};
				// https://tc39.github.io/ecma262/#sec-let-and-const-declarations
				Parser.prototype.parseLexicalBinding = function (kind, options) {
					var node = this.createNode();
					var params = [];
					var id = this.parsePattern(params, kind);
					if (this.context.strict && id.type === syntax_1.Syntax.Identifier) {
						if (this.scanner.isRestrictedWord(id.name)) {
							this.tolerateError(messages_1.Messages.StrictVarName);
						}
					}
					var init = null;
					if (kind === 'const') {
						if (!this.matchKeyword('in') && !this.matchContextualKeyword('of')) {
							if (this.match('=')) {
								this.nextToken();
								init = this.isolateCoverGrammar(this.parseAssignmentExpression);
							} else {
								this.throwError(messages_1.Messages.DeclarationMissingInitializer, 'const');
							}
						}
					} else if (!options.inFor && id.type !== syntax_1.Syntax.Identifier || this.match('=')) {
						this.expect('=');
						init = this.isolateCoverGrammar(this.parseAssignmentExpression);
					}
					return this.finalize(node, new Node.VariableDeclarator(id, init));
				};
				Parser.prototype.parseBindingList = function (kind, options) {
					var list = [this.parseLexicalBinding(kind, options)];
					while (this.match(',')) {
						this.nextToken();
						list.push(this.parseLexicalBinding(kind, options));
					}
					return list;
				};
				Parser.prototype.isLexicalDeclaration = function () {
					var state = this.scanner.saveState();
					this.scanner.scanComments();
					var next = this.scanner.lex();
					this.scanner.restoreState(state);
					return next.type === 3 /* Identifier */ || next.type === 7 /* Punctuator */ && next.value === '[' || next.type === 7 /* Punctuator */ && next.value === '{' || next.type === 4 /* Keyword */ && next.value === 'let' || next.type === 4 /* Keyword */ && next.value === 'yield';
				};
				Parser.prototype.parseLexicalDeclaration = function (options) {
					var node = this.createNode();
					var kind = this.nextToken().value;
					assert_1.assert(kind === 'let' || kind === 'const', 'Lexical declaration must be either let or const');
					var declarations = this.parseBindingList(kind, options);
					this.consumeSemicolon();
					return this.finalize(node, new Node.VariableDeclaration(declarations, kind));
				};
				// https://tc39.github.io/ecma262/#sec-destructuring-binding-patterns
				Parser.prototype.parseBindingRestElement = function (params, kind) {
					var node = this.createNode();
					this.expect('...');
					var arg = this.parsePattern(params, kind);
					return this.finalize(node, new Node.RestElement(arg));
				};
				Parser.prototype.parseArrayPattern = function (params, kind) {
					var node = this.createNode();
					this.expect('[');
					var elements = [];
					while (!this.match(']')) {
						if (this.match(',')) {
							this.nextToken();
							elements.push(null);
						} else {
							if (this.match('...')) {
								elements.push(this.parseBindingRestElement(params, kind));
								break;
							} else {
								elements.push(this.parsePatternWithDefault(params, kind));
							}
							if (!this.match(']')) {
								this.expect(',');
							}
						}
					}
					this.expect(']');
					return this.finalize(node, new Node.ArrayPattern(elements));
				};
				Parser.prototype.parsePropertyPattern = function (params, kind) {
					var node = this.createNode();
					var computed = false;
					var shorthand = false;
					var method = false;
					var key;
					var value;
					if (this.lookahead.type === 3 /* Identifier */) {
							var keyToken = this.lookahead;
							key = this.parseVariableIdentifier();
							var init = this.finalize(node, new Node.Identifier(keyToken.value));
							if (this.match('=')) {
								params.push(keyToken);
								shorthand = true;
								this.nextToken();
								var expr = this.parseAssignmentExpression();
								value = this.finalize(this.startNode(keyToken), new Node.AssignmentPattern(init, expr));
							} else if (!this.match(':')) {
								params.push(keyToken);
								shorthand = true;
								value = init;
							} else {
								this.expect(':');
								value = this.parsePatternWithDefault(params, kind);
							}
						} else {
						computed = this.match('[');
						key = this.parseObjectPropertyKey();
						this.expect(':');
						value = this.parsePatternWithDefault(params, kind);
					}
					return this.finalize(node, new Node.Property('init', key, computed, value, method, shorthand));
				};
				Parser.prototype.parseObjectPattern = function (params, kind) {
					var node = this.createNode();
					var properties = [];
					this.expect('{');
					while (!this.match('}')) {
						properties.push(this.parsePropertyPattern(params, kind));
						if (!this.match('}')) {
							this.expect(',');
						}
					}
					this.expect('}');
					return this.finalize(node, new Node.ObjectPattern(properties));
				};
				Parser.prototype.parsePattern = function (params, kind) {
					var pattern;
					if (this.match('[')) {
						pattern = this.parseArrayPattern(params, kind);
					} else if (this.match('{')) {
						pattern = this.parseObjectPattern(params, kind);
					} else {
						if (this.matchKeyword('let') && (kind === 'const' || kind === 'let')) {
							this.tolerateUnexpectedToken(this.lookahead, messages_1.Messages.LetInLexicalBinding);
						}
						params.push(this.lookahead);
						pattern = this.parseVariableIdentifier(kind);
					}
					return pattern;
				};
				Parser.prototype.parsePatternWithDefault = function (params, kind) {
					var startToken = this.lookahead;
					var pattern = this.parsePattern(params, kind);
					if (this.match('=')) {
						this.nextToken();
						var previousAllowYield = this.context.allowYield;
						this.context.allowYield = true;
						var right = this.isolateCoverGrammar(this.parseAssignmentExpression);
						this.context.allowYield = previousAllowYield;
						pattern = this.finalize(this.startNode(startToken), new Node.AssignmentPattern(pattern, right));
					}
					return pattern;
				};
				// https://tc39.github.io/ecma262/#sec-variable-statement
				Parser.prototype.parseVariableIdentifier = function (kind) {
					var node = this.createNode();
					var token = this.nextToken();
					if (token.type === 4 /* Keyword */ && token.value === 'yield') {
						if (this.context.strict) {
							this.tolerateUnexpectedToken(token, messages_1.Messages.StrictReservedWord);
						} else if (!this.context.allowYield) {
							this.throwUnexpectedToken(token);
						}
					} else if (token.type !== 3 /* Identifier */) {
							if (this.context.strict && token.type === 4 /* Keyword */ && this.scanner.isStrictModeReservedWord(token.value)) {
								this.tolerateUnexpectedToken(token, messages_1.Messages.StrictReservedWord);
							} else {
								if (this.context.strict || token.value !== 'let' || kind !== 'var') {
									this.throwUnexpectedToken(token);
								}
							}
						} else if ((this.context.isModule || this.context.await) && token.type === 3 /* Identifier */ && token.value === 'await') {
						this.tolerateUnexpectedToken(token);
					}
					return this.finalize(node, new Node.Identifier(token.value));
				};
				Parser.prototype.parseVariableDeclaration = function (options) {
					var node = this.createNode();
					var params = [];
					var id = this.parsePattern(params, 'var');
					if (this.context.strict && id.type === syntax_1.Syntax.Identifier) {
						if (this.scanner.isRestrictedWord(id.name)) {
							this.tolerateError(messages_1.Messages.StrictVarName);
						}
					}
					var init = null;
					if (this.match('=')) {
						this.nextToken();
						init = this.isolateCoverGrammar(this.parseAssignmentExpression);
					} else if (id.type !== syntax_1.Syntax.Identifier && !options.inFor) {
						this.expect('=');
					}
					return this.finalize(node, new Node.VariableDeclarator(id, init));
				};
				Parser.prototype.parseVariableDeclarationList = function (options) {
					var opt = { inFor: options.inFor };
					var list = [];
					list.push(this.parseVariableDeclaration(opt));
					while (this.match(',')) {
						this.nextToken();
						list.push(this.parseVariableDeclaration(opt));
					}
					return list;
				};
				Parser.prototype.parseVariableStatement = function () {
					var node = this.createNode();
					this.expectKeyword('var');
					var declarations = this.parseVariableDeclarationList({ inFor: false });
					this.consumeSemicolon();
					return this.finalize(node, new Node.VariableDeclaration(declarations, 'var'));
				};
				// https://tc39.github.io/ecma262/#sec-empty-statement
				Parser.prototype.parseEmptyStatement = function () {
					var node = this.createNode();
					this.expect(';');
					return this.finalize(node, new Node.EmptyStatement());
				};
				// https://tc39.github.io/ecma262/#sec-expression-statement
				Parser.prototype.parseExpressionStatement = function () {
					var node = this.createNode();
					var expr = this.parseExpression();
					this.consumeSemicolon();
					return this.finalize(node, new Node.ExpressionStatement(expr));
				};
				// https://tc39.github.io/ecma262/#sec-if-statement
				Parser.prototype.parseIfClause = function () {
					if (this.context.strict && this.matchKeyword('function')) {
						this.tolerateError(messages_1.Messages.StrictFunction);
					}
					return this.parseStatement();
				};
				Parser.prototype.parseIfStatement = function () {
					var node = this.createNode();
					var consequent;
					var alternate = null;
					this.expectKeyword('if');
					this.expect('(');
					var test = this.parseExpression();
					if (!this.match(')') && this.config.tolerant) {
						this.tolerateUnexpectedToken(this.nextToken());
						consequent = this.finalize(this.createNode(), new Node.EmptyStatement());
					} else {
						this.expect(')');
						consequent = this.parseIfClause();
						if (this.matchKeyword('else')) {
							this.nextToken();
							alternate = this.parseIfClause();
						}
					}
					return this.finalize(node, new Node.IfStatement(test, consequent, alternate));
				};
				// https://tc39.github.io/ecma262/#sec-do-while-statement
				Parser.prototype.parseDoWhileStatement = function () {
					var node = this.createNode();
					this.expectKeyword('do');
					var previousInIteration = this.context.inIteration;
					this.context.inIteration = true;
					var body = this.parseStatement();
					this.context.inIteration = previousInIteration;
					this.expectKeyword('while');
					this.expect('(');
					var test = this.parseExpression();
					if (!this.match(')') && this.config.tolerant) {
						this.tolerateUnexpectedToken(this.nextToken());
					} else {
						this.expect(')');
						if (this.match(';')) {
							this.nextToken();
						}
					}
					return this.finalize(node, new Node.DoWhileStatement(body, test));
				};
				// https://tc39.github.io/ecma262/#sec-while-statement
				Parser.prototype.parseWhileStatement = function () {
					var node = this.createNode();
					var body;
					this.expectKeyword('while');
					this.expect('(');
					var test = this.parseExpression();
					if (!this.match(')') && this.config.tolerant) {
						this.tolerateUnexpectedToken(this.nextToken());
						body = this.finalize(this.createNode(), new Node.EmptyStatement());
					} else {
						this.expect(')');
						var previousInIteration = this.context.inIteration;
						this.context.inIteration = true;
						body = this.parseStatement();
						this.context.inIteration = previousInIteration;
					}
					return this.finalize(node, new Node.WhileStatement(test, body));
				};
				// https://tc39.github.io/ecma262/#sec-for-statement
				// https://tc39.github.io/ecma262/#sec-for-in-and-for-of-statements
				Parser.prototype.parseForStatement = function () {
					var init = null;
					var test = null;
					var update = null;
					var forIn = true;
					var left, right;
					var node = this.createNode();
					this.expectKeyword('for');
					this.expect('(');
					if (this.match(';')) {
						this.nextToken();
					} else {
						if (this.matchKeyword('var')) {
							init = this.createNode();
							this.nextToken();
							var previousAllowIn = this.context.allowIn;
							this.context.allowIn = false;
							var declarations = this.parseVariableDeclarationList({ inFor: true });
							this.context.allowIn = previousAllowIn;
							if (declarations.length === 1 && this.matchKeyword('in')) {
								var decl = declarations[0];
								if (decl.init && (decl.id.type === syntax_1.Syntax.ArrayPattern || decl.id.type === syntax_1.Syntax.ObjectPattern || this.context.strict)) {
									this.tolerateError(messages_1.Messages.ForInOfLoopInitializer, 'for-in');
								}
								init = this.finalize(init, new Node.VariableDeclaration(declarations, 'var'));
								this.nextToken();
								left = init;
								right = this.parseExpression();
								init = null;
							} else if (declarations.length === 1 && declarations[0].init === null && this.matchContextualKeyword('of')) {
								init = this.finalize(init, new Node.VariableDeclaration(declarations, 'var'));
								this.nextToken();
								left = init;
								right = this.parseAssignmentExpression();
								init = null;
								forIn = false;
							} else {
								init = this.finalize(init, new Node.VariableDeclaration(declarations, 'var'));
								this.expect(';');
							}
						} else if (this.matchKeyword('const') || this.matchKeyword('let')) {
							init = this.createNode();
							var kind = this.nextToken().value;
							if (!this.context.strict && this.lookahead.value === 'in') {
								init = this.finalize(init, new Node.Identifier(kind));
								this.nextToken();
								left = init;
								right = this.parseExpression();
								init = null;
							} else {
								var previousAllowIn = this.context.allowIn;
								this.context.allowIn = false;
								var declarations = this.parseBindingList(kind, { inFor: true });
								this.context.allowIn = previousAllowIn;
								if (declarations.length === 1 && declarations[0].init === null && this.matchKeyword('in')) {
									init = this.finalize(init, new Node.VariableDeclaration(declarations, kind));
									this.nextToken();
									left = init;
									right = this.parseExpression();
									init = null;
								} else if (declarations.length === 1 && declarations[0].init === null && this.matchContextualKeyword('of')) {
									init = this.finalize(init, new Node.VariableDeclaration(declarations, kind));
									this.nextToken();
									left = init;
									right = this.parseAssignmentExpression();
									init = null;
									forIn = false;
								} else {
									this.consumeSemicolon();
									init = this.finalize(init, new Node.VariableDeclaration(declarations, kind));
								}
							}
						} else {
							var initStartToken = this.lookahead;
							var previousAllowIn = this.context.allowIn;
							this.context.allowIn = false;
							init = this.inheritCoverGrammar(this.parseAssignmentExpression);
							this.context.allowIn = previousAllowIn;
							if (this.matchKeyword('in')) {
								if (!this.context.isAssignmentTarget || init.type === syntax_1.Syntax.AssignmentExpression) {
									this.tolerateError(messages_1.Messages.InvalidLHSInForIn);
								}
								this.nextToken();
								this.reinterpretExpressionAsPattern(init);
								left = init;
								right = this.parseExpression();
								init = null;
							} else if (this.matchContextualKeyword('of')) {
								if (!this.context.isAssignmentTarget || init.type === syntax_1.Syntax.AssignmentExpression) {
									this.tolerateError(messages_1.Messages.InvalidLHSInForLoop);
								}
								this.nextToken();
								this.reinterpretExpressionAsPattern(init);
								left = init;
								right = this.parseAssignmentExpression();
								init = null;
								forIn = false;
							} else {
								if (this.match(',')) {
									var initSeq = [init];
									while (this.match(',')) {
										this.nextToken();
										initSeq.push(this.isolateCoverGrammar(this.parseAssignmentExpression));
									}
									init = this.finalize(this.startNode(initStartToken), new Node.SequenceExpression(initSeq));
								}
								this.expect(';');
							}
						}
					}
					if (typeof left === 'undefined') {
						if (!this.match(';')) {
							test = this.parseExpression();
						}
						this.expect(';');
						if (!this.match(')')) {
							update = this.parseExpression();
						}
					}
					var body;
					if (!this.match(')') && this.config.tolerant) {
						this.tolerateUnexpectedToken(this.nextToken());
						body = this.finalize(this.createNode(), new Node.EmptyStatement());
					} else {
						this.expect(')');
						var previousInIteration = this.context.inIteration;
						this.context.inIteration = true;
						body = this.isolateCoverGrammar(this.parseStatement);
						this.context.inIteration = previousInIteration;
					}
					return typeof left === 'undefined' ? this.finalize(node, new Node.ForStatement(init, test, update, body)) : forIn ? this.finalize(node, new Node.ForInStatement(left, right, body)) : this.finalize(node, new Node.ForOfStatement(left, right, body));
				};
				// https://tc39.github.io/ecma262/#sec-continue-statement
				Parser.prototype.parseContinueStatement = function () {
					var node = this.createNode();
					this.expectKeyword('continue');
					var label = null;
					if (this.lookahead.type === 3 /* Identifier */ && !this.hasLineTerminator) {
						var id = this.parseVariableIdentifier();
						label = id;
						var key = '$' + id.name;
						if (!Object.prototype.hasOwnProperty.call(this.context.labelSet, key)) {
							this.throwError(messages_1.Messages.UnknownLabel, id.name);
						}
					}
					this.consumeSemicolon();
					if (label === null && !this.context.inIteration) {
						this.throwError(messages_1.Messages.IllegalContinue);
					}
					return this.finalize(node, new Node.ContinueStatement(label));
				};
				// https://tc39.github.io/ecma262/#sec-break-statement
				Parser.prototype.parseBreakStatement = function () {
					var node = this.createNode();
					this.expectKeyword('break');
					var label = null;
					if (this.lookahead.type === 3 /* Identifier */ && !this.hasLineTerminator) {
						var id = this.parseVariableIdentifier();
						var key = '$' + id.name;
						if (!Object.prototype.hasOwnProperty.call(this.context.labelSet, key)) {
							this.throwError(messages_1.Messages.UnknownLabel, id.name);
						}
						label = id;
					}
					this.consumeSemicolon();
					if (label === null && !this.context.inIteration && !this.context.inSwitch) {
						this.throwError(messages_1.Messages.IllegalBreak);
					}
					return this.finalize(node, new Node.BreakStatement(label));
				};
				// https://tc39.github.io/ecma262/#sec-return-statement
				Parser.prototype.parseReturnStatement = function () {
					if (!this.context.inFunctionBody) {
						this.tolerateError(messages_1.Messages.IllegalReturn);
					}
					var node = this.createNode();
					this.expectKeyword('return');
					var hasArgument = !this.match(';') && !this.match('}') && !this.hasLineTerminator && this.lookahead.type !== 2 /* EOF */;
					var argument = hasArgument ? this.parseExpression() : null;
					this.consumeSemicolon();
					return this.finalize(node, new Node.ReturnStatement(argument));
				};
				// https://tc39.github.io/ecma262/#sec-with-statement
				Parser.prototype.parseWithStatement = function () {
					if (this.context.strict) {
						this.tolerateError(messages_1.Messages.StrictModeWith);
					}
					var node = this.createNode();
					var body;
					this.expectKeyword('with');
					this.expect('(');
					var object = this.parseExpression();
					if (!this.match(')') && this.config.tolerant) {
						this.tolerateUnexpectedToken(this.nextToken());
						body = this.finalize(this.createNode(), new Node.EmptyStatement());
					} else {
						this.expect(')');
						body = this.parseStatement();
					}
					return this.finalize(node, new Node.WithStatement(object, body));
				};
				// https://tc39.github.io/ecma262/#sec-switch-statement
				Parser.prototype.parseSwitchCase = function () {
					var node = this.createNode();
					var test;
					if (this.matchKeyword('default')) {
						this.nextToken();
						test = null;
					} else {
						this.expectKeyword('case');
						test = this.parseExpression();
					}
					this.expect(':');
					var consequent = [];
					while (true) {
						if (this.match('}') || this.matchKeyword('default') || this.matchKeyword('case')) {
							break;
						}
						consequent.push(this.parseStatementListItem());
					}
					return this.finalize(node, new Node.SwitchCase(test, consequent));
				};
				Parser.prototype.parseSwitchStatement = function () {
					var node = this.createNode();
					this.expectKeyword('switch');
					this.expect('(');
					var discriminant = this.parseExpression();
					this.expect(')');
					var previousInSwitch = this.context.inSwitch;
					this.context.inSwitch = true;
					var cases = [];
					var defaultFound = false;
					this.expect('{');
					while (true) {
						if (this.match('}')) {
							break;
						}
						var clause = this.parseSwitchCase();
						if (clause.test === null) {
							if (defaultFound) {
								this.throwError(messages_1.Messages.MultipleDefaultsInSwitch);
							}
							defaultFound = true;
						}
						cases.push(clause);
					}
					this.expect('}');
					this.context.inSwitch = previousInSwitch;
					return this.finalize(node, new Node.SwitchStatement(discriminant, cases));
				};
				// https://tc39.github.io/ecma262/#sec-labelled-statements
				Parser.prototype.parseLabelledStatement = function () {
					var node = this.createNode();
					var expr = this.parseExpression();
					var statement;
					if (expr.type === syntax_1.Syntax.Identifier && this.match(':')) {
						this.nextToken();
						var id = expr;
						var key = '$' + id.name;
						if (Object.prototype.hasOwnProperty.call(this.context.labelSet, key)) {
							this.throwError(messages_1.Messages.Redeclaration, 'Label', id.name);
						}
						this.context.labelSet[key] = true;
						var body = void 0;
						if (this.matchKeyword('class')) {
							this.tolerateUnexpectedToken(this.lookahead);
							body = this.parseClassDeclaration();
						} else if (this.matchKeyword('function')) {
							var token = this.lookahead;
							var declaration = this.parseFunctionDeclaration();
							if (this.context.strict) {
								this.tolerateUnexpectedToken(token, messages_1.Messages.StrictFunction);
							} else if (declaration.generator) {
								this.tolerateUnexpectedToken(token, messages_1.Messages.GeneratorInLegacyContext);
							}
							body = declaration;
						} else {
							body = this.parseStatement();
						}
						delete this.context.labelSet[key];
						statement = new Node.LabeledStatement(id, body);
					} else {
						this.consumeSemicolon();
						statement = new Node.ExpressionStatement(expr);
					}
					return this.finalize(node, statement);
				};
				// https://tc39.github.io/ecma262/#sec-throw-statement
				Parser.prototype.parseThrowStatement = function () {
					var node = this.createNode();
					this.expectKeyword('throw');
					if (this.hasLineTerminator) {
						this.throwError(messages_1.Messages.NewlineAfterThrow);
					}
					var argument = this.parseExpression();
					this.consumeSemicolon();
					return this.finalize(node, new Node.ThrowStatement(argument));
				};
				// https://tc39.github.io/ecma262/#sec-try-statement
				Parser.prototype.parseCatchClause = function () {
					var node = this.createNode();
					this.expectKeyword('catch');
					this.expect('(');
					if (this.match(')')) {
						this.throwUnexpectedToken(this.lookahead);
					}
					var params = [];
					var param = this.parsePattern(params);
					var paramMap = {};
					for (var i = 0; i < params.length; i++) {
						var key = '$' + params[i].value;
						if (Object.prototype.hasOwnProperty.call(paramMap, key)) {
							this.tolerateError(messages_1.Messages.DuplicateBinding, params[i].value);
						}
						paramMap[key] = true;
					}
					if (this.context.strict && param.type === syntax_1.Syntax.Identifier) {
						if (this.scanner.isRestrictedWord(param.name)) {
							this.tolerateError(messages_1.Messages.StrictCatchVariable);
						}
					}
					this.expect(')');
					var body = this.parseBlock();
					return this.finalize(node, new Node.CatchClause(param, body));
				};
				Parser.prototype.parseFinallyClause = function () {
					this.expectKeyword('finally');
					return this.parseBlock();
				};
				Parser.prototype.parseTryStatement = function () {
					var node = this.createNode();
					this.expectKeyword('try');
					var block = this.parseBlock();
					var handler = this.matchKeyword('catch') ? this.parseCatchClause() : null;
					var finalizer = this.matchKeyword('finally') ? this.parseFinallyClause() : null;
					if (!handler && !finalizer) {
						this.throwError(messages_1.Messages.NoCatchOrFinally);
					}
					return this.finalize(node, new Node.TryStatement(block, handler, finalizer));
				};
				// https://tc39.github.io/ecma262/#sec-debugger-statement
				Parser.prototype.parseDebuggerStatement = function () {
					var node = this.createNode();
					this.expectKeyword('debugger');
					this.consumeSemicolon();
					return this.finalize(node, new Node.DebuggerStatement());
				};
				// https://tc39.github.io/ecma262/#sec-ecmascript-language-statements-and-declarations
				Parser.prototype.parseStatement = function () {
					var statement;
					switch (this.lookahead.type) {
						case 1 /* BooleanLiteral */:
						case 5 /* NullLiteral */:
						case 6 /* NumericLiteral */:
						case 8 /* StringLiteral */:
						case 10 /* Template */:
						case 9 /* RegularExpression */:
							statement = this.parseExpressionStatement();
							break;
						case 7 /* Punctuator */:
							var value = this.lookahead.value;
							if (value === '{') {
								statement = this.parseBlock();
							} else if (value === '(') {
								statement = this.parseExpressionStatement();
							} else if (value === ';') {
								statement = this.parseEmptyStatement();
							} else {
								statement = this.parseExpressionStatement();
							}
							break;
						case 3 /* Identifier */:
							statement = this.matchAsyncFunction() ? this.parseFunctionDeclaration() : this.parseLabelledStatement();
							break;
						case 4 /* Keyword */:
							switch (this.lookahead.value) {
								case 'break':
									statement = this.parseBreakStatement();
									break;
								case 'continue':
									statement = this.parseContinueStatement();
									break;
								case 'debugger':
									statement = this.parseDebuggerStatement();
									break;
								case 'do':
									statement = this.parseDoWhileStatement();
									break;
								case 'for':
									statement = this.parseForStatement();
									break;
								case 'function':
									statement = this.parseFunctionDeclaration();
									break;
								case 'if':
									statement = this.parseIfStatement();
									break;
								case 'return':
									statement = this.parseReturnStatement();
									break;
								case 'switch':
									statement = this.parseSwitchStatement();
									break;
								case 'throw':
									statement = this.parseThrowStatement();
									break;
								case 'try':
									statement = this.parseTryStatement();
									break;
								case 'var':
									statement = this.parseVariableStatement();
									break;
								case 'while':
									statement = this.parseWhileStatement();
									break;
								case 'with':
									statement = this.parseWithStatement();
									break;
								default:
									statement = this.parseExpressionStatement();
									break;
							}
							break;
						default:
							statement = this.throwUnexpectedToken(this.lookahead);
					}
					return statement;
				};
				// https://tc39.github.io/ecma262/#sec-function-definitions
				Parser.prototype.parseFunctionSourceElements = function () {
					var node = this.createNode();
					this.expect('{');
					var body = this.parseDirectivePrologues();
					var previousLabelSet = this.context.labelSet;
					var previousInIteration = this.context.inIteration;
					var previousInSwitch = this.context.inSwitch;
					var previousInFunctionBody = this.context.inFunctionBody;
					this.context.labelSet = {};
					this.context.inIteration = false;
					this.context.inSwitch = false;
					this.context.inFunctionBody = true;
					while (this.lookahead.type !== 2 /* EOF */) {
						if (this.match('}')) {
							break;
						}
						body.push(this.parseStatementListItem());
					}
					this.expect('}');
					this.context.labelSet = previousLabelSet;
					this.context.inIteration = previousInIteration;
					this.context.inSwitch = previousInSwitch;
					this.context.inFunctionBody = previousInFunctionBody;
					return this.finalize(node, new Node.BlockStatement(body));
				};
				Parser.prototype.validateParam = function (options, param, name) {
					var key = '$' + name;
					if (this.context.strict) {
						if (this.scanner.isRestrictedWord(name)) {
							options.stricted = param;
							options.message = messages_1.Messages.StrictParamName;
						}
						if (Object.prototype.hasOwnProperty.call(options.paramSet, key)) {
							options.stricted = param;
							options.message = messages_1.Messages.StrictParamDupe;
						}
					} else if (!options.firstRestricted) {
						if (this.scanner.isRestrictedWord(name)) {
							options.firstRestricted = param;
							options.message = messages_1.Messages.StrictParamName;
						} else if (this.scanner.isStrictModeReservedWord(name)) {
							options.firstRestricted = param;
							options.message = messages_1.Messages.StrictReservedWord;
						} else if (Object.prototype.hasOwnProperty.call(options.paramSet, key)) {
							options.stricted = param;
							options.message = messages_1.Messages.StrictParamDupe;
						}
					}
					/* istanbul ignore next */
					if (typeof Object.defineProperty === 'function') {
						Object.defineProperty(options.paramSet, key, { value: true, enumerable: true, writable: true, configurable: true });
					} else {
						options.paramSet[key] = true;
					}
				};
				Parser.prototype.parseRestElement = function (params) {
					var node = this.createNode();
					this.expect('...');
					var arg = this.parsePattern(params);
					if (this.match('=')) {
						this.throwError(messages_1.Messages.DefaultRestParameter);
					}
					if (!this.match(')')) {
						this.throwError(messages_1.Messages.ParameterAfterRestParameter);
					}
					return this.finalize(node, new Node.RestElement(arg));
				};
				Parser.prototype.parseFormalParameter = function (options) {
					var params = [];
					var param = this.match('...') ? this.parseRestElement(params) : this.parsePatternWithDefault(params);
					for (var i = 0; i < params.length; i++) {
						this.validateParam(options, params[i], params[i].value);
					}
					options.simple = options.simple && param instanceof Node.Identifier;
					options.params.push(param);
				};
				Parser.prototype.parseFormalParameters = function (firstRestricted) {
					var options;
					options = {
						simple: true,
						params: [],
						firstRestricted: firstRestricted
					};
					this.expect('(');
					if (!this.match(')')) {
						options.paramSet = {};
						while (this.lookahead.type !== 2 /* EOF */) {
							this.parseFormalParameter(options);
							if (this.match(')')) {
								break;
							}
							this.expect(',');
							if (this.match(')')) {
								break;
							}
						}
					}
					this.expect(')');
					return {
						simple: options.simple,
						params: options.params,
						stricted: options.stricted,
						firstRestricted: options.firstRestricted,
						message: options.message
					};
				};
				Parser.prototype.matchAsyncFunction = function () {
					var match = this.matchContextualKeyword('async');
					if (match) {
						var state = this.scanner.saveState();
						this.scanner.scanComments();
						var next = this.scanner.lex();
						this.scanner.restoreState(state);
						match = state.lineNumber === next.lineNumber && next.type === 4 /* Keyword */ && next.value === 'function';
					}
					return match;
				};
				Parser.prototype.parseFunctionDeclaration = function (identifierIsOptional) {
					var node = this.createNode();
					var isAsync = this.matchContextualKeyword('async');
					if (isAsync) {
						this.nextToken();
					}
					this.expectKeyword('function');
					var isGenerator = isAsync ? false : this.match('*');
					if (isGenerator) {
						this.nextToken();
					}
					var message;
					var id = null;
					var firstRestricted = null;
					if (!identifierIsOptional || !this.match('(')) {
						var token = this.lookahead;
						id = this.parseVariableIdentifier();
						if (this.context.strict) {
							if (this.scanner.isRestrictedWord(token.value)) {
								this.tolerateUnexpectedToken(token, messages_1.Messages.StrictFunctionName);
							}
						} else {
							if (this.scanner.isRestrictedWord(token.value)) {
								firstRestricted = token;
								message = messages_1.Messages.StrictFunctionName;
							} else if (this.scanner.isStrictModeReservedWord(token.value)) {
								firstRestricted = token;
								message = messages_1.Messages.StrictReservedWord;
							}
						}
					}
					var previousAllowAwait = this.context.await;
					var previousAllowYield = this.context.allowYield;
					this.context.await = isAsync;
					this.context.allowYield = !isGenerator;
					var formalParameters = this.parseFormalParameters(firstRestricted);
					var params = formalParameters.params;
					var stricted = formalParameters.stricted;
					firstRestricted = formalParameters.firstRestricted;
					if (formalParameters.message) {
						message = formalParameters.message;
					}
					var previousStrict = this.context.strict;
					var previousAllowStrictDirective = this.context.allowStrictDirective;
					this.context.allowStrictDirective = formalParameters.simple;
					var body = this.parseFunctionSourceElements();
					if (this.context.strict && firstRestricted) {
						this.throwUnexpectedToken(firstRestricted, message);
					}
					if (this.context.strict && stricted) {
						this.tolerateUnexpectedToken(stricted, message);
					}
					this.context.strict = previousStrict;
					this.context.allowStrictDirective = previousAllowStrictDirective;
					this.context.await = previousAllowAwait;
					this.context.allowYield = previousAllowYield;
					return isAsync ? this.finalize(node, new Node.AsyncFunctionDeclaration(id, params, body)) : this.finalize(node, new Node.FunctionDeclaration(id, params, body, isGenerator));
				};
				Parser.prototype.parseFunctionExpression = function () {
					var node = this.createNode();
					var isAsync = this.matchContextualKeyword('async');
					if (isAsync) {
						this.nextToken();
					}
					this.expectKeyword('function');
					var isGenerator = isAsync ? false : this.match('*');
					if (isGenerator) {
						this.nextToken();
					}
					var message;
					var id = null;
					var firstRestricted;
					var previousAllowAwait = this.context.await;
					var previousAllowYield = this.context.allowYield;
					this.context.await = isAsync;
					this.context.allowYield = !isGenerator;
					if (!this.match('(')) {
						var token = this.lookahead;
						id = !this.context.strict && !isGenerator && this.matchKeyword('yield') ? this.parseIdentifierName() : this.parseVariableIdentifier();
						if (this.context.strict) {
							if (this.scanner.isRestrictedWord(token.value)) {
								this.tolerateUnexpectedToken(token, messages_1.Messages.StrictFunctionName);
							}
						} else {
							if (this.scanner.isRestrictedWord(token.value)) {
								firstRestricted = token;
								message = messages_1.Messages.StrictFunctionName;
							} else if (this.scanner.isStrictModeReservedWord(token.value)) {
								firstRestricted = token;
								message = messages_1.Messages.StrictReservedWord;
							}
						}
					}
					var formalParameters = this.parseFormalParameters(firstRestricted);
					var params = formalParameters.params;
					var stricted = formalParameters.stricted;
					firstRestricted = formalParameters.firstRestricted;
					if (formalParameters.message) {
						message = formalParameters.message;
					}
					var previousStrict = this.context.strict;
					var previousAllowStrictDirective = this.context.allowStrictDirective;
					this.context.allowStrictDirective = formalParameters.simple;
					var body = this.parseFunctionSourceElements();
					if (this.context.strict && firstRestricted) {
						this.throwUnexpectedToken(firstRestricted, message);
					}
					if (this.context.strict && stricted) {
						this.tolerateUnexpectedToken(stricted, message);
					}
					this.context.strict = previousStrict;
					this.context.allowStrictDirective = previousAllowStrictDirective;
					this.context.await = previousAllowAwait;
					this.context.allowYield = previousAllowYield;
					return isAsync ? this.finalize(node, new Node.AsyncFunctionExpression(id, params, body)) : this.finalize(node, new Node.FunctionExpression(id, params, body, isGenerator));
				};
				// https://tc39.github.io/ecma262/#sec-directive-prologues-and-the-use-strict-directive
				Parser.prototype.parseDirective = function () {
					var token = this.lookahead;
					var node = this.createNode();
					var expr = this.parseExpression();
					var directive = expr.type === syntax_1.Syntax.Literal ? this.getTokenRaw(token).slice(1, -1) : null;
					this.consumeSemicolon();
					return this.finalize(node, directive ? new Node.Directive(expr, directive) : new Node.ExpressionStatement(expr));
				};
				Parser.prototype.parseDirectivePrologues = function () {
					var firstRestricted = null;
					var body = [];
					while (true) {
						var token = this.lookahead;
						if (token.type !== 8 /* StringLiteral */) {
								break;
							}
						var statement = this.parseDirective();
						body.push(statement);
						var directive = statement.directive;
						if (typeof directive !== 'string') {
							break;
						}
						if (directive === 'use strict') {
							this.context.strict = true;
							if (firstRestricted) {
								this.tolerateUnexpectedToken(firstRestricted, messages_1.Messages.StrictOctalLiteral);
							}
							if (!this.context.allowStrictDirective) {
								this.tolerateUnexpectedToken(token, messages_1.Messages.IllegalLanguageModeDirective);
							}
						} else {
							if (!firstRestricted && token.octal) {
								firstRestricted = token;
							}
						}
					}
					return body;
				};
				// https://tc39.github.io/ecma262/#sec-method-definitions
				Parser.prototype.qualifiedPropertyName = function (token) {
					switch (token.type) {
						case 3 /* Identifier */:
						case 8 /* StringLiteral */:
						case 1 /* BooleanLiteral */:
						case 5 /* NullLiteral */:
						case 6 /* NumericLiteral */:
						case 4 /* Keyword */:
							return true;
						case 7 /* Punctuator */:
							return token.value === '[';
						default:
							break;
					}
					return false;
				};
				Parser.prototype.parseGetterMethod = function () {
					var node = this.createNode();
					var isGenerator = false;
					var previousAllowYield = this.context.allowYield;
					this.context.allowYield = false;
					var formalParameters = this.parseFormalParameters();
					if (formalParameters.params.length > 0) {
						this.tolerateError(messages_1.Messages.BadGetterArity);
					}
					var method = this.parsePropertyMethod(formalParameters);
					this.context.allowYield = previousAllowYield;
					return this.finalize(node, new Node.FunctionExpression(null, formalParameters.params, method, isGenerator));
				};
				Parser.prototype.parseSetterMethod = function () {
					var node = this.createNode();
					var isGenerator = false;
					var previousAllowYield = this.context.allowYield;
					this.context.allowYield = false;
					var formalParameters = this.parseFormalParameters();
					if (formalParameters.params.length !== 1) {
						this.tolerateError(messages_1.Messages.BadSetterArity);
					} else if (formalParameters.params[0] instanceof Node.RestElement) {
						this.tolerateError(messages_1.Messages.BadSetterRestParameter);
					}
					var method = this.parsePropertyMethod(formalParameters);
					this.context.allowYield = previousAllowYield;
					return this.finalize(node, new Node.FunctionExpression(null, formalParameters.params, method, isGenerator));
				};
				Parser.prototype.parseGeneratorMethod = function () {
					var node = this.createNode();
					var isGenerator = true;
					var previousAllowYield = this.context.allowYield;
					this.context.allowYield = true;
					var params = this.parseFormalParameters();
					this.context.allowYield = false;
					var method = this.parsePropertyMethod(params);
					this.context.allowYield = previousAllowYield;
					return this.finalize(node, new Node.FunctionExpression(null, params.params, method, isGenerator));
				};
				// https://tc39.github.io/ecma262/#sec-generator-function-definitions
				Parser.prototype.isStartOfExpression = function () {
					var start = true;
					var value = this.lookahead.value;
					switch (this.lookahead.type) {
						case 7 /* Punctuator */:
							start = value === '[' || value === '(' || value === '{' || value === '+' || value === '-' || value === '!' || value === '~' || value === '++' || value === '--' || value === '/' || value === '/='; // regular expression literal
							break;
						case 4 /* Keyword */:
							start = value === 'class' || value === 'delete' || value === 'function' || value === 'let' || value === 'new' || value === 'super' || value === 'this' || value === 'typeof' || value === 'void' || value === 'yield';
							break;
						default:
							break;
					}
					return start;
				};
				Parser.prototype.parseYieldExpression = function () {
					var node = this.createNode();
					this.expectKeyword('yield');
					var argument = null;
					var delegate = false;
					if (!this.hasLineTerminator) {
						var previousAllowYield = this.context.allowYield;
						this.context.allowYield = false;
						delegate = this.match('*');
						if (delegate) {
							this.nextToken();
							argument = this.parseAssignmentExpression();
						} else if (this.isStartOfExpression()) {
							argument = this.parseAssignmentExpression();
						}
						this.context.allowYield = previousAllowYield;
					}
					return this.finalize(node, new Node.YieldExpression(argument, delegate));
				};
				// https://tc39.github.io/ecma262/#sec-class-definitions
				Parser.prototype.parseClassElement = function (hasConstructor) {
					var token = this.lookahead;
					var node = this.createNode();
					var kind = '';
					var key = null;
					var value = null;
					var computed = false;
					var method = false;
					var isStatic = false;
					var isAsync = false;
					if (this.match('*')) {
						this.nextToken();
					} else {
						computed = this.match('[');
						key = this.parseObjectPropertyKey();
						var id = key;
						if (id.name === 'static' && (this.qualifiedPropertyName(this.lookahead) || this.match('*'))) {
							token = this.lookahead;
							isStatic = true;
							computed = this.match('[');
							if (this.match('*')) {
								this.nextToken();
							} else {
								key = this.parseObjectPropertyKey();
							}
						}
						if (token.type === 3 /* Identifier */ && !this.hasLineTerminator && token.value === 'async') {
							var punctuator = this.lookahead.value;
							if (punctuator !== ':' && punctuator !== '(' && punctuator !== '*') {
								isAsync = true;
								token = this.lookahead;
								key = this.parseObjectPropertyKey();
								if (token.type === 3 /* Identifier */) {
										if (token.value === 'get' || token.value === 'set') {
											this.tolerateUnexpectedToken(token);
										} else if (token.value === 'constructor') {
											this.tolerateUnexpectedToken(token, messages_1.Messages.ConstructorIsAsync);
										}
									}
							}
						}
					}
					var lookaheadPropertyKey = this.qualifiedPropertyName(this.lookahead);
					if (token.type === 3 /* Identifier */) {
							if (token.value === 'get' && lookaheadPropertyKey) {
								kind = 'get';
								computed = this.match('[');
								key = this.parseObjectPropertyKey();
								this.context.allowYield = false;
								value = this.parseGetterMethod();
							} else if (token.value === 'set' && lookaheadPropertyKey) {
								kind = 'set';
								computed = this.match('[');
								key = this.parseObjectPropertyKey();
								value = this.parseSetterMethod();
							}
						} else if (token.type === 7 /* Punctuator */ && token.value === '*' && lookaheadPropertyKey) {
						kind = 'init';
						computed = this.match('[');
						key = this.parseObjectPropertyKey();
						value = this.parseGeneratorMethod();
						method = true;
					}
					if (!kind && key && this.match('(')) {
						kind = 'init';
						value = isAsync ? this.parsePropertyMethodAsyncFunction() : this.parsePropertyMethodFunction();
						method = true;
					}
					if (!kind) {
						this.throwUnexpectedToken(this.lookahead);
					}
					if (kind === 'init') {
						kind = 'method';
					}
					if (!computed) {
						if (isStatic && this.isPropertyKey(key, 'prototype')) {
							this.throwUnexpectedToken(token, messages_1.Messages.StaticPrototype);
						}
						if (!isStatic && this.isPropertyKey(key, 'constructor')) {
							if (kind !== 'method' || !method || value && value.generator) {
								this.throwUnexpectedToken(token, messages_1.Messages.ConstructorSpecialMethod);
							}
							if (hasConstructor.value) {
								this.throwUnexpectedToken(token, messages_1.Messages.DuplicateConstructor);
							} else {
								hasConstructor.value = true;
							}
							kind = 'constructor';
						}
					}
					return this.finalize(node, new Node.MethodDefinition(key, computed, value, kind, isStatic));
				};
				Parser.prototype.parseClassElementList = function () {
					var body = [];
					var hasConstructor = { value: false };
					this.expect('{');
					while (!this.match('}')) {
						if (this.match(';')) {
							this.nextToken();
						} else {
							body.push(this.parseClassElement(hasConstructor));
						}
					}
					this.expect('}');
					return body;
				};
				Parser.prototype.parseClassBody = function () {
					var node = this.createNode();
					var elementList = this.parseClassElementList();
					return this.finalize(node, new Node.ClassBody(elementList));
				};
				Parser.prototype.parseClassDeclaration = function (identifierIsOptional) {
					var node = this.createNode();
					var previousStrict = this.context.strict;
					this.context.strict = true;
					this.expectKeyword('class');
					var id = identifierIsOptional && this.lookahead.type !== 3 /* Identifier */ ? null : this.parseVariableIdentifier();
					var superClass = null;
					if (this.matchKeyword('extends')) {
						this.nextToken();
						superClass = this.isolateCoverGrammar(this.parseLeftHandSideExpressionAllowCall);
					}
					var classBody = this.parseClassBody();
					this.context.strict = previousStrict;
					return this.finalize(node, new Node.ClassDeclaration(id, superClass, classBody));
				};
				Parser.prototype.parseClassExpression = function () {
					var node = this.createNode();
					var previousStrict = this.context.strict;
					this.context.strict = true;
					this.expectKeyword('class');
					var id = this.lookahead.type === 3 /* Identifier */ ? this.parseVariableIdentifier() : null;
					var superClass = null;
					if (this.matchKeyword('extends')) {
						this.nextToken();
						superClass = this.isolateCoverGrammar(this.parseLeftHandSideExpressionAllowCall);
					}
					var classBody = this.parseClassBody();
					this.context.strict = previousStrict;
					return this.finalize(node, new Node.ClassExpression(id, superClass, classBody));
				};
				// https://tc39.github.io/ecma262/#sec-scripts
				// https://tc39.github.io/ecma262/#sec-modules
				Parser.prototype.parseModule = function () {
					this.context.strict = true;
					this.context.isModule = true;
					var node = this.createNode();
					var body = this.parseDirectivePrologues();
					while (this.lookahead.type !== 2 /* EOF */) {
						body.push(this.parseStatementListItem());
					}
					return this.finalize(node, new Node.Module(body));
				};
				Parser.prototype.parseScript = function () {
					var node = this.createNode();
					var body = this.parseDirectivePrologues();
					while (this.lookahead.type !== 2 /* EOF */) {
						body.push(this.parseStatementListItem());
					}
					return this.finalize(node, new Node.Script(body));
				};
				// https://tc39.github.io/ecma262/#sec-imports
				Parser.prototype.parseModuleSpecifier = function () {
					var node = this.createNode();
					if (this.lookahead.type !== 8 /* StringLiteral */) {
							this.throwError(messages_1.Messages.InvalidModuleSpecifier);
						}
					var token = this.nextToken();
					var raw = this.getTokenRaw(token);
					return this.finalize(node, new Node.Literal(token.value, raw));
				};
				// import {<foo as bar>} ...;
				Parser.prototype.parseImportSpecifier = function () {
					var node = this.createNode();
					var imported;
					var local;
					if (this.lookahead.type === 3 /* Identifier */) {
							imported = this.parseVariableIdentifier();
							local = imported;
							if (this.matchContextualKeyword('as')) {
								this.nextToken();
								local = this.parseVariableIdentifier();
							}
						} else {
						imported = this.parseIdentifierName();
						local = imported;
						if (this.matchContextualKeyword('as')) {
							this.nextToken();
							local = this.parseVariableIdentifier();
						} else {
							this.throwUnexpectedToken(this.nextToken());
						}
					}
					return this.finalize(node, new Node.ImportSpecifier(local, imported));
				};
				// {foo, bar as bas}
				Parser.prototype.parseNamedImports = function () {
					this.expect('{');
					var specifiers = [];
					while (!this.match('}')) {
						specifiers.push(this.parseImportSpecifier());
						if (!this.match('}')) {
							this.expect(',');
						}
					}
					this.expect('}');
					return specifiers;
				};
				// import <foo> ...;
				Parser.prototype.parseImportDefaultSpecifier = function () {
					var node = this.createNode();
					var local = this.parseIdentifierName();
					return this.finalize(node, new Node.ImportDefaultSpecifier(local));
				};
				// import <* as foo> ...;
				Parser.prototype.parseImportNamespaceSpecifier = function () {
					var node = this.createNode();
					this.expect('*');
					if (!this.matchContextualKeyword('as')) {
						this.throwError(messages_1.Messages.NoAsAfterImportNamespace);
					}
					this.nextToken();
					var local = this.parseIdentifierName();
					return this.finalize(node, new Node.ImportNamespaceSpecifier(local));
				};
				Parser.prototype.parseImportDeclaration = function () {
					if (this.context.inFunctionBody) {
						this.throwError(messages_1.Messages.IllegalImportDeclaration);
					}
					var node = this.createNode();
					this.expectKeyword('import');
					var src;
					var specifiers = [];
					if (this.lookahead.type === 8 /* StringLiteral */) {
							// import 'foo';
							src = this.parseModuleSpecifier();
						} else {
						if (this.match('{')) {
							// import {bar}
							specifiers = specifiers.concat(this.parseNamedImports());
						} else if (this.match('*')) {
							// import * as foo
							specifiers.push(this.parseImportNamespaceSpecifier());
						} else if (this.isIdentifierName(this.lookahead) && !this.matchKeyword('default')) {
							// import foo
							specifiers.push(this.parseImportDefaultSpecifier());
							if (this.match(',')) {
								this.nextToken();
								if (this.match('*')) {
									// import foo, * as foo
									specifiers.push(this.parseImportNamespaceSpecifier());
								} else if (this.match('{')) {
									// import foo, {bar}
									specifiers = specifiers.concat(this.parseNamedImports());
								} else {
									this.throwUnexpectedToken(this.lookahead);
								}
							}
						} else {
							this.throwUnexpectedToken(this.nextToken());
						}
						if (!this.matchContextualKeyword('from')) {
							var message = this.lookahead.value ? messages_1.Messages.UnexpectedToken : messages_1.Messages.MissingFromClause;
							this.throwError(message, this.lookahead.value);
						}
						this.nextToken();
						src = this.parseModuleSpecifier();
					}
					this.consumeSemicolon();
					return this.finalize(node, new Node.ImportDeclaration(specifiers, src));
				};
				// https://tc39.github.io/ecma262/#sec-exports
				Parser.prototype.parseExportSpecifier = function () {
					var node = this.createNode();
					var local = this.parseIdentifierName();
					var exported = local;
					if (this.matchContextualKeyword('as')) {
						this.nextToken();
						exported = this.parseIdentifierName();
					}
					return this.finalize(node, new Node.ExportSpecifier(local, exported));
				};
				Parser.prototype.parseExportDeclaration = function () {
					if (this.context.inFunctionBody) {
						this.throwError(messages_1.Messages.IllegalExportDeclaration);
					}
					var node = this.createNode();
					this.expectKeyword('export');
					var exportDeclaration;
					if (this.matchKeyword('default')) {
						// export default ...
						this.nextToken();
						if (this.matchKeyword('function')) {
							// export default function foo () {}
							// export default function () {}
							var declaration = this.parseFunctionDeclaration(true);
							exportDeclaration = this.finalize(node, new Node.ExportDefaultDeclaration(declaration));
						} else if (this.matchKeyword('class')) {
							// export default class foo {}
							var declaration = this.parseClassDeclaration(true);
							exportDeclaration = this.finalize(node, new Node.ExportDefaultDeclaration(declaration));
						} else if (this.matchContextualKeyword('async')) {
							// export default async function f () {}
							// export default async function () {}
							// export default async x => x
							var declaration = this.matchAsyncFunction() ? this.parseFunctionDeclaration(true) : this.parseAssignmentExpression();
							exportDeclaration = this.finalize(node, new Node.ExportDefaultDeclaration(declaration));
						} else {
							if (this.matchContextualKeyword('from')) {
								this.throwError(messages_1.Messages.UnexpectedToken, this.lookahead.value);
							}
							// export default {};
							// export default [];
							// export default (1 + 2);
							var declaration = this.match('{') ? this.parseObjectInitializer() : this.match('[') ? this.parseArrayInitializer() : this.parseAssignmentExpression();
							this.consumeSemicolon();
							exportDeclaration = this.finalize(node, new Node.ExportDefaultDeclaration(declaration));
						}
					} else if (this.match('*')) {
						// export * from 'foo';
						this.nextToken();
						if (!this.matchContextualKeyword('from')) {
							var message = this.lookahead.value ? messages_1.Messages.UnexpectedToken : messages_1.Messages.MissingFromClause;
							this.throwError(message, this.lookahead.value);
						}
						this.nextToken();
						var src = this.parseModuleSpecifier();
						this.consumeSemicolon();
						exportDeclaration = this.finalize(node, new Node.ExportAllDeclaration(src));
					} else if (this.lookahead.type === 4 /* Keyword */) {
							// export var f = 1;
							var declaration = void 0;
							switch (this.lookahead.value) {
								case 'let':
								case 'const':
									declaration = this.parseLexicalDeclaration({ inFor: false });
									break;
								case 'var':
								case 'class':
								case 'function':
									declaration = this.parseStatementListItem();
									break;
								default:
									this.throwUnexpectedToken(this.lookahead);
							}
							exportDeclaration = this.finalize(node, new Node.ExportNamedDeclaration(declaration, [], null));
						} else if (this.matchAsyncFunction()) {
						var declaration = this.parseFunctionDeclaration();
						exportDeclaration = this.finalize(node, new Node.ExportNamedDeclaration(declaration, [], null));
					} else {
						var specifiers = [];
						var source = null;
						var isExportFromIdentifier = false;
						this.expect('{');
						while (!this.match('}')) {
							isExportFromIdentifier = isExportFromIdentifier || this.matchKeyword('default');
							specifiers.push(this.parseExportSpecifier());
							if (!this.match('}')) {
								this.expect(',');
							}
						}
						this.expect('}');
						if (this.matchContextualKeyword('from')) {
							// export {default} from 'foo';
							// export {foo} from 'foo';
							this.nextToken();
							source = this.parseModuleSpecifier();
							this.consumeSemicolon();
						} else if (isExportFromIdentifier) {
							// export {default}; // missing fromClause
							var message = this.lookahead.value ? messages_1.Messages.UnexpectedToken : messages_1.Messages.MissingFromClause;
							this.throwError(message, this.lookahead.value);
						} else {
							// export {foo};
							this.consumeSemicolon();
						}
						exportDeclaration = this.finalize(node, new Node.ExportNamedDeclaration(null, specifiers, source));
					}
					return exportDeclaration;
				};
				return Parser;
			}();
			exports.Parser = Parser;

			/***/
		},
		/* 9 */
		/***/function (module, exports) {

			"use strict";
			// Ensure the condition is true, otherwise throw an error.
			// This is only to have a better contract semantic, i.e. another safety net
			// to catch a logic error. The condition shall be fulfilled in normal case.
			// Do NOT use this to enforce a certain condition on any user input.

			Object.defineProperty(exports, "__esModule", { value: true });
			function assert(condition, message) {
				/* istanbul ignore if */
				if (!condition) {
					throw new Error('ASSERT: ' + message);
				}
			}
			exports.assert = assert;

			/***/
		},
		/* 10 */
		/***/function (module, exports) {

			"use strict";
			/* tslint:disable:max-classes-per-file */

			Object.defineProperty(exports, "__esModule", { value: true });
			var ErrorHandler = function () {
				function ErrorHandler() {
					this.errors = [];
					this.tolerant = false;
				}
				ErrorHandler.prototype.recordError = function (error) {
					this.errors.push(error);
				};
				ErrorHandler.prototype.tolerate = function (error) {
					if (this.tolerant) {
						this.recordError(error);
					} else {
						throw error;
					}
				};
				ErrorHandler.prototype.constructError = function (msg, column) {
					var error = new Error(msg);
					try {
						throw error;
					} catch (base) {
						/* istanbul ignore else */
						if (Object.create && Object.defineProperty) {
							error = Object.create(base);
							Object.defineProperty(error, 'column', { value: column });
						}
					}
					/* istanbul ignore next */
					return error;
				};
				ErrorHandler.prototype.createError = function (index, line, col, description) {
					var msg = 'Line ' + line + ': ' + description;
					var error = this.constructError(msg, col);
					error.index = index;
					error.lineNumber = line;
					error.description = description;
					return error;
				};
				ErrorHandler.prototype.throwError = function (index, line, col, description) {
					throw this.createError(index, line, col, description);
				};
				ErrorHandler.prototype.tolerateError = function (index, line, col, description) {
					var error = this.createError(index, line, col, description);
					if (this.tolerant) {
						this.recordError(error);
					} else {
						throw error;
					}
				};
				return ErrorHandler;
			}();
			exports.ErrorHandler = ErrorHandler;

			/***/
		},
		/* 11 */
		/***/function (module, exports) {

			"use strict";

			Object.defineProperty(exports, "__esModule", { value: true });
			// Error messages should be identical to V8.
			exports.Messages = {
				BadGetterArity: 'Getter must not have any formal parameters',
				BadSetterArity: 'Setter must have exactly one formal parameter',
				BadSetterRestParameter: 'Setter function argument must not be a rest parameter',
				ConstructorIsAsync: 'Class constructor may not be an async method',
				ConstructorSpecialMethod: 'Class constructor may not be an accessor',
				DeclarationMissingInitializer: 'Missing initializer in %0 declaration',
				DefaultRestParameter: 'Unexpected token =',
				DuplicateBinding: 'Duplicate binding %0',
				DuplicateConstructor: 'A class may only have one constructor',
				DuplicateProtoProperty: 'Duplicate __proto__ fields are not allowed in object literals',
				ForInOfLoopInitializer: '%0 loop variable declaration may not have an initializer',
				GeneratorInLegacyContext: 'Generator declarations are not allowed in legacy contexts',
				IllegalBreak: 'Illegal break statement',
				IllegalContinue: 'Illegal continue statement',
				IllegalExportDeclaration: 'Unexpected token',
				IllegalImportDeclaration: 'Unexpected token',
				IllegalLanguageModeDirective: 'Illegal \'use strict\' directive in function with non-simple parameter list',
				IllegalReturn: 'Illegal return statement',
				InvalidEscapedReservedWord: 'Keyword must not contain escaped characters',
				InvalidHexEscapeSequence: 'Invalid hexadecimal escape sequence',
				InvalidLHSInAssignment: 'Invalid left-hand side in assignment',
				InvalidLHSInForIn: 'Invalid left-hand side in for-in',
				InvalidLHSInForLoop: 'Invalid left-hand side in for-loop',
				InvalidModuleSpecifier: 'Unexpected token',
				InvalidRegExp: 'Invalid regular expression',
				LetInLexicalBinding: 'let is disallowed as a lexically bound name',
				MissingFromClause: 'Unexpected token',
				MultipleDefaultsInSwitch: 'More than one default clause in switch statement',
				NewlineAfterThrow: 'Illegal newline after throw',
				NoAsAfterImportNamespace: 'Unexpected token',
				NoCatchOrFinally: 'Missing catch or finally after try',
				ParameterAfterRestParameter: 'Rest parameter must be last formal parameter',
				Redeclaration: '%0 \'%1\' has already been declared',
				StaticPrototype: 'Classes may not have static property named prototype',
				StrictCatchVariable: 'Catch variable may not be eval or arguments in strict mode',
				StrictDelete: 'Delete of an unqualified identifier in strict mode.',
				StrictFunction: 'In strict mode code, functions can only be declared at top level or inside a block',
				StrictFunctionName: 'Function name may not be eval or arguments in strict mode',
				StrictLHSAssignment: 'Assignment to eval or arguments is not allowed in strict mode',
				StrictLHSPostfix: 'Postfix increment/decrement may not have eval or arguments operand in strict mode',
				StrictLHSPrefix: 'Prefix increment/decrement may not have eval or arguments operand in strict mode',
				StrictModeWith: 'Strict mode code may not include a with statement',
				StrictOctalLiteral: 'Octal literals are not allowed in strict mode.',
				StrictParamDupe: 'Strict mode function may not have duplicate parameter names',
				StrictParamName: 'Parameter name eval or arguments is not allowed in strict mode',
				StrictReservedWord: 'Use of future reserved word in strict mode',
				StrictVarName: 'Variable name may not be eval or arguments in strict mode',
				TemplateOctalLiteral: 'Octal literals are not allowed in template strings.',
				UnexpectedEOS: 'Unexpected end of input',
				UnexpectedIdentifier: 'Unexpected identifier',
				UnexpectedNumber: 'Unexpected number',
				UnexpectedReserved: 'Unexpected reserved word',
				UnexpectedString: 'Unexpected string',
				UnexpectedTemplate: 'Unexpected quasi %0',
				UnexpectedToken: 'Unexpected token %0',
				UnexpectedTokenIllegal: 'Unexpected token ILLEGAL',
				UnknownLabel: 'Undefined label \'%0\'',
				UnterminatedRegExp: 'Invalid regular expression: missing /'
			};

			/***/
		},
		/* 12 */
		/***/function (module, exports, __webpack_require__) {

			"use strict";

			Object.defineProperty(exports, "__esModule", { value: true });
			var assert_1 = __webpack_require__(9);
			var character_1 = __webpack_require__(4);
			var messages_1 = __webpack_require__(11);
			function hexValue(ch) {
				return '0123456789abcdef'.indexOf(ch.toLowerCase());
			}
			function octalValue(ch) {
				return '01234567'.indexOf(ch);
			}
			var Scanner = function () {
				function Scanner(code, handler) {
					this.source = code;
					this.errorHandler = handler;
					this.trackComment = false;
					this.length = code.length;
					this.index = 0;
					this.lineNumber = code.length > 0 ? 1 : 0;
					this.lineStart = 0;
					this.curlyStack = [];
				}
				Scanner.prototype.saveState = function () {
					return {
						index: this.index,
						lineNumber: this.lineNumber,
						lineStart: this.lineStart
					};
				};
				Scanner.prototype.restoreState = function (state) {
					this.index = state.index;
					this.lineNumber = state.lineNumber;
					this.lineStart = state.lineStart;
				};
				Scanner.prototype.eof = function () {
					return this.index >= this.length;
				};
				Scanner.prototype.throwUnexpectedToken = function (message) {
					if (message === void 0) {
						message = messages_1.Messages.UnexpectedTokenIllegal;
					}
					return this.errorHandler.throwError(this.index, this.lineNumber, this.index - this.lineStart + 1, message);
				};
				Scanner.prototype.tolerateUnexpectedToken = function (message) {
					if (message === void 0) {
						message = messages_1.Messages.UnexpectedTokenIllegal;
					}
					this.errorHandler.tolerateError(this.index, this.lineNumber, this.index - this.lineStart + 1, message);
				};
				// https://tc39.github.io/ecma262/#sec-comments
				Scanner.prototype.skipSingleLineComment = function (offset) {
					var comments = [];
					var start, loc;
					if (this.trackComment) {
						comments = [];
						start = this.index - offset;
						loc = {
							start: {
								line: this.lineNumber,
								column: this.index - this.lineStart - offset
							},
							end: {}
						};
					}
					while (!this.eof()) {
						var ch = this.source.charCodeAt(this.index);
						++this.index;
						if (character_1.Character.isLineTerminator(ch)) {
							if (this.trackComment) {
								loc.end = {
									line: this.lineNumber,
									column: this.index - this.lineStart - 1
								};
								var entry = {
									multiLine: false,
									slice: [start + offset, this.index - 1],
									range: [start, this.index - 1],
									loc: loc
								};
								comments.push(entry);
							}
							if (ch === 13 && this.source.charCodeAt(this.index) === 10) {
								++this.index;
							}
							++this.lineNumber;
							this.lineStart = this.index;
							return comments;
						}
					}
					if (this.trackComment) {
						loc.end = {
							line: this.lineNumber,
							column: this.index - this.lineStart
						};
						var entry = {
							multiLine: false,
							slice: [start + offset, this.index],
							range: [start, this.index],
							loc: loc
						};
						comments.push(entry);
					}
					return comments;
				};
				Scanner.prototype.skipMultiLineComment = function () {
					var comments = [];
					var start, loc;
					if (this.trackComment) {
						comments = [];
						start = this.index - 2;
						loc = {
							start: {
								line: this.lineNumber,
								column: this.index - this.lineStart - 2
							},
							end: {}
						};
					}
					while (!this.eof()) {
						var ch = this.source.charCodeAt(this.index);
						if (character_1.Character.isLineTerminator(ch)) {
							if (ch === 0x0D && this.source.charCodeAt(this.index + 1) === 0x0A) {
								++this.index;
							}
							++this.lineNumber;
							++this.index;
							this.lineStart = this.index;
						} else if (ch === 0x2A) {
							// Block comment ends with '*/'.
							if (this.source.charCodeAt(this.index + 1) === 0x2F) {
								this.index += 2;
								if (this.trackComment) {
									loc.end = {
										line: this.lineNumber,
										column: this.index - this.lineStart
									};
									var entry = {
										multiLine: true,
										slice: [start + 2, this.index - 2],
										range: [start, this.index],
										loc: loc
									};
									comments.push(entry);
								}
								return comments;
							}
							++this.index;
						} else {
							++this.index;
						}
					}
					// Ran off the end of the file - the whole thing is a comment
					if (this.trackComment) {
						loc.end = {
							line: this.lineNumber,
							column: this.index - this.lineStart
						};
						var entry = {
							multiLine: true,
							slice: [start + 2, this.index],
							range: [start, this.index],
							loc: loc
						};
						comments.push(entry);
					}
					this.tolerateUnexpectedToken();
					return comments;
				};
				Scanner.prototype.scanComments = function () {
					var comments;
					if (this.trackComment) {
						comments = [];
					}
					var start = this.index === 0;
					while (!this.eof()) {
						var ch = this.source.charCodeAt(this.index);
						if (character_1.Character.isWhiteSpace(ch)) {
							++this.index;
						} else if (character_1.Character.isLineTerminator(ch)) {
							++this.index;
							if (ch === 0x0D && this.source.charCodeAt(this.index) === 0x0A) {
								++this.index;
							}
							++this.lineNumber;
							this.lineStart = this.index;
							start = true;
						} else if (ch === 0x2F) {
							ch = this.source.charCodeAt(this.index + 1);
							if (ch === 0x2F) {
								this.index += 2;
								var comment = this.skipSingleLineComment(2);
								if (this.trackComment) {
									comments = comments.concat(comment);
								}
								start = true;
							} else if (ch === 0x2A) {
								this.index += 2;
								var comment = this.skipMultiLineComment();
								if (this.trackComment) {
									comments = comments.concat(comment);
								}
							} else {
								break;
							}
						} else if (start && ch === 0x2D) {
							// U+003E is '>'
							if (this.source.charCodeAt(this.index + 1) === 0x2D && this.source.charCodeAt(this.index + 2) === 0x3E) {
								// '-->' is a single-line comment
								this.index += 3;
								var comment = this.skipSingleLineComment(3);
								if (this.trackComment) {
									comments = comments.concat(comment);
								}
							} else {
								break;
							}
						} else if (ch === 0x3C) {
							if (this.source.slice(this.index + 1, this.index + 4) === '!--') {
								this.index += 4; // `<!--`
								var comment = this.skipSingleLineComment(4);
								if (this.trackComment) {
									comments = comments.concat(comment);
								}
							} else {
								break;
							}
						} else {
							break;
						}
					}
					return comments;
				};
				// https://tc39.github.io/ecma262/#sec-future-reserved-words
				Scanner.prototype.isFutureReservedWord = function (id) {
					switch (id) {
						case 'enum':
						case 'export':
						case 'import':
						case 'super':
							return true;
						default:
							return false;
					}
				};
				Scanner.prototype.isStrictModeReservedWord = function (id) {
					switch (id) {
						case 'implements':
						case 'interface':
						case 'package':
						case 'private':
						case 'protected':
						case 'public':
						case 'static':
						case 'yield':
						case 'let':
							return true;
						default:
							return false;
					}
				};
				Scanner.prototype.isRestrictedWord = function (id) {
					return id === 'eval' || id === 'arguments';
				};
				// https://tc39.github.io/ecma262/#sec-keywords
				Scanner.prototype.isKeyword = function (id) {
					switch (id.length) {
						case 2:
							return id === 'if' || id === 'in' || id === 'do';
						case 3:
							return id === 'var' || id === 'for' || id === 'new' || id === 'try' || id === 'let';
						case 4:
							return id === 'this' || id === 'else' || id === 'case' || id === 'void' || id === 'with' || id === 'enum';
						case 5:
							return id === 'while' || id === 'break' || id === 'catch' || id === 'throw' || id === 'const' || id === 'yield' || id === 'class' || id === 'super';
						case 6:
							return id === 'return' || id === 'typeof' || id === 'delete' || id === 'switch' || id === 'export' || id === 'import';
						case 7:
							return id === 'default' || id === 'finally' || id === 'extends';
						case 8:
							return id === 'function' || id === 'continue' || id === 'debugger';
						case 10:
							return id === 'instanceof';
						default:
							return false;
					}
				};
				Scanner.prototype.codePointAt = function (i) {
					var cp = this.source.charCodeAt(i);
					if (cp >= 0xD800 && cp <= 0xDBFF) {
						var second = this.source.charCodeAt(i + 1);
						if (second >= 0xDC00 && second <= 0xDFFF) {
							var first = cp;
							cp = (first - 0xD800) * 0x400 + second - 0xDC00 + 0x10000;
						}
					}
					return cp;
				};
				Scanner.prototype.scanHexEscape = function (prefix) {
					var len = prefix === 'u' ? 4 : 2;
					var code = 0;
					for (var i = 0; i < len; ++i) {
						if (!this.eof() && character_1.Character.isHexDigit(this.source.charCodeAt(this.index))) {
							code = code * 16 + hexValue(this.source[this.index++]);
						} else {
							return null;
						}
					}
					return String.fromCharCode(code);
				};
				Scanner.prototype.scanUnicodeCodePointEscape = function () {
					var ch = this.source[this.index];
					var code = 0;
					// At least, one hex digit is required.
					if (ch === '}') {
						this.throwUnexpectedToken();
					}
					while (!this.eof()) {
						ch = this.source[this.index++];
						if (!character_1.Character.isHexDigit(ch.charCodeAt(0))) {
							break;
						}
						code = code * 16 + hexValue(ch);
					}
					if (code > 0x10FFFF || ch !== '}') {
						this.throwUnexpectedToken();
					}
					return character_1.Character.fromCodePoint(code);
				};
				Scanner.prototype.getIdentifier = function () {
					var start = this.index++;
					while (!this.eof()) {
						var ch = this.source.charCodeAt(this.index);
						if (ch === 0x5C) {
							// Blackslash (U+005C) marks Unicode escape sequence.
							this.index = start;
							return this.getComplexIdentifier();
						} else if (ch >= 0xD800 && ch < 0xDFFF) {
							// Need to handle surrogate pairs.
							this.index = start;
							return this.getComplexIdentifier();
						}
						if (character_1.Character.isIdentifierPart(ch)) {
							++this.index;
						} else {
							break;
						}
					}
					return this.source.slice(start, this.index);
				};
				Scanner.prototype.getComplexIdentifier = function () {
					var cp = this.codePointAt(this.index);
					var id = character_1.Character.fromCodePoint(cp);
					this.index += id.length;
					// '\u' (U+005C, U+0075) denotes an escaped character.
					var ch;
					if (cp === 0x5C) {
						if (this.source.charCodeAt(this.index) !== 0x75) {
							this.throwUnexpectedToken();
						}
						++this.index;
						if (this.source[this.index] === '{') {
							++this.index;
							ch = this.scanUnicodeCodePointEscape();
						} else {
							ch = this.scanHexEscape('u');
							if (ch === null || ch === '\\' || !character_1.Character.isIdentifierStart(ch.charCodeAt(0))) {
								this.throwUnexpectedToken();
							}
						}
						id = ch;
					}
					while (!this.eof()) {
						cp = this.codePointAt(this.index);
						if (!character_1.Character.isIdentifierPart(cp)) {
							break;
						}
						ch = character_1.Character.fromCodePoint(cp);
						id += ch;
						this.index += ch.length;
						// '\u' (U+005C, U+0075) denotes an escaped character.
						if (cp === 0x5C) {
							id = id.substr(0, id.length - 1);
							if (this.source.charCodeAt(this.index) !== 0x75) {
								this.throwUnexpectedToken();
							}
							++this.index;
							if (this.source[this.index] === '{') {
								++this.index;
								ch = this.scanUnicodeCodePointEscape();
							} else {
								ch = this.scanHexEscape('u');
								if (ch === null || ch === '\\' || !character_1.Character.isIdentifierPart(ch.charCodeAt(0))) {
									this.throwUnexpectedToken();
								}
							}
							id += ch;
						}
					}
					return id;
				};
				Scanner.prototype.octalToDecimal = function (ch) {
					// \0 is not octal escape sequence
					var octal = ch !== '0';
					var code = octalValue(ch);
					if (!this.eof() && character_1.Character.isOctalDigit(this.source.charCodeAt(this.index))) {
						octal = true;
						code = code * 8 + octalValue(this.source[this.index++]);
						// 3 digits are only allowed when string starts
						// with 0, 1, 2, 3
						if ('0123'.indexOf(ch) >= 0 && !this.eof() && character_1.Character.isOctalDigit(this.source.charCodeAt(this.index))) {
							code = code * 8 + octalValue(this.source[this.index++]);
						}
					}
					return {
						code: code,
						octal: octal
					};
				};
				// https://tc39.github.io/ecma262/#sec-names-and-keywords
				Scanner.prototype.scanIdentifier = function () {
					var type;
					var start = this.index;
					// Backslash (U+005C) starts an escaped character.
					var id = this.source.charCodeAt(start) === 0x5C ? this.getComplexIdentifier() : this.getIdentifier();
					// There is no keyword or literal with only one character.
					// Thus, it must be an identifier.
					if (id.length === 1) {
						type = 3 /* Identifier */;
					} else if (this.isKeyword(id)) {
						type = 4 /* Keyword */;
					} else if (id === 'null') {
						type = 5 /* NullLiteral */;
					} else if (id === 'true' || id === 'false') {
						type = 1 /* BooleanLiteral */;
					} else {
						type = 3 /* Identifier */;
					}
					if (type !== 3 /* Identifier */ && start + id.length !== this.index) {
						var restore = this.index;
						this.index = start;
						this.tolerateUnexpectedToken(messages_1.Messages.InvalidEscapedReservedWord);
						this.index = restore;
					}
					return {
						type: type,
						value: id,
						lineNumber: this.lineNumber,
						lineStart: this.lineStart,
						start: start,
						end: this.index
					};
				};
				// https://tc39.github.io/ecma262/#sec-punctuators
				Scanner.prototype.scanPunctuator = function () {
					var start = this.index;
					// Check for most common single-character punctuators.
					var str = this.source[this.index];
					switch (str) {
						case '(':
						case '{':
							if (str === '{') {
								this.curlyStack.push('{');
							}
							++this.index;
							break;
						case '.':
							++this.index;
							if (this.source[this.index] === '.' && this.source[this.index + 1] === '.') {
								// Spread operator: ...
								this.index += 2;
								str = '...';
							}
							break;
						case '}':
							++this.index;
							this.curlyStack.pop();
							break;
						case ')':
						case ';':
						case ',':
						case '[':
						case ']':
						case ':':
						case '?':
						case '~':
							++this.index;
							break;
						default:
							// 4-character punctuator.
							str = this.source.substr(this.index, 4);
							if (str === '>>>=') {
								this.index += 4;
							} else {
								// 3-character punctuators.
								str = str.substr(0, 3);
								if (str === '===' || str === '!==' || str === '>>>' || str === '<<=' || str === '>>=' || str === '**=') {
									this.index += 3;
								} else {
									// 2-character punctuators.
									str = str.substr(0, 2);
									if (str === '&&' || str === '||' || str === '==' || str === '!=' || str === '+=' || str === '-=' || str === '*=' || str === '/=' || str === '++' || str === '--' || str === '<<' || str === '>>' || str === '&=' || str === '|=' || str === '^=' || str === '%=' || str === '<=' || str === '>=' || str === '=>' || str === '**') {
										this.index += 2;
									} else {
										// 1-character punctuators.
										str = this.source[this.index];
										if ('<>=!+-*%&|^/'.indexOf(str) >= 0) {
											++this.index;
										}
									}
								}
							}
					}
					if (this.index === start) {
						this.throwUnexpectedToken();
					}
					return {
						type: 7 /* Punctuator */
						, value: str,
						lineNumber: this.lineNumber,
						lineStart: this.lineStart,
						start: start,
						end: this.index
					};
				};
				// https://tc39.github.io/ecma262/#sec-literals-numeric-literals
				Scanner.prototype.scanHexLiteral = function (start) {
					var num = '';
					while (!this.eof()) {
						if (!character_1.Character.isHexDigit(this.source.charCodeAt(this.index))) {
							break;
						}
						num += this.source[this.index++];
					}
					if (num.length === 0) {
						this.throwUnexpectedToken();
					}
					if (character_1.Character.isIdentifierStart(this.source.charCodeAt(this.index))) {
						this.throwUnexpectedToken();
					}
					return {
						type: 6 /* NumericLiteral */
						, value: parseInt('0x' + num, 16),
						lineNumber: this.lineNumber,
						lineStart: this.lineStart,
						start: start,
						end: this.index
					};
				};
				Scanner.prototype.scanBinaryLiteral = function (start) {
					var num = '';
					var ch;
					while (!this.eof()) {
						ch = this.source[this.index];
						if (ch !== '0' && ch !== '1') {
							break;
						}
						num += this.source[this.index++];
					}
					if (num.length === 0) {
						// only 0b or 0B
						this.throwUnexpectedToken();
					}
					if (!this.eof()) {
						ch = this.source.charCodeAt(this.index);
						/* istanbul ignore else */
						if (character_1.Character.isIdentifierStart(ch) || character_1.Character.isDecimalDigit(ch)) {
							this.throwUnexpectedToken();
						}
					}
					return {
						type: 6 /* NumericLiteral */
						, value: parseInt(num, 2),
						lineNumber: this.lineNumber,
						lineStart: this.lineStart,
						start: start,
						end: this.index
					};
				};
				Scanner.prototype.scanOctalLiteral = function (prefix, start) {
					var num = '';
					var octal = false;
					if (character_1.Character.isOctalDigit(prefix.charCodeAt(0))) {
						octal = true;
						num = '0' + this.source[this.index++];
					} else {
						++this.index;
					}
					while (!this.eof()) {
						if (!character_1.Character.isOctalDigit(this.source.charCodeAt(this.index))) {
							break;
						}
						num += this.source[this.index++];
					}
					if (!octal && num.length === 0) {
						// only 0o or 0O
						this.throwUnexpectedToken();
					}
					if (character_1.Character.isIdentifierStart(this.source.charCodeAt(this.index)) || character_1.Character.isDecimalDigit(this.source.charCodeAt(this.index))) {
						this.throwUnexpectedToken();
					}
					return {
						type: 6 /* NumericLiteral */
						, value: parseInt(num, 8),
						octal: octal,
						lineNumber: this.lineNumber,
						lineStart: this.lineStart,
						start: start,
						end: this.index
					};
				};
				Scanner.prototype.isImplicitOctalLiteral = function () {
					// Implicit octal, unless there is a non-octal digit.
					// (Annex B.1.1 on Numeric Literals)
					for (var i = this.index + 1; i < this.length; ++i) {
						var ch = this.source[i];
						if (ch === '8' || ch === '9') {
							return false;
						}
						if (!character_1.Character.isOctalDigit(ch.charCodeAt(0))) {
							return true;
						}
					}
					return true;
				};
				Scanner.prototype.scanNumericLiteral = function () {
					var start = this.index;
					var ch = this.source[start];
					assert_1.assert(character_1.Character.isDecimalDigit(ch.charCodeAt(0)) || ch === '.', 'Numeric literal must start with a decimal digit or a decimal point');
					var num = '';
					if (ch !== '.') {
						num = this.source[this.index++];
						ch = this.source[this.index];
						// Hex number starts with '0x'.
						// Octal number starts with '0'.
						// Octal number in ES6 starts with '0o'.
						// Binary number in ES6 starts with '0b'.
						if (num === '0') {
							if (ch === 'x' || ch === 'X') {
								++this.index;
								return this.scanHexLiteral(start);
							}
							if (ch === 'b' || ch === 'B') {
								++this.index;
								return this.scanBinaryLiteral(start);
							}
							if (ch === 'o' || ch === 'O') {
								return this.scanOctalLiteral(ch, start);
							}
							if (ch && character_1.Character.isOctalDigit(ch.charCodeAt(0))) {
								if (this.isImplicitOctalLiteral()) {
									return this.scanOctalLiteral(ch, start);
								}
							}
						}
						while (character_1.Character.isDecimalDigit(this.source.charCodeAt(this.index))) {
							num += this.source[this.index++];
						}
						ch = this.source[this.index];
					}
					if (ch === '.') {
						num += this.source[this.index++];
						while (character_1.Character.isDecimalDigit(this.source.charCodeAt(this.index))) {
							num += this.source[this.index++];
						}
						ch = this.source[this.index];
					}
					if (ch === 'e' || ch === 'E') {
						num += this.source[this.index++];
						ch = this.source[this.index];
						if (ch === '+' || ch === '-') {
							num += this.source[this.index++];
						}
						if (character_1.Character.isDecimalDigit(this.source.charCodeAt(this.index))) {
							while (character_1.Character.isDecimalDigit(this.source.charCodeAt(this.index))) {
								num += this.source[this.index++];
							}
						} else {
							this.throwUnexpectedToken();
						}
					}
					if (character_1.Character.isIdentifierStart(this.source.charCodeAt(this.index))) {
						this.throwUnexpectedToken();
					}
					return {
						type: 6 /* NumericLiteral */
						, value: parseFloat(num),
						lineNumber: this.lineNumber,
						lineStart: this.lineStart,
						start: start,
						end: this.index
					};
				};
				// https://tc39.github.io/ecma262/#sec-literals-string-literals
				Scanner.prototype.scanStringLiteral = function () {
					var start = this.index;
					var quote = this.source[start];
					assert_1.assert(quote === '\'' || quote === '"', 'String literal must starts with a quote');
					++this.index;
					var octal = false;
					var str = '';
					while (!this.eof()) {
						var ch = this.source[this.index++];
						if (ch === quote) {
							quote = '';
							break;
						} else if (ch === '\\') {
							ch = this.source[this.index++];
							if (!ch || !character_1.Character.isLineTerminator(ch.charCodeAt(0))) {
								switch (ch) {
									case 'u':
										if (this.source[this.index] === '{') {
											++this.index;
											str += this.scanUnicodeCodePointEscape();
										} else {
											var unescaped_1 = this.scanHexEscape(ch);
											if (unescaped_1 === null) {
												this.throwUnexpectedToken();
											}
											str += unescaped_1;
										}
										break;
									case 'x':
										var unescaped = this.scanHexEscape(ch);
										if (unescaped === null) {
											this.throwUnexpectedToken(messages_1.Messages.InvalidHexEscapeSequence);
										}
										str += unescaped;
										break;
									case 'n':
										str += '\n';
										break;
									case 'r':
										str += '\r';
										break;
									case 't':
										str += '\t';
										break;
									case 'b':
										str += '\b';
										break;
									case 'f':
										str += '\f';
										break;
									case 'v':
										str += '\x0B';
										break;
									case '8':
									case '9':
										str += ch;
										this.tolerateUnexpectedToken();
										break;
									default:
										if (ch && character_1.Character.isOctalDigit(ch.charCodeAt(0))) {
											var octToDec = this.octalToDecimal(ch);
											octal = octToDec.octal || octal;
											str += String.fromCharCode(octToDec.code);
										} else {
											str += ch;
										}
										break;
								}
							} else {
								++this.lineNumber;
								if (ch === '\r' && this.source[this.index] === '\n') {
									++this.index;
								}
								this.lineStart = this.index;
							}
						} else if (character_1.Character.isLineTerminator(ch.charCodeAt(0))) {
							break;
						} else {
							str += ch;
						}
					}
					if (quote !== '') {
						this.index = start;
						this.throwUnexpectedToken();
					}
					return {
						type: 8 /* StringLiteral */
						, value: str,
						octal: octal,
						lineNumber: this.lineNumber,
						lineStart: this.lineStart,
						start: start,
						end: this.index
					};
				};
				// https://tc39.github.io/ecma262/#sec-template-literal-lexical-components
				Scanner.prototype.scanTemplate = function () {
					var cooked = '';
					var terminated = false;
					var start = this.index;
					var head = this.source[start] === '`';
					var tail = false;
					var rawOffset = 2;
					++this.index;
					while (!this.eof()) {
						var ch = this.source[this.index++];
						if (ch === '`') {
							rawOffset = 1;
							tail = true;
							terminated = true;
							break;
						} else if (ch === '$') {
							if (this.source[this.index] === '{') {
								this.curlyStack.push('${');
								++this.index;
								terminated = true;
								break;
							}
							cooked += ch;
						} else if (ch === '\\') {
							ch = this.source[this.index++];
							if (!character_1.Character.isLineTerminator(ch.charCodeAt(0))) {
								switch (ch) {
									case 'n':
										cooked += '\n';
										break;
									case 'r':
										cooked += '\r';
										break;
									case 't':
										cooked += '\t';
										break;
									case 'u':
										if (this.source[this.index] === '{') {
											++this.index;
											cooked += this.scanUnicodeCodePointEscape();
										} else {
											var restore = this.index;
											var unescaped_2 = this.scanHexEscape(ch);
											if (unescaped_2 !== null) {
												cooked += unescaped_2;
											} else {
												this.index = restore;
												cooked += ch;
											}
										}
										break;
									case 'x':
										var unescaped = this.scanHexEscape(ch);
										if (unescaped === null) {
											this.throwUnexpectedToken(messages_1.Messages.InvalidHexEscapeSequence);
										}
										cooked += unescaped;
										break;
									case 'b':
										cooked += '\b';
										break;
									case 'f':
										cooked += '\f';
										break;
									case 'v':
										cooked += '\v';
										break;
									default:
										if (ch === '0') {
											if (character_1.Character.isDecimalDigit(this.source.charCodeAt(this.index))) {
												// Illegal: \01 \02 and so on
												this.throwUnexpectedToken(messages_1.Messages.TemplateOctalLiteral);
											}
											cooked += '\0';
										} else if (character_1.Character.isOctalDigit(ch.charCodeAt(0))) {
											// Illegal: \1 \2
											this.throwUnexpectedToken(messages_1.Messages.TemplateOctalLiteral);
										} else {
											cooked += ch;
										}
										break;
								}
							} else {
								++this.lineNumber;
								if (ch === '\r' && this.source[this.index] === '\n') {
									++this.index;
								}
								this.lineStart = this.index;
							}
						} else if (character_1.Character.isLineTerminator(ch.charCodeAt(0))) {
							++this.lineNumber;
							if (ch === '\r' && this.source[this.index] === '\n') {
								++this.index;
							}
							this.lineStart = this.index;
							cooked += '\n';
						} else {
							cooked += ch;
						}
					}
					if (!terminated) {
						this.throwUnexpectedToken();
					}
					if (!head) {
						this.curlyStack.pop();
					}
					return {
						type: 10 /* Template */
						, value: this.source.slice(start + 1, this.index - rawOffset),
						cooked: cooked,
						head: head,
						tail: tail,
						lineNumber: this.lineNumber,
						lineStart: this.lineStart,
						start: start,
						end: this.index
					};
				};
				// https://tc39.github.io/ecma262/#sec-literals-regular-expression-literals
				Scanner.prototype.testRegExp = function (pattern, flags) {
					// The BMP character to use as a replacement for astral symbols when
					// translating an ES6 "u"-flagged pattern to an ES5-compatible
					// approximation.
					// Note: replacing with '\uFFFF' enables false positives in unlikely
					// scenarios. For example, `[\u{1044f}-\u{10440}]` is an invalid
					// pattern that would not be detected by this substitution.
					var astralSubstitute = '\uFFFF';
					var tmp = pattern;
					var self = this;
					if (flags.indexOf('u') >= 0) {
						tmp = tmp.replace(/\\u\{([0-9a-fA-F]+)\}|\\u([a-fA-F0-9]{4})/g, function ($0, $1, $2) {
							var codePoint = parseInt($1 || $2, 16);
							if (codePoint > 0x10FFFF) {
								self.throwUnexpectedToken(messages_1.Messages.InvalidRegExp);
							}
							if (codePoint <= 0xFFFF) {
								return String.fromCharCode(codePoint);
							}
							return astralSubstitute;
						}).replace(/[\uD800-\uDBFF][\uDC00-\uDFFF]/g, astralSubstitute);
					}
					// First, detect invalid regular expressions.
					try {
						RegExp(tmp);
					} catch (e) {
						this.throwUnexpectedToken(messages_1.Messages.InvalidRegExp);
					}
					// Return a regular expression object for this pattern-flag pair, or
					// `null` in case the current environment doesn't support the flags it
					// uses.
					try {
						return new RegExp(pattern, flags);
					} catch (exception) {
						/* istanbul ignore next */
						return null;
					}
				};
				Scanner.prototype.scanRegExpBody = function () {
					var ch = this.source[this.index];
					assert_1.assert(ch === '/', 'Regular expression literal must start with a slash');
					var str = this.source[this.index++];
					var classMarker = false;
					var terminated = false;
					while (!this.eof()) {
						ch = this.source[this.index++];
						str += ch;
						if (ch === '\\') {
							ch = this.source[this.index++];
							// https://tc39.github.io/ecma262/#sec-literals-regular-expression-literals
							if (character_1.Character.isLineTerminator(ch.charCodeAt(0))) {
								this.throwUnexpectedToken(messages_1.Messages.UnterminatedRegExp);
							}
							str += ch;
						} else if (character_1.Character.isLineTerminator(ch.charCodeAt(0))) {
							this.throwUnexpectedToken(messages_1.Messages.UnterminatedRegExp);
						} else if (classMarker) {
							if (ch === ']') {
								classMarker = false;
							}
						} else {
							if (ch === '/') {
								terminated = true;
								break;
							} else if (ch === '[') {
								classMarker = true;
							}
						}
					}
					if (!terminated) {
						this.throwUnexpectedToken(messages_1.Messages.UnterminatedRegExp);
					}
					// Exclude leading and trailing slash.
					return str.substr(1, str.length - 2);
				};
				Scanner.prototype.scanRegExpFlags = function () {
					var str = '';
					var flags = '';
					while (!this.eof()) {
						var ch = this.source[this.index];
						if (!character_1.Character.isIdentifierPart(ch.charCodeAt(0))) {
							break;
						}
						++this.index;
						if (ch === '\\' && !this.eof()) {
							ch = this.source[this.index];
							if (ch === 'u') {
								++this.index;
								var restore = this.index;
								var char = this.scanHexEscape('u');
								if (char !== null) {
									flags += char;
									for (str += '\\u'; restore < this.index; ++restore) {
										str += this.source[restore];
									}
								} else {
									this.index = restore;
									flags += 'u';
									str += '\\u';
								}
								this.tolerateUnexpectedToken();
							} else {
								str += '\\';
								this.tolerateUnexpectedToken();
							}
						} else {
							flags += ch;
							str += ch;
						}
					}
					return flags;
				};
				Scanner.prototype.scanRegExp = function () {
					var start = this.index;
					var pattern = this.scanRegExpBody();
					var flags = this.scanRegExpFlags();
					var value = this.testRegExp(pattern, flags);
					return {
						type: 9 /* RegularExpression */
						, value: '',
						pattern: pattern,
						flags: flags,
						regex: value,
						lineNumber: this.lineNumber,
						lineStart: this.lineStart,
						start: start,
						end: this.index
					};
				};
				Scanner.prototype.lex = function () {
					if (this.eof()) {
						return {
							type: 2 /* EOF */
							, value: '',
							lineNumber: this.lineNumber,
							lineStart: this.lineStart,
							start: this.index,
							end: this.index
						};
					}
					var cp = this.source.charCodeAt(this.index);
					if (character_1.Character.isIdentifierStart(cp)) {
						return this.scanIdentifier();
					}
					// Very common: ( and ) and ;
					if (cp === 0x28 || cp === 0x29 || cp === 0x3B) {
						return this.scanPunctuator();
					}
					// String literal starts with single quote (U+0027) or double quote (U+0022).
					if (cp === 0x27 || cp === 0x22) {
						return this.scanStringLiteral();
					}
					// Dot (.) U+002E can also start a floating-point number, hence the need
					// to check the next character.
					if (cp === 0x2E) {
						if (character_1.Character.isDecimalDigit(this.source.charCodeAt(this.index + 1))) {
							return this.scanNumericLiteral();
						}
						return this.scanPunctuator();
					}
					if (character_1.Character.isDecimalDigit(cp)) {
						return this.scanNumericLiteral();
					}
					// Template literals start with ` (U+0060) for template head
					// or } (U+007D) for template middle or template tail.
					if (cp === 0x60 || cp === 0x7D && this.curlyStack[this.curlyStack.length - 1] === '${') {
						return this.scanTemplate();
					}
					// Possible identifier start in a surrogate pair.
					if (cp >= 0xD800 && cp < 0xDFFF) {
						if (character_1.Character.isIdentifierStart(this.codePointAt(this.index))) {
							return this.scanIdentifier();
						}
					}
					return this.scanPunctuator();
				};
				return Scanner;
			}();
			exports.Scanner = Scanner;

			/***/
		},
		/* 13 */
		/***/function (module, exports) {

			"use strict";

			Object.defineProperty(exports, "__esModule", { value: true });
			exports.TokenName = {};
			exports.TokenName[1 /* BooleanLiteral */] = 'Boolean';
			exports.TokenName[2 /* EOF */] = '<end>';
			exports.TokenName[3 /* Identifier */] = 'Identifier';
			exports.TokenName[4 /* Keyword */] = 'Keyword';
			exports.TokenName[5 /* NullLiteral */] = 'Null';
			exports.TokenName[6 /* NumericLiteral */] = 'Numeric';
			exports.TokenName[7 /* Punctuator */] = 'Punctuator';
			exports.TokenName[8 /* StringLiteral */] = 'String';
			exports.TokenName[9 /* RegularExpression */] = 'RegularExpression';
			exports.TokenName[10 /* Template */] = 'Template';

			/***/
		},
		/* 14 */
		/***/function (module, exports) {

			"use strict";
			// Generated by generate-xhtml-entities.js. DO NOT MODIFY!

			Object.defineProperty(exports, "__esModule", { value: true });
			exports.XHTMLEntities = {
				quot: '\u0022',
				amp: '\u0026',
				apos: '\u0027',
				gt: '\u003E',
				nbsp: '\u00A0',
				iexcl: '\u00A1',
				cent: '\u00A2',
				pound: '\u00A3',
				curren: '\u00A4',
				yen: '\u00A5',
				brvbar: '\u00A6',
				sect: '\u00A7',
				uml: '\u00A8',
				copy: '\u00A9',
				ordf: '\u00AA',
				laquo: '\u00AB',
				not: '\u00AC',
				shy: '\u00AD',
				reg: '\u00AE',
				macr: '\u00AF',
				deg: '\u00B0',
				plusmn: '\u00B1',
				sup2: '\u00B2',
				sup3: '\u00B3',
				acute: '\u00B4',
				micro: '\u00B5',
				para: '\u00B6',
				middot: '\u00B7',
				cedil: '\u00B8',
				sup1: '\u00B9',
				ordm: '\u00BA',
				raquo: '\u00BB',
				frac14: '\u00BC',
				frac12: '\u00BD',
				frac34: '\u00BE',
				iquest: '\u00BF',
				Agrave: '\u00C0',
				Aacute: '\u00C1',
				Acirc: '\u00C2',
				Atilde: '\u00C3',
				Auml: '\u00C4',
				Aring: '\u00C5',
				AElig: '\u00C6',
				Ccedil: '\u00C7',
				Egrave: '\u00C8',
				Eacute: '\u00C9',
				Ecirc: '\u00CA',
				Euml: '\u00CB',
				Igrave: '\u00CC',
				Iacute: '\u00CD',
				Icirc: '\u00CE',
				Iuml: '\u00CF',
				ETH: '\u00D0',
				Ntilde: '\u00D1',
				Ograve: '\u00D2',
				Oacute: '\u00D3',
				Ocirc: '\u00D4',
				Otilde: '\u00D5',
				Ouml: '\u00D6',
				times: '\u00D7',
				Oslash: '\u00D8',
				Ugrave: '\u00D9',
				Uacute: '\u00DA',
				Ucirc: '\u00DB',
				Uuml: '\u00DC',
				Yacute: '\u00DD',
				THORN: '\u00DE',
				szlig: '\u00DF',
				agrave: '\u00E0',
				aacute: '\u00E1',
				acirc: '\u00E2',
				atilde: '\u00E3',
				auml: '\u00E4',
				aring: '\u00E5',
				aelig: '\u00E6',
				ccedil: '\u00E7',
				egrave: '\u00E8',
				eacute: '\u00E9',
				ecirc: '\u00EA',
				euml: '\u00EB',
				igrave: '\u00EC',
				iacute: '\u00ED',
				icirc: '\u00EE',
				iuml: '\u00EF',
				eth: '\u00F0',
				ntilde: '\u00F1',
				ograve: '\u00F2',
				oacute: '\u00F3',
				ocirc: '\u00F4',
				otilde: '\u00F5',
				ouml: '\u00F6',
				divide: '\u00F7',
				oslash: '\u00F8',
				ugrave: '\u00F9',
				uacute: '\u00FA',
				ucirc: '\u00FB',
				uuml: '\u00FC',
				yacute: '\u00FD',
				thorn: '\u00FE',
				yuml: '\u00FF',
				OElig: '\u0152',
				oelig: '\u0153',
				Scaron: '\u0160',
				scaron: '\u0161',
				Yuml: '\u0178',
				fnof: '\u0192',
				circ: '\u02C6',
				tilde: '\u02DC',
				Alpha: '\u0391',
				Beta: '\u0392',
				Gamma: '\u0393',
				Delta: '\u0394',
				Epsilon: '\u0395',
				Zeta: '\u0396',
				Eta: '\u0397',
				Theta: '\u0398',
				Iota: '\u0399',
				Kappa: '\u039A',
				Lambda: '\u039B',
				Mu: '\u039C',
				Nu: '\u039D',
				Xi: '\u039E',
				Omicron: '\u039F',
				Pi: '\u03A0',
				Rho: '\u03A1',
				Sigma: '\u03A3',
				Tau: '\u03A4',
				Upsilon: '\u03A5',
				Phi: '\u03A6',
				Chi: '\u03A7',
				Psi: '\u03A8',
				Omega: '\u03A9',
				alpha: '\u03B1',
				beta: '\u03B2',
				gamma: '\u03B3',
				delta: '\u03B4',
				epsilon: '\u03B5',
				zeta: '\u03B6',
				eta: '\u03B7',
				theta: '\u03B8',
				iota: '\u03B9',
				kappa: '\u03BA',
				lambda: '\u03BB',
				mu: '\u03BC',
				nu: '\u03BD',
				xi: '\u03BE',
				omicron: '\u03BF',
				pi: '\u03C0',
				rho: '\u03C1',
				sigmaf: '\u03C2',
				sigma: '\u03C3',
				tau: '\u03C4',
				upsilon: '\u03C5',
				phi: '\u03C6',
				chi: '\u03C7',
				psi: '\u03C8',
				omega: '\u03C9',
				thetasym: '\u03D1',
				upsih: '\u03D2',
				piv: '\u03D6',
				ensp: '\u2002',
				emsp: '\u2003',
				thinsp: '\u2009',
				zwnj: '\u200C',
				zwj: '\u200D',
				lrm: '\u200E',
				rlm: '\u200F',
				ndash: '\u2013',
				mdash: '\u2014',
				lsquo: '\u2018',
				rsquo: '\u2019',
				sbquo: '\u201A',
				ldquo: '\u201C',
				rdquo: '\u201D',
				bdquo: '\u201E',
				dagger: '\u2020',
				Dagger: '\u2021',
				bull: '\u2022',
				hellip: '\u2026',
				permil: '\u2030',
				prime: '\u2032',
				Prime: '\u2033',
				lsaquo: '\u2039',
				rsaquo: '\u203A',
				oline: '\u203E',
				frasl: '\u2044',
				euro: '\u20AC',
				image: '\u2111',
				weierp: '\u2118',
				real: '\u211C',
				trade: '\u2122',
				alefsym: '\u2135',
				larr: '\u2190',
				uarr: '\u2191',
				rarr: '\u2192',
				darr: '\u2193',
				harr: '\u2194',
				crarr: '\u21B5',
				lArr: '\u21D0',
				uArr: '\u21D1',
				rArr: '\u21D2',
				dArr: '\u21D3',
				hArr: '\u21D4',
				forall: '\u2200',
				part: '\u2202',
				exist: '\u2203',
				empty: '\u2205',
				nabla: '\u2207',
				isin: '\u2208',
				notin: '\u2209',
				ni: '\u220B',
				prod: '\u220F',
				sum: '\u2211',
				minus: '\u2212',
				lowast: '\u2217',
				radic: '\u221A',
				prop: '\u221D',
				infin: '\u221E',
				ang: '\u2220',
				and: '\u2227',
				or: '\u2228',
				cap: '\u2229',
				cup: '\u222A',
				int: '\u222B',
				there4: '\u2234',
				sim: '\u223C',
				cong: '\u2245',
				asymp: '\u2248',
				ne: '\u2260',
				equiv: '\u2261',
				le: '\u2264',
				ge: '\u2265',
				sub: '\u2282',
				sup: '\u2283',
				nsub: '\u2284',
				sube: '\u2286',
				supe: '\u2287',
				oplus: '\u2295',
				otimes: '\u2297',
				perp: '\u22A5',
				sdot: '\u22C5',
				lceil: '\u2308',
				rceil: '\u2309',
				lfloor: '\u230A',
				rfloor: '\u230B',
				loz: '\u25CA',
				spades: '\u2660',
				clubs: '\u2663',
				hearts: '\u2665',
				diams: '\u2666',
				lang: '\u27E8',
				rang: '\u27E9'
			};

			/***/
		},
		/* 15 */
		/***/function (module, exports, __webpack_require__) {

			"use strict";

			Object.defineProperty(exports, "__esModule", { value: true });
			var error_handler_1 = __webpack_require__(10);
			var scanner_1 = __webpack_require__(12);
			var token_1 = __webpack_require__(13);
			var Reader = function () {
				function Reader() {
					this.values = [];
					this.curly = this.paren = -1;
				}
				// A function following one of those tokens is an expression.
				Reader.prototype.beforeFunctionExpression = function (t) {
					return ['(', '{', '[', 'in', 'typeof', 'instanceof', 'new', 'return', 'case', 'delete', 'throw', 'void',
					// assignment operators
					'=', '+=', '-=', '*=', '**=', '/=', '%=', '<<=', '>>=', '>>>=', '&=', '|=', '^=', ',',
					// binary/unary operators
					'+', '-', '*', '**', '/', '%', '++', '--', '<<', '>>', '>>>', '&', '|', '^', '!', '~', '&&', '||', '?', ':', '===', '==', '>=', '<=', '<', '>', '!=', '!=='].indexOf(t) >= 0;
				};
				// Determine if forward slash (/) is an operator or part of a regular expression
				// https://github.com/mozilla/sweet.js/wiki/design
				Reader.prototype.isRegexStart = function () {
					var previous = this.values[this.values.length - 1];
					var regex = previous !== null;
					switch (previous) {
						case 'this':
						case ']':
							regex = false;
							break;
						case ')':
							var keyword = this.values[this.paren - 1];
							regex = keyword === 'if' || keyword === 'while' || keyword === 'for' || keyword === 'with';
							break;
						case '}':
							// Dividing a function by anything makes little sense,
							// but we have to check for that.
							regex = false;
							if (this.values[this.curly - 3] === 'function') {
								// Anonymous function, e.g. function(){} /42
								var check = this.values[this.curly - 4];
								regex = check ? !this.beforeFunctionExpression(check) : false;
							} else if (this.values[this.curly - 4] === 'function') {
								// Named function, e.g. function f(){} /42/
								var check = this.values[this.curly - 5];
								regex = check ? !this.beforeFunctionExpression(check) : true;
							}
							break;
						default:
							break;
					}
					return regex;
				};
				Reader.prototype.push = function (token) {
					if (token.type === 7 /* Punctuator */ || token.type === 4 /* Keyword */) {
							if (token.value === '{') {
								this.curly = this.values.length;
							} else if (token.value === '(') {
								this.paren = this.values.length;
							}
							this.values.push(token.value);
						} else {
						this.values.push(null);
					}
				};
				return Reader;
			}();
			var Tokenizer = function () {
				function Tokenizer(code, config) {
					this.errorHandler = new error_handler_1.ErrorHandler();
					this.errorHandler.tolerant = config ? typeof config.tolerant === 'boolean' && config.tolerant : false;
					this.scanner = new scanner_1.Scanner(code, this.errorHandler);
					this.scanner.trackComment = config ? typeof config.comment === 'boolean' && config.comment : false;
					this.trackRange = config ? typeof config.range === 'boolean' && config.range : false;
					this.trackLoc = config ? typeof config.loc === 'boolean' && config.loc : false;
					this.buffer = [];
					this.reader = new Reader();
				}
				Tokenizer.prototype.errors = function () {
					return this.errorHandler.errors;
				};
				Tokenizer.prototype.getNextToken = function () {
					if (this.buffer.length === 0) {
						var comments = this.scanner.scanComments();
						if (this.scanner.trackComment) {
							for (var i = 0; i < comments.length; ++i) {
								var e = comments[i];
								var value = this.scanner.source.slice(e.slice[0], e.slice[1]);
								var comment = {
									type: e.multiLine ? 'BlockComment' : 'LineComment',
									value: value
								};
								if (this.trackRange) {
									comment.range = e.range;
								}
								if (this.trackLoc) {
									comment.loc = e.loc;
								}
								this.buffer.push(comment);
							}
						}
						if (!this.scanner.eof()) {
							var loc = void 0;
							if (this.trackLoc) {
								loc = {
									start: {
										line: this.scanner.lineNumber,
										column: this.scanner.index - this.scanner.lineStart
									},
									end: {}
								};
							}
							var startRegex = this.scanner.source[this.scanner.index] === '/' && this.reader.isRegexStart();
							var token = startRegex ? this.scanner.scanRegExp() : this.scanner.lex();
							this.reader.push(token);
							var entry = {
								type: token_1.TokenName[token.type],
								value: this.scanner.source.slice(token.start, token.end)
							};
							if (this.trackRange) {
								entry.range = [token.start, token.end];
							}
							if (this.trackLoc) {
								loc.end = {
									line: this.scanner.lineNumber,
									column: this.scanner.index - this.scanner.lineStart
								};
								entry.loc = loc;
							}
							if (token.type === 9 /* RegularExpression */) {
									var pattern = token.pattern;
									var flags = token.flags;
									entry.regex = { pattern: pattern, flags: flags };
								}
							this.buffer.push(entry);
						}
					}
					return this.buffer.shift();
				};
				return Tokenizer;
			}();
			exports.Tokenizer = Tokenizer;

			/***/
		}
		/******/])
	);
});
;

/***/ }),
/* 158 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/*eslint-disable no-use-before-define*/

var common = __webpack_require__(17);
var YAMLException = __webpack_require__(21);
var DEFAULT_FULL_SCHEMA = __webpack_require__(25);
var DEFAULT_SAFE_SCHEMA = __webpack_require__(22);

var _toString = Object.prototype.toString;
var _hasOwnProperty = Object.prototype.hasOwnProperty;

var CHAR_TAB = 0x09; /* Tab */
var CHAR_LINE_FEED = 0x0A; /* LF */
var CHAR_SPACE = 0x20; /* Space */
var CHAR_EXCLAMATION = 0x21; /* ! */
var CHAR_DOUBLE_QUOTE = 0x22; /* " */
var CHAR_SHARP = 0x23; /* # */
var CHAR_PERCENT = 0x25; /* % */
var CHAR_AMPERSAND = 0x26; /* & */
var CHAR_SINGLE_QUOTE = 0x27; /* ' */
var CHAR_ASTERISK = 0x2A; /* * */
var CHAR_COMMA = 0x2C; /* , */
var CHAR_MINUS = 0x2D; /* - */
var CHAR_COLON = 0x3A; /* : */
var CHAR_GREATER_THAN = 0x3E; /* > */
var CHAR_QUESTION = 0x3F; /* ? */
var CHAR_COMMERCIAL_AT = 0x40; /* @ */
var CHAR_LEFT_SQUARE_BRACKET = 0x5B; /* [ */
var CHAR_RIGHT_SQUARE_BRACKET = 0x5D; /* ] */
var CHAR_GRAVE_ACCENT = 0x60; /* ` */
var CHAR_LEFT_CURLY_BRACKET = 0x7B; /* { */
var CHAR_VERTICAL_LINE = 0x7C; /* | */
var CHAR_RIGHT_CURLY_BRACKET = 0x7D; /* } */

var ESCAPE_SEQUENCES = {};

ESCAPE_SEQUENCES[0x00] = '\\0';
ESCAPE_SEQUENCES[0x07] = '\\a';
ESCAPE_SEQUENCES[0x08] = '\\b';
ESCAPE_SEQUENCES[0x09] = '\\t';
ESCAPE_SEQUENCES[0x0A] = '\\n';
ESCAPE_SEQUENCES[0x0B] = '\\v';
ESCAPE_SEQUENCES[0x0C] = '\\f';
ESCAPE_SEQUENCES[0x0D] = '\\r';
ESCAPE_SEQUENCES[0x1B] = '\\e';
ESCAPE_SEQUENCES[0x22] = '\\"';
ESCAPE_SEQUENCES[0x5C] = '\\\\';
ESCAPE_SEQUENCES[0x85] = '\\N';
ESCAPE_SEQUENCES[0xA0] = '\\_';
ESCAPE_SEQUENCES[0x2028] = '\\L';
ESCAPE_SEQUENCES[0x2029] = '\\P';

var DEPRECATED_BOOLEANS_SYNTAX = ['y', 'Y', 'yes', 'Yes', 'YES', 'on', 'On', 'ON', 'n', 'N', 'no', 'No', 'NO', 'off', 'Off', 'OFF'];

function compileStyleMap(schema, map) {
  var result, keys, index, length, tag, style, type;

  if (map === null) return {};

  result = {};
  keys = Object.keys(map);

  for (index = 0, length = keys.length; index < length; index += 1) {
    tag = keys[index];
    style = String(map[tag]);

    if (tag.slice(0, 2) === '!!') {
      tag = 'tag:yaml.org,2002:' + tag.slice(2);
    }
    type = schema.compiledTypeMap['fallback'][tag];

    if (type && _hasOwnProperty.call(type.styleAliases, style)) {
      style = type.styleAliases[style];
    }

    result[tag] = style;
  }

  return result;
}

function encodeHex(character) {
  var string, handle, length;

  string = character.toString(16).toUpperCase();

  if (character <= 0xFF) {
    handle = 'x';
    length = 2;
  } else if (character <= 0xFFFF) {
    handle = 'u';
    length = 4;
  } else if (character <= 0xFFFFFFFF) {
    handle = 'U';
    length = 8;
  } else {
    throw new YAMLException('code point within a string may not be greater than 0xFFFFFFFF');
  }

  return '\\' + handle + common.repeat('0', length - string.length) + string;
}

function State(options) {
  this.schema = options['schema'] || DEFAULT_FULL_SCHEMA;
  this.indent = Math.max(1, options['indent'] || 2);
  this.skipInvalid = options['skipInvalid'] || false;
  this.flowLevel = common.isNothing(options['flowLevel']) ? -1 : options['flowLevel'];
  this.styleMap = compileStyleMap(this.schema, options['styles'] || null);
  this.sortKeys = options['sortKeys'] || false;
  this.lineWidth = options['lineWidth'] || 80;
  this.noRefs = options['noRefs'] || false;
  this.noCompatMode = options['noCompatMode'] || false;
  this.condenseFlow = options['condenseFlow'] || false;

  this.implicitTypes = this.schema.compiledImplicit;
  this.explicitTypes = this.schema.compiledExplicit;

  this.tag = null;
  this.result = '';

  this.duplicates = [];
  this.usedDuplicates = null;
}

// Indents every line in a string. Empty lines (\n only) are not indented.
function indentString(string, spaces) {
  var ind = common.repeat(' ', spaces),
      position = 0,
      next = -1,
      result = '',
      line,
      length = string.length;

  while (position < length) {
    next = string.indexOf('\n', position);
    if (next === -1) {
      line = string.slice(position);
      position = length;
    } else {
      line = string.slice(position, next + 1);
      position = next + 1;
    }

    if (line.length && line !== '\n') result += ind;

    result += line;
  }

  return result;
}

function generateNextLine(state, level) {
  return '\n' + common.repeat(' ', state.indent * level);
}

function testImplicitResolving(state, str) {
  var index, length, type;

  for (index = 0, length = state.implicitTypes.length; index < length; index += 1) {
    type = state.implicitTypes[index];

    if (type.resolve(str)) {
      return true;
    }
  }

  return false;
}

// [33] s-white ::= s-space | s-tab
function isWhitespace(c) {
  return c === CHAR_SPACE || c === CHAR_TAB;
}

// Returns true if the character can be printed without escaping.
// From YAML 1.2: "any allowed characters known to be non-printable
// should also be escaped. [However,] This isn’t mandatory"
// Derived from nb-char - \t - #x85 - #xA0 - #x2028 - #x2029.
function isPrintable(c) {
  return 0x00020 <= c && c <= 0x00007E || 0x000A1 <= c && c <= 0x00D7FF && c !== 0x2028 && c !== 0x2029 || 0x0E000 <= c && c <= 0x00FFFD && c !== 0xFEFF /* BOM */ || 0x10000 <= c && c <= 0x10FFFF;
}

// Simplified test for values allowed after the first character in plain style.
function isPlainSafe(c) {
  // Uses a subset of nb-char - c-flow-indicator - ":" - "#"
  // where nb-char ::= c-printable - b-char - c-byte-order-mark.
  return isPrintable(c) && c !== 0xFEFF
  // - c-flow-indicator
  && c !== CHAR_COMMA && c !== CHAR_LEFT_SQUARE_BRACKET && c !== CHAR_RIGHT_SQUARE_BRACKET && c !== CHAR_LEFT_CURLY_BRACKET && c !== CHAR_RIGHT_CURLY_BRACKET
  // - ":" - "#"
  && c !== CHAR_COLON && c !== CHAR_SHARP;
}

// Simplified test for values allowed as the first character in plain style.
function isPlainSafeFirst(c) {
  // Uses a subset of ns-char - c-indicator
  // where ns-char = nb-char - s-white.
  return isPrintable(c) && c !== 0xFEFF && !isWhitespace(c) // - s-white
  // - (c-indicator ::=
  // “-” | “?” | “:” | “,” | “[” | “]” | “{” | “}”
  && c !== CHAR_MINUS && c !== CHAR_QUESTION && c !== CHAR_COLON && c !== CHAR_COMMA && c !== CHAR_LEFT_SQUARE_BRACKET && c !== CHAR_RIGHT_SQUARE_BRACKET && c !== CHAR_LEFT_CURLY_BRACKET && c !== CHAR_RIGHT_CURLY_BRACKET
  // | “#” | “&” | “*” | “!” | “|” | “>” | “'” | “"”
  && c !== CHAR_SHARP && c !== CHAR_AMPERSAND && c !== CHAR_ASTERISK && c !== CHAR_EXCLAMATION && c !== CHAR_VERTICAL_LINE && c !== CHAR_GREATER_THAN && c !== CHAR_SINGLE_QUOTE && c !== CHAR_DOUBLE_QUOTE
  // | “%” | “@” | “`”)
  && c !== CHAR_PERCENT && c !== CHAR_COMMERCIAL_AT && c !== CHAR_GRAVE_ACCENT;
}

var STYLE_PLAIN = 1,
    STYLE_SINGLE = 2,
    STYLE_LITERAL = 3,
    STYLE_FOLDED = 4,
    STYLE_DOUBLE = 5;

// Determines which scalar styles are possible and returns the preferred style.
// lineWidth = -1 => no limit.
// Pre-conditions: str.length > 0.
// Post-conditions:
//    STYLE_PLAIN or STYLE_SINGLE => no \n are in the string.
//    STYLE_LITERAL => no lines are suitable for folding (or lineWidth is -1).
//    STYLE_FOLDED => a line > lineWidth and can be folded (and lineWidth != -1).
function chooseScalarStyle(string, singleLineOnly, indentPerLevel, lineWidth, testAmbiguousType) {
  var i;
  var char;
  var hasLineBreak = false;
  var hasFoldableLine = false; // only checked if shouldTrackWidth
  var shouldTrackWidth = lineWidth !== -1;
  var previousLineBreak = -1; // count the first line correctly
  var plain = isPlainSafeFirst(string.charCodeAt(0)) && !isWhitespace(string.charCodeAt(string.length - 1));

  if (singleLineOnly) {
    // Case: no block styles.
    // Check for disallowed characters to rule out plain and single.
    for (i = 0; i < string.length; i++) {
      char = string.charCodeAt(i);
      if (!isPrintable(char)) {
        return STYLE_DOUBLE;
      }
      plain = plain && isPlainSafe(char);
    }
  } else {
    // Case: block styles permitted.
    for (i = 0; i < string.length; i++) {
      char = string.charCodeAt(i);
      if (char === CHAR_LINE_FEED) {
        hasLineBreak = true;
        // Check if any line can be folded.
        if (shouldTrackWidth) {
          hasFoldableLine = hasFoldableLine ||
          // Foldable line = too long, and not more-indented.
          i - previousLineBreak - 1 > lineWidth && string[previousLineBreak + 1] !== ' ';
          previousLineBreak = i;
        }
      } else if (!isPrintable(char)) {
        return STYLE_DOUBLE;
      }
      plain = plain && isPlainSafe(char);
    }
    // in case the end is missing a \n
    hasFoldableLine = hasFoldableLine || shouldTrackWidth && i - previousLineBreak - 1 > lineWidth && string[previousLineBreak + 1] !== ' ';
  }
  // Although every style can represent \n without escaping, prefer block styles
  // for multiline, since they're more readable and they don't add empty lines.
  // Also prefer folding a super-long line.
  if (!hasLineBreak && !hasFoldableLine) {
    // Strings interpretable as another type have to be quoted;
    // e.g. the string 'true' vs. the boolean true.
    return plain && !testAmbiguousType(string) ? STYLE_PLAIN : STYLE_SINGLE;
  }
  // Edge case: block indentation indicator can only have one digit.
  if (string[0] === ' ' && indentPerLevel > 9) {
    return STYLE_DOUBLE;
  }
  // At this point we know block styles are valid.
  // Prefer literal style unless we want to fold.
  return hasFoldableLine ? STYLE_FOLDED : STYLE_LITERAL;
}

// Note: line breaking/folding is implemented for only the folded style.
// NB. We drop the last trailing newline (if any) of a returned block scalar
//  since the dumper adds its own newline. This always works:
//    • No ending newline => unaffected; already using strip "-" chomping.
//    • Ending newline    => removed then restored.
//  Importantly, this keeps the "+" chomp indicator from gaining an extra line.
function writeScalar(state, string, level, iskey) {
  state.dump = function () {
    if (string.length === 0) {
      return "''";
    }
    if (!state.noCompatMode && DEPRECATED_BOOLEANS_SYNTAX.indexOf(string) !== -1) {
      return "'" + string + "'";
    }

    var indent = state.indent * Math.max(1, level); // no 0-indent scalars
    // As indentation gets deeper, let the width decrease monotonically
    // to the lower bound min(state.lineWidth, 40).
    // Note that this implies
    //  state.lineWidth ≤ 40 + state.indent: width is fixed at the lower bound.
    //  state.lineWidth > 40 + state.indent: width decreases until the lower bound.
    // This behaves better than a constant minimum width which disallows narrower options,
    // or an indent threshold which causes the width to suddenly increase.
    var lineWidth = state.lineWidth === -1 ? -1 : Math.max(Math.min(state.lineWidth, 40), state.lineWidth - indent);

    // Without knowing if keys are implicit/explicit, assume implicit for safety.
    var singleLineOnly = iskey
    // No block styles in flow mode.
    || state.flowLevel > -1 && level >= state.flowLevel;
    function testAmbiguity(string) {
      return testImplicitResolving(state, string);
    }

    switch (chooseScalarStyle(string, singleLineOnly, state.indent, lineWidth, testAmbiguity)) {
      case STYLE_PLAIN:
        return string;
      case STYLE_SINGLE:
        return "'" + string.replace(/'/g, "''") + "'";
      case STYLE_LITERAL:
        return '|' + blockHeader(string, state.indent) + dropEndingNewline(indentString(string, indent));
      case STYLE_FOLDED:
        return '>' + blockHeader(string, state.indent) + dropEndingNewline(indentString(foldString(string, lineWidth), indent));
      case STYLE_DOUBLE:
        return '"' + escapeString(string, lineWidth) + '"';
      default:
        throw new YAMLException('impossible error: invalid scalar style');
    }
  }();
}

// Pre-conditions: string is valid for a block scalar, 1 <= indentPerLevel <= 9.
function blockHeader(string, indentPerLevel) {
  var indentIndicator = string[0] === ' ' ? String(indentPerLevel) : '';

  // note the special case: the string '\n' counts as a "trailing" empty line.
  var clip = string[string.length - 1] === '\n';
  var keep = clip && (string[string.length - 2] === '\n' || string === '\n');
  var chomp = keep ? '+' : clip ? '' : '-';

  return indentIndicator + chomp + '\n';
}

// (See the note for writeScalar.)
function dropEndingNewline(string) {
  return string[string.length - 1] === '\n' ? string.slice(0, -1) : string;
}

// Note: a long line without a suitable break point will exceed the width limit.
// Pre-conditions: every char in str isPrintable, str.length > 0, width > 0.
function foldString(string, width) {
  // In folded style, $k$ consecutive newlines output as $k+1$ newlines—
  // unless they're before or after a more-indented line, or at the very
  // beginning or end, in which case $k$ maps to $k$.
  // Therefore, parse each chunk as newline(s) followed by a content line.
  var lineRe = /(\n+)([^\n]*)/g;

  // first line (possibly an empty line)
  var result = function () {
    var nextLF = string.indexOf('\n');
    nextLF = nextLF !== -1 ? nextLF : string.length;
    lineRe.lastIndex = nextLF;
    return foldLine(string.slice(0, nextLF), width);
  }();
  // If we haven't reached the first content line yet, don't add an extra \n.
  var prevMoreIndented = string[0] === '\n' || string[0] === ' ';
  var moreIndented;

  // rest of the lines
  var match;
  while (match = lineRe.exec(string)) {
    var prefix = match[1],
        line = match[2];
    moreIndented = line[0] === ' ';
    result += prefix + (!prevMoreIndented && !moreIndented && line !== '' ? '\n' : '') + foldLine(line, width);
    prevMoreIndented = moreIndented;
  }

  return result;
}

// Greedy line breaking.
// Picks the longest line under the limit each time,
// otherwise settles for the shortest line over the limit.
// NB. More-indented lines *cannot* be folded, as that would add an extra \n.
function foldLine(line, width) {
  if (line === '' || line[0] === ' ') return line;

  // Since a more-indented line adds a \n, breaks can't be followed by a space.
  var breakRe = / [^ ]/g; // note: the match index will always be <= length-2.
  var match;
  // start is an inclusive index. end, curr, and next are exclusive.
  var start = 0,
      end,
      curr = 0,
      next = 0;
  var result = '';

  // Invariants: 0 <= start <= length-1.
  //   0 <= curr <= next <= max(0, length-2). curr - start <= width.
  // Inside the loop:
  //   A match implies length >= 2, so curr and next are <= length-2.
  while (match = breakRe.exec(line)) {
    next = match.index;
    // maintain invariant: curr - start <= width
    if (next - start > width) {
      end = curr > start ? curr : next; // derive end <= length-2
      result += '\n' + line.slice(start, end);
      // skip the space that was output as \n
      start = end + 1; // derive start <= length-1
    }
    curr = next;
  }

  // By the invariants, start <= length-1, so there is something left over.
  // It is either the whole string or a part starting from non-whitespace.
  result += '\n';
  // Insert a break if the remainder is too long and there is a break available.
  if (line.length - start > width && curr > start) {
    result += line.slice(start, curr) + '\n' + line.slice(curr + 1);
  } else {
    result += line.slice(start);
  }

  return result.slice(1); // drop extra \n joiner
}

// Escapes a double-quoted string.
function escapeString(string) {
  var result = '';
  var char, nextChar;
  var escapeSeq;

  for (var i = 0; i < string.length; i++) {
    char = string.charCodeAt(i);
    // Check for surrogate pairs (reference Unicode 3.0 section "3.7 Surrogates").
    if (char >= 0xD800 && char <= 0xDBFF /* high surrogate */) {
        nextChar = string.charCodeAt(i + 1);
        if (nextChar >= 0xDC00 && nextChar <= 0xDFFF /* low surrogate */) {
            // Combine the surrogate pair and store it escaped.
            result += encodeHex((char - 0xD800) * 0x400 + nextChar - 0xDC00 + 0x10000);
            // Advance index one extra since we already used that char here.
            i++;continue;
          }
      }
    escapeSeq = ESCAPE_SEQUENCES[char];
    result += !escapeSeq && isPrintable(char) ? string[i] : escapeSeq || encodeHex(char);
  }

  return result;
}

function writeFlowSequence(state, level, object) {
  var _result = '',
      _tag = state.tag,
      index,
      length;

  for (index = 0, length = object.length; index < length; index += 1) {
    // Write only valid elements.
    if (writeNode(state, level, object[index], false, false)) {
      if (index !== 0) _result += ',' + (!state.condenseFlow ? ' ' : '');
      _result += state.dump;
    }
  }

  state.tag = _tag;
  state.dump = '[' + _result + ']';
}

function writeBlockSequence(state, level, object, compact) {
  var _result = '',
      _tag = state.tag,
      index,
      length;

  for (index = 0, length = object.length; index < length; index += 1) {
    // Write only valid elements.
    if (writeNode(state, level + 1, object[index], true, true)) {
      if (!compact || index !== 0) {
        _result += generateNextLine(state, level);
      }

      if (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0)) {
        _result += '-';
      } else {
        _result += '- ';
      }

      _result += state.dump;
    }
  }

  state.tag = _tag;
  state.dump = _result || '[]'; // Empty sequence if no valid values.
}

function writeFlowMapping(state, level, object) {
  var _result = '',
      _tag = state.tag,
      objectKeyList = Object.keys(object),
      index,
      length,
      objectKey,
      objectValue,
      pairBuffer;

  for (index = 0, length = objectKeyList.length; index < length; index += 1) {
    pairBuffer = state.condenseFlow ? '"' : '';

    if (index !== 0) pairBuffer += ', ';

    objectKey = objectKeyList[index];
    objectValue = object[objectKey];

    if (!writeNode(state, level, objectKey, false, false)) {
      continue; // Skip this pair because of invalid key;
    }

    if (state.dump.length > 1024) pairBuffer += '? ';

    pairBuffer += state.dump + (state.condenseFlow ? '"' : '') + ':' + (state.condenseFlow ? '' : ' ');

    if (!writeNode(state, level, objectValue, false, false)) {
      continue; // Skip this pair because of invalid value.
    }

    pairBuffer += state.dump;

    // Both key and value are valid.
    _result += pairBuffer;
  }

  state.tag = _tag;
  state.dump = '{' + _result + '}';
}

function writeBlockMapping(state, level, object, compact) {
  var _result = '',
      _tag = state.tag,
      objectKeyList = Object.keys(object),
      index,
      length,
      objectKey,
      objectValue,
      explicitPair,
      pairBuffer;

  // Allow sorting keys so that the output file is deterministic
  if (state.sortKeys === true) {
    // Default sorting
    objectKeyList.sort();
  } else if (typeof state.sortKeys === 'function') {
    // Custom sort function
    objectKeyList.sort(state.sortKeys);
  } else if (state.sortKeys) {
    // Something is wrong
    throw new YAMLException('sortKeys must be a boolean or a function');
  }

  for (index = 0, length = objectKeyList.length; index < length; index += 1) {
    pairBuffer = '';

    if (!compact || index !== 0) {
      pairBuffer += generateNextLine(state, level);
    }

    objectKey = objectKeyList[index];
    objectValue = object[objectKey];

    if (!writeNode(state, level + 1, objectKey, true, true, true)) {
      continue; // Skip this pair because of invalid key.
    }

    explicitPair = state.tag !== null && state.tag !== '?' || state.dump && state.dump.length > 1024;

    if (explicitPair) {
      if (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0)) {
        pairBuffer += '?';
      } else {
        pairBuffer += '? ';
      }
    }

    pairBuffer += state.dump;

    if (explicitPair) {
      pairBuffer += generateNextLine(state, level);
    }

    if (!writeNode(state, level + 1, objectValue, true, explicitPair)) {
      continue; // Skip this pair because of invalid value.
    }

    if (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0)) {
      pairBuffer += ':';
    } else {
      pairBuffer += ': ';
    }

    pairBuffer += state.dump;

    // Both key and value are valid.
    _result += pairBuffer;
  }

  state.tag = _tag;
  state.dump = _result || '{}'; // Empty mapping if no valid pairs.
}

function detectType(state, object, explicit) {
  var _result, typeList, index, length, type, style;

  typeList = explicit ? state.explicitTypes : state.implicitTypes;

  for (index = 0, length = typeList.length; index < length; index += 1) {
    type = typeList[index];

    if ((type.instanceOf || type.predicate) && (!type.instanceOf || typeof object === 'object' && object instanceof type.instanceOf) && (!type.predicate || type.predicate(object))) {

      state.tag = explicit ? type.tag : '?';

      if (type.represent) {
        style = state.styleMap[type.tag] || type.defaultStyle;

        if (_toString.call(type.represent) === '[object Function]') {
          _result = type.represent(object, style);
        } else if (_hasOwnProperty.call(type.represent, style)) {
          _result = type.represent[style](object, style);
        } else {
          throw new YAMLException('!<' + type.tag + '> tag resolver accepts not "' + style + '" style');
        }

        state.dump = _result;
      }

      return true;
    }
  }

  return false;
}

// Serializes `object` and writes it to global `result`.
// Returns true on success, or false on invalid object.
//
function writeNode(state, level, object, block, compact, iskey) {
  state.tag = null;
  state.dump = object;

  if (!detectType(state, object, false)) {
    detectType(state, object, true);
  }

  var type = _toString.call(state.dump);

  if (block) {
    block = state.flowLevel < 0 || state.flowLevel > level;
  }

  var objectOrArray = type === '[object Object]' || type === '[object Array]',
      duplicateIndex,
      duplicate;

  if (objectOrArray) {
    duplicateIndex = state.duplicates.indexOf(object);
    duplicate = duplicateIndex !== -1;
  }

  if (state.tag !== null && state.tag !== '?' || duplicate || state.indent !== 2 && level > 0) {
    compact = false;
  }

  if (duplicate && state.usedDuplicates[duplicateIndex]) {
    state.dump = '*ref_' + duplicateIndex;
  } else {
    if (objectOrArray && duplicate && !state.usedDuplicates[duplicateIndex]) {
      state.usedDuplicates[duplicateIndex] = true;
    }
    if (type === '[object Object]') {
      if (block && Object.keys(state.dump).length !== 0) {
        writeBlockMapping(state, level, state.dump, compact);
        if (duplicate) {
          state.dump = '&ref_' + duplicateIndex + state.dump;
        }
      } else {
        writeFlowMapping(state, level, state.dump);
        if (duplicate) {
          state.dump = '&ref_' + duplicateIndex + ' ' + state.dump;
        }
      }
    } else if (type === '[object Array]') {
      if (block && state.dump.length !== 0) {
        writeBlockSequence(state, level, state.dump, compact);
        if (duplicate) {
          state.dump = '&ref_' + duplicateIndex + state.dump;
        }
      } else {
        writeFlowSequence(state, level, state.dump);
        if (duplicate) {
          state.dump = '&ref_' + duplicateIndex + ' ' + state.dump;
        }
      }
    } else if (type === '[object String]') {
      if (state.tag !== '?') {
        writeScalar(state, state.dump, level, iskey);
      }
    } else {
      if (state.skipInvalid) return false;
      throw new YAMLException('unacceptable kind of an object to dump ' + type);
    }

    if (state.tag !== null && state.tag !== '?') {
      state.dump = '!<' + state.tag + '> ' + state.dump;
    }
  }

  return true;
}

function getDuplicateReferences(object, state) {
  var objects = [],
      duplicatesIndexes = [],
      index,
      length;

  inspectNode(object, objects, duplicatesIndexes);

  for (index = 0, length = duplicatesIndexes.length; index < length; index += 1) {
    state.duplicates.push(objects[duplicatesIndexes[index]]);
  }
  state.usedDuplicates = new Array(length);
}

function inspectNode(object, objects, duplicatesIndexes) {
  var objectKeyList, index, length;

  if (object !== null && typeof object === 'object') {
    index = objects.indexOf(object);
    if (index !== -1) {
      if (duplicatesIndexes.indexOf(index) === -1) {
        duplicatesIndexes.push(index);
      }
    } else {
      objects.push(object);

      if (Array.isArray(object)) {
        for (index = 0, length = object.length; index < length; index += 1) {
          inspectNode(object[index], objects, duplicatesIndexes);
        }
      } else {
        objectKeyList = Object.keys(object);

        for (index = 0, length = objectKeyList.length; index < length; index += 1) {
          inspectNode(object[objectKeyList[index]], objects, duplicatesIndexes);
        }
      }
    }
  }
}

function dump(input, options) {
  options = options || {};

  var state = new State(options);

  if (!state.noRefs) getDuplicateReferences(input, state);

  if (writeNode(state, 0, input, true, true)) return state.dump + '\n';

  return '';
}

function safeDump(input, options) {
  return dump(input, common.extend({ schema: DEFAULT_SAFE_SCHEMA }, options));
}

module.exports.dump = dump;
module.exports.safeDump = safeDump;

/***/ }),
/* 159 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
class Lazy {
    constructor(creator) {
        this.creator = creator;
    }
    get hasValue() {
        return this.creator == null;
    }
    get value() {
        if (this.creator == null) {
            return this._value;
        }
        this.value = this.creator();
        return this._value;
    }
    set value(value) {
        this._value = value;
        this.creator = null;
    }
}
exports.Lazy = Lazy; //# sourceMappingURL=main.js.map

/***/ }),
/* 160 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var SourceMapConsumer = __webpack_require__(161).SourceMapConsumer;
var path = __webpack_require__(0);

var fs;
try {
  fs = __webpack_require__(12);
  if (!fs.existsSync || !fs.readFileSync) {
    // fs doesn't have all methods we need
    fs = null;
  }
} catch (err) {}
/* nop */


// Only install once if called multiple times
var errorFormatterInstalled = false;
var uncaughtShimInstalled = false;

// If true, the caches are reset before a stack trace formatting operation
var emptyCacheBetweenOperations = false;

// Supports {browser, node, auto}
var environment = "auto";

// Maps a file path to a string containing the file contents
var fileContentsCache = {};

// Maps a file path to a source map for that file
var sourceMapCache = {};

// Regex for detecting source maps
var reSourceMap = /^data:application\/json[^,]+base64,/;

// Priority list of retrieve handlers
var retrieveFileHandlers = [];
var retrieveMapHandlers = [];

function isInBrowser() {
  if (environment === "browser") return true;
  if (environment === "node") return false;
  return typeof window !== 'undefined' && typeof XMLHttpRequest === 'function' && !(window.require && window.module && window.process && window.process.type === "renderer");
}

function hasGlobalProcessEventEmitter() {
  return typeof process === 'object' && process !== null && typeof process.on === 'function';
}

function handlerExec(list) {
  return function (arg) {
    for (var i = 0; i < list.length; i++) {
      var ret = list[i](arg);
      if (ret) {
        return ret;
      }
    }
    return null;
  };
}

var retrieveFile = handlerExec(retrieveFileHandlers);

retrieveFileHandlers.push(function (path) {
  // Trim the path to make sure there is no extra whitespace.
  path = path.trim();
  if (path in fileContentsCache) {
    return fileContentsCache[path];
  }

  var contents = null;
  if (!fs) {
    // Use SJAX if we are in the browser
    var xhr = new XMLHttpRequest();
    xhr.open('GET', path, false);
    xhr.send(null);
    var contents = null;
    if (xhr.readyState === 4 && xhr.status === 200) {
      contents = xhr.responseText;
    }
  } else if (fs.existsSync(path)) {
    // Otherwise, use the filesystem
    try {
      contents = fs.readFileSync(path, 'utf8');
    } catch (er) {
      contents = '';
    }
  }

  return fileContentsCache[path] = contents;
});

// Support URLs relative to a directory, but be careful about a protocol prefix
// in case we are in the browser (i.e. directories may start with "http://")
function supportRelativeURL(file, url) {
  if (!file) return url;
  var dir = path.dirname(file);
  var match = /^\w+:\/\/[^\/]*/.exec(dir);
  var protocol = match ? match[0] : '';
  return protocol + path.resolve(dir.slice(protocol.length), url);
}

function retrieveSourceMapURL(source) {
  var fileData;

  if (isInBrowser()) {
    try {
      var xhr = new XMLHttpRequest();
      xhr.open('GET', source, false);
      xhr.send(null);
      fileData = xhr.readyState === 4 ? xhr.responseText : null;

      // Support providing a sourceMappingURL via the SourceMap header
      var sourceMapHeader = xhr.getResponseHeader("SourceMap") || xhr.getResponseHeader("X-SourceMap");
      if (sourceMapHeader) {
        return sourceMapHeader;
      }
    } catch (e) {}
  }

  // Get the URL of the source map
  fileData = retrieveFile(source);
  var re = /(?:\/\/[@#][ \t]+sourceMappingURL=([^\s'"]+?)[ \t]*$)|(?:\/\*[@#][ \t]+sourceMappingURL=([^\*]+?)[ \t]*(?:\*\/)[ \t]*$)/mg;
  // Keep executing the search to find the *last* sourceMappingURL to avoid
  // picking up sourceMappingURLs from comments, strings, etc.
  var lastMatch, match;
  while (match = re.exec(fileData)) lastMatch = match;
  if (!lastMatch) return null;
  return lastMatch[1];
};

// Can be overridden by the retrieveSourceMap option to install. Takes a
// generated source filename; returns a {map, optional url} object, or null if
// there is no source map.  The map field may be either a string or the parsed
// JSON object (ie, it must be a valid argument to the SourceMapConsumer
// constructor).
var retrieveSourceMap = handlerExec(retrieveMapHandlers);
retrieveMapHandlers.push(function (source) {
  var sourceMappingURL = retrieveSourceMapURL(source);
  if (!sourceMappingURL) return null;

  // Read the contents of the source map
  var sourceMapData;
  if (reSourceMap.test(sourceMappingURL)) {
    // Support source map URL as a data url
    var rawData = sourceMappingURL.slice(sourceMappingURL.indexOf(',') + 1);
    sourceMapData = new Buffer(rawData, "base64").toString();
    sourceMappingURL = source;
  } else {
    // Support source map URLs relative to the source URL
    sourceMappingURL = supportRelativeURL(source, sourceMappingURL);
    sourceMapData = retrieveFile(sourceMappingURL);
  }

  if (!sourceMapData) {
    return null;
  }

  return {
    url: sourceMappingURL,
    map: sourceMapData
  };
});

function mapSourcePosition(position) {
  var sourceMap = sourceMapCache[position.source];
  if (!sourceMap) {
    // Call the (overrideable) retrieveSourceMap function to get the source map.
    var urlAndMap = retrieveSourceMap(position.source);
    if (urlAndMap) {
      sourceMap = sourceMapCache[position.source] = {
        url: urlAndMap.url,
        map: new SourceMapConsumer(urlAndMap.map)
      };

      // Load all sources stored inline with the source map into the file cache
      // to pretend like they are already loaded. They may not exist on disk.
      if (sourceMap.map.sourcesContent) {
        sourceMap.map.sources.forEach(function (source, i) {
          var contents = sourceMap.map.sourcesContent[i];
          if (contents) {
            var url = supportRelativeURL(sourceMap.url, source);
            fileContentsCache[url] = contents;
          }
        });
      }
    } else {
      sourceMap = sourceMapCache[position.source] = {
        url: null,
        map: null
      };
    }
  }

  // Resolve the source URL relative to the URL of the source map
  if (sourceMap && sourceMap.map) {
    var originalPosition = sourceMap.map.originalPositionFor(position);

    // Only return the original position if a matching line was found. If no
    // matching line is found then we return position instead, which will cause
    // the stack trace to print the path and line for the compiled file. It is
    // better to give a precise location in the compiled file than a vague
    // location in the original file.
    if (originalPosition.source !== null) {
      originalPosition.source = supportRelativeURL(sourceMap.url, originalPosition.source);
      return originalPosition;
    }
  }

  return position;
}

// Parses code generated by FormatEvalOrigin(), a function inside V8:
// https://code.google.com/p/v8/source/browse/trunk/src/messages.js
function mapEvalOrigin(origin) {
  // Most eval() calls are in this format
  var match = /^eval at ([^(]+) \((.+):(\d+):(\d+)\)$/.exec(origin);
  if (match) {
    var position = mapSourcePosition({
      source: match[2],
      line: +match[3],
      column: match[4] - 1
    });
    return 'eval at ' + match[1] + ' (' + position.source + ':' + position.line + ':' + (position.column + 1) + ')';
  }

  // Parse nested eval() calls using recursion
  match = /^eval at ([^(]+) \((.+)\)$/.exec(origin);
  if (match) {
    return 'eval at ' + match[1] + ' (' + mapEvalOrigin(match[2]) + ')';
  }

  // Make sure we still return useful information if we didn't find anything
  return origin;
}

// This is copied almost verbatim from the V8 source code at
// https://code.google.com/p/v8/source/browse/trunk/src/messages.js. The
// implementation of wrapCallSite() used to just forward to the actual source
// code of CallSite.prototype.toString but unfortunately a new release of V8
// did something to the prototype chain and broke the shim. The only fix I
// could find was copy/paste.
function CallSiteToString() {
  var fileName;
  var fileLocation = "";
  if (this.isNative()) {
    fileLocation = "native";
  } else {
    fileName = this.getScriptNameOrSourceURL();
    if (!fileName && this.isEval()) {
      fileLocation = this.getEvalOrigin();
      fileLocation += ", "; // Expecting source position to follow.
    }

    if (fileName) {
      fileLocation += fileName;
    } else {
      // Source code does not originate from a file and is not native, but we
      // can still get the source position inside the source string, e.g. in
      // an eval string.
      fileLocation += "<anonymous>";
    }
    var lineNumber = this.getLineNumber();
    if (lineNumber != null) {
      fileLocation += ":" + lineNumber;
      var columnNumber = this.getColumnNumber();
      if (columnNumber) {
        fileLocation += ":" + columnNumber;
      }
    }
  }

  var line = "";
  var functionName = this.getFunctionName();
  var addSuffix = true;
  var isConstructor = this.isConstructor();
  var isMethodCall = !(this.isToplevel() || isConstructor);
  if (isMethodCall) {
    var typeName = this.getTypeName();
    // Fixes shim to be backward compatable with Node v0 to v4
    if (typeName === "[object Object]") {
      typeName = "null";
    }
    var methodName = this.getMethodName();
    if (functionName) {
      if (typeName && functionName.indexOf(typeName) != 0) {
        line += typeName + ".";
      }
      line += functionName;
      if (methodName && functionName.indexOf("." + methodName) != functionName.length - methodName.length - 1) {
        line += " [as " + methodName + "]";
      }
    } else {
      line += typeName + "." + (methodName || "<anonymous>");
    }
  } else if (isConstructor) {
    line += "new " + (functionName || "<anonymous>");
  } else if (functionName) {
    line += functionName;
  } else {
    line += fileLocation;
    addSuffix = false;
  }
  if (addSuffix) {
    line += " (" + fileLocation + ")";
  }
  return line;
}

function cloneCallSite(frame) {
  var object = {};
  Object.getOwnPropertyNames(Object.getPrototypeOf(frame)).forEach(function (name) {
    object[name] = /^(?:is|get)/.test(name) ? function () {
      return frame[name].call(frame);
    } : frame[name];
  });
  object.toString = CallSiteToString;
  return object;
}

function wrapCallSite(frame) {
  if (frame.isNative()) {
    return frame;
  }

  // Most call sites will return the source file from getFileName(), but code
  // passed to eval() ending in "//# sourceURL=..." will return the source file
  // from getScriptNameOrSourceURL() instead
  var source = frame.getFileName() || frame.getScriptNameOrSourceURL();
  if (source) {
    var line = frame.getLineNumber();
    var column = frame.getColumnNumber() - 1;

    // Fix position in Node where some (internal) code is prepended.
    // See https://github.com/evanw/node-source-map-support/issues/36
    var headerLength = 62;
    if (line === 1 && column > headerLength && !isInBrowser() && !frame.isEval()) {
      column -= headerLength;
    }

    var position = mapSourcePosition({
      source: source,
      line: line,
      column: column
    });
    frame = cloneCallSite(frame);
    frame.getFileName = function () {
      return position.source;
    };
    frame.getLineNumber = function () {
      return position.line;
    };
    frame.getColumnNumber = function () {
      return position.column + 1;
    };
    frame.getScriptNameOrSourceURL = function () {
      return position.source;
    };
    return frame;
  }

  // Code called using eval() needs special handling
  var origin = frame.isEval() && frame.getEvalOrigin();
  if (origin) {
    origin = mapEvalOrigin(origin);
    frame = cloneCallSite(frame);
    frame.getEvalOrigin = function () {
      return origin;
    };
    return frame;
  }

  // If we get here then we were unable to change the source position
  return frame;
}

// This function is part of the V8 stack trace API, for more info see:
// http://code.google.com/p/v8/wiki/JavaScriptStackTraceApi
function prepareStackTrace(error, stack) {
  if (emptyCacheBetweenOperations) {
    fileContentsCache = {};
    sourceMapCache = {};
  }

  return error + stack.map(function (frame) {
    return '\n    at ' + wrapCallSite(frame);
  }).join('');
}

// Generate position and snippet of original source with pointer
function getErrorSource(error) {
  var match = /\n    at [^(]+ \((.*):(\d+):(\d+)\)/.exec(error.stack);
  if (match) {
    var source = match[1];
    var line = +match[2];
    var column = +match[3];

    // Support the inline sourceContents inside the source map
    var contents = fileContentsCache[source];

    // Support files on disk
    if (!contents && fs && fs.existsSync(source)) {
      try {
        contents = fs.readFileSync(source, 'utf8');
      } catch (er) {
        contents = '';
      }
    }

    // Format the line from the original source code like node does
    if (contents) {
      var code = contents.split(/(?:\r\n|\r|\n)/)[line - 1];
      if (code) {
        return source + ':' + line + '\n' + code + '\n' + new Array(column).join(' ') + '^';
      }
    }
  }
  return null;
}

function printErrorAndExit(error) {
  var source = getErrorSource(error);

  if (source) {
    console.error();
    console.error(source);
  }

  console.error(error.stack);
  process.exit(1);
}

function shimEmitUncaughtException() {
  var origEmit = process.emit;

  process.emit = function (type) {
    if (type === 'uncaughtException') {
      var hasStack = arguments[1] && arguments[1].stack;
      var hasListeners = this.listeners(type).length > 0;

      if (hasStack && !hasListeners) {
        return printErrorAndExit(arguments[1]);
      }
    }

    return origEmit.apply(this, arguments);
  };
}

exports.wrapCallSite = wrapCallSite;
exports.getErrorSource = getErrorSource;
exports.mapSourcePosition = mapSourcePosition;
exports.retrieveSourceMap = retrieveSourceMap;

exports.install = function (options) {
  options = options || {};

  if (options.environment) {
    environment = options.environment;
    if (["node", "browser", "auto"].indexOf(environment) === -1) {
      throw new Error("environment " + environment + " was unknown. Available options are {auto, browser, node}");
    }
  }

  // Allow sources to be found by methods other than reading the files
  // directly from disk.
  if (options.retrieveFile) {
    if (options.overrideRetrieveFile) {
      retrieveFileHandlers.length = 0;
    }

    retrieveFileHandlers.unshift(options.retrieveFile);
  }

  // Allow source maps to be found by methods other than reading the files
  // directly from disk.
  if (options.retrieveSourceMap) {
    if (options.overrideRetrieveSourceMap) {
      retrieveMapHandlers.length = 0;
    }

    retrieveMapHandlers.unshift(options.retrieveSourceMap);
  }

  // Support runtime transpilers that include inline source maps
  if (options.hookRequire && !isInBrowser()) {
    var Module;
    try {
      Module = __webpack_require__(168);
    } catch (err) {
      // NOP: Loading in catch block to convert webpack error to warning.
    }
    var $compile = Module.prototype._compile;

    if (!$compile.__sourceMapSupport) {
      Module.prototype._compile = function (content, filename) {
        fileContentsCache[filename] = content;
        sourceMapCache[filename] = undefined;
        return $compile.call(this, content, filename);
      };

      Module.prototype._compile.__sourceMapSupport = true;
    }
  }

  // Configure options
  if (!emptyCacheBetweenOperations) {
    emptyCacheBetweenOperations = 'emptyCacheBetweenOperations' in options ? options.emptyCacheBetweenOperations : false;
  }

  // Install the error reformatter
  if (!errorFormatterInstalled) {
    errorFormatterInstalled = true;
    Error.prepareStackTrace = prepareStackTrace;
  }

  if (!uncaughtShimInstalled) {
    var installHandler = 'handleUncaughtExceptions' in options ? options.handleUncaughtExceptions : true;

    // Provide the option to not install the uncaught exception handler. This is
    // to support other uncaught exception handlers (in test frameworks, for
    // example). If this handler is not installed and there are no other uncaught
    // exception handlers, uncaught exceptions will be caught by node's built-in
    // exception handler and the process will still be terminated. However, the
    // generated JavaScript code will be shown above the stack trace instead of
    // the original source code.
    if (installHandler && hasGlobalProcessEventEmitter()) {
      uncaughtShimInstalled = true;
      shimEmitUncaughtException();
    }
  }
};

/***/ }),
/* 161 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/*
 * Copyright 2009-2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE.txt or:
 * http://opensource.org/licenses/BSD-3-Clause
 */
exports.SourceMapGenerator = __webpack_require__(56).SourceMapGenerator;
exports.SourceMapConsumer = __webpack_require__(164).SourceMapConsumer;
exports.SourceNode = __webpack_require__(167).SourceNode;

/***/ }),
/* 162 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/* -*- Mode: js; js-indent-level: 2; -*- */
/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */

var intToCharMap = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'.split('');

/**
 * Encode an integer in the range of 0 to 63 to a single base 64 digit.
 */
exports.encode = function (number) {
  if (0 <= number && number < intToCharMap.length) {
    return intToCharMap[number];
  }
  throw new TypeError("Must be between 0 and 63: " + number);
};

/**
 * Decode a single base 64 character code digit to an integer. Returns -1 on
 * failure.
 */
exports.decode = function (charCode) {
  var bigA = 65; // 'A'
  var bigZ = 90; // 'Z'

  var littleA = 97; // 'a'
  var littleZ = 122; // 'z'

  var zero = 48; // '0'
  var nine = 57; // '9'

  var plus = 43; // '+'
  var slash = 47; // '/'

  var littleOffset = 26;
  var numberOffset = 52;

  // 0 - 25: ABCDEFGHIJKLMNOPQRSTUVWXYZ
  if (bigA <= charCode && charCode <= bigZ) {
    return charCode - bigA;
  }

  // 26 - 51: abcdefghijklmnopqrstuvwxyz
  if (littleA <= charCode && charCode <= littleZ) {
    return charCode - littleA + littleOffset;
  }

  // 52 - 61: 0123456789
  if (zero <= charCode && charCode <= nine) {
    return charCode - zero + numberOffset;
  }

  // 62: +
  if (charCode == plus) {
    return 62;
  }

  // 63: /
  if (charCode == slash) {
    return 63;
  }

  // Invalid base64 digit.
  return -1;
};

/***/ }),
/* 163 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/* -*- Mode: js; js-indent-level: 2; -*- */
/*
 * Copyright 2014 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */

var util = __webpack_require__(23);

/**
 * Determine whether mappingB is after mappingA with respect to generated
 * position.
 */
function generatedPositionAfter(mappingA, mappingB) {
  // Optimized for most common case
  var lineA = mappingA.generatedLine;
  var lineB = mappingB.generatedLine;
  var columnA = mappingA.generatedColumn;
  var columnB = mappingB.generatedColumn;
  return lineB > lineA || lineB == lineA && columnB >= columnA || util.compareByGeneratedPositionsInflated(mappingA, mappingB) <= 0;
}

/**
 * A data structure to provide a sorted view of accumulated mappings in a
 * performance conscious manner. It trades a neglibable overhead in general
 * case for a large speedup in case of mappings being added in order.
 */
function MappingList() {
  this._array = [];
  this._sorted = true;
  // Serves as infimum
  this._last = { generatedLine: -1, generatedColumn: 0 };
}

/**
 * Iterate through internal items. This method takes the same arguments that
 * `Array.prototype.forEach` takes.
 *
 * NOTE: The order of the mappings is NOT guaranteed.
 */
MappingList.prototype.unsortedForEach = function MappingList_forEach(aCallback, aThisArg) {
  this._array.forEach(aCallback, aThisArg);
};

/**
 * Add the given source mapping.
 *
 * @param Object aMapping
 */
MappingList.prototype.add = function MappingList_add(aMapping) {
  if (generatedPositionAfter(this._last, aMapping)) {
    this._last = aMapping;
    this._array.push(aMapping);
  } else {
    this._sorted = false;
    this._array.push(aMapping);
  }
};

/**
 * Returns the flat, sorted array of mappings. The mappings are sorted by
 * generated position.
 *
 * WARNING: This method returns internal data without copying, for
 * performance. The return value must NOT be mutated, and should be treated as
 * an immutable borrow. If you want to take ownership, you must make your own
 * copy.
 */
MappingList.prototype.toArray = function MappingList_toArray() {
  if (!this._sorted) {
    this._array.sort(util.compareByGeneratedPositionsInflated);
    this._sorted = true;
  }
  return this._array;
};

exports.MappingList = MappingList;

/***/ }),
/* 164 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/* -*- Mode: js; js-indent-level: 2; -*- */
/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */

var util = __webpack_require__(23);
var binarySearch = __webpack_require__(165);
var ArraySet = __webpack_require__(58).ArraySet;
var base64VLQ = __webpack_require__(57);
var quickSort = __webpack_require__(166).quickSort;

function SourceMapConsumer(aSourceMap, aSourceMapURL) {
  var sourceMap = aSourceMap;
  if (typeof aSourceMap === 'string') {
    sourceMap = util.parseSourceMapInput(aSourceMap);
  }

  return sourceMap.sections != null ? new IndexedSourceMapConsumer(sourceMap, aSourceMapURL) : new BasicSourceMapConsumer(sourceMap, aSourceMapURL);
}

SourceMapConsumer.fromSourceMap = function (aSourceMap, aSourceMapURL) {
  return BasicSourceMapConsumer.fromSourceMap(aSourceMap, aSourceMapURL);
};

/**
 * The version of the source mapping spec that we are consuming.
 */
SourceMapConsumer.prototype._version = 3;

// `__generatedMappings` and `__originalMappings` are arrays that hold the
// parsed mapping coordinates from the source map's "mappings" attribute. They
// are lazily instantiated, accessed via the `_generatedMappings` and
// `_originalMappings` getters respectively, and we only parse the mappings
// and create these arrays once queried for a source location. We jump through
// these hoops because there can be many thousands of mappings, and parsing
// them is expensive, so we only want to do it if we must.
//
// Each object in the arrays is of the form:
//
//     {
//       generatedLine: The line number in the generated code,
//       generatedColumn: The column number in the generated code,
//       source: The path to the original source file that generated this
//               chunk of code,
//       originalLine: The line number in the original source that
//                     corresponds to this chunk of generated code,
//       originalColumn: The column number in the original source that
//                       corresponds to this chunk of generated code,
//       name: The name of the original symbol which generated this chunk of
//             code.
//     }
//
// All properties except for `generatedLine` and `generatedColumn` can be
// `null`.
//
// `_generatedMappings` is ordered by the generated positions.
//
// `_originalMappings` is ordered by the original positions.

SourceMapConsumer.prototype.__generatedMappings = null;
Object.defineProperty(SourceMapConsumer.prototype, '_generatedMappings', {
  configurable: true,
  enumerable: true,
  get: function () {
    if (!this.__generatedMappings) {
      this._parseMappings(this._mappings, this.sourceRoot);
    }

    return this.__generatedMappings;
  }
});

SourceMapConsumer.prototype.__originalMappings = null;
Object.defineProperty(SourceMapConsumer.prototype, '_originalMappings', {
  configurable: true,
  enumerable: true,
  get: function () {
    if (!this.__originalMappings) {
      this._parseMappings(this._mappings, this.sourceRoot);
    }

    return this.__originalMappings;
  }
});

SourceMapConsumer.prototype._charIsMappingSeparator = function SourceMapConsumer_charIsMappingSeparator(aStr, index) {
  var c = aStr.charAt(index);
  return c === ";" || c === ",";
};

/**
 * Parse the mappings in a string in to a data structure which we can easily
 * query (the ordered arrays in the `this.__generatedMappings` and
 * `this.__originalMappings` properties).
 */
SourceMapConsumer.prototype._parseMappings = function SourceMapConsumer_parseMappings(aStr, aSourceRoot) {
  throw new Error("Subclasses must implement _parseMappings");
};

SourceMapConsumer.GENERATED_ORDER = 1;
SourceMapConsumer.ORIGINAL_ORDER = 2;

SourceMapConsumer.GREATEST_LOWER_BOUND = 1;
SourceMapConsumer.LEAST_UPPER_BOUND = 2;

/**
 * Iterate over each mapping between an original source/line/column and a
 * generated line/column in this source map.
 *
 * @param Function aCallback
 *        The function that is called with each mapping.
 * @param Object aContext
 *        Optional. If specified, this object will be the value of `this` every
 *        time that `aCallback` is called.
 * @param aOrder
 *        Either `SourceMapConsumer.GENERATED_ORDER` or
 *        `SourceMapConsumer.ORIGINAL_ORDER`. Specifies whether you want to
 *        iterate over the mappings sorted by the generated file's line/column
 *        order or the original's source/line/column order, respectively. Defaults to
 *        `SourceMapConsumer.GENERATED_ORDER`.
 */
SourceMapConsumer.prototype.eachMapping = function SourceMapConsumer_eachMapping(aCallback, aContext, aOrder) {
  var context = aContext || null;
  var order = aOrder || SourceMapConsumer.GENERATED_ORDER;

  var mappings;
  switch (order) {
    case SourceMapConsumer.GENERATED_ORDER:
      mappings = this._generatedMappings;
      break;
    case SourceMapConsumer.ORIGINAL_ORDER:
      mappings = this._originalMappings;
      break;
    default:
      throw new Error("Unknown order of iteration.");
  }

  var sourceRoot = this.sourceRoot;
  mappings.map(function (mapping) {
    var source = mapping.source === null ? null : this._sources.at(mapping.source);
    source = util.computeSourceURL(sourceRoot, source, this._sourceMapURL);
    return {
      source: source,
      generatedLine: mapping.generatedLine,
      generatedColumn: mapping.generatedColumn,
      originalLine: mapping.originalLine,
      originalColumn: mapping.originalColumn,
      name: mapping.name === null ? null : this._names.at(mapping.name)
    };
  }, this).forEach(aCallback, context);
};

/**
 * Returns all generated line and column information for the original source,
 * line, and column provided. If no column is provided, returns all mappings
 * corresponding to a either the line we are searching for or the next
 * closest line that has any mappings. Otherwise, returns all mappings
 * corresponding to the given line and either the column we are searching for
 * or the next closest column that has any offsets.
 *
 * The only argument is an object with the following properties:
 *
 *   - source: The filename of the original source.
 *   - line: The line number in the original source.  The line number is 1-based.
 *   - column: Optional. the column number in the original source.
 *    The column number is 0-based.
 *
 * and an array of objects is returned, each with the following properties:
 *
 *   - line: The line number in the generated source, or null.  The
 *    line number is 1-based.
 *   - column: The column number in the generated source, or null.
 *    The column number is 0-based.
 */
SourceMapConsumer.prototype.allGeneratedPositionsFor = function SourceMapConsumer_allGeneratedPositionsFor(aArgs) {
  var line = util.getArg(aArgs, 'line');

  // When there is no exact match, BasicSourceMapConsumer.prototype._findMapping
  // returns the index of the closest mapping less than the needle. By
  // setting needle.originalColumn to 0, we thus find the last mapping for
  // the given line, provided such a mapping exists.
  var needle = {
    source: util.getArg(aArgs, 'source'),
    originalLine: line,
    originalColumn: util.getArg(aArgs, 'column', 0)
  };

  needle.source = this._findSourceIndex(needle.source);
  if (needle.source < 0) {
    return [];
  }

  var mappings = [];

  var index = this._findMapping(needle, this._originalMappings, "originalLine", "originalColumn", util.compareByOriginalPositions, binarySearch.LEAST_UPPER_BOUND);
  if (index >= 0) {
    var mapping = this._originalMappings[index];

    if (aArgs.column === undefined) {
      var originalLine = mapping.originalLine;

      // Iterate until either we run out of mappings, or we run into
      // a mapping for a different line than the one we found. Since
      // mappings are sorted, this is guaranteed to find all mappings for
      // the line we found.
      while (mapping && mapping.originalLine === originalLine) {
        mappings.push({
          line: util.getArg(mapping, 'generatedLine', null),
          column: util.getArg(mapping, 'generatedColumn', null),
          lastColumn: util.getArg(mapping, 'lastGeneratedColumn', null)
        });

        mapping = this._originalMappings[++index];
      }
    } else {
      var originalColumn = mapping.originalColumn;

      // Iterate until either we run out of mappings, or we run into
      // a mapping for a different line than the one we were searching for.
      // Since mappings are sorted, this is guaranteed to find all mappings for
      // the line we are searching for.
      while (mapping && mapping.originalLine === line && mapping.originalColumn == originalColumn) {
        mappings.push({
          line: util.getArg(mapping, 'generatedLine', null),
          column: util.getArg(mapping, 'generatedColumn', null),
          lastColumn: util.getArg(mapping, 'lastGeneratedColumn', null)
        });

        mapping = this._originalMappings[++index];
      }
    }
  }

  return mappings;
};

exports.SourceMapConsumer = SourceMapConsumer;

/**
 * A BasicSourceMapConsumer instance represents a parsed source map which we can
 * query for information about the original file positions by giving it a file
 * position in the generated source.
 *
 * The first parameter is the raw source map (either as a JSON string, or
 * already parsed to an object). According to the spec, source maps have the
 * following attributes:
 *
 *   - version: Which version of the source map spec this map is following.
 *   - sources: An array of URLs to the original source files.
 *   - names: An array of identifiers which can be referrenced by individual mappings.
 *   - sourceRoot: Optional. The URL root from which all sources are relative.
 *   - sourcesContent: Optional. An array of contents of the original source files.
 *   - mappings: A string of base64 VLQs which contain the actual mappings.
 *   - file: Optional. The generated file this source map is associated with.
 *
 * Here is an example source map, taken from the source map spec[0]:
 *
 *     {
 *       version : 3,
 *       file: "out.js",
 *       sourceRoot : "",
 *       sources: ["foo.js", "bar.js"],
 *       names: ["src", "maps", "are", "fun"],
 *       mappings: "AA,AB;;ABCDE;"
 *     }
 *
 * The second parameter, if given, is a string whose value is the URL
 * at which the source map was found.  This URL is used to compute the
 * sources array.
 *
 * [0]: https://docs.google.com/document/d/1U1RGAehQwRypUTovF1KRlpiOFze0b-_2gc6fAH0KY0k/edit?pli=1#
 */
function BasicSourceMapConsumer(aSourceMap, aSourceMapURL) {
  var sourceMap = aSourceMap;
  if (typeof aSourceMap === 'string') {
    sourceMap = util.parseSourceMapInput(aSourceMap);
  }

  var version = util.getArg(sourceMap, 'version');
  var sources = util.getArg(sourceMap, 'sources');
  // Sass 3.3 leaves out the 'names' array, so we deviate from the spec (which
  // requires the array) to play nice here.
  var names = util.getArg(sourceMap, 'names', []);
  var sourceRoot = util.getArg(sourceMap, 'sourceRoot', null);
  var sourcesContent = util.getArg(sourceMap, 'sourcesContent', null);
  var mappings = util.getArg(sourceMap, 'mappings');
  var file = util.getArg(sourceMap, 'file', null);

  // Once again, Sass deviates from the spec and supplies the version as a
  // string rather than a number, so we use loose equality checking here.
  if (version != this._version) {
    throw new Error('Unsupported version: ' + version);
  }

  if (sourceRoot) {
    sourceRoot = util.normalize(sourceRoot);
  }

  sources = sources.map(String)
  // Some source maps produce relative source paths like "./foo.js" instead of
  // "foo.js".  Normalize these first so that future comparisons will succeed.
  // See bugzil.la/1090768.
  .map(util.normalize)
  // Always ensure that absolute sources are internally stored relative to
  // the source root, if the source root is absolute. Not doing this would
  // be particularly problematic when the source root is a prefix of the
  // source (valid, but why??). See github issue #199 and bugzil.la/1188982.
  .map(function (source) {
    return sourceRoot && util.isAbsolute(sourceRoot) && util.isAbsolute(source) ? util.relative(sourceRoot, source) : source;
  });

  // Pass `true` below to allow duplicate names and sources. While source maps
  // are intended to be compressed and deduplicated, the TypeScript compiler
  // sometimes generates source maps with duplicates in them. See Github issue
  // #72 and bugzil.la/889492.
  this._names = ArraySet.fromArray(names.map(String), true);
  this._sources = ArraySet.fromArray(sources, true);

  this._absoluteSources = this._sources.toArray().map(function (s) {
    return util.computeSourceURL(sourceRoot, s, aSourceMapURL);
  });

  this.sourceRoot = sourceRoot;
  this.sourcesContent = sourcesContent;
  this._mappings = mappings;
  this._sourceMapURL = aSourceMapURL;
  this.file = file;
}

BasicSourceMapConsumer.prototype = Object.create(SourceMapConsumer.prototype);
BasicSourceMapConsumer.prototype.consumer = SourceMapConsumer;

/**
 * Utility function to find the index of a source.  Returns -1 if not
 * found.
 */
BasicSourceMapConsumer.prototype._findSourceIndex = function (aSource) {
  var relativeSource = aSource;
  if (this.sourceRoot != null) {
    relativeSource = util.relative(this.sourceRoot, relativeSource);
  }

  if (this._sources.has(relativeSource)) {
    return this._sources.indexOf(relativeSource);
  }

  // Maybe aSource is an absolute URL as returned by |sources|.  In
  // this case we can't simply undo the transform.
  var i;
  for (i = 0; i < this._absoluteSources.length; ++i) {
    if (this._absoluteSources[i] == aSource) {
      return i;
    }
  }

  return -1;
};

/**
 * Create a BasicSourceMapConsumer from a SourceMapGenerator.
 *
 * @param SourceMapGenerator aSourceMap
 *        The source map that will be consumed.
 * @param String aSourceMapURL
 *        The URL at which the source map can be found (optional)
 * @returns BasicSourceMapConsumer
 */
BasicSourceMapConsumer.fromSourceMap = function SourceMapConsumer_fromSourceMap(aSourceMap, aSourceMapURL) {
  var smc = Object.create(BasicSourceMapConsumer.prototype);

  var names = smc._names = ArraySet.fromArray(aSourceMap._names.toArray(), true);
  var sources = smc._sources = ArraySet.fromArray(aSourceMap._sources.toArray(), true);
  smc.sourceRoot = aSourceMap._sourceRoot;
  smc.sourcesContent = aSourceMap._generateSourcesContent(smc._sources.toArray(), smc.sourceRoot);
  smc.file = aSourceMap._file;
  smc._sourceMapURL = aSourceMapURL;
  smc._absoluteSources = smc._sources.toArray().map(function (s) {
    return util.computeSourceURL(smc.sourceRoot, s, aSourceMapURL);
  });

  // Because we are modifying the entries (by converting string sources and
  // names to indices into the sources and names ArraySets), we have to make
  // a copy of the entry or else bad things happen. Shared mutable state
  // strikes again! See github issue #191.

  var generatedMappings = aSourceMap._mappings.toArray().slice();
  var destGeneratedMappings = smc.__generatedMappings = [];
  var destOriginalMappings = smc.__originalMappings = [];

  for (var i = 0, length = generatedMappings.length; i < length; i++) {
    var srcMapping = generatedMappings[i];
    var destMapping = new Mapping();
    destMapping.generatedLine = srcMapping.generatedLine;
    destMapping.generatedColumn = srcMapping.generatedColumn;

    if (srcMapping.source) {
      destMapping.source = sources.indexOf(srcMapping.source);
      destMapping.originalLine = srcMapping.originalLine;
      destMapping.originalColumn = srcMapping.originalColumn;

      if (srcMapping.name) {
        destMapping.name = names.indexOf(srcMapping.name);
      }

      destOriginalMappings.push(destMapping);
    }

    destGeneratedMappings.push(destMapping);
  }

  quickSort(smc.__originalMappings, util.compareByOriginalPositions);

  return smc;
};

/**
 * The version of the source mapping spec that we are consuming.
 */
BasicSourceMapConsumer.prototype._version = 3;

/**
 * The list of original sources.
 */
Object.defineProperty(BasicSourceMapConsumer.prototype, 'sources', {
  get: function () {
    return this._absoluteSources.slice();
  }
});

/**
 * Provide the JIT with a nice shape / hidden class.
 */
function Mapping() {
  this.generatedLine = 0;
  this.generatedColumn = 0;
  this.source = null;
  this.originalLine = null;
  this.originalColumn = null;
  this.name = null;
}

/**
 * Parse the mappings in a string in to a data structure which we can easily
 * query (the ordered arrays in the `this.__generatedMappings` and
 * `this.__originalMappings` properties).
 */
BasicSourceMapConsumer.prototype._parseMappings = function SourceMapConsumer_parseMappings(aStr, aSourceRoot) {
  var generatedLine = 1;
  var previousGeneratedColumn = 0;
  var previousOriginalLine = 0;
  var previousOriginalColumn = 0;
  var previousSource = 0;
  var previousName = 0;
  var length = aStr.length;
  var index = 0;
  var cachedSegments = {};
  var temp = {};
  var originalMappings = [];
  var generatedMappings = [];
  var mapping, str, segment, end, value;

  while (index < length) {
    if (aStr.charAt(index) === ';') {
      generatedLine++;
      index++;
      previousGeneratedColumn = 0;
    } else if (aStr.charAt(index) === ',') {
      index++;
    } else {
      mapping = new Mapping();
      mapping.generatedLine = generatedLine;

      // Because each offset is encoded relative to the previous one,
      // many segments often have the same encoding. We can exploit this
      // fact by caching the parsed variable length fields of each segment,
      // allowing us to avoid a second parse if we encounter the same
      // segment again.
      for (end = index; end < length; end++) {
        if (this._charIsMappingSeparator(aStr, end)) {
          break;
        }
      }
      str = aStr.slice(index, end);

      segment = cachedSegments[str];
      if (segment) {
        index += str.length;
      } else {
        segment = [];
        while (index < end) {
          base64VLQ.decode(aStr, index, temp);
          value = temp.value;
          index = temp.rest;
          segment.push(value);
        }

        if (segment.length === 2) {
          throw new Error('Found a source, but no line and column');
        }

        if (segment.length === 3) {
          throw new Error('Found a source and line, but no column');
        }

        cachedSegments[str] = segment;
      }

      // Generated column.
      mapping.generatedColumn = previousGeneratedColumn + segment[0];
      previousGeneratedColumn = mapping.generatedColumn;

      if (segment.length > 1) {
        // Original source.
        mapping.source = previousSource + segment[1];
        previousSource += segment[1];

        // Original line.
        mapping.originalLine = previousOriginalLine + segment[2];
        previousOriginalLine = mapping.originalLine;
        // Lines are stored 0-based
        mapping.originalLine += 1;

        // Original column.
        mapping.originalColumn = previousOriginalColumn + segment[3];
        previousOriginalColumn = mapping.originalColumn;

        if (segment.length > 4) {
          // Original name.
          mapping.name = previousName + segment[4];
          previousName += segment[4];
        }
      }

      generatedMappings.push(mapping);
      if (typeof mapping.originalLine === 'number') {
        originalMappings.push(mapping);
      }
    }
  }

  quickSort(generatedMappings, util.compareByGeneratedPositionsDeflated);
  this.__generatedMappings = generatedMappings;

  quickSort(originalMappings, util.compareByOriginalPositions);
  this.__originalMappings = originalMappings;
};

/**
 * Find the mapping that best matches the hypothetical "needle" mapping that
 * we are searching for in the given "haystack" of mappings.
 */
BasicSourceMapConsumer.prototype._findMapping = function SourceMapConsumer_findMapping(aNeedle, aMappings, aLineName, aColumnName, aComparator, aBias) {
  // To return the position we are searching for, we must first find the
  // mapping for the given position and then return the opposite position it
  // points to. Because the mappings are sorted, we can use binary search to
  // find the best mapping.

  if (aNeedle[aLineName] <= 0) {
    throw new TypeError('Line must be greater than or equal to 1, got ' + aNeedle[aLineName]);
  }
  if (aNeedle[aColumnName] < 0) {
    throw new TypeError('Column must be greater than or equal to 0, got ' + aNeedle[aColumnName]);
  }

  return binarySearch.search(aNeedle, aMappings, aComparator, aBias);
};

/**
 * Compute the last column for each generated mapping. The last column is
 * inclusive.
 */
BasicSourceMapConsumer.prototype.computeColumnSpans = function SourceMapConsumer_computeColumnSpans() {
  for (var index = 0; index < this._generatedMappings.length; ++index) {
    var mapping = this._generatedMappings[index];

    // Mappings do not contain a field for the last generated columnt. We
    // can come up with an optimistic estimate, however, by assuming that
    // mappings are contiguous (i.e. given two consecutive mappings, the
    // first mapping ends where the second one starts).
    if (index + 1 < this._generatedMappings.length) {
      var nextMapping = this._generatedMappings[index + 1];

      if (mapping.generatedLine === nextMapping.generatedLine) {
        mapping.lastGeneratedColumn = nextMapping.generatedColumn - 1;
        continue;
      }
    }

    // The last mapping for each line spans the entire line.
    mapping.lastGeneratedColumn = Infinity;
  }
};

/**
 * Returns the original source, line, and column information for the generated
 * source's line and column positions provided. The only argument is an object
 * with the following properties:
 *
 *   - line: The line number in the generated source.  The line number
 *     is 1-based.
 *   - column: The column number in the generated source.  The column
 *     number is 0-based.
 *   - bias: Either 'SourceMapConsumer.GREATEST_LOWER_BOUND' or
 *     'SourceMapConsumer.LEAST_UPPER_BOUND'. Specifies whether to return the
 *     closest element that is smaller than or greater than the one we are
 *     searching for, respectively, if the exact element cannot be found.
 *     Defaults to 'SourceMapConsumer.GREATEST_LOWER_BOUND'.
 *
 * and an object is returned with the following properties:
 *
 *   - source: The original source file, or null.
 *   - line: The line number in the original source, or null.  The
 *     line number is 1-based.
 *   - column: The column number in the original source, or null.  The
 *     column number is 0-based.
 *   - name: The original identifier, or null.
 */
BasicSourceMapConsumer.prototype.originalPositionFor = function SourceMapConsumer_originalPositionFor(aArgs) {
  var needle = {
    generatedLine: util.getArg(aArgs, 'line'),
    generatedColumn: util.getArg(aArgs, 'column')
  };

  var index = this._findMapping(needle, this._generatedMappings, "generatedLine", "generatedColumn", util.compareByGeneratedPositionsDeflated, util.getArg(aArgs, 'bias', SourceMapConsumer.GREATEST_LOWER_BOUND));

  if (index >= 0) {
    var mapping = this._generatedMappings[index];

    if (mapping.generatedLine === needle.generatedLine) {
      var source = util.getArg(mapping, 'source', null);
      if (source !== null) {
        source = this._sources.at(source);
        source = util.computeSourceURL(this.sourceRoot, source, this._sourceMapURL);
      }
      var name = util.getArg(mapping, 'name', null);
      if (name !== null) {
        name = this._names.at(name);
      }
      return {
        source: source,
        line: util.getArg(mapping, 'originalLine', null),
        column: util.getArg(mapping, 'originalColumn', null),
        name: name
      };
    }
  }

  return {
    source: null,
    line: null,
    column: null,
    name: null
  };
};

/**
 * Return true if we have the source content for every source in the source
 * map, false otherwise.
 */
BasicSourceMapConsumer.prototype.hasContentsOfAllSources = function BasicSourceMapConsumer_hasContentsOfAllSources() {
  if (!this.sourcesContent) {
    return false;
  }
  return this.sourcesContent.length >= this._sources.size() && !this.sourcesContent.some(function (sc) {
    return sc == null;
  });
};

/**
 * Returns the original source content. The only argument is the url of the
 * original source file. Returns null if no original source content is
 * available.
 */
BasicSourceMapConsumer.prototype.sourceContentFor = function SourceMapConsumer_sourceContentFor(aSource, nullOnMissing) {
  if (!this.sourcesContent) {
    return null;
  }

  var index = this._findSourceIndex(aSource);
  if (index >= 0) {
    return this.sourcesContent[index];
  }

  var relativeSource = aSource;
  if (this.sourceRoot != null) {
    relativeSource = util.relative(this.sourceRoot, relativeSource);
  }

  var url;
  if (this.sourceRoot != null && (url = util.urlParse(this.sourceRoot))) {
    // XXX: file:// URIs and absolute paths lead to unexpected behavior for
    // many users. We can help them out when they expect file:// URIs to
    // behave like it would if they were running a local HTTP server. See
    // https://bugzilla.mozilla.org/show_bug.cgi?id=885597.
    var fileUriAbsPath = relativeSource.replace(/^file:\/\//, "");
    if (url.scheme == "file" && this._sources.has(fileUriAbsPath)) {
      return this.sourcesContent[this._sources.indexOf(fileUriAbsPath)];
    }

    if ((!url.path || url.path == "/") && this._sources.has("/" + relativeSource)) {
      return this.sourcesContent[this._sources.indexOf("/" + relativeSource)];
    }
  }

  // This function is used recursively from
  // IndexedSourceMapConsumer.prototype.sourceContentFor. In that case, we
  // don't want to throw if we can't find the source - we just want to
  // return null, so we provide a flag to exit gracefully.
  if (nullOnMissing) {
    return null;
  } else {
    throw new Error('"' + relativeSource + '" is not in the SourceMap.');
  }
};

/**
 * Returns the generated line and column information for the original source,
 * line, and column positions provided. The only argument is an object with
 * the following properties:
 *
 *   - source: The filename of the original source.
 *   - line: The line number in the original source.  The line number
 *     is 1-based.
 *   - column: The column number in the original source.  The column
 *     number is 0-based.
 *   - bias: Either 'SourceMapConsumer.GREATEST_LOWER_BOUND' or
 *     'SourceMapConsumer.LEAST_UPPER_BOUND'. Specifies whether to return the
 *     closest element that is smaller than or greater than the one we are
 *     searching for, respectively, if the exact element cannot be found.
 *     Defaults to 'SourceMapConsumer.GREATEST_LOWER_BOUND'.
 *
 * and an object is returned with the following properties:
 *
 *   - line: The line number in the generated source, or null.  The
 *     line number is 1-based.
 *   - column: The column number in the generated source, or null.
 *     The column number is 0-based.
 */
BasicSourceMapConsumer.prototype.generatedPositionFor = function SourceMapConsumer_generatedPositionFor(aArgs) {
  var source = util.getArg(aArgs, 'source');
  source = this._findSourceIndex(source);
  if (source < 0) {
    return {
      line: null,
      column: null,
      lastColumn: null
    };
  }

  var needle = {
    source: source,
    originalLine: util.getArg(aArgs, 'line'),
    originalColumn: util.getArg(aArgs, 'column')
  };

  var index = this._findMapping(needle, this._originalMappings, "originalLine", "originalColumn", util.compareByOriginalPositions, util.getArg(aArgs, 'bias', SourceMapConsumer.GREATEST_LOWER_BOUND));

  if (index >= 0) {
    var mapping = this._originalMappings[index];

    if (mapping.source === needle.source) {
      return {
        line: util.getArg(mapping, 'generatedLine', null),
        column: util.getArg(mapping, 'generatedColumn', null),
        lastColumn: util.getArg(mapping, 'lastGeneratedColumn', null)
      };
    }
  }

  return {
    line: null,
    column: null,
    lastColumn: null
  };
};

exports.BasicSourceMapConsumer = BasicSourceMapConsumer;

/**
 * An IndexedSourceMapConsumer instance represents a parsed source map which
 * we can query for information. It differs from BasicSourceMapConsumer in
 * that it takes "indexed" source maps (i.e. ones with a "sections" field) as
 * input.
 *
 * The first parameter is a raw source map (either as a JSON string, or already
 * parsed to an object). According to the spec for indexed source maps, they
 * have the following attributes:
 *
 *   - version: Which version of the source map spec this map is following.
 *   - file: Optional. The generated file this source map is associated with.
 *   - sections: A list of section definitions.
 *
 * Each value under the "sections" field has two fields:
 *   - offset: The offset into the original specified at which this section
 *       begins to apply, defined as an object with a "line" and "column"
 *       field.
 *   - map: A source map definition. This source map could also be indexed,
 *       but doesn't have to be.
 *
 * Instead of the "map" field, it's also possible to have a "url" field
 * specifying a URL to retrieve a source map from, but that's currently
 * unsupported.
 *
 * Here's an example source map, taken from the source map spec[0], but
 * modified to omit a section which uses the "url" field.
 *
 *  {
 *    version : 3,
 *    file: "app.js",
 *    sections: [{
 *      offset: {line:100, column:10},
 *      map: {
 *        version : 3,
 *        file: "section.js",
 *        sources: ["foo.js", "bar.js"],
 *        names: ["src", "maps", "are", "fun"],
 *        mappings: "AAAA,E;;ABCDE;"
 *      }
 *    }],
 *  }
 *
 * The second parameter, if given, is a string whose value is the URL
 * at which the source map was found.  This URL is used to compute the
 * sources array.
 *
 * [0]: https://docs.google.com/document/d/1U1RGAehQwRypUTovF1KRlpiOFze0b-_2gc6fAH0KY0k/edit#heading=h.535es3xeprgt
 */
function IndexedSourceMapConsumer(aSourceMap, aSourceMapURL) {
  var sourceMap = aSourceMap;
  if (typeof aSourceMap === 'string') {
    sourceMap = util.parseSourceMapInput(aSourceMap);
  }

  var version = util.getArg(sourceMap, 'version');
  var sections = util.getArg(sourceMap, 'sections');

  if (version != this._version) {
    throw new Error('Unsupported version: ' + version);
  }

  this._sources = new ArraySet();
  this._names = new ArraySet();

  var lastOffset = {
    line: -1,
    column: 0
  };
  this._sections = sections.map(function (s) {
    if (s.url) {
      // The url field will require support for asynchronicity.
      // See https://github.com/mozilla/source-map/issues/16
      throw new Error('Support for url field in sections not implemented.');
    }
    var offset = util.getArg(s, 'offset');
    var offsetLine = util.getArg(offset, 'line');
    var offsetColumn = util.getArg(offset, 'column');

    if (offsetLine < lastOffset.line || offsetLine === lastOffset.line && offsetColumn < lastOffset.column) {
      throw new Error('Section offsets must be ordered and non-overlapping.');
    }
    lastOffset = offset;

    return {
      generatedOffset: {
        // The offset fields are 0-based, but we use 1-based indices when
        // encoding/decoding from VLQ.
        generatedLine: offsetLine + 1,
        generatedColumn: offsetColumn + 1
      },
      consumer: new SourceMapConsumer(util.getArg(s, 'map'), aSourceMapURL)
    };
  });
}

IndexedSourceMapConsumer.prototype = Object.create(SourceMapConsumer.prototype);
IndexedSourceMapConsumer.prototype.constructor = SourceMapConsumer;

/**
 * The version of the source mapping spec that we are consuming.
 */
IndexedSourceMapConsumer.prototype._version = 3;

/**
 * The list of original sources.
 */
Object.defineProperty(IndexedSourceMapConsumer.prototype, 'sources', {
  get: function () {
    var sources = [];
    for (var i = 0; i < this._sections.length; i++) {
      for (var j = 0; j < this._sections[i].consumer.sources.length; j++) {
        sources.push(this._sections[i].consumer.sources[j]);
      }
    }
    return sources;
  }
});

/**
 * Returns the original source, line, and column information for the generated
 * source's line and column positions provided. The only argument is an object
 * with the following properties:
 *
 *   - line: The line number in the generated source.  The line number
 *     is 1-based.
 *   - column: The column number in the generated source.  The column
 *     number is 0-based.
 *
 * and an object is returned with the following properties:
 *
 *   - source: The original source file, or null.
 *   - line: The line number in the original source, or null.  The
 *     line number is 1-based.
 *   - column: The column number in the original source, or null.  The
 *     column number is 0-based.
 *   - name: The original identifier, or null.
 */
IndexedSourceMapConsumer.prototype.originalPositionFor = function IndexedSourceMapConsumer_originalPositionFor(aArgs) {
  var needle = {
    generatedLine: util.getArg(aArgs, 'line'),
    generatedColumn: util.getArg(aArgs, 'column')
  };

  // Find the section containing the generated position we're trying to map
  // to an original position.
  var sectionIndex = binarySearch.search(needle, this._sections, function (needle, section) {
    var cmp = needle.generatedLine - section.generatedOffset.generatedLine;
    if (cmp) {
      return cmp;
    }

    return needle.generatedColumn - section.generatedOffset.generatedColumn;
  });
  var section = this._sections[sectionIndex];

  if (!section) {
    return {
      source: null,
      line: null,
      column: null,
      name: null
    };
  }

  return section.consumer.originalPositionFor({
    line: needle.generatedLine - (section.generatedOffset.generatedLine - 1),
    column: needle.generatedColumn - (section.generatedOffset.generatedLine === needle.generatedLine ? section.generatedOffset.generatedColumn - 1 : 0),
    bias: aArgs.bias
  });
};

/**
 * Return true if we have the source content for every source in the source
 * map, false otherwise.
 */
IndexedSourceMapConsumer.prototype.hasContentsOfAllSources = function IndexedSourceMapConsumer_hasContentsOfAllSources() {
  return this._sections.every(function (s) {
    return s.consumer.hasContentsOfAllSources();
  });
};

/**
 * Returns the original source content. The only argument is the url of the
 * original source file. Returns null if no original source content is
 * available.
 */
IndexedSourceMapConsumer.prototype.sourceContentFor = function IndexedSourceMapConsumer_sourceContentFor(aSource, nullOnMissing) {
  for (var i = 0; i < this._sections.length; i++) {
    var section = this._sections[i];

    var content = section.consumer.sourceContentFor(aSource, true);
    if (content) {
      return content;
    }
  }
  if (nullOnMissing) {
    return null;
  } else {
    throw new Error('"' + aSource + '" is not in the SourceMap.');
  }
};

/**
 * Returns the generated line and column information for the original source,
 * line, and column positions provided. The only argument is an object with
 * the following properties:
 *
 *   - source: The filename of the original source.
 *   - line: The line number in the original source.  The line number
 *     is 1-based.
 *   - column: The column number in the original source.  The column
 *     number is 0-based.
 *
 * and an object is returned with the following properties:
 *
 *   - line: The line number in the generated source, or null.  The
 *     line number is 1-based. 
 *   - column: The column number in the generated source, or null.
 *     The column number is 0-based.
 */
IndexedSourceMapConsumer.prototype.generatedPositionFor = function IndexedSourceMapConsumer_generatedPositionFor(aArgs) {
  for (var i = 0; i < this._sections.length; i++) {
    var section = this._sections[i];

    // Only consider this section if the requested source is in the list of
    // sources of the consumer.
    if (section.consumer._findSourceIndex(util.getArg(aArgs, 'source')) === -1) {
      continue;
    }
    var generatedPosition = section.consumer.generatedPositionFor(aArgs);
    if (generatedPosition) {
      var ret = {
        line: generatedPosition.line + (section.generatedOffset.generatedLine - 1),
        column: generatedPosition.column + (section.generatedOffset.generatedLine === generatedPosition.line ? section.generatedOffset.generatedColumn - 1 : 0)
      };
      return ret;
    }
  }

  return {
    line: null,
    column: null
  };
};

/**
 * Parse the mappings in a string in to a data structure which we can easily
 * query (the ordered arrays in the `this.__generatedMappings` and
 * `this.__originalMappings` properties).
 */
IndexedSourceMapConsumer.prototype._parseMappings = function IndexedSourceMapConsumer_parseMappings(aStr, aSourceRoot) {
  this.__generatedMappings = [];
  this.__originalMappings = [];
  for (var i = 0; i < this._sections.length; i++) {
    var section = this._sections[i];
    var sectionMappings = section.consumer._generatedMappings;
    for (var j = 0; j < sectionMappings.length; j++) {
      var mapping = sectionMappings[j];

      var source = section.consumer._sources.at(mapping.source);
      source = util.computeSourceURL(section.consumer.sourceRoot, source, this._sourceMapURL);
      this._sources.add(source);
      source = this._sources.indexOf(source);

      var name = null;
      if (mapping.name) {
        name = section.consumer._names.at(mapping.name);
        this._names.add(name);
        name = this._names.indexOf(name);
      }

      // The mappings coming from the consumer for the section have
      // generated positions relative to the start of the section, so we
      // need to offset them to be relative to the start of the concatenated
      // generated file.
      var adjustedMapping = {
        source: source,
        generatedLine: mapping.generatedLine + (section.generatedOffset.generatedLine - 1),
        generatedColumn: mapping.generatedColumn + (section.generatedOffset.generatedLine === mapping.generatedLine ? section.generatedOffset.generatedColumn - 1 : 0),
        originalLine: mapping.originalLine,
        originalColumn: mapping.originalColumn,
        name: name
      };

      this.__generatedMappings.push(adjustedMapping);
      if (typeof adjustedMapping.originalLine === 'number') {
        this.__originalMappings.push(adjustedMapping);
      }
    }
  }

  quickSort(this.__generatedMappings, util.compareByGeneratedPositionsDeflated);
  quickSort(this.__originalMappings, util.compareByOriginalPositions);
};

exports.IndexedSourceMapConsumer = IndexedSourceMapConsumer;

/***/ }),
/* 165 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/* -*- Mode: js; js-indent-level: 2; -*- */
/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */

exports.GREATEST_LOWER_BOUND = 1;
exports.LEAST_UPPER_BOUND = 2;

/**
 * Recursive implementation of binary search.
 *
 * @param aLow Indices here and lower do not contain the needle.
 * @param aHigh Indices here and higher do not contain the needle.
 * @param aNeedle The element being searched for.
 * @param aHaystack The non-empty array being searched.
 * @param aCompare Function which takes two elements and returns -1, 0, or 1.
 * @param aBias Either 'binarySearch.GREATEST_LOWER_BOUND' or
 *     'binarySearch.LEAST_UPPER_BOUND'. Specifies whether to return the
 *     closest element that is smaller than or greater than the one we are
 *     searching for, respectively, if the exact element cannot be found.
 */
function recursiveSearch(aLow, aHigh, aNeedle, aHaystack, aCompare, aBias) {
  // This function terminates when one of the following is true:
  //
  //   1. We find the exact element we are looking for.
  //
  //   2. We did not find the exact element, but we can return the index of
  //      the next-closest element.
  //
  //   3. We did not find the exact element, and there is no next-closest
  //      element than the one we are searching for, so we return -1.
  var mid = Math.floor((aHigh - aLow) / 2) + aLow;
  var cmp = aCompare(aNeedle, aHaystack[mid], true);
  if (cmp === 0) {
    // Found the element we are looking for.
    return mid;
  } else if (cmp > 0) {
    // Our needle is greater than aHaystack[mid].
    if (aHigh - mid > 1) {
      // The element is in the upper half.
      return recursiveSearch(mid, aHigh, aNeedle, aHaystack, aCompare, aBias);
    }

    // The exact needle element was not found in this haystack. Determine if
    // we are in termination case (3) or (2) and return the appropriate thing.
    if (aBias == exports.LEAST_UPPER_BOUND) {
      return aHigh < aHaystack.length ? aHigh : -1;
    } else {
      return mid;
    }
  } else {
    // Our needle is less than aHaystack[mid].
    if (mid - aLow > 1) {
      // The element is in the lower half.
      return recursiveSearch(aLow, mid, aNeedle, aHaystack, aCompare, aBias);
    }

    // we are in termination case (3) or (2) and return the appropriate thing.
    if (aBias == exports.LEAST_UPPER_BOUND) {
      return mid;
    } else {
      return aLow < 0 ? -1 : aLow;
    }
  }
}

/**
 * This is an implementation of binary search which will always try and return
 * the index of the closest element if there is no exact hit. This is because
 * mappings between original and generated line/col pairs are single points,
 * and there is an implicit region between each of them, so a miss just means
 * that you aren't on the very start of a region.
 *
 * @param aNeedle The element you are looking for.
 * @param aHaystack The array that is being searched.
 * @param aCompare A function which takes the needle and an element in the
 *     array and returns -1, 0, or 1 depending on whether the needle is less
 *     than, equal to, or greater than the element, respectively.
 * @param aBias Either 'binarySearch.GREATEST_LOWER_BOUND' or
 *     'binarySearch.LEAST_UPPER_BOUND'. Specifies whether to return the
 *     closest element that is smaller than or greater than the one we are
 *     searching for, respectively, if the exact element cannot be found.
 *     Defaults to 'binarySearch.GREATEST_LOWER_BOUND'.
 */
exports.search = function search(aNeedle, aHaystack, aCompare, aBias) {
  if (aHaystack.length === 0) {
    return -1;
  }

  var index = recursiveSearch(-1, aHaystack.length, aNeedle, aHaystack, aCompare, aBias || exports.GREATEST_LOWER_BOUND);
  if (index < 0) {
    return -1;
  }

  // We have found either the exact element, or the next-closest element than
  // the one we are searching for. However, there may be more than one such
  // element. Make sure we always return the smallest of these.
  while (index - 1 >= 0) {
    if (aCompare(aHaystack[index], aHaystack[index - 1], true) !== 0) {
      break;
    }
    --index;
  }

  return index;
};

/***/ }),
/* 166 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/* -*- Mode: js; js-indent-level: 2; -*- */
/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */

// It turns out that some (most?) JavaScript engines don't self-host
// `Array.prototype.sort`. This makes sense because C++ will likely remain
// faster than JS when doing raw CPU-intensive sorting. However, when using a
// custom comparator function, calling back and forth between the VM's C++ and
// JIT'd JS is rather slow *and* loses JIT type information, resulting in
// worse generated code for the comparator function than would be optimal. In
// fact, when sorting with a comparator, these costs outweigh the benefits of
// sorting in C++. By using our own JS-implemented Quick Sort (below), we get
// a ~3500ms mean speed-up in `bench/bench.html`.

/**
 * Swap the elements indexed by `x` and `y` in the array `ary`.
 *
 * @param {Array} ary
 *        The array.
 * @param {Number} x
 *        The index of the first item.
 * @param {Number} y
 *        The index of the second item.
 */
function swap(ary, x, y) {
  var temp = ary[x];
  ary[x] = ary[y];
  ary[y] = temp;
}

/**
 * Returns a random integer within the range `low .. high` inclusive.
 *
 * @param {Number} low
 *        The lower bound on the range.
 * @param {Number} high
 *        The upper bound on the range.
 */
function randomIntInRange(low, high) {
  return Math.round(low + Math.random() * (high - low));
}

/**
 * The Quick Sort algorithm.
 *
 * @param {Array} ary
 *        An array to sort.
 * @param {function} comparator
 *        Function to use to compare two items.
 * @param {Number} p
 *        Start index of the array
 * @param {Number} r
 *        End index of the array
 */
function doQuickSort(ary, comparator, p, r) {
  // If our lower bound is less than our upper bound, we (1) partition the
  // array into two pieces and (2) recurse on each half. If it is not, this is
  // the empty array and our base case.

  if (p < r) {
    // (1) Partitioning.
    //
    // The partitioning chooses a pivot between `p` and `r` and moves all
    // elements that are less than or equal to the pivot to the before it, and
    // all the elements that are greater than it after it. The effect is that
    // once partition is done, the pivot is in the exact place it will be when
    // the array is put in sorted order, and it will not need to be moved
    // again. This runs in O(n) time.

    // Always choose a random pivot so that an input array which is reverse
    // sorted does not cause O(n^2) running time.
    var pivotIndex = randomIntInRange(p, r);
    var i = p - 1;

    swap(ary, pivotIndex, r);
    var pivot = ary[r];

    // Immediately after `j` is incremented in this loop, the following hold
    // true:
    //
    //   * Every element in `ary[p .. i]` is less than or equal to the pivot.
    //
    //   * Every element in `ary[i+1 .. j-1]` is greater than the pivot.
    for (var j = p; j < r; j++) {
      if (comparator(ary[j], pivot) <= 0) {
        i += 1;
        swap(ary, i, j);
      }
    }

    swap(ary, i + 1, j);
    var q = i + 1;

    // (2) Recurse on each half.

    doQuickSort(ary, comparator, p, q - 1);
    doQuickSort(ary, comparator, q + 1, r);
  }
}

/**
 * Sort the given array in-place with the given comparator function.
 *
 * @param {Array} ary
 *        An array to sort.
 * @param {function} comparator
 *        Function to use to compare two items.
 */
exports.quickSort = function (ary, comparator) {
  doQuickSort(ary, comparator, 0, ary.length - 1);
};

/***/ }),
/* 167 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/* -*- Mode: js; js-indent-level: 2; -*- */
/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */

var SourceMapGenerator = __webpack_require__(56).SourceMapGenerator;
var util = __webpack_require__(23);

// Matches a Windows-style `\r\n` newline or a `\n` newline used by all other
// operating systems these days (capturing the result).
var REGEX_NEWLINE = /(\r?\n)/;

// Newline character code for charCodeAt() comparisons
var NEWLINE_CODE = 10;

// Private symbol for identifying `SourceNode`s when multiple versions of
// the source-map library are loaded. This MUST NOT CHANGE across
// versions!
var isSourceNode = "$$$isSourceNode$$$";

/**
 * SourceNodes provide a way to abstract over interpolating/concatenating
 * snippets of generated JavaScript source code while maintaining the line and
 * column information associated with the original source code.
 *
 * @param aLine The original line number.
 * @param aColumn The original column number.
 * @param aSource The original source's filename.
 * @param aChunks Optional. An array of strings which are snippets of
 *        generated JS, or other SourceNodes.
 * @param aName The original identifier.
 */
function SourceNode(aLine, aColumn, aSource, aChunks, aName) {
  this.children = [];
  this.sourceContents = {};
  this.line = aLine == null ? null : aLine;
  this.column = aColumn == null ? null : aColumn;
  this.source = aSource == null ? null : aSource;
  this.name = aName == null ? null : aName;
  this[isSourceNode] = true;
  if (aChunks != null) this.add(aChunks);
}

/**
 * Creates a SourceNode from generated code and a SourceMapConsumer.
 *
 * @param aGeneratedCode The generated code
 * @param aSourceMapConsumer The SourceMap for the generated code
 * @param aRelativePath Optional. The path that relative sources in the
 *        SourceMapConsumer should be relative to.
 */
SourceNode.fromStringWithSourceMap = function SourceNode_fromStringWithSourceMap(aGeneratedCode, aSourceMapConsumer, aRelativePath) {
  // The SourceNode we want to fill with the generated code
  // and the SourceMap
  var node = new SourceNode();

  // All even indices of this array are one line of the generated code,
  // while all odd indices are the newlines between two adjacent lines
  // (since `REGEX_NEWLINE` captures its match).
  // Processed fragments are accessed by calling `shiftNextLine`.
  var remainingLines = aGeneratedCode.split(REGEX_NEWLINE);
  var remainingLinesIndex = 0;
  var shiftNextLine = function () {
    var lineContents = getNextLine();
    // The last line of a file might not have a newline.
    var newLine = getNextLine() || "";
    return lineContents + newLine;

    function getNextLine() {
      return remainingLinesIndex < remainingLines.length ? remainingLines[remainingLinesIndex++] : undefined;
    }
  };

  // We need to remember the position of "remainingLines"
  var lastGeneratedLine = 1,
      lastGeneratedColumn = 0;

  // The generate SourceNodes we need a code range.
  // To extract it current and last mapping is used.
  // Here we store the last mapping.
  var lastMapping = null;

  aSourceMapConsumer.eachMapping(function (mapping) {
    if (lastMapping !== null) {
      // We add the code from "lastMapping" to "mapping":
      // First check if there is a new line in between.
      if (lastGeneratedLine < mapping.generatedLine) {
        // Associate first line with "lastMapping"
        addMappingWithCode(lastMapping, shiftNextLine());
        lastGeneratedLine++;
        lastGeneratedColumn = 0;
        // The remaining code is added without mapping
      } else {
        // There is no new line in between.
        // Associate the code between "lastGeneratedColumn" and
        // "mapping.generatedColumn" with "lastMapping"
        var nextLine = remainingLines[remainingLinesIndex] || '';
        var code = nextLine.substr(0, mapping.generatedColumn - lastGeneratedColumn);
        remainingLines[remainingLinesIndex] = nextLine.substr(mapping.generatedColumn - lastGeneratedColumn);
        lastGeneratedColumn = mapping.generatedColumn;
        addMappingWithCode(lastMapping, code);
        // No more remaining code, continue
        lastMapping = mapping;
        return;
      }
    }
    // We add the generated code until the first mapping
    // to the SourceNode without any mapping.
    // Each line is added as separate string.
    while (lastGeneratedLine < mapping.generatedLine) {
      node.add(shiftNextLine());
      lastGeneratedLine++;
    }
    if (lastGeneratedColumn < mapping.generatedColumn) {
      var nextLine = remainingLines[remainingLinesIndex] || '';
      node.add(nextLine.substr(0, mapping.generatedColumn));
      remainingLines[remainingLinesIndex] = nextLine.substr(mapping.generatedColumn);
      lastGeneratedColumn = mapping.generatedColumn;
    }
    lastMapping = mapping;
  }, this);
  // We have processed all mappings.
  if (remainingLinesIndex < remainingLines.length) {
    if (lastMapping) {
      // Associate the remaining code in the current line with "lastMapping"
      addMappingWithCode(lastMapping, shiftNextLine());
    }
    // and add the remaining lines without any mapping
    node.add(remainingLines.splice(remainingLinesIndex).join(""));
  }

  // Copy sourcesContent into SourceNode
  aSourceMapConsumer.sources.forEach(function (sourceFile) {
    var content = aSourceMapConsumer.sourceContentFor(sourceFile);
    if (content != null) {
      if (aRelativePath != null) {
        sourceFile = util.join(aRelativePath, sourceFile);
      }
      node.setSourceContent(sourceFile, content);
    }
  });

  return node;

  function addMappingWithCode(mapping, code) {
    if (mapping === null || mapping.source === undefined) {
      node.add(code);
    } else {
      var source = aRelativePath ? util.join(aRelativePath, mapping.source) : mapping.source;
      node.add(new SourceNode(mapping.originalLine, mapping.originalColumn, source, code, mapping.name));
    }
  }
};

/**
 * Add a chunk of generated JS to this source node.
 *
 * @param aChunk A string snippet of generated JS code, another instance of
 *        SourceNode, or an array where each member is one of those things.
 */
SourceNode.prototype.add = function SourceNode_add(aChunk) {
  if (Array.isArray(aChunk)) {
    aChunk.forEach(function (chunk) {
      this.add(chunk);
    }, this);
  } else if (aChunk[isSourceNode] || typeof aChunk === "string") {
    if (aChunk) {
      this.children.push(aChunk);
    }
  } else {
    throw new TypeError("Expected a SourceNode, string, or an array of SourceNodes and strings. Got " + aChunk);
  }
  return this;
};

/**
 * Add a chunk of generated JS to the beginning of this source node.
 *
 * @param aChunk A string snippet of generated JS code, another instance of
 *        SourceNode, or an array where each member is one of those things.
 */
SourceNode.prototype.prepend = function SourceNode_prepend(aChunk) {
  if (Array.isArray(aChunk)) {
    for (var i = aChunk.length - 1; i >= 0; i--) {
      this.prepend(aChunk[i]);
    }
  } else if (aChunk[isSourceNode] || typeof aChunk === "string") {
    this.children.unshift(aChunk);
  } else {
    throw new TypeError("Expected a SourceNode, string, or an array of SourceNodes and strings. Got " + aChunk);
  }
  return this;
};

/**
 * Walk over the tree of JS snippets in this node and its children. The
 * walking function is called once for each snippet of JS and is passed that
 * snippet and the its original associated source's line/column location.
 *
 * @param aFn The traversal function.
 */
SourceNode.prototype.walk = function SourceNode_walk(aFn) {
  var chunk;
  for (var i = 0, len = this.children.length; i < len; i++) {
    chunk = this.children[i];
    if (chunk[isSourceNode]) {
      chunk.walk(aFn);
    } else {
      if (chunk !== '') {
        aFn(chunk, { source: this.source,
          line: this.line,
          column: this.column,
          name: this.name });
      }
    }
  }
};

/**
 * Like `String.prototype.join` except for SourceNodes. Inserts `aStr` between
 * each of `this.children`.
 *
 * @param aSep The separator.
 */
SourceNode.prototype.join = function SourceNode_join(aSep) {
  var newChildren;
  var i;
  var len = this.children.length;
  if (len > 0) {
    newChildren = [];
    for (i = 0; i < len - 1; i++) {
      newChildren.push(this.children[i]);
      newChildren.push(aSep);
    }
    newChildren.push(this.children[i]);
    this.children = newChildren;
  }
  return this;
};

/**
 * Call String.prototype.replace on the very right-most source snippet. Useful
 * for trimming whitespace from the end of a source node, etc.
 *
 * @param aPattern The pattern to replace.
 * @param aReplacement The thing to replace the pattern with.
 */
SourceNode.prototype.replaceRight = function SourceNode_replaceRight(aPattern, aReplacement) {
  var lastChild = this.children[this.children.length - 1];
  if (lastChild[isSourceNode]) {
    lastChild.replaceRight(aPattern, aReplacement);
  } else if (typeof lastChild === 'string') {
    this.children[this.children.length - 1] = lastChild.replace(aPattern, aReplacement);
  } else {
    this.children.push(''.replace(aPattern, aReplacement));
  }
  return this;
};

/**
 * Set the source content for a source file. This will be added to the SourceMapGenerator
 * in the sourcesContent field.
 *
 * @param aSourceFile The filename of the source file
 * @param aSourceContent The content of the source file
 */
SourceNode.prototype.setSourceContent = function SourceNode_setSourceContent(aSourceFile, aSourceContent) {
  this.sourceContents[util.toSetString(aSourceFile)] = aSourceContent;
};

/**
 * Walk over the tree of SourceNodes. The walking function is called for each
 * source file content and is passed the filename and source content.
 *
 * @param aFn The traversal function.
 */
SourceNode.prototype.walkSourceContents = function SourceNode_walkSourceContents(aFn) {
  for (var i = 0, len = this.children.length; i < len; i++) {
    if (this.children[i][isSourceNode]) {
      this.children[i].walkSourceContents(aFn);
    }
  }

  var sources = Object.keys(this.sourceContents);
  for (var i = 0, len = sources.length; i < len; i++) {
    aFn(util.fromSetString(sources[i]), this.sourceContents[sources[i]]);
  }
};

/**
 * Return the string representation of this source node. Walks over the tree
 * and concatenates all the various snippets together to one string.
 */
SourceNode.prototype.toString = function SourceNode_toString() {
  var str = "";
  this.walk(function (chunk) {
    str += chunk;
  });
  return str;
};

/**
 * Returns the string representation of this source node along with a source
 * map.
 */
SourceNode.prototype.toStringWithSourceMap = function SourceNode_toStringWithSourceMap(aArgs) {
  var generated = {
    code: "",
    line: 1,
    column: 0
  };
  var map = new SourceMapGenerator(aArgs);
  var sourceMappingActive = false;
  var lastOriginalSource = null;
  var lastOriginalLine = null;
  var lastOriginalColumn = null;
  var lastOriginalName = null;
  this.walk(function (chunk, original) {
    generated.code += chunk;
    if (original.source !== null && original.line !== null && original.column !== null) {
      if (lastOriginalSource !== original.source || lastOriginalLine !== original.line || lastOriginalColumn !== original.column || lastOriginalName !== original.name) {
        map.addMapping({
          source: original.source,
          original: {
            line: original.line,
            column: original.column
          },
          generated: {
            line: generated.line,
            column: generated.column
          },
          name: original.name
        });
      }
      lastOriginalSource = original.source;
      lastOriginalLine = original.line;
      lastOriginalColumn = original.column;
      lastOriginalName = original.name;
      sourceMappingActive = true;
    } else if (sourceMappingActive) {
      map.addMapping({
        generated: {
          line: generated.line,
          column: generated.column
        }
      });
      lastOriginalSource = null;
      sourceMappingActive = false;
    }
    for (var idx = 0, length = chunk.length; idx < length; idx++) {
      if (chunk.charCodeAt(idx) === NEWLINE_CODE) {
        generated.line++;
        generated.column = 0;
        // Mappings end at eol
        if (idx + 1 === length) {
          lastOriginalSource = null;
          sourceMappingActive = false;
        } else if (sourceMappingActive) {
          map.addMapping({
            source: original.source,
            original: {
              line: original.line,
              column: original.column
            },
            generated: {
              line: generated.line,
              column: generated.column
            },
            name: original.name
          });
        }
      } else {
        generated.column++;
      }
    }
  });
  this.walkSourceContents(function (sourceFile, sourceContent) {
    map.setSourceContent(sourceFile, sourceContent);
  });

  return { code: generated.code, map: map };
};

exports.SourceNode = SourceNode;

/***/ }),
/* 168 */
/***/ (function(module, exports) {

module.exports = require("module");

/***/ }),
/* 169 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.ElectronHttpExecutor = undefined;

var _bluebirdLst;

function _load_bluebirdLst() {
    return _bluebirdLst = __webpack_require__(2);
}

var _builderUtilRuntime;

function _load_builderUtilRuntime() {
    return _builderUtilRuntime = __webpack_require__(3);
}

var _electron;

function _load_electron() {
    return _electron = __webpack_require__(10);
}

var _fsExtraP;

function _load_fsExtraP() {
    return _fsExtraP = __webpack_require__(9);
}

var _path = _interopRequireWildcard(__webpack_require__(0));

function _interopRequireWildcard(obj) {
    if (obj && obj.__esModule) {
        return obj;
    } else {
        var newObj = {};if (obj != null) {
            for (var key in obj) {
                if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key];
            }
        }newObj.default = obj;return newObj;
    }
}

class ElectronHttpExecutor extends (_builderUtilRuntime || _load_builderUtilRuntime()).HttpExecutor {
    constructor(proxyLoginCallback) {
        super();
        this.proxyLoginCallback = proxyLoginCallback;
    }
    download(url, destination, options) {
        var _this = this;

        return (0, (_bluebirdLst || _load_bluebirdLst()).coroutine)(function* () {
            if (options == null || !options.skipDirCreation) {
                yield (0, (_fsExtraP || _load_fsExtraP()).ensureDir)(_path.dirname(destination));
            }
            return yield options.cancellationToken.createPromise(function (resolve, reject, onCancel) {
                _this.doDownload(Object.assign({}, (0, (_builderUtilRuntime || _load_builderUtilRuntime()).configureRequestOptionsFromUrl)(url, {
                    headers: options.headers || undefined
                }), { redirect: "manual" }), destination, 0, options, function (error) {
                    if (error == null) {
                        resolve(destination);
                    } else {
                        reject(error);
                    }
                }, onCancel);
            });
        })();
    }
    doRequest(options, callback) {
        const request = (_electron || _load_electron()).net.request(options);
        request.on("response", callback);
        this.addProxyLoginHandler(request);
        return request;
    }
    addProxyLoginHandler(request) {
        if (this.proxyLoginCallback != null) {
            request.on("login", this.proxyLoginCallback);
        }
    }
    addRedirectHandlers(request, options, reject, redirectCount, handler) {
        request.on("redirect", (statusCode, method, redirectUrl) => {
            if (redirectCount > 10) {
                reject(new Error("Too many redirects (> 10)"));
                return;
            }
            handler((_builderUtilRuntime || _load_builderUtilRuntime()).HttpExecutor.prepareRedirectUrlOptions(redirectUrl, options));
        });
    }
}
exports.ElectronHttpExecutor = ElectronHttpExecutor; //# sourceMappingURL=electronHttpExecutor.js.map

/***/ }),
/* 170 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.createClient = createClient;

var _builderUtilRuntime;

function _load_builderUtilRuntime() {
    return _builderUtilRuntime = __webpack_require__(3);
}

var _BintrayProvider;

function _load_BintrayProvider() {
    return _BintrayProvider = __webpack_require__(171);
}

var _GenericProvider;

function _load_GenericProvider() {
    return _GenericProvider = __webpack_require__(59);
}

var _GitHubProvider;

function _load_GitHubProvider() {
    return _GitHubProvider = __webpack_require__(60);
}

var _PrivateGitHubProvider;

function _load_PrivateGitHubProvider() {
    return _PrivateGitHubProvider = __webpack_require__(173);
}

function createClient(data, updater) {
    if (typeof data === "string") {
        throw (0, (_builderUtilRuntime || _load_builderUtilRuntime()).newError)("Please pass PublishConfiguration object", "ERR_UPDATER_INVALID_PROVIDER_CONFIGURATION");
    }
    const httpExecutor = updater.httpExecutor;
    const provider = data.provider;
    switch (provider) {
        case "github":
            const githubOptions = data;
            const token = (githubOptions.private ? process.env.GH_TOKEN : null) || githubOptions.token;
            if (token == null) {
                return new (_GitHubProvider || _load_GitHubProvider()).GitHubProvider(githubOptions, updater, httpExecutor);
            } else {
                return new (_PrivateGitHubProvider || _load_PrivateGitHubProvider()).PrivateGitHubProvider(githubOptions, token, httpExecutor);
            }
        case "s3":
        case "spaces":
            return new (_GenericProvider || _load_GenericProvider()).GenericProvider({
                provider: "generic",
                url: (0, (_builderUtilRuntime || _load_builderUtilRuntime()).getS3LikeProviderBaseUrl)(data),
                channel: data.channel || null
            }, updater, provider === "spaces" /* https://github.com/minio/minio/issues/5285#issuecomment-350428955 */);
        case "generic":
            return new (_GenericProvider || _load_GenericProvider()).GenericProvider(data, updater, true);
        case "bintray":
            return new (_BintrayProvider || _load_BintrayProvider()).BintrayProvider(data, httpExecutor);
        default:
            throw (0, (_builderUtilRuntime || _load_builderUtilRuntime()).newError)(`Unsupported provider: ${provider}`, "ERR_UPDATER_UNSUPPORTED_PROVIDER");
    }
}
//# sourceMappingURL=providerFactory.js.map

/***/ }),
/* 171 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.BintrayProvider = undefined;

var _bluebirdLst;

function _load_bluebirdLst() {
    return _bluebirdLst = __webpack_require__(2);
}

var _builderUtilRuntime;

function _load_builderUtilRuntime() {
    return _builderUtilRuntime = __webpack_require__(3);
}

var _bintray;

function _load_bintray() {
    return _bintray = __webpack_require__(172);
}

var _url;

function _load_url() {
    return _url = __webpack_require__(20);
}

var _main;

function _load_main() {
    return _main = __webpack_require__(8);
}

var _Provider;

function _load_Provider() {
    return _Provider = __webpack_require__(14);
}

class BintrayProvider extends (_main || _load_main()).Provider {
    constructor(configuration, httpExecutor) {
        super(httpExecutor);
        this.client = new (_bintray || _load_bintray()).BintrayClient(configuration, httpExecutor, new (_builderUtilRuntime || _load_builderUtilRuntime()).CancellationToken());
        this.baseUrl = (0, (_main || _load_main()).newBaseUrl)(`https://dl.bintray.com/${this.client.owner}/${this.client.repo}`);
    }
    setRequestHeaders(value) {
        super.setRequestHeaders(value);
        this.client.setRequestHeaders(value);
    }
    getLatestVersion() {
        var _this = this;

        return (0, (_bluebirdLst || _load_bluebirdLst()).coroutine)(function* () {
            try {
                const data = yield _this.client.getVersion("_latest");
                const channelFilename = (0, (_main || _load_main()).getChannelFilename)((0, (_main || _load_main()).getDefaultChannelName)());
                const files = yield _this.client.getVersionFiles(data.name);
                const channelFile = files.find(function (it) {
                    return it.name.endsWith(`_${channelFilename}`) || it.name.endsWith(`-${channelFilename}`);
                });
                if (channelFile == null) {
                    // noinspection ExceptionCaughtLocallyJS
                    throw (0, (_builderUtilRuntime || _load_builderUtilRuntime()).newError)(`Cannot find channel file "${channelFilename}", existing files:\n${files.map(function (it) {
                        return JSON.stringify(it, null, 2);
                    }).join(",\n")}`, "ERR_UPDATER_CHANNEL_FILE_NOT_FOUND");
                }
                const channelFileUrl = new (_url || _load_url()).URL(`https://dl.bintray.com/${_this.client.owner}/${_this.client.repo}/${channelFile.name}`);
                return (0, (_Provider || _load_Provider()).parseUpdateInfo)((yield _this.httpRequest(channelFileUrl)), channelFilename, channelFileUrl);
            } catch (e) {
                if ("statusCode" in e && e.statusCode === 404) {
                    throw (0, (_builderUtilRuntime || _load_builderUtilRuntime()).newError)(`No latest version, please ensure that user, package and repository correctly configured. Or at least one version is published. ${e.stack || e.message}`, "ERR_UPDATER_LATEST_VERSION_NOT_FOUND");
                }
                throw e;
            }
        })();
    }
    resolveFiles(updateInfo) {
        return (0, (_Provider || _load_Provider()).resolveFiles)(updateInfo, this.baseUrl);
    }
}
exports.BintrayProvider = BintrayProvider; //# sourceMappingURL=BintrayProvider.js.map

/***/ }),
/* 172 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.BintrayClient = undefined;

var _httpExecutor;

function _load_httpExecutor() {
    return _httpExecutor = __webpack_require__(42);
}

class BintrayClient {
    constructor(options, httpExecutor, cancellationToken, apiKey) {
        this.httpExecutor = httpExecutor;
        this.cancellationToken = cancellationToken;
        if (options.owner == null) {
            throw new Error("owner is not specified");
        }
        if (options.package == null) {
            throw new Error("package is not specified");
        }
        this.repo = options.repo || "generic";
        this.packageName = options.package;
        this.owner = options.owner;
        this.user = options.user || options.owner;
        this.component = options.component || null;
        this.distribution = options.distribution || "stable";
        this.auth = apiKey == null ? null : `Basic ${Buffer.from(`${this.user}:${apiKey}`).toString("base64")}`;
        this.basePath = `/packages/${this.owner}/${this.repo}/${this.packageName}`;
    }
    setRequestHeaders(value) {
        this.requestHeaders = value;
    }
    bintrayRequest(path, auth, data = null, cancellationToken, method) {
        return (0, (_httpExecutor || _load_httpExecutor()).parseJson)(this.httpExecutor.request((0, (_httpExecutor || _load_httpExecutor()).configureRequestOptions)({ hostname: "api.bintray.com", path, headers: this.requestHeaders || undefined }, auth, method), cancellationToken, data));
    }
    getVersion(version) {
        return this.bintrayRequest(`${this.basePath}/versions/${version}`, this.auth, null, this.cancellationToken);
    }
    getVersionFiles(version) {
        return this.bintrayRequest(`${this.basePath}/versions/${version}/files`, this.auth, null, this.cancellationToken);
    }
    createVersion(version) {
        return this.bintrayRequest(`${this.basePath}/versions`, this.auth, {
            name: version
        }, this.cancellationToken);
    }
    deleteVersion(version) {
        return this.bintrayRequest(`${this.basePath}/versions/${version}`, this.auth, null, this.cancellationToken, "DELETE");
    }
}
exports.BintrayClient = BintrayClient; //# sourceMappingURL=bintray.js.map

/***/ }),
/* 173 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.PrivateGitHubProvider = undefined;

var _bluebirdLst;

function _load_bluebirdLst() {
    return _bluebirdLst = __webpack_require__(2);
}

var _builderUtilRuntime;

function _load_builderUtilRuntime() {
    return _builderUtilRuntime = __webpack_require__(3);
}

var _jsYaml;

function _load_jsYaml() {
    return _jsYaml = __webpack_require__(31);
}

var _path = _interopRequireWildcard(__webpack_require__(0));

var _url;

function _load_url() {
    return _url = __webpack_require__(20);
}

var _GitHubProvider;

function _load_GitHubProvider() {
    return _GitHubProvider = __webpack_require__(60);
}

var _main;

function _load_main() {
    return _main = __webpack_require__(8);
}

var _Provider;

function _load_Provider() {
    return _Provider = __webpack_require__(14);
}

function _interopRequireWildcard(obj) {
    if (obj && obj.__esModule) {
        return obj;
    } else {
        var newObj = {};if (obj != null) {
            for (var key in obj) {
                if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key];
            }
        }newObj.default = obj;return newObj;
    }
}

class PrivateGitHubProvider extends (_GitHubProvider || _load_GitHubProvider()).BaseGitHubProvider {
    constructor(options, token, executor) {
        super(options, "api.github.com", executor);
        this.token = token;
    }
    createRequestOptions(url, headers) {
        const result = super.createRequestOptions(url, headers);
        result.redirect = "manual";
        return result;
    }
    getLatestVersion() {
        var _this = this;

        return (0, (_bluebirdLst || _load_bluebirdLst()).coroutine)(function* () {
            const basePath = _this.basePath;
            const cancellationToken = new (_builderUtilRuntime || _load_builderUtilRuntime()).CancellationToken();
            const channelFile = (0, (_main || _load_main()).getChannelFilename)((0, (_main || _load_main()).getDefaultChannelName)());
            const releaseInfo = yield _this.getLatestVersionInfo(basePath, cancellationToken);
            const asset = releaseInfo.assets.find(function (it) {
                return it.name === channelFile;
            });
            if (asset == null) {
                // html_url must be always, but just to be sure
                throw (0, (_builderUtilRuntime || _load_builderUtilRuntime()).newError)(`Cannot find ${channelFile} in the release ${releaseInfo.html_url || releaseInfo.name}`, "ERR_UPDATER_CHANNEL_FILE_NOT_FOUND");
            }
            const url = new (_url || _load_url()).URL(asset.url);
            let result;
            try {
                result = (0, (_jsYaml || _load_jsYaml()).safeLoad)((yield _this.httpRequest(url, _this.configureHeaders("application/octet-stream"), cancellationToken)));
            } catch (e) {
                if (e instanceof (_builderUtilRuntime || _load_builderUtilRuntime()).HttpError && e.statusCode === 404) {
                    throw (0, (_builderUtilRuntime || _load_builderUtilRuntime()).newError)(`Cannot find ${channelFile} in the latest release artifacts (${url}): ${e.stack || e.message}`, "ERR_UPDATER_CHANNEL_FILE_NOT_FOUND");
                }
                throw e;
            }
            result.assets = releaseInfo.assets;
            return result;
        })();
    }
    get fileExtraDownloadHeaders() {
        return this.configureHeaders("application/octet-stream");
    }
    configureHeaders(accept) {
        return {
            Accept: accept,
            Authorization: `token ${this.token}`
        };
    }
    getLatestVersionInfo(basePath, cancellationToken) {
        var _this2 = this;

        return (0, (_bluebirdLst || _load_bluebirdLst()).coroutine)(function* () {
            const url = (0, (_main || _load_main()).newUrlFromBase)(`${basePath}/latest`, _this2.baseUrl);
            try {
                return JSON.parse((yield _this2.httpRequest(url, _this2.configureHeaders("application/vnd.github.v3+json"), cancellationToken)));
            } catch (e) {
                throw (0, (_builderUtilRuntime || _load_builderUtilRuntime()).newError)(`Unable to find latest version on GitHub (${url}), please ensure a production release exists: ${e.stack || e.message}`, "ERR_UPDATER_LATEST_VERSION_NOT_FOUND");
            }
        })();
    }
    get basePath() {
        return this.computeGithubBasePath(`/repos/${this.options.owner}/${this.options.repo}/releases`);
    }
    resolveFiles(updateInfo) {
        return (0, (_Provider || _load_Provider()).getFileList)(updateInfo).map(it => {
            const name = _path.posix.basename(it.url).replace(/ /g, "-");
            const asset = updateInfo.assets.find(it => it != null && it.name === name);
            if (asset == null) {
                throw (0, (_builderUtilRuntime || _load_builderUtilRuntime()).newError)(`Cannot find asset "${name}" in: ${JSON.stringify(updateInfo.assets, null, 2)}`, "ERR_UPDATER_ASSET_NOT_FOUND");
            }
            return {
                url: new (_url || _load_url()).URL(asset.url),
                info: it
            };
        });
    }
}
exports.PrivateGitHubProvider = PrivateGitHubProvider; //# sourceMappingURL=PrivateGitHubProvider.js.map

/***/ }),
/* 174 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.NsisUpdater = undefined;

var _bluebirdLst;

function _load_bluebirdLst() {
    return _bluebirdLst = __webpack_require__(2);
}

var _builderUtilRuntime;

function _load_builderUtilRuntime() {
    return _builderUtilRuntime = __webpack_require__(3);
}

var _child_process;

function _load_child_process() {
    return _child_process = __webpack_require__(34);
}

var _path = _interopRequireWildcard(__webpack_require__(0));

__webpack_require__(33);

var _BaseUpdater;

function _load_BaseUpdater() {
    return _BaseUpdater = __webpack_require__(61);
}

var _FileWithEmbeddedBlockMapDifferentialDownloader;

function _load_FileWithEmbeddedBlockMapDifferentialDownloader() {
    return _FileWithEmbeddedBlockMapDifferentialDownloader = __webpack_require__(62);
}

var _GenericDifferentialDownloader;

function _load_GenericDifferentialDownloader() {
    return _GenericDifferentialDownloader = __webpack_require__(179);
}

var _main;

function _load_main() {
    return _main = __webpack_require__(8);
}

var _Provider;

function _load_Provider() {
    return _Provider = __webpack_require__(14);
}

var _windowsExecutableCodeSignatureVerifier;

function _load_windowsExecutableCodeSignatureVerifier() {
    return _windowsExecutableCodeSignatureVerifier = __webpack_require__(180);
}

function _interopRequireWildcard(obj) {
    if (obj && obj.__esModule) {
        return obj;
    } else {
        var newObj = {};if (obj != null) {
            for (var key in obj) {
                if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key];
            }
        }newObj.default = obj;return newObj;
    }
}

class NsisUpdater extends (_BaseUpdater || _load_BaseUpdater()).BaseUpdater {
    constructor(options, app) {
        super(options, app);
    }
    /*** @private */
    doDownloadUpdate(updateInfo, cancellationToken) {
        var _this = this;

        return (0, (_bluebirdLst || _load_bluebirdLst()).coroutine)(function* () {
            const provider = yield _this.provider;
            const fileInfo = (0, (_Provider || _load_Provider()).findFile)(provider.resolveFiles(updateInfo), "exe");
            const requestHeaders = yield _this.computeRequestHeaders();
            const downloadOptions = {
                skipDirCreation: true,
                headers: requestHeaders,
                cancellationToken,
                sha512: fileInfo.info.sha512
            };
            let packagePath = _this.downloadedUpdateHelper.packagePath;
            let installerPath = _this.downloadedUpdateHelper.getDownloadedFile(updateInfo, fileInfo);
            if (installerPath != null) {
                return packagePath == null ? [installerPath] : [installerPath, packagePath];
            }
            yield _this.executeDownload(downloadOptions, fileInfo, (() => {
                var _ref = (0, (_bluebirdLst || _load_bluebirdLst()).coroutine)(function* (tempDir, destinationFile, removeTempDirIfAny) {
                    installerPath = destinationFile;
                    if (yield _this.differentialDownloadInstaller(fileInfo, "OLD", installerPath, requestHeaders, provider)) {
                        yield _this.httpExecutor.download(fileInfo.url.href, installerPath, downloadOptions);
                    }
                    const signatureVerificationStatus = yield _this.verifySignature(installerPath);
                    if (signatureVerificationStatus != null) {
                        yield removeTempDirIfAny();
                        // noinspection ThrowInsideFinallyBlockJS
                        throw (0, (_builderUtilRuntime || _load_builderUtilRuntime()).newError)(`New version ${_this.updateInfo.version} is not signed by the application owner: ${signatureVerificationStatus}`, "ERR_UPDATER_INVALID_SIGNATURE");
                    }
                    const packageInfo = fileInfo.packageInfo;
                    if (packageInfo != null) {
                        packagePath = _path.join(tempDir, `package-${updateInfo.version}${_path.extname(packageInfo.path) || ".7z"}`);
                        if (yield _this.differentialDownloadWebPackage(packageInfo, packagePath, provider)) {
                            yield _this.httpExecutor.download(packageInfo.path, packagePath, {
                                skipDirCreation: true,
                                headers: requestHeaders,
                                cancellationToken,
                                sha512: packageInfo.sha512
                            });
                        }
                    }
                });

                return function (_x, _x2, _x3) {
                    return _ref.apply(this, arguments);
                };
            })());
            _this.downloadedUpdateHelper.setDownloadedFile(installerPath, packagePath, updateInfo, fileInfo);
            _this.addQuitHandler();
            _this.emit((_main || _load_main()).UPDATE_DOWNLOADED, _this.updateInfo);
            return packagePath == null ? [installerPath] : [installerPath, packagePath];
        })();
    }
    // $certificateInfo = (Get-AuthenticodeSignature 'xxx\yyy.exe'
    // | where {$_.Status.Equals([System.Management.Automation.SignatureStatus]::Valid) -and $_.SignerCertificate.Subject.Contains("CN=siemens.com")})
    // | Out-String ; if ($certificateInfo) { exit 0 } else { exit 1 }
    verifySignature(tempUpdateFile) {
        var _this2 = this;

        return (0, (_bluebirdLst || _load_bluebirdLst()).coroutine)(function* () {
            let publisherName;
            try {
                publisherName = (yield _this2.configOnDisk.value).publisherName;
                if (publisherName == null) {
                    return null;
                }
            } catch (e) {
                if (e.code === "ENOENT") {
                    // no app-update.yml
                    return null;
                }
                throw e;
            }
            return yield (0, (_windowsExecutableCodeSignatureVerifier || _load_windowsExecutableCodeSignatureVerifier()).verifySignature)(Array.isArray(publisherName) ? publisherName : [publisherName], tempUpdateFile, _this2._logger);
        })();
    }
    doInstall(installerPath, isSilent, isForceRunAfter) {
        const args = ["--updated"];
        if (isSilent) {
            args.push("/S");
        }
        if (isForceRunAfter) {
            args.push("--force-run");
        }
        const packagePath = this.downloadedUpdateHelper.packagePath;
        if (packagePath != null) {
            // only = form is supported
            args.push(`--package-file=${packagePath}`);
        }
        const spawnOptions = {
            detached: true,
            stdio: "ignore"
        };
        try {
            (0, (_child_process || _load_child_process()).spawn)(installerPath, args, spawnOptions).unref();
        } catch (e) {
            // yes, such errors dispatched not as error event
            // https://github.com/electron-userland/electron-builder/issues/1129
            if (e.code === "UNKNOWN" || e.code === "EACCES") {
                this._logger.info("Access denied or UNKNOWN error code on spawn, will be executed again using elevate");
                try {
                    (0, (_child_process || _load_child_process()).spawn)(_path.join(process.resourcesPath, "elevate.exe"), [installerPath].concat(args), spawnOptions).unref();
                } catch (e) {
                    this.dispatchError(e);
                }
            } else {
                this.dispatchError(e);
            }
        }
        return true;
    }
    differentialDownloadInstaller(fileInfo, oldFile, installerPath, requestHeaders, provider) {
        var _this3 = this;

        return (0, (_bluebirdLst || _load_bluebirdLst()).coroutine)(function* () {
            if (process.env.__NSIS_DIFFERENTIAL_UPDATE__ == null) {
                return true;
            }
            try {
                const blockMapData = JSON.parse((yield provider.httpRequest((0, (_main || _load_main()).newUrlFromBase)(`${fileInfo.url.pathname}.blockMap.json`, fileInfo.url))));
                yield new (_GenericDifferentialDownloader || _load_GenericDifferentialDownloader()).GenericDifferentialDownloader(fileInfo.info, _this3.httpExecutor, {
                    newUrl: fileInfo.url.href,
                    oldFile,
                    logger: _this3._logger,
                    newFile: installerPath,
                    useMultipleRangeRequest: provider.useMultipleRangeRequest,
                    requestHeaders
                }).download(blockMapData);
            } catch (e) {
                _this3._logger.error(`Cannot download differentially, fallback to full download: ${e.stack || e}`);
                // during test (developer machine mac) we must throw error
                return process.platform === "win32";
            }
            return false;
        })();
    }
    differentialDownloadWebPackage(packageInfo, packagePath, provider) {
        var _this4 = this;

        return (0, (_bluebirdLst || _load_bluebirdLst()).coroutine)(function* () {
            if (packageInfo.blockMapSize == null) {
                return true;
            }
            try {
                yield new (_FileWithEmbeddedBlockMapDifferentialDownloader || _load_FileWithEmbeddedBlockMapDifferentialDownloader()).FileWithEmbeddedBlockMapDifferentialDownloader(packageInfo, _this4.httpExecutor, {
                    newUrl: packageInfo.path,
                    oldFile: _path.join(process.resourcesPath, "..", "package.7z"),
                    logger: _this4._logger,
                    newFile: packagePath,
                    requestHeaders: _this4.requestHeaders,
                    useMultipleRangeRequest: provider.useMultipleRangeRequest
                }).download();
            } catch (e) {
                _this4._logger.error(`Cannot download differentially, fallback to full download: ${e.stack || e}`);
                // during test (developer machine mac or linux) we must throw error
                return process.platform === "win32";
            }
            return false;
        })();
    }
}
exports.NsisUpdater = NsisUpdater; //# sourceMappingURL=NsisUpdater.js.map

/***/ }),
/* 175 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.DownloadedUpdateHelper = undefined;

var _lodash;

function _load_lodash() {
    return _lodash = _interopRequireDefault(__webpack_require__(176));
}

function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
}

/** @private **/
class DownloadedUpdateHelper {
    get file() {
        return this.setupPath;
    }
    get packagePath() {
        return this._packagePath;
    }
    getDownloadedFile(versionInfo, fileInfo) {
        if (this.setupPath == null) {
            return null;
        }
        return (0, (_lodash || _load_lodash()).default)(this.versionInfo, versionInfo) && (0, (_lodash || _load_lodash()).default)(this.fileInfo, fileInfo) ? this.setupPath : null;
    }
    setDownloadedFile(file, packagePath, versionInfo, fileInfo) {
        this.setupPath = file;
        this._packagePath = packagePath;
        this.versionInfo = versionInfo;
        this.fileInfo = fileInfo;
    }
    clear() {
        this.setupPath = null;
        this._packagePath = null;
        this.versionInfo = null;
        this.fileInfo = null;
    }
}
exports.DownloadedUpdateHelper = DownloadedUpdateHelper; //# sourceMappingURL=DownloadedUpdateHelper.js.map

/***/ }),
/* 176 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(module) {

/**
 * Lodash (Custom Build) <https://lodash.com/>
 * Build: `lodash modularize exports="npm" -o ./`
 * Copyright JS Foundation and other contributors <https://js.foundation/>
 * Released under MIT license <https://lodash.com/license>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 */

/** Used as the size to enable large array optimizations. */
var LARGE_ARRAY_SIZE = 200;

/** Used to stand-in for `undefined` hash values. */
var HASH_UNDEFINED = '__lodash_hash_undefined__';

/** Used to compose bitmasks for value comparisons. */
var COMPARE_PARTIAL_FLAG = 1,
    COMPARE_UNORDERED_FLAG = 2;

/** Used as references for various `Number` constants. */
var MAX_SAFE_INTEGER = 9007199254740991;

/** `Object#toString` result references. */
var argsTag = '[object Arguments]',
    arrayTag = '[object Array]',
    asyncTag = '[object AsyncFunction]',
    boolTag = '[object Boolean]',
    dateTag = '[object Date]',
    errorTag = '[object Error]',
    funcTag = '[object Function]',
    genTag = '[object GeneratorFunction]',
    mapTag = '[object Map]',
    numberTag = '[object Number]',
    nullTag = '[object Null]',
    objectTag = '[object Object]',
    promiseTag = '[object Promise]',
    proxyTag = '[object Proxy]',
    regexpTag = '[object RegExp]',
    setTag = '[object Set]',
    stringTag = '[object String]',
    symbolTag = '[object Symbol]',
    undefinedTag = '[object Undefined]',
    weakMapTag = '[object WeakMap]';

var arrayBufferTag = '[object ArrayBuffer]',
    dataViewTag = '[object DataView]',
    float32Tag = '[object Float32Array]',
    float64Tag = '[object Float64Array]',
    int8Tag = '[object Int8Array]',
    int16Tag = '[object Int16Array]',
    int32Tag = '[object Int32Array]',
    uint8Tag = '[object Uint8Array]',
    uint8ClampedTag = '[object Uint8ClampedArray]',
    uint16Tag = '[object Uint16Array]',
    uint32Tag = '[object Uint32Array]';

/**
 * Used to match `RegExp`
 * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).
 */
var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;

/** Used to detect host constructors (Safari). */
var reIsHostCtor = /^\[object .+?Constructor\]$/;

/** Used to detect unsigned integer values. */
var reIsUint = /^(?:0|[1-9]\d*)$/;

/** Used to identify `toStringTag` values of typed arrays. */
var typedArrayTags = {};
typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;
typedArrayTags[argsTag] = typedArrayTags[arrayTag] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] = typedArrayTags[dataViewTag] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag] = typedArrayTags[mapTag] = typedArrayTags[numberTag] = typedArrayTags[objectTag] = typedArrayTags[regexpTag] = typedArrayTags[setTag] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;

/** Detect free variable `global` from Node.js. */
var freeGlobal = typeof global == 'object' && global && global.Object === Object && global;

/** Detect free variable `self`. */
var freeSelf = typeof self == 'object' && self && self.Object === Object && self;

/** Used as a reference to the global object. */
var root = freeGlobal || freeSelf || Function('return this')();

/** Detect free variable `exports`. */
var freeExports = typeof exports == 'object' && exports && !exports.nodeType && exports;

/** Detect free variable `module`. */
var freeModule = freeExports && typeof module == 'object' && module && !module.nodeType && module;

/** Detect the popular CommonJS extension `module.exports`. */
var moduleExports = freeModule && freeModule.exports === freeExports;

/** Detect free variable `process` from Node.js. */
var freeProcess = moduleExports && freeGlobal.process;

/** Used to access faster Node.js helpers. */
var nodeUtil = function () {
  try {
    return freeProcess && freeProcess.binding && freeProcess.binding('util');
  } catch (e) {}
}();

/* Node.js helper references. */
var nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;

/**
 * A specialized version of `_.filter` for arrays without support for
 * iteratee shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} predicate The function invoked per iteration.
 * @returns {Array} Returns the new filtered array.
 */
function arrayFilter(array, predicate) {
  var index = -1,
      length = array == null ? 0 : array.length,
      resIndex = 0,
      result = [];

  while (++index < length) {
    var value = array[index];
    if (predicate(value, index, array)) {
      result[resIndex++] = value;
    }
  }
  return result;
}

/**
 * Appends the elements of `values` to `array`.
 *
 * @private
 * @param {Array} array The array to modify.
 * @param {Array} values The values to append.
 * @returns {Array} Returns `array`.
 */
function arrayPush(array, values) {
  var index = -1,
      length = values.length,
      offset = array.length;

  while (++index < length) {
    array[offset + index] = values[index];
  }
  return array;
}

/**
 * A specialized version of `_.some` for arrays without support for iteratee
 * shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} predicate The function invoked per iteration.
 * @returns {boolean} Returns `true` if any element passes the predicate check,
 *  else `false`.
 */
function arraySome(array, predicate) {
  var index = -1,
      length = array == null ? 0 : array.length;

  while (++index < length) {
    if (predicate(array[index], index, array)) {
      return true;
    }
  }
  return false;
}

/**
 * The base implementation of `_.times` without support for iteratee shorthands
 * or max array length checks.
 *
 * @private
 * @param {number} n The number of times to invoke `iteratee`.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns the array of results.
 */
function baseTimes(n, iteratee) {
  var index = -1,
      result = Array(n);

  while (++index < n) {
    result[index] = iteratee(index);
  }
  return result;
}

/**
 * The base implementation of `_.unary` without support for storing metadata.
 *
 * @private
 * @param {Function} func The function to cap arguments for.
 * @returns {Function} Returns the new capped function.
 */
function baseUnary(func) {
  return function (value) {
    return func(value);
  };
}

/**
 * Checks if a `cache` value for `key` exists.
 *
 * @private
 * @param {Object} cache The cache to query.
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function cacheHas(cache, key) {
  return cache.has(key);
}

/**
 * Gets the value at `key` of `object`.
 *
 * @private
 * @param {Object} [object] The object to query.
 * @param {string} key The key of the property to get.
 * @returns {*} Returns the property value.
 */
function getValue(object, key) {
  return object == null ? undefined : object[key];
}

/**
 * Converts `map` to its key-value pairs.
 *
 * @private
 * @param {Object} map The map to convert.
 * @returns {Array} Returns the key-value pairs.
 */
function mapToArray(map) {
  var index = -1,
      result = Array(map.size);

  map.forEach(function (value, key) {
    result[++index] = [key, value];
  });
  return result;
}

/**
 * Creates a unary function that invokes `func` with its argument transformed.
 *
 * @private
 * @param {Function} func The function to wrap.
 * @param {Function} transform The argument transform.
 * @returns {Function} Returns the new function.
 */
function overArg(func, transform) {
  return function (arg) {
    return func(transform(arg));
  };
}

/**
 * Converts `set` to an array of its values.
 *
 * @private
 * @param {Object} set The set to convert.
 * @returns {Array} Returns the values.
 */
function setToArray(set) {
  var index = -1,
      result = Array(set.size);

  set.forEach(function (value) {
    result[++index] = value;
  });
  return result;
}

/** Used for built-in method references. */
var arrayProto = Array.prototype,
    funcProto = Function.prototype,
    objectProto = Object.prototype;

/** Used to detect overreaching core-js shims. */
var coreJsData = root['__core-js_shared__'];

/** Used to resolve the decompiled source of functions. */
var funcToString = funcProto.toString;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/** Used to detect methods masquerading as native. */
var maskSrcKey = function () {
  var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');
  return uid ? 'Symbol(src)_1.' + uid : '';
}();

/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */
var nativeObjectToString = objectProto.toString;

/** Used to detect if a method is native. */
var reIsNative = RegExp('^' + funcToString.call(hasOwnProperty).replace(reRegExpChar, '\\$&').replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$');

/** Built-in value references. */
var Buffer = moduleExports ? root.Buffer : undefined,
    Symbol = root.Symbol,
    Uint8Array = root.Uint8Array,
    propertyIsEnumerable = objectProto.propertyIsEnumerable,
    splice = arrayProto.splice,
    symToStringTag = Symbol ? Symbol.toStringTag : undefined;

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeGetSymbols = Object.getOwnPropertySymbols,
    nativeIsBuffer = Buffer ? Buffer.isBuffer : undefined,
    nativeKeys = overArg(Object.keys, Object);

/* Built-in method references that are verified to be native. */
var DataView = getNative(root, 'DataView'),
    Map = getNative(root, 'Map'),
    Promise = getNative(root, 'Promise'),
    Set = getNative(root, 'Set'),
    WeakMap = getNative(root, 'WeakMap'),
    nativeCreate = getNative(Object, 'create');

/** Used to detect maps, sets, and weakmaps. */
var dataViewCtorString = toSource(DataView),
    mapCtorString = toSource(Map),
    promiseCtorString = toSource(Promise),
    setCtorString = toSource(Set),
    weakMapCtorString = toSource(WeakMap);

/** Used to convert symbols to primitives and strings. */
var symbolProto = Symbol ? Symbol.prototype : undefined,
    symbolValueOf = symbolProto ? symbolProto.valueOf : undefined;

/**
 * Creates a hash object.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function Hash(entries) {
  var index = -1,
      length = entries == null ? 0 : entries.length;

  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}

/**
 * Removes all key-value entries from the hash.
 *
 * @private
 * @name clear
 * @memberOf Hash
 */
function hashClear() {
  this.__data__ = nativeCreate ? nativeCreate(null) : {};
  this.size = 0;
}

/**
 * Removes `key` and its value from the hash.
 *
 * @private
 * @name delete
 * @memberOf Hash
 * @param {Object} hash The hash to modify.
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function hashDelete(key) {
  var result = this.has(key) && delete this.__data__[key];
  this.size -= result ? 1 : 0;
  return result;
}

/**
 * Gets the hash value for `key`.
 *
 * @private
 * @name get
 * @memberOf Hash
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function hashGet(key) {
  var data = this.__data__;
  if (nativeCreate) {
    var result = data[key];
    return result === HASH_UNDEFINED ? undefined : result;
  }
  return hasOwnProperty.call(data, key) ? data[key] : undefined;
}

/**
 * Checks if a hash value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf Hash
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function hashHas(key) {
  var data = this.__data__;
  return nativeCreate ? data[key] !== undefined : hasOwnProperty.call(data, key);
}

/**
 * Sets the hash `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf Hash
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the hash instance.
 */
function hashSet(key, value) {
  var data = this.__data__;
  this.size += this.has(key) ? 0 : 1;
  data[key] = nativeCreate && value === undefined ? HASH_UNDEFINED : value;
  return this;
}

// Add methods to `Hash`.
Hash.prototype.clear = hashClear;
Hash.prototype['delete'] = hashDelete;
Hash.prototype.get = hashGet;
Hash.prototype.has = hashHas;
Hash.prototype.set = hashSet;

/**
 * Creates an list cache object.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function ListCache(entries) {
  var index = -1,
      length = entries == null ? 0 : entries.length;

  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}

/**
 * Removes all key-value entries from the list cache.
 *
 * @private
 * @name clear
 * @memberOf ListCache
 */
function listCacheClear() {
  this.__data__ = [];
  this.size = 0;
}

/**
 * Removes `key` and its value from the list cache.
 *
 * @private
 * @name delete
 * @memberOf ListCache
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function listCacheDelete(key) {
  var data = this.__data__,
      index = assocIndexOf(data, key);

  if (index < 0) {
    return false;
  }
  var lastIndex = data.length - 1;
  if (index == lastIndex) {
    data.pop();
  } else {
    splice.call(data, index, 1);
  }
  --this.size;
  return true;
}

/**
 * Gets the list cache value for `key`.
 *
 * @private
 * @name get
 * @memberOf ListCache
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function listCacheGet(key) {
  var data = this.__data__,
      index = assocIndexOf(data, key);

  return index < 0 ? undefined : data[index][1];
}

/**
 * Checks if a list cache value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf ListCache
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function listCacheHas(key) {
  return assocIndexOf(this.__data__, key) > -1;
}

/**
 * Sets the list cache `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf ListCache
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the list cache instance.
 */
function listCacheSet(key, value) {
  var data = this.__data__,
      index = assocIndexOf(data, key);

  if (index < 0) {
    ++this.size;
    data.push([key, value]);
  } else {
    data[index][1] = value;
  }
  return this;
}

// Add methods to `ListCache`.
ListCache.prototype.clear = listCacheClear;
ListCache.prototype['delete'] = listCacheDelete;
ListCache.prototype.get = listCacheGet;
ListCache.prototype.has = listCacheHas;
ListCache.prototype.set = listCacheSet;

/**
 * Creates a map cache object to store key-value pairs.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function MapCache(entries) {
  var index = -1,
      length = entries == null ? 0 : entries.length;

  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}

/**
 * Removes all key-value entries from the map.
 *
 * @private
 * @name clear
 * @memberOf MapCache
 */
function mapCacheClear() {
  this.size = 0;
  this.__data__ = {
    'hash': new Hash(),
    'map': new (Map || ListCache)(),
    'string': new Hash()
  };
}

/**
 * Removes `key` and its value from the map.
 *
 * @private
 * @name delete
 * @memberOf MapCache
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function mapCacheDelete(key) {
  var result = getMapData(this, key)['delete'](key);
  this.size -= result ? 1 : 0;
  return result;
}

/**
 * Gets the map value for `key`.
 *
 * @private
 * @name get
 * @memberOf MapCache
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function mapCacheGet(key) {
  return getMapData(this, key).get(key);
}

/**
 * Checks if a map value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf MapCache
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function mapCacheHas(key) {
  return getMapData(this, key).has(key);
}

/**
 * Sets the map `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf MapCache
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the map cache instance.
 */
function mapCacheSet(key, value) {
  var data = getMapData(this, key),
      size = data.size;

  data.set(key, value);
  this.size += data.size == size ? 0 : 1;
  return this;
}

// Add methods to `MapCache`.
MapCache.prototype.clear = mapCacheClear;
MapCache.prototype['delete'] = mapCacheDelete;
MapCache.prototype.get = mapCacheGet;
MapCache.prototype.has = mapCacheHas;
MapCache.prototype.set = mapCacheSet;

/**
 *
 * Creates an array cache object to store unique values.
 *
 * @private
 * @constructor
 * @param {Array} [values] The values to cache.
 */
function SetCache(values) {
  var index = -1,
      length = values == null ? 0 : values.length;

  this.__data__ = new MapCache();
  while (++index < length) {
    this.add(values[index]);
  }
}

/**
 * Adds `value` to the array cache.
 *
 * @private
 * @name add
 * @memberOf SetCache
 * @alias push
 * @param {*} value The value to cache.
 * @returns {Object} Returns the cache instance.
 */
function setCacheAdd(value) {
  this.__data__.set(value, HASH_UNDEFINED);
  return this;
}

/**
 * Checks if `value` is in the array cache.
 *
 * @private
 * @name has
 * @memberOf SetCache
 * @param {*} value The value to search for.
 * @returns {number} Returns `true` if `value` is found, else `false`.
 */
function setCacheHas(value) {
  return this.__data__.has(value);
}

// Add methods to `SetCache`.
SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
SetCache.prototype.has = setCacheHas;

/**
 * Creates a stack cache object to store key-value pairs.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function Stack(entries) {
  var data = this.__data__ = new ListCache(entries);
  this.size = data.size;
}

/**
 * Removes all key-value entries from the stack.
 *
 * @private
 * @name clear
 * @memberOf Stack
 */
function stackClear() {
  this.__data__ = new ListCache();
  this.size = 0;
}

/**
 * Removes `key` and its value from the stack.
 *
 * @private
 * @name delete
 * @memberOf Stack
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function stackDelete(key) {
  var data = this.__data__,
      result = data['delete'](key);

  this.size = data.size;
  return result;
}

/**
 * Gets the stack value for `key`.
 *
 * @private
 * @name get
 * @memberOf Stack
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function stackGet(key) {
  return this.__data__.get(key);
}

/**
 * Checks if a stack value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf Stack
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function stackHas(key) {
  return this.__data__.has(key);
}

/**
 * Sets the stack `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf Stack
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the stack cache instance.
 */
function stackSet(key, value) {
  var data = this.__data__;
  if (data instanceof ListCache) {
    var pairs = data.__data__;
    if (!Map || pairs.length < LARGE_ARRAY_SIZE - 1) {
      pairs.push([key, value]);
      this.size = ++data.size;
      return this;
    }
    data = this.__data__ = new MapCache(pairs);
  }
  data.set(key, value);
  this.size = data.size;
  return this;
}

// Add methods to `Stack`.
Stack.prototype.clear = stackClear;
Stack.prototype['delete'] = stackDelete;
Stack.prototype.get = stackGet;
Stack.prototype.has = stackHas;
Stack.prototype.set = stackSet;

/**
 * Creates an array of the enumerable property names of the array-like `value`.
 *
 * @private
 * @param {*} value The value to query.
 * @param {boolean} inherited Specify returning inherited property names.
 * @returns {Array} Returns the array of property names.
 */
function arrayLikeKeys(value, inherited) {
  var isArr = isArray(value),
      isArg = !isArr && isArguments(value),
      isBuff = !isArr && !isArg && isBuffer(value),
      isType = !isArr && !isArg && !isBuff && isTypedArray(value),
      skipIndexes = isArr || isArg || isBuff || isType,
      result = skipIndexes ? baseTimes(value.length, String) : [],
      length = result.length;

  for (var key in value) {
    if ((inherited || hasOwnProperty.call(value, key)) && !(skipIndexes && (
    // Safari 9 has enumerable `arguments.length` in strict mode.
    key == 'length' ||
    // Node.js 0.10 has enumerable non-index properties on buffers.
    isBuff && (key == 'offset' || key == 'parent') ||
    // PhantomJS 2 has enumerable non-index properties on typed arrays.
    isType && (key == 'buffer' || key == 'byteLength' || key == 'byteOffset') ||
    // Skip index properties.
    isIndex(key, length)))) {
      result.push(key);
    }
  }
  return result;
}

/**
 * Gets the index at which the `key` is found in `array` of key-value pairs.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {*} key The key to search for.
 * @returns {number} Returns the index of the matched value, else `-1`.
 */
function assocIndexOf(array, key) {
  var length = array.length;
  while (length--) {
    if (eq(array[length][0], key)) {
      return length;
    }
  }
  return -1;
}

/**
 * The base implementation of `getAllKeys` and `getAllKeysIn` which uses
 * `keysFunc` and `symbolsFunc` to get the enumerable property names and
 * symbols of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {Function} keysFunc The function to get the keys of `object`.
 * @param {Function} symbolsFunc The function to get the symbols of `object`.
 * @returns {Array} Returns the array of property names and symbols.
 */
function baseGetAllKeys(object, keysFunc, symbolsFunc) {
  var result = keysFunc(object);
  return isArray(object) ? result : arrayPush(result, symbolsFunc(object));
}

/**
 * The base implementation of `getTag` without fallbacks for buggy environments.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the `toStringTag`.
 */
function baseGetTag(value) {
  if (value == null) {
    return value === undefined ? undefinedTag : nullTag;
  }
  return symToStringTag && symToStringTag in Object(value) ? getRawTag(value) : objectToString(value);
}

/**
 * The base implementation of `_.isArguments`.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an `arguments` object,
 */
function baseIsArguments(value) {
  return isObjectLike(value) && baseGetTag(value) == argsTag;
}

/**
 * The base implementation of `_.isEqual` which supports partial comparisons
 * and tracks traversed objects.
 *
 * @private
 * @param {*} value The value to compare.
 * @param {*} other The other value to compare.
 * @param {boolean} bitmask The bitmask flags.
 *  1 - Unordered comparison
 *  2 - Partial comparison
 * @param {Function} [customizer] The function to customize comparisons.
 * @param {Object} [stack] Tracks traversed `value` and `other` objects.
 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
 */
function baseIsEqual(value, other, bitmask, customizer, stack) {
  if (value === other) {
    return true;
  }
  if (value == null || other == null || !isObjectLike(value) && !isObjectLike(other)) {
    return value !== value && other !== other;
  }
  return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack);
}

/**
 * A specialized version of `baseIsEqual` for arrays and objects which performs
 * deep comparisons and tracks traversed objects enabling objects with circular
 * references to be compared.
 *
 * @private
 * @param {Object} object The object to compare.
 * @param {Object} other The other object to compare.
 * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
 * @param {Function} customizer The function to customize comparisons.
 * @param {Function} equalFunc The function to determine equivalents of values.
 * @param {Object} [stack] Tracks traversed `object` and `other` objects.
 * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
 */
function baseIsEqualDeep(object, other, bitmask, customizer, equalFunc, stack) {
  var objIsArr = isArray(object),
      othIsArr = isArray(other),
      objTag = objIsArr ? arrayTag : getTag(object),
      othTag = othIsArr ? arrayTag : getTag(other);

  objTag = objTag == argsTag ? objectTag : objTag;
  othTag = othTag == argsTag ? objectTag : othTag;

  var objIsObj = objTag == objectTag,
      othIsObj = othTag == objectTag,
      isSameTag = objTag == othTag;

  if (isSameTag && isBuffer(object)) {
    if (!isBuffer(other)) {
      return false;
    }
    objIsArr = true;
    objIsObj = false;
  }
  if (isSameTag && !objIsObj) {
    stack || (stack = new Stack());
    return objIsArr || isTypedArray(object) ? equalArrays(object, other, bitmask, customizer, equalFunc, stack) : equalByTag(object, other, objTag, bitmask, customizer, equalFunc, stack);
  }
  if (!(bitmask & COMPARE_PARTIAL_FLAG)) {
    var objIsWrapped = objIsObj && hasOwnProperty.call(object, '__wrapped__'),
        othIsWrapped = othIsObj && hasOwnProperty.call(other, '__wrapped__');

    if (objIsWrapped || othIsWrapped) {
      var objUnwrapped = objIsWrapped ? object.value() : object,
          othUnwrapped = othIsWrapped ? other.value() : other;

      stack || (stack = new Stack());
      return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);
    }
  }
  if (!isSameTag) {
    return false;
  }
  stack || (stack = new Stack());
  return equalObjects(object, other, bitmask, customizer, equalFunc, stack);
}

/**
 * The base implementation of `_.isNative` without bad shim checks.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a native function,
 *  else `false`.
 */
function baseIsNative(value) {
  if (!isObject(value) || isMasked(value)) {
    return false;
  }
  var pattern = isFunction(value) ? reIsNative : reIsHostCtor;
  return pattern.test(toSource(value));
}

/**
 * The base implementation of `_.isTypedArray` without Node.js optimizations.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
 */
function baseIsTypedArray(value) {
  return isObjectLike(value) && isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
}

/**
 * The base implementation of `_.keys` which doesn't treat sparse arrays as dense.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 */
function baseKeys(object) {
  if (!isPrototype(object)) {
    return nativeKeys(object);
  }
  var result = [];
  for (var key in Object(object)) {
    if (hasOwnProperty.call(object, key) && key != 'constructor') {
      result.push(key);
    }
  }
  return result;
}

/**
 * A specialized version of `baseIsEqualDeep` for arrays with support for
 * partial deep comparisons.
 *
 * @private
 * @param {Array} array The array to compare.
 * @param {Array} other The other array to compare.
 * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
 * @param {Function} customizer The function to customize comparisons.
 * @param {Function} equalFunc The function to determine equivalents of values.
 * @param {Object} stack Tracks traversed `array` and `other` objects.
 * @returns {boolean} Returns `true` if the arrays are equivalent, else `false`.
 */
function equalArrays(array, other, bitmask, customizer, equalFunc, stack) {
  var isPartial = bitmask & COMPARE_PARTIAL_FLAG,
      arrLength = array.length,
      othLength = other.length;

  if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
    return false;
  }
  // Assume cyclic values are equal.
  var stacked = stack.get(array);
  if (stacked && stack.get(other)) {
    return stacked == other;
  }
  var index = -1,
      result = true,
      seen = bitmask & COMPARE_UNORDERED_FLAG ? new SetCache() : undefined;

  stack.set(array, other);
  stack.set(other, array);

  // Ignore non-index properties.
  while (++index < arrLength) {
    var arrValue = array[index],
        othValue = other[index];

    if (customizer) {
      var compared = isPartial ? customizer(othValue, arrValue, index, other, array, stack) : customizer(arrValue, othValue, index, array, other, stack);
    }
    if (compared !== undefined) {
      if (compared) {
        continue;
      }
      result = false;
      break;
    }
    // Recursively compare arrays (susceptible to call stack limits).
    if (seen) {
      if (!arraySome(other, function (othValue, othIndex) {
        if (!cacheHas(seen, othIndex) && (arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
          return seen.push(othIndex);
        }
      })) {
        result = false;
        break;
      }
    } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
      result = false;
      break;
    }
  }
  stack['delete'](array);
  stack['delete'](other);
  return result;
}

/**
 * A specialized version of `baseIsEqualDeep` for comparing objects of
 * the same `toStringTag`.
 *
 * **Note:** This function only supports comparing values with tags of
 * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.
 *
 * @private
 * @param {Object} object The object to compare.
 * @param {Object} other The other object to compare.
 * @param {string} tag The `toStringTag` of the objects to compare.
 * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
 * @param {Function} customizer The function to customize comparisons.
 * @param {Function} equalFunc The function to determine equivalents of values.
 * @param {Object} stack Tracks traversed `object` and `other` objects.
 * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
 */
function equalByTag(object, other, tag, bitmask, customizer, equalFunc, stack) {
  switch (tag) {
    case dataViewTag:
      if (object.byteLength != other.byteLength || object.byteOffset != other.byteOffset) {
        return false;
      }
      object = object.buffer;
      other = other.buffer;

    case arrayBufferTag:
      if (object.byteLength != other.byteLength || !equalFunc(new Uint8Array(object), new Uint8Array(other))) {
        return false;
      }
      return true;

    case boolTag:
    case dateTag:
    case numberTag:
      // Coerce booleans to `1` or `0` and dates to milliseconds.
      // Invalid dates are coerced to `NaN`.
      return eq(+object, +other);

    case errorTag:
      return object.name == other.name && object.message == other.message;

    case regexpTag:
    case stringTag:
      // Coerce regexes to strings and treat strings, primitives and objects,
      // as equal. See http://www.ecma-international.org/ecma-262/7.0/#sec-regexp.prototype.tostring
      // for more details.
      return object == other + '';

    case mapTag:
      var convert = mapToArray;

    case setTag:
      var isPartial = bitmask & COMPARE_PARTIAL_FLAG;
      convert || (convert = setToArray);

      if (object.size != other.size && !isPartial) {
        return false;
      }
      // Assume cyclic values are equal.
      var stacked = stack.get(object);
      if (stacked) {
        return stacked == other;
      }
      bitmask |= COMPARE_UNORDERED_FLAG;

      // Recursively compare objects (susceptible to call stack limits).
      stack.set(object, other);
      var result = equalArrays(convert(object), convert(other), bitmask, customizer, equalFunc, stack);
      stack['delete'](object);
      return result;

    case symbolTag:
      if (symbolValueOf) {
        return symbolValueOf.call(object) == symbolValueOf.call(other);
      }
  }
  return false;
}

/**
 * A specialized version of `baseIsEqualDeep` for objects with support for
 * partial deep comparisons.
 *
 * @private
 * @param {Object} object The object to compare.
 * @param {Object} other The other object to compare.
 * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
 * @param {Function} customizer The function to customize comparisons.
 * @param {Function} equalFunc The function to determine equivalents of values.
 * @param {Object} stack Tracks traversed `object` and `other` objects.
 * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
 */
function equalObjects(object, other, bitmask, customizer, equalFunc, stack) {
  var isPartial = bitmask & COMPARE_PARTIAL_FLAG,
      objProps = getAllKeys(object),
      objLength = objProps.length,
      othProps = getAllKeys(other),
      othLength = othProps.length;

  if (objLength != othLength && !isPartial) {
    return false;
  }
  var index = objLength;
  while (index--) {
    var key = objProps[index];
    if (!(isPartial ? key in other : hasOwnProperty.call(other, key))) {
      return false;
    }
  }
  // Assume cyclic values are equal.
  var stacked = stack.get(object);
  if (stacked && stack.get(other)) {
    return stacked == other;
  }
  var result = true;
  stack.set(object, other);
  stack.set(other, object);

  var skipCtor = isPartial;
  while (++index < objLength) {
    key = objProps[index];
    var objValue = object[key],
        othValue = other[key];

    if (customizer) {
      var compared = isPartial ? customizer(othValue, objValue, key, other, object, stack) : customizer(objValue, othValue, key, object, other, stack);
    }
    // Recursively compare objects (susceptible to call stack limits).
    if (!(compared === undefined ? objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack) : compared)) {
      result = false;
      break;
    }
    skipCtor || (skipCtor = key == 'constructor');
  }
  if (result && !skipCtor) {
    var objCtor = object.constructor,
        othCtor = other.constructor;

    // Non `Object` object instances with different constructors are not equal.
    if (objCtor != othCtor && 'constructor' in object && 'constructor' in other && !(typeof objCtor == 'function' && objCtor instanceof objCtor && typeof othCtor == 'function' && othCtor instanceof othCtor)) {
      result = false;
    }
  }
  stack['delete'](object);
  stack['delete'](other);
  return result;
}

/**
 * Creates an array of own enumerable property names and symbols of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names and symbols.
 */
function getAllKeys(object) {
  return baseGetAllKeys(object, keys, getSymbols);
}

/**
 * Gets the data for `map`.
 *
 * @private
 * @param {Object} map The map to query.
 * @param {string} key The reference key.
 * @returns {*} Returns the map data.
 */
function getMapData(map, key) {
  var data = map.__data__;
  return isKeyable(key) ? data[typeof key == 'string' ? 'string' : 'hash'] : data.map;
}

/**
 * Gets the native function at `key` of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {string} key The key of the method to get.
 * @returns {*} Returns the function if it's native, else `undefined`.
 */
function getNative(object, key) {
  var value = getValue(object, key);
  return baseIsNative(value) ? value : undefined;
}

/**
 * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the raw `toStringTag`.
 */
function getRawTag(value) {
  var isOwn = hasOwnProperty.call(value, symToStringTag),
      tag = value[symToStringTag];

  try {
    value[symToStringTag] = undefined;
    var unmasked = true;
  } catch (e) {}

  var result = nativeObjectToString.call(value);
  if (unmasked) {
    if (isOwn) {
      value[symToStringTag] = tag;
    } else {
      delete value[symToStringTag];
    }
  }
  return result;
}

/**
 * Creates an array of the own enumerable symbols of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of symbols.
 */
var getSymbols = !nativeGetSymbols ? stubArray : function (object) {
  if (object == null) {
    return [];
  }
  object = Object(object);
  return arrayFilter(nativeGetSymbols(object), function (symbol) {
    return propertyIsEnumerable.call(object, symbol);
  });
};

/**
 * Gets the `toStringTag` of `value`.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the `toStringTag`.
 */
var getTag = baseGetTag;

// Fallback for data views, maps, sets, and weak maps in IE 11 and promises in Node.js < 6.
if (DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag || Map && getTag(new Map()) != mapTag || Promise && getTag(Promise.resolve()) != promiseTag || Set && getTag(new Set()) != setTag || WeakMap && getTag(new WeakMap()) != weakMapTag) {
  getTag = function (value) {
    var result = baseGetTag(value),
        Ctor = result == objectTag ? value.constructor : undefined,
        ctorString = Ctor ? toSource(Ctor) : '';

    if (ctorString) {
      switch (ctorString) {
        case dataViewCtorString:
          return dataViewTag;
        case mapCtorString:
          return mapTag;
        case promiseCtorString:
          return promiseTag;
        case setCtorString:
          return setTag;
        case weakMapCtorString:
          return weakMapTag;
      }
    }
    return result;
  };
}

/**
 * Checks if `value` is a valid array-like index.
 *
 * @private
 * @param {*} value The value to check.
 * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
 * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
 */
function isIndex(value, length) {
  length = length == null ? MAX_SAFE_INTEGER : length;
  return !!length && (typeof value == 'number' || reIsUint.test(value)) && value > -1 && value % 1 == 0 && value < length;
}

/**
 * Checks if `value` is suitable for use as unique object key.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is suitable, else `false`.
 */
function isKeyable(value) {
  var type = typeof value;
  return type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean' ? value !== '__proto__' : value === null;
}

/**
 * Checks if `func` has its source masked.
 *
 * @private
 * @param {Function} func The function to check.
 * @returns {boolean} Returns `true` if `func` is masked, else `false`.
 */
function isMasked(func) {
  return !!maskSrcKey && maskSrcKey in func;
}

/**
 * Checks if `value` is likely a prototype object.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.
 */
function isPrototype(value) {
  var Ctor = value && value.constructor,
      proto = typeof Ctor == 'function' && Ctor.prototype || objectProto;

  return value === proto;
}

/**
 * Converts `value` to a string using `Object.prototype.toString`.
 *
 * @private
 * @param {*} value The value to convert.
 * @returns {string} Returns the converted string.
 */
function objectToString(value) {
  return nativeObjectToString.call(value);
}

/**
 * Converts `func` to its source code.
 *
 * @private
 * @param {Function} func The function to convert.
 * @returns {string} Returns the source code.
 */
function toSource(func) {
  if (func != null) {
    try {
      return funcToString.call(func);
    } catch (e) {}
    try {
      return func + '';
    } catch (e) {}
  }
  return '';
}

/**
 * Performs a
 * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * comparison between two values to determine if they are equivalent.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to compare.
 * @param {*} other The other value to compare.
 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
 * @example
 *
 * var object = { 'a': 1 };
 * var other = { 'a': 1 };
 *
 * _.eq(object, object);
 * // => true
 *
 * _.eq(object, other);
 * // => false
 *
 * _.eq('a', 'a');
 * // => true
 *
 * _.eq('a', Object('a'));
 * // => false
 *
 * _.eq(NaN, NaN);
 * // => true
 */
function eq(value, other) {
  return value === other || value !== value && other !== other;
}

/**
 * Checks if `value` is likely an `arguments` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an `arguments` object,
 *  else `false`.
 * @example
 *
 * _.isArguments(function() { return arguments; }());
 * // => true
 *
 * _.isArguments([1, 2, 3]);
 * // => false
 */
var isArguments = baseIsArguments(function () {
  return arguments;
}()) ? baseIsArguments : function (value) {
  return isObjectLike(value) && hasOwnProperty.call(value, 'callee') && !propertyIsEnumerable.call(value, 'callee');
};

/**
 * Checks if `value` is classified as an `Array` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an array, else `false`.
 * @example
 *
 * _.isArray([1, 2, 3]);
 * // => true
 *
 * _.isArray(document.body.children);
 * // => false
 *
 * _.isArray('abc');
 * // => false
 *
 * _.isArray(_.noop);
 * // => false
 */
var isArray = Array.isArray;

/**
 * Checks if `value` is array-like. A value is considered array-like if it's
 * not a function and has a `value.length` that's an integer greater than or
 * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
 * @example
 *
 * _.isArrayLike([1, 2, 3]);
 * // => true
 *
 * _.isArrayLike(document.body.children);
 * // => true
 *
 * _.isArrayLike('abc');
 * // => true
 *
 * _.isArrayLike(_.noop);
 * // => false
 */
function isArrayLike(value) {
  return value != null && isLength(value.length) && !isFunction(value);
}

/**
 * Checks if `value` is a buffer.
 *
 * @static
 * @memberOf _
 * @since 4.3.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a buffer, else `false`.
 * @example
 *
 * _.isBuffer(new Buffer(2));
 * // => true
 *
 * _.isBuffer(new Uint8Array(2));
 * // => false
 */
var isBuffer = nativeIsBuffer || stubFalse;

/**
 * Performs a deep comparison between two values to determine if they are
 * equivalent.
 *
 * **Note:** This method supports comparing arrays, array buffers, booleans,
 * date objects, error objects, maps, numbers, `Object` objects, regexes,
 * sets, strings, symbols, and typed arrays. `Object` objects are compared
 * by their own, not inherited, enumerable properties. Functions and DOM
 * nodes are compared by strict equality, i.e. `===`.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to compare.
 * @param {*} other The other value to compare.
 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
 * @example
 *
 * var object = { 'a': 1 };
 * var other = { 'a': 1 };
 *
 * _.isEqual(object, other);
 * // => true
 *
 * object === other;
 * // => false
 */
function isEqual(value, other) {
  return baseIsEqual(value, other);
}

/**
 * Checks if `value` is classified as a `Function` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a function, else `false`.
 * @example
 *
 * _.isFunction(_);
 * // => true
 *
 * _.isFunction(/abc/);
 * // => false
 */
function isFunction(value) {
  if (!isObject(value)) {
    return false;
  }
  // The use of `Object#toString` avoids issues with the `typeof` operator
  // in Safari 9 which returns 'object' for typed arrays and other constructors.
  var tag = baseGetTag(value);
  return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
}

/**
 * Checks if `value` is a valid array-like length.
 *
 * **Note:** This method is loosely based on
 * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
 * @example
 *
 * _.isLength(3);
 * // => true
 *
 * _.isLength(Number.MIN_VALUE);
 * // => false
 *
 * _.isLength(Infinity);
 * // => false
 *
 * _.isLength('3');
 * // => false
 */
function isLength(value) {
  return typeof value == 'number' && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
}

/**
 * Checks if `value` is the
 * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
 * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
 * @example
 *
 * _.isObject({});
 * // => true
 *
 * _.isObject([1, 2, 3]);
 * // => true
 *
 * _.isObject(_.noop);
 * // => true
 *
 * _.isObject(null);
 * // => false
 */
function isObject(value) {
  var type = typeof value;
  return value != null && (type == 'object' || type == 'function');
}

/**
 * Checks if `value` is object-like. A value is object-like if it's not `null`
 * and has a `typeof` result of "object".
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
 * @example
 *
 * _.isObjectLike({});
 * // => true
 *
 * _.isObjectLike([1, 2, 3]);
 * // => true
 *
 * _.isObjectLike(_.noop);
 * // => false
 *
 * _.isObjectLike(null);
 * // => false
 */
function isObjectLike(value) {
  return value != null && typeof value == 'object';
}

/**
 * Checks if `value` is classified as a typed array.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
 * @example
 *
 * _.isTypedArray(new Uint8Array);
 * // => true
 *
 * _.isTypedArray([]);
 * // => false
 */
var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;

/**
 * Creates an array of the own enumerable property names of `object`.
 *
 * **Note:** Non-object values are coerced to objects. See the
 * [ES spec](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
 * for more details.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Object
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 *   this.b = 2;
 * }
 *
 * Foo.prototype.c = 3;
 *
 * _.keys(new Foo);
 * // => ['a', 'b'] (iteration order is not guaranteed)
 *
 * _.keys('hi');
 * // => ['0', '1']
 */
function keys(object) {
  return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
}

/**
 * This method returns a new empty array.
 *
 * @static
 * @memberOf _
 * @since 4.13.0
 * @category Util
 * @returns {Array} Returns the new empty array.
 * @example
 *
 * var arrays = _.times(2, _.stubArray);
 *
 * console.log(arrays);
 * // => [[], []]
 *
 * console.log(arrays[0] === arrays[1]);
 * // => false
 */
function stubArray() {
  return [];
}

/**
 * This method returns `false`.
 *
 * @static
 * @memberOf _
 * @since 4.13.0
 * @category Util
 * @returns {boolean} Returns `false`.
 * @example
 *
 * _.times(2, _.stubFalse);
 * // => [false, false]
 */
function stubFalse() {
  return false;
}

module.exports = isEqual;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(177)(module)))

/***/ }),
/* 177 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = function (module) {
	if (!module.webpackPolyfill) {
		module.deprecate = function () {};
		module.paths = [];
		// module.parent = undefined by default
		if (!module.children) module.children = [];
		Object.defineProperty(module, "loaded", {
			enumerable: true,
			get: function () {
				return module.l;
			}
		});
		Object.defineProperty(module, "id", {
			enumerable: true,
			get: function () {
				return module.i;
			}
		});
		module.webpackPolyfill = 1;
	}
	return module;
};

/***/ }),
/* 178 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.executeTasks = executeTasks;
exports._executeTasks = _executeTasks;
exports.checkIsRangesSupported = checkIsRangesSupported;

var _builderUtilRuntime;

function _load_builderUtilRuntime() {
    return _builderUtilRuntime = __webpack_require__(3);
}

var _DataSplitter;

function _load_DataSplitter() {
    return _DataSplitter = __webpack_require__(66);
}

var _downloadPlanBuilder;

function _load_downloadPlanBuilder() {
    return _downloadPlanBuilder = __webpack_require__(35);
}

function executeTasks(differentialDownloader, tasks, out, oldFileFd, reject) {
    const w = taskOffset => {
        if (taskOffset >= tasks.length) {
            if (differentialDownloader.fileMetadataBuffer != null) {
                out.write(differentialDownloader.fileMetadataBuffer);
            }
            out.end();
            return;
        }
        const nextOffset = taskOffset + (differentialDownloader.options.useMultipleRangeRequest === false ? 1 : 1000);
        _executeTasks(differentialDownloader, {
            tasks,
            start: taskOffset,
            end: Math.min(tasks.length, nextOffset),
            oldFileFd
        }, out, () => w(nextOffset), reject);
    };
    return w;
}
function _executeTasks(differentialDownloader, options, out, resolve, reject) {
    let ranges = "bytes=";
    let partCount = 0;
    const partIndexToTaskIndex = new Map();
    const partIndexToLength = [];
    for (let i = options.start; i < options.end; i++) {
        const task = options.tasks[i];
        if (task.kind === (_downloadPlanBuilder || _load_downloadPlanBuilder()).OperationKind.DOWNLOAD) {
            ranges += `${task.start}-${task.end - 1}, `;
            partIndexToTaskIndex.set(partCount, i);
            partCount++;
            partIndexToLength.push(task.end - task.start);
        }
    }
    if (partCount <= 1) {
        // the only remote range - copy
        const w = index => {
            if (index >= options.end) {
                resolve();
                return;
            }
            const task = options.tasks[index++];
            if (task.kind === (_downloadPlanBuilder || _load_downloadPlanBuilder()).OperationKind.COPY) {
                (0, (_DataSplitter || _load_DataSplitter()).copyData)(task, out, options.oldFileFd, reject, () => w(index));
            } else {
                const requestOptions = differentialDownloader.createRequestOptions("get");
                requestOptions.headers.Range = `bytes=${task.start}-${task.end - 1}`;
                const request = differentialDownloader.httpExecutor.doRequest(requestOptions, response => {
                    if (!checkIsRangesSupported(response, reject)) {
                        return;
                    }
                    response.pipe(out, {
                        end: false
                    });
                    response.once("end", () => w(index));
                });
                differentialDownloader.httpExecutor.addErrorAndTimeoutHandlers(request, reject);
                request.end();
            }
        };
        w(options.start);
        return;
    }
    const requestOptions = differentialDownloader.createRequestOptions("get");
    requestOptions.headers.Range = ranges.substring(0, ranges.length - 2);
    const request = differentialDownloader.httpExecutor.doRequest(requestOptions, response => {
        if (!checkIsRangesSupported(response, reject)) {
            return;
        }
        const contentType = (0, (_builderUtilRuntime || _load_builderUtilRuntime()).safeGetHeader)(response, "content-type");
        const m = /^multipart\/.+?(?:; boundary=(?:(?:"(.+)")|(?:([^\s]+))))$/i.exec(contentType);
        if (m == null) {
            reject(new Error(`Content-Type "multipart/byteranges" is expected, but got "${contentType}"`));
            return;
        }
        const dicer = new (_DataSplitter || _load_DataSplitter()).DataSplitter(out, options, partIndexToTaskIndex, m[1] || m[2], partIndexToLength, resolve);
        dicer.on("error", reject);
        response.pipe(dicer);
    });
    differentialDownloader.httpExecutor.addErrorAndTimeoutHandlers(request, reject);
    request.end();
}
function checkIsRangesSupported(response, reject) {
    // Electron net handles redirects automatically, our NodeJS test server doesn't use redirects - so, we don't check 3xx codes.
    if (response.statusCode >= 400) {
        reject((0, (_builderUtilRuntime || _load_builderUtilRuntime()).createHttpError)(response));
        return false;
    }
    if (response.statusCode !== 206) {
        const acceptRanges = (0, (_builderUtilRuntime || _load_builderUtilRuntime()).safeGetHeader)(response, "accept-ranges");
        if (acceptRanges == null || acceptRanges === "none") {
            reject(new Error("Server doesn't support Accept-Ranges"));
            return false;
        }
    }
    return true;
}
//# sourceMappingURL=multipleRangeDownloader.js.map

/***/ }),
/* 179 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.GenericDifferentialDownloader = undefined;

var _bluebirdLst;

function _load_bluebirdLst() {
    return _bluebirdLst = __webpack_require__(2);
}

var _blockMapApi;

function _load_blockMapApi() {
    return _blockMapApi = __webpack_require__(63);
}

var _fsExtraP;

function _load_fsExtraP() {
    return _fsExtraP = __webpack_require__(9);
}

var _path = _interopRequireWildcard(__webpack_require__(0));

var _DifferentialDownloader;

function _load_DifferentialDownloader() {
    return _DifferentialDownloader = __webpack_require__(65);
}

function _interopRequireWildcard(obj) {
    if (obj && obj.__esModule) {
        return obj;
    } else {
        var newObj = {};if (obj != null) {
            for (var key in obj) {
                if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key];
            }
        }newObj.default = obj;return newObj;
    }
}

class GenericDifferentialDownloader extends (_DifferentialDownloader || _load_DifferentialDownloader()).DifferentialDownloader {
    download(newBlockMap) {
        var _this = this;

        return (0, (_bluebirdLst || _load_bluebirdLst()).coroutine)(function* () {
            yield _this.doDownload((yield (0, (_fsExtraP || _load_fsExtraP()).readJson)(_path.join(process.resourcesPath, "..", (_blockMapApi || _load_blockMapApi()).BLOCK_MAP_FILE_NAME))), newBlockMap);
        })();
    }
}
exports.GenericDifferentialDownloader = GenericDifferentialDownloader; //# sourceMappingURL=GenericDifferentialDownloader.js.map

/***/ }),
/* 180 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.verifySignature = verifySignature;

var _bluebirdLst;

function _load_bluebirdLst() {
    return _bluebirdLst = _interopRequireDefault(__webpack_require__(2));
}

var _builderUtilRuntime;

function _load_builderUtilRuntime() {
    return _builderUtilRuntime = __webpack_require__(3);
}

var _child_process;

function _load_child_process() {
    return _child_process = __webpack_require__(34);
}

var _os;

function _load_os() {
    return _os = _interopRequireWildcard(__webpack_require__(15));
}

function _interopRequireWildcard(obj) {
    if (obj && obj.__esModule) {
        return obj;
    } else {
        var newObj = {};if (obj != null) {
            for (var key in obj) {
                if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key];
            }
        }newObj.default = obj;return newObj;
    }
}

function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
}

// $certificateInfo = (Get-AuthenticodeSignature 'xxx\yyy.exe'
// | where {$_.Status.Equals([System.Management.Automation.SignatureStatus]::Valid) -and $_.SignerCertificate.Subject.Contains("CN=siemens.com")})
// | Out-String ; if ($certificateInfo) { exit 0 } else { exit 1 }
function verifySignature(publisherNames, tempUpdateFile, logger) {
    return new (_bluebirdLst || _load_bluebirdLst()).default((resolve, reject) => {
        // https://github.com/electron-userland/electron-builder/issues/2421
        (0, (_child_process || _load_child_process()).execFile)("powershell.exe", [`Get-AuthenticodeSignature '${tempUpdateFile}' | ConvertTo-Json -Compress`], {
            timeout: 30 * 1000
        }, (error, stdout, stderr) => {
            if (error != null || stderr) {
                if (isOldWin6()) {
                    logger.warn(`Cannot execute Get-AuthenticodeSignature: ${error || stderr}. Ignoring signature validation due to unsupported powershell version. Please upgrade to powershell 3 or higher.`);
                    resolve(null);
                    return;
                }
                try {
                    (0, (_child_process || _load_child_process()).execFileSync)("powershell.exe", ["ConvertTo-Json test"], { timeout: 10 * 1000 });
                } catch (testError) {
                    logger.warn(`Cannot execute ConvertTo-Json: ${testError.message}. Ignoring signature validation due to unsupported powershell version. Please upgrade to powershell 3 or higher.`);
                    resolve(null);
                    return;
                }
                if (error != null) {
                    reject(error);
                    return;
                }
                if (stderr) {
                    reject(new Error(`Cannot execute Get-AuthenticodeSignature: ${stderr}`));
                    return;
                }
            }
            const data = JSON.parse(stdout);
            delete data.PrivateKey;
            delete data.IsOSBinary;
            delete data.SignatureType;
            const signerCertificate = data.SignerCertificate;
            if (signerCertificate != null) {
                delete signerCertificate.Archived;
                delete signerCertificate.Extensions;
                delete signerCertificate.Handle;
                delete signerCertificate.HasPrivateKey;
                // duplicates data.SignerCertificate (contains RawData)
                delete signerCertificate.SubjectName;
            }
            delete data.Path;
            if (data.Status === 0) {
                const name = (0, (_builderUtilRuntime || _load_builderUtilRuntime()).parseDn)(data.SignerCertificate.Subject).get("CN");
                if (publisherNames.includes(name)) {
                    resolve(null);
                    return;
                }
            }
            const result = `publisherNames: ${publisherNames.join(" | ")}, raw info: ` + JSON.stringify(data, (name, value) => name === "RawData" ? undefined : value, 2);
            logger.info(`Sign verification failed, installer signed with incorrect certificate: ${result}`);
            resolve(result);
        });
    });
}
function isOldWin6() {
    const winVersion = (_os || _load_os()).release();
    return winVersion.startsWith("6.") && !winVersion.startsWith("6.3");
}
//# sourceMappingURL=windowsExecutableCodeSignatureVerifier.js.map

/***/ }),
/* 181 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.MacUpdater = undefined;

var _bluebirdLst;

function _load_bluebirdLst() {
    return _bluebirdLst = __webpack_require__(2);
}

var _bluebirdLst2;

function _load_bluebirdLst2() {
    return _bluebirdLst2 = _interopRequireDefault(__webpack_require__(2));
}

var _builderUtilRuntime;

function _load_builderUtilRuntime() {
    return _builderUtilRuntime = __webpack_require__(3);
}

var _http;

function _load_http() {
    return _http = __webpack_require__(67);
}

var _AppUpdater;

function _load_AppUpdater() {
    return _AppUpdater = __webpack_require__(27);
}

var _main;

function _load_main() {
    return _main = __webpack_require__(8);
}

var _Provider;

function _load_Provider() {
    return _Provider = __webpack_require__(14);
}

function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
}

class MacUpdater extends (_AppUpdater || _load_AppUpdater()).AppUpdater {
    constructor(options) {
        super(options);
        this.nativeUpdater = __webpack_require__(10).autoUpdater;
        this.nativeUpdater.on("error", it => {
            this._logger.warn(it);
            this.emit("error", it);
        });
        this.nativeUpdater.on("update-downloaded", () => {
            this._logger.info(`New version ${this.updateInfo.version} has been downloaded`);
            this.emit((_main || _load_main()).UPDATE_DOWNLOADED, this.updateInfo);
        });
    }
    doDownloadUpdate(updateInfo, cancellationToken) {
        var _this = this;

        return (0, (_bluebirdLst || _load_bluebirdLst()).coroutine)(function* () {
            const files = (yield _this.provider).resolveFiles(updateInfo);
            const zipFileInfo = (0, (_Provider || _load_Provider()).findFile)(files, "zip", ["pkg", "dmg"]);
            if (zipFileInfo == null) {
                throw (0, (_builderUtilRuntime || _load_builderUtilRuntime()).newError)(`ZIP file not provided: ${(0, (_builderUtilRuntime || _load_builderUtilRuntime()).safeStringifyJson)(files)}`, "ERR_UPDATER_ZIP_FILE_NOT_FOUND");
            }
            const server = (0, (_http || _load_http()).createServer)();
            server.on("close", function () {
                _this._logger.info(`Proxy server for native Squirrel.Mac is closed (was started to download ${zipFileInfo.url.href})`);
            });
            function getServerUrl() {
                const address = server.address();
                return `http://${address.address}:${address.port}`;
            }
            const requestHeaders = yield _this.computeRequestHeaders();
            return yield new (_bluebirdLst2 || _load_bluebirdLst2()).default(function (resolve, reject) {
                server.on("request", function (request, response) {
                    const requestUrl = request.url;
                    _this._logger.info(`${requestUrl} requested`);
                    if (requestUrl === "/") {
                        const data = Buffer.from(`{ "url": "${getServerUrl()}/app.zip" }`);
                        response.writeHead(200, { "Content-Type": "application/json", "Content-Length": data.length });
                        response.end(data);
                    } else if (requestUrl.startsWith("/app.zip")) {
                        let errorOccurred = false;
                        response.on("finish", function () {
                            try {
                                setImmediate(function () {
                                    return server.close();
                                });
                            } finally {
                                if (!errorOccurred) {
                                    _this.nativeUpdater.removeListener("error", reject);
                                    resolve([]);
                                }
                            }
                        });
                        _this.doProxyUpdateFile(response, zipFileInfo.url.href, requestHeaders, zipFileInfo.info.sha512, cancellationToken, function (error) {
                            errorOccurred = true;
                            try {
                                response.writeHead(500);
                                response.end();
                            } finally {
                                _this.nativeUpdater.removeListener("error", reject);
                                reject(new Error(`Cannot download "${zipFileInfo.url}": ${error}`));
                            }
                        });
                    } else {
                        _this._logger.warn(`${requestUrl} requested, but not supported`);
                        response.writeHead(404);
                        response.end();
                    }
                });
                server.listen(0, "127.0.0.1", 16, function () {
                    _this.nativeUpdater.setFeedURL(`${getServerUrl()}`, { "Cache-Control": "no-cache" });
                    _this.nativeUpdater.once("error", reject);
                    _this.nativeUpdater.checkForUpdates();
                });
            });
        })();
    }
    doProxyUpdateFile(nativeResponse, url, headers, sha512, cancellationToken, errorHandler) {
        const downloadRequest = this.httpExecutor.doRequest((0, (_builderUtilRuntime || _load_builderUtilRuntime()).configureRequestOptionsFromUrl)(url, { headers }), downloadResponse => {
            if (downloadResponse.statusCode >= 400) {
                try {
                    nativeResponse.writeHead(404);
                    nativeResponse.end();
                } finally {
                    errorHandler(new Error(`Cannot download "${url}", status ${downloadResponse.statusCode}: ${downloadResponse.statusMessage}`));
                }
                return;
            }
            // in tests Electron NET Api is not used, so, we have to handle redirect.
            const redirectUrl = (0, (_builderUtilRuntime || _load_builderUtilRuntime()).safeGetHeader)(downloadResponse, "location");
            if (redirectUrl != null) {
                this.doProxyUpdateFile(nativeResponse, redirectUrl, headers, sha512, cancellationToken, errorHandler);
                return;
            }
            const nativeHeaders = { "Content-Type": "application/zip" };
            const streams = [];
            const downloadListenerCount = this.listenerCount((_main || _load_main()).DOWNLOAD_PROGRESS);
            this._logger.info(`${(_main || _load_main()).DOWNLOAD_PROGRESS} listener count: ${downloadListenerCount}`);
            if (downloadListenerCount > 0) {
                const contentLength = (0, (_builderUtilRuntime || _load_builderUtilRuntime()).safeGetHeader)(downloadResponse, "content-length");
                this._logger.info(`contentLength: ${contentLength}`);
                if (contentLength != null) {
                    nativeHeaders["Content-Length"] = contentLength;
                    streams.push(new (_builderUtilRuntime || _load_builderUtilRuntime()).ProgressCallbackTransform(parseInt(contentLength, 10), cancellationToken, it => this.emit((_main || _load_main()).DOWNLOAD_PROGRESS, it)));
                }
            }
            nativeResponse.writeHead(200, nativeHeaders);
            // for mac only sha512 is produced (sha256 is published for windows only to preserve backward compatibility)
            if (sha512 != null) {
                // "hex" to easy migrate to new base64 encoded hash (we already produces latest-mac.yml with hex encoded hash)
                streams.push(new (_builderUtilRuntime || _load_builderUtilRuntime()).DigestTransform(sha512, "sha512", sha512.length === 128 && !sha512.includes("+") && !sha512.includes("Z") && !sha512.includes("=") ? "hex" : "base64"));
            }
            streams.push(nativeResponse);
            let lastStream = downloadResponse;
            for (const stream of streams) {
                stream.on("error", errorHandler);
                lastStream = lastStream.pipe(stream);
            }
        });
        downloadRequest.on("redirect", (statusCode, method, redirectUrl) => {
            if (headers.Authorization != null && headers.Authorization.startsWith("token")) {
                const parsedNewUrl = new URL(redirectUrl);
                if (parsedNewUrl.hostname.endsWith(".amazonaws.com")) {
                    delete headers.Authorization;
                }
            }
            this.doProxyUpdateFile(nativeResponse, redirectUrl, headers, sha512, cancellationToken, errorHandler);
        });
        downloadRequest.on("error", errorHandler);
        downloadRequest.end();
    }
    quitAndInstall() {
        this.nativeUpdater.quitAndInstall();
    }
}
exports.MacUpdater = MacUpdater; //# sourceMappingURL=MacUpdater.js.map

/***/ }),
/* 182 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.AppImageUpdater = undefined;

var _bluebirdLst;

function _load_bluebirdLst() {
    return _bluebirdLst = __webpack_require__(2);
}

var _bluebirdLst2;

function _load_bluebirdLst2() {
    return _bluebirdLst2 = _interopRequireDefault(__webpack_require__(2));
}

var _builderUtilRuntime;

function _load_builderUtilRuntime() {
    return _builderUtilRuntime = __webpack_require__(3);
}

var _child_process;

function _load_child_process() {
    return _child_process = __webpack_require__(34);
}

var _electronIsDev;

function _load_electronIsDev() {
    return _electronIsDev = _interopRequireDefault(__webpack_require__(26));
}

var _fsExtraP;

function _load_fsExtraP() {
    return _fsExtraP = __webpack_require__(9);
}

var _path = _interopRequireWildcard(__webpack_require__(0));

__webpack_require__(33);

var _BaseUpdater;

function _load_BaseUpdater() {
    return _BaseUpdater = __webpack_require__(61);
}

var _FileWithEmbeddedBlockMapDifferentialDownloader;

function _load_FileWithEmbeddedBlockMapDifferentialDownloader() {
    return _FileWithEmbeddedBlockMapDifferentialDownloader = __webpack_require__(62);
}

var _main;

function _load_main() {
    return _main = __webpack_require__(8);
}

var _Provider;

function _load_Provider() {
    return _Provider = __webpack_require__(14);
}

function _interopRequireWildcard(obj) {
    if (obj && obj.__esModule) {
        return obj;
    } else {
        var newObj = {};if (obj != null) {
            for (var key in obj) {
                if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key];
            }
        }newObj.default = obj;return newObj;
    }
}

function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
}

class AppImageUpdater extends (_BaseUpdater || _load_BaseUpdater()).BaseUpdater {
    constructor(options, app) {
        super(options, app);
    }
    checkForUpdatesAndNotify() {
        if ((_electronIsDev || _load_electronIsDev()).default) {
            return (_bluebirdLst2 || _load_bluebirdLst2()).default.resolve(null);
        }
        if (process.env.APPIMAGE == null) {
            this._logger.warn("APPIMAGE env is not defined, current application is not an AppImage");
            return (_bluebirdLst2 || _load_bluebirdLst2()).default.resolve(null);
        }
        return super.checkForUpdatesAndNotify();
    }
    /*** @private */
    doDownloadUpdate(updateInfo, cancellationToken) {
        var _this = this;

        return (0, (_bluebirdLst || _load_bluebirdLst()).coroutine)(function* () {
            const provider = yield _this.provider;
            const fileInfo = (0, (_Provider || _load_Provider()).findFile)(provider.resolveFiles(updateInfo), "AppImage");
            const requestHeaders = yield _this.computeRequestHeaders();
            const downloadOptions = {
                skipDirCreation: true,
                headers: requestHeaders,
                cancellationToken,
                sha512: fileInfo.info.sha512
            };
            let installerPath = _this.downloadedUpdateHelper.getDownloadedFile(updateInfo, fileInfo);
            if (installerPath != null) {
                return [installerPath];
            }
            yield _this.executeDownload(downloadOptions, fileInfo, (() => {
                var _ref = (0, (_bluebirdLst || _load_bluebirdLst()).coroutine)(function* (tempDir, destinationFile) {
                    installerPath = destinationFile;
                    const oldFile = process.env.APPIMAGE;
                    if (oldFile == null) {
                        throw (0, (_builderUtilRuntime || _load_builderUtilRuntime()).newError)("APPIMAGE env is not defined", "ERR_UPDATER_OLD_FILE_NOT_FOUND");
                    }
                    let isDownloadFull = false;
                    try {
                        yield new (_FileWithEmbeddedBlockMapDifferentialDownloader || _load_FileWithEmbeddedBlockMapDifferentialDownloader()).FileWithEmbeddedBlockMapDifferentialDownloader(fileInfo.info, _this.httpExecutor, {
                            newUrl: fileInfo.url.href,
                            oldFile,
                            logger: _this._logger,
                            newFile: installerPath,
                            useMultipleRangeRequest: provider.useMultipleRangeRequest,
                            requestHeaders
                        }).download();
                    } catch (e) {
                        _this._logger.error(`Cannot download differentially, fallback to full download: ${e.stack || e}`);
                        // during test (developer machine mac) we must throw error
                        isDownloadFull = process.platform === "linux";
                    }
                    if (isDownloadFull) {
                        yield _this.httpExecutor.download(fileInfo.url.href, installerPath, downloadOptions);
                    }
                    yield (0, (_fsExtraP || _load_fsExtraP()).chmod)(installerPath, 0o755);
                });

                return function (_x, _x2) {
                    return _ref.apply(this, arguments);
                };
            })());
            _this.downloadedUpdateHelper.setDownloadedFile(installerPath, null, updateInfo, fileInfo);
            _this.addQuitHandler();
            _this.emit((_main || _load_main()).UPDATE_DOWNLOADED, _this.updateInfo);
            return [installerPath];
        })();
    }
    doInstall(installerPath, isSilent, isRunAfter) {
        const appImageFile = process.env.APPIMAGE;
        if (appImageFile == null) {
            throw (0, (_builderUtilRuntime || _load_builderUtilRuntime()).newError)("APPIMAGE env is not defined", "ERR_UPDATER_OLD_FILE_NOT_FOUND");
        }
        // https://stackoverflow.com/a/1712051/1910191
        (0, (_fsExtraP || _load_fsExtraP()).unlinkSync)(appImageFile);
        let destination;
        if (_path.basename(installerPath) === _path.basename(appImageFile)) {
            // no version in the file name, overwrite existing
            destination = appImageFile;
        } else {
            destination = _path.join(_path.dirname(appImageFile), _path.basename(installerPath));
        }
        (0, (_child_process || _load_child_process()).execFileSync)("mv", ["-f", installerPath, destination]);
        const env = Object.assign({}, process.env, { APPIMAGE_SILENT_INSTALL: "true" });
        if (isRunAfter) {
            (0, (_child_process || _load_child_process()).spawn)(destination, [], {
                detached: true,
                stdio: "ignore",
                env
            }).unref();
        } else {
            env.APPIMAGE_EXIT_AFTER_INSTALL = "true";
            (0, (_child_process || _load_child_process()).execFileSync)(destination, [], { env });
        }
        return true;
    }
}
exports.AppImageUpdater = AppImageUpdater; //# sourceMappingURL=AppImageUpdater.js.map

/***/ }),
/* 183 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


if (process.type === 'renderer') {
  module.exports = __webpack_require__(184);
} else {
  module.exports = __webpack_require__(185);
}

/***/ }),
/* 184 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = null;

var ipcRenderer;
try {
  ipcRenderer = __webpack_require__(10).ipcRenderer;
} catch (e) {
  ipcRenderer = null;
}

var originalConsole = __webpack_require__(68);

if (ipcRenderer) {
  module.exports = {
    error: log.bind(null, 'error'),
    warn: log.bind(null, 'warn'),
    info: log.bind(null, 'info'),
    verbose: log.bind(null, 'verbose'),
    debug: log.bind(null, 'debug'),
    silly: log.bind(null, 'silly'),
    log: log.bind(null, 'info')
  };

  module.exports.default = module.exports;

  ipcRenderer.on('__ELECTRON_LOG_RENDERER__', function (event, level, text) {
    if (level === 'verbose') {
      level = 'log';
    } else if (level === 'silly') {
      level = 'debug';
    }

    originalConsole[level].call(originalConsole.context, text);
  });
}

function log() {
  var data = Array.prototype.slice.call(arguments);

  data = data.map(function (obj) {
    if (obj instanceof Error) {
      obj = obj.stack || obj;
    }

    return obj;
  });

  ipcRenderer.send('__ELECTRON_LOG__', data);
}

/***/ }),
/* 185 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var electron;
try {
  electron = __webpack_require__(10);
} catch (e) {
  electron = null;
}

var log = __webpack_require__(186);
var transportConsole = __webpack_require__(36);
var transportFile = __webpack_require__(187);
var transportLogS = __webpack_require__(190);
var transportRendererConsole = __webpack_require__(192);

var transports = {
  console: transportConsole,
  file: transportFile,
  logS: transportLogS,
  rendererConsole: transportRendererConsole
};

module.exports = {
  transports: transports,

  error: log.bind(null, transports, 'error'),
  warn: log.bind(null, transports, 'warn'),
  info: log.bind(null, transports, 'info'),
  verbose: log.bind(null, transports, 'verbose'),
  debug: log.bind(null, transports, 'debug'),
  silly: log.bind(null, transports, 'silly'),
  log: log.bind(null, transports, 'info')
};

module.exports.default = module.exports;

if (electron && electron.ipcMain) {
  electron.ipcMain.on('__ELECTRON_LOG__', onRendererLog);
  var appName = electron.app.getName();
  if (appName !== 'Electron') {
    transportFile.appName = appName;
  }
}

function onRendererLog(event, data) {
  if (Array.isArray(data)) {
    data.unshift(transports);
    log.apply(null, data);
  }
}

/***/ }),
/* 186 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// jshint -W040


var LEVELS = ['error', 'warn', 'info', 'verbose', 'debug', 'silly'];

module.exports = log;

function log(transports, level, text) {
  var data = Array.prototype.slice.call(arguments, 2);

  var msg = {
    data: data,
    date: new Date(),
    level: level
  };

  for (var i in transports) {
    // jshint -W089
    if (!transports.hasOwnProperty(i) || typeof transports[i] !== 'function') {
      continue;
    }

    var transport = transports[i];

    if (transport === false || !compareLevels(transport.level, level)) {
      continue;
    }

    if (transport.level === false) continue;

    transport.call(null, msg);
  }
}

function compareLevels(passLevel, checkLevel) {
  var pass = LEVELS.indexOf(passLevel);
  var check = LEVELS.indexOf(checkLevel);
  if (check === -1 || pass === -1) {
    return true;
  }
  return check <= pass;
}

/***/ }),
/* 187 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var fs = __webpack_require__(12);
var EOL = __webpack_require__(15).EOL;
var format = __webpack_require__(37);
var consoleTransport = __webpack_require__(36);
var findLogPath = __webpack_require__(188);

transport.findLogPath = findLogPath;
transport.format = '[{y}-{m}-{d} {h}:{i}:{s}.{ms}] [{level}] {text}';
transport.level = 'warn';
transport.maxSize = 1024 * 1024;
transport.streamConfig = undefined;

module.exports = transport;

function transport(msg) {
  var text = format.format(msg, transport.format) + EOL;

  if (transport.stream === undefined) {
    initSteamConfig();
    openStream();
  }

  if (transport.level === false) {
    return;
  }

  var needLogRotation = transport.maxSize > 0 && getStreamSize(transport.stream) > transport.maxSize;

  if (needLogRotation) {
    archiveLog(transport.stream);
    openStream();
  }

  transport.stream.write(text);
}

function initSteamConfig() {
  transport.file = transport.file || findLogPath(transport.appName);

  if (!transport.file) {
    transport.level = false;
    logConsole('Could not set a log file');
  }
}

function openStream() {
  if (transport.level === false) {
    return;
  }

  transport.stream = fs.createWriteStream(transport.file, transport.streamConfig || { flags: 'a' });
}

function getStreamSize(stream) {
  if (!stream) {
    return 0;
  }

  if (stream.logSizeAtStart === undefined) {
    try {
      stream.logSizeAtStart = fs.statSync(stream.path).size;
    } catch (e) {
      stream.logSizeAtStart = 0;
    }
  }

  return stream.logSizeAtStart + stream.bytesWritten;
}

function archiveLog(stream) {
  if (stream.end) {
    stream.end();
  }

  try {
    fs.renameSync(stream.path, stream.path.replace(/log$/, 'old.log'));
  } catch (e) {
    logConsole('Could not rotate log', e);
  }
}

function logConsole(message, error) {
  var data = ['electron-log.transports.file: ' + message];

  if (error) {
    data.push(error);
  }

  consoleTransport({ data: data, date: new Date(), level: 'warn' });
}

/***/ }),
/* 188 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var fs = __webpack_require__(12);
var path = __webpack_require__(0);
var os = __webpack_require__(15);
var getAppName = __webpack_require__(189);

module.exports = findLogPath;

/**
 * Try to determine a platform-specific path where can write logs
 * @param {string} [appName] Used to determine the last part of a log path
 * @return {string|boolean}
 */
function findLogPath(appName) {
  appName = appName || getAppName();
  if (!appName) {
    return false;
  }

  var homeDir = os.homedir ? os.homedir() : process.env['HOME'];

  var dir;
  switch (process.platform) {
    case 'linux':
      {
        dir = prepareDir(process.env['XDG_CONFIG_HOME'], appName).or(homeDir, '.config', appName).or(process.env['XDG_DATA_HOME'], appName).or(homeDir, '.local', 'share', appName).result;
        break;
      }

    case 'darwin':
      {
        dir = prepareDir(homeDir, 'Library', 'Logs', appName).or(homeDir, 'Library', 'Application Support', appName).result;
        break;
      }

    case 'win32':
      {
        dir = prepareDir(process.env['APPDATA'], appName).or(homeDir, 'AppData', 'Roaming', appName).result;
        break;
      }
  }

  if (dir) {
    return path.join(dir, 'log.log');
  } else {
    return false;
  }
}

function prepareDir(dirPath) {
  // jshint -W040
  if (!this || this.or !== prepareDir || !this.result) {
    if (!dirPath) {
      return { or: prepareDir };
    }

    //noinspection JSCheckFunctionSignatures
    dirPath = path.join.apply(path, arguments);
    mkDir(dirPath);

    try {
      fs.accessSync(dirPath, fs.W_OK);
    } catch (e) {
      return { or: prepareDir };
    }
  }

  return {
    or: prepareDir,
    result: (this ? this.result : false) || dirPath
  };
}

function mkDir(dirPath, root) {
  var dirs = dirPath.split(path.sep);
  var dir = dirs.shift();
  root = (root || '') + dir + path.sep;

  try {
    fs.mkdirSync(root);
  } catch (e) {
    if (!fs.statSync(root).isDirectory()) {
      throw new Error(e);
    }
  }

  return !dirs.length || mkDir(dirs.join(path.sep), root);
}

/***/ }),
/* 189 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// jshint -W074


/** @name process.resourcesPath */

var fs = __webpack_require__(12);
var path = __webpack_require__(0);
var consoleTransport = __webpack_require__(36);

module.exports = getAppName;

function getAppName() {
  try {
    var name = loadPackageName();
    if (name) {
      return name;
    }
    return warn('electron-log: unable to load the app name from package.json');
  } catch (e) {
    return warn('electron-log: ' + e.message);
  }
}

/**
 * Try to load main app package
 * @throws {Error}
 * @return {Object|null}
 */
function loadPackageName() {
  var packageFile;

  try {
    if (__webpack_require__.c[__webpack_require__.s].filename) {
      packageFile = find(path.dirname(__webpack_require__.c[__webpack_require__.s].filename));
    }
  } catch (e) {}

  if (!packageFile && process.resourcesPath) {
    packageFile = find(path.join(process.resourcesPath, 'app.asar'));
    var electronModule = path.join('node_modules', 'electron', 'package.json');
    if (packageFile && packageFile.indexOf(electronModule) !== -1) {
      packageFile = null;
    }
  }

  if (!packageFile) {
    packageFile = find(process.cwd());
  }

  if (!packageFile) {
    return null;
  }

  var content = fs.readFileSync(packageFile, 'utf-8');
  var packageData = JSON.parse(content);

  //noinspection JSUnresolvedVariable
  return packageData ? packageData.productName || packageData.name : false;
}

function find(root) {
  var file;

  while (!file) {
    var parent;
    file = path.join(root, 'package.json');

    try {
      fs.statSync(file);
    } catch (e) {
      parent = path.resolve(root, '..');
      file = null;
    }

    if (root === parent) {
      break;
    }

    root = parent;
  }

  return file;
}

function warn(message) {
  consoleTransport({
    data: [message],
    date: new Date(),
    level: 'warn'
  });
}

/***/ }),
/* 190 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// jshint -W074, -W089


var http = __webpack_require__(67);
var https = __webpack_require__(191);
var url = __webpack_require__(20);

transport.client = { name: 'electron-application' };
transport.depth = 6;
transport.level = false;
transport.url = null;

module.exports = transport;

function transport(msg) {
  if (!transport.url) return;

  var data = jsonDepth({
    client: transport.client,
    data: msg.data,
    date: msg.date.getTime(),
    level: msg.level
  }, transport.depth + 1);

  post(transport.url, data);
}

function post(serverUrl, data) {
  var urlObject = url.parse(serverUrl);
  var transport = urlObject.protocol === 'https:' ? https : http;

  var body = JSON.stringify(data);

  var options = {
    hostname: urlObject.hostname,
    port: urlObject.port,
    path: urlObject.path,
    method: 'POST',
    headers: {
      'Content-Type': 'application/json',
      'Content-Length': body.length
    }
  };

  var request = transport.request(options);
  request.write(body);
  request.end();
}

function jsonDepth(json, depth) {
  if (depth < 1) {
    if (Array.isArray(json)) return '[array]';
    if (typeof json === 'object') return '[object]';
    return json;
  }

  if (Array.isArray(json)) {
    return json.map(function (child) {
      return jsonDepth(child, depth - 1);
    });
  }

  if (json && typeof json.getMonth === 'function') {
    return json;
  }

  if (json === null) {
    return null;
  }

  if (typeof json === 'object') {
    if (typeof json.toJSON === 'function') {
      json = json.toJSON();
    }

    var newJson = {};
    for (var i in json) {
      //noinspection JSUnfilteredForInLoop
      newJson[i] = jsonDepth(json[i], depth - 1);
    }

    return newJson;
  }

  return json;
}

/***/ }),
/* 191 */
/***/ (function(module, exports) {

module.exports = require("https");

/***/ }),
/* 192 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var BrowserWindow;
try {
  BrowserWindow = __webpack_require__(10).BrowserWindow;
} catch (e) {
  BrowserWindow = null;
}

var format = __webpack_require__(37);

transport.level = BrowserWindow ? 'silly' : false;
transport.format = '[{h}:{i}:{s}.{ms}] {text}';

module.exports = transport;

function transport(msg) {
  if (!BrowserWindow) return;

  var text = format.format(msg, transport.format);
  BrowserWindow.getAllWindows().forEach(function (wnd) {
    wnd.webContents.send('__ELECTRON_LOG_RENDERER__', msg.level, text);
  });
}

/***/ }),
/* 193 */
/***/ (function(module, exports) {

module.exports = {"name":"ELIT","version":"0.2.0","description":"ELIT - Eve Local Intel Tool","main":"dist/main.js","repository":"git@github.com:Squareheads/ELIT.git","author":"Owen Worley","license":"(c) Squareheads LTD 2018","devDependencies":{"@types/chai":"^4.0.8","@types/electron":"^1.6.10","@types/electron-is-dev":"^0.3.0","@types/material-ui":"^0.18.5","@types/mocha":"^2.2.44","@types/mockery":"^1.4.29","@types/node":"^8.0.53","@types/react":"^16.0.25","@types/react-dom":"^16.0.3","@types/request":"^2.0.8","@types/request-promise-native":"^1.0.10","@types/sinon":"^4.1.0","@types/url-parse":"^1.1.0","@types/x2js":"^3.1.0","babel-core":"^6.26.0","babel-loader":"^7.1.2","babel-plugin-add-module-exports":"^0.2.1","babel-plugin-transform-runtime":"^6.0.0","babel-preset-env":"^1.6.1","babel-preset-es2015":"^6.24.1","babel-preset-es2015-node":"^6.1.1","babel-preset-es2015-node5":"^1.2.0","babel-preset-react":"^6.24.1","babel-preset-stage-3":"^6.24.1","babel-preset-ts-node6-bluebird":"^1.0.1","chai":"^4.1.2","electron":"^1.7.9","electron-builder":"^19.46.9","fake-indexeddb":"^2.0.3","html-webpack-plugin":"^2.30.1","ignore-styles":"^5.0.1","mocha":"^4.0.1","mockery":"^2.1.0","node-noop":"^1.0.0","nyc":"^11.3.0","sinon":"^4.1.3","standard":"^10.0.3","standard-loader":"^6.0.1","ts-loader":"^3.1.1","ts-mockito":"^2.2.7","ts-node":"^3.3.0","tslint":"^5.8.0","tslint-config-standard":"^7.0.0","tslint-loader":"^3.5.3","typescript":"^2.6.2","webpack":"^3.8.1"},"scripts":{"build":"webpack --config webpack.config.js","prestart":"yarn run build","start":"electron .","test":"set TS_NODE_PROJECT=tsconfig.test.json&&mocha","pack":"electron-builder --dir","dist":"electron-builder","dist-all":"electron-builder -mwl"},"dependencies":{"dexie":"2","electron-google-analytics":"^0.0.24","electron-is-dev":"^0.3.0","electron-log":"^2.2.13","electron-updater":"^2.18.2","eve-online-esi":" https://github.com/Squareheads/eve-online-esi/archive/df440efa394e36e063a6593bede8dd8d285e1179.tar.gz","material-ui":"^0.20.0","material-ui-image":"^2.1.1","querystringify":"^1.0.0","react":"^16.2.0","react-dom":"^16.2.0","react-electron-web-view":"^2.0.1","request":"^2.83.0","typescript-collections":"^1.2.5","url-parse":"^1.2.0","x2js":"^3.1.1"},"build":{"appId":"io.squareheads.eve-intel","files":"./dist/**/*","directories":{"output":"packaged"},"mac":{"category":"public.app-category.utilities"}},"peerDependencies":{}}

/***/ })
/******/ ]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vd2VicGFjay9ib290c3RyYXAgOWFkNDgwOGI3ZjUwNzU5ODg2ZmQiLCJ3ZWJwYWNrOi8vL2V4dGVybmFsIFwicGF0aFwiIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9ibHVlYmlyZC9qcy9yZWxlYXNlL3V0aWwuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2JsdWViaXJkLWxzdC9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZWxlY3Ryb24tdXBkYXRlci9ub2RlX21vZHVsZXMvYnVpbGRlci11dGlsLXJ1bnRpbWUvb3V0L2luZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9qcy15YW1sL2xpYi9qcy15YW1sL3R5cGUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2dyYWNlZnVsLWZzL2dyYWNlZnVsLWZzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy91bml2ZXJzYWxpZnkvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2VsZWN0cm9uLXVwZGF0ZXIvbm9kZV9tb2R1bGVzL2ZzLWV4dHJhL2xpYi9ta2RpcnMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2VsZWN0cm9uLXVwZGF0ZXIvb3V0L21haW4uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2VsZWN0cm9uLXVwZGF0ZXIvbm9kZV9tb2R1bGVzL2ZzLWV4dHJhLXAvaW5kZXguanMiLCJ3ZWJwYWNrOi8vL2V4dGVybmFsIFwiZWxlY3Ryb25cIiIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYmx1ZWJpcmQvanMvcmVsZWFzZS9lcnJvcnMuanMiLCJ3ZWJwYWNrOi8vL2V4dGVybmFsIFwiZnNcIiIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZWxlY3Ryb24tdXBkYXRlci9ub2RlX21vZHVsZXMvZnMtZXh0cmEvbGliL3BhdGgtZXhpc3RzL2luZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9lbGVjdHJvbi11cGRhdGVyL291dC9Qcm92aWRlci5qcyIsIndlYnBhY2s6Ly8vZXh0ZXJuYWwgXCJvc1wiIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9ibHVlYmlyZC9qcy9yZWxlYXNlL2VzNS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvanMteWFtbC9saWIvanMteWFtbC9jb21tb24uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2pzLXlhbWwvbGliL2pzLXlhbWwvc2NoZW1hLmpzIiwid2VicGFjazovLy9leHRlcm5hbCBcInN0cmVhbVwiIiwid2VicGFjazovLy9leHRlcm5hbCBcInVybFwiIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9qcy15YW1sL2xpYi9qcy15YW1sL2V4Y2VwdGlvbi5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvanMteWFtbC9saWIvanMteWFtbC9zY2hlbWEvZGVmYXVsdF9zYWZlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9lbGVjdHJvbi11cGRhdGVyL25vZGVfbW9kdWxlcy9zb3VyY2UtbWFwL2xpYi91dGlsLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9lbGVjdHJvbi11cGRhdGVyL25vZGVfbW9kdWxlcy9mcy1leHRyYS9saWIvcmVtb3ZlL2luZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9qcy15YW1sL2xpYi9qcy15YW1sL3NjaGVtYS9kZWZhdWx0X2Z1bGwuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2VsZWN0cm9uLWlzLWRldi9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZWxlY3Ryb24tdXBkYXRlci9vdXQvQXBwVXBkYXRlci5qcyIsIndlYnBhY2s6Ly8vZXh0ZXJuYWwgXCJjcnlwdG9cIiIsIndlYnBhY2s6Ly8vZXh0ZXJuYWwgXCJ1dGlsXCIiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2VsZWN0cm9uLXVwZGF0ZXIvbm9kZV9tb2R1bGVzL2ZzLWV4dHJhL2xpYi9qc29uL2pzb25maWxlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9qcy15YW1sL2luZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9qcy15YW1sL2xpYi9qcy15YW1sL3NjaGVtYS9mYWlsc2FmZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZWxlY3Ryb24tdXBkYXRlci9ub2RlX21vZHVsZXMvc291cmNlLW1hcC1zdXBwb3J0L3JlZ2lzdGVyLmpzIiwid2VicGFjazovLy9leHRlcm5hbCBcImNoaWxkX3Byb2Nlc3NcIiIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZWxlY3Ryb24tdXBkYXRlci9vdXQvZGlmZmVyZW50aWFsRG93bmxvYWRlci9kb3dubG9hZFBsYW5CdWlsZGVyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9lbGVjdHJvbi1sb2cvbGliL3RyYW5zcG9ydHMvY29uc29sZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZWxlY3Ryb24tbG9nL2xpYi9mb3JtYXQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2JsdWViaXJkL2pzL3JlbGVhc2UvY2F0Y2hfZmlsdGVyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9ibHVlYmlyZC9qcy9yZWxlYXNlL25vZGViYWNrLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9lbGVjdHJvbi11cGRhdGVyL25vZGVfbW9kdWxlcy9idWlsZGVyLXV0aWwtcnVudGltZS9vdXQvQ2FuY2VsbGF0aW9uVG9rZW4uanMiLCJ3ZWJwYWNrOi8vL2V4dGVybmFsIFwiZXZlbnRzXCIiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2VsZWN0cm9uLXVwZGF0ZXIvbm9kZV9tb2R1bGVzL2J1aWxkZXItdXRpbC1ydW50aW1lL291dC9odHRwRXhlY3V0b3IuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2VsZWN0cm9uLXVwZGF0ZXIvbm9kZV9tb2R1bGVzL2RlYnVnL3NyYy9kZWJ1Zy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZWxlY3Ryb24tdXBkYXRlci9ub2RlX21vZHVsZXMvZnMtZXh0cmEvbGliL2ZzL2luZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9ncmFjZWZ1bC1mcy9mcy5qcyIsIndlYnBhY2s6Ly8vZXh0ZXJuYWwgXCJhc3NlcnRcIiIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZWxlY3Ryb24tdXBkYXRlci9ub2RlX21vZHVsZXMvZnMtZXh0cmEvbGliL2NvcHkvY29weS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZWxlY3Ryb24tdXBkYXRlci9ub2RlX21vZHVsZXMvZnMtZXh0cmEvbGliL21rZGlycy93aW4zMi5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZWxlY3Ryb24tdXBkYXRlci9ub2RlX21vZHVsZXMvZnMtZXh0cmEvbGliL3V0aWwvdXRpbWVzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9lbGVjdHJvbi11cGRhdGVyL25vZGVfbW9kdWxlcy9mcy1leHRyYS9saWIvY29weS1zeW5jL2luZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9lbGVjdHJvbi11cGRhdGVyL25vZGVfbW9kdWxlcy9mcy1leHRyYS9saWIvdXRpbC9idWZmZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2VsZWN0cm9uLXVwZGF0ZXIvbm9kZV9tb2R1bGVzL2J1aWxkZXItdXRpbC1ydW50aW1lL291dC9Qcm9ncmVzc0NhbGxiYWNrVHJhbnNmb3JtLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9qcy15YW1sL2xpYi9qcy15YW1sL3NjaGVtYS9jb3JlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9qcy15YW1sL2xpYi9qcy15YW1sL3NjaGVtYS9qc29uLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9zZW12ZXIvc2VtdmVyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9lbGVjdHJvbi11cGRhdGVyL25vZGVfbW9kdWxlcy9zb3VyY2UtbWFwL2xpYi9zb3VyY2UtbWFwLWdlbmVyYXRvci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZWxlY3Ryb24tdXBkYXRlci9ub2RlX21vZHVsZXMvc291cmNlLW1hcC9saWIvYmFzZTY0LXZscS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZWxlY3Ryb24tdXBkYXRlci9ub2RlX21vZHVsZXMvc291cmNlLW1hcC9saWIvYXJyYXktc2V0LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9lbGVjdHJvbi11cGRhdGVyL291dC9HZW5lcmljUHJvdmlkZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2VsZWN0cm9uLXVwZGF0ZXIvb3V0L0dpdEh1YlByb3ZpZGVyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9lbGVjdHJvbi11cGRhdGVyL291dC9CYXNlVXBkYXRlci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZWxlY3Ryb24tdXBkYXRlci9vdXQvZGlmZmVyZW50aWFsRG93bmxvYWRlci9GaWxlV2l0aEVtYmVkZGVkQmxvY2tNYXBEaWZmZXJlbnRpYWxEb3dubG9hZGVyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9lbGVjdHJvbi11cGRhdGVyL25vZGVfbW9kdWxlcy9idWlsZGVyLXV0aWwtcnVudGltZS9vdXQvYmxvY2tNYXBBcGkuanMiLCJ3ZWJwYWNrOi8vL2V4dGVybmFsIFwiemxpYlwiIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9lbGVjdHJvbi11cGRhdGVyL291dC9kaWZmZXJlbnRpYWxEb3dubG9hZGVyL0RpZmZlcmVudGlhbERvd25sb2FkZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2VsZWN0cm9uLXVwZGF0ZXIvb3V0L2RpZmZlcmVudGlhbERvd25sb2FkZXIvRGF0YVNwbGl0dGVyLmpzIiwid2VicGFjazovLy9leHRlcm5hbCBcImh0dHBcIiIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZWxlY3Ryb24tbG9nL2xpYi9vcmlnaW5hbC1jb25zb2xlLmpzIiwid2VicGFjazovLy8uL3NyYy9tYWluLnRzeCIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYmx1ZWJpcmQvanMvcmVsZWFzZS9wcm9taXNlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9ibHVlYmlyZC9qcy9yZWxlYXNlL2FzeW5jLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9ibHVlYmlyZC9qcy9yZWxlYXNlL3NjaGVkdWxlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9ibHVlYmlyZC9qcy9yZWxlYXNlL3F1ZXVlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9ibHVlYmlyZC9qcy9yZWxlYXNlL3RoZW5hYmxlcy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYmx1ZWJpcmQvanMvcmVsZWFzZS9wcm9taXNlX2FycmF5LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9ibHVlYmlyZC9qcy9yZWxlYXNlL2NvbnRleHQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2JsdWViaXJkL2pzL3JlbGVhc2UvZGVidWdnYWJpbGl0eS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYmx1ZWJpcmQvanMvcmVsZWFzZS9maW5hbGx5LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9ibHVlYmlyZC9qcy9yZWxlYXNlL21ldGhvZC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYmx1ZWJpcmQvanMvcmVsZWFzZS9iaW5kLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9ibHVlYmlyZC9qcy9yZWxlYXNlL2NhbmNlbC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYmx1ZWJpcmQvanMvcmVsZWFzZS9kaXJlY3RfcmVzb2x2ZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYmx1ZWJpcmQvanMvcmVsZWFzZS9zeW5jaHJvbm91c19pbnNwZWN0aW9uLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9ibHVlYmlyZC9qcy9yZWxlYXNlL2pvaW4uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2JsdWViaXJkL2pzL3JlbGVhc2UvbWFwLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9ibHVlYmlyZC9qcy9yZWxlYXNlL2NhbGxfZ2V0LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9ibHVlYmlyZC9qcy9yZWxlYXNlL3VzaW5nLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9ibHVlYmlyZC9qcy9yZWxlYXNlL3RpbWVycy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYmx1ZWJpcmQvanMvcmVsZWFzZS9nZW5lcmF0b3JzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9ibHVlYmlyZC9qcy9yZWxlYXNlL25vZGVpZnkuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2JsdWViaXJkL2pzL3JlbGVhc2UvcHJvbWlzaWZ5LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9ibHVlYmlyZC9qcy9yZWxlYXNlL3Byb3BzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9ibHVlYmlyZC9qcy9yZWxlYXNlL3JhY2UuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2JsdWViaXJkL2pzL3JlbGVhc2UvcmVkdWNlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9ibHVlYmlyZC9qcy9yZWxlYXNlL3NldHRsZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYmx1ZWJpcmQvanMvcmVsZWFzZS9zb21lLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9ibHVlYmlyZC9qcy9yZWxlYXNlL2ZpbHRlci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYmx1ZWJpcmQvanMvcmVsZWFzZS9lYWNoLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9ibHVlYmlyZC9qcy9yZWxlYXNlL2FueS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZWxlY3Ryb24tdXBkYXRlci9ub2RlX21vZHVsZXMvZGVidWcvc3JjL2luZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9lbGVjdHJvbi11cGRhdGVyL25vZGVfbW9kdWxlcy9kZWJ1Zy9zcmMvYnJvd3Nlci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbXMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2VsZWN0cm9uLXVwZGF0ZXIvbm9kZV9tb2R1bGVzL2RlYnVnL3NyYy9ub2RlLmpzIiwid2VicGFjazovLy9leHRlcm5hbCBcInR0eVwiIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9zdXBwb3J0cy1jb2xvci9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvaGFzLWZsYWcvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2VsZWN0cm9uLXVwZGF0ZXIvbm9kZV9tb2R1bGVzL2ZzLWV4dHJhL2xpYi9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZWxlY3Ryb24tdXBkYXRlci9ub2RlX21vZHVsZXMvZnMtZXh0cmEvbGliL3V0aWwvYXNzaWduLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9ncmFjZWZ1bC1mcy9wb2x5ZmlsbHMuanMiLCJ3ZWJwYWNrOi8vL2V4dGVybmFsIFwiY29uc3RhbnRzXCIiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2dyYWNlZnVsLWZzL2xlZ2FjeS1zdHJlYW1zLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9lbGVjdHJvbi11cGRhdGVyL25vZGVfbW9kdWxlcy9mcy1leHRyYS9saWIvY29weS9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZWxlY3Ryb24tdXBkYXRlci9ub2RlX21vZHVsZXMvZnMtZXh0cmEvbGliL21rZGlycy9ta2RpcnMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2VsZWN0cm9uLXVwZGF0ZXIvbm9kZV9tb2R1bGVzL2ZzLWV4dHJhL2xpYi9ta2RpcnMvbWtkaXJzLXN5bmMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2VsZWN0cm9uLXVwZGF0ZXIvbm9kZV9tb2R1bGVzL2ZzLWV4dHJhL2xpYi9jb3B5LXN5bmMvY29weS1zeW5jLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9lbGVjdHJvbi11cGRhdGVyL25vZGVfbW9kdWxlcy9mcy1leHRyYS9saWIvcmVtb3ZlL3JpbXJhZi5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZWxlY3Ryb24tdXBkYXRlci9ub2RlX21vZHVsZXMvZnMtZXh0cmEvbGliL2pzb24vaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2pzb25maWxlL2luZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9lbGVjdHJvbi11cGRhdGVyL25vZGVfbW9kdWxlcy9mcy1leHRyYS9saWIvanNvbi9vdXRwdXQtanNvbi5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZWxlY3Ryb24tdXBkYXRlci9ub2RlX21vZHVsZXMvZnMtZXh0cmEvbGliL2pzb24vb3V0cHV0LWpzb24tc3luYy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZWxlY3Ryb24tdXBkYXRlci9ub2RlX21vZHVsZXMvZnMtZXh0cmEvbGliL21vdmUvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2VsZWN0cm9uLXVwZGF0ZXIvbm9kZV9tb2R1bGVzL2ZzLWV4dHJhL2xpYi9tb3ZlLXN5bmMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2VsZWN0cm9uLXVwZGF0ZXIvbm9kZV9tb2R1bGVzL2ZzLWV4dHJhL2xpYi9lbXB0eS9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZWxlY3Ryb24tdXBkYXRlci9ub2RlX21vZHVsZXMvZnMtZXh0cmEvbGliL2Vuc3VyZS9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZWxlY3Ryb24tdXBkYXRlci9ub2RlX21vZHVsZXMvZnMtZXh0cmEvbGliL2Vuc3VyZS9maWxlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9lbGVjdHJvbi11cGRhdGVyL25vZGVfbW9kdWxlcy9mcy1leHRyYS9saWIvZW5zdXJlL2xpbmsuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2VsZWN0cm9uLXVwZGF0ZXIvbm9kZV9tb2R1bGVzL2ZzLWV4dHJhL2xpYi9lbnN1cmUvc3ltbGluay5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZWxlY3Ryb24tdXBkYXRlci9ub2RlX21vZHVsZXMvZnMtZXh0cmEvbGliL2Vuc3VyZS9zeW1saW5rLXBhdGhzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9lbGVjdHJvbi11cGRhdGVyL25vZGVfbW9kdWxlcy9mcy1leHRyYS9saWIvZW5zdXJlL3N5bWxpbmstdHlwZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZWxlY3Ryb24tdXBkYXRlci9ub2RlX21vZHVsZXMvZnMtZXh0cmEvbGliL291dHB1dC9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZWxlY3Ryb24tdXBkYXRlci9ub2RlX21vZHVsZXMvYnVpbGRlci11dGlsLXJ1bnRpbWUvb3V0L3B1Ymxpc2hPcHRpb25zLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9lbGVjdHJvbi11cGRhdGVyL25vZGVfbW9kdWxlcy9idWlsZGVyLXV0aWwtcnVudGltZS9vdXQvcmZjMjI1M1BhcnNlci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZWxlY3Ryb24tdXBkYXRlci9ub2RlX21vZHVsZXMvYnVpbGRlci11dGlsLXJ1bnRpbWUvb3V0L3V1aWQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2VsZWN0cm9uLXVwZGF0ZXIvbm9kZV9tb2R1bGVzL2J1aWxkZXItdXRpbC1ydW50aW1lL291dC94bWwuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3NheC9saWIvc2F4LmpzIiwid2VicGFjazovLy9leHRlcm5hbCBcInN0cmluZ19kZWNvZGVyXCIiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2pzLXlhbWwvbGliL2pzLXlhbWwuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2pzLXlhbWwvbGliL2pzLXlhbWwvbG9hZGVyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9qcy15YW1sL2xpYi9qcy15YW1sL21hcmsuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2pzLXlhbWwvbGliL2pzLXlhbWwvdHlwZS9zdHIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2pzLXlhbWwvbGliL2pzLXlhbWwvdHlwZS9zZXEuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2pzLXlhbWwvbGliL2pzLXlhbWwvdHlwZS9tYXAuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2pzLXlhbWwvbGliL2pzLXlhbWwvdHlwZS9udWxsLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9qcy15YW1sL2xpYi9qcy15YW1sL3R5cGUvYm9vbC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvanMteWFtbC9saWIvanMteWFtbC90eXBlL2ludC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvanMteWFtbC9saWIvanMteWFtbC90eXBlL2Zsb2F0LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9qcy15YW1sL2xpYi9qcy15YW1sL3R5cGUvdGltZXN0YW1wLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9qcy15YW1sL2xpYi9qcy15YW1sL3R5cGUvbWVyZ2UuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2pzLXlhbWwvbGliL2pzLXlhbWwvdHlwZS9iaW5hcnkuanMiLCJ3ZWJwYWNrOi8vL2V4dGVybmFsIFwiYnVmZmVyXCIiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2pzLXlhbWwvbGliL2pzLXlhbWwvdHlwZS9vbWFwLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9qcy15YW1sL2xpYi9qcy15YW1sL3R5cGUvcGFpcnMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2pzLXlhbWwvbGliL2pzLXlhbWwvdHlwZS9zZXQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2pzLXlhbWwvbGliL2pzLXlhbWwvdHlwZS9qcy91bmRlZmluZWQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2pzLXlhbWwvbGliL2pzLXlhbWwvdHlwZS9qcy9yZWdleHAuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2pzLXlhbWwvbGliL2pzLXlhbWwvdHlwZS9qcy9mdW5jdGlvbi5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZXNwcmltYS9kaXN0L2VzcHJpbWEuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2pzLXlhbWwvbGliL2pzLXlhbWwvZHVtcGVyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9lbGVjdHJvbi11cGRhdGVyL25vZGVfbW9kdWxlcy9sYXp5LXZhbC9vdXQvbWFpbi5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZWxlY3Ryb24tdXBkYXRlci9ub2RlX21vZHVsZXMvc291cmNlLW1hcC1zdXBwb3J0L3NvdXJjZS1tYXAtc3VwcG9ydC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZWxlY3Ryb24tdXBkYXRlci9ub2RlX21vZHVsZXMvc291cmNlLW1hcC9zb3VyY2UtbWFwLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9lbGVjdHJvbi11cGRhdGVyL25vZGVfbW9kdWxlcy9zb3VyY2UtbWFwL2xpYi9iYXNlNjQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2VsZWN0cm9uLXVwZGF0ZXIvbm9kZV9tb2R1bGVzL3NvdXJjZS1tYXAvbGliL21hcHBpbmctbGlzdC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZWxlY3Ryb24tdXBkYXRlci9ub2RlX21vZHVsZXMvc291cmNlLW1hcC9saWIvc291cmNlLW1hcC1jb25zdW1lci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZWxlY3Ryb24tdXBkYXRlci9ub2RlX21vZHVsZXMvc291cmNlLW1hcC9saWIvYmluYXJ5LXNlYXJjaC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZWxlY3Ryb24tdXBkYXRlci9ub2RlX21vZHVsZXMvc291cmNlLW1hcC9saWIvcXVpY2stc29ydC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZWxlY3Ryb24tdXBkYXRlci9ub2RlX21vZHVsZXMvc291cmNlLW1hcC9saWIvc291cmNlLW5vZGUuanMiLCJ3ZWJwYWNrOi8vL2V4dGVybmFsIFwibW9kdWxlXCIiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2VsZWN0cm9uLXVwZGF0ZXIvb3V0L2VsZWN0cm9uSHR0cEV4ZWN1dG9yLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9lbGVjdHJvbi11cGRhdGVyL291dC9wcm92aWRlckZhY3RvcnkuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2VsZWN0cm9uLXVwZGF0ZXIvb3V0L0JpbnRyYXlQcm92aWRlci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZWxlY3Ryb24tdXBkYXRlci9ub2RlX21vZHVsZXMvYnVpbGRlci11dGlsLXJ1bnRpbWUvb3V0L2JpbnRyYXkuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2VsZWN0cm9uLXVwZGF0ZXIvb3V0L1ByaXZhdGVHaXRIdWJQcm92aWRlci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZWxlY3Ryb24tdXBkYXRlci9vdXQvTnNpc1VwZGF0ZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2VsZWN0cm9uLXVwZGF0ZXIvb3V0L0Rvd25sb2FkZWRVcGRhdGVIZWxwZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC5pc2VxdWFsL2luZGV4LmpzIiwid2VicGFjazovLy8od2VicGFjaykvYnVpbGRpbi9tb2R1bGUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2VsZWN0cm9uLXVwZGF0ZXIvb3V0L2RpZmZlcmVudGlhbERvd25sb2FkZXIvbXVsdGlwbGVSYW5nZURvd25sb2FkZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2VsZWN0cm9uLXVwZGF0ZXIvb3V0L2RpZmZlcmVudGlhbERvd25sb2FkZXIvR2VuZXJpY0RpZmZlcmVudGlhbERvd25sb2FkZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2VsZWN0cm9uLXVwZGF0ZXIvb3V0L3dpbmRvd3NFeGVjdXRhYmxlQ29kZVNpZ25hdHVyZVZlcmlmaWVyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9lbGVjdHJvbi11cGRhdGVyL291dC9NYWNVcGRhdGVyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9lbGVjdHJvbi11cGRhdGVyL291dC9BcHBJbWFnZVVwZGF0ZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2VsZWN0cm9uLWxvZy9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZWxlY3Ryb24tbG9nL3JlbmRlcmVyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9lbGVjdHJvbi1sb2cvbWFpbi5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZWxlY3Ryb24tbG9nL2xpYi9sb2cuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2VsZWN0cm9uLWxvZy9saWIvdHJhbnNwb3J0cy9maWxlL2luZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9lbGVjdHJvbi1sb2cvbGliL3RyYW5zcG9ydHMvZmlsZS9maW5kLWxvZy1wYXRoLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9lbGVjdHJvbi1sb2cvbGliL3RyYW5zcG9ydHMvZmlsZS9nZXQtYXBwLW5hbWUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2VsZWN0cm9uLWxvZy9saWIvdHJhbnNwb3J0cy9sb2ctcy5qcyIsIndlYnBhY2s6Ly8vZXh0ZXJuYWwgXCJodHRwc1wiIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9lbGVjdHJvbi1sb2cvbGliL3RyYW5zcG9ydHMvcmVuZGVyZXItY29uc29sZS5qcyIsIndlYnBhY2s6Ly8vLi9wYWNrYWdlLmpzb24iXSwibmFtZXMiOlsiZXM1IiwicmVxdWlyZSIsImNhbkV2YWx1YXRlIiwibmF2aWdhdG9yIiwiZXJyb3JPYmoiLCJlIiwidHJ5Q2F0Y2hUYXJnZXQiLCJnbG9iYWxPYmplY3QiLCJzZWxmIiwid2luZG93IiwiZ2xvYmFsIiwidW5kZWZpbmVkIiwidHJ5Q2F0Y2hlciIsInRhcmdldCIsImFwcGx5IiwiYXJndW1lbnRzIiwidHJ5Q2F0Y2giLCJmbiIsImluaGVyaXRzIiwiQ2hpbGQiLCJQYXJlbnQiLCJoYXNQcm9wIiwiaGFzT3duUHJvcGVydHkiLCJUIiwiY29uc3RydWN0b3IiLCJjb25zdHJ1Y3RvciQiLCJwcm9wZXJ0eU5hbWUiLCJwcm90b3R5cGUiLCJjYWxsIiwiY2hhckF0IiwibGVuZ3RoIiwiaXNQcmltaXRpdmUiLCJ2YWwiLCJpc09iamVjdCIsInZhbHVlIiwibWF5YmVXcmFwQXNFcnJvciIsIm1heWJlRXJyb3IiLCJFcnJvciIsInNhZmVUb1N0cmluZyIsIndpdGhBcHBlbmRlZCIsImFwcGVuZGVlIiwibGVuIiwicmV0IiwiQXJyYXkiLCJpIiwiZ2V0RGF0YVByb3BlcnR5T3JEZWZhdWx0Iiwib2JqIiwia2V5IiwiZGVmYXVsdFZhbHVlIiwiaXNFUzUiLCJkZXNjIiwiT2JqZWN0IiwiZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yIiwiZ2V0Iiwic2V0Iiwibm90RW51bWVyYWJsZVByb3AiLCJuYW1lIiwiZGVzY3JpcHRvciIsImNvbmZpZ3VyYWJsZSIsImVudW1lcmFibGUiLCJ3cml0YWJsZSIsImRlZmluZVByb3BlcnR5IiwidGhyb3dlciIsInIiLCJpbmhlcml0ZWREYXRhS2V5cyIsImV4Y2x1ZGVkUHJvdG90eXBlcyIsIkZ1bmN0aW9uIiwiaXNFeGNsdWRlZFByb3RvIiwiZ2V0S2V5cyIsImdldE93blByb3BlcnR5TmFtZXMiLCJ2aXNpdGVkS2V5cyIsImNyZWF0ZSIsImtleXMiLCJwdXNoIiwiZ2V0UHJvdG90eXBlT2YiLCJlbnVtZXJhdGlvbiIsInRoaXNBc3NpZ25tZW50UGF0dGVybiIsImlzQ2xhc3MiLCJuYW1lcyIsImhhc01ldGhvZHMiLCJoYXNNZXRob2RzT3RoZXJUaGFuQ29uc3RydWN0b3IiLCJoYXNUaGlzQXNzaWdubWVudEFuZFN0YXRpY01ldGhvZHMiLCJ0ZXN0IiwidG9GYXN0UHJvcGVydGllcyIsIkZha2VDb25zdHJ1Y3RvciIsImwiLCJldmFsIiwicmlkZW50IiwiaXNJZGVudGlmaWVyIiwic3RyIiwiZmlsbGVkUmFuZ2UiLCJjb3VudCIsInByZWZpeCIsInN1ZmZpeCIsImlzRXJyb3IiLCJtZXNzYWdlIiwibWFya0FzT3JpZ2luYXRpbmdGcm9tUmVqZWN0aW9uIiwiaWdub3JlIiwib3JpZ2luYXRlc0Zyb21SZWplY3Rpb24iLCJPcGVyYXRpb25hbEVycm9yIiwiY2FuQXR0YWNoVHJhY2UiLCJwcm9wZXJ0eUlzV3JpdGFibGUiLCJlbnN1cmVFcnJvck9iamVjdCIsImVyciIsImNsYXNzU3RyaW5nIiwidG9TdHJpbmciLCJjb3B5RGVzY3JpcHRvcnMiLCJmcm9tIiwidG8iLCJmaWx0ZXIiLCJnZXREZXNjcmlwdG9yIiwiYXNBcnJheSIsInYiLCJpc0FycmF5IiwiU3ltYm9sIiwiaXRlcmF0b3IiLCJBcnJheUZyb20iLCJpdCIsIml0UmVzdWx0IiwibmV4dCIsImRvbmUiLCJpc05vZGUiLCJwcm9jZXNzIiwidG9Mb3dlckNhc2UiLCJoYXNFbnZWYXJpYWJsZXMiLCJlbnYiLCJnZXROYXRpdmVQcm9taXNlIiwiUHJvbWlzZSIsInByb21pc2UiLCJkb21haW5CaW5kIiwiY2IiLCJiaW5kIiwiaGFzRGV2VG9vbHMiLCJjaHJvbWUiLCJsb2FkVGltZXMiLCJpc1JlY2VudE5vZGUiLCJ2ZXJzaW9uIiwidmVyc2lvbnMiLCJub2RlIiwic3BsaXQiLCJtYXAiLCJOdW1iZXIiLCJsYXN0TGluZUVycm9yIiwibW9kdWxlIiwiZXhwb3J0cyIsIkJsdWViaXJkUHJvbWlzZSIsImNvbmZpZyIsImxvbmdTdGFja1RyYWNlcyIsImRlZmF1bHQiLCJfQ2FuY2VsbGF0aW9uVG9rZW4iLCJfbG9hZF9DYW5jZWxsYXRpb25Ub2tlbiIsIkNhbmNlbGxhdGlvblRva2VuIiwiQ2FuY2VsbGF0aW9uRXJyb3IiLCJfaHR0cEV4ZWN1dG9yIiwiX2xvYWRfaHR0cEV4ZWN1dG9yIiwiSHR0cEVycm9yIiwiY3JlYXRlSHR0cEVycm9yIiwiSHR0cEV4ZWN1dG9yIiwiRGlnZXN0VHJhbnNmb3JtIiwic2FmZUdldEhlYWRlciIsImNvbmZpZ3VyZVJlcXVlc3RPcHRpb25zIiwiY29uZmlndXJlUmVxdWVzdE9wdGlvbnNGcm9tVXJsIiwic2FmZVN0cmluZ2lmeUpzb24iLCJwYXJzZUpzb24iLCJfcHVibGlzaE9wdGlvbnMiLCJfbG9hZF9wdWJsaXNoT3B0aW9ucyIsImdldFMzTGlrZVByb3ZpZGVyQmFzZVVybCIsImdpdGh1YlVybCIsIl9yZmMyMjUzUGFyc2VyIiwiX2xvYWRfcmZjMjI1M1BhcnNlciIsInBhcnNlRG4iLCJfdXVpZCIsIl9sb2FkX3V1aWQiLCJVVUlEIiwiX1Byb2dyZXNzQ2FsbGJhY2tUcmFuc2Zvcm0iLCJfbG9hZF9Qcm9ncmVzc0NhbGxiYWNrVHJhbnNmb3JtIiwiUHJvZ3Jlc3NDYWxsYmFja1RyYW5zZm9ybSIsIl94bWwiLCJfbG9hZF94bWwiLCJwYXJzZVhtbCIsIlhFbGVtZW50IiwibmV3RXJyb3IiLCJjb2RlIiwiZXJyb3IiLCJZQU1MRXhjZXB0aW9uIiwiVFlQRV9DT05TVFJVQ1RPUl9PUFRJT05TIiwiWUFNTF9OT0RFX0tJTkRTIiwiY29tcGlsZVN0eWxlQWxpYXNlcyIsInJlc3VsdCIsImZvckVhY2giLCJzdHlsZSIsImFsaWFzIiwiU3RyaW5nIiwiVHlwZSIsInRhZyIsIm9wdGlvbnMiLCJpbmRleE9mIiwia2luZCIsInJlc29sdmUiLCJjb25zdHJ1Y3QiLCJkYXRhIiwiaW5zdGFuY2VPZiIsInByZWRpY2F0ZSIsInJlcHJlc2VudCIsImRlZmF1bHRTdHlsZSIsInN0eWxlQWxpYXNlcyIsImZzIiwicG9seWZpbGxzIiwibGVnYWN5IiwicXVldWUiLCJ1dGlsIiwibm9vcCIsImRlYnVnIiwiZGVidWdsb2ciLCJOT0RFX0RFQlVHIiwibSIsImZvcm1hdCIsImpvaW4iLCJjb25zb2xlIiwib24iLCJlcXVhbCIsInBhdGNoIiwiVEVTVF9HUkFDRUZVTF9GU19HTE9CQUxfUEFUQ0giLCJjbG9zZSIsImZzJGNsb3NlIiwiZmQiLCJyZXRyeSIsImNsb3NlU3luYyIsImZzJGNsb3NlU3luYyIsInJ2YWwiLCJncmFjZWZ1bGlmeSIsIkZpbGVSZWFkU3RyZWFtIiwiUmVhZFN0cmVhbSIsIkZpbGVXcml0ZVN0cmVhbSIsIldyaXRlU3RyZWFtIiwiY3JlYXRlUmVhZFN0cmVhbSIsImNyZWF0ZVdyaXRlU3RyZWFtIiwiZnMkcmVhZEZpbGUiLCJyZWFkRmlsZSIsInBhdGgiLCJnbyRyZWFkRmlsZSIsImVucXVldWUiLCJmcyR3cml0ZUZpbGUiLCJ3cml0ZUZpbGUiLCJnbyR3cml0ZUZpbGUiLCJmcyRhcHBlbmRGaWxlIiwiYXBwZW5kRmlsZSIsImdvJGFwcGVuZEZpbGUiLCJmcyRyZWFkZGlyIiwicmVhZGRpciIsImFyZ3MiLCJnbyRyZWFkZGlyJGNiIiwiZ28kcmVhZGRpciIsImZpbGVzIiwic29ydCIsInN1YnN0ciIsImxlZ1N0cmVhbXMiLCJmcyRSZWFkU3RyZWFtIiwib3BlbiIsIlJlYWRTdHJlYW0kb3BlbiIsImZzJFdyaXRlU3RyZWFtIiwiV3JpdGVTdHJlYW0kb3BlbiIsInRoYXQiLCJmbGFncyIsIm1vZGUiLCJhdXRvQ2xvc2UiLCJkZXN0cm95IiwiZW1pdCIsInJlYWQiLCJmcyRvcGVuIiwiZ28kb3BlbiIsImVsZW0iLCJzaGlmdCIsImZyb21DYWxsYmFjayIsInJlamVjdCIsInJlcyIsImZyb21Qcm9taXNlIiwidGhlbiIsInUiLCJta2RpcnMiLCJta2RpcnNTeW5jIiwibWtkaXJwIiwibWtkaXJwU3luYyIsImVuc3VyZURpciIsImVuc3VyZURpclN5bmMiLCJVcGRhdGVyU2lnbmFsIiwiVVBEQVRFX0RPV05MT0FERUQiLCJET1dOTE9BRF9QUk9HUkVTUyIsIlByb3ZpZGVyIiwiTm9PcExvZ2dlciIsIkFwcFVwZGF0ZXIiLCJfQXBwVXBkYXRlciIsIl9sb2FkX0FwcFVwZGF0ZXIiLCJfYnVpbGRlclV0aWxSdW50aW1lIiwiX2xvYWRfYnVpbGRlclV0aWxSdW50aW1lIiwiX1Byb3ZpZGVyIiwiX2xvYWRfUHJvdmlkZXIiLCJnZXREZWZhdWx0Q2hhbm5lbE5hbWUiLCJnZXRDdXN0b21DaGFubmVsTmFtZSIsImdldEN1cnJlbnRQbGF0Zm9ybSIsImlzVXNlT2xkTWFjUHJvdmlkZXIiLCJnZXRDaGFubmVsRmlsZW5hbWUiLCJuZXdCYXNlVXJsIiwibmV3VXJsRnJvbUJhc2UiLCJfdXJsIiwiX2xvYWRfdXJsIiwiX2F1dG9VcGRhdGVyIiwiX2xvYWRfYXV0b1VwZGF0ZXIiLCJwbGF0Zm9ybSIsIk5zaXNVcGRhdGVyIiwiTWFjVXBkYXRlciIsIkFwcEltYWdlVXBkYXRlciIsImdldENoYW5uZWxGaWxlUHJlZml4IiwiY3VycmVudFBsYXRmb3JtIiwiYXJjaCIsIlRFU1RfVVBEQVRFUl9BUkNIIiwiYXJjaFN1ZmZpeCIsImNoYW5uZWwiLCJURVNUX1VQREFURVJfUExBVEZPUk0iLCJlbWl0dGVyIiwibG9naW4iLCJoYW5kbGVyIiwiYWRkSGFuZGxlciIsInByb2dyZXNzIiwidXBkYXRlRG93bmxvYWRlZCIsInVwZGF0ZUNhbmNlbGxlZCIsImlzTG9nRXZlbnQiLCJldmVudCIsImxvZyIsInVybCIsIlVSTCIsInBhdGhuYW1lIiwiZW5kc1dpdGgiLCJiYXNlVXJsIiwic2VhcmNoIiwiZnNFeHRyYSIsIm1ha2VGcyIsIm1ldGhvZE5hbWUiLCJtZXRob2QiLCJtYXRjaCIsInByb21pc2lmeSIsImNyZWF0ZUZpbGUiLCJlbnN1cmVGaWxlIiwiT2JqZWN0ZnJlZXplIiwiZnJlZXplIiwic3ViRXJyb3IiLCJuYW1lUHJvcGVydHkiLCJkZWZhdWx0TWVzc2FnZSIsIlN1YkVycm9yIiwiY2FwdHVyZVN0YWNrVHJhY2UiLCJfVHlwZUVycm9yIiwiX1JhbmdlRXJyb3IiLCJXYXJuaW5nIiwiVGltZW91dEVycm9yIiwiQWdncmVnYXRlRXJyb3IiLCJUeXBlRXJyb3IiLCJSYW5nZUVycm9yIiwibWV0aG9kcyIsImxldmVsIiwiaW5kZW50IiwibGluZXMiLCJqIiwiY2F1c2UiLCJzdGFjayIsImVycm9yVHlwZXMiLCJSZWplY3Rpb25FcnJvciIsInBhdGhFeGlzdHMiLCJhY2Nlc3MiLCJjYXRjaCIsInBhdGhFeGlzdHNTeW5jIiwiZXhpc3RzU3luYyIsImZpbmRGaWxlIiwicGFyc2VVcGRhdGVJbmZvIiwiZ2V0RmlsZUxpc3QiLCJyZXNvbHZlRmlsZXMiLCJfanNZYW1sIiwiX2xvYWRfanNZYW1sIiwiX21haW4iLCJfbG9hZF9tYWluIiwiZXhlY3V0b3IiLCJ1c2VNdWx0aXBsZVJhbmdlUmVxdWVzdCIsImZpbGVFeHRyYURvd25sb2FkSGVhZGVycyIsInNldFJlcXVlc3RIZWFkZXJzIiwicmVxdWVzdEhlYWRlcnMiLCJodHRwUmVxdWVzdCIsImhlYWRlcnMiLCJjYW5jZWxsYXRpb25Ub2tlbiIsInJlcXVlc3QiLCJjcmVhdGVSZXF1ZXN0T3B0aW9ucyIsImFzc2lnbiIsInByb3RvY29sIiwiaG9zdG5hbWUiLCJwb3J0IiwiZXh0ZW5zaW9uIiwibm90IiwiZmluZCIsImZpbGVJbmZvIiwic29tZSIsImV4dCIsInJhd0RhdGEiLCJjaGFubmVsRmlsZSIsImNoYW5uZWxGaWxlVXJsIiwic2FmZUxvYWQiLCJ1cGRhdGVJbmZvIiwic2hhNTEyIiwicGF0aFRyYW5zZm9ybWVyIiwicCIsInNoYTIiLCJpbmZvIiwicGFja2FnZXMiLCJwYWNrYWdlSW5mbyIsImlhMzIiLCJocmVmIiwicHJvcCIsImhhcyIsInByb3RvIiwiT2JqZWN0S2V5cyIsIm8iLCJPYmplY3RHZXREZXNjcmlwdG9yIiwiT2JqZWN0RGVmaW5lUHJvcGVydHkiLCJPYmplY3RGcmVlemUiLCJPYmplY3RHZXRQcm90b3R5cGVPZiIsIkFycmF5SXNBcnJheSIsImlzTm90aGluZyIsInN1YmplY3QiLCJ0b0FycmF5Iiwic2VxdWVuY2UiLCJleHRlbmQiLCJzb3VyY2UiLCJpbmRleCIsInNvdXJjZUtleXMiLCJyZXBlYXQiLCJzdHJpbmciLCJjeWNsZSIsImlzTmVnYXRpdmVaZXJvIiwibnVtYmVyIiwiTkVHQVRJVkVfSU5GSU5JVFkiLCJjb21tb24iLCJjb21waWxlTGlzdCIsInNjaGVtYSIsImV4Y2x1ZGUiLCJpbmNsdWRlIiwiaW5jbHVkZWRTY2hlbWEiLCJjdXJyZW50VHlwZSIsInByZXZpb3VzVHlwZSIsInByZXZpb3VzSW5kZXgiLCJ0eXBlIiwiY29tcGlsZU1hcCIsInNjYWxhciIsIm1hcHBpbmciLCJmYWxsYmFjayIsImNvbGxlY3RUeXBlIiwiU2NoZW1hIiwiZGVmaW5pdGlvbiIsImltcGxpY2l0IiwiZXhwbGljaXQiLCJsb2FkS2luZCIsImNvbXBpbGVkSW1wbGljaXQiLCJjb21waWxlZEV4cGxpY2l0IiwiY29tcGlsZWRUeXBlTWFwIiwiREVGQVVMVCIsImNyZWF0ZVNjaGVtYSIsInNjaGVtYXMiLCJ0eXBlcyIsImV2ZXJ5IiwicmVhc29uIiwibWFyayIsImNvbXBhY3QiLCJnZXRBcmciLCJhQXJncyIsImFOYW1lIiwiYURlZmF1bHRWYWx1ZSIsInVybFJlZ2V4cCIsImRhdGFVcmxSZWdleHAiLCJ1cmxQYXJzZSIsImFVcmwiLCJzY2hlbWUiLCJhdXRoIiwiaG9zdCIsInVybEdlbmVyYXRlIiwiYVBhcnNlZFVybCIsIm5vcm1hbGl6ZSIsImFQYXRoIiwiaXNBYnNvbHV0ZSIsInBhcnRzIiwicGFydCIsInVwIiwic3BsaWNlIiwiYVJvb3QiLCJhUGF0aFVybCIsImFSb290VXJsIiwiam9pbmVkIiwicmVwbGFjZSIsInJlbGF0aXZlIiwibGFzdEluZGV4T2YiLCJzbGljZSIsInN1cHBvcnRzTnVsbFByb3RvIiwiaWRlbnRpdHkiLCJzIiwidG9TZXRTdHJpbmciLCJhU3RyIiwiaXNQcm90b1N0cmluZyIsImZyb21TZXRTdHJpbmciLCJjaGFyQ29kZUF0IiwiY29tcGFyZUJ5T3JpZ2luYWxQb3NpdGlvbnMiLCJtYXBwaW5nQSIsIm1hcHBpbmdCIiwib25seUNvbXBhcmVPcmlnaW5hbCIsImNtcCIsInN0cmNtcCIsIm9yaWdpbmFsTGluZSIsIm9yaWdpbmFsQ29sdW1uIiwiZ2VuZXJhdGVkQ29sdW1uIiwiZ2VuZXJhdGVkTGluZSIsImNvbXBhcmVCeUdlbmVyYXRlZFBvc2l0aW9uc0RlZmxhdGVkIiwib25seUNvbXBhcmVHZW5lcmF0ZWQiLCJhU3RyMSIsImFTdHIyIiwiY29tcGFyZUJ5R2VuZXJhdGVkUG9zaXRpb25zSW5mbGF0ZWQiLCJwYXJzZVNvdXJjZU1hcElucHV0IiwiSlNPTiIsInBhcnNlIiwiY29tcHV0ZVNvdXJjZVVSTCIsInNvdXJjZVJvb3QiLCJzb3VyY2VVUkwiLCJzb3VyY2VNYXBVUkwiLCJwYXJzZWQiLCJzdWJzdHJpbmciLCJyaW1yYWYiLCJyZW1vdmUiLCJyZW1vdmVTeW5jIiwic3luYyIsImdldEZyb21FbnYiLCJwYXJzZUludCIsIkVMRUNUUk9OX0lTX0RFViIsImlzRW52U2V0IiwiZGVmYXVsdEFwcCIsImV4ZWNQYXRoIiwiX2JsdWViaXJkTHN0IiwiX2xvYWRfYmx1ZWJpcmRMc3QiLCJfYmx1ZWJpcmRMc3QyIiwiX2xvYWRfYmx1ZWJpcmRMc3QyIiwiX2ludGVyb3BSZXF1aXJlRGVmYXVsdCIsIl9jcnlwdG8iLCJfbG9hZF9jcnlwdG8iLCJfZWxlY3Ryb24iLCJfbG9hZF9lbGVjdHJvbiIsIl9lbGVjdHJvbklzRGV2IiwiX2xvYWRfZWxlY3Ryb25Jc0RldiIsIl9ldmVudHMiLCJfbG9hZF9ldmVudHMiLCJfZnNFeHRyYVAiLCJfbG9hZF9mc0V4dHJhUCIsIl9sYXp5VmFsIiwiX2xvYWRfbGF6eVZhbCIsIl9wYXRoIiwiX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQiLCJfc2VtdmVyIiwiX2xvYWRfc2VtdmVyIiwiX2VsZWN0cm9uSHR0cEV4ZWN1dG9yIiwiX2xvYWRfZWxlY3Ryb25IdHRwRXhlY3V0b3IiLCJfR2VuZXJpY1Byb3ZpZGVyIiwiX2xvYWRfR2VuZXJpY1Byb3ZpZGVyIiwiX3Byb3ZpZGVyRmFjdG9yeSIsIl9sb2FkX3Byb3ZpZGVyRmFjdG9yeSIsIl9fZXNNb2R1bGUiLCJuZXdPYmoiLCJFdmVudEVtaXR0ZXIiLCJhcHAiLCJhdXRvRG93bmxvYWQiLCJhbGxvd1ByZXJlbGVhc2UiLCJmdWxsQ2hhbmdlbG9nIiwiYWxsb3dEb3duZ3JhZGUiLCJfY2hhbm5lbCIsIl9sb2dnZXIiLCJzaWduYWxzIiwidXBkYXRlQXZhaWxhYmxlIiwic3RhZ2luZ1VzZXJJZFByb21pc2UiLCJMYXp5IiwiZ2V0T3JDcmVhdGVTdGFnaW5nVXNlcklkIiwiY29uZmlnT25EaXNrIiwibG9hZFVwZGF0ZUNvbmZpZyIsIl9fdGVzdF9hcHAiLCJ1bnRpbEFwcFJlYWR5IiwiaHR0cEV4ZWN1dG9yIiwiRWxlY3Ryb25IdHRwRXhlY3V0b3IiLCJhdXRoSW5mbyIsImNhbGxiYWNrIiwiaXNSZWFkeSIsImN1cnJlbnRWZXJzaW9uU3RyaW5nIiwiZ2V0VmVyc2lvbiIsImN1cnJlbnRWZXJzaW9uIiwidmFsaWQiLCJoYXNQcmVyZWxlYXNlQ29tcG9uZW50cyIsInNldEZlZWRVUkwiLCJsb2dnZXIiLCJ1cGRhdGVDb25maWdQYXRoIiwiY2xpZW50UHJvbWlzZSIsIl9hcHBVcGRhdGVDb25maWdQYXRoIiwicHJvdmlkZXIiLCJnZXRGZWVkVVJMIiwiR2VuZXJpY1Byb3ZpZGVyIiwiY3JlYXRlQ2xpZW50IiwiY2hlY2tGb3JVcGRhdGVzIiwiY2hlY2tGb3JVcGRhdGVzUHJvbWlzZSIsIl9jaGVja0ZvclVwZGF0ZXMiLCJudWxsaXplUHJvbWlzZSIsImNoZWNrRm9yVXBkYXRlc0FuZE5vdGlmeSIsIk5vdGlmaWNhdGlvbiIsInRpdGxlIiwiYm9keSIsImdldE5hbWUiLCJzaG93IiwiaXNTdGFnaW5nTWF0Y2giLCJfdGhpcyIsImNvcm91dGluZSIsInJhd1N0YWdpbmdQZXJjZW50YWdlIiwic3RhZ2luZ1BlcmNlbnRhZ2UiLCJpc05hTiIsIndhcm4iLCJzdGFnaW5nVXNlcklkIiwicmVhZFVJbnQzMkJFIiwicGVyY2VudGFnZSIsIl90aGlzMiIsImRvQ2hlY2tGb3JVcGRhdGVzIiwiY29tcHV0ZUZpbmFsSGVhZGVycyIsIl90aGlzMyIsImNsaWVudCIsImdldExhdGVzdFZlcnNpb24iLCJsYXRlc3RWZXJzaW9uIiwiZXEiLCJndCIsInZlcnNpb25JbmZvIiwib25VcGRhdGVBdmFpbGFibGUiLCJkb3dubG9hZFByb21pc2UiLCJkb3dubG9hZFVwZGF0ZSIsIl90aGlzNCIsImRpc3BhdGNoRXJyb3IiLCJkb0Rvd25sb2FkVXBkYXRlIiwiX3RoaXM1IiwiZ2V0QXBwUGF0aCIsInJlc291cmNlc1BhdGgiLCJjb21wdXRlUmVxdWVzdEhlYWRlcnMiLCJfdGhpczYiLCJBY2NlcHQiLCJfdGhpczciLCJmaWxlIiwiZ2V0UGF0aCIsImlkIiwiY2hlY2siLCJ2NSIsInJhbmRvbUJ5dGVzIiwiT0lEIiwib3V0cHV0RmlsZSIsInZlcnNpb25QcmVyZWxlYXNlQ29tcG9uZW50IiwicHJlcmVsZWFzZSIsImpzb25GaWxlIiwicmVhZEpzb24iLCJyZWFkSnNvblN5bmMiLCJyZWFkRmlsZVN5bmMiLCJ3cml0ZUpzb24iLCJ3cml0ZUpzb25TeW5jIiwid3JpdGVGaWxlU3luYyIsInlhbWwiLCJpbnN0YWxsIiwiY29tcHV0ZU9wZXJhdGlvbnMiLCJPcGVyYXRpb25LaW5kIiwib2xkQmxvY2tNYXAiLCJuZXdCbG9ja01hcCIsIm5hbWVUb09sZEJsb2NrcyIsImJ1aWxkQmxvY2tGaWxlTWFwIiwibmFtZVRvTmV3QmxvY2tzIiwib2xkRW50cnlNYXAiLCJidWlsZEVudHJ5TWFwIiwibGFzdE9wZXJhdGlvbiIsIm9wZXJhdGlvbnMiLCJibG9ja01hcEZpbGUiLCJvbGRFbnRyeSIsIkRPV05MT0FEIiwic3RhcnQiLCJvZmZzZXQiLCJlbmQiLCJzaXplcyIsInJlZHVjZSIsImFjY3VtdWxhdG9yIiwiY3VycmVudFZhbHVlIiwibmV3RmlsZSIsImNoYW5nZWRCbG9ja0NvdW50IiwiY2hlY2tzdW1Ub09mZnNldCIsImNoZWNrc3VtVG9PbGRPZmZzZXQiLCJjaGVja3N1bVRvT2xkU2l6ZSIsImJ1aWxkQ2hlY2tzdW1NYXAiLCJuZXdPZmZzZXQiLCJjaGVja3N1bXMiLCJibG9ja1NpemUiLCJjaGVja3N1bSIsIm9sZE9mZnNldCIsIkNPUFkiLCJmaWxlT2Zmc2V0IiwiTWFwIiwiY2hlY2tzdW1Ub1NpemUiLCJzaXplIiwibGlzdCIsIml0ZW0iLCJvcmlnaW5hbENvbnNvbGUiLCJ0cmFuc3BvcnQiLCJtc2ciLCJ0ZXh0IiwiRU9MIiwiZm9ybWF0VGltZVpvbmUiLCJwYWQiLCJzdHJpbmdpZnlBcnJheSIsImZvcm1hdHRlciIsImRhdGUiLCJnZXRGdWxsWWVhciIsImdldE1vbnRoIiwiZ2V0RGF0ZSIsImdldEhvdXJzIiwiZ2V0TWludXRlcyIsImdldFNlY29uZHMiLCJnZXRNaWxsaXNlY29uZHMiLCJnZXRUaW1lem9uZU9mZnNldCIsImZvcm1hdEVycm9ycyIsImFyZyIsInplcm9zIiwibWludXRlc09mZnNldCIsIk1hdGgiLCJhYnMiLCJmbG9vciIsIk5FWFRfRklMVEVSIiwiY2F0Y2hGaWx0ZXIiLCJpbnN0YW5jZXMiLCJib3VuZFRvIiwiX2JvdW5kVmFsdWUiLCJwcmVkaWNhdGVMb29wIiwibWF0Y2hlc1ByZWRpY2F0ZSIsImVycm9ycyIsImlzVW50eXBlZEVycm9yIiwickVycm9yS2V5Iiwid3JhcEFzT3BlcmF0aW9uYWxFcnJvciIsIm5vZGViYWNrRm9yUHJvbWlzZSIsIm11bHRpQXJncyIsIndyYXBwZWQiLCJfYXR0YWNoRXh0cmFUcmFjZSIsIl9yZWplY3QiLCJfZnVsZmlsbCIsIiRfbGVuIiwibWF4IiwiJF9pIiwicGFyZW50IiwicGFyZW50Q2FuY2VsSGFuZGxlciIsIl9jYW5jZWxsZWQiLCJjYW5jZWxsZWQiLCJfcGFyZW50IiwicmVtb3ZlUGFyZW50Q2FuY2VsSGFuZGxlciIsImNhbmNlbCIsIm9uQ2FuY2VsIiwib25jZSIsImNyZWF0ZVByb21pc2UiLCJjYW5jZWxIYW5kbGVyIiwiYWRkZWRDYW5jZWxIYW5kbGVyIiwiZmluYWxseSIsInJlbW92ZUxpc3RlbmVyIiwiZGlzcG9zZSIsInJlbW92ZUFsbExpc3RlbmVycyIsIl9kZWJ1ZzIiLCJfc3RyZWFtIiwiX2xvYWRfc3RyZWFtIiwiX2luZGV4IiwiX2xvYWRfaW5kZXgiLCJyZXNwb25zZSIsImRlc2NyaXB0aW9uIiwic3RhdHVzQ29kZSIsInN0YXR1c01lc3NhZ2UiLCJzdHJpbmdpZnkiLCJIVFRQX1NUQVRVU19DT0RFUyIsIm1heFJlZGlyZWN0cyIsImVuY29kZWREYXRhIiwiQnVmZmVyIiwiZG9BcGlSZXF1ZXN0IiwicmVxdWVzdFByb2Nlc3NvciIsInJlZGlyZWN0Q291bnQiLCJlbmFibGVkIiwiZG9SZXF1ZXN0IiwiaGFuZGxlUmVzcG9uc2UiLCJhZGRFcnJvckFuZFRpbWVvdXRIYW5kbGVycyIsImFkZFJlZGlyZWN0SGFuZGxlcnMiLCJhYm9ydCIsImFkZFRpbWVPdXRIYW5kbGVyIiwicmVkaXJlY3RVcmwiLCJwcmVwYXJlUmVkaXJlY3RVcmxPcHRpb25zIiwic2V0RW5jb2RpbmciLCJjaHVuayIsImNvbnRlbnRUeXBlIiwiaXNKc29uIiwiaW5jbHVkZXMiLCJkb0Rvd25sb2FkIiwicmVxdWVzdE9wdGlvbnMiLCJkZXN0aW5hdGlvbiIsImNvbmZpZ3VyZVBpcGVzIiwic29ja2V0Iiwic2V0VGltZW91dCIsIm5ld09wdGlvbnMiLCJBdXRob3JpemF0aW9uIiwic3RhcnRzV2l0aCIsInBhcnNlZE5ld1VybCIsInBhcnNlZFVybCIsIlRyYW5zZm9ybSIsImV4cGVjdGVkIiwiYWxnb3JpdGhtIiwiZW5jb2RpbmciLCJpc1ZhbGlkYXRlT25FbmQiLCJkaWdlc3RlciIsImNyZWF0ZUhhc2giLCJhY3R1YWwiLCJfYWN0dWFsIiwiX3RyYW5zZm9ybSIsInVwZGF0ZSIsIl9mbHVzaCIsImRpZ2VzdCIsInZhbGlkYXRlIiwiY2hlY2tTaGEyIiwic2hhMkhlYWRlciIsImhlYWRlcktleSIsInN0cmVhbXMiLCJvblByb2dyZXNzIiwiY29udGVudExlbmd0aCIsImZpbGVPdXQiLCJsYXN0U3RyZWFtIiwic3RyZWFtIiwicGlwZSIsInRva2VuIiwiYXV0aG9yaXphdGlvbiIsImVsZWN0cm9uIiwic2tpcHBlZE5hbWVzIiwiY3JlYXRlRGVidWciLCJjb2VyY2UiLCJkaXNhYmxlIiwiZW5hYmxlIiwiaHVtYW5pemUiLCJza2lwcyIsImZvcm1hdHRlcnMiLCJzZWxlY3RDb2xvciIsIm5hbWVzcGFjZSIsImhhc2giLCJjb2xvcnMiLCJwcmV2VGltZSIsImN1cnIiLCJEYXRlIiwibXMiLCJkaWZmIiwicHJldiIsInVuc2hpZnQiLCJmb3JtYXRBcmdzIiwibG9nRm4iLCJ1c2VDb2xvcnMiLCJjb2xvciIsImluaXQiLCJuYW1lc3BhY2VzIiwic2F2ZSIsIlJlZ0V4cCIsImluc3RhbmNlIiwiYXBpIiwiZXhpc3RzIiwiZmlsZW5hbWUiLCJidWZmZXIiLCJwb3NpdGlvbiIsImJ5dGVzUmVhZCIsIndyaXRlIiwiYSIsImIiLCJjIiwiYnl0ZXNXcml0dGVuIiwiY2xvbmUiLCJjb3B5IiwiX19wcm90b19fIiwidXRpbWVzIiwidXRpbWVzTWlsbGlzIiwibm90RXhpc3QiLCJleGlzdHNSZWciLCJzcmMiLCJkZXN0Iiwib3B0cyIsImNsb2JiZXIiLCJvdmVyd3JpdGUiLCJwcmVzZXJ2ZVRpbWVzdGFtcHMiLCJoYW5kbGVGaWx0ZXIiLCJjaGVja1BhcmVudERpciIsImRlc3RQYXJlbnQiLCJkaXJuYW1lIiwiZGlyRXhpc3RzIiwic3RhcnRDb3B5IiwiZ2V0U3RhdHMiLCJvbkluY2x1ZGUiLCJzdGF0IiwiZGVyZWZlcmVuY2UiLCJsc3RhdCIsInN0IiwiaXNEaXJlY3RvcnkiLCJvbkRpciIsImlzRmlsZSIsImlzQ2hhcmFjdGVyRGV2aWNlIiwiaXNCbG9ja0RldmljZSIsIm9uRmlsZSIsImlzU3ltYm9saWNMaW5rIiwib25MaW5rIiwic3JjU3RhdCIsImNoZWNrRGVzdCIsInJlc29sdmVkUGF0aCIsImNvcHlGaWxlIiwibWF5Q29weUZpbGUiLCJ1bmxpbmsiLCJlcnJvck9uRXhpc3QiLCJzZXREZXN0TW9kZUFuZFRpbWVzdGFtcHMiLCJjb3B5RmlsZUZhbGxiYWNrIiwicnMiLCJ3cyIsImNobW9kIiwiYXRpbWUiLCJtdGltZSIsImlzU3JjU3ViZGlyIiwibWtEaXJBbmRDb3B5IiwibWF5Q29weURpciIsImNvcHlEaXIiLCJta2RpciIsIml0ZW1zIiwiY29weURpckl0ZW1zIiwicG9wIiwicmVhZGxpbmsiLCJyZXNvbHZlZFNyY1BhdGgiLCJjd2QiLCJyZXNvbHZlZERlc3RQYXRoIiwic3ltbGluayIsImNvcHlMaW5rIiwiYmFzZURpciIsInNlcCIsImRlc3RCYXNlbmFtZSIsImJhc2VuYW1lIiwiZ2V0Um9vdFBhdGgiLCJJTlZBTElEX1BBVEhfQ0hBUlMiLCJpbnZhbGlkV2luMzJQYXRoIiwicnAiLCJvcyIsImhhc01pbGxpc1Jlc1N5bmMiLCJ0bXBmaWxlIiwibm93IiwicmFuZG9tIiwidG1wZGlyIiwiZCIsIm9wZW5TeW5jIiwiZnV0aW1lc1N5bmMiLCJzdGF0U3luYyIsImhhc01pbGxpc1JlcyIsImZ1dGltZXMiLCJzdGF0cyIsInRpbWVSZW1vdmVNaWxsaXMiLCJ0aW1lc3RhbXAiLCJnZXRUaW1lIiwiZnV0aW1lc0VyciIsImNsb3NlRXJyIiwidXRpbWVzTWlsbGlzU3luYyIsImNvcHlTeW5jIiwiYWxsb2NVbnNhZmUiLCJ0b3RhbCIsInRyYW5zZmVycmVkIiwiZGVsdGEiLCJuZXh0VXBkYXRlIiwicGVyY2VudCIsImJ5dGVzUGVyU2Vjb25kIiwicm91bmQiLCJTZW1WZXIiLCJTRU1WRVJfU1BFQ19WRVJTSU9OIiwiTUFYX0xFTkdUSCIsIk1BWF9TQUZFX0lOVEVHRVIiLCJyZSIsIlIiLCJOVU1FUklDSURFTlRJRklFUiIsIk5VTUVSSUNJREVOVElGSUVSTE9PU0UiLCJOT05OVU1FUklDSURFTlRJRklFUiIsIk1BSU5WRVJTSU9OIiwiTUFJTlZFUlNJT05MT09TRSIsIlBSRVJFTEVBU0VJREVOVElGSUVSIiwiUFJFUkVMRUFTRUlERU5USUZJRVJMT09TRSIsIlBSRVJFTEVBU0UiLCJQUkVSRUxFQVNFTE9PU0UiLCJCVUlMRElERU5USUZJRVIiLCJCVUlMRCIsIkZVTEwiLCJGVUxMUExBSU4iLCJMT09TRVBMQUlOIiwiTE9PU0UiLCJHVExUIiwiWFJBTkdFSURFTlRJRklFUkxPT1NFIiwiWFJBTkdFSURFTlRJRklFUiIsIlhSQU5HRVBMQUlOIiwiWFJBTkdFUExBSU5MT09TRSIsIlhSQU5HRSIsIlhSQU5HRUxPT1NFIiwiTE9ORVRJTERFIiwiVElMREVUUklNIiwidGlsZGVUcmltUmVwbGFjZSIsIlRJTERFIiwiVElMREVMT09TRSIsIkxPTkVDQVJFVCIsIkNBUkVUVFJJTSIsImNhcmV0VHJpbVJlcGxhY2UiLCJDQVJFVCIsIkNBUkVUTE9PU0UiLCJDT01QQVJBVE9STE9PU0UiLCJDT01QQVJBVE9SIiwiQ09NUEFSQVRPUlRSSU0iLCJjb21wYXJhdG9yVHJpbVJlcGxhY2UiLCJIWVBIRU5SQU5HRSIsIkhZUEhFTlJBTkdFTE9PU0UiLCJTVEFSIiwibG9vc2UiLCJlciIsImNsZWFuIiwidHJpbSIsInJhdyIsIm1ham9yIiwibWlub3IiLCJudW0iLCJidWlsZCIsImNvbXBhcmUiLCJvdGhlciIsImNvbXBhcmVNYWluIiwiY29tcGFyZVByZSIsImNvbXBhcmVJZGVudGlmaWVycyIsImluYyIsInJlbGVhc2UiLCJpZGVudGlmaWVyIiwidmVyc2lvbjEiLCJ2ZXJzaW9uMiIsInYxIiwidjIiLCJudW1lcmljIiwiYW51bSIsImJudW0iLCJyY29tcGFyZUlkZW50aWZpZXJzIiwiY29tcGFyZUxvb3NlIiwicmNvbXBhcmUiLCJyc29ydCIsImx0IiwibmVxIiwiZ3RlIiwibHRlIiwib3AiLCJDb21wYXJhdG9yIiwiY29tcCIsInNlbXZlciIsIkFOWSIsIm9wZXJhdG9yIiwiaW50ZXJzZWN0cyIsInJhbmdlVG1wIiwiUmFuZ2UiLCJzYXRpc2ZpZXMiLCJzYW1lRGlyZWN0aW9uSW5jcmVhc2luZyIsInNhbWVEaXJlY3Rpb25EZWNyZWFzaW5nIiwic2FtZVNlbVZlciIsImRpZmZlcmVudERpcmVjdGlvbnNJbmNsdXNpdmUiLCJvcHBvc2l0ZURpcmVjdGlvbnNMZXNzVGhhbiIsIm9wcG9zaXRlRGlyZWN0aW9uc0dyZWF0ZXJUaGFuIiwicmFuZ2UiLCJwYXJzZVJhbmdlIiwiY29tcHMiLCJociIsImh5cGhlblJlcGxhY2UiLCJjb21wUmUiLCJwYXJzZUNvbXBhcmF0b3IiLCJ0aGlzQ29tcGFyYXRvcnMiLCJ0aGlzQ29tcGFyYXRvciIsInJhbmdlQ29tcGFyYXRvcnMiLCJyYW5nZUNvbXBhcmF0b3IiLCJ0b0NvbXBhcmF0b3JzIiwicmVwbGFjZUNhcmV0cyIsInJlcGxhY2VUaWxkZXMiLCJyZXBsYWNlWFJhbmdlcyIsInJlcGxhY2VTdGFycyIsImlzWCIsInJlcGxhY2VUaWxkZSIsIl8iLCJNIiwicHIiLCJyZXBsYWNlQ2FyZXQiLCJyZXBsYWNlWFJhbmdlIiwiZ3RsdCIsInhNIiwieG0iLCJ4cCIsImFueVgiLCIkMCIsImZNIiwiZm0iLCJmcCIsImZwciIsImZiIiwidE0iLCJ0bSIsInRwIiwidHByIiwidGIiLCJ0ZXN0U2V0IiwiYWxsb3dlZCIsIm1heFNhdGlzZnlpbmciLCJtYXhTViIsInJhbmdlT2JqIiwibWluU2F0aXNmeWluZyIsIm1pbiIsIm1pblNWIiwidmFsaWRSYW5nZSIsImx0ciIsIm91dHNpZGUiLCJndHIiLCJoaWxvIiwiZ3RmbiIsImx0ZWZuIiwibHRmbiIsImVjb21wIiwiY29tcGFyYXRvcnMiLCJoaWdoIiwibG93IiwiY29tcGFyYXRvciIsInIxIiwicjIiLCJiYXNlNjRWTFEiLCJBcnJheVNldCIsIk1hcHBpbmdMaXN0IiwiU291cmNlTWFwR2VuZXJhdG9yIiwiX2ZpbGUiLCJfc291cmNlUm9vdCIsIl9za2lwVmFsaWRhdGlvbiIsIl9zb3VyY2VzIiwiX25hbWVzIiwiX21hcHBpbmdzIiwiX3NvdXJjZXNDb250ZW50cyIsIl92ZXJzaW9uIiwiZnJvbVNvdXJjZU1hcCIsIlNvdXJjZU1hcEdlbmVyYXRvcl9mcm9tU291cmNlTWFwIiwiYVNvdXJjZU1hcENvbnN1bWVyIiwiZ2VuZXJhdG9yIiwiZWFjaE1hcHBpbmciLCJuZXdNYXBwaW5nIiwiZ2VuZXJhdGVkIiwibGluZSIsImNvbHVtbiIsIm9yaWdpbmFsIiwiYWRkTWFwcGluZyIsInNvdXJjZXMiLCJzb3VyY2VGaWxlIiwic291cmNlUmVsYXRpdmUiLCJhZGQiLCJjb250ZW50Iiwic291cmNlQ29udGVudEZvciIsInNldFNvdXJjZUNvbnRlbnQiLCJTb3VyY2VNYXBHZW5lcmF0b3JfYWRkTWFwcGluZyIsIl92YWxpZGF0ZU1hcHBpbmciLCJTb3VyY2VNYXBHZW5lcmF0b3Jfc2V0U291cmNlQ29udGVudCIsImFTb3VyY2VGaWxlIiwiYVNvdXJjZUNvbnRlbnQiLCJhcHBseVNvdXJjZU1hcCIsIlNvdXJjZU1hcEdlbmVyYXRvcl9hcHBseVNvdXJjZU1hcCIsImFTb3VyY2VNYXBQYXRoIiwibmV3U291cmNlcyIsIm5ld05hbWVzIiwidW5zb3J0ZWRGb3JFYWNoIiwib3JpZ2luYWxQb3NpdGlvbkZvciIsIlNvdXJjZU1hcEdlbmVyYXRvcl92YWxpZGF0ZU1hcHBpbmciLCJhR2VuZXJhdGVkIiwiYU9yaWdpbmFsIiwiYVNvdXJjZSIsIl9zZXJpYWxpemVNYXBwaW5ncyIsIlNvdXJjZU1hcEdlbmVyYXRvcl9zZXJpYWxpemVNYXBwaW5ncyIsInByZXZpb3VzR2VuZXJhdGVkQ29sdW1uIiwicHJldmlvdXNHZW5lcmF0ZWRMaW5lIiwicHJldmlvdXNPcmlnaW5hbENvbHVtbiIsInByZXZpb3VzT3JpZ2luYWxMaW5lIiwicHJldmlvdXNOYW1lIiwicHJldmlvdXNTb3VyY2UiLCJuYW1lSWR4Iiwic291cmNlSWR4IiwibWFwcGluZ3MiLCJlbmNvZGUiLCJfZ2VuZXJhdGVTb3VyY2VzQ29udGVudCIsIlNvdXJjZU1hcEdlbmVyYXRvcl9nZW5lcmF0ZVNvdXJjZXNDb250ZW50IiwiYVNvdXJjZXMiLCJhU291cmNlUm9vdCIsInRvSlNPTiIsIlNvdXJjZU1hcEdlbmVyYXRvcl90b0pTT04iLCJzb3VyY2VzQ29udGVudCIsIlNvdXJjZU1hcEdlbmVyYXRvcl90b1N0cmluZyIsImJhc2U2NCIsIlZMUV9CQVNFX1NISUZUIiwiVkxRX0JBU0UiLCJWTFFfQkFTRV9NQVNLIiwiVkxRX0NPTlRJTlVBVElPTl9CSVQiLCJ0b1ZMUVNpZ25lZCIsImFWYWx1ZSIsImZyb21WTFFTaWduZWQiLCJpc05lZ2F0aXZlIiwic2hpZnRlZCIsImJhc2U2NFZMUV9lbmNvZGUiLCJlbmNvZGVkIiwiZGlnaXQiLCJ2bHEiLCJkZWNvZGUiLCJiYXNlNjRWTFFfZGVjb2RlIiwiYUluZGV4IiwiYU91dFBhcmFtIiwic3RyTGVuIiwiY29udGludWF0aW9uIiwicmVzdCIsImhhc05hdGl2ZU1hcCIsIl9hcnJheSIsIl9zZXQiLCJmcm9tQXJyYXkiLCJBcnJheVNldF9mcm9tQXJyYXkiLCJhQXJyYXkiLCJhQWxsb3dEdXBsaWNhdGVzIiwiQXJyYXlTZXRfc2l6ZSIsIkFycmF5U2V0X2FkZCIsInNTdHIiLCJpc0R1cGxpY2F0ZSIsImlkeCIsIkFycmF5U2V0X2hhcyIsIkFycmF5U2V0X2luZGV4T2YiLCJhdCIsIkFycmF5U2V0X2F0IiwiYUlkeCIsIkFycmF5U2V0X3RvQXJyYXkiLCJjb25maWd1cmF0aW9uIiwidXBkYXRlciIsImNoYW5uZWxVcmwiLCJhdHRlbXB0TnVtYmVyIiwicmVsZWFzZUpzb25VcmwiLCJHaXRIdWJQcm92aWRlciIsIkJhc2VHaXRIdWJQcm92aWRlciIsImNvbXB1dGVSZWxlYXNlTm90ZXMiLCJkZWZhdWx0SG9zdCIsImNvbXB1dGVHaXRodWJCYXNlUGF0aCIsImJhc2VQYXRoIiwiZmVlZFhtbCIsImZlZWQiLCJsYXRlc3RSZWxlYXNlIiwiZWxlbWVudCIsImF0dHJpYnV0ZSIsImdldExhdGVzdFZlcnNpb25TdHJpbmciLCJnZXRCYXNlRG93bmxvYWRQYXRoIiwicmVsZWFzZU5hbWUiLCJlbGVtZW50VmFsdWVPckVtcHR5IiwicmVsZWFzZU5vdGVzIiwicmVsZWFzZUluZm8iLCJ0YWdfbmFtZSIsIm93bmVyIiwicmVwbyIsImZpbGVOYW1lIiwidlByZWZpeGVkVGFnTmFtZSIsImdldE5vdGVWYWx1ZSIsImlzRnVsbENoYW5nZWxvZyIsImdldEVsZW1lbnRzIiwidmVyc2lvblJlbGVhc2UiLCJub3RlIiwiQmFzZVVwZGF0ZXIiLCJfb3MiLCJfbG9hZF9vcyIsIl9Eb3dubG9hZGVkVXBkYXRlSGVscGVyIiwiX2xvYWRfRG93bmxvYWRlZFVwZGF0ZUhlbHBlciIsImRvd25sb2FkZWRVcGRhdGVIZWxwZXIiLCJEb3dubG9hZGVkVXBkYXRlSGVscGVyIiwicXVpdEFuZEluc3RhbGxDYWxsZWQiLCJxdWl0SGFuZGxlckFkZGVkIiwicXVpdEFuZEluc3RhbGwiLCJpc1NpbGVudCIsImlzRm9yY2VSdW5BZnRlciIsInNldEltbWVkaWF0ZSIsInF1aXQiLCJleGVjdXRlRG93bmxvYWQiLCJkb3dubG9hZE9wdGlvbnMiLCJ0YXNrIiwibGlzdGVuZXJDb3VudCIsInRlbXBEaXIiLCJta2R0ZW1wIiwiVEVTVF9BUFBfVE1QX0RJUiIsInJlbW92ZVRlbXBEaXJJZkFueSIsImNsZWFyIiwiZGVzdGluYXRpb25GaWxlIiwicG9zaXgiLCJpc1J1bkFmdGVyIiwiaW5zdGFsbGVyUGF0aCIsImRvSW5zdGFsbCIsImFkZFF1aXRIYW5kbGVyIiwiRmlsZVdpdGhFbWJlZGRlZEJsb2NrTWFwRGlmZmVyZW50aWFsRG93bmxvYWRlciIsIl9ibG9ja01hcEFwaSIsIl9sb2FkX2Jsb2NrTWFwQXBpIiwiX0RpZmZlcmVudGlhbERvd25sb2FkZXIiLCJfbG9hZF9EaWZmZXJlbnRpYWxEb3dubG9hZGVyIiwiRGlmZmVyZW50aWFsRG93bmxvYWRlciIsImRvd25sb2FkIiwiYmxvY2tBd2FyZUZpbGVJbmZvIiwiZmlsZVNpemUiLCJibG9ja01hcFNpemUiLCJmaWxlTWV0YWRhdGFCdWZmZXIiLCJyZWFkUmVtb3RlQnl0ZXMiLCJyZWFkQmxvY2tNYXAiLCJyZWFkRW1iZWRkZWRCbG9ja01hcERhdGEiLCJvbGRGaWxlIiwiQkxPQ0tfTUFQX0ZJTEVfTkFNRSIsIl9yZWYiLCJmc3RhdCIsInNpemVCdWZmZXIiLCJkYXRhQnVmZmVyIiwiaW5mbGF0ZVJhdyIsIl94IiwiRGlmZmVyZW50aWFsRG93bmxvYWRlck9wdGlvbnMiLCJfRGF0YVNwbGl0dGVyIiwiX2xvYWRfRGF0YVNwbGl0dGVyIiwiX2Rvd25sb2FkUGxhbkJ1aWxkZXIiLCJfbG9hZF9kb3dubG9hZFBsYW5CdWlsZGVyIiwiX211bHRpcGxlUmFuZ2VEb3dubG9hZGVyIiwiX2xvYWRfbXVsdGlwbGVSYW5nZURvd25sb2FkZXIiLCJiYXNlUmVxdWVzdE9wdGlvbnMiLCJuZXdVcmwiLCJzaWduYXR1cmVTaXplIiwiZG93bmxvYWRTaXplIiwiY29weVNpemUiLCJvcGVyYXRpb24iLCJuZXdQYWNrYWdlU2l6ZSIsImZvcm1hdEJ5dGVzIiwiZG93bmxvYWRGaWxlIiwidGFza3MiLCJzaWduYXR1cmUiLCJvbGRGaWxlRmQiLCJuZXdGaWxlRmQiLCJkaWdlc3RUcmFuc2Zvcm0iLCJmaXJzdFN0cmVhbSIsInciLCJleGVjdXRlVGFza3MiLCJhdHRlbXB0Q291bnQiLCJhY3R1YWxVcmwiLCJjb3B5RGF0YSIsInJlZGlyZWN0IiwicmVtb3ZlUXVlcnkiLCJmb2xsb3dSZWRpcmVjdCIsImVuZEluY2x1c2l2ZSIsImRhdGFIYW5kbGVyIiwiY2hlY2tJc1Jhbmdlc1N1cHBvcnRlZCIsInN5bWJvbCIsIkludGwiLCJOdW1iZXJGb3JtYXQiLCJ0b0ZpeGVkIiwiRGF0YVNwbGl0dGVyIiwiRE9VQkxFX0NSTEYiLCJSZWFkU3RhdGUiLCJvdXQiLCJyZWFkU3RyZWFtIiwiV3JpdGFibGUiLCJwYXJ0SW5kZXhUb1Rhc2tJbmRleCIsImJvdW5kYXJ5IiwicGFydEluZGV4VG9MZW5ndGgiLCJmaW5pc2hIYW5kbGVyIiwicGFydEluZGV4IiwiaGVhZGVyTGlzdEJ1ZmZlciIsInJlYWRTdGF0ZSIsIklOSVQiLCJpZ25vcmVCeXRlQ291bnQiLCJyZW1haW5pbmdQYXJ0RGF0YUNvdW50IiwiYWN0dWFsUGFydExlbmd0aCIsImJvdW5kYXJ5TGVuZ3RoIiwiaXNGaW5pc2hlZCIsIl93cml0ZSIsImhhbmRsZURhdGEiLCJ0b0lnbm9yZSIsInRvUmVhZCIsInByb2Nlc3NQYXJ0RGF0YSIsIkhFQURFUiIsImhlYWRlckxpc3RFbmQiLCJzZWFyY2hIZWFkZXJMaXN0RW5kIiwiQk9EWSIsInRhc2tJbmRleCIsInByZXZUYXNrSW5kZXgiLCJjb3B5RXhpc3RpbmdEYXRhIiwib25QYXJ0RW5kIiwicGFydExlbmd0aCIsImVmZmVjdGl2ZUVuZCIsInByb2Nlc3NQYXJ0U3RhcnRlZCIsInJlYWRPZmZzZXQiLCJwYXJ0aWFsQ2h1bmsiLCJjb25jYXQiLCJleHBlY3RlZExlbmd0aCIsImNvbnRleHQiLCJ2ZXJib3NlIiwic2lsbHkiLCJtYWtlU2VsZlJlc29sdXRpb25FcnJvciIsInJlZmxlY3RIYW5kbGVyIiwiUHJvbWlzZUluc3BlY3Rpb24iLCJfdGFyZ2V0IiwiYXBpUmVqZWN0aW9uIiwiUHJveHlhYmxlIiwiVU5ERUZJTkVEX0JJTkRJTkciLCJnZXREb21haW4iLCJkb21haW4iLCJBc3luYyIsImFzeW5jIiwiSU5URVJOQUwiLCJBUFBMWSIsInRyeUNvbnZlcnRUb1Byb21pc2UiLCJQcm9taXNlQXJyYXkiLCJDb250ZXh0IiwiY3JlYXRlQ29udGV4dCIsIkNhcHR1cmVkVHJhY2UiLCJQYXNzVGhyb3VnaEhhbmRsZXJDb250ZXh0IiwiX2JpdEZpZWxkIiwiX2Z1bGZpbGxtZW50SGFuZGxlcjAiLCJfcmVqZWN0aW9uSGFuZGxlcjAiLCJfcHJvbWlzZTAiLCJfcmVjZWl2ZXIwIiwiX3Jlc29sdmVGcm9tRXhlY3V0b3IiLCJfcHJvbWlzZUNyZWF0ZWQiLCJfZmlyZUV2ZW50IiwiY2F1Z2h0IiwiY2F0Y2hJbnN0YW5jZXMiLCJyZWZsZWN0IiwiX3RoZW4iLCJkaWRGdWxmaWxsIiwiZGlkUmVqZWN0Iiwid2FybmluZ3MiLCJfd2FybiIsIl9zZXRJc0ZpbmFsIiwic3ByZWFkIiwiYWxsIiwiaXNGdWxmaWxsZWQiLCJpc1JlamVjdGVkIiwiZnVsZmlsbG1lbnRWYWx1ZSIsInJlamVjdGlvblJlYXNvbiIsImdldE5ld0xpYnJhcnlDb3B5IiwiaXMiLCJmcm9tTm9kZSIsIl9jYXB0dXJlU3RhY2tUcmFjZSIsIl9yZWplY3RDYWxsYmFjayIsIl9pc0ZhdGVTZWFsZWQiLCJfc2V0QXN5bmNHdWFyYW50ZWVkIiwicHJvbWlzZXMiLCJjYXN0IiwiX3NldEZ1bGZpbGxlZCIsImZ1bGZpbGxlZCIsInJlamVjdGVkIiwic2V0U2NoZWR1bGVyIiwicmVjZWl2ZXIiLCJpbnRlcm5hbERhdGEiLCJoYXZlSW50ZXJuYWxEYXRhIiwiYml0RmllbGQiLCJfcHJvcGFnYXRlRnJvbSIsIl9ib3VuZFRvIiwic2V0dGxlciIsIl9zZXR0bGVQcm9taXNlQ3R4IiwiX3Vuc2V0UmVqZWN0aW9uSXNVbmhhbmRsZWQiLCJfc2V0dGxlUHJvbWlzZUxhdGVDYW5jZWxsYXRpb25PYnNlcnZlciIsImludm9rZSIsIl9hZGRDYWxsYmFja3MiLCJfbGVuZ3RoIiwiX2lzRm9sbG93aW5nIiwiX3NldExlbmd0aCIsIl9zZXRSZWplY3RlZCIsIl9zZXRGb2xsb3dpbmciLCJfaXNGaW5hbCIsIl91bnNldENhbmNlbGxlZCIsIl9zZXRDYW5jZWxsZWQiLCJfc2V0V2lsbEJlQ2FuY2VsbGVkIiwiaGFzQ3VzdG9tU2NoZWR1bGVyIiwiX3JlY2VpdmVyQXQiLCJfaXNCb3VuZCIsIl9wcm9taXNlQXQiLCJfZnVsZmlsbG1lbnRIYW5kbGVyQXQiLCJfcmVqZWN0aW9uSGFuZGxlckF0IiwiX21pZ3JhdGVDYWxsYmFjazAiLCJmb2xsb3dlciIsImZ1bGZpbGwiLCJfbWlncmF0ZUNhbGxiYWNrQXQiLCJiYXNlIiwiX3Byb3h5IiwicHJveHlhYmxlIiwiX3Jlc29sdmVDYWxsYmFjayIsInNob3VsZEJpbmQiLCJtYXliZVByb21pc2UiLCJfc2V0Rm9sbG93ZWUiLCJfdmFsdWUiLCJfcmVhc29uIiwic3luY2hyb25vdXMiLCJpZ25vcmVOb25FcnJvcldhcm5pbmdzIiwidHJhY2UiLCJoYXNTdGFjayIsIl9wdXNoQ29udGV4dCIsIl9leGVjdXRlIiwiX3BvcENvbnRleHQiLCJfc2V0dGxlUHJvbWlzZUZyb21IYW5kbGVyIiwieCIsInByb21pc2VDcmVhdGVkIiwiY2hlY2tGb3Jnb3R0ZW5SZXR1cm5zIiwiX2ZvbGxvd2VlIiwiX3NldHRsZVByb21pc2UiLCJpc1Byb21pc2UiLCJhc3luY0d1YXJhbnRlZWQiLCJfaW52b2tlSW50ZXJuYWxPbkNhbmNlbCIsImlzRmluYWxseUhhbmRsZXIiLCJjYW5jZWxQcm9taXNlIiwiX3Byb21pc2VDYW5jZWxsZWQiLCJfY2FuY2VsIiwiX2lzUmVzb2x2ZWQiLCJfcHJvbWlzZUZ1bGZpbGxlZCIsIl9wcm9taXNlUmVqZWN0ZWQiLCJjdHgiLCJfc2V0dGxlUHJvbWlzZTAiLCJfY2xlYXJDYWxsYmFja0RhdGFBdEluZGV4IiwiX3NldHRsZVByb21pc2VzIiwic2V0dGxlUHJvbWlzZXMiLCJmYXRhbEVycm9yIiwiX2Vuc3VyZVBvc3NpYmxlUmVqZWN0aW9uSGFuZGxlZCIsIl9mdWxmaWxsUHJvbWlzZXMiLCJfcmVqZWN0UHJvbWlzZXMiLCJfY2xlYXJDYW5jZWxsYXRpb25EYXRhIiwiX3NldHRsZWRWYWx1ZSIsImRlZmVyUmVzb2x2ZSIsImRlZmVyUmVqZWN0IiwiZGVmZXIiLCJwZW5kaW5nIiwiZGVwcmVjYXRlZCIsImZpbGxUeXBlcyIsInNldEJvdW5kcyIsImZpcnN0TGluZUVycm9yIiwic2NoZWR1bGUiLCJRdWV1ZSIsIl9jdXN0b21TY2hlZHVsZXIiLCJfaXNUaWNrVXNlZCIsIl9sYXRlUXVldWUiLCJfbm9ybWFsUXVldWUiLCJfaGF2ZURyYWluZWRRdWV1ZXMiLCJfdHJhbXBvbGluZUVuYWJsZWQiLCJkcmFpblF1ZXVlcyIsIl9kcmFpblF1ZXVlcyIsIl9zY2hlZHVsZSIsImVuYWJsZVRyYW1wb2xpbmUiLCJkaXNhYmxlVHJhbXBvbGluZUlmTmVjZXNzYXJ5IiwiaGF2ZUl0ZW1zUXVldWVkIiwic3RkZXJyIiwiZXhpdCIsInRocm93TGF0ZXIiLCJBc3luY0ludm9rZUxhdGVyIiwiX3F1ZXVlVGljayIsIkFzeW5jSW52b2tlIiwiQXN5bmNTZXR0bGVQcm9taXNlcyIsIl9wdXNoT25lIiwiaW52b2tlTGF0ZXIiLCJfZHJhaW5RdWV1ZSIsIl9yZXNldCIsIm5vQXN5bmNTY2hlZHVsZXIiLCJOYXRpdmVQcm9taXNlIiwiTXV0YXRpb25PYnNlcnZlciIsIkdsb2JhbFNldEltbWVkaWF0ZSIsIlByb2Nlc3NOZXh0VGljayIsIm5leHRUaWNrIiwibmF0aXZlUHJvbWlzZSIsInN0YW5kYWxvbmUiLCJjb3Jkb3ZhIiwiZGl2IiwiZG9jdW1lbnQiLCJjcmVhdGVFbGVtZW50IiwiYXR0cmlidXRlcyIsInRvZ2dsZVNjaGVkdWxlZCIsImRpdjIiLCJvMiIsImNsYXNzTGlzdCIsInRvZ2dsZSIsIm9ic2VydmUiLCJzY2hlZHVsZVRvZ2dsZSIsImRpc2Nvbm5lY3QiLCJhcnJheU1vdmUiLCJzcmNJbmRleCIsImRzdCIsImRzdEluZGV4IiwiY2FwYWNpdHkiLCJfY2FwYWNpdHkiLCJfZnJvbnQiLCJfd2lsbEJlT3ZlckNhcGFjaXR5IiwiX2NoZWNrQ2FwYWNpdHkiLCJ3cmFwTWFzayIsImZyb250IiwiX3Jlc2l6ZVRvIiwib2xkQ2FwYWNpdHkiLCJtb3ZlSXRlbXNDb3VudCIsImdldFRoZW4iLCJpc0FueUJsdWViaXJkUHJvbWlzZSIsImRvVGhlbmFibGUiLCJkb0dldFRoZW4iLCJ0b1Jlc29sdXRpb25WYWx1ZSIsInZhbHVlcyIsIl9wcm9taXNlIiwiX3NldE9uQ2FuY2VsIiwiX3ZhbHVlcyIsIl90b3RhbFJlc29sdmVkIiwiX2luaXQiLCJyZXNvbHZlVmFsdWVJZkVtcHR5IiwiX3Jlc29sdmVFbXB0eUFycmF5IiwiX3Jlc29sdmUiLCJfaXRlcmF0ZSIsImdldEFjdHVhbExlbmd0aCIsInNob3VsZENvcHlWYWx1ZXMiLCJpc1Jlc29sdmVkIiwic3VwcHJlc3NVbmhhbmRsZWRSZWplY3Rpb25zIiwiX2lzQ2FuY2VsbGFibGUiLCJ0b3RhbFJlc29sdmVkIiwiX3Jlc3VsdENhbmNlbGxlZCIsImNvbnRleHRTdGFjayIsIl9wZWVrQ29udGV4dCIsIl90cmFjZSIsInBlZWtDb250ZXh0IiwibGFzdEluZGV4IiwiZGVhY3RpdmF0ZUxvbmdTdGFja1RyYWNlcyIsImFjdGl2YXRlTG9uZ1N0YWNrVHJhY2VzIiwiUHJvbWlzZV9wdXNoQ29udGV4dCIsIlByb21pc2VfcG9wQ29udGV4dCIsIlByb21pc2VfUGVla0NvbnRleHQiLCJQcm9taXNlX3BlZWtDb250ZXh0IiwiUHJvbWlzZV9wcm9taXNlQ3JlYXRlZCIsIl9nZXREb21haW4iLCJfYXN5bmMiLCJ1bmhhbmRsZWRSZWplY3Rpb25IYW5kbGVkIiwicG9zc2libHlVbmhhbmRsZWRSZWplY3Rpb24iLCJibHVlYmlyZEZyYW1lUGF0dGVybiIsIm5vZGVGcmFtZVBhdHRlcm4iLCJwYXJzZUxpbmVQYXR0ZXJuIiwic3RhY2tGcmFtZVBhdHRlcm4iLCJmb3JtYXRTdGFjayIsImluZGVudFN0YWNrRnJhbWVzIiwicHJpbnRXYXJuaW5nIiwiZGVidWdnaW5nIiwid0ZvcmdvdHRlblJldHVybiIsIl9zZXRSZWplY3Rpb25Jc1VuaGFuZGxlZCIsIl9ub3RpZnlVbmhhbmRsZWRSZWplY3Rpb24iLCJfbm90aWZ5VW5oYW5kbGVkUmVqZWN0aW9uSXNIYW5kbGVkIiwiZmlyZVJlamVjdGlvbkV2ZW50IiwiX3NldFJldHVybmVkTm9uVW5kZWZpbmVkIiwiX3JldHVybmVkTm9uVW5kZWZpbmVkIiwiX2lzUmVqZWN0aW9uVW5oYW5kbGVkIiwiX3NldFVuaGFuZGxlZFJlamVjdGlvbklzTm90aWZpZWQiLCJfdW5zZXRVbmhhbmRsZWRSZWplY3Rpb25Jc05vdGlmaWVkIiwiX2lzVW5oYW5kbGVkUmVqZWN0aW9uTm90aWZpZWQiLCJzaG91bGRVc2VPd25UcmFjZSIsIm9uUG9zc2libHlVbmhhbmRsZWRSZWplY3Rpb24iLCJvblVuaGFuZGxlZFJlamVjdGlvbkhhbmRsZWQiLCJkaXNhYmxlTG9uZ1N0YWNrVHJhY2VzIiwibG9uZ1N0YWNrVHJhY2VzSXNTdXBwb3J0ZWQiLCJQcm9taXNlX2NhcHR1cmVTdGFja1RyYWNlIiwiUHJvbWlzZV9hdHRhY2hFeHRyYVRyYWNlIiwibG9uZ1N0YWNrVHJhY2VzQ2FwdHVyZVN0YWNrVHJhY2UiLCJsb25nU3RhY2tUcmFjZXNBdHRhY2hFeHRyYVRyYWNlIiwiaGFzTG9uZ1N0YWNrVHJhY2VzIiwiZmlyZURvbUV2ZW50IiwiQ3VzdG9tRXZlbnQiLCJkaXNwYXRjaEV2ZW50IiwiZG9tRXZlbnQiLCJkZXRhaWwiLCJjYW5jZWxhYmxlIiwiRXZlbnQiLCJjcmVhdGVFdmVudCIsImluaXRDdXN0b21FdmVudCIsImZpcmVHbG9iYWxFdmVudCIsImdlbmVyYXRlUHJvbWlzZUxpZmVjeWNsZUV2ZW50T2JqZWN0IiwiZXZlbnRUb09iamVjdEdlbmVyYXRvciIsInByb21pc2VGdWxmaWxsZWQiLCJwcm9taXNlUmVqZWN0ZWQiLCJwcm9taXNlUmVzb2x2ZWQiLCJwcm9taXNlQ2FuY2VsbGVkIiwicHJvbWlzZUNoYWluZWQiLCJjaGlsZCIsIndhcm5pbmciLCJ1bmhhbmRsZWRSZWplY3Rpb24iLCJyZWplY3Rpb25IYW5kbGVkIiwiYWN0aXZlRmlyZUV2ZW50IiwiZ2xvYmFsRXZlbnRGaXJlZCIsImRvbUV2ZW50RmlyZWQiLCJ3YXJuaW5nc09wdGlvbiIsImNhbmNlbGxhdGlvbiIsImNhbmNlbGxhdGlvbkNsZWFyQ2FuY2VsbGF0aW9uRGF0YSIsImNhbmNlbGxhdGlvblByb3BhZ2F0ZUZyb20iLCJfb25DYW5jZWwiLCJjYW5jZWxsYXRpb25PbkNhbmNlbCIsImNhbmNlbGxhdGlvblNldE9uQ2FuY2VsIiwiX2F0dGFjaENhbmNlbGxhdGlvbkNhbGxiYWNrIiwiY2FuY2VsbGF0aW9uQXR0YWNoQ2FuY2VsbGF0aW9uQ2FsbGJhY2siLCJjYW5jZWxsYXRpb25FeGVjdXRlIiwicHJvcGFnYXRlRnJvbUZ1bmN0aW9uIiwibW9uaXRvcmluZyIsImRlZmF1bHRGaXJlRXZlbnQiLCJwcmV2aW91c09uQ2FuY2VsIiwiX29uQ2FuY2VsRmllbGQiLCJfY2FuY2VsbGF0aW9uUGFyZW50IiwiYnJhbmNoZXNSZW1haW5pbmdUb0NhbmNlbCIsIl9icmFuY2hlc1JlbWFpbmluZ1RvQ2FuY2VsIiwiX3NldEJvdW5kVG8iLCJiaW5kaW5nUHJvcGFnYXRlRnJvbSIsImJvdW5kVmFsdWVGdW5jdGlvbiIsImlnbm9yZVNlbGYiLCJhdHRhY2hFeHRyYVRyYWNlIiwiX19zdGFja0NsZWFuZWRfXyIsInBhcnNlU3RhY2tBbmRNZXNzYWdlIiwicmV0dXJuVmFsdWUiLCJoYW5kbGVyTGluZSIsImNyZWF0b3JMaW5lIiwidHJhY2VMaW5lcyIsImNsZWFuU3RhY2siLCJsaW5lTWF0Y2hlcyIsImZpcnN0VXNlckxpbmUiLCJyZXBsYWNlbWVudCIsImZvcm1hdEFuZExvZ0Vycm9yIiwicmVjb25zdHJ1Y3RTdGFjayIsInN0YWNrcyIsInJlbW92ZUR1cGxpY2F0ZU9yRW1wdHlKdW1wcyIsInJlbW92ZUNvbW1vblJvb3RzIiwiY3VycmVudCIsImN1cnJlbnRMYXN0SW5kZXgiLCJjdXJyZW50TGFzdExpbmUiLCJjb21tb25Sb290TWVldFBvaW50IiwiaXNUcmFjZUxpbmUiLCJpc0ludGVybmFsRnJhbWUiLCJzaG91bGRJZ25vcmUiLCJzdGFja0ZyYW1lc0FzQXJyYXkiLCJpc1NvZnQiLCJsb2NhbEhhbmRsZXIiLCJsb2NhbEV2ZW50RmlyZWQiLCJmb3JtYXROb25FcnJvciIsInJ1c2VsZXNzVG9TdHJpbmciLCJuZXdTdHIiLCJzbmlwIiwibWF4Q2hhcnMiLCJwYXJzZUxpbmVJbmZvUmVnZXgiLCJwYXJzZUxpbmVJbmZvIiwibWF0Y2hlcyIsImZpcnN0U3RhY2tMaW5lcyIsImxhc3RTdGFja0xpbmVzIiwiZmlyc3RJbmRleCIsImZpcnN0RmlsZU5hbWUiLCJsYXN0RmlsZU5hbWUiLCJfcHJvbWlzZXNDcmVhdGVkIiwidW5jeWNsZSIsIm5vZGVzIiwic3RhY2tUb0luZGV4IiwiY3VycmVudFN0YWNrIiwiY3ljbGVFZGdlTm9kZSIsImN1cnJlbnRDaGlsZExlbmd0aCIsInN0YWNrRGV0ZWN0aW9uIiwidjhzdGFja0ZyYW1lUGF0dGVybiIsInY4c3RhY2tGb3JtYXR0ZXIiLCJzdGFja1RyYWNlTGltaXQiLCJpZ25vcmVVbnRpbCIsImhhc1N0YWNrQWZ0ZXJUaHJvdyIsImlzVFRZIiwiY2FsbGVkIiwiRmluYWxseUhhbmRsZXJDYW5jZWxSZWFjdGlvbiIsImZpbmFsbHlIYW5kbGVyIiwiY2hlY2tDYW5jZWwiLCJzdWNjZWVkIiwiZmFpbCIsInJlYXNvbk9yVmFsdWUiLCJfaXNDYW5jZWxsZWQiLCJpc1BlbmRpbmciLCJfcGFzc1Rocm91Z2giLCJzdWNjZXNzIiwibGFzdGx5IiwidGFwIiwidGFwQ2F0Y2giLCJoYW5kbGVyT3JQcmVkaWNhdGUiLCJfcmVzb2x2ZUZyb21TeW5jVmFsdWUiLCJhdHRlbXB0IiwiY2FsbGVkQmluZCIsInJlamVjdFRoaXMiLCJ0YXJnZXRSZWplY3RlZCIsInByb21pc2VSZWplY3Rpb25RdWV1ZWQiLCJiaW5kaW5nUHJvbWlzZSIsImJpbmRpbmdSZXNvbHZlZCIsInRoaXNBcmciLCJiaW5kaW5nUmVqZWN0ZWQiLCJfY2FuY2VsQnkiLCJfY2FuY2VsQnJhbmNoZWQiLCJfYnJhbmNoSGFzQ2FuY2VsbGVkIiwiX2Vub3VnaEJyYW5jaGVzSGF2ZUNhbmNlbGxlZCIsImNhbmNlbGxlciIsIl9pbnZva2VPbkNhbmNlbCIsIl9jYW5jZWxQcm9taXNlcyIsIl91bnNldE9uQ2FuY2VsIiwiaXNDYW5jZWxsYWJsZSIsImlzQ2FuY2VsbGVkIiwiX2RvSW52b2tlT25DYW5jZWwiLCJvbkNhbmNlbENhbGxiYWNrIiwiaW50ZXJuYWxPbmx5IiwicmV0dXJuZXIiLCJ0aGVuUmV0dXJuIiwidGhlblRocm93IiwiY2F0Y2hUaHJvdyIsImNhdGNoUmV0dXJuIiwiX3NldHRsZWRWYWx1ZUZpZWxkIiwiX19pc0NhbmNlbGxlZCIsInRoZW5DYWxsYmFjayIsInByb21pc2VTZXR0ZXIiLCJnZW5lcmF0ZUhvbGRlckNsYXNzIiwicHJvcHMiLCJhc3NpZ25tZW50IiwiY2FuY2VsbGF0aW9uQ29kZSIsInBhc3NlZEFyZ3VtZW50cyIsImhvbGRlckNsYXNzZXMiLCJ0aGVuQ2FsbGJhY2tzIiwicHJvbWlzZVNldHRlcnMiLCJsYXN0IiwiSG9sZGVyQ2xhc3MiLCJob2xkZXIiLCJjYWxsYmFja3MiLCJhc3luY05lZWRlZCIsIk1hcHBpbmdQcm9taXNlQXJyYXkiLCJsaW1pdCIsIl9maWx0ZXIiLCJfY2FsbGJhY2siLCJfcHJlc2VydmVkVmFsdWVzIiwiX2xpbWl0IiwiX2luRmxpZ2h0IiwiX3F1ZXVlIiwiX2FzeW5jSW5pdCIsIl9pbml0JCIsInByZXNlcnZlZFZhbHVlcyIsImJvb2xlYW5zIiwiY29uY3VycmVuY3kiLCJpc0Zpbml0ZSIsImNyIiwiY2FsbGVyQ2FjaGUiLCJnZXR0ZXJDYWNoZSIsImdldE1ldGhvZENhbGxlciIsImdldEdldHRlciIsIm1ha2VNZXRob2RDYWxsZXIiLCJlbnN1cmVNZXRob2QiLCJtYWtlR2V0dGVyIiwiZ2V0Q29tcGlsZWQiLCJjb21waWxlciIsImNhY2hlIiwiY2FsbGVyIiwibWF5YmVDYWxsZXIiLCJuYW1lZEdldHRlciIsImluZGV4ZWRHZXR0ZXIiLCJpc0luZGV4IiwiZ2V0dGVyIiwibWF5YmVHZXR0ZXIiLCJOVUxMIiwiY2FzdFByZXNlcnZpbmdEaXNwb3NhYmxlIiwidGhlbmFibGUiLCJfaXNEaXNwb3NhYmxlIiwiX2dldERpc3Bvc2VyIiwiX3NldERpc3Bvc2FibGUiLCJyZXNvdXJjZXMiLCJpbnNwZWN0aW9uIiwidHJ5RGlzcG9zZSIsIkRpc3Bvc2VyIiwiX2RhdGEiLCJfY29udGV4dCIsInJlc291cmNlIiwiZG9EaXNwb3NlIiwiX3Vuc2V0RGlzcG9zYWJsZSIsImlzRGlzcG9zZXIiLCJGdW5jdGlvbkRpc3Bvc2VyIiwibWF5YmVVbndyYXBEaXNwb3NlciIsIlJlc291cmNlTGlzdCIsInVzaW5nIiwiaW5wdXQiLCJzcHJlYWRBcmdzIiwiZGlzcG9zZXIiLCJyZWZsZWN0ZWRSZXNvdXJjZXMiLCJyZXN1bHRQcm9taXNlIiwiaW5zcGVjdGlvbnMiLCJfZGlzcG9zZXIiLCJIYW5kbGVXcmFwcGVyIiwiaGFuZGxlIiwiY2xlYXJUaW1lb3V0IiwiYWZ0ZXJWYWx1ZSIsImRlbGF5IiwiYWZ0ZXJUaW1lb3V0Iiwic3VjY2Vzc0NsZWFyIiwiZmFpbHVyZUNsZWFyIiwidGltZW91dCIsImhhbmRsZVdyYXBwZXIiLCJ0aW1lb3V0VGltZW91dCIsInlpZWxkSGFuZGxlcnMiLCJwcm9taXNlRnJvbVlpZWxkSGFuZGxlciIsInRyYWNlUGFyZW50IiwiUHJvbWlzZVNwYXduIiwiZ2VuZXJhdG9yRnVuY3Rpb24iLCJ5aWVsZEhhbmRsZXIiLCJpbnRlcm5hbCIsIl9maW5hbGx5UHJvbWlzZSIsIl9zdGFjayIsIl9nZW5lcmF0b3JGdW5jdGlvbiIsIl9yZWNlaXZlciIsIl9nZW5lcmF0b3IiLCJfeWllbGRIYW5kbGVycyIsIl95aWVsZGVkUHJvbWlzZSIsIl9jYW5jZWxsYXRpb25QaGFzZSIsIl9jbGVhbnVwIiwiaW1wbGVtZW50c1JldHVybiIsInJldHVyblNlbnRpbmVsIiwiX2NvbnRpbnVlIiwiX3J1biIsIlByb21pc2VTcGF3biQiLCJzcGF3biIsImFkZFlpZWxkSGFuZGxlciIsInNwcmVhZEFkYXB0ZXIiLCJub2RlYmFjayIsInN1Y2Nlc3NBZGFwdGVyIiwiZXJyb3JBZGFwdGVyIiwibmV3UmVhc29uIiwiYXNDYWxsYmFjayIsIm5vZGVpZnkiLCJhZGFwdGVyIiwiVEhJUyIsImRlZmF1bHRTdWZmaXgiLCJkZWZhdWx0UHJvbWlzaWZpZWQiLCJfX2lzUHJvbWlzaWZpZWRfXyIsIm5vQ29weVByb3BzIiwibm9Db3B5UHJvcHNQYXR0ZXJuIiwiZGVmYXVsdEZpbHRlciIsInByb3BzRmlsdGVyIiwiaXNQcm9taXNpZmllZCIsImhhc1Byb21pc2lmaWVkIiwiY2hlY2tWYWxpZCIsInN1ZmZpeFJlZ2V4cCIsImtleVdpdGhvdXRBc3luY1N1ZmZpeCIsInByb21pc2lmaWFibGVNZXRob2RzIiwicGFzc2VzRGVmYXVsdEZpbHRlciIsImVzY2FwZUlkZW50UmVnZXgiLCJtYWtlTm9kZVByb21pc2lmaWVkRXZhbCIsInN3aXRjaENhc2VBcmd1bWVudE9yZGVyIiwibGlrZWx5QXJndW1lbnRDb3VudCIsImFyZ3VtZW50U2VxdWVuY2UiLCJhcmd1bWVudENvdW50IiwicGFyYW1ldGVyRGVjbGFyYXRpb24iLCJwYXJhbWV0ZXJDb3VudCIsIm9yaWdpbmFsTmFtZSIsIm5ld1BhcmFtZXRlckNvdW50IiwiYXJndW1lbnRPcmRlciIsInNob3VsZFByb3h5VGhpcyIsImdlbmVyYXRlQ2FsbEZvckFyZ3VtZW50Q291bnQiLCJjb21tYSIsImdlbmVyYXRlQXJndW1lbnRTd2l0Y2hDYXNlIiwiZ2V0RnVuY3Rpb25Db2RlIiwibWFrZU5vZGVQcm9taXNpZmllZENsb3N1cmUiLCJfXyIsImRlZmF1bHRUaGlzIiwicHJvbWlzaWZpZWQiLCJtYWtlTm9kZVByb21pc2lmaWVkIiwicHJvbWlzaWZ5QWxsIiwicHJvbWlzaWZpZXIiLCJwcm9taXNpZmllZEtleSIsIkVzNk1hcCIsIm1hcFRvRW50cmllcyIsImV4dHJhY3RFbnRyeSIsImVudHJpZXNUb01hcCIsImVudHJpZXMiLCJQcm9wZXJ0aWVzUHJvbWlzZUFycmF5IiwiaXNNYXAiLCJfaXNNYXAiLCJrZXlPZmZzZXQiLCJjYXN0VmFsdWUiLCJyYWNlTGF0ZXIiLCJhcnJheSIsInJhY2UiLCJSZWR1Y3Rpb25Qcm9taXNlQXJyYXkiLCJpbml0aWFsVmFsdWUiLCJfZWFjaCIsIl9mbiIsIl9pbml0aWFsVmFsdWUiLCJfY3VycmVudENhbmNlbGxhYmxlIiwiX2VhY2hWYWx1ZXMiLCJfZ290QWNjdW0iLCJhY2N1bSIsIl9lYWNoQ29tcGxldGUiLCJzZW5kZXIiLCJfcmVzdWx0Q2FuY2VsbGVkJCIsImdvdEFjY3VtIiwiY29tcGxldGVkIiwidmFsdWVPclJlYXNvbiIsImdvdFZhbHVlIiwiU2V0dGxlZFByb21pc2VBcnJheSIsIl9wcm9taXNlUmVzb2x2ZWQiLCJzZXR0bGUiLCJDQU5DRUxMQVRJT04iLCJTb21lUHJvbWlzZUFycmF5IiwiX2hvd01hbnkiLCJfdW53cmFwIiwiX2luaXRpYWxpemVkIiwiaXNBcnJheVJlc29sdmVkIiwiX2NhblBvc3NpYmx5RnVsZmlsbCIsIl9nZXRSYW5nZUVycm9yIiwic2V0VW53cmFwIiwiaG93TWFueSIsInNldEhvd01hbnkiLCJfYWRkRnVsZmlsbGVkIiwiX2Z1bGZpbGxlZCIsIl9hZGRSZWplY3RlZCIsIl9jaGVja091dGNvbWUiLCJfcmVqZWN0ZWQiLCJfU29tZVByb21pc2VBcnJheSIsIlByb21pc2VNYXAiLCJQcm9taXNlUmVkdWNlIiwiUHJvbWlzZUFsbCIsInByb21pc2VBbGxUaGlzIiwiUHJvbWlzZU1hcFNlcmllcyIsImVhY2giLCJtYXBTZXJpZXMiLCJhbnkiLCJsb2FkIiwic3RvcmFnZSIsImxvY2FsIiwibG9jYWxzdG9yYWdlIiwidXNlckFnZW50IiwiZG9jdW1lbnRFbGVtZW50IiwiV2Via2l0QXBwZWFyYW5jZSIsImZpcmVidWciLCJleGNlcHRpb24iLCJ0YWJsZSIsIiQxIiwibGFzdEMiLCJyZW1vdmVJdGVtIiwiREVCVUciLCJsb2NhbFN0b3JhZ2UiLCJoIiwieSIsImxvbmciLCJmbXRMb25nIiwiZm10U2hvcnQiLCJleGVjIiwibiIsInBhcnNlRmxvYXQiLCJwbHVyYWwiLCJjZWlsIiwidHR5Iiwic3VwcG9ydHNDb2xvciIsImluc3BlY3RPcHRzIiwiayIsInRvVXBwZXJDYXNlIiwiQm9vbGVhbiIsImlzYXR0eSIsImluc3BlY3QiLCJPIiwiY29sb3JDb2RlIiwiaGlkZURhdGUiLCJ0b0lTT1N0cmluZyIsImhhc0ZsYWciLCJzdXBwb3J0IiwiaGFzQmFzaWMiLCJoYXMyNTYiLCJoYXMxNm0iLCJzdXBwb3J0TGV2ZWwiLCJzdGRvdXQiLCJvc1JlbGVhc2UiLCJzaWduIiwiQ0lfTkFNRSIsIlRFQU1DSVRZX1ZFUlNJT04iLCJURVJNX1BST0dSQU1fVkVSU0lPTiIsIlRFUk1fUFJPR1JBTSIsIlRFUk0iLCJGT1JDRV9DT0xPUiIsImZsYWciLCJhcmd2IiwidGVybWluYXRvclBvcyIsInBvcyIsImNvbnN0YW50cyIsIm9yaWdDd2QiLCJHUkFDRUZVTF9GU19QTEFURk9STSIsImNoZGlyIiwicGF0Y2hMY2htb2QiLCJsdXRpbWVzIiwicGF0Y2hMdXRpbWVzIiwiY2hvd24iLCJjaG93bkZpeCIsImZjaG93biIsImxjaG93biIsImNobW9kRml4IiwiZmNobW9kIiwibGNobW9kIiwiY2hvd25TeW5jIiwiY2hvd25GaXhTeW5jIiwiZmNob3duU3luYyIsImxjaG93blN5bmMiLCJjaG1vZFN5bmMiLCJjaG1vZEZpeFN5bmMiLCJmY2htb2RTeW5jIiwibGNobW9kU3luYyIsInN0YXRGaXgiLCJzdGF0Rml4U3luYyIsImZzdGF0U3luYyIsImxzdGF0U3luYyIsInVpZCIsImdpZCIsInJlbmFtZSIsImZzJHJlbmFtZSIsImJhY2tvZmYiLCJDQiIsInN0YXRlciIsImZzJHJlYWQiLCJjYWxsYmFja18iLCJlYWdDb3VudGVyIiwicmVhZFN5bmMiLCJmcyRyZWFkU3luYyIsIk9fV1JPTkxZIiwiT19TWU1MSU5LIiwiZXJyMiIsInRocmV3IiwibXQiLCJlcjIiLCJsdXRpbWVzU3luYyIsIl9hIiwiX2IiLCJfYyIsIm9yaWciLCJjaG93bkVyT2siLCJub25yb290IiwiZ2V0dWlkIiwiU3RyZWFtIiwicmVhZGFibGUiLCJwYXVzZWQiLCJidWZmZXJTaXplIiwiSW5maW5pdHkiLCJfcmVhZCIsImJ1c3kiLCJfb3BlbiIsImZsdXNoIiwibzc3NyIsIm1hZGUiLCJlcnJJbnZhbCIsInhmcyIsInVtYXNrIiwibWtkaXJTeW5jIiwiZXJyMCIsImVycjEiLCJ1dGltZXNTeW5jIiwidW5saW5rU3luYyIsImNvcHlGaWxlU3luYyIsIkJVRl9MRU5HVEgiLCJfYnVmZiIsImZkciIsImZkdyIsIndyaXRlU3luYyIsInJlYWRkaXJTeW5jIiwicmVhZGxpbmtTeW5jIiwic3ltbGlua1N5bmMiLCJhc3NlcnQiLCJpc1dpbmRvd3MiLCJkZWZhdWx0cyIsIm1heEJ1c3lUcmllcyIsImJ1c3lUcmllcyIsInJpbXJhZl8iLCJ0aW1lIiwiZml4V2luRVBFUk0iLCJybWRpciIsImVyMyIsImZpeFdpbkVQRVJNU3luYyIsInJtZGlyU3luYyIsIm9yaWdpbmFsRXIiLCJybWtpZHMiLCJlcnJTdGF0ZSIsImYiLCJyaW1yYWZTeW5jIiwicm1raWRzU3luYyIsInJldHJpZXMiLCJvdXRwdXRKc29uIiwib3V0cHV0SnNvblN5bmMiLCJvdXRwdXRKU09OIiwib3V0cHV0SlNPTlN5bmMiLCJ3cml0ZUpTT04iLCJ3cml0ZUpTT05TeW5jIiwicmVhZEpTT04iLCJyZWFkSlNPTlN5bmMiLCJfZnMiLCJzaG91bGRUaHJvdyIsInRocm93cyIsInN0cmlwQm9tIiwicmV2aXZlciIsInNwYWNlcyIsInJlcGxhY2VyIiwiaXNCdWZmZXIiLCJqc29uZmlsZSIsImRpciIsIml0RG9lcyIsIm1vdmUiLCJpdElzIiwiZG9SZW5hbWUiLCJtb3ZlQWNyb3NzRGV2aWNlIiwibGluayIsIm1vdmVEaXJBY3Jvc3NEZXZpY2UiLCJtb3ZlRmlsZUFjcm9zc0RldmljZSIsImlucyIsIm91dHMiLCJvbkNsb3NlIiwibW92ZVN5bmMiLCJhY2Nlc3NTeW5jIiwidHJ5UmVuYW1lU3luYyIsInJlbmFtZVN5bmMiLCJtb3ZlU3luY0Fjcm9zc0RldmljZSIsImxpbmtTeW5jIiwibW92ZURpclN5bmNBY3Jvc3NEZXZpY2UiLCJtb3ZlRmlsZVN5bmNBY3Jvc3NEZXZpY2UiLCJ0cnlDb3B5U3luYyIsImVtcHR5RGlyIiwiZGVsZXRlSXRlbSIsImVtcHR5RGlyU3luYyIsImVtcHR5ZGlyU3luYyIsImVtcHR5ZGlyIiwiY3JlYXRlRmlsZVN5bmMiLCJlbnN1cmVGaWxlU3luYyIsImNyZWF0ZUxpbmsiLCJjcmVhdGVMaW5rU3luYyIsImVuc3VyZUxpbmsiLCJlbnN1cmVMaW5rU3luYyIsImNyZWF0ZVN5bWxpbmsiLCJjcmVhdGVTeW1saW5rU3luYyIsImVuc3VyZVN5bWxpbmsiLCJlbnN1cmVTeW1saW5rU3luYyIsIm1ha2VGaWxlIiwic3JjcGF0aCIsImRzdHBhdGgiLCJtYWtlTGluayIsImRlc3RpbmF0aW9uRXhpc3RzIiwiX21rZGlycyIsIl9zeW1saW5rUGF0aHMiLCJzeW1saW5rUGF0aHMiLCJzeW1saW5rUGF0aHNTeW5jIiwiX3N5bWxpbmtUeXBlIiwic3ltbGlua1R5cGUiLCJzeW1saW5rVHlwZVN5bmMiLCJ0b0RzdCIsInRvQ3dkIiwiZHN0ZGlyIiwicmVsYXRpdmVUb0RzdCIsIm91dHB1dEZpbGVTeW5jIiwiczNVcmwiLCJzcGFjZXNVcmwiLCJlbmRwb2ludCIsImJ1Y2tldCIsInJlZ2lvbiIsInNlcSIsInF1b3RlZCIsIm5leHROb25TcGFjZSIsImNoIiwib3JkIiwiZnJvbUNoYXJDb2RlIiwibmlsIiwiaW52YWxpZE5hbWUiLCJtb3JlVGhhbjEwMDAwIiwicmFuZG9tSG9zdCIsInNlZWQiLCJjbG9ja1NlcSIsImxhc3RNVGltZSIsImxhc3ROVGltZSIsImhleDJieXRlIiwiYnl0ZTJoZXgiLCJoZXgiLCJ1dWlkIiwiYXNjaWkiLCJiaW5hcnkiLCJ1dWlkVGltZUJhc2VkIiwidXVpZE5hbWVkIiwidG9CdWZmZXIiLCJ2YXJpYW50IiwiZ2V0VmFyaWFudCIsImJpdHMiLCJVdWlkRW5jb2RpbmciLCJub2RlSWQiLCJBU0NJSSIsIm1UaW1lIiwiblRpbWUiLCJteUNsb2NrU2VxIiwidGltZUxvdyIsInRpbWVIaWdoIiwiQklOQVJZIiwiT0JKRUNUIiwiaGFzaE1ldGhvZCIsIm5hbWVJc05vdEFTdHJpbmciLCJfc2F4IiwiX2xvYWRfc2F4IiwiaXNDRGF0YSIsImVsZW1lbnRzIiwiaXNWYWxpZE5hbWUiLCJyZW1vdmVBdHRyaWJ1dGUiLCJpZ25vcmVDYXNlIiwiZXJyb3JJZk1pc3NlZCIsImVsZW1lbnRPck51bGwiLCJpc05hbWVFcXVhbHMiLCJOQU1FX1JFR19FWFAiLCJlbGVtZW50TmFtZSIsInJvb3RFbGVtZW50IiwicGFyc2VyIiwib25vcGVudGFnIiwic2F4RWxlbWVudCIsIm9uY2xvc2V0YWciLCJvbnRleHQiLCJvbmNkYXRhIiwiY2RhdGEiLCJvbmVycm9yIiwic2F4Iiwic3RyaWN0Iiwib3B0IiwiU0FYUGFyc2VyIiwiU0FYU3RyZWFtIiwiY3JlYXRlU3RyZWFtIiwiTUFYX0JVRkZFUl9MRU5HVEgiLCJidWZmZXJzIiwiRVZFTlRTIiwiY2xlYXJCdWZmZXJzIiwicSIsImJ1ZmZlckNoZWNrUG9zaXRpb24iLCJsb3dlcmNhc2UiLCJsb3dlcmNhc2V0YWdzIiwibG9vc2VDYXNlIiwidGFncyIsImNsb3NlZCIsImNsb3NlZFJvb3QiLCJzYXdSb290Iiwibm9zY3JpcHQiLCJzdGF0ZSIsIlMiLCJCRUdJTiIsInN0cmljdEVudGl0aWVzIiwiRU5USVRJRVMiLCJYTUxfRU5USVRJRVMiLCJhdHRyaWJMaXN0IiwieG1sbnMiLCJucyIsInJvb3ROUyIsInRyYWNrUG9zaXRpb24iLCJGIiwibmV3ZiIsImNoZWNrQnVmZmVyTGVuZ3RoIiwibWF4QWxsb3dlZCIsIm1heEFjdHVhbCIsImNsb3NlVGV4dCIsImVtaXROb2RlIiwic2NyaXB0IiwiZmx1c2hCdWZmZXJzIiwicmVzdW1lIiwiZXgiLCJzdHJlYW1XcmFwcyIsImV2IiwiX3BhcnNlciIsIm1lIiwib25lbmQiLCJfZGVjb2RlciIsIlNEIiwiU3RyaW5nRGVjb2RlciIsIkNEQVRBIiwiRE9DVFlQRSIsIlhNTF9OQU1FU1BBQ0UiLCJYTUxOU19OQU1FU1BBQ0UiLCJ4bWwiLCJuYW1lU3RhcnQiLCJuYW1lQm9keSIsImVudGl0eVN0YXJ0IiwiZW50aXR5Qm9keSIsImlzV2hpdGVzcGFjZSIsImlzUXVvdGUiLCJpc0F0dHJpYkVuZCIsImlzTWF0Y2giLCJyZWdleCIsIm5vdE1hdGNoIiwiU1RBVEUiLCJCRUdJTl9XSElURVNQQUNFIiwiVEVYVCIsIlRFWFRfRU5USVRZIiwiT1BFTl9XQUtBIiwiU0dNTF9ERUNMIiwiU0dNTF9ERUNMX1FVT1RFRCIsIkRPQ1RZUEVfUVVPVEVEIiwiRE9DVFlQRV9EVEQiLCJET0NUWVBFX0RURF9RVU9URUQiLCJDT01NRU5UX1NUQVJUSU5HIiwiQ09NTUVOVCIsIkNPTU1FTlRfRU5ESU5HIiwiQ09NTUVOVF9FTkRFRCIsIkNEQVRBX0VORElORyIsIkNEQVRBX0VORElOR18yIiwiUFJPQ19JTlNUIiwiUFJPQ19JTlNUX0JPRFkiLCJQUk9DX0lOU1RfRU5ESU5HIiwiT1BFTl9UQUciLCJPUEVOX1RBR19TTEFTSCIsIkFUVFJJQiIsIkFUVFJJQl9OQU1FIiwiQVRUUklCX05BTUVfU0FXX1dISVRFIiwiQVRUUklCX1ZBTFVFIiwiQVRUUklCX1ZBTFVFX1FVT1RFRCIsIkFUVFJJQl9WQUxVRV9DTE9TRUQiLCJBVFRSSUJfVkFMVUVfVU5RVU9URUQiLCJBVFRSSUJfVkFMVUVfRU5USVRZX1EiLCJBVFRSSUJfVkFMVUVfRU5USVRZX1UiLCJDTE9TRV9UQUciLCJDTE9TRV9UQUdfU0FXX1dISVRFIiwiU0NSSVBUIiwiU0NSSVBUX0VORElORyIsIm5vZGVUeXBlIiwidGV4dE5vZGUiLCJ0ZXh0b3B0cyIsInN0cmljdEZhaWwiLCJuZXdUYWciLCJ0YWdOYW1lIiwicW5hbWUiLCJxdWFsTmFtZSIsImF0dHJpYiIsImF0dHJpYk5hbWUiLCJhdHRyaWJWYWx1ZSIsInFuIiwib3BlblRhZyIsInNlbGZDbG9zaW5nIiwidXJpIiwibnYiLCJpc1NlbGZDbG9zaW5nIiwiY2xvc2VUYWciLCJ0IiwiY2xvc2VUbyIsInBhcnNlRW50aXR5IiwiZW50aXR5IiwiZW50aXR5TEMiLCJudW1TdHIiLCJmcm9tQ29kZVBvaW50IiwiYmVnaW5XaGl0ZVNwYWNlIiwic3RhcnRUYWdQb3NpdGlvbiIsInN0YXJ0aSIsInNnbWxEZWNsIiwicHJvY0luc3ROYW1lIiwicHJvY0luc3RCb2R5IiwiY29tbWVudCIsImRvY3R5cGUiLCJyZXR1cm5TdGF0ZSIsInN0cmluZ0Zyb21DaGFyQ29kZSIsIk1BWF9TSVpFIiwiY29kZVVuaXRzIiwiaGlnaFN1cnJvZ2F0ZSIsImxvd1N1cnJvZ2F0ZSIsImNvZGVQb2ludCIsImxvYWRlciIsImR1bXBlciIsIkZBSUxTQUZFX1NDSEVNQSIsIkpTT05fU0NIRU1BIiwiQ09SRV9TQ0hFTUEiLCJERUZBVUxUX1NBRkVfU0NIRU1BIiwiREVGQVVMVF9GVUxMX1NDSEVNQSIsImxvYWRBbGwiLCJzYWZlTG9hZEFsbCIsImR1bXAiLCJzYWZlRHVtcCIsIk1JTklNQUxfU0NIRU1BIiwiU0FGRV9TQ0hFTUEiLCJERUZBVUxUX1NDSEVNQSIsInNjYW4iLCJjb21wb3NlIiwiYWRkQ29uc3RydWN0b3IiLCJNYXJrIiwiX2hhc093blByb3BlcnR5IiwiQ09OVEVYVF9GTE9XX0lOIiwiQ09OVEVYVF9GTE9XX09VVCIsIkNPTlRFWFRfQkxPQ0tfSU4iLCJDT05URVhUX0JMT0NLX09VVCIsIkNIT01QSU5HX0NMSVAiLCJDSE9NUElOR19TVFJJUCIsIkNIT01QSU5HX0tFRVAiLCJQQVRURVJOX05PTl9QUklOVEFCTEUiLCJQQVRURVJOX05PTl9BU0NJSV9MSU5FX0JSRUFLUyIsIlBBVFRFUk5fRkxPV19JTkRJQ0FUT1JTIiwiUEFUVEVSTl9UQUdfSEFORExFIiwiUEFUVEVSTl9UQUdfVVJJIiwiaXNfRU9MIiwiaXNfV0hJVEVfU1BBQ0UiLCJpc19XU19PUl9FT0wiLCJpc19GTE9XX0lORElDQVRPUiIsImZyb21IZXhDb2RlIiwibGMiLCJlc2NhcGVkSGV4TGVuIiwiZnJvbURlY2ltYWxDb2RlIiwic2ltcGxlRXNjYXBlU2VxdWVuY2UiLCJjaGFyRnJvbUNvZGVwb2ludCIsInNpbXBsZUVzY2FwZUNoZWNrIiwic2ltcGxlRXNjYXBlTWFwIiwiU3RhdGUiLCJvbldhcm5pbmciLCJqc29uIiwibGlzdGVuZXIiLCJpbXBsaWNpdFR5cGVzIiwidHlwZU1hcCIsImxpbmVTdGFydCIsImxpbmVJbmRlbnQiLCJkb2N1bWVudHMiLCJnZW5lcmF0ZUVycm9yIiwidGhyb3dFcnJvciIsInRocm93V2FybmluZyIsImRpcmVjdGl2ZUhhbmRsZXJzIiwiWUFNTCIsImhhbmRsZVlhbWxEaXJlY3RpdmUiLCJjaGVja0xpbmVCcmVha3MiLCJUQUciLCJoYW5kbGVUYWdEaXJlY3RpdmUiLCJ0YWdNYXAiLCJjYXB0dXJlU2VnbWVudCIsImNoZWNrSnNvbiIsIl9wb3NpdGlvbiIsIl9jaGFyYWN0ZXIiLCJfcmVzdWx0IiwibWVyZ2VNYXBwaW5ncyIsIm92ZXJyaWRhYmxlS2V5cyIsInF1YW50aXR5Iiwic3RvcmVNYXBwaW5nUGFpciIsImtleVRhZyIsImtleU5vZGUiLCJ2YWx1ZU5vZGUiLCJzdGFydExpbmUiLCJzdGFydFBvcyIsInJlYWRMaW5lQnJlYWsiLCJza2lwU2VwYXJhdGlvblNwYWNlIiwiYWxsb3dDb21tZW50cyIsImNoZWNrSW5kZW50IiwibGluZUJyZWFrcyIsInRlc3REb2N1bWVudFNlcGFyYXRvciIsIndyaXRlRm9sZGVkTGluZXMiLCJyZWFkUGxhaW5TY2FsYXIiLCJub2RlSW5kZW50Iiwid2l0aGluRmxvd0NvbGxlY3Rpb24iLCJwcmVjZWRpbmciLCJmb2xsb3dpbmciLCJjYXB0dXJlU3RhcnQiLCJjYXB0dXJlRW5kIiwiaGFzUGVuZGluZ0NvbnRlbnQiLCJfbGluZSIsIl9saW5lU3RhcnQiLCJfbGluZUluZGVudCIsIl9raW5kIiwicmVhZFNpbmdsZVF1b3RlZFNjYWxhciIsInJlYWREb3VibGVRdW90ZWRTY2FsYXIiLCJoZXhMZW5ndGgiLCJoZXhSZXN1bHQiLCJ0bXAiLCJyZWFkRmxvd0NvbGxlY3Rpb24iLCJyZWFkTmV4dCIsIl90YWciLCJfYW5jaG9yIiwiYW5jaG9yIiwidGVybWluYXRvciIsImlzUGFpciIsImlzRXhwbGljaXRQYWlyIiwiaXNNYXBwaW5nIiwiYW5jaG9yTWFwIiwiY29tcG9zZU5vZGUiLCJyZWFkQmxvY2tTY2FsYXIiLCJmb2xkaW5nIiwiY2hvbXBpbmciLCJkaWRSZWFkQ29udGVudCIsImRldGVjdGVkSW5kZW50IiwidGV4dEluZGVudCIsImVtcHR5TGluZXMiLCJhdE1vcmVJbmRlbnRlZCIsInJlYWRCbG9ja1NlcXVlbmNlIiwiZGV0ZWN0ZWQiLCJyZWFkQmxvY2tNYXBwaW5nIiwiZmxvd0luZGVudCIsImFsbG93Q29tcGFjdCIsIl9wb3MiLCJhdEV4cGxpY2l0S2V5IiwicmVhZFRhZ1Byb3BlcnR5IiwiaXNWZXJiYXRpbSIsImlzTmFtZWQiLCJ0YWdIYW5kbGUiLCJyZWFkQW5jaG9yUHJvcGVydHkiLCJyZWFkQWxpYXMiLCJwYXJlbnRJbmRlbnQiLCJub2RlQ29udGV4dCIsImFsbG93VG9TZWVrIiwiYWxsb3dCbG9ja1N0eWxlcyIsImFsbG93QmxvY2tTY2FsYXJzIiwiYWxsb3dCbG9ja0NvbGxlY3Rpb25zIiwiaW5kZW50U3RhdHVzIiwiYXROZXdMaW5lIiwiaGFzQ29udGVudCIsInR5cGVJbmRleCIsInR5cGVRdWFudGl0eSIsImJsb2NrSW5kZW50IiwicmVhZERvY3VtZW50IiwiZG9jdW1lbnRTdGFydCIsImRpcmVjdGl2ZU5hbWUiLCJkaXJlY3RpdmVBcmdzIiwiaGFzRGlyZWN0aXZlcyIsImxvYWREb2N1bWVudHMiLCJvdXRwdXQiLCJnZXRTbmlwcGV0IiwibWF4TGVuZ3RoIiwiaGVhZCIsInRhaWwiLCJzbmlwcGV0Iiwid2hlcmUiLCJyZXNvbHZlWWFtbE51bGwiLCJjb25zdHJ1Y3RZYW1sTnVsbCIsImlzTnVsbCIsIm9iamVjdCIsImNhbm9uaWNhbCIsInVwcGVyY2FzZSIsImNhbWVsY2FzZSIsInJlc29sdmVZYW1sQm9vbGVhbiIsImNvbnN0cnVjdFlhbWxCb29sZWFuIiwiaXNCb29sZWFuIiwiaXNIZXhDb2RlIiwiaXNPY3RDb2RlIiwiaXNEZWNDb2RlIiwicmVzb2x2ZVlhbWxJbnRlZ2VyIiwiaGFzRGlnaXRzIiwiY29uc3RydWN0WWFtbEludGVnZXIiLCJkaWdpdHMiLCJpc0ludGVnZXIiLCJvY3RhbCIsImRlY2ltYWwiLCJoZXhhZGVjaW1hbCIsIllBTUxfRkxPQVRfUEFUVEVSTiIsInJlc29sdmVZYW1sRmxvYXQiLCJjb25zdHJ1Y3RZYW1sRmxvYXQiLCJQT1NJVElWRV9JTkZJTklUWSIsIk5hTiIsIlNDSUVOVElGSUNfV0lUSE9VVF9ET1QiLCJyZXByZXNlbnRZYW1sRmxvYXQiLCJpc0Zsb2F0IiwiWUFNTF9EQVRFX1JFR0VYUCIsIllBTUxfVElNRVNUQU1QX1JFR0VYUCIsInJlc29sdmVZYW1sVGltZXN0YW1wIiwiY29uc3RydWN0WWFtbFRpbWVzdGFtcCIsInllYXIiLCJtb250aCIsImRheSIsImhvdXIiLCJtaW51dGUiLCJzZWNvbmQiLCJmcmFjdGlvbiIsInR6X2hvdXIiLCJ0el9taW51dGUiLCJVVEMiLCJzZXRUaW1lIiwicmVwcmVzZW50WWFtbFRpbWVzdGFtcCIsInJlc29sdmVZYW1sTWVyZ2UiLCJOb2RlQnVmZmVyIiwiX3JlcXVpcmUiLCJCQVNFNjRfTUFQIiwicmVzb2x2ZVlhbWxCaW5hcnkiLCJiaXRsZW4iLCJjb25zdHJ1Y3RZYW1sQmluYXJ5IiwidGFpbGJpdHMiLCJyZXByZXNlbnRZYW1sQmluYXJ5IiwiaXNCaW5hcnkiLCJfdG9TdHJpbmciLCJyZXNvbHZlWWFtbE9tYXAiLCJvYmplY3RLZXlzIiwicGFpciIsInBhaXJLZXkiLCJwYWlySGFzS2V5IiwiY29uc3RydWN0WWFtbE9tYXAiLCJyZXNvbHZlWWFtbFBhaXJzIiwiY29uc3RydWN0WWFtbFBhaXJzIiwicmVzb2x2ZVlhbWxTZXQiLCJjb25zdHJ1Y3RZYW1sU2V0IiwicmVzb2x2ZUphdmFzY3JpcHRVbmRlZmluZWQiLCJjb25zdHJ1Y3RKYXZhc2NyaXB0VW5kZWZpbmVkIiwicmVwcmVzZW50SmF2YXNjcmlwdFVuZGVmaW5lZCIsImlzVW5kZWZpbmVkIiwicmVzb2x2ZUphdmFzY3JpcHRSZWdFeHAiLCJyZWdleHAiLCJtb2RpZmllcnMiLCJjb25zdHJ1Y3RKYXZhc2NyaXB0UmVnRXhwIiwicmVwcmVzZW50SmF2YXNjcmlwdFJlZ0V4cCIsIm11bHRpbGluZSIsImlzUmVnRXhwIiwiZXNwcmltYSIsInJlc29sdmVKYXZhc2NyaXB0RnVuY3Rpb24iLCJhc3QiLCJleHByZXNzaW9uIiwiY29uc3RydWN0SmF2YXNjcmlwdEZ1bmN0aW9uIiwicGFyYW1zIiwicGFyYW0iLCJyZXByZXNlbnRKYXZhc2NyaXB0RnVuY3Rpb24iLCJpc0Z1bmN0aW9uIiwid2VicGFja1VuaXZlcnNhbE1vZHVsZURlZmluaXRpb24iLCJyb290IiwiZmFjdG9yeSIsImRlZmluZSIsImFtZCIsIm1vZHVsZXMiLCJpbnN0YWxsZWRNb2R1bGVzIiwiX193ZWJwYWNrX3JlcXVpcmVfXyIsIm1vZHVsZUlkIiwibG9hZGVkIiwiY29tbWVudF9oYW5kbGVyXzEiLCJqc3hfcGFyc2VyXzEiLCJwYXJzZXJfMSIsInRva2VuaXplcl8xIiwiZGVsZWdhdGUiLCJjb21tZW50SGFuZGxlciIsInByb3h5RGVsZWdhdGUiLCJtZXRhZGF0YSIsInZpc2l0IiwicGFyc2VyRGVsZWdhdGUiLCJjb2xsZWN0Q29tbWVudCIsImF0dGFjaENvbW1lbnQiLCJDb21tZW50SGFuZGxlciIsImF0dGFjaCIsImlzTW9kdWxlIiwic291cmNlVHlwZSIsImpzeCIsIkpTWFBhcnNlciIsIlBhcnNlciIsInByb2dyYW0iLCJwYXJzZU1vZHVsZSIsInBhcnNlU2NyaXB0IiwiY29tbWVudHMiLCJ0b2tlbnMiLCJ0b2xlcmFudCIsImVycm9ySGFuZGxlciIsInBhcnNpbmdPcHRpb25zIiwidG9rZW5pemUiLCJ0b2tlbml6ZXIiLCJUb2tlbml6ZXIiLCJnZXROZXh0VG9rZW4iLCJ0b2xlcmF0ZSIsInN5bnRheF8xIiwiU3ludGF4IiwibGVhZGluZyIsInRyYWlsaW5nIiwiaW5zZXJ0SW5uZXJDb21tZW50cyIsIkJsb2NrU3RhdGVtZW50IiwiaW5uZXJDb21tZW50cyIsImVudHJ5IiwiZmluZFRyYWlsaW5nQ29tbWVudHMiLCJ0cmFpbGluZ0NvbW1lbnRzIiwiZW50cnlfMSIsImZpcnN0Q29tbWVudCIsImZpbmRMZWFkaW5nQ29tbWVudHMiLCJsZWFkaW5nQ29tbWVudHMiLCJ2aXNpdE5vZGUiLCJQcm9ncmFtIiwidmlzaXRDb21tZW50IiwibG9jIiwiQXNzaWdubWVudEV4cHJlc3Npb24iLCJBc3NpZ25tZW50UGF0dGVybiIsIkFycmF5RXhwcmVzc2lvbiIsIkFycmF5UGF0dGVybiIsIkFycm93RnVuY3Rpb25FeHByZXNzaW9uIiwiQXdhaXRFeHByZXNzaW9uIiwiQmluYXJ5RXhwcmVzc2lvbiIsIkJyZWFrU3RhdGVtZW50IiwiQ2FsbEV4cHJlc3Npb24iLCJDYXRjaENsYXVzZSIsIkNsYXNzQm9keSIsIkNsYXNzRGVjbGFyYXRpb24iLCJDbGFzc0V4cHJlc3Npb24iLCJDb25kaXRpb25hbEV4cHJlc3Npb24iLCJDb250aW51ZVN0YXRlbWVudCIsIkRvV2hpbGVTdGF0ZW1lbnQiLCJEZWJ1Z2dlclN0YXRlbWVudCIsIkVtcHR5U3RhdGVtZW50IiwiRXhwb3J0QWxsRGVjbGFyYXRpb24iLCJFeHBvcnREZWZhdWx0RGVjbGFyYXRpb24iLCJFeHBvcnROYW1lZERlY2xhcmF0aW9uIiwiRXhwb3J0U3BlY2lmaWVyIiwiRXhwcmVzc2lvblN0YXRlbWVudCIsIkZvclN0YXRlbWVudCIsIkZvck9mU3RhdGVtZW50IiwiRm9ySW5TdGF0ZW1lbnQiLCJGdW5jdGlvbkRlY2xhcmF0aW9uIiwiRnVuY3Rpb25FeHByZXNzaW9uIiwiSWRlbnRpZmllciIsIklmU3RhdGVtZW50IiwiSW1wb3J0RGVjbGFyYXRpb24iLCJJbXBvcnREZWZhdWx0U3BlY2lmaWVyIiwiSW1wb3J0TmFtZXNwYWNlU3BlY2lmaWVyIiwiSW1wb3J0U3BlY2lmaWVyIiwiTGl0ZXJhbCIsIkxhYmVsZWRTdGF0ZW1lbnQiLCJMb2dpY2FsRXhwcmVzc2lvbiIsIk1lbWJlckV4cHJlc3Npb24iLCJNZXRhUHJvcGVydHkiLCJNZXRob2REZWZpbml0aW9uIiwiTmV3RXhwcmVzc2lvbiIsIk9iamVjdEV4cHJlc3Npb24iLCJPYmplY3RQYXR0ZXJuIiwiUHJvcGVydHkiLCJSZXN0RWxlbWVudCIsIlJldHVyblN0YXRlbWVudCIsIlNlcXVlbmNlRXhwcmVzc2lvbiIsIlNwcmVhZEVsZW1lbnQiLCJTdXBlciIsIlN3aXRjaENhc2UiLCJTd2l0Y2hTdGF0ZW1lbnQiLCJUYWdnZWRUZW1wbGF0ZUV4cHJlc3Npb24iLCJUZW1wbGF0ZUVsZW1lbnQiLCJUZW1wbGF0ZUxpdGVyYWwiLCJUaGlzRXhwcmVzc2lvbiIsIlRocm93U3RhdGVtZW50IiwiVHJ5U3RhdGVtZW50IiwiVW5hcnlFeHByZXNzaW9uIiwiVXBkYXRlRXhwcmVzc2lvbiIsIlZhcmlhYmxlRGVjbGFyYXRpb24iLCJWYXJpYWJsZURlY2xhcmF0b3IiLCJXaGlsZVN0YXRlbWVudCIsIldpdGhTdGF0ZW1lbnQiLCJZaWVsZEV4cHJlc3Npb24iLCJfX2V4dGVuZHMiLCJleHRlbmRTdGF0aWNzIiwic2V0UHJvdG90eXBlT2YiLCJjaGFyYWN0ZXJfMSIsIkpTWE5vZGUiLCJqc3hfc3ludGF4XzEiLCJOb2RlIiwidG9rZW5fMSIsInhodG1sX2VudGl0aWVzXzEiLCJUb2tlbk5hbWUiLCJnZXRRdWFsaWZpZWRFbGVtZW50TmFtZSIsInF1YWxpZmllZE5hbWUiLCJKU1hTeW50YXgiLCJKU1hJZGVudGlmaWVyIiwiSlNYTmFtZXNwYWNlZE5hbWUiLCJKU1hNZW1iZXJFeHByZXNzaW9uIiwiZXhwciIsInByb3BlcnR5IiwiX3N1cGVyIiwicGFyc2VQcmltYXJ5RXhwcmVzc2lvbiIsInBhcnNlSlNYUm9vdCIsInN0YXJ0SlNYIiwic2Nhbm5lciIsInN0YXJ0TWFya2VyIiwibGluZU51bWJlciIsImZpbmlzaEpTWCIsIm5leHRUb2tlbiIsInJlZW50ZXJKU1giLCJleHBlY3RKU1giLCJjcmVhdGVKU1hOb2RlIiwiY29sbGVjdENvbW1lbnRzIiwiY3JlYXRlSlNYQ2hpbGROb2RlIiwic2NhblhIVE1MRW50aXR5IiwicXVvdGUiLCJ0ZXJtaW5hdGVkIiwiZW9mIiwiQ2hhcmFjdGVyIiwiaXNEZWNpbWFsRGlnaXQiLCJpc0hleERpZ2l0IiwiWEhUTUxFbnRpdGllcyIsImxleEpTWCIsImNwIiwibjEiLCJuMiIsImlzSWRlbnRpZmllclN0YXJ0IiwiaXNJZGVudGlmaWVyUGFydCIsImxleCIsIm5leHRKU1hUb2tlbiIsImxhc3RNYXJrZXIiLCJjb252ZXJ0VG9rZW4iLCJuZXh0SlNYVGV4dCIsImlzTGluZVRlcm1pbmF0b3IiLCJwZWVrSlNYVG9rZW4iLCJzYXZlU3RhdGUiLCJzY2FuQ29tbWVudHMiLCJyZXN0b3JlU3RhdGUiLCJ0aHJvd1VuZXhwZWN0ZWRUb2tlbiIsIm1hdGNoSlNYIiwicGFyc2VKU1hJZGVudGlmaWVyIiwiZmluYWxpemUiLCJwYXJzZUpTWEVsZW1lbnROYW1lIiwibmFtZV8xIiwicGFyc2VKU1hBdHRyaWJ1dGVOYW1lIiwiYXR0cmlidXRlTmFtZSIsIm5hbWVfMiIsInBhcnNlSlNYU3RyaW5nTGl0ZXJhbEF0dHJpYnV0ZSIsImdldFRva2VuUmF3IiwicGFyc2VKU1hFeHByZXNzaW9uQXR0cmlidXRlIiwidG9sZXJhdGVFcnJvciIsInBhcnNlQXNzaWdubWVudEV4cHJlc3Npb24iLCJKU1hFeHByZXNzaW9uQ29udGFpbmVyIiwicGFyc2VKU1hBdHRyaWJ1dGVWYWx1ZSIsInBhcnNlSlNYRWxlbWVudCIsInBhcnNlSlNYTmFtZVZhbHVlQXR0cmlidXRlIiwiSlNYQXR0cmlidXRlIiwicGFyc2VKU1hTcHJlYWRBdHRyaWJ1dGUiLCJhcmd1bWVudCIsIkpTWFNwcmVhZEF0dHJpYnV0ZSIsInBhcnNlSlNYQXR0cmlidXRlcyIsInBhcnNlSlNYT3BlbmluZ0VsZW1lbnQiLCJKU1hPcGVuaW5nRWxlbWVudCIsInBhcnNlSlNYQm91bmRhcnlFbGVtZW50IiwibmFtZV8zIiwiSlNYQ2xvc2luZ0VsZW1lbnQiLCJwYXJzZUpTWEVtcHR5RXhwcmVzc2lvbiIsIkpTWEVtcHR5RXhwcmVzc2lvbiIsInBhcnNlSlNYRXhwcmVzc2lvbkNvbnRhaW5lciIsInBhcnNlSlNYQ2hpbGRyZW4iLCJjaGlsZHJlbiIsIkpTWFRleHQiLCJjb250YWluZXIiLCJwYXJzZUNvbXBsZXhKU1hFbGVtZW50IiwiZWwiLCJvcGVuaW5nIiwiSlNYRWxlbWVudCIsImNsb3NpbmciLCJvcGVuXzEiLCJjbG9zZV8xIiwiaXNTdGFydE9mRXhwcmVzc2lvbiIsIlJlZ2V4IiwiTm9uQXNjaWlJZGVudGlmaWVyU3RhcnQiLCJOb25Bc2NpaUlkZW50aWZpZXJQYXJ0IiwiaXNXaGl0ZVNwYWNlIiwiaXNPY3RhbERpZ2l0Iiwib3BlbmluZ0VsZW1lbnQiLCJjbG9zaW5nRWxlbWVudCIsImxlZnQiLCJyaWdodCIsIkFzeW5jQXJyb3dGdW5jdGlvbkV4cHJlc3Npb24iLCJBc3luY0Z1bmN0aW9uRGVjbGFyYXRpb24iLCJBc3luY0Z1bmN0aW9uRXhwcmVzc2lvbiIsImxvZ2ljYWwiLCJsYWJlbCIsImNhbGxlZSIsInN1cGVyQ2xhc3MiLCJDb21wdXRlZE1lbWJlckV4cHJlc3Npb24iLCJjb21wdXRlZCIsImNvbnNlcXVlbnQiLCJhbHRlcm5hdGUiLCJEaXJlY3RpdmUiLCJkaXJlY3RpdmUiLCJkZWNsYXJhdGlvbiIsInNwZWNpZmllcnMiLCJleHBvcnRlZCIsImltcG9ydGVkIiwibWV0YSIsImlzU3RhdGljIiwic3RhdGljIiwiTW9kdWxlIiwicHJvcGVydGllcyIsInNob3J0aGFuZCIsIlJlZ2V4TGl0ZXJhbCIsInBhdHRlcm4iLCJTY3JpcHQiLCJleHByZXNzaW9ucyIsIlN0YXRpY01lbWJlckV4cHJlc3Npb24iLCJkaXNjcmltaW5hbnQiLCJjYXNlcyIsInF1YXNpIiwicXVhc2lzIiwiYmxvY2siLCJmaW5hbGl6ZXIiLCJkZWNsYXJhdGlvbnMiLCJhc3NlcnRfMSIsImVycm9yX2hhbmRsZXJfMSIsIm1lc3NhZ2VzXzEiLCJzY2FubmVyXzEiLCJBcnJvd1BhcmFtZXRlclBsYWNlSG9sZGVyIiwiRXJyb3JIYW5kbGVyIiwiU2Nhbm5lciIsInRyYWNrQ29tbWVudCIsIm9wZXJhdG9yUHJlY2VkZW5jZSIsImxvb2thaGVhZCIsImhhc0xpbmVUZXJtaW5hdG9yIiwiYXdhaXQiLCJhbGxvd0luIiwiYWxsb3dTdHJpY3REaXJlY3RpdmUiLCJhbGxvd1lpZWxkIiwiZmlyc3RDb3ZlckluaXRpYWxpemVkTmFtZUVycm9yIiwiaXNBc3NpZ25tZW50VGFyZ2V0IiwiaXNCaW5kaW5nRWxlbWVudCIsImluRnVuY3Rpb25Cb2R5IiwiaW5JdGVyYXRpb24iLCJpblN3aXRjaCIsImxhYmVsU2V0IiwibWVzc2FnZUZvcm1hdCIsIl9pIiwid2hvbGUiLCJjcmVhdGVFcnJvciIsInVuZXhwZWN0ZWRUb2tlbkVycm9yIiwiTWVzc2FnZXMiLCJVbmV4cGVjdGVkVG9rZW4iLCJVbmV4cGVjdGVkRU9TIiwiVW5leHBlY3RlZElkZW50aWZpZXIiLCJVbmV4cGVjdGVkTnVtYmVyIiwiVW5leHBlY3RlZFN0cmluZyIsIlVuZXhwZWN0ZWRUZW1wbGF0ZSIsImlzRnV0dXJlUmVzZXJ2ZWRXb3JkIiwiVW5leHBlY3RlZFJlc2VydmVkIiwiaXNTdHJpY3RNb2RlUmVzZXJ2ZWRXb3JkIiwiU3RyaWN0UmVzZXJ2ZWRXb3JkIiwibGFzdE1hcmtlckxpbmVTdGFydCIsInRvbGVyYXRlVW5leHBlY3RlZFRva2VuIiwibXVsdGlMaW5lIiwibmV4dFJlZ2V4VG9rZW4iLCJzY2FuUmVnRXhwIiwiY3JlYXRlTm9kZSIsInN0YXJ0Tm9kZSIsIm1hcmtlciIsImV4cGVjdCIsImV4cGVjdENvbW1hU2VwYXJhdG9yIiwiZXhwZWN0S2V5d29yZCIsImtleXdvcmQiLCJtYXRjaEtleXdvcmQiLCJtYXRjaENvbnRleHR1YWxLZXl3b3JkIiwibWF0Y2hBc3NpZ24iLCJpc29sYXRlQ292ZXJHcmFtbWFyIiwicGFyc2VGdW5jdGlvbiIsInByZXZpb3VzSXNCaW5kaW5nRWxlbWVudCIsInByZXZpb3VzSXNBc3NpZ25tZW50VGFyZ2V0IiwicHJldmlvdXNGaXJzdENvdmVySW5pdGlhbGl6ZWROYW1lRXJyb3IiLCJpbmhlcml0Q292ZXJHcmFtbWFyIiwiY29uc3VtZVNlbWljb2xvbiIsIm1hdGNoQXN5bmNGdW5jdGlvbiIsInBhcnNlRnVuY3Rpb25FeHByZXNzaW9uIiwiU3RyaWN0T2N0YWxMaXRlcmFsIiwicGFyc2VUZW1wbGF0ZUxpdGVyYWwiLCJwYXJzZUdyb3VwRXhwcmVzc2lvbiIsInBhcnNlQXJyYXlJbml0aWFsaXplciIsInBhcnNlT2JqZWN0SW5pdGlhbGl6ZXIiLCJwYXJzZUlkZW50aWZpZXJOYW1lIiwicGFyc2VDbGFzc0V4cHJlc3Npb24iLCJwYXJzZVNwcmVhZEVsZW1lbnQiLCJwYXJzZVByb3BlcnR5TWV0aG9kIiwicHJldmlvdXNTdHJpY3QiLCJwcmV2aW91c0FsbG93U3RyaWN0RGlyZWN0aXZlIiwic2ltcGxlIiwicGFyc2VGdW5jdGlvblNvdXJjZUVsZW1lbnRzIiwiZmlyc3RSZXN0cmljdGVkIiwic3RyaWN0ZWQiLCJwYXJzZVByb3BlcnR5TWV0aG9kRnVuY3Rpb24iLCJpc0dlbmVyYXRvciIsInByZXZpb3VzQWxsb3dZaWVsZCIsInBhcnNlRm9ybWFsUGFyYW1ldGVycyIsInBhcnNlUHJvcGVydHlNZXRob2RBc3luY0Z1bmN0aW9uIiwicHJldmlvdXNBd2FpdCIsInBhcnNlT2JqZWN0UHJvcGVydHlLZXkiLCJpc1Byb3BlcnR5S2V5IiwicGFyc2VPYmplY3RQcm9wZXJ0eSIsImhhc1Byb3RvIiwiaXNBc3luYyIsImxvb2thaGVhZFByb3BlcnR5S2V5IiwicXVhbGlmaWVkUHJvcGVydHlOYW1lIiwicGFyc2VHZXR0ZXJNZXRob2QiLCJwYXJzZVNldHRlck1ldGhvZCIsInBhcnNlR2VuZXJhdG9yTWV0aG9kIiwiRHVwbGljYXRlUHJvdG9Qcm9wZXJ0eSIsInBhcnNlVGVtcGxhdGVIZWFkIiwiY29va2VkIiwicGFyc2VUZW1wbGF0ZUVsZW1lbnQiLCJwYXJzZUV4cHJlc3Npb24iLCJyZWludGVycHJldEV4cHJlc3Npb25Bc1BhdHRlcm4iLCJzdGFydFRva2VuIiwicGFyc2VSZXN0RWxlbWVudCIsImFycm93IiwicGFyYW1ldGVycyIsInBhcnNlQXJndW1lbnRzIiwiaXNJZGVudGlmaWVyTmFtZSIsInBhcnNlTmV3RXhwcmVzc2lvbiIsInBhcnNlTGVmdEhhbmRTaWRlRXhwcmVzc2lvbiIsInBhcnNlQXN5bmNBcmd1bWVudCIsInBhcnNlQXN5bmNBcmd1bWVudHMiLCJwYXJzZUxlZnRIYW5kU2lkZUV4cHJlc3Npb25BbGxvd0NhbGwiLCJtYXliZUFzeW5jIiwicHJldmlvdXNBbGxvd0luIiwiYXN5bmNBcnJvdyIsInBhcnNlU3VwZXIiLCJwYXJzZVVwZGF0ZUV4cHJlc3Npb24iLCJwYXJzZVVuYXJ5RXhwcmVzc2lvbiIsImlzUmVzdHJpY3RlZFdvcmQiLCJTdHJpY3RMSFNQcmVmaXgiLCJJbnZhbGlkTEhTSW5Bc3NpZ25tZW50IiwiU3RyaWN0TEhTUG9zdGZpeCIsInBhcnNlQXdhaXRFeHByZXNzaW9uIiwiU3RyaWN0RGVsZXRlIiwicGFyc2VFeHBvbmVudGlhdGlvbkV4cHJlc3Npb24iLCJiaW5hcnlQcmVjZWRlbmNlIiwicHJlY2VkZW5jZSIsInBhcnNlQmluYXJ5RXhwcmVzc2lvbiIsInByZWMiLCJtYXJrZXJzIiwicHJlY2VkZW5jZXMiLCJwYXJzZUNvbmRpdGlvbmFsRXhwcmVzc2lvbiIsImNoZWNrUGF0dGVyblBhcmFtIiwidmFsaWRhdGVQYXJhbSIsInJlaW50ZXJwcmV0QXNDb3ZlckZvcm1hbHNMaXN0IiwicGFyYW1TZXQiLCJTdHJpY3RQYXJhbUR1cGUiLCJwYXJzZVlpZWxkRXhwcmVzc2lvbiIsIlN0cmljdExIU0Fzc2lnbm1lbnQiLCJwYXJzZVN0YXRlbWVudExpc3RJdGVtIiwic3RhdGVtZW50IiwiSWxsZWdhbEV4cG9ydERlY2xhcmF0aW9uIiwicGFyc2VFeHBvcnREZWNsYXJhdGlvbiIsIklsbGVnYWxJbXBvcnREZWNsYXJhdGlvbiIsInBhcnNlSW1wb3J0RGVjbGFyYXRpb24iLCJwYXJzZUxleGljYWxEZWNsYXJhdGlvbiIsImluRm9yIiwicGFyc2VGdW5jdGlvbkRlY2xhcmF0aW9uIiwicGFyc2VDbGFzc0RlY2xhcmF0aW9uIiwiaXNMZXhpY2FsRGVjbGFyYXRpb24iLCJwYXJzZVN0YXRlbWVudCIsInBhcnNlQmxvY2siLCJwYXJzZUxleGljYWxCaW5kaW5nIiwicGFyc2VQYXR0ZXJuIiwiU3RyaWN0VmFyTmFtZSIsIkRlY2xhcmF0aW9uTWlzc2luZ0luaXRpYWxpemVyIiwicGFyc2VCaW5kaW5nTGlzdCIsInBhcnNlQmluZGluZ1Jlc3RFbGVtZW50IiwicGFyc2VBcnJheVBhdHRlcm4iLCJwYXJzZVBhdHRlcm5XaXRoRGVmYXVsdCIsInBhcnNlUHJvcGVydHlQYXR0ZXJuIiwia2V5VG9rZW4iLCJwYXJzZVZhcmlhYmxlSWRlbnRpZmllciIsInBhcnNlT2JqZWN0UGF0dGVybiIsIkxldEluTGV4aWNhbEJpbmRpbmciLCJwYXJzZVZhcmlhYmxlRGVjbGFyYXRpb24iLCJwYXJzZVZhcmlhYmxlRGVjbGFyYXRpb25MaXN0IiwicGFyc2VWYXJpYWJsZVN0YXRlbWVudCIsInBhcnNlRW1wdHlTdGF0ZW1lbnQiLCJwYXJzZUV4cHJlc3Npb25TdGF0ZW1lbnQiLCJwYXJzZUlmQ2xhdXNlIiwiU3RyaWN0RnVuY3Rpb24iLCJwYXJzZUlmU3RhdGVtZW50IiwicGFyc2VEb1doaWxlU3RhdGVtZW50IiwicHJldmlvdXNJbkl0ZXJhdGlvbiIsInBhcnNlV2hpbGVTdGF0ZW1lbnQiLCJwYXJzZUZvclN0YXRlbWVudCIsImZvckluIiwiZGVjbCIsIkZvckluT2ZMb29wSW5pdGlhbGl6ZXIiLCJpbml0U3RhcnRUb2tlbiIsIkludmFsaWRMSFNJbkZvckluIiwiSW52YWxpZExIU0luRm9yTG9vcCIsImluaXRTZXEiLCJwYXJzZUNvbnRpbnVlU3RhdGVtZW50IiwiVW5rbm93bkxhYmVsIiwiSWxsZWdhbENvbnRpbnVlIiwicGFyc2VCcmVha1N0YXRlbWVudCIsIklsbGVnYWxCcmVhayIsInBhcnNlUmV0dXJuU3RhdGVtZW50IiwiSWxsZWdhbFJldHVybiIsImhhc0FyZ3VtZW50IiwicGFyc2VXaXRoU3RhdGVtZW50IiwiU3RyaWN0TW9kZVdpdGgiLCJwYXJzZVN3aXRjaENhc2UiLCJwYXJzZVN3aXRjaFN0YXRlbWVudCIsInByZXZpb3VzSW5Td2l0Y2giLCJkZWZhdWx0Rm91bmQiLCJjbGF1c2UiLCJNdWx0aXBsZURlZmF1bHRzSW5Td2l0Y2giLCJwYXJzZUxhYmVsbGVkU3RhdGVtZW50IiwiUmVkZWNsYXJhdGlvbiIsIkdlbmVyYXRvckluTGVnYWN5Q29udGV4dCIsInBhcnNlVGhyb3dTdGF0ZW1lbnQiLCJOZXdsaW5lQWZ0ZXJUaHJvdyIsInBhcnNlQ2F0Y2hDbGF1c2UiLCJwYXJhbU1hcCIsIkR1cGxpY2F0ZUJpbmRpbmciLCJTdHJpY3RDYXRjaFZhcmlhYmxlIiwicGFyc2VGaW5hbGx5Q2xhdXNlIiwicGFyc2VUcnlTdGF0ZW1lbnQiLCJOb0NhdGNoT3JGaW5hbGx5IiwicGFyc2VEZWJ1Z2dlclN0YXRlbWVudCIsInBhcnNlRGlyZWN0aXZlUHJvbG9ndWVzIiwicHJldmlvdXNMYWJlbFNldCIsInByZXZpb3VzSW5GdW5jdGlvbkJvZHkiLCJTdHJpY3RQYXJhbU5hbWUiLCJEZWZhdWx0UmVzdFBhcmFtZXRlciIsIlBhcmFtZXRlckFmdGVyUmVzdFBhcmFtZXRlciIsInBhcnNlRm9ybWFsUGFyYW1ldGVyIiwiaWRlbnRpZmllcklzT3B0aW9uYWwiLCJTdHJpY3RGdW5jdGlvbk5hbWUiLCJwcmV2aW91c0FsbG93QXdhaXQiLCJmb3JtYWxQYXJhbWV0ZXJzIiwicGFyc2VEaXJlY3RpdmUiLCJJbGxlZ2FsTGFuZ3VhZ2VNb2RlRGlyZWN0aXZlIiwiQmFkR2V0dGVyQXJpdHkiLCJCYWRTZXR0ZXJBcml0eSIsIkJhZFNldHRlclJlc3RQYXJhbWV0ZXIiLCJwYXJzZUNsYXNzRWxlbWVudCIsImhhc0NvbnN0cnVjdG9yIiwicHVuY3R1YXRvciIsIkNvbnN0cnVjdG9ySXNBc3luYyIsIlN0YXRpY1Byb3RvdHlwZSIsIkNvbnN0cnVjdG9yU3BlY2lhbE1ldGhvZCIsIkR1cGxpY2F0ZUNvbnN0cnVjdG9yIiwicGFyc2VDbGFzc0VsZW1lbnRMaXN0IiwicGFyc2VDbGFzc0JvZHkiLCJlbGVtZW50TGlzdCIsImNsYXNzQm9keSIsInBhcnNlTW9kdWxlU3BlY2lmaWVyIiwiSW52YWxpZE1vZHVsZVNwZWNpZmllciIsInBhcnNlSW1wb3J0U3BlY2lmaWVyIiwicGFyc2VOYW1lZEltcG9ydHMiLCJwYXJzZUltcG9ydERlZmF1bHRTcGVjaWZpZXIiLCJwYXJzZUltcG9ydE5hbWVzcGFjZVNwZWNpZmllciIsIk5vQXNBZnRlckltcG9ydE5hbWVzcGFjZSIsIk1pc3NpbmdGcm9tQ2xhdXNlIiwicGFyc2VFeHBvcnRTcGVjaWZpZXIiLCJleHBvcnREZWNsYXJhdGlvbiIsImlzRXhwb3J0RnJvbUlkZW50aWZpZXIiLCJjb25kaXRpb24iLCJyZWNvcmRFcnJvciIsImNvbnN0cnVjdEVycm9yIiwiY29sIiwiSW52YWxpZEVzY2FwZWRSZXNlcnZlZFdvcmQiLCJJbnZhbGlkSGV4RXNjYXBlU2VxdWVuY2UiLCJJbnZhbGlkUmVnRXhwIiwiVGVtcGxhdGVPY3RhbExpdGVyYWwiLCJVbmV4cGVjdGVkVG9rZW5JbGxlZ2FsIiwiVW50ZXJtaW5hdGVkUmVnRXhwIiwiaGV4VmFsdWUiLCJvY3RhbFZhbHVlIiwiY3VybHlTdGFjayIsInNraXBTaW5nbGVMaW5lQ29tbWVudCIsInNraXBNdWx0aUxpbmVDb21tZW50IiwiaXNLZXl3b3JkIiwiY29kZVBvaW50QXQiLCJmaXJzdCIsInNjYW5IZXhFc2NhcGUiLCJzY2FuVW5pY29kZUNvZGVQb2ludEVzY2FwZSIsImdldElkZW50aWZpZXIiLCJnZXRDb21wbGV4SWRlbnRpZmllciIsIm9jdGFsVG9EZWNpbWFsIiwic2NhbklkZW50aWZpZXIiLCJyZXN0b3JlIiwic2NhblB1bmN0dWF0b3IiLCJzY2FuSGV4TGl0ZXJhbCIsInNjYW5CaW5hcnlMaXRlcmFsIiwic2Nhbk9jdGFsTGl0ZXJhbCIsImlzSW1wbGljaXRPY3RhbExpdGVyYWwiLCJzY2FuTnVtZXJpY0xpdGVyYWwiLCJzY2FuU3RyaW5nTGl0ZXJhbCIsInVuZXNjYXBlZF8xIiwidW5lc2NhcGVkIiwib2N0VG9EZWMiLCJzY2FuVGVtcGxhdGUiLCJyYXdPZmZzZXQiLCJ1bmVzY2FwZWRfMiIsInRlc3RSZWdFeHAiLCJhc3RyYWxTdWJzdGl0dXRlIiwiJDIiLCJzY2FuUmVnRXhwQm9keSIsImNsYXNzTWFya2VyIiwic2NhblJlZ0V4cEZsYWdzIiwiY2hhciIsInF1b3QiLCJhbXAiLCJhcG9zIiwibmJzcCIsImlleGNsIiwiY2VudCIsInBvdW5kIiwiY3VycmVuIiwieWVuIiwiYnJ2YmFyIiwic2VjdCIsInVtbCIsIm9yZGYiLCJsYXF1byIsInNoeSIsInJlZyIsIm1hY3IiLCJkZWciLCJwbHVzbW4iLCJzdXAyIiwic3VwMyIsImFjdXRlIiwibWljcm8iLCJwYXJhIiwibWlkZG90IiwiY2VkaWwiLCJzdXAxIiwib3JkbSIsInJhcXVvIiwiZnJhYzE0IiwiZnJhYzEyIiwiZnJhYzM0IiwiaXF1ZXN0IiwiQWdyYXZlIiwiQWFjdXRlIiwiQWNpcmMiLCJBdGlsZGUiLCJBdW1sIiwiQXJpbmciLCJBRWxpZyIsIkNjZWRpbCIsIkVncmF2ZSIsIkVhY3V0ZSIsIkVjaXJjIiwiRXVtbCIsIklncmF2ZSIsIklhY3V0ZSIsIkljaXJjIiwiSXVtbCIsIkVUSCIsIk50aWxkZSIsIk9ncmF2ZSIsIk9hY3V0ZSIsIk9jaXJjIiwiT3RpbGRlIiwiT3VtbCIsInRpbWVzIiwiT3NsYXNoIiwiVWdyYXZlIiwiVWFjdXRlIiwiVWNpcmMiLCJVdW1sIiwiWWFjdXRlIiwiVEhPUk4iLCJzemxpZyIsImFncmF2ZSIsImFhY3V0ZSIsImFjaXJjIiwiYXRpbGRlIiwiYXVtbCIsImFyaW5nIiwiYWVsaWciLCJjY2VkaWwiLCJlZ3JhdmUiLCJlYWN1dGUiLCJlY2lyYyIsImV1bWwiLCJpZ3JhdmUiLCJpYWN1dGUiLCJpY2lyYyIsIml1bWwiLCJldGgiLCJudGlsZGUiLCJvZ3JhdmUiLCJvYWN1dGUiLCJvY2lyYyIsIm90aWxkZSIsIm91bWwiLCJkaXZpZGUiLCJvc2xhc2giLCJ1Z3JhdmUiLCJ1YWN1dGUiLCJ1Y2lyYyIsInV1bWwiLCJ5YWN1dGUiLCJ0aG9ybiIsInl1bWwiLCJPRWxpZyIsIm9lbGlnIiwiU2Nhcm9uIiwic2Nhcm9uIiwiWXVtbCIsImZub2YiLCJjaXJjIiwidGlsZGUiLCJBbHBoYSIsIkJldGEiLCJHYW1tYSIsIkRlbHRhIiwiRXBzaWxvbiIsIlpldGEiLCJFdGEiLCJUaGV0YSIsIklvdGEiLCJLYXBwYSIsIkxhbWJkYSIsIk11IiwiTnUiLCJYaSIsIk9taWNyb24iLCJQaSIsIlJobyIsIlNpZ21hIiwiVGF1IiwiVXBzaWxvbiIsIlBoaSIsIkNoaSIsIlBzaSIsIk9tZWdhIiwiYWxwaGEiLCJiZXRhIiwiZ2FtbWEiLCJlcHNpbG9uIiwiemV0YSIsImV0YSIsInRoZXRhIiwiaW90YSIsImthcHBhIiwibGFtYmRhIiwibXUiLCJudSIsInhpIiwib21pY3JvbiIsInBpIiwicmhvIiwic2lnbWFmIiwic2lnbWEiLCJ0YXUiLCJ1cHNpbG9uIiwicGhpIiwiY2hpIiwicHNpIiwib21lZ2EiLCJ0aGV0YXN5bSIsInVwc2loIiwicGl2IiwiZW5zcCIsImVtc3AiLCJ0aGluc3AiLCJ6d25qIiwiendqIiwibHJtIiwicmxtIiwibmRhc2giLCJtZGFzaCIsImxzcXVvIiwicnNxdW8iLCJzYnF1byIsImxkcXVvIiwicmRxdW8iLCJiZHF1byIsImRhZ2dlciIsIkRhZ2dlciIsImJ1bGwiLCJoZWxsaXAiLCJwZXJtaWwiLCJwcmltZSIsIlByaW1lIiwibHNhcXVvIiwicnNhcXVvIiwib2xpbmUiLCJmcmFzbCIsImV1cm8iLCJpbWFnZSIsIndlaWVycCIsInJlYWwiLCJ0cmFkZSIsImFsZWZzeW0iLCJsYXJyIiwidWFyciIsInJhcnIiLCJkYXJyIiwiaGFyciIsImNyYXJyIiwibEFyciIsInVBcnIiLCJyQXJyIiwiZEFyciIsImhBcnIiLCJmb3JhbGwiLCJleGlzdCIsImVtcHR5IiwibmFibGEiLCJpc2luIiwibm90aW4iLCJuaSIsInByb2QiLCJzdW0iLCJtaW51cyIsImxvd2FzdCIsInJhZGljIiwiaW5maW4iLCJhbmciLCJhbmQiLCJvciIsImNhcCIsImN1cCIsImludCIsInRoZXJlNCIsInNpbSIsImNvbmciLCJhc3ltcCIsIm5lIiwiZXF1aXYiLCJsZSIsImdlIiwic3ViIiwic3VwIiwibnN1YiIsInN1YmUiLCJzdXBlIiwib3BsdXMiLCJvdGltZXMiLCJwZXJwIiwic2RvdCIsImxjZWlsIiwicmNlaWwiLCJsZmxvb3IiLCJyZmxvb3IiLCJsb3oiLCJzcGFkZXMiLCJjbHVicyIsImhlYXJ0cyIsImRpYW1zIiwibGFuZyIsInJhbmciLCJSZWFkZXIiLCJjdXJseSIsInBhcmVuIiwiYmVmb3JlRnVuY3Rpb25FeHByZXNzaW9uIiwiaXNSZWdleFN0YXJ0IiwicHJldmlvdXMiLCJ0cmFja1JhbmdlIiwidHJhY2tMb2MiLCJyZWFkZXIiLCJzdGFydFJlZ2V4IiwiQ0hBUl9UQUIiLCJDSEFSX0xJTkVfRkVFRCIsIkNIQVJfU1BBQ0UiLCJDSEFSX0VYQ0xBTUFUSU9OIiwiQ0hBUl9ET1VCTEVfUVVPVEUiLCJDSEFSX1NIQVJQIiwiQ0hBUl9QRVJDRU5UIiwiQ0hBUl9BTVBFUlNBTkQiLCJDSEFSX1NJTkdMRV9RVU9URSIsIkNIQVJfQVNURVJJU0siLCJDSEFSX0NPTU1BIiwiQ0hBUl9NSU5VUyIsIkNIQVJfQ09MT04iLCJDSEFSX0dSRUFURVJfVEhBTiIsIkNIQVJfUVVFU1RJT04iLCJDSEFSX0NPTU1FUkNJQUxfQVQiLCJDSEFSX0xFRlRfU1FVQVJFX0JSQUNLRVQiLCJDSEFSX1JJR0hUX1NRVUFSRV9CUkFDS0VUIiwiQ0hBUl9HUkFWRV9BQ0NFTlQiLCJDSEFSX0xFRlRfQ1VSTFlfQlJBQ0tFVCIsIkNIQVJfVkVSVElDQUxfTElORSIsIkNIQVJfUklHSFRfQ1VSTFlfQlJBQ0tFVCIsIkVTQ0FQRV9TRVFVRU5DRVMiLCJERVBSRUNBVEVEX0JPT0xFQU5TX1NZTlRBWCIsImNvbXBpbGVTdHlsZU1hcCIsImVuY29kZUhleCIsImNoYXJhY3RlciIsInNraXBJbnZhbGlkIiwiZmxvd0xldmVsIiwic3R5bGVNYXAiLCJzb3J0S2V5cyIsImxpbmVXaWR0aCIsIm5vUmVmcyIsIm5vQ29tcGF0TW9kZSIsImNvbmRlbnNlRmxvdyIsImV4cGxpY2l0VHlwZXMiLCJkdXBsaWNhdGVzIiwidXNlZER1cGxpY2F0ZXMiLCJpbmRlbnRTdHJpbmciLCJpbmQiLCJnZW5lcmF0ZU5leHRMaW5lIiwidGVzdEltcGxpY2l0UmVzb2x2aW5nIiwiaXNQcmludGFibGUiLCJpc1BsYWluU2FmZSIsImlzUGxhaW5TYWZlRmlyc3QiLCJTVFlMRV9QTEFJTiIsIlNUWUxFX1NJTkdMRSIsIlNUWUxFX0xJVEVSQUwiLCJTVFlMRV9GT0xERUQiLCJTVFlMRV9ET1VCTEUiLCJjaG9vc2VTY2FsYXJTdHlsZSIsInNpbmdsZUxpbmVPbmx5IiwiaW5kZW50UGVyTGV2ZWwiLCJ0ZXN0QW1iaWd1b3VzVHlwZSIsImhhc0xpbmVCcmVhayIsImhhc0ZvbGRhYmxlTGluZSIsInNob3VsZFRyYWNrV2lkdGgiLCJwcmV2aW91c0xpbmVCcmVhayIsInBsYWluIiwid3JpdGVTY2FsYXIiLCJpc2tleSIsInRlc3RBbWJpZ3VpdHkiLCJibG9ja0hlYWRlciIsImRyb3BFbmRpbmdOZXdsaW5lIiwiZm9sZFN0cmluZyIsImVzY2FwZVN0cmluZyIsImluZGVudEluZGljYXRvciIsImNsaXAiLCJrZWVwIiwiY2hvbXAiLCJ3aWR0aCIsImxpbmVSZSIsIm5leHRMRiIsImZvbGRMaW5lIiwicHJldk1vcmVJbmRlbnRlZCIsIm1vcmVJbmRlbnRlZCIsImJyZWFrUmUiLCJuZXh0Q2hhciIsImVzY2FwZVNlcSIsIndyaXRlRmxvd1NlcXVlbmNlIiwid3JpdGVOb2RlIiwid3JpdGVCbG9ja1NlcXVlbmNlIiwid3JpdGVGbG93TWFwcGluZyIsIm9iamVjdEtleUxpc3QiLCJvYmplY3RLZXkiLCJvYmplY3RWYWx1ZSIsInBhaXJCdWZmZXIiLCJ3cml0ZUJsb2NrTWFwcGluZyIsImV4cGxpY2l0UGFpciIsImRldGVjdFR5cGUiLCJ0eXBlTGlzdCIsIm9iamVjdE9yQXJyYXkiLCJkdXBsaWNhdGVJbmRleCIsImR1cGxpY2F0ZSIsImdldER1cGxpY2F0ZVJlZmVyZW5jZXMiLCJvYmplY3RzIiwiZHVwbGljYXRlc0luZGV4ZXMiLCJpbnNwZWN0Tm9kZSIsImNyZWF0b3IiLCJoYXNWYWx1ZSIsIlNvdXJjZU1hcENvbnN1bWVyIiwiZXJyb3JGb3JtYXR0ZXJJbnN0YWxsZWQiLCJ1bmNhdWdodFNoaW1JbnN0YWxsZWQiLCJlbXB0eUNhY2hlQmV0d2Vlbk9wZXJhdGlvbnMiLCJlbnZpcm9ubWVudCIsImZpbGVDb250ZW50c0NhY2hlIiwic291cmNlTWFwQ2FjaGUiLCJyZVNvdXJjZU1hcCIsInJldHJpZXZlRmlsZUhhbmRsZXJzIiwicmV0cmlldmVNYXBIYW5kbGVycyIsImlzSW5Ccm93c2VyIiwiWE1MSHR0cFJlcXVlc3QiLCJoYXNHbG9iYWxQcm9jZXNzRXZlbnRFbWl0dGVyIiwiaGFuZGxlckV4ZWMiLCJyZXRyaWV2ZUZpbGUiLCJjb250ZW50cyIsInhociIsInNlbmQiLCJyZWFkeVN0YXRlIiwic3RhdHVzIiwicmVzcG9uc2VUZXh0Iiwic3VwcG9ydFJlbGF0aXZlVVJMIiwicmV0cmlldmVTb3VyY2VNYXBVUkwiLCJmaWxlRGF0YSIsInNvdXJjZU1hcEhlYWRlciIsImdldFJlc3BvbnNlSGVhZGVyIiwibGFzdE1hdGNoIiwicmV0cmlldmVTb3VyY2VNYXAiLCJzb3VyY2VNYXBwaW5nVVJMIiwic291cmNlTWFwRGF0YSIsIm1hcFNvdXJjZVBvc2l0aW9uIiwic291cmNlTWFwIiwidXJsQW5kTWFwIiwib3JpZ2luYWxQb3NpdGlvbiIsIm1hcEV2YWxPcmlnaW4iLCJvcmlnaW4iLCJDYWxsU2l0ZVRvU3RyaW5nIiwiZmlsZUxvY2F0aW9uIiwiaXNOYXRpdmUiLCJnZXRTY3JpcHROYW1lT3JTb3VyY2VVUkwiLCJpc0V2YWwiLCJnZXRFdmFsT3JpZ2luIiwiZ2V0TGluZU51bWJlciIsImNvbHVtbk51bWJlciIsImdldENvbHVtbk51bWJlciIsImZ1bmN0aW9uTmFtZSIsImdldEZ1bmN0aW9uTmFtZSIsImFkZFN1ZmZpeCIsImlzQ29uc3RydWN0b3IiLCJpc01ldGhvZENhbGwiLCJpc1RvcGxldmVsIiwidHlwZU5hbWUiLCJnZXRUeXBlTmFtZSIsImdldE1ldGhvZE5hbWUiLCJjbG9uZUNhbGxTaXRlIiwiZnJhbWUiLCJ3cmFwQ2FsbFNpdGUiLCJnZXRGaWxlTmFtZSIsImhlYWRlckxlbmd0aCIsInByZXBhcmVTdGFja1RyYWNlIiwiZ2V0RXJyb3JTb3VyY2UiLCJwcmludEVycm9yQW5kRXhpdCIsInNoaW1FbWl0VW5jYXVnaHRFeGNlcHRpb24iLCJvcmlnRW1pdCIsImhhc0xpc3RlbmVycyIsImxpc3RlbmVycyIsIm92ZXJyaWRlUmV0cmlldmVGaWxlIiwib3ZlcnJpZGVSZXRyaWV2ZVNvdXJjZU1hcCIsImhvb2tSZXF1aXJlIiwiJGNvbXBpbGUiLCJfY29tcGlsZSIsIl9fc291cmNlTWFwU3VwcG9ydCIsImluc3RhbGxIYW5kbGVyIiwiaGFuZGxlVW5jYXVnaHRFeGNlcHRpb25zIiwiU291cmNlTm9kZSIsImludFRvQ2hhck1hcCIsImNoYXJDb2RlIiwiYmlnQSIsImJpZ1oiLCJsaXR0bGVBIiwibGl0dGxlWiIsInplcm8iLCJuaW5lIiwicGx1cyIsInNsYXNoIiwibGl0dGxlT2Zmc2V0IiwibnVtYmVyT2Zmc2V0IiwiZ2VuZXJhdGVkUG9zaXRpb25BZnRlciIsImxpbmVBIiwibGluZUIiLCJjb2x1bW5BIiwiY29sdW1uQiIsIl9zb3J0ZWQiLCJfbGFzdCIsIk1hcHBpbmdMaXN0X2ZvckVhY2giLCJhQ2FsbGJhY2siLCJhVGhpc0FyZyIsIk1hcHBpbmdMaXN0X2FkZCIsImFNYXBwaW5nIiwiTWFwcGluZ0xpc3RfdG9BcnJheSIsImJpbmFyeVNlYXJjaCIsInF1aWNrU29ydCIsImFTb3VyY2VNYXAiLCJhU291cmNlTWFwVVJMIiwic2VjdGlvbnMiLCJJbmRleGVkU291cmNlTWFwQ29uc3VtZXIiLCJCYXNpY1NvdXJjZU1hcENvbnN1bWVyIiwiX19nZW5lcmF0ZWRNYXBwaW5ncyIsIl9wYXJzZU1hcHBpbmdzIiwiX19vcmlnaW5hbE1hcHBpbmdzIiwiX2NoYXJJc01hcHBpbmdTZXBhcmF0b3IiLCJTb3VyY2VNYXBDb25zdW1lcl9jaGFySXNNYXBwaW5nU2VwYXJhdG9yIiwiU291cmNlTWFwQ29uc3VtZXJfcGFyc2VNYXBwaW5ncyIsIkdFTkVSQVRFRF9PUkRFUiIsIk9SSUdJTkFMX09SREVSIiwiR1JFQVRFU1RfTE9XRVJfQk9VTkQiLCJMRUFTVF9VUFBFUl9CT1VORCIsIlNvdXJjZU1hcENvbnN1bWVyX2VhY2hNYXBwaW5nIiwiYUNvbnRleHQiLCJhT3JkZXIiLCJvcmRlciIsIl9nZW5lcmF0ZWRNYXBwaW5ncyIsIl9vcmlnaW5hbE1hcHBpbmdzIiwiX3NvdXJjZU1hcFVSTCIsImFsbEdlbmVyYXRlZFBvc2l0aW9uc0ZvciIsIlNvdXJjZU1hcENvbnN1bWVyX2FsbEdlbmVyYXRlZFBvc2l0aW9uc0ZvciIsIm5lZWRsZSIsIl9maW5kU291cmNlSW5kZXgiLCJfZmluZE1hcHBpbmciLCJsYXN0Q29sdW1uIiwiX2Fic29sdXRlU291cmNlcyIsImNvbnN1bWVyIiwicmVsYXRpdmVTb3VyY2UiLCJTb3VyY2VNYXBDb25zdW1lcl9mcm9tU291cmNlTWFwIiwic21jIiwiZ2VuZXJhdGVkTWFwcGluZ3MiLCJkZXN0R2VuZXJhdGVkTWFwcGluZ3MiLCJkZXN0T3JpZ2luYWxNYXBwaW5ncyIsInNyY01hcHBpbmciLCJkZXN0TWFwcGluZyIsIk1hcHBpbmciLCJjYWNoZWRTZWdtZW50cyIsInRlbXAiLCJvcmlnaW5hbE1hcHBpbmdzIiwic2VnbWVudCIsIlNvdXJjZU1hcENvbnN1bWVyX2ZpbmRNYXBwaW5nIiwiYU5lZWRsZSIsImFNYXBwaW5ncyIsImFMaW5lTmFtZSIsImFDb2x1bW5OYW1lIiwiYUNvbXBhcmF0b3IiLCJhQmlhcyIsImNvbXB1dGVDb2x1bW5TcGFucyIsIlNvdXJjZU1hcENvbnN1bWVyX2NvbXB1dGVDb2x1bW5TcGFucyIsIm5leHRNYXBwaW5nIiwibGFzdEdlbmVyYXRlZENvbHVtbiIsIlNvdXJjZU1hcENvbnN1bWVyX29yaWdpbmFsUG9zaXRpb25Gb3IiLCJoYXNDb250ZW50c09mQWxsU291cmNlcyIsIkJhc2ljU291cmNlTWFwQ29uc3VtZXJfaGFzQ29udGVudHNPZkFsbFNvdXJjZXMiLCJzYyIsIlNvdXJjZU1hcENvbnN1bWVyX3NvdXJjZUNvbnRlbnRGb3IiLCJudWxsT25NaXNzaW5nIiwiZmlsZVVyaUFic1BhdGgiLCJnZW5lcmF0ZWRQb3NpdGlvbkZvciIsIlNvdXJjZU1hcENvbnN1bWVyX2dlbmVyYXRlZFBvc2l0aW9uRm9yIiwibGFzdE9mZnNldCIsIl9zZWN0aW9ucyIsIm9mZnNldExpbmUiLCJvZmZzZXRDb2x1bW4iLCJnZW5lcmF0ZWRPZmZzZXQiLCJJbmRleGVkU291cmNlTWFwQ29uc3VtZXJfb3JpZ2luYWxQb3NpdGlvbkZvciIsInNlY3Rpb25JbmRleCIsInNlY3Rpb24iLCJiaWFzIiwiSW5kZXhlZFNvdXJjZU1hcENvbnN1bWVyX2hhc0NvbnRlbnRzT2ZBbGxTb3VyY2VzIiwiSW5kZXhlZFNvdXJjZU1hcENvbnN1bWVyX3NvdXJjZUNvbnRlbnRGb3IiLCJJbmRleGVkU291cmNlTWFwQ29uc3VtZXJfZ2VuZXJhdGVkUG9zaXRpb25Gb3IiLCJnZW5lcmF0ZWRQb3NpdGlvbiIsIkluZGV4ZWRTb3VyY2VNYXBDb25zdW1lcl9wYXJzZU1hcHBpbmdzIiwic2VjdGlvbk1hcHBpbmdzIiwiYWRqdXN0ZWRNYXBwaW5nIiwicmVjdXJzaXZlU2VhcmNoIiwiYUxvdyIsImFIaWdoIiwiYUhheXN0YWNrIiwiYUNvbXBhcmUiLCJtaWQiLCJzd2FwIiwiYXJ5IiwicmFuZG9tSW50SW5SYW5nZSIsImRvUXVpY2tTb3J0IiwicGl2b3RJbmRleCIsInBpdm90IiwiUkVHRVhfTkVXTElORSIsIk5FV0xJTkVfQ09ERSIsImlzU291cmNlTm9kZSIsImFMaW5lIiwiYUNvbHVtbiIsImFDaHVua3MiLCJzb3VyY2VDb250ZW50cyIsImZyb21TdHJpbmdXaXRoU291cmNlTWFwIiwiU291cmNlTm9kZV9mcm9tU3RyaW5nV2l0aFNvdXJjZU1hcCIsImFHZW5lcmF0ZWRDb2RlIiwiYVJlbGF0aXZlUGF0aCIsInJlbWFpbmluZ0xpbmVzIiwicmVtYWluaW5nTGluZXNJbmRleCIsInNoaWZ0TmV4dExpbmUiLCJsaW5lQ29udGVudHMiLCJnZXROZXh0TGluZSIsIm5ld0xpbmUiLCJsYXN0R2VuZXJhdGVkTGluZSIsImxhc3RNYXBwaW5nIiwiYWRkTWFwcGluZ1dpdGhDb2RlIiwibmV4dExpbmUiLCJTb3VyY2VOb2RlX2FkZCIsImFDaHVuayIsInByZXBlbmQiLCJTb3VyY2VOb2RlX3ByZXBlbmQiLCJ3YWxrIiwiU291cmNlTm9kZV93YWxrIiwiYUZuIiwiU291cmNlTm9kZV9qb2luIiwiYVNlcCIsIm5ld0NoaWxkcmVuIiwicmVwbGFjZVJpZ2h0IiwiU291cmNlTm9kZV9yZXBsYWNlUmlnaHQiLCJhUGF0dGVybiIsImFSZXBsYWNlbWVudCIsImxhc3RDaGlsZCIsIlNvdXJjZU5vZGVfc2V0U291cmNlQ29udGVudCIsIndhbGtTb3VyY2VDb250ZW50cyIsIlNvdXJjZU5vZGVfd2Fsa1NvdXJjZUNvbnRlbnRzIiwiU291cmNlTm9kZV90b1N0cmluZyIsInRvU3RyaW5nV2l0aFNvdXJjZU1hcCIsIlNvdXJjZU5vZGVfdG9TdHJpbmdXaXRoU291cmNlTWFwIiwic291cmNlTWFwcGluZ0FjdGl2ZSIsImxhc3RPcmlnaW5hbFNvdXJjZSIsImxhc3RPcmlnaW5hbExpbmUiLCJsYXN0T3JpZ2luYWxDb2x1bW4iLCJsYXN0T3JpZ2luYWxOYW1lIiwic291cmNlQ29udGVudCIsInByb3h5TG9naW5DYWxsYmFjayIsInNraXBEaXJDcmVhdGlvbiIsIm5ldCIsImFkZFByb3h5TG9naW5IYW5kbGVyIiwiX0JpbnRyYXlQcm92aWRlciIsIl9sb2FkX0JpbnRyYXlQcm92aWRlciIsIl9HaXRIdWJQcm92aWRlciIsIl9sb2FkX0dpdEh1YlByb3ZpZGVyIiwiX1ByaXZhdGVHaXRIdWJQcm92aWRlciIsIl9sb2FkX1ByaXZhdGVHaXRIdWJQcm92aWRlciIsImdpdGh1Yk9wdGlvbnMiLCJwcml2YXRlIiwiR0hfVE9LRU4iLCJQcml2YXRlR2l0SHViUHJvdmlkZXIiLCJCaW50cmF5UHJvdmlkZXIiLCJfYmludHJheSIsIl9sb2FkX2JpbnRyYXkiLCJCaW50cmF5Q2xpZW50IiwiY2hhbm5lbEZpbGVuYW1lIiwiZ2V0VmVyc2lvbkZpbGVzIiwiYXBpS2V5IiwicGFja2FnZSIsInBhY2thZ2VOYW1lIiwidXNlciIsImNvbXBvbmVudCIsImRpc3RyaWJ1dGlvbiIsImJpbnRyYXlSZXF1ZXN0IiwiY3JlYXRlVmVyc2lvbiIsImRlbGV0ZVZlcnNpb24iLCJnZXRMYXRlc3RWZXJzaW9uSW5mbyIsImFzc2V0IiwiYXNzZXRzIiwiaHRtbF91cmwiLCJjb25maWd1cmVIZWFkZXJzIiwiYWNjZXB0IiwiX2NoaWxkX3Byb2Nlc3MiLCJfbG9hZF9jaGlsZF9wcm9jZXNzIiwiX0Jhc2VVcGRhdGVyIiwiX2xvYWRfQmFzZVVwZGF0ZXIiLCJfRmlsZVdpdGhFbWJlZGRlZEJsb2NrTWFwRGlmZmVyZW50aWFsRG93bmxvYWRlciIsIl9sb2FkX0ZpbGVXaXRoRW1iZWRkZWRCbG9ja01hcERpZmZlcmVudGlhbERvd25sb2FkZXIiLCJfR2VuZXJpY0RpZmZlcmVudGlhbERvd25sb2FkZXIiLCJfbG9hZF9HZW5lcmljRGlmZmVyZW50aWFsRG93bmxvYWRlciIsIl93aW5kb3dzRXhlY3V0YWJsZUNvZGVTaWduYXR1cmVWZXJpZmllciIsIl9sb2FkX3dpbmRvd3NFeGVjdXRhYmxlQ29kZVNpZ25hdHVyZVZlcmlmaWVyIiwicGFja2FnZVBhdGgiLCJnZXREb3dubG9hZGVkRmlsZSIsImRpZmZlcmVudGlhbERvd25sb2FkSW5zdGFsbGVyIiwic2lnbmF0dXJlVmVyaWZpY2F0aW9uU3RhdHVzIiwidmVyaWZ5U2lnbmF0dXJlIiwiZXh0bmFtZSIsImRpZmZlcmVudGlhbERvd25sb2FkV2ViUGFja2FnZSIsIl94MiIsIl94MyIsInNldERvd25sb2FkZWRGaWxlIiwidGVtcFVwZGF0ZUZpbGUiLCJwdWJsaXNoZXJOYW1lIiwic3Bhd25PcHRpb25zIiwiZGV0YWNoZWQiLCJzdGRpbyIsInVucmVmIiwiX19OU0lTX0RJRkZFUkVOVElBTF9VUERBVEVfXyIsImJsb2NrTWFwRGF0YSIsIkdlbmVyaWNEaWZmZXJlbnRpYWxEb3dubG9hZGVyIiwiX2xvZGFzaCIsIl9sb2FkX2xvZGFzaCIsInNldHVwUGF0aCIsIl9wYWNrYWdlUGF0aCIsIkxBUkdFX0FSUkFZX1NJWkUiLCJIQVNIX1VOREVGSU5FRCIsIkNPTVBBUkVfUEFSVElBTF9GTEFHIiwiQ09NUEFSRV9VTk9SREVSRURfRkxBRyIsImFyZ3NUYWciLCJhcnJheVRhZyIsImFzeW5jVGFnIiwiYm9vbFRhZyIsImRhdGVUYWciLCJlcnJvclRhZyIsImZ1bmNUYWciLCJnZW5UYWciLCJtYXBUYWciLCJudW1iZXJUYWciLCJudWxsVGFnIiwib2JqZWN0VGFnIiwicHJvbWlzZVRhZyIsInByb3h5VGFnIiwicmVnZXhwVGFnIiwic2V0VGFnIiwic3RyaW5nVGFnIiwic3ltYm9sVGFnIiwidW5kZWZpbmVkVGFnIiwid2Vha01hcFRhZyIsImFycmF5QnVmZmVyVGFnIiwiZGF0YVZpZXdUYWciLCJmbG9hdDMyVGFnIiwiZmxvYXQ2NFRhZyIsImludDhUYWciLCJpbnQxNlRhZyIsImludDMyVGFnIiwidWludDhUYWciLCJ1aW50OENsYW1wZWRUYWciLCJ1aW50MTZUYWciLCJ1aW50MzJUYWciLCJyZVJlZ0V4cENoYXIiLCJyZUlzSG9zdEN0b3IiLCJyZUlzVWludCIsInR5cGVkQXJyYXlUYWdzIiwiZnJlZUdsb2JhbCIsImZyZWVTZWxmIiwiZnJlZUV4cG9ydHMiLCJmcmVlTW9kdWxlIiwibW9kdWxlRXhwb3J0cyIsImZyZWVQcm9jZXNzIiwibm9kZVV0aWwiLCJiaW5kaW5nIiwibm9kZUlzVHlwZWRBcnJheSIsImlzVHlwZWRBcnJheSIsImFycmF5RmlsdGVyIiwicmVzSW5kZXgiLCJhcnJheVB1c2giLCJhcnJheVNvbWUiLCJiYXNlVGltZXMiLCJpdGVyYXRlZSIsImJhc2VVbmFyeSIsImZ1bmMiLCJjYWNoZUhhcyIsImdldFZhbHVlIiwibWFwVG9BcnJheSIsIm92ZXJBcmciLCJ0cmFuc2Zvcm0iLCJzZXRUb0FycmF5IiwiYXJyYXlQcm90byIsImZ1bmNQcm90byIsIm9iamVjdFByb3RvIiwiY29yZUpzRGF0YSIsImZ1bmNUb1N0cmluZyIsIm1hc2tTcmNLZXkiLCJJRV9QUk9UTyIsIm5hdGl2ZU9iamVjdFRvU3RyaW5nIiwicmVJc05hdGl2ZSIsIlVpbnQ4QXJyYXkiLCJwcm9wZXJ0eUlzRW51bWVyYWJsZSIsInN5bVRvU3RyaW5nVGFnIiwidG9TdHJpbmdUYWciLCJuYXRpdmVHZXRTeW1ib2xzIiwiZ2V0T3duUHJvcGVydHlTeW1ib2xzIiwibmF0aXZlSXNCdWZmZXIiLCJuYXRpdmVLZXlzIiwiRGF0YVZpZXciLCJnZXROYXRpdmUiLCJTZXQiLCJXZWFrTWFwIiwibmF0aXZlQ3JlYXRlIiwiZGF0YVZpZXdDdG9yU3RyaW5nIiwidG9Tb3VyY2UiLCJtYXBDdG9yU3RyaW5nIiwicHJvbWlzZUN0b3JTdHJpbmciLCJzZXRDdG9yU3RyaW5nIiwid2Vha01hcEN0b3JTdHJpbmciLCJzeW1ib2xQcm90byIsInN5bWJvbFZhbHVlT2YiLCJ2YWx1ZU9mIiwiSGFzaCIsImhhc2hDbGVhciIsIl9fZGF0YV9fIiwiaGFzaERlbGV0ZSIsImhhc2hHZXQiLCJoYXNoSGFzIiwiaGFzaFNldCIsIkxpc3RDYWNoZSIsImxpc3RDYWNoZUNsZWFyIiwibGlzdENhY2hlRGVsZXRlIiwiYXNzb2NJbmRleE9mIiwibGlzdENhY2hlR2V0IiwibGlzdENhY2hlSGFzIiwibGlzdENhY2hlU2V0IiwiTWFwQ2FjaGUiLCJtYXBDYWNoZUNsZWFyIiwibWFwQ2FjaGVEZWxldGUiLCJnZXRNYXBEYXRhIiwibWFwQ2FjaGVHZXQiLCJtYXBDYWNoZUhhcyIsIm1hcENhY2hlU2V0IiwiU2V0Q2FjaGUiLCJzZXRDYWNoZUFkZCIsInNldENhY2hlSGFzIiwiU3RhY2siLCJzdGFja0NsZWFyIiwic3RhY2tEZWxldGUiLCJzdGFja0dldCIsInN0YWNrSGFzIiwic3RhY2tTZXQiLCJwYWlycyIsImFycmF5TGlrZUtleXMiLCJpbmhlcml0ZWQiLCJpc0FyciIsImlzQXJnIiwiaXNBcmd1bWVudHMiLCJpc0J1ZmYiLCJpc1R5cGUiLCJza2lwSW5kZXhlcyIsImJhc2VHZXRBbGxLZXlzIiwia2V5c0Z1bmMiLCJzeW1ib2xzRnVuYyIsImJhc2VHZXRUYWciLCJnZXRSYXdUYWciLCJvYmplY3RUb1N0cmluZyIsImJhc2VJc0FyZ3VtZW50cyIsImlzT2JqZWN0TGlrZSIsImJhc2VJc0VxdWFsIiwiYml0bWFzayIsImN1c3RvbWl6ZXIiLCJiYXNlSXNFcXVhbERlZXAiLCJlcXVhbEZ1bmMiLCJvYmpJc0FyciIsIm90aElzQXJyIiwib2JqVGFnIiwiZ2V0VGFnIiwib3RoVGFnIiwib2JqSXNPYmoiLCJvdGhJc09iaiIsImlzU2FtZVRhZyIsImVxdWFsQXJyYXlzIiwiZXF1YWxCeVRhZyIsIm9iaklzV3JhcHBlZCIsIm90aElzV3JhcHBlZCIsIm9ialVud3JhcHBlZCIsIm90aFVud3JhcHBlZCIsImVxdWFsT2JqZWN0cyIsImJhc2VJc05hdGl2ZSIsImlzTWFza2VkIiwiYmFzZUlzVHlwZWRBcnJheSIsImlzTGVuZ3RoIiwiYmFzZUtleXMiLCJpc1Byb3RvdHlwZSIsImlzUGFydGlhbCIsImFyckxlbmd0aCIsIm90aExlbmd0aCIsInN0YWNrZWQiLCJzZWVuIiwiYXJyVmFsdWUiLCJvdGhWYWx1ZSIsImNvbXBhcmVkIiwib3RoSW5kZXgiLCJieXRlTGVuZ3RoIiwiYnl0ZU9mZnNldCIsImNvbnZlcnQiLCJvYmpQcm9wcyIsImdldEFsbEtleXMiLCJvYmpMZW5ndGgiLCJvdGhQcm9wcyIsInNraXBDdG9yIiwib2JqVmFsdWUiLCJvYmpDdG9yIiwib3RoQ3RvciIsImdldFN5bWJvbHMiLCJpc0tleWFibGUiLCJpc093biIsInVubWFza2VkIiwic3R1YkFycmF5IiwiQXJyYXlCdWZmZXIiLCJDdG9yIiwiY3RvclN0cmluZyIsImlzQXJyYXlMaWtlIiwic3R1YkZhbHNlIiwiaXNFcXVhbCIsIndlYnBhY2tQb2x5ZmlsbCIsImRlcHJlY2F0ZSIsInBhdGhzIiwiX2V4ZWN1dGVUYXNrcyIsImRpZmZlcmVudGlhbERvd25sb2FkZXIiLCJ0YXNrT2Zmc2V0IiwibmV4dE9mZnNldCIsInJhbmdlcyIsInBhcnRDb3VudCIsImRpY2VyIiwiYWNjZXB0UmFuZ2VzIiwicHVibGlzaGVyTmFtZXMiLCJleGVjRmlsZSIsImlzT2xkV2luNiIsImV4ZWNGaWxlU3luYyIsInRlc3RFcnJvciIsIlByaXZhdGVLZXkiLCJJc09TQmluYXJ5IiwiU2lnbmF0dXJlVHlwZSIsInNpZ25lckNlcnRpZmljYXRlIiwiU2lnbmVyQ2VydGlmaWNhdGUiLCJBcmNoaXZlZCIsIkV4dGVuc2lvbnMiLCJIYW5kbGUiLCJIYXNQcml2YXRlS2V5IiwiU3ViamVjdE5hbWUiLCJQYXRoIiwiU3RhdHVzIiwiU3ViamVjdCIsIndpblZlcnNpb24iLCJfaHR0cCIsIl9sb2FkX2h0dHAiLCJuYXRpdmVVcGRhdGVyIiwiYXV0b1VwZGF0ZXIiLCJ6aXBGaWxlSW5mbyIsInNlcnZlciIsImNyZWF0ZVNlcnZlciIsImdldFNlcnZlclVybCIsImFkZHJlc3MiLCJyZXF1ZXN0VXJsIiwid3JpdGVIZWFkIiwiZXJyb3JPY2N1cnJlZCIsImRvUHJveHlVcGRhdGVGaWxlIiwibGlzdGVuIiwibmF0aXZlUmVzcG9uc2UiLCJkb3dubG9hZFJlcXVlc3QiLCJkb3dubG9hZFJlc3BvbnNlIiwibmF0aXZlSGVhZGVycyIsImRvd25sb2FkTGlzdGVuZXJDb3VudCIsIkFQUElNQUdFIiwiaXNEb3dubG9hZEZ1bGwiLCJhcHBJbWFnZUZpbGUiLCJBUFBJTUFHRV9TSUxFTlRfSU5TVEFMTCIsIkFQUElNQUdFX0VYSVRfQUZURVJfSU5TVEFMTCIsImlwY1JlbmRlcmVyIiwidHJhbnNwb3J0Q29uc29sZSIsInRyYW5zcG9ydEZpbGUiLCJ0cmFuc3BvcnRMb2dTIiwidHJhbnNwb3J0UmVuZGVyZXJDb25zb2xlIiwidHJhbnNwb3J0cyIsImxvZ1MiLCJyZW5kZXJlckNvbnNvbGUiLCJpcGNNYWluIiwib25SZW5kZXJlckxvZyIsImFwcE5hbWUiLCJMRVZFTFMiLCJjb21wYXJlTGV2ZWxzIiwicGFzc0xldmVsIiwiY2hlY2tMZXZlbCIsInBhc3MiLCJjb25zb2xlVHJhbnNwb3J0IiwiZmluZExvZ1BhdGgiLCJtYXhTaXplIiwic3RyZWFtQ29uZmlnIiwiaW5pdFN0ZWFtQ29uZmlnIiwib3BlblN0cmVhbSIsIm5lZWRMb2dSb3RhdGlvbiIsImdldFN0cmVhbVNpemUiLCJhcmNoaXZlTG9nIiwibG9nQ29uc29sZSIsImxvZ1NpemVBdFN0YXJ0IiwiZ2V0QXBwTmFtZSIsImhvbWVEaXIiLCJob21lZGlyIiwicHJlcGFyZURpciIsImRpclBhdGgiLCJta0RpciIsIldfT0siLCJkaXJzIiwibG9hZFBhY2thZ2VOYW1lIiwicGFja2FnZUZpbGUiLCJlbGVjdHJvbk1vZHVsZSIsInBhY2thZ2VEYXRhIiwicHJvZHVjdE5hbWUiLCJodHRwIiwiaHR0cHMiLCJkZXB0aCIsImpzb25EZXB0aCIsInBvc3QiLCJzZXJ2ZXJVcmwiLCJ1cmxPYmplY3QiLCJuZXdKc29uIiwiQnJvd3NlcldpbmRvdyIsImdldEFsbFdpbmRvd3MiLCJ3bmQiLCJ3ZWJDb250ZW50cyJdLCJtYXBwaW5ncyI6IjtBQUFBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFLO0FBQ0w7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QWNDLGFBQWQsR0FBOEJ0N0gsT0FBOUIsQ0FBc0MsVUFBU3U3SCxHQUFULEVBQWM7QUFDbERBLFFBQUlDLFdBQUosQ0FBZ0JubEIsSUFBaEIsQ0FBcUIsMkJBQXJCLEVBQWtEaDJGLElBQUk1VixLQUF0RCxFQUE2RDZWLElBQTdEO0FBQ0QsR0FGRDtBQUdELEM7Ozs7OztBQ3ZCRCxrQkFBa0Isb09BQW9PLDRzQ0FBNHNDLFlBQVksa1BBQWtQLGlCQUFpQixrZkFBa2YsVUFBVSx3RUFBd0Usb0JBQW9CLFFBQVEsNENBQTRDLHVCIiwiZmlsZSI6Im1haW4uanMiLCJzb3VyY2VzQ29udGVudCI6WyIgXHQvLyBUaGUgbW9kdWxlIGNhY2hlXG4gXHR2YXIgaW5zdGFsbGVkTW9kdWxlcyA9IHt9O1xuXG4gXHQvLyBUaGUgcmVxdWlyZSBmdW5jdGlvblxuIFx0ZnVuY3Rpb24gX193ZWJwYWNrX3JlcXVpcmVfXyhtb2R1bGVJZCkge1xuXG4gXHRcdC8vIENoZWNrIGlmIG1vZHVsZSBpcyBpbiBjYWNoZVxuIFx0XHRpZihpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSkge1xuIFx0XHRcdHJldHVybiBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXS5leHBvcnRzO1xuIFx0XHR9XG4gXHRcdC8vIENyZWF0ZSBhIG5ldyBtb2R1bGUgKGFuZCBwdXQgaXQgaW50byB0aGUgY2FjaGUpXG4gXHRcdHZhciBtb2R1bGUgPSBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSA9IHtcbiBcdFx0XHRpOiBtb2R1bGVJZCxcbiBcdFx0XHRsOiBmYWxzZSxcbiBcdFx0XHRleHBvcnRzOiB7fVxuIFx0XHR9O1xuXG4gXHRcdC8vIEV4ZWN1dGUgdGhlIG1vZHVsZSBmdW5jdGlvblxuIFx0XHRtb2R1bGVzW21vZHVsZUlkXS5jYWxsKG1vZHVsZS5leHBvcnRzLCBtb2R1bGUsIG1vZHVsZS5leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKTtcblxuIFx0XHQvLyBGbGFnIHRoZSBtb2R1bGUgYXMgbG9hZGVkXG4gXHRcdG1vZHVsZS5sID0gdHJ1ZTtcblxuIFx0XHQvLyBSZXR1cm4gdGhlIGV4cG9ydHMgb2YgdGhlIG1vZHVsZVxuIFx0XHRyZXR1cm4gbW9kdWxlLmV4cG9ydHM7XG4gXHR9XG5cblxuIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGVzIG9iamVjdCAoX193ZWJwYWNrX21vZHVsZXNfXylcbiBcdF9fd2VicGFja19yZXF1aXJlX18ubSA9IG1vZHVsZXM7XG5cbiBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlIGNhY2hlXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmMgPSBpbnN0YWxsZWRNb2R1bGVzO1xuXG4gXHQvLyBkZWZpbmUgZ2V0dGVyIGZ1bmN0aW9uIGZvciBoYXJtb255IGV4cG9ydHNcbiBcdF9fd2VicGFja19yZXF1aXJlX18uZCA9IGZ1bmN0aW9uKGV4cG9ydHMsIG5hbWUsIGdldHRlcikge1xuIFx0XHRpZighX193ZWJwYWNrX3JlcXVpcmVfXy5vKGV4cG9ydHMsIG5hbWUpKSB7XG4gXHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIG5hbWUsIHtcbiBcdFx0XHRcdGNvbmZpZ3VyYWJsZTogZmFsc2UsXG4gXHRcdFx0XHRlbnVtZXJhYmxlOiB0cnVlLFxuIFx0XHRcdFx0Z2V0OiBnZXR0ZXJcbiBcdFx0XHR9KTtcbiBcdFx0fVxuIFx0fTtcblxuIFx0Ly8gZ2V0RGVmYXVsdEV4cG9ydCBmdW5jdGlvbiBmb3IgY29tcGF0aWJpbGl0eSB3aXRoIG5vbi1oYXJtb255IG1vZHVsZXNcbiBcdF9fd2VicGFja19yZXF1aXJlX18ubiA9IGZ1bmN0aW9uKG1vZHVsZSkge1xuIFx0XHR2YXIgZ2V0dGVyID0gbW9kdWxlICYmIG1vZHVsZS5fX2VzTW9kdWxlID9cbiBcdFx0XHRmdW5jdGlvbiBnZXREZWZhdWx0KCkgeyByZXR1cm4gbW9kdWxlWydkZWZhdWx0J107IH0gOlxuIFx0XHRcdGZ1bmN0aW9uIGdldE1vZHVsZUV4cG9ydHMoKSB7IHJldHVybiBtb2R1bGU7IH07XG4gXHRcdF9fd2VicGFja19yZXF1aXJlX18uZChnZXR0ZXIsICdhJywgZ2V0dGVyKTtcbiBcdFx0cmV0dXJuIGdldHRlcjtcbiBcdH07XG5cbiBcdC8vIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbFxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5vID0gZnVuY3Rpb24ob2JqZWN0LCBwcm9wZXJ0eSkgeyByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwgcHJvcGVydHkpOyB9O1xuXG4gXHQvLyBfX3dlYnBhY2tfcHVibGljX3BhdGhfX1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5wID0gXCJcIjtcblxuIFx0Ly8gTG9hZCBlbnRyeSBtb2R1bGUgYW5kIHJldHVybiBleHBvcnRzXG4gXHRyZXR1cm4gX193ZWJwYWNrX3JlcXVpcmVfXyhfX3dlYnBhY2tfcmVxdWlyZV9fLnMgPSA2OSk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gd2VicGFjay9ib290c3RyYXAgOWFkNDgwOGI3ZjUwNzU5ODg2ZmQiLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCJwYXRoXCIpO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIGV4dGVybmFsIFwicGF0aFwiXG4vLyBtb2R1bGUgaWQgPSAwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIlwidXNlIHN0cmljdFwiO1xudmFyIGVzNSA9IHJlcXVpcmUoXCIuL2VzNVwiKTtcbnZhciBjYW5FdmFsdWF0ZSA9IHR5cGVvZiBuYXZpZ2F0b3IgPT0gXCJ1bmRlZmluZWRcIjtcblxudmFyIGVycm9yT2JqID0ge2U6IHt9fTtcbnZhciB0cnlDYXRjaFRhcmdldDtcbnZhciBnbG9iYWxPYmplY3QgPSB0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiA/IHNlbGYgOlxuICAgIHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOlxuICAgIHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIgPyBnbG9iYWwgOlxuICAgIHRoaXMgIT09IHVuZGVmaW5lZCA/IHRoaXMgOiBudWxsO1xuXG5mdW5jdGlvbiB0cnlDYXRjaGVyKCkge1xuICAgIHRyeSB7XG4gICAgICAgIHZhciB0YXJnZXQgPSB0cnlDYXRjaFRhcmdldDtcbiAgICAgICAgdHJ5Q2F0Y2hUYXJnZXQgPSBudWxsO1xuICAgICAgICByZXR1cm4gdGFyZ2V0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBlcnJvck9iai5lID0gZTtcbiAgICAgICAgcmV0dXJuIGVycm9yT2JqO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHRyeUNhdGNoKGZuKSB7XG4gICAgdHJ5Q2F0Y2hUYXJnZXQgPSBmbjtcbiAgICByZXR1cm4gdHJ5Q2F0Y2hlcjtcbn1cblxudmFyIGluaGVyaXRzID0gZnVuY3Rpb24oQ2hpbGQsIFBhcmVudCkge1xuICAgIHZhciBoYXNQcm9wID0ge30uaGFzT3duUHJvcGVydHk7XG5cbiAgICBmdW5jdGlvbiBUKCkge1xuICAgICAgICB0aGlzLmNvbnN0cnVjdG9yID0gQ2hpbGQ7XG4gICAgICAgIHRoaXMuY29uc3RydWN0b3IkID0gUGFyZW50O1xuICAgICAgICBmb3IgKHZhciBwcm9wZXJ0eU5hbWUgaW4gUGFyZW50LnByb3RvdHlwZSkge1xuICAgICAgICAgICAgaWYgKGhhc1Byb3AuY2FsbChQYXJlbnQucHJvdG90eXBlLCBwcm9wZXJ0eU5hbWUpICYmXG4gICAgICAgICAgICAgICAgcHJvcGVydHlOYW1lLmNoYXJBdChwcm9wZXJ0eU5hbWUubGVuZ3RoLTEpICE9PSBcIiRcIlxuICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICB0aGlzW3Byb3BlcnR5TmFtZSArIFwiJFwiXSA9IFBhcmVudC5wcm90b3R5cGVbcHJvcGVydHlOYW1lXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBULnByb3RvdHlwZSA9IFBhcmVudC5wcm90b3R5cGU7XG4gICAgQ2hpbGQucHJvdG90eXBlID0gbmV3IFQoKTtcbiAgICByZXR1cm4gQ2hpbGQucHJvdG90eXBlO1xufTtcblxuXG5mdW5jdGlvbiBpc1ByaW1pdGl2ZSh2YWwpIHtcbiAgICByZXR1cm4gdmFsID09IG51bGwgfHwgdmFsID09PSB0cnVlIHx8IHZhbCA9PT0gZmFsc2UgfHxcbiAgICAgICAgdHlwZW9mIHZhbCA9PT0gXCJzdHJpbmdcIiB8fCB0eXBlb2YgdmFsID09PSBcIm51bWJlclwiO1xuXG59XG5cbmZ1bmN0aW9uIGlzT2JqZWN0KHZhbHVlKSB7XG4gICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gXCJmdW5jdGlvblwiIHx8XG4gICAgICAgICAgIHR5cGVvZiB2YWx1ZSA9PT0gXCJvYmplY3RcIiAmJiB2YWx1ZSAhPT0gbnVsbDtcbn1cblxuZnVuY3Rpb24gbWF5YmVXcmFwQXNFcnJvcihtYXliZUVycm9yKSB7XG4gICAgaWYgKCFpc1ByaW1pdGl2ZShtYXliZUVycm9yKSkgcmV0dXJuIG1heWJlRXJyb3I7XG5cbiAgICByZXR1cm4gbmV3IEVycm9yKHNhZmVUb1N0cmluZyhtYXliZUVycm9yKSk7XG59XG5cbmZ1bmN0aW9uIHdpdGhBcHBlbmRlZCh0YXJnZXQsIGFwcGVuZGVlKSB7XG4gICAgdmFyIGxlbiA9IHRhcmdldC5sZW5ndGg7XG4gICAgdmFyIHJldCA9IG5ldyBBcnJheShsZW4gKyAxKTtcbiAgICB2YXIgaTtcbiAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyArK2kpIHtcbiAgICAgICAgcmV0W2ldID0gdGFyZ2V0W2ldO1xuICAgIH1cbiAgICByZXRbaV0gPSBhcHBlbmRlZTtcbiAgICByZXR1cm4gcmV0O1xufVxuXG5mdW5jdGlvbiBnZXREYXRhUHJvcGVydHlPckRlZmF1bHQob2JqLCBrZXksIGRlZmF1bHRWYWx1ZSkge1xuICAgIGlmIChlczUuaXNFUzUpIHtcbiAgICAgICAgdmFyIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iaiwga2V5KTtcblxuICAgICAgICBpZiAoZGVzYyAhPSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gZGVzYy5nZXQgPT0gbnVsbCAmJiBkZXNjLnNldCA9PSBudWxsXG4gICAgICAgICAgICAgICAgICAgID8gZGVzYy52YWx1ZVxuICAgICAgICAgICAgICAgICAgICA6IGRlZmF1bHRWYWx1ZTtcbiAgICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB7fS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwga2V5KSA/IG9ialtrZXldIDogdW5kZWZpbmVkO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gbm90RW51bWVyYWJsZVByb3Aob2JqLCBuYW1lLCB2YWx1ZSkge1xuICAgIGlmIChpc1ByaW1pdGl2ZShvYmopKSByZXR1cm4gb2JqO1xuICAgIHZhciBkZXNjcmlwdG9yID0ge1xuICAgICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIHdyaXRhYmxlOiB0cnVlXG4gICAgfTtcbiAgICBlczUuZGVmaW5lUHJvcGVydHkob2JqLCBuYW1lLCBkZXNjcmlwdG9yKTtcbiAgICByZXR1cm4gb2JqO1xufVxuXG5mdW5jdGlvbiB0aHJvd2VyKHIpIHtcbiAgICB0aHJvdyByO1xufVxuXG52YXIgaW5oZXJpdGVkRGF0YUtleXMgPSAoZnVuY3Rpb24oKSB7XG4gICAgdmFyIGV4Y2x1ZGVkUHJvdG90eXBlcyA9IFtcbiAgICAgICAgQXJyYXkucHJvdG90eXBlLFxuICAgICAgICBPYmplY3QucHJvdG90eXBlLFxuICAgICAgICBGdW5jdGlvbi5wcm90b3R5cGVcbiAgICBdO1xuXG4gICAgdmFyIGlzRXhjbHVkZWRQcm90byA9IGZ1bmN0aW9uKHZhbCkge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGV4Y2x1ZGVkUHJvdG90eXBlcy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgaWYgKGV4Y2x1ZGVkUHJvdG90eXBlc1tpXSA9PT0gdmFsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH07XG5cbiAgICBpZiAoZXM1LmlzRVM1KSB7XG4gICAgICAgIHZhciBnZXRLZXlzID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXM7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbihvYmopIHtcbiAgICAgICAgICAgIHZhciByZXQgPSBbXTtcbiAgICAgICAgICAgIHZhciB2aXNpdGVkS2V5cyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICAgICAgICB3aGlsZSAob2JqICE9IG51bGwgJiYgIWlzRXhjbHVkZWRQcm90byhvYmopKSB7XG4gICAgICAgICAgICAgICAgdmFyIGtleXM7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAga2V5cyA9IGdldEtleXMob2JqKTtcbiAgICAgICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIga2V5ID0ga2V5c1tpXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHZpc2l0ZWRLZXlzW2tleV0pIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICB2aXNpdGVkS2V5c1trZXldID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iaiwga2V5KTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGRlc2MgIT0gbnVsbCAmJiBkZXNjLmdldCA9PSBudWxsICYmIGRlc2Muc2V0ID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldC5wdXNoKGtleSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgb2JqID0gZXM1LmdldFByb3RvdHlwZU9mKG9iaik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmV0O1xuICAgICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBoYXNQcm9wID0ge30uaGFzT3duUHJvcGVydHk7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbihvYmopIHtcbiAgICAgICAgICAgIGlmIChpc0V4Y2x1ZGVkUHJvdG8ob2JqKSkgcmV0dXJuIFtdO1xuICAgICAgICAgICAgdmFyIHJldCA9IFtdO1xuXG4gICAgICAgICAgICAvKmpzaGludCBmb3JpbjpmYWxzZSAqL1xuICAgICAgICAgICAgZW51bWVyYXRpb246IGZvciAodmFyIGtleSBpbiBvYmopIHtcbiAgICAgICAgICAgICAgICBpZiAoaGFzUHJvcC5jYWxsKG9iaiwga2V5KSkge1xuICAgICAgICAgICAgICAgICAgICByZXQucHVzaChrZXkpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZXhjbHVkZWRQcm90b3R5cGVzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaGFzUHJvcC5jYWxsKGV4Y2x1ZGVkUHJvdG90eXBlc1tpXSwga2V5KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlIGVudW1lcmF0aW9uO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldC5wdXNoKGtleSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJldDtcbiAgICAgICAgfTtcbiAgICB9XG5cbn0pKCk7XG5cbnZhciB0aGlzQXNzaWdubWVudFBhdHRlcm4gPSAvdGhpc1xccypcXC5cXHMqXFxTK1xccyo9LztcbmZ1bmN0aW9uIGlzQ2xhc3MoZm4pIHtcbiAgICB0cnkge1xuICAgICAgICBpZiAodHlwZW9mIGZuID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgIHZhciBrZXlzID0gZXM1Lm5hbWVzKGZuLnByb3RvdHlwZSk7XG5cbiAgICAgICAgICAgIHZhciBoYXNNZXRob2RzID0gZXM1LmlzRVM1ICYmIGtleXMubGVuZ3RoID4gMTtcbiAgICAgICAgICAgIHZhciBoYXNNZXRob2RzT3RoZXJUaGFuQ29uc3RydWN0b3IgPSBrZXlzLmxlbmd0aCA+IDAgJiZcbiAgICAgICAgICAgICAgICAhKGtleXMubGVuZ3RoID09PSAxICYmIGtleXNbMF0gPT09IFwiY29uc3RydWN0b3JcIik7XG4gICAgICAgICAgICB2YXIgaGFzVGhpc0Fzc2lnbm1lbnRBbmRTdGF0aWNNZXRob2RzID1cbiAgICAgICAgICAgICAgICB0aGlzQXNzaWdubWVudFBhdHRlcm4udGVzdChmbiArIFwiXCIpICYmIGVzNS5uYW1lcyhmbikubGVuZ3RoID4gMDtcblxuICAgICAgICAgICAgaWYgKGhhc01ldGhvZHMgfHwgaGFzTWV0aG9kc090aGVyVGhhbkNvbnN0cnVjdG9yIHx8XG4gICAgICAgICAgICAgICAgaGFzVGhpc0Fzc2lnbm1lbnRBbmRTdGF0aWNNZXRob2RzKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gdG9GYXN0UHJvcGVydGllcyhvYmopIHtcbiAgICAvKmpzaGludCAtVzAyNywtVzA1NSwtVzAzMSovXG4gICAgZnVuY3Rpb24gRmFrZUNvbnN0cnVjdG9yKCkge31cbiAgICBGYWtlQ29uc3RydWN0b3IucHJvdG90eXBlID0gb2JqO1xuICAgIHZhciBsID0gODtcbiAgICB3aGlsZSAobC0tKSBuZXcgRmFrZUNvbnN0cnVjdG9yKCk7XG4gICAgcmV0dXJuIG9iajtcbiAgICBldmFsKG9iaik7XG59XG5cbnZhciByaWRlbnQgPSAvXlthLXokX11bYS16JF8wLTldKiQvaTtcbmZ1bmN0aW9uIGlzSWRlbnRpZmllcihzdHIpIHtcbiAgICByZXR1cm4gcmlkZW50LnRlc3Qoc3RyKTtcbn1cblxuZnVuY3Rpb24gZmlsbGVkUmFuZ2UoY291bnQsIHByZWZpeCwgc3VmZml4KSB7XG4gICAgdmFyIHJldCA9IG5ldyBBcnJheShjb3VudCk7XG4gICAgZm9yKHZhciBpID0gMDsgaSA8IGNvdW50OyArK2kpIHtcbiAgICAgICAgcmV0W2ldID0gcHJlZml4ICsgaSArIHN1ZmZpeDtcbiAgICB9XG4gICAgcmV0dXJuIHJldDtcbn1cblxuZnVuY3Rpb24gc2FmZVRvU3RyaW5nKG9iaikge1xuICAgIHRyeSB7XG4gICAgICAgIHJldHVybiBvYmogKyBcIlwiO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgcmV0dXJuIFwiW25vIHN0cmluZyByZXByZXNlbnRhdGlvbl1cIjtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGlzRXJyb3Iob2JqKSB7XG4gICAgcmV0dXJuIG9iaiBpbnN0YW5jZW9mIEVycm9yIHx8XG4gICAgICAgIChvYmogIT09IG51bGwgJiZcbiAgICAgICAgICAgdHlwZW9mIG9iaiA9PT0gXCJvYmplY3RcIiAmJlxuICAgICAgICAgICB0eXBlb2Ygb2JqLm1lc3NhZ2UgPT09IFwic3RyaW5nXCIgJiZcbiAgICAgICAgICAgdHlwZW9mIG9iai5uYW1lID09PSBcInN0cmluZ1wiKTtcbn1cblxuZnVuY3Rpb24gbWFya0FzT3JpZ2luYXRpbmdGcm9tUmVqZWN0aW9uKGUpIHtcbiAgICB0cnkge1xuICAgICAgICBub3RFbnVtZXJhYmxlUHJvcChlLCBcImlzT3BlcmF0aW9uYWxcIiwgdHJ1ZSk7XG4gICAgfVxuICAgIGNhdGNoKGlnbm9yZSkge31cbn1cblxuZnVuY3Rpb24gb3JpZ2luYXRlc0Zyb21SZWplY3Rpb24oZSkge1xuICAgIGlmIChlID09IG51bGwpIHJldHVybiBmYWxzZTtcbiAgICByZXR1cm4gKChlIGluc3RhbmNlb2YgRXJyb3JbXCJfX0JsdWViaXJkRXJyb3JUeXBlc19fXCJdLk9wZXJhdGlvbmFsRXJyb3IpIHx8XG4gICAgICAgIGVbXCJpc09wZXJhdGlvbmFsXCJdID09PSB0cnVlKTtcbn1cblxuZnVuY3Rpb24gY2FuQXR0YWNoVHJhY2Uob2JqKSB7XG4gICAgcmV0dXJuIGlzRXJyb3Iob2JqKSAmJiBlczUucHJvcGVydHlJc1dyaXRhYmxlKG9iaiwgXCJzdGFja1wiKTtcbn1cblxudmFyIGVuc3VyZUVycm9yT2JqZWN0ID0gKGZ1bmN0aW9uKCkge1xuICAgIGlmICghKFwic3RhY2tcIiBpbiBuZXcgRXJyb3IoKSkpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgICAgICBpZiAoY2FuQXR0YWNoVHJhY2UodmFsdWUpKSByZXR1cm4gdmFsdWU7XG4gICAgICAgICAgICB0cnkge3Rocm93IG5ldyBFcnJvcihzYWZlVG9TdHJpbmcodmFsdWUpKTt9XG4gICAgICAgICAgICBjYXRjaChlcnIpIHtyZXR1cm4gZXJyO31cbiAgICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgICAgIGlmIChjYW5BdHRhY2hUcmFjZSh2YWx1ZSkpIHJldHVybiB2YWx1ZTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgRXJyb3Ioc2FmZVRvU3RyaW5nKHZhbHVlKSk7XG4gICAgICAgIH07XG4gICAgfVxufSkoKTtcblxuZnVuY3Rpb24gY2xhc3NTdHJpbmcob2JqKSB7XG4gICAgcmV0dXJuIHt9LnRvU3RyaW5nLmNhbGwob2JqKTtcbn1cblxuZnVuY3Rpb24gY29weURlc2NyaXB0b3JzKGZyb20sIHRvLCBmaWx0ZXIpIHtcbiAgICB2YXIga2V5cyA9IGVzNS5uYW1lcyhmcm9tKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgdmFyIGtleSA9IGtleXNbaV07XG4gICAgICAgIGlmIChmaWx0ZXIoa2V5KSkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBlczUuZGVmaW5lUHJvcGVydHkodG8sIGtleSwgZXM1LmdldERlc2NyaXB0b3IoZnJvbSwga2V5KSk7XG4gICAgICAgICAgICB9IGNhdGNoIChpZ25vcmUpIHt9XG4gICAgICAgIH1cbiAgICB9XG59XG5cbnZhciBhc0FycmF5ID0gZnVuY3Rpb24odikge1xuICAgIGlmIChlczUuaXNBcnJheSh2KSkge1xuICAgICAgICByZXR1cm4gdjtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG59O1xuXG5pZiAodHlwZW9mIFN5bWJvbCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBTeW1ib2wuaXRlcmF0b3IpIHtcbiAgICB2YXIgQXJyYXlGcm9tID0gdHlwZW9mIEFycmF5LmZyb20gPT09IFwiZnVuY3Rpb25cIiA/IGZ1bmN0aW9uKHYpIHtcbiAgICAgICAgcmV0dXJuIEFycmF5LmZyb20odik7XG4gICAgfSA6IGZ1bmN0aW9uKHYpIHtcbiAgICAgICAgdmFyIHJldCA9IFtdO1xuICAgICAgICB2YXIgaXQgPSB2W1N5bWJvbC5pdGVyYXRvcl0oKTtcbiAgICAgICAgdmFyIGl0UmVzdWx0O1xuICAgICAgICB3aGlsZSAoISgoaXRSZXN1bHQgPSBpdC5uZXh0KCkpLmRvbmUpKSB7XG4gICAgICAgICAgICByZXQucHVzaChpdFJlc3VsdC52YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICB9O1xuXG4gICAgYXNBcnJheSA9IGZ1bmN0aW9uKHYpIHtcbiAgICAgICAgaWYgKGVzNS5pc0FycmF5KHYpKSB7XG4gICAgICAgICAgICByZXR1cm4gdjtcbiAgICAgICAgfSBlbHNlIGlmICh2ICE9IG51bGwgJiYgdHlwZW9mIHZbU3ltYm9sLml0ZXJhdG9yXSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICByZXR1cm4gQXJyYXlGcm9tKHYpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH07XG59XG5cbnZhciBpc05vZGUgPSB0eXBlb2YgcHJvY2VzcyAhPT0gXCJ1bmRlZmluZWRcIiAmJlxuICAgICAgICBjbGFzc1N0cmluZyhwcm9jZXNzKS50b0xvd2VyQ2FzZSgpID09PSBcIltvYmplY3QgcHJvY2Vzc11cIjtcblxudmFyIGhhc0VudlZhcmlhYmxlcyA9IHR5cGVvZiBwcm9jZXNzICE9PSBcInVuZGVmaW5lZFwiICYmXG4gICAgdHlwZW9mIHByb2Nlc3MuZW52ICE9PSBcInVuZGVmaW5lZFwiO1xuXG5mdW5jdGlvbiBlbnYoa2V5KSB7XG4gICAgcmV0dXJuIGhhc0VudlZhcmlhYmxlcyA/IHByb2Nlc3MuZW52W2tleV0gOiB1bmRlZmluZWQ7XG59XG5cbmZ1bmN0aW9uIGdldE5hdGl2ZVByb21pc2UoKSB7XG4gICAgaWYgKHR5cGVvZiBQcm9taXNlID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHZhciBwcm9taXNlID0gbmV3IFByb21pc2UoZnVuY3Rpb24oKXt9KTtcbiAgICAgICAgICAgIGlmICh7fS50b1N0cmluZy5jYWxsKHByb21pc2UpID09PSBcIltvYmplY3QgUHJvbWlzZV1cIikge1xuICAgICAgICAgICAgICAgIHJldHVybiBQcm9taXNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGNhdGNoIChlKSB7fVxuICAgIH1cbn1cblxuZnVuY3Rpb24gZG9tYWluQmluZChzZWxmLCBjYikge1xuICAgIHJldHVybiBzZWxmLmJpbmQoY2IpO1xufVxuXG52YXIgcmV0ID0ge1xuICAgIGlzQ2xhc3M6IGlzQ2xhc3MsXG4gICAgaXNJZGVudGlmaWVyOiBpc0lkZW50aWZpZXIsXG4gICAgaW5oZXJpdGVkRGF0YUtleXM6IGluaGVyaXRlZERhdGFLZXlzLFxuICAgIGdldERhdGFQcm9wZXJ0eU9yRGVmYXVsdDogZ2V0RGF0YVByb3BlcnR5T3JEZWZhdWx0LFxuICAgIHRocm93ZXI6IHRocm93ZXIsXG4gICAgaXNBcnJheTogZXM1LmlzQXJyYXksXG4gICAgYXNBcnJheTogYXNBcnJheSxcbiAgICBub3RFbnVtZXJhYmxlUHJvcDogbm90RW51bWVyYWJsZVByb3AsXG4gICAgaXNQcmltaXRpdmU6IGlzUHJpbWl0aXZlLFxuICAgIGlzT2JqZWN0OiBpc09iamVjdCxcbiAgICBpc0Vycm9yOiBpc0Vycm9yLFxuICAgIGNhbkV2YWx1YXRlOiBjYW5FdmFsdWF0ZSxcbiAgICBlcnJvck9iajogZXJyb3JPYmosXG4gICAgdHJ5Q2F0Y2g6IHRyeUNhdGNoLFxuICAgIGluaGVyaXRzOiBpbmhlcml0cyxcbiAgICB3aXRoQXBwZW5kZWQ6IHdpdGhBcHBlbmRlZCxcbiAgICBtYXliZVdyYXBBc0Vycm9yOiBtYXliZVdyYXBBc0Vycm9yLFxuICAgIHRvRmFzdFByb3BlcnRpZXM6IHRvRmFzdFByb3BlcnRpZXMsXG4gICAgZmlsbGVkUmFuZ2U6IGZpbGxlZFJhbmdlLFxuICAgIHRvU3RyaW5nOiBzYWZlVG9TdHJpbmcsXG4gICAgY2FuQXR0YWNoVHJhY2U6IGNhbkF0dGFjaFRyYWNlLFxuICAgIGVuc3VyZUVycm9yT2JqZWN0OiBlbnN1cmVFcnJvck9iamVjdCxcbiAgICBvcmlnaW5hdGVzRnJvbVJlamVjdGlvbjogb3JpZ2luYXRlc0Zyb21SZWplY3Rpb24sXG4gICAgbWFya0FzT3JpZ2luYXRpbmdGcm9tUmVqZWN0aW9uOiBtYXJrQXNPcmlnaW5hdGluZ0Zyb21SZWplY3Rpb24sXG4gICAgY2xhc3NTdHJpbmc6IGNsYXNzU3RyaW5nLFxuICAgIGNvcHlEZXNjcmlwdG9yczogY29weURlc2NyaXB0b3JzLFxuICAgIGhhc0RldlRvb2xzOiB0eXBlb2YgY2hyb21lICE9PSBcInVuZGVmaW5lZFwiICYmIGNocm9tZSAmJlxuICAgICAgICAgICAgICAgICB0eXBlb2YgY2hyb21lLmxvYWRUaW1lcyA9PT0gXCJmdW5jdGlvblwiLFxuICAgIGlzTm9kZTogaXNOb2RlLFxuICAgIGhhc0VudlZhcmlhYmxlczogaGFzRW52VmFyaWFibGVzLFxuICAgIGVudjogZW52LFxuICAgIGdsb2JhbDogZ2xvYmFsT2JqZWN0LFxuICAgIGdldE5hdGl2ZVByb21pc2U6IGdldE5hdGl2ZVByb21pc2UsXG4gICAgZG9tYWluQmluZDogZG9tYWluQmluZFxufTtcbnJldC5pc1JlY2VudE5vZGUgPSByZXQuaXNOb2RlICYmIChmdW5jdGlvbigpIHtcbiAgICB2YXIgdmVyc2lvbiA9IHByb2Nlc3MudmVyc2lvbnMubm9kZS5zcGxpdChcIi5cIikubWFwKE51bWJlcik7XG4gICAgcmV0dXJuICh2ZXJzaW9uWzBdID09PSAwICYmIHZlcnNpb25bMV0gPiAxMCkgfHwgKHZlcnNpb25bMF0gPiAwKTtcbn0pKCk7XG5cbmlmIChyZXQuaXNOb2RlKSByZXQudG9GYXN0UHJvcGVydGllcyhwcm9jZXNzKTtcblxudHJ5IHt0aHJvdyBuZXcgRXJyb3IoKTsgfSBjYXRjaCAoZSkge3JldC5sYXN0TGluZUVycm9yID0gZTt9XG5tb2R1bGUuZXhwb3J0cyA9IHJldDtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9ibHVlYmlyZC9qcy9yZWxlYXNlL3V0aWwuanMiLCJjb25zdCBCbHVlYmlyZFByb21pc2UgPSByZXF1aXJlKFwiYmx1ZWJpcmQvanMvcmVsZWFzZS9wcm9taXNlXCIpKClcbkJsdWViaXJkUHJvbWlzZS5jb25maWcoe1xuICBsb25nU3RhY2tUcmFjZXM6IHRydWUsXG59KVxuQmx1ZWJpcmRQcm9taXNlLmRlZmF1bHQgPSBCbHVlYmlyZFByb21pc2Vcbm1vZHVsZS5leHBvcnRzID0gQmx1ZWJpcmRQcm9taXNlXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2JsdWViaXJkLWxzdC9pbmRleC5qcyIsIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICB2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBfQ2FuY2VsbGF0aW9uVG9rZW47XG5cbmZ1bmN0aW9uIF9sb2FkX0NhbmNlbGxhdGlvblRva2VuKCkge1xuICAgIHJldHVybiBfQ2FuY2VsbGF0aW9uVG9rZW4gPSByZXF1aXJlKFwiLi9DYW5jZWxsYXRpb25Ub2tlblwiKTtcbn1cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiQ2FuY2VsbGF0aW9uVG9rZW5cIiwge1xuICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiAoX0NhbmNlbGxhdGlvblRva2VuIHx8IF9sb2FkX0NhbmNlbGxhdGlvblRva2VuKCkpLkNhbmNlbGxhdGlvblRva2VuO1xuICAgIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiQ2FuY2VsbGF0aW9uRXJyb3JcIiwge1xuICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiAoX0NhbmNlbGxhdGlvblRva2VuIHx8IF9sb2FkX0NhbmNlbGxhdGlvblRva2VuKCkpLkNhbmNlbGxhdGlvbkVycm9yO1xuICAgIH1cbn0pO1xuXG52YXIgX2h0dHBFeGVjdXRvcjtcblxuZnVuY3Rpb24gX2xvYWRfaHR0cEV4ZWN1dG9yKCkge1xuICAgIHJldHVybiBfaHR0cEV4ZWN1dG9yID0gcmVxdWlyZShcIi4vaHR0cEV4ZWN1dG9yXCIpO1xufVxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJIdHRwRXJyb3JcIiwge1xuICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiAoX2h0dHBFeGVjdXRvciB8fCBfbG9hZF9odHRwRXhlY3V0b3IoKSkuSHR0cEVycm9yO1xuICAgIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiY3JlYXRlSHR0cEVycm9yXCIsIHtcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gKF9odHRwRXhlY3V0b3IgfHwgX2xvYWRfaHR0cEV4ZWN1dG9yKCkpLmNyZWF0ZUh0dHBFcnJvcjtcbiAgICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkh0dHBFeGVjdXRvclwiLCB7XG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIChfaHR0cEV4ZWN1dG9yIHx8IF9sb2FkX2h0dHBFeGVjdXRvcigpKS5IdHRwRXhlY3V0b3I7XG4gICAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJEaWdlc3RUcmFuc2Zvcm1cIiwge1xuICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiAoX2h0dHBFeGVjdXRvciB8fCBfbG9hZF9odHRwRXhlY3V0b3IoKSkuRGlnZXN0VHJhbnNmb3JtO1xuICAgIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwic2FmZUdldEhlYWRlclwiLCB7XG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIChfaHR0cEV4ZWN1dG9yIHx8IF9sb2FkX2h0dHBFeGVjdXRvcigpKS5zYWZlR2V0SGVhZGVyO1xuICAgIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiY29uZmlndXJlUmVxdWVzdE9wdGlvbnNcIiwge1xuICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiAoX2h0dHBFeGVjdXRvciB8fCBfbG9hZF9odHRwRXhlY3V0b3IoKSkuY29uZmlndXJlUmVxdWVzdE9wdGlvbnM7XG4gICAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJjb25maWd1cmVSZXF1ZXN0T3B0aW9uc0Zyb21VcmxcIiwge1xuICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiAoX2h0dHBFeGVjdXRvciB8fCBfbG9hZF9odHRwRXhlY3V0b3IoKSkuY29uZmlndXJlUmVxdWVzdE9wdGlvbnNGcm9tVXJsO1xuICAgIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwic2FmZVN0cmluZ2lmeUpzb25cIiwge1xuICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiAoX2h0dHBFeGVjdXRvciB8fCBfbG9hZF9odHRwRXhlY3V0b3IoKSkuc2FmZVN0cmluZ2lmeUpzb247XG4gICAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJwYXJzZUpzb25cIiwge1xuICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiAoX2h0dHBFeGVjdXRvciB8fCBfbG9hZF9odHRwRXhlY3V0b3IoKSkucGFyc2VKc29uO1xuICAgIH1cbn0pO1xuXG52YXIgX3B1Ymxpc2hPcHRpb25zO1xuXG5mdW5jdGlvbiBfbG9hZF9wdWJsaXNoT3B0aW9ucygpIHtcbiAgICByZXR1cm4gX3B1Ymxpc2hPcHRpb25zID0gcmVxdWlyZShcIi4vcHVibGlzaE9wdGlvbnNcIik7XG59XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImdldFMzTGlrZVByb3ZpZGVyQmFzZVVybFwiLCB7XG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIChfcHVibGlzaE9wdGlvbnMgfHwgX2xvYWRfcHVibGlzaE9wdGlvbnMoKSkuZ2V0UzNMaWtlUHJvdmlkZXJCYXNlVXJsO1xuICAgIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiZ2l0aHViVXJsXCIsIHtcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gKF9wdWJsaXNoT3B0aW9ucyB8fCBfbG9hZF9wdWJsaXNoT3B0aW9ucygpKS5naXRodWJVcmw7XG4gICAgfVxufSk7XG5cbnZhciBfcmZjMjI1M1BhcnNlcjtcblxuZnVuY3Rpb24gX2xvYWRfcmZjMjI1M1BhcnNlcigpIHtcbiAgICByZXR1cm4gX3JmYzIyNTNQYXJzZXIgPSByZXF1aXJlKFwiLi9yZmMyMjUzUGFyc2VyXCIpO1xufVxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJwYXJzZURuXCIsIHtcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gKF9yZmMyMjUzUGFyc2VyIHx8IF9sb2FkX3JmYzIyNTNQYXJzZXIoKSkucGFyc2VEbjtcbiAgICB9XG59KTtcblxudmFyIF91dWlkO1xuXG5mdW5jdGlvbiBfbG9hZF91dWlkKCkge1xuICAgIHJldHVybiBfdXVpZCA9IHJlcXVpcmUoXCIuL3V1aWRcIik7XG59XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlVVSURcIiwge1xuICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiAoX3V1aWQgfHwgX2xvYWRfdXVpZCgpKS5VVUlEO1xuICAgIH1cbn0pO1xuXG52YXIgX1Byb2dyZXNzQ2FsbGJhY2tUcmFuc2Zvcm07XG5cbmZ1bmN0aW9uIF9sb2FkX1Byb2dyZXNzQ2FsbGJhY2tUcmFuc2Zvcm0oKSB7XG4gICAgcmV0dXJuIF9Qcm9ncmVzc0NhbGxiYWNrVHJhbnNmb3JtID0gcmVxdWlyZShcIi4vUHJvZ3Jlc3NDYWxsYmFja1RyYW5zZm9ybVwiKTtcbn1cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiUHJvZ3Jlc3NDYWxsYmFja1RyYW5zZm9ybVwiLCB7XG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIChfUHJvZ3Jlc3NDYWxsYmFja1RyYW5zZm9ybSB8fCBfbG9hZF9Qcm9ncmVzc0NhbGxiYWNrVHJhbnNmb3JtKCkpLlByb2dyZXNzQ2FsbGJhY2tUcmFuc2Zvcm07XG4gICAgfVxufSk7XG5cbnZhciBfeG1sO1xuXG5mdW5jdGlvbiBfbG9hZF94bWwoKSB7XG4gICAgcmV0dXJuIF94bWwgPSByZXF1aXJlKFwiLi94bWxcIik7XG59XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcInBhcnNlWG1sXCIsIHtcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gKF94bWwgfHwgX2xvYWRfeG1sKCkpLnBhcnNlWG1sO1xuICAgIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiWEVsZW1lbnRcIiwge1xuICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiAoX3htbCB8fCBfbG9hZF94bWwoKSkuWEVsZW1lbnQ7XG4gICAgfVxufSk7XG5leHBvcnRzLmFzQXJyYXkgPSBhc0FycmF5O1xuZXhwb3J0cy5uZXdFcnJvciA9IG5ld0Vycm9yO1xuZnVuY3Rpb24gYXNBcnJheSh2KSB7XG4gICAgaWYgKHYgPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gW107XG4gICAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KHYpKSB7XG4gICAgICAgIHJldHVybiB2O1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBbdl07XG4gICAgfVxufVxuZnVuY3Rpb24gbmV3RXJyb3IobWVzc2FnZSwgY29kZSkge1xuICAgIGNvbnN0IGVycm9yID0gbmV3IEVycm9yKG1lc3NhZ2UpO1xuICAgIGVycm9yLmNvZGUgPSBjb2RlO1xuICAgIHJldHVybiBlcnJvcjtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcFxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9lbGVjdHJvbi11cGRhdGVyL25vZGVfbW9kdWxlcy9idWlsZGVyLXV0aWwtcnVudGltZS9vdXQvaW5kZXguanMiLCIndXNlIHN0cmljdCc7XG5cbnZhciBZQU1MRXhjZXB0aW9uID0gcmVxdWlyZSgnLi9leGNlcHRpb24nKTtcblxudmFyIFRZUEVfQ09OU1RSVUNUT1JfT1BUSU9OUyA9IFtcbiAgJ2tpbmQnLFxuICAncmVzb2x2ZScsXG4gICdjb25zdHJ1Y3QnLFxuICAnaW5zdGFuY2VPZicsXG4gICdwcmVkaWNhdGUnLFxuICAncmVwcmVzZW50JyxcbiAgJ2RlZmF1bHRTdHlsZScsXG4gICdzdHlsZUFsaWFzZXMnXG5dO1xuXG52YXIgWUFNTF9OT0RFX0tJTkRTID0gW1xuICAnc2NhbGFyJyxcbiAgJ3NlcXVlbmNlJyxcbiAgJ21hcHBpbmcnXG5dO1xuXG5mdW5jdGlvbiBjb21waWxlU3R5bGVBbGlhc2VzKG1hcCkge1xuICB2YXIgcmVzdWx0ID0ge307XG5cbiAgaWYgKG1hcCAhPT0gbnVsbCkge1xuICAgIE9iamVjdC5rZXlzKG1hcCkuZm9yRWFjaChmdW5jdGlvbiAoc3R5bGUpIHtcbiAgICAgIG1hcFtzdHlsZV0uZm9yRWFjaChmdW5jdGlvbiAoYWxpYXMpIHtcbiAgICAgICAgcmVzdWx0W1N0cmluZyhhbGlhcyldID0gc3R5bGU7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuXG4gIHJldHVybiByZXN1bHQ7XG59XG5cbmZ1bmN0aW9uIFR5cGUodGFnLCBvcHRpb25zKSB7XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gIE9iamVjdC5rZXlzKG9wdGlvbnMpLmZvckVhY2goZnVuY3Rpb24gKG5hbWUpIHtcbiAgICBpZiAoVFlQRV9DT05TVFJVQ1RPUl9PUFRJT05TLmluZGV4T2YobmFtZSkgPT09IC0xKSB7XG4gICAgICB0aHJvdyBuZXcgWUFNTEV4Y2VwdGlvbignVW5rbm93biBvcHRpb24gXCInICsgbmFtZSArICdcIiBpcyBtZXQgaW4gZGVmaW5pdGlvbiBvZiBcIicgKyB0YWcgKyAnXCIgWUFNTCB0eXBlLicpO1xuICAgIH1cbiAgfSk7XG5cbiAgLy8gVE9ETzogQWRkIHRhZyBmb3JtYXQgY2hlY2suXG4gIHRoaXMudGFnICAgICAgICAgID0gdGFnO1xuICB0aGlzLmtpbmQgICAgICAgICA9IG9wdGlvbnNbJ2tpbmQnXSAgICAgICAgIHx8IG51bGw7XG4gIHRoaXMucmVzb2x2ZSAgICAgID0gb3B0aW9uc1sncmVzb2x2ZSddICAgICAgfHwgZnVuY3Rpb24gKCkgeyByZXR1cm4gdHJ1ZTsgfTtcbiAgdGhpcy5jb25zdHJ1Y3QgICAgPSBvcHRpb25zWydjb25zdHJ1Y3QnXSAgICB8fCBmdW5jdGlvbiAoZGF0YSkgeyByZXR1cm4gZGF0YTsgfTtcbiAgdGhpcy5pbnN0YW5jZU9mICAgPSBvcHRpb25zWydpbnN0YW5jZU9mJ10gICB8fCBudWxsO1xuICB0aGlzLnByZWRpY2F0ZSAgICA9IG9wdGlvbnNbJ3ByZWRpY2F0ZSddICAgIHx8IG51bGw7XG4gIHRoaXMucmVwcmVzZW50ICAgID0gb3B0aW9uc1sncmVwcmVzZW50J10gICAgfHwgbnVsbDtcbiAgdGhpcy5kZWZhdWx0U3R5bGUgPSBvcHRpb25zWydkZWZhdWx0U3R5bGUnXSB8fCBudWxsO1xuICB0aGlzLnN0eWxlQWxpYXNlcyA9IGNvbXBpbGVTdHlsZUFsaWFzZXMob3B0aW9uc1snc3R5bGVBbGlhc2VzJ10gfHwgbnVsbCk7XG5cbiAgaWYgKFlBTUxfTk9ERV9LSU5EUy5pbmRleE9mKHRoaXMua2luZCkgPT09IC0xKSB7XG4gICAgdGhyb3cgbmV3IFlBTUxFeGNlcHRpb24oJ1Vua25vd24ga2luZCBcIicgKyB0aGlzLmtpbmQgKyAnXCIgaXMgc3BlY2lmaWVkIGZvciBcIicgKyB0YWcgKyAnXCIgWUFNTCB0eXBlLicpO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gVHlwZTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9qcy15YW1sL2xpYi9qcy15YW1sL3R5cGUuanMiLCJ2YXIgZnMgPSByZXF1aXJlKCdmcycpXG52YXIgcG9seWZpbGxzID0gcmVxdWlyZSgnLi9wb2x5ZmlsbHMuanMnKVxudmFyIGxlZ2FjeSA9IHJlcXVpcmUoJy4vbGVnYWN5LXN0cmVhbXMuanMnKVxudmFyIHF1ZXVlID0gW11cblxudmFyIHV0aWwgPSByZXF1aXJlKCd1dGlsJylcblxuZnVuY3Rpb24gbm9vcCAoKSB7fVxuXG52YXIgZGVidWcgPSBub29wXG5pZiAodXRpbC5kZWJ1Z2xvZylcbiAgZGVidWcgPSB1dGlsLmRlYnVnbG9nKCdnZnM0JylcbmVsc2UgaWYgKC9cXGJnZnM0XFxiL2kudGVzdChwcm9jZXNzLmVudi5OT0RFX0RFQlVHIHx8ICcnKSlcbiAgZGVidWcgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgbSA9IHV0aWwuZm9ybWF0LmFwcGx5KHV0aWwsIGFyZ3VtZW50cylcbiAgICBtID0gJ0dGUzQ6ICcgKyBtLnNwbGl0KC9cXG4vKS5qb2luKCdcXG5HRlM0OiAnKVxuICAgIGNvbnNvbGUuZXJyb3IobSlcbiAgfVxuXG5pZiAoL1xcYmdmczRcXGIvaS50ZXN0KHByb2Nlc3MuZW52Lk5PREVfREVCVUcgfHwgJycpKSB7XG4gIHByb2Nlc3Mub24oJ2V4aXQnLCBmdW5jdGlvbigpIHtcbiAgICBkZWJ1ZyhxdWV1ZSlcbiAgICByZXF1aXJlKCdhc3NlcnQnKS5lcXVhbChxdWV1ZS5sZW5ndGgsIDApXG4gIH0pXG59XG5cbm1vZHVsZS5leHBvcnRzID0gcGF0Y2gocmVxdWlyZSgnLi9mcy5qcycpKVxuaWYgKHByb2Nlc3MuZW52LlRFU1RfR1JBQ0VGVUxfRlNfR0xPQkFMX1BBVENIKSB7XG4gIG1vZHVsZS5leHBvcnRzID0gcGF0Y2goZnMpXG59XG5cbi8vIEFsd2F5cyBwYXRjaCBmcy5jbG9zZS9jbG9zZVN5bmMsIGJlY2F1c2Ugd2Ugd2FudCB0b1xuLy8gcmV0cnkoKSB3aGVuZXZlciBhIGNsb3NlIGhhcHBlbnMgKmFueXdoZXJlKiBpbiB0aGUgcHJvZ3JhbS5cbi8vIFRoaXMgaXMgZXNzZW50aWFsIHdoZW4gbXVsdGlwbGUgZ3JhY2VmdWwtZnMgaW5zdGFuY2VzIGFyZVxuLy8gaW4gcGxheSBhdCB0aGUgc2FtZSB0aW1lLlxubW9kdWxlLmV4cG9ydHMuY2xvc2UgPVxuZnMuY2xvc2UgPSAoZnVuY3Rpb24gKGZzJGNsb3NlKSB7IHJldHVybiBmdW5jdGlvbiAoZmQsIGNiKSB7XG4gIHJldHVybiBmcyRjbG9zZS5jYWxsKGZzLCBmZCwgZnVuY3Rpb24gKGVycikge1xuICAgIGlmICghZXJyKVxuICAgICAgcmV0cnkoKVxuXG4gICAgaWYgKHR5cGVvZiBjYiA9PT0gJ2Z1bmN0aW9uJylcbiAgICAgIGNiLmFwcGx5KHRoaXMsIGFyZ3VtZW50cylcbiAgfSlcbn19KShmcy5jbG9zZSlcblxubW9kdWxlLmV4cG9ydHMuY2xvc2VTeW5jID1cbmZzLmNsb3NlU3luYyA9IChmdW5jdGlvbiAoZnMkY2xvc2VTeW5jKSB7IHJldHVybiBmdW5jdGlvbiAoZmQpIHtcbiAgLy8gTm90ZSB0aGF0IGdyYWNlZnVsLWZzIGFsc28gcmV0cmllcyB3aGVuIGZzLmNsb3NlU3luYygpIGZhaWxzLlxuICAvLyBMb29rcyBsaWtlIGEgYnVnIHRvIG1lLCBhbHRob3VnaCBpdCdzIHByb2JhYmx5IGEgaGFybWxlc3Mgb25lLlxuICB2YXIgcnZhbCA9IGZzJGNsb3NlU3luYy5hcHBseShmcywgYXJndW1lbnRzKVxuICByZXRyeSgpXG4gIHJldHVybiBydmFsXG59fSkoZnMuY2xvc2VTeW5jKVxuXG5mdW5jdGlvbiBwYXRjaCAoZnMpIHtcbiAgLy8gRXZlcnl0aGluZyB0aGF0IHJlZmVyZW5jZXMgdGhlIG9wZW4oKSBmdW5jdGlvbiBuZWVkcyB0byBiZSBpbiBoZXJlXG4gIHBvbHlmaWxscyhmcylcbiAgZnMuZ3JhY2VmdWxpZnkgPSBwYXRjaFxuICBmcy5GaWxlUmVhZFN0cmVhbSA9IFJlYWRTdHJlYW07ICAvLyBMZWdhY3kgbmFtZS5cbiAgZnMuRmlsZVdyaXRlU3RyZWFtID0gV3JpdGVTdHJlYW07ICAvLyBMZWdhY3kgbmFtZS5cbiAgZnMuY3JlYXRlUmVhZFN0cmVhbSA9IGNyZWF0ZVJlYWRTdHJlYW1cbiAgZnMuY3JlYXRlV3JpdGVTdHJlYW0gPSBjcmVhdGVXcml0ZVN0cmVhbVxuICB2YXIgZnMkcmVhZEZpbGUgPSBmcy5yZWFkRmlsZVxuICBmcy5yZWFkRmlsZSA9IHJlYWRGaWxlXG4gIGZ1bmN0aW9uIHJlYWRGaWxlIChwYXRoLCBvcHRpb25zLCBjYikge1xuICAgIGlmICh0eXBlb2Ygb3B0aW9ucyA9PT0gJ2Z1bmN0aW9uJylcbiAgICAgIGNiID0gb3B0aW9ucywgb3B0aW9ucyA9IG51bGxcblxuICAgIHJldHVybiBnbyRyZWFkRmlsZShwYXRoLCBvcHRpb25zLCBjYilcblxuICAgIGZ1bmN0aW9uIGdvJHJlYWRGaWxlIChwYXRoLCBvcHRpb25zLCBjYikge1xuICAgICAgcmV0dXJuIGZzJHJlYWRGaWxlKHBhdGgsIG9wdGlvbnMsIGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgaWYgKGVyciAmJiAoZXJyLmNvZGUgPT09ICdFTUZJTEUnIHx8IGVyci5jb2RlID09PSAnRU5GSUxFJykpXG4gICAgICAgICAgZW5xdWV1ZShbZ28kcmVhZEZpbGUsIFtwYXRoLCBvcHRpb25zLCBjYl1dKVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICBpZiAodHlwZW9mIGNiID09PSAnZnVuY3Rpb24nKVxuICAgICAgICAgICAgY2IuYXBwbHkodGhpcywgYXJndW1lbnRzKVxuICAgICAgICAgIHJldHJ5KClcbiAgICAgICAgfVxuICAgICAgfSlcbiAgICB9XG4gIH1cblxuICB2YXIgZnMkd3JpdGVGaWxlID0gZnMud3JpdGVGaWxlXG4gIGZzLndyaXRlRmlsZSA9IHdyaXRlRmlsZVxuICBmdW5jdGlvbiB3cml0ZUZpbGUgKHBhdGgsIGRhdGEsIG9wdGlvbnMsIGNiKSB7XG4gICAgaWYgKHR5cGVvZiBvcHRpb25zID09PSAnZnVuY3Rpb24nKVxuICAgICAgY2IgPSBvcHRpb25zLCBvcHRpb25zID0gbnVsbFxuXG4gICAgcmV0dXJuIGdvJHdyaXRlRmlsZShwYXRoLCBkYXRhLCBvcHRpb25zLCBjYilcblxuICAgIGZ1bmN0aW9uIGdvJHdyaXRlRmlsZSAocGF0aCwgZGF0YSwgb3B0aW9ucywgY2IpIHtcbiAgICAgIHJldHVybiBmcyR3cml0ZUZpbGUocGF0aCwgZGF0YSwgb3B0aW9ucywgZnVuY3Rpb24gKGVycikge1xuICAgICAgICBpZiAoZXJyICYmIChlcnIuY29kZSA9PT0gJ0VNRklMRScgfHwgZXJyLmNvZGUgPT09ICdFTkZJTEUnKSlcbiAgICAgICAgICBlbnF1ZXVlKFtnbyR3cml0ZUZpbGUsIFtwYXRoLCBkYXRhLCBvcHRpb25zLCBjYl1dKVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICBpZiAodHlwZW9mIGNiID09PSAnZnVuY3Rpb24nKVxuICAgICAgICAgICAgY2IuYXBwbHkodGhpcywgYXJndW1lbnRzKVxuICAgICAgICAgIHJldHJ5KClcbiAgICAgICAgfVxuICAgICAgfSlcbiAgICB9XG4gIH1cblxuICB2YXIgZnMkYXBwZW5kRmlsZSA9IGZzLmFwcGVuZEZpbGVcbiAgaWYgKGZzJGFwcGVuZEZpbGUpXG4gICAgZnMuYXBwZW5kRmlsZSA9IGFwcGVuZEZpbGVcbiAgZnVuY3Rpb24gYXBwZW5kRmlsZSAocGF0aCwgZGF0YSwgb3B0aW9ucywgY2IpIHtcbiAgICBpZiAodHlwZW9mIG9wdGlvbnMgPT09ICdmdW5jdGlvbicpXG4gICAgICBjYiA9IG9wdGlvbnMsIG9wdGlvbnMgPSBudWxsXG5cbiAgICByZXR1cm4gZ28kYXBwZW5kRmlsZShwYXRoLCBkYXRhLCBvcHRpb25zLCBjYilcblxuICAgIGZ1bmN0aW9uIGdvJGFwcGVuZEZpbGUgKHBhdGgsIGRhdGEsIG9wdGlvbnMsIGNiKSB7XG4gICAgICByZXR1cm4gZnMkYXBwZW5kRmlsZShwYXRoLCBkYXRhLCBvcHRpb25zLCBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgIGlmIChlcnIgJiYgKGVyci5jb2RlID09PSAnRU1GSUxFJyB8fCBlcnIuY29kZSA9PT0gJ0VORklMRScpKVxuICAgICAgICAgIGVucXVldWUoW2dvJGFwcGVuZEZpbGUsIFtwYXRoLCBkYXRhLCBvcHRpb25zLCBjYl1dKVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICBpZiAodHlwZW9mIGNiID09PSAnZnVuY3Rpb24nKVxuICAgICAgICAgICAgY2IuYXBwbHkodGhpcywgYXJndW1lbnRzKVxuICAgICAgICAgIHJldHJ5KClcbiAgICAgICAgfVxuICAgICAgfSlcbiAgICB9XG4gIH1cblxuICB2YXIgZnMkcmVhZGRpciA9IGZzLnJlYWRkaXJcbiAgZnMucmVhZGRpciA9IHJlYWRkaXJcbiAgZnVuY3Rpb24gcmVhZGRpciAocGF0aCwgb3B0aW9ucywgY2IpIHtcbiAgICB2YXIgYXJncyA9IFtwYXRoXVxuICAgIGlmICh0eXBlb2Ygb3B0aW9ucyAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgYXJncy5wdXNoKG9wdGlvbnMpXG4gICAgfSBlbHNlIHtcbiAgICAgIGNiID0gb3B0aW9uc1xuICAgIH1cbiAgICBhcmdzLnB1c2goZ28kcmVhZGRpciRjYilcblxuICAgIHJldHVybiBnbyRyZWFkZGlyKGFyZ3MpXG5cbiAgICBmdW5jdGlvbiBnbyRyZWFkZGlyJGNiIChlcnIsIGZpbGVzKSB7XG4gICAgICBpZiAoZmlsZXMgJiYgZmlsZXMuc29ydClcbiAgICAgICAgZmlsZXMuc29ydCgpXG5cbiAgICAgIGlmIChlcnIgJiYgKGVyci5jb2RlID09PSAnRU1GSUxFJyB8fCBlcnIuY29kZSA9PT0gJ0VORklMRScpKVxuICAgICAgICBlbnF1ZXVlKFtnbyRyZWFkZGlyLCBbYXJnc11dKVxuICAgICAgZWxzZSB7XG4gICAgICAgIGlmICh0eXBlb2YgY2IgPT09ICdmdW5jdGlvbicpXG4gICAgICAgICAgY2IuYXBwbHkodGhpcywgYXJndW1lbnRzKVxuICAgICAgICByZXRyeSgpXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gZ28kcmVhZGRpciAoYXJncykge1xuICAgIHJldHVybiBmcyRyZWFkZGlyLmFwcGx5KGZzLCBhcmdzKVxuICB9XG5cbiAgaWYgKHByb2Nlc3MudmVyc2lvbi5zdWJzdHIoMCwgNCkgPT09ICd2MC44Jykge1xuICAgIHZhciBsZWdTdHJlYW1zID0gbGVnYWN5KGZzKVxuICAgIFJlYWRTdHJlYW0gPSBsZWdTdHJlYW1zLlJlYWRTdHJlYW1cbiAgICBXcml0ZVN0cmVhbSA9IGxlZ1N0cmVhbXMuV3JpdGVTdHJlYW1cbiAgfVxuXG4gIHZhciBmcyRSZWFkU3RyZWFtID0gZnMuUmVhZFN0cmVhbVxuICBSZWFkU3RyZWFtLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoZnMkUmVhZFN0cmVhbS5wcm90b3R5cGUpXG4gIFJlYWRTdHJlYW0ucHJvdG90eXBlLm9wZW4gPSBSZWFkU3RyZWFtJG9wZW5cblxuICB2YXIgZnMkV3JpdGVTdHJlYW0gPSBmcy5Xcml0ZVN0cmVhbVxuICBXcml0ZVN0cmVhbS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKGZzJFdyaXRlU3RyZWFtLnByb3RvdHlwZSlcbiAgV3JpdGVTdHJlYW0ucHJvdG90eXBlLm9wZW4gPSBXcml0ZVN0cmVhbSRvcGVuXG5cbiAgZnMuUmVhZFN0cmVhbSA9IFJlYWRTdHJlYW1cbiAgZnMuV3JpdGVTdHJlYW0gPSBXcml0ZVN0cmVhbVxuXG4gIGZ1bmN0aW9uIFJlYWRTdHJlYW0gKHBhdGgsIG9wdGlvbnMpIHtcbiAgICBpZiAodGhpcyBpbnN0YW5jZW9mIFJlYWRTdHJlYW0pXG4gICAgICByZXR1cm4gZnMkUmVhZFN0cmVhbS5hcHBseSh0aGlzLCBhcmd1bWVudHMpLCB0aGlzXG4gICAgZWxzZVxuICAgICAgcmV0dXJuIFJlYWRTdHJlYW0uYXBwbHkoT2JqZWN0LmNyZWF0ZShSZWFkU3RyZWFtLnByb3RvdHlwZSksIGFyZ3VtZW50cylcbiAgfVxuXG4gIGZ1bmN0aW9uIFJlYWRTdHJlYW0kb3BlbiAoKSB7XG4gICAgdmFyIHRoYXQgPSB0aGlzXG4gICAgb3Blbih0aGF0LnBhdGgsIHRoYXQuZmxhZ3MsIHRoYXQubW9kZSwgZnVuY3Rpb24gKGVyciwgZmQpIHtcbiAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgaWYgKHRoYXQuYXV0b0Nsb3NlKVxuICAgICAgICAgIHRoYXQuZGVzdHJveSgpXG5cbiAgICAgICAgdGhhdC5lbWl0KCdlcnJvcicsIGVycilcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoYXQuZmQgPSBmZFxuICAgICAgICB0aGF0LmVtaXQoJ29wZW4nLCBmZClcbiAgICAgICAgdGhhdC5yZWFkKClcbiAgICAgIH1cbiAgICB9KVxuICB9XG5cbiAgZnVuY3Rpb24gV3JpdGVTdHJlYW0gKHBhdGgsIG9wdGlvbnMpIHtcbiAgICBpZiAodGhpcyBpbnN0YW5jZW9mIFdyaXRlU3RyZWFtKVxuICAgICAgcmV0dXJuIGZzJFdyaXRlU3RyZWFtLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyksIHRoaXNcbiAgICBlbHNlXG4gICAgICByZXR1cm4gV3JpdGVTdHJlYW0uYXBwbHkoT2JqZWN0LmNyZWF0ZShXcml0ZVN0cmVhbS5wcm90b3R5cGUpLCBhcmd1bWVudHMpXG4gIH1cblxuICBmdW5jdGlvbiBXcml0ZVN0cmVhbSRvcGVuICgpIHtcbiAgICB2YXIgdGhhdCA9IHRoaXNcbiAgICBvcGVuKHRoYXQucGF0aCwgdGhhdC5mbGFncywgdGhhdC5tb2RlLCBmdW5jdGlvbiAoZXJyLCBmZCkge1xuICAgICAgaWYgKGVycikge1xuICAgICAgICB0aGF0LmRlc3Ryb3koKVxuICAgICAgICB0aGF0LmVtaXQoJ2Vycm9yJywgZXJyKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhhdC5mZCA9IGZkXG4gICAgICAgIHRoYXQuZW1pdCgnb3BlbicsIGZkKVxuICAgICAgfVxuICAgIH0pXG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVSZWFkU3RyZWFtIChwYXRoLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIG5ldyBSZWFkU3RyZWFtKHBhdGgsIG9wdGlvbnMpXG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVXcml0ZVN0cmVhbSAocGF0aCwgb3B0aW9ucykge1xuICAgIHJldHVybiBuZXcgV3JpdGVTdHJlYW0ocGF0aCwgb3B0aW9ucylcbiAgfVxuXG4gIHZhciBmcyRvcGVuID0gZnMub3BlblxuICBmcy5vcGVuID0gb3BlblxuICBmdW5jdGlvbiBvcGVuIChwYXRoLCBmbGFncywgbW9kZSwgY2IpIHtcbiAgICBpZiAodHlwZW9mIG1vZGUgPT09ICdmdW5jdGlvbicpXG4gICAgICBjYiA9IG1vZGUsIG1vZGUgPSBudWxsXG5cbiAgICByZXR1cm4gZ28kb3BlbihwYXRoLCBmbGFncywgbW9kZSwgY2IpXG5cbiAgICBmdW5jdGlvbiBnbyRvcGVuIChwYXRoLCBmbGFncywgbW9kZSwgY2IpIHtcbiAgICAgIHJldHVybiBmcyRvcGVuKHBhdGgsIGZsYWdzLCBtb2RlLCBmdW5jdGlvbiAoZXJyLCBmZCkge1xuICAgICAgICBpZiAoZXJyICYmIChlcnIuY29kZSA9PT0gJ0VNRklMRScgfHwgZXJyLmNvZGUgPT09ICdFTkZJTEUnKSlcbiAgICAgICAgICBlbnF1ZXVlKFtnbyRvcGVuLCBbcGF0aCwgZmxhZ3MsIG1vZGUsIGNiXV0pXG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIGlmICh0eXBlb2YgY2IgPT09ICdmdW5jdGlvbicpXG4gICAgICAgICAgICBjYi5hcHBseSh0aGlzLCBhcmd1bWVudHMpXG4gICAgICAgICAgcmV0cnkoKVxuICAgICAgICB9XG4gICAgICB9KVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmc1xufVxuXG5mdW5jdGlvbiBlbnF1ZXVlIChlbGVtKSB7XG4gIGRlYnVnKCdFTlFVRVVFJywgZWxlbVswXS5uYW1lLCBlbGVtWzFdKVxuICBxdWV1ZS5wdXNoKGVsZW0pXG59XG5cbmZ1bmN0aW9uIHJldHJ5ICgpIHtcbiAgdmFyIGVsZW0gPSBxdWV1ZS5zaGlmdCgpXG4gIGlmIChlbGVtKSB7XG4gICAgZGVidWcoJ1JFVFJZJywgZWxlbVswXS5uYW1lLCBlbGVtWzFdKVxuICAgIGVsZW1bMF0uYXBwbHkobnVsbCwgZWxlbVsxXSlcbiAgfVxufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2dyYWNlZnVsLWZzL2dyYWNlZnVsLWZzLmpzIiwiJ3VzZSBzdHJpY3QnXG5cbmV4cG9ydHMuZnJvbUNhbGxiYWNrID0gZnVuY3Rpb24gKGZuKSB7XG4gIHJldHVybiBPYmplY3QuZGVmaW5lUHJvcGVydHkoZnVuY3Rpb24gKCkge1xuICAgIGlmICh0eXBlb2YgYXJndW1lbnRzW2FyZ3VtZW50cy5sZW5ndGggLSAxXSA9PT0gJ2Z1bmN0aW9uJykgZm4uYXBwbHkodGhpcywgYXJndW1lbnRzKVxuICAgIGVsc2Uge1xuICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgYXJndW1lbnRzW2FyZ3VtZW50cy5sZW5ndGhdID0gKGVyciwgcmVzKSA9PiB7XG4gICAgICAgICAgaWYgKGVycikgcmV0dXJuIHJlamVjdChlcnIpXG4gICAgICAgICAgcmVzb2x2ZShyZXMpXG4gICAgICAgIH1cbiAgICAgICAgYXJndW1lbnRzLmxlbmd0aCsrXG4gICAgICAgIGZuLmFwcGx5KHRoaXMsIGFyZ3VtZW50cylcbiAgICAgIH0pXG4gICAgfVxuICB9LCAnbmFtZScsIHsgdmFsdWU6IGZuLm5hbWUgfSlcbn1cblxuZXhwb3J0cy5mcm9tUHJvbWlzZSA9IGZ1bmN0aW9uIChmbikge1xuICByZXR1cm4gT2JqZWN0LmRlZmluZVByb3BlcnR5KGZ1bmN0aW9uICgpIHtcbiAgICBjb25zdCBjYiA9IGFyZ3VtZW50c1thcmd1bWVudHMubGVuZ3RoIC0gMV1cbiAgICBpZiAodHlwZW9mIGNiICE9PSAnZnVuY3Rpb24nKSByZXR1cm4gZm4uYXBwbHkodGhpcywgYXJndW1lbnRzKVxuICAgIGVsc2UgZm4uYXBwbHkodGhpcywgYXJndW1lbnRzKS50aGVuKHIgPT4gY2IobnVsbCwgciksIGNiKVxuICB9LCAnbmFtZScsIHsgdmFsdWU6IGZuLm5hbWUgfSlcbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy91bml2ZXJzYWxpZnkvaW5kZXguanMiLCIndXNlIHN0cmljdCdcbmNvbnN0IHUgPSByZXF1aXJlKCd1bml2ZXJzYWxpZnknKS5mcm9tQ2FsbGJhY2tcbmNvbnN0IG1rZGlycyA9IHUocmVxdWlyZSgnLi9ta2RpcnMnKSlcbmNvbnN0IG1rZGlyc1N5bmMgPSByZXF1aXJlKCcuL21rZGlycy1zeW5jJylcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIG1rZGlyczogbWtkaXJzLFxuICBta2RpcnNTeW5jOiBta2RpcnNTeW5jLFxuICAvLyBhbGlhc1xuICBta2RpcnA6IG1rZGlycyxcbiAgbWtkaXJwU3luYzogbWtkaXJzU3luYyxcbiAgZW5zdXJlRGlyOiBta2RpcnMsXG4gIGVuc3VyZURpclN5bmM6IG1rZGlyc1N5bmNcbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9lbGVjdHJvbi11cGRhdGVyL25vZGVfbW9kdWxlcy9mcy1leHRyYS9saWIvbWtkaXJzL2luZGV4LmpzIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuVXBkYXRlclNpZ25hbCA9IGV4cG9ydHMuVVBEQVRFX0RPV05MT0FERUQgPSBleHBvcnRzLkRPV05MT0FEX1BST0dSRVNTID0gZXhwb3J0cy5Qcm92aWRlciA9IGV4cG9ydHMuQ2FuY2VsbGF0aW9uVG9rZW4gPSBleHBvcnRzLk5vT3BMb2dnZXIgPSBleHBvcnRzLkFwcFVwZGF0ZXIgPSB1bmRlZmluZWQ7XG5cbnZhciBfQXBwVXBkYXRlcjtcblxuZnVuY3Rpb24gX2xvYWRfQXBwVXBkYXRlcigpIHtcbiAgICByZXR1cm4gX0FwcFVwZGF0ZXIgPSByZXF1aXJlKFwiLi9BcHBVcGRhdGVyXCIpO1xufVxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJBcHBVcGRhdGVyXCIsIHtcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gKF9BcHBVcGRhdGVyIHx8IF9sb2FkX0FwcFVwZGF0ZXIoKSkuQXBwVXBkYXRlcjtcbiAgICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIk5vT3BMb2dnZXJcIiwge1xuICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiAoX0FwcFVwZGF0ZXIgfHwgX2xvYWRfQXBwVXBkYXRlcigpKS5Ob09wTG9nZ2VyO1xuICAgIH1cbn0pO1xuXG52YXIgX2J1aWxkZXJVdGlsUnVudGltZTtcblxuZnVuY3Rpb24gX2xvYWRfYnVpbGRlclV0aWxSdW50aW1lKCkge1xuICAgIHJldHVybiBfYnVpbGRlclV0aWxSdW50aW1lID0gcmVxdWlyZShcImJ1aWxkZXItdXRpbC1ydW50aW1lXCIpO1xufVxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJDYW5jZWxsYXRpb25Ub2tlblwiLCB7XG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIChfYnVpbGRlclV0aWxSdW50aW1lIHx8IF9sb2FkX2J1aWxkZXJVdGlsUnVudGltZSgpKS5DYW5jZWxsYXRpb25Ub2tlbjtcbiAgICB9XG59KTtcblxudmFyIF9Qcm92aWRlcjtcblxuZnVuY3Rpb24gX2xvYWRfUHJvdmlkZXIoKSB7XG4gICAgcmV0dXJuIF9Qcm92aWRlciA9IHJlcXVpcmUoXCIuL1Byb3ZpZGVyXCIpO1xufVxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJQcm92aWRlclwiLCB7XG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIChfUHJvdmlkZXIgfHwgX2xvYWRfUHJvdmlkZXIoKSkuUHJvdmlkZXI7XG4gICAgfVxufSk7XG5leHBvcnRzLmdldERlZmF1bHRDaGFubmVsTmFtZSA9IGdldERlZmF1bHRDaGFubmVsTmFtZTtcbmV4cG9ydHMuZ2V0Q3VzdG9tQ2hhbm5lbE5hbWUgPSBnZXRDdXN0b21DaGFubmVsTmFtZTtcbmV4cG9ydHMuZ2V0Q3VycmVudFBsYXRmb3JtID0gZ2V0Q3VycmVudFBsYXRmb3JtO1xuZXhwb3J0cy5pc1VzZU9sZE1hY1Byb3ZpZGVyID0gaXNVc2VPbGRNYWNQcm92aWRlcjtcbmV4cG9ydHMuZ2V0Q2hhbm5lbEZpbGVuYW1lID0gZ2V0Q2hhbm5lbEZpbGVuYW1lO1xuZXhwb3J0cy5uZXdCYXNlVXJsID0gbmV3QmFzZVVybDtcbmV4cG9ydHMubmV3VXJsRnJvbUJhc2UgPSBuZXdVcmxGcm9tQmFzZTtcblxudmFyIF91cmw7XG5cbmZ1bmN0aW9uIF9sb2FkX3VybCgpIHtcbiAgICByZXR1cm4gX3VybCA9IHJlcXVpcmUoXCJ1cmxcIik7XG59XG5cbi8vIGF1dG9VcGRhdGVyIHRvIG1pbWljIGVsZWN0cm9uIGJ1bmRsZWQgYXV0b1VwZGF0ZXJcbmxldCBfYXV0b1VwZGF0ZXI7XG5mdW5jdGlvbiBfbG9hZF9hdXRvVXBkYXRlcigpIHtcbiAgICAvLyB0c2xpbnQ6ZGlzYWJsZTpwcmVmZXItY29uZGl0aW9uYWwtZXhwcmVzc2lvblxuICAgIGlmIChwcm9jZXNzLnBsYXRmb3JtID09PSBcIndpbjMyXCIpIHtcbiAgICAgICAgX2F1dG9VcGRhdGVyID0gbmV3IChyZXF1aXJlKFwiLi9Oc2lzVXBkYXRlclwiKS5Oc2lzVXBkYXRlcikoKTtcbiAgICB9IGVsc2UgaWYgKHByb2Nlc3MucGxhdGZvcm0gPT09IFwiZGFyd2luXCIpIHtcbiAgICAgICAgX2F1dG9VcGRhdGVyID0gbmV3IChyZXF1aXJlKFwiLi9NYWNVcGRhdGVyXCIpLk1hY1VwZGF0ZXIpKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgX2F1dG9VcGRhdGVyID0gbmV3IChyZXF1aXJlKFwiLi9BcHBJbWFnZVVwZGF0ZXJcIikuQXBwSW1hZ2VVcGRhdGVyKSgpO1xuICAgIH1cbiAgICByZXR1cm4gX2F1dG9VcGRhdGVyO1xufVxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiYXV0b1VwZGF0ZXJcIiwge1xuICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgZ2V0OiAoKSA9PiB7XG4gICAgICAgIHJldHVybiBfYXV0b1VwZGF0ZXIgfHwgX2xvYWRfYXV0b1VwZGF0ZXIoKTtcbiAgICB9XG59KTtcbi8vIGR1ZSB0byBoaXN0b3JpY2FsIHJlYXNvbnMgZm9yIHdpbmRvd3Mgd2UgdXNlIGNoYW5uZWwgbmFtZSB3aXRob3V0IHBsYXRmb3JtIHNwZWNpZmllclxuZnVuY3Rpb24gZ2V0RGVmYXVsdENoYW5uZWxOYW1lKCkge1xuICAgIHJldHVybiBgbGF0ZXN0JHtnZXRDaGFubmVsRmlsZVByZWZpeCgpfWA7XG59XG5mdW5jdGlvbiBnZXRDaGFubmVsRmlsZVByZWZpeCgpIHtcbiAgICBjb25zdCBjdXJyZW50UGxhdGZvcm0gPSBnZXRDdXJyZW50UGxhdGZvcm0oKTtcbiAgICBpZiAoY3VycmVudFBsYXRmb3JtID09PSBcImxpbnV4XCIpIHtcbiAgICAgICAgY29uc3QgYXJjaCA9IHByb2Nlc3MuZW52LlRFU1RfVVBEQVRFUl9BUkNIIHx8IHByb2Nlc3MuYXJjaDtcbiAgICAgICAgY29uc3QgYXJjaFN1ZmZpeCA9IGFyY2ggPT09IFwieDY0XCIgPyBcIlwiIDogYC0ke2FyY2h9YDtcbiAgICAgICAgcmV0dXJuIFwiLWxpbnV4XCIgKyBhcmNoU3VmZml4O1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBjdXJyZW50UGxhdGZvcm0gPT09IFwiZGFyd2luXCIgPyBcIi1tYWNcIiA6IFwiXCI7XG4gICAgfVxufVxuZnVuY3Rpb24gZ2V0Q3VzdG9tQ2hhbm5lbE5hbWUoY2hhbm5lbCkge1xuICAgIHJldHVybiBgJHtjaGFubmVsfSR7Z2V0Q2hhbm5lbEZpbGVQcmVmaXgoKX1gO1xufVxuZnVuY3Rpb24gZ2V0Q3VycmVudFBsYXRmb3JtKCkge1xuICAgIHJldHVybiBwcm9jZXNzLmVudi5URVNUX1VQREFURVJfUExBVEZPUk0gfHwgcHJvY2Vzcy5wbGF0Zm9ybTtcbn1cbmZ1bmN0aW9uIGlzVXNlT2xkTWFjUHJvdmlkZXIoKSB7XG4gICAgLy8gZ2V0Q3VycmVudFBsYXRmb3JtKCkgPT09IFwiZGFyd2luXCJcbiAgICByZXR1cm4gZmFsc2U7XG59XG5mdW5jdGlvbiBnZXRDaGFubmVsRmlsZW5hbWUoY2hhbm5lbCkge1xuICAgIHJldHVybiBgJHtjaGFubmVsfS55bWxgO1xufVxuY29uc3QgRE9XTkxPQURfUFJPR1JFU1MgPSBleHBvcnRzLkRPV05MT0FEX1BST0dSRVNTID0gXCJkb3dubG9hZC1wcm9ncmVzc1wiO1xuY29uc3QgVVBEQVRFX0RPV05MT0FERUQgPSBleHBvcnRzLlVQREFURV9ET1dOTE9BREVEID0gXCJ1cGRhdGUtZG93bmxvYWRlZFwiO1xuY2xhc3MgVXBkYXRlclNpZ25hbCB7XG4gICAgY29uc3RydWN0b3IoZW1pdHRlcikge1xuICAgICAgICB0aGlzLmVtaXR0ZXIgPSBlbWl0dGVyO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBFbWl0dGVkIHdoZW4gYW4gYXV0aGVudGljYXRpbmcgcHJveHkgaXMgW2Fza2luZyBmb3IgdXNlciBjcmVkZW50aWFsc10oaHR0cHM6Ly9naXRodWIuY29tL2VsZWN0cm9uL2VsZWN0cm9uL2Jsb2IvbWFzdGVyL2RvY3MvYXBpL2NsaWVudC1yZXF1ZXN0Lm1kI2V2ZW50LWxvZ2luKS5cbiAgICAgKi9cbiAgICBsb2dpbihoYW5kbGVyKSB7XG4gICAgICAgIGFkZEhhbmRsZXIodGhpcy5lbWl0dGVyLCBcImxvZ2luXCIsIGhhbmRsZXIpO1xuICAgIH1cbiAgICBwcm9ncmVzcyhoYW5kbGVyKSB7XG4gICAgICAgIGFkZEhhbmRsZXIodGhpcy5lbWl0dGVyLCBET1dOTE9BRF9QUk9HUkVTUywgaGFuZGxlcik7XG4gICAgfVxuICAgIHVwZGF0ZURvd25sb2FkZWQoaGFuZGxlcikge1xuICAgICAgICBhZGRIYW5kbGVyKHRoaXMuZW1pdHRlciwgVVBEQVRFX0RPV05MT0FERUQsIGhhbmRsZXIpO1xuICAgIH1cbiAgICB1cGRhdGVDYW5jZWxsZWQoaGFuZGxlcikge1xuICAgICAgICBhZGRIYW5kbGVyKHRoaXMuZW1pdHRlciwgXCJ1cGRhdGUtY2FuY2VsbGVkXCIsIGhhbmRsZXIpO1xuICAgIH1cbn1cbmV4cG9ydHMuVXBkYXRlclNpZ25hbCA9IFVwZGF0ZXJTaWduYWw7XG5jb25zdCBpc0xvZ0V2ZW50ID0gZmFsc2U7XG5mdW5jdGlvbiBhZGRIYW5kbGVyKGVtaXR0ZXIsIGV2ZW50LCBoYW5kbGVyKSB7XG4gICAgaWYgKGlzTG9nRXZlbnQpIHtcbiAgICAgICAgZW1pdHRlci5vbihldmVudCwgKC4uLmFyZ3MpID0+IHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiJXMgJXNcIiwgZXZlbnQsIGFyZ3MpO1xuICAgICAgICAgICAgaGFuZGxlci5hcHBseShudWxsLCBhcmdzKTtcbiAgICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgZW1pdHRlci5vbihldmVudCwgaGFuZGxlcik7XG4gICAgfVxufVxuLy8gaWYgYmFzZVVybCBwYXRoIGRvZXNuJ3QgZW5kcyB3aXRoIC8sIHRoaXMgcGF0aCB3aWxsIGJlIG5vdCBwcmVwZW5kZWQgdG8gcGFzc2VkIHBhdGhuYW1lIGZvciBuZXcgVVJMKGlucHV0LCBiYXNlKVxuLyoqIEBpbnRlcm5hbCAqL1xuZnVuY3Rpb24gbmV3QmFzZVVybCh1cmwpIHtcbiAgICBjb25zdCByZXN1bHQgPSBuZXcgKF91cmwgfHwgX2xvYWRfdXJsKCkpLlVSTCh1cmwpO1xuICAgIGlmICghcmVzdWx0LnBhdGhuYW1lLmVuZHNXaXRoKFwiL1wiKSkge1xuICAgICAgICByZXN1bHQucGF0aG5hbWUgKz0gXCIvXCI7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG4vKiogQGludGVybmFsICovXG5mdW5jdGlvbiBuZXdVcmxGcm9tQmFzZShwYXRobmFtZSwgYmFzZVVybCkge1xuICAgIGNvbnN0IHJlc3VsdCA9IG5ldyAoX3VybCB8fCBfbG9hZF91cmwoKSkuVVJMKHBhdGhuYW1lLCBiYXNlVXJsKTtcbiAgICAvLyBzZWFyY2ggaXMgbm90IHByb3BhZ2F0ZWRcbiAgICBpZiAoIXJlc3VsdC5zZWFyY2ggJiYgYmFzZVVybC5zZWFyY2gpIHtcbiAgICAgICAgcmVzdWx0LnNlYXJjaCA9IGJhc2VVcmwuc2VhcmNoO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bWFpbi5qcy5tYXBcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvZWxlY3Ryb24tdXBkYXRlci9vdXQvbWFpbi5qcyIsIlwidXNlIHN0cmljdFwiXG5cbmNvbnN0IGZzRXh0cmEgPSByZXF1aXJlKFwiZnMtZXh0cmFcIilcbmNvbnN0IFByb21pc2UgPSByZXF1aXJlKCdibHVlYmlyZC1sc3QnKVxuXG5mdW5jdGlvbiBtYWtlRnMoUHJvbWlzZSkge1xuICBjb25zdCBmcyA9IE9iamVjdC5jcmVhdGUobnVsbClcblxuICBmb3IgKGNvbnN0IG1ldGhvZE5hbWUgb2YgT2JqZWN0LmtleXMoZnNFeHRyYSkpIHtcbiAgICBjb25zdCBtZXRob2QgPSBmc0V4dHJhW21ldGhvZE5hbWVdXG4gICAgaWYgKG1ldGhvZE5hbWUgPT09IFwiY3JlYXRlRmlsZVwiIHx8IG1ldGhvZE5hbWUgPT09IFwibWtkaXJwXCIpIHtcbiAgICAgIGNvbnRpbnVlXG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBtZXRob2QgIT09IFwiZnVuY3Rpb25cIiB8fFxuICAgICAgICBtZXRob2ROYW1lLmVuZHNXaXRoKFwiU3luY1wiKSB8fFxuICAgICAgICBtZXRob2ROYW1lLmVuZHNXaXRoKFwiU3RyZWFtXCIpIHx8XG4gICAgICAgIG1ldGhvZE5hbWUubWF0Y2goL15bQS1aXS8pIHx8XG4gICAgICAgIG1ldGhvZE5hbWUgPT09IFwiZXhpc3RzXCIgfHxcbiAgICAgICAgbWV0aG9kTmFtZSA9PT0gXCJ3YXRjaFwiIHx8XG4gICAgICAgIG1ldGhvZE5hbWUgPT09IFwid2F0Y2hGaWxlXCIgfHxcbiAgICAgICAgbWV0aG9kTmFtZSA9PT0gXCJ1bndhdGNoRmlsZVwiKSB7XG4gICAgICBmc1ttZXRob2ROYW1lXSA9IG1ldGhvZFxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIGZzW21ldGhvZE5hbWVdID0gUHJvbWlzZS5wcm9taXNpZnkobWV0aG9kKVxuICAgIH1cbiAgfVxuXG4gIGZzLmNyZWF0ZUZpbGUgPSBmcy5lbnN1cmVGaWxlXG4gIGZzLm1rZGlycCA9IGZzLm1rZGlyc1xuICByZXR1cm4gZnNcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBtYWtlRnMoUHJvbWlzZSlcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvZWxlY3Ryb24tdXBkYXRlci9ub2RlX21vZHVsZXMvZnMtZXh0cmEtcC9pbmRleC5qcyIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcImVsZWN0cm9uXCIpO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIGV4dGVybmFsIFwiZWxlY3Ryb25cIlxuLy8gbW9kdWxlIGlkID0gMTBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgZXM1ID0gcmVxdWlyZShcIi4vZXM1XCIpO1xudmFyIE9iamVjdGZyZWV6ZSA9IGVzNS5mcmVlemU7XG52YXIgdXRpbCA9IHJlcXVpcmUoXCIuL3V0aWxcIik7XG52YXIgaW5oZXJpdHMgPSB1dGlsLmluaGVyaXRzO1xudmFyIG5vdEVudW1lcmFibGVQcm9wID0gdXRpbC5ub3RFbnVtZXJhYmxlUHJvcDtcblxuZnVuY3Rpb24gc3ViRXJyb3IobmFtZVByb3BlcnR5LCBkZWZhdWx0TWVzc2FnZSkge1xuICAgIGZ1bmN0aW9uIFN1YkVycm9yKG1lc3NhZ2UpIHtcbiAgICAgICAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIFN1YkVycm9yKSkgcmV0dXJuIG5ldyBTdWJFcnJvcihtZXNzYWdlKTtcbiAgICAgICAgbm90RW51bWVyYWJsZVByb3AodGhpcywgXCJtZXNzYWdlXCIsXG4gICAgICAgICAgICB0eXBlb2YgbWVzc2FnZSA9PT0gXCJzdHJpbmdcIiA/IG1lc3NhZ2UgOiBkZWZhdWx0TWVzc2FnZSk7XG4gICAgICAgIG5vdEVudW1lcmFibGVQcm9wKHRoaXMsIFwibmFtZVwiLCBuYW1lUHJvcGVydHkpO1xuICAgICAgICBpZiAoRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UpIHtcbiAgICAgICAgICAgIEVycm9yLmNhcHR1cmVTdGFja1RyYWNlKHRoaXMsIHRoaXMuY29uc3RydWN0b3IpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgRXJyb3IuY2FsbCh0aGlzKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpbmhlcml0cyhTdWJFcnJvciwgRXJyb3IpO1xuICAgIHJldHVybiBTdWJFcnJvcjtcbn1cblxudmFyIF9UeXBlRXJyb3IsIF9SYW5nZUVycm9yO1xudmFyIFdhcm5pbmcgPSBzdWJFcnJvcihcIldhcm5pbmdcIiwgXCJ3YXJuaW5nXCIpO1xudmFyIENhbmNlbGxhdGlvbkVycm9yID0gc3ViRXJyb3IoXCJDYW5jZWxsYXRpb25FcnJvclwiLCBcImNhbmNlbGxhdGlvbiBlcnJvclwiKTtcbnZhciBUaW1lb3V0RXJyb3IgPSBzdWJFcnJvcihcIlRpbWVvdXRFcnJvclwiLCBcInRpbWVvdXQgZXJyb3JcIik7XG52YXIgQWdncmVnYXRlRXJyb3IgPSBzdWJFcnJvcihcIkFnZ3JlZ2F0ZUVycm9yXCIsIFwiYWdncmVnYXRlIGVycm9yXCIpO1xudHJ5IHtcbiAgICBfVHlwZUVycm9yID0gVHlwZUVycm9yO1xuICAgIF9SYW5nZUVycm9yID0gUmFuZ2VFcnJvcjtcbn0gY2F0Y2goZSkge1xuICAgIF9UeXBlRXJyb3IgPSBzdWJFcnJvcihcIlR5cGVFcnJvclwiLCBcInR5cGUgZXJyb3JcIik7XG4gICAgX1JhbmdlRXJyb3IgPSBzdWJFcnJvcihcIlJhbmdlRXJyb3JcIiwgXCJyYW5nZSBlcnJvclwiKTtcbn1cblxudmFyIG1ldGhvZHMgPSAoXCJqb2luIHBvcCBwdXNoIHNoaWZ0IHVuc2hpZnQgc2xpY2UgZmlsdGVyIGZvckVhY2ggc29tZSBcIiArXG4gICAgXCJldmVyeSBtYXAgaW5kZXhPZiBsYXN0SW5kZXhPZiByZWR1Y2UgcmVkdWNlUmlnaHQgc29ydCByZXZlcnNlXCIpLnNwbGl0KFwiIFwiKTtcblxuZm9yICh2YXIgaSA9IDA7IGkgPCBtZXRob2RzLmxlbmd0aDsgKytpKSB7XG4gICAgaWYgKHR5cGVvZiBBcnJheS5wcm90b3R5cGVbbWV0aG9kc1tpXV0gPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICBBZ2dyZWdhdGVFcnJvci5wcm90b3R5cGVbbWV0aG9kc1tpXV0gPSBBcnJheS5wcm90b3R5cGVbbWV0aG9kc1tpXV07XG4gICAgfVxufVxuXG5lczUuZGVmaW5lUHJvcGVydHkoQWdncmVnYXRlRXJyb3IucHJvdG90eXBlLCBcImxlbmd0aFwiLCB7XG4gICAgdmFsdWU6IDAsXG4gICAgY29uZmlndXJhYmxlOiBmYWxzZSxcbiAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICBlbnVtZXJhYmxlOiB0cnVlXG59KTtcbkFnZ3JlZ2F0ZUVycm9yLnByb3RvdHlwZVtcImlzT3BlcmF0aW9uYWxcIl0gPSB0cnVlO1xudmFyIGxldmVsID0gMDtcbkFnZ3JlZ2F0ZUVycm9yLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBpbmRlbnQgPSBBcnJheShsZXZlbCAqIDQgKyAxKS5qb2luKFwiIFwiKTtcbiAgICB2YXIgcmV0ID0gXCJcXG5cIiArIGluZGVudCArIFwiQWdncmVnYXRlRXJyb3Igb2Y6XCIgKyBcIlxcblwiO1xuICAgIGxldmVsKys7XG4gICAgaW5kZW50ID0gQXJyYXkobGV2ZWwgKiA0ICsgMSkuam9pbihcIiBcIik7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIHZhciBzdHIgPSB0aGlzW2ldID09PSB0aGlzID8gXCJbQ2lyY3VsYXIgQWdncmVnYXRlRXJyb3JdXCIgOiB0aGlzW2ldICsgXCJcIjtcbiAgICAgICAgdmFyIGxpbmVzID0gc3RyLnNwbGl0KFwiXFxuXCIpO1xuICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGxpbmVzLmxlbmd0aDsgKytqKSB7XG4gICAgICAgICAgICBsaW5lc1tqXSA9IGluZGVudCArIGxpbmVzW2pdO1xuICAgICAgICB9XG4gICAgICAgIHN0ciA9IGxpbmVzLmpvaW4oXCJcXG5cIik7XG4gICAgICAgIHJldCArPSBzdHIgKyBcIlxcblwiO1xuICAgIH1cbiAgICBsZXZlbC0tO1xuICAgIHJldHVybiByZXQ7XG59O1xuXG5mdW5jdGlvbiBPcGVyYXRpb25hbEVycm9yKG1lc3NhZ2UpIHtcbiAgICBpZiAoISh0aGlzIGluc3RhbmNlb2YgT3BlcmF0aW9uYWxFcnJvcikpXG4gICAgICAgIHJldHVybiBuZXcgT3BlcmF0aW9uYWxFcnJvcihtZXNzYWdlKTtcbiAgICBub3RFbnVtZXJhYmxlUHJvcCh0aGlzLCBcIm5hbWVcIiwgXCJPcGVyYXRpb25hbEVycm9yXCIpO1xuICAgIG5vdEVudW1lcmFibGVQcm9wKHRoaXMsIFwibWVzc2FnZVwiLCBtZXNzYWdlKTtcbiAgICB0aGlzLmNhdXNlID0gbWVzc2FnZTtcbiAgICB0aGlzW1wiaXNPcGVyYXRpb25hbFwiXSA9IHRydWU7XG5cbiAgICBpZiAobWVzc2FnZSBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAgIG5vdEVudW1lcmFibGVQcm9wKHRoaXMsIFwibWVzc2FnZVwiLCBtZXNzYWdlLm1lc3NhZ2UpO1xuICAgICAgICBub3RFbnVtZXJhYmxlUHJvcCh0aGlzLCBcInN0YWNrXCIsIG1lc3NhZ2Uuc3RhY2spO1xuICAgIH0gZWxzZSBpZiAoRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UpIHtcbiAgICAgICAgRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UodGhpcywgdGhpcy5jb25zdHJ1Y3Rvcik7XG4gICAgfVxuXG59XG5pbmhlcml0cyhPcGVyYXRpb25hbEVycm9yLCBFcnJvcik7XG5cbnZhciBlcnJvclR5cGVzID0gRXJyb3JbXCJfX0JsdWViaXJkRXJyb3JUeXBlc19fXCJdO1xuaWYgKCFlcnJvclR5cGVzKSB7XG4gICAgZXJyb3JUeXBlcyA9IE9iamVjdGZyZWV6ZSh7XG4gICAgICAgIENhbmNlbGxhdGlvbkVycm9yOiBDYW5jZWxsYXRpb25FcnJvcixcbiAgICAgICAgVGltZW91dEVycm9yOiBUaW1lb3V0RXJyb3IsXG4gICAgICAgIE9wZXJhdGlvbmFsRXJyb3I6IE9wZXJhdGlvbmFsRXJyb3IsXG4gICAgICAgIFJlamVjdGlvbkVycm9yOiBPcGVyYXRpb25hbEVycm9yLFxuICAgICAgICBBZ2dyZWdhdGVFcnJvcjogQWdncmVnYXRlRXJyb3JcbiAgICB9KTtcbiAgICBlczUuZGVmaW5lUHJvcGVydHkoRXJyb3IsIFwiX19CbHVlYmlyZEVycm9yVHlwZXNfX1wiLCB7XG4gICAgICAgIHZhbHVlOiBlcnJvclR5cGVzLFxuICAgICAgICB3cml0YWJsZTogZmFsc2UsXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICBjb25maWd1cmFibGU6IGZhbHNlXG4gICAgfSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICAgIEVycm9yOiBFcnJvcixcbiAgICBUeXBlRXJyb3I6IF9UeXBlRXJyb3IsXG4gICAgUmFuZ2VFcnJvcjogX1JhbmdlRXJyb3IsXG4gICAgQ2FuY2VsbGF0aW9uRXJyb3I6IGVycm9yVHlwZXMuQ2FuY2VsbGF0aW9uRXJyb3IsXG4gICAgT3BlcmF0aW9uYWxFcnJvcjogZXJyb3JUeXBlcy5PcGVyYXRpb25hbEVycm9yLFxuICAgIFRpbWVvdXRFcnJvcjogZXJyb3JUeXBlcy5UaW1lb3V0RXJyb3IsXG4gICAgQWdncmVnYXRlRXJyb3I6IGVycm9yVHlwZXMuQWdncmVnYXRlRXJyb3IsXG4gICAgV2FybmluZzogV2FybmluZ1xufTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9ibHVlYmlyZC9qcy9yZWxlYXNlL2Vycm9ycy5qcyIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcImZzXCIpO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIGV4dGVybmFsIFwiZnNcIlxuLy8gbW9kdWxlIGlkID0gMTJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiJ3VzZSBzdHJpY3QnXG5jb25zdCB1ID0gcmVxdWlyZSgndW5pdmVyc2FsaWZ5JykuZnJvbVByb21pc2VcbmNvbnN0IGZzID0gcmVxdWlyZSgnLi4vZnMnKVxuXG5mdW5jdGlvbiBwYXRoRXhpc3RzIChwYXRoKSB7XG4gIHJldHVybiBmcy5hY2Nlc3MocGF0aCkudGhlbigoKSA9PiB0cnVlKS5jYXRjaCgoKSA9PiBmYWxzZSlcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIHBhdGhFeGlzdHM6IHUocGF0aEV4aXN0cyksXG4gIHBhdGhFeGlzdHNTeW5jOiBmcy5leGlzdHNTeW5jXG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvZWxlY3Ryb24tdXBkYXRlci9ub2RlX21vZHVsZXMvZnMtZXh0cmEvbGliL3BhdGgtZXhpc3RzL2luZGV4LmpzIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuUHJvdmlkZXIgPSB1bmRlZmluZWQ7XG5leHBvcnRzLmZpbmRGaWxlID0gZmluZEZpbGU7XG5leHBvcnRzLnBhcnNlVXBkYXRlSW5mbyA9IHBhcnNlVXBkYXRlSW5mbztcbmV4cG9ydHMuZ2V0RmlsZUxpc3QgPSBnZXRGaWxlTGlzdDtcbmV4cG9ydHMucmVzb2x2ZUZpbGVzID0gcmVzb2x2ZUZpbGVzO1xuXG52YXIgX2J1aWxkZXJVdGlsUnVudGltZTtcblxuZnVuY3Rpb24gX2xvYWRfYnVpbGRlclV0aWxSdW50aW1lKCkge1xuICAgIHJldHVybiBfYnVpbGRlclV0aWxSdW50aW1lID0gcmVxdWlyZShcImJ1aWxkZXItdXRpbC1ydW50aW1lXCIpO1xufVxuXG52YXIgX2pzWWFtbDtcblxuZnVuY3Rpb24gX2xvYWRfanNZYW1sKCkge1xuICAgIHJldHVybiBfanNZYW1sID0gcmVxdWlyZShcImpzLXlhbWxcIik7XG59XG5cbnZhciBfbWFpbjtcblxuZnVuY3Rpb24gX2xvYWRfbWFpbigpIHtcbiAgICByZXR1cm4gX21haW4gPSByZXF1aXJlKFwiLi9tYWluXCIpO1xufVxuXG5jbGFzcyBQcm92aWRlciB7XG4gICAgY29uc3RydWN0b3IoZXhlY3V0b3IsIHVzZU11bHRpcGxlUmFuZ2VSZXF1ZXN0ID0gdHJ1ZSkge1xuICAgICAgICB0aGlzLmV4ZWN1dG9yID0gZXhlY3V0b3I7XG4gICAgICAgIHRoaXMudXNlTXVsdGlwbGVSYW5nZVJlcXVlc3QgPSB1c2VNdWx0aXBsZVJhbmdlUmVxdWVzdDtcbiAgICB9XG4gICAgZ2V0IGZpbGVFeHRyYURvd25sb2FkSGVhZGVycygpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHNldFJlcXVlc3RIZWFkZXJzKHZhbHVlKSB7XG4gICAgICAgIHRoaXMucmVxdWVzdEhlYWRlcnMgPSB2YWx1ZTtcbiAgICB9XG4gICAgaHR0cFJlcXVlc3QodXJsLCBoZWFkZXJzLCBjYW5jZWxsYXRpb25Ub2tlbikge1xuICAgICAgICByZXR1cm4gdGhpcy5leGVjdXRvci5yZXF1ZXN0KHRoaXMuY3JlYXRlUmVxdWVzdE9wdGlvbnModXJsLCBoZWFkZXJzKSwgY2FuY2VsbGF0aW9uVG9rZW4pO1xuICAgIH1cbiAgICBjcmVhdGVSZXF1ZXN0T3B0aW9ucyh1cmwsIGhlYWRlcnMpIHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0ge307XG4gICAgICAgIGlmICh0aGlzLnJlcXVlc3RIZWFkZXJzID09IG51bGwpIHtcbiAgICAgICAgICAgIGlmIChoZWFkZXJzICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQuaGVhZGVycyA9IGhlYWRlcnM7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXN1bHQuaGVhZGVycyA9IGhlYWRlcnMgPT0gbnVsbCA/IHRoaXMucmVxdWVzdEhlYWRlcnMgOiBPYmplY3QuYXNzaWduKHt9LCB0aGlzLnJlcXVlc3RIZWFkZXJzLCBoZWFkZXJzKTtcbiAgICAgICAgfVxuICAgICAgICByZXN1bHQucHJvdG9jb2wgPSB1cmwucHJvdG9jb2w7XG4gICAgICAgIHJlc3VsdC5ob3N0bmFtZSA9IHVybC5ob3N0bmFtZTtcbiAgICAgICAgaWYgKHVybC5wb3J0KSB7XG4gICAgICAgICAgICByZXN1bHQucG9ydCA9IHVybC5wb3J0O1xuICAgICAgICB9XG4gICAgICAgIHJlc3VsdC5wYXRoID0gdXJsLnBhdGhuYW1lICsgdXJsLnNlYXJjaDtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG59XG5leHBvcnRzLlByb3ZpZGVyID0gUHJvdmlkZXI7XG5mdW5jdGlvbiBmaW5kRmlsZShmaWxlcywgZXh0ZW5zaW9uLCBub3QpIHtcbiAgICBpZiAoZmlsZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHRocm93ICgwLCAoX2J1aWxkZXJVdGlsUnVudGltZSB8fCBfbG9hZF9idWlsZGVyVXRpbFJ1bnRpbWUoKSkubmV3RXJyb3IpKFwiTm8gZmlsZXMgcHJvdmlkZWRcIiwgXCJFUlJfVVBEQVRFUl9OT19GSUxFU19QUk9WSURFRFwiKTtcbiAgICB9XG4gICAgY29uc3QgcmVzdWx0ID0gZmlsZXMuZmluZChpdCA9PiBpdC51cmwucGF0aG5hbWUudG9Mb3dlckNhc2UoKS5lbmRzV2l0aChgLiR7ZXh0ZW5zaW9ufWApKTtcbiAgICBpZiAocmVzdWx0ICE9IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9IGVsc2UgaWYgKG5vdCA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBmaWxlc1swXTtcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gZmlsZXMuZmluZChmaWxlSW5mbyA9PiAhbm90LnNvbWUoZXh0ID0+IGZpbGVJbmZvLnVybC5wYXRobmFtZS50b0xvd2VyQ2FzZSgpLmVuZHNXaXRoKGAuJHtleHR9YCkpKTtcbiAgICB9XG59XG5mdW5jdGlvbiBwYXJzZVVwZGF0ZUluZm8ocmF3RGF0YSwgY2hhbm5lbEZpbGUsIGNoYW5uZWxGaWxlVXJsKSB7XG4gICAgaWYgKHJhd0RhdGEgPT0gbnVsbCkge1xuICAgICAgICB0aHJvdyAoMCwgKF9idWlsZGVyVXRpbFJ1bnRpbWUgfHwgX2xvYWRfYnVpbGRlclV0aWxSdW50aW1lKCkpLm5ld0Vycm9yKShgQ2Fubm90IHBhcnNlIHVwZGF0ZSBpbmZvIGZyb20gJHtjaGFubmVsRmlsZX0gaW4gdGhlIGxhdGVzdCByZWxlYXNlIGFydGlmYWN0cyAoJHtjaGFubmVsRmlsZVVybH0pOiByYXdEYXRhOiBudWxsYCwgXCJFUlJfVVBEQVRFUl9JTlZBTElEX1VQREFURV9JTkZPXCIpO1xuICAgIH1cbiAgICBsZXQgcmVzdWx0O1xuICAgIHRyeSB7XG4gICAgICAgIHJlc3VsdCA9ICgwLCAoX2pzWWFtbCB8fCBfbG9hZF9qc1lhbWwoKSkuc2FmZUxvYWQpKHJhd0RhdGEpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgdGhyb3cgKDAsIChfYnVpbGRlclV0aWxSdW50aW1lIHx8IF9sb2FkX2J1aWxkZXJVdGlsUnVudGltZSgpKS5uZXdFcnJvcikoYENhbm5vdCBwYXJzZSB1cGRhdGUgaW5mbyBmcm9tICR7Y2hhbm5lbEZpbGV9IGluIHRoZSBsYXRlc3QgcmVsZWFzZSBhcnRpZmFjdHMgKCR7Y2hhbm5lbEZpbGVVcmx9KTogJHtlLnN0YWNrIHx8IGUubWVzc2FnZX0sIHJhd0RhdGE6ICR7cmF3RGF0YX1gLCBcIkVSUl9VUERBVEVSX0lOVkFMSURfVVBEQVRFX0lORk9cIik7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiBnZXRGaWxlTGlzdCh1cGRhdGVJbmZvKSB7XG4gICAgY29uc3QgZmlsZXMgPSB1cGRhdGVJbmZvLmZpbGVzO1xuICAgIGlmIChmaWxlcyAhPSBudWxsICYmIGZpbGVzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgcmV0dXJuIGZpbGVzO1xuICAgIH1cbiAgICBpZiAodXBkYXRlSW5mby5wYXRoICE9IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIFt7XG4gICAgICAgICAgICB1cmw6IHVwZGF0ZUluZm8ucGF0aCxcbiAgICAgICAgICAgIHNoYTUxMjogdXBkYXRlSW5mby5zaGE1MTJcbiAgICAgICAgfV07XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgKDAsIChfYnVpbGRlclV0aWxSdW50aW1lIHx8IF9sb2FkX2J1aWxkZXJVdGlsUnVudGltZSgpKS5uZXdFcnJvcikoYE5vIGZpbGVzIHByb3ZpZGVkOiAkeygwLCAoX2J1aWxkZXJVdGlsUnVudGltZSB8fCBfbG9hZF9idWlsZGVyVXRpbFJ1bnRpbWUoKSkuc2FmZVN0cmluZ2lmeUpzb24pKHVwZGF0ZUluZm8pfWAsIFwiRVJSX1VQREFURVJfTk9fRklMRVNfUFJPVklERURcIik7XG4gICAgfVxufVxuZnVuY3Rpb24gcmVzb2x2ZUZpbGVzKHVwZGF0ZUluZm8sIGJhc2VVcmwsIHBhdGhUcmFuc2Zvcm1lciA9IHAgPT4gcCkge1xuICAgIGNvbnN0IGZpbGVzID0gZ2V0RmlsZUxpc3QodXBkYXRlSW5mbyk7XG4gICAgY29uc3QgcmVzdWx0ID0gZmlsZXMubWFwKGZpbGVJbmZvID0+IHtcbiAgICAgICAgaWYgKGZpbGVJbmZvLnNoYTIgPT0gbnVsbCAmJiBmaWxlSW5mby5zaGE1MTIgPT0gbnVsbCkge1xuICAgICAgICAgICAgdGhyb3cgKDAsIChfYnVpbGRlclV0aWxSdW50aW1lIHx8IF9sb2FkX2J1aWxkZXJVdGlsUnVudGltZSgpKS5uZXdFcnJvcikoYFVwZGF0ZSBpbmZvIGRvZXNuJ3QgY29udGFpbiBub3Igc2hhMjU2IG5laXRoZXIgc2hhNTEyIGNoZWNrc3VtOiAkeygwLCAoX2J1aWxkZXJVdGlsUnVudGltZSB8fCBfbG9hZF9idWlsZGVyVXRpbFJ1bnRpbWUoKSkuc2FmZVN0cmluZ2lmeUpzb24pKGZpbGVJbmZvKX1gLCBcIkVSUl9VUERBVEVSX05PX0NIRUNLU1VNXCIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB1cmw6ICgwLCAoX21haW4gfHwgX2xvYWRfbWFpbigpKS5uZXdVcmxGcm9tQmFzZSkocGF0aFRyYW5zZm9ybWVyKGZpbGVJbmZvLnVybCksIGJhc2VVcmwpLFxuICAgICAgICAgICAgaW5mbzogZmlsZUluZm9cbiAgICAgICAgfTtcbiAgICB9KTtcbiAgICBjb25zdCBwYWNrYWdlcyA9IHVwZGF0ZUluZm8ucGFja2FnZXM7XG4gICAgY29uc3QgcGFja2FnZUluZm8gPSBwYWNrYWdlcyA9PSBudWxsID8gbnVsbCA6IHBhY2thZ2VzW3Byb2Nlc3MuYXJjaF0gfHwgcGFja2FnZXMuaWEzMjtcbiAgICBpZiAocGFja2FnZUluZm8gIT0gbnVsbCkge1xuICAgICAgICByZXN1bHRbMF0ucGFja2FnZUluZm8gPSBPYmplY3QuYXNzaWduKHt9LCBwYWNrYWdlSW5mbywgeyBwYXRoOiAoMCwgKF9tYWluIHx8IF9sb2FkX21haW4oKSkubmV3VXJsRnJvbUJhc2UpKHBhdGhUcmFuc2Zvcm1lcihwYWNrYWdlSW5mby5wYXRoKSwgYmFzZVVybCkuaHJlZiB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVByb3ZpZGVyLmpzLm1hcFxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9lbGVjdHJvbi11cGRhdGVyL291dC9Qcm92aWRlci5qcyIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcIm9zXCIpO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIGV4dGVybmFsIFwib3NcIlxuLy8gbW9kdWxlIGlkID0gMTVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIGlzRVM1ID0gKGZ1bmN0aW9uKCl7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgcmV0dXJuIHRoaXMgPT09IHVuZGVmaW5lZDtcbn0pKCk7XG5cbmlmIChpc0VTNSkge1xuICAgIG1vZHVsZS5leHBvcnRzID0ge1xuICAgICAgICBmcmVlemU6IE9iamVjdC5mcmVlemUsXG4gICAgICAgIGRlZmluZVByb3BlcnR5OiBPYmplY3QuZGVmaW5lUHJvcGVydHksXG4gICAgICAgIGdldERlc2NyaXB0b3I6IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IsXG4gICAgICAgIGtleXM6IE9iamVjdC5rZXlzLFxuICAgICAgICBuYW1lczogT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMsXG4gICAgICAgIGdldFByb3RvdHlwZU9mOiBPYmplY3QuZ2V0UHJvdG90eXBlT2YsXG4gICAgICAgIGlzQXJyYXk6IEFycmF5LmlzQXJyYXksXG4gICAgICAgIGlzRVM1OiBpc0VTNSxcbiAgICAgICAgcHJvcGVydHlJc1dyaXRhYmxlOiBmdW5jdGlvbihvYmosIHByb3ApIHtcbiAgICAgICAgICAgIHZhciBkZXNjcmlwdG9yID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmosIHByb3ApO1xuICAgICAgICAgICAgcmV0dXJuICEhKCFkZXNjcmlwdG9yIHx8IGRlc2NyaXB0b3Iud3JpdGFibGUgfHwgZGVzY3JpcHRvci5zZXQpO1xuICAgICAgICB9XG4gICAgfTtcbn0gZWxzZSB7XG4gICAgdmFyIGhhcyA9IHt9Lmhhc093blByb3BlcnR5O1xuICAgIHZhciBzdHIgPSB7fS50b1N0cmluZztcbiAgICB2YXIgcHJvdG8gPSB7fS5jb25zdHJ1Y3Rvci5wcm90b3R5cGU7XG5cbiAgICB2YXIgT2JqZWN0S2V5cyA9IGZ1bmN0aW9uIChvKSB7XG4gICAgICAgIHZhciByZXQgPSBbXTtcbiAgICAgICAgZm9yICh2YXIga2V5IGluIG8pIHtcbiAgICAgICAgICAgIGlmIChoYXMuY2FsbChvLCBrZXkpKSB7XG4gICAgICAgICAgICAgICAgcmV0LnB1c2goa2V5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmV0O1xuICAgIH07XG5cbiAgICB2YXIgT2JqZWN0R2V0RGVzY3JpcHRvciA9IGZ1bmN0aW9uKG8sIGtleSkge1xuICAgICAgICByZXR1cm4ge3ZhbHVlOiBvW2tleV19O1xuICAgIH07XG5cbiAgICB2YXIgT2JqZWN0RGVmaW5lUHJvcGVydHkgPSBmdW5jdGlvbiAobywga2V5LCBkZXNjKSB7XG4gICAgICAgIG9ba2V5XSA9IGRlc2MudmFsdWU7XG4gICAgICAgIHJldHVybiBvO1xuICAgIH07XG5cbiAgICB2YXIgT2JqZWN0RnJlZXplID0gZnVuY3Rpb24gKG9iaikge1xuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH07XG5cbiAgICB2YXIgT2JqZWN0R2V0UHJvdG90eXBlT2YgPSBmdW5jdGlvbiAob2JqKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gT2JqZWN0KG9iaikuY29uc3RydWN0b3IucHJvdG90eXBlO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICByZXR1cm4gcHJvdG87XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgdmFyIEFycmF5SXNBcnJheSA9IGZ1bmN0aW9uIChvYmopIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybiBzdHIuY2FsbChvYmopID09PSBcIltvYmplY3QgQXJyYXldXCI7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2goZSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIG1vZHVsZS5leHBvcnRzID0ge1xuICAgICAgICBpc0FycmF5OiBBcnJheUlzQXJyYXksXG4gICAgICAgIGtleXM6IE9iamVjdEtleXMsXG4gICAgICAgIG5hbWVzOiBPYmplY3RLZXlzLFxuICAgICAgICBkZWZpbmVQcm9wZXJ0eTogT2JqZWN0RGVmaW5lUHJvcGVydHksXG4gICAgICAgIGdldERlc2NyaXB0b3I6IE9iamVjdEdldERlc2NyaXB0b3IsXG4gICAgICAgIGZyZWV6ZTogT2JqZWN0RnJlZXplLFxuICAgICAgICBnZXRQcm90b3R5cGVPZjogT2JqZWN0R2V0UHJvdG90eXBlT2YsXG4gICAgICAgIGlzRVM1OiBpc0VTNSxcbiAgICAgICAgcHJvcGVydHlJc1dyaXRhYmxlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgfTtcbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9ibHVlYmlyZC9qcy9yZWxlYXNlL2VzNS5qcyIsIid1c2Ugc3RyaWN0JztcblxuXG5mdW5jdGlvbiBpc05vdGhpbmcoc3ViamVjdCkge1xuICByZXR1cm4gKHR5cGVvZiBzdWJqZWN0ID09PSAndW5kZWZpbmVkJykgfHwgKHN1YmplY3QgPT09IG51bGwpO1xufVxuXG5cbmZ1bmN0aW9uIGlzT2JqZWN0KHN1YmplY3QpIHtcbiAgcmV0dXJuICh0eXBlb2Ygc3ViamVjdCA9PT0gJ29iamVjdCcpICYmIChzdWJqZWN0ICE9PSBudWxsKTtcbn1cblxuXG5mdW5jdGlvbiB0b0FycmF5KHNlcXVlbmNlKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KHNlcXVlbmNlKSkgcmV0dXJuIHNlcXVlbmNlO1xuICBlbHNlIGlmIChpc05vdGhpbmcoc2VxdWVuY2UpKSByZXR1cm4gW107XG5cbiAgcmV0dXJuIFsgc2VxdWVuY2UgXTtcbn1cblxuXG5mdW5jdGlvbiBleHRlbmQodGFyZ2V0LCBzb3VyY2UpIHtcbiAgdmFyIGluZGV4LCBsZW5ndGgsIGtleSwgc291cmNlS2V5cztcblxuICBpZiAoc291cmNlKSB7XG4gICAgc291cmNlS2V5cyA9IE9iamVjdC5rZXlzKHNvdXJjZSk7XG5cbiAgICBmb3IgKGluZGV4ID0gMCwgbGVuZ3RoID0gc291cmNlS2V5cy5sZW5ndGg7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCArPSAxKSB7XG4gICAgICBrZXkgPSBzb3VyY2VLZXlzW2luZGV4XTtcbiAgICAgIHRhcmdldFtrZXldID0gc291cmNlW2tleV07XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRhcmdldDtcbn1cblxuXG5mdW5jdGlvbiByZXBlYXQoc3RyaW5nLCBjb3VudCkge1xuICB2YXIgcmVzdWx0ID0gJycsIGN5Y2xlO1xuXG4gIGZvciAoY3ljbGUgPSAwOyBjeWNsZSA8IGNvdW50OyBjeWNsZSArPSAxKSB7XG4gICAgcmVzdWx0ICs9IHN0cmluZztcbiAgfVxuXG4gIHJldHVybiByZXN1bHQ7XG59XG5cblxuZnVuY3Rpb24gaXNOZWdhdGl2ZVplcm8obnVtYmVyKSB7XG4gIHJldHVybiAobnVtYmVyID09PSAwKSAmJiAoTnVtYmVyLk5FR0FUSVZFX0lORklOSVRZID09PSAxIC8gbnVtYmVyKTtcbn1cblxuXG5tb2R1bGUuZXhwb3J0cy5pc05vdGhpbmcgICAgICA9IGlzTm90aGluZztcbm1vZHVsZS5leHBvcnRzLmlzT2JqZWN0ICAgICAgID0gaXNPYmplY3Q7XG5tb2R1bGUuZXhwb3J0cy50b0FycmF5ICAgICAgICA9IHRvQXJyYXk7XG5tb2R1bGUuZXhwb3J0cy5yZXBlYXQgICAgICAgICA9IHJlcGVhdDtcbm1vZHVsZS5leHBvcnRzLmlzTmVnYXRpdmVaZXJvID0gaXNOZWdhdGl2ZVplcm87XG5tb2R1bGUuZXhwb3J0cy5leHRlbmQgICAgICAgICA9IGV4dGVuZDtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9qcy15YW1sL2xpYi9qcy15YW1sL2NvbW1vbi5qcyIsIid1c2Ugc3RyaWN0JztcblxuLyplc2xpbnQtZGlzYWJsZSBtYXgtbGVuKi9cblxudmFyIGNvbW1vbiAgICAgICAgPSByZXF1aXJlKCcuL2NvbW1vbicpO1xudmFyIFlBTUxFeGNlcHRpb24gPSByZXF1aXJlKCcuL2V4Y2VwdGlvbicpO1xudmFyIFR5cGUgICAgICAgICAgPSByZXF1aXJlKCcuL3R5cGUnKTtcblxuXG5mdW5jdGlvbiBjb21waWxlTGlzdChzY2hlbWEsIG5hbWUsIHJlc3VsdCkge1xuICB2YXIgZXhjbHVkZSA9IFtdO1xuXG4gIHNjaGVtYS5pbmNsdWRlLmZvckVhY2goZnVuY3Rpb24gKGluY2x1ZGVkU2NoZW1hKSB7XG4gICAgcmVzdWx0ID0gY29tcGlsZUxpc3QoaW5jbHVkZWRTY2hlbWEsIG5hbWUsIHJlc3VsdCk7XG4gIH0pO1xuXG4gIHNjaGVtYVtuYW1lXS5mb3JFYWNoKGZ1bmN0aW9uIChjdXJyZW50VHlwZSkge1xuICAgIHJlc3VsdC5mb3JFYWNoKGZ1bmN0aW9uIChwcmV2aW91c1R5cGUsIHByZXZpb3VzSW5kZXgpIHtcbiAgICAgIGlmIChwcmV2aW91c1R5cGUudGFnID09PSBjdXJyZW50VHlwZS50YWcgJiYgcHJldmlvdXNUeXBlLmtpbmQgPT09IGN1cnJlbnRUeXBlLmtpbmQpIHtcbiAgICAgICAgZXhjbHVkZS5wdXNoKHByZXZpb3VzSW5kZXgpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgcmVzdWx0LnB1c2goY3VycmVudFR5cGUpO1xuICB9KTtcblxuICByZXR1cm4gcmVzdWx0LmZpbHRlcihmdW5jdGlvbiAodHlwZSwgaW5kZXgpIHtcbiAgICByZXR1cm4gZXhjbHVkZS5pbmRleE9mKGluZGV4KSA9PT0gLTE7XG4gIH0pO1xufVxuXG5cbmZ1bmN0aW9uIGNvbXBpbGVNYXAoLyogbGlzdHMuLi4gKi8pIHtcbiAgdmFyIHJlc3VsdCA9IHtcbiAgICAgICAgc2NhbGFyOiB7fSxcbiAgICAgICAgc2VxdWVuY2U6IHt9LFxuICAgICAgICBtYXBwaW5nOiB7fSxcbiAgICAgICAgZmFsbGJhY2s6IHt9XG4gICAgICB9LCBpbmRleCwgbGVuZ3RoO1xuXG4gIGZ1bmN0aW9uIGNvbGxlY3RUeXBlKHR5cGUpIHtcbiAgICByZXN1bHRbdHlwZS5raW5kXVt0eXBlLnRhZ10gPSByZXN1bHRbJ2ZhbGxiYWNrJ11bdHlwZS50YWddID0gdHlwZTtcbiAgfVxuXG4gIGZvciAoaW5kZXggPSAwLCBsZW5ndGggPSBhcmd1bWVudHMubGVuZ3RoOyBpbmRleCA8IGxlbmd0aDsgaW5kZXggKz0gMSkge1xuICAgIGFyZ3VtZW50c1tpbmRleF0uZm9yRWFjaChjb2xsZWN0VHlwZSk7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuXG5mdW5jdGlvbiBTY2hlbWEoZGVmaW5pdGlvbikge1xuICB0aGlzLmluY2x1ZGUgID0gZGVmaW5pdGlvbi5pbmNsdWRlICB8fCBbXTtcbiAgdGhpcy5pbXBsaWNpdCA9IGRlZmluaXRpb24uaW1wbGljaXQgfHwgW107XG4gIHRoaXMuZXhwbGljaXQgPSBkZWZpbml0aW9uLmV4cGxpY2l0IHx8IFtdO1xuXG4gIHRoaXMuaW1wbGljaXQuZm9yRWFjaChmdW5jdGlvbiAodHlwZSkge1xuICAgIGlmICh0eXBlLmxvYWRLaW5kICYmIHR5cGUubG9hZEtpbmQgIT09ICdzY2FsYXInKSB7XG4gICAgICB0aHJvdyBuZXcgWUFNTEV4Y2VwdGlvbignVGhlcmUgaXMgYSBub24tc2NhbGFyIHR5cGUgaW4gdGhlIGltcGxpY2l0IGxpc3Qgb2YgYSBzY2hlbWEuIEltcGxpY2l0IHJlc29sdmluZyBvZiBzdWNoIHR5cGVzIGlzIG5vdCBzdXBwb3J0ZWQuJyk7XG4gICAgfVxuICB9KTtcblxuICB0aGlzLmNvbXBpbGVkSW1wbGljaXQgPSBjb21waWxlTGlzdCh0aGlzLCAnaW1wbGljaXQnLCBbXSk7XG4gIHRoaXMuY29tcGlsZWRFeHBsaWNpdCA9IGNvbXBpbGVMaXN0KHRoaXMsICdleHBsaWNpdCcsIFtdKTtcbiAgdGhpcy5jb21waWxlZFR5cGVNYXAgID0gY29tcGlsZU1hcCh0aGlzLmNvbXBpbGVkSW1wbGljaXQsIHRoaXMuY29tcGlsZWRFeHBsaWNpdCk7XG59XG5cblxuU2NoZW1hLkRFRkFVTFQgPSBudWxsO1xuXG5cblNjaGVtYS5jcmVhdGUgPSBmdW5jdGlvbiBjcmVhdGVTY2hlbWEoKSB7XG4gIHZhciBzY2hlbWFzLCB0eXBlcztcblxuICBzd2l0Y2ggKGFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICBjYXNlIDE6XG4gICAgICBzY2hlbWFzID0gU2NoZW1hLkRFRkFVTFQ7XG4gICAgICB0eXBlcyA9IGFyZ3VtZW50c1swXTtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSAyOlxuICAgICAgc2NoZW1hcyA9IGFyZ3VtZW50c1swXTtcbiAgICAgIHR5cGVzID0gYXJndW1lbnRzWzFdO1xuICAgICAgYnJlYWs7XG5cbiAgICBkZWZhdWx0OlxuICAgICAgdGhyb3cgbmV3IFlBTUxFeGNlcHRpb24oJ1dyb25nIG51bWJlciBvZiBhcmd1bWVudHMgZm9yIFNjaGVtYS5jcmVhdGUgZnVuY3Rpb24nKTtcbiAgfVxuXG4gIHNjaGVtYXMgPSBjb21tb24udG9BcnJheShzY2hlbWFzKTtcbiAgdHlwZXMgPSBjb21tb24udG9BcnJheSh0eXBlcyk7XG5cbiAgaWYgKCFzY2hlbWFzLmV2ZXJ5KGZ1bmN0aW9uIChzY2hlbWEpIHsgcmV0dXJuIHNjaGVtYSBpbnN0YW5jZW9mIFNjaGVtYTsgfSkpIHtcbiAgICB0aHJvdyBuZXcgWUFNTEV4Y2VwdGlvbignU3BlY2lmaWVkIGxpc3Qgb2Ygc3VwZXIgc2NoZW1hcyAob3IgYSBzaW5nbGUgU2NoZW1hIG9iamVjdCkgY29udGFpbnMgYSBub24tU2NoZW1hIG9iamVjdC4nKTtcbiAgfVxuXG4gIGlmICghdHlwZXMuZXZlcnkoZnVuY3Rpb24gKHR5cGUpIHsgcmV0dXJuIHR5cGUgaW5zdGFuY2VvZiBUeXBlOyB9KSkge1xuICAgIHRocm93IG5ldyBZQU1MRXhjZXB0aW9uKCdTcGVjaWZpZWQgbGlzdCBvZiBZQU1MIHR5cGVzIChvciBhIHNpbmdsZSBUeXBlIG9iamVjdCkgY29udGFpbnMgYSBub24tVHlwZSBvYmplY3QuJyk7XG4gIH1cblxuICByZXR1cm4gbmV3IFNjaGVtYSh7XG4gICAgaW5jbHVkZTogc2NoZW1hcyxcbiAgICBleHBsaWNpdDogdHlwZXNcbiAgfSk7XG59O1xuXG5cbm1vZHVsZS5leHBvcnRzID0gU2NoZW1hO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2pzLXlhbWwvbGliL2pzLXlhbWwvc2NoZW1hLmpzIiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwic3RyZWFtXCIpO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIGV4dGVybmFsIFwic3RyZWFtXCJcbi8vIG1vZHVsZSBpZCA9IDE5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcInVybFwiKTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyBleHRlcm5hbCBcInVybFwiXG4vLyBtb2R1bGUgaWQgPSAyMFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvLyBZQU1MIGVycm9yIGNsYXNzLiBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzg0NTg5ODRcbi8vXG4ndXNlIHN0cmljdCc7XG5cbmZ1bmN0aW9uIFlBTUxFeGNlcHRpb24ocmVhc29uLCBtYXJrKSB7XG4gIC8vIFN1cGVyIGNvbnN0cnVjdG9yXG4gIEVycm9yLmNhbGwodGhpcyk7XG5cbiAgdGhpcy5uYW1lID0gJ1lBTUxFeGNlcHRpb24nO1xuICB0aGlzLnJlYXNvbiA9IHJlYXNvbjtcbiAgdGhpcy5tYXJrID0gbWFyaztcbiAgdGhpcy5tZXNzYWdlID0gKHRoaXMucmVhc29uIHx8ICcodW5rbm93biByZWFzb24pJykgKyAodGhpcy5tYXJrID8gJyAnICsgdGhpcy5tYXJrLnRvU3RyaW5nKCkgOiAnJyk7XG5cbiAgLy8gSW5jbHVkZSBzdGFjayB0cmFjZSBpbiBlcnJvciBvYmplY3RcbiAgaWYgKEVycm9yLmNhcHR1cmVTdGFja1RyYWNlKSB7XG4gICAgLy8gQ2hyb21lIGFuZCBOb2RlSlNcbiAgICBFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSh0aGlzLCB0aGlzLmNvbnN0cnVjdG9yKTtcbiAgfSBlbHNlIHtcbiAgICAvLyBGRiwgSUUgMTArIGFuZCBTYWZhcmkgNisuIEZhbGxiYWNrIGZvciBvdGhlcnNcbiAgICB0aGlzLnN0YWNrID0gKG5ldyBFcnJvcigpKS5zdGFjayB8fCAnJztcbiAgfVxufVxuXG5cbi8vIEluaGVyaXQgZnJvbSBFcnJvclxuWUFNTEV4Y2VwdGlvbi5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKEVycm9yLnByb3RvdHlwZSk7XG5ZQU1MRXhjZXB0aW9uLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFlBTUxFeGNlcHRpb247XG5cblxuWUFNTEV4Y2VwdGlvbi5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZyhjb21wYWN0KSB7XG4gIHZhciByZXN1bHQgPSB0aGlzLm5hbWUgKyAnOiAnO1xuXG4gIHJlc3VsdCArPSB0aGlzLnJlYXNvbiB8fCAnKHVua25vd24gcmVhc29uKSc7XG5cbiAgaWYgKCFjb21wYWN0ICYmIHRoaXMubWFyaykge1xuICAgIHJlc3VsdCArPSAnICcgKyB0aGlzLm1hcmsudG9TdHJpbmcoKTtcbiAgfVxuXG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG5cbm1vZHVsZS5leHBvcnRzID0gWUFNTEV4Y2VwdGlvbjtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9qcy15YW1sL2xpYi9qcy15YW1sL2V4Y2VwdGlvbi5qcyIsIi8vIEpTLVlBTUwncyBkZWZhdWx0IHNjaGVtYSBmb3IgYHNhZmVMb2FkYCBmdW5jdGlvbi5cbi8vIEl0IGlzIG5vdCBkZXNjcmliZWQgaW4gdGhlIFlBTUwgc3BlY2lmaWNhdGlvbi5cbi8vXG4vLyBUaGlzIHNjaGVtYSBpcyBiYXNlZCBvbiBzdGFuZGFyZCBZQU1MJ3MgQ29yZSBzY2hlbWEgYW5kIGluY2x1ZGVzIG1vc3Qgb2Zcbi8vIGV4dHJhIHR5cGVzIGRlc2NyaWJlZCBhdCBZQU1MIHRhZyByZXBvc2l0b3J5LiAoaHR0cDovL3lhbWwub3JnL3R5cGUvKVxuXG5cbid1c2Ugc3RyaWN0JztcblxuXG52YXIgU2NoZW1hID0gcmVxdWlyZSgnLi4vc2NoZW1hJyk7XG5cblxubW9kdWxlLmV4cG9ydHMgPSBuZXcgU2NoZW1hKHtcbiAgaW5jbHVkZTogW1xuICAgIHJlcXVpcmUoJy4vY29yZScpXG4gIF0sXG4gIGltcGxpY2l0OiBbXG4gICAgcmVxdWlyZSgnLi4vdHlwZS90aW1lc3RhbXAnKSxcbiAgICByZXF1aXJlKCcuLi90eXBlL21lcmdlJylcbiAgXSxcbiAgZXhwbGljaXQ6IFtcbiAgICByZXF1aXJlKCcuLi90eXBlL2JpbmFyeScpLFxuICAgIHJlcXVpcmUoJy4uL3R5cGUvb21hcCcpLFxuICAgIHJlcXVpcmUoJy4uL3R5cGUvcGFpcnMnKSxcbiAgICByZXF1aXJlKCcuLi90eXBlL3NldCcpXG4gIF1cbn0pO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2pzLXlhbWwvbGliL2pzLXlhbWwvc2NoZW1hL2RlZmF1bHRfc2FmZS5qcyIsIi8qIC0qLSBNb2RlOiBqczsganMtaW5kZW50LWxldmVsOiAyOyAtKi0gKi9cbi8qXG4gKiBDb3B5cmlnaHQgMjAxMSBNb3ppbGxhIEZvdW5kYXRpb24gYW5kIGNvbnRyaWJ1dG9yc1xuICogTGljZW5zZWQgdW5kZXIgdGhlIE5ldyBCU0QgbGljZW5zZS4gU2VlIExJQ0VOU0Ugb3I6XG4gKiBodHRwOi8vb3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvQlNELTMtQ2xhdXNlXG4gKi9cblxuLyoqXG4gKiBUaGlzIGlzIGEgaGVscGVyIGZ1bmN0aW9uIGZvciBnZXR0aW5nIHZhbHVlcyBmcm9tIHBhcmFtZXRlci9vcHRpb25zXG4gKiBvYmplY3RzLlxuICpcbiAqIEBwYXJhbSBhcmdzIFRoZSBvYmplY3Qgd2UgYXJlIGV4dHJhY3RpbmcgdmFsdWVzIGZyb21cbiAqIEBwYXJhbSBuYW1lIFRoZSBuYW1lIG9mIHRoZSBwcm9wZXJ0eSB3ZSBhcmUgZ2V0dGluZy5cbiAqIEBwYXJhbSBkZWZhdWx0VmFsdWUgQW4gb3B0aW9uYWwgdmFsdWUgdG8gcmV0dXJuIGlmIHRoZSBwcm9wZXJ0eSBpcyBtaXNzaW5nXG4gKiBmcm9tIHRoZSBvYmplY3QuIElmIHRoaXMgaXMgbm90IHNwZWNpZmllZCBhbmQgdGhlIHByb3BlcnR5IGlzIG1pc3NpbmcsIGFuXG4gKiBlcnJvciB3aWxsIGJlIHRocm93bi5cbiAqL1xuZnVuY3Rpb24gZ2V0QXJnKGFBcmdzLCBhTmFtZSwgYURlZmF1bHRWYWx1ZSkge1xuICBpZiAoYU5hbWUgaW4gYUFyZ3MpIHtcbiAgICByZXR1cm4gYUFyZ3NbYU5hbWVdO1xuICB9IGVsc2UgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDMpIHtcbiAgICByZXR1cm4gYURlZmF1bHRWYWx1ZTtcbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1wiJyArIGFOYW1lICsgJ1wiIGlzIGEgcmVxdWlyZWQgYXJndW1lbnQuJyk7XG4gIH1cbn1cbmV4cG9ydHMuZ2V0QXJnID0gZ2V0QXJnO1xuXG52YXIgdXJsUmVnZXhwID0gL14oPzooW1xcdytcXC0uXSspOik/XFwvXFwvKD86KFxcdys6XFx3KylAKT8oW1xcdy4tXSopKD86OihcXGQrKSk/KC4qKSQvO1xudmFyIGRhdGFVcmxSZWdleHAgPSAvXmRhdGE6LitcXCwuKyQvO1xuXG5mdW5jdGlvbiB1cmxQYXJzZShhVXJsKSB7XG4gIHZhciBtYXRjaCA9IGFVcmwubWF0Y2godXJsUmVnZXhwKTtcbiAgaWYgKCFtYXRjaCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIHJldHVybiB7XG4gICAgc2NoZW1lOiBtYXRjaFsxXSxcbiAgICBhdXRoOiBtYXRjaFsyXSxcbiAgICBob3N0OiBtYXRjaFszXSxcbiAgICBwb3J0OiBtYXRjaFs0XSxcbiAgICBwYXRoOiBtYXRjaFs1XVxuICB9O1xufVxuZXhwb3J0cy51cmxQYXJzZSA9IHVybFBhcnNlO1xuXG5mdW5jdGlvbiB1cmxHZW5lcmF0ZShhUGFyc2VkVXJsKSB7XG4gIHZhciB1cmwgPSAnJztcbiAgaWYgKGFQYXJzZWRVcmwuc2NoZW1lKSB7XG4gICAgdXJsICs9IGFQYXJzZWRVcmwuc2NoZW1lICsgJzonO1xuICB9XG4gIHVybCArPSAnLy8nO1xuICBpZiAoYVBhcnNlZFVybC5hdXRoKSB7XG4gICAgdXJsICs9IGFQYXJzZWRVcmwuYXV0aCArICdAJztcbiAgfVxuICBpZiAoYVBhcnNlZFVybC5ob3N0KSB7XG4gICAgdXJsICs9IGFQYXJzZWRVcmwuaG9zdDtcbiAgfVxuICBpZiAoYVBhcnNlZFVybC5wb3J0KSB7XG4gICAgdXJsICs9IFwiOlwiICsgYVBhcnNlZFVybC5wb3J0XG4gIH1cbiAgaWYgKGFQYXJzZWRVcmwucGF0aCkge1xuICAgIHVybCArPSBhUGFyc2VkVXJsLnBhdGg7XG4gIH1cbiAgcmV0dXJuIHVybDtcbn1cbmV4cG9ydHMudXJsR2VuZXJhdGUgPSB1cmxHZW5lcmF0ZTtcblxuLyoqXG4gKiBOb3JtYWxpemVzIGEgcGF0aCwgb3IgdGhlIHBhdGggcG9ydGlvbiBvZiBhIFVSTDpcbiAqXG4gKiAtIFJlcGxhY2VzIGNvbnNlY3V0aXZlIHNsYXNoZXMgd2l0aCBvbmUgc2xhc2guXG4gKiAtIFJlbW92ZXMgdW5uZWNlc3NhcnkgJy4nIHBhcnRzLlxuICogLSBSZW1vdmVzIHVubmVjZXNzYXJ5ICc8ZGlyPi8uLicgcGFydHMuXG4gKlxuICogQmFzZWQgb24gY29kZSBpbiB0aGUgTm9kZS5qcyAncGF0aCcgY29yZSBtb2R1bGUuXG4gKlxuICogQHBhcmFtIGFQYXRoIFRoZSBwYXRoIG9yIHVybCB0byBub3JtYWxpemUuXG4gKi9cbmZ1bmN0aW9uIG5vcm1hbGl6ZShhUGF0aCkge1xuICB2YXIgcGF0aCA9IGFQYXRoO1xuICB2YXIgdXJsID0gdXJsUGFyc2UoYVBhdGgpO1xuICBpZiAodXJsKSB7XG4gICAgaWYgKCF1cmwucGF0aCkge1xuICAgICAgcmV0dXJuIGFQYXRoO1xuICAgIH1cbiAgICBwYXRoID0gdXJsLnBhdGg7XG4gIH1cbiAgdmFyIGlzQWJzb2x1dGUgPSBleHBvcnRzLmlzQWJzb2x1dGUocGF0aCk7XG5cbiAgdmFyIHBhcnRzID0gcGF0aC5zcGxpdCgvXFwvKy8pO1xuICBmb3IgKHZhciBwYXJ0LCB1cCA9IDAsIGkgPSBwYXJ0cy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgIHBhcnQgPSBwYXJ0c1tpXTtcbiAgICBpZiAocGFydCA9PT0gJy4nKSB7XG4gICAgICBwYXJ0cy5zcGxpY2UoaSwgMSk7XG4gICAgfSBlbHNlIGlmIChwYXJ0ID09PSAnLi4nKSB7XG4gICAgICB1cCsrO1xuICAgIH0gZWxzZSBpZiAodXAgPiAwKSB7XG4gICAgICBpZiAocGFydCA9PT0gJycpIHtcbiAgICAgICAgLy8gVGhlIGZpcnN0IHBhcnQgaXMgYmxhbmsgaWYgdGhlIHBhdGggaXMgYWJzb2x1dGUuIFRyeWluZyB0byBnb1xuICAgICAgICAvLyBhYm92ZSB0aGUgcm9vdCBpcyBhIG5vLW9wLiBUaGVyZWZvcmUgd2UgY2FuIHJlbW92ZSBhbGwgJy4uJyBwYXJ0c1xuICAgICAgICAvLyBkaXJlY3RseSBhZnRlciB0aGUgcm9vdC5cbiAgICAgICAgcGFydHMuc3BsaWNlKGkgKyAxLCB1cCk7XG4gICAgICAgIHVwID0gMDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHBhcnRzLnNwbGljZShpLCAyKTtcbiAgICAgICAgdXAtLTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcGF0aCA9IHBhcnRzLmpvaW4oJy8nKTtcblxuICBpZiAocGF0aCA9PT0gJycpIHtcbiAgICBwYXRoID0gaXNBYnNvbHV0ZSA/ICcvJyA6ICcuJztcbiAgfVxuXG4gIGlmICh1cmwpIHtcbiAgICB1cmwucGF0aCA9IHBhdGg7XG4gICAgcmV0dXJuIHVybEdlbmVyYXRlKHVybCk7XG4gIH1cbiAgcmV0dXJuIHBhdGg7XG59XG5leHBvcnRzLm5vcm1hbGl6ZSA9IG5vcm1hbGl6ZTtcblxuLyoqXG4gKiBKb2lucyB0d28gcGF0aHMvVVJMcy5cbiAqXG4gKiBAcGFyYW0gYVJvb3QgVGhlIHJvb3QgcGF0aCBvciBVUkwuXG4gKiBAcGFyYW0gYVBhdGggVGhlIHBhdGggb3IgVVJMIHRvIGJlIGpvaW5lZCB3aXRoIHRoZSByb290LlxuICpcbiAqIC0gSWYgYVBhdGggaXMgYSBVUkwgb3IgYSBkYXRhIFVSSSwgYVBhdGggaXMgcmV0dXJuZWQsIHVubGVzcyBhUGF0aCBpcyBhXG4gKiAgIHNjaGVtZS1yZWxhdGl2ZSBVUkw6IFRoZW4gdGhlIHNjaGVtZSBvZiBhUm9vdCwgaWYgYW55LCBpcyBwcmVwZW5kZWRcbiAqICAgZmlyc3QuXG4gKiAtIE90aGVyd2lzZSBhUGF0aCBpcyBhIHBhdGguIElmIGFSb290IGlzIGEgVVJMLCB0aGVuIGl0cyBwYXRoIHBvcnRpb25cbiAqICAgaXMgdXBkYXRlZCB3aXRoIHRoZSByZXN1bHQgYW5kIGFSb290IGlzIHJldHVybmVkLiBPdGhlcndpc2UgdGhlIHJlc3VsdFxuICogICBpcyByZXR1cm5lZC5cbiAqICAgLSBJZiBhUGF0aCBpcyBhYnNvbHV0ZSwgdGhlIHJlc3VsdCBpcyBhUGF0aC5cbiAqICAgLSBPdGhlcndpc2UgdGhlIHR3byBwYXRocyBhcmUgam9pbmVkIHdpdGggYSBzbGFzaC5cbiAqIC0gSm9pbmluZyBmb3IgZXhhbXBsZSAnaHR0cDovLycgYW5kICd3d3cuZXhhbXBsZS5jb20nIGlzIGFsc28gc3VwcG9ydGVkLlxuICovXG5mdW5jdGlvbiBqb2luKGFSb290LCBhUGF0aCkge1xuICBpZiAoYVJvb3QgPT09IFwiXCIpIHtcbiAgICBhUm9vdCA9IFwiLlwiO1xuICB9XG4gIGlmIChhUGF0aCA9PT0gXCJcIikge1xuICAgIGFQYXRoID0gXCIuXCI7XG4gIH1cbiAgdmFyIGFQYXRoVXJsID0gdXJsUGFyc2UoYVBhdGgpO1xuICB2YXIgYVJvb3RVcmwgPSB1cmxQYXJzZShhUm9vdCk7XG4gIGlmIChhUm9vdFVybCkge1xuICAgIGFSb290ID0gYVJvb3RVcmwucGF0aCB8fCAnLyc7XG4gIH1cblxuICAvLyBgam9pbihmb28sICcvL3d3dy5leGFtcGxlLm9yZycpYFxuICBpZiAoYVBhdGhVcmwgJiYgIWFQYXRoVXJsLnNjaGVtZSkge1xuICAgIGlmIChhUm9vdFVybCkge1xuICAgICAgYVBhdGhVcmwuc2NoZW1lID0gYVJvb3RVcmwuc2NoZW1lO1xuICAgIH1cbiAgICByZXR1cm4gdXJsR2VuZXJhdGUoYVBhdGhVcmwpO1xuICB9XG5cbiAgaWYgKGFQYXRoVXJsIHx8IGFQYXRoLm1hdGNoKGRhdGFVcmxSZWdleHApKSB7XG4gICAgcmV0dXJuIGFQYXRoO1xuICB9XG5cbiAgLy8gYGpvaW4oJ2h0dHA6Ly8nLCAnd3d3LmV4YW1wbGUuY29tJylgXG4gIGlmIChhUm9vdFVybCAmJiAhYVJvb3RVcmwuaG9zdCAmJiAhYVJvb3RVcmwucGF0aCkge1xuICAgIGFSb290VXJsLmhvc3QgPSBhUGF0aDtcbiAgICByZXR1cm4gdXJsR2VuZXJhdGUoYVJvb3RVcmwpO1xuICB9XG5cbiAgdmFyIGpvaW5lZCA9IGFQYXRoLmNoYXJBdCgwKSA9PT0gJy8nXG4gICAgPyBhUGF0aFxuICAgIDogbm9ybWFsaXplKGFSb290LnJlcGxhY2UoL1xcLyskLywgJycpICsgJy8nICsgYVBhdGgpO1xuXG4gIGlmIChhUm9vdFVybCkge1xuICAgIGFSb290VXJsLnBhdGggPSBqb2luZWQ7XG4gICAgcmV0dXJuIHVybEdlbmVyYXRlKGFSb290VXJsKTtcbiAgfVxuICByZXR1cm4gam9pbmVkO1xufVxuZXhwb3J0cy5qb2luID0gam9pbjtcblxuZXhwb3J0cy5pc0Fic29sdXRlID0gZnVuY3Rpb24gKGFQYXRoKSB7XG4gIHJldHVybiBhUGF0aC5jaGFyQXQoMCkgPT09ICcvJyB8fCB1cmxSZWdleHAudGVzdChhUGF0aCk7XG59O1xuXG4vKipcbiAqIE1ha2UgYSBwYXRoIHJlbGF0aXZlIHRvIGEgVVJMIG9yIGFub3RoZXIgcGF0aC5cbiAqXG4gKiBAcGFyYW0gYVJvb3QgVGhlIHJvb3QgcGF0aCBvciBVUkwuXG4gKiBAcGFyYW0gYVBhdGggVGhlIHBhdGggb3IgVVJMIHRvIGJlIG1hZGUgcmVsYXRpdmUgdG8gYVJvb3QuXG4gKi9cbmZ1bmN0aW9uIHJlbGF0aXZlKGFSb290LCBhUGF0aCkge1xuICBpZiAoYVJvb3QgPT09IFwiXCIpIHtcbiAgICBhUm9vdCA9IFwiLlwiO1xuICB9XG5cbiAgYVJvb3QgPSBhUm9vdC5yZXBsYWNlKC9cXC8kLywgJycpO1xuXG4gIC8vIEl0IGlzIHBvc3NpYmxlIGZvciB0aGUgcGF0aCB0byBiZSBhYm92ZSB0aGUgcm9vdC4gSW4gdGhpcyBjYXNlLCBzaW1wbHlcbiAgLy8gY2hlY2tpbmcgd2hldGhlciB0aGUgcm9vdCBpcyBhIHByZWZpeCBvZiB0aGUgcGF0aCB3b24ndCB3b3JrLiBJbnN0ZWFkLCB3ZVxuICAvLyBuZWVkIHRvIHJlbW92ZSBjb21wb25lbnRzIGZyb20gdGhlIHJvb3Qgb25lIGJ5IG9uZSwgdW50aWwgZWl0aGVyIHdlIGZpbmRcbiAgLy8gYSBwcmVmaXggdGhhdCBmaXRzLCBvciB3ZSBydW4gb3V0IG9mIGNvbXBvbmVudHMgdG8gcmVtb3ZlLlxuICB2YXIgbGV2ZWwgPSAwO1xuICB3aGlsZSAoYVBhdGguaW5kZXhPZihhUm9vdCArICcvJykgIT09IDApIHtcbiAgICB2YXIgaW5kZXggPSBhUm9vdC5sYXN0SW5kZXhPZihcIi9cIik7XG4gICAgaWYgKGluZGV4IDwgMCkge1xuICAgICAgcmV0dXJuIGFQYXRoO1xuICAgIH1cblxuICAgIC8vIElmIHRoZSBvbmx5IHBhcnQgb2YgdGhlIHJvb3QgdGhhdCBpcyBsZWZ0IGlzIHRoZSBzY2hlbWUgKGkuZS4gaHR0cDovLyxcbiAgICAvLyBmaWxlOi8vLywgZXRjLiksIG9uZSBvciBtb3JlIHNsYXNoZXMgKC8pLCBvciBzaW1wbHkgbm90aGluZyBhdCBhbGwsIHdlXG4gICAgLy8gaGF2ZSBleGhhdXN0ZWQgYWxsIGNvbXBvbmVudHMsIHNvIHRoZSBwYXRoIGlzIG5vdCByZWxhdGl2ZSB0byB0aGUgcm9vdC5cbiAgICBhUm9vdCA9IGFSb290LnNsaWNlKDAsIGluZGV4KTtcbiAgICBpZiAoYVJvb3QubWF0Y2goL14oW15cXC9dKzpcXC8pP1xcLyokLykpIHtcbiAgICAgIHJldHVybiBhUGF0aDtcbiAgICB9XG5cbiAgICArK2xldmVsO1xuICB9XG5cbiAgLy8gTWFrZSBzdXJlIHdlIGFkZCBhIFwiLi4vXCIgZm9yIGVhY2ggY29tcG9uZW50IHdlIHJlbW92ZWQgZnJvbSB0aGUgcm9vdC5cbiAgcmV0dXJuIEFycmF5KGxldmVsICsgMSkuam9pbihcIi4uL1wiKSArIGFQYXRoLnN1YnN0cihhUm9vdC5sZW5ndGggKyAxKTtcbn1cbmV4cG9ydHMucmVsYXRpdmUgPSByZWxhdGl2ZTtcblxudmFyIHN1cHBvcnRzTnVsbFByb3RvID0gKGZ1bmN0aW9uICgpIHtcbiAgdmFyIG9iaiA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIHJldHVybiAhKCdfX3Byb3RvX18nIGluIG9iaik7XG59KCkpO1xuXG5mdW5jdGlvbiBpZGVudGl0eSAocykge1xuICByZXR1cm4gcztcbn1cblxuLyoqXG4gKiBCZWNhdXNlIGJlaGF2aW9yIGdvZXMgd2Fja3kgd2hlbiB5b3Ugc2V0IGBfX3Byb3RvX19gIG9uIG9iamVjdHMsIHdlXG4gKiBoYXZlIHRvIHByZWZpeCBhbGwgdGhlIHN0cmluZ3MgaW4gb3VyIHNldCB3aXRoIGFuIGFyYml0cmFyeSBjaGFyYWN0ZXIuXG4gKlxuICogU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9tb3ppbGxhL3NvdXJjZS1tYXAvcHVsbC8zMSBhbmRcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9tb3ppbGxhL3NvdXJjZS1tYXAvaXNzdWVzLzMwXG4gKlxuICogQHBhcmFtIFN0cmluZyBhU3RyXG4gKi9cbmZ1bmN0aW9uIHRvU2V0U3RyaW5nKGFTdHIpIHtcbiAgaWYgKGlzUHJvdG9TdHJpbmcoYVN0cikpIHtcbiAgICByZXR1cm4gJyQnICsgYVN0cjtcbiAgfVxuXG4gIHJldHVybiBhU3RyO1xufVxuZXhwb3J0cy50b1NldFN0cmluZyA9IHN1cHBvcnRzTnVsbFByb3RvID8gaWRlbnRpdHkgOiB0b1NldFN0cmluZztcblxuZnVuY3Rpb24gZnJvbVNldFN0cmluZyhhU3RyKSB7XG4gIGlmIChpc1Byb3RvU3RyaW5nKGFTdHIpKSB7XG4gICAgcmV0dXJuIGFTdHIuc2xpY2UoMSk7XG4gIH1cblxuICByZXR1cm4gYVN0cjtcbn1cbmV4cG9ydHMuZnJvbVNldFN0cmluZyA9IHN1cHBvcnRzTnVsbFByb3RvID8gaWRlbnRpdHkgOiBmcm9tU2V0U3RyaW5nO1xuXG5mdW5jdGlvbiBpc1Byb3RvU3RyaW5nKHMpIHtcbiAgaWYgKCFzKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgdmFyIGxlbmd0aCA9IHMubGVuZ3RoO1xuXG4gIGlmIChsZW5ndGggPCA5IC8qIFwiX19wcm90b19fXCIubGVuZ3RoICovKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgaWYgKHMuY2hhckNvZGVBdChsZW5ndGggLSAxKSAhPT0gOTUgIC8qICdfJyAqLyB8fFxuICAgICAgcy5jaGFyQ29kZUF0KGxlbmd0aCAtIDIpICE9PSA5NSAgLyogJ18nICovIHx8XG4gICAgICBzLmNoYXJDb2RlQXQobGVuZ3RoIC0gMykgIT09IDExMSAvKiAnbycgKi8gfHxcbiAgICAgIHMuY2hhckNvZGVBdChsZW5ndGggLSA0KSAhPT0gMTE2IC8qICd0JyAqLyB8fFxuICAgICAgcy5jaGFyQ29kZUF0KGxlbmd0aCAtIDUpICE9PSAxMTEgLyogJ28nICovIHx8XG4gICAgICBzLmNoYXJDb2RlQXQobGVuZ3RoIC0gNikgIT09IDExNCAvKiAncicgKi8gfHxcbiAgICAgIHMuY2hhckNvZGVBdChsZW5ndGggLSA3KSAhPT0gMTEyIC8qICdwJyAqLyB8fFxuICAgICAgcy5jaGFyQ29kZUF0KGxlbmd0aCAtIDgpICE9PSA5NSAgLyogJ18nICovIHx8XG4gICAgICBzLmNoYXJDb2RlQXQobGVuZ3RoIC0gOSkgIT09IDk1ICAvKiAnXycgKi8pIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBmb3IgKHZhciBpID0gbGVuZ3RoIC0gMTA7IGkgPj0gMDsgaS0tKSB7XG4gICAgaWYgKHMuY2hhckNvZGVBdChpKSAhPT0gMzYgLyogJyQnICovKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59XG5cbi8qKlxuICogQ29tcGFyYXRvciBiZXR3ZWVuIHR3byBtYXBwaW5ncyB3aGVyZSB0aGUgb3JpZ2luYWwgcG9zaXRpb25zIGFyZSBjb21wYXJlZC5cbiAqXG4gKiBPcHRpb25hbGx5IHBhc3MgaW4gYHRydWVgIGFzIGBvbmx5Q29tcGFyZUdlbmVyYXRlZGAgdG8gY29uc2lkZXIgdHdvXG4gKiBtYXBwaW5ncyB3aXRoIHRoZSBzYW1lIG9yaWdpbmFsIHNvdXJjZS9saW5lL2NvbHVtbiwgYnV0IGRpZmZlcmVudCBnZW5lcmF0ZWRcbiAqIGxpbmUgYW5kIGNvbHVtbiB0aGUgc2FtZS4gVXNlZnVsIHdoZW4gc2VhcmNoaW5nIGZvciBhIG1hcHBpbmcgd2l0aCBhXG4gKiBzdHViYmVkIG91dCBtYXBwaW5nLlxuICovXG5mdW5jdGlvbiBjb21wYXJlQnlPcmlnaW5hbFBvc2l0aW9ucyhtYXBwaW5nQSwgbWFwcGluZ0IsIG9ubHlDb21wYXJlT3JpZ2luYWwpIHtcbiAgdmFyIGNtcCA9IHN0cmNtcChtYXBwaW5nQS5zb3VyY2UsIG1hcHBpbmdCLnNvdXJjZSk7XG4gIGlmIChjbXAgIT09IDApIHtcbiAgICByZXR1cm4gY21wO1xuICB9XG5cbiAgY21wID0gbWFwcGluZ0Eub3JpZ2luYWxMaW5lIC0gbWFwcGluZ0Iub3JpZ2luYWxMaW5lO1xuICBpZiAoY21wICE9PSAwKSB7XG4gICAgcmV0dXJuIGNtcDtcbiAgfVxuXG4gIGNtcCA9IG1hcHBpbmdBLm9yaWdpbmFsQ29sdW1uIC0gbWFwcGluZ0Iub3JpZ2luYWxDb2x1bW47XG4gIGlmIChjbXAgIT09IDAgfHwgb25seUNvbXBhcmVPcmlnaW5hbCkge1xuICAgIHJldHVybiBjbXA7XG4gIH1cblxuICBjbXAgPSBtYXBwaW5nQS5nZW5lcmF0ZWRDb2x1bW4gLSBtYXBwaW5nQi5nZW5lcmF0ZWRDb2x1bW47XG4gIGlmIChjbXAgIT09IDApIHtcbiAgICByZXR1cm4gY21wO1xuICB9XG5cbiAgY21wID0gbWFwcGluZ0EuZ2VuZXJhdGVkTGluZSAtIG1hcHBpbmdCLmdlbmVyYXRlZExpbmU7XG4gIGlmIChjbXAgIT09IDApIHtcbiAgICByZXR1cm4gY21wO1xuICB9XG5cbiAgcmV0dXJuIHN0cmNtcChtYXBwaW5nQS5uYW1lLCBtYXBwaW5nQi5uYW1lKTtcbn1cbmV4cG9ydHMuY29tcGFyZUJ5T3JpZ2luYWxQb3NpdGlvbnMgPSBjb21wYXJlQnlPcmlnaW5hbFBvc2l0aW9ucztcblxuLyoqXG4gKiBDb21wYXJhdG9yIGJldHdlZW4gdHdvIG1hcHBpbmdzIHdpdGggZGVmbGF0ZWQgc291cmNlIGFuZCBuYW1lIGluZGljZXMgd2hlcmVcbiAqIHRoZSBnZW5lcmF0ZWQgcG9zaXRpb25zIGFyZSBjb21wYXJlZC5cbiAqXG4gKiBPcHRpb25hbGx5IHBhc3MgaW4gYHRydWVgIGFzIGBvbmx5Q29tcGFyZUdlbmVyYXRlZGAgdG8gY29uc2lkZXIgdHdvXG4gKiBtYXBwaW5ncyB3aXRoIHRoZSBzYW1lIGdlbmVyYXRlZCBsaW5lIGFuZCBjb2x1bW4sIGJ1dCBkaWZmZXJlbnRcbiAqIHNvdXJjZS9uYW1lL29yaWdpbmFsIGxpbmUgYW5kIGNvbHVtbiB0aGUgc2FtZS4gVXNlZnVsIHdoZW4gc2VhcmNoaW5nIGZvciBhXG4gKiBtYXBwaW5nIHdpdGggYSBzdHViYmVkIG91dCBtYXBwaW5nLlxuICovXG5mdW5jdGlvbiBjb21wYXJlQnlHZW5lcmF0ZWRQb3NpdGlvbnNEZWZsYXRlZChtYXBwaW5nQSwgbWFwcGluZ0IsIG9ubHlDb21wYXJlR2VuZXJhdGVkKSB7XG4gIHZhciBjbXAgPSBtYXBwaW5nQS5nZW5lcmF0ZWRMaW5lIC0gbWFwcGluZ0IuZ2VuZXJhdGVkTGluZTtcbiAgaWYgKGNtcCAhPT0gMCkge1xuICAgIHJldHVybiBjbXA7XG4gIH1cblxuICBjbXAgPSBtYXBwaW5nQS5nZW5lcmF0ZWRDb2x1bW4gLSBtYXBwaW5nQi5nZW5lcmF0ZWRDb2x1bW47XG4gIGlmIChjbXAgIT09IDAgfHwgb25seUNvbXBhcmVHZW5lcmF0ZWQpIHtcbiAgICByZXR1cm4gY21wO1xuICB9XG5cbiAgY21wID0gc3RyY21wKG1hcHBpbmdBLnNvdXJjZSwgbWFwcGluZ0Iuc291cmNlKTtcbiAgaWYgKGNtcCAhPT0gMCkge1xuICAgIHJldHVybiBjbXA7XG4gIH1cblxuICBjbXAgPSBtYXBwaW5nQS5vcmlnaW5hbExpbmUgLSBtYXBwaW5nQi5vcmlnaW5hbExpbmU7XG4gIGlmIChjbXAgIT09IDApIHtcbiAgICByZXR1cm4gY21wO1xuICB9XG5cbiAgY21wID0gbWFwcGluZ0Eub3JpZ2luYWxDb2x1bW4gLSBtYXBwaW5nQi5vcmlnaW5hbENvbHVtbjtcbiAgaWYgKGNtcCAhPT0gMCkge1xuICAgIHJldHVybiBjbXA7XG4gIH1cblxuICByZXR1cm4gc3RyY21wKG1hcHBpbmdBLm5hbWUsIG1hcHBpbmdCLm5hbWUpO1xufVxuZXhwb3J0cy5jb21wYXJlQnlHZW5lcmF0ZWRQb3NpdGlvbnNEZWZsYXRlZCA9IGNvbXBhcmVCeUdlbmVyYXRlZFBvc2l0aW9uc0RlZmxhdGVkO1xuXG5mdW5jdGlvbiBzdHJjbXAoYVN0cjEsIGFTdHIyKSB7XG4gIGlmIChhU3RyMSA9PT0gYVN0cjIpIHtcbiAgICByZXR1cm4gMDtcbiAgfVxuXG4gIGlmIChhU3RyMSA9PT0gbnVsbCkge1xuICAgIHJldHVybiAxOyAvLyBhU3RyMiAhPT0gbnVsbFxuICB9XG5cbiAgaWYgKGFTdHIyID09PSBudWxsKSB7XG4gICAgcmV0dXJuIC0xOyAvLyBhU3RyMSAhPT0gbnVsbFxuICB9XG5cbiAgaWYgKGFTdHIxID4gYVN0cjIpIHtcbiAgICByZXR1cm4gMTtcbiAgfVxuXG4gIHJldHVybiAtMTtcbn1cblxuLyoqXG4gKiBDb21wYXJhdG9yIGJldHdlZW4gdHdvIG1hcHBpbmdzIHdpdGggaW5mbGF0ZWQgc291cmNlIGFuZCBuYW1lIHN0cmluZ3Mgd2hlcmVcbiAqIHRoZSBnZW5lcmF0ZWQgcG9zaXRpb25zIGFyZSBjb21wYXJlZC5cbiAqL1xuZnVuY3Rpb24gY29tcGFyZUJ5R2VuZXJhdGVkUG9zaXRpb25zSW5mbGF0ZWQobWFwcGluZ0EsIG1hcHBpbmdCKSB7XG4gIHZhciBjbXAgPSBtYXBwaW5nQS5nZW5lcmF0ZWRMaW5lIC0gbWFwcGluZ0IuZ2VuZXJhdGVkTGluZTtcbiAgaWYgKGNtcCAhPT0gMCkge1xuICAgIHJldHVybiBjbXA7XG4gIH1cblxuICBjbXAgPSBtYXBwaW5nQS5nZW5lcmF0ZWRDb2x1bW4gLSBtYXBwaW5nQi5nZW5lcmF0ZWRDb2x1bW47XG4gIGlmIChjbXAgIT09IDApIHtcbiAgICByZXR1cm4gY21wO1xuICB9XG5cbiAgY21wID0gc3RyY21wKG1hcHBpbmdBLnNvdXJjZSwgbWFwcGluZ0Iuc291cmNlKTtcbiAgaWYgKGNtcCAhPT0gMCkge1xuICAgIHJldHVybiBjbXA7XG4gIH1cblxuICBjbXAgPSBtYXBwaW5nQS5vcmlnaW5hbExpbmUgLSBtYXBwaW5nQi5vcmlnaW5hbExpbmU7XG4gIGlmIChjbXAgIT09IDApIHtcbiAgICByZXR1cm4gY21wO1xuICB9XG5cbiAgY21wID0gbWFwcGluZ0Eub3JpZ2luYWxDb2x1bW4gLSBtYXBwaW5nQi5vcmlnaW5hbENvbHVtbjtcbiAgaWYgKGNtcCAhPT0gMCkge1xuICAgIHJldHVybiBjbXA7XG4gIH1cblxuICByZXR1cm4gc3RyY21wKG1hcHBpbmdBLm5hbWUsIG1hcHBpbmdCLm5hbWUpO1xufVxuZXhwb3J0cy5jb21wYXJlQnlHZW5lcmF0ZWRQb3NpdGlvbnNJbmZsYXRlZCA9IGNvbXBhcmVCeUdlbmVyYXRlZFBvc2l0aW9uc0luZmxhdGVkO1xuXG4vKipcbiAqIFN0cmlwIGFueSBKU09OIFhTU0kgYXZvaWRhbmNlIHByZWZpeCBmcm9tIHRoZSBzdHJpbmcgKGFzIGRvY3VtZW50ZWRcbiAqIGluIHRoZSBzb3VyY2UgbWFwcyBzcGVjaWZpY2F0aW9uKSwgYW5kIHRoZW4gcGFyc2UgdGhlIHN0cmluZyBhc1xuICogSlNPTi5cbiAqL1xuZnVuY3Rpb24gcGFyc2VTb3VyY2VNYXBJbnB1dChzdHIpIHtcbiAgcmV0dXJuIEpTT04ucGFyc2Uoc3RyLnJlcGxhY2UoL15cXCldfSdbXlxcbl0qXFxuLywgJycpKTtcbn1cbmV4cG9ydHMucGFyc2VTb3VyY2VNYXBJbnB1dCA9IHBhcnNlU291cmNlTWFwSW5wdXQ7XG5cbi8qKlxuICogQ29tcHV0ZSB0aGUgVVJMIG9mIGEgc291cmNlIGdpdmVuIHRoZSB0aGUgc291cmNlIHJvb3QsIHRoZSBzb3VyY2Unc1xuICogVVJMLCBhbmQgdGhlIHNvdXJjZSBtYXAncyBVUkwuXG4gKi9cbmZ1bmN0aW9uIGNvbXB1dGVTb3VyY2VVUkwoc291cmNlUm9vdCwgc291cmNlVVJMLCBzb3VyY2VNYXBVUkwpIHtcbiAgc291cmNlVVJMID0gc291cmNlVVJMIHx8ICcnO1xuXG4gIGlmIChzb3VyY2VSb290KSB7XG4gICAgLy8gVGhpcyBmb2xsb3dzIHdoYXQgQ2hyb21lIGRvZXMuXG4gICAgaWYgKHNvdXJjZVJvb3Rbc291cmNlUm9vdC5sZW5ndGggLSAxXSAhPT0gJy8nICYmIHNvdXJjZVVSTFswXSAhPT0gJy8nKSB7XG4gICAgICBzb3VyY2VSb290ICs9ICcvJztcbiAgICB9XG4gICAgLy8gVGhlIHNwZWMgc2F5czpcbiAgICAvLyAgIExpbmUgNDogQW4gb3B0aW9uYWwgc291cmNlIHJvb3QsIHVzZWZ1bCBmb3IgcmVsb2NhdGluZyBzb3VyY2VcbiAgICAvLyAgIGZpbGVzIG9uIGEgc2VydmVyIG9yIHJlbW92aW5nIHJlcGVhdGVkIHZhbHVlcyBpbiB0aGVcbiAgICAvLyAgIOKAnHNvdXJjZXPigJ0gZW50cnkuICBUaGlzIHZhbHVlIGlzIHByZXBlbmRlZCB0byB0aGUgaW5kaXZpZHVhbFxuICAgIC8vICAgZW50cmllcyBpbiB0aGUg4oCcc291cmNl4oCdIGZpZWxkLlxuICAgIHNvdXJjZVVSTCA9IHNvdXJjZVJvb3QgKyBzb3VyY2VVUkw7XG4gIH1cblxuICAvLyBIaXN0b3JpY2FsbHksIFNvdXJjZU1hcENvbnN1bWVyIGRpZCBub3QgdGFrZSB0aGUgc291cmNlTWFwVVJMIGFzXG4gIC8vIGEgcGFyYW1ldGVyLiAgVGhpcyBtb2RlIGlzIHN0aWxsIHNvbWV3aGF0IHN1cHBvcnRlZCwgd2hpY2ggaXMgd2h5XG4gIC8vIHRoaXMgY29kZSBibG9jayBpcyBjb25kaXRpb25hbC4gIEhvd2V2ZXIsIGl0J3MgcHJlZmVyYWJsZSB0byBwYXNzXG4gIC8vIHRoZSBzb3VyY2UgbWFwIFVSTCB0byBTb3VyY2VNYXBDb25zdW1lciwgc28gdGhhdCB0aGlzIGZ1bmN0aW9uXG4gIC8vIGNhbiBpbXBsZW1lbnQgdGhlIHNvdXJjZSBVUkwgcmVzb2x1dGlvbiBhbGdvcml0aG0gYXMgb3V0bGluZWQgaW5cbiAgLy8gdGhlIHNwZWMuICBUaGlzIGJsb2NrIGlzIGJhc2ljYWxseSB0aGUgZXF1aXZhbGVudCBvZjpcbiAgLy8gICAgbmV3IFVSTChzb3VyY2VVUkwsIHNvdXJjZU1hcFVSTCkudG9TdHJpbmcoKVxuICAvLyAuLi4gZXhjZXB0IGl0IGF2b2lkcyB1c2luZyBVUkwsIHdoaWNoIHdhc24ndCBhdmFpbGFibGUgaW4gdGhlXG4gIC8vIG9sZGVyIHJlbGVhc2VzIG9mIG5vZGUgc3RpbGwgc3VwcG9ydGVkIGJ5IHRoaXMgbGlicmFyeS5cbiAgLy9cbiAgLy8gVGhlIHNwZWMgc2F5czpcbiAgLy8gICBJZiB0aGUgc291cmNlcyBhcmUgbm90IGFic29sdXRlIFVSTHMgYWZ0ZXIgcHJlcGVuZGluZyBvZiB0aGVcbiAgLy8gICDigJxzb3VyY2VSb2904oCdLCB0aGUgc291cmNlcyBhcmUgcmVzb2x2ZWQgcmVsYXRpdmUgdG8gdGhlXG4gIC8vICAgU291cmNlTWFwIChsaWtlIHJlc29sdmluZyBzY3JpcHQgc3JjIGluIGEgaHRtbCBkb2N1bWVudCkuXG4gIGlmIChzb3VyY2VNYXBVUkwpIHtcbiAgICB2YXIgcGFyc2VkID0gdXJsUGFyc2Uoc291cmNlTWFwVVJMKTtcbiAgICBpZiAoIXBhcnNlZCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwic291cmNlTWFwVVJMIGNvdWxkIG5vdCBiZSBwYXJzZWRcIik7XG4gICAgfVxuICAgIGlmIChwYXJzZWQucGF0aCkge1xuICAgICAgLy8gU3RyaXAgdGhlIGxhc3QgcGF0aCBjb21wb25lbnQsIGJ1dCBrZWVwIHRoZSBcIi9cIi5cbiAgICAgIHZhciBpbmRleCA9IHBhcnNlZC5wYXRoLmxhc3RJbmRleE9mKCcvJyk7XG4gICAgICBpZiAoaW5kZXggPj0gMCkge1xuICAgICAgICBwYXJzZWQucGF0aCA9IHBhcnNlZC5wYXRoLnN1YnN0cmluZygwLCBpbmRleCArIDEpO1xuICAgICAgfVxuICAgIH1cbiAgICBzb3VyY2VVUkwgPSBqb2luKHVybEdlbmVyYXRlKHBhcnNlZCksIHNvdXJjZVVSTCk7XG4gIH1cblxuICByZXR1cm4gbm9ybWFsaXplKHNvdXJjZVVSTCk7XG59XG5leHBvcnRzLmNvbXB1dGVTb3VyY2VVUkwgPSBjb21wdXRlU291cmNlVVJMO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2VsZWN0cm9uLXVwZGF0ZXIvbm9kZV9tb2R1bGVzL3NvdXJjZS1tYXAvbGliL3V0aWwuanMiLCIndXNlIHN0cmljdCdcblxuY29uc3QgdSA9IHJlcXVpcmUoJ3VuaXZlcnNhbGlmeScpLmZyb21DYWxsYmFja1xuY29uc3QgcmltcmFmID0gcmVxdWlyZSgnLi9yaW1yYWYnKVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgcmVtb3ZlOiB1KHJpbXJhZiksXG4gIHJlbW92ZVN5bmM6IHJpbXJhZi5zeW5jXG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvZWxlY3Ryb24tdXBkYXRlci9ub2RlX21vZHVsZXMvZnMtZXh0cmEvbGliL3JlbW92ZS9pbmRleC5qcyIsIi8vIEpTLVlBTUwncyBkZWZhdWx0IHNjaGVtYSBmb3IgYGxvYWRgIGZ1bmN0aW9uLlxuLy8gSXQgaXMgbm90IGRlc2NyaWJlZCBpbiB0aGUgWUFNTCBzcGVjaWZpY2F0aW9uLlxuLy9cbi8vIFRoaXMgc2NoZW1hIGlzIGJhc2VkIG9uIEpTLVlBTUwncyBkZWZhdWx0IHNhZmUgc2NoZW1hIGFuZCBpbmNsdWRlc1xuLy8gSmF2YVNjcmlwdC1zcGVjaWZpYyB0eXBlczogISFqcy91bmRlZmluZWQsICEhanMvcmVnZXhwIGFuZCAhIWpzL2Z1bmN0aW9uLlxuLy9cbi8vIEFsc28gdGhpcyBzY2hlbWEgaXMgdXNlZCBhcyBkZWZhdWx0IGJhc2Ugc2NoZW1hIGF0IGBTY2hlbWEuY3JlYXRlYCBmdW5jdGlvbi5cblxuXG4ndXNlIHN0cmljdCc7XG5cblxudmFyIFNjaGVtYSA9IHJlcXVpcmUoJy4uL3NjaGVtYScpO1xuXG5cbm1vZHVsZS5leHBvcnRzID0gU2NoZW1hLkRFRkFVTFQgPSBuZXcgU2NoZW1hKHtcbiAgaW5jbHVkZTogW1xuICAgIHJlcXVpcmUoJy4vZGVmYXVsdF9zYWZlJylcbiAgXSxcbiAgZXhwbGljaXQ6IFtcbiAgICByZXF1aXJlKCcuLi90eXBlL2pzL3VuZGVmaW5lZCcpLFxuICAgIHJlcXVpcmUoJy4uL3R5cGUvanMvcmVnZXhwJyksXG4gICAgcmVxdWlyZSgnLi4vdHlwZS9qcy9mdW5jdGlvbicpXG4gIF1cbn0pO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2pzLXlhbWwvbGliL2pzLXlhbWwvc2NoZW1hL2RlZmF1bHRfZnVsbC5qcyIsIid1c2Ugc3RyaWN0JztcbmNvbnN0IGdldEZyb21FbnYgPSBwYXJzZUludChwcm9jZXNzLmVudi5FTEVDVFJPTl9JU19ERVYsIDEwKSA9PT0gMTtcbmNvbnN0IGlzRW52U2V0ID0gJ0VMRUNUUk9OX0lTX0RFVicgaW4gcHJvY2Vzcy5lbnY7XG5cbm1vZHVsZS5leHBvcnRzID0gaXNFbnZTZXQgPyBnZXRGcm9tRW52IDogKHByb2Nlc3MuZGVmYXVsdEFwcCB8fCAvbm9kZV9tb2R1bGVzW1xcXFwvXWVsZWN0cm9uW1xcXFwvXS8udGVzdChwcm9jZXNzLmV4ZWNQYXRoKSk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvZWxlY3Ryb24taXMtZGV2L2luZGV4LmpzIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuTm9PcExvZ2dlciA9IGV4cG9ydHMuQXBwVXBkYXRlciA9IHVuZGVmaW5lZDtcblxudmFyIF9ibHVlYmlyZExzdDtcblxuZnVuY3Rpb24gX2xvYWRfYmx1ZWJpcmRMc3QoKSB7XG4gICAgcmV0dXJuIF9ibHVlYmlyZExzdCA9IHJlcXVpcmUoXCJibHVlYmlyZC1sc3RcIik7XG59XG5cbnZhciBfYmx1ZWJpcmRMc3QyO1xuXG5mdW5jdGlvbiBfbG9hZF9ibHVlYmlyZExzdDIoKSB7XG4gICAgcmV0dXJuIF9ibHVlYmlyZExzdDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJibHVlYmlyZC1sc3RcIikpO1xufVxuXG52YXIgX2J1aWxkZXJVdGlsUnVudGltZTtcblxuZnVuY3Rpb24gX2xvYWRfYnVpbGRlclV0aWxSdW50aW1lKCkge1xuICAgIHJldHVybiBfYnVpbGRlclV0aWxSdW50aW1lID0gcmVxdWlyZShcImJ1aWxkZXItdXRpbC1ydW50aW1lXCIpO1xufVxuXG52YXIgX2NyeXB0bztcblxuZnVuY3Rpb24gX2xvYWRfY3J5cHRvKCkge1xuICAgIHJldHVybiBfY3J5cHRvID0gcmVxdWlyZShcImNyeXB0b1wiKTtcbn1cblxudmFyIF9lbGVjdHJvbjtcblxuZnVuY3Rpb24gX2xvYWRfZWxlY3Ryb24oKSB7XG4gICAgcmV0dXJuIF9lbGVjdHJvbiA9IHJlcXVpcmUoXCJlbGVjdHJvblwiKTtcbn1cblxudmFyIF9lbGVjdHJvbklzRGV2O1xuXG5mdW5jdGlvbiBfbG9hZF9lbGVjdHJvbklzRGV2KCkge1xuICAgIHJldHVybiBfZWxlY3Ryb25Jc0RldiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcImVsZWN0cm9uLWlzLWRldlwiKSk7XG59XG5cbnZhciBfZXZlbnRzO1xuXG5mdW5jdGlvbiBfbG9hZF9ldmVudHMoKSB7XG4gICAgcmV0dXJuIF9ldmVudHMgPSByZXF1aXJlKFwiZXZlbnRzXCIpO1xufVxuXG52YXIgX2ZzRXh0cmFQO1xuXG5mdW5jdGlvbiBfbG9hZF9mc0V4dHJhUCgpIHtcbiAgICByZXR1cm4gX2ZzRXh0cmFQID0gcmVxdWlyZShcImZzLWV4dHJhLXBcIik7XG59XG5cbnZhciBfanNZYW1sO1xuXG5mdW5jdGlvbiBfbG9hZF9qc1lhbWwoKSB7XG4gICAgcmV0dXJuIF9qc1lhbWwgPSByZXF1aXJlKFwianMteWFtbFwiKTtcbn1cblxudmFyIF9sYXp5VmFsO1xuXG5mdW5jdGlvbiBfbG9hZF9sYXp5VmFsKCkge1xuICAgIHJldHVybiBfbGF6eVZhbCA9IHJlcXVpcmUoXCJsYXp5LXZhbFwiKTtcbn1cblxudmFyIF9wYXRoID0gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQocmVxdWlyZShcInBhdGhcIikpO1xuXG52YXIgX3NlbXZlcjtcblxuZnVuY3Rpb24gX2xvYWRfc2VtdmVyKCkge1xuICAgIHJldHVybiBfc2VtdmVyID0gcmVxdWlyZShcInNlbXZlclwiKTtcbn1cblxucmVxdWlyZShcInNvdXJjZS1tYXAtc3VwcG9ydC9yZWdpc3RlclwiKTtcblxudmFyIF9lbGVjdHJvbkh0dHBFeGVjdXRvcjtcblxuZnVuY3Rpb24gX2xvYWRfZWxlY3Ryb25IdHRwRXhlY3V0b3IoKSB7XG4gICAgcmV0dXJuIF9lbGVjdHJvbkh0dHBFeGVjdXRvciA9IHJlcXVpcmUoXCIuL2VsZWN0cm9uSHR0cEV4ZWN1dG9yXCIpO1xufVxuXG52YXIgX0dlbmVyaWNQcm92aWRlcjtcblxuZnVuY3Rpb24gX2xvYWRfR2VuZXJpY1Byb3ZpZGVyKCkge1xuICAgIHJldHVybiBfR2VuZXJpY1Byb3ZpZGVyID0gcmVxdWlyZShcIi4vR2VuZXJpY1Byb3ZpZGVyXCIpO1xufVxuXG52YXIgX21haW47XG5cbmZ1bmN0aW9uIF9sb2FkX21haW4oKSB7XG4gICAgcmV0dXJuIF9tYWluID0gcmVxdWlyZShcIi4vbWFpblwiKTtcbn1cblxudmFyIF9wcm92aWRlckZhY3Rvcnk7XG5cbmZ1bmN0aW9uIF9sb2FkX3Byb3ZpZGVyRmFjdG9yeSgpIHtcbiAgICByZXR1cm4gX3Byb3ZpZGVyRmFjdG9yeSA9IHJlcXVpcmUoXCIuL3Byb3ZpZGVyRmFjdG9yeVwiKTtcbn1cblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQob2JqKSB7IGlmIChvYmogJiYgb2JqLl9fZXNNb2R1bGUpIHsgcmV0dXJuIG9iajsgfSBlbHNlIHsgdmFyIG5ld09iaiA9IHt9OyBpZiAob2JqICE9IG51bGwpIHsgZm9yICh2YXIga2V5IGluIG9iaikgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwga2V5KSkgbmV3T2JqW2tleV0gPSBvYmpba2V5XTsgfSB9IG5ld09iai5kZWZhdWx0ID0gb2JqOyByZXR1cm4gbmV3T2JqOyB9IH1cblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuY2xhc3MgQXBwVXBkYXRlciBleHRlbmRzIChfZXZlbnRzIHx8IF9sb2FkX2V2ZW50cygpKS5FdmVudEVtaXR0ZXIge1xuICAgIGNvbnN0cnVjdG9yKG9wdGlvbnMsIGFwcCkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICAvKipcbiAgICAgICAgICogV2hldGhlciB0byBhdXRvbWF0aWNhbGx5IGRvd25sb2FkIGFuIHVwZGF0ZSB3aGVuIGl0IGlzIGZvdW5kLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5hdXRvRG93bmxvYWQgPSB0cnVlO1xuICAgICAgICAvKipcbiAgICAgICAgICogKkdpdEh1YiBwcm92aWRlciBvbmx5LiogV2hldGhlciB0byBhbGxvdyB1cGRhdGUgdG8gcHJlLXJlbGVhc2UgdmVyc2lvbnMuIERlZmF1bHRzIHRvIGB0cnVlYCBpZiBhcHBsaWNhdGlvbiB2ZXJzaW9uIGNvbnRhaW5zIHByZXJlbGVhc2UgY29tcG9uZW50cyAoZS5nLiBgMC4xMi4xLWFscGhhLjFgLCBoZXJlIGBhbHBoYWAgaXMgYSBwcmVyZWxlYXNlIGNvbXBvbmVudCksIG90aGVyd2lzZSBgZmFsc2VgLlxuICAgICAgICAgKlxuICAgICAgICAgKiBJZiBgdHJ1ZWAsIGRvd25ncmFkZSB3aWxsIGJlIGFsbG93ZWQgKGBhbGxvd0Rvd25ncmFkZWAgd2lsbCBiZSBzZXQgdG8gYHRydWVgKS5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuYWxsb3dQcmVyZWxlYXNlID0gZmFsc2U7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiAqR2l0SHViIHByb3ZpZGVyIG9ubHkuKiBHZXQgYWxsIHJlbGVhc2Ugbm90ZXMgKGZyb20gY3VycmVudCB2ZXJzaW9uIHRvIGxhdGVzdCksIG5vdCBqdXN0IHRoZSBsYXRlc3QuXG4gICAgICAgICAqIEBkZWZhdWx0IGZhbHNlXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmZ1bGxDaGFuZ2Vsb2cgPSBmYWxzZTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFdoZXRoZXIgdG8gYWxsb3cgdmVyc2lvbiBkb3duZ3JhZGUgKHdoZW4gYSB1c2VyIGZyb20gdGhlIGJldGEgY2hhbm5lbCB3YW50cyB0byBnbyBiYWNrIHRvIHRoZSBzdGFibGUgY2hhbm5lbCkuXG4gICAgICAgICAqIEBkZWZhdWx0IGZhbHNlXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmFsbG93RG93bmdyYWRlID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX2NoYW5uZWwgPSBudWxsO1xuICAgICAgICB0aGlzLl9sb2dnZXIgPSBjb25zb2xlO1xuICAgICAgICAvKipcbiAgICAgICAgICogRm9yIHR5cGUgc2FmZXR5IHlvdSBjYW4gdXNlIHNpZ25hbHMsIGUuZy4gYGF1dG9VcGRhdGVyLnNpZ25hbHMudXBkYXRlRG93bmxvYWRlZCgoKSA9PiB7fSlgIGluc3RlYWQgb2YgYGF1dG9VcGRhdGVyLm9uKCd1cGRhdGUtYXZhaWxhYmxlJywgKCkgPT4ge30pYFxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5zaWduYWxzID0gbmV3IChfbWFpbiB8fCBfbG9hZF9tYWluKCkpLlVwZGF0ZXJTaWduYWwodGhpcyk7XG4gICAgICAgIHRoaXMudXBkYXRlQXZhaWxhYmxlID0gZmFsc2U7XG4gICAgICAgIHRoaXMuc3RhZ2luZ1VzZXJJZFByb21pc2UgPSBuZXcgKF9sYXp5VmFsIHx8IF9sb2FkX2xhenlWYWwoKSkuTGF6eSgoKSA9PiB0aGlzLmdldE9yQ3JlYXRlU3RhZ2luZ1VzZXJJZCgpKTtcbiAgICAgICAgLy8gcHVibGljLCBhbGxvdyB0byByZWFkIG9sZCBjb25maWcgZm9yIGFueW9uZVxuICAgICAgICB0aGlzLmNvbmZpZ09uRGlzayA9IG5ldyAoX2xhenlWYWwgfHwgX2xvYWRfbGF6eVZhbCgpKS5MYXp5KCgpID0+IHRoaXMubG9hZFVwZGF0ZUNvbmZpZygpKTtcbiAgICAgICAgdGhpcy5vbihcImVycm9yXCIsIGVycm9yID0+IHtcbiAgICAgICAgICAgIHRoaXMuX2xvZ2dlci5lcnJvcihgRXJyb3I6ICR7ZXJyb3Iuc3RhY2sgfHwgZXJyb3IubWVzc2FnZX1gKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChhcHAgIT0gbnVsbCB8fCBnbG9iYWwuX190ZXN0X2FwcCAhPSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLmFwcCA9IGFwcCB8fCBnbG9iYWwuX190ZXN0X2FwcDtcbiAgICAgICAgICAgIHRoaXMudW50aWxBcHBSZWFkeSA9IChfYmx1ZWJpcmRMc3QyIHx8IF9sb2FkX2JsdWViaXJkTHN0MigpKS5kZWZhdWx0LnJlc29sdmUoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuYXBwID0gcmVxdWlyZShcImVsZWN0cm9uXCIpLmFwcDtcbiAgICAgICAgICAgIHRoaXMuaHR0cEV4ZWN1dG9yID0gbmV3IChfZWxlY3Ryb25IdHRwRXhlY3V0b3IgfHwgX2xvYWRfZWxlY3Ryb25IdHRwRXhlY3V0b3IoKSkuRWxlY3Ryb25IdHRwRXhlY3V0b3IoKGF1dGhJbmZvLCBjYWxsYmFjaykgPT4gdGhpcy5lbWl0KFwibG9naW5cIiwgYXV0aEluZm8sIGNhbGxiYWNrKSk7XG4gICAgICAgICAgICB0aGlzLnVudGlsQXBwUmVhZHkgPSBuZXcgKF9ibHVlYmlyZExzdDIgfHwgX2xvYWRfYmx1ZWJpcmRMc3QyKCkpLmRlZmF1bHQocmVzb2x2ZSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuYXBwLmlzUmVhZHkoKSkge1xuICAgICAgICAgICAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hcHAub24oXCJyZWFkeVwiLCByZXNvbHZlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBjdXJyZW50VmVyc2lvblN0cmluZyA9IHRoaXMuYXBwLmdldFZlcnNpb24oKTtcbiAgICAgICAgY29uc3QgY3VycmVudFZlcnNpb24gPSAoMCwgKF9zZW12ZXIgfHwgX2xvYWRfc2VtdmVyKCkpLnZhbGlkKShjdXJyZW50VmVyc2lvblN0cmluZyk7XG4gICAgICAgIGlmIChjdXJyZW50VmVyc2lvbiA9PSBudWxsKSB7XG4gICAgICAgICAgICB0aHJvdyAoMCwgKF9idWlsZGVyVXRpbFJ1bnRpbWUgfHwgX2xvYWRfYnVpbGRlclV0aWxSdW50aW1lKCkpLm5ld0Vycm9yKShgQXBwIHZlcnNpb24gaXMgbm90IGEgdmFsaWQgc2VtdmVyIHZlcnNpb246IFwiJHtjdXJyZW50VmVyc2lvblN0cmluZ31gLCBcIkVSUl9VUERBVEVSX0lOVkFMSURfVkVSU0lPTlwiKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmN1cnJlbnRWZXJzaW9uID0gY3VycmVudFZlcnNpb247XG4gICAgICAgIHRoaXMuYWxsb3dQcmVyZWxlYXNlID0gaGFzUHJlcmVsZWFzZUNvbXBvbmVudHModGhpcy5jdXJyZW50VmVyc2lvbik7XG4gICAgICAgIGlmIChvcHRpb25zICE9IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuc2V0RmVlZFVSTChvcHRpb25zKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIHVwZGF0ZSBjaGFubmVsLiBOb3QgYXBwbGljYWJsZSBmb3IgR2l0SHViLiBEb2Vzbid0IHJldHVybiBgY2hhbm5lbGAgZnJvbSB0aGUgdXBkYXRlIGNvbmZpZ3VyYXRpb24sIG9ubHkgaWYgd2FzIHByZXZpb3VzbHkgc2V0LlxuICAgICAqL1xuICAgIGdldCBjaGFubmVsKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fY2hhbm5lbDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0IHRoZSB1cGRhdGUgY2hhbm5lbC4gTm90IGFwcGxpY2FibGUgZm9yIEdpdEh1Yi4gT3ZlcnJpZGVzIGBjaGFubmVsYCBpbiB0aGUgdXBkYXRlIGNvbmZpZ3VyYXRpb24uXG4gICAgICpcbiAgICAgKiBgYWxsb3dEb3duZ3JhZGVgIHdpbGwgYmUgYXV0b21hdGljYWxseSBzZXQgdG8gYHRydWVgLiBJZiB0aGlzIGJlaGF2aW9yIGlzIG5vdCBzdWl0YWJsZSBmb3IgeW91LCBzaW1wbGUgc2V0IGBhbGxvd0Rvd25ncmFkZWAgZXhwbGljaXRseSBhZnRlci5cbiAgICAgKi9cbiAgICBzZXQgY2hhbm5lbCh2YWx1ZSkge1xuICAgICAgICBpZiAodGhpcy5fY2hhbm5lbCAhPSBudWxsKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgKDAsIChfYnVpbGRlclV0aWxSdW50aW1lIHx8IF9sb2FkX2J1aWxkZXJVdGlsUnVudGltZSgpKS5uZXdFcnJvcikoYENoYW5uZWwgbXVzdCBiZSBhIHN0cmluZywgYnV0IGdvdDogJHt2YWx1ZX1gLCBcIkVSUl9VUERBVEVSX0lOVkFMSURfQ0hBTk5FTFwiKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodmFsdWUubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgKDAsIChfYnVpbGRlclV0aWxSdW50aW1lIHx8IF9sb2FkX2J1aWxkZXJVdGlsUnVudGltZSgpKS5uZXdFcnJvcikoYENoYW5uZWwgbXVzdCBiZSBub3QgYW4gZW1wdHkgc3RyaW5nYCwgXCJFUlJfVVBEQVRFUl9JTlZBTElEX0NIQU5ORUxcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fY2hhbm5lbCA9IHZhbHVlO1xuICAgICAgICB0aGlzLmFsbG93RG93bmdyYWRlID0gdHJ1ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVGhlIGxvZ2dlci4gWW91IGNhbiBwYXNzIFtlbGVjdHJvbi1sb2ddKGh0dHBzOi8vZ2l0aHViLmNvbS9tZWdhaGVydHovZWxlY3Ryb24tbG9nKSwgW3dpbnN0b25dKGh0dHBzOi8vZ2l0aHViLmNvbS93aW5zdG9uanMvd2luc3Rvbikgb3IgYW5vdGhlciBsb2dnZXIgd2l0aCB0aGUgZm9sbG93aW5nIGludGVyZmFjZTogYHsgaW5mbygpLCB3YXJuKCksIGVycm9yKCkgfWAuXG4gICAgICogU2V0IGl0IHRvIGBudWxsYCBpZiB5b3Ugd291bGQgbGlrZSB0byBkaXNhYmxlIGEgbG9nZ2luZyBmZWF0dXJlLlxuICAgICAqL1xuICAgIGdldCBsb2dnZXIoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9sb2dnZXI7XG4gICAgfVxuICAgIHNldCBsb2dnZXIodmFsdWUpIHtcbiAgICAgICAgdGhpcy5fbG9nZ2VyID0gdmFsdWUgPT0gbnVsbCA/IG5ldyBOb09wTG9nZ2VyKCkgOiB2YWx1ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogdGVzdCBvbmx5XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBzZXQgdXBkYXRlQ29uZmlnUGF0aCh2YWx1ZSkge1xuICAgICAgICB0aGlzLmNsaWVudFByb21pc2UgPSBudWxsO1xuICAgICAgICB0aGlzLl9hcHBVcGRhdGVDb25maWdQYXRoID0gdmFsdWU7XG4gICAgICAgIHRoaXMuY29uZmlnT25EaXNrID0gbmV3IChfbGF6eVZhbCB8fCBfbG9hZF9sYXp5VmFsKCkpLkxhenkoKCkgPT4gdGhpcy5sb2FkVXBkYXRlQ29uZmlnKCkpO1xuICAgIH1cbiAgICBnZXQgcHJvdmlkZXIoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNsaWVudFByb21pc2U7XG4gICAgfVxuICAgIC8vbm9pbnNwZWN0aW9uIEpTTWV0aG9kQ2FuQmVTdGF0aWMsSlNVbnVzZWRHbG9iYWxTeW1ib2xzXG4gICAgZ2V0RmVlZFVSTCgpIHtcbiAgICAgICAgcmV0dXJuIFwiRGVwcmVjYXRlZC4gRG8gbm90IHVzZSBpdC5cIjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ29uZmlndXJlIHVwZGF0ZSBwcm92aWRlci4gSWYgdmFsdWUgaXMgYHN0cmluZ2AsIFtHZW5lcmljU2VydmVyT3B0aW9uc10oL2NvbmZpZ3VyYXRpb24vcHVibGlzaC5tZCNnZW5lcmljc2VydmVyb3B0aW9ucykgd2lsbCBiZSBzZXQgd2l0aCB2YWx1ZSBhcyBgdXJsYC5cbiAgICAgKiBAcGFyYW0gb3B0aW9ucyBJZiB5b3Ugd2FudCB0byBvdmVycmlkZSBjb25maWd1cmF0aW9uIGluIHRoZSBgYXBwLXVwZGF0ZS55bWxgLlxuICAgICAqL1xuICAgIHNldEZlZWRVUkwob3B0aW9ucykge1xuICAgICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vZWxlY3Ryb24tdXNlcmxhbmQvZWxlY3Ryb24tYnVpbGRlci9pc3N1ZXMvMTEwNVxuICAgICAgICBsZXQgcHJvdmlkZXI7XG4gICAgICAgIGlmICh0eXBlb2Ygb3B0aW9ucyA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgcHJvdmlkZXIgPSBuZXcgKF9HZW5lcmljUHJvdmlkZXIgfHwgX2xvYWRfR2VuZXJpY1Byb3ZpZGVyKCkpLkdlbmVyaWNQcm92aWRlcih7IHByb3ZpZGVyOiBcImdlbmVyaWNcIiwgdXJsOiBvcHRpb25zIH0sIHRoaXMpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcHJvdmlkZXIgPSAoMCwgKF9wcm92aWRlckZhY3RvcnkgfHwgX2xvYWRfcHJvdmlkZXJGYWN0b3J5KCkpLmNyZWF0ZUNsaWVudCkob3B0aW9ucywgdGhpcyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jbGllbnRQcm9taXNlID0gUHJvbWlzZS5yZXNvbHZlKHByb3ZpZGVyKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQXNrcyB0aGUgc2VydmVyIHdoZXRoZXIgdGhlcmUgaXMgYW4gdXBkYXRlLlxuICAgICAqL1xuICAgIGNoZWNrRm9yVXBkYXRlcygpIHtcbiAgICAgICAgbGV0IGNoZWNrRm9yVXBkYXRlc1Byb21pc2UgPSB0aGlzLmNoZWNrRm9yVXBkYXRlc1Byb21pc2U7XG4gICAgICAgIGlmIChjaGVja0ZvclVwZGF0ZXNQcm9taXNlICE9IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBjaGVja0ZvclVwZGF0ZXNQcm9taXNlO1xuICAgICAgICB9XG4gICAgICAgIGNoZWNrRm9yVXBkYXRlc1Byb21pc2UgPSB0aGlzLl9jaGVja0ZvclVwZGF0ZXMoKTtcbiAgICAgICAgdGhpcy5jaGVja0ZvclVwZGF0ZXNQcm9taXNlID0gY2hlY2tGb3JVcGRhdGVzUHJvbWlzZTtcbiAgICAgICAgY29uc3QgbnVsbGl6ZVByb21pc2UgPSAoKSA9PiB0aGlzLmNoZWNrRm9yVXBkYXRlc1Byb21pc2UgPSBudWxsO1xuICAgICAgICBjaGVja0ZvclVwZGF0ZXNQcm9taXNlLnRoZW4obnVsbGl6ZVByb21pc2UpLmNhdGNoKG51bGxpemVQcm9taXNlKTtcbiAgICAgICAgcmV0dXJuIGNoZWNrRm9yVXBkYXRlc1Byb21pc2U7XG4gICAgfVxuICAgIGNoZWNrRm9yVXBkYXRlc0FuZE5vdGlmeSgpIHtcbiAgICAgICAgaWYgKChfZWxlY3Ryb25Jc0RldiB8fCBfbG9hZF9lbGVjdHJvbklzRGV2KCkpLmRlZmF1bHQpIHtcbiAgICAgICAgICAgIHJldHVybiAoX2JsdWViaXJkTHN0MiB8fCBfbG9hZF9ibHVlYmlyZExzdDIoKSkuZGVmYXVsdC5yZXNvbHZlKG51bGwpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc2lnbmFscy51cGRhdGVEb3dubG9hZGVkKGl0ID0+IHtcbiAgICAgICAgICAgIG5ldyAoX2VsZWN0cm9uIHx8IF9sb2FkX2VsZWN0cm9uKCkpLk5vdGlmaWNhdGlvbih7XG4gICAgICAgICAgICAgICAgdGl0bGU6IFwiQSBuZXcgdXBkYXRlIGlzIHJlYWR5IHRvIGluc3RhbGxcIixcbiAgICAgICAgICAgICAgICBib2R5OiBgJHt0aGlzLmFwcC5nZXROYW1lKCl9IHZlcnNpb24gJHtpdC52ZXJzaW9ufSBpcyBkb3dubG9hZGVkIGFuZCB3aWxsIGJlIGF1dG9tYXRpY2FsbHkgaW5zdGFsbGVkIG9uIGV4aXRgXG4gICAgICAgICAgICB9KS5zaG93KCk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gdGhpcy5jaGVja0ZvclVwZGF0ZXMoKTtcbiAgICB9XG4gICAgaXNTdGFnaW5nTWF0Y2godXBkYXRlSW5mbykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgICAgIHJldHVybiAoMCwgKF9ibHVlYmlyZExzdCB8fCBfbG9hZF9ibHVlYmlyZExzdCgpKS5jb3JvdXRpbmUpKGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCByYXdTdGFnaW5nUGVyY2VudGFnZSA9IHVwZGF0ZUluZm8uc3RhZ2luZ1BlcmNlbnRhZ2U7XG4gICAgICAgICAgICBsZXQgc3RhZ2luZ1BlcmNlbnRhZ2UgPSByYXdTdGFnaW5nUGVyY2VudGFnZTtcbiAgICAgICAgICAgIGlmIChzdGFnaW5nUGVyY2VudGFnZSA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzdGFnaW5nUGVyY2VudGFnZSA9IHBhcnNlSW50KHN0YWdpbmdQZXJjZW50YWdlLCAxMCk7XG4gICAgICAgICAgICBpZiAoaXNOYU4oc3RhZ2luZ1BlcmNlbnRhZ2UpKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMuX2xvZ2dlci53YXJuKGBTdGFnaW5nIHBlcmNlbnRhZ2UgaXMgTmFOOiAke3Jhd1N0YWdpbmdQZXJjZW50YWdlfWApO1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gY29udmVydCBmcm9tIHVzZXIgMC0xMDAgdG8gaW50ZXJuYWwgMC0xXG4gICAgICAgICAgICBzdGFnaW5nUGVyY2VudGFnZSA9IHN0YWdpbmdQZXJjZW50YWdlIC8gMTAwO1xuICAgICAgICAgICAgY29uc3Qgc3RhZ2luZ1VzZXJJZCA9IHlpZWxkIF90aGlzLnN0YWdpbmdVc2VySWRQcm9taXNlLnZhbHVlO1xuICAgICAgICAgICAgY29uc3QgdmFsID0gKF9idWlsZGVyVXRpbFJ1bnRpbWUgfHwgX2xvYWRfYnVpbGRlclV0aWxSdW50aW1lKCkpLlVVSUQucGFyc2Uoc3RhZ2luZ1VzZXJJZCkucmVhZFVJbnQzMkJFKDEyKTtcbiAgICAgICAgICAgIGNvbnN0IHBlcmNlbnRhZ2UgPSB2YWwgLyAweEZGRkZGRkZGO1xuICAgICAgICAgICAgX3RoaXMuX2xvZ2dlci5pbmZvKGBTdGFnaW5nIHBlcmNlbnRhZ2U6ICR7c3RhZ2luZ1BlcmNlbnRhZ2V9LCBwZXJjZW50YWdlOiAke3BlcmNlbnRhZ2V9LCB1c2VyIGlkOiAke3N0YWdpbmdVc2VySWR9YCk7XG4gICAgICAgICAgICByZXR1cm4gcGVyY2VudGFnZSA8IHN0YWdpbmdQZXJjZW50YWdlO1xuICAgICAgICB9KSgpO1xuICAgIH1cbiAgICBfY2hlY2tGb3JVcGRhdGVzKCkge1xuICAgICAgICB2YXIgX3RoaXMyID0gdGhpcztcblxuICAgICAgICByZXR1cm4gKDAsIChfYmx1ZWJpcmRMc3QgfHwgX2xvYWRfYmx1ZWJpcmRMc3QoKSkuY29yb3V0aW5lKShmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICB5aWVsZCBfdGhpczIudW50aWxBcHBSZWFkeTtcbiAgICAgICAgICAgICAgICBfdGhpczIuX2xvZ2dlci5pbmZvKFwiQ2hlY2tpbmcgZm9yIHVwZGF0ZVwiKTtcbiAgICAgICAgICAgICAgICBfdGhpczIuZW1pdChcImNoZWNraW5nLWZvci11cGRhdGVcIik7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHlpZWxkIF90aGlzMi5kb0NoZWNrRm9yVXBkYXRlcygpO1xuICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIF90aGlzMi5lbWl0KFwiZXJyb3JcIiwgZSwgYENhbm5vdCBjaGVjayBmb3IgdXBkYXRlczogJHsoZS5zdGFjayB8fCBlKS50b1N0cmluZygpfWApO1xuICAgICAgICAgICAgICAgIHRocm93IGU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pKCk7XG4gICAgfVxuICAgIGNvbXB1dGVGaW5hbEhlYWRlcnMoaGVhZGVycykge1xuICAgICAgICBpZiAodGhpcy5yZXF1ZXN0SGVhZGVycyAhPSBudWxsKSB7XG4gICAgICAgICAgICBPYmplY3QuYXNzaWduKGhlYWRlcnMsIHRoaXMucmVxdWVzdEhlYWRlcnMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBoZWFkZXJzO1xuICAgIH1cbiAgICBkb0NoZWNrRm9yVXBkYXRlcygpIHtcbiAgICAgICAgdmFyIF90aGlzMyA9IHRoaXM7XG5cbiAgICAgICAgcmV0dXJuICgwLCAoX2JsdWViaXJkTHN0IHx8IF9sb2FkX2JsdWViaXJkTHN0KCkpLmNvcm91dGluZSkoZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGlmIChfdGhpczMuY2xpZW50UHJvbWlzZSA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMzLmNsaWVudFByb21pc2UgPSBfdGhpczMuY29uZmlnT25EaXNrLnZhbHVlLnRoZW4oZnVuY3Rpb24gKGl0KSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAoMCwgKF9wcm92aWRlckZhY3RvcnkgfHwgX2xvYWRfcHJvdmlkZXJGYWN0b3J5KCkpLmNyZWF0ZUNsaWVudCkoaXQsIF90aGlzMyk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBjbGllbnQgPSB5aWVsZCBfdGhpczMuY2xpZW50UHJvbWlzZTtcbiAgICAgICAgICAgIGNvbnN0IHN0YWdpbmdVc2VySWQgPSB5aWVsZCBfdGhpczMuc3RhZ2luZ1VzZXJJZFByb21pc2UudmFsdWU7XG4gICAgICAgICAgICBjbGllbnQuc2V0UmVxdWVzdEhlYWRlcnMoX3RoaXMzLmNvbXB1dGVGaW5hbEhlYWRlcnMoeyBcIlgtVXNlci1TdGFnaW5nLUlkXCI6IHN0YWdpbmdVc2VySWQgfSkpO1xuICAgICAgICAgICAgY29uc3QgdXBkYXRlSW5mbyA9IHlpZWxkIGNsaWVudC5nZXRMYXRlc3RWZXJzaW9uKCk7XG4gICAgICAgICAgICBjb25zdCBsYXRlc3RWZXJzaW9uID0gKDAsIChfc2VtdmVyIHx8IF9sb2FkX3NlbXZlcigpKS52YWxpZCkodXBkYXRlSW5mby52ZXJzaW9uKTtcbiAgICAgICAgICAgIGlmIChsYXRlc3RWZXJzaW9uID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyAoMCwgKF9idWlsZGVyVXRpbFJ1bnRpbWUgfHwgX2xvYWRfYnVpbGRlclV0aWxSdW50aW1lKCkpLm5ld0Vycm9yKShgTGF0ZXN0IHZlcnNpb24gKGZyb20gdXBkYXRlIHNlcnZlcikgaXMgbm90IHZhbGlkIHNlbXZlciB2ZXJzaW9uOiBcIiR7bGF0ZXN0VmVyc2lvbn1gLCBcIkVSUl9VUERBVEVSX0lOVkFMSURfVkVSU0lPTlwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGlzU3RhZ2luZ01hdGNoID0geWllbGQgX3RoaXMzLmlzU3RhZ2luZ01hdGNoKHVwZGF0ZUluZm8pO1xuICAgICAgICAgICAgaWYgKCFpc1N0YWdpbmdNYXRjaCB8fCAoX3RoaXMzLmFsbG93RG93bmdyYWRlICYmICFoYXNQcmVyZWxlYXNlQ29tcG9uZW50cyhsYXRlc3RWZXJzaW9uKSA/ICgwLCAoX3NlbXZlciB8fCBfbG9hZF9zZW12ZXIoKSkuZXEpKGxhdGVzdFZlcnNpb24sIF90aGlzMy5jdXJyZW50VmVyc2lvbikgOiAhKDAsIChfc2VtdmVyIHx8IF9sb2FkX3NlbXZlcigpKS5ndCkobGF0ZXN0VmVyc2lvbiwgX3RoaXMzLmN1cnJlbnRWZXJzaW9uKSkpIHtcbiAgICAgICAgICAgICAgICBfdGhpczMudXBkYXRlQXZhaWxhYmxlID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgX3RoaXMzLl9sb2dnZXIuaW5mbyhgVXBkYXRlIGZvciB2ZXJzaW9uICR7X3RoaXMzLmN1cnJlbnRWZXJzaW9ufSBpcyBub3QgYXZhaWxhYmxlIChsYXRlc3QgdmVyc2lvbjogJHt1cGRhdGVJbmZvLnZlcnNpb259LCBkb3duZ3JhZGUgaXMgJHtfdGhpczMuYWxsb3dEb3duZ3JhZGUgPyBcImFsbG93ZWRcIiA6IFwiZGlzYWxsb3dlZFwifS5gKTtcbiAgICAgICAgICAgICAgICBfdGhpczMuZW1pdChcInVwZGF0ZS1ub3QtYXZhaWxhYmxlXCIsIHVwZGF0ZUluZm8pO1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIHZlcnNpb25JbmZvOiB1cGRhdGVJbmZvLFxuICAgICAgICAgICAgICAgICAgICB1cGRhdGVJbmZvXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIF90aGlzMy51cGRhdGVBdmFpbGFibGUgPSB0cnVlO1xuICAgICAgICAgICAgX3RoaXMzLnVwZGF0ZUluZm8gPSB1cGRhdGVJbmZvO1xuICAgICAgICAgICAgX3RoaXMzLm9uVXBkYXRlQXZhaWxhYmxlKHVwZGF0ZUluZm8pO1xuICAgICAgICAgICAgY29uc3QgY2FuY2VsbGF0aW9uVG9rZW4gPSBuZXcgKF9idWlsZGVyVXRpbFJ1bnRpbWUgfHwgX2xvYWRfYnVpbGRlclV0aWxSdW50aW1lKCkpLkNhbmNlbGxhdGlvblRva2VuKCk7XG4gICAgICAgICAgICAvL25vaW5zcGVjdGlvbiBFUzZNaXNzaW5nQXdhaXRcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdmVyc2lvbkluZm86IHVwZGF0ZUluZm8sXG4gICAgICAgICAgICAgICAgdXBkYXRlSW5mbyxcbiAgICAgICAgICAgICAgICBjYW5jZWxsYXRpb25Ub2tlbixcbiAgICAgICAgICAgICAgICBkb3dubG9hZFByb21pc2U6IF90aGlzMy5hdXRvRG93bmxvYWQgPyBfdGhpczMuZG93bmxvYWRVcGRhdGUoY2FuY2VsbGF0aW9uVG9rZW4pIDogbnVsbFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSkoKTtcbiAgICB9XG4gICAgb25VcGRhdGVBdmFpbGFibGUodXBkYXRlSW5mbykge1xuICAgICAgICB0aGlzLl9sb2dnZXIuaW5mbyhgRm91bmQgdmVyc2lvbiAke3VwZGF0ZUluZm8udmVyc2lvbn0gKHVybDogJHsoMCwgKF9idWlsZGVyVXRpbFJ1bnRpbWUgfHwgX2xvYWRfYnVpbGRlclV0aWxSdW50aW1lKCkpLmFzQXJyYXkpKHVwZGF0ZUluZm8uZmlsZXMpLm1hcChpdCA9PiBpdC51cmwpLmpvaW4oXCIsIFwiKX0pYCk7XG4gICAgICAgIHRoaXMuZW1pdChcInVwZGF0ZS1hdmFpbGFibGVcIiwgdXBkYXRlSW5mbyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFN0YXJ0IGRvd25sb2FkaW5nIHVwZGF0ZSBtYW51YWxseS4gWW91IGNhbiB1c2UgdGhpcyBtZXRob2QgaWYgYGF1dG9Eb3dubG9hZGAgb3B0aW9uIGlzIHNldCB0byBgZmFsc2VgLlxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPHN0cmluZz59IFBhdGggdG8gZG93bmxvYWRlZCBmaWxlLlxuICAgICAqL1xuICAgIGRvd25sb2FkVXBkYXRlKGNhbmNlbGxhdGlvblRva2VuID0gbmV3IChfYnVpbGRlclV0aWxSdW50aW1lIHx8IF9sb2FkX2J1aWxkZXJVdGlsUnVudGltZSgpKS5DYW5jZWxsYXRpb25Ub2tlbigpKSB7XG4gICAgICAgIHZhciBfdGhpczQgPSB0aGlzO1xuXG4gICAgICAgIHJldHVybiAoMCwgKF9ibHVlYmlyZExzdCB8fCBfbG9hZF9ibHVlYmlyZExzdCgpKS5jb3JvdXRpbmUpKGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCB1cGRhdGVJbmZvID0gX3RoaXM0LnVwZGF0ZUluZm87XG4gICAgICAgICAgICBpZiAodXBkYXRlSW5mbyA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZXJyb3IgPSBuZXcgRXJyb3IoXCJQbGVhc2UgY2hlY2sgdXBkYXRlIGZpcnN0XCIpO1xuICAgICAgICAgICAgICAgIF90aGlzNC5kaXNwYXRjaEVycm9yKGVycm9yKTtcbiAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIF90aGlzNC5fbG9nZ2VyLmluZm8oYERvd25sb2FkaW5nIHVwZGF0ZSBmcm9tICR7KDAsIChfYnVpbGRlclV0aWxSdW50aW1lIHx8IF9sb2FkX2J1aWxkZXJVdGlsUnVudGltZSgpKS5hc0FycmF5KSh1cGRhdGVJbmZvLmZpbGVzKS5tYXAoZnVuY3Rpb24gKGl0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGl0LnVybDtcbiAgICAgICAgICAgIH0pLmpvaW4oXCIsIFwiKX1gKTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHlpZWxkIF90aGlzNC5kb0Rvd25sb2FkVXBkYXRlKHVwZGF0ZUluZm8sIGNhbmNlbGxhdGlvblRva2VuKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICBfdGhpczQuZGlzcGF0Y2hFcnJvcihlKTtcbiAgICAgICAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KSgpO1xuICAgIH1cbiAgICBkaXNwYXRjaEVycm9yKGUpIHtcbiAgICAgICAgdGhpcy5lbWl0KFwiZXJyb3JcIiwgZSwgKGUuc3RhY2sgfHwgZSkudG9TdHJpbmcoKSk7XG4gICAgfVxuICAgIGxvYWRVcGRhdGVDb25maWcoKSB7XG4gICAgICAgIHZhciBfdGhpczUgPSB0aGlzO1xuXG4gICAgICAgIHJldHVybiAoMCwgKF9ibHVlYmlyZExzdCB8fCBfbG9hZF9ibHVlYmlyZExzdCgpKS5jb3JvdXRpbmUpKGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBpZiAoX3RoaXM1Ll9hcHBVcGRhdGVDb25maWdQYXRoID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBfdGhpczUuX2FwcFVwZGF0ZUNvbmZpZ1BhdGggPSAoX2VsZWN0cm9uSXNEZXYgfHwgX2xvYWRfZWxlY3Ryb25Jc0RldigpKS5kZWZhdWx0ID8gX3BhdGguam9pbihfdGhpczUuYXBwLmdldEFwcFBhdGgoKSwgXCJkZXYtYXBwLXVwZGF0ZS55bWxcIikgOiBfcGF0aC5qb2luKHByb2Nlc3MucmVzb3VyY2VzUGF0aCwgXCJhcHAtdXBkYXRlLnltbFwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiAoMCwgKF9qc1lhbWwgfHwgX2xvYWRfanNZYW1sKCkpLnNhZmVMb2FkKSgoeWllbGQgKDAsIChfZnNFeHRyYVAgfHwgX2xvYWRfZnNFeHRyYVAoKSkucmVhZEZpbGUpKF90aGlzNS5fYXBwVXBkYXRlQ29uZmlnUGF0aCwgXCJ1dGYtOFwiKSkpO1xuICAgICAgICB9KSgpO1xuICAgIH1cbiAgICAvKioqIEBwcml2YXRlICovXG4gICAgY29tcHV0ZVJlcXVlc3RIZWFkZXJzKCkge1xuICAgICAgICB2YXIgX3RoaXM2ID0gdGhpcztcblxuICAgICAgICByZXR1cm4gKDAsIChfYmx1ZWJpcmRMc3QgfHwgX2xvYWRfYmx1ZWJpcmRMc3QoKSkuY29yb3V0aW5lKShmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3QgZmlsZUV4dHJhRG93bmxvYWRIZWFkZXJzID0gKHlpZWxkIF90aGlzNi5wcm92aWRlcikuZmlsZUV4dHJhRG93bmxvYWRIZWFkZXJzO1xuICAgICAgICAgICAgaWYgKGZpbGVFeHRyYURvd25sb2FkSGVhZGVycyAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVxdWVzdEhlYWRlcnMgPSBfdGhpczYucmVxdWVzdEhlYWRlcnM7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlcXVlc3RIZWFkZXJzID09IG51bGwgPyBmaWxlRXh0cmFEb3dubG9hZEhlYWRlcnMgOiBPYmplY3QuYXNzaWduKHt9LCBmaWxlRXh0cmFEb3dubG9hZEhlYWRlcnMsIHJlcXVlc3RIZWFkZXJzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBfdGhpczYuY29tcHV0ZUZpbmFsSGVhZGVycyh7IEFjY2VwdDogXCIqLypcIiB9KTtcbiAgICAgICAgfSkoKTtcbiAgICB9XG4gICAgZ2V0T3JDcmVhdGVTdGFnaW5nVXNlcklkKCkge1xuICAgICAgICB2YXIgX3RoaXM3ID0gdGhpcztcblxuICAgICAgICByZXR1cm4gKDAsIChfYmx1ZWJpcmRMc3QgfHwgX2xvYWRfYmx1ZWJpcmRMc3QoKSkuY29yb3V0aW5lKShmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3QgZmlsZSA9IF9wYXRoLmpvaW4oX3RoaXM3LmFwcC5nZXRQYXRoKFwidXNlckRhdGFcIiksIFwiLnVwZGF0ZXJJZFwiKTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgY29uc3QgaWQgPSB5aWVsZCAoMCwgKF9mc0V4dHJhUCB8fCBfbG9hZF9mc0V4dHJhUCgpKS5yZWFkRmlsZSkoZmlsZSwgXCJ1dGYtOFwiKTtcbiAgICAgICAgICAgICAgICBpZiAoKF9idWlsZGVyVXRpbFJ1bnRpbWUgfHwgX2xvYWRfYnVpbGRlclV0aWxSdW50aW1lKCkpLlVVSUQuY2hlY2soaWQpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBpZDtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBfdGhpczcuX2xvZ2dlci53YXJuKGBTdGFnaW5nIHVzZXIgaWQgZmlsZSBleGlzdHMsIGJ1dCBjb250ZW50IHdhcyBpbnZhbGlkOiAke2lkfWApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICBpZiAoZS5jb2RlICE9PSBcIkVOT0VOVFwiKSB7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzNy5fbG9nZ2VyLndhcm4oYENvdWxkbid0IHJlYWQgc3RhZ2luZyB1c2VyIElELCBjcmVhdGluZyBhIGJsYW5rIG9uZTogJHtlfWApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGlkID0gKF9idWlsZGVyVXRpbFJ1bnRpbWUgfHwgX2xvYWRfYnVpbGRlclV0aWxSdW50aW1lKCkpLlVVSUQudjUoKDAsIChfY3J5cHRvIHx8IF9sb2FkX2NyeXB0bygpKS5yYW5kb21CeXRlcykoNDA5NiksIChfYnVpbGRlclV0aWxSdW50aW1lIHx8IF9sb2FkX2J1aWxkZXJVdGlsUnVudGltZSgpKS5VVUlELk9JRCk7XG4gICAgICAgICAgICBfdGhpczcuX2xvZ2dlci5pbmZvKGBHZW5lcmF0ZWQgbmV3IHN0YWdpbmcgdXNlciBJRDogJHtpZH1gKTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgeWllbGQgKDAsIChfZnNFeHRyYVAgfHwgX2xvYWRfZnNFeHRyYVAoKSkub3V0cHV0RmlsZSkoZmlsZSwgaWQpO1xuICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIF90aGlzNy5fbG9nZ2VyLndhcm4oYENvdWxkbid0IHdyaXRlIG91dCBzdGFnaW5nIHVzZXIgSUQ6ICR7ZX1gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBpZDtcbiAgICAgICAgfSkoKTtcbiAgICB9XG59XG5leHBvcnRzLkFwcFVwZGF0ZXIgPSBBcHBVcGRhdGVyO1xuZnVuY3Rpb24gaGFzUHJlcmVsZWFzZUNvbXBvbmVudHModmVyc2lvbikge1xuICAgIGNvbnN0IHZlcnNpb25QcmVyZWxlYXNlQ29tcG9uZW50ID0gKDAsIChfc2VtdmVyIHx8IF9sb2FkX3NlbXZlcigpKS5wcmVyZWxlYXNlKSh2ZXJzaW9uKTtcbiAgICByZXR1cm4gdmVyc2lvblByZXJlbGVhc2VDb21wb25lbnQgIT0gbnVsbCAmJiB2ZXJzaW9uUHJlcmVsZWFzZUNvbXBvbmVudC5sZW5ndGggPiAwO1xufVxuLyoqIEBwcml2YXRlICovXG5jbGFzcyBOb09wTG9nZ2VyIHtcbiAgICBpbmZvKG1lc3NhZ2UpIHtcbiAgICAgICAgLy8gaWdub3JlXG4gICAgfVxuICAgIHdhcm4obWVzc2FnZSkge1xuICAgICAgICAvLyBpZ25vcmVcbiAgICB9XG4gICAgZXJyb3IobWVzc2FnZSkge1xuICAgICAgICAvLyBpZ25vcmVcbiAgICB9XG59XG5leHBvcnRzLk5vT3BMb2dnZXIgPSBOb09wTG9nZ2VyOyAvLyMgc291cmNlTWFwcGluZ1VSTD1BcHBVcGRhdGVyLmpzLm1hcFxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9lbGVjdHJvbi11cGRhdGVyL291dC9BcHBVcGRhdGVyLmpzIiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwiY3J5cHRvXCIpO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIGV4dGVybmFsIFwiY3J5cHRvXCJcbi8vIG1vZHVsZSBpZCA9IDI4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcInV0aWxcIik7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gZXh0ZXJuYWwgXCJ1dGlsXCJcbi8vIG1vZHVsZSBpZCA9IDI5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIid1c2Ugc3RyaWN0J1xuXG5jb25zdCB1ID0gcmVxdWlyZSgndW5pdmVyc2FsaWZ5JykuZnJvbUNhbGxiYWNrXG5jb25zdCBqc29uRmlsZSA9IHJlcXVpcmUoJ2pzb25maWxlJylcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIC8vIGpzb25maWxlIGV4cG9ydHNcbiAgcmVhZEpzb246IHUoanNvbkZpbGUucmVhZEZpbGUpLFxuICByZWFkSnNvblN5bmM6IGpzb25GaWxlLnJlYWRGaWxlU3luYyxcbiAgd3JpdGVKc29uOiB1KGpzb25GaWxlLndyaXRlRmlsZSksXG4gIHdyaXRlSnNvblN5bmM6IGpzb25GaWxlLndyaXRlRmlsZVN5bmNcbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9lbGVjdHJvbi11cGRhdGVyL25vZGVfbW9kdWxlcy9mcy1leHRyYS9saWIvanNvbi9qc29uZmlsZS5qcyIsIid1c2Ugc3RyaWN0JztcblxuXG52YXIgeWFtbCA9IHJlcXVpcmUoJy4vbGliL2pzLXlhbWwuanMnKTtcblxuXG5tb2R1bGUuZXhwb3J0cyA9IHlhbWw7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvanMteWFtbC9pbmRleC5qcyIsIi8vIFN0YW5kYXJkIFlBTUwncyBGYWlsc2FmZSBzY2hlbWEuXG4vLyBodHRwOi8vd3d3LnlhbWwub3JnL3NwZWMvMS4yL3NwZWMuaHRtbCNpZDI4MDIzNDZcblxuXG4ndXNlIHN0cmljdCc7XG5cblxudmFyIFNjaGVtYSA9IHJlcXVpcmUoJy4uL3NjaGVtYScpO1xuXG5cbm1vZHVsZS5leHBvcnRzID0gbmV3IFNjaGVtYSh7XG4gIGV4cGxpY2l0OiBbXG4gICAgcmVxdWlyZSgnLi4vdHlwZS9zdHInKSxcbiAgICByZXF1aXJlKCcuLi90eXBlL3NlcScpLFxuICAgIHJlcXVpcmUoJy4uL3R5cGUvbWFwJylcbiAgXVxufSk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvanMteWFtbC9saWIvanMteWFtbC9zY2hlbWEvZmFpbHNhZmUuanMiLCJyZXF1aXJlKCcuLycpLmluc3RhbGwoKTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9lbGVjdHJvbi11cGRhdGVyL25vZGVfbW9kdWxlcy9zb3VyY2UtbWFwLXN1cHBvcnQvcmVnaXN0ZXIuanMiLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCJjaGlsZF9wcm9jZXNzXCIpO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIGV4dGVybmFsIFwiY2hpbGRfcHJvY2Vzc1wiXG4vLyBtb2R1bGUgaWQgPSAzNFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5jb21wdXRlT3BlcmF0aW9ucyA9IGNvbXB1dGVPcGVyYXRpb25zO1xudmFyIE9wZXJhdGlvbktpbmQgPSBleHBvcnRzLk9wZXJhdGlvbktpbmQgPSB1bmRlZmluZWQ7XG4oZnVuY3Rpb24gKE9wZXJhdGlvbktpbmQpIHtcbiAgICBPcGVyYXRpb25LaW5kW09wZXJhdGlvbktpbmRbXCJDT1BZXCJdID0gMF0gPSBcIkNPUFlcIjtcbiAgICBPcGVyYXRpb25LaW5kW09wZXJhdGlvbktpbmRbXCJET1dOTE9BRFwiXSA9IDFdID0gXCJET1dOTE9BRFwiO1xufSkoT3BlcmF0aW9uS2luZCB8fCAoZXhwb3J0cy5PcGVyYXRpb25LaW5kID0gT3BlcmF0aW9uS2luZCA9IHt9KSk7XG5mdW5jdGlvbiBjb21wdXRlT3BlcmF0aW9ucyhvbGRCbG9ja01hcCwgbmV3QmxvY2tNYXAsIGxvZ2dlcikge1xuICAgIGNvbnN0IG5hbWVUb09sZEJsb2NrcyA9IGJ1aWxkQmxvY2tGaWxlTWFwKG9sZEJsb2NrTWFwLmZpbGVzKTtcbiAgICBjb25zdCBuYW1lVG9OZXdCbG9ja3MgPSBidWlsZEJsb2NrRmlsZU1hcChuZXdCbG9ja01hcC5maWxlcyk7XG4gICAgY29uc3Qgb2xkRW50cnlNYXAgPSBidWlsZEVudHJ5TWFwKG9sZEJsb2NrTWFwLmZpbGVzKTtcbiAgICBsZXQgbGFzdE9wZXJhdGlvbiA9IG51bGw7XG4gICAgY29uc3Qgb3BlcmF0aW9ucyA9IFtdO1xuICAgIGZvciAoY29uc3QgYmxvY2tNYXBGaWxlIG9mIG5ld0Jsb2NrTWFwLmZpbGVzKSB7XG4gICAgICAgIGNvbnN0IG5hbWUgPSBibG9ja01hcEZpbGUubmFtZTtcbiAgICAgICAgY29uc3Qgb2xkRW50cnkgPSBvbGRFbnRyeU1hcC5nZXQobmFtZSk7XG4gICAgICAgIGlmIChvbGRFbnRyeSA9PSBudWxsKSB7XG4gICAgICAgICAgICAvLyBuZXcgZmlsZVxuICAgICAgICAgICAgb3BlcmF0aW9ucy5wdXNoKHtcbiAgICAgICAgICAgICAgICBraW5kOiBPcGVyYXRpb25LaW5kLkRPV05MT0FELFxuICAgICAgICAgICAgICAgIHN0YXJ0OiBibG9ja01hcEZpbGUub2Zmc2V0LFxuICAgICAgICAgICAgICAgIGVuZDogYmxvY2tNYXBGaWxlLm9mZnNldCArIGJsb2NrTWFwRmlsZS5zaXplcy5yZWR1Y2UoKGFjY3VtdWxhdG9yLCBjdXJyZW50VmFsdWUpID0+IGFjY3VtdWxhdG9yICsgY3VycmVudFZhbHVlKVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBuZXdGaWxlID0gbmFtZVRvTmV3QmxvY2tzLmdldChuYW1lKTtcbiAgICAgICAgbGV0IGNoYW5nZWRCbG9ja0NvdW50ID0gMDtcbiAgICAgICAgY29uc3QgeyBjaGVja3N1bVRvT2Zmc2V0OiBjaGVja3N1bVRvT2xkT2Zmc2V0LCBjaGVja3N1bVRvT2xkU2l6ZSB9ID0gYnVpbGRDaGVja3N1bU1hcChuYW1lVG9PbGRCbG9ja3MuZ2V0KG5hbWUpLCBvbGRFbnRyeS5vZmZzZXQpO1xuICAgICAgICBsZXQgbmV3T2Zmc2V0ID0gYmxvY2tNYXBGaWxlLm9mZnNldDtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBuZXdGaWxlLmNoZWNrc3Vtcy5sZW5ndGg7IG5ld09mZnNldCArPSBuZXdGaWxlLnNpemVzW2ldLCBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IGJsb2NrU2l6ZSA9IG5ld0ZpbGUuc2l6ZXNbaV07XG4gICAgICAgICAgICBjb25zdCBjaGVja3N1bSA9IG5ld0ZpbGUuY2hlY2tzdW1zW2ldO1xuICAgICAgICAgICAgbGV0IG9sZE9mZnNldCA9IGNoZWNrc3VtVG9PbGRPZmZzZXQuZ2V0KGNoZWNrc3VtKTtcbiAgICAgICAgICAgIGlmIChvbGRPZmZzZXQgIT0gbnVsbCAmJiBjaGVja3N1bVRvT2xkU2l6ZS5nZXQoY2hlY2tzdW0pICE9PSBibG9ja1NpemUpIHtcbiAgICAgICAgICAgICAgICBsb2dnZXIud2FybihgQ2hlY2tzdW0gKFwiJHtjaGVja3N1bX1cIikgbWF0Y2hlcywgYnV0IHNpemUgZGlmZmVycyAob2xkOiAke2NoZWNrc3VtVG9PbGRTaXplLmdldChjaGVja3N1bSl9LCBuZXc6ICR7YmxvY2tTaXplfSlgKTtcbiAgICAgICAgICAgICAgICBvbGRPZmZzZXQgPSBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG9sZE9mZnNldCA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgY2hhbmdlZEJsb2NrQ291bnQrKztcbiAgICAgICAgICAgICAgICBpZiAobGFzdE9wZXJhdGlvbiA9PSBudWxsIHx8IGxhc3RPcGVyYXRpb24ua2luZCAhPT0gT3BlcmF0aW9uS2luZC5ET1dOTE9BRCB8fCBsYXN0T3BlcmF0aW9uLmVuZCAhPT0gbmV3T2Zmc2V0KSB7XG4gICAgICAgICAgICAgICAgICAgIGxhc3RPcGVyYXRpb24gPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBraW5kOiBPcGVyYXRpb25LaW5kLkRPV05MT0FELFxuICAgICAgICAgICAgICAgICAgICAgICAgc3RhcnQ6IG5ld09mZnNldCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGVuZDogbmV3T2Zmc2V0ICsgYmxvY2tTaXplXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIG9wZXJhdGlvbnMucHVzaChsYXN0T3BlcmF0aW9uKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBsYXN0T3BlcmF0aW9uLmVuZCArPSBibG9ja1NpemU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmIChsYXN0T3BlcmF0aW9uID09IG51bGwgfHwgbGFzdE9wZXJhdGlvbi5raW5kICE9PSBPcGVyYXRpb25LaW5kLkNPUFkgfHwgbGFzdE9wZXJhdGlvbi5lbmQgIT09IG9sZE9mZnNldCkge1xuICAgICAgICAgICAgICAgIGxhc3RPcGVyYXRpb24gPSB7XG4gICAgICAgICAgICAgICAgICAgIGtpbmQ6IE9wZXJhdGlvbktpbmQuQ09QWSxcbiAgICAgICAgICAgICAgICAgICAgc3RhcnQ6IG9sZE9mZnNldCxcbiAgICAgICAgICAgICAgICAgICAgZW5kOiBvbGRPZmZzZXQgKyBibG9ja1NpemVcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIG9wZXJhdGlvbnMucHVzaChsYXN0T3BlcmF0aW9uKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgbGFzdE9wZXJhdGlvbi5lbmQgKz0gYmxvY2tTaXplO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChjaGFuZ2VkQmxvY2tDb3VudCA+IDApIHtcbiAgICAgICAgICAgIGxvZ2dlci5pbmZvKGBGaWxlJHtibG9ja01hcEZpbGUubmFtZSA9PT0gXCJmaWxlXCIgPyBcIlwiIDogXCIgXCIgKyBibG9ja01hcEZpbGUubmFtZX0gaGFzICR7Y2hhbmdlZEJsb2NrQ291bnR9IGNoYW5nZWQgYmxvY2tzYCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG9wZXJhdGlvbnM7XG59XG5mdW5jdGlvbiBidWlsZENoZWNrc3VtTWFwKGZpbGUsIGZpbGVPZmZzZXQpIHtcbiAgICBjb25zdCBjaGVja3N1bVRvT2Zmc2V0ID0gbmV3IE1hcCgpO1xuICAgIGNvbnN0IGNoZWNrc3VtVG9TaXplID0gbmV3IE1hcCgpO1xuICAgIGxldCBvZmZzZXQgPSBmaWxlT2Zmc2V0O1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZmlsZS5jaGVja3N1bXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3QgY2hlY2tzdW0gPSBmaWxlLmNoZWNrc3Vtc1tpXTtcbiAgICAgICAgY29uc3Qgc2l6ZSA9IGZpbGUuc2l6ZXNbaV07XG4gICAgICAgIGNoZWNrc3VtVG9PZmZzZXQuc2V0KGNoZWNrc3VtLCBvZmZzZXQpO1xuICAgICAgICBjaGVja3N1bVRvU2l6ZS5zZXQoY2hlY2tzdW0sIHNpemUpO1xuICAgICAgICBvZmZzZXQgKz0gc2l6ZTtcbiAgICB9XG4gICAgcmV0dXJuIHsgY2hlY2tzdW1Ub09mZnNldCwgY2hlY2tzdW1Ub09sZFNpemU6IGNoZWNrc3VtVG9TaXplIH07XG59XG5mdW5jdGlvbiBidWlsZEVudHJ5TWFwKGxpc3QpIHtcbiAgICBjb25zdCByZXN1bHQgPSBuZXcgTWFwKCk7XG4gICAgZm9yIChjb25zdCBpdGVtIG9mIGxpc3QpIHtcbiAgICAgICAgcmVzdWx0LnNldChpdGVtLm5hbWUsIGl0ZW0pO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gYnVpbGRCbG9ja0ZpbGVNYXAobGlzdCkge1xuICAgIGNvbnN0IHJlc3VsdCA9IG5ldyBNYXAoKTtcbiAgICBmb3IgKGNvbnN0IGl0ZW0gb2YgbGlzdCkge1xuICAgICAgICByZXN1bHQuc2V0KGl0ZW0ubmFtZSwgaXRlbSk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1kb3dubG9hZFBsYW5CdWlsZGVyLmpzLm1hcFxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9lbGVjdHJvbi11cGRhdGVyL291dC9kaWZmZXJlbnRpYWxEb3dubG9hZGVyL2Rvd25sb2FkUGxhbkJ1aWxkZXIuanMiLCIndXNlIHN0cmljdCc7XG5cbnZhciBmb3JtYXQgICAgICAgICAgPSByZXF1aXJlKCcuLi9mb3JtYXQnKTtcbnZhciBvcmlnaW5hbENvbnNvbGUgPSByZXF1aXJlKCcuLi9vcmlnaW5hbC1jb25zb2xlJyk7XG5cbnRyYW5zcG9ydC5sZXZlbCAgPSAnc2lsbHknO1xudHJhbnNwb3J0LmZvcm1hdCA9ICdbe2h9OntpfTp7c30ue21zfV0gW3tsZXZlbH1dIHt0ZXh0fSc7XG5cbm1vZHVsZS5leHBvcnRzID0gdHJhbnNwb3J0O1xuXG5mdW5jdGlvbiB0cmFuc3BvcnQobXNnKSB7XG4gIHZhciB0ZXh0ID0gZm9ybWF0LmZvcm1hdChtc2csIHRyYW5zcG9ydC5mb3JtYXQpO1xuICBpZiAob3JpZ2luYWxDb25zb2xlW21zZy5sZXZlbF0pIHtcbiAgICBvcmlnaW5hbENvbnNvbGVbbXNnLmxldmVsXSh0ZXh0KTtcbiAgfSBlbHNlIHtcbiAgICBvcmlnaW5hbENvbnNvbGUubG9nKHRleHQpO1xuICB9XG59XG5cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9lbGVjdHJvbi1sb2cvbGliL3RyYW5zcG9ydHMvY29uc29sZS5qcyIsIid1c2Ugc3RyaWN0JztcblxudmFyIHV0aWwgPSByZXF1aXJlKCd1dGlsJyk7XG52YXIgRU9MICA9IHJlcXVpcmUoJ29zJykuRU9MO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgZm9ybWF0OiBmb3JtYXQsXG4gIGZvcm1hdFRpbWVab25lOiBmb3JtYXRUaW1lWm9uZSxcbiAgcGFkOiBwYWQsXG4gIHN0cmluZ2lmeUFycmF5OiBzdHJpbmdpZnlBcnJheVxufTtcblxuZnVuY3Rpb24gZm9ybWF0KG1zZywgZm9ybWF0dGVyKSB7XG4gIGlmICh0eXBlb2YgZm9ybWF0dGVyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIGZvcm1hdHRlcihtc2cpO1xuICB9XG5cbiAgdmFyIGRhdGUgPSBtc2cuZGF0ZTtcblxuICByZXR1cm4gZm9ybWF0dGVyXG4gICAgLnJlcGxhY2UoJ3tsZXZlbH0nLCBtc2cubGV2ZWwpXG4gICAgLnJlcGxhY2UoJ3t0ZXh0fScsIHN0cmluZ2lmeUFycmF5KG1zZy5kYXRhKSlcbiAgICAucmVwbGFjZSgne3l9JywgZGF0ZS5nZXRGdWxsWWVhcigpKVxuICAgIC5yZXBsYWNlKCd7bX0nLCBwYWQoZGF0ZS5nZXRNb250aCgpICsgMSkpXG4gICAgLnJlcGxhY2UoJ3tkfScsIHBhZChkYXRlLmdldERhdGUoKSkpXG4gICAgLnJlcGxhY2UoJ3tofScsIHBhZChkYXRlLmdldEhvdXJzKCkpKVxuICAgIC5yZXBsYWNlKCd7aX0nLCBwYWQoZGF0ZS5nZXRNaW51dGVzKCkpKVxuICAgIC5yZXBsYWNlKCd7c30nLCBwYWQoZGF0ZS5nZXRTZWNvbmRzKCkpKVxuICAgIC5yZXBsYWNlKCd7bXN9JywgcGFkKGRhdGUuZ2V0TWlsbGlzZWNvbmRzKCksIDMpKVxuICAgIC5yZXBsYWNlKCd7en0nLCBmb3JtYXRUaW1lWm9uZShkYXRlLmdldFRpbWV6b25lT2Zmc2V0KCkpKTtcbn1cblxuZnVuY3Rpb24gc3RyaW5naWZ5QXJyYXkoZGF0YSkge1xuICBkYXRhID0gZGF0YS5tYXAoZnVuY3Rpb24gZm9ybWF0RXJyb3JzKGFyZykge1xuICAgIHJldHVybiBhcmcgaW5zdGFuY2VvZiBFcnJvciA/IGFyZy5zdGFjayArIEVPTCA6IGFyZztcbiAgfSk7XG4gIHJldHVybiB1dGlsLmZvcm1hdC5hcHBseSh1dGlsLCBkYXRhKTtcbn1cblxuZnVuY3Rpb24gcGFkKG51bWJlciwgemVyb3MpIHtcbiAgemVyb3MgPSB6ZXJvcyB8fCAyO1xuICByZXR1cm4gKG5ldyBBcnJheSh6ZXJvcyArIDEpLmpvaW4oJzAnKSArIG51bWJlcikuc3Vic3RyKC16ZXJvcywgemVyb3MpO1xufVxuXG5mdW5jdGlvbiBmb3JtYXRUaW1lWm9uZShtaW51dGVzT2Zmc2V0KSB7XG4gIHZhciBtID0gTWF0aC5hYnMobWludXRlc09mZnNldCk7XG4gIHJldHVybiAobWludXRlc09mZnNldCA+PSAwID8gJy0nIDogJysnKSArXG4gICAgcGFkKE1hdGguZmxvb3IobSAvIDYwKSkgKyAnOicgK1xuICAgIHBhZChtICUgNjApO1xufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2VsZWN0cm9uLWxvZy9saWIvZm9ybWF0LmpzIiwiXCJ1c2Ugc3RyaWN0XCI7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKE5FWFRfRklMVEVSKSB7XG52YXIgdXRpbCA9IHJlcXVpcmUoXCIuL3V0aWxcIik7XG52YXIgZ2V0S2V5cyA9IHJlcXVpcmUoXCIuL2VzNVwiKS5rZXlzO1xudmFyIHRyeUNhdGNoID0gdXRpbC50cnlDYXRjaDtcbnZhciBlcnJvck9iaiA9IHV0aWwuZXJyb3JPYmo7XG5cbmZ1bmN0aW9uIGNhdGNoRmlsdGVyKGluc3RhbmNlcywgY2IsIHByb21pc2UpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oZSkge1xuICAgICAgICB2YXIgYm91bmRUbyA9IHByb21pc2UuX2JvdW5kVmFsdWUoKTtcbiAgICAgICAgcHJlZGljYXRlTG9vcDogZm9yICh2YXIgaSA9IDA7IGkgPCBpbnN0YW5jZXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIHZhciBpdGVtID0gaW5zdGFuY2VzW2ldO1xuXG4gICAgICAgICAgICBpZiAoaXRlbSA9PT0gRXJyb3IgfHxcbiAgICAgICAgICAgICAgICAoaXRlbSAhPSBudWxsICYmIGl0ZW0ucHJvdG90eXBlIGluc3RhbmNlb2YgRXJyb3IpKSB7XG4gICAgICAgICAgICAgICAgaWYgKGUgaW5zdGFuY2VvZiBpdGVtKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnlDYXRjaChjYikuY2FsbChib3VuZFRvLCBlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBpdGVtID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgICAgICB2YXIgbWF0Y2hlc1ByZWRpY2F0ZSA9IHRyeUNhdGNoKGl0ZW0pLmNhbGwoYm91bmRUbywgZSk7XG4gICAgICAgICAgICAgICAgaWYgKG1hdGNoZXNQcmVkaWNhdGUgPT09IGVycm9yT2JqKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBtYXRjaGVzUHJlZGljYXRlO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAobWF0Y2hlc1ByZWRpY2F0ZSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ5Q2F0Y2goY2IpLmNhbGwoYm91bmRUbywgZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmICh1dGlsLmlzT2JqZWN0KGUpKSB7XG4gICAgICAgICAgICAgICAgdmFyIGtleXMgPSBnZXRLZXlzKGl0ZW0pO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwga2V5cy5sZW5ndGg7ICsraikge1xuICAgICAgICAgICAgICAgICAgICB2YXIga2V5ID0ga2V5c1tqXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGl0ZW1ba2V5XSAhPSBlW2tleV0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlIHByZWRpY2F0ZUxvb3A7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRyeUNhdGNoKGNiKS5jYWxsKGJvdW5kVG8sIGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBORVhUX0ZJTFRFUjtcbiAgICB9O1xufVxuXG5yZXR1cm4gY2F0Y2hGaWx0ZXI7XG59O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2JsdWViaXJkL2pzL3JlbGVhc2UvY2F0Y2hfZmlsdGVyLmpzIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgdXRpbCA9IHJlcXVpcmUoXCIuL3V0aWxcIik7XG52YXIgbWF5YmVXcmFwQXNFcnJvciA9IHV0aWwubWF5YmVXcmFwQXNFcnJvcjtcbnZhciBlcnJvcnMgPSByZXF1aXJlKFwiLi9lcnJvcnNcIik7XG52YXIgT3BlcmF0aW9uYWxFcnJvciA9IGVycm9ycy5PcGVyYXRpb25hbEVycm9yO1xudmFyIGVzNSA9IHJlcXVpcmUoXCIuL2VzNVwiKTtcblxuZnVuY3Rpb24gaXNVbnR5cGVkRXJyb3Iob2JqKSB7XG4gICAgcmV0dXJuIG9iaiBpbnN0YW5jZW9mIEVycm9yICYmXG4gICAgICAgIGVzNS5nZXRQcm90b3R5cGVPZihvYmopID09PSBFcnJvci5wcm90b3R5cGU7XG59XG5cbnZhciByRXJyb3JLZXkgPSAvXig/Om5hbWV8bWVzc2FnZXxzdGFja3xjYXVzZSkkLztcbmZ1bmN0aW9uIHdyYXBBc09wZXJhdGlvbmFsRXJyb3Iob2JqKSB7XG4gICAgdmFyIHJldDtcbiAgICBpZiAoaXNVbnR5cGVkRXJyb3Iob2JqKSkge1xuICAgICAgICByZXQgPSBuZXcgT3BlcmF0aW9uYWxFcnJvcihvYmopO1xuICAgICAgICByZXQubmFtZSA9IG9iai5uYW1lO1xuICAgICAgICByZXQubWVzc2FnZSA9IG9iai5tZXNzYWdlO1xuICAgICAgICByZXQuc3RhY2sgPSBvYmouc3RhY2s7XG4gICAgICAgIHZhciBrZXlzID0gZXM1LmtleXMob2JqKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICB2YXIga2V5ID0ga2V5c1tpXTtcbiAgICAgICAgICAgIGlmICghckVycm9yS2V5LnRlc3Qoa2V5KSkge1xuICAgICAgICAgICAgICAgIHJldFtrZXldID0gb2JqW2tleV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICB9XG4gICAgdXRpbC5tYXJrQXNPcmlnaW5hdGluZ0Zyb21SZWplY3Rpb24ob2JqKTtcbiAgICByZXR1cm4gb2JqO1xufVxuXG5mdW5jdGlvbiBub2RlYmFja0ZvclByb21pc2UocHJvbWlzZSwgbXVsdGlBcmdzKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKGVyciwgdmFsdWUpIHtcbiAgICAgICAgaWYgKHByb21pc2UgPT09IG51bGwpIHJldHVybjtcbiAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgdmFyIHdyYXBwZWQgPSB3cmFwQXNPcGVyYXRpb25hbEVycm9yKG1heWJlV3JhcEFzRXJyb3IoZXJyKSk7XG4gICAgICAgICAgICBwcm9taXNlLl9hdHRhY2hFeHRyYVRyYWNlKHdyYXBwZWQpO1xuICAgICAgICAgICAgcHJvbWlzZS5fcmVqZWN0KHdyYXBwZWQpO1xuICAgICAgICB9IGVsc2UgaWYgKCFtdWx0aUFyZ3MpIHtcbiAgICAgICAgICAgIHByb21pc2UuX2Z1bGZpbGwodmFsdWUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFyICRfbGVuID0gYXJndW1lbnRzLmxlbmd0aDt2YXIgYXJncyA9IG5ldyBBcnJheShNYXRoLm1heCgkX2xlbiAtIDEsIDApKTsgZm9yKHZhciAkX2kgPSAxOyAkX2kgPCAkX2xlbjsgKyskX2kpIHthcmdzWyRfaSAtIDFdID0gYXJndW1lbnRzWyRfaV07fTtcbiAgICAgICAgICAgIHByb21pc2UuX2Z1bGZpbGwoYXJncyk7XG4gICAgICAgIH1cbiAgICAgICAgcHJvbWlzZSA9IG51bGw7XG4gICAgfTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBub2RlYmFja0ZvclByb21pc2U7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvYmx1ZWJpcmQvanMvcmVsZWFzZS9ub2RlYmFjay5qcyIsIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLkNhbmNlbGxhdGlvbkVycm9yID0gZXhwb3J0cy5DYW5jZWxsYXRpb25Ub2tlbiA9IHVuZGVmaW5lZDtcblxudmFyIF9ibHVlYmlyZExzdDtcblxuZnVuY3Rpb24gX2xvYWRfYmx1ZWJpcmRMc3QoKSB7XG4gICAgcmV0dXJuIF9ibHVlYmlyZExzdCA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcImJsdWViaXJkLWxzdFwiKSk7XG59XG5cbnZhciBfZXZlbnRzO1xuXG5mdW5jdGlvbiBfbG9hZF9ldmVudHMoKSB7XG4gICAgcmV0dXJuIF9ldmVudHMgPSByZXF1aXJlKFwiZXZlbnRzXCIpO1xufVxuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5jbGFzcyBDYW5jZWxsYXRpb25Ub2tlbiBleHRlbmRzIChfZXZlbnRzIHx8IF9sb2FkX2V2ZW50cygpKS5FdmVudEVtaXR0ZXIge1xuICAgIC8vIGJhYmVsIGNhbm5vdCBjb21waWxlIC4uLiBjb3JyZWN0bHkgZm9yIHN1cGVyIGNhbGxzXG4gICAgY29uc3RydWN0b3IocGFyZW50KSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMucGFyZW50Q2FuY2VsSGFuZGxlciA9IG51bGw7XG4gICAgICAgIHRoaXMuX2NhbmNlbGxlZCA9IGZhbHNlO1xuICAgICAgICBpZiAocGFyZW50ICE9IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMucGFyZW50ID0gcGFyZW50O1xuICAgICAgICB9XG4gICAgfVxuICAgIGdldCBjYW5jZWxsZWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9jYW5jZWxsZWQgfHwgdGhpcy5fcGFyZW50ICE9IG51bGwgJiYgdGhpcy5fcGFyZW50LmNhbmNlbGxlZDtcbiAgICB9XG4gICAgc2V0IHBhcmVudCh2YWx1ZSkge1xuICAgICAgICB0aGlzLnJlbW92ZVBhcmVudENhbmNlbEhhbmRsZXIoKTtcbiAgICAgICAgdGhpcy5fcGFyZW50ID0gdmFsdWU7XG4gICAgICAgIHRoaXMucGFyZW50Q2FuY2VsSGFuZGxlciA9ICgpID0+IHRoaXMuY2FuY2VsKCk7XG4gICAgICAgIHRoaXMuX3BhcmVudC5vbkNhbmNlbCh0aGlzLnBhcmVudENhbmNlbEhhbmRsZXIpO1xuICAgIH1cbiAgICBjYW5jZWwoKSB7XG4gICAgICAgIHRoaXMuX2NhbmNlbGxlZCA9IHRydWU7XG4gICAgICAgIHRoaXMuZW1pdChcImNhbmNlbFwiKTtcbiAgICB9XG4gICAgb25DYW5jZWwoaGFuZGxlcikge1xuICAgICAgICBpZiAodGhpcy5jYW5jZWxsZWQpIHtcbiAgICAgICAgICAgIGhhbmRsZXIoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMub25jZShcImNhbmNlbFwiLCBoYW5kbGVyKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjcmVhdGVQcm9taXNlKGNhbGxiYWNrKSB7XG4gICAgICAgIGlmICh0aGlzLmNhbmNlbGxlZCkge1xuICAgICAgICAgICAgcmV0dXJuIChfYmx1ZWJpcmRMc3QgfHwgX2xvYWRfYmx1ZWJpcmRMc3QoKSkuZGVmYXVsdC5yZWplY3QobmV3IENhbmNlbGxhdGlvbkVycm9yKCkpO1xuICAgICAgICB9XG4gICAgICAgIGxldCBjYW5jZWxIYW5kbGVyID0gbnVsbDtcbiAgICAgICAgcmV0dXJuIG5ldyAoX2JsdWViaXJkTHN0IHx8IF9sb2FkX2JsdWViaXJkTHN0KCkpLmRlZmF1bHQoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgbGV0IGFkZGVkQ2FuY2VsSGFuZGxlciA9IG51bGw7XG4gICAgICAgICAgICBjYW5jZWxIYW5kbGVyID0gKCkgPT4ge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChhZGRlZENhbmNlbEhhbmRsZXIgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYWRkZWRDYW5jZWxIYW5kbGVyKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBhZGRlZENhbmNlbEhhbmRsZXIgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgICAgICAgcmVqZWN0KG5ldyBDYW5jZWxsYXRpb25FcnJvcigpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgaWYgKHRoaXMuY2FuY2VsbGVkKSB7XG4gICAgICAgICAgICAgICAgY2FuY2VsSGFuZGxlcigpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMub25DYW5jZWwoY2FuY2VsSGFuZGxlcik7XG4gICAgICAgICAgICBjYWxsYmFjayhyZXNvbHZlLCByZWplY3QsIGNhbGxiYWNrID0+IHtcbiAgICAgICAgICAgICAgICBhZGRlZENhbmNlbEhhbmRsZXIgPSBjYWxsYmFjaztcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KS5maW5hbGx5KCgpID0+IHtcbiAgICAgICAgICAgIGlmIChjYW5jZWxIYW5kbGVyICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnJlbW92ZUxpc3RlbmVyKFwiY2FuY2VsXCIsIGNhbmNlbEhhbmRsZXIpO1xuICAgICAgICAgICAgICAgIGNhbmNlbEhhbmRsZXIgPSBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgcmVtb3ZlUGFyZW50Q2FuY2VsSGFuZGxlcigpIHtcbiAgICAgICAgY29uc3QgcGFyZW50ID0gdGhpcy5fcGFyZW50O1xuICAgICAgICBpZiAocGFyZW50ICE9IG51bGwgJiYgdGhpcy5wYXJlbnRDYW5jZWxIYW5kbGVyICE9IG51bGwpIHtcbiAgICAgICAgICAgIHBhcmVudC5yZW1vdmVMaXN0ZW5lcihcImNhbmNlbFwiLCB0aGlzLnBhcmVudENhbmNlbEhhbmRsZXIpO1xuICAgICAgICAgICAgdGhpcy5wYXJlbnRDYW5jZWxIYW5kbGVyID0gbnVsbDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBkaXNwb3NlKCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgdGhpcy5yZW1vdmVQYXJlbnRDYW5jZWxIYW5kbGVyKCk7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICB0aGlzLnJlbW92ZUFsbExpc3RlbmVycygpO1xuICAgICAgICAgICAgdGhpcy5fcGFyZW50ID0gbnVsbDtcbiAgICAgICAgfVxuICAgIH1cbn1cbmV4cG9ydHMuQ2FuY2VsbGF0aW9uVG9rZW4gPSBDYW5jZWxsYXRpb25Ub2tlbjtcbmNsYXNzIENhbmNlbGxhdGlvbkVycm9yIGV4dGVuZHMgRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlcihcIkNhbmNlbGxlZFwiKTtcbiAgICB9XG59XG5leHBvcnRzLkNhbmNlbGxhdGlvbkVycm9yID0gQ2FuY2VsbGF0aW9uRXJyb3I7IC8vIyBzb3VyY2VNYXBwaW5nVVJMPUNhbmNlbGxhdGlvblRva2VuLmpzLm1hcFxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9lbGVjdHJvbi11cGRhdGVyL25vZGVfbW9kdWxlcy9idWlsZGVyLXV0aWwtcnVudGltZS9vdXQvQ2FuY2VsbGF0aW9uVG9rZW4uanMiLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCJldmVudHNcIik7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gZXh0ZXJuYWwgXCJldmVudHNcIlxuLy8gbW9kdWxlIGlkID0gNDFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuRGlnZXN0VHJhbnNmb3JtID0gZXhwb3J0cy5IdHRwRXhlY3V0b3IgPSBleHBvcnRzLkh0dHBFcnJvciA9IHVuZGVmaW5lZDtcbmV4cG9ydHMuY3JlYXRlSHR0cEVycm9yID0gY3JlYXRlSHR0cEVycm9yO1xuZXhwb3J0cy5wYXJzZUpzb24gPSBwYXJzZUpzb247XG5leHBvcnRzLmNvbmZpZ3VyZVJlcXVlc3RPcHRpb25zRnJvbVVybCA9IGNvbmZpZ3VyZVJlcXVlc3RPcHRpb25zRnJvbVVybDtcbmV4cG9ydHMuc2FmZUdldEhlYWRlciA9IHNhZmVHZXRIZWFkZXI7XG5leHBvcnRzLmNvbmZpZ3VyZVJlcXVlc3RPcHRpb25zID0gY29uZmlndXJlUmVxdWVzdE9wdGlvbnM7XG5leHBvcnRzLnNhZmVTdHJpbmdpZnlKc29uID0gc2FmZVN0cmluZ2lmeUpzb247XG5cbnZhciBfY3J5cHRvO1xuXG5mdW5jdGlvbiBfbG9hZF9jcnlwdG8oKSB7XG4gICAgcmV0dXJuIF9jcnlwdG8gPSByZXF1aXJlKFwiY3J5cHRvXCIpO1xufVxuXG52YXIgX2RlYnVnMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcImRlYnVnXCIpKTtcblxudmFyIF9mc0V4dHJhUDtcblxuZnVuY3Rpb24gX2xvYWRfZnNFeHRyYVAoKSB7XG4gICAgcmV0dXJuIF9mc0V4dHJhUCA9IHJlcXVpcmUoXCJmcy1leHRyYS1wXCIpO1xufVxuXG52YXIgX3N0cmVhbTtcblxuZnVuY3Rpb24gX2xvYWRfc3RyZWFtKCkge1xuICAgIHJldHVybiBfc3RyZWFtID0gcmVxdWlyZShcInN0cmVhbVwiKTtcbn1cblxudmFyIF91cmw7XG5cbmZ1bmN0aW9uIF9sb2FkX3VybCgpIHtcbiAgICByZXR1cm4gX3VybCA9IHJlcXVpcmUoXCJ1cmxcIik7XG59XG5cbnZhciBfQ2FuY2VsbGF0aW9uVG9rZW47XG5cbmZ1bmN0aW9uIF9sb2FkX0NhbmNlbGxhdGlvblRva2VuKCkge1xuICAgIHJldHVybiBfQ2FuY2VsbGF0aW9uVG9rZW4gPSByZXF1aXJlKFwiLi9DYW5jZWxsYXRpb25Ub2tlblwiKTtcbn1cblxudmFyIF9pbmRleDtcblxuZnVuY3Rpb24gX2xvYWRfaW5kZXgoKSB7XG4gICAgcmV0dXJuIF9pbmRleCA9IHJlcXVpcmUoXCIuL2luZGV4XCIpO1xufVxuXG52YXIgX1Byb2dyZXNzQ2FsbGJhY2tUcmFuc2Zvcm07XG5cbmZ1bmN0aW9uIF9sb2FkX1Byb2dyZXNzQ2FsbGJhY2tUcmFuc2Zvcm0oKSB7XG4gICAgcmV0dXJuIF9Qcm9ncmVzc0NhbGxiYWNrVHJhbnNmb3JtID0gcmVxdWlyZShcIi4vUHJvZ3Jlc3NDYWxsYmFja1RyYW5zZm9ybVwiKTtcbn1cblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuY29uc3QgZGVidWcgPSAoMCwgX2RlYnVnMi5kZWZhdWx0KShcImVsZWN0cm9uLWJ1aWxkZXJcIik7XG5mdW5jdGlvbiBjcmVhdGVIdHRwRXJyb3IocmVzcG9uc2UsIGRlc2NyaXB0aW9uID0gbnVsbCkge1xuICAgIHJldHVybiBuZXcgSHR0cEVycm9yKHJlc3BvbnNlLnN0YXR1c0NvZGUgfHwgLTEsIGAke3Jlc3BvbnNlLnN0YXR1c0NvZGV9ICR7cmVzcG9uc2Uuc3RhdHVzTWVzc2FnZX1gICsgKGRlc2NyaXB0aW9uID09IG51bGwgPyBcIlwiIDogXCJcXG5cIiArIEpTT04uc3RyaW5naWZ5KGRlc2NyaXB0aW9uLCBudWxsLCBcIiAgXCIpKSArIFwiXFxuSGVhZGVyczogXCIgKyBzYWZlU3RyaW5naWZ5SnNvbihyZXNwb25zZS5oZWFkZXJzKSwgZGVzY3JpcHRpb24pO1xufVxuY29uc3QgSFRUUF9TVEFUVVNfQ09ERVMgPSBuZXcgTWFwKFtbNDI5LCBcIlRvbyBtYW55IHJlcXVlc3RzXCJdLCBbNDAwLCBcIkJhZCByZXF1ZXN0XCJdLCBbNDAzLCBcIkZvcmJpZGRlblwiXSwgWzQwNCwgXCJOb3QgZm91bmRcIl0sIFs0MDUsIFwiTWV0aG9kIG5vdCBhbGxvd2VkXCJdLCBbNDA2LCBcIk5vdCBhY2NlcHRhYmxlXCJdLCBbNDA4LCBcIlJlcXVlc3QgdGltZW91dFwiXSwgWzQxMywgXCJSZXF1ZXN0IGVudGl0eSB0b28gbGFyZ2VcIl0sIFs1MDAsIFwiSW50ZXJuYWwgc2VydmVyIGVycm9yXCJdLCBbNTAyLCBcIkJhZCBnYXRld2F5XCJdLCBbNTAzLCBcIlNlcnZpY2UgdW5hdmFpbGFibGVcIl0sIFs1MDQsIFwiR2F0ZXdheSB0aW1lb3V0XCJdLCBbNTA1LCBcIkhUVFAgdmVyc2lvbiBub3Qgc3VwcG9ydGVkXCJdXSk7XG5jbGFzcyBIdHRwRXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gICAgY29uc3RydWN0b3Ioc3RhdHVzQ29kZSwgbWVzc2FnZSA9IGBIVFRQIGVycm9yOiAke0hUVFBfU1RBVFVTX0NPREVTLmdldChzdGF0dXNDb2RlKSB8fCBzdGF0dXNDb2RlfWAsIGRlc2NyaXB0aW9uID0gbnVsbCkge1xuICAgICAgICBzdXBlcihtZXNzYWdlKTtcbiAgICAgICAgdGhpcy5zdGF0dXNDb2RlID0gc3RhdHVzQ29kZTtcbiAgICAgICAgdGhpcy5kZXNjcmlwdGlvbiA9IGRlc2NyaXB0aW9uO1xuICAgICAgICB0aGlzLm5hbWUgPSBcIkh0dHBFcnJvclwiO1xuICAgIH1cbn1cbmV4cG9ydHMuSHR0cEVycm9yID0gSHR0cEVycm9yO1xuZnVuY3Rpb24gcGFyc2VKc29uKHJlc3VsdCkge1xuICAgIHJldHVybiByZXN1bHQudGhlbihpdCA9PiBpdCA9PSBudWxsIHx8IGl0Lmxlbmd0aCA9PT0gMCA/IG51bGwgOiBKU09OLnBhcnNlKGl0KSk7XG59XG5jbGFzcyBIdHRwRXhlY3V0b3Ige1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLm1heFJlZGlyZWN0cyA9IDEwO1xuICAgIH1cbiAgICByZXF1ZXN0KG9wdGlvbnMsIGNhbmNlbGxhdGlvblRva2VuID0gbmV3IChfQ2FuY2VsbGF0aW9uVG9rZW4gfHwgX2xvYWRfQ2FuY2VsbGF0aW9uVG9rZW4oKSkuQ2FuY2VsbGF0aW9uVG9rZW4oKSwgZGF0YSkge1xuICAgICAgICBjb25maWd1cmVSZXF1ZXN0T3B0aW9ucyhvcHRpb25zKTtcbiAgICAgICAgY29uc3QgZW5jb2RlZERhdGEgPSBkYXRhID09IG51bGwgPyB1bmRlZmluZWQgOiBCdWZmZXIuZnJvbShKU09OLnN0cmluZ2lmeShkYXRhKSk7XG4gICAgICAgIGlmIChlbmNvZGVkRGF0YSAhPSBudWxsKSB7XG4gICAgICAgICAgICBvcHRpb25zLm1ldGhvZCA9IFwicG9zdFwiO1xuICAgICAgICAgICAgb3B0aW9ucy5oZWFkZXJzW1wiQ29udGVudC1UeXBlXCJdID0gXCJhcHBsaWNhdGlvbi9qc29uXCI7XG4gICAgICAgICAgICBvcHRpb25zLmhlYWRlcnNbXCJDb250ZW50LUxlbmd0aFwiXSA9IGVuY29kZWREYXRhLmxlbmd0aDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5kb0FwaVJlcXVlc3Qob3B0aW9ucywgY2FuY2VsbGF0aW9uVG9rZW4sIGl0ID0+IGl0LmVuZChlbmNvZGVkRGF0YSkpO1xuICAgIH1cbiAgICBkb0FwaVJlcXVlc3Qob3B0aW9ucywgY2FuY2VsbGF0aW9uVG9rZW4sIHJlcXVlc3RQcm9jZXNzb3IsIHJlZGlyZWN0Q291bnQgPSAwKSB7XG4gICAgICAgIGlmIChkZWJ1Zy5lbmFibGVkKSB7XG4gICAgICAgICAgICBkZWJ1ZyhgUmVxdWVzdDogJHtzYWZlU3RyaW5naWZ5SnNvbihvcHRpb25zKX1gKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY2FuY2VsbGF0aW9uVG9rZW4uY3JlYXRlUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0LCBvbkNhbmNlbCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgcmVxdWVzdCA9IHRoaXMuZG9SZXF1ZXN0KG9wdGlvbnMsIHJlc3BvbnNlID0+IHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmhhbmRsZVJlc3BvbnNlKHJlc3BvbnNlLCBvcHRpb25zLCBjYW5jZWxsYXRpb25Ub2tlbiwgcmVzb2x2ZSwgcmVqZWN0LCByZWRpcmVjdENvdW50LCByZXF1ZXN0UHJvY2Vzc29yKTtcbiAgICAgICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlamVjdChlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRoaXMuYWRkRXJyb3JBbmRUaW1lb3V0SGFuZGxlcnMocmVxdWVzdCwgcmVqZWN0KTtcbiAgICAgICAgICAgIHRoaXMuYWRkUmVkaXJlY3RIYW5kbGVycyhyZXF1ZXN0LCBvcHRpb25zLCByZWplY3QsIHJlZGlyZWN0Q291bnQsIG9wdGlvbnMgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuZG9BcGlSZXF1ZXN0KG9wdGlvbnMsIGNhbmNlbGxhdGlvblRva2VuLCByZXF1ZXN0UHJvY2Vzc29yLCByZWRpcmVjdENvdW50KS50aGVuKHJlc29sdmUpLmNhdGNoKHJlamVjdCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJlcXVlc3RQcm9jZXNzb3IocmVxdWVzdCwgcmVqZWN0KTtcbiAgICAgICAgICAgIG9uQ2FuY2VsKCgpID0+IHJlcXVlc3QuYWJvcnQoKSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvLyBub2luc3BlY3Rpb24gSlNVbnVzZWRMb2NhbFN5bWJvbHNcbiAgICBhZGRSZWRpcmVjdEhhbmRsZXJzKHJlcXVlc3QsIG9wdGlvbnMsIHJlamVjdCwgcmVkaXJlY3RDb3VudCwgaGFuZGxlcikge1xuICAgICAgICAvLyBub3QgcmVxdWlyZWQgZm9yIE5vZGVKU1xuICAgIH1cbiAgICBhZGRFcnJvckFuZFRpbWVvdXRIYW5kbGVycyhyZXF1ZXN0LCByZWplY3QpIHtcbiAgICAgICAgdGhpcy5hZGRUaW1lT3V0SGFuZGxlcihyZXF1ZXN0LCByZWplY3QpO1xuICAgICAgICByZXF1ZXN0Lm9uKFwiZXJyb3JcIiwgcmVqZWN0KTtcbiAgICAgICAgcmVxdWVzdC5vbihcImFib3J0ZWRcIiwgKCkgPT4ge1xuICAgICAgICAgICAgcmVqZWN0KG5ldyBFcnJvcihcIlJlcXVlc3QgaGFzIGJlZW4gYWJvcnRlZCBieSB0aGUgc2VydmVyXCIpKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGhhbmRsZVJlc3BvbnNlKHJlc3BvbnNlLCBvcHRpb25zLCBjYW5jZWxsYXRpb25Ub2tlbiwgcmVzb2x2ZSwgcmVqZWN0LCByZWRpcmVjdENvdW50LCByZXF1ZXN0UHJvY2Vzc29yKSB7XG4gICAgICAgIGlmIChkZWJ1Zy5lbmFibGVkKSB7XG4gICAgICAgICAgICBkZWJ1ZyhgUmVzcG9uc2U6ICR7cmVzcG9uc2Uuc3RhdHVzQ29kZX0gJHtyZXNwb25zZS5zdGF0dXNNZXNzYWdlfSwgcmVxdWVzdCBvcHRpb25zOiAke3NhZmVTdHJpbmdpZnlKc29uKG9wdGlvbnMpfWApO1xuICAgICAgICB9XG4gICAgICAgIC8vIHdlIGhhbmRsZSBhbnkgb3RoZXIgPj0gNDAwIGVycm9yIG9uIHJlcXVlc3QgZW5kIChyZWFkIGRldGFpbGVkIG1lc3NhZ2UgaW4gdGhlIHJlc3BvbnNlIGJvZHkpXG4gICAgICAgIGlmIChyZXNwb25zZS5zdGF0dXNDb2RlID09PSA0MDQpIHtcbiAgICAgICAgICAgIC8vIGVycm9yIGlzIGNsZWFyLCB3ZSBkb24ndCBuZWVkIHRvIHJlYWQgZGV0YWlsZWQgZXJyb3IgZGVzY3JpcHRpb25cbiAgICAgICAgICAgIHJlamVjdChjcmVhdGVIdHRwRXJyb3IocmVzcG9uc2UsIGBtZXRob2Q6ICR7b3B0aW9ucy5tZXRob2R9IHVybDogJHtvcHRpb25zLnByb3RvY29sIHx8IFwiaHR0cHM6XCJ9Ly8ke29wdGlvbnMuaG9zdG5hbWV9JHtvcHRpb25zLnBhdGh9XG5cblBsZWFzZSBkb3VibGUgY2hlY2sgdGhhdCB5b3VyIGF1dGhlbnRpY2F0aW9uIHRva2VuIGlzIGNvcnJlY3QuIER1ZSB0byBzZWN1cml0eSByZWFzb25zIGFjdHVhbCBzdGF0dXMgbWF5YmUgbm90IHJlcG9ydGVkLCBidXQgNDA0LlxuYCkpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9IGVsc2UgaWYgKHJlc3BvbnNlLnN0YXR1c0NvZGUgPT09IDIwNCkge1xuICAgICAgICAgICAgLy8gb24gREVMRVRFIHJlcXVlc3RcbiAgICAgICAgICAgIHJlc29sdmUoKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByZWRpcmVjdFVybCA9IHNhZmVHZXRIZWFkZXIocmVzcG9uc2UsIFwibG9jYXRpb25cIik7XG4gICAgICAgIGlmIChyZWRpcmVjdFVybCAhPSBudWxsKSB7XG4gICAgICAgICAgICBpZiAocmVkaXJlY3RDb3VudCA+IDEwKSB7XG4gICAgICAgICAgICAgICAgcmVqZWN0KG5ldyBFcnJvcihcIlRvbyBtYW55IHJlZGlyZWN0cyAoPiAxMClcIikpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuZG9BcGlSZXF1ZXN0KEh0dHBFeGVjdXRvci5wcmVwYXJlUmVkaXJlY3RVcmxPcHRpb25zKHJlZGlyZWN0VXJsLCBvcHRpb25zKSwgY2FuY2VsbGF0aW9uVG9rZW4sIHJlcXVlc3RQcm9jZXNzb3IsIHJlZGlyZWN0Q291bnQpLnRoZW4ocmVzb2x2ZSkuY2F0Y2gocmVqZWN0KTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBsZXQgZGF0YSA9IFwiXCI7XG4gICAgICAgIHJlc3BvbnNlLnNldEVuY29kaW5nKFwidXRmOFwiKTtcbiAgICAgICAgcmVzcG9uc2Uub24oXCJkYXRhXCIsIGNodW5rID0+IGRhdGEgKz0gY2h1bmspO1xuICAgICAgICByZXNwb25zZS5vbihcImVuZFwiLCAoKSA9PiB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGlmIChyZXNwb25zZS5zdGF0dXNDb2RlICE9IG51bGwgJiYgcmVzcG9uc2Uuc3RhdHVzQ29kZSA+PSA0MDApIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgY29udGVudFR5cGUgPSBzYWZlR2V0SGVhZGVyKHJlc3BvbnNlLCBcImNvbnRlbnQtdHlwZVwiKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgaXNKc29uID0gY29udGVudFR5cGUgIT0gbnVsbCAmJiAoQXJyYXkuaXNBcnJheShjb250ZW50VHlwZSkgPyBjb250ZW50VHlwZS5maW5kKGl0ID0+IGl0LmluY2x1ZGVzKFwianNvblwiKSkgIT0gbnVsbCA6IGNvbnRlbnRUeXBlLmluY2x1ZGVzKFwianNvblwiKSk7XG4gICAgICAgICAgICAgICAgICAgIHJlamVjdChjcmVhdGVIdHRwRXJyb3IocmVzcG9uc2UsIGlzSnNvbiA/IEpTT04ucGFyc2UoZGF0YSkgOiBkYXRhKSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShkYXRhLmxlbmd0aCA9PT0gMCA/IG51bGwgOiBkYXRhKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgcmVqZWN0KGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgZG9Eb3dubG9hZChyZXF1ZXN0T3B0aW9ucywgZGVzdGluYXRpb24sIHJlZGlyZWN0Q291bnQsIG9wdGlvbnMsIGNhbGxiYWNrLCBvbkNhbmNlbCkge1xuICAgICAgICBjb25zdCByZXF1ZXN0ID0gdGhpcy5kb1JlcXVlc3QocmVxdWVzdE9wdGlvbnMsIHJlc3BvbnNlID0+IHtcbiAgICAgICAgICAgIGlmIChyZXNwb25zZS5zdGF0dXNDb2RlID49IDQwMCkge1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrKG5ldyBFcnJvcihgQ2Fubm90IGRvd25sb2FkIFwiJHtyZXF1ZXN0T3B0aW9ucy5wcm90b2NvbCB8fCBcImh0dHBzOlwifS8vJHtyZXF1ZXN0T3B0aW9ucy5ob3N0bmFtZX0ke3JlcXVlc3RPcHRpb25zLnBhdGh9XCIsIHN0YXR1cyAke3Jlc3BvbnNlLnN0YXR1c0NvZGV9OiAke3Jlc3BvbnNlLnN0YXR1c01lc3NhZ2V9YCkpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHJlZGlyZWN0VXJsID0gc2FmZUdldEhlYWRlcihyZXNwb25zZSwgXCJsb2NhdGlvblwiKTtcbiAgICAgICAgICAgIGlmIChyZWRpcmVjdFVybCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgaWYgKHJlZGlyZWN0Q291bnQgPCB0aGlzLm1heFJlZGlyZWN0cykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmRvRG93bmxvYWQoSHR0cEV4ZWN1dG9yLnByZXBhcmVSZWRpcmVjdFVybE9wdGlvbnMocmVkaXJlY3RVcmwsIHJlcXVlc3RPcHRpb25zKSwgZGVzdGluYXRpb24sIHJlZGlyZWN0Q291bnQrKywgb3B0aW9ucywgY2FsbGJhY2ssIG9uQ2FuY2VsKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayhuZXcgRXJyb3IoYFRvbyBtYW55IHJlZGlyZWN0cyAoPiAke3RoaXMubWF4UmVkaXJlY3RzfSlgKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbmZpZ3VyZVBpcGVzKG9wdGlvbnMsIHJlc3BvbnNlLCBkZXN0aW5hdGlvbiwgY2FsbGJhY2ssIG9wdGlvbnMuY2FuY2VsbGF0aW9uVG9rZW4pO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5hZGRFcnJvckFuZFRpbWVvdXRIYW5kbGVycyhyZXF1ZXN0LCBjYWxsYmFjayk7XG4gICAgICAgIHRoaXMuYWRkUmVkaXJlY3RIYW5kbGVycyhyZXF1ZXN0LCByZXF1ZXN0T3B0aW9ucywgY2FsbGJhY2ssIHJlZGlyZWN0Q291bnQsIHJlcXVlc3RPcHRpb25zID0+IHtcbiAgICAgICAgICAgIHRoaXMuZG9Eb3dubG9hZChyZXF1ZXN0T3B0aW9ucywgZGVzdGluYXRpb24sIHJlZGlyZWN0Q291bnQrKywgb3B0aW9ucywgY2FsbGJhY2ssIG9uQ2FuY2VsKTtcbiAgICAgICAgfSk7XG4gICAgICAgIG9uQ2FuY2VsKCgpID0+IHJlcXVlc3QuYWJvcnQoKSk7XG4gICAgICAgIHJlcXVlc3QuZW5kKCk7XG4gICAgfVxuICAgIGFkZFRpbWVPdXRIYW5kbGVyKHJlcXVlc3QsIGNhbGxiYWNrKSB7XG4gICAgICAgIHJlcXVlc3Qub24oXCJzb2NrZXRcIiwgc29ja2V0ID0+IHtcbiAgICAgICAgICAgIHNvY2tldC5zZXRUaW1lb3V0KDYwICogMTAwMCwgKCkgPT4ge1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrKG5ldyBFcnJvcihcIlJlcXVlc3QgdGltZWQgb3V0XCIpKTtcbiAgICAgICAgICAgICAgICByZXF1ZXN0LmFib3J0KCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHN0YXRpYyBwcmVwYXJlUmVkaXJlY3RVcmxPcHRpb25zKHJlZGlyZWN0VXJsLCBvcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IG5ld09wdGlvbnMgPSBjb25maWd1cmVSZXF1ZXN0T3B0aW9uc0Zyb21VcmwocmVkaXJlY3RVcmwsIE9iamVjdC5hc3NpZ24oe30sIG9wdGlvbnMpKTtcbiAgICAgICAgaWYgKG5ld09wdGlvbnMuaGVhZGVycyAhPSBudWxsICYmIG5ld09wdGlvbnMuaGVhZGVycy5BdXRob3JpemF0aW9uICE9IG51bGwgJiYgbmV3T3B0aW9ucy5oZWFkZXJzLkF1dGhvcml6YXRpb24uc3RhcnRzV2l0aChcInRva2VuXCIpKSB7XG4gICAgICAgICAgICBjb25zdCBwYXJzZWROZXdVcmwgPSBuZXcgKF91cmwgfHwgX2xvYWRfdXJsKCkpLlVSTChyZWRpcmVjdFVybCk7XG4gICAgICAgICAgICBpZiAocGFyc2VkTmV3VXJsLmhvc3RuYW1lLmVuZHNXaXRoKFwiLmFtYXpvbmF3cy5jb21cIikpIHtcbiAgICAgICAgICAgICAgICBkZWxldGUgbmV3T3B0aW9ucy5oZWFkZXJzLkF1dGhvcml6YXRpb247XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ld09wdGlvbnM7XG4gICAgfVxufVxuZXhwb3J0cy5IdHRwRXhlY3V0b3IgPSBIdHRwRXhlY3V0b3I7XG5mdW5jdGlvbiBjb25maWd1cmVSZXF1ZXN0T3B0aW9uc0Zyb21VcmwodXJsLCBvcHRpb25zKSB7XG4gICAgY29uc3QgcGFyc2VkVXJsID0gKDAsIChfdXJsIHx8IF9sb2FkX3VybCgpKS5wYXJzZSkodXJsKTtcbiAgICBvcHRpb25zLnByb3RvY29sID0gcGFyc2VkVXJsLnByb3RvY29sO1xuICAgIG9wdGlvbnMuaG9zdG5hbWUgPSBwYXJzZWRVcmwuaG9zdG5hbWU7XG4gICAgaWYgKHBhcnNlZFVybC5wb3J0ID09IG51bGwpIHtcbiAgICAgICAgaWYgKG9wdGlvbnMucG9ydCAhPSBudWxsKSB7XG4gICAgICAgICAgICBkZWxldGUgb3B0aW9ucy5wb3J0O1xuICAgICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgICAgb3B0aW9ucy5wb3J0ID0gcGFyc2VkVXJsLnBvcnQ7XG4gICAgfVxuICAgIG9wdGlvbnMucGF0aCA9IHBhcnNlZFVybC5wYXRoO1xuICAgIHJldHVybiBjb25maWd1cmVSZXF1ZXN0T3B0aW9ucyhvcHRpb25zKTtcbn1cbmNsYXNzIERpZ2VzdFRyYW5zZm9ybSBleHRlbmRzIChfc3RyZWFtIHx8IF9sb2FkX3N0cmVhbSgpKS5UcmFuc2Zvcm0ge1xuICAgIGNvbnN0cnVjdG9yKGV4cGVjdGVkLCBhbGdvcml0aG0gPSBcInNoYTUxMlwiLCBlbmNvZGluZyA9IFwiYmFzZTY0XCIpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5leHBlY3RlZCA9IGV4cGVjdGVkO1xuICAgICAgICB0aGlzLmFsZ29yaXRobSA9IGFsZ29yaXRobTtcbiAgICAgICAgdGhpcy5lbmNvZGluZyA9IGVuY29kaW5nO1xuICAgICAgICB0aGlzLmlzVmFsaWRhdGVPbkVuZCA9IHRydWU7XG4gICAgICAgIHRoaXMuZGlnZXN0ZXIgPSAoMCwgKF9jcnlwdG8gfHwgX2xvYWRfY3J5cHRvKCkpLmNyZWF0ZUhhc2gpKGFsZ29yaXRobSk7XG4gICAgfVxuICAgIC8vIG5vaW5zcGVjdGlvbiBKU1VudXNlZEdsb2JhbFN5bWJvbHNcbiAgICBnZXQgYWN0dWFsKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fYWN0dWFsO1xuICAgIH1cbiAgICAvLyBub2luc3BlY3Rpb24gSlNVbnVzZWRHbG9iYWxTeW1ib2xzXG4gICAgX3RyYW5zZm9ybShjaHVuaywgZW5jb2RpbmcsIGNhbGxiYWNrKSB7XG4gICAgICAgIHRoaXMuZGlnZXN0ZXIudXBkYXRlKGNodW5rKTtcbiAgICAgICAgY2FsbGJhY2sobnVsbCwgY2h1bmspO1xuICAgIH1cbiAgICAvLyBub2luc3BlY3Rpb24gSlNVbnVzZWRHbG9iYWxTeW1ib2xzXG4gICAgX2ZsdXNoKGNhbGxiYWNrKSB7XG4gICAgICAgIHRoaXMuX2FjdHVhbCA9IHRoaXMuZGlnZXN0ZXIuZGlnZXN0KHRoaXMuZW5jb2RpbmcpO1xuICAgICAgICBpZiAodGhpcy5pc1ZhbGlkYXRlT25FbmQpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgdGhpcy52YWxpZGF0ZSgpO1xuICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrKGUpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjYWxsYmFjayhudWxsKTtcbiAgICB9XG4gICAgdmFsaWRhdGUoKSB7XG4gICAgICAgIGlmICh0aGlzLl9hY3R1YWwgPT0gbnVsbCkge1xuICAgICAgICAgICAgdGhyb3cgKDAsIChfaW5kZXggfHwgX2xvYWRfaW5kZXgoKSkubmV3RXJyb3IpKFwiTm90IGZpbmlzaGVkIHlldFwiLCBcIkVSUl9TVFJFQU1fTk9UX0ZJTklTSEVEXCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLl9hY3R1YWwgIT09IHRoaXMuZXhwZWN0ZWQpIHtcbiAgICAgICAgICAgIHRocm93ICgwLCAoX2luZGV4IHx8IF9sb2FkX2luZGV4KCkpLm5ld0Vycm9yKShgJHt0aGlzLmFsZ29yaXRobX0gY2hlY2tzdW0gbWlzbWF0Y2gsIGV4cGVjdGVkICR7dGhpcy5leHBlY3RlZH0sIGdvdCAke3RoaXMuX2FjdHVhbH1gLCBcIkVSUl9DSEVDS1NVTV9NSVNNQVRDSFwiKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG59XG5leHBvcnRzLkRpZ2VzdFRyYW5zZm9ybSA9IERpZ2VzdFRyYW5zZm9ybTtcbmZ1bmN0aW9uIGNoZWNrU2hhMihzaGEySGVhZGVyLCBzaGEyLCBjYWxsYmFjaykge1xuICAgIGlmIChzaGEySGVhZGVyICE9IG51bGwgJiYgc2hhMiAhPSBudWxsKSB7XG4gICAgICAgIC8vIHRvZG8gd2h5IGJpbnRyYXkgZG9lc24ndCBzZW5kIHRoaXMgaGVhZGVyIGFsd2F5c1xuICAgICAgICBpZiAoc2hhMkhlYWRlciA9PSBudWxsKSB7XG4gICAgICAgICAgICBjYWxsYmFjayhuZXcgRXJyb3IoXCJjaGVja3N1bSBpcyByZXF1aXJlZCwgYnV0IHNlcnZlciByZXNwb25zZSBkb2Vzbid0IGNvbnRhaW4gWC1DaGVja3N1bS1TaGEyIGhlYWRlclwiKSk7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH0gZWxzZSBpZiAoc2hhMkhlYWRlciAhPT0gc2hhMikge1xuICAgICAgICAgICAgY2FsbGJhY2sobmV3IEVycm9yKGBjaGVja3N1bSBtaXNtYXRjaDogZXhwZWN0ZWQgJHtzaGEyfSBidXQgZ290ICR7c2hhMkhlYWRlcn0gKFgtQ2hlY2tzdW0tU2hhMiBoZWFkZXIpYCkpO1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xufVxuZnVuY3Rpb24gc2FmZUdldEhlYWRlcihyZXNwb25zZSwgaGVhZGVyS2V5KSB7XG4gICAgY29uc3QgdmFsdWUgPSByZXNwb25zZS5oZWFkZXJzW2hlYWRlcktleV07XG4gICAgaWYgKHZhbHVlID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICAvLyBlbGVjdHJvbiBBUElcbiAgICAgICAgcmV0dXJuIHZhbHVlLmxlbmd0aCA9PT0gMCA/IG51bGwgOiB2YWx1ZVt2YWx1ZS5sZW5ndGggLSAxXTtcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxufVxuZnVuY3Rpb24gY29uZmlndXJlUGlwZXMob3B0aW9ucywgcmVzcG9uc2UsIGRlc3RpbmF0aW9uLCBjYWxsYmFjaywgY2FuY2VsbGF0aW9uVG9rZW4pIHtcbiAgICBpZiAoIWNoZWNrU2hhMihzYWZlR2V0SGVhZGVyKHJlc3BvbnNlLCBcIlgtQ2hlY2tzdW0tU2hhMlwiKSwgb3B0aW9ucy5zaGEyLCBjYWxsYmFjaykpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBzdHJlYW1zID0gW107XG4gICAgaWYgKG9wdGlvbnMub25Qcm9ncmVzcyAhPSBudWxsKSB7XG4gICAgICAgIGNvbnN0IGNvbnRlbnRMZW5ndGggPSBzYWZlR2V0SGVhZGVyKHJlc3BvbnNlLCBcImNvbnRlbnQtbGVuZ3RoXCIpO1xuICAgICAgICBpZiAoY29udGVudExlbmd0aCAhPSBudWxsKSB7XG4gICAgICAgICAgICBzdHJlYW1zLnB1c2gobmV3IChfUHJvZ3Jlc3NDYWxsYmFja1RyYW5zZm9ybSB8fCBfbG9hZF9Qcm9ncmVzc0NhbGxiYWNrVHJhbnNmb3JtKCkpLlByb2dyZXNzQ2FsbGJhY2tUcmFuc2Zvcm0ocGFyc2VJbnQoY29udGVudExlbmd0aCwgMTApLCBvcHRpb25zLmNhbmNlbGxhdGlvblRva2VuLCBvcHRpb25zLm9uUHJvZ3Jlc3MpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBzaGE1MTIgPSBvcHRpb25zLnNoYTUxMjtcbiAgICBpZiAoc2hhNTEyICE9IG51bGwpIHtcbiAgICAgICAgc3RyZWFtcy5wdXNoKG5ldyBEaWdlc3RUcmFuc2Zvcm0oc2hhNTEyLCBcInNoYTUxMlwiLCBzaGE1MTIubGVuZ3RoID09PSAxMjggJiYgIXNoYTUxMi5pbmNsdWRlcyhcIitcIikgJiYgIXNoYTUxMi5pbmNsdWRlcyhcIlpcIikgJiYgIXNoYTUxMi5pbmNsdWRlcyhcIj1cIikgPyBcImhleFwiIDogXCJiYXNlNjRcIikpO1xuICAgIH0gZWxzZSBpZiAob3B0aW9ucy5zaGEyICE9IG51bGwpIHtcbiAgICAgICAgc3RyZWFtcy5wdXNoKG5ldyBEaWdlc3RUcmFuc2Zvcm0ob3B0aW9ucy5zaGEyLCBcInNoYTI1NlwiLCBcImhleFwiKSk7XG4gICAgfVxuICAgIGNvbnN0IGZpbGVPdXQgPSAoMCwgKF9mc0V4dHJhUCB8fCBfbG9hZF9mc0V4dHJhUCgpKS5jcmVhdGVXcml0ZVN0cmVhbSkoZGVzdGluYXRpb24pO1xuICAgIHN0cmVhbXMucHVzaChmaWxlT3V0KTtcbiAgICBsZXQgbGFzdFN0cmVhbSA9IHJlc3BvbnNlO1xuICAgIGZvciAoY29uc3Qgc3RyZWFtIG9mIHN0cmVhbXMpIHtcbiAgICAgICAgc3RyZWFtLm9uKFwiZXJyb3JcIiwgZXJyb3IgPT4ge1xuICAgICAgICAgICAgaWYgKCFjYW5jZWxsYXRpb25Ub2tlbi5jYW5jZWxsZWQpIHtcbiAgICAgICAgICAgICAgICBjYWxsYmFjayhlcnJvcik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBsYXN0U3RyZWFtID0gbGFzdFN0cmVhbS5waXBlKHN0cmVhbSk7XG4gICAgfVxuICAgIGZpbGVPdXQub24oXCJmaW5pc2hcIiwgKCkgPT4ge1xuICAgICAgICBmaWxlT3V0LmNsb3NlKGNhbGxiYWNrKTtcbiAgICB9KTtcbn1cbmZ1bmN0aW9uIGNvbmZpZ3VyZVJlcXVlc3RPcHRpb25zKG9wdGlvbnMsIHRva2VuLCBtZXRob2QpIHtcbiAgICBpZiAobWV0aG9kICE9IG51bGwpIHtcbiAgICAgICAgb3B0aW9ucy5tZXRob2QgPSBtZXRob2Q7XG4gICAgfVxuICAgIGxldCBoZWFkZXJzID0gb3B0aW9ucy5oZWFkZXJzO1xuICAgIGlmIChoZWFkZXJzID09IG51bGwpIHtcbiAgICAgICAgaGVhZGVycyA9IHt9O1xuICAgICAgICBvcHRpb25zLmhlYWRlcnMgPSBoZWFkZXJzO1xuICAgIH1cbiAgICBpZiAodG9rZW4gIT0gbnVsbCkge1xuICAgICAgICBoZWFkZXJzLmF1dGhvcml6YXRpb24gPSB0b2tlbi5zdGFydHNXaXRoKFwiQmFzaWNcIikgPyB0b2tlbiA6IGB0b2tlbiAke3Rva2VufWA7XG4gICAgfVxuICAgIGlmIChoZWFkZXJzW1wiVXNlci1BZ2VudFwiXSA9PSBudWxsKSB7XG4gICAgICAgIGhlYWRlcnNbXCJVc2VyLUFnZW50XCJdID0gXCJlbGVjdHJvbi1idWlsZGVyXCI7XG4gICAgfVxuICAgIGlmIChtZXRob2QgPT0gbnVsbCB8fCBtZXRob2QgPT09IFwiR0VUXCIgfHwgaGVhZGVyc1tcIkNhY2hlLUNvbnRyb2xcIl0gPT0gbnVsbCkge1xuICAgICAgICBoZWFkZXJzW1wiQ2FjaGUtQ29udHJvbFwiXSA9IFwibm8tY2FjaGVcIjtcbiAgICB9XG4gICAgLy8gZG8gbm90IHNwZWNpZnkgZm9yIG5vZGUgKGluIGFueSBjYXNlIHdlIHVzZSBodHRwcyBtb2R1bGUpXG4gICAgaWYgKG9wdGlvbnMucHJvdG9jb2wgPT0gbnVsbCAmJiBwcm9jZXNzLnZlcnNpb25zLmVsZWN0cm9uICE9IG51bGwpIHtcbiAgICAgICAgb3B0aW9ucy5wcm90b2NvbCA9IFwiaHR0cHM6XCI7XG4gICAgfVxuICAgIHJldHVybiBvcHRpb25zO1xufVxuZnVuY3Rpb24gc2FmZVN0cmluZ2lmeUpzb24oZGF0YSwgc2tpcHBlZE5hbWVzKSB7XG4gICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KGRhdGEsIChuYW1lLCB2YWx1ZSkgPT4ge1xuICAgICAgICBpZiAobmFtZS5lbmRzV2l0aChcImF1dGhvcml6YXRpb25cIikgfHwgbmFtZS5lbmRzV2l0aChcIlBhc3N3b3JkXCIpIHx8IG5hbWUuZW5kc1dpdGgoXCJQQVNTV09SRFwiKSB8fCBuYW1lLmVuZHNXaXRoKFwiVG9rZW5cIikgfHwgbmFtZS5pbmNsdWRlcyhcInBhc3N3b3JkXCIpIHx8IG5hbWUuaW5jbHVkZXMoXCJ0b2tlblwiKSB8fCBza2lwcGVkTmFtZXMgIT0gbnVsbCAmJiBza2lwcGVkTmFtZXMuaGFzKG5hbWUpKSB7XG4gICAgICAgICAgICByZXR1cm4gXCI8c3RyaXBwZWQgc2Vuc2l0aXZlIGRhdGE+XCI7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH0sIDIpO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aHR0cEV4ZWN1dG9yLmpzLm1hcFxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9lbGVjdHJvbi11cGRhdGVyL25vZGVfbW9kdWxlcy9idWlsZGVyLXV0aWwtcnVudGltZS9vdXQvaHR0cEV4ZWN1dG9yLmpzIiwiXG4vKipcbiAqIFRoaXMgaXMgdGhlIGNvbW1vbiBsb2dpYyBmb3IgYm90aCB0aGUgTm9kZS5qcyBhbmQgd2ViIGJyb3dzZXJcbiAqIGltcGxlbWVudGF0aW9ucyBvZiBgZGVidWcoKWAuXG4gKlxuICogRXhwb3NlIGBkZWJ1ZygpYCBhcyB0aGUgbW9kdWxlLlxuICovXG5cbmV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IGNyZWF0ZURlYnVnLmRlYnVnID0gY3JlYXRlRGVidWdbJ2RlZmF1bHQnXSA9IGNyZWF0ZURlYnVnO1xuZXhwb3J0cy5jb2VyY2UgPSBjb2VyY2U7XG5leHBvcnRzLmRpc2FibGUgPSBkaXNhYmxlO1xuZXhwb3J0cy5lbmFibGUgPSBlbmFibGU7XG5leHBvcnRzLmVuYWJsZWQgPSBlbmFibGVkO1xuZXhwb3J0cy5odW1hbml6ZSA9IHJlcXVpcmUoJ21zJyk7XG5cbi8qKlxuICogQWN0aXZlIGBkZWJ1Z2AgaW5zdGFuY2VzLlxuICovXG5leHBvcnRzLmluc3RhbmNlcyA9IFtdO1xuXG4vKipcbiAqIFRoZSBjdXJyZW50bHkgYWN0aXZlIGRlYnVnIG1vZGUgbmFtZXMsIGFuZCBuYW1lcyB0byBza2lwLlxuICovXG5cbmV4cG9ydHMubmFtZXMgPSBbXTtcbmV4cG9ydHMuc2tpcHMgPSBbXTtcblxuLyoqXG4gKiBNYXAgb2Ygc3BlY2lhbCBcIiVuXCIgaGFuZGxpbmcgZnVuY3Rpb25zLCBmb3IgdGhlIGRlYnVnIFwiZm9ybWF0XCIgYXJndW1lbnQuXG4gKlxuICogVmFsaWQga2V5IG5hbWVzIGFyZSBhIHNpbmdsZSwgbG93ZXIgb3IgdXBwZXItY2FzZSBsZXR0ZXIsIGkuZS4gXCJuXCIgYW5kIFwiTlwiLlxuICovXG5cbmV4cG9ydHMuZm9ybWF0dGVycyA9IHt9O1xuXG4vKipcbiAqIFNlbGVjdCBhIGNvbG9yLlxuICogQHBhcmFtIHtTdHJpbmd9IG5hbWVzcGFjZVxuICogQHJldHVybiB7TnVtYmVyfVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gc2VsZWN0Q29sb3IobmFtZXNwYWNlKSB7XG4gIHZhciBoYXNoID0gMCwgaTtcblxuICBmb3IgKGkgaW4gbmFtZXNwYWNlKSB7XG4gICAgaGFzaCAgPSAoKGhhc2ggPDwgNSkgLSBoYXNoKSArIG5hbWVzcGFjZS5jaGFyQ29kZUF0KGkpO1xuICAgIGhhc2ggfD0gMDsgLy8gQ29udmVydCB0byAzMmJpdCBpbnRlZ2VyXG4gIH1cblxuICByZXR1cm4gZXhwb3J0cy5jb2xvcnNbTWF0aC5hYnMoaGFzaCkgJSBleHBvcnRzLmNvbG9ycy5sZW5ndGhdO1xufVxuXG4vKipcbiAqIENyZWF0ZSBhIGRlYnVnZ2VyIHdpdGggdGhlIGdpdmVuIGBuYW1lc3BhY2VgLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lc3BhY2VcbiAqIEByZXR1cm4ge0Z1bmN0aW9ufVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBjcmVhdGVEZWJ1ZyhuYW1lc3BhY2UpIHtcblxuICB2YXIgcHJldlRpbWU7XG5cbiAgZnVuY3Rpb24gZGVidWcoKSB7XG4gICAgLy8gZGlzYWJsZWQ/XG4gICAgaWYgKCFkZWJ1Zy5lbmFibGVkKSByZXR1cm47XG5cbiAgICB2YXIgc2VsZiA9IGRlYnVnO1xuXG4gICAgLy8gc2V0IGBkaWZmYCB0aW1lc3RhbXBcbiAgICB2YXIgY3VyciA9ICtuZXcgRGF0ZSgpO1xuICAgIHZhciBtcyA9IGN1cnIgLSAocHJldlRpbWUgfHwgY3Vycik7XG4gICAgc2VsZi5kaWZmID0gbXM7XG4gICAgc2VsZi5wcmV2ID0gcHJldlRpbWU7XG4gICAgc2VsZi5jdXJyID0gY3VycjtcbiAgICBwcmV2VGltZSA9IGN1cnI7XG5cbiAgICAvLyB0dXJuIHRoZSBgYXJndW1lbnRzYCBpbnRvIGEgcHJvcGVyIEFycmF5XG4gICAgdmFyIGFyZ3MgPSBuZXcgQXJyYXkoYXJndW1lbnRzLmxlbmd0aCk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcmdzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBhcmdzW2ldID0gYXJndW1lbnRzW2ldO1xuICAgIH1cblxuICAgIGFyZ3NbMF0gPSBleHBvcnRzLmNvZXJjZShhcmdzWzBdKTtcblxuICAgIGlmICgnc3RyaW5nJyAhPT0gdHlwZW9mIGFyZ3NbMF0pIHtcbiAgICAgIC8vIGFueXRoaW5nIGVsc2UgbGV0J3MgaW5zcGVjdCB3aXRoICVPXG4gICAgICBhcmdzLnVuc2hpZnQoJyVPJyk7XG4gICAgfVxuXG4gICAgLy8gYXBwbHkgYW55IGBmb3JtYXR0ZXJzYCB0cmFuc2Zvcm1hdGlvbnNcbiAgICB2YXIgaW5kZXggPSAwO1xuICAgIGFyZ3NbMF0gPSBhcmdzWzBdLnJlcGxhY2UoLyUoW2EtekEtWiVdKS9nLCBmdW5jdGlvbihtYXRjaCwgZm9ybWF0KSB7XG4gICAgICAvLyBpZiB3ZSBlbmNvdW50ZXIgYW4gZXNjYXBlZCAlIHRoZW4gZG9uJ3QgaW5jcmVhc2UgdGhlIGFycmF5IGluZGV4XG4gICAgICBpZiAobWF0Y2ggPT09ICclJScpIHJldHVybiBtYXRjaDtcbiAgICAgIGluZGV4Kys7XG4gICAgICB2YXIgZm9ybWF0dGVyID0gZXhwb3J0cy5mb3JtYXR0ZXJzW2Zvcm1hdF07XG4gICAgICBpZiAoJ2Z1bmN0aW9uJyA9PT0gdHlwZW9mIGZvcm1hdHRlcikge1xuICAgICAgICB2YXIgdmFsID0gYXJnc1tpbmRleF07XG4gICAgICAgIG1hdGNoID0gZm9ybWF0dGVyLmNhbGwoc2VsZiwgdmFsKTtcblxuICAgICAgICAvLyBub3cgd2UgbmVlZCB0byByZW1vdmUgYGFyZ3NbaW5kZXhdYCBzaW5jZSBpdCdzIGlubGluZWQgaW4gdGhlIGBmb3JtYXRgXG4gICAgICAgIGFyZ3Muc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgICAgaW5kZXgtLTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBtYXRjaDtcbiAgICB9KTtcblxuICAgIC8vIGFwcGx5IGVudi1zcGVjaWZpYyBmb3JtYXR0aW5nIChjb2xvcnMsIGV0Yy4pXG4gICAgZXhwb3J0cy5mb3JtYXRBcmdzLmNhbGwoc2VsZiwgYXJncyk7XG5cbiAgICB2YXIgbG9nRm4gPSBkZWJ1Zy5sb2cgfHwgZXhwb3J0cy5sb2cgfHwgY29uc29sZS5sb2cuYmluZChjb25zb2xlKTtcbiAgICBsb2dGbi5hcHBseShzZWxmLCBhcmdzKTtcbiAgfVxuXG4gIGRlYnVnLm5hbWVzcGFjZSA9IG5hbWVzcGFjZTtcbiAgZGVidWcuZW5hYmxlZCA9IGV4cG9ydHMuZW5hYmxlZChuYW1lc3BhY2UpO1xuICBkZWJ1Zy51c2VDb2xvcnMgPSBleHBvcnRzLnVzZUNvbG9ycygpO1xuICBkZWJ1Zy5jb2xvciA9IHNlbGVjdENvbG9yKG5hbWVzcGFjZSk7XG4gIGRlYnVnLmRlc3Ryb3kgPSBkZXN0cm95O1xuXG4gIC8vIGVudi1zcGVjaWZpYyBpbml0aWFsaXphdGlvbiBsb2dpYyBmb3IgZGVidWcgaW5zdGFuY2VzXG4gIGlmICgnZnVuY3Rpb24nID09PSB0eXBlb2YgZXhwb3J0cy5pbml0KSB7XG4gICAgZXhwb3J0cy5pbml0KGRlYnVnKTtcbiAgfVxuXG4gIGV4cG9ydHMuaW5zdGFuY2VzLnB1c2goZGVidWcpO1xuXG4gIHJldHVybiBkZWJ1Zztcbn1cblxuZnVuY3Rpb24gZGVzdHJveSAoKSB7XG4gIHZhciBpbmRleCA9IGV4cG9ydHMuaW5zdGFuY2VzLmluZGV4T2YodGhpcyk7XG4gIGlmIChpbmRleCAhPT0gLTEpIHtcbiAgICBleHBvcnRzLmluc3RhbmNlcy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgIHJldHVybiB0cnVlO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufVxuXG4vKipcbiAqIEVuYWJsZXMgYSBkZWJ1ZyBtb2RlIGJ5IG5hbWVzcGFjZXMuIFRoaXMgY2FuIGluY2x1ZGUgbW9kZXNcbiAqIHNlcGFyYXRlZCBieSBhIGNvbG9uIGFuZCB3aWxkY2FyZHMuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IG5hbWVzcGFjZXNcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gZW5hYmxlKG5hbWVzcGFjZXMpIHtcbiAgZXhwb3J0cy5zYXZlKG5hbWVzcGFjZXMpO1xuXG4gIGV4cG9ydHMubmFtZXMgPSBbXTtcbiAgZXhwb3J0cy5za2lwcyA9IFtdO1xuXG4gIHZhciBpO1xuICB2YXIgc3BsaXQgPSAodHlwZW9mIG5hbWVzcGFjZXMgPT09ICdzdHJpbmcnID8gbmFtZXNwYWNlcyA6ICcnKS5zcGxpdCgvW1xccyxdKy8pO1xuICB2YXIgbGVuID0gc3BsaXQubGVuZ3RoO1xuXG4gIGZvciAoaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgIGlmICghc3BsaXRbaV0pIGNvbnRpbnVlOyAvLyBpZ25vcmUgZW1wdHkgc3RyaW5nc1xuICAgIG5hbWVzcGFjZXMgPSBzcGxpdFtpXS5yZXBsYWNlKC9cXCovZywgJy4qPycpO1xuICAgIGlmIChuYW1lc3BhY2VzWzBdID09PSAnLScpIHtcbiAgICAgIGV4cG9ydHMuc2tpcHMucHVzaChuZXcgUmVnRXhwKCdeJyArIG5hbWVzcGFjZXMuc3Vic3RyKDEpICsgJyQnKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGV4cG9ydHMubmFtZXMucHVzaChuZXcgUmVnRXhwKCdeJyArIG5hbWVzcGFjZXMgKyAnJCcpKTtcbiAgICB9XG4gIH1cblxuICBmb3IgKGkgPSAwOyBpIDwgZXhwb3J0cy5pbnN0YW5jZXMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgaW5zdGFuY2UgPSBleHBvcnRzLmluc3RhbmNlc1tpXTtcbiAgICBpbnN0YW5jZS5lbmFibGVkID0gZXhwb3J0cy5lbmFibGVkKGluc3RhbmNlLm5hbWVzcGFjZSk7XG4gIH1cbn1cblxuLyoqXG4gKiBEaXNhYmxlIGRlYnVnIG91dHB1dC5cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIGRpc2FibGUoKSB7XG4gIGV4cG9ydHMuZW5hYmxlKCcnKTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgdGhlIGdpdmVuIG1vZGUgbmFtZSBpcyBlbmFibGVkLCBmYWxzZSBvdGhlcndpc2UuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IG5hbWVcbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIGVuYWJsZWQobmFtZSkge1xuICBpZiAobmFtZVtuYW1lLmxlbmd0aCAtIDFdID09PSAnKicpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICB2YXIgaSwgbGVuO1xuICBmb3IgKGkgPSAwLCBsZW4gPSBleHBvcnRzLnNraXBzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgaWYgKGV4cG9ydHMuc2tpcHNbaV0udGVzdChuYW1lKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuICBmb3IgKGkgPSAwLCBsZW4gPSBleHBvcnRzLm5hbWVzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgaWYgKGV4cG9ydHMubmFtZXNbaV0udGVzdChuYW1lKSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cblxuLyoqXG4gKiBDb2VyY2UgYHZhbGAuXG4gKlxuICogQHBhcmFtIHtNaXhlZH0gdmFsXG4gKiBAcmV0dXJuIHtNaXhlZH1cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIGNvZXJjZSh2YWwpIHtcbiAgaWYgKHZhbCBpbnN0YW5jZW9mIEVycm9yKSByZXR1cm4gdmFsLnN0YWNrIHx8IHZhbC5tZXNzYWdlO1xuICByZXR1cm4gdmFsO1xufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2VsZWN0cm9uLXVwZGF0ZXIvbm9kZV9tb2R1bGVzL2RlYnVnL3NyYy9kZWJ1Zy5qcyIsIi8vIFRoaXMgaXMgYWRhcHRlZCBmcm9tIGh0dHBzOi8vZ2l0aHViLmNvbS9ub3JtYWxpemUvbXpcbi8vIENvcHlyaWdodCAoYykgMjAxNC0yMDE2IEpvbmF0aGFuIE9uZyBtZUBqb25nbGViZXJyeS5jb20gYW5kIENvbnRyaWJ1dG9yc1xuY29uc3QgdSA9IHJlcXVpcmUoJ3VuaXZlcnNhbGlmeScpLmZyb21DYWxsYmFja1xuY29uc3QgZnMgPSByZXF1aXJlKCdncmFjZWZ1bC1mcycpXG5cbmNvbnN0IGFwaSA9IFtcbiAgJ2FjY2VzcycsXG4gICdhcHBlbmRGaWxlJyxcbiAgJ2NobW9kJyxcbiAgJ2Nob3duJyxcbiAgJ2Nsb3NlJyxcbiAgJ2NvcHlGaWxlJyxcbiAgJ2ZjaG1vZCcsXG4gICdmY2hvd24nLFxuICAnZmRhdGFzeW5jJyxcbiAgJ2ZzdGF0JyxcbiAgJ2ZzeW5jJyxcbiAgJ2Z0cnVuY2F0ZScsXG4gICdmdXRpbWVzJyxcbiAgJ2xjaG93bicsXG4gICdsaW5rJyxcbiAgJ2xzdGF0JyxcbiAgJ21rZGlyJyxcbiAgJ21rZHRlbXAnLFxuICAnb3BlbicsXG4gICdyZWFkRmlsZScsXG4gICdyZWFkZGlyJyxcbiAgJ3JlYWRsaW5rJyxcbiAgJ3JlYWxwYXRoJyxcbiAgJ3JlbmFtZScsXG4gICdybWRpcicsXG4gICdzdGF0JyxcbiAgJ3N5bWxpbmsnLFxuICAndHJ1bmNhdGUnLFxuICAndW5saW5rJyxcbiAgJ3V0aW1lcycsXG4gICd3cml0ZUZpbGUnXG5dLmZpbHRlcihrZXkgPT4ge1xuICAvLyBTb21lIGNvbW1hbmRzIGFyZSBub3QgYXZhaWxhYmxlIG9uIHNvbWUgc3lzdGVtcy4gRXg6XG4gIC8vIGZzLmNvcHlGaWxlIHdhcyBhZGRlZCBpbiBOb2RlLmpzIHY4LjUuMFxuICAvLyBmcy5ta2R0ZW1wIHdhcyBhZGRlZCBpbiBOb2RlLmpzIHY1LjEwLjBcbiAgLy8gZnMubGNob3duIGlzIG5vdCBhdmFpbGFibGUgb24gYXQgbGVhc3Qgc29tZSBMaW51eFxuICByZXR1cm4gdHlwZW9mIGZzW2tleV0gPT09ICdmdW5jdGlvbidcbn0pXG5cbi8vIEV4cG9ydCBhbGwga2V5czpcbk9iamVjdC5rZXlzKGZzKS5mb3JFYWNoKGtleSA9PiB7XG4gIGV4cG9ydHNba2V5XSA9IGZzW2tleV1cbn0pXG5cbi8vIFVuaXZlcnNhbGlmeSBhc3luYyBtZXRob2RzOlxuYXBpLmZvckVhY2gobWV0aG9kID0+IHtcbiAgZXhwb3J0c1ttZXRob2RdID0gdShmc1ttZXRob2RdKVxufSlcblxuLy8gV2UgZGlmZmVyIGZyb20gbXovZnMgaW4gdGhhdCB3ZSBzdGlsbCBzaGlwIHRoZSBvbGQsIGJyb2tlbiwgZnMuZXhpc3RzKClcbi8vIHNpbmNlIHdlIGFyZSBhIGRyb3AtaW4gcmVwbGFjZW1lbnQgZm9yIHRoZSBuYXRpdmUgbW9kdWxlXG5leHBvcnRzLmV4aXN0cyA9IGZ1bmN0aW9uIChmaWxlbmFtZSwgY2FsbGJhY2spIHtcbiAgaWYgKHR5cGVvZiBjYWxsYmFjayA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiBmcy5leGlzdHMoZmlsZW5hbWUsIGNhbGxiYWNrKVxuICB9XG4gIHJldHVybiBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHtcbiAgICByZXR1cm4gZnMuZXhpc3RzKGZpbGVuYW1lLCByZXNvbHZlKVxuICB9KVxufVxuXG4vLyBmcy5yZWFkKCkgJiBmcy53cml0ZSBuZWVkIHNwZWNpYWwgdHJlYXRtZW50IGR1ZSB0byBtdWx0aXBsZSBjYWxsYmFjayBhcmdzXG5cbmV4cG9ydHMucmVhZCA9IGZ1bmN0aW9uIChmZCwgYnVmZmVyLCBvZmZzZXQsIGxlbmd0aCwgcG9zaXRpb24sIGNhbGxiYWNrKSB7XG4gIGlmICh0eXBlb2YgY2FsbGJhY2sgPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gZnMucmVhZChmZCwgYnVmZmVyLCBvZmZzZXQsIGxlbmd0aCwgcG9zaXRpb24sIGNhbGxiYWNrKVxuICB9XG4gIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgZnMucmVhZChmZCwgYnVmZmVyLCBvZmZzZXQsIGxlbmd0aCwgcG9zaXRpb24sIChlcnIsIGJ5dGVzUmVhZCwgYnVmZmVyKSA9PiB7XG4gICAgICBpZiAoZXJyKSByZXR1cm4gcmVqZWN0KGVycilcbiAgICAgIHJlc29sdmUoeyBieXRlc1JlYWQsIGJ1ZmZlciB9KVxuICAgIH0pXG4gIH0pXG59XG5cbi8vIEZ1bmN0aW9uIHNpZ25hdHVyZSBjYW4gYmVcbi8vIGZzLndyaXRlKGZkLCBidWZmZXJbLCBvZmZzZXRbLCBsZW5ndGhbLCBwb3NpdGlvbl1dXSwgY2FsbGJhY2spXG4vLyBPUlxuLy8gZnMud3JpdGUoZmQsIHN0cmluZ1ssIHBvc2l0aW9uWywgZW5jb2RpbmddXSwgY2FsbGJhY2spXG4vLyBzbyB3ZSBuZWVkIHRvIGhhbmRsZSBib3RoIGNhc2VzXG5leHBvcnRzLndyaXRlID0gZnVuY3Rpb24gKGZkLCBidWZmZXIsIGEsIGIsIGMsIGNhbGxiYWNrKSB7XG4gIGlmICh0eXBlb2YgYXJndW1lbnRzW2FyZ3VtZW50cy5sZW5ndGggLSAxXSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiBmcy53cml0ZShmZCwgYnVmZmVyLCBhLCBiLCBjLCBjYWxsYmFjaylcbiAgfVxuXG4gIC8vIENoZWNrIGZvciBvbGQsIGRlcHJpY2F0ZWQgZnMud3JpdGUoZmQsIHN0cmluZ1ssIHBvc2l0aW9uWywgZW5jb2RpbmddXSwgY2FsbGJhY2spXG4gIGlmICh0eXBlb2YgYnVmZmVyID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICBmcy53cml0ZShmZCwgYnVmZmVyLCBhLCBiLCAoZXJyLCBieXRlc1dyaXR0ZW4sIGJ1ZmZlcikgPT4ge1xuICAgICAgICBpZiAoZXJyKSByZXR1cm4gcmVqZWN0KGVycilcbiAgICAgICAgcmVzb2x2ZSh7IGJ5dGVzV3JpdHRlbiwgYnVmZmVyIH0pXG4gICAgICB9KVxuICAgIH0pXG4gIH1cblxuICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgIGZzLndyaXRlKGZkLCBidWZmZXIsIGEsIGIsIGMsIChlcnIsIGJ5dGVzV3JpdHRlbiwgYnVmZmVyKSA9PiB7XG4gICAgICBpZiAoZXJyKSByZXR1cm4gcmVqZWN0KGVycilcbiAgICAgIHJlc29sdmUoeyBieXRlc1dyaXR0ZW4sIGJ1ZmZlciB9KVxuICAgIH0pXG4gIH0pXG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvZWxlY3Ryb24tdXBkYXRlci9ub2RlX21vZHVsZXMvZnMtZXh0cmEvbGliL2ZzL2luZGV4LmpzIiwiJ3VzZSBzdHJpY3QnXG5cbnZhciBmcyA9IHJlcXVpcmUoJ2ZzJylcblxubW9kdWxlLmV4cG9ydHMgPSBjbG9uZShmcylcblxuZnVuY3Rpb24gY2xvbmUgKG9iaikge1xuICBpZiAob2JqID09PSBudWxsIHx8IHR5cGVvZiBvYmogIT09ICdvYmplY3QnKVxuICAgIHJldHVybiBvYmpcblxuICBpZiAob2JqIGluc3RhbmNlb2YgT2JqZWN0KVxuICAgIHZhciBjb3B5ID0geyBfX3Byb3RvX186IG9iai5fX3Byb3RvX18gfVxuICBlbHNlXG4gICAgdmFyIGNvcHkgPSBPYmplY3QuY3JlYXRlKG51bGwpXG5cbiAgT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMob2JqKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoY29weSwga2V5LCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iaiwga2V5KSlcbiAgfSlcblxuICByZXR1cm4gY29weVxufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2dyYWNlZnVsLWZzL2ZzLmpzIiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwiYXNzZXJ0XCIpO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIGV4dGVybmFsIFwiYXNzZXJ0XCJcbi8vIG1vZHVsZSBpZCA9IDQ2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIid1c2Ugc3RyaWN0J1xuXG5jb25zdCBmcyA9IHJlcXVpcmUoJ2dyYWNlZnVsLWZzJylcbmNvbnN0IHBhdGggPSByZXF1aXJlKCdwYXRoJylcbmNvbnN0IG1rZGlycCA9IHJlcXVpcmUoJy4uL21rZGlycycpLm1rZGlyc1xuY29uc3QgcGF0aEV4aXN0cyA9IHJlcXVpcmUoJy4uL3BhdGgtZXhpc3RzJykucGF0aEV4aXN0c1xuY29uc3QgdXRpbWVzID0gcmVxdWlyZSgnLi4vdXRpbC91dGltZXMnKS51dGltZXNNaWxsaXNcblxuY29uc3Qgbm90RXhpc3QgPSBTeW1ib2woJ25vdEV4aXN0JylcbmNvbnN0IGV4aXN0c1JlZyA9IFN5bWJvbCgnZXhpc3RzUmVnJylcblxuZnVuY3Rpb24gY29weSAoc3JjLCBkZXN0LCBvcHRzLCBjYikge1xuICBpZiAodHlwZW9mIG9wdHMgPT09ICdmdW5jdGlvbicgJiYgIWNiKSB7XG4gICAgY2IgPSBvcHRzXG4gICAgb3B0cyA9IHt9XG4gIH0gZWxzZSBpZiAodHlwZW9mIG9wdHMgPT09ICdmdW5jdGlvbicpIHtcbiAgICBvcHRzID0ge2ZpbHRlcjogb3B0c31cbiAgfVxuXG4gIGNiID0gY2IgfHwgZnVuY3Rpb24gKCkge31cbiAgb3B0cyA9IG9wdHMgfHwge31cblxuICBvcHRzLmNsb2JiZXIgPSAnY2xvYmJlcicgaW4gb3B0cyA/ICEhb3B0cy5jbG9iYmVyIDogdHJ1ZSAvLyBkZWZhdWx0IHRvIHRydWUgZm9yIG5vd1xuICBvcHRzLm92ZXJ3cml0ZSA9ICdvdmVyd3JpdGUnIGluIG9wdHMgPyAhIW9wdHMub3ZlcndyaXRlIDogb3B0cy5jbG9iYmVyIC8vIG92ZXJ3cml0ZSBmYWxscyBiYWNrIHRvIGNsb2JiZXJcblxuICAvLyBXYXJuIGFib3V0IHVzaW5nIHByZXNlcnZlVGltZXN0YW1wcyBvbiAzMi1iaXQgbm9kZVxuICBpZiAob3B0cy5wcmVzZXJ2ZVRpbWVzdGFtcHMgJiYgcHJvY2Vzcy5hcmNoID09PSAnaWEzMicpIHtcbiAgICBjb25zb2xlLndhcm4oYGZzLWV4dHJhOiBVc2luZyB0aGUgcHJlc2VydmVUaW1lc3RhbXBzIG9wdGlvbiBpbiAzMi1iaXQgbm9kZSBpcyBub3QgcmVjb21tZW5kZWQ7XFxuXG4gICAgc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9qcHJpY2hhcmRzb24vbm9kZS1mcy1leHRyYS9pc3N1ZXMvMjY5YClcbiAgfVxuXG4gIHNyYyA9IHBhdGgucmVzb2x2ZShzcmMpXG4gIGRlc3QgPSBwYXRoLnJlc29sdmUoZGVzdClcblxuICAvLyBkb24ndCBhbGxvdyBzcmMgYW5kIGRlc3QgdG8gYmUgdGhlIHNhbWVcbiAgaWYgKHNyYyA9PT0gZGVzdCkgcmV0dXJuIGNiKG5ldyBFcnJvcignU291cmNlIGFuZCBkZXN0aW5hdGlvbiBtdXN0IG5vdCBiZSB0aGUgc2FtZS4nKSlcblxuICBpZiAob3B0cy5maWx0ZXIpIHJldHVybiBoYW5kbGVGaWx0ZXIoY2hlY2tQYXJlbnREaXIsIHNyYywgZGVzdCwgb3B0cywgY2IpXG4gIHJldHVybiBjaGVja1BhcmVudERpcihzcmMsIGRlc3QsIG9wdHMsIGNiKVxufVxuXG5mdW5jdGlvbiBjaGVja1BhcmVudERpciAoc3JjLCBkZXN0LCBvcHRzLCBjYikge1xuICBjb25zdCBkZXN0UGFyZW50ID0gcGF0aC5kaXJuYW1lKGRlc3QpXG4gIHBhdGhFeGlzdHMoZGVzdFBhcmVudCwgKGVyciwgZGlyRXhpc3RzKSA9PiB7XG4gICAgaWYgKGVycikgcmV0dXJuIGNiKGVycilcbiAgICBpZiAoZGlyRXhpc3RzKSByZXR1cm4gc3RhcnRDb3B5KHNyYywgZGVzdCwgb3B0cywgY2IpXG4gICAgbWtkaXJwKGRlc3RQYXJlbnQsIGVyciA9PiB7XG4gICAgICBpZiAoZXJyKSByZXR1cm4gY2IoZXJyKVxuICAgICAgcmV0dXJuIHN0YXJ0Q29weShzcmMsIGRlc3QsIG9wdHMsIGNiKVxuICAgIH0pXG4gIH0pXG59XG5cbmZ1bmN0aW9uIHN0YXJ0Q29weSAoc3JjLCBkZXN0LCBvcHRzLCBjYikge1xuICBpZiAob3B0cy5maWx0ZXIpIHJldHVybiBoYW5kbGVGaWx0ZXIoZ2V0U3RhdHMsIHNyYywgZGVzdCwgb3B0cywgY2IpXG4gIHJldHVybiBnZXRTdGF0cyhzcmMsIGRlc3QsIG9wdHMsIGNiKVxufVxuXG5mdW5jdGlvbiBoYW5kbGVGaWx0ZXIgKG9uSW5jbHVkZSwgc3JjLCBkZXN0LCBvcHRzLCBjYikge1xuICBQcm9taXNlLnJlc29sdmUob3B0cy5maWx0ZXIoc3JjLCBkZXN0KSlcbiAgICAudGhlbihpbmNsdWRlID0+IHtcbiAgICAgIGlmIChpbmNsdWRlKSByZXR1cm4gb25JbmNsdWRlKHNyYywgZGVzdCwgb3B0cywgY2IpXG4gICAgICByZXR1cm4gY2IoKVxuICAgIH0sIGVycm9yID0+IGNiKGVycm9yKSlcbn1cblxuZnVuY3Rpb24gZ2V0U3RhdHMgKHNyYywgZGVzdCwgb3B0cywgY2IpIHtcbiAgY29uc3Qgc3RhdCA9IG9wdHMuZGVyZWZlcmVuY2UgPyBmcy5zdGF0IDogZnMubHN0YXRcbiAgc3RhdChzcmMsIChlcnIsIHN0KSA9PiB7XG4gICAgaWYgKGVycikgcmV0dXJuIGNiKGVycilcblxuICAgIGlmIChzdC5pc0RpcmVjdG9yeSgpKSByZXR1cm4gb25EaXIoc3QsIHNyYywgZGVzdCwgb3B0cywgY2IpXG4gICAgZWxzZSBpZiAoc3QuaXNGaWxlKCkgfHxcbiAgICAgICAgICAgICBzdC5pc0NoYXJhY3RlckRldmljZSgpIHx8XG4gICAgICAgICAgICAgc3QuaXNCbG9ja0RldmljZSgpKSByZXR1cm4gb25GaWxlKHN0LCBzcmMsIGRlc3QsIG9wdHMsIGNiKVxuICAgIGVsc2UgaWYgKHN0LmlzU3ltYm9saWNMaW5rKCkpIHJldHVybiBvbkxpbmsoc3JjLCBkZXN0LCBvcHRzLCBjYilcbiAgfSlcbn1cblxuZnVuY3Rpb24gb25GaWxlIChzcmNTdGF0LCBzcmMsIGRlc3QsIG9wdHMsIGNiKSB7XG4gIGNoZWNrRGVzdChkZXN0LCAoZXJyLCByZXNvbHZlZFBhdGgpID0+IHtcbiAgICBpZiAoZXJyKSByZXR1cm4gY2IoZXJyKVxuICAgIGlmIChyZXNvbHZlZFBhdGggPT09IG5vdEV4aXN0KSB7XG4gICAgICByZXR1cm4gY29weUZpbGUoc3JjU3RhdCwgc3JjLCBkZXN0LCBvcHRzLCBjYilcbiAgICB9IGVsc2UgaWYgKHJlc29sdmVkUGF0aCA9PT0gZXhpc3RzUmVnKSB7XG4gICAgICByZXR1cm4gbWF5Q29weUZpbGUoc3JjU3RhdCwgc3JjLCBkZXN0LCBvcHRzLCBjYilcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHNyYyA9PT0gcmVzb2x2ZWRQYXRoKSByZXR1cm4gY2IoKVxuICAgICAgcmV0dXJuIG1heUNvcHlGaWxlKHNyY1N0YXQsIHNyYywgZGVzdCwgb3B0cywgY2IpXG4gICAgfVxuICB9KVxufVxuXG5mdW5jdGlvbiBtYXlDb3B5RmlsZSAoc3JjU3RhdCwgc3JjLCBkZXN0LCBvcHRzLCBjYikge1xuICBpZiAob3B0cy5vdmVyd3JpdGUpIHtcbiAgICBmcy51bmxpbmsoZGVzdCwgZXJyID0+IHtcbiAgICAgIGlmIChlcnIpIHJldHVybiBjYihlcnIpXG4gICAgICByZXR1cm4gY29weUZpbGUoc3JjU3RhdCwgc3JjLCBkZXN0LCBvcHRzLCBjYilcbiAgICB9KVxuICB9IGVsc2UgaWYgKG9wdHMuZXJyb3JPbkV4aXN0KSB7XG4gICAgcmV0dXJuIGNiKG5ldyBFcnJvcihgJyR7ZGVzdH0nIGFscmVhZHkgZXhpc3RzYCkpXG4gIH0gZWxzZSByZXR1cm4gY2IoKVxufVxuXG5mdW5jdGlvbiBjb3B5RmlsZSAoc3JjU3RhdCwgc3JjLCBkZXN0LCBvcHRzLCBjYikge1xuICBpZiAodHlwZW9mIGZzLmNvcHlGaWxlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIGZzLmNvcHlGaWxlKHNyYywgZGVzdCwgZXJyID0+IHtcbiAgICAgIGlmIChlcnIpIHJldHVybiBjYihlcnIpXG4gICAgICByZXR1cm4gc2V0RGVzdE1vZGVBbmRUaW1lc3RhbXBzKHNyY1N0YXQsIGRlc3QsIG9wdHMsIGNiKVxuICAgIH0pXG4gIH1cbiAgcmV0dXJuIGNvcHlGaWxlRmFsbGJhY2soc3JjU3RhdCwgc3JjLCBkZXN0LCBvcHRzLCBjYilcbn1cblxuZnVuY3Rpb24gY29weUZpbGVGYWxsYmFjayAoc3JjU3RhdCwgc3JjLCBkZXN0LCBvcHRzLCBjYikge1xuICBjb25zdCBycyA9IGZzLmNyZWF0ZVJlYWRTdHJlYW0oc3JjKVxuICBycy5vbignZXJyb3InLCBlcnIgPT4gY2IoZXJyKSlcbiAgICAub25jZSgnb3BlbicsICgpID0+IHtcbiAgICAgIGNvbnN0IHdzID0gZnMuY3JlYXRlV3JpdGVTdHJlYW0oZGVzdCwgeyBtb2RlOiBzcmNTdGF0Lm1vZGUgfSlcbiAgICAgIHdzLm9uKCdlcnJvcicsIGVyciA9PiBjYihlcnIpKVxuICAgICAgICAub24oJ29wZW4nLCAoKSA9PiBycy5waXBlKHdzKSlcbiAgICAgICAgLm9uY2UoJ2Nsb3NlJywgKCkgPT4gc2V0RGVzdE1vZGVBbmRUaW1lc3RhbXBzKHNyY1N0YXQsIGRlc3QsIG9wdHMsIGNiKSlcbiAgICB9KVxufVxuXG5mdW5jdGlvbiBzZXREZXN0TW9kZUFuZFRpbWVzdGFtcHMgKHNyY1N0YXQsIGRlc3QsIG9wdHMsIGNiKSB7XG4gIGZzLmNobW9kKGRlc3QsIHNyY1N0YXQubW9kZSwgZXJyID0+IHtcbiAgICBpZiAoZXJyKSByZXR1cm4gY2IoZXJyKVxuICAgIGlmIChvcHRzLnByZXNlcnZlVGltZXN0YW1wcykge1xuICAgICAgcmV0dXJuIHV0aW1lcyhkZXN0LCBzcmNTdGF0LmF0aW1lLCBzcmNTdGF0Lm10aW1lLCBjYilcbiAgICB9XG4gICAgcmV0dXJuIGNiKClcbiAgfSlcbn1cblxuZnVuY3Rpb24gb25EaXIgKHNyY1N0YXQsIHNyYywgZGVzdCwgb3B0cywgY2IpIHtcbiAgY2hlY2tEZXN0KGRlc3QsIChlcnIsIHJlc29sdmVkUGF0aCkgPT4ge1xuICAgIGlmIChlcnIpIHJldHVybiBjYihlcnIpXG4gICAgaWYgKHJlc29sdmVkUGF0aCA9PT0gbm90RXhpc3QpIHtcbiAgICAgIGlmIChpc1NyY1N1YmRpcihzcmMsIGRlc3QpKSB7XG4gICAgICAgIHJldHVybiBjYihuZXcgRXJyb3IoYENhbm5vdCBjb3B5ICcke3NyY30nIHRvIGEgc3ViZGlyZWN0b3J5IG9mIGl0c2VsZiwgJyR7ZGVzdH0nLmApKVxuICAgICAgfVxuICAgICAgcmV0dXJuIG1rRGlyQW5kQ29weShzcmNTdGF0LCBzcmMsIGRlc3QsIG9wdHMsIGNiKVxuICAgIH0gZWxzZSBpZiAocmVzb2x2ZWRQYXRoID09PSBleGlzdHNSZWcpIHtcbiAgICAgIGlmIChpc1NyY1N1YmRpcihzcmMsIGRlc3QpKSB7XG4gICAgICAgIHJldHVybiBjYihuZXcgRXJyb3IoYENhbm5vdCBjb3B5ICcke3NyY30nIHRvIGEgc3ViZGlyZWN0b3J5IG9mIGl0c2VsZiwgJyR7ZGVzdH0nLmApKVxuICAgICAgfVxuICAgICAgcmV0dXJuIG1heUNvcHlEaXIoc3JjLCBkZXN0LCBvcHRzLCBjYilcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHNyYyA9PT0gcmVzb2x2ZWRQYXRoKSByZXR1cm4gY2IoKVxuICAgICAgcmV0dXJuIGNvcHlEaXIoc3JjLCBkZXN0LCBvcHRzLCBjYilcbiAgICB9XG4gIH0pXG59XG5cbmZ1bmN0aW9uIG1heUNvcHlEaXIgKHNyYywgZGVzdCwgb3B0cywgY2IpIHtcbiAgZnMuc3RhdChkZXN0LCAoZXJyLCBzdCkgPT4ge1xuICAgIGlmIChlcnIpIHJldHVybiBjYihlcnIpXG4gICAgaWYgKCFzdC5pc0RpcmVjdG9yeSgpKSB7XG4gICAgICByZXR1cm4gY2IobmV3IEVycm9yKGBDYW5ub3Qgb3ZlcndyaXRlIG5vbi1kaXJlY3RvcnkgJyR7ZGVzdH0nIHdpdGggZGlyZWN0b3J5ICcke3NyY30nLmApKVxuICAgIH1cbiAgICByZXR1cm4gY29weURpcihzcmMsIGRlc3QsIG9wdHMsIGNiKVxuICB9KVxufVxuXG5mdW5jdGlvbiBta0RpckFuZENvcHkgKHNyY1N0YXQsIHNyYywgZGVzdCwgb3B0cywgY2IpIHtcbiAgZnMubWtkaXIoZGVzdCwgc3JjU3RhdC5tb2RlLCBlcnIgPT4ge1xuICAgIGlmIChlcnIpIHJldHVybiBjYihlcnIpXG4gICAgZnMuY2htb2QoZGVzdCwgc3JjU3RhdC5tb2RlLCBlcnIgPT4ge1xuICAgICAgaWYgKGVycikgcmV0dXJuIGNiKGVycilcbiAgICAgIHJldHVybiBjb3B5RGlyKHNyYywgZGVzdCwgb3B0cywgY2IpXG4gICAgfSlcbiAgfSlcbn1cblxuZnVuY3Rpb24gY29weURpciAoc3JjLCBkZXN0LCBvcHRzLCBjYikge1xuICBmcy5yZWFkZGlyKHNyYywgKGVyciwgaXRlbXMpID0+IHtcbiAgICBpZiAoZXJyKSByZXR1cm4gY2IoZXJyKVxuICAgIHJldHVybiBjb3B5RGlySXRlbXMoaXRlbXMsIHNyYywgZGVzdCwgb3B0cywgY2IpXG4gIH0pXG59XG5cbmZ1bmN0aW9uIGNvcHlEaXJJdGVtcyAoaXRlbXMsIHNyYywgZGVzdCwgb3B0cywgY2IpIHtcbiAgY29uc3QgaXRlbSA9IGl0ZW1zLnBvcCgpXG4gIGlmICghaXRlbSkgcmV0dXJuIGNiKClcbiAgc3RhcnRDb3B5KHBhdGguam9pbihzcmMsIGl0ZW0pLCBwYXRoLmpvaW4oZGVzdCwgaXRlbSksIG9wdHMsIGVyciA9PiB7XG4gICAgaWYgKGVycikgcmV0dXJuIGNiKGVycilcbiAgICByZXR1cm4gY29weURpckl0ZW1zKGl0ZW1zLCBzcmMsIGRlc3QsIG9wdHMsIGNiKVxuICB9KVxufVxuXG5mdW5jdGlvbiBvbkxpbmsgKHNyYywgZGVzdCwgb3B0cywgY2IpIHtcbiAgZnMucmVhZGxpbmsoc3JjLCAoZXJyLCByZXNvbHZlZFNyY1BhdGgpID0+IHtcbiAgICBpZiAoZXJyKSByZXR1cm4gY2IoZXJyKVxuXG4gICAgaWYgKG9wdHMuZGVyZWZlcmVuY2UpIHtcbiAgICAgIHJlc29sdmVkU3JjUGF0aCA9IHBhdGgucmVzb2x2ZShwcm9jZXNzLmN3ZCgpLCByZXNvbHZlZFNyY1BhdGgpXG4gICAgfVxuXG4gICAgY2hlY2tEZXN0KGRlc3QsIChlcnIsIHJlc29sdmVkRGVzdFBhdGgpID0+IHtcbiAgICAgIGlmIChlcnIpIHJldHVybiBjYihlcnIpXG5cbiAgICAgIGlmIChyZXNvbHZlZERlc3RQYXRoID09PSBub3RFeGlzdCB8fCByZXNvbHZlZERlc3RQYXRoID09PSBleGlzdHNSZWcpIHtcbiAgICAgICAgLy8gaWYgZGVzdCBhbHJlYWR5IGV4aXN0cywgZnMgdGhyb3dzIGVycm9yIGFueXdheSxcbiAgICAgICAgLy8gc28gbm8gbmVlZCB0byBndWFyZCBhZ2FpbnN0IGl0IGhlcmUuXG4gICAgICAgIHJldHVybiBmcy5zeW1saW5rKHJlc29sdmVkU3JjUGF0aCwgZGVzdCwgY2IpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAob3B0cy5kZXJlZmVyZW5jZSkge1xuICAgICAgICAgIHJlc29sdmVkRGVzdFBhdGggPSBwYXRoLnJlc29sdmUocHJvY2Vzcy5jd2QoKSwgcmVzb2x2ZWREZXN0UGF0aClcbiAgICAgICAgfVxuICAgICAgICBpZiAocmVzb2x2ZWREZXN0UGF0aCA9PT0gcmVzb2x2ZWRTcmNQYXRoKSByZXR1cm4gY2IoKVxuXG4gICAgICAgIC8vIHByZXZlbnQgY29weSBpZiBzcmMgaXMgYSBzdWJkaXIgb2YgZGVzdCBzaW5jZSB1bmxpbmtpbmdcbiAgICAgICAgLy8gZGVzdCBpbiB0aGlzIGNhc2Ugd291bGQgcmVzdWx0IGluIHJlbW92aW5nIHNyYyBjb250ZW50c1xuICAgICAgICAvLyBhbmQgdGhlcmVmb3JlIGEgYnJva2VuIHN5bWxpbmsgd291bGQgYmUgY3JlYXRlZC5cbiAgICAgICAgZnMuc3RhdChkZXN0LCAoZXJyLCBzdCkgPT4ge1xuICAgICAgICAgIGlmIChlcnIpIHJldHVybiBjYihlcnIpXG4gICAgICAgICAgaWYgKHN0LmlzRGlyZWN0b3J5KCkgJiYgaXNTcmNTdWJkaXIocmVzb2x2ZWREZXN0UGF0aCwgcmVzb2x2ZWRTcmNQYXRoKSkge1xuICAgICAgICAgICAgcmV0dXJuIGNiKG5ldyBFcnJvcihgQ2Fubm90IG92ZXJ3cml0ZSAnJHtyZXNvbHZlZERlc3RQYXRofScgd2l0aCAnJHtyZXNvbHZlZFNyY1BhdGh9Jy5gKSlcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIGNvcHlMaW5rKHJlc29sdmVkU3JjUGF0aCwgZGVzdCwgY2IpXG4gICAgICAgIH0pXG4gICAgICB9XG4gICAgfSlcbiAgfSlcbn1cblxuZnVuY3Rpb24gY29weUxpbmsgKHJlc29sdmVkU3JjUGF0aCwgZGVzdCwgY2IpIHtcbiAgZnMudW5saW5rKGRlc3QsIGVyciA9PiB7XG4gICAgaWYgKGVycikgcmV0dXJuIGNiKGVycilcbiAgICByZXR1cm4gZnMuc3ltbGluayhyZXNvbHZlZFNyY1BhdGgsIGRlc3QsIGNiKVxuICB9KVxufVxuXG4vLyBjaGVjayBpZiBkZXN0IGV4aXN0cyBhbmQvb3IgaXMgYSBzeW1saW5rXG5mdW5jdGlvbiBjaGVja0Rlc3QgKGRlc3QsIGNiKSB7XG4gIGZzLnJlYWRsaW5rKGRlc3QsIChlcnIsIHJlc29sdmVkUGF0aCkgPT4ge1xuICAgIGlmIChlcnIpIHtcbiAgICAgIGlmIChlcnIuY29kZSA9PT0gJ0VOT0VOVCcpIHJldHVybiBjYihudWxsLCBub3RFeGlzdClcblxuICAgICAgLy8gZGVzdCBleGlzdHMgYW5kIGlzIGEgcmVndWxhciBmaWxlIG9yIGRpcmVjdG9yeSwgV2luZG93cyBtYXkgdGhyb3cgVU5LTk9XTiBlcnJvci5cbiAgICAgIGlmIChlcnIuY29kZSA9PT0gJ0VJTlZBTCcgfHwgZXJyLmNvZGUgPT09ICdVTktOT1dOJykgcmV0dXJuIGNiKG51bGwsIGV4aXN0c1JlZylcblxuICAgICAgcmV0dXJuIGNiKGVycilcbiAgICB9XG4gICAgcmV0dXJuIGNiKG51bGwsIHJlc29sdmVkUGF0aCkgLy8gZGVzdCBleGlzdHMgYW5kIGlzIGEgc3ltbGlua1xuICB9KVxufVxuXG4vLyByZXR1cm4gdHJ1ZSBpZiBkZXN0IGlzIGEgc3ViZGlyIG9mIHNyYywgb3RoZXJ3aXNlIGZhbHNlLlxuLy8gZXh0cmFjdCBkZXN0IGJhc2UgZGlyIGFuZCBjaGVjayBpZiB0aGF0IGlzIHRoZSBzYW1lIGFzIHNyYyBiYXNlbmFtZVxuZnVuY3Rpb24gaXNTcmNTdWJkaXIgKHNyYywgZGVzdCkge1xuICBjb25zdCBiYXNlRGlyID0gZGVzdC5zcGxpdChwYXRoLmRpcm5hbWUoc3JjKSArIHBhdGguc2VwKVsxXVxuICBpZiAoYmFzZURpcikge1xuICAgIGNvbnN0IGRlc3RCYXNlbmFtZSA9IGJhc2VEaXIuc3BsaXQocGF0aC5zZXApWzBdXG4gICAgaWYgKGRlc3RCYXNlbmFtZSkge1xuICAgICAgcmV0dXJuIHNyYyAhPT0gZGVzdCAmJiBkZXN0LmluZGV4T2Yoc3JjKSA+IC0xICYmIGRlc3RCYXNlbmFtZSA9PT0gcGF0aC5iYXNlbmFtZShzcmMpXG4gICAgfVxuICAgIHJldHVybiBmYWxzZVxuICB9XG4gIHJldHVybiBmYWxzZVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNvcHlcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9lbGVjdHJvbi11cGRhdGVyL25vZGVfbW9kdWxlcy9mcy1leHRyYS9saWIvY29weS9jb3B5LmpzIiwiJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IHBhdGggPSByZXF1aXJlKCdwYXRoJylcblxuLy8gZ2V0IGRyaXZlIG9uIHdpbmRvd3NcbmZ1bmN0aW9uIGdldFJvb3RQYXRoIChwKSB7XG4gIHAgPSBwYXRoLm5vcm1hbGl6ZShwYXRoLnJlc29sdmUocCkpLnNwbGl0KHBhdGguc2VwKVxuICBpZiAocC5sZW5ndGggPiAwKSByZXR1cm4gcFswXVxuICByZXR1cm4gbnVsbFxufVxuXG4vLyBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vYS82Mjg4OC8xMDMzMyBjb250YWlucyBtb3JlIGFjY3VyYXRlXG4vLyBUT0RPOiBleHBhbmQgdG8gaW5jbHVkZSB0aGUgcmVzdFxuY29uc3QgSU5WQUxJRF9QQVRIX0NIQVJTID0gL1s8PjpcInw/Kl0vXG5cbmZ1bmN0aW9uIGludmFsaWRXaW4zMlBhdGggKHApIHtcbiAgY29uc3QgcnAgPSBnZXRSb290UGF0aChwKVxuICBwID0gcC5yZXBsYWNlKHJwLCAnJylcbiAgcmV0dXJuIElOVkFMSURfUEFUSF9DSEFSUy50ZXN0KHApXG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBnZXRSb290UGF0aCxcbiAgaW52YWxpZFdpbjMyUGF0aFxufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2VsZWN0cm9uLXVwZGF0ZXIvbm9kZV9tb2R1bGVzL2ZzLWV4dHJhL2xpYi9ta2RpcnMvd2luMzIuanMiLCIndXNlIHN0cmljdCdcblxuY29uc3QgZnMgPSByZXF1aXJlKCdncmFjZWZ1bC1mcycpXG5jb25zdCBvcyA9IHJlcXVpcmUoJ29zJylcbmNvbnN0IHBhdGggPSByZXF1aXJlKCdwYXRoJylcblxuLy8gSEZTLCBleHR7MiwzfSwgRkFUIGRvIG5vdCwgTm9kZS5qcyB2MC4xMCBkb2VzIG5vdFxuZnVuY3Rpb24gaGFzTWlsbGlzUmVzU3luYyAoKSB7XG4gIGxldCB0bXBmaWxlID0gcGF0aC5qb2luKCdtaWxsaXMtdGVzdC1zeW5jJyArIERhdGUubm93KCkudG9TdHJpbmcoKSArIE1hdGgucmFuZG9tKCkudG9TdHJpbmcoKS5zbGljZSgyKSlcbiAgdG1wZmlsZSA9IHBhdGguam9pbihvcy50bXBkaXIoKSwgdG1wZmlsZSlcblxuICAvLyA1NTAgbWlsbGlzIHBhc3QgVU5JWCBlcG9jaFxuICBjb25zdCBkID0gbmV3IERhdGUoMTQzNTQxMDI0Mzg2MilcbiAgZnMud3JpdGVGaWxlU3luYyh0bXBmaWxlLCAnaHR0cHM6Ly9naXRodWIuY29tL2pwcmljaGFyZHNvbi9ub2RlLWZzLWV4dHJhL3B1bGwvMTQxJylcbiAgY29uc3QgZmQgPSBmcy5vcGVuU3luYyh0bXBmaWxlLCAncisnKVxuICBmcy5mdXRpbWVzU3luYyhmZCwgZCwgZClcbiAgZnMuY2xvc2VTeW5jKGZkKVxuICByZXR1cm4gZnMuc3RhdFN5bmModG1wZmlsZSkubXRpbWUgPiAxNDM1NDEwMjQzMDAwXG59XG5cbmZ1bmN0aW9uIGhhc01pbGxpc1JlcyAoY2FsbGJhY2spIHtcbiAgbGV0IHRtcGZpbGUgPSBwYXRoLmpvaW4oJ21pbGxpcy10ZXN0JyArIERhdGUubm93KCkudG9TdHJpbmcoKSArIE1hdGgucmFuZG9tKCkudG9TdHJpbmcoKS5zbGljZSgyKSlcbiAgdG1wZmlsZSA9IHBhdGguam9pbihvcy50bXBkaXIoKSwgdG1wZmlsZSlcblxuICAvLyA1NTAgbWlsbGlzIHBhc3QgVU5JWCBlcG9jaFxuICBjb25zdCBkID0gbmV3IERhdGUoMTQzNTQxMDI0Mzg2MilcbiAgZnMud3JpdGVGaWxlKHRtcGZpbGUsICdodHRwczovL2dpdGh1Yi5jb20vanByaWNoYXJkc29uL25vZGUtZnMtZXh0cmEvcHVsbC8xNDEnLCBlcnIgPT4ge1xuICAgIGlmIChlcnIpIHJldHVybiBjYWxsYmFjayhlcnIpXG4gICAgZnMub3Blbih0bXBmaWxlLCAncisnLCAoZXJyLCBmZCkgPT4ge1xuICAgICAgaWYgKGVycikgcmV0dXJuIGNhbGxiYWNrKGVycilcbiAgICAgIGZzLmZ1dGltZXMoZmQsIGQsIGQsIGVyciA9PiB7XG4gICAgICAgIGlmIChlcnIpIHJldHVybiBjYWxsYmFjayhlcnIpXG4gICAgICAgIGZzLmNsb3NlKGZkLCBlcnIgPT4ge1xuICAgICAgICAgIGlmIChlcnIpIHJldHVybiBjYWxsYmFjayhlcnIpXG4gICAgICAgICAgZnMuc3RhdCh0bXBmaWxlLCAoZXJyLCBzdGF0cykgPT4ge1xuICAgICAgICAgICAgaWYgKGVycikgcmV0dXJuIGNhbGxiYWNrKGVycilcbiAgICAgICAgICAgIGNhbGxiYWNrKG51bGwsIHN0YXRzLm10aW1lID4gMTQzNTQxMDI0MzAwMClcbiAgICAgICAgICB9KVxuICAgICAgICB9KVxuICAgICAgfSlcbiAgICB9KVxuICB9KVxufVxuXG5mdW5jdGlvbiB0aW1lUmVtb3ZlTWlsbGlzICh0aW1lc3RhbXApIHtcbiAgaWYgKHR5cGVvZiB0aW1lc3RhbXAgPT09ICdudW1iZXInKSB7XG4gICAgcmV0dXJuIE1hdGguZmxvb3IodGltZXN0YW1wIC8gMTAwMCkgKiAxMDAwXG4gIH0gZWxzZSBpZiAodGltZXN0YW1wIGluc3RhbmNlb2YgRGF0ZSkge1xuICAgIHJldHVybiBuZXcgRGF0ZShNYXRoLmZsb29yKHRpbWVzdGFtcC5nZXRUaW1lKCkgLyAxMDAwKSAqIDEwMDApXG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdmcy1leHRyYTogdGltZVJlbW92ZU1pbGxpcygpIHVua25vd24gcGFyYW1ldGVyIHR5cGUnKVxuICB9XG59XG5cbmZ1bmN0aW9uIHV0aW1lc01pbGxpcyAocGF0aCwgYXRpbWUsIG10aW1lLCBjYWxsYmFjaykge1xuICAvLyBpZiAoIUhBU19NSUxMSVNfUkVTKSByZXR1cm4gZnMudXRpbWVzKHBhdGgsIGF0aW1lLCBtdGltZSwgY2FsbGJhY2spXG4gIGZzLm9wZW4ocGF0aCwgJ3IrJywgKGVyciwgZmQpID0+IHtcbiAgICBpZiAoZXJyKSByZXR1cm4gY2FsbGJhY2soZXJyKVxuICAgIGZzLmZ1dGltZXMoZmQsIGF0aW1lLCBtdGltZSwgZnV0aW1lc0VyciA9PiB7XG4gICAgICBmcy5jbG9zZShmZCwgY2xvc2VFcnIgPT4ge1xuICAgICAgICBpZiAoY2FsbGJhY2spIGNhbGxiYWNrKGZ1dGltZXNFcnIgfHwgY2xvc2VFcnIpXG4gICAgICB9KVxuICAgIH0pXG4gIH0pXG59XG5cbmZ1bmN0aW9uIHV0aW1lc01pbGxpc1N5bmMgKHBhdGgsIGF0aW1lLCBtdGltZSkge1xuICBjb25zdCBmZCA9IGZzLm9wZW5TeW5jKHBhdGgsICdyKycpXG4gIGZzLmZ1dGltZXNTeW5jKGZkLCBhdGltZSwgbXRpbWUpXG4gIHJldHVybiBmcy5jbG9zZVN5bmMoZmQpXG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBoYXNNaWxsaXNSZXMsXG4gIGhhc01pbGxpc1Jlc1N5bmMsXG4gIHRpbWVSZW1vdmVNaWxsaXMsXG4gIHV0aW1lc01pbGxpcyxcbiAgdXRpbWVzTWlsbGlzU3luY1xufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2VsZWN0cm9uLXVwZGF0ZXIvbm9kZV9tb2R1bGVzL2ZzLWV4dHJhL2xpYi91dGlsL3V0aW1lcy5qcyIsIm1vZHVsZS5leHBvcnRzID0ge1xuICBjb3B5U3luYzogcmVxdWlyZSgnLi9jb3B5LXN5bmMnKVxufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2VsZWN0cm9uLXVwZGF0ZXIvbm9kZV9tb2R1bGVzL2ZzLWV4dHJhL2xpYi9jb3B5LXN5bmMvaW5kZXguanMiLCIvKiBlc2xpbnQtZGlzYWJsZSBub2RlL25vLWRlcHJlY2F0ZWQtYXBpICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChzaXplKSB7XG4gIGlmICh0eXBlb2YgQnVmZmVyLmFsbG9jVW5zYWZlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBCdWZmZXIuYWxsb2NVbnNhZmUoc2l6ZSlcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICByZXR1cm4gbmV3IEJ1ZmZlcihzaXplKVxuICAgIH1cbiAgfVxuICByZXR1cm4gbmV3IEJ1ZmZlcihzaXplKVxufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2VsZWN0cm9uLXVwZGF0ZXIvbm9kZV9tb2R1bGVzL2ZzLWV4dHJhL2xpYi91dGlsL2J1ZmZlci5qcyIsIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLlByb2dyZXNzQ2FsbGJhY2tUcmFuc2Zvcm0gPSB1bmRlZmluZWQ7XG5cbnZhciBfc3RyZWFtO1xuXG5mdW5jdGlvbiBfbG9hZF9zdHJlYW0oKSB7XG4gICAgcmV0dXJuIF9zdHJlYW0gPSByZXF1aXJlKFwic3RyZWFtXCIpO1xufVxuXG5jbGFzcyBQcm9ncmVzc0NhbGxiYWNrVHJhbnNmb3JtIGV4dGVuZHMgKF9zdHJlYW0gfHwgX2xvYWRfc3RyZWFtKCkpLlRyYW5zZm9ybSB7XG4gICAgY29uc3RydWN0b3IodG90YWwsIGNhbmNlbGxhdGlvblRva2VuLCBvblByb2dyZXNzKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMudG90YWwgPSB0b3RhbDtcbiAgICAgICAgdGhpcy5jYW5jZWxsYXRpb25Ub2tlbiA9IGNhbmNlbGxhdGlvblRva2VuO1xuICAgICAgICB0aGlzLm9uUHJvZ3Jlc3MgPSBvblByb2dyZXNzO1xuICAgICAgICB0aGlzLnN0YXJ0ID0gRGF0ZS5ub3coKTtcbiAgICAgICAgdGhpcy50cmFuc2ZlcnJlZCA9IDA7XG4gICAgICAgIHRoaXMuZGVsdGEgPSAwO1xuICAgICAgICB0aGlzLm5leHRVcGRhdGUgPSB0aGlzLnN0YXJ0ICsgMTAwMDtcbiAgICB9XG4gICAgX3RyYW5zZm9ybShjaHVuaywgZW5jb2RpbmcsIGNhbGxiYWNrKSB7XG4gICAgICAgIGlmICh0aGlzLmNhbmNlbGxhdGlvblRva2VuLmNhbmNlbGxlZCkge1xuICAgICAgICAgICAgY2FsbGJhY2sobmV3IEVycm9yKFwiQ2FuY2VsbGVkXCIpLCBudWxsKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnRyYW5zZmVycmVkICs9IGNodW5rLmxlbmd0aDtcbiAgICAgICAgdGhpcy5kZWx0YSArPSBjaHVuay5sZW5ndGg7XG4gICAgICAgIGNvbnN0IG5vdyA9IERhdGUubm93KCk7XG4gICAgICAgIGlmIChub3cgPj0gdGhpcy5uZXh0VXBkYXRlICYmIHRoaXMudHJhbnNmZXJyZWQgIT09IHRoaXMudG90YWwgLyogd2lsbCBiZSBlbWl0dGVkIG9uIF9mbHVzaCAqLykge1xuICAgICAgICAgICAgICAgIHRoaXMubmV4dFVwZGF0ZSA9IG5vdyArIDEwMDA7XG4gICAgICAgICAgICAgICAgdGhpcy5vblByb2dyZXNzKHtcbiAgICAgICAgICAgICAgICAgICAgdG90YWw6IHRoaXMudG90YWwsXG4gICAgICAgICAgICAgICAgICAgIGRlbHRhOiB0aGlzLmRlbHRhLFxuICAgICAgICAgICAgICAgICAgICB0cmFuc2ZlcnJlZDogdGhpcy50cmFuc2ZlcnJlZCxcbiAgICAgICAgICAgICAgICAgICAgcGVyY2VudDogdGhpcy50cmFuc2ZlcnJlZCAvIHRoaXMudG90YWwgKiAxMDAsXG4gICAgICAgICAgICAgICAgICAgIGJ5dGVzUGVyU2Vjb25kOiBNYXRoLnJvdW5kKHRoaXMudHJhbnNmZXJyZWQgLyAoKG5vdyAtIHRoaXMuc3RhcnQpIC8gMTAwMCkpXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgdGhpcy5kZWx0YSA9IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgIGNhbGxiYWNrKG51bGwsIGNodW5rKTtcbiAgICB9XG4gICAgX2ZsdXNoKGNhbGxiYWNrKSB7XG4gICAgICAgIGlmICh0aGlzLmNhbmNlbGxhdGlvblRva2VuLmNhbmNlbGxlZCkge1xuICAgICAgICAgICAgY2FsbGJhY2sobmV3IEVycm9yKFwiQ2FuY2VsbGVkXCIpKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm9uUHJvZ3Jlc3Moe1xuICAgICAgICAgICAgdG90YWw6IHRoaXMudG90YWwsXG4gICAgICAgICAgICBkZWx0YTogdGhpcy5kZWx0YSxcbiAgICAgICAgICAgIHRyYW5zZmVycmVkOiB0aGlzLnRvdGFsLFxuICAgICAgICAgICAgcGVyY2VudDogMTAwLFxuICAgICAgICAgICAgYnl0ZXNQZXJTZWNvbmQ6IE1hdGgucm91bmQodGhpcy50cmFuc2ZlcnJlZCAvICgoRGF0ZS5ub3coKSAtIHRoaXMuc3RhcnQpIC8gMTAwMCkpXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmRlbHRhID0gMDtcbiAgICAgICAgY2FsbGJhY2sobnVsbCk7XG4gICAgfVxufVxuZXhwb3J0cy5Qcm9ncmVzc0NhbGxiYWNrVHJhbnNmb3JtID0gUHJvZ3Jlc3NDYWxsYmFja1RyYW5zZm9ybTsgLy8jIHNvdXJjZU1hcHBpbmdVUkw9UHJvZ3Jlc3NDYWxsYmFja1RyYW5zZm9ybS5qcy5tYXBcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvZWxlY3Ryb24tdXBkYXRlci9ub2RlX21vZHVsZXMvYnVpbGRlci11dGlsLXJ1bnRpbWUvb3V0L1Byb2dyZXNzQ2FsbGJhY2tUcmFuc2Zvcm0uanMiLCIvLyBTdGFuZGFyZCBZQU1MJ3MgQ29yZSBzY2hlbWEuXG4vLyBodHRwOi8vd3d3LnlhbWwub3JnL3NwZWMvMS4yL3NwZWMuaHRtbCNpZDI4MDQ5MjNcbi8vXG4vLyBOT1RFOiBKUy1ZQU1MIGRvZXMgbm90IHN1cHBvcnQgc2NoZW1hLXNwZWNpZmljIHRhZyByZXNvbHV0aW9uIHJlc3RyaWN0aW9ucy5cbi8vIFNvLCBDb3JlIHNjaGVtYSBoYXMgbm8gZGlzdGluY3Rpb25zIGZyb20gSlNPTiBzY2hlbWEgaXMgSlMtWUFNTC5cblxuXG4ndXNlIHN0cmljdCc7XG5cblxudmFyIFNjaGVtYSA9IHJlcXVpcmUoJy4uL3NjaGVtYScpO1xuXG5cbm1vZHVsZS5leHBvcnRzID0gbmV3IFNjaGVtYSh7XG4gIGluY2x1ZGU6IFtcbiAgICByZXF1aXJlKCcuL2pzb24nKVxuICBdXG59KTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9qcy15YW1sL2xpYi9qcy15YW1sL3NjaGVtYS9jb3JlLmpzIiwiLy8gU3RhbmRhcmQgWUFNTCdzIEpTT04gc2NoZW1hLlxuLy8gaHR0cDovL3d3dy55YW1sLm9yZy9zcGVjLzEuMi9zcGVjLmh0bWwjaWQyODAzMjMxXG4vL1xuLy8gTk9URTogSlMtWUFNTCBkb2VzIG5vdCBzdXBwb3J0IHNjaGVtYS1zcGVjaWZpYyB0YWcgcmVzb2x1dGlvbiByZXN0cmljdGlvbnMuXG4vLyBTbywgdGhpcyBzY2hlbWEgaXMgbm90IHN1Y2ggc3RyaWN0IGFzIGRlZmluZWQgaW4gdGhlIFlBTUwgc3BlY2lmaWNhdGlvbi5cbi8vIEl0IGFsbG93cyBudW1iZXJzIGluIGJpbmFyeSBub3RhaW9uLCB1c2UgYE51bGxgIGFuZCBgTlVMTGAgYXMgYG51bGxgLCBldGMuXG5cblxuJ3VzZSBzdHJpY3QnO1xuXG5cbnZhciBTY2hlbWEgPSByZXF1aXJlKCcuLi9zY2hlbWEnKTtcblxuXG5tb2R1bGUuZXhwb3J0cyA9IG5ldyBTY2hlbWEoe1xuICBpbmNsdWRlOiBbXG4gICAgcmVxdWlyZSgnLi9mYWlsc2FmZScpXG4gIF0sXG4gIGltcGxpY2l0OiBbXG4gICAgcmVxdWlyZSgnLi4vdHlwZS9udWxsJyksXG4gICAgcmVxdWlyZSgnLi4vdHlwZS9ib29sJyksXG4gICAgcmVxdWlyZSgnLi4vdHlwZS9pbnQnKSxcbiAgICByZXF1aXJlKCcuLi90eXBlL2Zsb2F0JylcbiAgXVxufSk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvanMteWFtbC9saWIvanMteWFtbC9zY2hlbWEvanNvbi5qcyIsImV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IFNlbVZlcjtcblxuLy8gVGhlIGRlYnVnIGZ1bmN0aW9uIGlzIGV4Y2x1ZGVkIGVudGlyZWx5IGZyb20gdGhlIG1pbmlmaWVkIHZlcnNpb24uXG4vKiBub21pbiAqLyB2YXIgZGVidWc7XG4vKiBub21pbiAqLyBpZiAodHlwZW9mIHByb2Nlc3MgPT09ICdvYmplY3QnICYmXG4gICAgLyogbm9taW4gKi8gcHJvY2Vzcy5lbnYgJiZcbiAgICAvKiBub21pbiAqLyBwcm9jZXNzLmVudi5OT0RFX0RFQlVHICYmXG4gICAgLyogbm9taW4gKi8gL1xcYnNlbXZlclxcYi9pLnRlc3QocHJvY2Vzcy5lbnYuTk9ERV9ERUJVRykpXG4gIC8qIG5vbWluICovIGRlYnVnID0gZnVuY3Rpb24oKSB7XG4gICAgLyogbm9taW4gKi8gdmFyIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDApO1xuICAgIC8qIG5vbWluICovIGFyZ3MudW5zaGlmdCgnU0VNVkVSJyk7XG4gICAgLyogbm9taW4gKi8gY29uc29sZS5sb2cuYXBwbHkoY29uc29sZSwgYXJncyk7XG4gICAgLyogbm9taW4gKi8gfTtcbi8qIG5vbWluICovIGVsc2VcbiAgLyogbm9taW4gKi8gZGVidWcgPSBmdW5jdGlvbigpIHt9O1xuXG4vLyBOb3RlOiB0aGlzIGlzIHRoZSBzZW12ZXIub3JnIHZlcnNpb24gb2YgdGhlIHNwZWMgdGhhdCBpdCBpbXBsZW1lbnRzXG4vLyBOb3QgbmVjZXNzYXJpbHkgdGhlIHBhY2thZ2UgdmVyc2lvbiBvZiB0aGlzIGNvZGUuXG5leHBvcnRzLlNFTVZFUl9TUEVDX1ZFUlNJT04gPSAnMi4wLjAnO1xuXG52YXIgTUFYX0xFTkdUSCA9IDI1NjtcbnZhciBNQVhfU0FGRV9JTlRFR0VSID0gTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVIgfHwgOTAwNzE5OTI1NDc0MDk5MTtcblxuLy8gVGhlIGFjdHVhbCByZWdleHBzIGdvIG9uIGV4cG9ydHMucmVcbnZhciByZSA9IGV4cG9ydHMucmUgPSBbXTtcbnZhciBzcmMgPSBleHBvcnRzLnNyYyA9IFtdO1xudmFyIFIgPSAwO1xuXG4vLyBUaGUgZm9sbG93aW5nIFJlZ3VsYXIgRXhwcmVzc2lvbnMgY2FuIGJlIHVzZWQgZm9yIHRva2VuaXppbmcsXG4vLyB2YWxpZGF0aW5nLCBhbmQgcGFyc2luZyBTZW1WZXIgdmVyc2lvbiBzdHJpbmdzLlxuXG4vLyAjIyBOdW1lcmljIElkZW50aWZpZXJcbi8vIEEgc2luZ2xlIGAwYCwgb3IgYSBub24temVybyBkaWdpdCBmb2xsb3dlZCBieSB6ZXJvIG9yIG1vcmUgZGlnaXRzLlxuXG52YXIgTlVNRVJJQ0lERU5USUZJRVIgPSBSKys7XG5zcmNbTlVNRVJJQ0lERU5USUZJRVJdID0gJzB8WzEtOV1cXFxcZConO1xudmFyIE5VTUVSSUNJREVOVElGSUVSTE9PU0UgPSBSKys7XG5zcmNbTlVNRVJJQ0lERU5USUZJRVJMT09TRV0gPSAnWzAtOV0rJztcblxuXG4vLyAjIyBOb24tbnVtZXJpYyBJZGVudGlmaWVyXG4vLyBaZXJvIG9yIG1vcmUgZGlnaXRzLCBmb2xsb3dlZCBieSBhIGxldHRlciBvciBoeXBoZW4sIGFuZCB0aGVuIHplcm8gb3Jcbi8vIG1vcmUgbGV0dGVycywgZGlnaXRzLCBvciBoeXBoZW5zLlxuXG52YXIgTk9OTlVNRVJJQ0lERU5USUZJRVIgPSBSKys7XG5zcmNbTk9OTlVNRVJJQ0lERU5USUZJRVJdID0gJ1xcXFxkKlthLXpBLVotXVthLXpBLVowLTktXSonO1xuXG5cbi8vICMjIE1haW4gVmVyc2lvblxuLy8gVGhyZWUgZG90LXNlcGFyYXRlZCBudW1lcmljIGlkZW50aWZpZXJzLlxuXG52YXIgTUFJTlZFUlNJT04gPSBSKys7XG5zcmNbTUFJTlZFUlNJT05dID0gJygnICsgc3JjW05VTUVSSUNJREVOVElGSUVSXSArICcpXFxcXC4nICtcbiAgICAgICAgICAgICAgICAgICAnKCcgKyBzcmNbTlVNRVJJQ0lERU5USUZJRVJdICsgJylcXFxcLicgK1xuICAgICAgICAgICAgICAgICAgICcoJyArIHNyY1tOVU1FUklDSURFTlRJRklFUl0gKyAnKSc7XG5cbnZhciBNQUlOVkVSU0lPTkxPT1NFID0gUisrO1xuc3JjW01BSU5WRVJTSU9OTE9PU0VdID0gJygnICsgc3JjW05VTUVSSUNJREVOVElGSUVSTE9PU0VdICsgJylcXFxcLicgK1xuICAgICAgICAgICAgICAgICAgICAgICAgJygnICsgc3JjW05VTUVSSUNJREVOVElGSUVSTE9PU0VdICsgJylcXFxcLicgK1xuICAgICAgICAgICAgICAgICAgICAgICAgJygnICsgc3JjW05VTUVSSUNJREVOVElGSUVSTE9PU0VdICsgJyknO1xuXG4vLyAjIyBQcmUtcmVsZWFzZSBWZXJzaW9uIElkZW50aWZpZXJcbi8vIEEgbnVtZXJpYyBpZGVudGlmaWVyLCBvciBhIG5vbi1udW1lcmljIGlkZW50aWZpZXIuXG5cbnZhciBQUkVSRUxFQVNFSURFTlRJRklFUiA9IFIrKztcbnNyY1tQUkVSRUxFQVNFSURFTlRJRklFUl0gPSAnKD86JyArIHNyY1tOVU1FUklDSURFTlRJRklFUl0gK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICd8JyArIHNyY1tOT05OVU1FUklDSURFTlRJRklFUl0gKyAnKSc7XG5cbnZhciBQUkVSRUxFQVNFSURFTlRJRklFUkxPT1NFID0gUisrO1xuc3JjW1BSRVJFTEVBU0VJREVOVElGSUVSTE9PU0VdID0gJyg/OicgKyBzcmNbTlVNRVJJQ0lERU5USUZJRVJMT09TRV0gK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ3wnICsgc3JjW05PTk5VTUVSSUNJREVOVElGSUVSXSArICcpJztcblxuXG4vLyAjIyBQcmUtcmVsZWFzZSBWZXJzaW9uXG4vLyBIeXBoZW4sIGZvbGxvd2VkIGJ5IG9uZSBvciBtb3JlIGRvdC1zZXBhcmF0ZWQgcHJlLXJlbGVhc2UgdmVyc2lvblxuLy8gaWRlbnRpZmllcnMuXG5cbnZhciBQUkVSRUxFQVNFID0gUisrO1xuc3JjW1BSRVJFTEVBU0VdID0gJyg/Oi0oJyArIHNyY1tQUkVSRUxFQVNFSURFTlRJRklFUl0gK1xuICAgICAgICAgICAgICAgICAgJyg/OlxcXFwuJyArIHNyY1tQUkVSRUxFQVNFSURFTlRJRklFUl0gKyAnKSopKSc7XG5cbnZhciBQUkVSRUxFQVNFTE9PU0UgPSBSKys7XG5zcmNbUFJFUkVMRUFTRUxPT1NFXSA9ICcoPzotPygnICsgc3JjW1BSRVJFTEVBU0VJREVOVElGSUVSTE9PU0VdICtcbiAgICAgICAgICAgICAgICAgICAgICAgJyg/OlxcXFwuJyArIHNyY1tQUkVSRUxFQVNFSURFTlRJRklFUkxPT1NFXSArICcpKikpJztcblxuLy8gIyMgQnVpbGQgTWV0YWRhdGEgSWRlbnRpZmllclxuLy8gQW55IGNvbWJpbmF0aW9uIG9mIGRpZ2l0cywgbGV0dGVycywgb3IgaHlwaGVucy5cblxudmFyIEJVSUxESURFTlRJRklFUiA9IFIrKztcbnNyY1tCVUlMRElERU5USUZJRVJdID0gJ1swLTlBLVphLXotXSsnO1xuXG4vLyAjIyBCdWlsZCBNZXRhZGF0YVxuLy8gUGx1cyBzaWduLCBmb2xsb3dlZCBieSBvbmUgb3IgbW9yZSBwZXJpb2Qtc2VwYXJhdGVkIGJ1aWxkIG1ldGFkYXRhXG4vLyBpZGVudGlmaWVycy5cblxudmFyIEJVSUxEID0gUisrO1xuc3JjW0JVSUxEXSA9ICcoPzpcXFxcKygnICsgc3JjW0JVSUxESURFTlRJRklFUl0gK1xuICAgICAgICAgICAgICcoPzpcXFxcLicgKyBzcmNbQlVJTERJREVOVElGSUVSXSArICcpKikpJztcblxuXG4vLyAjIyBGdWxsIFZlcnNpb24gU3RyaW5nXG4vLyBBIG1haW4gdmVyc2lvbiwgZm9sbG93ZWQgb3B0aW9uYWxseSBieSBhIHByZS1yZWxlYXNlIHZlcnNpb24gYW5kXG4vLyBidWlsZCBtZXRhZGF0YS5cblxuLy8gTm90ZSB0aGF0IHRoZSBvbmx5IG1ham9yLCBtaW5vciwgcGF0Y2gsIGFuZCBwcmUtcmVsZWFzZSBzZWN0aW9ucyBvZlxuLy8gdGhlIHZlcnNpb24gc3RyaW5nIGFyZSBjYXB0dXJpbmcgZ3JvdXBzLiAgVGhlIGJ1aWxkIG1ldGFkYXRhIGlzIG5vdCBhXG4vLyBjYXB0dXJpbmcgZ3JvdXAsIGJlY2F1c2UgaXQgc2hvdWxkIG5vdCBldmVyIGJlIHVzZWQgaW4gdmVyc2lvblxuLy8gY29tcGFyaXNvbi5cblxudmFyIEZVTEwgPSBSKys7XG52YXIgRlVMTFBMQUlOID0gJ3Y/JyArIHNyY1tNQUlOVkVSU0lPTl0gK1xuICAgICAgICAgICAgICAgIHNyY1tQUkVSRUxFQVNFXSArICc/JyArXG4gICAgICAgICAgICAgICAgc3JjW0JVSUxEXSArICc/Jztcblxuc3JjW0ZVTExdID0gJ14nICsgRlVMTFBMQUlOICsgJyQnO1xuXG4vLyBsaWtlIGZ1bGwsIGJ1dCBhbGxvd3MgdjEuMi4zIGFuZCA9MS4yLjMsIHdoaWNoIHBlb3BsZSBkbyBzb21ldGltZXMuXG4vLyBhbHNvLCAxLjAuMGFscGhhMSAocHJlcmVsZWFzZSB3aXRob3V0IHRoZSBoeXBoZW4pIHdoaWNoIGlzIHByZXR0eVxuLy8gY29tbW9uIGluIHRoZSBucG0gcmVnaXN0cnkuXG52YXIgTE9PU0VQTEFJTiA9ICdbdj1cXFxcc10qJyArIHNyY1tNQUlOVkVSU0lPTkxPT1NFXSArXG4gICAgICAgICAgICAgICAgIHNyY1tQUkVSRUxFQVNFTE9PU0VdICsgJz8nICtcbiAgICAgICAgICAgICAgICAgc3JjW0JVSUxEXSArICc/JztcblxudmFyIExPT1NFID0gUisrO1xuc3JjW0xPT1NFXSA9ICdeJyArIExPT1NFUExBSU4gKyAnJCc7XG5cbnZhciBHVExUID0gUisrO1xuc3JjW0dUTFRdID0gJygoPzo8fD4pPz0/KSc7XG5cbi8vIFNvbWV0aGluZyBsaWtlIFwiMi4qXCIgb3IgXCIxLjIueFwiLlxuLy8gTm90ZSB0aGF0IFwieC54XCIgaXMgYSB2YWxpZCB4UmFuZ2UgaWRlbnRpZmVyLCBtZWFuaW5nIFwiYW55IHZlcnNpb25cIlxuLy8gT25seSB0aGUgZmlyc3QgaXRlbSBpcyBzdHJpY3RseSByZXF1aXJlZC5cbnZhciBYUkFOR0VJREVOVElGSUVSTE9PU0UgPSBSKys7XG5zcmNbWFJBTkdFSURFTlRJRklFUkxPT1NFXSA9IHNyY1tOVU1FUklDSURFTlRJRklFUkxPT1NFXSArICd8eHxYfFxcXFwqJztcbnZhciBYUkFOR0VJREVOVElGSUVSID0gUisrO1xuc3JjW1hSQU5HRUlERU5USUZJRVJdID0gc3JjW05VTUVSSUNJREVOVElGSUVSXSArICd8eHxYfFxcXFwqJztcblxudmFyIFhSQU5HRVBMQUlOID0gUisrO1xuc3JjW1hSQU5HRVBMQUlOXSA9ICdbdj1cXFxcc10qKCcgKyBzcmNbWFJBTkdFSURFTlRJRklFUl0gKyAnKScgK1xuICAgICAgICAgICAgICAgICAgICcoPzpcXFxcLignICsgc3JjW1hSQU5HRUlERU5USUZJRVJdICsgJyknICtcbiAgICAgICAgICAgICAgICAgICAnKD86XFxcXC4oJyArIHNyY1tYUkFOR0VJREVOVElGSUVSXSArICcpJyArXG4gICAgICAgICAgICAgICAgICAgJyg/OicgKyBzcmNbUFJFUkVMRUFTRV0gKyAnKT8nICtcbiAgICAgICAgICAgICAgICAgICBzcmNbQlVJTERdICsgJz8nICtcbiAgICAgICAgICAgICAgICAgICAnKT8pPyc7XG5cbnZhciBYUkFOR0VQTEFJTkxPT1NFID0gUisrO1xuc3JjW1hSQU5HRVBMQUlOTE9PU0VdID0gJ1t2PVxcXFxzXSooJyArIHNyY1tYUkFOR0VJREVOVElGSUVSTE9PU0VdICsgJyknICtcbiAgICAgICAgICAgICAgICAgICAgICAgICcoPzpcXFxcLignICsgc3JjW1hSQU5HRUlERU5USUZJRVJMT09TRV0gKyAnKScgK1xuICAgICAgICAgICAgICAgICAgICAgICAgJyg/OlxcXFwuKCcgKyBzcmNbWFJBTkdFSURFTlRJRklFUkxPT1NFXSArICcpJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAnKD86JyArIHNyY1tQUkVSRUxFQVNFTE9PU0VdICsgJyk/JyArXG4gICAgICAgICAgICAgICAgICAgICAgICBzcmNbQlVJTERdICsgJz8nICtcbiAgICAgICAgICAgICAgICAgICAgICAgICcpPyk/JztcblxudmFyIFhSQU5HRSA9IFIrKztcbnNyY1tYUkFOR0VdID0gJ14nICsgc3JjW0dUTFRdICsgJ1xcXFxzKicgKyBzcmNbWFJBTkdFUExBSU5dICsgJyQnO1xudmFyIFhSQU5HRUxPT1NFID0gUisrO1xuc3JjW1hSQU5HRUxPT1NFXSA9ICdeJyArIHNyY1tHVExUXSArICdcXFxccyonICsgc3JjW1hSQU5HRVBMQUlOTE9PU0VdICsgJyQnO1xuXG4vLyBUaWxkZSByYW5nZXMuXG4vLyBNZWFuaW5nIGlzIFwicmVhc29uYWJseSBhdCBvciBncmVhdGVyIHRoYW5cIlxudmFyIExPTkVUSUxERSA9IFIrKztcbnNyY1tMT05FVElMREVdID0gJyg/On4+PyknO1xuXG52YXIgVElMREVUUklNID0gUisrO1xuc3JjW1RJTERFVFJJTV0gPSAnKFxcXFxzKiknICsgc3JjW0xPTkVUSUxERV0gKyAnXFxcXHMrJztcbnJlW1RJTERFVFJJTV0gPSBuZXcgUmVnRXhwKHNyY1tUSUxERVRSSU1dLCAnZycpO1xudmFyIHRpbGRlVHJpbVJlcGxhY2UgPSAnJDF+JztcblxudmFyIFRJTERFID0gUisrO1xuc3JjW1RJTERFXSA9ICdeJyArIHNyY1tMT05FVElMREVdICsgc3JjW1hSQU5HRVBMQUlOXSArICckJztcbnZhciBUSUxERUxPT1NFID0gUisrO1xuc3JjW1RJTERFTE9PU0VdID0gJ14nICsgc3JjW0xPTkVUSUxERV0gKyBzcmNbWFJBTkdFUExBSU5MT09TRV0gKyAnJCc7XG5cbi8vIENhcmV0IHJhbmdlcy5cbi8vIE1lYW5pbmcgaXMgXCJhdCBsZWFzdCBhbmQgYmFja3dhcmRzIGNvbXBhdGlibGUgd2l0aFwiXG52YXIgTE9ORUNBUkVUID0gUisrO1xuc3JjW0xPTkVDQVJFVF0gPSAnKD86XFxcXF4pJztcblxudmFyIENBUkVUVFJJTSA9IFIrKztcbnNyY1tDQVJFVFRSSU1dID0gJyhcXFxccyopJyArIHNyY1tMT05FQ0FSRVRdICsgJ1xcXFxzKyc7XG5yZVtDQVJFVFRSSU1dID0gbmV3IFJlZ0V4cChzcmNbQ0FSRVRUUklNXSwgJ2cnKTtcbnZhciBjYXJldFRyaW1SZXBsYWNlID0gJyQxXic7XG5cbnZhciBDQVJFVCA9IFIrKztcbnNyY1tDQVJFVF0gPSAnXicgKyBzcmNbTE9ORUNBUkVUXSArIHNyY1tYUkFOR0VQTEFJTl0gKyAnJCc7XG52YXIgQ0FSRVRMT09TRSA9IFIrKztcbnNyY1tDQVJFVExPT1NFXSA9ICdeJyArIHNyY1tMT05FQ0FSRVRdICsgc3JjW1hSQU5HRVBMQUlOTE9PU0VdICsgJyQnO1xuXG4vLyBBIHNpbXBsZSBndC9sdC9lcSB0aGluZywgb3IganVzdCBcIlwiIHRvIGluZGljYXRlIFwiYW55IHZlcnNpb25cIlxudmFyIENPTVBBUkFUT1JMT09TRSA9IFIrKztcbnNyY1tDT01QQVJBVE9STE9PU0VdID0gJ14nICsgc3JjW0dUTFRdICsgJ1xcXFxzKignICsgTE9PU0VQTEFJTiArICcpJHxeJCc7XG52YXIgQ09NUEFSQVRPUiA9IFIrKztcbnNyY1tDT01QQVJBVE9SXSA9ICdeJyArIHNyY1tHVExUXSArICdcXFxccyooJyArIEZVTExQTEFJTiArICcpJHxeJCc7XG5cblxuLy8gQW4gZXhwcmVzc2lvbiB0byBzdHJpcCBhbnkgd2hpdGVzcGFjZSBiZXR3ZWVuIHRoZSBndGx0IGFuZCB0aGUgdGhpbmdcbi8vIGl0IG1vZGlmaWVzLCBzbyB0aGF0IGA+IDEuMi4zYCA9PT4gYD4xLjIuM2BcbnZhciBDT01QQVJBVE9SVFJJTSA9IFIrKztcbnNyY1tDT01QQVJBVE9SVFJJTV0gPSAnKFxcXFxzKiknICsgc3JjW0dUTFRdICtcbiAgICAgICAgICAgICAgICAgICAgICAnXFxcXHMqKCcgKyBMT09TRVBMQUlOICsgJ3wnICsgc3JjW1hSQU5HRVBMQUlOXSArICcpJztcblxuLy8gdGhpcyBvbmUgaGFzIHRvIHVzZSB0aGUgL2cgZmxhZ1xucmVbQ09NUEFSQVRPUlRSSU1dID0gbmV3IFJlZ0V4cChzcmNbQ09NUEFSQVRPUlRSSU1dLCAnZycpO1xudmFyIGNvbXBhcmF0b3JUcmltUmVwbGFjZSA9ICckMSQyJDMnO1xuXG5cbi8vIFNvbWV0aGluZyBsaWtlIGAxLjIuMyAtIDEuMi40YFxuLy8gTm90ZSB0aGF0IHRoZXNlIGFsbCB1c2UgdGhlIGxvb3NlIGZvcm0sIGJlY2F1c2UgdGhleSdsbCBiZVxuLy8gY2hlY2tlZCBhZ2FpbnN0IGVpdGhlciB0aGUgc3RyaWN0IG9yIGxvb3NlIGNvbXBhcmF0b3IgZm9ybVxuLy8gbGF0ZXIuXG52YXIgSFlQSEVOUkFOR0UgPSBSKys7XG5zcmNbSFlQSEVOUkFOR0VdID0gJ15cXFxccyooJyArIHNyY1tYUkFOR0VQTEFJTl0gKyAnKScgK1xuICAgICAgICAgICAgICAgICAgICdcXFxccystXFxcXHMrJyArXG4gICAgICAgICAgICAgICAgICAgJygnICsgc3JjW1hSQU5HRVBMQUlOXSArICcpJyArXG4gICAgICAgICAgICAgICAgICAgJ1xcXFxzKiQnO1xuXG52YXIgSFlQSEVOUkFOR0VMT09TRSA9IFIrKztcbnNyY1tIWVBIRU5SQU5HRUxPT1NFXSA9ICdeXFxcXHMqKCcgKyBzcmNbWFJBTkdFUExBSU5MT09TRV0gKyAnKScgK1xuICAgICAgICAgICAgICAgICAgICAgICAgJ1xcXFxzKy1cXFxccysnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICcoJyArIHNyY1tYUkFOR0VQTEFJTkxPT1NFXSArICcpJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAnXFxcXHMqJCc7XG5cbi8vIFN0YXIgcmFuZ2VzIGJhc2ljYWxseSBqdXN0IGFsbG93IGFueXRoaW5nIGF0IGFsbC5cbnZhciBTVEFSID0gUisrO1xuc3JjW1NUQVJdID0gJyg8fD4pPz0/XFxcXHMqXFxcXConO1xuXG4vLyBDb21waWxlIHRvIGFjdHVhbCByZWdleHAgb2JqZWN0cy5cbi8vIEFsbCBhcmUgZmxhZy1mcmVlLCB1bmxlc3MgdGhleSB3ZXJlIGNyZWF0ZWQgYWJvdmUgd2l0aCBhIGZsYWcuXG5mb3IgKHZhciBpID0gMDsgaSA8IFI7IGkrKykge1xuICBkZWJ1ZyhpLCBzcmNbaV0pO1xuICBpZiAoIXJlW2ldKVxuICAgIHJlW2ldID0gbmV3IFJlZ0V4cChzcmNbaV0pO1xufVxuXG5leHBvcnRzLnBhcnNlID0gcGFyc2U7XG5mdW5jdGlvbiBwYXJzZSh2ZXJzaW9uLCBsb29zZSkge1xuICBpZiAodmVyc2lvbiBpbnN0YW5jZW9mIFNlbVZlcilcbiAgICByZXR1cm4gdmVyc2lvbjtcblxuICBpZiAodHlwZW9mIHZlcnNpb24gIT09ICdzdHJpbmcnKVxuICAgIHJldHVybiBudWxsO1xuXG4gIGlmICh2ZXJzaW9uLmxlbmd0aCA+IE1BWF9MRU5HVEgpXG4gICAgcmV0dXJuIG51bGw7XG5cbiAgdmFyIHIgPSBsb29zZSA/IHJlW0xPT1NFXSA6IHJlW0ZVTExdO1xuICBpZiAoIXIudGVzdCh2ZXJzaW9uKSlcbiAgICByZXR1cm4gbnVsbDtcblxuICB0cnkge1xuICAgIHJldHVybiBuZXcgU2VtVmVyKHZlcnNpb24sIGxvb3NlKTtcbiAgfSBjYXRjaCAoZXIpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxufVxuXG5leHBvcnRzLnZhbGlkID0gdmFsaWQ7XG5mdW5jdGlvbiB2YWxpZCh2ZXJzaW9uLCBsb29zZSkge1xuICB2YXIgdiA9IHBhcnNlKHZlcnNpb24sIGxvb3NlKTtcbiAgcmV0dXJuIHYgPyB2LnZlcnNpb24gOiBudWxsO1xufVxuXG5cbmV4cG9ydHMuY2xlYW4gPSBjbGVhbjtcbmZ1bmN0aW9uIGNsZWFuKHZlcnNpb24sIGxvb3NlKSB7XG4gIHZhciBzID0gcGFyc2UodmVyc2lvbi50cmltKCkucmVwbGFjZSgvXls9dl0rLywgJycpLCBsb29zZSk7XG4gIHJldHVybiBzID8gcy52ZXJzaW9uIDogbnVsbDtcbn1cblxuZXhwb3J0cy5TZW1WZXIgPSBTZW1WZXI7XG5cbmZ1bmN0aW9uIFNlbVZlcih2ZXJzaW9uLCBsb29zZSkge1xuICBpZiAodmVyc2lvbiBpbnN0YW5jZW9mIFNlbVZlcikge1xuICAgIGlmICh2ZXJzaW9uLmxvb3NlID09PSBsb29zZSlcbiAgICAgIHJldHVybiB2ZXJzaW9uO1xuICAgIGVsc2VcbiAgICAgIHZlcnNpb24gPSB2ZXJzaW9uLnZlcnNpb247XG4gIH0gZWxzZSBpZiAodHlwZW9mIHZlcnNpb24gIT09ICdzdHJpbmcnKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignSW52YWxpZCBWZXJzaW9uOiAnICsgdmVyc2lvbik7XG4gIH1cblxuICBpZiAodmVyc2lvbi5sZW5ndGggPiBNQVhfTEVOR1RIKVxuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ3ZlcnNpb24gaXMgbG9uZ2VyIHRoYW4gJyArIE1BWF9MRU5HVEggKyAnIGNoYXJhY3RlcnMnKVxuXG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBTZW1WZXIpKVxuICAgIHJldHVybiBuZXcgU2VtVmVyKHZlcnNpb24sIGxvb3NlKTtcblxuICBkZWJ1ZygnU2VtVmVyJywgdmVyc2lvbiwgbG9vc2UpO1xuICB0aGlzLmxvb3NlID0gbG9vc2U7XG4gIHZhciBtID0gdmVyc2lvbi50cmltKCkubWF0Y2gobG9vc2UgPyByZVtMT09TRV0gOiByZVtGVUxMXSk7XG5cbiAgaWYgKCFtKVxuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0ludmFsaWQgVmVyc2lvbjogJyArIHZlcnNpb24pO1xuXG4gIHRoaXMucmF3ID0gdmVyc2lvbjtcblxuICAvLyB0aGVzZSBhcmUgYWN0dWFsbHkgbnVtYmVyc1xuICB0aGlzLm1ham9yID0gK21bMV07XG4gIHRoaXMubWlub3IgPSArbVsyXTtcbiAgdGhpcy5wYXRjaCA9ICttWzNdO1xuXG4gIGlmICh0aGlzLm1ham9yID4gTUFYX1NBRkVfSU5URUdFUiB8fCB0aGlzLm1ham9yIDwgMClcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdJbnZhbGlkIG1ham9yIHZlcnNpb24nKVxuXG4gIGlmICh0aGlzLm1pbm9yID4gTUFYX1NBRkVfSU5URUdFUiB8fCB0aGlzLm1pbm9yIDwgMClcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdJbnZhbGlkIG1pbm9yIHZlcnNpb24nKVxuXG4gIGlmICh0aGlzLnBhdGNoID4gTUFYX1NBRkVfSU5URUdFUiB8fCB0aGlzLnBhdGNoIDwgMClcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdJbnZhbGlkIHBhdGNoIHZlcnNpb24nKVxuXG4gIC8vIG51bWJlcmlmeSBhbnkgcHJlcmVsZWFzZSBudW1lcmljIGlkc1xuICBpZiAoIW1bNF0pXG4gICAgdGhpcy5wcmVyZWxlYXNlID0gW107XG4gIGVsc2VcbiAgICB0aGlzLnByZXJlbGVhc2UgPSBtWzRdLnNwbGl0KCcuJykubWFwKGZ1bmN0aW9uKGlkKSB7XG4gICAgICBpZiAoL15bMC05XSskLy50ZXN0KGlkKSkge1xuICAgICAgICB2YXIgbnVtID0gK2lkO1xuICAgICAgICBpZiAobnVtID49IDAgJiYgbnVtIDwgTUFYX1NBRkVfSU5URUdFUilcbiAgICAgICAgICByZXR1cm4gbnVtO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGlkO1xuICAgIH0pO1xuXG4gIHRoaXMuYnVpbGQgPSBtWzVdID8gbVs1XS5zcGxpdCgnLicpIDogW107XG4gIHRoaXMuZm9ybWF0KCk7XG59XG5cblNlbVZlci5wcm90b3R5cGUuZm9ybWF0ID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMudmVyc2lvbiA9IHRoaXMubWFqb3IgKyAnLicgKyB0aGlzLm1pbm9yICsgJy4nICsgdGhpcy5wYXRjaDtcbiAgaWYgKHRoaXMucHJlcmVsZWFzZS5sZW5ndGgpXG4gICAgdGhpcy52ZXJzaW9uICs9ICctJyArIHRoaXMucHJlcmVsZWFzZS5qb2luKCcuJyk7XG4gIHJldHVybiB0aGlzLnZlcnNpb247XG59O1xuXG5TZW1WZXIucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLnZlcnNpb247XG59O1xuXG5TZW1WZXIucHJvdG90eXBlLmNvbXBhcmUgPSBmdW5jdGlvbihvdGhlcikge1xuICBkZWJ1ZygnU2VtVmVyLmNvbXBhcmUnLCB0aGlzLnZlcnNpb24sIHRoaXMubG9vc2UsIG90aGVyKTtcbiAgaWYgKCEob3RoZXIgaW5zdGFuY2VvZiBTZW1WZXIpKVxuICAgIG90aGVyID0gbmV3IFNlbVZlcihvdGhlciwgdGhpcy5sb29zZSk7XG5cbiAgcmV0dXJuIHRoaXMuY29tcGFyZU1haW4ob3RoZXIpIHx8IHRoaXMuY29tcGFyZVByZShvdGhlcik7XG59O1xuXG5TZW1WZXIucHJvdG90eXBlLmNvbXBhcmVNYWluID0gZnVuY3Rpb24ob3RoZXIpIHtcbiAgaWYgKCEob3RoZXIgaW5zdGFuY2VvZiBTZW1WZXIpKVxuICAgIG90aGVyID0gbmV3IFNlbVZlcihvdGhlciwgdGhpcy5sb29zZSk7XG5cbiAgcmV0dXJuIGNvbXBhcmVJZGVudGlmaWVycyh0aGlzLm1ham9yLCBvdGhlci5tYWpvcikgfHxcbiAgICAgICAgIGNvbXBhcmVJZGVudGlmaWVycyh0aGlzLm1pbm9yLCBvdGhlci5taW5vcikgfHxcbiAgICAgICAgIGNvbXBhcmVJZGVudGlmaWVycyh0aGlzLnBhdGNoLCBvdGhlci5wYXRjaCk7XG59O1xuXG5TZW1WZXIucHJvdG90eXBlLmNvbXBhcmVQcmUgPSBmdW5jdGlvbihvdGhlcikge1xuICBpZiAoIShvdGhlciBpbnN0YW5jZW9mIFNlbVZlcikpXG4gICAgb3RoZXIgPSBuZXcgU2VtVmVyKG90aGVyLCB0aGlzLmxvb3NlKTtcblxuICAvLyBOT1QgaGF2aW5nIGEgcHJlcmVsZWFzZSBpcyA+IGhhdmluZyBvbmVcbiAgaWYgKHRoaXMucHJlcmVsZWFzZS5sZW5ndGggJiYgIW90aGVyLnByZXJlbGVhc2UubGVuZ3RoKVxuICAgIHJldHVybiAtMTtcbiAgZWxzZSBpZiAoIXRoaXMucHJlcmVsZWFzZS5sZW5ndGggJiYgb3RoZXIucHJlcmVsZWFzZS5sZW5ndGgpXG4gICAgcmV0dXJuIDE7XG4gIGVsc2UgaWYgKCF0aGlzLnByZXJlbGVhc2UubGVuZ3RoICYmICFvdGhlci5wcmVyZWxlYXNlLmxlbmd0aClcbiAgICByZXR1cm4gMDtcblxuICB2YXIgaSA9IDA7XG4gIGRvIHtcbiAgICB2YXIgYSA9IHRoaXMucHJlcmVsZWFzZVtpXTtcbiAgICB2YXIgYiA9IG90aGVyLnByZXJlbGVhc2VbaV07XG4gICAgZGVidWcoJ3ByZXJlbGVhc2UgY29tcGFyZScsIGksIGEsIGIpO1xuICAgIGlmIChhID09PSB1bmRlZmluZWQgJiYgYiA9PT0gdW5kZWZpbmVkKVxuICAgICAgcmV0dXJuIDA7XG4gICAgZWxzZSBpZiAoYiA9PT0gdW5kZWZpbmVkKVxuICAgICAgcmV0dXJuIDE7XG4gICAgZWxzZSBpZiAoYSA9PT0gdW5kZWZpbmVkKVxuICAgICAgcmV0dXJuIC0xO1xuICAgIGVsc2UgaWYgKGEgPT09IGIpXG4gICAgICBjb250aW51ZTtcbiAgICBlbHNlXG4gICAgICByZXR1cm4gY29tcGFyZUlkZW50aWZpZXJzKGEsIGIpO1xuICB9IHdoaWxlICgrK2kpO1xufTtcblxuLy8gcHJlbWlub3Igd2lsbCBidW1wIHRoZSB2ZXJzaW9uIHVwIHRvIHRoZSBuZXh0IG1pbm9yIHJlbGVhc2UsIGFuZCBpbW1lZGlhdGVseVxuLy8gZG93biB0byBwcmUtcmVsZWFzZS4gcHJlbWFqb3IgYW5kIHByZXBhdGNoIHdvcmsgdGhlIHNhbWUgd2F5LlxuU2VtVmVyLnByb3RvdHlwZS5pbmMgPSBmdW5jdGlvbihyZWxlYXNlLCBpZGVudGlmaWVyKSB7XG4gIHN3aXRjaCAocmVsZWFzZSkge1xuICAgIGNhc2UgJ3ByZW1ham9yJzpcbiAgICAgIHRoaXMucHJlcmVsZWFzZS5sZW5ndGggPSAwO1xuICAgICAgdGhpcy5wYXRjaCA9IDA7XG4gICAgICB0aGlzLm1pbm9yID0gMDtcbiAgICAgIHRoaXMubWFqb3IrKztcbiAgICAgIHRoaXMuaW5jKCdwcmUnLCBpZGVudGlmaWVyKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ3ByZW1pbm9yJzpcbiAgICAgIHRoaXMucHJlcmVsZWFzZS5sZW5ndGggPSAwO1xuICAgICAgdGhpcy5wYXRjaCA9IDA7XG4gICAgICB0aGlzLm1pbm9yKys7XG4gICAgICB0aGlzLmluYygncHJlJywgaWRlbnRpZmllcik7XG4gICAgICBicmVhaztcbiAgICBjYXNlICdwcmVwYXRjaCc6XG4gICAgICAvLyBJZiB0aGlzIGlzIGFscmVhZHkgYSBwcmVyZWxlYXNlLCBpdCB3aWxsIGJ1bXAgdG8gdGhlIG5leHQgdmVyc2lvblxuICAgICAgLy8gZHJvcCBhbnkgcHJlcmVsZWFzZXMgdGhhdCBtaWdodCBhbHJlYWR5IGV4aXN0LCBzaW5jZSB0aGV5IGFyZSBub3RcbiAgICAgIC8vIHJlbGV2YW50IGF0IHRoaXMgcG9pbnQuXG4gICAgICB0aGlzLnByZXJlbGVhc2UubGVuZ3RoID0gMDtcbiAgICAgIHRoaXMuaW5jKCdwYXRjaCcsIGlkZW50aWZpZXIpO1xuICAgICAgdGhpcy5pbmMoJ3ByZScsIGlkZW50aWZpZXIpO1xuICAgICAgYnJlYWs7XG4gICAgLy8gSWYgdGhlIGlucHV0IGlzIGEgbm9uLXByZXJlbGVhc2UgdmVyc2lvbiwgdGhpcyBhY3RzIHRoZSBzYW1lIGFzXG4gICAgLy8gcHJlcGF0Y2guXG4gICAgY2FzZSAncHJlcmVsZWFzZSc6XG4gICAgICBpZiAodGhpcy5wcmVyZWxlYXNlLmxlbmd0aCA9PT0gMClcbiAgICAgICAgdGhpcy5pbmMoJ3BhdGNoJywgaWRlbnRpZmllcik7XG4gICAgICB0aGlzLmluYygncHJlJywgaWRlbnRpZmllcik7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgJ21ham9yJzpcbiAgICAgIC8vIElmIHRoaXMgaXMgYSBwcmUtbWFqb3IgdmVyc2lvbiwgYnVtcCB1cCB0byB0aGUgc2FtZSBtYWpvciB2ZXJzaW9uLlxuICAgICAgLy8gT3RoZXJ3aXNlIGluY3JlbWVudCBtYWpvci5cbiAgICAgIC8vIDEuMC4wLTUgYnVtcHMgdG8gMS4wLjBcbiAgICAgIC8vIDEuMS4wIGJ1bXBzIHRvIDIuMC4wXG4gICAgICBpZiAodGhpcy5taW5vciAhPT0gMCB8fCB0aGlzLnBhdGNoICE9PSAwIHx8IHRoaXMucHJlcmVsZWFzZS5sZW5ndGggPT09IDApXG4gICAgICAgIHRoaXMubWFqb3IrKztcbiAgICAgIHRoaXMubWlub3IgPSAwO1xuICAgICAgdGhpcy5wYXRjaCA9IDA7XG4gICAgICB0aGlzLnByZXJlbGVhc2UgPSBbXTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ21pbm9yJzpcbiAgICAgIC8vIElmIHRoaXMgaXMgYSBwcmUtbWlub3IgdmVyc2lvbiwgYnVtcCB1cCB0byB0aGUgc2FtZSBtaW5vciB2ZXJzaW9uLlxuICAgICAgLy8gT3RoZXJ3aXNlIGluY3JlbWVudCBtaW5vci5cbiAgICAgIC8vIDEuMi4wLTUgYnVtcHMgdG8gMS4yLjBcbiAgICAgIC8vIDEuMi4xIGJ1bXBzIHRvIDEuMy4wXG4gICAgICBpZiAodGhpcy5wYXRjaCAhPT0gMCB8fCB0aGlzLnByZXJlbGVhc2UubGVuZ3RoID09PSAwKVxuICAgICAgICB0aGlzLm1pbm9yKys7XG4gICAgICB0aGlzLnBhdGNoID0gMDtcbiAgICAgIHRoaXMucHJlcmVsZWFzZSA9IFtdO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAncGF0Y2gnOlxuICAgICAgLy8gSWYgdGhpcyBpcyBub3QgYSBwcmUtcmVsZWFzZSB2ZXJzaW9uLCBpdCB3aWxsIGluY3JlbWVudCB0aGUgcGF0Y2guXG4gICAgICAvLyBJZiBpdCBpcyBhIHByZS1yZWxlYXNlIGl0IHdpbGwgYnVtcCB1cCB0byB0aGUgc2FtZSBwYXRjaCB2ZXJzaW9uLlxuICAgICAgLy8gMS4yLjAtNSBwYXRjaGVzIHRvIDEuMi4wXG4gICAgICAvLyAxLjIuMCBwYXRjaGVzIHRvIDEuMi4xXG4gICAgICBpZiAodGhpcy5wcmVyZWxlYXNlLmxlbmd0aCA9PT0gMClcbiAgICAgICAgdGhpcy5wYXRjaCsrO1xuICAgICAgdGhpcy5wcmVyZWxlYXNlID0gW107XG4gICAgICBicmVhaztcbiAgICAvLyBUaGlzIHByb2JhYmx5IHNob3VsZG4ndCBiZSB1c2VkIHB1YmxpY2x5LlxuICAgIC8vIDEuMC4wIFwicHJlXCIgd291bGQgYmVjb21lIDEuMC4wLTAgd2hpY2ggaXMgdGhlIHdyb25nIGRpcmVjdGlvbi5cbiAgICBjYXNlICdwcmUnOlxuICAgICAgaWYgKHRoaXMucHJlcmVsZWFzZS5sZW5ndGggPT09IDApXG4gICAgICAgIHRoaXMucHJlcmVsZWFzZSA9IFswXTtcbiAgICAgIGVsc2Uge1xuICAgICAgICB2YXIgaSA9IHRoaXMucHJlcmVsZWFzZS5sZW5ndGg7XG4gICAgICAgIHdoaWxlICgtLWkgPj0gMCkge1xuICAgICAgICAgIGlmICh0eXBlb2YgdGhpcy5wcmVyZWxlYXNlW2ldID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgdGhpcy5wcmVyZWxlYXNlW2ldKys7XG4gICAgICAgICAgICBpID0gLTI7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChpID09PSAtMSkgLy8gZGlkbid0IGluY3JlbWVudCBhbnl0aGluZ1xuICAgICAgICAgIHRoaXMucHJlcmVsZWFzZS5wdXNoKDApO1xuICAgICAgfVxuICAgICAgaWYgKGlkZW50aWZpZXIpIHtcbiAgICAgICAgLy8gMS4yLjAtYmV0YS4xIGJ1bXBzIHRvIDEuMi4wLWJldGEuMixcbiAgICAgICAgLy8gMS4yLjAtYmV0YS5mb29ibHogb3IgMS4yLjAtYmV0YSBidW1wcyB0byAxLjIuMC1iZXRhLjBcbiAgICAgICAgaWYgKHRoaXMucHJlcmVsZWFzZVswXSA9PT0gaWRlbnRpZmllcikge1xuICAgICAgICAgIGlmIChpc05hTih0aGlzLnByZXJlbGVhc2VbMV0pKVxuICAgICAgICAgICAgdGhpcy5wcmVyZWxlYXNlID0gW2lkZW50aWZpZXIsIDBdO1xuICAgICAgICB9IGVsc2VcbiAgICAgICAgICB0aGlzLnByZXJlbGVhc2UgPSBbaWRlbnRpZmllciwgMF07XG4gICAgICB9XG4gICAgICBicmVhaztcblxuICAgIGRlZmF1bHQ6XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgaW5jcmVtZW50IGFyZ3VtZW50OiAnICsgcmVsZWFzZSk7XG4gIH1cbiAgdGhpcy5mb3JtYXQoKTtcbiAgdGhpcy5yYXcgPSB0aGlzLnZlcnNpb247XG4gIHJldHVybiB0aGlzO1xufTtcblxuZXhwb3J0cy5pbmMgPSBpbmM7XG5mdW5jdGlvbiBpbmModmVyc2lvbiwgcmVsZWFzZSwgbG9vc2UsIGlkZW50aWZpZXIpIHtcbiAgaWYgKHR5cGVvZihsb29zZSkgPT09ICdzdHJpbmcnKSB7XG4gICAgaWRlbnRpZmllciA9IGxvb3NlO1xuICAgIGxvb3NlID0gdW5kZWZpbmVkO1xuICB9XG5cbiAgdHJ5IHtcbiAgICByZXR1cm4gbmV3IFNlbVZlcih2ZXJzaW9uLCBsb29zZSkuaW5jKHJlbGVhc2UsIGlkZW50aWZpZXIpLnZlcnNpb247XG4gIH0gY2F0Y2ggKGVyKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbn1cblxuZXhwb3J0cy5kaWZmID0gZGlmZjtcbmZ1bmN0aW9uIGRpZmYodmVyc2lvbjEsIHZlcnNpb24yKSB7XG4gIGlmIChlcSh2ZXJzaW9uMSwgdmVyc2lvbjIpKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH0gZWxzZSB7XG4gICAgdmFyIHYxID0gcGFyc2UodmVyc2lvbjEpO1xuICAgIHZhciB2MiA9IHBhcnNlKHZlcnNpb24yKTtcbiAgICBpZiAodjEucHJlcmVsZWFzZS5sZW5ndGggfHwgdjIucHJlcmVsZWFzZS5sZW5ndGgpIHtcbiAgICAgIGZvciAodmFyIGtleSBpbiB2MSkge1xuICAgICAgICBpZiAoa2V5ID09PSAnbWFqb3InIHx8IGtleSA9PT0gJ21pbm9yJyB8fCBrZXkgPT09ICdwYXRjaCcpIHtcbiAgICAgICAgICBpZiAodjFba2V5XSAhPT0gdjJba2V5XSkge1xuICAgICAgICAgICAgcmV0dXJuICdwcmUnK2tleTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiAncHJlcmVsZWFzZSc7XG4gICAgfVxuICAgIGZvciAodmFyIGtleSBpbiB2MSkge1xuICAgICAgaWYgKGtleSA9PT0gJ21ham9yJyB8fCBrZXkgPT09ICdtaW5vcicgfHwga2V5ID09PSAncGF0Y2gnKSB7XG4gICAgICAgIGlmICh2MVtrZXldICE9PSB2MltrZXldKSB7XG4gICAgICAgICAgcmV0dXJuIGtleTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5leHBvcnRzLmNvbXBhcmVJZGVudGlmaWVycyA9IGNvbXBhcmVJZGVudGlmaWVycztcblxudmFyIG51bWVyaWMgPSAvXlswLTldKyQvO1xuZnVuY3Rpb24gY29tcGFyZUlkZW50aWZpZXJzKGEsIGIpIHtcbiAgdmFyIGFudW0gPSBudW1lcmljLnRlc3QoYSk7XG4gIHZhciBibnVtID0gbnVtZXJpYy50ZXN0KGIpO1xuXG4gIGlmIChhbnVtICYmIGJudW0pIHtcbiAgICBhID0gK2E7XG4gICAgYiA9ICtiO1xuICB9XG5cbiAgcmV0dXJuIChhbnVtICYmICFibnVtKSA/IC0xIDpcbiAgICAgICAgIChibnVtICYmICFhbnVtKSA/IDEgOlxuICAgICAgICAgYSA8IGIgPyAtMSA6XG4gICAgICAgICBhID4gYiA/IDEgOlxuICAgICAgICAgMDtcbn1cblxuZXhwb3J0cy5yY29tcGFyZUlkZW50aWZpZXJzID0gcmNvbXBhcmVJZGVudGlmaWVycztcbmZ1bmN0aW9uIHJjb21wYXJlSWRlbnRpZmllcnMoYSwgYikge1xuICByZXR1cm4gY29tcGFyZUlkZW50aWZpZXJzKGIsIGEpO1xufVxuXG5leHBvcnRzLm1ham9yID0gbWFqb3I7XG5mdW5jdGlvbiBtYWpvcihhLCBsb29zZSkge1xuICByZXR1cm4gbmV3IFNlbVZlcihhLCBsb29zZSkubWFqb3I7XG59XG5cbmV4cG9ydHMubWlub3IgPSBtaW5vcjtcbmZ1bmN0aW9uIG1pbm9yKGEsIGxvb3NlKSB7XG4gIHJldHVybiBuZXcgU2VtVmVyKGEsIGxvb3NlKS5taW5vcjtcbn1cblxuZXhwb3J0cy5wYXRjaCA9IHBhdGNoO1xuZnVuY3Rpb24gcGF0Y2goYSwgbG9vc2UpIHtcbiAgcmV0dXJuIG5ldyBTZW1WZXIoYSwgbG9vc2UpLnBhdGNoO1xufVxuXG5leHBvcnRzLmNvbXBhcmUgPSBjb21wYXJlO1xuZnVuY3Rpb24gY29tcGFyZShhLCBiLCBsb29zZSkge1xuICByZXR1cm4gbmV3IFNlbVZlcihhLCBsb29zZSkuY29tcGFyZShuZXcgU2VtVmVyKGIsIGxvb3NlKSk7XG59XG5cbmV4cG9ydHMuY29tcGFyZUxvb3NlID0gY29tcGFyZUxvb3NlO1xuZnVuY3Rpb24gY29tcGFyZUxvb3NlKGEsIGIpIHtcbiAgcmV0dXJuIGNvbXBhcmUoYSwgYiwgdHJ1ZSk7XG59XG5cbmV4cG9ydHMucmNvbXBhcmUgPSByY29tcGFyZTtcbmZ1bmN0aW9uIHJjb21wYXJlKGEsIGIsIGxvb3NlKSB7XG4gIHJldHVybiBjb21wYXJlKGIsIGEsIGxvb3NlKTtcbn1cblxuZXhwb3J0cy5zb3J0ID0gc29ydDtcbmZ1bmN0aW9uIHNvcnQobGlzdCwgbG9vc2UpIHtcbiAgcmV0dXJuIGxpc3Quc29ydChmdW5jdGlvbihhLCBiKSB7XG4gICAgcmV0dXJuIGV4cG9ydHMuY29tcGFyZShhLCBiLCBsb29zZSk7XG4gIH0pO1xufVxuXG5leHBvcnRzLnJzb3J0ID0gcnNvcnQ7XG5mdW5jdGlvbiByc29ydChsaXN0LCBsb29zZSkge1xuICByZXR1cm4gbGlzdC5zb3J0KGZ1bmN0aW9uKGEsIGIpIHtcbiAgICByZXR1cm4gZXhwb3J0cy5yY29tcGFyZShhLCBiLCBsb29zZSk7XG4gIH0pO1xufVxuXG5leHBvcnRzLmd0ID0gZ3Q7XG5mdW5jdGlvbiBndChhLCBiLCBsb29zZSkge1xuICByZXR1cm4gY29tcGFyZShhLCBiLCBsb29zZSkgPiAwO1xufVxuXG5leHBvcnRzLmx0ID0gbHQ7XG5mdW5jdGlvbiBsdChhLCBiLCBsb29zZSkge1xuICByZXR1cm4gY29tcGFyZShhLCBiLCBsb29zZSkgPCAwO1xufVxuXG5leHBvcnRzLmVxID0gZXE7XG5mdW5jdGlvbiBlcShhLCBiLCBsb29zZSkge1xuICByZXR1cm4gY29tcGFyZShhLCBiLCBsb29zZSkgPT09IDA7XG59XG5cbmV4cG9ydHMubmVxID0gbmVxO1xuZnVuY3Rpb24gbmVxKGEsIGIsIGxvb3NlKSB7XG4gIHJldHVybiBjb21wYXJlKGEsIGIsIGxvb3NlKSAhPT0gMDtcbn1cblxuZXhwb3J0cy5ndGUgPSBndGU7XG5mdW5jdGlvbiBndGUoYSwgYiwgbG9vc2UpIHtcbiAgcmV0dXJuIGNvbXBhcmUoYSwgYiwgbG9vc2UpID49IDA7XG59XG5cbmV4cG9ydHMubHRlID0gbHRlO1xuZnVuY3Rpb24gbHRlKGEsIGIsIGxvb3NlKSB7XG4gIHJldHVybiBjb21wYXJlKGEsIGIsIGxvb3NlKSA8PSAwO1xufVxuXG5leHBvcnRzLmNtcCA9IGNtcDtcbmZ1bmN0aW9uIGNtcChhLCBvcCwgYiwgbG9vc2UpIHtcbiAgdmFyIHJldDtcbiAgc3dpdGNoIChvcCkge1xuICAgIGNhc2UgJz09PSc6XG4gICAgICBpZiAodHlwZW9mIGEgPT09ICdvYmplY3QnKSBhID0gYS52ZXJzaW9uO1xuICAgICAgaWYgKHR5cGVvZiBiID09PSAnb2JqZWN0JykgYiA9IGIudmVyc2lvbjtcbiAgICAgIHJldCA9IGEgPT09IGI7XG4gICAgICBicmVhaztcbiAgICBjYXNlICchPT0nOlxuICAgICAgaWYgKHR5cGVvZiBhID09PSAnb2JqZWN0JykgYSA9IGEudmVyc2lvbjtcbiAgICAgIGlmICh0eXBlb2YgYiA9PT0gJ29iamVjdCcpIGIgPSBiLnZlcnNpb247XG4gICAgICByZXQgPSBhICE9PSBiO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnJzogY2FzZSAnPSc6IGNhc2UgJz09JzogcmV0ID0gZXEoYSwgYiwgbG9vc2UpOyBicmVhaztcbiAgICBjYXNlICchPSc6IHJldCA9IG5lcShhLCBiLCBsb29zZSk7IGJyZWFrO1xuICAgIGNhc2UgJz4nOiByZXQgPSBndChhLCBiLCBsb29zZSk7IGJyZWFrO1xuICAgIGNhc2UgJz49JzogcmV0ID0gZ3RlKGEsIGIsIGxvb3NlKTsgYnJlYWs7XG4gICAgY2FzZSAnPCc6IHJldCA9IGx0KGEsIGIsIGxvb3NlKTsgYnJlYWs7XG4gICAgY2FzZSAnPD0nOiByZXQgPSBsdGUoYSwgYiwgbG9vc2UpOyBicmVhaztcbiAgICBkZWZhdWx0OiB0aHJvdyBuZXcgVHlwZUVycm9yKCdJbnZhbGlkIG9wZXJhdG9yOiAnICsgb3ApO1xuICB9XG4gIHJldHVybiByZXQ7XG59XG5cbmV4cG9ydHMuQ29tcGFyYXRvciA9IENvbXBhcmF0b3I7XG5mdW5jdGlvbiBDb21wYXJhdG9yKGNvbXAsIGxvb3NlKSB7XG4gIGlmIChjb21wIGluc3RhbmNlb2YgQ29tcGFyYXRvcikge1xuICAgIGlmIChjb21wLmxvb3NlID09PSBsb29zZSlcbiAgICAgIHJldHVybiBjb21wO1xuICAgIGVsc2VcbiAgICAgIGNvbXAgPSBjb21wLnZhbHVlO1xuICB9XG5cbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIENvbXBhcmF0b3IpKVxuICAgIHJldHVybiBuZXcgQ29tcGFyYXRvcihjb21wLCBsb29zZSk7XG5cbiAgZGVidWcoJ2NvbXBhcmF0b3InLCBjb21wLCBsb29zZSk7XG4gIHRoaXMubG9vc2UgPSBsb29zZTtcbiAgdGhpcy5wYXJzZShjb21wKTtcblxuICBpZiAodGhpcy5zZW12ZXIgPT09IEFOWSlcbiAgICB0aGlzLnZhbHVlID0gJyc7XG4gIGVsc2VcbiAgICB0aGlzLnZhbHVlID0gdGhpcy5vcGVyYXRvciArIHRoaXMuc2VtdmVyLnZlcnNpb247XG5cbiAgZGVidWcoJ2NvbXAnLCB0aGlzKTtcbn1cblxudmFyIEFOWSA9IHt9O1xuQ29tcGFyYXRvci5wcm90b3R5cGUucGFyc2UgPSBmdW5jdGlvbihjb21wKSB7XG4gIHZhciByID0gdGhpcy5sb29zZSA/IHJlW0NPTVBBUkFUT1JMT09TRV0gOiByZVtDT01QQVJBVE9SXTtcbiAgdmFyIG0gPSBjb21wLm1hdGNoKHIpO1xuXG4gIGlmICghbSlcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdJbnZhbGlkIGNvbXBhcmF0b3I6ICcgKyBjb21wKTtcblxuICB0aGlzLm9wZXJhdG9yID0gbVsxXTtcbiAgaWYgKHRoaXMub3BlcmF0b3IgPT09ICc9JylcbiAgICB0aGlzLm9wZXJhdG9yID0gJyc7XG5cbiAgLy8gaWYgaXQgbGl0ZXJhbGx5IGlzIGp1c3QgJz4nIG9yICcnIHRoZW4gYWxsb3cgYW55dGhpbmcuXG4gIGlmICghbVsyXSlcbiAgICB0aGlzLnNlbXZlciA9IEFOWTtcbiAgZWxzZVxuICAgIHRoaXMuc2VtdmVyID0gbmV3IFNlbVZlcihtWzJdLCB0aGlzLmxvb3NlKTtcbn07XG5cbkNvbXBhcmF0b3IucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLnZhbHVlO1xufTtcblxuQ29tcGFyYXRvci5wcm90b3R5cGUudGVzdCA9IGZ1bmN0aW9uKHZlcnNpb24pIHtcbiAgZGVidWcoJ0NvbXBhcmF0b3IudGVzdCcsIHZlcnNpb24sIHRoaXMubG9vc2UpO1xuXG4gIGlmICh0aGlzLnNlbXZlciA9PT0gQU5ZKVxuICAgIHJldHVybiB0cnVlO1xuXG4gIGlmICh0eXBlb2YgdmVyc2lvbiA9PT0gJ3N0cmluZycpXG4gICAgdmVyc2lvbiA9IG5ldyBTZW1WZXIodmVyc2lvbiwgdGhpcy5sb29zZSk7XG5cbiAgcmV0dXJuIGNtcCh2ZXJzaW9uLCB0aGlzLm9wZXJhdG9yLCB0aGlzLnNlbXZlciwgdGhpcy5sb29zZSk7XG59O1xuXG5Db21wYXJhdG9yLnByb3RvdHlwZS5pbnRlcnNlY3RzID0gZnVuY3Rpb24oY29tcCwgbG9vc2UpIHtcbiAgaWYgKCEoY29tcCBpbnN0YW5jZW9mIENvbXBhcmF0b3IpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignYSBDb21wYXJhdG9yIGlzIHJlcXVpcmVkJyk7XG4gIH1cblxuICB2YXIgcmFuZ2VUbXA7XG5cbiAgaWYgKHRoaXMub3BlcmF0b3IgPT09ICcnKSB7XG4gICAgcmFuZ2VUbXAgPSBuZXcgUmFuZ2UoY29tcC52YWx1ZSwgbG9vc2UpO1xuICAgIHJldHVybiBzYXRpc2ZpZXModGhpcy52YWx1ZSwgcmFuZ2VUbXAsIGxvb3NlKTtcbiAgfSBlbHNlIGlmIChjb21wLm9wZXJhdG9yID09PSAnJykge1xuICAgIHJhbmdlVG1wID0gbmV3IFJhbmdlKHRoaXMudmFsdWUsIGxvb3NlKTtcbiAgICByZXR1cm4gc2F0aXNmaWVzKGNvbXAuc2VtdmVyLCByYW5nZVRtcCwgbG9vc2UpO1xuICB9XG5cbiAgdmFyIHNhbWVEaXJlY3Rpb25JbmNyZWFzaW5nID1cbiAgICAodGhpcy5vcGVyYXRvciA9PT0gJz49JyB8fCB0aGlzLm9wZXJhdG9yID09PSAnPicpICYmXG4gICAgKGNvbXAub3BlcmF0b3IgPT09ICc+PScgfHwgY29tcC5vcGVyYXRvciA9PT0gJz4nKTtcbiAgdmFyIHNhbWVEaXJlY3Rpb25EZWNyZWFzaW5nID1cbiAgICAodGhpcy5vcGVyYXRvciA9PT0gJzw9JyB8fCB0aGlzLm9wZXJhdG9yID09PSAnPCcpICYmXG4gICAgKGNvbXAub3BlcmF0b3IgPT09ICc8PScgfHwgY29tcC5vcGVyYXRvciA9PT0gJzwnKTtcbiAgdmFyIHNhbWVTZW1WZXIgPSB0aGlzLnNlbXZlci52ZXJzaW9uID09PSBjb21wLnNlbXZlci52ZXJzaW9uO1xuICB2YXIgZGlmZmVyZW50RGlyZWN0aW9uc0luY2x1c2l2ZSA9XG4gICAgKHRoaXMub3BlcmF0b3IgPT09ICc+PScgfHwgdGhpcy5vcGVyYXRvciA9PT0gJzw9JykgJiZcbiAgICAoY29tcC5vcGVyYXRvciA9PT0gJz49JyB8fCBjb21wLm9wZXJhdG9yID09PSAnPD0nKTtcbiAgdmFyIG9wcG9zaXRlRGlyZWN0aW9uc0xlc3NUaGFuID1cbiAgICBjbXAodGhpcy5zZW12ZXIsICc8JywgY29tcC5zZW12ZXIsIGxvb3NlKSAmJlxuICAgICgodGhpcy5vcGVyYXRvciA9PT0gJz49JyB8fCB0aGlzLm9wZXJhdG9yID09PSAnPicpICYmXG4gICAgKGNvbXAub3BlcmF0b3IgPT09ICc8PScgfHwgY29tcC5vcGVyYXRvciA9PT0gJzwnKSk7XG4gIHZhciBvcHBvc2l0ZURpcmVjdGlvbnNHcmVhdGVyVGhhbiA9XG4gICAgY21wKHRoaXMuc2VtdmVyLCAnPicsIGNvbXAuc2VtdmVyLCBsb29zZSkgJiZcbiAgICAoKHRoaXMub3BlcmF0b3IgPT09ICc8PScgfHwgdGhpcy5vcGVyYXRvciA9PT0gJzwnKSAmJlxuICAgIChjb21wLm9wZXJhdG9yID09PSAnPj0nIHx8IGNvbXAub3BlcmF0b3IgPT09ICc+JykpO1xuXG4gIHJldHVybiBzYW1lRGlyZWN0aW9uSW5jcmVhc2luZyB8fCBzYW1lRGlyZWN0aW9uRGVjcmVhc2luZyB8fFxuICAgIChzYW1lU2VtVmVyICYmIGRpZmZlcmVudERpcmVjdGlvbnNJbmNsdXNpdmUpIHx8XG4gICAgb3Bwb3NpdGVEaXJlY3Rpb25zTGVzc1RoYW4gfHwgb3Bwb3NpdGVEaXJlY3Rpb25zR3JlYXRlclRoYW47XG59O1xuXG5cbmV4cG9ydHMuUmFuZ2UgPSBSYW5nZTtcbmZ1bmN0aW9uIFJhbmdlKHJhbmdlLCBsb29zZSkge1xuICBpZiAocmFuZ2UgaW5zdGFuY2VvZiBSYW5nZSkge1xuICAgIGlmIChyYW5nZS5sb29zZSA9PT0gbG9vc2UpIHtcbiAgICAgIHJldHVybiByYW5nZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIG5ldyBSYW5nZShyYW5nZS5yYXcsIGxvb3NlKTtcbiAgICB9XG4gIH1cblxuICBpZiAocmFuZ2UgaW5zdGFuY2VvZiBDb21wYXJhdG9yKSB7XG4gICAgcmV0dXJuIG5ldyBSYW5nZShyYW5nZS52YWx1ZSwgbG9vc2UpO1xuICB9XG5cbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIFJhbmdlKSlcbiAgICByZXR1cm4gbmV3IFJhbmdlKHJhbmdlLCBsb29zZSk7XG5cbiAgdGhpcy5sb29zZSA9IGxvb3NlO1xuXG4gIC8vIEZpcnN0LCBzcGxpdCBiYXNlZCBvbiBib29sZWFuIG9yIHx8XG4gIHRoaXMucmF3ID0gcmFuZ2U7XG4gIHRoaXMuc2V0ID0gcmFuZ2Uuc3BsaXQoL1xccypcXHxcXHxcXHMqLykubWFwKGZ1bmN0aW9uKHJhbmdlKSB7XG4gICAgcmV0dXJuIHRoaXMucGFyc2VSYW5nZShyYW5nZS50cmltKCkpO1xuICB9LCB0aGlzKS5maWx0ZXIoZnVuY3Rpb24oYykge1xuICAgIC8vIHRocm93IG91dCBhbnkgdGhhdCBhcmUgbm90IHJlbGV2YW50IGZvciB3aGF0ZXZlciByZWFzb25cbiAgICByZXR1cm4gYy5sZW5ndGg7XG4gIH0pO1xuXG4gIGlmICghdGhpcy5zZXQubGVuZ3RoKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignSW52YWxpZCBTZW1WZXIgUmFuZ2U6ICcgKyByYW5nZSk7XG4gIH1cblxuICB0aGlzLmZvcm1hdCgpO1xufVxuXG5SYW5nZS5wcm90b3R5cGUuZm9ybWF0ID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMucmFuZ2UgPSB0aGlzLnNldC5tYXAoZnVuY3Rpb24oY29tcHMpIHtcbiAgICByZXR1cm4gY29tcHMuam9pbignICcpLnRyaW0oKTtcbiAgfSkuam9pbignfHwnKS50cmltKCk7XG4gIHJldHVybiB0aGlzLnJhbmdlO1xufTtcblxuUmFuZ2UucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLnJhbmdlO1xufTtcblxuUmFuZ2UucHJvdG90eXBlLnBhcnNlUmFuZ2UgPSBmdW5jdGlvbihyYW5nZSkge1xuICB2YXIgbG9vc2UgPSB0aGlzLmxvb3NlO1xuICByYW5nZSA9IHJhbmdlLnRyaW0oKTtcbiAgZGVidWcoJ3JhbmdlJywgcmFuZ2UsIGxvb3NlKTtcbiAgLy8gYDEuMi4zIC0gMS4yLjRgID0+IGA+PTEuMi4zIDw9MS4yLjRgXG4gIHZhciBociA9IGxvb3NlID8gcmVbSFlQSEVOUkFOR0VMT09TRV0gOiByZVtIWVBIRU5SQU5HRV07XG4gIHJhbmdlID0gcmFuZ2UucmVwbGFjZShociwgaHlwaGVuUmVwbGFjZSk7XG4gIGRlYnVnKCdoeXBoZW4gcmVwbGFjZScsIHJhbmdlKTtcbiAgLy8gYD4gMS4yLjMgPCAxLjIuNWAgPT4gYD4xLjIuMyA8MS4yLjVgXG4gIHJhbmdlID0gcmFuZ2UucmVwbGFjZShyZVtDT01QQVJBVE9SVFJJTV0sIGNvbXBhcmF0b3JUcmltUmVwbGFjZSk7XG4gIGRlYnVnKCdjb21wYXJhdG9yIHRyaW0nLCByYW5nZSwgcmVbQ09NUEFSQVRPUlRSSU1dKTtcblxuICAvLyBgfiAxLjIuM2AgPT4gYH4xLjIuM2BcbiAgcmFuZ2UgPSByYW5nZS5yZXBsYWNlKHJlW1RJTERFVFJJTV0sIHRpbGRlVHJpbVJlcGxhY2UpO1xuXG4gIC8vIGBeIDEuMi4zYCA9PiBgXjEuMi4zYFxuICByYW5nZSA9IHJhbmdlLnJlcGxhY2UocmVbQ0FSRVRUUklNXSwgY2FyZXRUcmltUmVwbGFjZSk7XG5cbiAgLy8gbm9ybWFsaXplIHNwYWNlc1xuICByYW5nZSA9IHJhbmdlLnNwbGl0KC9cXHMrLykuam9pbignICcpO1xuXG4gIC8vIEF0IHRoaXMgcG9pbnQsIHRoZSByYW5nZSBpcyBjb21wbGV0ZWx5IHRyaW1tZWQgYW5kXG4gIC8vIHJlYWR5IHRvIGJlIHNwbGl0IGludG8gY29tcGFyYXRvcnMuXG5cbiAgdmFyIGNvbXBSZSA9IGxvb3NlID8gcmVbQ09NUEFSQVRPUkxPT1NFXSA6IHJlW0NPTVBBUkFUT1JdO1xuICB2YXIgc2V0ID0gcmFuZ2Uuc3BsaXQoJyAnKS5tYXAoZnVuY3Rpb24oY29tcCkge1xuICAgIHJldHVybiBwYXJzZUNvbXBhcmF0b3IoY29tcCwgbG9vc2UpO1xuICB9KS5qb2luKCcgJykuc3BsaXQoL1xccysvKTtcbiAgaWYgKHRoaXMubG9vc2UpIHtcbiAgICAvLyBpbiBsb29zZSBtb2RlLCB0aHJvdyBvdXQgYW55IHRoYXQgYXJlIG5vdCB2YWxpZCBjb21wYXJhdG9yc1xuICAgIHNldCA9IHNldC5maWx0ZXIoZnVuY3Rpb24oY29tcCkge1xuICAgICAgcmV0dXJuICEhY29tcC5tYXRjaChjb21wUmUpO1xuICAgIH0pO1xuICB9XG4gIHNldCA9IHNldC5tYXAoZnVuY3Rpb24oY29tcCkge1xuICAgIHJldHVybiBuZXcgQ29tcGFyYXRvcihjb21wLCBsb29zZSk7XG4gIH0pO1xuXG4gIHJldHVybiBzZXQ7XG59O1xuXG5SYW5nZS5wcm90b3R5cGUuaW50ZXJzZWN0cyA9IGZ1bmN0aW9uKHJhbmdlLCBsb29zZSkge1xuICBpZiAoIShyYW5nZSBpbnN0YW5jZW9mIFJhbmdlKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2EgUmFuZ2UgaXMgcmVxdWlyZWQnKTtcbiAgfVxuXG4gIHJldHVybiB0aGlzLnNldC5zb21lKGZ1bmN0aW9uKHRoaXNDb21wYXJhdG9ycykge1xuICAgIHJldHVybiB0aGlzQ29tcGFyYXRvcnMuZXZlcnkoZnVuY3Rpb24odGhpc0NvbXBhcmF0b3IpIHtcbiAgICAgIHJldHVybiByYW5nZS5zZXQuc29tZShmdW5jdGlvbihyYW5nZUNvbXBhcmF0b3JzKSB7XG4gICAgICAgIHJldHVybiByYW5nZUNvbXBhcmF0b3JzLmV2ZXJ5KGZ1bmN0aW9uKHJhbmdlQ29tcGFyYXRvcikge1xuICAgICAgICAgIHJldHVybiB0aGlzQ29tcGFyYXRvci5pbnRlcnNlY3RzKHJhbmdlQ29tcGFyYXRvciwgbG9vc2UpO1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9KTtcbn07XG5cbi8vIE1vc3RseSBqdXN0IGZvciB0ZXN0aW5nIGFuZCBsZWdhY3kgQVBJIHJlYXNvbnNcbmV4cG9ydHMudG9Db21wYXJhdG9ycyA9IHRvQ29tcGFyYXRvcnM7XG5mdW5jdGlvbiB0b0NvbXBhcmF0b3JzKHJhbmdlLCBsb29zZSkge1xuICByZXR1cm4gbmV3IFJhbmdlKHJhbmdlLCBsb29zZSkuc2V0Lm1hcChmdW5jdGlvbihjb21wKSB7XG4gICAgcmV0dXJuIGNvbXAubWFwKGZ1bmN0aW9uKGMpIHtcbiAgICAgIHJldHVybiBjLnZhbHVlO1xuICAgIH0pLmpvaW4oJyAnKS50cmltKCkuc3BsaXQoJyAnKTtcbiAgfSk7XG59XG5cbi8vIGNvbXByaXNlZCBvZiB4cmFuZ2VzLCB0aWxkZXMsIHN0YXJzLCBhbmQgZ3RsdCdzIGF0IHRoaXMgcG9pbnQuXG4vLyBhbHJlYWR5IHJlcGxhY2VkIHRoZSBoeXBoZW4gcmFuZ2VzXG4vLyB0dXJuIGludG8gYSBzZXQgb2YgSlVTVCBjb21wYXJhdG9ycy5cbmZ1bmN0aW9uIHBhcnNlQ29tcGFyYXRvcihjb21wLCBsb29zZSkge1xuICBkZWJ1ZygnY29tcCcsIGNvbXApO1xuICBjb21wID0gcmVwbGFjZUNhcmV0cyhjb21wLCBsb29zZSk7XG4gIGRlYnVnKCdjYXJldCcsIGNvbXApO1xuICBjb21wID0gcmVwbGFjZVRpbGRlcyhjb21wLCBsb29zZSk7XG4gIGRlYnVnKCd0aWxkZXMnLCBjb21wKTtcbiAgY29tcCA9IHJlcGxhY2VYUmFuZ2VzKGNvbXAsIGxvb3NlKTtcbiAgZGVidWcoJ3hyYW5nZScsIGNvbXApO1xuICBjb21wID0gcmVwbGFjZVN0YXJzKGNvbXAsIGxvb3NlKTtcbiAgZGVidWcoJ3N0YXJzJywgY29tcCk7XG4gIHJldHVybiBjb21wO1xufVxuXG5mdW5jdGlvbiBpc1goaWQpIHtcbiAgcmV0dXJuICFpZCB8fCBpZC50b0xvd2VyQ2FzZSgpID09PSAneCcgfHwgaWQgPT09ICcqJztcbn1cblxuLy8gfiwgfj4gLS0+ICogKGFueSwga2luZGEgc2lsbHkpXG4vLyB+MiwgfjIueCwgfjIueC54LCB+PjIsIH4+Mi54IH4+Mi54LnggLS0+ID49Mi4wLjAgPDMuMC4wXG4vLyB+Mi4wLCB+Mi4wLngsIH4+Mi4wLCB+PjIuMC54IC0tPiA+PTIuMC4wIDwyLjEuMFxuLy8gfjEuMiwgfjEuMi54LCB+PjEuMiwgfj4xLjIueCAtLT4gPj0xLjIuMCA8MS4zLjBcbi8vIH4xLjIuMywgfj4xLjIuMyAtLT4gPj0xLjIuMyA8MS4zLjBcbi8vIH4xLjIuMCwgfj4xLjIuMCAtLT4gPj0xLjIuMCA8MS4zLjBcbmZ1bmN0aW9uIHJlcGxhY2VUaWxkZXMoY29tcCwgbG9vc2UpIHtcbiAgcmV0dXJuIGNvbXAudHJpbSgpLnNwbGl0KC9cXHMrLykubWFwKGZ1bmN0aW9uKGNvbXApIHtcbiAgICByZXR1cm4gcmVwbGFjZVRpbGRlKGNvbXAsIGxvb3NlKTtcbiAgfSkuam9pbignICcpO1xufVxuXG5mdW5jdGlvbiByZXBsYWNlVGlsZGUoY29tcCwgbG9vc2UpIHtcbiAgdmFyIHIgPSBsb29zZSA/IHJlW1RJTERFTE9PU0VdIDogcmVbVElMREVdO1xuICByZXR1cm4gY29tcC5yZXBsYWNlKHIsIGZ1bmN0aW9uKF8sIE0sIG0sIHAsIHByKSB7XG4gICAgZGVidWcoJ3RpbGRlJywgY29tcCwgXywgTSwgbSwgcCwgcHIpO1xuICAgIHZhciByZXQ7XG5cbiAgICBpZiAoaXNYKE0pKVxuICAgICAgcmV0ID0gJyc7XG4gICAgZWxzZSBpZiAoaXNYKG0pKVxuICAgICAgcmV0ID0gJz49JyArIE0gKyAnLjAuMCA8JyArICgrTSArIDEpICsgJy4wLjAnO1xuICAgIGVsc2UgaWYgKGlzWChwKSlcbiAgICAgIC8vIH4xLjIgPT0gPj0xLjIuMCA8MS4zLjBcbiAgICAgIHJldCA9ICc+PScgKyBNICsgJy4nICsgbSArICcuMCA8JyArIE0gKyAnLicgKyAoK20gKyAxKSArICcuMCc7XG4gICAgZWxzZSBpZiAocHIpIHtcbiAgICAgIGRlYnVnKCdyZXBsYWNlVGlsZGUgcHInLCBwcik7XG4gICAgICBpZiAocHIuY2hhckF0KDApICE9PSAnLScpXG4gICAgICAgIHByID0gJy0nICsgcHI7XG4gICAgICByZXQgPSAnPj0nICsgTSArICcuJyArIG0gKyAnLicgKyBwICsgcHIgK1xuICAgICAgICAgICAgJyA8JyArIE0gKyAnLicgKyAoK20gKyAxKSArICcuMCc7XG4gICAgfSBlbHNlXG4gICAgICAvLyB+MS4yLjMgPT0gPj0xLjIuMyA8MS4zLjBcbiAgICAgIHJldCA9ICc+PScgKyBNICsgJy4nICsgbSArICcuJyArIHAgK1xuICAgICAgICAgICAgJyA8JyArIE0gKyAnLicgKyAoK20gKyAxKSArICcuMCc7XG5cbiAgICBkZWJ1ZygndGlsZGUgcmV0dXJuJywgcmV0KTtcbiAgICByZXR1cm4gcmV0O1xuICB9KTtcbn1cblxuLy8gXiAtLT4gKiAoYW55LCBraW5kYSBzaWxseSlcbi8vIF4yLCBeMi54LCBeMi54LnggLS0+ID49Mi4wLjAgPDMuMC4wXG4vLyBeMi4wLCBeMi4wLnggLS0+ID49Mi4wLjAgPDMuMC4wXG4vLyBeMS4yLCBeMS4yLnggLS0+ID49MS4yLjAgPDIuMC4wXG4vLyBeMS4yLjMgLS0+ID49MS4yLjMgPDIuMC4wXG4vLyBeMS4yLjAgLS0+ID49MS4yLjAgPDIuMC4wXG5mdW5jdGlvbiByZXBsYWNlQ2FyZXRzKGNvbXAsIGxvb3NlKSB7XG4gIHJldHVybiBjb21wLnRyaW0oKS5zcGxpdCgvXFxzKy8pLm1hcChmdW5jdGlvbihjb21wKSB7XG4gICAgcmV0dXJuIHJlcGxhY2VDYXJldChjb21wLCBsb29zZSk7XG4gIH0pLmpvaW4oJyAnKTtcbn1cblxuZnVuY3Rpb24gcmVwbGFjZUNhcmV0KGNvbXAsIGxvb3NlKSB7XG4gIGRlYnVnKCdjYXJldCcsIGNvbXAsIGxvb3NlKTtcbiAgdmFyIHIgPSBsb29zZSA/IHJlW0NBUkVUTE9PU0VdIDogcmVbQ0FSRVRdO1xuICByZXR1cm4gY29tcC5yZXBsYWNlKHIsIGZ1bmN0aW9uKF8sIE0sIG0sIHAsIHByKSB7XG4gICAgZGVidWcoJ2NhcmV0JywgY29tcCwgXywgTSwgbSwgcCwgcHIpO1xuICAgIHZhciByZXQ7XG5cbiAgICBpZiAoaXNYKE0pKVxuICAgICAgcmV0ID0gJyc7XG4gICAgZWxzZSBpZiAoaXNYKG0pKVxuICAgICAgcmV0ID0gJz49JyArIE0gKyAnLjAuMCA8JyArICgrTSArIDEpICsgJy4wLjAnO1xuICAgIGVsc2UgaWYgKGlzWChwKSkge1xuICAgICAgaWYgKE0gPT09ICcwJylcbiAgICAgICAgcmV0ID0gJz49JyArIE0gKyAnLicgKyBtICsgJy4wIDwnICsgTSArICcuJyArICgrbSArIDEpICsgJy4wJztcbiAgICAgIGVsc2VcbiAgICAgICAgcmV0ID0gJz49JyArIE0gKyAnLicgKyBtICsgJy4wIDwnICsgKCtNICsgMSkgKyAnLjAuMCc7XG4gICAgfSBlbHNlIGlmIChwcikge1xuICAgICAgZGVidWcoJ3JlcGxhY2VDYXJldCBwcicsIHByKTtcbiAgICAgIGlmIChwci5jaGFyQXQoMCkgIT09ICctJylcbiAgICAgICAgcHIgPSAnLScgKyBwcjtcbiAgICAgIGlmIChNID09PSAnMCcpIHtcbiAgICAgICAgaWYgKG0gPT09ICcwJylcbiAgICAgICAgICByZXQgPSAnPj0nICsgTSArICcuJyArIG0gKyAnLicgKyBwICsgcHIgK1xuICAgICAgICAgICAgICAgICcgPCcgKyBNICsgJy4nICsgbSArICcuJyArICgrcCArIDEpO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgcmV0ID0gJz49JyArIE0gKyAnLicgKyBtICsgJy4nICsgcCArIHByICtcbiAgICAgICAgICAgICAgICAnIDwnICsgTSArICcuJyArICgrbSArIDEpICsgJy4wJztcbiAgICAgIH0gZWxzZVxuICAgICAgICByZXQgPSAnPj0nICsgTSArICcuJyArIG0gKyAnLicgKyBwICsgcHIgK1xuICAgICAgICAgICAgICAnIDwnICsgKCtNICsgMSkgKyAnLjAuMCc7XG4gICAgfSBlbHNlIHtcbiAgICAgIGRlYnVnKCdubyBwcicpO1xuICAgICAgaWYgKE0gPT09ICcwJykge1xuICAgICAgICBpZiAobSA9PT0gJzAnKVxuICAgICAgICAgIHJldCA9ICc+PScgKyBNICsgJy4nICsgbSArICcuJyArIHAgK1xuICAgICAgICAgICAgICAgICcgPCcgKyBNICsgJy4nICsgbSArICcuJyArICgrcCArIDEpO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgcmV0ID0gJz49JyArIE0gKyAnLicgKyBtICsgJy4nICsgcCArXG4gICAgICAgICAgICAgICAgJyA8JyArIE0gKyAnLicgKyAoK20gKyAxKSArICcuMCc7XG4gICAgICB9IGVsc2VcbiAgICAgICAgcmV0ID0gJz49JyArIE0gKyAnLicgKyBtICsgJy4nICsgcCArXG4gICAgICAgICAgICAgICcgPCcgKyAoK00gKyAxKSArICcuMC4wJztcbiAgICB9XG5cbiAgICBkZWJ1ZygnY2FyZXQgcmV0dXJuJywgcmV0KTtcbiAgICByZXR1cm4gcmV0O1xuICB9KTtcbn1cblxuZnVuY3Rpb24gcmVwbGFjZVhSYW5nZXMoY29tcCwgbG9vc2UpIHtcbiAgZGVidWcoJ3JlcGxhY2VYUmFuZ2VzJywgY29tcCwgbG9vc2UpO1xuICByZXR1cm4gY29tcC5zcGxpdCgvXFxzKy8pLm1hcChmdW5jdGlvbihjb21wKSB7XG4gICAgcmV0dXJuIHJlcGxhY2VYUmFuZ2UoY29tcCwgbG9vc2UpO1xuICB9KS5qb2luKCcgJyk7XG59XG5cbmZ1bmN0aW9uIHJlcGxhY2VYUmFuZ2UoY29tcCwgbG9vc2UpIHtcbiAgY29tcCA9IGNvbXAudHJpbSgpO1xuICB2YXIgciA9IGxvb3NlID8gcmVbWFJBTkdFTE9PU0VdIDogcmVbWFJBTkdFXTtcbiAgcmV0dXJuIGNvbXAucmVwbGFjZShyLCBmdW5jdGlvbihyZXQsIGd0bHQsIE0sIG0sIHAsIHByKSB7XG4gICAgZGVidWcoJ3hSYW5nZScsIGNvbXAsIHJldCwgZ3RsdCwgTSwgbSwgcCwgcHIpO1xuICAgIHZhciB4TSA9IGlzWChNKTtcbiAgICB2YXIgeG0gPSB4TSB8fCBpc1gobSk7XG4gICAgdmFyIHhwID0geG0gfHwgaXNYKHApO1xuICAgIHZhciBhbnlYID0geHA7XG5cbiAgICBpZiAoZ3RsdCA9PT0gJz0nICYmIGFueVgpXG4gICAgICBndGx0ID0gJyc7XG5cbiAgICBpZiAoeE0pIHtcbiAgICAgIGlmIChndGx0ID09PSAnPicgfHwgZ3RsdCA9PT0gJzwnKSB7XG4gICAgICAgIC8vIG5vdGhpbmcgaXMgYWxsb3dlZFxuICAgICAgICByZXQgPSAnPDAuMC4wJztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIG5vdGhpbmcgaXMgZm9yYmlkZGVuXG4gICAgICAgIHJldCA9ICcqJztcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGd0bHQgJiYgYW55WCkge1xuICAgICAgLy8gcmVwbGFjZSBYIHdpdGggMFxuICAgICAgaWYgKHhtKVxuICAgICAgICBtID0gMDtcbiAgICAgIGlmICh4cClcbiAgICAgICAgcCA9IDA7XG5cbiAgICAgIGlmIChndGx0ID09PSAnPicpIHtcbiAgICAgICAgLy8gPjEgPT4gPj0yLjAuMFxuICAgICAgICAvLyA+MS4yID0+ID49MS4zLjBcbiAgICAgICAgLy8gPjEuMi4zID0+ID49IDEuMi40XG4gICAgICAgIGd0bHQgPSAnPj0nO1xuICAgICAgICBpZiAoeG0pIHtcbiAgICAgICAgICBNID0gK00gKyAxO1xuICAgICAgICAgIG0gPSAwO1xuICAgICAgICAgIHAgPSAwO1xuICAgICAgICB9IGVsc2UgaWYgKHhwKSB7XG4gICAgICAgICAgbSA9ICttICsgMTtcbiAgICAgICAgICBwID0gMDtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChndGx0ID09PSAnPD0nKSB7XG4gICAgICAgIC8vIDw9MC43LnggaXMgYWN0dWFsbHkgPDAuOC4wLCBzaW5jZSBhbnkgMC43Lnggc2hvdWxkXG4gICAgICAgIC8vIHBhc3MuICBTaW1pbGFybHksIDw9Ny54IGlzIGFjdHVhbGx5IDw4LjAuMCwgZXRjLlxuICAgICAgICBndGx0ID0gJzwnO1xuICAgICAgICBpZiAoeG0pXG4gICAgICAgICAgTSA9ICtNICsgMTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgIG0gPSArbSArIDE7XG4gICAgICB9XG5cbiAgICAgIHJldCA9IGd0bHQgKyBNICsgJy4nICsgbSArICcuJyArIHA7XG4gICAgfSBlbHNlIGlmICh4bSkge1xuICAgICAgcmV0ID0gJz49JyArIE0gKyAnLjAuMCA8JyArICgrTSArIDEpICsgJy4wLjAnO1xuICAgIH0gZWxzZSBpZiAoeHApIHtcbiAgICAgIHJldCA9ICc+PScgKyBNICsgJy4nICsgbSArICcuMCA8JyArIE0gKyAnLicgKyAoK20gKyAxKSArICcuMCc7XG4gICAgfVxuXG4gICAgZGVidWcoJ3hSYW5nZSByZXR1cm4nLCByZXQpO1xuXG4gICAgcmV0dXJuIHJldDtcbiAgfSk7XG59XG5cbi8vIEJlY2F1c2UgKiBpcyBBTkQtZWQgd2l0aCBldmVyeXRoaW5nIGVsc2UgaW4gdGhlIGNvbXBhcmF0b3IsXG4vLyBhbmQgJycgbWVhbnMgXCJhbnkgdmVyc2lvblwiLCBqdXN0IHJlbW92ZSB0aGUgKnMgZW50aXJlbHkuXG5mdW5jdGlvbiByZXBsYWNlU3RhcnMoY29tcCwgbG9vc2UpIHtcbiAgZGVidWcoJ3JlcGxhY2VTdGFycycsIGNvbXAsIGxvb3NlKTtcbiAgLy8gTG9vc2VuZXNzIGlzIGlnbm9yZWQgaGVyZS4gIHN0YXIgaXMgYWx3YXlzIGFzIGxvb3NlIGFzIGl0IGdldHMhXG4gIHJldHVybiBjb21wLnRyaW0oKS5yZXBsYWNlKHJlW1NUQVJdLCAnJyk7XG59XG5cbi8vIFRoaXMgZnVuY3Rpb24gaXMgcGFzc2VkIHRvIHN0cmluZy5yZXBsYWNlKHJlW0hZUEhFTlJBTkdFXSlcbi8vIE0sIG0sIHBhdGNoLCBwcmVyZWxlYXNlLCBidWlsZFxuLy8gMS4yIC0gMy40LjUgPT4gPj0xLjIuMCA8PTMuNC41XG4vLyAxLjIuMyAtIDMuNCA9PiA+PTEuMi4wIDwzLjUuMCBBbnkgMy40Lnggd2lsbCBkb1xuLy8gMS4yIC0gMy40ID0+ID49MS4yLjAgPDMuNS4wXG5mdW5jdGlvbiBoeXBoZW5SZXBsYWNlKCQwLFxuICAgICAgICAgICAgICAgICAgICAgICBmcm9tLCBmTSwgZm0sIGZwLCBmcHIsIGZiLFxuICAgICAgICAgICAgICAgICAgICAgICB0bywgdE0sIHRtLCB0cCwgdHByLCB0Yikge1xuXG4gIGlmIChpc1goZk0pKVxuICAgIGZyb20gPSAnJztcbiAgZWxzZSBpZiAoaXNYKGZtKSlcbiAgICBmcm9tID0gJz49JyArIGZNICsgJy4wLjAnO1xuICBlbHNlIGlmIChpc1goZnApKVxuICAgIGZyb20gPSAnPj0nICsgZk0gKyAnLicgKyBmbSArICcuMCc7XG4gIGVsc2VcbiAgICBmcm9tID0gJz49JyArIGZyb207XG5cbiAgaWYgKGlzWCh0TSkpXG4gICAgdG8gPSAnJztcbiAgZWxzZSBpZiAoaXNYKHRtKSlcbiAgICB0byA9ICc8JyArICgrdE0gKyAxKSArICcuMC4wJztcbiAgZWxzZSBpZiAoaXNYKHRwKSlcbiAgICB0byA9ICc8JyArIHRNICsgJy4nICsgKCt0bSArIDEpICsgJy4wJztcbiAgZWxzZSBpZiAodHByKVxuICAgIHRvID0gJzw9JyArIHRNICsgJy4nICsgdG0gKyAnLicgKyB0cCArICctJyArIHRwcjtcbiAgZWxzZVxuICAgIHRvID0gJzw9JyArIHRvO1xuXG4gIHJldHVybiAoZnJvbSArICcgJyArIHRvKS50cmltKCk7XG59XG5cblxuLy8gaWYgQU5ZIG9mIHRoZSBzZXRzIG1hdGNoIEFMTCBvZiBpdHMgY29tcGFyYXRvcnMsIHRoZW4gcGFzc1xuUmFuZ2UucHJvdG90eXBlLnRlc3QgPSBmdW5jdGlvbih2ZXJzaW9uKSB7XG4gIGlmICghdmVyc2lvbilcbiAgICByZXR1cm4gZmFsc2U7XG5cbiAgaWYgKHR5cGVvZiB2ZXJzaW9uID09PSAnc3RyaW5nJylcbiAgICB2ZXJzaW9uID0gbmV3IFNlbVZlcih2ZXJzaW9uLCB0aGlzLmxvb3NlKTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuc2V0Lmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKHRlc3RTZXQodGhpcy5zZXRbaV0sIHZlcnNpb24pKVxuICAgICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufTtcblxuZnVuY3Rpb24gdGVzdFNldChzZXQsIHZlcnNpb24pIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzZXQubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAoIXNldFtpXS50ZXN0KHZlcnNpb24pKVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgaWYgKHZlcnNpb24ucHJlcmVsZWFzZS5sZW5ndGgpIHtcbiAgICAvLyBGaW5kIHRoZSBzZXQgb2YgdmVyc2lvbnMgdGhhdCBhcmUgYWxsb3dlZCB0byBoYXZlIHByZXJlbGVhc2VzXG4gICAgLy8gRm9yIGV4YW1wbGUsIF4xLjIuMy1wci4xIGRlc3VnYXJzIHRvID49MS4yLjMtcHIuMSA8Mi4wLjBcbiAgICAvLyBUaGF0IHNob3VsZCBhbGxvdyBgMS4yLjMtcHIuMmAgdG8gcGFzcy5cbiAgICAvLyBIb3dldmVyLCBgMS4yLjQtYWxwaGEubm90cmVhZHlgIHNob3VsZCBOT1QgYmUgYWxsb3dlZCxcbiAgICAvLyBldmVuIHRob3VnaCBpdCdzIHdpdGhpbiB0aGUgcmFuZ2Ugc2V0IGJ5IHRoZSBjb21wYXJhdG9ycy5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNldC5sZW5ndGg7IGkrKykge1xuICAgICAgZGVidWcoc2V0W2ldLnNlbXZlcik7XG4gICAgICBpZiAoc2V0W2ldLnNlbXZlciA9PT0gQU5ZKVxuICAgICAgICBjb250aW51ZTtcblxuICAgICAgaWYgKHNldFtpXS5zZW12ZXIucHJlcmVsZWFzZS5sZW5ndGggPiAwKSB7XG4gICAgICAgIHZhciBhbGxvd2VkID0gc2V0W2ldLnNlbXZlcjtcbiAgICAgICAgaWYgKGFsbG93ZWQubWFqb3IgPT09IHZlcnNpb24ubWFqb3IgJiZcbiAgICAgICAgICAgIGFsbG93ZWQubWlub3IgPT09IHZlcnNpb24ubWlub3IgJiZcbiAgICAgICAgICAgIGFsbG93ZWQucGF0Y2ggPT09IHZlcnNpb24ucGF0Y2gpXG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gVmVyc2lvbiBoYXMgYSAtcHJlLCBidXQgaXQncyBub3Qgb25lIG9mIHRoZSBvbmVzIHdlIGxpa2UuXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59XG5cbmV4cG9ydHMuc2F0aXNmaWVzID0gc2F0aXNmaWVzO1xuZnVuY3Rpb24gc2F0aXNmaWVzKHZlcnNpb24sIHJhbmdlLCBsb29zZSkge1xuICB0cnkge1xuICAgIHJhbmdlID0gbmV3IFJhbmdlKHJhbmdlLCBsb29zZSk7XG4gIH0gY2F0Y2ggKGVyKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHJldHVybiByYW5nZS50ZXN0KHZlcnNpb24pO1xufVxuXG5leHBvcnRzLm1heFNhdGlzZnlpbmcgPSBtYXhTYXRpc2Z5aW5nO1xuZnVuY3Rpb24gbWF4U2F0aXNmeWluZyh2ZXJzaW9ucywgcmFuZ2UsIGxvb3NlKSB7XG4gIHZhciBtYXggPSBudWxsO1xuICB2YXIgbWF4U1YgPSBudWxsO1xuICB0cnkge1xuICAgIHZhciByYW5nZU9iaiA9IG5ldyBSYW5nZShyYW5nZSwgbG9vc2UpO1xuICB9IGNhdGNoIChlcikge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIHZlcnNpb25zLmZvckVhY2goZnVuY3Rpb24gKHYpIHtcbiAgICBpZiAocmFuZ2VPYmoudGVzdCh2KSkgeyAvLyBzYXRpc2ZpZXModiwgcmFuZ2UsIGxvb3NlKVxuICAgICAgaWYgKCFtYXggfHwgbWF4U1YuY29tcGFyZSh2KSA9PT0gLTEpIHsgLy8gY29tcGFyZShtYXgsIHYsIHRydWUpXG4gICAgICAgIG1heCA9IHY7XG4gICAgICAgIG1heFNWID0gbmV3IFNlbVZlcihtYXgsIGxvb3NlKTtcbiAgICAgIH1cbiAgICB9XG4gIH0pXG4gIHJldHVybiBtYXg7XG59XG5cbmV4cG9ydHMubWluU2F0aXNmeWluZyA9IG1pblNhdGlzZnlpbmc7XG5mdW5jdGlvbiBtaW5TYXRpc2Z5aW5nKHZlcnNpb25zLCByYW5nZSwgbG9vc2UpIHtcbiAgdmFyIG1pbiA9IG51bGw7XG4gIHZhciBtaW5TViA9IG51bGw7XG4gIHRyeSB7XG4gICAgdmFyIHJhbmdlT2JqID0gbmV3IFJhbmdlKHJhbmdlLCBsb29zZSk7XG4gIH0gY2F0Y2ggKGVyKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgdmVyc2lvbnMuZm9yRWFjaChmdW5jdGlvbiAodikge1xuICAgIGlmIChyYW5nZU9iai50ZXN0KHYpKSB7IC8vIHNhdGlzZmllcyh2LCByYW5nZSwgbG9vc2UpXG4gICAgICBpZiAoIW1pbiB8fCBtaW5TVi5jb21wYXJlKHYpID09PSAxKSB7IC8vIGNvbXBhcmUobWluLCB2LCB0cnVlKVxuICAgICAgICBtaW4gPSB2O1xuICAgICAgICBtaW5TViA9IG5ldyBTZW1WZXIobWluLCBsb29zZSk7XG4gICAgICB9XG4gICAgfVxuICB9KVxuICByZXR1cm4gbWluO1xufVxuXG5leHBvcnRzLnZhbGlkUmFuZ2UgPSB2YWxpZFJhbmdlO1xuZnVuY3Rpb24gdmFsaWRSYW5nZShyYW5nZSwgbG9vc2UpIHtcbiAgdHJ5IHtcbiAgICAvLyBSZXR1cm4gJyonIGluc3RlYWQgb2YgJycgc28gdGhhdCB0cnV0aGluZXNzIHdvcmtzLlxuICAgIC8vIFRoaXMgd2lsbCB0aHJvdyBpZiBpdCdzIGludmFsaWQgYW55d2F5XG4gICAgcmV0dXJuIG5ldyBSYW5nZShyYW5nZSwgbG9vc2UpLnJhbmdlIHx8ICcqJztcbiAgfSBjYXRjaCAoZXIpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxufVxuXG4vLyBEZXRlcm1pbmUgaWYgdmVyc2lvbiBpcyBsZXNzIHRoYW4gYWxsIHRoZSB2ZXJzaW9ucyBwb3NzaWJsZSBpbiB0aGUgcmFuZ2VcbmV4cG9ydHMubHRyID0gbHRyO1xuZnVuY3Rpb24gbHRyKHZlcnNpb24sIHJhbmdlLCBsb29zZSkge1xuICByZXR1cm4gb3V0c2lkZSh2ZXJzaW9uLCByYW5nZSwgJzwnLCBsb29zZSk7XG59XG5cbi8vIERldGVybWluZSBpZiB2ZXJzaW9uIGlzIGdyZWF0ZXIgdGhhbiBhbGwgdGhlIHZlcnNpb25zIHBvc3NpYmxlIGluIHRoZSByYW5nZS5cbmV4cG9ydHMuZ3RyID0gZ3RyO1xuZnVuY3Rpb24gZ3RyKHZlcnNpb24sIHJhbmdlLCBsb29zZSkge1xuICByZXR1cm4gb3V0c2lkZSh2ZXJzaW9uLCByYW5nZSwgJz4nLCBsb29zZSk7XG59XG5cbmV4cG9ydHMub3V0c2lkZSA9IG91dHNpZGU7XG5mdW5jdGlvbiBvdXRzaWRlKHZlcnNpb24sIHJhbmdlLCBoaWxvLCBsb29zZSkge1xuICB2ZXJzaW9uID0gbmV3IFNlbVZlcih2ZXJzaW9uLCBsb29zZSk7XG4gIHJhbmdlID0gbmV3IFJhbmdlKHJhbmdlLCBsb29zZSk7XG5cbiAgdmFyIGd0Zm4sIGx0ZWZuLCBsdGZuLCBjb21wLCBlY29tcDtcbiAgc3dpdGNoIChoaWxvKSB7XG4gICAgY2FzZSAnPic6XG4gICAgICBndGZuID0gZ3Q7XG4gICAgICBsdGVmbiA9IGx0ZTtcbiAgICAgIGx0Zm4gPSBsdDtcbiAgICAgIGNvbXAgPSAnPic7XG4gICAgICBlY29tcCA9ICc+PSc7XG4gICAgICBicmVhaztcbiAgICBjYXNlICc8JzpcbiAgICAgIGd0Zm4gPSBsdDtcbiAgICAgIGx0ZWZuID0gZ3RlO1xuICAgICAgbHRmbiA9IGd0O1xuICAgICAgY29tcCA9ICc8JztcbiAgICAgIGVjb21wID0gJzw9JztcbiAgICAgIGJyZWFrO1xuICAgIGRlZmF1bHQ6XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdNdXN0IHByb3ZpZGUgYSBoaWxvIHZhbCBvZiBcIjxcIiBvciBcIj5cIicpO1xuICB9XG5cbiAgLy8gSWYgaXQgc2F0aXNpZmVzIHRoZSByYW5nZSBpdCBpcyBub3Qgb3V0c2lkZVxuICBpZiAoc2F0aXNmaWVzKHZlcnNpb24sIHJhbmdlLCBsb29zZSkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICAvLyBGcm9tIG5vdyBvbiwgdmFyaWFibGUgdGVybXMgYXJlIGFzIGlmIHdlJ3JlIGluIFwiZ3RyXCIgbW9kZS5cbiAgLy8gYnV0IG5vdGUgdGhhdCBldmVyeXRoaW5nIGlzIGZsaXBwZWQgZm9yIHRoZSBcImx0clwiIGZ1bmN0aW9uLlxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcmFuZ2Uuc2V0Lmxlbmd0aDsgKytpKSB7XG4gICAgdmFyIGNvbXBhcmF0b3JzID0gcmFuZ2Uuc2V0W2ldO1xuXG4gICAgdmFyIGhpZ2ggPSBudWxsO1xuICAgIHZhciBsb3cgPSBudWxsO1xuXG4gICAgY29tcGFyYXRvcnMuZm9yRWFjaChmdW5jdGlvbihjb21wYXJhdG9yKSB7XG4gICAgICBpZiAoY29tcGFyYXRvci5zZW12ZXIgPT09IEFOWSkge1xuICAgICAgICBjb21wYXJhdG9yID0gbmV3IENvbXBhcmF0b3IoJz49MC4wLjAnKVxuICAgICAgfVxuICAgICAgaGlnaCA9IGhpZ2ggfHwgY29tcGFyYXRvcjtcbiAgICAgIGxvdyA9IGxvdyB8fCBjb21wYXJhdG9yO1xuICAgICAgaWYgKGd0Zm4oY29tcGFyYXRvci5zZW12ZXIsIGhpZ2guc2VtdmVyLCBsb29zZSkpIHtcbiAgICAgICAgaGlnaCA9IGNvbXBhcmF0b3I7XG4gICAgICB9IGVsc2UgaWYgKGx0Zm4oY29tcGFyYXRvci5zZW12ZXIsIGxvdy5zZW12ZXIsIGxvb3NlKSkge1xuICAgICAgICBsb3cgPSBjb21wYXJhdG9yO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgLy8gSWYgdGhlIGVkZ2UgdmVyc2lvbiBjb21wYXJhdG9yIGhhcyBhIG9wZXJhdG9yIHRoZW4gb3VyIHZlcnNpb25cbiAgICAvLyBpc24ndCBvdXRzaWRlIGl0XG4gICAgaWYgKGhpZ2gub3BlcmF0b3IgPT09IGNvbXAgfHwgaGlnaC5vcGVyYXRvciA9PT0gZWNvbXApIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICAvLyBJZiB0aGUgbG93ZXN0IHZlcnNpb24gY29tcGFyYXRvciBoYXMgYW4gb3BlcmF0b3IgYW5kIG91ciB2ZXJzaW9uXG4gICAgLy8gaXMgbGVzcyB0aGFuIGl0IHRoZW4gaXQgaXNuJ3QgaGlnaGVyIHRoYW4gdGhlIHJhbmdlXG4gICAgaWYgKCghbG93Lm9wZXJhdG9yIHx8IGxvdy5vcGVyYXRvciA9PT0gY29tcCkgJiZcbiAgICAgICAgbHRlZm4odmVyc2lvbiwgbG93LnNlbXZlcikpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9IGVsc2UgaWYgKGxvdy5vcGVyYXRvciA9PT0gZWNvbXAgJiYgbHRmbih2ZXJzaW9uLCBsb3cuc2VtdmVyKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn1cblxuZXhwb3J0cy5wcmVyZWxlYXNlID0gcHJlcmVsZWFzZTtcbmZ1bmN0aW9uIHByZXJlbGVhc2UodmVyc2lvbiwgbG9vc2UpIHtcbiAgdmFyIHBhcnNlZCA9IHBhcnNlKHZlcnNpb24sIGxvb3NlKTtcbiAgcmV0dXJuIChwYXJzZWQgJiYgcGFyc2VkLnByZXJlbGVhc2UubGVuZ3RoKSA/IHBhcnNlZC5wcmVyZWxlYXNlIDogbnVsbDtcbn1cblxuZXhwb3J0cy5pbnRlcnNlY3RzID0gaW50ZXJzZWN0cztcbmZ1bmN0aW9uIGludGVyc2VjdHMocjEsIHIyLCBsb29zZSkge1xuICByMSA9IG5ldyBSYW5nZShyMSwgbG9vc2UpXG4gIHIyID0gbmV3IFJhbmdlKHIyLCBsb29zZSlcbiAgcmV0dXJuIHIxLmludGVyc2VjdHMocjIpXG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvc2VtdmVyL3NlbXZlci5qcyIsIi8qIC0qLSBNb2RlOiBqczsganMtaW5kZW50LWxldmVsOiAyOyAtKi0gKi9cbi8qXG4gKiBDb3B5cmlnaHQgMjAxMSBNb3ppbGxhIEZvdW5kYXRpb24gYW5kIGNvbnRyaWJ1dG9yc1xuICogTGljZW5zZWQgdW5kZXIgdGhlIE5ldyBCU0QgbGljZW5zZS4gU2VlIExJQ0VOU0Ugb3I6XG4gKiBodHRwOi8vb3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvQlNELTMtQ2xhdXNlXG4gKi9cblxudmFyIGJhc2U2NFZMUSA9IHJlcXVpcmUoJy4vYmFzZTY0LXZscScpO1xudmFyIHV0aWwgPSByZXF1aXJlKCcuL3V0aWwnKTtcbnZhciBBcnJheVNldCA9IHJlcXVpcmUoJy4vYXJyYXktc2V0JykuQXJyYXlTZXQ7XG52YXIgTWFwcGluZ0xpc3QgPSByZXF1aXJlKCcuL21hcHBpbmctbGlzdCcpLk1hcHBpbmdMaXN0O1xuXG4vKipcbiAqIEFuIGluc3RhbmNlIG9mIHRoZSBTb3VyY2VNYXBHZW5lcmF0b3IgcmVwcmVzZW50cyBhIHNvdXJjZSBtYXAgd2hpY2ggaXNcbiAqIGJlaW5nIGJ1aWx0IGluY3JlbWVudGFsbHkuIFlvdSBtYXkgcGFzcyBhbiBvYmplY3Qgd2l0aCB0aGUgZm9sbG93aW5nXG4gKiBwcm9wZXJ0aWVzOlxuICpcbiAqICAgLSBmaWxlOiBUaGUgZmlsZW5hbWUgb2YgdGhlIGdlbmVyYXRlZCBzb3VyY2UuXG4gKiAgIC0gc291cmNlUm9vdDogQSByb290IGZvciBhbGwgcmVsYXRpdmUgVVJMcyBpbiB0aGlzIHNvdXJjZSBtYXAuXG4gKi9cbmZ1bmN0aW9uIFNvdXJjZU1hcEdlbmVyYXRvcihhQXJncykge1xuICBpZiAoIWFBcmdzKSB7XG4gICAgYUFyZ3MgPSB7fTtcbiAgfVxuICB0aGlzLl9maWxlID0gdXRpbC5nZXRBcmcoYUFyZ3MsICdmaWxlJywgbnVsbCk7XG4gIHRoaXMuX3NvdXJjZVJvb3QgPSB1dGlsLmdldEFyZyhhQXJncywgJ3NvdXJjZVJvb3QnLCBudWxsKTtcbiAgdGhpcy5fc2tpcFZhbGlkYXRpb24gPSB1dGlsLmdldEFyZyhhQXJncywgJ3NraXBWYWxpZGF0aW9uJywgZmFsc2UpO1xuICB0aGlzLl9zb3VyY2VzID0gbmV3IEFycmF5U2V0KCk7XG4gIHRoaXMuX25hbWVzID0gbmV3IEFycmF5U2V0KCk7XG4gIHRoaXMuX21hcHBpbmdzID0gbmV3IE1hcHBpbmdMaXN0KCk7XG4gIHRoaXMuX3NvdXJjZXNDb250ZW50cyA9IG51bGw7XG59XG5cblNvdXJjZU1hcEdlbmVyYXRvci5wcm90b3R5cGUuX3ZlcnNpb24gPSAzO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgU291cmNlTWFwR2VuZXJhdG9yIGJhc2VkIG9uIGEgU291cmNlTWFwQ29uc3VtZXJcbiAqXG4gKiBAcGFyYW0gYVNvdXJjZU1hcENvbnN1bWVyIFRoZSBTb3VyY2VNYXAuXG4gKi9cblNvdXJjZU1hcEdlbmVyYXRvci5mcm9tU291cmNlTWFwID1cbiAgZnVuY3Rpb24gU291cmNlTWFwR2VuZXJhdG9yX2Zyb21Tb3VyY2VNYXAoYVNvdXJjZU1hcENvbnN1bWVyKSB7XG4gICAgdmFyIHNvdXJjZVJvb3QgPSBhU291cmNlTWFwQ29uc3VtZXIuc291cmNlUm9vdDtcbiAgICB2YXIgZ2VuZXJhdG9yID0gbmV3IFNvdXJjZU1hcEdlbmVyYXRvcih7XG4gICAgICBmaWxlOiBhU291cmNlTWFwQ29uc3VtZXIuZmlsZSxcbiAgICAgIHNvdXJjZVJvb3Q6IHNvdXJjZVJvb3RcbiAgICB9KTtcbiAgICBhU291cmNlTWFwQ29uc3VtZXIuZWFjaE1hcHBpbmcoZnVuY3Rpb24gKG1hcHBpbmcpIHtcbiAgICAgIHZhciBuZXdNYXBwaW5nID0ge1xuICAgICAgICBnZW5lcmF0ZWQ6IHtcbiAgICAgICAgICBsaW5lOiBtYXBwaW5nLmdlbmVyYXRlZExpbmUsXG4gICAgICAgICAgY29sdW1uOiBtYXBwaW5nLmdlbmVyYXRlZENvbHVtblxuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICBpZiAobWFwcGluZy5zb3VyY2UgIT0gbnVsbCkge1xuICAgICAgICBuZXdNYXBwaW5nLnNvdXJjZSA9IG1hcHBpbmcuc291cmNlO1xuICAgICAgICBpZiAoc291cmNlUm9vdCAhPSBudWxsKSB7XG4gICAgICAgICAgbmV3TWFwcGluZy5zb3VyY2UgPSB1dGlsLnJlbGF0aXZlKHNvdXJjZVJvb3QsIG5ld01hcHBpbmcuc291cmNlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIG5ld01hcHBpbmcub3JpZ2luYWwgPSB7XG4gICAgICAgICAgbGluZTogbWFwcGluZy5vcmlnaW5hbExpbmUsXG4gICAgICAgICAgY29sdW1uOiBtYXBwaW5nLm9yaWdpbmFsQ29sdW1uXG4gICAgICAgIH07XG5cbiAgICAgICAgaWYgKG1hcHBpbmcubmFtZSAhPSBudWxsKSB7XG4gICAgICAgICAgbmV3TWFwcGluZy5uYW1lID0gbWFwcGluZy5uYW1lO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGdlbmVyYXRvci5hZGRNYXBwaW5nKG5ld01hcHBpbmcpO1xuICAgIH0pO1xuICAgIGFTb3VyY2VNYXBDb25zdW1lci5zb3VyY2VzLmZvckVhY2goZnVuY3Rpb24gKHNvdXJjZUZpbGUpIHtcbiAgICAgIHZhciBzb3VyY2VSZWxhdGl2ZSA9IHNvdXJjZUZpbGU7XG4gICAgICBpZiAoc291cmNlUm9vdCAhPT0gbnVsbCkge1xuICAgICAgICBzb3VyY2VSZWxhdGl2ZSA9IHV0aWwucmVsYXRpdmUoc291cmNlUm9vdCwgc291cmNlRmlsZSk7XG4gICAgICB9XG5cbiAgICAgIGlmICghZ2VuZXJhdG9yLl9zb3VyY2VzLmhhcyhzb3VyY2VSZWxhdGl2ZSkpIHtcbiAgICAgICAgZ2VuZXJhdG9yLl9zb3VyY2VzLmFkZChzb3VyY2VSZWxhdGl2ZSk7XG4gICAgICB9XG5cbiAgICAgIHZhciBjb250ZW50ID0gYVNvdXJjZU1hcENvbnN1bWVyLnNvdXJjZUNvbnRlbnRGb3Ioc291cmNlRmlsZSk7XG4gICAgICBpZiAoY29udGVudCAhPSBudWxsKSB7XG4gICAgICAgIGdlbmVyYXRvci5zZXRTb3VyY2VDb250ZW50KHNvdXJjZUZpbGUsIGNvbnRlbnQpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBnZW5lcmF0b3I7XG4gIH07XG5cbi8qKlxuICogQWRkIGEgc2luZ2xlIG1hcHBpbmcgZnJvbSBvcmlnaW5hbCBzb3VyY2UgbGluZSBhbmQgY29sdW1uIHRvIHRoZSBnZW5lcmF0ZWRcbiAqIHNvdXJjZSdzIGxpbmUgYW5kIGNvbHVtbiBmb3IgdGhpcyBzb3VyY2UgbWFwIGJlaW5nIGNyZWF0ZWQuIFRoZSBtYXBwaW5nXG4gKiBvYmplY3Qgc2hvdWxkIGhhdmUgdGhlIGZvbGxvd2luZyBwcm9wZXJ0aWVzOlxuICpcbiAqICAgLSBnZW5lcmF0ZWQ6IEFuIG9iamVjdCB3aXRoIHRoZSBnZW5lcmF0ZWQgbGluZSBhbmQgY29sdW1uIHBvc2l0aW9ucy5cbiAqICAgLSBvcmlnaW5hbDogQW4gb2JqZWN0IHdpdGggdGhlIG9yaWdpbmFsIGxpbmUgYW5kIGNvbHVtbiBwb3NpdGlvbnMuXG4gKiAgIC0gc291cmNlOiBUaGUgb3JpZ2luYWwgc291cmNlIGZpbGUgKHJlbGF0aXZlIHRvIHRoZSBzb3VyY2VSb290KS5cbiAqICAgLSBuYW1lOiBBbiBvcHRpb25hbCBvcmlnaW5hbCB0b2tlbiBuYW1lIGZvciB0aGlzIG1hcHBpbmcuXG4gKi9cblNvdXJjZU1hcEdlbmVyYXRvci5wcm90b3R5cGUuYWRkTWFwcGluZyA9XG4gIGZ1bmN0aW9uIFNvdXJjZU1hcEdlbmVyYXRvcl9hZGRNYXBwaW5nKGFBcmdzKSB7XG4gICAgdmFyIGdlbmVyYXRlZCA9IHV0aWwuZ2V0QXJnKGFBcmdzLCAnZ2VuZXJhdGVkJyk7XG4gICAgdmFyIG9yaWdpbmFsID0gdXRpbC5nZXRBcmcoYUFyZ3MsICdvcmlnaW5hbCcsIG51bGwpO1xuICAgIHZhciBzb3VyY2UgPSB1dGlsLmdldEFyZyhhQXJncywgJ3NvdXJjZScsIG51bGwpO1xuICAgIHZhciBuYW1lID0gdXRpbC5nZXRBcmcoYUFyZ3MsICduYW1lJywgbnVsbCk7XG5cbiAgICBpZiAoIXRoaXMuX3NraXBWYWxpZGF0aW9uKSB7XG4gICAgICB0aGlzLl92YWxpZGF0ZU1hcHBpbmcoZ2VuZXJhdGVkLCBvcmlnaW5hbCwgc291cmNlLCBuYW1lKTtcbiAgICB9XG5cbiAgICBpZiAoc291cmNlICE9IG51bGwpIHtcbiAgICAgIHNvdXJjZSA9IFN0cmluZyhzb3VyY2UpO1xuICAgICAgaWYgKCF0aGlzLl9zb3VyY2VzLmhhcyhzb3VyY2UpKSB7XG4gICAgICAgIHRoaXMuX3NvdXJjZXMuYWRkKHNvdXJjZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKG5hbWUgIT0gbnVsbCkge1xuICAgICAgbmFtZSA9IFN0cmluZyhuYW1lKTtcbiAgICAgIGlmICghdGhpcy5fbmFtZXMuaGFzKG5hbWUpKSB7XG4gICAgICAgIHRoaXMuX25hbWVzLmFkZChuYW1lKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLl9tYXBwaW5ncy5hZGQoe1xuICAgICAgZ2VuZXJhdGVkTGluZTogZ2VuZXJhdGVkLmxpbmUsXG4gICAgICBnZW5lcmF0ZWRDb2x1bW46IGdlbmVyYXRlZC5jb2x1bW4sXG4gICAgICBvcmlnaW5hbExpbmU6IG9yaWdpbmFsICE9IG51bGwgJiYgb3JpZ2luYWwubGluZSxcbiAgICAgIG9yaWdpbmFsQ29sdW1uOiBvcmlnaW5hbCAhPSBudWxsICYmIG9yaWdpbmFsLmNvbHVtbixcbiAgICAgIHNvdXJjZTogc291cmNlLFxuICAgICAgbmFtZTogbmFtZVxuICAgIH0pO1xuICB9O1xuXG4vKipcbiAqIFNldCB0aGUgc291cmNlIGNvbnRlbnQgZm9yIGEgc291cmNlIGZpbGUuXG4gKi9cblNvdXJjZU1hcEdlbmVyYXRvci5wcm90b3R5cGUuc2V0U291cmNlQ29udGVudCA9XG4gIGZ1bmN0aW9uIFNvdXJjZU1hcEdlbmVyYXRvcl9zZXRTb3VyY2VDb250ZW50KGFTb3VyY2VGaWxlLCBhU291cmNlQ29udGVudCkge1xuICAgIHZhciBzb3VyY2UgPSBhU291cmNlRmlsZTtcbiAgICBpZiAodGhpcy5fc291cmNlUm9vdCAhPSBudWxsKSB7XG4gICAgICBzb3VyY2UgPSB1dGlsLnJlbGF0aXZlKHRoaXMuX3NvdXJjZVJvb3QsIHNvdXJjZSk7XG4gICAgfVxuXG4gICAgaWYgKGFTb3VyY2VDb250ZW50ICE9IG51bGwpIHtcbiAgICAgIC8vIEFkZCB0aGUgc291cmNlIGNvbnRlbnQgdG8gdGhlIF9zb3VyY2VzQ29udGVudHMgbWFwLlxuICAgICAgLy8gQ3JlYXRlIGEgbmV3IF9zb3VyY2VzQ29udGVudHMgbWFwIGlmIHRoZSBwcm9wZXJ0eSBpcyBudWxsLlxuICAgICAgaWYgKCF0aGlzLl9zb3VyY2VzQ29udGVudHMpIHtcbiAgICAgICAgdGhpcy5fc291cmNlc0NvbnRlbnRzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuX3NvdXJjZXNDb250ZW50c1t1dGlsLnRvU2V0U3RyaW5nKHNvdXJjZSldID0gYVNvdXJjZUNvbnRlbnQ7XG4gICAgfSBlbHNlIGlmICh0aGlzLl9zb3VyY2VzQ29udGVudHMpIHtcbiAgICAgIC8vIFJlbW92ZSB0aGUgc291cmNlIGZpbGUgZnJvbSB0aGUgX3NvdXJjZXNDb250ZW50cyBtYXAuXG4gICAgICAvLyBJZiB0aGUgX3NvdXJjZXNDb250ZW50cyBtYXAgaXMgZW1wdHksIHNldCB0aGUgcHJvcGVydHkgdG8gbnVsbC5cbiAgICAgIGRlbGV0ZSB0aGlzLl9zb3VyY2VzQ29udGVudHNbdXRpbC50b1NldFN0cmluZyhzb3VyY2UpXTtcbiAgICAgIGlmIChPYmplY3Qua2V5cyh0aGlzLl9zb3VyY2VzQ29udGVudHMpLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICB0aGlzLl9zb3VyY2VzQ29udGVudHMgPSBudWxsO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuLyoqXG4gKiBBcHBsaWVzIHRoZSBtYXBwaW5ncyBvZiBhIHN1Yi1zb3VyY2UtbWFwIGZvciBhIHNwZWNpZmljIHNvdXJjZSBmaWxlIHRvIHRoZVxuICogc291cmNlIG1hcCBiZWluZyBnZW5lcmF0ZWQuIEVhY2ggbWFwcGluZyB0byB0aGUgc3VwcGxpZWQgc291cmNlIGZpbGUgaXNcbiAqIHJld3JpdHRlbiB1c2luZyB0aGUgc3VwcGxpZWQgc291cmNlIG1hcC4gTm90ZTogVGhlIHJlc29sdXRpb24gZm9yIHRoZVxuICogcmVzdWx0aW5nIG1hcHBpbmdzIGlzIHRoZSBtaW5pbWl1bSBvZiB0aGlzIG1hcCBhbmQgdGhlIHN1cHBsaWVkIG1hcC5cbiAqXG4gKiBAcGFyYW0gYVNvdXJjZU1hcENvbnN1bWVyIFRoZSBzb3VyY2UgbWFwIHRvIGJlIGFwcGxpZWQuXG4gKiBAcGFyYW0gYVNvdXJjZUZpbGUgT3B0aW9uYWwuIFRoZSBmaWxlbmFtZSBvZiB0aGUgc291cmNlIGZpbGUuXG4gKiAgICAgICAgSWYgb21pdHRlZCwgU291cmNlTWFwQ29uc3VtZXIncyBmaWxlIHByb3BlcnR5IHdpbGwgYmUgdXNlZC5cbiAqIEBwYXJhbSBhU291cmNlTWFwUGF0aCBPcHRpb25hbC4gVGhlIGRpcm5hbWUgb2YgdGhlIHBhdGggdG8gdGhlIHNvdXJjZSBtYXBcbiAqICAgICAgICB0byBiZSBhcHBsaWVkLiBJZiByZWxhdGl2ZSwgaXQgaXMgcmVsYXRpdmUgdG8gdGhlIFNvdXJjZU1hcENvbnN1bWVyLlxuICogICAgICAgIFRoaXMgcGFyYW1ldGVyIGlzIG5lZWRlZCB3aGVuIHRoZSB0d28gc291cmNlIG1hcHMgYXJlbid0IGluIHRoZSBzYW1lXG4gKiAgICAgICAgZGlyZWN0b3J5LCBhbmQgdGhlIHNvdXJjZSBtYXAgdG8gYmUgYXBwbGllZCBjb250YWlucyByZWxhdGl2ZSBzb3VyY2VcbiAqICAgICAgICBwYXRocy4gSWYgc28sIHRob3NlIHJlbGF0aXZlIHNvdXJjZSBwYXRocyBuZWVkIHRvIGJlIHJld3JpdHRlblxuICogICAgICAgIHJlbGF0aXZlIHRvIHRoZSBTb3VyY2VNYXBHZW5lcmF0b3IuXG4gKi9cblNvdXJjZU1hcEdlbmVyYXRvci5wcm90b3R5cGUuYXBwbHlTb3VyY2VNYXAgPVxuICBmdW5jdGlvbiBTb3VyY2VNYXBHZW5lcmF0b3JfYXBwbHlTb3VyY2VNYXAoYVNvdXJjZU1hcENvbnN1bWVyLCBhU291cmNlRmlsZSwgYVNvdXJjZU1hcFBhdGgpIHtcbiAgICB2YXIgc291cmNlRmlsZSA9IGFTb3VyY2VGaWxlO1xuICAgIC8vIElmIGFTb3VyY2VGaWxlIGlzIG9taXR0ZWQsIHdlIHdpbGwgdXNlIHRoZSBmaWxlIHByb3BlcnR5IG9mIHRoZSBTb3VyY2VNYXBcbiAgICBpZiAoYVNvdXJjZUZpbGUgPT0gbnVsbCkge1xuICAgICAgaWYgKGFTb3VyY2VNYXBDb25zdW1lci5maWxlID09IG51bGwpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICdTb3VyY2VNYXBHZW5lcmF0b3IucHJvdG90eXBlLmFwcGx5U291cmNlTWFwIHJlcXVpcmVzIGVpdGhlciBhbiBleHBsaWNpdCBzb3VyY2UgZmlsZSwgJyArXG4gICAgICAgICAgJ29yIHRoZSBzb3VyY2UgbWFwXFwncyBcImZpbGVcIiBwcm9wZXJ0eS4gQm90aCB3ZXJlIG9taXR0ZWQuJ1xuICAgICAgICApO1xuICAgICAgfVxuICAgICAgc291cmNlRmlsZSA9IGFTb3VyY2VNYXBDb25zdW1lci5maWxlO1xuICAgIH1cbiAgICB2YXIgc291cmNlUm9vdCA9IHRoaXMuX3NvdXJjZVJvb3Q7XG4gICAgLy8gTWFrZSBcInNvdXJjZUZpbGVcIiByZWxhdGl2ZSBpZiBhbiBhYnNvbHV0ZSBVcmwgaXMgcGFzc2VkLlxuICAgIGlmIChzb3VyY2VSb290ICE9IG51bGwpIHtcbiAgICAgIHNvdXJjZUZpbGUgPSB1dGlsLnJlbGF0aXZlKHNvdXJjZVJvb3QsIHNvdXJjZUZpbGUpO1xuICAgIH1cbiAgICAvLyBBcHBseWluZyB0aGUgU291cmNlTWFwIGNhbiBhZGQgYW5kIHJlbW92ZSBpdGVtcyBmcm9tIHRoZSBzb3VyY2VzIGFuZFxuICAgIC8vIHRoZSBuYW1lcyBhcnJheS5cbiAgICB2YXIgbmV3U291cmNlcyA9IG5ldyBBcnJheVNldCgpO1xuICAgIHZhciBuZXdOYW1lcyA9IG5ldyBBcnJheVNldCgpO1xuXG4gICAgLy8gRmluZCBtYXBwaW5ncyBmb3IgdGhlIFwic291cmNlRmlsZVwiXG4gICAgdGhpcy5fbWFwcGluZ3MudW5zb3J0ZWRGb3JFYWNoKGZ1bmN0aW9uIChtYXBwaW5nKSB7XG4gICAgICBpZiAobWFwcGluZy5zb3VyY2UgPT09IHNvdXJjZUZpbGUgJiYgbWFwcGluZy5vcmlnaW5hbExpbmUgIT0gbnVsbCkge1xuICAgICAgICAvLyBDaGVjayBpZiBpdCBjYW4gYmUgbWFwcGVkIGJ5IHRoZSBzb3VyY2UgbWFwLCB0aGVuIHVwZGF0ZSB0aGUgbWFwcGluZy5cbiAgICAgICAgdmFyIG9yaWdpbmFsID0gYVNvdXJjZU1hcENvbnN1bWVyLm9yaWdpbmFsUG9zaXRpb25Gb3Ioe1xuICAgICAgICAgIGxpbmU6IG1hcHBpbmcub3JpZ2luYWxMaW5lLFxuICAgICAgICAgIGNvbHVtbjogbWFwcGluZy5vcmlnaW5hbENvbHVtblxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKG9yaWdpbmFsLnNvdXJjZSAhPSBudWxsKSB7XG4gICAgICAgICAgLy8gQ29weSBtYXBwaW5nXG4gICAgICAgICAgbWFwcGluZy5zb3VyY2UgPSBvcmlnaW5hbC5zb3VyY2U7XG4gICAgICAgICAgaWYgKGFTb3VyY2VNYXBQYXRoICE9IG51bGwpIHtcbiAgICAgICAgICAgIG1hcHBpbmcuc291cmNlID0gdXRpbC5qb2luKGFTb3VyY2VNYXBQYXRoLCBtYXBwaW5nLnNvdXJjZSlcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHNvdXJjZVJvb3QgIT0gbnVsbCkge1xuICAgICAgICAgICAgbWFwcGluZy5zb3VyY2UgPSB1dGlsLnJlbGF0aXZlKHNvdXJjZVJvb3QsIG1hcHBpbmcuc291cmNlKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgbWFwcGluZy5vcmlnaW5hbExpbmUgPSBvcmlnaW5hbC5saW5lO1xuICAgICAgICAgIG1hcHBpbmcub3JpZ2luYWxDb2x1bW4gPSBvcmlnaW5hbC5jb2x1bW47XG4gICAgICAgICAgaWYgKG9yaWdpbmFsLm5hbWUgIT0gbnVsbCkge1xuICAgICAgICAgICAgbWFwcGluZy5uYW1lID0gb3JpZ2luYWwubmFtZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdmFyIHNvdXJjZSA9IG1hcHBpbmcuc291cmNlO1xuICAgICAgaWYgKHNvdXJjZSAhPSBudWxsICYmICFuZXdTb3VyY2VzLmhhcyhzb3VyY2UpKSB7XG4gICAgICAgIG5ld1NvdXJjZXMuYWRkKHNvdXJjZSk7XG4gICAgICB9XG5cbiAgICAgIHZhciBuYW1lID0gbWFwcGluZy5uYW1lO1xuICAgICAgaWYgKG5hbWUgIT0gbnVsbCAmJiAhbmV3TmFtZXMuaGFzKG5hbWUpKSB7XG4gICAgICAgIG5ld05hbWVzLmFkZChuYW1lKTtcbiAgICAgIH1cblxuICAgIH0sIHRoaXMpO1xuICAgIHRoaXMuX3NvdXJjZXMgPSBuZXdTb3VyY2VzO1xuICAgIHRoaXMuX25hbWVzID0gbmV3TmFtZXM7XG5cbiAgICAvLyBDb3B5IHNvdXJjZXNDb250ZW50cyBvZiBhcHBsaWVkIG1hcC5cbiAgICBhU291cmNlTWFwQ29uc3VtZXIuc291cmNlcy5mb3JFYWNoKGZ1bmN0aW9uIChzb3VyY2VGaWxlKSB7XG4gICAgICB2YXIgY29udGVudCA9IGFTb3VyY2VNYXBDb25zdW1lci5zb3VyY2VDb250ZW50Rm9yKHNvdXJjZUZpbGUpO1xuICAgICAgaWYgKGNvbnRlbnQgIT0gbnVsbCkge1xuICAgICAgICBpZiAoYVNvdXJjZU1hcFBhdGggIT0gbnVsbCkge1xuICAgICAgICAgIHNvdXJjZUZpbGUgPSB1dGlsLmpvaW4oYVNvdXJjZU1hcFBhdGgsIHNvdXJjZUZpbGUpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzb3VyY2VSb290ICE9IG51bGwpIHtcbiAgICAgICAgICBzb3VyY2VGaWxlID0gdXRpbC5yZWxhdGl2ZShzb3VyY2VSb290LCBzb3VyY2VGaWxlKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnNldFNvdXJjZUNvbnRlbnQoc291cmNlRmlsZSwgY29udGVudCk7XG4gICAgICB9XG4gICAgfSwgdGhpcyk7XG4gIH07XG5cbi8qKlxuICogQSBtYXBwaW5nIGNhbiBoYXZlIG9uZSBvZiB0aGUgdGhyZWUgbGV2ZWxzIG9mIGRhdGE6XG4gKlxuICogICAxLiBKdXN0IHRoZSBnZW5lcmF0ZWQgcG9zaXRpb24uXG4gKiAgIDIuIFRoZSBHZW5lcmF0ZWQgcG9zaXRpb24sIG9yaWdpbmFsIHBvc2l0aW9uLCBhbmQgb3JpZ2luYWwgc291cmNlLlxuICogICAzLiBHZW5lcmF0ZWQgYW5kIG9yaWdpbmFsIHBvc2l0aW9uLCBvcmlnaW5hbCBzb3VyY2UsIGFzIHdlbGwgYXMgYSBuYW1lXG4gKiAgICAgIHRva2VuLlxuICpcbiAqIFRvIG1haW50YWluIGNvbnNpc3RlbmN5LCB3ZSB2YWxpZGF0ZSB0aGF0IGFueSBuZXcgbWFwcGluZyBiZWluZyBhZGRlZCBmYWxsc1xuICogaW4gdG8gb25lIG9mIHRoZXNlIGNhdGVnb3JpZXMuXG4gKi9cblNvdXJjZU1hcEdlbmVyYXRvci5wcm90b3R5cGUuX3ZhbGlkYXRlTWFwcGluZyA9XG4gIGZ1bmN0aW9uIFNvdXJjZU1hcEdlbmVyYXRvcl92YWxpZGF0ZU1hcHBpbmcoYUdlbmVyYXRlZCwgYU9yaWdpbmFsLCBhU291cmNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFOYW1lKSB7XG4gICAgLy8gV2hlbiBhT3JpZ2luYWwgaXMgdHJ1dGh5IGJ1dCBoYXMgZW1wdHkgdmFsdWVzIGZvciAubGluZSBhbmQgLmNvbHVtbixcbiAgICAvLyBpdCBpcyBtb3N0IGxpa2VseSBhIHByb2dyYW1tZXIgZXJyb3IuIEluIHRoaXMgY2FzZSB3ZSB0aHJvdyBhIHZlcnlcbiAgICAvLyBzcGVjaWZpYyBlcnJvciBtZXNzYWdlIHRvIHRyeSB0byBndWlkZSB0aGVtIHRoZSByaWdodCB3YXkuXG4gICAgLy8gRm9yIGV4YW1wbGU6IGh0dHBzOi8vZ2l0aHViLmNvbS9Qb2x5bWVyL3BvbHltZXItYnVuZGxlci9wdWxsLzUxOVxuICAgIGlmIChhT3JpZ2luYWwgJiYgdHlwZW9mIGFPcmlnaW5hbC5saW5lICE9PSAnbnVtYmVyJyAmJiB0eXBlb2YgYU9yaWdpbmFsLmNvbHVtbiAhPT0gJ251bWJlcicpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICAgJ29yaWdpbmFsLmxpbmUgYW5kIG9yaWdpbmFsLmNvbHVtbiBhcmUgbm90IG51bWJlcnMgLS0geW91IHByb2JhYmx5IG1lYW50IHRvIG9taXQgJyArXG4gICAgICAgICAgICAndGhlIG9yaWdpbmFsIG1hcHBpbmcgZW50aXJlbHkgYW5kIG9ubHkgbWFwIHRoZSBnZW5lcmF0ZWQgcG9zaXRpb24uIElmIHNvLCBwYXNzICcgK1xuICAgICAgICAgICAgJ251bGwgZm9yIHRoZSBvcmlnaW5hbCBtYXBwaW5nIGluc3RlYWQgb2YgYW4gb2JqZWN0IHdpdGggZW1wdHkgb3IgbnVsbCB2YWx1ZXMuJ1xuICAgICAgICApO1xuICAgIH1cblxuICAgIGlmIChhR2VuZXJhdGVkICYmICdsaW5lJyBpbiBhR2VuZXJhdGVkICYmICdjb2x1bW4nIGluIGFHZW5lcmF0ZWRcbiAgICAgICAgJiYgYUdlbmVyYXRlZC5saW5lID4gMCAmJiBhR2VuZXJhdGVkLmNvbHVtbiA+PSAwXG4gICAgICAgICYmICFhT3JpZ2luYWwgJiYgIWFTb3VyY2UgJiYgIWFOYW1lKSB7XG4gICAgICAvLyBDYXNlIDEuXG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGVsc2UgaWYgKGFHZW5lcmF0ZWQgJiYgJ2xpbmUnIGluIGFHZW5lcmF0ZWQgJiYgJ2NvbHVtbicgaW4gYUdlbmVyYXRlZFxuICAgICAgICAgICAgICYmIGFPcmlnaW5hbCAmJiAnbGluZScgaW4gYU9yaWdpbmFsICYmICdjb2x1bW4nIGluIGFPcmlnaW5hbFxuICAgICAgICAgICAgICYmIGFHZW5lcmF0ZWQubGluZSA+IDAgJiYgYUdlbmVyYXRlZC5jb2x1bW4gPj0gMFxuICAgICAgICAgICAgICYmIGFPcmlnaW5hbC5saW5lID4gMCAmJiBhT3JpZ2luYWwuY29sdW1uID49IDBcbiAgICAgICAgICAgICAmJiBhU291cmNlKSB7XG4gICAgICAvLyBDYXNlcyAyIGFuZCAzLlxuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBtYXBwaW5nOiAnICsgSlNPTi5zdHJpbmdpZnkoe1xuICAgICAgICBnZW5lcmF0ZWQ6IGFHZW5lcmF0ZWQsXG4gICAgICAgIHNvdXJjZTogYVNvdXJjZSxcbiAgICAgICAgb3JpZ2luYWw6IGFPcmlnaW5hbCxcbiAgICAgICAgbmFtZTogYU5hbWVcbiAgICAgIH0pKTtcbiAgICB9XG4gIH07XG5cbi8qKlxuICogU2VyaWFsaXplIHRoZSBhY2N1bXVsYXRlZCBtYXBwaW5ncyBpbiB0byB0aGUgc3RyZWFtIG9mIGJhc2UgNjQgVkxRc1xuICogc3BlY2lmaWVkIGJ5IHRoZSBzb3VyY2UgbWFwIGZvcm1hdC5cbiAqL1xuU291cmNlTWFwR2VuZXJhdG9yLnByb3RvdHlwZS5fc2VyaWFsaXplTWFwcGluZ3MgPVxuICBmdW5jdGlvbiBTb3VyY2VNYXBHZW5lcmF0b3Jfc2VyaWFsaXplTWFwcGluZ3MoKSB7XG4gICAgdmFyIHByZXZpb3VzR2VuZXJhdGVkQ29sdW1uID0gMDtcbiAgICB2YXIgcHJldmlvdXNHZW5lcmF0ZWRMaW5lID0gMTtcbiAgICB2YXIgcHJldmlvdXNPcmlnaW5hbENvbHVtbiA9IDA7XG4gICAgdmFyIHByZXZpb3VzT3JpZ2luYWxMaW5lID0gMDtcbiAgICB2YXIgcHJldmlvdXNOYW1lID0gMDtcbiAgICB2YXIgcHJldmlvdXNTb3VyY2UgPSAwO1xuICAgIHZhciByZXN1bHQgPSAnJztcbiAgICB2YXIgbmV4dDtcbiAgICB2YXIgbWFwcGluZztcbiAgICB2YXIgbmFtZUlkeDtcbiAgICB2YXIgc291cmNlSWR4O1xuXG4gICAgdmFyIG1hcHBpbmdzID0gdGhpcy5fbWFwcGluZ3MudG9BcnJheSgpO1xuICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBtYXBwaW5ncy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgbWFwcGluZyA9IG1hcHBpbmdzW2ldO1xuICAgICAgbmV4dCA9ICcnXG5cbiAgICAgIGlmIChtYXBwaW5nLmdlbmVyYXRlZExpbmUgIT09IHByZXZpb3VzR2VuZXJhdGVkTGluZSkge1xuICAgICAgICBwcmV2aW91c0dlbmVyYXRlZENvbHVtbiA9IDA7XG4gICAgICAgIHdoaWxlIChtYXBwaW5nLmdlbmVyYXRlZExpbmUgIT09IHByZXZpb3VzR2VuZXJhdGVkTGluZSkge1xuICAgICAgICAgIG5leHQgKz0gJzsnO1xuICAgICAgICAgIHByZXZpb3VzR2VuZXJhdGVkTGluZSsrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgaWYgKGkgPiAwKSB7XG4gICAgICAgICAgaWYgKCF1dGlsLmNvbXBhcmVCeUdlbmVyYXRlZFBvc2l0aW9uc0luZmxhdGVkKG1hcHBpbmcsIG1hcHBpbmdzW2kgLSAxXSkpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBuZXh0ICs9ICcsJztcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBuZXh0ICs9IGJhc2U2NFZMUS5lbmNvZGUobWFwcGluZy5nZW5lcmF0ZWRDb2x1bW5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC0gcHJldmlvdXNHZW5lcmF0ZWRDb2x1bW4pO1xuICAgICAgcHJldmlvdXNHZW5lcmF0ZWRDb2x1bW4gPSBtYXBwaW5nLmdlbmVyYXRlZENvbHVtbjtcblxuICAgICAgaWYgKG1hcHBpbmcuc291cmNlICE9IG51bGwpIHtcbiAgICAgICAgc291cmNlSWR4ID0gdGhpcy5fc291cmNlcy5pbmRleE9mKG1hcHBpbmcuc291cmNlKTtcbiAgICAgICAgbmV4dCArPSBiYXNlNjRWTFEuZW5jb2RlKHNvdXJjZUlkeCAtIHByZXZpb3VzU291cmNlKTtcbiAgICAgICAgcHJldmlvdXNTb3VyY2UgPSBzb3VyY2VJZHg7XG5cbiAgICAgICAgLy8gbGluZXMgYXJlIHN0b3JlZCAwLWJhc2VkIGluIFNvdXJjZU1hcCBzcGVjIHZlcnNpb24gM1xuICAgICAgICBuZXh0ICs9IGJhc2U2NFZMUS5lbmNvZGUobWFwcGluZy5vcmlnaW5hbExpbmUgLSAxXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC0gcHJldmlvdXNPcmlnaW5hbExpbmUpO1xuICAgICAgICBwcmV2aW91c09yaWdpbmFsTGluZSA9IG1hcHBpbmcub3JpZ2luYWxMaW5lIC0gMTtcblxuICAgICAgICBuZXh0ICs9IGJhc2U2NFZMUS5lbmNvZGUobWFwcGluZy5vcmlnaW5hbENvbHVtblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAtIHByZXZpb3VzT3JpZ2luYWxDb2x1bW4pO1xuICAgICAgICBwcmV2aW91c09yaWdpbmFsQ29sdW1uID0gbWFwcGluZy5vcmlnaW5hbENvbHVtbjtcblxuICAgICAgICBpZiAobWFwcGluZy5uYW1lICE9IG51bGwpIHtcbiAgICAgICAgICBuYW1lSWR4ID0gdGhpcy5fbmFtZXMuaW5kZXhPZihtYXBwaW5nLm5hbWUpO1xuICAgICAgICAgIG5leHQgKz0gYmFzZTY0VkxRLmVuY29kZShuYW1lSWR4IC0gcHJldmlvdXNOYW1lKTtcbiAgICAgICAgICBwcmV2aW91c05hbWUgPSBuYW1lSWR4O1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJlc3VsdCArPSBuZXh0O1xuICAgIH1cblxuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG5cblNvdXJjZU1hcEdlbmVyYXRvci5wcm90b3R5cGUuX2dlbmVyYXRlU291cmNlc0NvbnRlbnQgPVxuICBmdW5jdGlvbiBTb3VyY2VNYXBHZW5lcmF0b3JfZ2VuZXJhdGVTb3VyY2VzQ29udGVudChhU291cmNlcywgYVNvdXJjZVJvb3QpIHtcbiAgICByZXR1cm4gYVNvdXJjZXMubWFwKGZ1bmN0aW9uIChzb3VyY2UpIHtcbiAgICAgIGlmICghdGhpcy5fc291cmNlc0NvbnRlbnRzKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgICAgaWYgKGFTb3VyY2VSb290ICE9IG51bGwpIHtcbiAgICAgICAgc291cmNlID0gdXRpbC5yZWxhdGl2ZShhU291cmNlUm9vdCwgc291cmNlKTtcbiAgICAgIH1cbiAgICAgIHZhciBrZXkgPSB1dGlsLnRvU2V0U3RyaW5nKHNvdXJjZSk7XG4gICAgICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHRoaXMuX3NvdXJjZXNDb250ZW50cywga2V5KVxuICAgICAgICA/IHRoaXMuX3NvdXJjZXNDb250ZW50c1trZXldXG4gICAgICAgIDogbnVsbDtcbiAgICB9LCB0aGlzKTtcbiAgfTtcblxuLyoqXG4gKiBFeHRlcm5hbGl6ZSB0aGUgc291cmNlIG1hcC5cbiAqL1xuU291cmNlTWFwR2VuZXJhdG9yLnByb3RvdHlwZS50b0pTT04gPVxuICBmdW5jdGlvbiBTb3VyY2VNYXBHZW5lcmF0b3JfdG9KU09OKCkge1xuICAgIHZhciBtYXAgPSB7XG4gICAgICB2ZXJzaW9uOiB0aGlzLl92ZXJzaW9uLFxuICAgICAgc291cmNlczogdGhpcy5fc291cmNlcy50b0FycmF5KCksXG4gICAgICBuYW1lczogdGhpcy5fbmFtZXMudG9BcnJheSgpLFxuICAgICAgbWFwcGluZ3M6IHRoaXMuX3NlcmlhbGl6ZU1hcHBpbmdzKClcbiAgICB9O1xuICAgIGlmICh0aGlzLl9maWxlICE9IG51bGwpIHtcbiAgICAgIG1hcC5maWxlID0gdGhpcy5fZmlsZTtcbiAgICB9XG4gICAgaWYgKHRoaXMuX3NvdXJjZVJvb3QgIT0gbnVsbCkge1xuICAgICAgbWFwLnNvdXJjZVJvb3QgPSB0aGlzLl9zb3VyY2VSb290O1xuICAgIH1cbiAgICBpZiAodGhpcy5fc291cmNlc0NvbnRlbnRzKSB7XG4gICAgICBtYXAuc291cmNlc0NvbnRlbnQgPSB0aGlzLl9nZW5lcmF0ZVNvdXJjZXNDb250ZW50KG1hcC5zb3VyY2VzLCBtYXAuc291cmNlUm9vdCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG1hcDtcbiAgfTtcblxuLyoqXG4gKiBSZW5kZXIgdGhlIHNvdXJjZSBtYXAgYmVpbmcgZ2VuZXJhdGVkIHRvIGEgc3RyaW5nLlxuICovXG5Tb3VyY2VNYXBHZW5lcmF0b3IucHJvdG90eXBlLnRvU3RyaW5nID1cbiAgZnVuY3Rpb24gU291cmNlTWFwR2VuZXJhdG9yX3RvU3RyaW5nKCkge1xuICAgIHJldHVybiBKU09OLnN0cmluZ2lmeSh0aGlzLnRvSlNPTigpKTtcbiAgfTtcblxuZXhwb3J0cy5Tb3VyY2VNYXBHZW5lcmF0b3IgPSBTb3VyY2VNYXBHZW5lcmF0b3I7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvZWxlY3Ryb24tdXBkYXRlci9ub2RlX21vZHVsZXMvc291cmNlLW1hcC9saWIvc291cmNlLW1hcC1nZW5lcmF0b3IuanMiLCIvKiAtKi0gTW9kZToganM7IGpzLWluZGVudC1sZXZlbDogMjsgLSotICovXG4vKlxuICogQ29weXJpZ2h0IDIwMTEgTW96aWxsYSBGb3VuZGF0aW9uIGFuZCBjb250cmlidXRvcnNcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBOZXcgQlNEIGxpY2Vuc2UuIFNlZSBMSUNFTlNFIG9yOlxuICogaHR0cDovL29wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL0JTRC0zLUNsYXVzZVxuICpcbiAqIEJhc2VkIG9uIHRoZSBCYXNlIDY0IFZMUSBpbXBsZW1lbnRhdGlvbiBpbiBDbG9zdXJlIENvbXBpbGVyOlxuICogaHR0cHM6Ly9jb2RlLmdvb2dsZS5jb20vcC9jbG9zdXJlLWNvbXBpbGVyL3NvdXJjZS9icm93c2UvdHJ1bmsvc3JjL2NvbS9nb29nbGUvZGVidWdnaW5nL3NvdXJjZW1hcC9CYXNlNjRWTFEuamF2YVxuICpcbiAqIENvcHlyaWdodCAyMDExIFRoZSBDbG9zdXJlIENvbXBpbGVyIEF1dGhvcnMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBSZWRpc3RyaWJ1dGlvbiBhbmQgdXNlIGluIHNvdXJjZSBhbmQgYmluYXJ5IGZvcm1zLCB3aXRoIG9yIHdpdGhvdXRcbiAqIG1vZGlmaWNhdGlvbiwgYXJlIHBlcm1pdHRlZCBwcm92aWRlZCB0aGF0IHRoZSBmb2xsb3dpbmcgY29uZGl0aW9ucyBhcmVcbiAqIG1ldDpcbiAqXG4gKiAgKiBSZWRpc3RyaWJ1dGlvbnMgb2Ygc291cmNlIGNvZGUgbXVzdCByZXRhaW4gdGhlIGFib3ZlIGNvcHlyaWdodFxuICogICAgbm90aWNlLCB0aGlzIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZyBkaXNjbGFpbWVyLlxuICogICogUmVkaXN0cmlidXRpb25zIGluIGJpbmFyeSBmb3JtIG11c3QgcmVwcm9kdWNlIHRoZSBhYm92ZVxuICogICAgY29weXJpZ2h0IG5vdGljZSwgdGhpcyBsaXN0IG9mIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmdcbiAqICAgIGRpc2NsYWltZXIgaW4gdGhlIGRvY3VtZW50YXRpb24gYW5kL29yIG90aGVyIG1hdGVyaWFscyBwcm92aWRlZFxuICogICAgd2l0aCB0aGUgZGlzdHJpYnV0aW9uLlxuICogICogTmVpdGhlciB0aGUgbmFtZSBvZiBHb29nbGUgSW5jLiBub3IgdGhlIG5hbWVzIG9mIGl0c1xuICogICAgY29udHJpYnV0b3JzIG1heSBiZSB1c2VkIHRvIGVuZG9yc2Ugb3IgcHJvbW90ZSBwcm9kdWN0cyBkZXJpdmVkXG4gKiAgICBmcm9tIHRoaXMgc29mdHdhcmUgd2l0aG91dCBzcGVjaWZpYyBwcmlvciB3cml0dGVuIHBlcm1pc3Npb24uXG4gKlxuICogVEhJUyBTT0ZUV0FSRSBJUyBQUk9WSURFRCBCWSBUSEUgQ09QWVJJR0hUIEhPTERFUlMgQU5EIENPTlRSSUJVVE9SU1xuICogXCJBUyBJU1wiIEFORCBBTlkgRVhQUkVTUyBPUiBJTVBMSUVEIFdBUlJBTlRJRVMsIElOQ0xVRElORywgQlVUIE5PVFxuICogTElNSVRFRCBUTywgVEhFIElNUExJRUQgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFkgQU5EIEZJVE5FU1MgRk9SXG4gKiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBUkUgRElTQ0xBSU1FRC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIENPUFlSSUdIVFxuICogT1dORVIgT1IgQ09OVFJJQlVUT1JTIEJFIExJQUJMRSBGT1IgQU5ZIERJUkVDVCwgSU5ESVJFQ1QsIElOQ0lERU5UQUwsXG4gKiBTUEVDSUFMLCBFWEVNUExBUlksIE9SIENPTlNFUVVFTlRJQUwgREFNQUdFUyAoSU5DTFVESU5HLCBCVVQgTk9UXG4gKiBMSU1JVEVEIFRPLCBQUk9DVVJFTUVOVCBPRiBTVUJTVElUVVRFIEdPT0RTIE9SIFNFUlZJQ0VTOyBMT1NTIE9GIFVTRSxcbiAqIERBVEEsIE9SIFBST0ZJVFM7IE9SIEJVU0lORVNTIElOVEVSUlVQVElPTikgSE9XRVZFUiBDQVVTRUQgQU5EIE9OIEFOWVxuICogVEhFT1JZIE9GIExJQUJJTElUWSwgV0hFVEhFUiBJTiBDT05UUkFDVCwgU1RSSUNUIExJQUJJTElUWSwgT1IgVE9SVFxuICogKElOQ0xVRElORyBORUdMSUdFTkNFIE9SIE9USEVSV0lTRSkgQVJJU0lORyBJTiBBTlkgV0FZIE9VVCBPRiBUSEUgVVNFXG4gKiBPRiBUSElTIFNPRlRXQVJFLCBFVkVOIElGIEFEVklTRUQgT0YgVEhFIFBPU1NJQklMSVRZIE9GIFNVQ0ggREFNQUdFLlxuICovXG5cbnZhciBiYXNlNjQgPSByZXF1aXJlKCcuL2Jhc2U2NCcpO1xuXG4vLyBBIHNpbmdsZSBiYXNlIDY0IGRpZ2l0IGNhbiBjb250YWluIDYgYml0cyBvZiBkYXRhLiBGb3IgdGhlIGJhc2UgNjQgdmFyaWFibGVcbi8vIGxlbmd0aCBxdWFudGl0aWVzIHdlIHVzZSBpbiB0aGUgc291cmNlIG1hcCBzcGVjLCB0aGUgZmlyc3QgYml0IGlzIHRoZSBzaWduLFxuLy8gdGhlIG5leHQgZm91ciBiaXRzIGFyZSB0aGUgYWN0dWFsIHZhbHVlLCBhbmQgdGhlIDZ0aCBiaXQgaXMgdGhlXG4vLyBjb250aW51YXRpb24gYml0LiBUaGUgY29udGludWF0aW9uIGJpdCB0ZWxscyB1cyB3aGV0aGVyIHRoZXJlIGFyZSBtb3JlXG4vLyBkaWdpdHMgaW4gdGhpcyB2YWx1ZSBmb2xsb3dpbmcgdGhpcyBkaWdpdC5cbi8vXG4vLyAgIENvbnRpbnVhdGlvblxuLy8gICB8ICAgIFNpZ25cbi8vICAgfCAgICB8XG4vLyAgIFYgICAgVlxuLy8gICAxMDEwMTFcblxudmFyIFZMUV9CQVNFX1NISUZUID0gNTtcblxuLy8gYmluYXJ5OiAxMDAwMDBcbnZhciBWTFFfQkFTRSA9IDEgPDwgVkxRX0JBU0VfU0hJRlQ7XG5cbi8vIGJpbmFyeTogMDExMTExXG52YXIgVkxRX0JBU0VfTUFTSyA9IFZMUV9CQVNFIC0gMTtcblxuLy8gYmluYXJ5OiAxMDAwMDBcbnZhciBWTFFfQ09OVElOVUFUSU9OX0JJVCA9IFZMUV9CQVNFO1xuXG4vKipcbiAqIENvbnZlcnRzIGZyb20gYSB0d28tY29tcGxlbWVudCB2YWx1ZSB0byBhIHZhbHVlIHdoZXJlIHRoZSBzaWduIGJpdCBpc1xuICogcGxhY2VkIGluIHRoZSBsZWFzdCBzaWduaWZpY2FudCBiaXQuICBGb3IgZXhhbXBsZSwgYXMgZGVjaW1hbHM6XG4gKiAgIDEgYmVjb21lcyAyICgxMCBiaW5hcnkpLCAtMSBiZWNvbWVzIDMgKDExIGJpbmFyeSlcbiAqICAgMiBiZWNvbWVzIDQgKDEwMCBiaW5hcnkpLCAtMiBiZWNvbWVzIDUgKDEwMSBiaW5hcnkpXG4gKi9cbmZ1bmN0aW9uIHRvVkxRU2lnbmVkKGFWYWx1ZSkge1xuICByZXR1cm4gYVZhbHVlIDwgMFxuICAgID8gKCgtYVZhbHVlKSA8PCAxKSArIDFcbiAgICA6IChhVmFsdWUgPDwgMSkgKyAwO1xufVxuXG4vKipcbiAqIENvbnZlcnRzIHRvIGEgdHdvLWNvbXBsZW1lbnQgdmFsdWUgZnJvbSBhIHZhbHVlIHdoZXJlIHRoZSBzaWduIGJpdCBpc1xuICogcGxhY2VkIGluIHRoZSBsZWFzdCBzaWduaWZpY2FudCBiaXQuICBGb3IgZXhhbXBsZSwgYXMgZGVjaW1hbHM6XG4gKiAgIDIgKDEwIGJpbmFyeSkgYmVjb21lcyAxLCAzICgxMSBiaW5hcnkpIGJlY29tZXMgLTFcbiAqICAgNCAoMTAwIGJpbmFyeSkgYmVjb21lcyAyLCA1ICgxMDEgYmluYXJ5KSBiZWNvbWVzIC0yXG4gKi9cbmZ1bmN0aW9uIGZyb21WTFFTaWduZWQoYVZhbHVlKSB7XG4gIHZhciBpc05lZ2F0aXZlID0gKGFWYWx1ZSAmIDEpID09PSAxO1xuICB2YXIgc2hpZnRlZCA9IGFWYWx1ZSA+PiAxO1xuICByZXR1cm4gaXNOZWdhdGl2ZVxuICAgID8gLXNoaWZ0ZWRcbiAgICA6IHNoaWZ0ZWQ7XG59XG5cbi8qKlxuICogUmV0dXJucyB0aGUgYmFzZSA2NCBWTFEgZW5jb2RlZCB2YWx1ZS5cbiAqL1xuZXhwb3J0cy5lbmNvZGUgPSBmdW5jdGlvbiBiYXNlNjRWTFFfZW5jb2RlKGFWYWx1ZSkge1xuICB2YXIgZW5jb2RlZCA9IFwiXCI7XG4gIHZhciBkaWdpdDtcblxuICB2YXIgdmxxID0gdG9WTFFTaWduZWQoYVZhbHVlKTtcblxuICBkbyB7XG4gICAgZGlnaXQgPSB2bHEgJiBWTFFfQkFTRV9NQVNLO1xuICAgIHZscSA+Pj49IFZMUV9CQVNFX1NISUZUO1xuICAgIGlmICh2bHEgPiAwKSB7XG4gICAgICAvLyBUaGVyZSBhcmUgc3RpbGwgbW9yZSBkaWdpdHMgaW4gdGhpcyB2YWx1ZSwgc28gd2UgbXVzdCBtYWtlIHN1cmUgdGhlXG4gICAgICAvLyBjb250aW51YXRpb24gYml0IGlzIG1hcmtlZC5cbiAgICAgIGRpZ2l0IHw9IFZMUV9DT05USU5VQVRJT05fQklUO1xuICAgIH1cbiAgICBlbmNvZGVkICs9IGJhc2U2NC5lbmNvZGUoZGlnaXQpO1xuICB9IHdoaWxlICh2bHEgPiAwKTtcblxuICByZXR1cm4gZW5jb2RlZDtcbn07XG5cbi8qKlxuICogRGVjb2RlcyB0aGUgbmV4dCBiYXNlIDY0IFZMUSB2YWx1ZSBmcm9tIHRoZSBnaXZlbiBzdHJpbmcgYW5kIHJldHVybnMgdGhlXG4gKiB2YWx1ZSBhbmQgdGhlIHJlc3Qgb2YgdGhlIHN0cmluZyB2aWEgdGhlIG91dCBwYXJhbWV0ZXIuXG4gKi9cbmV4cG9ydHMuZGVjb2RlID0gZnVuY3Rpb24gYmFzZTY0VkxRX2RlY29kZShhU3RyLCBhSW5kZXgsIGFPdXRQYXJhbSkge1xuICB2YXIgc3RyTGVuID0gYVN0ci5sZW5ndGg7XG4gIHZhciByZXN1bHQgPSAwO1xuICB2YXIgc2hpZnQgPSAwO1xuICB2YXIgY29udGludWF0aW9uLCBkaWdpdDtcblxuICBkbyB7XG4gICAgaWYgKGFJbmRleCA+PSBzdHJMZW4pIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkV4cGVjdGVkIG1vcmUgZGlnaXRzIGluIGJhc2UgNjQgVkxRIHZhbHVlLlwiKTtcbiAgICB9XG5cbiAgICBkaWdpdCA9IGJhc2U2NC5kZWNvZGUoYVN0ci5jaGFyQ29kZUF0KGFJbmRleCsrKSk7XG4gICAgaWYgKGRpZ2l0ID09PSAtMSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBiYXNlNjQgZGlnaXQ6IFwiICsgYVN0ci5jaGFyQXQoYUluZGV4IC0gMSkpO1xuICAgIH1cblxuICAgIGNvbnRpbnVhdGlvbiA9ICEhKGRpZ2l0ICYgVkxRX0NPTlRJTlVBVElPTl9CSVQpO1xuICAgIGRpZ2l0ICY9IFZMUV9CQVNFX01BU0s7XG4gICAgcmVzdWx0ID0gcmVzdWx0ICsgKGRpZ2l0IDw8IHNoaWZ0KTtcbiAgICBzaGlmdCArPSBWTFFfQkFTRV9TSElGVDtcbiAgfSB3aGlsZSAoY29udGludWF0aW9uKTtcblxuICBhT3V0UGFyYW0udmFsdWUgPSBmcm9tVkxRU2lnbmVkKHJlc3VsdCk7XG4gIGFPdXRQYXJhbS5yZXN0ID0gYUluZGV4O1xufTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9lbGVjdHJvbi11cGRhdGVyL25vZGVfbW9kdWxlcy9zb3VyY2UtbWFwL2xpYi9iYXNlNjQtdmxxLmpzIiwiLyogLSotIE1vZGU6IGpzOyBqcy1pbmRlbnQtbGV2ZWw6IDI7IC0qLSAqL1xuLypcbiAqIENvcHlyaWdodCAyMDExIE1vemlsbGEgRm91bmRhdGlvbiBhbmQgY29udHJpYnV0b3JzXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTmV3IEJTRCBsaWNlbnNlLiBTZWUgTElDRU5TRSBvcjpcbiAqIGh0dHA6Ly9vcGVuc291cmNlLm9yZy9saWNlbnNlcy9CU0QtMy1DbGF1c2VcbiAqL1xuXG52YXIgdXRpbCA9IHJlcXVpcmUoJy4vdXRpbCcpO1xudmFyIGhhcyA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG52YXIgaGFzTmF0aXZlTWFwID0gdHlwZW9mIE1hcCAhPT0gXCJ1bmRlZmluZWRcIjtcblxuLyoqXG4gKiBBIGRhdGEgc3RydWN0dXJlIHdoaWNoIGlzIGEgY29tYmluYXRpb24gb2YgYW4gYXJyYXkgYW5kIGEgc2V0LiBBZGRpbmcgYSBuZXdcbiAqIG1lbWJlciBpcyBPKDEpLCB0ZXN0aW5nIGZvciBtZW1iZXJzaGlwIGlzIE8oMSksIGFuZCBmaW5kaW5nIHRoZSBpbmRleCBvZiBhblxuICogZWxlbWVudCBpcyBPKDEpLiBSZW1vdmluZyBlbGVtZW50cyBmcm9tIHRoZSBzZXQgaXMgbm90IHN1cHBvcnRlZC4gT25seVxuICogc3RyaW5ncyBhcmUgc3VwcG9ydGVkIGZvciBtZW1iZXJzaGlwLlxuICovXG5mdW5jdGlvbiBBcnJheVNldCgpIHtcbiAgdGhpcy5fYXJyYXkgPSBbXTtcbiAgdGhpcy5fc2V0ID0gaGFzTmF0aXZlTWFwID8gbmV3IE1hcCgpIDogT2JqZWN0LmNyZWF0ZShudWxsKTtcbn1cblxuLyoqXG4gKiBTdGF0aWMgbWV0aG9kIGZvciBjcmVhdGluZyBBcnJheVNldCBpbnN0YW5jZXMgZnJvbSBhbiBleGlzdGluZyBhcnJheS5cbiAqL1xuQXJyYXlTZXQuZnJvbUFycmF5ID0gZnVuY3Rpb24gQXJyYXlTZXRfZnJvbUFycmF5KGFBcnJheSwgYUFsbG93RHVwbGljYXRlcykge1xuICB2YXIgc2V0ID0gbmV3IEFycmF5U2V0KCk7XG4gIGZvciAodmFyIGkgPSAwLCBsZW4gPSBhQXJyYXkubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICBzZXQuYWRkKGFBcnJheVtpXSwgYUFsbG93RHVwbGljYXRlcyk7XG4gIH1cbiAgcmV0dXJuIHNldDtcbn07XG5cbi8qKlxuICogUmV0dXJuIGhvdyBtYW55IHVuaXF1ZSBpdGVtcyBhcmUgaW4gdGhpcyBBcnJheVNldC4gSWYgZHVwbGljYXRlcyBoYXZlIGJlZW5cbiAqIGFkZGVkLCB0aGFuIHRob3NlIGRvIG5vdCBjb3VudCB0b3dhcmRzIHRoZSBzaXplLlxuICpcbiAqIEByZXR1cm5zIE51bWJlclxuICovXG5BcnJheVNldC5wcm90b3R5cGUuc2l6ZSA9IGZ1bmN0aW9uIEFycmF5U2V0X3NpemUoKSB7XG4gIHJldHVybiBoYXNOYXRpdmVNYXAgPyB0aGlzLl9zZXQuc2l6ZSA6IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHRoaXMuX3NldCkubGVuZ3RoO1xufTtcblxuLyoqXG4gKiBBZGQgdGhlIGdpdmVuIHN0cmluZyB0byB0aGlzIHNldC5cbiAqXG4gKiBAcGFyYW0gU3RyaW5nIGFTdHJcbiAqL1xuQXJyYXlTZXQucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uIEFycmF5U2V0X2FkZChhU3RyLCBhQWxsb3dEdXBsaWNhdGVzKSB7XG4gIHZhciBzU3RyID0gaGFzTmF0aXZlTWFwID8gYVN0ciA6IHV0aWwudG9TZXRTdHJpbmcoYVN0cik7XG4gIHZhciBpc0R1cGxpY2F0ZSA9IGhhc05hdGl2ZU1hcCA/IHRoaXMuaGFzKGFTdHIpIDogaGFzLmNhbGwodGhpcy5fc2V0LCBzU3RyKTtcbiAgdmFyIGlkeCA9IHRoaXMuX2FycmF5Lmxlbmd0aDtcbiAgaWYgKCFpc0R1cGxpY2F0ZSB8fCBhQWxsb3dEdXBsaWNhdGVzKSB7XG4gICAgdGhpcy5fYXJyYXkucHVzaChhU3RyKTtcbiAgfVxuICBpZiAoIWlzRHVwbGljYXRlKSB7XG4gICAgaWYgKGhhc05hdGl2ZU1hcCkge1xuICAgICAgdGhpcy5fc2V0LnNldChhU3RyLCBpZHgpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9zZXRbc1N0cl0gPSBpZHg7XG4gICAgfVxuICB9XG59O1xuXG4vKipcbiAqIElzIHRoZSBnaXZlbiBzdHJpbmcgYSBtZW1iZXIgb2YgdGhpcyBzZXQ/XG4gKlxuICogQHBhcmFtIFN0cmluZyBhU3RyXG4gKi9cbkFycmF5U2V0LnByb3RvdHlwZS5oYXMgPSBmdW5jdGlvbiBBcnJheVNldF9oYXMoYVN0cikge1xuICBpZiAoaGFzTmF0aXZlTWFwKSB7XG4gICAgcmV0dXJuIHRoaXMuX3NldC5oYXMoYVN0cik7XG4gIH0gZWxzZSB7XG4gICAgdmFyIHNTdHIgPSB1dGlsLnRvU2V0U3RyaW5nKGFTdHIpO1xuICAgIHJldHVybiBoYXMuY2FsbCh0aGlzLl9zZXQsIHNTdHIpO1xuICB9XG59O1xuXG4vKipcbiAqIFdoYXQgaXMgdGhlIGluZGV4IG9mIHRoZSBnaXZlbiBzdHJpbmcgaW4gdGhlIGFycmF5P1xuICpcbiAqIEBwYXJhbSBTdHJpbmcgYVN0clxuICovXG5BcnJheVNldC5wcm90b3R5cGUuaW5kZXhPZiA9IGZ1bmN0aW9uIEFycmF5U2V0X2luZGV4T2YoYVN0cikge1xuICBpZiAoaGFzTmF0aXZlTWFwKSB7XG4gICAgdmFyIGlkeCA9IHRoaXMuX3NldC5nZXQoYVN0cik7XG4gICAgaWYgKGlkeCA+PSAwKSB7XG4gICAgICAgIHJldHVybiBpZHg7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHZhciBzU3RyID0gdXRpbC50b1NldFN0cmluZyhhU3RyKTtcbiAgICBpZiAoaGFzLmNhbGwodGhpcy5fc2V0LCBzU3RyKSkge1xuICAgICAgcmV0dXJuIHRoaXMuX3NldFtzU3RyXTtcbiAgICB9XG4gIH1cblxuICB0aHJvdyBuZXcgRXJyb3IoJ1wiJyArIGFTdHIgKyAnXCIgaXMgbm90IGluIHRoZSBzZXQuJyk7XG59O1xuXG4vKipcbiAqIFdoYXQgaXMgdGhlIGVsZW1lbnQgYXQgdGhlIGdpdmVuIGluZGV4P1xuICpcbiAqIEBwYXJhbSBOdW1iZXIgYUlkeFxuICovXG5BcnJheVNldC5wcm90b3R5cGUuYXQgPSBmdW5jdGlvbiBBcnJheVNldF9hdChhSWR4KSB7XG4gIGlmIChhSWR4ID49IDAgJiYgYUlkeCA8IHRoaXMuX2FycmF5Lmxlbmd0aCkge1xuICAgIHJldHVybiB0aGlzLl9hcnJheVthSWR4XTtcbiAgfVxuICB0aHJvdyBuZXcgRXJyb3IoJ05vIGVsZW1lbnQgaW5kZXhlZCBieSAnICsgYUlkeCk7XG59O1xuXG4vKipcbiAqIFJldHVybnMgdGhlIGFycmF5IHJlcHJlc2VudGF0aW9uIG9mIHRoaXMgc2V0ICh3aGljaCBoYXMgdGhlIHByb3BlciBpbmRpY2VzXG4gKiBpbmRpY2F0ZWQgYnkgaW5kZXhPZikuIE5vdGUgdGhhdCB0aGlzIGlzIGEgY29weSBvZiB0aGUgaW50ZXJuYWwgYXJyYXkgdXNlZFxuICogZm9yIHN0b3JpbmcgdGhlIG1lbWJlcnMgc28gdGhhdCBubyBvbmUgY2FuIG1lc3Mgd2l0aCBpbnRlcm5hbCBzdGF0ZS5cbiAqL1xuQXJyYXlTZXQucHJvdG90eXBlLnRvQXJyYXkgPSBmdW5jdGlvbiBBcnJheVNldF90b0FycmF5KCkge1xuICByZXR1cm4gdGhpcy5fYXJyYXkuc2xpY2UoKTtcbn07XG5cbmV4cG9ydHMuQXJyYXlTZXQgPSBBcnJheVNldDtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9lbGVjdHJvbi11cGRhdGVyL25vZGVfbW9kdWxlcy9zb3VyY2UtbWFwL2xpYi9hcnJheS1zZXQuanMiLCJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5HZW5lcmljUHJvdmlkZXIgPSB1bmRlZmluZWQ7XG5cbnZhciBfYmx1ZWJpcmRMc3Q7XG5cbmZ1bmN0aW9uIF9sb2FkX2JsdWViaXJkTHN0KCkge1xuICAgIHJldHVybiBfYmx1ZWJpcmRMc3QgPSByZXF1aXJlKFwiYmx1ZWJpcmQtbHN0XCIpO1xufVxuXG52YXIgX2J1aWxkZXJVdGlsUnVudGltZTtcblxuZnVuY3Rpb24gX2xvYWRfYnVpbGRlclV0aWxSdW50aW1lKCkge1xuICAgIHJldHVybiBfYnVpbGRlclV0aWxSdW50aW1lID0gcmVxdWlyZShcImJ1aWxkZXItdXRpbC1ydW50aW1lXCIpO1xufVxuXG52YXIgX21haW47XG5cbmZ1bmN0aW9uIF9sb2FkX21haW4oKSB7XG4gICAgcmV0dXJuIF9tYWluID0gcmVxdWlyZShcIi4vbWFpblwiKTtcbn1cblxudmFyIF9Qcm92aWRlcjtcblxuZnVuY3Rpb24gX2xvYWRfUHJvdmlkZXIoKSB7XG4gICAgcmV0dXJuIF9Qcm92aWRlciA9IHJlcXVpcmUoXCIuL1Byb3ZpZGVyXCIpO1xufVxuXG5jbGFzcyBHZW5lcmljUHJvdmlkZXIgZXh0ZW5kcyAoX21haW4gfHwgX2xvYWRfbWFpbigpKS5Qcm92aWRlciB7XG4gICAgY29uc3RydWN0b3IoY29uZmlndXJhdGlvbiwgdXBkYXRlciwgdXNlTXVsdGlwbGVSYW5nZVJlcXVlc3QgPSB0cnVlKSB7XG4gICAgICAgIHN1cGVyKHVwZGF0ZXIuaHR0cEV4ZWN1dG9yLCB1c2VNdWx0aXBsZVJhbmdlUmVxdWVzdCk7XG4gICAgICAgIHRoaXMuY29uZmlndXJhdGlvbiA9IGNvbmZpZ3VyYXRpb247XG4gICAgICAgIHRoaXMudXBkYXRlciA9IHVwZGF0ZXI7XG4gICAgICAgIHRoaXMuYmFzZVVybCA9ICgwLCAoX21haW4gfHwgX2xvYWRfbWFpbigpKS5uZXdCYXNlVXJsKSh0aGlzLmNvbmZpZ3VyYXRpb24udXJsKTtcbiAgICB9XG4gICAgZ2V0IGNoYW5uZWwoKSB7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IHRoaXMudXBkYXRlci5jaGFubmVsIHx8IHRoaXMuY29uZmlndXJhdGlvbi5jaGFubmVsO1xuICAgICAgICByZXR1cm4gcmVzdWx0ID09IG51bGwgPyAoMCwgKF9tYWluIHx8IF9sb2FkX21haW4oKSkuZ2V0RGVmYXVsdENoYW5uZWxOYW1lKSgpIDogKDAsIChfbWFpbiB8fCBfbG9hZF9tYWluKCkpLmdldEN1c3RvbUNoYW5uZWxOYW1lKShyZXN1bHQpO1xuICAgIH1cbiAgICBnZXRMYXRlc3RWZXJzaW9uKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgICAgIHJldHVybiAoMCwgKF9ibHVlYmlyZExzdCB8fCBfbG9hZF9ibHVlYmlyZExzdCgpKS5jb3JvdXRpbmUpKGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBsZXQgcmVzdWx0O1xuICAgICAgICAgICAgY29uc3QgY2hhbm5lbEZpbGUgPSAoMCwgKF9tYWluIHx8IF9sb2FkX21haW4oKSkuZ2V0Q2hhbm5lbEZpbGVuYW1lKShfdGhpcy5jaGFubmVsKTtcbiAgICAgICAgICAgIGNvbnN0IGNoYW5uZWxVcmwgPSAoMCwgKF9tYWluIHx8IF9sb2FkX21haW4oKSkubmV3VXJsRnJvbUJhc2UpKGNoYW5uZWxGaWxlLCBfdGhpcy5iYXNlVXJsKTtcbiAgICAgICAgICAgIGZvciAobGV0IGF0dGVtcHROdW1iZXIgPSAwOzsgYXR0ZW1wdE51bWJlcisrKSB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gKDAsIChfUHJvdmlkZXIgfHwgX2xvYWRfUHJvdmlkZXIoKSkucGFyc2VVcGRhdGVJbmZvKSgoeWllbGQgX3RoaXMuaHR0cFJlcXVlc3QoY2hhbm5lbFVybCkpLCBjaGFubmVsRmlsZSwgY2hhbm5lbFVybCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGUgaW5zdGFuY2VvZiAoX2J1aWxkZXJVdGlsUnVudGltZSB8fCBfbG9hZF9idWlsZGVyVXRpbFJ1bnRpbWUoKSkuSHR0cEVycm9yICYmIGUuc3RhdHVzQ29kZSA9PT0gNDA0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyAoMCwgKF9idWlsZGVyVXRpbFJ1bnRpbWUgfHwgX2xvYWRfYnVpbGRlclV0aWxSdW50aW1lKCkpLm5ld0Vycm9yKShgQ2Fubm90IGZpbmQgY2hhbm5lbCBcIiR7Y2hhbm5lbEZpbGV9XCIgdXBkYXRlIGluZm86ICR7ZS5zdGFjayB8fCBlLm1lc3NhZ2V9YCwgXCJFUlJfVVBEQVRFUl9DSEFOTkVMX0ZJTEVfTk9UX0ZPVU5EXCIpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGUuY29kZSA9PT0gXCJFQ09OTlJFRlVTRURcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGF0dGVtcHROdW1iZXIgPCAzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgeWllbGQgbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2V0VGltZW91dChyZXNvbHZlLCAxMDAwICogYXR0ZW1wdE51bWJlcik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlamVjdChlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHRocm93IGU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCgwLCAoX21haW4gfHwgX2xvYWRfbWFpbigpKS5pc1VzZU9sZE1hY1Byb3ZpZGVyKSgpKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnJlbGVhc2VKc29uVXJsID0gY2hhbm5lbFVybC5ocmVmO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfSkoKTtcbiAgICB9XG4gICAgcmVzb2x2ZUZpbGVzKHVwZGF0ZUluZm8pIHtcbiAgICAgICAgcmV0dXJuICgwLCAoX1Byb3ZpZGVyIHx8IF9sb2FkX1Byb3ZpZGVyKCkpLnJlc29sdmVGaWxlcykodXBkYXRlSW5mbywgdGhpcy5iYXNlVXJsKTtcbiAgICB9XG59XG5leHBvcnRzLkdlbmVyaWNQcm92aWRlciA9IEdlbmVyaWNQcm92aWRlcjsgLy8jIHNvdXJjZU1hcHBpbmdVUkw9R2VuZXJpY1Byb3ZpZGVyLmpzLm1hcFxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9lbGVjdHJvbi11cGRhdGVyL291dC9HZW5lcmljUHJvdmlkZXIuanMiLCJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5HaXRIdWJQcm92aWRlciA9IGV4cG9ydHMuQmFzZUdpdEh1YlByb3ZpZGVyID0gdW5kZWZpbmVkO1xuXG52YXIgX2JsdWViaXJkTHN0O1xuXG5mdW5jdGlvbiBfbG9hZF9ibHVlYmlyZExzdCgpIHtcbiAgICByZXR1cm4gX2JsdWViaXJkTHN0ID0gcmVxdWlyZShcImJsdWViaXJkLWxzdFwiKTtcbn1cblxuZXhwb3J0cy5jb21wdXRlUmVsZWFzZU5vdGVzID0gY29tcHV0ZVJlbGVhc2VOb3RlcztcblxudmFyIF9idWlsZGVyVXRpbFJ1bnRpbWU7XG5cbmZ1bmN0aW9uIF9sb2FkX2J1aWxkZXJVdGlsUnVudGltZSgpIHtcbiAgICByZXR1cm4gX2J1aWxkZXJVdGlsUnVudGltZSA9IHJlcXVpcmUoXCJidWlsZGVyLXV0aWwtcnVudGltZVwiKTtcbn1cblxudmFyIF9zZW12ZXI7XG5cbmZ1bmN0aW9uIF9sb2FkX3NlbXZlcigpIHtcbiAgICByZXR1cm4gX3NlbXZlciA9IF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKHJlcXVpcmUoXCJzZW12ZXJcIikpO1xufVxuXG52YXIgX21haW47XG5cbmZ1bmN0aW9uIF9sb2FkX21haW4oKSB7XG4gICAgcmV0dXJuIF9tYWluID0gcmVxdWlyZShcIi4vbWFpblwiKTtcbn1cblxudmFyIF9Qcm92aWRlcjtcblxuZnVuY3Rpb24gX2xvYWRfUHJvdmlkZXIoKSB7XG4gICAgcmV0dXJuIF9Qcm92aWRlciA9IHJlcXVpcmUoXCIuL1Byb3ZpZGVyXCIpO1xufVxuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChvYmopIHsgaWYgKG9iaiAmJiBvYmouX19lc01vZHVsZSkgeyByZXR1cm4gb2JqOyB9IGVsc2UgeyB2YXIgbmV3T2JqID0ge307IGlmIChvYmogIT0gbnVsbCkgeyBmb3IgKHZhciBrZXkgaW4gb2JqKSB7IGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBrZXkpKSBuZXdPYmpba2V5XSA9IG9ialtrZXldOyB9IH0gbmV3T2JqLmRlZmF1bHQgPSBvYmo7IHJldHVybiBuZXdPYmo7IH0gfVxuXG5jbGFzcyBCYXNlR2l0SHViUHJvdmlkZXIgZXh0ZW5kcyAoX21haW4gfHwgX2xvYWRfbWFpbigpKS5Qcm92aWRlciB7XG4gICAgY29uc3RydWN0b3Iob3B0aW9ucywgZGVmYXVsdEhvc3QsIGV4ZWN1dG9yKSB7XG4gICAgICAgIHN1cGVyKGV4ZWN1dG9yLCBmYWxzZSAvKiBiZWNhdXNlIEdpdEhpYiB1c2VzIFMzICovKTtcbiAgICAgICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgICAgICAgdGhpcy5iYXNlVXJsID0gKDAsIChfbWFpbiB8fCBfbG9hZF9tYWluKCkpLm5ld0Jhc2VVcmwpKCgwLCAoX2J1aWxkZXJVdGlsUnVudGltZSB8fCBfbG9hZF9idWlsZGVyVXRpbFJ1bnRpbWUoKSkuZ2l0aHViVXJsKShvcHRpb25zLCBkZWZhdWx0SG9zdCkpO1xuICAgIH1cbiAgICBjb21wdXRlR2l0aHViQmFzZVBhdGgocmVzdWx0KSB7XG4gICAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9lbGVjdHJvbi11c2VybGFuZC9lbGVjdHJvbi1idWlsZGVyL2lzc3Vlcy8xOTAzI2lzc3VlY29tbWVudC0zMjA4ODEyMTFcbiAgICAgICAgY29uc3QgaG9zdCA9IHRoaXMub3B0aW9ucy5ob3N0O1xuICAgICAgICByZXR1cm4gaG9zdCAhPSBudWxsICYmIGhvc3QgIT09IFwiZ2l0aHViLmNvbVwiICYmIGhvc3QgIT09IFwiYXBpLmdpdGh1Yi5jb21cIiA/IGAvYXBpL3YzJHtyZXN1bHR9YCA6IHJlc3VsdDtcbiAgICB9XG59XG5leHBvcnRzLkJhc2VHaXRIdWJQcm92aWRlciA9IEJhc2VHaXRIdWJQcm92aWRlcjtcbmNsYXNzIEdpdEh1YlByb3ZpZGVyIGV4dGVuZHMgQmFzZUdpdEh1YlByb3ZpZGVyIHtcbiAgICBjb25zdHJ1Y3RvcihvcHRpb25zLCB1cGRhdGVyLCBleGVjdXRvcikge1xuICAgICAgICBzdXBlcihvcHRpb25zLCBcImdpdGh1Yi5jb21cIiwgZXhlY3V0b3IpO1xuICAgICAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuICAgICAgICB0aGlzLnVwZGF0ZXIgPSB1cGRhdGVyO1xuICAgIH1cbiAgICBnZXRMYXRlc3RWZXJzaW9uKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgICAgIHJldHVybiAoMCwgKF9ibHVlYmlyZExzdCB8fCBfbG9hZF9ibHVlYmlyZExzdCgpKS5jb3JvdXRpbmUpKGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCBiYXNlUGF0aCA9IF90aGlzLmJhc2VQYXRoO1xuICAgICAgICAgICAgY29uc3QgY2FuY2VsbGF0aW9uVG9rZW4gPSBuZXcgKF9idWlsZGVyVXRpbFJ1bnRpbWUgfHwgX2xvYWRfYnVpbGRlclV0aWxSdW50aW1lKCkpLkNhbmNlbGxhdGlvblRva2VuKCk7XG4gICAgICAgICAgICBjb25zdCBmZWVkWG1sID0geWllbGQgX3RoaXMuaHR0cFJlcXVlc3QoKDAsIChfbWFpbiB8fCBfbG9hZF9tYWluKCkpLm5ld1VybEZyb21CYXNlKShgJHtiYXNlUGF0aH0uYXRvbWAsIF90aGlzLmJhc2VVcmwpLCB7XG4gICAgICAgICAgICAgICAgQWNjZXB0OiBcImFwcGxpY2F0aW9uL3htbCwgYXBwbGljYXRpb24vYXRvbSt4bWwsIHRleHQveG1sLCAqLypcIlxuICAgICAgICAgICAgfSwgY2FuY2VsbGF0aW9uVG9rZW4pO1xuICAgICAgICAgICAgY29uc3QgZmVlZCA9ICgwLCAoX2J1aWxkZXJVdGlsUnVudGltZSB8fCBfbG9hZF9idWlsZGVyVXRpbFJ1bnRpbWUoKSkucGFyc2VYbWwpKGZlZWRYbWwpO1xuICAgICAgICAgICAgY29uc3QgbGF0ZXN0UmVsZWFzZSA9IGZlZWQuZWxlbWVudChcImVudHJ5XCIsIGZhbHNlLCBgTm8gcHVibGlzaGVkIHZlcnNpb25zIG9uIEdpdEh1YmApO1xuICAgICAgICAgICAgbGV0IHZlcnNpb247XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGlmIChfdGhpcy51cGRhdGVyLmFsbG93UHJlcmVsZWFzZSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBub2luc3BlY3Rpb24gVHlwZVNjcmlwdFZhbGlkYXRlSlNUeXBlc1xuICAgICAgICAgICAgICAgICAgICB2ZXJzaW9uID0gbGF0ZXN0UmVsZWFzZS5lbGVtZW50KFwibGlua1wiKS5hdHRyaWJ1dGUoXCJocmVmXCIpLm1hdGNoKC9cXC90YWdcXC92PyhbXlxcL10rKSQvKVsxXTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB2ZXJzaW9uID0geWllbGQgX3RoaXMuZ2V0TGF0ZXN0VmVyc2lvblN0cmluZyhiYXNlUGF0aCwgY2FuY2VsbGF0aW9uVG9rZW4pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyAoMCwgKF9idWlsZGVyVXRpbFJ1bnRpbWUgfHwgX2xvYWRfYnVpbGRlclV0aWxSdW50aW1lKCkpLm5ld0Vycm9yKShgQ2Fubm90IHBhcnNlIHJlbGVhc2VzIGZlZWQ6ICR7ZS5zdGFjayB8fCBlLm1lc3NhZ2V9LFxcblhNTDpcXG4ke2ZlZWRYbWx9YCwgXCJFUlJfVVBEQVRFUl9JTlZBTElEX1JFTEVBU0VfRkVFRFwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh2ZXJzaW9uID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyAoMCwgKF9idWlsZGVyVXRpbFJ1bnRpbWUgfHwgX2xvYWRfYnVpbGRlclV0aWxSdW50aW1lKCkpLm5ld0Vycm9yKShgTm8gcHVibGlzaGVkIHZlcnNpb25zIG9uIEdpdEh1YmAsIFwiRVJSX1VQREFURVJfTk9fUFVCTElTSEVEX1ZFUlNJT05TXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgY2hhbm5lbEZpbGUgPSAoMCwgKF9tYWluIHx8IF9sb2FkX21haW4oKSkuZ2V0Q2hhbm5lbEZpbGVuYW1lKSgoMCwgKF9tYWluIHx8IF9sb2FkX21haW4oKSkuZ2V0RGVmYXVsdENoYW5uZWxOYW1lKSgpKTtcbiAgICAgICAgICAgIGNvbnN0IGNoYW5uZWxGaWxlVXJsID0gKDAsIChfbWFpbiB8fCBfbG9hZF9tYWluKCkpLm5ld1VybEZyb21CYXNlKShfdGhpcy5nZXRCYXNlRG93bmxvYWRQYXRoKHZlcnNpb24sIGNoYW5uZWxGaWxlKSwgX3RoaXMuYmFzZVVybCk7XG4gICAgICAgICAgICBjb25zdCByZXF1ZXN0T3B0aW9ucyA9IF90aGlzLmNyZWF0ZVJlcXVlc3RPcHRpb25zKGNoYW5uZWxGaWxlVXJsKTtcbiAgICAgICAgICAgIGxldCByYXdEYXRhO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICByYXdEYXRhID0geWllbGQgX3RoaXMuZXhlY3V0b3IucmVxdWVzdChyZXF1ZXN0T3B0aW9ucywgY2FuY2VsbGF0aW9uVG9rZW4pO1xuICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIGlmICghX3RoaXMudXBkYXRlci5hbGxvd1ByZXJlbGVhc2UgJiYgZSBpbnN0YW5jZW9mIChfYnVpbGRlclV0aWxSdW50aW1lIHx8IF9sb2FkX2J1aWxkZXJVdGlsUnVudGltZSgpKS5IdHRwRXJyb3IgJiYgZS5zdGF0dXNDb2RlID09PSA0MDQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgKDAsIChfYnVpbGRlclV0aWxSdW50aW1lIHx8IF9sb2FkX2J1aWxkZXJVdGlsUnVudGltZSgpKS5uZXdFcnJvcikoYENhbm5vdCBmaW5kICR7Y2hhbm5lbEZpbGV9IGluIHRoZSBsYXRlc3QgcmVsZWFzZSBhcnRpZmFjdHMgKCR7Y2hhbm5lbEZpbGVVcmx9KTogJHtlLnN0YWNrIHx8IGUubWVzc2FnZX1gLCBcIkVSUl9VUERBVEVSX0NIQU5ORUxfRklMRV9OT1RfRk9VTkRcIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRocm93IGU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCByZXN1bHQgPSAoMCwgKF9Qcm92aWRlciB8fCBfbG9hZF9Qcm92aWRlcigpKS5wYXJzZVVwZGF0ZUluZm8pKHJhd0RhdGEsIGNoYW5uZWxGaWxlLCBjaGFubmVsRmlsZVVybCk7XG4gICAgICAgICAgICBpZiAoKDAsIChfbWFpbiB8fCBfbG9hZF9tYWluKCkpLmlzVXNlT2xkTWFjUHJvdmlkZXIpKCkpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQucmVsZWFzZUpzb25VcmwgPSBgJHsoMCwgKF9idWlsZGVyVXRpbFJ1bnRpbWUgfHwgX2xvYWRfYnVpbGRlclV0aWxSdW50aW1lKCkpLmdpdGh1YlVybCkoX3RoaXMub3B0aW9ucyl9LyR7cmVxdWVzdE9wdGlvbnMucGF0aH1gO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHJlc3VsdC5yZWxlYXNlTmFtZSA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnJlbGVhc2VOYW1lID0gbGF0ZXN0UmVsZWFzZS5lbGVtZW50VmFsdWVPckVtcHR5KFwidGl0bGVcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocmVzdWx0LnJlbGVhc2VOb3RlcyA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnJlbGVhc2VOb3RlcyA9IGNvbXB1dGVSZWxlYXNlTm90ZXMoX3RoaXMudXBkYXRlci5jdXJyZW50VmVyc2lvbiwgX3RoaXMudXBkYXRlci5mdWxsQ2hhbmdlbG9nLCBmZWVkLCBsYXRlc3RSZWxlYXNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH0pKCk7XG4gICAgfVxuICAgIGdldExhdGVzdFZlcnNpb25TdHJpbmcoYmFzZVBhdGgsIGNhbmNlbGxhdGlvblRva2VuKSB7XG4gICAgICAgIHZhciBfdGhpczIgPSB0aGlzO1xuXG4gICAgICAgIHJldHVybiAoMCwgKF9ibHVlYmlyZExzdCB8fCBfbG9hZF9ibHVlYmlyZExzdCgpKS5jb3JvdXRpbmUpKGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCB1cmwgPSAoMCwgKF9tYWluIHx8IF9sb2FkX21haW4oKSkubmV3VXJsRnJvbUJhc2UpKGAke2Jhc2VQYXRofS9sYXRlc3RgLCBfdGhpczIuYmFzZVVybCk7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIC8vIGRvIG5vdCB1c2UgQVBJIHRvIGF2b2lkIGxpbWl0XG4gICAgICAgICAgICAgICAgY29uc3QgcmF3RGF0YSA9IHlpZWxkIF90aGlzMi5odHRwUmVxdWVzdCh1cmwsIHsgQWNjZXB0OiBcImFwcGxpY2F0aW9uL2pzb25cIiB9LCBjYW5jZWxsYXRpb25Ub2tlbik7XG4gICAgICAgICAgICAgICAgaWYgKHJhd0RhdGEgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgcmVsZWFzZUluZm8gPSBKU09OLnBhcnNlKHJhd0RhdGEpO1xuICAgICAgICAgICAgICAgIHJldHVybiByZWxlYXNlSW5mby50YWdfbmFtZS5zdGFydHNXaXRoKFwidlwiKSA/IHJlbGVhc2VJbmZvLnRhZ19uYW1lLnN1YnN0cmluZygxKSA6IHJlbGVhc2VJbmZvLnRhZ19uYW1lO1xuICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIHRocm93ICgwLCAoX2J1aWxkZXJVdGlsUnVudGltZSB8fCBfbG9hZF9idWlsZGVyVXRpbFJ1bnRpbWUoKSkubmV3RXJyb3IpKGBVbmFibGUgdG8gZmluZCBsYXRlc3QgdmVyc2lvbiBvbiBHaXRIdWIgKCR7dXJsfSksIHBsZWFzZSBlbnN1cmUgYSBwcm9kdWN0aW9uIHJlbGVhc2UgZXhpc3RzOiAke2Uuc3RhY2sgfHwgZS5tZXNzYWdlfWAsIFwiRVJSX1VQREFURVJfTEFURVNUX1ZFUlNJT05fTk9UX0ZPVU5EXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KSgpO1xuICAgIH1cbiAgICBnZXQgYmFzZVBhdGgoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbXB1dGVHaXRodWJCYXNlUGF0aChgLyR7dGhpcy5vcHRpb25zLm93bmVyfS8ke3RoaXMub3B0aW9ucy5yZXBvfS9yZWxlYXNlc2ApO1xuICAgIH1cbiAgICByZXNvbHZlRmlsZXModXBkYXRlSW5mbykge1xuICAgICAgICAvLyBzdGlsbCByZXBsYWNlIHNwYWNlIHRvIC0gZHVlIHRvIGJhY2t3YXJkIGNvbXBhdGliaWxpdHlcbiAgICAgICAgcmV0dXJuICgwLCAoX1Byb3ZpZGVyIHx8IF9sb2FkX1Byb3ZpZGVyKCkpLnJlc29sdmVGaWxlcykodXBkYXRlSW5mbywgdGhpcy5iYXNlVXJsLCBwID0+IHRoaXMuZ2V0QmFzZURvd25sb2FkUGF0aCh1cGRhdGVJbmZvLnZlcnNpb24sIHAucmVwbGFjZSgvIC9nLCBcIi1cIikpKTtcbiAgICB9XG4gICAgZ2V0QmFzZURvd25sb2FkUGF0aCh2ZXJzaW9uLCBmaWxlTmFtZSkge1xuICAgICAgICByZXR1cm4gYCR7dGhpcy5iYXNlUGF0aH0vZG93bmxvYWQvJHt0aGlzLm9wdGlvbnMudlByZWZpeGVkVGFnTmFtZSA9PT0gZmFsc2UgPyBcIlwiIDogXCJ2XCJ9JHt2ZXJzaW9ufS8ke2ZpbGVOYW1lfWA7XG4gICAgfVxufVxuZXhwb3J0cy5HaXRIdWJQcm92aWRlciA9IEdpdEh1YlByb3ZpZGVyO1xuZnVuY3Rpb24gZ2V0Tm90ZVZhbHVlKHBhcmVudCkge1xuICAgIGNvbnN0IHJlc3VsdCA9IHBhcmVudC5lbGVtZW50VmFsdWVPckVtcHR5KFwiY29udGVudFwiKTtcbiAgICAvLyBHaXRIdWIgcmVwb3J0cyBlbXB0eSBub3RlcyBhcyA8Y29udGVudD5ObyBjb250ZW50LjwvY29udGVudD5cbiAgICByZXR1cm4gcmVzdWx0ID09PSBcIk5vIGNvbnRlbnQuXCIgPyBcIlwiIDogcmVzdWx0O1xufVxuZnVuY3Rpb24gY29tcHV0ZVJlbGVhc2VOb3RlcyhjdXJyZW50VmVyc2lvbiwgaXNGdWxsQ2hhbmdlbG9nLCBmZWVkLCBsYXRlc3RSZWxlYXNlKSB7XG4gICAgaWYgKCFpc0Z1bGxDaGFuZ2Vsb2cpIHtcbiAgICAgICAgcmV0dXJuIGdldE5vdGVWYWx1ZShsYXRlc3RSZWxlYXNlKTtcbiAgICB9XG4gICAgY29uc3QgcmVsZWFzZU5vdGVzID0gW107XG4gICAgZm9yIChjb25zdCByZWxlYXNlIG9mIGZlZWQuZ2V0RWxlbWVudHMoXCJlbnRyeVwiKSkge1xuICAgICAgICAvLyBub2luc3BlY3Rpb24gVHlwZVNjcmlwdFZhbGlkYXRlSlNUeXBlc1xuICAgICAgICBjb25zdCB2ZXJzaW9uUmVsZWFzZSA9IHJlbGVhc2UuZWxlbWVudChcImxpbmtcIikuYXR0cmlidXRlKFwiaHJlZlwiKS5tYXRjaCgvXFwvdGFnXFwvdj8oW15cXC9dKykkLylbMV07XG4gICAgICAgIGlmICgoX3NlbXZlciB8fCBfbG9hZF9zZW12ZXIoKSkubHQoY3VycmVudFZlcnNpb24sIHZlcnNpb25SZWxlYXNlKSkge1xuICAgICAgICAgICAgcmVsZWFzZU5vdGVzLnB1c2goe1xuICAgICAgICAgICAgICAgIHZlcnNpb246IHZlcnNpb25SZWxlYXNlLFxuICAgICAgICAgICAgICAgIG5vdGU6IGdldE5vdGVWYWx1ZShyZWxlYXNlKVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlbGVhc2VOb3Rlcy5zb3J0KChhLCBiKSA9PiAoX3NlbXZlciB8fCBfbG9hZF9zZW12ZXIoKSkucmNvbXBhcmUoYS52ZXJzaW9uLCBiLnZlcnNpb24pKTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUdpdEh1YlByb3ZpZGVyLmpzLm1hcFxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9lbGVjdHJvbi11cGRhdGVyL291dC9HaXRIdWJQcm92aWRlci5qcyIsIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLkJhc2VVcGRhdGVyID0gdW5kZWZpbmVkO1xuXG52YXIgX2JsdWViaXJkTHN0O1xuXG5mdW5jdGlvbiBfbG9hZF9ibHVlYmlyZExzdCgpIHtcbiAgICByZXR1cm4gX2JsdWViaXJkTHN0ID0gcmVxdWlyZShcImJsdWViaXJkLWxzdFwiKTtcbn1cblxudmFyIF9idWlsZGVyVXRpbFJ1bnRpbWU7XG5cbmZ1bmN0aW9uIF9sb2FkX2J1aWxkZXJVdGlsUnVudGltZSgpIHtcbiAgICByZXR1cm4gX2J1aWxkZXJVdGlsUnVudGltZSA9IHJlcXVpcmUoXCJidWlsZGVyLXV0aWwtcnVudGltZVwiKTtcbn1cblxudmFyIF9mc0V4dHJhUDtcblxuZnVuY3Rpb24gX2xvYWRfZnNFeHRyYVAoKSB7XG4gICAgcmV0dXJuIF9mc0V4dHJhUCA9IHJlcXVpcmUoXCJmcy1leHRyYS1wXCIpO1xufVxuXG52YXIgX29zO1xuXG5mdW5jdGlvbiBfbG9hZF9vcygpIHtcbiAgICByZXR1cm4gX29zID0gcmVxdWlyZShcIm9zXCIpO1xufVxuXG52YXIgX3BhdGggPSBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChyZXF1aXJlKFwicGF0aFwiKSk7XG5cbnZhciBfQXBwVXBkYXRlcjtcblxuZnVuY3Rpb24gX2xvYWRfQXBwVXBkYXRlcigpIHtcbiAgICByZXR1cm4gX0FwcFVwZGF0ZXIgPSByZXF1aXJlKFwiLi9BcHBVcGRhdGVyXCIpO1xufVxuXG52YXIgX0Rvd25sb2FkZWRVcGRhdGVIZWxwZXI7XG5cbmZ1bmN0aW9uIF9sb2FkX0Rvd25sb2FkZWRVcGRhdGVIZWxwZXIoKSB7XG4gICAgcmV0dXJuIF9Eb3dubG9hZGVkVXBkYXRlSGVscGVyID0gcmVxdWlyZShcIi4vRG93bmxvYWRlZFVwZGF0ZUhlbHBlclwiKTtcbn1cblxudmFyIF9tYWluO1xuXG5mdW5jdGlvbiBfbG9hZF9tYWluKCkge1xuICAgIHJldHVybiBfbWFpbiA9IHJlcXVpcmUoXCIuL21haW5cIik7XG59XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKG9iaikgeyBpZiAob2JqICYmIG9iai5fX2VzTW9kdWxlKSB7IHJldHVybiBvYmo7IH0gZWxzZSB7IHZhciBuZXdPYmogPSB7fTsgaWYgKG9iaiAhPSBudWxsKSB7IGZvciAodmFyIGtleSBpbiBvYmopIHsgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGtleSkpIG5ld09ialtrZXldID0gb2JqW2tleV07IH0gfSBuZXdPYmouZGVmYXVsdCA9IG9iajsgcmV0dXJuIG5ld09iajsgfSB9XG5cbmNsYXNzIEJhc2VVcGRhdGVyIGV4dGVuZHMgKF9BcHBVcGRhdGVyIHx8IF9sb2FkX0FwcFVwZGF0ZXIoKSkuQXBwVXBkYXRlciB7XG4gICAgY29uc3RydWN0b3Iob3B0aW9ucywgYXBwKSB7XG4gICAgICAgIHN1cGVyKG9wdGlvbnMsIGFwcCk7XG4gICAgICAgIHRoaXMuZG93bmxvYWRlZFVwZGF0ZUhlbHBlciA9IG5ldyAoX0Rvd25sb2FkZWRVcGRhdGVIZWxwZXIgfHwgX2xvYWRfRG93bmxvYWRlZFVwZGF0ZUhlbHBlcigpKS5Eb3dubG9hZGVkVXBkYXRlSGVscGVyKCk7XG4gICAgICAgIHRoaXMucXVpdEFuZEluc3RhbGxDYWxsZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5xdWl0SGFuZGxlckFkZGVkID0gZmFsc2U7XG4gICAgfVxuICAgIHF1aXRBbmRJbnN0YWxsKGlzU2lsZW50ID0gZmFsc2UsIGlzRm9yY2VSdW5BZnRlciA9IGZhbHNlKSB7XG4gICAgICAgIHRoaXMuX2xvZ2dlci5pbmZvKGBJbnN0YWxsIG9uIGV4cGxpY2l0IHF1aXRBbmRJbnN0YWxsYCk7XG4gICAgICAgIGlmICh0aGlzLmluc3RhbGwoaXNTaWxlbnQsIGlzU2lsZW50ID8gaXNGb3JjZVJ1bkFmdGVyIDogdHJ1ZSkpIHtcbiAgICAgICAgICAgIHNldEltbWVkaWF0ZSgoKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5hcHAucXVpdCgpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZXhlY3V0ZURvd25sb2FkKGRvd25sb2FkT3B0aW9ucywgZmlsZUluZm8sIHRhc2spIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgICAgICByZXR1cm4gKDAsIChfYmx1ZWJpcmRMc3QgfHwgX2xvYWRfYmx1ZWJpcmRMc3QoKSkuY29yb3V0aW5lKShmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgaWYgKF90aGlzLmxpc3RlbmVyQ291bnQoKF9tYWluIHx8IF9sb2FkX21haW4oKSkuRE9XTkxPQURfUFJPR1JFU1MpID4gMCkge1xuICAgICAgICAgICAgICAgIGRvd25sb2FkT3B0aW9ucy5vblByb2dyZXNzID0gZnVuY3Rpb24gKGl0KSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBfdGhpcy5lbWl0KChfbWFpbiB8fCBfbG9hZF9tYWluKCkpLkRPV05MT0FEX1BST0dSRVNTLCBpdCk7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIHVzZSBURVNUX0FQUF9UTVBfRElSIGlmIGRlZmluZWQgYW5kIGRldmVsb3BlciBtYWNoaW5lIChtdXN0IGJlIG5vdCB3aW5kb3dzIGR1ZSB0byBzZWN1cml0eSByZWFzb25zIC0gd2UgbXVzdCBub3QgdXNlIGVudiB2YXIgaW4gdGhlIHByb2R1Y3Rpb24pXG4gICAgICAgICAgICBjb25zdCB0ZW1wRGlyID0geWllbGQgKDAsIChfZnNFeHRyYVAgfHwgX2xvYWRfZnNFeHRyYVAoKSkubWtkdGVtcCkoYCR7X3BhdGguam9pbigocHJvY2Vzcy5wbGF0Zm9ybSA9PT0gXCJkYXJ3aW5cIiA/IHByb2Nlc3MuZW52LlRFU1RfQVBQX1RNUF9ESVIgOiBudWxsKSB8fCAoMCwgKF9vcyB8fCBfbG9hZF9vcygpKS50bXBkaXIpKCksIFwidXBcIil9LWApO1xuICAgICAgICAgICAgY29uc3QgcmVtb3ZlVGVtcERpcklmQW55ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIF90aGlzLmRvd25sb2FkZWRVcGRhdGVIZWxwZXIuY2xlYXIoKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gKDAsIChfZnNFeHRyYVAgfHwgX2xvYWRfZnNFeHRyYVAoKSkucmVtb3ZlKSh0ZW1wRGlyKS5jYXRjaChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGlnbm9yZWRcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGRlc3RpbmF0aW9uRmlsZSA9IF9wYXRoLmpvaW4odGVtcERpciwgX3BhdGgucG9zaXguYmFzZW5hbWUoZmlsZUluZm8uaW5mby51cmwpKTtcbiAgICAgICAgICAgICAgICB5aWVsZCB0YXNrKHRlbXBEaXIsIGRlc3RpbmF0aW9uRmlsZSwgcmVtb3ZlVGVtcERpcklmQW55KTtcbiAgICAgICAgICAgICAgICBfdGhpcy5fbG9nZ2VyLmluZm8oYE5ldyB2ZXJzaW9uICR7X3RoaXMudXBkYXRlSW5mby52ZXJzaW9ufSBoYXMgYmVlbiBkb3dubG9hZGVkIHRvICR7ZGVzdGluYXRpb25GaWxlfWApO1xuICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIHlpZWxkIHJlbW92ZVRlbXBEaXJJZkFueSgpO1xuICAgICAgICAgICAgICAgIGlmIChlIGluc3RhbmNlb2YgKF9idWlsZGVyVXRpbFJ1bnRpbWUgfHwgX2xvYWRfYnVpbGRlclV0aWxSdW50aW1lKCkpLkNhbmNlbGxhdGlvbkVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLmVtaXQoXCJ1cGRhdGUtY2FuY2VsbGVkXCIsIF90aGlzLnVwZGF0ZUluZm8pO1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5fbG9nZ2VyLmluZm8oXCJDYW5jZWxsZWRcIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRocm93IGU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pKCk7XG4gICAgfVxuICAgIGluc3RhbGwoaXNTaWxlbnQsIGlzUnVuQWZ0ZXIpIHtcbiAgICAgICAgaWYgKHRoaXMucXVpdEFuZEluc3RhbGxDYWxsZWQpIHtcbiAgICAgICAgICAgIHRoaXMuX2xvZ2dlci53YXJuKFwiaW5zdGFsbCBjYWxsIGlnbm9yZWQ6IHF1aXRBbmRJbnN0YWxsQ2FsbGVkIGlzIHNldCB0byB0cnVlXCIpO1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGluc3RhbGxlclBhdGggPSB0aGlzLmRvd25sb2FkZWRVcGRhdGVIZWxwZXIuZmlsZTtcbiAgICAgICAgaWYgKCF0aGlzLnVwZGF0ZUF2YWlsYWJsZSB8fCBpbnN0YWxsZXJQYXRoID09IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuZGlzcGF0Y2hFcnJvcihuZXcgRXJyb3IoXCJObyB1cGRhdGUgYXZhaWxhYmxlLCBjYW4ndCBxdWl0IGFuZCBpbnN0YWxsXCIpKTtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBwcmV2ZW50IGNhbGxpbmcgc2V2ZXJhbCB0aW1lc1xuICAgICAgICB0aGlzLnF1aXRBbmRJbnN0YWxsQ2FsbGVkID0gdHJ1ZTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHRoaXMuX2xvZ2dlci5pbmZvKGBJbnN0YWxsOiBpc1NpbGVudDogJHtpc1NpbGVudH0sIGlzUnVuQWZ0ZXI6ICR7aXNSdW5BZnRlcn1gKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmRvSW5zdGFsbChpbnN0YWxsZXJQYXRoLCBpc1NpbGVudCwgaXNSdW5BZnRlcik7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIHRoaXMuZGlzcGF0Y2hFcnJvcihlKTtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhZGRRdWl0SGFuZGxlcigpIHtcbiAgICAgICAgaWYgKHRoaXMucXVpdEhhbmRsZXJBZGRlZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucXVpdEhhbmRsZXJBZGRlZCA9IHRydWU7XG4gICAgICAgIHRoaXMuYXBwLm9uY2UoXCJxdWl0XCIsICgpID0+IHtcbiAgICAgICAgICAgIGlmICghdGhpcy5xdWl0QW5kSW5zdGFsbENhbGxlZCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2xvZ2dlci5pbmZvKFwiQXV0byBpbnN0YWxsIHVwZGF0ZSBvbiBxdWl0XCIpO1xuICAgICAgICAgICAgICAgIHRoaXMuaW5zdGFsbCh0cnVlLCBmYWxzZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbn1cbmV4cG9ydHMuQmFzZVVwZGF0ZXIgPSBCYXNlVXBkYXRlcjsgLy8jIHNvdXJjZU1hcHBpbmdVUkw9QmFzZVVwZGF0ZXIuanMubWFwXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2VsZWN0cm9uLXVwZGF0ZXIvb3V0L0Jhc2VVcGRhdGVyLmpzIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuRmlsZVdpdGhFbWJlZGRlZEJsb2NrTWFwRGlmZmVyZW50aWFsRG93bmxvYWRlciA9IHVuZGVmaW5lZDtcblxudmFyIF9ibHVlYmlyZExzdDtcblxuZnVuY3Rpb24gX2xvYWRfYmx1ZWJpcmRMc3QoKSB7XG4gICAgcmV0dXJuIF9ibHVlYmlyZExzdCA9IHJlcXVpcmUoXCJibHVlYmlyZC1sc3RcIik7XG59XG5cbnZhciBfYmxvY2tNYXBBcGk7XG5cbmZ1bmN0aW9uIF9sb2FkX2Jsb2NrTWFwQXBpKCkge1xuICAgIHJldHVybiBfYmxvY2tNYXBBcGkgPSByZXF1aXJlKFwiYnVpbGRlci11dGlsLXJ1bnRpbWUvb3V0L2Jsb2NrTWFwQXBpXCIpO1xufVxuXG52YXIgX0RpZmZlcmVudGlhbERvd25sb2FkZXI7XG5cbmZ1bmN0aW9uIF9sb2FkX0RpZmZlcmVudGlhbERvd25sb2FkZXIoKSB7XG4gICAgcmV0dXJuIF9EaWZmZXJlbnRpYWxEb3dubG9hZGVyID0gcmVxdWlyZShcIi4vRGlmZmVyZW50aWFsRG93bmxvYWRlclwiKTtcbn1cblxuY2xhc3MgRmlsZVdpdGhFbWJlZGRlZEJsb2NrTWFwRGlmZmVyZW50aWFsRG93bmxvYWRlciBleHRlbmRzIChfRGlmZmVyZW50aWFsRG93bmxvYWRlciB8fCBfbG9hZF9EaWZmZXJlbnRpYWxEb3dubG9hZGVyKCkpLkRpZmZlcmVudGlhbERvd25sb2FkZXIge1xuICAgIGRvd25sb2FkKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgICAgIHJldHVybiAoMCwgKF9ibHVlYmlyZExzdCB8fCBfbG9hZF9ibHVlYmlyZExzdCgpKS5jb3JvdXRpbmUpKGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCBwYWNrYWdlSW5mbyA9IF90aGlzLmJsb2NrQXdhcmVGaWxlSW5mbztcbiAgICAgICAgICAgIGNvbnN0IGZpbGVTaXplID0gcGFja2FnZUluZm8uc2l6ZTtcbiAgICAgICAgICAgIGNvbnN0IG9mZnNldCA9IGZpbGVTaXplIC0gKHBhY2thZ2VJbmZvLmJsb2NrTWFwU2l6ZSArIDQpO1xuICAgICAgICAgICAgX3RoaXMuZmlsZU1ldGFkYXRhQnVmZmVyID0geWllbGQgX3RoaXMucmVhZFJlbW90ZUJ5dGVzKG9mZnNldCwgZmlsZVNpemUgLSAxKTtcbiAgICAgICAgICAgIGNvbnN0IG5ld0Jsb2NrTWFwID0geWllbGQgKDAsIChfRGlmZmVyZW50aWFsRG93bmxvYWRlciB8fCBfbG9hZF9EaWZmZXJlbnRpYWxEb3dubG9hZGVyKCkpLnJlYWRCbG9ja01hcCkoX3RoaXMuZmlsZU1ldGFkYXRhQnVmZmVyLnNsaWNlKDAsIF90aGlzLmZpbGVNZXRhZGF0YUJ1ZmZlci5sZW5ndGggLSA0KSk7XG4gICAgICAgICAgICB5aWVsZCBfdGhpcy5kb0Rvd25sb2FkKEpTT04ucGFyc2UoKHlpZWxkICgwLCAoX2Jsb2NrTWFwQXBpIHx8IF9sb2FkX2Jsb2NrTWFwQXBpKCkpLnJlYWRFbWJlZGRlZEJsb2NrTWFwRGF0YSkoX3RoaXMub3B0aW9ucy5vbGRGaWxlKSkpLCBuZXdCbG9ja01hcCk7XG4gICAgICAgIH0pKCk7XG4gICAgfVxufVxuZXhwb3J0cy5GaWxlV2l0aEVtYmVkZGVkQmxvY2tNYXBEaWZmZXJlbnRpYWxEb3dubG9hZGVyID0gRmlsZVdpdGhFbWJlZGRlZEJsb2NrTWFwRGlmZmVyZW50aWFsRG93bmxvYWRlcjsgLy8jIHNvdXJjZU1hcHBpbmdVUkw9RmlsZVdpdGhFbWJlZGRlZEJsb2NrTWFwRGlmZmVyZW50aWFsRG93bmxvYWRlci5qcy5tYXBcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvZWxlY3Ryb24tdXBkYXRlci9vdXQvZGlmZmVyZW50aWFsRG93bmxvYWRlci9GaWxlV2l0aEVtYmVkZGVkQmxvY2tNYXBEaWZmZXJlbnRpYWxEb3dubG9hZGVyLmpzIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMucmVhZEVtYmVkZGVkQmxvY2tNYXBEYXRhID0gZXhwb3J0cy5CTE9DS19NQVBfRklMRV9OQU1FID0gdW5kZWZpbmVkO1xuXG52YXIgX2JsdWViaXJkTHN0O1xuXG5mdW5jdGlvbiBfbG9hZF9ibHVlYmlyZExzdCgpIHtcbiAgICByZXR1cm4gX2JsdWViaXJkTHN0ID0gcmVxdWlyZShcImJsdWViaXJkLWxzdFwiKTtcbn1cblxudmFyIF9ibHVlYmlyZExzdDI7XG5cbmZ1bmN0aW9uIF9sb2FkX2JsdWViaXJkTHN0MigpIHtcbiAgICByZXR1cm4gX2JsdWViaXJkTHN0MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcImJsdWViaXJkLWxzdFwiKSk7XG59XG5cbmxldCByZWFkRW1iZWRkZWRCbG9ja01hcERhdGEgPSBleHBvcnRzLnJlYWRFbWJlZGRlZEJsb2NrTWFwRGF0YSA9ICgoKSA9PiB7XG4gICAgdmFyIF9yZWYgPSAoMCwgKF9ibHVlYmlyZExzdCB8fCBfbG9hZF9ibHVlYmlyZExzdCgpKS5jb3JvdXRpbmUpKGZ1bmN0aW9uKiAoZmlsZSkge1xuICAgICAgICBjb25zdCBmZCA9IHlpZWxkICgwLCAoX2ZzRXh0cmFQIHx8IF9sb2FkX2ZzRXh0cmFQKCkpLm9wZW4pKGZpbGUsIFwiclwiKTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IGZpbGVTaXplID0gKHlpZWxkICgwLCAoX2ZzRXh0cmFQIHx8IF9sb2FkX2ZzRXh0cmFQKCkpLmZzdGF0KShmZCkpLnNpemU7XG4gICAgICAgICAgICBjb25zdCBzaXplQnVmZmVyID0gQnVmZmVyLmFsbG9jVW5zYWZlKDQpO1xuICAgICAgICAgICAgeWllbGQgKDAsIChfZnNFeHRyYVAgfHwgX2xvYWRfZnNFeHRyYVAoKSkucmVhZCkoZmQsIHNpemVCdWZmZXIsIDAsIHNpemVCdWZmZXIubGVuZ3RoLCBmaWxlU2l6ZSAtIHNpemVCdWZmZXIubGVuZ3RoKTtcbiAgICAgICAgICAgIGNvbnN0IGRhdGFCdWZmZXIgPSBCdWZmZXIuYWxsb2NVbnNhZmUoc2l6ZUJ1ZmZlci5yZWFkVUludDMyQkUoMCkpO1xuICAgICAgICAgICAgeWllbGQgKDAsIChfZnNFeHRyYVAgfHwgX2xvYWRfZnNFeHRyYVAoKSkucmVhZCkoZmQsIGRhdGFCdWZmZXIsIDAsIGRhdGFCdWZmZXIubGVuZ3RoLCBmaWxlU2l6ZSAtIHNpemVCdWZmZXIubGVuZ3RoIC0gZGF0YUJ1ZmZlci5sZW5ndGgpO1xuICAgICAgICAgICAgeWllbGQgKDAsIChfZnNFeHRyYVAgfHwgX2xvYWRfZnNFeHRyYVAoKSkuY2xvc2UpKGZkKTtcbiAgICAgICAgICAgIGNvbnN0IGluZmxhdGVSYXcgPSAoX2JsdWViaXJkTHN0MiB8fCBfbG9hZF9ibHVlYmlyZExzdDIoKSkuZGVmYXVsdC5wcm9taXNpZnkocmVxdWlyZShcInpsaWJcIikuaW5mbGF0ZVJhdyk7XG4gICAgICAgICAgICByZXR1cm4gKHlpZWxkIGluZmxhdGVSYXcoZGF0YUJ1ZmZlcikpLnRvU3RyaW5nKCk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIHlpZWxkICgwLCAoX2ZzRXh0cmFQIHx8IF9sb2FkX2ZzRXh0cmFQKCkpLmNsb3NlKShmZCk7XG4gICAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICByZXR1cm4gZnVuY3Rpb24gcmVhZEVtYmVkZGVkQmxvY2tNYXBEYXRhKF94KSB7XG4gICAgICAgIHJldHVybiBfcmVmLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfTtcbn0pKCk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1ibG9ja01hcEFwaS5qcy5tYXBcblxuXG52YXIgX2ZzRXh0cmFQO1xuXG5mdW5jdGlvbiBfbG9hZF9mc0V4dHJhUCgpIHtcbiAgICByZXR1cm4gX2ZzRXh0cmFQID0gcmVxdWlyZShcImZzLWV4dHJhLXBcIik7XG59XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmNvbnN0IEJMT0NLX01BUF9GSUxFX05BTUUgPSBleHBvcnRzLkJMT0NLX01BUF9GSUxFX05BTUUgPSBcIl9ibG9ja01hcC5ibG9ja21hcFwiO1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9lbGVjdHJvbi11cGRhdGVyL25vZGVfbW9kdWxlcy9idWlsZGVyLXV0aWwtcnVudGltZS9vdXQvYmxvY2tNYXBBcGkuanMiLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCJ6bGliXCIpO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIGV4dGVybmFsIFwiemxpYlwiXG4vLyBtb2R1bGUgaWQgPSA2NFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5yZWFkQmxvY2tNYXAgPSBleHBvcnRzLkRpZmZlcmVudGlhbERvd25sb2FkZXIgPSBleHBvcnRzLkRpZmZlcmVudGlhbERvd25sb2FkZXJPcHRpb25zID0gdW5kZWZpbmVkO1xuXG52YXIgX2JsdWViaXJkTHN0O1xuXG5mdW5jdGlvbiBfbG9hZF9ibHVlYmlyZExzdCgpIHtcbiAgICByZXR1cm4gX2JsdWViaXJkTHN0ID0gcmVxdWlyZShcImJsdWViaXJkLWxzdFwiKTtcbn1cblxudmFyIF9ibHVlYmlyZExzdDI7XG5cbmZ1bmN0aW9uIF9sb2FkX2JsdWViaXJkTHN0MigpIHtcbiAgICByZXR1cm4gX2JsdWViaXJkTHN0MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcImJsdWViaXJkLWxzdFwiKSk7XG59XG5cbmxldCByZWFkQmxvY2tNYXAgPSBleHBvcnRzLnJlYWRCbG9ja01hcCA9ICgoKSA9PiB7XG4gICAgdmFyIF9yZWYgPSAoMCwgKF9ibHVlYmlyZExzdCB8fCBfbG9hZF9ibHVlYmlyZExzdCgpKS5jb3JvdXRpbmUpKGZ1bmN0aW9uKiAoZGF0YSkge1xuICAgICAgICByZXR1cm4gSlNPTi5wYXJzZSgoeWllbGQgaW5mbGF0ZVJhdyhkYXRhKSkudG9TdHJpbmcoKSk7XG4gICAgfSk7XG5cbiAgICByZXR1cm4gZnVuY3Rpb24gcmVhZEJsb2NrTWFwKF94KSB7XG4gICAgICAgIHJldHVybiBfcmVmLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfTtcbn0pKCk7XG5cbnZhciBfYnVpbGRlclV0aWxSdW50aW1lO1xuXG5mdW5jdGlvbiBfbG9hZF9idWlsZGVyVXRpbFJ1bnRpbWUoKSB7XG4gICAgcmV0dXJuIF9idWlsZGVyVXRpbFJ1bnRpbWUgPSByZXF1aXJlKFwiYnVpbGRlci11dGlsLXJ1bnRpbWVcIik7XG59XG5cbnZhciBfZnNFeHRyYVA7XG5cbmZ1bmN0aW9uIF9sb2FkX2ZzRXh0cmFQKCkge1xuICAgIHJldHVybiBfZnNFeHRyYVAgPSByZXF1aXJlKFwiZnMtZXh0cmEtcFwiKTtcbn1cblxudmFyIF9EYXRhU3BsaXR0ZXI7XG5cbmZ1bmN0aW9uIF9sb2FkX0RhdGFTcGxpdHRlcigpIHtcbiAgICByZXR1cm4gX0RhdGFTcGxpdHRlciA9IHJlcXVpcmUoXCIuL0RhdGFTcGxpdHRlclwiKTtcbn1cblxudmFyIF9kb3dubG9hZFBsYW5CdWlsZGVyO1xuXG5mdW5jdGlvbiBfbG9hZF9kb3dubG9hZFBsYW5CdWlsZGVyKCkge1xuICAgIHJldHVybiBfZG93bmxvYWRQbGFuQnVpbGRlciA9IHJlcXVpcmUoXCIuL2Rvd25sb2FkUGxhbkJ1aWxkZXJcIik7XG59XG5cbnZhciBfbXVsdGlwbGVSYW5nZURvd25sb2FkZXI7XG5cbmZ1bmN0aW9uIF9sb2FkX211bHRpcGxlUmFuZ2VEb3dubG9hZGVyKCkge1xuICAgIHJldHVybiBfbXVsdGlwbGVSYW5nZURvd25sb2FkZXIgPSByZXF1aXJlKFwiLi9tdWx0aXBsZVJhbmdlRG93bmxvYWRlclwiKTtcbn1cblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuY29uc3QgaW5mbGF0ZVJhdyA9IChfYmx1ZWJpcmRMc3QyIHx8IF9sb2FkX2JsdWViaXJkTHN0MigpKS5kZWZhdWx0LnByb21pc2lmeShyZXF1aXJlKFwiemxpYlwiKS5pbmZsYXRlUmF3KTtcbmNsYXNzIERpZmZlcmVudGlhbERvd25sb2FkZXJPcHRpb25zIHt9XG5leHBvcnRzLkRpZmZlcmVudGlhbERvd25sb2FkZXJPcHRpb25zID0gRGlmZmVyZW50aWFsRG93bmxvYWRlck9wdGlvbnM7XG5jbGFzcyBEaWZmZXJlbnRpYWxEb3dubG9hZGVyIHtcbiAgICAvLyBub2luc3BlY3Rpb24gVHlwZVNjcmlwdEFic3RyYWN0Q2xhc3NDb25zdHJ1Y3RvckNhbkJlTWFkZVByb3RlY3RlZFxuICAgIGNvbnN0cnVjdG9yKGJsb2NrQXdhcmVGaWxlSW5mbywgaHR0cEV4ZWN1dG9yLCBvcHRpb25zKSB7XG4gICAgICAgIHRoaXMuYmxvY2tBd2FyZUZpbGVJbmZvID0gYmxvY2tBd2FyZUZpbGVJbmZvO1xuICAgICAgICB0aGlzLmh0dHBFeGVjdXRvciA9IGh0dHBFeGVjdXRvcjtcbiAgICAgICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgICAgICAgdGhpcy5sb2dnZXIgPSBvcHRpb25zLmxvZ2dlcjtcbiAgICAgICAgdGhpcy5iYXNlUmVxdWVzdE9wdGlvbnMgPSAoMCwgKF9idWlsZGVyVXRpbFJ1bnRpbWUgfHwgX2xvYWRfYnVpbGRlclV0aWxSdW50aW1lKCkpLmNvbmZpZ3VyZVJlcXVlc3RPcHRpb25zRnJvbVVybCkob3B0aW9ucy5uZXdVcmwsIHt9KTtcbiAgICB9XG4gICAgZ2V0IHNpZ25hdHVyZVNpemUoKSB7XG4gICAgICAgIHJldHVybiAwO1xuICAgIH1cbiAgICBjcmVhdGVSZXF1ZXN0T3B0aW9ucyhtZXRob2QgPSBcImdldFwiLCBuZXdVcmwpIHtcbiAgICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oe30sIG5ld1VybCA9PSBudWxsID8gdGhpcy5iYXNlUmVxdWVzdE9wdGlvbnMgOiAoMCwgKF9idWlsZGVyVXRpbFJ1bnRpbWUgfHwgX2xvYWRfYnVpbGRlclV0aWxSdW50aW1lKCkpLmNvbmZpZ3VyZVJlcXVlc3RPcHRpb25zRnJvbVVybCkobmV3VXJsLCB7fSksIHsgbWV0aG9kLCBoZWFkZXJzOiBPYmplY3QuYXNzaWduKHt9LCB0aGlzLm9wdGlvbnMucmVxdWVzdEhlYWRlcnMsIHsgQWNjZXB0OiBcIiovKlwiIH0pIH0pO1xuICAgIH1cbiAgICBkb0Rvd25sb2FkKG9sZEJsb2NrTWFwLCBuZXdCbG9ja01hcCkge1xuICAgICAgICAvLyB3ZSBkb24ndCBjaGVjayBvdGhlciBtZXRhZGF0YSBsaWtlIGNvbXByZXNzaW9uTWV0aG9kIC0gZ2VuZXJpYyBjaGVjayB0aGF0IGl0IGlzIG1ha2Ugc2Vuc2UgdG8gZGlmZmVyZW50aWFsbHkgdXBkYXRlIGlzIHN1aXRhYmxlIGZvciBpdFxuICAgICAgICBpZiAob2xkQmxvY2tNYXAudmVyc2lvbiAhPT0gbmV3QmxvY2tNYXAudmVyc2lvbikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGB2ZXJzaW9uIGlzIGRpZmZlcmVudCAoJHtvbGRCbG9ja01hcC52ZXJzaW9ufSAtICR7bmV3QmxvY2tNYXAudmVyc2lvbn0pLCBmdWxsIGRvd25sb2FkIGlzIHJlcXVpcmVkYCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbG9nZ2VyID0gdGhpcy5sb2dnZXI7XG4gICAgICAgIGNvbnN0IG9wZXJhdGlvbnMgPSAoMCwgKF9kb3dubG9hZFBsYW5CdWlsZGVyIHx8IF9sb2FkX2Rvd25sb2FkUGxhbkJ1aWxkZXIoKSkuY29tcHV0ZU9wZXJhdGlvbnMpKG9sZEJsb2NrTWFwLCBuZXdCbG9ja01hcCwgbG9nZ2VyKTtcbiAgICAgICAgaWYgKGxvZ2dlci5kZWJ1ZyAhPSBudWxsKSB7XG4gICAgICAgICAgICBsb2dnZXIuZGVidWcoSlNPTi5zdHJpbmdpZnkob3BlcmF0aW9ucywgbnVsbCwgMikpO1xuICAgICAgICB9XG4gICAgICAgIGxldCBkb3dubG9hZFNpemUgPSAwO1xuICAgICAgICBsZXQgY29weVNpemUgPSAwO1xuICAgICAgICBmb3IgKGNvbnN0IG9wZXJhdGlvbiBvZiBvcGVyYXRpb25zKSB7XG4gICAgICAgICAgICBjb25zdCBsZW5ndGggPSBvcGVyYXRpb24uZW5kIC0gb3BlcmF0aW9uLnN0YXJ0O1xuICAgICAgICAgICAgaWYgKG9wZXJhdGlvbi5raW5kID09PSAoX2Rvd25sb2FkUGxhbkJ1aWxkZXIgfHwgX2xvYWRfZG93bmxvYWRQbGFuQnVpbGRlcigpKS5PcGVyYXRpb25LaW5kLkRPV05MT0FEKSB7XG4gICAgICAgICAgICAgICAgZG93bmxvYWRTaXplICs9IGxlbmd0aDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgY29weVNpemUgKz0gbGVuZ3RoO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG5ld1BhY2thZ2VTaXplID0gdGhpcy5ibG9ja0F3YXJlRmlsZUluZm8uc2l6ZTtcbiAgICAgICAgaWYgKGRvd25sb2FkU2l6ZSArIGNvcHlTaXplICsgKHRoaXMuZmlsZU1ldGFkYXRhQnVmZmVyID09IG51bGwgPyAwIDogdGhpcy5maWxlTWV0YWRhdGFCdWZmZXIubGVuZ3RoKSArIHRoaXMuc2lnbmF0dXJlU2l6ZSAhPT0gbmV3UGFja2FnZVNpemUpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgSW50ZXJuYWwgZXJyb3IsIHNpemUgbWlzbWF0Y2g6IGRvd25sb2FkU2l6ZTogJHtkb3dubG9hZFNpemV9LCBjb3B5U2l6ZTogJHtjb3B5U2l6ZX0sIG5ld1BhY2thZ2VTaXplOiAke25ld1BhY2thZ2VTaXplfWApO1xuICAgICAgICB9XG4gICAgICAgIGxvZ2dlci5pbmZvKGBGdWxsOiAke2Zvcm1hdEJ5dGVzKG5ld1BhY2thZ2VTaXplKX0sIFRvIGRvd25sb2FkOiAke2Zvcm1hdEJ5dGVzKGRvd25sb2FkU2l6ZSl9ICgke01hdGgucm91bmQoZG93bmxvYWRTaXplIC8gKG5ld1BhY2thZ2VTaXplIC8gMTAwKSl9JSlgKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuZG93bmxvYWRGaWxlKG9wZXJhdGlvbnMpO1xuICAgIH1cbiAgICBkb3dubG9hZEZpbGUodGFza3MpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgICAgICByZXR1cm4gKDAsIChfYmx1ZWJpcmRMc3QgfHwgX2xvYWRfYmx1ZWJpcmRMc3QoKSkuY29yb3V0aW5lKShmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3Qgc2lnbmF0dXJlID0gX3RoaXMuc2lnbmF0dXJlU2l6ZSA9PT0gMCA/IG51bGwgOiB5aWVsZCBfdGhpcy5yZWFkUmVtb3RlQnl0ZXMoMCwgX3RoaXMuc2lnbmF0dXJlU2l6ZSAtIDEpO1xuICAgICAgICAgICAgY29uc3Qgb2xkRmlsZUZkID0geWllbGQgKDAsIChfZnNFeHRyYVAgfHwgX2xvYWRfZnNFeHRyYVAoKSkub3BlbikoX3RoaXMub3B0aW9ucy5vbGRGaWxlLCBcInJcIik7XG4gICAgICAgICAgICBjb25zdCBuZXdGaWxlRmQgPSB5aWVsZCAoMCwgKF9mc0V4dHJhUCB8fCBfbG9hZF9mc0V4dHJhUCgpKS5vcGVuKShfdGhpcy5vcHRpb25zLm5ld0ZpbGUsIFwid1wiKTtcbiAgICAgICAgICAgIGNvbnN0IGZpbGVPdXQgPSAoMCwgKF9mc0V4dHJhUCB8fCBfbG9hZF9mc0V4dHJhUCgpKS5jcmVhdGVXcml0ZVN0cmVhbSkoX3RoaXMub3B0aW9ucy5uZXdGaWxlLCB7IGZkOiBuZXdGaWxlRmQgfSk7XG4gICAgICAgICAgICB5aWVsZCBuZXcgKF9ibHVlYmlyZExzdDIgfHwgX2xvYWRfYmx1ZWJpcmRMc3QyKCkpLmRlZmF1bHQoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHN0cmVhbXMgPSBbXTtcbiAgICAgICAgICAgICAgICBjb25zdCBkaWdlc3RUcmFuc2Zvcm0gPSBuZXcgKF9idWlsZGVyVXRpbFJ1bnRpbWUgfHwgX2xvYWRfYnVpbGRlclV0aWxSdW50aW1lKCkpLkRpZ2VzdFRyYW5zZm9ybShfdGhpcy5ibG9ja0F3YXJlRmlsZUluZm8uc2hhNTEyKTtcbiAgICAgICAgICAgICAgICAvLyB0byBzaW1wbHkgZGVidWcsIGRvIG1hbnVhbCB2YWxpZGF0aW9uIHRvIGFsbG93IGZpbGUgdG8gYmUgZnVsbHkgd3JpdHRlblxuICAgICAgICAgICAgICAgIGRpZ2VzdFRyYW5zZm9ybS5pc1ZhbGlkYXRlT25FbmQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBzdHJlYW1zLnB1c2goZGlnZXN0VHJhbnNmb3JtKTtcbiAgICAgICAgICAgICAgICAvLyBub2luc3BlY3Rpb24gSlNBcnJvd0Z1bmN0aW9uQ2FuQmVSZXBsYWNlZFdpdGhTaG9ydGhhbmRcbiAgICAgICAgICAgICAgICBmaWxlT3V0Lm9uKFwiZmluaXNoXCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgZmlsZU91dC5jbG9zZShmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRpZ2VzdFRyYW5zZm9ybS52YWxpZGF0ZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlamVjdChlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHN0cmVhbXMucHVzaChmaWxlT3V0KTtcbiAgICAgICAgICAgICAgICBsZXQgbGFzdFN0cmVhbSA9IG51bGw7XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBzdHJlYW0gb2Ygc3RyZWFtcykge1xuICAgICAgICAgICAgICAgICAgICBzdHJlYW0ub24oXCJlcnJvclwiLCByZWplY3QpO1xuICAgICAgICAgICAgICAgICAgICBpZiAobGFzdFN0cmVhbSA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsYXN0U3RyZWFtID0gc3RyZWFtO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGFzdFN0cmVhbSA9IGxhc3RTdHJlYW0ucGlwZShzdHJlYW0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IGZpcnN0U3RyZWFtID0gc3RyZWFtc1swXTtcbiAgICAgICAgICAgICAgICBsZXQgdztcbiAgICAgICAgICAgICAgICBpZiAoX3RoaXMub3B0aW9ucy51c2VNdWx0aXBsZVJhbmdlUmVxdWVzdCkge1xuICAgICAgICAgICAgICAgICAgICB3ID0gKDAsIChfbXVsdGlwbGVSYW5nZURvd25sb2FkZXIgfHwgX2xvYWRfbXVsdGlwbGVSYW5nZURvd25sb2FkZXIoKSkuZXhlY3V0ZVRhc2tzKShfdGhpcywgdGFza3MsIGZpcnN0U3RyZWFtLCBvbGRGaWxlRmQsIHJlamVjdCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGF0dGVtcHRDb3VudCA9IDA7XG4gICAgICAgICAgICAgICAgICAgIGxldCBhY3R1YWxVcmwgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5sb2dnZXIuaW5mbyhgRGlmZmVyZW50aWFsIGRvd25sb2FkOiAke190aGlzLm9wdGlvbnMubmV3VXJsfWApO1xuICAgICAgICAgICAgICAgICAgICB3ID0gZnVuY3Rpb24gKGluZGV4KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaW5kZXggPj0gdGFza3MubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKF90aGlzLmZpbGVNZXRhZGF0YUJ1ZmZlciAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZpcnN0U3RyZWFtLndyaXRlKF90aGlzLmZpbGVNZXRhZGF0YUJ1ZmZlcik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZpcnN0U3RyZWFtLmVuZCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IG9wZXJhdGlvbiA9IHRhc2tzW2luZGV4KytdO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG9wZXJhdGlvbi5raW5kID09PSAoX2Rvd25sb2FkUGxhbkJ1aWxkZXIgfHwgX2xvYWRfZG93bmxvYWRQbGFuQnVpbGRlcigpKS5PcGVyYXRpb25LaW5kLkNPUFkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAoMCwgKF9EYXRhU3BsaXR0ZXIgfHwgX2xvYWRfRGF0YVNwbGl0dGVyKCkpLmNvcHlEYXRhKShvcGVyYXRpb24sIGZpcnN0U3RyZWFtLCBvbGRGaWxlRmQsIHJlamVjdCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdyhpbmRleCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlcXVlc3RPcHRpb25zID0gX3RoaXMuY3JlYXRlUmVxdWVzdE9wdGlvbnMoXCJnZXRcIiwgYWN0dWFsVXJsKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCByYW5nZSA9IGBieXRlcz0ke29wZXJhdGlvbi5zdGFydH0tJHtvcGVyYXRpb24uZW5kIC0gMX1gO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlcXVlc3RPcHRpb25zLmhlYWRlcnMuUmFuZ2UgPSByYW5nZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXF1ZXN0T3B0aW9ucy5yZWRpcmVjdCA9IFwibWFudWFsXCI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZGVidWcgPSBfdGhpcy5sb2dnZXIuZGVidWc7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGRlYnVnICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVidWcoYGVmZmVjdGl2ZSB1cmw6ICR7YWN0dWFsVXJsID09IG51bGwgPyBcIlwiIDogcmVtb3ZlUXVlcnkoYWN0dWFsVXJsKX0sIHJhbmdlOiAke3JhbmdlfWApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCByZXF1ZXN0ID0gX3RoaXMuaHR0cEV4ZWN1dG9yLmRvUmVxdWVzdChyZXF1ZXN0T3B0aW9ucywgZnVuY3Rpb24gKHJlc3BvbnNlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEVsZWN0cm9uIG5ldCBoYW5kbGVzIHJlZGlyZWN0cyBhdXRvbWF0aWNhbGx5LCBvdXIgTm9kZUpTIHRlc3Qgc2VydmVyIGRvZXNuJ3QgdXNlIHJlZGlyZWN0cyAtIHNvLCB3ZSBkb24ndCBjaGVjayAzeHggY29kZXMuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyZXNwb25zZS5zdGF0dXNDb2RlID49IDQwMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVqZWN0KCgwLCAoX2J1aWxkZXJVdGlsUnVudGltZSB8fCBfbG9hZF9idWlsZGVyVXRpbFJ1bnRpbWUoKSkuY3JlYXRlSHR0cEVycm9yKShyZXNwb25zZSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlLnBpcGUoZmlyc3RTdHJlYW0sIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVuZDogZmFsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlLm9uY2UoXCJlbmRcIiwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCsrYXR0ZW1wdENvdW50ID09PSAxMDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhdHRlbXB0Q291bnQgPSAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdyhpbmRleCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSwgMTAwMCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHcoaW5kZXgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXF1ZXN0Lm9uKFwicmVkaXJlY3RcIiwgZnVuY3Rpb24gKHN0YXR1c0NvZGUsIG1ldGhvZCwgcmVkaXJlY3RVcmwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMubG9nZ2VyLmluZm8oYFJlZGlyZWN0IHRvICR7cmVtb3ZlUXVlcnkocmVkaXJlY3RVcmwpfWApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhY3R1YWxVcmwgPSByZWRpcmVjdFVybDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVxdWVzdC5mb2xsb3dSZWRpcmVjdCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLmh0dHBFeGVjdXRvci5hZGRFcnJvckFuZFRpbWVvdXRIYW5kbGVycyhyZXF1ZXN0LCByZWplY3QpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlcXVlc3QuZW5kKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChzaWduYXR1cmUgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICB3KDApO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGZpcnN0U3RyZWFtLndyaXRlKHNpZ25hdHVyZSwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHcoMCk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiAoMCwgKF9mc0V4dHJhUCB8fCBfbG9hZF9mc0V4dHJhUCgpKS5jbG9zZSkob2xkRmlsZUZkKTtcbiAgICAgICAgICAgIH0pLmNhdGNoKGZ1bmN0aW9uIChlcnJvcikge1xuICAgICAgICAgICAgICAgICgwLCAoX2ZzRXh0cmFQIHx8IF9sb2FkX2ZzRXh0cmFQKCkpLmNsb3NlU3luYykob2xkRmlsZUZkKTtcbiAgICAgICAgICAgICAgICAoMCwgKF9mc0V4dHJhUCB8fCBfbG9hZF9mc0V4dHJhUCgpKS5jbG9zZVN5bmMpKG5ld0ZpbGVGZCk7XG4gICAgICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSkoKTtcbiAgICB9XG4gICAgcmVhZFJlbW90ZUJ5dGVzKHN0YXJ0LCBlbmRJbmNsdXNpdmUpIHtcbiAgICAgICAgdmFyIF90aGlzMiA9IHRoaXM7XG5cbiAgICAgICAgcmV0dXJuICgwLCAoX2JsdWViaXJkTHN0IHx8IF9sb2FkX2JsdWViaXJkTHN0KCkpLmNvcm91dGluZSkoZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGNvbnN0IGJ1ZmZlciA9IEJ1ZmZlci5hbGxvY1Vuc2FmZShlbmRJbmNsdXNpdmUgKyAxIC0gc3RhcnQpO1xuICAgICAgICAgICAgY29uc3QgcmVxdWVzdE9wdGlvbnMgPSBfdGhpczIuY3JlYXRlUmVxdWVzdE9wdGlvbnMoKTtcbiAgICAgICAgICAgIHJlcXVlc3RPcHRpb25zLmhlYWRlcnMuUmFuZ2UgPSBgYnl0ZXM9JHtzdGFydH0tJHtlbmRJbmNsdXNpdmV9YDtcbiAgICAgICAgICAgIGxldCBwb3NpdGlvbiA9IDA7XG4gICAgICAgICAgICB5aWVsZCBfdGhpczIucmVxdWVzdChyZXF1ZXN0T3B0aW9ucywgZnVuY3Rpb24gKGNodW5rKSB7XG4gICAgICAgICAgICAgICAgY2h1bmsuY29weShidWZmZXIsIHBvc2l0aW9uKTtcbiAgICAgICAgICAgICAgICBwb3NpdGlvbiArPSBjaHVuay5sZW5ndGg7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBidWZmZXI7XG4gICAgICAgIH0pKCk7XG4gICAgfVxuICAgIHJlcXVlc3QocmVxdWVzdE9wdGlvbnMsIGRhdGFIYW5kbGVyKSB7XG4gICAgICAgIHJldHVybiBuZXcgKF9ibHVlYmlyZExzdDIgfHwgX2xvYWRfYmx1ZWJpcmRMc3QyKCkpLmRlZmF1bHQoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgcmVxdWVzdCA9IHRoaXMuaHR0cEV4ZWN1dG9yLmRvUmVxdWVzdChyZXF1ZXN0T3B0aW9ucywgcmVzcG9uc2UgPT4ge1xuICAgICAgICAgICAgICAgIGlmICghKDAsIChfbXVsdGlwbGVSYW5nZURvd25sb2FkZXIgfHwgX2xvYWRfbXVsdGlwbGVSYW5nZURvd25sb2FkZXIoKSkuY2hlY2tJc1Jhbmdlc1N1cHBvcnRlZCkocmVzcG9uc2UsIHJlamVjdCkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXNwb25zZS5vbihcImRhdGFcIiwgZGF0YUhhbmRsZXIpO1xuICAgICAgICAgICAgICAgIHJlc3BvbnNlLm9uKFwiZW5kXCIsICgpID0+IHJlc29sdmUoKSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRoaXMuaHR0cEV4ZWN1dG9yLmFkZEVycm9yQW5kVGltZW91dEhhbmRsZXJzKHJlcXVlc3QsIHJlamVjdCk7XG4gICAgICAgICAgICByZXF1ZXN0LmVuZCgpO1xuICAgICAgICB9KTtcbiAgICB9XG59XG5leHBvcnRzLkRpZmZlcmVudGlhbERvd25sb2FkZXIgPSBEaWZmZXJlbnRpYWxEb3dubG9hZGVyO1xuXG5mdW5jdGlvbiBmb3JtYXRCeXRlcyh2YWx1ZSwgc3ltYm9sID0gXCIgS0JcIikge1xuICAgIHJldHVybiBuZXcgSW50bC5OdW1iZXJGb3JtYXQoXCJlblwiKS5mb3JtYXQoKHZhbHVlIC8gMTAyNCkudG9GaXhlZCgyKSkgKyBzeW1ib2w7XG59XG4vLyBzYWZldHlcbmZ1bmN0aW9uIHJlbW92ZVF1ZXJ5KHVybCkge1xuICAgIGNvbnN0IGluZGV4ID0gdXJsLmluZGV4T2YoXCI/XCIpO1xuICAgIHJldHVybiBpbmRleCA8IDAgPyB1cmwgOiB1cmwuc3Vic3RyaW5nKDAsIGluZGV4KTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPURpZmZlcmVudGlhbERvd25sb2FkZXIuanMubWFwXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2VsZWN0cm9uLXVwZGF0ZXIvb3V0L2RpZmZlcmVudGlhbERvd25sb2FkZXIvRGlmZmVyZW50aWFsRG93bmxvYWRlci5qcyIsIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLkRhdGFTcGxpdHRlciA9IHVuZGVmaW5lZDtcblxudmFyIF9ibHVlYmlyZExzdDtcblxuZnVuY3Rpb24gX2xvYWRfYmx1ZWJpcmRMc3QoKSB7XG4gICAgcmV0dXJuIF9ibHVlYmlyZExzdCA9IHJlcXVpcmUoXCJibHVlYmlyZC1sc3RcIik7XG59XG5cbnZhciBfYmx1ZWJpcmRMc3QyO1xuXG5mdW5jdGlvbiBfbG9hZF9ibHVlYmlyZExzdDIoKSB7XG4gICAgcmV0dXJuIF9ibHVlYmlyZExzdDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJibHVlYmlyZC1sc3RcIikpO1xufVxuXG5leHBvcnRzLmNvcHlEYXRhID0gY29weURhdGE7XG5cbnZhciBfYnVpbGRlclV0aWxSdW50aW1lO1xuXG5mdW5jdGlvbiBfbG9hZF9idWlsZGVyVXRpbFJ1bnRpbWUoKSB7XG4gICAgcmV0dXJuIF9idWlsZGVyVXRpbFJ1bnRpbWUgPSByZXF1aXJlKFwiYnVpbGRlci11dGlsLXJ1bnRpbWVcIik7XG59XG5cbnZhciBfZnNFeHRyYVA7XG5cbmZ1bmN0aW9uIF9sb2FkX2ZzRXh0cmFQKCkge1xuICAgIHJldHVybiBfZnNFeHRyYVAgPSByZXF1aXJlKFwiZnMtZXh0cmEtcFwiKTtcbn1cblxudmFyIF9zdHJlYW07XG5cbmZ1bmN0aW9uIF9sb2FkX3N0cmVhbSgpIHtcbiAgICByZXR1cm4gX3N0cmVhbSA9IHJlcXVpcmUoXCJzdHJlYW1cIik7XG59XG5cbnZhciBfZG93bmxvYWRQbGFuQnVpbGRlcjtcblxuZnVuY3Rpb24gX2xvYWRfZG93bmxvYWRQbGFuQnVpbGRlcigpIHtcbiAgICByZXR1cm4gX2Rvd25sb2FkUGxhbkJ1aWxkZXIgPSByZXF1aXJlKFwiLi9kb3dubG9hZFBsYW5CdWlsZGVyXCIpO1xufVxuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5jb25zdCBET1VCTEVfQ1JMRiA9IEJ1ZmZlci5mcm9tKFwiXFxyXFxuXFxyXFxuXCIpO1xudmFyIFJlYWRTdGF0ZTtcbihmdW5jdGlvbiAoUmVhZFN0YXRlKSB7XG4gICAgUmVhZFN0YXRlW1JlYWRTdGF0ZVtcIklOSVRcIl0gPSAwXSA9IFwiSU5JVFwiO1xuICAgIFJlYWRTdGF0ZVtSZWFkU3RhdGVbXCJIRUFERVJcIl0gPSAxXSA9IFwiSEVBREVSXCI7XG4gICAgUmVhZFN0YXRlW1JlYWRTdGF0ZVtcIkJPRFlcIl0gPSAyXSA9IFwiQk9EWVwiO1xufSkoUmVhZFN0YXRlIHx8IChSZWFkU3RhdGUgPSB7fSkpO1xuZnVuY3Rpb24gY29weURhdGEodGFzaywgb3V0LCBvbGRGaWxlRmQsIHJlamVjdCwgcmVzb2x2ZSkge1xuICAgIGNvbnN0IHJlYWRTdHJlYW0gPSAoMCwgKF9mc0V4dHJhUCB8fCBfbG9hZF9mc0V4dHJhUCgpKS5jcmVhdGVSZWFkU3RyZWFtKShcIlwiLCB7XG4gICAgICAgIGZkOiBvbGRGaWxlRmQsXG4gICAgICAgIGF1dG9DbG9zZTogZmFsc2UsXG4gICAgICAgIHN0YXJ0OiB0YXNrLnN0YXJ0LFxuICAgICAgICAvLyBlbmQgaXMgaW5jbHVzaXZlXG4gICAgICAgIGVuZDogdGFzay5lbmQgLSAxXG4gICAgfSk7XG4gICAgcmVhZFN0cmVhbS5vbihcImVycm9yXCIsIHJlamVjdCk7XG4gICAgcmVhZFN0cmVhbS5vbmNlKFwiZW5kXCIsIHJlc29sdmUpO1xuICAgIHJlYWRTdHJlYW0ucGlwZShvdXQsIHtcbiAgICAgICAgZW5kOiBmYWxzZVxuICAgIH0pO1xufVxuY2xhc3MgRGF0YVNwbGl0dGVyIGV4dGVuZHMgKF9zdHJlYW0gfHwgX2xvYWRfc3RyZWFtKCkpLldyaXRhYmxlIHtcbiAgICBjb25zdHJ1Y3RvcihvdXQsIG9wdGlvbnMsIHBhcnRJbmRleFRvVGFza0luZGV4LCBib3VuZGFyeSwgcGFydEluZGV4VG9MZW5ndGgsIGZpbmlzaEhhbmRsZXIpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5vdXQgPSBvdXQ7XG4gICAgICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgICAgIHRoaXMucGFydEluZGV4VG9UYXNrSW5kZXggPSBwYXJ0SW5kZXhUb1Rhc2tJbmRleDtcbiAgICAgICAgdGhpcy5wYXJ0SW5kZXhUb0xlbmd0aCA9IHBhcnRJbmRleFRvTGVuZ3RoO1xuICAgICAgICB0aGlzLmZpbmlzaEhhbmRsZXIgPSBmaW5pc2hIYW5kbGVyO1xuICAgICAgICB0aGlzLnBhcnRJbmRleCA9IC0xO1xuICAgICAgICB0aGlzLmhlYWRlckxpc3RCdWZmZXIgPSBudWxsO1xuICAgICAgICB0aGlzLnJlYWRTdGF0ZSA9IFJlYWRTdGF0ZS5JTklUO1xuICAgICAgICB0aGlzLmlnbm9yZUJ5dGVDb3VudCA9IDA7XG4gICAgICAgIHRoaXMucmVtYWluaW5nUGFydERhdGFDb3VudCA9IDA7XG4gICAgICAgIHRoaXMuYWN0dWFsUGFydExlbmd0aCA9IDA7XG4gICAgICAgIHRoaXMuYm91bmRhcnlMZW5ndGggPSBib3VuZGFyeS5sZW5ndGggKyA0OyAvKiBzaXplIG9mIFxcclxcbi0tICovXG4gICAgICAgIC8vIGZpcnN0IGNodW5rIGRvZXNuJ3Qgc3RhcnQgd2l0aCBcXHJcXG5cbiAgICAgICAgdGhpcy5pZ25vcmVCeXRlQ291bnQgPSB0aGlzLmJvdW5kYXJ5TGVuZ3RoIC0gMjtcbiAgICB9XG4gICAgZ2V0IGlzRmluaXNoZWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnBhcnRJbmRleCA9PT0gdGhpcy5wYXJ0SW5kZXhUb0xlbmd0aC5sZW5ndGg7XG4gICAgfVxuICAgIC8vIG5vaW5zcGVjdGlvbiBKU1VudXNlZEdsb2JhbFN5bWJvbHNcbiAgICBfd3JpdGUoZGF0YSwgZW5jb2RpbmcsIGNhbGxiYWNrKSB7XG4gICAgICAgIGlmICh0aGlzLmlzRmluaXNoZWQpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoYFRyYWlsaW5nIGlnbm9yZWQgZGF0YTogJHtkYXRhLmxlbmd0aH0gYnl0ZXNgKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmhhbmRsZURhdGEoZGF0YSkudGhlbihjYWxsYmFjaykuY2F0Y2goY2FsbGJhY2spO1xuICAgIH1cbiAgICBoYW5kbGVEYXRhKGNodW5rKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICAgICAgcmV0dXJuICgwLCAoX2JsdWViaXJkTHN0IHx8IF9sb2FkX2JsdWViaXJkTHN0KCkpLmNvcm91dGluZSkoZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGxldCBzdGFydCA9IDA7XG4gICAgICAgICAgICBpZiAoX3RoaXMuaWdub3JlQnl0ZUNvdW50ICE9PSAwICYmIF90aGlzLnJlbWFpbmluZ1BhcnREYXRhQ291bnQgIT09IDApIHtcbiAgICAgICAgICAgICAgICB0aHJvdyAoMCwgKF9idWlsZGVyVXRpbFJ1bnRpbWUgfHwgX2xvYWRfYnVpbGRlclV0aWxSdW50aW1lKCkpLm5ld0Vycm9yKShcIkludGVybmFsIGVycm9yXCIsIFwiRVJSX0RBVEFfU1BMSVRURVJfQllURV9DT1VOVF9NSVNNQVRDSFwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChfdGhpcy5pZ25vcmVCeXRlQ291bnQgPiAwKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgdG9JZ25vcmUgPSBNYXRoLm1pbihfdGhpcy5pZ25vcmVCeXRlQ291bnQsIGNodW5rLmxlbmd0aCk7XG4gICAgICAgICAgICAgICAgX3RoaXMuaWdub3JlQnl0ZUNvdW50IC09IHRvSWdub3JlO1xuICAgICAgICAgICAgICAgIHN0YXJ0ID0gdG9JZ25vcmU7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKF90aGlzLnJlbWFpbmluZ1BhcnREYXRhQ291bnQgPiAwKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgdG9SZWFkID0gTWF0aC5taW4oX3RoaXMucmVtYWluaW5nUGFydERhdGFDb3VudCwgY2h1bmsubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICBfdGhpcy5yZW1haW5pbmdQYXJ0RGF0YUNvdW50IC09IHRvUmVhZDtcbiAgICAgICAgICAgICAgICB5aWVsZCBfdGhpcy5wcm9jZXNzUGFydERhdGEoY2h1bmssIDAsIHRvUmVhZCk7XG4gICAgICAgICAgICAgICAgc3RhcnQgPSB0b1JlYWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoc3RhcnQgPT09IGNodW5rLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChfdGhpcy5yZWFkU3RhdGUgPT09IFJlYWRTdGF0ZS5IRUFERVIpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBoZWFkZXJMaXN0RW5kID0gX3RoaXMuc2VhcmNoSGVhZGVyTGlzdEVuZChjaHVuaywgc3RhcnQpO1xuICAgICAgICAgICAgICAgIGlmIChoZWFkZXJMaXN0RW5kID09PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHN0YXJ0ID0gaGVhZGVyTGlzdEVuZDtcbiAgICAgICAgICAgICAgICBfdGhpcy5yZWFkU3RhdGUgPSBSZWFkU3RhdGUuQk9EWTtcbiAgICAgICAgICAgICAgICAvLyBoZWFkZXIgbGlzdCBpcyBpZ25vcmVkLCB3ZSBkb24ndCBuZWVkIGl0XG4gICAgICAgICAgICAgICAgX3RoaXMuaGVhZGVyTGlzdEJ1ZmZlciA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICAgICAgICAgIGlmIChfdGhpcy5yZWFkU3RhdGUgPT09IFJlYWRTdGF0ZS5CT0RZKSB7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLnJlYWRTdGF0ZSA9IFJlYWRTdGF0ZS5JTklUO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLnBhcnRJbmRleCsrO1xuICAgICAgICAgICAgICAgICAgICBsZXQgdGFza0luZGV4ID0gX3RoaXMucGFydEluZGV4VG9UYXNrSW5kZXguZ2V0KF90aGlzLnBhcnRJbmRleCk7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0YXNrSW5kZXggPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKF90aGlzLmlzRmluaXNoZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0YXNrSW5kZXggPSBfdGhpcy5vcHRpb25zLmVuZDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgKDAsIChfYnVpbGRlclV0aWxSdW50aW1lIHx8IF9sb2FkX2J1aWxkZXJVdGlsUnVudGltZSgpKS5uZXdFcnJvcikoXCJ0YXNrSW5kZXggaXMgbnVsbFwiLCBcIkVSUl9EQVRBX1NQTElUVEVSX1RBU0tfSU5ERVhfSVNfTlVMTFwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjb25zdCBwcmV2VGFza0luZGV4ID0gX3RoaXMucGFydEluZGV4ID09PSAwID8gX3RoaXMub3B0aW9ucy5zdGFydCA6IF90aGlzLnBhcnRJbmRleFRvVGFza0luZGV4LmdldChfdGhpcy5wYXJ0SW5kZXggLSAxKSArIDEgLyogcHJldiBwYXJ0IGlzIGRvd25sb2FkLCBuZXh0IG1heWJlIGNvcHkgKi87XG4gICAgICAgICAgICAgICAgICAgIGlmIChwcmV2VGFza0luZGV4IDwgdGFza0luZGV4KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB5aWVsZCBfdGhpcy5jb3B5RXhpc3RpbmdEYXRhKHByZXZUYXNrSW5kZXgsIHRhc2tJbmRleCk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAocHJldlRhc2tJbmRleCA+IHRhc2tJbmRleCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgKDAsIChfYnVpbGRlclV0aWxSdW50aW1lIHx8IF9sb2FkX2J1aWxkZXJVdGlsUnVudGltZSgpKS5uZXdFcnJvcikoXCJwcmV2VGFza0luZGV4IG11c3QgYmUgPCB0YXNrSW5kZXhcIiwgXCJFUlJfREFUQV9TUExJVFRFUl9UQVNLX0lOREVYX0FTU0VSVF9GQUlMRURcIik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKF90aGlzLmlzRmluaXNoZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLm9uUGFydEVuZCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuZmluaXNoSGFuZGxlcigpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHN0YXJ0ID0gX3RoaXMuc2VhcmNoSGVhZGVyTGlzdEVuZChjaHVuaywgc3RhcnQpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoc3RhcnQgPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5yZWFkU3RhdGUgPSBSZWFkU3RhdGUuSEVBREVSO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IHBhcnRMZW5ndGggPSBfdGhpcy5wYXJ0SW5kZXhUb0xlbmd0aFtfdGhpcy5wYXJ0SW5kZXhdO1xuICAgICAgICAgICAgICAgIGNvbnN0IGVuZCA9IHN0YXJ0ICsgcGFydExlbmd0aDtcbiAgICAgICAgICAgICAgICBjb25zdCBlZmZlY3RpdmVFbmQgPSBNYXRoLm1pbihlbmQsIGNodW5rLmxlbmd0aCk7XG4gICAgICAgICAgICAgICAgeWllbGQgX3RoaXMucHJvY2Vzc1BhcnRTdGFydGVkKGNodW5rLCBzdGFydCwgZWZmZWN0aXZlRW5kKTtcbiAgICAgICAgICAgICAgICBfdGhpcy5yZW1haW5pbmdQYXJ0RGF0YUNvdW50ID0gcGFydExlbmd0aCAtIChlZmZlY3RpdmVFbmQgLSBzdGFydCk7XG4gICAgICAgICAgICAgICAgaWYgKF90aGlzLnJlbWFpbmluZ1BhcnREYXRhQ291bnQgPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgc3RhcnQgPSBlbmQgKyBfdGhpcy5ib3VuZGFyeUxlbmd0aDtcbiAgICAgICAgICAgICAgICBpZiAoc3RhcnQgPj0gY2h1bmsubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLmlnbm9yZUJ5dGVDb3VudCA9IF90aGlzLmJvdW5kYXJ5TGVuZ3RoIC0gKGNodW5rLmxlbmd0aCAtIGVuZCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pKCk7XG4gICAgfVxuICAgIGNvcHlFeGlzdGluZ0RhdGEoaW5kZXgsIGVuZCkge1xuICAgICAgICByZXR1cm4gbmV3IChfYmx1ZWJpcmRMc3QyIHx8IF9sb2FkX2JsdWViaXJkTHN0MigpKS5kZWZhdWx0KChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHcgPSAoKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKGluZGV4ID09PSBlbmQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IHRhc2sgPSB0aGlzLm9wdGlvbnMudGFza3NbaW5kZXhdO1xuICAgICAgICAgICAgICAgIGlmICh0YXNrLmtpbmQgIT09IChfZG93bmxvYWRQbGFuQnVpbGRlciB8fCBfbG9hZF9kb3dubG9hZFBsYW5CdWlsZGVyKCkpLk9wZXJhdGlvbktpbmQuQ09QWSkge1xuICAgICAgICAgICAgICAgICAgICByZWplY3QobmV3IEVycm9yKFwiVGFzayBraW5kIG11c3QgYmUgQ09QWVwiKSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29weURhdGEodGFzaywgdGhpcy5vdXQsIHRoaXMub3B0aW9ucy5vbGRGaWxlRmQsIHJlamVjdCwgKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpbmRleCsrO1xuICAgICAgICAgICAgICAgICAgICB3KCk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdygpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgc2VhcmNoSGVhZGVyTGlzdEVuZChjaHVuaywgcmVhZE9mZnNldCkge1xuICAgICAgICBjb25zdCBoZWFkZXJMaXN0RW5kID0gY2h1bmsuaW5kZXhPZihET1VCTEVfQ1JMRiwgcmVhZE9mZnNldCk7XG4gICAgICAgIGlmIChoZWFkZXJMaXN0RW5kICE9PSAtMSkge1xuICAgICAgICAgICAgcmV0dXJuIGhlYWRlckxpc3RFbmQgKyBET1VCTEVfQ1JMRi5sZW5ndGg7XG4gICAgICAgIH1cbiAgICAgICAgLy8gbm90IGFsbCBoZWFkZXJzIGRhdGEgd2VyZSByZWNlaXZlZCwgc2F2ZSB0byBidWZmZXJcbiAgICAgICAgY29uc3QgcGFydGlhbENodW5rID0gcmVhZE9mZnNldCA9PT0gMCA/IGNodW5rIDogY2h1bmsuc2xpY2UocmVhZE9mZnNldCk7XG4gICAgICAgIGlmICh0aGlzLmhlYWRlckxpc3RCdWZmZXIgPT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5oZWFkZXJMaXN0QnVmZmVyID0gcGFydGlhbENodW5rO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5oZWFkZXJMaXN0QnVmZmVyID0gQnVmZmVyLmNvbmNhdChbdGhpcy5oZWFkZXJMaXN0QnVmZmVyLCBwYXJ0aWFsQ2h1bmtdKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gLTE7XG4gICAgfVxuICAgIG9uUGFydEVuZCgpIHtcbiAgICAgICAgY29uc3QgZXhwZWN0ZWRMZW5ndGggPSB0aGlzLnBhcnRJbmRleFRvTGVuZ3RoW3RoaXMucGFydEluZGV4IC0gMV07XG4gICAgICAgIGlmICh0aGlzLmFjdHVhbFBhcnRMZW5ndGggIT09IGV4cGVjdGVkTGVuZ3RoKSB7XG4gICAgICAgICAgICB0aHJvdyAoMCwgKF9idWlsZGVyVXRpbFJ1bnRpbWUgfHwgX2xvYWRfYnVpbGRlclV0aWxSdW50aW1lKCkpLm5ld0Vycm9yKShgRXhwZWN0ZWQgbGVuZ3RoOiAke2V4cGVjdGVkTGVuZ3RofSBkaWZmZXJzIGZyb20gYWN0dWFsOiAke3RoaXMuYWN0dWFsUGFydExlbmd0aH1gLCBcIkVSUl9EQVRBX1NQTElUVEVSX0xFTkdUSF9NSVNNQVRDSFwiKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmFjdHVhbFBhcnRMZW5ndGggPSAwO1xuICAgIH1cbiAgICBwcm9jZXNzUGFydFN0YXJ0ZWQoZGF0YSwgc3RhcnQsIGVuZCkge1xuICAgICAgICBpZiAodGhpcy5wYXJ0SW5kZXggIT09IDApIHtcbiAgICAgICAgICAgIHRoaXMub25QYXJ0RW5kKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMucHJvY2Vzc1BhcnREYXRhKGRhdGEsIHN0YXJ0LCBlbmQpO1xuICAgIH1cbiAgICBwcm9jZXNzUGFydERhdGEoZGF0YSwgc3RhcnQsIGVuZCkge1xuICAgICAgICB0aGlzLmFjdHVhbFBhcnRMZW5ndGggKz0gZW5kIC0gc3RhcnQ7XG4gICAgICAgIGNvbnN0IG91dCA9IHRoaXMub3V0O1xuICAgICAgICBpZiAob3V0LndyaXRlKHN0YXJ0ID09PSAwICYmIGRhdGEubGVuZ3RoID09PSBlbmQgPyBkYXRhIDogZGF0YS5zbGljZShzdGFydCwgZW5kKSkpIHtcbiAgICAgICAgICAgIHJldHVybiAoX2JsdWViaXJkTHN0MiB8fCBfbG9hZF9ibHVlYmlyZExzdDIoKSkuZGVmYXVsdC5yZXNvbHZlKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IChfYmx1ZWJpcmRMc3QyIHx8IF9sb2FkX2JsdWViaXJkTHN0MigpKS5kZWZhdWx0KChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgICAgICBvdXQub24oXCJlcnJvclwiLCByZWplY3QpO1xuICAgICAgICAgICAgICAgIG91dC5vbmNlKFwiZHJhaW5cIiwgKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBvdXQucmVtb3ZlTGlzdGVuZXIoXCJlcnJvclwiLCByZWplY3QpO1xuICAgICAgICAgICAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmV4cG9ydHMuRGF0YVNwbGl0dGVyID0gRGF0YVNwbGl0dGVyOyAvLyMgc291cmNlTWFwcGluZ1VSTD1EYXRhU3BsaXR0ZXIuanMubWFwXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2VsZWN0cm9uLXVwZGF0ZXIvb3V0L2RpZmZlcmVudGlhbERvd25sb2FkZXIvRGF0YVNwbGl0dGVyLmpzIiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwiaHR0cFwiKTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyBleHRlcm5hbCBcImh0dHBcIlxuLy8gbW9kdWxlIGlkID0gNjdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIFNhdmUgY29uc29sZSBtZXRob2RzIGZvciB1c2luZyB3aGVuIG9yaWdpbmFscyBhcmUgb3ZlcnJpZGRlblxuICovXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgY29udGV4dDogY29uc29sZSxcbiAgZXJyb3I6ICAgY29uc29sZS5lcnJvcixcbiAgd2FybjogICAgY29uc29sZS53YXJuLFxuICBpbmZvOiAgICBjb25zb2xlLmluZm8sXG4gIHZlcmJvc2U6IGNvbnNvbGUudmVyYm9zZSxcbiAgZGVidWc6ICAgY29uc29sZS5kZWJ1ZyxcbiAgc2lsbHk6ICAgY29uc29sZS5zaWxseSxcbiAgbG9nOiAgICAgY29uc29sZS5sb2dcbn07XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvZWxlY3Ryb24tbG9nL2xpYi9vcmlnaW5hbC1jb25zb2xlLmpzIiwiaW1wb3J0IHsgYXBwLCBCcm93c2VyV2luZG93LCBpcGNNYWluIH0gZnJvbSAnZWxlY3Ryb24nXG5pbXBvcnQgaXNEZXYgZnJvbSAnZWxlY3Ryb24taXMtZGV2J1xuaW1wb3J0IHsgYXV0b1VwZGF0ZXIgfSBmcm9tICdlbGVjdHJvbi11cGRhdGVyJ1xuXG5kZWNsYXJlIHZhciBfX2Rpcm5hbWU6IHN0cmluZ1xubGV0IG1haW5XaW5kb3c6IEVsZWN0cm9uLkJyb3dzZXJXaW5kb3dcbmNvbnN0IGxvZyA9IHJlcXVpcmUoJ2VsZWN0cm9uLWxvZycpXG5sb2cudHJhbnNwb3J0cy5maWxlLmxldmVsID0gJ2RlYnVnJ1xuXG5mdW5jdGlvbiBvblJlYWR5KCkge1xuICBtYWluV2luZG93ID0gbmV3IEJyb3dzZXJXaW5kb3coe1xuICAgIHdpZHRoOiA4MDAsXG4gICAgaGVpZ2h0OiA2MDAsXG4gICAgd2ViUHJlZmVyZW5jZXM6IHtcbiAgICAgIHdlYlNlY3VyaXR5OiBmYWxzZVxuICAgIH1cbiAgfSlcbiAgbWFpbldpbmRvdy5zZXRUaXRsZShyZXF1aXJlKCcuLi9wYWNrYWdlLmpzb24nKS5uYW1lKVxuXG4gIGNvbnN0IGZpbGVOYW1lID0gYGZpbGU6Ly8ke19fZGlybmFtZX0vaW5kZXguaHRtbGBcbiAgbWFpbldpbmRvdy5sb2FkVVJMKGZpbGVOYW1lKVxuICBtYWluV2luZG93Lm9uKCdjbG9zZScsICgpID0+IGFwcC5xdWl0KCkpXG5cbiAgaWYgKGlzRGV2KSB7XG4gICAgbWFpbldpbmRvdy53ZWJDb250ZW50cy5vcGVuRGV2VG9vbHMoKVxuICB9XG5cbiAgaWYgKCFpc0Rldikge1xuICAgIGNvbmZpZ3VyZUFwcFVwZGF0ZSgpXG4gICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICBwZXJmb3JtQXBwVXBkYXRlKClcbiAgICB9LCA1MDAwKVxuICB9XG59XG5cbmFwcC5vbigncmVhZHknLCAoKSA9PiBvblJlYWR5KCkpXG5hcHAub24oJ3dpbmRvdy1hbGwtY2xvc2VkJywgKCkgPT4gYXBwLnF1aXQoKSlcbmFwcC5vbignYnJvd3Nlci13aW5kb3ctY3JlYXRlZCcsZnVuY3Rpb24oX2UsIHdpbmRvdykge1xuICB3aW5kb3cuc2V0TWVudShudWxsKVxufSlcblxuaXBjTWFpbi5vbigndGhlbWUnICwgKF9ldmVudDogc3RyaW5nLCBhcmc6IHN0cmluZykgPT4ge1xuICBtYWluV2luZG93LndlYkNvbnRlbnRzLnNlbmQoJ3RoZW1lJywgYXJnKVxufSlcblxuZnVuY3Rpb24gcGVyZm9ybUFwcFVwZGF0ZSgpIHtcbiAgbG9nLmRlYnVnKCdzZW5kaW5nIHVwZGF0ZXIgY2hlY2tpbmctZm9yLXVwZGF0ZScpXG4gIGF1dG9VcGRhdGVyLmF1dG9Eb3dubG9hZCA9IGZhbHNlXG4gIGF1dG9VcGRhdGVyLmNoZWNrRm9yVXBkYXRlcygpXG59XG5cbmZ1bmN0aW9uIGNvbmZpZ3VyZUFwcFVwZGF0ZSgpIHtcbiAgYXV0b1VwZGF0ZXIubG9nZ2VyID0gbG9nXG5cbiAgYXV0b1VwZGF0ZXIub24oJ2NoZWNraW5nLWZvci11cGRhdGUnLCAoKSA9PiB7XG4gICAgbG9nLmRlYnVnKCdzZW5kaW5nIHVwZGF0ZXIgY2hlY2tpbmctZm9yLXVwZGF0ZScpXG4gICAgbWFpbldpbmRvdy53ZWJDb250ZW50cy5zZW5kKCd1cGRhdGVyJywgJ2NoZWNraW5nLWZvci11cGRhdGUnKVxuICB9KVxuICBhdXRvVXBkYXRlci5vbigndXBkYXRlLWF2YWlsYWJsZScsIChpbmZvKSA9PiB7XG4gICAgbG9nLmRlYnVnKCdzZW5kaW5nIHVwZGF0ZXIgdXBkYXRlLWF2YWlsYWJsZScpXG4gICAgbWFpbldpbmRvdy53ZWJDb250ZW50cy5zZW5kKCd1cGRhdGVyJywgJ3VwZGF0ZS1hdmFpbGFibGUnLCBpbmZvKVxuICB9KVxuICBhdXRvVXBkYXRlci5vbigndXBkYXRlLW5vdC1hdmFpbGFibGUnLCAoaW5mbykgPT4ge1xuICAgIGxvZy5kZWJ1Zygnc2VuZGluZyB1cGRhdGVyIHVwZGF0ZS1ub3QtYXZhaWxhYmxlJylcbiAgICBtYWluV2luZG93LndlYkNvbnRlbnRzLnNlbmQoJ3VwZGF0ZXInLCAndXBkYXRlLW5vdC1hdmFpbGFibGUnLCBpbmZvKVxuICB9KVxuICBhdXRvVXBkYXRlci5vbignZXJyb3InLCAoZXJyKSA9PiB7XG4gICAgbG9nLmRlYnVnKCdzZW5kaW5nIHVwZGF0ZXIgZXJyb3InKVxuICAgIG1haW5XaW5kb3cud2ViQ29udGVudHMuc2VuZCgndXBkYXRlcicsICdlcnJvcicsIGVycilcbiAgfSlcbiAgYXV0b1VwZGF0ZXIub24oJ2Rvd25sb2FkLXByb2dyZXNzJywgKHByb2dyZXNzT2JqKSA9PiB7XG4gICAgbG9nLmRlYnVnKCdzZW5kaW5nIHVwZGF0ZXIgZG93bmxvYWQtcHJvZ3Jlc3MnKVxuICAgIG1haW5XaW5kb3cud2ViQ29udGVudHMuc2VuZCgndXBkYXRlcicsICdkb3dubG9hZC1wcm9ncmVzcycsIHByb2dyZXNzT2JqKVxuICB9KVxuICBhdXRvVXBkYXRlci5vbigndXBkYXRlLWRvd25sb2FkZWQnLCAoaW5mbykgPT4ge1xuICAgIGxvZy5kZWJ1Zygnc2VuZGluZyB1cGRhdGVyIHVwZGF0ZS1kb3dubG9hZGVkJylcbiAgICBtYWluV2luZG93LndlYkNvbnRlbnRzLnNlbmQoJ3VwZGF0ZXInLCAndXBkYXRlLWRvd25sb2FkZWQnLCBpbmZvKVxuICB9KVxuXG4gIGlwY01haW4ub24oJ3VwZGF0ZXInLCAoX2V2ZW50OiBhbnksIHR5cGU6IHN0cmluZykgPT4ge1xuICAgIGlmICh0eXBlID09PSAnZG93bmxvYWQnKSB7XG4gICAgICBhdXRvVXBkYXRlci5kb3dubG9hZFVwZGF0ZSgpXG4gICAgfVxuICAgIGlmICh0eXBlID09PSAnaW5zdGFsbCcpIHtcbiAgICAgIGF1dG9VcGRhdGVyLnF1aXRBbmRJbnN0YWxsKClcbiAgICB9XG4gIH0pXG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvbWFpbi50c3giLCJcInVzZSBzdHJpY3RcIjtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oKSB7XG52YXIgbWFrZVNlbGZSZXNvbHV0aW9uRXJyb3IgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIG5ldyBUeXBlRXJyb3IoXCJjaXJjdWxhciBwcm9taXNlIHJlc29sdXRpb24gY2hhaW5cXHUwMDBhXFx1MDAwYSAgICBTZWUgaHR0cDovL2dvby5nbC9NcXJGbVhcXHUwMDBhXCIpO1xufTtcbnZhciByZWZsZWN0SGFuZGxlciA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZS5Qcm9taXNlSW5zcGVjdGlvbih0aGlzLl90YXJnZXQoKSk7XG59O1xudmFyIGFwaVJlamVjdGlvbiA9IGZ1bmN0aW9uKG1zZykge1xuICAgIHJldHVybiBQcm9taXNlLnJlamVjdChuZXcgVHlwZUVycm9yKG1zZykpO1xufTtcbmZ1bmN0aW9uIFByb3h5YWJsZSgpIHt9XG52YXIgVU5ERUZJTkVEX0JJTkRJTkcgPSB7fTtcbnZhciB1dGlsID0gcmVxdWlyZShcIi4vdXRpbFwiKTtcblxudmFyIGdldERvbWFpbjtcbmlmICh1dGlsLmlzTm9kZSkge1xuICAgIGdldERvbWFpbiA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgcmV0ID0gcHJvY2Vzcy5kb21haW47XG4gICAgICAgIGlmIChyZXQgPT09IHVuZGVmaW5lZCkgcmV0ID0gbnVsbDtcbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICB9O1xufSBlbHNlIHtcbiAgICBnZXREb21haW4gPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfTtcbn1cbnV0aWwubm90RW51bWVyYWJsZVByb3AoUHJvbWlzZSwgXCJfZ2V0RG9tYWluXCIsIGdldERvbWFpbik7XG5cbnZhciBlczUgPSByZXF1aXJlKFwiLi9lczVcIik7XG52YXIgQXN5bmMgPSByZXF1aXJlKFwiLi9hc3luY1wiKTtcbnZhciBhc3luYyA9IG5ldyBBc3luYygpO1xuZXM1LmRlZmluZVByb3BlcnR5KFByb21pc2UsIFwiX2FzeW5jXCIsIHt2YWx1ZTogYXN5bmN9KTtcbnZhciBlcnJvcnMgPSByZXF1aXJlKFwiLi9lcnJvcnNcIik7XG52YXIgVHlwZUVycm9yID0gUHJvbWlzZS5UeXBlRXJyb3IgPSBlcnJvcnMuVHlwZUVycm9yO1xuUHJvbWlzZS5SYW5nZUVycm9yID0gZXJyb3JzLlJhbmdlRXJyb3I7XG52YXIgQ2FuY2VsbGF0aW9uRXJyb3IgPSBQcm9taXNlLkNhbmNlbGxhdGlvbkVycm9yID0gZXJyb3JzLkNhbmNlbGxhdGlvbkVycm9yO1xuUHJvbWlzZS5UaW1lb3V0RXJyb3IgPSBlcnJvcnMuVGltZW91dEVycm9yO1xuUHJvbWlzZS5PcGVyYXRpb25hbEVycm9yID0gZXJyb3JzLk9wZXJhdGlvbmFsRXJyb3I7XG5Qcm9taXNlLlJlamVjdGlvbkVycm9yID0gZXJyb3JzLk9wZXJhdGlvbmFsRXJyb3I7XG5Qcm9taXNlLkFnZ3JlZ2F0ZUVycm9yID0gZXJyb3JzLkFnZ3JlZ2F0ZUVycm9yO1xudmFyIElOVEVSTkFMID0gZnVuY3Rpb24oKXt9O1xudmFyIEFQUExZID0ge307XG52YXIgTkVYVF9GSUxURVIgPSB7fTtcbnZhciB0cnlDb252ZXJ0VG9Qcm9taXNlID0gcmVxdWlyZShcIi4vdGhlbmFibGVzXCIpKFByb21pc2UsIElOVEVSTkFMKTtcbnZhciBQcm9taXNlQXJyYXkgPVxuICAgIHJlcXVpcmUoXCIuL3Byb21pc2VfYXJyYXlcIikoUHJvbWlzZSwgSU5URVJOQUwsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJ5Q29udmVydFRvUHJvbWlzZSwgYXBpUmVqZWN0aW9uLCBQcm94eWFibGUpO1xudmFyIENvbnRleHQgPSByZXF1aXJlKFwiLi9jb250ZXh0XCIpKFByb21pc2UpO1xuIC8qanNoaW50IHVudXNlZDpmYWxzZSovXG52YXIgY3JlYXRlQ29udGV4dCA9IENvbnRleHQuY3JlYXRlO1xudmFyIGRlYnVnID0gcmVxdWlyZShcIi4vZGVidWdnYWJpbGl0eVwiKShQcm9taXNlLCBDb250ZXh0KTtcbnZhciBDYXB0dXJlZFRyYWNlID0gZGVidWcuQ2FwdHVyZWRUcmFjZTtcbnZhciBQYXNzVGhyb3VnaEhhbmRsZXJDb250ZXh0ID1cbiAgICByZXF1aXJlKFwiLi9maW5hbGx5XCIpKFByb21pc2UsIHRyeUNvbnZlcnRUb1Byb21pc2UsIE5FWFRfRklMVEVSKTtcbnZhciBjYXRjaEZpbHRlciA9IHJlcXVpcmUoXCIuL2NhdGNoX2ZpbHRlclwiKShORVhUX0ZJTFRFUik7XG52YXIgbm9kZWJhY2tGb3JQcm9taXNlID0gcmVxdWlyZShcIi4vbm9kZWJhY2tcIik7XG52YXIgZXJyb3JPYmogPSB1dGlsLmVycm9yT2JqO1xudmFyIHRyeUNhdGNoID0gdXRpbC50cnlDYXRjaDtcbmZ1bmN0aW9uIGNoZWNrKHNlbGYsIGV4ZWN1dG9yKSB7XG4gICAgaWYgKHNlbGYgPT0gbnVsbCB8fCBzZWxmLmNvbnN0cnVjdG9yICE9PSBQcm9taXNlKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJ0aGUgcHJvbWlzZSBjb25zdHJ1Y3RvciBjYW5ub3QgYmUgaW52b2tlZCBkaXJlY3RseVxcdTAwMGFcXHUwMDBhICAgIFNlZSBodHRwOi8vZ29vLmdsL01xckZtWFxcdTAwMGFcIik7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgZXhlY3V0b3IgIT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiZXhwZWN0aW5nIGEgZnVuY3Rpb24gYnV0IGdvdCBcIiArIHV0aWwuY2xhc3NTdHJpbmcoZXhlY3V0b3IpKTtcbiAgICB9XG5cbn1cblxuZnVuY3Rpb24gUHJvbWlzZShleGVjdXRvcikge1xuICAgIGlmIChleGVjdXRvciAhPT0gSU5URVJOQUwpIHtcbiAgICAgICAgY2hlY2sodGhpcywgZXhlY3V0b3IpO1xuICAgIH1cbiAgICB0aGlzLl9iaXRGaWVsZCA9IDA7XG4gICAgdGhpcy5fZnVsZmlsbG1lbnRIYW5kbGVyMCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLl9yZWplY3Rpb25IYW5kbGVyMCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLl9wcm9taXNlMCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLl9yZWNlaXZlcjAgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5fcmVzb2x2ZUZyb21FeGVjdXRvcihleGVjdXRvcik7XG4gICAgdGhpcy5fcHJvbWlzZUNyZWF0ZWQoKTtcbiAgICB0aGlzLl9maXJlRXZlbnQoXCJwcm9taXNlQ3JlYXRlZFwiLCB0aGlzKTtcbn1cblxuUHJvbWlzZS5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIFwiW29iamVjdCBQcm9taXNlXVwiO1xufTtcblxuUHJvbWlzZS5wcm90b3R5cGUuY2F1Z2h0ID0gUHJvbWlzZS5wcm90b3R5cGVbXCJjYXRjaFwiXSA9IGZ1bmN0aW9uIChmbikge1xuICAgIHZhciBsZW4gPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgIGlmIChsZW4gPiAxKSB7XG4gICAgICAgIHZhciBjYXRjaEluc3RhbmNlcyA9IG5ldyBBcnJheShsZW4gLSAxKSxcbiAgICAgICAgICAgIGogPSAwLCBpO1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuIC0gMTsgKytpKSB7XG4gICAgICAgICAgICB2YXIgaXRlbSA9IGFyZ3VtZW50c1tpXTtcbiAgICAgICAgICAgIGlmICh1dGlsLmlzT2JqZWN0KGl0ZW0pKSB7XG4gICAgICAgICAgICAgICAgY2F0Y2hJbnN0YW5jZXNbaisrXSA9IGl0ZW07XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBhcGlSZWplY3Rpb24oXCJDYXRjaCBzdGF0ZW1lbnQgcHJlZGljYXRlOiBcIiArXG4gICAgICAgICAgICAgICAgICAgIFwiZXhwZWN0aW5nIGFuIG9iamVjdCBidXQgZ290IFwiICsgdXRpbC5jbGFzc1N0cmluZyhpdGVtKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2hJbnN0YW5jZXMubGVuZ3RoID0gajtcbiAgICAgICAgZm4gPSBhcmd1bWVudHNbaV07XG4gICAgICAgIHJldHVybiB0aGlzLnRoZW4odW5kZWZpbmVkLCBjYXRjaEZpbHRlcihjYXRjaEluc3RhbmNlcywgZm4sIHRoaXMpKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMudGhlbih1bmRlZmluZWQsIGZuKTtcbn07XG5cblByb21pc2UucHJvdG90eXBlLnJlZmxlY3QgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3RoZW4ocmVmbGVjdEhhbmRsZXIsXG4gICAgICAgIHJlZmxlY3RIYW5kbGVyLCB1bmRlZmluZWQsIHRoaXMsIHVuZGVmaW5lZCk7XG59O1xuXG5Qcm9taXNlLnByb3RvdHlwZS50aGVuID0gZnVuY3Rpb24gKGRpZEZ1bGZpbGwsIGRpZFJlamVjdCkge1xuICAgIGlmIChkZWJ1Zy53YXJuaW5ncygpICYmIGFyZ3VtZW50cy5sZW5ndGggPiAwICYmXG4gICAgICAgIHR5cGVvZiBkaWRGdWxmaWxsICE9PSBcImZ1bmN0aW9uXCIgJiZcbiAgICAgICAgdHlwZW9mIGRpZFJlamVjdCAhPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIHZhciBtc2cgPSBcIi50aGVuKCkgb25seSBhY2NlcHRzIGZ1bmN0aW9ucyBidXQgd2FzIHBhc3NlZDogXCIgK1xuICAgICAgICAgICAgICAgIHV0aWwuY2xhc3NTdHJpbmcoZGlkRnVsZmlsbCk7XG4gICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgbXNnICs9IFwiLCBcIiArIHV0aWwuY2xhc3NTdHJpbmcoZGlkUmVqZWN0KTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl93YXJuKG1zZyk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl90aGVuKGRpZEZ1bGZpbGwsIGRpZFJlamVjdCwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIHVuZGVmaW5lZCk7XG59O1xuXG5Qcm9taXNlLnByb3RvdHlwZS5kb25lID0gZnVuY3Rpb24gKGRpZEZ1bGZpbGwsIGRpZFJlamVjdCkge1xuICAgIHZhciBwcm9taXNlID1cbiAgICAgICAgdGhpcy5fdGhlbihkaWRGdWxmaWxsLCBkaWRSZWplY3QsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCB1bmRlZmluZWQpO1xuICAgIHByb21pc2UuX3NldElzRmluYWwoKTtcbn07XG5cblByb21pc2UucHJvdG90eXBlLnNwcmVhZCA9IGZ1bmN0aW9uIChmbikge1xuICAgIGlmICh0eXBlb2YgZm4gIT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICByZXR1cm4gYXBpUmVqZWN0aW9uKFwiZXhwZWN0aW5nIGEgZnVuY3Rpb24gYnV0IGdvdCBcIiArIHV0aWwuY2xhc3NTdHJpbmcoZm4pKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuYWxsKCkuX3RoZW4oZm4sIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBBUFBMWSwgdW5kZWZpbmVkKTtcbn07XG5cblByb21pc2UucHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgcmV0ID0ge1xuICAgICAgICBpc0Z1bGZpbGxlZDogZmFsc2UsXG4gICAgICAgIGlzUmVqZWN0ZWQ6IGZhbHNlLFxuICAgICAgICBmdWxmaWxsbWVudFZhbHVlOiB1bmRlZmluZWQsXG4gICAgICAgIHJlamVjdGlvblJlYXNvbjogdW5kZWZpbmVkXG4gICAgfTtcbiAgICBpZiAodGhpcy5pc0Z1bGZpbGxlZCgpKSB7XG4gICAgICAgIHJldC5mdWxmaWxsbWVudFZhbHVlID0gdGhpcy52YWx1ZSgpO1xuICAgICAgICByZXQuaXNGdWxmaWxsZWQgPSB0cnVlO1xuICAgIH0gZWxzZSBpZiAodGhpcy5pc1JlamVjdGVkKCkpIHtcbiAgICAgICAgcmV0LnJlamVjdGlvblJlYXNvbiA9IHRoaXMucmVhc29uKCk7XG4gICAgICAgIHJldC5pc1JlamVjdGVkID0gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIHJldDtcbn07XG5cblByb21pc2UucHJvdG90eXBlLmFsbCA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgdGhpcy5fd2FybihcIi5hbGwoKSB3YXMgcGFzc2VkIGFyZ3VtZW50cyBidXQgaXQgZG9lcyBub3QgdGFrZSBhbnlcIik7XG4gICAgfVxuICAgIHJldHVybiBuZXcgUHJvbWlzZUFycmF5KHRoaXMpLnByb21pc2UoKTtcbn07XG5cblByb21pc2UucHJvdG90eXBlLmVycm9yID0gZnVuY3Rpb24gKGZuKSB7XG4gICAgcmV0dXJuIHRoaXMuY2F1Z2h0KHV0aWwub3JpZ2luYXRlc0Zyb21SZWplY3Rpb24sIGZuKTtcbn07XG5cblByb21pc2UuZ2V0TmV3TGlicmFyeUNvcHkgPSBtb2R1bGUuZXhwb3J0cztcblxuUHJvbWlzZS5pcyA9IGZ1bmN0aW9uICh2YWwpIHtcbiAgICByZXR1cm4gdmFsIGluc3RhbmNlb2YgUHJvbWlzZTtcbn07XG5cblByb21pc2UuZnJvbU5vZGUgPSBQcm9taXNlLmZyb21DYWxsYmFjayA9IGZ1bmN0aW9uKGZuKSB7XG4gICAgdmFyIHJldCA9IG5ldyBQcm9taXNlKElOVEVSTkFMKTtcbiAgICByZXQuX2NhcHR1cmVTdGFja1RyYWNlKCk7XG4gICAgdmFyIG11bHRpQXJncyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxID8gISFPYmplY3QoYXJndW1lbnRzWzFdKS5tdWx0aUFyZ3NcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOiBmYWxzZTtcbiAgICB2YXIgcmVzdWx0ID0gdHJ5Q2F0Y2goZm4pKG5vZGViYWNrRm9yUHJvbWlzZShyZXQsIG11bHRpQXJncykpO1xuICAgIGlmIChyZXN1bHQgPT09IGVycm9yT2JqKSB7XG4gICAgICAgIHJldC5fcmVqZWN0Q2FsbGJhY2socmVzdWx0LmUsIHRydWUpO1xuICAgIH1cbiAgICBpZiAoIXJldC5faXNGYXRlU2VhbGVkKCkpIHJldC5fc2V0QXN5bmNHdWFyYW50ZWVkKCk7XG4gICAgcmV0dXJuIHJldDtcbn07XG5cblByb21pc2UuYWxsID0gZnVuY3Rpb24gKHByb21pc2VzKSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlQXJyYXkocHJvbWlzZXMpLnByb21pc2UoKTtcbn07XG5cblByb21pc2UuY2FzdCA9IGZ1bmN0aW9uIChvYmopIHtcbiAgICB2YXIgcmV0ID0gdHJ5Q29udmVydFRvUHJvbWlzZShvYmopO1xuICAgIGlmICghKHJldCBpbnN0YW5jZW9mIFByb21pc2UpKSB7XG4gICAgICAgIHJldCA9IG5ldyBQcm9taXNlKElOVEVSTkFMKTtcbiAgICAgICAgcmV0Ll9jYXB0dXJlU3RhY2tUcmFjZSgpO1xuICAgICAgICByZXQuX3NldEZ1bGZpbGxlZCgpO1xuICAgICAgICByZXQuX3JlamVjdGlvbkhhbmRsZXIwID0gb2JqO1xuICAgIH1cbiAgICByZXR1cm4gcmV0O1xufTtcblxuUHJvbWlzZS5yZXNvbHZlID0gUHJvbWlzZS5mdWxmaWxsZWQgPSBQcm9taXNlLmNhc3Q7XG5cblByb21pc2UucmVqZWN0ID0gUHJvbWlzZS5yZWplY3RlZCA9IGZ1bmN0aW9uIChyZWFzb24pIHtcbiAgICB2YXIgcmV0ID0gbmV3IFByb21pc2UoSU5URVJOQUwpO1xuICAgIHJldC5fY2FwdHVyZVN0YWNrVHJhY2UoKTtcbiAgICByZXQuX3JlamVjdENhbGxiYWNrKHJlYXNvbiwgdHJ1ZSk7XG4gICAgcmV0dXJuIHJldDtcbn07XG5cblByb21pc2Uuc2V0U2NoZWR1bGVyID0gZnVuY3Rpb24oZm4pIHtcbiAgICBpZiAodHlwZW9mIGZuICE9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcImV4cGVjdGluZyBhIGZ1bmN0aW9uIGJ1dCBnb3QgXCIgKyB1dGlsLmNsYXNzU3RyaW5nKGZuKSk7XG4gICAgfVxuICAgIHJldHVybiBhc3luYy5zZXRTY2hlZHVsZXIoZm4pO1xufTtcblxuUHJvbWlzZS5wcm90b3R5cGUuX3RoZW4gPSBmdW5jdGlvbiAoXG4gICAgZGlkRnVsZmlsbCxcbiAgICBkaWRSZWplY3QsXG4gICAgXywgICAgcmVjZWl2ZXIsXG4gICAgaW50ZXJuYWxEYXRhXG4pIHtcbiAgICB2YXIgaGF2ZUludGVybmFsRGF0YSA9IGludGVybmFsRGF0YSAhPT0gdW5kZWZpbmVkO1xuICAgIHZhciBwcm9taXNlID0gaGF2ZUludGVybmFsRGF0YSA/IGludGVybmFsRGF0YSA6IG5ldyBQcm9taXNlKElOVEVSTkFMKTtcbiAgICB2YXIgdGFyZ2V0ID0gdGhpcy5fdGFyZ2V0KCk7XG4gICAgdmFyIGJpdEZpZWxkID0gdGFyZ2V0Ll9iaXRGaWVsZDtcblxuICAgIGlmICghaGF2ZUludGVybmFsRGF0YSkge1xuICAgICAgICBwcm9taXNlLl9wcm9wYWdhdGVGcm9tKHRoaXMsIDMpO1xuICAgICAgICBwcm9taXNlLl9jYXB0dXJlU3RhY2tUcmFjZSgpO1xuICAgICAgICBpZiAocmVjZWl2ZXIgPT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgKCh0aGlzLl9iaXRGaWVsZCAmIDIwOTcxNTIpICE9PSAwKSkge1xuICAgICAgICAgICAgaWYgKCEoKGJpdEZpZWxkICYgNTAzOTcxODQpID09PSAwKSkge1xuICAgICAgICAgICAgICAgIHJlY2VpdmVyID0gdGhpcy5fYm91bmRWYWx1ZSgpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZWNlaXZlciA9IHRhcmdldCA9PT0gdGhpcyA/IHVuZGVmaW5lZCA6IHRoaXMuX2JvdW5kVG87XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fZmlyZUV2ZW50KFwicHJvbWlzZUNoYWluZWRcIiwgdGhpcywgcHJvbWlzZSk7XG4gICAgfVxuXG4gICAgdmFyIGRvbWFpbiA9IGdldERvbWFpbigpO1xuICAgIGlmICghKChiaXRGaWVsZCAmIDUwMzk3MTg0KSA9PT0gMCkpIHtcbiAgICAgICAgdmFyIGhhbmRsZXIsIHZhbHVlLCBzZXR0bGVyID0gdGFyZ2V0Ll9zZXR0bGVQcm9taXNlQ3R4O1xuICAgICAgICBpZiAoKChiaXRGaWVsZCAmIDMzNTU0NDMyKSAhPT0gMCkpIHtcbiAgICAgICAgICAgIHZhbHVlID0gdGFyZ2V0Ll9yZWplY3Rpb25IYW5kbGVyMDtcbiAgICAgICAgICAgIGhhbmRsZXIgPSBkaWRGdWxmaWxsO1xuICAgICAgICB9IGVsc2UgaWYgKCgoYml0RmllbGQgJiAxNjc3NzIxNikgIT09IDApKSB7XG4gICAgICAgICAgICB2YWx1ZSA9IHRhcmdldC5fZnVsZmlsbG1lbnRIYW5kbGVyMDtcbiAgICAgICAgICAgIGhhbmRsZXIgPSBkaWRSZWplY3Q7XG4gICAgICAgICAgICB0YXJnZXQuX3Vuc2V0UmVqZWN0aW9uSXNVbmhhbmRsZWQoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHNldHRsZXIgPSB0YXJnZXQuX3NldHRsZVByb21pc2VMYXRlQ2FuY2VsbGF0aW9uT2JzZXJ2ZXI7XG4gICAgICAgICAgICB2YWx1ZSA9IG5ldyBDYW5jZWxsYXRpb25FcnJvcihcImxhdGUgY2FuY2VsbGF0aW9uIG9ic2VydmVyXCIpO1xuICAgICAgICAgICAgdGFyZ2V0Ll9hdHRhY2hFeHRyYVRyYWNlKHZhbHVlKTtcbiAgICAgICAgICAgIGhhbmRsZXIgPSBkaWRSZWplY3Q7XG4gICAgICAgIH1cblxuICAgICAgICBhc3luYy5pbnZva2Uoc2V0dGxlciwgdGFyZ2V0LCB7XG4gICAgICAgICAgICBoYW5kbGVyOiBkb21haW4gPT09IG51bGwgPyBoYW5kbGVyXG4gICAgICAgICAgICAgICAgOiAodHlwZW9mIGhhbmRsZXIgPT09IFwiZnVuY3Rpb25cIiAmJlxuICAgICAgICAgICAgICAgICAgICB1dGlsLmRvbWFpbkJpbmQoZG9tYWluLCBoYW5kbGVyKSksXG4gICAgICAgICAgICBwcm9taXNlOiBwcm9taXNlLFxuICAgICAgICAgICAgcmVjZWl2ZXI6IHJlY2VpdmVyLFxuICAgICAgICAgICAgdmFsdWU6IHZhbHVlXG4gICAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHRhcmdldC5fYWRkQ2FsbGJhY2tzKGRpZEZ1bGZpbGwsIGRpZFJlamVjdCwgcHJvbWlzZSwgcmVjZWl2ZXIsIGRvbWFpbik7XG4gICAgfVxuXG4gICAgcmV0dXJuIHByb21pc2U7XG59O1xuXG5Qcm9taXNlLnByb3RvdHlwZS5fbGVuZ3RoID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLl9iaXRGaWVsZCAmIDY1NTM1O1xufTtcblxuUHJvbWlzZS5wcm90b3R5cGUuX2lzRmF0ZVNlYWxlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gKHRoaXMuX2JpdEZpZWxkICYgMTE3NTA2MDQ4KSAhPT0gMDtcbn07XG5cblByb21pc2UucHJvdG90eXBlLl9pc0ZvbGxvd2luZyA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gKHRoaXMuX2JpdEZpZWxkICYgNjcxMDg4NjQpID09PSA2NzEwODg2NDtcbn07XG5cblByb21pc2UucHJvdG90eXBlLl9zZXRMZW5ndGggPSBmdW5jdGlvbiAobGVuKSB7XG4gICAgdGhpcy5fYml0RmllbGQgPSAodGhpcy5fYml0RmllbGQgJiAtNjU1MzYpIHxcbiAgICAgICAgKGxlbiAmIDY1NTM1KTtcbn07XG5cblByb21pc2UucHJvdG90eXBlLl9zZXRGdWxmaWxsZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5fYml0RmllbGQgPSB0aGlzLl9iaXRGaWVsZCB8IDMzNTU0NDMyO1xuICAgIHRoaXMuX2ZpcmVFdmVudChcInByb21pc2VGdWxmaWxsZWRcIiwgdGhpcyk7XG59O1xuXG5Qcm9taXNlLnByb3RvdHlwZS5fc2V0UmVqZWN0ZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5fYml0RmllbGQgPSB0aGlzLl9iaXRGaWVsZCB8IDE2Nzc3MjE2O1xuICAgIHRoaXMuX2ZpcmVFdmVudChcInByb21pc2VSZWplY3RlZFwiLCB0aGlzKTtcbn07XG5cblByb21pc2UucHJvdG90eXBlLl9zZXRGb2xsb3dpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5fYml0RmllbGQgPSB0aGlzLl9iaXRGaWVsZCB8IDY3MTA4ODY0O1xuICAgIHRoaXMuX2ZpcmVFdmVudChcInByb21pc2VSZXNvbHZlZFwiLCB0aGlzKTtcbn07XG5cblByb21pc2UucHJvdG90eXBlLl9zZXRJc0ZpbmFsID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuX2JpdEZpZWxkID0gdGhpcy5fYml0RmllbGQgfCA0MTk0MzA0O1xufTtcblxuUHJvbWlzZS5wcm90b3R5cGUuX2lzRmluYWwgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuICh0aGlzLl9iaXRGaWVsZCAmIDQxOTQzMDQpID4gMDtcbn07XG5cblByb21pc2UucHJvdG90eXBlLl91bnNldENhbmNlbGxlZCA9IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuX2JpdEZpZWxkID0gdGhpcy5fYml0RmllbGQgJiAofjY1NTM2KTtcbn07XG5cblByb21pc2UucHJvdG90eXBlLl9zZXRDYW5jZWxsZWQgPSBmdW5jdGlvbigpIHtcbiAgICB0aGlzLl9iaXRGaWVsZCA9IHRoaXMuX2JpdEZpZWxkIHwgNjU1MzY7XG4gICAgdGhpcy5fZmlyZUV2ZW50KFwicHJvbWlzZUNhbmNlbGxlZFwiLCB0aGlzKTtcbn07XG5cblByb21pc2UucHJvdG90eXBlLl9zZXRXaWxsQmVDYW5jZWxsZWQgPSBmdW5jdGlvbigpIHtcbiAgICB0aGlzLl9iaXRGaWVsZCA9IHRoaXMuX2JpdEZpZWxkIHwgODM4ODYwODtcbn07XG5cblByb21pc2UucHJvdG90eXBlLl9zZXRBc3luY0d1YXJhbnRlZWQgPSBmdW5jdGlvbigpIHtcbiAgICBpZiAoYXN5bmMuaGFzQ3VzdG9tU2NoZWR1bGVyKCkpIHJldHVybjtcbiAgICB0aGlzLl9iaXRGaWVsZCA9IHRoaXMuX2JpdEZpZWxkIHwgMTM0MjE3NzI4O1xufTtcblxuUHJvbWlzZS5wcm90b3R5cGUuX3JlY2VpdmVyQXQgPSBmdW5jdGlvbiAoaW5kZXgpIHtcbiAgICB2YXIgcmV0ID0gaW5kZXggPT09IDAgPyB0aGlzLl9yZWNlaXZlcjAgOiB0aGlzW1xuICAgICAgICAgICAgaW5kZXggKiA0IC0gNCArIDNdO1xuICAgIGlmIChyZXQgPT09IFVOREVGSU5FRF9CSU5ESU5HKSB7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfSBlbHNlIGlmIChyZXQgPT09IHVuZGVmaW5lZCAmJiB0aGlzLl9pc0JvdW5kKCkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2JvdW5kVmFsdWUoKTtcbiAgICB9XG4gICAgcmV0dXJuIHJldDtcbn07XG5cblByb21pc2UucHJvdG90eXBlLl9wcm9taXNlQXQgPSBmdW5jdGlvbiAoaW5kZXgpIHtcbiAgICByZXR1cm4gdGhpc1tcbiAgICAgICAgICAgIGluZGV4ICogNCAtIDQgKyAyXTtcbn07XG5cblByb21pc2UucHJvdG90eXBlLl9mdWxmaWxsbWVudEhhbmRsZXJBdCA9IGZ1bmN0aW9uIChpbmRleCkge1xuICAgIHJldHVybiB0aGlzW1xuICAgICAgICAgICAgaW5kZXggKiA0IC0gNCArIDBdO1xufTtcblxuUHJvbWlzZS5wcm90b3R5cGUuX3JlamVjdGlvbkhhbmRsZXJBdCA9IGZ1bmN0aW9uIChpbmRleCkge1xuICAgIHJldHVybiB0aGlzW1xuICAgICAgICAgICAgaW5kZXggKiA0IC0gNCArIDFdO1xufTtcblxuUHJvbWlzZS5wcm90b3R5cGUuX2JvdW5kVmFsdWUgPSBmdW5jdGlvbigpIHt9O1xuXG5Qcm9taXNlLnByb3RvdHlwZS5fbWlncmF0ZUNhbGxiYWNrMCA9IGZ1bmN0aW9uIChmb2xsb3dlcikge1xuICAgIHZhciBiaXRGaWVsZCA9IGZvbGxvd2VyLl9iaXRGaWVsZDtcbiAgICB2YXIgZnVsZmlsbCA9IGZvbGxvd2VyLl9mdWxmaWxsbWVudEhhbmRsZXIwO1xuICAgIHZhciByZWplY3QgPSBmb2xsb3dlci5fcmVqZWN0aW9uSGFuZGxlcjA7XG4gICAgdmFyIHByb21pc2UgPSBmb2xsb3dlci5fcHJvbWlzZTA7XG4gICAgdmFyIHJlY2VpdmVyID0gZm9sbG93ZXIuX3JlY2VpdmVyQXQoMCk7XG4gICAgaWYgKHJlY2VpdmVyID09PSB1bmRlZmluZWQpIHJlY2VpdmVyID0gVU5ERUZJTkVEX0JJTkRJTkc7XG4gICAgdGhpcy5fYWRkQ2FsbGJhY2tzKGZ1bGZpbGwsIHJlamVjdCwgcHJvbWlzZSwgcmVjZWl2ZXIsIG51bGwpO1xufTtcblxuUHJvbWlzZS5wcm90b3R5cGUuX21pZ3JhdGVDYWxsYmFja0F0ID0gZnVuY3Rpb24gKGZvbGxvd2VyLCBpbmRleCkge1xuICAgIHZhciBmdWxmaWxsID0gZm9sbG93ZXIuX2Z1bGZpbGxtZW50SGFuZGxlckF0KGluZGV4KTtcbiAgICB2YXIgcmVqZWN0ID0gZm9sbG93ZXIuX3JlamVjdGlvbkhhbmRsZXJBdChpbmRleCk7XG4gICAgdmFyIHByb21pc2UgPSBmb2xsb3dlci5fcHJvbWlzZUF0KGluZGV4KTtcbiAgICB2YXIgcmVjZWl2ZXIgPSBmb2xsb3dlci5fcmVjZWl2ZXJBdChpbmRleCk7XG4gICAgaWYgKHJlY2VpdmVyID09PSB1bmRlZmluZWQpIHJlY2VpdmVyID0gVU5ERUZJTkVEX0JJTkRJTkc7XG4gICAgdGhpcy5fYWRkQ2FsbGJhY2tzKGZ1bGZpbGwsIHJlamVjdCwgcHJvbWlzZSwgcmVjZWl2ZXIsIG51bGwpO1xufTtcblxuUHJvbWlzZS5wcm90b3R5cGUuX2FkZENhbGxiYWNrcyA9IGZ1bmN0aW9uIChcbiAgICBmdWxmaWxsLFxuICAgIHJlamVjdCxcbiAgICBwcm9taXNlLFxuICAgIHJlY2VpdmVyLFxuICAgIGRvbWFpblxuKSB7XG4gICAgdmFyIGluZGV4ID0gdGhpcy5fbGVuZ3RoKCk7XG5cbiAgICBpZiAoaW5kZXggPj0gNjU1MzUgLSA0KSB7XG4gICAgICAgIGluZGV4ID0gMDtcbiAgICAgICAgdGhpcy5fc2V0TGVuZ3RoKDApO1xuICAgIH1cblxuICAgIGlmIChpbmRleCA9PT0gMCkge1xuICAgICAgICB0aGlzLl9wcm9taXNlMCA9IHByb21pc2U7XG4gICAgICAgIHRoaXMuX3JlY2VpdmVyMCA9IHJlY2VpdmVyO1xuICAgICAgICBpZiAodHlwZW9mIGZ1bGZpbGwgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgdGhpcy5fZnVsZmlsbG1lbnRIYW5kbGVyMCA9XG4gICAgICAgICAgICAgICAgZG9tYWluID09PSBudWxsID8gZnVsZmlsbCA6IHV0aWwuZG9tYWluQmluZChkb21haW4sIGZ1bGZpbGwpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgcmVqZWN0ID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgIHRoaXMuX3JlamVjdGlvbkhhbmRsZXIwID1cbiAgICAgICAgICAgICAgICBkb21haW4gPT09IG51bGwgPyByZWplY3QgOiB1dGlsLmRvbWFpbkJpbmQoZG9tYWluLCByZWplY3QpO1xuICAgICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIGJhc2UgPSBpbmRleCAqIDQgLSA0O1xuICAgICAgICB0aGlzW2Jhc2UgKyAyXSA9IHByb21pc2U7XG4gICAgICAgIHRoaXNbYmFzZSArIDNdID0gcmVjZWl2ZXI7XG4gICAgICAgIGlmICh0eXBlb2YgZnVsZmlsbCA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICB0aGlzW2Jhc2UgKyAwXSA9XG4gICAgICAgICAgICAgICAgZG9tYWluID09PSBudWxsID8gZnVsZmlsbCA6IHV0aWwuZG9tYWluQmluZChkb21haW4sIGZ1bGZpbGwpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgcmVqZWN0ID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgIHRoaXNbYmFzZSArIDFdID1cbiAgICAgICAgICAgICAgICBkb21haW4gPT09IG51bGwgPyByZWplY3QgOiB1dGlsLmRvbWFpbkJpbmQoZG9tYWluLCByZWplY3QpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHRoaXMuX3NldExlbmd0aChpbmRleCArIDEpO1xuICAgIHJldHVybiBpbmRleDtcbn07XG5cblByb21pc2UucHJvdG90eXBlLl9wcm94eSA9IGZ1bmN0aW9uIChwcm94eWFibGUsIGFyZykge1xuICAgIHRoaXMuX2FkZENhbGxiYWNrcyh1bmRlZmluZWQsIHVuZGVmaW5lZCwgYXJnLCBwcm94eWFibGUsIG51bGwpO1xufTtcblxuUHJvbWlzZS5wcm90b3R5cGUuX3Jlc29sdmVDYWxsYmFjayA9IGZ1bmN0aW9uKHZhbHVlLCBzaG91bGRCaW5kKSB7XG4gICAgaWYgKCgodGhpcy5fYml0RmllbGQgJiAxMTc1MDYwNDgpICE9PSAwKSkgcmV0dXJuO1xuICAgIGlmICh2YWx1ZSA9PT0gdGhpcylcbiAgICAgICAgcmV0dXJuIHRoaXMuX3JlamVjdENhbGxiYWNrKG1ha2VTZWxmUmVzb2x1dGlvbkVycm9yKCksIGZhbHNlKTtcbiAgICB2YXIgbWF5YmVQcm9taXNlID0gdHJ5Q29udmVydFRvUHJvbWlzZSh2YWx1ZSwgdGhpcyk7XG4gICAgaWYgKCEobWF5YmVQcm9taXNlIGluc3RhbmNlb2YgUHJvbWlzZSkpIHJldHVybiB0aGlzLl9mdWxmaWxsKHZhbHVlKTtcblxuICAgIGlmIChzaG91bGRCaW5kKSB0aGlzLl9wcm9wYWdhdGVGcm9tKG1heWJlUHJvbWlzZSwgMik7XG5cbiAgICB2YXIgcHJvbWlzZSA9IG1heWJlUHJvbWlzZS5fdGFyZ2V0KCk7XG5cbiAgICBpZiAocHJvbWlzZSA9PT0gdGhpcykge1xuICAgICAgICB0aGlzLl9yZWplY3QobWFrZVNlbGZSZXNvbHV0aW9uRXJyb3IoKSk7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgYml0RmllbGQgPSBwcm9taXNlLl9iaXRGaWVsZDtcbiAgICBpZiAoKChiaXRGaWVsZCAmIDUwMzk3MTg0KSA9PT0gMCkpIHtcbiAgICAgICAgdmFyIGxlbiA9IHRoaXMuX2xlbmd0aCgpO1xuICAgICAgICBpZiAobGVuID4gMCkgcHJvbWlzZS5fbWlncmF0ZUNhbGxiYWNrMCh0aGlzKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCBsZW47ICsraSkge1xuICAgICAgICAgICAgcHJvbWlzZS5fbWlncmF0ZUNhbGxiYWNrQXQodGhpcywgaSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fc2V0Rm9sbG93aW5nKCk7XG4gICAgICAgIHRoaXMuX3NldExlbmd0aCgwKTtcbiAgICAgICAgdGhpcy5fc2V0Rm9sbG93ZWUocHJvbWlzZSk7XG4gICAgfSBlbHNlIGlmICgoKGJpdEZpZWxkICYgMzM1NTQ0MzIpICE9PSAwKSkge1xuICAgICAgICB0aGlzLl9mdWxmaWxsKHByb21pc2UuX3ZhbHVlKCkpO1xuICAgIH0gZWxzZSBpZiAoKChiaXRGaWVsZCAmIDE2Nzc3MjE2KSAhPT0gMCkpIHtcbiAgICAgICAgdGhpcy5fcmVqZWN0KHByb21pc2UuX3JlYXNvbigpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgcmVhc29uID0gbmV3IENhbmNlbGxhdGlvbkVycm9yKFwibGF0ZSBjYW5jZWxsYXRpb24gb2JzZXJ2ZXJcIik7XG4gICAgICAgIHByb21pc2UuX2F0dGFjaEV4dHJhVHJhY2UocmVhc29uKTtcbiAgICAgICAgdGhpcy5fcmVqZWN0KHJlYXNvbik7XG4gICAgfVxufTtcblxuUHJvbWlzZS5wcm90b3R5cGUuX3JlamVjdENhbGxiYWNrID1cbmZ1bmN0aW9uKHJlYXNvbiwgc3luY2hyb25vdXMsIGlnbm9yZU5vbkVycm9yV2FybmluZ3MpIHtcbiAgICB2YXIgdHJhY2UgPSB1dGlsLmVuc3VyZUVycm9yT2JqZWN0KHJlYXNvbik7XG4gICAgdmFyIGhhc1N0YWNrID0gdHJhY2UgPT09IHJlYXNvbjtcbiAgICBpZiAoIWhhc1N0YWNrICYmICFpZ25vcmVOb25FcnJvcldhcm5pbmdzICYmIGRlYnVnLndhcm5pbmdzKCkpIHtcbiAgICAgICAgdmFyIG1lc3NhZ2UgPSBcImEgcHJvbWlzZSB3YXMgcmVqZWN0ZWQgd2l0aCBhIG5vbi1lcnJvcjogXCIgK1xuICAgICAgICAgICAgdXRpbC5jbGFzc1N0cmluZyhyZWFzb24pO1xuICAgICAgICB0aGlzLl93YXJuKG1lc3NhZ2UsIHRydWUpO1xuICAgIH1cbiAgICB0aGlzLl9hdHRhY2hFeHRyYVRyYWNlKHRyYWNlLCBzeW5jaHJvbm91cyA/IGhhc1N0YWNrIDogZmFsc2UpO1xuICAgIHRoaXMuX3JlamVjdChyZWFzb24pO1xufTtcblxuUHJvbWlzZS5wcm90b3R5cGUuX3Jlc29sdmVGcm9tRXhlY3V0b3IgPSBmdW5jdGlvbiAoZXhlY3V0b3IpIHtcbiAgICBpZiAoZXhlY3V0b3IgPT09IElOVEVSTkFMKSByZXR1cm47XG4gICAgdmFyIHByb21pc2UgPSB0aGlzO1xuICAgIHRoaXMuX2NhcHR1cmVTdGFja1RyYWNlKCk7XG4gICAgdGhpcy5fcHVzaENvbnRleHQoKTtcbiAgICB2YXIgc3luY2hyb25vdXMgPSB0cnVlO1xuICAgIHZhciByID0gdGhpcy5fZXhlY3V0ZShleGVjdXRvciwgZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgcHJvbWlzZS5fcmVzb2x2ZUNhbGxiYWNrKHZhbHVlKTtcbiAgICB9LCBmdW5jdGlvbiAocmVhc29uKSB7XG4gICAgICAgIHByb21pc2UuX3JlamVjdENhbGxiYWNrKHJlYXNvbiwgc3luY2hyb25vdXMpO1xuICAgIH0pO1xuICAgIHN5bmNocm9ub3VzID0gZmFsc2U7XG4gICAgdGhpcy5fcG9wQ29udGV4dCgpO1xuXG4gICAgaWYgKHIgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBwcm9taXNlLl9yZWplY3RDYWxsYmFjayhyLCB0cnVlKTtcbiAgICB9XG59O1xuXG5Qcm9taXNlLnByb3RvdHlwZS5fc2V0dGxlUHJvbWlzZUZyb21IYW5kbGVyID0gZnVuY3Rpb24gKFxuICAgIGhhbmRsZXIsIHJlY2VpdmVyLCB2YWx1ZSwgcHJvbWlzZVxuKSB7XG4gICAgdmFyIGJpdEZpZWxkID0gcHJvbWlzZS5fYml0RmllbGQ7XG4gICAgaWYgKCgoYml0RmllbGQgJiA2NTUzNikgIT09IDApKSByZXR1cm47XG4gICAgcHJvbWlzZS5fcHVzaENvbnRleHQoKTtcbiAgICB2YXIgeDtcbiAgICBpZiAocmVjZWl2ZXIgPT09IEFQUExZKSB7XG4gICAgICAgIGlmICghdmFsdWUgfHwgdHlwZW9mIHZhbHVlLmxlbmd0aCAhPT0gXCJudW1iZXJcIikge1xuICAgICAgICAgICAgeCA9IGVycm9yT2JqO1xuICAgICAgICAgICAgeC5lID0gbmV3IFR5cGVFcnJvcihcImNhbm5vdCAuc3ByZWFkKCkgYSBub24tYXJyYXk6IFwiICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHV0aWwuY2xhc3NTdHJpbmcodmFsdWUpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHggPSB0cnlDYXRjaChoYW5kbGVyKS5hcHBseSh0aGlzLl9ib3VuZFZhbHVlKCksIHZhbHVlKTtcbiAgICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAgIHggPSB0cnlDYXRjaChoYW5kbGVyKS5jYWxsKHJlY2VpdmVyLCB2YWx1ZSk7XG4gICAgfVxuICAgIHZhciBwcm9taXNlQ3JlYXRlZCA9IHByb21pc2UuX3BvcENvbnRleHQoKTtcbiAgICBiaXRGaWVsZCA9IHByb21pc2UuX2JpdEZpZWxkO1xuICAgIGlmICgoKGJpdEZpZWxkICYgNjU1MzYpICE9PSAwKSkgcmV0dXJuO1xuXG4gICAgaWYgKHggPT09IE5FWFRfRklMVEVSKSB7XG4gICAgICAgIHByb21pc2UuX3JlamVjdCh2YWx1ZSk7XG4gICAgfSBlbHNlIGlmICh4ID09PSBlcnJvck9iaikge1xuICAgICAgICBwcm9taXNlLl9yZWplY3RDYWxsYmFjayh4LmUsIGZhbHNlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBkZWJ1Zy5jaGVja0ZvcmdvdHRlblJldHVybnMoeCwgcHJvbWlzZUNyZWF0ZWQsIFwiXCIsICBwcm9taXNlLCB0aGlzKTtcbiAgICAgICAgcHJvbWlzZS5fcmVzb2x2ZUNhbGxiYWNrKHgpO1xuICAgIH1cbn07XG5cblByb21pc2UucHJvdG90eXBlLl90YXJnZXQgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgcmV0ID0gdGhpcztcbiAgICB3aGlsZSAocmV0Ll9pc0ZvbGxvd2luZygpKSByZXQgPSByZXQuX2ZvbGxvd2VlKCk7XG4gICAgcmV0dXJuIHJldDtcbn07XG5cblByb21pc2UucHJvdG90eXBlLl9mb2xsb3dlZSA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLl9yZWplY3Rpb25IYW5kbGVyMDtcbn07XG5cblByb21pc2UucHJvdG90eXBlLl9zZXRGb2xsb3dlZSA9IGZ1bmN0aW9uKHByb21pc2UpIHtcbiAgICB0aGlzLl9yZWplY3Rpb25IYW5kbGVyMCA9IHByb21pc2U7XG59O1xuXG5Qcm9taXNlLnByb3RvdHlwZS5fc2V0dGxlUHJvbWlzZSA9IGZ1bmN0aW9uKHByb21pc2UsIGhhbmRsZXIsIHJlY2VpdmVyLCB2YWx1ZSkge1xuICAgIHZhciBpc1Byb21pc2UgPSBwcm9taXNlIGluc3RhbmNlb2YgUHJvbWlzZTtcbiAgICB2YXIgYml0RmllbGQgPSB0aGlzLl9iaXRGaWVsZDtcbiAgICB2YXIgYXN5bmNHdWFyYW50ZWVkID0gKChiaXRGaWVsZCAmIDEzNDIxNzcyOCkgIT09IDApO1xuICAgIGlmICgoKGJpdEZpZWxkICYgNjU1MzYpICE9PSAwKSkge1xuICAgICAgICBpZiAoaXNQcm9taXNlKSBwcm9taXNlLl9pbnZva2VJbnRlcm5hbE9uQ2FuY2VsKCk7XG5cbiAgICAgICAgaWYgKHJlY2VpdmVyIGluc3RhbmNlb2YgUGFzc1Rocm91Z2hIYW5kbGVyQ29udGV4dCAmJlxuICAgICAgICAgICAgcmVjZWl2ZXIuaXNGaW5hbGx5SGFuZGxlcigpKSB7XG4gICAgICAgICAgICByZWNlaXZlci5jYW5jZWxQcm9taXNlID0gcHJvbWlzZTtcbiAgICAgICAgICAgIGlmICh0cnlDYXRjaChoYW5kbGVyKS5jYWxsKHJlY2VpdmVyLCB2YWx1ZSkgPT09IGVycm9yT2JqKSB7XG4gICAgICAgICAgICAgICAgcHJvbWlzZS5fcmVqZWN0KGVycm9yT2JqLmUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKGhhbmRsZXIgPT09IHJlZmxlY3RIYW5kbGVyKSB7XG4gICAgICAgICAgICBwcm9taXNlLl9mdWxmaWxsKHJlZmxlY3RIYW5kbGVyLmNhbGwocmVjZWl2ZXIpKTtcbiAgICAgICAgfSBlbHNlIGlmIChyZWNlaXZlciBpbnN0YW5jZW9mIFByb3h5YWJsZSkge1xuICAgICAgICAgICAgcmVjZWl2ZXIuX3Byb21pc2VDYW5jZWxsZWQocHJvbWlzZSk7XG4gICAgICAgIH0gZWxzZSBpZiAoaXNQcm9taXNlIHx8IHByb21pc2UgaW5zdGFuY2VvZiBQcm9taXNlQXJyYXkpIHtcbiAgICAgICAgICAgIHByb21pc2UuX2NhbmNlbCgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVjZWl2ZXIuY2FuY2VsKCk7XG4gICAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBoYW5kbGVyID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgaWYgKCFpc1Byb21pc2UpIHtcbiAgICAgICAgICAgIGhhbmRsZXIuY2FsbChyZWNlaXZlciwgdmFsdWUsIHByb21pc2UpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKGFzeW5jR3VhcmFudGVlZCkgcHJvbWlzZS5fc2V0QXN5bmNHdWFyYW50ZWVkKCk7XG4gICAgICAgICAgICB0aGlzLl9zZXR0bGVQcm9taXNlRnJvbUhhbmRsZXIoaGFuZGxlciwgcmVjZWl2ZXIsIHZhbHVlLCBwcm9taXNlKTtcbiAgICAgICAgfVxuICAgIH0gZWxzZSBpZiAocmVjZWl2ZXIgaW5zdGFuY2VvZiBQcm94eWFibGUpIHtcbiAgICAgICAgaWYgKCFyZWNlaXZlci5faXNSZXNvbHZlZCgpKSB7XG4gICAgICAgICAgICBpZiAoKChiaXRGaWVsZCAmIDMzNTU0NDMyKSAhPT0gMCkpIHtcbiAgICAgICAgICAgICAgICByZWNlaXZlci5fcHJvbWlzZUZ1bGZpbGxlZCh2YWx1ZSwgcHJvbWlzZSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJlY2VpdmVyLl9wcm9taXNlUmVqZWN0ZWQodmFsdWUsIHByb21pc2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSBlbHNlIGlmIChpc1Byb21pc2UpIHtcbiAgICAgICAgaWYgKGFzeW5jR3VhcmFudGVlZCkgcHJvbWlzZS5fc2V0QXN5bmNHdWFyYW50ZWVkKCk7XG4gICAgICAgIGlmICgoKGJpdEZpZWxkICYgMzM1NTQ0MzIpICE9PSAwKSkge1xuICAgICAgICAgICAgcHJvbWlzZS5fZnVsZmlsbCh2YWx1ZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBwcm9taXNlLl9yZWplY3QodmFsdWUpO1xuICAgICAgICB9XG4gICAgfVxufTtcblxuUHJvbWlzZS5wcm90b3R5cGUuX3NldHRsZVByb21pc2VMYXRlQ2FuY2VsbGF0aW9uT2JzZXJ2ZXIgPSBmdW5jdGlvbihjdHgpIHtcbiAgICB2YXIgaGFuZGxlciA9IGN0eC5oYW5kbGVyO1xuICAgIHZhciBwcm9taXNlID0gY3R4LnByb21pc2U7XG4gICAgdmFyIHJlY2VpdmVyID0gY3R4LnJlY2VpdmVyO1xuICAgIHZhciB2YWx1ZSA9IGN0eC52YWx1ZTtcbiAgICBpZiAodHlwZW9mIGhhbmRsZXIgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICBpZiAoIShwcm9taXNlIGluc3RhbmNlb2YgUHJvbWlzZSkpIHtcbiAgICAgICAgICAgIGhhbmRsZXIuY2FsbChyZWNlaXZlciwgdmFsdWUsIHByb21pc2UpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5fc2V0dGxlUHJvbWlzZUZyb21IYW5kbGVyKGhhbmRsZXIsIHJlY2VpdmVyLCB2YWx1ZSwgcHJvbWlzZSk7XG4gICAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHByb21pc2UgaW5zdGFuY2VvZiBQcm9taXNlKSB7XG4gICAgICAgIHByb21pc2UuX3JlamVjdCh2YWx1ZSk7XG4gICAgfVxufTtcblxuUHJvbWlzZS5wcm90b3R5cGUuX3NldHRsZVByb21pc2VDdHggPSBmdW5jdGlvbihjdHgpIHtcbiAgICB0aGlzLl9zZXR0bGVQcm9taXNlKGN0eC5wcm9taXNlLCBjdHguaGFuZGxlciwgY3R4LnJlY2VpdmVyLCBjdHgudmFsdWUpO1xufTtcblxuUHJvbWlzZS5wcm90b3R5cGUuX3NldHRsZVByb21pc2UwID0gZnVuY3Rpb24oaGFuZGxlciwgdmFsdWUsIGJpdEZpZWxkKSB7XG4gICAgdmFyIHByb21pc2UgPSB0aGlzLl9wcm9taXNlMDtcbiAgICB2YXIgcmVjZWl2ZXIgPSB0aGlzLl9yZWNlaXZlckF0KDApO1xuICAgIHRoaXMuX3Byb21pc2UwID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuX3JlY2VpdmVyMCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLl9zZXR0bGVQcm9taXNlKHByb21pc2UsIGhhbmRsZXIsIHJlY2VpdmVyLCB2YWx1ZSk7XG59O1xuXG5Qcm9taXNlLnByb3RvdHlwZS5fY2xlYXJDYWxsYmFja0RhdGFBdEluZGV4ID0gZnVuY3Rpb24oaW5kZXgpIHtcbiAgICB2YXIgYmFzZSA9IGluZGV4ICogNCAtIDQ7XG4gICAgdGhpc1tiYXNlICsgMl0gPVxuICAgIHRoaXNbYmFzZSArIDNdID1cbiAgICB0aGlzW2Jhc2UgKyAwXSA9XG4gICAgdGhpc1tiYXNlICsgMV0gPSB1bmRlZmluZWQ7XG59O1xuXG5Qcm9taXNlLnByb3RvdHlwZS5fZnVsZmlsbCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgIHZhciBiaXRGaWVsZCA9IHRoaXMuX2JpdEZpZWxkO1xuICAgIGlmICgoKGJpdEZpZWxkICYgMTE3NTA2MDQ4KSA+Pj4gMTYpKSByZXR1cm47XG4gICAgaWYgKHZhbHVlID09PSB0aGlzKSB7XG4gICAgICAgIHZhciBlcnIgPSBtYWtlU2VsZlJlc29sdXRpb25FcnJvcigpO1xuICAgICAgICB0aGlzLl9hdHRhY2hFeHRyYVRyYWNlKGVycik7XG4gICAgICAgIHJldHVybiB0aGlzLl9yZWplY3QoZXJyKTtcbiAgICB9XG4gICAgdGhpcy5fc2V0RnVsZmlsbGVkKCk7XG4gICAgdGhpcy5fcmVqZWN0aW9uSGFuZGxlcjAgPSB2YWx1ZTtcblxuICAgIGlmICgoYml0RmllbGQgJiA2NTUzNSkgPiAwKSB7XG4gICAgICAgIGlmICgoKGJpdEZpZWxkICYgMTM0MjE3NzI4KSAhPT0gMCkpIHtcbiAgICAgICAgICAgIHRoaXMuX3NldHRsZVByb21pc2VzKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBhc3luYy5zZXR0bGVQcm9taXNlcyh0aGlzKTtcbiAgICAgICAgfVxuICAgIH1cbn07XG5cblByb21pc2UucHJvdG90eXBlLl9yZWplY3QgPSBmdW5jdGlvbiAocmVhc29uKSB7XG4gICAgdmFyIGJpdEZpZWxkID0gdGhpcy5fYml0RmllbGQ7XG4gICAgaWYgKCgoYml0RmllbGQgJiAxMTc1MDYwNDgpID4+PiAxNikpIHJldHVybjtcbiAgICB0aGlzLl9zZXRSZWplY3RlZCgpO1xuICAgIHRoaXMuX2Z1bGZpbGxtZW50SGFuZGxlcjAgPSByZWFzb247XG5cbiAgICBpZiAodGhpcy5faXNGaW5hbCgpKSB7XG4gICAgICAgIHJldHVybiBhc3luYy5mYXRhbEVycm9yKHJlYXNvbiwgdXRpbC5pc05vZGUpO1xuICAgIH1cblxuICAgIGlmICgoYml0RmllbGQgJiA2NTUzNSkgPiAwKSB7XG4gICAgICAgIGFzeW5jLnNldHRsZVByb21pc2VzKHRoaXMpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuX2Vuc3VyZVBvc3NpYmxlUmVqZWN0aW9uSGFuZGxlZCgpO1xuICAgIH1cbn07XG5cblByb21pc2UucHJvdG90eXBlLl9mdWxmaWxsUHJvbWlzZXMgPSBmdW5jdGlvbiAobGVuLCB2YWx1ZSkge1xuICAgIGZvciAodmFyIGkgPSAxOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgdmFyIGhhbmRsZXIgPSB0aGlzLl9mdWxmaWxsbWVudEhhbmRsZXJBdChpKTtcbiAgICAgICAgdmFyIHByb21pc2UgPSB0aGlzLl9wcm9taXNlQXQoaSk7XG4gICAgICAgIHZhciByZWNlaXZlciA9IHRoaXMuX3JlY2VpdmVyQXQoaSk7XG4gICAgICAgIHRoaXMuX2NsZWFyQ2FsbGJhY2tEYXRhQXRJbmRleChpKTtcbiAgICAgICAgdGhpcy5fc2V0dGxlUHJvbWlzZShwcm9taXNlLCBoYW5kbGVyLCByZWNlaXZlciwgdmFsdWUpO1xuICAgIH1cbn07XG5cblByb21pc2UucHJvdG90eXBlLl9yZWplY3RQcm9taXNlcyA9IGZ1bmN0aW9uIChsZW4sIHJlYXNvbikge1xuICAgIGZvciAodmFyIGkgPSAxOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgdmFyIGhhbmRsZXIgPSB0aGlzLl9yZWplY3Rpb25IYW5kbGVyQXQoaSk7XG4gICAgICAgIHZhciBwcm9taXNlID0gdGhpcy5fcHJvbWlzZUF0KGkpO1xuICAgICAgICB2YXIgcmVjZWl2ZXIgPSB0aGlzLl9yZWNlaXZlckF0KGkpO1xuICAgICAgICB0aGlzLl9jbGVhckNhbGxiYWNrRGF0YUF0SW5kZXgoaSk7XG4gICAgICAgIHRoaXMuX3NldHRsZVByb21pc2UocHJvbWlzZSwgaGFuZGxlciwgcmVjZWl2ZXIsIHJlYXNvbik7XG4gICAgfVxufTtcblxuUHJvbWlzZS5wcm90b3R5cGUuX3NldHRsZVByb21pc2VzID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBiaXRGaWVsZCA9IHRoaXMuX2JpdEZpZWxkO1xuICAgIHZhciBsZW4gPSAoYml0RmllbGQgJiA2NTUzNSk7XG5cbiAgICBpZiAobGVuID4gMCkge1xuICAgICAgICBpZiAoKChiaXRGaWVsZCAmIDE2ODQyNzUyKSAhPT0gMCkpIHtcbiAgICAgICAgICAgIHZhciByZWFzb24gPSB0aGlzLl9mdWxmaWxsbWVudEhhbmRsZXIwO1xuICAgICAgICAgICAgdGhpcy5fc2V0dGxlUHJvbWlzZTAodGhpcy5fcmVqZWN0aW9uSGFuZGxlcjAsIHJlYXNvbiwgYml0RmllbGQpO1xuICAgICAgICAgICAgdGhpcy5fcmVqZWN0UHJvbWlzZXMobGVuLCByZWFzb24pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFyIHZhbHVlID0gdGhpcy5fcmVqZWN0aW9uSGFuZGxlcjA7XG4gICAgICAgICAgICB0aGlzLl9zZXR0bGVQcm9taXNlMCh0aGlzLl9mdWxmaWxsbWVudEhhbmRsZXIwLCB2YWx1ZSwgYml0RmllbGQpO1xuICAgICAgICAgICAgdGhpcy5fZnVsZmlsbFByb21pc2VzKGxlbiwgdmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3NldExlbmd0aCgwKTtcbiAgICB9XG4gICAgdGhpcy5fY2xlYXJDYW5jZWxsYXRpb25EYXRhKCk7XG59O1xuXG5Qcm9taXNlLnByb3RvdHlwZS5fc2V0dGxlZFZhbHVlID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGJpdEZpZWxkID0gdGhpcy5fYml0RmllbGQ7XG4gICAgaWYgKCgoYml0RmllbGQgJiAzMzU1NDQzMikgIT09IDApKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9yZWplY3Rpb25IYW5kbGVyMDtcbiAgICB9IGVsc2UgaWYgKCgoYml0RmllbGQgJiAxNjc3NzIxNikgIT09IDApKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9mdWxmaWxsbWVudEhhbmRsZXIwO1xuICAgIH1cbn07XG5cbmZ1bmN0aW9uIGRlZmVyUmVzb2x2ZSh2KSB7dGhpcy5wcm9taXNlLl9yZXNvbHZlQ2FsbGJhY2sodik7fVxuZnVuY3Rpb24gZGVmZXJSZWplY3Qodikge3RoaXMucHJvbWlzZS5fcmVqZWN0Q2FsbGJhY2sodiwgZmFsc2UpO31cblxuUHJvbWlzZS5kZWZlciA9IFByb21pc2UucGVuZGluZyA9IGZ1bmN0aW9uKCkge1xuICAgIGRlYnVnLmRlcHJlY2F0ZWQoXCJQcm9taXNlLmRlZmVyXCIsIFwibmV3IFByb21pc2VcIik7XG4gICAgdmFyIHByb21pc2UgPSBuZXcgUHJvbWlzZShJTlRFUk5BTCk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgcHJvbWlzZTogcHJvbWlzZSxcbiAgICAgICAgcmVzb2x2ZTogZGVmZXJSZXNvbHZlLFxuICAgICAgICByZWplY3Q6IGRlZmVyUmVqZWN0XG4gICAgfTtcbn07XG5cbnV0aWwubm90RW51bWVyYWJsZVByb3AoUHJvbWlzZSxcbiAgICAgICAgICAgICAgICAgICAgICAgXCJfbWFrZVNlbGZSZXNvbHV0aW9uRXJyb3JcIixcbiAgICAgICAgICAgICAgICAgICAgICAgbWFrZVNlbGZSZXNvbHV0aW9uRXJyb3IpO1xuXG5yZXF1aXJlKFwiLi9tZXRob2RcIikoUHJvbWlzZSwgSU5URVJOQUwsIHRyeUNvbnZlcnRUb1Byb21pc2UsIGFwaVJlamVjdGlvbixcbiAgICBkZWJ1Zyk7XG5yZXF1aXJlKFwiLi9iaW5kXCIpKFByb21pc2UsIElOVEVSTkFMLCB0cnlDb252ZXJ0VG9Qcm9taXNlLCBkZWJ1Zyk7XG5yZXF1aXJlKFwiLi9jYW5jZWxcIikoUHJvbWlzZSwgUHJvbWlzZUFycmF5LCBhcGlSZWplY3Rpb24sIGRlYnVnKTtcbnJlcXVpcmUoXCIuL2RpcmVjdF9yZXNvbHZlXCIpKFByb21pc2UpO1xucmVxdWlyZShcIi4vc3luY2hyb25vdXNfaW5zcGVjdGlvblwiKShQcm9taXNlKTtcbnJlcXVpcmUoXCIuL2pvaW5cIikoXG4gICAgUHJvbWlzZSwgUHJvbWlzZUFycmF5LCB0cnlDb252ZXJ0VG9Qcm9taXNlLCBJTlRFUk5BTCwgYXN5bmMsIGdldERvbWFpbik7XG5Qcm9taXNlLlByb21pc2UgPSBQcm9taXNlO1xuUHJvbWlzZS52ZXJzaW9uID0gXCIzLjUuMVwiO1xucmVxdWlyZSgnLi9tYXAuanMnKShQcm9taXNlLCBQcm9taXNlQXJyYXksIGFwaVJlamVjdGlvbiwgdHJ5Q29udmVydFRvUHJvbWlzZSwgSU5URVJOQUwsIGRlYnVnKTtcbnJlcXVpcmUoJy4vY2FsbF9nZXQuanMnKShQcm9taXNlKTtcbnJlcXVpcmUoJy4vdXNpbmcuanMnKShQcm9taXNlLCBhcGlSZWplY3Rpb24sIHRyeUNvbnZlcnRUb1Byb21pc2UsIGNyZWF0ZUNvbnRleHQsIElOVEVSTkFMLCBkZWJ1Zyk7XG5yZXF1aXJlKCcuL3RpbWVycy5qcycpKFByb21pc2UsIElOVEVSTkFMLCBkZWJ1Zyk7XG5yZXF1aXJlKCcuL2dlbmVyYXRvcnMuanMnKShQcm9taXNlLCBhcGlSZWplY3Rpb24sIElOVEVSTkFMLCB0cnlDb252ZXJ0VG9Qcm9taXNlLCBQcm94eWFibGUsIGRlYnVnKTtcbnJlcXVpcmUoJy4vbm9kZWlmeS5qcycpKFByb21pc2UpO1xucmVxdWlyZSgnLi9wcm9taXNpZnkuanMnKShQcm9taXNlLCBJTlRFUk5BTCk7XG5yZXF1aXJlKCcuL3Byb3BzLmpzJykoUHJvbWlzZSwgUHJvbWlzZUFycmF5LCB0cnlDb252ZXJ0VG9Qcm9taXNlLCBhcGlSZWplY3Rpb24pO1xucmVxdWlyZSgnLi9yYWNlLmpzJykoUHJvbWlzZSwgSU5URVJOQUwsIHRyeUNvbnZlcnRUb1Byb21pc2UsIGFwaVJlamVjdGlvbik7XG5yZXF1aXJlKCcuL3JlZHVjZS5qcycpKFByb21pc2UsIFByb21pc2VBcnJheSwgYXBpUmVqZWN0aW9uLCB0cnlDb252ZXJ0VG9Qcm9taXNlLCBJTlRFUk5BTCwgZGVidWcpO1xucmVxdWlyZSgnLi9zZXR0bGUuanMnKShQcm9taXNlLCBQcm9taXNlQXJyYXksIGRlYnVnKTtcbnJlcXVpcmUoJy4vc29tZS5qcycpKFByb21pc2UsIFByb21pc2VBcnJheSwgYXBpUmVqZWN0aW9uKTtcbnJlcXVpcmUoJy4vZmlsdGVyLmpzJykoUHJvbWlzZSwgSU5URVJOQUwpO1xucmVxdWlyZSgnLi9lYWNoLmpzJykoUHJvbWlzZSwgSU5URVJOQUwpO1xucmVxdWlyZSgnLi9hbnkuanMnKShQcm9taXNlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgIHV0aWwudG9GYXN0UHJvcGVydGllcyhQcm9taXNlKTsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcbiAgICB1dGlsLnRvRmFzdFByb3BlcnRpZXMoUHJvbWlzZS5wcm90b3R5cGUpOyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgZnVuY3Rpb24gZmlsbFR5cGVzKHZhbHVlKSB7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICB2YXIgcCA9IG5ldyBQcm9taXNlKElOVEVSTkFMKTsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgcC5fZnVsZmlsbG1lbnRIYW5kbGVyMCA9IHZhbHVlOyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgIHAuX3JlamVjdGlvbkhhbmRsZXIwID0gdmFsdWU7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICBwLl9wcm9taXNlMCA9IHZhbHVlOyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgcC5fcmVjZWl2ZXIwID0gdmFsdWU7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgfSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgIC8vIENvbXBsZXRlIHNsYWNrIHRyYWNraW5nLCBvcHQgb3V0IG9mIGZpZWxkLXR5cGUgdHJhY2tpbmcgYW5kICAgICAgICAgICBcbiAgICAvLyBzdGFiaWxpemUgbWFwICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgZmlsbFR5cGVzKHthOiAxfSk7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgIGZpbGxUeXBlcyh7YjogMn0pOyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcbiAgICBmaWxsVHlwZXMoe2M6IDN9KTsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgZmlsbFR5cGVzKDEpOyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgIGZpbGxUeXBlcyhmdW5jdGlvbigpe30pOyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcbiAgICBmaWxsVHlwZXModW5kZWZpbmVkKTsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgZmlsbFR5cGVzKGZhbHNlKTsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgIGZpbGxUeXBlcyhuZXcgUHJvbWlzZShJTlRFUk5BTCkpOyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcbiAgICBkZWJ1Zy5zZXRCb3VuZHMoQXN5bmMuZmlyc3RMaW5lRXJyb3IsIHV0aWwubGFzdExpbmVFcnJvcik7ICAgICAgICAgICAgICAgXG4gICAgcmV0dXJuIFByb21pc2U7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuXG59O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2JsdWViaXJkL2pzL3JlbGVhc2UvcHJvbWlzZS5qcyIsIlwidXNlIHN0cmljdFwiO1xudmFyIGZpcnN0TGluZUVycm9yO1xudHJ5IHt0aHJvdyBuZXcgRXJyb3IoKTsgfSBjYXRjaCAoZSkge2ZpcnN0TGluZUVycm9yID0gZTt9XG52YXIgc2NoZWR1bGUgPSByZXF1aXJlKFwiLi9zY2hlZHVsZVwiKTtcbnZhciBRdWV1ZSA9IHJlcXVpcmUoXCIuL3F1ZXVlXCIpO1xudmFyIHV0aWwgPSByZXF1aXJlKFwiLi91dGlsXCIpO1xuXG5mdW5jdGlvbiBBc3luYygpIHtcbiAgICB0aGlzLl9jdXN0b21TY2hlZHVsZXIgPSBmYWxzZTtcbiAgICB0aGlzLl9pc1RpY2tVc2VkID0gZmFsc2U7XG4gICAgdGhpcy5fbGF0ZVF1ZXVlID0gbmV3IFF1ZXVlKDE2KTtcbiAgICB0aGlzLl9ub3JtYWxRdWV1ZSA9IG5ldyBRdWV1ZSgxNik7XG4gICAgdGhpcy5faGF2ZURyYWluZWRRdWV1ZXMgPSBmYWxzZTtcbiAgICB0aGlzLl90cmFtcG9saW5lRW5hYmxlZCA9IHRydWU7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHRoaXMuZHJhaW5RdWV1ZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHNlbGYuX2RyYWluUXVldWVzKCk7XG4gICAgfTtcbiAgICB0aGlzLl9zY2hlZHVsZSA9IHNjaGVkdWxlO1xufVxuXG5Bc3luYy5wcm90b3R5cGUuc2V0U2NoZWR1bGVyID0gZnVuY3Rpb24oZm4pIHtcbiAgICB2YXIgcHJldiA9IHRoaXMuX3NjaGVkdWxlO1xuICAgIHRoaXMuX3NjaGVkdWxlID0gZm47XG4gICAgdGhpcy5fY3VzdG9tU2NoZWR1bGVyID0gdHJ1ZTtcbiAgICByZXR1cm4gcHJldjtcbn07XG5cbkFzeW5jLnByb3RvdHlwZS5oYXNDdXN0b21TY2hlZHVsZXIgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5fY3VzdG9tU2NoZWR1bGVyO1xufTtcblxuQXN5bmMucHJvdG90eXBlLmVuYWJsZVRyYW1wb2xpbmUgPSBmdW5jdGlvbigpIHtcbiAgICB0aGlzLl90cmFtcG9saW5lRW5hYmxlZCA9IHRydWU7XG59O1xuXG5Bc3luYy5wcm90b3R5cGUuZGlzYWJsZVRyYW1wb2xpbmVJZk5lY2Vzc2FyeSA9IGZ1bmN0aW9uKCkge1xuICAgIGlmICh1dGlsLmhhc0RldlRvb2xzKSB7XG4gICAgICAgIHRoaXMuX3RyYW1wb2xpbmVFbmFibGVkID0gZmFsc2U7XG4gICAgfVxufTtcblxuQXN5bmMucHJvdG90eXBlLmhhdmVJdGVtc1F1ZXVlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5faXNUaWNrVXNlZCB8fCB0aGlzLl9oYXZlRHJhaW5lZFF1ZXVlcztcbn07XG5cblxuQXN5bmMucHJvdG90eXBlLmZhdGFsRXJyb3IgPSBmdW5jdGlvbihlLCBpc05vZGUpIHtcbiAgICBpZiAoaXNOb2RlKSB7XG4gICAgICAgIHByb2Nlc3Muc3RkZXJyLndyaXRlKFwiRmF0YWwgXCIgKyAoZSBpbnN0YW5jZW9mIEVycm9yID8gZS5zdGFjayA6IGUpICtcbiAgICAgICAgICAgIFwiXFxuXCIpO1xuICAgICAgICBwcm9jZXNzLmV4aXQoMik7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy50aHJvd0xhdGVyKGUpO1xuICAgIH1cbn07XG5cbkFzeW5jLnByb3RvdHlwZS50aHJvd0xhdGVyID0gZnVuY3Rpb24oZm4sIGFyZykge1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgIGFyZyA9IGZuO1xuICAgICAgICBmbiA9IGZ1bmN0aW9uICgpIHsgdGhyb3cgYXJnOyB9O1xuICAgIH1cbiAgICBpZiAodHlwZW9mIHNldFRpbWVvdXQgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGZuKGFyZyk7XG4gICAgICAgIH0sIDApO1xuICAgIH0gZWxzZSB0cnkge1xuICAgICAgICB0aGlzLl9zY2hlZHVsZShmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGZuKGFyZyk7XG4gICAgICAgIH0pO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTm8gYXN5bmMgc2NoZWR1bGVyIGF2YWlsYWJsZVxcdTAwMGFcXHUwMDBhICAgIFNlZSBodHRwOi8vZ29vLmdsL01xckZtWFxcdTAwMGFcIik7XG4gICAgfVxufTtcblxuZnVuY3Rpb24gQXN5bmNJbnZva2VMYXRlcihmbiwgcmVjZWl2ZXIsIGFyZykge1xuICAgIHRoaXMuX2xhdGVRdWV1ZS5wdXNoKGZuLCByZWNlaXZlciwgYXJnKTtcbiAgICB0aGlzLl9xdWV1ZVRpY2soKTtcbn1cblxuZnVuY3Rpb24gQXN5bmNJbnZva2UoZm4sIHJlY2VpdmVyLCBhcmcpIHtcbiAgICB0aGlzLl9ub3JtYWxRdWV1ZS5wdXNoKGZuLCByZWNlaXZlciwgYXJnKTtcbiAgICB0aGlzLl9xdWV1ZVRpY2soKTtcbn1cblxuZnVuY3Rpb24gQXN5bmNTZXR0bGVQcm9taXNlcyhwcm9taXNlKSB7XG4gICAgdGhpcy5fbm9ybWFsUXVldWUuX3B1c2hPbmUocHJvbWlzZSk7XG4gICAgdGhpcy5fcXVldWVUaWNrKCk7XG59XG5cbmlmICghdXRpbC5oYXNEZXZUb29scykge1xuICAgIEFzeW5jLnByb3RvdHlwZS5pbnZva2VMYXRlciA9IEFzeW5jSW52b2tlTGF0ZXI7XG4gICAgQXN5bmMucHJvdG90eXBlLmludm9rZSA9IEFzeW5jSW52b2tlO1xuICAgIEFzeW5jLnByb3RvdHlwZS5zZXR0bGVQcm9taXNlcyA9IEFzeW5jU2V0dGxlUHJvbWlzZXM7XG59IGVsc2Uge1xuICAgIEFzeW5jLnByb3RvdHlwZS5pbnZva2VMYXRlciA9IGZ1bmN0aW9uIChmbiwgcmVjZWl2ZXIsIGFyZykge1xuICAgICAgICBpZiAodGhpcy5fdHJhbXBvbGluZUVuYWJsZWQpIHtcbiAgICAgICAgICAgIEFzeW5jSW52b2tlTGF0ZXIuY2FsbCh0aGlzLCBmbiwgcmVjZWl2ZXIsIGFyZyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl9zY2hlZHVsZShmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICBmbi5jYWxsKHJlY2VpdmVyLCBhcmcpO1xuICAgICAgICAgICAgICAgIH0sIDEwMCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBBc3luYy5wcm90b3R5cGUuaW52b2tlID0gZnVuY3Rpb24gKGZuLCByZWNlaXZlciwgYXJnKSB7XG4gICAgICAgIGlmICh0aGlzLl90cmFtcG9saW5lRW5hYmxlZCkge1xuICAgICAgICAgICAgQXN5bmNJbnZva2UuY2FsbCh0aGlzLCBmbiwgcmVjZWl2ZXIsIGFyZyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl9zY2hlZHVsZShmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBmbi5jYWxsKHJlY2VpdmVyLCBhcmcpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgQXN5bmMucHJvdG90eXBlLnNldHRsZVByb21pc2VzID0gZnVuY3Rpb24ocHJvbWlzZSkge1xuICAgICAgICBpZiAodGhpcy5fdHJhbXBvbGluZUVuYWJsZWQpIHtcbiAgICAgICAgICAgIEFzeW5jU2V0dGxlUHJvbWlzZXMuY2FsbCh0aGlzLCBwcm9taXNlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX3NjaGVkdWxlKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHByb21pc2UuX3NldHRsZVByb21pc2VzKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH07XG59XG5cbkFzeW5jLnByb3RvdHlwZS5fZHJhaW5RdWV1ZSA9IGZ1bmN0aW9uKHF1ZXVlKSB7XG4gICAgd2hpbGUgKHF1ZXVlLmxlbmd0aCgpID4gMCkge1xuICAgICAgICB2YXIgZm4gPSBxdWV1ZS5zaGlmdCgpO1xuICAgICAgICBpZiAodHlwZW9mIGZuICE9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgIGZuLl9zZXR0bGVQcm9taXNlcygpO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHJlY2VpdmVyID0gcXVldWUuc2hpZnQoKTtcbiAgICAgICAgdmFyIGFyZyA9IHF1ZXVlLnNoaWZ0KCk7XG4gICAgICAgIGZuLmNhbGwocmVjZWl2ZXIsIGFyZyk7XG4gICAgfVxufTtcblxuQXN5bmMucHJvdG90eXBlLl9kcmFpblF1ZXVlcyA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLl9kcmFpblF1ZXVlKHRoaXMuX25vcm1hbFF1ZXVlKTtcbiAgICB0aGlzLl9yZXNldCgpO1xuICAgIHRoaXMuX2hhdmVEcmFpbmVkUXVldWVzID0gdHJ1ZTtcbiAgICB0aGlzLl9kcmFpblF1ZXVlKHRoaXMuX2xhdGVRdWV1ZSk7XG59O1xuXG5Bc3luYy5wcm90b3R5cGUuX3F1ZXVlVGljayA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoIXRoaXMuX2lzVGlja1VzZWQpIHtcbiAgICAgICAgdGhpcy5faXNUaWNrVXNlZCA9IHRydWU7XG4gICAgICAgIHRoaXMuX3NjaGVkdWxlKHRoaXMuZHJhaW5RdWV1ZXMpO1xuICAgIH1cbn07XG5cbkFzeW5jLnByb3RvdHlwZS5fcmVzZXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5faXNUaWNrVXNlZCA9IGZhbHNlO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBBc3luYztcbm1vZHVsZS5leHBvcnRzLmZpcnN0TGluZUVycm9yID0gZmlyc3RMaW5lRXJyb3I7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvYmx1ZWJpcmQvanMvcmVsZWFzZS9hc3luYy5qcyIsIlwidXNlIHN0cmljdFwiO1xudmFyIHV0aWwgPSByZXF1aXJlKFwiLi91dGlsXCIpO1xudmFyIHNjaGVkdWxlO1xudmFyIG5vQXN5bmNTY2hlZHVsZXIgPSBmdW5jdGlvbigpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJObyBhc3luYyBzY2hlZHVsZXIgYXZhaWxhYmxlXFx1MDAwYVxcdTAwMGEgICAgU2VlIGh0dHA6Ly9nb28uZ2wvTXFyRm1YXFx1MDAwYVwiKTtcbn07XG52YXIgTmF0aXZlUHJvbWlzZSA9IHV0aWwuZ2V0TmF0aXZlUHJvbWlzZSgpO1xuaWYgKHV0aWwuaXNOb2RlICYmIHR5cGVvZiBNdXRhdGlvbk9ic2VydmVyID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgdmFyIEdsb2JhbFNldEltbWVkaWF0ZSA9IGdsb2JhbC5zZXRJbW1lZGlhdGU7XG4gICAgdmFyIFByb2Nlc3NOZXh0VGljayA9IHByb2Nlc3MubmV4dFRpY2s7XG4gICAgc2NoZWR1bGUgPSB1dGlsLmlzUmVjZW50Tm9kZVxuICAgICAgICAgICAgICAgID8gZnVuY3Rpb24oZm4pIHsgR2xvYmFsU2V0SW1tZWRpYXRlLmNhbGwoZ2xvYmFsLCBmbik7IH1cbiAgICAgICAgICAgICAgICA6IGZ1bmN0aW9uKGZuKSB7IFByb2Nlc3NOZXh0VGljay5jYWxsKHByb2Nlc3MsIGZuKTsgfTtcbn0gZWxzZSBpZiAodHlwZW9mIE5hdGl2ZVByb21pc2UgPT09IFwiZnVuY3Rpb25cIiAmJlxuICAgICAgICAgICB0eXBlb2YgTmF0aXZlUHJvbWlzZS5yZXNvbHZlID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICB2YXIgbmF0aXZlUHJvbWlzZSA9IE5hdGl2ZVByb21pc2UucmVzb2x2ZSgpO1xuICAgIHNjaGVkdWxlID0gZnVuY3Rpb24oZm4pIHtcbiAgICAgICAgbmF0aXZlUHJvbWlzZS50aGVuKGZuKTtcbiAgICB9O1xufSBlbHNlIGlmICgodHlwZW9mIE11dGF0aW9uT2JzZXJ2ZXIgIT09IFwidW5kZWZpbmVkXCIpICYmXG4gICAgICAgICAgISh0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiICYmXG4gICAgICAgICAgICB3aW5kb3cubmF2aWdhdG9yICYmXG4gICAgICAgICAgICAod2luZG93Lm5hdmlnYXRvci5zdGFuZGFsb25lIHx8IHdpbmRvdy5jb3Jkb3ZhKSkpIHtcbiAgICBzY2hlZHVsZSA9IChmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGRpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgICAgIHZhciBvcHRzID0ge2F0dHJpYnV0ZXM6IHRydWV9O1xuICAgICAgICB2YXIgdG9nZ2xlU2NoZWR1bGVkID0gZmFsc2U7XG4gICAgICAgIHZhciBkaXYyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICAgICAgdmFyIG8yID0gbmV3IE11dGF0aW9uT2JzZXJ2ZXIoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBkaXYuY2xhc3NMaXN0LnRvZ2dsZShcImZvb1wiKTtcbiAgICAgICAgICAgIHRvZ2dsZVNjaGVkdWxlZCA9IGZhbHNlO1xuICAgICAgICB9KTtcbiAgICAgICAgbzIub2JzZXJ2ZShkaXYyLCBvcHRzKTtcblxuICAgICAgICB2YXIgc2NoZWR1bGVUb2dnbGUgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGlmICh0b2dnbGVTY2hlZHVsZWQpIHJldHVybjtcbiAgICAgICAgICAgIHRvZ2dsZVNjaGVkdWxlZCA9IHRydWU7XG4gICAgICAgICAgICBkaXYyLmNsYXNzTGlzdC50b2dnbGUoXCJmb29cIik7XG4gICAgICAgIH07XG5cbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIHNjaGVkdWxlKGZuKSB7XG4gICAgICAgICAgICB2YXIgbyA9IG5ldyBNdXRhdGlvbk9ic2VydmVyKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIG8uZGlzY29ubmVjdCgpO1xuICAgICAgICAgICAgICAgIGZuKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIG8ub2JzZXJ2ZShkaXYsIG9wdHMpO1xuICAgICAgICAgICAgc2NoZWR1bGVUb2dnbGUoKTtcbiAgICAgICAgfTtcbiAgICB9KSgpO1xufSBlbHNlIGlmICh0eXBlb2Ygc2V0SW1tZWRpYXRlICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgc2NoZWR1bGUgPSBmdW5jdGlvbiAoZm4pIHtcbiAgICAgICAgc2V0SW1tZWRpYXRlKGZuKTtcbiAgICB9O1xufSBlbHNlIGlmICh0eXBlb2Ygc2V0VGltZW91dCAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgIHNjaGVkdWxlID0gZnVuY3Rpb24gKGZuKSB7XG4gICAgICAgIHNldFRpbWVvdXQoZm4sIDApO1xuICAgIH07XG59IGVsc2Uge1xuICAgIHNjaGVkdWxlID0gbm9Bc3luY1NjaGVkdWxlcjtcbn1cbm1vZHVsZS5leHBvcnRzID0gc2NoZWR1bGU7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvYmx1ZWJpcmQvanMvcmVsZWFzZS9zY2hlZHVsZS5qcyIsIlwidXNlIHN0cmljdFwiO1xuZnVuY3Rpb24gYXJyYXlNb3ZlKHNyYywgc3JjSW5kZXgsIGRzdCwgZHN0SW5kZXgsIGxlbikge1xuICAgIGZvciAodmFyIGogPSAwOyBqIDwgbGVuOyArK2opIHtcbiAgICAgICAgZHN0W2ogKyBkc3RJbmRleF0gPSBzcmNbaiArIHNyY0luZGV4XTtcbiAgICAgICAgc3JjW2ogKyBzcmNJbmRleF0gPSB2b2lkIDA7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBRdWV1ZShjYXBhY2l0eSkge1xuICAgIHRoaXMuX2NhcGFjaXR5ID0gY2FwYWNpdHk7XG4gICAgdGhpcy5fbGVuZ3RoID0gMDtcbiAgICB0aGlzLl9mcm9udCA9IDA7XG59XG5cblF1ZXVlLnByb3RvdHlwZS5fd2lsbEJlT3ZlckNhcGFjaXR5ID0gZnVuY3Rpb24gKHNpemUpIHtcbiAgICByZXR1cm4gdGhpcy5fY2FwYWNpdHkgPCBzaXplO1xufTtcblxuUXVldWUucHJvdG90eXBlLl9wdXNoT25lID0gZnVuY3Rpb24gKGFyZykge1xuICAgIHZhciBsZW5ndGggPSB0aGlzLmxlbmd0aCgpO1xuICAgIHRoaXMuX2NoZWNrQ2FwYWNpdHkobGVuZ3RoICsgMSk7XG4gICAgdmFyIGkgPSAodGhpcy5fZnJvbnQgKyBsZW5ndGgpICYgKHRoaXMuX2NhcGFjaXR5IC0gMSk7XG4gICAgdGhpc1tpXSA9IGFyZztcbiAgICB0aGlzLl9sZW5ndGggPSBsZW5ndGggKyAxO1xufTtcblxuUXVldWUucHJvdG90eXBlLnB1c2ggPSBmdW5jdGlvbiAoZm4sIHJlY2VpdmVyLCBhcmcpIHtcbiAgICB2YXIgbGVuZ3RoID0gdGhpcy5sZW5ndGgoKSArIDM7XG4gICAgaWYgKHRoaXMuX3dpbGxCZU92ZXJDYXBhY2l0eShsZW5ndGgpKSB7XG4gICAgICAgIHRoaXMuX3B1c2hPbmUoZm4pO1xuICAgICAgICB0aGlzLl9wdXNoT25lKHJlY2VpdmVyKTtcbiAgICAgICAgdGhpcy5fcHVzaE9uZShhcmcpO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciBqID0gdGhpcy5fZnJvbnQgKyBsZW5ndGggLSAzO1xuICAgIHRoaXMuX2NoZWNrQ2FwYWNpdHkobGVuZ3RoKTtcbiAgICB2YXIgd3JhcE1hc2sgPSB0aGlzLl9jYXBhY2l0eSAtIDE7XG4gICAgdGhpc1soaiArIDApICYgd3JhcE1hc2tdID0gZm47XG4gICAgdGhpc1soaiArIDEpICYgd3JhcE1hc2tdID0gcmVjZWl2ZXI7XG4gICAgdGhpc1soaiArIDIpICYgd3JhcE1hc2tdID0gYXJnO1xuICAgIHRoaXMuX2xlbmd0aCA9IGxlbmd0aDtcbn07XG5cblF1ZXVlLnByb3RvdHlwZS5zaGlmdCA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZnJvbnQgPSB0aGlzLl9mcm9udCxcbiAgICAgICAgcmV0ID0gdGhpc1tmcm9udF07XG5cbiAgICB0aGlzW2Zyb250XSA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLl9mcm9udCA9IChmcm9udCArIDEpICYgKHRoaXMuX2NhcGFjaXR5IC0gMSk7XG4gICAgdGhpcy5fbGVuZ3RoLS07XG4gICAgcmV0dXJuIHJldDtcbn07XG5cblF1ZXVlLnByb3RvdHlwZS5sZW5ndGggPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2xlbmd0aDtcbn07XG5cblF1ZXVlLnByb3RvdHlwZS5fY2hlY2tDYXBhY2l0eSA9IGZ1bmN0aW9uIChzaXplKSB7XG4gICAgaWYgKHRoaXMuX2NhcGFjaXR5IDwgc2l6ZSkge1xuICAgICAgICB0aGlzLl9yZXNpemVUbyh0aGlzLl9jYXBhY2l0eSA8PCAxKTtcbiAgICB9XG59O1xuXG5RdWV1ZS5wcm90b3R5cGUuX3Jlc2l6ZVRvID0gZnVuY3Rpb24gKGNhcGFjaXR5KSB7XG4gICAgdmFyIG9sZENhcGFjaXR5ID0gdGhpcy5fY2FwYWNpdHk7XG4gICAgdGhpcy5fY2FwYWNpdHkgPSBjYXBhY2l0eTtcbiAgICB2YXIgZnJvbnQgPSB0aGlzLl9mcm9udDtcbiAgICB2YXIgbGVuZ3RoID0gdGhpcy5fbGVuZ3RoO1xuICAgIHZhciBtb3ZlSXRlbXNDb3VudCA9IChmcm9udCArIGxlbmd0aCkgJiAob2xkQ2FwYWNpdHkgLSAxKTtcbiAgICBhcnJheU1vdmUodGhpcywgMCwgdGhpcywgb2xkQ2FwYWNpdHksIG1vdmVJdGVtc0NvdW50KTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gUXVldWU7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvYmx1ZWJpcmQvanMvcmVsZWFzZS9xdWV1ZS5qcyIsIlwidXNlIHN0cmljdFwiO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihQcm9taXNlLCBJTlRFUk5BTCkge1xudmFyIHV0aWwgPSByZXF1aXJlKFwiLi91dGlsXCIpO1xudmFyIGVycm9yT2JqID0gdXRpbC5lcnJvck9iajtcbnZhciBpc09iamVjdCA9IHV0aWwuaXNPYmplY3Q7XG5cbmZ1bmN0aW9uIHRyeUNvbnZlcnRUb1Byb21pc2Uob2JqLCBjb250ZXh0KSB7XG4gICAgaWYgKGlzT2JqZWN0KG9iaikpIHtcbiAgICAgICAgaWYgKG9iaiBpbnN0YW5jZW9mIFByb21pc2UpIHJldHVybiBvYmo7XG4gICAgICAgIHZhciB0aGVuID0gZ2V0VGhlbihvYmopO1xuICAgICAgICBpZiAodGhlbiA9PT0gZXJyb3JPYmopIHtcbiAgICAgICAgICAgIGlmIChjb250ZXh0KSBjb250ZXh0Ll9wdXNoQ29udGV4dCgpO1xuICAgICAgICAgICAgdmFyIHJldCA9IFByb21pc2UucmVqZWN0KHRoZW4uZSk7XG4gICAgICAgICAgICBpZiAoY29udGV4dCkgY29udGV4dC5fcG9wQ29udGV4dCgpO1xuICAgICAgICAgICAgcmV0dXJuIHJldDtcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgdGhlbiA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICBpZiAoaXNBbnlCbHVlYmlyZFByb21pc2Uob2JqKSkge1xuICAgICAgICAgICAgICAgIHZhciByZXQgPSBuZXcgUHJvbWlzZShJTlRFUk5BTCk7XG4gICAgICAgICAgICAgICAgb2JqLl90aGVuKFxuICAgICAgICAgICAgICAgICAgICByZXQuX2Z1bGZpbGwsXG4gICAgICAgICAgICAgICAgICAgIHJldC5fcmVqZWN0LFxuICAgICAgICAgICAgICAgICAgICB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgICAgIHJldCxcbiAgICAgICAgICAgICAgICAgICAgbnVsbFxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJldDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBkb1RoZW5hYmxlKG9iaiwgdGhlbiwgY29udGV4dCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG9iajtcbn1cblxuZnVuY3Rpb24gZG9HZXRUaGVuKG9iaikge1xuICAgIHJldHVybiBvYmoudGhlbjtcbn1cblxuZnVuY3Rpb24gZ2V0VGhlbihvYmopIHtcbiAgICB0cnkge1xuICAgICAgICByZXR1cm4gZG9HZXRUaGVuKG9iaik7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBlcnJvck9iai5lID0gZTtcbiAgICAgICAgcmV0dXJuIGVycm9yT2JqO1xuICAgIH1cbn1cblxudmFyIGhhc1Byb3AgPSB7fS5oYXNPd25Qcm9wZXJ0eTtcbmZ1bmN0aW9uIGlzQW55Qmx1ZWJpcmRQcm9taXNlKG9iaikge1xuICAgIHRyeSB7XG4gICAgICAgIHJldHVybiBoYXNQcm9wLmNhbGwob2JqLCBcIl9wcm9taXNlMFwiKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGRvVGhlbmFibGUoeCwgdGhlbiwgY29udGV4dCkge1xuICAgIHZhciBwcm9taXNlID0gbmV3IFByb21pc2UoSU5URVJOQUwpO1xuICAgIHZhciByZXQgPSBwcm9taXNlO1xuICAgIGlmIChjb250ZXh0KSBjb250ZXh0Ll9wdXNoQ29udGV4dCgpO1xuICAgIHByb21pc2UuX2NhcHR1cmVTdGFja1RyYWNlKCk7XG4gICAgaWYgKGNvbnRleHQpIGNvbnRleHQuX3BvcENvbnRleHQoKTtcbiAgICB2YXIgc3luY2hyb25vdXMgPSB0cnVlO1xuICAgIHZhciByZXN1bHQgPSB1dGlsLnRyeUNhdGNoKHRoZW4pLmNhbGwoeCwgcmVzb2x2ZSwgcmVqZWN0KTtcbiAgICBzeW5jaHJvbm91cyA9IGZhbHNlO1xuXG4gICAgaWYgKHByb21pc2UgJiYgcmVzdWx0ID09PSBlcnJvck9iaikge1xuICAgICAgICBwcm9taXNlLl9yZWplY3RDYWxsYmFjayhyZXN1bHQuZSwgdHJ1ZSwgdHJ1ZSk7XG4gICAgICAgIHByb21pc2UgPSBudWxsO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHJlc29sdmUodmFsdWUpIHtcbiAgICAgICAgaWYgKCFwcm9taXNlKSByZXR1cm47XG4gICAgICAgIHByb21pc2UuX3Jlc29sdmVDYWxsYmFjayh2YWx1ZSk7XG4gICAgICAgIHByb21pc2UgPSBudWxsO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHJlamVjdChyZWFzb24pIHtcbiAgICAgICAgaWYgKCFwcm9taXNlKSByZXR1cm47XG4gICAgICAgIHByb21pc2UuX3JlamVjdENhbGxiYWNrKHJlYXNvbiwgc3luY2hyb25vdXMsIHRydWUpO1xuICAgICAgICBwcm9taXNlID0gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIHJldDtcbn1cblxucmV0dXJuIHRyeUNvbnZlcnRUb1Byb21pc2U7XG59O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2JsdWViaXJkL2pzL3JlbGVhc2UvdGhlbmFibGVzLmpzIiwiXCJ1c2Ugc3RyaWN0XCI7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKFByb21pc2UsIElOVEVSTkFMLCB0cnlDb252ZXJ0VG9Qcm9taXNlLFxuICAgIGFwaVJlamVjdGlvbiwgUHJveHlhYmxlKSB7XG52YXIgdXRpbCA9IHJlcXVpcmUoXCIuL3V0aWxcIik7XG52YXIgaXNBcnJheSA9IHV0aWwuaXNBcnJheTtcblxuZnVuY3Rpb24gdG9SZXNvbHV0aW9uVmFsdWUodmFsKSB7XG4gICAgc3dpdGNoKHZhbCkge1xuICAgIGNhc2UgLTI6IHJldHVybiBbXTtcbiAgICBjYXNlIC0zOiByZXR1cm4ge307XG4gICAgY2FzZSAtNjogcmV0dXJuIG5ldyBNYXAoKTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIFByb21pc2VBcnJheSh2YWx1ZXMpIHtcbiAgICB2YXIgcHJvbWlzZSA9IHRoaXMuX3Byb21pc2UgPSBuZXcgUHJvbWlzZShJTlRFUk5BTCk7XG4gICAgaWYgKHZhbHVlcyBpbnN0YW5jZW9mIFByb21pc2UpIHtcbiAgICAgICAgcHJvbWlzZS5fcHJvcGFnYXRlRnJvbSh2YWx1ZXMsIDMpO1xuICAgIH1cbiAgICBwcm9taXNlLl9zZXRPbkNhbmNlbCh0aGlzKTtcbiAgICB0aGlzLl92YWx1ZXMgPSB2YWx1ZXM7XG4gICAgdGhpcy5fbGVuZ3RoID0gMDtcbiAgICB0aGlzLl90b3RhbFJlc29sdmVkID0gMDtcbiAgICB0aGlzLl9pbml0KHVuZGVmaW5lZCwgLTIpO1xufVxudXRpbC5pbmhlcml0cyhQcm9taXNlQXJyYXksIFByb3h5YWJsZSk7XG5cblByb21pc2VBcnJheS5wcm90b3R5cGUubGVuZ3RoID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLl9sZW5ndGg7XG59O1xuXG5Qcm9taXNlQXJyYXkucHJvdG90eXBlLnByb21pc2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3Byb21pc2U7XG59O1xuXG5Qcm9taXNlQXJyYXkucHJvdG90eXBlLl9pbml0ID0gZnVuY3Rpb24gaW5pdChfLCByZXNvbHZlVmFsdWVJZkVtcHR5KSB7XG4gICAgdmFyIHZhbHVlcyA9IHRyeUNvbnZlcnRUb1Byb21pc2UodGhpcy5fdmFsdWVzLCB0aGlzLl9wcm9taXNlKTtcbiAgICBpZiAodmFsdWVzIGluc3RhbmNlb2YgUHJvbWlzZSkge1xuICAgICAgICB2YWx1ZXMgPSB2YWx1ZXMuX3RhcmdldCgpO1xuICAgICAgICB2YXIgYml0RmllbGQgPSB2YWx1ZXMuX2JpdEZpZWxkO1xuICAgICAgICA7XG4gICAgICAgIHRoaXMuX3ZhbHVlcyA9IHZhbHVlcztcblxuICAgICAgICBpZiAoKChiaXRGaWVsZCAmIDUwMzk3MTg0KSA9PT0gMCkpIHtcbiAgICAgICAgICAgIHRoaXMuX3Byb21pc2UuX3NldEFzeW5jR3VhcmFudGVlZCgpO1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlcy5fdGhlbihcbiAgICAgICAgICAgICAgICBpbml0LFxuICAgICAgICAgICAgICAgIHRoaXMuX3JlamVjdCxcbiAgICAgICAgICAgICAgICB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgdGhpcyxcbiAgICAgICAgICAgICAgICByZXNvbHZlVmFsdWVJZkVtcHR5XG4gICAgICAgICAgICk7XG4gICAgICAgIH0gZWxzZSBpZiAoKChiaXRGaWVsZCAmIDMzNTU0NDMyKSAhPT0gMCkpIHtcbiAgICAgICAgICAgIHZhbHVlcyA9IHZhbHVlcy5fdmFsdWUoKTtcbiAgICAgICAgfSBlbHNlIGlmICgoKGJpdEZpZWxkICYgMTY3NzcyMTYpICE9PSAwKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3JlamVjdCh2YWx1ZXMuX3JlYXNvbigpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9jYW5jZWwoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICB2YWx1ZXMgPSB1dGlsLmFzQXJyYXkodmFsdWVzKTtcbiAgICBpZiAodmFsdWVzID09PSBudWxsKSB7XG4gICAgICAgIHZhciBlcnIgPSBhcGlSZWplY3Rpb24oXG4gICAgICAgICAgICBcImV4cGVjdGluZyBhbiBhcnJheSBvciBhbiBpdGVyYWJsZSBvYmplY3QgYnV0IGdvdCBcIiArIHV0aWwuY2xhc3NTdHJpbmcodmFsdWVzKSkucmVhc29uKCk7XG4gICAgICAgIHRoaXMuX3Byb21pc2UuX3JlamVjdENhbGxiYWNrKGVyciwgZmFsc2UpO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKHZhbHVlcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgaWYgKHJlc29sdmVWYWx1ZUlmRW1wdHkgPT09IC01KSB7XG4gICAgICAgICAgICB0aGlzLl9yZXNvbHZlRW1wdHlBcnJheSgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5fcmVzb2x2ZSh0b1Jlc29sdXRpb25WYWx1ZShyZXNvbHZlVmFsdWVJZkVtcHR5KSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLl9pdGVyYXRlKHZhbHVlcyk7XG59O1xuXG5Qcm9taXNlQXJyYXkucHJvdG90eXBlLl9pdGVyYXRlID0gZnVuY3Rpb24odmFsdWVzKSB7XG4gICAgdmFyIGxlbiA9IHRoaXMuZ2V0QWN0dWFsTGVuZ3RoKHZhbHVlcy5sZW5ndGgpO1xuICAgIHRoaXMuX2xlbmd0aCA9IGxlbjtcbiAgICB0aGlzLl92YWx1ZXMgPSB0aGlzLnNob3VsZENvcHlWYWx1ZXMoKSA/IG5ldyBBcnJheShsZW4pIDogdGhpcy5fdmFsdWVzO1xuICAgIHZhciByZXN1bHQgPSB0aGlzLl9wcm9taXNlO1xuICAgIHZhciBpc1Jlc29sdmVkID0gZmFsc2U7XG4gICAgdmFyIGJpdEZpZWxkID0gbnVsbDtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgKytpKSB7XG4gICAgICAgIHZhciBtYXliZVByb21pc2UgPSB0cnlDb252ZXJ0VG9Qcm9taXNlKHZhbHVlc1tpXSwgcmVzdWx0KTtcblxuICAgICAgICBpZiAobWF5YmVQcm9taXNlIGluc3RhbmNlb2YgUHJvbWlzZSkge1xuICAgICAgICAgICAgbWF5YmVQcm9taXNlID0gbWF5YmVQcm9taXNlLl90YXJnZXQoKTtcbiAgICAgICAgICAgIGJpdEZpZWxkID0gbWF5YmVQcm9taXNlLl9iaXRGaWVsZDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGJpdEZpZWxkID0gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChpc1Jlc29sdmVkKSB7XG4gICAgICAgICAgICBpZiAoYml0RmllbGQgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBtYXliZVByb21pc2Uuc3VwcHJlc3NVbmhhbmRsZWRSZWplY3Rpb25zKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoYml0RmllbGQgIT09IG51bGwpIHtcbiAgICAgICAgICAgIGlmICgoKGJpdEZpZWxkICYgNTAzOTcxODQpID09PSAwKSkge1xuICAgICAgICAgICAgICAgIG1heWJlUHJvbWlzZS5fcHJveHkodGhpcywgaSk7XG4gICAgICAgICAgICAgICAgdGhpcy5fdmFsdWVzW2ldID0gbWF5YmVQcm9taXNlO1xuICAgICAgICAgICAgfSBlbHNlIGlmICgoKGJpdEZpZWxkICYgMzM1NTQ0MzIpICE9PSAwKSkge1xuICAgICAgICAgICAgICAgIGlzUmVzb2x2ZWQgPSB0aGlzLl9wcm9taXNlRnVsZmlsbGVkKG1heWJlUHJvbWlzZS5fdmFsdWUoKSwgaSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKCgoYml0RmllbGQgJiAxNjc3NzIxNikgIT09IDApKSB7XG4gICAgICAgICAgICAgICAgaXNSZXNvbHZlZCA9IHRoaXMuX3Byb21pc2VSZWplY3RlZChtYXliZVByb21pc2UuX3JlYXNvbigpLCBpKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaXNSZXNvbHZlZCA9IHRoaXMuX3Byb21pc2VDYW5jZWxsZWQoaSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpc1Jlc29sdmVkID0gdGhpcy5fcHJvbWlzZUZ1bGZpbGxlZChtYXliZVByb21pc2UsIGkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmICghaXNSZXNvbHZlZCkgcmVzdWx0Ll9zZXRBc3luY0d1YXJhbnRlZWQoKTtcbn07XG5cblByb21pc2VBcnJheS5wcm90b3R5cGUuX2lzUmVzb2x2ZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3ZhbHVlcyA9PT0gbnVsbDtcbn07XG5cblByb21pc2VBcnJheS5wcm90b3R5cGUuX3Jlc29sdmUgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICB0aGlzLl92YWx1ZXMgPSBudWxsO1xuICAgIHRoaXMuX3Byb21pc2UuX2Z1bGZpbGwodmFsdWUpO1xufTtcblxuUHJvbWlzZUFycmF5LnByb3RvdHlwZS5fY2FuY2VsID0gZnVuY3Rpb24oKSB7XG4gICAgaWYgKHRoaXMuX2lzUmVzb2x2ZWQoKSB8fCAhdGhpcy5fcHJvbWlzZS5faXNDYW5jZWxsYWJsZSgpKSByZXR1cm47XG4gICAgdGhpcy5fdmFsdWVzID0gbnVsbDtcbiAgICB0aGlzLl9wcm9taXNlLl9jYW5jZWwoKTtcbn07XG5cblByb21pc2VBcnJheS5wcm90b3R5cGUuX3JlamVjdCA9IGZ1bmN0aW9uIChyZWFzb24pIHtcbiAgICB0aGlzLl92YWx1ZXMgPSBudWxsO1xuICAgIHRoaXMuX3Byb21pc2UuX3JlamVjdENhbGxiYWNrKHJlYXNvbiwgZmFsc2UpO1xufTtcblxuUHJvbWlzZUFycmF5LnByb3RvdHlwZS5fcHJvbWlzZUZ1bGZpbGxlZCA9IGZ1bmN0aW9uICh2YWx1ZSwgaW5kZXgpIHtcbiAgICB0aGlzLl92YWx1ZXNbaW5kZXhdID0gdmFsdWU7XG4gICAgdmFyIHRvdGFsUmVzb2x2ZWQgPSArK3RoaXMuX3RvdGFsUmVzb2x2ZWQ7XG4gICAgaWYgKHRvdGFsUmVzb2x2ZWQgPj0gdGhpcy5fbGVuZ3RoKSB7XG4gICAgICAgIHRoaXMuX3Jlc29sdmUodGhpcy5fdmFsdWVzKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn07XG5cblByb21pc2VBcnJheS5wcm90b3R5cGUuX3Byb21pc2VDYW5jZWxsZWQgPSBmdW5jdGlvbigpIHtcbiAgICB0aGlzLl9jYW5jZWwoKTtcbiAgICByZXR1cm4gdHJ1ZTtcbn07XG5cblByb21pc2VBcnJheS5wcm90b3R5cGUuX3Byb21pc2VSZWplY3RlZCA9IGZ1bmN0aW9uIChyZWFzb24pIHtcbiAgICB0aGlzLl90b3RhbFJlc29sdmVkKys7XG4gICAgdGhpcy5fcmVqZWN0KHJlYXNvbik7XG4gICAgcmV0dXJuIHRydWU7XG59O1xuXG5Qcm9taXNlQXJyYXkucHJvdG90eXBlLl9yZXN1bHRDYW5jZWxsZWQgPSBmdW5jdGlvbigpIHtcbiAgICBpZiAodGhpcy5faXNSZXNvbHZlZCgpKSByZXR1cm47XG4gICAgdmFyIHZhbHVlcyA9IHRoaXMuX3ZhbHVlcztcbiAgICB0aGlzLl9jYW5jZWwoKTtcbiAgICBpZiAodmFsdWVzIGluc3RhbmNlb2YgUHJvbWlzZSkge1xuICAgICAgICB2YWx1ZXMuY2FuY2VsKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB2YWx1ZXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIGlmICh2YWx1ZXNbaV0gaW5zdGFuY2VvZiBQcm9taXNlKSB7XG4gICAgICAgICAgICAgICAgdmFsdWVzW2ldLmNhbmNlbCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufTtcblxuUHJvbWlzZUFycmF5LnByb3RvdHlwZS5zaG91bGRDb3B5VmFsdWVzID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0cnVlO1xufTtcblxuUHJvbWlzZUFycmF5LnByb3RvdHlwZS5nZXRBY3R1YWxMZW5ndGggPSBmdW5jdGlvbiAobGVuKSB7XG4gICAgcmV0dXJuIGxlbjtcbn07XG5cbnJldHVybiBQcm9taXNlQXJyYXk7XG59O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2JsdWViaXJkL2pzL3JlbGVhc2UvcHJvbWlzZV9hcnJheS5qcyIsIlwidXNlIHN0cmljdFwiO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihQcm9taXNlKSB7XG52YXIgbG9uZ1N0YWNrVHJhY2VzID0gZmFsc2U7XG52YXIgY29udGV4dFN0YWNrID0gW107XG5cblByb21pc2UucHJvdG90eXBlLl9wcm9taXNlQ3JlYXRlZCA9IGZ1bmN0aW9uKCkge307XG5Qcm9taXNlLnByb3RvdHlwZS5fcHVzaENvbnRleHQgPSBmdW5jdGlvbigpIHt9O1xuUHJvbWlzZS5wcm90b3R5cGUuX3BvcENvbnRleHQgPSBmdW5jdGlvbigpIHtyZXR1cm4gbnVsbDt9O1xuUHJvbWlzZS5fcGVla0NvbnRleHQgPSBQcm9taXNlLnByb3RvdHlwZS5fcGVla0NvbnRleHQgPSBmdW5jdGlvbigpIHt9O1xuXG5mdW5jdGlvbiBDb250ZXh0KCkge1xuICAgIHRoaXMuX3RyYWNlID0gbmV3IENvbnRleHQuQ2FwdHVyZWRUcmFjZShwZWVrQ29udGV4dCgpKTtcbn1cbkNvbnRleHQucHJvdG90eXBlLl9wdXNoQ29udGV4dCA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAodGhpcy5fdHJhY2UgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aGlzLl90cmFjZS5fcHJvbWlzZUNyZWF0ZWQgPSBudWxsO1xuICAgICAgICBjb250ZXh0U3RhY2sucHVzaCh0aGlzLl90cmFjZSk7XG4gICAgfVxufTtcblxuQ29udGV4dC5wcm90b3R5cGUuX3BvcENvbnRleHQgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHRoaXMuX3RyYWNlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdmFyIHRyYWNlID0gY29udGV4dFN0YWNrLnBvcCgpO1xuICAgICAgICB2YXIgcmV0ID0gdHJhY2UuX3Byb21pc2VDcmVhdGVkO1xuICAgICAgICB0cmFjZS5fcHJvbWlzZUNyZWF0ZWQgPSBudWxsO1xuICAgICAgICByZXR1cm4gcmV0O1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbn07XG5cbmZ1bmN0aW9uIGNyZWF0ZUNvbnRleHQoKSB7XG4gICAgaWYgKGxvbmdTdGFja1RyYWNlcykgcmV0dXJuIG5ldyBDb250ZXh0KCk7XG59XG5cbmZ1bmN0aW9uIHBlZWtDb250ZXh0KCkge1xuICAgIHZhciBsYXN0SW5kZXggPSBjb250ZXh0U3RhY2subGVuZ3RoIC0gMTtcbiAgICBpZiAobGFzdEluZGV4ID49IDApIHtcbiAgICAgICAgcmV0dXJuIGNvbnRleHRTdGFja1tsYXN0SW5kZXhdO1xuICAgIH1cbiAgICByZXR1cm4gdW5kZWZpbmVkO1xufVxuQ29udGV4dC5DYXB0dXJlZFRyYWNlID0gbnVsbDtcbkNvbnRleHQuY3JlYXRlID0gY3JlYXRlQ29udGV4dDtcbkNvbnRleHQuZGVhY3RpdmF0ZUxvbmdTdGFja1RyYWNlcyA9IGZ1bmN0aW9uKCkge307XG5Db250ZXh0LmFjdGl2YXRlTG9uZ1N0YWNrVHJhY2VzID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIFByb21pc2VfcHVzaENvbnRleHQgPSBQcm9taXNlLnByb3RvdHlwZS5fcHVzaENvbnRleHQ7XG4gICAgdmFyIFByb21pc2VfcG9wQ29udGV4dCA9IFByb21pc2UucHJvdG90eXBlLl9wb3BDb250ZXh0O1xuICAgIHZhciBQcm9taXNlX1BlZWtDb250ZXh0ID0gUHJvbWlzZS5fcGVla0NvbnRleHQ7XG4gICAgdmFyIFByb21pc2VfcGVla0NvbnRleHQgPSBQcm9taXNlLnByb3RvdHlwZS5fcGVla0NvbnRleHQ7XG4gICAgdmFyIFByb21pc2VfcHJvbWlzZUNyZWF0ZWQgPSBQcm9taXNlLnByb3RvdHlwZS5fcHJvbWlzZUNyZWF0ZWQ7XG4gICAgQ29udGV4dC5kZWFjdGl2YXRlTG9uZ1N0YWNrVHJhY2VzID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIFByb21pc2UucHJvdG90eXBlLl9wdXNoQ29udGV4dCA9IFByb21pc2VfcHVzaENvbnRleHQ7XG4gICAgICAgIFByb21pc2UucHJvdG90eXBlLl9wb3BDb250ZXh0ID0gUHJvbWlzZV9wb3BDb250ZXh0O1xuICAgICAgICBQcm9taXNlLl9wZWVrQ29udGV4dCA9IFByb21pc2VfUGVla0NvbnRleHQ7XG4gICAgICAgIFByb21pc2UucHJvdG90eXBlLl9wZWVrQ29udGV4dCA9IFByb21pc2VfcGVla0NvbnRleHQ7XG4gICAgICAgIFByb21pc2UucHJvdG90eXBlLl9wcm9taXNlQ3JlYXRlZCA9IFByb21pc2VfcHJvbWlzZUNyZWF0ZWQ7XG4gICAgICAgIGxvbmdTdGFja1RyYWNlcyA9IGZhbHNlO1xuICAgIH07XG4gICAgbG9uZ1N0YWNrVHJhY2VzID0gdHJ1ZTtcbiAgICBQcm9taXNlLnByb3RvdHlwZS5fcHVzaENvbnRleHQgPSBDb250ZXh0LnByb3RvdHlwZS5fcHVzaENvbnRleHQ7XG4gICAgUHJvbWlzZS5wcm90b3R5cGUuX3BvcENvbnRleHQgPSBDb250ZXh0LnByb3RvdHlwZS5fcG9wQ29udGV4dDtcbiAgICBQcm9taXNlLl9wZWVrQ29udGV4dCA9IFByb21pc2UucHJvdG90eXBlLl9wZWVrQ29udGV4dCA9IHBlZWtDb250ZXh0O1xuICAgIFByb21pc2UucHJvdG90eXBlLl9wcm9taXNlQ3JlYXRlZCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgY3R4ID0gdGhpcy5fcGVla0NvbnRleHQoKTtcbiAgICAgICAgaWYgKGN0eCAmJiBjdHguX3Byb21pc2VDcmVhdGVkID09IG51bGwpIGN0eC5fcHJvbWlzZUNyZWF0ZWQgPSB0aGlzO1xuICAgIH07XG59O1xucmV0dXJuIENvbnRleHQ7XG59O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2JsdWViaXJkL2pzL3JlbGVhc2UvY29udGV4dC5qcyIsIlwidXNlIHN0cmljdFwiO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihQcm9taXNlLCBDb250ZXh0KSB7XG52YXIgZ2V0RG9tYWluID0gUHJvbWlzZS5fZ2V0RG9tYWluO1xudmFyIGFzeW5jID0gUHJvbWlzZS5fYXN5bmM7XG52YXIgV2FybmluZyA9IHJlcXVpcmUoXCIuL2Vycm9yc1wiKS5XYXJuaW5nO1xudmFyIHV0aWwgPSByZXF1aXJlKFwiLi91dGlsXCIpO1xudmFyIGNhbkF0dGFjaFRyYWNlID0gdXRpbC5jYW5BdHRhY2hUcmFjZTtcbnZhciB1bmhhbmRsZWRSZWplY3Rpb25IYW5kbGVkO1xudmFyIHBvc3NpYmx5VW5oYW5kbGVkUmVqZWN0aW9uO1xudmFyIGJsdWViaXJkRnJhbWVQYXR0ZXJuID1cbiAgICAvW1xcXFxcXC9dYmx1ZWJpcmRbXFxcXFxcL11qc1tcXFxcXFwvXShyZWxlYXNlfGRlYnVnfGluc3RydW1lbnRlZCkvO1xudmFyIG5vZGVGcmFtZVBhdHRlcm4gPSAvXFwoKD86dGltZXJzXFwuanMpOlxcZCs6XFxkK1xcKS87XG52YXIgcGFyc2VMaW5lUGF0dGVybiA9IC9bXFwvPFxcKF0oLis/KTooXFxkKyk6KFxcZCspXFwpP1xccyokLztcbnZhciBzdGFja0ZyYW1lUGF0dGVybiA9IG51bGw7XG52YXIgZm9ybWF0U3RhY2sgPSBudWxsO1xudmFyIGluZGVudFN0YWNrRnJhbWVzID0gZmFsc2U7XG52YXIgcHJpbnRXYXJuaW5nO1xudmFyIGRlYnVnZ2luZyA9ICEhKHV0aWwuZW52KFwiQkxVRUJJUkRfREVCVUdcIikgIT0gMCAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgKGZhbHNlIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgdXRpbC5lbnYoXCJCTFVFQklSRF9ERUJVR1wiKSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgIHV0aWwuZW52KFwiTk9ERV9FTlZcIikgPT09IFwiZGV2ZWxvcG1lbnRcIikpO1xuXG52YXIgd2FybmluZ3MgPSAhISh1dGlsLmVudihcIkJMVUVCSVJEX1dBUk5JTkdTXCIpICE9IDAgJiZcbiAgICAoZGVidWdnaW5nIHx8IHV0aWwuZW52KFwiQkxVRUJJUkRfV0FSTklOR1NcIikpKTtcblxudmFyIGxvbmdTdGFja1RyYWNlcyA9ICEhKHV0aWwuZW52KFwiQkxVRUJJUkRfTE9OR19TVEFDS19UUkFDRVNcIikgIT0gMCAmJlxuICAgIChkZWJ1Z2dpbmcgfHwgdXRpbC5lbnYoXCJCTFVFQklSRF9MT05HX1NUQUNLX1RSQUNFU1wiKSkpO1xuXG52YXIgd0ZvcmdvdHRlblJldHVybiA9IHV0aWwuZW52KFwiQkxVRUJJUkRfV19GT1JHT1RURU5fUkVUVVJOXCIpICE9IDAgJiZcbiAgICAod2FybmluZ3MgfHwgISF1dGlsLmVudihcIkJMVUVCSVJEX1dfRk9SR09UVEVOX1JFVFVSTlwiKSk7XG5cblByb21pc2UucHJvdG90eXBlLnN1cHByZXNzVW5oYW5kbGVkUmVqZWN0aW9ucyA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciB0YXJnZXQgPSB0aGlzLl90YXJnZXQoKTtcbiAgICB0YXJnZXQuX2JpdEZpZWxkID0gKCh0YXJnZXQuX2JpdEZpZWxkICYgKH4xMDQ4NTc2KSkgfFxuICAgICAgICAgICAgICAgICAgICAgIDUyNDI4OCk7XG59O1xuXG5Qcm9taXNlLnByb3RvdHlwZS5fZW5zdXJlUG9zc2libGVSZWplY3Rpb25IYW5kbGVkID0gZnVuY3Rpb24gKCkge1xuICAgIGlmICgodGhpcy5fYml0RmllbGQgJiA1MjQyODgpICE9PSAwKSByZXR1cm47XG4gICAgdGhpcy5fc2V0UmVqZWN0aW9uSXNVbmhhbmRsZWQoKTtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgc2VsZi5fbm90aWZ5VW5oYW5kbGVkUmVqZWN0aW9uKCk7XG4gICAgfSwgMSk7XG59O1xuXG5Qcm9taXNlLnByb3RvdHlwZS5fbm90aWZ5VW5oYW5kbGVkUmVqZWN0aW9uSXNIYW5kbGVkID0gZnVuY3Rpb24gKCkge1xuICAgIGZpcmVSZWplY3Rpb25FdmVudChcInJlamVjdGlvbkhhbmRsZWRcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB1bmhhbmRsZWRSZWplY3Rpb25IYW5kbGVkLCB1bmRlZmluZWQsIHRoaXMpO1xufTtcblxuUHJvbWlzZS5wcm90b3R5cGUuX3NldFJldHVybmVkTm9uVW5kZWZpbmVkID0gZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5fYml0RmllbGQgPSB0aGlzLl9iaXRGaWVsZCB8IDI2ODQzNTQ1Njtcbn07XG5cblByb21pc2UucHJvdG90eXBlLl9yZXR1cm5lZE5vblVuZGVmaW5lZCA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiAodGhpcy5fYml0RmllbGQgJiAyNjg0MzU0NTYpICE9PSAwO1xufTtcblxuUHJvbWlzZS5wcm90b3R5cGUuX25vdGlmeVVuaGFuZGxlZFJlamVjdGlvbiA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAodGhpcy5faXNSZWplY3Rpb25VbmhhbmRsZWQoKSkge1xuICAgICAgICB2YXIgcmVhc29uID0gdGhpcy5fc2V0dGxlZFZhbHVlKCk7XG4gICAgICAgIHRoaXMuX3NldFVuaGFuZGxlZFJlamVjdGlvbklzTm90aWZpZWQoKTtcbiAgICAgICAgZmlyZVJlamVjdGlvbkV2ZW50KFwidW5oYW5kbGVkUmVqZWN0aW9uXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBvc3NpYmx5VW5oYW5kbGVkUmVqZWN0aW9uLCByZWFzb24sIHRoaXMpO1xuICAgIH1cbn07XG5cblByb21pc2UucHJvdG90eXBlLl9zZXRVbmhhbmRsZWRSZWplY3Rpb25Jc05vdGlmaWVkID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuX2JpdEZpZWxkID0gdGhpcy5fYml0RmllbGQgfCAyNjIxNDQ7XG59O1xuXG5Qcm9taXNlLnByb3RvdHlwZS5fdW5zZXRVbmhhbmRsZWRSZWplY3Rpb25Jc05vdGlmaWVkID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuX2JpdEZpZWxkID0gdGhpcy5fYml0RmllbGQgJiAofjI2MjE0NCk7XG59O1xuXG5Qcm9taXNlLnByb3RvdHlwZS5faXNVbmhhbmRsZWRSZWplY3Rpb25Ob3RpZmllZCA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gKHRoaXMuX2JpdEZpZWxkICYgMjYyMTQ0KSA+IDA7XG59O1xuXG5Qcm9taXNlLnByb3RvdHlwZS5fc2V0UmVqZWN0aW9uSXNVbmhhbmRsZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5fYml0RmllbGQgPSB0aGlzLl9iaXRGaWVsZCB8IDEwNDg1NzY7XG59O1xuXG5Qcm9taXNlLnByb3RvdHlwZS5fdW5zZXRSZWplY3Rpb25Jc1VuaGFuZGxlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLl9iaXRGaWVsZCA9IHRoaXMuX2JpdEZpZWxkICYgKH4xMDQ4NTc2KTtcbiAgICBpZiAodGhpcy5faXNVbmhhbmRsZWRSZWplY3Rpb25Ob3RpZmllZCgpKSB7XG4gICAgICAgIHRoaXMuX3Vuc2V0VW5oYW5kbGVkUmVqZWN0aW9uSXNOb3RpZmllZCgpO1xuICAgICAgICB0aGlzLl9ub3RpZnlVbmhhbmRsZWRSZWplY3Rpb25Jc0hhbmRsZWQoKTtcbiAgICB9XG59O1xuXG5Qcm9taXNlLnByb3RvdHlwZS5faXNSZWplY3Rpb25VbmhhbmRsZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuICh0aGlzLl9iaXRGaWVsZCAmIDEwNDg1NzYpID4gMDtcbn07XG5cblByb21pc2UucHJvdG90eXBlLl93YXJuID0gZnVuY3Rpb24obWVzc2FnZSwgc2hvdWxkVXNlT3duVHJhY2UsIHByb21pc2UpIHtcbiAgICByZXR1cm4gd2FybihtZXNzYWdlLCBzaG91bGRVc2VPd25UcmFjZSwgcHJvbWlzZSB8fCB0aGlzKTtcbn07XG5cblByb21pc2Uub25Qb3NzaWJseVVuaGFuZGxlZFJlamVjdGlvbiA9IGZ1bmN0aW9uIChmbikge1xuICAgIHZhciBkb21haW4gPSBnZXREb21haW4oKTtcbiAgICBwb3NzaWJseVVuaGFuZGxlZFJlamVjdGlvbiA9XG4gICAgICAgIHR5cGVvZiBmbiA9PT0gXCJmdW5jdGlvblwiID8gKGRvbWFpbiA9PT0gbnVsbCA/XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZuIDogdXRpbC5kb21haW5CaW5kKGRvbWFpbiwgZm4pKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOiB1bmRlZmluZWQ7XG59O1xuXG5Qcm9taXNlLm9uVW5oYW5kbGVkUmVqZWN0aW9uSGFuZGxlZCA9IGZ1bmN0aW9uIChmbikge1xuICAgIHZhciBkb21haW4gPSBnZXREb21haW4oKTtcbiAgICB1bmhhbmRsZWRSZWplY3Rpb25IYW5kbGVkID1cbiAgICAgICAgdHlwZW9mIGZuID09PSBcImZ1bmN0aW9uXCIgPyAoZG9tYWluID09PSBudWxsID9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm4gOiB1dGlsLmRvbWFpbkJpbmQoZG9tYWluLCBmbikpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZDtcbn07XG5cbnZhciBkaXNhYmxlTG9uZ1N0YWNrVHJhY2VzID0gZnVuY3Rpb24oKSB7fTtcblByb21pc2UubG9uZ1N0YWNrVHJhY2VzID0gZnVuY3Rpb24gKCkge1xuICAgIGlmIChhc3luYy5oYXZlSXRlbXNRdWV1ZWQoKSAmJiAhY29uZmlnLmxvbmdTdGFja1RyYWNlcykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJjYW5ub3QgZW5hYmxlIGxvbmcgc3RhY2sgdHJhY2VzIGFmdGVyIHByb21pc2VzIGhhdmUgYmVlbiBjcmVhdGVkXFx1MDAwYVxcdTAwMGEgICAgU2VlIGh0dHA6Ly9nb28uZ2wvTXFyRm1YXFx1MDAwYVwiKTtcbiAgICB9XG4gICAgaWYgKCFjb25maWcubG9uZ1N0YWNrVHJhY2VzICYmIGxvbmdTdGFja1RyYWNlc0lzU3VwcG9ydGVkKCkpIHtcbiAgICAgICAgdmFyIFByb21pc2VfY2FwdHVyZVN0YWNrVHJhY2UgPSBQcm9taXNlLnByb3RvdHlwZS5fY2FwdHVyZVN0YWNrVHJhY2U7XG4gICAgICAgIHZhciBQcm9taXNlX2F0dGFjaEV4dHJhVHJhY2UgPSBQcm9taXNlLnByb3RvdHlwZS5fYXR0YWNoRXh0cmFUcmFjZTtcbiAgICAgICAgY29uZmlnLmxvbmdTdGFja1RyYWNlcyA9IHRydWU7XG4gICAgICAgIGRpc2FibGVMb25nU3RhY2tUcmFjZXMgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGlmIChhc3luYy5oYXZlSXRlbXNRdWV1ZWQoKSAmJiAhY29uZmlnLmxvbmdTdGFja1RyYWNlcykge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImNhbm5vdCBlbmFibGUgbG9uZyBzdGFjayB0cmFjZXMgYWZ0ZXIgcHJvbWlzZXMgaGF2ZSBiZWVuIGNyZWF0ZWRcXHUwMDBhXFx1MDAwYSAgICBTZWUgaHR0cDovL2dvby5nbC9NcXJGbVhcXHUwMDBhXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgUHJvbWlzZS5wcm90b3R5cGUuX2NhcHR1cmVTdGFja1RyYWNlID0gUHJvbWlzZV9jYXB0dXJlU3RhY2tUcmFjZTtcbiAgICAgICAgICAgIFByb21pc2UucHJvdG90eXBlLl9hdHRhY2hFeHRyYVRyYWNlID0gUHJvbWlzZV9hdHRhY2hFeHRyYVRyYWNlO1xuICAgICAgICAgICAgQ29udGV4dC5kZWFjdGl2YXRlTG9uZ1N0YWNrVHJhY2VzKCk7XG4gICAgICAgICAgICBhc3luYy5lbmFibGVUcmFtcG9saW5lKCk7XG4gICAgICAgICAgICBjb25maWcubG9uZ1N0YWNrVHJhY2VzID0gZmFsc2U7XG4gICAgICAgIH07XG4gICAgICAgIFByb21pc2UucHJvdG90eXBlLl9jYXB0dXJlU3RhY2tUcmFjZSA9IGxvbmdTdGFja1RyYWNlc0NhcHR1cmVTdGFja1RyYWNlO1xuICAgICAgICBQcm9taXNlLnByb3RvdHlwZS5fYXR0YWNoRXh0cmFUcmFjZSA9IGxvbmdTdGFja1RyYWNlc0F0dGFjaEV4dHJhVHJhY2U7XG4gICAgICAgIENvbnRleHQuYWN0aXZhdGVMb25nU3RhY2tUcmFjZXMoKTtcbiAgICAgICAgYXN5bmMuZGlzYWJsZVRyYW1wb2xpbmVJZk5lY2Vzc2FyeSgpO1xuICAgIH1cbn07XG5cblByb21pc2UuaGFzTG9uZ1N0YWNrVHJhY2VzID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBjb25maWcubG9uZ1N0YWNrVHJhY2VzICYmIGxvbmdTdGFja1RyYWNlc0lzU3VwcG9ydGVkKCk7XG59O1xuXG52YXIgZmlyZURvbUV2ZW50ID0gKGZ1bmN0aW9uKCkge1xuICAgIHRyeSB7XG4gICAgICAgIGlmICh0eXBlb2YgQ3VzdG9tRXZlbnQgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgdmFyIGV2ZW50ID0gbmV3IEN1c3RvbUV2ZW50KFwiQ3VzdG9tRXZlbnRcIik7XG4gICAgICAgICAgICB1dGlsLmdsb2JhbC5kaXNwYXRjaEV2ZW50KGV2ZW50KTtcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbihuYW1lLCBldmVudCkge1xuICAgICAgICAgICAgICAgIHZhciBkb21FdmVudCA9IG5ldyBDdXN0b21FdmVudChuYW1lLnRvTG93ZXJDYXNlKCksIHtcbiAgICAgICAgICAgICAgICAgICAgZGV0YWlsOiBldmVudCxcbiAgICAgICAgICAgICAgICAgICAgY2FuY2VsYWJsZTogdHJ1ZVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHJldHVybiAhdXRpbC5nbG9iYWwuZGlzcGF0Y2hFdmVudChkb21FdmVudCk7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBFdmVudCA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICB2YXIgZXZlbnQgPSBuZXcgRXZlbnQoXCJDdXN0b21FdmVudFwiKTtcbiAgICAgICAgICAgIHV0aWwuZ2xvYmFsLmRpc3BhdGNoRXZlbnQoZXZlbnQpO1xuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKG5hbWUsIGV2ZW50KSB7XG4gICAgICAgICAgICAgICAgdmFyIGRvbUV2ZW50ID0gbmV3IEV2ZW50KG5hbWUudG9Mb3dlckNhc2UoKSwge1xuICAgICAgICAgICAgICAgICAgICBjYW5jZWxhYmxlOiB0cnVlXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgZG9tRXZlbnQuZGV0YWlsID0gZXZlbnQ7XG4gICAgICAgICAgICAgICAgcmV0dXJuICF1dGlsLmdsb2JhbC5kaXNwYXRjaEV2ZW50KGRvbUV2ZW50KTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YXIgZXZlbnQgPSBkb2N1bWVudC5jcmVhdGVFdmVudChcIkN1c3RvbUV2ZW50XCIpO1xuICAgICAgICAgICAgZXZlbnQuaW5pdEN1c3RvbUV2ZW50KFwidGVzdGluZ3RoZWV2ZW50XCIsIGZhbHNlLCB0cnVlLCB7fSk7XG4gICAgICAgICAgICB1dGlsLmdsb2JhbC5kaXNwYXRjaEV2ZW50KGV2ZW50KTtcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbihuYW1lLCBldmVudCkge1xuICAgICAgICAgICAgICAgIHZhciBkb21FdmVudCA9IGRvY3VtZW50LmNyZWF0ZUV2ZW50KFwiQ3VzdG9tRXZlbnRcIik7XG4gICAgICAgICAgICAgICAgZG9tRXZlbnQuaW5pdEN1c3RvbUV2ZW50KG5hbWUudG9Mb3dlckNhc2UoKSwgZmFsc2UsIHRydWUsXG4gICAgICAgICAgICAgICAgICAgIGV2ZW50KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gIXV0aWwuZ2xvYmFsLmRpc3BhdGNoRXZlbnQoZG9tRXZlbnQpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgIH0gY2F0Y2ggKGUpIHt9XG4gICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfTtcbn0pKCk7XG5cbnZhciBmaXJlR2xvYmFsRXZlbnQgPSAoZnVuY3Rpb24oKSB7XG4gICAgaWYgKHV0aWwuaXNOb2RlKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiBwcm9jZXNzLmVtaXQuYXBwbHkocHJvY2VzcywgYXJndW1lbnRzKTtcbiAgICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoIXV0aWwuZ2xvYmFsKSB7XG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZnVuY3Rpb24obmFtZSkge1xuICAgICAgICAgICAgdmFyIG1ldGhvZE5hbWUgPSBcIm9uXCIgKyBuYW1lLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICB2YXIgbWV0aG9kID0gdXRpbC5nbG9iYWxbbWV0aG9kTmFtZV07XG4gICAgICAgICAgICBpZiAoIW1ldGhvZCkgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgbWV0aG9kLmFwcGx5KHV0aWwuZ2xvYmFsLCBbXS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSkpO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH07XG4gICAgfVxufSkoKTtcblxuZnVuY3Rpb24gZ2VuZXJhdGVQcm9taXNlTGlmZWN5Y2xlRXZlbnRPYmplY3QobmFtZSwgcHJvbWlzZSkge1xuICAgIHJldHVybiB7cHJvbWlzZTogcHJvbWlzZX07XG59XG5cbnZhciBldmVudFRvT2JqZWN0R2VuZXJhdG9yID0ge1xuICAgIHByb21pc2VDcmVhdGVkOiBnZW5lcmF0ZVByb21pc2VMaWZlY3ljbGVFdmVudE9iamVjdCxcbiAgICBwcm9taXNlRnVsZmlsbGVkOiBnZW5lcmF0ZVByb21pc2VMaWZlY3ljbGVFdmVudE9iamVjdCxcbiAgICBwcm9taXNlUmVqZWN0ZWQ6IGdlbmVyYXRlUHJvbWlzZUxpZmVjeWNsZUV2ZW50T2JqZWN0LFxuICAgIHByb21pc2VSZXNvbHZlZDogZ2VuZXJhdGVQcm9taXNlTGlmZWN5Y2xlRXZlbnRPYmplY3QsXG4gICAgcHJvbWlzZUNhbmNlbGxlZDogZ2VuZXJhdGVQcm9taXNlTGlmZWN5Y2xlRXZlbnRPYmplY3QsXG4gICAgcHJvbWlzZUNoYWluZWQ6IGZ1bmN0aW9uKG5hbWUsIHByb21pc2UsIGNoaWxkKSB7XG4gICAgICAgIHJldHVybiB7cHJvbWlzZTogcHJvbWlzZSwgY2hpbGQ6IGNoaWxkfTtcbiAgICB9LFxuICAgIHdhcm5pbmc6IGZ1bmN0aW9uKG5hbWUsIHdhcm5pbmcpIHtcbiAgICAgICAgcmV0dXJuIHt3YXJuaW5nOiB3YXJuaW5nfTtcbiAgICB9LFxuICAgIHVuaGFuZGxlZFJlamVjdGlvbjogZnVuY3Rpb24gKG5hbWUsIHJlYXNvbiwgcHJvbWlzZSkge1xuICAgICAgICByZXR1cm4ge3JlYXNvbjogcmVhc29uLCBwcm9taXNlOiBwcm9taXNlfTtcbiAgICB9LFxuICAgIHJlamVjdGlvbkhhbmRsZWQ6IGdlbmVyYXRlUHJvbWlzZUxpZmVjeWNsZUV2ZW50T2JqZWN0XG59O1xuXG52YXIgYWN0aXZlRmlyZUV2ZW50ID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICB2YXIgZ2xvYmFsRXZlbnRGaXJlZCA9IGZhbHNlO1xuICAgIHRyeSB7XG4gICAgICAgIGdsb2JhbEV2ZW50RmlyZWQgPSBmaXJlR2xvYmFsRXZlbnQuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGFzeW5jLnRocm93TGF0ZXIoZSk7XG4gICAgICAgIGdsb2JhbEV2ZW50RmlyZWQgPSB0cnVlO1xuICAgIH1cblxuICAgIHZhciBkb21FdmVudEZpcmVkID0gZmFsc2U7XG4gICAgdHJ5IHtcbiAgICAgICAgZG9tRXZlbnRGaXJlZCA9IGZpcmVEb21FdmVudChuYW1lLFxuICAgICAgICAgICAgICAgICAgICBldmVudFRvT2JqZWN0R2VuZXJhdG9yW25hbWVdLmFwcGx5KG51bGwsIGFyZ3VtZW50cykpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgYXN5bmMudGhyb3dMYXRlcihlKTtcbiAgICAgICAgZG9tRXZlbnRGaXJlZCA9IHRydWU7XG4gICAgfVxuXG4gICAgcmV0dXJuIGRvbUV2ZW50RmlyZWQgfHwgZ2xvYmFsRXZlbnRGaXJlZDtcbn07XG5cblByb21pc2UuY29uZmlnID0gZnVuY3Rpb24ob3B0cykge1xuICAgIG9wdHMgPSBPYmplY3Qob3B0cyk7XG4gICAgaWYgKFwibG9uZ1N0YWNrVHJhY2VzXCIgaW4gb3B0cykge1xuICAgICAgICBpZiAob3B0cy5sb25nU3RhY2tUcmFjZXMpIHtcbiAgICAgICAgICAgIFByb21pc2UubG9uZ1N0YWNrVHJhY2VzKCk7XG4gICAgICAgIH0gZWxzZSBpZiAoIW9wdHMubG9uZ1N0YWNrVHJhY2VzICYmIFByb21pc2UuaGFzTG9uZ1N0YWNrVHJhY2VzKCkpIHtcbiAgICAgICAgICAgIGRpc2FibGVMb25nU3RhY2tUcmFjZXMoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoXCJ3YXJuaW5nc1wiIGluIG9wdHMpIHtcbiAgICAgICAgdmFyIHdhcm5pbmdzT3B0aW9uID0gb3B0cy53YXJuaW5ncztcbiAgICAgICAgY29uZmlnLndhcm5pbmdzID0gISF3YXJuaW5nc09wdGlvbjtcbiAgICAgICAgd0ZvcmdvdHRlblJldHVybiA9IGNvbmZpZy53YXJuaW5ncztcblxuICAgICAgICBpZiAodXRpbC5pc09iamVjdCh3YXJuaW5nc09wdGlvbikpIHtcbiAgICAgICAgICAgIGlmIChcIndGb3Jnb3R0ZW5SZXR1cm5cIiBpbiB3YXJuaW5nc09wdGlvbikge1xuICAgICAgICAgICAgICAgIHdGb3Jnb3R0ZW5SZXR1cm4gPSAhIXdhcm5pbmdzT3B0aW9uLndGb3Jnb3R0ZW5SZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKFwiY2FuY2VsbGF0aW9uXCIgaW4gb3B0cyAmJiBvcHRzLmNhbmNlbGxhdGlvbiAmJiAhY29uZmlnLmNhbmNlbGxhdGlvbikge1xuICAgICAgICBpZiAoYXN5bmMuaGF2ZUl0ZW1zUXVldWVkKCkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAgICAgICBcImNhbm5vdCBlbmFibGUgY2FuY2VsbGF0aW9uIGFmdGVyIHByb21pc2VzIGFyZSBpbiB1c2VcIik7XG4gICAgICAgIH1cbiAgICAgICAgUHJvbWlzZS5wcm90b3R5cGUuX2NsZWFyQ2FuY2VsbGF0aW9uRGF0YSA9XG4gICAgICAgICAgICBjYW5jZWxsYXRpb25DbGVhckNhbmNlbGxhdGlvbkRhdGE7XG4gICAgICAgIFByb21pc2UucHJvdG90eXBlLl9wcm9wYWdhdGVGcm9tID0gY2FuY2VsbGF0aW9uUHJvcGFnYXRlRnJvbTtcbiAgICAgICAgUHJvbWlzZS5wcm90b3R5cGUuX29uQ2FuY2VsID0gY2FuY2VsbGF0aW9uT25DYW5jZWw7XG4gICAgICAgIFByb21pc2UucHJvdG90eXBlLl9zZXRPbkNhbmNlbCA9IGNhbmNlbGxhdGlvblNldE9uQ2FuY2VsO1xuICAgICAgICBQcm9taXNlLnByb3RvdHlwZS5fYXR0YWNoQ2FuY2VsbGF0aW9uQ2FsbGJhY2sgPVxuICAgICAgICAgICAgY2FuY2VsbGF0aW9uQXR0YWNoQ2FuY2VsbGF0aW9uQ2FsbGJhY2s7XG4gICAgICAgIFByb21pc2UucHJvdG90eXBlLl9leGVjdXRlID0gY2FuY2VsbGF0aW9uRXhlY3V0ZTtcbiAgICAgICAgcHJvcGFnYXRlRnJvbUZ1bmN0aW9uID0gY2FuY2VsbGF0aW9uUHJvcGFnYXRlRnJvbTtcbiAgICAgICAgY29uZmlnLmNhbmNlbGxhdGlvbiA9IHRydWU7XG4gICAgfVxuICAgIGlmIChcIm1vbml0b3JpbmdcIiBpbiBvcHRzKSB7XG4gICAgICAgIGlmIChvcHRzLm1vbml0b3JpbmcgJiYgIWNvbmZpZy5tb25pdG9yaW5nKSB7XG4gICAgICAgICAgICBjb25maWcubW9uaXRvcmluZyA9IHRydWU7XG4gICAgICAgICAgICBQcm9taXNlLnByb3RvdHlwZS5fZmlyZUV2ZW50ID0gYWN0aXZlRmlyZUV2ZW50O1xuICAgICAgICB9IGVsc2UgaWYgKCFvcHRzLm1vbml0b3JpbmcgJiYgY29uZmlnLm1vbml0b3JpbmcpIHtcbiAgICAgICAgICAgIGNvbmZpZy5tb25pdG9yaW5nID0gZmFsc2U7XG4gICAgICAgICAgICBQcm9taXNlLnByb3RvdHlwZS5fZmlyZUV2ZW50ID0gZGVmYXVsdEZpcmVFdmVudDtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gUHJvbWlzZTtcbn07XG5cbmZ1bmN0aW9uIGRlZmF1bHRGaXJlRXZlbnQoKSB7IHJldHVybiBmYWxzZTsgfVxuXG5Qcm9taXNlLnByb3RvdHlwZS5fZmlyZUV2ZW50ID0gZGVmYXVsdEZpcmVFdmVudDtcblByb21pc2UucHJvdG90eXBlLl9leGVjdXRlID0gZnVuY3Rpb24oZXhlY3V0b3IsIHJlc29sdmUsIHJlamVjdCkge1xuICAgIHRyeSB7XG4gICAgICAgIGV4ZWN1dG9yKHJlc29sdmUsIHJlamVjdCk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgICByZXR1cm4gZTtcbiAgICB9XG59O1xuUHJvbWlzZS5wcm90b3R5cGUuX29uQ2FuY2VsID0gZnVuY3Rpb24gKCkge307XG5Qcm9taXNlLnByb3RvdHlwZS5fc2V0T25DYW5jZWwgPSBmdW5jdGlvbiAoaGFuZGxlcikgeyA7IH07XG5Qcm9taXNlLnByb3RvdHlwZS5fYXR0YWNoQ2FuY2VsbGF0aW9uQ2FsbGJhY2sgPSBmdW5jdGlvbihvbkNhbmNlbCkge1xuICAgIDtcbn07XG5Qcm9taXNlLnByb3RvdHlwZS5fY2FwdHVyZVN0YWNrVHJhY2UgPSBmdW5jdGlvbiAoKSB7fTtcblByb21pc2UucHJvdG90eXBlLl9hdHRhY2hFeHRyYVRyYWNlID0gZnVuY3Rpb24gKCkge307XG5Qcm9taXNlLnByb3RvdHlwZS5fY2xlYXJDYW5jZWxsYXRpb25EYXRhID0gZnVuY3Rpb24oKSB7fTtcblByb21pc2UucHJvdG90eXBlLl9wcm9wYWdhdGVGcm9tID0gZnVuY3Rpb24gKHBhcmVudCwgZmxhZ3MpIHtcbiAgICA7XG4gICAgO1xufTtcblxuZnVuY3Rpb24gY2FuY2VsbGF0aW9uRXhlY3V0ZShleGVjdXRvciwgcmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgdmFyIHByb21pc2UgPSB0aGlzO1xuICAgIHRyeSB7XG4gICAgICAgIGV4ZWN1dG9yKHJlc29sdmUsIHJlamVjdCwgZnVuY3Rpb24ob25DYW5jZWwpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygb25DYW5jZWwgIT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJvbkNhbmNlbCBtdXN0IGJlIGEgZnVuY3Rpb24sIGdvdDogXCIgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdXRpbC50b1N0cmluZyhvbkNhbmNlbCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcHJvbWlzZS5fYXR0YWNoQ2FuY2VsbGF0aW9uQ2FsbGJhY2sob25DYW5jZWwpO1xuICAgICAgICB9KTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIHJldHVybiBlO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gY2FuY2VsbGF0aW9uQXR0YWNoQ2FuY2VsbGF0aW9uQ2FsbGJhY2sob25DYW5jZWwpIHtcbiAgICBpZiAoIXRoaXMuX2lzQ2FuY2VsbGFibGUoKSkgcmV0dXJuIHRoaXM7XG5cbiAgICB2YXIgcHJldmlvdXNPbkNhbmNlbCA9IHRoaXMuX29uQ2FuY2VsKCk7XG4gICAgaWYgKHByZXZpb3VzT25DYW5jZWwgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBpZiAodXRpbC5pc0FycmF5KHByZXZpb3VzT25DYW5jZWwpKSB7XG4gICAgICAgICAgICBwcmV2aW91c09uQ2FuY2VsLnB1c2gob25DYW5jZWwpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5fc2V0T25DYW5jZWwoW3ByZXZpb3VzT25DYW5jZWwsIG9uQ2FuY2VsXSk7XG4gICAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLl9zZXRPbkNhbmNlbChvbkNhbmNlbCk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBjYW5jZWxsYXRpb25PbkNhbmNlbCgpIHtcbiAgICByZXR1cm4gdGhpcy5fb25DYW5jZWxGaWVsZDtcbn1cblxuZnVuY3Rpb24gY2FuY2VsbGF0aW9uU2V0T25DYW5jZWwob25DYW5jZWwpIHtcbiAgICB0aGlzLl9vbkNhbmNlbEZpZWxkID0gb25DYW5jZWw7XG59XG5cbmZ1bmN0aW9uIGNhbmNlbGxhdGlvbkNsZWFyQ2FuY2VsbGF0aW9uRGF0YSgpIHtcbiAgICB0aGlzLl9jYW5jZWxsYXRpb25QYXJlbnQgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5fb25DYW5jZWxGaWVsZCA9IHVuZGVmaW5lZDtcbn1cblxuZnVuY3Rpb24gY2FuY2VsbGF0aW9uUHJvcGFnYXRlRnJvbShwYXJlbnQsIGZsYWdzKSB7XG4gICAgaWYgKChmbGFncyAmIDEpICE9PSAwKSB7XG4gICAgICAgIHRoaXMuX2NhbmNlbGxhdGlvblBhcmVudCA9IHBhcmVudDtcbiAgICAgICAgdmFyIGJyYW5jaGVzUmVtYWluaW5nVG9DYW5jZWwgPSBwYXJlbnQuX2JyYW5jaGVzUmVtYWluaW5nVG9DYW5jZWw7XG4gICAgICAgIGlmIChicmFuY2hlc1JlbWFpbmluZ1RvQ2FuY2VsID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGJyYW5jaGVzUmVtYWluaW5nVG9DYW5jZWwgPSAwO1xuICAgICAgICB9XG4gICAgICAgIHBhcmVudC5fYnJhbmNoZXNSZW1haW5pbmdUb0NhbmNlbCA9IGJyYW5jaGVzUmVtYWluaW5nVG9DYW5jZWwgKyAxO1xuICAgIH1cbiAgICBpZiAoKGZsYWdzICYgMikgIT09IDAgJiYgcGFyZW50Ll9pc0JvdW5kKCkpIHtcbiAgICAgICAgdGhpcy5fc2V0Qm91bmRUbyhwYXJlbnQuX2JvdW5kVG8pO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gYmluZGluZ1Byb3BhZ2F0ZUZyb20ocGFyZW50LCBmbGFncykge1xuICAgIGlmICgoZmxhZ3MgJiAyKSAhPT0gMCAmJiBwYXJlbnQuX2lzQm91bmQoKSkge1xuICAgICAgICB0aGlzLl9zZXRCb3VuZFRvKHBhcmVudC5fYm91bmRUbyk7XG4gICAgfVxufVxudmFyIHByb3BhZ2F0ZUZyb21GdW5jdGlvbiA9IGJpbmRpbmdQcm9wYWdhdGVGcm9tO1xuXG5mdW5jdGlvbiBib3VuZFZhbHVlRnVuY3Rpb24oKSB7XG4gICAgdmFyIHJldCA9IHRoaXMuX2JvdW5kVG87XG4gICAgaWYgKHJldCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGlmIChyZXQgaW5zdGFuY2VvZiBQcm9taXNlKSB7XG4gICAgICAgICAgICBpZiAocmV0LmlzRnVsZmlsbGVkKCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmV0LnZhbHVlKCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJldDtcbn1cblxuZnVuY3Rpb24gbG9uZ1N0YWNrVHJhY2VzQ2FwdHVyZVN0YWNrVHJhY2UoKSB7XG4gICAgdGhpcy5fdHJhY2UgPSBuZXcgQ2FwdHVyZWRUcmFjZSh0aGlzLl9wZWVrQ29udGV4dCgpKTtcbn1cblxuZnVuY3Rpb24gbG9uZ1N0YWNrVHJhY2VzQXR0YWNoRXh0cmFUcmFjZShlcnJvciwgaWdub3JlU2VsZikge1xuICAgIGlmIChjYW5BdHRhY2hUcmFjZShlcnJvcikpIHtcbiAgICAgICAgdmFyIHRyYWNlID0gdGhpcy5fdHJhY2U7XG4gICAgICAgIGlmICh0cmFjZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBpZiAoaWdub3JlU2VsZikgdHJhY2UgPSB0cmFjZS5fcGFyZW50O1xuICAgICAgICB9XG4gICAgICAgIGlmICh0cmFjZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0cmFjZS5hdHRhY2hFeHRyYVRyYWNlKGVycm9yKTtcbiAgICAgICAgfSBlbHNlIGlmICghZXJyb3IuX19zdGFja0NsZWFuZWRfXykge1xuICAgICAgICAgICAgdmFyIHBhcnNlZCA9IHBhcnNlU3RhY2tBbmRNZXNzYWdlKGVycm9yKTtcbiAgICAgICAgICAgIHV0aWwubm90RW51bWVyYWJsZVByb3AoZXJyb3IsIFwic3RhY2tcIixcbiAgICAgICAgICAgICAgICBwYXJzZWQubWVzc2FnZSArIFwiXFxuXCIgKyBwYXJzZWQuc3RhY2suam9pbihcIlxcblwiKSk7XG4gICAgICAgICAgICB1dGlsLm5vdEVudW1lcmFibGVQcm9wKGVycm9yLCBcIl9fc3RhY2tDbGVhbmVkX19cIiwgdHJ1ZSk7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbmZ1bmN0aW9uIGNoZWNrRm9yZ290dGVuUmV0dXJucyhyZXR1cm5WYWx1ZSwgcHJvbWlzZUNyZWF0ZWQsIG5hbWUsIHByb21pc2UsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFyZW50KSB7XG4gICAgaWYgKHJldHVyblZhbHVlID09PSB1bmRlZmluZWQgJiYgcHJvbWlzZUNyZWF0ZWQgIT09IG51bGwgJiZcbiAgICAgICAgd0ZvcmdvdHRlblJldHVybikge1xuICAgICAgICBpZiAocGFyZW50ICE9PSB1bmRlZmluZWQgJiYgcGFyZW50Ll9yZXR1cm5lZE5vblVuZGVmaW5lZCgpKSByZXR1cm47XG4gICAgICAgIGlmICgocHJvbWlzZS5fYml0RmllbGQgJiA2NTUzNSkgPT09IDApIHJldHVybjtcblxuICAgICAgICBpZiAobmFtZSkgbmFtZSA9IG5hbWUgKyBcIiBcIjtcbiAgICAgICAgdmFyIGhhbmRsZXJMaW5lID0gXCJcIjtcbiAgICAgICAgdmFyIGNyZWF0b3JMaW5lID0gXCJcIjtcbiAgICAgICAgaWYgKHByb21pc2VDcmVhdGVkLl90cmFjZSkge1xuICAgICAgICAgICAgdmFyIHRyYWNlTGluZXMgPSBwcm9taXNlQ3JlYXRlZC5fdHJhY2Uuc3RhY2suc3BsaXQoXCJcXG5cIik7XG4gICAgICAgICAgICB2YXIgc3RhY2sgPSBjbGVhblN0YWNrKHRyYWNlTGluZXMpO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IHN0YWNrLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICAgICAgICAgICAgdmFyIGxpbmUgPSBzdGFja1tpXTtcbiAgICAgICAgICAgICAgICBpZiAoIW5vZGVGcmFtZVBhdHRlcm4udGVzdChsaW5lKSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgbGluZU1hdGNoZXMgPSBsaW5lLm1hdGNoKHBhcnNlTGluZVBhdHRlcm4pO1xuICAgICAgICAgICAgICAgICAgICBpZiAobGluZU1hdGNoZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGhhbmRsZXJMaW5lICA9IFwiYXQgXCIgKyBsaW5lTWF0Y2hlc1sxXSArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXCI6XCIgKyBsaW5lTWF0Y2hlc1syXSArIFwiOlwiICsgbGluZU1hdGNoZXNbM10gKyBcIiBcIjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChzdGFjay5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgdmFyIGZpcnN0VXNlckxpbmUgPSBzdGFja1swXTtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRyYWNlTGluZXMubGVuZ3RoOyArK2kpIHtcblxuICAgICAgICAgICAgICAgICAgICBpZiAodHJhY2VMaW5lc1tpXSA9PT0gZmlyc3RVc2VyTGluZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGkgPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3JlYXRvckxpbmUgPSBcIlxcblwiICsgdHJhY2VMaW5lc1tpIC0gMV07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHZhciBtc2cgPSBcImEgcHJvbWlzZSB3YXMgY3JlYXRlZCBpbiBhIFwiICsgbmFtZSArXG4gICAgICAgICAgICBcImhhbmRsZXIgXCIgKyBoYW5kbGVyTGluZSArIFwiYnV0IHdhcyBub3QgcmV0dXJuZWQgZnJvbSBpdCwgXCIgK1xuICAgICAgICAgICAgXCJzZWUgaHR0cDovL2dvby5nbC9yUnFNVXdcIiArXG4gICAgICAgICAgICBjcmVhdG9yTGluZTtcbiAgICAgICAgcHJvbWlzZS5fd2Fybihtc2csIHRydWUsIHByb21pc2VDcmVhdGVkKTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGRlcHJlY2F0ZWQobmFtZSwgcmVwbGFjZW1lbnQpIHtcbiAgICB2YXIgbWVzc2FnZSA9IG5hbWUgK1xuICAgICAgICBcIiBpcyBkZXByZWNhdGVkIGFuZCB3aWxsIGJlIHJlbW92ZWQgaW4gYSBmdXR1cmUgdmVyc2lvbi5cIjtcbiAgICBpZiAocmVwbGFjZW1lbnQpIG1lc3NhZ2UgKz0gXCIgVXNlIFwiICsgcmVwbGFjZW1lbnQgKyBcIiBpbnN0ZWFkLlwiO1xuICAgIHJldHVybiB3YXJuKG1lc3NhZ2UpO1xufVxuXG5mdW5jdGlvbiB3YXJuKG1lc3NhZ2UsIHNob3VsZFVzZU93blRyYWNlLCBwcm9taXNlKSB7XG4gICAgaWYgKCFjb25maWcud2FybmluZ3MpIHJldHVybjtcbiAgICB2YXIgd2FybmluZyA9IG5ldyBXYXJuaW5nKG1lc3NhZ2UpO1xuICAgIHZhciBjdHg7XG4gICAgaWYgKHNob3VsZFVzZU93blRyYWNlKSB7XG4gICAgICAgIHByb21pc2UuX2F0dGFjaEV4dHJhVHJhY2Uod2FybmluZyk7XG4gICAgfSBlbHNlIGlmIChjb25maWcubG9uZ1N0YWNrVHJhY2VzICYmIChjdHggPSBQcm9taXNlLl9wZWVrQ29udGV4dCgpKSkge1xuICAgICAgICBjdHguYXR0YWNoRXh0cmFUcmFjZSh3YXJuaW5nKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgcGFyc2VkID0gcGFyc2VTdGFja0FuZE1lc3NhZ2Uod2FybmluZyk7XG4gICAgICAgIHdhcm5pbmcuc3RhY2sgPSBwYXJzZWQubWVzc2FnZSArIFwiXFxuXCIgKyBwYXJzZWQuc3RhY2suam9pbihcIlxcblwiKTtcbiAgICB9XG5cbiAgICBpZiAoIWFjdGl2ZUZpcmVFdmVudChcIndhcm5pbmdcIiwgd2FybmluZykpIHtcbiAgICAgICAgZm9ybWF0QW5kTG9nRXJyb3Iod2FybmluZywgXCJcIiwgdHJ1ZSk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiByZWNvbnN0cnVjdFN0YWNrKG1lc3NhZ2UsIHN0YWNrcykge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc3RhY2tzLmxlbmd0aCAtIDE7ICsraSkge1xuICAgICAgICBzdGFja3NbaV0ucHVzaChcIkZyb20gcHJldmlvdXMgZXZlbnQ6XCIpO1xuICAgICAgICBzdGFja3NbaV0gPSBzdGFja3NbaV0uam9pbihcIlxcblwiKTtcbiAgICB9XG4gICAgaWYgKGkgPCBzdGFja3MubGVuZ3RoKSB7XG4gICAgICAgIHN0YWNrc1tpXSA9IHN0YWNrc1tpXS5qb2luKFwiXFxuXCIpO1xuICAgIH1cbiAgICByZXR1cm4gbWVzc2FnZSArIFwiXFxuXCIgKyBzdGFja3Muam9pbihcIlxcblwiKTtcbn1cblxuZnVuY3Rpb24gcmVtb3ZlRHVwbGljYXRlT3JFbXB0eUp1bXBzKHN0YWNrcykge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc3RhY2tzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIGlmIChzdGFja3NbaV0ubGVuZ3RoID09PSAwIHx8XG4gICAgICAgICAgICAoKGkgKyAxIDwgc3RhY2tzLmxlbmd0aCkgJiYgc3RhY2tzW2ldWzBdID09PSBzdGFja3NbaSsxXVswXSkpIHtcbiAgICAgICAgICAgIHN0YWNrcy5zcGxpY2UoaSwgMSk7XG4gICAgICAgICAgICBpLS07XG4gICAgICAgIH1cbiAgICB9XG59XG5cbmZ1bmN0aW9uIHJlbW92ZUNvbW1vblJvb3RzKHN0YWNrcykge1xuICAgIHZhciBjdXJyZW50ID0gc3RhY2tzWzBdO1xuICAgIGZvciAodmFyIGkgPSAxOyBpIDwgc3RhY2tzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIHZhciBwcmV2ID0gc3RhY2tzW2ldO1xuICAgICAgICB2YXIgY3VycmVudExhc3RJbmRleCA9IGN1cnJlbnQubGVuZ3RoIC0gMTtcbiAgICAgICAgdmFyIGN1cnJlbnRMYXN0TGluZSA9IGN1cnJlbnRbY3VycmVudExhc3RJbmRleF07XG4gICAgICAgIHZhciBjb21tb25Sb290TWVldFBvaW50ID0gLTE7XG5cbiAgICAgICAgZm9yICh2YXIgaiA9IHByZXYubGVuZ3RoIC0gMTsgaiA+PSAwOyAtLWopIHtcbiAgICAgICAgICAgIGlmIChwcmV2W2pdID09PSBjdXJyZW50TGFzdExpbmUpIHtcbiAgICAgICAgICAgICAgICBjb21tb25Sb290TWVldFBvaW50ID0gajtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAodmFyIGogPSBjb21tb25Sb290TWVldFBvaW50OyBqID49IDA7IC0taikge1xuICAgICAgICAgICAgdmFyIGxpbmUgPSBwcmV2W2pdO1xuICAgICAgICAgICAgaWYgKGN1cnJlbnRbY3VycmVudExhc3RJbmRleF0gPT09IGxpbmUpIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50LnBvcCgpO1xuICAgICAgICAgICAgICAgIGN1cnJlbnRMYXN0SW5kZXgtLTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY3VycmVudCA9IHByZXY7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBjbGVhblN0YWNrKHN0YWNrKSB7XG4gICAgdmFyIHJldCA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc3RhY2subGVuZ3RoOyArK2kpIHtcbiAgICAgICAgdmFyIGxpbmUgPSBzdGFja1tpXTtcbiAgICAgICAgdmFyIGlzVHJhY2VMaW5lID0gXCIgICAgKE5vIHN0YWNrIHRyYWNlKVwiID09PSBsaW5lIHx8XG4gICAgICAgICAgICBzdGFja0ZyYW1lUGF0dGVybi50ZXN0KGxpbmUpO1xuICAgICAgICB2YXIgaXNJbnRlcm5hbEZyYW1lID0gaXNUcmFjZUxpbmUgJiYgc2hvdWxkSWdub3JlKGxpbmUpO1xuICAgICAgICBpZiAoaXNUcmFjZUxpbmUgJiYgIWlzSW50ZXJuYWxGcmFtZSkge1xuICAgICAgICAgICAgaWYgKGluZGVudFN0YWNrRnJhbWVzICYmIGxpbmUuY2hhckF0KDApICE9PSBcIiBcIikge1xuICAgICAgICAgICAgICAgIGxpbmUgPSBcIiAgICBcIiArIGxpbmU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXQucHVzaChsaW5lKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmV0O1xufVxuXG5mdW5jdGlvbiBzdGFja0ZyYW1lc0FzQXJyYXkoZXJyb3IpIHtcbiAgICB2YXIgc3RhY2sgPSBlcnJvci5zdGFjay5yZXBsYWNlKC9cXHMrJC9nLCBcIlwiKS5zcGxpdChcIlxcblwiKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHN0YWNrLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIHZhciBsaW5lID0gc3RhY2tbaV07XG4gICAgICAgIGlmIChcIiAgICAoTm8gc3RhY2sgdHJhY2UpXCIgPT09IGxpbmUgfHwgc3RhY2tGcmFtZVBhdHRlcm4udGVzdChsaW5lKSkge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKGkgPiAwICYmIGVycm9yLm5hbWUgIT0gXCJTeW50YXhFcnJvclwiKSB7XG4gICAgICAgIHN0YWNrID0gc3RhY2suc2xpY2UoaSk7XG4gICAgfVxuICAgIHJldHVybiBzdGFjaztcbn1cblxuZnVuY3Rpb24gcGFyc2VTdGFja0FuZE1lc3NhZ2UoZXJyb3IpIHtcbiAgICB2YXIgc3RhY2sgPSBlcnJvci5zdGFjaztcbiAgICB2YXIgbWVzc2FnZSA9IGVycm9yLnRvU3RyaW5nKCk7XG4gICAgc3RhY2sgPSB0eXBlb2Ygc3RhY2sgPT09IFwic3RyaW5nXCIgJiYgc3RhY2subGVuZ3RoID4gMFxuICAgICAgICAgICAgICAgID8gc3RhY2tGcmFtZXNBc0FycmF5KGVycm9yKSA6IFtcIiAgICAoTm8gc3RhY2sgdHJhY2UpXCJdO1xuICAgIHJldHVybiB7XG4gICAgICAgIG1lc3NhZ2U6IG1lc3NhZ2UsXG4gICAgICAgIHN0YWNrOiBlcnJvci5uYW1lID09IFwiU3ludGF4RXJyb3JcIiA/IHN0YWNrIDogY2xlYW5TdGFjayhzdGFjaylcbiAgICB9O1xufVxuXG5mdW5jdGlvbiBmb3JtYXRBbmRMb2dFcnJvcihlcnJvciwgdGl0bGUsIGlzU29mdCkge1xuICAgIGlmICh0eXBlb2YgY29uc29sZSAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICB2YXIgbWVzc2FnZTtcbiAgICAgICAgaWYgKHV0aWwuaXNPYmplY3QoZXJyb3IpKSB7XG4gICAgICAgICAgICB2YXIgc3RhY2sgPSBlcnJvci5zdGFjaztcbiAgICAgICAgICAgIG1lc3NhZ2UgPSB0aXRsZSArIGZvcm1hdFN0YWNrKHN0YWNrLCBlcnJvcik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBtZXNzYWdlID0gdGl0bGUgKyBTdHJpbmcoZXJyb3IpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgcHJpbnRXYXJuaW5nID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgIHByaW50V2FybmluZyhtZXNzYWdlLCBpc1NvZnQpO1xuICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBjb25zb2xlLmxvZyA9PT0gXCJmdW5jdGlvblwiIHx8XG4gICAgICAgICAgICB0eXBlb2YgY29uc29sZS5sb2cgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKG1lc3NhZ2UpO1xuICAgICAgICB9XG4gICAgfVxufVxuXG5mdW5jdGlvbiBmaXJlUmVqZWN0aW9uRXZlbnQobmFtZSwgbG9jYWxIYW5kbGVyLCByZWFzb24sIHByb21pc2UpIHtcbiAgICB2YXIgbG9jYWxFdmVudEZpcmVkID0gZmFsc2U7XG4gICAgdHJ5IHtcbiAgICAgICAgaWYgKHR5cGVvZiBsb2NhbEhhbmRsZXIgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgbG9jYWxFdmVudEZpcmVkID0gdHJ1ZTtcbiAgICAgICAgICAgIGlmIChuYW1lID09PSBcInJlamVjdGlvbkhhbmRsZWRcIikge1xuICAgICAgICAgICAgICAgIGxvY2FsSGFuZGxlcihwcm9taXNlKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgbG9jYWxIYW5kbGVyKHJlYXNvbiwgcHJvbWlzZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGFzeW5jLnRocm93TGF0ZXIoZSk7XG4gICAgfVxuXG4gICAgaWYgKG5hbWUgPT09IFwidW5oYW5kbGVkUmVqZWN0aW9uXCIpIHtcbiAgICAgICAgaWYgKCFhY3RpdmVGaXJlRXZlbnQobmFtZSwgcmVhc29uLCBwcm9taXNlKSAmJiAhbG9jYWxFdmVudEZpcmVkKSB7XG4gICAgICAgICAgICBmb3JtYXRBbmRMb2dFcnJvcihyZWFzb24sIFwiVW5oYW5kbGVkIHJlamVjdGlvbiBcIik7XG4gICAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgICBhY3RpdmVGaXJlRXZlbnQobmFtZSwgcHJvbWlzZSk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBmb3JtYXROb25FcnJvcihvYmopIHtcbiAgICB2YXIgc3RyO1xuICAgIGlmICh0eXBlb2Ygb2JqID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgc3RyID0gXCJbZnVuY3Rpb24gXCIgK1xuICAgICAgICAgICAgKG9iai5uYW1lIHx8IFwiYW5vbnltb3VzXCIpICtcbiAgICAgICAgICAgIFwiXVwiO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHN0ciA9IG9iaiAmJiB0eXBlb2Ygb2JqLnRvU3RyaW5nID09PSBcImZ1bmN0aW9uXCJcbiAgICAgICAgICAgID8gb2JqLnRvU3RyaW5nKCkgOiB1dGlsLnRvU3RyaW5nKG9iaik7XG4gICAgICAgIHZhciBydXNlbGVzc1RvU3RyaW5nID0gL1xcW29iamVjdCBbYS16QS1aMC05JF9dK1xcXS87XG4gICAgICAgIGlmIChydXNlbGVzc1RvU3RyaW5nLnRlc3Qoc3RyKSkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICB2YXIgbmV3U3RyID0gSlNPTi5zdHJpbmdpZnkob2JqKTtcbiAgICAgICAgICAgICAgICBzdHIgPSBuZXdTdHI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaChlKSB7XG5cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoc3RyLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgc3RyID0gXCIoZW1wdHkgYXJyYXkpXCI7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIChcIig8XCIgKyBzbmlwKHN0cikgKyBcIj4sIG5vIHN0YWNrIHRyYWNlKVwiKTtcbn1cblxuZnVuY3Rpb24gc25pcChzdHIpIHtcbiAgICB2YXIgbWF4Q2hhcnMgPSA0MTtcbiAgICBpZiAoc3RyLmxlbmd0aCA8IG1heENoYXJzKSB7XG4gICAgICAgIHJldHVybiBzdHI7XG4gICAgfVxuICAgIHJldHVybiBzdHIuc3Vic3RyKDAsIG1heENoYXJzIC0gMykgKyBcIi4uLlwiO1xufVxuXG5mdW5jdGlvbiBsb25nU3RhY2tUcmFjZXNJc1N1cHBvcnRlZCgpIHtcbiAgICByZXR1cm4gdHlwZW9mIGNhcHR1cmVTdGFja1RyYWNlID09PSBcImZ1bmN0aW9uXCI7XG59XG5cbnZhciBzaG91bGRJZ25vcmUgPSBmdW5jdGlvbigpIHsgcmV0dXJuIGZhbHNlOyB9O1xudmFyIHBhcnNlTGluZUluZm9SZWdleCA9IC9bXFwvPFxcKF0oW146XFwvXSspOihcXGQrKTooPzpcXGQrKVxcKT9cXHMqJC87XG5mdW5jdGlvbiBwYXJzZUxpbmVJbmZvKGxpbmUpIHtcbiAgICB2YXIgbWF0Y2hlcyA9IGxpbmUubWF0Y2gocGFyc2VMaW5lSW5mb1JlZ2V4KTtcbiAgICBpZiAobWF0Y2hlcykge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZmlsZU5hbWU6IG1hdGNoZXNbMV0sXG4gICAgICAgICAgICBsaW5lOiBwYXJzZUludChtYXRjaGVzWzJdLCAxMClcbiAgICAgICAgfTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIHNldEJvdW5kcyhmaXJzdExpbmVFcnJvciwgbGFzdExpbmVFcnJvcikge1xuICAgIGlmICghbG9uZ1N0YWNrVHJhY2VzSXNTdXBwb3J0ZWQoKSkgcmV0dXJuO1xuICAgIHZhciBmaXJzdFN0YWNrTGluZXMgPSBmaXJzdExpbmVFcnJvci5zdGFjay5zcGxpdChcIlxcblwiKTtcbiAgICB2YXIgbGFzdFN0YWNrTGluZXMgPSBsYXN0TGluZUVycm9yLnN0YWNrLnNwbGl0KFwiXFxuXCIpO1xuICAgIHZhciBmaXJzdEluZGV4ID0gLTE7XG4gICAgdmFyIGxhc3RJbmRleCA9IC0xO1xuICAgIHZhciBmaXJzdEZpbGVOYW1lO1xuICAgIHZhciBsYXN0RmlsZU5hbWU7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBmaXJzdFN0YWNrTGluZXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IHBhcnNlTGluZUluZm8oZmlyc3RTdGFja0xpbmVzW2ldKTtcbiAgICAgICAgaWYgKHJlc3VsdCkge1xuICAgICAgICAgICAgZmlyc3RGaWxlTmFtZSA9IHJlc3VsdC5maWxlTmFtZTtcbiAgICAgICAgICAgIGZpcnN0SW5kZXggPSByZXN1bHQubGluZTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGFzdFN0YWNrTGluZXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IHBhcnNlTGluZUluZm8obGFzdFN0YWNrTGluZXNbaV0pO1xuICAgICAgICBpZiAocmVzdWx0KSB7XG4gICAgICAgICAgICBsYXN0RmlsZU5hbWUgPSByZXN1bHQuZmlsZU5hbWU7XG4gICAgICAgICAgICBsYXN0SW5kZXggPSByZXN1bHQubGluZTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChmaXJzdEluZGV4IDwgMCB8fCBsYXN0SW5kZXggPCAwIHx8ICFmaXJzdEZpbGVOYW1lIHx8ICFsYXN0RmlsZU5hbWUgfHxcbiAgICAgICAgZmlyc3RGaWxlTmFtZSAhPT0gbGFzdEZpbGVOYW1lIHx8IGZpcnN0SW5kZXggPj0gbGFzdEluZGV4KSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBzaG91bGRJZ25vcmUgPSBmdW5jdGlvbihsaW5lKSB7XG4gICAgICAgIGlmIChibHVlYmlyZEZyYW1lUGF0dGVybi50ZXN0KGxpbmUpKSByZXR1cm4gdHJ1ZTtcbiAgICAgICAgdmFyIGluZm8gPSBwYXJzZUxpbmVJbmZvKGxpbmUpO1xuICAgICAgICBpZiAoaW5mbykge1xuICAgICAgICAgICAgaWYgKGluZm8uZmlsZU5hbWUgPT09IGZpcnN0RmlsZU5hbWUgJiZcbiAgICAgICAgICAgICAgICAoZmlyc3RJbmRleCA8PSBpbmZvLmxpbmUgJiYgaW5mby5saW5lIDw9IGxhc3RJbmRleCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfTtcbn1cblxuZnVuY3Rpb24gQ2FwdHVyZWRUcmFjZShwYXJlbnQpIHtcbiAgICB0aGlzLl9wYXJlbnQgPSBwYXJlbnQ7XG4gICAgdGhpcy5fcHJvbWlzZXNDcmVhdGVkID0gMDtcbiAgICB2YXIgbGVuZ3RoID0gdGhpcy5fbGVuZ3RoID0gMSArIChwYXJlbnQgPT09IHVuZGVmaW5lZCA/IDAgOiBwYXJlbnQuX2xlbmd0aCk7XG4gICAgY2FwdHVyZVN0YWNrVHJhY2UodGhpcywgQ2FwdHVyZWRUcmFjZSk7XG4gICAgaWYgKGxlbmd0aCA+IDMyKSB0aGlzLnVuY3ljbGUoKTtcbn1cbnV0aWwuaW5oZXJpdHMoQ2FwdHVyZWRUcmFjZSwgRXJyb3IpO1xuQ29udGV4dC5DYXB0dXJlZFRyYWNlID0gQ2FwdHVyZWRUcmFjZTtcblxuQ2FwdHVyZWRUcmFjZS5wcm90b3R5cGUudW5jeWNsZSA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBsZW5ndGggPSB0aGlzLl9sZW5ndGg7XG4gICAgaWYgKGxlbmd0aCA8IDIpIHJldHVybjtcbiAgICB2YXIgbm9kZXMgPSBbXTtcbiAgICB2YXIgc3RhY2tUb0luZGV4ID0ge307XG5cbiAgICBmb3IgKHZhciBpID0gMCwgbm9kZSA9IHRoaXM7IG5vZGUgIT09IHVuZGVmaW5lZDsgKytpKSB7XG4gICAgICAgIG5vZGVzLnB1c2gobm9kZSk7XG4gICAgICAgIG5vZGUgPSBub2RlLl9wYXJlbnQ7XG4gICAgfVxuICAgIGxlbmd0aCA9IHRoaXMuX2xlbmd0aCA9IGk7XG4gICAgZm9yICh2YXIgaSA9IGxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICAgIHZhciBzdGFjayA9IG5vZGVzW2ldLnN0YWNrO1xuICAgICAgICBpZiAoc3RhY2tUb0luZGV4W3N0YWNrXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBzdGFja1RvSW5kZXhbc3RhY2tdID0gaTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgKytpKSB7XG4gICAgICAgIHZhciBjdXJyZW50U3RhY2sgPSBub2Rlc1tpXS5zdGFjaztcbiAgICAgICAgdmFyIGluZGV4ID0gc3RhY2tUb0luZGV4W2N1cnJlbnRTdGFja107XG4gICAgICAgIGlmIChpbmRleCAhPT0gdW5kZWZpbmVkICYmIGluZGV4ICE9PSBpKSB7XG4gICAgICAgICAgICBpZiAoaW5kZXggPiAwKSB7XG4gICAgICAgICAgICAgICAgbm9kZXNbaW5kZXggLSAxXS5fcGFyZW50ID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgIG5vZGVzW2luZGV4IC0gMV0uX2xlbmd0aCA9IDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBub2Rlc1tpXS5fcGFyZW50ID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgbm9kZXNbaV0uX2xlbmd0aCA9IDE7XG4gICAgICAgICAgICB2YXIgY3ljbGVFZGdlTm9kZSA9IGkgPiAwID8gbm9kZXNbaSAtIDFdIDogdGhpcztcblxuICAgICAgICAgICAgaWYgKGluZGV4IDwgbGVuZ3RoIC0gMSkge1xuICAgICAgICAgICAgICAgIGN5Y2xlRWRnZU5vZGUuX3BhcmVudCA9IG5vZGVzW2luZGV4ICsgMV07XG4gICAgICAgICAgICAgICAgY3ljbGVFZGdlTm9kZS5fcGFyZW50LnVuY3ljbGUoKTtcbiAgICAgICAgICAgICAgICBjeWNsZUVkZ2VOb2RlLl9sZW5ndGggPVxuICAgICAgICAgICAgICAgICAgICBjeWNsZUVkZ2VOb2RlLl9wYXJlbnQuX2xlbmd0aCArIDE7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGN5Y2xlRWRnZU5vZGUuX3BhcmVudCA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICBjeWNsZUVkZ2VOb2RlLl9sZW5ndGggPSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGN1cnJlbnRDaGlsZExlbmd0aCA9IGN5Y2xlRWRnZU5vZGUuX2xlbmd0aCArIDE7XG4gICAgICAgICAgICBmb3IgKHZhciBqID0gaSAtIDI7IGogPj0gMDsgLS1qKSB7XG4gICAgICAgICAgICAgICAgbm9kZXNbal0uX2xlbmd0aCA9IGN1cnJlbnRDaGlsZExlbmd0aDtcbiAgICAgICAgICAgICAgICBjdXJyZW50Q2hpbGRMZW5ndGgrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgIH1cbn07XG5cbkNhcHR1cmVkVHJhY2UucHJvdG90eXBlLmF0dGFjaEV4dHJhVHJhY2UgPSBmdW5jdGlvbihlcnJvcikge1xuICAgIGlmIChlcnJvci5fX3N0YWNrQ2xlYW5lZF9fKSByZXR1cm47XG4gICAgdGhpcy51bmN5Y2xlKCk7XG4gICAgdmFyIHBhcnNlZCA9IHBhcnNlU3RhY2tBbmRNZXNzYWdlKGVycm9yKTtcbiAgICB2YXIgbWVzc2FnZSA9IHBhcnNlZC5tZXNzYWdlO1xuICAgIHZhciBzdGFja3MgPSBbcGFyc2VkLnN0YWNrXTtcblxuICAgIHZhciB0cmFjZSA9IHRoaXM7XG4gICAgd2hpbGUgKHRyYWNlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgc3RhY2tzLnB1c2goY2xlYW5TdGFjayh0cmFjZS5zdGFjay5zcGxpdChcIlxcblwiKSkpO1xuICAgICAgICB0cmFjZSA9IHRyYWNlLl9wYXJlbnQ7XG4gICAgfVxuICAgIHJlbW92ZUNvbW1vblJvb3RzKHN0YWNrcyk7XG4gICAgcmVtb3ZlRHVwbGljYXRlT3JFbXB0eUp1bXBzKHN0YWNrcyk7XG4gICAgdXRpbC5ub3RFbnVtZXJhYmxlUHJvcChlcnJvciwgXCJzdGFja1wiLCByZWNvbnN0cnVjdFN0YWNrKG1lc3NhZ2UsIHN0YWNrcykpO1xuICAgIHV0aWwubm90RW51bWVyYWJsZVByb3AoZXJyb3IsIFwiX19zdGFja0NsZWFuZWRfX1wiLCB0cnVlKTtcbn07XG5cbnZhciBjYXB0dXJlU3RhY2tUcmFjZSA9IChmdW5jdGlvbiBzdGFja0RldGVjdGlvbigpIHtcbiAgICB2YXIgdjhzdGFja0ZyYW1lUGF0dGVybiA9IC9eXFxzKmF0XFxzKi87XG4gICAgdmFyIHY4c3RhY2tGb3JtYXR0ZXIgPSBmdW5jdGlvbihzdGFjaywgZXJyb3IpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBzdGFjayA9PT0gXCJzdHJpbmdcIikgcmV0dXJuIHN0YWNrO1xuXG4gICAgICAgIGlmIChlcnJvci5uYW1lICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgIGVycm9yLm1lc3NhZ2UgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIGVycm9yLnRvU3RyaW5nKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZvcm1hdE5vbkVycm9yKGVycm9yKTtcbiAgICB9O1xuXG4gICAgaWYgKHR5cGVvZiBFcnJvci5zdGFja1RyYWNlTGltaXQgPT09IFwibnVtYmVyXCIgJiZcbiAgICAgICAgdHlwZW9mIEVycm9yLmNhcHR1cmVTdGFja1RyYWNlID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgRXJyb3Iuc3RhY2tUcmFjZUxpbWl0ICs9IDY7XG4gICAgICAgIHN0YWNrRnJhbWVQYXR0ZXJuID0gdjhzdGFja0ZyYW1lUGF0dGVybjtcbiAgICAgICAgZm9ybWF0U3RhY2sgPSB2OHN0YWNrRm9ybWF0dGVyO1xuICAgICAgICB2YXIgY2FwdHVyZVN0YWNrVHJhY2UgPSBFcnJvci5jYXB0dXJlU3RhY2tUcmFjZTtcblxuICAgICAgICBzaG91bGRJZ25vcmUgPSBmdW5jdGlvbihsaW5lKSB7XG4gICAgICAgICAgICByZXR1cm4gYmx1ZWJpcmRGcmFtZVBhdHRlcm4udGVzdChsaW5lKTtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKHJlY2VpdmVyLCBpZ25vcmVVbnRpbCkge1xuICAgICAgICAgICAgRXJyb3Iuc3RhY2tUcmFjZUxpbWl0ICs9IDY7XG4gICAgICAgICAgICBjYXB0dXJlU3RhY2tUcmFjZShyZWNlaXZlciwgaWdub3JlVW50aWwpO1xuICAgICAgICAgICAgRXJyb3Iuc3RhY2tUcmFjZUxpbWl0IC09IDY7XG4gICAgICAgIH07XG4gICAgfVxuICAgIHZhciBlcnIgPSBuZXcgRXJyb3IoKTtcblxuICAgIGlmICh0eXBlb2YgZXJyLnN0YWNrID09PSBcInN0cmluZ1wiICYmXG4gICAgICAgIGVyci5zdGFjay5zcGxpdChcIlxcblwiKVswXS5pbmRleE9mKFwic3RhY2tEZXRlY3Rpb25AXCIpID49IDApIHtcbiAgICAgICAgc3RhY2tGcmFtZVBhdHRlcm4gPSAvQC87XG4gICAgICAgIGZvcm1hdFN0YWNrID0gdjhzdGFja0Zvcm1hdHRlcjtcbiAgICAgICAgaW5kZW50U3RhY2tGcmFtZXMgPSB0cnVlO1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gY2FwdHVyZVN0YWNrVHJhY2Uobykge1xuICAgICAgICAgICAgby5zdGFjayA9IG5ldyBFcnJvcigpLnN0YWNrO1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIHZhciBoYXNTdGFja0FmdGVyVGhyb3c7XG4gICAgdHJ5IHsgdGhyb3cgbmV3IEVycm9yKCk7IH1cbiAgICBjYXRjaChlKSB7XG4gICAgICAgIGhhc1N0YWNrQWZ0ZXJUaHJvdyA9IChcInN0YWNrXCIgaW4gZSk7XG4gICAgfVxuICAgIGlmICghKFwic3RhY2tcIiBpbiBlcnIpICYmIGhhc1N0YWNrQWZ0ZXJUaHJvdyAmJlxuICAgICAgICB0eXBlb2YgRXJyb3Iuc3RhY2tUcmFjZUxpbWl0ID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgIHN0YWNrRnJhbWVQYXR0ZXJuID0gdjhzdGFja0ZyYW1lUGF0dGVybjtcbiAgICAgICAgZm9ybWF0U3RhY2sgPSB2OHN0YWNrRm9ybWF0dGVyO1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gY2FwdHVyZVN0YWNrVHJhY2Uobykge1xuICAgICAgICAgICAgRXJyb3Iuc3RhY2tUcmFjZUxpbWl0ICs9IDY7XG4gICAgICAgICAgICB0cnkgeyB0aHJvdyBuZXcgRXJyb3IoKTsgfVxuICAgICAgICAgICAgY2F0Y2goZSkgeyBvLnN0YWNrID0gZS5zdGFjazsgfVxuICAgICAgICAgICAgRXJyb3Iuc3RhY2tUcmFjZUxpbWl0IC09IDY7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgZm9ybWF0U3RhY2sgPSBmdW5jdGlvbihzdGFjaywgZXJyb3IpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBzdGFjayA9PT0gXCJzdHJpbmdcIikgcmV0dXJuIHN0YWNrO1xuXG4gICAgICAgIGlmICgodHlwZW9mIGVycm9yID09PSBcIm9iamVjdFwiIHx8XG4gICAgICAgICAgICB0eXBlb2YgZXJyb3IgPT09IFwiZnVuY3Rpb25cIikgJiZcbiAgICAgICAgICAgIGVycm9yLm5hbWUgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgZXJyb3IubWVzc2FnZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gZXJyb3IudG9TdHJpbmcoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZm9ybWF0Tm9uRXJyb3IoZXJyb3IpO1xuICAgIH07XG5cbiAgICByZXR1cm4gbnVsbDtcblxufSkoW10pO1xuXG5pZiAodHlwZW9mIGNvbnNvbGUgIT09IFwidW5kZWZpbmVkXCIgJiYgdHlwZW9mIGNvbnNvbGUud2FybiAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgIHByaW50V2FybmluZyA9IGZ1bmN0aW9uIChtZXNzYWdlKSB7XG4gICAgICAgIGNvbnNvbGUud2FybihtZXNzYWdlKTtcbiAgICB9O1xuICAgIGlmICh1dGlsLmlzTm9kZSAmJiBwcm9jZXNzLnN0ZGVyci5pc1RUWSkge1xuICAgICAgICBwcmludFdhcm5pbmcgPSBmdW5jdGlvbihtZXNzYWdlLCBpc1NvZnQpIHtcbiAgICAgICAgICAgIHZhciBjb2xvciA9IGlzU29mdCA/IFwiXFx1MDAxYlszM21cIiA6IFwiXFx1MDAxYlszMW1cIjtcbiAgICAgICAgICAgIGNvbnNvbGUud2Fybihjb2xvciArIG1lc3NhZ2UgKyBcIlxcdTAwMWJbMG1cXG5cIik7XG4gICAgICAgIH07XG4gICAgfSBlbHNlIGlmICghdXRpbC5pc05vZGUgJiYgdHlwZW9mIChuZXcgRXJyb3IoKS5zdGFjaykgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgcHJpbnRXYXJuaW5nID0gZnVuY3Rpb24obWVzc2FnZSwgaXNTb2Z0KSB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oXCIlY1wiICsgbWVzc2FnZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGlzU29mdCA/IFwiY29sb3I6IGRhcmtvcmFuZ2VcIiA6IFwiY29sb3I6IHJlZFwiKTtcbiAgICAgICAgfTtcbiAgICB9XG59XG5cbnZhciBjb25maWcgPSB7XG4gICAgd2FybmluZ3M6IHdhcm5pbmdzLFxuICAgIGxvbmdTdGFja1RyYWNlczogZmFsc2UsXG4gICAgY2FuY2VsbGF0aW9uOiBmYWxzZSxcbiAgICBtb25pdG9yaW5nOiBmYWxzZVxufTtcblxuaWYgKGxvbmdTdGFja1RyYWNlcykgUHJvbWlzZS5sb25nU3RhY2tUcmFjZXMoKTtcblxucmV0dXJuIHtcbiAgICBsb25nU3RhY2tUcmFjZXM6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gY29uZmlnLmxvbmdTdGFja1RyYWNlcztcbiAgICB9LFxuICAgIHdhcm5pbmdzOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIGNvbmZpZy53YXJuaW5ncztcbiAgICB9LFxuICAgIGNhbmNlbGxhdGlvbjogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBjb25maWcuY2FuY2VsbGF0aW9uO1xuICAgIH0sXG4gICAgbW9uaXRvcmluZzogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBjb25maWcubW9uaXRvcmluZztcbiAgICB9LFxuICAgIHByb3BhZ2F0ZUZyb21GdW5jdGlvbjogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBwcm9wYWdhdGVGcm9tRnVuY3Rpb247XG4gICAgfSxcbiAgICBib3VuZFZhbHVlRnVuY3Rpb246IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gYm91bmRWYWx1ZUZ1bmN0aW9uO1xuICAgIH0sXG4gICAgY2hlY2tGb3Jnb3R0ZW5SZXR1cm5zOiBjaGVja0ZvcmdvdHRlblJldHVybnMsXG4gICAgc2V0Qm91bmRzOiBzZXRCb3VuZHMsXG4gICAgd2Fybjogd2FybixcbiAgICBkZXByZWNhdGVkOiBkZXByZWNhdGVkLFxuICAgIENhcHR1cmVkVHJhY2U6IENhcHR1cmVkVHJhY2UsXG4gICAgZmlyZURvbUV2ZW50OiBmaXJlRG9tRXZlbnQsXG4gICAgZmlyZUdsb2JhbEV2ZW50OiBmaXJlR2xvYmFsRXZlbnRcbn07XG59O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2JsdWViaXJkL2pzL3JlbGVhc2UvZGVidWdnYWJpbGl0eS5qcyIsIlwidXNlIHN0cmljdFwiO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihQcm9taXNlLCB0cnlDb252ZXJ0VG9Qcm9taXNlLCBORVhUX0ZJTFRFUikge1xudmFyIHV0aWwgPSByZXF1aXJlKFwiLi91dGlsXCIpO1xudmFyIENhbmNlbGxhdGlvbkVycm9yID0gUHJvbWlzZS5DYW5jZWxsYXRpb25FcnJvcjtcbnZhciBlcnJvck9iaiA9IHV0aWwuZXJyb3JPYmo7XG52YXIgY2F0Y2hGaWx0ZXIgPSByZXF1aXJlKFwiLi9jYXRjaF9maWx0ZXJcIikoTkVYVF9GSUxURVIpO1xuXG5mdW5jdGlvbiBQYXNzVGhyb3VnaEhhbmRsZXJDb250ZXh0KHByb21pc2UsIHR5cGUsIGhhbmRsZXIpIHtcbiAgICB0aGlzLnByb21pc2UgPSBwcm9taXNlO1xuICAgIHRoaXMudHlwZSA9IHR5cGU7XG4gICAgdGhpcy5oYW5kbGVyID0gaGFuZGxlcjtcbiAgICB0aGlzLmNhbGxlZCA9IGZhbHNlO1xuICAgIHRoaXMuY2FuY2VsUHJvbWlzZSA9IG51bGw7XG59XG5cblBhc3NUaHJvdWdoSGFuZGxlckNvbnRleHQucHJvdG90eXBlLmlzRmluYWxseUhhbmRsZXIgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy50eXBlID09PSAwO1xufTtcblxuZnVuY3Rpb24gRmluYWxseUhhbmRsZXJDYW5jZWxSZWFjdGlvbihmaW5hbGx5SGFuZGxlcikge1xuICAgIHRoaXMuZmluYWxseUhhbmRsZXIgPSBmaW5hbGx5SGFuZGxlcjtcbn1cblxuRmluYWxseUhhbmRsZXJDYW5jZWxSZWFjdGlvbi5wcm90b3R5cGUuX3Jlc3VsdENhbmNlbGxlZCA9IGZ1bmN0aW9uKCkge1xuICAgIGNoZWNrQ2FuY2VsKHRoaXMuZmluYWxseUhhbmRsZXIpO1xufTtcblxuZnVuY3Rpb24gY2hlY2tDYW5jZWwoY3R4LCByZWFzb24pIHtcbiAgICBpZiAoY3R4LmNhbmNlbFByb21pc2UgIT0gbnVsbCkge1xuICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgIGN0eC5jYW5jZWxQcm9taXNlLl9yZWplY3QocmVhc29uKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGN0eC5jYW5jZWxQcm9taXNlLl9jYW5jZWwoKTtcbiAgICAgICAgfVxuICAgICAgICBjdHguY2FuY2VsUHJvbWlzZSA9IG51bGw7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIHN1Y2NlZWQoKSB7XG4gICAgcmV0dXJuIGZpbmFsbHlIYW5kbGVyLmNhbGwodGhpcywgdGhpcy5wcm9taXNlLl90YXJnZXQoKS5fc2V0dGxlZFZhbHVlKCkpO1xufVxuZnVuY3Rpb24gZmFpbChyZWFzb24pIHtcbiAgICBpZiAoY2hlY2tDYW5jZWwodGhpcywgcmVhc29uKSkgcmV0dXJuO1xuICAgIGVycm9yT2JqLmUgPSByZWFzb247XG4gICAgcmV0dXJuIGVycm9yT2JqO1xufVxuZnVuY3Rpb24gZmluYWxseUhhbmRsZXIocmVhc29uT3JWYWx1ZSkge1xuICAgIHZhciBwcm9taXNlID0gdGhpcy5wcm9taXNlO1xuICAgIHZhciBoYW5kbGVyID0gdGhpcy5oYW5kbGVyO1xuXG4gICAgaWYgKCF0aGlzLmNhbGxlZCkge1xuICAgICAgICB0aGlzLmNhbGxlZCA9IHRydWU7XG4gICAgICAgIHZhciByZXQgPSB0aGlzLmlzRmluYWxseUhhbmRsZXIoKVxuICAgICAgICAgICAgPyBoYW5kbGVyLmNhbGwocHJvbWlzZS5fYm91bmRWYWx1ZSgpKVxuICAgICAgICAgICAgOiBoYW5kbGVyLmNhbGwocHJvbWlzZS5fYm91bmRWYWx1ZSgpLCByZWFzb25PclZhbHVlKTtcbiAgICAgICAgaWYgKHJldCA9PT0gTkVYVF9GSUxURVIpIHtcbiAgICAgICAgICAgIHJldHVybiByZXQ7XG4gICAgICAgIH0gZWxzZSBpZiAocmV0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHByb21pc2UuX3NldFJldHVybmVkTm9uVW5kZWZpbmVkKCk7XG4gICAgICAgICAgICB2YXIgbWF5YmVQcm9taXNlID0gdHJ5Q29udmVydFRvUHJvbWlzZShyZXQsIHByb21pc2UpO1xuICAgICAgICAgICAgaWYgKG1heWJlUHJvbWlzZSBpbnN0YW5jZW9mIFByb21pc2UpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5jYW5jZWxQcm9taXNlICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG1heWJlUHJvbWlzZS5faXNDYW5jZWxsZWQoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHJlYXNvbiA9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV3IENhbmNlbGxhdGlvbkVycm9yKFwibGF0ZSBjYW5jZWxsYXRpb24gb2JzZXJ2ZXJcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICBwcm9taXNlLl9hdHRhY2hFeHRyYVRyYWNlKHJlYXNvbik7XG4gICAgICAgICAgICAgICAgICAgICAgICBlcnJvck9iai5lID0gcmVhc29uO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGVycm9yT2JqO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKG1heWJlUHJvbWlzZS5pc1BlbmRpbmcoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbWF5YmVQcm9taXNlLl9hdHRhY2hDYW5jZWxsYXRpb25DYWxsYmFjayhcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXcgRmluYWxseUhhbmRsZXJDYW5jZWxSZWFjdGlvbih0aGlzKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIG1heWJlUHJvbWlzZS5fdGhlbihcbiAgICAgICAgICAgICAgICAgICAgc3VjY2VlZCwgZmFpbCwgdW5kZWZpbmVkLCB0aGlzLCB1bmRlZmluZWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHByb21pc2UuaXNSZWplY3RlZCgpKSB7XG4gICAgICAgIGNoZWNrQ2FuY2VsKHRoaXMpO1xuICAgICAgICBlcnJvck9iai5lID0gcmVhc29uT3JWYWx1ZTtcbiAgICAgICAgcmV0dXJuIGVycm9yT2JqO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGNoZWNrQ2FuY2VsKHRoaXMpO1xuICAgICAgICByZXR1cm4gcmVhc29uT3JWYWx1ZTtcbiAgICB9XG59XG5cblByb21pc2UucHJvdG90eXBlLl9wYXNzVGhyb3VnaCA9IGZ1bmN0aW9uKGhhbmRsZXIsIHR5cGUsIHN1Y2Nlc3MsIGZhaWwpIHtcbiAgICBpZiAodHlwZW9mIGhhbmRsZXIgIT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIHRoaXMudGhlbigpO1xuICAgIHJldHVybiB0aGlzLl90aGVuKHN1Y2Nlc3MsXG4gICAgICAgICAgICAgICAgICAgICAgZmFpbCxcbiAgICAgICAgICAgICAgICAgICAgICB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgICAgICAgbmV3IFBhc3NUaHJvdWdoSGFuZGxlckNvbnRleHQodGhpcywgdHlwZSwgaGFuZGxlciksXG4gICAgICAgICAgICAgICAgICAgICAgdW5kZWZpbmVkKTtcbn07XG5cblByb21pc2UucHJvdG90eXBlLmxhc3RseSA9XG5Qcm9taXNlLnByb3RvdHlwZVtcImZpbmFsbHlcIl0gPSBmdW5jdGlvbiAoaGFuZGxlcikge1xuICAgIHJldHVybiB0aGlzLl9wYXNzVGhyb3VnaChoYW5kbGVyLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmaW5hbGx5SGFuZGxlcixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZmluYWxseUhhbmRsZXIpO1xufTtcblxuXG5Qcm9taXNlLnByb3RvdHlwZS50YXAgPSBmdW5jdGlvbiAoaGFuZGxlcikge1xuICAgIHJldHVybiB0aGlzLl9wYXNzVGhyb3VnaChoYW5kbGVyLCAxLCBmaW5hbGx5SGFuZGxlcik7XG59O1xuXG5Qcm9taXNlLnByb3RvdHlwZS50YXBDYXRjaCA9IGZ1bmN0aW9uIChoYW5kbGVyT3JQcmVkaWNhdGUpIHtcbiAgICB2YXIgbGVuID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICBpZihsZW4gPT09IDEpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3Bhc3NUaHJvdWdoKGhhbmRsZXJPclByZWRpY2F0ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDEsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmaW5hbGx5SGFuZGxlcik7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgIHZhciBjYXRjaEluc3RhbmNlcyA9IG5ldyBBcnJheShsZW4gLSAxKSxcbiAgICAgICAgICAgIGogPSAwLCBpO1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuIC0gMTsgKytpKSB7XG4gICAgICAgICAgICB2YXIgaXRlbSA9IGFyZ3VtZW50c1tpXTtcbiAgICAgICAgICAgIGlmICh1dGlsLmlzT2JqZWN0KGl0ZW0pKSB7XG4gICAgICAgICAgICAgICAgY2F0Y2hJbnN0YW5jZXNbaisrXSA9IGl0ZW07XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChuZXcgVHlwZUVycm9yKFxuICAgICAgICAgICAgICAgICAgICBcInRhcENhdGNoIHN0YXRlbWVudCBwcmVkaWNhdGU6IFwiXG4gICAgICAgICAgICAgICAgICAgICsgXCJleHBlY3RpbmcgYW4gb2JqZWN0IGJ1dCBnb3QgXCIgKyB1dGlsLmNsYXNzU3RyaW5nKGl0ZW0pXG4gICAgICAgICAgICAgICAgKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2hJbnN0YW5jZXMubGVuZ3RoID0gajtcbiAgICAgICAgdmFyIGhhbmRsZXIgPSBhcmd1bWVudHNbaV07XG4gICAgICAgIHJldHVybiB0aGlzLl9wYXNzVGhyb3VnaChjYXRjaEZpbHRlcihjYXRjaEluc3RhbmNlcywgaGFuZGxlciwgdGhpcyksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAxLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZmluYWxseUhhbmRsZXIpO1xuICAgIH1cblxufTtcblxucmV0dXJuIFBhc3NUaHJvdWdoSGFuZGxlckNvbnRleHQ7XG59O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2JsdWViaXJkL2pzL3JlbGVhc2UvZmluYWxseS5qcyIsIlwidXNlIHN0cmljdFwiO1xubW9kdWxlLmV4cG9ydHMgPVxuZnVuY3Rpb24oUHJvbWlzZSwgSU5URVJOQUwsIHRyeUNvbnZlcnRUb1Byb21pc2UsIGFwaVJlamVjdGlvbiwgZGVidWcpIHtcbnZhciB1dGlsID0gcmVxdWlyZShcIi4vdXRpbFwiKTtcbnZhciB0cnlDYXRjaCA9IHV0aWwudHJ5Q2F0Y2g7XG5cblByb21pc2UubWV0aG9kID0gZnVuY3Rpb24gKGZuKSB7XG4gICAgaWYgKHR5cGVvZiBmbiAhPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIHRocm93IG5ldyBQcm9taXNlLlR5cGVFcnJvcihcImV4cGVjdGluZyBhIGZ1bmN0aW9uIGJ1dCBnb3QgXCIgKyB1dGlsLmNsYXNzU3RyaW5nKGZuKSk7XG4gICAgfVxuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciByZXQgPSBuZXcgUHJvbWlzZShJTlRFUk5BTCk7XG4gICAgICAgIHJldC5fY2FwdHVyZVN0YWNrVHJhY2UoKTtcbiAgICAgICAgcmV0Ll9wdXNoQ29udGV4dCgpO1xuICAgICAgICB2YXIgdmFsdWUgPSB0cnlDYXRjaChmbikuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgdmFyIHByb21pc2VDcmVhdGVkID0gcmV0Ll9wb3BDb250ZXh0KCk7XG4gICAgICAgIGRlYnVnLmNoZWNrRm9yZ290dGVuUmV0dXJucyhcbiAgICAgICAgICAgIHZhbHVlLCBwcm9taXNlQ3JlYXRlZCwgXCJQcm9taXNlLm1ldGhvZFwiLCByZXQpO1xuICAgICAgICByZXQuX3Jlc29sdmVGcm9tU3luY1ZhbHVlKHZhbHVlKTtcbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICB9O1xufTtcblxuUHJvbWlzZS5hdHRlbXB0ID0gUHJvbWlzZVtcInRyeVwiXSA9IGZ1bmN0aW9uIChmbikge1xuICAgIGlmICh0eXBlb2YgZm4gIT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICByZXR1cm4gYXBpUmVqZWN0aW9uKFwiZXhwZWN0aW5nIGEgZnVuY3Rpb24gYnV0IGdvdCBcIiArIHV0aWwuY2xhc3NTdHJpbmcoZm4pKTtcbiAgICB9XG4gICAgdmFyIHJldCA9IG5ldyBQcm9taXNlKElOVEVSTkFMKTtcbiAgICByZXQuX2NhcHR1cmVTdGFja1RyYWNlKCk7XG4gICAgcmV0Ll9wdXNoQ29udGV4dCgpO1xuICAgIHZhciB2YWx1ZTtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgZGVidWcuZGVwcmVjYXRlZChcImNhbGxpbmcgUHJvbWlzZS50cnkgd2l0aCBtb3JlIHRoYW4gMSBhcmd1bWVudFwiKTtcbiAgICAgICAgdmFyIGFyZyA9IGFyZ3VtZW50c1sxXTtcbiAgICAgICAgdmFyIGN0eCA9IGFyZ3VtZW50c1syXTtcbiAgICAgICAgdmFsdWUgPSB1dGlsLmlzQXJyYXkoYXJnKSA/IHRyeUNhdGNoKGZuKS5hcHBseShjdHgsIGFyZylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IHRyeUNhdGNoKGZuKS5jYWxsKGN0eCwgYXJnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICB2YWx1ZSA9IHRyeUNhdGNoKGZuKSgpO1xuICAgIH1cbiAgICB2YXIgcHJvbWlzZUNyZWF0ZWQgPSByZXQuX3BvcENvbnRleHQoKTtcbiAgICBkZWJ1Zy5jaGVja0ZvcmdvdHRlblJldHVybnMoXG4gICAgICAgIHZhbHVlLCBwcm9taXNlQ3JlYXRlZCwgXCJQcm9taXNlLnRyeVwiLCByZXQpO1xuICAgIHJldC5fcmVzb2x2ZUZyb21TeW5jVmFsdWUodmFsdWUpO1xuICAgIHJldHVybiByZXQ7XG59O1xuXG5Qcm9taXNlLnByb3RvdHlwZS5fcmVzb2x2ZUZyb21TeW5jVmFsdWUgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICBpZiAodmFsdWUgPT09IHV0aWwuZXJyb3JPYmopIHtcbiAgICAgICAgdGhpcy5fcmVqZWN0Q2FsbGJhY2sodmFsdWUuZSwgZmFsc2UpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuX3Jlc29sdmVDYWxsYmFjayh2YWx1ZSwgdHJ1ZSk7XG4gICAgfVxufTtcbn07XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvYmx1ZWJpcmQvanMvcmVsZWFzZS9tZXRob2QuanMiLCJcInVzZSBzdHJpY3RcIjtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oUHJvbWlzZSwgSU5URVJOQUwsIHRyeUNvbnZlcnRUb1Byb21pc2UsIGRlYnVnKSB7XG52YXIgY2FsbGVkQmluZCA9IGZhbHNlO1xudmFyIHJlamVjdFRoaXMgPSBmdW5jdGlvbihfLCBlKSB7XG4gICAgdGhpcy5fcmVqZWN0KGUpO1xufTtcblxudmFyIHRhcmdldFJlamVjdGVkID0gZnVuY3Rpb24oZSwgY29udGV4dCkge1xuICAgIGNvbnRleHQucHJvbWlzZVJlamVjdGlvblF1ZXVlZCA9IHRydWU7XG4gICAgY29udGV4dC5iaW5kaW5nUHJvbWlzZS5fdGhlbihyZWplY3RUaGlzLCByZWplY3RUaGlzLCBudWxsLCB0aGlzLCBlKTtcbn07XG5cbnZhciBiaW5kaW5nUmVzb2x2ZWQgPSBmdW5jdGlvbih0aGlzQXJnLCBjb250ZXh0KSB7XG4gICAgaWYgKCgodGhpcy5fYml0RmllbGQgJiA1MDM5NzE4NCkgPT09IDApKSB7XG4gICAgICAgIHRoaXMuX3Jlc29sdmVDYWxsYmFjayhjb250ZXh0LnRhcmdldCk7XG4gICAgfVxufTtcblxudmFyIGJpbmRpbmdSZWplY3RlZCA9IGZ1bmN0aW9uKGUsIGNvbnRleHQpIHtcbiAgICBpZiAoIWNvbnRleHQucHJvbWlzZVJlamVjdGlvblF1ZXVlZCkgdGhpcy5fcmVqZWN0KGUpO1xufTtcblxuUHJvbWlzZS5wcm90b3R5cGUuYmluZCA9IGZ1bmN0aW9uICh0aGlzQXJnKSB7XG4gICAgaWYgKCFjYWxsZWRCaW5kKSB7XG4gICAgICAgIGNhbGxlZEJpbmQgPSB0cnVlO1xuICAgICAgICBQcm9taXNlLnByb3RvdHlwZS5fcHJvcGFnYXRlRnJvbSA9IGRlYnVnLnByb3BhZ2F0ZUZyb21GdW5jdGlvbigpO1xuICAgICAgICBQcm9taXNlLnByb3RvdHlwZS5fYm91bmRWYWx1ZSA9IGRlYnVnLmJvdW5kVmFsdWVGdW5jdGlvbigpO1xuICAgIH1cbiAgICB2YXIgbWF5YmVQcm9taXNlID0gdHJ5Q29udmVydFRvUHJvbWlzZSh0aGlzQXJnKTtcbiAgICB2YXIgcmV0ID0gbmV3IFByb21pc2UoSU5URVJOQUwpO1xuICAgIHJldC5fcHJvcGFnYXRlRnJvbSh0aGlzLCAxKTtcbiAgICB2YXIgdGFyZ2V0ID0gdGhpcy5fdGFyZ2V0KCk7XG4gICAgcmV0Ll9zZXRCb3VuZFRvKG1heWJlUHJvbWlzZSk7XG4gICAgaWYgKG1heWJlUHJvbWlzZSBpbnN0YW5jZW9mIFByb21pc2UpIHtcbiAgICAgICAgdmFyIGNvbnRleHQgPSB7XG4gICAgICAgICAgICBwcm9taXNlUmVqZWN0aW9uUXVldWVkOiBmYWxzZSxcbiAgICAgICAgICAgIHByb21pc2U6IHJldCxcbiAgICAgICAgICAgIHRhcmdldDogdGFyZ2V0LFxuICAgICAgICAgICAgYmluZGluZ1Byb21pc2U6IG1heWJlUHJvbWlzZVxuICAgICAgICB9O1xuICAgICAgICB0YXJnZXQuX3RoZW4oSU5URVJOQUwsIHRhcmdldFJlamVjdGVkLCB1bmRlZmluZWQsIHJldCwgY29udGV4dCk7XG4gICAgICAgIG1heWJlUHJvbWlzZS5fdGhlbihcbiAgICAgICAgICAgIGJpbmRpbmdSZXNvbHZlZCwgYmluZGluZ1JlamVjdGVkLCB1bmRlZmluZWQsIHJldCwgY29udGV4dCk7XG4gICAgICAgIHJldC5fc2V0T25DYW5jZWwobWF5YmVQcm9taXNlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXQuX3Jlc29sdmVDYWxsYmFjayh0YXJnZXQpO1xuICAgIH1cbiAgICByZXR1cm4gcmV0O1xufTtcblxuUHJvbWlzZS5wcm90b3R5cGUuX3NldEJvdW5kVG8gPSBmdW5jdGlvbiAob2JqKSB7XG4gICAgaWYgKG9iaiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRoaXMuX2JpdEZpZWxkID0gdGhpcy5fYml0RmllbGQgfCAyMDk3MTUyO1xuICAgICAgICB0aGlzLl9ib3VuZFRvID0gb2JqO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuX2JpdEZpZWxkID0gdGhpcy5fYml0RmllbGQgJiAofjIwOTcxNTIpO1xuICAgIH1cbn07XG5cblByb21pc2UucHJvdG90eXBlLl9pc0JvdW5kID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiAodGhpcy5fYml0RmllbGQgJiAyMDk3MTUyKSA9PT0gMjA5NzE1Mjtcbn07XG5cblByb21pc2UuYmluZCA9IGZ1bmN0aW9uICh0aGlzQXJnLCB2YWx1ZSkge1xuICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUodmFsdWUpLmJpbmQodGhpc0FyZyk7XG59O1xufTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9ibHVlYmlyZC9qcy9yZWxlYXNlL2JpbmQuanMiLCJcInVzZSBzdHJpY3RcIjtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oUHJvbWlzZSwgUHJvbWlzZUFycmF5LCBhcGlSZWplY3Rpb24sIGRlYnVnKSB7XG52YXIgdXRpbCA9IHJlcXVpcmUoXCIuL3V0aWxcIik7XG52YXIgdHJ5Q2F0Y2ggPSB1dGlsLnRyeUNhdGNoO1xudmFyIGVycm9yT2JqID0gdXRpbC5lcnJvck9iajtcbnZhciBhc3luYyA9IFByb21pc2UuX2FzeW5jO1xuXG5Qcm9taXNlLnByb3RvdHlwZVtcImJyZWFrXCJdID0gUHJvbWlzZS5wcm90b3R5cGUuY2FuY2VsID0gZnVuY3Rpb24oKSB7XG4gICAgaWYgKCFkZWJ1Zy5jYW5jZWxsYXRpb24oKSkgcmV0dXJuIHRoaXMuX3dhcm4oXCJjYW5jZWxsYXRpb24gaXMgZGlzYWJsZWRcIik7XG5cbiAgICB2YXIgcHJvbWlzZSA9IHRoaXM7XG4gICAgdmFyIGNoaWxkID0gcHJvbWlzZTtcbiAgICB3aGlsZSAocHJvbWlzZS5faXNDYW5jZWxsYWJsZSgpKSB7XG4gICAgICAgIGlmICghcHJvbWlzZS5fY2FuY2VsQnkoY2hpbGQpKSB7XG4gICAgICAgICAgICBpZiAoY2hpbGQuX2lzRm9sbG93aW5nKCkpIHtcbiAgICAgICAgICAgICAgICBjaGlsZC5fZm9sbG93ZWUoKS5jYW5jZWwoKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgY2hpbGQuX2NhbmNlbEJyYW5jaGVkKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBwYXJlbnQgPSBwcm9taXNlLl9jYW5jZWxsYXRpb25QYXJlbnQ7XG4gICAgICAgIGlmIChwYXJlbnQgPT0gbnVsbCB8fCAhcGFyZW50Ll9pc0NhbmNlbGxhYmxlKCkpIHtcbiAgICAgICAgICAgIGlmIChwcm9taXNlLl9pc0ZvbGxvd2luZygpKSB7XG4gICAgICAgICAgICAgICAgcHJvbWlzZS5fZm9sbG93ZWUoKS5jYW5jZWwoKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcHJvbWlzZS5fY2FuY2VsQnJhbmNoZWQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKHByb21pc2UuX2lzRm9sbG93aW5nKCkpIHByb21pc2UuX2ZvbGxvd2VlKCkuY2FuY2VsKCk7XG4gICAgICAgICAgICBwcm9taXNlLl9zZXRXaWxsQmVDYW5jZWxsZWQoKTtcbiAgICAgICAgICAgIGNoaWxkID0gcHJvbWlzZTtcbiAgICAgICAgICAgIHByb21pc2UgPSBwYXJlbnQ7XG4gICAgICAgIH1cbiAgICB9XG59O1xuXG5Qcm9taXNlLnByb3RvdHlwZS5fYnJhbmNoSGFzQ2FuY2VsbGVkID0gZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5fYnJhbmNoZXNSZW1haW5pbmdUb0NhbmNlbC0tO1xufTtcblxuUHJvbWlzZS5wcm90b3R5cGUuX2Vub3VnaEJyYW5jaGVzSGF2ZUNhbmNlbGxlZCA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLl9icmFuY2hlc1JlbWFpbmluZ1RvQ2FuY2VsID09PSB1bmRlZmluZWQgfHxcbiAgICAgICAgICAgdGhpcy5fYnJhbmNoZXNSZW1haW5pbmdUb0NhbmNlbCA8PSAwO1xufTtcblxuUHJvbWlzZS5wcm90b3R5cGUuX2NhbmNlbEJ5ID0gZnVuY3Rpb24oY2FuY2VsbGVyKSB7XG4gICAgaWYgKGNhbmNlbGxlciA9PT0gdGhpcykge1xuICAgICAgICB0aGlzLl9icmFuY2hlc1JlbWFpbmluZ1RvQ2FuY2VsID0gMDtcbiAgICAgICAgdGhpcy5faW52b2tlT25DYW5jZWwoKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5fYnJhbmNoSGFzQ2FuY2VsbGVkKCk7XG4gICAgICAgIGlmICh0aGlzLl9lbm91Z2hCcmFuY2hlc0hhdmVDYW5jZWxsZWQoKSkge1xuICAgICAgICAgICAgdGhpcy5faW52b2tlT25DYW5jZWwoKTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn07XG5cblByb21pc2UucHJvdG90eXBlLl9jYW5jZWxCcmFuY2hlZCA9IGZ1bmN0aW9uKCkge1xuICAgIGlmICh0aGlzLl9lbm91Z2hCcmFuY2hlc0hhdmVDYW5jZWxsZWQoKSkge1xuICAgICAgICB0aGlzLl9jYW5jZWwoKTtcbiAgICB9XG59O1xuXG5Qcm9taXNlLnByb3RvdHlwZS5fY2FuY2VsID0gZnVuY3Rpb24oKSB7XG4gICAgaWYgKCF0aGlzLl9pc0NhbmNlbGxhYmxlKCkpIHJldHVybjtcbiAgICB0aGlzLl9zZXRDYW5jZWxsZWQoKTtcbiAgICBhc3luYy5pbnZva2UodGhpcy5fY2FuY2VsUHJvbWlzZXMsIHRoaXMsIHVuZGVmaW5lZCk7XG59O1xuXG5Qcm9taXNlLnByb3RvdHlwZS5fY2FuY2VsUHJvbWlzZXMgPSBmdW5jdGlvbigpIHtcbiAgICBpZiAodGhpcy5fbGVuZ3RoKCkgPiAwKSB0aGlzLl9zZXR0bGVQcm9taXNlcygpO1xufTtcblxuUHJvbWlzZS5wcm90b3R5cGUuX3Vuc2V0T25DYW5jZWwgPSBmdW5jdGlvbigpIHtcbiAgICB0aGlzLl9vbkNhbmNlbEZpZWxkID0gdW5kZWZpbmVkO1xufTtcblxuUHJvbWlzZS5wcm90b3R5cGUuX2lzQ2FuY2VsbGFibGUgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5pc1BlbmRpbmcoKSAmJiAhdGhpcy5faXNDYW5jZWxsZWQoKTtcbn07XG5cblByb21pc2UucHJvdG90eXBlLmlzQ2FuY2VsbGFibGUgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5pc1BlbmRpbmcoKSAmJiAhdGhpcy5pc0NhbmNlbGxlZCgpO1xufTtcblxuUHJvbWlzZS5wcm90b3R5cGUuX2RvSW52b2tlT25DYW5jZWwgPSBmdW5jdGlvbihvbkNhbmNlbENhbGxiYWNrLCBpbnRlcm5hbE9ubHkpIHtcbiAgICBpZiAodXRpbC5pc0FycmF5KG9uQ2FuY2VsQ2FsbGJhY2spKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgb25DYW5jZWxDYWxsYmFjay5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgdGhpcy5fZG9JbnZva2VPbkNhbmNlbChvbkNhbmNlbENhbGxiYWNrW2ldLCBpbnRlcm5hbE9ubHkpO1xuICAgICAgICB9XG4gICAgfSBlbHNlIGlmIChvbkNhbmNlbENhbGxiYWNrICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBvbkNhbmNlbENhbGxiYWNrID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgIGlmICghaW50ZXJuYWxPbmx5KSB7XG4gICAgICAgICAgICAgICAgdmFyIGUgPSB0cnlDYXRjaChvbkNhbmNlbENhbGxiYWNrKS5jYWxsKHRoaXMuX2JvdW5kVmFsdWUoKSk7XG4gICAgICAgICAgICAgICAgaWYgKGUgPT09IGVycm9yT2JqKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2F0dGFjaEV4dHJhVHJhY2UoZS5lKTtcbiAgICAgICAgICAgICAgICAgICAgYXN5bmMudGhyb3dMYXRlcihlLmUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG9uQ2FuY2VsQ2FsbGJhY2suX3Jlc3VsdENhbmNlbGxlZCh0aGlzKTtcbiAgICAgICAgfVxuICAgIH1cbn07XG5cblByb21pc2UucHJvdG90eXBlLl9pbnZva2VPbkNhbmNlbCA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBvbkNhbmNlbENhbGxiYWNrID0gdGhpcy5fb25DYW5jZWwoKTtcbiAgICB0aGlzLl91bnNldE9uQ2FuY2VsKCk7XG4gICAgYXN5bmMuaW52b2tlKHRoaXMuX2RvSW52b2tlT25DYW5jZWwsIHRoaXMsIG9uQ2FuY2VsQ2FsbGJhY2spO1xufTtcblxuUHJvbWlzZS5wcm90b3R5cGUuX2ludm9rZUludGVybmFsT25DYW5jZWwgPSBmdW5jdGlvbigpIHtcbiAgICBpZiAodGhpcy5faXNDYW5jZWxsYWJsZSgpKSB7XG4gICAgICAgIHRoaXMuX2RvSW52b2tlT25DYW5jZWwodGhpcy5fb25DYW5jZWwoKSwgdHJ1ZSk7XG4gICAgICAgIHRoaXMuX3Vuc2V0T25DYW5jZWwoKTtcbiAgICB9XG59O1xuXG5Qcm9taXNlLnByb3RvdHlwZS5fcmVzdWx0Q2FuY2VsbGVkID0gZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5jYW5jZWwoKTtcbn07XG5cbn07XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvYmx1ZWJpcmQvanMvcmVsZWFzZS9jYW5jZWwuanMiLCJcInVzZSBzdHJpY3RcIjtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oUHJvbWlzZSkge1xuZnVuY3Rpb24gcmV0dXJuZXIoKSB7XG4gICAgcmV0dXJuIHRoaXMudmFsdWU7XG59XG5mdW5jdGlvbiB0aHJvd2VyKCkge1xuICAgIHRocm93IHRoaXMucmVhc29uO1xufVxuXG5Qcm9taXNlLnByb3RvdHlwZVtcInJldHVyblwiXSA9XG5Qcm9taXNlLnByb3RvdHlwZS50aGVuUmV0dXJuID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgUHJvbWlzZSkgdmFsdWUuc3VwcHJlc3NVbmhhbmRsZWRSZWplY3Rpb25zKCk7XG4gICAgcmV0dXJuIHRoaXMuX3RoZW4oXG4gICAgICAgIHJldHVybmVyLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwge3ZhbHVlOiB2YWx1ZX0sIHVuZGVmaW5lZCk7XG59O1xuXG5Qcm9taXNlLnByb3RvdHlwZVtcInRocm93XCJdID1cblByb21pc2UucHJvdG90eXBlLnRoZW5UaHJvdyA9IGZ1bmN0aW9uIChyZWFzb24pIHtcbiAgICByZXR1cm4gdGhpcy5fdGhlbihcbiAgICAgICAgdGhyb3dlciwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIHtyZWFzb246IHJlYXNvbn0sIHVuZGVmaW5lZCk7XG59O1xuXG5Qcm9taXNlLnByb3RvdHlwZS5jYXRjaFRocm93ID0gZnVuY3Rpb24gKHJlYXNvbikge1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoIDw9IDEpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3RoZW4oXG4gICAgICAgICAgICB1bmRlZmluZWQsIHRocm93ZXIsIHVuZGVmaW5lZCwge3JlYXNvbjogcmVhc29ufSwgdW5kZWZpbmVkKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgX3JlYXNvbiA9IGFyZ3VtZW50c1sxXTtcbiAgICAgICAgdmFyIGhhbmRsZXIgPSBmdW5jdGlvbigpIHt0aHJvdyBfcmVhc29uO307XG4gICAgICAgIHJldHVybiB0aGlzLmNhdWdodChyZWFzb24sIGhhbmRsZXIpO1xuICAgIH1cbn07XG5cblByb21pc2UucHJvdG90eXBlLmNhdGNoUmV0dXJuID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPD0gMSkge1xuICAgICAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBQcm9taXNlKSB2YWx1ZS5zdXBwcmVzc1VuaGFuZGxlZFJlamVjdGlvbnMoKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3RoZW4oXG4gICAgICAgICAgICB1bmRlZmluZWQsIHJldHVybmVyLCB1bmRlZmluZWQsIHt2YWx1ZTogdmFsdWV9LCB1bmRlZmluZWQpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBfdmFsdWUgPSBhcmd1bWVudHNbMV07XG4gICAgICAgIGlmIChfdmFsdWUgaW5zdGFuY2VvZiBQcm9taXNlKSBfdmFsdWUuc3VwcHJlc3NVbmhhbmRsZWRSZWplY3Rpb25zKCk7XG4gICAgICAgIHZhciBoYW5kbGVyID0gZnVuY3Rpb24oKSB7cmV0dXJuIF92YWx1ZTt9O1xuICAgICAgICByZXR1cm4gdGhpcy5jYXVnaHQodmFsdWUsIGhhbmRsZXIpO1xuICAgIH1cbn07XG59O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2JsdWViaXJkL2pzL3JlbGVhc2UvZGlyZWN0X3Jlc29sdmUuanMiLCJcInVzZSBzdHJpY3RcIjtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oUHJvbWlzZSkge1xuZnVuY3Rpb24gUHJvbWlzZUluc3BlY3Rpb24ocHJvbWlzZSkge1xuICAgIGlmIChwcm9taXNlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcHJvbWlzZSA9IHByb21pc2UuX3RhcmdldCgpO1xuICAgICAgICB0aGlzLl9iaXRGaWVsZCA9IHByb21pc2UuX2JpdEZpZWxkO1xuICAgICAgICB0aGlzLl9zZXR0bGVkVmFsdWVGaWVsZCA9IHByb21pc2UuX2lzRmF0ZVNlYWxlZCgpXG4gICAgICAgICAgICA/IHByb21pc2UuX3NldHRsZWRWYWx1ZSgpIDogdW5kZWZpbmVkO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgdGhpcy5fYml0RmllbGQgPSAwO1xuICAgICAgICB0aGlzLl9zZXR0bGVkVmFsdWVGaWVsZCA9IHVuZGVmaW5lZDtcbiAgICB9XG59XG5cblByb21pc2VJbnNwZWN0aW9uLnByb3RvdHlwZS5fc2V0dGxlZFZhbHVlID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuX3NldHRsZWRWYWx1ZUZpZWxkO1xufTtcblxudmFyIHZhbHVlID0gUHJvbWlzZUluc3BlY3Rpb24ucHJvdG90eXBlLnZhbHVlID0gZnVuY3Rpb24gKCkge1xuICAgIGlmICghdGhpcy5pc0Z1bGZpbGxlZCgpKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJjYW5ub3QgZ2V0IGZ1bGZpbGxtZW50IHZhbHVlIG9mIGEgbm9uLWZ1bGZpbGxlZCBwcm9taXNlXFx1MDAwYVxcdTAwMGEgICAgU2VlIGh0dHA6Ly9nb28uZ2wvTXFyRm1YXFx1MDAwYVwiKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX3NldHRsZWRWYWx1ZSgpO1xufTtcblxudmFyIHJlYXNvbiA9IFByb21pc2VJbnNwZWN0aW9uLnByb3RvdHlwZS5lcnJvciA9XG5Qcm9taXNlSW5zcGVjdGlvbi5wcm90b3R5cGUucmVhc29uID0gZnVuY3Rpb24gKCkge1xuICAgIGlmICghdGhpcy5pc1JlamVjdGVkKCkpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcImNhbm5vdCBnZXQgcmVqZWN0aW9uIHJlYXNvbiBvZiBhIG5vbi1yZWplY3RlZCBwcm9taXNlXFx1MDAwYVxcdTAwMGEgICAgU2VlIGh0dHA6Ly9nb28uZ2wvTXFyRm1YXFx1MDAwYVwiKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX3NldHRsZWRWYWx1ZSgpO1xufTtcblxudmFyIGlzRnVsZmlsbGVkID0gUHJvbWlzZUluc3BlY3Rpb24ucHJvdG90eXBlLmlzRnVsZmlsbGVkID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuICh0aGlzLl9iaXRGaWVsZCAmIDMzNTU0NDMyKSAhPT0gMDtcbn07XG5cbnZhciBpc1JlamVjdGVkID0gUHJvbWlzZUluc3BlY3Rpb24ucHJvdG90eXBlLmlzUmVqZWN0ZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuICh0aGlzLl9iaXRGaWVsZCAmIDE2Nzc3MjE2KSAhPT0gMDtcbn07XG5cbnZhciBpc1BlbmRpbmcgPSBQcm9taXNlSW5zcGVjdGlvbi5wcm90b3R5cGUuaXNQZW5kaW5nID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiAodGhpcy5fYml0RmllbGQgJiA1MDM5NzE4NCkgPT09IDA7XG59O1xuXG52YXIgaXNSZXNvbHZlZCA9IFByb21pc2VJbnNwZWN0aW9uLnByb3RvdHlwZS5pc1Jlc29sdmVkID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiAodGhpcy5fYml0RmllbGQgJiA1MDMzMTY0OCkgIT09IDA7XG59O1xuXG5Qcm9taXNlSW5zcGVjdGlvbi5wcm90b3R5cGUuaXNDYW5jZWxsZWQgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gKHRoaXMuX2JpdEZpZWxkICYgODQ1NDE0NCkgIT09IDA7XG59O1xuXG5Qcm9taXNlLnByb3RvdHlwZS5fX2lzQ2FuY2VsbGVkID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuICh0aGlzLl9iaXRGaWVsZCAmIDY1NTM2KSA9PT0gNjU1MzY7XG59O1xuXG5Qcm9taXNlLnByb3RvdHlwZS5faXNDYW5jZWxsZWQgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5fdGFyZ2V0KCkuX19pc0NhbmNlbGxlZCgpO1xufTtcblxuUHJvbWlzZS5wcm90b3R5cGUuaXNDYW5jZWxsZWQgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gKHRoaXMuX3RhcmdldCgpLl9iaXRGaWVsZCAmIDg0NTQxNDQpICE9PSAwO1xufTtcblxuUHJvbWlzZS5wcm90b3R5cGUuaXNQZW5kaW5nID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIGlzUGVuZGluZy5jYWxsKHRoaXMuX3RhcmdldCgpKTtcbn07XG5cblByb21pc2UucHJvdG90eXBlLmlzUmVqZWN0ZWQgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gaXNSZWplY3RlZC5jYWxsKHRoaXMuX3RhcmdldCgpKTtcbn07XG5cblByb21pc2UucHJvdG90eXBlLmlzRnVsZmlsbGVkID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIGlzRnVsZmlsbGVkLmNhbGwodGhpcy5fdGFyZ2V0KCkpO1xufTtcblxuUHJvbWlzZS5wcm90b3R5cGUuaXNSZXNvbHZlZCA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBpc1Jlc29sdmVkLmNhbGwodGhpcy5fdGFyZ2V0KCkpO1xufTtcblxuUHJvbWlzZS5wcm90b3R5cGUudmFsdWUgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdmFsdWUuY2FsbCh0aGlzLl90YXJnZXQoKSk7XG59O1xuXG5Qcm9taXNlLnByb3RvdHlwZS5yZWFzb24gPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgdGFyZ2V0ID0gdGhpcy5fdGFyZ2V0KCk7XG4gICAgdGFyZ2V0Ll91bnNldFJlamVjdGlvbklzVW5oYW5kbGVkKCk7XG4gICAgcmV0dXJuIHJlYXNvbi5jYWxsKHRhcmdldCk7XG59O1xuXG5Qcm9taXNlLnByb3RvdHlwZS5fdmFsdWUgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5fc2V0dGxlZFZhbHVlKCk7XG59O1xuXG5Qcm9taXNlLnByb3RvdHlwZS5fcmVhc29uID0gZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5fdW5zZXRSZWplY3Rpb25Jc1VuaGFuZGxlZCgpO1xuICAgIHJldHVybiB0aGlzLl9zZXR0bGVkVmFsdWUoKTtcbn07XG5cblByb21pc2UuUHJvbWlzZUluc3BlY3Rpb24gPSBQcm9taXNlSW5zcGVjdGlvbjtcbn07XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvYmx1ZWJpcmQvanMvcmVsZWFzZS9zeW5jaHJvbm91c19pbnNwZWN0aW9uLmpzIiwiXCJ1c2Ugc3RyaWN0XCI7XG5tb2R1bGUuZXhwb3J0cyA9XG5mdW5jdGlvbihQcm9taXNlLCBQcm9taXNlQXJyYXksIHRyeUNvbnZlcnRUb1Byb21pc2UsIElOVEVSTkFMLCBhc3luYyxcbiAgICAgICAgIGdldERvbWFpbikge1xudmFyIHV0aWwgPSByZXF1aXJlKFwiLi91dGlsXCIpO1xudmFyIGNhbkV2YWx1YXRlID0gdXRpbC5jYW5FdmFsdWF0ZTtcbnZhciB0cnlDYXRjaCA9IHV0aWwudHJ5Q2F0Y2g7XG52YXIgZXJyb3JPYmogPSB1dGlsLmVycm9yT2JqO1xudmFyIHJlamVjdDtcblxuaWYgKCFmYWxzZSkge1xuaWYgKGNhbkV2YWx1YXRlKSB7XG4gICAgdmFyIHRoZW5DYWxsYmFjayA9IGZ1bmN0aW9uKGkpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBGdW5jdGlvbihcInZhbHVlXCIsIFwiaG9sZGVyXCIsIFwiICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcXG5cXFxuICAgICAgICAgICAgJ3VzZSBzdHJpY3QnOyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcXG5cXFxuICAgICAgICAgICAgaG9sZGVyLnBJbmRleCA9IHZhbHVlOyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcXG5cXFxuICAgICAgICAgICAgaG9sZGVyLmNoZWNrRnVsZmlsbG1lbnQodGhpcyk7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcXG5cXFxuICAgICAgICAgICAgXCIucmVwbGFjZSgvSW5kZXgvZywgaSkpO1xuICAgIH07XG5cbiAgICB2YXIgcHJvbWlzZVNldHRlciA9IGZ1bmN0aW9uKGkpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBGdW5jdGlvbihcInByb21pc2VcIiwgXCJob2xkZXJcIiwgXCIgICAgICAgICAgICAgICAgICAgICAgICAgICBcXG5cXFxuICAgICAgICAgICAgJ3VzZSBzdHJpY3QnOyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcXG5cXFxuICAgICAgICAgICAgaG9sZGVyLnBJbmRleCA9IHByb21pc2U7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcXG5cXFxuICAgICAgICAgICAgXCIucmVwbGFjZSgvSW5kZXgvZywgaSkpO1xuICAgIH07XG5cbiAgICB2YXIgZ2VuZXJhdGVIb2xkZXJDbGFzcyA9IGZ1bmN0aW9uKHRvdGFsKSB7XG4gICAgICAgIHZhciBwcm9wcyA9IG5ldyBBcnJheSh0b3RhbCk7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIHByb3BzW2ldID0gXCJ0aGlzLnBcIiArIChpKzEpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBhc3NpZ25tZW50ID0gcHJvcHMuam9pbihcIiA9IFwiKSArIFwiID0gbnVsbDtcIjtcbiAgICAgICAgdmFyIGNhbmNlbGxhdGlvbkNvZGU9IFwidmFyIHByb21pc2U7XFxuXCIgKyBwcm9wcy5tYXAoZnVuY3Rpb24ocHJvcCkge1xuICAgICAgICAgICAgcmV0dXJuIFwiICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXFxuXFxcbiAgICAgICAgICAgICAgICBwcm9taXNlID0gXCIgKyBwcm9wICsgXCI7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcXG5cXFxuICAgICAgICAgICAgICAgIGlmIChwcm9taXNlIGluc3RhbmNlb2YgUHJvbWlzZSkgeyAgICAgICAgICAgICAgICAgICAgICAgICAgICBcXG5cXFxuICAgICAgICAgICAgICAgICAgICBwcm9taXNlLmNhbmNlbCgpOyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcXG5cXFxuICAgICAgICAgICAgICAgIH0gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcXG5cXFxuICAgICAgICAgICAgXCI7XG4gICAgICAgIH0pLmpvaW4oXCJcXG5cIik7XG4gICAgICAgIHZhciBwYXNzZWRBcmd1bWVudHMgPSBwcm9wcy5qb2luKFwiLCBcIik7XG4gICAgICAgIHZhciBuYW1lID0gXCJIb2xkZXIkXCIgKyB0b3RhbDtcblxuXG4gICAgICAgIHZhciBjb2RlID0gXCJyZXR1cm4gZnVuY3Rpb24odHJ5Q2F0Y2gsIGVycm9yT2JqLCBQcm9taXNlLCBhc3luYykgeyAgICBcXG5cXFxuICAgICAgICAgICAgJ3VzZSBzdHJpY3QnOyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcXG5cXFxuICAgICAgICAgICAgZnVuY3Rpb24gW1RoZU5hbWVdKGZuKSB7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcXG5cXFxuICAgICAgICAgICAgICAgIFtUaGVQcm9wZXJ0aWVzXSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcXG5cXFxuICAgICAgICAgICAgICAgIHRoaXMuZm4gPSBmbjsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcXG5cXFxuICAgICAgICAgICAgICAgIHRoaXMuYXN5bmNOZWVkZWQgPSB0cnVlOyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcXG5cXFxuICAgICAgICAgICAgICAgIHRoaXMubm93ID0gMDsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcXG5cXFxuICAgICAgICAgICAgfSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcXG5cXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcXG5cXFxuICAgICAgICAgICAgW1RoZU5hbWVdLnByb3RvdHlwZS5fY2FsbEZ1bmN0aW9uID0gZnVuY3Rpb24ocHJvbWlzZSkgeyAgICAgICAgICBcXG5cXFxuICAgICAgICAgICAgICAgIHByb21pc2UuX3B1c2hDb250ZXh0KCk7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcXG5cXFxuICAgICAgICAgICAgICAgIHZhciByZXQgPSB0cnlDYXRjaCh0aGlzLmZuKShbVGhlUGFzc2VkQXJndW1lbnRzXSk7ICAgICAgICAgICBcXG5cXFxuICAgICAgICAgICAgICAgIHByb21pc2UuX3BvcENvbnRleHQoKTsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcXG5cXFxuICAgICAgICAgICAgICAgIGlmIChyZXQgPT09IGVycm9yT2JqKSB7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcXG5cXFxuICAgICAgICAgICAgICAgICAgICBwcm9taXNlLl9yZWplY3RDYWxsYmFjayhyZXQuZSwgZmFsc2UpOyAgICAgICAgICAgICAgICAgICBcXG5cXFxuICAgICAgICAgICAgICAgIH0gZWxzZSB7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcXG5cXFxuICAgICAgICAgICAgICAgICAgICBwcm9taXNlLl9yZXNvbHZlQ2FsbGJhY2socmV0KTsgICAgICAgICAgICAgICAgICAgICAgICAgICBcXG5cXFxuICAgICAgICAgICAgICAgIH0gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcXG5cXFxuICAgICAgICAgICAgfTsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcXG5cXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcXG5cXFxuICAgICAgICAgICAgW1RoZU5hbWVdLnByb3RvdHlwZS5jaGVja0Z1bGZpbGxtZW50ID0gZnVuY3Rpb24ocHJvbWlzZSkgeyAgICAgICBcXG5cXFxuICAgICAgICAgICAgICAgIHZhciBub3cgPSArK3RoaXMubm93OyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcXG5cXFxuICAgICAgICAgICAgICAgIGlmIChub3cgPT09IFtUaGVUb3RhbF0pIHsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcXG5cXFxuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5hc3luY05lZWRlZCkgeyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcXG5cXFxuICAgICAgICAgICAgICAgICAgICAgICAgYXN5bmMuaW52b2tlKHRoaXMuX2NhbGxGdW5jdGlvbiwgdGhpcywgcHJvbWlzZSk7ICAgICBcXG5cXFxuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgeyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcXG5cXFxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fY2FsbEZ1bmN0aW9uKHByb21pc2UpOyAgICAgICAgICAgICAgICAgICAgICAgICBcXG5cXFxuICAgICAgICAgICAgICAgICAgICB9ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcXG5cXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcXG5cXFxuICAgICAgICAgICAgICAgIH0gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcXG5cXFxuICAgICAgICAgICAgfTsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcXG5cXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcXG5cXFxuICAgICAgICAgICAgW1RoZU5hbWVdLnByb3RvdHlwZS5fcmVzdWx0Q2FuY2VsbGVkID0gZnVuY3Rpb24oKSB7ICAgICAgICAgICAgICBcXG5cXFxuICAgICAgICAgICAgICAgIFtDYW5jZWxsYXRpb25Db2RlXSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcXG5cXFxuICAgICAgICAgICAgfTsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcXG5cXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcXG5cXFxuICAgICAgICAgICAgcmV0dXJuIFtUaGVOYW1lXTsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcXG5cXFxuICAgICAgICB9KHRyeUNhdGNoLCBlcnJvck9iaiwgUHJvbWlzZSwgYXN5bmMpOyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcXG5cXFxuICAgICAgICBcIjtcblxuICAgICAgICBjb2RlID0gY29kZS5yZXBsYWNlKC9cXFtUaGVOYW1lXFxdL2csIG5hbWUpXG4gICAgICAgICAgICAucmVwbGFjZSgvXFxbVGhlVG90YWxcXF0vZywgdG90YWwpXG4gICAgICAgICAgICAucmVwbGFjZSgvXFxbVGhlUGFzc2VkQXJndW1lbnRzXFxdL2csIHBhc3NlZEFyZ3VtZW50cylcbiAgICAgICAgICAgIC5yZXBsYWNlKC9cXFtUaGVQcm9wZXJ0aWVzXFxdL2csIGFzc2lnbm1lbnQpXG4gICAgICAgICAgICAucmVwbGFjZSgvXFxbQ2FuY2VsbGF0aW9uQ29kZVxcXS9nLCBjYW5jZWxsYXRpb25Db2RlKTtcblxuICAgICAgICByZXR1cm4gbmV3IEZ1bmN0aW9uKFwidHJ5Q2F0Y2hcIiwgXCJlcnJvck9ialwiLCBcIlByb21pc2VcIiwgXCJhc3luY1wiLCBjb2RlKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgKHRyeUNhdGNoLCBlcnJvck9iaiwgUHJvbWlzZSwgYXN5bmMpO1xuICAgIH07XG5cbiAgICB2YXIgaG9sZGVyQ2xhc3NlcyA9IFtdO1xuICAgIHZhciB0aGVuQ2FsbGJhY2tzID0gW107XG4gICAgdmFyIHByb21pc2VTZXR0ZXJzID0gW107XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IDg7ICsraSkge1xuICAgICAgICBob2xkZXJDbGFzc2VzLnB1c2goZ2VuZXJhdGVIb2xkZXJDbGFzcyhpICsgMSkpO1xuICAgICAgICB0aGVuQ2FsbGJhY2tzLnB1c2godGhlbkNhbGxiYWNrKGkgKyAxKSk7XG4gICAgICAgIHByb21pc2VTZXR0ZXJzLnB1c2gocHJvbWlzZVNldHRlcihpICsgMSkpO1xuICAgIH1cblxuICAgIHJlamVjdCA9IGZ1bmN0aW9uIChyZWFzb24pIHtcbiAgICAgICAgdGhpcy5fcmVqZWN0KHJlYXNvbik7XG4gICAgfTtcbn19XG5cblByb21pc2Uuam9pbiA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgbGFzdCA9IGFyZ3VtZW50cy5sZW5ndGggLSAxO1xuICAgIHZhciBmbjtcbiAgICBpZiAobGFzdCA+IDAgJiYgdHlwZW9mIGFyZ3VtZW50c1tsYXN0XSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIGZuID0gYXJndW1lbnRzW2xhc3RdO1xuICAgICAgICBpZiAoIWZhbHNlKSB7XG4gICAgICAgICAgICBpZiAobGFzdCA8PSA4ICYmIGNhbkV2YWx1YXRlKSB7XG4gICAgICAgICAgICAgICAgdmFyIHJldCA9IG5ldyBQcm9taXNlKElOVEVSTkFMKTtcbiAgICAgICAgICAgICAgICByZXQuX2NhcHR1cmVTdGFja1RyYWNlKCk7XG4gICAgICAgICAgICAgICAgdmFyIEhvbGRlckNsYXNzID0gaG9sZGVyQ2xhc3Nlc1tsYXN0IC0gMV07XG4gICAgICAgICAgICAgICAgdmFyIGhvbGRlciA9IG5ldyBIb2xkZXJDbGFzcyhmbik7XG4gICAgICAgICAgICAgICAgdmFyIGNhbGxiYWNrcyA9IHRoZW5DYWxsYmFja3M7XG5cbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxhc3Q7ICsraSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgbWF5YmVQcm9taXNlID0gdHJ5Q29udmVydFRvUHJvbWlzZShhcmd1bWVudHNbaV0sIHJldCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChtYXliZVByb21pc2UgaW5zdGFuY2VvZiBQcm9taXNlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtYXliZVByb21pc2UgPSBtYXliZVByb21pc2UuX3RhcmdldCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGJpdEZpZWxkID0gbWF5YmVQcm9taXNlLl9iaXRGaWVsZDtcbiAgICAgICAgICAgICAgICAgICAgICAgIDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICgoKGJpdEZpZWxkICYgNTAzOTcxODQpID09PSAwKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1heWJlUHJvbWlzZS5fdGhlbihjYWxsYmFja3NbaV0sIHJlamVjdCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdW5kZWZpbmVkLCByZXQsIGhvbGRlcik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJvbWlzZVNldHRlcnNbaV0obWF5YmVQcm9taXNlLCBob2xkZXIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhvbGRlci5hc3luY05lZWRlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmICgoKGJpdEZpZWxkICYgMzM1NTQ0MzIpICE9PSAwKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrc1tpXS5jYWxsKHJldCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXliZVByb21pc2UuX3ZhbHVlKCksIGhvbGRlcik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKCgoYml0RmllbGQgJiAxNjc3NzIxNikgIT09IDApKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0Ll9yZWplY3QobWF5YmVQcm9taXNlLl9yZWFzb24oKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldC5fY2FuY2VsKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYWxsYmFja3NbaV0uY2FsbChyZXQsIG1heWJlUHJvbWlzZSwgaG9sZGVyKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmICghcmV0Ll9pc0ZhdGVTZWFsZWQoKSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoaG9sZGVyLmFzeW5jTmVlZGVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZG9tYWluID0gZ2V0RG9tYWluKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZG9tYWluICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaG9sZGVyLmZuID0gdXRpbC5kb21haW5CaW5kKGRvbWFpbiwgaG9sZGVyLmZuKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXQuX3NldEFzeW5jR3VhcmFudGVlZCgpO1xuICAgICAgICAgICAgICAgICAgICByZXQuX3NldE9uQ2FuY2VsKGhvbGRlcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiByZXQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgdmFyICRfbGVuID0gYXJndW1lbnRzLmxlbmd0aDt2YXIgYXJncyA9IG5ldyBBcnJheSgkX2xlbik7IGZvcih2YXIgJF9pID0gMDsgJF9pIDwgJF9sZW47ICsrJF9pKSB7YXJnc1skX2ldID0gYXJndW1lbnRzWyRfaV07fTtcbiAgICBpZiAoZm4pIGFyZ3MucG9wKCk7XG4gICAgdmFyIHJldCA9IG5ldyBQcm9taXNlQXJyYXkoYXJncykucHJvbWlzZSgpO1xuICAgIHJldHVybiBmbiAhPT0gdW5kZWZpbmVkID8gcmV0LnNwcmVhZChmbikgOiByZXQ7XG59O1xuXG59O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2JsdWViaXJkL2pzL3JlbGVhc2Uvam9pbi5qcyIsIlwidXNlIHN0cmljdFwiO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihQcm9taXNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICBQcm9taXNlQXJyYXksXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGFwaVJlamVjdGlvbixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgdHJ5Q29udmVydFRvUHJvbWlzZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgSU5URVJOQUwsXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGRlYnVnKSB7XG52YXIgZ2V0RG9tYWluID0gUHJvbWlzZS5fZ2V0RG9tYWluO1xudmFyIHV0aWwgPSByZXF1aXJlKFwiLi91dGlsXCIpO1xudmFyIHRyeUNhdGNoID0gdXRpbC50cnlDYXRjaDtcbnZhciBlcnJvck9iaiA9IHV0aWwuZXJyb3JPYmo7XG52YXIgYXN5bmMgPSBQcm9taXNlLl9hc3luYztcblxuZnVuY3Rpb24gTWFwcGluZ1Byb21pc2VBcnJheShwcm9taXNlcywgZm4sIGxpbWl0LCBfZmlsdGVyKSB7XG4gICAgdGhpcy5jb25zdHJ1Y3RvciQocHJvbWlzZXMpO1xuICAgIHRoaXMuX3Byb21pc2UuX2NhcHR1cmVTdGFja1RyYWNlKCk7XG4gICAgdmFyIGRvbWFpbiA9IGdldERvbWFpbigpO1xuICAgIHRoaXMuX2NhbGxiYWNrID0gZG9tYWluID09PSBudWxsID8gZm4gOiB1dGlsLmRvbWFpbkJpbmQoZG9tYWluLCBmbik7XG4gICAgdGhpcy5fcHJlc2VydmVkVmFsdWVzID0gX2ZpbHRlciA9PT0gSU5URVJOQUxcbiAgICAgICAgPyBuZXcgQXJyYXkodGhpcy5sZW5ndGgoKSlcbiAgICAgICAgOiBudWxsO1xuICAgIHRoaXMuX2xpbWl0ID0gbGltaXQ7XG4gICAgdGhpcy5faW5GbGlnaHQgPSAwO1xuICAgIHRoaXMuX3F1ZXVlID0gW107XG4gICAgYXN5bmMuaW52b2tlKHRoaXMuX2FzeW5jSW5pdCwgdGhpcywgdW5kZWZpbmVkKTtcbn1cbnV0aWwuaW5oZXJpdHMoTWFwcGluZ1Byb21pc2VBcnJheSwgUHJvbWlzZUFycmF5KTtcblxuTWFwcGluZ1Byb21pc2VBcnJheS5wcm90b3R5cGUuX2FzeW5jSW5pdCA9IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuX2luaXQkKHVuZGVmaW5lZCwgLTIpO1xufTtcblxuTWFwcGluZ1Byb21pc2VBcnJheS5wcm90b3R5cGUuX2luaXQgPSBmdW5jdGlvbiAoKSB7fTtcblxuTWFwcGluZ1Byb21pc2VBcnJheS5wcm90b3R5cGUuX3Byb21pc2VGdWxmaWxsZWQgPSBmdW5jdGlvbiAodmFsdWUsIGluZGV4KSB7XG4gICAgdmFyIHZhbHVlcyA9IHRoaXMuX3ZhbHVlcztcbiAgICB2YXIgbGVuZ3RoID0gdGhpcy5sZW5ndGgoKTtcbiAgICB2YXIgcHJlc2VydmVkVmFsdWVzID0gdGhpcy5fcHJlc2VydmVkVmFsdWVzO1xuICAgIHZhciBsaW1pdCA9IHRoaXMuX2xpbWl0O1xuXG4gICAgaWYgKGluZGV4IDwgMCkge1xuICAgICAgICBpbmRleCA9IChpbmRleCAqIC0xKSAtIDE7XG4gICAgICAgIHZhbHVlc1tpbmRleF0gPSB2YWx1ZTtcbiAgICAgICAgaWYgKGxpbWl0ID49IDEpIHtcbiAgICAgICAgICAgIHRoaXMuX2luRmxpZ2h0LS07XG4gICAgICAgICAgICB0aGlzLl9kcmFpblF1ZXVlKCk7XG4gICAgICAgICAgICBpZiAodGhpcy5faXNSZXNvbHZlZCgpKSByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChsaW1pdCA+PSAxICYmIHRoaXMuX2luRmxpZ2h0ID49IGxpbWl0KSB7XG4gICAgICAgICAgICB2YWx1ZXNbaW5kZXhdID0gdmFsdWU7XG4gICAgICAgICAgICB0aGlzLl9xdWV1ZS5wdXNoKGluZGV4KTtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocHJlc2VydmVkVmFsdWVzICE9PSBudWxsKSBwcmVzZXJ2ZWRWYWx1ZXNbaW5kZXhdID0gdmFsdWU7XG5cbiAgICAgICAgdmFyIHByb21pc2UgPSB0aGlzLl9wcm9taXNlO1xuICAgICAgICB2YXIgY2FsbGJhY2sgPSB0aGlzLl9jYWxsYmFjaztcbiAgICAgICAgdmFyIHJlY2VpdmVyID0gcHJvbWlzZS5fYm91bmRWYWx1ZSgpO1xuICAgICAgICBwcm9taXNlLl9wdXNoQ29udGV4dCgpO1xuICAgICAgICB2YXIgcmV0ID0gdHJ5Q2F0Y2goY2FsbGJhY2spLmNhbGwocmVjZWl2ZXIsIHZhbHVlLCBpbmRleCwgbGVuZ3RoKTtcbiAgICAgICAgdmFyIHByb21pc2VDcmVhdGVkID0gcHJvbWlzZS5fcG9wQ29udGV4dCgpO1xuICAgICAgICBkZWJ1Zy5jaGVja0ZvcmdvdHRlblJldHVybnMoXG4gICAgICAgICAgICByZXQsXG4gICAgICAgICAgICBwcm9taXNlQ3JlYXRlZCxcbiAgICAgICAgICAgIHByZXNlcnZlZFZhbHVlcyAhPT0gbnVsbCA/IFwiUHJvbWlzZS5maWx0ZXJcIiA6IFwiUHJvbWlzZS5tYXBcIixcbiAgICAgICAgICAgIHByb21pc2VcbiAgICAgICAgKTtcbiAgICAgICAgaWYgKHJldCA9PT0gZXJyb3JPYmopIHtcbiAgICAgICAgICAgIHRoaXMuX3JlamVjdChyZXQuZSk7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBtYXliZVByb21pc2UgPSB0cnlDb252ZXJ0VG9Qcm9taXNlKHJldCwgdGhpcy5fcHJvbWlzZSk7XG4gICAgICAgIGlmIChtYXliZVByb21pc2UgaW5zdGFuY2VvZiBQcm9taXNlKSB7XG4gICAgICAgICAgICBtYXliZVByb21pc2UgPSBtYXliZVByb21pc2UuX3RhcmdldCgpO1xuICAgICAgICAgICAgdmFyIGJpdEZpZWxkID0gbWF5YmVQcm9taXNlLl9iaXRGaWVsZDtcbiAgICAgICAgICAgIDtcbiAgICAgICAgICAgIGlmICgoKGJpdEZpZWxkICYgNTAzOTcxODQpID09PSAwKSkge1xuICAgICAgICAgICAgICAgIGlmIChsaW1pdCA+PSAxKSB0aGlzLl9pbkZsaWdodCsrO1xuICAgICAgICAgICAgICAgIHZhbHVlc1tpbmRleF0gPSBtYXliZVByb21pc2U7XG4gICAgICAgICAgICAgICAgbWF5YmVQcm9taXNlLl9wcm94eSh0aGlzLCAoaW5kZXggKyAxKSAqIC0xKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKCgoYml0RmllbGQgJiAzMzU1NDQzMikgIT09IDApKSB7XG4gICAgICAgICAgICAgICAgcmV0ID0gbWF5YmVQcm9taXNlLl92YWx1ZSgpO1xuICAgICAgICAgICAgfSBlbHNlIGlmICgoKGJpdEZpZWxkICYgMTY3NzcyMTYpICE9PSAwKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3JlamVjdChtYXliZVByb21pc2UuX3JlYXNvbigpKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fY2FuY2VsKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdmFsdWVzW2luZGV4XSA9IHJldDtcbiAgICB9XG4gICAgdmFyIHRvdGFsUmVzb2x2ZWQgPSArK3RoaXMuX3RvdGFsUmVzb2x2ZWQ7XG4gICAgaWYgKHRvdGFsUmVzb2x2ZWQgPj0gbGVuZ3RoKSB7XG4gICAgICAgIGlmIChwcmVzZXJ2ZWRWYWx1ZXMgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuX2ZpbHRlcih2YWx1ZXMsIHByZXNlcnZlZFZhbHVlcyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl9yZXNvbHZlKHZhbHVlcyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn07XG5cbk1hcHBpbmdQcm9taXNlQXJyYXkucHJvdG90eXBlLl9kcmFpblF1ZXVlID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBxdWV1ZSA9IHRoaXMuX3F1ZXVlO1xuICAgIHZhciBsaW1pdCA9IHRoaXMuX2xpbWl0O1xuICAgIHZhciB2YWx1ZXMgPSB0aGlzLl92YWx1ZXM7XG4gICAgd2hpbGUgKHF1ZXVlLmxlbmd0aCA+IDAgJiYgdGhpcy5faW5GbGlnaHQgPCBsaW1pdCkge1xuICAgICAgICBpZiAodGhpcy5faXNSZXNvbHZlZCgpKSByZXR1cm47XG4gICAgICAgIHZhciBpbmRleCA9IHF1ZXVlLnBvcCgpO1xuICAgICAgICB0aGlzLl9wcm9taXNlRnVsZmlsbGVkKHZhbHVlc1tpbmRleF0sIGluZGV4KTtcbiAgICB9XG59O1xuXG5NYXBwaW5nUHJvbWlzZUFycmF5LnByb3RvdHlwZS5fZmlsdGVyID0gZnVuY3Rpb24gKGJvb2xlYW5zLCB2YWx1ZXMpIHtcbiAgICB2YXIgbGVuID0gdmFsdWVzLmxlbmd0aDtcbiAgICB2YXIgcmV0ID0gbmV3IEFycmF5KGxlbik7XG4gICAgdmFyIGogPSAwO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyArK2kpIHtcbiAgICAgICAgaWYgKGJvb2xlYW5zW2ldKSByZXRbaisrXSA9IHZhbHVlc1tpXTtcbiAgICB9XG4gICAgcmV0Lmxlbmd0aCA9IGo7XG4gICAgdGhpcy5fcmVzb2x2ZShyZXQpO1xufTtcblxuTWFwcGluZ1Byb21pc2VBcnJheS5wcm90b3R5cGUucHJlc2VydmVkVmFsdWVzID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLl9wcmVzZXJ2ZWRWYWx1ZXM7XG59O1xuXG5mdW5jdGlvbiBtYXAocHJvbWlzZXMsIGZuLCBvcHRpb25zLCBfZmlsdGVyKSB7XG4gICAgaWYgKHR5cGVvZiBmbiAhPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIHJldHVybiBhcGlSZWplY3Rpb24oXCJleHBlY3RpbmcgYSBmdW5jdGlvbiBidXQgZ290IFwiICsgdXRpbC5jbGFzc1N0cmluZyhmbikpO1xuICAgIH1cblxuICAgIHZhciBsaW1pdCA9IDA7XG4gICAgaWYgKG9wdGlvbnMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBpZiAodHlwZW9mIG9wdGlvbnMgPT09IFwib2JqZWN0XCIgJiYgb3B0aW9ucyAhPT0gbnVsbCkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBvcHRpb25zLmNvbmN1cnJlbmN5ICE9PSBcIm51bWJlclwiKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KFxuICAgICAgICAgICAgICAgICAgICBuZXcgVHlwZUVycm9yKFwiJ2NvbmN1cnJlbmN5JyBtdXN0IGJlIGEgbnVtYmVyIGJ1dCBpdCBpcyBcIiArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB1dGlsLmNsYXNzU3RyaW5nKG9wdGlvbnMuY29uY3VycmVuY3kpKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsaW1pdCA9IG9wdGlvbnMuY29uY3VycmVuY3k7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QobmV3IFR5cGVFcnJvcihcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIm9wdGlvbnMgYXJndW1lbnQgbXVzdCBiZSBhbiBvYmplY3QgYnV0IGl0IGlzIFwiICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdXRpbC5jbGFzc1N0cmluZyhvcHRpb25zKSkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGxpbWl0ID0gdHlwZW9mIGxpbWl0ID09PSBcIm51bWJlclwiICYmXG4gICAgICAgIGlzRmluaXRlKGxpbWl0KSAmJiBsaW1pdCA+PSAxID8gbGltaXQgOiAwO1xuICAgIHJldHVybiBuZXcgTWFwcGluZ1Byb21pc2VBcnJheShwcm9taXNlcywgZm4sIGxpbWl0LCBfZmlsdGVyKS5wcm9taXNlKCk7XG59XG5cblByb21pc2UucHJvdG90eXBlLm1hcCA9IGZ1bmN0aW9uIChmbiwgb3B0aW9ucykge1xuICAgIHJldHVybiBtYXAodGhpcywgZm4sIG9wdGlvbnMsIG51bGwpO1xufTtcblxuUHJvbWlzZS5tYXAgPSBmdW5jdGlvbiAocHJvbWlzZXMsIGZuLCBvcHRpb25zLCBfZmlsdGVyKSB7XG4gICAgcmV0dXJuIG1hcChwcm9taXNlcywgZm4sIG9wdGlvbnMsIF9maWx0ZXIpO1xufTtcblxuXG59O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2JsdWViaXJkL2pzL3JlbGVhc2UvbWFwLmpzIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgY3IgPSBPYmplY3QuY3JlYXRlO1xuaWYgKGNyKSB7XG4gICAgdmFyIGNhbGxlckNhY2hlID0gY3IobnVsbCk7XG4gICAgdmFyIGdldHRlckNhY2hlID0gY3IobnVsbCk7XG4gICAgY2FsbGVyQ2FjaGVbXCIgc2l6ZVwiXSA9IGdldHRlckNhY2hlW1wiIHNpemVcIl0gPSAwO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKFByb21pc2UpIHtcbnZhciB1dGlsID0gcmVxdWlyZShcIi4vdXRpbFwiKTtcbnZhciBjYW5FdmFsdWF0ZSA9IHV0aWwuY2FuRXZhbHVhdGU7XG52YXIgaXNJZGVudGlmaWVyID0gdXRpbC5pc0lkZW50aWZpZXI7XG5cbnZhciBnZXRNZXRob2RDYWxsZXI7XG52YXIgZ2V0R2V0dGVyO1xuaWYgKCFmYWxzZSkge1xudmFyIG1ha2VNZXRob2RDYWxsZXIgPSBmdW5jdGlvbiAobWV0aG9kTmFtZSkge1xuICAgIHJldHVybiBuZXcgRnVuY3Rpb24oXCJlbnN1cmVNZXRob2RcIiwgXCIgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcXG5cXFxuICAgICAgICByZXR1cm4gZnVuY3Rpb24ob2JqKSB7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcXG5cXFxuICAgICAgICAgICAgJ3VzZSBzdHJpY3QnICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcXG5cXFxuICAgICAgICAgICAgdmFyIGxlbiA9IHRoaXMubGVuZ3RoOyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcXG5cXFxuICAgICAgICAgICAgZW5zdXJlTWV0aG9kKG9iaiwgJ21ldGhvZE5hbWUnKTsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcXG5cXFxuICAgICAgICAgICAgc3dpdGNoKGxlbikgeyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcXG5cXFxuICAgICAgICAgICAgICAgIGNhc2UgMTogcmV0dXJuIG9iai5tZXRob2ROYW1lKHRoaXNbMF0pOyAgICAgICAgICAgICAgICAgICAgICBcXG5cXFxuICAgICAgICAgICAgICAgIGNhc2UgMjogcmV0dXJuIG9iai5tZXRob2ROYW1lKHRoaXNbMF0sIHRoaXNbMV0pOyAgICAgICAgICAgICBcXG5cXFxuICAgICAgICAgICAgICAgIGNhc2UgMzogcmV0dXJuIG9iai5tZXRob2ROYW1lKHRoaXNbMF0sIHRoaXNbMV0sIHRoaXNbMl0pOyAgICBcXG5cXFxuICAgICAgICAgICAgICAgIGNhc2UgMDogcmV0dXJuIG9iai5tZXRob2ROYW1lKCk7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcXG5cXFxuICAgICAgICAgICAgICAgIGRlZmF1bHQ6ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcXG5cXFxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gb2JqLm1ldGhvZE5hbWUuYXBwbHkob2JqLCB0aGlzKTsgICAgICAgICAgICAgICAgICBcXG5cXFxuICAgICAgICAgICAgfSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcXG5cXFxuICAgICAgICB9OyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcXG5cXFxuICAgICAgICBcIi5yZXBsYWNlKC9tZXRob2ROYW1lL2csIG1ldGhvZE5hbWUpKShlbnN1cmVNZXRob2QpO1xufTtcblxudmFyIG1ha2VHZXR0ZXIgPSBmdW5jdGlvbiAocHJvcGVydHlOYW1lKSB7XG4gICAgcmV0dXJuIG5ldyBGdW5jdGlvbihcIm9ialwiLCBcIiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxcblxcXG4gICAgICAgICd1c2Ugc3RyaWN0JzsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxcblxcXG4gICAgICAgIHJldHVybiBvYmoucHJvcGVydHlOYW1lOyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxcblxcXG4gICAgICAgIFwiLnJlcGxhY2UoXCJwcm9wZXJ0eU5hbWVcIiwgcHJvcGVydHlOYW1lKSk7XG59O1xuXG52YXIgZ2V0Q29tcGlsZWQgPSBmdW5jdGlvbihuYW1lLCBjb21waWxlciwgY2FjaGUpIHtcbiAgICB2YXIgcmV0ID0gY2FjaGVbbmFtZV07XG4gICAgaWYgKHR5cGVvZiByZXQgIT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICBpZiAoIWlzSWRlbnRpZmllcihuYW1lKSkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0ID0gY29tcGlsZXIobmFtZSk7XG4gICAgICAgIGNhY2hlW25hbWVdID0gcmV0O1xuICAgICAgICBjYWNoZVtcIiBzaXplXCJdKys7XG4gICAgICAgIGlmIChjYWNoZVtcIiBzaXplXCJdID4gNTEyKSB7XG4gICAgICAgICAgICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKGNhY2hlKTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgMjU2OyArK2kpIGRlbGV0ZSBjYWNoZVtrZXlzW2ldXTtcbiAgICAgICAgICAgIGNhY2hlW1wiIHNpemVcIl0gPSBrZXlzLmxlbmd0aCAtIDI1NjtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmV0O1xufTtcblxuZ2V0TWV0aG9kQ2FsbGVyID0gZnVuY3Rpb24obmFtZSkge1xuICAgIHJldHVybiBnZXRDb21waWxlZChuYW1lLCBtYWtlTWV0aG9kQ2FsbGVyLCBjYWxsZXJDYWNoZSk7XG59O1xuXG5nZXRHZXR0ZXIgPSBmdW5jdGlvbihuYW1lKSB7XG4gICAgcmV0dXJuIGdldENvbXBpbGVkKG5hbWUsIG1ha2VHZXR0ZXIsIGdldHRlckNhY2hlKTtcbn07XG59XG5cbmZ1bmN0aW9uIGVuc3VyZU1ldGhvZChvYmosIG1ldGhvZE5hbWUpIHtcbiAgICB2YXIgZm47XG4gICAgaWYgKG9iaiAhPSBudWxsKSBmbiA9IG9ialttZXRob2ROYW1lXTtcbiAgICBpZiAodHlwZW9mIGZuICE9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgdmFyIG1lc3NhZ2UgPSBcIk9iamVjdCBcIiArIHV0aWwuY2xhc3NTdHJpbmcob2JqKSArIFwiIGhhcyBubyBtZXRob2QgJ1wiICtcbiAgICAgICAgICAgIHV0aWwudG9TdHJpbmcobWV0aG9kTmFtZSkgKyBcIidcIjtcbiAgICAgICAgdGhyb3cgbmV3IFByb21pc2UuVHlwZUVycm9yKG1lc3NhZ2UpO1xuICAgIH1cbiAgICByZXR1cm4gZm47XG59XG5cbmZ1bmN0aW9uIGNhbGxlcihvYmopIHtcbiAgICB2YXIgbWV0aG9kTmFtZSA9IHRoaXMucG9wKCk7XG4gICAgdmFyIGZuID0gZW5zdXJlTWV0aG9kKG9iaiwgbWV0aG9kTmFtZSk7XG4gICAgcmV0dXJuIGZuLmFwcGx5KG9iaiwgdGhpcyk7XG59XG5Qcm9taXNlLnByb3RvdHlwZS5jYWxsID0gZnVuY3Rpb24gKG1ldGhvZE5hbWUpIHtcbiAgICB2YXIgJF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoO3ZhciBhcmdzID0gbmV3IEFycmF5KE1hdGgubWF4KCRfbGVuIC0gMSwgMCkpOyBmb3IodmFyICRfaSA9IDE7ICRfaSA8ICRfbGVuOyArKyRfaSkge2FyZ3NbJF9pIC0gMV0gPSBhcmd1bWVudHNbJF9pXTt9O1xuICAgIGlmICghZmFsc2UpIHtcbiAgICAgICAgaWYgKGNhbkV2YWx1YXRlKSB7XG4gICAgICAgICAgICB2YXIgbWF5YmVDYWxsZXIgPSBnZXRNZXRob2RDYWxsZXIobWV0aG9kTmFtZSk7XG4gICAgICAgICAgICBpZiAobWF5YmVDYWxsZXIgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fdGhlbihcbiAgICAgICAgICAgICAgICAgICAgbWF5YmVDYWxsZXIsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBhcmdzLCB1bmRlZmluZWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGFyZ3MucHVzaChtZXRob2ROYW1lKTtcbiAgICByZXR1cm4gdGhpcy5fdGhlbihjYWxsZXIsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBhcmdzLCB1bmRlZmluZWQpO1xufTtcblxuZnVuY3Rpb24gbmFtZWRHZXR0ZXIob2JqKSB7XG4gICAgcmV0dXJuIG9ialt0aGlzXTtcbn1cbmZ1bmN0aW9uIGluZGV4ZWRHZXR0ZXIob2JqKSB7XG4gICAgdmFyIGluZGV4ID0gK3RoaXM7XG4gICAgaWYgKGluZGV4IDwgMCkgaW5kZXggPSBNYXRoLm1heCgwLCBpbmRleCArIG9iai5sZW5ndGgpO1xuICAgIHJldHVybiBvYmpbaW5kZXhdO1xufVxuUHJvbWlzZS5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24gKHByb3BlcnR5TmFtZSkge1xuICAgIHZhciBpc0luZGV4ID0gKHR5cGVvZiBwcm9wZXJ0eU5hbWUgPT09IFwibnVtYmVyXCIpO1xuICAgIHZhciBnZXR0ZXI7XG4gICAgaWYgKCFpc0luZGV4KSB7XG4gICAgICAgIGlmIChjYW5FdmFsdWF0ZSkge1xuICAgICAgICAgICAgdmFyIG1heWJlR2V0dGVyID0gZ2V0R2V0dGVyKHByb3BlcnR5TmFtZSk7XG4gICAgICAgICAgICBnZXR0ZXIgPSBtYXliZUdldHRlciAhPT0gbnVsbCA/IG1heWJlR2V0dGVyIDogbmFtZWRHZXR0ZXI7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBnZXR0ZXIgPSBuYW1lZEdldHRlcjtcbiAgICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAgIGdldHRlciA9IGluZGV4ZWRHZXR0ZXI7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl90aGVuKGdldHRlciwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIHByb3BlcnR5TmFtZSwgdW5kZWZpbmVkKTtcbn07XG59O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2JsdWViaXJkL2pzL3JlbGVhc2UvY2FsbF9nZXQuanMiLCJcInVzZSBzdHJpY3RcIjtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKFByb21pc2UsIGFwaVJlamVjdGlvbiwgdHJ5Q29udmVydFRvUHJvbWlzZSxcbiAgICBjcmVhdGVDb250ZXh0LCBJTlRFUk5BTCwgZGVidWcpIHtcbiAgICB2YXIgdXRpbCA9IHJlcXVpcmUoXCIuL3V0aWxcIik7XG4gICAgdmFyIFR5cGVFcnJvciA9IHJlcXVpcmUoXCIuL2Vycm9yc1wiKS5UeXBlRXJyb3I7XG4gICAgdmFyIGluaGVyaXRzID0gcmVxdWlyZShcIi4vdXRpbFwiKS5pbmhlcml0cztcbiAgICB2YXIgZXJyb3JPYmogPSB1dGlsLmVycm9yT2JqO1xuICAgIHZhciB0cnlDYXRjaCA9IHV0aWwudHJ5Q2F0Y2g7XG4gICAgdmFyIE5VTEwgPSB7fTtcblxuICAgIGZ1bmN0aW9uIHRocm93ZXIoZSkge1xuICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7dGhyb3cgZTt9LCAwKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjYXN0UHJlc2VydmluZ0Rpc3Bvc2FibGUodGhlbmFibGUpIHtcbiAgICAgICAgdmFyIG1heWJlUHJvbWlzZSA9IHRyeUNvbnZlcnRUb1Byb21pc2UodGhlbmFibGUpO1xuICAgICAgICBpZiAobWF5YmVQcm9taXNlICE9PSB0aGVuYWJsZSAmJlxuICAgICAgICAgICAgdHlwZW9mIHRoZW5hYmxlLl9pc0Rpc3Bvc2FibGUgPT09IFwiZnVuY3Rpb25cIiAmJlxuICAgICAgICAgICAgdHlwZW9mIHRoZW5hYmxlLl9nZXREaXNwb3NlciA9PT0gXCJmdW5jdGlvblwiICYmXG4gICAgICAgICAgICB0aGVuYWJsZS5faXNEaXNwb3NhYmxlKCkpIHtcbiAgICAgICAgICAgIG1heWJlUHJvbWlzZS5fc2V0RGlzcG9zYWJsZSh0aGVuYWJsZS5fZ2V0RGlzcG9zZXIoKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1heWJlUHJvbWlzZTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZGlzcG9zZShyZXNvdXJjZXMsIGluc3BlY3Rpb24pIHtcbiAgICAgICAgdmFyIGkgPSAwO1xuICAgICAgICB2YXIgbGVuID0gcmVzb3VyY2VzLmxlbmd0aDtcbiAgICAgICAgdmFyIHJldCA9IG5ldyBQcm9taXNlKElOVEVSTkFMKTtcbiAgICAgICAgZnVuY3Rpb24gaXRlcmF0b3IoKSB7XG4gICAgICAgICAgICBpZiAoaSA+PSBsZW4pIHJldHVybiByZXQuX2Z1bGZpbGwoKTtcbiAgICAgICAgICAgIHZhciBtYXliZVByb21pc2UgPSBjYXN0UHJlc2VydmluZ0Rpc3Bvc2FibGUocmVzb3VyY2VzW2krK10pO1xuICAgICAgICAgICAgaWYgKG1heWJlUHJvbWlzZSBpbnN0YW5jZW9mIFByb21pc2UgJiZcbiAgICAgICAgICAgICAgICBtYXliZVByb21pc2UuX2lzRGlzcG9zYWJsZSgpKSB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgbWF5YmVQcm9taXNlID0gdHJ5Q29udmVydFRvUHJvbWlzZShcbiAgICAgICAgICAgICAgICAgICAgICAgIG1heWJlUHJvbWlzZS5fZ2V0RGlzcG9zZXIoKS50cnlEaXNwb3NlKGluc3BlY3Rpb24pLFxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzb3VyY2VzLnByb21pc2UpO1xuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRocm93ZXIoZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChtYXliZVByb21pc2UgaW5zdGFuY2VvZiBQcm9taXNlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBtYXliZVByb21pc2UuX3RoZW4oaXRlcmF0b3IsIHRocm93ZXIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbnVsbCwgbnVsbCwgbnVsbCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaXRlcmF0b3IoKTtcbiAgICAgICAgfVxuICAgICAgICBpdGVyYXRvcigpO1xuICAgICAgICByZXR1cm4gcmV0O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIERpc3Bvc2VyKGRhdGEsIHByb21pc2UsIGNvbnRleHQpIHtcbiAgICAgICAgdGhpcy5fZGF0YSA9IGRhdGE7XG4gICAgICAgIHRoaXMuX3Byb21pc2UgPSBwcm9taXNlO1xuICAgICAgICB0aGlzLl9jb250ZXh0ID0gY29udGV4dDtcbiAgICB9XG5cbiAgICBEaXNwb3Nlci5wcm90b3R5cGUuZGF0YSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2RhdGE7XG4gICAgfTtcblxuICAgIERpc3Bvc2VyLnByb3RvdHlwZS5wcm9taXNlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcHJvbWlzZTtcbiAgICB9O1xuXG4gICAgRGlzcG9zZXIucHJvdG90eXBlLnJlc291cmNlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5wcm9taXNlKCkuaXNGdWxmaWxsZWQoKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucHJvbWlzZSgpLnZhbHVlKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIE5VTEw7XG4gICAgfTtcblxuICAgIERpc3Bvc2VyLnByb3RvdHlwZS50cnlEaXNwb3NlID0gZnVuY3Rpb24oaW5zcGVjdGlvbikge1xuICAgICAgICB2YXIgcmVzb3VyY2UgPSB0aGlzLnJlc291cmNlKCk7XG4gICAgICAgIHZhciBjb250ZXh0ID0gdGhpcy5fY29udGV4dDtcbiAgICAgICAgaWYgKGNvbnRleHQgIT09IHVuZGVmaW5lZCkgY29udGV4dC5fcHVzaENvbnRleHQoKTtcbiAgICAgICAgdmFyIHJldCA9IHJlc291cmNlICE9PSBOVUxMXG4gICAgICAgICAgICA/IHRoaXMuZG9EaXNwb3NlKHJlc291cmNlLCBpbnNwZWN0aW9uKSA6IG51bGw7XG4gICAgICAgIGlmIChjb250ZXh0ICE9PSB1bmRlZmluZWQpIGNvbnRleHQuX3BvcENvbnRleHQoKTtcbiAgICAgICAgdGhpcy5fcHJvbWlzZS5fdW5zZXREaXNwb3NhYmxlKCk7XG4gICAgICAgIHRoaXMuX2RhdGEgPSBudWxsO1xuICAgICAgICByZXR1cm4gcmV0O1xuICAgIH07XG5cbiAgICBEaXNwb3Nlci5pc0Rpc3Bvc2VyID0gZnVuY3Rpb24gKGQpIHtcbiAgICAgICAgcmV0dXJuIChkICE9IG51bGwgJiZcbiAgICAgICAgICAgICAgICB0eXBlb2YgZC5yZXNvdXJjZSA9PT0gXCJmdW5jdGlvblwiICYmXG4gICAgICAgICAgICAgICAgdHlwZW9mIGQudHJ5RGlzcG9zZSA9PT0gXCJmdW5jdGlvblwiKTtcbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gRnVuY3Rpb25EaXNwb3NlcihmbiwgcHJvbWlzZSwgY29udGV4dCkge1xuICAgICAgICB0aGlzLmNvbnN0cnVjdG9yJChmbiwgcHJvbWlzZSwgY29udGV4dCk7XG4gICAgfVxuICAgIGluaGVyaXRzKEZ1bmN0aW9uRGlzcG9zZXIsIERpc3Bvc2VyKTtcblxuICAgIEZ1bmN0aW9uRGlzcG9zZXIucHJvdG90eXBlLmRvRGlzcG9zZSA9IGZ1bmN0aW9uIChyZXNvdXJjZSwgaW5zcGVjdGlvbikge1xuICAgICAgICB2YXIgZm4gPSB0aGlzLmRhdGEoKTtcbiAgICAgICAgcmV0dXJuIGZuLmNhbGwocmVzb3VyY2UsIHJlc291cmNlLCBpbnNwZWN0aW9uKTtcbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gbWF5YmVVbndyYXBEaXNwb3Nlcih2YWx1ZSkge1xuICAgICAgICBpZiAoRGlzcG9zZXIuaXNEaXNwb3Nlcih2YWx1ZSkpIHtcbiAgICAgICAgICAgIHRoaXMucmVzb3VyY2VzW3RoaXMuaW5kZXhdLl9zZXREaXNwb3NhYmxlKHZhbHVlKTtcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZS5wcm9taXNlKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIFJlc291cmNlTGlzdChsZW5ndGgpIHtcbiAgICAgICAgdGhpcy5sZW5ndGggPSBsZW5ndGg7XG4gICAgICAgIHRoaXMucHJvbWlzZSA9IG51bGw7XG4gICAgICAgIHRoaXNbbGVuZ3RoLTFdID0gbnVsbDtcbiAgICB9XG5cbiAgICBSZXNvdXJjZUxpc3QucHJvdG90eXBlLl9yZXN1bHRDYW5jZWxsZWQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGxlbiA9IHRoaXMubGVuZ3RoO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgKytpKSB7XG4gICAgICAgICAgICB2YXIgaXRlbSA9IHRoaXNbaV07XG4gICAgICAgICAgICBpZiAoaXRlbSBpbnN0YW5jZW9mIFByb21pc2UpIHtcbiAgICAgICAgICAgICAgICBpdGVtLmNhbmNlbCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcblxuICAgIFByb21pc2UudXNpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBsZW4gPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgICAgICBpZiAobGVuIDwgMikgcmV0dXJuIGFwaVJlamVjdGlvbihcbiAgICAgICAgICAgICAgICAgICAgICAgIFwieW91IG11c3QgcGFzcyBhdCBsZWFzdCAyIGFyZ3VtZW50cyB0byBQcm9taXNlLnVzaW5nXCIpO1xuICAgICAgICB2YXIgZm4gPSBhcmd1bWVudHNbbGVuIC0gMV07XG4gICAgICAgIGlmICh0eXBlb2YgZm4gIT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgcmV0dXJuIGFwaVJlamVjdGlvbihcImV4cGVjdGluZyBhIGZ1bmN0aW9uIGJ1dCBnb3QgXCIgKyB1dGlsLmNsYXNzU3RyaW5nKGZuKSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGlucHV0O1xuICAgICAgICB2YXIgc3ByZWFkQXJncyA9IHRydWU7XG4gICAgICAgIGlmIChsZW4gPT09IDIgJiYgQXJyYXkuaXNBcnJheShhcmd1bWVudHNbMF0pKSB7XG4gICAgICAgICAgICBpbnB1dCA9IGFyZ3VtZW50c1swXTtcbiAgICAgICAgICAgIGxlbiA9IGlucHV0Lmxlbmd0aDtcbiAgICAgICAgICAgIHNwcmVhZEFyZ3MgPSBmYWxzZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlucHV0ID0gYXJndW1lbnRzO1xuICAgICAgICAgICAgbGVuLS07XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHJlc291cmNlcyA9IG5ldyBSZXNvdXJjZUxpc3QobGVuKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47ICsraSkge1xuICAgICAgICAgICAgdmFyIHJlc291cmNlID0gaW5wdXRbaV07XG4gICAgICAgICAgICBpZiAoRGlzcG9zZXIuaXNEaXNwb3NlcihyZXNvdXJjZSkpIHtcbiAgICAgICAgICAgICAgICB2YXIgZGlzcG9zZXIgPSByZXNvdXJjZTtcbiAgICAgICAgICAgICAgICByZXNvdXJjZSA9IHJlc291cmNlLnByb21pc2UoKTtcbiAgICAgICAgICAgICAgICByZXNvdXJjZS5fc2V0RGlzcG9zYWJsZShkaXNwb3Nlcik7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHZhciBtYXliZVByb21pc2UgPSB0cnlDb252ZXJ0VG9Qcm9taXNlKHJlc291cmNlKTtcbiAgICAgICAgICAgICAgICBpZiAobWF5YmVQcm9taXNlIGluc3RhbmNlb2YgUHJvbWlzZSkge1xuICAgICAgICAgICAgICAgICAgICByZXNvdXJjZSA9XG4gICAgICAgICAgICAgICAgICAgICAgICBtYXliZVByb21pc2UuX3RoZW4obWF5YmVVbndyYXBEaXNwb3NlciwgbnVsbCwgbnVsbCwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc291cmNlczogcmVzb3VyY2VzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluZGV4OiBpXG4gICAgICAgICAgICAgICAgICAgIH0sIHVuZGVmaW5lZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVzb3VyY2VzW2ldID0gcmVzb3VyY2U7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgcmVmbGVjdGVkUmVzb3VyY2VzID0gbmV3IEFycmF5KHJlc291cmNlcy5sZW5ndGgpO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHJlZmxlY3RlZFJlc291cmNlcy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgcmVmbGVjdGVkUmVzb3VyY2VzW2ldID0gUHJvbWlzZS5yZXNvbHZlKHJlc291cmNlc1tpXSkucmVmbGVjdCgpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHJlc3VsdFByb21pc2UgPSBQcm9taXNlLmFsbChyZWZsZWN0ZWRSZXNvdXJjZXMpXG4gICAgICAgICAgICAudGhlbihmdW5jdGlvbihpbnNwZWN0aW9ucykge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaW5zcGVjdGlvbnMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGluc3BlY3Rpb24gPSBpbnNwZWN0aW9uc1tpXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGluc3BlY3Rpb24uaXNSZWplY3RlZCgpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBlcnJvck9iai5lID0gaW5zcGVjdGlvbi5lcnJvcigpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGVycm9yT2JqO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKCFpbnNwZWN0aW9uLmlzRnVsZmlsbGVkKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdFByb21pc2UuY2FuY2VsKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaW5zcGVjdGlvbnNbaV0gPSBpbnNwZWN0aW9uLnZhbHVlKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHByb21pc2UuX3B1c2hDb250ZXh0KCk7XG5cbiAgICAgICAgICAgICAgICBmbiA9IHRyeUNhdGNoKGZuKTtcbiAgICAgICAgICAgICAgICB2YXIgcmV0ID0gc3ByZWFkQXJnc1xuICAgICAgICAgICAgICAgICAgICA/IGZuLmFwcGx5KHVuZGVmaW5lZCwgaW5zcGVjdGlvbnMpIDogZm4oaW5zcGVjdGlvbnMpO1xuICAgICAgICAgICAgICAgIHZhciBwcm9taXNlQ3JlYXRlZCA9IHByb21pc2UuX3BvcENvbnRleHQoKTtcbiAgICAgICAgICAgICAgICBkZWJ1Zy5jaGVja0ZvcmdvdHRlblJldHVybnMoXG4gICAgICAgICAgICAgICAgICAgIHJldCwgcHJvbWlzZUNyZWF0ZWQsIFwiUHJvbWlzZS51c2luZ1wiLCBwcm9taXNlKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmV0O1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgdmFyIHByb21pc2UgPSByZXN1bHRQcm9taXNlLmxhc3RseShmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciBpbnNwZWN0aW9uID0gbmV3IFByb21pc2UuUHJvbWlzZUluc3BlY3Rpb24ocmVzdWx0UHJvbWlzZSk7XG4gICAgICAgICAgICByZXR1cm4gZGlzcG9zZShyZXNvdXJjZXMsIGluc3BlY3Rpb24pO1xuICAgICAgICB9KTtcbiAgICAgICAgcmVzb3VyY2VzLnByb21pc2UgPSBwcm9taXNlO1xuICAgICAgICBwcm9taXNlLl9zZXRPbkNhbmNlbChyZXNvdXJjZXMpO1xuICAgICAgICByZXR1cm4gcHJvbWlzZTtcbiAgICB9O1xuXG4gICAgUHJvbWlzZS5wcm90b3R5cGUuX3NldERpc3Bvc2FibGUgPSBmdW5jdGlvbiAoZGlzcG9zZXIpIHtcbiAgICAgICAgdGhpcy5fYml0RmllbGQgPSB0aGlzLl9iaXRGaWVsZCB8IDEzMTA3MjtcbiAgICAgICAgdGhpcy5fZGlzcG9zZXIgPSBkaXNwb3NlcjtcbiAgICB9O1xuXG4gICAgUHJvbWlzZS5wcm90b3R5cGUuX2lzRGlzcG9zYWJsZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuICh0aGlzLl9iaXRGaWVsZCAmIDEzMTA3MikgPiAwO1xuICAgIH07XG5cbiAgICBQcm9taXNlLnByb3RvdHlwZS5fZ2V0RGlzcG9zZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9kaXNwb3NlcjtcbiAgICB9O1xuXG4gICAgUHJvbWlzZS5wcm90b3R5cGUuX3Vuc2V0RGlzcG9zYWJsZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5fYml0RmllbGQgPSB0aGlzLl9iaXRGaWVsZCAmICh+MTMxMDcyKTtcbiAgICAgICAgdGhpcy5fZGlzcG9zZXIgPSB1bmRlZmluZWQ7XG4gICAgfTtcblxuICAgIFByb21pc2UucHJvdG90eXBlLmRpc3Bvc2VyID0gZnVuY3Rpb24gKGZuKSB7XG4gICAgICAgIGlmICh0eXBlb2YgZm4gPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBGdW5jdGlvbkRpc3Bvc2VyKGZuLCB0aGlzLCBjcmVhdGVDb250ZXh0KCkpO1xuICAgICAgICB9XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoKTtcbiAgICB9O1xuXG59O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2JsdWViaXJkL2pzL3JlbGVhc2UvdXNpbmcuanMiLCJcInVzZSBzdHJpY3RcIjtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oUHJvbWlzZSwgSU5URVJOQUwsIGRlYnVnKSB7XG52YXIgdXRpbCA9IHJlcXVpcmUoXCIuL3V0aWxcIik7XG52YXIgVGltZW91dEVycm9yID0gUHJvbWlzZS5UaW1lb3V0RXJyb3I7XG5cbmZ1bmN0aW9uIEhhbmRsZVdyYXBwZXIoaGFuZGxlKSAge1xuICAgIHRoaXMuaGFuZGxlID0gaGFuZGxlO1xufVxuXG5IYW5kbGVXcmFwcGVyLnByb3RvdHlwZS5fcmVzdWx0Q2FuY2VsbGVkID0gZnVuY3Rpb24oKSB7XG4gICAgY2xlYXJUaW1lb3V0KHRoaXMuaGFuZGxlKTtcbn07XG5cbnZhciBhZnRlclZhbHVlID0gZnVuY3Rpb24odmFsdWUpIHsgcmV0dXJuIGRlbGF5KCt0aGlzKS50aGVuUmV0dXJuKHZhbHVlKTsgfTtcbnZhciBkZWxheSA9IFByb21pc2UuZGVsYXkgPSBmdW5jdGlvbiAobXMsIHZhbHVlKSB7XG4gICAgdmFyIHJldDtcbiAgICB2YXIgaGFuZGxlO1xuICAgIGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldCA9IFByb21pc2UucmVzb2x2ZSh2YWx1ZSlcbiAgICAgICAgICAgICAgICAuX3RoZW4oYWZ0ZXJWYWx1ZSwgbnVsbCwgbnVsbCwgbXMsIHVuZGVmaW5lZCk7XG4gICAgICAgIGlmIChkZWJ1Zy5jYW5jZWxsYXRpb24oKSAmJiB2YWx1ZSBpbnN0YW5jZW9mIFByb21pc2UpIHtcbiAgICAgICAgICAgIHJldC5fc2V0T25DYW5jZWwodmFsdWUpO1xuICAgICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV0ID0gbmV3IFByb21pc2UoSU5URVJOQUwpO1xuICAgICAgICBoYW5kbGUgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkgeyByZXQuX2Z1bGZpbGwoKTsgfSwgK21zKTtcbiAgICAgICAgaWYgKGRlYnVnLmNhbmNlbGxhdGlvbigpKSB7XG4gICAgICAgICAgICByZXQuX3NldE9uQ2FuY2VsKG5ldyBIYW5kbGVXcmFwcGVyKGhhbmRsZSkpO1xuICAgICAgICB9XG4gICAgICAgIHJldC5fY2FwdHVyZVN0YWNrVHJhY2UoKTtcbiAgICB9XG4gICAgcmV0Ll9zZXRBc3luY0d1YXJhbnRlZWQoKTtcbiAgICByZXR1cm4gcmV0O1xufTtcblxuUHJvbWlzZS5wcm90b3R5cGUuZGVsYXkgPSBmdW5jdGlvbiAobXMpIHtcbiAgICByZXR1cm4gZGVsYXkobXMsIHRoaXMpO1xufTtcblxudmFyIGFmdGVyVGltZW91dCA9IGZ1bmN0aW9uIChwcm9taXNlLCBtZXNzYWdlLCBwYXJlbnQpIHtcbiAgICB2YXIgZXJyO1xuICAgIGlmICh0eXBlb2YgbWVzc2FnZSAhPT0gXCJzdHJpbmdcIikge1xuICAgICAgICBpZiAobWVzc2FnZSBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAgICAgICBlcnIgPSBtZXNzYWdlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZXJyID0gbmV3IFRpbWVvdXRFcnJvcihcIm9wZXJhdGlvbiB0aW1lZCBvdXRcIik7XG4gICAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgICBlcnIgPSBuZXcgVGltZW91dEVycm9yKG1lc3NhZ2UpO1xuICAgIH1cbiAgICB1dGlsLm1hcmtBc09yaWdpbmF0aW5nRnJvbVJlamVjdGlvbihlcnIpO1xuICAgIHByb21pc2UuX2F0dGFjaEV4dHJhVHJhY2UoZXJyKTtcbiAgICBwcm9taXNlLl9yZWplY3QoZXJyKTtcblxuICAgIGlmIChwYXJlbnQgIT0gbnVsbCkge1xuICAgICAgICBwYXJlbnQuY2FuY2VsKCk7XG4gICAgfVxufTtcblxuZnVuY3Rpb24gc3VjY2Vzc0NsZWFyKHZhbHVlKSB7XG4gICAgY2xlYXJUaW1lb3V0KHRoaXMuaGFuZGxlKTtcbiAgICByZXR1cm4gdmFsdWU7XG59XG5cbmZ1bmN0aW9uIGZhaWx1cmVDbGVhcihyZWFzb24pIHtcbiAgICBjbGVhclRpbWVvdXQodGhpcy5oYW5kbGUpO1xuICAgIHRocm93IHJlYXNvbjtcbn1cblxuUHJvbWlzZS5wcm90b3R5cGUudGltZW91dCA9IGZ1bmN0aW9uIChtcywgbWVzc2FnZSkge1xuICAgIG1zID0gK21zO1xuICAgIHZhciByZXQsIHBhcmVudDtcblxuICAgIHZhciBoYW5kbGVXcmFwcGVyID0gbmV3IEhhbmRsZVdyYXBwZXIoc2V0VGltZW91dChmdW5jdGlvbiB0aW1lb3V0VGltZW91dCgpIHtcbiAgICAgICAgaWYgKHJldC5pc1BlbmRpbmcoKSkge1xuICAgICAgICAgICAgYWZ0ZXJUaW1lb3V0KHJldCwgbWVzc2FnZSwgcGFyZW50KTtcbiAgICAgICAgfVxuICAgIH0sIG1zKSk7XG5cbiAgICBpZiAoZGVidWcuY2FuY2VsbGF0aW9uKCkpIHtcbiAgICAgICAgcGFyZW50ID0gdGhpcy50aGVuKCk7XG4gICAgICAgIHJldCA9IHBhcmVudC5fdGhlbihzdWNjZXNzQ2xlYXIsIGZhaWx1cmVDbGVhcixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB1bmRlZmluZWQsIGhhbmRsZVdyYXBwZXIsIHVuZGVmaW5lZCk7XG4gICAgICAgIHJldC5fc2V0T25DYW5jZWwoaGFuZGxlV3JhcHBlcik7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV0ID0gdGhpcy5fdGhlbihzdWNjZXNzQ2xlYXIsIGZhaWx1cmVDbGVhcixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB1bmRlZmluZWQsIGhhbmRsZVdyYXBwZXIsIHVuZGVmaW5lZCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJldDtcbn07XG5cbn07XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvYmx1ZWJpcmQvanMvcmVsZWFzZS90aW1lcnMuanMiLCJcInVzZSBzdHJpY3RcIjtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oUHJvbWlzZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgYXBpUmVqZWN0aW9uLFxuICAgICAgICAgICAgICAgICAgICAgICAgICBJTlRFUk5BTCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgdHJ5Q29udmVydFRvUHJvbWlzZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgUHJveHlhYmxlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICBkZWJ1Zykge1xudmFyIGVycm9ycyA9IHJlcXVpcmUoXCIuL2Vycm9yc1wiKTtcbnZhciBUeXBlRXJyb3IgPSBlcnJvcnMuVHlwZUVycm9yO1xudmFyIHV0aWwgPSByZXF1aXJlKFwiLi91dGlsXCIpO1xudmFyIGVycm9yT2JqID0gdXRpbC5lcnJvck9iajtcbnZhciB0cnlDYXRjaCA9IHV0aWwudHJ5Q2F0Y2g7XG52YXIgeWllbGRIYW5kbGVycyA9IFtdO1xuXG5mdW5jdGlvbiBwcm9taXNlRnJvbVlpZWxkSGFuZGxlcih2YWx1ZSwgeWllbGRIYW5kbGVycywgdHJhY2VQYXJlbnQpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHlpZWxkSGFuZGxlcnMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgdHJhY2VQYXJlbnQuX3B1c2hDb250ZXh0KCk7XG4gICAgICAgIHZhciByZXN1bHQgPSB0cnlDYXRjaCh5aWVsZEhhbmRsZXJzW2ldKSh2YWx1ZSk7XG4gICAgICAgIHRyYWNlUGFyZW50Ll9wb3BDb250ZXh0KCk7XG4gICAgICAgIGlmIChyZXN1bHQgPT09IGVycm9yT2JqKSB7XG4gICAgICAgICAgICB0cmFjZVBhcmVudC5fcHVzaENvbnRleHQoKTtcbiAgICAgICAgICAgIHZhciByZXQgPSBQcm9taXNlLnJlamVjdChlcnJvck9iai5lKTtcbiAgICAgICAgICAgIHRyYWNlUGFyZW50Ll9wb3BDb250ZXh0KCk7XG4gICAgICAgICAgICByZXR1cm4gcmV0O1xuICAgICAgICB9XG4gICAgICAgIHZhciBtYXliZVByb21pc2UgPSB0cnlDb252ZXJ0VG9Qcm9taXNlKHJlc3VsdCwgdHJhY2VQYXJlbnQpO1xuICAgICAgICBpZiAobWF5YmVQcm9taXNlIGluc3RhbmNlb2YgUHJvbWlzZSkgcmV0dXJuIG1heWJlUHJvbWlzZTtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG59XG5cbmZ1bmN0aW9uIFByb21pc2VTcGF3bihnZW5lcmF0b3JGdW5jdGlvbiwgcmVjZWl2ZXIsIHlpZWxkSGFuZGxlciwgc3RhY2spIHtcbiAgICBpZiAoZGVidWcuY2FuY2VsbGF0aW9uKCkpIHtcbiAgICAgICAgdmFyIGludGVybmFsID0gbmV3IFByb21pc2UoSU5URVJOQUwpO1xuICAgICAgICB2YXIgX2ZpbmFsbHlQcm9taXNlID0gdGhpcy5fZmluYWxseVByb21pc2UgPSBuZXcgUHJvbWlzZShJTlRFUk5BTCk7XG4gICAgICAgIHRoaXMuX3Byb21pc2UgPSBpbnRlcm5hbC5sYXN0bHkoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gX2ZpbmFsbHlQcm9taXNlO1xuICAgICAgICB9KTtcbiAgICAgICAgaW50ZXJuYWwuX2NhcHR1cmVTdGFja1RyYWNlKCk7XG4gICAgICAgIGludGVybmFsLl9zZXRPbkNhbmNlbCh0aGlzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgcHJvbWlzZSA9IHRoaXMuX3Byb21pc2UgPSBuZXcgUHJvbWlzZShJTlRFUk5BTCk7XG4gICAgICAgIHByb21pc2UuX2NhcHR1cmVTdGFja1RyYWNlKCk7XG4gICAgfVxuICAgIHRoaXMuX3N0YWNrID0gc3RhY2s7XG4gICAgdGhpcy5fZ2VuZXJhdG9yRnVuY3Rpb24gPSBnZW5lcmF0b3JGdW5jdGlvbjtcbiAgICB0aGlzLl9yZWNlaXZlciA9IHJlY2VpdmVyO1xuICAgIHRoaXMuX2dlbmVyYXRvciA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLl95aWVsZEhhbmRsZXJzID0gdHlwZW9mIHlpZWxkSGFuZGxlciA9PT0gXCJmdW5jdGlvblwiXG4gICAgICAgID8gW3lpZWxkSGFuZGxlcl0uY29uY2F0KHlpZWxkSGFuZGxlcnMpXG4gICAgICAgIDogeWllbGRIYW5kbGVycztcbiAgICB0aGlzLl95aWVsZGVkUHJvbWlzZSA9IG51bGw7XG4gICAgdGhpcy5fY2FuY2VsbGF0aW9uUGhhc2UgPSBmYWxzZTtcbn1cbnV0aWwuaW5oZXJpdHMoUHJvbWlzZVNwYXduLCBQcm94eWFibGUpO1xuXG5Qcm9taXNlU3Bhd24ucHJvdG90eXBlLl9pc1Jlc29sdmVkID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuX3Byb21pc2UgPT09IG51bGw7XG59O1xuXG5Qcm9taXNlU3Bhd24ucHJvdG90eXBlLl9jbGVhbnVwID0gZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5fcHJvbWlzZSA9IHRoaXMuX2dlbmVyYXRvciA9IG51bGw7XG4gICAgaWYgKGRlYnVnLmNhbmNlbGxhdGlvbigpICYmIHRoaXMuX2ZpbmFsbHlQcm9taXNlICE9PSBudWxsKSB7XG4gICAgICAgIHRoaXMuX2ZpbmFsbHlQcm9taXNlLl9mdWxmaWxsKCk7XG4gICAgICAgIHRoaXMuX2ZpbmFsbHlQcm9taXNlID0gbnVsbDtcbiAgICB9XG59O1xuXG5Qcm9taXNlU3Bhd24ucHJvdG90eXBlLl9wcm9taXNlQ2FuY2VsbGVkID0gZnVuY3Rpb24oKSB7XG4gICAgaWYgKHRoaXMuX2lzUmVzb2x2ZWQoKSkgcmV0dXJuO1xuICAgIHZhciBpbXBsZW1lbnRzUmV0dXJuID0gdHlwZW9mIHRoaXMuX2dlbmVyYXRvcltcInJldHVyblwiXSAhPT0gXCJ1bmRlZmluZWRcIjtcblxuICAgIHZhciByZXN1bHQ7XG4gICAgaWYgKCFpbXBsZW1lbnRzUmV0dXJuKSB7XG4gICAgICAgIHZhciByZWFzb24gPSBuZXcgUHJvbWlzZS5DYW5jZWxsYXRpb25FcnJvcihcbiAgICAgICAgICAgIFwiZ2VuZXJhdG9yIC5yZXR1cm4oKSBzZW50aW5lbFwiKTtcbiAgICAgICAgUHJvbWlzZS5jb3JvdXRpbmUucmV0dXJuU2VudGluZWwgPSByZWFzb247XG4gICAgICAgIHRoaXMuX3Byb21pc2UuX2F0dGFjaEV4dHJhVHJhY2UocmVhc29uKTtcbiAgICAgICAgdGhpcy5fcHJvbWlzZS5fcHVzaENvbnRleHQoKTtcbiAgICAgICAgcmVzdWx0ID0gdHJ5Q2F0Y2godGhpcy5fZ2VuZXJhdG9yW1widGhyb3dcIl0pLmNhbGwodGhpcy5fZ2VuZXJhdG9yLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVhc29uKTtcbiAgICAgICAgdGhpcy5fcHJvbWlzZS5fcG9wQ29udGV4dCgpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuX3Byb21pc2UuX3B1c2hDb250ZXh0KCk7XG4gICAgICAgIHJlc3VsdCA9IHRyeUNhdGNoKHRoaXMuX2dlbmVyYXRvcltcInJldHVyblwiXSkuY2FsbCh0aGlzLl9nZW5lcmF0b3IsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdW5kZWZpbmVkKTtcbiAgICAgICAgdGhpcy5fcHJvbWlzZS5fcG9wQ29udGV4dCgpO1xuICAgIH1cbiAgICB0aGlzLl9jYW5jZWxsYXRpb25QaGFzZSA9IHRydWU7XG4gICAgdGhpcy5feWllbGRlZFByb21pc2UgPSBudWxsO1xuICAgIHRoaXMuX2NvbnRpbnVlKHJlc3VsdCk7XG59O1xuXG5Qcm9taXNlU3Bhd24ucHJvdG90eXBlLl9wcm9taXNlRnVsZmlsbGVkID0gZnVuY3Rpb24odmFsdWUpIHtcbiAgICB0aGlzLl95aWVsZGVkUHJvbWlzZSA9IG51bGw7XG4gICAgdGhpcy5fcHJvbWlzZS5fcHVzaENvbnRleHQoKTtcbiAgICB2YXIgcmVzdWx0ID0gdHJ5Q2F0Y2godGhpcy5fZ2VuZXJhdG9yLm5leHQpLmNhbGwodGhpcy5fZ2VuZXJhdG9yLCB2YWx1ZSk7XG4gICAgdGhpcy5fcHJvbWlzZS5fcG9wQ29udGV4dCgpO1xuICAgIHRoaXMuX2NvbnRpbnVlKHJlc3VsdCk7XG59O1xuXG5Qcm9taXNlU3Bhd24ucHJvdG90eXBlLl9wcm9taXNlUmVqZWN0ZWQgPSBmdW5jdGlvbihyZWFzb24pIHtcbiAgICB0aGlzLl95aWVsZGVkUHJvbWlzZSA9IG51bGw7XG4gICAgdGhpcy5fcHJvbWlzZS5fYXR0YWNoRXh0cmFUcmFjZShyZWFzb24pO1xuICAgIHRoaXMuX3Byb21pc2UuX3B1c2hDb250ZXh0KCk7XG4gICAgdmFyIHJlc3VsdCA9IHRyeUNhdGNoKHRoaXMuX2dlbmVyYXRvcltcInRocm93XCJdKVxuICAgICAgICAuY2FsbCh0aGlzLl9nZW5lcmF0b3IsIHJlYXNvbik7XG4gICAgdGhpcy5fcHJvbWlzZS5fcG9wQ29udGV4dCgpO1xuICAgIHRoaXMuX2NvbnRpbnVlKHJlc3VsdCk7XG59O1xuXG5Qcm9taXNlU3Bhd24ucHJvdG90eXBlLl9yZXN1bHRDYW5jZWxsZWQgPSBmdW5jdGlvbigpIHtcbiAgICBpZiAodGhpcy5feWllbGRlZFByb21pc2UgaW5zdGFuY2VvZiBQcm9taXNlKSB7XG4gICAgICAgIHZhciBwcm9taXNlID0gdGhpcy5feWllbGRlZFByb21pc2U7XG4gICAgICAgIHRoaXMuX3lpZWxkZWRQcm9taXNlID0gbnVsbDtcbiAgICAgICAgcHJvbWlzZS5jYW5jZWwoKTtcbiAgICB9XG59O1xuXG5Qcm9taXNlU3Bhd24ucHJvdG90eXBlLnByb21pc2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3Byb21pc2U7XG59O1xuXG5Qcm9taXNlU3Bhd24ucHJvdG90eXBlLl9ydW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5fZ2VuZXJhdG9yID0gdGhpcy5fZ2VuZXJhdG9yRnVuY3Rpb24uY2FsbCh0aGlzLl9yZWNlaXZlcik7XG4gICAgdGhpcy5fcmVjZWl2ZXIgPVxuICAgICAgICB0aGlzLl9nZW5lcmF0b3JGdW5jdGlvbiA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLl9wcm9taXNlRnVsZmlsbGVkKHVuZGVmaW5lZCk7XG59O1xuXG5Qcm9taXNlU3Bhd24ucHJvdG90eXBlLl9jb250aW51ZSA9IGZ1bmN0aW9uIChyZXN1bHQpIHtcbiAgICB2YXIgcHJvbWlzZSA9IHRoaXMuX3Byb21pc2U7XG4gICAgaWYgKHJlc3VsdCA9PT0gZXJyb3JPYmopIHtcbiAgICAgICAgdGhpcy5fY2xlYW51cCgpO1xuICAgICAgICBpZiAodGhpcy5fY2FuY2VsbGF0aW9uUGhhc2UpIHtcbiAgICAgICAgICAgIHJldHVybiBwcm9taXNlLmNhbmNlbCgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHByb21pc2UuX3JlamVjdENhbGxiYWNrKHJlc3VsdC5lLCBmYWxzZSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgdmFsdWUgPSByZXN1bHQudmFsdWU7XG4gICAgaWYgKHJlc3VsdC5kb25lID09PSB0cnVlKSB7XG4gICAgICAgIHRoaXMuX2NsZWFudXAoKTtcbiAgICAgICAgaWYgKHRoaXMuX2NhbmNlbGxhdGlvblBoYXNlKSB7XG4gICAgICAgICAgICByZXR1cm4gcHJvbWlzZS5jYW5jZWwoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBwcm9taXNlLl9yZXNvbHZlQ2FsbGJhY2sodmFsdWUpO1xuICAgICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIG1heWJlUHJvbWlzZSA9IHRyeUNvbnZlcnRUb1Byb21pc2UodmFsdWUsIHRoaXMuX3Byb21pc2UpO1xuICAgICAgICBpZiAoIShtYXliZVByb21pc2UgaW5zdGFuY2VvZiBQcm9taXNlKSkge1xuICAgICAgICAgICAgbWF5YmVQcm9taXNlID1cbiAgICAgICAgICAgICAgICBwcm9taXNlRnJvbVlpZWxkSGFuZGxlcihtYXliZVByb21pc2UsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5feWllbGRIYW5kbGVycyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9wcm9taXNlKTtcbiAgICAgICAgICAgIGlmIChtYXliZVByb21pc2UgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9wcm9taXNlUmVqZWN0ZWQoXG4gICAgICAgICAgICAgICAgICAgIG5ldyBUeXBlRXJyb3IoXG4gICAgICAgICAgICAgICAgICAgICAgICBcIkEgdmFsdWUgJXMgd2FzIHlpZWxkZWQgdGhhdCBjb3VsZCBub3QgYmUgdHJlYXRlZCBhcyBhIHByb21pc2VcXHUwMDBhXFx1MDAwYSAgICBTZWUgaHR0cDovL2dvby5nbC9NcXJGbVhcXHUwMDBhXFx1MDAwYVwiLnJlcGxhY2UoXCIlc1wiLCBTdHJpbmcodmFsdWUpKSArXG4gICAgICAgICAgICAgICAgICAgICAgICBcIkZyb20gY29yb3V0aW5lOlxcdTAwMGFcIiArXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9zdGFjay5zcGxpdChcIlxcblwiKS5zbGljZSgxLCAtNykuam9pbihcIlxcblwiKVxuICAgICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgbWF5YmVQcm9taXNlID0gbWF5YmVQcm9taXNlLl90YXJnZXQoKTtcbiAgICAgICAgdmFyIGJpdEZpZWxkID0gbWF5YmVQcm9taXNlLl9iaXRGaWVsZDtcbiAgICAgICAgO1xuICAgICAgICBpZiAoKChiaXRGaWVsZCAmIDUwMzk3MTg0KSA9PT0gMCkpIHtcbiAgICAgICAgICAgIHRoaXMuX3lpZWxkZWRQcm9taXNlID0gbWF5YmVQcm9taXNlO1xuICAgICAgICAgICAgbWF5YmVQcm9taXNlLl9wcm94eSh0aGlzLCBudWxsKTtcbiAgICAgICAgfSBlbHNlIGlmICgoKGJpdEZpZWxkICYgMzM1NTQ0MzIpICE9PSAwKSkge1xuICAgICAgICAgICAgUHJvbWlzZS5fYXN5bmMuaW52b2tlKFxuICAgICAgICAgICAgICAgIHRoaXMuX3Byb21pc2VGdWxmaWxsZWQsIHRoaXMsIG1heWJlUHJvbWlzZS5fdmFsdWUoKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgfSBlbHNlIGlmICgoKGJpdEZpZWxkICYgMTY3NzcyMTYpICE9PSAwKSkge1xuICAgICAgICAgICAgUHJvbWlzZS5fYXN5bmMuaW52b2tlKFxuICAgICAgICAgICAgICAgIHRoaXMuX3Byb21pc2VSZWplY3RlZCwgdGhpcywgbWF5YmVQcm9taXNlLl9yZWFzb24oKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX3Byb21pc2VDYW5jZWxsZWQoKTtcbiAgICAgICAgfVxuICAgIH1cbn07XG5cblByb21pc2UuY29yb3V0aW5lID0gZnVuY3Rpb24gKGdlbmVyYXRvckZ1bmN0aW9uLCBvcHRpb25zKSB7XG4gICAgaWYgKHR5cGVvZiBnZW5lcmF0b3JGdW5jdGlvbiAhPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJnZW5lcmF0b3JGdW5jdGlvbiBtdXN0IGJlIGEgZnVuY3Rpb25cXHUwMDBhXFx1MDAwYSAgICBTZWUgaHR0cDovL2dvby5nbC9NcXJGbVhcXHUwMDBhXCIpO1xuICAgIH1cbiAgICB2YXIgeWllbGRIYW5kbGVyID0gT2JqZWN0KG9wdGlvbnMpLnlpZWxkSGFuZGxlcjtcbiAgICB2YXIgUHJvbWlzZVNwYXduJCA9IFByb21pc2VTcGF3bjtcbiAgICB2YXIgc3RhY2sgPSBuZXcgRXJyb3IoKS5zdGFjaztcbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgZ2VuZXJhdG9yID0gZ2VuZXJhdG9yRnVuY3Rpb24uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgdmFyIHNwYXduID0gbmV3IFByb21pc2VTcGF3biQodW5kZWZpbmVkLCB1bmRlZmluZWQsIHlpZWxkSGFuZGxlcixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhY2spO1xuICAgICAgICB2YXIgcmV0ID0gc3Bhd24ucHJvbWlzZSgpO1xuICAgICAgICBzcGF3bi5fZ2VuZXJhdG9yID0gZ2VuZXJhdG9yO1xuICAgICAgICBzcGF3bi5fcHJvbWlzZUZ1bGZpbGxlZCh1bmRlZmluZWQpO1xuICAgICAgICByZXR1cm4gcmV0O1xuICAgIH07XG59O1xuXG5Qcm9taXNlLmNvcm91dGluZS5hZGRZaWVsZEhhbmRsZXIgPSBmdW5jdGlvbihmbikge1xuICAgIGlmICh0eXBlb2YgZm4gIT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiZXhwZWN0aW5nIGEgZnVuY3Rpb24gYnV0IGdvdCBcIiArIHV0aWwuY2xhc3NTdHJpbmcoZm4pKTtcbiAgICB9XG4gICAgeWllbGRIYW5kbGVycy5wdXNoKGZuKTtcbn07XG5cblByb21pc2Uuc3Bhd24gPSBmdW5jdGlvbiAoZ2VuZXJhdG9yRnVuY3Rpb24pIHtcbiAgICBkZWJ1Zy5kZXByZWNhdGVkKFwiUHJvbWlzZS5zcGF3bigpXCIsIFwiUHJvbWlzZS5jb3JvdXRpbmUoKVwiKTtcbiAgICBpZiAodHlwZW9mIGdlbmVyYXRvckZ1bmN0aW9uICE9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgcmV0dXJuIGFwaVJlamVjdGlvbihcImdlbmVyYXRvckZ1bmN0aW9uIG11c3QgYmUgYSBmdW5jdGlvblxcdTAwMGFcXHUwMDBhICAgIFNlZSBodHRwOi8vZ29vLmdsL01xckZtWFxcdTAwMGFcIik7XG4gICAgfVxuICAgIHZhciBzcGF3biA9IG5ldyBQcm9taXNlU3Bhd24oZ2VuZXJhdG9yRnVuY3Rpb24sIHRoaXMpO1xuICAgIHZhciByZXQgPSBzcGF3bi5wcm9taXNlKCk7XG4gICAgc3Bhd24uX3J1bihQcm9taXNlLnNwYXduKTtcbiAgICByZXR1cm4gcmV0O1xufTtcbn07XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvYmx1ZWJpcmQvanMvcmVsZWFzZS9nZW5lcmF0b3JzLmpzIiwiXCJ1c2Ugc3RyaWN0XCI7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKFByb21pc2UpIHtcbnZhciB1dGlsID0gcmVxdWlyZShcIi4vdXRpbFwiKTtcbnZhciBhc3luYyA9IFByb21pc2UuX2FzeW5jO1xudmFyIHRyeUNhdGNoID0gdXRpbC50cnlDYXRjaDtcbnZhciBlcnJvck9iaiA9IHV0aWwuZXJyb3JPYmo7XG5cbmZ1bmN0aW9uIHNwcmVhZEFkYXB0ZXIodmFsLCBub2RlYmFjaykge1xuICAgIHZhciBwcm9taXNlID0gdGhpcztcbiAgICBpZiAoIXV0aWwuaXNBcnJheSh2YWwpKSByZXR1cm4gc3VjY2Vzc0FkYXB0ZXIuY2FsbChwcm9taXNlLCB2YWwsIG5vZGViYWNrKTtcbiAgICB2YXIgcmV0ID1cbiAgICAgICAgdHJ5Q2F0Y2gobm9kZWJhY2spLmFwcGx5KHByb21pc2UuX2JvdW5kVmFsdWUoKSwgW251bGxdLmNvbmNhdCh2YWwpKTtcbiAgICBpZiAocmV0ID09PSBlcnJvck9iaikge1xuICAgICAgICBhc3luYy50aHJvd0xhdGVyKHJldC5lKTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIHN1Y2Nlc3NBZGFwdGVyKHZhbCwgbm9kZWJhY2spIHtcbiAgICB2YXIgcHJvbWlzZSA9IHRoaXM7XG4gICAgdmFyIHJlY2VpdmVyID0gcHJvbWlzZS5fYm91bmRWYWx1ZSgpO1xuICAgIHZhciByZXQgPSB2YWwgPT09IHVuZGVmaW5lZFxuICAgICAgICA/IHRyeUNhdGNoKG5vZGViYWNrKS5jYWxsKHJlY2VpdmVyLCBudWxsKVxuICAgICAgICA6IHRyeUNhdGNoKG5vZGViYWNrKS5jYWxsKHJlY2VpdmVyLCBudWxsLCB2YWwpO1xuICAgIGlmIChyZXQgPT09IGVycm9yT2JqKSB7XG4gICAgICAgIGFzeW5jLnRocm93TGF0ZXIocmV0LmUpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGVycm9yQWRhcHRlcihyZWFzb24sIG5vZGViYWNrKSB7XG4gICAgdmFyIHByb21pc2UgPSB0aGlzO1xuICAgIGlmICghcmVhc29uKSB7XG4gICAgICAgIHZhciBuZXdSZWFzb24gPSBuZXcgRXJyb3IocmVhc29uICsgXCJcIik7XG4gICAgICAgIG5ld1JlYXNvbi5jYXVzZSA9IHJlYXNvbjtcbiAgICAgICAgcmVhc29uID0gbmV3UmVhc29uO1xuICAgIH1cbiAgICB2YXIgcmV0ID0gdHJ5Q2F0Y2gobm9kZWJhY2spLmNhbGwocHJvbWlzZS5fYm91bmRWYWx1ZSgpLCByZWFzb24pO1xuICAgIGlmIChyZXQgPT09IGVycm9yT2JqKSB7XG4gICAgICAgIGFzeW5jLnRocm93TGF0ZXIocmV0LmUpO1xuICAgIH1cbn1cblxuUHJvbWlzZS5wcm90b3R5cGUuYXNDYWxsYmFjayA9IFByb21pc2UucHJvdG90eXBlLm5vZGVpZnkgPSBmdW5jdGlvbiAobm9kZWJhY2ssXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25zKSB7XG4gICAgaWYgKHR5cGVvZiBub2RlYmFjayA9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgdmFyIGFkYXB0ZXIgPSBzdWNjZXNzQWRhcHRlcjtcbiAgICAgICAgaWYgKG9wdGlvbnMgIT09IHVuZGVmaW5lZCAmJiBPYmplY3Qob3B0aW9ucykuc3ByZWFkKSB7XG4gICAgICAgICAgICBhZGFwdGVyID0gc3ByZWFkQWRhcHRlcjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl90aGVuKFxuICAgICAgICAgICAgYWRhcHRlcixcbiAgICAgICAgICAgIGVycm9yQWRhcHRlcixcbiAgICAgICAgICAgIHVuZGVmaW5lZCxcbiAgICAgICAgICAgIHRoaXMsXG4gICAgICAgICAgICBub2RlYmFja1xuICAgICAgICApO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbn07XG59O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2JsdWViaXJkL2pzL3JlbGVhc2Uvbm9kZWlmeS5qcyIsIlwidXNlIHN0cmljdFwiO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihQcm9taXNlLCBJTlRFUk5BTCkge1xudmFyIFRISVMgPSB7fTtcbnZhciB1dGlsID0gcmVxdWlyZShcIi4vdXRpbFwiKTtcbnZhciBub2RlYmFja0ZvclByb21pc2UgPSByZXF1aXJlKFwiLi9ub2RlYmFja1wiKTtcbnZhciB3aXRoQXBwZW5kZWQgPSB1dGlsLndpdGhBcHBlbmRlZDtcbnZhciBtYXliZVdyYXBBc0Vycm9yID0gdXRpbC5tYXliZVdyYXBBc0Vycm9yO1xudmFyIGNhbkV2YWx1YXRlID0gdXRpbC5jYW5FdmFsdWF0ZTtcbnZhciBUeXBlRXJyb3IgPSByZXF1aXJlKFwiLi9lcnJvcnNcIikuVHlwZUVycm9yO1xudmFyIGRlZmF1bHRTdWZmaXggPSBcIkFzeW5jXCI7XG52YXIgZGVmYXVsdFByb21pc2lmaWVkID0ge19faXNQcm9taXNpZmllZF9fOiB0cnVlfTtcbnZhciBub0NvcHlQcm9wcyA9IFtcbiAgICBcImFyaXR5XCIsICAgIFwibGVuZ3RoXCIsXG4gICAgXCJuYW1lXCIsXG4gICAgXCJhcmd1bWVudHNcIixcbiAgICBcImNhbGxlclwiLFxuICAgIFwiY2FsbGVlXCIsXG4gICAgXCJwcm90b3R5cGVcIixcbiAgICBcIl9faXNQcm9taXNpZmllZF9fXCJcbl07XG52YXIgbm9Db3B5UHJvcHNQYXR0ZXJuID0gbmV3IFJlZ0V4cChcIl4oPzpcIiArIG5vQ29weVByb3BzLmpvaW4oXCJ8XCIpICsgXCIpJFwiKTtcblxudmFyIGRlZmF1bHRGaWx0ZXIgPSBmdW5jdGlvbihuYW1lKSB7XG4gICAgcmV0dXJuIHV0aWwuaXNJZGVudGlmaWVyKG5hbWUpICYmXG4gICAgICAgIG5hbWUuY2hhckF0KDApICE9PSBcIl9cIiAmJlxuICAgICAgICBuYW1lICE9PSBcImNvbnN0cnVjdG9yXCI7XG59O1xuXG5mdW5jdGlvbiBwcm9wc0ZpbHRlcihrZXkpIHtcbiAgICByZXR1cm4gIW5vQ29weVByb3BzUGF0dGVybi50ZXN0KGtleSk7XG59XG5cbmZ1bmN0aW9uIGlzUHJvbWlzaWZpZWQoZm4pIHtcbiAgICB0cnkge1xuICAgICAgICByZXR1cm4gZm4uX19pc1Byb21pc2lmaWVkX18gPT09IHRydWU7XG4gICAgfVxuICAgIGNhdGNoIChlKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGhhc1Byb21pc2lmaWVkKG9iaiwga2V5LCBzdWZmaXgpIHtcbiAgICB2YXIgdmFsID0gdXRpbC5nZXREYXRhUHJvcGVydHlPckRlZmF1bHQob2JqLCBrZXkgKyBzdWZmaXgsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlZmF1bHRQcm9taXNpZmllZCk7XG4gICAgcmV0dXJuIHZhbCA/IGlzUHJvbWlzaWZpZWQodmFsKSA6IGZhbHNlO1xufVxuZnVuY3Rpb24gY2hlY2tWYWxpZChyZXQsIHN1ZmZpeCwgc3VmZml4UmVnZXhwKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCByZXQubGVuZ3RoOyBpICs9IDIpIHtcbiAgICAgICAgdmFyIGtleSA9IHJldFtpXTtcbiAgICAgICAgaWYgKHN1ZmZpeFJlZ2V4cC50ZXN0KGtleSkpIHtcbiAgICAgICAgICAgIHZhciBrZXlXaXRob3V0QXN5bmNTdWZmaXggPSBrZXkucmVwbGFjZShzdWZmaXhSZWdleHAsIFwiXCIpO1xuICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCByZXQubGVuZ3RoOyBqICs9IDIpIHtcbiAgICAgICAgICAgICAgICBpZiAocmV0W2pdID09PSBrZXlXaXRob3V0QXN5bmNTdWZmaXgpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBwcm9taXNpZnkgYW4gQVBJIHRoYXQgaGFzIG5vcm1hbCBtZXRob2RzIHdpdGggJyVzJy1zdWZmaXhcXHUwMDBhXFx1MDAwYSAgICBTZWUgaHR0cDovL2dvby5nbC9NcXJGbVhcXHUwMDBhXCJcbiAgICAgICAgICAgICAgICAgICAgICAgIC5yZXBsYWNlKFwiJXNcIiwgc3VmZml4KSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufVxuXG5mdW5jdGlvbiBwcm9taXNpZmlhYmxlTWV0aG9kcyhvYmosIHN1ZmZpeCwgc3VmZml4UmVnZXhwLCBmaWx0ZXIpIHtcbiAgICB2YXIga2V5cyA9IHV0aWwuaW5oZXJpdGVkRGF0YUtleXMob2JqKTtcbiAgICB2YXIgcmV0ID0gW107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIHZhciBrZXkgPSBrZXlzW2ldO1xuICAgICAgICB2YXIgdmFsdWUgPSBvYmpba2V5XTtcbiAgICAgICAgdmFyIHBhc3Nlc0RlZmF1bHRGaWx0ZXIgPSBmaWx0ZXIgPT09IGRlZmF1bHRGaWx0ZXJcbiAgICAgICAgICAgID8gdHJ1ZSA6IGRlZmF1bHRGaWx0ZXIoa2V5LCB2YWx1ZSwgb2JqKTtcbiAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJmdW5jdGlvblwiICYmXG4gICAgICAgICAgICAhaXNQcm9taXNpZmllZCh2YWx1ZSkgJiZcbiAgICAgICAgICAgICFoYXNQcm9taXNpZmllZChvYmosIGtleSwgc3VmZml4KSAmJlxuICAgICAgICAgICAgZmlsdGVyKGtleSwgdmFsdWUsIG9iaiwgcGFzc2VzRGVmYXVsdEZpbHRlcikpIHtcbiAgICAgICAgICAgIHJldC5wdXNoKGtleSwgdmFsdWUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNoZWNrVmFsaWQocmV0LCBzdWZmaXgsIHN1ZmZpeFJlZ2V4cCk7XG4gICAgcmV0dXJuIHJldDtcbn1cblxudmFyIGVzY2FwZUlkZW50UmVnZXggPSBmdW5jdGlvbihzdHIpIHtcbiAgICByZXR1cm4gc3RyLnJlcGxhY2UoLyhbJF0pLywgXCJcXFxcJFwiKTtcbn07XG5cbnZhciBtYWtlTm9kZVByb21pc2lmaWVkRXZhbDtcbmlmICghZmFsc2UpIHtcbnZhciBzd2l0Y2hDYXNlQXJndW1lbnRPcmRlciA9IGZ1bmN0aW9uKGxpa2VseUFyZ3VtZW50Q291bnQpIHtcbiAgICB2YXIgcmV0ID0gW2xpa2VseUFyZ3VtZW50Q291bnRdO1xuICAgIHZhciBtaW4gPSBNYXRoLm1heCgwLCBsaWtlbHlBcmd1bWVudENvdW50IC0gMSAtIDMpO1xuICAgIGZvcih2YXIgaSA9IGxpa2VseUFyZ3VtZW50Q291bnQgLSAxOyBpID49IG1pbjsgLS1pKSB7XG4gICAgICAgIHJldC5wdXNoKGkpO1xuICAgIH1cbiAgICBmb3IodmFyIGkgPSBsaWtlbHlBcmd1bWVudENvdW50ICsgMTsgaSA8PSAzOyArK2kpIHtcbiAgICAgICAgcmV0LnB1c2goaSk7XG4gICAgfVxuICAgIHJldHVybiByZXQ7XG59O1xuXG52YXIgYXJndW1lbnRTZXF1ZW5jZSA9IGZ1bmN0aW9uKGFyZ3VtZW50Q291bnQpIHtcbiAgICByZXR1cm4gdXRpbC5maWxsZWRSYW5nZShhcmd1bWVudENvdW50LCBcIl9hcmdcIiwgXCJcIik7XG59O1xuXG52YXIgcGFyYW1ldGVyRGVjbGFyYXRpb24gPSBmdW5jdGlvbihwYXJhbWV0ZXJDb3VudCkge1xuICAgIHJldHVybiB1dGlsLmZpbGxlZFJhbmdlKFxuICAgICAgICBNYXRoLm1heChwYXJhbWV0ZXJDb3VudCwgMyksIFwiX2FyZ1wiLCBcIlwiKTtcbn07XG5cbnZhciBwYXJhbWV0ZXJDb3VudCA9IGZ1bmN0aW9uKGZuKSB7XG4gICAgaWYgKHR5cGVvZiBmbi5sZW5ndGggPT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgcmV0dXJuIE1hdGgubWF4KE1hdGgubWluKGZuLmxlbmd0aCwgMTAyMyArIDEpLCAwKTtcbiAgICB9XG4gICAgcmV0dXJuIDA7XG59O1xuXG5tYWtlTm9kZVByb21pc2lmaWVkRXZhbCA9XG5mdW5jdGlvbihjYWxsYmFjaywgcmVjZWl2ZXIsIG9yaWdpbmFsTmFtZSwgZm4sIF8sIG11bHRpQXJncykge1xuICAgIHZhciBuZXdQYXJhbWV0ZXJDb3VudCA9IE1hdGgubWF4KDAsIHBhcmFtZXRlckNvdW50KGZuKSAtIDEpO1xuICAgIHZhciBhcmd1bWVudE9yZGVyID0gc3dpdGNoQ2FzZUFyZ3VtZW50T3JkZXIobmV3UGFyYW1ldGVyQ291bnQpO1xuICAgIHZhciBzaG91bGRQcm94eVRoaXMgPSB0eXBlb2YgY2FsbGJhY2sgPT09IFwic3RyaW5nXCIgfHwgcmVjZWl2ZXIgPT09IFRISVM7XG5cbiAgICBmdW5jdGlvbiBnZW5lcmF0ZUNhbGxGb3JBcmd1bWVudENvdW50KGNvdW50KSB7XG4gICAgICAgIHZhciBhcmdzID0gYXJndW1lbnRTZXF1ZW5jZShjb3VudCkuam9pbihcIiwgXCIpO1xuICAgICAgICB2YXIgY29tbWEgPSBjb3VudCA+IDAgPyBcIiwgXCIgOiBcIlwiO1xuICAgICAgICB2YXIgcmV0O1xuICAgICAgICBpZiAoc2hvdWxkUHJveHlUaGlzKSB7XG4gICAgICAgICAgICByZXQgPSBcInJldCA9IGNhbGxiYWNrLmNhbGwodGhpcywge3thcmdzfX0sIG5vZGViYWNrKTsgYnJlYWs7XFxuXCI7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXQgPSByZWNlaXZlciA9PT0gdW5kZWZpbmVkXG4gICAgICAgICAgICAgICAgPyBcInJldCA9IGNhbGxiYWNrKHt7YXJnc319LCBub2RlYmFjayk7IGJyZWFrO1xcblwiXG4gICAgICAgICAgICAgICAgOiBcInJldCA9IGNhbGxiYWNrLmNhbGwocmVjZWl2ZXIsIHt7YXJnc319LCBub2RlYmFjayk7IGJyZWFrO1xcblwiO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXQucmVwbGFjZShcInt7YXJnc319XCIsIGFyZ3MpLnJlcGxhY2UoXCIsIFwiLCBjb21tYSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2VuZXJhdGVBcmd1bWVudFN3aXRjaENhc2UoKSB7XG4gICAgICAgIHZhciByZXQgPSBcIlwiO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFyZ3VtZW50T3JkZXIubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIHJldCArPSBcImNhc2UgXCIgKyBhcmd1bWVudE9yZGVyW2ldICtcIjpcIiArXG4gICAgICAgICAgICAgICAgZ2VuZXJhdGVDYWxsRm9yQXJndW1lbnRDb3VudChhcmd1bWVudE9yZGVyW2ldKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldCArPSBcIiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcXG5cXFxuICAgICAgICBkZWZhdWx0OiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcXG5cXFxuICAgICAgICAgICAgdmFyIGFyZ3MgPSBuZXcgQXJyYXkobGVuICsgMSk7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcXG5cXFxuICAgICAgICAgICAgdmFyIGkgPSAwOyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcXG5cXFxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47ICsraSkgeyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcXG5cXFxuICAgICAgICAgICAgICAgYXJnc1tpXSA9IGFyZ3VtZW50c1tpXTsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcXG5cXFxuICAgICAgICAgICAgfSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcXG5cXFxuICAgICAgICAgICAgYXJnc1tpXSA9IG5vZGViYWNrOyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcXG5cXFxuICAgICAgICAgICAgW0NvZGVGb3JDYWxsXSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcXG5cXFxuICAgICAgICAgICAgYnJlYWs7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcXG5cXFxuICAgICAgICBcIi5yZXBsYWNlKFwiW0NvZGVGb3JDYWxsXVwiLCAoc2hvdWxkUHJveHlUaGlzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gXCJyZXQgPSBjYWxsYmFjay5hcHBseSh0aGlzLCBhcmdzKTtcXG5cIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IFwicmV0ID0gY2FsbGJhY2suYXBwbHkocmVjZWl2ZXIsIGFyZ3MpO1xcblwiKSk7XG4gICAgICAgIHJldHVybiByZXQ7XG4gICAgfVxuXG4gICAgdmFyIGdldEZ1bmN0aW9uQ29kZSA9IHR5cGVvZiBjYWxsYmFjayA9PT0gXCJzdHJpbmdcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IChcInRoaXMgIT0gbnVsbCA/IHRoaXNbJ1wiK2NhbGxiYWNrK1wiJ10gOiBmblwiKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IFwiZm5cIjtcbiAgICB2YXIgYm9keSA9IFwiJ3VzZSBzdHJpY3QnOyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxcblxcXG4gICAgICAgIHZhciByZXQgPSBmdW5jdGlvbiAoUGFyYW1ldGVycykgeyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxcblxcXG4gICAgICAgICAgICAndXNlIHN0cmljdCc7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxcblxcXG4gICAgICAgICAgICB2YXIgbGVuID0gYXJndW1lbnRzLmxlbmd0aDsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxcblxcXG4gICAgICAgICAgICB2YXIgcHJvbWlzZSA9IG5ldyBQcm9taXNlKElOVEVSTkFMKTsgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxcblxcXG4gICAgICAgICAgICBwcm9taXNlLl9jYXB0dXJlU3RhY2tUcmFjZSgpOyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxcblxcXG4gICAgICAgICAgICB2YXIgbm9kZWJhY2sgPSBub2RlYmFja0ZvclByb21pc2UocHJvbWlzZSwgXCIgKyBtdWx0aUFyZ3MgKyBcIik7ICAgXFxuXFxcbiAgICAgICAgICAgIHZhciByZXQ7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXFxuXFxcbiAgICAgICAgICAgIHZhciBjYWxsYmFjayA9IHRyeUNhdGNoKFtHZXRGdW5jdGlvbkNvZGVdKTsgICAgICAgICAgICAgICAgICAgICAgXFxuXFxcbiAgICAgICAgICAgIHN3aXRjaChsZW4pIHsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXFxuXFxcbiAgICAgICAgICAgICAgICBbQ29kZUZvclN3aXRjaENhc2VdICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXFxuXFxcbiAgICAgICAgICAgIH0gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXFxuXFxcbiAgICAgICAgICAgIGlmIChyZXQgPT09IGVycm9yT2JqKSB7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXFxuXFxcbiAgICAgICAgICAgICAgICBwcm9taXNlLl9yZWplY3RDYWxsYmFjayhtYXliZVdyYXBBc0Vycm9yKHJldC5lKSwgdHJ1ZSwgdHJ1ZSk7XFxuXFxcbiAgICAgICAgICAgIH0gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXFxuXFxcbiAgICAgICAgICAgIGlmICghcHJvbWlzZS5faXNGYXRlU2VhbGVkKCkpIHByb21pc2UuX3NldEFzeW5jR3VhcmFudGVlZCgpOyAgICAgXFxuXFxcbiAgICAgICAgICAgIHJldHVybiBwcm9taXNlOyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXFxuXFxcbiAgICAgICAgfTsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXFxuXFxcbiAgICAgICAgbm90RW51bWVyYWJsZVByb3AocmV0LCAnX19pc1Byb21pc2lmaWVkX18nLCB0cnVlKTsgICAgICAgICAgICAgICAgICAgXFxuXFxcbiAgICAgICAgcmV0dXJuIHJldDsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXFxuXFxcbiAgICBcIi5yZXBsYWNlKFwiW0NvZGVGb3JTd2l0Y2hDYXNlXVwiLCBnZW5lcmF0ZUFyZ3VtZW50U3dpdGNoQ2FzZSgpKVxuICAgICAgICAucmVwbGFjZShcIltHZXRGdW5jdGlvbkNvZGVdXCIsIGdldEZ1bmN0aW9uQ29kZSk7XG4gICAgYm9keSA9IGJvZHkucmVwbGFjZShcIlBhcmFtZXRlcnNcIiwgcGFyYW1ldGVyRGVjbGFyYXRpb24obmV3UGFyYW1ldGVyQ291bnQpKTtcbiAgICByZXR1cm4gbmV3IEZ1bmN0aW9uKFwiUHJvbWlzZVwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgXCJmblwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgXCJyZWNlaXZlclwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgXCJ3aXRoQXBwZW5kZWRcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIFwibWF5YmVXcmFwQXNFcnJvclwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgXCJub2RlYmFja0ZvclByb21pc2VcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIFwidHJ5Q2F0Y2hcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIFwiZXJyb3JPYmpcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIFwibm90RW51bWVyYWJsZVByb3BcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIFwiSU5URVJOQUxcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIGJvZHkpKFxuICAgICAgICAgICAgICAgICAgICBQcm9taXNlLFxuICAgICAgICAgICAgICAgICAgICBmbixcbiAgICAgICAgICAgICAgICAgICAgcmVjZWl2ZXIsXG4gICAgICAgICAgICAgICAgICAgIHdpdGhBcHBlbmRlZCxcbiAgICAgICAgICAgICAgICAgICAgbWF5YmVXcmFwQXNFcnJvcixcbiAgICAgICAgICAgICAgICAgICAgbm9kZWJhY2tGb3JQcm9taXNlLFxuICAgICAgICAgICAgICAgICAgICB1dGlsLnRyeUNhdGNoLFxuICAgICAgICAgICAgICAgICAgICB1dGlsLmVycm9yT2JqLFxuICAgICAgICAgICAgICAgICAgICB1dGlsLm5vdEVudW1lcmFibGVQcm9wLFxuICAgICAgICAgICAgICAgICAgICBJTlRFUk5BTCk7XG59O1xufVxuXG5mdW5jdGlvbiBtYWtlTm9kZVByb21pc2lmaWVkQ2xvc3VyZShjYWxsYmFjaywgcmVjZWl2ZXIsIF8sIGZuLCBfXywgbXVsdGlBcmdzKSB7XG4gICAgdmFyIGRlZmF1bHRUaGlzID0gKGZ1bmN0aW9uKCkge3JldHVybiB0aGlzO30pKCk7XG4gICAgdmFyIG1ldGhvZCA9IGNhbGxiYWNrO1xuICAgIGlmICh0eXBlb2YgbWV0aG9kID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIGNhbGxiYWNrID0gZm47XG4gICAgfVxuICAgIGZ1bmN0aW9uIHByb21pc2lmaWVkKCkge1xuICAgICAgICB2YXIgX3JlY2VpdmVyID0gcmVjZWl2ZXI7XG4gICAgICAgIGlmIChyZWNlaXZlciA9PT0gVEhJUykgX3JlY2VpdmVyID0gdGhpcztcbiAgICAgICAgdmFyIHByb21pc2UgPSBuZXcgUHJvbWlzZShJTlRFUk5BTCk7XG4gICAgICAgIHByb21pc2UuX2NhcHR1cmVTdGFja1RyYWNlKCk7XG4gICAgICAgIHZhciBjYiA9IHR5cGVvZiBtZXRob2QgPT09IFwic3RyaW5nXCIgJiYgdGhpcyAhPT0gZGVmYXVsdFRoaXNcbiAgICAgICAgICAgID8gdGhpc1ttZXRob2RdIDogY2FsbGJhY2s7XG4gICAgICAgIHZhciBmbiA9IG5vZGViYWNrRm9yUHJvbWlzZShwcm9taXNlLCBtdWx0aUFyZ3MpO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY2IuYXBwbHkoX3JlY2VpdmVyLCB3aXRoQXBwZW5kZWQoYXJndW1lbnRzLCBmbikpO1xuICAgICAgICB9IGNhdGNoKGUpIHtcbiAgICAgICAgICAgIHByb21pc2UuX3JlamVjdENhbGxiYWNrKG1heWJlV3JhcEFzRXJyb3IoZSksIHRydWUsIHRydWUpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghcHJvbWlzZS5faXNGYXRlU2VhbGVkKCkpIHByb21pc2UuX3NldEFzeW5jR3VhcmFudGVlZCgpO1xuICAgICAgICByZXR1cm4gcHJvbWlzZTtcbiAgICB9XG4gICAgdXRpbC5ub3RFbnVtZXJhYmxlUHJvcChwcm9taXNpZmllZCwgXCJfX2lzUHJvbWlzaWZpZWRfX1wiLCB0cnVlKTtcbiAgICByZXR1cm4gcHJvbWlzaWZpZWQ7XG59XG5cbnZhciBtYWtlTm9kZVByb21pc2lmaWVkID0gY2FuRXZhbHVhdGVcbiAgICA/IG1ha2VOb2RlUHJvbWlzaWZpZWRFdmFsXG4gICAgOiBtYWtlTm9kZVByb21pc2lmaWVkQ2xvc3VyZTtcblxuZnVuY3Rpb24gcHJvbWlzaWZ5QWxsKG9iaiwgc3VmZml4LCBmaWx0ZXIsIHByb21pc2lmaWVyLCBtdWx0aUFyZ3MpIHtcbiAgICB2YXIgc3VmZml4UmVnZXhwID0gbmV3IFJlZ0V4cChlc2NhcGVJZGVudFJlZ2V4KHN1ZmZpeCkgKyBcIiRcIik7XG4gICAgdmFyIG1ldGhvZHMgPVxuICAgICAgICBwcm9taXNpZmlhYmxlTWV0aG9kcyhvYmosIHN1ZmZpeCwgc3VmZml4UmVnZXhwLCBmaWx0ZXIpO1xuXG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IG1ldGhvZHMubGVuZ3RoOyBpIDwgbGVuOyBpKz0gMikge1xuICAgICAgICB2YXIga2V5ID0gbWV0aG9kc1tpXTtcbiAgICAgICAgdmFyIGZuID0gbWV0aG9kc1tpKzFdO1xuICAgICAgICB2YXIgcHJvbWlzaWZpZWRLZXkgPSBrZXkgKyBzdWZmaXg7XG4gICAgICAgIGlmIChwcm9taXNpZmllciA9PT0gbWFrZU5vZGVQcm9taXNpZmllZCkge1xuICAgICAgICAgICAgb2JqW3Byb21pc2lmaWVkS2V5XSA9XG4gICAgICAgICAgICAgICAgbWFrZU5vZGVQcm9taXNpZmllZChrZXksIFRISVMsIGtleSwgZm4sIHN1ZmZpeCwgbXVsdGlBcmdzKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhciBwcm9taXNpZmllZCA9IHByb21pc2lmaWVyKGZuLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbWFrZU5vZGVQcm9taXNpZmllZChrZXksIFRISVMsIGtleSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmbiwgc3VmZml4LCBtdWx0aUFyZ3MpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB1dGlsLm5vdEVudW1lcmFibGVQcm9wKHByb21pc2lmaWVkLCBcIl9faXNQcm9taXNpZmllZF9fXCIsIHRydWUpO1xuICAgICAgICAgICAgb2JqW3Byb21pc2lmaWVkS2V5XSA9IHByb21pc2lmaWVkO1xuICAgICAgICB9XG4gICAgfVxuICAgIHV0aWwudG9GYXN0UHJvcGVydGllcyhvYmopO1xuICAgIHJldHVybiBvYmo7XG59XG5cbmZ1bmN0aW9uIHByb21pc2lmeShjYWxsYmFjaywgcmVjZWl2ZXIsIG11bHRpQXJncykge1xuICAgIHJldHVybiBtYWtlTm9kZVByb21pc2lmaWVkKGNhbGxiYWNrLCByZWNlaXZlciwgdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYWxsYmFjaywgbnVsbCwgbXVsdGlBcmdzKTtcbn1cblxuUHJvbWlzZS5wcm9taXNpZnkgPSBmdW5jdGlvbiAoZm4sIG9wdGlvbnMpIHtcbiAgICBpZiAodHlwZW9mIGZuICE9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcImV4cGVjdGluZyBhIGZ1bmN0aW9uIGJ1dCBnb3QgXCIgKyB1dGlsLmNsYXNzU3RyaW5nKGZuKSk7XG4gICAgfVxuICAgIGlmIChpc1Byb21pc2lmaWVkKGZuKSkge1xuICAgICAgICByZXR1cm4gZm47XG4gICAgfVxuICAgIG9wdGlvbnMgPSBPYmplY3Qob3B0aW9ucyk7XG4gICAgdmFyIHJlY2VpdmVyID0gb3B0aW9ucy5jb250ZXh0ID09PSB1bmRlZmluZWQgPyBUSElTIDogb3B0aW9ucy5jb250ZXh0O1xuICAgIHZhciBtdWx0aUFyZ3MgPSAhIW9wdGlvbnMubXVsdGlBcmdzO1xuICAgIHZhciByZXQgPSBwcm9taXNpZnkoZm4sIHJlY2VpdmVyLCBtdWx0aUFyZ3MpO1xuICAgIHV0aWwuY29weURlc2NyaXB0b3JzKGZuLCByZXQsIHByb3BzRmlsdGVyKTtcbiAgICByZXR1cm4gcmV0O1xufTtcblxuUHJvbWlzZS5wcm9taXNpZnlBbGwgPSBmdW5jdGlvbiAodGFyZ2V0LCBvcHRpb25zKSB7XG4gICAgaWYgKHR5cGVvZiB0YXJnZXQgIT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgdGFyZ2V0ICE9PSBcIm9iamVjdFwiKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJ0aGUgdGFyZ2V0IG9mIHByb21pc2lmeUFsbCBtdXN0IGJlIGFuIG9iamVjdCBvciBhIGZ1bmN0aW9uXFx1MDAwYVxcdTAwMGEgICAgU2VlIGh0dHA6Ly9nb28uZ2wvTXFyRm1YXFx1MDAwYVwiKTtcbiAgICB9XG4gICAgb3B0aW9ucyA9IE9iamVjdChvcHRpb25zKTtcbiAgICB2YXIgbXVsdGlBcmdzID0gISFvcHRpb25zLm11bHRpQXJncztcbiAgICB2YXIgc3VmZml4ID0gb3B0aW9ucy5zdWZmaXg7XG4gICAgaWYgKHR5cGVvZiBzdWZmaXggIT09IFwic3RyaW5nXCIpIHN1ZmZpeCA9IGRlZmF1bHRTdWZmaXg7XG4gICAgdmFyIGZpbHRlciA9IG9wdGlvbnMuZmlsdGVyO1xuICAgIGlmICh0eXBlb2YgZmlsdGVyICE9PSBcImZ1bmN0aW9uXCIpIGZpbHRlciA9IGRlZmF1bHRGaWx0ZXI7XG4gICAgdmFyIHByb21pc2lmaWVyID0gb3B0aW9ucy5wcm9taXNpZmllcjtcbiAgICBpZiAodHlwZW9mIHByb21pc2lmaWVyICE9PSBcImZ1bmN0aW9uXCIpIHByb21pc2lmaWVyID0gbWFrZU5vZGVQcm9taXNpZmllZDtcblxuICAgIGlmICghdXRpbC5pc0lkZW50aWZpZXIoc3VmZml4KSkge1xuICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcInN1ZmZpeCBtdXN0IGJlIGEgdmFsaWQgaWRlbnRpZmllclxcdTAwMGFcXHUwMDBhICAgIFNlZSBodHRwOi8vZ29vLmdsL01xckZtWFxcdTAwMGFcIik7XG4gICAgfVxuXG4gICAgdmFyIGtleXMgPSB1dGlsLmluaGVyaXRlZERhdGFLZXlzKHRhcmdldCk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIHZhciB2YWx1ZSA9IHRhcmdldFtrZXlzW2ldXTtcbiAgICAgICAgaWYgKGtleXNbaV0gIT09IFwiY29uc3RydWN0b3JcIiAmJlxuICAgICAgICAgICAgdXRpbC5pc0NsYXNzKHZhbHVlKSkge1xuICAgICAgICAgICAgcHJvbWlzaWZ5QWxsKHZhbHVlLnByb3RvdHlwZSwgc3VmZml4LCBmaWx0ZXIsIHByb21pc2lmaWVyLFxuICAgICAgICAgICAgICAgIG11bHRpQXJncyk7XG4gICAgICAgICAgICBwcm9taXNpZnlBbGwodmFsdWUsIHN1ZmZpeCwgZmlsdGVyLCBwcm9taXNpZmllciwgbXVsdGlBcmdzKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBwcm9taXNpZnlBbGwodGFyZ2V0LCBzdWZmaXgsIGZpbHRlciwgcHJvbWlzaWZpZXIsIG11bHRpQXJncyk7XG59O1xufTtcblxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2JsdWViaXJkL2pzL3JlbGVhc2UvcHJvbWlzaWZ5LmpzIiwiXCJ1c2Ugc3RyaWN0XCI7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKFxuICAgIFByb21pc2UsIFByb21pc2VBcnJheSwgdHJ5Q29udmVydFRvUHJvbWlzZSwgYXBpUmVqZWN0aW9uKSB7XG52YXIgdXRpbCA9IHJlcXVpcmUoXCIuL3V0aWxcIik7XG52YXIgaXNPYmplY3QgPSB1dGlsLmlzT2JqZWN0O1xudmFyIGVzNSA9IHJlcXVpcmUoXCIuL2VzNVwiKTtcbnZhciBFczZNYXA7XG5pZiAodHlwZW9mIE1hcCA9PT0gXCJmdW5jdGlvblwiKSBFczZNYXAgPSBNYXA7XG5cbnZhciBtYXBUb0VudHJpZXMgPSAoZnVuY3Rpb24oKSB7XG4gICAgdmFyIGluZGV4ID0gMDtcbiAgICB2YXIgc2l6ZSA9IDA7XG5cbiAgICBmdW5jdGlvbiBleHRyYWN0RW50cnkodmFsdWUsIGtleSkge1xuICAgICAgICB0aGlzW2luZGV4XSA9IHZhbHVlO1xuICAgICAgICB0aGlzW2luZGV4ICsgc2l6ZV0gPSBrZXk7XG4gICAgICAgIGluZGV4Kys7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZ1bmN0aW9uIG1hcFRvRW50cmllcyhtYXApIHtcbiAgICAgICAgc2l6ZSA9IG1hcC5zaXplO1xuICAgICAgICBpbmRleCA9IDA7XG4gICAgICAgIHZhciByZXQgPSBuZXcgQXJyYXkobWFwLnNpemUgKiAyKTtcbiAgICAgICAgbWFwLmZvckVhY2goZXh0cmFjdEVudHJ5LCByZXQpO1xuICAgICAgICByZXR1cm4gcmV0O1xuICAgIH07XG59KSgpO1xuXG52YXIgZW50cmllc1RvTWFwID0gZnVuY3Rpb24oZW50cmllcykge1xuICAgIHZhciByZXQgPSBuZXcgRXM2TWFwKCk7XG4gICAgdmFyIGxlbmd0aCA9IGVudHJpZXMubGVuZ3RoIC8gMiB8IDA7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7ICsraSkge1xuICAgICAgICB2YXIga2V5ID0gZW50cmllc1tsZW5ndGggKyBpXTtcbiAgICAgICAgdmFyIHZhbHVlID0gZW50cmllc1tpXTtcbiAgICAgICAgcmV0LnNldChrZXksIHZhbHVlKTtcbiAgICB9XG4gICAgcmV0dXJuIHJldDtcbn07XG5cbmZ1bmN0aW9uIFByb3BlcnRpZXNQcm9taXNlQXJyYXkob2JqKSB7XG4gICAgdmFyIGlzTWFwID0gZmFsc2U7XG4gICAgdmFyIGVudHJpZXM7XG4gICAgaWYgKEVzNk1hcCAhPT0gdW5kZWZpbmVkICYmIG9iaiBpbnN0YW5jZW9mIEVzNk1hcCkge1xuICAgICAgICBlbnRyaWVzID0gbWFwVG9FbnRyaWVzKG9iaik7XG4gICAgICAgIGlzTWFwID0gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgICB2YXIga2V5cyA9IGVzNS5rZXlzKG9iaik7XG4gICAgICAgIHZhciBsZW4gPSBrZXlzLmxlbmd0aDtcbiAgICAgICAgZW50cmllcyA9IG5ldyBBcnJheShsZW4gKiAyKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47ICsraSkge1xuICAgICAgICAgICAgdmFyIGtleSA9IGtleXNbaV07XG4gICAgICAgICAgICBlbnRyaWVzW2ldID0gb2JqW2tleV07XG4gICAgICAgICAgICBlbnRyaWVzW2kgKyBsZW5dID0ga2V5O1xuICAgICAgICB9XG4gICAgfVxuICAgIHRoaXMuY29uc3RydWN0b3IkKGVudHJpZXMpO1xuICAgIHRoaXMuX2lzTWFwID0gaXNNYXA7XG4gICAgdGhpcy5faW5pdCQodW5kZWZpbmVkLCBpc01hcCA/IC02IDogLTMpO1xufVxudXRpbC5pbmhlcml0cyhQcm9wZXJ0aWVzUHJvbWlzZUFycmF5LCBQcm9taXNlQXJyYXkpO1xuXG5Qcm9wZXJ0aWVzUHJvbWlzZUFycmF5LnByb3RvdHlwZS5faW5pdCA9IGZ1bmN0aW9uICgpIHt9O1xuXG5Qcm9wZXJ0aWVzUHJvbWlzZUFycmF5LnByb3RvdHlwZS5fcHJvbWlzZUZ1bGZpbGxlZCA9IGZ1bmN0aW9uICh2YWx1ZSwgaW5kZXgpIHtcbiAgICB0aGlzLl92YWx1ZXNbaW5kZXhdID0gdmFsdWU7XG4gICAgdmFyIHRvdGFsUmVzb2x2ZWQgPSArK3RoaXMuX3RvdGFsUmVzb2x2ZWQ7XG4gICAgaWYgKHRvdGFsUmVzb2x2ZWQgPj0gdGhpcy5fbGVuZ3RoKSB7XG4gICAgICAgIHZhciB2YWw7XG4gICAgICAgIGlmICh0aGlzLl9pc01hcCkge1xuICAgICAgICAgICAgdmFsID0gZW50cmllc1RvTWFwKHRoaXMuX3ZhbHVlcyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YWwgPSB7fTtcbiAgICAgICAgICAgIHZhciBrZXlPZmZzZXQgPSB0aGlzLmxlbmd0aCgpO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHRoaXMubGVuZ3RoKCk7IGkgPCBsZW47ICsraSkge1xuICAgICAgICAgICAgICAgIHZhbFt0aGlzLl92YWx1ZXNbaSArIGtleU9mZnNldF1dID0gdGhpcy5fdmFsdWVzW2ldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3Jlc29sdmUodmFsKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn07XG5cblByb3BlcnRpZXNQcm9taXNlQXJyYXkucHJvdG90eXBlLnNob3VsZENvcHlWYWx1ZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xufTtcblxuUHJvcGVydGllc1Byb21pc2VBcnJheS5wcm90b3R5cGUuZ2V0QWN0dWFsTGVuZ3RoID0gZnVuY3Rpb24gKGxlbikge1xuICAgIHJldHVybiBsZW4gPj4gMTtcbn07XG5cbmZ1bmN0aW9uIHByb3BzKHByb21pc2VzKSB7XG4gICAgdmFyIHJldDtcbiAgICB2YXIgY2FzdFZhbHVlID0gdHJ5Q29udmVydFRvUHJvbWlzZShwcm9taXNlcyk7XG5cbiAgICBpZiAoIWlzT2JqZWN0KGNhc3RWYWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuIGFwaVJlamVjdGlvbihcImNhbm5vdCBhd2FpdCBwcm9wZXJ0aWVzIG9mIGEgbm9uLW9iamVjdFxcdTAwMGFcXHUwMDBhICAgIFNlZSBodHRwOi8vZ29vLmdsL01xckZtWFxcdTAwMGFcIik7XG4gICAgfSBlbHNlIGlmIChjYXN0VmFsdWUgaW5zdGFuY2VvZiBQcm9taXNlKSB7XG4gICAgICAgIHJldCA9IGNhc3RWYWx1ZS5fdGhlbihcbiAgICAgICAgICAgIFByb21pc2UucHJvcHMsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIHVuZGVmaW5lZCk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV0ID0gbmV3IFByb3BlcnRpZXNQcm9taXNlQXJyYXkoY2FzdFZhbHVlKS5wcm9taXNlKCk7XG4gICAgfVxuXG4gICAgaWYgKGNhc3RWYWx1ZSBpbnN0YW5jZW9mIFByb21pc2UpIHtcbiAgICAgICAgcmV0Ll9wcm9wYWdhdGVGcm9tKGNhc3RWYWx1ZSwgMik7XG4gICAgfVxuICAgIHJldHVybiByZXQ7XG59XG5cblByb21pc2UucHJvdG90eXBlLnByb3BzID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBwcm9wcyh0aGlzKTtcbn07XG5cblByb21pc2UucHJvcHMgPSBmdW5jdGlvbiAocHJvbWlzZXMpIHtcbiAgICByZXR1cm4gcHJvcHMocHJvbWlzZXMpO1xufTtcbn07XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvYmx1ZWJpcmQvanMvcmVsZWFzZS9wcm9wcy5qcyIsIlwidXNlIHN0cmljdFwiO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihcbiAgICBQcm9taXNlLCBJTlRFUk5BTCwgdHJ5Q29udmVydFRvUHJvbWlzZSwgYXBpUmVqZWN0aW9uKSB7XG52YXIgdXRpbCA9IHJlcXVpcmUoXCIuL3V0aWxcIik7XG5cbnZhciByYWNlTGF0ZXIgPSBmdW5jdGlvbiAocHJvbWlzZSkge1xuICAgIHJldHVybiBwcm9taXNlLnRoZW4oZnVuY3Rpb24oYXJyYXkpIHtcbiAgICAgICAgcmV0dXJuIHJhY2UoYXJyYXksIHByb21pc2UpO1xuICAgIH0pO1xufTtcblxuZnVuY3Rpb24gcmFjZShwcm9taXNlcywgcGFyZW50KSB7XG4gICAgdmFyIG1heWJlUHJvbWlzZSA9IHRyeUNvbnZlcnRUb1Byb21pc2UocHJvbWlzZXMpO1xuXG4gICAgaWYgKG1heWJlUHJvbWlzZSBpbnN0YW5jZW9mIFByb21pc2UpIHtcbiAgICAgICAgcmV0dXJuIHJhY2VMYXRlcihtYXliZVByb21pc2UpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHByb21pc2VzID0gdXRpbC5hc0FycmF5KHByb21pc2VzKTtcbiAgICAgICAgaWYgKHByb21pc2VzID09PSBudWxsKVxuICAgICAgICAgICAgcmV0dXJuIGFwaVJlamVjdGlvbihcImV4cGVjdGluZyBhbiBhcnJheSBvciBhbiBpdGVyYWJsZSBvYmplY3QgYnV0IGdvdCBcIiArIHV0aWwuY2xhc3NTdHJpbmcocHJvbWlzZXMpKTtcbiAgICB9XG5cbiAgICB2YXIgcmV0ID0gbmV3IFByb21pc2UoSU5URVJOQUwpO1xuICAgIGlmIChwYXJlbnQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXQuX3Byb3BhZ2F0ZUZyb20ocGFyZW50LCAzKTtcbiAgICB9XG4gICAgdmFyIGZ1bGZpbGwgPSByZXQuX2Z1bGZpbGw7XG4gICAgdmFyIHJlamVjdCA9IHJldC5fcmVqZWN0O1xuICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBwcm9taXNlcy5sZW5ndGg7IGkgPCBsZW47ICsraSkge1xuICAgICAgICB2YXIgdmFsID0gcHJvbWlzZXNbaV07XG5cbiAgICAgICAgaWYgKHZhbCA9PT0gdW5kZWZpbmVkICYmICEoaSBpbiBwcm9taXNlcykpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgUHJvbWlzZS5jYXN0KHZhbCkuX3RoZW4oZnVsZmlsbCwgcmVqZWN0LCB1bmRlZmluZWQsIHJldCwgbnVsbCk7XG4gICAgfVxuICAgIHJldHVybiByZXQ7XG59XG5cblByb21pc2UucmFjZSA9IGZ1bmN0aW9uIChwcm9taXNlcykge1xuICAgIHJldHVybiByYWNlKHByb21pc2VzLCB1bmRlZmluZWQpO1xufTtcblxuUHJvbWlzZS5wcm90b3R5cGUucmFjZSA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gcmFjZSh0aGlzLCB1bmRlZmluZWQpO1xufTtcblxufTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9ibHVlYmlyZC9qcy9yZWxlYXNlL3JhY2UuanMiLCJcInVzZSBzdHJpY3RcIjtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oUHJvbWlzZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgUHJvbWlzZUFycmF5LFxuICAgICAgICAgICAgICAgICAgICAgICAgICBhcGlSZWplY3Rpb24sXG4gICAgICAgICAgICAgICAgICAgICAgICAgIHRyeUNvbnZlcnRUb1Byb21pc2UsXG4gICAgICAgICAgICAgICAgICAgICAgICAgIElOVEVSTkFMLFxuICAgICAgICAgICAgICAgICAgICAgICAgICBkZWJ1Zykge1xudmFyIGdldERvbWFpbiA9IFByb21pc2UuX2dldERvbWFpbjtcbnZhciB1dGlsID0gcmVxdWlyZShcIi4vdXRpbFwiKTtcbnZhciB0cnlDYXRjaCA9IHV0aWwudHJ5Q2F0Y2g7XG5cbmZ1bmN0aW9uIFJlZHVjdGlvblByb21pc2VBcnJheShwcm9taXNlcywgZm4sIGluaXRpYWxWYWx1ZSwgX2VhY2gpIHtcbiAgICB0aGlzLmNvbnN0cnVjdG9yJChwcm9taXNlcyk7XG4gICAgdmFyIGRvbWFpbiA9IGdldERvbWFpbigpO1xuICAgIHRoaXMuX2ZuID0gZG9tYWluID09PSBudWxsID8gZm4gOiB1dGlsLmRvbWFpbkJpbmQoZG9tYWluLCBmbik7XG4gICAgaWYgKGluaXRpYWxWYWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGluaXRpYWxWYWx1ZSA9IFByb21pc2UucmVzb2x2ZShpbml0aWFsVmFsdWUpO1xuICAgICAgICBpbml0aWFsVmFsdWUuX2F0dGFjaENhbmNlbGxhdGlvbkNhbGxiYWNrKHRoaXMpO1xuICAgIH1cbiAgICB0aGlzLl9pbml0aWFsVmFsdWUgPSBpbml0aWFsVmFsdWU7XG4gICAgdGhpcy5fY3VycmVudENhbmNlbGxhYmxlID0gbnVsbDtcbiAgICBpZihfZWFjaCA9PT0gSU5URVJOQUwpIHtcbiAgICAgICAgdGhpcy5fZWFjaFZhbHVlcyA9IEFycmF5KHRoaXMuX2xlbmd0aCk7XG4gICAgfSBlbHNlIGlmIChfZWFjaCA9PT0gMCkge1xuICAgICAgICB0aGlzLl9lYWNoVmFsdWVzID0gbnVsbDtcbiAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLl9lYWNoVmFsdWVzID0gdW5kZWZpbmVkO1xuICAgIH1cbiAgICB0aGlzLl9wcm9taXNlLl9jYXB0dXJlU3RhY2tUcmFjZSgpO1xuICAgIHRoaXMuX2luaXQkKHVuZGVmaW5lZCwgLTUpO1xufVxudXRpbC5pbmhlcml0cyhSZWR1Y3Rpb25Qcm9taXNlQXJyYXksIFByb21pc2VBcnJheSk7XG5cblJlZHVjdGlvblByb21pc2VBcnJheS5wcm90b3R5cGUuX2dvdEFjY3VtID0gZnVuY3Rpb24oYWNjdW0pIHtcbiAgICBpZiAodGhpcy5fZWFjaFZhbHVlcyAhPT0gdW5kZWZpbmVkICYmIFxuICAgICAgICB0aGlzLl9lYWNoVmFsdWVzICE9PSBudWxsICYmIFxuICAgICAgICBhY2N1bSAhPT0gSU5URVJOQUwpIHtcbiAgICAgICAgdGhpcy5fZWFjaFZhbHVlcy5wdXNoKGFjY3VtKTtcbiAgICB9XG59O1xuXG5SZWR1Y3Rpb25Qcm9taXNlQXJyYXkucHJvdG90eXBlLl9lYWNoQ29tcGxldGUgPSBmdW5jdGlvbih2YWx1ZSkge1xuICAgIGlmICh0aGlzLl9lYWNoVmFsdWVzICE9PSBudWxsKSB7XG4gICAgICAgIHRoaXMuX2VhY2hWYWx1ZXMucHVzaCh2YWx1ZSk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9lYWNoVmFsdWVzO1xufTtcblxuUmVkdWN0aW9uUHJvbWlzZUFycmF5LnByb3RvdHlwZS5faW5pdCA9IGZ1bmN0aW9uKCkge307XG5cblJlZHVjdGlvblByb21pc2VBcnJheS5wcm90b3R5cGUuX3Jlc29sdmVFbXB0eUFycmF5ID0gZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5fcmVzb2x2ZSh0aGlzLl9lYWNoVmFsdWVzICE9PSB1bmRlZmluZWQgPyB0aGlzLl9lYWNoVmFsdWVzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOiB0aGlzLl9pbml0aWFsVmFsdWUpO1xufTtcblxuUmVkdWN0aW9uUHJvbWlzZUFycmF5LnByb3RvdHlwZS5zaG91bGRDb3B5VmFsdWVzID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBmYWxzZTtcbn07XG5cblJlZHVjdGlvblByb21pc2VBcnJheS5wcm90b3R5cGUuX3Jlc29sdmUgPSBmdW5jdGlvbih2YWx1ZSkge1xuICAgIHRoaXMuX3Byb21pc2UuX3Jlc29sdmVDYWxsYmFjayh2YWx1ZSk7XG4gICAgdGhpcy5fdmFsdWVzID0gbnVsbDtcbn07XG5cblJlZHVjdGlvblByb21pc2VBcnJheS5wcm90b3R5cGUuX3Jlc3VsdENhbmNlbGxlZCA9IGZ1bmN0aW9uKHNlbmRlcikge1xuICAgIGlmIChzZW5kZXIgPT09IHRoaXMuX2luaXRpYWxWYWx1ZSkgcmV0dXJuIHRoaXMuX2NhbmNlbCgpO1xuICAgIGlmICh0aGlzLl9pc1Jlc29sdmVkKCkpIHJldHVybjtcbiAgICB0aGlzLl9yZXN1bHRDYW5jZWxsZWQkKCk7XG4gICAgaWYgKHRoaXMuX2N1cnJlbnRDYW5jZWxsYWJsZSBpbnN0YW5jZW9mIFByb21pc2UpIHtcbiAgICAgICAgdGhpcy5fY3VycmVudENhbmNlbGxhYmxlLmNhbmNlbCgpO1xuICAgIH1cbiAgICBpZiAodGhpcy5faW5pdGlhbFZhbHVlIGluc3RhbmNlb2YgUHJvbWlzZSkge1xuICAgICAgICB0aGlzLl9pbml0aWFsVmFsdWUuY2FuY2VsKCk7XG4gICAgfVxufTtcblxuUmVkdWN0aW9uUHJvbWlzZUFycmF5LnByb3RvdHlwZS5faXRlcmF0ZSA9IGZ1bmN0aW9uICh2YWx1ZXMpIHtcbiAgICB0aGlzLl92YWx1ZXMgPSB2YWx1ZXM7XG4gICAgdmFyIHZhbHVlO1xuICAgIHZhciBpO1xuICAgIHZhciBsZW5ndGggPSB2YWx1ZXMubGVuZ3RoO1xuICAgIGlmICh0aGlzLl9pbml0aWFsVmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB2YWx1ZSA9IHRoaXMuX2luaXRpYWxWYWx1ZTtcbiAgICAgICAgaSA9IDA7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdmFsdWUgPSBQcm9taXNlLnJlc29sdmUodmFsdWVzWzBdKTtcbiAgICAgICAgaSA9IDE7XG4gICAgfVxuXG4gICAgdGhpcy5fY3VycmVudENhbmNlbGxhYmxlID0gdmFsdWU7XG5cbiAgICBpZiAoIXZhbHVlLmlzUmVqZWN0ZWQoKSkge1xuICAgICAgICBmb3IgKDsgaSA8IGxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICB2YXIgY3R4ID0ge1xuICAgICAgICAgICAgICAgIGFjY3VtOiBudWxsLFxuICAgICAgICAgICAgICAgIHZhbHVlOiB2YWx1ZXNbaV0sXG4gICAgICAgICAgICAgICAgaW5kZXg6IGksXG4gICAgICAgICAgICAgICAgbGVuZ3RoOiBsZW5ndGgsXG4gICAgICAgICAgICAgICAgYXJyYXk6IHRoaXNcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB2YWx1ZSA9IHZhbHVlLl90aGVuKGdvdEFjY3VtLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgY3R4LCB1bmRlZmluZWQpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX2VhY2hWYWx1ZXMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB2YWx1ZSA9IHZhbHVlXG4gICAgICAgICAgICAuX3RoZW4odGhpcy5fZWFjaENvbXBsZXRlLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgdGhpcywgdW5kZWZpbmVkKTtcbiAgICB9XG4gICAgdmFsdWUuX3RoZW4oY29tcGxldGVkLCBjb21wbGV0ZWQsIHVuZGVmaW5lZCwgdmFsdWUsIHRoaXMpO1xufTtcblxuUHJvbWlzZS5wcm90b3R5cGUucmVkdWNlID0gZnVuY3Rpb24gKGZuLCBpbml0aWFsVmFsdWUpIHtcbiAgICByZXR1cm4gcmVkdWNlKHRoaXMsIGZuLCBpbml0aWFsVmFsdWUsIG51bGwpO1xufTtcblxuUHJvbWlzZS5yZWR1Y2UgPSBmdW5jdGlvbiAocHJvbWlzZXMsIGZuLCBpbml0aWFsVmFsdWUsIF9lYWNoKSB7XG4gICAgcmV0dXJuIHJlZHVjZShwcm9taXNlcywgZm4sIGluaXRpYWxWYWx1ZSwgX2VhY2gpO1xufTtcblxuZnVuY3Rpb24gY29tcGxldGVkKHZhbHVlT3JSZWFzb24sIGFycmF5KSB7XG4gICAgaWYgKHRoaXMuaXNGdWxmaWxsZWQoKSkge1xuICAgICAgICBhcnJheS5fcmVzb2x2ZSh2YWx1ZU9yUmVhc29uKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBhcnJheS5fcmVqZWN0KHZhbHVlT3JSZWFzb24pO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gcmVkdWNlKHByb21pc2VzLCBmbiwgaW5pdGlhbFZhbHVlLCBfZWFjaCkge1xuICAgIGlmICh0eXBlb2YgZm4gIT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICByZXR1cm4gYXBpUmVqZWN0aW9uKFwiZXhwZWN0aW5nIGEgZnVuY3Rpb24gYnV0IGdvdCBcIiArIHV0aWwuY2xhc3NTdHJpbmcoZm4pKTtcbiAgICB9XG4gICAgdmFyIGFycmF5ID0gbmV3IFJlZHVjdGlvblByb21pc2VBcnJheShwcm9taXNlcywgZm4sIGluaXRpYWxWYWx1ZSwgX2VhY2gpO1xuICAgIHJldHVybiBhcnJheS5wcm9taXNlKCk7XG59XG5cbmZ1bmN0aW9uIGdvdEFjY3VtKGFjY3VtKSB7XG4gICAgdGhpcy5hY2N1bSA9IGFjY3VtO1xuICAgIHRoaXMuYXJyYXkuX2dvdEFjY3VtKGFjY3VtKTtcbiAgICB2YXIgdmFsdWUgPSB0cnlDb252ZXJ0VG9Qcm9taXNlKHRoaXMudmFsdWUsIHRoaXMuYXJyYXkuX3Byb21pc2UpO1xuICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIFByb21pc2UpIHtcbiAgICAgICAgdGhpcy5hcnJheS5fY3VycmVudENhbmNlbGxhYmxlID0gdmFsdWU7XG4gICAgICAgIHJldHVybiB2YWx1ZS5fdGhlbihnb3RWYWx1ZSwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIHRoaXMsIHVuZGVmaW5lZCk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGdvdFZhbHVlLmNhbGwodGhpcywgdmFsdWUpO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gZ290VmFsdWUodmFsdWUpIHtcbiAgICB2YXIgYXJyYXkgPSB0aGlzLmFycmF5O1xuICAgIHZhciBwcm9taXNlID0gYXJyYXkuX3Byb21pc2U7XG4gICAgdmFyIGZuID0gdHJ5Q2F0Y2goYXJyYXkuX2ZuKTtcbiAgICBwcm9taXNlLl9wdXNoQ29udGV4dCgpO1xuICAgIHZhciByZXQ7XG4gICAgaWYgKGFycmF5Ll9lYWNoVmFsdWVzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0ID0gZm4uY2FsbChwcm9taXNlLl9ib3VuZFZhbHVlKCksIHZhbHVlLCB0aGlzLmluZGV4LCB0aGlzLmxlbmd0aCk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV0ID0gZm4uY2FsbChwcm9taXNlLl9ib3VuZFZhbHVlKCksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmFjY3VtLCB2YWx1ZSwgdGhpcy5pbmRleCwgdGhpcy5sZW5ndGgpO1xuICAgIH1cbiAgICBpZiAocmV0IGluc3RhbmNlb2YgUHJvbWlzZSkge1xuICAgICAgICBhcnJheS5fY3VycmVudENhbmNlbGxhYmxlID0gcmV0O1xuICAgIH1cbiAgICB2YXIgcHJvbWlzZUNyZWF0ZWQgPSBwcm9taXNlLl9wb3BDb250ZXh0KCk7XG4gICAgZGVidWcuY2hlY2tGb3Jnb3R0ZW5SZXR1cm5zKFxuICAgICAgICByZXQsXG4gICAgICAgIHByb21pc2VDcmVhdGVkLFxuICAgICAgICBhcnJheS5fZWFjaFZhbHVlcyAhPT0gdW5kZWZpbmVkID8gXCJQcm9taXNlLmVhY2hcIiA6IFwiUHJvbWlzZS5yZWR1Y2VcIixcbiAgICAgICAgcHJvbWlzZVxuICAgICk7XG4gICAgcmV0dXJuIHJldDtcbn1cbn07XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvYmx1ZWJpcmQvanMvcmVsZWFzZS9yZWR1Y2UuanMiLCJcInVzZSBzdHJpY3RcIjtcbm1vZHVsZS5leHBvcnRzID1cbiAgICBmdW5jdGlvbihQcm9taXNlLCBQcm9taXNlQXJyYXksIGRlYnVnKSB7XG52YXIgUHJvbWlzZUluc3BlY3Rpb24gPSBQcm9taXNlLlByb21pc2VJbnNwZWN0aW9uO1xudmFyIHV0aWwgPSByZXF1aXJlKFwiLi91dGlsXCIpO1xuXG5mdW5jdGlvbiBTZXR0bGVkUHJvbWlzZUFycmF5KHZhbHVlcykge1xuICAgIHRoaXMuY29uc3RydWN0b3IkKHZhbHVlcyk7XG59XG51dGlsLmluaGVyaXRzKFNldHRsZWRQcm9taXNlQXJyYXksIFByb21pc2VBcnJheSk7XG5cblNldHRsZWRQcm9taXNlQXJyYXkucHJvdG90eXBlLl9wcm9taXNlUmVzb2x2ZWQgPSBmdW5jdGlvbiAoaW5kZXgsIGluc3BlY3Rpb24pIHtcbiAgICB0aGlzLl92YWx1ZXNbaW5kZXhdID0gaW5zcGVjdGlvbjtcbiAgICB2YXIgdG90YWxSZXNvbHZlZCA9ICsrdGhpcy5fdG90YWxSZXNvbHZlZDtcbiAgICBpZiAodG90YWxSZXNvbHZlZCA+PSB0aGlzLl9sZW5ndGgpIHtcbiAgICAgICAgdGhpcy5fcmVzb2x2ZSh0aGlzLl92YWx1ZXMpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufTtcblxuU2V0dGxlZFByb21pc2VBcnJheS5wcm90b3R5cGUuX3Byb21pc2VGdWxmaWxsZWQgPSBmdW5jdGlvbiAodmFsdWUsIGluZGV4KSB7XG4gICAgdmFyIHJldCA9IG5ldyBQcm9taXNlSW5zcGVjdGlvbigpO1xuICAgIHJldC5fYml0RmllbGQgPSAzMzU1NDQzMjtcbiAgICByZXQuX3NldHRsZWRWYWx1ZUZpZWxkID0gdmFsdWU7XG4gICAgcmV0dXJuIHRoaXMuX3Byb21pc2VSZXNvbHZlZChpbmRleCwgcmV0KTtcbn07XG5TZXR0bGVkUHJvbWlzZUFycmF5LnByb3RvdHlwZS5fcHJvbWlzZVJlamVjdGVkID0gZnVuY3Rpb24gKHJlYXNvbiwgaW5kZXgpIHtcbiAgICB2YXIgcmV0ID0gbmV3IFByb21pc2VJbnNwZWN0aW9uKCk7XG4gICAgcmV0Ll9iaXRGaWVsZCA9IDE2Nzc3MjE2O1xuICAgIHJldC5fc2V0dGxlZFZhbHVlRmllbGQgPSByZWFzb247XG4gICAgcmV0dXJuIHRoaXMuX3Byb21pc2VSZXNvbHZlZChpbmRleCwgcmV0KTtcbn07XG5cblByb21pc2Uuc2V0dGxlID0gZnVuY3Rpb24gKHByb21pc2VzKSB7XG4gICAgZGVidWcuZGVwcmVjYXRlZChcIi5zZXR0bGUoKVwiLCBcIi5yZWZsZWN0KClcIik7XG4gICAgcmV0dXJuIG5ldyBTZXR0bGVkUHJvbWlzZUFycmF5KHByb21pc2VzKS5wcm9taXNlKCk7XG59O1xuXG5Qcm9taXNlLnByb3RvdHlwZS5zZXR0bGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIFByb21pc2Uuc2V0dGxlKHRoaXMpO1xufTtcbn07XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvYmx1ZWJpcmQvanMvcmVsZWFzZS9zZXR0bGUuanMiLCJcInVzZSBzdHJpY3RcIjtcbm1vZHVsZS5leHBvcnRzID1cbmZ1bmN0aW9uKFByb21pc2UsIFByb21pc2VBcnJheSwgYXBpUmVqZWN0aW9uKSB7XG52YXIgdXRpbCA9IHJlcXVpcmUoXCIuL3V0aWxcIik7XG52YXIgUmFuZ2VFcnJvciA9IHJlcXVpcmUoXCIuL2Vycm9yc1wiKS5SYW5nZUVycm9yO1xudmFyIEFnZ3JlZ2F0ZUVycm9yID0gcmVxdWlyZShcIi4vZXJyb3JzXCIpLkFnZ3JlZ2F0ZUVycm9yO1xudmFyIGlzQXJyYXkgPSB1dGlsLmlzQXJyYXk7XG52YXIgQ0FOQ0VMTEFUSU9OID0ge307XG5cblxuZnVuY3Rpb24gU29tZVByb21pc2VBcnJheSh2YWx1ZXMpIHtcbiAgICB0aGlzLmNvbnN0cnVjdG9yJCh2YWx1ZXMpO1xuICAgIHRoaXMuX2hvd01hbnkgPSAwO1xuICAgIHRoaXMuX3Vud3JhcCA9IGZhbHNlO1xuICAgIHRoaXMuX2luaXRpYWxpemVkID0gZmFsc2U7XG59XG51dGlsLmluaGVyaXRzKFNvbWVQcm9taXNlQXJyYXksIFByb21pc2VBcnJheSk7XG5cblNvbWVQcm9taXNlQXJyYXkucHJvdG90eXBlLl9pbml0ID0gZnVuY3Rpb24gKCkge1xuICAgIGlmICghdGhpcy5faW5pdGlhbGl6ZWQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAodGhpcy5faG93TWFueSA9PT0gMCkge1xuICAgICAgICB0aGlzLl9yZXNvbHZlKFtdKTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLl9pbml0JCh1bmRlZmluZWQsIC01KTtcbiAgICB2YXIgaXNBcnJheVJlc29sdmVkID0gaXNBcnJheSh0aGlzLl92YWx1ZXMpO1xuICAgIGlmICghdGhpcy5faXNSZXNvbHZlZCgpICYmXG4gICAgICAgIGlzQXJyYXlSZXNvbHZlZCAmJlxuICAgICAgICB0aGlzLl9ob3dNYW55ID4gdGhpcy5fY2FuUG9zc2libHlGdWxmaWxsKCkpIHtcbiAgICAgICAgdGhpcy5fcmVqZWN0KHRoaXMuX2dldFJhbmdlRXJyb3IodGhpcy5sZW5ndGgoKSkpO1xuICAgIH1cbn07XG5cblNvbWVQcm9taXNlQXJyYXkucHJvdG90eXBlLmluaXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5faW5pdGlhbGl6ZWQgPSB0cnVlO1xuICAgIHRoaXMuX2luaXQoKTtcbn07XG5cblNvbWVQcm9taXNlQXJyYXkucHJvdG90eXBlLnNldFVud3JhcCA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLl91bndyYXAgPSB0cnVlO1xufTtcblxuU29tZVByb21pc2VBcnJheS5wcm90b3R5cGUuaG93TWFueSA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5faG93TWFueTtcbn07XG5cblNvbWVQcm9taXNlQXJyYXkucHJvdG90eXBlLnNldEhvd01hbnkgPSBmdW5jdGlvbiAoY291bnQpIHtcbiAgICB0aGlzLl9ob3dNYW55ID0gY291bnQ7XG59O1xuXG5Tb21lUHJvbWlzZUFycmF5LnByb3RvdHlwZS5fcHJvbWlzZUZ1bGZpbGxlZCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgIHRoaXMuX2FkZEZ1bGZpbGxlZCh2YWx1ZSk7XG4gICAgaWYgKHRoaXMuX2Z1bGZpbGxlZCgpID09PSB0aGlzLmhvd01hbnkoKSkge1xuICAgICAgICB0aGlzLl92YWx1ZXMubGVuZ3RoID0gdGhpcy5ob3dNYW55KCk7XG4gICAgICAgIGlmICh0aGlzLmhvd01hbnkoKSA9PT0gMSAmJiB0aGlzLl91bndyYXApIHtcbiAgICAgICAgICAgIHRoaXMuX3Jlc29sdmUodGhpcy5fdmFsdWVzWzBdKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX3Jlc29sdmUodGhpcy5fdmFsdWVzKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuXG59O1xuU29tZVByb21pc2VBcnJheS5wcm90b3R5cGUuX3Byb21pc2VSZWplY3RlZCA9IGZ1bmN0aW9uIChyZWFzb24pIHtcbiAgICB0aGlzLl9hZGRSZWplY3RlZChyZWFzb24pO1xuICAgIHJldHVybiB0aGlzLl9jaGVja091dGNvbWUoKTtcbn07XG5cblNvbWVQcm9taXNlQXJyYXkucHJvdG90eXBlLl9wcm9taXNlQ2FuY2VsbGVkID0gZnVuY3Rpb24gKCkge1xuICAgIGlmICh0aGlzLl92YWx1ZXMgaW5zdGFuY2VvZiBQcm9taXNlIHx8IHRoaXMuX3ZhbHVlcyA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9jYW5jZWwoKTtcbiAgICB9XG4gICAgdGhpcy5fYWRkUmVqZWN0ZWQoQ0FOQ0VMTEFUSU9OKTtcbiAgICByZXR1cm4gdGhpcy5fY2hlY2tPdXRjb21lKCk7XG59O1xuXG5Tb21lUHJvbWlzZUFycmF5LnByb3RvdHlwZS5fY2hlY2tPdXRjb21lID0gZnVuY3Rpb24oKSB7XG4gICAgaWYgKHRoaXMuaG93TWFueSgpID4gdGhpcy5fY2FuUG9zc2libHlGdWxmaWxsKCkpIHtcbiAgICAgICAgdmFyIGUgPSBuZXcgQWdncmVnYXRlRXJyb3IoKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IHRoaXMubGVuZ3RoKCk7IGkgPCB0aGlzLl92YWx1ZXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLl92YWx1ZXNbaV0gIT09IENBTkNFTExBVElPTikge1xuICAgICAgICAgICAgICAgIGUucHVzaCh0aGlzLl92YWx1ZXNbaV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChlLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIHRoaXMuX3JlamVjdChlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX2NhbmNlbCgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59O1xuXG5Tb21lUHJvbWlzZUFycmF5LnByb3RvdHlwZS5fZnVsZmlsbGVkID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLl90b3RhbFJlc29sdmVkO1xufTtcblxuU29tZVByb21pc2VBcnJheS5wcm90b3R5cGUuX3JlamVjdGVkID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLl92YWx1ZXMubGVuZ3RoIC0gdGhpcy5sZW5ndGgoKTtcbn07XG5cblNvbWVQcm9taXNlQXJyYXkucHJvdG90eXBlLl9hZGRSZWplY3RlZCA9IGZ1bmN0aW9uIChyZWFzb24pIHtcbiAgICB0aGlzLl92YWx1ZXMucHVzaChyZWFzb24pO1xufTtcblxuU29tZVByb21pc2VBcnJheS5wcm90b3R5cGUuX2FkZEZ1bGZpbGxlZCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgIHRoaXMuX3ZhbHVlc1t0aGlzLl90b3RhbFJlc29sdmVkKytdID0gdmFsdWU7XG59O1xuXG5Tb21lUHJvbWlzZUFycmF5LnByb3RvdHlwZS5fY2FuUG9zc2libHlGdWxmaWxsID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLmxlbmd0aCgpIC0gdGhpcy5fcmVqZWN0ZWQoKTtcbn07XG5cblNvbWVQcm9taXNlQXJyYXkucHJvdG90eXBlLl9nZXRSYW5nZUVycm9yID0gZnVuY3Rpb24gKGNvdW50KSB7XG4gICAgdmFyIG1lc3NhZ2UgPSBcIklucHV0IGFycmF5IG11c3QgY29udGFpbiBhdCBsZWFzdCBcIiArXG4gICAgICAgICAgICB0aGlzLl9ob3dNYW55ICsgXCIgaXRlbXMgYnV0IGNvbnRhaW5zIG9ubHkgXCIgKyBjb3VudCArIFwiIGl0ZW1zXCI7XG4gICAgcmV0dXJuIG5ldyBSYW5nZUVycm9yKG1lc3NhZ2UpO1xufTtcblxuU29tZVByb21pc2VBcnJheS5wcm90b3R5cGUuX3Jlc29sdmVFbXB0eUFycmF5ID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuX3JlamVjdCh0aGlzLl9nZXRSYW5nZUVycm9yKDApKTtcbn07XG5cbmZ1bmN0aW9uIHNvbWUocHJvbWlzZXMsIGhvd01hbnkpIHtcbiAgICBpZiAoKGhvd01hbnkgfCAwKSAhPT0gaG93TWFueSB8fCBob3dNYW55IDwgMCkge1xuICAgICAgICByZXR1cm4gYXBpUmVqZWN0aW9uKFwiZXhwZWN0aW5nIGEgcG9zaXRpdmUgaW50ZWdlclxcdTAwMGFcXHUwMDBhICAgIFNlZSBodHRwOi8vZ29vLmdsL01xckZtWFxcdTAwMGFcIik7XG4gICAgfVxuICAgIHZhciByZXQgPSBuZXcgU29tZVByb21pc2VBcnJheShwcm9taXNlcyk7XG4gICAgdmFyIHByb21pc2UgPSByZXQucHJvbWlzZSgpO1xuICAgIHJldC5zZXRIb3dNYW55KGhvd01hbnkpO1xuICAgIHJldC5pbml0KCk7XG4gICAgcmV0dXJuIHByb21pc2U7XG59XG5cblByb21pc2Uuc29tZSA9IGZ1bmN0aW9uIChwcm9taXNlcywgaG93TWFueSkge1xuICAgIHJldHVybiBzb21lKHByb21pc2VzLCBob3dNYW55KTtcbn07XG5cblByb21pc2UucHJvdG90eXBlLnNvbWUgPSBmdW5jdGlvbiAoaG93TWFueSkge1xuICAgIHJldHVybiBzb21lKHRoaXMsIGhvd01hbnkpO1xufTtcblxuUHJvbWlzZS5fU29tZVByb21pc2VBcnJheSA9IFNvbWVQcm9taXNlQXJyYXk7XG59O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2JsdWViaXJkL2pzL3JlbGVhc2Uvc29tZS5qcyIsIlwidXNlIHN0cmljdFwiO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihQcm9taXNlLCBJTlRFUk5BTCkge1xudmFyIFByb21pc2VNYXAgPSBQcm9taXNlLm1hcDtcblxuUHJvbWlzZS5wcm90b3R5cGUuZmlsdGVyID0gZnVuY3Rpb24gKGZuLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIFByb21pc2VNYXAodGhpcywgZm4sIG9wdGlvbnMsIElOVEVSTkFMKTtcbn07XG5cblByb21pc2UuZmlsdGVyID0gZnVuY3Rpb24gKHByb21pc2VzLCBmbiwgb3B0aW9ucykge1xuICAgIHJldHVybiBQcm9taXNlTWFwKHByb21pc2VzLCBmbiwgb3B0aW9ucywgSU5URVJOQUwpO1xufTtcbn07XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvYmx1ZWJpcmQvanMvcmVsZWFzZS9maWx0ZXIuanMiLCJcInVzZSBzdHJpY3RcIjtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oUHJvbWlzZSwgSU5URVJOQUwpIHtcbnZhciBQcm9taXNlUmVkdWNlID0gUHJvbWlzZS5yZWR1Y2U7XG52YXIgUHJvbWlzZUFsbCA9IFByb21pc2UuYWxsO1xuXG5mdW5jdGlvbiBwcm9taXNlQWxsVGhpcygpIHtcbiAgICByZXR1cm4gUHJvbWlzZUFsbCh0aGlzKTtcbn1cblxuZnVuY3Rpb24gUHJvbWlzZU1hcFNlcmllcyhwcm9taXNlcywgZm4pIHtcbiAgICByZXR1cm4gUHJvbWlzZVJlZHVjZShwcm9taXNlcywgZm4sIElOVEVSTkFMLCBJTlRFUk5BTCk7XG59XG5cblByb21pc2UucHJvdG90eXBlLmVhY2ggPSBmdW5jdGlvbiAoZm4pIHtcbiAgICByZXR1cm4gUHJvbWlzZVJlZHVjZSh0aGlzLCBmbiwgSU5URVJOQUwsIDApXG4gICAgICAgICAgICAgIC5fdGhlbihwcm9taXNlQWxsVGhpcywgdW5kZWZpbmVkLCB1bmRlZmluZWQsIHRoaXMsIHVuZGVmaW5lZCk7XG59O1xuXG5Qcm9taXNlLnByb3RvdHlwZS5tYXBTZXJpZXMgPSBmdW5jdGlvbiAoZm4pIHtcbiAgICByZXR1cm4gUHJvbWlzZVJlZHVjZSh0aGlzLCBmbiwgSU5URVJOQUwsIElOVEVSTkFMKTtcbn07XG5cblByb21pc2UuZWFjaCA9IGZ1bmN0aW9uIChwcm9taXNlcywgZm4pIHtcbiAgICByZXR1cm4gUHJvbWlzZVJlZHVjZShwcm9taXNlcywgZm4sIElOVEVSTkFMLCAwKVxuICAgICAgICAgICAgICAuX3RoZW4ocHJvbWlzZUFsbFRoaXMsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBwcm9taXNlcywgdW5kZWZpbmVkKTtcbn07XG5cblByb21pc2UubWFwU2VyaWVzID0gUHJvbWlzZU1hcFNlcmllcztcbn07XG5cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9ibHVlYmlyZC9qcy9yZWxlYXNlL2VhY2guanMiLCJcInVzZSBzdHJpY3RcIjtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oUHJvbWlzZSkge1xudmFyIFNvbWVQcm9taXNlQXJyYXkgPSBQcm9taXNlLl9Tb21lUHJvbWlzZUFycmF5O1xuZnVuY3Rpb24gYW55KHByb21pc2VzKSB7XG4gICAgdmFyIHJldCA9IG5ldyBTb21lUHJvbWlzZUFycmF5KHByb21pc2VzKTtcbiAgICB2YXIgcHJvbWlzZSA9IHJldC5wcm9taXNlKCk7XG4gICAgcmV0LnNldEhvd01hbnkoMSk7XG4gICAgcmV0LnNldFVud3JhcCgpO1xuICAgIHJldC5pbml0KCk7XG4gICAgcmV0dXJuIHByb21pc2U7XG59XG5cblByb21pc2UuYW55ID0gZnVuY3Rpb24gKHByb21pc2VzKSB7XG4gICAgcmV0dXJuIGFueShwcm9taXNlcyk7XG59O1xuXG5Qcm9taXNlLnByb3RvdHlwZS5hbnkgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIGFueSh0aGlzKTtcbn07XG5cbn07XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvYmx1ZWJpcmQvanMvcmVsZWFzZS9hbnkuanMiLCIvKipcbiAqIERldGVjdCBFbGVjdHJvbiByZW5kZXJlciBwcm9jZXNzLCB3aGljaCBpcyBub2RlLCBidXQgd2Ugc2hvdWxkXG4gKiB0cmVhdCBhcyBhIGJyb3dzZXIuXG4gKi9cblxuaWYgKHR5cGVvZiBwcm9jZXNzID09PSAndW5kZWZpbmVkJyB8fCBwcm9jZXNzLnR5cGUgPT09ICdyZW5kZXJlcicpIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2Jyb3dzZXIuanMnKTtcbn0gZWxzZSB7XG4gIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9ub2RlLmpzJyk7XG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvZWxlY3Ryb24tdXBkYXRlci9ub2RlX21vZHVsZXMvZGVidWcvc3JjL2luZGV4LmpzIiwiLyoqXG4gKiBUaGlzIGlzIHRoZSB3ZWIgYnJvd3NlciBpbXBsZW1lbnRhdGlvbiBvZiBgZGVidWcoKWAuXG4gKlxuICogRXhwb3NlIGBkZWJ1ZygpYCBhcyB0aGUgbW9kdWxlLlxuICovXG5cbmV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vZGVidWcnKTtcbmV4cG9ydHMubG9nID0gbG9nO1xuZXhwb3J0cy5mb3JtYXRBcmdzID0gZm9ybWF0QXJncztcbmV4cG9ydHMuc2F2ZSA9IHNhdmU7XG5leHBvcnRzLmxvYWQgPSBsb2FkO1xuZXhwb3J0cy51c2VDb2xvcnMgPSB1c2VDb2xvcnM7XG5leHBvcnRzLnN0b3JhZ2UgPSAndW5kZWZpbmVkJyAhPSB0eXBlb2YgY2hyb21lXG4gICAgICAgICAgICAgICAmJiAndW5kZWZpbmVkJyAhPSB0eXBlb2YgY2hyb21lLnN0b3JhZ2VcbiAgICAgICAgICAgICAgICAgID8gY2hyb21lLnN0b3JhZ2UubG9jYWxcbiAgICAgICAgICAgICAgICAgIDogbG9jYWxzdG9yYWdlKCk7XG5cbi8qKlxuICogQ29sb3JzLlxuICovXG5cbmV4cG9ydHMuY29sb3JzID0gW1xuICAnIzAwMDBDQycsICcjMDAwMEZGJywgJyMwMDMzQ0MnLCAnIzAwMzNGRicsICcjMDA2NkNDJywgJyMwMDY2RkYnLCAnIzAwOTlDQycsXG4gICcjMDA5OUZGJywgJyMwMENDMDAnLCAnIzAwQ0MzMycsICcjMDBDQzY2JywgJyMwMENDOTknLCAnIzAwQ0NDQycsICcjMDBDQ0ZGJyxcbiAgJyMzMzAwQ0MnLCAnIzMzMDBGRicsICcjMzMzM0NDJywgJyMzMzMzRkYnLCAnIzMzNjZDQycsICcjMzM2NkZGJywgJyMzMzk5Q0MnLFxuICAnIzMzOTlGRicsICcjMzNDQzAwJywgJyMzM0NDMzMnLCAnIzMzQ0M2NicsICcjMzNDQzk5JywgJyMzM0NDQ0MnLCAnIzMzQ0NGRicsXG4gICcjNjYwMENDJywgJyM2NjAwRkYnLCAnIzY2MzNDQycsICcjNjYzM0ZGJywgJyM2NkNDMDAnLCAnIzY2Q0MzMycsICcjOTkwMENDJyxcbiAgJyM5OTAwRkYnLCAnIzk5MzNDQycsICcjOTkzM0ZGJywgJyM5OUNDMDAnLCAnIzk5Q0MzMycsICcjQ0MwMDAwJywgJyNDQzAwMzMnLFxuICAnI0NDMDA2NicsICcjQ0MwMDk5JywgJyNDQzAwQ0MnLCAnI0NDMDBGRicsICcjQ0MzMzAwJywgJyNDQzMzMzMnLCAnI0NDMzM2NicsXG4gICcjQ0MzMzk5JywgJyNDQzMzQ0MnLCAnI0NDMzNGRicsICcjQ0M2NjAwJywgJyNDQzY2MzMnLCAnI0NDOTkwMCcsICcjQ0M5OTMzJyxcbiAgJyNDQ0NDMDAnLCAnI0NDQ0MzMycsICcjRkYwMDAwJywgJyNGRjAwMzMnLCAnI0ZGMDA2NicsICcjRkYwMDk5JywgJyNGRjAwQ0MnLFxuICAnI0ZGMDBGRicsICcjRkYzMzAwJywgJyNGRjMzMzMnLCAnI0ZGMzM2NicsICcjRkYzMzk5JywgJyNGRjMzQ0MnLCAnI0ZGMzNGRicsXG4gICcjRkY2NjAwJywgJyNGRjY2MzMnLCAnI0ZGOTkwMCcsICcjRkY5OTMzJywgJyNGRkNDMDAnLCAnI0ZGQ0MzMydcbl07XG5cbi8qKlxuICogQ3VycmVudGx5IG9ubHkgV2ViS2l0LWJhc2VkIFdlYiBJbnNwZWN0b3JzLCBGaXJlZm94ID49IHYzMSxcbiAqIGFuZCB0aGUgRmlyZWJ1ZyBleHRlbnNpb24gKGFueSBGaXJlZm94IHZlcnNpb24pIGFyZSBrbm93blxuICogdG8gc3VwcG9ydCBcIiVjXCIgQ1NTIGN1c3RvbWl6YXRpb25zLlxuICpcbiAqIFRPRE86IGFkZCBhIGBsb2NhbFN0b3JhZ2VgIHZhcmlhYmxlIHRvIGV4cGxpY2l0bHkgZW5hYmxlL2Rpc2FibGUgY29sb3JzXG4gKi9cblxuZnVuY3Rpb24gdXNlQ29sb3JzKCkge1xuICAvLyBOQjogSW4gYW4gRWxlY3Ryb24gcHJlbG9hZCBzY3JpcHQsIGRvY3VtZW50IHdpbGwgYmUgZGVmaW5lZCBidXQgbm90IGZ1bGx5XG4gIC8vIGluaXRpYWxpemVkLiBTaW5jZSB3ZSBrbm93IHdlJ3JlIGluIENocm9tZSwgd2UnbGwganVzdCBkZXRlY3QgdGhpcyBjYXNlXG4gIC8vIGV4cGxpY2l0bHlcbiAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHdpbmRvdy5wcm9jZXNzICYmIHdpbmRvdy5wcm9jZXNzLnR5cGUgPT09ICdyZW5kZXJlcicpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIC8vIEludGVybmV0IEV4cGxvcmVyIGFuZCBFZGdlIGRvIG5vdCBzdXBwb3J0IGNvbG9ycy5cbiAgaWYgKHR5cGVvZiBuYXZpZ2F0b3IgIT09ICd1bmRlZmluZWQnICYmIG5hdmlnYXRvci51c2VyQWdlbnQgJiYgbmF2aWdhdG9yLnVzZXJBZ2VudC50b0xvd2VyQ2FzZSgpLm1hdGNoKC8oZWRnZXx0cmlkZW50KVxcLyhcXGQrKS8pKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgLy8gaXMgd2Via2l0PyBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8xNjQ1OTYwNi8zNzY3NzNcbiAgLy8gZG9jdW1lbnQgaXMgdW5kZWZpbmVkIGluIHJlYWN0LW5hdGl2ZTogaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0LW5hdGl2ZS9wdWxsLzE2MzJcbiAgcmV0dXJuICh0eXBlb2YgZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnICYmIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCAmJiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc3R5bGUgJiYgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnN0eWxlLldlYmtpdEFwcGVhcmFuY2UpIHx8XG4gICAgLy8gaXMgZmlyZWJ1Zz8gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMzk4MTIwLzM3Njc3M1xuICAgICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB3aW5kb3cuY29uc29sZSAmJiAod2luZG93LmNvbnNvbGUuZmlyZWJ1ZyB8fCAod2luZG93LmNvbnNvbGUuZXhjZXB0aW9uICYmIHdpbmRvdy5jb25zb2xlLnRhYmxlKSkpIHx8XG4gICAgLy8gaXMgZmlyZWZveCA+PSB2MzE/XG4gICAgLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9Ub29scy9XZWJfQ29uc29sZSNTdHlsaW5nX21lc3NhZ2VzXG4gICAgKHR5cGVvZiBuYXZpZ2F0b3IgIT09ICd1bmRlZmluZWQnICYmIG5hdmlnYXRvci51c2VyQWdlbnQgJiYgbmF2aWdhdG9yLnVzZXJBZ2VudC50b0xvd2VyQ2FzZSgpLm1hdGNoKC9maXJlZm94XFwvKFxcZCspLykgJiYgcGFyc2VJbnQoUmVnRXhwLiQxLCAxMCkgPj0gMzEpIHx8XG4gICAgLy8gZG91YmxlIGNoZWNrIHdlYmtpdCBpbiB1c2VyQWdlbnQganVzdCBpbiBjYXNlIHdlIGFyZSBpbiBhIHdvcmtlclxuICAgICh0eXBlb2YgbmF2aWdhdG9yICE9PSAndW5kZWZpbmVkJyAmJiBuYXZpZ2F0b3IudXNlckFnZW50ICYmIG5hdmlnYXRvci51c2VyQWdlbnQudG9Mb3dlckNhc2UoKS5tYXRjaCgvYXBwbGV3ZWJraXRcXC8oXFxkKykvKSk7XG59XG5cbi8qKlxuICogTWFwICVqIHRvIGBKU09OLnN0cmluZ2lmeSgpYCwgc2luY2Ugbm8gV2ViIEluc3BlY3RvcnMgZG8gdGhhdCBieSBkZWZhdWx0LlxuICovXG5cbmV4cG9ydHMuZm9ybWF0dGVycy5qID0gZnVuY3Rpb24odikge1xuICB0cnkge1xuICAgIHJldHVybiBKU09OLnN0cmluZ2lmeSh2KTtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgcmV0dXJuICdbVW5leHBlY3RlZEpTT05QYXJzZUVycm9yXTogJyArIGVyci5tZXNzYWdlO1xuICB9XG59O1xuXG5cbi8qKlxuICogQ29sb3JpemUgbG9nIGFyZ3VtZW50cyBpZiBlbmFibGVkLlxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gZm9ybWF0QXJncyhhcmdzKSB7XG4gIHZhciB1c2VDb2xvcnMgPSB0aGlzLnVzZUNvbG9ycztcblxuICBhcmdzWzBdID0gKHVzZUNvbG9ycyA/ICclYycgOiAnJylcbiAgICArIHRoaXMubmFtZXNwYWNlXG4gICAgKyAodXNlQ29sb3JzID8gJyAlYycgOiAnICcpXG4gICAgKyBhcmdzWzBdXG4gICAgKyAodXNlQ29sb3JzID8gJyVjICcgOiAnICcpXG4gICAgKyAnKycgKyBleHBvcnRzLmh1bWFuaXplKHRoaXMuZGlmZik7XG5cbiAgaWYgKCF1c2VDb2xvcnMpIHJldHVybjtcblxuICB2YXIgYyA9ICdjb2xvcjogJyArIHRoaXMuY29sb3I7XG4gIGFyZ3Muc3BsaWNlKDEsIDAsIGMsICdjb2xvcjogaW5oZXJpdCcpXG5cbiAgLy8gdGhlIGZpbmFsIFwiJWNcIiBpcyBzb21ld2hhdCB0cmlja3ksIGJlY2F1c2UgdGhlcmUgY291bGQgYmUgb3RoZXJcbiAgLy8gYXJndW1lbnRzIHBhc3NlZCBlaXRoZXIgYmVmb3JlIG9yIGFmdGVyIHRoZSAlYywgc28gd2UgbmVlZCB0b1xuICAvLyBmaWd1cmUgb3V0IHRoZSBjb3JyZWN0IGluZGV4IHRvIGluc2VydCB0aGUgQ1NTIGludG9cbiAgdmFyIGluZGV4ID0gMDtcbiAgdmFyIGxhc3RDID0gMDtcbiAgYXJnc1swXS5yZXBsYWNlKC8lW2EtekEtWiVdL2csIGZ1bmN0aW9uKG1hdGNoKSB7XG4gICAgaWYgKCclJScgPT09IG1hdGNoKSByZXR1cm47XG4gICAgaW5kZXgrKztcbiAgICBpZiAoJyVjJyA9PT0gbWF0Y2gpIHtcbiAgICAgIC8vIHdlIG9ubHkgYXJlIGludGVyZXN0ZWQgaW4gdGhlICpsYXN0KiAlY1xuICAgICAgLy8gKHRoZSB1c2VyIG1heSBoYXZlIHByb3ZpZGVkIHRoZWlyIG93bilcbiAgICAgIGxhc3RDID0gaW5kZXg7XG4gICAgfVxuICB9KTtcblxuICBhcmdzLnNwbGljZShsYXN0QywgMCwgYyk7XG59XG5cbi8qKlxuICogSW52b2tlcyBgY29uc29sZS5sb2coKWAgd2hlbiBhdmFpbGFibGUuXG4gKiBOby1vcCB3aGVuIGBjb25zb2xlLmxvZ2AgaXMgbm90IGEgXCJmdW5jdGlvblwiLlxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gbG9nKCkge1xuICAvLyB0aGlzIGhhY2tlcnkgaXMgcmVxdWlyZWQgZm9yIElFOC85LCB3aGVyZVxuICAvLyB0aGUgYGNvbnNvbGUubG9nYCBmdW5jdGlvbiBkb2Vzbid0IGhhdmUgJ2FwcGx5J1xuICByZXR1cm4gJ29iamVjdCcgPT09IHR5cGVvZiBjb25zb2xlXG4gICAgJiYgY29uc29sZS5sb2dcbiAgICAmJiBGdW5jdGlvbi5wcm90b3R5cGUuYXBwbHkuY2FsbChjb25zb2xlLmxvZywgY29uc29sZSwgYXJndW1lbnRzKTtcbn1cblxuLyoqXG4gKiBTYXZlIGBuYW1lc3BhY2VzYC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZXNwYWNlc1xuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gc2F2ZShuYW1lc3BhY2VzKSB7XG4gIHRyeSB7XG4gICAgaWYgKG51bGwgPT0gbmFtZXNwYWNlcykge1xuICAgICAgZXhwb3J0cy5zdG9yYWdlLnJlbW92ZUl0ZW0oJ2RlYnVnJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGV4cG9ydHMuc3RvcmFnZS5kZWJ1ZyA9IG5hbWVzcGFjZXM7XG4gICAgfVxuICB9IGNhdGNoKGUpIHt9XG59XG5cbi8qKlxuICogTG9hZCBgbmFtZXNwYWNlc2AuXG4gKlxuICogQHJldHVybiB7U3RyaW5nfSByZXR1cm5zIHRoZSBwcmV2aW91c2x5IHBlcnNpc3RlZCBkZWJ1ZyBtb2Rlc1xuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gbG9hZCgpIHtcbiAgdmFyIHI7XG4gIHRyeSB7XG4gICAgciA9IGV4cG9ydHMuc3RvcmFnZS5kZWJ1ZztcbiAgfSBjYXRjaChlKSB7fVxuXG4gIC8vIElmIGRlYnVnIGlzbid0IHNldCBpbiBMUywgYW5kIHdlJ3JlIGluIEVsZWN0cm9uLCB0cnkgdG8gbG9hZCAkREVCVUdcbiAgaWYgKCFyICYmIHR5cGVvZiBwcm9jZXNzICE9PSAndW5kZWZpbmVkJyAmJiAnZW52JyBpbiBwcm9jZXNzKSB7XG4gICAgciA9IHByb2Nlc3MuZW52LkRFQlVHO1xuICB9XG5cbiAgcmV0dXJuIHI7XG59XG5cbi8qKlxuICogRW5hYmxlIG5hbWVzcGFjZXMgbGlzdGVkIGluIGBsb2NhbFN0b3JhZ2UuZGVidWdgIGluaXRpYWxseS5cbiAqL1xuXG5leHBvcnRzLmVuYWJsZShsb2FkKCkpO1xuXG4vKipcbiAqIExvY2Fsc3RvcmFnZSBhdHRlbXB0cyB0byByZXR1cm4gdGhlIGxvY2Fsc3RvcmFnZS5cbiAqXG4gKiBUaGlzIGlzIG5lY2Vzc2FyeSBiZWNhdXNlIHNhZmFyaSB0aHJvd3NcbiAqIHdoZW4gYSB1c2VyIGRpc2FibGVzIGNvb2tpZXMvbG9jYWxzdG9yYWdlXG4gKiBhbmQgeW91IGF0dGVtcHQgdG8gYWNjZXNzIGl0LlxuICpcbiAqIEByZXR1cm4ge0xvY2FsU3RvcmFnZX1cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIGxvY2Fsc3RvcmFnZSgpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gd2luZG93LmxvY2FsU3RvcmFnZTtcbiAgfSBjYXRjaCAoZSkge31cbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9lbGVjdHJvbi11cGRhdGVyL25vZGVfbW9kdWxlcy9kZWJ1Zy9zcmMvYnJvd3Nlci5qcyIsIi8qKlxuICogSGVscGVycy5cbiAqL1xuXG52YXIgcyA9IDEwMDA7XG52YXIgbSA9IHMgKiA2MDtcbnZhciBoID0gbSAqIDYwO1xudmFyIGQgPSBoICogMjQ7XG52YXIgeSA9IGQgKiAzNjUuMjU7XG5cbi8qKlxuICogUGFyc2Ugb3IgZm9ybWF0IHRoZSBnaXZlbiBgdmFsYC5cbiAqXG4gKiBPcHRpb25zOlxuICpcbiAqICAtIGBsb25nYCB2ZXJib3NlIGZvcm1hdHRpbmcgW2ZhbHNlXVxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfE51bWJlcn0gdmFsXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXG4gKiBAdGhyb3dzIHtFcnJvcn0gdGhyb3cgYW4gZXJyb3IgaWYgdmFsIGlzIG5vdCBhIG5vbi1lbXB0eSBzdHJpbmcgb3IgYSBudW1iZXJcbiAqIEByZXR1cm4ge1N0cmluZ3xOdW1iZXJ9XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24odmFsLCBvcHRpb25zKSB7XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICB2YXIgdHlwZSA9IHR5cGVvZiB2YWw7XG4gIGlmICh0eXBlID09PSAnc3RyaW5nJyAmJiB2YWwubGVuZ3RoID4gMCkge1xuICAgIHJldHVybiBwYXJzZSh2YWwpO1xuICB9IGVsc2UgaWYgKHR5cGUgPT09ICdudW1iZXInICYmIGlzTmFOKHZhbCkgPT09IGZhbHNlKSB7XG4gICAgcmV0dXJuIG9wdGlvbnMubG9uZyA/IGZtdExvbmcodmFsKSA6IGZtdFNob3J0KHZhbCk7XG4gIH1cbiAgdGhyb3cgbmV3IEVycm9yKFxuICAgICd2YWwgaXMgbm90IGEgbm9uLWVtcHR5IHN0cmluZyBvciBhIHZhbGlkIG51bWJlci4gdmFsPScgK1xuICAgICAgSlNPTi5zdHJpbmdpZnkodmFsKVxuICApO1xufTtcblxuLyoqXG4gKiBQYXJzZSB0aGUgZ2l2ZW4gYHN0cmAgYW5kIHJldHVybiBtaWxsaXNlY29uZHMuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHN0clxuICogQHJldHVybiB7TnVtYmVyfVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gcGFyc2Uoc3RyKSB7XG4gIHN0ciA9IFN0cmluZyhzdHIpO1xuICBpZiAoc3RyLmxlbmd0aCA+IDEwMCkge1xuICAgIHJldHVybjtcbiAgfVxuICB2YXIgbWF0Y2ggPSAvXigoPzpcXGQrKT9cXC4/XFxkKykgKihtaWxsaXNlY29uZHM/fG1zZWNzP3xtc3xzZWNvbmRzP3xzZWNzP3xzfG1pbnV0ZXM/fG1pbnM/fG18aG91cnM/fGhycz98aHxkYXlzP3xkfHllYXJzP3x5cnM/fHkpPyQvaS5leGVjKFxuICAgIHN0clxuICApO1xuICBpZiAoIW1hdGNoKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHZhciBuID0gcGFyc2VGbG9hdChtYXRjaFsxXSk7XG4gIHZhciB0eXBlID0gKG1hdGNoWzJdIHx8ICdtcycpLnRvTG93ZXJDYXNlKCk7XG4gIHN3aXRjaCAodHlwZSkge1xuICAgIGNhc2UgJ3llYXJzJzpcbiAgICBjYXNlICd5ZWFyJzpcbiAgICBjYXNlICd5cnMnOlxuICAgIGNhc2UgJ3lyJzpcbiAgICBjYXNlICd5JzpcbiAgICAgIHJldHVybiBuICogeTtcbiAgICBjYXNlICdkYXlzJzpcbiAgICBjYXNlICdkYXknOlxuICAgIGNhc2UgJ2QnOlxuICAgICAgcmV0dXJuIG4gKiBkO1xuICAgIGNhc2UgJ2hvdXJzJzpcbiAgICBjYXNlICdob3VyJzpcbiAgICBjYXNlICdocnMnOlxuICAgIGNhc2UgJ2hyJzpcbiAgICBjYXNlICdoJzpcbiAgICAgIHJldHVybiBuICogaDtcbiAgICBjYXNlICdtaW51dGVzJzpcbiAgICBjYXNlICdtaW51dGUnOlxuICAgIGNhc2UgJ21pbnMnOlxuICAgIGNhc2UgJ21pbic6XG4gICAgY2FzZSAnbSc6XG4gICAgICByZXR1cm4gbiAqIG07XG4gICAgY2FzZSAnc2Vjb25kcyc6XG4gICAgY2FzZSAnc2Vjb25kJzpcbiAgICBjYXNlICdzZWNzJzpcbiAgICBjYXNlICdzZWMnOlxuICAgIGNhc2UgJ3MnOlxuICAgICAgcmV0dXJuIG4gKiBzO1xuICAgIGNhc2UgJ21pbGxpc2Vjb25kcyc6XG4gICAgY2FzZSAnbWlsbGlzZWNvbmQnOlxuICAgIGNhc2UgJ21zZWNzJzpcbiAgICBjYXNlICdtc2VjJzpcbiAgICBjYXNlICdtcyc6XG4gICAgICByZXR1cm4gbjtcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxufVxuXG4vKipcbiAqIFNob3J0IGZvcm1hdCBmb3IgYG1zYC5cbiAqXG4gKiBAcGFyYW0ge051bWJlcn0gbXNcbiAqIEByZXR1cm4ge1N0cmluZ31cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIGZtdFNob3J0KG1zKSB7XG4gIGlmIChtcyA+PSBkKSB7XG4gICAgcmV0dXJuIE1hdGgucm91bmQobXMgLyBkKSArICdkJztcbiAgfVxuICBpZiAobXMgPj0gaCkge1xuICAgIHJldHVybiBNYXRoLnJvdW5kKG1zIC8gaCkgKyAnaCc7XG4gIH1cbiAgaWYgKG1zID49IG0pIHtcbiAgICByZXR1cm4gTWF0aC5yb3VuZChtcyAvIG0pICsgJ20nO1xuICB9XG4gIGlmIChtcyA+PSBzKSB7XG4gICAgcmV0dXJuIE1hdGgucm91bmQobXMgLyBzKSArICdzJztcbiAgfVxuICByZXR1cm4gbXMgKyAnbXMnO1xufVxuXG4vKipcbiAqIExvbmcgZm9ybWF0IGZvciBgbXNgLlxuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSBtc1xuICogQHJldHVybiB7U3RyaW5nfVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gZm10TG9uZyhtcykge1xuICByZXR1cm4gcGx1cmFsKG1zLCBkLCAnZGF5JykgfHxcbiAgICBwbHVyYWwobXMsIGgsICdob3VyJykgfHxcbiAgICBwbHVyYWwobXMsIG0sICdtaW51dGUnKSB8fFxuICAgIHBsdXJhbChtcywgcywgJ3NlY29uZCcpIHx8XG4gICAgbXMgKyAnIG1zJztcbn1cblxuLyoqXG4gKiBQbHVyYWxpemF0aW9uIGhlbHBlci5cbiAqL1xuXG5mdW5jdGlvbiBwbHVyYWwobXMsIG4sIG5hbWUpIHtcbiAgaWYgKG1zIDwgbikge1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAobXMgPCBuICogMS41KSB7XG4gICAgcmV0dXJuIE1hdGguZmxvb3IobXMgLyBuKSArICcgJyArIG5hbWU7XG4gIH1cbiAgcmV0dXJuIE1hdGguY2VpbChtcyAvIG4pICsgJyAnICsgbmFtZSArICdzJztcbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9tcy9pbmRleC5qcyIsIi8qKlxuICogTW9kdWxlIGRlcGVuZGVuY2llcy5cbiAqL1xuXG52YXIgdHR5ID0gcmVxdWlyZSgndHR5Jyk7XG52YXIgdXRpbCA9IHJlcXVpcmUoJ3V0aWwnKTtcblxuLyoqXG4gKiBUaGlzIGlzIHRoZSBOb2RlLmpzIGltcGxlbWVudGF0aW9uIG9mIGBkZWJ1ZygpYC5cbiAqXG4gKiBFeHBvc2UgYGRlYnVnKClgIGFzIHRoZSBtb2R1bGUuXG4gKi9cblxuZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9kZWJ1ZycpO1xuZXhwb3J0cy5pbml0ID0gaW5pdDtcbmV4cG9ydHMubG9nID0gbG9nO1xuZXhwb3J0cy5mb3JtYXRBcmdzID0gZm9ybWF0QXJncztcbmV4cG9ydHMuc2F2ZSA9IHNhdmU7XG5leHBvcnRzLmxvYWQgPSBsb2FkO1xuZXhwb3J0cy51c2VDb2xvcnMgPSB1c2VDb2xvcnM7XG5cbi8qKlxuICogQ29sb3JzLlxuICovXG5cbmV4cG9ydHMuY29sb3JzID0gWyA2LCAyLCAzLCA0LCA1LCAxIF07XG5cbnRyeSB7XG4gIHZhciBzdXBwb3J0c0NvbG9yID0gcmVxdWlyZSgnc3VwcG9ydHMtY29sb3InKTtcbiAgaWYgKHN1cHBvcnRzQ29sb3IgJiYgc3VwcG9ydHNDb2xvci5sZXZlbCA+PSAyKSB7XG4gICAgZXhwb3J0cy5jb2xvcnMgPSBbXG4gICAgICAyMCwgMjEsIDI2LCAyNywgMzIsIDMzLCAzOCwgMzksIDQwLCA0MSwgNDIsIDQzLCA0NCwgNDUsIDU2LCA1NywgNjIsIDYzLCA2OCxcbiAgICAgIDY5LCA3NCwgNzUsIDc2LCA3NywgNzgsIDc5LCA4MCwgODEsIDkyLCA5MywgOTgsIDk5LCAxMTIsIDExMywgMTI4LCAxMjksIDEzNCxcbiAgICAgIDEzNSwgMTQ4LCAxNDksIDE2MCwgMTYxLCAxNjIsIDE2MywgMTY0LCAxNjUsIDE2NiwgMTY3LCAxNjgsIDE2OSwgMTcwLCAxNzEsXG4gICAgICAxNzIsIDE3MywgMTc4LCAxNzksIDE4NCwgMTg1LCAxOTYsIDE5NywgMTk4LCAxOTksIDIwMCwgMjAxLCAyMDIsIDIwMywgMjA0LFxuICAgICAgMjA1LCAyMDYsIDIwNywgMjA4LCAyMDksIDIxNCwgMjE1LCAyMjAsIDIyMVxuICAgIF07XG4gIH1cbn0gY2F0Y2ggKGVycikge1xuICAvLyBzd2FsbG93IC0gd2Ugb25seSBjYXJlIGlmIGBzdXBwb3J0cy1jb2xvcmAgaXMgYXZhaWxhYmxlOyBpdCBkb2Vzbid0IGhhdmUgdG8gYmUuXG59XG5cbi8qKlxuICogQnVpbGQgdXAgdGhlIGRlZmF1bHQgYGluc3BlY3RPcHRzYCBvYmplY3QgZnJvbSB0aGUgZW52aXJvbm1lbnQgdmFyaWFibGVzLlxuICpcbiAqICAgJCBERUJVR19DT0xPUlM9bm8gREVCVUdfREVQVEg9MTAgREVCVUdfU0hPV19ISURERU49ZW5hYmxlZCBub2RlIHNjcmlwdC5qc1xuICovXG5cbmV4cG9ydHMuaW5zcGVjdE9wdHMgPSBPYmplY3Qua2V5cyhwcm9jZXNzLmVudikuZmlsdGVyKGZ1bmN0aW9uIChrZXkpIHtcbiAgcmV0dXJuIC9eZGVidWdfL2kudGVzdChrZXkpO1xufSkucmVkdWNlKGZ1bmN0aW9uIChvYmosIGtleSkge1xuICAvLyBjYW1lbC1jYXNlXG4gIHZhciBwcm9wID0ga2V5XG4gICAgLnN1YnN0cmluZyg2KVxuICAgIC50b0xvd2VyQ2FzZSgpXG4gICAgLnJlcGxhY2UoL18oW2Etel0pL2csIGZ1bmN0aW9uIChfLCBrKSB7IHJldHVybiBrLnRvVXBwZXJDYXNlKCkgfSk7XG5cbiAgLy8gY29lcmNlIHN0cmluZyB2YWx1ZSBpbnRvIEpTIHZhbHVlXG4gIHZhciB2YWwgPSBwcm9jZXNzLmVudltrZXldO1xuICBpZiAoL14oeWVzfG9ufHRydWV8ZW5hYmxlZCkkL2kudGVzdCh2YWwpKSB2YWwgPSB0cnVlO1xuICBlbHNlIGlmICgvXihub3xvZmZ8ZmFsc2V8ZGlzYWJsZWQpJC9pLnRlc3QodmFsKSkgdmFsID0gZmFsc2U7XG4gIGVsc2UgaWYgKHZhbCA9PT0gJ251bGwnKSB2YWwgPSBudWxsO1xuICBlbHNlIHZhbCA9IE51bWJlcih2YWwpO1xuXG4gIG9ialtwcm9wXSA9IHZhbDtcbiAgcmV0dXJuIG9iajtcbn0sIHt9KTtcblxuLyoqXG4gKiBJcyBzdGRvdXQgYSBUVFk/IENvbG9yZWQgb3V0cHV0IGlzIGVuYWJsZWQgd2hlbiBgdHJ1ZWAuXG4gKi9cblxuZnVuY3Rpb24gdXNlQ29sb3JzKCkge1xuICByZXR1cm4gJ2NvbG9ycycgaW4gZXhwb3J0cy5pbnNwZWN0T3B0c1xuICAgID8gQm9vbGVhbihleHBvcnRzLmluc3BlY3RPcHRzLmNvbG9ycylcbiAgICA6IHR0eS5pc2F0dHkocHJvY2Vzcy5zdGRlcnIuZmQpO1xufVxuXG4vKipcbiAqIE1hcCAlbyB0byBgdXRpbC5pbnNwZWN0KClgLCBhbGwgb24gYSBzaW5nbGUgbGluZS5cbiAqL1xuXG5leHBvcnRzLmZvcm1hdHRlcnMubyA9IGZ1bmN0aW9uKHYpIHtcbiAgdGhpcy5pbnNwZWN0T3B0cy5jb2xvcnMgPSB0aGlzLnVzZUNvbG9ycztcbiAgcmV0dXJuIHV0aWwuaW5zcGVjdCh2LCB0aGlzLmluc3BlY3RPcHRzKVxuICAgIC5zcGxpdCgnXFxuJykubWFwKGZ1bmN0aW9uKHN0cikge1xuICAgICAgcmV0dXJuIHN0ci50cmltKClcbiAgICB9KS5qb2luKCcgJyk7XG59O1xuXG4vKipcbiAqIE1hcCAlbyB0byBgdXRpbC5pbnNwZWN0KClgLCBhbGxvd2luZyBtdWx0aXBsZSBsaW5lcyBpZiBuZWVkZWQuXG4gKi9cblxuZXhwb3J0cy5mb3JtYXR0ZXJzLk8gPSBmdW5jdGlvbih2KSB7XG4gIHRoaXMuaW5zcGVjdE9wdHMuY29sb3JzID0gdGhpcy51c2VDb2xvcnM7XG4gIHJldHVybiB1dGlsLmluc3BlY3QodiwgdGhpcy5pbnNwZWN0T3B0cyk7XG59O1xuXG4vKipcbiAqIEFkZHMgQU5TSSBjb2xvciBlc2NhcGUgY29kZXMgaWYgZW5hYmxlZC5cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIGZvcm1hdEFyZ3MoYXJncykge1xuICB2YXIgbmFtZSA9IHRoaXMubmFtZXNwYWNlO1xuICB2YXIgdXNlQ29sb3JzID0gdGhpcy51c2VDb2xvcnM7XG5cbiAgaWYgKHVzZUNvbG9ycykge1xuICAgIHZhciBjID0gdGhpcy5jb2xvcjtcbiAgICB2YXIgY29sb3JDb2RlID0gJ1xcdTAwMWJbMycgKyAoYyA8IDggPyBjIDogJzg7NTsnICsgYyk7XG4gICAgdmFyIHByZWZpeCA9ICcgICcgKyBjb2xvckNvZGUgKyAnOzFtJyArIG5hbWUgKyAnICcgKyAnXFx1MDAxYlswbSc7XG5cbiAgICBhcmdzWzBdID0gcHJlZml4ICsgYXJnc1swXS5zcGxpdCgnXFxuJykuam9pbignXFxuJyArIHByZWZpeCk7XG4gICAgYXJncy5wdXNoKGNvbG9yQ29kZSArICdtKycgKyBleHBvcnRzLmh1bWFuaXplKHRoaXMuZGlmZikgKyAnXFx1MDAxYlswbScpO1xuICB9IGVsc2Uge1xuICAgIGFyZ3NbMF0gPSBnZXREYXRlKCkgKyBuYW1lICsgJyAnICsgYXJnc1swXTtcbiAgfVxufVxuXG5mdW5jdGlvbiBnZXREYXRlKCkge1xuICBpZiAoZXhwb3J0cy5pbnNwZWN0T3B0cy5oaWRlRGF0ZSkge1xuICAgIHJldHVybiAnJztcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gbmV3IERhdGUoKS50b0lTT1N0cmluZygpICsgJyAnO1xuICB9XG59XG5cbi8qKlxuICogSW52b2tlcyBgdXRpbC5mb3JtYXQoKWAgd2l0aCB0aGUgc3BlY2lmaWVkIGFyZ3VtZW50cyBhbmQgd3JpdGVzIHRvIHN0ZGVyci5cbiAqL1xuXG5mdW5jdGlvbiBsb2coKSB7XG4gIHJldHVybiBwcm9jZXNzLnN0ZGVyci53cml0ZSh1dGlsLmZvcm1hdC5hcHBseSh1dGlsLCBhcmd1bWVudHMpICsgJ1xcbicpO1xufVxuXG4vKipcbiAqIFNhdmUgYG5hbWVzcGFjZXNgLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lc3BhY2VzXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBzYXZlKG5hbWVzcGFjZXMpIHtcbiAgaWYgKG51bGwgPT0gbmFtZXNwYWNlcykge1xuICAgIC8vIElmIHlvdSBzZXQgYSBwcm9jZXNzLmVudiBmaWVsZCB0byBudWxsIG9yIHVuZGVmaW5lZCwgaXQgZ2V0cyBjYXN0IHRvIHRoZVxuICAgIC8vIHN0cmluZyAnbnVsbCcgb3IgJ3VuZGVmaW5lZCcuIEp1c3QgZGVsZXRlIGluc3RlYWQuXG4gICAgZGVsZXRlIHByb2Nlc3MuZW52LkRFQlVHO1xuICB9IGVsc2Uge1xuICAgIHByb2Nlc3MuZW52LkRFQlVHID0gbmFtZXNwYWNlcztcbiAgfVxufVxuXG4vKipcbiAqIExvYWQgYG5hbWVzcGFjZXNgLlxuICpcbiAqIEByZXR1cm4ge1N0cmluZ30gcmV0dXJucyB0aGUgcHJldmlvdXNseSBwZXJzaXN0ZWQgZGVidWcgbW9kZXNcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIGxvYWQoKSB7XG4gIHJldHVybiBwcm9jZXNzLmVudi5ERUJVRztcbn1cblxuLyoqXG4gKiBJbml0IGxvZ2ljIGZvciBgZGVidWdgIGluc3RhbmNlcy5cbiAqXG4gKiBDcmVhdGUgYSBuZXcgYGluc3BlY3RPcHRzYCBvYmplY3QgaW4gY2FzZSBgdXNlQ29sb3JzYCBpcyBzZXRcbiAqIGRpZmZlcmVudGx5IGZvciBhIHBhcnRpY3VsYXIgYGRlYnVnYCBpbnN0YW5jZS5cbiAqL1xuXG5mdW5jdGlvbiBpbml0IChkZWJ1Zykge1xuICBkZWJ1Zy5pbnNwZWN0T3B0cyA9IHt9O1xuXG4gIHZhciBrZXlzID0gT2JqZWN0LmtleXMoZXhwb3J0cy5pbnNwZWN0T3B0cyk7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkrKykge1xuICAgIGRlYnVnLmluc3BlY3RPcHRzW2tleXNbaV1dID0gZXhwb3J0cy5pbnNwZWN0T3B0c1trZXlzW2ldXTtcbiAgfVxufVxuXG4vKipcbiAqIEVuYWJsZSBuYW1lc3BhY2VzIGxpc3RlZCBpbiBgcHJvY2Vzcy5lbnYuREVCVUdgIGluaXRpYWxseS5cbiAqL1xuXG5leHBvcnRzLmVuYWJsZShsb2FkKCkpO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2VsZWN0cm9uLXVwZGF0ZXIvbm9kZV9tb2R1bGVzL2RlYnVnL3NyYy9ub2RlLmpzIiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwidHR5XCIpO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIGV4dGVybmFsIFwidHR5XCJcbi8vIG1vZHVsZSBpZCA9IDEwNFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIndXNlIHN0cmljdCc7XG5jb25zdCBvcyA9IHJlcXVpcmUoJ29zJyk7XG5jb25zdCBoYXNGbGFnID0gcmVxdWlyZSgnaGFzLWZsYWcnKTtcblxuY29uc3QgZW52ID0gcHJvY2Vzcy5lbnY7XG5cbmNvbnN0IHN1cHBvcnQgPSBsZXZlbCA9PiB7XG5cdGlmIChsZXZlbCA9PT0gMCkge1xuXHRcdHJldHVybiBmYWxzZTtcblx0fVxuXG5cdHJldHVybiB7XG5cdFx0bGV2ZWwsXG5cdFx0aGFzQmFzaWM6IHRydWUsXG5cdFx0aGFzMjU2OiBsZXZlbCA+PSAyLFxuXHRcdGhhczE2bTogbGV2ZWwgPj0gM1xuXHR9O1xufTtcblxubGV0IHN1cHBvcnRMZXZlbCA9ICgoKSA9PiB7XG5cdGlmIChoYXNGbGFnKCduby1jb2xvcicpIHx8XG5cdFx0aGFzRmxhZygnbm8tY29sb3JzJykgfHxcblx0XHRoYXNGbGFnKCdjb2xvcj1mYWxzZScpKSB7XG5cdFx0cmV0dXJuIDA7XG5cdH1cblxuXHRpZiAoaGFzRmxhZygnY29sb3I9MTZtJykgfHxcblx0XHRoYXNGbGFnKCdjb2xvcj1mdWxsJykgfHxcblx0XHRoYXNGbGFnKCdjb2xvcj10cnVlY29sb3InKSkge1xuXHRcdHJldHVybiAzO1xuXHR9XG5cblx0aWYgKGhhc0ZsYWcoJ2NvbG9yPTI1NicpKSB7XG5cdFx0cmV0dXJuIDI7XG5cdH1cblxuXHRpZiAoaGFzRmxhZygnY29sb3InKSB8fFxuXHRcdGhhc0ZsYWcoJ2NvbG9ycycpIHx8XG5cdFx0aGFzRmxhZygnY29sb3I9dHJ1ZScpIHx8XG5cdFx0aGFzRmxhZygnY29sb3I9YWx3YXlzJykpIHtcblx0XHRyZXR1cm4gMTtcblx0fVxuXG5cdGlmIChwcm9jZXNzLnN0ZG91dCAmJiAhcHJvY2Vzcy5zdGRvdXQuaXNUVFkpIHtcblx0XHRyZXR1cm4gMDtcblx0fVxuXG5cdGlmIChwcm9jZXNzLnBsYXRmb3JtID09PSAnd2luMzInKSB7XG5cdFx0Ly8gTm9kZS5qcyA3LjUuMCBpcyB0aGUgZmlyc3QgdmVyc2lvbiBvZiBOb2RlLmpzIHRvIGluY2x1ZGUgYSBwYXRjaCB0b1xuXHRcdC8vIGxpYnV2IHRoYXQgZW5hYmxlcyAyNTYgY29sb3Igb3V0cHV0IG9uIFdpbmRvd3MuIEFueXRoaW5nIGVhcmxpZXIgYW5kIGl0XG5cdFx0Ly8gd29uJ3Qgd29yay4gSG93ZXZlciwgaGVyZSB3ZSB0YXJnZXQgTm9kZS5qcyA4IGF0IG1pbmltdW0gYXMgaXQgaXMgYW4gTFRTXG5cdFx0Ly8gcmVsZWFzZSwgYW5kIE5vZGUuanMgNyBpcyBub3QuIFdpbmRvd3MgMTAgYnVpbGQgMTA1ODYgaXMgdGhlIGZpcnN0IFdpbmRvd3Ncblx0XHQvLyByZWxlYXNlIHRoYXQgc3VwcG9ydHMgMjU2IGNvbG9ycy5cblx0XHRjb25zdCBvc1JlbGVhc2UgPSBvcy5yZWxlYXNlKCkuc3BsaXQoJy4nKTtcblx0XHRpZiAoXG5cdFx0XHROdW1iZXIocHJvY2Vzcy52ZXJzaW9ucy5ub2RlLnNwbGl0KCcuJylbMF0pID49IDggJiZcblx0XHRcdE51bWJlcihvc1JlbGVhc2VbMF0pID49IDEwICYmXG5cdFx0XHROdW1iZXIob3NSZWxlYXNlWzJdKSA+PSAxMDU4NlxuXHRcdCkge1xuXHRcdFx0cmV0dXJuIDI7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIDE7XG5cdH1cblxuXHRpZiAoJ0NJJyBpbiBlbnYpIHtcblx0XHRpZiAoWydUUkFWSVMnLCAnQ0lSQ0xFQ0knLCAnQVBQVkVZT1InLCAnR0lUTEFCX0NJJ10uc29tZShzaWduID0+IHNpZ24gaW4gZW52KSB8fCBlbnYuQ0lfTkFNRSA9PT0gJ2NvZGVzaGlwJykge1xuXHRcdFx0cmV0dXJuIDE7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIDA7XG5cdH1cblxuXHRpZiAoJ1RFQU1DSVRZX1ZFUlNJT04nIGluIGVudikge1xuXHRcdHJldHVybiAvXig5XFwuKDAqWzEtOV1cXGQqKVxcLnxcXGR7Mix9XFwuKS8udGVzdChlbnYuVEVBTUNJVFlfVkVSU0lPTikgPyAxIDogMDtcblx0fVxuXG5cdGlmICgnVEVSTV9QUk9HUkFNJyBpbiBlbnYpIHtcblx0XHRjb25zdCB2ZXJzaW9uID0gcGFyc2VJbnQoKGVudi5URVJNX1BST0dSQU1fVkVSU0lPTiB8fCAnJykuc3BsaXQoJy4nKVswXSwgMTApO1xuXG5cdFx0c3dpdGNoIChlbnYuVEVSTV9QUk9HUkFNKSB7XG5cdFx0XHRjYXNlICdpVGVybS5hcHAnOlxuXHRcdFx0XHRyZXR1cm4gdmVyc2lvbiA+PSAzID8gMyA6IDI7XG5cdFx0XHRjYXNlICdIeXBlcic6XG5cdFx0XHRcdHJldHVybiAzO1xuXHRcdFx0Y2FzZSAnQXBwbGVfVGVybWluYWwnOlxuXHRcdFx0XHRyZXR1cm4gMjtcblx0XHRcdC8vIE5vIGRlZmF1bHRcblx0XHR9XG5cdH1cblxuXHRpZiAoLy0yNTYoY29sb3IpPyQvaS50ZXN0KGVudi5URVJNKSkge1xuXHRcdHJldHVybiAyO1xuXHR9XG5cblx0aWYgKC9ec2NyZWVufF54dGVybXxednQxMDB8XnJ4dnR8Y29sb3J8YW5zaXxjeWd3aW58bGludXgvaS50ZXN0KGVudi5URVJNKSkge1xuXHRcdHJldHVybiAxO1xuXHR9XG5cblx0aWYgKCdDT0xPUlRFUk0nIGluIGVudikge1xuXHRcdHJldHVybiAxO1xuXHR9XG5cblx0aWYgKGVudi5URVJNID09PSAnZHVtYicpIHtcblx0XHRyZXR1cm4gMDtcblx0fVxuXG5cdHJldHVybiAwO1xufSkoKTtcblxuaWYgKCdGT1JDRV9DT0xPUicgaW4gZW52KSB7XG5cdHN1cHBvcnRMZXZlbCA9IHBhcnNlSW50KGVudi5GT1JDRV9DT0xPUiwgMTApID09PSAwID8gMCA6IChzdXBwb3J0TGV2ZWwgfHwgMSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gcHJvY2VzcyAmJiBzdXBwb3J0KHN1cHBvcnRMZXZlbCk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvc3VwcG9ydHMtY29sb3IvaW5kZXguanMiLCIndXNlIHN0cmljdCc7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChmbGFnLCBhcmd2KSB7XG5cdGFyZ3YgPSBhcmd2IHx8IHByb2Nlc3MuYXJndjtcblxuXHR2YXIgdGVybWluYXRvclBvcyA9IGFyZ3YuaW5kZXhPZignLS0nKTtcblx0dmFyIHByZWZpeCA9IC9eLXsxLDJ9Ly50ZXN0KGZsYWcpID8gJycgOiAnLS0nO1xuXHR2YXIgcG9zID0gYXJndi5pbmRleE9mKHByZWZpeCArIGZsYWcpO1xuXG5cdHJldHVybiBwb3MgIT09IC0xICYmICh0ZXJtaW5hdG9yUG9zID09PSAtMSA/IHRydWUgOiBwb3MgPCB0ZXJtaW5hdG9yUG9zKTtcbn07XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvaGFzLWZsYWcvaW5kZXguanMiLCIndXNlIHN0cmljdCdcblxuY29uc3QgYXNzaWduID0gcmVxdWlyZSgnLi91dGlsL2Fzc2lnbicpXG5cbmNvbnN0IGZzID0ge31cblxuLy8gRXhwb3J0IGdyYWNlZnVsLWZzOlxuYXNzaWduKGZzLCByZXF1aXJlKCcuL2ZzJykpXG4vLyBFeHBvcnQgZXh0cmEgbWV0aG9kczpcbmFzc2lnbihmcywgcmVxdWlyZSgnLi9jb3B5JykpXG5hc3NpZ24oZnMsIHJlcXVpcmUoJy4vY29weS1zeW5jJykpXG5hc3NpZ24oZnMsIHJlcXVpcmUoJy4vbWtkaXJzJykpXG5hc3NpZ24oZnMsIHJlcXVpcmUoJy4vcmVtb3ZlJykpXG5hc3NpZ24oZnMsIHJlcXVpcmUoJy4vanNvbicpKVxuYXNzaWduKGZzLCByZXF1aXJlKCcuL21vdmUnKSlcbmFzc2lnbihmcywgcmVxdWlyZSgnLi9tb3ZlLXN5bmMnKSlcbmFzc2lnbihmcywgcmVxdWlyZSgnLi9lbXB0eScpKVxuYXNzaWduKGZzLCByZXF1aXJlKCcuL2Vuc3VyZScpKVxuYXNzaWduKGZzLCByZXF1aXJlKCcuL291dHB1dCcpKVxuYXNzaWduKGZzLCByZXF1aXJlKCcuL3BhdGgtZXhpc3RzJykpXG5cbm1vZHVsZS5leHBvcnRzID0gZnNcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9lbGVjdHJvbi11cGRhdGVyL25vZGVfbW9kdWxlcy9mcy1leHRyYS9saWIvaW5kZXguanMiLCIndXNlIHN0cmljdCdcblxuLy8gc2ltcGxlIG11dGFibGUgYXNzaWduXG5mdW5jdGlvbiBhc3NpZ24gKCkge1xuICBjb25zdCBhcmdzID0gW10uc2xpY2UuY2FsbChhcmd1bWVudHMpLmZpbHRlcihpID0+IGkpXG4gIGNvbnN0IGRlc3QgPSBhcmdzLnNoaWZ0KClcbiAgYXJncy5mb3JFYWNoKHNyYyA9PiB7XG4gICAgT2JqZWN0LmtleXMoc3JjKS5mb3JFYWNoKGtleSA9PiB7XG4gICAgICBkZXN0W2tleV0gPSBzcmNba2V5XVxuICAgIH0pXG4gIH0pXG5cbiAgcmV0dXJuIGRlc3Rcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBhc3NpZ25cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9lbGVjdHJvbi11cGRhdGVyL25vZGVfbW9kdWxlcy9mcy1leHRyYS9saWIvdXRpbC9hc3NpZ24uanMiLCJ2YXIgZnMgPSByZXF1aXJlKCcuL2ZzLmpzJylcbnZhciBjb25zdGFudHMgPSByZXF1aXJlKCdjb25zdGFudHMnKVxuXG52YXIgb3JpZ0N3ZCA9IHByb2Nlc3MuY3dkXG52YXIgY3dkID0gbnVsbFxuXG52YXIgcGxhdGZvcm0gPSBwcm9jZXNzLmVudi5HUkFDRUZVTF9GU19QTEFURk9STSB8fCBwcm9jZXNzLnBsYXRmb3JtXG5cbnByb2Nlc3MuY3dkID0gZnVuY3Rpb24oKSB7XG4gIGlmICghY3dkKVxuICAgIGN3ZCA9IG9yaWdDd2QuY2FsbChwcm9jZXNzKVxuICByZXR1cm4gY3dkXG59XG50cnkge1xuICBwcm9jZXNzLmN3ZCgpXG59IGNhdGNoIChlcikge31cblxudmFyIGNoZGlyID0gcHJvY2Vzcy5jaGRpclxucHJvY2Vzcy5jaGRpciA9IGZ1bmN0aW9uKGQpIHtcbiAgY3dkID0gbnVsbFxuICBjaGRpci5jYWxsKHByb2Nlc3MsIGQpXG59XG5cbm1vZHVsZS5leHBvcnRzID0gcGF0Y2hcblxuZnVuY3Rpb24gcGF0Y2ggKGZzKSB7XG4gIC8vIChyZS0paW1wbGVtZW50IHNvbWUgdGhpbmdzIHRoYXQgYXJlIGtub3duIGJ1c3RlZCBvciBtaXNzaW5nLlxuXG4gIC8vIGxjaG1vZCwgYnJva2VuIHByaW9yIHRvIDAuNi4yXG4gIC8vIGJhY2stcG9ydCB0aGUgZml4IGhlcmUuXG4gIGlmIChjb25zdGFudHMuaGFzT3duUHJvcGVydHkoJ09fU1lNTElOSycpICYmXG4gICAgICBwcm9jZXNzLnZlcnNpb24ubWF0Y2goL152MFxcLjZcXC5bMC0yXXxedjBcXC41XFwuLykpIHtcbiAgICBwYXRjaExjaG1vZChmcylcbiAgfVxuXG4gIC8vIGx1dGltZXMgaW1wbGVtZW50YXRpb24sIG9yIG5vLW9wXG4gIGlmICghZnMubHV0aW1lcykge1xuICAgIHBhdGNoTHV0aW1lcyhmcylcbiAgfVxuXG4gIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9pc2FhY3Mvbm9kZS1ncmFjZWZ1bC1mcy9pc3N1ZXMvNFxuICAvLyBDaG93biBzaG91bGQgbm90IGZhaWwgb24gZWludmFsIG9yIGVwZXJtIGlmIG5vbi1yb290LlxuICAvLyBJdCBzaG91bGQgbm90IGZhaWwgb24gZW5vc3lzIGV2ZXIsIGFzIHRoaXMganVzdCBpbmRpY2F0ZXNcbiAgLy8gdGhhdCBhIGZzIGRvZXNuJ3Qgc3VwcG9ydCB0aGUgaW50ZW5kZWQgb3BlcmF0aW9uLlxuXG4gIGZzLmNob3duID0gY2hvd25GaXgoZnMuY2hvd24pXG4gIGZzLmZjaG93biA9IGNob3duRml4KGZzLmZjaG93bilcbiAgZnMubGNob3duID0gY2hvd25GaXgoZnMubGNob3duKVxuXG4gIGZzLmNobW9kID0gY2htb2RGaXgoZnMuY2htb2QpXG4gIGZzLmZjaG1vZCA9IGNobW9kRml4KGZzLmZjaG1vZClcbiAgZnMubGNobW9kID0gY2htb2RGaXgoZnMubGNobW9kKVxuXG4gIGZzLmNob3duU3luYyA9IGNob3duRml4U3luYyhmcy5jaG93blN5bmMpXG4gIGZzLmZjaG93blN5bmMgPSBjaG93bkZpeFN5bmMoZnMuZmNob3duU3luYylcbiAgZnMubGNob3duU3luYyA9IGNob3duRml4U3luYyhmcy5sY2hvd25TeW5jKVxuXG4gIGZzLmNobW9kU3luYyA9IGNobW9kRml4U3luYyhmcy5jaG1vZFN5bmMpXG4gIGZzLmZjaG1vZFN5bmMgPSBjaG1vZEZpeFN5bmMoZnMuZmNobW9kU3luYylcbiAgZnMubGNobW9kU3luYyA9IGNobW9kRml4U3luYyhmcy5sY2htb2RTeW5jKVxuXG4gIGZzLnN0YXQgPSBzdGF0Rml4KGZzLnN0YXQpXG4gIGZzLmZzdGF0ID0gc3RhdEZpeChmcy5mc3RhdClcbiAgZnMubHN0YXQgPSBzdGF0Rml4KGZzLmxzdGF0KVxuXG4gIGZzLnN0YXRTeW5jID0gc3RhdEZpeFN5bmMoZnMuc3RhdFN5bmMpXG4gIGZzLmZzdGF0U3luYyA9IHN0YXRGaXhTeW5jKGZzLmZzdGF0U3luYylcbiAgZnMubHN0YXRTeW5jID0gc3RhdEZpeFN5bmMoZnMubHN0YXRTeW5jKVxuXG4gIC8vIGlmIGxjaG1vZC9sY2hvd24gZG8gbm90IGV4aXN0LCB0aGVuIG1ha2UgdGhlbSBuby1vcHNcbiAgaWYgKCFmcy5sY2htb2QpIHtcbiAgICBmcy5sY2htb2QgPSBmdW5jdGlvbiAocGF0aCwgbW9kZSwgY2IpIHtcbiAgICAgIGlmIChjYikgcHJvY2Vzcy5uZXh0VGljayhjYilcbiAgICB9XG4gICAgZnMubGNobW9kU3luYyA9IGZ1bmN0aW9uICgpIHt9XG4gIH1cbiAgaWYgKCFmcy5sY2hvd24pIHtcbiAgICBmcy5sY2hvd24gPSBmdW5jdGlvbiAocGF0aCwgdWlkLCBnaWQsIGNiKSB7XG4gICAgICBpZiAoY2IpIHByb2Nlc3MubmV4dFRpY2soY2IpXG4gICAgfVxuICAgIGZzLmxjaG93blN5bmMgPSBmdW5jdGlvbiAoKSB7fVxuICB9XG5cbiAgLy8gb24gV2luZG93cywgQS9WIHNvZnR3YXJlIGNhbiBsb2NrIHRoZSBkaXJlY3RvcnksIGNhdXNpbmcgdGhpc1xuICAvLyB0byBmYWlsIHdpdGggYW4gRUFDQ0VTIG9yIEVQRVJNIGlmIHRoZSBkaXJlY3RvcnkgY29udGFpbnMgbmV3bHlcbiAgLy8gY3JlYXRlZCBmaWxlcy4gIFRyeSBhZ2FpbiBvbiBmYWlsdXJlLCBmb3IgdXAgdG8gNjAgc2Vjb25kcy5cblxuICAvLyBTZXQgdGhlIHRpbWVvdXQgdGhpcyBsb25nIGJlY2F1c2Ugc29tZSBXaW5kb3dzIEFudGktVmlydXMsIHN1Y2ggYXMgUGFyaXR5XG4gIC8vIGJpdDksIG1heSBsb2NrIGZpbGVzIGZvciB1cCB0byBhIG1pbnV0ZSwgY2F1c2luZyBucG0gcGFja2FnZSBpbnN0YWxsXG4gIC8vIGZhaWx1cmVzLiBBbHNvLCB0YWtlIGNhcmUgdG8geWllbGQgdGhlIHNjaGVkdWxlci4gV2luZG93cyBzY2hlZHVsaW5nIGdpdmVzXG4gIC8vIENQVSB0byBhIGJ1c3kgbG9vcGluZyBwcm9jZXNzLCB3aGljaCBjYW4gY2F1c2UgdGhlIHByb2dyYW0gY2F1c2luZyB0aGUgbG9ja1xuICAvLyBjb250ZW50aW9uIHRvIGJlIHN0YXJ2ZWQgb2YgQ1BVIGJ5IG5vZGUsIHNvIHRoZSBjb250ZW50aW9uIGRvZXNuJ3QgcmVzb2x2ZS5cbiAgaWYgKHBsYXRmb3JtID09PSBcIndpbjMyXCIpIHtcbiAgICBmcy5yZW5hbWUgPSAoZnVuY3Rpb24gKGZzJHJlbmFtZSkgeyByZXR1cm4gZnVuY3Rpb24gKGZyb20sIHRvLCBjYikge1xuICAgICAgdmFyIHN0YXJ0ID0gRGF0ZS5ub3coKVxuICAgICAgdmFyIGJhY2tvZmYgPSAwO1xuICAgICAgZnMkcmVuYW1lKGZyb20sIHRvLCBmdW5jdGlvbiBDQiAoZXIpIHtcbiAgICAgICAgaWYgKGVyXG4gICAgICAgICAgICAmJiAoZXIuY29kZSA9PT0gXCJFQUNDRVNcIiB8fCBlci5jb2RlID09PSBcIkVQRVJNXCIpXG4gICAgICAgICAgICAmJiBEYXRlLm5vdygpIC0gc3RhcnQgPCA2MDAwMCkge1xuICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBmcy5zdGF0KHRvLCBmdW5jdGlvbiAoc3RhdGVyLCBzdCkge1xuICAgICAgICAgICAgICBpZiAoc3RhdGVyICYmIHN0YXRlci5jb2RlID09PSBcIkVOT0VOVFwiKVxuICAgICAgICAgICAgICAgIGZzJHJlbmFtZShmcm9tLCB0bywgQ0IpO1xuICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgY2IoZXIpXG4gICAgICAgICAgICB9KVxuICAgICAgICAgIH0sIGJhY2tvZmYpXG4gICAgICAgICAgaWYgKGJhY2tvZmYgPCAxMDApXG4gICAgICAgICAgICBiYWNrb2ZmICs9IDEwO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY2IpIGNiKGVyKVxuICAgICAgfSlcbiAgICB9fSkoZnMucmVuYW1lKVxuICB9XG5cbiAgLy8gaWYgcmVhZCgpIHJldHVybnMgRUFHQUlOLCB0aGVuIGp1c3QgdHJ5IGl0IGFnYWluLlxuICBmcy5yZWFkID0gKGZ1bmN0aW9uIChmcyRyZWFkKSB7IHJldHVybiBmdW5jdGlvbiAoZmQsIGJ1ZmZlciwgb2Zmc2V0LCBsZW5ndGgsIHBvc2l0aW9uLCBjYWxsYmFja18pIHtcbiAgICB2YXIgY2FsbGJhY2tcbiAgICBpZiAoY2FsbGJhY2tfICYmIHR5cGVvZiBjYWxsYmFja18gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHZhciBlYWdDb3VudGVyID0gMFxuICAgICAgY2FsbGJhY2sgPSBmdW5jdGlvbiAoZXIsIF8sIF9fKSB7XG4gICAgICAgIGlmIChlciAmJiBlci5jb2RlID09PSAnRUFHQUlOJyAmJiBlYWdDb3VudGVyIDwgMTApIHtcbiAgICAgICAgICBlYWdDb3VudGVyICsrXG4gICAgICAgICAgcmV0dXJuIGZzJHJlYWQuY2FsbChmcywgZmQsIGJ1ZmZlciwgb2Zmc2V0LCBsZW5ndGgsIHBvc2l0aW9uLCBjYWxsYmFjaylcbiAgICAgICAgfVxuICAgICAgICBjYWxsYmFja18uYXBwbHkodGhpcywgYXJndW1lbnRzKVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZnMkcmVhZC5jYWxsKGZzLCBmZCwgYnVmZmVyLCBvZmZzZXQsIGxlbmd0aCwgcG9zaXRpb24sIGNhbGxiYWNrKVxuICB9fSkoZnMucmVhZClcblxuICBmcy5yZWFkU3luYyA9IChmdW5jdGlvbiAoZnMkcmVhZFN5bmMpIHsgcmV0dXJuIGZ1bmN0aW9uIChmZCwgYnVmZmVyLCBvZmZzZXQsIGxlbmd0aCwgcG9zaXRpb24pIHtcbiAgICB2YXIgZWFnQ291bnRlciA9IDBcbiAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIGZzJHJlYWRTeW5jLmNhbGwoZnMsIGZkLCBidWZmZXIsIG9mZnNldCwgbGVuZ3RoLCBwb3NpdGlvbilcbiAgICAgIH0gY2F0Y2ggKGVyKSB7XG4gICAgICAgIGlmIChlci5jb2RlID09PSAnRUFHQUlOJyAmJiBlYWdDb3VudGVyIDwgMTApIHtcbiAgICAgICAgICBlYWdDb3VudGVyICsrXG4gICAgICAgICAgY29udGludWVcbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBlclxuICAgICAgfVxuICAgIH1cbiAgfX0pKGZzLnJlYWRTeW5jKVxufVxuXG5mdW5jdGlvbiBwYXRjaExjaG1vZCAoZnMpIHtcbiAgZnMubGNobW9kID0gZnVuY3Rpb24gKHBhdGgsIG1vZGUsIGNhbGxiYWNrKSB7XG4gICAgZnMub3BlbiggcGF0aFxuICAgICAgICAgICAsIGNvbnN0YW50cy5PX1dST05MWSB8IGNvbnN0YW50cy5PX1NZTUxJTktcbiAgICAgICAgICAgLCBtb2RlXG4gICAgICAgICAgICwgZnVuY3Rpb24gKGVyciwgZmQpIHtcbiAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgaWYgKGNhbGxiYWNrKSBjYWxsYmFjayhlcnIpXG4gICAgICAgIHJldHVyblxuICAgICAgfVxuICAgICAgLy8gcHJlZmVyIHRvIHJldHVybiB0aGUgY2htb2QgZXJyb3IsIGlmIG9uZSBvY2N1cnMsXG4gICAgICAvLyBidXQgc3RpbGwgdHJ5IHRvIGNsb3NlLCBhbmQgcmVwb3J0IGNsb3NpbmcgZXJyb3JzIGlmIHRoZXkgb2NjdXIuXG4gICAgICBmcy5mY2htb2QoZmQsIG1vZGUsIGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgZnMuY2xvc2UoZmQsIGZ1bmN0aW9uKGVycjIpIHtcbiAgICAgICAgICBpZiAoY2FsbGJhY2spIGNhbGxiYWNrKGVyciB8fCBlcnIyKVxuICAgICAgICB9KVxuICAgICAgfSlcbiAgICB9KVxuICB9XG5cbiAgZnMubGNobW9kU3luYyA9IGZ1bmN0aW9uIChwYXRoLCBtb2RlKSB7XG4gICAgdmFyIGZkID0gZnMub3BlblN5bmMocGF0aCwgY29uc3RhbnRzLk9fV1JPTkxZIHwgY29uc3RhbnRzLk9fU1lNTElOSywgbW9kZSlcblxuICAgIC8vIHByZWZlciB0byByZXR1cm4gdGhlIGNobW9kIGVycm9yLCBpZiBvbmUgb2NjdXJzLFxuICAgIC8vIGJ1dCBzdGlsbCB0cnkgdG8gY2xvc2UsIGFuZCByZXBvcnQgY2xvc2luZyBlcnJvcnMgaWYgdGhleSBvY2N1ci5cbiAgICB2YXIgdGhyZXcgPSB0cnVlXG4gICAgdmFyIHJldFxuICAgIHRyeSB7XG4gICAgICByZXQgPSBmcy5mY2htb2RTeW5jKGZkLCBtb2RlKVxuICAgICAgdGhyZXcgPSBmYWxzZVxuICAgIH0gZmluYWxseSB7XG4gICAgICBpZiAodGhyZXcpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBmcy5jbG9zZVN5bmMoZmQpXG4gICAgICAgIH0gY2F0Y2ggKGVyKSB7fVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZnMuY2xvc2VTeW5jKGZkKVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmV0XG4gIH1cbn1cblxuZnVuY3Rpb24gcGF0Y2hMdXRpbWVzIChmcykge1xuICBpZiAoY29uc3RhbnRzLmhhc093blByb3BlcnR5KFwiT19TWU1MSU5LXCIpKSB7XG4gICAgZnMubHV0aW1lcyA9IGZ1bmN0aW9uIChwYXRoLCBhdCwgbXQsIGNiKSB7XG4gICAgICBmcy5vcGVuKHBhdGgsIGNvbnN0YW50cy5PX1NZTUxJTkssIGZ1bmN0aW9uIChlciwgZmQpIHtcbiAgICAgICAgaWYgKGVyKSB7XG4gICAgICAgICAgaWYgKGNiKSBjYihlcilcbiAgICAgICAgICByZXR1cm5cbiAgICAgICAgfVxuICAgICAgICBmcy5mdXRpbWVzKGZkLCBhdCwgbXQsIGZ1bmN0aW9uIChlcikge1xuICAgICAgICAgIGZzLmNsb3NlKGZkLCBmdW5jdGlvbiAoZXIyKSB7XG4gICAgICAgICAgICBpZiAoY2IpIGNiKGVyIHx8IGVyMilcbiAgICAgICAgICB9KVxuICAgICAgICB9KVxuICAgICAgfSlcbiAgICB9XG5cbiAgICBmcy5sdXRpbWVzU3luYyA9IGZ1bmN0aW9uIChwYXRoLCBhdCwgbXQpIHtcbiAgICAgIHZhciBmZCA9IGZzLm9wZW5TeW5jKHBhdGgsIGNvbnN0YW50cy5PX1NZTUxJTkspXG4gICAgICB2YXIgcmV0XG4gICAgICB2YXIgdGhyZXcgPSB0cnVlXG4gICAgICB0cnkge1xuICAgICAgICByZXQgPSBmcy5mdXRpbWVzU3luYyhmZCwgYXQsIG10KVxuICAgICAgICB0aHJldyA9IGZhbHNlXG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBpZiAodGhyZXcpIHtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgZnMuY2xvc2VTeW5jKGZkKVxuICAgICAgICAgIH0gY2F0Y2ggKGVyKSB7fVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGZzLmNsb3NlU3luYyhmZClcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHJldFxuICAgIH1cblxuICB9IGVsc2Uge1xuICAgIGZzLmx1dGltZXMgPSBmdW5jdGlvbiAoX2EsIF9iLCBfYywgY2IpIHsgaWYgKGNiKSBwcm9jZXNzLm5leHRUaWNrKGNiKSB9XG4gICAgZnMubHV0aW1lc1N5bmMgPSBmdW5jdGlvbiAoKSB7fVxuICB9XG59XG5cbmZ1bmN0aW9uIGNobW9kRml4IChvcmlnKSB7XG4gIGlmICghb3JpZykgcmV0dXJuIG9yaWdcbiAgcmV0dXJuIGZ1bmN0aW9uICh0YXJnZXQsIG1vZGUsIGNiKSB7XG4gICAgcmV0dXJuIG9yaWcuY2FsbChmcywgdGFyZ2V0LCBtb2RlLCBmdW5jdGlvbiAoZXIpIHtcbiAgICAgIGlmIChjaG93bkVyT2soZXIpKSBlciA9IG51bGxcbiAgICAgIGlmIChjYikgY2IuYXBwbHkodGhpcywgYXJndW1lbnRzKVxuICAgIH0pXG4gIH1cbn1cblxuZnVuY3Rpb24gY2htb2RGaXhTeW5jIChvcmlnKSB7XG4gIGlmICghb3JpZykgcmV0dXJuIG9yaWdcbiAgcmV0dXJuIGZ1bmN0aW9uICh0YXJnZXQsIG1vZGUpIHtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIG9yaWcuY2FsbChmcywgdGFyZ2V0LCBtb2RlKVxuICAgIH0gY2F0Y2ggKGVyKSB7XG4gICAgICBpZiAoIWNob3duRXJPayhlcikpIHRocm93IGVyXG4gICAgfVxuICB9XG59XG5cblxuZnVuY3Rpb24gY2hvd25GaXggKG9yaWcpIHtcbiAgaWYgKCFvcmlnKSByZXR1cm4gb3JpZ1xuICByZXR1cm4gZnVuY3Rpb24gKHRhcmdldCwgdWlkLCBnaWQsIGNiKSB7XG4gICAgcmV0dXJuIG9yaWcuY2FsbChmcywgdGFyZ2V0LCB1aWQsIGdpZCwgZnVuY3Rpb24gKGVyKSB7XG4gICAgICBpZiAoY2hvd25Fck9rKGVyKSkgZXIgPSBudWxsXG4gICAgICBpZiAoY2IpIGNiLmFwcGx5KHRoaXMsIGFyZ3VtZW50cylcbiAgICB9KVxuICB9XG59XG5cbmZ1bmN0aW9uIGNob3duRml4U3luYyAob3JpZykge1xuICBpZiAoIW9yaWcpIHJldHVybiBvcmlnXG4gIHJldHVybiBmdW5jdGlvbiAodGFyZ2V0LCB1aWQsIGdpZCkge1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4gb3JpZy5jYWxsKGZzLCB0YXJnZXQsIHVpZCwgZ2lkKVxuICAgIH0gY2F0Y2ggKGVyKSB7XG4gICAgICBpZiAoIWNob3duRXJPayhlcikpIHRocm93IGVyXG4gICAgfVxuICB9XG59XG5cblxuZnVuY3Rpb24gc3RhdEZpeCAob3JpZykge1xuICBpZiAoIW9yaWcpIHJldHVybiBvcmlnXG4gIC8vIE9sZGVyIHZlcnNpb25zIG9mIE5vZGUgZXJyb25lb3VzbHkgcmV0dXJuZWQgc2lnbmVkIGludGVnZXJzIGZvclxuICAvLyB1aWQgKyBnaWQuXG4gIHJldHVybiBmdW5jdGlvbiAodGFyZ2V0LCBjYikge1xuICAgIHJldHVybiBvcmlnLmNhbGwoZnMsIHRhcmdldCwgZnVuY3Rpb24gKGVyLCBzdGF0cykge1xuICAgICAgaWYgKCFzdGF0cykgcmV0dXJuIGNiLmFwcGx5KHRoaXMsIGFyZ3VtZW50cylcbiAgICAgIGlmIChzdGF0cy51aWQgPCAwKSBzdGF0cy51aWQgKz0gMHgxMDAwMDAwMDBcbiAgICAgIGlmIChzdGF0cy5naWQgPCAwKSBzdGF0cy5naWQgKz0gMHgxMDAwMDAwMDBcbiAgICAgIGlmIChjYikgY2IuYXBwbHkodGhpcywgYXJndW1lbnRzKVxuICAgIH0pXG4gIH1cbn1cblxuZnVuY3Rpb24gc3RhdEZpeFN5bmMgKG9yaWcpIHtcbiAgaWYgKCFvcmlnKSByZXR1cm4gb3JpZ1xuICAvLyBPbGRlciB2ZXJzaW9ucyBvZiBOb2RlIGVycm9uZW91c2x5IHJldHVybmVkIHNpZ25lZCBpbnRlZ2VycyBmb3JcbiAgLy8gdWlkICsgZ2lkLlxuICByZXR1cm4gZnVuY3Rpb24gKHRhcmdldCkge1xuICAgIHZhciBzdGF0cyA9IG9yaWcuY2FsbChmcywgdGFyZ2V0KVxuICAgIGlmIChzdGF0cy51aWQgPCAwKSBzdGF0cy51aWQgKz0gMHgxMDAwMDAwMDBcbiAgICBpZiAoc3RhdHMuZ2lkIDwgMCkgc3RhdHMuZ2lkICs9IDB4MTAwMDAwMDAwXG4gICAgcmV0dXJuIHN0YXRzO1xuICB9XG59XG5cbi8vIEVOT1NZUyBtZWFucyB0aGF0IHRoZSBmcyBkb2Vzbid0IHN1cHBvcnQgdGhlIG9wLiBKdXN0IGlnbm9yZVxuLy8gdGhhdCwgYmVjYXVzZSBpdCBkb2Vzbid0IG1hdHRlci5cbi8vXG4vLyBpZiB0aGVyZSdzIG5vIGdldHVpZCwgb3IgaWYgZ2V0dWlkKCkgaXMgc29tZXRoaW5nIG90aGVyXG4vLyB0aGFuIDAsIGFuZCB0aGUgZXJyb3IgaXMgRUlOVkFMIG9yIEVQRVJNLCB0aGVuIGp1c3QgaWdub3JlXG4vLyBpdC5cbi8vXG4vLyBUaGlzIHNwZWNpZmljIGNhc2UgaXMgYSBzaWxlbnQgZmFpbHVyZSBpbiBjcCwgaW5zdGFsbCwgdGFyLFxuLy8gYW5kIG1vc3Qgb3RoZXIgdW5peCB0b29scyB0aGF0IG1hbmFnZSBwZXJtaXNzaW9ucy5cbi8vXG4vLyBXaGVuIHJ1bm5pbmcgYXMgcm9vdCwgb3IgaWYgb3RoZXIgdHlwZXMgb2YgZXJyb3JzIGFyZVxuLy8gZW5jb3VudGVyZWQsIHRoZW4gaXQncyBzdHJpY3QuXG5mdW5jdGlvbiBjaG93bkVyT2sgKGVyKSB7XG4gIGlmICghZXIpXG4gICAgcmV0dXJuIHRydWVcblxuICBpZiAoZXIuY29kZSA9PT0gXCJFTk9TWVNcIilcbiAgICByZXR1cm4gdHJ1ZVxuXG4gIHZhciBub25yb290ID0gIXByb2Nlc3MuZ2V0dWlkIHx8IHByb2Nlc3MuZ2V0dWlkKCkgIT09IDBcbiAgaWYgKG5vbnJvb3QpIHtcbiAgICBpZiAoZXIuY29kZSA9PT0gXCJFSU5WQUxcIiB8fCBlci5jb2RlID09PSBcIkVQRVJNXCIpXG4gICAgICByZXR1cm4gdHJ1ZVxuICB9XG5cbiAgcmV0dXJuIGZhbHNlXG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvZ3JhY2VmdWwtZnMvcG9seWZpbGxzLmpzIiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwiY29uc3RhbnRzXCIpO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIGV4dGVybmFsIFwiY29uc3RhbnRzXCJcbi8vIG1vZHVsZSBpZCA9IDExMFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgU3RyZWFtID0gcmVxdWlyZSgnc3RyZWFtJykuU3RyZWFtXG5cbm1vZHVsZS5leHBvcnRzID0gbGVnYWN5XG5cbmZ1bmN0aW9uIGxlZ2FjeSAoZnMpIHtcbiAgcmV0dXJuIHtcbiAgICBSZWFkU3RyZWFtOiBSZWFkU3RyZWFtLFxuICAgIFdyaXRlU3RyZWFtOiBXcml0ZVN0cmVhbVxuICB9XG5cbiAgZnVuY3Rpb24gUmVhZFN0cmVhbSAocGF0aCwgb3B0aW9ucykge1xuICAgIGlmICghKHRoaXMgaW5zdGFuY2VvZiBSZWFkU3RyZWFtKSkgcmV0dXJuIG5ldyBSZWFkU3RyZWFtKHBhdGgsIG9wdGlvbnMpO1xuXG4gICAgU3RyZWFtLmNhbGwodGhpcyk7XG5cbiAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICB0aGlzLnBhdGggPSBwYXRoO1xuICAgIHRoaXMuZmQgPSBudWxsO1xuICAgIHRoaXMucmVhZGFibGUgPSB0cnVlO1xuICAgIHRoaXMucGF1c2VkID0gZmFsc2U7XG5cbiAgICB0aGlzLmZsYWdzID0gJ3InO1xuICAgIHRoaXMubW9kZSA9IDQzODsgLyo9MDY2NiovXG4gICAgdGhpcy5idWZmZXJTaXplID0gNjQgKiAxMDI0O1xuXG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgICAvLyBNaXhpbiBvcHRpb25zIGludG8gdGhpc1xuICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXMob3B0aW9ucyk7XG4gICAgZm9yICh2YXIgaW5kZXggPSAwLCBsZW5ndGggPSBrZXlzLmxlbmd0aDsgaW5kZXggPCBsZW5ndGg7IGluZGV4KyspIHtcbiAgICAgIHZhciBrZXkgPSBrZXlzW2luZGV4XTtcbiAgICAgIHRoaXNba2V5XSA9IG9wdGlvbnNba2V5XTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5lbmNvZGluZykgdGhpcy5zZXRFbmNvZGluZyh0aGlzLmVuY29kaW5nKTtcblxuICAgIGlmICh0aGlzLnN0YXJ0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGlmICgnbnVtYmVyJyAhPT0gdHlwZW9mIHRoaXMuc3RhcnQpIHtcbiAgICAgICAgdGhyb3cgVHlwZUVycm9yKCdzdGFydCBtdXN0IGJlIGEgTnVtYmVyJyk7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5lbmQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aGlzLmVuZCA9IEluZmluaXR5O1xuICAgICAgfSBlbHNlIGlmICgnbnVtYmVyJyAhPT0gdHlwZW9mIHRoaXMuZW5kKSB7XG4gICAgICAgIHRocm93IFR5cGVFcnJvcignZW5kIG11c3QgYmUgYSBOdW1iZXInKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMuc3RhcnQgPiB0aGlzLmVuZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3N0YXJ0IG11c3QgYmUgPD0gZW5kJyk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMucG9zID0gdGhpcy5zdGFydDtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5mZCAhPT0gbnVsbCkge1xuICAgICAgcHJvY2Vzcy5uZXh0VGljayhmdW5jdGlvbigpIHtcbiAgICAgICAgc2VsZi5fcmVhZCgpO1xuICAgICAgfSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgZnMub3Blbih0aGlzLnBhdGgsIHRoaXMuZmxhZ3MsIHRoaXMubW9kZSwgZnVuY3Rpb24gKGVyciwgZmQpIHtcbiAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgc2VsZi5lbWl0KCdlcnJvcicsIGVycik7XG4gICAgICAgIHNlbGYucmVhZGFibGUgPSBmYWxzZTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBzZWxmLmZkID0gZmQ7XG4gICAgICBzZWxmLmVtaXQoJ29wZW4nLCBmZCk7XG4gICAgICBzZWxmLl9yZWFkKCk7XG4gICAgfSlcbiAgfVxuXG4gIGZ1bmN0aW9uIFdyaXRlU3RyZWFtIChwYXRoLCBvcHRpb25zKSB7XG4gICAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIFdyaXRlU3RyZWFtKSkgcmV0dXJuIG5ldyBXcml0ZVN0cmVhbShwYXRoLCBvcHRpb25zKTtcblxuICAgIFN0cmVhbS5jYWxsKHRoaXMpO1xuXG4gICAgdGhpcy5wYXRoID0gcGF0aDtcbiAgICB0aGlzLmZkID0gbnVsbDtcbiAgICB0aGlzLndyaXRhYmxlID0gdHJ1ZTtcblxuICAgIHRoaXMuZmxhZ3MgPSAndyc7XG4gICAgdGhpcy5lbmNvZGluZyA9ICdiaW5hcnknO1xuICAgIHRoaXMubW9kZSA9IDQzODsgLyo9MDY2NiovXG4gICAgdGhpcy5ieXRlc1dyaXR0ZW4gPSAwO1xuXG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgICAvLyBNaXhpbiBvcHRpb25zIGludG8gdGhpc1xuICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXMob3B0aW9ucyk7XG4gICAgZm9yICh2YXIgaW5kZXggPSAwLCBsZW5ndGggPSBrZXlzLmxlbmd0aDsgaW5kZXggPCBsZW5ndGg7IGluZGV4KyspIHtcbiAgICAgIHZhciBrZXkgPSBrZXlzW2luZGV4XTtcbiAgICAgIHRoaXNba2V5XSA9IG9wdGlvbnNba2V5XTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5zdGFydCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBpZiAoJ251bWJlcicgIT09IHR5cGVvZiB0aGlzLnN0YXJ0KSB7XG4gICAgICAgIHRocm93IFR5cGVFcnJvcignc3RhcnQgbXVzdCBiZSBhIE51bWJlcicpO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMuc3RhcnQgPCAwKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignc3RhcnQgbXVzdCBiZSA+PSB6ZXJvJyk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMucG9zID0gdGhpcy5zdGFydDtcbiAgICB9XG5cbiAgICB0aGlzLmJ1c3kgPSBmYWxzZTtcbiAgICB0aGlzLl9xdWV1ZSA9IFtdO1xuXG4gICAgaWYgKHRoaXMuZmQgPT09IG51bGwpIHtcbiAgICAgIHRoaXMuX29wZW4gPSBmcy5vcGVuO1xuICAgICAgdGhpcy5fcXVldWUucHVzaChbdGhpcy5fb3BlbiwgdGhpcy5wYXRoLCB0aGlzLmZsYWdzLCB0aGlzLm1vZGUsIHVuZGVmaW5lZF0pO1xuICAgICAgdGhpcy5mbHVzaCgpO1xuICAgIH1cbiAgfVxufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2dyYWNlZnVsLWZzL2xlZ2FjeS1zdHJlYW1zLmpzIiwiY29uc3QgdSA9IHJlcXVpcmUoJ3VuaXZlcnNhbGlmeScpLmZyb21DYWxsYmFja1xubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGNvcHk6IHUocmVxdWlyZSgnLi9jb3B5JykpXG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvZWxlY3Ryb24tdXBkYXRlci9ub2RlX21vZHVsZXMvZnMtZXh0cmEvbGliL2NvcHkvaW5kZXguanMiLCIndXNlIHN0cmljdCdcblxuY29uc3QgZnMgPSByZXF1aXJlKCdncmFjZWZ1bC1mcycpXG5jb25zdCBwYXRoID0gcmVxdWlyZSgncGF0aCcpXG5jb25zdCBpbnZhbGlkV2luMzJQYXRoID0gcmVxdWlyZSgnLi93aW4zMicpLmludmFsaWRXaW4zMlBhdGhcblxuY29uc3Qgbzc3NyA9IHBhcnNlSW50KCcwNzc3JywgOClcblxuZnVuY3Rpb24gbWtkaXJzIChwLCBvcHRzLCBjYWxsYmFjaywgbWFkZSkge1xuICBpZiAodHlwZW9mIG9wdHMgPT09ICdmdW5jdGlvbicpIHtcbiAgICBjYWxsYmFjayA9IG9wdHNcbiAgICBvcHRzID0ge31cbiAgfSBlbHNlIGlmICghb3B0cyB8fCB0eXBlb2Ygb3B0cyAhPT0gJ29iamVjdCcpIHtcbiAgICBvcHRzID0geyBtb2RlOiBvcHRzIH1cbiAgfVxuXG4gIGlmIChwcm9jZXNzLnBsYXRmb3JtID09PSAnd2luMzInICYmIGludmFsaWRXaW4zMlBhdGgocCkpIHtcbiAgICBjb25zdCBlcnJJbnZhbCA9IG5ldyBFcnJvcihwICsgJyBjb250YWlucyBpbnZhbGlkIFdJTjMyIHBhdGggY2hhcmFjdGVycy4nKVxuICAgIGVyckludmFsLmNvZGUgPSAnRUlOVkFMJ1xuICAgIHJldHVybiBjYWxsYmFjayhlcnJJbnZhbClcbiAgfVxuXG4gIGxldCBtb2RlID0gb3B0cy5tb2RlXG4gIGNvbnN0IHhmcyA9IG9wdHMuZnMgfHwgZnNcblxuICBpZiAobW9kZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgbW9kZSA9IG83NzcgJiAofnByb2Nlc3MudW1hc2soKSlcbiAgfVxuICBpZiAoIW1hZGUpIG1hZGUgPSBudWxsXG5cbiAgY2FsbGJhY2sgPSBjYWxsYmFjayB8fCBmdW5jdGlvbiAoKSB7fVxuICBwID0gcGF0aC5yZXNvbHZlKHApXG5cbiAgeGZzLm1rZGlyKHAsIG1vZGUsIGVyID0+IHtcbiAgICBpZiAoIWVyKSB7XG4gICAgICBtYWRlID0gbWFkZSB8fCBwXG4gICAgICByZXR1cm4gY2FsbGJhY2sobnVsbCwgbWFkZSlcbiAgICB9XG4gICAgc3dpdGNoIChlci5jb2RlKSB7XG4gICAgICBjYXNlICdFTk9FTlQnOlxuICAgICAgICBpZiAocGF0aC5kaXJuYW1lKHApID09PSBwKSByZXR1cm4gY2FsbGJhY2soZXIpXG4gICAgICAgIG1rZGlycyhwYXRoLmRpcm5hbWUocCksIG9wdHMsIChlciwgbWFkZSkgPT4ge1xuICAgICAgICAgIGlmIChlcikgY2FsbGJhY2soZXIsIG1hZGUpXG4gICAgICAgICAgZWxzZSBta2RpcnMocCwgb3B0cywgY2FsbGJhY2ssIG1hZGUpXG4gICAgICAgIH0pXG4gICAgICAgIGJyZWFrXG5cbiAgICAgIC8vIEluIHRoZSBjYXNlIG9mIGFueSBvdGhlciBlcnJvciwganVzdCBzZWUgaWYgdGhlcmUncyBhIGRpclxuICAgICAgLy8gdGhlcmUgYWxyZWFkeS4gIElmIHNvLCB0aGVuIGhvb3JheSEgIElmIG5vdCwgdGhlbiBzb21ldGhpbmdcbiAgICAgIC8vIGlzIGJvcmtlZC5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHhmcy5zdGF0KHAsIChlcjIsIHN0YXQpID0+IHtcbiAgICAgICAgICAvLyBpZiB0aGUgc3RhdCBmYWlscywgdGhlbiB0aGF0J3Mgc3VwZXIgd2VpcmQuXG4gICAgICAgICAgLy8gbGV0IHRoZSBvcmlnaW5hbCBlcnJvciBiZSB0aGUgZmFpbHVyZSByZWFzb24uXG4gICAgICAgICAgaWYgKGVyMiB8fCAhc3RhdC5pc0RpcmVjdG9yeSgpKSBjYWxsYmFjayhlciwgbWFkZSlcbiAgICAgICAgICBlbHNlIGNhbGxiYWNrKG51bGwsIG1hZGUpXG4gICAgICAgIH0pXG4gICAgICAgIGJyZWFrXG4gICAgfVxuICB9KVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IG1rZGlyc1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2VsZWN0cm9uLXVwZGF0ZXIvbm9kZV9tb2R1bGVzL2ZzLWV4dHJhL2xpYi9ta2RpcnMvbWtkaXJzLmpzIiwiJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IGZzID0gcmVxdWlyZSgnZ3JhY2VmdWwtZnMnKVxuY29uc3QgcGF0aCA9IHJlcXVpcmUoJ3BhdGgnKVxuY29uc3QgaW52YWxpZFdpbjMyUGF0aCA9IHJlcXVpcmUoJy4vd2luMzInKS5pbnZhbGlkV2luMzJQYXRoXG5cbmNvbnN0IG83NzcgPSBwYXJzZUludCgnMDc3NycsIDgpXG5cbmZ1bmN0aW9uIG1rZGlyc1N5bmMgKHAsIG9wdHMsIG1hZGUpIHtcbiAgaWYgKCFvcHRzIHx8IHR5cGVvZiBvcHRzICE9PSAnb2JqZWN0Jykge1xuICAgIG9wdHMgPSB7IG1vZGU6IG9wdHMgfVxuICB9XG5cbiAgbGV0IG1vZGUgPSBvcHRzLm1vZGVcbiAgY29uc3QgeGZzID0gb3B0cy5mcyB8fCBmc1xuXG4gIGlmIChwcm9jZXNzLnBsYXRmb3JtID09PSAnd2luMzInICYmIGludmFsaWRXaW4zMlBhdGgocCkpIHtcbiAgICBjb25zdCBlcnJJbnZhbCA9IG5ldyBFcnJvcihwICsgJyBjb250YWlucyBpbnZhbGlkIFdJTjMyIHBhdGggY2hhcmFjdGVycy4nKVxuICAgIGVyckludmFsLmNvZGUgPSAnRUlOVkFMJ1xuICAgIHRocm93IGVyckludmFsXG4gIH1cblxuICBpZiAobW9kZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgbW9kZSA9IG83NzcgJiAofnByb2Nlc3MudW1hc2soKSlcbiAgfVxuICBpZiAoIW1hZGUpIG1hZGUgPSBudWxsXG5cbiAgcCA9IHBhdGgucmVzb2x2ZShwKVxuXG4gIHRyeSB7XG4gICAgeGZzLm1rZGlyU3luYyhwLCBtb2RlKVxuICAgIG1hZGUgPSBtYWRlIHx8IHBcbiAgfSBjYXRjaCAoZXJyMCkge1xuICAgIHN3aXRjaCAoZXJyMC5jb2RlKSB7XG4gICAgICBjYXNlICdFTk9FTlQnOlxuICAgICAgICBpZiAocGF0aC5kaXJuYW1lKHApID09PSBwKSB0aHJvdyBlcnIwXG4gICAgICAgIG1hZGUgPSBta2RpcnNTeW5jKHBhdGguZGlybmFtZShwKSwgb3B0cywgbWFkZSlcbiAgICAgICAgbWtkaXJzU3luYyhwLCBvcHRzLCBtYWRlKVxuICAgICAgICBicmVha1xuXG4gICAgICAvLyBJbiB0aGUgY2FzZSBvZiBhbnkgb3RoZXIgZXJyb3IsIGp1c3Qgc2VlIGlmIHRoZXJlJ3MgYSBkaXJcbiAgICAgIC8vIHRoZXJlIGFscmVhZHkuICBJZiBzbywgdGhlbiBob29yYXkhICBJZiBub3QsIHRoZW4gc29tZXRoaW5nXG4gICAgICAvLyBpcyBib3JrZWQuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICBsZXQgc3RhdFxuICAgICAgICB0cnkge1xuICAgICAgICAgIHN0YXQgPSB4ZnMuc3RhdFN5bmMocClcbiAgICAgICAgfSBjYXRjaCAoZXJyMSkge1xuICAgICAgICAgIHRocm93IGVycjBcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXN0YXQuaXNEaXJlY3RvcnkoKSkgdGhyb3cgZXJyMFxuICAgICAgICBicmVha1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBtYWRlXG59XG5cbm1vZHVsZS5leHBvcnRzID0gbWtkaXJzU3luY1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2VsZWN0cm9uLXVwZGF0ZXIvbm9kZV9tb2R1bGVzL2ZzLWV4dHJhL2xpYi9ta2RpcnMvbWtkaXJzLXN5bmMuanMiLCIndXNlIHN0cmljdCdcblxuY29uc3QgZnMgPSByZXF1aXJlKCdncmFjZWZ1bC1mcycpXG5jb25zdCBwYXRoID0gcmVxdWlyZSgncGF0aCcpXG5jb25zdCBta2RpcnBTeW5jID0gcmVxdWlyZSgnLi4vbWtkaXJzJykubWtkaXJzU3luY1xuY29uc3QgdXRpbWVzU3luYyA9IHJlcXVpcmUoJy4uL3V0aWwvdXRpbWVzLmpzJykudXRpbWVzTWlsbGlzU3luY1xuXG5jb25zdCBub3RFeGlzdCA9IFN5bWJvbCgnbm90RXhpc3QnKVxuY29uc3QgZXhpc3RzUmVnID0gU3ltYm9sKCdleGlzdHNSZWcnKVxuXG5mdW5jdGlvbiBjb3B5U3luYyAoc3JjLCBkZXN0LCBvcHRzKSB7XG4gIGlmICh0eXBlb2Ygb3B0cyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIG9wdHMgPSB7ZmlsdGVyOiBvcHRzfVxuICB9XG5cbiAgb3B0cyA9IG9wdHMgfHwge31cbiAgb3B0cy5jbG9iYmVyID0gJ2Nsb2JiZXInIGluIG9wdHMgPyAhIW9wdHMuY2xvYmJlciA6IHRydWUgLy8gZGVmYXVsdCB0byB0cnVlIGZvciBub3dcbiAgb3B0cy5vdmVyd3JpdGUgPSAnb3ZlcndyaXRlJyBpbiBvcHRzID8gISFvcHRzLm92ZXJ3cml0ZSA6IG9wdHMuY2xvYmJlciAvLyBvdmVyd3JpdGUgZmFsbHMgYmFjayB0byBjbG9iYmVyXG5cbiAgLy8gV2FybiBhYm91dCB1c2luZyBwcmVzZXJ2ZVRpbWVzdGFtcHMgb24gMzItYml0IG5vZGVcbiAgaWYgKG9wdHMucHJlc2VydmVUaW1lc3RhbXBzICYmIHByb2Nlc3MuYXJjaCA9PT0gJ2lhMzInKSB7XG4gICAgY29uc29sZS53YXJuKGBmcy1leHRyYTogVXNpbmcgdGhlIHByZXNlcnZlVGltZXN0YW1wcyBvcHRpb24gaW4gMzItYml0IG5vZGUgaXMgbm90IHJlY29tbWVuZGVkO1xcblxuICAgIHNlZSBodHRwczovL2dpdGh1Yi5jb20vanByaWNoYXJkc29uL25vZGUtZnMtZXh0cmEvaXNzdWVzLzI2OWApXG4gIH1cblxuICBzcmMgPSBwYXRoLnJlc29sdmUoc3JjKVxuICBkZXN0ID0gcGF0aC5yZXNvbHZlKGRlc3QpXG5cbiAgLy8gZG9uJ3QgYWxsb3cgc3JjIGFuZCBkZXN0IHRvIGJlIHRoZSBzYW1lXG4gIGlmIChzcmMgPT09IGRlc3QpIHRocm93IG5ldyBFcnJvcignU291cmNlIGFuZCBkZXN0aW5hdGlvbiBtdXN0IG5vdCBiZSB0aGUgc2FtZS4nKVxuXG4gIGlmIChvcHRzLmZpbHRlciAmJiAhb3B0cy5maWx0ZXIoc3JjLCBkZXN0KSkgcmV0dXJuXG5cbiAgY29uc3QgZGVzdFBhcmVudCA9IHBhdGguZGlybmFtZShkZXN0KVxuICBpZiAoIWZzLmV4aXN0c1N5bmMoZGVzdFBhcmVudCkpIG1rZGlycFN5bmMoZGVzdFBhcmVudClcbiAgcmV0dXJuIHN0YXJ0Q29weShzcmMsIGRlc3QsIG9wdHMpXG59XG5cbmZ1bmN0aW9uIHN0YXJ0Q29weSAoc3JjLCBkZXN0LCBvcHRzKSB7XG4gIGlmIChvcHRzLmZpbHRlciAmJiAhb3B0cy5maWx0ZXIoc3JjLCBkZXN0KSkgcmV0dXJuXG4gIHJldHVybiBnZXRTdGF0cyhzcmMsIGRlc3QsIG9wdHMpXG59XG5cbmZ1bmN0aW9uIGdldFN0YXRzIChzcmMsIGRlc3QsIG9wdHMpIHtcbiAgY29uc3Qgc3RhdFN5bmMgPSBvcHRzLmRlcmVmZXJlbmNlID8gZnMuc3RhdFN5bmMgOiBmcy5sc3RhdFN5bmNcbiAgY29uc3Qgc3QgPSBzdGF0U3luYyhzcmMpXG5cbiAgaWYgKHN0LmlzRGlyZWN0b3J5KCkpIHJldHVybiBvbkRpcihzdCwgc3JjLCBkZXN0LCBvcHRzKVxuICBlbHNlIGlmIChzdC5pc0ZpbGUoKSB8fFxuICAgICAgICAgICBzdC5pc0NoYXJhY3RlckRldmljZSgpIHx8XG4gICAgICAgICAgIHN0LmlzQmxvY2tEZXZpY2UoKSkgcmV0dXJuIG9uRmlsZShzdCwgc3JjLCBkZXN0LCBvcHRzKVxuICBlbHNlIGlmIChzdC5pc1N5bWJvbGljTGluaygpKSByZXR1cm4gb25MaW5rKHNyYywgZGVzdCwgb3B0cylcbn1cblxuZnVuY3Rpb24gb25GaWxlIChzcmNTdGF0LCBzcmMsIGRlc3QsIG9wdHMpIHtcbiAgY29uc3QgcmVzb2x2ZWRQYXRoID0gY2hlY2tEZXN0KGRlc3QpXG4gIGlmIChyZXNvbHZlZFBhdGggPT09IG5vdEV4aXN0KSB7XG4gICAgcmV0dXJuIGNvcHlGaWxlKHNyY1N0YXQsIHNyYywgZGVzdCwgb3B0cylcbiAgfSBlbHNlIGlmIChyZXNvbHZlZFBhdGggPT09IGV4aXN0c1JlZykge1xuICAgIHJldHVybiBtYXlDb3B5RmlsZShzcmNTdGF0LCBzcmMsIGRlc3QsIG9wdHMpXG4gIH0gZWxzZSB7XG4gICAgaWYgKHNyYyA9PT0gcmVzb2x2ZWRQYXRoKSByZXR1cm5cbiAgICByZXR1cm4gbWF5Q29weUZpbGUoc3JjU3RhdCwgc3JjLCBkZXN0LCBvcHRzKVxuICB9XG59XG5cbmZ1bmN0aW9uIG1heUNvcHlGaWxlIChzcmNTdGF0LCBzcmMsIGRlc3QsIG9wdHMpIHtcbiAgaWYgKG9wdHMub3ZlcndyaXRlKSB7XG4gICAgZnMudW5saW5rU3luYyhkZXN0KVxuICAgIHJldHVybiBjb3B5RmlsZShzcmNTdGF0LCBzcmMsIGRlc3QsIG9wdHMpXG4gIH0gZWxzZSBpZiAob3B0cy5lcnJvck9uRXhpc3QpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYCcke2Rlc3R9JyBhbHJlYWR5IGV4aXN0c2ApXG4gIH1cbn1cblxuZnVuY3Rpb24gY29weUZpbGUgKHNyY1N0YXQsIHNyYywgZGVzdCwgb3B0cykge1xuICBpZiAodHlwZW9mIGZzLmNvcHlGaWxlU3luYyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGZzLmNvcHlGaWxlU3luYyhzcmMsIGRlc3QpXG4gICAgZnMuY2htb2RTeW5jKGRlc3QsIHNyY1N0YXQubW9kZSlcbiAgICBpZiAob3B0cy5wcmVzZXJ2ZVRpbWVzdGFtcHMpIHtcbiAgICAgIHJldHVybiB1dGltZXNTeW5jKGRlc3QsIHNyY1N0YXQuYXRpbWUsIHNyY1N0YXQubXRpbWUpXG4gICAgfVxuICAgIHJldHVyblxuICB9XG4gIHJldHVybiBjb3B5RmlsZUZhbGxiYWNrKHNyY1N0YXQsIHNyYywgZGVzdCwgb3B0cylcbn1cblxuZnVuY3Rpb24gY29weUZpbGVGYWxsYmFjayAoc3JjU3RhdCwgc3JjLCBkZXN0LCBvcHRzKSB7XG4gIGNvbnN0IEJVRl9MRU5HVEggPSA2NCAqIDEwMjRcbiAgY29uc3QgX2J1ZmYgPSByZXF1aXJlKCcuLi91dGlsL2J1ZmZlcicpKEJVRl9MRU5HVEgpXG5cbiAgY29uc3QgZmRyID0gZnMub3BlblN5bmMoc3JjLCAncicpXG4gIGNvbnN0IGZkdyA9IGZzLm9wZW5TeW5jKGRlc3QsICd3Jywgc3JjU3RhdC5tb2RlKVxuICBsZXQgYnl0ZXNSZWFkID0gMVxuICBsZXQgcG9zID0gMFxuXG4gIHdoaWxlIChieXRlc1JlYWQgPiAwKSB7XG4gICAgYnl0ZXNSZWFkID0gZnMucmVhZFN5bmMoZmRyLCBfYnVmZiwgMCwgQlVGX0xFTkdUSCwgcG9zKVxuICAgIGZzLndyaXRlU3luYyhmZHcsIF9idWZmLCAwLCBieXRlc1JlYWQpXG4gICAgcG9zICs9IGJ5dGVzUmVhZFxuICB9XG5cbiAgaWYgKG9wdHMucHJlc2VydmVUaW1lc3RhbXBzKSBmcy5mdXRpbWVzU3luYyhmZHcsIHNyY1N0YXQuYXRpbWUsIHNyY1N0YXQubXRpbWUpXG5cbiAgZnMuY2xvc2VTeW5jKGZkcilcbiAgZnMuY2xvc2VTeW5jKGZkdylcbn1cblxuZnVuY3Rpb24gb25EaXIgKHNyY1N0YXQsIHNyYywgZGVzdCwgb3B0cykge1xuICBjb25zdCByZXNvbHZlZFBhdGggPSBjaGVja0Rlc3QoZGVzdClcbiAgaWYgKHJlc29sdmVkUGF0aCA9PT0gbm90RXhpc3QpIHtcbiAgICBpZiAoaXNTcmNTdWJkaXIoc3JjLCBkZXN0KSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBDYW5ub3QgY29weSAnJHtzcmN9JyB0byBhIHN1YmRpcmVjdG9yeSBvZiBpdHNlbGYsICcke2Rlc3R9Jy5gKVxuICAgIH1cbiAgICByZXR1cm4gbWtEaXJBbmRDb3B5KHNyY1N0YXQsIHNyYywgZGVzdCwgb3B0cylcbiAgfSBlbHNlIGlmIChyZXNvbHZlZFBhdGggPT09IGV4aXN0c1JlZykge1xuICAgIGlmIChpc1NyY1N1YmRpcihzcmMsIGRlc3QpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYENhbm5vdCBjb3B5ICcke3NyY30nIHRvIGEgc3ViZGlyZWN0b3J5IG9mIGl0c2VsZiwgJyR7ZGVzdH0nLmApXG4gICAgfVxuICAgIHJldHVybiBtYXlDb3B5RGlyKHNyYywgZGVzdCwgb3B0cylcbiAgfSBlbHNlIHtcbiAgICBpZiAoc3JjID09PSByZXNvbHZlZFBhdGgpIHJldHVyblxuICAgIHJldHVybiBjb3B5RGlyKHNyYywgZGVzdCwgb3B0cylcbiAgfVxufVxuXG5mdW5jdGlvbiBtYXlDb3B5RGlyIChzcmMsIGRlc3QsIG9wdHMpIHtcbiAgaWYgKCFmcy5zdGF0U3luYyhkZXN0KS5pc0RpcmVjdG9yeSgpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBDYW5ub3Qgb3ZlcndyaXRlIG5vbi1kaXJlY3RvcnkgJyR7ZGVzdH0nIHdpdGggZGlyZWN0b3J5ICcke3NyY30nLmApXG4gIH1cbiAgcmV0dXJuIGNvcHlEaXIoc3JjLCBkZXN0LCBvcHRzKVxufVxuXG5mdW5jdGlvbiBta0RpckFuZENvcHkgKHNyY1N0YXQsIHNyYywgZGVzdCwgb3B0cykge1xuICBmcy5ta2RpclN5bmMoZGVzdCwgc3JjU3RhdC5tb2RlKVxuICBmcy5jaG1vZFN5bmMoZGVzdCwgc3JjU3RhdC5tb2RlKVxuICByZXR1cm4gY29weURpcihzcmMsIGRlc3QsIG9wdHMpXG59XG5cbmZ1bmN0aW9uIGNvcHlEaXIgKHNyYywgZGVzdCwgb3B0cykge1xuICBmcy5yZWFkZGlyU3luYyhzcmMpLmZvckVhY2goaXRlbSA9PiB7XG4gICAgc3RhcnRDb3B5KHBhdGguam9pbihzcmMsIGl0ZW0pLCBwYXRoLmpvaW4oZGVzdCwgaXRlbSksIG9wdHMpXG4gIH0pXG59XG5cbmZ1bmN0aW9uIG9uTGluayAoc3JjLCBkZXN0LCBvcHRzKSB7XG4gIGxldCByZXNvbHZlZFNyY1BhdGggPSBmcy5yZWFkbGlua1N5bmMoc3JjKVxuXG4gIGlmIChvcHRzLmRlcmVmZXJlbmNlKSB7XG4gICAgcmVzb2x2ZWRTcmNQYXRoID0gcGF0aC5yZXNvbHZlKHByb2Nlc3MuY3dkKCksIHJlc29sdmVkU3JjUGF0aClcbiAgfVxuXG4gIGxldCByZXNvbHZlZERlc3RQYXRoID0gY2hlY2tEZXN0KGRlc3QpXG4gIGlmIChyZXNvbHZlZERlc3RQYXRoID09PSBub3RFeGlzdCB8fCByZXNvbHZlZERlc3RQYXRoID09PSBleGlzdHNSZWcpIHtcbiAgICAvLyBpZiBkZXN0IGFscmVhZHkgZXhpc3RzLCBmcyB0aHJvd3MgZXJyb3IgYW55d2F5LFxuICAgIC8vIHNvIG5vIG5lZWQgdG8gZ3VhcmQgYWdhaW5zdCBpdCBoZXJlLlxuICAgIHJldHVybiBmcy5zeW1saW5rU3luYyhyZXNvbHZlZFNyY1BhdGgsIGRlc3QpXG4gIH0gZWxzZSB7XG4gICAgaWYgKG9wdHMuZGVyZWZlcmVuY2UpIHtcbiAgICAgIHJlc29sdmVkRGVzdFBhdGggPSBwYXRoLnJlc29sdmUocHJvY2Vzcy5jd2QoKSwgcmVzb2x2ZWREZXN0UGF0aClcbiAgICB9XG4gICAgaWYgKHJlc29sdmVkRGVzdFBhdGggPT09IHJlc29sdmVkU3JjUGF0aCkgcmV0dXJuXG5cbiAgICAvLyBwcmV2ZW50IGNvcHkgaWYgc3JjIGlzIGEgc3ViZGlyIG9mIGRlc3Qgc2luY2UgdW5saW5raW5nXG4gICAgLy8gZGVzdCBpbiB0aGlzIGNhc2Ugd291bGQgcmVzdWx0IGluIHJlbW92aW5nIHNyYyBjb250ZW50c1xuICAgIC8vIGFuZCB0aGVyZWZvcmUgYSBicm9rZW4gc3ltbGluayB3b3VsZCBiZSBjcmVhdGVkLlxuICAgIGlmIChmcy5zdGF0U3luYyhkZXN0KS5pc0RpcmVjdG9yeSgpICYmIGlzU3JjU3ViZGlyKHJlc29sdmVkRGVzdFBhdGgsIHJlc29sdmVkU3JjUGF0aCkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgQ2Fubm90IG92ZXJ3cml0ZSAnJHtyZXNvbHZlZERlc3RQYXRofScgd2l0aCAnJHtyZXNvbHZlZFNyY1BhdGh9Jy5gKVxuICAgIH1cbiAgICByZXR1cm4gY29weUxpbmsocmVzb2x2ZWRTcmNQYXRoLCBkZXN0KVxuICB9XG59XG5cbmZ1bmN0aW9uIGNvcHlMaW5rIChyZXNvbHZlZFNyY1BhdGgsIGRlc3QpIHtcbiAgZnMudW5saW5rU3luYyhkZXN0KVxuICByZXR1cm4gZnMuc3ltbGlua1N5bmMocmVzb2x2ZWRTcmNQYXRoLCBkZXN0KVxufVxuXG4vLyBjaGVjayBpZiBkZXN0IGV4aXN0cyBhbmQvb3IgaXMgYSBzeW1saW5rXG5mdW5jdGlvbiBjaGVja0Rlc3QgKGRlc3QpIHtcbiAgbGV0IHJlc29sdmVkUGF0aFxuICB0cnkge1xuICAgIHJlc29sdmVkUGF0aCA9IGZzLnJlYWRsaW5rU3luYyhkZXN0KVxuICB9IGNhdGNoIChlcnIpIHtcbiAgICBpZiAoZXJyLmNvZGUgPT09ICdFTk9FTlQnKSByZXR1cm4gbm90RXhpc3RcblxuICAgIC8vIGRlc3QgZXhpc3RzIGFuZCBpcyBhIHJlZ3VsYXIgZmlsZSBvciBkaXJlY3RvcnksIFdpbmRvd3MgbWF5IHRocm93IFVOS05PV04gZXJyb3JcbiAgICBpZiAoZXJyLmNvZGUgPT09ICdFSU5WQUwnIHx8IGVyci5jb2RlID09PSAnVU5LTk9XTicpIHJldHVybiBleGlzdHNSZWdcblxuICAgIHRocm93IGVyclxuICB9XG4gIHJldHVybiByZXNvbHZlZFBhdGggLy8gZGVzdCBleGlzdHMgYW5kIGlzIGEgc3ltbGlua1xufVxuXG4vLyByZXR1cm4gdHJ1ZSBpZiBkZXN0IGlzIGEgc3ViZGlyIG9mIHNyYywgb3RoZXJ3aXNlIGZhbHNlLlxuLy8gZXh0cmFjdCBkZXN0IGJhc2UgZGlyIGFuZCBjaGVjayBpZiB0aGF0IGlzIHRoZSBzYW1lIGFzIHNyYyBiYXNlbmFtZVxuZnVuY3Rpb24gaXNTcmNTdWJkaXIgKHNyYywgZGVzdCkge1xuICBjb25zdCBiYXNlRGlyID0gZGVzdC5zcGxpdChwYXRoLmRpcm5hbWUoc3JjKSArIHBhdGguc2VwKVsxXVxuICBpZiAoYmFzZURpcikge1xuICAgIGNvbnN0IGRlc3RCYXNlbmFtZSA9IGJhc2VEaXIuc3BsaXQocGF0aC5zZXApWzBdXG4gICAgaWYgKGRlc3RCYXNlbmFtZSkge1xuICAgICAgcmV0dXJuIHNyYyAhPT0gZGVzdCAmJiBkZXN0LmluZGV4T2Yoc3JjKSA+IC0xICYmIGRlc3RCYXNlbmFtZSA9PT0gcGF0aC5iYXNlbmFtZShzcmMpXG4gICAgfVxuICAgIHJldHVybiBmYWxzZVxuICB9XG4gIHJldHVybiBmYWxzZVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNvcHlTeW5jXG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvZWxlY3Ryb24tdXBkYXRlci9ub2RlX21vZHVsZXMvZnMtZXh0cmEvbGliL2NvcHktc3luYy9jb3B5LXN5bmMuanMiLCIndXNlIHN0cmljdCdcblxuY29uc3QgZnMgPSByZXF1aXJlKCdncmFjZWZ1bC1mcycpXG5jb25zdCBwYXRoID0gcmVxdWlyZSgncGF0aCcpXG5jb25zdCBhc3NlcnQgPSByZXF1aXJlKCdhc3NlcnQnKVxuXG5jb25zdCBpc1dpbmRvd3MgPSAocHJvY2Vzcy5wbGF0Zm9ybSA9PT0gJ3dpbjMyJylcblxuZnVuY3Rpb24gZGVmYXVsdHMgKG9wdGlvbnMpIHtcbiAgY29uc3QgbWV0aG9kcyA9IFtcbiAgICAndW5saW5rJyxcbiAgICAnY2htb2QnLFxuICAgICdzdGF0JyxcbiAgICAnbHN0YXQnLFxuICAgICdybWRpcicsXG4gICAgJ3JlYWRkaXInXG4gIF1cbiAgbWV0aG9kcy5mb3JFYWNoKG0gPT4ge1xuICAgIG9wdGlvbnNbbV0gPSBvcHRpb25zW21dIHx8IGZzW21dXG4gICAgbSA9IG0gKyAnU3luYydcbiAgICBvcHRpb25zW21dID0gb3B0aW9uc1ttXSB8fCBmc1ttXVxuICB9KVxuXG4gIG9wdGlvbnMubWF4QnVzeVRyaWVzID0gb3B0aW9ucy5tYXhCdXN5VHJpZXMgfHwgM1xufVxuXG5mdW5jdGlvbiByaW1yYWYgKHAsIG9wdGlvbnMsIGNiKSB7XG4gIGxldCBidXN5VHJpZXMgPSAwXG5cbiAgaWYgKHR5cGVvZiBvcHRpb25zID09PSAnZnVuY3Rpb24nKSB7XG4gICAgY2IgPSBvcHRpb25zXG4gICAgb3B0aW9ucyA9IHt9XG4gIH1cblxuICBhc3NlcnQocCwgJ3JpbXJhZjogbWlzc2luZyBwYXRoJylcbiAgYXNzZXJ0LmVxdWFsKHR5cGVvZiBwLCAnc3RyaW5nJywgJ3JpbXJhZjogcGF0aCBzaG91bGQgYmUgYSBzdHJpbmcnKVxuICBhc3NlcnQuZXF1YWwodHlwZW9mIGNiLCAnZnVuY3Rpb24nLCAncmltcmFmOiBjYWxsYmFjayBmdW5jdGlvbiByZXF1aXJlZCcpXG4gIGFzc2VydChvcHRpb25zLCAncmltcmFmOiBpbnZhbGlkIG9wdGlvbnMgYXJndW1lbnQgcHJvdmlkZWQnKVxuICBhc3NlcnQuZXF1YWwodHlwZW9mIG9wdGlvbnMsICdvYmplY3QnLCAncmltcmFmOiBvcHRpb25zIHNob3VsZCBiZSBvYmplY3QnKVxuXG4gIGRlZmF1bHRzKG9wdGlvbnMpXG5cbiAgcmltcmFmXyhwLCBvcHRpb25zLCBmdW5jdGlvbiBDQiAoZXIpIHtcbiAgICBpZiAoZXIpIHtcbiAgICAgIGlmICgoZXIuY29kZSA9PT0gJ0VCVVNZJyB8fCBlci5jb2RlID09PSAnRU5PVEVNUFRZJyB8fCBlci5jb2RlID09PSAnRVBFUk0nKSAmJlxuICAgICAgICAgIGJ1c3lUcmllcyA8IG9wdGlvbnMubWF4QnVzeVRyaWVzKSB7XG4gICAgICAgIGJ1c3lUcmllcysrXG4gICAgICAgIGxldCB0aW1lID0gYnVzeVRyaWVzICogMTAwXG4gICAgICAgIC8vIHRyeSBhZ2Fpbiwgd2l0aCB0aGUgc2FtZSBleGFjdCBjYWxsYmFjayBhcyB0aGlzIG9uZS5cbiAgICAgICAgcmV0dXJuIHNldFRpbWVvdXQoKCkgPT4gcmltcmFmXyhwLCBvcHRpb25zLCBDQiksIHRpbWUpXG4gICAgICB9XG5cbiAgICAgIC8vIGFscmVhZHkgZ29uZVxuICAgICAgaWYgKGVyLmNvZGUgPT09ICdFTk9FTlQnKSBlciA9IG51bGxcbiAgICB9XG5cbiAgICBjYihlcilcbiAgfSlcbn1cblxuLy8gVHdvIHBvc3NpYmxlIHN0cmF0ZWdpZXMuXG4vLyAxLiBBc3N1bWUgaXQncyBhIGZpbGUuICB1bmxpbmsgaXQsIHRoZW4gZG8gdGhlIGRpciBzdHVmZiBvbiBFUEVSTSBvciBFSVNESVJcbi8vIDIuIEFzc3VtZSBpdCdzIGEgZGlyZWN0b3J5LiAgcmVhZGRpciwgdGhlbiBkbyB0aGUgZmlsZSBzdHVmZiBvbiBFTk9URElSXG4vL1xuLy8gQm90aCByZXN1bHQgaW4gYW4gZXh0cmEgc3lzY2FsbCB3aGVuIHlvdSBndWVzcyB3cm9uZy4gIEhvd2V2ZXIsIHRoZXJlXG4vLyBhcmUgbGlrZWx5IGZhciBtb3JlIG5vcm1hbCBmaWxlcyBpbiB0aGUgd29ybGQgdGhhbiBkaXJlY3Rvcmllcy4gIFRoaXNcbi8vIGlzIGJhc2VkIG9uIHRoZSBhc3N1bXB0aW9uIHRoYXQgYSB0aGUgYXZlcmFnZSBudW1iZXIgb2YgZmlsZXMgcGVyXG4vLyBkaXJlY3RvcnkgaXMgPj0gMS5cbi8vXG4vLyBJZiBhbnlvbmUgZXZlciBjb21wbGFpbnMgYWJvdXQgdGhpcywgdGhlbiBJIGd1ZXNzIHRoZSBzdHJhdGVneSBjb3VsZFxuLy8gYmUgbWFkZSBjb25maWd1cmFibGUgc29tZWhvdy4gIEJ1dCB1bnRpbCB0aGVuLCBZQUdOSS5cbmZ1bmN0aW9uIHJpbXJhZl8gKHAsIG9wdGlvbnMsIGNiKSB7XG4gIGFzc2VydChwKVxuICBhc3NlcnQob3B0aW9ucylcbiAgYXNzZXJ0KHR5cGVvZiBjYiA9PT0gJ2Z1bmN0aW9uJylcblxuICAvLyBzdW5vcyBsZXRzIHRoZSByb290IHVzZXIgdW5saW5rIGRpcmVjdG9yaWVzLCB3aGljaCBpcy4uLiB3ZWlyZC5cbiAgLy8gc28gd2UgaGF2ZSB0byBsc3RhdCBoZXJlIGFuZCBtYWtlIHN1cmUgaXQncyBub3QgYSBkaXIuXG4gIG9wdGlvbnMubHN0YXQocCwgKGVyLCBzdCkgPT4ge1xuICAgIGlmIChlciAmJiBlci5jb2RlID09PSAnRU5PRU5UJykge1xuICAgICAgcmV0dXJuIGNiKG51bGwpXG4gICAgfVxuXG4gICAgLy8gV2luZG93cyBjYW4gRVBFUk0gb24gc3RhdC4gIExpZmUgaXMgc3VmZmVyaW5nLlxuICAgIGlmIChlciAmJiBlci5jb2RlID09PSAnRVBFUk0nICYmIGlzV2luZG93cykge1xuICAgICAgcmV0dXJuIGZpeFdpbkVQRVJNKHAsIG9wdGlvbnMsIGVyLCBjYilcbiAgICB9XG5cbiAgICBpZiAoc3QgJiYgc3QuaXNEaXJlY3RvcnkoKSkge1xuICAgICAgcmV0dXJuIHJtZGlyKHAsIG9wdGlvbnMsIGVyLCBjYilcbiAgICB9XG5cbiAgICBvcHRpb25zLnVubGluayhwLCBlciA9PiB7XG4gICAgICBpZiAoZXIpIHtcbiAgICAgICAgaWYgKGVyLmNvZGUgPT09ICdFTk9FTlQnKSB7XG4gICAgICAgICAgcmV0dXJuIGNiKG51bGwpXG4gICAgICAgIH1cbiAgICAgICAgaWYgKGVyLmNvZGUgPT09ICdFUEVSTScpIHtcbiAgICAgICAgICByZXR1cm4gKGlzV2luZG93cylcbiAgICAgICAgICAgID8gZml4V2luRVBFUk0ocCwgb3B0aW9ucywgZXIsIGNiKVxuICAgICAgICAgICAgOiBybWRpcihwLCBvcHRpb25zLCBlciwgY2IpXG4gICAgICAgIH1cbiAgICAgICAgaWYgKGVyLmNvZGUgPT09ICdFSVNESVInKSB7XG4gICAgICAgICAgcmV0dXJuIHJtZGlyKHAsIG9wdGlvbnMsIGVyLCBjYilcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGNiKGVyKVxuICAgIH0pXG4gIH0pXG59XG5cbmZ1bmN0aW9uIGZpeFdpbkVQRVJNIChwLCBvcHRpb25zLCBlciwgY2IpIHtcbiAgYXNzZXJ0KHApXG4gIGFzc2VydChvcHRpb25zKVxuICBhc3NlcnQodHlwZW9mIGNiID09PSAnZnVuY3Rpb24nKVxuICBpZiAoZXIpIHtcbiAgICBhc3NlcnQoZXIgaW5zdGFuY2VvZiBFcnJvcilcbiAgfVxuXG4gIG9wdGlvbnMuY2htb2QocCwgMG82NjYsIGVyMiA9PiB7XG4gICAgaWYgKGVyMikge1xuICAgICAgY2IoZXIyLmNvZGUgPT09ICdFTk9FTlQnID8gbnVsbCA6IGVyKVxuICAgIH0gZWxzZSB7XG4gICAgICBvcHRpb25zLnN0YXQocCwgKGVyMywgc3RhdHMpID0+IHtcbiAgICAgICAgaWYgKGVyMykge1xuICAgICAgICAgIGNiKGVyMy5jb2RlID09PSAnRU5PRU5UJyA/IG51bGwgOiBlcilcbiAgICAgICAgfSBlbHNlIGlmIChzdGF0cy5pc0RpcmVjdG9yeSgpKSB7XG4gICAgICAgICAgcm1kaXIocCwgb3B0aW9ucywgZXIsIGNiKVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG9wdGlvbnMudW5saW5rKHAsIGNiKVxuICAgICAgICB9XG4gICAgICB9KVxuICAgIH1cbiAgfSlcbn1cblxuZnVuY3Rpb24gZml4V2luRVBFUk1TeW5jIChwLCBvcHRpb25zLCBlcikge1xuICBsZXQgc3RhdHNcblxuICBhc3NlcnQocClcbiAgYXNzZXJ0KG9wdGlvbnMpXG4gIGlmIChlcikge1xuICAgIGFzc2VydChlciBpbnN0YW5jZW9mIEVycm9yKVxuICB9XG5cbiAgdHJ5IHtcbiAgICBvcHRpb25zLmNobW9kU3luYyhwLCAwbzY2NilcbiAgfSBjYXRjaCAoZXIyKSB7XG4gICAgaWYgKGVyMi5jb2RlID09PSAnRU5PRU5UJykge1xuICAgICAgcmV0dXJuXG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IGVyXG4gICAgfVxuICB9XG5cbiAgdHJ5IHtcbiAgICBzdGF0cyA9IG9wdGlvbnMuc3RhdFN5bmMocClcbiAgfSBjYXRjaCAoZXIzKSB7XG4gICAgaWYgKGVyMy5jb2RlID09PSAnRU5PRU5UJykge1xuICAgICAgcmV0dXJuXG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IGVyXG4gICAgfVxuICB9XG5cbiAgaWYgKHN0YXRzLmlzRGlyZWN0b3J5KCkpIHtcbiAgICBybWRpclN5bmMocCwgb3B0aW9ucywgZXIpXG4gIH0gZWxzZSB7XG4gICAgb3B0aW9ucy51bmxpbmtTeW5jKHApXG4gIH1cbn1cblxuZnVuY3Rpb24gcm1kaXIgKHAsIG9wdGlvbnMsIG9yaWdpbmFsRXIsIGNiKSB7XG4gIGFzc2VydChwKVxuICBhc3NlcnQob3B0aW9ucylcbiAgaWYgKG9yaWdpbmFsRXIpIHtcbiAgICBhc3NlcnQob3JpZ2luYWxFciBpbnN0YW5jZW9mIEVycm9yKVxuICB9XG4gIGFzc2VydCh0eXBlb2YgY2IgPT09ICdmdW5jdGlvbicpXG5cbiAgLy8gdHJ5IHRvIHJtZGlyIGZpcnN0LCBhbmQgb25seSByZWFkZGlyIG9uIEVOT1RFTVBUWSBvciBFRVhJU1QgKFN1bk9TKVxuICAvLyBpZiB3ZSBndWVzc2VkIHdyb25nLCBhbmQgaXQncyBub3QgYSBkaXJlY3RvcnksIHRoZW5cbiAgLy8gcmFpc2UgdGhlIG9yaWdpbmFsIGVycm9yLlxuICBvcHRpb25zLnJtZGlyKHAsIGVyID0+IHtcbiAgICBpZiAoZXIgJiYgKGVyLmNvZGUgPT09ICdFTk9URU1QVFknIHx8IGVyLmNvZGUgPT09ICdFRVhJU1QnIHx8IGVyLmNvZGUgPT09ICdFUEVSTScpKSB7XG4gICAgICBybWtpZHMocCwgb3B0aW9ucywgY2IpXG4gICAgfSBlbHNlIGlmIChlciAmJiBlci5jb2RlID09PSAnRU5PVERJUicpIHtcbiAgICAgIGNiKG9yaWdpbmFsRXIpXG4gICAgfSBlbHNlIHtcbiAgICAgIGNiKGVyKVxuICAgIH1cbiAgfSlcbn1cblxuZnVuY3Rpb24gcm1raWRzIChwLCBvcHRpb25zLCBjYikge1xuICBhc3NlcnQocClcbiAgYXNzZXJ0KG9wdGlvbnMpXG4gIGFzc2VydCh0eXBlb2YgY2IgPT09ICdmdW5jdGlvbicpXG5cbiAgb3B0aW9ucy5yZWFkZGlyKHAsIChlciwgZmlsZXMpID0+IHtcbiAgICBpZiAoZXIpIHJldHVybiBjYihlcilcblxuICAgIGxldCBuID0gZmlsZXMubGVuZ3RoXG4gICAgbGV0IGVyclN0YXRlXG5cbiAgICBpZiAobiA9PT0gMCkgcmV0dXJuIG9wdGlvbnMucm1kaXIocCwgY2IpXG5cbiAgICBmaWxlcy5mb3JFYWNoKGYgPT4ge1xuICAgICAgcmltcmFmKHBhdGguam9pbihwLCBmKSwgb3B0aW9ucywgZXIgPT4ge1xuICAgICAgICBpZiAoZXJyU3RhdGUpIHtcbiAgICAgICAgICByZXR1cm5cbiAgICAgICAgfVxuICAgICAgICBpZiAoZXIpIHJldHVybiBjYihlcnJTdGF0ZSA9IGVyKVxuICAgICAgICBpZiAoLS1uID09PSAwKSB7XG4gICAgICAgICAgb3B0aW9ucy5ybWRpcihwLCBjYilcbiAgICAgICAgfVxuICAgICAgfSlcbiAgICB9KVxuICB9KVxufVxuXG4vLyB0aGlzIGxvb2tzIHNpbXBsZXIsIGFuZCBpcyBzdHJpY3RseSAqZmFzdGVyKiwgYnV0IHdpbGxcbi8vIHRpZSB1cCB0aGUgSmF2YVNjcmlwdCB0aHJlYWQgYW5kIGZhaWwgb24gZXhjZXNzaXZlbHlcbi8vIGRlZXAgZGlyZWN0b3J5IHRyZWVzLlxuZnVuY3Rpb24gcmltcmFmU3luYyAocCwgb3B0aW9ucykge1xuICBsZXQgc3RcblxuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fVxuICBkZWZhdWx0cyhvcHRpb25zKVxuXG4gIGFzc2VydChwLCAncmltcmFmOiBtaXNzaW5nIHBhdGgnKVxuICBhc3NlcnQuZXF1YWwodHlwZW9mIHAsICdzdHJpbmcnLCAncmltcmFmOiBwYXRoIHNob3VsZCBiZSBhIHN0cmluZycpXG4gIGFzc2VydChvcHRpb25zLCAncmltcmFmOiBtaXNzaW5nIG9wdGlvbnMnKVxuICBhc3NlcnQuZXF1YWwodHlwZW9mIG9wdGlvbnMsICdvYmplY3QnLCAncmltcmFmOiBvcHRpb25zIHNob3VsZCBiZSBvYmplY3QnKVxuXG4gIHRyeSB7XG4gICAgc3QgPSBvcHRpb25zLmxzdGF0U3luYyhwKVxuICB9IGNhdGNoIChlcikge1xuICAgIGlmIChlci5jb2RlID09PSAnRU5PRU5UJykge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgLy8gV2luZG93cyBjYW4gRVBFUk0gb24gc3RhdC4gIExpZmUgaXMgc3VmZmVyaW5nLlxuICAgIGlmIChlci5jb2RlID09PSAnRVBFUk0nICYmIGlzV2luZG93cykge1xuICAgICAgZml4V2luRVBFUk1TeW5jKHAsIG9wdGlvbnMsIGVyKVxuICAgIH1cbiAgfVxuXG4gIHRyeSB7XG4gICAgLy8gc3Vub3MgbGV0cyB0aGUgcm9vdCB1c2VyIHVubGluayBkaXJlY3Rvcmllcywgd2hpY2ggaXMuLi4gd2VpcmQuXG4gICAgaWYgKHN0ICYmIHN0LmlzRGlyZWN0b3J5KCkpIHtcbiAgICAgIHJtZGlyU3luYyhwLCBvcHRpb25zLCBudWxsKVxuICAgIH0gZWxzZSB7XG4gICAgICBvcHRpb25zLnVubGlua1N5bmMocClcbiAgICB9XG4gIH0gY2F0Y2ggKGVyKSB7XG4gICAgaWYgKGVyLmNvZGUgPT09ICdFTk9FTlQnKSB7XG4gICAgICByZXR1cm5cbiAgICB9IGVsc2UgaWYgKGVyLmNvZGUgPT09ICdFUEVSTScpIHtcbiAgICAgIHJldHVybiBpc1dpbmRvd3MgPyBmaXhXaW5FUEVSTVN5bmMocCwgb3B0aW9ucywgZXIpIDogcm1kaXJTeW5jKHAsIG9wdGlvbnMsIGVyKVxuICAgIH0gZWxzZSBpZiAoZXIuY29kZSAhPT0gJ0VJU0RJUicpIHtcbiAgICAgIHRocm93IGVyXG4gICAgfVxuICAgIHJtZGlyU3luYyhwLCBvcHRpb25zLCBlcilcbiAgfVxufVxuXG5mdW5jdGlvbiBybWRpclN5bmMgKHAsIG9wdGlvbnMsIG9yaWdpbmFsRXIpIHtcbiAgYXNzZXJ0KHApXG4gIGFzc2VydChvcHRpb25zKVxuICBpZiAob3JpZ2luYWxFcikge1xuICAgIGFzc2VydChvcmlnaW5hbEVyIGluc3RhbmNlb2YgRXJyb3IpXG4gIH1cblxuICB0cnkge1xuICAgIG9wdGlvbnMucm1kaXJTeW5jKHApXG4gIH0gY2F0Y2ggKGVyKSB7XG4gICAgaWYgKGVyLmNvZGUgPT09ICdFTk9URElSJykge1xuICAgICAgdGhyb3cgb3JpZ2luYWxFclxuICAgIH0gZWxzZSBpZiAoZXIuY29kZSA9PT0gJ0VOT1RFTVBUWScgfHwgZXIuY29kZSA9PT0gJ0VFWElTVCcgfHwgZXIuY29kZSA9PT0gJ0VQRVJNJykge1xuICAgICAgcm1raWRzU3luYyhwLCBvcHRpb25zKVxuICAgIH0gZWxzZSBpZiAoZXIuY29kZSAhPT0gJ0VOT0VOVCcpIHtcbiAgICAgIHRocm93IGVyXG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHJta2lkc1N5bmMgKHAsIG9wdGlvbnMpIHtcbiAgYXNzZXJ0KHApXG4gIGFzc2VydChvcHRpb25zKVxuICBvcHRpb25zLnJlYWRkaXJTeW5jKHApLmZvckVhY2goZiA9PiByaW1yYWZTeW5jKHBhdGguam9pbihwLCBmKSwgb3B0aW9ucykpXG5cbiAgLy8gV2Ugb25seSBlbmQgdXAgaGVyZSBvbmNlIHdlIGdvdCBFTk9URU1QVFkgYXQgbGVhc3Qgb25jZSwgYW5kXG4gIC8vIGF0IHRoaXMgcG9pbnQsIHdlIGFyZSBndWFyYW50ZWVkIHRvIGhhdmUgcmVtb3ZlZCBhbGwgdGhlIGtpZHMuXG4gIC8vIFNvLCB3ZSBrbm93IHRoYXQgaXQgd29uJ3QgYmUgRU5PRU5UIG9yIEVOT1RESVIgb3IgYW55dGhpbmcgZWxzZS5cbiAgLy8gdHJ5IHJlYWxseSBoYXJkIHRvIGRlbGV0ZSBzdHVmZiBvbiB3aW5kb3dzLCBiZWNhdXNlIGl0IGhhcyBhXG4gIC8vIFBST0ZPVU5ETFkgYW5ub3lpbmcgaGFiaXQgb2Ygbm90IGNsb3NpbmcgaGFuZGxlcyBwcm9tcHRseSB3aGVuXG4gIC8vIGZpbGVzIGFyZSBkZWxldGVkLCByZXN1bHRpbmcgaW4gc3B1cmlvdXMgRU5PVEVNUFRZIGVycm9ycy5cbiAgY29uc3QgcmV0cmllcyA9IGlzV2luZG93cyA/IDEwMCA6IDFcbiAgbGV0IGkgPSAwXG4gIGRvIHtcbiAgICBsZXQgdGhyZXcgPSB0cnVlXG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHJldCA9IG9wdGlvbnMucm1kaXJTeW5jKHAsIG9wdGlvbnMpXG4gICAgICB0aHJldyA9IGZhbHNlXG4gICAgICByZXR1cm4gcmV0XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIGlmICgrK2kgPCByZXRyaWVzICYmIHRocmV3KSBjb250aW51ZSAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG4gICAgfVxuICB9IHdoaWxlICh0cnVlKVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHJpbXJhZlxucmltcmFmLnN5bmMgPSByaW1yYWZTeW5jXG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvZWxlY3Ryb24tdXBkYXRlci9ub2RlX21vZHVsZXMvZnMtZXh0cmEvbGliL3JlbW92ZS9yaW1yYWYuanMiLCIndXNlIHN0cmljdCdcblxuY29uc3QgdSA9IHJlcXVpcmUoJ3VuaXZlcnNhbGlmeScpLmZyb21DYWxsYmFja1xuY29uc3QganNvbkZpbGUgPSByZXF1aXJlKCcuL2pzb25maWxlJylcblxuanNvbkZpbGUub3V0cHV0SnNvbiA9IHUocmVxdWlyZSgnLi9vdXRwdXQtanNvbicpKVxuanNvbkZpbGUub3V0cHV0SnNvblN5bmMgPSByZXF1aXJlKCcuL291dHB1dC1qc29uLXN5bmMnKVxuLy8gYWxpYXNlc1xuanNvbkZpbGUub3V0cHV0SlNPTiA9IGpzb25GaWxlLm91dHB1dEpzb25cbmpzb25GaWxlLm91dHB1dEpTT05TeW5jID0ganNvbkZpbGUub3V0cHV0SnNvblN5bmNcbmpzb25GaWxlLndyaXRlSlNPTiA9IGpzb25GaWxlLndyaXRlSnNvblxuanNvbkZpbGUud3JpdGVKU09OU3luYyA9IGpzb25GaWxlLndyaXRlSnNvblN5bmNcbmpzb25GaWxlLnJlYWRKU09OID0ganNvbkZpbGUucmVhZEpzb25cbmpzb25GaWxlLnJlYWRKU09OU3luYyA9IGpzb25GaWxlLnJlYWRKc29uU3luY1xuXG5tb2R1bGUuZXhwb3J0cyA9IGpzb25GaWxlXG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvZWxlY3Ryb24tdXBkYXRlci9ub2RlX21vZHVsZXMvZnMtZXh0cmEvbGliL2pzb24vaW5kZXguanMiLCJ2YXIgX2ZzXG50cnkge1xuICBfZnMgPSByZXF1aXJlKCdncmFjZWZ1bC1mcycpXG59IGNhdGNoIChfKSB7XG4gIF9mcyA9IHJlcXVpcmUoJ2ZzJylcbn1cblxuZnVuY3Rpb24gcmVhZEZpbGUgKGZpbGUsIG9wdGlvbnMsIGNhbGxiYWNrKSB7XG4gIGlmIChjYWxsYmFjayA9PSBudWxsKSB7XG4gICAgY2FsbGJhY2sgPSBvcHRpb25zXG4gICAgb3B0aW9ucyA9IHt9XG4gIH1cblxuICBpZiAodHlwZW9mIG9wdGlvbnMgPT09ICdzdHJpbmcnKSB7XG4gICAgb3B0aW9ucyA9IHtlbmNvZGluZzogb3B0aW9uc31cbiAgfVxuXG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9XG4gIHZhciBmcyA9IG9wdGlvbnMuZnMgfHwgX2ZzXG5cbiAgdmFyIHNob3VsZFRocm93ID0gdHJ1ZVxuICBpZiAoJ3Rocm93cycgaW4gb3B0aW9ucykge1xuICAgIHNob3VsZFRocm93ID0gb3B0aW9ucy50aHJvd3NcbiAgfVxuXG4gIGZzLnJlYWRGaWxlKGZpbGUsIG9wdGlvbnMsIGZ1bmN0aW9uIChlcnIsIGRhdGEpIHtcbiAgICBpZiAoZXJyKSByZXR1cm4gY2FsbGJhY2soZXJyKVxuXG4gICAgZGF0YSA9IHN0cmlwQm9tKGRhdGEpXG5cbiAgICB2YXIgb2JqXG4gICAgdHJ5IHtcbiAgICAgIG9iaiA9IEpTT04ucGFyc2UoZGF0YSwgb3B0aW9ucyA/IG9wdGlvbnMucmV2aXZlciA6IG51bGwpXG4gICAgfSBjYXRjaCAoZXJyMikge1xuICAgICAgaWYgKHNob3VsZFRocm93KSB7XG4gICAgICAgIGVycjIubWVzc2FnZSA9IGZpbGUgKyAnOiAnICsgZXJyMi5tZXNzYWdlXG4gICAgICAgIHJldHVybiBjYWxsYmFjayhlcnIyKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGNhbGxiYWNrKG51bGwsIG51bGwpXG4gICAgICB9XG4gICAgfVxuXG4gICAgY2FsbGJhY2sobnVsbCwgb2JqKVxuICB9KVxufVxuXG5mdW5jdGlvbiByZWFkRmlsZVN5bmMgKGZpbGUsIG9wdGlvbnMpIHtcbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge31cbiAgaWYgKHR5cGVvZiBvcHRpb25zID09PSAnc3RyaW5nJykge1xuICAgIG9wdGlvbnMgPSB7ZW5jb2Rpbmc6IG9wdGlvbnN9XG4gIH1cblxuICB2YXIgZnMgPSBvcHRpb25zLmZzIHx8IF9mc1xuXG4gIHZhciBzaG91bGRUaHJvdyA9IHRydWVcbiAgaWYgKCd0aHJvd3MnIGluIG9wdGlvbnMpIHtcbiAgICBzaG91bGRUaHJvdyA9IG9wdGlvbnMudGhyb3dzXG4gIH1cblxuICB0cnkge1xuICAgIHZhciBjb250ZW50ID0gZnMucmVhZEZpbGVTeW5jKGZpbGUsIG9wdGlvbnMpXG4gICAgY29udGVudCA9IHN0cmlwQm9tKGNvbnRlbnQpXG4gICAgcmV0dXJuIEpTT04ucGFyc2UoY29udGVudCwgb3B0aW9ucy5yZXZpdmVyKVxuICB9IGNhdGNoIChlcnIpIHtcbiAgICBpZiAoc2hvdWxkVGhyb3cpIHtcbiAgICAgIGVyci5tZXNzYWdlID0gZmlsZSArICc6ICcgKyBlcnIubWVzc2FnZVxuICAgICAgdGhyb3cgZXJyXG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBudWxsXG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHN0cmluZ2lmeSAob2JqLCBvcHRpb25zKSB7XG4gIHZhciBzcGFjZXNcbiAgdmFyIEVPTCA9ICdcXG4nXG4gIGlmICh0eXBlb2Ygb3B0aW9ucyA9PT0gJ29iamVjdCcgJiYgb3B0aW9ucyAhPT0gbnVsbCkge1xuICAgIGlmIChvcHRpb25zLnNwYWNlcykge1xuICAgICAgc3BhY2VzID0gb3B0aW9ucy5zcGFjZXNcbiAgICB9XG4gICAgaWYgKG9wdGlvbnMuRU9MKSB7XG4gICAgICBFT0wgPSBvcHRpb25zLkVPTFxuICAgIH1cbiAgfVxuXG4gIHZhciBzdHIgPSBKU09OLnN0cmluZ2lmeShvYmosIG9wdGlvbnMgPyBvcHRpb25zLnJlcGxhY2VyIDogbnVsbCwgc3BhY2VzKVxuXG4gIHJldHVybiBzdHIucmVwbGFjZSgvXFxuL2csIEVPTCkgKyBFT0xcbn1cblxuZnVuY3Rpb24gd3JpdGVGaWxlIChmaWxlLCBvYmosIG9wdGlvbnMsIGNhbGxiYWNrKSB7XG4gIGlmIChjYWxsYmFjayA9PSBudWxsKSB7XG4gICAgY2FsbGJhY2sgPSBvcHRpb25zXG4gICAgb3B0aW9ucyA9IHt9XG4gIH1cbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge31cbiAgdmFyIGZzID0gb3B0aW9ucy5mcyB8fCBfZnNcblxuICB2YXIgc3RyID0gJydcbiAgdHJ5IHtcbiAgICBzdHIgPSBzdHJpbmdpZnkob2JqLCBvcHRpb25zKVxuICB9IGNhdGNoIChlcnIpIHtcbiAgICAvLyBOZWVkIHRvIHJldHVybiB3aGV0aGVyIGEgY2FsbGJhY2sgd2FzIHBhc3NlZCBvciBub3RcbiAgICBpZiAoY2FsbGJhY2spIGNhbGxiYWNrKGVyciwgbnVsbClcbiAgICByZXR1cm5cbiAgfVxuXG4gIGZzLndyaXRlRmlsZShmaWxlLCBzdHIsIG9wdGlvbnMsIGNhbGxiYWNrKVxufVxuXG5mdW5jdGlvbiB3cml0ZUZpbGVTeW5jIChmaWxlLCBvYmosIG9wdGlvbnMpIHtcbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge31cbiAgdmFyIGZzID0gb3B0aW9ucy5mcyB8fCBfZnNcblxuICB2YXIgc3RyID0gc3RyaW5naWZ5KG9iaiwgb3B0aW9ucylcbiAgLy8gbm90IHN1cmUgaWYgZnMud3JpdGVGaWxlU3luYyByZXR1cm5zIGFueXRoaW5nLCBidXQganVzdCBpbiBjYXNlXG4gIHJldHVybiBmcy53cml0ZUZpbGVTeW5jKGZpbGUsIHN0ciwgb3B0aW9ucylcbn1cblxuZnVuY3Rpb24gc3RyaXBCb20gKGNvbnRlbnQpIHtcbiAgLy8gd2UgZG8gdGhpcyBiZWNhdXNlIEpTT04ucGFyc2Ugd291bGQgY29udmVydCBpdCB0byBhIHV0Zjggc3RyaW5nIGlmIGVuY29kaW5nIHdhc24ndCBzcGVjaWZpZWRcbiAgaWYgKEJ1ZmZlci5pc0J1ZmZlcihjb250ZW50KSkgY29udGVudCA9IGNvbnRlbnQudG9TdHJpbmcoJ3V0ZjgnKVxuICBjb250ZW50ID0gY29udGVudC5yZXBsYWNlKC9eXFx1RkVGRi8sICcnKVxuICByZXR1cm4gY29udGVudFxufVxuXG52YXIganNvbmZpbGUgPSB7XG4gIHJlYWRGaWxlOiByZWFkRmlsZSxcbiAgcmVhZEZpbGVTeW5jOiByZWFkRmlsZVN5bmMsXG4gIHdyaXRlRmlsZTogd3JpdGVGaWxlLFxuICB3cml0ZUZpbGVTeW5jOiB3cml0ZUZpbGVTeW5jXG59XG5cbm1vZHVsZS5leHBvcnRzID0ganNvbmZpbGVcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9qc29uZmlsZS9pbmRleC5qcyIsIid1c2Ugc3RyaWN0J1xuXG5jb25zdCBwYXRoID0gcmVxdWlyZSgncGF0aCcpXG5jb25zdCBta2RpciA9IHJlcXVpcmUoJy4uL21rZGlycycpXG5jb25zdCBwYXRoRXhpc3RzID0gcmVxdWlyZSgnLi4vcGF0aC1leGlzdHMnKS5wYXRoRXhpc3RzXG5jb25zdCBqc29uRmlsZSA9IHJlcXVpcmUoJy4vanNvbmZpbGUnKVxuXG5mdW5jdGlvbiBvdXRwdXRKc29uIChmaWxlLCBkYXRhLCBvcHRpb25zLCBjYWxsYmFjaykge1xuICBpZiAodHlwZW9mIG9wdGlvbnMgPT09ICdmdW5jdGlvbicpIHtcbiAgICBjYWxsYmFjayA9IG9wdGlvbnNcbiAgICBvcHRpb25zID0ge31cbiAgfVxuXG4gIGNvbnN0IGRpciA9IHBhdGguZGlybmFtZShmaWxlKVxuXG4gIHBhdGhFeGlzdHMoZGlyLCAoZXJyLCBpdERvZXMpID0+IHtcbiAgICBpZiAoZXJyKSByZXR1cm4gY2FsbGJhY2soZXJyKVxuICAgIGlmIChpdERvZXMpIHJldHVybiBqc29uRmlsZS53cml0ZUpzb24oZmlsZSwgZGF0YSwgb3B0aW9ucywgY2FsbGJhY2spXG5cbiAgICBta2Rpci5ta2RpcnMoZGlyLCBlcnIgPT4ge1xuICAgICAgaWYgKGVycikgcmV0dXJuIGNhbGxiYWNrKGVycilcbiAgICAgIGpzb25GaWxlLndyaXRlSnNvbihmaWxlLCBkYXRhLCBvcHRpb25zLCBjYWxsYmFjaylcbiAgICB9KVxuICB9KVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IG91dHB1dEpzb25cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9lbGVjdHJvbi11cGRhdGVyL25vZGVfbW9kdWxlcy9mcy1leHRyYS9saWIvanNvbi9vdXRwdXQtanNvbi5qcyIsIid1c2Ugc3RyaWN0J1xuXG5jb25zdCBmcyA9IHJlcXVpcmUoJ2dyYWNlZnVsLWZzJylcbmNvbnN0IHBhdGggPSByZXF1aXJlKCdwYXRoJylcbmNvbnN0IG1rZGlyID0gcmVxdWlyZSgnLi4vbWtkaXJzJylcbmNvbnN0IGpzb25GaWxlID0gcmVxdWlyZSgnLi9qc29uZmlsZScpXG5cbmZ1bmN0aW9uIG91dHB1dEpzb25TeW5jIChmaWxlLCBkYXRhLCBvcHRpb25zKSB7XG4gIGNvbnN0IGRpciA9IHBhdGguZGlybmFtZShmaWxlKVxuXG4gIGlmICghZnMuZXhpc3RzU3luYyhkaXIpKSB7XG4gICAgbWtkaXIubWtkaXJzU3luYyhkaXIpXG4gIH1cblxuICBqc29uRmlsZS53cml0ZUpzb25TeW5jKGZpbGUsIGRhdGEsIG9wdGlvbnMpXG59XG5cbm1vZHVsZS5leHBvcnRzID0gb3V0cHV0SnNvblN5bmNcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9lbGVjdHJvbi11cGRhdGVyL25vZGVfbW9kdWxlcy9mcy1leHRyYS9saWIvanNvbi9vdXRwdXQtanNvbi1zeW5jLmpzIiwiJ3VzZSBzdHJpY3QnXG5cbi8vIG1vc3Qgb2YgdGhpcyBjb2RlIHdhcyB3cml0dGVuIGJ5IEFuZHJldyBLZWxsZXlcbi8vIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0QgbGljZW5zZTogc2VlXG4vLyBodHRwczovL2dpdGh1Yi5jb20vYW5kcmV3cmsvbm9kZS1tdi9ibG9iL21hc3Rlci9wYWNrYWdlLmpzb25cblxuLy8gdGhpcyBuZWVkcyBhIGNsZWFudXBcblxuY29uc3QgdSA9IHJlcXVpcmUoJ3VuaXZlcnNhbGlmeScpLmZyb21DYWxsYmFja1xuY29uc3QgZnMgPSByZXF1aXJlKCdncmFjZWZ1bC1mcycpXG5jb25zdCBjb3B5ID0gcmVxdWlyZSgnLi4vY29weS9jb3B5JylcbmNvbnN0IHBhdGggPSByZXF1aXJlKCdwYXRoJylcbmNvbnN0IHJlbW92ZSA9IHJlcXVpcmUoJy4uL3JlbW92ZScpLnJlbW92ZVxuY29uc3QgbWtkaXJwID0gcmVxdWlyZSgnLi4vbWtkaXJzJykubWtkaXJzXG5cbmZ1bmN0aW9uIG1vdmUgKHNyYywgZGVzdCwgb3B0aW9ucywgY2FsbGJhY2spIHtcbiAgaWYgKHR5cGVvZiBvcHRpb25zID09PSAnZnVuY3Rpb24nKSB7XG4gICAgY2FsbGJhY2sgPSBvcHRpb25zXG4gICAgb3B0aW9ucyA9IHt9XG4gIH1cblxuICBjb25zdCBvdmVyd3JpdGUgPSBvcHRpb25zLm92ZXJ3cml0ZSB8fCBvcHRpb25zLmNsb2JiZXIgfHwgZmFsc2VcblxuICBpc1NyY1N1YmRpcihzcmMsIGRlc3QsIChlcnIsIGl0SXMpID0+IHtcbiAgICBpZiAoZXJyKSByZXR1cm4gY2FsbGJhY2soZXJyKVxuICAgIGlmIChpdElzKSByZXR1cm4gY2FsbGJhY2sobmV3IEVycm9yKGBDYW5ub3QgbW92ZSAnJHtzcmN9JyB0byBhIHN1YmRpcmVjdG9yeSBvZiBpdHNlbGYsICcke2Rlc3R9Jy5gKSlcbiAgICBta2RpcnAocGF0aC5kaXJuYW1lKGRlc3QpLCBlcnIgPT4ge1xuICAgICAgaWYgKGVycikgcmV0dXJuIGNhbGxiYWNrKGVycilcbiAgICAgIGRvUmVuYW1lKClcbiAgICB9KVxuICB9KVxuXG4gIGZ1bmN0aW9uIGRvUmVuYW1lICgpIHtcbiAgICBpZiAocGF0aC5yZXNvbHZlKHNyYykgPT09IHBhdGgucmVzb2x2ZShkZXN0KSkge1xuICAgICAgZnMuYWNjZXNzKHNyYywgY2FsbGJhY2spXG4gICAgfSBlbHNlIGlmIChvdmVyd3JpdGUpIHtcbiAgICAgIGZzLnJlbmFtZShzcmMsIGRlc3QsIGVyciA9PiB7XG4gICAgICAgIGlmICghZXJyKSByZXR1cm4gY2FsbGJhY2soKVxuXG4gICAgICAgIGlmIChlcnIuY29kZSA9PT0gJ0VOT1RFTVBUWScgfHwgZXJyLmNvZGUgPT09ICdFRVhJU1QnKSB7XG4gICAgICAgICAgcmVtb3ZlKGRlc3QsIGVyciA9PiB7XG4gICAgICAgICAgICBpZiAoZXJyKSByZXR1cm4gY2FsbGJhY2soZXJyKVxuICAgICAgICAgICAgb3B0aW9ucy5vdmVyd3JpdGUgPSBmYWxzZSAvLyBqdXN0IG92ZXJ3cml0ZWVkIGl0LCBubyBuZWVkIHRvIGRvIGl0IGFnYWluXG4gICAgICAgICAgICBtb3ZlKHNyYywgZGVzdCwgb3B0aW9ucywgY2FsbGJhY2spXG4gICAgICAgICAgfSlcbiAgICAgICAgICByZXR1cm5cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHdlaXJkIFdpbmRvd3Mgc2hpdFxuICAgICAgICBpZiAoZXJyLmNvZGUgPT09ICdFUEVSTScpIHtcbiAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgIHJlbW92ZShkZXN0LCBlcnIgPT4ge1xuICAgICAgICAgICAgICBpZiAoZXJyKSByZXR1cm4gY2FsbGJhY2soZXJyKVxuICAgICAgICAgICAgICBvcHRpb25zLm92ZXJ3cml0ZSA9IGZhbHNlXG4gICAgICAgICAgICAgIG1vdmUoc3JjLCBkZXN0LCBvcHRpb25zLCBjYWxsYmFjaylcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgfSwgMjAwKVxuICAgICAgICAgIHJldHVyblxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGVyci5jb2RlICE9PSAnRVhERVYnKSByZXR1cm4gY2FsbGJhY2soZXJyKVxuICAgICAgICBtb3ZlQWNyb3NzRGV2aWNlKHNyYywgZGVzdCwgb3ZlcndyaXRlLCBjYWxsYmFjaylcbiAgICAgIH0pXG4gICAgfSBlbHNlIHtcbiAgICAgIGZzLmxpbmsoc3JjLCBkZXN0LCBlcnIgPT4ge1xuICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgaWYgKGVyci5jb2RlID09PSAnRVhERVYnIHx8IGVyci5jb2RlID09PSAnRUlTRElSJyB8fCBlcnIuY29kZSA9PT0gJ0VQRVJNJyB8fCBlcnIuY29kZSA9PT0gJ0VOT1RTVVAnKSB7XG4gICAgICAgICAgICByZXR1cm4gbW92ZUFjcm9zc0RldmljZShzcmMsIGRlc3QsIG92ZXJ3cml0ZSwgY2FsbGJhY2spXG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBjYWxsYmFjayhlcnIpXG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZzLnVubGluayhzcmMsIGNhbGxiYWNrKVxuICAgICAgfSlcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gbW92ZUFjcm9zc0RldmljZSAoc3JjLCBkZXN0LCBvdmVyd3JpdGUsIGNhbGxiYWNrKSB7XG4gIGZzLnN0YXQoc3JjLCAoZXJyLCBzdGF0KSA9PiB7XG4gICAgaWYgKGVycikgcmV0dXJuIGNhbGxiYWNrKGVycilcblxuICAgIGlmIChzdGF0LmlzRGlyZWN0b3J5KCkpIHtcbiAgICAgIG1vdmVEaXJBY3Jvc3NEZXZpY2Uoc3JjLCBkZXN0LCBvdmVyd3JpdGUsIGNhbGxiYWNrKVxuICAgIH0gZWxzZSB7XG4gICAgICBtb3ZlRmlsZUFjcm9zc0RldmljZShzcmMsIGRlc3QsIG92ZXJ3cml0ZSwgY2FsbGJhY2spXG4gICAgfVxuICB9KVxufVxuXG5mdW5jdGlvbiBtb3ZlRmlsZUFjcm9zc0RldmljZSAoc3JjLCBkZXN0LCBvdmVyd3JpdGUsIGNhbGxiYWNrKSB7XG4gIGNvbnN0IGZsYWdzID0gb3ZlcndyaXRlID8gJ3cnIDogJ3d4J1xuICBjb25zdCBpbnMgPSBmcy5jcmVhdGVSZWFkU3RyZWFtKHNyYylcbiAgY29uc3Qgb3V0cyA9IGZzLmNyZWF0ZVdyaXRlU3RyZWFtKGRlc3QsIHsgZmxhZ3MgfSlcblxuICBpbnMub24oJ2Vycm9yJywgZXJyID0+IHtcbiAgICBpbnMuZGVzdHJveSgpXG4gICAgb3V0cy5kZXN0cm95KClcbiAgICBvdXRzLnJlbW92ZUxpc3RlbmVyKCdjbG9zZScsIG9uQ2xvc2UpXG5cbiAgICAvLyBtYXkgd2FudCB0byBjcmVhdGUgYSBkaXJlY3RvcnkgYnV0IGBvdXRgIGxpbmUgYWJvdmVcbiAgICAvLyBjcmVhdGVzIGFuIGVtcHR5IGZpbGUgZm9yIHVzOiBTZWUgIzEwOFxuICAgIC8vIGRvbid0IGNhcmUgYWJvdXQgZXJyb3IgaGVyZVxuICAgIGZzLnVubGluayhkZXN0LCAoKSA9PiB7XG4gICAgICAvLyBub3RlOiBgZXJyYCBoZXJlIGlzIGZyb20gdGhlIGlucHV0IHN0cmVhbSBlcnJyb3JcbiAgICAgIGlmIChlcnIuY29kZSA9PT0gJ0VJU0RJUicgfHwgZXJyLmNvZGUgPT09ICdFUEVSTScpIHtcbiAgICAgICAgbW92ZURpckFjcm9zc0RldmljZShzcmMsIGRlc3QsIG92ZXJ3cml0ZSwgY2FsbGJhY2spXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjYWxsYmFjayhlcnIpXG4gICAgICB9XG4gICAgfSlcbiAgfSlcblxuICBvdXRzLm9uKCdlcnJvcicsIGVyciA9PiB7XG4gICAgaW5zLmRlc3Ryb3koKVxuICAgIG91dHMuZGVzdHJveSgpXG4gICAgb3V0cy5yZW1vdmVMaXN0ZW5lcignY2xvc2UnLCBvbkNsb3NlKVxuICAgIGNhbGxiYWNrKGVycilcbiAgfSlcblxuICBvdXRzLm9uY2UoJ2Nsb3NlJywgb25DbG9zZSlcbiAgaW5zLnBpcGUob3V0cylcblxuICBmdW5jdGlvbiBvbkNsb3NlICgpIHtcbiAgICBmcy51bmxpbmsoc3JjLCBjYWxsYmFjaylcbiAgfVxufVxuXG5mdW5jdGlvbiBtb3ZlRGlyQWNyb3NzRGV2aWNlIChzcmMsIGRlc3QsIG92ZXJ3cml0ZSwgY2FsbGJhY2spIHtcbiAgY29uc3Qgb3B0aW9ucyA9IHtcbiAgICBvdmVyd3JpdGU6IGZhbHNlXG4gIH1cblxuICBpZiAob3ZlcndyaXRlKSB7XG4gICAgcmVtb3ZlKGRlc3QsIGVyciA9PiB7XG4gICAgICBpZiAoZXJyKSByZXR1cm4gY2FsbGJhY2soZXJyKVxuICAgICAgc3RhcnRDb3B5KClcbiAgICB9KVxuICB9IGVsc2Uge1xuICAgIHN0YXJ0Q29weSgpXG4gIH1cblxuICBmdW5jdGlvbiBzdGFydENvcHkgKCkge1xuICAgIGNvcHkoc3JjLCBkZXN0LCBvcHRpb25zLCBlcnIgPT4ge1xuICAgICAgaWYgKGVycikgcmV0dXJuIGNhbGxiYWNrKGVycilcbiAgICAgIHJlbW92ZShzcmMsIGNhbGxiYWNrKVxuICAgIH0pXG4gIH1cbn1cblxuLy8gcmV0dXJuIHRydWUgaWYgZGVzdCBpcyBhIHN1YmRpciBvZiBzcmMsIG90aGVyd2lzZSBmYWxzZS5cbi8vIGV4dHJhY3QgZGVzdCBiYXNlIGRpciBhbmQgY2hlY2sgaWYgdGhhdCBpcyB0aGUgc2FtZSBhcyBzcmMgYmFzZW5hbWVcbmZ1bmN0aW9uIGlzU3JjU3ViZGlyIChzcmMsIGRlc3QsIGNiKSB7XG4gIGZzLnN0YXQoc3JjLCAoZXJyLCBzdCkgPT4ge1xuICAgIGlmIChlcnIpIHJldHVybiBjYihlcnIpXG4gICAgaWYgKHN0LmlzRGlyZWN0b3J5KCkpIHtcbiAgICAgIGNvbnN0IGJhc2VEaXIgPSBkZXN0LnNwbGl0KHBhdGguZGlybmFtZShzcmMpICsgcGF0aC5zZXApWzFdXG4gICAgICBpZiAoYmFzZURpcikge1xuICAgICAgICBjb25zdCBkZXN0QmFzZW5hbWUgPSBiYXNlRGlyLnNwbGl0KHBhdGguc2VwKVswXVxuICAgICAgICBpZiAoZGVzdEJhc2VuYW1lKSByZXR1cm4gY2IobnVsbCwgc3JjICE9PSBkZXN0ICYmIGRlc3QuaW5kZXhPZihzcmMpID4gLTEgJiYgZGVzdEJhc2VuYW1lID09PSBwYXRoLmJhc2VuYW1lKHNyYykpXG4gICAgICAgIHJldHVybiBjYihudWxsLCBmYWxzZSlcbiAgICAgIH1cbiAgICAgIHJldHVybiBjYihudWxsLCBmYWxzZSlcbiAgICB9XG4gICAgcmV0dXJuIGNiKG51bGwsIGZhbHNlKVxuICB9KVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgbW92ZTogdShtb3ZlKVxufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2VsZWN0cm9uLXVwZGF0ZXIvbm9kZV9tb2R1bGVzL2ZzLWV4dHJhL2xpYi9tb3ZlL2luZGV4LmpzIiwiJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IGZzID0gcmVxdWlyZSgnZ3JhY2VmdWwtZnMnKVxuY29uc3QgcGF0aCA9IHJlcXVpcmUoJ3BhdGgnKVxuY29uc3QgY29weVN5bmMgPSByZXF1aXJlKCcuLi9jb3B5LXN5bmMnKS5jb3B5U3luY1xuY29uc3QgcmVtb3ZlU3luYyA9IHJlcXVpcmUoJy4uL3JlbW92ZScpLnJlbW92ZVN5bmNcbmNvbnN0IG1rZGlycFN5bmMgPSByZXF1aXJlKCcuLi9ta2RpcnMnKS5ta2RpcnNTeW5jXG5jb25zdCBidWZmZXIgPSByZXF1aXJlKCcuLi91dGlsL2J1ZmZlcicpXG5cbmZ1bmN0aW9uIG1vdmVTeW5jIChzcmMsIGRlc3QsIG9wdGlvbnMpIHtcbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge31cbiAgY29uc3Qgb3ZlcndyaXRlID0gb3B0aW9ucy5vdmVyd3JpdGUgfHwgb3B0aW9ucy5jbG9iYmVyIHx8IGZhbHNlXG5cbiAgc3JjID0gcGF0aC5yZXNvbHZlKHNyYylcbiAgZGVzdCA9IHBhdGgucmVzb2x2ZShkZXN0KVxuXG4gIGlmIChzcmMgPT09IGRlc3QpIHJldHVybiBmcy5hY2Nlc3NTeW5jKHNyYylcblxuICBpZiAoaXNTcmNTdWJkaXIoc3JjLCBkZXN0KSkgdGhyb3cgbmV3IEVycm9yKGBDYW5ub3QgbW92ZSAnJHtzcmN9JyBpbnRvIGl0c2VsZiAnJHtkZXN0fScuYClcblxuICBta2RpcnBTeW5jKHBhdGguZGlybmFtZShkZXN0KSlcbiAgdHJ5UmVuYW1lU3luYygpXG5cbiAgZnVuY3Rpb24gdHJ5UmVuYW1lU3luYyAoKSB7XG4gICAgaWYgKG92ZXJ3cml0ZSkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIGZzLnJlbmFtZVN5bmMoc3JjLCBkZXN0KVxuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIGlmIChlcnIuY29kZSA9PT0gJ0VOT1RFTVBUWScgfHwgZXJyLmNvZGUgPT09ICdFRVhJU1QnIHx8IGVyci5jb2RlID09PSAnRVBFUk0nKSB7XG4gICAgICAgICAgcmVtb3ZlU3luYyhkZXN0KVxuICAgICAgICAgIG9wdGlvbnMub3ZlcndyaXRlID0gZmFsc2UgLy8ganVzdCBvdmVyd3JpdGVlZCBpdCwgbm8gbmVlZCB0byBkbyBpdCBhZ2FpblxuICAgICAgICAgIHJldHVybiBtb3ZlU3luYyhzcmMsIGRlc3QsIG9wdGlvbnMpXG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZXJyLmNvZGUgIT09ICdFWERFVicpIHRocm93IGVyclxuICAgICAgICByZXR1cm4gbW92ZVN5bmNBY3Jvc3NEZXZpY2Uoc3JjLCBkZXN0LCBvdmVyd3JpdGUpXG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGZzLmxpbmtTeW5jKHNyYywgZGVzdClcbiAgICAgICAgcmV0dXJuIGZzLnVubGlua1N5bmMoc3JjKVxuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIGlmIChlcnIuY29kZSA9PT0gJ0VYREVWJyB8fCBlcnIuY29kZSA9PT0gJ0VJU0RJUicgfHwgZXJyLmNvZGUgPT09ICdFUEVSTScgfHwgZXJyLmNvZGUgPT09ICdFTk9UU1VQJykge1xuICAgICAgICAgIHJldHVybiBtb3ZlU3luY0Fjcm9zc0RldmljZShzcmMsIGRlc3QsIG92ZXJ3cml0ZSlcbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBlcnJcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gbW92ZVN5bmNBY3Jvc3NEZXZpY2UgKHNyYywgZGVzdCwgb3ZlcndyaXRlKSB7XG4gIGNvbnN0IHN0YXQgPSBmcy5zdGF0U3luYyhzcmMpXG5cbiAgaWYgKHN0YXQuaXNEaXJlY3RvcnkoKSkge1xuICAgIHJldHVybiBtb3ZlRGlyU3luY0Fjcm9zc0RldmljZShzcmMsIGRlc3QsIG92ZXJ3cml0ZSlcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gbW92ZUZpbGVTeW5jQWNyb3NzRGV2aWNlKHNyYywgZGVzdCwgb3ZlcndyaXRlKVxuICB9XG59XG5cbmZ1bmN0aW9uIG1vdmVGaWxlU3luY0Fjcm9zc0RldmljZSAoc3JjLCBkZXN0LCBvdmVyd3JpdGUpIHtcbiAgY29uc3QgQlVGX0xFTkdUSCA9IDY0ICogMTAyNFxuICBjb25zdCBfYnVmZiA9IGJ1ZmZlcihCVUZfTEVOR1RIKVxuXG4gIGNvbnN0IGZsYWdzID0gb3ZlcndyaXRlID8gJ3cnIDogJ3d4J1xuXG4gIGNvbnN0IGZkciA9IGZzLm9wZW5TeW5jKHNyYywgJ3InKVxuICBjb25zdCBzdGF0ID0gZnMuZnN0YXRTeW5jKGZkcilcbiAgY29uc3QgZmR3ID0gZnMub3BlblN5bmMoZGVzdCwgZmxhZ3MsIHN0YXQubW9kZSlcbiAgbGV0IGJ5dGVzUmVhZCA9IDFcbiAgbGV0IHBvcyA9IDBcblxuICB3aGlsZSAoYnl0ZXNSZWFkID4gMCkge1xuICAgIGJ5dGVzUmVhZCA9IGZzLnJlYWRTeW5jKGZkciwgX2J1ZmYsIDAsIEJVRl9MRU5HVEgsIHBvcylcbiAgICBmcy53cml0ZVN5bmMoZmR3LCBfYnVmZiwgMCwgYnl0ZXNSZWFkKVxuICAgIHBvcyArPSBieXRlc1JlYWRcbiAgfVxuXG4gIGZzLmNsb3NlU3luYyhmZHIpXG4gIGZzLmNsb3NlU3luYyhmZHcpXG4gIHJldHVybiBmcy51bmxpbmtTeW5jKHNyYylcbn1cblxuZnVuY3Rpb24gbW92ZURpclN5bmNBY3Jvc3NEZXZpY2UgKHNyYywgZGVzdCwgb3ZlcndyaXRlKSB7XG4gIGNvbnN0IG9wdGlvbnMgPSB7XG4gICAgb3ZlcndyaXRlOiBmYWxzZVxuICB9XG5cbiAgaWYgKG92ZXJ3cml0ZSkge1xuICAgIHJlbW92ZVN5bmMoZGVzdClcbiAgICB0cnlDb3B5U3luYygpXG4gIH0gZWxzZSB7XG4gICAgdHJ5Q29weVN5bmMoKVxuICB9XG5cbiAgZnVuY3Rpb24gdHJ5Q29weVN5bmMgKCkge1xuICAgIGNvcHlTeW5jKHNyYywgZGVzdCwgb3B0aW9ucylcbiAgICByZXR1cm4gcmVtb3ZlU3luYyhzcmMpXG4gIH1cbn1cblxuLy8gcmV0dXJuIHRydWUgaWYgZGVzdCBpcyBhIHN1YmRpciBvZiBzcmMsIG90aGVyd2lzZSBmYWxzZS5cbi8vIGV4dHJhY3QgZGVzdCBiYXNlIGRpciBhbmQgY2hlY2sgaWYgdGhhdCBpcyB0aGUgc2FtZSBhcyBzcmMgYmFzZW5hbWVcbmZ1bmN0aW9uIGlzU3JjU3ViZGlyIChzcmMsIGRlc3QpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gZnMuc3RhdFN5bmMoc3JjKS5pc0RpcmVjdG9yeSgpICYmXG4gICAgICAgICAgIHNyYyAhPT0gZGVzdCAmJlxuICAgICAgICAgICBkZXN0LmluZGV4T2Yoc3JjKSA+IC0xICYmXG4gICAgICAgICAgIGRlc3Quc3BsaXQocGF0aC5kaXJuYW1lKHNyYykgKyBwYXRoLnNlcClbMV0uc3BsaXQocGF0aC5zZXApWzBdID09PSBwYXRoLmJhc2VuYW1lKHNyYylcbiAgfSBjYXRjaCAoZSkge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBtb3ZlU3luY1xufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2VsZWN0cm9uLXVwZGF0ZXIvbm9kZV9tb2R1bGVzL2ZzLWV4dHJhL2xpYi9tb3ZlLXN5bmMvaW5kZXguanMiLCIndXNlIHN0cmljdCdcblxuY29uc3QgdSA9IHJlcXVpcmUoJ3VuaXZlcnNhbGlmeScpLmZyb21DYWxsYmFja1xuY29uc3QgZnMgPSByZXF1aXJlKCdmcycpXG5jb25zdCBwYXRoID0gcmVxdWlyZSgncGF0aCcpXG5jb25zdCBta2RpciA9IHJlcXVpcmUoJy4uL21rZGlycycpXG5jb25zdCByZW1vdmUgPSByZXF1aXJlKCcuLi9yZW1vdmUnKVxuXG5jb25zdCBlbXB0eURpciA9IHUoZnVuY3Rpb24gZW1wdHlEaXIgKGRpciwgY2FsbGJhY2spIHtcbiAgY2FsbGJhY2sgPSBjYWxsYmFjayB8fCBmdW5jdGlvbiAoKSB7fVxuICBmcy5yZWFkZGlyKGRpciwgKGVyciwgaXRlbXMpID0+IHtcbiAgICBpZiAoZXJyKSByZXR1cm4gbWtkaXIubWtkaXJzKGRpciwgY2FsbGJhY2spXG5cbiAgICBpdGVtcyA9IGl0ZW1zLm1hcChpdGVtID0+IHBhdGguam9pbihkaXIsIGl0ZW0pKVxuXG4gICAgZGVsZXRlSXRlbSgpXG5cbiAgICBmdW5jdGlvbiBkZWxldGVJdGVtICgpIHtcbiAgICAgIGNvbnN0IGl0ZW0gPSBpdGVtcy5wb3AoKVxuICAgICAgaWYgKCFpdGVtKSByZXR1cm4gY2FsbGJhY2soKVxuICAgICAgcmVtb3ZlLnJlbW92ZShpdGVtLCBlcnIgPT4ge1xuICAgICAgICBpZiAoZXJyKSByZXR1cm4gY2FsbGJhY2soZXJyKVxuICAgICAgICBkZWxldGVJdGVtKClcbiAgICAgIH0pXG4gICAgfVxuICB9KVxufSlcblxuZnVuY3Rpb24gZW1wdHlEaXJTeW5jIChkaXIpIHtcbiAgbGV0IGl0ZW1zXG4gIHRyeSB7XG4gICAgaXRlbXMgPSBmcy5yZWFkZGlyU3luYyhkaXIpXG4gIH0gY2F0Y2ggKGVycikge1xuICAgIHJldHVybiBta2Rpci5ta2RpcnNTeW5jKGRpcilcbiAgfVxuXG4gIGl0ZW1zLmZvckVhY2goaXRlbSA9PiB7XG4gICAgaXRlbSA9IHBhdGguam9pbihkaXIsIGl0ZW0pXG4gICAgcmVtb3ZlLnJlbW92ZVN5bmMoaXRlbSlcbiAgfSlcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGVtcHR5RGlyU3luYyxcbiAgZW1wdHlkaXJTeW5jOiBlbXB0eURpclN5bmMsXG4gIGVtcHR5RGlyLFxuICBlbXB0eWRpcjogZW1wdHlEaXJcbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9lbGVjdHJvbi11cGRhdGVyL25vZGVfbW9kdWxlcy9mcy1leHRyYS9saWIvZW1wdHkvaW5kZXguanMiLCIndXNlIHN0cmljdCdcblxuY29uc3QgZmlsZSA9IHJlcXVpcmUoJy4vZmlsZScpXG5jb25zdCBsaW5rID0gcmVxdWlyZSgnLi9saW5rJylcbmNvbnN0IHN5bWxpbmsgPSByZXF1aXJlKCcuL3N5bWxpbmsnKVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgLy8gZmlsZVxuICBjcmVhdGVGaWxlOiBmaWxlLmNyZWF0ZUZpbGUsXG4gIGNyZWF0ZUZpbGVTeW5jOiBmaWxlLmNyZWF0ZUZpbGVTeW5jLFxuICBlbnN1cmVGaWxlOiBmaWxlLmNyZWF0ZUZpbGUsXG4gIGVuc3VyZUZpbGVTeW5jOiBmaWxlLmNyZWF0ZUZpbGVTeW5jLFxuICAvLyBsaW5rXG4gIGNyZWF0ZUxpbms6IGxpbmsuY3JlYXRlTGluayxcbiAgY3JlYXRlTGlua1N5bmM6IGxpbmsuY3JlYXRlTGlua1N5bmMsXG4gIGVuc3VyZUxpbms6IGxpbmsuY3JlYXRlTGluayxcbiAgZW5zdXJlTGlua1N5bmM6IGxpbmsuY3JlYXRlTGlua1N5bmMsXG4gIC8vIHN5bWxpbmtcbiAgY3JlYXRlU3ltbGluazogc3ltbGluay5jcmVhdGVTeW1saW5rLFxuICBjcmVhdGVTeW1saW5rU3luYzogc3ltbGluay5jcmVhdGVTeW1saW5rU3luYyxcbiAgZW5zdXJlU3ltbGluazogc3ltbGluay5jcmVhdGVTeW1saW5rLFxuICBlbnN1cmVTeW1saW5rU3luYzogc3ltbGluay5jcmVhdGVTeW1saW5rU3luY1xufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2VsZWN0cm9uLXVwZGF0ZXIvbm9kZV9tb2R1bGVzL2ZzLWV4dHJhL2xpYi9lbnN1cmUvaW5kZXguanMiLCIndXNlIHN0cmljdCdcblxuY29uc3QgdSA9IHJlcXVpcmUoJ3VuaXZlcnNhbGlmeScpLmZyb21DYWxsYmFja1xuY29uc3QgcGF0aCA9IHJlcXVpcmUoJ3BhdGgnKVxuY29uc3QgZnMgPSByZXF1aXJlKCdncmFjZWZ1bC1mcycpXG5jb25zdCBta2RpciA9IHJlcXVpcmUoJy4uL21rZGlycycpXG5jb25zdCBwYXRoRXhpc3RzID0gcmVxdWlyZSgnLi4vcGF0aC1leGlzdHMnKS5wYXRoRXhpc3RzXG5cbmZ1bmN0aW9uIGNyZWF0ZUZpbGUgKGZpbGUsIGNhbGxiYWNrKSB7XG4gIGZ1bmN0aW9uIG1ha2VGaWxlICgpIHtcbiAgICBmcy53cml0ZUZpbGUoZmlsZSwgJycsIGVyciA9PiB7XG4gICAgICBpZiAoZXJyKSByZXR1cm4gY2FsbGJhY2soZXJyKVxuICAgICAgY2FsbGJhY2soKVxuICAgIH0pXG4gIH1cblxuICBmcy5zdGF0KGZpbGUsIChlcnIsIHN0YXRzKSA9PiB7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgaGFuZGxlLWNhbGxiYWNrLWVyclxuICAgIGlmICghZXJyICYmIHN0YXRzLmlzRmlsZSgpKSByZXR1cm4gY2FsbGJhY2soKVxuICAgIGNvbnN0IGRpciA9IHBhdGguZGlybmFtZShmaWxlKVxuICAgIHBhdGhFeGlzdHMoZGlyLCAoZXJyLCBkaXJFeGlzdHMpID0+IHtcbiAgICAgIGlmIChlcnIpIHJldHVybiBjYWxsYmFjayhlcnIpXG4gICAgICBpZiAoZGlyRXhpc3RzKSByZXR1cm4gbWFrZUZpbGUoKVxuICAgICAgbWtkaXIubWtkaXJzKGRpciwgZXJyID0+IHtcbiAgICAgICAgaWYgKGVycikgcmV0dXJuIGNhbGxiYWNrKGVycilcbiAgICAgICAgbWFrZUZpbGUoKVxuICAgICAgfSlcbiAgICB9KVxuICB9KVxufVxuXG5mdW5jdGlvbiBjcmVhdGVGaWxlU3luYyAoZmlsZSkge1xuICBsZXQgc3RhdHNcbiAgdHJ5IHtcbiAgICBzdGF0cyA9IGZzLnN0YXRTeW5jKGZpbGUpXG4gIH0gY2F0Y2ggKGUpIHt9XG4gIGlmIChzdGF0cyAmJiBzdGF0cy5pc0ZpbGUoKSkgcmV0dXJuXG5cbiAgY29uc3QgZGlyID0gcGF0aC5kaXJuYW1lKGZpbGUpXG4gIGlmICghZnMuZXhpc3RzU3luYyhkaXIpKSB7XG4gICAgbWtkaXIubWtkaXJzU3luYyhkaXIpXG4gIH1cblxuICBmcy53cml0ZUZpbGVTeW5jKGZpbGUsICcnKVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgY3JlYXRlRmlsZTogdShjcmVhdGVGaWxlKSxcbiAgY3JlYXRlRmlsZVN5bmNcbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9lbGVjdHJvbi11cGRhdGVyL25vZGVfbW9kdWxlcy9mcy1leHRyYS9saWIvZW5zdXJlL2ZpbGUuanMiLCIndXNlIHN0cmljdCdcblxuY29uc3QgdSA9IHJlcXVpcmUoJ3VuaXZlcnNhbGlmeScpLmZyb21DYWxsYmFja1xuY29uc3QgcGF0aCA9IHJlcXVpcmUoJ3BhdGgnKVxuY29uc3QgZnMgPSByZXF1aXJlKCdncmFjZWZ1bC1mcycpXG5jb25zdCBta2RpciA9IHJlcXVpcmUoJy4uL21rZGlycycpXG5jb25zdCBwYXRoRXhpc3RzID0gcmVxdWlyZSgnLi4vcGF0aC1leGlzdHMnKS5wYXRoRXhpc3RzXG5cbmZ1bmN0aW9uIGNyZWF0ZUxpbmsgKHNyY3BhdGgsIGRzdHBhdGgsIGNhbGxiYWNrKSB7XG4gIGZ1bmN0aW9uIG1ha2VMaW5rIChzcmNwYXRoLCBkc3RwYXRoKSB7XG4gICAgZnMubGluayhzcmNwYXRoLCBkc3RwYXRoLCBlcnIgPT4ge1xuICAgICAgaWYgKGVycikgcmV0dXJuIGNhbGxiYWNrKGVycilcbiAgICAgIGNhbGxiYWNrKG51bGwpXG4gICAgfSlcbiAgfVxuXG4gIHBhdGhFeGlzdHMoZHN0cGF0aCwgKGVyciwgZGVzdGluYXRpb25FeGlzdHMpID0+IHtcbiAgICBpZiAoZXJyKSByZXR1cm4gY2FsbGJhY2soZXJyKVxuICAgIGlmIChkZXN0aW5hdGlvbkV4aXN0cykgcmV0dXJuIGNhbGxiYWNrKG51bGwpXG4gICAgZnMubHN0YXQoc3JjcGF0aCwgKGVyciwgc3RhdCkgPT4ge1xuICAgICAgaWYgKGVycikge1xuICAgICAgICBlcnIubWVzc2FnZSA9IGVyci5tZXNzYWdlLnJlcGxhY2UoJ2xzdGF0JywgJ2Vuc3VyZUxpbmsnKVxuICAgICAgICByZXR1cm4gY2FsbGJhY2soZXJyKVxuICAgICAgfVxuXG4gICAgICBjb25zdCBkaXIgPSBwYXRoLmRpcm5hbWUoZHN0cGF0aClcbiAgICAgIHBhdGhFeGlzdHMoZGlyLCAoZXJyLCBkaXJFeGlzdHMpID0+IHtcbiAgICAgICAgaWYgKGVycikgcmV0dXJuIGNhbGxiYWNrKGVycilcbiAgICAgICAgaWYgKGRpckV4aXN0cykgcmV0dXJuIG1ha2VMaW5rKHNyY3BhdGgsIGRzdHBhdGgpXG4gICAgICAgIG1rZGlyLm1rZGlycyhkaXIsIGVyciA9PiB7XG4gICAgICAgICAgaWYgKGVycikgcmV0dXJuIGNhbGxiYWNrKGVycilcbiAgICAgICAgICBtYWtlTGluayhzcmNwYXRoLCBkc3RwYXRoKVxuICAgICAgICB9KVxuICAgICAgfSlcbiAgICB9KVxuICB9KVxufVxuXG5mdW5jdGlvbiBjcmVhdGVMaW5rU3luYyAoc3JjcGF0aCwgZHN0cGF0aCwgY2FsbGJhY2spIHtcbiAgY29uc3QgZGVzdGluYXRpb25FeGlzdHMgPSBmcy5leGlzdHNTeW5jKGRzdHBhdGgpXG4gIGlmIChkZXN0aW5hdGlvbkV4aXN0cykgcmV0dXJuIHVuZGVmaW5lZFxuXG4gIHRyeSB7XG4gICAgZnMubHN0YXRTeW5jKHNyY3BhdGgpXG4gIH0gY2F0Y2ggKGVycikge1xuICAgIGVyci5tZXNzYWdlID0gZXJyLm1lc3NhZ2UucmVwbGFjZSgnbHN0YXQnLCAnZW5zdXJlTGluaycpXG4gICAgdGhyb3cgZXJyXG4gIH1cblxuICBjb25zdCBkaXIgPSBwYXRoLmRpcm5hbWUoZHN0cGF0aClcbiAgY29uc3QgZGlyRXhpc3RzID0gZnMuZXhpc3RzU3luYyhkaXIpXG4gIGlmIChkaXJFeGlzdHMpIHJldHVybiBmcy5saW5rU3luYyhzcmNwYXRoLCBkc3RwYXRoKVxuICBta2Rpci5ta2RpcnNTeW5jKGRpcilcblxuICByZXR1cm4gZnMubGlua1N5bmMoc3JjcGF0aCwgZHN0cGF0aClcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGNyZWF0ZUxpbms6IHUoY3JlYXRlTGluayksXG4gIGNyZWF0ZUxpbmtTeW5jXG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvZWxlY3Ryb24tdXBkYXRlci9ub2RlX21vZHVsZXMvZnMtZXh0cmEvbGliL2Vuc3VyZS9saW5rLmpzIiwiJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IHUgPSByZXF1aXJlKCd1bml2ZXJzYWxpZnknKS5mcm9tQ2FsbGJhY2tcbmNvbnN0IHBhdGggPSByZXF1aXJlKCdwYXRoJylcbmNvbnN0IGZzID0gcmVxdWlyZSgnZ3JhY2VmdWwtZnMnKVxuY29uc3QgX21rZGlycyA9IHJlcXVpcmUoJy4uL21rZGlycycpXG5jb25zdCBta2RpcnMgPSBfbWtkaXJzLm1rZGlyc1xuY29uc3QgbWtkaXJzU3luYyA9IF9ta2RpcnMubWtkaXJzU3luY1xuXG5jb25zdCBfc3ltbGlua1BhdGhzID0gcmVxdWlyZSgnLi9zeW1saW5rLXBhdGhzJylcbmNvbnN0IHN5bWxpbmtQYXRocyA9IF9zeW1saW5rUGF0aHMuc3ltbGlua1BhdGhzXG5jb25zdCBzeW1saW5rUGF0aHNTeW5jID0gX3N5bWxpbmtQYXRocy5zeW1saW5rUGF0aHNTeW5jXG5cbmNvbnN0IF9zeW1saW5rVHlwZSA9IHJlcXVpcmUoJy4vc3ltbGluay10eXBlJylcbmNvbnN0IHN5bWxpbmtUeXBlID0gX3N5bWxpbmtUeXBlLnN5bWxpbmtUeXBlXG5jb25zdCBzeW1saW5rVHlwZVN5bmMgPSBfc3ltbGlua1R5cGUuc3ltbGlua1R5cGVTeW5jXG5cbmNvbnN0IHBhdGhFeGlzdHMgPSByZXF1aXJlKCcuLi9wYXRoLWV4aXN0cycpLnBhdGhFeGlzdHNcblxuZnVuY3Rpb24gY3JlYXRlU3ltbGluayAoc3JjcGF0aCwgZHN0cGF0aCwgdHlwZSwgY2FsbGJhY2spIHtcbiAgY2FsbGJhY2sgPSAodHlwZW9mIHR5cGUgPT09ICdmdW5jdGlvbicpID8gdHlwZSA6IGNhbGxiYWNrXG4gIHR5cGUgPSAodHlwZW9mIHR5cGUgPT09ICdmdW5jdGlvbicpID8gZmFsc2UgOiB0eXBlXG5cbiAgcGF0aEV4aXN0cyhkc3RwYXRoLCAoZXJyLCBkZXN0aW5hdGlvbkV4aXN0cykgPT4ge1xuICAgIGlmIChlcnIpIHJldHVybiBjYWxsYmFjayhlcnIpXG4gICAgaWYgKGRlc3RpbmF0aW9uRXhpc3RzKSByZXR1cm4gY2FsbGJhY2sobnVsbClcbiAgICBzeW1saW5rUGF0aHMoc3JjcGF0aCwgZHN0cGF0aCwgKGVyciwgcmVsYXRpdmUpID0+IHtcbiAgICAgIGlmIChlcnIpIHJldHVybiBjYWxsYmFjayhlcnIpXG4gICAgICBzcmNwYXRoID0gcmVsYXRpdmUudG9Ec3RcbiAgICAgIHN5bWxpbmtUeXBlKHJlbGF0aXZlLnRvQ3dkLCB0eXBlLCAoZXJyLCB0eXBlKSA9PiB7XG4gICAgICAgIGlmIChlcnIpIHJldHVybiBjYWxsYmFjayhlcnIpXG4gICAgICAgIGNvbnN0IGRpciA9IHBhdGguZGlybmFtZShkc3RwYXRoKVxuICAgICAgICBwYXRoRXhpc3RzKGRpciwgKGVyciwgZGlyRXhpc3RzKSA9PiB7XG4gICAgICAgICAgaWYgKGVycikgcmV0dXJuIGNhbGxiYWNrKGVycilcbiAgICAgICAgICBpZiAoZGlyRXhpc3RzKSByZXR1cm4gZnMuc3ltbGluayhzcmNwYXRoLCBkc3RwYXRoLCB0eXBlLCBjYWxsYmFjaylcbiAgICAgICAgICBta2RpcnMoZGlyLCBlcnIgPT4ge1xuICAgICAgICAgICAgaWYgKGVycikgcmV0dXJuIGNhbGxiYWNrKGVycilcbiAgICAgICAgICAgIGZzLnN5bWxpbmsoc3JjcGF0aCwgZHN0cGF0aCwgdHlwZSwgY2FsbGJhY2spXG4gICAgICAgICAgfSlcbiAgICAgICAgfSlcbiAgICAgIH0pXG4gICAgfSlcbiAgfSlcbn1cblxuZnVuY3Rpb24gY3JlYXRlU3ltbGlua1N5bmMgKHNyY3BhdGgsIGRzdHBhdGgsIHR5cGUsIGNhbGxiYWNrKSB7XG4gIGNhbGxiYWNrID0gKHR5cGVvZiB0eXBlID09PSAnZnVuY3Rpb24nKSA/IHR5cGUgOiBjYWxsYmFja1xuICB0eXBlID0gKHR5cGVvZiB0eXBlID09PSAnZnVuY3Rpb24nKSA/IGZhbHNlIDogdHlwZVxuXG4gIGNvbnN0IGRlc3RpbmF0aW9uRXhpc3RzID0gZnMuZXhpc3RzU3luYyhkc3RwYXRoKVxuICBpZiAoZGVzdGluYXRpb25FeGlzdHMpIHJldHVybiB1bmRlZmluZWRcblxuICBjb25zdCByZWxhdGl2ZSA9IHN5bWxpbmtQYXRoc1N5bmMoc3JjcGF0aCwgZHN0cGF0aClcbiAgc3JjcGF0aCA9IHJlbGF0aXZlLnRvRHN0XG4gIHR5cGUgPSBzeW1saW5rVHlwZVN5bmMocmVsYXRpdmUudG9Dd2QsIHR5cGUpXG4gIGNvbnN0IGRpciA9IHBhdGguZGlybmFtZShkc3RwYXRoKVxuICBjb25zdCBleGlzdHMgPSBmcy5leGlzdHNTeW5jKGRpcilcbiAgaWYgKGV4aXN0cykgcmV0dXJuIGZzLnN5bWxpbmtTeW5jKHNyY3BhdGgsIGRzdHBhdGgsIHR5cGUpXG4gIG1rZGlyc1N5bmMoZGlyKVxuICByZXR1cm4gZnMuc3ltbGlua1N5bmMoc3JjcGF0aCwgZHN0cGF0aCwgdHlwZSlcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGNyZWF0ZVN5bWxpbms6IHUoY3JlYXRlU3ltbGluayksXG4gIGNyZWF0ZVN5bWxpbmtTeW5jXG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvZWxlY3Ryb24tdXBkYXRlci9ub2RlX21vZHVsZXMvZnMtZXh0cmEvbGliL2Vuc3VyZS9zeW1saW5rLmpzIiwiJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IHBhdGggPSByZXF1aXJlKCdwYXRoJylcbmNvbnN0IGZzID0gcmVxdWlyZSgnZ3JhY2VmdWwtZnMnKVxuY29uc3QgcGF0aEV4aXN0cyA9IHJlcXVpcmUoJy4uL3BhdGgtZXhpc3RzJykucGF0aEV4aXN0c1xuXG4vKipcbiAqIEZ1bmN0aW9uIHRoYXQgcmV0dXJucyB0d28gdHlwZXMgb2YgcGF0aHMsIG9uZSByZWxhdGl2ZSB0byBzeW1saW5rLCBhbmQgb25lXG4gKiByZWxhdGl2ZSB0byB0aGUgY3VycmVudCB3b3JraW5nIGRpcmVjdG9yeS4gQ2hlY2tzIGlmIHBhdGggaXMgYWJzb2x1dGUgb3JcbiAqIHJlbGF0aXZlLiBJZiB0aGUgcGF0aCBpcyByZWxhdGl2ZSwgdGhpcyBmdW5jdGlvbiBjaGVja3MgaWYgdGhlIHBhdGggaXNcbiAqIHJlbGF0aXZlIHRvIHN5bWxpbmsgb3IgcmVsYXRpdmUgdG8gY3VycmVudCB3b3JraW5nIGRpcmVjdG9yeS4gVGhpcyBpcyBhblxuICogaW5pdGlhdGl2ZSB0byBmaW5kIGEgc21hcnRlciBgc3JjcGF0aGAgdG8gc3VwcGx5IHdoZW4gYnVpbGRpbmcgc3ltbGlua3MuXG4gKiBUaGlzIGFsbG93cyB5b3UgdG8gZGV0ZXJtaW5lIHdoaWNoIHBhdGggdG8gdXNlIG91dCBvZiBvbmUgb2YgdGhyZWUgcG9zc2libGVcbiAqIHR5cGVzIG9mIHNvdXJjZSBwYXRocy4gVGhlIGZpcnN0IGlzIGFuIGFic29sdXRlIHBhdGguIFRoaXMgaXMgZGV0ZWN0ZWQgYnlcbiAqIGBwYXRoLmlzQWJzb2x1dGUoKWAuIFdoZW4gYW4gYWJzb2x1dGUgcGF0aCBpcyBwcm92aWRlZCwgaXQgaXMgY2hlY2tlZCB0b1xuICogc2VlIGlmIGl0IGV4aXN0cy4gSWYgaXQgZG9lcyBpdCdzIHVzZWQsIGlmIG5vdCBhbiBlcnJvciBpcyByZXR1cm5lZFxuICogKGNhbGxiYWNrKS8gdGhyb3duIChzeW5jKS4gVGhlIG90aGVyIHR3byBvcHRpb25zIGZvciBgc3JjcGF0aGAgYXJlIGFcbiAqIHJlbGF0aXZlIHVybC4gQnkgZGVmYXVsdCBOb2RlJ3MgYGZzLnN5bWxpbmtgIHdvcmtzIGJ5IGNyZWF0aW5nIGEgc3ltbGlua1xuICogdXNpbmcgYGRzdHBhdGhgIGFuZCBleHBlY3RzIHRoZSBgc3JjcGF0aGAgdG8gYmUgcmVsYXRpdmUgdG8gdGhlIG5ld2x5XG4gKiBjcmVhdGVkIHN5bWxpbmsuIElmIHlvdSBwcm92aWRlIGEgYHNyY3BhdGhgIHRoYXQgZG9lcyBub3QgZXhpc3Qgb24gdGhlIGZpbGVcbiAqIHN5c3RlbSBpdCByZXN1bHRzIGluIGEgYnJva2VuIHN5bWxpbmsuIFRvIG1pbmltaXplIHRoaXMsIHRoZSBmdW5jdGlvblxuICogY2hlY2tzIHRvIHNlZSBpZiB0aGUgJ3JlbGF0aXZlIHRvIHN5bWxpbmsnIHNvdXJjZSBmaWxlIGV4aXN0cywgYW5kIGlmIGl0XG4gKiBkb2VzIGl0IHdpbGwgdXNlIGl0LiBJZiBpdCBkb2VzIG5vdCwgaXQgY2hlY2tzIGlmIHRoZXJlJ3MgYSBmaWxlIHRoYXRcbiAqIGV4aXN0cyB0aGF0IGlzIHJlbGF0aXZlIHRvIHRoZSBjdXJyZW50IHdvcmtpbmcgZGlyZWN0b3J5LCBpZiBkb2VzIGl0cyB1c2VkLlxuICogVGhpcyBwcmVzZXJ2ZXMgdGhlIGV4cGVjdGF0aW9ucyBvZiB0aGUgb3JpZ2luYWwgZnMuc3ltbGluayBzcGVjIGFuZCBhZGRzXG4gKiB0aGUgYWJpbGl0eSB0byBwYXNzIGluIGByZWxhdGl2ZSB0byBjdXJyZW50IHdvcmtpbmcgZGlyZWNvdHJ5YCBwYXRocy5cbiAqL1xuXG5mdW5jdGlvbiBzeW1saW5rUGF0aHMgKHNyY3BhdGgsIGRzdHBhdGgsIGNhbGxiYWNrKSB7XG4gIGlmIChwYXRoLmlzQWJzb2x1dGUoc3JjcGF0aCkpIHtcbiAgICByZXR1cm4gZnMubHN0YXQoc3JjcGF0aCwgKGVyciwgc3RhdCkgPT4ge1xuICAgICAgaWYgKGVycikge1xuICAgICAgICBlcnIubWVzc2FnZSA9IGVyci5tZXNzYWdlLnJlcGxhY2UoJ2xzdGF0JywgJ2Vuc3VyZVN5bWxpbmsnKVxuICAgICAgICByZXR1cm4gY2FsbGJhY2soZXJyKVxuICAgICAgfVxuICAgICAgcmV0dXJuIGNhbGxiYWNrKG51bGwsIHtcbiAgICAgICAgJ3RvQ3dkJzogc3JjcGF0aCxcbiAgICAgICAgJ3RvRHN0Jzogc3JjcGF0aFxuICAgICAgfSlcbiAgICB9KVxuICB9IGVsc2Uge1xuICAgIGNvbnN0IGRzdGRpciA9IHBhdGguZGlybmFtZShkc3RwYXRoKVxuICAgIGNvbnN0IHJlbGF0aXZlVG9Ec3QgPSBwYXRoLmpvaW4oZHN0ZGlyLCBzcmNwYXRoKVxuICAgIHJldHVybiBwYXRoRXhpc3RzKHJlbGF0aXZlVG9Ec3QsIChlcnIsIGV4aXN0cykgPT4ge1xuICAgICAgaWYgKGVycikgcmV0dXJuIGNhbGxiYWNrKGVycilcbiAgICAgIGlmIChleGlzdHMpIHtcbiAgICAgICAgcmV0dXJuIGNhbGxiYWNrKG51bGwsIHtcbiAgICAgICAgICAndG9Dd2QnOiByZWxhdGl2ZVRvRHN0LFxuICAgICAgICAgICd0b0RzdCc6IHNyY3BhdGhcbiAgICAgICAgfSlcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBmcy5sc3RhdChzcmNwYXRoLCAoZXJyLCBzdGF0KSA9PiB7XG4gICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgZXJyLm1lc3NhZ2UgPSBlcnIubWVzc2FnZS5yZXBsYWNlKCdsc3RhdCcsICdlbnN1cmVTeW1saW5rJylcbiAgICAgICAgICAgIHJldHVybiBjYWxsYmFjayhlcnIpXG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBjYWxsYmFjayhudWxsLCB7XG4gICAgICAgICAgICAndG9Dd2QnOiBzcmNwYXRoLFxuICAgICAgICAgICAgJ3RvRHN0JzogcGF0aC5yZWxhdGl2ZShkc3RkaXIsIHNyY3BhdGgpXG4gICAgICAgICAgfSlcbiAgICAgICAgfSlcbiAgICAgIH1cbiAgICB9KVxuICB9XG59XG5cbmZ1bmN0aW9uIHN5bWxpbmtQYXRoc1N5bmMgKHNyY3BhdGgsIGRzdHBhdGgpIHtcbiAgbGV0IGV4aXN0c1xuICBpZiAocGF0aC5pc0Fic29sdXRlKHNyY3BhdGgpKSB7XG4gICAgZXhpc3RzID0gZnMuZXhpc3RzU3luYyhzcmNwYXRoKVxuICAgIGlmICghZXhpc3RzKSB0aHJvdyBuZXcgRXJyb3IoJ2Fic29sdXRlIHNyY3BhdGggZG9lcyBub3QgZXhpc3QnKVxuICAgIHJldHVybiB7XG4gICAgICAndG9Dd2QnOiBzcmNwYXRoLFxuICAgICAgJ3RvRHN0Jzogc3JjcGF0aFxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBjb25zdCBkc3RkaXIgPSBwYXRoLmRpcm5hbWUoZHN0cGF0aClcbiAgICBjb25zdCByZWxhdGl2ZVRvRHN0ID0gcGF0aC5qb2luKGRzdGRpciwgc3JjcGF0aClcbiAgICBleGlzdHMgPSBmcy5leGlzdHNTeW5jKHJlbGF0aXZlVG9Ec3QpXG4gICAgaWYgKGV4aXN0cykge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgJ3RvQ3dkJzogcmVsYXRpdmVUb0RzdCxcbiAgICAgICAgJ3RvRHN0Jzogc3JjcGF0aFxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBleGlzdHMgPSBmcy5leGlzdHNTeW5jKHNyY3BhdGgpXG4gICAgICBpZiAoIWV4aXN0cykgdGhyb3cgbmV3IEVycm9yKCdyZWxhdGl2ZSBzcmNwYXRoIGRvZXMgbm90IGV4aXN0JylcbiAgICAgIHJldHVybiB7XG4gICAgICAgICd0b0N3ZCc6IHNyY3BhdGgsXG4gICAgICAgICd0b0RzdCc6IHBhdGgucmVsYXRpdmUoZHN0ZGlyLCBzcmNwYXRoKVxuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgc3ltbGlua1BhdGhzLFxuICBzeW1saW5rUGF0aHNTeW5jXG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvZWxlY3Ryb24tdXBkYXRlci9ub2RlX21vZHVsZXMvZnMtZXh0cmEvbGliL2Vuc3VyZS9zeW1saW5rLXBhdGhzLmpzIiwiJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IGZzID0gcmVxdWlyZSgnZ3JhY2VmdWwtZnMnKVxuXG5mdW5jdGlvbiBzeW1saW5rVHlwZSAoc3JjcGF0aCwgdHlwZSwgY2FsbGJhY2spIHtcbiAgY2FsbGJhY2sgPSAodHlwZW9mIHR5cGUgPT09ICdmdW5jdGlvbicpID8gdHlwZSA6IGNhbGxiYWNrXG4gIHR5cGUgPSAodHlwZW9mIHR5cGUgPT09ICdmdW5jdGlvbicpID8gZmFsc2UgOiB0eXBlXG4gIGlmICh0eXBlKSByZXR1cm4gY2FsbGJhY2sobnVsbCwgdHlwZSlcbiAgZnMubHN0YXQoc3JjcGF0aCwgKGVyciwgc3RhdHMpID0+IHtcbiAgICBpZiAoZXJyKSByZXR1cm4gY2FsbGJhY2sobnVsbCwgJ2ZpbGUnKVxuICAgIHR5cGUgPSAoc3RhdHMgJiYgc3RhdHMuaXNEaXJlY3RvcnkoKSkgPyAnZGlyJyA6ICdmaWxlJ1xuICAgIGNhbGxiYWNrKG51bGwsIHR5cGUpXG4gIH0pXG59XG5cbmZ1bmN0aW9uIHN5bWxpbmtUeXBlU3luYyAoc3JjcGF0aCwgdHlwZSkge1xuICBsZXQgc3RhdHNcblxuICBpZiAodHlwZSkgcmV0dXJuIHR5cGVcbiAgdHJ5IHtcbiAgICBzdGF0cyA9IGZzLmxzdGF0U3luYyhzcmNwYXRoKVxuICB9IGNhdGNoIChlKSB7XG4gICAgcmV0dXJuICdmaWxlJ1xuICB9XG4gIHJldHVybiAoc3RhdHMgJiYgc3RhdHMuaXNEaXJlY3RvcnkoKSkgPyAnZGlyJyA6ICdmaWxlJ1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgc3ltbGlua1R5cGUsXG4gIHN5bWxpbmtUeXBlU3luY1xufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2VsZWN0cm9uLXVwZGF0ZXIvbm9kZV9tb2R1bGVzL2ZzLWV4dHJhL2xpYi9lbnN1cmUvc3ltbGluay10eXBlLmpzIiwiJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IHUgPSByZXF1aXJlKCd1bml2ZXJzYWxpZnknKS5mcm9tQ2FsbGJhY2tcbmNvbnN0IGZzID0gcmVxdWlyZSgnZ3JhY2VmdWwtZnMnKVxuY29uc3QgcGF0aCA9IHJlcXVpcmUoJ3BhdGgnKVxuY29uc3QgbWtkaXIgPSByZXF1aXJlKCcuLi9ta2RpcnMnKVxuY29uc3QgcGF0aEV4aXN0cyA9IHJlcXVpcmUoJy4uL3BhdGgtZXhpc3RzJykucGF0aEV4aXN0c1xuXG5mdW5jdGlvbiBvdXRwdXRGaWxlIChmaWxlLCBkYXRhLCBlbmNvZGluZywgY2FsbGJhY2spIHtcbiAgaWYgKHR5cGVvZiBlbmNvZGluZyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGNhbGxiYWNrID0gZW5jb2RpbmdcbiAgICBlbmNvZGluZyA9ICd1dGY4J1xuICB9XG5cbiAgY29uc3QgZGlyID0gcGF0aC5kaXJuYW1lKGZpbGUpXG4gIHBhdGhFeGlzdHMoZGlyLCAoZXJyLCBpdERvZXMpID0+IHtcbiAgICBpZiAoZXJyKSByZXR1cm4gY2FsbGJhY2soZXJyKVxuICAgIGlmIChpdERvZXMpIHJldHVybiBmcy53cml0ZUZpbGUoZmlsZSwgZGF0YSwgZW5jb2RpbmcsIGNhbGxiYWNrKVxuXG4gICAgbWtkaXIubWtkaXJzKGRpciwgZXJyID0+IHtcbiAgICAgIGlmIChlcnIpIHJldHVybiBjYWxsYmFjayhlcnIpXG5cbiAgICAgIGZzLndyaXRlRmlsZShmaWxlLCBkYXRhLCBlbmNvZGluZywgY2FsbGJhY2spXG4gICAgfSlcbiAgfSlcbn1cblxuZnVuY3Rpb24gb3V0cHV0RmlsZVN5bmMgKGZpbGUsIGRhdGEsIGVuY29kaW5nKSB7XG4gIGNvbnN0IGRpciA9IHBhdGguZGlybmFtZShmaWxlKVxuICBpZiAoZnMuZXhpc3RzU3luYyhkaXIpKSB7XG4gICAgcmV0dXJuIGZzLndyaXRlRmlsZVN5bmMuYXBwbHkoZnMsIGFyZ3VtZW50cylcbiAgfVxuICBta2Rpci5ta2RpcnNTeW5jKGRpcilcbiAgZnMud3JpdGVGaWxlU3luYy5hcHBseShmcywgYXJndW1lbnRzKVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgb3V0cHV0RmlsZTogdShvdXRwdXRGaWxlKSxcbiAgb3V0cHV0RmlsZVN5bmNcbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9lbGVjdHJvbi11cGRhdGVyL25vZGVfbW9kdWxlcy9mcy1leHRyYS9saWIvb3V0cHV0L2luZGV4LmpzIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZ2l0aHViVXJsID0gZ2l0aHViVXJsO1xuZXhwb3J0cy5nZXRTM0xpa2VQcm92aWRlckJhc2VVcmwgPSBnZXRTM0xpa2VQcm92aWRlckJhc2VVcmw7XG4vKiogQHByaXZhdGUgKi9cbmZ1bmN0aW9uIGdpdGh1YlVybChvcHRpb25zLCBkZWZhdWx0SG9zdCA9IFwiZ2l0aHViLmNvbVwiKSB7XG4gICAgcmV0dXJuIGAke29wdGlvbnMucHJvdG9jb2wgfHwgXCJodHRwc1wifTovLyR7b3B0aW9ucy5ob3N0IHx8IGRlZmF1bHRIb3N0fWA7XG59XG5mdW5jdGlvbiBnZXRTM0xpa2VQcm92aWRlckJhc2VVcmwoY29uZmlndXJhdGlvbikge1xuICAgIGNvbnN0IHByb3ZpZGVyID0gY29uZmlndXJhdGlvbi5wcm92aWRlcjtcbiAgICBpZiAocHJvdmlkZXIgPT09IFwiczNcIikge1xuICAgICAgICByZXR1cm4gczNVcmwoY29uZmlndXJhdGlvbik7XG4gICAgfVxuICAgIGlmIChwcm92aWRlciA9PT0gXCJzcGFjZXNcIikge1xuICAgICAgICByZXR1cm4gc3BhY2VzVXJsKGNvbmZpZ3VyYXRpb24pO1xuICAgIH1cbiAgICB0aHJvdyBuZXcgRXJyb3IoYE5vdCBzdXBwb3J0ZWQgcHJvdmlkZXI6ICR7cHJvdmlkZXJ9YCk7XG59XG5mdW5jdGlvbiBzM1VybChvcHRpb25zKSB7XG4gICAgbGV0IHVybDtcbiAgICBpZiAob3B0aW9ucy5lbmRwb2ludCAhPSBudWxsKSB7XG4gICAgICAgIHVybCA9IGAke29wdGlvbnMuZW5kcG9pbnR9LyR7b3B0aW9ucy5idWNrZXR9YDtcbiAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoIW9wdGlvbnMuYnVja2V0LmluY2x1ZGVzKFwiLlwiKSkge1xuICAgICAgICAgICAgaWYgKG9wdGlvbnMucmVnaW9uID09PSBcImNuLW5vcnRoLTFcIikge1xuICAgICAgICAgICAgICAgIHVybCA9IGBodHRwczovLyR7b3B0aW9ucy5idWNrZXR9LnMzLiR7b3B0aW9ucy5yZWdpb259LmFtYXpvbmF3cy5jb20uY25gO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB1cmwgPSBgaHR0cHM6Ly8ke29wdGlvbnMuYnVja2V0fS5zMy5hbWF6b25hd3MuY29tYDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmIChvcHRpb25zLnJlZ2lvbiA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBCdWNrZXQgbmFtZSBcIiR7b3B0aW9ucy5idWNrZXR9XCIgaW5jbHVkZXMgYSBkb3QsIGJ1dCBTMyByZWdpb24gaXMgbWlzc2luZ2ApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gc3BlY2lhbCBjYXNlLCBzZWUgaHR0cDovL2RvY3MuYXdzLmFtYXpvbi5jb20vQW1hem9uUzMvbGF0ZXN0L2Rldi9Vc2luZ0J1Y2tldC5odG1sI2FjY2Vzcy1idWNrZXQtaW50cm9cbiAgICAgICAgICAgIHVybCA9IG9wdGlvbnMucmVnaW9uID09PSBcInVzLWVhc3QtMVwiID8gYGh0dHBzOi8vczMuYW1hem9uYXdzLmNvbS8ke29wdGlvbnMuYnVja2V0fWAgOiBgaHR0cHM6Ly9zMy0ke29wdGlvbnMucmVnaW9ufS5hbWF6b25hd3MuY29tLyR7b3B0aW9ucy5idWNrZXR9YDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAob3B0aW9ucy5wYXRoICE9IG51bGwpIHtcbiAgICAgICAgdXJsICs9IGAvJHtvcHRpb25zLnBhdGh9YDtcbiAgICB9XG4gICAgcmV0dXJuIHVybDtcbn1cbmZ1bmN0aW9uIHNwYWNlc1VybChvcHRpb25zKSB7XG4gICAgaWYgKG9wdGlvbnMubmFtZSA9PSBudWxsKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgbmFtZSBpcyBtaXNzaW5nYCk7XG4gICAgfVxuICAgIGlmIChvcHRpb25zLnJlZ2lvbiA9PSBudWxsKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgcmVnaW9uIGlzIG1pc3NpbmdgKTtcbiAgICB9XG4gICAgbGV0IHVybCA9IGBodHRwczovLyR7b3B0aW9ucy5uYW1lfS4ke29wdGlvbnMucmVnaW9ufS5kaWdpdGFsb2NlYW5zcGFjZXMuY29tYDtcbiAgICBpZiAob3B0aW9ucy5wYXRoICE9IG51bGwpIHtcbiAgICAgICAgdXJsICs9IGAvJHtvcHRpb25zLnBhdGh9YDtcbiAgICB9XG4gICAgcmV0dXJuIHVybDtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXB1Ymxpc2hPcHRpb25zLmpzLm1hcFxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9lbGVjdHJvbi11cGRhdGVyL25vZGVfbW9kdWxlcy9idWlsZGVyLXV0aWwtcnVudGltZS9vdXQvcHVibGlzaE9wdGlvbnMuanMiLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMucGFyc2VEbiA9IHBhcnNlRG47XG5mdW5jdGlvbiBwYXJzZURuKHNlcSkge1xuICAgIGxldCBxdW90ZWQgPSBmYWxzZTtcbiAgICBsZXQga2V5ID0gbnVsbDtcbiAgICBsZXQgdG9rZW4gPSBcIlwiO1xuICAgIGxldCBuZXh0Tm9uU3BhY2UgPSAwO1xuICAgIHNlcSA9IHNlcS50cmltKCk7XG4gICAgY29uc3QgcmVzdWx0ID0gbmV3IE1hcCgpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDw9IHNlcS5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoaSA9PT0gc2VxLmxlbmd0aCkge1xuICAgICAgICAgICAgaWYgKGtleSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJlc3VsdC5zZXQoa2V5LCB0b2tlbik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBjaCA9IHNlcVtpXTtcbiAgICAgICAgaWYgKHF1b3RlZCkge1xuICAgICAgICAgICAgaWYgKGNoID09PSAnXCInKSB7XG4gICAgICAgICAgICAgICAgcXVvdGVkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAoY2ggPT09ICdcIicpIHtcbiAgICAgICAgICAgICAgICBxdW90ZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGNoID09PSBcIlxcXFxcIikge1xuICAgICAgICAgICAgICAgIGkrKztcbiAgICAgICAgICAgICAgICBjb25zdCBvcmQgPSBwYXJzZUludChzZXEuc2xpY2UoaSwgaSArIDIpLCAxNik7XG4gICAgICAgICAgICAgICAgaWYgKE51bWJlci5pc05hTihvcmQpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRva2VuICs9IHNlcVtpXTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpKys7XG4gICAgICAgICAgICAgICAgICAgIHRva2VuICs9IFN0cmluZy5mcm9tQ2hhckNvZGUob3JkKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoa2V5ID09PSBudWxsICYmIGNoID09PSBcIj1cIikge1xuICAgICAgICAgICAgICAgIGtleSA9IHRva2VuO1xuICAgICAgICAgICAgICAgIHRva2VuID0gXCJcIjtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjaCA9PT0gXCIsXCIgfHwgY2ggPT09IFwiO1wiIHx8IGNoID09PSBcIitcIikge1xuICAgICAgICAgICAgICAgIGlmIChrZXkgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnNldChrZXksIHRva2VuKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAga2V5ID0gbnVsbDtcbiAgICAgICAgICAgICAgICB0b2tlbiA9IFwiXCI7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNoID09PSBcIiBcIiAmJiAhcXVvdGVkKSB7XG4gICAgICAgICAgICBpZiAodG9rZW4ubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaSA+IG5leHROb25TcGFjZSkge1xuICAgICAgICAgICAgICAgIGxldCBqID0gaTtcbiAgICAgICAgICAgICAgICB3aGlsZSAoc2VxW2pdID09PSBcIiBcIikge1xuICAgICAgICAgICAgICAgICAgICBqKys7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG5leHROb25TcGFjZSA9IGo7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobmV4dE5vblNwYWNlID49IHNlcS5sZW5ndGggfHwgc2VxW25leHROb25TcGFjZV0gPT09IFwiLFwiIHx8IHNlcVtuZXh0Tm9uU3BhY2VdID09PSBcIjtcIiB8fCBrZXkgPT09IG51bGwgJiYgc2VxW25leHROb25TcGFjZV0gPT09IFwiPVwiIHx8IGtleSAhPT0gbnVsbCAmJiBzZXFbbmV4dE5vblNwYWNlXSA9PT0gXCIrXCIpIHtcbiAgICAgICAgICAgICAgICBpID0gbmV4dE5vblNwYWNlIC0gMTtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0b2tlbiArPSBjaDtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXJmYzIyNTNQYXJzZXIuanMubWFwXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2VsZWN0cm9uLXVwZGF0ZXIvbm9kZV9tb2R1bGVzL2J1aWxkZXItdXRpbC1ydW50aW1lL291dC9yZmMyMjUzUGFyc2VyLmpzIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMubmlsID0gZXhwb3J0cy5VVUlEID0gdW5kZWZpbmVkO1xuXG52YXIgX2NyeXB0bztcblxuZnVuY3Rpb24gX2xvYWRfY3J5cHRvKCkge1xuICAgIHJldHVybiBfY3J5cHRvID0gcmVxdWlyZShcImNyeXB0b1wiKTtcbn1cblxudmFyIF9pbmRleDtcblxuZnVuY3Rpb24gX2xvYWRfaW5kZXgoKSB7XG4gICAgcmV0dXJuIF9pbmRleCA9IHJlcXVpcmUoXCIuL2luZGV4XCIpO1xufVxuXG5jb25zdCBpbnZhbGlkTmFtZSA9IFwib3B0aW9ucy5uYW1lIG11c3QgYmUgZWl0aGVyIGEgc3RyaW5nIG9yIGEgQnVmZmVyXCI7XG5jb25zdCBtb3JlVGhhbjEwMDAwID0gXCJjYW4gbm90IGdlbmVyYXRlIG1vcmUgdGhhbiAxMDAwMCBVVUlEcyBwZXIgc2Vjb25kXCI7XG4vLyBOb2RlIElEIGFjY29yZGluZyB0byByZmM0MTIyI3NlY3Rpb24tNC41XG5jb25zdCByYW5kb21Ib3N0ID0gKDAsIChfY3J5cHRvIHx8IF9sb2FkX2NyeXB0bygpKS5yYW5kb21CeXRlcykoMTYpO1xucmFuZG9tSG9zdFswXSA9IHJhbmRvbUhvc3RbMF0gfCAweDAxO1xuLy8gcmFuZG9taXplIGNsb2NrU2VxIGluaXRpYWxseSwgYXMgcGVyIHJmYzQxMjIjc2VjdGlvbi00LjEuNVxuY29uc3Qgc2VlZCA9ICgwLCAoX2NyeXB0byB8fCBfbG9hZF9jcnlwdG8oKSkucmFuZG9tQnl0ZXMpKDIpO1xubGV0IGNsb2NrU2VxID0gKHNlZWRbMF0gfCBzZWVkWzFdIDw8IDgpICYgMHgzZmZmO1xuLy8gY2xvY2sgdmFsdWVzXG5sZXQgbGFzdE1UaW1lID0gMDtcbmxldCBsYXN0TlRpbWUgPSAwO1xuLy8gbG9va3VwIHRhYmxlIGhleCB0byBieXRlXG5jb25zdCBoZXgyYnl0ZSA9IHt9O1xuLy8gbG9va3VwIHRhYmxlIGJ5dGUgdG8gaGV4XG5jb25zdCBieXRlMmhleCA9IFtdO1xuLy8gcG9wdWxhdGUgbG9va3VwIHRhYmxlc1xuZm9yIChsZXQgaSA9IDA7IGkgPCAyNTY7IGkrKykge1xuICAgIGNvbnN0IGhleCA9IChpICsgMHgxMDApLnRvU3RyaW5nKDE2KS5zdWJzdHIoMSk7XG4gICAgaGV4MmJ5dGVbaGV4XSA9IGk7XG4gICAgYnl0ZTJoZXhbaV0gPSBoZXg7XG59XG4vLyBVVUlEIGNsYXNzXG5jbGFzcyBVVUlEIHtcbiAgICBjb25zdHJ1Y3Rvcih1dWlkKSB7XG4gICAgICAgIGNvbnN0IGNoZWNrID0gVVVJRC5jaGVjayh1dWlkKTtcbiAgICAgICAgaWYgKCFjaGVjaykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwibm90IGEgVVVJRFwiKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnZlcnNpb24gPSBjaGVjay52ZXJzaW9uO1xuICAgICAgICBpZiAoY2hlY2suZm9ybWF0ID09PSBcImFzY2lpXCIpIHtcbiAgICAgICAgICAgIHRoaXMuYXNjaWkgPSB1dWlkO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5iaW5hcnkgPSB1dWlkO1xuICAgICAgICB9XG4gICAgfVxuICAgIHN0YXRpYyB2MSgpIHtcbiAgICAgICAgcmV0dXJuIHV1aWRUaW1lQmFzZWQocmFuZG9tSG9zdCk7XG4gICAgfVxuICAgIHN0YXRpYyB2NShuYW1lLCBuYW1lc3BhY2UpIHtcbiAgICAgICAgcmV0dXJuIHV1aWROYW1lZChuYW1lLCBcInNoYTFcIiwgMHg1MCwgbmFtZXNwYWNlKTtcbiAgICB9XG4gICAgdG9TdHJpbmcoKSB7XG4gICAgICAgIGlmICh0aGlzLmFzY2lpID09IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuYXNjaWkgPSBzdHJpbmdpZnkodGhpcy5iaW5hcnkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmFzY2lpO1xuICAgIH1cbiAgICB0b0J1ZmZlcigpIHtcbiAgICAgICAgaWYgKHRoaXMuYmluYXJ5ID09IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuYmluYXJ5ID0gVVVJRC5wYXJzZSh0aGlzLmFzY2lpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gQnVmZmVyLmZyb20odGhpcy5iaW5hcnkpO1xuICAgIH1cbiAgICBpbnNwZWN0KCkge1xuICAgICAgICByZXR1cm4gYFVVSUQgdiR7dGhpcy52ZXJzaW9ufSAke3RoaXMudG9TdHJpbmcoKX1gO1xuICAgIH1cbiAgICBzdGF0aWMgY2hlY2sodXVpZCwgb2Zmc2V0ID0gMCkge1xuICAgICAgICBpZiAodHlwZW9mIHV1aWQgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIHV1aWQgPSB1dWlkLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICBpZiAoIS9eW2EtZjAtOV17OH0oXFwtW2EtZjAtOV17NH0pezN9XFwtKFthLWYwLTldezEyfSkkLy50ZXN0KHV1aWQpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHV1aWQgPT09IFwiMDAwMDAwMDAtMDAwMC0wMDAwLTAwMDAtMDAwMDAwMDAwMDAwXCIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4geyB2ZXJzaW9uOiB1bmRlZmluZWQsIHZhcmlhbnQ6IFwibmlsXCIsIGZvcm1hdDogXCJhc2NpaVwiIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHZlcnNpb246IChoZXgyYnl0ZVt1dWlkWzE0XSArIHV1aWRbMTVdXSAmIDB4ZjApID4+IDQsXG4gICAgICAgICAgICAgICAgdmFyaWFudDogZ2V0VmFyaWFudCgoaGV4MmJ5dGVbdXVpZFsxOV0gKyB1dWlkWzIwXV0gJiAweGUwKSA+PiA1KSxcbiAgICAgICAgICAgICAgICBmb3JtYXQ6IFwiYXNjaWlcIlxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoQnVmZmVyLmlzQnVmZmVyKHV1aWQpKSB7XG4gICAgICAgICAgICBpZiAodXVpZC5sZW5ndGggPCBvZmZzZXQgKyAxNikge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBpID0gMDtcbiAgICAgICAgICAgIGZvciAoOyBpIDwgMTY7IGkrKykge1xuICAgICAgICAgICAgICAgIGlmICh1dWlkW29mZnNldCArIGldICE9PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpID09PSAxNikge1xuICAgICAgICAgICAgICAgIHJldHVybiB7IHZlcnNpb246IHVuZGVmaW5lZCwgdmFyaWFudDogXCJuaWxcIiwgZm9ybWF0OiBcImJpbmFyeVwiIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHZlcnNpb246ICh1dWlkW29mZnNldCArIDZdICYgMHhmMCkgPj4gNCxcbiAgICAgICAgICAgICAgICB2YXJpYW50OiBnZXRWYXJpYW50KCh1dWlkW29mZnNldCArIDhdICYgMHhlMCkgPj4gNSksXG4gICAgICAgICAgICAgICAgZm9ybWF0OiBcImJpbmFyeVwiXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHRocm93ICgwLCAoX2luZGV4IHx8IF9sb2FkX2luZGV4KCkpLm5ld0Vycm9yKShcIlVua25vd24gdHlwZSBvZiB1dWlkXCIsIFwiRVJSX1VOS05PV05fVVVJRF9UWVBFXCIpO1xuICAgIH1cbiAgICAvLyByZWFkIHN0cmluZ2lmaWVkIHV1aWQgaW50byBhIEJ1ZmZlclxuICAgIHN0YXRpYyBwYXJzZShpbnB1dCkge1xuICAgICAgICBjb25zdCBidWZmZXIgPSBCdWZmZXIuYWxsb2NVbnNhZmUoMTYpO1xuICAgICAgICBsZXQgaiA9IDA7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgMTY7IGkrKykge1xuICAgICAgICAgICAgYnVmZmVyW2ldID0gaGV4MmJ5dGVbaW5wdXRbaisrXSArIGlucHV0W2orK11dO1xuICAgICAgICAgICAgaWYgKGkgPT09IDMgfHwgaSA9PT0gNSB8fCBpID09PSA3IHx8IGkgPT09IDkpIHtcbiAgICAgICAgICAgICAgICBqICs9IDE7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGJ1ZmZlcjtcbiAgICB9XG59XG5leHBvcnRzLlVVSUQgPSBVVUlEOyAvLyBmcm9tIHJmYzQxMjIjYXBwZW5kaXgtQ1xuXG5VVUlELlVSTCA9IG5ldyBVVUlEKFwiNmJhN2I4MTEtOWRhZC0xMWQxLTgwYjQtMDBjMDRmZDQzMGM4XCIpO1xuVVVJRC5PSUQgPSBVVUlELnBhcnNlKFwiNmJhN2I4MTItOWRhZC0xMWQxLTgwYjQtMDBjMDRmZDQzMGM4XCIpO1xuLy8gYWNjb3JkaW5nIHRvIHJmYzQxMjIjc2VjdGlvbi00LjEuMVxuZnVuY3Rpb24gZ2V0VmFyaWFudChiaXRzKSB7XG4gICAgc3dpdGNoIChiaXRzKSB7XG4gICAgICAgIGNhc2UgMDpcbiAgICAgICAgY2FzZSAxOlxuICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICByZXR1cm4gXCJuY3NcIjtcbiAgICAgICAgY2FzZSA0OlxuICAgICAgICBjYXNlIDU6XG4gICAgICAgICAgICByZXR1cm4gXCJyZmM0MTIyXCI7XG4gICAgICAgIGNhc2UgNjpcbiAgICAgICAgICAgIHJldHVybiBcIm1pY3Jvc29mdFwiO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgcmV0dXJuIFwiZnV0dXJlXCI7XG4gICAgfVxufVxudmFyIFV1aWRFbmNvZGluZztcbihmdW5jdGlvbiAoVXVpZEVuY29kaW5nKSB7XG4gICAgVXVpZEVuY29kaW5nW1V1aWRFbmNvZGluZ1tcIkFTQ0lJXCJdID0gMF0gPSBcIkFTQ0lJXCI7XG4gICAgVXVpZEVuY29kaW5nW1V1aWRFbmNvZGluZ1tcIkJJTkFSWVwiXSA9IDFdID0gXCJCSU5BUllcIjtcbiAgICBVdWlkRW5jb2RpbmdbVXVpZEVuY29kaW5nW1wiT0JKRUNUXCJdID0gMl0gPSBcIk9CSkVDVFwiO1xufSkoVXVpZEVuY29kaW5nIHx8IChVdWlkRW5jb2RpbmcgPSB7fSkpO1xuLy8gdjFcbmZ1bmN0aW9uIHV1aWRUaW1lQmFzZWQobm9kZUlkLCBlbmNvZGluZyA9IFV1aWRFbmNvZGluZy5BU0NJSSkge1xuICAgIGxldCBtVGltZSA9IERhdGUubm93KCk7XG4gICAgbGV0IG5UaW1lID0gbGFzdE5UaW1lICsgMTtcbiAgICBjb25zdCBkZWx0YSA9IG1UaW1lIC0gbGFzdE1UaW1lICsgKG5UaW1lIC0gbGFzdE5UaW1lKSAvIDEwMDAwO1xuICAgIGlmIChkZWx0YSA8IDApIHtcbiAgICAgICAgY2xvY2tTZXEgPSBjbG9ja1NlcSArIDEgJiAweDNmZmY7XG4gICAgICAgIG5UaW1lID0gMDtcbiAgICB9IGVsc2UgaWYgKG1UaW1lID4gbGFzdE1UaW1lKSB7XG4gICAgICAgIG5UaW1lID0gMDtcbiAgICB9IGVsc2UgaWYgKG5UaW1lID49IDEwMDAwKSB7XG4gICAgICAgIHJldHVybiBtb3JlVGhhbjEwMDAwO1xuICAgIH1cbiAgICBsYXN0TVRpbWUgPSBtVGltZTtcbiAgICBsYXN0TlRpbWUgPSBuVGltZTtcbiAgICAvLyB1bml4IHRpbWVzdGFtcCB0byBncmVnb3JpYW4gZXBvY2ggYXMgcGVyIHJmYzQxMjIjc2VjdGlvbi00LjVcbiAgICBtVGltZSArPSAxMjIxOTI5MjgwMDAwMDtcbiAgICBjb25zdCBidWZmZXIgPSBCdWZmZXIuYWxsb2NVbnNhZmUoMTYpO1xuICAgIGNvbnN0IG15Q2xvY2tTZXEgPSBjbG9ja1NlcTtcbiAgICBjb25zdCB0aW1lTG93ID0gKChtVGltZSAmIDB4ZmZmZmZmZikgKiAxMDAwMCArIG5UaW1lKSAlIDB4MTAwMDAwMDAwO1xuICAgIGNvbnN0IHRpbWVIaWdoID0gbVRpbWUgLyAweDEwMDAwMDAwMCAqIDEwMDAwICYgMHhmZmZmZmZmO1xuICAgIGJ1ZmZlclswXSA9IHRpbWVMb3cgPj4+IDI0ICYgMHhmZjtcbiAgICBidWZmZXJbMV0gPSB0aW1lTG93ID4+PiAxNiAmIDB4ZmY7XG4gICAgYnVmZmVyWzJdID0gdGltZUxvdyA+Pj4gOCAmIDB4ZmY7XG4gICAgYnVmZmVyWzNdID0gdGltZUxvdyAmIDB4ZmY7XG4gICAgYnVmZmVyWzRdID0gdGltZUhpZ2ggPj4+IDggJiAweGZmO1xuICAgIGJ1ZmZlcls1XSA9IHRpbWVIaWdoICYgMHhmZjtcbiAgICBidWZmZXJbNl0gPSB0aW1lSGlnaCA+Pj4gMjQgJiAweDBmIHwgMHgxMDtcbiAgICBidWZmZXJbN10gPSB0aW1lSGlnaCA+Pj4gMTYgJiAweDNmIHwgMHg4MDtcbiAgICBidWZmZXJbOF0gPSBteUNsb2NrU2VxID4+PiA4O1xuICAgIGJ1ZmZlcls5XSA9IG15Q2xvY2tTZXEgJiAweGZmO1xuICAgIGxldCByZXN1bHQ7XG4gICAgc3dpdGNoIChlbmNvZGluZykge1xuICAgICAgICBjYXNlIFV1aWRFbmNvZGluZy5CSU5BUlk6XG4gICAgICAgICAgICBidWZmZXJbMTBdID0gbm9kZUlkWzBdO1xuICAgICAgICAgICAgYnVmZmVyWzExXSA9IG5vZGVJZFsxXTtcbiAgICAgICAgICAgIGJ1ZmZlclsxMl0gPSBub2RlSWRbMl07XG4gICAgICAgICAgICBidWZmZXJbMTNdID0gbm9kZUlkWzNdO1xuICAgICAgICAgICAgYnVmZmVyWzE0XSA9IG5vZGVJZFs0XTtcbiAgICAgICAgICAgIGJ1ZmZlclsxNV0gPSBub2RlSWRbNV07XG4gICAgICAgICAgICByZXN1bHQgPSBidWZmZXI7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBVdWlkRW5jb2RpbmcuT0JKRUNUOlxuICAgICAgICAgICAgYnVmZmVyWzEwXSA9IG5vZGVJZFswXTtcbiAgICAgICAgICAgIGJ1ZmZlclsxMV0gPSBub2RlSWRbMV07XG4gICAgICAgICAgICBidWZmZXJbMTJdID0gbm9kZUlkWzJdO1xuICAgICAgICAgICAgYnVmZmVyWzEzXSA9IG5vZGVJZFszXTtcbiAgICAgICAgICAgIGJ1ZmZlclsxNF0gPSBub2RlSWRbNF07XG4gICAgICAgICAgICBidWZmZXJbMTVdID0gbm9kZUlkWzVdO1xuICAgICAgICAgICAgcmVzdWx0ID0gbmV3IFVVSUQoYnVmZmVyKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgcmVzdWx0ID0gYnl0ZTJoZXhbYnVmZmVyWzBdXSArIGJ5dGUyaGV4W2J1ZmZlclsxXV0gKyBieXRlMmhleFtidWZmZXJbMl1dICsgYnl0ZTJoZXhbYnVmZmVyWzNdXSArIFwiLVwiICsgYnl0ZTJoZXhbYnVmZmVyWzRdXSArIGJ5dGUyaGV4W2J1ZmZlcls1XV0gKyBcIi1cIiArIGJ5dGUyaGV4W2J1ZmZlcls2XV0gKyBieXRlMmhleFtidWZmZXJbN11dICsgXCItXCIgKyBieXRlMmhleFtidWZmZXJbOF1dICsgYnl0ZTJoZXhbYnVmZmVyWzldXSArIFwiLVwiICsgYnl0ZTJoZXhbbm9kZUlkWzBdXSArIGJ5dGUyaGV4W25vZGVJZFsxXV0gKyBieXRlMmhleFtub2RlSWRbMl1dICsgYnl0ZTJoZXhbbm9kZUlkWzNdXSArIGJ5dGUyaGV4W25vZGVJZFs0XV0gKyBieXRlMmhleFtub2RlSWRbNV1dO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG4vLyB2MyArIHY1XG5mdW5jdGlvbiB1dWlkTmFtZWQobmFtZSwgaGFzaE1ldGhvZCwgdmVyc2lvbiwgbmFtZXNwYWNlLCBlbmNvZGluZyA9IFV1aWRFbmNvZGluZy5BU0NJSSkge1xuICAgIGNvbnN0IGhhc2ggPSAoMCwgKF9jcnlwdG8gfHwgX2xvYWRfY3J5cHRvKCkpLmNyZWF0ZUhhc2gpKGhhc2hNZXRob2QpO1xuICAgIGNvbnN0IG5hbWVJc05vdEFTdHJpbmcgPSB0eXBlb2YgbmFtZSAhPT0gXCJzdHJpbmdcIjtcbiAgICBpZiAobmFtZUlzTm90QVN0cmluZyAmJiAhQnVmZmVyLmlzQnVmZmVyKG5hbWUpKSB7XG4gICAgICAgIHRocm93ICgwLCAoX2luZGV4IHx8IF9sb2FkX2luZGV4KCkpLm5ld0Vycm9yKShpbnZhbGlkTmFtZSwgXCJFUlJfSU5WQUxJRF9VVUlEX05BTUVcIik7XG4gICAgfVxuICAgIGhhc2gudXBkYXRlKG5hbWVzcGFjZSk7XG4gICAgaGFzaC51cGRhdGUobmFtZSwgbmFtZUlzTm90QVN0cmluZyA/IFwibGF0aW4xXCIgOiBcInV0ZjhcIik7XG4gICAgY29uc3QgYnVmZmVyID0gaGFzaC5kaWdlc3QoKTtcbiAgICBsZXQgcmVzdWx0O1xuICAgIHN3aXRjaCAoZW5jb2RpbmcpIHtcbiAgICAgICAgY2FzZSBVdWlkRW5jb2RpbmcuQklOQVJZOlxuICAgICAgICAgICAgYnVmZmVyWzZdID0gYnVmZmVyWzZdICYgMHgwZiB8IHZlcnNpb247XG4gICAgICAgICAgICBidWZmZXJbOF0gPSBidWZmZXJbOF0gJiAweDNmIHwgMHg4MDtcbiAgICAgICAgICAgIHJlc3VsdCA9IGJ1ZmZlcjtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFV1aWRFbmNvZGluZy5PQkpFQ1Q6XG4gICAgICAgICAgICBidWZmZXJbNl0gPSBidWZmZXJbNl0gJiAweDBmIHwgdmVyc2lvbjtcbiAgICAgICAgICAgIGJ1ZmZlcls4XSA9IGJ1ZmZlcls4XSAmIDB4M2YgfCAweDgwO1xuICAgICAgICAgICAgcmVzdWx0ID0gbmV3IFVVSUQoYnVmZmVyKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgcmVzdWx0ID0gYnl0ZTJoZXhbYnVmZmVyWzBdXSArIGJ5dGUyaGV4W2J1ZmZlclsxXV0gKyBieXRlMmhleFtidWZmZXJbMl1dICsgYnl0ZTJoZXhbYnVmZmVyWzNdXSArIFwiLVwiICsgYnl0ZTJoZXhbYnVmZmVyWzRdXSArIGJ5dGUyaGV4W2J1ZmZlcls1XV0gKyBcIi1cIiArIGJ5dGUyaGV4W2J1ZmZlcls2XSAmIDB4MGYgfCB2ZXJzaW9uXSArIGJ5dGUyaGV4W2J1ZmZlcls3XV0gKyBcIi1cIiArIGJ5dGUyaGV4W2J1ZmZlcls4XSAmIDB4M2YgfCAweDgwXSArIGJ5dGUyaGV4W2J1ZmZlcls5XV0gKyBcIi1cIiArIGJ5dGUyaGV4W2J1ZmZlclsxMF1dICsgYnl0ZTJoZXhbYnVmZmVyWzExXV0gKyBieXRlMmhleFtidWZmZXJbMTJdXSArIGJ5dGUyaGV4W2J1ZmZlclsxM11dICsgYnl0ZTJoZXhbYnVmZmVyWzE0XV0gKyBieXRlMmhleFtidWZmZXJbMTVdXTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gc3RyaW5naWZ5KGJ1ZmZlcikge1xuICAgIHJldHVybiBieXRlMmhleFtidWZmZXJbMF1dICsgYnl0ZTJoZXhbYnVmZmVyWzFdXSArIGJ5dGUyaGV4W2J1ZmZlclsyXV0gKyBieXRlMmhleFtidWZmZXJbM11dICsgXCItXCIgKyBieXRlMmhleFtidWZmZXJbNF1dICsgYnl0ZTJoZXhbYnVmZmVyWzVdXSArIFwiLVwiICsgYnl0ZTJoZXhbYnVmZmVyWzZdXSArIGJ5dGUyaGV4W2J1ZmZlcls3XV0gKyBcIi1cIiArIGJ5dGUyaGV4W2J1ZmZlcls4XV0gKyBieXRlMmhleFtidWZmZXJbOV1dICsgXCItXCIgKyBieXRlMmhleFtidWZmZXJbMTBdXSArIGJ5dGUyaGV4W2J1ZmZlclsxMV1dICsgYnl0ZTJoZXhbYnVmZmVyWzEyXV0gKyBieXRlMmhleFtidWZmZXJbMTNdXSArIGJ5dGUyaGV4W2J1ZmZlclsxNF1dICsgYnl0ZTJoZXhbYnVmZmVyWzE1XV07XG59XG4vLyBhY2NvcmRpbmcgdG8gcmZjNDEyMiNzZWN0aW9uLTQuMS43XG5jb25zdCBuaWwgPSBleHBvcnRzLm5pbCA9IG5ldyBVVUlEKFwiMDAwMDAwMDAtMDAwMC0wMDAwLTAwMDAtMDAwMDAwMDAwMDAwXCIpO1xuLy8gVVVJRC52NCA9IHV1aWRSYW5kb21cbi8vIFVVSUQudjRmYXN0ID0gdXVpZFJhbmRvbUZhc3Rcbi8vIFVVSUQudjMgPSBmdW5jdGlvbihvcHRpb25zLCBjYWxsYmFjaykge1xuLy8gICAgIHJldHVybiB1dWlkTmFtZWQoXCJtZDVcIiwgMHgzMCwgb3B0aW9ucywgY2FsbGJhY2spXG4vLyB9IFxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dXVpZC5qcy5tYXBcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvZWxlY3Ryb24tdXBkYXRlci9ub2RlX21vZHVsZXMvYnVpbGRlci11dGlsLXJ1bnRpbWUvb3V0L3V1aWQuanMiLCJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5YRWxlbWVudCA9IHVuZGVmaW5lZDtcbmV4cG9ydHMucGFyc2VYbWwgPSBwYXJzZVhtbDtcblxudmFyIF9zYXg7XG5cbmZ1bmN0aW9uIF9sb2FkX3NheCgpIHtcbiAgICByZXR1cm4gX3NheCA9IF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKHJlcXVpcmUoXCJzYXhcIikpO1xufVxuXG52YXIgX2luZGV4O1xuXG5mdW5jdGlvbiBfbG9hZF9pbmRleCgpIHtcbiAgICByZXR1cm4gX2luZGV4ID0gcmVxdWlyZShcIi4vaW5kZXhcIik7XG59XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKG9iaikgeyBpZiAob2JqICYmIG9iai5fX2VzTW9kdWxlKSB7IHJldHVybiBvYmo7IH0gZWxzZSB7IHZhciBuZXdPYmogPSB7fTsgaWYgKG9iaiAhPSBudWxsKSB7IGZvciAodmFyIGtleSBpbiBvYmopIHsgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGtleSkpIG5ld09ialtrZXldID0gb2JqW2tleV07IH0gfSBuZXdPYmouZGVmYXVsdCA9IG9iajsgcmV0dXJuIG5ld09iajsgfSB9XG5cbmNsYXNzIFhFbGVtZW50IHtcbiAgICBjb25zdHJ1Y3RvcihuYW1lKSB7XG4gICAgICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gICAgICAgIHRoaXMudmFsdWUgPSBcIlwiO1xuICAgICAgICB0aGlzLmF0dHJpYnV0ZXMgPSBudWxsO1xuICAgICAgICB0aGlzLmlzQ0RhdGEgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5lbGVtZW50cyA9IG51bGw7XG4gICAgICAgIGlmICghbmFtZSkge1xuICAgICAgICAgICAgdGhyb3cgKDAsIChfaW5kZXggfHwgX2xvYWRfaW5kZXgoKSkubmV3RXJyb3IpKFwiRWxlbWVudCBuYW1lIGNhbm5vdCBiZSBlbXB0eVwiLCBcIkVSUl9YTUxfRUxFTUVOVF9OQU1FX0VNUFRZXCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghaXNWYWxpZE5hbWUobmFtZSkpIHtcbiAgICAgICAgICAgIHRocm93ICgwLCAoX2luZGV4IHx8IF9sb2FkX2luZGV4KCkpLm5ld0Vycm9yKShgSW52YWxpZCBlbGVtZW50IG5hbWU6ICR7bmFtZX1gLCBcIkVSUl9YTUxfRUxFTUVOVF9JTlZBTElEX05BTUVcIik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXR0cmlidXRlKG5hbWUpIHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gdGhpcy5hdHRyaWJ1dGVzID09PSBudWxsID8gbnVsbCA6IHRoaXMuYXR0cmlidXRlc1tuYW1lXTtcbiAgICAgICAgaWYgKHJlc3VsdCA9PSBudWxsKSB7XG4gICAgICAgICAgICB0aHJvdyAoMCwgKF9pbmRleCB8fCBfbG9hZF9pbmRleCgpKS5uZXdFcnJvcikoYE5vIGF0dHJpYnV0ZSBcIiR7bmFtZX1cImAsIFwiRVJSX1hNTF9NSVNTRURfQVRUUklCVVRFXCIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIHJlbW92ZUF0dHJpYnV0ZShuYW1lKSB7XG4gICAgICAgIGlmICh0aGlzLmF0dHJpYnV0ZXMgIT09IG51bGwpIHtcbiAgICAgICAgICAgIGRlbGV0ZSB0aGlzLmF0dHJpYnV0ZXNbbmFtZV07XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxlbWVudChuYW1lLCBpZ25vcmVDYXNlID0gZmFsc2UsIGVycm9ySWZNaXNzZWQgPSBudWxsKSB7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IHRoaXMuZWxlbWVudE9yTnVsbChuYW1lLCBpZ25vcmVDYXNlKTtcbiAgICAgICAgaWYgKHJlc3VsdCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgdGhyb3cgKDAsIChfaW5kZXggfHwgX2xvYWRfaW5kZXgoKSkubmV3RXJyb3IpKGVycm9ySWZNaXNzZWQgfHwgYE5vIGVsZW1lbnQgXCIke25hbWV9XCJgLCBcIkVSUl9YTUxfTUlTU0VEX0VMRU1FTlRcIik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgZWxlbWVudE9yTnVsbChuYW1lLCBpZ25vcmVDYXNlID0gZmFsc2UpIHtcbiAgICAgICAgaWYgKHRoaXMuZWxlbWVudHMgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGZvciAoY29uc3QgZWxlbWVudCBvZiB0aGlzLmVsZW1lbnRzKSB7XG4gICAgICAgICAgICBpZiAoaXNOYW1lRXF1YWxzKGVsZW1lbnQsIG5hbWUsIGlnbm9yZUNhc2UpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGVsZW1lbnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGdldEVsZW1lbnRzKG5hbWUsIGlnbm9yZUNhc2UgPSBmYWxzZSkge1xuICAgICAgICBpZiAodGhpcy5lbGVtZW50cyA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmVsZW1lbnRzLmZpbHRlcihpdCA9PiBpc05hbWVFcXVhbHMoaXQsIG5hbWUsIGlnbm9yZUNhc2UpKTtcbiAgICB9XG4gICAgZWxlbWVudFZhbHVlT3JFbXB0eShuYW1lLCBpZ25vcmVDYXNlID0gZmFsc2UpIHtcbiAgICAgICAgY29uc3QgZWxlbWVudCA9IHRoaXMuZWxlbWVudE9yTnVsbChuYW1lLCBpZ25vcmVDYXNlKTtcbiAgICAgICAgcmV0dXJuIGVsZW1lbnQgPT09IG51bGwgPyBcIlwiIDogZWxlbWVudC52YWx1ZTtcbiAgICB9XG59XG5leHBvcnRzLlhFbGVtZW50ID0gWEVsZW1lbnQ7XG5jb25zdCBOQU1FX1JFR19FWFAgPSBuZXcgUmVnRXhwKC9eW0EtWmEtel9dWzpBLVphLXowLTlfLV0qJC9pKTtcbmZ1bmN0aW9uIGlzVmFsaWROYW1lKG5hbWUpIHtcbiAgICByZXR1cm4gTkFNRV9SRUdfRVhQLnRlc3QobmFtZSk7XG59XG5mdW5jdGlvbiBpc05hbWVFcXVhbHMoZWxlbWVudCwgbmFtZSwgaWdub3JlQ2FzZSkge1xuICAgIGNvbnN0IGVsZW1lbnROYW1lID0gZWxlbWVudC5uYW1lO1xuICAgIHJldHVybiBlbGVtZW50TmFtZSA9PT0gbmFtZSB8fCBpZ25vcmVDYXNlID09PSB0cnVlICYmIGVsZW1lbnROYW1lLmxlbmd0aCA9PT0gbmFtZS5sZW5ndGggJiYgZWxlbWVudE5hbWUudG9Mb3dlckNhc2UoKSA9PT0gbmFtZS50b0xvd2VyQ2FzZSgpO1xufVxuZnVuY3Rpb24gcGFyc2VYbWwoZGF0YSkge1xuICAgIGxldCByb290RWxlbWVudCA9IG51bGw7XG4gICAgY29uc3QgcGFyc2VyID0gKF9zYXggfHwgX2xvYWRfc2F4KCkpLnBhcnNlcih0cnVlLCB7fSk7XG4gICAgY29uc3QgZWxlbWVudHMgPSBbXTtcbiAgICBwYXJzZXIub25vcGVudGFnID0gc2F4RWxlbWVudCA9PiB7XG4gICAgICAgIGNvbnN0IGVsZW1lbnQgPSBuZXcgWEVsZW1lbnQoc2F4RWxlbWVudC5uYW1lKTtcbiAgICAgICAgZWxlbWVudC5hdHRyaWJ1dGVzID0gc2F4RWxlbWVudC5hdHRyaWJ1dGVzO1xuICAgICAgICBpZiAocm9vdEVsZW1lbnQgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJvb3RFbGVtZW50ID0gZWxlbWVudDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IHBhcmVudCA9IGVsZW1lbnRzW2VsZW1lbnRzLmxlbmd0aCAtIDFdO1xuICAgICAgICAgICAgaWYgKHBhcmVudC5lbGVtZW50cyA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcGFyZW50LmVsZW1lbnRzID0gW107XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwYXJlbnQuZWxlbWVudHMucHVzaChlbGVtZW50KTtcbiAgICAgICAgfVxuICAgICAgICBlbGVtZW50cy5wdXNoKGVsZW1lbnQpO1xuICAgIH07XG4gICAgcGFyc2VyLm9uY2xvc2V0YWcgPSAoKSA9PiB7XG4gICAgICAgIGVsZW1lbnRzLnBvcCgpO1xuICAgIH07XG4gICAgcGFyc2VyLm9udGV4dCA9IHRleHQgPT4ge1xuICAgICAgICBpZiAoZWxlbWVudHMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgZWxlbWVudHNbZWxlbWVudHMubGVuZ3RoIC0gMV0udmFsdWUgPSB0ZXh0O1xuICAgICAgICB9XG4gICAgfTtcbiAgICBwYXJzZXIub25jZGF0YSA9IGNkYXRhID0+IHtcbiAgICAgICAgY29uc3QgZWxlbWVudCA9IGVsZW1lbnRzW2VsZW1lbnRzLmxlbmd0aCAtIDFdO1xuICAgICAgICBlbGVtZW50LnZhbHVlID0gY2RhdGE7XG4gICAgICAgIGVsZW1lbnQuaXNDRGF0YSA9IHRydWU7XG4gICAgfTtcbiAgICBwYXJzZXIub25lcnJvciA9IGVyciA9PiB7XG4gICAgICAgIHRocm93IGVycjtcbiAgICB9O1xuICAgIHBhcnNlci53cml0ZShkYXRhKTtcbiAgICByZXR1cm4gcm9vdEVsZW1lbnQ7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD14bWwuanMubWFwXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2VsZWN0cm9uLXVwZGF0ZXIvbm9kZV9tb2R1bGVzL2J1aWxkZXItdXRpbC1ydW50aW1lL291dC94bWwuanMiLCI7KGZ1bmN0aW9uIChzYXgpIHsgLy8gd3JhcHBlciBmb3Igbm9uLW5vZGUgZW52c1xuICBzYXgucGFyc2VyID0gZnVuY3Rpb24gKHN0cmljdCwgb3B0KSB7IHJldHVybiBuZXcgU0FYUGFyc2VyKHN0cmljdCwgb3B0KSB9XG4gIHNheC5TQVhQYXJzZXIgPSBTQVhQYXJzZXJcbiAgc2F4LlNBWFN0cmVhbSA9IFNBWFN0cmVhbVxuICBzYXguY3JlYXRlU3RyZWFtID0gY3JlYXRlU3RyZWFtXG5cbiAgLy8gV2hlbiB3ZSBwYXNzIHRoZSBNQVhfQlVGRkVSX0xFTkdUSCBwb3NpdGlvbiwgc3RhcnQgY2hlY2tpbmcgZm9yIGJ1ZmZlciBvdmVycnVucy5cbiAgLy8gV2hlbiB3ZSBjaGVjaywgc2NoZWR1bGUgdGhlIG5leHQgY2hlY2sgZm9yIE1BWF9CVUZGRVJfTEVOR1RIIC0gKG1heChidWZmZXIgbGVuZ3RocykpLFxuICAvLyBzaW5jZSB0aGF0J3MgdGhlIGVhcmxpZXN0IHRoYXQgYSBidWZmZXIgb3ZlcnJ1biBjb3VsZCBvY2N1ci4gIFRoaXMgd2F5LCBjaGVja3MgYXJlXG4gIC8vIGFzIHJhcmUgYXMgcmVxdWlyZWQsIGJ1dCBhcyBvZnRlbiBhcyBuZWNlc3NhcnkgdG8gZW5zdXJlIG5ldmVyIGNyb3NzaW5nIHRoaXMgYm91bmQuXG4gIC8vIEZ1cnRoZXJtb3JlLCBidWZmZXJzIGFyZSBvbmx5IHRlc3RlZCBhdCBtb3N0IG9uY2UgcGVyIHdyaXRlKCksIHNvIHBhc3NpbmcgYSB2ZXJ5XG4gIC8vIGxhcmdlIHN0cmluZyBpbnRvIHdyaXRlKCkgbWlnaHQgaGF2ZSB1bmRlc2lyYWJsZSBlZmZlY3RzLCBidXQgdGhpcyBpcyBtYW5hZ2VhYmxlIGJ5XG4gIC8vIHRoZSBjYWxsZXIsIHNvIGl0IGlzIGFzc3VtZWQgdG8gYmUgc2FmZS4gIFRodXMsIGEgY2FsbCB0byB3cml0ZSgpIG1heSwgaW4gdGhlIGV4dHJlbWVcbiAgLy8gZWRnZSBjYXNlLCByZXN1bHQgaW4gY3JlYXRpbmcgYXQgbW9zdCBvbmUgY29tcGxldGUgY29weSBvZiB0aGUgc3RyaW5nIHBhc3NlZCBpbi5cbiAgLy8gU2V0IHRvIEluZmluaXR5IHRvIGhhdmUgdW5saW1pdGVkIGJ1ZmZlcnMuXG4gIHNheC5NQVhfQlVGRkVSX0xFTkdUSCA9IDY0ICogMTAyNFxuXG4gIHZhciBidWZmZXJzID0gW1xuICAgICdjb21tZW50JywgJ3NnbWxEZWNsJywgJ3RleHROb2RlJywgJ3RhZ05hbWUnLCAnZG9jdHlwZScsXG4gICAgJ3Byb2NJbnN0TmFtZScsICdwcm9jSW5zdEJvZHknLCAnZW50aXR5JywgJ2F0dHJpYk5hbWUnLFxuICAgICdhdHRyaWJWYWx1ZScsICdjZGF0YScsICdzY3JpcHQnXG4gIF1cblxuICBzYXguRVZFTlRTID0gW1xuICAgICd0ZXh0JyxcbiAgICAncHJvY2Vzc2luZ2luc3RydWN0aW9uJyxcbiAgICAnc2dtbGRlY2xhcmF0aW9uJyxcbiAgICAnZG9jdHlwZScsXG4gICAgJ2NvbW1lbnQnLFxuICAgICdvcGVudGFnc3RhcnQnLFxuICAgICdhdHRyaWJ1dGUnLFxuICAgICdvcGVudGFnJyxcbiAgICAnY2xvc2V0YWcnLFxuICAgICdvcGVuY2RhdGEnLFxuICAgICdjZGF0YScsXG4gICAgJ2Nsb3NlY2RhdGEnLFxuICAgICdlcnJvcicsXG4gICAgJ2VuZCcsXG4gICAgJ3JlYWR5JyxcbiAgICAnc2NyaXB0JyxcbiAgICAnb3Blbm5hbWVzcGFjZScsXG4gICAgJ2Nsb3NlbmFtZXNwYWNlJ1xuICBdXG5cbiAgZnVuY3Rpb24gU0FYUGFyc2VyIChzdHJpY3QsIG9wdCkge1xuICAgIGlmICghKHRoaXMgaW5zdGFuY2VvZiBTQVhQYXJzZXIpKSB7XG4gICAgICByZXR1cm4gbmV3IFNBWFBhcnNlcihzdHJpY3QsIG9wdClcbiAgICB9XG5cbiAgICB2YXIgcGFyc2VyID0gdGhpc1xuICAgIGNsZWFyQnVmZmVycyhwYXJzZXIpXG4gICAgcGFyc2VyLnEgPSBwYXJzZXIuYyA9ICcnXG4gICAgcGFyc2VyLmJ1ZmZlckNoZWNrUG9zaXRpb24gPSBzYXguTUFYX0JVRkZFUl9MRU5HVEhcbiAgICBwYXJzZXIub3B0ID0gb3B0IHx8IHt9XG4gICAgcGFyc2VyLm9wdC5sb3dlcmNhc2UgPSBwYXJzZXIub3B0Lmxvd2VyY2FzZSB8fCBwYXJzZXIub3B0Lmxvd2VyY2FzZXRhZ3NcbiAgICBwYXJzZXIubG9vc2VDYXNlID0gcGFyc2VyLm9wdC5sb3dlcmNhc2UgPyAndG9Mb3dlckNhc2UnIDogJ3RvVXBwZXJDYXNlJ1xuICAgIHBhcnNlci50YWdzID0gW11cbiAgICBwYXJzZXIuY2xvc2VkID0gcGFyc2VyLmNsb3NlZFJvb3QgPSBwYXJzZXIuc2F3Um9vdCA9IGZhbHNlXG4gICAgcGFyc2VyLnRhZyA9IHBhcnNlci5lcnJvciA9IG51bGxcbiAgICBwYXJzZXIuc3RyaWN0ID0gISFzdHJpY3RcbiAgICBwYXJzZXIubm9zY3JpcHQgPSAhIShzdHJpY3QgfHwgcGFyc2VyLm9wdC5ub3NjcmlwdClcbiAgICBwYXJzZXIuc3RhdGUgPSBTLkJFR0lOXG4gICAgcGFyc2VyLnN0cmljdEVudGl0aWVzID0gcGFyc2VyLm9wdC5zdHJpY3RFbnRpdGllc1xuICAgIHBhcnNlci5FTlRJVElFUyA9IHBhcnNlci5zdHJpY3RFbnRpdGllcyA/IE9iamVjdC5jcmVhdGUoc2F4LlhNTF9FTlRJVElFUykgOiBPYmplY3QuY3JlYXRlKHNheC5FTlRJVElFUylcbiAgICBwYXJzZXIuYXR0cmliTGlzdCA9IFtdXG5cbiAgICAvLyBuYW1lc3BhY2VzIGZvcm0gYSBwcm90b3R5cGUgY2hhaW4uXG4gICAgLy8gaXQgYWx3YXlzIHBvaW50cyBhdCB0aGUgY3VycmVudCB0YWcsXG4gICAgLy8gd2hpY2ggcHJvdG9zIHRvIGl0cyBwYXJlbnQgdGFnLlxuICAgIGlmIChwYXJzZXIub3B0LnhtbG5zKSB7XG4gICAgICBwYXJzZXIubnMgPSBPYmplY3QuY3JlYXRlKHJvb3ROUylcbiAgICB9XG5cbiAgICAvLyBtb3N0bHkganVzdCBmb3IgZXJyb3IgcmVwb3J0aW5nXG4gICAgcGFyc2VyLnRyYWNrUG9zaXRpb24gPSBwYXJzZXIub3B0LnBvc2l0aW9uICE9PSBmYWxzZVxuICAgIGlmIChwYXJzZXIudHJhY2tQb3NpdGlvbikge1xuICAgICAgcGFyc2VyLnBvc2l0aW9uID0gcGFyc2VyLmxpbmUgPSBwYXJzZXIuY29sdW1uID0gMFxuICAgIH1cbiAgICBlbWl0KHBhcnNlciwgJ29ucmVhZHknKVxuICB9XG5cbiAgaWYgKCFPYmplY3QuY3JlYXRlKSB7XG4gICAgT2JqZWN0LmNyZWF0ZSA9IGZ1bmN0aW9uIChvKSB7XG4gICAgICBmdW5jdGlvbiBGICgpIHt9XG4gICAgICBGLnByb3RvdHlwZSA9IG9cbiAgICAgIHZhciBuZXdmID0gbmV3IEYoKVxuICAgICAgcmV0dXJuIG5ld2ZcbiAgICB9XG4gIH1cblxuICBpZiAoIU9iamVjdC5rZXlzKSB7XG4gICAgT2JqZWN0LmtleXMgPSBmdW5jdGlvbiAobykge1xuICAgICAgdmFyIGEgPSBbXVxuICAgICAgZm9yICh2YXIgaSBpbiBvKSBpZiAoby5oYXNPd25Qcm9wZXJ0eShpKSkgYS5wdXNoKGkpXG4gICAgICByZXR1cm4gYVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGNoZWNrQnVmZmVyTGVuZ3RoIChwYXJzZXIpIHtcbiAgICB2YXIgbWF4QWxsb3dlZCA9IE1hdGgubWF4KHNheC5NQVhfQlVGRkVSX0xFTkdUSCwgMTApXG4gICAgdmFyIG1heEFjdHVhbCA9IDBcbiAgICBmb3IgKHZhciBpID0gMCwgbCA9IGJ1ZmZlcnMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICB2YXIgbGVuID0gcGFyc2VyW2J1ZmZlcnNbaV1dLmxlbmd0aFxuICAgICAgaWYgKGxlbiA+IG1heEFsbG93ZWQpIHtcbiAgICAgICAgLy8gVGV4dC9jZGF0YSBub2RlcyBjYW4gZ2V0IGJpZywgYW5kIHNpbmNlIHRoZXkncmUgYnVmZmVyZWQsXG4gICAgICAgIC8vIHdlIGNhbiBnZXQgaGVyZSB1bmRlciBub3JtYWwgY29uZGl0aW9ucy5cbiAgICAgICAgLy8gQXZvaWQgaXNzdWVzIGJ5IGVtaXR0aW5nIHRoZSB0ZXh0IG5vZGUgbm93LFxuICAgICAgICAvLyBzbyBhdCBsZWFzdCBpdCB3b24ndCBnZXQgYW55IGJpZ2dlci5cbiAgICAgICAgc3dpdGNoIChidWZmZXJzW2ldKSB7XG4gICAgICAgICAgY2FzZSAndGV4dE5vZGUnOlxuICAgICAgICAgICAgY2xvc2VUZXh0KHBhcnNlcilcbiAgICAgICAgICAgIGJyZWFrXG5cbiAgICAgICAgICBjYXNlICdjZGF0YSc6XG4gICAgICAgICAgICBlbWl0Tm9kZShwYXJzZXIsICdvbmNkYXRhJywgcGFyc2VyLmNkYXRhKVxuICAgICAgICAgICAgcGFyc2VyLmNkYXRhID0gJydcbiAgICAgICAgICAgIGJyZWFrXG5cbiAgICAgICAgICBjYXNlICdzY3JpcHQnOlxuICAgICAgICAgICAgZW1pdE5vZGUocGFyc2VyLCAnb25zY3JpcHQnLCBwYXJzZXIuc2NyaXB0KVxuICAgICAgICAgICAgcGFyc2VyLnNjcmlwdCA9ICcnXG4gICAgICAgICAgICBicmVha1xuXG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIGVycm9yKHBhcnNlciwgJ01heCBidWZmZXIgbGVuZ3RoIGV4Y2VlZGVkOiAnICsgYnVmZmVyc1tpXSlcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgbWF4QWN0dWFsID0gTWF0aC5tYXgobWF4QWN0dWFsLCBsZW4pXG4gICAgfVxuICAgIC8vIHNjaGVkdWxlIHRoZSBuZXh0IGNoZWNrIGZvciB0aGUgZWFybGllc3QgcG9zc2libGUgYnVmZmVyIG92ZXJydW4uXG4gICAgdmFyIG0gPSBzYXguTUFYX0JVRkZFUl9MRU5HVEggLSBtYXhBY3R1YWxcbiAgICBwYXJzZXIuYnVmZmVyQ2hlY2tQb3NpdGlvbiA9IG0gKyBwYXJzZXIucG9zaXRpb25cbiAgfVxuXG4gIGZ1bmN0aW9uIGNsZWFyQnVmZmVycyAocGFyc2VyKSB7XG4gICAgZm9yICh2YXIgaSA9IDAsIGwgPSBidWZmZXJzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgcGFyc2VyW2J1ZmZlcnNbaV1dID0gJydcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBmbHVzaEJ1ZmZlcnMgKHBhcnNlcikge1xuICAgIGNsb3NlVGV4dChwYXJzZXIpXG4gICAgaWYgKHBhcnNlci5jZGF0YSAhPT0gJycpIHtcbiAgICAgIGVtaXROb2RlKHBhcnNlciwgJ29uY2RhdGEnLCBwYXJzZXIuY2RhdGEpXG4gICAgICBwYXJzZXIuY2RhdGEgPSAnJ1xuICAgIH1cbiAgICBpZiAocGFyc2VyLnNjcmlwdCAhPT0gJycpIHtcbiAgICAgIGVtaXROb2RlKHBhcnNlciwgJ29uc2NyaXB0JywgcGFyc2VyLnNjcmlwdClcbiAgICAgIHBhcnNlci5zY3JpcHQgPSAnJ1xuICAgIH1cbiAgfVxuXG4gIFNBWFBhcnNlci5wcm90b3R5cGUgPSB7XG4gICAgZW5kOiBmdW5jdGlvbiAoKSB7IGVuZCh0aGlzKSB9LFxuICAgIHdyaXRlOiB3cml0ZSxcbiAgICByZXN1bWU6IGZ1bmN0aW9uICgpIHsgdGhpcy5lcnJvciA9IG51bGw7IHJldHVybiB0aGlzIH0sXG4gICAgY2xvc2U6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMud3JpdGUobnVsbCkgfSxcbiAgICBmbHVzaDogZnVuY3Rpb24gKCkgeyBmbHVzaEJ1ZmZlcnModGhpcykgfVxuICB9XG5cbiAgdmFyIFN0cmVhbVxuICB0cnkge1xuICAgIFN0cmVhbSA9IHJlcXVpcmUoJ3N0cmVhbScpLlN0cmVhbVxuICB9IGNhdGNoIChleCkge1xuICAgIFN0cmVhbSA9IGZ1bmN0aW9uICgpIHt9XG4gIH1cblxuICB2YXIgc3RyZWFtV3JhcHMgPSBzYXguRVZFTlRTLmZpbHRlcihmdW5jdGlvbiAoZXYpIHtcbiAgICByZXR1cm4gZXYgIT09ICdlcnJvcicgJiYgZXYgIT09ICdlbmQnXG4gIH0pXG5cbiAgZnVuY3Rpb24gY3JlYXRlU3RyZWFtIChzdHJpY3QsIG9wdCkge1xuICAgIHJldHVybiBuZXcgU0FYU3RyZWFtKHN0cmljdCwgb3B0KVxuICB9XG5cbiAgZnVuY3Rpb24gU0FYU3RyZWFtIChzdHJpY3QsIG9wdCkge1xuICAgIGlmICghKHRoaXMgaW5zdGFuY2VvZiBTQVhTdHJlYW0pKSB7XG4gICAgICByZXR1cm4gbmV3IFNBWFN0cmVhbShzdHJpY3QsIG9wdClcbiAgICB9XG5cbiAgICBTdHJlYW0uYXBwbHkodGhpcylcblxuICAgIHRoaXMuX3BhcnNlciA9IG5ldyBTQVhQYXJzZXIoc3RyaWN0LCBvcHQpXG4gICAgdGhpcy53cml0YWJsZSA9IHRydWVcbiAgICB0aGlzLnJlYWRhYmxlID0gdHJ1ZVxuXG4gICAgdmFyIG1lID0gdGhpc1xuXG4gICAgdGhpcy5fcGFyc2VyLm9uZW5kID0gZnVuY3Rpb24gKCkge1xuICAgICAgbWUuZW1pdCgnZW5kJylcbiAgICB9XG5cbiAgICB0aGlzLl9wYXJzZXIub25lcnJvciA9IGZ1bmN0aW9uIChlcikge1xuICAgICAgbWUuZW1pdCgnZXJyb3InLCBlcilcblxuICAgICAgLy8gaWYgZGlkbid0IHRocm93LCB0aGVuIG1lYW5zIGVycm9yIHdhcyBoYW5kbGVkLlxuICAgICAgLy8gZ28gYWhlYWQgYW5kIGNsZWFyIGVycm9yLCBzbyB3ZSBjYW4gd3JpdGUgYWdhaW4uXG4gICAgICBtZS5fcGFyc2VyLmVycm9yID0gbnVsbFxuICAgIH1cblxuICAgIHRoaXMuX2RlY29kZXIgPSBudWxsXG5cbiAgICBzdHJlYW1XcmFwcy5mb3JFYWNoKGZ1bmN0aW9uIChldikge1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG1lLCAnb24nICsgZXYsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmV0dXJuIG1lLl9wYXJzZXJbJ29uJyArIGV2XVxuICAgICAgICB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uIChoKSB7XG4gICAgICAgICAgaWYgKCFoKSB7XG4gICAgICAgICAgICBtZS5yZW1vdmVBbGxMaXN0ZW5lcnMoZXYpXG4gICAgICAgICAgICBtZS5fcGFyc2VyWydvbicgKyBldl0gPSBoXG4gICAgICAgICAgICByZXR1cm4gaFxuICAgICAgICAgIH1cbiAgICAgICAgICBtZS5vbihldiwgaClcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiBmYWxzZVxuICAgICAgfSlcbiAgICB9KVxuICB9XG5cbiAgU0FYU3RyZWFtLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoU3RyZWFtLnByb3RvdHlwZSwge1xuICAgIGNvbnN0cnVjdG9yOiB7XG4gICAgICB2YWx1ZTogU0FYU3RyZWFtXG4gICAgfVxuICB9KVxuXG4gIFNBWFN0cmVhbS5wcm90b3R5cGUud3JpdGUgPSBmdW5jdGlvbiAoZGF0YSkge1xuICAgIGlmICh0eXBlb2YgQnVmZmVyID09PSAnZnVuY3Rpb24nICYmXG4gICAgICB0eXBlb2YgQnVmZmVyLmlzQnVmZmVyID09PSAnZnVuY3Rpb24nICYmXG4gICAgICBCdWZmZXIuaXNCdWZmZXIoZGF0YSkpIHtcbiAgICAgIGlmICghdGhpcy5fZGVjb2Rlcikge1xuICAgICAgICB2YXIgU0QgPSByZXF1aXJlKCdzdHJpbmdfZGVjb2RlcicpLlN0cmluZ0RlY29kZXJcbiAgICAgICAgdGhpcy5fZGVjb2RlciA9IG5ldyBTRCgndXRmOCcpXG4gICAgICB9XG4gICAgICBkYXRhID0gdGhpcy5fZGVjb2Rlci53cml0ZShkYXRhKVxuICAgIH1cblxuICAgIHRoaXMuX3BhcnNlci53cml0ZShkYXRhLnRvU3RyaW5nKCkpXG4gICAgdGhpcy5lbWl0KCdkYXRhJywgZGF0YSlcbiAgICByZXR1cm4gdHJ1ZVxuICB9XG5cbiAgU0FYU3RyZWFtLnByb3RvdHlwZS5lbmQgPSBmdW5jdGlvbiAoY2h1bmspIHtcbiAgICBpZiAoY2h1bmsgJiYgY2h1bmsubGVuZ3RoKSB7XG4gICAgICB0aGlzLndyaXRlKGNodW5rKVxuICAgIH1cbiAgICB0aGlzLl9wYXJzZXIuZW5kKClcbiAgICByZXR1cm4gdHJ1ZVxuICB9XG5cbiAgU0FYU3RyZWFtLnByb3RvdHlwZS5vbiA9IGZ1bmN0aW9uIChldiwgaGFuZGxlcikge1xuICAgIHZhciBtZSA9IHRoaXNcbiAgICBpZiAoIW1lLl9wYXJzZXJbJ29uJyArIGV2XSAmJiBzdHJlYW1XcmFwcy5pbmRleE9mKGV2KSAhPT0gLTEpIHtcbiAgICAgIG1lLl9wYXJzZXJbJ29uJyArIGV2XSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGFyZ3MgPSBhcmd1bWVudHMubGVuZ3RoID09PSAxID8gW2FyZ3VtZW50c1swXV0gOiBBcnJheS5hcHBseShudWxsLCBhcmd1bWVudHMpXG4gICAgICAgIGFyZ3Muc3BsaWNlKDAsIDAsIGV2KVxuICAgICAgICBtZS5lbWl0LmFwcGx5KG1lLCBhcmdzKVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBTdHJlYW0ucHJvdG90eXBlLm9uLmNhbGwobWUsIGV2LCBoYW5kbGVyKVxuICB9XG5cbiAgLy8gdGhpcyByZWFsbHkgbmVlZHMgdG8gYmUgcmVwbGFjZWQgd2l0aCBjaGFyYWN0ZXIgY2xhc3Nlcy5cbiAgLy8gWE1MIGFsbG93cyBhbGwgbWFubmVyIG9mIHJpZGljdWxvdXMgbnVtYmVycyBhbmQgZGlnaXRzLlxuICB2YXIgQ0RBVEEgPSAnW0NEQVRBWydcbiAgdmFyIERPQ1RZUEUgPSAnRE9DVFlQRSdcbiAgdmFyIFhNTF9OQU1FU1BBQ0UgPSAnaHR0cDovL3d3dy53My5vcmcvWE1MLzE5OTgvbmFtZXNwYWNlJ1xuICB2YXIgWE1MTlNfTkFNRVNQQUNFID0gJ2h0dHA6Ly93d3cudzMub3JnLzIwMDAveG1sbnMvJ1xuICB2YXIgcm9vdE5TID0geyB4bWw6IFhNTF9OQU1FU1BBQ0UsIHhtbG5zOiBYTUxOU19OQU1FU1BBQ0UgfVxuXG4gIC8vIGh0dHA6Ly93d3cudzMub3JnL1RSL1JFQy14bWwvI05ULU5hbWVTdGFydENoYXJcbiAgLy8gVGhpcyBpbXBsZW1lbnRhdGlvbiB3b3JrcyBvbiBzdHJpbmdzLCBhIHNpbmdsZSBjaGFyYWN0ZXIgYXQgYSB0aW1lXG4gIC8vIGFzIHN1Y2gsIGl0IGNhbm5vdCBldmVyIHN1cHBvcnQgYXN0cmFsLXBsYW5lIGNoYXJhY3RlcnMgKDEwMDAwLUVGRkZGKVxuICAvLyB3aXRob3V0IGEgc2lnbmlmaWNhbnQgYnJlYWtpbmcgY2hhbmdlIHRvIGVpdGhlciB0aGlzICBwYXJzZXIsIG9yIHRoZVxuICAvLyBKYXZhU2NyaXB0IGxhbmd1YWdlLiAgSW1wbGVtZW50YXRpb24gb2YgYW4gZW1vamktY2FwYWJsZSB4bWwgcGFyc2VyXG4gIC8vIGlzIGxlZnQgYXMgYW4gZXhlcmNpc2UgZm9yIHRoZSByZWFkZXIuXG4gIHZhciBuYW1lU3RhcnQgPSAvWzpfQS1aYS16XFx1MDBDMC1cXHUwMEQ2XFx1MDBEOC1cXHUwMEY2XFx1MDBGOC1cXHUwMkZGXFx1MDM3MC1cXHUwMzdEXFx1MDM3Ri1cXHUxRkZGXFx1MjAwQy1cXHUyMDBEXFx1MjA3MC1cXHUyMThGXFx1MkMwMC1cXHUyRkVGXFx1MzAwMS1cXHVEN0ZGXFx1RjkwMC1cXHVGRENGXFx1RkRGMC1cXHVGRkZEXS9cblxuICB2YXIgbmFtZUJvZHkgPSAvWzpfQS1aYS16XFx1MDBDMC1cXHUwMEQ2XFx1MDBEOC1cXHUwMEY2XFx1MDBGOC1cXHUwMkZGXFx1MDM3MC1cXHUwMzdEXFx1MDM3Ri1cXHUxRkZGXFx1MjAwQy1cXHUyMDBEXFx1MjA3MC1cXHUyMThGXFx1MkMwMC1cXHUyRkVGXFx1MzAwMS1cXHVEN0ZGXFx1RjkwMC1cXHVGRENGXFx1RkRGMC1cXHVGRkZEXFx1MDBCN1xcdTAzMDAtXFx1MDM2RlxcdTIwM0YtXFx1MjA0MC5cXGQtXS9cblxuICB2YXIgZW50aXR5U3RhcnQgPSAvWyM6X0EtWmEtelxcdTAwQzAtXFx1MDBENlxcdTAwRDgtXFx1MDBGNlxcdTAwRjgtXFx1MDJGRlxcdTAzNzAtXFx1MDM3RFxcdTAzN0YtXFx1MUZGRlxcdTIwMEMtXFx1MjAwRFxcdTIwNzAtXFx1MjE4RlxcdTJDMDAtXFx1MkZFRlxcdTMwMDEtXFx1RDdGRlxcdUY5MDAtXFx1RkRDRlxcdUZERjAtXFx1RkZGRF0vXG4gIHZhciBlbnRpdHlCb2R5ID0gL1sjOl9BLVphLXpcXHUwMEMwLVxcdTAwRDZcXHUwMEQ4LVxcdTAwRjZcXHUwMEY4LVxcdTAyRkZcXHUwMzcwLVxcdTAzN0RcXHUwMzdGLVxcdTFGRkZcXHUyMDBDLVxcdTIwMERcXHUyMDcwLVxcdTIxOEZcXHUyQzAwLVxcdTJGRUZcXHUzMDAxLVxcdUQ3RkZcXHVGOTAwLVxcdUZEQ0ZcXHVGREYwLVxcdUZGRkRcXHUwMEI3XFx1MDMwMC1cXHUwMzZGXFx1MjAzRi1cXHUyMDQwLlxcZC1dL1xuXG4gIGZ1bmN0aW9uIGlzV2hpdGVzcGFjZSAoYykge1xuICAgIHJldHVybiBjID09PSAnICcgfHwgYyA9PT0gJ1xcbicgfHwgYyA9PT0gJ1xccicgfHwgYyA9PT0gJ1xcdCdcbiAgfVxuXG4gIGZ1bmN0aW9uIGlzUXVvdGUgKGMpIHtcbiAgICByZXR1cm4gYyA9PT0gJ1wiJyB8fCBjID09PSAnXFwnJ1xuICB9XG5cbiAgZnVuY3Rpb24gaXNBdHRyaWJFbmQgKGMpIHtcbiAgICByZXR1cm4gYyA9PT0gJz4nIHx8IGlzV2hpdGVzcGFjZShjKVxuICB9XG5cbiAgZnVuY3Rpb24gaXNNYXRjaCAocmVnZXgsIGMpIHtcbiAgICByZXR1cm4gcmVnZXgudGVzdChjKVxuICB9XG5cbiAgZnVuY3Rpb24gbm90TWF0Y2ggKHJlZ2V4LCBjKSB7XG4gICAgcmV0dXJuICFpc01hdGNoKHJlZ2V4LCBjKVxuICB9XG5cbiAgdmFyIFMgPSAwXG4gIHNheC5TVEFURSA9IHtcbiAgICBCRUdJTjogUysrLCAvLyBsZWFkaW5nIGJ5dGUgb3JkZXIgbWFyayBvciB3aGl0ZXNwYWNlXG4gICAgQkVHSU5fV0hJVEVTUEFDRTogUysrLCAvLyBsZWFkaW5nIHdoaXRlc3BhY2VcbiAgICBURVhUOiBTKyssIC8vIGdlbmVyYWwgc3R1ZmZcbiAgICBURVhUX0VOVElUWTogUysrLCAvLyAmYW1wIGFuZCBzdWNoLlxuICAgIE9QRU5fV0FLQTogUysrLCAvLyA8XG4gICAgU0dNTF9ERUNMOiBTKyssIC8vIDwhQkxBUkdcbiAgICBTR01MX0RFQ0xfUVVPVEVEOiBTKyssIC8vIDwhQkxBUkcgZm9vIFwiYmFyXG4gICAgRE9DVFlQRTogUysrLCAvLyA8IURPQ1RZUEVcbiAgICBET0NUWVBFX1FVT1RFRDogUysrLCAvLyA8IURPQ1RZUEUgXCIvL2JsYWhcbiAgICBET0NUWVBFX0RURDogUysrLCAvLyA8IURPQ1RZUEUgXCIvL2JsYWhcIiBbIC4uLlxuICAgIERPQ1RZUEVfRFREX1FVT1RFRDogUysrLCAvLyA8IURPQ1RZUEUgXCIvL2JsYWhcIiBbIFwiZm9vXG4gICAgQ09NTUVOVF9TVEFSVElORzogUysrLCAvLyA8IS1cbiAgICBDT01NRU5UOiBTKyssIC8vIDwhLS1cbiAgICBDT01NRU5UX0VORElORzogUysrLCAvLyA8IS0tIGJsYWggLVxuICAgIENPTU1FTlRfRU5ERUQ6IFMrKywgLy8gPCEtLSBibGFoIC0tXG4gICAgQ0RBVEE6IFMrKywgLy8gPCFbQ0RBVEFbIHNvbWV0aGluZ1xuICAgIENEQVRBX0VORElORzogUysrLCAvLyBdXG4gICAgQ0RBVEFfRU5ESU5HXzI6IFMrKywgLy8gXV1cbiAgICBQUk9DX0lOU1Q6IFMrKywgLy8gPD9oaVxuICAgIFBST0NfSU5TVF9CT0RZOiBTKyssIC8vIDw/aGkgdGhlcmVcbiAgICBQUk9DX0lOU1RfRU5ESU5HOiBTKyssIC8vIDw/aGkgXCJ0aGVyZVwiID9cbiAgICBPUEVOX1RBRzogUysrLCAvLyA8c3Ryb25nXG4gICAgT1BFTl9UQUdfU0xBU0g6IFMrKywgLy8gPHN0cm9uZyAvXG4gICAgQVRUUklCOiBTKyssIC8vIDxhXG4gICAgQVRUUklCX05BTUU6IFMrKywgLy8gPGEgZm9vXG4gICAgQVRUUklCX05BTUVfU0FXX1dISVRFOiBTKyssIC8vIDxhIGZvbyBfXG4gICAgQVRUUklCX1ZBTFVFOiBTKyssIC8vIDxhIGZvbz1cbiAgICBBVFRSSUJfVkFMVUVfUVVPVEVEOiBTKyssIC8vIDxhIGZvbz1cImJhclxuICAgIEFUVFJJQl9WQUxVRV9DTE9TRUQ6IFMrKywgLy8gPGEgZm9vPVwiYmFyXCJcbiAgICBBVFRSSUJfVkFMVUVfVU5RVU9URUQ6IFMrKywgLy8gPGEgZm9vPWJhclxuICAgIEFUVFJJQl9WQUxVRV9FTlRJVFlfUTogUysrLCAvLyA8Zm9vIGJhcj1cIiZxdW90O1wiXG4gICAgQVRUUklCX1ZBTFVFX0VOVElUWV9VOiBTKyssIC8vIDxmb28gYmFyPSZxdW90XG4gICAgQ0xPU0VfVEFHOiBTKyssIC8vIDwvYVxuICAgIENMT1NFX1RBR19TQVdfV0hJVEU6IFMrKywgLy8gPC9hICAgPlxuICAgIFNDUklQVDogUysrLCAvLyA8c2NyaXB0PiAuLi5cbiAgICBTQ1JJUFRfRU5ESU5HOiBTKysgLy8gPHNjcmlwdD4gLi4uIDxcbiAgfVxuXG4gIHNheC5YTUxfRU5USVRJRVMgPSB7XG4gICAgJ2FtcCc6ICcmJyxcbiAgICAnZ3QnOiAnPicsXG4gICAgJ2x0JzogJzwnLFxuICAgICdxdW90JzogJ1wiJyxcbiAgICAnYXBvcyc6IFwiJ1wiXG4gIH1cblxuICBzYXguRU5USVRJRVMgPSB7XG4gICAgJ2FtcCc6ICcmJyxcbiAgICAnZ3QnOiAnPicsXG4gICAgJ2x0JzogJzwnLFxuICAgICdxdW90JzogJ1wiJyxcbiAgICAnYXBvcyc6IFwiJ1wiLFxuICAgICdBRWxpZyc6IDE5OCxcbiAgICAnQWFjdXRlJzogMTkzLFxuICAgICdBY2lyYyc6IDE5NCxcbiAgICAnQWdyYXZlJzogMTkyLFxuICAgICdBcmluZyc6IDE5NyxcbiAgICAnQXRpbGRlJzogMTk1LFxuICAgICdBdW1sJzogMTk2LFxuICAgICdDY2VkaWwnOiAxOTksXG4gICAgJ0VUSCc6IDIwOCxcbiAgICAnRWFjdXRlJzogMjAxLFxuICAgICdFY2lyYyc6IDIwMixcbiAgICAnRWdyYXZlJzogMjAwLFxuICAgICdFdW1sJzogMjAzLFxuICAgICdJYWN1dGUnOiAyMDUsXG4gICAgJ0ljaXJjJzogMjA2LFxuICAgICdJZ3JhdmUnOiAyMDQsXG4gICAgJ0l1bWwnOiAyMDcsXG4gICAgJ050aWxkZSc6IDIwOSxcbiAgICAnT2FjdXRlJzogMjExLFxuICAgICdPY2lyYyc6IDIxMixcbiAgICAnT2dyYXZlJzogMjEwLFxuICAgICdPc2xhc2gnOiAyMTYsXG4gICAgJ090aWxkZSc6IDIxMyxcbiAgICAnT3VtbCc6IDIxNCxcbiAgICAnVEhPUk4nOiAyMjIsXG4gICAgJ1VhY3V0ZSc6IDIxOCxcbiAgICAnVWNpcmMnOiAyMTksXG4gICAgJ1VncmF2ZSc6IDIxNyxcbiAgICAnVXVtbCc6IDIyMCxcbiAgICAnWWFjdXRlJzogMjIxLFxuICAgICdhYWN1dGUnOiAyMjUsXG4gICAgJ2FjaXJjJzogMjI2LFxuICAgICdhZWxpZyc6IDIzMCxcbiAgICAnYWdyYXZlJzogMjI0LFxuICAgICdhcmluZyc6IDIyOSxcbiAgICAnYXRpbGRlJzogMjI3LFxuICAgICdhdW1sJzogMjI4LFxuICAgICdjY2VkaWwnOiAyMzEsXG4gICAgJ2VhY3V0ZSc6IDIzMyxcbiAgICAnZWNpcmMnOiAyMzQsXG4gICAgJ2VncmF2ZSc6IDIzMixcbiAgICAnZXRoJzogMjQwLFxuICAgICdldW1sJzogMjM1LFxuICAgICdpYWN1dGUnOiAyMzcsXG4gICAgJ2ljaXJjJzogMjM4LFxuICAgICdpZ3JhdmUnOiAyMzYsXG4gICAgJ2l1bWwnOiAyMzksXG4gICAgJ250aWxkZSc6IDI0MSxcbiAgICAnb2FjdXRlJzogMjQzLFxuICAgICdvY2lyYyc6IDI0NCxcbiAgICAnb2dyYXZlJzogMjQyLFxuICAgICdvc2xhc2gnOiAyNDgsXG4gICAgJ290aWxkZSc6IDI0NSxcbiAgICAnb3VtbCc6IDI0NixcbiAgICAnc3psaWcnOiAyMjMsXG4gICAgJ3Rob3JuJzogMjU0LFxuICAgICd1YWN1dGUnOiAyNTAsXG4gICAgJ3VjaXJjJzogMjUxLFxuICAgICd1Z3JhdmUnOiAyNDksXG4gICAgJ3V1bWwnOiAyNTIsXG4gICAgJ3lhY3V0ZSc6IDI1MyxcbiAgICAneXVtbCc6IDI1NSxcbiAgICAnY29weSc6IDE2OSxcbiAgICAncmVnJzogMTc0LFxuICAgICduYnNwJzogMTYwLFxuICAgICdpZXhjbCc6IDE2MSxcbiAgICAnY2VudCc6IDE2MixcbiAgICAncG91bmQnOiAxNjMsXG4gICAgJ2N1cnJlbic6IDE2NCxcbiAgICAneWVuJzogMTY1LFxuICAgICdicnZiYXInOiAxNjYsXG4gICAgJ3NlY3QnOiAxNjcsXG4gICAgJ3VtbCc6IDE2OCxcbiAgICAnb3JkZic6IDE3MCxcbiAgICAnbGFxdW8nOiAxNzEsXG4gICAgJ25vdCc6IDE3MixcbiAgICAnc2h5JzogMTczLFxuICAgICdtYWNyJzogMTc1LFxuICAgICdkZWcnOiAxNzYsXG4gICAgJ3BsdXNtbic6IDE3NyxcbiAgICAnc3VwMSc6IDE4NSxcbiAgICAnc3VwMic6IDE3OCxcbiAgICAnc3VwMyc6IDE3OSxcbiAgICAnYWN1dGUnOiAxODAsXG4gICAgJ21pY3JvJzogMTgxLFxuICAgICdwYXJhJzogMTgyLFxuICAgICdtaWRkb3QnOiAxODMsXG4gICAgJ2NlZGlsJzogMTg0LFxuICAgICdvcmRtJzogMTg2LFxuICAgICdyYXF1byc6IDE4NyxcbiAgICAnZnJhYzE0JzogMTg4LFxuICAgICdmcmFjMTInOiAxODksXG4gICAgJ2ZyYWMzNCc6IDE5MCxcbiAgICAnaXF1ZXN0JzogMTkxLFxuICAgICd0aW1lcyc6IDIxNSxcbiAgICAnZGl2aWRlJzogMjQ3LFxuICAgICdPRWxpZyc6IDMzOCxcbiAgICAnb2VsaWcnOiAzMzksXG4gICAgJ1NjYXJvbic6IDM1MixcbiAgICAnc2Nhcm9uJzogMzUzLFxuICAgICdZdW1sJzogMzc2LFxuICAgICdmbm9mJzogNDAyLFxuICAgICdjaXJjJzogNzEwLFxuICAgICd0aWxkZSc6IDczMixcbiAgICAnQWxwaGEnOiA5MTMsXG4gICAgJ0JldGEnOiA5MTQsXG4gICAgJ0dhbW1hJzogOTE1LFxuICAgICdEZWx0YSc6IDkxNixcbiAgICAnRXBzaWxvbic6IDkxNyxcbiAgICAnWmV0YSc6IDkxOCxcbiAgICAnRXRhJzogOTE5LFxuICAgICdUaGV0YSc6IDkyMCxcbiAgICAnSW90YSc6IDkyMSxcbiAgICAnS2FwcGEnOiA5MjIsXG4gICAgJ0xhbWJkYSc6IDkyMyxcbiAgICAnTXUnOiA5MjQsXG4gICAgJ051JzogOTI1LFxuICAgICdYaSc6IDkyNixcbiAgICAnT21pY3Jvbic6IDkyNyxcbiAgICAnUGknOiA5MjgsXG4gICAgJ1Jobyc6IDkyOSxcbiAgICAnU2lnbWEnOiA5MzEsXG4gICAgJ1RhdSc6IDkzMixcbiAgICAnVXBzaWxvbic6IDkzMyxcbiAgICAnUGhpJzogOTM0LFxuICAgICdDaGknOiA5MzUsXG4gICAgJ1BzaSc6IDkzNixcbiAgICAnT21lZ2EnOiA5MzcsXG4gICAgJ2FscGhhJzogOTQ1LFxuICAgICdiZXRhJzogOTQ2LFxuICAgICdnYW1tYSc6IDk0NyxcbiAgICAnZGVsdGEnOiA5NDgsXG4gICAgJ2Vwc2lsb24nOiA5NDksXG4gICAgJ3pldGEnOiA5NTAsXG4gICAgJ2V0YSc6IDk1MSxcbiAgICAndGhldGEnOiA5NTIsXG4gICAgJ2lvdGEnOiA5NTMsXG4gICAgJ2thcHBhJzogOTU0LFxuICAgICdsYW1iZGEnOiA5NTUsXG4gICAgJ211JzogOTU2LFxuICAgICdudSc6IDk1NyxcbiAgICAneGknOiA5NTgsXG4gICAgJ29taWNyb24nOiA5NTksXG4gICAgJ3BpJzogOTYwLFxuICAgICdyaG8nOiA5NjEsXG4gICAgJ3NpZ21hZic6IDk2MixcbiAgICAnc2lnbWEnOiA5NjMsXG4gICAgJ3RhdSc6IDk2NCxcbiAgICAndXBzaWxvbic6IDk2NSxcbiAgICAncGhpJzogOTY2LFxuICAgICdjaGknOiA5NjcsXG4gICAgJ3BzaSc6IDk2OCxcbiAgICAnb21lZ2EnOiA5NjksXG4gICAgJ3RoZXRhc3ltJzogOTc3LFxuICAgICd1cHNpaCc6IDk3OCxcbiAgICAncGl2JzogOTgyLFxuICAgICdlbnNwJzogODE5NCxcbiAgICAnZW1zcCc6IDgxOTUsXG4gICAgJ3RoaW5zcCc6IDgyMDEsXG4gICAgJ3p3bmonOiA4MjA0LFxuICAgICd6d2onOiA4MjA1LFxuICAgICdscm0nOiA4MjA2LFxuICAgICdybG0nOiA4MjA3LFxuICAgICduZGFzaCc6IDgyMTEsXG4gICAgJ21kYXNoJzogODIxMixcbiAgICAnbHNxdW8nOiA4MjE2LFxuICAgICdyc3F1byc6IDgyMTcsXG4gICAgJ3NicXVvJzogODIxOCxcbiAgICAnbGRxdW8nOiA4MjIwLFxuICAgICdyZHF1byc6IDgyMjEsXG4gICAgJ2JkcXVvJzogODIyMixcbiAgICAnZGFnZ2VyJzogODIyNCxcbiAgICAnRGFnZ2VyJzogODIyNSxcbiAgICAnYnVsbCc6IDgyMjYsXG4gICAgJ2hlbGxpcCc6IDgyMzAsXG4gICAgJ3Blcm1pbCc6IDgyNDAsXG4gICAgJ3ByaW1lJzogODI0MixcbiAgICAnUHJpbWUnOiA4MjQzLFxuICAgICdsc2FxdW8nOiA4MjQ5LFxuICAgICdyc2FxdW8nOiA4MjUwLFxuICAgICdvbGluZSc6IDgyNTQsXG4gICAgJ2ZyYXNsJzogODI2MCxcbiAgICAnZXVybyc6IDgzNjQsXG4gICAgJ2ltYWdlJzogODQ2NSxcbiAgICAnd2VpZXJwJzogODQ3MixcbiAgICAncmVhbCc6IDg0NzYsXG4gICAgJ3RyYWRlJzogODQ4MixcbiAgICAnYWxlZnN5bSc6IDg1MDEsXG4gICAgJ2xhcnInOiA4NTkyLFxuICAgICd1YXJyJzogODU5MyxcbiAgICAncmFycic6IDg1OTQsXG4gICAgJ2RhcnInOiA4NTk1LFxuICAgICdoYXJyJzogODU5NixcbiAgICAnY3JhcnInOiA4NjI5LFxuICAgICdsQXJyJzogODY1NixcbiAgICAndUFycic6IDg2NTcsXG4gICAgJ3JBcnInOiA4NjU4LFxuICAgICdkQXJyJzogODY1OSxcbiAgICAnaEFycic6IDg2NjAsXG4gICAgJ2ZvcmFsbCc6IDg3MDQsXG4gICAgJ3BhcnQnOiA4NzA2LFxuICAgICdleGlzdCc6IDg3MDcsXG4gICAgJ2VtcHR5JzogODcwOSxcbiAgICAnbmFibGEnOiA4NzExLFxuICAgICdpc2luJzogODcxMixcbiAgICAnbm90aW4nOiA4NzEzLFxuICAgICduaSc6IDg3MTUsXG4gICAgJ3Byb2QnOiA4NzE5LFxuICAgICdzdW0nOiA4NzIxLFxuICAgICdtaW51cyc6IDg3MjIsXG4gICAgJ2xvd2FzdCc6IDg3MjcsXG4gICAgJ3JhZGljJzogODczMCxcbiAgICAncHJvcCc6IDg3MzMsXG4gICAgJ2luZmluJzogODczNCxcbiAgICAnYW5nJzogODczNixcbiAgICAnYW5kJzogODc0MyxcbiAgICAnb3InOiA4NzQ0LFxuICAgICdjYXAnOiA4NzQ1LFxuICAgICdjdXAnOiA4NzQ2LFxuICAgICdpbnQnOiA4NzQ3LFxuICAgICd0aGVyZTQnOiA4NzU2LFxuICAgICdzaW0nOiA4NzY0LFxuICAgICdjb25nJzogODc3MyxcbiAgICAnYXN5bXAnOiA4Nzc2LFxuICAgICduZSc6IDg4MDAsXG4gICAgJ2VxdWl2JzogODgwMSxcbiAgICAnbGUnOiA4ODA0LFxuICAgICdnZSc6IDg4MDUsXG4gICAgJ3N1Yic6IDg4MzQsXG4gICAgJ3N1cCc6IDg4MzUsXG4gICAgJ25zdWInOiA4ODM2LFxuICAgICdzdWJlJzogODgzOCxcbiAgICAnc3VwZSc6IDg4MzksXG4gICAgJ29wbHVzJzogODg1MyxcbiAgICAnb3RpbWVzJzogODg1NSxcbiAgICAncGVycCc6IDg4NjksXG4gICAgJ3Nkb3QnOiA4OTAxLFxuICAgICdsY2VpbCc6IDg5NjgsXG4gICAgJ3JjZWlsJzogODk2OSxcbiAgICAnbGZsb29yJzogODk3MCxcbiAgICAncmZsb29yJzogODk3MSxcbiAgICAnbGFuZyc6IDkwMDEsXG4gICAgJ3JhbmcnOiA5MDAyLFxuICAgICdsb3onOiA5Njc0LFxuICAgICdzcGFkZXMnOiA5ODI0LFxuICAgICdjbHVicyc6IDk4MjcsXG4gICAgJ2hlYXJ0cyc6IDk4MjksXG4gICAgJ2RpYW1zJzogOTgzMFxuICB9XG5cbiAgT2JqZWN0LmtleXMoc2F4LkVOVElUSUVTKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICB2YXIgZSA9IHNheC5FTlRJVElFU1trZXldXG4gICAgdmFyIHMgPSB0eXBlb2YgZSA9PT0gJ251bWJlcicgPyBTdHJpbmcuZnJvbUNoYXJDb2RlKGUpIDogZVxuICAgIHNheC5FTlRJVElFU1trZXldID0gc1xuICB9KVxuXG4gIGZvciAodmFyIHMgaW4gc2F4LlNUQVRFKSB7XG4gICAgc2F4LlNUQVRFW3NheC5TVEFURVtzXV0gPSBzXG4gIH1cblxuICAvLyBzaG9ydGhhbmRcbiAgUyA9IHNheC5TVEFURVxuXG4gIGZ1bmN0aW9uIGVtaXQgKHBhcnNlciwgZXZlbnQsIGRhdGEpIHtcbiAgICBwYXJzZXJbZXZlbnRdICYmIHBhcnNlcltldmVudF0oZGF0YSlcbiAgfVxuXG4gIGZ1bmN0aW9uIGVtaXROb2RlIChwYXJzZXIsIG5vZGVUeXBlLCBkYXRhKSB7XG4gICAgaWYgKHBhcnNlci50ZXh0Tm9kZSkgY2xvc2VUZXh0KHBhcnNlcilcbiAgICBlbWl0KHBhcnNlciwgbm9kZVR5cGUsIGRhdGEpXG4gIH1cblxuICBmdW5jdGlvbiBjbG9zZVRleHQgKHBhcnNlcikge1xuICAgIHBhcnNlci50ZXh0Tm9kZSA9IHRleHRvcHRzKHBhcnNlci5vcHQsIHBhcnNlci50ZXh0Tm9kZSlcbiAgICBpZiAocGFyc2VyLnRleHROb2RlKSBlbWl0KHBhcnNlciwgJ29udGV4dCcsIHBhcnNlci50ZXh0Tm9kZSlcbiAgICBwYXJzZXIudGV4dE5vZGUgPSAnJ1xuICB9XG5cbiAgZnVuY3Rpb24gdGV4dG9wdHMgKG9wdCwgdGV4dCkge1xuICAgIGlmIChvcHQudHJpbSkgdGV4dCA9IHRleHQudHJpbSgpXG4gICAgaWYgKG9wdC5ub3JtYWxpemUpIHRleHQgPSB0ZXh0LnJlcGxhY2UoL1xccysvZywgJyAnKVxuICAgIHJldHVybiB0ZXh0XG4gIH1cblxuICBmdW5jdGlvbiBlcnJvciAocGFyc2VyLCBlcikge1xuICAgIGNsb3NlVGV4dChwYXJzZXIpXG4gICAgaWYgKHBhcnNlci50cmFja1Bvc2l0aW9uKSB7XG4gICAgICBlciArPSAnXFxuTGluZTogJyArIHBhcnNlci5saW5lICtcbiAgICAgICAgJ1xcbkNvbHVtbjogJyArIHBhcnNlci5jb2x1bW4gK1xuICAgICAgICAnXFxuQ2hhcjogJyArIHBhcnNlci5jXG4gICAgfVxuICAgIGVyID0gbmV3IEVycm9yKGVyKVxuICAgIHBhcnNlci5lcnJvciA9IGVyXG4gICAgZW1pdChwYXJzZXIsICdvbmVycm9yJywgZXIpXG4gICAgcmV0dXJuIHBhcnNlclxuICB9XG5cbiAgZnVuY3Rpb24gZW5kIChwYXJzZXIpIHtcbiAgICBpZiAocGFyc2VyLnNhd1Jvb3QgJiYgIXBhcnNlci5jbG9zZWRSb290KSBzdHJpY3RGYWlsKHBhcnNlciwgJ1VuY2xvc2VkIHJvb3QgdGFnJylcbiAgICBpZiAoKHBhcnNlci5zdGF0ZSAhPT0gUy5CRUdJTikgJiZcbiAgICAgIChwYXJzZXIuc3RhdGUgIT09IFMuQkVHSU5fV0hJVEVTUEFDRSkgJiZcbiAgICAgIChwYXJzZXIuc3RhdGUgIT09IFMuVEVYVCkpIHtcbiAgICAgIGVycm9yKHBhcnNlciwgJ1VuZXhwZWN0ZWQgZW5kJylcbiAgICB9XG4gICAgY2xvc2VUZXh0KHBhcnNlcilcbiAgICBwYXJzZXIuYyA9ICcnXG4gICAgcGFyc2VyLmNsb3NlZCA9IHRydWVcbiAgICBlbWl0KHBhcnNlciwgJ29uZW5kJylcbiAgICBTQVhQYXJzZXIuY2FsbChwYXJzZXIsIHBhcnNlci5zdHJpY3QsIHBhcnNlci5vcHQpXG4gICAgcmV0dXJuIHBhcnNlclxuICB9XG5cbiAgZnVuY3Rpb24gc3RyaWN0RmFpbCAocGFyc2VyLCBtZXNzYWdlKSB7XG4gICAgaWYgKHR5cGVvZiBwYXJzZXIgIT09ICdvYmplY3QnIHx8ICEocGFyc2VyIGluc3RhbmNlb2YgU0FYUGFyc2VyKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdiYWQgY2FsbCB0byBzdHJpY3RGYWlsJylcbiAgICB9XG4gICAgaWYgKHBhcnNlci5zdHJpY3QpIHtcbiAgICAgIGVycm9yKHBhcnNlciwgbWVzc2FnZSlcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBuZXdUYWcgKHBhcnNlcikge1xuICAgIGlmICghcGFyc2VyLnN0cmljdCkgcGFyc2VyLnRhZ05hbWUgPSBwYXJzZXIudGFnTmFtZVtwYXJzZXIubG9vc2VDYXNlXSgpXG4gICAgdmFyIHBhcmVudCA9IHBhcnNlci50YWdzW3BhcnNlci50YWdzLmxlbmd0aCAtIDFdIHx8IHBhcnNlclxuICAgIHZhciB0YWcgPSBwYXJzZXIudGFnID0geyBuYW1lOiBwYXJzZXIudGFnTmFtZSwgYXR0cmlidXRlczoge30gfVxuXG4gICAgLy8gd2lsbCBiZSBvdmVycmlkZGVuIGlmIHRhZyBjb250YWlscyBhbiB4bWxucz1cImZvb1wiIG9yIHhtbG5zOmZvbz1cImJhclwiXG4gICAgaWYgKHBhcnNlci5vcHQueG1sbnMpIHtcbiAgICAgIHRhZy5ucyA9IHBhcmVudC5uc1xuICAgIH1cbiAgICBwYXJzZXIuYXR0cmliTGlzdC5sZW5ndGggPSAwXG4gICAgZW1pdE5vZGUocGFyc2VyLCAnb25vcGVudGFnc3RhcnQnLCB0YWcpXG4gIH1cblxuICBmdW5jdGlvbiBxbmFtZSAobmFtZSwgYXR0cmlidXRlKSB7XG4gICAgdmFyIGkgPSBuYW1lLmluZGV4T2YoJzonKVxuICAgIHZhciBxdWFsTmFtZSA9IGkgPCAwID8gWyAnJywgbmFtZSBdIDogbmFtZS5zcGxpdCgnOicpXG4gICAgdmFyIHByZWZpeCA9IHF1YWxOYW1lWzBdXG4gICAgdmFyIGxvY2FsID0gcXVhbE5hbWVbMV1cblxuICAgIC8vIDx4IFwieG1sbnNcIj1cImh0dHA6Ly9mb29cIj5cbiAgICBpZiAoYXR0cmlidXRlICYmIG5hbWUgPT09ICd4bWxucycpIHtcbiAgICAgIHByZWZpeCA9ICd4bWxucydcbiAgICAgIGxvY2FsID0gJydcbiAgICB9XG5cbiAgICByZXR1cm4geyBwcmVmaXg6IHByZWZpeCwgbG9jYWw6IGxvY2FsIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGF0dHJpYiAocGFyc2VyKSB7XG4gICAgaWYgKCFwYXJzZXIuc3RyaWN0KSB7XG4gICAgICBwYXJzZXIuYXR0cmliTmFtZSA9IHBhcnNlci5hdHRyaWJOYW1lW3BhcnNlci5sb29zZUNhc2VdKClcbiAgICB9XG5cbiAgICBpZiAocGFyc2VyLmF0dHJpYkxpc3QuaW5kZXhPZihwYXJzZXIuYXR0cmliTmFtZSkgIT09IC0xIHx8XG4gICAgICBwYXJzZXIudGFnLmF0dHJpYnV0ZXMuaGFzT3duUHJvcGVydHkocGFyc2VyLmF0dHJpYk5hbWUpKSB7XG4gICAgICBwYXJzZXIuYXR0cmliTmFtZSA9IHBhcnNlci5hdHRyaWJWYWx1ZSA9ICcnXG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICBpZiAocGFyc2VyLm9wdC54bWxucykge1xuICAgICAgdmFyIHFuID0gcW5hbWUocGFyc2VyLmF0dHJpYk5hbWUsIHRydWUpXG4gICAgICB2YXIgcHJlZml4ID0gcW4ucHJlZml4XG4gICAgICB2YXIgbG9jYWwgPSBxbi5sb2NhbFxuXG4gICAgICBpZiAocHJlZml4ID09PSAneG1sbnMnKSB7XG4gICAgICAgIC8vIG5hbWVzcGFjZSBiaW5kaW5nIGF0dHJpYnV0ZS4gcHVzaCB0aGUgYmluZGluZyBpbnRvIHNjb3BlXG4gICAgICAgIGlmIChsb2NhbCA9PT0gJ3htbCcgJiYgcGFyc2VyLmF0dHJpYlZhbHVlICE9PSBYTUxfTkFNRVNQQUNFKSB7XG4gICAgICAgICAgc3RyaWN0RmFpbChwYXJzZXIsXG4gICAgICAgICAgICAneG1sOiBwcmVmaXggbXVzdCBiZSBib3VuZCB0byAnICsgWE1MX05BTUVTUEFDRSArICdcXG4nICtcbiAgICAgICAgICAgICdBY3R1YWw6ICcgKyBwYXJzZXIuYXR0cmliVmFsdWUpXG4gICAgICAgIH0gZWxzZSBpZiAobG9jYWwgPT09ICd4bWxucycgJiYgcGFyc2VyLmF0dHJpYlZhbHVlICE9PSBYTUxOU19OQU1FU1BBQ0UpIHtcbiAgICAgICAgICBzdHJpY3RGYWlsKHBhcnNlcixcbiAgICAgICAgICAgICd4bWxuczogcHJlZml4IG11c3QgYmUgYm91bmQgdG8gJyArIFhNTE5TX05BTUVTUEFDRSArICdcXG4nICtcbiAgICAgICAgICAgICdBY3R1YWw6ICcgKyBwYXJzZXIuYXR0cmliVmFsdWUpXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIHRhZyA9IHBhcnNlci50YWdcbiAgICAgICAgICB2YXIgcGFyZW50ID0gcGFyc2VyLnRhZ3NbcGFyc2VyLnRhZ3MubGVuZ3RoIC0gMV0gfHwgcGFyc2VyXG4gICAgICAgICAgaWYgKHRhZy5ucyA9PT0gcGFyZW50Lm5zKSB7XG4gICAgICAgICAgICB0YWcubnMgPSBPYmplY3QuY3JlYXRlKHBhcmVudC5ucylcbiAgICAgICAgICB9XG4gICAgICAgICAgdGFnLm5zW2xvY2FsXSA9IHBhcnNlci5hdHRyaWJWYWx1ZVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIGRlZmVyIG9uYXR0cmlidXRlIGV2ZW50cyB1bnRpbCBhbGwgYXR0cmlidXRlcyBoYXZlIGJlZW4gc2VlblxuICAgICAgLy8gc28gYW55IG5ldyBiaW5kaW5ncyBjYW4gdGFrZSBlZmZlY3QuIHByZXNlcnZlIGF0dHJpYnV0ZSBvcmRlclxuICAgICAgLy8gc28gZGVmZXJyZWQgZXZlbnRzIGNhbiBiZSBlbWl0dGVkIGluIGRvY3VtZW50IG9yZGVyXG4gICAgICBwYXJzZXIuYXR0cmliTGlzdC5wdXNoKFtwYXJzZXIuYXR0cmliTmFtZSwgcGFyc2VyLmF0dHJpYlZhbHVlXSlcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gaW4gbm9uLXhtbG5zIG1vZGUsIHdlIGNhbiBlbWl0IHRoZSBldmVudCByaWdodCBhd2F5XG4gICAgICBwYXJzZXIudGFnLmF0dHJpYnV0ZXNbcGFyc2VyLmF0dHJpYk5hbWVdID0gcGFyc2VyLmF0dHJpYlZhbHVlXG4gICAgICBlbWl0Tm9kZShwYXJzZXIsICdvbmF0dHJpYnV0ZScsIHtcbiAgICAgICAgbmFtZTogcGFyc2VyLmF0dHJpYk5hbWUsXG4gICAgICAgIHZhbHVlOiBwYXJzZXIuYXR0cmliVmFsdWVcbiAgICAgIH0pXG4gICAgfVxuXG4gICAgcGFyc2VyLmF0dHJpYk5hbWUgPSBwYXJzZXIuYXR0cmliVmFsdWUgPSAnJ1xuICB9XG5cbiAgZnVuY3Rpb24gb3BlblRhZyAocGFyc2VyLCBzZWxmQ2xvc2luZykge1xuICAgIGlmIChwYXJzZXIub3B0LnhtbG5zKSB7XG4gICAgICAvLyBlbWl0IG5hbWVzcGFjZSBiaW5kaW5nIGV2ZW50c1xuICAgICAgdmFyIHRhZyA9IHBhcnNlci50YWdcblxuICAgICAgLy8gYWRkIG5hbWVzcGFjZSBpbmZvIHRvIHRhZ1xuICAgICAgdmFyIHFuID0gcW5hbWUocGFyc2VyLnRhZ05hbWUpXG4gICAgICB0YWcucHJlZml4ID0gcW4ucHJlZml4XG4gICAgICB0YWcubG9jYWwgPSBxbi5sb2NhbFxuICAgICAgdGFnLnVyaSA9IHRhZy5uc1txbi5wcmVmaXhdIHx8ICcnXG5cbiAgICAgIGlmICh0YWcucHJlZml4ICYmICF0YWcudXJpKSB7XG4gICAgICAgIHN0cmljdEZhaWwocGFyc2VyLCAnVW5ib3VuZCBuYW1lc3BhY2UgcHJlZml4OiAnICtcbiAgICAgICAgICBKU09OLnN0cmluZ2lmeShwYXJzZXIudGFnTmFtZSkpXG4gICAgICAgIHRhZy51cmkgPSBxbi5wcmVmaXhcbiAgICAgIH1cblxuICAgICAgdmFyIHBhcmVudCA9IHBhcnNlci50YWdzW3BhcnNlci50YWdzLmxlbmd0aCAtIDFdIHx8IHBhcnNlclxuICAgICAgaWYgKHRhZy5ucyAmJiBwYXJlbnQubnMgIT09IHRhZy5ucykge1xuICAgICAgICBPYmplY3Qua2V5cyh0YWcubnMpLmZvckVhY2goZnVuY3Rpb24gKHApIHtcbiAgICAgICAgICBlbWl0Tm9kZShwYXJzZXIsICdvbm9wZW5uYW1lc3BhY2UnLCB7XG4gICAgICAgICAgICBwcmVmaXg6IHAsXG4gICAgICAgICAgICB1cmk6IHRhZy5uc1twXVxuICAgICAgICAgIH0pXG4gICAgICAgIH0pXG4gICAgICB9XG5cbiAgICAgIC8vIGhhbmRsZSBkZWZlcnJlZCBvbmF0dHJpYnV0ZSBldmVudHNcbiAgICAgIC8vIE5vdGU6IGRvIG5vdCBhcHBseSBkZWZhdWx0IG5zIHRvIGF0dHJpYnV0ZXM6XG4gICAgICAvLyAgIGh0dHA6Ly93d3cudzMub3JnL1RSL1JFQy14bWwtbmFtZXMvI2RlZmF1bHRpbmdcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gcGFyc2VyLmF0dHJpYkxpc3QubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgIHZhciBudiA9IHBhcnNlci5hdHRyaWJMaXN0W2ldXG4gICAgICAgIHZhciBuYW1lID0gbnZbMF1cbiAgICAgICAgdmFyIHZhbHVlID0gbnZbMV1cbiAgICAgICAgdmFyIHF1YWxOYW1lID0gcW5hbWUobmFtZSwgdHJ1ZSlcbiAgICAgICAgdmFyIHByZWZpeCA9IHF1YWxOYW1lLnByZWZpeFxuICAgICAgICB2YXIgbG9jYWwgPSBxdWFsTmFtZS5sb2NhbFxuICAgICAgICB2YXIgdXJpID0gcHJlZml4ID09PSAnJyA/ICcnIDogKHRhZy5uc1twcmVmaXhdIHx8ICcnKVxuICAgICAgICB2YXIgYSA9IHtcbiAgICAgICAgICBuYW1lOiBuYW1lLFxuICAgICAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgICAgICBwcmVmaXg6IHByZWZpeCxcbiAgICAgICAgICBsb2NhbDogbG9jYWwsXG4gICAgICAgICAgdXJpOiB1cmlcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGlmIHRoZXJlJ3MgYW55IGF0dHJpYnV0ZXMgd2l0aCBhbiB1bmRlZmluZWQgbmFtZXNwYWNlLFxuICAgICAgICAvLyB0aGVuIGZhaWwgb24gdGhlbSBub3cuXG4gICAgICAgIGlmIChwcmVmaXggJiYgcHJlZml4ICE9PSAneG1sbnMnICYmICF1cmkpIHtcbiAgICAgICAgICBzdHJpY3RGYWlsKHBhcnNlciwgJ1VuYm91bmQgbmFtZXNwYWNlIHByZWZpeDogJyArXG4gICAgICAgICAgICBKU09OLnN0cmluZ2lmeShwcmVmaXgpKVxuICAgICAgICAgIGEudXJpID0gcHJlZml4XG4gICAgICAgIH1cbiAgICAgICAgcGFyc2VyLnRhZy5hdHRyaWJ1dGVzW25hbWVdID0gYVxuICAgICAgICBlbWl0Tm9kZShwYXJzZXIsICdvbmF0dHJpYnV0ZScsIGEpXG4gICAgICB9XG4gICAgICBwYXJzZXIuYXR0cmliTGlzdC5sZW5ndGggPSAwXG4gICAgfVxuXG4gICAgcGFyc2VyLnRhZy5pc1NlbGZDbG9zaW5nID0gISFzZWxmQ2xvc2luZ1xuXG4gICAgLy8gcHJvY2VzcyB0aGUgdGFnXG4gICAgcGFyc2VyLnNhd1Jvb3QgPSB0cnVlXG4gICAgcGFyc2VyLnRhZ3MucHVzaChwYXJzZXIudGFnKVxuICAgIGVtaXROb2RlKHBhcnNlciwgJ29ub3BlbnRhZycsIHBhcnNlci50YWcpXG4gICAgaWYgKCFzZWxmQ2xvc2luZykge1xuICAgICAgLy8gc3BlY2lhbCBjYXNlIGZvciA8c2NyaXB0PiBpbiBub24tc3RyaWN0IG1vZGUuXG4gICAgICBpZiAoIXBhcnNlci5ub3NjcmlwdCAmJiBwYXJzZXIudGFnTmFtZS50b0xvd2VyQ2FzZSgpID09PSAnc2NyaXB0Jykge1xuICAgICAgICBwYXJzZXIuc3RhdGUgPSBTLlNDUklQVFxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcGFyc2VyLnN0YXRlID0gUy5URVhUXG4gICAgICB9XG4gICAgICBwYXJzZXIudGFnID0gbnVsbFxuICAgICAgcGFyc2VyLnRhZ05hbWUgPSAnJ1xuICAgIH1cbiAgICBwYXJzZXIuYXR0cmliTmFtZSA9IHBhcnNlci5hdHRyaWJWYWx1ZSA9ICcnXG4gICAgcGFyc2VyLmF0dHJpYkxpc3QubGVuZ3RoID0gMFxuICB9XG5cbiAgZnVuY3Rpb24gY2xvc2VUYWcgKHBhcnNlcikge1xuICAgIGlmICghcGFyc2VyLnRhZ05hbWUpIHtcbiAgICAgIHN0cmljdEZhaWwocGFyc2VyLCAnV2VpcmQgZW1wdHkgY2xvc2UgdGFnLicpXG4gICAgICBwYXJzZXIudGV4dE5vZGUgKz0gJzwvPidcbiAgICAgIHBhcnNlci5zdGF0ZSA9IFMuVEVYVFxuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgaWYgKHBhcnNlci5zY3JpcHQpIHtcbiAgICAgIGlmIChwYXJzZXIudGFnTmFtZSAhPT0gJ3NjcmlwdCcpIHtcbiAgICAgICAgcGFyc2VyLnNjcmlwdCArPSAnPC8nICsgcGFyc2VyLnRhZ05hbWUgKyAnPidcbiAgICAgICAgcGFyc2VyLnRhZ05hbWUgPSAnJ1xuICAgICAgICBwYXJzZXIuc3RhdGUgPSBTLlNDUklQVFxuICAgICAgICByZXR1cm5cbiAgICAgIH1cbiAgICAgIGVtaXROb2RlKHBhcnNlciwgJ29uc2NyaXB0JywgcGFyc2VyLnNjcmlwdClcbiAgICAgIHBhcnNlci5zY3JpcHQgPSAnJ1xuICAgIH1cblxuICAgIC8vIGZpcnN0IG1ha2Ugc3VyZSB0aGF0IHRoZSBjbG9zaW5nIHRhZyBhY3R1YWxseSBleGlzdHMuXG4gICAgLy8gPGE+PGI+PC9jPjwvYj48L2E+IHdpbGwgY2xvc2UgZXZlcnl0aGluZywgb3RoZXJ3aXNlLlxuICAgIHZhciB0ID0gcGFyc2VyLnRhZ3MubGVuZ3RoXG4gICAgdmFyIHRhZ05hbWUgPSBwYXJzZXIudGFnTmFtZVxuICAgIGlmICghcGFyc2VyLnN0cmljdCkge1xuICAgICAgdGFnTmFtZSA9IHRhZ05hbWVbcGFyc2VyLmxvb3NlQ2FzZV0oKVxuICAgIH1cbiAgICB2YXIgY2xvc2VUbyA9IHRhZ05hbWVcbiAgICB3aGlsZSAodC0tKSB7XG4gICAgICB2YXIgY2xvc2UgPSBwYXJzZXIudGFnc1t0XVxuICAgICAgaWYgKGNsb3NlLm5hbWUgIT09IGNsb3NlVG8pIHtcbiAgICAgICAgLy8gZmFpbCB0aGUgZmlyc3QgdGltZSBpbiBzdHJpY3QgbW9kZVxuICAgICAgICBzdHJpY3RGYWlsKHBhcnNlciwgJ1VuZXhwZWN0ZWQgY2xvc2UgdGFnJylcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGJyZWFrXG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gZGlkbid0IGZpbmQgaXQuICB3ZSBhbHJlYWR5IGZhaWxlZCBmb3Igc3RyaWN0LCBzbyBqdXN0IGFib3J0LlxuICAgIGlmICh0IDwgMCkge1xuICAgICAgc3RyaWN0RmFpbChwYXJzZXIsICdVbm1hdGNoZWQgY2xvc2luZyB0YWc6ICcgKyBwYXJzZXIudGFnTmFtZSlcbiAgICAgIHBhcnNlci50ZXh0Tm9kZSArPSAnPC8nICsgcGFyc2VyLnRhZ05hbWUgKyAnPidcbiAgICAgIHBhcnNlci5zdGF0ZSA9IFMuVEVYVFxuICAgICAgcmV0dXJuXG4gICAgfVxuICAgIHBhcnNlci50YWdOYW1lID0gdGFnTmFtZVxuICAgIHZhciBzID0gcGFyc2VyLnRhZ3MubGVuZ3RoXG4gICAgd2hpbGUgKHMtLSA+IHQpIHtcbiAgICAgIHZhciB0YWcgPSBwYXJzZXIudGFnID0gcGFyc2VyLnRhZ3MucG9wKClcbiAgICAgIHBhcnNlci50YWdOYW1lID0gcGFyc2VyLnRhZy5uYW1lXG4gICAgICBlbWl0Tm9kZShwYXJzZXIsICdvbmNsb3NldGFnJywgcGFyc2VyLnRhZ05hbWUpXG5cbiAgICAgIHZhciB4ID0ge31cbiAgICAgIGZvciAodmFyIGkgaW4gdGFnLm5zKSB7XG4gICAgICAgIHhbaV0gPSB0YWcubnNbaV1cbiAgICAgIH1cblxuICAgICAgdmFyIHBhcmVudCA9IHBhcnNlci50YWdzW3BhcnNlci50YWdzLmxlbmd0aCAtIDFdIHx8IHBhcnNlclxuICAgICAgaWYgKHBhcnNlci5vcHQueG1sbnMgJiYgdGFnLm5zICE9PSBwYXJlbnQubnMpIHtcbiAgICAgICAgLy8gcmVtb3ZlIG5hbWVzcGFjZSBiaW5kaW5ncyBpbnRyb2R1Y2VkIGJ5IHRhZ1xuICAgICAgICBPYmplY3Qua2V5cyh0YWcubnMpLmZvckVhY2goZnVuY3Rpb24gKHApIHtcbiAgICAgICAgICB2YXIgbiA9IHRhZy5uc1twXVxuICAgICAgICAgIGVtaXROb2RlKHBhcnNlciwgJ29uY2xvc2VuYW1lc3BhY2UnLCB7IHByZWZpeDogcCwgdXJpOiBuIH0pXG4gICAgICAgIH0pXG4gICAgICB9XG4gICAgfVxuICAgIGlmICh0ID09PSAwKSBwYXJzZXIuY2xvc2VkUm9vdCA9IHRydWVcbiAgICBwYXJzZXIudGFnTmFtZSA9IHBhcnNlci5hdHRyaWJWYWx1ZSA9IHBhcnNlci5hdHRyaWJOYW1lID0gJydcbiAgICBwYXJzZXIuYXR0cmliTGlzdC5sZW5ndGggPSAwXG4gICAgcGFyc2VyLnN0YXRlID0gUy5URVhUXG4gIH1cblxuICBmdW5jdGlvbiBwYXJzZUVudGl0eSAocGFyc2VyKSB7XG4gICAgdmFyIGVudGl0eSA9IHBhcnNlci5lbnRpdHlcbiAgICB2YXIgZW50aXR5TEMgPSBlbnRpdHkudG9Mb3dlckNhc2UoKVxuICAgIHZhciBudW1cbiAgICB2YXIgbnVtU3RyID0gJydcblxuICAgIGlmIChwYXJzZXIuRU5USVRJRVNbZW50aXR5XSkge1xuICAgICAgcmV0dXJuIHBhcnNlci5FTlRJVElFU1tlbnRpdHldXG4gICAgfVxuICAgIGlmIChwYXJzZXIuRU5USVRJRVNbZW50aXR5TENdKSB7XG4gICAgICByZXR1cm4gcGFyc2VyLkVOVElUSUVTW2VudGl0eUxDXVxuICAgIH1cbiAgICBlbnRpdHkgPSBlbnRpdHlMQ1xuICAgIGlmIChlbnRpdHkuY2hhckF0KDApID09PSAnIycpIHtcbiAgICAgIGlmIChlbnRpdHkuY2hhckF0KDEpID09PSAneCcpIHtcbiAgICAgICAgZW50aXR5ID0gZW50aXR5LnNsaWNlKDIpXG4gICAgICAgIG51bSA9IHBhcnNlSW50KGVudGl0eSwgMTYpXG4gICAgICAgIG51bVN0ciA9IG51bS50b1N0cmluZygxNilcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGVudGl0eSA9IGVudGl0eS5zbGljZSgxKVxuICAgICAgICBudW0gPSBwYXJzZUludChlbnRpdHksIDEwKVxuICAgICAgICBudW1TdHIgPSBudW0udG9TdHJpbmcoMTApXG4gICAgICB9XG4gICAgfVxuICAgIGVudGl0eSA9IGVudGl0eS5yZXBsYWNlKC9eMCsvLCAnJylcbiAgICBpZiAoaXNOYU4obnVtKSB8fCBudW1TdHIudG9Mb3dlckNhc2UoKSAhPT0gZW50aXR5KSB7XG4gICAgICBzdHJpY3RGYWlsKHBhcnNlciwgJ0ludmFsaWQgY2hhcmFjdGVyIGVudGl0eScpXG4gICAgICByZXR1cm4gJyYnICsgcGFyc2VyLmVudGl0eSArICc7J1xuICAgIH1cblxuICAgIHJldHVybiBTdHJpbmcuZnJvbUNvZGVQb2ludChudW0pXG4gIH1cblxuICBmdW5jdGlvbiBiZWdpbldoaXRlU3BhY2UgKHBhcnNlciwgYykge1xuICAgIGlmIChjID09PSAnPCcpIHtcbiAgICAgIHBhcnNlci5zdGF0ZSA9IFMuT1BFTl9XQUtBXG4gICAgICBwYXJzZXIuc3RhcnRUYWdQb3NpdGlvbiA9IHBhcnNlci5wb3NpdGlvblxuICAgIH0gZWxzZSBpZiAoIWlzV2hpdGVzcGFjZShjKSkge1xuICAgICAgLy8gaGF2ZSB0byBwcm9jZXNzIHRoaXMgYXMgYSB0ZXh0IG5vZGUuXG4gICAgICAvLyB3ZWlyZCwgYnV0IGhhcHBlbnMuXG4gICAgICBzdHJpY3RGYWlsKHBhcnNlciwgJ05vbi13aGl0ZXNwYWNlIGJlZm9yZSBmaXJzdCB0YWcuJylcbiAgICAgIHBhcnNlci50ZXh0Tm9kZSA9IGNcbiAgICAgIHBhcnNlci5zdGF0ZSA9IFMuVEVYVFxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGNoYXJBdCAoY2h1bmssIGkpIHtcbiAgICB2YXIgcmVzdWx0ID0gJydcbiAgICBpZiAoaSA8IGNodW5rLmxlbmd0aCkge1xuICAgICAgcmVzdWx0ID0gY2h1bmsuY2hhckF0KGkpXG4gICAgfVxuICAgIHJldHVybiByZXN1bHRcbiAgfVxuXG4gIGZ1bmN0aW9uIHdyaXRlIChjaHVuaykge1xuICAgIHZhciBwYXJzZXIgPSB0aGlzXG4gICAgaWYgKHRoaXMuZXJyb3IpIHtcbiAgICAgIHRocm93IHRoaXMuZXJyb3JcbiAgICB9XG4gICAgaWYgKHBhcnNlci5jbG9zZWQpIHtcbiAgICAgIHJldHVybiBlcnJvcihwYXJzZXIsXG4gICAgICAgICdDYW5ub3Qgd3JpdGUgYWZ0ZXIgY2xvc2UuIEFzc2lnbiBhbiBvbnJlYWR5IGhhbmRsZXIuJylcbiAgICB9XG4gICAgaWYgKGNodW5rID09PSBudWxsKSB7XG4gICAgICByZXR1cm4gZW5kKHBhcnNlcilcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBjaHVuayA9PT0gJ29iamVjdCcpIHtcbiAgICAgIGNodW5rID0gY2h1bmsudG9TdHJpbmcoKVxuICAgIH1cbiAgICB2YXIgaSA9IDBcbiAgICB2YXIgYyA9ICcnXG4gICAgd2hpbGUgKHRydWUpIHtcbiAgICAgIGMgPSBjaGFyQXQoY2h1bmssIGkrKylcbiAgICAgIHBhcnNlci5jID0gY1xuXG4gICAgICBpZiAoIWMpIHtcbiAgICAgICAgYnJlYWtcbiAgICAgIH1cblxuICAgICAgaWYgKHBhcnNlci50cmFja1Bvc2l0aW9uKSB7XG4gICAgICAgIHBhcnNlci5wb3NpdGlvbisrXG4gICAgICAgIGlmIChjID09PSAnXFxuJykge1xuICAgICAgICAgIHBhcnNlci5saW5lKytcbiAgICAgICAgICBwYXJzZXIuY29sdW1uID0gMFxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHBhcnNlci5jb2x1bW4rK1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHN3aXRjaCAocGFyc2VyLnN0YXRlKSB7XG4gICAgICAgIGNhc2UgUy5CRUdJTjpcbiAgICAgICAgICBwYXJzZXIuc3RhdGUgPSBTLkJFR0lOX1dISVRFU1BBQ0VcbiAgICAgICAgICBpZiAoYyA9PT0gJ1xcdUZFRkYnKSB7XG4gICAgICAgICAgICBjb250aW51ZVxuICAgICAgICAgIH1cbiAgICAgICAgICBiZWdpbldoaXRlU3BhY2UocGFyc2VyLCBjKVxuICAgICAgICAgIGNvbnRpbnVlXG5cbiAgICAgICAgY2FzZSBTLkJFR0lOX1dISVRFU1BBQ0U6XG4gICAgICAgICAgYmVnaW5XaGl0ZVNwYWNlKHBhcnNlciwgYylcbiAgICAgICAgICBjb250aW51ZVxuXG4gICAgICAgIGNhc2UgUy5URVhUOlxuICAgICAgICAgIGlmIChwYXJzZXIuc2F3Um9vdCAmJiAhcGFyc2VyLmNsb3NlZFJvb3QpIHtcbiAgICAgICAgICAgIHZhciBzdGFydGkgPSBpIC0gMVxuICAgICAgICAgICAgd2hpbGUgKGMgJiYgYyAhPT0gJzwnICYmIGMgIT09ICcmJykge1xuICAgICAgICAgICAgICBjID0gY2hhckF0KGNodW5rLCBpKyspXG4gICAgICAgICAgICAgIGlmIChjICYmIHBhcnNlci50cmFja1Bvc2l0aW9uKSB7XG4gICAgICAgICAgICAgICAgcGFyc2VyLnBvc2l0aW9uKytcbiAgICAgICAgICAgICAgICBpZiAoYyA9PT0gJ1xcbicpIHtcbiAgICAgICAgICAgICAgICAgIHBhcnNlci5saW5lKytcbiAgICAgICAgICAgICAgICAgIHBhcnNlci5jb2x1bW4gPSAwXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIHBhcnNlci5jb2x1bW4rK1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcGFyc2VyLnRleHROb2RlICs9IGNodW5rLnN1YnN0cmluZyhzdGFydGksIGkgLSAxKVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoYyA9PT0gJzwnICYmICEocGFyc2VyLnNhd1Jvb3QgJiYgcGFyc2VyLmNsb3NlZFJvb3QgJiYgIXBhcnNlci5zdHJpY3QpKSB7XG4gICAgICAgICAgICBwYXJzZXIuc3RhdGUgPSBTLk9QRU5fV0FLQVxuICAgICAgICAgICAgcGFyc2VyLnN0YXJ0VGFnUG9zaXRpb24gPSBwYXJzZXIucG9zaXRpb25cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKCFpc1doaXRlc3BhY2UoYykgJiYgKCFwYXJzZXIuc2F3Um9vdCB8fCBwYXJzZXIuY2xvc2VkUm9vdCkpIHtcbiAgICAgICAgICAgICAgc3RyaWN0RmFpbChwYXJzZXIsICdUZXh0IGRhdGEgb3V0c2lkZSBvZiByb290IG5vZGUuJylcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjID09PSAnJicpIHtcbiAgICAgICAgICAgICAgcGFyc2VyLnN0YXRlID0gUy5URVhUX0VOVElUWVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgcGFyc2VyLnRleHROb2RlICs9IGNcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgY29udGludWVcblxuICAgICAgICBjYXNlIFMuU0NSSVBUOlxuICAgICAgICAgIC8vIG9ubHkgbm9uLXN0cmljdFxuICAgICAgICAgIGlmIChjID09PSAnPCcpIHtcbiAgICAgICAgICAgIHBhcnNlci5zdGF0ZSA9IFMuU0NSSVBUX0VORElOR1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBwYXJzZXIuc2NyaXB0ICs9IGNcbiAgICAgICAgICB9XG4gICAgICAgICAgY29udGludWVcblxuICAgICAgICBjYXNlIFMuU0NSSVBUX0VORElORzpcbiAgICAgICAgICBpZiAoYyA9PT0gJy8nKSB7XG4gICAgICAgICAgICBwYXJzZXIuc3RhdGUgPSBTLkNMT1NFX1RBR1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBwYXJzZXIuc2NyaXB0ICs9ICc8JyArIGNcbiAgICAgICAgICAgIHBhcnNlci5zdGF0ZSA9IFMuU0NSSVBUXG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnRpbnVlXG5cbiAgICAgICAgY2FzZSBTLk9QRU5fV0FLQTpcbiAgICAgICAgICAvLyBlaXRoZXIgYSAvLCA/LCAhLCBvciB0ZXh0IGlzIGNvbWluZyBuZXh0LlxuICAgICAgICAgIGlmIChjID09PSAnIScpIHtcbiAgICAgICAgICAgIHBhcnNlci5zdGF0ZSA9IFMuU0dNTF9ERUNMXG4gICAgICAgICAgICBwYXJzZXIuc2dtbERlY2wgPSAnJ1xuICAgICAgICAgIH0gZWxzZSBpZiAoaXNXaGl0ZXNwYWNlKGMpKSB7XG4gICAgICAgICAgICAvLyB3YWl0IGZvciBpdC4uLlxuICAgICAgICAgIH0gZWxzZSBpZiAoaXNNYXRjaChuYW1lU3RhcnQsIGMpKSB7XG4gICAgICAgICAgICBwYXJzZXIuc3RhdGUgPSBTLk9QRU5fVEFHXG4gICAgICAgICAgICBwYXJzZXIudGFnTmFtZSA9IGNcbiAgICAgICAgICB9IGVsc2UgaWYgKGMgPT09ICcvJykge1xuICAgICAgICAgICAgcGFyc2VyLnN0YXRlID0gUy5DTE9TRV9UQUdcbiAgICAgICAgICAgIHBhcnNlci50YWdOYW1lID0gJydcbiAgICAgICAgICB9IGVsc2UgaWYgKGMgPT09ICc/Jykge1xuICAgICAgICAgICAgcGFyc2VyLnN0YXRlID0gUy5QUk9DX0lOU1RcbiAgICAgICAgICAgIHBhcnNlci5wcm9jSW5zdE5hbWUgPSBwYXJzZXIucHJvY0luc3RCb2R5ID0gJydcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc3RyaWN0RmFpbChwYXJzZXIsICdVbmVuY29kZWQgPCcpXG4gICAgICAgICAgICAvLyBpZiB0aGVyZSB3YXMgc29tZSB3aGl0ZXNwYWNlLCB0aGVuIGFkZCB0aGF0IGluLlxuICAgICAgICAgICAgaWYgKHBhcnNlci5zdGFydFRhZ1Bvc2l0aW9uICsgMSA8IHBhcnNlci5wb3NpdGlvbikge1xuICAgICAgICAgICAgICB2YXIgcGFkID0gcGFyc2VyLnBvc2l0aW9uIC0gcGFyc2VyLnN0YXJ0VGFnUG9zaXRpb25cbiAgICAgICAgICAgICAgYyA9IG5ldyBBcnJheShwYWQpLmpvaW4oJyAnKSArIGNcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHBhcnNlci50ZXh0Tm9kZSArPSAnPCcgKyBjXG4gICAgICAgICAgICBwYXJzZXIuc3RhdGUgPSBTLlRFWFRcbiAgICAgICAgICB9XG4gICAgICAgICAgY29udGludWVcblxuICAgICAgICBjYXNlIFMuU0dNTF9ERUNMOlxuICAgICAgICAgIGlmICgocGFyc2VyLnNnbWxEZWNsICsgYykudG9VcHBlckNhc2UoKSA9PT0gQ0RBVEEpIHtcbiAgICAgICAgICAgIGVtaXROb2RlKHBhcnNlciwgJ29ub3BlbmNkYXRhJylcbiAgICAgICAgICAgIHBhcnNlci5zdGF0ZSA9IFMuQ0RBVEFcbiAgICAgICAgICAgIHBhcnNlci5zZ21sRGVjbCA9ICcnXG4gICAgICAgICAgICBwYXJzZXIuY2RhdGEgPSAnJ1xuICAgICAgICAgIH0gZWxzZSBpZiAocGFyc2VyLnNnbWxEZWNsICsgYyA9PT0gJy0tJykge1xuICAgICAgICAgICAgcGFyc2VyLnN0YXRlID0gUy5DT01NRU5UXG4gICAgICAgICAgICBwYXJzZXIuY29tbWVudCA9ICcnXG4gICAgICAgICAgICBwYXJzZXIuc2dtbERlY2wgPSAnJ1xuICAgICAgICAgIH0gZWxzZSBpZiAoKHBhcnNlci5zZ21sRGVjbCArIGMpLnRvVXBwZXJDYXNlKCkgPT09IERPQ1RZUEUpIHtcbiAgICAgICAgICAgIHBhcnNlci5zdGF0ZSA9IFMuRE9DVFlQRVxuICAgICAgICAgICAgaWYgKHBhcnNlci5kb2N0eXBlIHx8IHBhcnNlci5zYXdSb290KSB7XG4gICAgICAgICAgICAgIHN0cmljdEZhaWwocGFyc2VyLFxuICAgICAgICAgICAgICAgICdJbmFwcHJvcHJpYXRlbHkgbG9jYXRlZCBkb2N0eXBlIGRlY2xhcmF0aW9uJylcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHBhcnNlci5kb2N0eXBlID0gJydcbiAgICAgICAgICAgIHBhcnNlci5zZ21sRGVjbCA9ICcnXG4gICAgICAgICAgfSBlbHNlIGlmIChjID09PSAnPicpIHtcbiAgICAgICAgICAgIGVtaXROb2RlKHBhcnNlciwgJ29uc2dtbGRlY2xhcmF0aW9uJywgcGFyc2VyLnNnbWxEZWNsKVxuICAgICAgICAgICAgcGFyc2VyLnNnbWxEZWNsID0gJydcbiAgICAgICAgICAgIHBhcnNlci5zdGF0ZSA9IFMuVEVYVFxuICAgICAgICAgIH0gZWxzZSBpZiAoaXNRdW90ZShjKSkge1xuICAgICAgICAgICAgcGFyc2VyLnN0YXRlID0gUy5TR01MX0RFQ0xfUVVPVEVEXG4gICAgICAgICAgICBwYXJzZXIuc2dtbERlY2wgKz0gY1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBwYXJzZXIuc2dtbERlY2wgKz0gY1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb250aW51ZVxuXG4gICAgICAgIGNhc2UgUy5TR01MX0RFQ0xfUVVPVEVEOlxuICAgICAgICAgIGlmIChjID09PSBwYXJzZXIucSkge1xuICAgICAgICAgICAgcGFyc2VyLnN0YXRlID0gUy5TR01MX0RFQ0xcbiAgICAgICAgICAgIHBhcnNlci5xID0gJydcbiAgICAgICAgICB9XG4gICAgICAgICAgcGFyc2VyLnNnbWxEZWNsICs9IGNcbiAgICAgICAgICBjb250aW51ZVxuXG4gICAgICAgIGNhc2UgUy5ET0NUWVBFOlxuICAgICAgICAgIGlmIChjID09PSAnPicpIHtcbiAgICAgICAgICAgIHBhcnNlci5zdGF0ZSA9IFMuVEVYVFxuICAgICAgICAgICAgZW1pdE5vZGUocGFyc2VyLCAnb25kb2N0eXBlJywgcGFyc2VyLmRvY3R5cGUpXG4gICAgICAgICAgICBwYXJzZXIuZG9jdHlwZSA9IHRydWUgLy8ganVzdCByZW1lbWJlciB0aGF0IHdlIHNhdyBpdC5cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcGFyc2VyLmRvY3R5cGUgKz0gY1xuICAgICAgICAgICAgaWYgKGMgPT09ICdbJykge1xuICAgICAgICAgICAgICBwYXJzZXIuc3RhdGUgPSBTLkRPQ1RZUEVfRFREXG4gICAgICAgICAgICB9IGVsc2UgaWYgKGlzUXVvdGUoYykpIHtcbiAgICAgICAgICAgICAgcGFyc2VyLnN0YXRlID0gUy5ET0NUWVBFX1FVT1RFRFxuICAgICAgICAgICAgICBwYXJzZXIucSA9IGNcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgY29udGludWVcblxuICAgICAgICBjYXNlIFMuRE9DVFlQRV9RVU9URUQ6XG4gICAgICAgICAgcGFyc2VyLmRvY3R5cGUgKz0gY1xuICAgICAgICAgIGlmIChjID09PSBwYXJzZXIucSkge1xuICAgICAgICAgICAgcGFyc2VyLnEgPSAnJ1xuICAgICAgICAgICAgcGFyc2VyLnN0YXRlID0gUy5ET0NUWVBFXG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnRpbnVlXG5cbiAgICAgICAgY2FzZSBTLkRPQ1RZUEVfRFREOlxuICAgICAgICAgIHBhcnNlci5kb2N0eXBlICs9IGNcbiAgICAgICAgICBpZiAoYyA9PT0gJ10nKSB7XG4gICAgICAgICAgICBwYXJzZXIuc3RhdGUgPSBTLkRPQ1RZUEVcbiAgICAgICAgICB9IGVsc2UgaWYgKGlzUXVvdGUoYykpIHtcbiAgICAgICAgICAgIHBhcnNlci5zdGF0ZSA9IFMuRE9DVFlQRV9EVERfUVVPVEVEXG4gICAgICAgICAgICBwYXJzZXIucSA9IGNcbiAgICAgICAgICB9XG4gICAgICAgICAgY29udGludWVcblxuICAgICAgICBjYXNlIFMuRE9DVFlQRV9EVERfUVVPVEVEOlxuICAgICAgICAgIHBhcnNlci5kb2N0eXBlICs9IGNcbiAgICAgICAgICBpZiAoYyA9PT0gcGFyc2VyLnEpIHtcbiAgICAgICAgICAgIHBhcnNlci5zdGF0ZSA9IFMuRE9DVFlQRV9EVERcbiAgICAgICAgICAgIHBhcnNlci5xID0gJydcbiAgICAgICAgICB9XG4gICAgICAgICAgY29udGludWVcblxuICAgICAgICBjYXNlIFMuQ09NTUVOVDpcbiAgICAgICAgICBpZiAoYyA9PT0gJy0nKSB7XG4gICAgICAgICAgICBwYXJzZXIuc3RhdGUgPSBTLkNPTU1FTlRfRU5ESU5HXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHBhcnNlci5jb21tZW50ICs9IGNcbiAgICAgICAgICB9XG4gICAgICAgICAgY29udGludWVcblxuICAgICAgICBjYXNlIFMuQ09NTUVOVF9FTkRJTkc6XG4gICAgICAgICAgaWYgKGMgPT09ICctJykge1xuICAgICAgICAgICAgcGFyc2VyLnN0YXRlID0gUy5DT01NRU5UX0VOREVEXG4gICAgICAgICAgICBwYXJzZXIuY29tbWVudCA9IHRleHRvcHRzKHBhcnNlci5vcHQsIHBhcnNlci5jb21tZW50KVxuICAgICAgICAgICAgaWYgKHBhcnNlci5jb21tZW50KSB7XG4gICAgICAgICAgICAgIGVtaXROb2RlKHBhcnNlciwgJ29uY29tbWVudCcsIHBhcnNlci5jb21tZW50KVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcGFyc2VyLmNvbW1lbnQgPSAnJ1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBwYXJzZXIuY29tbWVudCArPSAnLScgKyBjXG4gICAgICAgICAgICBwYXJzZXIuc3RhdGUgPSBTLkNPTU1FTlRcbiAgICAgICAgICB9XG4gICAgICAgICAgY29udGludWVcblxuICAgICAgICBjYXNlIFMuQ09NTUVOVF9FTkRFRDpcbiAgICAgICAgICBpZiAoYyAhPT0gJz4nKSB7XG4gICAgICAgICAgICBzdHJpY3RGYWlsKHBhcnNlciwgJ01hbGZvcm1lZCBjb21tZW50JylcbiAgICAgICAgICAgIC8vIGFsbG93IDwhLS0gYmxhaCAtLSBibG9vIC0tPiBpbiBub24tc3RyaWN0IG1vZGUsXG4gICAgICAgICAgICAvLyB3aGljaCBpcyBhIGNvbW1lbnQgb2YgXCIgYmxhaCAtLSBibG9vIFwiXG4gICAgICAgICAgICBwYXJzZXIuY29tbWVudCArPSAnLS0nICsgY1xuICAgICAgICAgICAgcGFyc2VyLnN0YXRlID0gUy5DT01NRU5UXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHBhcnNlci5zdGF0ZSA9IFMuVEVYVFxuICAgICAgICAgIH1cbiAgICAgICAgICBjb250aW51ZVxuXG4gICAgICAgIGNhc2UgUy5DREFUQTpcbiAgICAgICAgICBpZiAoYyA9PT0gJ10nKSB7XG4gICAgICAgICAgICBwYXJzZXIuc3RhdGUgPSBTLkNEQVRBX0VORElOR1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBwYXJzZXIuY2RhdGEgKz0gY1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb250aW51ZVxuXG4gICAgICAgIGNhc2UgUy5DREFUQV9FTkRJTkc6XG4gICAgICAgICAgaWYgKGMgPT09ICddJykge1xuICAgICAgICAgICAgcGFyc2VyLnN0YXRlID0gUy5DREFUQV9FTkRJTkdfMlxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBwYXJzZXIuY2RhdGEgKz0gJ10nICsgY1xuICAgICAgICAgICAgcGFyc2VyLnN0YXRlID0gUy5DREFUQVxuICAgICAgICAgIH1cbiAgICAgICAgICBjb250aW51ZVxuXG4gICAgICAgIGNhc2UgUy5DREFUQV9FTkRJTkdfMjpcbiAgICAgICAgICBpZiAoYyA9PT0gJz4nKSB7XG4gICAgICAgICAgICBpZiAocGFyc2VyLmNkYXRhKSB7XG4gICAgICAgICAgICAgIGVtaXROb2RlKHBhcnNlciwgJ29uY2RhdGEnLCBwYXJzZXIuY2RhdGEpXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbWl0Tm9kZShwYXJzZXIsICdvbmNsb3NlY2RhdGEnKVxuICAgICAgICAgICAgcGFyc2VyLmNkYXRhID0gJydcbiAgICAgICAgICAgIHBhcnNlci5zdGF0ZSA9IFMuVEVYVFxuICAgICAgICAgIH0gZWxzZSBpZiAoYyA9PT0gJ10nKSB7XG4gICAgICAgICAgICBwYXJzZXIuY2RhdGEgKz0gJ10nXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHBhcnNlci5jZGF0YSArPSAnXV0nICsgY1xuICAgICAgICAgICAgcGFyc2VyLnN0YXRlID0gUy5DREFUQVxuICAgICAgICAgIH1cbiAgICAgICAgICBjb250aW51ZVxuXG4gICAgICAgIGNhc2UgUy5QUk9DX0lOU1Q6XG4gICAgICAgICAgaWYgKGMgPT09ICc/Jykge1xuICAgICAgICAgICAgcGFyc2VyLnN0YXRlID0gUy5QUk9DX0lOU1RfRU5ESU5HXG4gICAgICAgICAgfSBlbHNlIGlmIChpc1doaXRlc3BhY2UoYykpIHtcbiAgICAgICAgICAgIHBhcnNlci5zdGF0ZSA9IFMuUFJPQ19JTlNUX0JPRFlcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcGFyc2VyLnByb2NJbnN0TmFtZSArPSBjXG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnRpbnVlXG5cbiAgICAgICAgY2FzZSBTLlBST0NfSU5TVF9CT0RZOlxuICAgICAgICAgIGlmICghcGFyc2VyLnByb2NJbnN0Qm9keSAmJiBpc1doaXRlc3BhY2UoYykpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgICAgfSBlbHNlIGlmIChjID09PSAnPycpIHtcbiAgICAgICAgICAgIHBhcnNlci5zdGF0ZSA9IFMuUFJPQ19JTlNUX0VORElOR1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBwYXJzZXIucHJvY0luc3RCb2R5ICs9IGNcbiAgICAgICAgICB9XG4gICAgICAgICAgY29udGludWVcblxuICAgICAgICBjYXNlIFMuUFJPQ19JTlNUX0VORElORzpcbiAgICAgICAgICBpZiAoYyA9PT0gJz4nKSB7XG4gICAgICAgICAgICBlbWl0Tm9kZShwYXJzZXIsICdvbnByb2Nlc3NpbmdpbnN0cnVjdGlvbicsIHtcbiAgICAgICAgICAgICAgbmFtZTogcGFyc2VyLnByb2NJbnN0TmFtZSxcbiAgICAgICAgICAgICAgYm9keTogcGFyc2VyLnByb2NJbnN0Qm9keVxuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIHBhcnNlci5wcm9jSW5zdE5hbWUgPSBwYXJzZXIucHJvY0luc3RCb2R5ID0gJydcbiAgICAgICAgICAgIHBhcnNlci5zdGF0ZSA9IFMuVEVYVFxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBwYXJzZXIucHJvY0luc3RCb2R5ICs9ICc/JyArIGNcbiAgICAgICAgICAgIHBhcnNlci5zdGF0ZSA9IFMuUFJPQ19JTlNUX0JPRFlcbiAgICAgICAgICB9XG4gICAgICAgICAgY29udGludWVcblxuICAgICAgICBjYXNlIFMuT1BFTl9UQUc6XG4gICAgICAgICAgaWYgKGlzTWF0Y2gobmFtZUJvZHksIGMpKSB7XG4gICAgICAgICAgICBwYXJzZXIudGFnTmFtZSArPSBjXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG5ld1RhZyhwYXJzZXIpXG4gICAgICAgICAgICBpZiAoYyA9PT0gJz4nKSB7XG4gICAgICAgICAgICAgIG9wZW5UYWcocGFyc2VyKVxuICAgICAgICAgICAgfSBlbHNlIGlmIChjID09PSAnLycpIHtcbiAgICAgICAgICAgICAgcGFyc2VyLnN0YXRlID0gUy5PUEVOX1RBR19TTEFTSFxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgaWYgKCFpc1doaXRlc3BhY2UoYykpIHtcbiAgICAgICAgICAgICAgICBzdHJpY3RGYWlsKHBhcnNlciwgJ0ludmFsaWQgY2hhcmFjdGVyIGluIHRhZyBuYW1lJylcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBwYXJzZXIuc3RhdGUgPSBTLkFUVFJJQlxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBjb250aW51ZVxuXG4gICAgICAgIGNhc2UgUy5PUEVOX1RBR19TTEFTSDpcbiAgICAgICAgICBpZiAoYyA9PT0gJz4nKSB7XG4gICAgICAgICAgICBvcGVuVGFnKHBhcnNlciwgdHJ1ZSlcbiAgICAgICAgICAgIGNsb3NlVGFnKHBhcnNlcilcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc3RyaWN0RmFpbChwYXJzZXIsICdGb3J3YXJkLXNsYXNoIGluIG9wZW5pbmcgdGFnIG5vdCBmb2xsb3dlZCBieSA+JylcbiAgICAgICAgICAgIHBhcnNlci5zdGF0ZSA9IFMuQVRUUklCXG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnRpbnVlXG5cbiAgICAgICAgY2FzZSBTLkFUVFJJQjpcbiAgICAgICAgICAvLyBoYXZlbid0IHJlYWQgdGhlIGF0dHJpYnV0ZSBuYW1lIHlldC5cbiAgICAgICAgICBpZiAoaXNXaGl0ZXNwYWNlKGMpKSB7XG4gICAgICAgICAgICBjb250aW51ZVxuICAgICAgICAgIH0gZWxzZSBpZiAoYyA9PT0gJz4nKSB7XG4gICAgICAgICAgICBvcGVuVGFnKHBhcnNlcilcbiAgICAgICAgICB9IGVsc2UgaWYgKGMgPT09ICcvJykge1xuICAgICAgICAgICAgcGFyc2VyLnN0YXRlID0gUy5PUEVOX1RBR19TTEFTSFxuICAgICAgICAgIH0gZWxzZSBpZiAoaXNNYXRjaChuYW1lU3RhcnQsIGMpKSB7XG4gICAgICAgICAgICBwYXJzZXIuYXR0cmliTmFtZSA9IGNcbiAgICAgICAgICAgIHBhcnNlci5hdHRyaWJWYWx1ZSA9ICcnXG4gICAgICAgICAgICBwYXJzZXIuc3RhdGUgPSBTLkFUVFJJQl9OQU1FXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHN0cmljdEZhaWwocGFyc2VyLCAnSW52YWxpZCBhdHRyaWJ1dGUgbmFtZScpXG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnRpbnVlXG5cbiAgICAgICAgY2FzZSBTLkFUVFJJQl9OQU1FOlxuICAgICAgICAgIGlmIChjID09PSAnPScpIHtcbiAgICAgICAgICAgIHBhcnNlci5zdGF0ZSA9IFMuQVRUUklCX1ZBTFVFXG4gICAgICAgICAgfSBlbHNlIGlmIChjID09PSAnPicpIHtcbiAgICAgICAgICAgIHN0cmljdEZhaWwocGFyc2VyLCAnQXR0cmlidXRlIHdpdGhvdXQgdmFsdWUnKVxuICAgICAgICAgICAgcGFyc2VyLmF0dHJpYlZhbHVlID0gcGFyc2VyLmF0dHJpYk5hbWVcbiAgICAgICAgICAgIGF0dHJpYihwYXJzZXIpXG4gICAgICAgICAgICBvcGVuVGFnKHBhcnNlcilcbiAgICAgICAgICB9IGVsc2UgaWYgKGlzV2hpdGVzcGFjZShjKSkge1xuICAgICAgICAgICAgcGFyc2VyLnN0YXRlID0gUy5BVFRSSUJfTkFNRV9TQVdfV0hJVEVcbiAgICAgICAgICB9IGVsc2UgaWYgKGlzTWF0Y2gobmFtZUJvZHksIGMpKSB7XG4gICAgICAgICAgICBwYXJzZXIuYXR0cmliTmFtZSArPSBjXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHN0cmljdEZhaWwocGFyc2VyLCAnSW52YWxpZCBhdHRyaWJ1dGUgbmFtZScpXG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnRpbnVlXG5cbiAgICAgICAgY2FzZSBTLkFUVFJJQl9OQU1FX1NBV19XSElURTpcbiAgICAgICAgICBpZiAoYyA9PT0gJz0nKSB7XG4gICAgICAgICAgICBwYXJzZXIuc3RhdGUgPSBTLkFUVFJJQl9WQUxVRVxuICAgICAgICAgIH0gZWxzZSBpZiAoaXNXaGl0ZXNwYWNlKGMpKSB7XG4gICAgICAgICAgICBjb250aW51ZVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzdHJpY3RGYWlsKHBhcnNlciwgJ0F0dHJpYnV0ZSB3aXRob3V0IHZhbHVlJylcbiAgICAgICAgICAgIHBhcnNlci50YWcuYXR0cmlidXRlc1twYXJzZXIuYXR0cmliTmFtZV0gPSAnJ1xuICAgICAgICAgICAgcGFyc2VyLmF0dHJpYlZhbHVlID0gJydcbiAgICAgICAgICAgIGVtaXROb2RlKHBhcnNlciwgJ29uYXR0cmlidXRlJywge1xuICAgICAgICAgICAgICBuYW1lOiBwYXJzZXIuYXR0cmliTmFtZSxcbiAgICAgICAgICAgICAgdmFsdWU6ICcnXG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgcGFyc2VyLmF0dHJpYk5hbWUgPSAnJ1xuICAgICAgICAgICAgaWYgKGMgPT09ICc+Jykge1xuICAgICAgICAgICAgICBvcGVuVGFnKHBhcnNlcilcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoaXNNYXRjaChuYW1lU3RhcnQsIGMpKSB7XG4gICAgICAgICAgICAgIHBhcnNlci5hdHRyaWJOYW1lID0gY1xuICAgICAgICAgICAgICBwYXJzZXIuc3RhdGUgPSBTLkFUVFJJQl9OQU1FXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBzdHJpY3RGYWlsKHBhcnNlciwgJ0ludmFsaWQgYXR0cmlidXRlIG5hbWUnKVxuICAgICAgICAgICAgICBwYXJzZXIuc3RhdGUgPSBTLkFUVFJJQlxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBjb250aW51ZVxuXG4gICAgICAgIGNhc2UgUy5BVFRSSUJfVkFMVUU6XG4gICAgICAgICAgaWYgKGlzV2hpdGVzcGFjZShjKSkge1xuICAgICAgICAgICAgY29udGludWVcbiAgICAgICAgICB9IGVsc2UgaWYgKGlzUXVvdGUoYykpIHtcbiAgICAgICAgICAgIHBhcnNlci5xID0gY1xuICAgICAgICAgICAgcGFyc2VyLnN0YXRlID0gUy5BVFRSSUJfVkFMVUVfUVVPVEVEXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHN0cmljdEZhaWwocGFyc2VyLCAnVW5xdW90ZWQgYXR0cmlidXRlIHZhbHVlJylcbiAgICAgICAgICAgIHBhcnNlci5zdGF0ZSA9IFMuQVRUUklCX1ZBTFVFX1VOUVVPVEVEXG4gICAgICAgICAgICBwYXJzZXIuYXR0cmliVmFsdWUgPSBjXG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnRpbnVlXG5cbiAgICAgICAgY2FzZSBTLkFUVFJJQl9WQUxVRV9RVU9URUQ6XG4gICAgICAgICAgaWYgKGMgIT09IHBhcnNlci5xKSB7XG4gICAgICAgICAgICBpZiAoYyA9PT0gJyYnKSB7XG4gICAgICAgICAgICAgIHBhcnNlci5zdGF0ZSA9IFMuQVRUUklCX1ZBTFVFX0VOVElUWV9RXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBwYXJzZXIuYXR0cmliVmFsdWUgKz0gY1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29udGludWVcbiAgICAgICAgICB9XG4gICAgICAgICAgYXR0cmliKHBhcnNlcilcbiAgICAgICAgICBwYXJzZXIucSA9ICcnXG4gICAgICAgICAgcGFyc2VyLnN0YXRlID0gUy5BVFRSSUJfVkFMVUVfQ0xPU0VEXG4gICAgICAgICAgY29udGludWVcblxuICAgICAgICBjYXNlIFMuQVRUUklCX1ZBTFVFX0NMT1NFRDpcbiAgICAgICAgICBpZiAoaXNXaGl0ZXNwYWNlKGMpKSB7XG4gICAgICAgICAgICBwYXJzZXIuc3RhdGUgPSBTLkFUVFJJQlxuICAgICAgICAgIH0gZWxzZSBpZiAoYyA9PT0gJz4nKSB7XG4gICAgICAgICAgICBvcGVuVGFnKHBhcnNlcilcbiAgICAgICAgICB9IGVsc2UgaWYgKGMgPT09ICcvJykge1xuICAgICAgICAgICAgcGFyc2VyLnN0YXRlID0gUy5PUEVOX1RBR19TTEFTSFxuICAgICAgICAgIH0gZWxzZSBpZiAoaXNNYXRjaChuYW1lU3RhcnQsIGMpKSB7XG4gICAgICAgICAgICBzdHJpY3RGYWlsKHBhcnNlciwgJ05vIHdoaXRlc3BhY2UgYmV0d2VlbiBhdHRyaWJ1dGVzJylcbiAgICAgICAgICAgIHBhcnNlci5hdHRyaWJOYW1lID0gY1xuICAgICAgICAgICAgcGFyc2VyLmF0dHJpYlZhbHVlID0gJydcbiAgICAgICAgICAgIHBhcnNlci5zdGF0ZSA9IFMuQVRUUklCX05BTUVcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc3RyaWN0RmFpbChwYXJzZXIsICdJbnZhbGlkIGF0dHJpYnV0ZSBuYW1lJylcbiAgICAgICAgICB9XG4gICAgICAgICAgY29udGludWVcblxuICAgICAgICBjYXNlIFMuQVRUUklCX1ZBTFVFX1VOUVVPVEVEOlxuICAgICAgICAgIGlmICghaXNBdHRyaWJFbmQoYykpIHtcbiAgICAgICAgICAgIGlmIChjID09PSAnJicpIHtcbiAgICAgICAgICAgICAgcGFyc2VyLnN0YXRlID0gUy5BVFRSSUJfVkFMVUVfRU5USVRZX1VcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHBhcnNlci5hdHRyaWJWYWx1ZSArPSBjXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb250aW51ZVxuICAgICAgICAgIH1cbiAgICAgICAgICBhdHRyaWIocGFyc2VyKVxuICAgICAgICAgIGlmIChjID09PSAnPicpIHtcbiAgICAgICAgICAgIG9wZW5UYWcocGFyc2VyKVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBwYXJzZXIuc3RhdGUgPSBTLkFUVFJJQlxuICAgICAgICAgIH1cbiAgICAgICAgICBjb250aW51ZVxuXG4gICAgICAgIGNhc2UgUy5DTE9TRV9UQUc6XG4gICAgICAgICAgaWYgKCFwYXJzZXIudGFnTmFtZSkge1xuICAgICAgICAgICAgaWYgKGlzV2hpdGVzcGFjZShjKSkge1xuICAgICAgICAgICAgICBjb250aW51ZVxuICAgICAgICAgICAgfSBlbHNlIGlmIChub3RNYXRjaChuYW1lU3RhcnQsIGMpKSB7XG4gICAgICAgICAgICAgIGlmIChwYXJzZXIuc2NyaXB0KSB7XG4gICAgICAgICAgICAgICAgcGFyc2VyLnNjcmlwdCArPSAnPC8nICsgY1xuICAgICAgICAgICAgICAgIHBhcnNlci5zdGF0ZSA9IFMuU0NSSVBUXG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgc3RyaWN0RmFpbChwYXJzZXIsICdJbnZhbGlkIHRhZ25hbWUgaW4gY2xvc2luZyB0YWcuJylcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgcGFyc2VyLnRhZ05hbWUgPSBjXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIGlmIChjID09PSAnPicpIHtcbiAgICAgICAgICAgIGNsb3NlVGFnKHBhcnNlcilcbiAgICAgICAgICB9IGVsc2UgaWYgKGlzTWF0Y2gobmFtZUJvZHksIGMpKSB7XG4gICAgICAgICAgICBwYXJzZXIudGFnTmFtZSArPSBjXG4gICAgICAgICAgfSBlbHNlIGlmIChwYXJzZXIuc2NyaXB0KSB7XG4gICAgICAgICAgICBwYXJzZXIuc2NyaXB0ICs9ICc8LycgKyBwYXJzZXIudGFnTmFtZVxuICAgICAgICAgICAgcGFyc2VyLnRhZ05hbWUgPSAnJ1xuICAgICAgICAgICAgcGFyc2VyLnN0YXRlID0gUy5TQ1JJUFRcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKCFpc1doaXRlc3BhY2UoYykpIHtcbiAgICAgICAgICAgICAgc3RyaWN0RmFpbChwYXJzZXIsICdJbnZhbGlkIHRhZ25hbWUgaW4gY2xvc2luZyB0YWcnKVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcGFyc2VyLnN0YXRlID0gUy5DTE9TRV9UQUdfU0FXX1dISVRFXG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnRpbnVlXG5cbiAgICAgICAgY2FzZSBTLkNMT1NFX1RBR19TQVdfV0hJVEU6XG4gICAgICAgICAgaWYgKGlzV2hpdGVzcGFjZShjKSkge1xuICAgICAgICAgICAgY29udGludWVcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGMgPT09ICc+Jykge1xuICAgICAgICAgICAgY2xvc2VUYWcocGFyc2VyKVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzdHJpY3RGYWlsKHBhcnNlciwgJ0ludmFsaWQgY2hhcmFjdGVycyBpbiBjbG9zaW5nIHRhZycpXG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnRpbnVlXG5cbiAgICAgICAgY2FzZSBTLlRFWFRfRU5USVRZOlxuICAgICAgICBjYXNlIFMuQVRUUklCX1ZBTFVFX0VOVElUWV9ROlxuICAgICAgICBjYXNlIFMuQVRUUklCX1ZBTFVFX0VOVElUWV9VOlxuICAgICAgICAgIHZhciByZXR1cm5TdGF0ZVxuICAgICAgICAgIHZhciBidWZmZXJcbiAgICAgICAgICBzd2l0Y2ggKHBhcnNlci5zdGF0ZSkge1xuICAgICAgICAgICAgY2FzZSBTLlRFWFRfRU5USVRZOlxuICAgICAgICAgICAgICByZXR1cm5TdGF0ZSA9IFMuVEVYVFxuICAgICAgICAgICAgICBidWZmZXIgPSAndGV4dE5vZGUnXG4gICAgICAgICAgICAgIGJyZWFrXG5cbiAgICAgICAgICAgIGNhc2UgUy5BVFRSSUJfVkFMVUVfRU5USVRZX1E6XG4gICAgICAgICAgICAgIHJldHVyblN0YXRlID0gUy5BVFRSSUJfVkFMVUVfUVVPVEVEXG4gICAgICAgICAgICAgIGJ1ZmZlciA9ICdhdHRyaWJWYWx1ZSdcbiAgICAgICAgICAgICAgYnJlYWtcblxuICAgICAgICAgICAgY2FzZSBTLkFUVFJJQl9WQUxVRV9FTlRJVFlfVTpcbiAgICAgICAgICAgICAgcmV0dXJuU3RhdGUgPSBTLkFUVFJJQl9WQUxVRV9VTlFVT1RFRFxuICAgICAgICAgICAgICBidWZmZXIgPSAnYXR0cmliVmFsdWUnXG4gICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKGMgPT09ICc7Jykge1xuICAgICAgICAgICAgcGFyc2VyW2J1ZmZlcl0gKz0gcGFyc2VFbnRpdHkocGFyc2VyKVxuICAgICAgICAgICAgcGFyc2VyLmVudGl0eSA9ICcnXG4gICAgICAgICAgICBwYXJzZXIuc3RhdGUgPSByZXR1cm5TdGF0ZVxuICAgICAgICAgIH0gZWxzZSBpZiAoaXNNYXRjaChwYXJzZXIuZW50aXR5Lmxlbmd0aCA/IGVudGl0eUJvZHkgOiBlbnRpdHlTdGFydCwgYykpIHtcbiAgICAgICAgICAgIHBhcnNlci5lbnRpdHkgKz0gY1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzdHJpY3RGYWlsKHBhcnNlciwgJ0ludmFsaWQgY2hhcmFjdGVyIGluIGVudGl0eSBuYW1lJylcbiAgICAgICAgICAgIHBhcnNlcltidWZmZXJdICs9ICcmJyArIHBhcnNlci5lbnRpdHkgKyBjXG4gICAgICAgICAgICBwYXJzZXIuZW50aXR5ID0gJydcbiAgICAgICAgICAgIHBhcnNlci5zdGF0ZSA9IHJldHVyblN0YXRlXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY29udGludWVcblxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihwYXJzZXIsICdVbmtub3duIHN0YXRlOiAnICsgcGFyc2VyLnN0YXRlKVxuICAgICAgfVxuICAgIH0gLy8gd2hpbGVcblxuICAgIGlmIChwYXJzZXIucG9zaXRpb24gPj0gcGFyc2VyLmJ1ZmZlckNoZWNrUG9zaXRpb24pIHtcbiAgICAgIGNoZWNrQnVmZmVyTGVuZ3RoKHBhcnNlcilcbiAgICB9XG4gICAgcmV0dXJuIHBhcnNlclxuICB9XG5cbiAgLyohIGh0dHA6Ly9tdGhzLmJlL2Zyb21jb2RlcG9pbnQgdjAuMS4wIGJ5IEBtYXRoaWFzICovXG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gIGlmICghU3RyaW5nLmZyb21Db2RlUG9pbnQpIHtcbiAgICAoZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIHN0cmluZ0Zyb21DaGFyQ29kZSA9IFN0cmluZy5mcm9tQ2hhckNvZGVcbiAgICAgIHZhciBmbG9vciA9IE1hdGguZmxvb3JcbiAgICAgIHZhciBmcm9tQ29kZVBvaW50ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgTUFYX1NJWkUgPSAweDQwMDBcbiAgICAgICAgdmFyIGNvZGVVbml0cyA9IFtdXG4gICAgICAgIHZhciBoaWdoU3Vycm9nYXRlXG4gICAgICAgIHZhciBsb3dTdXJyb2dhdGVcbiAgICAgICAgdmFyIGluZGV4ID0gLTFcbiAgICAgICAgdmFyIGxlbmd0aCA9IGFyZ3VtZW50cy5sZW5ndGhcbiAgICAgICAgaWYgKCFsZW5ndGgpIHtcbiAgICAgICAgICByZXR1cm4gJydcbiAgICAgICAgfVxuICAgICAgICB2YXIgcmVzdWx0ID0gJydcbiAgICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgICB2YXIgY29kZVBvaW50ID0gTnVtYmVyKGFyZ3VtZW50c1tpbmRleF0pXG4gICAgICAgICAgaWYgKFxuICAgICAgICAgICAgIWlzRmluaXRlKGNvZGVQb2ludCkgfHwgLy8gYE5hTmAsIGArSW5maW5pdHlgLCBvciBgLUluZmluaXR5YFxuICAgICAgICAgICAgY29kZVBvaW50IDwgMCB8fCAvLyBub3QgYSB2YWxpZCBVbmljb2RlIGNvZGUgcG9pbnRcbiAgICAgICAgICAgIGNvZGVQb2ludCA+IDB4MTBGRkZGIHx8IC8vIG5vdCBhIHZhbGlkIFVuaWNvZGUgY29kZSBwb2ludFxuICAgICAgICAgICAgZmxvb3IoY29kZVBvaW50KSAhPT0gY29kZVBvaW50IC8vIG5vdCBhbiBpbnRlZ2VyXG4gICAgICAgICAgKSB7XG4gICAgICAgICAgICB0aHJvdyBSYW5nZUVycm9yKCdJbnZhbGlkIGNvZGUgcG9pbnQ6ICcgKyBjb2RlUG9pbnQpXG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChjb2RlUG9pbnQgPD0gMHhGRkZGKSB7IC8vIEJNUCBjb2RlIHBvaW50XG4gICAgICAgICAgICBjb2RlVW5pdHMucHVzaChjb2RlUG9pbnQpXG4gICAgICAgICAgfSBlbHNlIHsgLy8gQXN0cmFsIGNvZGUgcG9pbnQ7IHNwbGl0IGluIHN1cnJvZ2F0ZSBoYWx2ZXNcbiAgICAgICAgICAgIC8vIGh0dHA6Ly9tYXRoaWFzYnluZW5zLmJlL25vdGVzL2phdmFzY3JpcHQtZW5jb2Rpbmcjc3Vycm9nYXRlLWZvcm11bGFlXG4gICAgICAgICAgICBjb2RlUG9pbnQgLT0gMHgxMDAwMFxuICAgICAgICAgICAgaGlnaFN1cnJvZ2F0ZSA9IChjb2RlUG9pbnQgPj4gMTApICsgMHhEODAwXG4gICAgICAgICAgICBsb3dTdXJyb2dhdGUgPSAoY29kZVBvaW50ICUgMHg0MDApICsgMHhEQzAwXG4gICAgICAgICAgICBjb2RlVW5pdHMucHVzaChoaWdoU3Vycm9nYXRlLCBsb3dTdXJyb2dhdGUpXG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChpbmRleCArIDEgPT09IGxlbmd0aCB8fCBjb2RlVW5pdHMubGVuZ3RoID4gTUFYX1NJWkUpIHtcbiAgICAgICAgICAgIHJlc3VsdCArPSBzdHJpbmdGcm9tQ2hhckNvZGUuYXBwbHkobnVsbCwgY29kZVVuaXRzKVxuICAgICAgICAgICAgY29kZVVuaXRzLmxlbmd0aCA9IDBcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdFxuICAgICAgfVxuICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICAgIGlmIChPYmplY3QuZGVmaW5lUHJvcGVydHkpIHtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFN0cmluZywgJ2Zyb21Db2RlUG9pbnQnLCB7XG4gICAgICAgICAgdmFsdWU6IGZyb21Db2RlUG9pbnQsXG4gICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgIHdyaXRhYmxlOiB0cnVlXG4gICAgICAgIH0pXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBTdHJpbmcuZnJvbUNvZGVQb2ludCA9IGZyb21Db2RlUG9pbnRcbiAgICAgIH1cbiAgICB9KCkpXG4gIH1cbn0pKHR5cGVvZiBleHBvcnRzID09PSAndW5kZWZpbmVkJyA/IHRoaXMuc2F4ID0ge30gOiBleHBvcnRzKVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL3NheC9saWIvc2F4LmpzIiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwic3RyaW5nX2RlY29kZXJcIik7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gZXh0ZXJuYWwgXCJzdHJpbmdfZGVjb2RlclwiXG4vLyBtb2R1bGUgaWQgPSAxMzZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiJ3VzZSBzdHJpY3QnO1xuXG5cbnZhciBsb2FkZXIgPSByZXF1aXJlKCcuL2pzLXlhbWwvbG9hZGVyJyk7XG52YXIgZHVtcGVyID0gcmVxdWlyZSgnLi9qcy15YW1sL2R1bXBlcicpO1xuXG5cbmZ1bmN0aW9uIGRlcHJlY2F0ZWQobmFtZSkge1xuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIHRocm93IG5ldyBFcnJvcignRnVuY3Rpb24gJyArIG5hbWUgKyAnIGlzIGRlcHJlY2F0ZWQgYW5kIGNhbm5vdCBiZSB1c2VkLicpO1xuICB9O1xufVxuXG5cbm1vZHVsZS5leHBvcnRzLlR5cGUgICAgICAgICAgICAgICAgPSByZXF1aXJlKCcuL2pzLXlhbWwvdHlwZScpO1xubW9kdWxlLmV4cG9ydHMuU2NoZW1hICAgICAgICAgICAgICA9IHJlcXVpcmUoJy4vanMteWFtbC9zY2hlbWEnKTtcbm1vZHVsZS5leHBvcnRzLkZBSUxTQUZFX1NDSEVNQSAgICAgPSByZXF1aXJlKCcuL2pzLXlhbWwvc2NoZW1hL2ZhaWxzYWZlJyk7XG5tb2R1bGUuZXhwb3J0cy5KU09OX1NDSEVNQSAgICAgICAgID0gcmVxdWlyZSgnLi9qcy15YW1sL3NjaGVtYS9qc29uJyk7XG5tb2R1bGUuZXhwb3J0cy5DT1JFX1NDSEVNQSAgICAgICAgID0gcmVxdWlyZSgnLi9qcy15YW1sL3NjaGVtYS9jb3JlJyk7XG5tb2R1bGUuZXhwb3J0cy5ERUZBVUxUX1NBRkVfU0NIRU1BID0gcmVxdWlyZSgnLi9qcy15YW1sL3NjaGVtYS9kZWZhdWx0X3NhZmUnKTtcbm1vZHVsZS5leHBvcnRzLkRFRkFVTFRfRlVMTF9TQ0hFTUEgPSByZXF1aXJlKCcuL2pzLXlhbWwvc2NoZW1hL2RlZmF1bHRfZnVsbCcpO1xubW9kdWxlLmV4cG9ydHMubG9hZCAgICAgICAgICAgICAgICA9IGxvYWRlci5sb2FkO1xubW9kdWxlLmV4cG9ydHMubG9hZEFsbCAgICAgICAgICAgICA9IGxvYWRlci5sb2FkQWxsO1xubW9kdWxlLmV4cG9ydHMuc2FmZUxvYWQgICAgICAgICAgICA9IGxvYWRlci5zYWZlTG9hZDtcbm1vZHVsZS5leHBvcnRzLnNhZmVMb2FkQWxsICAgICAgICAgPSBsb2FkZXIuc2FmZUxvYWRBbGw7XG5tb2R1bGUuZXhwb3J0cy5kdW1wICAgICAgICAgICAgICAgID0gZHVtcGVyLmR1bXA7XG5tb2R1bGUuZXhwb3J0cy5zYWZlRHVtcCAgICAgICAgICAgID0gZHVtcGVyLnNhZmVEdW1wO1xubW9kdWxlLmV4cG9ydHMuWUFNTEV4Y2VwdGlvbiAgICAgICA9IHJlcXVpcmUoJy4vanMteWFtbC9leGNlcHRpb24nKTtcblxuLy8gRGVwcmVjYXRlZCBzY2hlbWEgbmFtZXMgZnJvbSBKUy1ZQU1MIDIuMC54XG5tb2R1bGUuZXhwb3J0cy5NSU5JTUFMX1NDSEVNQSA9IHJlcXVpcmUoJy4vanMteWFtbC9zY2hlbWEvZmFpbHNhZmUnKTtcbm1vZHVsZS5leHBvcnRzLlNBRkVfU0NIRU1BICAgID0gcmVxdWlyZSgnLi9qcy15YW1sL3NjaGVtYS9kZWZhdWx0X3NhZmUnKTtcbm1vZHVsZS5leHBvcnRzLkRFRkFVTFRfU0NIRU1BID0gcmVxdWlyZSgnLi9qcy15YW1sL3NjaGVtYS9kZWZhdWx0X2Z1bGwnKTtcblxuLy8gRGVwcmVjYXRlZCBmdW5jdGlvbnMgZnJvbSBKUy1ZQU1MIDEueC54XG5tb2R1bGUuZXhwb3J0cy5zY2FuICAgICAgICAgICA9IGRlcHJlY2F0ZWQoJ3NjYW4nKTtcbm1vZHVsZS5leHBvcnRzLnBhcnNlICAgICAgICAgID0gZGVwcmVjYXRlZCgncGFyc2UnKTtcbm1vZHVsZS5leHBvcnRzLmNvbXBvc2UgICAgICAgID0gZGVwcmVjYXRlZCgnY29tcG9zZScpO1xubW9kdWxlLmV4cG9ydHMuYWRkQ29uc3RydWN0b3IgPSBkZXByZWNhdGVkKCdhZGRDb25zdHJ1Y3RvcicpO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2pzLXlhbWwvbGliL2pzLXlhbWwuanMiLCIndXNlIHN0cmljdCc7XG5cbi8qZXNsaW50LWRpc2FibGUgbWF4LWxlbixuby11c2UtYmVmb3JlLWRlZmluZSovXG5cbnZhciBjb21tb24gICAgICAgICAgICAgID0gcmVxdWlyZSgnLi9jb21tb24nKTtcbnZhciBZQU1MRXhjZXB0aW9uICAgICAgID0gcmVxdWlyZSgnLi9leGNlcHRpb24nKTtcbnZhciBNYXJrICAgICAgICAgICAgICAgID0gcmVxdWlyZSgnLi9tYXJrJyk7XG52YXIgREVGQVVMVF9TQUZFX1NDSEVNQSA9IHJlcXVpcmUoJy4vc2NoZW1hL2RlZmF1bHRfc2FmZScpO1xudmFyIERFRkFVTFRfRlVMTF9TQ0hFTUEgPSByZXF1aXJlKCcuL3NjaGVtYS9kZWZhdWx0X2Z1bGwnKTtcblxuXG52YXIgX2hhc093blByb3BlcnR5ID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcblxuXG52YXIgQ09OVEVYVF9GTE9XX0lOICAgPSAxO1xudmFyIENPTlRFWFRfRkxPV19PVVQgID0gMjtcbnZhciBDT05URVhUX0JMT0NLX0lOICA9IDM7XG52YXIgQ09OVEVYVF9CTE9DS19PVVQgPSA0O1xuXG5cbnZhciBDSE9NUElOR19DTElQICA9IDE7XG52YXIgQ0hPTVBJTkdfU1RSSVAgPSAyO1xudmFyIENIT01QSU5HX0tFRVAgID0gMztcblxuXG52YXIgUEFUVEVSTl9OT05fUFJJTlRBQkxFICAgICAgICAgPSAvW1xceDAwLVxceDA4XFx4MEJcXHgwQ1xceDBFLVxceDFGXFx4N0YtXFx4ODRcXHg4Ni1cXHg5RlxcdUZGRkVcXHVGRkZGXXxbXFx1RDgwMC1cXHVEQkZGXSg/IVtcXHVEQzAwLVxcdURGRkZdKXwoPzpbXlxcdUQ4MDAtXFx1REJGRl18XilbXFx1REMwMC1cXHVERkZGXS87XG52YXIgUEFUVEVSTl9OT05fQVNDSUlfTElORV9CUkVBS1MgPSAvW1xceDg1XFx1MjAyOFxcdTIwMjldLztcbnZhciBQQVRURVJOX0ZMT1dfSU5ESUNBVE9SUyAgICAgICA9IC9bLFxcW1xcXVxce1xcfV0vO1xudmFyIFBBVFRFUk5fVEFHX0hBTkRMRSAgICAgICAgICAgID0gL14oPzohfCEhfCFbYS16XFwtXSshKSQvaTtcbnZhciBQQVRURVJOX1RBR19VUkkgICAgICAgICAgICAgICA9IC9eKD86IXxbXixcXFtcXF1cXHtcXH1dKSg/OiVbMC05YS1mXXsyfXxbMC05YS16XFwtIztcXC9cXD86QCY9XFwrXFwkLF9cXC4hflxcKidcXChcXClcXFtcXF1dKSokL2k7XG5cblxuZnVuY3Rpb24gaXNfRU9MKGMpIHtcbiAgcmV0dXJuIChjID09PSAweDBBLyogTEYgKi8pIHx8IChjID09PSAweDBELyogQ1IgKi8pO1xufVxuXG5mdW5jdGlvbiBpc19XSElURV9TUEFDRShjKSB7XG4gIHJldHVybiAoYyA9PT0gMHgwOS8qIFRhYiAqLykgfHwgKGMgPT09IDB4MjAvKiBTcGFjZSAqLyk7XG59XG5cbmZ1bmN0aW9uIGlzX1dTX09SX0VPTChjKSB7XG4gIHJldHVybiAoYyA9PT0gMHgwOS8qIFRhYiAqLykgfHxcbiAgICAgICAgIChjID09PSAweDIwLyogU3BhY2UgKi8pIHx8XG4gICAgICAgICAoYyA9PT0gMHgwQS8qIExGICovKSB8fFxuICAgICAgICAgKGMgPT09IDB4MEQvKiBDUiAqLyk7XG59XG5cbmZ1bmN0aW9uIGlzX0ZMT1dfSU5ESUNBVE9SKGMpIHtcbiAgcmV0dXJuIGMgPT09IDB4MkMvKiAsICovIHx8XG4gICAgICAgICBjID09PSAweDVCLyogWyAqLyB8fFxuICAgICAgICAgYyA9PT0gMHg1RC8qIF0gKi8gfHxcbiAgICAgICAgIGMgPT09IDB4N0IvKiB7ICovIHx8XG4gICAgICAgICBjID09PSAweDdELyogfSAqLztcbn1cblxuZnVuY3Rpb24gZnJvbUhleENvZGUoYykge1xuICB2YXIgbGM7XG5cbiAgaWYgKCgweDMwLyogMCAqLyA8PSBjKSAmJiAoYyA8PSAweDM5LyogOSAqLykpIHtcbiAgICByZXR1cm4gYyAtIDB4MzA7XG4gIH1cblxuICAvKmVzbGludC1kaXNhYmxlIG5vLWJpdHdpc2UqL1xuICBsYyA9IGMgfCAweDIwO1xuXG4gIGlmICgoMHg2MS8qIGEgKi8gPD0gbGMpICYmIChsYyA8PSAweDY2LyogZiAqLykpIHtcbiAgICByZXR1cm4gbGMgLSAweDYxICsgMTA7XG4gIH1cblxuICByZXR1cm4gLTE7XG59XG5cbmZ1bmN0aW9uIGVzY2FwZWRIZXhMZW4oYykge1xuICBpZiAoYyA9PT0gMHg3OC8qIHggKi8pIHsgcmV0dXJuIDI7IH1cbiAgaWYgKGMgPT09IDB4NzUvKiB1ICovKSB7IHJldHVybiA0OyB9XG4gIGlmIChjID09PSAweDU1LyogVSAqLykgeyByZXR1cm4gODsgfVxuICByZXR1cm4gMDtcbn1cblxuZnVuY3Rpb24gZnJvbURlY2ltYWxDb2RlKGMpIHtcbiAgaWYgKCgweDMwLyogMCAqLyA8PSBjKSAmJiAoYyA8PSAweDM5LyogOSAqLykpIHtcbiAgICByZXR1cm4gYyAtIDB4MzA7XG4gIH1cblxuICByZXR1cm4gLTE7XG59XG5cbmZ1bmN0aW9uIHNpbXBsZUVzY2FwZVNlcXVlbmNlKGMpIHtcbiAgLyogZXNsaW50LWRpc2FibGUgaW5kZW50ICovXG4gIHJldHVybiAoYyA9PT0gMHgzMC8qIDAgKi8pID8gJ1xceDAwJyA6XG4gICAgICAgIChjID09PSAweDYxLyogYSAqLykgPyAnXFx4MDcnIDpcbiAgICAgICAgKGMgPT09IDB4NjIvKiBiICovKSA/ICdcXHgwOCcgOlxuICAgICAgICAoYyA9PT0gMHg3NC8qIHQgKi8pID8gJ1xceDA5JyA6XG4gICAgICAgIChjID09PSAweDA5LyogVGFiICovKSA/ICdcXHgwOScgOlxuICAgICAgICAoYyA9PT0gMHg2RS8qIG4gKi8pID8gJ1xceDBBJyA6XG4gICAgICAgIChjID09PSAweDc2LyogdiAqLykgPyAnXFx4MEInIDpcbiAgICAgICAgKGMgPT09IDB4NjYvKiBmICovKSA/ICdcXHgwQycgOlxuICAgICAgICAoYyA9PT0gMHg3Mi8qIHIgKi8pID8gJ1xceDBEJyA6XG4gICAgICAgIChjID09PSAweDY1LyogZSAqLykgPyAnXFx4MUInIDpcbiAgICAgICAgKGMgPT09IDB4MjAvKiBTcGFjZSAqLykgPyAnICcgOlxuICAgICAgICAoYyA9PT0gMHgyMi8qIFwiICovKSA/ICdcXHgyMicgOlxuICAgICAgICAoYyA9PT0gMHgyRi8qIC8gKi8pID8gJy8nIDpcbiAgICAgICAgKGMgPT09IDB4NUMvKiBcXCAqLykgPyAnXFx4NUMnIDpcbiAgICAgICAgKGMgPT09IDB4NEUvKiBOICovKSA/ICdcXHg4NScgOlxuICAgICAgICAoYyA9PT0gMHg1Ri8qIF8gKi8pID8gJ1xceEEwJyA6XG4gICAgICAgIChjID09PSAweDRDLyogTCAqLykgPyAnXFx1MjAyOCcgOlxuICAgICAgICAoYyA9PT0gMHg1MC8qIFAgKi8pID8gJ1xcdTIwMjknIDogJyc7XG59XG5cbmZ1bmN0aW9uIGNoYXJGcm9tQ29kZXBvaW50KGMpIHtcbiAgaWYgKGMgPD0gMHhGRkZGKSB7XG4gICAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUoYyk7XG4gIH1cbiAgLy8gRW5jb2RlIFVURi0xNiBzdXJyb2dhdGUgcGFpclxuICAvLyBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9VVEYtMTYjQ29kZV9wb2ludHNfVS4yQjAxMDAwMF90b19VLjJCMTBGRkZGXG4gIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlKFxuICAgICgoYyAtIDB4MDEwMDAwKSA+PiAxMCkgKyAweEQ4MDAsXG4gICAgKChjIC0gMHgwMTAwMDApICYgMHgwM0ZGKSArIDB4REMwMFxuICApO1xufVxuXG52YXIgc2ltcGxlRXNjYXBlQ2hlY2sgPSBuZXcgQXJyYXkoMjU2KTsgLy8gaW50ZWdlciwgZm9yIGZhc3QgYWNjZXNzXG52YXIgc2ltcGxlRXNjYXBlTWFwID0gbmV3IEFycmF5KDI1Nik7XG5mb3IgKHZhciBpID0gMDsgaSA8IDI1NjsgaSsrKSB7XG4gIHNpbXBsZUVzY2FwZUNoZWNrW2ldID0gc2ltcGxlRXNjYXBlU2VxdWVuY2UoaSkgPyAxIDogMDtcbiAgc2ltcGxlRXNjYXBlTWFwW2ldID0gc2ltcGxlRXNjYXBlU2VxdWVuY2UoaSk7XG59XG5cblxuZnVuY3Rpb24gU3RhdGUoaW5wdXQsIG9wdGlvbnMpIHtcbiAgdGhpcy5pbnB1dCA9IGlucHV0O1xuXG4gIHRoaXMuZmlsZW5hbWUgID0gb3B0aW9uc1snZmlsZW5hbWUnXSAgfHwgbnVsbDtcbiAgdGhpcy5zY2hlbWEgICAgPSBvcHRpb25zWydzY2hlbWEnXSAgICB8fCBERUZBVUxUX0ZVTExfU0NIRU1BO1xuICB0aGlzLm9uV2FybmluZyA9IG9wdGlvbnNbJ29uV2FybmluZyddIHx8IG51bGw7XG4gIHRoaXMubGVnYWN5ICAgID0gb3B0aW9uc1snbGVnYWN5J10gICAgfHwgZmFsc2U7XG4gIHRoaXMuanNvbiAgICAgID0gb3B0aW9uc1snanNvbiddICAgICAgfHwgZmFsc2U7XG4gIHRoaXMubGlzdGVuZXIgID0gb3B0aW9uc1snbGlzdGVuZXInXSAgfHwgbnVsbDtcblxuICB0aGlzLmltcGxpY2l0VHlwZXMgPSB0aGlzLnNjaGVtYS5jb21waWxlZEltcGxpY2l0O1xuICB0aGlzLnR5cGVNYXAgICAgICAgPSB0aGlzLnNjaGVtYS5jb21waWxlZFR5cGVNYXA7XG5cbiAgdGhpcy5sZW5ndGggICAgID0gaW5wdXQubGVuZ3RoO1xuICB0aGlzLnBvc2l0aW9uICAgPSAwO1xuICB0aGlzLmxpbmUgICAgICAgPSAwO1xuICB0aGlzLmxpbmVTdGFydCAgPSAwO1xuICB0aGlzLmxpbmVJbmRlbnQgPSAwO1xuXG4gIHRoaXMuZG9jdW1lbnRzID0gW107XG5cbiAgLypcbiAgdGhpcy52ZXJzaW9uO1xuICB0aGlzLmNoZWNrTGluZUJyZWFrcztcbiAgdGhpcy50YWdNYXA7XG4gIHRoaXMuYW5jaG9yTWFwO1xuICB0aGlzLnRhZztcbiAgdGhpcy5hbmNob3I7XG4gIHRoaXMua2luZDtcbiAgdGhpcy5yZXN1bHQ7Ki9cblxufVxuXG5cbmZ1bmN0aW9uIGdlbmVyYXRlRXJyb3Ioc3RhdGUsIG1lc3NhZ2UpIHtcbiAgcmV0dXJuIG5ldyBZQU1MRXhjZXB0aW9uKFxuICAgIG1lc3NhZ2UsXG4gICAgbmV3IE1hcmsoc3RhdGUuZmlsZW5hbWUsIHN0YXRlLmlucHV0LCBzdGF0ZS5wb3NpdGlvbiwgc3RhdGUubGluZSwgKHN0YXRlLnBvc2l0aW9uIC0gc3RhdGUubGluZVN0YXJ0KSkpO1xufVxuXG5mdW5jdGlvbiB0aHJvd0Vycm9yKHN0YXRlLCBtZXNzYWdlKSB7XG4gIHRocm93IGdlbmVyYXRlRXJyb3Ioc3RhdGUsIG1lc3NhZ2UpO1xufVxuXG5mdW5jdGlvbiB0aHJvd1dhcm5pbmcoc3RhdGUsIG1lc3NhZ2UpIHtcbiAgaWYgKHN0YXRlLm9uV2FybmluZykge1xuICAgIHN0YXRlLm9uV2FybmluZy5jYWxsKG51bGwsIGdlbmVyYXRlRXJyb3Ioc3RhdGUsIG1lc3NhZ2UpKTtcbiAgfVxufVxuXG5cbnZhciBkaXJlY3RpdmVIYW5kbGVycyA9IHtcblxuICBZQU1MOiBmdW5jdGlvbiBoYW5kbGVZYW1sRGlyZWN0aXZlKHN0YXRlLCBuYW1lLCBhcmdzKSB7XG5cbiAgICB2YXIgbWF0Y2gsIG1ham9yLCBtaW5vcjtcblxuICAgIGlmIChzdGF0ZS52ZXJzaW9uICE9PSBudWxsKSB7XG4gICAgICB0aHJvd0Vycm9yKHN0YXRlLCAnZHVwbGljYXRpb24gb2YgJVlBTUwgZGlyZWN0aXZlJyk7XG4gICAgfVxuXG4gICAgaWYgKGFyZ3MubGVuZ3RoICE9PSAxKSB7XG4gICAgICB0aHJvd0Vycm9yKHN0YXRlLCAnWUFNTCBkaXJlY3RpdmUgYWNjZXB0cyBleGFjdGx5IG9uZSBhcmd1bWVudCcpO1xuICAgIH1cblxuICAgIG1hdGNoID0gL14oWzAtOV0rKVxcLihbMC05XSspJC8uZXhlYyhhcmdzWzBdKTtcblxuICAgIGlmIChtYXRjaCA9PT0gbnVsbCkge1xuICAgICAgdGhyb3dFcnJvcihzdGF0ZSwgJ2lsbC1mb3JtZWQgYXJndW1lbnQgb2YgdGhlIFlBTUwgZGlyZWN0aXZlJyk7XG4gICAgfVxuXG4gICAgbWFqb3IgPSBwYXJzZUludChtYXRjaFsxXSwgMTApO1xuICAgIG1pbm9yID0gcGFyc2VJbnQobWF0Y2hbMl0sIDEwKTtcblxuICAgIGlmIChtYWpvciAhPT0gMSkge1xuICAgICAgdGhyb3dFcnJvcihzdGF0ZSwgJ3VuYWNjZXB0YWJsZSBZQU1MIHZlcnNpb24gb2YgdGhlIGRvY3VtZW50Jyk7XG4gICAgfVxuXG4gICAgc3RhdGUudmVyc2lvbiA9IGFyZ3NbMF07XG4gICAgc3RhdGUuY2hlY2tMaW5lQnJlYWtzID0gKG1pbm9yIDwgMik7XG5cbiAgICBpZiAobWlub3IgIT09IDEgJiYgbWlub3IgIT09IDIpIHtcbiAgICAgIHRocm93V2FybmluZyhzdGF0ZSwgJ3Vuc3VwcG9ydGVkIFlBTUwgdmVyc2lvbiBvZiB0aGUgZG9jdW1lbnQnKTtcbiAgICB9XG4gIH0sXG5cbiAgVEFHOiBmdW5jdGlvbiBoYW5kbGVUYWdEaXJlY3RpdmUoc3RhdGUsIG5hbWUsIGFyZ3MpIHtcblxuICAgIHZhciBoYW5kbGUsIHByZWZpeDtcblxuICAgIGlmIChhcmdzLmxlbmd0aCAhPT0gMikge1xuICAgICAgdGhyb3dFcnJvcihzdGF0ZSwgJ1RBRyBkaXJlY3RpdmUgYWNjZXB0cyBleGFjdGx5IHR3byBhcmd1bWVudHMnKTtcbiAgICB9XG5cbiAgICBoYW5kbGUgPSBhcmdzWzBdO1xuICAgIHByZWZpeCA9IGFyZ3NbMV07XG5cbiAgICBpZiAoIVBBVFRFUk5fVEFHX0hBTkRMRS50ZXN0KGhhbmRsZSkpIHtcbiAgICAgIHRocm93RXJyb3Ioc3RhdGUsICdpbGwtZm9ybWVkIHRhZyBoYW5kbGUgKGZpcnN0IGFyZ3VtZW50KSBvZiB0aGUgVEFHIGRpcmVjdGl2ZScpO1xuICAgIH1cblxuICAgIGlmIChfaGFzT3duUHJvcGVydHkuY2FsbChzdGF0ZS50YWdNYXAsIGhhbmRsZSkpIHtcbiAgICAgIHRocm93RXJyb3Ioc3RhdGUsICd0aGVyZSBpcyBhIHByZXZpb3VzbHkgZGVjbGFyZWQgc3VmZml4IGZvciBcIicgKyBoYW5kbGUgKyAnXCIgdGFnIGhhbmRsZScpO1xuICAgIH1cblxuICAgIGlmICghUEFUVEVSTl9UQUdfVVJJLnRlc3QocHJlZml4KSkge1xuICAgICAgdGhyb3dFcnJvcihzdGF0ZSwgJ2lsbC1mb3JtZWQgdGFnIHByZWZpeCAoc2Vjb25kIGFyZ3VtZW50KSBvZiB0aGUgVEFHIGRpcmVjdGl2ZScpO1xuICAgIH1cblxuICAgIHN0YXRlLnRhZ01hcFtoYW5kbGVdID0gcHJlZml4O1xuICB9XG59O1xuXG5cbmZ1bmN0aW9uIGNhcHR1cmVTZWdtZW50KHN0YXRlLCBzdGFydCwgZW5kLCBjaGVja0pzb24pIHtcbiAgdmFyIF9wb3NpdGlvbiwgX2xlbmd0aCwgX2NoYXJhY3RlciwgX3Jlc3VsdDtcblxuICBpZiAoc3RhcnQgPCBlbmQpIHtcbiAgICBfcmVzdWx0ID0gc3RhdGUuaW5wdXQuc2xpY2Uoc3RhcnQsIGVuZCk7XG5cbiAgICBpZiAoY2hlY2tKc29uKSB7XG4gICAgICBmb3IgKF9wb3NpdGlvbiA9IDAsIF9sZW5ndGggPSBfcmVzdWx0Lmxlbmd0aDsgX3Bvc2l0aW9uIDwgX2xlbmd0aDsgX3Bvc2l0aW9uICs9IDEpIHtcbiAgICAgICAgX2NoYXJhY3RlciA9IF9yZXN1bHQuY2hhckNvZGVBdChfcG9zaXRpb24pO1xuICAgICAgICBpZiAoIShfY2hhcmFjdGVyID09PSAweDA5IHx8XG4gICAgICAgICAgICAgICgweDIwIDw9IF9jaGFyYWN0ZXIgJiYgX2NoYXJhY3RlciA8PSAweDEwRkZGRikpKSB7XG4gICAgICAgICAgdGhyb3dFcnJvcihzdGF0ZSwgJ2V4cGVjdGVkIHZhbGlkIEpTT04gY2hhcmFjdGVyJyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKFBBVFRFUk5fTk9OX1BSSU5UQUJMRS50ZXN0KF9yZXN1bHQpKSB7XG4gICAgICB0aHJvd0Vycm9yKHN0YXRlLCAndGhlIHN0cmVhbSBjb250YWlucyBub24tcHJpbnRhYmxlIGNoYXJhY3RlcnMnKTtcbiAgICB9XG5cbiAgICBzdGF0ZS5yZXN1bHQgKz0gX3Jlc3VsdDtcbiAgfVxufVxuXG5mdW5jdGlvbiBtZXJnZU1hcHBpbmdzKHN0YXRlLCBkZXN0aW5hdGlvbiwgc291cmNlLCBvdmVycmlkYWJsZUtleXMpIHtcbiAgdmFyIHNvdXJjZUtleXMsIGtleSwgaW5kZXgsIHF1YW50aXR5O1xuXG4gIGlmICghY29tbW9uLmlzT2JqZWN0KHNvdXJjZSkpIHtcbiAgICB0aHJvd0Vycm9yKHN0YXRlLCAnY2Fubm90IG1lcmdlIG1hcHBpbmdzOyB0aGUgcHJvdmlkZWQgc291cmNlIG9iamVjdCBpcyB1bmFjY2VwdGFibGUnKTtcbiAgfVxuXG4gIHNvdXJjZUtleXMgPSBPYmplY3Qua2V5cyhzb3VyY2UpO1xuXG4gIGZvciAoaW5kZXggPSAwLCBxdWFudGl0eSA9IHNvdXJjZUtleXMubGVuZ3RoOyBpbmRleCA8IHF1YW50aXR5OyBpbmRleCArPSAxKSB7XG4gICAga2V5ID0gc291cmNlS2V5c1tpbmRleF07XG5cbiAgICBpZiAoIV9oYXNPd25Qcm9wZXJ0eS5jYWxsKGRlc3RpbmF0aW9uLCBrZXkpKSB7XG4gICAgICBkZXN0aW5hdGlvbltrZXldID0gc291cmNlW2tleV07XG4gICAgICBvdmVycmlkYWJsZUtleXNba2V5XSA9IHRydWU7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHN0b3JlTWFwcGluZ1BhaXIoc3RhdGUsIF9yZXN1bHQsIG92ZXJyaWRhYmxlS2V5cywga2V5VGFnLCBrZXlOb2RlLCB2YWx1ZU5vZGUsIHN0YXJ0TGluZSwgc3RhcnRQb3MpIHtcbiAgdmFyIGluZGV4LCBxdWFudGl0eTtcblxuICBrZXlOb2RlID0gU3RyaW5nKGtleU5vZGUpO1xuXG4gIGlmIChfcmVzdWx0ID09PSBudWxsKSB7XG4gICAgX3Jlc3VsdCA9IHt9O1xuICB9XG5cbiAgaWYgKGtleVRhZyA9PT0gJ3RhZzp5YW1sLm9yZywyMDAyOm1lcmdlJykge1xuICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlTm9kZSkpIHtcbiAgICAgIGZvciAoaW5kZXggPSAwLCBxdWFudGl0eSA9IHZhbHVlTm9kZS5sZW5ndGg7IGluZGV4IDwgcXVhbnRpdHk7IGluZGV4ICs9IDEpIHtcbiAgICAgICAgbWVyZ2VNYXBwaW5ncyhzdGF0ZSwgX3Jlc3VsdCwgdmFsdWVOb2RlW2luZGV4XSwgb3ZlcnJpZGFibGVLZXlzKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgbWVyZ2VNYXBwaW5ncyhzdGF0ZSwgX3Jlc3VsdCwgdmFsdWVOb2RlLCBvdmVycmlkYWJsZUtleXMpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBpZiAoIXN0YXRlLmpzb24gJiZcbiAgICAgICAgIV9oYXNPd25Qcm9wZXJ0eS5jYWxsKG92ZXJyaWRhYmxlS2V5cywga2V5Tm9kZSkgJiZcbiAgICAgICAgX2hhc093blByb3BlcnR5LmNhbGwoX3Jlc3VsdCwga2V5Tm9kZSkpIHtcbiAgICAgIHN0YXRlLmxpbmUgPSBzdGFydExpbmUgfHwgc3RhdGUubGluZTtcbiAgICAgIHN0YXRlLnBvc2l0aW9uID0gc3RhcnRQb3MgfHwgc3RhdGUucG9zaXRpb247XG4gICAgICB0aHJvd0Vycm9yKHN0YXRlLCAnZHVwbGljYXRlZCBtYXBwaW5nIGtleScpO1xuICAgIH1cbiAgICBfcmVzdWx0W2tleU5vZGVdID0gdmFsdWVOb2RlO1xuICAgIGRlbGV0ZSBvdmVycmlkYWJsZUtleXNba2V5Tm9kZV07XG4gIH1cblxuICByZXR1cm4gX3Jlc3VsdDtcbn1cblxuZnVuY3Rpb24gcmVhZExpbmVCcmVhayhzdGF0ZSkge1xuICB2YXIgY2g7XG5cbiAgY2ggPSBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KHN0YXRlLnBvc2l0aW9uKTtcblxuICBpZiAoY2ggPT09IDB4MEEvKiBMRiAqLykge1xuICAgIHN0YXRlLnBvc2l0aW9uKys7XG4gIH0gZWxzZSBpZiAoY2ggPT09IDB4MEQvKiBDUiAqLykge1xuICAgIHN0YXRlLnBvc2l0aW9uKys7XG4gICAgaWYgKHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoc3RhdGUucG9zaXRpb24pID09PSAweDBBLyogTEYgKi8pIHtcbiAgICAgIHN0YXRlLnBvc2l0aW9uKys7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHRocm93RXJyb3Ioc3RhdGUsICdhIGxpbmUgYnJlYWsgaXMgZXhwZWN0ZWQnKTtcbiAgfVxuXG4gIHN0YXRlLmxpbmUgKz0gMTtcbiAgc3RhdGUubGluZVN0YXJ0ID0gc3RhdGUucG9zaXRpb247XG59XG5cbmZ1bmN0aW9uIHNraXBTZXBhcmF0aW9uU3BhY2Uoc3RhdGUsIGFsbG93Q29tbWVudHMsIGNoZWNrSW5kZW50KSB7XG4gIHZhciBsaW5lQnJlYWtzID0gMCxcbiAgICAgIGNoID0gc3RhdGUuaW5wdXQuY2hhckNvZGVBdChzdGF0ZS5wb3NpdGlvbik7XG5cbiAgd2hpbGUgKGNoICE9PSAwKSB7XG4gICAgd2hpbGUgKGlzX1dISVRFX1NQQUNFKGNoKSkge1xuICAgICAgY2ggPSBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KCsrc3RhdGUucG9zaXRpb24pO1xuICAgIH1cblxuICAgIGlmIChhbGxvd0NvbW1lbnRzICYmIGNoID09PSAweDIzLyogIyAqLykge1xuICAgICAgZG8ge1xuICAgICAgICBjaCA9IHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoKytzdGF0ZS5wb3NpdGlvbik7XG4gICAgICB9IHdoaWxlIChjaCAhPT0gMHgwQS8qIExGICovICYmIGNoICE9PSAweDBELyogQ1IgKi8gJiYgY2ggIT09IDApO1xuICAgIH1cblxuICAgIGlmIChpc19FT0woY2gpKSB7XG4gICAgICByZWFkTGluZUJyZWFrKHN0YXRlKTtcblxuICAgICAgY2ggPSBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KHN0YXRlLnBvc2l0aW9uKTtcbiAgICAgIGxpbmVCcmVha3MrKztcbiAgICAgIHN0YXRlLmxpbmVJbmRlbnQgPSAwO1xuXG4gICAgICB3aGlsZSAoY2ggPT09IDB4MjAvKiBTcGFjZSAqLykge1xuICAgICAgICBzdGF0ZS5saW5lSW5kZW50Kys7XG4gICAgICAgIGNoID0gc3RhdGUuaW5wdXQuY2hhckNvZGVBdCgrK3N0YXRlLnBvc2l0aW9uKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG5cbiAgaWYgKGNoZWNrSW5kZW50ICE9PSAtMSAmJiBsaW5lQnJlYWtzICE9PSAwICYmIHN0YXRlLmxpbmVJbmRlbnQgPCBjaGVja0luZGVudCkge1xuICAgIHRocm93V2FybmluZyhzdGF0ZSwgJ2RlZmljaWVudCBpbmRlbnRhdGlvbicpO1xuICB9XG5cbiAgcmV0dXJuIGxpbmVCcmVha3M7XG59XG5cbmZ1bmN0aW9uIHRlc3REb2N1bWVudFNlcGFyYXRvcihzdGF0ZSkge1xuICB2YXIgX3Bvc2l0aW9uID0gc3RhdGUucG9zaXRpb24sXG4gICAgICBjaDtcblxuICBjaCA9IHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoX3Bvc2l0aW9uKTtcblxuICAvLyBDb25kaXRpb24gc3RhdGUucG9zaXRpb24gPT09IHN0YXRlLmxpbmVTdGFydCBpcyB0ZXN0ZWRcbiAgLy8gaW4gcGFyZW50IG9uIGVhY2ggY2FsbCwgZm9yIGVmZmljaWVuY3kuIE5vIG5lZWRzIHRvIHRlc3QgaGVyZSBhZ2Fpbi5cbiAgaWYgKChjaCA9PT0gMHgyRC8qIC0gKi8gfHwgY2ggPT09IDB4MkUvKiAuICovKSAmJlxuICAgICAgY2ggPT09IHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoX3Bvc2l0aW9uICsgMSkgJiZcbiAgICAgIGNoID09PSBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KF9wb3NpdGlvbiArIDIpKSB7XG5cbiAgICBfcG9zaXRpb24gKz0gMztcblxuICAgIGNoID0gc3RhdGUuaW5wdXQuY2hhckNvZGVBdChfcG9zaXRpb24pO1xuXG4gICAgaWYgKGNoID09PSAwIHx8IGlzX1dTX09SX0VPTChjaCkpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gd3JpdGVGb2xkZWRMaW5lcyhzdGF0ZSwgY291bnQpIHtcbiAgaWYgKGNvdW50ID09PSAxKSB7XG4gICAgc3RhdGUucmVzdWx0ICs9ICcgJztcbiAgfSBlbHNlIGlmIChjb3VudCA+IDEpIHtcbiAgICBzdGF0ZS5yZXN1bHQgKz0gY29tbW9uLnJlcGVhdCgnXFxuJywgY291bnQgLSAxKTtcbiAgfVxufVxuXG5cbmZ1bmN0aW9uIHJlYWRQbGFpblNjYWxhcihzdGF0ZSwgbm9kZUluZGVudCwgd2l0aGluRmxvd0NvbGxlY3Rpb24pIHtcbiAgdmFyIHByZWNlZGluZyxcbiAgICAgIGZvbGxvd2luZyxcbiAgICAgIGNhcHR1cmVTdGFydCxcbiAgICAgIGNhcHR1cmVFbmQsXG4gICAgICBoYXNQZW5kaW5nQ29udGVudCxcbiAgICAgIF9saW5lLFxuICAgICAgX2xpbmVTdGFydCxcbiAgICAgIF9saW5lSW5kZW50LFxuICAgICAgX2tpbmQgPSBzdGF0ZS5raW5kLFxuICAgICAgX3Jlc3VsdCA9IHN0YXRlLnJlc3VsdCxcbiAgICAgIGNoO1xuXG4gIGNoID0gc3RhdGUuaW5wdXQuY2hhckNvZGVBdChzdGF0ZS5wb3NpdGlvbik7XG5cbiAgaWYgKGlzX1dTX09SX0VPTChjaCkgICAgICB8fFxuICAgICAgaXNfRkxPV19JTkRJQ0FUT1IoY2gpIHx8XG4gICAgICBjaCA9PT0gMHgyMy8qICMgKi8gICAgfHxcbiAgICAgIGNoID09PSAweDI2LyogJiAqLyAgICB8fFxuICAgICAgY2ggPT09IDB4MkEvKiAqICovICAgIHx8XG4gICAgICBjaCA9PT0gMHgyMS8qICEgKi8gICAgfHxcbiAgICAgIGNoID09PSAweDdDLyogfCAqLyAgICB8fFxuICAgICAgY2ggPT09IDB4M0UvKiA+ICovICAgIHx8XG4gICAgICBjaCA9PT0gMHgyNy8qICcgKi8gICAgfHxcbiAgICAgIGNoID09PSAweDIyLyogXCIgKi8gICAgfHxcbiAgICAgIGNoID09PSAweDI1LyogJSAqLyAgICB8fFxuICAgICAgY2ggPT09IDB4NDAvKiBAICovICAgIHx8XG4gICAgICBjaCA9PT0gMHg2MC8qIGAgKi8pIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBpZiAoY2ggPT09IDB4M0YvKiA/ICovIHx8IGNoID09PSAweDJELyogLSAqLykge1xuICAgIGZvbGxvd2luZyA9IHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoc3RhdGUucG9zaXRpb24gKyAxKTtcblxuICAgIGlmIChpc19XU19PUl9FT0woZm9sbG93aW5nKSB8fFxuICAgICAgICB3aXRoaW5GbG93Q29sbGVjdGlvbiAmJiBpc19GTE9XX0lORElDQVRPUihmb2xsb3dpbmcpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgc3RhdGUua2luZCA9ICdzY2FsYXInO1xuICBzdGF0ZS5yZXN1bHQgPSAnJztcbiAgY2FwdHVyZVN0YXJ0ID0gY2FwdHVyZUVuZCA9IHN0YXRlLnBvc2l0aW9uO1xuICBoYXNQZW5kaW5nQ29udGVudCA9IGZhbHNlO1xuXG4gIHdoaWxlIChjaCAhPT0gMCkge1xuICAgIGlmIChjaCA9PT0gMHgzQS8qIDogKi8pIHtcbiAgICAgIGZvbGxvd2luZyA9IHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoc3RhdGUucG9zaXRpb24gKyAxKTtcblxuICAgICAgaWYgKGlzX1dTX09SX0VPTChmb2xsb3dpbmcpIHx8XG4gICAgICAgICAgd2l0aGluRmxvd0NvbGxlY3Rpb24gJiYgaXNfRkxPV19JTkRJQ0FUT1IoZm9sbG93aW5nKSkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgIH0gZWxzZSBpZiAoY2ggPT09IDB4MjMvKiAjICovKSB7XG4gICAgICBwcmVjZWRpbmcgPSBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KHN0YXRlLnBvc2l0aW9uIC0gMSk7XG5cbiAgICAgIGlmIChpc19XU19PUl9FT0wocHJlY2VkaW5nKSkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgIH0gZWxzZSBpZiAoKHN0YXRlLnBvc2l0aW9uID09PSBzdGF0ZS5saW5lU3RhcnQgJiYgdGVzdERvY3VtZW50U2VwYXJhdG9yKHN0YXRlKSkgfHxcbiAgICAgICAgICAgICAgIHdpdGhpbkZsb3dDb2xsZWN0aW9uICYmIGlzX0ZMT1dfSU5ESUNBVE9SKGNoKSkge1xuICAgICAgYnJlYWs7XG5cbiAgICB9IGVsc2UgaWYgKGlzX0VPTChjaCkpIHtcbiAgICAgIF9saW5lID0gc3RhdGUubGluZTtcbiAgICAgIF9saW5lU3RhcnQgPSBzdGF0ZS5saW5lU3RhcnQ7XG4gICAgICBfbGluZUluZGVudCA9IHN0YXRlLmxpbmVJbmRlbnQ7XG4gICAgICBza2lwU2VwYXJhdGlvblNwYWNlKHN0YXRlLCBmYWxzZSwgLTEpO1xuXG4gICAgICBpZiAoc3RhdGUubGluZUluZGVudCA+PSBub2RlSW5kZW50KSB7XG4gICAgICAgIGhhc1BlbmRpbmdDb250ZW50ID0gdHJ1ZTtcbiAgICAgICAgY2ggPSBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KHN0YXRlLnBvc2l0aW9uKTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzdGF0ZS5wb3NpdGlvbiA9IGNhcHR1cmVFbmQ7XG4gICAgICAgIHN0YXRlLmxpbmUgPSBfbGluZTtcbiAgICAgICAgc3RhdGUubGluZVN0YXJ0ID0gX2xpbmVTdGFydDtcbiAgICAgICAgc3RhdGUubGluZUluZGVudCA9IF9saW5lSW5kZW50O1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoaGFzUGVuZGluZ0NvbnRlbnQpIHtcbiAgICAgIGNhcHR1cmVTZWdtZW50KHN0YXRlLCBjYXB0dXJlU3RhcnQsIGNhcHR1cmVFbmQsIGZhbHNlKTtcbiAgICAgIHdyaXRlRm9sZGVkTGluZXMoc3RhdGUsIHN0YXRlLmxpbmUgLSBfbGluZSk7XG4gICAgICBjYXB0dXJlU3RhcnQgPSBjYXB0dXJlRW5kID0gc3RhdGUucG9zaXRpb247XG4gICAgICBoYXNQZW5kaW5nQ29udGVudCA9IGZhbHNlO1xuICAgIH1cblxuICAgIGlmICghaXNfV0hJVEVfU1BBQ0UoY2gpKSB7XG4gICAgICBjYXB0dXJlRW5kID0gc3RhdGUucG9zaXRpb24gKyAxO1xuICAgIH1cblxuICAgIGNoID0gc3RhdGUuaW5wdXQuY2hhckNvZGVBdCgrK3N0YXRlLnBvc2l0aW9uKTtcbiAgfVxuXG4gIGNhcHR1cmVTZWdtZW50KHN0YXRlLCBjYXB0dXJlU3RhcnQsIGNhcHR1cmVFbmQsIGZhbHNlKTtcblxuICBpZiAoc3RhdGUucmVzdWx0KSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICBzdGF0ZS5raW5kID0gX2tpbmQ7XG4gIHN0YXRlLnJlc3VsdCA9IF9yZXN1bHQ7XG4gIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gcmVhZFNpbmdsZVF1b3RlZFNjYWxhcihzdGF0ZSwgbm9kZUluZGVudCkge1xuICB2YXIgY2gsXG4gICAgICBjYXB0dXJlU3RhcnQsIGNhcHR1cmVFbmQ7XG5cbiAgY2ggPSBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KHN0YXRlLnBvc2l0aW9uKTtcblxuICBpZiAoY2ggIT09IDB4MjcvKiAnICovKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgc3RhdGUua2luZCA9ICdzY2FsYXInO1xuICBzdGF0ZS5yZXN1bHQgPSAnJztcbiAgc3RhdGUucG9zaXRpb24rKztcbiAgY2FwdHVyZVN0YXJ0ID0gY2FwdHVyZUVuZCA9IHN0YXRlLnBvc2l0aW9uO1xuXG4gIHdoaWxlICgoY2ggPSBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KHN0YXRlLnBvc2l0aW9uKSkgIT09IDApIHtcbiAgICBpZiAoY2ggPT09IDB4MjcvKiAnICovKSB7XG4gICAgICBjYXB0dXJlU2VnbWVudChzdGF0ZSwgY2FwdHVyZVN0YXJ0LCBzdGF0ZS5wb3NpdGlvbiwgdHJ1ZSk7XG4gICAgICBjaCA9IHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoKytzdGF0ZS5wb3NpdGlvbik7XG5cbiAgICAgIGlmIChjaCA9PT0gMHgyNy8qICcgKi8pIHtcbiAgICAgICAgY2FwdHVyZVN0YXJ0ID0gc3RhdGUucG9zaXRpb247XG4gICAgICAgIHN0YXRlLnBvc2l0aW9uKys7XG4gICAgICAgIGNhcHR1cmVFbmQgPSBzdGF0ZS5wb3NpdGlvbjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuXG4gICAgfSBlbHNlIGlmIChpc19FT0woY2gpKSB7XG4gICAgICBjYXB0dXJlU2VnbWVudChzdGF0ZSwgY2FwdHVyZVN0YXJ0LCBjYXB0dXJlRW5kLCB0cnVlKTtcbiAgICAgIHdyaXRlRm9sZGVkTGluZXMoc3RhdGUsIHNraXBTZXBhcmF0aW9uU3BhY2Uoc3RhdGUsIGZhbHNlLCBub2RlSW5kZW50KSk7XG4gICAgICBjYXB0dXJlU3RhcnQgPSBjYXB0dXJlRW5kID0gc3RhdGUucG9zaXRpb247XG5cbiAgICB9IGVsc2UgaWYgKHN0YXRlLnBvc2l0aW9uID09PSBzdGF0ZS5saW5lU3RhcnQgJiYgdGVzdERvY3VtZW50U2VwYXJhdG9yKHN0YXRlKSkge1xuICAgICAgdGhyb3dFcnJvcihzdGF0ZSwgJ3VuZXhwZWN0ZWQgZW5kIG9mIHRoZSBkb2N1bWVudCB3aXRoaW4gYSBzaW5nbGUgcXVvdGVkIHNjYWxhcicpO1xuXG4gICAgfSBlbHNlIHtcbiAgICAgIHN0YXRlLnBvc2l0aW9uKys7XG4gICAgICBjYXB0dXJlRW5kID0gc3RhdGUucG9zaXRpb247XG4gICAgfVxuICB9XG5cbiAgdGhyb3dFcnJvcihzdGF0ZSwgJ3VuZXhwZWN0ZWQgZW5kIG9mIHRoZSBzdHJlYW0gd2l0aGluIGEgc2luZ2xlIHF1b3RlZCBzY2FsYXInKTtcbn1cblxuZnVuY3Rpb24gcmVhZERvdWJsZVF1b3RlZFNjYWxhcihzdGF0ZSwgbm9kZUluZGVudCkge1xuICB2YXIgY2FwdHVyZVN0YXJ0LFxuICAgICAgY2FwdHVyZUVuZCxcbiAgICAgIGhleExlbmd0aCxcbiAgICAgIGhleFJlc3VsdCxcbiAgICAgIHRtcCxcbiAgICAgIGNoO1xuXG4gIGNoID0gc3RhdGUuaW5wdXQuY2hhckNvZGVBdChzdGF0ZS5wb3NpdGlvbik7XG5cbiAgaWYgKGNoICE9PSAweDIyLyogXCIgKi8pIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBzdGF0ZS5raW5kID0gJ3NjYWxhcic7XG4gIHN0YXRlLnJlc3VsdCA9ICcnO1xuICBzdGF0ZS5wb3NpdGlvbisrO1xuICBjYXB0dXJlU3RhcnQgPSBjYXB0dXJlRW5kID0gc3RhdGUucG9zaXRpb247XG5cbiAgd2hpbGUgKChjaCA9IHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoc3RhdGUucG9zaXRpb24pKSAhPT0gMCkge1xuICAgIGlmIChjaCA9PT0gMHgyMi8qIFwiICovKSB7XG4gICAgICBjYXB0dXJlU2VnbWVudChzdGF0ZSwgY2FwdHVyZVN0YXJ0LCBzdGF0ZS5wb3NpdGlvbiwgdHJ1ZSk7XG4gICAgICBzdGF0ZS5wb3NpdGlvbisrO1xuICAgICAgcmV0dXJuIHRydWU7XG5cbiAgICB9IGVsc2UgaWYgKGNoID09PSAweDVDLyogXFwgKi8pIHtcbiAgICAgIGNhcHR1cmVTZWdtZW50KHN0YXRlLCBjYXB0dXJlU3RhcnQsIHN0YXRlLnBvc2l0aW9uLCB0cnVlKTtcbiAgICAgIGNoID0gc3RhdGUuaW5wdXQuY2hhckNvZGVBdCgrK3N0YXRlLnBvc2l0aW9uKTtcblxuICAgICAgaWYgKGlzX0VPTChjaCkpIHtcbiAgICAgICAgc2tpcFNlcGFyYXRpb25TcGFjZShzdGF0ZSwgZmFsc2UsIG5vZGVJbmRlbnQpO1xuXG4gICAgICAgIC8vIFRPRE86IHJld29yayB0byBpbmxpbmUgZm4gd2l0aCBubyB0eXBlIGNhc3Q/XG4gICAgICB9IGVsc2UgaWYgKGNoIDwgMjU2ICYmIHNpbXBsZUVzY2FwZUNoZWNrW2NoXSkge1xuICAgICAgICBzdGF0ZS5yZXN1bHQgKz0gc2ltcGxlRXNjYXBlTWFwW2NoXTtcbiAgICAgICAgc3RhdGUucG9zaXRpb24rKztcblxuICAgICAgfSBlbHNlIGlmICgodG1wID0gZXNjYXBlZEhleExlbihjaCkpID4gMCkge1xuICAgICAgICBoZXhMZW5ndGggPSB0bXA7XG4gICAgICAgIGhleFJlc3VsdCA9IDA7XG5cbiAgICAgICAgZm9yICg7IGhleExlbmd0aCA+IDA7IGhleExlbmd0aC0tKSB7XG4gICAgICAgICAgY2ggPSBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KCsrc3RhdGUucG9zaXRpb24pO1xuXG4gICAgICAgICAgaWYgKCh0bXAgPSBmcm9tSGV4Q29kZShjaCkpID49IDApIHtcbiAgICAgICAgICAgIGhleFJlc3VsdCA9IChoZXhSZXN1bHQgPDwgNCkgKyB0bXA7XG5cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhyb3dFcnJvcihzdGF0ZSwgJ2V4cGVjdGVkIGhleGFkZWNpbWFsIGNoYXJhY3RlcicpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHN0YXRlLnJlc3VsdCArPSBjaGFyRnJvbUNvZGVwb2ludChoZXhSZXN1bHQpO1xuXG4gICAgICAgIHN0YXRlLnBvc2l0aW9uKys7XG5cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93RXJyb3Ioc3RhdGUsICd1bmtub3duIGVzY2FwZSBzZXF1ZW5jZScpO1xuICAgICAgfVxuXG4gICAgICBjYXB0dXJlU3RhcnQgPSBjYXB0dXJlRW5kID0gc3RhdGUucG9zaXRpb247XG5cbiAgICB9IGVsc2UgaWYgKGlzX0VPTChjaCkpIHtcbiAgICAgIGNhcHR1cmVTZWdtZW50KHN0YXRlLCBjYXB0dXJlU3RhcnQsIGNhcHR1cmVFbmQsIHRydWUpO1xuICAgICAgd3JpdGVGb2xkZWRMaW5lcyhzdGF0ZSwgc2tpcFNlcGFyYXRpb25TcGFjZShzdGF0ZSwgZmFsc2UsIG5vZGVJbmRlbnQpKTtcbiAgICAgIGNhcHR1cmVTdGFydCA9IGNhcHR1cmVFbmQgPSBzdGF0ZS5wb3NpdGlvbjtcblxuICAgIH0gZWxzZSBpZiAoc3RhdGUucG9zaXRpb24gPT09IHN0YXRlLmxpbmVTdGFydCAmJiB0ZXN0RG9jdW1lbnRTZXBhcmF0b3Ioc3RhdGUpKSB7XG4gICAgICB0aHJvd0Vycm9yKHN0YXRlLCAndW5leHBlY3RlZCBlbmQgb2YgdGhlIGRvY3VtZW50IHdpdGhpbiBhIGRvdWJsZSBxdW90ZWQgc2NhbGFyJyk7XG5cbiAgICB9IGVsc2Uge1xuICAgICAgc3RhdGUucG9zaXRpb24rKztcbiAgICAgIGNhcHR1cmVFbmQgPSBzdGF0ZS5wb3NpdGlvbjtcbiAgICB9XG4gIH1cblxuICB0aHJvd0Vycm9yKHN0YXRlLCAndW5leHBlY3RlZCBlbmQgb2YgdGhlIHN0cmVhbSB3aXRoaW4gYSBkb3VibGUgcXVvdGVkIHNjYWxhcicpO1xufVxuXG5mdW5jdGlvbiByZWFkRmxvd0NvbGxlY3Rpb24oc3RhdGUsIG5vZGVJbmRlbnQpIHtcbiAgdmFyIHJlYWROZXh0ID0gdHJ1ZSxcbiAgICAgIF9saW5lLFxuICAgICAgX3RhZyAgICAgPSBzdGF0ZS50YWcsXG4gICAgICBfcmVzdWx0LFxuICAgICAgX2FuY2hvciAgPSBzdGF0ZS5hbmNob3IsXG4gICAgICBmb2xsb3dpbmcsXG4gICAgICB0ZXJtaW5hdG9yLFxuICAgICAgaXNQYWlyLFxuICAgICAgaXNFeHBsaWNpdFBhaXIsXG4gICAgICBpc01hcHBpbmcsXG4gICAgICBvdmVycmlkYWJsZUtleXMgPSB7fSxcbiAgICAgIGtleU5vZGUsXG4gICAgICBrZXlUYWcsXG4gICAgICB2YWx1ZU5vZGUsXG4gICAgICBjaDtcblxuICBjaCA9IHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoc3RhdGUucG9zaXRpb24pO1xuXG4gIGlmIChjaCA9PT0gMHg1Qi8qIFsgKi8pIHtcbiAgICB0ZXJtaW5hdG9yID0gMHg1RDsvKiBdICovXG4gICAgaXNNYXBwaW5nID0gZmFsc2U7XG4gICAgX3Jlc3VsdCA9IFtdO1xuICB9IGVsc2UgaWYgKGNoID09PSAweDdCLyogeyAqLykge1xuICAgIHRlcm1pbmF0b3IgPSAweDdEOy8qIH0gKi9cbiAgICBpc01hcHBpbmcgPSB0cnVlO1xuICAgIF9yZXN1bHQgPSB7fTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBpZiAoc3RhdGUuYW5jaG9yICE9PSBudWxsKSB7XG4gICAgc3RhdGUuYW5jaG9yTWFwW3N0YXRlLmFuY2hvcl0gPSBfcmVzdWx0O1xuICB9XG5cbiAgY2ggPSBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KCsrc3RhdGUucG9zaXRpb24pO1xuXG4gIHdoaWxlIChjaCAhPT0gMCkge1xuICAgIHNraXBTZXBhcmF0aW9uU3BhY2Uoc3RhdGUsIHRydWUsIG5vZGVJbmRlbnQpO1xuXG4gICAgY2ggPSBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KHN0YXRlLnBvc2l0aW9uKTtcblxuICAgIGlmIChjaCA9PT0gdGVybWluYXRvcikge1xuICAgICAgc3RhdGUucG9zaXRpb24rKztcbiAgICAgIHN0YXRlLnRhZyA9IF90YWc7XG4gICAgICBzdGF0ZS5hbmNob3IgPSBfYW5jaG9yO1xuICAgICAgc3RhdGUua2luZCA9IGlzTWFwcGluZyA/ICdtYXBwaW5nJyA6ICdzZXF1ZW5jZSc7XG4gICAgICBzdGF0ZS5yZXN1bHQgPSBfcmVzdWx0O1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIGlmICghcmVhZE5leHQpIHtcbiAgICAgIHRocm93RXJyb3Ioc3RhdGUsICdtaXNzZWQgY29tbWEgYmV0d2VlbiBmbG93IGNvbGxlY3Rpb24gZW50cmllcycpO1xuICAgIH1cblxuICAgIGtleVRhZyA9IGtleU5vZGUgPSB2YWx1ZU5vZGUgPSBudWxsO1xuICAgIGlzUGFpciA9IGlzRXhwbGljaXRQYWlyID0gZmFsc2U7XG5cbiAgICBpZiAoY2ggPT09IDB4M0YvKiA/ICovKSB7XG4gICAgICBmb2xsb3dpbmcgPSBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KHN0YXRlLnBvc2l0aW9uICsgMSk7XG5cbiAgICAgIGlmIChpc19XU19PUl9FT0woZm9sbG93aW5nKSkge1xuICAgICAgICBpc1BhaXIgPSBpc0V4cGxpY2l0UGFpciA9IHRydWU7XG4gICAgICAgIHN0YXRlLnBvc2l0aW9uKys7XG4gICAgICAgIHNraXBTZXBhcmF0aW9uU3BhY2Uoc3RhdGUsIHRydWUsIG5vZGVJbmRlbnQpO1xuICAgICAgfVxuICAgIH1cblxuICAgIF9saW5lID0gc3RhdGUubGluZTtcbiAgICBjb21wb3NlTm9kZShzdGF0ZSwgbm9kZUluZGVudCwgQ09OVEVYVF9GTE9XX0lOLCBmYWxzZSwgdHJ1ZSk7XG4gICAga2V5VGFnID0gc3RhdGUudGFnO1xuICAgIGtleU5vZGUgPSBzdGF0ZS5yZXN1bHQ7XG4gICAgc2tpcFNlcGFyYXRpb25TcGFjZShzdGF0ZSwgdHJ1ZSwgbm9kZUluZGVudCk7XG5cbiAgICBjaCA9IHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoc3RhdGUucG9zaXRpb24pO1xuXG4gICAgaWYgKChpc0V4cGxpY2l0UGFpciB8fCBzdGF0ZS5saW5lID09PSBfbGluZSkgJiYgY2ggPT09IDB4M0EvKiA6ICovKSB7XG4gICAgICBpc1BhaXIgPSB0cnVlO1xuICAgICAgY2ggPSBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KCsrc3RhdGUucG9zaXRpb24pO1xuICAgICAgc2tpcFNlcGFyYXRpb25TcGFjZShzdGF0ZSwgdHJ1ZSwgbm9kZUluZGVudCk7XG4gICAgICBjb21wb3NlTm9kZShzdGF0ZSwgbm9kZUluZGVudCwgQ09OVEVYVF9GTE9XX0lOLCBmYWxzZSwgdHJ1ZSk7XG4gICAgICB2YWx1ZU5vZGUgPSBzdGF0ZS5yZXN1bHQ7XG4gICAgfVxuXG4gICAgaWYgKGlzTWFwcGluZykge1xuICAgICAgc3RvcmVNYXBwaW5nUGFpcihzdGF0ZSwgX3Jlc3VsdCwgb3ZlcnJpZGFibGVLZXlzLCBrZXlUYWcsIGtleU5vZGUsIHZhbHVlTm9kZSk7XG4gICAgfSBlbHNlIGlmIChpc1BhaXIpIHtcbiAgICAgIF9yZXN1bHQucHVzaChzdG9yZU1hcHBpbmdQYWlyKHN0YXRlLCBudWxsLCBvdmVycmlkYWJsZUtleXMsIGtleVRhZywga2V5Tm9kZSwgdmFsdWVOb2RlKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIF9yZXN1bHQucHVzaChrZXlOb2RlKTtcbiAgICB9XG5cbiAgICBza2lwU2VwYXJhdGlvblNwYWNlKHN0YXRlLCB0cnVlLCBub2RlSW5kZW50KTtcblxuICAgIGNoID0gc3RhdGUuaW5wdXQuY2hhckNvZGVBdChzdGF0ZS5wb3NpdGlvbik7XG5cbiAgICBpZiAoY2ggPT09IDB4MkMvKiAsICovKSB7XG4gICAgICByZWFkTmV4dCA9IHRydWU7XG4gICAgICBjaCA9IHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoKytzdGF0ZS5wb3NpdGlvbik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlYWROZXh0ID0gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgdGhyb3dFcnJvcihzdGF0ZSwgJ3VuZXhwZWN0ZWQgZW5kIG9mIHRoZSBzdHJlYW0gd2l0aGluIGEgZmxvdyBjb2xsZWN0aW9uJyk7XG59XG5cbmZ1bmN0aW9uIHJlYWRCbG9ja1NjYWxhcihzdGF0ZSwgbm9kZUluZGVudCkge1xuICB2YXIgY2FwdHVyZVN0YXJ0LFxuICAgICAgZm9sZGluZyxcbiAgICAgIGNob21waW5nICAgICAgID0gQ0hPTVBJTkdfQ0xJUCxcbiAgICAgIGRpZFJlYWRDb250ZW50ID0gZmFsc2UsXG4gICAgICBkZXRlY3RlZEluZGVudCA9IGZhbHNlLFxuICAgICAgdGV4dEluZGVudCAgICAgPSBub2RlSW5kZW50LFxuICAgICAgZW1wdHlMaW5lcyAgICAgPSAwLFxuICAgICAgYXRNb3JlSW5kZW50ZWQgPSBmYWxzZSxcbiAgICAgIHRtcCxcbiAgICAgIGNoO1xuXG4gIGNoID0gc3RhdGUuaW5wdXQuY2hhckNvZGVBdChzdGF0ZS5wb3NpdGlvbik7XG5cbiAgaWYgKGNoID09PSAweDdDLyogfCAqLykge1xuICAgIGZvbGRpbmcgPSBmYWxzZTtcbiAgfSBlbHNlIGlmIChjaCA9PT0gMHgzRS8qID4gKi8pIHtcbiAgICBmb2xkaW5nID0gdHJ1ZTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBzdGF0ZS5raW5kID0gJ3NjYWxhcic7XG4gIHN0YXRlLnJlc3VsdCA9ICcnO1xuXG4gIHdoaWxlIChjaCAhPT0gMCkge1xuICAgIGNoID0gc3RhdGUuaW5wdXQuY2hhckNvZGVBdCgrK3N0YXRlLnBvc2l0aW9uKTtcblxuICAgIGlmIChjaCA9PT0gMHgyQi8qICsgKi8gfHwgY2ggPT09IDB4MkQvKiAtICovKSB7XG4gICAgICBpZiAoQ0hPTVBJTkdfQ0xJUCA9PT0gY2hvbXBpbmcpIHtcbiAgICAgICAgY2hvbXBpbmcgPSAoY2ggPT09IDB4MkIvKiArICovKSA/IENIT01QSU5HX0tFRVAgOiBDSE9NUElOR19TVFJJUDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93RXJyb3Ioc3RhdGUsICdyZXBlYXQgb2YgYSBjaG9tcGluZyBtb2RlIGlkZW50aWZpZXInKTtcbiAgICAgIH1cblxuICAgIH0gZWxzZSBpZiAoKHRtcCA9IGZyb21EZWNpbWFsQ29kZShjaCkpID49IDApIHtcbiAgICAgIGlmICh0bXAgPT09IDApIHtcbiAgICAgICAgdGhyb3dFcnJvcihzdGF0ZSwgJ2JhZCBleHBsaWNpdCBpbmRlbnRhdGlvbiB3aWR0aCBvZiBhIGJsb2NrIHNjYWxhcjsgaXQgY2Fubm90IGJlIGxlc3MgdGhhbiBvbmUnKTtcbiAgICAgIH0gZWxzZSBpZiAoIWRldGVjdGVkSW5kZW50KSB7XG4gICAgICAgIHRleHRJbmRlbnQgPSBub2RlSW5kZW50ICsgdG1wIC0gMTtcbiAgICAgICAgZGV0ZWN0ZWRJbmRlbnQgPSB0cnVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3dFcnJvcihzdGF0ZSwgJ3JlcGVhdCBvZiBhbiBpbmRlbnRhdGlvbiB3aWR0aCBpZGVudGlmaWVyJyk7XG4gICAgICB9XG5cbiAgICB9IGVsc2Uge1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG5cbiAgaWYgKGlzX1dISVRFX1NQQUNFKGNoKSkge1xuICAgIGRvIHsgY2ggPSBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KCsrc3RhdGUucG9zaXRpb24pOyB9XG4gICAgd2hpbGUgKGlzX1dISVRFX1NQQUNFKGNoKSk7XG5cbiAgICBpZiAoY2ggPT09IDB4MjMvKiAjICovKSB7XG4gICAgICBkbyB7IGNoID0gc3RhdGUuaW5wdXQuY2hhckNvZGVBdCgrK3N0YXRlLnBvc2l0aW9uKTsgfVxuICAgICAgd2hpbGUgKCFpc19FT0woY2gpICYmIChjaCAhPT0gMCkpO1xuICAgIH1cbiAgfVxuXG4gIHdoaWxlIChjaCAhPT0gMCkge1xuICAgIHJlYWRMaW5lQnJlYWsoc3RhdGUpO1xuICAgIHN0YXRlLmxpbmVJbmRlbnQgPSAwO1xuXG4gICAgY2ggPSBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KHN0YXRlLnBvc2l0aW9uKTtcblxuICAgIHdoaWxlICgoIWRldGVjdGVkSW5kZW50IHx8IHN0YXRlLmxpbmVJbmRlbnQgPCB0ZXh0SW5kZW50KSAmJlxuICAgICAgICAgICAoY2ggPT09IDB4MjAvKiBTcGFjZSAqLykpIHtcbiAgICAgIHN0YXRlLmxpbmVJbmRlbnQrKztcbiAgICAgIGNoID0gc3RhdGUuaW5wdXQuY2hhckNvZGVBdCgrK3N0YXRlLnBvc2l0aW9uKTtcbiAgICB9XG5cbiAgICBpZiAoIWRldGVjdGVkSW5kZW50ICYmIHN0YXRlLmxpbmVJbmRlbnQgPiB0ZXh0SW5kZW50KSB7XG4gICAgICB0ZXh0SW5kZW50ID0gc3RhdGUubGluZUluZGVudDtcbiAgICB9XG5cbiAgICBpZiAoaXNfRU9MKGNoKSkge1xuICAgICAgZW1wdHlMaW5lcysrO1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgLy8gRW5kIG9mIHRoZSBzY2FsYXIuXG4gICAgaWYgKHN0YXRlLmxpbmVJbmRlbnQgPCB0ZXh0SW5kZW50KSB7XG5cbiAgICAgIC8vIFBlcmZvcm0gdGhlIGNob21waW5nLlxuICAgICAgaWYgKGNob21waW5nID09PSBDSE9NUElOR19LRUVQKSB7XG4gICAgICAgIHN0YXRlLnJlc3VsdCArPSBjb21tb24ucmVwZWF0KCdcXG4nLCBkaWRSZWFkQ29udGVudCA/IDEgKyBlbXB0eUxpbmVzIDogZW1wdHlMaW5lcyk7XG4gICAgICB9IGVsc2UgaWYgKGNob21waW5nID09PSBDSE9NUElOR19DTElQKSB7XG4gICAgICAgIGlmIChkaWRSZWFkQ29udGVudCkgeyAvLyBpLmUuIG9ubHkgaWYgdGhlIHNjYWxhciBpcyBub3QgZW1wdHkuXG4gICAgICAgICAgc3RhdGUucmVzdWx0ICs9ICdcXG4nO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIEJyZWFrIHRoaXMgYHdoaWxlYCBjeWNsZSBhbmQgZ28gdG8gdGhlIGZ1bmNpdG9uJ3MgZXBpbG9ndWUuXG4gICAgICBicmVhaztcbiAgICB9XG5cbiAgICAvLyBGb2xkZWQgc3R5bGU6IHVzZSBmYW5jeSBydWxlcyB0byBoYW5kbGUgbGluZSBicmVha3MuXG4gICAgaWYgKGZvbGRpbmcpIHtcblxuICAgICAgLy8gTGluZXMgc3RhcnRpbmcgd2l0aCB3aGl0ZSBzcGFjZSBjaGFyYWN0ZXJzIChtb3JlLWluZGVudGVkIGxpbmVzKSBhcmUgbm90IGZvbGRlZC5cbiAgICAgIGlmIChpc19XSElURV9TUEFDRShjaCkpIHtcbiAgICAgICAgYXRNb3JlSW5kZW50ZWQgPSB0cnVlO1xuICAgICAgICAvLyBleGNlcHQgZm9yIHRoZSBmaXJzdCBjb250ZW50IGxpbmUgKGNmLiBFeGFtcGxlIDguMSlcbiAgICAgICAgc3RhdGUucmVzdWx0ICs9IGNvbW1vbi5yZXBlYXQoJ1xcbicsIGRpZFJlYWRDb250ZW50ID8gMSArIGVtcHR5TGluZXMgOiBlbXB0eUxpbmVzKTtcblxuICAgICAgLy8gRW5kIG9mIG1vcmUtaW5kZW50ZWQgYmxvY2suXG4gICAgICB9IGVsc2UgaWYgKGF0TW9yZUluZGVudGVkKSB7XG4gICAgICAgIGF0TW9yZUluZGVudGVkID0gZmFsc2U7XG4gICAgICAgIHN0YXRlLnJlc3VsdCArPSBjb21tb24ucmVwZWF0KCdcXG4nLCBlbXB0eUxpbmVzICsgMSk7XG5cbiAgICAgIC8vIEp1c3Qgb25lIGxpbmUgYnJlYWsgLSBwZXJjZWl2ZSBhcyB0aGUgc2FtZSBsaW5lLlxuICAgICAgfSBlbHNlIGlmIChlbXB0eUxpbmVzID09PSAwKSB7XG4gICAgICAgIGlmIChkaWRSZWFkQ29udGVudCkgeyAvLyBpLmUuIG9ubHkgaWYgd2UgaGF2ZSBhbHJlYWR5IHJlYWQgc29tZSBzY2FsYXIgY29udGVudC5cbiAgICAgICAgICBzdGF0ZS5yZXN1bHQgKz0gJyAnO1xuICAgICAgICB9XG5cbiAgICAgIC8vIFNldmVyYWwgbGluZSBicmVha3MgLSBwZXJjZWl2ZSBhcyBkaWZmZXJlbnQgbGluZXMuXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzdGF0ZS5yZXN1bHQgKz0gY29tbW9uLnJlcGVhdCgnXFxuJywgZW1wdHlMaW5lcyk7XG4gICAgICB9XG5cbiAgICAvLyBMaXRlcmFsIHN0eWxlOiBqdXN0IGFkZCBleGFjdCBudW1iZXIgb2YgbGluZSBicmVha3MgYmV0d2VlbiBjb250ZW50IGxpbmVzLlxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBLZWVwIGFsbCBsaW5lIGJyZWFrcyBleGNlcHQgdGhlIGhlYWRlciBsaW5lIGJyZWFrLlxuICAgICAgc3RhdGUucmVzdWx0ICs9IGNvbW1vbi5yZXBlYXQoJ1xcbicsIGRpZFJlYWRDb250ZW50ID8gMSArIGVtcHR5TGluZXMgOiBlbXB0eUxpbmVzKTtcbiAgICB9XG5cbiAgICBkaWRSZWFkQ29udGVudCA9IHRydWU7XG4gICAgZGV0ZWN0ZWRJbmRlbnQgPSB0cnVlO1xuICAgIGVtcHR5TGluZXMgPSAwO1xuICAgIGNhcHR1cmVTdGFydCA9IHN0YXRlLnBvc2l0aW9uO1xuXG4gICAgd2hpbGUgKCFpc19FT0woY2gpICYmIChjaCAhPT0gMCkpIHtcbiAgICAgIGNoID0gc3RhdGUuaW5wdXQuY2hhckNvZGVBdCgrK3N0YXRlLnBvc2l0aW9uKTtcbiAgICB9XG5cbiAgICBjYXB0dXJlU2VnbWVudChzdGF0ZSwgY2FwdHVyZVN0YXJ0LCBzdGF0ZS5wb3NpdGlvbiwgZmFsc2UpO1xuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59XG5cbmZ1bmN0aW9uIHJlYWRCbG9ja1NlcXVlbmNlKHN0YXRlLCBub2RlSW5kZW50KSB7XG4gIHZhciBfbGluZSxcbiAgICAgIF90YWcgICAgICA9IHN0YXRlLnRhZyxcbiAgICAgIF9hbmNob3IgICA9IHN0YXRlLmFuY2hvcixcbiAgICAgIF9yZXN1bHQgICA9IFtdLFxuICAgICAgZm9sbG93aW5nLFxuICAgICAgZGV0ZWN0ZWQgID0gZmFsc2UsXG4gICAgICBjaDtcblxuICBpZiAoc3RhdGUuYW5jaG9yICE9PSBudWxsKSB7XG4gICAgc3RhdGUuYW5jaG9yTWFwW3N0YXRlLmFuY2hvcl0gPSBfcmVzdWx0O1xuICB9XG5cbiAgY2ggPSBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KHN0YXRlLnBvc2l0aW9uKTtcblxuICB3aGlsZSAoY2ggIT09IDApIHtcblxuICAgIGlmIChjaCAhPT0gMHgyRC8qIC0gKi8pIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIGZvbGxvd2luZyA9IHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoc3RhdGUucG9zaXRpb24gKyAxKTtcblxuICAgIGlmICghaXNfV1NfT1JfRU9MKGZvbGxvd2luZykpIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIGRldGVjdGVkID0gdHJ1ZTtcbiAgICBzdGF0ZS5wb3NpdGlvbisrO1xuXG4gICAgaWYgKHNraXBTZXBhcmF0aW9uU3BhY2Uoc3RhdGUsIHRydWUsIC0xKSkge1xuICAgICAgaWYgKHN0YXRlLmxpbmVJbmRlbnQgPD0gbm9kZUluZGVudCkge1xuICAgICAgICBfcmVzdWx0LnB1c2gobnVsbCk7XG4gICAgICAgIGNoID0gc3RhdGUuaW5wdXQuY2hhckNvZGVBdChzdGF0ZS5wb3NpdGlvbik7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIF9saW5lID0gc3RhdGUubGluZTtcbiAgICBjb21wb3NlTm9kZShzdGF0ZSwgbm9kZUluZGVudCwgQ09OVEVYVF9CTE9DS19JTiwgZmFsc2UsIHRydWUpO1xuICAgIF9yZXN1bHQucHVzaChzdGF0ZS5yZXN1bHQpO1xuICAgIHNraXBTZXBhcmF0aW9uU3BhY2Uoc3RhdGUsIHRydWUsIC0xKTtcblxuICAgIGNoID0gc3RhdGUuaW5wdXQuY2hhckNvZGVBdChzdGF0ZS5wb3NpdGlvbik7XG5cbiAgICBpZiAoKHN0YXRlLmxpbmUgPT09IF9saW5lIHx8IHN0YXRlLmxpbmVJbmRlbnQgPiBub2RlSW5kZW50KSAmJiAoY2ggIT09IDApKSB7XG4gICAgICB0aHJvd0Vycm9yKHN0YXRlLCAnYmFkIGluZGVudGF0aW9uIG9mIGEgc2VxdWVuY2UgZW50cnknKTtcbiAgICB9IGVsc2UgaWYgKHN0YXRlLmxpbmVJbmRlbnQgPCBub2RlSW5kZW50KSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cblxuICBpZiAoZGV0ZWN0ZWQpIHtcbiAgICBzdGF0ZS50YWcgPSBfdGFnO1xuICAgIHN0YXRlLmFuY2hvciA9IF9hbmNob3I7XG4gICAgc3RhdGUua2luZCA9ICdzZXF1ZW5jZSc7XG4gICAgc3RhdGUucmVzdWx0ID0gX3Jlc3VsdDtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIHJlYWRCbG9ja01hcHBpbmcoc3RhdGUsIG5vZGVJbmRlbnQsIGZsb3dJbmRlbnQpIHtcbiAgdmFyIGZvbGxvd2luZyxcbiAgICAgIGFsbG93Q29tcGFjdCxcbiAgICAgIF9saW5lLFxuICAgICAgX3BvcyxcbiAgICAgIF90YWcgICAgICAgICAgPSBzdGF0ZS50YWcsXG4gICAgICBfYW5jaG9yICAgICAgID0gc3RhdGUuYW5jaG9yLFxuICAgICAgX3Jlc3VsdCAgICAgICA9IHt9LFxuICAgICAgb3ZlcnJpZGFibGVLZXlzID0ge30sXG4gICAgICBrZXlUYWcgICAgICAgID0gbnVsbCxcbiAgICAgIGtleU5vZGUgICAgICAgPSBudWxsLFxuICAgICAgdmFsdWVOb2RlICAgICA9IG51bGwsXG4gICAgICBhdEV4cGxpY2l0S2V5ID0gZmFsc2UsXG4gICAgICBkZXRlY3RlZCAgICAgID0gZmFsc2UsXG4gICAgICBjaDtcblxuICBpZiAoc3RhdGUuYW5jaG9yICE9PSBudWxsKSB7XG4gICAgc3RhdGUuYW5jaG9yTWFwW3N0YXRlLmFuY2hvcl0gPSBfcmVzdWx0O1xuICB9XG5cbiAgY2ggPSBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KHN0YXRlLnBvc2l0aW9uKTtcblxuICB3aGlsZSAoY2ggIT09IDApIHtcbiAgICBmb2xsb3dpbmcgPSBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KHN0YXRlLnBvc2l0aW9uICsgMSk7XG4gICAgX2xpbmUgPSBzdGF0ZS5saW5lOyAvLyBTYXZlIHRoZSBjdXJyZW50IGxpbmUuXG4gICAgX3BvcyA9IHN0YXRlLnBvc2l0aW9uO1xuXG4gICAgLy9cbiAgICAvLyBFeHBsaWNpdCBub3RhdGlvbiBjYXNlLiBUaGVyZSBhcmUgdHdvIHNlcGFyYXRlIGJsb2NrczpcbiAgICAvLyBmaXJzdCBmb3IgdGhlIGtleSAoZGVub3RlZCBieSBcIj9cIikgYW5kIHNlY29uZCBmb3IgdGhlIHZhbHVlIChkZW5vdGVkIGJ5IFwiOlwiKVxuICAgIC8vXG4gICAgaWYgKChjaCA9PT0gMHgzRi8qID8gKi8gfHwgY2ggPT09IDB4M0EvKiA6ICovKSAmJiBpc19XU19PUl9FT0woZm9sbG93aW5nKSkge1xuXG4gICAgICBpZiAoY2ggPT09IDB4M0YvKiA/ICovKSB7XG4gICAgICAgIGlmIChhdEV4cGxpY2l0S2V5KSB7XG4gICAgICAgICAgc3RvcmVNYXBwaW5nUGFpcihzdGF0ZSwgX3Jlc3VsdCwgb3ZlcnJpZGFibGVLZXlzLCBrZXlUYWcsIGtleU5vZGUsIG51bGwpO1xuICAgICAgICAgIGtleVRhZyA9IGtleU5vZGUgPSB2YWx1ZU5vZGUgPSBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgZGV0ZWN0ZWQgPSB0cnVlO1xuICAgICAgICBhdEV4cGxpY2l0S2V5ID0gdHJ1ZTtcbiAgICAgICAgYWxsb3dDb21wYWN0ID0gdHJ1ZTtcblxuICAgICAgfSBlbHNlIGlmIChhdEV4cGxpY2l0S2V5KSB7XG4gICAgICAgIC8vIGkuZS4gMHgzQS8qIDogKi8gPT09IGNoYXJhY3RlciBhZnRlciB0aGUgZXhwbGljaXQga2V5LlxuICAgICAgICBhdEV4cGxpY2l0S2V5ID0gZmFsc2U7XG4gICAgICAgIGFsbG93Q29tcGFjdCA9IHRydWU7XG5cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93RXJyb3Ioc3RhdGUsICdpbmNvbXBsZXRlIGV4cGxpY2l0IG1hcHBpbmcgcGFpcjsgYSBrZXkgbm9kZSBpcyBtaXNzZWQ7IG9yIGZvbGxvd2VkIGJ5IGEgbm9uLXRhYnVsYXRlZCBlbXB0eSBsaW5lJyk7XG4gICAgICB9XG5cbiAgICAgIHN0YXRlLnBvc2l0aW9uICs9IDE7XG4gICAgICBjaCA9IGZvbGxvd2luZztcblxuICAgIC8vXG4gICAgLy8gSW1wbGljaXQgbm90YXRpb24gY2FzZS4gRmxvdy1zdHlsZSBub2RlIGFzIHRoZSBrZXkgZmlyc3QsIHRoZW4gXCI6XCIsIGFuZCB0aGUgdmFsdWUuXG4gICAgLy9cbiAgICB9IGVsc2UgaWYgKGNvbXBvc2VOb2RlKHN0YXRlLCBmbG93SW5kZW50LCBDT05URVhUX0ZMT1dfT1VULCBmYWxzZSwgdHJ1ZSkpIHtcblxuICAgICAgaWYgKHN0YXRlLmxpbmUgPT09IF9saW5lKSB7XG4gICAgICAgIGNoID0gc3RhdGUuaW5wdXQuY2hhckNvZGVBdChzdGF0ZS5wb3NpdGlvbik7XG5cbiAgICAgICAgd2hpbGUgKGlzX1dISVRFX1NQQUNFKGNoKSkge1xuICAgICAgICAgIGNoID0gc3RhdGUuaW5wdXQuY2hhckNvZGVBdCgrK3N0YXRlLnBvc2l0aW9uKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChjaCA9PT0gMHgzQS8qIDogKi8pIHtcbiAgICAgICAgICBjaCA9IHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoKytzdGF0ZS5wb3NpdGlvbik7XG5cbiAgICAgICAgICBpZiAoIWlzX1dTX09SX0VPTChjaCkpIHtcbiAgICAgICAgICAgIHRocm93RXJyb3Ioc3RhdGUsICdhIHdoaXRlc3BhY2UgY2hhcmFjdGVyIGlzIGV4cGVjdGVkIGFmdGVyIHRoZSBrZXktdmFsdWUgc2VwYXJhdG9yIHdpdGhpbiBhIGJsb2NrIG1hcHBpbmcnKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoYXRFeHBsaWNpdEtleSkge1xuICAgICAgICAgICAgc3RvcmVNYXBwaW5nUGFpcihzdGF0ZSwgX3Jlc3VsdCwgb3ZlcnJpZGFibGVLZXlzLCBrZXlUYWcsIGtleU5vZGUsIG51bGwpO1xuICAgICAgICAgICAga2V5VGFnID0ga2V5Tm9kZSA9IHZhbHVlTm9kZSA9IG51bGw7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZGV0ZWN0ZWQgPSB0cnVlO1xuICAgICAgICAgIGF0RXhwbGljaXRLZXkgPSBmYWxzZTtcbiAgICAgICAgICBhbGxvd0NvbXBhY3QgPSBmYWxzZTtcbiAgICAgICAgICBrZXlUYWcgPSBzdGF0ZS50YWc7XG4gICAgICAgICAga2V5Tm9kZSA9IHN0YXRlLnJlc3VsdDtcblxuICAgICAgICB9IGVsc2UgaWYgKGRldGVjdGVkKSB7XG4gICAgICAgICAgdGhyb3dFcnJvcihzdGF0ZSwgJ2NhbiBub3QgcmVhZCBhbiBpbXBsaWNpdCBtYXBwaW5nIHBhaXI7IGEgY29sb24gaXMgbWlzc2VkJyk7XG5cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzdGF0ZS50YWcgPSBfdGFnO1xuICAgICAgICAgIHN0YXRlLmFuY2hvciA9IF9hbmNob3I7XG4gICAgICAgICAgcmV0dXJuIHRydWU7IC8vIEtlZXAgdGhlIHJlc3VsdCBvZiBgY29tcG9zZU5vZGVgLlxuICAgICAgICB9XG5cbiAgICAgIH0gZWxzZSBpZiAoZGV0ZWN0ZWQpIHtcbiAgICAgICAgdGhyb3dFcnJvcihzdGF0ZSwgJ2NhbiBub3QgcmVhZCBhIGJsb2NrIG1hcHBpbmcgZW50cnk7IGEgbXVsdGlsaW5lIGtleSBtYXkgbm90IGJlIGFuIGltcGxpY2l0IGtleScpO1xuXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzdGF0ZS50YWcgPSBfdGFnO1xuICAgICAgICBzdGF0ZS5hbmNob3IgPSBfYW5jaG9yO1xuICAgICAgICByZXR1cm4gdHJ1ZTsgLy8gS2VlcCB0aGUgcmVzdWx0IG9mIGBjb21wb3NlTm9kZWAuXG4gICAgICB9XG5cbiAgICB9IGVsc2Uge1xuICAgICAgYnJlYWs7IC8vIFJlYWRpbmcgaXMgZG9uZS4gR28gdG8gdGhlIGVwaWxvZ3VlLlxuICAgIH1cblxuICAgIC8vXG4gICAgLy8gQ29tbW9uIHJlYWRpbmcgY29kZSBmb3IgYm90aCBleHBsaWNpdCBhbmQgaW1wbGljaXQgbm90YXRpb25zLlxuICAgIC8vXG4gICAgaWYgKHN0YXRlLmxpbmUgPT09IF9saW5lIHx8IHN0YXRlLmxpbmVJbmRlbnQgPiBub2RlSW5kZW50KSB7XG4gICAgICBpZiAoY29tcG9zZU5vZGUoc3RhdGUsIG5vZGVJbmRlbnQsIENPTlRFWFRfQkxPQ0tfT1VULCB0cnVlLCBhbGxvd0NvbXBhY3QpKSB7XG4gICAgICAgIGlmIChhdEV4cGxpY2l0S2V5KSB7XG4gICAgICAgICAga2V5Tm9kZSA9IHN0YXRlLnJlc3VsdDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YWx1ZU5vZGUgPSBzdGF0ZS5yZXN1bHQ7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKCFhdEV4cGxpY2l0S2V5KSB7XG4gICAgICAgIHN0b3JlTWFwcGluZ1BhaXIoc3RhdGUsIF9yZXN1bHQsIG92ZXJyaWRhYmxlS2V5cywga2V5VGFnLCBrZXlOb2RlLCB2YWx1ZU5vZGUsIF9saW5lLCBfcG9zKTtcbiAgICAgICAga2V5VGFnID0ga2V5Tm9kZSA9IHZhbHVlTm9kZSA9IG51bGw7XG4gICAgICB9XG5cbiAgICAgIHNraXBTZXBhcmF0aW9uU3BhY2Uoc3RhdGUsIHRydWUsIC0xKTtcbiAgICAgIGNoID0gc3RhdGUuaW5wdXQuY2hhckNvZGVBdChzdGF0ZS5wb3NpdGlvbik7XG4gICAgfVxuXG4gICAgaWYgKHN0YXRlLmxpbmVJbmRlbnQgPiBub2RlSW5kZW50ICYmIChjaCAhPT0gMCkpIHtcbiAgICAgIHRocm93RXJyb3Ioc3RhdGUsICdiYWQgaW5kZW50YXRpb24gb2YgYSBtYXBwaW5nIGVudHJ5Jyk7XG4gICAgfSBlbHNlIGlmIChzdGF0ZS5saW5lSW5kZW50IDwgbm9kZUluZGVudCkge1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG5cbiAgLy9cbiAgLy8gRXBpbG9ndWUuXG4gIC8vXG5cbiAgLy8gU3BlY2lhbCBjYXNlOiBsYXN0IG1hcHBpbmcncyBub2RlIGNvbnRhaW5zIG9ubHkgdGhlIGtleSBpbiBleHBsaWNpdCBub3RhdGlvbi5cbiAgaWYgKGF0RXhwbGljaXRLZXkpIHtcbiAgICBzdG9yZU1hcHBpbmdQYWlyKHN0YXRlLCBfcmVzdWx0LCBvdmVycmlkYWJsZUtleXMsIGtleVRhZywga2V5Tm9kZSwgbnVsbCk7XG4gIH1cblxuICAvLyBFeHBvc2UgdGhlIHJlc3VsdGluZyBtYXBwaW5nLlxuICBpZiAoZGV0ZWN0ZWQpIHtcbiAgICBzdGF0ZS50YWcgPSBfdGFnO1xuICAgIHN0YXRlLmFuY2hvciA9IF9hbmNob3I7XG4gICAgc3RhdGUua2luZCA9ICdtYXBwaW5nJztcbiAgICBzdGF0ZS5yZXN1bHQgPSBfcmVzdWx0O1xuICB9XG5cbiAgcmV0dXJuIGRldGVjdGVkO1xufVxuXG5mdW5jdGlvbiByZWFkVGFnUHJvcGVydHkoc3RhdGUpIHtcbiAgdmFyIF9wb3NpdGlvbixcbiAgICAgIGlzVmVyYmF0aW0gPSBmYWxzZSxcbiAgICAgIGlzTmFtZWQgICAgPSBmYWxzZSxcbiAgICAgIHRhZ0hhbmRsZSxcbiAgICAgIHRhZ05hbWUsXG4gICAgICBjaDtcblxuICBjaCA9IHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoc3RhdGUucG9zaXRpb24pO1xuXG4gIGlmIChjaCAhPT0gMHgyMS8qICEgKi8pIHJldHVybiBmYWxzZTtcblxuICBpZiAoc3RhdGUudGFnICE9PSBudWxsKSB7XG4gICAgdGhyb3dFcnJvcihzdGF0ZSwgJ2R1cGxpY2F0aW9uIG9mIGEgdGFnIHByb3BlcnR5Jyk7XG4gIH1cblxuICBjaCA9IHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoKytzdGF0ZS5wb3NpdGlvbik7XG5cbiAgaWYgKGNoID09PSAweDNDLyogPCAqLykge1xuICAgIGlzVmVyYmF0aW0gPSB0cnVlO1xuICAgIGNoID0gc3RhdGUuaW5wdXQuY2hhckNvZGVBdCgrK3N0YXRlLnBvc2l0aW9uKTtcblxuICB9IGVsc2UgaWYgKGNoID09PSAweDIxLyogISAqLykge1xuICAgIGlzTmFtZWQgPSB0cnVlO1xuICAgIHRhZ0hhbmRsZSA9ICchISc7XG4gICAgY2ggPSBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KCsrc3RhdGUucG9zaXRpb24pO1xuXG4gIH0gZWxzZSB7XG4gICAgdGFnSGFuZGxlID0gJyEnO1xuICB9XG5cbiAgX3Bvc2l0aW9uID0gc3RhdGUucG9zaXRpb247XG5cbiAgaWYgKGlzVmVyYmF0aW0pIHtcbiAgICBkbyB7IGNoID0gc3RhdGUuaW5wdXQuY2hhckNvZGVBdCgrK3N0YXRlLnBvc2l0aW9uKTsgfVxuICAgIHdoaWxlIChjaCAhPT0gMCAmJiBjaCAhPT0gMHgzRS8qID4gKi8pO1xuXG4gICAgaWYgKHN0YXRlLnBvc2l0aW9uIDwgc3RhdGUubGVuZ3RoKSB7XG4gICAgICB0YWdOYW1lID0gc3RhdGUuaW5wdXQuc2xpY2UoX3Bvc2l0aW9uLCBzdGF0ZS5wb3NpdGlvbik7XG4gICAgICBjaCA9IHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoKytzdGF0ZS5wb3NpdGlvbik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93RXJyb3Ioc3RhdGUsICd1bmV4cGVjdGVkIGVuZCBvZiB0aGUgc3RyZWFtIHdpdGhpbiBhIHZlcmJhdGltIHRhZycpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB3aGlsZSAoY2ggIT09IDAgJiYgIWlzX1dTX09SX0VPTChjaCkpIHtcblxuICAgICAgaWYgKGNoID09PSAweDIxLyogISAqLykge1xuICAgICAgICBpZiAoIWlzTmFtZWQpIHtcbiAgICAgICAgICB0YWdIYW5kbGUgPSBzdGF0ZS5pbnB1dC5zbGljZShfcG9zaXRpb24gLSAxLCBzdGF0ZS5wb3NpdGlvbiArIDEpO1xuXG4gICAgICAgICAgaWYgKCFQQVRURVJOX1RBR19IQU5ETEUudGVzdCh0YWdIYW5kbGUpKSB7XG4gICAgICAgICAgICB0aHJvd0Vycm9yKHN0YXRlLCAnbmFtZWQgdGFnIGhhbmRsZSBjYW5ub3QgY29udGFpbiBzdWNoIGNoYXJhY3RlcnMnKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpc05hbWVkID0gdHJ1ZTtcbiAgICAgICAgICBfcG9zaXRpb24gPSBzdGF0ZS5wb3NpdGlvbiArIDE7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhyb3dFcnJvcihzdGF0ZSwgJ3RhZyBzdWZmaXggY2Fubm90IGNvbnRhaW4gZXhjbGFtYXRpb24gbWFya3MnKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBjaCA9IHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoKytzdGF0ZS5wb3NpdGlvbik7XG4gICAgfVxuXG4gICAgdGFnTmFtZSA9IHN0YXRlLmlucHV0LnNsaWNlKF9wb3NpdGlvbiwgc3RhdGUucG9zaXRpb24pO1xuXG4gICAgaWYgKFBBVFRFUk5fRkxPV19JTkRJQ0FUT1JTLnRlc3QodGFnTmFtZSkpIHtcbiAgICAgIHRocm93RXJyb3Ioc3RhdGUsICd0YWcgc3VmZml4IGNhbm5vdCBjb250YWluIGZsb3cgaW5kaWNhdG9yIGNoYXJhY3RlcnMnKTtcbiAgICB9XG4gIH1cblxuICBpZiAodGFnTmFtZSAmJiAhUEFUVEVSTl9UQUdfVVJJLnRlc3QodGFnTmFtZSkpIHtcbiAgICB0aHJvd0Vycm9yKHN0YXRlLCAndGFnIG5hbWUgY2Fubm90IGNvbnRhaW4gc3VjaCBjaGFyYWN0ZXJzOiAnICsgdGFnTmFtZSk7XG4gIH1cblxuICBpZiAoaXNWZXJiYXRpbSkge1xuICAgIHN0YXRlLnRhZyA9IHRhZ05hbWU7XG5cbiAgfSBlbHNlIGlmIChfaGFzT3duUHJvcGVydHkuY2FsbChzdGF0ZS50YWdNYXAsIHRhZ0hhbmRsZSkpIHtcbiAgICBzdGF0ZS50YWcgPSBzdGF0ZS50YWdNYXBbdGFnSGFuZGxlXSArIHRhZ05hbWU7XG5cbiAgfSBlbHNlIGlmICh0YWdIYW5kbGUgPT09ICchJykge1xuICAgIHN0YXRlLnRhZyA9ICchJyArIHRhZ05hbWU7XG5cbiAgfSBlbHNlIGlmICh0YWdIYW5kbGUgPT09ICchIScpIHtcbiAgICBzdGF0ZS50YWcgPSAndGFnOnlhbWwub3JnLDIwMDI6JyArIHRhZ05hbWU7XG5cbiAgfSBlbHNlIHtcbiAgICB0aHJvd0Vycm9yKHN0YXRlLCAndW5kZWNsYXJlZCB0YWcgaGFuZGxlIFwiJyArIHRhZ0hhbmRsZSArICdcIicpO1xuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59XG5cbmZ1bmN0aW9uIHJlYWRBbmNob3JQcm9wZXJ0eShzdGF0ZSkge1xuICB2YXIgX3Bvc2l0aW9uLFxuICAgICAgY2g7XG5cbiAgY2ggPSBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KHN0YXRlLnBvc2l0aW9uKTtcblxuICBpZiAoY2ggIT09IDB4MjYvKiAmICovKSByZXR1cm4gZmFsc2U7XG5cbiAgaWYgKHN0YXRlLmFuY2hvciAhPT0gbnVsbCkge1xuICAgIHRocm93RXJyb3Ioc3RhdGUsICdkdXBsaWNhdGlvbiBvZiBhbiBhbmNob3IgcHJvcGVydHknKTtcbiAgfVxuXG4gIGNoID0gc3RhdGUuaW5wdXQuY2hhckNvZGVBdCgrK3N0YXRlLnBvc2l0aW9uKTtcbiAgX3Bvc2l0aW9uID0gc3RhdGUucG9zaXRpb247XG5cbiAgd2hpbGUgKGNoICE9PSAwICYmICFpc19XU19PUl9FT0woY2gpICYmICFpc19GTE9XX0lORElDQVRPUihjaCkpIHtcbiAgICBjaCA9IHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoKytzdGF0ZS5wb3NpdGlvbik7XG4gIH1cblxuICBpZiAoc3RhdGUucG9zaXRpb24gPT09IF9wb3NpdGlvbikge1xuICAgIHRocm93RXJyb3Ioc3RhdGUsICduYW1lIG9mIGFuIGFuY2hvciBub2RlIG11c3QgY29udGFpbiBhdCBsZWFzdCBvbmUgY2hhcmFjdGVyJyk7XG4gIH1cblxuICBzdGF0ZS5hbmNob3IgPSBzdGF0ZS5pbnB1dC5zbGljZShfcG9zaXRpb24sIHN0YXRlLnBvc2l0aW9uKTtcbiAgcmV0dXJuIHRydWU7XG59XG5cbmZ1bmN0aW9uIHJlYWRBbGlhcyhzdGF0ZSkge1xuICB2YXIgX3Bvc2l0aW9uLCBhbGlhcyxcbiAgICAgIGNoO1xuXG4gIGNoID0gc3RhdGUuaW5wdXQuY2hhckNvZGVBdChzdGF0ZS5wb3NpdGlvbik7XG5cbiAgaWYgKGNoICE9PSAweDJBLyogKiAqLykgcmV0dXJuIGZhbHNlO1xuXG4gIGNoID0gc3RhdGUuaW5wdXQuY2hhckNvZGVBdCgrK3N0YXRlLnBvc2l0aW9uKTtcbiAgX3Bvc2l0aW9uID0gc3RhdGUucG9zaXRpb247XG5cbiAgd2hpbGUgKGNoICE9PSAwICYmICFpc19XU19PUl9FT0woY2gpICYmICFpc19GTE9XX0lORElDQVRPUihjaCkpIHtcbiAgICBjaCA9IHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoKytzdGF0ZS5wb3NpdGlvbik7XG4gIH1cblxuICBpZiAoc3RhdGUucG9zaXRpb24gPT09IF9wb3NpdGlvbikge1xuICAgIHRocm93RXJyb3Ioc3RhdGUsICduYW1lIG9mIGFuIGFsaWFzIG5vZGUgbXVzdCBjb250YWluIGF0IGxlYXN0IG9uZSBjaGFyYWN0ZXInKTtcbiAgfVxuXG4gIGFsaWFzID0gc3RhdGUuaW5wdXQuc2xpY2UoX3Bvc2l0aW9uLCBzdGF0ZS5wb3NpdGlvbik7XG5cbiAgaWYgKCFzdGF0ZS5hbmNob3JNYXAuaGFzT3duUHJvcGVydHkoYWxpYXMpKSB7XG4gICAgdGhyb3dFcnJvcihzdGF0ZSwgJ3VuaWRlbnRpZmllZCBhbGlhcyBcIicgKyBhbGlhcyArICdcIicpO1xuICB9XG5cbiAgc3RhdGUucmVzdWx0ID0gc3RhdGUuYW5jaG9yTWFwW2FsaWFzXTtcbiAgc2tpcFNlcGFyYXRpb25TcGFjZShzdGF0ZSwgdHJ1ZSwgLTEpO1xuICByZXR1cm4gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gY29tcG9zZU5vZGUoc3RhdGUsIHBhcmVudEluZGVudCwgbm9kZUNvbnRleHQsIGFsbG93VG9TZWVrLCBhbGxvd0NvbXBhY3QpIHtcbiAgdmFyIGFsbG93QmxvY2tTdHlsZXMsXG4gICAgICBhbGxvd0Jsb2NrU2NhbGFycyxcbiAgICAgIGFsbG93QmxvY2tDb2xsZWN0aW9ucyxcbiAgICAgIGluZGVudFN0YXR1cyA9IDEsIC8vIDE6IHRoaXM+cGFyZW50LCAwOiB0aGlzPXBhcmVudCwgLTE6IHRoaXM8cGFyZW50XG4gICAgICBhdE5ld0xpbmUgID0gZmFsc2UsXG4gICAgICBoYXNDb250ZW50ID0gZmFsc2UsXG4gICAgICB0eXBlSW5kZXgsXG4gICAgICB0eXBlUXVhbnRpdHksXG4gICAgICB0eXBlLFxuICAgICAgZmxvd0luZGVudCxcbiAgICAgIGJsb2NrSW5kZW50O1xuXG4gIGlmIChzdGF0ZS5saXN0ZW5lciAhPT0gbnVsbCkge1xuICAgIHN0YXRlLmxpc3RlbmVyKCdvcGVuJywgc3RhdGUpO1xuICB9XG5cbiAgc3RhdGUudGFnICAgID0gbnVsbDtcbiAgc3RhdGUuYW5jaG9yID0gbnVsbDtcbiAgc3RhdGUua2luZCAgID0gbnVsbDtcbiAgc3RhdGUucmVzdWx0ID0gbnVsbDtcblxuICBhbGxvd0Jsb2NrU3R5bGVzID0gYWxsb3dCbG9ja1NjYWxhcnMgPSBhbGxvd0Jsb2NrQ29sbGVjdGlvbnMgPVxuICAgIENPTlRFWFRfQkxPQ0tfT1VUID09PSBub2RlQ29udGV4dCB8fFxuICAgIENPTlRFWFRfQkxPQ0tfSU4gID09PSBub2RlQ29udGV4dDtcblxuICBpZiAoYWxsb3dUb1NlZWspIHtcbiAgICBpZiAoc2tpcFNlcGFyYXRpb25TcGFjZShzdGF0ZSwgdHJ1ZSwgLTEpKSB7XG4gICAgICBhdE5ld0xpbmUgPSB0cnVlO1xuXG4gICAgICBpZiAoc3RhdGUubGluZUluZGVudCA+IHBhcmVudEluZGVudCkge1xuICAgICAgICBpbmRlbnRTdGF0dXMgPSAxO1xuICAgICAgfSBlbHNlIGlmIChzdGF0ZS5saW5lSW5kZW50ID09PSBwYXJlbnRJbmRlbnQpIHtcbiAgICAgICAgaW5kZW50U3RhdHVzID0gMDtcbiAgICAgIH0gZWxzZSBpZiAoc3RhdGUubGluZUluZGVudCA8IHBhcmVudEluZGVudCkge1xuICAgICAgICBpbmRlbnRTdGF0dXMgPSAtMTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBpZiAoaW5kZW50U3RhdHVzID09PSAxKSB7XG4gICAgd2hpbGUgKHJlYWRUYWdQcm9wZXJ0eShzdGF0ZSkgfHwgcmVhZEFuY2hvclByb3BlcnR5KHN0YXRlKSkge1xuICAgICAgaWYgKHNraXBTZXBhcmF0aW9uU3BhY2Uoc3RhdGUsIHRydWUsIC0xKSkge1xuICAgICAgICBhdE5ld0xpbmUgPSB0cnVlO1xuICAgICAgICBhbGxvd0Jsb2NrQ29sbGVjdGlvbnMgPSBhbGxvd0Jsb2NrU3R5bGVzO1xuXG4gICAgICAgIGlmIChzdGF0ZS5saW5lSW5kZW50ID4gcGFyZW50SW5kZW50KSB7XG4gICAgICAgICAgaW5kZW50U3RhdHVzID0gMTtcbiAgICAgICAgfSBlbHNlIGlmIChzdGF0ZS5saW5lSW5kZW50ID09PSBwYXJlbnRJbmRlbnQpIHtcbiAgICAgICAgICBpbmRlbnRTdGF0dXMgPSAwO1xuICAgICAgICB9IGVsc2UgaWYgKHN0YXRlLmxpbmVJbmRlbnQgPCBwYXJlbnRJbmRlbnQpIHtcbiAgICAgICAgICBpbmRlbnRTdGF0dXMgPSAtMTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYWxsb3dCbG9ja0NvbGxlY3Rpb25zID0gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgaWYgKGFsbG93QmxvY2tDb2xsZWN0aW9ucykge1xuICAgIGFsbG93QmxvY2tDb2xsZWN0aW9ucyA9IGF0TmV3TGluZSB8fCBhbGxvd0NvbXBhY3Q7XG4gIH1cblxuICBpZiAoaW5kZW50U3RhdHVzID09PSAxIHx8IENPTlRFWFRfQkxPQ0tfT1VUID09PSBub2RlQ29udGV4dCkge1xuICAgIGlmIChDT05URVhUX0ZMT1dfSU4gPT09IG5vZGVDb250ZXh0IHx8IENPTlRFWFRfRkxPV19PVVQgPT09IG5vZGVDb250ZXh0KSB7XG4gICAgICBmbG93SW5kZW50ID0gcGFyZW50SW5kZW50O1xuICAgIH0gZWxzZSB7XG4gICAgICBmbG93SW5kZW50ID0gcGFyZW50SW5kZW50ICsgMTtcbiAgICB9XG5cbiAgICBibG9ja0luZGVudCA9IHN0YXRlLnBvc2l0aW9uIC0gc3RhdGUubGluZVN0YXJ0O1xuXG4gICAgaWYgKGluZGVudFN0YXR1cyA9PT0gMSkge1xuICAgICAgaWYgKGFsbG93QmxvY2tDb2xsZWN0aW9ucyAmJlxuICAgICAgICAgIChyZWFkQmxvY2tTZXF1ZW5jZShzdGF0ZSwgYmxvY2tJbmRlbnQpIHx8XG4gICAgICAgICAgIHJlYWRCbG9ja01hcHBpbmcoc3RhdGUsIGJsb2NrSW5kZW50LCBmbG93SW5kZW50KSkgfHxcbiAgICAgICAgICByZWFkRmxvd0NvbGxlY3Rpb24oc3RhdGUsIGZsb3dJbmRlbnQpKSB7XG4gICAgICAgIGhhc0NvbnRlbnQgPSB0cnVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKChhbGxvd0Jsb2NrU2NhbGFycyAmJiByZWFkQmxvY2tTY2FsYXIoc3RhdGUsIGZsb3dJbmRlbnQpKSB8fFxuICAgICAgICAgICAgcmVhZFNpbmdsZVF1b3RlZFNjYWxhcihzdGF0ZSwgZmxvd0luZGVudCkgfHxcbiAgICAgICAgICAgIHJlYWREb3VibGVRdW90ZWRTY2FsYXIoc3RhdGUsIGZsb3dJbmRlbnQpKSB7XG4gICAgICAgICAgaGFzQ29udGVudCA9IHRydWU7XG5cbiAgICAgICAgfSBlbHNlIGlmIChyZWFkQWxpYXMoc3RhdGUpKSB7XG4gICAgICAgICAgaGFzQ29udGVudCA9IHRydWU7XG5cbiAgICAgICAgICBpZiAoc3RhdGUudGFnICE9PSBudWxsIHx8IHN0YXRlLmFuY2hvciAhPT0gbnVsbCkge1xuICAgICAgICAgICAgdGhyb3dFcnJvcihzdGF0ZSwgJ2FsaWFzIG5vZGUgc2hvdWxkIG5vdCBoYXZlIGFueSBwcm9wZXJ0aWVzJyk7XG4gICAgICAgICAgfVxuXG4gICAgICAgIH0gZWxzZSBpZiAocmVhZFBsYWluU2NhbGFyKHN0YXRlLCBmbG93SW5kZW50LCBDT05URVhUX0ZMT1dfSU4gPT09IG5vZGVDb250ZXh0KSkge1xuICAgICAgICAgIGhhc0NvbnRlbnQgPSB0cnVlO1xuXG4gICAgICAgICAgaWYgKHN0YXRlLnRhZyA9PT0gbnVsbCkge1xuICAgICAgICAgICAgc3RhdGUudGFnID0gJz8nO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChzdGF0ZS5hbmNob3IgIT09IG51bGwpIHtcbiAgICAgICAgICBzdGF0ZS5hbmNob3JNYXBbc3RhdGUuYW5jaG9yXSA9IHN0YXRlLnJlc3VsdDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoaW5kZW50U3RhdHVzID09PSAwKSB7XG4gICAgICAvLyBTcGVjaWFsIGNhc2U6IGJsb2NrIHNlcXVlbmNlcyBhcmUgYWxsb3dlZCB0byBoYXZlIHNhbWUgaW5kZW50YXRpb24gbGV2ZWwgYXMgdGhlIHBhcmVudC5cbiAgICAgIC8vIGh0dHA6Ly93d3cueWFtbC5vcmcvc3BlYy8xLjIvc3BlYy5odG1sI2lkMjc5OTc4NFxuICAgICAgaGFzQ29udGVudCA9IGFsbG93QmxvY2tDb2xsZWN0aW9ucyAmJiByZWFkQmxvY2tTZXF1ZW5jZShzdGF0ZSwgYmxvY2tJbmRlbnQpO1xuICAgIH1cbiAgfVxuXG4gIGlmIChzdGF0ZS50YWcgIT09IG51bGwgJiYgc3RhdGUudGFnICE9PSAnIScpIHtcbiAgICBpZiAoc3RhdGUudGFnID09PSAnPycpIHtcbiAgICAgIGZvciAodHlwZUluZGV4ID0gMCwgdHlwZVF1YW50aXR5ID0gc3RhdGUuaW1wbGljaXRUeXBlcy5sZW5ndGg7IHR5cGVJbmRleCA8IHR5cGVRdWFudGl0eTsgdHlwZUluZGV4ICs9IDEpIHtcbiAgICAgICAgdHlwZSA9IHN0YXRlLmltcGxpY2l0VHlwZXNbdHlwZUluZGV4XTtcblxuICAgICAgICAvLyBJbXBsaWNpdCByZXNvbHZpbmcgaXMgbm90IGFsbG93ZWQgZm9yIG5vbi1zY2FsYXIgdHlwZXMsIGFuZCAnPydcbiAgICAgICAgLy8gbm9uLXNwZWNpZmljIHRhZyBpcyBvbmx5IGFzc2lnbmVkIHRvIHBsYWluIHNjYWxhcnMuIFNvLCBpdCBpc24ndFxuICAgICAgICAvLyBuZWVkZWQgdG8gY2hlY2sgZm9yICdraW5kJyBjb25mb3JtaXR5LlxuXG4gICAgICAgIGlmICh0eXBlLnJlc29sdmUoc3RhdGUucmVzdWx0KSkgeyAvLyBgc3RhdGUucmVzdWx0YCB1cGRhdGVkIGluIHJlc29sdmVyIGlmIG1hdGNoZWRcbiAgICAgICAgICBzdGF0ZS5yZXN1bHQgPSB0eXBlLmNvbnN0cnVjdChzdGF0ZS5yZXN1bHQpO1xuICAgICAgICAgIHN0YXRlLnRhZyA9IHR5cGUudGFnO1xuICAgICAgICAgIGlmIChzdGF0ZS5hbmNob3IgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHN0YXRlLmFuY2hvck1hcFtzdGF0ZS5hbmNob3JdID0gc3RhdGUucmVzdWx0O1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoX2hhc093blByb3BlcnR5LmNhbGwoc3RhdGUudHlwZU1hcFtzdGF0ZS5raW5kIHx8ICdmYWxsYmFjayddLCBzdGF0ZS50YWcpKSB7XG4gICAgICB0eXBlID0gc3RhdGUudHlwZU1hcFtzdGF0ZS5raW5kIHx8ICdmYWxsYmFjayddW3N0YXRlLnRhZ107XG5cbiAgICAgIGlmIChzdGF0ZS5yZXN1bHQgIT09IG51bGwgJiYgdHlwZS5raW5kICE9PSBzdGF0ZS5raW5kKSB7XG4gICAgICAgIHRocm93RXJyb3Ioc3RhdGUsICd1bmFjY2VwdGFibGUgbm9kZSBraW5kIGZvciAhPCcgKyBzdGF0ZS50YWcgKyAnPiB0YWc7IGl0IHNob3VsZCBiZSBcIicgKyB0eXBlLmtpbmQgKyAnXCIsIG5vdCBcIicgKyBzdGF0ZS5raW5kICsgJ1wiJyk7XG4gICAgICB9XG5cbiAgICAgIGlmICghdHlwZS5yZXNvbHZlKHN0YXRlLnJlc3VsdCkpIHsgLy8gYHN0YXRlLnJlc3VsdGAgdXBkYXRlZCBpbiByZXNvbHZlciBpZiBtYXRjaGVkXG4gICAgICAgIHRocm93RXJyb3Ioc3RhdGUsICdjYW5ub3QgcmVzb2x2ZSBhIG5vZGUgd2l0aCAhPCcgKyBzdGF0ZS50YWcgKyAnPiBleHBsaWNpdCB0YWcnKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN0YXRlLnJlc3VsdCA9IHR5cGUuY29uc3RydWN0KHN0YXRlLnJlc3VsdCk7XG4gICAgICAgIGlmIChzdGF0ZS5hbmNob3IgIT09IG51bGwpIHtcbiAgICAgICAgICBzdGF0ZS5hbmNob3JNYXBbc3RhdGUuYW5jaG9yXSA9IHN0YXRlLnJlc3VsdDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvd0Vycm9yKHN0YXRlLCAndW5rbm93biB0YWcgITwnICsgc3RhdGUudGFnICsgJz4nKTtcbiAgICB9XG4gIH1cblxuICBpZiAoc3RhdGUubGlzdGVuZXIgIT09IG51bGwpIHtcbiAgICBzdGF0ZS5saXN0ZW5lcignY2xvc2UnLCBzdGF0ZSk7XG4gIH1cbiAgcmV0dXJuIHN0YXRlLnRhZyAhPT0gbnVsbCB8fCAgc3RhdGUuYW5jaG9yICE9PSBudWxsIHx8IGhhc0NvbnRlbnQ7XG59XG5cbmZ1bmN0aW9uIHJlYWREb2N1bWVudChzdGF0ZSkge1xuICB2YXIgZG9jdW1lbnRTdGFydCA9IHN0YXRlLnBvc2l0aW9uLFxuICAgICAgX3Bvc2l0aW9uLFxuICAgICAgZGlyZWN0aXZlTmFtZSxcbiAgICAgIGRpcmVjdGl2ZUFyZ3MsXG4gICAgICBoYXNEaXJlY3RpdmVzID0gZmFsc2UsXG4gICAgICBjaDtcblxuICBzdGF0ZS52ZXJzaW9uID0gbnVsbDtcbiAgc3RhdGUuY2hlY2tMaW5lQnJlYWtzID0gc3RhdGUubGVnYWN5O1xuICBzdGF0ZS50YWdNYXAgPSB7fTtcbiAgc3RhdGUuYW5jaG9yTWFwID0ge307XG5cbiAgd2hpbGUgKChjaCA9IHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoc3RhdGUucG9zaXRpb24pKSAhPT0gMCkge1xuICAgIHNraXBTZXBhcmF0aW9uU3BhY2Uoc3RhdGUsIHRydWUsIC0xKTtcblxuICAgIGNoID0gc3RhdGUuaW5wdXQuY2hhckNvZGVBdChzdGF0ZS5wb3NpdGlvbik7XG5cbiAgICBpZiAoc3RhdGUubGluZUluZGVudCA+IDAgfHwgY2ggIT09IDB4MjUvKiAlICovKSB7XG4gICAgICBicmVhaztcbiAgICB9XG5cbiAgICBoYXNEaXJlY3RpdmVzID0gdHJ1ZTtcbiAgICBjaCA9IHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoKytzdGF0ZS5wb3NpdGlvbik7XG4gICAgX3Bvc2l0aW9uID0gc3RhdGUucG9zaXRpb247XG5cbiAgICB3aGlsZSAoY2ggIT09IDAgJiYgIWlzX1dTX09SX0VPTChjaCkpIHtcbiAgICAgIGNoID0gc3RhdGUuaW5wdXQuY2hhckNvZGVBdCgrK3N0YXRlLnBvc2l0aW9uKTtcbiAgICB9XG5cbiAgICBkaXJlY3RpdmVOYW1lID0gc3RhdGUuaW5wdXQuc2xpY2UoX3Bvc2l0aW9uLCBzdGF0ZS5wb3NpdGlvbik7XG4gICAgZGlyZWN0aXZlQXJncyA9IFtdO1xuXG4gICAgaWYgKGRpcmVjdGl2ZU5hbWUubGVuZ3RoIDwgMSkge1xuICAgICAgdGhyb3dFcnJvcihzdGF0ZSwgJ2RpcmVjdGl2ZSBuYW1lIG11c3Qgbm90IGJlIGxlc3MgdGhhbiBvbmUgY2hhcmFjdGVyIGluIGxlbmd0aCcpO1xuICAgIH1cblxuICAgIHdoaWxlIChjaCAhPT0gMCkge1xuICAgICAgd2hpbGUgKGlzX1dISVRFX1NQQUNFKGNoKSkge1xuICAgICAgICBjaCA9IHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoKytzdGF0ZS5wb3NpdGlvbik7XG4gICAgICB9XG5cbiAgICAgIGlmIChjaCA9PT0gMHgyMy8qICMgKi8pIHtcbiAgICAgICAgZG8geyBjaCA9IHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoKytzdGF0ZS5wb3NpdGlvbik7IH1cbiAgICAgICAgd2hpbGUgKGNoICE9PSAwICYmICFpc19FT0woY2gpKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICAgIGlmIChpc19FT0woY2gpKSBicmVhaztcblxuICAgICAgX3Bvc2l0aW9uID0gc3RhdGUucG9zaXRpb247XG5cbiAgICAgIHdoaWxlIChjaCAhPT0gMCAmJiAhaXNfV1NfT1JfRU9MKGNoKSkge1xuICAgICAgICBjaCA9IHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoKytzdGF0ZS5wb3NpdGlvbik7XG4gICAgICB9XG5cbiAgICAgIGRpcmVjdGl2ZUFyZ3MucHVzaChzdGF0ZS5pbnB1dC5zbGljZShfcG9zaXRpb24sIHN0YXRlLnBvc2l0aW9uKSk7XG4gICAgfVxuXG4gICAgaWYgKGNoICE9PSAwKSByZWFkTGluZUJyZWFrKHN0YXRlKTtcblxuICAgIGlmIChfaGFzT3duUHJvcGVydHkuY2FsbChkaXJlY3RpdmVIYW5kbGVycywgZGlyZWN0aXZlTmFtZSkpIHtcbiAgICAgIGRpcmVjdGl2ZUhhbmRsZXJzW2RpcmVjdGl2ZU5hbWVdKHN0YXRlLCBkaXJlY3RpdmVOYW1lLCBkaXJlY3RpdmVBcmdzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3dXYXJuaW5nKHN0YXRlLCAndW5rbm93biBkb2N1bWVudCBkaXJlY3RpdmUgXCInICsgZGlyZWN0aXZlTmFtZSArICdcIicpO1xuICAgIH1cbiAgfVxuXG4gIHNraXBTZXBhcmF0aW9uU3BhY2Uoc3RhdGUsIHRydWUsIC0xKTtcblxuICBpZiAoc3RhdGUubGluZUluZGVudCA9PT0gMCAmJlxuICAgICAgc3RhdGUuaW5wdXQuY2hhckNvZGVBdChzdGF0ZS5wb3NpdGlvbikgICAgID09PSAweDJELyogLSAqLyAmJlxuICAgICAgc3RhdGUuaW5wdXQuY2hhckNvZGVBdChzdGF0ZS5wb3NpdGlvbiArIDEpID09PSAweDJELyogLSAqLyAmJlxuICAgICAgc3RhdGUuaW5wdXQuY2hhckNvZGVBdChzdGF0ZS5wb3NpdGlvbiArIDIpID09PSAweDJELyogLSAqLykge1xuICAgIHN0YXRlLnBvc2l0aW9uICs9IDM7XG4gICAgc2tpcFNlcGFyYXRpb25TcGFjZShzdGF0ZSwgdHJ1ZSwgLTEpO1xuXG4gIH0gZWxzZSBpZiAoaGFzRGlyZWN0aXZlcykge1xuICAgIHRocm93RXJyb3Ioc3RhdGUsICdkaXJlY3RpdmVzIGVuZCBtYXJrIGlzIGV4cGVjdGVkJyk7XG4gIH1cblxuICBjb21wb3NlTm9kZShzdGF0ZSwgc3RhdGUubGluZUluZGVudCAtIDEsIENPTlRFWFRfQkxPQ0tfT1VULCBmYWxzZSwgdHJ1ZSk7XG4gIHNraXBTZXBhcmF0aW9uU3BhY2Uoc3RhdGUsIHRydWUsIC0xKTtcblxuICBpZiAoc3RhdGUuY2hlY2tMaW5lQnJlYWtzICYmXG4gICAgICBQQVRURVJOX05PTl9BU0NJSV9MSU5FX0JSRUFLUy50ZXN0KHN0YXRlLmlucHV0LnNsaWNlKGRvY3VtZW50U3RhcnQsIHN0YXRlLnBvc2l0aW9uKSkpIHtcbiAgICB0aHJvd1dhcm5pbmcoc3RhdGUsICdub24tQVNDSUkgbGluZSBicmVha3MgYXJlIGludGVycHJldGVkIGFzIGNvbnRlbnQnKTtcbiAgfVxuXG4gIHN0YXRlLmRvY3VtZW50cy5wdXNoKHN0YXRlLnJlc3VsdCk7XG5cbiAgaWYgKHN0YXRlLnBvc2l0aW9uID09PSBzdGF0ZS5saW5lU3RhcnQgJiYgdGVzdERvY3VtZW50U2VwYXJhdG9yKHN0YXRlKSkge1xuXG4gICAgaWYgKHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoc3RhdGUucG9zaXRpb24pID09PSAweDJFLyogLiAqLykge1xuICAgICAgc3RhdGUucG9zaXRpb24gKz0gMztcbiAgICAgIHNraXBTZXBhcmF0aW9uU3BhY2Uoc3RhdGUsIHRydWUsIC0xKTtcbiAgICB9XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgaWYgKHN0YXRlLnBvc2l0aW9uIDwgKHN0YXRlLmxlbmd0aCAtIDEpKSB7XG4gICAgdGhyb3dFcnJvcihzdGF0ZSwgJ2VuZCBvZiB0aGUgc3RyZWFtIG9yIGEgZG9jdW1lbnQgc2VwYXJhdG9yIGlzIGV4cGVjdGVkJyk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuO1xuICB9XG59XG5cblxuZnVuY3Rpb24gbG9hZERvY3VtZW50cyhpbnB1dCwgb3B0aW9ucykge1xuICBpbnB1dCA9IFN0cmluZyhpbnB1dCk7XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gIGlmIChpbnB1dC5sZW5ndGggIT09IDApIHtcblxuICAgIC8vIEFkZCB0YWlsaW5nIGBcXG5gIGlmIG5vdCBleGlzdHNcbiAgICBpZiAoaW5wdXQuY2hhckNvZGVBdChpbnB1dC5sZW5ndGggLSAxKSAhPT0gMHgwQS8qIExGICovICYmXG4gICAgICAgIGlucHV0LmNoYXJDb2RlQXQoaW5wdXQubGVuZ3RoIC0gMSkgIT09IDB4MEQvKiBDUiAqLykge1xuICAgICAgaW5wdXQgKz0gJ1xcbic7XG4gICAgfVxuXG4gICAgLy8gU3RyaXAgQk9NXG4gICAgaWYgKGlucHV0LmNoYXJDb2RlQXQoMCkgPT09IDB4RkVGRikge1xuICAgICAgaW5wdXQgPSBpbnB1dC5zbGljZSgxKTtcbiAgICB9XG4gIH1cblxuICB2YXIgc3RhdGUgPSBuZXcgU3RhdGUoaW5wdXQsIG9wdGlvbnMpO1xuXG4gIC8vIFVzZSAwIGFzIHN0cmluZyB0ZXJtaW5hdG9yLiBUaGF0IHNpZ25pZmljYW50bHkgc2ltcGxpZmllcyBib3VuZHMgY2hlY2suXG4gIHN0YXRlLmlucHV0ICs9ICdcXDAnO1xuXG4gIHdoaWxlIChzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KHN0YXRlLnBvc2l0aW9uKSA9PT0gMHgyMC8qIFNwYWNlICovKSB7XG4gICAgc3RhdGUubGluZUluZGVudCArPSAxO1xuICAgIHN0YXRlLnBvc2l0aW9uICs9IDE7XG4gIH1cblxuICB3aGlsZSAoc3RhdGUucG9zaXRpb24gPCAoc3RhdGUubGVuZ3RoIC0gMSkpIHtcbiAgICByZWFkRG9jdW1lbnQoc3RhdGUpO1xuICB9XG5cbiAgcmV0dXJuIHN0YXRlLmRvY3VtZW50cztcbn1cblxuXG5mdW5jdGlvbiBsb2FkQWxsKGlucHV0LCBpdGVyYXRvciwgb3B0aW9ucykge1xuICB2YXIgZG9jdW1lbnRzID0gbG9hZERvY3VtZW50cyhpbnB1dCwgb3B0aW9ucyksIGluZGV4LCBsZW5ndGg7XG5cbiAgaWYgKHR5cGVvZiBpdGVyYXRvciAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiBkb2N1bWVudHM7XG4gIH1cblxuICBmb3IgKGluZGV4ID0gMCwgbGVuZ3RoID0gZG9jdW1lbnRzLmxlbmd0aDsgaW5kZXggPCBsZW5ndGg7IGluZGV4ICs9IDEpIHtcbiAgICBpdGVyYXRvcihkb2N1bWVudHNbaW5kZXhdKTtcbiAgfVxufVxuXG5cbmZ1bmN0aW9uIGxvYWQoaW5wdXQsIG9wdGlvbnMpIHtcbiAgdmFyIGRvY3VtZW50cyA9IGxvYWREb2N1bWVudHMoaW5wdXQsIG9wdGlvbnMpO1xuXG4gIGlmIChkb2N1bWVudHMubGVuZ3RoID09PSAwKSB7XG4gICAgLyplc2xpbnQtZGlzYWJsZSBuby11bmRlZmluZWQqL1xuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH0gZWxzZSBpZiAoZG9jdW1lbnRzLmxlbmd0aCA9PT0gMSkge1xuICAgIHJldHVybiBkb2N1bWVudHNbMF07XG4gIH1cbiAgdGhyb3cgbmV3IFlBTUxFeGNlcHRpb24oJ2V4cGVjdGVkIGEgc2luZ2xlIGRvY3VtZW50IGluIHRoZSBzdHJlYW0sIGJ1dCBmb3VuZCBtb3JlJyk7XG59XG5cblxuZnVuY3Rpb24gc2FmZUxvYWRBbGwoaW5wdXQsIG91dHB1dCwgb3B0aW9ucykge1xuICBpZiAodHlwZW9mIG91dHB1dCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGxvYWRBbGwoaW5wdXQsIG91dHB1dCwgY29tbW9uLmV4dGVuZCh7IHNjaGVtYTogREVGQVVMVF9TQUZFX1NDSEVNQSB9LCBvcHRpb25zKSk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGxvYWRBbGwoaW5wdXQsIGNvbW1vbi5leHRlbmQoeyBzY2hlbWE6IERFRkFVTFRfU0FGRV9TQ0hFTUEgfSwgb3B0aW9ucykpO1xuICB9XG59XG5cblxuZnVuY3Rpb24gc2FmZUxvYWQoaW5wdXQsIG9wdGlvbnMpIHtcbiAgcmV0dXJuIGxvYWQoaW5wdXQsIGNvbW1vbi5leHRlbmQoeyBzY2hlbWE6IERFRkFVTFRfU0FGRV9TQ0hFTUEgfSwgb3B0aW9ucykpO1xufVxuXG5cbm1vZHVsZS5leHBvcnRzLmxvYWRBbGwgICAgID0gbG9hZEFsbDtcbm1vZHVsZS5leHBvcnRzLmxvYWQgICAgICAgID0gbG9hZDtcbm1vZHVsZS5leHBvcnRzLnNhZmVMb2FkQWxsID0gc2FmZUxvYWRBbGw7XG5tb2R1bGUuZXhwb3J0cy5zYWZlTG9hZCAgICA9IHNhZmVMb2FkO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2pzLXlhbWwvbGliL2pzLXlhbWwvbG9hZGVyLmpzIiwiJ3VzZSBzdHJpY3QnO1xuXG5cbnZhciBjb21tb24gPSByZXF1aXJlKCcuL2NvbW1vbicpO1xuXG5cbmZ1bmN0aW9uIE1hcmsobmFtZSwgYnVmZmVyLCBwb3NpdGlvbiwgbGluZSwgY29sdW1uKSB7XG4gIHRoaXMubmFtZSAgICAgPSBuYW1lO1xuICB0aGlzLmJ1ZmZlciAgID0gYnVmZmVyO1xuICB0aGlzLnBvc2l0aW9uID0gcG9zaXRpb247XG4gIHRoaXMubGluZSAgICAgPSBsaW5lO1xuICB0aGlzLmNvbHVtbiAgID0gY29sdW1uO1xufVxuXG5cbk1hcmsucHJvdG90eXBlLmdldFNuaXBwZXQgPSBmdW5jdGlvbiBnZXRTbmlwcGV0KGluZGVudCwgbWF4TGVuZ3RoKSB7XG4gIHZhciBoZWFkLCBzdGFydCwgdGFpbCwgZW5kLCBzbmlwcGV0O1xuXG4gIGlmICghdGhpcy5idWZmZXIpIHJldHVybiBudWxsO1xuXG4gIGluZGVudCA9IGluZGVudCB8fCA0O1xuICBtYXhMZW5ndGggPSBtYXhMZW5ndGggfHwgNzU7XG5cbiAgaGVhZCA9ICcnO1xuICBzdGFydCA9IHRoaXMucG9zaXRpb247XG5cbiAgd2hpbGUgKHN0YXJ0ID4gMCAmJiAnXFx4MDBcXHJcXG5cXHg4NVxcdTIwMjhcXHUyMDI5Jy5pbmRleE9mKHRoaXMuYnVmZmVyLmNoYXJBdChzdGFydCAtIDEpKSA9PT0gLTEpIHtcbiAgICBzdGFydCAtPSAxO1xuICAgIGlmICh0aGlzLnBvc2l0aW9uIC0gc3RhcnQgPiAobWF4TGVuZ3RoIC8gMiAtIDEpKSB7XG4gICAgICBoZWFkID0gJyAuLi4gJztcbiAgICAgIHN0YXJ0ICs9IDU7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cblxuICB0YWlsID0gJyc7XG4gIGVuZCA9IHRoaXMucG9zaXRpb247XG5cbiAgd2hpbGUgKGVuZCA8IHRoaXMuYnVmZmVyLmxlbmd0aCAmJiAnXFx4MDBcXHJcXG5cXHg4NVxcdTIwMjhcXHUyMDI5Jy5pbmRleE9mKHRoaXMuYnVmZmVyLmNoYXJBdChlbmQpKSA9PT0gLTEpIHtcbiAgICBlbmQgKz0gMTtcbiAgICBpZiAoZW5kIC0gdGhpcy5wb3NpdGlvbiA+IChtYXhMZW5ndGggLyAyIC0gMSkpIHtcbiAgICAgIHRhaWwgPSAnIC4uLiAnO1xuICAgICAgZW5kIC09IDU7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cblxuICBzbmlwcGV0ID0gdGhpcy5idWZmZXIuc2xpY2Uoc3RhcnQsIGVuZCk7XG5cbiAgcmV0dXJuIGNvbW1vbi5yZXBlYXQoJyAnLCBpbmRlbnQpICsgaGVhZCArIHNuaXBwZXQgKyB0YWlsICsgJ1xcbicgK1xuICAgICAgICAgY29tbW9uLnJlcGVhdCgnICcsIGluZGVudCArIHRoaXMucG9zaXRpb24gLSBzdGFydCArIGhlYWQubGVuZ3RoKSArICdeJztcbn07XG5cblxuTWFyay5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZyhjb21wYWN0KSB7XG4gIHZhciBzbmlwcGV0LCB3aGVyZSA9ICcnO1xuXG4gIGlmICh0aGlzLm5hbWUpIHtcbiAgICB3aGVyZSArPSAnaW4gXCInICsgdGhpcy5uYW1lICsgJ1wiICc7XG4gIH1cblxuICB3aGVyZSArPSAnYXQgbGluZSAnICsgKHRoaXMubGluZSArIDEpICsgJywgY29sdW1uICcgKyAodGhpcy5jb2x1bW4gKyAxKTtcblxuICBpZiAoIWNvbXBhY3QpIHtcbiAgICBzbmlwcGV0ID0gdGhpcy5nZXRTbmlwcGV0KCk7XG5cbiAgICBpZiAoc25pcHBldCkge1xuICAgICAgd2hlcmUgKz0gJzpcXG4nICsgc25pcHBldDtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gd2hlcmU7XG59O1xuXG5cbm1vZHVsZS5leHBvcnRzID0gTWFyaztcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9qcy15YW1sL2xpYi9qcy15YW1sL21hcmsuanMiLCIndXNlIHN0cmljdCc7XG5cbnZhciBUeXBlID0gcmVxdWlyZSgnLi4vdHlwZScpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IG5ldyBUeXBlKCd0YWc6eWFtbC5vcmcsMjAwMjpzdHInLCB7XG4gIGtpbmQ6ICdzY2FsYXInLFxuICBjb25zdHJ1Y3Q6IGZ1bmN0aW9uIChkYXRhKSB7IHJldHVybiBkYXRhICE9PSBudWxsID8gZGF0YSA6ICcnOyB9XG59KTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9qcy15YW1sL2xpYi9qcy15YW1sL3R5cGUvc3RyLmpzIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgVHlwZSA9IHJlcXVpcmUoJy4uL3R5cGUnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBuZXcgVHlwZSgndGFnOnlhbWwub3JnLDIwMDI6c2VxJywge1xuICBraW5kOiAnc2VxdWVuY2UnLFxuICBjb25zdHJ1Y3Q6IGZ1bmN0aW9uIChkYXRhKSB7IHJldHVybiBkYXRhICE9PSBudWxsID8gZGF0YSA6IFtdOyB9XG59KTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9qcy15YW1sL2xpYi9qcy15YW1sL3R5cGUvc2VxLmpzIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgVHlwZSA9IHJlcXVpcmUoJy4uL3R5cGUnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBuZXcgVHlwZSgndGFnOnlhbWwub3JnLDIwMDI6bWFwJywge1xuICBraW5kOiAnbWFwcGluZycsXG4gIGNvbnN0cnVjdDogZnVuY3Rpb24gKGRhdGEpIHsgcmV0dXJuIGRhdGEgIT09IG51bGwgPyBkYXRhIDoge307IH1cbn0pO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2pzLXlhbWwvbGliL2pzLXlhbWwvdHlwZS9tYXAuanMiLCIndXNlIHN0cmljdCc7XG5cbnZhciBUeXBlID0gcmVxdWlyZSgnLi4vdHlwZScpO1xuXG5mdW5jdGlvbiByZXNvbHZlWWFtbE51bGwoZGF0YSkge1xuICBpZiAoZGF0YSA9PT0gbnVsbCkgcmV0dXJuIHRydWU7XG5cbiAgdmFyIG1heCA9IGRhdGEubGVuZ3RoO1xuXG4gIHJldHVybiAobWF4ID09PSAxICYmIGRhdGEgPT09ICd+JykgfHxcbiAgICAgICAgIChtYXggPT09IDQgJiYgKGRhdGEgPT09ICdudWxsJyB8fCBkYXRhID09PSAnTnVsbCcgfHwgZGF0YSA9PT0gJ05VTEwnKSk7XG59XG5cbmZ1bmN0aW9uIGNvbnN0cnVjdFlhbWxOdWxsKCkge1xuICByZXR1cm4gbnVsbDtcbn1cblxuZnVuY3Rpb24gaXNOdWxsKG9iamVjdCkge1xuICByZXR1cm4gb2JqZWN0ID09PSBudWxsO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IG5ldyBUeXBlKCd0YWc6eWFtbC5vcmcsMjAwMjpudWxsJywge1xuICBraW5kOiAnc2NhbGFyJyxcbiAgcmVzb2x2ZTogcmVzb2x2ZVlhbWxOdWxsLFxuICBjb25zdHJ1Y3Q6IGNvbnN0cnVjdFlhbWxOdWxsLFxuICBwcmVkaWNhdGU6IGlzTnVsbCxcbiAgcmVwcmVzZW50OiB7XG4gICAgY2Fub25pY2FsOiBmdW5jdGlvbiAoKSB7IHJldHVybiAnfic7ICAgIH0sXG4gICAgbG93ZXJjYXNlOiBmdW5jdGlvbiAoKSB7IHJldHVybiAnbnVsbCc7IH0sXG4gICAgdXBwZXJjYXNlOiBmdW5jdGlvbiAoKSB7IHJldHVybiAnTlVMTCc7IH0sXG4gICAgY2FtZWxjYXNlOiBmdW5jdGlvbiAoKSB7IHJldHVybiAnTnVsbCc7IH1cbiAgfSxcbiAgZGVmYXVsdFN0eWxlOiAnbG93ZXJjYXNlJ1xufSk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvanMteWFtbC9saWIvanMteWFtbC90eXBlL251bGwuanMiLCIndXNlIHN0cmljdCc7XG5cbnZhciBUeXBlID0gcmVxdWlyZSgnLi4vdHlwZScpO1xuXG5mdW5jdGlvbiByZXNvbHZlWWFtbEJvb2xlYW4oZGF0YSkge1xuICBpZiAoZGF0YSA9PT0gbnVsbCkgcmV0dXJuIGZhbHNlO1xuXG4gIHZhciBtYXggPSBkYXRhLmxlbmd0aDtcblxuICByZXR1cm4gKG1heCA9PT0gNCAmJiAoZGF0YSA9PT0gJ3RydWUnIHx8IGRhdGEgPT09ICdUcnVlJyB8fCBkYXRhID09PSAnVFJVRScpKSB8fFxuICAgICAgICAgKG1heCA9PT0gNSAmJiAoZGF0YSA9PT0gJ2ZhbHNlJyB8fCBkYXRhID09PSAnRmFsc2UnIHx8IGRhdGEgPT09ICdGQUxTRScpKTtcbn1cblxuZnVuY3Rpb24gY29uc3RydWN0WWFtbEJvb2xlYW4oZGF0YSkge1xuICByZXR1cm4gZGF0YSA9PT0gJ3RydWUnIHx8XG4gICAgICAgICBkYXRhID09PSAnVHJ1ZScgfHxcbiAgICAgICAgIGRhdGEgPT09ICdUUlVFJztcbn1cblxuZnVuY3Rpb24gaXNCb29sZWFuKG9iamVjdCkge1xuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG9iamVjdCkgPT09ICdbb2JqZWN0IEJvb2xlYW5dJztcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBuZXcgVHlwZSgndGFnOnlhbWwub3JnLDIwMDI6Ym9vbCcsIHtcbiAga2luZDogJ3NjYWxhcicsXG4gIHJlc29sdmU6IHJlc29sdmVZYW1sQm9vbGVhbixcbiAgY29uc3RydWN0OiBjb25zdHJ1Y3RZYW1sQm9vbGVhbixcbiAgcHJlZGljYXRlOiBpc0Jvb2xlYW4sXG4gIHJlcHJlc2VudDoge1xuICAgIGxvd2VyY2FzZTogZnVuY3Rpb24gKG9iamVjdCkgeyByZXR1cm4gb2JqZWN0ID8gJ3RydWUnIDogJ2ZhbHNlJzsgfSxcbiAgICB1cHBlcmNhc2U6IGZ1bmN0aW9uIChvYmplY3QpIHsgcmV0dXJuIG9iamVjdCA/ICdUUlVFJyA6ICdGQUxTRSc7IH0sXG4gICAgY2FtZWxjYXNlOiBmdW5jdGlvbiAob2JqZWN0KSB7IHJldHVybiBvYmplY3QgPyAnVHJ1ZScgOiAnRmFsc2UnOyB9XG4gIH0sXG4gIGRlZmF1bHRTdHlsZTogJ2xvd2VyY2FzZSdcbn0pO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2pzLXlhbWwvbGliL2pzLXlhbWwvdHlwZS9ib29sLmpzIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgY29tbW9uID0gcmVxdWlyZSgnLi4vY29tbW9uJyk7XG52YXIgVHlwZSAgID0gcmVxdWlyZSgnLi4vdHlwZScpO1xuXG5mdW5jdGlvbiBpc0hleENvZGUoYykge1xuICByZXR1cm4gKCgweDMwLyogMCAqLyA8PSBjKSAmJiAoYyA8PSAweDM5LyogOSAqLykpIHx8XG4gICAgICAgICAoKDB4NDEvKiBBICovIDw9IGMpICYmIChjIDw9IDB4NDYvKiBGICovKSkgfHxcbiAgICAgICAgICgoMHg2MS8qIGEgKi8gPD0gYykgJiYgKGMgPD0gMHg2Ni8qIGYgKi8pKTtcbn1cblxuZnVuY3Rpb24gaXNPY3RDb2RlKGMpIHtcbiAgcmV0dXJuICgoMHgzMC8qIDAgKi8gPD0gYykgJiYgKGMgPD0gMHgzNy8qIDcgKi8pKTtcbn1cblxuZnVuY3Rpb24gaXNEZWNDb2RlKGMpIHtcbiAgcmV0dXJuICgoMHgzMC8qIDAgKi8gPD0gYykgJiYgKGMgPD0gMHgzOS8qIDkgKi8pKTtcbn1cblxuZnVuY3Rpb24gcmVzb2x2ZVlhbWxJbnRlZ2VyKGRhdGEpIHtcbiAgaWYgKGRhdGEgPT09IG51bGwpIHJldHVybiBmYWxzZTtcblxuICB2YXIgbWF4ID0gZGF0YS5sZW5ndGgsXG4gICAgICBpbmRleCA9IDAsXG4gICAgICBoYXNEaWdpdHMgPSBmYWxzZSxcbiAgICAgIGNoO1xuXG4gIGlmICghbWF4KSByZXR1cm4gZmFsc2U7XG5cbiAgY2ggPSBkYXRhW2luZGV4XTtcblxuICAvLyBzaWduXG4gIGlmIChjaCA9PT0gJy0nIHx8IGNoID09PSAnKycpIHtcbiAgICBjaCA9IGRhdGFbKytpbmRleF07XG4gIH1cblxuICBpZiAoY2ggPT09ICcwJykge1xuICAgIC8vIDBcbiAgICBpZiAoaW5kZXggKyAxID09PSBtYXgpIHJldHVybiB0cnVlO1xuICAgIGNoID0gZGF0YVsrK2luZGV4XTtcblxuICAgIC8vIGJhc2UgMiwgYmFzZSA4LCBiYXNlIDE2XG5cbiAgICBpZiAoY2ggPT09ICdiJykge1xuICAgICAgLy8gYmFzZSAyXG4gICAgICBpbmRleCsrO1xuXG4gICAgICBmb3IgKDsgaW5kZXggPCBtYXg7IGluZGV4KyspIHtcbiAgICAgICAgY2ggPSBkYXRhW2luZGV4XTtcbiAgICAgICAgaWYgKGNoID09PSAnXycpIGNvbnRpbnVlO1xuICAgICAgICBpZiAoY2ggIT09ICcwJyAmJiBjaCAhPT0gJzEnKSByZXR1cm4gZmFsc2U7XG4gICAgICAgIGhhc0RpZ2l0cyA9IHRydWU7XG4gICAgICB9XG4gICAgICByZXR1cm4gaGFzRGlnaXRzICYmIGNoICE9PSAnXyc7XG4gICAgfVxuXG5cbiAgICBpZiAoY2ggPT09ICd4Jykge1xuICAgICAgLy8gYmFzZSAxNlxuICAgICAgaW5kZXgrKztcblxuICAgICAgZm9yICg7IGluZGV4IDwgbWF4OyBpbmRleCsrKSB7XG4gICAgICAgIGNoID0gZGF0YVtpbmRleF07XG4gICAgICAgIGlmIChjaCA9PT0gJ18nKSBjb250aW51ZTtcbiAgICAgICAgaWYgKCFpc0hleENvZGUoZGF0YS5jaGFyQ29kZUF0KGluZGV4KSkpIHJldHVybiBmYWxzZTtcbiAgICAgICAgaGFzRGlnaXRzID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBoYXNEaWdpdHMgJiYgY2ggIT09ICdfJztcbiAgICB9XG5cbiAgICAvLyBiYXNlIDhcbiAgICBmb3IgKDsgaW5kZXggPCBtYXg7IGluZGV4KyspIHtcbiAgICAgIGNoID0gZGF0YVtpbmRleF07XG4gICAgICBpZiAoY2ggPT09ICdfJykgY29udGludWU7XG4gICAgICBpZiAoIWlzT2N0Q29kZShkYXRhLmNoYXJDb2RlQXQoaW5kZXgpKSkgcmV0dXJuIGZhbHNlO1xuICAgICAgaGFzRGlnaXRzID0gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGhhc0RpZ2l0cyAmJiBjaCAhPT0gJ18nO1xuICB9XG5cbiAgLy8gYmFzZSAxMCAoZXhjZXB0IDApIG9yIGJhc2UgNjBcblxuICAvLyB2YWx1ZSBzaG91bGQgbm90IHN0YXJ0IHdpdGggYF9gO1xuICBpZiAoY2ggPT09ICdfJykgcmV0dXJuIGZhbHNlO1xuXG4gIGZvciAoOyBpbmRleCA8IG1heDsgaW5kZXgrKykge1xuICAgIGNoID0gZGF0YVtpbmRleF07XG4gICAgaWYgKGNoID09PSAnXycpIGNvbnRpbnVlO1xuICAgIGlmIChjaCA9PT0gJzonKSBicmVhaztcbiAgICBpZiAoIWlzRGVjQ29kZShkYXRhLmNoYXJDb2RlQXQoaW5kZXgpKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBoYXNEaWdpdHMgPSB0cnVlO1xuICB9XG5cbiAgLy8gU2hvdWxkIGhhdmUgZGlnaXRzIGFuZCBzaG91bGQgbm90IGVuZCB3aXRoIGBfYFxuICBpZiAoIWhhc0RpZ2l0cyB8fCBjaCA9PT0gJ18nKSByZXR1cm4gZmFsc2U7XG5cbiAgLy8gaWYgIWJhc2U2MCAtIGRvbmU7XG4gIGlmIChjaCAhPT0gJzonKSByZXR1cm4gdHJ1ZTtcblxuICAvLyBiYXNlNjAgYWxtb3N0IG5vdCB1c2VkLCBubyBuZWVkcyB0byBvcHRpbWl6ZVxuICByZXR1cm4gL14oOlswLTVdP1swLTldKSskLy50ZXN0KGRhdGEuc2xpY2UoaW5kZXgpKTtcbn1cblxuZnVuY3Rpb24gY29uc3RydWN0WWFtbEludGVnZXIoZGF0YSkge1xuICB2YXIgdmFsdWUgPSBkYXRhLCBzaWduID0gMSwgY2gsIGJhc2UsIGRpZ2l0cyA9IFtdO1xuXG4gIGlmICh2YWx1ZS5pbmRleE9mKCdfJykgIT09IC0xKSB7XG4gICAgdmFsdWUgPSB2YWx1ZS5yZXBsYWNlKC9fL2csICcnKTtcbiAgfVxuXG4gIGNoID0gdmFsdWVbMF07XG5cbiAgaWYgKGNoID09PSAnLScgfHwgY2ggPT09ICcrJykge1xuICAgIGlmIChjaCA9PT0gJy0nKSBzaWduID0gLTE7XG4gICAgdmFsdWUgPSB2YWx1ZS5zbGljZSgxKTtcbiAgICBjaCA9IHZhbHVlWzBdO1xuICB9XG5cbiAgaWYgKHZhbHVlID09PSAnMCcpIHJldHVybiAwO1xuXG4gIGlmIChjaCA9PT0gJzAnKSB7XG4gICAgaWYgKHZhbHVlWzFdID09PSAnYicpIHJldHVybiBzaWduICogcGFyc2VJbnQodmFsdWUuc2xpY2UoMiksIDIpO1xuICAgIGlmICh2YWx1ZVsxXSA9PT0gJ3gnKSByZXR1cm4gc2lnbiAqIHBhcnNlSW50KHZhbHVlLCAxNik7XG4gICAgcmV0dXJuIHNpZ24gKiBwYXJzZUludCh2YWx1ZSwgOCk7XG4gIH1cblxuICBpZiAodmFsdWUuaW5kZXhPZignOicpICE9PSAtMSkge1xuICAgIHZhbHVlLnNwbGl0KCc6JykuZm9yRWFjaChmdW5jdGlvbiAodikge1xuICAgICAgZGlnaXRzLnVuc2hpZnQocGFyc2VJbnQodiwgMTApKTtcbiAgICB9KTtcblxuICAgIHZhbHVlID0gMDtcbiAgICBiYXNlID0gMTtcblxuICAgIGRpZ2l0cy5mb3JFYWNoKGZ1bmN0aW9uIChkKSB7XG4gICAgICB2YWx1ZSArPSAoZCAqIGJhc2UpO1xuICAgICAgYmFzZSAqPSA2MDtcbiAgICB9KTtcblxuICAgIHJldHVybiBzaWduICogdmFsdWU7XG5cbiAgfVxuXG4gIHJldHVybiBzaWduICogcGFyc2VJbnQodmFsdWUsIDEwKTtcbn1cblxuZnVuY3Rpb24gaXNJbnRlZ2VyKG9iamVjdCkge1xuICByZXR1cm4gKE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvYmplY3QpKSA9PT0gJ1tvYmplY3QgTnVtYmVyXScgJiZcbiAgICAgICAgIChvYmplY3QgJSAxID09PSAwICYmICFjb21tb24uaXNOZWdhdGl2ZVplcm8ob2JqZWN0KSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gbmV3IFR5cGUoJ3RhZzp5YW1sLm9yZywyMDAyOmludCcsIHtcbiAga2luZDogJ3NjYWxhcicsXG4gIHJlc29sdmU6IHJlc29sdmVZYW1sSW50ZWdlcixcbiAgY29uc3RydWN0OiBjb25zdHJ1Y3RZYW1sSW50ZWdlcixcbiAgcHJlZGljYXRlOiBpc0ludGVnZXIsXG4gIHJlcHJlc2VudDoge1xuICAgIGJpbmFyeTogICAgICBmdW5jdGlvbiAob2JqZWN0KSB7IHJldHVybiAnMGInICsgb2JqZWN0LnRvU3RyaW5nKDIpOyB9LFxuICAgIG9jdGFsOiAgICAgICBmdW5jdGlvbiAob2JqZWN0KSB7IHJldHVybiAnMCcgICsgb2JqZWN0LnRvU3RyaW5nKDgpOyB9LFxuICAgIGRlY2ltYWw6ICAgICBmdW5jdGlvbiAob2JqZWN0KSB7IHJldHVybiAgICAgICAgb2JqZWN0LnRvU3RyaW5nKDEwKTsgfSxcbiAgICBoZXhhZGVjaW1hbDogZnVuY3Rpb24gKG9iamVjdCkgeyByZXR1cm4gJzB4JyArIG9iamVjdC50b1N0cmluZygxNikudG9VcHBlckNhc2UoKTsgfVxuICB9LFxuICBkZWZhdWx0U3R5bGU6ICdkZWNpbWFsJyxcbiAgc3R5bGVBbGlhc2VzOiB7XG4gICAgYmluYXJ5OiAgICAgIFsgMiwgICdiaW4nIF0sXG4gICAgb2N0YWw6ICAgICAgIFsgOCwgICdvY3QnIF0sXG4gICAgZGVjaW1hbDogICAgIFsgMTAsICdkZWMnIF0sXG4gICAgaGV4YWRlY2ltYWw6IFsgMTYsICdoZXgnIF1cbiAgfVxufSk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvanMteWFtbC9saWIvanMteWFtbC90eXBlL2ludC5qcyIsIid1c2Ugc3RyaWN0JztcblxudmFyIGNvbW1vbiA9IHJlcXVpcmUoJy4uL2NvbW1vbicpO1xudmFyIFR5cGUgICA9IHJlcXVpcmUoJy4uL3R5cGUnKTtcblxudmFyIFlBTUxfRkxPQVRfUEFUVEVSTiA9IG5ldyBSZWdFeHAoXG4gIC8vIDIuNWU0LCAyLjUgYW5kIGludGVnZXJzXG4gICdeKD86Wy0rXT8oPzowfFsxLTldWzAtOV9dKikoPzpcXFxcLlswLTlfXSopPyg/OltlRV1bLStdP1swLTldKyk/JyArXG4gIC8vIC4yZTQsIC4yXG4gIC8vIHNwZWNpYWwgY2FzZSwgc2VlbXMgbm90IGZyb20gc3BlY1xuICAnfFxcXFwuWzAtOV9dKyg/OltlRV1bLStdP1swLTldKyk/JyArXG4gIC8vIDIwOjU5XG4gICd8Wy0rXT9bMC05XVswLTlfXSooPzo6WzAtNV0/WzAtOV0pK1xcXFwuWzAtOV9dKicgK1xuICAvLyAuaW5mXG4gICd8Wy0rXT9cXFxcLig/OmluZnxJbmZ8SU5GKScgK1xuICAvLyAubmFuXG4gICd8XFxcXC4oPzpuYW58TmFOfE5BTikpJCcpO1xuXG5mdW5jdGlvbiByZXNvbHZlWWFtbEZsb2F0KGRhdGEpIHtcbiAgaWYgKGRhdGEgPT09IG51bGwpIHJldHVybiBmYWxzZTtcblxuICBpZiAoIVlBTUxfRkxPQVRfUEFUVEVSTi50ZXN0KGRhdGEpIHx8XG4gICAgICAvLyBRdWljayBoYWNrIHRvIG5vdCBhbGxvdyBpbnRlZ2VycyBlbmQgd2l0aCBgX2BcbiAgICAgIC8vIFByb2JhYmx5IHNob3VsZCB1cGRhdGUgcmVnZXhwICYgY2hlY2sgc3BlZWRcbiAgICAgIGRhdGFbZGF0YS5sZW5ndGggLSAxXSA9PT0gJ18nKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59XG5cbmZ1bmN0aW9uIGNvbnN0cnVjdFlhbWxGbG9hdChkYXRhKSB7XG4gIHZhciB2YWx1ZSwgc2lnbiwgYmFzZSwgZGlnaXRzO1xuXG4gIHZhbHVlICA9IGRhdGEucmVwbGFjZSgvXy9nLCAnJykudG9Mb3dlckNhc2UoKTtcbiAgc2lnbiAgID0gdmFsdWVbMF0gPT09ICctJyA/IC0xIDogMTtcbiAgZGlnaXRzID0gW107XG5cbiAgaWYgKCcrLScuaW5kZXhPZih2YWx1ZVswXSkgPj0gMCkge1xuICAgIHZhbHVlID0gdmFsdWUuc2xpY2UoMSk7XG4gIH1cblxuICBpZiAodmFsdWUgPT09ICcuaW5mJykge1xuICAgIHJldHVybiAoc2lnbiA9PT0gMSkgPyBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFkgOiBOdW1iZXIuTkVHQVRJVkVfSU5GSU5JVFk7XG5cbiAgfSBlbHNlIGlmICh2YWx1ZSA9PT0gJy5uYW4nKSB7XG4gICAgcmV0dXJuIE5hTjtcblxuICB9IGVsc2UgaWYgKHZhbHVlLmluZGV4T2YoJzonKSA+PSAwKSB7XG4gICAgdmFsdWUuc3BsaXQoJzonKS5mb3JFYWNoKGZ1bmN0aW9uICh2KSB7XG4gICAgICBkaWdpdHMudW5zaGlmdChwYXJzZUZsb2F0KHYsIDEwKSk7XG4gICAgfSk7XG5cbiAgICB2YWx1ZSA9IDAuMDtcbiAgICBiYXNlID0gMTtcblxuICAgIGRpZ2l0cy5mb3JFYWNoKGZ1bmN0aW9uIChkKSB7XG4gICAgICB2YWx1ZSArPSBkICogYmFzZTtcbiAgICAgIGJhc2UgKj0gNjA7XG4gICAgfSk7XG5cbiAgICByZXR1cm4gc2lnbiAqIHZhbHVlO1xuXG4gIH1cbiAgcmV0dXJuIHNpZ24gKiBwYXJzZUZsb2F0KHZhbHVlLCAxMCk7XG59XG5cblxudmFyIFNDSUVOVElGSUNfV0lUSE9VVF9ET1QgPSAvXlstK10/WzAtOV0rZS87XG5cbmZ1bmN0aW9uIHJlcHJlc2VudFlhbWxGbG9hdChvYmplY3QsIHN0eWxlKSB7XG4gIHZhciByZXM7XG5cbiAgaWYgKGlzTmFOKG9iamVjdCkpIHtcbiAgICBzd2l0Y2ggKHN0eWxlKSB7XG4gICAgICBjYXNlICdsb3dlcmNhc2UnOiByZXR1cm4gJy5uYW4nO1xuICAgICAgY2FzZSAndXBwZXJjYXNlJzogcmV0dXJuICcuTkFOJztcbiAgICAgIGNhc2UgJ2NhbWVsY2FzZSc6IHJldHVybiAnLk5hTic7XG4gICAgfVxuICB9IGVsc2UgaWYgKE51bWJlci5QT1NJVElWRV9JTkZJTklUWSA9PT0gb2JqZWN0KSB7XG4gICAgc3dpdGNoIChzdHlsZSkge1xuICAgICAgY2FzZSAnbG93ZXJjYXNlJzogcmV0dXJuICcuaW5mJztcbiAgICAgIGNhc2UgJ3VwcGVyY2FzZSc6IHJldHVybiAnLklORic7XG4gICAgICBjYXNlICdjYW1lbGNhc2UnOiByZXR1cm4gJy5JbmYnO1xuICAgIH1cbiAgfSBlbHNlIGlmIChOdW1iZXIuTkVHQVRJVkVfSU5GSU5JVFkgPT09IG9iamVjdCkge1xuICAgIHN3aXRjaCAoc3R5bGUpIHtcbiAgICAgIGNhc2UgJ2xvd2VyY2FzZSc6IHJldHVybiAnLS5pbmYnO1xuICAgICAgY2FzZSAndXBwZXJjYXNlJzogcmV0dXJuICctLklORic7XG4gICAgICBjYXNlICdjYW1lbGNhc2UnOiByZXR1cm4gJy0uSW5mJztcbiAgICB9XG4gIH0gZWxzZSBpZiAoY29tbW9uLmlzTmVnYXRpdmVaZXJvKG9iamVjdCkpIHtcbiAgICByZXR1cm4gJy0wLjAnO1xuICB9XG5cbiAgcmVzID0gb2JqZWN0LnRvU3RyaW5nKDEwKTtcblxuICAvLyBKUyBzdHJpbmdpZmllciBjYW4gYnVpbGQgc2NpZW50aWZpYyBmb3JtYXQgd2l0aG91dCBkb3RzOiA1ZS0xMDAsXG4gIC8vIHdoaWxlIFlBTUwgcmVxdXJlcyBkb3Q6IDUuZS0xMDAuIEZpeCBpdCB3aXRoIHNpbXBsZSBoYWNrXG5cbiAgcmV0dXJuIFNDSUVOVElGSUNfV0lUSE9VVF9ET1QudGVzdChyZXMpID8gcmVzLnJlcGxhY2UoJ2UnLCAnLmUnKSA6IHJlcztcbn1cblxuZnVuY3Rpb24gaXNGbG9hdChvYmplY3QpIHtcbiAgcmV0dXJuIChPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwob2JqZWN0KSA9PT0gJ1tvYmplY3QgTnVtYmVyXScpICYmXG4gICAgICAgICAob2JqZWN0ICUgMSAhPT0gMCB8fCBjb21tb24uaXNOZWdhdGl2ZVplcm8ob2JqZWN0KSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gbmV3IFR5cGUoJ3RhZzp5YW1sLm9yZywyMDAyOmZsb2F0Jywge1xuICBraW5kOiAnc2NhbGFyJyxcbiAgcmVzb2x2ZTogcmVzb2x2ZVlhbWxGbG9hdCxcbiAgY29uc3RydWN0OiBjb25zdHJ1Y3RZYW1sRmxvYXQsXG4gIHByZWRpY2F0ZTogaXNGbG9hdCxcbiAgcmVwcmVzZW50OiByZXByZXNlbnRZYW1sRmxvYXQsXG4gIGRlZmF1bHRTdHlsZTogJ2xvd2VyY2FzZSdcbn0pO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2pzLXlhbWwvbGliL2pzLXlhbWwvdHlwZS9mbG9hdC5qcyIsIid1c2Ugc3RyaWN0JztcblxudmFyIFR5cGUgPSByZXF1aXJlKCcuLi90eXBlJyk7XG5cbnZhciBZQU1MX0RBVEVfUkVHRVhQID0gbmV3IFJlZ0V4cChcbiAgJ14oWzAtOV1bMC05XVswLTldWzAtOV0pJyAgICAgICAgICArIC8vIFsxXSB5ZWFyXG4gICctKFswLTldWzAtOV0pJyAgICAgICAgICAgICAgICAgICAgKyAvLyBbMl0gbW9udGhcbiAgJy0oWzAtOV1bMC05XSkkJyk7ICAgICAgICAgICAgICAgICAgIC8vIFszXSBkYXlcblxudmFyIFlBTUxfVElNRVNUQU1QX1JFR0VYUCA9IG5ldyBSZWdFeHAoXG4gICdeKFswLTldWzAtOV1bMC05XVswLTldKScgICAgICAgICAgKyAvLyBbMV0geWVhclxuICAnLShbMC05XVswLTldPyknICAgICAgICAgICAgICAgICAgICsgLy8gWzJdIG1vbnRoXG4gICctKFswLTldWzAtOV0/KScgICAgICAgICAgICAgICAgICAgKyAvLyBbM10gZGF5XG4gICcoPzpbVHRdfFsgXFxcXHRdKyknICAgICAgICAgICAgICAgICArIC8vIC4uLlxuICAnKFswLTldWzAtOV0/KScgICAgICAgICAgICAgICAgICAgICsgLy8gWzRdIGhvdXJcbiAgJzooWzAtOV1bMC05XSknICAgICAgICAgICAgICAgICAgICArIC8vIFs1XSBtaW51dGVcbiAgJzooWzAtOV1bMC05XSknICAgICAgICAgICAgICAgICAgICArIC8vIFs2XSBzZWNvbmRcbiAgJyg/OlxcXFwuKFswLTldKikpPycgICAgICAgICAgICAgICAgICsgLy8gWzddIGZyYWN0aW9uXG4gICcoPzpbIFxcXFx0XSooWnwoWy0rXSkoWzAtOV1bMC05XT8pJyArIC8vIFs4XSB0eiBbOV0gdHpfc2lnbiBbMTBdIHR6X2hvdXJcbiAgJyg/OjooWzAtOV1bMC05XSkpPykpPyQnKTsgICAgICAgICAgIC8vIFsxMV0gdHpfbWludXRlXG5cbmZ1bmN0aW9uIHJlc29sdmVZYW1sVGltZXN0YW1wKGRhdGEpIHtcbiAgaWYgKGRhdGEgPT09IG51bGwpIHJldHVybiBmYWxzZTtcbiAgaWYgKFlBTUxfREFURV9SRUdFWFAuZXhlYyhkYXRhKSAhPT0gbnVsbCkgcmV0dXJuIHRydWU7XG4gIGlmIChZQU1MX1RJTUVTVEFNUF9SRUdFWFAuZXhlYyhkYXRhKSAhPT0gbnVsbCkgcmV0dXJuIHRydWU7XG4gIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gY29uc3RydWN0WWFtbFRpbWVzdGFtcChkYXRhKSB7XG4gIHZhciBtYXRjaCwgeWVhciwgbW9udGgsIGRheSwgaG91ciwgbWludXRlLCBzZWNvbmQsIGZyYWN0aW9uID0gMCxcbiAgICAgIGRlbHRhID0gbnVsbCwgdHpfaG91ciwgdHpfbWludXRlLCBkYXRlO1xuXG4gIG1hdGNoID0gWUFNTF9EQVRFX1JFR0VYUC5leGVjKGRhdGEpO1xuICBpZiAobWF0Y2ggPT09IG51bGwpIG1hdGNoID0gWUFNTF9USU1FU1RBTVBfUkVHRVhQLmV4ZWMoZGF0YSk7XG5cbiAgaWYgKG1hdGNoID09PSBudWxsKSB0aHJvdyBuZXcgRXJyb3IoJ0RhdGUgcmVzb2x2ZSBlcnJvcicpO1xuXG4gIC8vIG1hdGNoOiBbMV0geWVhciBbMl0gbW9udGggWzNdIGRheVxuXG4gIHllYXIgPSArKG1hdGNoWzFdKTtcbiAgbW9udGggPSArKG1hdGNoWzJdKSAtIDE7IC8vIEpTIG1vbnRoIHN0YXJ0cyB3aXRoIDBcbiAgZGF5ID0gKyhtYXRjaFszXSk7XG5cbiAgaWYgKCFtYXRjaFs0XSkgeyAvLyBubyBob3VyXG4gICAgcmV0dXJuIG5ldyBEYXRlKERhdGUuVVRDKHllYXIsIG1vbnRoLCBkYXkpKTtcbiAgfVxuXG4gIC8vIG1hdGNoOiBbNF0gaG91ciBbNV0gbWludXRlIFs2XSBzZWNvbmQgWzddIGZyYWN0aW9uXG5cbiAgaG91ciA9ICsobWF0Y2hbNF0pO1xuICBtaW51dGUgPSArKG1hdGNoWzVdKTtcbiAgc2Vjb25kID0gKyhtYXRjaFs2XSk7XG5cbiAgaWYgKG1hdGNoWzddKSB7XG4gICAgZnJhY3Rpb24gPSBtYXRjaFs3XS5zbGljZSgwLCAzKTtcbiAgICB3aGlsZSAoZnJhY3Rpb24ubGVuZ3RoIDwgMykgeyAvLyBtaWxsaS1zZWNvbmRzXG4gICAgICBmcmFjdGlvbiArPSAnMCc7XG4gICAgfVxuICAgIGZyYWN0aW9uID0gK2ZyYWN0aW9uO1xuICB9XG5cbiAgLy8gbWF0Y2g6IFs4XSB0eiBbOV0gdHpfc2lnbiBbMTBdIHR6X2hvdXIgWzExXSB0el9taW51dGVcblxuICBpZiAobWF0Y2hbOV0pIHtcbiAgICB0el9ob3VyID0gKyhtYXRjaFsxMF0pO1xuICAgIHR6X21pbnV0ZSA9ICsobWF0Y2hbMTFdIHx8IDApO1xuICAgIGRlbHRhID0gKHR6X2hvdXIgKiA2MCArIHR6X21pbnV0ZSkgKiA2MDAwMDsgLy8gZGVsdGEgaW4gbWlsaS1zZWNvbmRzXG4gICAgaWYgKG1hdGNoWzldID09PSAnLScpIGRlbHRhID0gLWRlbHRhO1xuICB9XG5cbiAgZGF0ZSA9IG5ldyBEYXRlKERhdGUuVVRDKHllYXIsIG1vbnRoLCBkYXksIGhvdXIsIG1pbnV0ZSwgc2Vjb25kLCBmcmFjdGlvbikpO1xuXG4gIGlmIChkZWx0YSkgZGF0ZS5zZXRUaW1lKGRhdGUuZ2V0VGltZSgpIC0gZGVsdGEpO1xuXG4gIHJldHVybiBkYXRlO1xufVxuXG5mdW5jdGlvbiByZXByZXNlbnRZYW1sVGltZXN0YW1wKG9iamVjdCAvKiwgc3R5bGUqLykge1xuICByZXR1cm4gb2JqZWN0LnRvSVNPU3RyaW5nKCk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gbmV3IFR5cGUoJ3RhZzp5YW1sLm9yZywyMDAyOnRpbWVzdGFtcCcsIHtcbiAga2luZDogJ3NjYWxhcicsXG4gIHJlc29sdmU6IHJlc29sdmVZYW1sVGltZXN0YW1wLFxuICBjb25zdHJ1Y3Q6IGNvbnN0cnVjdFlhbWxUaW1lc3RhbXAsXG4gIGluc3RhbmNlT2Y6IERhdGUsXG4gIHJlcHJlc2VudDogcmVwcmVzZW50WWFtbFRpbWVzdGFtcFxufSk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvanMteWFtbC9saWIvanMteWFtbC90eXBlL3RpbWVzdGFtcC5qcyIsIid1c2Ugc3RyaWN0JztcblxudmFyIFR5cGUgPSByZXF1aXJlKCcuLi90eXBlJyk7XG5cbmZ1bmN0aW9uIHJlc29sdmVZYW1sTWVyZ2UoZGF0YSkge1xuICByZXR1cm4gZGF0YSA9PT0gJzw8JyB8fCBkYXRhID09PSBudWxsO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IG5ldyBUeXBlKCd0YWc6eWFtbC5vcmcsMjAwMjptZXJnZScsIHtcbiAga2luZDogJ3NjYWxhcicsXG4gIHJlc29sdmU6IHJlc29sdmVZYW1sTWVyZ2Vcbn0pO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2pzLXlhbWwvbGliL2pzLXlhbWwvdHlwZS9tZXJnZS5qcyIsIid1c2Ugc3RyaWN0JztcblxuLyplc2xpbnQtZGlzYWJsZSBuby1iaXR3aXNlKi9cblxudmFyIE5vZGVCdWZmZXI7XG5cbnRyeSB7XG4gIC8vIEEgdHJpY2sgZm9yIGJyb3dzZXJpZmllZCB2ZXJzaW9uLCB0byBub3QgaW5jbHVkZSBgQnVmZmVyYCBzaGltXG4gIHZhciBfcmVxdWlyZSA9IHJlcXVpcmU7XG4gIE5vZGVCdWZmZXIgPSBfcmVxdWlyZSgnYnVmZmVyJykuQnVmZmVyO1xufSBjYXRjaCAoX18pIHt9XG5cbnZhciBUeXBlICAgICAgID0gcmVxdWlyZSgnLi4vdHlwZScpO1xuXG5cbi8vIFsgNjQsIDY1LCA2NiBdIC0+IFsgcGFkZGluZywgQ1IsIExGIF1cbnZhciBCQVNFNjRfTUFQID0gJ0FCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDU2Nzg5Ky89XFxuXFxyJztcblxuXG5mdW5jdGlvbiByZXNvbHZlWWFtbEJpbmFyeShkYXRhKSB7XG4gIGlmIChkYXRhID09PSBudWxsKSByZXR1cm4gZmFsc2U7XG5cbiAgdmFyIGNvZGUsIGlkeCwgYml0bGVuID0gMCwgbWF4ID0gZGF0YS5sZW5ndGgsIG1hcCA9IEJBU0U2NF9NQVA7XG5cbiAgLy8gQ29udmVydCBvbmUgYnkgb25lLlxuICBmb3IgKGlkeCA9IDA7IGlkeCA8IG1heDsgaWR4KyspIHtcbiAgICBjb2RlID0gbWFwLmluZGV4T2YoZGF0YS5jaGFyQXQoaWR4KSk7XG5cbiAgICAvLyBTa2lwIENSL0xGXG4gICAgaWYgKGNvZGUgPiA2NCkgY29udGludWU7XG5cbiAgICAvLyBGYWlsIG9uIGlsbGVnYWwgY2hhcmFjdGVyc1xuICAgIGlmIChjb2RlIDwgMCkgcmV0dXJuIGZhbHNlO1xuXG4gICAgYml0bGVuICs9IDY7XG4gIH1cblxuICAvLyBJZiB0aGVyZSBhcmUgYW55IGJpdHMgbGVmdCwgc291cmNlIHdhcyBjb3JydXB0ZWRcbiAgcmV0dXJuIChiaXRsZW4gJSA4KSA9PT0gMDtcbn1cblxuZnVuY3Rpb24gY29uc3RydWN0WWFtbEJpbmFyeShkYXRhKSB7XG4gIHZhciBpZHgsIHRhaWxiaXRzLFxuICAgICAgaW5wdXQgPSBkYXRhLnJlcGxhY2UoL1tcXHJcXG49XS9nLCAnJyksIC8vIHJlbW92ZSBDUi9MRiAmIHBhZGRpbmcgdG8gc2ltcGxpZnkgc2NhblxuICAgICAgbWF4ID0gaW5wdXQubGVuZ3RoLFxuICAgICAgbWFwID0gQkFTRTY0X01BUCxcbiAgICAgIGJpdHMgPSAwLFxuICAgICAgcmVzdWx0ID0gW107XG5cbiAgLy8gQ29sbGVjdCBieSA2KjQgYml0cyAoMyBieXRlcylcblxuICBmb3IgKGlkeCA9IDA7IGlkeCA8IG1heDsgaWR4KyspIHtcbiAgICBpZiAoKGlkeCAlIDQgPT09IDApICYmIGlkeCkge1xuICAgICAgcmVzdWx0LnB1c2goKGJpdHMgPj4gMTYpICYgMHhGRik7XG4gICAgICByZXN1bHQucHVzaCgoYml0cyA+PiA4KSAmIDB4RkYpO1xuICAgICAgcmVzdWx0LnB1c2goYml0cyAmIDB4RkYpO1xuICAgIH1cblxuICAgIGJpdHMgPSAoYml0cyA8PCA2KSB8IG1hcC5pbmRleE9mKGlucHV0LmNoYXJBdChpZHgpKTtcbiAgfVxuXG4gIC8vIER1bXAgdGFpbFxuXG4gIHRhaWxiaXRzID0gKG1heCAlIDQpICogNjtcblxuICBpZiAodGFpbGJpdHMgPT09IDApIHtcbiAgICByZXN1bHQucHVzaCgoYml0cyA+PiAxNikgJiAweEZGKTtcbiAgICByZXN1bHQucHVzaCgoYml0cyA+PiA4KSAmIDB4RkYpO1xuICAgIHJlc3VsdC5wdXNoKGJpdHMgJiAweEZGKTtcbiAgfSBlbHNlIGlmICh0YWlsYml0cyA9PT0gMTgpIHtcbiAgICByZXN1bHQucHVzaCgoYml0cyA+PiAxMCkgJiAweEZGKTtcbiAgICByZXN1bHQucHVzaCgoYml0cyA+PiAyKSAmIDB4RkYpO1xuICB9IGVsc2UgaWYgKHRhaWxiaXRzID09PSAxMikge1xuICAgIHJlc3VsdC5wdXNoKChiaXRzID4+IDQpICYgMHhGRik7XG4gIH1cblxuICAvLyBXcmFwIGludG8gQnVmZmVyIGZvciBOb2RlSlMgYW5kIGxlYXZlIEFycmF5IGZvciBicm93c2VyXG4gIGlmIChOb2RlQnVmZmVyKSB7XG4gICAgLy8gU3VwcG9ydCBub2RlIDYuKyBCdWZmZXIgQVBJIHdoZW4gYXZhaWxhYmxlXG4gICAgcmV0dXJuIE5vZGVCdWZmZXIuZnJvbSA/IE5vZGVCdWZmZXIuZnJvbShyZXN1bHQpIDogbmV3IE5vZGVCdWZmZXIocmVzdWx0KTtcbiAgfVxuXG4gIHJldHVybiByZXN1bHQ7XG59XG5cbmZ1bmN0aW9uIHJlcHJlc2VudFlhbWxCaW5hcnkob2JqZWN0IC8qLCBzdHlsZSovKSB7XG4gIHZhciByZXN1bHQgPSAnJywgYml0cyA9IDAsIGlkeCwgdGFpbCxcbiAgICAgIG1heCA9IG9iamVjdC5sZW5ndGgsXG4gICAgICBtYXAgPSBCQVNFNjRfTUFQO1xuXG4gIC8vIENvbnZlcnQgZXZlcnkgdGhyZWUgYnl0ZXMgdG8gNCBBU0NJSSBjaGFyYWN0ZXJzLlxuXG4gIGZvciAoaWR4ID0gMDsgaWR4IDwgbWF4OyBpZHgrKykge1xuICAgIGlmICgoaWR4ICUgMyA9PT0gMCkgJiYgaWR4KSB7XG4gICAgICByZXN1bHQgKz0gbWFwWyhiaXRzID4+IDE4KSAmIDB4M0ZdO1xuICAgICAgcmVzdWx0ICs9IG1hcFsoYml0cyA+PiAxMikgJiAweDNGXTtcbiAgICAgIHJlc3VsdCArPSBtYXBbKGJpdHMgPj4gNikgJiAweDNGXTtcbiAgICAgIHJlc3VsdCArPSBtYXBbYml0cyAmIDB4M0ZdO1xuICAgIH1cblxuICAgIGJpdHMgPSAoYml0cyA8PCA4KSArIG9iamVjdFtpZHhdO1xuICB9XG5cbiAgLy8gRHVtcCB0YWlsXG5cbiAgdGFpbCA9IG1heCAlIDM7XG5cbiAgaWYgKHRhaWwgPT09IDApIHtcbiAgICByZXN1bHQgKz0gbWFwWyhiaXRzID4+IDE4KSAmIDB4M0ZdO1xuICAgIHJlc3VsdCArPSBtYXBbKGJpdHMgPj4gMTIpICYgMHgzRl07XG4gICAgcmVzdWx0ICs9IG1hcFsoYml0cyA+PiA2KSAmIDB4M0ZdO1xuICAgIHJlc3VsdCArPSBtYXBbYml0cyAmIDB4M0ZdO1xuICB9IGVsc2UgaWYgKHRhaWwgPT09IDIpIHtcbiAgICByZXN1bHQgKz0gbWFwWyhiaXRzID4+IDEwKSAmIDB4M0ZdO1xuICAgIHJlc3VsdCArPSBtYXBbKGJpdHMgPj4gNCkgJiAweDNGXTtcbiAgICByZXN1bHQgKz0gbWFwWyhiaXRzIDw8IDIpICYgMHgzRl07XG4gICAgcmVzdWx0ICs9IG1hcFs2NF07XG4gIH0gZWxzZSBpZiAodGFpbCA9PT0gMSkge1xuICAgIHJlc3VsdCArPSBtYXBbKGJpdHMgPj4gMikgJiAweDNGXTtcbiAgICByZXN1bHQgKz0gbWFwWyhiaXRzIDw8IDQpICYgMHgzRl07XG4gICAgcmVzdWx0ICs9IG1hcFs2NF07XG4gICAgcmVzdWx0ICs9IG1hcFs2NF07XG4gIH1cblxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5mdW5jdGlvbiBpc0JpbmFyeShvYmplY3QpIHtcbiAgcmV0dXJuIE5vZGVCdWZmZXIgJiYgTm9kZUJ1ZmZlci5pc0J1ZmZlcihvYmplY3QpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IG5ldyBUeXBlKCd0YWc6eWFtbC5vcmcsMjAwMjpiaW5hcnknLCB7XG4gIGtpbmQ6ICdzY2FsYXInLFxuICByZXNvbHZlOiByZXNvbHZlWWFtbEJpbmFyeSxcbiAgY29uc3RydWN0OiBjb25zdHJ1Y3RZYW1sQmluYXJ5LFxuICBwcmVkaWNhdGU6IGlzQmluYXJ5LFxuICByZXByZXNlbnQ6IHJlcHJlc2VudFlhbWxCaW5hcnlcbn0pO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2pzLXlhbWwvbGliL2pzLXlhbWwvdHlwZS9iaW5hcnkuanMiLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCJidWZmZXJcIik7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gZXh0ZXJuYWwgXCJidWZmZXJcIlxuLy8gbW9kdWxlIGlkID0gMTUwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIid1c2Ugc3RyaWN0JztcblxudmFyIFR5cGUgPSByZXF1aXJlKCcuLi90eXBlJyk7XG5cbnZhciBfaGFzT3duUHJvcGVydHkgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xudmFyIF90b1N0cmluZyAgICAgICA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmc7XG5cbmZ1bmN0aW9uIHJlc29sdmVZYW1sT21hcChkYXRhKSB7XG4gIGlmIChkYXRhID09PSBudWxsKSByZXR1cm4gdHJ1ZTtcblxuICB2YXIgb2JqZWN0S2V5cyA9IFtdLCBpbmRleCwgbGVuZ3RoLCBwYWlyLCBwYWlyS2V5LCBwYWlySGFzS2V5LFxuICAgICAgb2JqZWN0ID0gZGF0YTtcblxuICBmb3IgKGluZGV4ID0gMCwgbGVuZ3RoID0gb2JqZWN0Lmxlbmd0aDsgaW5kZXggPCBsZW5ndGg7IGluZGV4ICs9IDEpIHtcbiAgICBwYWlyID0gb2JqZWN0W2luZGV4XTtcbiAgICBwYWlySGFzS2V5ID0gZmFsc2U7XG5cbiAgICBpZiAoX3RvU3RyaW5nLmNhbGwocGFpcikgIT09ICdbb2JqZWN0IE9iamVjdF0nKSByZXR1cm4gZmFsc2U7XG5cbiAgICBmb3IgKHBhaXJLZXkgaW4gcGFpcikge1xuICAgICAgaWYgKF9oYXNPd25Qcm9wZXJ0eS5jYWxsKHBhaXIsIHBhaXJLZXkpKSB7XG4gICAgICAgIGlmICghcGFpckhhc0tleSkgcGFpckhhc0tleSA9IHRydWU7XG4gICAgICAgIGVsc2UgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICghcGFpckhhc0tleSkgcmV0dXJuIGZhbHNlO1xuXG4gICAgaWYgKG9iamVjdEtleXMuaW5kZXhPZihwYWlyS2V5KSA9PT0gLTEpIG9iamVjdEtleXMucHVzaChwYWlyS2V5KTtcbiAgICBlbHNlIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufVxuXG5mdW5jdGlvbiBjb25zdHJ1Y3RZYW1sT21hcChkYXRhKSB7XG4gIHJldHVybiBkYXRhICE9PSBudWxsID8gZGF0YSA6IFtdO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IG5ldyBUeXBlKCd0YWc6eWFtbC5vcmcsMjAwMjpvbWFwJywge1xuICBraW5kOiAnc2VxdWVuY2UnLFxuICByZXNvbHZlOiByZXNvbHZlWWFtbE9tYXAsXG4gIGNvbnN0cnVjdDogY29uc3RydWN0WWFtbE9tYXBcbn0pO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2pzLXlhbWwvbGliL2pzLXlhbWwvdHlwZS9vbWFwLmpzIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgVHlwZSA9IHJlcXVpcmUoJy4uL3R5cGUnKTtcblxudmFyIF90b1N0cmluZyA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmc7XG5cbmZ1bmN0aW9uIHJlc29sdmVZYW1sUGFpcnMoZGF0YSkge1xuICBpZiAoZGF0YSA9PT0gbnVsbCkgcmV0dXJuIHRydWU7XG5cbiAgdmFyIGluZGV4LCBsZW5ndGgsIHBhaXIsIGtleXMsIHJlc3VsdCxcbiAgICAgIG9iamVjdCA9IGRhdGE7XG5cbiAgcmVzdWx0ID0gbmV3IEFycmF5KG9iamVjdC5sZW5ndGgpO1xuXG4gIGZvciAoaW5kZXggPSAwLCBsZW5ndGggPSBvYmplY3QubGVuZ3RoOyBpbmRleCA8IGxlbmd0aDsgaW5kZXggKz0gMSkge1xuICAgIHBhaXIgPSBvYmplY3RbaW5kZXhdO1xuXG4gICAgaWYgKF90b1N0cmluZy5jYWxsKHBhaXIpICE9PSAnW29iamVjdCBPYmplY3RdJykgcmV0dXJuIGZhbHNlO1xuXG4gICAga2V5cyA9IE9iamVjdC5rZXlzKHBhaXIpO1xuXG4gICAgaWYgKGtleXMubGVuZ3RoICE9PSAxKSByZXR1cm4gZmFsc2U7XG5cbiAgICByZXN1bHRbaW5kZXhdID0gWyBrZXlzWzBdLCBwYWlyW2tleXNbMF1dIF07XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gY29uc3RydWN0WWFtbFBhaXJzKGRhdGEpIHtcbiAgaWYgKGRhdGEgPT09IG51bGwpIHJldHVybiBbXTtcblxuICB2YXIgaW5kZXgsIGxlbmd0aCwgcGFpciwga2V5cywgcmVzdWx0LFxuICAgICAgb2JqZWN0ID0gZGF0YTtcblxuICByZXN1bHQgPSBuZXcgQXJyYXkob2JqZWN0Lmxlbmd0aCk7XG5cbiAgZm9yIChpbmRleCA9IDAsIGxlbmd0aCA9IG9iamVjdC5sZW5ndGg7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCArPSAxKSB7XG4gICAgcGFpciA9IG9iamVjdFtpbmRleF07XG5cbiAgICBrZXlzID0gT2JqZWN0LmtleXMocGFpcik7XG5cbiAgICByZXN1bHRbaW5kZXhdID0gWyBrZXlzWzBdLCBwYWlyW2tleXNbMF1dIF07XG4gIH1cblxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IG5ldyBUeXBlKCd0YWc6eWFtbC5vcmcsMjAwMjpwYWlycycsIHtcbiAga2luZDogJ3NlcXVlbmNlJyxcbiAgcmVzb2x2ZTogcmVzb2x2ZVlhbWxQYWlycyxcbiAgY29uc3RydWN0OiBjb25zdHJ1Y3RZYW1sUGFpcnNcbn0pO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2pzLXlhbWwvbGliL2pzLXlhbWwvdHlwZS9wYWlycy5qcyIsIid1c2Ugc3RyaWN0JztcblxudmFyIFR5cGUgPSByZXF1aXJlKCcuLi90eXBlJyk7XG5cbnZhciBfaGFzT3duUHJvcGVydHkgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xuXG5mdW5jdGlvbiByZXNvbHZlWWFtbFNldChkYXRhKSB7XG4gIGlmIChkYXRhID09PSBudWxsKSByZXR1cm4gdHJ1ZTtcblxuICB2YXIga2V5LCBvYmplY3QgPSBkYXRhO1xuXG4gIGZvciAoa2V5IGluIG9iamVjdCkge1xuICAgIGlmIChfaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIGtleSkpIHtcbiAgICAgIGlmIChvYmplY3Rba2V5XSAhPT0gbnVsbCkgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufVxuXG5mdW5jdGlvbiBjb25zdHJ1Y3RZYW1sU2V0KGRhdGEpIHtcbiAgcmV0dXJuIGRhdGEgIT09IG51bGwgPyBkYXRhIDoge307XG59XG5cbm1vZHVsZS5leHBvcnRzID0gbmV3IFR5cGUoJ3RhZzp5YW1sLm9yZywyMDAyOnNldCcsIHtcbiAga2luZDogJ21hcHBpbmcnLFxuICByZXNvbHZlOiByZXNvbHZlWWFtbFNldCxcbiAgY29uc3RydWN0OiBjb25zdHJ1Y3RZYW1sU2V0XG59KTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9qcy15YW1sL2xpYi9qcy15YW1sL3R5cGUvc2V0LmpzIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgVHlwZSA9IHJlcXVpcmUoJy4uLy4uL3R5cGUnKTtcblxuZnVuY3Rpb24gcmVzb2x2ZUphdmFzY3JpcHRVbmRlZmluZWQoKSB7XG4gIHJldHVybiB0cnVlO1xufVxuXG5mdW5jdGlvbiBjb25zdHJ1Y3RKYXZhc2NyaXB0VW5kZWZpbmVkKCkge1xuICAvKmVzbGludC1kaXNhYmxlIG5vLXVuZGVmaW5lZCovXG4gIHJldHVybiB1bmRlZmluZWQ7XG59XG5cbmZ1bmN0aW9uIHJlcHJlc2VudEphdmFzY3JpcHRVbmRlZmluZWQoKSB7XG4gIHJldHVybiAnJztcbn1cblxuZnVuY3Rpb24gaXNVbmRlZmluZWQob2JqZWN0KSB7XG4gIHJldHVybiB0eXBlb2Ygb2JqZWN0ID09PSAndW5kZWZpbmVkJztcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBuZXcgVHlwZSgndGFnOnlhbWwub3JnLDIwMDI6anMvdW5kZWZpbmVkJywge1xuICBraW5kOiAnc2NhbGFyJyxcbiAgcmVzb2x2ZTogcmVzb2x2ZUphdmFzY3JpcHRVbmRlZmluZWQsXG4gIGNvbnN0cnVjdDogY29uc3RydWN0SmF2YXNjcmlwdFVuZGVmaW5lZCxcbiAgcHJlZGljYXRlOiBpc1VuZGVmaW5lZCxcbiAgcmVwcmVzZW50OiByZXByZXNlbnRKYXZhc2NyaXB0VW5kZWZpbmVkXG59KTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9qcy15YW1sL2xpYi9qcy15YW1sL3R5cGUvanMvdW5kZWZpbmVkLmpzIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgVHlwZSA9IHJlcXVpcmUoJy4uLy4uL3R5cGUnKTtcblxuZnVuY3Rpb24gcmVzb2x2ZUphdmFzY3JpcHRSZWdFeHAoZGF0YSkge1xuICBpZiAoZGF0YSA9PT0gbnVsbCkgcmV0dXJuIGZhbHNlO1xuICBpZiAoZGF0YS5sZW5ndGggPT09IDApIHJldHVybiBmYWxzZTtcblxuICB2YXIgcmVnZXhwID0gZGF0YSxcbiAgICAgIHRhaWwgICA9IC9cXC8oW2dpbV0qKSQvLmV4ZWMoZGF0YSksXG4gICAgICBtb2RpZmllcnMgPSAnJztcblxuICAvLyBpZiByZWdleHAgc3RhcnRzIHdpdGggJy8nIGl0IGNhbiBoYXZlIG1vZGlmaWVycyBhbmQgbXVzdCBiZSBwcm9wZXJseSBjbG9zZWRcbiAgLy8gYC9mb28vZ2ltYCAtIG1vZGlmaWVycyB0YWlsIGNhbiBiZSBtYXhpbXVtIDMgY2hhcnNcbiAgaWYgKHJlZ2V4cFswXSA9PT0gJy8nKSB7XG4gICAgaWYgKHRhaWwpIG1vZGlmaWVycyA9IHRhaWxbMV07XG5cbiAgICBpZiAobW9kaWZpZXJzLmxlbmd0aCA+IDMpIHJldHVybiBmYWxzZTtcbiAgICAvLyBpZiBleHByZXNzaW9uIHN0YXJ0cyB3aXRoIC8sIGlzIHNob3VsZCBiZSBwcm9wZXJseSB0ZXJtaW5hdGVkXG4gICAgaWYgKHJlZ2V4cFtyZWdleHAubGVuZ3RoIC0gbW9kaWZpZXJzLmxlbmd0aCAtIDFdICE9PSAnLycpIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufVxuXG5mdW5jdGlvbiBjb25zdHJ1Y3RKYXZhc2NyaXB0UmVnRXhwKGRhdGEpIHtcbiAgdmFyIHJlZ2V4cCA9IGRhdGEsXG4gICAgICB0YWlsICAgPSAvXFwvKFtnaW1dKikkLy5leGVjKGRhdGEpLFxuICAgICAgbW9kaWZpZXJzID0gJyc7XG5cbiAgLy8gYC9mb28vZ2ltYCAtIHRhaWwgY2FuIGJlIG1heGltdW0gNCBjaGFyc1xuICBpZiAocmVnZXhwWzBdID09PSAnLycpIHtcbiAgICBpZiAodGFpbCkgbW9kaWZpZXJzID0gdGFpbFsxXTtcbiAgICByZWdleHAgPSByZWdleHAuc2xpY2UoMSwgcmVnZXhwLmxlbmd0aCAtIG1vZGlmaWVycy5sZW5ndGggLSAxKTtcbiAgfVxuXG4gIHJldHVybiBuZXcgUmVnRXhwKHJlZ2V4cCwgbW9kaWZpZXJzKTtcbn1cblxuZnVuY3Rpb24gcmVwcmVzZW50SmF2YXNjcmlwdFJlZ0V4cChvYmplY3QgLyosIHN0eWxlKi8pIHtcbiAgdmFyIHJlc3VsdCA9ICcvJyArIG9iamVjdC5zb3VyY2UgKyAnLyc7XG5cbiAgaWYgKG9iamVjdC5nbG9iYWwpIHJlc3VsdCArPSAnZyc7XG4gIGlmIChvYmplY3QubXVsdGlsaW5lKSByZXN1bHQgKz0gJ20nO1xuICBpZiAob2JqZWN0Lmlnbm9yZUNhc2UpIHJlc3VsdCArPSAnaSc7XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuZnVuY3Rpb24gaXNSZWdFeHAob2JqZWN0KSB7XG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwob2JqZWN0KSA9PT0gJ1tvYmplY3QgUmVnRXhwXSc7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gbmV3IFR5cGUoJ3RhZzp5YW1sLm9yZywyMDAyOmpzL3JlZ2V4cCcsIHtcbiAga2luZDogJ3NjYWxhcicsXG4gIHJlc29sdmU6IHJlc29sdmVKYXZhc2NyaXB0UmVnRXhwLFxuICBjb25zdHJ1Y3Q6IGNvbnN0cnVjdEphdmFzY3JpcHRSZWdFeHAsXG4gIHByZWRpY2F0ZTogaXNSZWdFeHAsXG4gIHJlcHJlc2VudDogcmVwcmVzZW50SmF2YXNjcmlwdFJlZ0V4cFxufSk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvanMteWFtbC9saWIvanMteWFtbC90eXBlL2pzL3JlZ2V4cC5qcyIsIid1c2Ugc3RyaWN0JztcblxudmFyIGVzcHJpbWE7XG5cbi8vIEJyb3dzZXJpZmllZCB2ZXJzaW9uIGRvZXMgbm90IGhhdmUgZXNwcmltYVxuLy9cbi8vIDEuIEZvciBub2RlLmpzIGp1c3QgcmVxdWlyZSBtb2R1bGUgYXMgZGVwc1xuLy8gMi4gRm9yIGJyb3dzZXIgdHJ5IHRvIHJlcXVpcmUgbXVkdWxlIHZpYSBleHRlcm5hbCBBTUQgc3lzdGVtLlxuLy8gICAgSWYgbm90IGZvdW5kIC0gdHJ5IHRvIGZhbGxiYWNrIHRvIHdpbmRvdy5lc3ByaW1hLiBJZiBub3Rcbi8vICAgIGZvdW5kIHRvbyAtIHRoZW4gZmFpbCB0byBwYXJzZS5cbi8vXG50cnkge1xuICAvLyB3b3JrYXJvdW5kIHRvIGV4Y2x1ZGUgcGFja2FnZSBmcm9tIGJyb3dzZXJpZnkgbGlzdC5cbiAgdmFyIF9yZXF1aXJlID0gcmVxdWlyZTtcbiAgZXNwcmltYSA9IF9yZXF1aXJlKCdlc3ByaW1hJyk7XG59IGNhdGNoIChfKSB7XG4gIC8qZ2xvYmFsIHdpbmRvdyAqL1xuICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcpIGVzcHJpbWEgPSB3aW5kb3cuZXNwcmltYTtcbn1cblxudmFyIFR5cGUgPSByZXF1aXJlKCcuLi8uLi90eXBlJyk7XG5cbmZ1bmN0aW9uIHJlc29sdmVKYXZhc2NyaXB0RnVuY3Rpb24oZGF0YSkge1xuICBpZiAoZGF0YSA9PT0gbnVsbCkgcmV0dXJuIGZhbHNlO1xuXG4gIHRyeSB7XG4gICAgdmFyIHNvdXJjZSA9ICcoJyArIGRhdGEgKyAnKScsXG4gICAgICAgIGFzdCAgICA9IGVzcHJpbWEucGFyc2Uoc291cmNlLCB7IHJhbmdlOiB0cnVlIH0pO1xuXG4gICAgaWYgKGFzdC50eXBlICAgICAgICAgICAgICAgICAgICAhPT0gJ1Byb2dyYW0nICAgICAgICAgICAgIHx8XG4gICAgICAgIGFzdC5ib2R5Lmxlbmd0aCAgICAgICAgICAgICAhPT0gMSAgICAgICAgICAgICAgICAgICAgIHx8XG4gICAgICAgIGFzdC5ib2R5WzBdLnR5cGUgICAgICAgICAgICAhPT0gJ0V4cHJlc3Npb25TdGF0ZW1lbnQnIHx8XG4gICAgICAgIGFzdC5ib2R5WzBdLmV4cHJlc3Npb24udHlwZSAhPT0gJ0Z1bmN0aW9uRXhwcmVzc2lvbicpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59XG5cbmZ1bmN0aW9uIGNvbnN0cnVjdEphdmFzY3JpcHRGdW5jdGlvbihkYXRhKSB7XG4gIC8qanNsaW50IGV2aWw6dHJ1ZSovXG5cbiAgdmFyIHNvdXJjZSA9ICcoJyArIGRhdGEgKyAnKScsXG4gICAgICBhc3QgICAgPSBlc3ByaW1hLnBhcnNlKHNvdXJjZSwgeyByYW5nZTogdHJ1ZSB9KSxcbiAgICAgIHBhcmFtcyA9IFtdLFxuICAgICAgYm9keTtcblxuICBpZiAoYXN0LnR5cGUgICAgICAgICAgICAgICAgICAgICE9PSAnUHJvZ3JhbScgICAgICAgICAgICAgfHxcbiAgICAgIGFzdC5ib2R5Lmxlbmd0aCAgICAgICAgICAgICAhPT0gMSAgICAgICAgICAgICAgICAgICAgIHx8XG4gICAgICBhc3QuYm9keVswXS50eXBlICAgICAgICAgICAgIT09ICdFeHByZXNzaW9uU3RhdGVtZW50JyB8fFxuICAgICAgYXN0LmJvZHlbMF0uZXhwcmVzc2lvbi50eXBlICE9PSAnRnVuY3Rpb25FeHByZXNzaW9uJykge1xuICAgIHRocm93IG5ldyBFcnJvcignRmFpbGVkIHRvIHJlc29sdmUgZnVuY3Rpb24nKTtcbiAgfVxuXG4gIGFzdC5ib2R5WzBdLmV4cHJlc3Npb24ucGFyYW1zLmZvckVhY2goZnVuY3Rpb24gKHBhcmFtKSB7XG4gICAgcGFyYW1zLnB1c2gocGFyYW0ubmFtZSk7XG4gIH0pO1xuXG4gIGJvZHkgPSBhc3QuYm9keVswXS5leHByZXNzaW9uLmJvZHkucmFuZ2U7XG5cbiAgLy8gRXNwcmltYSdzIHJhbmdlcyBpbmNsdWRlIHRoZSBmaXJzdCAneycgYW5kIHRoZSBsYXN0ICd9JyBjaGFyYWN0ZXJzIG9uXG4gIC8vIGZ1bmN0aW9uIGV4cHJlc3Npb25zLiBTbyBjdXQgdGhlbSBvdXQuXG4gIC8qZXNsaW50LWRpc2FibGUgbm8tbmV3LWZ1bmMqL1xuICByZXR1cm4gbmV3IEZ1bmN0aW9uKHBhcmFtcywgc291cmNlLnNsaWNlKGJvZHlbMF0gKyAxLCBib2R5WzFdIC0gMSkpO1xufVxuXG5mdW5jdGlvbiByZXByZXNlbnRKYXZhc2NyaXB0RnVuY3Rpb24ob2JqZWN0IC8qLCBzdHlsZSovKSB7XG4gIHJldHVybiBvYmplY3QudG9TdHJpbmcoKTtcbn1cblxuZnVuY3Rpb24gaXNGdW5jdGlvbihvYmplY3QpIHtcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvYmplY3QpID09PSAnW29iamVjdCBGdW5jdGlvbl0nO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IG5ldyBUeXBlKCd0YWc6eWFtbC5vcmcsMjAwMjpqcy9mdW5jdGlvbicsIHtcbiAga2luZDogJ3NjYWxhcicsXG4gIHJlc29sdmU6IHJlc29sdmVKYXZhc2NyaXB0RnVuY3Rpb24sXG4gIGNvbnN0cnVjdDogY29uc3RydWN0SmF2YXNjcmlwdEZ1bmN0aW9uLFxuICBwcmVkaWNhdGU6IGlzRnVuY3Rpb24sXG4gIHJlcHJlc2VudDogcmVwcmVzZW50SmF2YXNjcmlwdEZ1bmN0aW9uXG59KTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9qcy15YW1sL2xpYi9qcy15YW1sL3R5cGUvanMvZnVuY3Rpb24uanMiLCIoZnVuY3Rpb24gd2VicGFja1VuaXZlcnNhbE1vZHVsZURlZmluaXRpb24ocm9vdCwgZmFjdG9yeSkge1xuLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cblx0aWYodHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgPT09ICdvYmplY3QnKVxuXHRcdG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeSgpO1xuXHRlbHNlIGlmKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZClcblx0XHRkZWZpbmUoW10sIGZhY3RvcnkpO1xuLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cblx0ZWxzZSBpZih0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcpXG5cdFx0ZXhwb3J0c1tcImVzcHJpbWFcIl0gPSBmYWN0b3J5KCk7XG5cdGVsc2Vcblx0XHRyb290W1wiZXNwcmltYVwiXSA9IGZhY3RvcnkoKTtcbn0pKHRoaXMsIGZ1bmN0aW9uKCkge1xucmV0dXJuIC8qKioqKiovIChmdW5jdGlvbihtb2R1bGVzKSB7IC8vIHdlYnBhY2tCb290c3RyYXBcbi8qKioqKiovIFx0Ly8gVGhlIG1vZHVsZSBjYWNoZVxuLyoqKioqKi8gXHR2YXIgaW5zdGFsbGVkTW9kdWxlcyA9IHt9O1xuXG4vKioqKioqLyBcdC8vIFRoZSByZXF1aXJlIGZ1bmN0aW9uXG4vKioqKioqLyBcdGZ1bmN0aW9uIF9fd2VicGFja19yZXF1aXJlX18obW9kdWxlSWQpIHtcblxuLyoqKioqKi8gXHRcdC8vIENoZWNrIGlmIG1vZHVsZSBpcyBpbiBjYWNoZVxuLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4vKioqKioqLyBcdFx0aWYoaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0pXG4vKioqKioqLyBcdFx0XHRyZXR1cm4gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0uZXhwb3J0cztcblxuLyoqKioqKi8gXHRcdC8vIENyZWF0ZSBhIG5ldyBtb2R1bGUgKGFuZCBwdXQgaXQgaW50byB0aGUgY2FjaGUpXG4vKioqKioqLyBcdFx0dmFyIG1vZHVsZSA9IGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdID0ge1xuLyoqKioqKi8gXHRcdFx0ZXhwb3J0czoge30sXG4vKioqKioqLyBcdFx0XHRpZDogbW9kdWxlSWQsXG4vKioqKioqLyBcdFx0XHRsb2FkZWQ6IGZhbHNlXG4vKioqKioqLyBcdFx0fTtcblxuLyoqKioqKi8gXHRcdC8vIEV4ZWN1dGUgdGhlIG1vZHVsZSBmdW5jdGlvblxuLyoqKioqKi8gXHRcdG1vZHVsZXNbbW9kdWxlSWRdLmNhbGwobW9kdWxlLmV4cG9ydHMsIG1vZHVsZSwgbW9kdWxlLmV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pO1xuXG4vKioqKioqLyBcdFx0Ly8gRmxhZyB0aGUgbW9kdWxlIGFzIGxvYWRlZFxuLyoqKioqKi8gXHRcdG1vZHVsZS5sb2FkZWQgPSB0cnVlO1xuXG4vKioqKioqLyBcdFx0Ly8gUmV0dXJuIHRoZSBleHBvcnRzIG9mIHRoZSBtb2R1bGVcbi8qKioqKiovIFx0XHRyZXR1cm4gbW9kdWxlLmV4cG9ydHM7XG4vKioqKioqLyBcdH1cblxuXG4vKioqKioqLyBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlcyBvYmplY3QgKF9fd2VicGFja19tb2R1bGVzX18pXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18ubSA9IG1vZHVsZXM7XG5cbi8qKioqKiovIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGUgY2FjaGVcbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5jID0gaW5zdGFsbGVkTW9kdWxlcztcblxuLyoqKioqKi8gXHQvLyBfX3dlYnBhY2tfcHVibGljX3BhdGhfX1xuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLnAgPSBcIlwiO1xuXG4vKioqKioqLyBcdC8vIExvYWQgZW50cnkgbW9kdWxlIGFuZCByZXR1cm4gZXhwb3J0c1xuLyoqKioqKi8gXHRyZXR1cm4gX193ZWJwYWNrX3JlcXVpcmVfXygwKTtcbi8qKioqKiovIH0pXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKioqKi8gKFtcbi8qIDAgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cdFwidXNlIHN0cmljdFwiO1xyXG5cdC8qXHJcblx0ICBDb3B5cmlnaHQgSlMgRm91bmRhdGlvbiBhbmQgb3RoZXIgY29udHJpYnV0b3JzLCBodHRwczovL2pzLmZvdW5kYXRpb24vXHJcblxyXG5cdCAgUmVkaXN0cmlidXRpb24gYW5kIHVzZSBpbiBzb3VyY2UgYW5kIGJpbmFyeSBmb3Jtcywgd2l0aCBvciB3aXRob3V0XHJcblx0ICBtb2RpZmljYXRpb24sIGFyZSBwZXJtaXR0ZWQgcHJvdmlkZWQgdGhhdCB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnMgYXJlIG1ldDpcclxuXHJcblx0ICAgICogUmVkaXN0cmlidXRpb25zIG9mIHNvdXJjZSBjb2RlIG11c3QgcmV0YWluIHRoZSBhYm92ZSBjb3B5cmlnaHRcclxuXHQgICAgICBub3RpY2UsIHRoaXMgbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nIGRpc2NsYWltZXIuXHJcblx0ICAgICogUmVkaXN0cmlidXRpb25zIGluIGJpbmFyeSBmb3JtIG11c3QgcmVwcm9kdWNlIHRoZSBhYm92ZSBjb3B5cmlnaHRcclxuXHQgICAgICBub3RpY2UsIHRoaXMgbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nIGRpc2NsYWltZXIgaW4gdGhlXHJcblx0ICAgICAgZG9jdW1lbnRhdGlvbiBhbmQvb3Igb3RoZXIgbWF0ZXJpYWxzIHByb3ZpZGVkIHdpdGggdGhlIGRpc3RyaWJ1dGlvbi5cclxuXHJcblx0ICBUSElTIFNPRlRXQVJFIElTIFBST1ZJREVEIEJZIFRIRSBDT1BZUklHSFQgSE9MREVSUyBBTkQgQ09OVFJJQlVUT1JTIFwiQVMgSVNcIlxyXG5cdCAgQU5EIEFOWSBFWFBSRVNTIE9SIElNUExJRUQgV0FSUkFOVElFUywgSU5DTFVESU5HLCBCVVQgTk9UIExJTUlURUQgVE8sIFRIRVxyXG5cdCAgSU1QTElFRCBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSBBTkQgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0VcclxuXHQgIEFSRSBESVNDTEFJTUVELiBJTiBOTyBFVkVOVCBTSEFMTCA8Q09QWVJJR0hUIEhPTERFUj4gQkUgTElBQkxFIEZPUiBBTllcclxuXHQgIERJUkVDVCwgSU5ESVJFQ1QsIElOQ0lERU5UQUwsIFNQRUNJQUwsIEVYRU1QTEFSWSwgT1IgQ09OU0VRVUVOVElBTCBEQU1BR0VTXHJcblx0ICAoSU5DTFVESU5HLCBCVVQgTk9UIExJTUlURUQgVE8sIFBST0NVUkVNRU5UIE9GIFNVQlNUSVRVVEUgR09PRFMgT1IgU0VSVklDRVM7XHJcblx0ICBMT1NTIE9GIFVTRSwgREFUQSwgT1IgUFJPRklUUzsgT1IgQlVTSU5FU1MgSU5URVJSVVBUSU9OKSBIT1dFVkVSIENBVVNFRCBBTkRcclxuXHQgIE9OIEFOWSBUSEVPUlkgT0YgTElBQklMSVRZLCBXSEVUSEVSIElOIENPTlRSQUNULCBTVFJJQ1QgTElBQklMSVRZLCBPUiBUT1JUXHJcblx0ICAoSU5DTFVESU5HIE5FR0xJR0VOQ0UgT1IgT1RIRVJXSVNFKSBBUklTSU5HIElOIEFOWSBXQVkgT1VUIE9GIFRIRSBVU0UgT0ZcclxuXHQgIFRISVMgU09GVFdBUkUsIEVWRU4gSUYgQURWSVNFRCBPRiBUSEUgUE9TU0lCSUxJVFkgT0YgU1VDSCBEQU1BR0UuXHJcblx0Ki9cclxuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcblx0dmFyIGNvbW1lbnRfaGFuZGxlcl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygxKTtcclxuXHR2YXIganN4X3BhcnNlcl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygzKTtcclxuXHR2YXIgcGFyc2VyXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDgpO1xyXG5cdHZhciB0b2tlbml6ZXJfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMTUpO1xyXG5cdGZ1bmN0aW9uIHBhcnNlKGNvZGUsIG9wdGlvbnMsIGRlbGVnYXRlKSB7XHJcblx0ICAgIHZhciBjb21tZW50SGFuZGxlciA9IG51bGw7XHJcblx0ICAgIHZhciBwcm94eURlbGVnYXRlID0gZnVuY3Rpb24gKG5vZGUsIG1ldGFkYXRhKSB7XHJcblx0ICAgICAgICBpZiAoZGVsZWdhdGUpIHtcclxuXHQgICAgICAgICAgICBkZWxlZ2F0ZShub2RlLCBtZXRhZGF0YSk7XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICBpZiAoY29tbWVudEhhbmRsZXIpIHtcclxuXHQgICAgICAgICAgICBjb21tZW50SGFuZGxlci52aXNpdChub2RlLCBtZXRhZGF0YSk7XHJcblx0ICAgICAgICB9XHJcblx0ICAgIH07XHJcblx0ICAgIHZhciBwYXJzZXJEZWxlZ2F0ZSA9ICh0eXBlb2YgZGVsZWdhdGUgPT09ICdmdW5jdGlvbicpID8gcHJveHlEZWxlZ2F0ZSA6IG51bGw7XHJcblx0ICAgIHZhciBjb2xsZWN0Q29tbWVudCA9IGZhbHNlO1xyXG5cdCAgICBpZiAob3B0aW9ucykge1xyXG5cdCAgICAgICAgY29sbGVjdENvbW1lbnQgPSAodHlwZW9mIG9wdGlvbnMuY29tbWVudCA9PT0gJ2Jvb2xlYW4nICYmIG9wdGlvbnMuY29tbWVudCk7XHJcblx0ICAgICAgICB2YXIgYXR0YWNoQ29tbWVudCA9ICh0eXBlb2Ygb3B0aW9ucy5hdHRhY2hDb21tZW50ID09PSAnYm9vbGVhbicgJiYgb3B0aW9ucy5hdHRhY2hDb21tZW50KTtcclxuXHQgICAgICAgIGlmIChjb2xsZWN0Q29tbWVudCB8fCBhdHRhY2hDb21tZW50KSB7XHJcblx0ICAgICAgICAgICAgY29tbWVudEhhbmRsZXIgPSBuZXcgY29tbWVudF9oYW5kbGVyXzEuQ29tbWVudEhhbmRsZXIoKTtcclxuXHQgICAgICAgICAgICBjb21tZW50SGFuZGxlci5hdHRhY2ggPSBhdHRhY2hDb21tZW50O1xyXG5cdCAgICAgICAgICAgIG9wdGlvbnMuY29tbWVudCA9IHRydWU7XHJcblx0ICAgICAgICAgICAgcGFyc2VyRGVsZWdhdGUgPSBwcm94eURlbGVnYXRlO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICB9XHJcblx0ICAgIHZhciBpc01vZHVsZSA9IGZhbHNlO1xyXG5cdCAgICBpZiAob3B0aW9ucyAmJiB0eXBlb2Ygb3B0aW9ucy5zb3VyY2VUeXBlID09PSAnc3RyaW5nJykge1xyXG5cdCAgICAgICAgaXNNb2R1bGUgPSAob3B0aW9ucy5zb3VyY2VUeXBlID09PSAnbW9kdWxlJyk7XHJcblx0ICAgIH1cclxuXHQgICAgdmFyIHBhcnNlcjtcclxuXHQgICAgaWYgKG9wdGlvbnMgJiYgdHlwZW9mIG9wdGlvbnMuanN4ID09PSAnYm9vbGVhbicgJiYgb3B0aW9ucy5qc3gpIHtcclxuXHQgICAgICAgIHBhcnNlciA9IG5ldyBqc3hfcGFyc2VyXzEuSlNYUGFyc2VyKGNvZGUsIG9wdGlvbnMsIHBhcnNlckRlbGVnYXRlKTtcclxuXHQgICAgfVxyXG5cdCAgICBlbHNlIHtcclxuXHQgICAgICAgIHBhcnNlciA9IG5ldyBwYXJzZXJfMS5QYXJzZXIoY29kZSwgb3B0aW9ucywgcGFyc2VyRGVsZWdhdGUpO1xyXG5cdCAgICB9XHJcblx0ICAgIHZhciBwcm9ncmFtID0gaXNNb2R1bGUgPyBwYXJzZXIucGFyc2VNb2R1bGUoKSA6IHBhcnNlci5wYXJzZVNjcmlwdCgpO1xyXG5cdCAgICB2YXIgYXN0ID0gcHJvZ3JhbTtcclxuXHQgICAgaWYgKGNvbGxlY3RDb21tZW50ICYmIGNvbW1lbnRIYW5kbGVyKSB7XHJcblx0ICAgICAgICBhc3QuY29tbWVudHMgPSBjb21tZW50SGFuZGxlci5jb21tZW50cztcclxuXHQgICAgfVxyXG5cdCAgICBpZiAocGFyc2VyLmNvbmZpZy50b2tlbnMpIHtcclxuXHQgICAgICAgIGFzdC50b2tlbnMgPSBwYXJzZXIudG9rZW5zO1xyXG5cdCAgICB9XHJcblx0ICAgIGlmIChwYXJzZXIuY29uZmlnLnRvbGVyYW50KSB7XHJcblx0ICAgICAgICBhc3QuZXJyb3JzID0gcGFyc2VyLmVycm9ySGFuZGxlci5lcnJvcnM7XHJcblx0ICAgIH1cclxuXHQgICAgcmV0dXJuIGFzdDtcclxuXHR9XHJcblx0ZXhwb3J0cy5wYXJzZSA9IHBhcnNlO1xyXG5cdGZ1bmN0aW9uIHBhcnNlTW9kdWxlKGNvZGUsIG9wdGlvbnMsIGRlbGVnYXRlKSB7XHJcblx0ICAgIHZhciBwYXJzaW5nT3B0aW9ucyA9IG9wdGlvbnMgfHwge307XHJcblx0ICAgIHBhcnNpbmdPcHRpb25zLnNvdXJjZVR5cGUgPSAnbW9kdWxlJztcclxuXHQgICAgcmV0dXJuIHBhcnNlKGNvZGUsIHBhcnNpbmdPcHRpb25zLCBkZWxlZ2F0ZSk7XHJcblx0fVxyXG5cdGV4cG9ydHMucGFyc2VNb2R1bGUgPSBwYXJzZU1vZHVsZTtcclxuXHRmdW5jdGlvbiBwYXJzZVNjcmlwdChjb2RlLCBvcHRpb25zLCBkZWxlZ2F0ZSkge1xyXG5cdCAgICB2YXIgcGFyc2luZ09wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xyXG5cdCAgICBwYXJzaW5nT3B0aW9ucy5zb3VyY2VUeXBlID0gJ3NjcmlwdCc7XHJcblx0ICAgIHJldHVybiBwYXJzZShjb2RlLCBwYXJzaW5nT3B0aW9ucywgZGVsZWdhdGUpO1xyXG5cdH1cclxuXHRleHBvcnRzLnBhcnNlU2NyaXB0ID0gcGFyc2VTY3JpcHQ7XHJcblx0ZnVuY3Rpb24gdG9rZW5pemUoY29kZSwgb3B0aW9ucywgZGVsZWdhdGUpIHtcclxuXHQgICAgdmFyIHRva2VuaXplciA9IG5ldyB0b2tlbml6ZXJfMS5Ub2tlbml6ZXIoY29kZSwgb3B0aW9ucyk7XHJcblx0ICAgIHZhciB0b2tlbnM7XHJcblx0ICAgIHRva2VucyA9IFtdO1xyXG5cdCAgICB0cnkge1xyXG5cdCAgICAgICAgd2hpbGUgKHRydWUpIHtcclxuXHQgICAgICAgICAgICB2YXIgdG9rZW4gPSB0b2tlbml6ZXIuZ2V0TmV4dFRva2VuKCk7XHJcblx0ICAgICAgICAgICAgaWYgKCF0b2tlbikge1xyXG5cdCAgICAgICAgICAgICAgICBicmVhaztcclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgaWYgKGRlbGVnYXRlKSB7XHJcblx0ICAgICAgICAgICAgICAgIHRva2VuID0gZGVsZWdhdGUodG9rZW4pO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICB0b2tlbnMucHVzaCh0b2tlbik7XHJcblx0ICAgICAgICB9XHJcblx0ICAgIH1cclxuXHQgICAgY2F0Y2ggKGUpIHtcclxuXHQgICAgICAgIHRva2VuaXplci5lcnJvckhhbmRsZXIudG9sZXJhdGUoZSk7XHJcblx0ICAgIH1cclxuXHQgICAgaWYgKHRva2VuaXplci5lcnJvckhhbmRsZXIudG9sZXJhbnQpIHtcclxuXHQgICAgICAgIHRva2Vucy5lcnJvcnMgPSB0b2tlbml6ZXIuZXJyb3JzKCk7XHJcblx0ICAgIH1cclxuXHQgICAgcmV0dXJuIHRva2VucztcclxuXHR9XHJcblx0ZXhwb3J0cy50b2tlbml6ZSA9IHRva2VuaXplO1xyXG5cdHZhciBzeW50YXhfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMik7XHJcblx0ZXhwb3J0cy5TeW50YXggPSBzeW50YXhfMS5TeW50YXg7XHJcblx0Ly8gU3luYyB3aXRoICouanNvbiBtYW5pZmVzdHMuXHJcblx0ZXhwb3J0cy52ZXJzaW9uID0gJzQuMC4wJztcclxuXG5cbi8qKiovIH0sXG4vKiAxICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXHRcInVzZSBzdHJpY3RcIjtcclxuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcblx0dmFyIHN5bnRheF8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygyKTtcclxuXHR2YXIgQ29tbWVudEhhbmRsZXIgPSAoZnVuY3Rpb24gKCkge1xyXG5cdCAgICBmdW5jdGlvbiBDb21tZW50SGFuZGxlcigpIHtcclxuXHQgICAgICAgIHRoaXMuYXR0YWNoID0gZmFsc2U7XHJcblx0ICAgICAgICB0aGlzLmNvbW1lbnRzID0gW107XHJcblx0ICAgICAgICB0aGlzLnN0YWNrID0gW107XHJcblx0ICAgICAgICB0aGlzLmxlYWRpbmcgPSBbXTtcclxuXHQgICAgICAgIHRoaXMudHJhaWxpbmcgPSBbXTtcclxuXHQgICAgfVxyXG5cdCAgICBDb21tZW50SGFuZGxlci5wcm90b3R5cGUuaW5zZXJ0SW5uZXJDb21tZW50cyA9IGZ1bmN0aW9uIChub2RlLCBtZXRhZGF0YSkge1xyXG5cdCAgICAgICAgLy8gIGlubm5lckNvbW1lbnRzIGZvciBwcm9wZXJ0aWVzIGVtcHR5IGJsb2NrXHJcblx0ICAgICAgICAvLyAgYGZ1bmN0aW9uIGEoKSB7LyoqIGNvbW1lbnRzICoqXFwvfWBcclxuXHQgICAgICAgIGlmIChub2RlLnR5cGUgPT09IHN5bnRheF8xLlN5bnRheC5CbG9ja1N0YXRlbWVudCAmJiBub2RlLmJvZHkubGVuZ3RoID09PSAwKSB7XHJcblx0ICAgICAgICAgICAgdmFyIGlubmVyQ29tbWVudHMgPSBbXTtcclxuXHQgICAgICAgICAgICBmb3IgKHZhciBpID0gdGhpcy5sZWFkaW5nLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XHJcblx0ICAgICAgICAgICAgICAgIHZhciBlbnRyeSA9IHRoaXMubGVhZGluZ1tpXTtcclxuXHQgICAgICAgICAgICAgICAgaWYgKG1ldGFkYXRhLmVuZC5vZmZzZXQgPj0gZW50cnkuc3RhcnQpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgIGlubmVyQ29tbWVudHMudW5zaGlmdChlbnRyeS5jb21tZW50KTtcclxuXHQgICAgICAgICAgICAgICAgICAgIHRoaXMubGVhZGluZy5zcGxpY2UoaSwgMSk7XHJcblx0ICAgICAgICAgICAgICAgICAgICB0aGlzLnRyYWlsaW5nLnNwbGljZShpLCAxKTtcclxuXHQgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICBpZiAoaW5uZXJDb21tZW50cy5sZW5ndGgpIHtcclxuXHQgICAgICAgICAgICAgICAgbm9kZS5pbm5lckNvbW1lbnRzID0gaW5uZXJDb21tZW50cztcclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICB9XHJcblx0ICAgIH07XHJcblx0ICAgIENvbW1lbnRIYW5kbGVyLnByb3RvdHlwZS5maW5kVHJhaWxpbmdDb21tZW50cyA9IGZ1bmN0aW9uIChtZXRhZGF0YSkge1xyXG5cdCAgICAgICAgdmFyIHRyYWlsaW5nQ29tbWVudHMgPSBbXTtcclxuXHQgICAgICAgIGlmICh0aGlzLnRyYWlsaW5nLmxlbmd0aCA+IDApIHtcclxuXHQgICAgICAgICAgICBmb3IgKHZhciBpID0gdGhpcy50cmFpbGluZy5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xyXG5cdCAgICAgICAgICAgICAgICB2YXIgZW50cnlfMSA9IHRoaXMudHJhaWxpbmdbaV07XHJcblx0ICAgICAgICAgICAgICAgIGlmIChlbnRyeV8xLnN0YXJ0ID49IG1ldGFkYXRhLmVuZC5vZmZzZXQpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgIHRyYWlsaW5nQ29tbWVudHMudW5zaGlmdChlbnRyeV8xLmNvbW1lbnQpO1xyXG5cdCAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgIHRoaXMudHJhaWxpbmcubGVuZ3RoID0gMDtcclxuXHQgICAgICAgICAgICByZXR1cm4gdHJhaWxpbmdDb21tZW50cztcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIHZhciBlbnRyeSA9IHRoaXMuc3RhY2tbdGhpcy5zdGFjay5sZW5ndGggLSAxXTtcclxuXHQgICAgICAgIGlmIChlbnRyeSAmJiBlbnRyeS5ub2RlLnRyYWlsaW5nQ29tbWVudHMpIHtcclxuXHQgICAgICAgICAgICB2YXIgZmlyc3RDb21tZW50ID0gZW50cnkubm9kZS50cmFpbGluZ0NvbW1lbnRzWzBdO1xyXG5cdCAgICAgICAgICAgIGlmIChmaXJzdENvbW1lbnQgJiYgZmlyc3RDb21tZW50LnJhbmdlWzBdID49IG1ldGFkYXRhLmVuZC5vZmZzZXQpIHtcclxuXHQgICAgICAgICAgICAgICAgdHJhaWxpbmdDb21tZW50cyA9IGVudHJ5Lm5vZGUudHJhaWxpbmdDb21tZW50cztcclxuXHQgICAgICAgICAgICAgICAgZGVsZXRlIGVudHJ5Lm5vZGUudHJhaWxpbmdDb21tZW50cztcclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICByZXR1cm4gdHJhaWxpbmdDb21tZW50cztcclxuXHQgICAgfTtcclxuXHQgICAgQ29tbWVudEhhbmRsZXIucHJvdG90eXBlLmZpbmRMZWFkaW5nQ29tbWVudHMgPSBmdW5jdGlvbiAobWV0YWRhdGEpIHtcclxuXHQgICAgICAgIHZhciBsZWFkaW5nQ29tbWVudHMgPSBbXTtcclxuXHQgICAgICAgIHZhciB0YXJnZXQ7XHJcblx0ICAgICAgICB3aGlsZSAodGhpcy5zdGFjay5sZW5ndGggPiAwKSB7XHJcblx0ICAgICAgICAgICAgdmFyIGVudHJ5ID0gdGhpcy5zdGFja1t0aGlzLnN0YWNrLmxlbmd0aCAtIDFdO1xyXG5cdCAgICAgICAgICAgIGlmIChlbnRyeSAmJiBlbnRyeS5zdGFydCA+PSBtZXRhZGF0YS5zdGFydC5vZmZzZXQpIHtcclxuXHQgICAgICAgICAgICAgICAgdGFyZ2V0ID0gZW50cnkubm9kZTtcclxuXHQgICAgICAgICAgICAgICAgdGhpcy5zdGFjay5wb3AoKTtcclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgZWxzZSB7XHJcblx0ICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIGlmICh0YXJnZXQpIHtcclxuXHQgICAgICAgICAgICB2YXIgY291bnQgPSB0YXJnZXQubGVhZGluZ0NvbW1lbnRzID8gdGFyZ2V0LmxlYWRpbmdDb21tZW50cy5sZW5ndGggOiAwO1xyXG5cdCAgICAgICAgICAgIGZvciAodmFyIGkgPSBjb3VudCAtIDE7IGkgPj0gMDsgLS1pKSB7XHJcblx0ICAgICAgICAgICAgICAgIHZhciBjb21tZW50ID0gdGFyZ2V0LmxlYWRpbmdDb21tZW50c1tpXTtcclxuXHQgICAgICAgICAgICAgICAgaWYgKGNvbW1lbnQucmFuZ2VbMV0gPD0gbWV0YWRhdGEuc3RhcnQub2Zmc2V0KSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICBsZWFkaW5nQ29tbWVudHMudW5zaGlmdChjb21tZW50KTtcclxuXHQgICAgICAgICAgICAgICAgICAgIHRhcmdldC5sZWFkaW5nQ29tbWVudHMuc3BsaWNlKGksIDEpO1xyXG5cdCAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgIGlmICh0YXJnZXQubGVhZGluZ0NvbW1lbnRzICYmIHRhcmdldC5sZWFkaW5nQ29tbWVudHMubGVuZ3RoID09PSAwKSB7XHJcblx0ICAgICAgICAgICAgICAgIGRlbGV0ZSB0YXJnZXQubGVhZGluZ0NvbW1lbnRzO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICByZXR1cm4gbGVhZGluZ0NvbW1lbnRzO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgZm9yICh2YXIgaSA9IHRoaXMubGVhZGluZy5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xyXG5cdCAgICAgICAgICAgIHZhciBlbnRyeSA9IHRoaXMubGVhZGluZ1tpXTtcclxuXHQgICAgICAgICAgICBpZiAoZW50cnkuc3RhcnQgPD0gbWV0YWRhdGEuc3RhcnQub2Zmc2V0KSB7XHJcblx0ICAgICAgICAgICAgICAgIGxlYWRpbmdDb21tZW50cy51bnNoaWZ0KGVudHJ5LmNvbW1lbnQpO1xyXG5cdCAgICAgICAgICAgICAgICB0aGlzLmxlYWRpbmcuc3BsaWNlKGksIDEpO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIHJldHVybiBsZWFkaW5nQ29tbWVudHM7XHJcblx0ICAgIH07XHJcblx0ICAgIENvbW1lbnRIYW5kbGVyLnByb3RvdHlwZS52aXNpdE5vZGUgPSBmdW5jdGlvbiAobm9kZSwgbWV0YWRhdGEpIHtcclxuXHQgICAgICAgIGlmIChub2RlLnR5cGUgPT09IHN5bnRheF8xLlN5bnRheC5Qcm9ncmFtICYmIG5vZGUuYm9keS5sZW5ndGggPiAwKSB7XHJcblx0ICAgICAgICAgICAgcmV0dXJuO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgdGhpcy5pbnNlcnRJbm5lckNvbW1lbnRzKG5vZGUsIG1ldGFkYXRhKTtcclxuXHQgICAgICAgIHZhciB0cmFpbGluZ0NvbW1lbnRzID0gdGhpcy5maW5kVHJhaWxpbmdDb21tZW50cyhtZXRhZGF0YSk7XHJcblx0ICAgICAgICB2YXIgbGVhZGluZ0NvbW1lbnRzID0gdGhpcy5maW5kTGVhZGluZ0NvbW1lbnRzKG1ldGFkYXRhKTtcclxuXHQgICAgICAgIGlmIChsZWFkaW5nQ29tbWVudHMubGVuZ3RoID4gMCkge1xyXG5cdCAgICAgICAgICAgIG5vZGUubGVhZGluZ0NvbW1lbnRzID0gbGVhZGluZ0NvbW1lbnRzO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgaWYgKHRyYWlsaW5nQ29tbWVudHMubGVuZ3RoID4gMCkge1xyXG5cdCAgICAgICAgICAgIG5vZGUudHJhaWxpbmdDb21tZW50cyA9IHRyYWlsaW5nQ29tbWVudHM7XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICB0aGlzLnN0YWNrLnB1c2goe1xyXG5cdCAgICAgICAgICAgIG5vZGU6IG5vZGUsXHJcblx0ICAgICAgICAgICAgc3RhcnQ6IG1ldGFkYXRhLnN0YXJ0Lm9mZnNldFxyXG5cdCAgICAgICAgfSk7XHJcblx0ICAgIH07XHJcblx0ICAgIENvbW1lbnRIYW5kbGVyLnByb3RvdHlwZS52aXNpdENvbW1lbnQgPSBmdW5jdGlvbiAobm9kZSwgbWV0YWRhdGEpIHtcclxuXHQgICAgICAgIHZhciB0eXBlID0gKG5vZGUudHlwZVswXSA9PT0gJ0wnKSA/ICdMaW5lJyA6ICdCbG9jayc7XHJcblx0ICAgICAgICB2YXIgY29tbWVudCA9IHtcclxuXHQgICAgICAgICAgICB0eXBlOiB0eXBlLFxyXG5cdCAgICAgICAgICAgIHZhbHVlOiBub2RlLnZhbHVlXHJcblx0ICAgICAgICB9O1xyXG5cdCAgICAgICAgaWYgKG5vZGUucmFuZ2UpIHtcclxuXHQgICAgICAgICAgICBjb21tZW50LnJhbmdlID0gbm9kZS5yYW5nZTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIGlmIChub2RlLmxvYykge1xyXG5cdCAgICAgICAgICAgIGNvbW1lbnQubG9jID0gbm9kZS5sb2M7XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICB0aGlzLmNvbW1lbnRzLnB1c2goY29tbWVudCk7XHJcblx0ICAgICAgICBpZiAodGhpcy5hdHRhY2gpIHtcclxuXHQgICAgICAgICAgICB2YXIgZW50cnkgPSB7XHJcblx0ICAgICAgICAgICAgICAgIGNvbW1lbnQ6IHtcclxuXHQgICAgICAgICAgICAgICAgICAgIHR5cGU6IHR5cGUsXHJcblx0ICAgICAgICAgICAgICAgICAgICB2YWx1ZTogbm9kZS52YWx1ZSxcclxuXHQgICAgICAgICAgICAgICAgICAgIHJhbmdlOiBbbWV0YWRhdGEuc3RhcnQub2Zmc2V0LCBtZXRhZGF0YS5lbmQub2Zmc2V0XVxyXG5cdCAgICAgICAgICAgICAgICB9LFxyXG5cdCAgICAgICAgICAgICAgICBzdGFydDogbWV0YWRhdGEuc3RhcnQub2Zmc2V0XHJcblx0ICAgICAgICAgICAgfTtcclxuXHQgICAgICAgICAgICBpZiAobm9kZS5sb2MpIHtcclxuXHQgICAgICAgICAgICAgICAgZW50cnkuY29tbWVudC5sb2MgPSBub2RlLmxvYztcclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgbm9kZS50eXBlID0gdHlwZTtcclxuXHQgICAgICAgICAgICB0aGlzLmxlYWRpbmcucHVzaChlbnRyeSk7XHJcblx0ICAgICAgICAgICAgdGhpcy50cmFpbGluZy5wdXNoKGVudHJ5KTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgfTtcclxuXHQgICAgQ29tbWVudEhhbmRsZXIucHJvdG90eXBlLnZpc2l0ID0gZnVuY3Rpb24gKG5vZGUsIG1ldGFkYXRhKSB7XHJcblx0ICAgICAgICBpZiAobm9kZS50eXBlID09PSAnTGluZUNvbW1lbnQnKSB7XHJcblx0ICAgICAgICAgICAgdGhpcy52aXNpdENvbW1lbnQobm9kZSwgbWV0YWRhdGEpO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgZWxzZSBpZiAobm9kZS50eXBlID09PSAnQmxvY2tDb21tZW50Jykge1xyXG5cdCAgICAgICAgICAgIHRoaXMudmlzaXRDb21tZW50KG5vZGUsIG1ldGFkYXRhKTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIGVsc2UgaWYgKHRoaXMuYXR0YWNoKSB7XHJcblx0ICAgICAgICAgICAgdGhpcy52aXNpdE5vZGUobm9kZSwgbWV0YWRhdGEpO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICB9O1xyXG5cdCAgICByZXR1cm4gQ29tbWVudEhhbmRsZXI7XHJcblx0fSgpKTtcclxuXHRleHBvcnRzLkNvbW1lbnRIYW5kbGVyID0gQ29tbWVudEhhbmRsZXI7XHJcblxuXG4vKioqLyB9LFxuLyogMiAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cblx0XCJ1c2Ugc3RyaWN0XCI7XHJcblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG5cdGV4cG9ydHMuU3ludGF4ID0ge1xyXG5cdCAgICBBc3NpZ25tZW50RXhwcmVzc2lvbjogJ0Fzc2lnbm1lbnRFeHByZXNzaW9uJyxcclxuXHQgICAgQXNzaWdubWVudFBhdHRlcm46ICdBc3NpZ25tZW50UGF0dGVybicsXHJcblx0ICAgIEFycmF5RXhwcmVzc2lvbjogJ0FycmF5RXhwcmVzc2lvbicsXHJcblx0ICAgIEFycmF5UGF0dGVybjogJ0FycmF5UGF0dGVybicsXHJcblx0ICAgIEFycm93RnVuY3Rpb25FeHByZXNzaW9uOiAnQXJyb3dGdW5jdGlvbkV4cHJlc3Npb24nLFxyXG5cdCAgICBBd2FpdEV4cHJlc3Npb246ICdBd2FpdEV4cHJlc3Npb24nLFxyXG5cdCAgICBCbG9ja1N0YXRlbWVudDogJ0Jsb2NrU3RhdGVtZW50JyxcclxuXHQgICAgQmluYXJ5RXhwcmVzc2lvbjogJ0JpbmFyeUV4cHJlc3Npb24nLFxyXG5cdCAgICBCcmVha1N0YXRlbWVudDogJ0JyZWFrU3RhdGVtZW50JyxcclxuXHQgICAgQ2FsbEV4cHJlc3Npb246ICdDYWxsRXhwcmVzc2lvbicsXHJcblx0ICAgIENhdGNoQ2xhdXNlOiAnQ2F0Y2hDbGF1c2UnLFxyXG5cdCAgICBDbGFzc0JvZHk6ICdDbGFzc0JvZHknLFxyXG5cdCAgICBDbGFzc0RlY2xhcmF0aW9uOiAnQ2xhc3NEZWNsYXJhdGlvbicsXHJcblx0ICAgIENsYXNzRXhwcmVzc2lvbjogJ0NsYXNzRXhwcmVzc2lvbicsXHJcblx0ICAgIENvbmRpdGlvbmFsRXhwcmVzc2lvbjogJ0NvbmRpdGlvbmFsRXhwcmVzc2lvbicsXHJcblx0ICAgIENvbnRpbnVlU3RhdGVtZW50OiAnQ29udGludWVTdGF0ZW1lbnQnLFxyXG5cdCAgICBEb1doaWxlU3RhdGVtZW50OiAnRG9XaGlsZVN0YXRlbWVudCcsXHJcblx0ICAgIERlYnVnZ2VyU3RhdGVtZW50OiAnRGVidWdnZXJTdGF0ZW1lbnQnLFxyXG5cdCAgICBFbXB0eVN0YXRlbWVudDogJ0VtcHR5U3RhdGVtZW50JyxcclxuXHQgICAgRXhwb3J0QWxsRGVjbGFyYXRpb246ICdFeHBvcnRBbGxEZWNsYXJhdGlvbicsXHJcblx0ICAgIEV4cG9ydERlZmF1bHREZWNsYXJhdGlvbjogJ0V4cG9ydERlZmF1bHREZWNsYXJhdGlvbicsXHJcblx0ICAgIEV4cG9ydE5hbWVkRGVjbGFyYXRpb246ICdFeHBvcnROYW1lZERlY2xhcmF0aW9uJyxcclxuXHQgICAgRXhwb3J0U3BlY2lmaWVyOiAnRXhwb3J0U3BlY2lmaWVyJyxcclxuXHQgICAgRXhwcmVzc2lvblN0YXRlbWVudDogJ0V4cHJlc3Npb25TdGF0ZW1lbnQnLFxyXG5cdCAgICBGb3JTdGF0ZW1lbnQ6ICdGb3JTdGF0ZW1lbnQnLFxyXG5cdCAgICBGb3JPZlN0YXRlbWVudDogJ0Zvck9mU3RhdGVtZW50JyxcclxuXHQgICAgRm9ySW5TdGF0ZW1lbnQ6ICdGb3JJblN0YXRlbWVudCcsXHJcblx0ICAgIEZ1bmN0aW9uRGVjbGFyYXRpb246ICdGdW5jdGlvbkRlY2xhcmF0aW9uJyxcclxuXHQgICAgRnVuY3Rpb25FeHByZXNzaW9uOiAnRnVuY3Rpb25FeHByZXNzaW9uJyxcclxuXHQgICAgSWRlbnRpZmllcjogJ0lkZW50aWZpZXInLFxyXG5cdCAgICBJZlN0YXRlbWVudDogJ0lmU3RhdGVtZW50JyxcclxuXHQgICAgSW1wb3J0RGVjbGFyYXRpb246ICdJbXBvcnREZWNsYXJhdGlvbicsXHJcblx0ICAgIEltcG9ydERlZmF1bHRTcGVjaWZpZXI6ICdJbXBvcnREZWZhdWx0U3BlY2lmaWVyJyxcclxuXHQgICAgSW1wb3J0TmFtZXNwYWNlU3BlY2lmaWVyOiAnSW1wb3J0TmFtZXNwYWNlU3BlY2lmaWVyJyxcclxuXHQgICAgSW1wb3J0U3BlY2lmaWVyOiAnSW1wb3J0U3BlY2lmaWVyJyxcclxuXHQgICAgTGl0ZXJhbDogJ0xpdGVyYWwnLFxyXG5cdCAgICBMYWJlbGVkU3RhdGVtZW50OiAnTGFiZWxlZFN0YXRlbWVudCcsXHJcblx0ICAgIExvZ2ljYWxFeHByZXNzaW9uOiAnTG9naWNhbEV4cHJlc3Npb24nLFxyXG5cdCAgICBNZW1iZXJFeHByZXNzaW9uOiAnTWVtYmVyRXhwcmVzc2lvbicsXHJcblx0ICAgIE1ldGFQcm9wZXJ0eTogJ01ldGFQcm9wZXJ0eScsXHJcblx0ICAgIE1ldGhvZERlZmluaXRpb246ICdNZXRob2REZWZpbml0aW9uJyxcclxuXHQgICAgTmV3RXhwcmVzc2lvbjogJ05ld0V4cHJlc3Npb24nLFxyXG5cdCAgICBPYmplY3RFeHByZXNzaW9uOiAnT2JqZWN0RXhwcmVzc2lvbicsXHJcblx0ICAgIE9iamVjdFBhdHRlcm46ICdPYmplY3RQYXR0ZXJuJyxcclxuXHQgICAgUHJvZ3JhbTogJ1Byb2dyYW0nLFxyXG5cdCAgICBQcm9wZXJ0eTogJ1Byb3BlcnR5JyxcclxuXHQgICAgUmVzdEVsZW1lbnQ6ICdSZXN0RWxlbWVudCcsXHJcblx0ICAgIFJldHVyblN0YXRlbWVudDogJ1JldHVyblN0YXRlbWVudCcsXHJcblx0ICAgIFNlcXVlbmNlRXhwcmVzc2lvbjogJ1NlcXVlbmNlRXhwcmVzc2lvbicsXHJcblx0ICAgIFNwcmVhZEVsZW1lbnQ6ICdTcHJlYWRFbGVtZW50JyxcclxuXHQgICAgU3VwZXI6ICdTdXBlcicsXHJcblx0ICAgIFN3aXRjaENhc2U6ICdTd2l0Y2hDYXNlJyxcclxuXHQgICAgU3dpdGNoU3RhdGVtZW50OiAnU3dpdGNoU3RhdGVtZW50JyxcclxuXHQgICAgVGFnZ2VkVGVtcGxhdGVFeHByZXNzaW9uOiAnVGFnZ2VkVGVtcGxhdGVFeHByZXNzaW9uJyxcclxuXHQgICAgVGVtcGxhdGVFbGVtZW50OiAnVGVtcGxhdGVFbGVtZW50JyxcclxuXHQgICAgVGVtcGxhdGVMaXRlcmFsOiAnVGVtcGxhdGVMaXRlcmFsJyxcclxuXHQgICAgVGhpc0V4cHJlc3Npb246ICdUaGlzRXhwcmVzc2lvbicsXHJcblx0ICAgIFRocm93U3RhdGVtZW50OiAnVGhyb3dTdGF0ZW1lbnQnLFxyXG5cdCAgICBUcnlTdGF0ZW1lbnQ6ICdUcnlTdGF0ZW1lbnQnLFxyXG5cdCAgICBVbmFyeUV4cHJlc3Npb246ICdVbmFyeUV4cHJlc3Npb24nLFxyXG5cdCAgICBVcGRhdGVFeHByZXNzaW9uOiAnVXBkYXRlRXhwcmVzc2lvbicsXHJcblx0ICAgIFZhcmlhYmxlRGVjbGFyYXRpb246ICdWYXJpYWJsZURlY2xhcmF0aW9uJyxcclxuXHQgICAgVmFyaWFibGVEZWNsYXJhdG9yOiAnVmFyaWFibGVEZWNsYXJhdG9yJyxcclxuXHQgICAgV2hpbGVTdGF0ZW1lbnQ6ICdXaGlsZVN0YXRlbWVudCcsXHJcblx0ICAgIFdpdGhTdGF0ZW1lbnQ6ICdXaXRoU3RhdGVtZW50JyxcclxuXHQgICAgWWllbGRFeHByZXNzaW9uOiAnWWllbGRFeHByZXNzaW9uJ1xyXG5cdH07XHJcblxuXG4vKioqLyB9LFxuLyogMyAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblx0XCJ1c2Ugc3RyaWN0XCI7XHJcbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG5cdHZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcclxuXHQgICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcclxuXHQgICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcclxuXHQgICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xyXG5cdCAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcclxuXHQgICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XHJcblx0ICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cclxuXHQgICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcclxuXHQgICAgfTtcclxuXHR9KSgpO1xyXG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuXHR2YXIgY2hhcmFjdGVyXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQpO1xyXG5cdHZhciBKU1hOb2RlID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1KTtcclxuXHR2YXIganN4X3N5bnRheF8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2KTtcclxuXHR2YXIgTm9kZSA9IF9fd2VicGFja19yZXF1aXJlX18oNyk7XHJcblx0dmFyIHBhcnNlcl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg4KTtcclxuXHR2YXIgdG9rZW5fMSA9IF9fd2VicGFja19yZXF1aXJlX18oMTMpO1xyXG5cdHZhciB4aHRtbF9lbnRpdGllc18xID0gX193ZWJwYWNrX3JlcXVpcmVfXygxNCk7XHJcblx0dG9rZW5fMS5Ub2tlbk5hbWVbMTAwIC8qIElkZW50aWZpZXIgKi9dID0gJ0pTWElkZW50aWZpZXInO1xyXG5cdHRva2VuXzEuVG9rZW5OYW1lWzEwMSAvKiBUZXh0ICovXSA9ICdKU1hUZXh0JztcclxuXHQvLyBGdWxseSBxdWFsaWZpZWQgZWxlbWVudCBuYW1lLCBlLmcuIDxzdmc6cGF0aD4gcmV0dXJucyBcInN2ZzpwYXRoXCJcclxuXHRmdW5jdGlvbiBnZXRRdWFsaWZpZWRFbGVtZW50TmFtZShlbGVtZW50TmFtZSkge1xyXG5cdCAgICB2YXIgcXVhbGlmaWVkTmFtZTtcclxuXHQgICAgc3dpdGNoIChlbGVtZW50TmFtZS50eXBlKSB7XHJcblx0ICAgICAgICBjYXNlIGpzeF9zeW50YXhfMS5KU1hTeW50YXguSlNYSWRlbnRpZmllcjpcclxuXHQgICAgICAgICAgICB2YXIgaWQgPSBlbGVtZW50TmFtZTtcclxuXHQgICAgICAgICAgICBxdWFsaWZpZWROYW1lID0gaWQubmFtZTtcclxuXHQgICAgICAgICAgICBicmVhaztcclxuXHQgICAgICAgIGNhc2UganN4X3N5bnRheF8xLkpTWFN5bnRheC5KU1hOYW1lc3BhY2VkTmFtZTpcclxuXHQgICAgICAgICAgICB2YXIgbnMgPSBlbGVtZW50TmFtZTtcclxuXHQgICAgICAgICAgICBxdWFsaWZpZWROYW1lID0gZ2V0UXVhbGlmaWVkRWxlbWVudE5hbWUobnMubmFtZXNwYWNlKSArICc6JyArXHJcblx0ICAgICAgICAgICAgICAgIGdldFF1YWxpZmllZEVsZW1lbnROYW1lKG5zLm5hbWUpO1xyXG5cdCAgICAgICAgICAgIGJyZWFrO1xyXG5cdCAgICAgICAgY2FzZSBqc3hfc3ludGF4XzEuSlNYU3ludGF4LkpTWE1lbWJlckV4cHJlc3Npb246XHJcblx0ICAgICAgICAgICAgdmFyIGV4cHIgPSBlbGVtZW50TmFtZTtcclxuXHQgICAgICAgICAgICBxdWFsaWZpZWROYW1lID0gZ2V0UXVhbGlmaWVkRWxlbWVudE5hbWUoZXhwci5vYmplY3QpICsgJy4nICtcclxuXHQgICAgICAgICAgICAgICAgZ2V0UXVhbGlmaWVkRWxlbWVudE5hbWUoZXhwci5wcm9wZXJ0eSk7XHJcblx0ICAgICAgICAgICAgYnJlYWs7XHJcblx0ICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xyXG5cdCAgICAgICAgZGVmYXVsdDpcclxuXHQgICAgICAgICAgICBicmVhaztcclxuXHQgICAgfVxyXG5cdCAgICByZXR1cm4gcXVhbGlmaWVkTmFtZTtcclxuXHR9XHJcblx0dmFyIEpTWFBhcnNlciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcblx0ICAgIF9fZXh0ZW5kcyhKU1hQYXJzZXIsIF9zdXBlcik7XHJcblx0ICAgIGZ1bmN0aW9uIEpTWFBhcnNlcihjb2RlLCBvcHRpb25zLCBkZWxlZ2F0ZSkge1xyXG5cdCAgICAgICAgcmV0dXJuIF9zdXBlci5jYWxsKHRoaXMsIGNvZGUsIG9wdGlvbnMsIGRlbGVnYXRlKSB8fCB0aGlzO1xyXG5cdCAgICB9XHJcblx0ICAgIEpTWFBhcnNlci5wcm90b3R5cGUucGFyc2VQcmltYXJ5RXhwcmVzc2lvbiA9IGZ1bmN0aW9uICgpIHtcclxuXHQgICAgICAgIHJldHVybiB0aGlzLm1hdGNoKCc8JykgPyB0aGlzLnBhcnNlSlNYUm9vdCgpIDogX3N1cGVyLnByb3RvdHlwZS5wYXJzZVByaW1hcnlFeHByZXNzaW9uLmNhbGwodGhpcyk7XHJcblx0ICAgIH07XHJcblx0ICAgIEpTWFBhcnNlci5wcm90b3R5cGUuc3RhcnRKU1ggPSBmdW5jdGlvbiAoKSB7XHJcblx0ICAgICAgICAvLyBVbndpbmQgdGhlIHNjYW5uZXIgYmVmb3JlIHRoZSBsb29rYWhlYWQgdG9rZW4uXHJcblx0ICAgICAgICB0aGlzLnNjYW5uZXIuaW5kZXggPSB0aGlzLnN0YXJ0TWFya2VyLmluZGV4O1xyXG5cdCAgICAgICAgdGhpcy5zY2FubmVyLmxpbmVOdW1iZXIgPSB0aGlzLnN0YXJ0TWFya2VyLmxpbmU7XHJcblx0ICAgICAgICB0aGlzLnNjYW5uZXIubGluZVN0YXJ0ID0gdGhpcy5zdGFydE1hcmtlci5pbmRleCAtIHRoaXMuc3RhcnRNYXJrZXIuY29sdW1uO1xyXG5cdCAgICB9O1xyXG5cdCAgICBKU1hQYXJzZXIucHJvdG90eXBlLmZpbmlzaEpTWCA9IGZ1bmN0aW9uICgpIHtcclxuXHQgICAgICAgIC8vIFByaW1lIHRoZSBuZXh0IGxvb2thaGVhZC5cclxuXHQgICAgICAgIHRoaXMubmV4dFRva2VuKCk7XHJcblx0ICAgIH07XHJcblx0ICAgIEpTWFBhcnNlci5wcm90b3R5cGUucmVlbnRlckpTWCA9IGZ1bmN0aW9uICgpIHtcclxuXHQgICAgICAgIHRoaXMuc3RhcnRKU1goKTtcclxuXHQgICAgICAgIHRoaXMuZXhwZWN0SlNYKCd9Jyk7XHJcblx0ICAgICAgICAvLyBQb3AgdGhlIGNsb3NpbmcgJ30nIGFkZGVkIGZyb20gdGhlIGxvb2thaGVhZC5cclxuXHQgICAgICAgIGlmICh0aGlzLmNvbmZpZy50b2tlbnMpIHtcclxuXHQgICAgICAgICAgICB0aGlzLnRva2Vucy5wb3AoKTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgfTtcclxuXHQgICAgSlNYUGFyc2VyLnByb3RvdHlwZS5jcmVhdGVKU1hOb2RlID0gZnVuY3Rpb24gKCkge1xyXG5cdCAgICAgICAgdGhpcy5jb2xsZWN0Q29tbWVudHMoKTtcclxuXHQgICAgICAgIHJldHVybiB7XHJcblx0ICAgICAgICAgICAgaW5kZXg6IHRoaXMuc2Nhbm5lci5pbmRleCxcclxuXHQgICAgICAgICAgICBsaW5lOiB0aGlzLnNjYW5uZXIubGluZU51bWJlcixcclxuXHQgICAgICAgICAgICBjb2x1bW46IHRoaXMuc2Nhbm5lci5pbmRleCAtIHRoaXMuc2Nhbm5lci5saW5lU3RhcnRcclxuXHQgICAgICAgIH07XHJcblx0ICAgIH07XHJcblx0ICAgIEpTWFBhcnNlci5wcm90b3R5cGUuY3JlYXRlSlNYQ2hpbGROb2RlID0gZnVuY3Rpb24gKCkge1xyXG5cdCAgICAgICAgcmV0dXJuIHtcclxuXHQgICAgICAgICAgICBpbmRleDogdGhpcy5zY2FubmVyLmluZGV4LFxyXG5cdCAgICAgICAgICAgIGxpbmU6IHRoaXMuc2Nhbm5lci5saW5lTnVtYmVyLFxyXG5cdCAgICAgICAgICAgIGNvbHVtbjogdGhpcy5zY2FubmVyLmluZGV4IC0gdGhpcy5zY2FubmVyLmxpbmVTdGFydFxyXG5cdCAgICAgICAgfTtcclxuXHQgICAgfTtcclxuXHQgICAgSlNYUGFyc2VyLnByb3RvdHlwZS5zY2FuWEhUTUxFbnRpdHkgPSBmdW5jdGlvbiAocXVvdGUpIHtcclxuXHQgICAgICAgIHZhciByZXN1bHQgPSAnJic7XHJcblx0ICAgICAgICB2YXIgdmFsaWQgPSB0cnVlO1xyXG5cdCAgICAgICAgdmFyIHRlcm1pbmF0ZWQgPSBmYWxzZTtcclxuXHQgICAgICAgIHZhciBudW1lcmljID0gZmFsc2U7XHJcblx0ICAgICAgICB2YXIgaGV4ID0gZmFsc2U7XHJcblx0ICAgICAgICB3aGlsZSAoIXRoaXMuc2Nhbm5lci5lb2YoKSAmJiB2YWxpZCAmJiAhdGVybWluYXRlZCkge1xyXG5cdCAgICAgICAgICAgIHZhciBjaCA9IHRoaXMuc2Nhbm5lci5zb3VyY2VbdGhpcy5zY2FubmVyLmluZGV4XTtcclxuXHQgICAgICAgICAgICBpZiAoY2ggPT09IHF1b3RlKSB7XHJcblx0ICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICB0ZXJtaW5hdGVkID0gKGNoID09PSAnOycpO1xyXG5cdCAgICAgICAgICAgIHJlc3VsdCArPSBjaDtcclxuXHQgICAgICAgICAgICArK3RoaXMuc2Nhbm5lci5pbmRleDtcclxuXHQgICAgICAgICAgICBpZiAoIXRlcm1pbmF0ZWQpIHtcclxuXHQgICAgICAgICAgICAgICAgc3dpdGNoIChyZXN1bHQubGVuZ3RoKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICBjYXNlIDI6XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgLy8gZS5nLiAnJiMxMjM7J1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIG51bWVyaWMgPSAoY2ggPT09ICcjJyk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcblx0ICAgICAgICAgICAgICAgICAgICBjYXNlIDM6XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG51bWVyaWMpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gZS5nLiAnJiN4NDE7J1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBoZXggPSAoY2ggPT09ICd4Jyk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbGlkID0gaGV4IHx8IGNoYXJhY3Rlcl8xLkNoYXJhY3Rlci5pc0RlY2ltYWxEaWdpdChjaC5jaGFyQ29kZUF0KDApKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgbnVtZXJpYyA9IG51bWVyaWMgJiYgIWhleDtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcblx0ICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHZhbGlkID0gdmFsaWQgJiYgIShudW1lcmljICYmICFjaGFyYWN0ZXJfMS5DaGFyYWN0ZXIuaXNEZWNpbWFsRGlnaXQoY2guY2hhckNvZGVBdCgwKSkpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHZhbGlkID0gdmFsaWQgJiYgIShoZXggJiYgIWNoYXJhY3Rlcl8xLkNoYXJhY3Rlci5pc0hleERpZ2l0KGNoLmNoYXJDb2RlQXQoMCkpKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuXHQgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIGlmICh2YWxpZCAmJiB0ZXJtaW5hdGVkICYmIHJlc3VsdC5sZW5ndGggPiAyKSB7XHJcblx0ICAgICAgICAgICAgLy8gZS5nLiAnJiN4NDE7JyBiZWNvbWVzIGp1c3QgJyN4NDEnXHJcblx0ICAgICAgICAgICAgdmFyIHN0ciA9IHJlc3VsdC5zdWJzdHIoMSwgcmVzdWx0Lmxlbmd0aCAtIDIpO1xyXG5cdCAgICAgICAgICAgIGlmIChudW1lcmljICYmIHN0ci5sZW5ndGggPiAxKSB7XHJcblx0ICAgICAgICAgICAgICAgIHJlc3VsdCA9IFN0cmluZy5mcm9tQ2hhckNvZGUocGFyc2VJbnQoc3RyLnN1YnN0cigxKSwgMTApKTtcclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgZWxzZSBpZiAoaGV4ICYmIHN0ci5sZW5ndGggPiAyKSB7XHJcblx0ICAgICAgICAgICAgICAgIHJlc3VsdCA9IFN0cmluZy5mcm9tQ2hhckNvZGUocGFyc2VJbnQoJzAnICsgc3RyLnN1YnN0cigxKSwgMTYpKTtcclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgZWxzZSBpZiAoIW51bWVyaWMgJiYgIWhleCAmJiB4aHRtbF9lbnRpdGllc18xLlhIVE1MRW50aXRpZXNbc3RyXSkge1xyXG5cdCAgICAgICAgICAgICAgICByZXN1bHQgPSB4aHRtbF9lbnRpdGllc18xLlhIVE1MRW50aXRpZXNbc3RyXTtcclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG5cdCAgICB9O1xyXG5cdCAgICAvLyBTY2FuIHRoZSBuZXh0IEpTWCB0b2tlbi4gVGhpcyByZXBsYWNlcyBTY2FubmVyI2xleCB3aGVuIGluIEpTWCBtb2RlLlxyXG5cdCAgICBKU1hQYXJzZXIucHJvdG90eXBlLmxleEpTWCA9IGZ1bmN0aW9uICgpIHtcclxuXHQgICAgICAgIHZhciBjcCA9IHRoaXMuc2Nhbm5lci5zb3VyY2UuY2hhckNvZGVBdCh0aGlzLnNjYW5uZXIuaW5kZXgpO1xyXG5cdCAgICAgICAgLy8gPCA+IC8gOiA9IHsgfVxyXG5cdCAgICAgICAgaWYgKGNwID09PSA2MCB8fCBjcCA9PT0gNjIgfHwgY3AgPT09IDQ3IHx8IGNwID09PSA1OCB8fCBjcCA9PT0gNjEgfHwgY3AgPT09IDEyMyB8fCBjcCA9PT0gMTI1KSB7XHJcblx0ICAgICAgICAgICAgdmFyIHZhbHVlID0gdGhpcy5zY2FubmVyLnNvdXJjZVt0aGlzLnNjYW5uZXIuaW5kZXgrK107XHJcblx0ICAgICAgICAgICAgcmV0dXJuIHtcclxuXHQgICAgICAgICAgICAgICAgdHlwZTogNyAvKiBQdW5jdHVhdG9yICovLFxyXG5cdCAgICAgICAgICAgICAgICB2YWx1ZTogdmFsdWUsXHJcblx0ICAgICAgICAgICAgICAgIGxpbmVOdW1iZXI6IHRoaXMuc2Nhbm5lci5saW5lTnVtYmVyLFxyXG5cdCAgICAgICAgICAgICAgICBsaW5lU3RhcnQ6IHRoaXMuc2Nhbm5lci5saW5lU3RhcnQsXHJcblx0ICAgICAgICAgICAgICAgIHN0YXJ0OiB0aGlzLnNjYW5uZXIuaW5kZXggLSAxLFxyXG5cdCAgICAgICAgICAgICAgICBlbmQ6IHRoaXMuc2Nhbm5lci5pbmRleFxyXG5cdCAgICAgICAgICAgIH07XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICAvLyBcIiAnXHJcblx0ICAgICAgICBpZiAoY3AgPT09IDM0IHx8IGNwID09PSAzOSkge1xyXG5cdCAgICAgICAgICAgIHZhciBzdGFydCA9IHRoaXMuc2Nhbm5lci5pbmRleDtcclxuXHQgICAgICAgICAgICB2YXIgcXVvdGUgPSB0aGlzLnNjYW5uZXIuc291cmNlW3RoaXMuc2Nhbm5lci5pbmRleCsrXTtcclxuXHQgICAgICAgICAgICB2YXIgc3RyID0gJyc7XHJcblx0ICAgICAgICAgICAgd2hpbGUgKCF0aGlzLnNjYW5uZXIuZW9mKCkpIHtcclxuXHQgICAgICAgICAgICAgICAgdmFyIGNoID0gdGhpcy5zY2FubmVyLnNvdXJjZVt0aGlzLnNjYW5uZXIuaW5kZXgrK107XHJcblx0ICAgICAgICAgICAgICAgIGlmIChjaCA9PT0gcXVvdGUpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cdCAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgIGVsc2UgaWYgKGNoID09PSAnJicpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgIHN0ciArPSB0aGlzLnNjYW5YSFRNTEVudGl0eShxdW90ZSk7XHJcblx0ICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgZWxzZSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICBzdHIgKz0gY2g7XHJcblx0ICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgcmV0dXJuIHtcclxuXHQgICAgICAgICAgICAgICAgdHlwZTogOCAvKiBTdHJpbmdMaXRlcmFsICovLFxyXG5cdCAgICAgICAgICAgICAgICB2YWx1ZTogc3RyLFxyXG5cdCAgICAgICAgICAgICAgICBsaW5lTnVtYmVyOiB0aGlzLnNjYW5uZXIubGluZU51bWJlcixcclxuXHQgICAgICAgICAgICAgICAgbGluZVN0YXJ0OiB0aGlzLnNjYW5uZXIubGluZVN0YXJ0LFxyXG5cdCAgICAgICAgICAgICAgICBzdGFydDogc3RhcnQsXHJcblx0ICAgICAgICAgICAgICAgIGVuZDogdGhpcy5zY2FubmVyLmluZGV4XHJcblx0ICAgICAgICAgICAgfTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIC8vIC4uLiBvciAuXHJcblx0ICAgICAgICBpZiAoY3AgPT09IDQ2KSB7XHJcblx0ICAgICAgICAgICAgdmFyIG4xID0gdGhpcy5zY2FubmVyLnNvdXJjZS5jaGFyQ29kZUF0KHRoaXMuc2Nhbm5lci5pbmRleCArIDEpO1xyXG5cdCAgICAgICAgICAgIHZhciBuMiA9IHRoaXMuc2Nhbm5lci5zb3VyY2UuY2hhckNvZGVBdCh0aGlzLnNjYW5uZXIuaW5kZXggKyAyKTtcclxuXHQgICAgICAgICAgICB2YXIgdmFsdWUgPSAobjEgPT09IDQ2ICYmIG4yID09PSA0NikgPyAnLi4uJyA6ICcuJztcclxuXHQgICAgICAgICAgICB2YXIgc3RhcnQgPSB0aGlzLnNjYW5uZXIuaW5kZXg7XHJcblx0ICAgICAgICAgICAgdGhpcy5zY2FubmVyLmluZGV4ICs9IHZhbHVlLmxlbmd0aDtcclxuXHQgICAgICAgICAgICByZXR1cm4ge1xyXG5cdCAgICAgICAgICAgICAgICB0eXBlOiA3IC8qIFB1bmN0dWF0b3IgKi8sXHJcblx0ICAgICAgICAgICAgICAgIHZhbHVlOiB2YWx1ZSxcclxuXHQgICAgICAgICAgICAgICAgbGluZU51bWJlcjogdGhpcy5zY2FubmVyLmxpbmVOdW1iZXIsXHJcblx0ICAgICAgICAgICAgICAgIGxpbmVTdGFydDogdGhpcy5zY2FubmVyLmxpbmVTdGFydCxcclxuXHQgICAgICAgICAgICAgICAgc3RhcnQ6IHN0YXJ0LFxyXG5cdCAgICAgICAgICAgICAgICBlbmQ6IHRoaXMuc2Nhbm5lci5pbmRleFxyXG5cdCAgICAgICAgICAgIH07XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICAvLyBgXHJcblx0ICAgICAgICBpZiAoY3AgPT09IDk2KSB7XHJcblx0ICAgICAgICAgICAgLy8gT25seSBwbGFjZWhvbGRlciwgc2luY2UgaXQgd2lsbCBiZSByZXNjYW5uZWQgYXMgYSByZWFsIGFzc2lnbm1lbnQgZXhwcmVzc2lvbi5cclxuXHQgICAgICAgICAgICByZXR1cm4ge1xyXG5cdCAgICAgICAgICAgICAgICB0eXBlOiAxMCAvKiBUZW1wbGF0ZSAqLyxcclxuXHQgICAgICAgICAgICAgICAgdmFsdWU6ICcnLFxyXG5cdCAgICAgICAgICAgICAgICBsaW5lTnVtYmVyOiB0aGlzLnNjYW5uZXIubGluZU51bWJlcixcclxuXHQgICAgICAgICAgICAgICAgbGluZVN0YXJ0OiB0aGlzLnNjYW5uZXIubGluZVN0YXJ0LFxyXG5cdCAgICAgICAgICAgICAgICBzdGFydDogdGhpcy5zY2FubmVyLmluZGV4LFxyXG5cdCAgICAgICAgICAgICAgICBlbmQ6IHRoaXMuc2Nhbm5lci5pbmRleFxyXG5cdCAgICAgICAgICAgIH07XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICAvLyBJZGVudGlmZXIgY2FuIG5vdCBjb250YWluIGJhY2tzbGFzaCAoY2hhciBjb2RlIDkyKS5cclxuXHQgICAgICAgIGlmIChjaGFyYWN0ZXJfMS5DaGFyYWN0ZXIuaXNJZGVudGlmaWVyU3RhcnQoY3ApICYmIChjcCAhPT0gOTIpKSB7XHJcblx0ICAgICAgICAgICAgdmFyIHN0YXJ0ID0gdGhpcy5zY2FubmVyLmluZGV4O1xyXG5cdCAgICAgICAgICAgICsrdGhpcy5zY2FubmVyLmluZGV4O1xyXG5cdCAgICAgICAgICAgIHdoaWxlICghdGhpcy5zY2FubmVyLmVvZigpKSB7XHJcblx0ICAgICAgICAgICAgICAgIHZhciBjaCA9IHRoaXMuc2Nhbm5lci5zb3VyY2UuY2hhckNvZGVBdCh0aGlzLnNjYW5uZXIuaW5kZXgpO1xyXG5cdCAgICAgICAgICAgICAgICBpZiAoY2hhcmFjdGVyXzEuQ2hhcmFjdGVyLmlzSWRlbnRpZmllclBhcnQoY2gpICYmIChjaCAhPT0gOTIpKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICArK3RoaXMuc2Nhbm5lci5pbmRleDtcclxuXHQgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICBlbHNlIGlmIChjaCA9PT0gNDUpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgIC8vIEh5cGhlbiAoY2hhciBjb2RlIDQ1KSBjYW4gYmUgcGFydCBvZiBhbiBpZGVudGlmaWVyLlxyXG5cdCAgICAgICAgICAgICAgICAgICAgKyt0aGlzLnNjYW5uZXIuaW5kZXg7XHJcblx0ICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgZWxzZSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuXHQgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICB2YXIgaWQgPSB0aGlzLnNjYW5uZXIuc291cmNlLnNsaWNlKHN0YXJ0LCB0aGlzLnNjYW5uZXIuaW5kZXgpO1xyXG5cdCAgICAgICAgICAgIHJldHVybiB7XHJcblx0ICAgICAgICAgICAgICAgIHR5cGU6IDEwMCAvKiBJZGVudGlmaWVyICovLFxyXG5cdCAgICAgICAgICAgICAgICB2YWx1ZTogaWQsXHJcblx0ICAgICAgICAgICAgICAgIGxpbmVOdW1iZXI6IHRoaXMuc2Nhbm5lci5saW5lTnVtYmVyLFxyXG5cdCAgICAgICAgICAgICAgICBsaW5lU3RhcnQ6IHRoaXMuc2Nhbm5lci5saW5lU3RhcnQsXHJcblx0ICAgICAgICAgICAgICAgIHN0YXJ0OiBzdGFydCxcclxuXHQgICAgICAgICAgICAgICAgZW5kOiB0aGlzLnNjYW5uZXIuaW5kZXhcclxuXHQgICAgICAgICAgICB9O1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgcmV0dXJuIHRoaXMuc2Nhbm5lci5sZXgoKTtcclxuXHQgICAgfTtcclxuXHQgICAgSlNYUGFyc2VyLnByb3RvdHlwZS5uZXh0SlNYVG9rZW4gPSBmdW5jdGlvbiAoKSB7XHJcblx0ICAgICAgICB0aGlzLmNvbGxlY3RDb21tZW50cygpO1xyXG5cdCAgICAgICAgdGhpcy5zdGFydE1hcmtlci5pbmRleCA9IHRoaXMuc2Nhbm5lci5pbmRleDtcclxuXHQgICAgICAgIHRoaXMuc3RhcnRNYXJrZXIubGluZSA9IHRoaXMuc2Nhbm5lci5saW5lTnVtYmVyO1xyXG5cdCAgICAgICAgdGhpcy5zdGFydE1hcmtlci5jb2x1bW4gPSB0aGlzLnNjYW5uZXIuaW5kZXggLSB0aGlzLnNjYW5uZXIubGluZVN0YXJ0O1xyXG5cdCAgICAgICAgdmFyIHRva2VuID0gdGhpcy5sZXhKU1goKTtcclxuXHQgICAgICAgIHRoaXMubGFzdE1hcmtlci5pbmRleCA9IHRoaXMuc2Nhbm5lci5pbmRleDtcclxuXHQgICAgICAgIHRoaXMubGFzdE1hcmtlci5saW5lID0gdGhpcy5zY2FubmVyLmxpbmVOdW1iZXI7XHJcblx0ICAgICAgICB0aGlzLmxhc3RNYXJrZXIuY29sdW1uID0gdGhpcy5zY2FubmVyLmluZGV4IC0gdGhpcy5zY2FubmVyLmxpbmVTdGFydDtcclxuXHQgICAgICAgIGlmICh0aGlzLmNvbmZpZy50b2tlbnMpIHtcclxuXHQgICAgICAgICAgICB0aGlzLnRva2Vucy5wdXNoKHRoaXMuY29udmVydFRva2VuKHRva2VuKSk7XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICByZXR1cm4gdG9rZW47XHJcblx0ICAgIH07XHJcblx0ICAgIEpTWFBhcnNlci5wcm90b3R5cGUubmV4dEpTWFRleHQgPSBmdW5jdGlvbiAoKSB7XHJcblx0ICAgICAgICB0aGlzLnN0YXJ0TWFya2VyLmluZGV4ID0gdGhpcy5zY2FubmVyLmluZGV4O1xyXG5cdCAgICAgICAgdGhpcy5zdGFydE1hcmtlci5saW5lID0gdGhpcy5zY2FubmVyLmxpbmVOdW1iZXI7XHJcblx0ICAgICAgICB0aGlzLnN0YXJ0TWFya2VyLmNvbHVtbiA9IHRoaXMuc2Nhbm5lci5pbmRleCAtIHRoaXMuc2Nhbm5lci5saW5lU3RhcnQ7XHJcblx0ICAgICAgICB2YXIgc3RhcnQgPSB0aGlzLnNjYW5uZXIuaW5kZXg7XHJcblx0ICAgICAgICB2YXIgdGV4dCA9ICcnO1xyXG5cdCAgICAgICAgd2hpbGUgKCF0aGlzLnNjYW5uZXIuZW9mKCkpIHtcclxuXHQgICAgICAgICAgICB2YXIgY2ggPSB0aGlzLnNjYW5uZXIuc291cmNlW3RoaXMuc2Nhbm5lci5pbmRleF07XHJcblx0ICAgICAgICAgICAgaWYgKGNoID09PSAneycgfHwgY2ggPT09ICc8Jykge1xyXG5cdCAgICAgICAgICAgICAgICBicmVhaztcclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgKyt0aGlzLnNjYW5uZXIuaW5kZXg7XHJcblx0ICAgICAgICAgICAgdGV4dCArPSBjaDtcclxuXHQgICAgICAgICAgICBpZiAoY2hhcmFjdGVyXzEuQ2hhcmFjdGVyLmlzTGluZVRlcm1pbmF0b3IoY2guY2hhckNvZGVBdCgwKSkpIHtcclxuXHQgICAgICAgICAgICAgICAgKyt0aGlzLnNjYW5uZXIubGluZU51bWJlcjtcclxuXHQgICAgICAgICAgICAgICAgaWYgKGNoID09PSAnXFxyJyAmJiB0aGlzLnNjYW5uZXIuc291cmNlW3RoaXMuc2Nhbm5lci5pbmRleF0gPT09ICdcXG4nKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICArK3RoaXMuc2Nhbm5lci5pbmRleDtcclxuXHQgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICB0aGlzLnNjYW5uZXIubGluZVN0YXJ0ID0gdGhpcy5zY2FubmVyLmluZGV4O1xyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIHRoaXMubGFzdE1hcmtlci5pbmRleCA9IHRoaXMuc2Nhbm5lci5pbmRleDtcclxuXHQgICAgICAgIHRoaXMubGFzdE1hcmtlci5saW5lID0gdGhpcy5zY2FubmVyLmxpbmVOdW1iZXI7XHJcblx0ICAgICAgICB0aGlzLmxhc3RNYXJrZXIuY29sdW1uID0gdGhpcy5zY2FubmVyLmluZGV4IC0gdGhpcy5zY2FubmVyLmxpbmVTdGFydDtcclxuXHQgICAgICAgIHZhciB0b2tlbiA9IHtcclxuXHQgICAgICAgICAgICB0eXBlOiAxMDEgLyogVGV4dCAqLyxcclxuXHQgICAgICAgICAgICB2YWx1ZTogdGV4dCxcclxuXHQgICAgICAgICAgICBsaW5lTnVtYmVyOiB0aGlzLnNjYW5uZXIubGluZU51bWJlcixcclxuXHQgICAgICAgICAgICBsaW5lU3RhcnQ6IHRoaXMuc2Nhbm5lci5saW5lU3RhcnQsXHJcblx0ICAgICAgICAgICAgc3RhcnQ6IHN0YXJ0LFxyXG5cdCAgICAgICAgICAgIGVuZDogdGhpcy5zY2FubmVyLmluZGV4XHJcblx0ICAgICAgICB9O1xyXG5cdCAgICAgICAgaWYgKCh0ZXh0Lmxlbmd0aCA+IDApICYmIHRoaXMuY29uZmlnLnRva2Vucykge1xyXG5cdCAgICAgICAgICAgIHRoaXMudG9rZW5zLnB1c2godGhpcy5jb252ZXJ0VG9rZW4odG9rZW4pKTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIHJldHVybiB0b2tlbjtcclxuXHQgICAgfTtcclxuXHQgICAgSlNYUGFyc2VyLnByb3RvdHlwZS5wZWVrSlNYVG9rZW4gPSBmdW5jdGlvbiAoKSB7XHJcblx0ICAgICAgICB2YXIgc3RhdGUgPSB0aGlzLnNjYW5uZXIuc2F2ZVN0YXRlKCk7XHJcblx0ICAgICAgICB0aGlzLnNjYW5uZXIuc2NhbkNvbW1lbnRzKCk7XHJcblx0ICAgICAgICB2YXIgbmV4dCA9IHRoaXMubGV4SlNYKCk7XHJcblx0ICAgICAgICB0aGlzLnNjYW5uZXIucmVzdG9yZVN0YXRlKHN0YXRlKTtcclxuXHQgICAgICAgIHJldHVybiBuZXh0O1xyXG5cdCAgICB9O1xyXG5cdCAgICAvLyBFeHBlY3QgdGhlIG5leHQgSlNYIHRva2VuIHRvIG1hdGNoIHRoZSBzcGVjaWZpZWQgcHVuY3R1YXRvci5cclxuXHQgICAgLy8gSWYgbm90LCBhbiBleGNlcHRpb24gd2lsbCBiZSB0aHJvd24uXHJcblx0ICAgIEpTWFBhcnNlci5wcm90b3R5cGUuZXhwZWN0SlNYID0gZnVuY3Rpb24gKHZhbHVlKSB7XHJcblx0ICAgICAgICB2YXIgdG9rZW4gPSB0aGlzLm5leHRKU1hUb2tlbigpO1xyXG5cdCAgICAgICAgaWYgKHRva2VuLnR5cGUgIT09IDcgLyogUHVuY3R1YXRvciAqLyB8fCB0b2tlbi52YWx1ZSAhPT0gdmFsdWUpIHtcclxuXHQgICAgICAgICAgICB0aGlzLnRocm93VW5leHBlY3RlZFRva2VuKHRva2VuKTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgfTtcclxuXHQgICAgLy8gUmV0dXJuIHRydWUgaWYgdGhlIG5leHQgSlNYIHRva2VuIG1hdGNoZXMgdGhlIHNwZWNpZmllZCBwdW5jdHVhdG9yLlxyXG5cdCAgICBKU1hQYXJzZXIucHJvdG90eXBlLm1hdGNoSlNYID0gZnVuY3Rpb24gKHZhbHVlKSB7XHJcblx0ICAgICAgICB2YXIgbmV4dCA9IHRoaXMucGVla0pTWFRva2VuKCk7XHJcblx0ICAgICAgICByZXR1cm4gbmV4dC50eXBlID09PSA3IC8qIFB1bmN0dWF0b3IgKi8gJiYgbmV4dC52YWx1ZSA9PT0gdmFsdWU7XHJcblx0ICAgIH07XHJcblx0ICAgIEpTWFBhcnNlci5wcm90b3R5cGUucGFyc2VKU1hJZGVudGlmaWVyID0gZnVuY3Rpb24gKCkge1xyXG5cdCAgICAgICAgdmFyIG5vZGUgPSB0aGlzLmNyZWF0ZUpTWE5vZGUoKTtcclxuXHQgICAgICAgIHZhciB0b2tlbiA9IHRoaXMubmV4dEpTWFRva2VuKCk7XHJcblx0ICAgICAgICBpZiAodG9rZW4udHlwZSAhPT0gMTAwIC8qIElkZW50aWZpZXIgKi8pIHtcclxuXHQgICAgICAgICAgICB0aGlzLnRocm93VW5leHBlY3RlZFRva2VuKHRva2VuKTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIHJldHVybiB0aGlzLmZpbmFsaXplKG5vZGUsIG5ldyBKU1hOb2RlLkpTWElkZW50aWZpZXIodG9rZW4udmFsdWUpKTtcclxuXHQgICAgfTtcclxuXHQgICAgSlNYUGFyc2VyLnByb3RvdHlwZS5wYXJzZUpTWEVsZW1lbnROYW1lID0gZnVuY3Rpb24gKCkge1xyXG5cdCAgICAgICAgdmFyIG5vZGUgPSB0aGlzLmNyZWF0ZUpTWE5vZGUoKTtcclxuXHQgICAgICAgIHZhciBlbGVtZW50TmFtZSA9IHRoaXMucGFyc2VKU1hJZGVudGlmaWVyKCk7XHJcblx0ICAgICAgICBpZiAodGhpcy5tYXRjaEpTWCgnOicpKSB7XHJcblx0ICAgICAgICAgICAgdmFyIG5hbWVzcGFjZSA9IGVsZW1lbnROYW1lO1xyXG5cdCAgICAgICAgICAgIHRoaXMuZXhwZWN0SlNYKCc6Jyk7XHJcblx0ICAgICAgICAgICAgdmFyIG5hbWVfMSA9IHRoaXMucGFyc2VKU1hJZGVudGlmaWVyKCk7XHJcblx0ICAgICAgICAgICAgZWxlbWVudE5hbWUgPSB0aGlzLmZpbmFsaXplKG5vZGUsIG5ldyBKU1hOb2RlLkpTWE5hbWVzcGFjZWROYW1lKG5hbWVzcGFjZSwgbmFtZV8xKSk7XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICBlbHNlIGlmICh0aGlzLm1hdGNoSlNYKCcuJykpIHtcclxuXHQgICAgICAgICAgICB3aGlsZSAodGhpcy5tYXRjaEpTWCgnLicpKSB7XHJcblx0ICAgICAgICAgICAgICAgIHZhciBvYmplY3QgPSBlbGVtZW50TmFtZTtcclxuXHQgICAgICAgICAgICAgICAgdGhpcy5leHBlY3RKU1goJy4nKTtcclxuXHQgICAgICAgICAgICAgICAgdmFyIHByb3BlcnR5ID0gdGhpcy5wYXJzZUpTWElkZW50aWZpZXIoKTtcclxuXHQgICAgICAgICAgICAgICAgZWxlbWVudE5hbWUgPSB0aGlzLmZpbmFsaXplKG5vZGUsIG5ldyBKU1hOb2RlLkpTWE1lbWJlckV4cHJlc3Npb24ob2JqZWN0LCBwcm9wZXJ0eSkpO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIHJldHVybiBlbGVtZW50TmFtZTtcclxuXHQgICAgfTtcclxuXHQgICAgSlNYUGFyc2VyLnByb3RvdHlwZS5wYXJzZUpTWEF0dHJpYnV0ZU5hbWUgPSBmdW5jdGlvbiAoKSB7XHJcblx0ICAgICAgICB2YXIgbm9kZSA9IHRoaXMuY3JlYXRlSlNYTm9kZSgpO1xyXG5cdCAgICAgICAgdmFyIGF0dHJpYnV0ZU5hbWU7XHJcblx0ICAgICAgICB2YXIgaWRlbnRpZmllciA9IHRoaXMucGFyc2VKU1hJZGVudGlmaWVyKCk7XHJcblx0ICAgICAgICBpZiAodGhpcy5tYXRjaEpTWCgnOicpKSB7XHJcblx0ICAgICAgICAgICAgdmFyIG5hbWVzcGFjZSA9IGlkZW50aWZpZXI7XHJcblx0ICAgICAgICAgICAgdGhpcy5leHBlY3RKU1goJzonKTtcclxuXHQgICAgICAgICAgICB2YXIgbmFtZV8yID0gdGhpcy5wYXJzZUpTWElkZW50aWZpZXIoKTtcclxuXHQgICAgICAgICAgICBhdHRyaWJ1dGVOYW1lID0gdGhpcy5maW5hbGl6ZShub2RlLCBuZXcgSlNYTm9kZS5KU1hOYW1lc3BhY2VkTmFtZShuYW1lc3BhY2UsIG5hbWVfMikpO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgZWxzZSB7XHJcblx0ICAgICAgICAgICAgYXR0cmlidXRlTmFtZSA9IGlkZW50aWZpZXI7XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICByZXR1cm4gYXR0cmlidXRlTmFtZTtcclxuXHQgICAgfTtcclxuXHQgICAgSlNYUGFyc2VyLnByb3RvdHlwZS5wYXJzZUpTWFN0cmluZ0xpdGVyYWxBdHRyaWJ1dGUgPSBmdW5jdGlvbiAoKSB7XHJcblx0ICAgICAgICB2YXIgbm9kZSA9IHRoaXMuY3JlYXRlSlNYTm9kZSgpO1xyXG5cdCAgICAgICAgdmFyIHRva2VuID0gdGhpcy5uZXh0SlNYVG9rZW4oKTtcclxuXHQgICAgICAgIGlmICh0b2tlbi50eXBlICE9PSA4IC8qIFN0cmluZ0xpdGVyYWwgKi8pIHtcclxuXHQgICAgICAgICAgICB0aGlzLnRocm93VW5leHBlY3RlZFRva2VuKHRva2VuKTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIHZhciByYXcgPSB0aGlzLmdldFRva2VuUmF3KHRva2VuKTtcclxuXHQgICAgICAgIHJldHVybiB0aGlzLmZpbmFsaXplKG5vZGUsIG5ldyBOb2RlLkxpdGVyYWwodG9rZW4udmFsdWUsIHJhdykpO1xyXG5cdCAgICB9O1xyXG5cdCAgICBKU1hQYXJzZXIucHJvdG90eXBlLnBhcnNlSlNYRXhwcmVzc2lvbkF0dHJpYnV0ZSA9IGZ1bmN0aW9uICgpIHtcclxuXHQgICAgICAgIHZhciBub2RlID0gdGhpcy5jcmVhdGVKU1hOb2RlKCk7XHJcblx0ICAgICAgICB0aGlzLmV4cGVjdEpTWCgneycpO1xyXG5cdCAgICAgICAgdGhpcy5maW5pc2hKU1goKTtcclxuXHQgICAgICAgIGlmICh0aGlzLm1hdGNoKCd9JykpIHtcclxuXHQgICAgICAgICAgICB0aGlzLnRvbGVyYXRlRXJyb3IoJ0pTWCBhdHRyaWJ1dGVzIG11c3Qgb25seSBiZSBhc3NpZ25lZCBhIG5vbi1lbXB0eSBleHByZXNzaW9uJyk7XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICB2YXIgZXhwcmVzc2lvbiA9IHRoaXMucGFyc2VBc3NpZ25tZW50RXhwcmVzc2lvbigpO1xyXG5cdCAgICAgICAgdGhpcy5yZWVudGVySlNYKCk7XHJcblx0ICAgICAgICByZXR1cm4gdGhpcy5maW5hbGl6ZShub2RlLCBuZXcgSlNYTm9kZS5KU1hFeHByZXNzaW9uQ29udGFpbmVyKGV4cHJlc3Npb24pKTtcclxuXHQgICAgfTtcclxuXHQgICAgSlNYUGFyc2VyLnByb3RvdHlwZS5wYXJzZUpTWEF0dHJpYnV0ZVZhbHVlID0gZnVuY3Rpb24gKCkge1xyXG5cdCAgICAgICAgcmV0dXJuIHRoaXMubWF0Y2hKU1goJ3snKSA/IHRoaXMucGFyc2VKU1hFeHByZXNzaW9uQXR0cmlidXRlKCkgOlxyXG5cdCAgICAgICAgICAgIHRoaXMubWF0Y2hKU1goJzwnKSA/IHRoaXMucGFyc2VKU1hFbGVtZW50KCkgOiB0aGlzLnBhcnNlSlNYU3RyaW5nTGl0ZXJhbEF0dHJpYnV0ZSgpO1xyXG5cdCAgICB9O1xyXG5cdCAgICBKU1hQYXJzZXIucHJvdG90eXBlLnBhcnNlSlNYTmFtZVZhbHVlQXR0cmlidXRlID0gZnVuY3Rpb24gKCkge1xyXG5cdCAgICAgICAgdmFyIG5vZGUgPSB0aGlzLmNyZWF0ZUpTWE5vZGUoKTtcclxuXHQgICAgICAgIHZhciBuYW1lID0gdGhpcy5wYXJzZUpTWEF0dHJpYnV0ZU5hbWUoKTtcclxuXHQgICAgICAgIHZhciB2YWx1ZSA9IG51bGw7XHJcblx0ICAgICAgICBpZiAodGhpcy5tYXRjaEpTWCgnPScpKSB7XHJcblx0ICAgICAgICAgICAgdGhpcy5leHBlY3RKU1goJz0nKTtcclxuXHQgICAgICAgICAgICB2YWx1ZSA9IHRoaXMucGFyc2VKU1hBdHRyaWJ1dGVWYWx1ZSgpO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgcmV0dXJuIHRoaXMuZmluYWxpemUobm9kZSwgbmV3IEpTWE5vZGUuSlNYQXR0cmlidXRlKG5hbWUsIHZhbHVlKSk7XHJcblx0ICAgIH07XHJcblx0ICAgIEpTWFBhcnNlci5wcm90b3R5cGUucGFyc2VKU1hTcHJlYWRBdHRyaWJ1dGUgPSBmdW5jdGlvbiAoKSB7XHJcblx0ICAgICAgICB2YXIgbm9kZSA9IHRoaXMuY3JlYXRlSlNYTm9kZSgpO1xyXG5cdCAgICAgICAgdGhpcy5leHBlY3RKU1goJ3snKTtcclxuXHQgICAgICAgIHRoaXMuZXhwZWN0SlNYKCcuLi4nKTtcclxuXHQgICAgICAgIHRoaXMuZmluaXNoSlNYKCk7XHJcblx0ICAgICAgICB2YXIgYXJndW1lbnQgPSB0aGlzLnBhcnNlQXNzaWdubWVudEV4cHJlc3Npb24oKTtcclxuXHQgICAgICAgIHRoaXMucmVlbnRlckpTWCgpO1xyXG5cdCAgICAgICAgcmV0dXJuIHRoaXMuZmluYWxpemUobm9kZSwgbmV3IEpTWE5vZGUuSlNYU3ByZWFkQXR0cmlidXRlKGFyZ3VtZW50KSk7XHJcblx0ICAgIH07XHJcblx0ICAgIEpTWFBhcnNlci5wcm90b3R5cGUucGFyc2VKU1hBdHRyaWJ1dGVzID0gZnVuY3Rpb24gKCkge1xyXG5cdCAgICAgICAgdmFyIGF0dHJpYnV0ZXMgPSBbXTtcclxuXHQgICAgICAgIHdoaWxlICghdGhpcy5tYXRjaEpTWCgnLycpICYmICF0aGlzLm1hdGNoSlNYKCc+JykpIHtcclxuXHQgICAgICAgICAgICB2YXIgYXR0cmlidXRlID0gdGhpcy5tYXRjaEpTWCgneycpID8gdGhpcy5wYXJzZUpTWFNwcmVhZEF0dHJpYnV0ZSgpIDpcclxuXHQgICAgICAgICAgICAgICAgdGhpcy5wYXJzZUpTWE5hbWVWYWx1ZUF0dHJpYnV0ZSgpO1xyXG5cdCAgICAgICAgICAgIGF0dHJpYnV0ZXMucHVzaChhdHRyaWJ1dGUpO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgcmV0dXJuIGF0dHJpYnV0ZXM7XHJcblx0ICAgIH07XHJcblx0ICAgIEpTWFBhcnNlci5wcm90b3R5cGUucGFyc2VKU1hPcGVuaW5nRWxlbWVudCA9IGZ1bmN0aW9uICgpIHtcclxuXHQgICAgICAgIHZhciBub2RlID0gdGhpcy5jcmVhdGVKU1hOb2RlKCk7XHJcblx0ICAgICAgICB0aGlzLmV4cGVjdEpTWCgnPCcpO1xyXG5cdCAgICAgICAgdmFyIG5hbWUgPSB0aGlzLnBhcnNlSlNYRWxlbWVudE5hbWUoKTtcclxuXHQgICAgICAgIHZhciBhdHRyaWJ1dGVzID0gdGhpcy5wYXJzZUpTWEF0dHJpYnV0ZXMoKTtcclxuXHQgICAgICAgIHZhciBzZWxmQ2xvc2luZyA9IHRoaXMubWF0Y2hKU1goJy8nKTtcclxuXHQgICAgICAgIGlmIChzZWxmQ2xvc2luZykge1xyXG5cdCAgICAgICAgICAgIHRoaXMuZXhwZWN0SlNYKCcvJyk7XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICB0aGlzLmV4cGVjdEpTWCgnPicpO1xyXG5cdCAgICAgICAgcmV0dXJuIHRoaXMuZmluYWxpemUobm9kZSwgbmV3IEpTWE5vZGUuSlNYT3BlbmluZ0VsZW1lbnQobmFtZSwgc2VsZkNsb3NpbmcsIGF0dHJpYnV0ZXMpKTtcclxuXHQgICAgfTtcclxuXHQgICAgSlNYUGFyc2VyLnByb3RvdHlwZS5wYXJzZUpTWEJvdW5kYXJ5RWxlbWVudCA9IGZ1bmN0aW9uICgpIHtcclxuXHQgICAgICAgIHZhciBub2RlID0gdGhpcy5jcmVhdGVKU1hOb2RlKCk7XHJcblx0ICAgICAgICB0aGlzLmV4cGVjdEpTWCgnPCcpO1xyXG5cdCAgICAgICAgaWYgKHRoaXMubWF0Y2hKU1goJy8nKSkge1xyXG5cdCAgICAgICAgICAgIHRoaXMuZXhwZWN0SlNYKCcvJyk7XHJcblx0ICAgICAgICAgICAgdmFyIG5hbWVfMyA9IHRoaXMucGFyc2VKU1hFbGVtZW50TmFtZSgpO1xyXG5cdCAgICAgICAgICAgIHRoaXMuZXhwZWN0SlNYKCc+Jyk7XHJcblx0ICAgICAgICAgICAgcmV0dXJuIHRoaXMuZmluYWxpemUobm9kZSwgbmV3IEpTWE5vZGUuSlNYQ2xvc2luZ0VsZW1lbnQobmFtZV8zKSk7XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICB2YXIgbmFtZSA9IHRoaXMucGFyc2VKU1hFbGVtZW50TmFtZSgpO1xyXG5cdCAgICAgICAgdmFyIGF0dHJpYnV0ZXMgPSB0aGlzLnBhcnNlSlNYQXR0cmlidXRlcygpO1xyXG5cdCAgICAgICAgdmFyIHNlbGZDbG9zaW5nID0gdGhpcy5tYXRjaEpTWCgnLycpO1xyXG5cdCAgICAgICAgaWYgKHNlbGZDbG9zaW5nKSB7XHJcblx0ICAgICAgICAgICAgdGhpcy5leHBlY3RKU1goJy8nKTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIHRoaXMuZXhwZWN0SlNYKCc+Jyk7XHJcblx0ICAgICAgICByZXR1cm4gdGhpcy5maW5hbGl6ZShub2RlLCBuZXcgSlNYTm9kZS5KU1hPcGVuaW5nRWxlbWVudChuYW1lLCBzZWxmQ2xvc2luZywgYXR0cmlidXRlcykpO1xyXG5cdCAgICB9O1xyXG5cdCAgICBKU1hQYXJzZXIucHJvdG90eXBlLnBhcnNlSlNYRW1wdHlFeHByZXNzaW9uID0gZnVuY3Rpb24gKCkge1xyXG5cdCAgICAgICAgdmFyIG5vZGUgPSB0aGlzLmNyZWF0ZUpTWENoaWxkTm9kZSgpO1xyXG5cdCAgICAgICAgdGhpcy5jb2xsZWN0Q29tbWVudHMoKTtcclxuXHQgICAgICAgIHRoaXMubGFzdE1hcmtlci5pbmRleCA9IHRoaXMuc2Nhbm5lci5pbmRleDtcclxuXHQgICAgICAgIHRoaXMubGFzdE1hcmtlci5saW5lID0gdGhpcy5zY2FubmVyLmxpbmVOdW1iZXI7XHJcblx0ICAgICAgICB0aGlzLmxhc3RNYXJrZXIuY29sdW1uID0gdGhpcy5zY2FubmVyLmluZGV4IC0gdGhpcy5zY2FubmVyLmxpbmVTdGFydDtcclxuXHQgICAgICAgIHJldHVybiB0aGlzLmZpbmFsaXplKG5vZGUsIG5ldyBKU1hOb2RlLkpTWEVtcHR5RXhwcmVzc2lvbigpKTtcclxuXHQgICAgfTtcclxuXHQgICAgSlNYUGFyc2VyLnByb3RvdHlwZS5wYXJzZUpTWEV4cHJlc3Npb25Db250YWluZXIgPSBmdW5jdGlvbiAoKSB7XHJcblx0ICAgICAgICB2YXIgbm9kZSA9IHRoaXMuY3JlYXRlSlNYTm9kZSgpO1xyXG5cdCAgICAgICAgdGhpcy5leHBlY3RKU1goJ3snKTtcclxuXHQgICAgICAgIHZhciBleHByZXNzaW9uO1xyXG5cdCAgICAgICAgaWYgKHRoaXMubWF0Y2hKU1goJ30nKSkge1xyXG5cdCAgICAgICAgICAgIGV4cHJlc3Npb24gPSB0aGlzLnBhcnNlSlNYRW1wdHlFeHByZXNzaW9uKCk7XHJcblx0ICAgICAgICAgICAgdGhpcy5leHBlY3RKU1goJ30nKTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIGVsc2Uge1xyXG5cdCAgICAgICAgICAgIHRoaXMuZmluaXNoSlNYKCk7XHJcblx0ICAgICAgICAgICAgZXhwcmVzc2lvbiA9IHRoaXMucGFyc2VBc3NpZ25tZW50RXhwcmVzc2lvbigpO1xyXG5cdCAgICAgICAgICAgIHRoaXMucmVlbnRlckpTWCgpO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgcmV0dXJuIHRoaXMuZmluYWxpemUobm9kZSwgbmV3IEpTWE5vZGUuSlNYRXhwcmVzc2lvbkNvbnRhaW5lcihleHByZXNzaW9uKSk7XHJcblx0ICAgIH07XHJcblx0ICAgIEpTWFBhcnNlci5wcm90b3R5cGUucGFyc2VKU1hDaGlsZHJlbiA9IGZ1bmN0aW9uICgpIHtcclxuXHQgICAgICAgIHZhciBjaGlsZHJlbiA9IFtdO1xyXG5cdCAgICAgICAgd2hpbGUgKCF0aGlzLnNjYW5uZXIuZW9mKCkpIHtcclxuXHQgICAgICAgICAgICB2YXIgbm9kZSA9IHRoaXMuY3JlYXRlSlNYQ2hpbGROb2RlKCk7XHJcblx0ICAgICAgICAgICAgdmFyIHRva2VuID0gdGhpcy5uZXh0SlNYVGV4dCgpO1xyXG5cdCAgICAgICAgICAgIGlmICh0b2tlbi5zdGFydCA8IHRva2VuLmVuZCkge1xyXG5cdCAgICAgICAgICAgICAgICB2YXIgcmF3ID0gdGhpcy5nZXRUb2tlblJhdyh0b2tlbik7XHJcblx0ICAgICAgICAgICAgICAgIHZhciBjaGlsZCA9IHRoaXMuZmluYWxpemUobm9kZSwgbmV3IEpTWE5vZGUuSlNYVGV4dCh0b2tlbi52YWx1ZSwgcmF3KSk7XHJcblx0ICAgICAgICAgICAgICAgIGNoaWxkcmVuLnB1c2goY2hpbGQpO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICBpZiAodGhpcy5zY2FubmVyLnNvdXJjZVt0aGlzLnNjYW5uZXIuaW5kZXhdID09PSAneycpIHtcclxuXHQgICAgICAgICAgICAgICAgdmFyIGNvbnRhaW5lciA9IHRoaXMucGFyc2VKU1hFeHByZXNzaW9uQ29udGFpbmVyKCk7XHJcblx0ICAgICAgICAgICAgICAgIGNoaWxkcmVuLnB1c2goY29udGFpbmVyKTtcclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgZWxzZSB7XHJcblx0ICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIHJldHVybiBjaGlsZHJlbjtcclxuXHQgICAgfTtcclxuXHQgICAgSlNYUGFyc2VyLnByb3RvdHlwZS5wYXJzZUNvbXBsZXhKU1hFbGVtZW50ID0gZnVuY3Rpb24gKGVsKSB7XHJcblx0ICAgICAgICB2YXIgc3RhY2sgPSBbXTtcclxuXHQgICAgICAgIHdoaWxlICghdGhpcy5zY2FubmVyLmVvZigpKSB7XHJcblx0ICAgICAgICAgICAgZWwuY2hpbGRyZW4gPSBlbC5jaGlsZHJlbi5jb25jYXQodGhpcy5wYXJzZUpTWENoaWxkcmVuKCkpO1xyXG5cdCAgICAgICAgICAgIHZhciBub2RlID0gdGhpcy5jcmVhdGVKU1hDaGlsZE5vZGUoKTtcclxuXHQgICAgICAgICAgICB2YXIgZWxlbWVudCA9IHRoaXMucGFyc2VKU1hCb3VuZGFyeUVsZW1lbnQoKTtcclxuXHQgICAgICAgICAgICBpZiAoZWxlbWVudC50eXBlID09PSBqc3hfc3ludGF4XzEuSlNYU3ludGF4LkpTWE9wZW5pbmdFbGVtZW50KSB7XHJcblx0ICAgICAgICAgICAgICAgIHZhciBvcGVuaW5nID0gZWxlbWVudDtcclxuXHQgICAgICAgICAgICAgICAgaWYgKG9wZW5pbmcuc2VsZkNsb3NpbmcpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgIHZhciBjaGlsZCA9IHRoaXMuZmluYWxpemUobm9kZSwgbmV3IEpTWE5vZGUuSlNYRWxlbWVudChvcGVuaW5nLCBbXSwgbnVsbCkpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgZWwuY2hpbGRyZW4ucHVzaChjaGlsZCk7XHJcblx0ICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgZWxzZSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICBzdGFjay5wdXNoKGVsKTtcclxuXHQgICAgICAgICAgICAgICAgICAgIGVsID0geyBub2RlOiBub2RlLCBvcGVuaW5nOiBvcGVuaW5nLCBjbG9zaW5nOiBudWxsLCBjaGlsZHJlbjogW10gfTtcclxuXHQgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICBpZiAoZWxlbWVudC50eXBlID09PSBqc3hfc3ludGF4XzEuSlNYU3ludGF4LkpTWENsb3NpbmdFbGVtZW50KSB7XHJcblx0ICAgICAgICAgICAgICAgIGVsLmNsb3NpbmcgPSBlbGVtZW50O1xyXG5cdCAgICAgICAgICAgICAgICB2YXIgb3Blbl8xID0gZ2V0UXVhbGlmaWVkRWxlbWVudE5hbWUoZWwub3BlbmluZy5uYW1lKTtcclxuXHQgICAgICAgICAgICAgICAgdmFyIGNsb3NlXzEgPSBnZXRRdWFsaWZpZWRFbGVtZW50TmFtZShlbC5jbG9zaW5nLm5hbWUpO1xyXG5cdCAgICAgICAgICAgICAgICBpZiAob3Blbl8xICE9PSBjbG9zZV8xKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICB0aGlzLnRvbGVyYXRlRXJyb3IoJ0V4cGVjdGVkIGNvcnJlc3BvbmRpbmcgSlNYIGNsb3NpbmcgdGFnIGZvciAlMCcsIG9wZW5fMSk7XHJcblx0ICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgaWYgKHN0YWNrLmxlbmd0aCA+IDApIHtcclxuXHQgICAgICAgICAgICAgICAgICAgIHZhciBjaGlsZCA9IHRoaXMuZmluYWxpemUoZWwubm9kZSwgbmV3IEpTWE5vZGUuSlNYRWxlbWVudChlbC5vcGVuaW5nLCBlbC5jaGlsZHJlbiwgZWwuY2xvc2luZykpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgZWwgPSBzdGFja1tzdGFjay5sZW5ndGggLSAxXTtcclxuXHQgICAgICAgICAgICAgICAgICAgIGVsLmNoaWxkcmVuLnB1c2goY2hpbGQpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgc3RhY2sucG9wKCk7XHJcblx0ICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgZWxzZSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuXHQgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIHJldHVybiBlbDtcclxuXHQgICAgfTtcclxuXHQgICAgSlNYUGFyc2VyLnByb3RvdHlwZS5wYXJzZUpTWEVsZW1lbnQgPSBmdW5jdGlvbiAoKSB7XHJcblx0ICAgICAgICB2YXIgbm9kZSA9IHRoaXMuY3JlYXRlSlNYTm9kZSgpO1xyXG5cdCAgICAgICAgdmFyIG9wZW5pbmcgPSB0aGlzLnBhcnNlSlNYT3BlbmluZ0VsZW1lbnQoKTtcclxuXHQgICAgICAgIHZhciBjaGlsZHJlbiA9IFtdO1xyXG5cdCAgICAgICAgdmFyIGNsb3NpbmcgPSBudWxsO1xyXG5cdCAgICAgICAgaWYgKCFvcGVuaW5nLnNlbGZDbG9zaW5nKSB7XHJcblx0ICAgICAgICAgICAgdmFyIGVsID0gdGhpcy5wYXJzZUNvbXBsZXhKU1hFbGVtZW50KHsgbm9kZTogbm9kZSwgb3BlbmluZzogb3BlbmluZywgY2xvc2luZzogY2xvc2luZywgY2hpbGRyZW46IGNoaWxkcmVuIH0pO1xyXG5cdCAgICAgICAgICAgIGNoaWxkcmVuID0gZWwuY2hpbGRyZW47XHJcblx0ICAgICAgICAgICAgY2xvc2luZyA9IGVsLmNsb3Npbmc7XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICByZXR1cm4gdGhpcy5maW5hbGl6ZShub2RlLCBuZXcgSlNYTm9kZS5KU1hFbGVtZW50KG9wZW5pbmcsIGNoaWxkcmVuLCBjbG9zaW5nKSk7XHJcblx0ICAgIH07XHJcblx0ICAgIEpTWFBhcnNlci5wcm90b3R5cGUucGFyc2VKU1hSb290ID0gZnVuY3Rpb24gKCkge1xyXG5cdCAgICAgICAgLy8gUG9wIHRoZSBvcGVuaW5nICc8JyBhZGRlZCBmcm9tIHRoZSBsb29rYWhlYWQuXHJcblx0ICAgICAgICBpZiAodGhpcy5jb25maWcudG9rZW5zKSB7XHJcblx0ICAgICAgICAgICAgdGhpcy50b2tlbnMucG9wKCk7XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICB0aGlzLnN0YXJ0SlNYKCk7XHJcblx0ICAgICAgICB2YXIgZWxlbWVudCA9IHRoaXMucGFyc2VKU1hFbGVtZW50KCk7XHJcblx0ICAgICAgICB0aGlzLmZpbmlzaEpTWCgpO1xyXG5cdCAgICAgICAgcmV0dXJuIGVsZW1lbnQ7XHJcblx0ICAgIH07XHJcblx0ICAgIEpTWFBhcnNlci5wcm90b3R5cGUuaXNTdGFydE9mRXhwcmVzc2lvbiA9IGZ1bmN0aW9uICgpIHtcclxuXHQgICAgICAgIHJldHVybiBfc3VwZXIucHJvdG90eXBlLmlzU3RhcnRPZkV4cHJlc3Npb24uY2FsbCh0aGlzKSB8fCB0aGlzLm1hdGNoKCc8Jyk7XHJcblx0ICAgIH07XHJcblx0ICAgIHJldHVybiBKU1hQYXJzZXI7XHJcblx0fShwYXJzZXJfMS5QYXJzZXIpKTtcclxuXHRleHBvcnRzLkpTWFBhcnNlciA9IEpTWFBhcnNlcjtcclxuXG5cbi8qKiovIH0sXG4vKiA0ICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxuXHRcInVzZSBzdHJpY3RcIjtcclxuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcblx0Ly8gU2VlIGFsc28gdG9vbHMvZ2VuZXJhdGUtdW5pY29kZS1yZWdleC5qcy5cclxuXHR2YXIgUmVnZXggPSB7XHJcblx0ICAgIC8vIFVuaWNvZGUgdjguMC4wIE5vbkFzY2lpSWRlbnRpZmllclN0YXJ0OlxyXG5cdCAgICBOb25Bc2NpaUlkZW50aWZpZXJTdGFydDogL1tcXHhBQVxceEI1XFx4QkFcXHhDMC1cXHhENlxceEQ4LVxceEY2XFx4RjgtXFx1MDJDMVxcdTAyQzYtXFx1MDJEMVxcdTAyRTAtXFx1MDJFNFxcdTAyRUNcXHUwMkVFXFx1MDM3MC1cXHUwMzc0XFx1MDM3NlxcdTAzNzdcXHUwMzdBLVxcdTAzN0RcXHUwMzdGXFx1MDM4NlxcdTAzODgtXFx1MDM4QVxcdTAzOENcXHUwMzhFLVxcdTAzQTFcXHUwM0EzLVxcdTAzRjVcXHUwM0Y3LVxcdTA0ODFcXHUwNDhBLVxcdTA1MkZcXHUwNTMxLVxcdTA1NTZcXHUwNTU5XFx1MDU2MS1cXHUwNTg3XFx1MDVEMC1cXHUwNUVBXFx1MDVGMC1cXHUwNUYyXFx1MDYyMC1cXHUwNjRBXFx1MDY2RVxcdTA2NkZcXHUwNjcxLVxcdTA2RDNcXHUwNkQ1XFx1MDZFNVxcdTA2RTZcXHUwNkVFXFx1MDZFRlxcdTA2RkEtXFx1MDZGQ1xcdTA2RkZcXHUwNzEwXFx1MDcxMi1cXHUwNzJGXFx1MDc0RC1cXHUwN0E1XFx1MDdCMVxcdTA3Q0EtXFx1MDdFQVxcdTA3RjRcXHUwN0Y1XFx1MDdGQVxcdTA4MDAtXFx1MDgxNVxcdTA4MUFcXHUwODI0XFx1MDgyOFxcdTA4NDAtXFx1MDg1OFxcdTA4QTAtXFx1MDhCNFxcdTA5MDQtXFx1MDkzOVxcdTA5M0RcXHUwOTUwXFx1MDk1OC1cXHUwOTYxXFx1MDk3MS1cXHUwOTgwXFx1MDk4NS1cXHUwOThDXFx1MDk4RlxcdTA5OTBcXHUwOTkzLVxcdTA5QThcXHUwOUFBLVxcdTA5QjBcXHUwOUIyXFx1MDlCNi1cXHUwOUI5XFx1MDlCRFxcdTA5Q0VcXHUwOURDXFx1MDlERFxcdTA5REYtXFx1MDlFMVxcdTA5RjBcXHUwOUYxXFx1MEEwNS1cXHUwQTBBXFx1MEEwRlxcdTBBMTBcXHUwQTEzLVxcdTBBMjhcXHUwQTJBLVxcdTBBMzBcXHUwQTMyXFx1MEEzM1xcdTBBMzVcXHUwQTM2XFx1MEEzOFxcdTBBMzlcXHUwQTU5LVxcdTBBNUNcXHUwQTVFXFx1MEE3Mi1cXHUwQTc0XFx1MEE4NS1cXHUwQThEXFx1MEE4Ri1cXHUwQTkxXFx1MEE5My1cXHUwQUE4XFx1MEFBQS1cXHUwQUIwXFx1MEFCMlxcdTBBQjNcXHUwQUI1LVxcdTBBQjlcXHUwQUJEXFx1MEFEMFxcdTBBRTBcXHUwQUUxXFx1MEFGOVxcdTBCMDUtXFx1MEIwQ1xcdTBCMEZcXHUwQjEwXFx1MEIxMy1cXHUwQjI4XFx1MEIyQS1cXHUwQjMwXFx1MEIzMlxcdTBCMzNcXHUwQjM1LVxcdTBCMzlcXHUwQjNEXFx1MEI1Q1xcdTBCNURcXHUwQjVGLVxcdTBCNjFcXHUwQjcxXFx1MEI4M1xcdTBCODUtXFx1MEI4QVxcdTBCOEUtXFx1MEI5MFxcdTBCOTItXFx1MEI5NVxcdTBCOTlcXHUwQjlBXFx1MEI5Q1xcdTBCOUVcXHUwQjlGXFx1MEJBM1xcdTBCQTRcXHUwQkE4LVxcdTBCQUFcXHUwQkFFLVxcdTBCQjlcXHUwQkQwXFx1MEMwNS1cXHUwQzBDXFx1MEMwRS1cXHUwQzEwXFx1MEMxMi1cXHUwQzI4XFx1MEMyQS1cXHUwQzM5XFx1MEMzRFxcdTBDNTgtXFx1MEM1QVxcdTBDNjBcXHUwQzYxXFx1MEM4NS1cXHUwQzhDXFx1MEM4RS1cXHUwQzkwXFx1MEM5Mi1cXHUwQ0E4XFx1MENBQS1cXHUwQ0IzXFx1MENCNS1cXHUwQ0I5XFx1MENCRFxcdTBDREVcXHUwQ0UwXFx1MENFMVxcdTBDRjFcXHUwQ0YyXFx1MEQwNS1cXHUwRDBDXFx1MEQwRS1cXHUwRDEwXFx1MEQxMi1cXHUwRDNBXFx1MEQzRFxcdTBENEVcXHUwRDVGLVxcdTBENjFcXHUwRDdBLVxcdTBEN0ZcXHUwRDg1LVxcdTBEOTZcXHUwRDlBLVxcdTBEQjFcXHUwREIzLVxcdTBEQkJcXHUwREJEXFx1MERDMC1cXHUwREM2XFx1MEUwMS1cXHUwRTMwXFx1MEUzMlxcdTBFMzNcXHUwRTQwLVxcdTBFNDZcXHUwRTgxXFx1MEU4MlxcdTBFODRcXHUwRTg3XFx1MEU4OFxcdTBFOEFcXHUwRThEXFx1MEU5NC1cXHUwRTk3XFx1MEU5OS1cXHUwRTlGXFx1MEVBMS1cXHUwRUEzXFx1MEVBNVxcdTBFQTdcXHUwRUFBXFx1MEVBQlxcdTBFQUQtXFx1MEVCMFxcdTBFQjJcXHUwRUIzXFx1MEVCRFxcdTBFQzAtXFx1MEVDNFxcdTBFQzZcXHUwRURDLVxcdTBFREZcXHUwRjAwXFx1MEY0MC1cXHUwRjQ3XFx1MEY0OS1cXHUwRjZDXFx1MEY4OC1cXHUwRjhDXFx1MTAwMC1cXHUxMDJBXFx1MTAzRlxcdTEwNTAtXFx1MTA1NVxcdTEwNUEtXFx1MTA1RFxcdTEwNjFcXHUxMDY1XFx1MTA2NlxcdTEwNkUtXFx1MTA3MFxcdTEwNzUtXFx1MTA4MVxcdTEwOEVcXHUxMEEwLVxcdTEwQzVcXHUxMEM3XFx1MTBDRFxcdTEwRDAtXFx1MTBGQVxcdTEwRkMtXFx1MTI0OFxcdTEyNEEtXFx1MTI0RFxcdTEyNTAtXFx1MTI1NlxcdTEyNThcXHUxMjVBLVxcdTEyNURcXHUxMjYwLVxcdTEyODhcXHUxMjhBLVxcdTEyOERcXHUxMjkwLVxcdTEyQjBcXHUxMkIyLVxcdTEyQjVcXHUxMkI4LVxcdTEyQkVcXHUxMkMwXFx1MTJDMi1cXHUxMkM1XFx1MTJDOC1cXHUxMkQ2XFx1MTJEOC1cXHUxMzEwXFx1MTMxMi1cXHUxMzE1XFx1MTMxOC1cXHUxMzVBXFx1MTM4MC1cXHUxMzhGXFx1MTNBMC1cXHUxM0Y1XFx1MTNGOC1cXHUxM0ZEXFx1MTQwMS1cXHUxNjZDXFx1MTY2Ri1cXHUxNjdGXFx1MTY4MS1cXHUxNjlBXFx1MTZBMC1cXHUxNkVBXFx1MTZFRS1cXHUxNkY4XFx1MTcwMC1cXHUxNzBDXFx1MTcwRS1cXHUxNzExXFx1MTcyMC1cXHUxNzMxXFx1MTc0MC1cXHUxNzUxXFx1MTc2MC1cXHUxNzZDXFx1MTc2RS1cXHUxNzcwXFx1MTc4MC1cXHUxN0IzXFx1MTdEN1xcdTE3RENcXHUxODIwLVxcdTE4NzdcXHUxODgwLVxcdTE4QThcXHUxOEFBXFx1MThCMC1cXHUxOEY1XFx1MTkwMC1cXHUxOTFFXFx1MTk1MC1cXHUxOTZEXFx1MTk3MC1cXHUxOTc0XFx1MTk4MC1cXHUxOUFCXFx1MTlCMC1cXHUxOUM5XFx1MUEwMC1cXHUxQTE2XFx1MUEyMC1cXHUxQTU0XFx1MUFBN1xcdTFCMDUtXFx1MUIzM1xcdTFCNDUtXFx1MUI0QlxcdTFCODMtXFx1MUJBMFxcdTFCQUVcXHUxQkFGXFx1MUJCQS1cXHUxQkU1XFx1MUMwMC1cXHUxQzIzXFx1MUM0RC1cXHUxQzRGXFx1MUM1QS1cXHUxQzdEXFx1MUNFOS1cXHUxQ0VDXFx1MUNFRS1cXHUxQ0YxXFx1MUNGNVxcdTFDRjZcXHUxRDAwLVxcdTFEQkZcXHUxRTAwLVxcdTFGMTVcXHUxRjE4LVxcdTFGMURcXHUxRjIwLVxcdTFGNDVcXHUxRjQ4LVxcdTFGNERcXHUxRjUwLVxcdTFGNTdcXHUxRjU5XFx1MUY1QlxcdTFGNURcXHUxRjVGLVxcdTFGN0RcXHUxRjgwLVxcdTFGQjRcXHUxRkI2LVxcdTFGQkNcXHUxRkJFXFx1MUZDMi1cXHUxRkM0XFx1MUZDNi1cXHUxRkNDXFx1MUZEMC1cXHUxRkQzXFx1MUZENi1cXHUxRkRCXFx1MUZFMC1cXHUxRkVDXFx1MUZGMi1cXHUxRkY0XFx1MUZGNi1cXHUxRkZDXFx1MjA3MVxcdTIwN0ZcXHUyMDkwLVxcdTIwOUNcXHUyMTAyXFx1MjEwN1xcdTIxMEEtXFx1MjExM1xcdTIxMTVcXHUyMTE4LVxcdTIxMURcXHUyMTI0XFx1MjEyNlxcdTIxMjhcXHUyMTJBLVxcdTIxMzlcXHUyMTNDLVxcdTIxM0ZcXHUyMTQ1LVxcdTIxNDlcXHUyMTRFXFx1MjE2MC1cXHUyMTg4XFx1MkMwMC1cXHUyQzJFXFx1MkMzMC1cXHUyQzVFXFx1MkM2MC1cXHUyQ0U0XFx1MkNFQi1cXHUyQ0VFXFx1MkNGMlxcdTJDRjNcXHUyRDAwLVxcdTJEMjVcXHUyRDI3XFx1MkQyRFxcdTJEMzAtXFx1MkQ2N1xcdTJENkZcXHUyRDgwLVxcdTJEOTZcXHUyREEwLVxcdTJEQTZcXHUyREE4LVxcdTJEQUVcXHUyREIwLVxcdTJEQjZcXHUyREI4LVxcdTJEQkVcXHUyREMwLVxcdTJEQzZcXHUyREM4LVxcdTJEQ0VcXHUyREQwLVxcdTJERDZcXHUyREQ4LVxcdTJEREVcXHUzMDA1LVxcdTMwMDdcXHUzMDIxLVxcdTMwMjlcXHUzMDMxLVxcdTMwMzVcXHUzMDM4LVxcdTMwM0NcXHUzMDQxLVxcdTMwOTZcXHUzMDlCLVxcdTMwOUZcXHUzMEExLVxcdTMwRkFcXHUzMEZDLVxcdTMwRkZcXHUzMTA1LVxcdTMxMkRcXHUzMTMxLVxcdTMxOEVcXHUzMUEwLVxcdTMxQkFcXHUzMUYwLVxcdTMxRkZcXHUzNDAwLVxcdTREQjVcXHU0RTAwLVxcdTlGRDVcXHVBMDAwLVxcdUE0OENcXHVBNEQwLVxcdUE0RkRcXHVBNTAwLVxcdUE2MENcXHVBNjEwLVxcdUE2MUZcXHVBNjJBXFx1QTYyQlxcdUE2NDAtXFx1QTY2RVxcdUE2N0YtXFx1QTY5RFxcdUE2QTAtXFx1QTZFRlxcdUE3MTctXFx1QTcxRlxcdUE3MjItXFx1QTc4OFxcdUE3OEItXFx1QTdBRFxcdUE3QjAtXFx1QTdCN1xcdUE3RjctXFx1QTgwMVxcdUE4MDMtXFx1QTgwNVxcdUE4MDctXFx1QTgwQVxcdUE4MEMtXFx1QTgyMlxcdUE4NDAtXFx1QTg3M1xcdUE4ODItXFx1QThCM1xcdUE4RjItXFx1QThGN1xcdUE4RkJcXHVBOEZEXFx1QTkwQS1cXHVBOTI1XFx1QTkzMC1cXHVBOTQ2XFx1QTk2MC1cXHVBOTdDXFx1QTk4NC1cXHVBOUIyXFx1QTlDRlxcdUE5RTAtXFx1QTlFNFxcdUE5RTYtXFx1QTlFRlxcdUE5RkEtXFx1QTlGRVxcdUFBMDAtXFx1QUEyOFxcdUFBNDAtXFx1QUE0MlxcdUFBNDQtXFx1QUE0QlxcdUFBNjAtXFx1QUE3NlxcdUFBN0FcXHVBQTdFLVxcdUFBQUZcXHVBQUIxXFx1QUFCNVxcdUFBQjZcXHVBQUI5LVxcdUFBQkRcXHVBQUMwXFx1QUFDMlxcdUFBREItXFx1QUFERFxcdUFBRTAtXFx1QUFFQVxcdUFBRjItXFx1QUFGNFxcdUFCMDEtXFx1QUIwNlxcdUFCMDktXFx1QUIwRVxcdUFCMTEtXFx1QUIxNlxcdUFCMjAtXFx1QUIyNlxcdUFCMjgtXFx1QUIyRVxcdUFCMzAtXFx1QUI1QVxcdUFCNUMtXFx1QUI2NVxcdUFCNzAtXFx1QUJFMlxcdUFDMDAtXFx1RDdBM1xcdUQ3QjAtXFx1RDdDNlxcdUQ3Q0ItXFx1RDdGQlxcdUY5MDAtXFx1RkE2RFxcdUZBNzAtXFx1RkFEOVxcdUZCMDAtXFx1RkIwNlxcdUZCMTMtXFx1RkIxN1xcdUZCMURcXHVGQjFGLVxcdUZCMjhcXHVGQjJBLVxcdUZCMzZcXHVGQjM4LVxcdUZCM0NcXHVGQjNFXFx1RkI0MFxcdUZCNDFcXHVGQjQzXFx1RkI0NFxcdUZCNDYtXFx1RkJCMVxcdUZCRDMtXFx1RkQzRFxcdUZENTAtXFx1RkQ4RlxcdUZEOTItXFx1RkRDN1xcdUZERjAtXFx1RkRGQlxcdUZFNzAtXFx1RkU3NFxcdUZFNzYtXFx1RkVGQ1xcdUZGMjEtXFx1RkYzQVxcdUZGNDEtXFx1RkY1QVxcdUZGNjYtXFx1RkZCRVxcdUZGQzItXFx1RkZDN1xcdUZGQ0EtXFx1RkZDRlxcdUZGRDItXFx1RkZEN1xcdUZGREEtXFx1RkZEQ118XFx1RDgwMFtcXHVEQzAwLVxcdURDMEJcXHVEQzBELVxcdURDMjZcXHVEQzI4LVxcdURDM0FcXHVEQzNDXFx1REMzRFxcdURDM0YtXFx1REM0RFxcdURDNTAtXFx1REM1RFxcdURDODAtXFx1RENGQVxcdURENDAtXFx1REQ3NFxcdURFODAtXFx1REU5Q1xcdURFQTAtXFx1REVEMFxcdURGMDAtXFx1REYxRlxcdURGMzAtXFx1REY0QVxcdURGNTAtXFx1REY3NVxcdURGODAtXFx1REY5RFxcdURGQTAtXFx1REZDM1xcdURGQzgtXFx1REZDRlxcdURGRDEtXFx1REZENV18XFx1RDgwMVtcXHVEQzAwLVxcdURDOURcXHVERDAwLVxcdUREMjdcXHVERDMwLVxcdURENjNcXHVERTAwLVxcdURGMzZcXHVERjQwLVxcdURGNTVcXHVERjYwLVxcdURGNjddfFxcdUQ4MDJbXFx1REMwMC1cXHVEQzA1XFx1REMwOFxcdURDMEEtXFx1REMzNVxcdURDMzdcXHVEQzM4XFx1REMzQ1xcdURDM0YtXFx1REM1NVxcdURDNjAtXFx1REM3NlxcdURDODAtXFx1REM5RVxcdURDRTAtXFx1RENGMlxcdURDRjRcXHVEQ0Y1XFx1REQwMC1cXHVERDE1XFx1REQyMC1cXHVERDM5XFx1REQ4MC1cXHVEREI3XFx1RERCRVxcdUREQkZcXHVERTAwXFx1REUxMC1cXHVERTEzXFx1REUxNS1cXHVERTE3XFx1REUxOS1cXHVERTMzXFx1REU2MC1cXHVERTdDXFx1REU4MC1cXHVERTlDXFx1REVDMC1cXHVERUM3XFx1REVDOS1cXHVERUU0XFx1REYwMC1cXHVERjM1XFx1REY0MC1cXHVERjU1XFx1REY2MC1cXHVERjcyXFx1REY4MC1cXHVERjkxXXxcXHVEODAzW1xcdURDMDAtXFx1REM0OFxcdURDODAtXFx1RENCMlxcdURDQzAtXFx1RENGMl18XFx1RDgwNFtcXHVEQzAzLVxcdURDMzdcXHVEQzgzLVxcdURDQUZcXHVEQ0QwLVxcdURDRThcXHVERDAzLVxcdUREMjZcXHVERDUwLVxcdURENzJcXHVERDc2XFx1REQ4My1cXHVEREIyXFx1RERDMS1cXHVEREM0XFx1REREQVxcdURERENcXHVERTAwLVxcdURFMTFcXHVERTEzLVxcdURFMkJcXHVERTgwLVxcdURFODZcXHVERTg4XFx1REU4QS1cXHVERThEXFx1REU4Ri1cXHVERTlEXFx1REU5Ri1cXHVERUE4XFx1REVCMC1cXHVERURFXFx1REYwNS1cXHVERjBDXFx1REYwRlxcdURGMTBcXHVERjEzLVxcdURGMjhcXHVERjJBLVxcdURGMzBcXHVERjMyXFx1REYzM1xcdURGMzUtXFx1REYzOVxcdURGM0RcXHVERjUwXFx1REY1RC1cXHVERjYxXXxcXHVEODA1W1xcdURDODAtXFx1RENBRlxcdURDQzRcXHVEQ0M1XFx1RENDN1xcdUREODAtXFx1RERBRVxcdURERDgtXFx1REREQlxcdURFMDAtXFx1REUyRlxcdURFNDRcXHVERTgwLVxcdURFQUFcXHVERjAwLVxcdURGMTldfFxcdUQ4MDZbXFx1RENBMC1cXHVEQ0RGXFx1RENGRlxcdURFQzAtXFx1REVGOF18XFx1RDgwOFtcXHVEQzAwLVxcdURGOTldfFxcdUQ4MDlbXFx1REMwMC1cXHVEQzZFXFx1REM4MC1cXHVERDQzXXxbXFx1RDgwQ1xcdUQ4NDAtXFx1RDg2OFxcdUQ4NkEtXFx1RDg2Q1xcdUQ4NkYtXFx1RDg3Ml1bXFx1REMwMC1cXHVERkZGXXxcXHVEODBEW1xcdURDMDAtXFx1REMyRV18XFx1RDgxMVtcXHVEQzAwLVxcdURFNDZdfFxcdUQ4MUFbXFx1REMwMC1cXHVERTM4XFx1REU0MC1cXHVERTVFXFx1REVEMC1cXHVERUVEXFx1REYwMC1cXHVERjJGXFx1REY0MC1cXHVERjQzXFx1REY2My1cXHVERjc3XFx1REY3RC1cXHVERjhGXXxcXHVEODFCW1xcdURGMDAtXFx1REY0NFxcdURGNTBcXHVERjkzLVxcdURGOUZdfFxcdUQ4MkNbXFx1REMwMFxcdURDMDFdfFxcdUQ4MkZbXFx1REMwMC1cXHVEQzZBXFx1REM3MC1cXHVEQzdDXFx1REM4MC1cXHVEQzg4XFx1REM5MC1cXHVEQzk5XXxcXHVEODM1W1xcdURDMDAtXFx1REM1NFxcdURDNTYtXFx1REM5Q1xcdURDOUVcXHVEQzlGXFx1RENBMlxcdURDQTVcXHVEQ0E2XFx1RENBOS1cXHVEQ0FDXFx1RENBRS1cXHVEQ0I5XFx1RENCQlxcdURDQkQtXFx1RENDM1xcdURDQzUtXFx1REQwNVxcdUREMDctXFx1REQwQVxcdUREMEQtXFx1REQxNFxcdUREMTYtXFx1REQxQ1xcdUREMUUtXFx1REQzOVxcdUREM0ItXFx1REQzRVxcdURENDAtXFx1REQ0NFxcdURENDZcXHVERDRBLVxcdURENTBcXHVERDUyLVxcdURFQTVcXHVERUE4LVxcdURFQzBcXHVERUMyLVxcdURFREFcXHVERURDLVxcdURFRkFcXHVERUZDLVxcdURGMTRcXHVERjE2LVxcdURGMzRcXHVERjM2LVxcdURGNEVcXHVERjUwLVxcdURGNkVcXHVERjcwLVxcdURGODhcXHVERjhBLVxcdURGQThcXHVERkFBLVxcdURGQzJcXHVERkM0LVxcdURGQ0JdfFxcdUQ4M0FbXFx1REMwMC1cXHVEQ0M0XXxcXHVEODNCW1xcdURFMDAtXFx1REUwM1xcdURFMDUtXFx1REUxRlxcdURFMjFcXHVERTIyXFx1REUyNFxcdURFMjdcXHVERTI5LVxcdURFMzJcXHVERTM0LVxcdURFMzdcXHVERTM5XFx1REUzQlxcdURFNDJcXHVERTQ3XFx1REU0OVxcdURFNEJcXHVERTRELVxcdURFNEZcXHVERTUxXFx1REU1MlxcdURFNTRcXHVERTU3XFx1REU1OVxcdURFNUJcXHVERTVEXFx1REU1RlxcdURFNjFcXHVERTYyXFx1REU2NFxcdURFNjctXFx1REU2QVxcdURFNkMtXFx1REU3MlxcdURFNzQtXFx1REU3N1xcdURFNzktXFx1REU3Q1xcdURFN0VcXHVERTgwLVxcdURFODlcXHVERThCLVxcdURFOUJcXHVERUExLVxcdURFQTNcXHVERUE1LVxcdURFQTlcXHVERUFCLVxcdURFQkJdfFxcdUQ4NjlbXFx1REMwMC1cXHVERUQ2XFx1REYwMC1cXHVERkZGXXxcXHVEODZEW1xcdURDMDAtXFx1REYzNFxcdURGNDAtXFx1REZGRl18XFx1RDg2RVtcXHVEQzAwLVxcdURDMURcXHVEQzIwLVxcdURGRkZdfFxcdUQ4NzNbXFx1REMwMC1cXHVERUExXXxcXHVEODdFW1xcdURDMDAtXFx1REUxRF0vLFxyXG5cdCAgICAvLyBVbmljb2RlIHY4LjAuMCBOb25Bc2NpaUlkZW50aWZpZXJQYXJ0OlxyXG5cdCAgICBOb25Bc2NpaUlkZW50aWZpZXJQYXJ0OiAvW1xceEFBXFx4QjVcXHhCN1xceEJBXFx4QzAtXFx4RDZcXHhEOC1cXHhGNlxceEY4LVxcdTAyQzFcXHUwMkM2LVxcdTAyRDFcXHUwMkUwLVxcdTAyRTRcXHUwMkVDXFx1MDJFRVxcdTAzMDAtXFx1MDM3NFxcdTAzNzZcXHUwMzc3XFx1MDM3QS1cXHUwMzdEXFx1MDM3RlxcdTAzODYtXFx1MDM4QVxcdTAzOENcXHUwMzhFLVxcdTAzQTFcXHUwM0EzLVxcdTAzRjVcXHUwM0Y3LVxcdTA0ODFcXHUwNDgzLVxcdTA0ODdcXHUwNDhBLVxcdTA1MkZcXHUwNTMxLVxcdTA1NTZcXHUwNTU5XFx1MDU2MS1cXHUwNTg3XFx1MDU5MS1cXHUwNUJEXFx1MDVCRlxcdTA1QzFcXHUwNUMyXFx1MDVDNFxcdTA1QzVcXHUwNUM3XFx1MDVEMC1cXHUwNUVBXFx1MDVGMC1cXHUwNUYyXFx1MDYxMC1cXHUwNjFBXFx1MDYyMC1cXHUwNjY5XFx1MDY2RS1cXHUwNkQzXFx1MDZENS1cXHUwNkRDXFx1MDZERi1cXHUwNkU4XFx1MDZFQS1cXHUwNkZDXFx1MDZGRlxcdTA3MTAtXFx1MDc0QVxcdTA3NEQtXFx1MDdCMVxcdTA3QzAtXFx1MDdGNVxcdTA3RkFcXHUwODAwLVxcdTA4MkRcXHUwODQwLVxcdTA4NUJcXHUwOEEwLVxcdTA4QjRcXHUwOEUzLVxcdTA5NjNcXHUwOTY2LVxcdTA5NkZcXHUwOTcxLVxcdTA5ODNcXHUwOTg1LVxcdTA5OENcXHUwOThGXFx1MDk5MFxcdTA5OTMtXFx1MDlBOFxcdTA5QUEtXFx1MDlCMFxcdTA5QjJcXHUwOUI2LVxcdTA5QjlcXHUwOUJDLVxcdTA5QzRcXHUwOUM3XFx1MDlDOFxcdTA5Q0ItXFx1MDlDRVxcdTA5RDdcXHUwOURDXFx1MDlERFxcdTA5REYtXFx1MDlFM1xcdTA5RTYtXFx1MDlGMVxcdTBBMDEtXFx1MEEwM1xcdTBBMDUtXFx1MEEwQVxcdTBBMEZcXHUwQTEwXFx1MEExMy1cXHUwQTI4XFx1MEEyQS1cXHUwQTMwXFx1MEEzMlxcdTBBMzNcXHUwQTM1XFx1MEEzNlxcdTBBMzhcXHUwQTM5XFx1MEEzQ1xcdTBBM0UtXFx1MEE0MlxcdTBBNDdcXHUwQTQ4XFx1MEE0Qi1cXHUwQTREXFx1MEE1MVxcdTBBNTktXFx1MEE1Q1xcdTBBNUVcXHUwQTY2LVxcdTBBNzVcXHUwQTgxLVxcdTBBODNcXHUwQTg1LVxcdTBBOERcXHUwQThGLVxcdTBBOTFcXHUwQTkzLVxcdTBBQThcXHUwQUFBLVxcdTBBQjBcXHUwQUIyXFx1MEFCM1xcdTBBQjUtXFx1MEFCOVxcdTBBQkMtXFx1MEFDNVxcdTBBQzctXFx1MEFDOVxcdTBBQ0ItXFx1MEFDRFxcdTBBRDBcXHUwQUUwLVxcdTBBRTNcXHUwQUU2LVxcdTBBRUZcXHUwQUY5XFx1MEIwMS1cXHUwQjAzXFx1MEIwNS1cXHUwQjBDXFx1MEIwRlxcdTBCMTBcXHUwQjEzLVxcdTBCMjhcXHUwQjJBLVxcdTBCMzBcXHUwQjMyXFx1MEIzM1xcdTBCMzUtXFx1MEIzOVxcdTBCM0MtXFx1MEI0NFxcdTBCNDdcXHUwQjQ4XFx1MEI0Qi1cXHUwQjREXFx1MEI1NlxcdTBCNTdcXHUwQjVDXFx1MEI1RFxcdTBCNUYtXFx1MEI2M1xcdTBCNjYtXFx1MEI2RlxcdTBCNzFcXHUwQjgyXFx1MEI4M1xcdTBCODUtXFx1MEI4QVxcdTBCOEUtXFx1MEI5MFxcdTBCOTItXFx1MEI5NVxcdTBCOTlcXHUwQjlBXFx1MEI5Q1xcdTBCOUVcXHUwQjlGXFx1MEJBM1xcdTBCQTRcXHUwQkE4LVxcdTBCQUFcXHUwQkFFLVxcdTBCQjlcXHUwQkJFLVxcdTBCQzJcXHUwQkM2LVxcdTBCQzhcXHUwQkNBLVxcdTBCQ0RcXHUwQkQwXFx1MEJEN1xcdTBCRTYtXFx1MEJFRlxcdTBDMDAtXFx1MEMwM1xcdTBDMDUtXFx1MEMwQ1xcdTBDMEUtXFx1MEMxMFxcdTBDMTItXFx1MEMyOFxcdTBDMkEtXFx1MEMzOVxcdTBDM0QtXFx1MEM0NFxcdTBDNDYtXFx1MEM0OFxcdTBDNEEtXFx1MEM0RFxcdTBDNTVcXHUwQzU2XFx1MEM1OC1cXHUwQzVBXFx1MEM2MC1cXHUwQzYzXFx1MEM2Ni1cXHUwQzZGXFx1MEM4MS1cXHUwQzgzXFx1MEM4NS1cXHUwQzhDXFx1MEM4RS1cXHUwQzkwXFx1MEM5Mi1cXHUwQ0E4XFx1MENBQS1cXHUwQ0IzXFx1MENCNS1cXHUwQ0I5XFx1MENCQy1cXHUwQ0M0XFx1MENDNi1cXHUwQ0M4XFx1MENDQS1cXHUwQ0NEXFx1MENENVxcdTBDRDZcXHUwQ0RFXFx1MENFMC1cXHUwQ0UzXFx1MENFNi1cXHUwQ0VGXFx1MENGMVxcdTBDRjJcXHUwRDAxLVxcdTBEMDNcXHUwRDA1LVxcdTBEMENcXHUwRDBFLVxcdTBEMTBcXHUwRDEyLVxcdTBEM0FcXHUwRDNELVxcdTBENDRcXHUwRDQ2LVxcdTBENDhcXHUwRDRBLVxcdTBENEVcXHUwRDU3XFx1MEQ1Ri1cXHUwRDYzXFx1MEQ2Ni1cXHUwRDZGXFx1MEQ3QS1cXHUwRDdGXFx1MEQ4MlxcdTBEODNcXHUwRDg1LVxcdTBEOTZcXHUwRDlBLVxcdTBEQjFcXHUwREIzLVxcdTBEQkJcXHUwREJEXFx1MERDMC1cXHUwREM2XFx1MERDQVxcdTBEQ0YtXFx1MERENFxcdTBERDZcXHUwREQ4LVxcdTBEREZcXHUwREU2LVxcdTBERUZcXHUwREYyXFx1MERGM1xcdTBFMDEtXFx1MEUzQVxcdTBFNDAtXFx1MEU0RVxcdTBFNTAtXFx1MEU1OVxcdTBFODFcXHUwRTgyXFx1MEU4NFxcdTBFODdcXHUwRTg4XFx1MEU4QVxcdTBFOERcXHUwRTk0LVxcdTBFOTdcXHUwRTk5LVxcdTBFOUZcXHUwRUExLVxcdTBFQTNcXHUwRUE1XFx1MEVBN1xcdTBFQUFcXHUwRUFCXFx1MEVBRC1cXHUwRUI5XFx1MEVCQi1cXHUwRUJEXFx1MEVDMC1cXHUwRUM0XFx1MEVDNlxcdTBFQzgtXFx1MEVDRFxcdTBFRDAtXFx1MEVEOVxcdTBFREMtXFx1MEVERlxcdTBGMDBcXHUwRjE4XFx1MEYxOVxcdTBGMjAtXFx1MEYyOVxcdTBGMzVcXHUwRjM3XFx1MEYzOVxcdTBGM0UtXFx1MEY0N1xcdTBGNDktXFx1MEY2Q1xcdTBGNzEtXFx1MEY4NFxcdTBGODYtXFx1MEY5N1xcdTBGOTktXFx1MEZCQ1xcdTBGQzZcXHUxMDAwLVxcdTEwNDlcXHUxMDUwLVxcdTEwOURcXHUxMEEwLVxcdTEwQzVcXHUxMEM3XFx1MTBDRFxcdTEwRDAtXFx1MTBGQVxcdTEwRkMtXFx1MTI0OFxcdTEyNEEtXFx1MTI0RFxcdTEyNTAtXFx1MTI1NlxcdTEyNThcXHUxMjVBLVxcdTEyNURcXHUxMjYwLVxcdTEyODhcXHUxMjhBLVxcdTEyOERcXHUxMjkwLVxcdTEyQjBcXHUxMkIyLVxcdTEyQjVcXHUxMkI4LVxcdTEyQkVcXHUxMkMwXFx1MTJDMi1cXHUxMkM1XFx1MTJDOC1cXHUxMkQ2XFx1MTJEOC1cXHUxMzEwXFx1MTMxMi1cXHUxMzE1XFx1MTMxOC1cXHUxMzVBXFx1MTM1RC1cXHUxMzVGXFx1MTM2OS1cXHUxMzcxXFx1MTM4MC1cXHUxMzhGXFx1MTNBMC1cXHUxM0Y1XFx1MTNGOC1cXHUxM0ZEXFx1MTQwMS1cXHUxNjZDXFx1MTY2Ri1cXHUxNjdGXFx1MTY4MS1cXHUxNjlBXFx1MTZBMC1cXHUxNkVBXFx1MTZFRS1cXHUxNkY4XFx1MTcwMC1cXHUxNzBDXFx1MTcwRS1cXHUxNzE0XFx1MTcyMC1cXHUxNzM0XFx1MTc0MC1cXHUxNzUzXFx1MTc2MC1cXHUxNzZDXFx1MTc2RS1cXHUxNzcwXFx1MTc3MlxcdTE3NzNcXHUxNzgwLVxcdTE3RDNcXHUxN0Q3XFx1MTdEQ1xcdTE3RERcXHUxN0UwLVxcdTE3RTlcXHUxODBCLVxcdTE4MERcXHUxODEwLVxcdTE4MTlcXHUxODIwLVxcdTE4NzdcXHUxODgwLVxcdTE4QUFcXHUxOEIwLVxcdTE4RjVcXHUxOTAwLVxcdTE5MUVcXHUxOTIwLVxcdTE5MkJcXHUxOTMwLVxcdTE5M0JcXHUxOTQ2LVxcdTE5NkRcXHUxOTcwLVxcdTE5NzRcXHUxOTgwLVxcdTE5QUJcXHUxOUIwLVxcdTE5QzlcXHUxOUQwLVxcdTE5REFcXHUxQTAwLVxcdTFBMUJcXHUxQTIwLVxcdTFBNUVcXHUxQTYwLVxcdTFBN0NcXHUxQTdGLVxcdTFBODlcXHUxQTkwLVxcdTFBOTlcXHUxQUE3XFx1MUFCMC1cXHUxQUJEXFx1MUIwMC1cXHUxQjRCXFx1MUI1MC1cXHUxQjU5XFx1MUI2Qi1cXHUxQjczXFx1MUI4MC1cXHUxQkYzXFx1MUMwMC1cXHUxQzM3XFx1MUM0MC1cXHUxQzQ5XFx1MUM0RC1cXHUxQzdEXFx1MUNEMC1cXHUxQ0QyXFx1MUNENC1cXHUxQ0Y2XFx1MUNGOFxcdTFDRjlcXHUxRDAwLVxcdTFERjVcXHUxREZDLVxcdTFGMTVcXHUxRjE4LVxcdTFGMURcXHUxRjIwLVxcdTFGNDVcXHUxRjQ4LVxcdTFGNERcXHUxRjUwLVxcdTFGNTdcXHUxRjU5XFx1MUY1QlxcdTFGNURcXHUxRjVGLVxcdTFGN0RcXHUxRjgwLVxcdTFGQjRcXHUxRkI2LVxcdTFGQkNcXHUxRkJFXFx1MUZDMi1cXHUxRkM0XFx1MUZDNi1cXHUxRkNDXFx1MUZEMC1cXHUxRkQzXFx1MUZENi1cXHUxRkRCXFx1MUZFMC1cXHUxRkVDXFx1MUZGMi1cXHUxRkY0XFx1MUZGNi1cXHUxRkZDXFx1MjAwQ1xcdTIwMERcXHUyMDNGXFx1MjA0MFxcdTIwNTRcXHUyMDcxXFx1MjA3RlxcdTIwOTAtXFx1MjA5Q1xcdTIwRDAtXFx1MjBEQ1xcdTIwRTFcXHUyMEU1LVxcdTIwRjBcXHUyMTAyXFx1MjEwN1xcdTIxMEEtXFx1MjExM1xcdTIxMTVcXHUyMTE4LVxcdTIxMURcXHUyMTI0XFx1MjEyNlxcdTIxMjhcXHUyMTJBLVxcdTIxMzlcXHUyMTNDLVxcdTIxM0ZcXHUyMTQ1LVxcdTIxNDlcXHUyMTRFXFx1MjE2MC1cXHUyMTg4XFx1MkMwMC1cXHUyQzJFXFx1MkMzMC1cXHUyQzVFXFx1MkM2MC1cXHUyQ0U0XFx1MkNFQi1cXHUyQ0YzXFx1MkQwMC1cXHUyRDI1XFx1MkQyN1xcdTJEMkRcXHUyRDMwLVxcdTJENjdcXHUyRDZGXFx1MkQ3Ri1cXHUyRDk2XFx1MkRBMC1cXHUyREE2XFx1MkRBOC1cXHUyREFFXFx1MkRCMC1cXHUyREI2XFx1MkRCOC1cXHUyREJFXFx1MkRDMC1cXHUyREM2XFx1MkRDOC1cXHUyRENFXFx1MkREMC1cXHUyREQ2XFx1MkREOC1cXHUyRERFXFx1MkRFMC1cXHUyREZGXFx1MzAwNS1cXHUzMDA3XFx1MzAyMS1cXHUzMDJGXFx1MzAzMS1cXHUzMDM1XFx1MzAzOC1cXHUzMDNDXFx1MzA0MS1cXHUzMDk2XFx1MzA5OS1cXHUzMDlGXFx1MzBBMS1cXHUzMEZBXFx1MzBGQy1cXHUzMEZGXFx1MzEwNS1cXHUzMTJEXFx1MzEzMS1cXHUzMThFXFx1MzFBMC1cXHUzMUJBXFx1MzFGMC1cXHUzMUZGXFx1MzQwMC1cXHU0REI1XFx1NEUwMC1cXHU5RkQ1XFx1QTAwMC1cXHVBNDhDXFx1QTREMC1cXHVBNEZEXFx1QTUwMC1cXHVBNjBDXFx1QTYxMC1cXHVBNjJCXFx1QTY0MC1cXHVBNjZGXFx1QTY3NC1cXHVBNjdEXFx1QTY3Ri1cXHVBNkYxXFx1QTcxNy1cXHVBNzFGXFx1QTcyMi1cXHVBNzg4XFx1QTc4Qi1cXHVBN0FEXFx1QTdCMC1cXHVBN0I3XFx1QTdGNy1cXHVBODI3XFx1QTg0MC1cXHVBODczXFx1QTg4MC1cXHVBOEM0XFx1QThEMC1cXHVBOEQ5XFx1QThFMC1cXHVBOEY3XFx1QThGQlxcdUE4RkRcXHVBOTAwLVxcdUE5MkRcXHVBOTMwLVxcdUE5NTNcXHVBOTYwLVxcdUE5N0NcXHVBOTgwLVxcdUE5QzBcXHVBOUNGLVxcdUE5RDlcXHVBOUUwLVxcdUE5RkVcXHVBQTAwLVxcdUFBMzZcXHVBQTQwLVxcdUFBNERcXHVBQTUwLVxcdUFBNTlcXHVBQTYwLVxcdUFBNzZcXHVBQTdBLVxcdUFBQzJcXHVBQURCLVxcdUFBRERcXHVBQUUwLVxcdUFBRUZcXHVBQUYyLVxcdUFBRjZcXHVBQjAxLVxcdUFCMDZcXHVBQjA5LVxcdUFCMEVcXHVBQjExLVxcdUFCMTZcXHVBQjIwLVxcdUFCMjZcXHVBQjI4LVxcdUFCMkVcXHVBQjMwLVxcdUFCNUFcXHVBQjVDLVxcdUFCNjVcXHVBQjcwLVxcdUFCRUFcXHVBQkVDXFx1QUJFRFxcdUFCRjAtXFx1QUJGOVxcdUFDMDAtXFx1RDdBM1xcdUQ3QjAtXFx1RDdDNlxcdUQ3Q0ItXFx1RDdGQlxcdUY5MDAtXFx1RkE2RFxcdUZBNzAtXFx1RkFEOVxcdUZCMDAtXFx1RkIwNlxcdUZCMTMtXFx1RkIxN1xcdUZCMUQtXFx1RkIyOFxcdUZCMkEtXFx1RkIzNlxcdUZCMzgtXFx1RkIzQ1xcdUZCM0VcXHVGQjQwXFx1RkI0MVxcdUZCNDNcXHVGQjQ0XFx1RkI0Ni1cXHVGQkIxXFx1RkJEMy1cXHVGRDNEXFx1RkQ1MC1cXHVGRDhGXFx1RkQ5Mi1cXHVGREM3XFx1RkRGMC1cXHVGREZCXFx1RkUwMC1cXHVGRTBGXFx1RkUyMC1cXHVGRTJGXFx1RkUzM1xcdUZFMzRcXHVGRTRELVxcdUZFNEZcXHVGRTcwLVxcdUZFNzRcXHVGRTc2LVxcdUZFRkNcXHVGRjEwLVxcdUZGMTlcXHVGRjIxLVxcdUZGM0FcXHVGRjNGXFx1RkY0MS1cXHVGRjVBXFx1RkY2Ni1cXHVGRkJFXFx1RkZDMi1cXHVGRkM3XFx1RkZDQS1cXHVGRkNGXFx1RkZEMi1cXHVGRkQ3XFx1RkZEQS1cXHVGRkRDXXxcXHVEODAwW1xcdURDMDAtXFx1REMwQlxcdURDMEQtXFx1REMyNlxcdURDMjgtXFx1REMzQVxcdURDM0NcXHVEQzNEXFx1REMzRi1cXHVEQzREXFx1REM1MC1cXHVEQzVEXFx1REM4MC1cXHVEQ0ZBXFx1REQ0MC1cXHVERDc0XFx1RERGRFxcdURFODAtXFx1REU5Q1xcdURFQTAtXFx1REVEMFxcdURFRTBcXHVERjAwLVxcdURGMUZcXHVERjMwLVxcdURGNEFcXHVERjUwLVxcdURGN0FcXHVERjgwLVxcdURGOURcXHVERkEwLVxcdURGQzNcXHVERkM4LVxcdURGQ0ZcXHVERkQxLVxcdURGRDVdfFxcdUQ4MDFbXFx1REMwMC1cXHVEQzlEXFx1RENBMC1cXHVEQ0E5XFx1REQwMC1cXHVERDI3XFx1REQzMC1cXHVERDYzXFx1REUwMC1cXHVERjM2XFx1REY0MC1cXHVERjU1XFx1REY2MC1cXHVERjY3XXxcXHVEODAyW1xcdURDMDAtXFx1REMwNVxcdURDMDhcXHVEQzBBLVxcdURDMzVcXHVEQzM3XFx1REMzOFxcdURDM0NcXHVEQzNGLVxcdURDNTVcXHVEQzYwLVxcdURDNzZcXHVEQzgwLVxcdURDOUVcXHVEQ0UwLVxcdURDRjJcXHVEQ0Y0XFx1RENGNVxcdUREMDAtXFx1REQxNVxcdUREMjAtXFx1REQzOVxcdUREODAtXFx1RERCN1xcdUREQkVcXHVEREJGXFx1REUwMC1cXHVERTAzXFx1REUwNVxcdURFMDZcXHVERTBDLVxcdURFMTNcXHVERTE1LVxcdURFMTdcXHVERTE5LVxcdURFMzNcXHVERTM4LVxcdURFM0FcXHVERTNGXFx1REU2MC1cXHVERTdDXFx1REU4MC1cXHVERTlDXFx1REVDMC1cXHVERUM3XFx1REVDOS1cXHVERUU2XFx1REYwMC1cXHVERjM1XFx1REY0MC1cXHVERjU1XFx1REY2MC1cXHVERjcyXFx1REY4MC1cXHVERjkxXXxcXHVEODAzW1xcdURDMDAtXFx1REM0OFxcdURDODAtXFx1RENCMlxcdURDQzAtXFx1RENGMl18XFx1RDgwNFtcXHVEQzAwLVxcdURDNDZcXHVEQzY2LVxcdURDNkZcXHVEQzdGLVxcdURDQkFcXHVEQ0QwLVxcdURDRThcXHVEQ0YwLVxcdURDRjlcXHVERDAwLVxcdUREMzRcXHVERDM2LVxcdUREM0ZcXHVERDUwLVxcdURENzNcXHVERDc2XFx1REQ4MC1cXHVEREM0XFx1RERDQS1cXHVERENDXFx1REREMC1cXHVERERBXFx1REREQ1xcdURFMDAtXFx1REUxMVxcdURFMTMtXFx1REUzN1xcdURFODAtXFx1REU4NlxcdURFODhcXHVERThBLVxcdURFOERcXHVERThGLVxcdURFOURcXHVERTlGLVxcdURFQThcXHVERUIwLVxcdURFRUFcXHVERUYwLVxcdURFRjlcXHVERjAwLVxcdURGMDNcXHVERjA1LVxcdURGMENcXHVERjBGXFx1REYxMFxcdURGMTMtXFx1REYyOFxcdURGMkEtXFx1REYzMFxcdURGMzJcXHVERjMzXFx1REYzNS1cXHVERjM5XFx1REYzQy1cXHVERjQ0XFx1REY0N1xcdURGNDhcXHVERjRCLVxcdURGNERcXHVERjUwXFx1REY1N1xcdURGNUQtXFx1REY2M1xcdURGNjYtXFx1REY2Q1xcdURGNzAtXFx1REY3NF18XFx1RDgwNVtcXHVEQzgwLVxcdURDQzVcXHVEQ0M3XFx1RENEMC1cXHVEQ0Q5XFx1REQ4MC1cXHVEREI1XFx1RERCOC1cXHVEREMwXFx1REREOC1cXHVEREREXFx1REUwMC1cXHVERTQwXFx1REU0NFxcdURFNTAtXFx1REU1OVxcdURFODAtXFx1REVCN1xcdURFQzAtXFx1REVDOVxcdURGMDAtXFx1REYxOVxcdURGMUQtXFx1REYyQlxcdURGMzAtXFx1REYzOV18XFx1RDgwNltcXHVEQ0EwLVxcdURDRTlcXHVEQ0ZGXFx1REVDMC1cXHVERUY4XXxcXHVEODA4W1xcdURDMDAtXFx1REY5OV18XFx1RDgwOVtcXHVEQzAwLVxcdURDNkVcXHVEQzgwLVxcdURENDNdfFtcXHVEODBDXFx1RDg0MC1cXHVEODY4XFx1RDg2QS1cXHVEODZDXFx1RDg2Ri1cXHVEODcyXVtcXHVEQzAwLVxcdURGRkZdfFxcdUQ4MERbXFx1REMwMC1cXHVEQzJFXXxcXHVEODExW1xcdURDMDAtXFx1REU0Nl18XFx1RDgxQVtcXHVEQzAwLVxcdURFMzhcXHVERTQwLVxcdURFNUVcXHVERTYwLVxcdURFNjlcXHVERUQwLVxcdURFRURcXHVERUYwLVxcdURFRjRcXHVERjAwLVxcdURGMzZcXHVERjQwLVxcdURGNDNcXHVERjUwLVxcdURGNTlcXHVERjYzLVxcdURGNzdcXHVERjdELVxcdURGOEZdfFxcdUQ4MUJbXFx1REYwMC1cXHVERjQ0XFx1REY1MC1cXHVERjdFXFx1REY4Ri1cXHVERjlGXXxcXHVEODJDW1xcdURDMDBcXHVEQzAxXXxcXHVEODJGW1xcdURDMDAtXFx1REM2QVxcdURDNzAtXFx1REM3Q1xcdURDODAtXFx1REM4OFxcdURDOTAtXFx1REM5OVxcdURDOURcXHVEQzlFXXxcXHVEODM0W1xcdURENjUtXFx1REQ2OVxcdURENkQtXFx1REQ3MlxcdUREN0ItXFx1REQ4MlxcdUREODUtXFx1REQ4QlxcdUREQUEtXFx1RERBRFxcdURFNDItXFx1REU0NF18XFx1RDgzNVtcXHVEQzAwLVxcdURDNTRcXHVEQzU2LVxcdURDOUNcXHVEQzlFXFx1REM5RlxcdURDQTJcXHVEQ0E1XFx1RENBNlxcdURDQTktXFx1RENBQ1xcdURDQUUtXFx1RENCOVxcdURDQkJcXHVEQ0JELVxcdURDQzNcXHVEQ0M1LVxcdUREMDVcXHVERDA3LVxcdUREMEFcXHVERDBELVxcdUREMTRcXHVERDE2LVxcdUREMUNcXHVERDFFLVxcdUREMzlcXHVERDNCLVxcdUREM0VcXHVERDQwLVxcdURENDRcXHVERDQ2XFx1REQ0QS1cXHVERDUwXFx1REQ1Mi1cXHVERUE1XFx1REVBOC1cXHVERUMwXFx1REVDMi1cXHVERURBXFx1REVEQy1cXHVERUZBXFx1REVGQy1cXHVERjE0XFx1REYxNi1cXHVERjM0XFx1REYzNi1cXHVERjRFXFx1REY1MC1cXHVERjZFXFx1REY3MC1cXHVERjg4XFx1REY4QS1cXHVERkE4XFx1REZBQS1cXHVERkMyXFx1REZDNC1cXHVERkNCXFx1REZDRS1cXHVERkZGXXxcXHVEODM2W1xcdURFMDAtXFx1REUzNlxcdURFM0ItXFx1REU2Q1xcdURFNzVcXHVERTg0XFx1REU5Qi1cXHVERTlGXFx1REVBMS1cXHVERUFGXXxcXHVEODNBW1xcdURDMDAtXFx1RENDNFxcdURDRDAtXFx1RENENl18XFx1RDgzQltcXHVERTAwLVxcdURFMDNcXHVERTA1LVxcdURFMUZcXHVERTIxXFx1REUyMlxcdURFMjRcXHVERTI3XFx1REUyOS1cXHVERTMyXFx1REUzNC1cXHVERTM3XFx1REUzOVxcdURFM0JcXHVERTQyXFx1REU0N1xcdURFNDlcXHVERTRCXFx1REU0RC1cXHVERTRGXFx1REU1MVxcdURFNTJcXHVERTU0XFx1REU1N1xcdURFNTlcXHVERTVCXFx1REU1RFxcdURFNUZcXHVERTYxXFx1REU2MlxcdURFNjRcXHVERTY3LVxcdURFNkFcXHVERTZDLVxcdURFNzJcXHVERTc0LVxcdURFNzdcXHVERTc5LVxcdURFN0NcXHVERTdFXFx1REU4MC1cXHVERTg5XFx1REU4Qi1cXHVERTlCXFx1REVBMS1cXHVERUEzXFx1REVBNS1cXHVERUE5XFx1REVBQi1cXHVERUJCXXxcXHVEODY5W1xcdURDMDAtXFx1REVENlxcdURGMDAtXFx1REZGRl18XFx1RDg2RFtcXHVEQzAwLVxcdURGMzRcXHVERjQwLVxcdURGRkZdfFxcdUQ4NkVbXFx1REMwMC1cXHVEQzFEXFx1REMyMC1cXHVERkZGXXxcXHVEODczW1xcdURDMDAtXFx1REVBMV18XFx1RDg3RVtcXHVEQzAwLVxcdURFMURdfFxcdURCNDBbXFx1REQwMC1cXHVEREVGXS9cclxuXHR9O1xyXG5cdGV4cG9ydHMuQ2hhcmFjdGVyID0ge1xyXG5cdCAgICAvKiB0c2xpbnQ6ZGlzYWJsZTpuby1iaXR3aXNlICovXHJcblx0ICAgIGZyb21Db2RlUG9pbnQ6IGZ1bmN0aW9uIChjcCkge1xyXG5cdCAgICAgICAgcmV0dXJuIChjcCA8IDB4MTAwMDApID8gU3RyaW5nLmZyb21DaGFyQ29kZShjcCkgOlxyXG5cdCAgICAgICAgICAgIFN0cmluZy5mcm9tQ2hhckNvZGUoMHhEODAwICsgKChjcCAtIDB4MTAwMDApID4+IDEwKSkgK1xyXG5cdCAgICAgICAgICAgICAgICBTdHJpbmcuZnJvbUNoYXJDb2RlKDB4REMwMCArICgoY3AgLSAweDEwMDAwKSAmIDEwMjMpKTtcclxuXHQgICAgfSxcclxuXHQgICAgLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtd2hpdGUtc3BhY2VcclxuXHQgICAgaXNXaGl0ZVNwYWNlOiBmdW5jdGlvbiAoY3ApIHtcclxuXHQgICAgICAgIHJldHVybiAoY3AgPT09IDB4MjApIHx8IChjcCA9PT0gMHgwOSkgfHwgKGNwID09PSAweDBCKSB8fCAoY3AgPT09IDB4MEMpIHx8IChjcCA9PT0gMHhBMCkgfHxcclxuXHQgICAgICAgICAgICAoY3AgPj0gMHgxNjgwICYmIFsweDE2ODAsIDB4MjAwMCwgMHgyMDAxLCAweDIwMDIsIDB4MjAwMywgMHgyMDA0LCAweDIwMDUsIDB4MjAwNiwgMHgyMDA3LCAweDIwMDgsIDB4MjAwOSwgMHgyMDBBLCAweDIwMkYsIDB4MjA1RiwgMHgzMDAwLCAweEZFRkZdLmluZGV4T2YoY3ApID49IDApO1xyXG5cdCAgICB9LFxyXG5cdCAgICAvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1saW5lLXRlcm1pbmF0b3JzXHJcblx0ICAgIGlzTGluZVRlcm1pbmF0b3I6IGZ1bmN0aW9uIChjcCkge1xyXG5cdCAgICAgICAgcmV0dXJuIChjcCA9PT0gMHgwQSkgfHwgKGNwID09PSAweDBEKSB8fCAoY3AgPT09IDB4MjAyOCkgfHwgKGNwID09PSAweDIwMjkpO1xyXG5cdCAgICB9LFxyXG5cdCAgICAvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1uYW1lcy1hbmQta2V5d29yZHNcclxuXHQgICAgaXNJZGVudGlmaWVyU3RhcnQ6IGZ1bmN0aW9uIChjcCkge1xyXG5cdCAgICAgICAgcmV0dXJuIChjcCA9PT0gMHgyNCkgfHwgKGNwID09PSAweDVGKSB8fFxyXG5cdCAgICAgICAgICAgIChjcCA+PSAweDQxICYmIGNwIDw9IDB4NUEpIHx8XHJcblx0ICAgICAgICAgICAgKGNwID49IDB4NjEgJiYgY3AgPD0gMHg3QSkgfHxcclxuXHQgICAgICAgICAgICAoY3AgPT09IDB4NUMpIHx8XHJcblx0ICAgICAgICAgICAgKChjcCA+PSAweDgwKSAmJiBSZWdleC5Ob25Bc2NpaUlkZW50aWZpZXJTdGFydC50ZXN0KGV4cG9ydHMuQ2hhcmFjdGVyLmZyb21Db2RlUG9pbnQoY3ApKSk7XHJcblx0ICAgIH0sXHJcblx0ICAgIGlzSWRlbnRpZmllclBhcnQ6IGZ1bmN0aW9uIChjcCkge1xyXG5cdCAgICAgICAgcmV0dXJuIChjcCA9PT0gMHgyNCkgfHwgKGNwID09PSAweDVGKSB8fFxyXG5cdCAgICAgICAgICAgIChjcCA+PSAweDQxICYmIGNwIDw9IDB4NUEpIHx8XHJcblx0ICAgICAgICAgICAgKGNwID49IDB4NjEgJiYgY3AgPD0gMHg3QSkgfHxcclxuXHQgICAgICAgICAgICAoY3AgPj0gMHgzMCAmJiBjcCA8PSAweDM5KSB8fFxyXG5cdCAgICAgICAgICAgIChjcCA9PT0gMHg1QykgfHxcclxuXHQgICAgICAgICAgICAoKGNwID49IDB4ODApICYmIFJlZ2V4Lk5vbkFzY2lpSWRlbnRpZmllclBhcnQudGVzdChleHBvcnRzLkNoYXJhY3Rlci5mcm9tQ29kZVBvaW50KGNwKSkpO1xyXG5cdCAgICB9LFxyXG5cdCAgICAvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1saXRlcmFscy1udW1lcmljLWxpdGVyYWxzXHJcblx0ICAgIGlzRGVjaW1hbERpZ2l0OiBmdW5jdGlvbiAoY3ApIHtcclxuXHQgICAgICAgIHJldHVybiAoY3AgPj0gMHgzMCAmJiBjcCA8PSAweDM5KTsgLy8gMC4uOVxyXG5cdCAgICB9LFxyXG5cdCAgICBpc0hleERpZ2l0OiBmdW5jdGlvbiAoY3ApIHtcclxuXHQgICAgICAgIHJldHVybiAoY3AgPj0gMHgzMCAmJiBjcCA8PSAweDM5KSB8fFxyXG5cdCAgICAgICAgICAgIChjcCA+PSAweDQxICYmIGNwIDw9IDB4NDYpIHx8XHJcblx0ICAgICAgICAgICAgKGNwID49IDB4NjEgJiYgY3AgPD0gMHg2Nik7IC8vIGEuLmZcclxuXHQgICAgfSxcclxuXHQgICAgaXNPY3RhbERpZ2l0OiBmdW5jdGlvbiAoY3ApIHtcclxuXHQgICAgICAgIHJldHVybiAoY3AgPj0gMHgzMCAmJiBjcCA8PSAweDM3KTsgLy8gMC4uN1xyXG5cdCAgICB9XHJcblx0fTtcclxuXG5cbi8qKiovIH0sXG4vKiA1ICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXHRcInVzZSBzdHJpY3RcIjtcclxuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcblx0dmFyIGpzeF9zeW50YXhfMSA9IF9fd2VicGFja19yZXF1aXJlX18oNik7XHJcblx0LyogdHNsaW50OmRpc2FibGU6bWF4LWNsYXNzZXMtcGVyLWZpbGUgKi9cclxuXHR2YXIgSlNYQ2xvc2luZ0VsZW1lbnQgPSAoZnVuY3Rpb24gKCkge1xyXG5cdCAgICBmdW5jdGlvbiBKU1hDbG9zaW5nRWxlbWVudChuYW1lKSB7XHJcblx0ICAgICAgICB0aGlzLnR5cGUgPSBqc3hfc3ludGF4XzEuSlNYU3ludGF4LkpTWENsb3NpbmdFbGVtZW50O1xyXG5cdCAgICAgICAgdGhpcy5uYW1lID0gbmFtZTtcclxuXHQgICAgfVxyXG5cdCAgICByZXR1cm4gSlNYQ2xvc2luZ0VsZW1lbnQ7XHJcblx0fSgpKTtcclxuXHRleHBvcnRzLkpTWENsb3NpbmdFbGVtZW50ID0gSlNYQ2xvc2luZ0VsZW1lbnQ7XHJcblx0dmFyIEpTWEVsZW1lbnQgPSAoZnVuY3Rpb24gKCkge1xyXG5cdCAgICBmdW5jdGlvbiBKU1hFbGVtZW50KG9wZW5pbmdFbGVtZW50LCBjaGlsZHJlbiwgY2xvc2luZ0VsZW1lbnQpIHtcclxuXHQgICAgICAgIHRoaXMudHlwZSA9IGpzeF9zeW50YXhfMS5KU1hTeW50YXguSlNYRWxlbWVudDtcclxuXHQgICAgICAgIHRoaXMub3BlbmluZ0VsZW1lbnQgPSBvcGVuaW5nRWxlbWVudDtcclxuXHQgICAgICAgIHRoaXMuY2hpbGRyZW4gPSBjaGlsZHJlbjtcclxuXHQgICAgICAgIHRoaXMuY2xvc2luZ0VsZW1lbnQgPSBjbG9zaW5nRWxlbWVudDtcclxuXHQgICAgfVxyXG5cdCAgICByZXR1cm4gSlNYRWxlbWVudDtcclxuXHR9KCkpO1xyXG5cdGV4cG9ydHMuSlNYRWxlbWVudCA9IEpTWEVsZW1lbnQ7XHJcblx0dmFyIEpTWEVtcHR5RXhwcmVzc2lvbiA9IChmdW5jdGlvbiAoKSB7XHJcblx0ICAgIGZ1bmN0aW9uIEpTWEVtcHR5RXhwcmVzc2lvbigpIHtcclxuXHQgICAgICAgIHRoaXMudHlwZSA9IGpzeF9zeW50YXhfMS5KU1hTeW50YXguSlNYRW1wdHlFeHByZXNzaW9uO1xyXG5cdCAgICB9XHJcblx0ICAgIHJldHVybiBKU1hFbXB0eUV4cHJlc3Npb247XHJcblx0fSgpKTtcclxuXHRleHBvcnRzLkpTWEVtcHR5RXhwcmVzc2lvbiA9IEpTWEVtcHR5RXhwcmVzc2lvbjtcclxuXHR2YXIgSlNYRXhwcmVzc2lvbkNvbnRhaW5lciA9IChmdW5jdGlvbiAoKSB7XHJcblx0ICAgIGZ1bmN0aW9uIEpTWEV4cHJlc3Npb25Db250YWluZXIoZXhwcmVzc2lvbikge1xyXG5cdCAgICAgICAgdGhpcy50eXBlID0ganN4X3N5bnRheF8xLkpTWFN5bnRheC5KU1hFeHByZXNzaW9uQ29udGFpbmVyO1xyXG5cdCAgICAgICAgdGhpcy5leHByZXNzaW9uID0gZXhwcmVzc2lvbjtcclxuXHQgICAgfVxyXG5cdCAgICByZXR1cm4gSlNYRXhwcmVzc2lvbkNvbnRhaW5lcjtcclxuXHR9KCkpO1xyXG5cdGV4cG9ydHMuSlNYRXhwcmVzc2lvbkNvbnRhaW5lciA9IEpTWEV4cHJlc3Npb25Db250YWluZXI7XHJcblx0dmFyIEpTWElkZW50aWZpZXIgPSAoZnVuY3Rpb24gKCkge1xyXG5cdCAgICBmdW5jdGlvbiBKU1hJZGVudGlmaWVyKG5hbWUpIHtcclxuXHQgICAgICAgIHRoaXMudHlwZSA9IGpzeF9zeW50YXhfMS5KU1hTeW50YXguSlNYSWRlbnRpZmllcjtcclxuXHQgICAgICAgIHRoaXMubmFtZSA9IG5hbWU7XHJcblx0ICAgIH1cclxuXHQgICAgcmV0dXJuIEpTWElkZW50aWZpZXI7XHJcblx0fSgpKTtcclxuXHRleHBvcnRzLkpTWElkZW50aWZpZXIgPSBKU1hJZGVudGlmaWVyO1xyXG5cdHZhciBKU1hNZW1iZXJFeHByZXNzaW9uID0gKGZ1bmN0aW9uICgpIHtcclxuXHQgICAgZnVuY3Rpb24gSlNYTWVtYmVyRXhwcmVzc2lvbihvYmplY3QsIHByb3BlcnR5KSB7XHJcblx0ICAgICAgICB0aGlzLnR5cGUgPSBqc3hfc3ludGF4XzEuSlNYU3ludGF4LkpTWE1lbWJlckV4cHJlc3Npb247XHJcblx0ICAgICAgICB0aGlzLm9iamVjdCA9IG9iamVjdDtcclxuXHQgICAgICAgIHRoaXMucHJvcGVydHkgPSBwcm9wZXJ0eTtcclxuXHQgICAgfVxyXG5cdCAgICByZXR1cm4gSlNYTWVtYmVyRXhwcmVzc2lvbjtcclxuXHR9KCkpO1xyXG5cdGV4cG9ydHMuSlNYTWVtYmVyRXhwcmVzc2lvbiA9IEpTWE1lbWJlckV4cHJlc3Npb247XHJcblx0dmFyIEpTWEF0dHJpYnV0ZSA9IChmdW5jdGlvbiAoKSB7XHJcblx0ICAgIGZ1bmN0aW9uIEpTWEF0dHJpYnV0ZShuYW1lLCB2YWx1ZSkge1xyXG5cdCAgICAgICAgdGhpcy50eXBlID0ganN4X3N5bnRheF8xLkpTWFN5bnRheC5KU1hBdHRyaWJ1dGU7XHJcblx0ICAgICAgICB0aGlzLm5hbWUgPSBuYW1lO1xyXG5cdCAgICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xyXG5cdCAgICB9XHJcblx0ICAgIHJldHVybiBKU1hBdHRyaWJ1dGU7XHJcblx0fSgpKTtcclxuXHRleHBvcnRzLkpTWEF0dHJpYnV0ZSA9IEpTWEF0dHJpYnV0ZTtcclxuXHR2YXIgSlNYTmFtZXNwYWNlZE5hbWUgPSAoZnVuY3Rpb24gKCkge1xyXG5cdCAgICBmdW5jdGlvbiBKU1hOYW1lc3BhY2VkTmFtZShuYW1lc3BhY2UsIG5hbWUpIHtcclxuXHQgICAgICAgIHRoaXMudHlwZSA9IGpzeF9zeW50YXhfMS5KU1hTeW50YXguSlNYTmFtZXNwYWNlZE5hbWU7XHJcblx0ICAgICAgICB0aGlzLm5hbWVzcGFjZSA9IG5hbWVzcGFjZTtcclxuXHQgICAgICAgIHRoaXMubmFtZSA9IG5hbWU7XHJcblx0ICAgIH1cclxuXHQgICAgcmV0dXJuIEpTWE5hbWVzcGFjZWROYW1lO1xyXG5cdH0oKSk7XHJcblx0ZXhwb3J0cy5KU1hOYW1lc3BhY2VkTmFtZSA9IEpTWE5hbWVzcGFjZWROYW1lO1xyXG5cdHZhciBKU1hPcGVuaW5nRWxlbWVudCA9IChmdW5jdGlvbiAoKSB7XHJcblx0ICAgIGZ1bmN0aW9uIEpTWE9wZW5pbmdFbGVtZW50KG5hbWUsIHNlbGZDbG9zaW5nLCBhdHRyaWJ1dGVzKSB7XHJcblx0ICAgICAgICB0aGlzLnR5cGUgPSBqc3hfc3ludGF4XzEuSlNYU3ludGF4LkpTWE9wZW5pbmdFbGVtZW50O1xyXG5cdCAgICAgICAgdGhpcy5uYW1lID0gbmFtZTtcclxuXHQgICAgICAgIHRoaXMuc2VsZkNsb3NpbmcgPSBzZWxmQ2xvc2luZztcclxuXHQgICAgICAgIHRoaXMuYXR0cmlidXRlcyA9IGF0dHJpYnV0ZXM7XHJcblx0ICAgIH1cclxuXHQgICAgcmV0dXJuIEpTWE9wZW5pbmdFbGVtZW50O1xyXG5cdH0oKSk7XHJcblx0ZXhwb3J0cy5KU1hPcGVuaW5nRWxlbWVudCA9IEpTWE9wZW5pbmdFbGVtZW50O1xyXG5cdHZhciBKU1hTcHJlYWRBdHRyaWJ1dGUgPSAoZnVuY3Rpb24gKCkge1xyXG5cdCAgICBmdW5jdGlvbiBKU1hTcHJlYWRBdHRyaWJ1dGUoYXJndW1lbnQpIHtcclxuXHQgICAgICAgIHRoaXMudHlwZSA9IGpzeF9zeW50YXhfMS5KU1hTeW50YXguSlNYU3ByZWFkQXR0cmlidXRlO1xyXG5cdCAgICAgICAgdGhpcy5hcmd1bWVudCA9IGFyZ3VtZW50O1xyXG5cdCAgICB9XHJcblx0ICAgIHJldHVybiBKU1hTcHJlYWRBdHRyaWJ1dGU7XHJcblx0fSgpKTtcclxuXHRleHBvcnRzLkpTWFNwcmVhZEF0dHJpYnV0ZSA9IEpTWFNwcmVhZEF0dHJpYnV0ZTtcclxuXHR2YXIgSlNYVGV4dCA9IChmdW5jdGlvbiAoKSB7XHJcblx0ICAgIGZ1bmN0aW9uIEpTWFRleHQodmFsdWUsIHJhdykge1xyXG5cdCAgICAgICAgdGhpcy50eXBlID0ganN4X3N5bnRheF8xLkpTWFN5bnRheC5KU1hUZXh0O1xyXG5cdCAgICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xyXG5cdCAgICAgICAgdGhpcy5yYXcgPSByYXc7XHJcblx0ICAgIH1cclxuXHQgICAgcmV0dXJuIEpTWFRleHQ7XHJcblx0fSgpKTtcclxuXHRleHBvcnRzLkpTWFRleHQgPSBKU1hUZXh0O1xyXG5cblxuLyoqKi8gfSxcbi8qIDYgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG5cdFwidXNlIHN0cmljdFwiO1xyXG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuXHRleHBvcnRzLkpTWFN5bnRheCA9IHtcclxuXHQgICAgSlNYQXR0cmlidXRlOiAnSlNYQXR0cmlidXRlJyxcclxuXHQgICAgSlNYQ2xvc2luZ0VsZW1lbnQ6ICdKU1hDbG9zaW5nRWxlbWVudCcsXHJcblx0ICAgIEpTWEVsZW1lbnQ6ICdKU1hFbGVtZW50JyxcclxuXHQgICAgSlNYRW1wdHlFeHByZXNzaW9uOiAnSlNYRW1wdHlFeHByZXNzaW9uJyxcclxuXHQgICAgSlNYRXhwcmVzc2lvbkNvbnRhaW5lcjogJ0pTWEV4cHJlc3Npb25Db250YWluZXInLFxyXG5cdCAgICBKU1hJZGVudGlmaWVyOiAnSlNYSWRlbnRpZmllcicsXHJcblx0ICAgIEpTWE1lbWJlckV4cHJlc3Npb246ICdKU1hNZW1iZXJFeHByZXNzaW9uJyxcclxuXHQgICAgSlNYTmFtZXNwYWNlZE5hbWU6ICdKU1hOYW1lc3BhY2VkTmFtZScsXHJcblx0ICAgIEpTWE9wZW5pbmdFbGVtZW50OiAnSlNYT3BlbmluZ0VsZW1lbnQnLFxyXG5cdCAgICBKU1hTcHJlYWRBdHRyaWJ1dGU6ICdKU1hTcHJlYWRBdHRyaWJ1dGUnLFxyXG5cdCAgICBKU1hUZXh0OiAnSlNYVGV4dCdcclxuXHR9O1xyXG5cblxuLyoqKi8gfSxcbi8qIDcgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cdFwidXNlIHN0cmljdFwiO1xyXG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuXHR2YXIgc3ludGF4XzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIpO1xyXG5cdC8qIHRzbGludDpkaXNhYmxlOm1heC1jbGFzc2VzLXBlci1maWxlICovXHJcblx0dmFyIEFycmF5RXhwcmVzc2lvbiA9IChmdW5jdGlvbiAoKSB7XHJcblx0ICAgIGZ1bmN0aW9uIEFycmF5RXhwcmVzc2lvbihlbGVtZW50cykge1xyXG5cdCAgICAgICAgdGhpcy50eXBlID0gc3ludGF4XzEuU3ludGF4LkFycmF5RXhwcmVzc2lvbjtcclxuXHQgICAgICAgIHRoaXMuZWxlbWVudHMgPSBlbGVtZW50cztcclxuXHQgICAgfVxyXG5cdCAgICByZXR1cm4gQXJyYXlFeHByZXNzaW9uO1xyXG5cdH0oKSk7XHJcblx0ZXhwb3J0cy5BcnJheUV4cHJlc3Npb24gPSBBcnJheUV4cHJlc3Npb247XHJcblx0dmFyIEFycmF5UGF0dGVybiA9IChmdW5jdGlvbiAoKSB7XHJcblx0ICAgIGZ1bmN0aW9uIEFycmF5UGF0dGVybihlbGVtZW50cykge1xyXG5cdCAgICAgICAgdGhpcy50eXBlID0gc3ludGF4XzEuU3ludGF4LkFycmF5UGF0dGVybjtcclxuXHQgICAgICAgIHRoaXMuZWxlbWVudHMgPSBlbGVtZW50cztcclxuXHQgICAgfVxyXG5cdCAgICByZXR1cm4gQXJyYXlQYXR0ZXJuO1xyXG5cdH0oKSk7XHJcblx0ZXhwb3J0cy5BcnJheVBhdHRlcm4gPSBBcnJheVBhdHRlcm47XHJcblx0dmFyIEFycm93RnVuY3Rpb25FeHByZXNzaW9uID0gKGZ1bmN0aW9uICgpIHtcclxuXHQgICAgZnVuY3Rpb24gQXJyb3dGdW5jdGlvbkV4cHJlc3Npb24ocGFyYW1zLCBib2R5LCBleHByZXNzaW9uKSB7XHJcblx0ICAgICAgICB0aGlzLnR5cGUgPSBzeW50YXhfMS5TeW50YXguQXJyb3dGdW5jdGlvbkV4cHJlc3Npb247XHJcblx0ICAgICAgICB0aGlzLmlkID0gbnVsbDtcclxuXHQgICAgICAgIHRoaXMucGFyYW1zID0gcGFyYW1zO1xyXG5cdCAgICAgICAgdGhpcy5ib2R5ID0gYm9keTtcclxuXHQgICAgICAgIHRoaXMuZ2VuZXJhdG9yID0gZmFsc2U7XHJcblx0ICAgICAgICB0aGlzLmV4cHJlc3Npb24gPSBleHByZXNzaW9uO1xyXG5cdCAgICAgICAgdGhpcy5hc3luYyA9IGZhbHNlO1xyXG5cdCAgICB9XHJcblx0ICAgIHJldHVybiBBcnJvd0Z1bmN0aW9uRXhwcmVzc2lvbjtcclxuXHR9KCkpO1xyXG5cdGV4cG9ydHMuQXJyb3dGdW5jdGlvbkV4cHJlc3Npb24gPSBBcnJvd0Z1bmN0aW9uRXhwcmVzc2lvbjtcclxuXHR2YXIgQXNzaWdubWVudEV4cHJlc3Npb24gPSAoZnVuY3Rpb24gKCkge1xyXG5cdCAgICBmdW5jdGlvbiBBc3NpZ25tZW50RXhwcmVzc2lvbihvcGVyYXRvciwgbGVmdCwgcmlnaHQpIHtcclxuXHQgICAgICAgIHRoaXMudHlwZSA9IHN5bnRheF8xLlN5bnRheC5Bc3NpZ25tZW50RXhwcmVzc2lvbjtcclxuXHQgICAgICAgIHRoaXMub3BlcmF0b3IgPSBvcGVyYXRvcjtcclxuXHQgICAgICAgIHRoaXMubGVmdCA9IGxlZnQ7XHJcblx0ICAgICAgICB0aGlzLnJpZ2h0ID0gcmlnaHQ7XHJcblx0ICAgIH1cclxuXHQgICAgcmV0dXJuIEFzc2lnbm1lbnRFeHByZXNzaW9uO1xyXG5cdH0oKSk7XHJcblx0ZXhwb3J0cy5Bc3NpZ25tZW50RXhwcmVzc2lvbiA9IEFzc2lnbm1lbnRFeHByZXNzaW9uO1xyXG5cdHZhciBBc3NpZ25tZW50UGF0dGVybiA9IChmdW5jdGlvbiAoKSB7XHJcblx0ICAgIGZ1bmN0aW9uIEFzc2lnbm1lbnRQYXR0ZXJuKGxlZnQsIHJpZ2h0KSB7XHJcblx0ICAgICAgICB0aGlzLnR5cGUgPSBzeW50YXhfMS5TeW50YXguQXNzaWdubWVudFBhdHRlcm47XHJcblx0ICAgICAgICB0aGlzLmxlZnQgPSBsZWZ0O1xyXG5cdCAgICAgICAgdGhpcy5yaWdodCA9IHJpZ2h0O1xyXG5cdCAgICB9XHJcblx0ICAgIHJldHVybiBBc3NpZ25tZW50UGF0dGVybjtcclxuXHR9KCkpO1xyXG5cdGV4cG9ydHMuQXNzaWdubWVudFBhdHRlcm4gPSBBc3NpZ25tZW50UGF0dGVybjtcclxuXHR2YXIgQXN5bmNBcnJvd0Z1bmN0aW9uRXhwcmVzc2lvbiA9IChmdW5jdGlvbiAoKSB7XHJcblx0ICAgIGZ1bmN0aW9uIEFzeW5jQXJyb3dGdW5jdGlvbkV4cHJlc3Npb24ocGFyYW1zLCBib2R5LCBleHByZXNzaW9uKSB7XHJcblx0ICAgICAgICB0aGlzLnR5cGUgPSBzeW50YXhfMS5TeW50YXguQXJyb3dGdW5jdGlvbkV4cHJlc3Npb247XHJcblx0ICAgICAgICB0aGlzLmlkID0gbnVsbDtcclxuXHQgICAgICAgIHRoaXMucGFyYW1zID0gcGFyYW1zO1xyXG5cdCAgICAgICAgdGhpcy5ib2R5ID0gYm9keTtcclxuXHQgICAgICAgIHRoaXMuZ2VuZXJhdG9yID0gZmFsc2U7XHJcblx0ICAgICAgICB0aGlzLmV4cHJlc3Npb24gPSBleHByZXNzaW9uO1xyXG5cdCAgICAgICAgdGhpcy5hc3luYyA9IHRydWU7XHJcblx0ICAgIH1cclxuXHQgICAgcmV0dXJuIEFzeW5jQXJyb3dGdW5jdGlvbkV4cHJlc3Npb247XHJcblx0fSgpKTtcclxuXHRleHBvcnRzLkFzeW5jQXJyb3dGdW5jdGlvbkV4cHJlc3Npb24gPSBBc3luY0Fycm93RnVuY3Rpb25FeHByZXNzaW9uO1xyXG5cdHZhciBBc3luY0Z1bmN0aW9uRGVjbGFyYXRpb24gPSAoZnVuY3Rpb24gKCkge1xyXG5cdCAgICBmdW5jdGlvbiBBc3luY0Z1bmN0aW9uRGVjbGFyYXRpb24oaWQsIHBhcmFtcywgYm9keSkge1xyXG5cdCAgICAgICAgdGhpcy50eXBlID0gc3ludGF4XzEuU3ludGF4LkZ1bmN0aW9uRGVjbGFyYXRpb247XHJcblx0ICAgICAgICB0aGlzLmlkID0gaWQ7XHJcblx0ICAgICAgICB0aGlzLnBhcmFtcyA9IHBhcmFtcztcclxuXHQgICAgICAgIHRoaXMuYm9keSA9IGJvZHk7XHJcblx0ICAgICAgICB0aGlzLmdlbmVyYXRvciA9IGZhbHNlO1xyXG5cdCAgICAgICAgdGhpcy5leHByZXNzaW9uID0gZmFsc2U7XHJcblx0ICAgICAgICB0aGlzLmFzeW5jID0gdHJ1ZTtcclxuXHQgICAgfVxyXG5cdCAgICByZXR1cm4gQXN5bmNGdW5jdGlvbkRlY2xhcmF0aW9uO1xyXG5cdH0oKSk7XHJcblx0ZXhwb3J0cy5Bc3luY0Z1bmN0aW9uRGVjbGFyYXRpb24gPSBBc3luY0Z1bmN0aW9uRGVjbGFyYXRpb247XHJcblx0dmFyIEFzeW5jRnVuY3Rpb25FeHByZXNzaW9uID0gKGZ1bmN0aW9uICgpIHtcclxuXHQgICAgZnVuY3Rpb24gQXN5bmNGdW5jdGlvbkV4cHJlc3Npb24oaWQsIHBhcmFtcywgYm9keSkge1xyXG5cdCAgICAgICAgdGhpcy50eXBlID0gc3ludGF4XzEuU3ludGF4LkZ1bmN0aW9uRXhwcmVzc2lvbjtcclxuXHQgICAgICAgIHRoaXMuaWQgPSBpZDtcclxuXHQgICAgICAgIHRoaXMucGFyYW1zID0gcGFyYW1zO1xyXG5cdCAgICAgICAgdGhpcy5ib2R5ID0gYm9keTtcclxuXHQgICAgICAgIHRoaXMuZ2VuZXJhdG9yID0gZmFsc2U7XHJcblx0ICAgICAgICB0aGlzLmV4cHJlc3Npb24gPSBmYWxzZTtcclxuXHQgICAgICAgIHRoaXMuYXN5bmMgPSB0cnVlO1xyXG5cdCAgICB9XHJcblx0ICAgIHJldHVybiBBc3luY0Z1bmN0aW9uRXhwcmVzc2lvbjtcclxuXHR9KCkpO1xyXG5cdGV4cG9ydHMuQXN5bmNGdW5jdGlvbkV4cHJlc3Npb24gPSBBc3luY0Z1bmN0aW9uRXhwcmVzc2lvbjtcclxuXHR2YXIgQXdhaXRFeHByZXNzaW9uID0gKGZ1bmN0aW9uICgpIHtcclxuXHQgICAgZnVuY3Rpb24gQXdhaXRFeHByZXNzaW9uKGFyZ3VtZW50KSB7XHJcblx0ICAgICAgICB0aGlzLnR5cGUgPSBzeW50YXhfMS5TeW50YXguQXdhaXRFeHByZXNzaW9uO1xyXG5cdCAgICAgICAgdGhpcy5hcmd1bWVudCA9IGFyZ3VtZW50O1xyXG5cdCAgICB9XHJcblx0ICAgIHJldHVybiBBd2FpdEV4cHJlc3Npb247XHJcblx0fSgpKTtcclxuXHRleHBvcnRzLkF3YWl0RXhwcmVzc2lvbiA9IEF3YWl0RXhwcmVzc2lvbjtcclxuXHR2YXIgQmluYXJ5RXhwcmVzc2lvbiA9IChmdW5jdGlvbiAoKSB7XHJcblx0ICAgIGZ1bmN0aW9uIEJpbmFyeUV4cHJlc3Npb24ob3BlcmF0b3IsIGxlZnQsIHJpZ2h0KSB7XHJcblx0ICAgICAgICB2YXIgbG9naWNhbCA9IChvcGVyYXRvciA9PT0gJ3x8JyB8fCBvcGVyYXRvciA9PT0gJyYmJyk7XHJcblx0ICAgICAgICB0aGlzLnR5cGUgPSBsb2dpY2FsID8gc3ludGF4XzEuU3ludGF4LkxvZ2ljYWxFeHByZXNzaW9uIDogc3ludGF4XzEuU3ludGF4LkJpbmFyeUV4cHJlc3Npb247XHJcblx0ICAgICAgICB0aGlzLm9wZXJhdG9yID0gb3BlcmF0b3I7XHJcblx0ICAgICAgICB0aGlzLmxlZnQgPSBsZWZ0O1xyXG5cdCAgICAgICAgdGhpcy5yaWdodCA9IHJpZ2h0O1xyXG5cdCAgICB9XHJcblx0ICAgIHJldHVybiBCaW5hcnlFeHByZXNzaW9uO1xyXG5cdH0oKSk7XHJcblx0ZXhwb3J0cy5CaW5hcnlFeHByZXNzaW9uID0gQmluYXJ5RXhwcmVzc2lvbjtcclxuXHR2YXIgQmxvY2tTdGF0ZW1lbnQgPSAoZnVuY3Rpb24gKCkge1xyXG5cdCAgICBmdW5jdGlvbiBCbG9ja1N0YXRlbWVudChib2R5KSB7XHJcblx0ICAgICAgICB0aGlzLnR5cGUgPSBzeW50YXhfMS5TeW50YXguQmxvY2tTdGF0ZW1lbnQ7XHJcblx0ICAgICAgICB0aGlzLmJvZHkgPSBib2R5O1xyXG5cdCAgICB9XHJcblx0ICAgIHJldHVybiBCbG9ja1N0YXRlbWVudDtcclxuXHR9KCkpO1xyXG5cdGV4cG9ydHMuQmxvY2tTdGF0ZW1lbnQgPSBCbG9ja1N0YXRlbWVudDtcclxuXHR2YXIgQnJlYWtTdGF0ZW1lbnQgPSAoZnVuY3Rpb24gKCkge1xyXG5cdCAgICBmdW5jdGlvbiBCcmVha1N0YXRlbWVudChsYWJlbCkge1xyXG5cdCAgICAgICAgdGhpcy50eXBlID0gc3ludGF4XzEuU3ludGF4LkJyZWFrU3RhdGVtZW50O1xyXG5cdCAgICAgICAgdGhpcy5sYWJlbCA9IGxhYmVsO1xyXG5cdCAgICB9XHJcblx0ICAgIHJldHVybiBCcmVha1N0YXRlbWVudDtcclxuXHR9KCkpO1xyXG5cdGV4cG9ydHMuQnJlYWtTdGF0ZW1lbnQgPSBCcmVha1N0YXRlbWVudDtcclxuXHR2YXIgQ2FsbEV4cHJlc3Npb24gPSAoZnVuY3Rpb24gKCkge1xyXG5cdCAgICBmdW5jdGlvbiBDYWxsRXhwcmVzc2lvbihjYWxsZWUsIGFyZ3MpIHtcclxuXHQgICAgICAgIHRoaXMudHlwZSA9IHN5bnRheF8xLlN5bnRheC5DYWxsRXhwcmVzc2lvbjtcclxuXHQgICAgICAgIHRoaXMuY2FsbGVlID0gY2FsbGVlO1xyXG5cdCAgICAgICAgdGhpcy5hcmd1bWVudHMgPSBhcmdzO1xyXG5cdCAgICB9XHJcblx0ICAgIHJldHVybiBDYWxsRXhwcmVzc2lvbjtcclxuXHR9KCkpO1xyXG5cdGV4cG9ydHMuQ2FsbEV4cHJlc3Npb24gPSBDYWxsRXhwcmVzc2lvbjtcclxuXHR2YXIgQ2F0Y2hDbGF1c2UgPSAoZnVuY3Rpb24gKCkge1xyXG5cdCAgICBmdW5jdGlvbiBDYXRjaENsYXVzZShwYXJhbSwgYm9keSkge1xyXG5cdCAgICAgICAgdGhpcy50eXBlID0gc3ludGF4XzEuU3ludGF4LkNhdGNoQ2xhdXNlO1xyXG5cdCAgICAgICAgdGhpcy5wYXJhbSA9IHBhcmFtO1xyXG5cdCAgICAgICAgdGhpcy5ib2R5ID0gYm9keTtcclxuXHQgICAgfVxyXG5cdCAgICByZXR1cm4gQ2F0Y2hDbGF1c2U7XHJcblx0fSgpKTtcclxuXHRleHBvcnRzLkNhdGNoQ2xhdXNlID0gQ2F0Y2hDbGF1c2U7XHJcblx0dmFyIENsYXNzQm9keSA9IChmdW5jdGlvbiAoKSB7XHJcblx0ICAgIGZ1bmN0aW9uIENsYXNzQm9keShib2R5KSB7XHJcblx0ICAgICAgICB0aGlzLnR5cGUgPSBzeW50YXhfMS5TeW50YXguQ2xhc3NCb2R5O1xyXG5cdCAgICAgICAgdGhpcy5ib2R5ID0gYm9keTtcclxuXHQgICAgfVxyXG5cdCAgICByZXR1cm4gQ2xhc3NCb2R5O1xyXG5cdH0oKSk7XHJcblx0ZXhwb3J0cy5DbGFzc0JvZHkgPSBDbGFzc0JvZHk7XHJcblx0dmFyIENsYXNzRGVjbGFyYXRpb24gPSAoZnVuY3Rpb24gKCkge1xyXG5cdCAgICBmdW5jdGlvbiBDbGFzc0RlY2xhcmF0aW9uKGlkLCBzdXBlckNsYXNzLCBib2R5KSB7XHJcblx0ICAgICAgICB0aGlzLnR5cGUgPSBzeW50YXhfMS5TeW50YXguQ2xhc3NEZWNsYXJhdGlvbjtcclxuXHQgICAgICAgIHRoaXMuaWQgPSBpZDtcclxuXHQgICAgICAgIHRoaXMuc3VwZXJDbGFzcyA9IHN1cGVyQ2xhc3M7XHJcblx0ICAgICAgICB0aGlzLmJvZHkgPSBib2R5O1xyXG5cdCAgICB9XHJcblx0ICAgIHJldHVybiBDbGFzc0RlY2xhcmF0aW9uO1xyXG5cdH0oKSk7XHJcblx0ZXhwb3J0cy5DbGFzc0RlY2xhcmF0aW9uID0gQ2xhc3NEZWNsYXJhdGlvbjtcclxuXHR2YXIgQ2xhc3NFeHByZXNzaW9uID0gKGZ1bmN0aW9uICgpIHtcclxuXHQgICAgZnVuY3Rpb24gQ2xhc3NFeHByZXNzaW9uKGlkLCBzdXBlckNsYXNzLCBib2R5KSB7XHJcblx0ICAgICAgICB0aGlzLnR5cGUgPSBzeW50YXhfMS5TeW50YXguQ2xhc3NFeHByZXNzaW9uO1xyXG5cdCAgICAgICAgdGhpcy5pZCA9IGlkO1xyXG5cdCAgICAgICAgdGhpcy5zdXBlckNsYXNzID0gc3VwZXJDbGFzcztcclxuXHQgICAgICAgIHRoaXMuYm9keSA9IGJvZHk7XHJcblx0ICAgIH1cclxuXHQgICAgcmV0dXJuIENsYXNzRXhwcmVzc2lvbjtcclxuXHR9KCkpO1xyXG5cdGV4cG9ydHMuQ2xhc3NFeHByZXNzaW9uID0gQ2xhc3NFeHByZXNzaW9uO1xyXG5cdHZhciBDb21wdXRlZE1lbWJlckV4cHJlc3Npb24gPSAoZnVuY3Rpb24gKCkge1xyXG5cdCAgICBmdW5jdGlvbiBDb21wdXRlZE1lbWJlckV4cHJlc3Npb24ob2JqZWN0LCBwcm9wZXJ0eSkge1xyXG5cdCAgICAgICAgdGhpcy50eXBlID0gc3ludGF4XzEuU3ludGF4Lk1lbWJlckV4cHJlc3Npb247XHJcblx0ICAgICAgICB0aGlzLmNvbXB1dGVkID0gdHJ1ZTtcclxuXHQgICAgICAgIHRoaXMub2JqZWN0ID0gb2JqZWN0O1xyXG5cdCAgICAgICAgdGhpcy5wcm9wZXJ0eSA9IHByb3BlcnR5O1xyXG5cdCAgICB9XHJcblx0ICAgIHJldHVybiBDb21wdXRlZE1lbWJlckV4cHJlc3Npb247XHJcblx0fSgpKTtcclxuXHRleHBvcnRzLkNvbXB1dGVkTWVtYmVyRXhwcmVzc2lvbiA9IENvbXB1dGVkTWVtYmVyRXhwcmVzc2lvbjtcclxuXHR2YXIgQ29uZGl0aW9uYWxFeHByZXNzaW9uID0gKGZ1bmN0aW9uICgpIHtcclxuXHQgICAgZnVuY3Rpb24gQ29uZGl0aW9uYWxFeHByZXNzaW9uKHRlc3QsIGNvbnNlcXVlbnQsIGFsdGVybmF0ZSkge1xyXG5cdCAgICAgICAgdGhpcy50eXBlID0gc3ludGF4XzEuU3ludGF4LkNvbmRpdGlvbmFsRXhwcmVzc2lvbjtcclxuXHQgICAgICAgIHRoaXMudGVzdCA9IHRlc3Q7XHJcblx0ICAgICAgICB0aGlzLmNvbnNlcXVlbnQgPSBjb25zZXF1ZW50O1xyXG5cdCAgICAgICAgdGhpcy5hbHRlcm5hdGUgPSBhbHRlcm5hdGU7XHJcblx0ICAgIH1cclxuXHQgICAgcmV0dXJuIENvbmRpdGlvbmFsRXhwcmVzc2lvbjtcclxuXHR9KCkpO1xyXG5cdGV4cG9ydHMuQ29uZGl0aW9uYWxFeHByZXNzaW9uID0gQ29uZGl0aW9uYWxFeHByZXNzaW9uO1xyXG5cdHZhciBDb250aW51ZVN0YXRlbWVudCA9IChmdW5jdGlvbiAoKSB7XHJcblx0ICAgIGZ1bmN0aW9uIENvbnRpbnVlU3RhdGVtZW50KGxhYmVsKSB7XHJcblx0ICAgICAgICB0aGlzLnR5cGUgPSBzeW50YXhfMS5TeW50YXguQ29udGludWVTdGF0ZW1lbnQ7XHJcblx0ICAgICAgICB0aGlzLmxhYmVsID0gbGFiZWw7XHJcblx0ICAgIH1cclxuXHQgICAgcmV0dXJuIENvbnRpbnVlU3RhdGVtZW50O1xyXG5cdH0oKSk7XHJcblx0ZXhwb3J0cy5Db250aW51ZVN0YXRlbWVudCA9IENvbnRpbnVlU3RhdGVtZW50O1xyXG5cdHZhciBEZWJ1Z2dlclN0YXRlbWVudCA9IChmdW5jdGlvbiAoKSB7XHJcblx0ICAgIGZ1bmN0aW9uIERlYnVnZ2VyU3RhdGVtZW50KCkge1xyXG5cdCAgICAgICAgdGhpcy50eXBlID0gc3ludGF4XzEuU3ludGF4LkRlYnVnZ2VyU3RhdGVtZW50O1xyXG5cdCAgICB9XHJcblx0ICAgIHJldHVybiBEZWJ1Z2dlclN0YXRlbWVudDtcclxuXHR9KCkpO1xyXG5cdGV4cG9ydHMuRGVidWdnZXJTdGF0ZW1lbnQgPSBEZWJ1Z2dlclN0YXRlbWVudDtcclxuXHR2YXIgRGlyZWN0aXZlID0gKGZ1bmN0aW9uICgpIHtcclxuXHQgICAgZnVuY3Rpb24gRGlyZWN0aXZlKGV4cHJlc3Npb24sIGRpcmVjdGl2ZSkge1xyXG5cdCAgICAgICAgdGhpcy50eXBlID0gc3ludGF4XzEuU3ludGF4LkV4cHJlc3Npb25TdGF0ZW1lbnQ7XHJcblx0ICAgICAgICB0aGlzLmV4cHJlc3Npb24gPSBleHByZXNzaW9uO1xyXG5cdCAgICAgICAgdGhpcy5kaXJlY3RpdmUgPSBkaXJlY3RpdmU7XHJcblx0ICAgIH1cclxuXHQgICAgcmV0dXJuIERpcmVjdGl2ZTtcclxuXHR9KCkpO1xyXG5cdGV4cG9ydHMuRGlyZWN0aXZlID0gRGlyZWN0aXZlO1xyXG5cdHZhciBEb1doaWxlU3RhdGVtZW50ID0gKGZ1bmN0aW9uICgpIHtcclxuXHQgICAgZnVuY3Rpb24gRG9XaGlsZVN0YXRlbWVudChib2R5LCB0ZXN0KSB7XHJcblx0ICAgICAgICB0aGlzLnR5cGUgPSBzeW50YXhfMS5TeW50YXguRG9XaGlsZVN0YXRlbWVudDtcclxuXHQgICAgICAgIHRoaXMuYm9keSA9IGJvZHk7XHJcblx0ICAgICAgICB0aGlzLnRlc3QgPSB0ZXN0O1xyXG5cdCAgICB9XHJcblx0ICAgIHJldHVybiBEb1doaWxlU3RhdGVtZW50O1xyXG5cdH0oKSk7XHJcblx0ZXhwb3J0cy5Eb1doaWxlU3RhdGVtZW50ID0gRG9XaGlsZVN0YXRlbWVudDtcclxuXHR2YXIgRW1wdHlTdGF0ZW1lbnQgPSAoZnVuY3Rpb24gKCkge1xyXG5cdCAgICBmdW5jdGlvbiBFbXB0eVN0YXRlbWVudCgpIHtcclxuXHQgICAgICAgIHRoaXMudHlwZSA9IHN5bnRheF8xLlN5bnRheC5FbXB0eVN0YXRlbWVudDtcclxuXHQgICAgfVxyXG5cdCAgICByZXR1cm4gRW1wdHlTdGF0ZW1lbnQ7XHJcblx0fSgpKTtcclxuXHRleHBvcnRzLkVtcHR5U3RhdGVtZW50ID0gRW1wdHlTdGF0ZW1lbnQ7XHJcblx0dmFyIEV4cG9ydEFsbERlY2xhcmF0aW9uID0gKGZ1bmN0aW9uICgpIHtcclxuXHQgICAgZnVuY3Rpb24gRXhwb3J0QWxsRGVjbGFyYXRpb24oc291cmNlKSB7XHJcblx0ICAgICAgICB0aGlzLnR5cGUgPSBzeW50YXhfMS5TeW50YXguRXhwb3J0QWxsRGVjbGFyYXRpb247XHJcblx0ICAgICAgICB0aGlzLnNvdXJjZSA9IHNvdXJjZTtcclxuXHQgICAgfVxyXG5cdCAgICByZXR1cm4gRXhwb3J0QWxsRGVjbGFyYXRpb247XHJcblx0fSgpKTtcclxuXHRleHBvcnRzLkV4cG9ydEFsbERlY2xhcmF0aW9uID0gRXhwb3J0QWxsRGVjbGFyYXRpb247XHJcblx0dmFyIEV4cG9ydERlZmF1bHREZWNsYXJhdGlvbiA9IChmdW5jdGlvbiAoKSB7XHJcblx0ICAgIGZ1bmN0aW9uIEV4cG9ydERlZmF1bHREZWNsYXJhdGlvbihkZWNsYXJhdGlvbikge1xyXG5cdCAgICAgICAgdGhpcy50eXBlID0gc3ludGF4XzEuU3ludGF4LkV4cG9ydERlZmF1bHREZWNsYXJhdGlvbjtcclxuXHQgICAgICAgIHRoaXMuZGVjbGFyYXRpb24gPSBkZWNsYXJhdGlvbjtcclxuXHQgICAgfVxyXG5cdCAgICByZXR1cm4gRXhwb3J0RGVmYXVsdERlY2xhcmF0aW9uO1xyXG5cdH0oKSk7XHJcblx0ZXhwb3J0cy5FeHBvcnREZWZhdWx0RGVjbGFyYXRpb24gPSBFeHBvcnREZWZhdWx0RGVjbGFyYXRpb247XHJcblx0dmFyIEV4cG9ydE5hbWVkRGVjbGFyYXRpb24gPSAoZnVuY3Rpb24gKCkge1xyXG5cdCAgICBmdW5jdGlvbiBFeHBvcnROYW1lZERlY2xhcmF0aW9uKGRlY2xhcmF0aW9uLCBzcGVjaWZpZXJzLCBzb3VyY2UpIHtcclxuXHQgICAgICAgIHRoaXMudHlwZSA9IHN5bnRheF8xLlN5bnRheC5FeHBvcnROYW1lZERlY2xhcmF0aW9uO1xyXG5cdCAgICAgICAgdGhpcy5kZWNsYXJhdGlvbiA9IGRlY2xhcmF0aW9uO1xyXG5cdCAgICAgICAgdGhpcy5zcGVjaWZpZXJzID0gc3BlY2lmaWVycztcclxuXHQgICAgICAgIHRoaXMuc291cmNlID0gc291cmNlO1xyXG5cdCAgICB9XHJcblx0ICAgIHJldHVybiBFeHBvcnROYW1lZERlY2xhcmF0aW9uO1xyXG5cdH0oKSk7XHJcblx0ZXhwb3J0cy5FeHBvcnROYW1lZERlY2xhcmF0aW9uID0gRXhwb3J0TmFtZWREZWNsYXJhdGlvbjtcclxuXHR2YXIgRXhwb3J0U3BlY2lmaWVyID0gKGZ1bmN0aW9uICgpIHtcclxuXHQgICAgZnVuY3Rpb24gRXhwb3J0U3BlY2lmaWVyKGxvY2FsLCBleHBvcnRlZCkge1xyXG5cdCAgICAgICAgdGhpcy50eXBlID0gc3ludGF4XzEuU3ludGF4LkV4cG9ydFNwZWNpZmllcjtcclxuXHQgICAgICAgIHRoaXMuZXhwb3J0ZWQgPSBleHBvcnRlZDtcclxuXHQgICAgICAgIHRoaXMubG9jYWwgPSBsb2NhbDtcclxuXHQgICAgfVxyXG5cdCAgICByZXR1cm4gRXhwb3J0U3BlY2lmaWVyO1xyXG5cdH0oKSk7XHJcblx0ZXhwb3J0cy5FeHBvcnRTcGVjaWZpZXIgPSBFeHBvcnRTcGVjaWZpZXI7XHJcblx0dmFyIEV4cHJlc3Npb25TdGF0ZW1lbnQgPSAoZnVuY3Rpb24gKCkge1xyXG5cdCAgICBmdW5jdGlvbiBFeHByZXNzaW9uU3RhdGVtZW50KGV4cHJlc3Npb24pIHtcclxuXHQgICAgICAgIHRoaXMudHlwZSA9IHN5bnRheF8xLlN5bnRheC5FeHByZXNzaW9uU3RhdGVtZW50O1xyXG5cdCAgICAgICAgdGhpcy5leHByZXNzaW9uID0gZXhwcmVzc2lvbjtcclxuXHQgICAgfVxyXG5cdCAgICByZXR1cm4gRXhwcmVzc2lvblN0YXRlbWVudDtcclxuXHR9KCkpO1xyXG5cdGV4cG9ydHMuRXhwcmVzc2lvblN0YXRlbWVudCA9IEV4cHJlc3Npb25TdGF0ZW1lbnQ7XHJcblx0dmFyIEZvckluU3RhdGVtZW50ID0gKGZ1bmN0aW9uICgpIHtcclxuXHQgICAgZnVuY3Rpb24gRm9ySW5TdGF0ZW1lbnQobGVmdCwgcmlnaHQsIGJvZHkpIHtcclxuXHQgICAgICAgIHRoaXMudHlwZSA9IHN5bnRheF8xLlN5bnRheC5Gb3JJblN0YXRlbWVudDtcclxuXHQgICAgICAgIHRoaXMubGVmdCA9IGxlZnQ7XHJcblx0ICAgICAgICB0aGlzLnJpZ2h0ID0gcmlnaHQ7XHJcblx0ICAgICAgICB0aGlzLmJvZHkgPSBib2R5O1xyXG5cdCAgICAgICAgdGhpcy5lYWNoID0gZmFsc2U7XHJcblx0ICAgIH1cclxuXHQgICAgcmV0dXJuIEZvckluU3RhdGVtZW50O1xyXG5cdH0oKSk7XHJcblx0ZXhwb3J0cy5Gb3JJblN0YXRlbWVudCA9IEZvckluU3RhdGVtZW50O1xyXG5cdHZhciBGb3JPZlN0YXRlbWVudCA9IChmdW5jdGlvbiAoKSB7XHJcblx0ICAgIGZ1bmN0aW9uIEZvck9mU3RhdGVtZW50KGxlZnQsIHJpZ2h0LCBib2R5KSB7XHJcblx0ICAgICAgICB0aGlzLnR5cGUgPSBzeW50YXhfMS5TeW50YXguRm9yT2ZTdGF0ZW1lbnQ7XHJcblx0ICAgICAgICB0aGlzLmxlZnQgPSBsZWZ0O1xyXG5cdCAgICAgICAgdGhpcy5yaWdodCA9IHJpZ2h0O1xyXG5cdCAgICAgICAgdGhpcy5ib2R5ID0gYm9keTtcclxuXHQgICAgfVxyXG5cdCAgICByZXR1cm4gRm9yT2ZTdGF0ZW1lbnQ7XHJcblx0fSgpKTtcclxuXHRleHBvcnRzLkZvck9mU3RhdGVtZW50ID0gRm9yT2ZTdGF0ZW1lbnQ7XHJcblx0dmFyIEZvclN0YXRlbWVudCA9IChmdW5jdGlvbiAoKSB7XHJcblx0ICAgIGZ1bmN0aW9uIEZvclN0YXRlbWVudChpbml0LCB0ZXN0LCB1cGRhdGUsIGJvZHkpIHtcclxuXHQgICAgICAgIHRoaXMudHlwZSA9IHN5bnRheF8xLlN5bnRheC5Gb3JTdGF0ZW1lbnQ7XHJcblx0ICAgICAgICB0aGlzLmluaXQgPSBpbml0O1xyXG5cdCAgICAgICAgdGhpcy50ZXN0ID0gdGVzdDtcclxuXHQgICAgICAgIHRoaXMudXBkYXRlID0gdXBkYXRlO1xyXG5cdCAgICAgICAgdGhpcy5ib2R5ID0gYm9keTtcclxuXHQgICAgfVxyXG5cdCAgICByZXR1cm4gRm9yU3RhdGVtZW50O1xyXG5cdH0oKSk7XHJcblx0ZXhwb3J0cy5Gb3JTdGF0ZW1lbnQgPSBGb3JTdGF0ZW1lbnQ7XHJcblx0dmFyIEZ1bmN0aW9uRGVjbGFyYXRpb24gPSAoZnVuY3Rpb24gKCkge1xyXG5cdCAgICBmdW5jdGlvbiBGdW5jdGlvbkRlY2xhcmF0aW9uKGlkLCBwYXJhbXMsIGJvZHksIGdlbmVyYXRvcikge1xyXG5cdCAgICAgICAgdGhpcy50eXBlID0gc3ludGF4XzEuU3ludGF4LkZ1bmN0aW9uRGVjbGFyYXRpb247XHJcblx0ICAgICAgICB0aGlzLmlkID0gaWQ7XHJcblx0ICAgICAgICB0aGlzLnBhcmFtcyA9IHBhcmFtcztcclxuXHQgICAgICAgIHRoaXMuYm9keSA9IGJvZHk7XHJcblx0ICAgICAgICB0aGlzLmdlbmVyYXRvciA9IGdlbmVyYXRvcjtcclxuXHQgICAgICAgIHRoaXMuZXhwcmVzc2lvbiA9IGZhbHNlO1xyXG5cdCAgICAgICAgdGhpcy5hc3luYyA9IGZhbHNlO1xyXG5cdCAgICB9XHJcblx0ICAgIHJldHVybiBGdW5jdGlvbkRlY2xhcmF0aW9uO1xyXG5cdH0oKSk7XHJcblx0ZXhwb3J0cy5GdW5jdGlvbkRlY2xhcmF0aW9uID0gRnVuY3Rpb25EZWNsYXJhdGlvbjtcclxuXHR2YXIgRnVuY3Rpb25FeHByZXNzaW9uID0gKGZ1bmN0aW9uICgpIHtcclxuXHQgICAgZnVuY3Rpb24gRnVuY3Rpb25FeHByZXNzaW9uKGlkLCBwYXJhbXMsIGJvZHksIGdlbmVyYXRvcikge1xyXG5cdCAgICAgICAgdGhpcy50eXBlID0gc3ludGF4XzEuU3ludGF4LkZ1bmN0aW9uRXhwcmVzc2lvbjtcclxuXHQgICAgICAgIHRoaXMuaWQgPSBpZDtcclxuXHQgICAgICAgIHRoaXMucGFyYW1zID0gcGFyYW1zO1xyXG5cdCAgICAgICAgdGhpcy5ib2R5ID0gYm9keTtcclxuXHQgICAgICAgIHRoaXMuZ2VuZXJhdG9yID0gZ2VuZXJhdG9yO1xyXG5cdCAgICAgICAgdGhpcy5leHByZXNzaW9uID0gZmFsc2U7XHJcblx0ICAgICAgICB0aGlzLmFzeW5jID0gZmFsc2U7XHJcblx0ICAgIH1cclxuXHQgICAgcmV0dXJuIEZ1bmN0aW9uRXhwcmVzc2lvbjtcclxuXHR9KCkpO1xyXG5cdGV4cG9ydHMuRnVuY3Rpb25FeHByZXNzaW9uID0gRnVuY3Rpb25FeHByZXNzaW9uO1xyXG5cdHZhciBJZGVudGlmaWVyID0gKGZ1bmN0aW9uICgpIHtcclxuXHQgICAgZnVuY3Rpb24gSWRlbnRpZmllcihuYW1lKSB7XHJcblx0ICAgICAgICB0aGlzLnR5cGUgPSBzeW50YXhfMS5TeW50YXguSWRlbnRpZmllcjtcclxuXHQgICAgICAgIHRoaXMubmFtZSA9IG5hbWU7XHJcblx0ICAgIH1cclxuXHQgICAgcmV0dXJuIElkZW50aWZpZXI7XHJcblx0fSgpKTtcclxuXHRleHBvcnRzLklkZW50aWZpZXIgPSBJZGVudGlmaWVyO1xyXG5cdHZhciBJZlN0YXRlbWVudCA9IChmdW5jdGlvbiAoKSB7XHJcblx0ICAgIGZ1bmN0aW9uIElmU3RhdGVtZW50KHRlc3QsIGNvbnNlcXVlbnQsIGFsdGVybmF0ZSkge1xyXG5cdCAgICAgICAgdGhpcy50eXBlID0gc3ludGF4XzEuU3ludGF4LklmU3RhdGVtZW50O1xyXG5cdCAgICAgICAgdGhpcy50ZXN0ID0gdGVzdDtcclxuXHQgICAgICAgIHRoaXMuY29uc2VxdWVudCA9IGNvbnNlcXVlbnQ7XHJcblx0ICAgICAgICB0aGlzLmFsdGVybmF0ZSA9IGFsdGVybmF0ZTtcclxuXHQgICAgfVxyXG5cdCAgICByZXR1cm4gSWZTdGF0ZW1lbnQ7XHJcblx0fSgpKTtcclxuXHRleHBvcnRzLklmU3RhdGVtZW50ID0gSWZTdGF0ZW1lbnQ7XHJcblx0dmFyIEltcG9ydERlY2xhcmF0aW9uID0gKGZ1bmN0aW9uICgpIHtcclxuXHQgICAgZnVuY3Rpb24gSW1wb3J0RGVjbGFyYXRpb24oc3BlY2lmaWVycywgc291cmNlKSB7XHJcblx0ICAgICAgICB0aGlzLnR5cGUgPSBzeW50YXhfMS5TeW50YXguSW1wb3J0RGVjbGFyYXRpb247XHJcblx0ICAgICAgICB0aGlzLnNwZWNpZmllcnMgPSBzcGVjaWZpZXJzO1xyXG5cdCAgICAgICAgdGhpcy5zb3VyY2UgPSBzb3VyY2U7XHJcblx0ICAgIH1cclxuXHQgICAgcmV0dXJuIEltcG9ydERlY2xhcmF0aW9uO1xyXG5cdH0oKSk7XHJcblx0ZXhwb3J0cy5JbXBvcnREZWNsYXJhdGlvbiA9IEltcG9ydERlY2xhcmF0aW9uO1xyXG5cdHZhciBJbXBvcnREZWZhdWx0U3BlY2lmaWVyID0gKGZ1bmN0aW9uICgpIHtcclxuXHQgICAgZnVuY3Rpb24gSW1wb3J0RGVmYXVsdFNwZWNpZmllcihsb2NhbCkge1xyXG5cdCAgICAgICAgdGhpcy50eXBlID0gc3ludGF4XzEuU3ludGF4LkltcG9ydERlZmF1bHRTcGVjaWZpZXI7XHJcblx0ICAgICAgICB0aGlzLmxvY2FsID0gbG9jYWw7XHJcblx0ICAgIH1cclxuXHQgICAgcmV0dXJuIEltcG9ydERlZmF1bHRTcGVjaWZpZXI7XHJcblx0fSgpKTtcclxuXHRleHBvcnRzLkltcG9ydERlZmF1bHRTcGVjaWZpZXIgPSBJbXBvcnREZWZhdWx0U3BlY2lmaWVyO1xyXG5cdHZhciBJbXBvcnROYW1lc3BhY2VTcGVjaWZpZXIgPSAoZnVuY3Rpb24gKCkge1xyXG5cdCAgICBmdW5jdGlvbiBJbXBvcnROYW1lc3BhY2VTcGVjaWZpZXIobG9jYWwpIHtcclxuXHQgICAgICAgIHRoaXMudHlwZSA9IHN5bnRheF8xLlN5bnRheC5JbXBvcnROYW1lc3BhY2VTcGVjaWZpZXI7XHJcblx0ICAgICAgICB0aGlzLmxvY2FsID0gbG9jYWw7XHJcblx0ICAgIH1cclxuXHQgICAgcmV0dXJuIEltcG9ydE5hbWVzcGFjZVNwZWNpZmllcjtcclxuXHR9KCkpO1xyXG5cdGV4cG9ydHMuSW1wb3J0TmFtZXNwYWNlU3BlY2lmaWVyID0gSW1wb3J0TmFtZXNwYWNlU3BlY2lmaWVyO1xyXG5cdHZhciBJbXBvcnRTcGVjaWZpZXIgPSAoZnVuY3Rpb24gKCkge1xyXG5cdCAgICBmdW5jdGlvbiBJbXBvcnRTcGVjaWZpZXIobG9jYWwsIGltcG9ydGVkKSB7XHJcblx0ICAgICAgICB0aGlzLnR5cGUgPSBzeW50YXhfMS5TeW50YXguSW1wb3J0U3BlY2lmaWVyO1xyXG5cdCAgICAgICAgdGhpcy5sb2NhbCA9IGxvY2FsO1xyXG5cdCAgICAgICAgdGhpcy5pbXBvcnRlZCA9IGltcG9ydGVkO1xyXG5cdCAgICB9XHJcblx0ICAgIHJldHVybiBJbXBvcnRTcGVjaWZpZXI7XHJcblx0fSgpKTtcclxuXHRleHBvcnRzLkltcG9ydFNwZWNpZmllciA9IEltcG9ydFNwZWNpZmllcjtcclxuXHR2YXIgTGFiZWxlZFN0YXRlbWVudCA9IChmdW5jdGlvbiAoKSB7XHJcblx0ICAgIGZ1bmN0aW9uIExhYmVsZWRTdGF0ZW1lbnQobGFiZWwsIGJvZHkpIHtcclxuXHQgICAgICAgIHRoaXMudHlwZSA9IHN5bnRheF8xLlN5bnRheC5MYWJlbGVkU3RhdGVtZW50O1xyXG5cdCAgICAgICAgdGhpcy5sYWJlbCA9IGxhYmVsO1xyXG5cdCAgICAgICAgdGhpcy5ib2R5ID0gYm9keTtcclxuXHQgICAgfVxyXG5cdCAgICByZXR1cm4gTGFiZWxlZFN0YXRlbWVudDtcclxuXHR9KCkpO1xyXG5cdGV4cG9ydHMuTGFiZWxlZFN0YXRlbWVudCA9IExhYmVsZWRTdGF0ZW1lbnQ7XHJcblx0dmFyIExpdGVyYWwgPSAoZnVuY3Rpb24gKCkge1xyXG5cdCAgICBmdW5jdGlvbiBMaXRlcmFsKHZhbHVlLCByYXcpIHtcclxuXHQgICAgICAgIHRoaXMudHlwZSA9IHN5bnRheF8xLlN5bnRheC5MaXRlcmFsO1xyXG5cdCAgICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xyXG5cdCAgICAgICAgdGhpcy5yYXcgPSByYXc7XHJcblx0ICAgIH1cclxuXHQgICAgcmV0dXJuIExpdGVyYWw7XHJcblx0fSgpKTtcclxuXHRleHBvcnRzLkxpdGVyYWwgPSBMaXRlcmFsO1xyXG5cdHZhciBNZXRhUHJvcGVydHkgPSAoZnVuY3Rpb24gKCkge1xyXG5cdCAgICBmdW5jdGlvbiBNZXRhUHJvcGVydHkobWV0YSwgcHJvcGVydHkpIHtcclxuXHQgICAgICAgIHRoaXMudHlwZSA9IHN5bnRheF8xLlN5bnRheC5NZXRhUHJvcGVydHk7XHJcblx0ICAgICAgICB0aGlzLm1ldGEgPSBtZXRhO1xyXG5cdCAgICAgICAgdGhpcy5wcm9wZXJ0eSA9IHByb3BlcnR5O1xyXG5cdCAgICB9XHJcblx0ICAgIHJldHVybiBNZXRhUHJvcGVydHk7XHJcblx0fSgpKTtcclxuXHRleHBvcnRzLk1ldGFQcm9wZXJ0eSA9IE1ldGFQcm9wZXJ0eTtcclxuXHR2YXIgTWV0aG9kRGVmaW5pdGlvbiA9IChmdW5jdGlvbiAoKSB7XHJcblx0ICAgIGZ1bmN0aW9uIE1ldGhvZERlZmluaXRpb24oa2V5LCBjb21wdXRlZCwgdmFsdWUsIGtpbmQsIGlzU3RhdGljKSB7XHJcblx0ICAgICAgICB0aGlzLnR5cGUgPSBzeW50YXhfMS5TeW50YXguTWV0aG9kRGVmaW5pdGlvbjtcclxuXHQgICAgICAgIHRoaXMua2V5ID0ga2V5O1xyXG5cdCAgICAgICAgdGhpcy5jb21wdXRlZCA9IGNvbXB1dGVkO1xyXG5cdCAgICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xyXG5cdCAgICAgICAgdGhpcy5raW5kID0ga2luZDtcclxuXHQgICAgICAgIHRoaXMuc3RhdGljID0gaXNTdGF0aWM7XHJcblx0ICAgIH1cclxuXHQgICAgcmV0dXJuIE1ldGhvZERlZmluaXRpb247XHJcblx0fSgpKTtcclxuXHRleHBvcnRzLk1ldGhvZERlZmluaXRpb24gPSBNZXRob2REZWZpbml0aW9uO1xyXG5cdHZhciBNb2R1bGUgPSAoZnVuY3Rpb24gKCkge1xyXG5cdCAgICBmdW5jdGlvbiBNb2R1bGUoYm9keSkge1xyXG5cdCAgICAgICAgdGhpcy50eXBlID0gc3ludGF4XzEuU3ludGF4LlByb2dyYW07XHJcblx0ICAgICAgICB0aGlzLmJvZHkgPSBib2R5O1xyXG5cdCAgICAgICAgdGhpcy5zb3VyY2VUeXBlID0gJ21vZHVsZSc7XHJcblx0ICAgIH1cclxuXHQgICAgcmV0dXJuIE1vZHVsZTtcclxuXHR9KCkpO1xyXG5cdGV4cG9ydHMuTW9kdWxlID0gTW9kdWxlO1xyXG5cdHZhciBOZXdFeHByZXNzaW9uID0gKGZ1bmN0aW9uICgpIHtcclxuXHQgICAgZnVuY3Rpb24gTmV3RXhwcmVzc2lvbihjYWxsZWUsIGFyZ3MpIHtcclxuXHQgICAgICAgIHRoaXMudHlwZSA9IHN5bnRheF8xLlN5bnRheC5OZXdFeHByZXNzaW9uO1xyXG5cdCAgICAgICAgdGhpcy5jYWxsZWUgPSBjYWxsZWU7XHJcblx0ICAgICAgICB0aGlzLmFyZ3VtZW50cyA9IGFyZ3M7XHJcblx0ICAgIH1cclxuXHQgICAgcmV0dXJuIE5ld0V4cHJlc3Npb247XHJcblx0fSgpKTtcclxuXHRleHBvcnRzLk5ld0V4cHJlc3Npb24gPSBOZXdFeHByZXNzaW9uO1xyXG5cdHZhciBPYmplY3RFeHByZXNzaW9uID0gKGZ1bmN0aW9uICgpIHtcclxuXHQgICAgZnVuY3Rpb24gT2JqZWN0RXhwcmVzc2lvbihwcm9wZXJ0aWVzKSB7XHJcblx0ICAgICAgICB0aGlzLnR5cGUgPSBzeW50YXhfMS5TeW50YXguT2JqZWN0RXhwcmVzc2lvbjtcclxuXHQgICAgICAgIHRoaXMucHJvcGVydGllcyA9IHByb3BlcnRpZXM7XHJcblx0ICAgIH1cclxuXHQgICAgcmV0dXJuIE9iamVjdEV4cHJlc3Npb247XHJcblx0fSgpKTtcclxuXHRleHBvcnRzLk9iamVjdEV4cHJlc3Npb24gPSBPYmplY3RFeHByZXNzaW9uO1xyXG5cdHZhciBPYmplY3RQYXR0ZXJuID0gKGZ1bmN0aW9uICgpIHtcclxuXHQgICAgZnVuY3Rpb24gT2JqZWN0UGF0dGVybihwcm9wZXJ0aWVzKSB7XHJcblx0ICAgICAgICB0aGlzLnR5cGUgPSBzeW50YXhfMS5TeW50YXguT2JqZWN0UGF0dGVybjtcclxuXHQgICAgICAgIHRoaXMucHJvcGVydGllcyA9IHByb3BlcnRpZXM7XHJcblx0ICAgIH1cclxuXHQgICAgcmV0dXJuIE9iamVjdFBhdHRlcm47XHJcblx0fSgpKTtcclxuXHRleHBvcnRzLk9iamVjdFBhdHRlcm4gPSBPYmplY3RQYXR0ZXJuO1xyXG5cdHZhciBQcm9wZXJ0eSA9IChmdW5jdGlvbiAoKSB7XHJcblx0ICAgIGZ1bmN0aW9uIFByb3BlcnR5KGtpbmQsIGtleSwgY29tcHV0ZWQsIHZhbHVlLCBtZXRob2QsIHNob3J0aGFuZCkge1xyXG5cdCAgICAgICAgdGhpcy50eXBlID0gc3ludGF4XzEuU3ludGF4LlByb3BlcnR5O1xyXG5cdCAgICAgICAgdGhpcy5rZXkgPSBrZXk7XHJcblx0ICAgICAgICB0aGlzLmNvbXB1dGVkID0gY29tcHV0ZWQ7XHJcblx0ICAgICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XHJcblx0ICAgICAgICB0aGlzLmtpbmQgPSBraW5kO1xyXG5cdCAgICAgICAgdGhpcy5tZXRob2QgPSBtZXRob2Q7XHJcblx0ICAgICAgICB0aGlzLnNob3J0aGFuZCA9IHNob3J0aGFuZDtcclxuXHQgICAgfVxyXG5cdCAgICByZXR1cm4gUHJvcGVydHk7XHJcblx0fSgpKTtcclxuXHRleHBvcnRzLlByb3BlcnR5ID0gUHJvcGVydHk7XHJcblx0dmFyIFJlZ2V4TGl0ZXJhbCA9IChmdW5jdGlvbiAoKSB7XHJcblx0ICAgIGZ1bmN0aW9uIFJlZ2V4TGl0ZXJhbCh2YWx1ZSwgcmF3LCBwYXR0ZXJuLCBmbGFncykge1xyXG5cdCAgICAgICAgdGhpcy50eXBlID0gc3ludGF4XzEuU3ludGF4LkxpdGVyYWw7XHJcblx0ICAgICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XHJcblx0ICAgICAgICB0aGlzLnJhdyA9IHJhdztcclxuXHQgICAgICAgIHRoaXMucmVnZXggPSB7IHBhdHRlcm46IHBhdHRlcm4sIGZsYWdzOiBmbGFncyB9O1xyXG5cdCAgICB9XHJcblx0ICAgIHJldHVybiBSZWdleExpdGVyYWw7XHJcblx0fSgpKTtcclxuXHRleHBvcnRzLlJlZ2V4TGl0ZXJhbCA9IFJlZ2V4TGl0ZXJhbDtcclxuXHR2YXIgUmVzdEVsZW1lbnQgPSAoZnVuY3Rpb24gKCkge1xyXG5cdCAgICBmdW5jdGlvbiBSZXN0RWxlbWVudChhcmd1bWVudCkge1xyXG5cdCAgICAgICAgdGhpcy50eXBlID0gc3ludGF4XzEuU3ludGF4LlJlc3RFbGVtZW50O1xyXG5cdCAgICAgICAgdGhpcy5hcmd1bWVudCA9IGFyZ3VtZW50O1xyXG5cdCAgICB9XHJcblx0ICAgIHJldHVybiBSZXN0RWxlbWVudDtcclxuXHR9KCkpO1xyXG5cdGV4cG9ydHMuUmVzdEVsZW1lbnQgPSBSZXN0RWxlbWVudDtcclxuXHR2YXIgUmV0dXJuU3RhdGVtZW50ID0gKGZ1bmN0aW9uICgpIHtcclxuXHQgICAgZnVuY3Rpb24gUmV0dXJuU3RhdGVtZW50KGFyZ3VtZW50KSB7XHJcblx0ICAgICAgICB0aGlzLnR5cGUgPSBzeW50YXhfMS5TeW50YXguUmV0dXJuU3RhdGVtZW50O1xyXG5cdCAgICAgICAgdGhpcy5hcmd1bWVudCA9IGFyZ3VtZW50O1xyXG5cdCAgICB9XHJcblx0ICAgIHJldHVybiBSZXR1cm5TdGF0ZW1lbnQ7XHJcblx0fSgpKTtcclxuXHRleHBvcnRzLlJldHVyblN0YXRlbWVudCA9IFJldHVyblN0YXRlbWVudDtcclxuXHR2YXIgU2NyaXB0ID0gKGZ1bmN0aW9uICgpIHtcclxuXHQgICAgZnVuY3Rpb24gU2NyaXB0KGJvZHkpIHtcclxuXHQgICAgICAgIHRoaXMudHlwZSA9IHN5bnRheF8xLlN5bnRheC5Qcm9ncmFtO1xyXG5cdCAgICAgICAgdGhpcy5ib2R5ID0gYm9keTtcclxuXHQgICAgICAgIHRoaXMuc291cmNlVHlwZSA9ICdzY3JpcHQnO1xyXG5cdCAgICB9XHJcblx0ICAgIHJldHVybiBTY3JpcHQ7XHJcblx0fSgpKTtcclxuXHRleHBvcnRzLlNjcmlwdCA9IFNjcmlwdDtcclxuXHR2YXIgU2VxdWVuY2VFeHByZXNzaW9uID0gKGZ1bmN0aW9uICgpIHtcclxuXHQgICAgZnVuY3Rpb24gU2VxdWVuY2VFeHByZXNzaW9uKGV4cHJlc3Npb25zKSB7XHJcblx0ICAgICAgICB0aGlzLnR5cGUgPSBzeW50YXhfMS5TeW50YXguU2VxdWVuY2VFeHByZXNzaW9uO1xyXG5cdCAgICAgICAgdGhpcy5leHByZXNzaW9ucyA9IGV4cHJlc3Npb25zO1xyXG5cdCAgICB9XHJcblx0ICAgIHJldHVybiBTZXF1ZW5jZUV4cHJlc3Npb247XHJcblx0fSgpKTtcclxuXHRleHBvcnRzLlNlcXVlbmNlRXhwcmVzc2lvbiA9IFNlcXVlbmNlRXhwcmVzc2lvbjtcclxuXHR2YXIgU3ByZWFkRWxlbWVudCA9IChmdW5jdGlvbiAoKSB7XHJcblx0ICAgIGZ1bmN0aW9uIFNwcmVhZEVsZW1lbnQoYXJndW1lbnQpIHtcclxuXHQgICAgICAgIHRoaXMudHlwZSA9IHN5bnRheF8xLlN5bnRheC5TcHJlYWRFbGVtZW50O1xyXG5cdCAgICAgICAgdGhpcy5hcmd1bWVudCA9IGFyZ3VtZW50O1xyXG5cdCAgICB9XHJcblx0ICAgIHJldHVybiBTcHJlYWRFbGVtZW50O1xyXG5cdH0oKSk7XHJcblx0ZXhwb3J0cy5TcHJlYWRFbGVtZW50ID0gU3ByZWFkRWxlbWVudDtcclxuXHR2YXIgU3RhdGljTWVtYmVyRXhwcmVzc2lvbiA9IChmdW5jdGlvbiAoKSB7XHJcblx0ICAgIGZ1bmN0aW9uIFN0YXRpY01lbWJlckV4cHJlc3Npb24ob2JqZWN0LCBwcm9wZXJ0eSkge1xyXG5cdCAgICAgICAgdGhpcy50eXBlID0gc3ludGF4XzEuU3ludGF4Lk1lbWJlckV4cHJlc3Npb247XHJcblx0ICAgICAgICB0aGlzLmNvbXB1dGVkID0gZmFsc2U7XHJcblx0ICAgICAgICB0aGlzLm9iamVjdCA9IG9iamVjdDtcclxuXHQgICAgICAgIHRoaXMucHJvcGVydHkgPSBwcm9wZXJ0eTtcclxuXHQgICAgfVxyXG5cdCAgICByZXR1cm4gU3RhdGljTWVtYmVyRXhwcmVzc2lvbjtcclxuXHR9KCkpO1xyXG5cdGV4cG9ydHMuU3RhdGljTWVtYmVyRXhwcmVzc2lvbiA9IFN0YXRpY01lbWJlckV4cHJlc3Npb247XHJcblx0dmFyIFN1cGVyID0gKGZ1bmN0aW9uICgpIHtcclxuXHQgICAgZnVuY3Rpb24gU3VwZXIoKSB7XHJcblx0ICAgICAgICB0aGlzLnR5cGUgPSBzeW50YXhfMS5TeW50YXguU3VwZXI7XHJcblx0ICAgIH1cclxuXHQgICAgcmV0dXJuIFN1cGVyO1xyXG5cdH0oKSk7XHJcblx0ZXhwb3J0cy5TdXBlciA9IFN1cGVyO1xyXG5cdHZhciBTd2l0Y2hDYXNlID0gKGZ1bmN0aW9uICgpIHtcclxuXHQgICAgZnVuY3Rpb24gU3dpdGNoQ2FzZSh0ZXN0LCBjb25zZXF1ZW50KSB7XHJcblx0ICAgICAgICB0aGlzLnR5cGUgPSBzeW50YXhfMS5TeW50YXguU3dpdGNoQ2FzZTtcclxuXHQgICAgICAgIHRoaXMudGVzdCA9IHRlc3Q7XHJcblx0ICAgICAgICB0aGlzLmNvbnNlcXVlbnQgPSBjb25zZXF1ZW50O1xyXG5cdCAgICB9XHJcblx0ICAgIHJldHVybiBTd2l0Y2hDYXNlO1xyXG5cdH0oKSk7XHJcblx0ZXhwb3J0cy5Td2l0Y2hDYXNlID0gU3dpdGNoQ2FzZTtcclxuXHR2YXIgU3dpdGNoU3RhdGVtZW50ID0gKGZ1bmN0aW9uICgpIHtcclxuXHQgICAgZnVuY3Rpb24gU3dpdGNoU3RhdGVtZW50KGRpc2NyaW1pbmFudCwgY2FzZXMpIHtcclxuXHQgICAgICAgIHRoaXMudHlwZSA9IHN5bnRheF8xLlN5bnRheC5Td2l0Y2hTdGF0ZW1lbnQ7XHJcblx0ICAgICAgICB0aGlzLmRpc2NyaW1pbmFudCA9IGRpc2NyaW1pbmFudDtcclxuXHQgICAgICAgIHRoaXMuY2FzZXMgPSBjYXNlcztcclxuXHQgICAgfVxyXG5cdCAgICByZXR1cm4gU3dpdGNoU3RhdGVtZW50O1xyXG5cdH0oKSk7XHJcblx0ZXhwb3J0cy5Td2l0Y2hTdGF0ZW1lbnQgPSBTd2l0Y2hTdGF0ZW1lbnQ7XHJcblx0dmFyIFRhZ2dlZFRlbXBsYXRlRXhwcmVzc2lvbiA9IChmdW5jdGlvbiAoKSB7XHJcblx0ICAgIGZ1bmN0aW9uIFRhZ2dlZFRlbXBsYXRlRXhwcmVzc2lvbih0YWcsIHF1YXNpKSB7XHJcblx0ICAgICAgICB0aGlzLnR5cGUgPSBzeW50YXhfMS5TeW50YXguVGFnZ2VkVGVtcGxhdGVFeHByZXNzaW9uO1xyXG5cdCAgICAgICAgdGhpcy50YWcgPSB0YWc7XHJcblx0ICAgICAgICB0aGlzLnF1YXNpID0gcXVhc2k7XHJcblx0ICAgIH1cclxuXHQgICAgcmV0dXJuIFRhZ2dlZFRlbXBsYXRlRXhwcmVzc2lvbjtcclxuXHR9KCkpO1xyXG5cdGV4cG9ydHMuVGFnZ2VkVGVtcGxhdGVFeHByZXNzaW9uID0gVGFnZ2VkVGVtcGxhdGVFeHByZXNzaW9uO1xyXG5cdHZhciBUZW1wbGF0ZUVsZW1lbnQgPSAoZnVuY3Rpb24gKCkge1xyXG5cdCAgICBmdW5jdGlvbiBUZW1wbGF0ZUVsZW1lbnQodmFsdWUsIHRhaWwpIHtcclxuXHQgICAgICAgIHRoaXMudHlwZSA9IHN5bnRheF8xLlN5bnRheC5UZW1wbGF0ZUVsZW1lbnQ7XHJcblx0ICAgICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XHJcblx0ICAgICAgICB0aGlzLnRhaWwgPSB0YWlsO1xyXG5cdCAgICB9XHJcblx0ICAgIHJldHVybiBUZW1wbGF0ZUVsZW1lbnQ7XHJcblx0fSgpKTtcclxuXHRleHBvcnRzLlRlbXBsYXRlRWxlbWVudCA9IFRlbXBsYXRlRWxlbWVudDtcclxuXHR2YXIgVGVtcGxhdGVMaXRlcmFsID0gKGZ1bmN0aW9uICgpIHtcclxuXHQgICAgZnVuY3Rpb24gVGVtcGxhdGVMaXRlcmFsKHF1YXNpcywgZXhwcmVzc2lvbnMpIHtcclxuXHQgICAgICAgIHRoaXMudHlwZSA9IHN5bnRheF8xLlN5bnRheC5UZW1wbGF0ZUxpdGVyYWw7XHJcblx0ICAgICAgICB0aGlzLnF1YXNpcyA9IHF1YXNpcztcclxuXHQgICAgICAgIHRoaXMuZXhwcmVzc2lvbnMgPSBleHByZXNzaW9ucztcclxuXHQgICAgfVxyXG5cdCAgICByZXR1cm4gVGVtcGxhdGVMaXRlcmFsO1xyXG5cdH0oKSk7XHJcblx0ZXhwb3J0cy5UZW1wbGF0ZUxpdGVyYWwgPSBUZW1wbGF0ZUxpdGVyYWw7XHJcblx0dmFyIFRoaXNFeHByZXNzaW9uID0gKGZ1bmN0aW9uICgpIHtcclxuXHQgICAgZnVuY3Rpb24gVGhpc0V4cHJlc3Npb24oKSB7XHJcblx0ICAgICAgICB0aGlzLnR5cGUgPSBzeW50YXhfMS5TeW50YXguVGhpc0V4cHJlc3Npb247XHJcblx0ICAgIH1cclxuXHQgICAgcmV0dXJuIFRoaXNFeHByZXNzaW9uO1xyXG5cdH0oKSk7XHJcblx0ZXhwb3J0cy5UaGlzRXhwcmVzc2lvbiA9IFRoaXNFeHByZXNzaW9uO1xyXG5cdHZhciBUaHJvd1N0YXRlbWVudCA9IChmdW5jdGlvbiAoKSB7XHJcblx0ICAgIGZ1bmN0aW9uIFRocm93U3RhdGVtZW50KGFyZ3VtZW50KSB7XHJcblx0ICAgICAgICB0aGlzLnR5cGUgPSBzeW50YXhfMS5TeW50YXguVGhyb3dTdGF0ZW1lbnQ7XHJcblx0ICAgICAgICB0aGlzLmFyZ3VtZW50ID0gYXJndW1lbnQ7XHJcblx0ICAgIH1cclxuXHQgICAgcmV0dXJuIFRocm93U3RhdGVtZW50O1xyXG5cdH0oKSk7XHJcblx0ZXhwb3J0cy5UaHJvd1N0YXRlbWVudCA9IFRocm93U3RhdGVtZW50O1xyXG5cdHZhciBUcnlTdGF0ZW1lbnQgPSAoZnVuY3Rpb24gKCkge1xyXG5cdCAgICBmdW5jdGlvbiBUcnlTdGF0ZW1lbnQoYmxvY2ssIGhhbmRsZXIsIGZpbmFsaXplcikge1xyXG5cdCAgICAgICAgdGhpcy50eXBlID0gc3ludGF4XzEuU3ludGF4LlRyeVN0YXRlbWVudDtcclxuXHQgICAgICAgIHRoaXMuYmxvY2sgPSBibG9jaztcclxuXHQgICAgICAgIHRoaXMuaGFuZGxlciA9IGhhbmRsZXI7XHJcblx0ICAgICAgICB0aGlzLmZpbmFsaXplciA9IGZpbmFsaXplcjtcclxuXHQgICAgfVxyXG5cdCAgICByZXR1cm4gVHJ5U3RhdGVtZW50O1xyXG5cdH0oKSk7XHJcblx0ZXhwb3J0cy5UcnlTdGF0ZW1lbnQgPSBUcnlTdGF0ZW1lbnQ7XHJcblx0dmFyIFVuYXJ5RXhwcmVzc2lvbiA9IChmdW5jdGlvbiAoKSB7XHJcblx0ICAgIGZ1bmN0aW9uIFVuYXJ5RXhwcmVzc2lvbihvcGVyYXRvciwgYXJndW1lbnQpIHtcclxuXHQgICAgICAgIHRoaXMudHlwZSA9IHN5bnRheF8xLlN5bnRheC5VbmFyeUV4cHJlc3Npb247XHJcblx0ICAgICAgICB0aGlzLm9wZXJhdG9yID0gb3BlcmF0b3I7XHJcblx0ICAgICAgICB0aGlzLmFyZ3VtZW50ID0gYXJndW1lbnQ7XHJcblx0ICAgICAgICB0aGlzLnByZWZpeCA9IHRydWU7XHJcblx0ICAgIH1cclxuXHQgICAgcmV0dXJuIFVuYXJ5RXhwcmVzc2lvbjtcclxuXHR9KCkpO1xyXG5cdGV4cG9ydHMuVW5hcnlFeHByZXNzaW9uID0gVW5hcnlFeHByZXNzaW9uO1xyXG5cdHZhciBVcGRhdGVFeHByZXNzaW9uID0gKGZ1bmN0aW9uICgpIHtcclxuXHQgICAgZnVuY3Rpb24gVXBkYXRlRXhwcmVzc2lvbihvcGVyYXRvciwgYXJndW1lbnQsIHByZWZpeCkge1xyXG5cdCAgICAgICAgdGhpcy50eXBlID0gc3ludGF4XzEuU3ludGF4LlVwZGF0ZUV4cHJlc3Npb247XHJcblx0ICAgICAgICB0aGlzLm9wZXJhdG9yID0gb3BlcmF0b3I7XHJcblx0ICAgICAgICB0aGlzLmFyZ3VtZW50ID0gYXJndW1lbnQ7XHJcblx0ICAgICAgICB0aGlzLnByZWZpeCA9IHByZWZpeDtcclxuXHQgICAgfVxyXG5cdCAgICByZXR1cm4gVXBkYXRlRXhwcmVzc2lvbjtcclxuXHR9KCkpO1xyXG5cdGV4cG9ydHMuVXBkYXRlRXhwcmVzc2lvbiA9IFVwZGF0ZUV4cHJlc3Npb247XHJcblx0dmFyIFZhcmlhYmxlRGVjbGFyYXRpb24gPSAoZnVuY3Rpb24gKCkge1xyXG5cdCAgICBmdW5jdGlvbiBWYXJpYWJsZURlY2xhcmF0aW9uKGRlY2xhcmF0aW9ucywga2luZCkge1xyXG5cdCAgICAgICAgdGhpcy50eXBlID0gc3ludGF4XzEuU3ludGF4LlZhcmlhYmxlRGVjbGFyYXRpb247XHJcblx0ICAgICAgICB0aGlzLmRlY2xhcmF0aW9ucyA9IGRlY2xhcmF0aW9ucztcclxuXHQgICAgICAgIHRoaXMua2luZCA9IGtpbmQ7XHJcblx0ICAgIH1cclxuXHQgICAgcmV0dXJuIFZhcmlhYmxlRGVjbGFyYXRpb247XHJcblx0fSgpKTtcclxuXHRleHBvcnRzLlZhcmlhYmxlRGVjbGFyYXRpb24gPSBWYXJpYWJsZURlY2xhcmF0aW9uO1xyXG5cdHZhciBWYXJpYWJsZURlY2xhcmF0b3IgPSAoZnVuY3Rpb24gKCkge1xyXG5cdCAgICBmdW5jdGlvbiBWYXJpYWJsZURlY2xhcmF0b3IoaWQsIGluaXQpIHtcclxuXHQgICAgICAgIHRoaXMudHlwZSA9IHN5bnRheF8xLlN5bnRheC5WYXJpYWJsZURlY2xhcmF0b3I7XHJcblx0ICAgICAgICB0aGlzLmlkID0gaWQ7XHJcblx0ICAgICAgICB0aGlzLmluaXQgPSBpbml0O1xyXG5cdCAgICB9XHJcblx0ICAgIHJldHVybiBWYXJpYWJsZURlY2xhcmF0b3I7XHJcblx0fSgpKTtcclxuXHRleHBvcnRzLlZhcmlhYmxlRGVjbGFyYXRvciA9IFZhcmlhYmxlRGVjbGFyYXRvcjtcclxuXHR2YXIgV2hpbGVTdGF0ZW1lbnQgPSAoZnVuY3Rpb24gKCkge1xyXG5cdCAgICBmdW5jdGlvbiBXaGlsZVN0YXRlbWVudCh0ZXN0LCBib2R5KSB7XHJcblx0ICAgICAgICB0aGlzLnR5cGUgPSBzeW50YXhfMS5TeW50YXguV2hpbGVTdGF0ZW1lbnQ7XHJcblx0ICAgICAgICB0aGlzLnRlc3QgPSB0ZXN0O1xyXG5cdCAgICAgICAgdGhpcy5ib2R5ID0gYm9keTtcclxuXHQgICAgfVxyXG5cdCAgICByZXR1cm4gV2hpbGVTdGF0ZW1lbnQ7XHJcblx0fSgpKTtcclxuXHRleHBvcnRzLldoaWxlU3RhdGVtZW50ID0gV2hpbGVTdGF0ZW1lbnQ7XHJcblx0dmFyIFdpdGhTdGF0ZW1lbnQgPSAoZnVuY3Rpb24gKCkge1xyXG5cdCAgICBmdW5jdGlvbiBXaXRoU3RhdGVtZW50KG9iamVjdCwgYm9keSkge1xyXG5cdCAgICAgICAgdGhpcy50eXBlID0gc3ludGF4XzEuU3ludGF4LldpdGhTdGF0ZW1lbnQ7XHJcblx0ICAgICAgICB0aGlzLm9iamVjdCA9IG9iamVjdDtcclxuXHQgICAgICAgIHRoaXMuYm9keSA9IGJvZHk7XHJcblx0ICAgIH1cclxuXHQgICAgcmV0dXJuIFdpdGhTdGF0ZW1lbnQ7XHJcblx0fSgpKTtcclxuXHRleHBvcnRzLldpdGhTdGF0ZW1lbnQgPSBXaXRoU3RhdGVtZW50O1xyXG5cdHZhciBZaWVsZEV4cHJlc3Npb24gPSAoZnVuY3Rpb24gKCkge1xyXG5cdCAgICBmdW5jdGlvbiBZaWVsZEV4cHJlc3Npb24oYXJndW1lbnQsIGRlbGVnYXRlKSB7XHJcblx0ICAgICAgICB0aGlzLnR5cGUgPSBzeW50YXhfMS5TeW50YXguWWllbGRFeHByZXNzaW9uO1xyXG5cdCAgICAgICAgdGhpcy5hcmd1bWVudCA9IGFyZ3VtZW50O1xyXG5cdCAgICAgICAgdGhpcy5kZWxlZ2F0ZSA9IGRlbGVnYXRlO1xyXG5cdCAgICB9XHJcblx0ICAgIHJldHVybiBZaWVsZEV4cHJlc3Npb247XHJcblx0fSgpKTtcclxuXHRleHBvcnRzLllpZWxkRXhwcmVzc2lvbiA9IFlpZWxkRXhwcmVzc2lvbjtcclxuXG5cbi8qKiovIH0sXG4vKiA4ICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXHRcInVzZSBzdHJpY3RcIjtcclxuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcblx0dmFyIGFzc2VydF8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg5KTtcclxuXHR2YXIgZXJyb3JfaGFuZGxlcl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMCk7XHJcblx0dmFyIG1lc3NhZ2VzXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDExKTtcclxuXHR2YXIgTm9kZSA9IF9fd2VicGFja19yZXF1aXJlX18oNyk7XHJcblx0dmFyIHNjYW5uZXJfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMTIpO1xyXG5cdHZhciBzeW50YXhfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMik7XHJcblx0dmFyIHRva2VuXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEzKTtcclxuXHR2YXIgQXJyb3dQYXJhbWV0ZXJQbGFjZUhvbGRlciA9ICdBcnJvd1BhcmFtZXRlclBsYWNlSG9sZGVyJztcclxuXHR2YXIgUGFyc2VyID0gKGZ1bmN0aW9uICgpIHtcclxuXHQgICAgZnVuY3Rpb24gUGFyc2VyKGNvZGUsIG9wdGlvbnMsIGRlbGVnYXRlKSB7XHJcblx0ICAgICAgICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7IG9wdGlvbnMgPSB7fTsgfVxyXG5cdCAgICAgICAgdGhpcy5jb25maWcgPSB7XHJcblx0ICAgICAgICAgICAgcmFuZ2U6ICh0eXBlb2Ygb3B0aW9ucy5yYW5nZSA9PT0gJ2Jvb2xlYW4nKSAmJiBvcHRpb25zLnJhbmdlLFxyXG5cdCAgICAgICAgICAgIGxvYzogKHR5cGVvZiBvcHRpb25zLmxvYyA9PT0gJ2Jvb2xlYW4nKSAmJiBvcHRpb25zLmxvYyxcclxuXHQgICAgICAgICAgICBzb3VyY2U6IG51bGwsXHJcblx0ICAgICAgICAgICAgdG9rZW5zOiAodHlwZW9mIG9wdGlvbnMudG9rZW5zID09PSAnYm9vbGVhbicpICYmIG9wdGlvbnMudG9rZW5zLFxyXG5cdCAgICAgICAgICAgIGNvbW1lbnQ6ICh0eXBlb2Ygb3B0aW9ucy5jb21tZW50ID09PSAnYm9vbGVhbicpICYmIG9wdGlvbnMuY29tbWVudCxcclxuXHQgICAgICAgICAgICB0b2xlcmFudDogKHR5cGVvZiBvcHRpb25zLnRvbGVyYW50ID09PSAnYm9vbGVhbicpICYmIG9wdGlvbnMudG9sZXJhbnRcclxuXHQgICAgICAgIH07XHJcblx0ICAgICAgICBpZiAodGhpcy5jb25maWcubG9jICYmIG9wdGlvbnMuc291cmNlICYmIG9wdGlvbnMuc291cmNlICE9PSBudWxsKSB7XHJcblx0ICAgICAgICAgICAgdGhpcy5jb25maWcuc291cmNlID0gU3RyaW5nKG9wdGlvbnMuc291cmNlKTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIHRoaXMuZGVsZWdhdGUgPSBkZWxlZ2F0ZTtcclxuXHQgICAgICAgIHRoaXMuZXJyb3JIYW5kbGVyID0gbmV3IGVycm9yX2hhbmRsZXJfMS5FcnJvckhhbmRsZXIoKTtcclxuXHQgICAgICAgIHRoaXMuZXJyb3JIYW5kbGVyLnRvbGVyYW50ID0gdGhpcy5jb25maWcudG9sZXJhbnQ7XHJcblx0ICAgICAgICB0aGlzLnNjYW5uZXIgPSBuZXcgc2Nhbm5lcl8xLlNjYW5uZXIoY29kZSwgdGhpcy5lcnJvckhhbmRsZXIpO1xyXG5cdCAgICAgICAgdGhpcy5zY2FubmVyLnRyYWNrQ29tbWVudCA9IHRoaXMuY29uZmlnLmNvbW1lbnQ7XHJcblx0ICAgICAgICB0aGlzLm9wZXJhdG9yUHJlY2VkZW5jZSA9IHtcclxuXHQgICAgICAgICAgICAnKSc6IDAsXHJcblx0ICAgICAgICAgICAgJzsnOiAwLFxyXG5cdCAgICAgICAgICAgICcsJzogMCxcclxuXHQgICAgICAgICAgICAnPSc6IDAsXHJcblx0ICAgICAgICAgICAgJ10nOiAwLFxyXG5cdCAgICAgICAgICAgICd8fCc6IDEsXHJcblx0ICAgICAgICAgICAgJyYmJzogMixcclxuXHQgICAgICAgICAgICAnfCc6IDMsXHJcblx0ICAgICAgICAgICAgJ14nOiA0LFxyXG5cdCAgICAgICAgICAgICcmJzogNSxcclxuXHQgICAgICAgICAgICAnPT0nOiA2LFxyXG5cdCAgICAgICAgICAgICchPSc6IDYsXHJcblx0ICAgICAgICAgICAgJz09PSc6IDYsXHJcblx0ICAgICAgICAgICAgJyE9PSc6IDYsXHJcblx0ICAgICAgICAgICAgJzwnOiA3LFxyXG5cdCAgICAgICAgICAgICc+JzogNyxcclxuXHQgICAgICAgICAgICAnPD0nOiA3LFxyXG5cdCAgICAgICAgICAgICc+PSc6IDcsXHJcblx0ICAgICAgICAgICAgJzw8JzogOCxcclxuXHQgICAgICAgICAgICAnPj4nOiA4LFxyXG5cdCAgICAgICAgICAgICc+Pj4nOiA4LFxyXG5cdCAgICAgICAgICAgICcrJzogOSxcclxuXHQgICAgICAgICAgICAnLSc6IDksXHJcblx0ICAgICAgICAgICAgJyonOiAxMSxcclxuXHQgICAgICAgICAgICAnLyc6IDExLFxyXG5cdCAgICAgICAgICAgICclJzogMTFcclxuXHQgICAgICAgIH07XHJcblx0ICAgICAgICB0aGlzLmxvb2thaGVhZCA9IHtcclxuXHQgICAgICAgICAgICB0eXBlOiAyIC8qIEVPRiAqLyxcclxuXHQgICAgICAgICAgICB2YWx1ZTogJycsXHJcblx0ICAgICAgICAgICAgbGluZU51bWJlcjogdGhpcy5zY2FubmVyLmxpbmVOdW1iZXIsXHJcblx0ICAgICAgICAgICAgbGluZVN0YXJ0OiAwLFxyXG5cdCAgICAgICAgICAgIHN0YXJ0OiAwLFxyXG5cdCAgICAgICAgICAgIGVuZDogMFxyXG5cdCAgICAgICAgfTtcclxuXHQgICAgICAgIHRoaXMuaGFzTGluZVRlcm1pbmF0b3IgPSBmYWxzZTtcclxuXHQgICAgICAgIHRoaXMuY29udGV4dCA9IHtcclxuXHQgICAgICAgICAgICBpc01vZHVsZTogZmFsc2UsXHJcblx0ICAgICAgICAgICAgYXdhaXQ6IGZhbHNlLFxyXG5cdCAgICAgICAgICAgIGFsbG93SW46IHRydWUsXHJcblx0ICAgICAgICAgICAgYWxsb3dTdHJpY3REaXJlY3RpdmU6IHRydWUsXHJcblx0ICAgICAgICAgICAgYWxsb3dZaWVsZDogdHJ1ZSxcclxuXHQgICAgICAgICAgICBmaXJzdENvdmVySW5pdGlhbGl6ZWROYW1lRXJyb3I6IG51bGwsXHJcblx0ICAgICAgICAgICAgaXNBc3NpZ25tZW50VGFyZ2V0OiBmYWxzZSxcclxuXHQgICAgICAgICAgICBpc0JpbmRpbmdFbGVtZW50OiBmYWxzZSxcclxuXHQgICAgICAgICAgICBpbkZ1bmN0aW9uQm9keTogZmFsc2UsXHJcblx0ICAgICAgICAgICAgaW5JdGVyYXRpb246IGZhbHNlLFxyXG5cdCAgICAgICAgICAgIGluU3dpdGNoOiBmYWxzZSxcclxuXHQgICAgICAgICAgICBsYWJlbFNldDoge30sXHJcblx0ICAgICAgICAgICAgc3RyaWN0OiBmYWxzZVxyXG5cdCAgICAgICAgfTtcclxuXHQgICAgICAgIHRoaXMudG9rZW5zID0gW107XHJcblx0ICAgICAgICB0aGlzLnN0YXJ0TWFya2VyID0ge1xyXG5cdCAgICAgICAgICAgIGluZGV4OiAwLFxyXG5cdCAgICAgICAgICAgIGxpbmU6IHRoaXMuc2Nhbm5lci5saW5lTnVtYmVyLFxyXG5cdCAgICAgICAgICAgIGNvbHVtbjogMFxyXG5cdCAgICAgICAgfTtcclxuXHQgICAgICAgIHRoaXMubGFzdE1hcmtlciA9IHtcclxuXHQgICAgICAgICAgICBpbmRleDogMCxcclxuXHQgICAgICAgICAgICBsaW5lOiB0aGlzLnNjYW5uZXIubGluZU51bWJlcixcclxuXHQgICAgICAgICAgICBjb2x1bW46IDBcclxuXHQgICAgICAgIH07XHJcblx0ICAgICAgICB0aGlzLm5leHRUb2tlbigpO1xyXG5cdCAgICAgICAgdGhpcy5sYXN0TWFya2VyID0ge1xyXG5cdCAgICAgICAgICAgIGluZGV4OiB0aGlzLnNjYW5uZXIuaW5kZXgsXHJcblx0ICAgICAgICAgICAgbGluZTogdGhpcy5zY2FubmVyLmxpbmVOdW1iZXIsXHJcblx0ICAgICAgICAgICAgY29sdW1uOiB0aGlzLnNjYW5uZXIuaW5kZXggLSB0aGlzLnNjYW5uZXIubGluZVN0YXJ0XHJcblx0ICAgICAgICB9O1xyXG5cdCAgICB9XHJcblx0ICAgIFBhcnNlci5wcm90b3R5cGUudGhyb3dFcnJvciA9IGZ1bmN0aW9uIChtZXNzYWdlRm9ybWF0KSB7XHJcblx0ICAgICAgICB2YXIgdmFsdWVzID0gW107XHJcblx0ICAgICAgICBmb3IgKHZhciBfaSA9IDE7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xyXG5cdCAgICAgICAgICAgIHZhbHVlc1tfaSAtIDFdID0gYXJndW1lbnRzW19pXTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIHZhciBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKTtcclxuXHQgICAgICAgIHZhciBtc2cgPSBtZXNzYWdlRm9ybWF0LnJlcGxhY2UoLyUoXFxkKS9nLCBmdW5jdGlvbiAod2hvbGUsIGlkeCkge1xyXG5cdCAgICAgICAgICAgIGFzc2VydF8xLmFzc2VydChpZHggPCBhcmdzLmxlbmd0aCwgJ01lc3NhZ2UgcmVmZXJlbmNlIG11c3QgYmUgaW4gcmFuZ2UnKTtcclxuXHQgICAgICAgICAgICByZXR1cm4gYXJnc1tpZHhdO1xyXG5cdCAgICAgICAgfSk7XHJcblx0ICAgICAgICB2YXIgaW5kZXggPSB0aGlzLmxhc3RNYXJrZXIuaW5kZXg7XHJcblx0ICAgICAgICB2YXIgbGluZSA9IHRoaXMubGFzdE1hcmtlci5saW5lO1xyXG5cdCAgICAgICAgdmFyIGNvbHVtbiA9IHRoaXMubGFzdE1hcmtlci5jb2x1bW4gKyAxO1xyXG5cdCAgICAgICAgdGhyb3cgdGhpcy5lcnJvckhhbmRsZXIuY3JlYXRlRXJyb3IoaW5kZXgsIGxpbmUsIGNvbHVtbiwgbXNnKTtcclxuXHQgICAgfTtcclxuXHQgICAgUGFyc2VyLnByb3RvdHlwZS50b2xlcmF0ZUVycm9yID0gZnVuY3Rpb24gKG1lc3NhZ2VGb3JtYXQpIHtcclxuXHQgICAgICAgIHZhciB2YWx1ZXMgPSBbXTtcclxuXHQgICAgICAgIGZvciAodmFyIF9pID0gMTsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XHJcblx0ICAgICAgICAgICAgdmFsdWVzW19pIC0gMV0gPSBhcmd1bWVudHNbX2ldO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgdmFyIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpO1xyXG5cdCAgICAgICAgdmFyIG1zZyA9IG1lc3NhZ2VGb3JtYXQucmVwbGFjZSgvJShcXGQpL2csIGZ1bmN0aW9uICh3aG9sZSwgaWR4KSB7XHJcblx0ICAgICAgICAgICAgYXNzZXJ0XzEuYXNzZXJ0KGlkeCA8IGFyZ3MubGVuZ3RoLCAnTWVzc2FnZSByZWZlcmVuY2UgbXVzdCBiZSBpbiByYW5nZScpO1xyXG5cdCAgICAgICAgICAgIHJldHVybiBhcmdzW2lkeF07XHJcblx0ICAgICAgICB9KTtcclxuXHQgICAgICAgIHZhciBpbmRleCA9IHRoaXMubGFzdE1hcmtlci5pbmRleDtcclxuXHQgICAgICAgIHZhciBsaW5lID0gdGhpcy5zY2FubmVyLmxpbmVOdW1iZXI7XHJcblx0ICAgICAgICB2YXIgY29sdW1uID0gdGhpcy5sYXN0TWFya2VyLmNvbHVtbiArIDE7XHJcblx0ICAgICAgICB0aGlzLmVycm9ySGFuZGxlci50b2xlcmF0ZUVycm9yKGluZGV4LCBsaW5lLCBjb2x1bW4sIG1zZyk7XHJcblx0ICAgIH07XHJcblx0ICAgIC8vIFRocm93IGFuIGV4Y2VwdGlvbiBiZWNhdXNlIG9mIHRoZSB0b2tlbi5cclxuXHQgICAgUGFyc2VyLnByb3RvdHlwZS51bmV4cGVjdGVkVG9rZW5FcnJvciA9IGZ1bmN0aW9uICh0b2tlbiwgbWVzc2FnZSkge1xyXG5cdCAgICAgICAgdmFyIG1zZyA9IG1lc3NhZ2UgfHwgbWVzc2FnZXNfMS5NZXNzYWdlcy5VbmV4cGVjdGVkVG9rZW47XHJcblx0ICAgICAgICB2YXIgdmFsdWU7XHJcblx0ICAgICAgICBpZiAodG9rZW4pIHtcclxuXHQgICAgICAgICAgICBpZiAoIW1lc3NhZ2UpIHtcclxuXHQgICAgICAgICAgICAgICAgbXNnID0gKHRva2VuLnR5cGUgPT09IDIgLyogRU9GICovKSA/IG1lc3NhZ2VzXzEuTWVzc2FnZXMuVW5leHBlY3RlZEVPUyA6XHJcblx0ICAgICAgICAgICAgICAgICAgICAodG9rZW4udHlwZSA9PT0gMyAvKiBJZGVudGlmaWVyICovKSA/IG1lc3NhZ2VzXzEuTWVzc2FnZXMuVW5leHBlY3RlZElkZW50aWZpZXIgOlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICh0b2tlbi50eXBlID09PSA2IC8qIE51bWVyaWNMaXRlcmFsICovKSA/IG1lc3NhZ2VzXzEuTWVzc2FnZXMuVW5leHBlY3RlZE51bWJlciA6XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICh0b2tlbi50eXBlID09PSA4IC8qIFN0cmluZ0xpdGVyYWwgKi8pID8gbWVzc2FnZXNfMS5NZXNzYWdlcy5VbmV4cGVjdGVkU3RyaW5nIDpcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICh0b2tlbi50eXBlID09PSAxMCAvKiBUZW1wbGF0ZSAqLykgPyBtZXNzYWdlc18xLk1lc3NhZ2VzLlVuZXhwZWN0ZWRUZW1wbGF0ZSA6XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZXNfMS5NZXNzYWdlcy5VbmV4cGVjdGVkVG9rZW47XHJcblx0ICAgICAgICAgICAgICAgIGlmICh0b2tlbi50eXBlID09PSA0IC8qIEtleXdvcmQgKi8pIHtcclxuXHQgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLnNjYW5uZXIuaXNGdXR1cmVSZXNlcnZlZFdvcmQodG9rZW4udmFsdWUpKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgbXNnID0gbWVzc2FnZXNfMS5NZXNzYWdlcy5VbmV4cGVjdGVkUmVzZXJ2ZWQ7XHJcblx0ICAgICAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICh0aGlzLmNvbnRleHQuc3RyaWN0ICYmIHRoaXMuc2Nhbm5lci5pc1N0cmljdE1vZGVSZXNlcnZlZFdvcmQodG9rZW4udmFsdWUpKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgbXNnID0gbWVzc2FnZXNfMS5NZXNzYWdlcy5TdHJpY3RSZXNlcnZlZFdvcmQ7XHJcblx0ICAgICAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgdmFsdWUgPSB0b2tlbi52YWx1ZTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIGVsc2Uge1xyXG5cdCAgICAgICAgICAgIHZhbHVlID0gJ0lMTEVHQUwnO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgbXNnID0gbXNnLnJlcGxhY2UoJyUwJywgdmFsdWUpO1xyXG5cdCAgICAgICAgaWYgKHRva2VuICYmIHR5cGVvZiB0b2tlbi5saW5lTnVtYmVyID09PSAnbnVtYmVyJykge1xyXG5cdCAgICAgICAgICAgIHZhciBpbmRleCA9IHRva2VuLnN0YXJ0O1xyXG5cdCAgICAgICAgICAgIHZhciBsaW5lID0gdG9rZW4ubGluZU51bWJlcjtcclxuXHQgICAgICAgICAgICB2YXIgbGFzdE1hcmtlckxpbmVTdGFydCA9IHRoaXMubGFzdE1hcmtlci5pbmRleCAtIHRoaXMubGFzdE1hcmtlci5jb2x1bW47XHJcblx0ICAgICAgICAgICAgdmFyIGNvbHVtbiA9IHRva2VuLnN0YXJ0IC0gbGFzdE1hcmtlckxpbmVTdGFydCArIDE7XHJcblx0ICAgICAgICAgICAgcmV0dXJuIHRoaXMuZXJyb3JIYW5kbGVyLmNyZWF0ZUVycm9yKGluZGV4LCBsaW5lLCBjb2x1bW4sIG1zZyk7XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICBlbHNlIHtcclxuXHQgICAgICAgICAgICB2YXIgaW5kZXggPSB0aGlzLmxhc3RNYXJrZXIuaW5kZXg7XHJcblx0ICAgICAgICAgICAgdmFyIGxpbmUgPSB0aGlzLmxhc3RNYXJrZXIubGluZTtcclxuXHQgICAgICAgICAgICB2YXIgY29sdW1uID0gdGhpcy5sYXN0TWFya2VyLmNvbHVtbiArIDE7XHJcblx0ICAgICAgICAgICAgcmV0dXJuIHRoaXMuZXJyb3JIYW5kbGVyLmNyZWF0ZUVycm9yKGluZGV4LCBsaW5lLCBjb2x1bW4sIG1zZyk7XHJcblx0ICAgICAgICB9XHJcblx0ICAgIH07XHJcblx0ICAgIFBhcnNlci5wcm90b3R5cGUudGhyb3dVbmV4cGVjdGVkVG9rZW4gPSBmdW5jdGlvbiAodG9rZW4sIG1lc3NhZ2UpIHtcclxuXHQgICAgICAgIHRocm93IHRoaXMudW5leHBlY3RlZFRva2VuRXJyb3IodG9rZW4sIG1lc3NhZ2UpO1xyXG5cdCAgICB9O1xyXG5cdCAgICBQYXJzZXIucHJvdG90eXBlLnRvbGVyYXRlVW5leHBlY3RlZFRva2VuID0gZnVuY3Rpb24gKHRva2VuLCBtZXNzYWdlKSB7XHJcblx0ICAgICAgICB0aGlzLmVycm9ySGFuZGxlci50b2xlcmF0ZSh0aGlzLnVuZXhwZWN0ZWRUb2tlbkVycm9yKHRva2VuLCBtZXNzYWdlKSk7XHJcblx0ICAgIH07XHJcblx0ICAgIFBhcnNlci5wcm90b3R5cGUuY29sbGVjdENvbW1lbnRzID0gZnVuY3Rpb24gKCkge1xyXG5cdCAgICAgICAgaWYgKCF0aGlzLmNvbmZpZy5jb21tZW50KSB7XHJcblx0ICAgICAgICAgICAgdGhpcy5zY2FubmVyLnNjYW5Db21tZW50cygpO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgZWxzZSB7XHJcblx0ICAgICAgICAgICAgdmFyIGNvbW1lbnRzID0gdGhpcy5zY2FubmVyLnNjYW5Db21tZW50cygpO1xyXG5cdCAgICAgICAgICAgIGlmIChjb21tZW50cy5sZW5ndGggPiAwICYmIHRoaXMuZGVsZWdhdGUpIHtcclxuXHQgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb21tZW50cy5sZW5ndGg7ICsraSkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIGUgPSBjb21tZW50c1tpXTtcclxuXHQgICAgICAgICAgICAgICAgICAgIHZhciBub2RlID0gdm9pZCAwO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgbm9kZSA9IHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBlLm11bHRpTGluZSA/ICdCbG9ja0NvbW1lbnQnIDogJ0xpbmVDb21tZW50JyxcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogdGhpcy5zY2FubmVyLnNvdXJjZS5zbGljZShlLnNsaWNlWzBdLCBlLnNsaWNlWzFdKVxyXG5cdCAgICAgICAgICAgICAgICAgICAgfTtcclxuXHQgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZy5yYW5nZSkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUucmFuZ2UgPSBlLnJhbmdlO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlnLmxvYykge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUubG9jID0gZS5sb2M7XHJcblx0ICAgICAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgbWV0YWRhdGEgPSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgc3RhcnQ6IHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGluZTogZS5sb2Muc3RhcnQubGluZSxcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29sdW1uOiBlLmxvYy5zdGFydC5jb2x1bW4sXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9mZnNldDogZS5yYW5nZVswXVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH0sXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgZW5kOiB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxpbmU6IGUubG9jLmVuZC5saW5lLFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2x1bW46IGUubG9jLmVuZC5jb2x1bW4sXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9mZnNldDogZS5yYW5nZVsxXVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgICAgIH07XHJcblx0ICAgICAgICAgICAgICAgICAgICB0aGlzLmRlbGVnYXRlKG5vZGUsIG1ldGFkYXRhKTtcclxuXHQgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgIH1cclxuXHQgICAgfTtcclxuXHQgICAgLy8gRnJvbSBpbnRlcm5hbCByZXByZXNlbnRhdGlvbiB0byBhbiBleHRlcm5hbCBzdHJ1Y3R1cmVcclxuXHQgICAgUGFyc2VyLnByb3RvdHlwZS5nZXRUb2tlblJhdyA9IGZ1bmN0aW9uICh0b2tlbikge1xyXG5cdCAgICAgICAgcmV0dXJuIHRoaXMuc2Nhbm5lci5zb3VyY2Uuc2xpY2UodG9rZW4uc3RhcnQsIHRva2VuLmVuZCk7XHJcblx0ICAgIH07XHJcblx0ICAgIFBhcnNlci5wcm90b3R5cGUuY29udmVydFRva2VuID0gZnVuY3Rpb24gKHRva2VuKSB7XHJcblx0ICAgICAgICB2YXIgdCA9IHtcclxuXHQgICAgICAgICAgICB0eXBlOiB0b2tlbl8xLlRva2VuTmFtZVt0b2tlbi50eXBlXSxcclxuXHQgICAgICAgICAgICB2YWx1ZTogdGhpcy5nZXRUb2tlblJhdyh0b2tlbilcclxuXHQgICAgICAgIH07XHJcblx0ICAgICAgICBpZiAodGhpcy5jb25maWcucmFuZ2UpIHtcclxuXHQgICAgICAgICAgICB0LnJhbmdlID0gW3Rva2VuLnN0YXJ0LCB0b2tlbi5lbmRdO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgaWYgKHRoaXMuY29uZmlnLmxvYykge1xyXG5cdCAgICAgICAgICAgIHQubG9jID0ge1xyXG5cdCAgICAgICAgICAgICAgICBzdGFydDoge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgbGluZTogdGhpcy5zdGFydE1hcmtlci5saW5lLFxyXG5cdCAgICAgICAgICAgICAgICAgICAgY29sdW1uOiB0aGlzLnN0YXJ0TWFya2VyLmNvbHVtblxyXG5cdCAgICAgICAgICAgICAgICB9LFxyXG5cdCAgICAgICAgICAgICAgICBlbmQ6IHtcclxuXHQgICAgICAgICAgICAgICAgICAgIGxpbmU6IHRoaXMuc2Nhbm5lci5saW5lTnVtYmVyLFxyXG5cdCAgICAgICAgICAgICAgICAgICAgY29sdW1uOiB0aGlzLnNjYW5uZXIuaW5kZXggLSB0aGlzLnNjYW5uZXIubGluZVN0YXJ0XHJcblx0ICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICB9O1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgaWYgKHRva2VuLnR5cGUgPT09IDkgLyogUmVndWxhckV4cHJlc3Npb24gKi8pIHtcclxuXHQgICAgICAgICAgICB2YXIgcGF0dGVybiA9IHRva2VuLnBhdHRlcm47XHJcblx0ICAgICAgICAgICAgdmFyIGZsYWdzID0gdG9rZW4uZmxhZ3M7XHJcblx0ICAgICAgICAgICAgdC5yZWdleCA9IHsgcGF0dGVybjogcGF0dGVybiwgZmxhZ3M6IGZsYWdzIH07XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICByZXR1cm4gdDtcclxuXHQgICAgfTtcclxuXHQgICAgUGFyc2VyLnByb3RvdHlwZS5uZXh0VG9rZW4gPSBmdW5jdGlvbiAoKSB7XHJcblx0ICAgICAgICB2YXIgdG9rZW4gPSB0aGlzLmxvb2thaGVhZDtcclxuXHQgICAgICAgIHRoaXMubGFzdE1hcmtlci5pbmRleCA9IHRoaXMuc2Nhbm5lci5pbmRleDtcclxuXHQgICAgICAgIHRoaXMubGFzdE1hcmtlci5saW5lID0gdGhpcy5zY2FubmVyLmxpbmVOdW1iZXI7XHJcblx0ICAgICAgICB0aGlzLmxhc3RNYXJrZXIuY29sdW1uID0gdGhpcy5zY2FubmVyLmluZGV4IC0gdGhpcy5zY2FubmVyLmxpbmVTdGFydDtcclxuXHQgICAgICAgIHRoaXMuY29sbGVjdENvbW1lbnRzKCk7XHJcblx0ICAgICAgICBpZiAodGhpcy5zY2FubmVyLmluZGV4ICE9PSB0aGlzLnN0YXJ0TWFya2VyLmluZGV4KSB7XHJcblx0ICAgICAgICAgICAgdGhpcy5zdGFydE1hcmtlci5pbmRleCA9IHRoaXMuc2Nhbm5lci5pbmRleDtcclxuXHQgICAgICAgICAgICB0aGlzLnN0YXJ0TWFya2VyLmxpbmUgPSB0aGlzLnNjYW5uZXIubGluZU51bWJlcjtcclxuXHQgICAgICAgICAgICB0aGlzLnN0YXJ0TWFya2VyLmNvbHVtbiA9IHRoaXMuc2Nhbm5lci5pbmRleCAtIHRoaXMuc2Nhbm5lci5saW5lU3RhcnQ7XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICB2YXIgbmV4dCA9IHRoaXMuc2Nhbm5lci5sZXgoKTtcclxuXHQgICAgICAgIHRoaXMuaGFzTGluZVRlcm1pbmF0b3IgPSAodG9rZW4ubGluZU51bWJlciAhPT0gbmV4dC5saW5lTnVtYmVyKTtcclxuXHQgICAgICAgIGlmIChuZXh0ICYmIHRoaXMuY29udGV4dC5zdHJpY3QgJiYgbmV4dC50eXBlID09PSAzIC8qIElkZW50aWZpZXIgKi8pIHtcclxuXHQgICAgICAgICAgICBpZiAodGhpcy5zY2FubmVyLmlzU3RyaWN0TW9kZVJlc2VydmVkV29yZChuZXh0LnZhbHVlKSkge1xyXG5cdCAgICAgICAgICAgICAgICBuZXh0LnR5cGUgPSA0IC8qIEtleXdvcmQgKi87XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgdGhpcy5sb29rYWhlYWQgPSBuZXh0O1xyXG5cdCAgICAgICAgaWYgKHRoaXMuY29uZmlnLnRva2VucyAmJiBuZXh0LnR5cGUgIT09IDIgLyogRU9GICovKSB7XHJcblx0ICAgICAgICAgICAgdGhpcy50b2tlbnMucHVzaCh0aGlzLmNvbnZlcnRUb2tlbihuZXh0KSk7XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICByZXR1cm4gdG9rZW47XHJcblx0ICAgIH07XHJcblx0ICAgIFBhcnNlci5wcm90b3R5cGUubmV4dFJlZ2V4VG9rZW4gPSBmdW5jdGlvbiAoKSB7XHJcblx0ICAgICAgICB0aGlzLmNvbGxlY3RDb21tZW50cygpO1xyXG5cdCAgICAgICAgdmFyIHRva2VuID0gdGhpcy5zY2FubmVyLnNjYW5SZWdFeHAoKTtcclxuXHQgICAgICAgIGlmICh0aGlzLmNvbmZpZy50b2tlbnMpIHtcclxuXHQgICAgICAgICAgICAvLyBQb3AgdGhlIHByZXZpb3VzIHRva2VuLCAnLycgb3IgJy89J1xyXG5cdCAgICAgICAgICAgIC8vIFRoaXMgaXMgYWRkZWQgZnJvbSB0aGUgbG9va2FoZWFkIHRva2VuLlxyXG5cdCAgICAgICAgICAgIHRoaXMudG9rZW5zLnBvcCgpO1xyXG5cdCAgICAgICAgICAgIHRoaXMudG9rZW5zLnB1c2godGhpcy5jb252ZXJ0VG9rZW4odG9rZW4pKTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIC8vIFByaW1lIHRoZSBuZXh0IGxvb2thaGVhZC5cclxuXHQgICAgICAgIHRoaXMubG9va2FoZWFkID0gdG9rZW47XHJcblx0ICAgICAgICB0aGlzLm5leHRUb2tlbigpO1xyXG5cdCAgICAgICAgcmV0dXJuIHRva2VuO1xyXG5cdCAgICB9O1xyXG5cdCAgICBQYXJzZXIucHJvdG90eXBlLmNyZWF0ZU5vZGUgPSBmdW5jdGlvbiAoKSB7XHJcblx0ICAgICAgICByZXR1cm4ge1xyXG5cdCAgICAgICAgICAgIGluZGV4OiB0aGlzLnN0YXJ0TWFya2VyLmluZGV4LFxyXG5cdCAgICAgICAgICAgIGxpbmU6IHRoaXMuc3RhcnRNYXJrZXIubGluZSxcclxuXHQgICAgICAgICAgICBjb2x1bW46IHRoaXMuc3RhcnRNYXJrZXIuY29sdW1uXHJcblx0ICAgICAgICB9O1xyXG5cdCAgICB9O1xyXG5cdCAgICBQYXJzZXIucHJvdG90eXBlLnN0YXJ0Tm9kZSA9IGZ1bmN0aW9uICh0b2tlbikge1xyXG5cdCAgICAgICAgcmV0dXJuIHtcclxuXHQgICAgICAgICAgICBpbmRleDogdG9rZW4uc3RhcnQsXHJcblx0ICAgICAgICAgICAgbGluZTogdG9rZW4ubGluZU51bWJlcixcclxuXHQgICAgICAgICAgICBjb2x1bW46IHRva2VuLnN0YXJ0IC0gdG9rZW4ubGluZVN0YXJ0XHJcblx0ICAgICAgICB9O1xyXG5cdCAgICB9O1xyXG5cdCAgICBQYXJzZXIucHJvdG90eXBlLmZpbmFsaXplID0gZnVuY3Rpb24gKG1hcmtlciwgbm9kZSkge1xyXG5cdCAgICAgICAgaWYgKHRoaXMuY29uZmlnLnJhbmdlKSB7XHJcblx0ICAgICAgICAgICAgbm9kZS5yYW5nZSA9IFttYXJrZXIuaW5kZXgsIHRoaXMubGFzdE1hcmtlci5pbmRleF07XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICBpZiAodGhpcy5jb25maWcubG9jKSB7XHJcblx0ICAgICAgICAgICAgbm9kZS5sb2MgPSB7XHJcblx0ICAgICAgICAgICAgICAgIHN0YXJ0OiB7XHJcblx0ICAgICAgICAgICAgICAgICAgICBsaW5lOiBtYXJrZXIubGluZSxcclxuXHQgICAgICAgICAgICAgICAgICAgIGNvbHVtbjogbWFya2VyLmNvbHVtbixcclxuXHQgICAgICAgICAgICAgICAgfSxcclxuXHQgICAgICAgICAgICAgICAgZW5kOiB7XHJcblx0ICAgICAgICAgICAgICAgICAgICBsaW5lOiB0aGlzLmxhc3RNYXJrZXIubGluZSxcclxuXHQgICAgICAgICAgICAgICAgICAgIGNvbHVtbjogdGhpcy5sYXN0TWFya2VyLmNvbHVtblxyXG5cdCAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgfTtcclxuXHQgICAgICAgICAgICBpZiAodGhpcy5jb25maWcuc291cmNlKSB7XHJcblx0ICAgICAgICAgICAgICAgIG5vZGUubG9jLnNvdXJjZSA9IHRoaXMuY29uZmlnLnNvdXJjZTtcclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICBpZiAodGhpcy5kZWxlZ2F0ZSkge1xyXG5cdCAgICAgICAgICAgIHZhciBtZXRhZGF0YSA9IHtcclxuXHQgICAgICAgICAgICAgICAgc3RhcnQ6IHtcclxuXHQgICAgICAgICAgICAgICAgICAgIGxpbmU6IG1hcmtlci5saW5lLFxyXG5cdCAgICAgICAgICAgICAgICAgICAgY29sdW1uOiBtYXJrZXIuY29sdW1uLFxyXG5cdCAgICAgICAgICAgICAgICAgICAgb2Zmc2V0OiBtYXJrZXIuaW5kZXhcclxuXHQgICAgICAgICAgICAgICAgfSxcclxuXHQgICAgICAgICAgICAgICAgZW5kOiB7XHJcblx0ICAgICAgICAgICAgICAgICAgICBsaW5lOiB0aGlzLmxhc3RNYXJrZXIubGluZSxcclxuXHQgICAgICAgICAgICAgICAgICAgIGNvbHVtbjogdGhpcy5sYXN0TWFya2VyLmNvbHVtbixcclxuXHQgICAgICAgICAgICAgICAgICAgIG9mZnNldDogdGhpcy5sYXN0TWFya2VyLmluZGV4XHJcblx0ICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICB9O1xyXG5cdCAgICAgICAgICAgIHRoaXMuZGVsZWdhdGUobm9kZSwgbWV0YWRhdGEpO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgcmV0dXJuIG5vZGU7XHJcblx0ICAgIH07XHJcblx0ICAgIC8vIEV4cGVjdCB0aGUgbmV4dCB0b2tlbiB0byBtYXRjaCB0aGUgc3BlY2lmaWVkIHB1bmN0dWF0b3IuXHJcblx0ICAgIC8vIElmIG5vdCwgYW4gZXhjZXB0aW9uIHdpbGwgYmUgdGhyb3duLlxyXG5cdCAgICBQYXJzZXIucHJvdG90eXBlLmV4cGVjdCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xyXG5cdCAgICAgICAgdmFyIHRva2VuID0gdGhpcy5uZXh0VG9rZW4oKTtcclxuXHQgICAgICAgIGlmICh0b2tlbi50eXBlICE9PSA3IC8qIFB1bmN0dWF0b3IgKi8gfHwgdG9rZW4udmFsdWUgIT09IHZhbHVlKSB7XHJcblx0ICAgICAgICAgICAgdGhpcy50aHJvd1VuZXhwZWN0ZWRUb2tlbih0b2tlbik7XHJcblx0ICAgICAgICB9XHJcblx0ICAgIH07XHJcblx0ICAgIC8vIFF1aWV0bHkgZXhwZWN0IGEgY29tbWEgd2hlbiBpbiB0b2xlcmFudCBtb2RlLCBvdGhlcndpc2UgZGVsZWdhdGVzIHRvIGV4cGVjdCgpLlxyXG5cdCAgICBQYXJzZXIucHJvdG90eXBlLmV4cGVjdENvbW1hU2VwYXJhdG9yID0gZnVuY3Rpb24gKCkge1xyXG5cdCAgICAgICAgaWYgKHRoaXMuY29uZmlnLnRvbGVyYW50KSB7XHJcblx0ICAgICAgICAgICAgdmFyIHRva2VuID0gdGhpcy5sb29rYWhlYWQ7XHJcblx0ICAgICAgICAgICAgaWYgKHRva2VuLnR5cGUgPT09IDcgLyogUHVuY3R1YXRvciAqLyAmJiB0b2tlbi52YWx1ZSA9PT0gJywnKSB7XHJcblx0ICAgICAgICAgICAgICAgIHRoaXMubmV4dFRva2VuKCk7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgIGVsc2UgaWYgKHRva2VuLnR5cGUgPT09IDcgLyogUHVuY3R1YXRvciAqLyAmJiB0b2tlbi52YWx1ZSA9PT0gJzsnKSB7XHJcblx0ICAgICAgICAgICAgICAgIHRoaXMubmV4dFRva2VuKCk7XHJcblx0ICAgICAgICAgICAgICAgIHRoaXMudG9sZXJhdGVVbmV4cGVjdGVkVG9rZW4odG9rZW4pO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICBlbHNlIHtcclxuXHQgICAgICAgICAgICAgICAgdGhpcy50b2xlcmF0ZVVuZXhwZWN0ZWRUb2tlbih0b2tlbiwgbWVzc2FnZXNfMS5NZXNzYWdlcy5VbmV4cGVjdGVkVG9rZW4pO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIGVsc2Uge1xyXG5cdCAgICAgICAgICAgIHRoaXMuZXhwZWN0KCcsJyk7XHJcblx0ICAgICAgICB9XHJcblx0ICAgIH07XHJcblx0ICAgIC8vIEV4cGVjdCB0aGUgbmV4dCB0b2tlbiB0byBtYXRjaCB0aGUgc3BlY2lmaWVkIGtleXdvcmQuXHJcblx0ICAgIC8vIElmIG5vdCwgYW4gZXhjZXB0aW9uIHdpbGwgYmUgdGhyb3duLlxyXG5cdCAgICBQYXJzZXIucHJvdG90eXBlLmV4cGVjdEtleXdvcmQgPSBmdW5jdGlvbiAoa2V5d29yZCkge1xyXG5cdCAgICAgICAgdmFyIHRva2VuID0gdGhpcy5uZXh0VG9rZW4oKTtcclxuXHQgICAgICAgIGlmICh0b2tlbi50eXBlICE9PSA0IC8qIEtleXdvcmQgKi8gfHwgdG9rZW4udmFsdWUgIT09IGtleXdvcmQpIHtcclxuXHQgICAgICAgICAgICB0aGlzLnRocm93VW5leHBlY3RlZFRva2VuKHRva2VuKTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgfTtcclxuXHQgICAgLy8gUmV0dXJuIHRydWUgaWYgdGhlIG5leHQgdG9rZW4gbWF0Y2hlcyB0aGUgc3BlY2lmaWVkIHB1bmN0dWF0b3IuXHJcblx0ICAgIFBhcnNlci5wcm90b3R5cGUubWF0Y2ggPSBmdW5jdGlvbiAodmFsdWUpIHtcclxuXHQgICAgICAgIHJldHVybiB0aGlzLmxvb2thaGVhZC50eXBlID09PSA3IC8qIFB1bmN0dWF0b3IgKi8gJiYgdGhpcy5sb29rYWhlYWQudmFsdWUgPT09IHZhbHVlO1xyXG5cdCAgICB9O1xyXG5cdCAgICAvLyBSZXR1cm4gdHJ1ZSBpZiB0aGUgbmV4dCB0b2tlbiBtYXRjaGVzIHRoZSBzcGVjaWZpZWQga2V5d29yZFxyXG5cdCAgICBQYXJzZXIucHJvdG90eXBlLm1hdGNoS2V5d29yZCA9IGZ1bmN0aW9uIChrZXl3b3JkKSB7XHJcblx0ICAgICAgICByZXR1cm4gdGhpcy5sb29rYWhlYWQudHlwZSA9PT0gNCAvKiBLZXl3b3JkICovICYmIHRoaXMubG9va2FoZWFkLnZhbHVlID09PSBrZXl3b3JkO1xyXG5cdCAgICB9O1xyXG5cdCAgICAvLyBSZXR1cm4gdHJ1ZSBpZiB0aGUgbmV4dCB0b2tlbiBtYXRjaGVzIHRoZSBzcGVjaWZpZWQgY29udGV4dHVhbCBrZXl3b3JkXHJcblx0ICAgIC8vICh3aGVyZSBhbiBpZGVudGlmaWVyIGlzIHNvbWV0aW1lcyBhIGtleXdvcmQgZGVwZW5kaW5nIG9uIHRoZSBjb250ZXh0KVxyXG5cdCAgICBQYXJzZXIucHJvdG90eXBlLm1hdGNoQ29udGV4dHVhbEtleXdvcmQgPSBmdW5jdGlvbiAoa2V5d29yZCkge1xyXG5cdCAgICAgICAgcmV0dXJuIHRoaXMubG9va2FoZWFkLnR5cGUgPT09IDMgLyogSWRlbnRpZmllciAqLyAmJiB0aGlzLmxvb2thaGVhZC52YWx1ZSA9PT0ga2V5d29yZDtcclxuXHQgICAgfTtcclxuXHQgICAgLy8gUmV0dXJuIHRydWUgaWYgdGhlIG5leHQgdG9rZW4gaXMgYW4gYXNzaWdubWVudCBvcGVyYXRvclxyXG5cdCAgICBQYXJzZXIucHJvdG90eXBlLm1hdGNoQXNzaWduID0gZnVuY3Rpb24gKCkge1xyXG5cdCAgICAgICAgaWYgKHRoaXMubG9va2FoZWFkLnR5cGUgIT09IDcgLyogUHVuY3R1YXRvciAqLykge1xyXG5cdCAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIHZhciBvcCA9IHRoaXMubG9va2FoZWFkLnZhbHVlO1xyXG5cdCAgICAgICAgcmV0dXJuIG9wID09PSAnPScgfHxcclxuXHQgICAgICAgICAgICBvcCA9PT0gJyo9JyB8fFxyXG5cdCAgICAgICAgICAgIG9wID09PSAnKio9JyB8fFxyXG5cdCAgICAgICAgICAgIG9wID09PSAnLz0nIHx8XHJcblx0ICAgICAgICAgICAgb3AgPT09ICclPScgfHxcclxuXHQgICAgICAgICAgICBvcCA9PT0gJys9JyB8fFxyXG5cdCAgICAgICAgICAgIG9wID09PSAnLT0nIHx8XHJcblx0ICAgICAgICAgICAgb3AgPT09ICc8PD0nIHx8XHJcblx0ICAgICAgICAgICAgb3AgPT09ICc+Pj0nIHx8XHJcblx0ICAgICAgICAgICAgb3AgPT09ICc+Pj49JyB8fFxyXG5cdCAgICAgICAgICAgIG9wID09PSAnJj0nIHx8XHJcblx0ICAgICAgICAgICAgb3AgPT09ICdePScgfHxcclxuXHQgICAgICAgICAgICBvcCA9PT0gJ3w9JztcclxuXHQgICAgfTtcclxuXHQgICAgLy8gQ292ZXIgZ3JhbW1hciBzdXBwb3J0LlxyXG5cdCAgICAvL1xyXG5cdCAgICAvLyBXaGVuIGFuIGFzc2lnbm1lbnQgZXhwcmVzc2lvbiBwb3NpdGlvbiBzdGFydHMgd2l0aCBhbiBsZWZ0IHBhcmVudGhlc2lzLCB0aGUgZGV0ZXJtaW5hdGlvbiBvZiB0aGUgdHlwZVxyXG5cdCAgICAvLyBvZiB0aGUgc3ludGF4IGlzIHRvIGJlIGRlZmVycmVkIGFyYml0cmFyaWx5IGxvbmcgdW50aWwgdGhlIGVuZCBvZiB0aGUgcGFyZW50aGVzZXMgcGFpciAocGx1cyBhIGxvb2thaGVhZClcclxuXHQgICAgLy8gb3IgdGhlIGZpcnN0IGNvbW1hLiBUaGlzIHNpdHVhdGlvbiBhbHNvIGRlZmVycyB0aGUgZGV0ZXJtaW5hdGlvbiBvZiBhbGwgdGhlIGV4cHJlc3Npb25zIG5lc3RlZCBpbiB0aGUgcGFpci5cclxuXHQgICAgLy9cclxuXHQgICAgLy8gVGhlcmUgYXJlIHRocmVlIHByb2R1Y3Rpb25zIHRoYXQgY2FuIGJlIHBhcnNlZCBpbiBhIHBhcmVudGhlc2VzIHBhaXIgdGhhdCBuZWVkcyB0byBiZSBkZXRlcm1pbmVkXHJcblx0ICAgIC8vIGFmdGVyIHRoZSBvdXRlcm1vc3QgcGFpciBpcyBjbG9zZWQuIFRoZXkgYXJlOlxyXG5cdCAgICAvL1xyXG5cdCAgICAvLyAgIDEuIEFzc2lnbm1lbnRFeHByZXNzaW9uXHJcblx0ICAgIC8vICAgMi4gQmluZGluZ0VsZW1lbnRzXHJcblx0ICAgIC8vICAgMy4gQXNzaWdubWVudFRhcmdldHNcclxuXHQgICAgLy9cclxuXHQgICAgLy8gSW4gb3JkZXIgdG8gYXZvaWQgZXhwb25lbnRpYWwgYmFja3RyYWNraW5nLCB3ZSB1c2UgdHdvIGZsYWdzIHRvIGRlbm90ZSBpZiB0aGUgcHJvZHVjdGlvbiBjYW4gYmVcclxuXHQgICAgLy8gYmluZGluZyBlbGVtZW50IG9yIGFzc2lnbm1lbnQgdGFyZ2V0LlxyXG5cdCAgICAvL1xyXG5cdCAgICAvLyBUaGUgdGhyZWUgcHJvZHVjdGlvbnMgaGF2ZSB0aGUgcmVsYXRpb25zaGlwOlxyXG5cdCAgICAvL1xyXG5cdCAgICAvLyAgIEJpbmRpbmdFbGVtZW50cyDiioYgQXNzaWdubWVudFRhcmdldHMg4oqGIEFzc2lnbm1lbnRFeHByZXNzaW9uXHJcblx0ICAgIC8vXHJcblx0ICAgIC8vIHdpdGggYSBzaW5nbGUgZXhjZXB0aW9uIHRoYXQgQ292ZXJJbml0aWFsaXplZE5hbWUgd2hlbiB1c2VkIGRpcmVjdGx5IGluIGFuIEV4cHJlc3Npb24sIGdlbmVyYXRlc1xyXG5cdCAgICAvLyBhbiBlYXJseSBlcnJvci4gVGhlcmVmb3JlLCB3ZSBuZWVkIHRoZSB0aGlyZCBzdGF0ZSwgZmlyc3RDb3ZlckluaXRpYWxpemVkTmFtZUVycm9yLCB0byB0cmFjayB0aGVcclxuXHQgICAgLy8gZmlyc3QgdXNhZ2Ugb2YgQ292ZXJJbml0aWFsaXplZE5hbWUgYW5kIHJlcG9ydCBpdCB3aGVuIHdlIHJlYWNoZWQgdGhlIGVuZCBvZiB0aGUgcGFyZW50aGVzZXMgcGFpci5cclxuXHQgICAgLy9cclxuXHQgICAgLy8gaXNvbGF0ZUNvdmVyR3JhbW1hciBmdW5jdGlvbiBydW5zIHRoZSBnaXZlbiBwYXJzZXIgZnVuY3Rpb24gd2l0aCBhIG5ldyBjb3ZlciBncmFtbWFyIGNvbnRleHQsIGFuZCBpdCBkb2VzIG5vdFxyXG5cdCAgICAvLyBlZmZlY3QgdGhlIGN1cnJlbnQgZmxhZ3MuIFRoaXMgbWVhbnMgdGhlIHByb2R1Y3Rpb24gdGhlIHBhcnNlciBwYXJzZXMgaXMgb25seSB1c2VkIGFzIGFuIGV4cHJlc3Npb24uIFRoZXJlZm9yZVxyXG5cdCAgICAvLyB0aGUgQ292ZXJJbml0aWFsaXplZE5hbWUgY2hlY2sgaXMgY29uZHVjdGVkLlxyXG5cdCAgICAvL1xyXG5cdCAgICAvLyBpbmhlcml0Q292ZXJHcmFtbWFyIGZ1bmN0aW9uIHJ1bnMgdGhlIGdpdmVuIHBhcnNlIGZ1bmN0aW9uIHdpdGggYSBuZXcgY292ZXIgZ3JhbW1hciBjb250ZXh0LCBhbmQgaXQgcHJvcGFnYXRlc1xyXG5cdCAgICAvLyB0aGUgZmxhZ3Mgb3V0c2lkZSBvZiB0aGUgcGFyc2VyLiBUaGlzIG1lYW5zIHRoZSBwcm9kdWN0aW9uIHRoZSBwYXJzZXIgcGFyc2VzIGlzIHVzZWQgYXMgYSBwYXJ0IG9mIGEgcG90ZW50aWFsXHJcblx0ICAgIC8vIHBhdHRlcm4uIFRoZSBDb3ZlckluaXRpYWxpemVkTmFtZSBjaGVjayBpcyBkZWZlcnJlZC5cclxuXHQgICAgUGFyc2VyLnByb3RvdHlwZS5pc29sYXRlQ292ZXJHcmFtbWFyID0gZnVuY3Rpb24gKHBhcnNlRnVuY3Rpb24pIHtcclxuXHQgICAgICAgIHZhciBwcmV2aW91c0lzQmluZGluZ0VsZW1lbnQgPSB0aGlzLmNvbnRleHQuaXNCaW5kaW5nRWxlbWVudDtcclxuXHQgICAgICAgIHZhciBwcmV2aW91c0lzQXNzaWdubWVudFRhcmdldCA9IHRoaXMuY29udGV4dC5pc0Fzc2lnbm1lbnRUYXJnZXQ7XHJcblx0ICAgICAgICB2YXIgcHJldmlvdXNGaXJzdENvdmVySW5pdGlhbGl6ZWROYW1lRXJyb3IgPSB0aGlzLmNvbnRleHQuZmlyc3RDb3ZlckluaXRpYWxpemVkTmFtZUVycm9yO1xyXG5cdCAgICAgICAgdGhpcy5jb250ZXh0LmlzQmluZGluZ0VsZW1lbnQgPSB0cnVlO1xyXG5cdCAgICAgICAgdGhpcy5jb250ZXh0LmlzQXNzaWdubWVudFRhcmdldCA9IHRydWU7XHJcblx0ICAgICAgICB0aGlzLmNvbnRleHQuZmlyc3RDb3ZlckluaXRpYWxpemVkTmFtZUVycm9yID0gbnVsbDtcclxuXHQgICAgICAgIHZhciByZXN1bHQgPSBwYXJzZUZ1bmN0aW9uLmNhbGwodGhpcyk7XHJcblx0ICAgICAgICBpZiAodGhpcy5jb250ZXh0LmZpcnN0Q292ZXJJbml0aWFsaXplZE5hbWVFcnJvciAhPT0gbnVsbCkge1xyXG5cdCAgICAgICAgICAgIHRoaXMudGhyb3dVbmV4cGVjdGVkVG9rZW4odGhpcy5jb250ZXh0LmZpcnN0Q292ZXJJbml0aWFsaXplZE5hbWVFcnJvcik7XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICB0aGlzLmNvbnRleHQuaXNCaW5kaW5nRWxlbWVudCA9IHByZXZpb3VzSXNCaW5kaW5nRWxlbWVudDtcclxuXHQgICAgICAgIHRoaXMuY29udGV4dC5pc0Fzc2lnbm1lbnRUYXJnZXQgPSBwcmV2aW91c0lzQXNzaWdubWVudFRhcmdldDtcclxuXHQgICAgICAgIHRoaXMuY29udGV4dC5maXJzdENvdmVySW5pdGlhbGl6ZWROYW1lRXJyb3IgPSBwcmV2aW91c0ZpcnN0Q292ZXJJbml0aWFsaXplZE5hbWVFcnJvcjtcclxuXHQgICAgICAgIHJldHVybiByZXN1bHQ7XHJcblx0ICAgIH07XHJcblx0ICAgIFBhcnNlci5wcm90b3R5cGUuaW5oZXJpdENvdmVyR3JhbW1hciA9IGZ1bmN0aW9uIChwYXJzZUZ1bmN0aW9uKSB7XHJcblx0ICAgICAgICB2YXIgcHJldmlvdXNJc0JpbmRpbmdFbGVtZW50ID0gdGhpcy5jb250ZXh0LmlzQmluZGluZ0VsZW1lbnQ7XHJcblx0ICAgICAgICB2YXIgcHJldmlvdXNJc0Fzc2lnbm1lbnRUYXJnZXQgPSB0aGlzLmNvbnRleHQuaXNBc3NpZ25tZW50VGFyZ2V0O1xyXG5cdCAgICAgICAgdmFyIHByZXZpb3VzRmlyc3RDb3ZlckluaXRpYWxpemVkTmFtZUVycm9yID0gdGhpcy5jb250ZXh0LmZpcnN0Q292ZXJJbml0aWFsaXplZE5hbWVFcnJvcjtcclxuXHQgICAgICAgIHRoaXMuY29udGV4dC5pc0JpbmRpbmdFbGVtZW50ID0gdHJ1ZTtcclxuXHQgICAgICAgIHRoaXMuY29udGV4dC5pc0Fzc2lnbm1lbnRUYXJnZXQgPSB0cnVlO1xyXG5cdCAgICAgICAgdGhpcy5jb250ZXh0LmZpcnN0Q292ZXJJbml0aWFsaXplZE5hbWVFcnJvciA9IG51bGw7XHJcblx0ICAgICAgICB2YXIgcmVzdWx0ID0gcGFyc2VGdW5jdGlvbi5jYWxsKHRoaXMpO1xyXG5cdCAgICAgICAgdGhpcy5jb250ZXh0LmlzQmluZGluZ0VsZW1lbnQgPSB0aGlzLmNvbnRleHQuaXNCaW5kaW5nRWxlbWVudCAmJiBwcmV2aW91c0lzQmluZGluZ0VsZW1lbnQ7XHJcblx0ICAgICAgICB0aGlzLmNvbnRleHQuaXNBc3NpZ25tZW50VGFyZ2V0ID0gdGhpcy5jb250ZXh0LmlzQXNzaWdubWVudFRhcmdldCAmJiBwcmV2aW91c0lzQXNzaWdubWVudFRhcmdldDtcclxuXHQgICAgICAgIHRoaXMuY29udGV4dC5maXJzdENvdmVySW5pdGlhbGl6ZWROYW1lRXJyb3IgPSBwcmV2aW91c0ZpcnN0Q292ZXJJbml0aWFsaXplZE5hbWVFcnJvciB8fCB0aGlzLmNvbnRleHQuZmlyc3RDb3ZlckluaXRpYWxpemVkTmFtZUVycm9yO1xyXG5cdCAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuXHQgICAgfTtcclxuXHQgICAgUGFyc2VyLnByb3RvdHlwZS5jb25zdW1lU2VtaWNvbG9uID0gZnVuY3Rpb24gKCkge1xyXG5cdCAgICAgICAgaWYgKHRoaXMubWF0Y2goJzsnKSkge1xyXG5cdCAgICAgICAgICAgIHRoaXMubmV4dFRva2VuKCk7XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICBlbHNlIGlmICghdGhpcy5oYXNMaW5lVGVybWluYXRvcikge1xyXG5cdCAgICAgICAgICAgIGlmICh0aGlzLmxvb2thaGVhZC50eXBlICE9PSAyIC8qIEVPRiAqLyAmJiAhdGhpcy5tYXRjaCgnfScpKSB7XHJcblx0ICAgICAgICAgICAgICAgIHRoaXMudGhyb3dVbmV4cGVjdGVkVG9rZW4odGhpcy5sb29rYWhlYWQpO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICB0aGlzLmxhc3RNYXJrZXIuaW5kZXggPSB0aGlzLnN0YXJ0TWFya2VyLmluZGV4O1xyXG5cdCAgICAgICAgICAgIHRoaXMubGFzdE1hcmtlci5saW5lID0gdGhpcy5zdGFydE1hcmtlci5saW5lO1xyXG5cdCAgICAgICAgICAgIHRoaXMubGFzdE1hcmtlci5jb2x1bW4gPSB0aGlzLnN0YXJ0TWFya2VyLmNvbHVtbjtcclxuXHQgICAgICAgIH1cclxuXHQgICAgfTtcclxuXHQgICAgLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtcHJpbWFyeS1leHByZXNzaW9uXHJcblx0ICAgIFBhcnNlci5wcm90b3R5cGUucGFyc2VQcmltYXJ5RXhwcmVzc2lvbiA9IGZ1bmN0aW9uICgpIHtcclxuXHQgICAgICAgIHZhciBub2RlID0gdGhpcy5jcmVhdGVOb2RlKCk7XHJcblx0ICAgICAgICB2YXIgZXhwcjtcclxuXHQgICAgICAgIHZhciB0b2tlbiwgcmF3O1xyXG5cdCAgICAgICAgc3dpdGNoICh0aGlzLmxvb2thaGVhZC50eXBlKSB7XHJcblx0ICAgICAgICAgICAgY2FzZSAzIC8qIElkZW50aWZpZXIgKi86XHJcblx0ICAgICAgICAgICAgICAgIGlmICgodGhpcy5jb250ZXh0LmlzTW9kdWxlIHx8IHRoaXMuY29udGV4dC5hd2FpdCkgJiYgdGhpcy5sb29rYWhlYWQudmFsdWUgPT09ICdhd2FpdCcpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgIHRoaXMudG9sZXJhdGVVbmV4cGVjdGVkVG9rZW4odGhpcy5sb29rYWhlYWQpO1xyXG5cdCAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgIGV4cHIgPSB0aGlzLm1hdGNoQXN5bmNGdW5jdGlvbigpID8gdGhpcy5wYXJzZUZ1bmN0aW9uRXhwcmVzc2lvbigpIDogdGhpcy5maW5hbGl6ZShub2RlLCBuZXcgTm9kZS5JZGVudGlmaWVyKHRoaXMubmV4dFRva2VuKCkudmFsdWUpKTtcclxuXHQgICAgICAgICAgICAgICAgYnJlYWs7XHJcblx0ICAgICAgICAgICAgY2FzZSA2IC8qIE51bWVyaWNMaXRlcmFsICovOlxyXG5cdCAgICAgICAgICAgIGNhc2UgOCAvKiBTdHJpbmdMaXRlcmFsICovOlxyXG5cdCAgICAgICAgICAgICAgICBpZiAodGhpcy5jb250ZXh0LnN0cmljdCAmJiB0aGlzLmxvb2thaGVhZC5vY3RhbCkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgdGhpcy50b2xlcmF0ZVVuZXhwZWN0ZWRUb2tlbih0aGlzLmxvb2thaGVhZCwgbWVzc2FnZXNfMS5NZXNzYWdlcy5TdHJpY3RPY3RhbExpdGVyYWwpO1xyXG5cdCAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgIHRoaXMuY29udGV4dC5pc0Fzc2lnbm1lbnRUYXJnZXQgPSBmYWxzZTtcclxuXHQgICAgICAgICAgICAgICAgdGhpcy5jb250ZXh0LmlzQmluZGluZ0VsZW1lbnQgPSBmYWxzZTtcclxuXHQgICAgICAgICAgICAgICAgdG9rZW4gPSB0aGlzLm5leHRUb2tlbigpO1xyXG5cdCAgICAgICAgICAgICAgICByYXcgPSB0aGlzLmdldFRva2VuUmF3KHRva2VuKTtcclxuXHQgICAgICAgICAgICAgICAgZXhwciA9IHRoaXMuZmluYWxpemUobm9kZSwgbmV3IE5vZGUuTGl0ZXJhbCh0b2tlbi52YWx1ZSwgcmF3KSk7XHJcblx0ICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cdCAgICAgICAgICAgIGNhc2UgMSAvKiBCb29sZWFuTGl0ZXJhbCAqLzpcclxuXHQgICAgICAgICAgICAgICAgdGhpcy5jb250ZXh0LmlzQXNzaWdubWVudFRhcmdldCA9IGZhbHNlO1xyXG5cdCAgICAgICAgICAgICAgICB0aGlzLmNvbnRleHQuaXNCaW5kaW5nRWxlbWVudCA9IGZhbHNlO1xyXG5cdCAgICAgICAgICAgICAgICB0b2tlbiA9IHRoaXMubmV4dFRva2VuKCk7XHJcblx0ICAgICAgICAgICAgICAgIHJhdyA9IHRoaXMuZ2V0VG9rZW5SYXcodG9rZW4pO1xyXG5cdCAgICAgICAgICAgICAgICBleHByID0gdGhpcy5maW5hbGl6ZShub2RlLCBuZXcgTm9kZS5MaXRlcmFsKHRva2VuLnZhbHVlID09PSAndHJ1ZScsIHJhdykpO1xyXG5cdCAgICAgICAgICAgICAgICBicmVhaztcclxuXHQgICAgICAgICAgICBjYXNlIDUgLyogTnVsbExpdGVyYWwgKi86XHJcblx0ICAgICAgICAgICAgICAgIHRoaXMuY29udGV4dC5pc0Fzc2lnbm1lbnRUYXJnZXQgPSBmYWxzZTtcclxuXHQgICAgICAgICAgICAgICAgdGhpcy5jb250ZXh0LmlzQmluZGluZ0VsZW1lbnQgPSBmYWxzZTtcclxuXHQgICAgICAgICAgICAgICAgdG9rZW4gPSB0aGlzLm5leHRUb2tlbigpO1xyXG5cdCAgICAgICAgICAgICAgICByYXcgPSB0aGlzLmdldFRva2VuUmF3KHRva2VuKTtcclxuXHQgICAgICAgICAgICAgICAgZXhwciA9IHRoaXMuZmluYWxpemUobm9kZSwgbmV3IE5vZGUuTGl0ZXJhbChudWxsLCByYXcpKTtcclxuXHQgICAgICAgICAgICAgICAgYnJlYWs7XHJcblx0ICAgICAgICAgICAgY2FzZSAxMCAvKiBUZW1wbGF0ZSAqLzpcclxuXHQgICAgICAgICAgICAgICAgZXhwciA9IHRoaXMucGFyc2VUZW1wbGF0ZUxpdGVyYWwoKTtcclxuXHQgICAgICAgICAgICAgICAgYnJlYWs7XHJcblx0ICAgICAgICAgICAgY2FzZSA3IC8qIFB1bmN0dWF0b3IgKi86XHJcblx0ICAgICAgICAgICAgICAgIHN3aXRjaCAodGhpcy5sb29rYWhlYWQudmFsdWUpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgIGNhc2UgJygnOlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY29udGV4dC5pc0JpbmRpbmdFbGVtZW50ID0gZmFsc2U7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgZXhwciA9IHRoaXMuaW5oZXJpdENvdmVyR3JhbW1hcih0aGlzLnBhcnNlR3JvdXBFeHByZXNzaW9uKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuXHQgICAgICAgICAgICAgICAgICAgIGNhc2UgJ1snOlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGV4cHIgPSB0aGlzLmluaGVyaXRDb3ZlckdyYW1tYXIodGhpcy5wYXJzZUFycmF5SW5pdGlhbGl6ZXIpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgY2FzZSAneyc6XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgZXhwciA9IHRoaXMuaW5oZXJpdENvdmVyR3JhbW1hcih0aGlzLnBhcnNlT2JqZWN0SW5pdGlhbGl6ZXIpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgY2FzZSAnLyc6XHJcblx0ICAgICAgICAgICAgICAgICAgICBjYXNlICcvPSc6XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jb250ZXh0LmlzQXNzaWdubWVudFRhcmdldCA9IGZhbHNlO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY29udGV4dC5pc0JpbmRpbmdFbGVtZW50ID0gZmFsc2U7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zY2FubmVyLmluZGV4ID0gdGhpcy5zdGFydE1hcmtlci5pbmRleDtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICB0b2tlbiA9IHRoaXMubmV4dFJlZ2V4VG9rZW4oKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICByYXcgPSB0aGlzLmdldFRva2VuUmF3KHRva2VuKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBleHByID0gdGhpcy5maW5hbGl6ZShub2RlLCBuZXcgTm9kZS5SZWdleExpdGVyYWwodG9rZW4ucmVnZXgsIHJhdywgdG9rZW4ucGF0dGVybiwgdG9rZW4uZmxhZ3MpKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuXHQgICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgZXhwciA9IHRoaXMudGhyb3dVbmV4cGVjdGVkVG9rZW4odGhpcy5uZXh0VG9rZW4oKSk7XHJcblx0ICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgYnJlYWs7XHJcblx0ICAgICAgICAgICAgY2FzZSA0IC8qIEtleXdvcmQgKi86XHJcblx0ICAgICAgICAgICAgICAgIGlmICghdGhpcy5jb250ZXh0LnN0cmljdCAmJiB0aGlzLmNvbnRleHQuYWxsb3dZaWVsZCAmJiB0aGlzLm1hdGNoS2V5d29yZCgneWllbGQnKSkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgZXhwciA9IHRoaXMucGFyc2VJZGVudGlmaWVyTmFtZSgpO1xyXG5cdCAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgIGVsc2UgaWYgKCF0aGlzLmNvbnRleHQuc3RyaWN0ICYmIHRoaXMubWF0Y2hLZXl3b3JkKCdsZXQnKSkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgZXhwciA9IHRoaXMuZmluYWxpemUobm9kZSwgbmV3IE5vZGUuSWRlbnRpZmllcih0aGlzLm5leHRUb2tlbigpLnZhbHVlKSk7XHJcblx0ICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgZWxzZSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbnRleHQuaXNBc3NpZ25tZW50VGFyZ2V0ID0gZmFsc2U7XHJcblx0ICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbnRleHQuaXNCaW5kaW5nRWxlbWVudCA9IGZhbHNlO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMubWF0Y2hLZXl3b3JkKCdmdW5jdGlvbicpKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgZXhwciA9IHRoaXMucGFyc2VGdW5jdGlvbkV4cHJlc3Npb24oKTtcclxuXHQgICAgICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMubWF0Y2hLZXl3b3JkKCd0aGlzJykpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm5leHRUb2tlbigpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGV4cHIgPSB0aGlzLmZpbmFsaXplKG5vZGUsIG5ldyBOb2RlLlRoaXNFeHByZXNzaW9uKCkpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5tYXRjaEtleXdvcmQoJ2NsYXNzJykpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBleHByID0gdGhpcy5wYXJzZUNsYXNzRXhwcmVzc2lvbigpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgZXhwciA9IHRoaXMudGhyb3dVbmV4cGVjdGVkVG9rZW4odGhpcy5uZXh0VG9rZW4oKSk7XHJcblx0ICAgICAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgYnJlYWs7XHJcblx0ICAgICAgICAgICAgZGVmYXVsdDpcclxuXHQgICAgICAgICAgICAgICAgZXhwciA9IHRoaXMudGhyb3dVbmV4cGVjdGVkVG9rZW4odGhpcy5uZXh0VG9rZW4oKSk7XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICByZXR1cm4gZXhwcjtcclxuXHQgICAgfTtcclxuXHQgICAgLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtYXJyYXktaW5pdGlhbGl6ZXJcclxuXHQgICAgUGFyc2VyLnByb3RvdHlwZS5wYXJzZVNwcmVhZEVsZW1lbnQgPSBmdW5jdGlvbiAoKSB7XHJcblx0ICAgICAgICB2YXIgbm9kZSA9IHRoaXMuY3JlYXRlTm9kZSgpO1xyXG5cdCAgICAgICAgdGhpcy5leHBlY3QoJy4uLicpO1xyXG5cdCAgICAgICAgdmFyIGFyZyA9IHRoaXMuaW5oZXJpdENvdmVyR3JhbW1hcih0aGlzLnBhcnNlQXNzaWdubWVudEV4cHJlc3Npb24pO1xyXG5cdCAgICAgICAgcmV0dXJuIHRoaXMuZmluYWxpemUobm9kZSwgbmV3IE5vZGUuU3ByZWFkRWxlbWVudChhcmcpKTtcclxuXHQgICAgfTtcclxuXHQgICAgUGFyc2VyLnByb3RvdHlwZS5wYXJzZUFycmF5SW5pdGlhbGl6ZXIgPSBmdW5jdGlvbiAoKSB7XHJcblx0ICAgICAgICB2YXIgbm9kZSA9IHRoaXMuY3JlYXRlTm9kZSgpO1xyXG5cdCAgICAgICAgdmFyIGVsZW1lbnRzID0gW107XHJcblx0ICAgICAgICB0aGlzLmV4cGVjdCgnWycpO1xyXG5cdCAgICAgICAgd2hpbGUgKCF0aGlzLm1hdGNoKCddJykpIHtcclxuXHQgICAgICAgICAgICBpZiAodGhpcy5tYXRjaCgnLCcpKSB7XHJcblx0ICAgICAgICAgICAgICAgIHRoaXMubmV4dFRva2VuKCk7XHJcblx0ICAgICAgICAgICAgICAgIGVsZW1lbnRzLnB1c2gobnVsbCk7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMubWF0Y2goJy4uLicpKSB7XHJcblx0ICAgICAgICAgICAgICAgIHZhciBlbGVtZW50ID0gdGhpcy5wYXJzZVNwcmVhZEVsZW1lbnQoKTtcclxuXHQgICAgICAgICAgICAgICAgaWYgKCF0aGlzLm1hdGNoKCddJykpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgIHRoaXMuY29udGV4dC5pc0Fzc2lnbm1lbnRUYXJnZXQgPSBmYWxzZTtcclxuXHQgICAgICAgICAgICAgICAgICAgIHRoaXMuY29udGV4dC5pc0JpbmRpbmdFbGVtZW50ID0gZmFsc2U7XHJcblx0ICAgICAgICAgICAgICAgICAgICB0aGlzLmV4cGVjdCgnLCcpO1xyXG5cdCAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgIGVsZW1lbnRzLnB1c2goZWxlbWVudCk7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgIGVsc2Uge1xyXG5cdCAgICAgICAgICAgICAgICBlbGVtZW50cy5wdXNoKHRoaXMuaW5oZXJpdENvdmVyR3JhbW1hcih0aGlzLnBhcnNlQXNzaWdubWVudEV4cHJlc3Npb24pKTtcclxuXHQgICAgICAgICAgICAgICAgaWYgKCF0aGlzLm1hdGNoKCddJykpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgIHRoaXMuZXhwZWN0KCcsJyk7XHJcblx0ICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICB0aGlzLmV4cGVjdCgnXScpO1xyXG5cdCAgICAgICAgcmV0dXJuIHRoaXMuZmluYWxpemUobm9kZSwgbmV3IE5vZGUuQXJyYXlFeHByZXNzaW9uKGVsZW1lbnRzKSk7XHJcblx0ICAgIH07XHJcblx0ICAgIC8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLW9iamVjdC1pbml0aWFsaXplclxyXG5cdCAgICBQYXJzZXIucHJvdG90eXBlLnBhcnNlUHJvcGVydHlNZXRob2QgPSBmdW5jdGlvbiAocGFyYW1zKSB7XHJcblx0ICAgICAgICB0aGlzLmNvbnRleHQuaXNBc3NpZ25tZW50VGFyZ2V0ID0gZmFsc2U7XHJcblx0ICAgICAgICB0aGlzLmNvbnRleHQuaXNCaW5kaW5nRWxlbWVudCA9IGZhbHNlO1xyXG5cdCAgICAgICAgdmFyIHByZXZpb3VzU3RyaWN0ID0gdGhpcy5jb250ZXh0LnN0cmljdDtcclxuXHQgICAgICAgIHZhciBwcmV2aW91c0FsbG93U3RyaWN0RGlyZWN0aXZlID0gdGhpcy5jb250ZXh0LmFsbG93U3RyaWN0RGlyZWN0aXZlO1xyXG5cdCAgICAgICAgdGhpcy5jb250ZXh0LmFsbG93U3RyaWN0RGlyZWN0aXZlID0gcGFyYW1zLnNpbXBsZTtcclxuXHQgICAgICAgIHZhciBib2R5ID0gdGhpcy5pc29sYXRlQ292ZXJHcmFtbWFyKHRoaXMucGFyc2VGdW5jdGlvblNvdXJjZUVsZW1lbnRzKTtcclxuXHQgICAgICAgIGlmICh0aGlzLmNvbnRleHQuc3RyaWN0ICYmIHBhcmFtcy5maXJzdFJlc3RyaWN0ZWQpIHtcclxuXHQgICAgICAgICAgICB0aGlzLnRvbGVyYXRlVW5leHBlY3RlZFRva2VuKHBhcmFtcy5maXJzdFJlc3RyaWN0ZWQsIHBhcmFtcy5tZXNzYWdlKTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIGlmICh0aGlzLmNvbnRleHQuc3RyaWN0ICYmIHBhcmFtcy5zdHJpY3RlZCkge1xyXG5cdCAgICAgICAgICAgIHRoaXMudG9sZXJhdGVVbmV4cGVjdGVkVG9rZW4ocGFyYW1zLnN0cmljdGVkLCBwYXJhbXMubWVzc2FnZSk7XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICB0aGlzLmNvbnRleHQuc3RyaWN0ID0gcHJldmlvdXNTdHJpY3Q7XHJcblx0ICAgICAgICB0aGlzLmNvbnRleHQuYWxsb3dTdHJpY3REaXJlY3RpdmUgPSBwcmV2aW91c0FsbG93U3RyaWN0RGlyZWN0aXZlO1xyXG5cdCAgICAgICAgcmV0dXJuIGJvZHk7XHJcblx0ICAgIH07XHJcblx0ICAgIFBhcnNlci5wcm90b3R5cGUucGFyc2VQcm9wZXJ0eU1ldGhvZEZ1bmN0aW9uID0gZnVuY3Rpb24gKCkge1xyXG5cdCAgICAgICAgdmFyIGlzR2VuZXJhdG9yID0gZmFsc2U7XHJcblx0ICAgICAgICB2YXIgbm9kZSA9IHRoaXMuY3JlYXRlTm9kZSgpO1xyXG5cdCAgICAgICAgdmFyIHByZXZpb3VzQWxsb3dZaWVsZCA9IHRoaXMuY29udGV4dC5hbGxvd1lpZWxkO1xyXG5cdCAgICAgICAgdGhpcy5jb250ZXh0LmFsbG93WWllbGQgPSBmYWxzZTtcclxuXHQgICAgICAgIHZhciBwYXJhbXMgPSB0aGlzLnBhcnNlRm9ybWFsUGFyYW1ldGVycygpO1xyXG5cdCAgICAgICAgdmFyIG1ldGhvZCA9IHRoaXMucGFyc2VQcm9wZXJ0eU1ldGhvZChwYXJhbXMpO1xyXG5cdCAgICAgICAgdGhpcy5jb250ZXh0LmFsbG93WWllbGQgPSBwcmV2aW91c0FsbG93WWllbGQ7XHJcblx0ICAgICAgICByZXR1cm4gdGhpcy5maW5hbGl6ZShub2RlLCBuZXcgTm9kZS5GdW5jdGlvbkV4cHJlc3Npb24obnVsbCwgcGFyYW1zLnBhcmFtcywgbWV0aG9kLCBpc0dlbmVyYXRvcikpO1xyXG5cdCAgICB9O1xyXG5cdCAgICBQYXJzZXIucHJvdG90eXBlLnBhcnNlUHJvcGVydHlNZXRob2RBc3luY0Z1bmN0aW9uID0gZnVuY3Rpb24gKCkge1xyXG5cdCAgICAgICAgdmFyIG5vZGUgPSB0aGlzLmNyZWF0ZU5vZGUoKTtcclxuXHQgICAgICAgIHZhciBwcmV2aW91c0FsbG93WWllbGQgPSB0aGlzLmNvbnRleHQuYWxsb3dZaWVsZDtcclxuXHQgICAgICAgIHZhciBwcmV2aW91c0F3YWl0ID0gdGhpcy5jb250ZXh0LmF3YWl0O1xyXG5cdCAgICAgICAgdGhpcy5jb250ZXh0LmFsbG93WWllbGQgPSBmYWxzZTtcclxuXHQgICAgICAgIHRoaXMuY29udGV4dC5hd2FpdCA9IHRydWU7XHJcblx0ICAgICAgICB2YXIgcGFyYW1zID0gdGhpcy5wYXJzZUZvcm1hbFBhcmFtZXRlcnMoKTtcclxuXHQgICAgICAgIHZhciBtZXRob2QgPSB0aGlzLnBhcnNlUHJvcGVydHlNZXRob2QocGFyYW1zKTtcclxuXHQgICAgICAgIHRoaXMuY29udGV4dC5hbGxvd1lpZWxkID0gcHJldmlvdXNBbGxvd1lpZWxkO1xyXG5cdCAgICAgICAgdGhpcy5jb250ZXh0LmF3YWl0ID0gcHJldmlvdXNBd2FpdDtcclxuXHQgICAgICAgIHJldHVybiB0aGlzLmZpbmFsaXplKG5vZGUsIG5ldyBOb2RlLkFzeW5jRnVuY3Rpb25FeHByZXNzaW9uKG51bGwsIHBhcmFtcy5wYXJhbXMsIG1ldGhvZCkpO1xyXG5cdCAgICB9O1xyXG5cdCAgICBQYXJzZXIucHJvdG90eXBlLnBhcnNlT2JqZWN0UHJvcGVydHlLZXkgPSBmdW5jdGlvbiAoKSB7XHJcblx0ICAgICAgICB2YXIgbm9kZSA9IHRoaXMuY3JlYXRlTm9kZSgpO1xyXG5cdCAgICAgICAgdmFyIHRva2VuID0gdGhpcy5uZXh0VG9rZW4oKTtcclxuXHQgICAgICAgIHZhciBrZXk7XHJcblx0ICAgICAgICBzd2l0Y2ggKHRva2VuLnR5cGUpIHtcclxuXHQgICAgICAgICAgICBjYXNlIDggLyogU3RyaW5nTGl0ZXJhbCAqLzpcclxuXHQgICAgICAgICAgICBjYXNlIDYgLyogTnVtZXJpY0xpdGVyYWwgKi86XHJcblx0ICAgICAgICAgICAgICAgIGlmICh0aGlzLmNvbnRleHQuc3RyaWN0ICYmIHRva2VuLm9jdGFsKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICB0aGlzLnRvbGVyYXRlVW5leHBlY3RlZFRva2VuKHRva2VuLCBtZXNzYWdlc18xLk1lc3NhZ2VzLlN0cmljdE9jdGFsTGl0ZXJhbCk7XHJcblx0ICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgdmFyIHJhdyA9IHRoaXMuZ2V0VG9rZW5SYXcodG9rZW4pO1xyXG5cdCAgICAgICAgICAgICAgICBrZXkgPSB0aGlzLmZpbmFsaXplKG5vZGUsIG5ldyBOb2RlLkxpdGVyYWwodG9rZW4udmFsdWUsIHJhdykpO1xyXG5cdCAgICAgICAgICAgICAgICBicmVhaztcclxuXHQgICAgICAgICAgICBjYXNlIDMgLyogSWRlbnRpZmllciAqLzpcclxuXHQgICAgICAgICAgICBjYXNlIDEgLyogQm9vbGVhbkxpdGVyYWwgKi86XHJcblx0ICAgICAgICAgICAgY2FzZSA1IC8qIE51bGxMaXRlcmFsICovOlxyXG5cdCAgICAgICAgICAgIGNhc2UgNCAvKiBLZXl3b3JkICovOlxyXG5cdCAgICAgICAgICAgICAgICBrZXkgPSB0aGlzLmZpbmFsaXplKG5vZGUsIG5ldyBOb2RlLklkZW50aWZpZXIodG9rZW4udmFsdWUpKTtcclxuXHQgICAgICAgICAgICAgICAgYnJlYWs7XHJcblx0ICAgICAgICAgICAgY2FzZSA3IC8qIFB1bmN0dWF0b3IgKi86XHJcblx0ICAgICAgICAgICAgICAgIGlmICh0b2tlbi52YWx1ZSA9PT0gJ1snKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICBrZXkgPSB0aGlzLmlzb2xhdGVDb3ZlckdyYW1tYXIodGhpcy5wYXJzZUFzc2lnbm1lbnRFeHByZXNzaW9uKTtcclxuXHQgICAgICAgICAgICAgICAgICAgIHRoaXMuZXhwZWN0KCddJyk7XHJcblx0ICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgZWxzZSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICBrZXkgPSB0aGlzLnRocm93VW5leHBlY3RlZFRva2VuKHRva2VuKTtcclxuXHQgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICBicmVhaztcclxuXHQgICAgICAgICAgICBkZWZhdWx0OlxyXG5cdCAgICAgICAgICAgICAgICBrZXkgPSB0aGlzLnRocm93VW5leHBlY3RlZFRva2VuKHRva2VuKTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIHJldHVybiBrZXk7XHJcblx0ICAgIH07XHJcblx0ICAgIFBhcnNlci5wcm90b3R5cGUuaXNQcm9wZXJ0eUtleSA9IGZ1bmN0aW9uIChrZXksIHZhbHVlKSB7XHJcblx0ICAgICAgICByZXR1cm4gKGtleS50eXBlID09PSBzeW50YXhfMS5TeW50YXguSWRlbnRpZmllciAmJiBrZXkubmFtZSA9PT0gdmFsdWUpIHx8XHJcblx0ICAgICAgICAgICAgKGtleS50eXBlID09PSBzeW50YXhfMS5TeW50YXguTGl0ZXJhbCAmJiBrZXkudmFsdWUgPT09IHZhbHVlKTtcclxuXHQgICAgfTtcclxuXHQgICAgUGFyc2VyLnByb3RvdHlwZS5wYXJzZU9iamVjdFByb3BlcnR5ID0gZnVuY3Rpb24gKGhhc1Byb3RvKSB7XHJcblx0ICAgICAgICB2YXIgbm9kZSA9IHRoaXMuY3JlYXRlTm9kZSgpO1xyXG5cdCAgICAgICAgdmFyIHRva2VuID0gdGhpcy5sb29rYWhlYWQ7XHJcblx0ICAgICAgICB2YXIga2luZDtcclxuXHQgICAgICAgIHZhciBrZXkgPSBudWxsO1xyXG5cdCAgICAgICAgdmFyIHZhbHVlID0gbnVsbDtcclxuXHQgICAgICAgIHZhciBjb21wdXRlZCA9IGZhbHNlO1xyXG5cdCAgICAgICAgdmFyIG1ldGhvZCA9IGZhbHNlO1xyXG5cdCAgICAgICAgdmFyIHNob3J0aGFuZCA9IGZhbHNlO1xyXG5cdCAgICAgICAgdmFyIGlzQXN5bmMgPSBmYWxzZTtcclxuXHQgICAgICAgIGlmICh0b2tlbi50eXBlID09PSAzIC8qIElkZW50aWZpZXIgKi8pIHtcclxuXHQgICAgICAgICAgICB2YXIgaWQgPSB0b2tlbi52YWx1ZTtcclxuXHQgICAgICAgICAgICB0aGlzLm5leHRUb2tlbigpO1xyXG5cdCAgICAgICAgICAgIGNvbXB1dGVkID0gdGhpcy5tYXRjaCgnWycpO1xyXG5cdCAgICAgICAgICAgIGlzQXN5bmMgPSAhdGhpcy5oYXNMaW5lVGVybWluYXRvciAmJiAoaWQgPT09ICdhc3luYycpICYmXHJcblx0ICAgICAgICAgICAgICAgICF0aGlzLm1hdGNoKCc6JykgJiYgIXRoaXMubWF0Y2goJygnKSAmJiAhdGhpcy5tYXRjaCgnKicpO1xyXG5cdCAgICAgICAgICAgIGtleSA9IGlzQXN5bmMgPyB0aGlzLnBhcnNlT2JqZWN0UHJvcGVydHlLZXkoKSA6IHRoaXMuZmluYWxpemUobm9kZSwgbmV3IE5vZGUuSWRlbnRpZmllcihpZCkpO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgZWxzZSBpZiAodGhpcy5tYXRjaCgnKicpKSB7XHJcblx0ICAgICAgICAgICAgdGhpcy5uZXh0VG9rZW4oKTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIGVsc2Uge1xyXG5cdCAgICAgICAgICAgIGNvbXB1dGVkID0gdGhpcy5tYXRjaCgnWycpO1xyXG5cdCAgICAgICAgICAgIGtleSA9IHRoaXMucGFyc2VPYmplY3RQcm9wZXJ0eUtleSgpO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgdmFyIGxvb2thaGVhZFByb3BlcnR5S2V5ID0gdGhpcy5xdWFsaWZpZWRQcm9wZXJ0eU5hbWUodGhpcy5sb29rYWhlYWQpO1xyXG5cdCAgICAgICAgaWYgKHRva2VuLnR5cGUgPT09IDMgLyogSWRlbnRpZmllciAqLyAmJiAhaXNBc3luYyAmJiB0b2tlbi52YWx1ZSA9PT0gJ2dldCcgJiYgbG9va2FoZWFkUHJvcGVydHlLZXkpIHtcclxuXHQgICAgICAgICAgICBraW5kID0gJ2dldCc7XHJcblx0ICAgICAgICAgICAgY29tcHV0ZWQgPSB0aGlzLm1hdGNoKCdbJyk7XHJcblx0ICAgICAgICAgICAga2V5ID0gdGhpcy5wYXJzZU9iamVjdFByb3BlcnR5S2V5KCk7XHJcblx0ICAgICAgICAgICAgdGhpcy5jb250ZXh0LmFsbG93WWllbGQgPSBmYWxzZTtcclxuXHQgICAgICAgICAgICB2YWx1ZSA9IHRoaXMucGFyc2VHZXR0ZXJNZXRob2QoKTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIGVsc2UgaWYgKHRva2VuLnR5cGUgPT09IDMgLyogSWRlbnRpZmllciAqLyAmJiAhaXNBc3luYyAmJiB0b2tlbi52YWx1ZSA9PT0gJ3NldCcgJiYgbG9va2FoZWFkUHJvcGVydHlLZXkpIHtcclxuXHQgICAgICAgICAgICBraW5kID0gJ3NldCc7XHJcblx0ICAgICAgICAgICAgY29tcHV0ZWQgPSB0aGlzLm1hdGNoKCdbJyk7XHJcblx0ICAgICAgICAgICAga2V5ID0gdGhpcy5wYXJzZU9iamVjdFByb3BlcnR5S2V5KCk7XHJcblx0ICAgICAgICAgICAgdmFsdWUgPSB0aGlzLnBhcnNlU2V0dGVyTWV0aG9kKCk7XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICBlbHNlIGlmICh0b2tlbi50eXBlID09PSA3IC8qIFB1bmN0dWF0b3IgKi8gJiYgdG9rZW4udmFsdWUgPT09ICcqJyAmJiBsb29rYWhlYWRQcm9wZXJ0eUtleSkge1xyXG5cdCAgICAgICAgICAgIGtpbmQgPSAnaW5pdCc7XHJcblx0ICAgICAgICAgICAgY29tcHV0ZWQgPSB0aGlzLm1hdGNoKCdbJyk7XHJcblx0ICAgICAgICAgICAga2V5ID0gdGhpcy5wYXJzZU9iamVjdFByb3BlcnR5S2V5KCk7XHJcblx0ICAgICAgICAgICAgdmFsdWUgPSB0aGlzLnBhcnNlR2VuZXJhdG9yTWV0aG9kKCk7XHJcblx0ICAgICAgICAgICAgbWV0aG9kID0gdHJ1ZTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIGVsc2Uge1xyXG5cdCAgICAgICAgICAgIGlmICgha2V5KSB7XHJcblx0ICAgICAgICAgICAgICAgIHRoaXMudGhyb3dVbmV4cGVjdGVkVG9rZW4odGhpcy5sb29rYWhlYWQpO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICBraW5kID0gJ2luaXQnO1xyXG5cdCAgICAgICAgICAgIGlmICh0aGlzLm1hdGNoKCc6JykgJiYgIWlzQXN5bmMpIHtcclxuXHQgICAgICAgICAgICAgICAgaWYgKCFjb21wdXRlZCAmJiB0aGlzLmlzUHJvcGVydHlLZXkoa2V5LCAnX19wcm90b19fJykpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgIGlmIChoYXNQcm90by52YWx1ZSkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMudG9sZXJhdGVFcnJvcihtZXNzYWdlc18xLk1lc3NhZ2VzLkR1cGxpY2F0ZVByb3RvUHJvcGVydHkpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICAgICAgaGFzUHJvdG8udmFsdWUgPSB0cnVlO1xyXG5cdCAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgIHRoaXMubmV4dFRva2VuKCk7XHJcblx0ICAgICAgICAgICAgICAgIHZhbHVlID0gdGhpcy5pbmhlcml0Q292ZXJHcmFtbWFyKHRoaXMucGFyc2VBc3NpZ25tZW50RXhwcmVzc2lvbik7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMubWF0Y2goJygnKSkge1xyXG5cdCAgICAgICAgICAgICAgICB2YWx1ZSA9IGlzQXN5bmMgPyB0aGlzLnBhcnNlUHJvcGVydHlNZXRob2RBc3luY0Z1bmN0aW9uKCkgOiB0aGlzLnBhcnNlUHJvcGVydHlNZXRob2RGdW5jdGlvbigpO1xyXG5cdCAgICAgICAgICAgICAgICBtZXRob2QgPSB0cnVlO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICBlbHNlIGlmICh0b2tlbi50eXBlID09PSAzIC8qIElkZW50aWZpZXIgKi8pIHtcclxuXHQgICAgICAgICAgICAgICAgdmFyIGlkID0gdGhpcy5maW5hbGl6ZShub2RlLCBuZXcgTm9kZS5JZGVudGlmaWVyKHRva2VuLnZhbHVlKSk7XHJcblx0ICAgICAgICAgICAgICAgIGlmICh0aGlzLm1hdGNoKCc9JykpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgIHRoaXMuY29udGV4dC5maXJzdENvdmVySW5pdGlhbGl6ZWROYW1lRXJyb3IgPSB0aGlzLmxvb2thaGVhZDtcclxuXHQgICAgICAgICAgICAgICAgICAgIHRoaXMubmV4dFRva2VuKCk7XHJcblx0ICAgICAgICAgICAgICAgICAgICBzaG9ydGhhbmQgPSB0cnVlO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIGluaXQgPSB0aGlzLmlzb2xhdGVDb3ZlckdyYW1tYXIodGhpcy5wYXJzZUFzc2lnbm1lbnRFeHByZXNzaW9uKTtcclxuXHQgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gdGhpcy5maW5hbGl6ZShub2RlLCBuZXcgTm9kZS5Bc3NpZ25tZW50UGF0dGVybihpZCwgaW5pdCkpO1xyXG5cdCAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgIGVsc2Uge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgc2hvcnRoYW5kID0gdHJ1ZTtcclxuXHQgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gaWQ7XHJcblx0ICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgZWxzZSB7XHJcblx0ICAgICAgICAgICAgICAgIHRoaXMudGhyb3dVbmV4cGVjdGVkVG9rZW4odGhpcy5uZXh0VG9rZW4oKSk7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgcmV0dXJuIHRoaXMuZmluYWxpemUobm9kZSwgbmV3IE5vZGUuUHJvcGVydHkoa2luZCwga2V5LCBjb21wdXRlZCwgdmFsdWUsIG1ldGhvZCwgc2hvcnRoYW5kKSk7XHJcblx0ICAgIH07XHJcblx0ICAgIFBhcnNlci5wcm90b3R5cGUucGFyc2VPYmplY3RJbml0aWFsaXplciA9IGZ1bmN0aW9uICgpIHtcclxuXHQgICAgICAgIHZhciBub2RlID0gdGhpcy5jcmVhdGVOb2RlKCk7XHJcblx0ICAgICAgICB0aGlzLmV4cGVjdCgneycpO1xyXG5cdCAgICAgICAgdmFyIHByb3BlcnRpZXMgPSBbXTtcclxuXHQgICAgICAgIHZhciBoYXNQcm90byA9IHsgdmFsdWU6IGZhbHNlIH07XHJcblx0ICAgICAgICB3aGlsZSAoIXRoaXMubWF0Y2goJ30nKSkge1xyXG5cdCAgICAgICAgICAgIHByb3BlcnRpZXMucHVzaCh0aGlzLnBhcnNlT2JqZWN0UHJvcGVydHkoaGFzUHJvdG8pKTtcclxuXHQgICAgICAgICAgICBpZiAoIXRoaXMubWF0Y2goJ30nKSkge1xyXG5cdCAgICAgICAgICAgICAgICB0aGlzLmV4cGVjdENvbW1hU2VwYXJhdG9yKCk7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgdGhpcy5leHBlY3QoJ30nKTtcclxuXHQgICAgICAgIHJldHVybiB0aGlzLmZpbmFsaXplKG5vZGUsIG5ldyBOb2RlLk9iamVjdEV4cHJlc3Npb24ocHJvcGVydGllcykpO1xyXG5cdCAgICB9O1xyXG5cdCAgICAvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy10ZW1wbGF0ZS1saXRlcmFsc1xyXG5cdCAgICBQYXJzZXIucHJvdG90eXBlLnBhcnNlVGVtcGxhdGVIZWFkID0gZnVuY3Rpb24gKCkge1xyXG5cdCAgICAgICAgYXNzZXJ0XzEuYXNzZXJ0KHRoaXMubG9va2FoZWFkLmhlYWQsICdUZW1wbGF0ZSBsaXRlcmFsIG11c3Qgc3RhcnQgd2l0aCBhIHRlbXBsYXRlIGhlYWQnKTtcclxuXHQgICAgICAgIHZhciBub2RlID0gdGhpcy5jcmVhdGVOb2RlKCk7XHJcblx0ICAgICAgICB2YXIgdG9rZW4gPSB0aGlzLm5leHRUb2tlbigpO1xyXG5cdCAgICAgICAgdmFyIHJhdyA9IHRva2VuLnZhbHVlO1xyXG5cdCAgICAgICAgdmFyIGNvb2tlZCA9IHRva2VuLmNvb2tlZDtcclxuXHQgICAgICAgIHJldHVybiB0aGlzLmZpbmFsaXplKG5vZGUsIG5ldyBOb2RlLlRlbXBsYXRlRWxlbWVudCh7IHJhdzogcmF3LCBjb29rZWQ6IGNvb2tlZCB9LCB0b2tlbi50YWlsKSk7XHJcblx0ICAgIH07XHJcblx0ICAgIFBhcnNlci5wcm90b3R5cGUucGFyc2VUZW1wbGF0ZUVsZW1lbnQgPSBmdW5jdGlvbiAoKSB7XHJcblx0ICAgICAgICBpZiAodGhpcy5sb29rYWhlYWQudHlwZSAhPT0gMTAgLyogVGVtcGxhdGUgKi8pIHtcclxuXHQgICAgICAgICAgICB0aGlzLnRocm93VW5leHBlY3RlZFRva2VuKCk7XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICB2YXIgbm9kZSA9IHRoaXMuY3JlYXRlTm9kZSgpO1xyXG5cdCAgICAgICAgdmFyIHRva2VuID0gdGhpcy5uZXh0VG9rZW4oKTtcclxuXHQgICAgICAgIHZhciByYXcgPSB0b2tlbi52YWx1ZTtcclxuXHQgICAgICAgIHZhciBjb29rZWQgPSB0b2tlbi5jb29rZWQ7XHJcblx0ICAgICAgICByZXR1cm4gdGhpcy5maW5hbGl6ZShub2RlLCBuZXcgTm9kZS5UZW1wbGF0ZUVsZW1lbnQoeyByYXc6IHJhdywgY29va2VkOiBjb29rZWQgfSwgdG9rZW4udGFpbCkpO1xyXG5cdCAgICB9O1xyXG5cdCAgICBQYXJzZXIucHJvdG90eXBlLnBhcnNlVGVtcGxhdGVMaXRlcmFsID0gZnVuY3Rpb24gKCkge1xyXG5cdCAgICAgICAgdmFyIG5vZGUgPSB0aGlzLmNyZWF0ZU5vZGUoKTtcclxuXHQgICAgICAgIHZhciBleHByZXNzaW9ucyA9IFtdO1xyXG5cdCAgICAgICAgdmFyIHF1YXNpcyA9IFtdO1xyXG5cdCAgICAgICAgdmFyIHF1YXNpID0gdGhpcy5wYXJzZVRlbXBsYXRlSGVhZCgpO1xyXG5cdCAgICAgICAgcXVhc2lzLnB1c2gocXVhc2kpO1xyXG5cdCAgICAgICAgd2hpbGUgKCFxdWFzaS50YWlsKSB7XHJcblx0ICAgICAgICAgICAgZXhwcmVzc2lvbnMucHVzaCh0aGlzLnBhcnNlRXhwcmVzc2lvbigpKTtcclxuXHQgICAgICAgICAgICBxdWFzaSA9IHRoaXMucGFyc2VUZW1wbGF0ZUVsZW1lbnQoKTtcclxuXHQgICAgICAgICAgICBxdWFzaXMucHVzaChxdWFzaSk7XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICByZXR1cm4gdGhpcy5maW5hbGl6ZShub2RlLCBuZXcgTm9kZS5UZW1wbGF0ZUxpdGVyYWwocXVhc2lzLCBleHByZXNzaW9ucykpO1xyXG5cdCAgICB9O1xyXG5cdCAgICAvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1ncm91cGluZy1vcGVyYXRvclxyXG5cdCAgICBQYXJzZXIucHJvdG90eXBlLnJlaW50ZXJwcmV0RXhwcmVzc2lvbkFzUGF0dGVybiA9IGZ1bmN0aW9uIChleHByKSB7XHJcblx0ICAgICAgICBzd2l0Y2ggKGV4cHIudHlwZSkge1xyXG5cdCAgICAgICAgICAgIGNhc2Ugc3ludGF4XzEuU3ludGF4LklkZW50aWZpZXI6XHJcblx0ICAgICAgICAgICAgY2FzZSBzeW50YXhfMS5TeW50YXguTWVtYmVyRXhwcmVzc2lvbjpcclxuXHQgICAgICAgICAgICBjYXNlIHN5bnRheF8xLlN5bnRheC5SZXN0RWxlbWVudDpcclxuXHQgICAgICAgICAgICBjYXNlIHN5bnRheF8xLlN5bnRheC5Bc3NpZ25tZW50UGF0dGVybjpcclxuXHQgICAgICAgICAgICAgICAgYnJlYWs7XHJcblx0ICAgICAgICAgICAgY2FzZSBzeW50YXhfMS5TeW50YXguU3ByZWFkRWxlbWVudDpcclxuXHQgICAgICAgICAgICAgICAgZXhwci50eXBlID0gc3ludGF4XzEuU3ludGF4LlJlc3RFbGVtZW50O1xyXG5cdCAgICAgICAgICAgICAgICB0aGlzLnJlaW50ZXJwcmV0RXhwcmVzc2lvbkFzUGF0dGVybihleHByLmFyZ3VtZW50KTtcclxuXHQgICAgICAgICAgICAgICAgYnJlYWs7XHJcblx0ICAgICAgICAgICAgY2FzZSBzeW50YXhfMS5TeW50YXguQXJyYXlFeHByZXNzaW9uOlxyXG5cdCAgICAgICAgICAgICAgICBleHByLnR5cGUgPSBzeW50YXhfMS5TeW50YXguQXJyYXlQYXR0ZXJuO1xyXG5cdCAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGV4cHIuZWxlbWVudHMubGVuZ3RoOyBpKyspIHtcclxuXHQgICAgICAgICAgICAgICAgICAgIGlmIChleHByLmVsZW1lbnRzW2ldICE9PSBudWxsKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5yZWludGVycHJldEV4cHJlc3Npb25Bc1BhdHRlcm4oZXhwci5lbGVtZW50c1tpXSk7XHJcblx0ICAgICAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgYnJlYWs7XHJcblx0ICAgICAgICAgICAgY2FzZSBzeW50YXhfMS5TeW50YXguT2JqZWN0RXhwcmVzc2lvbjpcclxuXHQgICAgICAgICAgICAgICAgZXhwci50eXBlID0gc3ludGF4XzEuU3ludGF4Lk9iamVjdFBhdHRlcm47XHJcblx0ICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZXhwci5wcm9wZXJ0aWVzLmxlbmd0aDsgaSsrKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICB0aGlzLnJlaW50ZXJwcmV0RXhwcmVzc2lvbkFzUGF0dGVybihleHByLnByb3BlcnRpZXNbaV0udmFsdWUpO1xyXG5cdCAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cdCAgICAgICAgICAgIGNhc2Ugc3ludGF4XzEuU3ludGF4LkFzc2lnbm1lbnRFeHByZXNzaW9uOlxyXG5cdCAgICAgICAgICAgICAgICBleHByLnR5cGUgPSBzeW50YXhfMS5TeW50YXguQXNzaWdubWVudFBhdHRlcm47XHJcblx0ICAgICAgICAgICAgICAgIGRlbGV0ZSBleHByLm9wZXJhdG9yO1xyXG5cdCAgICAgICAgICAgICAgICB0aGlzLnJlaW50ZXJwcmV0RXhwcmVzc2lvbkFzUGF0dGVybihleHByLmxlZnQpO1xyXG5cdCAgICAgICAgICAgICAgICBicmVhaztcclxuXHQgICAgICAgICAgICBkZWZhdWx0OlxyXG5cdCAgICAgICAgICAgICAgICAvLyBBbGxvdyBvdGhlciBub2RlIHR5cGUgZm9yIHRvbGVyYW50IHBhcnNpbmcuXHJcblx0ICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICB9O1xyXG5cdCAgICBQYXJzZXIucHJvdG90eXBlLnBhcnNlR3JvdXBFeHByZXNzaW9uID0gZnVuY3Rpb24gKCkge1xyXG5cdCAgICAgICAgdmFyIGV4cHI7XHJcblx0ICAgICAgICB0aGlzLmV4cGVjdCgnKCcpO1xyXG5cdCAgICAgICAgaWYgKHRoaXMubWF0Y2goJyknKSkge1xyXG5cdCAgICAgICAgICAgIHRoaXMubmV4dFRva2VuKCk7XHJcblx0ICAgICAgICAgICAgaWYgKCF0aGlzLm1hdGNoKCc9PicpKSB7XHJcblx0ICAgICAgICAgICAgICAgIHRoaXMuZXhwZWN0KCc9PicpO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICBleHByID0ge1xyXG5cdCAgICAgICAgICAgICAgICB0eXBlOiBBcnJvd1BhcmFtZXRlclBsYWNlSG9sZGVyLFxyXG5cdCAgICAgICAgICAgICAgICBwYXJhbXM6IFtdLFxyXG5cdCAgICAgICAgICAgICAgICBhc3luYzogZmFsc2VcclxuXHQgICAgICAgICAgICB9O1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgZWxzZSB7XHJcblx0ICAgICAgICAgICAgdmFyIHN0YXJ0VG9rZW4gPSB0aGlzLmxvb2thaGVhZDtcclxuXHQgICAgICAgICAgICB2YXIgcGFyYW1zID0gW107XHJcblx0ICAgICAgICAgICAgaWYgKHRoaXMubWF0Y2goJy4uLicpKSB7XHJcblx0ICAgICAgICAgICAgICAgIGV4cHIgPSB0aGlzLnBhcnNlUmVzdEVsZW1lbnQocGFyYW1zKTtcclxuXHQgICAgICAgICAgICAgICAgdGhpcy5leHBlY3QoJyknKTtcclxuXHQgICAgICAgICAgICAgICAgaWYgKCF0aGlzLm1hdGNoKCc9PicpKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICB0aGlzLmV4cGVjdCgnPT4nKTtcclxuXHQgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICBleHByID0ge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgdHlwZTogQXJyb3dQYXJhbWV0ZXJQbGFjZUhvbGRlcixcclxuXHQgICAgICAgICAgICAgICAgICAgIHBhcmFtczogW2V4cHJdLFxyXG5cdCAgICAgICAgICAgICAgICAgICAgYXN5bmM6IGZhbHNlXHJcblx0ICAgICAgICAgICAgICAgIH07XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgIGVsc2Uge1xyXG5cdCAgICAgICAgICAgICAgICB2YXIgYXJyb3cgPSBmYWxzZTtcclxuXHQgICAgICAgICAgICAgICAgdGhpcy5jb250ZXh0LmlzQmluZGluZ0VsZW1lbnQgPSB0cnVlO1xyXG5cdCAgICAgICAgICAgICAgICBleHByID0gdGhpcy5pbmhlcml0Q292ZXJHcmFtbWFyKHRoaXMucGFyc2VBc3NpZ25tZW50RXhwcmVzc2lvbik7XHJcblx0ICAgICAgICAgICAgICAgIGlmICh0aGlzLm1hdGNoKCcsJykpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgIHZhciBleHByZXNzaW9ucyA9IFtdO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgdGhpcy5jb250ZXh0LmlzQXNzaWdubWVudFRhcmdldCA9IGZhbHNlO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgZXhwcmVzc2lvbnMucHVzaChleHByKTtcclxuXHQgICAgICAgICAgICAgICAgICAgIHdoaWxlICh0aGlzLmxvb2thaGVhZC50eXBlICE9PSAyIC8qIEVPRiAqLykge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGlmICghdGhpcy5tYXRjaCgnLCcpKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm5leHRUb2tlbigpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLm1hdGNoKCcpJykpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5uZXh0VG9rZW4oKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBleHByZXNzaW9ucy5sZW5ndGg7IGkrKykge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5yZWludGVycHJldEV4cHJlc3Npb25Bc1BhdHRlcm4oZXhwcmVzc2lvbnNbaV0pO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFycm93ID0gdHJ1ZTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXhwciA9IHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IEFycm93UGFyYW1ldGVyUGxhY2VIb2xkZXIsXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXJhbXM6IGV4cHJlc3Npb25zLFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXN5bmM6IGZhbHNlXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIH07XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMubWF0Y2goJy4uLicpKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghdGhpcy5jb250ZXh0LmlzQmluZGluZ0VsZW1lbnQpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMudGhyb3dVbmV4cGVjdGVkVG9rZW4odGhpcy5sb29rYWhlYWQpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV4cHJlc3Npb25zLnB1c2godGhpcy5wYXJzZVJlc3RFbGVtZW50KHBhcmFtcykpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmV4cGVjdCgnKScpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXRoaXMubWF0Y2goJz0+JykpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZXhwZWN0KCc9PicpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY29udGV4dC5pc0JpbmRpbmdFbGVtZW50ID0gZmFsc2U7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZXhwcmVzc2lvbnMubGVuZ3RoOyBpKyspIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucmVpbnRlcnByZXRFeHByZXNzaW9uQXNQYXR0ZXJuKGV4cHJlc3Npb25zW2ldKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcnJvdyA9IHRydWU7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV4cHIgPSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBBcnJvd1BhcmFtZXRlclBsYWNlSG9sZGVyLFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFyYW1zOiBleHByZXNzaW9ucyxcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFzeW5jOiBmYWxzZVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXhwcmVzc2lvbnMucHVzaCh0aGlzLmluaGVyaXRDb3ZlckdyYW1tYXIodGhpcy5wYXJzZUFzc2lnbm1lbnRFeHByZXNzaW9uKSk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGlmIChhcnJvdykge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgICAgICBpZiAoIWFycm93KSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgZXhwciA9IHRoaXMuZmluYWxpemUodGhpcy5zdGFydE5vZGUoc3RhcnRUb2tlbiksIG5ldyBOb2RlLlNlcXVlbmNlRXhwcmVzc2lvbihleHByZXNzaW9ucykpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgIGlmICghYXJyb3cpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgIHRoaXMuZXhwZWN0KCcpJyk7XHJcblx0ICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5tYXRjaCgnPT4nKSkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGlmIChleHByLnR5cGUgPT09IHN5bnRheF8xLlN5bnRheC5JZGVudGlmaWVyICYmIGV4cHIubmFtZSA9PT0gJ3lpZWxkJykge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcnJvdyA9IHRydWU7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV4cHIgPSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBBcnJvd1BhcmFtZXRlclBsYWNlSG9sZGVyLFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFyYW1zOiBbZXhwcl0sXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhc3luYzogZmFsc2VcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgfTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFhcnJvdykge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXRoaXMuY29udGV4dC5pc0JpbmRpbmdFbGVtZW50KSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnRocm93VW5leHBlY3RlZFRva2VuKHRoaXMubG9va2FoZWFkKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZXhwci50eXBlID09PSBzeW50YXhfMS5TeW50YXguU2VxdWVuY2VFeHByZXNzaW9uKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGV4cHIuZXhwcmVzc2lvbnMubGVuZ3RoOyBpKyspIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnJlaW50ZXJwcmV0RXhwcmVzc2lvbkFzUGF0dGVybihleHByLmV4cHJlc3Npb25zW2ldKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucmVpbnRlcnByZXRFeHByZXNzaW9uQXNQYXR0ZXJuKGV4cHIpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBwYXJhbWV0ZXJzID0gKGV4cHIudHlwZSA9PT0gc3ludGF4XzEuU3ludGF4LlNlcXVlbmNlRXhwcmVzc2lvbiA/IGV4cHIuZXhwcmVzc2lvbnMgOiBbZXhwcl0pO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBleHByID0ge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogQXJyb3dQYXJhbWV0ZXJQbGFjZUhvbGRlcixcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcmFtczogcGFyYW1ldGVycyxcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFzeW5jOiBmYWxzZVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgICAgIHRoaXMuY29udGV4dC5pc0JpbmRpbmdFbGVtZW50ID0gZmFsc2U7XHJcblx0ICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICByZXR1cm4gZXhwcjtcclxuXHQgICAgfTtcclxuXHQgICAgLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtbGVmdC1oYW5kLXNpZGUtZXhwcmVzc2lvbnNcclxuXHQgICAgUGFyc2VyLnByb3RvdHlwZS5wYXJzZUFyZ3VtZW50cyA9IGZ1bmN0aW9uICgpIHtcclxuXHQgICAgICAgIHRoaXMuZXhwZWN0KCcoJyk7XHJcblx0ICAgICAgICB2YXIgYXJncyA9IFtdO1xyXG5cdCAgICAgICAgaWYgKCF0aGlzLm1hdGNoKCcpJykpIHtcclxuXHQgICAgICAgICAgICB3aGlsZSAodHJ1ZSkge1xyXG5cdCAgICAgICAgICAgICAgICB2YXIgZXhwciA9IHRoaXMubWF0Y2goJy4uLicpID8gdGhpcy5wYXJzZVNwcmVhZEVsZW1lbnQoKSA6XHJcblx0ICAgICAgICAgICAgICAgICAgICB0aGlzLmlzb2xhdGVDb3ZlckdyYW1tYXIodGhpcy5wYXJzZUFzc2lnbm1lbnRFeHByZXNzaW9uKTtcclxuXHQgICAgICAgICAgICAgICAgYXJncy5wdXNoKGV4cHIpO1xyXG5cdCAgICAgICAgICAgICAgICBpZiAodGhpcy5tYXRjaCgnKScpKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuXHQgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICB0aGlzLmV4cGVjdENvbW1hU2VwYXJhdG9yKCk7XHJcblx0ICAgICAgICAgICAgICAgIGlmICh0aGlzLm1hdGNoKCcpJykpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cdCAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgdGhpcy5leHBlY3QoJyknKTtcclxuXHQgICAgICAgIHJldHVybiBhcmdzO1xyXG5cdCAgICB9O1xyXG5cdCAgICBQYXJzZXIucHJvdG90eXBlLmlzSWRlbnRpZmllck5hbWUgPSBmdW5jdGlvbiAodG9rZW4pIHtcclxuXHQgICAgICAgIHJldHVybiB0b2tlbi50eXBlID09PSAzIC8qIElkZW50aWZpZXIgKi8gfHxcclxuXHQgICAgICAgICAgICB0b2tlbi50eXBlID09PSA0IC8qIEtleXdvcmQgKi8gfHxcclxuXHQgICAgICAgICAgICB0b2tlbi50eXBlID09PSAxIC8qIEJvb2xlYW5MaXRlcmFsICovIHx8XHJcblx0ICAgICAgICAgICAgdG9rZW4udHlwZSA9PT0gNSAvKiBOdWxsTGl0ZXJhbCAqLztcclxuXHQgICAgfTtcclxuXHQgICAgUGFyc2VyLnByb3RvdHlwZS5wYXJzZUlkZW50aWZpZXJOYW1lID0gZnVuY3Rpb24gKCkge1xyXG5cdCAgICAgICAgdmFyIG5vZGUgPSB0aGlzLmNyZWF0ZU5vZGUoKTtcclxuXHQgICAgICAgIHZhciB0b2tlbiA9IHRoaXMubmV4dFRva2VuKCk7XHJcblx0ICAgICAgICBpZiAoIXRoaXMuaXNJZGVudGlmaWVyTmFtZSh0b2tlbikpIHtcclxuXHQgICAgICAgICAgICB0aGlzLnRocm93VW5leHBlY3RlZFRva2VuKHRva2VuKTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIHJldHVybiB0aGlzLmZpbmFsaXplKG5vZGUsIG5ldyBOb2RlLklkZW50aWZpZXIodG9rZW4udmFsdWUpKTtcclxuXHQgICAgfTtcclxuXHQgICAgUGFyc2VyLnByb3RvdHlwZS5wYXJzZU5ld0V4cHJlc3Npb24gPSBmdW5jdGlvbiAoKSB7XHJcblx0ICAgICAgICB2YXIgbm9kZSA9IHRoaXMuY3JlYXRlTm9kZSgpO1xyXG5cdCAgICAgICAgdmFyIGlkID0gdGhpcy5wYXJzZUlkZW50aWZpZXJOYW1lKCk7XHJcblx0ICAgICAgICBhc3NlcnRfMS5hc3NlcnQoaWQubmFtZSA9PT0gJ25ldycsICdOZXcgZXhwcmVzc2lvbiBtdXN0IHN0YXJ0IHdpdGggYG5ld2AnKTtcclxuXHQgICAgICAgIHZhciBleHByO1xyXG5cdCAgICAgICAgaWYgKHRoaXMubWF0Y2goJy4nKSkge1xyXG5cdCAgICAgICAgICAgIHRoaXMubmV4dFRva2VuKCk7XHJcblx0ICAgICAgICAgICAgaWYgKHRoaXMubG9va2FoZWFkLnR5cGUgPT09IDMgLyogSWRlbnRpZmllciAqLyAmJiB0aGlzLmNvbnRleHQuaW5GdW5jdGlvbkJvZHkgJiYgdGhpcy5sb29rYWhlYWQudmFsdWUgPT09ICd0YXJnZXQnKSB7XHJcblx0ICAgICAgICAgICAgICAgIHZhciBwcm9wZXJ0eSA9IHRoaXMucGFyc2VJZGVudGlmaWVyTmFtZSgpO1xyXG5cdCAgICAgICAgICAgICAgICBleHByID0gbmV3IE5vZGUuTWV0YVByb3BlcnR5KGlkLCBwcm9wZXJ0eSk7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgIGVsc2Uge1xyXG5cdCAgICAgICAgICAgICAgICB0aGlzLnRocm93VW5leHBlY3RlZFRva2VuKHRoaXMubG9va2FoZWFkKTtcclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICBlbHNlIHtcclxuXHQgICAgICAgICAgICB2YXIgY2FsbGVlID0gdGhpcy5pc29sYXRlQ292ZXJHcmFtbWFyKHRoaXMucGFyc2VMZWZ0SGFuZFNpZGVFeHByZXNzaW9uKTtcclxuXHQgICAgICAgICAgICB2YXIgYXJncyA9IHRoaXMubWF0Y2goJygnKSA/IHRoaXMucGFyc2VBcmd1bWVudHMoKSA6IFtdO1xyXG5cdCAgICAgICAgICAgIGV4cHIgPSBuZXcgTm9kZS5OZXdFeHByZXNzaW9uKGNhbGxlZSwgYXJncyk7XHJcblx0ICAgICAgICAgICAgdGhpcy5jb250ZXh0LmlzQXNzaWdubWVudFRhcmdldCA9IGZhbHNlO1xyXG5cdCAgICAgICAgICAgIHRoaXMuY29udGV4dC5pc0JpbmRpbmdFbGVtZW50ID0gZmFsc2U7XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICByZXR1cm4gdGhpcy5maW5hbGl6ZShub2RlLCBleHByKTtcclxuXHQgICAgfTtcclxuXHQgICAgUGFyc2VyLnByb3RvdHlwZS5wYXJzZUFzeW5jQXJndW1lbnQgPSBmdW5jdGlvbiAoKSB7XHJcblx0ICAgICAgICB2YXIgYXJnID0gdGhpcy5wYXJzZUFzc2lnbm1lbnRFeHByZXNzaW9uKCk7XHJcblx0ICAgICAgICB0aGlzLmNvbnRleHQuZmlyc3RDb3ZlckluaXRpYWxpemVkTmFtZUVycm9yID0gbnVsbDtcclxuXHQgICAgICAgIHJldHVybiBhcmc7XHJcblx0ICAgIH07XHJcblx0ICAgIFBhcnNlci5wcm90b3R5cGUucGFyc2VBc3luY0FyZ3VtZW50cyA9IGZ1bmN0aW9uICgpIHtcclxuXHQgICAgICAgIHRoaXMuZXhwZWN0KCcoJyk7XHJcblx0ICAgICAgICB2YXIgYXJncyA9IFtdO1xyXG5cdCAgICAgICAgaWYgKCF0aGlzLm1hdGNoKCcpJykpIHtcclxuXHQgICAgICAgICAgICB3aGlsZSAodHJ1ZSkge1xyXG5cdCAgICAgICAgICAgICAgICB2YXIgZXhwciA9IHRoaXMubWF0Y2goJy4uLicpID8gdGhpcy5wYXJzZVNwcmVhZEVsZW1lbnQoKSA6XHJcblx0ICAgICAgICAgICAgICAgICAgICB0aGlzLmlzb2xhdGVDb3ZlckdyYW1tYXIodGhpcy5wYXJzZUFzeW5jQXJndW1lbnQpO1xyXG5cdCAgICAgICAgICAgICAgICBhcmdzLnB1c2goZXhwcik7XHJcblx0ICAgICAgICAgICAgICAgIGlmICh0aGlzLm1hdGNoKCcpJykpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cdCAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgIHRoaXMuZXhwZWN0Q29tbWFTZXBhcmF0b3IoKTtcclxuXHQgICAgICAgICAgICAgICAgaWYgKHRoaXMubWF0Y2goJyknKSkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcblx0ICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICB0aGlzLmV4cGVjdCgnKScpO1xyXG5cdCAgICAgICAgcmV0dXJuIGFyZ3M7XHJcblx0ICAgIH07XHJcblx0ICAgIFBhcnNlci5wcm90b3R5cGUucGFyc2VMZWZ0SGFuZFNpZGVFeHByZXNzaW9uQWxsb3dDYWxsID0gZnVuY3Rpb24gKCkge1xyXG5cdCAgICAgICAgdmFyIHN0YXJ0VG9rZW4gPSB0aGlzLmxvb2thaGVhZDtcclxuXHQgICAgICAgIHZhciBtYXliZUFzeW5jID0gdGhpcy5tYXRjaENvbnRleHR1YWxLZXl3b3JkKCdhc3luYycpO1xyXG5cdCAgICAgICAgdmFyIHByZXZpb3VzQWxsb3dJbiA9IHRoaXMuY29udGV4dC5hbGxvd0luO1xyXG5cdCAgICAgICAgdGhpcy5jb250ZXh0LmFsbG93SW4gPSB0cnVlO1xyXG5cdCAgICAgICAgdmFyIGV4cHI7XHJcblx0ICAgICAgICBpZiAodGhpcy5tYXRjaEtleXdvcmQoJ3N1cGVyJykgJiYgdGhpcy5jb250ZXh0LmluRnVuY3Rpb25Cb2R5KSB7XHJcblx0ICAgICAgICAgICAgZXhwciA9IHRoaXMuY3JlYXRlTm9kZSgpO1xyXG5cdCAgICAgICAgICAgIHRoaXMubmV4dFRva2VuKCk7XHJcblx0ICAgICAgICAgICAgZXhwciA9IHRoaXMuZmluYWxpemUoZXhwciwgbmV3IE5vZGUuU3VwZXIoKSk7XHJcblx0ICAgICAgICAgICAgaWYgKCF0aGlzLm1hdGNoKCcoJykgJiYgIXRoaXMubWF0Y2goJy4nKSAmJiAhdGhpcy5tYXRjaCgnWycpKSB7XHJcblx0ICAgICAgICAgICAgICAgIHRoaXMudGhyb3dVbmV4cGVjdGVkVG9rZW4odGhpcy5sb29rYWhlYWQpO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIGVsc2Uge1xyXG5cdCAgICAgICAgICAgIGV4cHIgPSB0aGlzLmluaGVyaXRDb3ZlckdyYW1tYXIodGhpcy5tYXRjaEtleXdvcmQoJ25ldycpID8gdGhpcy5wYXJzZU5ld0V4cHJlc3Npb24gOiB0aGlzLnBhcnNlUHJpbWFyeUV4cHJlc3Npb24pO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgd2hpbGUgKHRydWUpIHtcclxuXHQgICAgICAgICAgICBpZiAodGhpcy5tYXRjaCgnLicpKSB7XHJcblx0ICAgICAgICAgICAgICAgIHRoaXMuY29udGV4dC5pc0JpbmRpbmdFbGVtZW50ID0gZmFsc2U7XHJcblx0ICAgICAgICAgICAgICAgIHRoaXMuY29udGV4dC5pc0Fzc2lnbm1lbnRUYXJnZXQgPSB0cnVlO1xyXG5cdCAgICAgICAgICAgICAgICB0aGlzLmV4cGVjdCgnLicpO1xyXG5cdCAgICAgICAgICAgICAgICB2YXIgcHJvcGVydHkgPSB0aGlzLnBhcnNlSWRlbnRpZmllck5hbWUoKTtcclxuXHQgICAgICAgICAgICAgICAgZXhwciA9IHRoaXMuZmluYWxpemUodGhpcy5zdGFydE5vZGUoc3RhcnRUb2tlbiksIG5ldyBOb2RlLlN0YXRpY01lbWJlckV4cHJlc3Npb24oZXhwciwgcHJvcGVydHkpKTtcclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5tYXRjaCgnKCcpKSB7XHJcblx0ICAgICAgICAgICAgICAgIHZhciBhc3luY0Fycm93ID0gbWF5YmVBc3luYyAmJiAoc3RhcnRUb2tlbi5saW5lTnVtYmVyID09PSB0aGlzLmxvb2thaGVhZC5saW5lTnVtYmVyKTtcclxuXHQgICAgICAgICAgICAgICAgdGhpcy5jb250ZXh0LmlzQmluZGluZ0VsZW1lbnQgPSBmYWxzZTtcclxuXHQgICAgICAgICAgICAgICAgdGhpcy5jb250ZXh0LmlzQXNzaWdubWVudFRhcmdldCA9IGZhbHNlO1xyXG5cdCAgICAgICAgICAgICAgICB2YXIgYXJncyA9IGFzeW5jQXJyb3cgPyB0aGlzLnBhcnNlQXN5bmNBcmd1bWVudHMoKSA6IHRoaXMucGFyc2VBcmd1bWVudHMoKTtcclxuXHQgICAgICAgICAgICAgICAgZXhwciA9IHRoaXMuZmluYWxpemUodGhpcy5zdGFydE5vZGUoc3RhcnRUb2tlbiksIG5ldyBOb2RlLkNhbGxFeHByZXNzaW9uKGV4cHIsIGFyZ3MpKTtcclxuXHQgICAgICAgICAgICAgICAgaWYgKGFzeW5jQXJyb3cgJiYgdGhpcy5tYXRjaCgnPT4nKSkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcmdzLmxlbmd0aDsgKytpKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5yZWludGVycHJldEV4cHJlc3Npb25Bc1BhdHRlcm4oYXJnc1tpXSk7XHJcblx0ICAgICAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgICAgICBleHByID0ge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IEFycm93UGFyYW1ldGVyUGxhY2VIb2xkZXIsXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcGFyYW1zOiBhcmdzLFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGFzeW5jOiB0cnVlXHJcblx0ICAgICAgICAgICAgICAgICAgICB9O1xyXG5cdCAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMubWF0Y2goJ1snKSkge1xyXG5cdCAgICAgICAgICAgICAgICB0aGlzLmNvbnRleHQuaXNCaW5kaW5nRWxlbWVudCA9IGZhbHNlO1xyXG5cdCAgICAgICAgICAgICAgICB0aGlzLmNvbnRleHQuaXNBc3NpZ25tZW50VGFyZ2V0ID0gdHJ1ZTtcclxuXHQgICAgICAgICAgICAgICAgdGhpcy5leHBlY3QoJ1snKTtcclxuXHQgICAgICAgICAgICAgICAgdmFyIHByb3BlcnR5ID0gdGhpcy5pc29sYXRlQ292ZXJHcmFtbWFyKHRoaXMucGFyc2VFeHByZXNzaW9uKTtcclxuXHQgICAgICAgICAgICAgICAgdGhpcy5leHBlY3QoJ10nKTtcclxuXHQgICAgICAgICAgICAgICAgZXhwciA9IHRoaXMuZmluYWxpemUodGhpcy5zdGFydE5vZGUoc3RhcnRUb2tlbiksIG5ldyBOb2RlLkNvbXB1dGVkTWVtYmVyRXhwcmVzc2lvbihleHByLCBwcm9wZXJ0eSkpO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICBlbHNlIGlmICh0aGlzLmxvb2thaGVhZC50eXBlID09PSAxMCAvKiBUZW1wbGF0ZSAqLyAmJiB0aGlzLmxvb2thaGVhZC5oZWFkKSB7XHJcblx0ICAgICAgICAgICAgICAgIHZhciBxdWFzaSA9IHRoaXMucGFyc2VUZW1wbGF0ZUxpdGVyYWwoKTtcclxuXHQgICAgICAgICAgICAgICAgZXhwciA9IHRoaXMuZmluYWxpemUodGhpcy5zdGFydE5vZGUoc3RhcnRUb2tlbiksIG5ldyBOb2RlLlRhZ2dlZFRlbXBsYXRlRXhwcmVzc2lvbihleHByLCBxdWFzaSkpO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICBlbHNlIHtcclxuXHQgICAgICAgICAgICAgICAgYnJlYWs7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgdGhpcy5jb250ZXh0LmFsbG93SW4gPSBwcmV2aW91c0FsbG93SW47XHJcblx0ICAgICAgICByZXR1cm4gZXhwcjtcclxuXHQgICAgfTtcclxuXHQgICAgUGFyc2VyLnByb3RvdHlwZS5wYXJzZVN1cGVyID0gZnVuY3Rpb24gKCkge1xyXG5cdCAgICAgICAgdmFyIG5vZGUgPSB0aGlzLmNyZWF0ZU5vZGUoKTtcclxuXHQgICAgICAgIHRoaXMuZXhwZWN0S2V5d29yZCgnc3VwZXInKTtcclxuXHQgICAgICAgIGlmICghdGhpcy5tYXRjaCgnWycpICYmICF0aGlzLm1hdGNoKCcuJykpIHtcclxuXHQgICAgICAgICAgICB0aGlzLnRocm93VW5leHBlY3RlZFRva2VuKHRoaXMubG9va2FoZWFkKTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIHJldHVybiB0aGlzLmZpbmFsaXplKG5vZGUsIG5ldyBOb2RlLlN1cGVyKCkpO1xyXG5cdCAgICB9O1xyXG5cdCAgICBQYXJzZXIucHJvdG90eXBlLnBhcnNlTGVmdEhhbmRTaWRlRXhwcmVzc2lvbiA9IGZ1bmN0aW9uICgpIHtcclxuXHQgICAgICAgIGFzc2VydF8xLmFzc2VydCh0aGlzLmNvbnRleHQuYWxsb3dJbiwgJ2NhbGxlZSBvZiBuZXcgZXhwcmVzc2lvbiBhbHdheXMgYWxsb3cgaW4ga2V5d29yZC4nKTtcclxuXHQgICAgICAgIHZhciBub2RlID0gdGhpcy5zdGFydE5vZGUodGhpcy5sb29rYWhlYWQpO1xyXG5cdCAgICAgICAgdmFyIGV4cHIgPSAodGhpcy5tYXRjaEtleXdvcmQoJ3N1cGVyJykgJiYgdGhpcy5jb250ZXh0LmluRnVuY3Rpb25Cb2R5KSA/IHRoaXMucGFyc2VTdXBlcigpIDpcclxuXHQgICAgICAgICAgICB0aGlzLmluaGVyaXRDb3ZlckdyYW1tYXIodGhpcy5tYXRjaEtleXdvcmQoJ25ldycpID8gdGhpcy5wYXJzZU5ld0V4cHJlc3Npb24gOiB0aGlzLnBhcnNlUHJpbWFyeUV4cHJlc3Npb24pO1xyXG5cdCAgICAgICAgd2hpbGUgKHRydWUpIHtcclxuXHQgICAgICAgICAgICBpZiAodGhpcy5tYXRjaCgnWycpKSB7XHJcblx0ICAgICAgICAgICAgICAgIHRoaXMuY29udGV4dC5pc0JpbmRpbmdFbGVtZW50ID0gZmFsc2U7XHJcblx0ICAgICAgICAgICAgICAgIHRoaXMuY29udGV4dC5pc0Fzc2lnbm1lbnRUYXJnZXQgPSB0cnVlO1xyXG5cdCAgICAgICAgICAgICAgICB0aGlzLmV4cGVjdCgnWycpO1xyXG5cdCAgICAgICAgICAgICAgICB2YXIgcHJvcGVydHkgPSB0aGlzLmlzb2xhdGVDb3ZlckdyYW1tYXIodGhpcy5wYXJzZUV4cHJlc3Npb24pO1xyXG5cdCAgICAgICAgICAgICAgICB0aGlzLmV4cGVjdCgnXScpO1xyXG5cdCAgICAgICAgICAgICAgICBleHByID0gdGhpcy5maW5hbGl6ZShub2RlLCBuZXcgTm9kZS5Db21wdXRlZE1lbWJlckV4cHJlc3Npb24oZXhwciwgcHJvcGVydHkpKTtcclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5tYXRjaCgnLicpKSB7XHJcblx0ICAgICAgICAgICAgICAgIHRoaXMuY29udGV4dC5pc0JpbmRpbmdFbGVtZW50ID0gZmFsc2U7XHJcblx0ICAgICAgICAgICAgICAgIHRoaXMuY29udGV4dC5pc0Fzc2lnbm1lbnRUYXJnZXQgPSB0cnVlO1xyXG5cdCAgICAgICAgICAgICAgICB0aGlzLmV4cGVjdCgnLicpO1xyXG5cdCAgICAgICAgICAgICAgICB2YXIgcHJvcGVydHkgPSB0aGlzLnBhcnNlSWRlbnRpZmllck5hbWUoKTtcclxuXHQgICAgICAgICAgICAgICAgZXhwciA9IHRoaXMuZmluYWxpemUobm9kZSwgbmV3IE5vZGUuU3RhdGljTWVtYmVyRXhwcmVzc2lvbihleHByLCBwcm9wZXJ0eSkpO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICBlbHNlIGlmICh0aGlzLmxvb2thaGVhZC50eXBlID09PSAxMCAvKiBUZW1wbGF0ZSAqLyAmJiB0aGlzLmxvb2thaGVhZC5oZWFkKSB7XHJcblx0ICAgICAgICAgICAgICAgIHZhciBxdWFzaSA9IHRoaXMucGFyc2VUZW1wbGF0ZUxpdGVyYWwoKTtcclxuXHQgICAgICAgICAgICAgICAgZXhwciA9IHRoaXMuZmluYWxpemUobm9kZSwgbmV3IE5vZGUuVGFnZ2VkVGVtcGxhdGVFeHByZXNzaW9uKGV4cHIsIHF1YXNpKSk7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgIGVsc2Uge1xyXG5cdCAgICAgICAgICAgICAgICBicmVhaztcclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICByZXR1cm4gZXhwcjtcclxuXHQgICAgfTtcclxuXHQgICAgLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtdXBkYXRlLWV4cHJlc3Npb25zXHJcblx0ICAgIFBhcnNlci5wcm90b3R5cGUucGFyc2VVcGRhdGVFeHByZXNzaW9uID0gZnVuY3Rpb24gKCkge1xyXG5cdCAgICAgICAgdmFyIGV4cHI7XHJcblx0ICAgICAgICB2YXIgc3RhcnRUb2tlbiA9IHRoaXMubG9va2FoZWFkO1xyXG5cdCAgICAgICAgaWYgKHRoaXMubWF0Y2goJysrJykgfHwgdGhpcy5tYXRjaCgnLS0nKSkge1xyXG5cdCAgICAgICAgICAgIHZhciBub2RlID0gdGhpcy5zdGFydE5vZGUoc3RhcnRUb2tlbik7XHJcblx0ICAgICAgICAgICAgdmFyIHRva2VuID0gdGhpcy5uZXh0VG9rZW4oKTtcclxuXHQgICAgICAgICAgICBleHByID0gdGhpcy5pbmhlcml0Q292ZXJHcmFtbWFyKHRoaXMucGFyc2VVbmFyeUV4cHJlc3Npb24pO1xyXG5cdCAgICAgICAgICAgIGlmICh0aGlzLmNvbnRleHQuc3RyaWN0ICYmIGV4cHIudHlwZSA9PT0gc3ludGF4XzEuU3ludGF4LklkZW50aWZpZXIgJiYgdGhpcy5zY2FubmVyLmlzUmVzdHJpY3RlZFdvcmQoZXhwci5uYW1lKSkge1xyXG5cdCAgICAgICAgICAgICAgICB0aGlzLnRvbGVyYXRlRXJyb3IobWVzc2FnZXNfMS5NZXNzYWdlcy5TdHJpY3RMSFNQcmVmaXgpO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICBpZiAoIXRoaXMuY29udGV4dC5pc0Fzc2lnbm1lbnRUYXJnZXQpIHtcclxuXHQgICAgICAgICAgICAgICAgdGhpcy50b2xlcmF0ZUVycm9yKG1lc3NhZ2VzXzEuTWVzc2FnZXMuSW52YWxpZExIU0luQXNzaWdubWVudCk7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgIHZhciBwcmVmaXggPSB0cnVlO1xyXG5cdCAgICAgICAgICAgIGV4cHIgPSB0aGlzLmZpbmFsaXplKG5vZGUsIG5ldyBOb2RlLlVwZGF0ZUV4cHJlc3Npb24odG9rZW4udmFsdWUsIGV4cHIsIHByZWZpeCkpO1xyXG5cdCAgICAgICAgICAgIHRoaXMuY29udGV4dC5pc0Fzc2lnbm1lbnRUYXJnZXQgPSBmYWxzZTtcclxuXHQgICAgICAgICAgICB0aGlzLmNvbnRleHQuaXNCaW5kaW5nRWxlbWVudCA9IGZhbHNlO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgZWxzZSB7XHJcblx0ICAgICAgICAgICAgZXhwciA9IHRoaXMuaW5oZXJpdENvdmVyR3JhbW1hcih0aGlzLnBhcnNlTGVmdEhhbmRTaWRlRXhwcmVzc2lvbkFsbG93Q2FsbCk7XHJcblx0ICAgICAgICAgICAgaWYgKCF0aGlzLmhhc0xpbmVUZXJtaW5hdG9yICYmIHRoaXMubG9va2FoZWFkLnR5cGUgPT09IDcgLyogUHVuY3R1YXRvciAqLykge1xyXG5cdCAgICAgICAgICAgICAgICBpZiAodGhpcy5tYXRjaCgnKysnKSB8fCB0aGlzLm1hdGNoKCctLScpKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5jb250ZXh0LnN0cmljdCAmJiBleHByLnR5cGUgPT09IHN5bnRheF8xLlN5bnRheC5JZGVudGlmaWVyICYmIHRoaXMuc2Nhbm5lci5pc1Jlc3RyaWN0ZWRXb3JkKGV4cHIubmFtZSkpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnRvbGVyYXRlRXJyb3IobWVzc2FnZXNfMS5NZXNzYWdlcy5TdHJpY3RMSFNQb3N0Zml4KTtcclxuXHQgICAgICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgICAgIGlmICghdGhpcy5jb250ZXh0LmlzQXNzaWdubWVudFRhcmdldCkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMudG9sZXJhdGVFcnJvcihtZXNzYWdlc18xLk1lc3NhZ2VzLkludmFsaWRMSFNJbkFzc2lnbm1lbnQpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICAgICAgdGhpcy5jb250ZXh0LmlzQXNzaWdubWVudFRhcmdldCA9IGZhbHNlO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgdGhpcy5jb250ZXh0LmlzQmluZGluZ0VsZW1lbnQgPSBmYWxzZTtcclxuXHQgICAgICAgICAgICAgICAgICAgIHZhciBvcGVyYXRvciA9IHRoaXMubmV4dFRva2VuKCkudmFsdWU7XHJcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgcHJlZml4ID0gZmFsc2U7XHJcblx0ICAgICAgICAgICAgICAgICAgICBleHByID0gdGhpcy5maW5hbGl6ZSh0aGlzLnN0YXJ0Tm9kZShzdGFydFRva2VuKSwgbmV3IE5vZGUuVXBkYXRlRXhwcmVzc2lvbihvcGVyYXRvciwgZXhwciwgcHJlZml4KSk7XHJcblx0ICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICByZXR1cm4gZXhwcjtcclxuXHQgICAgfTtcclxuXHQgICAgLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtdW5hcnktb3BlcmF0b3JzXHJcblx0ICAgIFBhcnNlci5wcm90b3R5cGUucGFyc2VBd2FpdEV4cHJlc3Npb24gPSBmdW5jdGlvbiAoKSB7XHJcblx0ICAgICAgICB2YXIgbm9kZSA9IHRoaXMuY3JlYXRlTm9kZSgpO1xyXG5cdCAgICAgICAgdGhpcy5uZXh0VG9rZW4oKTtcclxuXHQgICAgICAgIHZhciBhcmd1bWVudCA9IHRoaXMucGFyc2VVbmFyeUV4cHJlc3Npb24oKTtcclxuXHQgICAgICAgIHJldHVybiB0aGlzLmZpbmFsaXplKG5vZGUsIG5ldyBOb2RlLkF3YWl0RXhwcmVzc2lvbihhcmd1bWVudCkpO1xyXG5cdCAgICB9O1xyXG5cdCAgICBQYXJzZXIucHJvdG90eXBlLnBhcnNlVW5hcnlFeHByZXNzaW9uID0gZnVuY3Rpb24gKCkge1xyXG5cdCAgICAgICAgdmFyIGV4cHI7XHJcblx0ICAgICAgICBpZiAodGhpcy5tYXRjaCgnKycpIHx8IHRoaXMubWF0Y2goJy0nKSB8fCB0aGlzLm1hdGNoKCd+JykgfHwgdGhpcy5tYXRjaCgnIScpIHx8XHJcblx0ICAgICAgICAgICAgdGhpcy5tYXRjaEtleXdvcmQoJ2RlbGV0ZScpIHx8IHRoaXMubWF0Y2hLZXl3b3JkKCd2b2lkJykgfHwgdGhpcy5tYXRjaEtleXdvcmQoJ3R5cGVvZicpKSB7XHJcblx0ICAgICAgICAgICAgdmFyIG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZSh0aGlzLmxvb2thaGVhZCk7XHJcblx0ICAgICAgICAgICAgdmFyIHRva2VuID0gdGhpcy5uZXh0VG9rZW4oKTtcclxuXHQgICAgICAgICAgICBleHByID0gdGhpcy5pbmhlcml0Q292ZXJHcmFtbWFyKHRoaXMucGFyc2VVbmFyeUV4cHJlc3Npb24pO1xyXG5cdCAgICAgICAgICAgIGV4cHIgPSB0aGlzLmZpbmFsaXplKG5vZGUsIG5ldyBOb2RlLlVuYXJ5RXhwcmVzc2lvbih0b2tlbi52YWx1ZSwgZXhwcikpO1xyXG5cdCAgICAgICAgICAgIGlmICh0aGlzLmNvbnRleHQuc3RyaWN0ICYmIGV4cHIub3BlcmF0b3IgPT09ICdkZWxldGUnICYmIGV4cHIuYXJndW1lbnQudHlwZSA9PT0gc3ludGF4XzEuU3ludGF4LklkZW50aWZpZXIpIHtcclxuXHQgICAgICAgICAgICAgICAgdGhpcy50b2xlcmF0ZUVycm9yKG1lc3NhZ2VzXzEuTWVzc2FnZXMuU3RyaWN0RGVsZXRlKTtcclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgdGhpcy5jb250ZXh0LmlzQXNzaWdubWVudFRhcmdldCA9IGZhbHNlO1xyXG5cdCAgICAgICAgICAgIHRoaXMuY29udGV4dC5pc0JpbmRpbmdFbGVtZW50ID0gZmFsc2U7XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICBlbHNlIGlmICh0aGlzLmNvbnRleHQuYXdhaXQgJiYgdGhpcy5tYXRjaENvbnRleHR1YWxLZXl3b3JkKCdhd2FpdCcpKSB7XHJcblx0ICAgICAgICAgICAgZXhwciA9IHRoaXMucGFyc2VBd2FpdEV4cHJlc3Npb24oKTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIGVsc2Uge1xyXG5cdCAgICAgICAgICAgIGV4cHIgPSB0aGlzLnBhcnNlVXBkYXRlRXhwcmVzc2lvbigpO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgcmV0dXJuIGV4cHI7XHJcblx0ICAgIH07XHJcblx0ICAgIFBhcnNlci5wcm90b3R5cGUucGFyc2VFeHBvbmVudGlhdGlvbkV4cHJlc3Npb24gPSBmdW5jdGlvbiAoKSB7XHJcblx0ICAgICAgICB2YXIgc3RhcnRUb2tlbiA9IHRoaXMubG9va2FoZWFkO1xyXG5cdCAgICAgICAgdmFyIGV4cHIgPSB0aGlzLmluaGVyaXRDb3ZlckdyYW1tYXIodGhpcy5wYXJzZVVuYXJ5RXhwcmVzc2lvbik7XHJcblx0ICAgICAgICBpZiAoZXhwci50eXBlICE9PSBzeW50YXhfMS5TeW50YXguVW5hcnlFeHByZXNzaW9uICYmIHRoaXMubWF0Y2goJyoqJykpIHtcclxuXHQgICAgICAgICAgICB0aGlzLm5leHRUb2tlbigpO1xyXG5cdCAgICAgICAgICAgIHRoaXMuY29udGV4dC5pc0Fzc2lnbm1lbnRUYXJnZXQgPSBmYWxzZTtcclxuXHQgICAgICAgICAgICB0aGlzLmNvbnRleHQuaXNCaW5kaW5nRWxlbWVudCA9IGZhbHNlO1xyXG5cdCAgICAgICAgICAgIHZhciBsZWZ0ID0gZXhwcjtcclxuXHQgICAgICAgICAgICB2YXIgcmlnaHQgPSB0aGlzLmlzb2xhdGVDb3ZlckdyYW1tYXIodGhpcy5wYXJzZUV4cG9uZW50aWF0aW9uRXhwcmVzc2lvbik7XHJcblx0ICAgICAgICAgICAgZXhwciA9IHRoaXMuZmluYWxpemUodGhpcy5zdGFydE5vZGUoc3RhcnRUb2tlbiksIG5ldyBOb2RlLkJpbmFyeUV4cHJlc3Npb24oJyoqJywgbGVmdCwgcmlnaHQpKTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIHJldHVybiBleHByO1xyXG5cdCAgICB9O1xyXG5cdCAgICAvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1leHAtb3BlcmF0b3JcclxuXHQgICAgLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtbXVsdGlwbGljYXRpdmUtb3BlcmF0b3JzXHJcblx0ICAgIC8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLWFkZGl0aXZlLW9wZXJhdG9yc1xyXG5cdCAgICAvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1iaXR3aXNlLXNoaWZ0LW9wZXJhdG9yc1xyXG5cdCAgICAvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1yZWxhdGlvbmFsLW9wZXJhdG9yc1xyXG5cdCAgICAvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1lcXVhbGl0eS1vcGVyYXRvcnNcclxuXHQgICAgLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtYmluYXJ5LWJpdHdpc2Utb3BlcmF0b3JzXHJcblx0ICAgIC8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLWJpbmFyeS1sb2dpY2FsLW9wZXJhdG9yc1xyXG5cdCAgICBQYXJzZXIucHJvdG90eXBlLmJpbmFyeVByZWNlZGVuY2UgPSBmdW5jdGlvbiAodG9rZW4pIHtcclxuXHQgICAgICAgIHZhciBvcCA9IHRva2VuLnZhbHVlO1xyXG5cdCAgICAgICAgdmFyIHByZWNlZGVuY2U7XHJcblx0ICAgICAgICBpZiAodG9rZW4udHlwZSA9PT0gNyAvKiBQdW5jdHVhdG9yICovKSB7XHJcblx0ICAgICAgICAgICAgcHJlY2VkZW5jZSA9IHRoaXMub3BlcmF0b3JQcmVjZWRlbmNlW29wXSB8fCAwO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgZWxzZSBpZiAodG9rZW4udHlwZSA9PT0gNCAvKiBLZXl3b3JkICovKSB7XHJcblx0ICAgICAgICAgICAgcHJlY2VkZW5jZSA9IChvcCA9PT0gJ2luc3RhbmNlb2YnIHx8ICh0aGlzLmNvbnRleHQuYWxsb3dJbiAmJiBvcCA9PT0gJ2luJykpID8gNyA6IDA7XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICBlbHNlIHtcclxuXHQgICAgICAgICAgICBwcmVjZWRlbmNlID0gMDtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIHJldHVybiBwcmVjZWRlbmNlO1xyXG5cdCAgICB9O1xyXG5cdCAgICBQYXJzZXIucHJvdG90eXBlLnBhcnNlQmluYXJ5RXhwcmVzc2lvbiA9IGZ1bmN0aW9uICgpIHtcclxuXHQgICAgICAgIHZhciBzdGFydFRva2VuID0gdGhpcy5sb29rYWhlYWQ7XHJcblx0ICAgICAgICB2YXIgZXhwciA9IHRoaXMuaW5oZXJpdENvdmVyR3JhbW1hcih0aGlzLnBhcnNlRXhwb25lbnRpYXRpb25FeHByZXNzaW9uKTtcclxuXHQgICAgICAgIHZhciB0b2tlbiA9IHRoaXMubG9va2FoZWFkO1xyXG5cdCAgICAgICAgdmFyIHByZWMgPSB0aGlzLmJpbmFyeVByZWNlZGVuY2UodG9rZW4pO1xyXG5cdCAgICAgICAgaWYgKHByZWMgPiAwKSB7XHJcblx0ICAgICAgICAgICAgdGhpcy5uZXh0VG9rZW4oKTtcclxuXHQgICAgICAgICAgICB0aGlzLmNvbnRleHQuaXNBc3NpZ25tZW50VGFyZ2V0ID0gZmFsc2U7XHJcblx0ICAgICAgICAgICAgdGhpcy5jb250ZXh0LmlzQmluZGluZ0VsZW1lbnQgPSBmYWxzZTtcclxuXHQgICAgICAgICAgICB2YXIgbWFya2VycyA9IFtzdGFydFRva2VuLCB0aGlzLmxvb2thaGVhZF07XHJcblx0ICAgICAgICAgICAgdmFyIGxlZnQgPSBleHByO1xyXG5cdCAgICAgICAgICAgIHZhciByaWdodCA9IHRoaXMuaXNvbGF0ZUNvdmVyR3JhbW1hcih0aGlzLnBhcnNlRXhwb25lbnRpYXRpb25FeHByZXNzaW9uKTtcclxuXHQgICAgICAgICAgICB2YXIgc3RhY2sgPSBbbGVmdCwgdG9rZW4udmFsdWUsIHJpZ2h0XTtcclxuXHQgICAgICAgICAgICB2YXIgcHJlY2VkZW5jZXMgPSBbcHJlY107XHJcblx0ICAgICAgICAgICAgd2hpbGUgKHRydWUpIHtcclxuXHQgICAgICAgICAgICAgICAgcHJlYyA9IHRoaXMuYmluYXJ5UHJlY2VkZW5jZSh0aGlzLmxvb2thaGVhZCk7XHJcblx0ICAgICAgICAgICAgICAgIGlmIChwcmVjIDw9IDApIHtcclxuXHQgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cdCAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgIC8vIFJlZHVjZTogbWFrZSBhIGJpbmFyeSBleHByZXNzaW9uIGZyb20gdGhlIHRocmVlIHRvcG1vc3QgZW50cmllcy5cclxuXHQgICAgICAgICAgICAgICAgd2hpbGUgKChzdGFjay5sZW5ndGggPiAyKSAmJiAocHJlYyA8PSBwcmVjZWRlbmNlc1twcmVjZWRlbmNlcy5sZW5ndGggLSAxXSkpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgIHJpZ2h0ID0gc3RhY2sucG9wKCk7XHJcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgb3BlcmF0b3IgPSBzdGFjay5wb3AoKTtcclxuXHQgICAgICAgICAgICAgICAgICAgIHByZWNlZGVuY2VzLnBvcCgpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgbGVmdCA9IHN0YWNrLnBvcCgpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgbWFya2Vycy5wb3AoKTtcclxuXHQgICAgICAgICAgICAgICAgICAgIHZhciBub2RlID0gdGhpcy5zdGFydE5vZGUobWFya2Vyc1ttYXJrZXJzLmxlbmd0aCAtIDFdKTtcclxuXHQgICAgICAgICAgICAgICAgICAgIHN0YWNrLnB1c2godGhpcy5maW5hbGl6ZShub2RlLCBuZXcgTm9kZS5CaW5hcnlFeHByZXNzaW9uKG9wZXJhdG9yLCBsZWZ0LCByaWdodCkpKTtcclxuXHQgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICAvLyBTaGlmdC5cclxuXHQgICAgICAgICAgICAgICAgc3RhY2sucHVzaCh0aGlzLm5leHRUb2tlbigpLnZhbHVlKTtcclxuXHQgICAgICAgICAgICAgICAgcHJlY2VkZW5jZXMucHVzaChwcmVjKTtcclxuXHQgICAgICAgICAgICAgICAgbWFya2Vycy5wdXNoKHRoaXMubG9va2FoZWFkKTtcclxuXHQgICAgICAgICAgICAgICAgc3RhY2sucHVzaCh0aGlzLmlzb2xhdGVDb3ZlckdyYW1tYXIodGhpcy5wYXJzZUV4cG9uZW50aWF0aW9uRXhwcmVzc2lvbikpO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAvLyBGaW5hbCByZWR1Y2UgdG8gY2xlYW4tdXAgdGhlIHN0YWNrLlxyXG5cdCAgICAgICAgICAgIHZhciBpID0gc3RhY2subGVuZ3RoIC0gMTtcclxuXHQgICAgICAgICAgICBleHByID0gc3RhY2tbaV07XHJcblx0ICAgICAgICAgICAgbWFya2Vycy5wb3AoKTtcclxuXHQgICAgICAgICAgICB3aGlsZSAoaSA+IDEpIHtcclxuXHQgICAgICAgICAgICAgICAgdmFyIG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZShtYXJrZXJzLnBvcCgpKTtcclxuXHQgICAgICAgICAgICAgICAgdmFyIG9wZXJhdG9yID0gc3RhY2tbaSAtIDFdO1xyXG5cdCAgICAgICAgICAgICAgICBleHByID0gdGhpcy5maW5hbGl6ZShub2RlLCBuZXcgTm9kZS5CaW5hcnlFeHByZXNzaW9uKG9wZXJhdG9yLCBzdGFja1tpIC0gMl0sIGV4cHIpKTtcclxuXHQgICAgICAgICAgICAgICAgaSAtPSAyO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIHJldHVybiBleHByO1xyXG5cdCAgICB9O1xyXG5cdCAgICAvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1jb25kaXRpb25hbC1vcGVyYXRvclxyXG5cdCAgICBQYXJzZXIucHJvdG90eXBlLnBhcnNlQ29uZGl0aW9uYWxFeHByZXNzaW9uID0gZnVuY3Rpb24gKCkge1xyXG5cdCAgICAgICAgdmFyIHN0YXJ0VG9rZW4gPSB0aGlzLmxvb2thaGVhZDtcclxuXHQgICAgICAgIHZhciBleHByID0gdGhpcy5pbmhlcml0Q292ZXJHcmFtbWFyKHRoaXMucGFyc2VCaW5hcnlFeHByZXNzaW9uKTtcclxuXHQgICAgICAgIGlmICh0aGlzLm1hdGNoKCc/JykpIHtcclxuXHQgICAgICAgICAgICB0aGlzLm5leHRUb2tlbigpO1xyXG5cdCAgICAgICAgICAgIHZhciBwcmV2aW91c0FsbG93SW4gPSB0aGlzLmNvbnRleHQuYWxsb3dJbjtcclxuXHQgICAgICAgICAgICB0aGlzLmNvbnRleHQuYWxsb3dJbiA9IHRydWU7XHJcblx0ICAgICAgICAgICAgdmFyIGNvbnNlcXVlbnQgPSB0aGlzLmlzb2xhdGVDb3ZlckdyYW1tYXIodGhpcy5wYXJzZUFzc2lnbm1lbnRFeHByZXNzaW9uKTtcclxuXHQgICAgICAgICAgICB0aGlzLmNvbnRleHQuYWxsb3dJbiA9IHByZXZpb3VzQWxsb3dJbjtcclxuXHQgICAgICAgICAgICB0aGlzLmV4cGVjdCgnOicpO1xyXG5cdCAgICAgICAgICAgIHZhciBhbHRlcm5hdGUgPSB0aGlzLmlzb2xhdGVDb3ZlckdyYW1tYXIodGhpcy5wYXJzZUFzc2lnbm1lbnRFeHByZXNzaW9uKTtcclxuXHQgICAgICAgICAgICBleHByID0gdGhpcy5maW5hbGl6ZSh0aGlzLnN0YXJ0Tm9kZShzdGFydFRva2VuKSwgbmV3IE5vZGUuQ29uZGl0aW9uYWxFeHByZXNzaW9uKGV4cHIsIGNvbnNlcXVlbnQsIGFsdGVybmF0ZSkpO1xyXG5cdCAgICAgICAgICAgIHRoaXMuY29udGV4dC5pc0Fzc2lnbm1lbnRUYXJnZXQgPSBmYWxzZTtcclxuXHQgICAgICAgICAgICB0aGlzLmNvbnRleHQuaXNCaW5kaW5nRWxlbWVudCA9IGZhbHNlO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgcmV0dXJuIGV4cHI7XHJcblx0ICAgIH07XHJcblx0ICAgIC8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLWFzc2lnbm1lbnQtb3BlcmF0b3JzXHJcblx0ICAgIFBhcnNlci5wcm90b3R5cGUuY2hlY2tQYXR0ZXJuUGFyYW0gPSBmdW5jdGlvbiAob3B0aW9ucywgcGFyYW0pIHtcclxuXHQgICAgICAgIHN3aXRjaCAocGFyYW0udHlwZSkge1xyXG5cdCAgICAgICAgICAgIGNhc2Ugc3ludGF4XzEuU3ludGF4LklkZW50aWZpZXI6XHJcblx0ICAgICAgICAgICAgICAgIHRoaXMudmFsaWRhdGVQYXJhbShvcHRpb25zLCBwYXJhbSwgcGFyYW0ubmFtZSk7XHJcblx0ICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cdCAgICAgICAgICAgIGNhc2Ugc3ludGF4XzEuU3ludGF4LlJlc3RFbGVtZW50OlxyXG5cdCAgICAgICAgICAgICAgICB0aGlzLmNoZWNrUGF0dGVyblBhcmFtKG9wdGlvbnMsIHBhcmFtLmFyZ3VtZW50KTtcclxuXHQgICAgICAgICAgICAgICAgYnJlYWs7XHJcblx0ICAgICAgICAgICAgY2FzZSBzeW50YXhfMS5TeW50YXguQXNzaWdubWVudFBhdHRlcm46XHJcblx0ICAgICAgICAgICAgICAgIHRoaXMuY2hlY2tQYXR0ZXJuUGFyYW0ob3B0aW9ucywgcGFyYW0ubGVmdCk7XHJcblx0ICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cdCAgICAgICAgICAgIGNhc2Ugc3ludGF4XzEuU3ludGF4LkFycmF5UGF0dGVybjpcclxuXHQgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwYXJhbS5lbGVtZW50cy5sZW5ndGg7IGkrKykge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKHBhcmFtLmVsZW1lbnRzW2ldICE9PSBudWxsKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jaGVja1BhdHRlcm5QYXJhbShvcHRpb25zLCBwYXJhbS5lbGVtZW50c1tpXSk7XHJcblx0ICAgICAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgYnJlYWs7XHJcblx0ICAgICAgICAgICAgY2FzZSBzeW50YXhfMS5TeW50YXguT2JqZWN0UGF0dGVybjpcclxuXHQgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwYXJhbS5wcm9wZXJ0aWVzLmxlbmd0aDsgaSsrKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICB0aGlzLmNoZWNrUGF0dGVyblBhcmFtKG9wdGlvbnMsIHBhcmFtLnByb3BlcnRpZXNbaV0udmFsdWUpO1xyXG5cdCAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cdCAgICAgICAgICAgIGRlZmF1bHQ6XHJcblx0ICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgb3B0aW9ucy5zaW1wbGUgPSBvcHRpb25zLnNpbXBsZSAmJiAocGFyYW0gaW5zdGFuY2VvZiBOb2RlLklkZW50aWZpZXIpO1xyXG5cdCAgICB9O1xyXG5cdCAgICBQYXJzZXIucHJvdG90eXBlLnJlaW50ZXJwcmV0QXNDb3ZlckZvcm1hbHNMaXN0ID0gZnVuY3Rpb24gKGV4cHIpIHtcclxuXHQgICAgICAgIHZhciBwYXJhbXMgPSBbZXhwcl07XHJcblx0ICAgICAgICB2YXIgb3B0aW9ucztcclxuXHQgICAgICAgIHZhciBhc3luY0Fycm93ID0gZmFsc2U7XHJcblx0ICAgICAgICBzd2l0Y2ggKGV4cHIudHlwZSkge1xyXG5cdCAgICAgICAgICAgIGNhc2Ugc3ludGF4XzEuU3ludGF4LklkZW50aWZpZXI6XHJcblx0ICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cdCAgICAgICAgICAgIGNhc2UgQXJyb3dQYXJhbWV0ZXJQbGFjZUhvbGRlcjpcclxuXHQgICAgICAgICAgICAgICAgcGFyYW1zID0gZXhwci5wYXJhbXM7XHJcblx0ICAgICAgICAgICAgICAgIGFzeW5jQXJyb3cgPSBleHByLmFzeW5jO1xyXG5cdCAgICAgICAgICAgICAgICBicmVhaztcclxuXHQgICAgICAgICAgICBkZWZhdWx0OlxyXG5cdCAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIG9wdGlvbnMgPSB7XHJcblx0ICAgICAgICAgICAgc2ltcGxlOiB0cnVlLFxyXG5cdCAgICAgICAgICAgIHBhcmFtU2V0OiB7fVxyXG5cdCAgICAgICAgfTtcclxuXHQgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcGFyYW1zLmxlbmd0aDsgKytpKSB7XHJcblx0ICAgICAgICAgICAgdmFyIHBhcmFtID0gcGFyYW1zW2ldO1xyXG5cdCAgICAgICAgICAgIGlmIChwYXJhbS50eXBlID09PSBzeW50YXhfMS5TeW50YXguQXNzaWdubWVudFBhdHRlcm4pIHtcclxuXHQgICAgICAgICAgICAgICAgaWYgKHBhcmFtLnJpZ2h0LnR5cGUgPT09IHN5bnRheF8xLlN5bnRheC5ZaWVsZEV4cHJlc3Npb24pIHtcclxuXHQgICAgICAgICAgICAgICAgICAgIGlmIChwYXJhbS5yaWdodC5hcmd1bWVudCkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMudGhyb3dVbmV4cGVjdGVkVG9rZW4odGhpcy5sb29rYWhlYWQpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICAgICAgcGFyYW0ucmlnaHQudHlwZSA9IHN5bnRheF8xLlN5bnRheC5JZGVudGlmaWVyO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgcGFyYW0ucmlnaHQubmFtZSA9ICd5aWVsZCc7XHJcblx0ICAgICAgICAgICAgICAgICAgICBkZWxldGUgcGFyYW0ucmlnaHQuYXJndW1lbnQ7XHJcblx0ICAgICAgICAgICAgICAgICAgICBkZWxldGUgcGFyYW0ucmlnaHQuZGVsZWdhdGU7XHJcblx0ICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgZWxzZSBpZiAoYXN5bmNBcnJvdyAmJiBwYXJhbS50eXBlID09PSBzeW50YXhfMS5TeW50YXguSWRlbnRpZmllciAmJiBwYXJhbS5uYW1lID09PSAnYXdhaXQnKSB7XHJcblx0ICAgICAgICAgICAgICAgIHRoaXMudGhyb3dVbmV4cGVjdGVkVG9rZW4odGhpcy5sb29rYWhlYWQpO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICB0aGlzLmNoZWNrUGF0dGVyblBhcmFtKG9wdGlvbnMsIHBhcmFtKTtcclxuXHQgICAgICAgICAgICBwYXJhbXNbaV0gPSBwYXJhbTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIGlmICh0aGlzLmNvbnRleHQuc3RyaWN0IHx8ICF0aGlzLmNvbnRleHQuYWxsb3dZaWVsZCkge1xyXG5cdCAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcGFyYW1zLmxlbmd0aDsgKytpKSB7XHJcblx0ICAgICAgICAgICAgICAgIHZhciBwYXJhbSA9IHBhcmFtc1tpXTtcclxuXHQgICAgICAgICAgICAgICAgaWYgKHBhcmFtLnR5cGUgPT09IHN5bnRheF8xLlN5bnRheC5ZaWVsZEV4cHJlc3Npb24pIHtcclxuXHQgICAgICAgICAgICAgICAgICAgIHRoaXMudGhyb3dVbmV4cGVjdGVkVG9rZW4odGhpcy5sb29rYWhlYWQpO1xyXG5cdCAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgaWYgKG9wdGlvbnMubWVzc2FnZSA9PT0gbWVzc2FnZXNfMS5NZXNzYWdlcy5TdHJpY3RQYXJhbUR1cGUpIHtcclxuXHQgICAgICAgICAgICB2YXIgdG9rZW4gPSB0aGlzLmNvbnRleHQuc3RyaWN0ID8gb3B0aW9ucy5zdHJpY3RlZCA6IG9wdGlvbnMuZmlyc3RSZXN0cmljdGVkO1xyXG5cdCAgICAgICAgICAgIHRoaXMudGhyb3dVbmV4cGVjdGVkVG9rZW4odG9rZW4sIG9wdGlvbnMubWVzc2FnZSk7XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICByZXR1cm4ge1xyXG5cdCAgICAgICAgICAgIHNpbXBsZTogb3B0aW9ucy5zaW1wbGUsXHJcblx0ICAgICAgICAgICAgcGFyYW1zOiBwYXJhbXMsXHJcblx0ICAgICAgICAgICAgc3RyaWN0ZWQ6IG9wdGlvbnMuc3RyaWN0ZWQsXHJcblx0ICAgICAgICAgICAgZmlyc3RSZXN0cmljdGVkOiBvcHRpb25zLmZpcnN0UmVzdHJpY3RlZCxcclxuXHQgICAgICAgICAgICBtZXNzYWdlOiBvcHRpb25zLm1lc3NhZ2VcclxuXHQgICAgICAgIH07XHJcblx0ICAgIH07XHJcblx0ICAgIFBhcnNlci5wcm90b3R5cGUucGFyc2VBc3NpZ25tZW50RXhwcmVzc2lvbiA9IGZ1bmN0aW9uICgpIHtcclxuXHQgICAgICAgIHZhciBleHByO1xyXG5cdCAgICAgICAgaWYgKCF0aGlzLmNvbnRleHQuYWxsb3dZaWVsZCAmJiB0aGlzLm1hdGNoS2V5d29yZCgneWllbGQnKSkge1xyXG5cdCAgICAgICAgICAgIGV4cHIgPSB0aGlzLnBhcnNlWWllbGRFeHByZXNzaW9uKCk7XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICBlbHNlIHtcclxuXHQgICAgICAgICAgICB2YXIgc3RhcnRUb2tlbiA9IHRoaXMubG9va2FoZWFkO1xyXG5cdCAgICAgICAgICAgIHZhciB0b2tlbiA9IHN0YXJ0VG9rZW47XHJcblx0ICAgICAgICAgICAgZXhwciA9IHRoaXMucGFyc2VDb25kaXRpb25hbEV4cHJlc3Npb24oKTtcclxuXHQgICAgICAgICAgICBpZiAodG9rZW4udHlwZSA9PT0gMyAvKiBJZGVudGlmaWVyICovICYmICh0b2tlbi5saW5lTnVtYmVyID09PSB0aGlzLmxvb2thaGVhZC5saW5lTnVtYmVyKSAmJiB0b2tlbi52YWx1ZSA9PT0gJ2FzeW5jJykge1xyXG5cdCAgICAgICAgICAgICAgICBpZiAodGhpcy5sb29rYWhlYWQudHlwZSA9PT0gMyAvKiBJZGVudGlmaWVyICovIHx8IHRoaXMubWF0Y2hLZXl3b3JkKCd5aWVsZCcpKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgYXJnID0gdGhpcy5wYXJzZVByaW1hcnlFeHByZXNzaW9uKCk7XHJcblx0ICAgICAgICAgICAgICAgICAgICB0aGlzLnJlaW50ZXJwcmV0RXhwcmVzc2lvbkFzUGF0dGVybihhcmcpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgZXhwciA9IHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBBcnJvd1BhcmFtZXRlclBsYWNlSG9sZGVyLFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHBhcmFtczogW2FyZ10sXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgYXN5bmM6IHRydWVcclxuXHQgICAgICAgICAgICAgICAgICAgIH07XHJcblx0ICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgaWYgKGV4cHIudHlwZSA9PT0gQXJyb3dQYXJhbWV0ZXJQbGFjZUhvbGRlciB8fCB0aGlzLm1hdGNoKCc9PicpKSB7XHJcblx0ICAgICAgICAgICAgICAgIC8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLWFycm93LWZ1bmN0aW9uLWRlZmluaXRpb25zXHJcblx0ICAgICAgICAgICAgICAgIHRoaXMuY29udGV4dC5pc0Fzc2lnbm1lbnRUYXJnZXQgPSBmYWxzZTtcclxuXHQgICAgICAgICAgICAgICAgdGhpcy5jb250ZXh0LmlzQmluZGluZ0VsZW1lbnQgPSBmYWxzZTtcclxuXHQgICAgICAgICAgICAgICAgdmFyIGlzQXN5bmMgPSBleHByLmFzeW5jO1xyXG5cdCAgICAgICAgICAgICAgICB2YXIgbGlzdCA9IHRoaXMucmVpbnRlcnByZXRBc0NvdmVyRm9ybWFsc0xpc3QoZXhwcik7XHJcblx0ICAgICAgICAgICAgICAgIGlmIChsaXN0KSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5oYXNMaW5lVGVybWluYXRvcikge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMudG9sZXJhdGVVbmV4cGVjdGVkVG9rZW4odGhpcy5sb29rYWhlYWQpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICAgICAgdGhpcy5jb250ZXh0LmZpcnN0Q292ZXJJbml0aWFsaXplZE5hbWVFcnJvciA9IG51bGw7XHJcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgcHJldmlvdXNTdHJpY3QgPSB0aGlzLmNvbnRleHQuc3RyaWN0O1xyXG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIHByZXZpb3VzQWxsb3dTdHJpY3REaXJlY3RpdmUgPSB0aGlzLmNvbnRleHQuYWxsb3dTdHJpY3REaXJlY3RpdmU7XHJcblx0ICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbnRleHQuYWxsb3dTdHJpY3REaXJlY3RpdmUgPSBsaXN0LnNpbXBsZTtcclxuXHQgICAgICAgICAgICAgICAgICAgIHZhciBwcmV2aW91c0FsbG93WWllbGQgPSB0aGlzLmNvbnRleHQuYWxsb3dZaWVsZDtcclxuXHQgICAgICAgICAgICAgICAgICAgIHZhciBwcmV2aW91c0F3YWl0ID0gdGhpcy5jb250ZXh0LmF3YWl0O1xyXG5cdCAgICAgICAgICAgICAgICAgICAgdGhpcy5jb250ZXh0LmFsbG93WWllbGQgPSB0cnVlO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgdGhpcy5jb250ZXh0LmF3YWl0ID0gaXNBc3luYztcclxuXHQgICAgICAgICAgICAgICAgICAgIHZhciBub2RlID0gdGhpcy5zdGFydE5vZGUoc3RhcnRUb2tlbik7XHJcblx0ICAgICAgICAgICAgICAgICAgICB0aGlzLmV4cGVjdCgnPT4nKTtcclxuXHQgICAgICAgICAgICAgICAgICAgIHZhciBib2R5ID0gdm9pZCAwO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMubWF0Y2goJ3snKSkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHZhciBwcmV2aW91c0FsbG93SW4gPSB0aGlzLmNvbnRleHQuYWxsb3dJbjtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbnRleHQuYWxsb3dJbiA9IHRydWU7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgYm9keSA9IHRoaXMucGFyc2VGdW5jdGlvblNvdXJjZUVsZW1lbnRzKCk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jb250ZXh0LmFsbG93SW4gPSBwcmV2aW91c0FsbG93SW47XHJcblx0ICAgICAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBib2R5ID0gdGhpcy5pc29sYXRlQ292ZXJHcmFtbWFyKHRoaXMucGFyc2VBc3NpZ25tZW50RXhwcmVzc2lvbik7XHJcblx0ICAgICAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgZXhwcmVzc2lvbiA9IGJvZHkudHlwZSAhPT0gc3ludGF4XzEuU3ludGF4LkJsb2NrU3RhdGVtZW50O1xyXG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuY29udGV4dC5zdHJpY3QgJiYgbGlzdC5maXJzdFJlc3RyaWN0ZWQpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnRocm93VW5leHBlY3RlZFRva2VuKGxpc3QuZmlyc3RSZXN0cmljdGVkLCBsaXN0Lm1lc3NhZ2UpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuY29udGV4dC5zdHJpY3QgJiYgbGlzdC5zdHJpY3RlZCkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMudG9sZXJhdGVVbmV4cGVjdGVkVG9rZW4obGlzdC5zdHJpY3RlZCwgbGlzdC5tZXNzYWdlKTtcclxuXHQgICAgICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgICAgIGV4cHIgPSBpc0FzeW5jID8gdGhpcy5maW5hbGl6ZShub2RlLCBuZXcgTm9kZS5Bc3luY0Fycm93RnVuY3Rpb25FeHByZXNzaW9uKGxpc3QucGFyYW1zLCBib2R5LCBleHByZXNzaW9uKSkgOlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZmluYWxpemUobm9kZSwgbmV3IE5vZGUuQXJyb3dGdW5jdGlvbkV4cHJlc3Npb24obGlzdC5wYXJhbXMsIGJvZHksIGV4cHJlc3Npb24pKTtcclxuXHQgICAgICAgICAgICAgICAgICAgIHRoaXMuY29udGV4dC5zdHJpY3QgPSBwcmV2aW91c1N0cmljdDtcclxuXHQgICAgICAgICAgICAgICAgICAgIHRoaXMuY29udGV4dC5hbGxvd1N0cmljdERpcmVjdGl2ZSA9IHByZXZpb3VzQWxsb3dTdHJpY3REaXJlY3RpdmU7XHJcblx0ICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbnRleHQuYWxsb3dZaWVsZCA9IHByZXZpb3VzQWxsb3dZaWVsZDtcclxuXHQgICAgICAgICAgICAgICAgICAgIHRoaXMuY29udGV4dC5hd2FpdCA9IHByZXZpb3VzQXdhaXQ7XHJcblx0ICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgZWxzZSB7XHJcblx0ICAgICAgICAgICAgICAgIGlmICh0aGlzLm1hdGNoQXNzaWduKCkpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgIGlmICghdGhpcy5jb250ZXh0LmlzQXNzaWdubWVudFRhcmdldCkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMudG9sZXJhdGVFcnJvcihtZXNzYWdlc18xLk1lc3NhZ2VzLkludmFsaWRMSFNJbkFzc2lnbm1lbnQpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuY29udGV4dC5zdHJpY3QgJiYgZXhwci50eXBlID09PSBzeW50YXhfMS5TeW50YXguSWRlbnRpZmllcikge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHZhciBpZCA9IGV4cHI7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuc2Nhbm5lci5pc1Jlc3RyaWN0ZWRXb3JkKGlkLm5hbWUpKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMudG9sZXJhdGVVbmV4cGVjdGVkVG9rZW4odG9rZW4sIG1lc3NhZ2VzXzEuTWVzc2FnZXMuU3RyaWN0TEhTQXNzaWdubWVudCk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLnNjYW5uZXIuaXNTdHJpY3RNb2RlUmVzZXJ2ZWRXb3JkKGlkLm5hbWUpKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMudG9sZXJhdGVVbmV4cGVjdGVkVG9rZW4odG9rZW4sIG1lc3NhZ2VzXzEuTWVzc2FnZXMuU3RyaWN0UmVzZXJ2ZWRXb3JkKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgICAgICBpZiAoIXRoaXMubWF0Y2goJz0nKSkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY29udGV4dC5pc0Fzc2lnbm1lbnRUYXJnZXQgPSBmYWxzZTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbnRleHQuaXNCaW5kaW5nRWxlbWVudCA9IGZhbHNlO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5yZWludGVycHJldEV4cHJlc3Npb25Bc1BhdHRlcm4oZXhwcik7XHJcblx0ICAgICAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgICAgICB0b2tlbiA9IHRoaXMubmV4dFRva2VuKCk7XHJcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgb3BlcmF0b3IgPSB0b2tlbi52YWx1ZTtcclxuXHQgICAgICAgICAgICAgICAgICAgIHZhciByaWdodCA9IHRoaXMuaXNvbGF0ZUNvdmVyR3JhbW1hcih0aGlzLnBhcnNlQXNzaWdubWVudEV4cHJlc3Npb24pO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgZXhwciA9IHRoaXMuZmluYWxpemUodGhpcy5zdGFydE5vZGUoc3RhcnRUb2tlbiksIG5ldyBOb2RlLkFzc2lnbm1lbnRFeHByZXNzaW9uKG9wZXJhdG9yLCBleHByLCByaWdodCkpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgdGhpcy5jb250ZXh0LmZpcnN0Q292ZXJJbml0aWFsaXplZE5hbWVFcnJvciA9IG51bGw7XHJcblx0ICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICByZXR1cm4gZXhwcjtcclxuXHQgICAgfTtcclxuXHQgICAgLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtY29tbWEtb3BlcmF0b3JcclxuXHQgICAgUGFyc2VyLnByb3RvdHlwZS5wYXJzZUV4cHJlc3Npb24gPSBmdW5jdGlvbiAoKSB7XHJcblx0ICAgICAgICB2YXIgc3RhcnRUb2tlbiA9IHRoaXMubG9va2FoZWFkO1xyXG5cdCAgICAgICAgdmFyIGV4cHIgPSB0aGlzLmlzb2xhdGVDb3ZlckdyYW1tYXIodGhpcy5wYXJzZUFzc2lnbm1lbnRFeHByZXNzaW9uKTtcclxuXHQgICAgICAgIGlmICh0aGlzLm1hdGNoKCcsJykpIHtcclxuXHQgICAgICAgICAgICB2YXIgZXhwcmVzc2lvbnMgPSBbXTtcclxuXHQgICAgICAgICAgICBleHByZXNzaW9ucy5wdXNoKGV4cHIpO1xyXG5cdCAgICAgICAgICAgIHdoaWxlICh0aGlzLmxvb2thaGVhZC50eXBlICE9PSAyIC8qIEVPRiAqLykge1xyXG5cdCAgICAgICAgICAgICAgICBpZiAoIXRoaXMubWF0Y2goJywnKSkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcblx0ICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgdGhpcy5uZXh0VG9rZW4oKTtcclxuXHQgICAgICAgICAgICAgICAgZXhwcmVzc2lvbnMucHVzaCh0aGlzLmlzb2xhdGVDb3ZlckdyYW1tYXIodGhpcy5wYXJzZUFzc2lnbm1lbnRFeHByZXNzaW9uKSk7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgIGV4cHIgPSB0aGlzLmZpbmFsaXplKHRoaXMuc3RhcnROb2RlKHN0YXJ0VG9rZW4pLCBuZXcgTm9kZS5TZXF1ZW5jZUV4cHJlc3Npb24oZXhwcmVzc2lvbnMpKTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIHJldHVybiBleHByO1xyXG5cdCAgICB9O1xyXG5cdCAgICAvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1ibG9ja1xyXG5cdCAgICBQYXJzZXIucHJvdG90eXBlLnBhcnNlU3RhdGVtZW50TGlzdEl0ZW0gPSBmdW5jdGlvbiAoKSB7XHJcblx0ICAgICAgICB2YXIgc3RhdGVtZW50O1xyXG5cdCAgICAgICAgdGhpcy5jb250ZXh0LmlzQXNzaWdubWVudFRhcmdldCA9IHRydWU7XHJcblx0ICAgICAgICB0aGlzLmNvbnRleHQuaXNCaW5kaW5nRWxlbWVudCA9IHRydWU7XHJcblx0ICAgICAgICBpZiAodGhpcy5sb29rYWhlYWQudHlwZSA9PT0gNCAvKiBLZXl3b3JkICovKSB7XHJcblx0ICAgICAgICAgICAgc3dpdGNoICh0aGlzLmxvb2thaGVhZC52YWx1ZSkge1xyXG5cdCAgICAgICAgICAgICAgICBjYXNlICdleHBvcnQnOlxyXG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKCF0aGlzLmNvbnRleHQuaXNNb2R1bGUpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnRvbGVyYXRlVW5leHBlY3RlZFRva2VuKHRoaXMubG9va2FoZWFkLCBtZXNzYWdlc18xLk1lc3NhZ2VzLklsbGVnYWxFeHBvcnREZWNsYXJhdGlvbik7XHJcblx0ICAgICAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgICAgICBzdGF0ZW1lbnQgPSB0aGlzLnBhcnNlRXhwb3J0RGVjbGFyYXRpb24oKTtcclxuXHQgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cdCAgICAgICAgICAgICAgICBjYXNlICdpbXBvcnQnOlxyXG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKCF0aGlzLmNvbnRleHQuaXNNb2R1bGUpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnRvbGVyYXRlVW5leHBlY3RlZFRva2VuKHRoaXMubG9va2FoZWFkLCBtZXNzYWdlc18xLk1lc3NhZ2VzLklsbGVnYWxJbXBvcnREZWNsYXJhdGlvbik7XHJcblx0ICAgICAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgICAgICBzdGF0ZW1lbnQgPSB0aGlzLnBhcnNlSW1wb3J0RGVjbGFyYXRpb24oKTtcclxuXHQgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cdCAgICAgICAgICAgICAgICBjYXNlICdjb25zdCc6XHJcblx0ICAgICAgICAgICAgICAgICAgICBzdGF0ZW1lbnQgPSB0aGlzLnBhcnNlTGV4aWNhbERlY2xhcmF0aW9uKHsgaW5Gb3I6IGZhbHNlIH0pO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcblx0ICAgICAgICAgICAgICAgIGNhc2UgJ2Z1bmN0aW9uJzpcclxuXHQgICAgICAgICAgICAgICAgICAgIHN0YXRlbWVudCA9IHRoaXMucGFyc2VGdW5jdGlvbkRlY2xhcmF0aW9uKCk7XHJcblx0ICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuXHQgICAgICAgICAgICAgICAgY2FzZSAnY2xhc3MnOlxyXG5cdCAgICAgICAgICAgICAgICAgICAgc3RhdGVtZW50ID0gdGhpcy5wYXJzZUNsYXNzRGVjbGFyYXRpb24oKTtcclxuXHQgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cdCAgICAgICAgICAgICAgICBjYXNlICdsZXQnOlxyXG5cdCAgICAgICAgICAgICAgICAgICAgc3RhdGVtZW50ID0gdGhpcy5pc0xleGljYWxEZWNsYXJhdGlvbigpID8gdGhpcy5wYXJzZUxleGljYWxEZWNsYXJhdGlvbih7IGluRm9yOiBmYWxzZSB9KSA6IHRoaXMucGFyc2VTdGF0ZW1lbnQoKTtcclxuXHQgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cdCAgICAgICAgICAgICAgICBkZWZhdWx0OlxyXG5cdCAgICAgICAgICAgICAgICAgICAgc3RhdGVtZW50ID0gdGhpcy5wYXJzZVN0YXRlbWVudCgpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgZWxzZSB7XHJcblx0ICAgICAgICAgICAgc3RhdGVtZW50ID0gdGhpcy5wYXJzZVN0YXRlbWVudCgpO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgcmV0dXJuIHN0YXRlbWVudDtcclxuXHQgICAgfTtcclxuXHQgICAgUGFyc2VyLnByb3RvdHlwZS5wYXJzZUJsb2NrID0gZnVuY3Rpb24gKCkge1xyXG5cdCAgICAgICAgdmFyIG5vZGUgPSB0aGlzLmNyZWF0ZU5vZGUoKTtcclxuXHQgICAgICAgIHRoaXMuZXhwZWN0KCd7Jyk7XHJcblx0ICAgICAgICB2YXIgYmxvY2sgPSBbXTtcclxuXHQgICAgICAgIHdoaWxlICh0cnVlKSB7XHJcblx0ICAgICAgICAgICAgaWYgKHRoaXMubWF0Y2goJ30nKSkge1xyXG5cdCAgICAgICAgICAgICAgICBicmVhaztcclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgYmxvY2sucHVzaCh0aGlzLnBhcnNlU3RhdGVtZW50TGlzdEl0ZW0oKSk7XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICB0aGlzLmV4cGVjdCgnfScpO1xyXG5cdCAgICAgICAgcmV0dXJuIHRoaXMuZmluYWxpemUobm9kZSwgbmV3IE5vZGUuQmxvY2tTdGF0ZW1lbnQoYmxvY2spKTtcclxuXHQgICAgfTtcclxuXHQgICAgLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtbGV0LWFuZC1jb25zdC1kZWNsYXJhdGlvbnNcclxuXHQgICAgUGFyc2VyLnByb3RvdHlwZS5wYXJzZUxleGljYWxCaW5kaW5nID0gZnVuY3Rpb24gKGtpbmQsIG9wdGlvbnMpIHtcclxuXHQgICAgICAgIHZhciBub2RlID0gdGhpcy5jcmVhdGVOb2RlKCk7XHJcblx0ICAgICAgICB2YXIgcGFyYW1zID0gW107XHJcblx0ICAgICAgICB2YXIgaWQgPSB0aGlzLnBhcnNlUGF0dGVybihwYXJhbXMsIGtpbmQpO1xyXG5cdCAgICAgICAgaWYgKHRoaXMuY29udGV4dC5zdHJpY3QgJiYgaWQudHlwZSA9PT0gc3ludGF4XzEuU3ludGF4LklkZW50aWZpZXIpIHtcclxuXHQgICAgICAgICAgICBpZiAodGhpcy5zY2FubmVyLmlzUmVzdHJpY3RlZFdvcmQoaWQubmFtZSkpIHtcclxuXHQgICAgICAgICAgICAgICAgdGhpcy50b2xlcmF0ZUVycm9yKG1lc3NhZ2VzXzEuTWVzc2FnZXMuU3RyaWN0VmFyTmFtZSk7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgdmFyIGluaXQgPSBudWxsO1xyXG5cdCAgICAgICAgaWYgKGtpbmQgPT09ICdjb25zdCcpIHtcclxuXHQgICAgICAgICAgICBpZiAoIXRoaXMubWF0Y2hLZXl3b3JkKCdpbicpICYmICF0aGlzLm1hdGNoQ29udGV4dHVhbEtleXdvcmQoJ29mJykpIHtcclxuXHQgICAgICAgICAgICAgICAgaWYgKHRoaXMubWF0Y2goJz0nKSkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgdGhpcy5uZXh0VG9rZW4oKTtcclxuXHQgICAgICAgICAgICAgICAgICAgIGluaXQgPSB0aGlzLmlzb2xhdGVDb3ZlckdyYW1tYXIodGhpcy5wYXJzZUFzc2lnbm1lbnRFeHByZXNzaW9uKTtcclxuXHQgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICBlbHNlIHtcclxuXHQgICAgICAgICAgICAgICAgICAgIHRoaXMudGhyb3dFcnJvcihtZXNzYWdlc18xLk1lc3NhZ2VzLkRlY2xhcmF0aW9uTWlzc2luZ0luaXRpYWxpemVyLCAnY29uc3QnKTtcclxuXHQgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIGVsc2UgaWYgKCghb3B0aW9ucy5pbkZvciAmJiBpZC50eXBlICE9PSBzeW50YXhfMS5TeW50YXguSWRlbnRpZmllcikgfHwgdGhpcy5tYXRjaCgnPScpKSB7XHJcblx0ICAgICAgICAgICAgdGhpcy5leHBlY3QoJz0nKTtcclxuXHQgICAgICAgICAgICBpbml0ID0gdGhpcy5pc29sYXRlQ292ZXJHcmFtbWFyKHRoaXMucGFyc2VBc3NpZ25tZW50RXhwcmVzc2lvbik7XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICByZXR1cm4gdGhpcy5maW5hbGl6ZShub2RlLCBuZXcgTm9kZS5WYXJpYWJsZURlY2xhcmF0b3IoaWQsIGluaXQpKTtcclxuXHQgICAgfTtcclxuXHQgICAgUGFyc2VyLnByb3RvdHlwZS5wYXJzZUJpbmRpbmdMaXN0ID0gZnVuY3Rpb24gKGtpbmQsIG9wdGlvbnMpIHtcclxuXHQgICAgICAgIHZhciBsaXN0ID0gW3RoaXMucGFyc2VMZXhpY2FsQmluZGluZyhraW5kLCBvcHRpb25zKV07XHJcblx0ICAgICAgICB3aGlsZSAodGhpcy5tYXRjaCgnLCcpKSB7XHJcblx0ICAgICAgICAgICAgdGhpcy5uZXh0VG9rZW4oKTtcclxuXHQgICAgICAgICAgICBsaXN0LnB1c2godGhpcy5wYXJzZUxleGljYWxCaW5kaW5nKGtpbmQsIG9wdGlvbnMpKTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIHJldHVybiBsaXN0O1xyXG5cdCAgICB9O1xyXG5cdCAgICBQYXJzZXIucHJvdG90eXBlLmlzTGV4aWNhbERlY2xhcmF0aW9uID0gZnVuY3Rpb24gKCkge1xyXG5cdCAgICAgICAgdmFyIHN0YXRlID0gdGhpcy5zY2FubmVyLnNhdmVTdGF0ZSgpO1xyXG5cdCAgICAgICAgdGhpcy5zY2FubmVyLnNjYW5Db21tZW50cygpO1xyXG5cdCAgICAgICAgdmFyIG5leHQgPSB0aGlzLnNjYW5uZXIubGV4KCk7XHJcblx0ICAgICAgICB0aGlzLnNjYW5uZXIucmVzdG9yZVN0YXRlKHN0YXRlKTtcclxuXHQgICAgICAgIHJldHVybiAobmV4dC50eXBlID09PSAzIC8qIElkZW50aWZpZXIgKi8pIHx8XHJcblx0ICAgICAgICAgICAgKG5leHQudHlwZSA9PT0gNyAvKiBQdW5jdHVhdG9yICovICYmIG5leHQudmFsdWUgPT09ICdbJykgfHxcclxuXHQgICAgICAgICAgICAobmV4dC50eXBlID09PSA3IC8qIFB1bmN0dWF0b3IgKi8gJiYgbmV4dC52YWx1ZSA9PT0gJ3snKSB8fFxyXG5cdCAgICAgICAgICAgIChuZXh0LnR5cGUgPT09IDQgLyogS2V5d29yZCAqLyAmJiBuZXh0LnZhbHVlID09PSAnbGV0JykgfHxcclxuXHQgICAgICAgICAgICAobmV4dC50eXBlID09PSA0IC8qIEtleXdvcmQgKi8gJiYgbmV4dC52YWx1ZSA9PT0gJ3lpZWxkJyk7XHJcblx0ICAgIH07XHJcblx0ICAgIFBhcnNlci5wcm90b3R5cGUucGFyc2VMZXhpY2FsRGVjbGFyYXRpb24gPSBmdW5jdGlvbiAob3B0aW9ucykge1xyXG5cdCAgICAgICAgdmFyIG5vZGUgPSB0aGlzLmNyZWF0ZU5vZGUoKTtcclxuXHQgICAgICAgIHZhciBraW5kID0gdGhpcy5uZXh0VG9rZW4oKS52YWx1ZTtcclxuXHQgICAgICAgIGFzc2VydF8xLmFzc2VydChraW5kID09PSAnbGV0JyB8fCBraW5kID09PSAnY29uc3QnLCAnTGV4aWNhbCBkZWNsYXJhdGlvbiBtdXN0IGJlIGVpdGhlciBsZXQgb3IgY29uc3QnKTtcclxuXHQgICAgICAgIHZhciBkZWNsYXJhdGlvbnMgPSB0aGlzLnBhcnNlQmluZGluZ0xpc3Qoa2luZCwgb3B0aW9ucyk7XHJcblx0ICAgICAgICB0aGlzLmNvbnN1bWVTZW1pY29sb24oKTtcclxuXHQgICAgICAgIHJldHVybiB0aGlzLmZpbmFsaXplKG5vZGUsIG5ldyBOb2RlLlZhcmlhYmxlRGVjbGFyYXRpb24oZGVjbGFyYXRpb25zLCBraW5kKSk7XHJcblx0ICAgIH07XHJcblx0ICAgIC8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLWRlc3RydWN0dXJpbmctYmluZGluZy1wYXR0ZXJuc1xyXG5cdCAgICBQYXJzZXIucHJvdG90eXBlLnBhcnNlQmluZGluZ1Jlc3RFbGVtZW50ID0gZnVuY3Rpb24gKHBhcmFtcywga2luZCkge1xyXG5cdCAgICAgICAgdmFyIG5vZGUgPSB0aGlzLmNyZWF0ZU5vZGUoKTtcclxuXHQgICAgICAgIHRoaXMuZXhwZWN0KCcuLi4nKTtcclxuXHQgICAgICAgIHZhciBhcmcgPSB0aGlzLnBhcnNlUGF0dGVybihwYXJhbXMsIGtpbmQpO1xyXG5cdCAgICAgICAgcmV0dXJuIHRoaXMuZmluYWxpemUobm9kZSwgbmV3IE5vZGUuUmVzdEVsZW1lbnQoYXJnKSk7XHJcblx0ICAgIH07XHJcblx0ICAgIFBhcnNlci5wcm90b3R5cGUucGFyc2VBcnJheVBhdHRlcm4gPSBmdW5jdGlvbiAocGFyYW1zLCBraW5kKSB7XHJcblx0ICAgICAgICB2YXIgbm9kZSA9IHRoaXMuY3JlYXRlTm9kZSgpO1xyXG5cdCAgICAgICAgdGhpcy5leHBlY3QoJ1snKTtcclxuXHQgICAgICAgIHZhciBlbGVtZW50cyA9IFtdO1xyXG5cdCAgICAgICAgd2hpbGUgKCF0aGlzLm1hdGNoKCddJykpIHtcclxuXHQgICAgICAgICAgICBpZiAodGhpcy5tYXRjaCgnLCcpKSB7XHJcblx0ICAgICAgICAgICAgICAgIHRoaXMubmV4dFRva2VuKCk7XHJcblx0ICAgICAgICAgICAgICAgIGVsZW1lbnRzLnB1c2gobnVsbCk7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgIGVsc2Uge1xyXG5cdCAgICAgICAgICAgICAgICBpZiAodGhpcy5tYXRjaCgnLi4uJykpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgIGVsZW1lbnRzLnB1c2godGhpcy5wYXJzZUJpbmRpbmdSZXN0RWxlbWVudChwYXJhbXMsIGtpbmQpKTtcclxuXHQgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cdCAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgIGVsc2Uge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgZWxlbWVudHMucHVzaCh0aGlzLnBhcnNlUGF0dGVybldpdGhEZWZhdWx0KHBhcmFtcywga2luZCkpO1xyXG5cdCAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgIGlmICghdGhpcy5tYXRjaCgnXScpKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICB0aGlzLmV4cGVjdCgnLCcpO1xyXG5cdCAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgdGhpcy5leHBlY3QoJ10nKTtcclxuXHQgICAgICAgIHJldHVybiB0aGlzLmZpbmFsaXplKG5vZGUsIG5ldyBOb2RlLkFycmF5UGF0dGVybihlbGVtZW50cykpO1xyXG5cdCAgICB9O1xyXG5cdCAgICBQYXJzZXIucHJvdG90eXBlLnBhcnNlUHJvcGVydHlQYXR0ZXJuID0gZnVuY3Rpb24gKHBhcmFtcywga2luZCkge1xyXG5cdCAgICAgICAgdmFyIG5vZGUgPSB0aGlzLmNyZWF0ZU5vZGUoKTtcclxuXHQgICAgICAgIHZhciBjb21wdXRlZCA9IGZhbHNlO1xyXG5cdCAgICAgICAgdmFyIHNob3J0aGFuZCA9IGZhbHNlO1xyXG5cdCAgICAgICAgdmFyIG1ldGhvZCA9IGZhbHNlO1xyXG5cdCAgICAgICAgdmFyIGtleTtcclxuXHQgICAgICAgIHZhciB2YWx1ZTtcclxuXHQgICAgICAgIGlmICh0aGlzLmxvb2thaGVhZC50eXBlID09PSAzIC8qIElkZW50aWZpZXIgKi8pIHtcclxuXHQgICAgICAgICAgICB2YXIga2V5VG9rZW4gPSB0aGlzLmxvb2thaGVhZDtcclxuXHQgICAgICAgICAgICBrZXkgPSB0aGlzLnBhcnNlVmFyaWFibGVJZGVudGlmaWVyKCk7XHJcblx0ICAgICAgICAgICAgdmFyIGluaXQgPSB0aGlzLmZpbmFsaXplKG5vZGUsIG5ldyBOb2RlLklkZW50aWZpZXIoa2V5VG9rZW4udmFsdWUpKTtcclxuXHQgICAgICAgICAgICBpZiAodGhpcy5tYXRjaCgnPScpKSB7XHJcblx0ICAgICAgICAgICAgICAgIHBhcmFtcy5wdXNoKGtleVRva2VuKTtcclxuXHQgICAgICAgICAgICAgICAgc2hvcnRoYW5kID0gdHJ1ZTtcclxuXHQgICAgICAgICAgICAgICAgdGhpcy5uZXh0VG9rZW4oKTtcclxuXHQgICAgICAgICAgICAgICAgdmFyIGV4cHIgPSB0aGlzLnBhcnNlQXNzaWdubWVudEV4cHJlc3Npb24oKTtcclxuXHQgICAgICAgICAgICAgICAgdmFsdWUgPSB0aGlzLmZpbmFsaXplKHRoaXMuc3RhcnROb2RlKGtleVRva2VuKSwgbmV3IE5vZGUuQXNzaWdubWVudFBhdHRlcm4oaW5pdCwgZXhwcikpO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICBlbHNlIGlmICghdGhpcy5tYXRjaCgnOicpKSB7XHJcblx0ICAgICAgICAgICAgICAgIHBhcmFtcy5wdXNoKGtleVRva2VuKTtcclxuXHQgICAgICAgICAgICAgICAgc2hvcnRoYW5kID0gdHJ1ZTtcclxuXHQgICAgICAgICAgICAgICAgdmFsdWUgPSBpbml0O1xyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICBlbHNlIHtcclxuXHQgICAgICAgICAgICAgICAgdGhpcy5leHBlY3QoJzonKTtcclxuXHQgICAgICAgICAgICAgICAgdmFsdWUgPSB0aGlzLnBhcnNlUGF0dGVybldpdGhEZWZhdWx0KHBhcmFtcywga2luZCk7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgZWxzZSB7XHJcblx0ICAgICAgICAgICAgY29tcHV0ZWQgPSB0aGlzLm1hdGNoKCdbJyk7XHJcblx0ICAgICAgICAgICAga2V5ID0gdGhpcy5wYXJzZU9iamVjdFByb3BlcnR5S2V5KCk7XHJcblx0ICAgICAgICAgICAgdGhpcy5leHBlY3QoJzonKTtcclxuXHQgICAgICAgICAgICB2YWx1ZSA9IHRoaXMucGFyc2VQYXR0ZXJuV2l0aERlZmF1bHQocGFyYW1zLCBraW5kKTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIHJldHVybiB0aGlzLmZpbmFsaXplKG5vZGUsIG5ldyBOb2RlLlByb3BlcnR5KCdpbml0Jywga2V5LCBjb21wdXRlZCwgdmFsdWUsIG1ldGhvZCwgc2hvcnRoYW5kKSk7XHJcblx0ICAgIH07XHJcblx0ICAgIFBhcnNlci5wcm90b3R5cGUucGFyc2VPYmplY3RQYXR0ZXJuID0gZnVuY3Rpb24gKHBhcmFtcywga2luZCkge1xyXG5cdCAgICAgICAgdmFyIG5vZGUgPSB0aGlzLmNyZWF0ZU5vZGUoKTtcclxuXHQgICAgICAgIHZhciBwcm9wZXJ0aWVzID0gW107XHJcblx0ICAgICAgICB0aGlzLmV4cGVjdCgneycpO1xyXG5cdCAgICAgICAgd2hpbGUgKCF0aGlzLm1hdGNoKCd9JykpIHtcclxuXHQgICAgICAgICAgICBwcm9wZXJ0aWVzLnB1c2godGhpcy5wYXJzZVByb3BlcnR5UGF0dGVybihwYXJhbXMsIGtpbmQpKTtcclxuXHQgICAgICAgICAgICBpZiAoIXRoaXMubWF0Y2goJ30nKSkge1xyXG5cdCAgICAgICAgICAgICAgICB0aGlzLmV4cGVjdCgnLCcpO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIHRoaXMuZXhwZWN0KCd9Jyk7XHJcblx0ICAgICAgICByZXR1cm4gdGhpcy5maW5hbGl6ZShub2RlLCBuZXcgTm9kZS5PYmplY3RQYXR0ZXJuKHByb3BlcnRpZXMpKTtcclxuXHQgICAgfTtcclxuXHQgICAgUGFyc2VyLnByb3RvdHlwZS5wYXJzZVBhdHRlcm4gPSBmdW5jdGlvbiAocGFyYW1zLCBraW5kKSB7XHJcblx0ICAgICAgICB2YXIgcGF0dGVybjtcclxuXHQgICAgICAgIGlmICh0aGlzLm1hdGNoKCdbJykpIHtcclxuXHQgICAgICAgICAgICBwYXR0ZXJuID0gdGhpcy5wYXJzZUFycmF5UGF0dGVybihwYXJhbXMsIGtpbmQpO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgZWxzZSBpZiAodGhpcy5tYXRjaCgneycpKSB7XHJcblx0ICAgICAgICAgICAgcGF0dGVybiA9IHRoaXMucGFyc2VPYmplY3RQYXR0ZXJuKHBhcmFtcywga2luZCk7XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICBlbHNlIHtcclxuXHQgICAgICAgICAgICBpZiAodGhpcy5tYXRjaEtleXdvcmQoJ2xldCcpICYmIChraW5kID09PSAnY29uc3QnIHx8IGtpbmQgPT09ICdsZXQnKSkge1xyXG5cdCAgICAgICAgICAgICAgICB0aGlzLnRvbGVyYXRlVW5leHBlY3RlZFRva2VuKHRoaXMubG9va2FoZWFkLCBtZXNzYWdlc18xLk1lc3NhZ2VzLkxldEluTGV4aWNhbEJpbmRpbmcpO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICBwYXJhbXMucHVzaCh0aGlzLmxvb2thaGVhZCk7XHJcblx0ICAgICAgICAgICAgcGF0dGVybiA9IHRoaXMucGFyc2VWYXJpYWJsZUlkZW50aWZpZXIoa2luZCk7XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICByZXR1cm4gcGF0dGVybjtcclxuXHQgICAgfTtcclxuXHQgICAgUGFyc2VyLnByb3RvdHlwZS5wYXJzZVBhdHRlcm5XaXRoRGVmYXVsdCA9IGZ1bmN0aW9uIChwYXJhbXMsIGtpbmQpIHtcclxuXHQgICAgICAgIHZhciBzdGFydFRva2VuID0gdGhpcy5sb29rYWhlYWQ7XHJcblx0ICAgICAgICB2YXIgcGF0dGVybiA9IHRoaXMucGFyc2VQYXR0ZXJuKHBhcmFtcywga2luZCk7XHJcblx0ICAgICAgICBpZiAodGhpcy5tYXRjaCgnPScpKSB7XHJcblx0ICAgICAgICAgICAgdGhpcy5uZXh0VG9rZW4oKTtcclxuXHQgICAgICAgICAgICB2YXIgcHJldmlvdXNBbGxvd1lpZWxkID0gdGhpcy5jb250ZXh0LmFsbG93WWllbGQ7XHJcblx0ICAgICAgICAgICAgdGhpcy5jb250ZXh0LmFsbG93WWllbGQgPSB0cnVlO1xyXG5cdCAgICAgICAgICAgIHZhciByaWdodCA9IHRoaXMuaXNvbGF0ZUNvdmVyR3JhbW1hcih0aGlzLnBhcnNlQXNzaWdubWVudEV4cHJlc3Npb24pO1xyXG5cdCAgICAgICAgICAgIHRoaXMuY29udGV4dC5hbGxvd1lpZWxkID0gcHJldmlvdXNBbGxvd1lpZWxkO1xyXG5cdCAgICAgICAgICAgIHBhdHRlcm4gPSB0aGlzLmZpbmFsaXplKHRoaXMuc3RhcnROb2RlKHN0YXJ0VG9rZW4pLCBuZXcgTm9kZS5Bc3NpZ25tZW50UGF0dGVybihwYXR0ZXJuLCByaWdodCkpO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgcmV0dXJuIHBhdHRlcm47XHJcblx0ICAgIH07XHJcblx0ICAgIC8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLXZhcmlhYmxlLXN0YXRlbWVudFxyXG5cdCAgICBQYXJzZXIucHJvdG90eXBlLnBhcnNlVmFyaWFibGVJZGVudGlmaWVyID0gZnVuY3Rpb24gKGtpbmQpIHtcclxuXHQgICAgICAgIHZhciBub2RlID0gdGhpcy5jcmVhdGVOb2RlKCk7XHJcblx0ICAgICAgICB2YXIgdG9rZW4gPSB0aGlzLm5leHRUb2tlbigpO1xyXG5cdCAgICAgICAgaWYgKHRva2VuLnR5cGUgPT09IDQgLyogS2V5d29yZCAqLyAmJiB0b2tlbi52YWx1ZSA9PT0gJ3lpZWxkJykge1xyXG5cdCAgICAgICAgICAgIGlmICh0aGlzLmNvbnRleHQuc3RyaWN0KSB7XHJcblx0ICAgICAgICAgICAgICAgIHRoaXMudG9sZXJhdGVVbmV4cGVjdGVkVG9rZW4odG9rZW4sIG1lc3NhZ2VzXzEuTWVzc2FnZXMuU3RyaWN0UmVzZXJ2ZWRXb3JkKTtcclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgZWxzZSBpZiAoIXRoaXMuY29udGV4dC5hbGxvd1lpZWxkKSB7XHJcblx0ICAgICAgICAgICAgICAgIHRoaXMudGhyb3dVbmV4cGVjdGVkVG9rZW4odG9rZW4pO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIGVsc2UgaWYgKHRva2VuLnR5cGUgIT09IDMgLyogSWRlbnRpZmllciAqLykge1xyXG5cdCAgICAgICAgICAgIGlmICh0aGlzLmNvbnRleHQuc3RyaWN0ICYmIHRva2VuLnR5cGUgPT09IDQgLyogS2V5d29yZCAqLyAmJiB0aGlzLnNjYW5uZXIuaXNTdHJpY3RNb2RlUmVzZXJ2ZWRXb3JkKHRva2VuLnZhbHVlKSkge1xyXG5cdCAgICAgICAgICAgICAgICB0aGlzLnRvbGVyYXRlVW5leHBlY3RlZFRva2VuKHRva2VuLCBtZXNzYWdlc18xLk1lc3NhZ2VzLlN0cmljdFJlc2VydmVkV29yZCk7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgIGVsc2Uge1xyXG5cdCAgICAgICAgICAgICAgICBpZiAodGhpcy5jb250ZXh0LnN0cmljdCB8fCB0b2tlbi52YWx1ZSAhPT0gJ2xldCcgfHwga2luZCAhPT0gJ3ZhcicpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgIHRoaXMudGhyb3dVbmV4cGVjdGVkVG9rZW4odG9rZW4pO1xyXG5cdCAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgZWxzZSBpZiAoKHRoaXMuY29udGV4dC5pc01vZHVsZSB8fCB0aGlzLmNvbnRleHQuYXdhaXQpICYmIHRva2VuLnR5cGUgPT09IDMgLyogSWRlbnRpZmllciAqLyAmJiB0b2tlbi52YWx1ZSA9PT0gJ2F3YWl0Jykge1xyXG5cdCAgICAgICAgICAgIHRoaXMudG9sZXJhdGVVbmV4cGVjdGVkVG9rZW4odG9rZW4pO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgcmV0dXJuIHRoaXMuZmluYWxpemUobm9kZSwgbmV3IE5vZGUuSWRlbnRpZmllcih0b2tlbi52YWx1ZSkpO1xyXG5cdCAgICB9O1xyXG5cdCAgICBQYXJzZXIucHJvdG90eXBlLnBhcnNlVmFyaWFibGVEZWNsYXJhdGlvbiA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XHJcblx0ICAgICAgICB2YXIgbm9kZSA9IHRoaXMuY3JlYXRlTm9kZSgpO1xyXG5cdCAgICAgICAgdmFyIHBhcmFtcyA9IFtdO1xyXG5cdCAgICAgICAgdmFyIGlkID0gdGhpcy5wYXJzZVBhdHRlcm4ocGFyYW1zLCAndmFyJyk7XHJcblx0ICAgICAgICBpZiAodGhpcy5jb250ZXh0LnN0cmljdCAmJiBpZC50eXBlID09PSBzeW50YXhfMS5TeW50YXguSWRlbnRpZmllcikge1xyXG5cdCAgICAgICAgICAgIGlmICh0aGlzLnNjYW5uZXIuaXNSZXN0cmljdGVkV29yZChpZC5uYW1lKSkge1xyXG5cdCAgICAgICAgICAgICAgICB0aGlzLnRvbGVyYXRlRXJyb3IobWVzc2FnZXNfMS5NZXNzYWdlcy5TdHJpY3RWYXJOYW1lKTtcclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICB2YXIgaW5pdCA9IG51bGw7XHJcblx0ICAgICAgICBpZiAodGhpcy5tYXRjaCgnPScpKSB7XHJcblx0ICAgICAgICAgICAgdGhpcy5uZXh0VG9rZW4oKTtcclxuXHQgICAgICAgICAgICBpbml0ID0gdGhpcy5pc29sYXRlQ292ZXJHcmFtbWFyKHRoaXMucGFyc2VBc3NpZ25tZW50RXhwcmVzc2lvbik7XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICBlbHNlIGlmIChpZC50eXBlICE9PSBzeW50YXhfMS5TeW50YXguSWRlbnRpZmllciAmJiAhb3B0aW9ucy5pbkZvcikge1xyXG5cdCAgICAgICAgICAgIHRoaXMuZXhwZWN0KCc9Jyk7XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICByZXR1cm4gdGhpcy5maW5hbGl6ZShub2RlLCBuZXcgTm9kZS5WYXJpYWJsZURlY2xhcmF0b3IoaWQsIGluaXQpKTtcclxuXHQgICAgfTtcclxuXHQgICAgUGFyc2VyLnByb3RvdHlwZS5wYXJzZVZhcmlhYmxlRGVjbGFyYXRpb25MaXN0ID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcclxuXHQgICAgICAgIHZhciBvcHQgPSB7IGluRm9yOiBvcHRpb25zLmluRm9yIH07XHJcblx0ICAgICAgICB2YXIgbGlzdCA9IFtdO1xyXG5cdCAgICAgICAgbGlzdC5wdXNoKHRoaXMucGFyc2VWYXJpYWJsZURlY2xhcmF0aW9uKG9wdCkpO1xyXG5cdCAgICAgICAgd2hpbGUgKHRoaXMubWF0Y2goJywnKSkge1xyXG5cdCAgICAgICAgICAgIHRoaXMubmV4dFRva2VuKCk7XHJcblx0ICAgICAgICAgICAgbGlzdC5wdXNoKHRoaXMucGFyc2VWYXJpYWJsZURlY2xhcmF0aW9uKG9wdCkpO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgcmV0dXJuIGxpc3Q7XHJcblx0ICAgIH07XHJcblx0ICAgIFBhcnNlci5wcm90b3R5cGUucGFyc2VWYXJpYWJsZVN0YXRlbWVudCA9IGZ1bmN0aW9uICgpIHtcclxuXHQgICAgICAgIHZhciBub2RlID0gdGhpcy5jcmVhdGVOb2RlKCk7XHJcblx0ICAgICAgICB0aGlzLmV4cGVjdEtleXdvcmQoJ3ZhcicpO1xyXG5cdCAgICAgICAgdmFyIGRlY2xhcmF0aW9ucyA9IHRoaXMucGFyc2VWYXJpYWJsZURlY2xhcmF0aW9uTGlzdCh7IGluRm9yOiBmYWxzZSB9KTtcclxuXHQgICAgICAgIHRoaXMuY29uc3VtZVNlbWljb2xvbigpO1xyXG5cdCAgICAgICAgcmV0dXJuIHRoaXMuZmluYWxpemUobm9kZSwgbmV3IE5vZGUuVmFyaWFibGVEZWNsYXJhdGlvbihkZWNsYXJhdGlvbnMsICd2YXInKSk7XHJcblx0ICAgIH07XHJcblx0ICAgIC8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLWVtcHR5LXN0YXRlbWVudFxyXG5cdCAgICBQYXJzZXIucHJvdG90eXBlLnBhcnNlRW1wdHlTdGF0ZW1lbnQgPSBmdW5jdGlvbiAoKSB7XHJcblx0ICAgICAgICB2YXIgbm9kZSA9IHRoaXMuY3JlYXRlTm9kZSgpO1xyXG5cdCAgICAgICAgdGhpcy5leHBlY3QoJzsnKTtcclxuXHQgICAgICAgIHJldHVybiB0aGlzLmZpbmFsaXplKG5vZGUsIG5ldyBOb2RlLkVtcHR5U3RhdGVtZW50KCkpO1xyXG5cdCAgICB9O1xyXG5cdCAgICAvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1leHByZXNzaW9uLXN0YXRlbWVudFxyXG5cdCAgICBQYXJzZXIucHJvdG90eXBlLnBhcnNlRXhwcmVzc2lvblN0YXRlbWVudCA9IGZ1bmN0aW9uICgpIHtcclxuXHQgICAgICAgIHZhciBub2RlID0gdGhpcy5jcmVhdGVOb2RlKCk7XHJcblx0ICAgICAgICB2YXIgZXhwciA9IHRoaXMucGFyc2VFeHByZXNzaW9uKCk7XHJcblx0ICAgICAgICB0aGlzLmNvbnN1bWVTZW1pY29sb24oKTtcclxuXHQgICAgICAgIHJldHVybiB0aGlzLmZpbmFsaXplKG5vZGUsIG5ldyBOb2RlLkV4cHJlc3Npb25TdGF0ZW1lbnQoZXhwcikpO1xyXG5cdCAgICB9O1xyXG5cdCAgICAvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1pZi1zdGF0ZW1lbnRcclxuXHQgICAgUGFyc2VyLnByb3RvdHlwZS5wYXJzZUlmQ2xhdXNlID0gZnVuY3Rpb24gKCkge1xyXG5cdCAgICAgICAgaWYgKHRoaXMuY29udGV4dC5zdHJpY3QgJiYgdGhpcy5tYXRjaEtleXdvcmQoJ2Z1bmN0aW9uJykpIHtcclxuXHQgICAgICAgICAgICB0aGlzLnRvbGVyYXRlRXJyb3IobWVzc2FnZXNfMS5NZXNzYWdlcy5TdHJpY3RGdW5jdGlvbik7XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICByZXR1cm4gdGhpcy5wYXJzZVN0YXRlbWVudCgpO1xyXG5cdCAgICB9O1xyXG5cdCAgICBQYXJzZXIucHJvdG90eXBlLnBhcnNlSWZTdGF0ZW1lbnQgPSBmdW5jdGlvbiAoKSB7XHJcblx0ICAgICAgICB2YXIgbm9kZSA9IHRoaXMuY3JlYXRlTm9kZSgpO1xyXG5cdCAgICAgICAgdmFyIGNvbnNlcXVlbnQ7XHJcblx0ICAgICAgICB2YXIgYWx0ZXJuYXRlID0gbnVsbDtcclxuXHQgICAgICAgIHRoaXMuZXhwZWN0S2V5d29yZCgnaWYnKTtcclxuXHQgICAgICAgIHRoaXMuZXhwZWN0KCcoJyk7XHJcblx0ICAgICAgICB2YXIgdGVzdCA9IHRoaXMucGFyc2VFeHByZXNzaW9uKCk7XHJcblx0ICAgICAgICBpZiAoIXRoaXMubWF0Y2goJyknKSAmJiB0aGlzLmNvbmZpZy50b2xlcmFudCkge1xyXG5cdCAgICAgICAgICAgIHRoaXMudG9sZXJhdGVVbmV4cGVjdGVkVG9rZW4odGhpcy5uZXh0VG9rZW4oKSk7XHJcblx0ICAgICAgICAgICAgY29uc2VxdWVudCA9IHRoaXMuZmluYWxpemUodGhpcy5jcmVhdGVOb2RlKCksIG5ldyBOb2RlLkVtcHR5U3RhdGVtZW50KCkpO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgZWxzZSB7XHJcblx0ICAgICAgICAgICAgdGhpcy5leHBlY3QoJyknKTtcclxuXHQgICAgICAgICAgICBjb25zZXF1ZW50ID0gdGhpcy5wYXJzZUlmQ2xhdXNlKCk7XHJcblx0ICAgICAgICAgICAgaWYgKHRoaXMubWF0Y2hLZXl3b3JkKCdlbHNlJykpIHtcclxuXHQgICAgICAgICAgICAgICAgdGhpcy5uZXh0VG9rZW4oKTtcclxuXHQgICAgICAgICAgICAgICAgYWx0ZXJuYXRlID0gdGhpcy5wYXJzZUlmQ2xhdXNlKCk7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgcmV0dXJuIHRoaXMuZmluYWxpemUobm9kZSwgbmV3IE5vZGUuSWZTdGF0ZW1lbnQodGVzdCwgY29uc2VxdWVudCwgYWx0ZXJuYXRlKSk7XHJcblx0ICAgIH07XHJcblx0ICAgIC8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLWRvLXdoaWxlLXN0YXRlbWVudFxyXG5cdCAgICBQYXJzZXIucHJvdG90eXBlLnBhcnNlRG9XaGlsZVN0YXRlbWVudCA9IGZ1bmN0aW9uICgpIHtcclxuXHQgICAgICAgIHZhciBub2RlID0gdGhpcy5jcmVhdGVOb2RlKCk7XHJcblx0ICAgICAgICB0aGlzLmV4cGVjdEtleXdvcmQoJ2RvJyk7XHJcblx0ICAgICAgICB2YXIgcHJldmlvdXNJbkl0ZXJhdGlvbiA9IHRoaXMuY29udGV4dC5pbkl0ZXJhdGlvbjtcclxuXHQgICAgICAgIHRoaXMuY29udGV4dC5pbkl0ZXJhdGlvbiA9IHRydWU7XHJcblx0ICAgICAgICB2YXIgYm9keSA9IHRoaXMucGFyc2VTdGF0ZW1lbnQoKTtcclxuXHQgICAgICAgIHRoaXMuY29udGV4dC5pbkl0ZXJhdGlvbiA9IHByZXZpb3VzSW5JdGVyYXRpb247XHJcblx0ICAgICAgICB0aGlzLmV4cGVjdEtleXdvcmQoJ3doaWxlJyk7XHJcblx0ICAgICAgICB0aGlzLmV4cGVjdCgnKCcpO1xyXG5cdCAgICAgICAgdmFyIHRlc3QgPSB0aGlzLnBhcnNlRXhwcmVzc2lvbigpO1xyXG5cdCAgICAgICAgaWYgKCF0aGlzLm1hdGNoKCcpJykgJiYgdGhpcy5jb25maWcudG9sZXJhbnQpIHtcclxuXHQgICAgICAgICAgICB0aGlzLnRvbGVyYXRlVW5leHBlY3RlZFRva2VuKHRoaXMubmV4dFRva2VuKCkpO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgZWxzZSB7XHJcblx0ICAgICAgICAgICAgdGhpcy5leHBlY3QoJyknKTtcclxuXHQgICAgICAgICAgICBpZiAodGhpcy5tYXRjaCgnOycpKSB7XHJcblx0ICAgICAgICAgICAgICAgIHRoaXMubmV4dFRva2VuKCk7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgcmV0dXJuIHRoaXMuZmluYWxpemUobm9kZSwgbmV3IE5vZGUuRG9XaGlsZVN0YXRlbWVudChib2R5LCB0ZXN0KSk7XHJcblx0ICAgIH07XHJcblx0ICAgIC8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLXdoaWxlLXN0YXRlbWVudFxyXG5cdCAgICBQYXJzZXIucHJvdG90eXBlLnBhcnNlV2hpbGVTdGF0ZW1lbnQgPSBmdW5jdGlvbiAoKSB7XHJcblx0ICAgICAgICB2YXIgbm9kZSA9IHRoaXMuY3JlYXRlTm9kZSgpO1xyXG5cdCAgICAgICAgdmFyIGJvZHk7XHJcblx0ICAgICAgICB0aGlzLmV4cGVjdEtleXdvcmQoJ3doaWxlJyk7XHJcblx0ICAgICAgICB0aGlzLmV4cGVjdCgnKCcpO1xyXG5cdCAgICAgICAgdmFyIHRlc3QgPSB0aGlzLnBhcnNlRXhwcmVzc2lvbigpO1xyXG5cdCAgICAgICAgaWYgKCF0aGlzLm1hdGNoKCcpJykgJiYgdGhpcy5jb25maWcudG9sZXJhbnQpIHtcclxuXHQgICAgICAgICAgICB0aGlzLnRvbGVyYXRlVW5leHBlY3RlZFRva2VuKHRoaXMubmV4dFRva2VuKCkpO1xyXG5cdCAgICAgICAgICAgIGJvZHkgPSB0aGlzLmZpbmFsaXplKHRoaXMuY3JlYXRlTm9kZSgpLCBuZXcgTm9kZS5FbXB0eVN0YXRlbWVudCgpKTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIGVsc2Uge1xyXG5cdCAgICAgICAgICAgIHRoaXMuZXhwZWN0KCcpJyk7XHJcblx0ICAgICAgICAgICAgdmFyIHByZXZpb3VzSW5JdGVyYXRpb24gPSB0aGlzLmNvbnRleHQuaW5JdGVyYXRpb247XHJcblx0ICAgICAgICAgICAgdGhpcy5jb250ZXh0LmluSXRlcmF0aW9uID0gdHJ1ZTtcclxuXHQgICAgICAgICAgICBib2R5ID0gdGhpcy5wYXJzZVN0YXRlbWVudCgpO1xyXG5cdCAgICAgICAgICAgIHRoaXMuY29udGV4dC5pbkl0ZXJhdGlvbiA9IHByZXZpb3VzSW5JdGVyYXRpb247XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICByZXR1cm4gdGhpcy5maW5hbGl6ZShub2RlLCBuZXcgTm9kZS5XaGlsZVN0YXRlbWVudCh0ZXN0LCBib2R5KSk7XHJcblx0ICAgIH07XHJcblx0ICAgIC8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLWZvci1zdGF0ZW1lbnRcclxuXHQgICAgLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtZm9yLWluLWFuZC1mb3Itb2Ytc3RhdGVtZW50c1xyXG5cdCAgICBQYXJzZXIucHJvdG90eXBlLnBhcnNlRm9yU3RhdGVtZW50ID0gZnVuY3Rpb24gKCkge1xyXG5cdCAgICAgICAgdmFyIGluaXQgPSBudWxsO1xyXG5cdCAgICAgICAgdmFyIHRlc3QgPSBudWxsO1xyXG5cdCAgICAgICAgdmFyIHVwZGF0ZSA9IG51bGw7XHJcblx0ICAgICAgICB2YXIgZm9ySW4gPSB0cnVlO1xyXG5cdCAgICAgICAgdmFyIGxlZnQsIHJpZ2h0O1xyXG5cdCAgICAgICAgdmFyIG5vZGUgPSB0aGlzLmNyZWF0ZU5vZGUoKTtcclxuXHQgICAgICAgIHRoaXMuZXhwZWN0S2V5d29yZCgnZm9yJyk7XHJcblx0ICAgICAgICB0aGlzLmV4cGVjdCgnKCcpO1xyXG5cdCAgICAgICAgaWYgKHRoaXMubWF0Y2goJzsnKSkge1xyXG5cdCAgICAgICAgICAgIHRoaXMubmV4dFRva2VuKCk7XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICBlbHNlIHtcclxuXHQgICAgICAgICAgICBpZiAodGhpcy5tYXRjaEtleXdvcmQoJ3ZhcicpKSB7XHJcblx0ICAgICAgICAgICAgICAgIGluaXQgPSB0aGlzLmNyZWF0ZU5vZGUoKTtcclxuXHQgICAgICAgICAgICAgICAgdGhpcy5uZXh0VG9rZW4oKTtcclxuXHQgICAgICAgICAgICAgICAgdmFyIHByZXZpb3VzQWxsb3dJbiA9IHRoaXMuY29udGV4dC5hbGxvd0luO1xyXG5cdCAgICAgICAgICAgICAgICB0aGlzLmNvbnRleHQuYWxsb3dJbiA9IGZhbHNlO1xyXG5cdCAgICAgICAgICAgICAgICB2YXIgZGVjbGFyYXRpb25zID0gdGhpcy5wYXJzZVZhcmlhYmxlRGVjbGFyYXRpb25MaXN0KHsgaW5Gb3I6IHRydWUgfSk7XHJcblx0ICAgICAgICAgICAgICAgIHRoaXMuY29udGV4dC5hbGxvd0luID0gcHJldmlvdXNBbGxvd0luO1xyXG5cdCAgICAgICAgICAgICAgICBpZiAoZGVjbGFyYXRpb25zLmxlbmd0aCA9PT0gMSAmJiB0aGlzLm1hdGNoS2V5d29yZCgnaW4nKSkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIGRlY2wgPSBkZWNsYXJhdGlvbnNbMF07XHJcblx0ICAgICAgICAgICAgICAgICAgICBpZiAoZGVjbC5pbml0ICYmIChkZWNsLmlkLnR5cGUgPT09IHN5bnRheF8xLlN5bnRheC5BcnJheVBhdHRlcm4gfHwgZGVjbC5pZC50eXBlID09PSBzeW50YXhfMS5TeW50YXguT2JqZWN0UGF0dGVybiB8fCB0aGlzLmNvbnRleHQuc3RyaWN0KSkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMudG9sZXJhdGVFcnJvcihtZXNzYWdlc18xLk1lc3NhZ2VzLkZvckluT2ZMb29wSW5pdGlhbGl6ZXIsICdmb3ItaW4nKTtcclxuXHQgICAgICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgICAgIGluaXQgPSB0aGlzLmZpbmFsaXplKGluaXQsIG5ldyBOb2RlLlZhcmlhYmxlRGVjbGFyYXRpb24oZGVjbGFyYXRpb25zLCAndmFyJykpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgdGhpcy5uZXh0VG9rZW4oKTtcclxuXHQgICAgICAgICAgICAgICAgICAgIGxlZnQgPSBpbml0O1xyXG5cdCAgICAgICAgICAgICAgICAgICAgcmlnaHQgPSB0aGlzLnBhcnNlRXhwcmVzc2lvbigpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgaW5pdCA9IG51bGw7XHJcblx0ICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgZWxzZSBpZiAoZGVjbGFyYXRpb25zLmxlbmd0aCA9PT0gMSAmJiBkZWNsYXJhdGlvbnNbMF0uaW5pdCA9PT0gbnVsbCAmJiB0aGlzLm1hdGNoQ29udGV4dHVhbEtleXdvcmQoJ29mJykpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgIGluaXQgPSB0aGlzLmZpbmFsaXplKGluaXQsIG5ldyBOb2RlLlZhcmlhYmxlRGVjbGFyYXRpb24oZGVjbGFyYXRpb25zLCAndmFyJykpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgdGhpcy5uZXh0VG9rZW4oKTtcclxuXHQgICAgICAgICAgICAgICAgICAgIGxlZnQgPSBpbml0O1xyXG5cdCAgICAgICAgICAgICAgICAgICAgcmlnaHQgPSB0aGlzLnBhcnNlQXNzaWdubWVudEV4cHJlc3Npb24oKTtcclxuXHQgICAgICAgICAgICAgICAgICAgIGluaXQgPSBudWxsO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgZm9ySW4gPSBmYWxzZTtcclxuXHQgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICBlbHNlIHtcclxuXHQgICAgICAgICAgICAgICAgICAgIGluaXQgPSB0aGlzLmZpbmFsaXplKGluaXQsIG5ldyBOb2RlLlZhcmlhYmxlRGVjbGFyYXRpb24oZGVjbGFyYXRpb25zLCAndmFyJykpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgdGhpcy5leHBlY3QoJzsnKTtcclxuXHQgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICBlbHNlIGlmICh0aGlzLm1hdGNoS2V5d29yZCgnY29uc3QnKSB8fCB0aGlzLm1hdGNoS2V5d29yZCgnbGV0JykpIHtcclxuXHQgICAgICAgICAgICAgICAgaW5pdCA9IHRoaXMuY3JlYXRlTm9kZSgpO1xyXG5cdCAgICAgICAgICAgICAgICB2YXIga2luZCA9IHRoaXMubmV4dFRva2VuKCkudmFsdWU7XHJcblx0ICAgICAgICAgICAgICAgIGlmICghdGhpcy5jb250ZXh0LnN0cmljdCAmJiB0aGlzLmxvb2thaGVhZC52YWx1ZSA9PT0gJ2luJykge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgaW5pdCA9IHRoaXMuZmluYWxpemUoaW5pdCwgbmV3IE5vZGUuSWRlbnRpZmllcihraW5kKSk7XHJcblx0ICAgICAgICAgICAgICAgICAgICB0aGlzLm5leHRUb2tlbigpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgbGVmdCA9IGluaXQ7XHJcblx0ICAgICAgICAgICAgICAgICAgICByaWdodCA9IHRoaXMucGFyc2VFeHByZXNzaW9uKCk7XHJcblx0ICAgICAgICAgICAgICAgICAgICBpbml0ID0gbnVsbDtcclxuXHQgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICBlbHNlIHtcclxuXHQgICAgICAgICAgICAgICAgICAgIHZhciBwcmV2aW91c0FsbG93SW4gPSB0aGlzLmNvbnRleHQuYWxsb3dJbjtcclxuXHQgICAgICAgICAgICAgICAgICAgIHRoaXMuY29udGV4dC5hbGxvd0luID0gZmFsc2U7XHJcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgZGVjbGFyYXRpb25zID0gdGhpcy5wYXJzZUJpbmRpbmdMaXN0KGtpbmQsIHsgaW5Gb3I6IHRydWUgfSk7XHJcblx0ICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbnRleHQuYWxsb3dJbiA9IHByZXZpb3VzQWxsb3dJbjtcclxuXHQgICAgICAgICAgICAgICAgICAgIGlmIChkZWNsYXJhdGlvbnMubGVuZ3RoID09PSAxICYmIGRlY2xhcmF0aW9uc1swXS5pbml0ID09PSBudWxsICYmIHRoaXMubWF0Y2hLZXl3b3JkKCdpbicpKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgaW5pdCA9IHRoaXMuZmluYWxpemUoaW5pdCwgbmV3IE5vZGUuVmFyaWFibGVEZWNsYXJhdGlvbihkZWNsYXJhdGlvbnMsIGtpbmQpKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm5leHRUb2tlbigpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGxlZnQgPSBpbml0O1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJpZ2h0ID0gdGhpcy5wYXJzZUV4cHJlc3Npb24oKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBpbml0ID0gbnVsbDtcclxuXHQgICAgICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGRlY2xhcmF0aW9ucy5sZW5ndGggPT09IDEgJiYgZGVjbGFyYXRpb25zWzBdLmluaXQgPT09IG51bGwgJiYgdGhpcy5tYXRjaENvbnRleHR1YWxLZXl3b3JkKCdvZicpKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgaW5pdCA9IHRoaXMuZmluYWxpemUoaW5pdCwgbmV3IE5vZGUuVmFyaWFibGVEZWNsYXJhdGlvbihkZWNsYXJhdGlvbnMsIGtpbmQpKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm5leHRUb2tlbigpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGxlZnQgPSBpbml0O1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJpZ2h0ID0gdGhpcy5wYXJzZUFzc2lnbm1lbnRFeHByZXNzaW9uKCk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgaW5pdCA9IG51bGw7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgZm9ySW4gPSBmYWxzZTtcclxuXHQgICAgICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY29uc3VtZVNlbWljb2xvbigpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGluaXQgPSB0aGlzLmZpbmFsaXplKGluaXQsIG5ldyBOb2RlLlZhcmlhYmxlRGVjbGFyYXRpb24oZGVjbGFyYXRpb25zLCBraW5kKSk7XHJcblx0ICAgICAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgZWxzZSB7XHJcblx0ICAgICAgICAgICAgICAgIHZhciBpbml0U3RhcnRUb2tlbiA9IHRoaXMubG9va2FoZWFkO1xyXG5cdCAgICAgICAgICAgICAgICB2YXIgcHJldmlvdXNBbGxvd0luID0gdGhpcy5jb250ZXh0LmFsbG93SW47XHJcblx0ICAgICAgICAgICAgICAgIHRoaXMuY29udGV4dC5hbGxvd0luID0gZmFsc2U7XHJcblx0ICAgICAgICAgICAgICAgIGluaXQgPSB0aGlzLmluaGVyaXRDb3ZlckdyYW1tYXIodGhpcy5wYXJzZUFzc2lnbm1lbnRFeHByZXNzaW9uKTtcclxuXHQgICAgICAgICAgICAgICAgdGhpcy5jb250ZXh0LmFsbG93SW4gPSBwcmV2aW91c0FsbG93SW47XHJcblx0ICAgICAgICAgICAgICAgIGlmICh0aGlzLm1hdGNoS2V5d29yZCgnaW4nKSkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKCF0aGlzLmNvbnRleHQuaXNBc3NpZ25tZW50VGFyZ2V0IHx8IGluaXQudHlwZSA9PT0gc3ludGF4XzEuU3ludGF4LkFzc2lnbm1lbnRFeHByZXNzaW9uKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy50b2xlcmF0ZUVycm9yKG1lc3NhZ2VzXzEuTWVzc2FnZXMuSW52YWxpZExIU0luRm9ySW4pO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICAgICAgdGhpcy5uZXh0VG9rZW4oKTtcclxuXHQgICAgICAgICAgICAgICAgICAgIHRoaXMucmVpbnRlcnByZXRFeHByZXNzaW9uQXNQYXR0ZXJuKGluaXQpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgbGVmdCA9IGluaXQ7XHJcblx0ICAgICAgICAgICAgICAgICAgICByaWdodCA9IHRoaXMucGFyc2VFeHByZXNzaW9uKCk7XHJcblx0ICAgICAgICAgICAgICAgICAgICBpbml0ID0gbnVsbDtcclxuXHQgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICBlbHNlIGlmICh0aGlzLm1hdGNoQ29udGV4dHVhbEtleXdvcmQoJ29mJykpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgIGlmICghdGhpcy5jb250ZXh0LmlzQXNzaWdubWVudFRhcmdldCB8fCBpbml0LnR5cGUgPT09IHN5bnRheF8xLlN5bnRheC5Bc3NpZ25tZW50RXhwcmVzc2lvbikge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMudG9sZXJhdGVFcnJvcihtZXNzYWdlc18xLk1lc3NhZ2VzLkludmFsaWRMSFNJbkZvckxvb3ApO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICAgICAgdGhpcy5uZXh0VG9rZW4oKTtcclxuXHQgICAgICAgICAgICAgICAgICAgIHRoaXMucmVpbnRlcnByZXRFeHByZXNzaW9uQXNQYXR0ZXJuKGluaXQpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgbGVmdCA9IGluaXQ7XHJcblx0ICAgICAgICAgICAgICAgICAgICByaWdodCA9IHRoaXMucGFyc2VBc3NpZ25tZW50RXhwcmVzc2lvbigpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgaW5pdCA9IG51bGw7XHJcblx0ICAgICAgICAgICAgICAgICAgICBmb3JJbiA9IGZhbHNlO1xyXG5cdCAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgIGVsc2Uge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMubWF0Y2goJywnKSkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHZhciBpbml0U2VxID0gW2luaXRdO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHdoaWxlICh0aGlzLm1hdGNoKCcsJykpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5uZXh0VG9rZW4oKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5pdFNlcS5wdXNoKHRoaXMuaXNvbGF0ZUNvdmVyR3JhbW1hcih0aGlzLnBhcnNlQXNzaWdubWVudEV4cHJlc3Npb24pKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgaW5pdCA9IHRoaXMuZmluYWxpemUodGhpcy5zdGFydE5vZGUoaW5pdFN0YXJ0VG9rZW4pLCBuZXcgTm9kZS5TZXF1ZW5jZUV4cHJlc3Npb24oaW5pdFNlcSkpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICAgICAgdGhpcy5leHBlY3QoJzsnKTtcclxuXHQgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIGlmICh0eXBlb2YgbGVmdCA9PT0gJ3VuZGVmaW5lZCcpIHtcclxuXHQgICAgICAgICAgICBpZiAoIXRoaXMubWF0Y2goJzsnKSkge1xyXG5cdCAgICAgICAgICAgICAgICB0ZXN0ID0gdGhpcy5wYXJzZUV4cHJlc3Npb24oKTtcclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgdGhpcy5leHBlY3QoJzsnKTtcclxuXHQgICAgICAgICAgICBpZiAoIXRoaXMubWF0Y2goJyknKSkge1xyXG5cdCAgICAgICAgICAgICAgICB1cGRhdGUgPSB0aGlzLnBhcnNlRXhwcmVzc2lvbigpO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIHZhciBib2R5O1xyXG5cdCAgICAgICAgaWYgKCF0aGlzLm1hdGNoKCcpJykgJiYgdGhpcy5jb25maWcudG9sZXJhbnQpIHtcclxuXHQgICAgICAgICAgICB0aGlzLnRvbGVyYXRlVW5leHBlY3RlZFRva2VuKHRoaXMubmV4dFRva2VuKCkpO1xyXG5cdCAgICAgICAgICAgIGJvZHkgPSB0aGlzLmZpbmFsaXplKHRoaXMuY3JlYXRlTm9kZSgpLCBuZXcgTm9kZS5FbXB0eVN0YXRlbWVudCgpKTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIGVsc2Uge1xyXG5cdCAgICAgICAgICAgIHRoaXMuZXhwZWN0KCcpJyk7XHJcblx0ICAgICAgICAgICAgdmFyIHByZXZpb3VzSW5JdGVyYXRpb24gPSB0aGlzLmNvbnRleHQuaW5JdGVyYXRpb247XHJcblx0ICAgICAgICAgICAgdGhpcy5jb250ZXh0LmluSXRlcmF0aW9uID0gdHJ1ZTtcclxuXHQgICAgICAgICAgICBib2R5ID0gdGhpcy5pc29sYXRlQ292ZXJHcmFtbWFyKHRoaXMucGFyc2VTdGF0ZW1lbnQpO1xyXG5cdCAgICAgICAgICAgIHRoaXMuY29udGV4dC5pbkl0ZXJhdGlvbiA9IHByZXZpb3VzSW5JdGVyYXRpb247XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICByZXR1cm4gKHR5cGVvZiBsZWZ0ID09PSAndW5kZWZpbmVkJykgP1xyXG5cdCAgICAgICAgICAgIHRoaXMuZmluYWxpemUobm9kZSwgbmV3IE5vZGUuRm9yU3RhdGVtZW50KGluaXQsIHRlc3QsIHVwZGF0ZSwgYm9keSkpIDpcclxuXHQgICAgICAgICAgICBmb3JJbiA/IHRoaXMuZmluYWxpemUobm9kZSwgbmV3IE5vZGUuRm9ySW5TdGF0ZW1lbnQobGVmdCwgcmlnaHQsIGJvZHkpKSA6XHJcblx0ICAgICAgICAgICAgICAgIHRoaXMuZmluYWxpemUobm9kZSwgbmV3IE5vZGUuRm9yT2ZTdGF0ZW1lbnQobGVmdCwgcmlnaHQsIGJvZHkpKTtcclxuXHQgICAgfTtcclxuXHQgICAgLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtY29udGludWUtc3RhdGVtZW50XHJcblx0ICAgIFBhcnNlci5wcm90b3R5cGUucGFyc2VDb250aW51ZVN0YXRlbWVudCA9IGZ1bmN0aW9uICgpIHtcclxuXHQgICAgICAgIHZhciBub2RlID0gdGhpcy5jcmVhdGVOb2RlKCk7XHJcblx0ICAgICAgICB0aGlzLmV4cGVjdEtleXdvcmQoJ2NvbnRpbnVlJyk7XHJcblx0ICAgICAgICB2YXIgbGFiZWwgPSBudWxsO1xyXG5cdCAgICAgICAgaWYgKHRoaXMubG9va2FoZWFkLnR5cGUgPT09IDMgLyogSWRlbnRpZmllciAqLyAmJiAhdGhpcy5oYXNMaW5lVGVybWluYXRvcikge1xyXG5cdCAgICAgICAgICAgIHZhciBpZCA9IHRoaXMucGFyc2VWYXJpYWJsZUlkZW50aWZpZXIoKTtcclxuXHQgICAgICAgICAgICBsYWJlbCA9IGlkO1xyXG5cdCAgICAgICAgICAgIHZhciBrZXkgPSAnJCcgKyBpZC5uYW1lO1xyXG5cdCAgICAgICAgICAgIGlmICghT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHRoaXMuY29udGV4dC5sYWJlbFNldCwga2V5KSkge1xyXG5cdCAgICAgICAgICAgICAgICB0aGlzLnRocm93RXJyb3IobWVzc2FnZXNfMS5NZXNzYWdlcy5Vbmtub3duTGFiZWwsIGlkLm5hbWUpO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIHRoaXMuY29uc3VtZVNlbWljb2xvbigpO1xyXG5cdCAgICAgICAgaWYgKGxhYmVsID09PSBudWxsICYmICF0aGlzLmNvbnRleHQuaW5JdGVyYXRpb24pIHtcclxuXHQgICAgICAgICAgICB0aGlzLnRocm93RXJyb3IobWVzc2FnZXNfMS5NZXNzYWdlcy5JbGxlZ2FsQ29udGludWUpO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgcmV0dXJuIHRoaXMuZmluYWxpemUobm9kZSwgbmV3IE5vZGUuQ29udGludWVTdGF0ZW1lbnQobGFiZWwpKTtcclxuXHQgICAgfTtcclxuXHQgICAgLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtYnJlYWstc3RhdGVtZW50XHJcblx0ICAgIFBhcnNlci5wcm90b3R5cGUucGFyc2VCcmVha1N0YXRlbWVudCA9IGZ1bmN0aW9uICgpIHtcclxuXHQgICAgICAgIHZhciBub2RlID0gdGhpcy5jcmVhdGVOb2RlKCk7XHJcblx0ICAgICAgICB0aGlzLmV4cGVjdEtleXdvcmQoJ2JyZWFrJyk7XHJcblx0ICAgICAgICB2YXIgbGFiZWwgPSBudWxsO1xyXG5cdCAgICAgICAgaWYgKHRoaXMubG9va2FoZWFkLnR5cGUgPT09IDMgLyogSWRlbnRpZmllciAqLyAmJiAhdGhpcy5oYXNMaW5lVGVybWluYXRvcikge1xyXG5cdCAgICAgICAgICAgIHZhciBpZCA9IHRoaXMucGFyc2VWYXJpYWJsZUlkZW50aWZpZXIoKTtcclxuXHQgICAgICAgICAgICB2YXIga2V5ID0gJyQnICsgaWQubmFtZTtcclxuXHQgICAgICAgICAgICBpZiAoIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh0aGlzLmNvbnRleHQubGFiZWxTZXQsIGtleSkpIHtcclxuXHQgICAgICAgICAgICAgICAgdGhpcy50aHJvd0Vycm9yKG1lc3NhZ2VzXzEuTWVzc2FnZXMuVW5rbm93bkxhYmVsLCBpZC5uYW1lKTtcclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgbGFiZWwgPSBpZDtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIHRoaXMuY29uc3VtZVNlbWljb2xvbigpO1xyXG5cdCAgICAgICAgaWYgKGxhYmVsID09PSBudWxsICYmICF0aGlzLmNvbnRleHQuaW5JdGVyYXRpb24gJiYgIXRoaXMuY29udGV4dC5pblN3aXRjaCkge1xyXG5cdCAgICAgICAgICAgIHRoaXMudGhyb3dFcnJvcihtZXNzYWdlc18xLk1lc3NhZ2VzLklsbGVnYWxCcmVhayk7XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICByZXR1cm4gdGhpcy5maW5hbGl6ZShub2RlLCBuZXcgTm9kZS5CcmVha1N0YXRlbWVudChsYWJlbCkpO1xyXG5cdCAgICB9O1xyXG5cdCAgICAvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1yZXR1cm4tc3RhdGVtZW50XHJcblx0ICAgIFBhcnNlci5wcm90b3R5cGUucGFyc2VSZXR1cm5TdGF0ZW1lbnQgPSBmdW5jdGlvbiAoKSB7XHJcblx0ICAgICAgICBpZiAoIXRoaXMuY29udGV4dC5pbkZ1bmN0aW9uQm9keSkge1xyXG5cdCAgICAgICAgICAgIHRoaXMudG9sZXJhdGVFcnJvcihtZXNzYWdlc18xLk1lc3NhZ2VzLklsbGVnYWxSZXR1cm4pO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgdmFyIG5vZGUgPSB0aGlzLmNyZWF0ZU5vZGUoKTtcclxuXHQgICAgICAgIHRoaXMuZXhwZWN0S2V5d29yZCgncmV0dXJuJyk7XHJcblx0ICAgICAgICB2YXIgaGFzQXJndW1lbnQgPSAhdGhpcy5tYXRjaCgnOycpICYmICF0aGlzLm1hdGNoKCd9JykgJiZcclxuXHQgICAgICAgICAgICAhdGhpcy5oYXNMaW5lVGVybWluYXRvciAmJiB0aGlzLmxvb2thaGVhZC50eXBlICE9PSAyIC8qIEVPRiAqLztcclxuXHQgICAgICAgIHZhciBhcmd1bWVudCA9IGhhc0FyZ3VtZW50ID8gdGhpcy5wYXJzZUV4cHJlc3Npb24oKSA6IG51bGw7XHJcblx0ICAgICAgICB0aGlzLmNvbnN1bWVTZW1pY29sb24oKTtcclxuXHQgICAgICAgIHJldHVybiB0aGlzLmZpbmFsaXplKG5vZGUsIG5ldyBOb2RlLlJldHVyblN0YXRlbWVudChhcmd1bWVudCkpO1xyXG5cdCAgICB9O1xyXG5cdCAgICAvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy13aXRoLXN0YXRlbWVudFxyXG5cdCAgICBQYXJzZXIucHJvdG90eXBlLnBhcnNlV2l0aFN0YXRlbWVudCA9IGZ1bmN0aW9uICgpIHtcclxuXHQgICAgICAgIGlmICh0aGlzLmNvbnRleHQuc3RyaWN0KSB7XHJcblx0ICAgICAgICAgICAgdGhpcy50b2xlcmF0ZUVycm9yKG1lc3NhZ2VzXzEuTWVzc2FnZXMuU3RyaWN0TW9kZVdpdGgpO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgdmFyIG5vZGUgPSB0aGlzLmNyZWF0ZU5vZGUoKTtcclxuXHQgICAgICAgIHZhciBib2R5O1xyXG5cdCAgICAgICAgdGhpcy5leHBlY3RLZXl3b3JkKCd3aXRoJyk7XHJcblx0ICAgICAgICB0aGlzLmV4cGVjdCgnKCcpO1xyXG5cdCAgICAgICAgdmFyIG9iamVjdCA9IHRoaXMucGFyc2VFeHByZXNzaW9uKCk7XHJcblx0ICAgICAgICBpZiAoIXRoaXMubWF0Y2goJyknKSAmJiB0aGlzLmNvbmZpZy50b2xlcmFudCkge1xyXG5cdCAgICAgICAgICAgIHRoaXMudG9sZXJhdGVVbmV4cGVjdGVkVG9rZW4odGhpcy5uZXh0VG9rZW4oKSk7XHJcblx0ICAgICAgICAgICAgYm9keSA9IHRoaXMuZmluYWxpemUodGhpcy5jcmVhdGVOb2RlKCksIG5ldyBOb2RlLkVtcHR5U3RhdGVtZW50KCkpO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgZWxzZSB7XHJcblx0ICAgICAgICAgICAgdGhpcy5leHBlY3QoJyknKTtcclxuXHQgICAgICAgICAgICBib2R5ID0gdGhpcy5wYXJzZVN0YXRlbWVudCgpO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgcmV0dXJuIHRoaXMuZmluYWxpemUobm9kZSwgbmV3IE5vZGUuV2l0aFN0YXRlbWVudChvYmplY3QsIGJvZHkpKTtcclxuXHQgICAgfTtcclxuXHQgICAgLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtc3dpdGNoLXN0YXRlbWVudFxyXG5cdCAgICBQYXJzZXIucHJvdG90eXBlLnBhcnNlU3dpdGNoQ2FzZSA9IGZ1bmN0aW9uICgpIHtcclxuXHQgICAgICAgIHZhciBub2RlID0gdGhpcy5jcmVhdGVOb2RlKCk7XHJcblx0ICAgICAgICB2YXIgdGVzdDtcclxuXHQgICAgICAgIGlmICh0aGlzLm1hdGNoS2V5d29yZCgnZGVmYXVsdCcpKSB7XHJcblx0ICAgICAgICAgICAgdGhpcy5uZXh0VG9rZW4oKTtcclxuXHQgICAgICAgICAgICB0ZXN0ID0gbnVsbDtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIGVsc2Uge1xyXG5cdCAgICAgICAgICAgIHRoaXMuZXhwZWN0S2V5d29yZCgnY2FzZScpO1xyXG5cdCAgICAgICAgICAgIHRlc3QgPSB0aGlzLnBhcnNlRXhwcmVzc2lvbigpO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgdGhpcy5leHBlY3QoJzonKTtcclxuXHQgICAgICAgIHZhciBjb25zZXF1ZW50ID0gW107XHJcblx0ICAgICAgICB3aGlsZSAodHJ1ZSkge1xyXG5cdCAgICAgICAgICAgIGlmICh0aGlzLm1hdGNoKCd9JykgfHwgdGhpcy5tYXRjaEtleXdvcmQoJ2RlZmF1bHQnKSB8fCB0aGlzLm1hdGNoS2V5d29yZCgnY2FzZScpKSB7XHJcblx0ICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICBjb25zZXF1ZW50LnB1c2godGhpcy5wYXJzZVN0YXRlbWVudExpc3RJdGVtKCkpO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgcmV0dXJuIHRoaXMuZmluYWxpemUobm9kZSwgbmV3IE5vZGUuU3dpdGNoQ2FzZSh0ZXN0LCBjb25zZXF1ZW50KSk7XHJcblx0ICAgIH07XHJcblx0ICAgIFBhcnNlci5wcm90b3R5cGUucGFyc2VTd2l0Y2hTdGF0ZW1lbnQgPSBmdW5jdGlvbiAoKSB7XHJcblx0ICAgICAgICB2YXIgbm9kZSA9IHRoaXMuY3JlYXRlTm9kZSgpO1xyXG5cdCAgICAgICAgdGhpcy5leHBlY3RLZXl3b3JkKCdzd2l0Y2gnKTtcclxuXHQgICAgICAgIHRoaXMuZXhwZWN0KCcoJyk7XHJcblx0ICAgICAgICB2YXIgZGlzY3JpbWluYW50ID0gdGhpcy5wYXJzZUV4cHJlc3Npb24oKTtcclxuXHQgICAgICAgIHRoaXMuZXhwZWN0KCcpJyk7XHJcblx0ICAgICAgICB2YXIgcHJldmlvdXNJblN3aXRjaCA9IHRoaXMuY29udGV4dC5pblN3aXRjaDtcclxuXHQgICAgICAgIHRoaXMuY29udGV4dC5pblN3aXRjaCA9IHRydWU7XHJcblx0ICAgICAgICB2YXIgY2FzZXMgPSBbXTtcclxuXHQgICAgICAgIHZhciBkZWZhdWx0Rm91bmQgPSBmYWxzZTtcclxuXHQgICAgICAgIHRoaXMuZXhwZWN0KCd7Jyk7XHJcblx0ICAgICAgICB3aGlsZSAodHJ1ZSkge1xyXG5cdCAgICAgICAgICAgIGlmICh0aGlzLm1hdGNoKCd9JykpIHtcclxuXHQgICAgICAgICAgICAgICAgYnJlYWs7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgIHZhciBjbGF1c2UgPSB0aGlzLnBhcnNlU3dpdGNoQ2FzZSgpO1xyXG5cdCAgICAgICAgICAgIGlmIChjbGF1c2UudGVzdCA9PT0gbnVsbCkge1xyXG5cdCAgICAgICAgICAgICAgICBpZiAoZGVmYXVsdEZvdW5kKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICB0aGlzLnRocm93RXJyb3IobWVzc2FnZXNfMS5NZXNzYWdlcy5NdWx0aXBsZURlZmF1bHRzSW5Td2l0Y2gpO1xyXG5cdCAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgIGRlZmF1bHRGb3VuZCA9IHRydWU7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgIGNhc2VzLnB1c2goY2xhdXNlKTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIHRoaXMuZXhwZWN0KCd9Jyk7XHJcblx0ICAgICAgICB0aGlzLmNvbnRleHQuaW5Td2l0Y2ggPSBwcmV2aW91c0luU3dpdGNoO1xyXG5cdCAgICAgICAgcmV0dXJuIHRoaXMuZmluYWxpemUobm9kZSwgbmV3IE5vZGUuU3dpdGNoU3RhdGVtZW50KGRpc2NyaW1pbmFudCwgY2FzZXMpKTtcclxuXHQgICAgfTtcclxuXHQgICAgLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtbGFiZWxsZWQtc3RhdGVtZW50c1xyXG5cdCAgICBQYXJzZXIucHJvdG90eXBlLnBhcnNlTGFiZWxsZWRTdGF0ZW1lbnQgPSBmdW5jdGlvbiAoKSB7XHJcblx0ICAgICAgICB2YXIgbm9kZSA9IHRoaXMuY3JlYXRlTm9kZSgpO1xyXG5cdCAgICAgICAgdmFyIGV4cHIgPSB0aGlzLnBhcnNlRXhwcmVzc2lvbigpO1xyXG5cdCAgICAgICAgdmFyIHN0YXRlbWVudDtcclxuXHQgICAgICAgIGlmICgoZXhwci50eXBlID09PSBzeW50YXhfMS5TeW50YXguSWRlbnRpZmllcikgJiYgdGhpcy5tYXRjaCgnOicpKSB7XHJcblx0ICAgICAgICAgICAgdGhpcy5uZXh0VG9rZW4oKTtcclxuXHQgICAgICAgICAgICB2YXIgaWQgPSBleHByO1xyXG5cdCAgICAgICAgICAgIHZhciBrZXkgPSAnJCcgKyBpZC5uYW1lO1xyXG5cdCAgICAgICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodGhpcy5jb250ZXh0LmxhYmVsU2V0LCBrZXkpKSB7XHJcblx0ICAgICAgICAgICAgICAgIHRoaXMudGhyb3dFcnJvcihtZXNzYWdlc18xLk1lc3NhZ2VzLlJlZGVjbGFyYXRpb24sICdMYWJlbCcsIGlkLm5hbWUpO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICB0aGlzLmNvbnRleHQubGFiZWxTZXRba2V5XSA9IHRydWU7XHJcblx0ICAgICAgICAgICAgdmFyIGJvZHkgPSB2b2lkIDA7XHJcblx0ICAgICAgICAgICAgaWYgKHRoaXMubWF0Y2hLZXl3b3JkKCdjbGFzcycpKSB7XHJcblx0ICAgICAgICAgICAgICAgIHRoaXMudG9sZXJhdGVVbmV4cGVjdGVkVG9rZW4odGhpcy5sb29rYWhlYWQpO1xyXG5cdCAgICAgICAgICAgICAgICBib2R5ID0gdGhpcy5wYXJzZUNsYXNzRGVjbGFyYXRpb24oKTtcclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5tYXRjaEtleXdvcmQoJ2Z1bmN0aW9uJykpIHtcclxuXHQgICAgICAgICAgICAgICAgdmFyIHRva2VuID0gdGhpcy5sb29rYWhlYWQ7XHJcblx0ICAgICAgICAgICAgICAgIHZhciBkZWNsYXJhdGlvbiA9IHRoaXMucGFyc2VGdW5jdGlvbkRlY2xhcmF0aW9uKCk7XHJcblx0ICAgICAgICAgICAgICAgIGlmICh0aGlzLmNvbnRleHQuc3RyaWN0KSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICB0aGlzLnRvbGVyYXRlVW5leHBlY3RlZFRva2VuKHRva2VuLCBtZXNzYWdlc18xLk1lc3NhZ2VzLlN0cmljdEZ1bmN0aW9uKTtcclxuXHQgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICBlbHNlIGlmIChkZWNsYXJhdGlvbi5nZW5lcmF0b3IpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgIHRoaXMudG9sZXJhdGVVbmV4cGVjdGVkVG9rZW4odG9rZW4sIG1lc3NhZ2VzXzEuTWVzc2FnZXMuR2VuZXJhdG9ySW5MZWdhY3lDb250ZXh0KTtcclxuXHQgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICBib2R5ID0gZGVjbGFyYXRpb247XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgIGVsc2Uge1xyXG5cdCAgICAgICAgICAgICAgICBib2R5ID0gdGhpcy5wYXJzZVN0YXRlbWVudCgpO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICBkZWxldGUgdGhpcy5jb250ZXh0LmxhYmVsU2V0W2tleV07XHJcblx0ICAgICAgICAgICAgc3RhdGVtZW50ID0gbmV3IE5vZGUuTGFiZWxlZFN0YXRlbWVudChpZCwgYm9keSk7XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICBlbHNlIHtcclxuXHQgICAgICAgICAgICB0aGlzLmNvbnN1bWVTZW1pY29sb24oKTtcclxuXHQgICAgICAgICAgICBzdGF0ZW1lbnQgPSBuZXcgTm9kZS5FeHByZXNzaW9uU3RhdGVtZW50KGV4cHIpO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgcmV0dXJuIHRoaXMuZmluYWxpemUobm9kZSwgc3RhdGVtZW50KTtcclxuXHQgICAgfTtcclxuXHQgICAgLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtdGhyb3ctc3RhdGVtZW50XHJcblx0ICAgIFBhcnNlci5wcm90b3R5cGUucGFyc2VUaHJvd1N0YXRlbWVudCA9IGZ1bmN0aW9uICgpIHtcclxuXHQgICAgICAgIHZhciBub2RlID0gdGhpcy5jcmVhdGVOb2RlKCk7XHJcblx0ICAgICAgICB0aGlzLmV4cGVjdEtleXdvcmQoJ3Rocm93Jyk7XHJcblx0ICAgICAgICBpZiAodGhpcy5oYXNMaW5lVGVybWluYXRvcikge1xyXG5cdCAgICAgICAgICAgIHRoaXMudGhyb3dFcnJvcihtZXNzYWdlc18xLk1lc3NhZ2VzLk5ld2xpbmVBZnRlclRocm93KTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIHZhciBhcmd1bWVudCA9IHRoaXMucGFyc2VFeHByZXNzaW9uKCk7XHJcblx0ICAgICAgICB0aGlzLmNvbnN1bWVTZW1pY29sb24oKTtcclxuXHQgICAgICAgIHJldHVybiB0aGlzLmZpbmFsaXplKG5vZGUsIG5ldyBOb2RlLlRocm93U3RhdGVtZW50KGFyZ3VtZW50KSk7XHJcblx0ICAgIH07XHJcblx0ICAgIC8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLXRyeS1zdGF0ZW1lbnRcclxuXHQgICAgUGFyc2VyLnByb3RvdHlwZS5wYXJzZUNhdGNoQ2xhdXNlID0gZnVuY3Rpb24gKCkge1xyXG5cdCAgICAgICAgdmFyIG5vZGUgPSB0aGlzLmNyZWF0ZU5vZGUoKTtcclxuXHQgICAgICAgIHRoaXMuZXhwZWN0S2V5d29yZCgnY2F0Y2gnKTtcclxuXHQgICAgICAgIHRoaXMuZXhwZWN0KCcoJyk7XHJcblx0ICAgICAgICBpZiAodGhpcy5tYXRjaCgnKScpKSB7XHJcblx0ICAgICAgICAgICAgdGhpcy50aHJvd1VuZXhwZWN0ZWRUb2tlbih0aGlzLmxvb2thaGVhZCk7XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICB2YXIgcGFyYW1zID0gW107XHJcblx0ICAgICAgICB2YXIgcGFyYW0gPSB0aGlzLnBhcnNlUGF0dGVybihwYXJhbXMpO1xyXG5cdCAgICAgICAgdmFyIHBhcmFtTWFwID0ge307XHJcblx0ICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBhcmFtcy5sZW5ndGg7IGkrKykge1xyXG5cdCAgICAgICAgICAgIHZhciBrZXkgPSAnJCcgKyBwYXJhbXNbaV0udmFsdWU7XHJcblx0ICAgICAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChwYXJhbU1hcCwga2V5KSkge1xyXG5cdCAgICAgICAgICAgICAgICB0aGlzLnRvbGVyYXRlRXJyb3IobWVzc2FnZXNfMS5NZXNzYWdlcy5EdXBsaWNhdGVCaW5kaW5nLCBwYXJhbXNbaV0udmFsdWUpO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICBwYXJhbU1hcFtrZXldID0gdHJ1ZTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIGlmICh0aGlzLmNvbnRleHQuc3RyaWN0ICYmIHBhcmFtLnR5cGUgPT09IHN5bnRheF8xLlN5bnRheC5JZGVudGlmaWVyKSB7XHJcblx0ICAgICAgICAgICAgaWYgKHRoaXMuc2Nhbm5lci5pc1Jlc3RyaWN0ZWRXb3JkKHBhcmFtLm5hbWUpKSB7XHJcblx0ICAgICAgICAgICAgICAgIHRoaXMudG9sZXJhdGVFcnJvcihtZXNzYWdlc18xLk1lc3NhZ2VzLlN0cmljdENhdGNoVmFyaWFibGUpO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIHRoaXMuZXhwZWN0KCcpJyk7XHJcblx0ICAgICAgICB2YXIgYm9keSA9IHRoaXMucGFyc2VCbG9jaygpO1xyXG5cdCAgICAgICAgcmV0dXJuIHRoaXMuZmluYWxpemUobm9kZSwgbmV3IE5vZGUuQ2F0Y2hDbGF1c2UocGFyYW0sIGJvZHkpKTtcclxuXHQgICAgfTtcclxuXHQgICAgUGFyc2VyLnByb3RvdHlwZS5wYXJzZUZpbmFsbHlDbGF1c2UgPSBmdW5jdGlvbiAoKSB7XHJcblx0ICAgICAgICB0aGlzLmV4cGVjdEtleXdvcmQoJ2ZpbmFsbHknKTtcclxuXHQgICAgICAgIHJldHVybiB0aGlzLnBhcnNlQmxvY2soKTtcclxuXHQgICAgfTtcclxuXHQgICAgUGFyc2VyLnByb3RvdHlwZS5wYXJzZVRyeVN0YXRlbWVudCA9IGZ1bmN0aW9uICgpIHtcclxuXHQgICAgICAgIHZhciBub2RlID0gdGhpcy5jcmVhdGVOb2RlKCk7XHJcblx0ICAgICAgICB0aGlzLmV4cGVjdEtleXdvcmQoJ3RyeScpO1xyXG5cdCAgICAgICAgdmFyIGJsb2NrID0gdGhpcy5wYXJzZUJsb2NrKCk7XHJcblx0ICAgICAgICB2YXIgaGFuZGxlciA9IHRoaXMubWF0Y2hLZXl3b3JkKCdjYXRjaCcpID8gdGhpcy5wYXJzZUNhdGNoQ2xhdXNlKCkgOiBudWxsO1xyXG5cdCAgICAgICAgdmFyIGZpbmFsaXplciA9IHRoaXMubWF0Y2hLZXl3b3JkKCdmaW5hbGx5JykgPyB0aGlzLnBhcnNlRmluYWxseUNsYXVzZSgpIDogbnVsbDtcclxuXHQgICAgICAgIGlmICghaGFuZGxlciAmJiAhZmluYWxpemVyKSB7XHJcblx0ICAgICAgICAgICAgdGhpcy50aHJvd0Vycm9yKG1lc3NhZ2VzXzEuTWVzc2FnZXMuTm9DYXRjaE9yRmluYWxseSk7XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICByZXR1cm4gdGhpcy5maW5hbGl6ZShub2RlLCBuZXcgTm9kZS5UcnlTdGF0ZW1lbnQoYmxvY2ssIGhhbmRsZXIsIGZpbmFsaXplcikpO1xyXG5cdCAgICB9O1xyXG5cdCAgICAvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1kZWJ1Z2dlci1zdGF0ZW1lbnRcclxuXHQgICAgUGFyc2VyLnByb3RvdHlwZS5wYXJzZURlYnVnZ2VyU3RhdGVtZW50ID0gZnVuY3Rpb24gKCkge1xyXG5cdCAgICAgICAgdmFyIG5vZGUgPSB0aGlzLmNyZWF0ZU5vZGUoKTtcclxuXHQgICAgICAgIHRoaXMuZXhwZWN0S2V5d29yZCgnZGVidWdnZXInKTtcclxuXHQgICAgICAgIHRoaXMuY29uc3VtZVNlbWljb2xvbigpO1xyXG5cdCAgICAgICAgcmV0dXJuIHRoaXMuZmluYWxpemUobm9kZSwgbmV3IE5vZGUuRGVidWdnZXJTdGF0ZW1lbnQoKSk7XHJcblx0ICAgIH07XHJcblx0ICAgIC8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLWVjbWFzY3JpcHQtbGFuZ3VhZ2Utc3RhdGVtZW50cy1hbmQtZGVjbGFyYXRpb25zXHJcblx0ICAgIFBhcnNlci5wcm90b3R5cGUucGFyc2VTdGF0ZW1lbnQgPSBmdW5jdGlvbiAoKSB7XHJcblx0ICAgICAgICB2YXIgc3RhdGVtZW50O1xyXG5cdCAgICAgICAgc3dpdGNoICh0aGlzLmxvb2thaGVhZC50eXBlKSB7XHJcblx0ICAgICAgICAgICAgY2FzZSAxIC8qIEJvb2xlYW5MaXRlcmFsICovOlxyXG5cdCAgICAgICAgICAgIGNhc2UgNSAvKiBOdWxsTGl0ZXJhbCAqLzpcclxuXHQgICAgICAgICAgICBjYXNlIDYgLyogTnVtZXJpY0xpdGVyYWwgKi86XHJcblx0ICAgICAgICAgICAgY2FzZSA4IC8qIFN0cmluZ0xpdGVyYWwgKi86XHJcblx0ICAgICAgICAgICAgY2FzZSAxMCAvKiBUZW1wbGF0ZSAqLzpcclxuXHQgICAgICAgICAgICBjYXNlIDkgLyogUmVndWxhckV4cHJlc3Npb24gKi86XHJcblx0ICAgICAgICAgICAgICAgIHN0YXRlbWVudCA9IHRoaXMucGFyc2VFeHByZXNzaW9uU3RhdGVtZW50KCk7XHJcblx0ICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cdCAgICAgICAgICAgIGNhc2UgNyAvKiBQdW5jdHVhdG9yICovOlxyXG5cdCAgICAgICAgICAgICAgICB2YXIgdmFsdWUgPSB0aGlzLmxvb2thaGVhZC52YWx1ZTtcclxuXHQgICAgICAgICAgICAgICAgaWYgKHZhbHVlID09PSAneycpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgIHN0YXRlbWVudCA9IHRoaXMucGFyc2VCbG9jaygpO1xyXG5cdCAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgIGVsc2UgaWYgKHZhbHVlID09PSAnKCcpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgIHN0YXRlbWVudCA9IHRoaXMucGFyc2VFeHByZXNzaW9uU3RhdGVtZW50KCk7XHJcblx0ICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgZWxzZSBpZiAodmFsdWUgPT09ICc7Jykge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgc3RhdGVtZW50ID0gdGhpcy5wYXJzZUVtcHR5U3RhdGVtZW50KCk7XHJcblx0ICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgZWxzZSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICBzdGF0ZW1lbnQgPSB0aGlzLnBhcnNlRXhwcmVzc2lvblN0YXRlbWVudCgpO1xyXG5cdCAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cdCAgICAgICAgICAgIGNhc2UgMyAvKiBJZGVudGlmaWVyICovOlxyXG5cdCAgICAgICAgICAgICAgICBzdGF0ZW1lbnQgPSB0aGlzLm1hdGNoQXN5bmNGdW5jdGlvbigpID8gdGhpcy5wYXJzZUZ1bmN0aW9uRGVjbGFyYXRpb24oKSA6IHRoaXMucGFyc2VMYWJlbGxlZFN0YXRlbWVudCgpO1xyXG5cdCAgICAgICAgICAgICAgICBicmVhaztcclxuXHQgICAgICAgICAgICBjYXNlIDQgLyogS2V5d29yZCAqLzpcclxuXHQgICAgICAgICAgICAgICAgc3dpdGNoICh0aGlzLmxvb2thaGVhZC52YWx1ZSkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgY2FzZSAnYnJlYWsnOlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRlbWVudCA9IHRoaXMucGFyc2VCcmVha1N0YXRlbWVudCgpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgY2FzZSAnY29udGludWUnOlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRlbWVudCA9IHRoaXMucGFyc2VDb250aW51ZVN0YXRlbWVudCgpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgY2FzZSAnZGVidWdnZXInOlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRlbWVudCA9IHRoaXMucGFyc2VEZWJ1Z2dlclN0YXRlbWVudCgpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgY2FzZSAnZG8nOlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRlbWVudCA9IHRoaXMucGFyc2VEb1doaWxlU3RhdGVtZW50KCk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcblx0ICAgICAgICAgICAgICAgICAgICBjYXNlICdmb3InOlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRlbWVudCA9IHRoaXMucGFyc2VGb3JTdGF0ZW1lbnQoKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuXHQgICAgICAgICAgICAgICAgICAgIGNhc2UgJ2Z1bmN0aW9uJzpcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBzdGF0ZW1lbnQgPSB0aGlzLnBhcnNlRnVuY3Rpb25EZWNsYXJhdGlvbigpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgY2FzZSAnaWYnOlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRlbWVudCA9IHRoaXMucGFyc2VJZlN0YXRlbWVudCgpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgY2FzZSAncmV0dXJuJzpcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBzdGF0ZW1lbnQgPSB0aGlzLnBhcnNlUmV0dXJuU3RhdGVtZW50KCk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcblx0ICAgICAgICAgICAgICAgICAgICBjYXNlICdzd2l0Y2gnOlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRlbWVudCA9IHRoaXMucGFyc2VTd2l0Y2hTdGF0ZW1lbnQoKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuXHQgICAgICAgICAgICAgICAgICAgIGNhc2UgJ3Rocm93JzpcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBzdGF0ZW1lbnQgPSB0aGlzLnBhcnNlVGhyb3dTdGF0ZW1lbnQoKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuXHQgICAgICAgICAgICAgICAgICAgIGNhc2UgJ3RyeSc6XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGVtZW50ID0gdGhpcy5wYXJzZVRyeVN0YXRlbWVudCgpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgY2FzZSAndmFyJzpcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBzdGF0ZW1lbnQgPSB0aGlzLnBhcnNlVmFyaWFibGVTdGF0ZW1lbnQoKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuXHQgICAgICAgICAgICAgICAgICAgIGNhc2UgJ3doaWxlJzpcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBzdGF0ZW1lbnQgPSB0aGlzLnBhcnNlV2hpbGVTdGF0ZW1lbnQoKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuXHQgICAgICAgICAgICAgICAgICAgIGNhc2UgJ3dpdGgnOlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRlbWVudCA9IHRoaXMucGFyc2VXaXRoU3RhdGVtZW50KCk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcblx0ICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRlbWVudCA9IHRoaXMucGFyc2VFeHByZXNzaW9uU3RhdGVtZW50KCk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcblx0ICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgYnJlYWs7XHJcblx0ICAgICAgICAgICAgZGVmYXVsdDpcclxuXHQgICAgICAgICAgICAgICAgc3RhdGVtZW50ID0gdGhpcy50aHJvd1VuZXhwZWN0ZWRUb2tlbih0aGlzLmxvb2thaGVhZCk7XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICByZXR1cm4gc3RhdGVtZW50O1xyXG5cdCAgICB9O1xyXG5cdCAgICAvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1mdW5jdGlvbi1kZWZpbml0aW9uc1xyXG5cdCAgICBQYXJzZXIucHJvdG90eXBlLnBhcnNlRnVuY3Rpb25Tb3VyY2VFbGVtZW50cyA9IGZ1bmN0aW9uICgpIHtcclxuXHQgICAgICAgIHZhciBub2RlID0gdGhpcy5jcmVhdGVOb2RlKCk7XHJcblx0ICAgICAgICB0aGlzLmV4cGVjdCgneycpO1xyXG5cdCAgICAgICAgdmFyIGJvZHkgPSB0aGlzLnBhcnNlRGlyZWN0aXZlUHJvbG9ndWVzKCk7XHJcblx0ICAgICAgICB2YXIgcHJldmlvdXNMYWJlbFNldCA9IHRoaXMuY29udGV4dC5sYWJlbFNldDtcclxuXHQgICAgICAgIHZhciBwcmV2aW91c0luSXRlcmF0aW9uID0gdGhpcy5jb250ZXh0LmluSXRlcmF0aW9uO1xyXG5cdCAgICAgICAgdmFyIHByZXZpb3VzSW5Td2l0Y2ggPSB0aGlzLmNvbnRleHQuaW5Td2l0Y2g7XHJcblx0ICAgICAgICB2YXIgcHJldmlvdXNJbkZ1bmN0aW9uQm9keSA9IHRoaXMuY29udGV4dC5pbkZ1bmN0aW9uQm9keTtcclxuXHQgICAgICAgIHRoaXMuY29udGV4dC5sYWJlbFNldCA9IHt9O1xyXG5cdCAgICAgICAgdGhpcy5jb250ZXh0LmluSXRlcmF0aW9uID0gZmFsc2U7XHJcblx0ICAgICAgICB0aGlzLmNvbnRleHQuaW5Td2l0Y2ggPSBmYWxzZTtcclxuXHQgICAgICAgIHRoaXMuY29udGV4dC5pbkZ1bmN0aW9uQm9keSA9IHRydWU7XHJcblx0ICAgICAgICB3aGlsZSAodGhpcy5sb29rYWhlYWQudHlwZSAhPT0gMiAvKiBFT0YgKi8pIHtcclxuXHQgICAgICAgICAgICBpZiAodGhpcy5tYXRjaCgnfScpKSB7XHJcblx0ICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICBib2R5LnB1c2godGhpcy5wYXJzZVN0YXRlbWVudExpc3RJdGVtKCkpO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgdGhpcy5leHBlY3QoJ30nKTtcclxuXHQgICAgICAgIHRoaXMuY29udGV4dC5sYWJlbFNldCA9IHByZXZpb3VzTGFiZWxTZXQ7XHJcblx0ICAgICAgICB0aGlzLmNvbnRleHQuaW5JdGVyYXRpb24gPSBwcmV2aW91c0luSXRlcmF0aW9uO1xyXG5cdCAgICAgICAgdGhpcy5jb250ZXh0LmluU3dpdGNoID0gcHJldmlvdXNJblN3aXRjaDtcclxuXHQgICAgICAgIHRoaXMuY29udGV4dC5pbkZ1bmN0aW9uQm9keSA9IHByZXZpb3VzSW5GdW5jdGlvbkJvZHk7XHJcblx0ICAgICAgICByZXR1cm4gdGhpcy5maW5hbGl6ZShub2RlLCBuZXcgTm9kZS5CbG9ja1N0YXRlbWVudChib2R5KSk7XHJcblx0ICAgIH07XHJcblx0ICAgIFBhcnNlci5wcm90b3R5cGUudmFsaWRhdGVQYXJhbSA9IGZ1bmN0aW9uIChvcHRpb25zLCBwYXJhbSwgbmFtZSkge1xyXG5cdCAgICAgICAgdmFyIGtleSA9ICckJyArIG5hbWU7XHJcblx0ICAgICAgICBpZiAodGhpcy5jb250ZXh0LnN0cmljdCkge1xyXG5cdCAgICAgICAgICAgIGlmICh0aGlzLnNjYW5uZXIuaXNSZXN0cmljdGVkV29yZChuYW1lKSkge1xyXG5cdCAgICAgICAgICAgICAgICBvcHRpb25zLnN0cmljdGVkID0gcGFyYW07XHJcblx0ICAgICAgICAgICAgICAgIG9wdGlvbnMubWVzc2FnZSA9IG1lc3NhZ2VzXzEuTWVzc2FnZXMuU3RyaWN0UGFyYW1OYW1lO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9wdGlvbnMucGFyYW1TZXQsIGtleSkpIHtcclxuXHQgICAgICAgICAgICAgICAgb3B0aW9ucy5zdHJpY3RlZCA9IHBhcmFtO1xyXG5cdCAgICAgICAgICAgICAgICBvcHRpb25zLm1lc3NhZ2UgPSBtZXNzYWdlc18xLk1lc3NhZ2VzLlN0cmljdFBhcmFtRHVwZTtcclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICBlbHNlIGlmICghb3B0aW9ucy5maXJzdFJlc3RyaWN0ZWQpIHtcclxuXHQgICAgICAgICAgICBpZiAodGhpcy5zY2FubmVyLmlzUmVzdHJpY3RlZFdvcmQobmFtZSkpIHtcclxuXHQgICAgICAgICAgICAgICAgb3B0aW9ucy5maXJzdFJlc3RyaWN0ZWQgPSBwYXJhbTtcclxuXHQgICAgICAgICAgICAgICAgb3B0aW9ucy5tZXNzYWdlID0gbWVzc2FnZXNfMS5NZXNzYWdlcy5TdHJpY3RQYXJhbU5hbWU7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMuc2Nhbm5lci5pc1N0cmljdE1vZGVSZXNlcnZlZFdvcmQobmFtZSkpIHtcclxuXHQgICAgICAgICAgICAgICAgb3B0aW9ucy5maXJzdFJlc3RyaWN0ZWQgPSBwYXJhbTtcclxuXHQgICAgICAgICAgICAgICAgb3B0aW9ucy5tZXNzYWdlID0gbWVzc2FnZXNfMS5NZXNzYWdlcy5TdHJpY3RSZXNlcnZlZFdvcmQ7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgIGVsc2UgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvcHRpb25zLnBhcmFtU2V0LCBrZXkpKSB7XHJcblx0ICAgICAgICAgICAgICAgIG9wdGlvbnMuc3RyaWN0ZWQgPSBwYXJhbTtcclxuXHQgICAgICAgICAgICAgICAgb3B0aW9ucy5tZXNzYWdlID0gbWVzc2FnZXNfMS5NZXNzYWdlcy5TdHJpY3RQYXJhbUR1cGU7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cclxuXHQgICAgICAgIGlmICh0eXBlb2YgT2JqZWN0LmRlZmluZVByb3BlcnR5ID09PSAnZnVuY3Rpb24nKSB7XHJcblx0ICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9wdGlvbnMucGFyYW1TZXQsIGtleSwgeyB2YWx1ZTogdHJ1ZSwgZW51bWVyYWJsZTogdHJ1ZSwgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9KTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIGVsc2Uge1xyXG5cdCAgICAgICAgICAgIG9wdGlvbnMucGFyYW1TZXRba2V5XSA9IHRydWU7XHJcblx0ICAgICAgICB9XHJcblx0ICAgIH07XHJcblx0ICAgIFBhcnNlci5wcm90b3R5cGUucGFyc2VSZXN0RWxlbWVudCA9IGZ1bmN0aW9uIChwYXJhbXMpIHtcclxuXHQgICAgICAgIHZhciBub2RlID0gdGhpcy5jcmVhdGVOb2RlKCk7XHJcblx0ICAgICAgICB0aGlzLmV4cGVjdCgnLi4uJyk7XHJcblx0ICAgICAgICB2YXIgYXJnID0gdGhpcy5wYXJzZVBhdHRlcm4ocGFyYW1zKTtcclxuXHQgICAgICAgIGlmICh0aGlzLm1hdGNoKCc9JykpIHtcclxuXHQgICAgICAgICAgICB0aGlzLnRocm93RXJyb3IobWVzc2FnZXNfMS5NZXNzYWdlcy5EZWZhdWx0UmVzdFBhcmFtZXRlcik7XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICBpZiAoIXRoaXMubWF0Y2goJyknKSkge1xyXG5cdCAgICAgICAgICAgIHRoaXMudGhyb3dFcnJvcihtZXNzYWdlc18xLk1lc3NhZ2VzLlBhcmFtZXRlckFmdGVyUmVzdFBhcmFtZXRlcik7XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICByZXR1cm4gdGhpcy5maW5hbGl6ZShub2RlLCBuZXcgTm9kZS5SZXN0RWxlbWVudChhcmcpKTtcclxuXHQgICAgfTtcclxuXHQgICAgUGFyc2VyLnByb3RvdHlwZS5wYXJzZUZvcm1hbFBhcmFtZXRlciA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XHJcblx0ICAgICAgICB2YXIgcGFyYW1zID0gW107XHJcblx0ICAgICAgICB2YXIgcGFyYW0gPSB0aGlzLm1hdGNoKCcuLi4nKSA/IHRoaXMucGFyc2VSZXN0RWxlbWVudChwYXJhbXMpIDogdGhpcy5wYXJzZVBhdHRlcm5XaXRoRGVmYXVsdChwYXJhbXMpO1xyXG5cdCAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwYXJhbXMubGVuZ3RoOyBpKyspIHtcclxuXHQgICAgICAgICAgICB0aGlzLnZhbGlkYXRlUGFyYW0ob3B0aW9ucywgcGFyYW1zW2ldLCBwYXJhbXNbaV0udmFsdWUpO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgb3B0aW9ucy5zaW1wbGUgPSBvcHRpb25zLnNpbXBsZSAmJiAocGFyYW0gaW5zdGFuY2VvZiBOb2RlLklkZW50aWZpZXIpO1xyXG5cdCAgICAgICAgb3B0aW9ucy5wYXJhbXMucHVzaChwYXJhbSk7XHJcblx0ICAgIH07XHJcblx0ICAgIFBhcnNlci5wcm90b3R5cGUucGFyc2VGb3JtYWxQYXJhbWV0ZXJzID0gZnVuY3Rpb24gKGZpcnN0UmVzdHJpY3RlZCkge1xyXG5cdCAgICAgICAgdmFyIG9wdGlvbnM7XHJcblx0ICAgICAgICBvcHRpb25zID0ge1xyXG5cdCAgICAgICAgICAgIHNpbXBsZTogdHJ1ZSxcclxuXHQgICAgICAgICAgICBwYXJhbXM6IFtdLFxyXG5cdCAgICAgICAgICAgIGZpcnN0UmVzdHJpY3RlZDogZmlyc3RSZXN0cmljdGVkXHJcblx0ICAgICAgICB9O1xyXG5cdCAgICAgICAgdGhpcy5leHBlY3QoJygnKTtcclxuXHQgICAgICAgIGlmICghdGhpcy5tYXRjaCgnKScpKSB7XHJcblx0ICAgICAgICAgICAgb3B0aW9ucy5wYXJhbVNldCA9IHt9O1xyXG5cdCAgICAgICAgICAgIHdoaWxlICh0aGlzLmxvb2thaGVhZC50eXBlICE9PSAyIC8qIEVPRiAqLykge1xyXG5cdCAgICAgICAgICAgICAgICB0aGlzLnBhcnNlRm9ybWFsUGFyYW1ldGVyKG9wdGlvbnMpO1xyXG5cdCAgICAgICAgICAgICAgICBpZiAodGhpcy5tYXRjaCgnKScpKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuXHQgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICB0aGlzLmV4cGVjdCgnLCcpO1xyXG5cdCAgICAgICAgICAgICAgICBpZiAodGhpcy5tYXRjaCgnKScpKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuXHQgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIHRoaXMuZXhwZWN0KCcpJyk7XHJcblx0ICAgICAgICByZXR1cm4ge1xyXG5cdCAgICAgICAgICAgIHNpbXBsZTogb3B0aW9ucy5zaW1wbGUsXHJcblx0ICAgICAgICAgICAgcGFyYW1zOiBvcHRpb25zLnBhcmFtcyxcclxuXHQgICAgICAgICAgICBzdHJpY3RlZDogb3B0aW9ucy5zdHJpY3RlZCxcclxuXHQgICAgICAgICAgICBmaXJzdFJlc3RyaWN0ZWQ6IG9wdGlvbnMuZmlyc3RSZXN0cmljdGVkLFxyXG5cdCAgICAgICAgICAgIG1lc3NhZ2U6IG9wdGlvbnMubWVzc2FnZVxyXG5cdCAgICAgICAgfTtcclxuXHQgICAgfTtcclxuXHQgICAgUGFyc2VyLnByb3RvdHlwZS5tYXRjaEFzeW5jRnVuY3Rpb24gPSBmdW5jdGlvbiAoKSB7XHJcblx0ICAgICAgICB2YXIgbWF0Y2ggPSB0aGlzLm1hdGNoQ29udGV4dHVhbEtleXdvcmQoJ2FzeW5jJyk7XHJcblx0ICAgICAgICBpZiAobWF0Y2gpIHtcclxuXHQgICAgICAgICAgICB2YXIgc3RhdGUgPSB0aGlzLnNjYW5uZXIuc2F2ZVN0YXRlKCk7XHJcblx0ICAgICAgICAgICAgdGhpcy5zY2FubmVyLnNjYW5Db21tZW50cygpO1xyXG5cdCAgICAgICAgICAgIHZhciBuZXh0ID0gdGhpcy5zY2FubmVyLmxleCgpO1xyXG5cdCAgICAgICAgICAgIHRoaXMuc2Nhbm5lci5yZXN0b3JlU3RhdGUoc3RhdGUpO1xyXG5cdCAgICAgICAgICAgIG1hdGNoID0gKHN0YXRlLmxpbmVOdW1iZXIgPT09IG5leHQubGluZU51bWJlcikgJiYgKG5leHQudHlwZSA9PT0gNCAvKiBLZXl3b3JkICovKSAmJiAobmV4dC52YWx1ZSA9PT0gJ2Z1bmN0aW9uJyk7XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICByZXR1cm4gbWF0Y2g7XHJcblx0ICAgIH07XHJcblx0ICAgIFBhcnNlci5wcm90b3R5cGUucGFyc2VGdW5jdGlvbkRlY2xhcmF0aW9uID0gZnVuY3Rpb24gKGlkZW50aWZpZXJJc09wdGlvbmFsKSB7XHJcblx0ICAgICAgICB2YXIgbm9kZSA9IHRoaXMuY3JlYXRlTm9kZSgpO1xyXG5cdCAgICAgICAgdmFyIGlzQXN5bmMgPSB0aGlzLm1hdGNoQ29udGV4dHVhbEtleXdvcmQoJ2FzeW5jJyk7XHJcblx0ICAgICAgICBpZiAoaXNBc3luYykge1xyXG5cdCAgICAgICAgICAgIHRoaXMubmV4dFRva2VuKCk7XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICB0aGlzLmV4cGVjdEtleXdvcmQoJ2Z1bmN0aW9uJyk7XHJcblx0ICAgICAgICB2YXIgaXNHZW5lcmF0b3IgPSBpc0FzeW5jID8gZmFsc2UgOiB0aGlzLm1hdGNoKCcqJyk7XHJcblx0ICAgICAgICBpZiAoaXNHZW5lcmF0b3IpIHtcclxuXHQgICAgICAgICAgICB0aGlzLm5leHRUb2tlbigpO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgdmFyIG1lc3NhZ2U7XHJcblx0ICAgICAgICB2YXIgaWQgPSBudWxsO1xyXG5cdCAgICAgICAgdmFyIGZpcnN0UmVzdHJpY3RlZCA9IG51bGw7XHJcblx0ICAgICAgICBpZiAoIWlkZW50aWZpZXJJc09wdGlvbmFsIHx8ICF0aGlzLm1hdGNoKCcoJykpIHtcclxuXHQgICAgICAgICAgICB2YXIgdG9rZW4gPSB0aGlzLmxvb2thaGVhZDtcclxuXHQgICAgICAgICAgICBpZCA9IHRoaXMucGFyc2VWYXJpYWJsZUlkZW50aWZpZXIoKTtcclxuXHQgICAgICAgICAgICBpZiAodGhpcy5jb250ZXh0LnN0cmljdCkge1xyXG5cdCAgICAgICAgICAgICAgICBpZiAodGhpcy5zY2FubmVyLmlzUmVzdHJpY3RlZFdvcmQodG9rZW4udmFsdWUpKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICB0aGlzLnRvbGVyYXRlVW5leHBlY3RlZFRva2VuKHRva2VuLCBtZXNzYWdlc18xLk1lc3NhZ2VzLlN0cmljdEZ1bmN0aW9uTmFtZSk7XHJcblx0ICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgZWxzZSB7XHJcblx0ICAgICAgICAgICAgICAgIGlmICh0aGlzLnNjYW5uZXIuaXNSZXN0cmljdGVkV29yZCh0b2tlbi52YWx1ZSkpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgIGZpcnN0UmVzdHJpY3RlZCA9IHRva2VuO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgbWVzc2FnZSA9IG1lc3NhZ2VzXzEuTWVzc2FnZXMuU3RyaWN0RnVuY3Rpb25OYW1lO1xyXG5cdCAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMuc2Nhbm5lci5pc1N0cmljdE1vZGVSZXNlcnZlZFdvcmQodG9rZW4udmFsdWUpKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICBmaXJzdFJlc3RyaWN0ZWQgPSB0b2tlbjtcclxuXHQgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UgPSBtZXNzYWdlc18xLk1lc3NhZ2VzLlN0cmljdFJlc2VydmVkV29yZDtcclxuXHQgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIHZhciBwcmV2aW91c0FsbG93QXdhaXQgPSB0aGlzLmNvbnRleHQuYXdhaXQ7XHJcblx0ICAgICAgICB2YXIgcHJldmlvdXNBbGxvd1lpZWxkID0gdGhpcy5jb250ZXh0LmFsbG93WWllbGQ7XHJcblx0ICAgICAgICB0aGlzLmNvbnRleHQuYXdhaXQgPSBpc0FzeW5jO1xyXG5cdCAgICAgICAgdGhpcy5jb250ZXh0LmFsbG93WWllbGQgPSAhaXNHZW5lcmF0b3I7XHJcblx0ICAgICAgICB2YXIgZm9ybWFsUGFyYW1ldGVycyA9IHRoaXMucGFyc2VGb3JtYWxQYXJhbWV0ZXJzKGZpcnN0UmVzdHJpY3RlZCk7XHJcblx0ICAgICAgICB2YXIgcGFyYW1zID0gZm9ybWFsUGFyYW1ldGVycy5wYXJhbXM7XHJcblx0ICAgICAgICB2YXIgc3RyaWN0ZWQgPSBmb3JtYWxQYXJhbWV0ZXJzLnN0cmljdGVkO1xyXG5cdCAgICAgICAgZmlyc3RSZXN0cmljdGVkID0gZm9ybWFsUGFyYW1ldGVycy5maXJzdFJlc3RyaWN0ZWQ7XHJcblx0ICAgICAgICBpZiAoZm9ybWFsUGFyYW1ldGVycy5tZXNzYWdlKSB7XHJcblx0ICAgICAgICAgICAgbWVzc2FnZSA9IGZvcm1hbFBhcmFtZXRlcnMubWVzc2FnZTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIHZhciBwcmV2aW91c1N0cmljdCA9IHRoaXMuY29udGV4dC5zdHJpY3Q7XHJcblx0ICAgICAgICB2YXIgcHJldmlvdXNBbGxvd1N0cmljdERpcmVjdGl2ZSA9IHRoaXMuY29udGV4dC5hbGxvd1N0cmljdERpcmVjdGl2ZTtcclxuXHQgICAgICAgIHRoaXMuY29udGV4dC5hbGxvd1N0cmljdERpcmVjdGl2ZSA9IGZvcm1hbFBhcmFtZXRlcnMuc2ltcGxlO1xyXG5cdCAgICAgICAgdmFyIGJvZHkgPSB0aGlzLnBhcnNlRnVuY3Rpb25Tb3VyY2VFbGVtZW50cygpO1xyXG5cdCAgICAgICAgaWYgKHRoaXMuY29udGV4dC5zdHJpY3QgJiYgZmlyc3RSZXN0cmljdGVkKSB7XHJcblx0ICAgICAgICAgICAgdGhpcy50aHJvd1VuZXhwZWN0ZWRUb2tlbihmaXJzdFJlc3RyaWN0ZWQsIG1lc3NhZ2UpO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgaWYgKHRoaXMuY29udGV4dC5zdHJpY3QgJiYgc3RyaWN0ZWQpIHtcclxuXHQgICAgICAgICAgICB0aGlzLnRvbGVyYXRlVW5leHBlY3RlZFRva2VuKHN0cmljdGVkLCBtZXNzYWdlKTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIHRoaXMuY29udGV4dC5zdHJpY3QgPSBwcmV2aW91c1N0cmljdDtcclxuXHQgICAgICAgIHRoaXMuY29udGV4dC5hbGxvd1N0cmljdERpcmVjdGl2ZSA9IHByZXZpb3VzQWxsb3dTdHJpY3REaXJlY3RpdmU7XHJcblx0ICAgICAgICB0aGlzLmNvbnRleHQuYXdhaXQgPSBwcmV2aW91c0FsbG93QXdhaXQ7XHJcblx0ICAgICAgICB0aGlzLmNvbnRleHQuYWxsb3dZaWVsZCA9IHByZXZpb3VzQWxsb3dZaWVsZDtcclxuXHQgICAgICAgIHJldHVybiBpc0FzeW5jID8gdGhpcy5maW5hbGl6ZShub2RlLCBuZXcgTm9kZS5Bc3luY0Z1bmN0aW9uRGVjbGFyYXRpb24oaWQsIHBhcmFtcywgYm9keSkpIDpcclxuXHQgICAgICAgICAgICB0aGlzLmZpbmFsaXplKG5vZGUsIG5ldyBOb2RlLkZ1bmN0aW9uRGVjbGFyYXRpb24oaWQsIHBhcmFtcywgYm9keSwgaXNHZW5lcmF0b3IpKTtcclxuXHQgICAgfTtcclxuXHQgICAgUGFyc2VyLnByb3RvdHlwZS5wYXJzZUZ1bmN0aW9uRXhwcmVzc2lvbiA9IGZ1bmN0aW9uICgpIHtcclxuXHQgICAgICAgIHZhciBub2RlID0gdGhpcy5jcmVhdGVOb2RlKCk7XHJcblx0ICAgICAgICB2YXIgaXNBc3luYyA9IHRoaXMubWF0Y2hDb250ZXh0dWFsS2V5d29yZCgnYXN5bmMnKTtcclxuXHQgICAgICAgIGlmIChpc0FzeW5jKSB7XHJcblx0ICAgICAgICAgICAgdGhpcy5uZXh0VG9rZW4oKTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIHRoaXMuZXhwZWN0S2V5d29yZCgnZnVuY3Rpb24nKTtcclxuXHQgICAgICAgIHZhciBpc0dlbmVyYXRvciA9IGlzQXN5bmMgPyBmYWxzZSA6IHRoaXMubWF0Y2goJyonKTtcclxuXHQgICAgICAgIGlmIChpc0dlbmVyYXRvcikge1xyXG5cdCAgICAgICAgICAgIHRoaXMubmV4dFRva2VuKCk7XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICB2YXIgbWVzc2FnZTtcclxuXHQgICAgICAgIHZhciBpZCA9IG51bGw7XHJcblx0ICAgICAgICB2YXIgZmlyc3RSZXN0cmljdGVkO1xyXG5cdCAgICAgICAgdmFyIHByZXZpb3VzQWxsb3dBd2FpdCA9IHRoaXMuY29udGV4dC5hd2FpdDtcclxuXHQgICAgICAgIHZhciBwcmV2aW91c0FsbG93WWllbGQgPSB0aGlzLmNvbnRleHQuYWxsb3dZaWVsZDtcclxuXHQgICAgICAgIHRoaXMuY29udGV4dC5hd2FpdCA9IGlzQXN5bmM7XHJcblx0ICAgICAgICB0aGlzLmNvbnRleHQuYWxsb3dZaWVsZCA9ICFpc0dlbmVyYXRvcjtcclxuXHQgICAgICAgIGlmICghdGhpcy5tYXRjaCgnKCcpKSB7XHJcblx0ICAgICAgICAgICAgdmFyIHRva2VuID0gdGhpcy5sb29rYWhlYWQ7XHJcblx0ICAgICAgICAgICAgaWQgPSAoIXRoaXMuY29udGV4dC5zdHJpY3QgJiYgIWlzR2VuZXJhdG9yICYmIHRoaXMubWF0Y2hLZXl3b3JkKCd5aWVsZCcpKSA/IHRoaXMucGFyc2VJZGVudGlmaWVyTmFtZSgpIDogdGhpcy5wYXJzZVZhcmlhYmxlSWRlbnRpZmllcigpO1xyXG5cdCAgICAgICAgICAgIGlmICh0aGlzLmNvbnRleHQuc3RyaWN0KSB7XHJcblx0ICAgICAgICAgICAgICAgIGlmICh0aGlzLnNjYW5uZXIuaXNSZXN0cmljdGVkV29yZCh0b2tlbi52YWx1ZSkpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgIHRoaXMudG9sZXJhdGVVbmV4cGVjdGVkVG9rZW4odG9rZW4sIG1lc3NhZ2VzXzEuTWVzc2FnZXMuU3RyaWN0RnVuY3Rpb25OYW1lKTtcclxuXHQgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICBlbHNlIHtcclxuXHQgICAgICAgICAgICAgICAgaWYgKHRoaXMuc2Nhbm5lci5pc1Jlc3RyaWN0ZWRXb3JkKHRva2VuLnZhbHVlKSkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgZmlyc3RSZXN0cmljdGVkID0gdG9rZW47XHJcblx0ICAgICAgICAgICAgICAgICAgICBtZXNzYWdlID0gbWVzc2FnZXNfMS5NZXNzYWdlcy5TdHJpY3RGdW5jdGlvbk5hbWU7XHJcblx0ICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5zY2FubmVyLmlzU3RyaWN0TW9kZVJlc2VydmVkV29yZCh0b2tlbi52YWx1ZSkpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgIGZpcnN0UmVzdHJpY3RlZCA9IHRva2VuO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgbWVzc2FnZSA9IG1lc3NhZ2VzXzEuTWVzc2FnZXMuU3RyaWN0UmVzZXJ2ZWRXb3JkO1xyXG5cdCAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgdmFyIGZvcm1hbFBhcmFtZXRlcnMgPSB0aGlzLnBhcnNlRm9ybWFsUGFyYW1ldGVycyhmaXJzdFJlc3RyaWN0ZWQpO1xyXG5cdCAgICAgICAgdmFyIHBhcmFtcyA9IGZvcm1hbFBhcmFtZXRlcnMucGFyYW1zO1xyXG5cdCAgICAgICAgdmFyIHN0cmljdGVkID0gZm9ybWFsUGFyYW1ldGVycy5zdHJpY3RlZDtcclxuXHQgICAgICAgIGZpcnN0UmVzdHJpY3RlZCA9IGZvcm1hbFBhcmFtZXRlcnMuZmlyc3RSZXN0cmljdGVkO1xyXG5cdCAgICAgICAgaWYgKGZvcm1hbFBhcmFtZXRlcnMubWVzc2FnZSkge1xyXG5cdCAgICAgICAgICAgIG1lc3NhZ2UgPSBmb3JtYWxQYXJhbWV0ZXJzLm1lc3NhZ2U7XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICB2YXIgcHJldmlvdXNTdHJpY3QgPSB0aGlzLmNvbnRleHQuc3RyaWN0O1xyXG5cdCAgICAgICAgdmFyIHByZXZpb3VzQWxsb3dTdHJpY3REaXJlY3RpdmUgPSB0aGlzLmNvbnRleHQuYWxsb3dTdHJpY3REaXJlY3RpdmU7XHJcblx0ICAgICAgICB0aGlzLmNvbnRleHQuYWxsb3dTdHJpY3REaXJlY3RpdmUgPSBmb3JtYWxQYXJhbWV0ZXJzLnNpbXBsZTtcclxuXHQgICAgICAgIHZhciBib2R5ID0gdGhpcy5wYXJzZUZ1bmN0aW9uU291cmNlRWxlbWVudHMoKTtcclxuXHQgICAgICAgIGlmICh0aGlzLmNvbnRleHQuc3RyaWN0ICYmIGZpcnN0UmVzdHJpY3RlZCkge1xyXG5cdCAgICAgICAgICAgIHRoaXMudGhyb3dVbmV4cGVjdGVkVG9rZW4oZmlyc3RSZXN0cmljdGVkLCBtZXNzYWdlKTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIGlmICh0aGlzLmNvbnRleHQuc3RyaWN0ICYmIHN0cmljdGVkKSB7XHJcblx0ICAgICAgICAgICAgdGhpcy50b2xlcmF0ZVVuZXhwZWN0ZWRUb2tlbihzdHJpY3RlZCwgbWVzc2FnZSk7XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICB0aGlzLmNvbnRleHQuc3RyaWN0ID0gcHJldmlvdXNTdHJpY3Q7XHJcblx0ICAgICAgICB0aGlzLmNvbnRleHQuYWxsb3dTdHJpY3REaXJlY3RpdmUgPSBwcmV2aW91c0FsbG93U3RyaWN0RGlyZWN0aXZlO1xyXG5cdCAgICAgICAgdGhpcy5jb250ZXh0LmF3YWl0ID0gcHJldmlvdXNBbGxvd0F3YWl0O1xyXG5cdCAgICAgICAgdGhpcy5jb250ZXh0LmFsbG93WWllbGQgPSBwcmV2aW91c0FsbG93WWllbGQ7XHJcblx0ICAgICAgICByZXR1cm4gaXNBc3luYyA/IHRoaXMuZmluYWxpemUobm9kZSwgbmV3IE5vZGUuQXN5bmNGdW5jdGlvbkV4cHJlc3Npb24oaWQsIHBhcmFtcywgYm9keSkpIDpcclxuXHQgICAgICAgICAgICB0aGlzLmZpbmFsaXplKG5vZGUsIG5ldyBOb2RlLkZ1bmN0aW9uRXhwcmVzc2lvbihpZCwgcGFyYW1zLCBib2R5LCBpc0dlbmVyYXRvcikpO1xyXG5cdCAgICB9O1xyXG5cdCAgICAvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1kaXJlY3RpdmUtcHJvbG9ndWVzLWFuZC10aGUtdXNlLXN0cmljdC1kaXJlY3RpdmVcclxuXHQgICAgUGFyc2VyLnByb3RvdHlwZS5wYXJzZURpcmVjdGl2ZSA9IGZ1bmN0aW9uICgpIHtcclxuXHQgICAgICAgIHZhciB0b2tlbiA9IHRoaXMubG9va2FoZWFkO1xyXG5cdCAgICAgICAgdmFyIG5vZGUgPSB0aGlzLmNyZWF0ZU5vZGUoKTtcclxuXHQgICAgICAgIHZhciBleHByID0gdGhpcy5wYXJzZUV4cHJlc3Npb24oKTtcclxuXHQgICAgICAgIHZhciBkaXJlY3RpdmUgPSAoZXhwci50eXBlID09PSBzeW50YXhfMS5TeW50YXguTGl0ZXJhbCkgPyB0aGlzLmdldFRva2VuUmF3KHRva2VuKS5zbGljZSgxLCAtMSkgOiBudWxsO1xyXG5cdCAgICAgICAgdGhpcy5jb25zdW1lU2VtaWNvbG9uKCk7XHJcblx0ICAgICAgICByZXR1cm4gdGhpcy5maW5hbGl6ZShub2RlLCBkaXJlY3RpdmUgPyBuZXcgTm9kZS5EaXJlY3RpdmUoZXhwciwgZGlyZWN0aXZlKSA6IG5ldyBOb2RlLkV4cHJlc3Npb25TdGF0ZW1lbnQoZXhwcikpO1xyXG5cdCAgICB9O1xyXG5cdCAgICBQYXJzZXIucHJvdG90eXBlLnBhcnNlRGlyZWN0aXZlUHJvbG9ndWVzID0gZnVuY3Rpb24gKCkge1xyXG5cdCAgICAgICAgdmFyIGZpcnN0UmVzdHJpY3RlZCA9IG51bGw7XHJcblx0ICAgICAgICB2YXIgYm9keSA9IFtdO1xyXG5cdCAgICAgICAgd2hpbGUgKHRydWUpIHtcclxuXHQgICAgICAgICAgICB2YXIgdG9rZW4gPSB0aGlzLmxvb2thaGVhZDtcclxuXHQgICAgICAgICAgICBpZiAodG9rZW4udHlwZSAhPT0gOCAvKiBTdHJpbmdMaXRlcmFsICovKSB7XHJcblx0ICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICB2YXIgc3RhdGVtZW50ID0gdGhpcy5wYXJzZURpcmVjdGl2ZSgpO1xyXG5cdCAgICAgICAgICAgIGJvZHkucHVzaChzdGF0ZW1lbnQpO1xyXG5cdCAgICAgICAgICAgIHZhciBkaXJlY3RpdmUgPSBzdGF0ZW1lbnQuZGlyZWN0aXZlO1xyXG5cdCAgICAgICAgICAgIGlmICh0eXBlb2YgZGlyZWN0aXZlICE9PSAnc3RyaW5nJykge1xyXG5cdCAgICAgICAgICAgICAgICBicmVhaztcclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgaWYgKGRpcmVjdGl2ZSA9PT0gJ3VzZSBzdHJpY3QnKSB7XHJcblx0ICAgICAgICAgICAgICAgIHRoaXMuY29udGV4dC5zdHJpY3QgPSB0cnVlO1xyXG5cdCAgICAgICAgICAgICAgICBpZiAoZmlyc3RSZXN0cmljdGVkKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICB0aGlzLnRvbGVyYXRlVW5leHBlY3RlZFRva2VuKGZpcnN0UmVzdHJpY3RlZCwgbWVzc2FnZXNfMS5NZXNzYWdlcy5TdHJpY3RPY3RhbExpdGVyYWwpO1xyXG5cdCAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgIGlmICghdGhpcy5jb250ZXh0LmFsbG93U3RyaWN0RGlyZWN0aXZlKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICB0aGlzLnRvbGVyYXRlVW5leHBlY3RlZFRva2VuKHRva2VuLCBtZXNzYWdlc18xLk1lc3NhZ2VzLklsbGVnYWxMYW5ndWFnZU1vZGVEaXJlY3RpdmUpO1xyXG5cdCAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgIGVsc2Uge1xyXG5cdCAgICAgICAgICAgICAgICBpZiAoIWZpcnN0UmVzdHJpY3RlZCAmJiB0b2tlbi5vY3RhbCkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgZmlyc3RSZXN0cmljdGVkID0gdG9rZW47XHJcblx0ICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICByZXR1cm4gYm9keTtcclxuXHQgICAgfTtcclxuXHQgICAgLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtbWV0aG9kLWRlZmluaXRpb25zXHJcblx0ICAgIFBhcnNlci5wcm90b3R5cGUucXVhbGlmaWVkUHJvcGVydHlOYW1lID0gZnVuY3Rpb24gKHRva2VuKSB7XHJcblx0ICAgICAgICBzd2l0Y2ggKHRva2VuLnR5cGUpIHtcclxuXHQgICAgICAgICAgICBjYXNlIDMgLyogSWRlbnRpZmllciAqLzpcclxuXHQgICAgICAgICAgICBjYXNlIDggLyogU3RyaW5nTGl0ZXJhbCAqLzpcclxuXHQgICAgICAgICAgICBjYXNlIDEgLyogQm9vbGVhbkxpdGVyYWwgKi86XHJcblx0ICAgICAgICAgICAgY2FzZSA1IC8qIE51bGxMaXRlcmFsICovOlxyXG5cdCAgICAgICAgICAgIGNhc2UgNiAvKiBOdW1lcmljTGl0ZXJhbCAqLzpcclxuXHQgICAgICAgICAgICBjYXNlIDQgLyogS2V5d29yZCAqLzpcclxuXHQgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcblx0ICAgICAgICAgICAgY2FzZSA3IC8qIFB1bmN0dWF0b3IgKi86XHJcblx0ICAgICAgICAgICAgICAgIHJldHVybiB0b2tlbi52YWx1ZSA9PT0gJ1snO1xyXG5cdCAgICAgICAgICAgIGRlZmF1bHQ6XHJcblx0ICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG5cdCAgICB9O1xyXG5cdCAgICBQYXJzZXIucHJvdG90eXBlLnBhcnNlR2V0dGVyTWV0aG9kID0gZnVuY3Rpb24gKCkge1xyXG5cdCAgICAgICAgdmFyIG5vZGUgPSB0aGlzLmNyZWF0ZU5vZGUoKTtcclxuXHQgICAgICAgIHZhciBpc0dlbmVyYXRvciA9IGZhbHNlO1xyXG5cdCAgICAgICAgdmFyIHByZXZpb3VzQWxsb3dZaWVsZCA9IHRoaXMuY29udGV4dC5hbGxvd1lpZWxkO1xyXG5cdCAgICAgICAgdGhpcy5jb250ZXh0LmFsbG93WWllbGQgPSBmYWxzZTtcclxuXHQgICAgICAgIHZhciBmb3JtYWxQYXJhbWV0ZXJzID0gdGhpcy5wYXJzZUZvcm1hbFBhcmFtZXRlcnMoKTtcclxuXHQgICAgICAgIGlmIChmb3JtYWxQYXJhbWV0ZXJzLnBhcmFtcy5sZW5ndGggPiAwKSB7XHJcblx0ICAgICAgICAgICAgdGhpcy50b2xlcmF0ZUVycm9yKG1lc3NhZ2VzXzEuTWVzc2FnZXMuQmFkR2V0dGVyQXJpdHkpO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgdmFyIG1ldGhvZCA9IHRoaXMucGFyc2VQcm9wZXJ0eU1ldGhvZChmb3JtYWxQYXJhbWV0ZXJzKTtcclxuXHQgICAgICAgIHRoaXMuY29udGV4dC5hbGxvd1lpZWxkID0gcHJldmlvdXNBbGxvd1lpZWxkO1xyXG5cdCAgICAgICAgcmV0dXJuIHRoaXMuZmluYWxpemUobm9kZSwgbmV3IE5vZGUuRnVuY3Rpb25FeHByZXNzaW9uKG51bGwsIGZvcm1hbFBhcmFtZXRlcnMucGFyYW1zLCBtZXRob2QsIGlzR2VuZXJhdG9yKSk7XHJcblx0ICAgIH07XHJcblx0ICAgIFBhcnNlci5wcm90b3R5cGUucGFyc2VTZXR0ZXJNZXRob2QgPSBmdW5jdGlvbiAoKSB7XHJcblx0ICAgICAgICB2YXIgbm9kZSA9IHRoaXMuY3JlYXRlTm9kZSgpO1xyXG5cdCAgICAgICAgdmFyIGlzR2VuZXJhdG9yID0gZmFsc2U7XHJcblx0ICAgICAgICB2YXIgcHJldmlvdXNBbGxvd1lpZWxkID0gdGhpcy5jb250ZXh0LmFsbG93WWllbGQ7XHJcblx0ICAgICAgICB0aGlzLmNvbnRleHQuYWxsb3dZaWVsZCA9IGZhbHNlO1xyXG5cdCAgICAgICAgdmFyIGZvcm1hbFBhcmFtZXRlcnMgPSB0aGlzLnBhcnNlRm9ybWFsUGFyYW1ldGVycygpO1xyXG5cdCAgICAgICAgaWYgKGZvcm1hbFBhcmFtZXRlcnMucGFyYW1zLmxlbmd0aCAhPT0gMSkge1xyXG5cdCAgICAgICAgICAgIHRoaXMudG9sZXJhdGVFcnJvcihtZXNzYWdlc18xLk1lc3NhZ2VzLkJhZFNldHRlckFyaXR5KTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIGVsc2UgaWYgKGZvcm1hbFBhcmFtZXRlcnMucGFyYW1zWzBdIGluc3RhbmNlb2YgTm9kZS5SZXN0RWxlbWVudCkge1xyXG5cdCAgICAgICAgICAgIHRoaXMudG9sZXJhdGVFcnJvcihtZXNzYWdlc18xLk1lc3NhZ2VzLkJhZFNldHRlclJlc3RQYXJhbWV0ZXIpO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgdmFyIG1ldGhvZCA9IHRoaXMucGFyc2VQcm9wZXJ0eU1ldGhvZChmb3JtYWxQYXJhbWV0ZXJzKTtcclxuXHQgICAgICAgIHRoaXMuY29udGV4dC5hbGxvd1lpZWxkID0gcHJldmlvdXNBbGxvd1lpZWxkO1xyXG5cdCAgICAgICAgcmV0dXJuIHRoaXMuZmluYWxpemUobm9kZSwgbmV3IE5vZGUuRnVuY3Rpb25FeHByZXNzaW9uKG51bGwsIGZvcm1hbFBhcmFtZXRlcnMucGFyYW1zLCBtZXRob2QsIGlzR2VuZXJhdG9yKSk7XHJcblx0ICAgIH07XHJcblx0ICAgIFBhcnNlci5wcm90b3R5cGUucGFyc2VHZW5lcmF0b3JNZXRob2QgPSBmdW5jdGlvbiAoKSB7XHJcblx0ICAgICAgICB2YXIgbm9kZSA9IHRoaXMuY3JlYXRlTm9kZSgpO1xyXG5cdCAgICAgICAgdmFyIGlzR2VuZXJhdG9yID0gdHJ1ZTtcclxuXHQgICAgICAgIHZhciBwcmV2aW91c0FsbG93WWllbGQgPSB0aGlzLmNvbnRleHQuYWxsb3dZaWVsZDtcclxuXHQgICAgICAgIHRoaXMuY29udGV4dC5hbGxvd1lpZWxkID0gdHJ1ZTtcclxuXHQgICAgICAgIHZhciBwYXJhbXMgPSB0aGlzLnBhcnNlRm9ybWFsUGFyYW1ldGVycygpO1xyXG5cdCAgICAgICAgdGhpcy5jb250ZXh0LmFsbG93WWllbGQgPSBmYWxzZTtcclxuXHQgICAgICAgIHZhciBtZXRob2QgPSB0aGlzLnBhcnNlUHJvcGVydHlNZXRob2QocGFyYW1zKTtcclxuXHQgICAgICAgIHRoaXMuY29udGV4dC5hbGxvd1lpZWxkID0gcHJldmlvdXNBbGxvd1lpZWxkO1xyXG5cdCAgICAgICAgcmV0dXJuIHRoaXMuZmluYWxpemUobm9kZSwgbmV3IE5vZGUuRnVuY3Rpb25FeHByZXNzaW9uKG51bGwsIHBhcmFtcy5wYXJhbXMsIG1ldGhvZCwgaXNHZW5lcmF0b3IpKTtcclxuXHQgICAgfTtcclxuXHQgICAgLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtZ2VuZXJhdG9yLWZ1bmN0aW9uLWRlZmluaXRpb25zXHJcblx0ICAgIFBhcnNlci5wcm90b3R5cGUuaXNTdGFydE9mRXhwcmVzc2lvbiA9IGZ1bmN0aW9uICgpIHtcclxuXHQgICAgICAgIHZhciBzdGFydCA9IHRydWU7XHJcblx0ICAgICAgICB2YXIgdmFsdWUgPSB0aGlzLmxvb2thaGVhZC52YWx1ZTtcclxuXHQgICAgICAgIHN3aXRjaCAodGhpcy5sb29rYWhlYWQudHlwZSkge1xyXG5cdCAgICAgICAgICAgIGNhc2UgNyAvKiBQdW5jdHVhdG9yICovOlxyXG5cdCAgICAgICAgICAgICAgICBzdGFydCA9ICh2YWx1ZSA9PT0gJ1snKSB8fCAodmFsdWUgPT09ICcoJykgfHwgKHZhbHVlID09PSAneycpIHx8XHJcblx0ICAgICAgICAgICAgICAgICAgICAodmFsdWUgPT09ICcrJykgfHwgKHZhbHVlID09PSAnLScpIHx8XHJcblx0ICAgICAgICAgICAgICAgICAgICAodmFsdWUgPT09ICchJykgfHwgKHZhbHVlID09PSAnficpIHx8XHJcblx0ICAgICAgICAgICAgICAgICAgICAodmFsdWUgPT09ICcrKycpIHx8ICh2YWx1ZSA9PT0gJy0tJykgfHxcclxuXHQgICAgICAgICAgICAgICAgICAgICh2YWx1ZSA9PT0gJy8nKSB8fCAodmFsdWUgPT09ICcvPScpOyAvLyByZWd1bGFyIGV4cHJlc3Npb24gbGl0ZXJhbFxyXG5cdCAgICAgICAgICAgICAgICBicmVhaztcclxuXHQgICAgICAgICAgICBjYXNlIDQgLyogS2V5d29yZCAqLzpcclxuXHQgICAgICAgICAgICAgICAgc3RhcnQgPSAodmFsdWUgPT09ICdjbGFzcycpIHx8ICh2YWx1ZSA9PT0gJ2RlbGV0ZScpIHx8XHJcblx0ICAgICAgICAgICAgICAgICAgICAodmFsdWUgPT09ICdmdW5jdGlvbicpIHx8ICh2YWx1ZSA9PT0gJ2xldCcpIHx8ICh2YWx1ZSA9PT0gJ25ldycpIHx8XHJcblx0ICAgICAgICAgICAgICAgICAgICAodmFsdWUgPT09ICdzdXBlcicpIHx8ICh2YWx1ZSA9PT0gJ3RoaXMnKSB8fCAodmFsdWUgPT09ICd0eXBlb2YnKSB8fFxyXG5cdCAgICAgICAgICAgICAgICAgICAgKHZhbHVlID09PSAndm9pZCcpIHx8ICh2YWx1ZSA9PT0gJ3lpZWxkJyk7XHJcblx0ICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cdCAgICAgICAgICAgIGRlZmF1bHQ6XHJcblx0ICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgcmV0dXJuIHN0YXJ0O1xyXG5cdCAgICB9O1xyXG5cdCAgICBQYXJzZXIucHJvdG90eXBlLnBhcnNlWWllbGRFeHByZXNzaW9uID0gZnVuY3Rpb24gKCkge1xyXG5cdCAgICAgICAgdmFyIG5vZGUgPSB0aGlzLmNyZWF0ZU5vZGUoKTtcclxuXHQgICAgICAgIHRoaXMuZXhwZWN0S2V5d29yZCgneWllbGQnKTtcclxuXHQgICAgICAgIHZhciBhcmd1bWVudCA9IG51bGw7XHJcblx0ICAgICAgICB2YXIgZGVsZWdhdGUgPSBmYWxzZTtcclxuXHQgICAgICAgIGlmICghdGhpcy5oYXNMaW5lVGVybWluYXRvcikge1xyXG5cdCAgICAgICAgICAgIHZhciBwcmV2aW91c0FsbG93WWllbGQgPSB0aGlzLmNvbnRleHQuYWxsb3dZaWVsZDtcclxuXHQgICAgICAgICAgICB0aGlzLmNvbnRleHQuYWxsb3dZaWVsZCA9IGZhbHNlO1xyXG5cdCAgICAgICAgICAgIGRlbGVnYXRlID0gdGhpcy5tYXRjaCgnKicpO1xyXG5cdCAgICAgICAgICAgIGlmIChkZWxlZ2F0ZSkge1xyXG5cdCAgICAgICAgICAgICAgICB0aGlzLm5leHRUb2tlbigpO1xyXG5cdCAgICAgICAgICAgICAgICBhcmd1bWVudCA9IHRoaXMucGFyc2VBc3NpZ25tZW50RXhwcmVzc2lvbigpO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICBlbHNlIGlmICh0aGlzLmlzU3RhcnRPZkV4cHJlc3Npb24oKSkge1xyXG5cdCAgICAgICAgICAgICAgICBhcmd1bWVudCA9IHRoaXMucGFyc2VBc3NpZ25tZW50RXhwcmVzc2lvbigpO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICB0aGlzLmNvbnRleHQuYWxsb3dZaWVsZCA9IHByZXZpb3VzQWxsb3dZaWVsZDtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIHJldHVybiB0aGlzLmZpbmFsaXplKG5vZGUsIG5ldyBOb2RlLllpZWxkRXhwcmVzc2lvbihhcmd1bWVudCwgZGVsZWdhdGUpKTtcclxuXHQgICAgfTtcclxuXHQgICAgLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtY2xhc3MtZGVmaW5pdGlvbnNcclxuXHQgICAgUGFyc2VyLnByb3RvdHlwZS5wYXJzZUNsYXNzRWxlbWVudCA9IGZ1bmN0aW9uIChoYXNDb25zdHJ1Y3Rvcikge1xyXG5cdCAgICAgICAgdmFyIHRva2VuID0gdGhpcy5sb29rYWhlYWQ7XHJcblx0ICAgICAgICB2YXIgbm9kZSA9IHRoaXMuY3JlYXRlTm9kZSgpO1xyXG5cdCAgICAgICAgdmFyIGtpbmQgPSAnJztcclxuXHQgICAgICAgIHZhciBrZXkgPSBudWxsO1xyXG5cdCAgICAgICAgdmFyIHZhbHVlID0gbnVsbDtcclxuXHQgICAgICAgIHZhciBjb21wdXRlZCA9IGZhbHNlO1xyXG5cdCAgICAgICAgdmFyIG1ldGhvZCA9IGZhbHNlO1xyXG5cdCAgICAgICAgdmFyIGlzU3RhdGljID0gZmFsc2U7XHJcblx0ICAgICAgICB2YXIgaXNBc3luYyA9IGZhbHNlO1xyXG5cdCAgICAgICAgaWYgKHRoaXMubWF0Y2goJyonKSkge1xyXG5cdCAgICAgICAgICAgIHRoaXMubmV4dFRva2VuKCk7XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICBlbHNlIHtcclxuXHQgICAgICAgICAgICBjb21wdXRlZCA9IHRoaXMubWF0Y2goJ1snKTtcclxuXHQgICAgICAgICAgICBrZXkgPSB0aGlzLnBhcnNlT2JqZWN0UHJvcGVydHlLZXkoKTtcclxuXHQgICAgICAgICAgICB2YXIgaWQgPSBrZXk7XHJcblx0ICAgICAgICAgICAgaWYgKGlkLm5hbWUgPT09ICdzdGF0aWMnICYmICh0aGlzLnF1YWxpZmllZFByb3BlcnR5TmFtZSh0aGlzLmxvb2thaGVhZCkgfHwgdGhpcy5tYXRjaCgnKicpKSkge1xyXG5cdCAgICAgICAgICAgICAgICB0b2tlbiA9IHRoaXMubG9va2FoZWFkO1xyXG5cdCAgICAgICAgICAgICAgICBpc1N0YXRpYyA9IHRydWU7XHJcblx0ICAgICAgICAgICAgICAgIGNvbXB1dGVkID0gdGhpcy5tYXRjaCgnWycpO1xyXG5cdCAgICAgICAgICAgICAgICBpZiAodGhpcy5tYXRjaCgnKicpKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICB0aGlzLm5leHRUb2tlbigpO1xyXG5cdCAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgIGVsc2Uge1xyXG5cdCAgICAgICAgICAgICAgICAgICAga2V5ID0gdGhpcy5wYXJzZU9iamVjdFByb3BlcnR5S2V5KCk7XHJcblx0ICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgaWYgKCh0b2tlbi50eXBlID09PSAzIC8qIElkZW50aWZpZXIgKi8pICYmICF0aGlzLmhhc0xpbmVUZXJtaW5hdG9yICYmICh0b2tlbi52YWx1ZSA9PT0gJ2FzeW5jJykpIHtcclxuXHQgICAgICAgICAgICAgICAgdmFyIHB1bmN0dWF0b3IgPSB0aGlzLmxvb2thaGVhZC52YWx1ZTtcclxuXHQgICAgICAgICAgICAgICAgaWYgKHB1bmN0dWF0b3IgIT09ICc6JyAmJiBwdW5jdHVhdG9yICE9PSAnKCcgJiYgcHVuY3R1YXRvciAhPT0gJyonKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICBpc0FzeW5jID0gdHJ1ZTtcclxuXHQgICAgICAgICAgICAgICAgICAgIHRva2VuID0gdGhpcy5sb29rYWhlYWQ7XHJcblx0ICAgICAgICAgICAgICAgICAgICBrZXkgPSB0aGlzLnBhcnNlT2JqZWN0UHJvcGVydHlLZXkoKTtcclxuXHQgICAgICAgICAgICAgICAgICAgIGlmICh0b2tlbi50eXBlID09PSAzIC8qIElkZW50aWZpZXIgKi8pIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBpZiAodG9rZW4udmFsdWUgPT09ICdnZXQnIHx8IHRva2VuLnZhbHVlID09PSAnc2V0Jykge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnRvbGVyYXRlVW5leHBlY3RlZFRva2VuKHRva2VuKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAodG9rZW4udmFsdWUgPT09ICdjb25zdHJ1Y3RvcicpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy50b2xlcmF0ZVVuZXhwZWN0ZWRUb2tlbih0b2tlbiwgbWVzc2FnZXNfMS5NZXNzYWdlcy5Db25zdHJ1Y3RvcklzQXN5bmMpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIHZhciBsb29rYWhlYWRQcm9wZXJ0eUtleSA9IHRoaXMucXVhbGlmaWVkUHJvcGVydHlOYW1lKHRoaXMubG9va2FoZWFkKTtcclxuXHQgICAgICAgIGlmICh0b2tlbi50eXBlID09PSAzIC8qIElkZW50aWZpZXIgKi8pIHtcclxuXHQgICAgICAgICAgICBpZiAodG9rZW4udmFsdWUgPT09ICdnZXQnICYmIGxvb2thaGVhZFByb3BlcnR5S2V5KSB7XHJcblx0ICAgICAgICAgICAgICAgIGtpbmQgPSAnZ2V0JztcclxuXHQgICAgICAgICAgICAgICAgY29tcHV0ZWQgPSB0aGlzLm1hdGNoKCdbJyk7XHJcblx0ICAgICAgICAgICAgICAgIGtleSA9IHRoaXMucGFyc2VPYmplY3RQcm9wZXJ0eUtleSgpO1xyXG5cdCAgICAgICAgICAgICAgICB0aGlzLmNvbnRleHQuYWxsb3dZaWVsZCA9IGZhbHNlO1xyXG5cdCAgICAgICAgICAgICAgICB2YWx1ZSA9IHRoaXMucGFyc2VHZXR0ZXJNZXRob2QoKTtcclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgZWxzZSBpZiAodG9rZW4udmFsdWUgPT09ICdzZXQnICYmIGxvb2thaGVhZFByb3BlcnR5S2V5KSB7XHJcblx0ICAgICAgICAgICAgICAgIGtpbmQgPSAnc2V0JztcclxuXHQgICAgICAgICAgICAgICAgY29tcHV0ZWQgPSB0aGlzLm1hdGNoKCdbJyk7XHJcblx0ICAgICAgICAgICAgICAgIGtleSA9IHRoaXMucGFyc2VPYmplY3RQcm9wZXJ0eUtleSgpO1xyXG5cdCAgICAgICAgICAgICAgICB2YWx1ZSA9IHRoaXMucGFyc2VTZXR0ZXJNZXRob2QoKTtcclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICBlbHNlIGlmICh0b2tlbi50eXBlID09PSA3IC8qIFB1bmN0dWF0b3IgKi8gJiYgdG9rZW4udmFsdWUgPT09ICcqJyAmJiBsb29rYWhlYWRQcm9wZXJ0eUtleSkge1xyXG5cdCAgICAgICAgICAgIGtpbmQgPSAnaW5pdCc7XHJcblx0ICAgICAgICAgICAgY29tcHV0ZWQgPSB0aGlzLm1hdGNoKCdbJyk7XHJcblx0ICAgICAgICAgICAga2V5ID0gdGhpcy5wYXJzZU9iamVjdFByb3BlcnR5S2V5KCk7XHJcblx0ICAgICAgICAgICAgdmFsdWUgPSB0aGlzLnBhcnNlR2VuZXJhdG9yTWV0aG9kKCk7XHJcblx0ICAgICAgICAgICAgbWV0aG9kID0gdHJ1ZTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIGlmICgha2luZCAmJiBrZXkgJiYgdGhpcy5tYXRjaCgnKCcpKSB7XHJcblx0ICAgICAgICAgICAga2luZCA9ICdpbml0JztcclxuXHQgICAgICAgICAgICB2YWx1ZSA9IGlzQXN5bmMgPyB0aGlzLnBhcnNlUHJvcGVydHlNZXRob2RBc3luY0Z1bmN0aW9uKCkgOiB0aGlzLnBhcnNlUHJvcGVydHlNZXRob2RGdW5jdGlvbigpO1xyXG5cdCAgICAgICAgICAgIG1ldGhvZCA9IHRydWU7XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICBpZiAoIWtpbmQpIHtcclxuXHQgICAgICAgICAgICB0aGlzLnRocm93VW5leHBlY3RlZFRva2VuKHRoaXMubG9va2FoZWFkKTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIGlmIChraW5kID09PSAnaW5pdCcpIHtcclxuXHQgICAgICAgICAgICBraW5kID0gJ21ldGhvZCc7XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICBpZiAoIWNvbXB1dGVkKSB7XHJcblx0ICAgICAgICAgICAgaWYgKGlzU3RhdGljICYmIHRoaXMuaXNQcm9wZXJ0eUtleShrZXksICdwcm90b3R5cGUnKSkge1xyXG5cdCAgICAgICAgICAgICAgICB0aGlzLnRocm93VW5leHBlY3RlZFRva2VuKHRva2VuLCBtZXNzYWdlc18xLk1lc3NhZ2VzLlN0YXRpY1Byb3RvdHlwZSk7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgIGlmICghaXNTdGF0aWMgJiYgdGhpcy5pc1Byb3BlcnR5S2V5KGtleSwgJ2NvbnN0cnVjdG9yJykpIHtcclxuXHQgICAgICAgICAgICAgICAgaWYgKGtpbmQgIT09ICdtZXRob2QnIHx8ICFtZXRob2QgfHwgKHZhbHVlICYmIHZhbHVlLmdlbmVyYXRvcikpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgIHRoaXMudGhyb3dVbmV4cGVjdGVkVG9rZW4odG9rZW4sIG1lc3NhZ2VzXzEuTWVzc2FnZXMuQ29uc3RydWN0b3JTcGVjaWFsTWV0aG9kKTtcclxuXHQgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICBpZiAoaGFzQ29uc3RydWN0b3IudmFsdWUpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgIHRoaXMudGhyb3dVbmV4cGVjdGVkVG9rZW4odG9rZW4sIG1lc3NhZ2VzXzEuTWVzc2FnZXMuRHVwbGljYXRlQ29uc3RydWN0b3IpO1xyXG5cdCAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgIGVsc2Uge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgaGFzQ29uc3RydWN0b3IudmFsdWUgPSB0cnVlO1xyXG5cdCAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgIGtpbmQgPSAnY29uc3RydWN0b3InO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIHJldHVybiB0aGlzLmZpbmFsaXplKG5vZGUsIG5ldyBOb2RlLk1ldGhvZERlZmluaXRpb24oa2V5LCBjb21wdXRlZCwgdmFsdWUsIGtpbmQsIGlzU3RhdGljKSk7XHJcblx0ICAgIH07XHJcblx0ICAgIFBhcnNlci5wcm90b3R5cGUucGFyc2VDbGFzc0VsZW1lbnRMaXN0ID0gZnVuY3Rpb24gKCkge1xyXG5cdCAgICAgICAgdmFyIGJvZHkgPSBbXTtcclxuXHQgICAgICAgIHZhciBoYXNDb25zdHJ1Y3RvciA9IHsgdmFsdWU6IGZhbHNlIH07XHJcblx0ICAgICAgICB0aGlzLmV4cGVjdCgneycpO1xyXG5cdCAgICAgICAgd2hpbGUgKCF0aGlzLm1hdGNoKCd9JykpIHtcclxuXHQgICAgICAgICAgICBpZiAodGhpcy5tYXRjaCgnOycpKSB7XHJcblx0ICAgICAgICAgICAgICAgIHRoaXMubmV4dFRva2VuKCk7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgIGVsc2Uge1xyXG5cdCAgICAgICAgICAgICAgICBib2R5LnB1c2godGhpcy5wYXJzZUNsYXNzRWxlbWVudChoYXNDb25zdHJ1Y3RvcikpO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIHRoaXMuZXhwZWN0KCd9Jyk7XHJcblx0ICAgICAgICByZXR1cm4gYm9keTtcclxuXHQgICAgfTtcclxuXHQgICAgUGFyc2VyLnByb3RvdHlwZS5wYXJzZUNsYXNzQm9keSA9IGZ1bmN0aW9uICgpIHtcclxuXHQgICAgICAgIHZhciBub2RlID0gdGhpcy5jcmVhdGVOb2RlKCk7XHJcblx0ICAgICAgICB2YXIgZWxlbWVudExpc3QgPSB0aGlzLnBhcnNlQ2xhc3NFbGVtZW50TGlzdCgpO1xyXG5cdCAgICAgICAgcmV0dXJuIHRoaXMuZmluYWxpemUobm9kZSwgbmV3IE5vZGUuQ2xhc3NCb2R5KGVsZW1lbnRMaXN0KSk7XHJcblx0ICAgIH07XHJcblx0ICAgIFBhcnNlci5wcm90b3R5cGUucGFyc2VDbGFzc0RlY2xhcmF0aW9uID0gZnVuY3Rpb24gKGlkZW50aWZpZXJJc09wdGlvbmFsKSB7XHJcblx0ICAgICAgICB2YXIgbm9kZSA9IHRoaXMuY3JlYXRlTm9kZSgpO1xyXG5cdCAgICAgICAgdmFyIHByZXZpb3VzU3RyaWN0ID0gdGhpcy5jb250ZXh0LnN0cmljdDtcclxuXHQgICAgICAgIHRoaXMuY29udGV4dC5zdHJpY3QgPSB0cnVlO1xyXG5cdCAgICAgICAgdGhpcy5leHBlY3RLZXl3b3JkKCdjbGFzcycpO1xyXG5cdCAgICAgICAgdmFyIGlkID0gKGlkZW50aWZpZXJJc09wdGlvbmFsICYmICh0aGlzLmxvb2thaGVhZC50eXBlICE9PSAzIC8qIElkZW50aWZpZXIgKi8pKSA/IG51bGwgOiB0aGlzLnBhcnNlVmFyaWFibGVJZGVudGlmaWVyKCk7XHJcblx0ICAgICAgICB2YXIgc3VwZXJDbGFzcyA9IG51bGw7XHJcblx0ICAgICAgICBpZiAodGhpcy5tYXRjaEtleXdvcmQoJ2V4dGVuZHMnKSkge1xyXG5cdCAgICAgICAgICAgIHRoaXMubmV4dFRva2VuKCk7XHJcblx0ICAgICAgICAgICAgc3VwZXJDbGFzcyA9IHRoaXMuaXNvbGF0ZUNvdmVyR3JhbW1hcih0aGlzLnBhcnNlTGVmdEhhbmRTaWRlRXhwcmVzc2lvbkFsbG93Q2FsbCk7XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICB2YXIgY2xhc3NCb2R5ID0gdGhpcy5wYXJzZUNsYXNzQm9keSgpO1xyXG5cdCAgICAgICAgdGhpcy5jb250ZXh0LnN0cmljdCA9IHByZXZpb3VzU3RyaWN0O1xyXG5cdCAgICAgICAgcmV0dXJuIHRoaXMuZmluYWxpemUobm9kZSwgbmV3IE5vZGUuQ2xhc3NEZWNsYXJhdGlvbihpZCwgc3VwZXJDbGFzcywgY2xhc3NCb2R5KSk7XHJcblx0ICAgIH07XHJcblx0ICAgIFBhcnNlci5wcm90b3R5cGUucGFyc2VDbGFzc0V4cHJlc3Npb24gPSBmdW5jdGlvbiAoKSB7XHJcblx0ICAgICAgICB2YXIgbm9kZSA9IHRoaXMuY3JlYXRlTm9kZSgpO1xyXG5cdCAgICAgICAgdmFyIHByZXZpb3VzU3RyaWN0ID0gdGhpcy5jb250ZXh0LnN0cmljdDtcclxuXHQgICAgICAgIHRoaXMuY29udGV4dC5zdHJpY3QgPSB0cnVlO1xyXG5cdCAgICAgICAgdGhpcy5leHBlY3RLZXl3b3JkKCdjbGFzcycpO1xyXG5cdCAgICAgICAgdmFyIGlkID0gKHRoaXMubG9va2FoZWFkLnR5cGUgPT09IDMgLyogSWRlbnRpZmllciAqLykgPyB0aGlzLnBhcnNlVmFyaWFibGVJZGVudGlmaWVyKCkgOiBudWxsO1xyXG5cdCAgICAgICAgdmFyIHN1cGVyQ2xhc3MgPSBudWxsO1xyXG5cdCAgICAgICAgaWYgKHRoaXMubWF0Y2hLZXl3b3JkKCdleHRlbmRzJykpIHtcclxuXHQgICAgICAgICAgICB0aGlzLm5leHRUb2tlbigpO1xyXG5cdCAgICAgICAgICAgIHN1cGVyQ2xhc3MgPSB0aGlzLmlzb2xhdGVDb3ZlckdyYW1tYXIodGhpcy5wYXJzZUxlZnRIYW5kU2lkZUV4cHJlc3Npb25BbGxvd0NhbGwpO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgdmFyIGNsYXNzQm9keSA9IHRoaXMucGFyc2VDbGFzc0JvZHkoKTtcclxuXHQgICAgICAgIHRoaXMuY29udGV4dC5zdHJpY3QgPSBwcmV2aW91c1N0cmljdDtcclxuXHQgICAgICAgIHJldHVybiB0aGlzLmZpbmFsaXplKG5vZGUsIG5ldyBOb2RlLkNsYXNzRXhwcmVzc2lvbihpZCwgc3VwZXJDbGFzcywgY2xhc3NCb2R5KSk7XHJcblx0ICAgIH07XHJcblx0ICAgIC8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLXNjcmlwdHNcclxuXHQgICAgLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtbW9kdWxlc1xyXG5cdCAgICBQYXJzZXIucHJvdG90eXBlLnBhcnNlTW9kdWxlID0gZnVuY3Rpb24gKCkge1xyXG5cdCAgICAgICAgdGhpcy5jb250ZXh0LnN0cmljdCA9IHRydWU7XHJcblx0ICAgICAgICB0aGlzLmNvbnRleHQuaXNNb2R1bGUgPSB0cnVlO1xyXG5cdCAgICAgICAgdmFyIG5vZGUgPSB0aGlzLmNyZWF0ZU5vZGUoKTtcclxuXHQgICAgICAgIHZhciBib2R5ID0gdGhpcy5wYXJzZURpcmVjdGl2ZVByb2xvZ3VlcygpO1xyXG5cdCAgICAgICAgd2hpbGUgKHRoaXMubG9va2FoZWFkLnR5cGUgIT09IDIgLyogRU9GICovKSB7XHJcblx0ICAgICAgICAgICAgYm9keS5wdXNoKHRoaXMucGFyc2VTdGF0ZW1lbnRMaXN0SXRlbSgpKTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIHJldHVybiB0aGlzLmZpbmFsaXplKG5vZGUsIG5ldyBOb2RlLk1vZHVsZShib2R5KSk7XHJcblx0ICAgIH07XHJcblx0ICAgIFBhcnNlci5wcm90b3R5cGUucGFyc2VTY3JpcHQgPSBmdW5jdGlvbiAoKSB7XHJcblx0ICAgICAgICB2YXIgbm9kZSA9IHRoaXMuY3JlYXRlTm9kZSgpO1xyXG5cdCAgICAgICAgdmFyIGJvZHkgPSB0aGlzLnBhcnNlRGlyZWN0aXZlUHJvbG9ndWVzKCk7XHJcblx0ICAgICAgICB3aGlsZSAodGhpcy5sb29rYWhlYWQudHlwZSAhPT0gMiAvKiBFT0YgKi8pIHtcclxuXHQgICAgICAgICAgICBib2R5LnB1c2godGhpcy5wYXJzZVN0YXRlbWVudExpc3RJdGVtKCkpO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgcmV0dXJuIHRoaXMuZmluYWxpemUobm9kZSwgbmV3IE5vZGUuU2NyaXB0KGJvZHkpKTtcclxuXHQgICAgfTtcclxuXHQgICAgLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtaW1wb3J0c1xyXG5cdCAgICBQYXJzZXIucHJvdG90eXBlLnBhcnNlTW9kdWxlU3BlY2lmaWVyID0gZnVuY3Rpb24gKCkge1xyXG5cdCAgICAgICAgdmFyIG5vZGUgPSB0aGlzLmNyZWF0ZU5vZGUoKTtcclxuXHQgICAgICAgIGlmICh0aGlzLmxvb2thaGVhZC50eXBlICE9PSA4IC8qIFN0cmluZ0xpdGVyYWwgKi8pIHtcclxuXHQgICAgICAgICAgICB0aGlzLnRocm93RXJyb3IobWVzc2FnZXNfMS5NZXNzYWdlcy5JbnZhbGlkTW9kdWxlU3BlY2lmaWVyKTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIHZhciB0b2tlbiA9IHRoaXMubmV4dFRva2VuKCk7XHJcblx0ICAgICAgICB2YXIgcmF3ID0gdGhpcy5nZXRUb2tlblJhdyh0b2tlbik7XHJcblx0ICAgICAgICByZXR1cm4gdGhpcy5maW5hbGl6ZShub2RlLCBuZXcgTm9kZS5MaXRlcmFsKHRva2VuLnZhbHVlLCByYXcpKTtcclxuXHQgICAgfTtcclxuXHQgICAgLy8gaW1wb3J0IHs8Zm9vIGFzIGJhcj59IC4uLjtcclxuXHQgICAgUGFyc2VyLnByb3RvdHlwZS5wYXJzZUltcG9ydFNwZWNpZmllciA9IGZ1bmN0aW9uICgpIHtcclxuXHQgICAgICAgIHZhciBub2RlID0gdGhpcy5jcmVhdGVOb2RlKCk7XHJcblx0ICAgICAgICB2YXIgaW1wb3J0ZWQ7XHJcblx0ICAgICAgICB2YXIgbG9jYWw7XHJcblx0ICAgICAgICBpZiAodGhpcy5sb29rYWhlYWQudHlwZSA9PT0gMyAvKiBJZGVudGlmaWVyICovKSB7XHJcblx0ICAgICAgICAgICAgaW1wb3J0ZWQgPSB0aGlzLnBhcnNlVmFyaWFibGVJZGVudGlmaWVyKCk7XHJcblx0ICAgICAgICAgICAgbG9jYWwgPSBpbXBvcnRlZDtcclxuXHQgICAgICAgICAgICBpZiAodGhpcy5tYXRjaENvbnRleHR1YWxLZXl3b3JkKCdhcycpKSB7XHJcblx0ICAgICAgICAgICAgICAgIHRoaXMubmV4dFRva2VuKCk7XHJcblx0ICAgICAgICAgICAgICAgIGxvY2FsID0gdGhpcy5wYXJzZVZhcmlhYmxlSWRlbnRpZmllcigpO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIGVsc2Uge1xyXG5cdCAgICAgICAgICAgIGltcG9ydGVkID0gdGhpcy5wYXJzZUlkZW50aWZpZXJOYW1lKCk7XHJcblx0ICAgICAgICAgICAgbG9jYWwgPSBpbXBvcnRlZDtcclxuXHQgICAgICAgICAgICBpZiAodGhpcy5tYXRjaENvbnRleHR1YWxLZXl3b3JkKCdhcycpKSB7XHJcblx0ICAgICAgICAgICAgICAgIHRoaXMubmV4dFRva2VuKCk7XHJcblx0ICAgICAgICAgICAgICAgIGxvY2FsID0gdGhpcy5wYXJzZVZhcmlhYmxlSWRlbnRpZmllcigpO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICBlbHNlIHtcclxuXHQgICAgICAgICAgICAgICAgdGhpcy50aHJvd1VuZXhwZWN0ZWRUb2tlbih0aGlzLm5leHRUb2tlbigpKTtcclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICByZXR1cm4gdGhpcy5maW5hbGl6ZShub2RlLCBuZXcgTm9kZS5JbXBvcnRTcGVjaWZpZXIobG9jYWwsIGltcG9ydGVkKSk7XHJcblx0ICAgIH07XHJcblx0ICAgIC8vIHtmb28sIGJhciBhcyBiYXN9XHJcblx0ICAgIFBhcnNlci5wcm90b3R5cGUucGFyc2VOYW1lZEltcG9ydHMgPSBmdW5jdGlvbiAoKSB7XHJcblx0ICAgICAgICB0aGlzLmV4cGVjdCgneycpO1xyXG5cdCAgICAgICAgdmFyIHNwZWNpZmllcnMgPSBbXTtcclxuXHQgICAgICAgIHdoaWxlICghdGhpcy5tYXRjaCgnfScpKSB7XHJcblx0ICAgICAgICAgICAgc3BlY2lmaWVycy5wdXNoKHRoaXMucGFyc2VJbXBvcnRTcGVjaWZpZXIoKSk7XHJcblx0ICAgICAgICAgICAgaWYgKCF0aGlzLm1hdGNoKCd9JykpIHtcclxuXHQgICAgICAgICAgICAgICAgdGhpcy5leHBlY3QoJywnKTtcclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICB0aGlzLmV4cGVjdCgnfScpO1xyXG5cdCAgICAgICAgcmV0dXJuIHNwZWNpZmllcnM7XHJcblx0ICAgIH07XHJcblx0ICAgIC8vIGltcG9ydCA8Zm9vPiAuLi47XHJcblx0ICAgIFBhcnNlci5wcm90b3R5cGUucGFyc2VJbXBvcnREZWZhdWx0U3BlY2lmaWVyID0gZnVuY3Rpb24gKCkge1xyXG5cdCAgICAgICAgdmFyIG5vZGUgPSB0aGlzLmNyZWF0ZU5vZGUoKTtcclxuXHQgICAgICAgIHZhciBsb2NhbCA9IHRoaXMucGFyc2VJZGVudGlmaWVyTmFtZSgpO1xyXG5cdCAgICAgICAgcmV0dXJuIHRoaXMuZmluYWxpemUobm9kZSwgbmV3IE5vZGUuSW1wb3J0RGVmYXVsdFNwZWNpZmllcihsb2NhbCkpO1xyXG5cdCAgICB9O1xyXG5cdCAgICAvLyBpbXBvcnQgPCogYXMgZm9vPiAuLi47XHJcblx0ICAgIFBhcnNlci5wcm90b3R5cGUucGFyc2VJbXBvcnROYW1lc3BhY2VTcGVjaWZpZXIgPSBmdW5jdGlvbiAoKSB7XHJcblx0ICAgICAgICB2YXIgbm9kZSA9IHRoaXMuY3JlYXRlTm9kZSgpO1xyXG5cdCAgICAgICAgdGhpcy5leHBlY3QoJyonKTtcclxuXHQgICAgICAgIGlmICghdGhpcy5tYXRjaENvbnRleHR1YWxLZXl3b3JkKCdhcycpKSB7XHJcblx0ICAgICAgICAgICAgdGhpcy50aHJvd0Vycm9yKG1lc3NhZ2VzXzEuTWVzc2FnZXMuTm9Bc0FmdGVySW1wb3J0TmFtZXNwYWNlKTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIHRoaXMubmV4dFRva2VuKCk7XHJcblx0ICAgICAgICB2YXIgbG9jYWwgPSB0aGlzLnBhcnNlSWRlbnRpZmllck5hbWUoKTtcclxuXHQgICAgICAgIHJldHVybiB0aGlzLmZpbmFsaXplKG5vZGUsIG5ldyBOb2RlLkltcG9ydE5hbWVzcGFjZVNwZWNpZmllcihsb2NhbCkpO1xyXG5cdCAgICB9O1xyXG5cdCAgICBQYXJzZXIucHJvdG90eXBlLnBhcnNlSW1wb3J0RGVjbGFyYXRpb24gPSBmdW5jdGlvbiAoKSB7XHJcblx0ICAgICAgICBpZiAodGhpcy5jb250ZXh0LmluRnVuY3Rpb25Cb2R5KSB7XHJcblx0ICAgICAgICAgICAgdGhpcy50aHJvd0Vycm9yKG1lc3NhZ2VzXzEuTWVzc2FnZXMuSWxsZWdhbEltcG9ydERlY2xhcmF0aW9uKTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIHZhciBub2RlID0gdGhpcy5jcmVhdGVOb2RlKCk7XHJcblx0ICAgICAgICB0aGlzLmV4cGVjdEtleXdvcmQoJ2ltcG9ydCcpO1xyXG5cdCAgICAgICAgdmFyIHNyYztcclxuXHQgICAgICAgIHZhciBzcGVjaWZpZXJzID0gW107XHJcblx0ICAgICAgICBpZiAodGhpcy5sb29rYWhlYWQudHlwZSA9PT0gOCAvKiBTdHJpbmdMaXRlcmFsICovKSB7XHJcblx0ICAgICAgICAgICAgLy8gaW1wb3J0ICdmb28nO1xyXG5cdCAgICAgICAgICAgIHNyYyA9IHRoaXMucGFyc2VNb2R1bGVTcGVjaWZpZXIoKTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIGVsc2Uge1xyXG5cdCAgICAgICAgICAgIGlmICh0aGlzLm1hdGNoKCd7JykpIHtcclxuXHQgICAgICAgICAgICAgICAgLy8gaW1wb3J0IHtiYXJ9XHJcblx0ICAgICAgICAgICAgICAgIHNwZWNpZmllcnMgPSBzcGVjaWZpZXJzLmNvbmNhdCh0aGlzLnBhcnNlTmFtZWRJbXBvcnRzKCkpO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICBlbHNlIGlmICh0aGlzLm1hdGNoKCcqJykpIHtcclxuXHQgICAgICAgICAgICAgICAgLy8gaW1wb3J0ICogYXMgZm9vXHJcblx0ICAgICAgICAgICAgICAgIHNwZWNpZmllcnMucHVzaCh0aGlzLnBhcnNlSW1wb3J0TmFtZXNwYWNlU3BlY2lmaWVyKCkpO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICBlbHNlIGlmICh0aGlzLmlzSWRlbnRpZmllck5hbWUodGhpcy5sb29rYWhlYWQpICYmICF0aGlzLm1hdGNoS2V5d29yZCgnZGVmYXVsdCcpKSB7XHJcblx0ICAgICAgICAgICAgICAgIC8vIGltcG9ydCBmb29cclxuXHQgICAgICAgICAgICAgICAgc3BlY2lmaWVycy5wdXNoKHRoaXMucGFyc2VJbXBvcnREZWZhdWx0U3BlY2lmaWVyKCkpO1xyXG5cdCAgICAgICAgICAgICAgICBpZiAodGhpcy5tYXRjaCgnLCcpKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICB0aGlzLm5leHRUb2tlbigpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMubWF0Y2goJyonKSkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIC8vIGltcG9ydCBmb28sICogYXMgZm9vXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgc3BlY2lmaWVycy5wdXNoKHRoaXMucGFyc2VJbXBvcnROYW1lc3BhY2VTcGVjaWZpZXIoKSk7XHJcblx0ICAgICAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICh0aGlzLm1hdGNoKCd7JykpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAvLyBpbXBvcnQgZm9vLCB7YmFyfVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHNwZWNpZmllcnMgPSBzcGVjaWZpZXJzLmNvbmNhdCh0aGlzLnBhcnNlTmFtZWRJbXBvcnRzKCkpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy50aHJvd1VuZXhwZWN0ZWRUb2tlbih0aGlzLmxvb2thaGVhZCk7XHJcblx0ICAgICAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgZWxzZSB7XHJcblx0ICAgICAgICAgICAgICAgIHRoaXMudGhyb3dVbmV4cGVjdGVkVG9rZW4odGhpcy5uZXh0VG9rZW4oKSk7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgIGlmICghdGhpcy5tYXRjaENvbnRleHR1YWxLZXl3b3JkKCdmcm9tJykpIHtcclxuXHQgICAgICAgICAgICAgICAgdmFyIG1lc3NhZ2UgPSB0aGlzLmxvb2thaGVhZC52YWx1ZSA/IG1lc3NhZ2VzXzEuTWVzc2FnZXMuVW5leHBlY3RlZFRva2VuIDogbWVzc2FnZXNfMS5NZXNzYWdlcy5NaXNzaW5nRnJvbUNsYXVzZTtcclxuXHQgICAgICAgICAgICAgICAgdGhpcy50aHJvd0Vycm9yKG1lc3NhZ2UsIHRoaXMubG9va2FoZWFkLnZhbHVlKTtcclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgdGhpcy5uZXh0VG9rZW4oKTtcclxuXHQgICAgICAgICAgICBzcmMgPSB0aGlzLnBhcnNlTW9kdWxlU3BlY2lmaWVyKCk7XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICB0aGlzLmNvbnN1bWVTZW1pY29sb24oKTtcclxuXHQgICAgICAgIHJldHVybiB0aGlzLmZpbmFsaXplKG5vZGUsIG5ldyBOb2RlLkltcG9ydERlY2xhcmF0aW9uKHNwZWNpZmllcnMsIHNyYykpO1xyXG5cdCAgICB9O1xyXG5cdCAgICAvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1leHBvcnRzXHJcblx0ICAgIFBhcnNlci5wcm90b3R5cGUucGFyc2VFeHBvcnRTcGVjaWZpZXIgPSBmdW5jdGlvbiAoKSB7XHJcblx0ICAgICAgICB2YXIgbm9kZSA9IHRoaXMuY3JlYXRlTm9kZSgpO1xyXG5cdCAgICAgICAgdmFyIGxvY2FsID0gdGhpcy5wYXJzZUlkZW50aWZpZXJOYW1lKCk7XHJcblx0ICAgICAgICB2YXIgZXhwb3J0ZWQgPSBsb2NhbDtcclxuXHQgICAgICAgIGlmICh0aGlzLm1hdGNoQ29udGV4dHVhbEtleXdvcmQoJ2FzJykpIHtcclxuXHQgICAgICAgICAgICB0aGlzLm5leHRUb2tlbigpO1xyXG5cdCAgICAgICAgICAgIGV4cG9ydGVkID0gdGhpcy5wYXJzZUlkZW50aWZpZXJOYW1lKCk7XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICByZXR1cm4gdGhpcy5maW5hbGl6ZShub2RlLCBuZXcgTm9kZS5FeHBvcnRTcGVjaWZpZXIobG9jYWwsIGV4cG9ydGVkKSk7XHJcblx0ICAgIH07XHJcblx0ICAgIFBhcnNlci5wcm90b3R5cGUucGFyc2VFeHBvcnREZWNsYXJhdGlvbiA9IGZ1bmN0aW9uICgpIHtcclxuXHQgICAgICAgIGlmICh0aGlzLmNvbnRleHQuaW5GdW5jdGlvbkJvZHkpIHtcclxuXHQgICAgICAgICAgICB0aGlzLnRocm93RXJyb3IobWVzc2FnZXNfMS5NZXNzYWdlcy5JbGxlZ2FsRXhwb3J0RGVjbGFyYXRpb24pO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgdmFyIG5vZGUgPSB0aGlzLmNyZWF0ZU5vZGUoKTtcclxuXHQgICAgICAgIHRoaXMuZXhwZWN0S2V5d29yZCgnZXhwb3J0Jyk7XHJcblx0ICAgICAgICB2YXIgZXhwb3J0RGVjbGFyYXRpb247XHJcblx0ICAgICAgICBpZiAodGhpcy5tYXRjaEtleXdvcmQoJ2RlZmF1bHQnKSkge1xyXG5cdCAgICAgICAgICAgIC8vIGV4cG9ydCBkZWZhdWx0IC4uLlxyXG5cdCAgICAgICAgICAgIHRoaXMubmV4dFRva2VuKCk7XHJcblx0ICAgICAgICAgICAgaWYgKHRoaXMubWF0Y2hLZXl3b3JkKCdmdW5jdGlvbicpKSB7XHJcblx0ICAgICAgICAgICAgICAgIC8vIGV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGZvbyAoKSB7fVxyXG5cdCAgICAgICAgICAgICAgICAvLyBleHBvcnQgZGVmYXVsdCBmdW5jdGlvbiAoKSB7fVxyXG5cdCAgICAgICAgICAgICAgICB2YXIgZGVjbGFyYXRpb24gPSB0aGlzLnBhcnNlRnVuY3Rpb25EZWNsYXJhdGlvbih0cnVlKTtcclxuXHQgICAgICAgICAgICAgICAgZXhwb3J0RGVjbGFyYXRpb24gPSB0aGlzLmZpbmFsaXplKG5vZGUsIG5ldyBOb2RlLkV4cG9ydERlZmF1bHREZWNsYXJhdGlvbihkZWNsYXJhdGlvbikpO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICBlbHNlIGlmICh0aGlzLm1hdGNoS2V5d29yZCgnY2xhc3MnKSkge1xyXG5cdCAgICAgICAgICAgICAgICAvLyBleHBvcnQgZGVmYXVsdCBjbGFzcyBmb28ge31cclxuXHQgICAgICAgICAgICAgICAgdmFyIGRlY2xhcmF0aW9uID0gdGhpcy5wYXJzZUNsYXNzRGVjbGFyYXRpb24odHJ1ZSk7XHJcblx0ICAgICAgICAgICAgICAgIGV4cG9ydERlY2xhcmF0aW9uID0gdGhpcy5maW5hbGl6ZShub2RlLCBuZXcgTm9kZS5FeHBvcnREZWZhdWx0RGVjbGFyYXRpb24oZGVjbGFyYXRpb24pKTtcclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5tYXRjaENvbnRleHR1YWxLZXl3b3JkKCdhc3luYycpKSB7XHJcblx0ICAgICAgICAgICAgICAgIC8vIGV4cG9ydCBkZWZhdWx0IGFzeW5jIGZ1bmN0aW9uIGYgKCkge31cclxuXHQgICAgICAgICAgICAgICAgLy8gZXhwb3J0IGRlZmF1bHQgYXN5bmMgZnVuY3Rpb24gKCkge31cclxuXHQgICAgICAgICAgICAgICAgLy8gZXhwb3J0IGRlZmF1bHQgYXN5bmMgeCA9PiB4XHJcblx0ICAgICAgICAgICAgICAgIHZhciBkZWNsYXJhdGlvbiA9IHRoaXMubWF0Y2hBc3luY0Z1bmN0aW9uKCkgPyB0aGlzLnBhcnNlRnVuY3Rpb25EZWNsYXJhdGlvbih0cnVlKSA6IHRoaXMucGFyc2VBc3NpZ25tZW50RXhwcmVzc2lvbigpO1xyXG5cdCAgICAgICAgICAgICAgICBleHBvcnREZWNsYXJhdGlvbiA9IHRoaXMuZmluYWxpemUobm9kZSwgbmV3IE5vZGUuRXhwb3J0RGVmYXVsdERlY2xhcmF0aW9uKGRlY2xhcmF0aW9uKSk7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgIGVsc2Uge1xyXG5cdCAgICAgICAgICAgICAgICBpZiAodGhpcy5tYXRjaENvbnRleHR1YWxLZXl3b3JkKCdmcm9tJykpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgIHRoaXMudGhyb3dFcnJvcihtZXNzYWdlc18xLk1lc3NhZ2VzLlVuZXhwZWN0ZWRUb2tlbiwgdGhpcy5sb29rYWhlYWQudmFsdWUpO1xyXG5cdCAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgIC8vIGV4cG9ydCBkZWZhdWx0IHt9O1xyXG5cdCAgICAgICAgICAgICAgICAvLyBleHBvcnQgZGVmYXVsdCBbXTtcclxuXHQgICAgICAgICAgICAgICAgLy8gZXhwb3J0IGRlZmF1bHQgKDEgKyAyKTtcclxuXHQgICAgICAgICAgICAgICAgdmFyIGRlY2xhcmF0aW9uID0gdGhpcy5tYXRjaCgneycpID8gdGhpcy5wYXJzZU9iamVjdEluaXRpYWxpemVyKCkgOlxyXG5cdCAgICAgICAgICAgICAgICAgICAgdGhpcy5tYXRjaCgnWycpID8gdGhpcy5wYXJzZUFycmF5SW5pdGlhbGl6ZXIoKSA6IHRoaXMucGFyc2VBc3NpZ25tZW50RXhwcmVzc2lvbigpO1xyXG5cdCAgICAgICAgICAgICAgICB0aGlzLmNvbnN1bWVTZW1pY29sb24oKTtcclxuXHQgICAgICAgICAgICAgICAgZXhwb3J0RGVjbGFyYXRpb24gPSB0aGlzLmZpbmFsaXplKG5vZGUsIG5ldyBOb2RlLkV4cG9ydERlZmF1bHREZWNsYXJhdGlvbihkZWNsYXJhdGlvbikpO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIGVsc2UgaWYgKHRoaXMubWF0Y2goJyonKSkge1xyXG5cdCAgICAgICAgICAgIC8vIGV4cG9ydCAqIGZyb20gJ2Zvbyc7XHJcblx0ICAgICAgICAgICAgdGhpcy5uZXh0VG9rZW4oKTtcclxuXHQgICAgICAgICAgICBpZiAoIXRoaXMubWF0Y2hDb250ZXh0dWFsS2V5d29yZCgnZnJvbScpKSB7XHJcblx0ICAgICAgICAgICAgICAgIHZhciBtZXNzYWdlID0gdGhpcy5sb29rYWhlYWQudmFsdWUgPyBtZXNzYWdlc18xLk1lc3NhZ2VzLlVuZXhwZWN0ZWRUb2tlbiA6IG1lc3NhZ2VzXzEuTWVzc2FnZXMuTWlzc2luZ0Zyb21DbGF1c2U7XHJcblx0ICAgICAgICAgICAgICAgIHRoaXMudGhyb3dFcnJvcihtZXNzYWdlLCB0aGlzLmxvb2thaGVhZC52YWx1ZSk7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgIHRoaXMubmV4dFRva2VuKCk7XHJcblx0ICAgICAgICAgICAgdmFyIHNyYyA9IHRoaXMucGFyc2VNb2R1bGVTcGVjaWZpZXIoKTtcclxuXHQgICAgICAgICAgICB0aGlzLmNvbnN1bWVTZW1pY29sb24oKTtcclxuXHQgICAgICAgICAgICBleHBvcnREZWNsYXJhdGlvbiA9IHRoaXMuZmluYWxpemUobm9kZSwgbmV3IE5vZGUuRXhwb3J0QWxsRGVjbGFyYXRpb24oc3JjKSk7XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICBlbHNlIGlmICh0aGlzLmxvb2thaGVhZC50eXBlID09PSA0IC8qIEtleXdvcmQgKi8pIHtcclxuXHQgICAgICAgICAgICAvLyBleHBvcnQgdmFyIGYgPSAxO1xyXG5cdCAgICAgICAgICAgIHZhciBkZWNsYXJhdGlvbiA9IHZvaWQgMDtcclxuXHQgICAgICAgICAgICBzd2l0Y2ggKHRoaXMubG9va2FoZWFkLnZhbHVlKSB7XHJcblx0ICAgICAgICAgICAgICAgIGNhc2UgJ2xldCc6XHJcblx0ICAgICAgICAgICAgICAgIGNhc2UgJ2NvbnN0JzpcclxuXHQgICAgICAgICAgICAgICAgICAgIGRlY2xhcmF0aW9uID0gdGhpcy5wYXJzZUxleGljYWxEZWNsYXJhdGlvbih7IGluRm9yOiBmYWxzZSB9KTtcclxuXHQgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cdCAgICAgICAgICAgICAgICBjYXNlICd2YXInOlxyXG5cdCAgICAgICAgICAgICAgICBjYXNlICdjbGFzcyc6XHJcblx0ICAgICAgICAgICAgICAgIGNhc2UgJ2Z1bmN0aW9uJzpcclxuXHQgICAgICAgICAgICAgICAgICAgIGRlY2xhcmF0aW9uID0gdGhpcy5wYXJzZVN0YXRlbWVudExpc3RJdGVtKCk7XHJcblx0ICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuXHQgICAgICAgICAgICAgICAgZGVmYXVsdDpcclxuXHQgICAgICAgICAgICAgICAgICAgIHRoaXMudGhyb3dVbmV4cGVjdGVkVG9rZW4odGhpcy5sb29rYWhlYWQpO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICBleHBvcnREZWNsYXJhdGlvbiA9IHRoaXMuZmluYWxpemUobm9kZSwgbmV3IE5vZGUuRXhwb3J0TmFtZWREZWNsYXJhdGlvbihkZWNsYXJhdGlvbiwgW10sIG51bGwpKTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIGVsc2UgaWYgKHRoaXMubWF0Y2hBc3luY0Z1bmN0aW9uKCkpIHtcclxuXHQgICAgICAgICAgICB2YXIgZGVjbGFyYXRpb24gPSB0aGlzLnBhcnNlRnVuY3Rpb25EZWNsYXJhdGlvbigpO1xyXG5cdCAgICAgICAgICAgIGV4cG9ydERlY2xhcmF0aW9uID0gdGhpcy5maW5hbGl6ZShub2RlLCBuZXcgTm9kZS5FeHBvcnROYW1lZERlY2xhcmF0aW9uKGRlY2xhcmF0aW9uLCBbXSwgbnVsbCkpO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgZWxzZSB7XHJcblx0ICAgICAgICAgICAgdmFyIHNwZWNpZmllcnMgPSBbXTtcclxuXHQgICAgICAgICAgICB2YXIgc291cmNlID0gbnVsbDtcclxuXHQgICAgICAgICAgICB2YXIgaXNFeHBvcnRGcm9tSWRlbnRpZmllciA9IGZhbHNlO1xyXG5cdCAgICAgICAgICAgIHRoaXMuZXhwZWN0KCd7Jyk7XHJcblx0ICAgICAgICAgICAgd2hpbGUgKCF0aGlzLm1hdGNoKCd9JykpIHtcclxuXHQgICAgICAgICAgICAgICAgaXNFeHBvcnRGcm9tSWRlbnRpZmllciA9IGlzRXhwb3J0RnJvbUlkZW50aWZpZXIgfHwgdGhpcy5tYXRjaEtleXdvcmQoJ2RlZmF1bHQnKTtcclxuXHQgICAgICAgICAgICAgICAgc3BlY2lmaWVycy5wdXNoKHRoaXMucGFyc2VFeHBvcnRTcGVjaWZpZXIoKSk7XHJcblx0ICAgICAgICAgICAgICAgIGlmICghdGhpcy5tYXRjaCgnfScpKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICB0aGlzLmV4cGVjdCgnLCcpO1xyXG5cdCAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgIHRoaXMuZXhwZWN0KCd9Jyk7XHJcblx0ICAgICAgICAgICAgaWYgKHRoaXMubWF0Y2hDb250ZXh0dWFsS2V5d29yZCgnZnJvbScpKSB7XHJcblx0ICAgICAgICAgICAgICAgIC8vIGV4cG9ydCB7ZGVmYXVsdH0gZnJvbSAnZm9vJztcclxuXHQgICAgICAgICAgICAgICAgLy8gZXhwb3J0IHtmb299IGZyb20gJ2Zvbyc7XHJcblx0ICAgICAgICAgICAgICAgIHRoaXMubmV4dFRva2VuKCk7XHJcblx0ICAgICAgICAgICAgICAgIHNvdXJjZSA9IHRoaXMucGFyc2VNb2R1bGVTcGVjaWZpZXIoKTtcclxuXHQgICAgICAgICAgICAgICAgdGhpcy5jb25zdW1lU2VtaWNvbG9uKCk7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgIGVsc2UgaWYgKGlzRXhwb3J0RnJvbUlkZW50aWZpZXIpIHtcclxuXHQgICAgICAgICAgICAgICAgLy8gZXhwb3J0IHtkZWZhdWx0fTsgLy8gbWlzc2luZyBmcm9tQ2xhdXNlXHJcblx0ICAgICAgICAgICAgICAgIHZhciBtZXNzYWdlID0gdGhpcy5sb29rYWhlYWQudmFsdWUgPyBtZXNzYWdlc18xLk1lc3NhZ2VzLlVuZXhwZWN0ZWRUb2tlbiA6IG1lc3NhZ2VzXzEuTWVzc2FnZXMuTWlzc2luZ0Zyb21DbGF1c2U7XHJcblx0ICAgICAgICAgICAgICAgIHRoaXMudGhyb3dFcnJvcihtZXNzYWdlLCB0aGlzLmxvb2thaGVhZC52YWx1ZSk7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgIGVsc2Uge1xyXG5cdCAgICAgICAgICAgICAgICAvLyBleHBvcnQge2Zvb307XHJcblx0ICAgICAgICAgICAgICAgIHRoaXMuY29uc3VtZVNlbWljb2xvbigpO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICBleHBvcnREZWNsYXJhdGlvbiA9IHRoaXMuZmluYWxpemUobm9kZSwgbmV3IE5vZGUuRXhwb3J0TmFtZWREZWNsYXJhdGlvbihudWxsLCBzcGVjaWZpZXJzLCBzb3VyY2UpKTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIHJldHVybiBleHBvcnREZWNsYXJhdGlvbjtcclxuXHQgICAgfTtcclxuXHQgICAgcmV0dXJuIFBhcnNlcjtcclxuXHR9KCkpO1xyXG5cdGV4cG9ydHMuUGFyc2VyID0gUGFyc2VyO1xyXG5cblxuLyoqKi8gfSxcbi8qIDkgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG5cdFwidXNlIHN0cmljdFwiO1xyXG5cdC8vIEVuc3VyZSB0aGUgY29uZGl0aW9uIGlzIHRydWUsIG90aGVyd2lzZSB0aHJvdyBhbiBlcnJvci5cclxuXHQvLyBUaGlzIGlzIG9ubHkgdG8gaGF2ZSBhIGJldHRlciBjb250cmFjdCBzZW1hbnRpYywgaS5lLiBhbm90aGVyIHNhZmV0eSBuZXRcclxuXHQvLyB0byBjYXRjaCBhIGxvZ2ljIGVycm9yLiBUaGUgY29uZGl0aW9uIHNoYWxsIGJlIGZ1bGZpbGxlZCBpbiBub3JtYWwgY2FzZS5cclxuXHQvLyBEbyBOT1QgdXNlIHRoaXMgdG8gZW5mb3JjZSBhIGNlcnRhaW4gY29uZGl0aW9uIG9uIGFueSB1c2VyIGlucHV0LlxyXG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuXHRmdW5jdGlvbiBhc3NlcnQoY29uZGl0aW9uLCBtZXNzYWdlKSB7XHJcblx0ICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xyXG5cdCAgICBpZiAoIWNvbmRpdGlvbikge1xyXG5cdCAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdBU1NFUlQ6ICcgKyBtZXNzYWdlKTtcclxuXHQgICAgfVxyXG5cdH1cclxuXHRleHBvcnRzLmFzc2VydCA9IGFzc2VydDtcclxuXG5cbi8qKiovIH0sXG4vKiAxMCAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cblx0XCJ1c2Ugc3RyaWN0XCI7XHJcblx0LyogdHNsaW50OmRpc2FibGU6bWF4LWNsYXNzZXMtcGVyLWZpbGUgKi9cclxuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcblx0dmFyIEVycm9ySGFuZGxlciA9IChmdW5jdGlvbiAoKSB7XHJcblx0ICAgIGZ1bmN0aW9uIEVycm9ySGFuZGxlcigpIHtcclxuXHQgICAgICAgIHRoaXMuZXJyb3JzID0gW107XHJcblx0ICAgICAgICB0aGlzLnRvbGVyYW50ID0gZmFsc2U7XHJcblx0ICAgIH1cclxuXHQgICAgRXJyb3JIYW5kbGVyLnByb3RvdHlwZS5yZWNvcmRFcnJvciA9IGZ1bmN0aW9uIChlcnJvcikge1xyXG5cdCAgICAgICAgdGhpcy5lcnJvcnMucHVzaChlcnJvcik7XHJcblx0ICAgIH07XHJcblx0ICAgIEVycm9ySGFuZGxlci5wcm90b3R5cGUudG9sZXJhdGUgPSBmdW5jdGlvbiAoZXJyb3IpIHtcclxuXHQgICAgICAgIGlmICh0aGlzLnRvbGVyYW50KSB7XHJcblx0ICAgICAgICAgICAgdGhpcy5yZWNvcmRFcnJvcihlcnJvcik7XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICBlbHNlIHtcclxuXHQgICAgICAgICAgICB0aHJvdyBlcnJvcjtcclxuXHQgICAgICAgIH1cclxuXHQgICAgfTtcclxuXHQgICAgRXJyb3JIYW5kbGVyLnByb3RvdHlwZS5jb25zdHJ1Y3RFcnJvciA9IGZ1bmN0aW9uIChtc2csIGNvbHVtbikge1xyXG5cdCAgICAgICAgdmFyIGVycm9yID0gbmV3IEVycm9yKG1zZyk7XHJcblx0ICAgICAgICB0cnkge1xyXG5cdCAgICAgICAgICAgIHRocm93IGVycm9yO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgY2F0Y2ggKGJhc2UpIHtcclxuXHQgICAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xyXG5cdCAgICAgICAgICAgIGlmIChPYmplY3QuY3JlYXRlICYmIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSkge1xyXG5cdCAgICAgICAgICAgICAgICBlcnJvciA9IE9iamVjdC5jcmVhdGUoYmFzZSk7XHJcblx0ICAgICAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlcnJvciwgJ2NvbHVtbicsIHsgdmFsdWU6IGNvbHVtbiB9KTtcclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xyXG5cdCAgICAgICAgcmV0dXJuIGVycm9yO1xyXG5cdCAgICB9O1xyXG5cdCAgICBFcnJvckhhbmRsZXIucHJvdG90eXBlLmNyZWF0ZUVycm9yID0gZnVuY3Rpb24gKGluZGV4LCBsaW5lLCBjb2wsIGRlc2NyaXB0aW9uKSB7XHJcblx0ICAgICAgICB2YXIgbXNnID0gJ0xpbmUgJyArIGxpbmUgKyAnOiAnICsgZGVzY3JpcHRpb247XHJcblx0ICAgICAgICB2YXIgZXJyb3IgPSB0aGlzLmNvbnN0cnVjdEVycm9yKG1zZywgY29sKTtcclxuXHQgICAgICAgIGVycm9yLmluZGV4ID0gaW5kZXg7XHJcblx0ICAgICAgICBlcnJvci5saW5lTnVtYmVyID0gbGluZTtcclxuXHQgICAgICAgIGVycm9yLmRlc2NyaXB0aW9uID0gZGVzY3JpcHRpb247XHJcblx0ICAgICAgICByZXR1cm4gZXJyb3I7XHJcblx0ICAgIH07XHJcblx0ICAgIEVycm9ySGFuZGxlci5wcm90b3R5cGUudGhyb3dFcnJvciA9IGZ1bmN0aW9uIChpbmRleCwgbGluZSwgY29sLCBkZXNjcmlwdGlvbikge1xyXG5cdCAgICAgICAgdGhyb3cgdGhpcy5jcmVhdGVFcnJvcihpbmRleCwgbGluZSwgY29sLCBkZXNjcmlwdGlvbik7XHJcblx0ICAgIH07XHJcblx0ICAgIEVycm9ySGFuZGxlci5wcm90b3R5cGUudG9sZXJhdGVFcnJvciA9IGZ1bmN0aW9uIChpbmRleCwgbGluZSwgY29sLCBkZXNjcmlwdGlvbikge1xyXG5cdCAgICAgICAgdmFyIGVycm9yID0gdGhpcy5jcmVhdGVFcnJvcihpbmRleCwgbGluZSwgY29sLCBkZXNjcmlwdGlvbik7XHJcblx0ICAgICAgICBpZiAodGhpcy50b2xlcmFudCkge1xyXG5cdCAgICAgICAgICAgIHRoaXMucmVjb3JkRXJyb3IoZXJyb3IpO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgZWxzZSB7XHJcblx0ICAgICAgICAgICAgdGhyb3cgZXJyb3I7XHJcblx0ICAgICAgICB9XHJcblx0ICAgIH07XHJcblx0ICAgIHJldHVybiBFcnJvckhhbmRsZXI7XHJcblx0fSgpKTtcclxuXHRleHBvcnRzLkVycm9ySGFuZGxlciA9IEVycm9ySGFuZGxlcjtcclxuXG5cbi8qKiovIH0sXG4vKiAxMSAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cblx0XCJ1c2Ugc3RyaWN0XCI7XHJcblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG5cdC8vIEVycm9yIG1lc3NhZ2VzIHNob3VsZCBiZSBpZGVudGljYWwgdG8gVjguXHJcblx0ZXhwb3J0cy5NZXNzYWdlcyA9IHtcclxuXHQgICAgQmFkR2V0dGVyQXJpdHk6ICdHZXR0ZXIgbXVzdCBub3QgaGF2ZSBhbnkgZm9ybWFsIHBhcmFtZXRlcnMnLFxyXG5cdCAgICBCYWRTZXR0ZXJBcml0eTogJ1NldHRlciBtdXN0IGhhdmUgZXhhY3RseSBvbmUgZm9ybWFsIHBhcmFtZXRlcicsXHJcblx0ICAgIEJhZFNldHRlclJlc3RQYXJhbWV0ZXI6ICdTZXR0ZXIgZnVuY3Rpb24gYXJndW1lbnQgbXVzdCBub3QgYmUgYSByZXN0IHBhcmFtZXRlcicsXHJcblx0ICAgIENvbnN0cnVjdG9ySXNBc3luYzogJ0NsYXNzIGNvbnN0cnVjdG9yIG1heSBub3QgYmUgYW4gYXN5bmMgbWV0aG9kJyxcclxuXHQgICAgQ29uc3RydWN0b3JTcGVjaWFsTWV0aG9kOiAnQ2xhc3MgY29uc3RydWN0b3IgbWF5IG5vdCBiZSBhbiBhY2Nlc3NvcicsXHJcblx0ICAgIERlY2xhcmF0aW9uTWlzc2luZ0luaXRpYWxpemVyOiAnTWlzc2luZyBpbml0aWFsaXplciBpbiAlMCBkZWNsYXJhdGlvbicsXHJcblx0ICAgIERlZmF1bHRSZXN0UGFyYW1ldGVyOiAnVW5leHBlY3RlZCB0b2tlbiA9JyxcclxuXHQgICAgRHVwbGljYXRlQmluZGluZzogJ0R1cGxpY2F0ZSBiaW5kaW5nICUwJyxcclxuXHQgICAgRHVwbGljYXRlQ29uc3RydWN0b3I6ICdBIGNsYXNzIG1heSBvbmx5IGhhdmUgb25lIGNvbnN0cnVjdG9yJyxcclxuXHQgICAgRHVwbGljYXRlUHJvdG9Qcm9wZXJ0eTogJ0R1cGxpY2F0ZSBfX3Byb3RvX18gZmllbGRzIGFyZSBub3QgYWxsb3dlZCBpbiBvYmplY3QgbGl0ZXJhbHMnLFxyXG5cdCAgICBGb3JJbk9mTG9vcEluaXRpYWxpemVyOiAnJTAgbG9vcCB2YXJpYWJsZSBkZWNsYXJhdGlvbiBtYXkgbm90IGhhdmUgYW4gaW5pdGlhbGl6ZXInLFxyXG5cdCAgICBHZW5lcmF0b3JJbkxlZ2FjeUNvbnRleHQ6ICdHZW5lcmF0b3IgZGVjbGFyYXRpb25zIGFyZSBub3QgYWxsb3dlZCBpbiBsZWdhY3kgY29udGV4dHMnLFxyXG5cdCAgICBJbGxlZ2FsQnJlYWs6ICdJbGxlZ2FsIGJyZWFrIHN0YXRlbWVudCcsXHJcblx0ICAgIElsbGVnYWxDb250aW51ZTogJ0lsbGVnYWwgY29udGludWUgc3RhdGVtZW50JyxcclxuXHQgICAgSWxsZWdhbEV4cG9ydERlY2xhcmF0aW9uOiAnVW5leHBlY3RlZCB0b2tlbicsXHJcblx0ICAgIElsbGVnYWxJbXBvcnREZWNsYXJhdGlvbjogJ1VuZXhwZWN0ZWQgdG9rZW4nLFxyXG5cdCAgICBJbGxlZ2FsTGFuZ3VhZ2VNb2RlRGlyZWN0aXZlOiAnSWxsZWdhbCBcXCd1c2Ugc3RyaWN0XFwnIGRpcmVjdGl2ZSBpbiBmdW5jdGlvbiB3aXRoIG5vbi1zaW1wbGUgcGFyYW1ldGVyIGxpc3QnLFxyXG5cdCAgICBJbGxlZ2FsUmV0dXJuOiAnSWxsZWdhbCByZXR1cm4gc3RhdGVtZW50JyxcclxuXHQgICAgSW52YWxpZEVzY2FwZWRSZXNlcnZlZFdvcmQ6ICdLZXl3b3JkIG11c3Qgbm90IGNvbnRhaW4gZXNjYXBlZCBjaGFyYWN0ZXJzJyxcclxuXHQgICAgSW52YWxpZEhleEVzY2FwZVNlcXVlbmNlOiAnSW52YWxpZCBoZXhhZGVjaW1hbCBlc2NhcGUgc2VxdWVuY2UnLFxyXG5cdCAgICBJbnZhbGlkTEhTSW5Bc3NpZ25tZW50OiAnSW52YWxpZCBsZWZ0LWhhbmQgc2lkZSBpbiBhc3NpZ25tZW50JyxcclxuXHQgICAgSW52YWxpZExIU0luRm9ySW46ICdJbnZhbGlkIGxlZnQtaGFuZCBzaWRlIGluIGZvci1pbicsXHJcblx0ICAgIEludmFsaWRMSFNJbkZvckxvb3A6ICdJbnZhbGlkIGxlZnQtaGFuZCBzaWRlIGluIGZvci1sb29wJyxcclxuXHQgICAgSW52YWxpZE1vZHVsZVNwZWNpZmllcjogJ1VuZXhwZWN0ZWQgdG9rZW4nLFxyXG5cdCAgICBJbnZhbGlkUmVnRXhwOiAnSW52YWxpZCByZWd1bGFyIGV4cHJlc3Npb24nLFxyXG5cdCAgICBMZXRJbkxleGljYWxCaW5kaW5nOiAnbGV0IGlzIGRpc2FsbG93ZWQgYXMgYSBsZXhpY2FsbHkgYm91bmQgbmFtZScsXHJcblx0ICAgIE1pc3NpbmdGcm9tQ2xhdXNlOiAnVW5leHBlY3RlZCB0b2tlbicsXHJcblx0ICAgIE11bHRpcGxlRGVmYXVsdHNJblN3aXRjaDogJ01vcmUgdGhhbiBvbmUgZGVmYXVsdCBjbGF1c2UgaW4gc3dpdGNoIHN0YXRlbWVudCcsXHJcblx0ICAgIE5ld2xpbmVBZnRlclRocm93OiAnSWxsZWdhbCBuZXdsaW5lIGFmdGVyIHRocm93JyxcclxuXHQgICAgTm9Bc0FmdGVySW1wb3J0TmFtZXNwYWNlOiAnVW5leHBlY3RlZCB0b2tlbicsXHJcblx0ICAgIE5vQ2F0Y2hPckZpbmFsbHk6ICdNaXNzaW5nIGNhdGNoIG9yIGZpbmFsbHkgYWZ0ZXIgdHJ5JyxcclxuXHQgICAgUGFyYW1ldGVyQWZ0ZXJSZXN0UGFyYW1ldGVyOiAnUmVzdCBwYXJhbWV0ZXIgbXVzdCBiZSBsYXN0IGZvcm1hbCBwYXJhbWV0ZXInLFxyXG5cdCAgICBSZWRlY2xhcmF0aW9uOiAnJTAgXFwnJTFcXCcgaGFzIGFscmVhZHkgYmVlbiBkZWNsYXJlZCcsXHJcblx0ICAgIFN0YXRpY1Byb3RvdHlwZTogJ0NsYXNzZXMgbWF5IG5vdCBoYXZlIHN0YXRpYyBwcm9wZXJ0eSBuYW1lZCBwcm90b3R5cGUnLFxyXG5cdCAgICBTdHJpY3RDYXRjaFZhcmlhYmxlOiAnQ2F0Y2ggdmFyaWFibGUgbWF5IG5vdCBiZSBldmFsIG9yIGFyZ3VtZW50cyBpbiBzdHJpY3QgbW9kZScsXHJcblx0ICAgIFN0cmljdERlbGV0ZTogJ0RlbGV0ZSBvZiBhbiB1bnF1YWxpZmllZCBpZGVudGlmaWVyIGluIHN0cmljdCBtb2RlLicsXHJcblx0ICAgIFN0cmljdEZ1bmN0aW9uOiAnSW4gc3RyaWN0IG1vZGUgY29kZSwgZnVuY3Rpb25zIGNhbiBvbmx5IGJlIGRlY2xhcmVkIGF0IHRvcCBsZXZlbCBvciBpbnNpZGUgYSBibG9jaycsXHJcblx0ICAgIFN0cmljdEZ1bmN0aW9uTmFtZTogJ0Z1bmN0aW9uIG5hbWUgbWF5IG5vdCBiZSBldmFsIG9yIGFyZ3VtZW50cyBpbiBzdHJpY3QgbW9kZScsXHJcblx0ICAgIFN0cmljdExIU0Fzc2lnbm1lbnQ6ICdBc3NpZ25tZW50IHRvIGV2YWwgb3IgYXJndW1lbnRzIGlzIG5vdCBhbGxvd2VkIGluIHN0cmljdCBtb2RlJyxcclxuXHQgICAgU3RyaWN0TEhTUG9zdGZpeDogJ1Bvc3RmaXggaW5jcmVtZW50L2RlY3JlbWVudCBtYXkgbm90IGhhdmUgZXZhbCBvciBhcmd1bWVudHMgb3BlcmFuZCBpbiBzdHJpY3QgbW9kZScsXHJcblx0ICAgIFN0cmljdExIU1ByZWZpeDogJ1ByZWZpeCBpbmNyZW1lbnQvZGVjcmVtZW50IG1heSBub3QgaGF2ZSBldmFsIG9yIGFyZ3VtZW50cyBvcGVyYW5kIGluIHN0cmljdCBtb2RlJyxcclxuXHQgICAgU3RyaWN0TW9kZVdpdGg6ICdTdHJpY3QgbW9kZSBjb2RlIG1heSBub3QgaW5jbHVkZSBhIHdpdGggc3RhdGVtZW50JyxcclxuXHQgICAgU3RyaWN0T2N0YWxMaXRlcmFsOiAnT2N0YWwgbGl0ZXJhbHMgYXJlIG5vdCBhbGxvd2VkIGluIHN0cmljdCBtb2RlLicsXHJcblx0ICAgIFN0cmljdFBhcmFtRHVwZTogJ1N0cmljdCBtb2RlIGZ1bmN0aW9uIG1heSBub3QgaGF2ZSBkdXBsaWNhdGUgcGFyYW1ldGVyIG5hbWVzJyxcclxuXHQgICAgU3RyaWN0UGFyYW1OYW1lOiAnUGFyYW1ldGVyIG5hbWUgZXZhbCBvciBhcmd1bWVudHMgaXMgbm90IGFsbG93ZWQgaW4gc3RyaWN0IG1vZGUnLFxyXG5cdCAgICBTdHJpY3RSZXNlcnZlZFdvcmQ6ICdVc2Ugb2YgZnV0dXJlIHJlc2VydmVkIHdvcmQgaW4gc3RyaWN0IG1vZGUnLFxyXG5cdCAgICBTdHJpY3RWYXJOYW1lOiAnVmFyaWFibGUgbmFtZSBtYXkgbm90IGJlIGV2YWwgb3IgYXJndW1lbnRzIGluIHN0cmljdCBtb2RlJyxcclxuXHQgICAgVGVtcGxhdGVPY3RhbExpdGVyYWw6ICdPY3RhbCBsaXRlcmFscyBhcmUgbm90IGFsbG93ZWQgaW4gdGVtcGxhdGUgc3RyaW5ncy4nLFxyXG5cdCAgICBVbmV4cGVjdGVkRU9TOiAnVW5leHBlY3RlZCBlbmQgb2YgaW5wdXQnLFxyXG5cdCAgICBVbmV4cGVjdGVkSWRlbnRpZmllcjogJ1VuZXhwZWN0ZWQgaWRlbnRpZmllcicsXHJcblx0ICAgIFVuZXhwZWN0ZWROdW1iZXI6ICdVbmV4cGVjdGVkIG51bWJlcicsXHJcblx0ICAgIFVuZXhwZWN0ZWRSZXNlcnZlZDogJ1VuZXhwZWN0ZWQgcmVzZXJ2ZWQgd29yZCcsXHJcblx0ICAgIFVuZXhwZWN0ZWRTdHJpbmc6ICdVbmV4cGVjdGVkIHN0cmluZycsXHJcblx0ICAgIFVuZXhwZWN0ZWRUZW1wbGF0ZTogJ1VuZXhwZWN0ZWQgcXVhc2kgJTAnLFxyXG5cdCAgICBVbmV4cGVjdGVkVG9rZW46ICdVbmV4cGVjdGVkIHRva2VuICUwJyxcclxuXHQgICAgVW5leHBlY3RlZFRva2VuSWxsZWdhbDogJ1VuZXhwZWN0ZWQgdG9rZW4gSUxMRUdBTCcsXHJcblx0ICAgIFVua25vd25MYWJlbDogJ1VuZGVmaW5lZCBsYWJlbCBcXCclMFxcJycsXHJcblx0ICAgIFVudGVybWluYXRlZFJlZ0V4cDogJ0ludmFsaWQgcmVndWxhciBleHByZXNzaW9uOiBtaXNzaW5nIC8nXHJcblx0fTtcclxuXG5cbi8qKiovIH0sXG4vKiAxMiAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblx0XCJ1c2Ugc3RyaWN0XCI7XHJcblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG5cdHZhciBhc3NlcnRfMSA9IF9fd2VicGFja19yZXF1aXJlX18oOSk7XHJcblx0dmFyIGNoYXJhY3Rlcl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0KTtcclxuXHR2YXIgbWVzc2FnZXNfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMTEpO1xyXG5cdGZ1bmN0aW9uIGhleFZhbHVlKGNoKSB7XHJcblx0ICAgIHJldHVybiAnMDEyMzQ1Njc4OWFiY2RlZicuaW5kZXhPZihjaC50b0xvd2VyQ2FzZSgpKTtcclxuXHR9XHJcblx0ZnVuY3Rpb24gb2N0YWxWYWx1ZShjaCkge1xyXG5cdCAgICByZXR1cm4gJzAxMjM0NTY3Jy5pbmRleE9mKGNoKTtcclxuXHR9XHJcblx0dmFyIFNjYW5uZXIgPSAoZnVuY3Rpb24gKCkge1xyXG5cdCAgICBmdW5jdGlvbiBTY2FubmVyKGNvZGUsIGhhbmRsZXIpIHtcclxuXHQgICAgICAgIHRoaXMuc291cmNlID0gY29kZTtcclxuXHQgICAgICAgIHRoaXMuZXJyb3JIYW5kbGVyID0gaGFuZGxlcjtcclxuXHQgICAgICAgIHRoaXMudHJhY2tDb21tZW50ID0gZmFsc2U7XHJcblx0ICAgICAgICB0aGlzLmxlbmd0aCA9IGNvZGUubGVuZ3RoO1xyXG5cdCAgICAgICAgdGhpcy5pbmRleCA9IDA7XHJcblx0ICAgICAgICB0aGlzLmxpbmVOdW1iZXIgPSAoY29kZS5sZW5ndGggPiAwKSA/IDEgOiAwO1xyXG5cdCAgICAgICAgdGhpcy5saW5lU3RhcnQgPSAwO1xyXG5cdCAgICAgICAgdGhpcy5jdXJseVN0YWNrID0gW107XHJcblx0ICAgIH1cclxuXHQgICAgU2Nhbm5lci5wcm90b3R5cGUuc2F2ZVN0YXRlID0gZnVuY3Rpb24gKCkge1xyXG5cdCAgICAgICAgcmV0dXJuIHtcclxuXHQgICAgICAgICAgICBpbmRleDogdGhpcy5pbmRleCxcclxuXHQgICAgICAgICAgICBsaW5lTnVtYmVyOiB0aGlzLmxpbmVOdW1iZXIsXHJcblx0ICAgICAgICAgICAgbGluZVN0YXJ0OiB0aGlzLmxpbmVTdGFydFxyXG5cdCAgICAgICAgfTtcclxuXHQgICAgfTtcclxuXHQgICAgU2Nhbm5lci5wcm90b3R5cGUucmVzdG9yZVN0YXRlID0gZnVuY3Rpb24gKHN0YXRlKSB7XHJcblx0ICAgICAgICB0aGlzLmluZGV4ID0gc3RhdGUuaW5kZXg7XHJcblx0ICAgICAgICB0aGlzLmxpbmVOdW1iZXIgPSBzdGF0ZS5saW5lTnVtYmVyO1xyXG5cdCAgICAgICAgdGhpcy5saW5lU3RhcnQgPSBzdGF0ZS5saW5lU3RhcnQ7XHJcblx0ICAgIH07XHJcblx0ICAgIFNjYW5uZXIucHJvdG90eXBlLmVvZiA9IGZ1bmN0aW9uICgpIHtcclxuXHQgICAgICAgIHJldHVybiB0aGlzLmluZGV4ID49IHRoaXMubGVuZ3RoO1xyXG5cdCAgICB9O1xyXG5cdCAgICBTY2FubmVyLnByb3RvdHlwZS50aHJvd1VuZXhwZWN0ZWRUb2tlbiA9IGZ1bmN0aW9uIChtZXNzYWdlKSB7XHJcblx0ICAgICAgICBpZiAobWVzc2FnZSA9PT0gdm9pZCAwKSB7IG1lc3NhZ2UgPSBtZXNzYWdlc18xLk1lc3NhZ2VzLlVuZXhwZWN0ZWRUb2tlbklsbGVnYWw7IH1cclxuXHQgICAgICAgIHJldHVybiB0aGlzLmVycm9ySGFuZGxlci50aHJvd0Vycm9yKHRoaXMuaW5kZXgsIHRoaXMubGluZU51bWJlciwgdGhpcy5pbmRleCAtIHRoaXMubGluZVN0YXJ0ICsgMSwgbWVzc2FnZSk7XHJcblx0ICAgIH07XHJcblx0ICAgIFNjYW5uZXIucHJvdG90eXBlLnRvbGVyYXRlVW5leHBlY3RlZFRva2VuID0gZnVuY3Rpb24gKG1lc3NhZ2UpIHtcclxuXHQgICAgICAgIGlmIChtZXNzYWdlID09PSB2b2lkIDApIHsgbWVzc2FnZSA9IG1lc3NhZ2VzXzEuTWVzc2FnZXMuVW5leHBlY3RlZFRva2VuSWxsZWdhbDsgfVxyXG5cdCAgICAgICAgdGhpcy5lcnJvckhhbmRsZXIudG9sZXJhdGVFcnJvcih0aGlzLmluZGV4LCB0aGlzLmxpbmVOdW1iZXIsIHRoaXMuaW5kZXggLSB0aGlzLmxpbmVTdGFydCArIDEsIG1lc3NhZ2UpO1xyXG5cdCAgICB9O1xyXG5cdCAgICAvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1jb21tZW50c1xyXG5cdCAgICBTY2FubmVyLnByb3RvdHlwZS5za2lwU2luZ2xlTGluZUNvbW1lbnQgPSBmdW5jdGlvbiAob2Zmc2V0KSB7XHJcblx0ICAgICAgICB2YXIgY29tbWVudHMgPSBbXTtcclxuXHQgICAgICAgIHZhciBzdGFydCwgbG9jO1xyXG5cdCAgICAgICAgaWYgKHRoaXMudHJhY2tDb21tZW50KSB7XHJcblx0ICAgICAgICAgICAgY29tbWVudHMgPSBbXTtcclxuXHQgICAgICAgICAgICBzdGFydCA9IHRoaXMuaW5kZXggLSBvZmZzZXQ7XHJcblx0ICAgICAgICAgICAgbG9jID0ge1xyXG5cdCAgICAgICAgICAgICAgICBzdGFydDoge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgbGluZTogdGhpcy5saW5lTnVtYmVyLFxyXG5cdCAgICAgICAgICAgICAgICAgICAgY29sdW1uOiB0aGlzLmluZGV4IC0gdGhpcy5saW5lU3RhcnQgLSBvZmZzZXRcclxuXHQgICAgICAgICAgICAgICAgfSxcclxuXHQgICAgICAgICAgICAgICAgZW5kOiB7fVxyXG5cdCAgICAgICAgICAgIH07XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICB3aGlsZSAoIXRoaXMuZW9mKCkpIHtcclxuXHQgICAgICAgICAgICB2YXIgY2ggPSB0aGlzLnNvdXJjZS5jaGFyQ29kZUF0KHRoaXMuaW5kZXgpO1xyXG5cdCAgICAgICAgICAgICsrdGhpcy5pbmRleDtcclxuXHQgICAgICAgICAgICBpZiAoY2hhcmFjdGVyXzEuQ2hhcmFjdGVyLmlzTGluZVRlcm1pbmF0b3IoY2gpKSB7XHJcblx0ICAgICAgICAgICAgICAgIGlmICh0aGlzLnRyYWNrQ29tbWVudCkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgbG9jLmVuZCA9IHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBsaW5lOiB0aGlzLmxpbmVOdW1iZXIsXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgY29sdW1uOiB0aGlzLmluZGV4IC0gdGhpcy5saW5lU3RhcnQgLSAxXHJcblx0ICAgICAgICAgICAgICAgICAgICB9O1xyXG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIGVudHJ5ID0ge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIG11bHRpTGluZTogZmFsc2UsXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgc2xpY2U6IFtzdGFydCArIG9mZnNldCwgdGhpcy5pbmRleCAtIDFdLFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJhbmdlOiBbc3RhcnQsIHRoaXMuaW5kZXggLSAxXSxcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBsb2M6IGxvY1xyXG5cdCAgICAgICAgICAgICAgICAgICAgfTtcclxuXHQgICAgICAgICAgICAgICAgICAgIGNvbW1lbnRzLnB1c2goZW50cnkpO1xyXG5cdCAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgIGlmIChjaCA9PT0gMTMgJiYgdGhpcy5zb3VyY2UuY2hhckNvZGVBdCh0aGlzLmluZGV4KSA9PT0gMTApIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICsrdGhpcy5pbmRleDtcclxuXHQgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICArK3RoaXMubGluZU51bWJlcjtcclxuXHQgICAgICAgICAgICAgICAgdGhpcy5saW5lU3RhcnQgPSB0aGlzLmluZGV4O1xyXG5cdCAgICAgICAgICAgICAgICByZXR1cm4gY29tbWVudHM7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgaWYgKHRoaXMudHJhY2tDb21tZW50KSB7XHJcblx0ICAgICAgICAgICAgbG9jLmVuZCA9IHtcclxuXHQgICAgICAgICAgICAgICAgbGluZTogdGhpcy5saW5lTnVtYmVyLFxyXG5cdCAgICAgICAgICAgICAgICBjb2x1bW46IHRoaXMuaW5kZXggLSB0aGlzLmxpbmVTdGFydFxyXG5cdCAgICAgICAgICAgIH07XHJcblx0ICAgICAgICAgICAgdmFyIGVudHJ5ID0ge1xyXG5cdCAgICAgICAgICAgICAgICBtdWx0aUxpbmU6IGZhbHNlLFxyXG5cdCAgICAgICAgICAgICAgICBzbGljZTogW3N0YXJ0ICsgb2Zmc2V0LCB0aGlzLmluZGV4XSxcclxuXHQgICAgICAgICAgICAgICAgcmFuZ2U6IFtzdGFydCwgdGhpcy5pbmRleF0sXHJcblx0ICAgICAgICAgICAgICAgIGxvYzogbG9jXHJcblx0ICAgICAgICAgICAgfTtcclxuXHQgICAgICAgICAgICBjb21tZW50cy5wdXNoKGVudHJ5KTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIHJldHVybiBjb21tZW50cztcclxuXHQgICAgfTtcclxuXHQgICAgU2Nhbm5lci5wcm90b3R5cGUuc2tpcE11bHRpTGluZUNvbW1lbnQgPSBmdW5jdGlvbiAoKSB7XHJcblx0ICAgICAgICB2YXIgY29tbWVudHMgPSBbXTtcclxuXHQgICAgICAgIHZhciBzdGFydCwgbG9jO1xyXG5cdCAgICAgICAgaWYgKHRoaXMudHJhY2tDb21tZW50KSB7XHJcblx0ICAgICAgICAgICAgY29tbWVudHMgPSBbXTtcclxuXHQgICAgICAgICAgICBzdGFydCA9IHRoaXMuaW5kZXggLSAyO1xyXG5cdCAgICAgICAgICAgIGxvYyA9IHtcclxuXHQgICAgICAgICAgICAgICAgc3RhcnQ6IHtcclxuXHQgICAgICAgICAgICAgICAgICAgIGxpbmU6IHRoaXMubGluZU51bWJlcixcclxuXHQgICAgICAgICAgICAgICAgICAgIGNvbHVtbjogdGhpcy5pbmRleCAtIHRoaXMubGluZVN0YXJ0IC0gMlxyXG5cdCAgICAgICAgICAgICAgICB9LFxyXG5cdCAgICAgICAgICAgICAgICBlbmQ6IHt9XHJcblx0ICAgICAgICAgICAgfTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIHdoaWxlICghdGhpcy5lb2YoKSkge1xyXG5cdCAgICAgICAgICAgIHZhciBjaCA9IHRoaXMuc291cmNlLmNoYXJDb2RlQXQodGhpcy5pbmRleCk7XHJcblx0ICAgICAgICAgICAgaWYgKGNoYXJhY3Rlcl8xLkNoYXJhY3Rlci5pc0xpbmVUZXJtaW5hdG9yKGNoKSkge1xyXG5cdCAgICAgICAgICAgICAgICBpZiAoY2ggPT09IDB4MEQgJiYgdGhpcy5zb3VyY2UuY2hhckNvZGVBdCh0aGlzLmluZGV4ICsgMSkgPT09IDB4MEEpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICsrdGhpcy5pbmRleDtcclxuXHQgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICArK3RoaXMubGluZU51bWJlcjtcclxuXHQgICAgICAgICAgICAgICAgKyt0aGlzLmluZGV4O1xyXG5cdCAgICAgICAgICAgICAgICB0aGlzLmxpbmVTdGFydCA9IHRoaXMuaW5kZXg7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgIGVsc2UgaWYgKGNoID09PSAweDJBKSB7XHJcblx0ICAgICAgICAgICAgICAgIC8vIEJsb2NrIGNvbW1lbnQgZW5kcyB3aXRoICcqLycuXHJcblx0ICAgICAgICAgICAgICAgIGlmICh0aGlzLnNvdXJjZS5jaGFyQ29kZUF0KHRoaXMuaW5kZXggKyAxKSA9PT0gMHgyRikge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgdGhpcy5pbmRleCArPSAyO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMudHJhY2tDb21tZW50KSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgbG9jLmVuZCA9IHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGluZTogdGhpcy5saW5lTnVtYmVyLFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2x1bW46IHRoaXMuaW5kZXggLSB0aGlzLmxpbmVTdGFydFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH07XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGVudHJ5ID0ge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBtdWx0aUxpbmU6IHRydWUsXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNsaWNlOiBbc3RhcnQgKyAyLCB0aGlzLmluZGV4IC0gMl0sXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJhbmdlOiBbc3RhcnQsIHRoaXMuaW5kZXhdLFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBsb2M6IGxvY1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH07XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgY29tbWVudHMucHVzaChlbnRyeSk7XHJcblx0ICAgICAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgICAgICByZXR1cm4gY29tbWVudHM7XHJcblx0ICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgKyt0aGlzLmluZGV4O1xyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICBlbHNlIHtcclxuXHQgICAgICAgICAgICAgICAgKyt0aGlzLmluZGV4O1xyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIC8vIFJhbiBvZmYgdGhlIGVuZCBvZiB0aGUgZmlsZSAtIHRoZSB3aG9sZSB0aGluZyBpcyBhIGNvbW1lbnRcclxuXHQgICAgICAgIGlmICh0aGlzLnRyYWNrQ29tbWVudCkge1xyXG5cdCAgICAgICAgICAgIGxvYy5lbmQgPSB7XHJcblx0ICAgICAgICAgICAgICAgIGxpbmU6IHRoaXMubGluZU51bWJlcixcclxuXHQgICAgICAgICAgICAgICAgY29sdW1uOiB0aGlzLmluZGV4IC0gdGhpcy5saW5lU3RhcnRcclxuXHQgICAgICAgICAgICB9O1xyXG5cdCAgICAgICAgICAgIHZhciBlbnRyeSA9IHtcclxuXHQgICAgICAgICAgICAgICAgbXVsdGlMaW5lOiB0cnVlLFxyXG5cdCAgICAgICAgICAgICAgICBzbGljZTogW3N0YXJ0ICsgMiwgdGhpcy5pbmRleF0sXHJcblx0ICAgICAgICAgICAgICAgIHJhbmdlOiBbc3RhcnQsIHRoaXMuaW5kZXhdLFxyXG5cdCAgICAgICAgICAgICAgICBsb2M6IGxvY1xyXG5cdCAgICAgICAgICAgIH07XHJcblx0ICAgICAgICAgICAgY29tbWVudHMucHVzaChlbnRyeSk7XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICB0aGlzLnRvbGVyYXRlVW5leHBlY3RlZFRva2VuKCk7XHJcblx0ICAgICAgICByZXR1cm4gY29tbWVudHM7XHJcblx0ICAgIH07XHJcblx0ICAgIFNjYW5uZXIucHJvdG90eXBlLnNjYW5Db21tZW50cyA9IGZ1bmN0aW9uICgpIHtcclxuXHQgICAgICAgIHZhciBjb21tZW50cztcclxuXHQgICAgICAgIGlmICh0aGlzLnRyYWNrQ29tbWVudCkge1xyXG5cdCAgICAgICAgICAgIGNvbW1lbnRzID0gW107XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICB2YXIgc3RhcnQgPSAodGhpcy5pbmRleCA9PT0gMCk7XHJcblx0ICAgICAgICB3aGlsZSAoIXRoaXMuZW9mKCkpIHtcclxuXHQgICAgICAgICAgICB2YXIgY2ggPSB0aGlzLnNvdXJjZS5jaGFyQ29kZUF0KHRoaXMuaW5kZXgpO1xyXG5cdCAgICAgICAgICAgIGlmIChjaGFyYWN0ZXJfMS5DaGFyYWN0ZXIuaXNXaGl0ZVNwYWNlKGNoKSkge1xyXG5cdCAgICAgICAgICAgICAgICArK3RoaXMuaW5kZXg7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgIGVsc2UgaWYgKGNoYXJhY3Rlcl8xLkNoYXJhY3Rlci5pc0xpbmVUZXJtaW5hdG9yKGNoKSkge1xyXG5cdCAgICAgICAgICAgICAgICArK3RoaXMuaW5kZXg7XHJcblx0ICAgICAgICAgICAgICAgIGlmIChjaCA9PT0gMHgwRCAmJiB0aGlzLnNvdXJjZS5jaGFyQ29kZUF0KHRoaXMuaW5kZXgpID09PSAweDBBKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICArK3RoaXMuaW5kZXg7XHJcblx0ICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgKyt0aGlzLmxpbmVOdW1iZXI7XHJcblx0ICAgICAgICAgICAgICAgIHRoaXMubGluZVN0YXJ0ID0gdGhpcy5pbmRleDtcclxuXHQgICAgICAgICAgICAgICAgc3RhcnQgPSB0cnVlO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICBlbHNlIGlmIChjaCA9PT0gMHgyRikge1xyXG5cdCAgICAgICAgICAgICAgICBjaCA9IHRoaXMuc291cmNlLmNoYXJDb2RlQXQodGhpcy5pbmRleCArIDEpO1xyXG5cdCAgICAgICAgICAgICAgICBpZiAoY2ggPT09IDB4MkYpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgIHRoaXMuaW5kZXggKz0gMjtcclxuXHQgICAgICAgICAgICAgICAgICAgIHZhciBjb21tZW50ID0gdGhpcy5za2lwU2luZ2xlTGluZUNvbW1lbnQoMik7XHJcblx0ICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy50cmFja0NvbW1lbnQpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBjb21tZW50cyA9IGNvbW1lbnRzLmNvbmNhdChjb21tZW50KTtcclxuXHQgICAgICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgICAgIHN0YXJ0ID0gdHJ1ZTtcclxuXHQgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICBlbHNlIGlmIChjaCA9PT0gMHgyQSkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgdGhpcy5pbmRleCArPSAyO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIGNvbW1lbnQgPSB0aGlzLnNraXBNdWx0aUxpbmVDb21tZW50KCk7XHJcblx0ICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy50cmFja0NvbW1lbnQpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBjb21tZW50cyA9IGNvbW1lbnRzLmNvbmNhdChjb21tZW50KTtcclxuXHQgICAgICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICBlbHNlIHtcclxuXHQgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cdCAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgIGVsc2UgaWYgKHN0YXJ0ICYmIGNoID09PSAweDJEKSB7XHJcblx0ICAgICAgICAgICAgICAgIC8vIFUrMDAzRSBpcyAnPidcclxuXHQgICAgICAgICAgICAgICAgaWYgKCh0aGlzLnNvdXJjZS5jaGFyQ29kZUF0KHRoaXMuaW5kZXggKyAxKSA9PT0gMHgyRCkgJiYgKHRoaXMuc291cmNlLmNoYXJDb2RlQXQodGhpcy5pbmRleCArIDIpID09PSAweDNFKSkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgLy8gJy0tPicgaXMgYSBzaW5nbGUtbGluZSBjb21tZW50XHJcblx0ICAgICAgICAgICAgICAgICAgICB0aGlzLmluZGV4ICs9IDM7XHJcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgY29tbWVudCA9IHRoaXMuc2tpcFNpbmdsZUxpbmVDb21tZW50KDMpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMudHJhY2tDb21tZW50KSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgY29tbWVudHMgPSBjb21tZW50cy5jb25jYXQoY29tbWVudCk7XHJcblx0ICAgICAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgZWxzZSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuXHQgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICBlbHNlIGlmIChjaCA9PT0gMHgzQykge1xyXG5cdCAgICAgICAgICAgICAgICBpZiAodGhpcy5zb3VyY2Uuc2xpY2UodGhpcy5pbmRleCArIDEsIHRoaXMuaW5kZXggKyA0KSA9PT0gJyEtLScpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgIHRoaXMuaW5kZXggKz0gNDsgLy8gYDwhLS1gXHJcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgY29tbWVudCA9IHRoaXMuc2tpcFNpbmdsZUxpbmVDb21tZW50KDQpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMudHJhY2tDb21tZW50KSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgY29tbWVudHMgPSBjb21tZW50cy5jb25jYXQoY29tbWVudCk7XHJcblx0ICAgICAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgZWxzZSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuXHQgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICBlbHNlIHtcclxuXHQgICAgICAgICAgICAgICAgYnJlYWs7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgcmV0dXJuIGNvbW1lbnRzO1xyXG5cdCAgICB9O1xyXG5cdCAgICAvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1mdXR1cmUtcmVzZXJ2ZWQtd29yZHNcclxuXHQgICAgU2Nhbm5lci5wcm90b3R5cGUuaXNGdXR1cmVSZXNlcnZlZFdvcmQgPSBmdW5jdGlvbiAoaWQpIHtcclxuXHQgICAgICAgIHN3aXRjaCAoaWQpIHtcclxuXHQgICAgICAgICAgICBjYXNlICdlbnVtJzpcclxuXHQgICAgICAgICAgICBjYXNlICdleHBvcnQnOlxyXG5cdCAgICAgICAgICAgIGNhc2UgJ2ltcG9ydCc6XHJcblx0ICAgICAgICAgICAgY2FzZSAnc3VwZXInOlxyXG5cdCAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuXHQgICAgICAgICAgICBkZWZhdWx0OlxyXG5cdCAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcblx0ICAgICAgICB9XHJcblx0ICAgIH07XHJcblx0ICAgIFNjYW5uZXIucHJvdG90eXBlLmlzU3RyaWN0TW9kZVJlc2VydmVkV29yZCA9IGZ1bmN0aW9uIChpZCkge1xyXG5cdCAgICAgICAgc3dpdGNoIChpZCkge1xyXG5cdCAgICAgICAgICAgIGNhc2UgJ2ltcGxlbWVudHMnOlxyXG5cdCAgICAgICAgICAgIGNhc2UgJ2ludGVyZmFjZSc6XHJcblx0ICAgICAgICAgICAgY2FzZSAncGFja2FnZSc6XHJcblx0ICAgICAgICAgICAgY2FzZSAncHJpdmF0ZSc6XHJcblx0ICAgICAgICAgICAgY2FzZSAncHJvdGVjdGVkJzpcclxuXHQgICAgICAgICAgICBjYXNlICdwdWJsaWMnOlxyXG5cdCAgICAgICAgICAgIGNhc2UgJ3N0YXRpYyc6XHJcblx0ICAgICAgICAgICAgY2FzZSAneWllbGQnOlxyXG5cdCAgICAgICAgICAgIGNhc2UgJ2xldCc6XHJcblx0ICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG5cdCAgICAgICAgICAgIGRlZmF1bHQ6XHJcblx0ICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgfTtcclxuXHQgICAgU2Nhbm5lci5wcm90b3R5cGUuaXNSZXN0cmljdGVkV29yZCA9IGZ1bmN0aW9uIChpZCkge1xyXG5cdCAgICAgICAgcmV0dXJuIGlkID09PSAnZXZhbCcgfHwgaWQgPT09ICdhcmd1bWVudHMnO1xyXG5cdCAgICB9O1xyXG5cdCAgICAvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1rZXl3b3Jkc1xyXG5cdCAgICBTY2FubmVyLnByb3RvdHlwZS5pc0tleXdvcmQgPSBmdW5jdGlvbiAoaWQpIHtcclxuXHQgICAgICAgIHN3aXRjaCAoaWQubGVuZ3RoKSB7XHJcblx0ICAgICAgICAgICAgY2FzZSAyOlxyXG5cdCAgICAgICAgICAgICAgICByZXR1cm4gKGlkID09PSAnaWYnKSB8fCAoaWQgPT09ICdpbicpIHx8IChpZCA9PT0gJ2RvJyk7XHJcblx0ICAgICAgICAgICAgY2FzZSAzOlxyXG5cdCAgICAgICAgICAgICAgICByZXR1cm4gKGlkID09PSAndmFyJykgfHwgKGlkID09PSAnZm9yJykgfHwgKGlkID09PSAnbmV3JykgfHxcclxuXHQgICAgICAgICAgICAgICAgICAgIChpZCA9PT0gJ3RyeScpIHx8IChpZCA9PT0gJ2xldCcpO1xyXG5cdCAgICAgICAgICAgIGNhc2UgNDpcclxuXHQgICAgICAgICAgICAgICAgcmV0dXJuIChpZCA9PT0gJ3RoaXMnKSB8fCAoaWQgPT09ICdlbHNlJykgfHwgKGlkID09PSAnY2FzZScpIHx8XHJcblx0ICAgICAgICAgICAgICAgICAgICAoaWQgPT09ICd2b2lkJykgfHwgKGlkID09PSAnd2l0aCcpIHx8IChpZCA9PT0gJ2VudW0nKTtcclxuXHQgICAgICAgICAgICBjYXNlIDU6XHJcblx0ICAgICAgICAgICAgICAgIHJldHVybiAoaWQgPT09ICd3aGlsZScpIHx8IChpZCA9PT0gJ2JyZWFrJykgfHwgKGlkID09PSAnY2F0Y2gnKSB8fFxyXG5cdCAgICAgICAgICAgICAgICAgICAgKGlkID09PSAndGhyb3cnKSB8fCAoaWQgPT09ICdjb25zdCcpIHx8IChpZCA9PT0gJ3lpZWxkJykgfHxcclxuXHQgICAgICAgICAgICAgICAgICAgIChpZCA9PT0gJ2NsYXNzJykgfHwgKGlkID09PSAnc3VwZXInKTtcclxuXHQgICAgICAgICAgICBjYXNlIDY6XHJcblx0ICAgICAgICAgICAgICAgIHJldHVybiAoaWQgPT09ICdyZXR1cm4nKSB8fCAoaWQgPT09ICd0eXBlb2YnKSB8fCAoaWQgPT09ICdkZWxldGUnKSB8fFxyXG5cdCAgICAgICAgICAgICAgICAgICAgKGlkID09PSAnc3dpdGNoJykgfHwgKGlkID09PSAnZXhwb3J0JykgfHwgKGlkID09PSAnaW1wb3J0Jyk7XHJcblx0ICAgICAgICAgICAgY2FzZSA3OlxyXG5cdCAgICAgICAgICAgICAgICByZXR1cm4gKGlkID09PSAnZGVmYXVsdCcpIHx8IChpZCA9PT0gJ2ZpbmFsbHknKSB8fCAoaWQgPT09ICdleHRlbmRzJyk7XHJcblx0ICAgICAgICAgICAgY2FzZSA4OlxyXG5cdCAgICAgICAgICAgICAgICByZXR1cm4gKGlkID09PSAnZnVuY3Rpb24nKSB8fCAoaWQgPT09ICdjb250aW51ZScpIHx8IChpZCA9PT0gJ2RlYnVnZ2VyJyk7XHJcblx0ICAgICAgICAgICAgY2FzZSAxMDpcclxuXHQgICAgICAgICAgICAgICAgcmV0dXJuIChpZCA9PT0gJ2luc3RhbmNlb2YnKTtcclxuXHQgICAgICAgICAgICBkZWZhdWx0OlxyXG5cdCAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcblx0ICAgICAgICB9XHJcblx0ICAgIH07XHJcblx0ICAgIFNjYW5uZXIucHJvdG90eXBlLmNvZGVQb2ludEF0ID0gZnVuY3Rpb24gKGkpIHtcclxuXHQgICAgICAgIHZhciBjcCA9IHRoaXMuc291cmNlLmNoYXJDb2RlQXQoaSk7XHJcblx0ICAgICAgICBpZiAoY3AgPj0gMHhEODAwICYmIGNwIDw9IDB4REJGRikge1xyXG5cdCAgICAgICAgICAgIHZhciBzZWNvbmQgPSB0aGlzLnNvdXJjZS5jaGFyQ29kZUF0KGkgKyAxKTtcclxuXHQgICAgICAgICAgICBpZiAoc2Vjb25kID49IDB4REMwMCAmJiBzZWNvbmQgPD0gMHhERkZGKSB7XHJcblx0ICAgICAgICAgICAgICAgIHZhciBmaXJzdCA9IGNwO1xyXG5cdCAgICAgICAgICAgICAgICBjcCA9IChmaXJzdCAtIDB4RDgwMCkgKiAweDQwMCArIHNlY29uZCAtIDB4REMwMCArIDB4MTAwMDA7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgcmV0dXJuIGNwO1xyXG5cdCAgICB9O1xyXG5cdCAgICBTY2FubmVyLnByb3RvdHlwZS5zY2FuSGV4RXNjYXBlID0gZnVuY3Rpb24gKHByZWZpeCkge1xyXG5cdCAgICAgICAgdmFyIGxlbiA9IChwcmVmaXggPT09ICd1JykgPyA0IDogMjtcclxuXHQgICAgICAgIHZhciBjb2RlID0gMDtcclxuXHQgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyArK2kpIHtcclxuXHQgICAgICAgICAgICBpZiAoIXRoaXMuZW9mKCkgJiYgY2hhcmFjdGVyXzEuQ2hhcmFjdGVyLmlzSGV4RGlnaXQodGhpcy5zb3VyY2UuY2hhckNvZGVBdCh0aGlzLmluZGV4KSkpIHtcclxuXHQgICAgICAgICAgICAgICAgY29kZSA9IGNvZGUgKiAxNiArIGhleFZhbHVlKHRoaXMuc291cmNlW3RoaXMuaW5kZXgrK10pO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICBlbHNlIHtcclxuXHQgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUoY29kZSk7XHJcblx0ICAgIH07XHJcblx0ICAgIFNjYW5uZXIucHJvdG90eXBlLnNjYW5Vbmljb2RlQ29kZVBvaW50RXNjYXBlID0gZnVuY3Rpb24gKCkge1xyXG5cdCAgICAgICAgdmFyIGNoID0gdGhpcy5zb3VyY2VbdGhpcy5pbmRleF07XHJcblx0ICAgICAgICB2YXIgY29kZSA9IDA7XHJcblx0ICAgICAgICAvLyBBdCBsZWFzdCwgb25lIGhleCBkaWdpdCBpcyByZXF1aXJlZC5cclxuXHQgICAgICAgIGlmIChjaCA9PT0gJ30nKSB7XHJcblx0ICAgICAgICAgICAgdGhpcy50aHJvd1VuZXhwZWN0ZWRUb2tlbigpO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgd2hpbGUgKCF0aGlzLmVvZigpKSB7XHJcblx0ICAgICAgICAgICAgY2ggPSB0aGlzLnNvdXJjZVt0aGlzLmluZGV4KytdO1xyXG5cdCAgICAgICAgICAgIGlmICghY2hhcmFjdGVyXzEuQ2hhcmFjdGVyLmlzSGV4RGlnaXQoY2guY2hhckNvZGVBdCgwKSkpIHtcclxuXHQgICAgICAgICAgICAgICAgYnJlYWs7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgIGNvZGUgPSBjb2RlICogMTYgKyBoZXhWYWx1ZShjaCk7XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICBpZiAoY29kZSA+IDB4MTBGRkZGIHx8IGNoICE9PSAnfScpIHtcclxuXHQgICAgICAgICAgICB0aGlzLnRocm93VW5leHBlY3RlZFRva2VuKCk7XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICByZXR1cm4gY2hhcmFjdGVyXzEuQ2hhcmFjdGVyLmZyb21Db2RlUG9pbnQoY29kZSk7XHJcblx0ICAgIH07XHJcblx0ICAgIFNjYW5uZXIucHJvdG90eXBlLmdldElkZW50aWZpZXIgPSBmdW5jdGlvbiAoKSB7XHJcblx0ICAgICAgICB2YXIgc3RhcnQgPSB0aGlzLmluZGV4Kys7XHJcblx0ICAgICAgICB3aGlsZSAoIXRoaXMuZW9mKCkpIHtcclxuXHQgICAgICAgICAgICB2YXIgY2ggPSB0aGlzLnNvdXJjZS5jaGFyQ29kZUF0KHRoaXMuaW5kZXgpO1xyXG5cdCAgICAgICAgICAgIGlmIChjaCA9PT0gMHg1Qykge1xyXG5cdCAgICAgICAgICAgICAgICAvLyBCbGFja3NsYXNoIChVKzAwNUMpIG1hcmtzIFVuaWNvZGUgZXNjYXBlIHNlcXVlbmNlLlxyXG5cdCAgICAgICAgICAgICAgICB0aGlzLmluZGV4ID0gc3RhcnQ7XHJcblx0ICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmdldENvbXBsZXhJZGVudGlmaWVyKCk7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgIGVsc2UgaWYgKGNoID49IDB4RDgwMCAmJiBjaCA8IDB4REZGRikge1xyXG5cdCAgICAgICAgICAgICAgICAvLyBOZWVkIHRvIGhhbmRsZSBzdXJyb2dhdGUgcGFpcnMuXHJcblx0ICAgICAgICAgICAgICAgIHRoaXMuaW5kZXggPSBzdGFydDtcclxuXHQgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0Q29tcGxleElkZW50aWZpZXIoKTtcclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgaWYgKGNoYXJhY3Rlcl8xLkNoYXJhY3Rlci5pc0lkZW50aWZpZXJQYXJ0KGNoKSkge1xyXG5cdCAgICAgICAgICAgICAgICArK3RoaXMuaW5kZXg7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgIGVsc2Uge1xyXG5cdCAgICAgICAgICAgICAgICBicmVhaztcclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICByZXR1cm4gdGhpcy5zb3VyY2Uuc2xpY2Uoc3RhcnQsIHRoaXMuaW5kZXgpO1xyXG5cdCAgICB9O1xyXG5cdCAgICBTY2FubmVyLnByb3RvdHlwZS5nZXRDb21wbGV4SWRlbnRpZmllciA9IGZ1bmN0aW9uICgpIHtcclxuXHQgICAgICAgIHZhciBjcCA9IHRoaXMuY29kZVBvaW50QXQodGhpcy5pbmRleCk7XHJcblx0ICAgICAgICB2YXIgaWQgPSBjaGFyYWN0ZXJfMS5DaGFyYWN0ZXIuZnJvbUNvZGVQb2ludChjcCk7XHJcblx0ICAgICAgICB0aGlzLmluZGV4ICs9IGlkLmxlbmd0aDtcclxuXHQgICAgICAgIC8vICdcXHUnIChVKzAwNUMsIFUrMDA3NSkgZGVub3RlcyBhbiBlc2NhcGVkIGNoYXJhY3Rlci5cclxuXHQgICAgICAgIHZhciBjaDtcclxuXHQgICAgICAgIGlmIChjcCA9PT0gMHg1Qykge1xyXG5cdCAgICAgICAgICAgIGlmICh0aGlzLnNvdXJjZS5jaGFyQ29kZUF0KHRoaXMuaW5kZXgpICE9PSAweDc1KSB7XHJcblx0ICAgICAgICAgICAgICAgIHRoaXMudGhyb3dVbmV4cGVjdGVkVG9rZW4oKTtcclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgKyt0aGlzLmluZGV4O1xyXG5cdCAgICAgICAgICAgIGlmICh0aGlzLnNvdXJjZVt0aGlzLmluZGV4XSA9PT0gJ3snKSB7XHJcblx0ICAgICAgICAgICAgICAgICsrdGhpcy5pbmRleDtcclxuXHQgICAgICAgICAgICAgICAgY2ggPSB0aGlzLnNjYW5Vbmljb2RlQ29kZVBvaW50RXNjYXBlKCk7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgIGVsc2Uge1xyXG5cdCAgICAgICAgICAgICAgICBjaCA9IHRoaXMuc2NhbkhleEVzY2FwZSgndScpO1xyXG5cdCAgICAgICAgICAgICAgICBpZiAoY2ggPT09IG51bGwgfHwgY2ggPT09ICdcXFxcJyB8fCAhY2hhcmFjdGVyXzEuQ2hhcmFjdGVyLmlzSWRlbnRpZmllclN0YXJ0KGNoLmNoYXJDb2RlQXQoMCkpKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICB0aGlzLnRocm93VW5leHBlY3RlZFRva2VuKCk7XHJcblx0ICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgaWQgPSBjaDtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIHdoaWxlICghdGhpcy5lb2YoKSkge1xyXG5cdCAgICAgICAgICAgIGNwID0gdGhpcy5jb2RlUG9pbnRBdCh0aGlzLmluZGV4KTtcclxuXHQgICAgICAgICAgICBpZiAoIWNoYXJhY3Rlcl8xLkNoYXJhY3Rlci5pc0lkZW50aWZpZXJQYXJ0KGNwKSkge1xyXG5cdCAgICAgICAgICAgICAgICBicmVhaztcclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgY2ggPSBjaGFyYWN0ZXJfMS5DaGFyYWN0ZXIuZnJvbUNvZGVQb2ludChjcCk7XHJcblx0ICAgICAgICAgICAgaWQgKz0gY2g7XHJcblx0ICAgICAgICAgICAgdGhpcy5pbmRleCArPSBjaC5sZW5ndGg7XHJcblx0ICAgICAgICAgICAgLy8gJ1xcdScgKFUrMDA1QywgVSswMDc1KSBkZW5vdGVzIGFuIGVzY2FwZWQgY2hhcmFjdGVyLlxyXG5cdCAgICAgICAgICAgIGlmIChjcCA9PT0gMHg1Qykge1xyXG5cdCAgICAgICAgICAgICAgICBpZCA9IGlkLnN1YnN0cigwLCBpZC5sZW5ndGggLSAxKTtcclxuXHQgICAgICAgICAgICAgICAgaWYgKHRoaXMuc291cmNlLmNoYXJDb2RlQXQodGhpcy5pbmRleCkgIT09IDB4NzUpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgIHRoaXMudGhyb3dVbmV4cGVjdGVkVG9rZW4oKTtcclxuXHQgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICArK3RoaXMuaW5kZXg7XHJcblx0ICAgICAgICAgICAgICAgIGlmICh0aGlzLnNvdXJjZVt0aGlzLmluZGV4XSA9PT0gJ3snKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICArK3RoaXMuaW5kZXg7XHJcblx0ICAgICAgICAgICAgICAgICAgICBjaCA9IHRoaXMuc2NhblVuaWNvZGVDb2RlUG9pbnRFc2NhcGUoKTtcclxuXHQgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICBlbHNlIHtcclxuXHQgICAgICAgICAgICAgICAgICAgIGNoID0gdGhpcy5zY2FuSGV4RXNjYXBlKCd1Jyk7XHJcblx0ICAgICAgICAgICAgICAgICAgICBpZiAoY2ggPT09IG51bGwgfHwgY2ggPT09ICdcXFxcJyB8fCAhY2hhcmFjdGVyXzEuQ2hhcmFjdGVyLmlzSWRlbnRpZmllclBhcnQoY2guY2hhckNvZGVBdCgwKSkpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnRocm93VW5leHBlY3RlZFRva2VuKCk7XHJcblx0ICAgICAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgaWQgKz0gY2g7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgcmV0dXJuIGlkO1xyXG5cdCAgICB9O1xyXG5cdCAgICBTY2FubmVyLnByb3RvdHlwZS5vY3RhbFRvRGVjaW1hbCA9IGZ1bmN0aW9uIChjaCkge1xyXG5cdCAgICAgICAgLy8gXFwwIGlzIG5vdCBvY3RhbCBlc2NhcGUgc2VxdWVuY2VcclxuXHQgICAgICAgIHZhciBvY3RhbCA9IChjaCAhPT0gJzAnKTtcclxuXHQgICAgICAgIHZhciBjb2RlID0gb2N0YWxWYWx1ZShjaCk7XHJcblx0ICAgICAgICBpZiAoIXRoaXMuZW9mKCkgJiYgY2hhcmFjdGVyXzEuQ2hhcmFjdGVyLmlzT2N0YWxEaWdpdCh0aGlzLnNvdXJjZS5jaGFyQ29kZUF0KHRoaXMuaW5kZXgpKSkge1xyXG5cdCAgICAgICAgICAgIG9jdGFsID0gdHJ1ZTtcclxuXHQgICAgICAgICAgICBjb2RlID0gY29kZSAqIDggKyBvY3RhbFZhbHVlKHRoaXMuc291cmNlW3RoaXMuaW5kZXgrK10pO1xyXG5cdCAgICAgICAgICAgIC8vIDMgZGlnaXRzIGFyZSBvbmx5IGFsbG93ZWQgd2hlbiBzdHJpbmcgc3RhcnRzXHJcblx0ICAgICAgICAgICAgLy8gd2l0aCAwLCAxLCAyLCAzXHJcblx0ICAgICAgICAgICAgaWYgKCcwMTIzJy5pbmRleE9mKGNoKSA+PSAwICYmICF0aGlzLmVvZigpICYmIGNoYXJhY3Rlcl8xLkNoYXJhY3Rlci5pc09jdGFsRGlnaXQodGhpcy5zb3VyY2UuY2hhckNvZGVBdCh0aGlzLmluZGV4KSkpIHtcclxuXHQgICAgICAgICAgICAgICAgY29kZSA9IGNvZGUgKiA4ICsgb2N0YWxWYWx1ZSh0aGlzLnNvdXJjZVt0aGlzLmluZGV4KytdKTtcclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICByZXR1cm4ge1xyXG5cdCAgICAgICAgICAgIGNvZGU6IGNvZGUsXHJcblx0ICAgICAgICAgICAgb2N0YWw6IG9jdGFsXHJcblx0ICAgICAgICB9O1xyXG5cdCAgICB9O1xyXG5cdCAgICAvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1uYW1lcy1hbmQta2V5d29yZHNcclxuXHQgICAgU2Nhbm5lci5wcm90b3R5cGUuc2NhbklkZW50aWZpZXIgPSBmdW5jdGlvbiAoKSB7XHJcblx0ICAgICAgICB2YXIgdHlwZTtcclxuXHQgICAgICAgIHZhciBzdGFydCA9IHRoaXMuaW5kZXg7XHJcblx0ICAgICAgICAvLyBCYWNrc2xhc2ggKFUrMDA1Qykgc3RhcnRzIGFuIGVzY2FwZWQgY2hhcmFjdGVyLlxyXG5cdCAgICAgICAgdmFyIGlkID0gKHRoaXMuc291cmNlLmNoYXJDb2RlQXQoc3RhcnQpID09PSAweDVDKSA/IHRoaXMuZ2V0Q29tcGxleElkZW50aWZpZXIoKSA6IHRoaXMuZ2V0SWRlbnRpZmllcigpO1xyXG5cdCAgICAgICAgLy8gVGhlcmUgaXMgbm8ga2V5d29yZCBvciBsaXRlcmFsIHdpdGggb25seSBvbmUgY2hhcmFjdGVyLlxyXG5cdCAgICAgICAgLy8gVGh1cywgaXQgbXVzdCBiZSBhbiBpZGVudGlmaWVyLlxyXG5cdCAgICAgICAgaWYgKGlkLmxlbmd0aCA9PT0gMSkge1xyXG5cdCAgICAgICAgICAgIHR5cGUgPSAzIC8qIElkZW50aWZpZXIgKi87XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICBlbHNlIGlmICh0aGlzLmlzS2V5d29yZChpZCkpIHtcclxuXHQgICAgICAgICAgICB0eXBlID0gNCAvKiBLZXl3b3JkICovO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgZWxzZSBpZiAoaWQgPT09ICdudWxsJykge1xyXG5cdCAgICAgICAgICAgIHR5cGUgPSA1IC8qIE51bGxMaXRlcmFsICovO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgZWxzZSBpZiAoaWQgPT09ICd0cnVlJyB8fCBpZCA9PT0gJ2ZhbHNlJykge1xyXG5cdCAgICAgICAgICAgIHR5cGUgPSAxIC8qIEJvb2xlYW5MaXRlcmFsICovO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgZWxzZSB7XHJcblx0ICAgICAgICAgICAgdHlwZSA9IDMgLyogSWRlbnRpZmllciAqLztcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIGlmICh0eXBlICE9PSAzIC8qIElkZW50aWZpZXIgKi8gJiYgKHN0YXJ0ICsgaWQubGVuZ3RoICE9PSB0aGlzLmluZGV4KSkge1xyXG5cdCAgICAgICAgICAgIHZhciByZXN0b3JlID0gdGhpcy5pbmRleDtcclxuXHQgICAgICAgICAgICB0aGlzLmluZGV4ID0gc3RhcnQ7XHJcblx0ICAgICAgICAgICAgdGhpcy50b2xlcmF0ZVVuZXhwZWN0ZWRUb2tlbihtZXNzYWdlc18xLk1lc3NhZ2VzLkludmFsaWRFc2NhcGVkUmVzZXJ2ZWRXb3JkKTtcclxuXHQgICAgICAgICAgICB0aGlzLmluZGV4ID0gcmVzdG9yZTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIHJldHVybiB7XHJcblx0ICAgICAgICAgICAgdHlwZTogdHlwZSxcclxuXHQgICAgICAgICAgICB2YWx1ZTogaWQsXHJcblx0ICAgICAgICAgICAgbGluZU51bWJlcjogdGhpcy5saW5lTnVtYmVyLFxyXG5cdCAgICAgICAgICAgIGxpbmVTdGFydDogdGhpcy5saW5lU3RhcnQsXHJcblx0ICAgICAgICAgICAgc3RhcnQ6IHN0YXJ0LFxyXG5cdCAgICAgICAgICAgIGVuZDogdGhpcy5pbmRleFxyXG5cdCAgICAgICAgfTtcclxuXHQgICAgfTtcclxuXHQgICAgLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtcHVuY3R1YXRvcnNcclxuXHQgICAgU2Nhbm5lci5wcm90b3R5cGUuc2NhblB1bmN0dWF0b3IgPSBmdW5jdGlvbiAoKSB7XHJcblx0ICAgICAgICB2YXIgc3RhcnQgPSB0aGlzLmluZGV4O1xyXG5cdCAgICAgICAgLy8gQ2hlY2sgZm9yIG1vc3QgY29tbW9uIHNpbmdsZS1jaGFyYWN0ZXIgcHVuY3R1YXRvcnMuXHJcblx0ICAgICAgICB2YXIgc3RyID0gdGhpcy5zb3VyY2VbdGhpcy5pbmRleF07XHJcblx0ICAgICAgICBzd2l0Y2ggKHN0cikge1xyXG5cdCAgICAgICAgICAgIGNhc2UgJygnOlxyXG5cdCAgICAgICAgICAgIGNhc2UgJ3snOlxyXG5cdCAgICAgICAgICAgICAgICBpZiAoc3RyID09PSAneycpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgIHRoaXMuY3VybHlTdGFjay5wdXNoKCd7Jyk7XHJcblx0ICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgKyt0aGlzLmluZGV4O1xyXG5cdCAgICAgICAgICAgICAgICBicmVhaztcclxuXHQgICAgICAgICAgICBjYXNlICcuJzpcclxuXHQgICAgICAgICAgICAgICAgKyt0aGlzLmluZGV4O1xyXG5cdCAgICAgICAgICAgICAgICBpZiAodGhpcy5zb3VyY2VbdGhpcy5pbmRleF0gPT09ICcuJyAmJiB0aGlzLnNvdXJjZVt0aGlzLmluZGV4ICsgMV0gPT09ICcuJykge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgLy8gU3ByZWFkIG9wZXJhdG9yOiAuLi5cclxuXHQgICAgICAgICAgICAgICAgICAgIHRoaXMuaW5kZXggKz0gMjtcclxuXHQgICAgICAgICAgICAgICAgICAgIHN0ciA9ICcuLi4nO1xyXG5cdCAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cdCAgICAgICAgICAgIGNhc2UgJ30nOlxyXG5cdCAgICAgICAgICAgICAgICArK3RoaXMuaW5kZXg7XHJcblx0ICAgICAgICAgICAgICAgIHRoaXMuY3VybHlTdGFjay5wb3AoKTtcclxuXHQgICAgICAgICAgICAgICAgYnJlYWs7XHJcblx0ICAgICAgICAgICAgY2FzZSAnKSc6XHJcblx0ICAgICAgICAgICAgY2FzZSAnOyc6XHJcblx0ICAgICAgICAgICAgY2FzZSAnLCc6XHJcblx0ICAgICAgICAgICAgY2FzZSAnWyc6XHJcblx0ICAgICAgICAgICAgY2FzZSAnXSc6XHJcblx0ICAgICAgICAgICAgY2FzZSAnOic6XHJcblx0ICAgICAgICAgICAgY2FzZSAnPyc6XHJcblx0ICAgICAgICAgICAgY2FzZSAnfic6XHJcblx0ICAgICAgICAgICAgICAgICsrdGhpcy5pbmRleDtcclxuXHQgICAgICAgICAgICAgICAgYnJlYWs7XHJcblx0ICAgICAgICAgICAgZGVmYXVsdDpcclxuXHQgICAgICAgICAgICAgICAgLy8gNC1jaGFyYWN0ZXIgcHVuY3R1YXRvci5cclxuXHQgICAgICAgICAgICAgICAgc3RyID0gdGhpcy5zb3VyY2Uuc3Vic3RyKHRoaXMuaW5kZXgsIDQpO1xyXG5cdCAgICAgICAgICAgICAgICBpZiAoc3RyID09PSAnPj4+PScpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgIHRoaXMuaW5kZXggKz0gNDtcclxuXHQgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICBlbHNlIHtcclxuXHQgICAgICAgICAgICAgICAgICAgIC8vIDMtY2hhcmFjdGVyIHB1bmN0dWF0b3JzLlxyXG5cdCAgICAgICAgICAgICAgICAgICAgc3RyID0gc3RyLnN1YnN0cigwLCAzKTtcclxuXHQgICAgICAgICAgICAgICAgICAgIGlmIChzdHIgPT09ICc9PT0nIHx8IHN0ciA9PT0gJyE9PScgfHwgc3RyID09PSAnPj4+JyB8fFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHN0ciA9PT0gJzw8PScgfHwgc3RyID09PSAnPj49JyB8fCBzdHIgPT09ICcqKj0nKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5pbmRleCArPSAzO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgLy8gMi1jaGFyYWN0ZXIgcHVuY3R1YXRvcnMuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgc3RyID0gc3RyLnN1YnN0cigwLCAyKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBpZiAoc3RyID09PSAnJiYnIHx8IHN0ciA9PT0gJ3x8JyB8fCBzdHIgPT09ICc9PScgfHwgc3RyID09PSAnIT0nIHx8XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0ciA9PT0gJys9JyB8fCBzdHIgPT09ICctPScgfHwgc3RyID09PSAnKj0nIHx8IHN0ciA9PT0gJy89JyB8fFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHIgPT09ICcrKycgfHwgc3RyID09PSAnLS0nIHx8IHN0ciA9PT0gJzw8JyB8fCBzdHIgPT09ICc+PicgfHxcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RyID09PSAnJj0nIHx8IHN0ciA9PT0gJ3w9JyB8fCBzdHIgPT09ICdePScgfHwgc3RyID09PSAnJT0nIHx8XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0ciA9PT0gJzw9JyB8fCBzdHIgPT09ICc+PScgfHwgc3RyID09PSAnPT4nIHx8IHN0ciA9PT0gJyoqJykge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmluZGV4ICs9IDI7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyAxLWNoYXJhY3RlciBwdW5jdHVhdG9ycy5cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RyID0gdGhpcy5zb3VyY2VbdGhpcy5pbmRleF07XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICgnPD49ISstKiUmfF4vJy5pbmRleE9mKHN0cikgPj0gMCkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKyt0aGlzLmluZGV4O1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICBpZiAodGhpcy5pbmRleCA9PT0gc3RhcnQpIHtcclxuXHQgICAgICAgICAgICB0aGlzLnRocm93VW5leHBlY3RlZFRva2VuKCk7XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICByZXR1cm4ge1xyXG5cdCAgICAgICAgICAgIHR5cGU6IDcgLyogUHVuY3R1YXRvciAqLyxcclxuXHQgICAgICAgICAgICB2YWx1ZTogc3RyLFxyXG5cdCAgICAgICAgICAgIGxpbmVOdW1iZXI6IHRoaXMubGluZU51bWJlcixcclxuXHQgICAgICAgICAgICBsaW5lU3RhcnQ6IHRoaXMubGluZVN0YXJ0LFxyXG5cdCAgICAgICAgICAgIHN0YXJ0OiBzdGFydCxcclxuXHQgICAgICAgICAgICBlbmQ6IHRoaXMuaW5kZXhcclxuXHQgICAgICAgIH07XHJcblx0ICAgIH07XHJcblx0ICAgIC8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLWxpdGVyYWxzLW51bWVyaWMtbGl0ZXJhbHNcclxuXHQgICAgU2Nhbm5lci5wcm90b3R5cGUuc2NhbkhleExpdGVyYWwgPSBmdW5jdGlvbiAoc3RhcnQpIHtcclxuXHQgICAgICAgIHZhciBudW0gPSAnJztcclxuXHQgICAgICAgIHdoaWxlICghdGhpcy5lb2YoKSkge1xyXG5cdCAgICAgICAgICAgIGlmICghY2hhcmFjdGVyXzEuQ2hhcmFjdGVyLmlzSGV4RGlnaXQodGhpcy5zb3VyY2UuY2hhckNvZGVBdCh0aGlzLmluZGV4KSkpIHtcclxuXHQgICAgICAgICAgICAgICAgYnJlYWs7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgIG51bSArPSB0aGlzLnNvdXJjZVt0aGlzLmluZGV4KytdO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgaWYgKG51bS5sZW5ndGggPT09IDApIHtcclxuXHQgICAgICAgICAgICB0aGlzLnRocm93VW5leHBlY3RlZFRva2VuKCk7XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICBpZiAoY2hhcmFjdGVyXzEuQ2hhcmFjdGVyLmlzSWRlbnRpZmllclN0YXJ0KHRoaXMuc291cmNlLmNoYXJDb2RlQXQodGhpcy5pbmRleCkpKSB7XHJcblx0ICAgICAgICAgICAgdGhpcy50aHJvd1VuZXhwZWN0ZWRUb2tlbigpO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgcmV0dXJuIHtcclxuXHQgICAgICAgICAgICB0eXBlOiA2IC8qIE51bWVyaWNMaXRlcmFsICovLFxyXG5cdCAgICAgICAgICAgIHZhbHVlOiBwYXJzZUludCgnMHgnICsgbnVtLCAxNiksXHJcblx0ICAgICAgICAgICAgbGluZU51bWJlcjogdGhpcy5saW5lTnVtYmVyLFxyXG5cdCAgICAgICAgICAgIGxpbmVTdGFydDogdGhpcy5saW5lU3RhcnQsXHJcblx0ICAgICAgICAgICAgc3RhcnQ6IHN0YXJ0LFxyXG5cdCAgICAgICAgICAgIGVuZDogdGhpcy5pbmRleFxyXG5cdCAgICAgICAgfTtcclxuXHQgICAgfTtcclxuXHQgICAgU2Nhbm5lci5wcm90b3R5cGUuc2NhbkJpbmFyeUxpdGVyYWwgPSBmdW5jdGlvbiAoc3RhcnQpIHtcclxuXHQgICAgICAgIHZhciBudW0gPSAnJztcclxuXHQgICAgICAgIHZhciBjaDtcclxuXHQgICAgICAgIHdoaWxlICghdGhpcy5lb2YoKSkge1xyXG5cdCAgICAgICAgICAgIGNoID0gdGhpcy5zb3VyY2VbdGhpcy5pbmRleF07XHJcblx0ICAgICAgICAgICAgaWYgKGNoICE9PSAnMCcgJiYgY2ggIT09ICcxJykge1xyXG5cdCAgICAgICAgICAgICAgICBicmVhaztcclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgbnVtICs9IHRoaXMuc291cmNlW3RoaXMuaW5kZXgrK107XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICBpZiAobnVtLmxlbmd0aCA9PT0gMCkge1xyXG5cdCAgICAgICAgICAgIC8vIG9ubHkgMGIgb3IgMEJcclxuXHQgICAgICAgICAgICB0aGlzLnRocm93VW5leHBlY3RlZFRva2VuKCk7XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICBpZiAoIXRoaXMuZW9mKCkpIHtcclxuXHQgICAgICAgICAgICBjaCA9IHRoaXMuc291cmNlLmNoYXJDb2RlQXQodGhpcy5pbmRleCk7XHJcblx0ICAgICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cclxuXHQgICAgICAgICAgICBpZiAoY2hhcmFjdGVyXzEuQ2hhcmFjdGVyLmlzSWRlbnRpZmllclN0YXJ0KGNoKSB8fCBjaGFyYWN0ZXJfMS5DaGFyYWN0ZXIuaXNEZWNpbWFsRGlnaXQoY2gpKSB7XHJcblx0ICAgICAgICAgICAgICAgIHRoaXMudGhyb3dVbmV4cGVjdGVkVG9rZW4oKTtcclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICByZXR1cm4ge1xyXG5cdCAgICAgICAgICAgIHR5cGU6IDYgLyogTnVtZXJpY0xpdGVyYWwgKi8sXHJcblx0ICAgICAgICAgICAgdmFsdWU6IHBhcnNlSW50KG51bSwgMiksXHJcblx0ICAgICAgICAgICAgbGluZU51bWJlcjogdGhpcy5saW5lTnVtYmVyLFxyXG5cdCAgICAgICAgICAgIGxpbmVTdGFydDogdGhpcy5saW5lU3RhcnQsXHJcblx0ICAgICAgICAgICAgc3RhcnQ6IHN0YXJ0LFxyXG5cdCAgICAgICAgICAgIGVuZDogdGhpcy5pbmRleFxyXG5cdCAgICAgICAgfTtcclxuXHQgICAgfTtcclxuXHQgICAgU2Nhbm5lci5wcm90b3R5cGUuc2Nhbk9jdGFsTGl0ZXJhbCA9IGZ1bmN0aW9uIChwcmVmaXgsIHN0YXJ0KSB7XHJcblx0ICAgICAgICB2YXIgbnVtID0gJyc7XHJcblx0ICAgICAgICB2YXIgb2N0YWwgPSBmYWxzZTtcclxuXHQgICAgICAgIGlmIChjaGFyYWN0ZXJfMS5DaGFyYWN0ZXIuaXNPY3RhbERpZ2l0KHByZWZpeC5jaGFyQ29kZUF0KDApKSkge1xyXG5cdCAgICAgICAgICAgIG9jdGFsID0gdHJ1ZTtcclxuXHQgICAgICAgICAgICBudW0gPSAnMCcgKyB0aGlzLnNvdXJjZVt0aGlzLmluZGV4KytdO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgZWxzZSB7XHJcblx0ICAgICAgICAgICAgKyt0aGlzLmluZGV4O1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgd2hpbGUgKCF0aGlzLmVvZigpKSB7XHJcblx0ICAgICAgICAgICAgaWYgKCFjaGFyYWN0ZXJfMS5DaGFyYWN0ZXIuaXNPY3RhbERpZ2l0KHRoaXMuc291cmNlLmNoYXJDb2RlQXQodGhpcy5pbmRleCkpKSB7XHJcblx0ICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICBudW0gKz0gdGhpcy5zb3VyY2VbdGhpcy5pbmRleCsrXTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIGlmICghb2N0YWwgJiYgbnVtLmxlbmd0aCA9PT0gMCkge1xyXG5cdCAgICAgICAgICAgIC8vIG9ubHkgMG8gb3IgME9cclxuXHQgICAgICAgICAgICB0aGlzLnRocm93VW5leHBlY3RlZFRva2VuKCk7XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICBpZiAoY2hhcmFjdGVyXzEuQ2hhcmFjdGVyLmlzSWRlbnRpZmllclN0YXJ0KHRoaXMuc291cmNlLmNoYXJDb2RlQXQodGhpcy5pbmRleCkpIHx8IGNoYXJhY3Rlcl8xLkNoYXJhY3Rlci5pc0RlY2ltYWxEaWdpdCh0aGlzLnNvdXJjZS5jaGFyQ29kZUF0KHRoaXMuaW5kZXgpKSkge1xyXG5cdCAgICAgICAgICAgIHRoaXMudGhyb3dVbmV4cGVjdGVkVG9rZW4oKTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIHJldHVybiB7XHJcblx0ICAgICAgICAgICAgdHlwZTogNiAvKiBOdW1lcmljTGl0ZXJhbCAqLyxcclxuXHQgICAgICAgICAgICB2YWx1ZTogcGFyc2VJbnQobnVtLCA4KSxcclxuXHQgICAgICAgICAgICBvY3RhbDogb2N0YWwsXHJcblx0ICAgICAgICAgICAgbGluZU51bWJlcjogdGhpcy5saW5lTnVtYmVyLFxyXG5cdCAgICAgICAgICAgIGxpbmVTdGFydDogdGhpcy5saW5lU3RhcnQsXHJcblx0ICAgICAgICAgICAgc3RhcnQ6IHN0YXJ0LFxyXG5cdCAgICAgICAgICAgIGVuZDogdGhpcy5pbmRleFxyXG5cdCAgICAgICAgfTtcclxuXHQgICAgfTtcclxuXHQgICAgU2Nhbm5lci5wcm90b3R5cGUuaXNJbXBsaWNpdE9jdGFsTGl0ZXJhbCA9IGZ1bmN0aW9uICgpIHtcclxuXHQgICAgICAgIC8vIEltcGxpY2l0IG9jdGFsLCB1bmxlc3MgdGhlcmUgaXMgYSBub24tb2N0YWwgZGlnaXQuXHJcblx0ICAgICAgICAvLyAoQW5uZXggQi4xLjEgb24gTnVtZXJpYyBMaXRlcmFscylcclxuXHQgICAgICAgIGZvciAodmFyIGkgPSB0aGlzLmluZGV4ICsgMTsgaSA8IHRoaXMubGVuZ3RoOyArK2kpIHtcclxuXHQgICAgICAgICAgICB2YXIgY2ggPSB0aGlzLnNvdXJjZVtpXTtcclxuXHQgICAgICAgICAgICBpZiAoY2ggPT09ICc4JyB8fCBjaCA9PT0gJzknKSB7XHJcblx0ICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgaWYgKCFjaGFyYWN0ZXJfMS5DaGFyYWN0ZXIuaXNPY3RhbERpZ2l0KGNoLmNoYXJDb2RlQXQoMCkpKSB7XHJcblx0ICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIHJldHVybiB0cnVlO1xyXG5cdCAgICB9O1xyXG5cdCAgICBTY2FubmVyLnByb3RvdHlwZS5zY2FuTnVtZXJpY0xpdGVyYWwgPSBmdW5jdGlvbiAoKSB7XHJcblx0ICAgICAgICB2YXIgc3RhcnQgPSB0aGlzLmluZGV4O1xyXG5cdCAgICAgICAgdmFyIGNoID0gdGhpcy5zb3VyY2Vbc3RhcnRdO1xyXG5cdCAgICAgICAgYXNzZXJ0XzEuYXNzZXJ0KGNoYXJhY3Rlcl8xLkNoYXJhY3Rlci5pc0RlY2ltYWxEaWdpdChjaC5jaGFyQ29kZUF0KDApKSB8fCAoY2ggPT09ICcuJyksICdOdW1lcmljIGxpdGVyYWwgbXVzdCBzdGFydCB3aXRoIGEgZGVjaW1hbCBkaWdpdCBvciBhIGRlY2ltYWwgcG9pbnQnKTtcclxuXHQgICAgICAgIHZhciBudW0gPSAnJztcclxuXHQgICAgICAgIGlmIChjaCAhPT0gJy4nKSB7XHJcblx0ICAgICAgICAgICAgbnVtID0gdGhpcy5zb3VyY2VbdGhpcy5pbmRleCsrXTtcclxuXHQgICAgICAgICAgICBjaCA9IHRoaXMuc291cmNlW3RoaXMuaW5kZXhdO1xyXG5cdCAgICAgICAgICAgIC8vIEhleCBudW1iZXIgc3RhcnRzIHdpdGggJzB4Jy5cclxuXHQgICAgICAgICAgICAvLyBPY3RhbCBudW1iZXIgc3RhcnRzIHdpdGggJzAnLlxyXG5cdCAgICAgICAgICAgIC8vIE9jdGFsIG51bWJlciBpbiBFUzYgc3RhcnRzIHdpdGggJzBvJy5cclxuXHQgICAgICAgICAgICAvLyBCaW5hcnkgbnVtYmVyIGluIEVTNiBzdGFydHMgd2l0aCAnMGInLlxyXG5cdCAgICAgICAgICAgIGlmIChudW0gPT09ICcwJykge1xyXG5cdCAgICAgICAgICAgICAgICBpZiAoY2ggPT09ICd4JyB8fCBjaCA9PT0gJ1gnKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICArK3RoaXMuaW5kZXg7XHJcblx0ICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5zY2FuSGV4TGl0ZXJhbChzdGFydCk7XHJcblx0ICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgaWYgKGNoID09PSAnYicgfHwgY2ggPT09ICdCJykge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgKyt0aGlzLmluZGV4O1xyXG5cdCAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2NhbkJpbmFyeUxpdGVyYWwoc3RhcnQpO1xyXG5cdCAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgIGlmIChjaCA9PT0gJ28nIHx8IGNoID09PSAnTycpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnNjYW5PY3RhbExpdGVyYWwoY2gsIHN0YXJ0KTtcclxuXHQgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICBpZiAoY2ggJiYgY2hhcmFjdGVyXzEuQ2hhcmFjdGVyLmlzT2N0YWxEaWdpdChjaC5jaGFyQ29kZUF0KDApKSkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuaXNJbXBsaWNpdE9jdGFsTGl0ZXJhbCgpKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2Nhbk9jdGFsTGl0ZXJhbChjaCwgc3RhcnQpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgIHdoaWxlIChjaGFyYWN0ZXJfMS5DaGFyYWN0ZXIuaXNEZWNpbWFsRGlnaXQodGhpcy5zb3VyY2UuY2hhckNvZGVBdCh0aGlzLmluZGV4KSkpIHtcclxuXHQgICAgICAgICAgICAgICAgbnVtICs9IHRoaXMuc291cmNlW3RoaXMuaW5kZXgrK107XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgIGNoID0gdGhpcy5zb3VyY2VbdGhpcy5pbmRleF07XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICBpZiAoY2ggPT09ICcuJykge1xyXG5cdCAgICAgICAgICAgIG51bSArPSB0aGlzLnNvdXJjZVt0aGlzLmluZGV4KytdO1xyXG5cdCAgICAgICAgICAgIHdoaWxlIChjaGFyYWN0ZXJfMS5DaGFyYWN0ZXIuaXNEZWNpbWFsRGlnaXQodGhpcy5zb3VyY2UuY2hhckNvZGVBdCh0aGlzLmluZGV4KSkpIHtcclxuXHQgICAgICAgICAgICAgICAgbnVtICs9IHRoaXMuc291cmNlW3RoaXMuaW5kZXgrK107XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgIGNoID0gdGhpcy5zb3VyY2VbdGhpcy5pbmRleF07XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICBpZiAoY2ggPT09ICdlJyB8fCBjaCA9PT0gJ0UnKSB7XHJcblx0ICAgICAgICAgICAgbnVtICs9IHRoaXMuc291cmNlW3RoaXMuaW5kZXgrK107XHJcblx0ICAgICAgICAgICAgY2ggPSB0aGlzLnNvdXJjZVt0aGlzLmluZGV4XTtcclxuXHQgICAgICAgICAgICBpZiAoY2ggPT09ICcrJyB8fCBjaCA9PT0gJy0nKSB7XHJcblx0ICAgICAgICAgICAgICAgIG51bSArPSB0aGlzLnNvdXJjZVt0aGlzLmluZGV4KytdO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICBpZiAoY2hhcmFjdGVyXzEuQ2hhcmFjdGVyLmlzRGVjaW1hbERpZ2l0KHRoaXMuc291cmNlLmNoYXJDb2RlQXQodGhpcy5pbmRleCkpKSB7XHJcblx0ICAgICAgICAgICAgICAgIHdoaWxlIChjaGFyYWN0ZXJfMS5DaGFyYWN0ZXIuaXNEZWNpbWFsRGlnaXQodGhpcy5zb3VyY2UuY2hhckNvZGVBdCh0aGlzLmluZGV4KSkpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgIG51bSArPSB0aGlzLnNvdXJjZVt0aGlzLmluZGV4KytdO1xyXG5cdCAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgIGVsc2Uge1xyXG5cdCAgICAgICAgICAgICAgICB0aGlzLnRocm93VW5leHBlY3RlZFRva2VuKCk7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgaWYgKGNoYXJhY3Rlcl8xLkNoYXJhY3Rlci5pc0lkZW50aWZpZXJTdGFydCh0aGlzLnNvdXJjZS5jaGFyQ29kZUF0KHRoaXMuaW5kZXgpKSkge1xyXG5cdCAgICAgICAgICAgIHRoaXMudGhyb3dVbmV4cGVjdGVkVG9rZW4oKTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIHJldHVybiB7XHJcblx0ICAgICAgICAgICAgdHlwZTogNiAvKiBOdW1lcmljTGl0ZXJhbCAqLyxcclxuXHQgICAgICAgICAgICB2YWx1ZTogcGFyc2VGbG9hdChudW0pLFxyXG5cdCAgICAgICAgICAgIGxpbmVOdW1iZXI6IHRoaXMubGluZU51bWJlcixcclxuXHQgICAgICAgICAgICBsaW5lU3RhcnQ6IHRoaXMubGluZVN0YXJ0LFxyXG5cdCAgICAgICAgICAgIHN0YXJ0OiBzdGFydCxcclxuXHQgICAgICAgICAgICBlbmQ6IHRoaXMuaW5kZXhcclxuXHQgICAgICAgIH07XHJcblx0ICAgIH07XHJcblx0ICAgIC8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLWxpdGVyYWxzLXN0cmluZy1saXRlcmFsc1xyXG5cdCAgICBTY2FubmVyLnByb3RvdHlwZS5zY2FuU3RyaW5nTGl0ZXJhbCA9IGZ1bmN0aW9uICgpIHtcclxuXHQgICAgICAgIHZhciBzdGFydCA9IHRoaXMuaW5kZXg7XHJcblx0ICAgICAgICB2YXIgcXVvdGUgPSB0aGlzLnNvdXJjZVtzdGFydF07XHJcblx0ICAgICAgICBhc3NlcnRfMS5hc3NlcnQoKHF1b3RlID09PSAnXFwnJyB8fCBxdW90ZSA9PT0gJ1wiJyksICdTdHJpbmcgbGl0ZXJhbCBtdXN0IHN0YXJ0cyB3aXRoIGEgcXVvdGUnKTtcclxuXHQgICAgICAgICsrdGhpcy5pbmRleDtcclxuXHQgICAgICAgIHZhciBvY3RhbCA9IGZhbHNlO1xyXG5cdCAgICAgICAgdmFyIHN0ciA9ICcnO1xyXG5cdCAgICAgICAgd2hpbGUgKCF0aGlzLmVvZigpKSB7XHJcblx0ICAgICAgICAgICAgdmFyIGNoID0gdGhpcy5zb3VyY2VbdGhpcy5pbmRleCsrXTtcclxuXHQgICAgICAgICAgICBpZiAoY2ggPT09IHF1b3RlKSB7XHJcblx0ICAgICAgICAgICAgICAgIHF1b3RlID0gJyc7XHJcblx0ICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICBlbHNlIGlmIChjaCA9PT0gJ1xcXFwnKSB7XHJcblx0ICAgICAgICAgICAgICAgIGNoID0gdGhpcy5zb3VyY2VbdGhpcy5pbmRleCsrXTtcclxuXHQgICAgICAgICAgICAgICAgaWYgKCFjaCB8fCAhY2hhcmFjdGVyXzEuQ2hhcmFjdGVyLmlzTGluZVRlcm1pbmF0b3IoY2guY2hhckNvZGVBdCgwKSkpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgIHN3aXRjaCAoY2gpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBjYXNlICd1JzpcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuc291cmNlW3RoaXMuaW5kZXhdID09PSAneycpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICsrdGhpcy5pbmRleDtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0ciArPSB0aGlzLnNjYW5Vbmljb2RlQ29kZVBvaW50RXNjYXBlKCk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgdW5lc2NhcGVkXzEgPSB0aGlzLnNjYW5IZXhFc2NhcGUoY2gpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHVuZXNjYXBlZF8xID09PSBudWxsKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy50aHJvd1VuZXhwZWN0ZWRUb2tlbigpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RyICs9IHVuZXNjYXBlZF8xO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ3gnOlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgdW5lc2NhcGVkID0gdGhpcy5zY2FuSGV4RXNjYXBlKGNoKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHVuZXNjYXBlZCA9PT0gbnVsbCkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy50aHJvd1VuZXhwZWN0ZWRUb2tlbihtZXNzYWdlc18xLk1lc3NhZ2VzLkludmFsaWRIZXhFc2NhcGVTZXF1ZW5jZSk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RyICs9IHVuZXNjYXBlZDtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnbic6XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0ciArPSAnXFxuJztcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAncic6XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0ciArPSAnXFxyJztcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAndCc6XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0ciArPSAnXFx0JztcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnYic6XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0ciArPSAnXFxiJztcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnZic6XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0ciArPSAnXFxmJztcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAndic6XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0ciArPSAnXFx4MEInO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBjYXNlICc4JzpcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBjYXNlICc5JzpcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RyICs9IGNoO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnRvbGVyYXRlVW5leHBlY3RlZFRva2VuKCk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjaCAmJiBjaGFyYWN0ZXJfMS5DaGFyYWN0ZXIuaXNPY3RhbERpZ2l0KGNoLmNoYXJDb2RlQXQoMCkpKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgb2N0VG9EZWMgPSB0aGlzLm9jdGFsVG9EZWNpbWFsKGNoKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9jdGFsID0gb2N0VG9EZWMub2N0YWwgfHwgb2N0YWw7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHIgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShvY3RUb0RlYy5jb2RlKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0ciArPSBjaDtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuXHQgICAgICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICBlbHNlIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICsrdGhpcy5saW5lTnVtYmVyO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKGNoID09PSAnXFxyJyAmJiB0aGlzLnNvdXJjZVt0aGlzLmluZGV4XSA9PT0gJ1xcbicpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICArK3RoaXMuaW5kZXg7XHJcblx0ICAgICAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgICAgICB0aGlzLmxpbmVTdGFydCA9IHRoaXMuaW5kZXg7XHJcblx0ICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgZWxzZSBpZiAoY2hhcmFjdGVyXzEuQ2hhcmFjdGVyLmlzTGluZVRlcm1pbmF0b3IoY2guY2hhckNvZGVBdCgwKSkpIHtcclxuXHQgICAgICAgICAgICAgICAgYnJlYWs7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgIGVsc2Uge1xyXG5cdCAgICAgICAgICAgICAgICBzdHIgKz0gY2g7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgaWYgKHF1b3RlICE9PSAnJykge1xyXG5cdCAgICAgICAgICAgIHRoaXMuaW5kZXggPSBzdGFydDtcclxuXHQgICAgICAgICAgICB0aGlzLnRocm93VW5leHBlY3RlZFRva2VuKCk7XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICByZXR1cm4ge1xyXG5cdCAgICAgICAgICAgIHR5cGU6IDggLyogU3RyaW5nTGl0ZXJhbCAqLyxcclxuXHQgICAgICAgICAgICB2YWx1ZTogc3RyLFxyXG5cdCAgICAgICAgICAgIG9jdGFsOiBvY3RhbCxcclxuXHQgICAgICAgICAgICBsaW5lTnVtYmVyOiB0aGlzLmxpbmVOdW1iZXIsXHJcblx0ICAgICAgICAgICAgbGluZVN0YXJ0OiB0aGlzLmxpbmVTdGFydCxcclxuXHQgICAgICAgICAgICBzdGFydDogc3RhcnQsXHJcblx0ICAgICAgICAgICAgZW5kOiB0aGlzLmluZGV4XHJcblx0ICAgICAgICB9O1xyXG5cdCAgICB9O1xyXG5cdCAgICAvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy10ZW1wbGF0ZS1saXRlcmFsLWxleGljYWwtY29tcG9uZW50c1xyXG5cdCAgICBTY2FubmVyLnByb3RvdHlwZS5zY2FuVGVtcGxhdGUgPSBmdW5jdGlvbiAoKSB7XHJcblx0ICAgICAgICB2YXIgY29va2VkID0gJyc7XHJcblx0ICAgICAgICB2YXIgdGVybWluYXRlZCA9IGZhbHNlO1xyXG5cdCAgICAgICAgdmFyIHN0YXJ0ID0gdGhpcy5pbmRleDtcclxuXHQgICAgICAgIHZhciBoZWFkID0gKHRoaXMuc291cmNlW3N0YXJ0XSA9PT0gJ2AnKTtcclxuXHQgICAgICAgIHZhciB0YWlsID0gZmFsc2U7XHJcblx0ICAgICAgICB2YXIgcmF3T2Zmc2V0ID0gMjtcclxuXHQgICAgICAgICsrdGhpcy5pbmRleDtcclxuXHQgICAgICAgIHdoaWxlICghdGhpcy5lb2YoKSkge1xyXG5cdCAgICAgICAgICAgIHZhciBjaCA9IHRoaXMuc291cmNlW3RoaXMuaW5kZXgrK107XHJcblx0ICAgICAgICAgICAgaWYgKGNoID09PSAnYCcpIHtcclxuXHQgICAgICAgICAgICAgICAgcmF3T2Zmc2V0ID0gMTtcclxuXHQgICAgICAgICAgICAgICAgdGFpbCA9IHRydWU7XHJcblx0ICAgICAgICAgICAgICAgIHRlcm1pbmF0ZWQgPSB0cnVlO1xyXG5cdCAgICAgICAgICAgICAgICBicmVhaztcclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgZWxzZSBpZiAoY2ggPT09ICckJykge1xyXG5cdCAgICAgICAgICAgICAgICBpZiAodGhpcy5zb3VyY2VbdGhpcy5pbmRleF0gPT09ICd7Jykge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgdGhpcy5jdXJseVN0YWNrLnB1c2goJyR7Jyk7XHJcblx0ICAgICAgICAgICAgICAgICAgICArK3RoaXMuaW5kZXg7XHJcblx0ICAgICAgICAgICAgICAgICAgICB0ZXJtaW5hdGVkID0gdHJ1ZTtcclxuXHQgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cdCAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgIGNvb2tlZCArPSBjaDtcclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgZWxzZSBpZiAoY2ggPT09ICdcXFxcJykge1xyXG5cdCAgICAgICAgICAgICAgICBjaCA9IHRoaXMuc291cmNlW3RoaXMuaW5kZXgrK107XHJcblx0ICAgICAgICAgICAgICAgIGlmICghY2hhcmFjdGVyXzEuQ2hhcmFjdGVyLmlzTGluZVRlcm1pbmF0b3IoY2guY2hhckNvZGVBdCgwKSkpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgIHN3aXRjaCAoY2gpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBjYXNlICduJzpcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29va2VkICs9ICdcXG4nO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBjYXNlICdyJzpcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29va2VkICs9ICdcXHInO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBjYXNlICd0JzpcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29va2VkICs9ICdcXHQnO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBjYXNlICd1JzpcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuc291cmNlW3RoaXMuaW5kZXhdID09PSAneycpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICsrdGhpcy5pbmRleDtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvb2tlZCArPSB0aGlzLnNjYW5Vbmljb2RlQ29kZVBvaW50RXNjYXBlKCk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcmVzdG9yZSA9IHRoaXMuaW5kZXg7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgdW5lc2NhcGVkXzIgPSB0aGlzLnNjYW5IZXhFc2NhcGUoY2gpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHVuZXNjYXBlZF8yICE9PSBudWxsKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29va2VkICs9IHVuZXNjYXBlZF8yO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5pbmRleCA9IHJlc3RvcmU7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29va2VkICs9IGNoO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ3gnOlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgdW5lc2NhcGVkID0gdGhpcy5zY2FuSGV4RXNjYXBlKGNoKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHVuZXNjYXBlZCA9PT0gbnVsbCkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy50aHJvd1VuZXhwZWN0ZWRUb2tlbihtZXNzYWdlc18xLk1lc3NhZ2VzLkludmFsaWRIZXhFc2NhcGVTZXF1ZW5jZSk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29va2VkICs9IHVuZXNjYXBlZDtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnYic6XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvb2tlZCArPSAnXFxiJztcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnZic6XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvb2tlZCArPSAnXFxmJztcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAndic6XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvb2tlZCArPSAnXFx2JztcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNoID09PSAnMCcpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjaGFyYWN0ZXJfMS5DaGFyYWN0ZXIuaXNEZWNpbWFsRGlnaXQodGhpcy5zb3VyY2UuY2hhckNvZGVBdCh0aGlzLmluZGV4KSkpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBJbGxlZ2FsOiBcXDAxIFxcMDIgYW5kIHNvIG9uXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy50aHJvd1VuZXhwZWN0ZWRUb2tlbihtZXNzYWdlc18xLk1lc3NhZ2VzLlRlbXBsYXRlT2N0YWxMaXRlcmFsKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvb2tlZCArPSAnXFwwJztcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChjaGFyYWN0ZXJfMS5DaGFyYWN0ZXIuaXNPY3RhbERpZ2l0KGNoLmNoYXJDb2RlQXQoMCkpKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBJbGxlZ2FsOiBcXDEgXFwyXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnRocm93VW5leHBlY3RlZFRva2VuKG1lc3NhZ2VzXzEuTWVzc2FnZXMuVGVtcGxhdGVPY3RhbExpdGVyYWwpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29va2VkICs9IGNoO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgIGVsc2Uge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgKyt0aGlzLmxpbmVOdW1iZXI7XHJcblx0ICAgICAgICAgICAgICAgICAgICBpZiAoY2ggPT09ICdcXHInICYmIHRoaXMuc291cmNlW3RoaXMuaW5kZXhdID09PSAnXFxuJykge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICsrdGhpcy5pbmRleDtcclxuXHQgICAgICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgICAgIHRoaXMubGluZVN0YXJ0ID0gdGhpcy5pbmRleDtcclxuXHQgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICBlbHNlIGlmIChjaGFyYWN0ZXJfMS5DaGFyYWN0ZXIuaXNMaW5lVGVybWluYXRvcihjaC5jaGFyQ29kZUF0KDApKSkge1xyXG5cdCAgICAgICAgICAgICAgICArK3RoaXMubGluZU51bWJlcjtcclxuXHQgICAgICAgICAgICAgICAgaWYgKGNoID09PSAnXFxyJyAmJiB0aGlzLnNvdXJjZVt0aGlzLmluZGV4XSA9PT0gJ1xcbicpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICsrdGhpcy5pbmRleDtcclxuXHQgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICB0aGlzLmxpbmVTdGFydCA9IHRoaXMuaW5kZXg7XHJcblx0ICAgICAgICAgICAgICAgIGNvb2tlZCArPSAnXFxuJztcclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgZWxzZSB7XHJcblx0ICAgICAgICAgICAgICAgIGNvb2tlZCArPSBjaDtcclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICBpZiAoIXRlcm1pbmF0ZWQpIHtcclxuXHQgICAgICAgICAgICB0aGlzLnRocm93VW5leHBlY3RlZFRva2VuKCk7XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICBpZiAoIWhlYWQpIHtcclxuXHQgICAgICAgICAgICB0aGlzLmN1cmx5U3RhY2sucG9wKCk7XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICByZXR1cm4ge1xyXG5cdCAgICAgICAgICAgIHR5cGU6IDEwIC8qIFRlbXBsYXRlICovLFxyXG5cdCAgICAgICAgICAgIHZhbHVlOiB0aGlzLnNvdXJjZS5zbGljZShzdGFydCArIDEsIHRoaXMuaW5kZXggLSByYXdPZmZzZXQpLFxyXG5cdCAgICAgICAgICAgIGNvb2tlZDogY29va2VkLFxyXG5cdCAgICAgICAgICAgIGhlYWQ6IGhlYWQsXHJcblx0ICAgICAgICAgICAgdGFpbDogdGFpbCxcclxuXHQgICAgICAgICAgICBsaW5lTnVtYmVyOiB0aGlzLmxpbmVOdW1iZXIsXHJcblx0ICAgICAgICAgICAgbGluZVN0YXJ0OiB0aGlzLmxpbmVTdGFydCxcclxuXHQgICAgICAgICAgICBzdGFydDogc3RhcnQsXHJcblx0ICAgICAgICAgICAgZW5kOiB0aGlzLmluZGV4XHJcblx0ICAgICAgICB9O1xyXG5cdCAgICB9O1xyXG5cdCAgICAvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1saXRlcmFscy1yZWd1bGFyLWV4cHJlc3Npb24tbGl0ZXJhbHNcclxuXHQgICAgU2Nhbm5lci5wcm90b3R5cGUudGVzdFJlZ0V4cCA9IGZ1bmN0aW9uIChwYXR0ZXJuLCBmbGFncykge1xyXG5cdCAgICAgICAgLy8gVGhlIEJNUCBjaGFyYWN0ZXIgdG8gdXNlIGFzIGEgcmVwbGFjZW1lbnQgZm9yIGFzdHJhbCBzeW1ib2xzIHdoZW5cclxuXHQgICAgICAgIC8vIHRyYW5zbGF0aW5nIGFuIEVTNiBcInVcIi1mbGFnZ2VkIHBhdHRlcm4gdG8gYW4gRVM1LWNvbXBhdGlibGVcclxuXHQgICAgICAgIC8vIGFwcHJveGltYXRpb24uXHJcblx0ICAgICAgICAvLyBOb3RlOiByZXBsYWNpbmcgd2l0aCAnXFx1RkZGRicgZW5hYmxlcyBmYWxzZSBwb3NpdGl2ZXMgaW4gdW5saWtlbHlcclxuXHQgICAgICAgIC8vIHNjZW5hcmlvcy4gRm9yIGV4YW1wbGUsIGBbXFx1ezEwNDRmfS1cXHV7MTA0NDB9XWAgaXMgYW4gaW52YWxpZFxyXG5cdCAgICAgICAgLy8gcGF0dGVybiB0aGF0IHdvdWxkIG5vdCBiZSBkZXRlY3RlZCBieSB0aGlzIHN1YnN0aXR1dGlvbi5cclxuXHQgICAgICAgIHZhciBhc3RyYWxTdWJzdGl0dXRlID0gJ1xcdUZGRkYnO1xyXG5cdCAgICAgICAgdmFyIHRtcCA9IHBhdHRlcm47XHJcblx0ICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XHJcblx0ICAgICAgICBpZiAoZmxhZ3MuaW5kZXhPZigndScpID49IDApIHtcclxuXHQgICAgICAgICAgICB0bXAgPSB0bXBcclxuXHQgICAgICAgICAgICAgICAgLnJlcGxhY2UoL1xcXFx1XFx7KFswLTlhLWZBLUZdKylcXH18XFxcXHUoW2EtZkEtRjAtOV17NH0pL2csIGZ1bmN0aW9uICgkMCwgJDEsICQyKSB7XHJcblx0ICAgICAgICAgICAgICAgIHZhciBjb2RlUG9pbnQgPSBwYXJzZUludCgkMSB8fCAkMiwgMTYpO1xyXG5cdCAgICAgICAgICAgICAgICBpZiAoY29kZVBvaW50ID4gMHgxMEZGRkYpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgIHNlbGYudGhyb3dVbmV4cGVjdGVkVG9rZW4obWVzc2FnZXNfMS5NZXNzYWdlcy5JbnZhbGlkUmVnRXhwKTtcclxuXHQgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICBpZiAoY29kZVBvaW50IDw9IDB4RkZGRikge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUoY29kZVBvaW50KTtcclxuXHQgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICByZXR1cm4gYXN0cmFsU3Vic3RpdHV0ZTtcclxuXHQgICAgICAgICAgICB9KVxyXG5cdCAgICAgICAgICAgICAgICAucmVwbGFjZSgvW1xcdUQ4MDAtXFx1REJGRl1bXFx1REMwMC1cXHVERkZGXS9nLCBhc3RyYWxTdWJzdGl0dXRlKTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIC8vIEZpcnN0LCBkZXRlY3QgaW52YWxpZCByZWd1bGFyIGV4cHJlc3Npb25zLlxyXG5cdCAgICAgICAgdHJ5IHtcclxuXHQgICAgICAgICAgICBSZWdFeHAodG1wKTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIGNhdGNoIChlKSB7XHJcblx0ICAgICAgICAgICAgdGhpcy50aHJvd1VuZXhwZWN0ZWRUb2tlbihtZXNzYWdlc18xLk1lc3NhZ2VzLkludmFsaWRSZWdFeHApO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgLy8gUmV0dXJuIGEgcmVndWxhciBleHByZXNzaW9uIG9iamVjdCBmb3IgdGhpcyBwYXR0ZXJuLWZsYWcgcGFpciwgb3JcclxuXHQgICAgICAgIC8vIGBudWxsYCBpbiBjYXNlIHRoZSBjdXJyZW50IGVudmlyb25tZW50IGRvZXNuJ3Qgc3VwcG9ydCB0aGUgZmxhZ3MgaXRcclxuXHQgICAgICAgIC8vIHVzZXMuXHJcblx0ICAgICAgICB0cnkge1xyXG5cdCAgICAgICAgICAgIHJldHVybiBuZXcgUmVnRXhwKHBhdHRlcm4sIGZsYWdzKTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIGNhdGNoIChleGNlcHRpb24pIHtcclxuXHQgICAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xyXG5cdCAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICB9O1xyXG5cdCAgICBTY2FubmVyLnByb3RvdHlwZS5zY2FuUmVnRXhwQm9keSA9IGZ1bmN0aW9uICgpIHtcclxuXHQgICAgICAgIHZhciBjaCA9IHRoaXMuc291cmNlW3RoaXMuaW5kZXhdO1xyXG5cdCAgICAgICAgYXNzZXJ0XzEuYXNzZXJ0KGNoID09PSAnLycsICdSZWd1bGFyIGV4cHJlc3Npb24gbGl0ZXJhbCBtdXN0IHN0YXJ0IHdpdGggYSBzbGFzaCcpO1xyXG5cdCAgICAgICAgdmFyIHN0ciA9IHRoaXMuc291cmNlW3RoaXMuaW5kZXgrK107XHJcblx0ICAgICAgICB2YXIgY2xhc3NNYXJrZXIgPSBmYWxzZTtcclxuXHQgICAgICAgIHZhciB0ZXJtaW5hdGVkID0gZmFsc2U7XHJcblx0ICAgICAgICB3aGlsZSAoIXRoaXMuZW9mKCkpIHtcclxuXHQgICAgICAgICAgICBjaCA9IHRoaXMuc291cmNlW3RoaXMuaW5kZXgrK107XHJcblx0ICAgICAgICAgICAgc3RyICs9IGNoO1xyXG5cdCAgICAgICAgICAgIGlmIChjaCA9PT0gJ1xcXFwnKSB7XHJcblx0ICAgICAgICAgICAgICAgIGNoID0gdGhpcy5zb3VyY2VbdGhpcy5pbmRleCsrXTtcclxuXHQgICAgICAgICAgICAgICAgLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtbGl0ZXJhbHMtcmVndWxhci1leHByZXNzaW9uLWxpdGVyYWxzXHJcblx0ICAgICAgICAgICAgICAgIGlmIChjaGFyYWN0ZXJfMS5DaGFyYWN0ZXIuaXNMaW5lVGVybWluYXRvcihjaC5jaGFyQ29kZUF0KDApKSkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgdGhpcy50aHJvd1VuZXhwZWN0ZWRUb2tlbihtZXNzYWdlc18xLk1lc3NhZ2VzLlVudGVybWluYXRlZFJlZ0V4cCk7XHJcblx0ICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgc3RyICs9IGNoO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICBlbHNlIGlmIChjaGFyYWN0ZXJfMS5DaGFyYWN0ZXIuaXNMaW5lVGVybWluYXRvcihjaC5jaGFyQ29kZUF0KDApKSkge1xyXG5cdCAgICAgICAgICAgICAgICB0aGlzLnRocm93VW5leHBlY3RlZFRva2VuKG1lc3NhZ2VzXzEuTWVzc2FnZXMuVW50ZXJtaW5hdGVkUmVnRXhwKTtcclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgZWxzZSBpZiAoY2xhc3NNYXJrZXIpIHtcclxuXHQgICAgICAgICAgICAgICAgaWYgKGNoID09PSAnXScpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgIGNsYXNzTWFya2VyID0gZmFsc2U7XHJcblx0ICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgZWxzZSB7XHJcblx0ICAgICAgICAgICAgICAgIGlmIChjaCA9PT0gJy8nKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICB0ZXJtaW5hdGVkID0gdHJ1ZTtcclxuXHQgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cdCAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgIGVsc2UgaWYgKGNoID09PSAnWycpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgIGNsYXNzTWFya2VyID0gdHJ1ZTtcclxuXHQgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIGlmICghdGVybWluYXRlZCkge1xyXG5cdCAgICAgICAgICAgIHRoaXMudGhyb3dVbmV4cGVjdGVkVG9rZW4obWVzc2FnZXNfMS5NZXNzYWdlcy5VbnRlcm1pbmF0ZWRSZWdFeHApO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgLy8gRXhjbHVkZSBsZWFkaW5nIGFuZCB0cmFpbGluZyBzbGFzaC5cclxuXHQgICAgICAgIHJldHVybiBzdHIuc3Vic3RyKDEsIHN0ci5sZW5ndGggLSAyKTtcclxuXHQgICAgfTtcclxuXHQgICAgU2Nhbm5lci5wcm90b3R5cGUuc2NhblJlZ0V4cEZsYWdzID0gZnVuY3Rpb24gKCkge1xyXG5cdCAgICAgICAgdmFyIHN0ciA9ICcnO1xyXG5cdCAgICAgICAgdmFyIGZsYWdzID0gJyc7XHJcblx0ICAgICAgICB3aGlsZSAoIXRoaXMuZW9mKCkpIHtcclxuXHQgICAgICAgICAgICB2YXIgY2ggPSB0aGlzLnNvdXJjZVt0aGlzLmluZGV4XTtcclxuXHQgICAgICAgICAgICBpZiAoIWNoYXJhY3Rlcl8xLkNoYXJhY3Rlci5pc0lkZW50aWZpZXJQYXJ0KGNoLmNoYXJDb2RlQXQoMCkpKSB7XHJcblx0ICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICArK3RoaXMuaW5kZXg7XHJcblx0ICAgICAgICAgICAgaWYgKGNoID09PSAnXFxcXCcgJiYgIXRoaXMuZW9mKCkpIHtcclxuXHQgICAgICAgICAgICAgICAgY2ggPSB0aGlzLnNvdXJjZVt0aGlzLmluZGV4XTtcclxuXHQgICAgICAgICAgICAgICAgaWYgKGNoID09PSAndScpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICsrdGhpcy5pbmRleDtcclxuXHQgICAgICAgICAgICAgICAgICAgIHZhciByZXN0b3JlID0gdGhpcy5pbmRleDtcclxuXHQgICAgICAgICAgICAgICAgICAgIHZhciBjaGFyID0gdGhpcy5zY2FuSGV4RXNjYXBlKCd1Jyk7XHJcblx0ICAgICAgICAgICAgICAgICAgICBpZiAoY2hhciAhPT0gbnVsbCkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGZsYWdzICs9IGNoYXI7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChzdHIgKz0gJ1xcXFx1JzsgcmVzdG9yZSA8IHRoaXMuaW5kZXg7ICsrcmVzdG9yZSkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHIgKz0gdGhpcy5zb3VyY2VbcmVzdG9yZV07XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5pbmRleCA9IHJlc3RvcmU7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgZmxhZ3MgKz0gJ3UnO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHN0ciArPSAnXFxcXHUnO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICAgICAgdGhpcy50b2xlcmF0ZVVuZXhwZWN0ZWRUb2tlbigpO1xyXG5cdCAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgIGVsc2Uge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgc3RyICs9ICdcXFxcJztcclxuXHQgICAgICAgICAgICAgICAgICAgIHRoaXMudG9sZXJhdGVVbmV4cGVjdGVkVG9rZW4oKTtcclxuXHQgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICBlbHNlIHtcclxuXHQgICAgICAgICAgICAgICAgZmxhZ3MgKz0gY2g7XHJcblx0ICAgICAgICAgICAgICAgIHN0ciArPSBjaDtcclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICByZXR1cm4gZmxhZ3M7XHJcblx0ICAgIH07XHJcblx0ICAgIFNjYW5uZXIucHJvdG90eXBlLnNjYW5SZWdFeHAgPSBmdW5jdGlvbiAoKSB7XHJcblx0ICAgICAgICB2YXIgc3RhcnQgPSB0aGlzLmluZGV4O1xyXG5cdCAgICAgICAgdmFyIHBhdHRlcm4gPSB0aGlzLnNjYW5SZWdFeHBCb2R5KCk7XHJcblx0ICAgICAgICB2YXIgZmxhZ3MgPSB0aGlzLnNjYW5SZWdFeHBGbGFncygpO1xyXG5cdCAgICAgICAgdmFyIHZhbHVlID0gdGhpcy50ZXN0UmVnRXhwKHBhdHRlcm4sIGZsYWdzKTtcclxuXHQgICAgICAgIHJldHVybiB7XHJcblx0ICAgICAgICAgICAgdHlwZTogOSAvKiBSZWd1bGFyRXhwcmVzc2lvbiAqLyxcclxuXHQgICAgICAgICAgICB2YWx1ZTogJycsXHJcblx0ICAgICAgICAgICAgcGF0dGVybjogcGF0dGVybixcclxuXHQgICAgICAgICAgICBmbGFnczogZmxhZ3MsXHJcblx0ICAgICAgICAgICAgcmVnZXg6IHZhbHVlLFxyXG5cdCAgICAgICAgICAgIGxpbmVOdW1iZXI6IHRoaXMubGluZU51bWJlcixcclxuXHQgICAgICAgICAgICBsaW5lU3RhcnQ6IHRoaXMubGluZVN0YXJ0LFxyXG5cdCAgICAgICAgICAgIHN0YXJ0OiBzdGFydCxcclxuXHQgICAgICAgICAgICBlbmQ6IHRoaXMuaW5kZXhcclxuXHQgICAgICAgIH07XHJcblx0ICAgIH07XHJcblx0ICAgIFNjYW5uZXIucHJvdG90eXBlLmxleCA9IGZ1bmN0aW9uICgpIHtcclxuXHQgICAgICAgIGlmICh0aGlzLmVvZigpKSB7XHJcblx0ICAgICAgICAgICAgcmV0dXJuIHtcclxuXHQgICAgICAgICAgICAgICAgdHlwZTogMiAvKiBFT0YgKi8sXHJcblx0ICAgICAgICAgICAgICAgIHZhbHVlOiAnJyxcclxuXHQgICAgICAgICAgICAgICAgbGluZU51bWJlcjogdGhpcy5saW5lTnVtYmVyLFxyXG5cdCAgICAgICAgICAgICAgICBsaW5lU3RhcnQ6IHRoaXMubGluZVN0YXJ0LFxyXG5cdCAgICAgICAgICAgICAgICBzdGFydDogdGhpcy5pbmRleCxcclxuXHQgICAgICAgICAgICAgICAgZW5kOiB0aGlzLmluZGV4XHJcblx0ICAgICAgICAgICAgfTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIHZhciBjcCA9IHRoaXMuc291cmNlLmNoYXJDb2RlQXQodGhpcy5pbmRleCk7XHJcblx0ICAgICAgICBpZiAoY2hhcmFjdGVyXzEuQ2hhcmFjdGVyLmlzSWRlbnRpZmllclN0YXJ0KGNwKSkge1xyXG5cdCAgICAgICAgICAgIHJldHVybiB0aGlzLnNjYW5JZGVudGlmaWVyKCk7XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICAvLyBWZXJ5IGNvbW1vbjogKCBhbmQgKSBhbmQgO1xyXG5cdCAgICAgICAgaWYgKGNwID09PSAweDI4IHx8IGNwID09PSAweDI5IHx8IGNwID09PSAweDNCKSB7XHJcblx0ICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2NhblB1bmN0dWF0b3IoKTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIC8vIFN0cmluZyBsaXRlcmFsIHN0YXJ0cyB3aXRoIHNpbmdsZSBxdW90ZSAoVSswMDI3KSBvciBkb3VibGUgcXVvdGUgKFUrMDAyMikuXHJcblx0ICAgICAgICBpZiAoY3AgPT09IDB4MjcgfHwgY3AgPT09IDB4MjIpIHtcclxuXHQgICAgICAgICAgICByZXR1cm4gdGhpcy5zY2FuU3RyaW5nTGl0ZXJhbCgpO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgLy8gRG90ICguKSBVKzAwMkUgY2FuIGFsc28gc3RhcnQgYSBmbG9hdGluZy1wb2ludCBudW1iZXIsIGhlbmNlIHRoZSBuZWVkXHJcblx0ICAgICAgICAvLyB0byBjaGVjayB0aGUgbmV4dCBjaGFyYWN0ZXIuXHJcblx0ICAgICAgICBpZiAoY3AgPT09IDB4MkUpIHtcclxuXHQgICAgICAgICAgICBpZiAoY2hhcmFjdGVyXzEuQ2hhcmFjdGVyLmlzRGVjaW1hbERpZ2l0KHRoaXMuc291cmNlLmNoYXJDb2RlQXQodGhpcy5pbmRleCArIDEpKSkge1xyXG5cdCAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5zY2FuTnVtZXJpY0xpdGVyYWwoKTtcclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2NhblB1bmN0dWF0b3IoKTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIGlmIChjaGFyYWN0ZXJfMS5DaGFyYWN0ZXIuaXNEZWNpbWFsRGlnaXQoY3ApKSB7XHJcblx0ICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2Nhbk51bWVyaWNMaXRlcmFsKCk7XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICAvLyBUZW1wbGF0ZSBsaXRlcmFscyBzdGFydCB3aXRoIGAgKFUrMDA2MCkgZm9yIHRlbXBsYXRlIGhlYWRcclxuXHQgICAgICAgIC8vIG9yIH0gKFUrMDA3RCkgZm9yIHRlbXBsYXRlIG1pZGRsZSBvciB0ZW1wbGF0ZSB0YWlsLlxyXG5cdCAgICAgICAgaWYgKGNwID09PSAweDYwIHx8IChjcCA9PT0gMHg3RCAmJiB0aGlzLmN1cmx5U3RhY2tbdGhpcy5jdXJseVN0YWNrLmxlbmd0aCAtIDFdID09PSAnJHsnKSkge1xyXG5cdCAgICAgICAgICAgIHJldHVybiB0aGlzLnNjYW5UZW1wbGF0ZSgpO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgLy8gUG9zc2libGUgaWRlbnRpZmllciBzdGFydCBpbiBhIHN1cnJvZ2F0ZSBwYWlyLlxyXG5cdCAgICAgICAgaWYgKGNwID49IDB4RDgwMCAmJiBjcCA8IDB4REZGRikge1xyXG5cdCAgICAgICAgICAgIGlmIChjaGFyYWN0ZXJfMS5DaGFyYWN0ZXIuaXNJZGVudGlmaWVyU3RhcnQodGhpcy5jb2RlUG9pbnRBdCh0aGlzLmluZGV4KSkpIHtcclxuXHQgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2NhbklkZW50aWZpZXIoKTtcclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICByZXR1cm4gdGhpcy5zY2FuUHVuY3R1YXRvcigpO1xyXG5cdCAgICB9O1xyXG5cdCAgICByZXR1cm4gU2Nhbm5lcjtcclxuXHR9KCkpO1xyXG5cdGV4cG9ydHMuU2Nhbm5lciA9IFNjYW5uZXI7XHJcblxuXG4vKioqLyB9LFxuLyogMTMgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG5cdFwidXNlIHN0cmljdFwiO1xyXG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuXHRleHBvcnRzLlRva2VuTmFtZSA9IHt9O1xyXG5cdGV4cG9ydHMuVG9rZW5OYW1lWzEgLyogQm9vbGVhbkxpdGVyYWwgKi9dID0gJ0Jvb2xlYW4nO1xyXG5cdGV4cG9ydHMuVG9rZW5OYW1lWzIgLyogRU9GICovXSA9ICc8ZW5kPic7XHJcblx0ZXhwb3J0cy5Ub2tlbk5hbWVbMyAvKiBJZGVudGlmaWVyICovXSA9ICdJZGVudGlmaWVyJztcclxuXHRleHBvcnRzLlRva2VuTmFtZVs0IC8qIEtleXdvcmQgKi9dID0gJ0tleXdvcmQnO1xyXG5cdGV4cG9ydHMuVG9rZW5OYW1lWzUgLyogTnVsbExpdGVyYWwgKi9dID0gJ051bGwnO1xyXG5cdGV4cG9ydHMuVG9rZW5OYW1lWzYgLyogTnVtZXJpY0xpdGVyYWwgKi9dID0gJ051bWVyaWMnO1xyXG5cdGV4cG9ydHMuVG9rZW5OYW1lWzcgLyogUHVuY3R1YXRvciAqL10gPSAnUHVuY3R1YXRvcic7XHJcblx0ZXhwb3J0cy5Ub2tlbk5hbWVbOCAvKiBTdHJpbmdMaXRlcmFsICovXSA9ICdTdHJpbmcnO1xyXG5cdGV4cG9ydHMuVG9rZW5OYW1lWzkgLyogUmVndWxhckV4cHJlc3Npb24gKi9dID0gJ1JlZ3VsYXJFeHByZXNzaW9uJztcclxuXHRleHBvcnRzLlRva2VuTmFtZVsxMCAvKiBUZW1wbGF0ZSAqL10gPSAnVGVtcGxhdGUnO1xyXG5cblxuLyoqKi8gfSxcbi8qIDE0ICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxuXHRcInVzZSBzdHJpY3RcIjtcclxuXHQvLyBHZW5lcmF0ZWQgYnkgZ2VuZXJhdGUteGh0bWwtZW50aXRpZXMuanMuIERPIE5PVCBNT0RJRlkhXHJcblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG5cdGV4cG9ydHMuWEhUTUxFbnRpdGllcyA9IHtcclxuXHQgICAgcXVvdDogJ1xcdTAwMjInLFxyXG5cdCAgICBhbXA6ICdcXHUwMDI2JyxcclxuXHQgICAgYXBvczogJ1xcdTAwMjcnLFxyXG5cdCAgICBndDogJ1xcdTAwM0UnLFxyXG5cdCAgICBuYnNwOiAnXFx1MDBBMCcsXHJcblx0ICAgIGlleGNsOiAnXFx1MDBBMScsXHJcblx0ICAgIGNlbnQ6ICdcXHUwMEEyJyxcclxuXHQgICAgcG91bmQ6ICdcXHUwMEEzJyxcclxuXHQgICAgY3VycmVuOiAnXFx1MDBBNCcsXHJcblx0ICAgIHllbjogJ1xcdTAwQTUnLFxyXG5cdCAgICBicnZiYXI6ICdcXHUwMEE2JyxcclxuXHQgICAgc2VjdDogJ1xcdTAwQTcnLFxyXG5cdCAgICB1bWw6ICdcXHUwMEE4JyxcclxuXHQgICAgY29weTogJ1xcdTAwQTknLFxyXG5cdCAgICBvcmRmOiAnXFx1MDBBQScsXHJcblx0ICAgIGxhcXVvOiAnXFx1MDBBQicsXHJcblx0ICAgIG5vdDogJ1xcdTAwQUMnLFxyXG5cdCAgICBzaHk6ICdcXHUwMEFEJyxcclxuXHQgICAgcmVnOiAnXFx1MDBBRScsXHJcblx0ICAgIG1hY3I6ICdcXHUwMEFGJyxcclxuXHQgICAgZGVnOiAnXFx1MDBCMCcsXHJcblx0ICAgIHBsdXNtbjogJ1xcdTAwQjEnLFxyXG5cdCAgICBzdXAyOiAnXFx1MDBCMicsXHJcblx0ICAgIHN1cDM6ICdcXHUwMEIzJyxcclxuXHQgICAgYWN1dGU6ICdcXHUwMEI0JyxcclxuXHQgICAgbWljcm86ICdcXHUwMEI1JyxcclxuXHQgICAgcGFyYTogJ1xcdTAwQjYnLFxyXG5cdCAgICBtaWRkb3Q6ICdcXHUwMEI3JyxcclxuXHQgICAgY2VkaWw6ICdcXHUwMEI4JyxcclxuXHQgICAgc3VwMTogJ1xcdTAwQjknLFxyXG5cdCAgICBvcmRtOiAnXFx1MDBCQScsXHJcblx0ICAgIHJhcXVvOiAnXFx1MDBCQicsXHJcblx0ICAgIGZyYWMxNDogJ1xcdTAwQkMnLFxyXG5cdCAgICBmcmFjMTI6ICdcXHUwMEJEJyxcclxuXHQgICAgZnJhYzM0OiAnXFx1MDBCRScsXHJcblx0ICAgIGlxdWVzdDogJ1xcdTAwQkYnLFxyXG5cdCAgICBBZ3JhdmU6ICdcXHUwMEMwJyxcclxuXHQgICAgQWFjdXRlOiAnXFx1MDBDMScsXHJcblx0ICAgIEFjaXJjOiAnXFx1MDBDMicsXHJcblx0ICAgIEF0aWxkZTogJ1xcdTAwQzMnLFxyXG5cdCAgICBBdW1sOiAnXFx1MDBDNCcsXHJcblx0ICAgIEFyaW5nOiAnXFx1MDBDNScsXHJcblx0ICAgIEFFbGlnOiAnXFx1MDBDNicsXHJcblx0ICAgIENjZWRpbDogJ1xcdTAwQzcnLFxyXG5cdCAgICBFZ3JhdmU6ICdcXHUwMEM4JyxcclxuXHQgICAgRWFjdXRlOiAnXFx1MDBDOScsXHJcblx0ICAgIEVjaXJjOiAnXFx1MDBDQScsXHJcblx0ICAgIEV1bWw6ICdcXHUwMENCJyxcclxuXHQgICAgSWdyYXZlOiAnXFx1MDBDQycsXHJcblx0ICAgIElhY3V0ZTogJ1xcdTAwQ0QnLFxyXG5cdCAgICBJY2lyYzogJ1xcdTAwQ0UnLFxyXG5cdCAgICBJdW1sOiAnXFx1MDBDRicsXHJcblx0ICAgIEVUSDogJ1xcdTAwRDAnLFxyXG5cdCAgICBOdGlsZGU6ICdcXHUwMEQxJyxcclxuXHQgICAgT2dyYXZlOiAnXFx1MDBEMicsXHJcblx0ICAgIE9hY3V0ZTogJ1xcdTAwRDMnLFxyXG5cdCAgICBPY2lyYzogJ1xcdTAwRDQnLFxyXG5cdCAgICBPdGlsZGU6ICdcXHUwMEQ1JyxcclxuXHQgICAgT3VtbDogJ1xcdTAwRDYnLFxyXG5cdCAgICB0aW1lczogJ1xcdTAwRDcnLFxyXG5cdCAgICBPc2xhc2g6ICdcXHUwMEQ4JyxcclxuXHQgICAgVWdyYXZlOiAnXFx1MDBEOScsXHJcblx0ICAgIFVhY3V0ZTogJ1xcdTAwREEnLFxyXG5cdCAgICBVY2lyYzogJ1xcdTAwREInLFxyXG5cdCAgICBVdW1sOiAnXFx1MDBEQycsXHJcblx0ICAgIFlhY3V0ZTogJ1xcdTAwREQnLFxyXG5cdCAgICBUSE9STjogJ1xcdTAwREUnLFxyXG5cdCAgICBzemxpZzogJ1xcdTAwREYnLFxyXG5cdCAgICBhZ3JhdmU6ICdcXHUwMEUwJyxcclxuXHQgICAgYWFjdXRlOiAnXFx1MDBFMScsXHJcblx0ICAgIGFjaXJjOiAnXFx1MDBFMicsXHJcblx0ICAgIGF0aWxkZTogJ1xcdTAwRTMnLFxyXG5cdCAgICBhdW1sOiAnXFx1MDBFNCcsXHJcblx0ICAgIGFyaW5nOiAnXFx1MDBFNScsXHJcblx0ICAgIGFlbGlnOiAnXFx1MDBFNicsXHJcblx0ICAgIGNjZWRpbDogJ1xcdTAwRTcnLFxyXG5cdCAgICBlZ3JhdmU6ICdcXHUwMEU4JyxcclxuXHQgICAgZWFjdXRlOiAnXFx1MDBFOScsXHJcblx0ICAgIGVjaXJjOiAnXFx1MDBFQScsXHJcblx0ICAgIGV1bWw6ICdcXHUwMEVCJyxcclxuXHQgICAgaWdyYXZlOiAnXFx1MDBFQycsXHJcblx0ICAgIGlhY3V0ZTogJ1xcdTAwRUQnLFxyXG5cdCAgICBpY2lyYzogJ1xcdTAwRUUnLFxyXG5cdCAgICBpdW1sOiAnXFx1MDBFRicsXHJcblx0ICAgIGV0aDogJ1xcdTAwRjAnLFxyXG5cdCAgICBudGlsZGU6ICdcXHUwMEYxJyxcclxuXHQgICAgb2dyYXZlOiAnXFx1MDBGMicsXHJcblx0ICAgIG9hY3V0ZTogJ1xcdTAwRjMnLFxyXG5cdCAgICBvY2lyYzogJ1xcdTAwRjQnLFxyXG5cdCAgICBvdGlsZGU6ICdcXHUwMEY1JyxcclxuXHQgICAgb3VtbDogJ1xcdTAwRjYnLFxyXG5cdCAgICBkaXZpZGU6ICdcXHUwMEY3JyxcclxuXHQgICAgb3NsYXNoOiAnXFx1MDBGOCcsXHJcblx0ICAgIHVncmF2ZTogJ1xcdTAwRjknLFxyXG5cdCAgICB1YWN1dGU6ICdcXHUwMEZBJyxcclxuXHQgICAgdWNpcmM6ICdcXHUwMEZCJyxcclxuXHQgICAgdXVtbDogJ1xcdTAwRkMnLFxyXG5cdCAgICB5YWN1dGU6ICdcXHUwMEZEJyxcclxuXHQgICAgdGhvcm46ICdcXHUwMEZFJyxcclxuXHQgICAgeXVtbDogJ1xcdTAwRkYnLFxyXG5cdCAgICBPRWxpZzogJ1xcdTAxNTInLFxyXG5cdCAgICBvZWxpZzogJ1xcdTAxNTMnLFxyXG5cdCAgICBTY2Fyb246ICdcXHUwMTYwJyxcclxuXHQgICAgc2Nhcm9uOiAnXFx1MDE2MScsXHJcblx0ICAgIFl1bWw6ICdcXHUwMTc4JyxcclxuXHQgICAgZm5vZjogJ1xcdTAxOTInLFxyXG5cdCAgICBjaXJjOiAnXFx1MDJDNicsXHJcblx0ICAgIHRpbGRlOiAnXFx1MDJEQycsXHJcblx0ICAgIEFscGhhOiAnXFx1MDM5MScsXHJcblx0ICAgIEJldGE6ICdcXHUwMzkyJyxcclxuXHQgICAgR2FtbWE6ICdcXHUwMzkzJyxcclxuXHQgICAgRGVsdGE6ICdcXHUwMzk0JyxcclxuXHQgICAgRXBzaWxvbjogJ1xcdTAzOTUnLFxyXG5cdCAgICBaZXRhOiAnXFx1MDM5NicsXHJcblx0ICAgIEV0YTogJ1xcdTAzOTcnLFxyXG5cdCAgICBUaGV0YTogJ1xcdTAzOTgnLFxyXG5cdCAgICBJb3RhOiAnXFx1MDM5OScsXHJcblx0ICAgIEthcHBhOiAnXFx1MDM5QScsXHJcblx0ICAgIExhbWJkYTogJ1xcdTAzOUInLFxyXG5cdCAgICBNdTogJ1xcdTAzOUMnLFxyXG5cdCAgICBOdTogJ1xcdTAzOUQnLFxyXG5cdCAgICBYaTogJ1xcdTAzOUUnLFxyXG5cdCAgICBPbWljcm9uOiAnXFx1MDM5RicsXHJcblx0ICAgIFBpOiAnXFx1MDNBMCcsXHJcblx0ICAgIFJobzogJ1xcdTAzQTEnLFxyXG5cdCAgICBTaWdtYTogJ1xcdTAzQTMnLFxyXG5cdCAgICBUYXU6ICdcXHUwM0E0JyxcclxuXHQgICAgVXBzaWxvbjogJ1xcdTAzQTUnLFxyXG5cdCAgICBQaGk6ICdcXHUwM0E2JyxcclxuXHQgICAgQ2hpOiAnXFx1MDNBNycsXHJcblx0ICAgIFBzaTogJ1xcdTAzQTgnLFxyXG5cdCAgICBPbWVnYTogJ1xcdTAzQTknLFxyXG5cdCAgICBhbHBoYTogJ1xcdTAzQjEnLFxyXG5cdCAgICBiZXRhOiAnXFx1MDNCMicsXHJcblx0ICAgIGdhbW1hOiAnXFx1MDNCMycsXHJcblx0ICAgIGRlbHRhOiAnXFx1MDNCNCcsXHJcblx0ICAgIGVwc2lsb246ICdcXHUwM0I1JyxcclxuXHQgICAgemV0YTogJ1xcdTAzQjYnLFxyXG5cdCAgICBldGE6ICdcXHUwM0I3JyxcclxuXHQgICAgdGhldGE6ICdcXHUwM0I4JyxcclxuXHQgICAgaW90YTogJ1xcdTAzQjknLFxyXG5cdCAgICBrYXBwYTogJ1xcdTAzQkEnLFxyXG5cdCAgICBsYW1iZGE6ICdcXHUwM0JCJyxcclxuXHQgICAgbXU6ICdcXHUwM0JDJyxcclxuXHQgICAgbnU6ICdcXHUwM0JEJyxcclxuXHQgICAgeGk6ICdcXHUwM0JFJyxcclxuXHQgICAgb21pY3JvbjogJ1xcdTAzQkYnLFxyXG5cdCAgICBwaTogJ1xcdTAzQzAnLFxyXG5cdCAgICByaG86ICdcXHUwM0MxJyxcclxuXHQgICAgc2lnbWFmOiAnXFx1MDNDMicsXHJcblx0ICAgIHNpZ21hOiAnXFx1MDNDMycsXHJcblx0ICAgIHRhdTogJ1xcdTAzQzQnLFxyXG5cdCAgICB1cHNpbG9uOiAnXFx1MDNDNScsXHJcblx0ICAgIHBoaTogJ1xcdTAzQzYnLFxyXG5cdCAgICBjaGk6ICdcXHUwM0M3JyxcclxuXHQgICAgcHNpOiAnXFx1MDNDOCcsXHJcblx0ICAgIG9tZWdhOiAnXFx1MDNDOScsXHJcblx0ICAgIHRoZXRhc3ltOiAnXFx1MDNEMScsXHJcblx0ICAgIHVwc2loOiAnXFx1MDNEMicsXHJcblx0ICAgIHBpdjogJ1xcdTAzRDYnLFxyXG5cdCAgICBlbnNwOiAnXFx1MjAwMicsXHJcblx0ICAgIGVtc3A6ICdcXHUyMDAzJyxcclxuXHQgICAgdGhpbnNwOiAnXFx1MjAwOScsXHJcblx0ICAgIHp3bmo6ICdcXHUyMDBDJyxcclxuXHQgICAgendqOiAnXFx1MjAwRCcsXHJcblx0ICAgIGxybTogJ1xcdTIwMEUnLFxyXG5cdCAgICBybG06ICdcXHUyMDBGJyxcclxuXHQgICAgbmRhc2g6ICdcXHUyMDEzJyxcclxuXHQgICAgbWRhc2g6ICdcXHUyMDE0JyxcclxuXHQgICAgbHNxdW86ICdcXHUyMDE4JyxcclxuXHQgICAgcnNxdW86ICdcXHUyMDE5JyxcclxuXHQgICAgc2JxdW86ICdcXHUyMDFBJyxcclxuXHQgICAgbGRxdW86ICdcXHUyMDFDJyxcclxuXHQgICAgcmRxdW86ICdcXHUyMDFEJyxcclxuXHQgICAgYmRxdW86ICdcXHUyMDFFJyxcclxuXHQgICAgZGFnZ2VyOiAnXFx1MjAyMCcsXHJcblx0ICAgIERhZ2dlcjogJ1xcdTIwMjEnLFxyXG5cdCAgICBidWxsOiAnXFx1MjAyMicsXHJcblx0ICAgIGhlbGxpcDogJ1xcdTIwMjYnLFxyXG5cdCAgICBwZXJtaWw6ICdcXHUyMDMwJyxcclxuXHQgICAgcHJpbWU6ICdcXHUyMDMyJyxcclxuXHQgICAgUHJpbWU6ICdcXHUyMDMzJyxcclxuXHQgICAgbHNhcXVvOiAnXFx1MjAzOScsXHJcblx0ICAgIHJzYXF1bzogJ1xcdTIwM0EnLFxyXG5cdCAgICBvbGluZTogJ1xcdTIwM0UnLFxyXG5cdCAgICBmcmFzbDogJ1xcdTIwNDQnLFxyXG5cdCAgICBldXJvOiAnXFx1MjBBQycsXHJcblx0ICAgIGltYWdlOiAnXFx1MjExMScsXHJcblx0ICAgIHdlaWVycDogJ1xcdTIxMTgnLFxyXG5cdCAgICByZWFsOiAnXFx1MjExQycsXHJcblx0ICAgIHRyYWRlOiAnXFx1MjEyMicsXHJcblx0ICAgIGFsZWZzeW06ICdcXHUyMTM1JyxcclxuXHQgICAgbGFycjogJ1xcdTIxOTAnLFxyXG5cdCAgICB1YXJyOiAnXFx1MjE5MScsXHJcblx0ICAgIHJhcnI6ICdcXHUyMTkyJyxcclxuXHQgICAgZGFycjogJ1xcdTIxOTMnLFxyXG5cdCAgICBoYXJyOiAnXFx1MjE5NCcsXHJcblx0ICAgIGNyYXJyOiAnXFx1MjFCNScsXHJcblx0ICAgIGxBcnI6ICdcXHUyMUQwJyxcclxuXHQgICAgdUFycjogJ1xcdTIxRDEnLFxyXG5cdCAgICByQXJyOiAnXFx1MjFEMicsXHJcblx0ICAgIGRBcnI6ICdcXHUyMUQzJyxcclxuXHQgICAgaEFycjogJ1xcdTIxRDQnLFxyXG5cdCAgICBmb3JhbGw6ICdcXHUyMjAwJyxcclxuXHQgICAgcGFydDogJ1xcdTIyMDInLFxyXG5cdCAgICBleGlzdDogJ1xcdTIyMDMnLFxyXG5cdCAgICBlbXB0eTogJ1xcdTIyMDUnLFxyXG5cdCAgICBuYWJsYTogJ1xcdTIyMDcnLFxyXG5cdCAgICBpc2luOiAnXFx1MjIwOCcsXHJcblx0ICAgIG5vdGluOiAnXFx1MjIwOScsXHJcblx0ICAgIG5pOiAnXFx1MjIwQicsXHJcblx0ICAgIHByb2Q6ICdcXHUyMjBGJyxcclxuXHQgICAgc3VtOiAnXFx1MjIxMScsXHJcblx0ICAgIG1pbnVzOiAnXFx1MjIxMicsXHJcblx0ICAgIGxvd2FzdDogJ1xcdTIyMTcnLFxyXG5cdCAgICByYWRpYzogJ1xcdTIyMUEnLFxyXG5cdCAgICBwcm9wOiAnXFx1MjIxRCcsXHJcblx0ICAgIGluZmluOiAnXFx1MjIxRScsXHJcblx0ICAgIGFuZzogJ1xcdTIyMjAnLFxyXG5cdCAgICBhbmQ6ICdcXHUyMjI3JyxcclxuXHQgICAgb3I6ICdcXHUyMjI4JyxcclxuXHQgICAgY2FwOiAnXFx1MjIyOScsXHJcblx0ICAgIGN1cDogJ1xcdTIyMkEnLFxyXG5cdCAgICBpbnQ6ICdcXHUyMjJCJyxcclxuXHQgICAgdGhlcmU0OiAnXFx1MjIzNCcsXHJcblx0ICAgIHNpbTogJ1xcdTIyM0MnLFxyXG5cdCAgICBjb25nOiAnXFx1MjI0NScsXHJcblx0ICAgIGFzeW1wOiAnXFx1MjI0OCcsXHJcblx0ICAgIG5lOiAnXFx1MjI2MCcsXHJcblx0ICAgIGVxdWl2OiAnXFx1MjI2MScsXHJcblx0ICAgIGxlOiAnXFx1MjI2NCcsXHJcblx0ICAgIGdlOiAnXFx1MjI2NScsXHJcblx0ICAgIHN1YjogJ1xcdTIyODInLFxyXG5cdCAgICBzdXA6ICdcXHUyMjgzJyxcclxuXHQgICAgbnN1YjogJ1xcdTIyODQnLFxyXG5cdCAgICBzdWJlOiAnXFx1MjI4NicsXHJcblx0ICAgIHN1cGU6ICdcXHUyMjg3JyxcclxuXHQgICAgb3BsdXM6ICdcXHUyMjk1JyxcclxuXHQgICAgb3RpbWVzOiAnXFx1MjI5NycsXHJcblx0ICAgIHBlcnA6ICdcXHUyMkE1JyxcclxuXHQgICAgc2RvdDogJ1xcdTIyQzUnLFxyXG5cdCAgICBsY2VpbDogJ1xcdTIzMDgnLFxyXG5cdCAgICByY2VpbDogJ1xcdTIzMDknLFxyXG5cdCAgICBsZmxvb3I6ICdcXHUyMzBBJyxcclxuXHQgICAgcmZsb29yOiAnXFx1MjMwQicsXHJcblx0ICAgIGxvejogJ1xcdTI1Q0EnLFxyXG5cdCAgICBzcGFkZXM6ICdcXHUyNjYwJyxcclxuXHQgICAgY2x1YnM6ICdcXHUyNjYzJyxcclxuXHQgICAgaGVhcnRzOiAnXFx1MjY2NScsXHJcblx0ICAgIGRpYW1zOiAnXFx1MjY2NicsXHJcblx0ICAgIGxhbmc6ICdcXHUyN0U4JyxcclxuXHQgICAgcmFuZzogJ1xcdTI3RTknXHJcblx0fTtcclxuXG5cbi8qKiovIH0sXG4vKiAxNSAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblx0XCJ1c2Ugc3RyaWN0XCI7XHJcblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG5cdHZhciBlcnJvcl9oYW5kbGVyXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEwKTtcclxuXHR2YXIgc2Nhbm5lcl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMik7XHJcblx0dmFyIHRva2VuXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEzKTtcclxuXHR2YXIgUmVhZGVyID0gKGZ1bmN0aW9uICgpIHtcclxuXHQgICAgZnVuY3Rpb24gUmVhZGVyKCkge1xyXG5cdCAgICAgICAgdGhpcy52YWx1ZXMgPSBbXTtcclxuXHQgICAgICAgIHRoaXMuY3VybHkgPSB0aGlzLnBhcmVuID0gLTE7XHJcblx0ICAgIH1cclxuXHQgICAgLy8gQSBmdW5jdGlvbiBmb2xsb3dpbmcgb25lIG9mIHRob3NlIHRva2VucyBpcyBhbiBleHByZXNzaW9uLlxyXG5cdCAgICBSZWFkZXIucHJvdG90eXBlLmJlZm9yZUZ1bmN0aW9uRXhwcmVzc2lvbiA9IGZ1bmN0aW9uICh0KSB7XHJcblx0ICAgICAgICByZXR1cm4gWycoJywgJ3snLCAnWycsICdpbicsICd0eXBlb2YnLCAnaW5zdGFuY2VvZicsICduZXcnLFxyXG5cdCAgICAgICAgICAgICdyZXR1cm4nLCAnY2FzZScsICdkZWxldGUnLCAndGhyb3cnLCAndm9pZCcsXHJcblx0ICAgICAgICAgICAgLy8gYXNzaWdubWVudCBvcGVyYXRvcnNcclxuXHQgICAgICAgICAgICAnPScsICcrPScsICctPScsICcqPScsICcqKj0nLCAnLz0nLCAnJT0nLCAnPDw9JywgJz4+PScsICc+Pj49JyxcclxuXHQgICAgICAgICAgICAnJj0nLCAnfD0nLCAnXj0nLCAnLCcsXHJcblx0ICAgICAgICAgICAgLy8gYmluYXJ5L3VuYXJ5IG9wZXJhdG9yc1xyXG5cdCAgICAgICAgICAgICcrJywgJy0nLCAnKicsICcqKicsICcvJywgJyUnLCAnKysnLCAnLS0nLCAnPDwnLCAnPj4nLCAnPj4+JywgJyYnLFxyXG5cdCAgICAgICAgICAgICd8JywgJ14nLCAnIScsICd+JywgJyYmJywgJ3x8JywgJz8nLCAnOicsICc9PT0nLCAnPT0nLCAnPj0nLFxyXG5cdCAgICAgICAgICAgICc8PScsICc8JywgJz4nLCAnIT0nLCAnIT09J10uaW5kZXhPZih0KSA+PSAwO1xyXG5cdCAgICB9O1xyXG5cdCAgICAvLyBEZXRlcm1pbmUgaWYgZm9yd2FyZCBzbGFzaCAoLykgaXMgYW4gb3BlcmF0b3Igb3IgcGFydCBvZiBhIHJlZ3VsYXIgZXhwcmVzc2lvblxyXG5cdCAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vbW96aWxsYS9zd2VldC5qcy93aWtpL2Rlc2lnblxyXG5cdCAgICBSZWFkZXIucHJvdG90eXBlLmlzUmVnZXhTdGFydCA9IGZ1bmN0aW9uICgpIHtcclxuXHQgICAgICAgIHZhciBwcmV2aW91cyA9IHRoaXMudmFsdWVzW3RoaXMudmFsdWVzLmxlbmd0aCAtIDFdO1xyXG5cdCAgICAgICAgdmFyIHJlZ2V4ID0gKHByZXZpb3VzICE9PSBudWxsKTtcclxuXHQgICAgICAgIHN3aXRjaCAocHJldmlvdXMpIHtcclxuXHQgICAgICAgICAgICBjYXNlICd0aGlzJzpcclxuXHQgICAgICAgICAgICBjYXNlICddJzpcclxuXHQgICAgICAgICAgICAgICAgcmVnZXggPSBmYWxzZTtcclxuXHQgICAgICAgICAgICAgICAgYnJlYWs7XHJcblx0ICAgICAgICAgICAgY2FzZSAnKSc6XHJcblx0ICAgICAgICAgICAgICAgIHZhciBrZXl3b3JkID0gdGhpcy52YWx1ZXNbdGhpcy5wYXJlbiAtIDFdO1xyXG5cdCAgICAgICAgICAgICAgICByZWdleCA9IChrZXl3b3JkID09PSAnaWYnIHx8IGtleXdvcmQgPT09ICd3aGlsZScgfHwga2V5d29yZCA9PT0gJ2ZvcicgfHwga2V5d29yZCA9PT0gJ3dpdGgnKTtcclxuXHQgICAgICAgICAgICAgICAgYnJlYWs7XHJcblx0ICAgICAgICAgICAgY2FzZSAnfSc6XHJcblx0ICAgICAgICAgICAgICAgIC8vIERpdmlkaW5nIGEgZnVuY3Rpb24gYnkgYW55dGhpbmcgbWFrZXMgbGl0dGxlIHNlbnNlLFxyXG5cdCAgICAgICAgICAgICAgICAvLyBidXQgd2UgaGF2ZSB0byBjaGVjayBmb3IgdGhhdC5cclxuXHQgICAgICAgICAgICAgICAgcmVnZXggPSBmYWxzZTtcclxuXHQgICAgICAgICAgICAgICAgaWYgKHRoaXMudmFsdWVzW3RoaXMuY3VybHkgLSAzXSA9PT0gJ2Z1bmN0aW9uJykge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgLy8gQW5vbnltb3VzIGZ1bmN0aW9uLCBlLmcuIGZ1bmN0aW9uKCl7fSAvNDJcclxuXHQgICAgICAgICAgICAgICAgICAgIHZhciBjaGVjayA9IHRoaXMudmFsdWVzW3RoaXMuY3VybHkgLSA0XTtcclxuXHQgICAgICAgICAgICAgICAgICAgIHJlZ2V4ID0gY2hlY2sgPyAhdGhpcy5iZWZvcmVGdW5jdGlvbkV4cHJlc3Npb24oY2hlY2spIDogZmFsc2U7XHJcblx0ICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgZWxzZSBpZiAodGhpcy52YWx1ZXNbdGhpcy5jdXJseSAtIDRdID09PSAnZnVuY3Rpb24nKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAvLyBOYW1lZCBmdW5jdGlvbiwgZS5nLiBmdW5jdGlvbiBmKCl7fSAvNDIvXHJcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgY2hlY2sgPSB0aGlzLnZhbHVlc1t0aGlzLmN1cmx5IC0gNV07XHJcblx0ICAgICAgICAgICAgICAgICAgICByZWdleCA9IGNoZWNrID8gIXRoaXMuYmVmb3JlRnVuY3Rpb25FeHByZXNzaW9uKGNoZWNrKSA6IHRydWU7XHJcblx0ICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgYnJlYWs7XHJcblx0ICAgICAgICAgICAgZGVmYXVsdDpcclxuXHQgICAgICAgICAgICAgICAgYnJlYWs7XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICByZXR1cm4gcmVnZXg7XHJcblx0ICAgIH07XHJcblx0ICAgIFJlYWRlci5wcm90b3R5cGUucHVzaCA9IGZ1bmN0aW9uICh0b2tlbikge1xyXG5cdCAgICAgICAgaWYgKHRva2VuLnR5cGUgPT09IDcgLyogUHVuY3R1YXRvciAqLyB8fCB0b2tlbi50eXBlID09PSA0IC8qIEtleXdvcmQgKi8pIHtcclxuXHQgICAgICAgICAgICBpZiAodG9rZW4udmFsdWUgPT09ICd7Jykge1xyXG5cdCAgICAgICAgICAgICAgICB0aGlzLmN1cmx5ID0gdGhpcy52YWx1ZXMubGVuZ3RoO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICBlbHNlIGlmICh0b2tlbi52YWx1ZSA9PT0gJygnKSB7XHJcblx0ICAgICAgICAgICAgICAgIHRoaXMucGFyZW4gPSB0aGlzLnZhbHVlcy5sZW5ndGg7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgIHRoaXMudmFsdWVzLnB1c2godG9rZW4udmFsdWUpO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgZWxzZSB7XHJcblx0ICAgICAgICAgICAgdGhpcy52YWx1ZXMucHVzaChudWxsKTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgfTtcclxuXHQgICAgcmV0dXJuIFJlYWRlcjtcclxuXHR9KCkpO1xyXG5cdHZhciBUb2tlbml6ZXIgPSAoZnVuY3Rpb24gKCkge1xyXG5cdCAgICBmdW5jdGlvbiBUb2tlbml6ZXIoY29kZSwgY29uZmlnKSB7XHJcblx0ICAgICAgICB0aGlzLmVycm9ySGFuZGxlciA9IG5ldyBlcnJvcl9oYW5kbGVyXzEuRXJyb3JIYW5kbGVyKCk7XHJcblx0ICAgICAgICB0aGlzLmVycm9ySGFuZGxlci50b2xlcmFudCA9IGNvbmZpZyA/ICh0eXBlb2YgY29uZmlnLnRvbGVyYW50ID09PSAnYm9vbGVhbicgJiYgY29uZmlnLnRvbGVyYW50KSA6IGZhbHNlO1xyXG5cdCAgICAgICAgdGhpcy5zY2FubmVyID0gbmV3IHNjYW5uZXJfMS5TY2FubmVyKGNvZGUsIHRoaXMuZXJyb3JIYW5kbGVyKTtcclxuXHQgICAgICAgIHRoaXMuc2Nhbm5lci50cmFja0NvbW1lbnQgPSBjb25maWcgPyAodHlwZW9mIGNvbmZpZy5jb21tZW50ID09PSAnYm9vbGVhbicgJiYgY29uZmlnLmNvbW1lbnQpIDogZmFsc2U7XHJcblx0ICAgICAgICB0aGlzLnRyYWNrUmFuZ2UgPSBjb25maWcgPyAodHlwZW9mIGNvbmZpZy5yYW5nZSA9PT0gJ2Jvb2xlYW4nICYmIGNvbmZpZy5yYW5nZSkgOiBmYWxzZTtcclxuXHQgICAgICAgIHRoaXMudHJhY2tMb2MgPSBjb25maWcgPyAodHlwZW9mIGNvbmZpZy5sb2MgPT09ICdib29sZWFuJyAmJiBjb25maWcubG9jKSA6IGZhbHNlO1xyXG5cdCAgICAgICAgdGhpcy5idWZmZXIgPSBbXTtcclxuXHQgICAgICAgIHRoaXMucmVhZGVyID0gbmV3IFJlYWRlcigpO1xyXG5cdCAgICB9XHJcblx0ICAgIFRva2VuaXplci5wcm90b3R5cGUuZXJyb3JzID0gZnVuY3Rpb24gKCkge1xyXG5cdCAgICAgICAgcmV0dXJuIHRoaXMuZXJyb3JIYW5kbGVyLmVycm9ycztcclxuXHQgICAgfTtcclxuXHQgICAgVG9rZW5pemVyLnByb3RvdHlwZS5nZXROZXh0VG9rZW4gPSBmdW5jdGlvbiAoKSB7XHJcblx0ICAgICAgICBpZiAodGhpcy5idWZmZXIubGVuZ3RoID09PSAwKSB7XHJcblx0ICAgICAgICAgICAgdmFyIGNvbW1lbnRzID0gdGhpcy5zY2FubmVyLnNjYW5Db21tZW50cygpO1xyXG5cdCAgICAgICAgICAgIGlmICh0aGlzLnNjYW5uZXIudHJhY2tDb21tZW50KSB7XHJcblx0ICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY29tbWVudHMubGVuZ3RoOyArK2kpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgIHZhciBlID0gY29tbWVudHNbaV07XHJcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgdmFsdWUgPSB0aGlzLnNjYW5uZXIuc291cmNlLnNsaWNlKGUuc2xpY2VbMF0sIGUuc2xpY2VbMV0pO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIGNvbW1lbnQgPSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogZS5tdWx0aUxpbmUgPyAnQmxvY2tDb21tZW50JyA6ICdMaW5lQ29tbWVudCcsXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IHZhbHVlXHJcblx0ICAgICAgICAgICAgICAgICAgICB9O1xyXG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMudHJhY2tSYW5nZSkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGNvbW1lbnQucmFuZ2UgPSBlLnJhbmdlO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMudHJhY2tMb2MpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBjb21tZW50LmxvYyA9IGUubG9jO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICAgICAgdGhpcy5idWZmZXIucHVzaChjb21tZW50KTtcclxuXHQgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICBpZiAoIXRoaXMuc2Nhbm5lci5lb2YoKSkge1xyXG5cdCAgICAgICAgICAgICAgICB2YXIgbG9jID0gdm9pZCAwO1xyXG5cdCAgICAgICAgICAgICAgICBpZiAodGhpcy50cmFja0xvYykge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgbG9jID0ge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHN0YXJ0OiB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxpbmU6IHRoaXMuc2Nhbm5lci5saW5lTnVtYmVyLFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2x1bW46IHRoaXMuc2Nhbm5lci5pbmRleCAtIHRoaXMuc2Nhbm5lci5saW5lU3RhcnRcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICB9LFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGVuZDoge31cclxuXHQgICAgICAgICAgICAgICAgICAgIH07XHJcblx0ICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgdmFyIHN0YXJ0UmVnZXggPSAodGhpcy5zY2FubmVyLnNvdXJjZVt0aGlzLnNjYW5uZXIuaW5kZXhdID09PSAnLycpICYmIHRoaXMucmVhZGVyLmlzUmVnZXhTdGFydCgpO1xyXG5cdCAgICAgICAgICAgICAgICB2YXIgdG9rZW4gPSBzdGFydFJlZ2V4ID8gdGhpcy5zY2FubmVyLnNjYW5SZWdFeHAoKSA6IHRoaXMuc2Nhbm5lci5sZXgoKTtcclxuXHQgICAgICAgICAgICAgICAgdGhpcy5yZWFkZXIucHVzaCh0b2tlbik7XHJcblx0ICAgICAgICAgICAgICAgIHZhciBlbnRyeSA9IHtcclxuXHQgICAgICAgICAgICAgICAgICAgIHR5cGU6IHRva2VuXzEuVG9rZW5OYW1lW3Rva2VuLnR5cGVdLFxyXG5cdCAgICAgICAgICAgICAgICAgICAgdmFsdWU6IHRoaXMuc2Nhbm5lci5zb3VyY2Uuc2xpY2UodG9rZW4uc3RhcnQsIHRva2VuLmVuZClcclxuXHQgICAgICAgICAgICAgICAgfTtcclxuXHQgICAgICAgICAgICAgICAgaWYgKHRoaXMudHJhY2tSYW5nZSkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgZW50cnkucmFuZ2UgPSBbdG9rZW4uc3RhcnQsIHRva2VuLmVuZF07XHJcblx0ICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgaWYgKHRoaXMudHJhY2tMb2MpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgIGxvYy5lbmQgPSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgbGluZTogdGhpcy5zY2FubmVyLmxpbmVOdW1iZXIsXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgY29sdW1uOiB0aGlzLnNjYW5uZXIuaW5kZXggLSB0aGlzLnNjYW5uZXIubGluZVN0YXJ0XHJcblx0ICAgICAgICAgICAgICAgICAgICB9O1xyXG5cdCAgICAgICAgICAgICAgICAgICAgZW50cnkubG9jID0gbG9jO1xyXG5cdCAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgIGlmICh0b2tlbi50eXBlID09PSA5IC8qIFJlZ3VsYXJFeHByZXNzaW9uICovKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgcGF0dGVybiA9IHRva2VuLnBhdHRlcm47XHJcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgZmxhZ3MgPSB0b2tlbi5mbGFncztcclxuXHQgICAgICAgICAgICAgICAgICAgIGVudHJ5LnJlZ2V4ID0geyBwYXR0ZXJuOiBwYXR0ZXJuLCBmbGFnczogZmxhZ3MgfTtcclxuXHQgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICB0aGlzLmJ1ZmZlci5wdXNoKGVudHJ5KTtcclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICByZXR1cm4gdGhpcy5idWZmZXIuc2hpZnQoKTtcclxuXHQgICAgfTtcclxuXHQgICAgcmV0dXJuIFRva2VuaXplcjtcclxuXHR9KCkpO1xyXG5cdGV4cG9ydHMuVG9rZW5pemVyID0gVG9rZW5pemVyO1xyXG5cblxuLyoqKi8gfVxuLyoqKioqKi8gXSlcbn0pO1xuO1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9lc3ByaW1hL2Rpc3QvZXNwcmltYS5qcyIsIid1c2Ugc3RyaWN0JztcblxuLyplc2xpbnQtZGlzYWJsZSBuby11c2UtYmVmb3JlLWRlZmluZSovXG5cbnZhciBjb21tb24gICAgICAgICAgICAgID0gcmVxdWlyZSgnLi9jb21tb24nKTtcbnZhciBZQU1MRXhjZXB0aW9uICAgICAgID0gcmVxdWlyZSgnLi9leGNlcHRpb24nKTtcbnZhciBERUZBVUxUX0ZVTExfU0NIRU1BID0gcmVxdWlyZSgnLi9zY2hlbWEvZGVmYXVsdF9mdWxsJyk7XG52YXIgREVGQVVMVF9TQUZFX1NDSEVNQSA9IHJlcXVpcmUoJy4vc2NoZW1hL2RlZmF1bHRfc2FmZScpO1xuXG52YXIgX3RvU3RyaW5nICAgICAgID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZztcbnZhciBfaGFzT3duUHJvcGVydHkgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xuXG52YXIgQ0hBUl9UQUIgICAgICAgICAgICAgICAgICA9IDB4MDk7IC8qIFRhYiAqL1xudmFyIENIQVJfTElORV9GRUVEICAgICAgICAgICAgPSAweDBBOyAvKiBMRiAqL1xudmFyIENIQVJfU1BBQ0UgICAgICAgICAgICAgICAgPSAweDIwOyAvKiBTcGFjZSAqL1xudmFyIENIQVJfRVhDTEFNQVRJT04gICAgICAgICAgPSAweDIxOyAvKiAhICovXG52YXIgQ0hBUl9ET1VCTEVfUVVPVEUgICAgICAgICA9IDB4MjI7IC8qIFwiICovXG52YXIgQ0hBUl9TSEFSUCAgICAgICAgICAgICAgICA9IDB4MjM7IC8qICMgKi9cbnZhciBDSEFSX1BFUkNFTlQgICAgICAgICAgICAgID0gMHgyNTsgLyogJSAqL1xudmFyIENIQVJfQU1QRVJTQU5EICAgICAgICAgICAgPSAweDI2OyAvKiAmICovXG52YXIgQ0hBUl9TSU5HTEVfUVVPVEUgICAgICAgICA9IDB4Mjc7IC8qICcgKi9cbnZhciBDSEFSX0FTVEVSSVNLICAgICAgICAgICAgID0gMHgyQTsgLyogKiAqL1xudmFyIENIQVJfQ09NTUEgICAgICAgICAgICAgICAgPSAweDJDOyAvKiAsICovXG52YXIgQ0hBUl9NSU5VUyAgICAgICAgICAgICAgICA9IDB4MkQ7IC8qIC0gKi9cbnZhciBDSEFSX0NPTE9OICAgICAgICAgICAgICAgID0gMHgzQTsgLyogOiAqL1xudmFyIENIQVJfR1JFQVRFUl9USEFOICAgICAgICAgPSAweDNFOyAvKiA+ICovXG52YXIgQ0hBUl9RVUVTVElPTiAgICAgICAgICAgICA9IDB4M0Y7IC8qID8gKi9cbnZhciBDSEFSX0NPTU1FUkNJQUxfQVQgICAgICAgID0gMHg0MDsgLyogQCAqL1xudmFyIENIQVJfTEVGVF9TUVVBUkVfQlJBQ0tFVCAgPSAweDVCOyAvKiBbICovXG52YXIgQ0hBUl9SSUdIVF9TUVVBUkVfQlJBQ0tFVCA9IDB4NUQ7IC8qIF0gKi9cbnZhciBDSEFSX0dSQVZFX0FDQ0VOVCAgICAgICAgID0gMHg2MDsgLyogYCAqL1xudmFyIENIQVJfTEVGVF9DVVJMWV9CUkFDS0VUICAgPSAweDdCOyAvKiB7ICovXG52YXIgQ0hBUl9WRVJUSUNBTF9MSU5FICAgICAgICA9IDB4N0M7IC8qIHwgKi9cbnZhciBDSEFSX1JJR0hUX0NVUkxZX0JSQUNLRVQgID0gMHg3RDsgLyogfSAqL1xuXG52YXIgRVNDQVBFX1NFUVVFTkNFUyA9IHt9O1xuXG5FU0NBUEVfU0VRVUVOQ0VTWzB4MDBdICAgPSAnXFxcXDAnO1xuRVNDQVBFX1NFUVVFTkNFU1sweDA3XSAgID0gJ1xcXFxhJztcbkVTQ0FQRV9TRVFVRU5DRVNbMHgwOF0gICA9ICdcXFxcYic7XG5FU0NBUEVfU0VRVUVOQ0VTWzB4MDldICAgPSAnXFxcXHQnO1xuRVNDQVBFX1NFUVVFTkNFU1sweDBBXSAgID0gJ1xcXFxuJztcbkVTQ0FQRV9TRVFVRU5DRVNbMHgwQl0gICA9ICdcXFxcdic7XG5FU0NBUEVfU0VRVUVOQ0VTWzB4MENdICAgPSAnXFxcXGYnO1xuRVNDQVBFX1NFUVVFTkNFU1sweDBEXSAgID0gJ1xcXFxyJztcbkVTQ0FQRV9TRVFVRU5DRVNbMHgxQl0gICA9ICdcXFxcZSc7XG5FU0NBUEVfU0VRVUVOQ0VTWzB4MjJdICAgPSAnXFxcXFwiJztcbkVTQ0FQRV9TRVFVRU5DRVNbMHg1Q10gICA9ICdcXFxcXFxcXCc7XG5FU0NBUEVfU0VRVUVOQ0VTWzB4ODVdICAgPSAnXFxcXE4nO1xuRVNDQVBFX1NFUVVFTkNFU1sweEEwXSAgID0gJ1xcXFxfJztcbkVTQ0FQRV9TRVFVRU5DRVNbMHgyMDI4XSA9ICdcXFxcTCc7XG5FU0NBUEVfU0VRVUVOQ0VTWzB4MjAyOV0gPSAnXFxcXFAnO1xuXG52YXIgREVQUkVDQVRFRF9CT09MRUFOU19TWU5UQVggPSBbXG4gICd5JywgJ1knLCAneWVzJywgJ1llcycsICdZRVMnLCAnb24nLCAnT24nLCAnT04nLFxuICAnbicsICdOJywgJ25vJywgJ05vJywgJ05PJywgJ29mZicsICdPZmYnLCAnT0ZGJ1xuXTtcblxuZnVuY3Rpb24gY29tcGlsZVN0eWxlTWFwKHNjaGVtYSwgbWFwKSB7XG4gIHZhciByZXN1bHQsIGtleXMsIGluZGV4LCBsZW5ndGgsIHRhZywgc3R5bGUsIHR5cGU7XG5cbiAgaWYgKG1hcCA9PT0gbnVsbCkgcmV0dXJuIHt9O1xuXG4gIHJlc3VsdCA9IHt9O1xuICBrZXlzID0gT2JqZWN0LmtleXMobWFwKTtcblxuICBmb3IgKGluZGV4ID0gMCwgbGVuZ3RoID0ga2V5cy5sZW5ndGg7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCArPSAxKSB7XG4gICAgdGFnID0ga2V5c1tpbmRleF07XG4gICAgc3R5bGUgPSBTdHJpbmcobWFwW3RhZ10pO1xuXG4gICAgaWYgKHRhZy5zbGljZSgwLCAyKSA9PT0gJyEhJykge1xuICAgICAgdGFnID0gJ3RhZzp5YW1sLm9yZywyMDAyOicgKyB0YWcuc2xpY2UoMik7XG4gICAgfVxuICAgIHR5cGUgPSBzY2hlbWEuY29tcGlsZWRUeXBlTWFwWydmYWxsYmFjayddW3RhZ107XG5cbiAgICBpZiAodHlwZSAmJiBfaGFzT3duUHJvcGVydHkuY2FsbCh0eXBlLnN0eWxlQWxpYXNlcywgc3R5bGUpKSB7XG4gICAgICBzdHlsZSA9IHR5cGUuc3R5bGVBbGlhc2VzW3N0eWxlXTtcbiAgICB9XG5cbiAgICByZXN1bHRbdGFnXSA9IHN0eWxlO1xuICB9XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuZnVuY3Rpb24gZW5jb2RlSGV4KGNoYXJhY3Rlcikge1xuICB2YXIgc3RyaW5nLCBoYW5kbGUsIGxlbmd0aDtcblxuICBzdHJpbmcgPSBjaGFyYWN0ZXIudG9TdHJpbmcoMTYpLnRvVXBwZXJDYXNlKCk7XG5cbiAgaWYgKGNoYXJhY3RlciA8PSAweEZGKSB7XG4gICAgaGFuZGxlID0gJ3gnO1xuICAgIGxlbmd0aCA9IDI7XG4gIH0gZWxzZSBpZiAoY2hhcmFjdGVyIDw9IDB4RkZGRikge1xuICAgIGhhbmRsZSA9ICd1JztcbiAgICBsZW5ndGggPSA0O1xuICB9IGVsc2UgaWYgKGNoYXJhY3RlciA8PSAweEZGRkZGRkZGKSB7XG4gICAgaGFuZGxlID0gJ1UnO1xuICAgIGxlbmd0aCA9IDg7XG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IFlBTUxFeGNlcHRpb24oJ2NvZGUgcG9pbnQgd2l0aGluIGEgc3RyaW5nIG1heSBub3QgYmUgZ3JlYXRlciB0aGFuIDB4RkZGRkZGRkYnKTtcbiAgfVxuXG4gIHJldHVybiAnXFxcXCcgKyBoYW5kbGUgKyBjb21tb24ucmVwZWF0KCcwJywgbGVuZ3RoIC0gc3RyaW5nLmxlbmd0aCkgKyBzdHJpbmc7XG59XG5cbmZ1bmN0aW9uIFN0YXRlKG9wdGlvbnMpIHtcbiAgdGhpcy5zY2hlbWEgICAgICAgPSBvcHRpb25zWydzY2hlbWEnXSB8fCBERUZBVUxUX0ZVTExfU0NIRU1BO1xuICB0aGlzLmluZGVudCAgICAgICA9IE1hdGgubWF4KDEsIChvcHRpb25zWydpbmRlbnQnXSB8fCAyKSk7XG4gIHRoaXMuc2tpcEludmFsaWQgID0gb3B0aW9uc1snc2tpcEludmFsaWQnXSB8fCBmYWxzZTtcbiAgdGhpcy5mbG93TGV2ZWwgICAgPSAoY29tbW9uLmlzTm90aGluZyhvcHRpb25zWydmbG93TGV2ZWwnXSkgPyAtMSA6IG9wdGlvbnNbJ2Zsb3dMZXZlbCddKTtcbiAgdGhpcy5zdHlsZU1hcCAgICAgPSBjb21waWxlU3R5bGVNYXAodGhpcy5zY2hlbWEsIG9wdGlvbnNbJ3N0eWxlcyddIHx8IG51bGwpO1xuICB0aGlzLnNvcnRLZXlzICAgICA9IG9wdGlvbnNbJ3NvcnRLZXlzJ10gfHwgZmFsc2U7XG4gIHRoaXMubGluZVdpZHRoICAgID0gb3B0aW9uc1snbGluZVdpZHRoJ10gfHwgODA7XG4gIHRoaXMubm9SZWZzICAgICAgID0gb3B0aW9uc1snbm9SZWZzJ10gfHwgZmFsc2U7XG4gIHRoaXMubm9Db21wYXRNb2RlID0gb3B0aW9uc1snbm9Db21wYXRNb2RlJ10gfHwgZmFsc2U7XG4gIHRoaXMuY29uZGVuc2VGbG93ID0gb3B0aW9uc1snY29uZGVuc2VGbG93J10gfHwgZmFsc2U7XG5cbiAgdGhpcy5pbXBsaWNpdFR5cGVzID0gdGhpcy5zY2hlbWEuY29tcGlsZWRJbXBsaWNpdDtcbiAgdGhpcy5leHBsaWNpdFR5cGVzID0gdGhpcy5zY2hlbWEuY29tcGlsZWRFeHBsaWNpdDtcblxuICB0aGlzLnRhZyA9IG51bGw7XG4gIHRoaXMucmVzdWx0ID0gJyc7XG5cbiAgdGhpcy5kdXBsaWNhdGVzID0gW107XG4gIHRoaXMudXNlZER1cGxpY2F0ZXMgPSBudWxsO1xufVxuXG4vLyBJbmRlbnRzIGV2ZXJ5IGxpbmUgaW4gYSBzdHJpbmcuIEVtcHR5IGxpbmVzIChcXG4gb25seSkgYXJlIG5vdCBpbmRlbnRlZC5cbmZ1bmN0aW9uIGluZGVudFN0cmluZyhzdHJpbmcsIHNwYWNlcykge1xuICB2YXIgaW5kID0gY29tbW9uLnJlcGVhdCgnICcsIHNwYWNlcyksXG4gICAgICBwb3NpdGlvbiA9IDAsXG4gICAgICBuZXh0ID0gLTEsXG4gICAgICByZXN1bHQgPSAnJyxcbiAgICAgIGxpbmUsXG4gICAgICBsZW5ndGggPSBzdHJpbmcubGVuZ3RoO1xuXG4gIHdoaWxlIChwb3NpdGlvbiA8IGxlbmd0aCkge1xuICAgIG5leHQgPSBzdHJpbmcuaW5kZXhPZignXFxuJywgcG9zaXRpb24pO1xuICAgIGlmIChuZXh0ID09PSAtMSkge1xuICAgICAgbGluZSA9IHN0cmluZy5zbGljZShwb3NpdGlvbik7XG4gICAgICBwb3NpdGlvbiA9IGxlbmd0aDtcbiAgICB9IGVsc2Uge1xuICAgICAgbGluZSA9IHN0cmluZy5zbGljZShwb3NpdGlvbiwgbmV4dCArIDEpO1xuICAgICAgcG9zaXRpb24gPSBuZXh0ICsgMTtcbiAgICB9XG5cbiAgICBpZiAobGluZS5sZW5ndGggJiYgbGluZSAhPT0gJ1xcbicpIHJlc3VsdCArPSBpbmQ7XG5cbiAgICByZXN1bHQgKz0gbGluZTtcbiAgfVxuXG4gIHJldHVybiByZXN1bHQ7XG59XG5cbmZ1bmN0aW9uIGdlbmVyYXRlTmV4dExpbmUoc3RhdGUsIGxldmVsKSB7XG4gIHJldHVybiAnXFxuJyArIGNvbW1vbi5yZXBlYXQoJyAnLCBzdGF0ZS5pbmRlbnQgKiBsZXZlbCk7XG59XG5cbmZ1bmN0aW9uIHRlc3RJbXBsaWNpdFJlc29sdmluZyhzdGF0ZSwgc3RyKSB7XG4gIHZhciBpbmRleCwgbGVuZ3RoLCB0eXBlO1xuXG4gIGZvciAoaW5kZXggPSAwLCBsZW5ndGggPSBzdGF0ZS5pbXBsaWNpdFR5cGVzLmxlbmd0aDsgaW5kZXggPCBsZW5ndGg7IGluZGV4ICs9IDEpIHtcbiAgICB0eXBlID0gc3RhdGUuaW1wbGljaXRUeXBlc1tpbmRleF07XG5cbiAgICBpZiAodHlwZS5yZXNvbHZlKHN0cikpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxuLy8gWzMzXSBzLXdoaXRlIDo6PSBzLXNwYWNlIHwgcy10YWJcbmZ1bmN0aW9uIGlzV2hpdGVzcGFjZShjKSB7XG4gIHJldHVybiBjID09PSBDSEFSX1NQQUNFIHx8IGMgPT09IENIQVJfVEFCO1xufVxuXG4vLyBSZXR1cm5zIHRydWUgaWYgdGhlIGNoYXJhY3RlciBjYW4gYmUgcHJpbnRlZCB3aXRob3V0IGVzY2FwaW5nLlxuLy8gRnJvbSBZQU1MIDEuMjogXCJhbnkgYWxsb3dlZCBjaGFyYWN0ZXJzIGtub3duIHRvIGJlIG5vbi1wcmludGFibGVcbi8vIHNob3VsZCBhbHNvIGJlIGVzY2FwZWQuIFtIb3dldmVyLF0gVGhpcyBpc27igJl0IG1hbmRhdG9yeVwiXG4vLyBEZXJpdmVkIGZyb20gbmItY2hhciAtIFxcdCAtICN4ODUgLSAjeEEwIC0gI3gyMDI4IC0gI3gyMDI5LlxuZnVuY3Rpb24gaXNQcmludGFibGUoYykge1xuICByZXR1cm4gICgweDAwMDIwIDw9IGMgJiYgYyA8PSAweDAwMDA3RSlcbiAgICAgIHx8ICgoMHgwMDBBMSA8PSBjICYmIGMgPD0gMHgwMEQ3RkYpICYmIGMgIT09IDB4MjAyOCAmJiBjICE9PSAweDIwMjkpXG4gICAgICB8fCAoKDB4MEUwMDAgPD0gYyAmJiBjIDw9IDB4MDBGRkZEKSAmJiBjICE9PSAweEZFRkYgLyogQk9NICovKVxuICAgICAgfHwgICgweDEwMDAwIDw9IGMgJiYgYyA8PSAweDEwRkZGRik7XG59XG5cbi8vIFNpbXBsaWZpZWQgdGVzdCBmb3IgdmFsdWVzIGFsbG93ZWQgYWZ0ZXIgdGhlIGZpcnN0IGNoYXJhY3RlciBpbiBwbGFpbiBzdHlsZS5cbmZ1bmN0aW9uIGlzUGxhaW5TYWZlKGMpIHtcbiAgLy8gVXNlcyBhIHN1YnNldCBvZiBuYi1jaGFyIC0gYy1mbG93LWluZGljYXRvciAtIFwiOlwiIC0gXCIjXCJcbiAgLy8gd2hlcmUgbmItY2hhciA6Oj0gYy1wcmludGFibGUgLSBiLWNoYXIgLSBjLWJ5dGUtb3JkZXItbWFyay5cbiAgcmV0dXJuIGlzUHJpbnRhYmxlKGMpICYmIGMgIT09IDB4RkVGRlxuICAgIC8vIC0gYy1mbG93LWluZGljYXRvclxuICAgICYmIGMgIT09IENIQVJfQ09NTUFcbiAgICAmJiBjICE9PSBDSEFSX0xFRlRfU1FVQVJFX0JSQUNLRVRcbiAgICAmJiBjICE9PSBDSEFSX1JJR0hUX1NRVUFSRV9CUkFDS0VUXG4gICAgJiYgYyAhPT0gQ0hBUl9MRUZUX0NVUkxZX0JSQUNLRVRcbiAgICAmJiBjICE9PSBDSEFSX1JJR0hUX0NVUkxZX0JSQUNLRVRcbiAgICAvLyAtIFwiOlwiIC0gXCIjXCJcbiAgICAmJiBjICE9PSBDSEFSX0NPTE9OXG4gICAgJiYgYyAhPT0gQ0hBUl9TSEFSUDtcbn1cblxuLy8gU2ltcGxpZmllZCB0ZXN0IGZvciB2YWx1ZXMgYWxsb3dlZCBhcyB0aGUgZmlyc3QgY2hhcmFjdGVyIGluIHBsYWluIHN0eWxlLlxuZnVuY3Rpb24gaXNQbGFpblNhZmVGaXJzdChjKSB7XG4gIC8vIFVzZXMgYSBzdWJzZXQgb2YgbnMtY2hhciAtIGMtaW5kaWNhdG9yXG4gIC8vIHdoZXJlIG5zLWNoYXIgPSBuYi1jaGFyIC0gcy13aGl0ZS5cbiAgcmV0dXJuIGlzUHJpbnRhYmxlKGMpICYmIGMgIT09IDB4RkVGRlxuICAgICYmICFpc1doaXRlc3BhY2UoYykgLy8gLSBzLXdoaXRlXG4gICAgLy8gLSAoYy1pbmRpY2F0b3IgOjo9XG4gICAgLy8g4oCcLeKAnSB8IOKAnD/igJ0gfCDigJw64oCdIHwg4oCcLOKAnSB8IOKAnFvigJ0gfCDigJxd4oCdIHwg4oCce+KAnSB8IOKAnH3igJ1cbiAgICAmJiBjICE9PSBDSEFSX01JTlVTXG4gICAgJiYgYyAhPT0gQ0hBUl9RVUVTVElPTlxuICAgICYmIGMgIT09IENIQVJfQ09MT05cbiAgICAmJiBjICE9PSBDSEFSX0NPTU1BXG4gICAgJiYgYyAhPT0gQ0hBUl9MRUZUX1NRVUFSRV9CUkFDS0VUXG4gICAgJiYgYyAhPT0gQ0hBUl9SSUdIVF9TUVVBUkVfQlJBQ0tFVFxuICAgICYmIGMgIT09IENIQVJfTEVGVF9DVVJMWV9CUkFDS0VUXG4gICAgJiYgYyAhPT0gQ0hBUl9SSUdIVF9DVVJMWV9CUkFDS0VUXG4gICAgLy8gfCDigJwj4oCdIHwg4oCcJuKAnSB8IOKAnCrigJ0gfCDigJwh4oCdIHwg4oCcfOKAnSB8IOKAnD7igJ0gfCDigJwn4oCdIHwg4oCcXCLigJ1cbiAgICAmJiBjICE9PSBDSEFSX1NIQVJQXG4gICAgJiYgYyAhPT0gQ0hBUl9BTVBFUlNBTkRcbiAgICAmJiBjICE9PSBDSEFSX0FTVEVSSVNLXG4gICAgJiYgYyAhPT0gQ0hBUl9FWENMQU1BVElPTlxuICAgICYmIGMgIT09IENIQVJfVkVSVElDQUxfTElORVxuICAgICYmIGMgIT09IENIQVJfR1JFQVRFUl9USEFOXG4gICAgJiYgYyAhPT0gQ0hBUl9TSU5HTEVfUVVPVEVcbiAgICAmJiBjICE9PSBDSEFSX0RPVUJMRV9RVU9URVxuICAgIC8vIHwg4oCcJeKAnSB8IOKAnEDigJ0gfCDigJxg4oCdKVxuICAgICYmIGMgIT09IENIQVJfUEVSQ0VOVFxuICAgICYmIGMgIT09IENIQVJfQ09NTUVSQ0lBTF9BVFxuICAgICYmIGMgIT09IENIQVJfR1JBVkVfQUNDRU5UO1xufVxuXG52YXIgU1RZTEVfUExBSU4gICA9IDEsXG4gICAgU1RZTEVfU0lOR0xFICA9IDIsXG4gICAgU1RZTEVfTElURVJBTCA9IDMsXG4gICAgU1RZTEVfRk9MREVEICA9IDQsXG4gICAgU1RZTEVfRE9VQkxFICA9IDU7XG5cbi8vIERldGVybWluZXMgd2hpY2ggc2NhbGFyIHN0eWxlcyBhcmUgcG9zc2libGUgYW5kIHJldHVybnMgdGhlIHByZWZlcnJlZCBzdHlsZS5cbi8vIGxpbmVXaWR0aCA9IC0xID0+IG5vIGxpbWl0LlxuLy8gUHJlLWNvbmRpdGlvbnM6IHN0ci5sZW5ndGggPiAwLlxuLy8gUG9zdC1jb25kaXRpb25zOlxuLy8gICAgU1RZTEVfUExBSU4gb3IgU1RZTEVfU0lOR0xFID0+IG5vIFxcbiBhcmUgaW4gdGhlIHN0cmluZy5cbi8vICAgIFNUWUxFX0xJVEVSQUwgPT4gbm8gbGluZXMgYXJlIHN1aXRhYmxlIGZvciBmb2xkaW5nIChvciBsaW5lV2lkdGggaXMgLTEpLlxuLy8gICAgU1RZTEVfRk9MREVEID0+IGEgbGluZSA+IGxpbmVXaWR0aCBhbmQgY2FuIGJlIGZvbGRlZCAoYW5kIGxpbmVXaWR0aCAhPSAtMSkuXG5mdW5jdGlvbiBjaG9vc2VTY2FsYXJTdHlsZShzdHJpbmcsIHNpbmdsZUxpbmVPbmx5LCBpbmRlbnRQZXJMZXZlbCwgbGluZVdpZHRoLCB0ZXN0QW1iaWd1b3VzVHlwZSkge1xuICB2YXIgaTtcbiAgdmFyIGNoYXI7XG4gIHZhciBoYXNMaW5lQnJlYWsgPSBmYWxzZTtcbiAgdmFyIGhhc0ZvbGRhYmxlTGluZSA9IGZhbHNlOyAvLyBvbmx5IGNoZWNrZWQgaWYgc2hvdWxkVHJhY2tXaWR0aFxuICB2YXIgc2hvdWxkVHJhY2tXaWR0aCA9IGxpbmVXaWR0aCAhPT0gLTE7XG4gIHZhciBwcmV2aW91c0xpbmVCcmVhayA9IC0xOyAvLyBjb3VudCB0aGUgZmlyc3QgbGluZSBjb3JyZWN0bHlcbiAgdmFyIHBsYWluID0gaXNQbGFpblNhZmVGaXJzdChzdHJpbmcuY2hhckNvZGVBdCgwKSlcbiAgICAgICAgICAmJiAhaXNXaGl0ZXNwYWNlKHN0cmluZy5jaGFyQ29kZUF0KHN0cmluZy5sZW5ndGggLSAxKSk7XG5cbiAgaWYgKHNpbmdsZUxpbmVPbmx5KSB7XG4gICAgLy8gQ2FzZTogbm8gYmxvY2sgc3R5bGVzLlxuICAgIC8vIENoZWNrIGZvciBkaXNhbGxvd2VkIGNoYXJhY3RlcnMgdG8gcnVsZSBvdXQgcGxhaW4gYW5kIHNpbmdsZS5cbiAgICBmb3IgKGkgPSAwOyBpIDwgc3RyaW5nLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjaGFyID0gc3RyaW5nLmNoYXJDb2RlQXQoaSk7XG4gICAgICBpZiAoIWlzUHJpbnRhYmxlKGNoYXIpKSB7XG4gICAgICAgIHJldHVybiBTVFlMRV9ET1VCTEU7XG4gICAgICB9XG4gICAgICBwbGFpbiA9IHBsYWluICYmIGlzUGxhaW5TYWZlKGNoYXIpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICAvLyBDYXNlOiBibG9jayBzdHlsZXMgcGVybWl0dGVkLlxuICAgIGZvciAoaSA9IDA7IGkgPCBzdHJpbmcubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNoYXIgPSBzdHJpbmcuY2hhckNvZGVBdChpKTtcbiAgICAgIGlmIChjaGFyID09PSBDSEFSX0xJTkVfRkVFRCkge1xuICAgICAgICBoYXNMaW5lQnJlYWsgPSB0cnVlO1xuICAgICAgICAvLyBDaGVjayBpZiBhbnkgbGluZSBjYW4gYmUgZm9sZGVkLlxuICAgICAgICBpZiAoc2hvdWxkVHJhY2tXaWR0aCkge1xuICAgICAgICAgIGhhc0ZvbGRhYmxlTGluZSA9IGhhc0ZvbGRhYmxlTGluZSB8fFxuICAgICAgICAgICAgLy8gRm9sZGFibGUgbGluZSA9IHRvbyBsb25nLCBhbmQgbm90IG1vcmUtaW5kZW50ZWQuXG4gICAgICAgICAgICAoaSAtIHByZXZpb3VzTGluZUJyZWFrIC0gMSA+IGxpbmVXaWR0aCAmJlxuICAgICAgICAgICAgIHN0cmluZ1twcmV2aW91c0xpbmVCcmVhayArIDFdICE9PSAnICcpO1xuICAgICAgICAgIHByZXZpb3VzTGluZUJyZWFrID0gaTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmICghaXNQcmludGFibGUoY2hhcikpIHtcbiAgICAgICAgcmV0dXJuIFNUWUxFX0RPVUJMRTtcbiAgICAgIH1cbiAgICAgIHBsYWluID0gcGxhaW4gJiYgaXNQbGFpblNhZmUoY2hhcik7XG4gICAgfVxuICAgIC8vIGluIGNhc2UgdGhlIGVuZCBpcyBtaXNzaW5nIGEgXFxuXG4gICAgaGFzRm9sZGFibGVMaW5lID0gaGFzRm9sZGFibGVMaW5lIHx8IChzaG91bGRUcmFja1dpZHRoICYmXG4gICAgICAoaSAtIHByZXZpb3VzTGluZUJyZWFrIC0gMSA+IGxpbmVXaWR0aCAmJlxuICAgICAgIHN0cmluZ1twcmV2aW91c0xpbmVCcmVhayArIDFdICE9PSAnICcpKTtcbiAgfVxuICAvLyBBbHRob3VnaCBldmVyeSBzdHlsZSBjYW4gcmVwcmVzZW50IFxcbiB3aXRob3V0IGVzY2FwaW5nLCBwcmVmZXIgYmxvY2sgc3R5bGVzXG4gIC8vIGZvciBtdWx0aWxpbmUsIHNpbmNlIHRoZXkncmUgbW9yZSByZWFkYWJsZSBhbmQgdGhleSBkb24ndCBhZGQgZW1wdHkgbGluZXMuXG4gIC8vIEFsc28gcHJlZmVyIGZvbGRpbmcgYSBzdXBlci1sb25nIGxpbmUuXG4gIGlmICghaGFzTGluZUJyZWFrICYmICFoYXNGb2xkYWJsZUxpbmUpIHtcbiAgICAvLyBTdHJpbmdzIGludGVycHJldGFibGUgYXMgYW5vdGhlciB0eXBlIGhhdmUgdG8gYmUgcXVvdGVkO1xuICAgIC8vIGUuZy4gdGhlIHN0cmluZyAndHJ1ZScgdnMuIHRoZSBib29sZWFuIHRydWUuXG4gICAgcmV0dXJuIHBsYWluICYmICF0ZXN0QW1iaWd1b3VzVHlwZShzdHJpbmcpXG4gICAgICA/IFNUWUxFX1BMQUlOIDogU1RZTEVfU0lOR0xFO1xuICB9XG4gIC8vIEVkZ2UgY2FzZTogYmxvY2sgaW5kZW50YXRpb24gaW5kaWNhdG9yIGNhbiBvbmx5IGhhdmUgb25lIGRpZ2l0LlxuICBpZiAoc3RyaW5nWzBdID09PSAnICcgJiYgaW5kZW50UGVyTGV2ZWwgPiA5KSB7XG4gICAgcmV0dXJuIFNUWUxFX0RPVUJMRTtcbiAgfVxuICAvLyBBdCB0aGlzIHBvaW50IHdlIGtub3cgYmxvY2sgc3R5bGVzIGFyZSB2YWxpZC5cbiAgLy8gUHJlZmVyIGxpdGVyYWwgc3R5bGUgdW5sZXNzIHdlIHdhbnQgdG8gZm9sZC5cbiAgcmV0dXJuIGhhc0ZvbGRhYmxlTGluZSA/IFNUWUxFX0ZPTERFRCA6IFNUWUxFX0xJVEVSQUw7XG59XG5cbi8vIE5vdGU6IGxpbmUgYnJlYWtpbmcvZm9sZGluZyBpcyBpbXBsZW1lbnRlZCBmb3Igb25seSB0aGUgZm9sZGVkIHN0eWxlLlxuLy8gTkIuIFdlIGRyb3AgdGhlIGxhc3QgdHJhaWxpbmcgbmV3bGluZSAoaWYgYW55KSBvZiBhIHJldHVybmVkIGJsb2NrIHNjYWxhclxuLy8gIHNpbmNlIHRoZSBkdW1wZXIgYWRkcyBpdHMgb3duIG5ld2xpbmUuIFRoaXMgYWx3YXlzIHdvcmtzOlxuLy8gICAg4oCiIE5vIGVuZGluZyBuZXdsaW5lID0+IHVuYWZmZWN0ZWQ7IGFscmVhZHkgdXNpbmcgc3RyaXAgXCItXCIgY2hvbXBpbmcuXG4vLyAgICDigKIgRW5kaW5nIG5ld2xpbmUgICAgPT4gcmVtb3ZlZCB0aGVuIHJlc3RvcmVkLlxuLy8gIEltcG9ydGFudGx5LCB0aGlzIGtlZXBzIHRoZSBcIitcIiBjaG9tcCBpbmRpY2F0b3IgZnJvbSBnYWluaW5nIGFuIGV4dHJhIGxpbmUuXG5mdW5jdGlvbiB3cml0ZVNjYWxhcihzdGF0ZSwgc3RyaW5nLCBsZXZlbCwgaXNrZXkpIHtcbiAgc3RhdGUuZHVtcCA9IChmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHN0cmluZy5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiBcIicnXCI7XG4gICAgfVxuICAgIGlmICghc3RhdGUubm9Db21wYXRNb2RlICYmXG4gICAgICAgIERFUFJFQ0FURURfQk9PTEVBTlNfU1lOVEFYLmluZGV4T2Yoc3RyaW5nKSAhPT0gLTEpIHtcbiAgICAgIHJldHVybiBcIidcIiArIHN0cmluZyArIFwiJ1wiO1xuICAgIH1cblxuICAgIHZhciBpbmRlbnQgPSBzdGF0ZS5pbmRlbnQgKiBNYXRoLm1heCgxLCBsZXZlbCk7IC8vIG5vIDAtaW5kZW50IHNjYWxhcnNcbiAgICAvLyBBcyBpbmRlbnRhdGlvbiBnZXRzIGRlZXBlciwgbGV0IHRoZSB3aWR0aCBkZWNyZWFzZSBtb25vdG9uaWNhbGx5XG4gICAgLy8gdG8gdGhlIGxvd2VyIGJvdW5kIG1pbihzdGF0ZS5saW5lV2lkdGgsIDQwKS5cbiAgICAvLyBOb3RlIHRoYXQgdGhpcyBpbXBsaWVzXG4gICAgLy8gIHN0YXRlLmxpbmVXaWR0aCDiiaQgNDAgKyBzdGF0ZS5pbmRlbnQ6IHdpZHRoIGlzIGZpeGVkIGF0IHRoZSBsb3dlciBib3VuZC5cbiAgICAvLyAgc3RhdGUubGluZVdpZHRoID4gNDAgKyBzdGF0ZS5pbmRlbnQ6IHdpZHRoIGRlY3JlYXNlcyB1bnRpbCB0aGUgbG93ZXIgYm91bmQuXG4gICAgLy8gVGhpcyBiZWhhdmVzIGJldHRlciB0aGFuIGEgY29uc3RhbnQgbWluaW11bSB3aWR0aCB3aGljaCBkaXNhbGxvd3MgbmFycm93ZXIgb3B0aW9ucyxcbiAgICAvLyBvciBhbiBpbmRlbnQgdGhyZXNob2xkIHdoaWNoIGNhdXNlcyB0aGUgd2lkdGggdG8gc3VkZGVubHkgaW5jcmVhc2UuXG4gICAgdmFyIGxpbmVXaWR0aCA9IHN0YXRlLmxpbmVXaWR0aCA9PT0gLTFcbiAgICAgID8gLTEgOiBNYXRoLm1heChNYXRoLm1pbihzdGF0ZS5saW5lV2lkdGgsIDQwKSwgc3RhdGUubGluZVdpZHRoIC0gaW5kZW50KTtcblxuICAgIC8vIFdpdGhvdXQga25vd2luZyBpZiBrZXlzIGFyZSBpbXBsaWNpdC9leHBsaWNpdCwgYXNzdW1lIGltcGxpY2l0IGZvciBzYWZldHkuXG4gICAgdmFyIHNpbmdsZUxpbmVPbmx5ID0gaXNrZXlcbiAgICAgIC8vIE5vIGJsb2NrIHN0eWxlcyBpbiBmbG93IG1vZGUuXG4gICAgICB8fCAoc3RhdGUuZmxvd0xldmVsID4gLTEgJiYgbGV2ZWwgPj0gc3RhdGUuZmxvd0xldmVsKTtcbiAgICBmdW5jdGlvbiB0ZXN0QW1iaWd1aXR5KHN0cmluZykge1xuICAgICAgcmV0dXJuIHRlc3RJbXBsaWNpdFJlc29sdmluZyhzdGF0ZSwgc3RyaW5nKTtcbiAgICB9XG5cbiAgICBzd2l0Y2ggKGNob29zZVNjYWxhclN0eWxlKHN0cmluZywgc2luZ2xlTGluZU9ubHksIHN0YXRlLmluZGVudCwgbGluZVdpZHRoLCB0ZXN0QW1iaWd1aXR5KSkge1xuICAgICAgY2FzZSBTVFlMRV9QTEFJTjpcbiAgICAgICAgcmV0dXJuIHN0cmluZztcbiAgICAgIGNhc2UgU1RZTEVfU0lOR0xFOlxuICAgICAgICByZXR1cm4gXCInXCIgKyBzdHJpbmcucmVwbGFjZSgvJy9nLCBcIicnXCIpICsgXCInXCI7XG4gICAgICBjYXNlIFNUWUxFX0xJVEVSQUw6XG4gICAgICAgIHJldHVybiAnfCcgKyBibG9ja0hlYWRlcihzdHJpbmcsIHN0YXRlLmluZGVudClcbiAgICAgICAgICArIGRyb3BFbmRpbmdOZXdsaW5lKGluZGVudFN0cmluZyhzdHJpbmcsIGluZGVudCkpO1xuICAgICAgY2FzZSBTVFlMRV9GT0xERUQ6XG4gICAgICAgIHJldHVybiAnPicgKyBibG9ja0hlYWRlcihzdHJpbmcsIHN0YXRlLmluZGVudClcbiAgICAgICAgICArIGRyb3BFbmRpbmdOZXdsaW5lKGluZGVudFN0cmluZyhmb2xkU3RyaW5nKHN0cmluZywgbGluZVdpZHRoKSwgaW5kZW50KSk7XG4gICAgICBjYXNlIFNUWUxFX0RPVUJMRTpcbiAgICAgICAgcmV0dXJuICdcIicgKyBlc2NhcGVTdHJpbmcoc3RyaW5nLCBsaW5lV2lkdGgpICsgJ1wiJztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHRocm93IG5ldyBZQU1MRXhjZXB0aW9uKCdpbXBvc3NpYmxlIGVycm9yOiBpbnZhbGlkIHNjYWxhciBzdHlsZScpO1xuICAgIH1cbiAgfSgpKTtcbn1cblxuLy8gUHJlLWNvbmRpdGlvbnM6IHN0cmluZyBpcyB2YWxpZCBmb3IgYSBibG9jayBzY2FsYXIsIDEgPD0gaW5kZW50UGVyTGV2ZWwgPD0gOS5cbmZ1bmN0aW9uIGJsb2NrSGVhZGVyKHN0cmluZywgaW5kZW50UGVyTGV2ZWwpIHtcbiAgdmFyIGluZGVudEluZGljYXRvciA9IChzdHJpbmdbMF0gPT09ICcgJykgPyBTdHJpbmcoaW5kZW50UGVyTGV2ZWwpIDogJyc7XG5cbiAgLy8gbm90ZSB0aGUgc3BlY2lhbCBjYXNlOiB0aGUgc3RyaW5nICdcXG4nIGNvdW50cyBhcyBhIFwidHJhaWxpbmdcIiBlbXB0eSBsaW5lLlxuICB2YXIgY2xpcCA9ICAgICAgICAgIHN0cmluZ1tzdHJpbmcubGVuZ3RoIC0gMV0gPT09ICdcXG4nO1xuICB2YXIga2VlcCA9IGNsaXAgJiYgKHN0cmluZ1tzdHJpbmcubGVuZ3RoIC0gMl0gPT09ICdcXG4nIHx8IHN0cmluZyA9PT0gJ1xcbicpO1xuICB2YXIgY2hvbXAgPSBrZWVwID8gJysnIDogKGNsaXAgPyAnJyA6ICctJyk7XG5cbiAgcmV0dXJuIGluZGVudEluZGljYXRvciArIGNob21wICsgJ1xcbic7XG59XG5cbi8vIChTZWUgdGhlIG5vdGUgZm9yIHdyaXRlU2NhbGFyLilcbmZ1bmN0aW9uIGRyb3BFbmRpbmdOZXdsaW5lKHN0cmluZykge1xuICByZXR1cm4gc3RyaW5nW3N0cmluZy5sZW5ndGggLSAxXSA9PT0gJ1xcbicgPyBzdHJpbmcuc2xpY2UoMCwgLTEpIDogc3RyaW5nO1xufVxuXG4vLyBOb3RlOiBhIGxvbmcgbGluZSB3aXRob3V0IGEgc3VpdGFibGUgYnJlYWsgcG9pbnQgd2lsbCBleGNlZWQgdGhlIHdpZHRoIGxpbWl0LlxuLy8gUHJlLWNvbmRpdGlvbnM6IGV2ZXJ5IGNoYXIgaW4gc3RyIGlzUHJpbnRhYmxlLCBzdHIubGVuZ3RoID4gMCwgd2lkdGggPiAwLlxuZnVuY3Rpb24gZm9sZFN0cmluZyhzdHJpbmcsIHdpZHRoKSB7XG4gIC8vIEluIGZvbGRlZCBzdHlsZSwgJGskIGNvbnNlY3V0aXZlIG5ld2xpbmVzIG91dHB1dCBhcyAkaysxJCBuZXdsaW5lc+KAlFxuICAvLyB1bmxlc3MgdGhleSdyZSBiZWZvcmUgb3IgYWZ0ZXIgYSBtb3JlLWluZGVudGVkIGxpbmUsIG9yIGF0IHRoZSB2ZXJ5XG4gIC8vIGJlZ2lubmluZyBvciBlbmQsIGluIHdoaWNoIGNhc2UgJGskIG1hcHMgdG8gJGskLlxuICAvLyBUaGVyZWZvcmUsIHBhcnNlIGVhY2ggY2h1bmsgYXMgbmV3bGluZShzKSBmb2xsb3dlZCBieSBhIGNvbnRlbnQgbGluZS5cbiAgdmFyIGxpbmVSZSA9IC8oXFxuKykoW15cXG5dKikvZztcblxuICAvLyBmaXJzdCBsaW5lIChwb3NzaWJseSBhbiBlbXB0eSBsaW5lKVxuICB2YXIgcmVzdWx0ID0gKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgbmV4dExGID0gc3RyaW5nLmluZGV4T2YoJ1xcbicpO1xuICAgIG5leHRMRiA9IG5leHRMRiAhPT0gLTEgPyBuZXh0TEYgOiBzdHJpbmcubGVuZ3RoO1xuICAgIGxpbmVSZS5sYXN0SW5kZXggPSBuZXh0TEY7XG4gICAgcmV0dXJuIGZvbGRMaW5lKHN0cmluZy5zbGljZSgwLCBuZXh0TEYpLCB3aWR0aCk7XG4gIH0oKSk7XG4gIC8vIElmIHdlIGhhdmVuJ3QgcmVhY2hlZCB0aGUgZmlyc3QgY29udGVudCBsaW5lIHlldCwgZG9uJ3QgYWRkIGFuIGV4dHJhIFxcbi5cbiAgdmFyIHByZXZNb3JlSW5kZW50ZWQgPSBzdHJpbmdbMF0gPT09ICdcXG4nIHx8IHN0cmluZ1swXSA9PT0gJyAnO1xuICB2YXIgbW9yZUluZGVudGVkO1xuXG4gIC8vIHJlc3Qgb2YgdGhlIGxpbmVzXG4gIHZhciBtYXRjaDtcbiAgd2hpbGUgKChtYXRjaCA9IGxpbmVSZS5leGVjKHN0cmluZykpKSB7XG4gICAgdmFyIHByZWZpeCA9IG1hdGNoWzFdLCBsaW5lID0gbWF0Y2hbMl07XG4gICAgbW9yZUluZGVudGVkID0gKGxpbmVbMF0gPT09ICcgJyk7XG4gICAgcmVzdWx0ICs9IHByZWZpeFxuICAgICAgKyAoIXByZXZNb3JlSW5kZW50ZWQgJiYgIW1vcmVJbmRlbnRlZCAmJiBsaW5lICE9PSAnJ1xuICAgICAgICA/ICdcXG4nIDogJycpXG4gICAgICArIGZvbGRMaW5lKGxpbmUsIHdpZHRoKTtcbiAgICBwcmV2TW9yZUluZGVudGVkID0gbW9yZUluZGVudGVkO1xuICB9XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLy8gR3JlZWR5IGxpbmUgYnJlYWtpbmcuXG4vLyBQaWNrcyB0aGUgbG9uZ2VzdCBsaW5lIHVuZGVyIHRoZSBsaW1pdCBlYWNoIHRpbWUsXG4vLyBvdGhlcndpc2Ugc2V0dGxlcyBmb3IgdGhlIHNob3J0ZXN0IGxpbmUgb3ZlciB0aGUgbGltaXQuXG4vLyBOQi4gTW9yZS1pbmRlbnRlZCBsaW5lcyAqY2Fubm90KiBiZSBmb2xkZWQsIGFzIHRoYXQgd291bGQgYWRkIGFuIGV4dHJhIFxcbi5cbmZ1bmN0aW9uIGZvbGRMaW5lKGxpbmUsIHdpZHRoKSB7XG4gIGlmIChsaW5lID09PSAnJyB8fCBsaW5lWzBdID09PSAnICcpIHJldHVybiBsaW5lO1xuXG4gIC8vIFNpbmNlIGEgbW9yZS1pbmRlbnRlZCBsaW5lIGFkZHMgYSBcXG4sIGJyZWFrcyBjYW4ndCBiZSBmb2xsb3dlZCBieSBhIHNwYWNlLlxuICB2YXIgYnJlYWtSZSA9IC8gW14gXS9nOyAvLyBub3RlOiB0aGUgbWF0Y2ggaW5kZXggd2lsbCBhbHdheXMgYmUgPD0gbGVuZ3RoLTIuXG4gIHZhciBtYXRjaDtcbiAgLy8gc3RhcnQgaXMgYW4gaW5jbHVzaXZlIGluZGV4LiBlbmQsIGN1cnIsIGFuZCBuZXh0IGFyZSBleGNsdXNpdmUuXG4gIHZhciBzdGFydCA9IDAsIGVuZCwgY3VyciA9IDAsIG5leHQgPSAwO1xuICB2YXIgcmVzdWx0ID0gJyc7XG5cbiAgLy8gSW52YXJpYW50czogMCA8PSBzdGFydCA8PSBsZW5ndGgtMS5cbiAgLy8gICAwIDw9IGN1cnIgPD0gbmV4dCA8PSBtYXgoMCwgbGVuZ3RoLTIpLiBjdXJyIC0gc3RhcnQgPD0gd2lkdGguXG4gIC8vIEluc2lkZSB0aGUgbG9vcDpcbiAgLy8gICBBIG1hdGNoIGltcGxpZXMgbGVuZ3RoID49IDIsIHNvIGN1cnIgYW5kIG5leHQgYXJlIDw9IGxlbmd0aC0yLlxuICB3aGlsZSAoKG1hdGNoID0gYnJlYWtSZS5leGVjKGxpbmUpKSkge1xuICAgIG5leHQgPSBtYXRjaC5pbmRleDtcbiAgICAvLyBtYWludGFpbiBpbnZhcmlhbnQ6IGN1cnIgLSBzdGFydCA8PSB3aWR0aFxuICAgIGlmIChuZXh0IC0gc3RhcnQgPiB3aWR0aCkge1xuICAgICAgZW5kID0gKGN1cnIgPiBzdGFydCkgPyBjdXJyIDogbmV4dDsgLy8gZGVyaXZlIGVuZCA8PSBsZW5ndGgtMlxuICAgICAgcmVzdWx0ICs9ICdcXG4nICsgbGluZS5zbGljZShzdGFydCwgZW5kKTtcbiAgICAgIC8vIHNraXAgdGhlIHNwYWNlIHRoYXQgd2FzIG91dHB1dCBhcyBcXG5cbiAgICAgIHN0YXJ0ID0gZW5kICsgMTsgICAgICAgICAgICAgICAgICAgIC8vIGRlcml2ZSBzdGFydCA8PSBsZW5ndGgtMVxuICAgIH1cbiAgICBjdXJyID0gbmV4dDtcbiAgfVxuXG4gIC8vIEJ5IHRoZSBpbnZhcmlhbnRzLCBzdGFydCA8PSBsZW5ndGgtMSwgc28gdGhlcmUgaXMgc29tZXRoaW5nIGxlZnQgb3Zlci5cbiAgLy8gSXQgaXMgZWl0aGVyIHRoZSB3aG9sZSBzdHJpbmcgb3IgYSBwYXJ0IHN0YXJ0aW5nIGZyb20gbm9uLXdoaXRlc3BhY2UuXG4gIHJlc3VsdCArPSAnXFxuJztcbiAgLy8gSW5zZXJ0IGEgYnJlYWsgaWYgdGhlIHJlbWFpbmRlciBpcyB0b28gbG9uZyBhbmQgdGhlcmUgaXMgYSBicmVhayBhdmFpbGFibGUuXG4gIGlmIChsaW5lLmxlbmd0aCAtIHN0YXJ0ID4gd2lkdGggJiYgY3VyciA+IHN0YXJ0KSB7XG4gICAgcmVzdWx0ICs9IGxpbmUuc2xpY2Uoc3RhcnQsIGN1cnIpICsgJ1xcbicgKyBsaW5lLnNsaWNlKGN1cnIgKyAxKTtcbiAgfSBlbHNlIHtcbiAgICByZXN1bHQgKz0gbGluZS5zbGljZShzdGFydCk7XG4gIH1cblxuICByZXR1cm4gcmVzdWx0LnNsaWNlKDEpOyAvLyBkcm9wIGV4dHJhIFxcbiBqb2luZXJcbn1cblxuLy8gRXNjYXBlcyBhIGRvdWJsZS1xdW90ZWQgc3RyaW5nLlxuZnVuY3Rpb24gZXNjYXBlU3RyaW5nKHN0cmluZykge1xuICB2YXIgcmVzdWx0ID0gJyc7XG4gIHZhciBjaGFyLCBuZXh0Q2hhcjtcbiAgdmFyIGVzY2FwZVNlcTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IHN0cmluZy5sZW5ndGg7IGkrKykge1xuICAgIGNoYXIgPSBzdHJpbmcuY2hhckNvZGVBdChpKTtcbiAgICAvLyBDaGVjayBmb3Igc3Vycm9nYXRlIHBhaXJzIChyZWZlcmVuY2UgVW5pY29kZSAzLjAgc2VjdGlvbiBcIjMuNyBTdXJyb2dhdGVzXCIpLlxuICAgIGlmIChjaGFyID49IDB4RDgwMCAmJiBjaGFyIDw9IDB4REJGRi8qIGhpZ2ggc3Vycm9nYXRlICovKSB7XG4gICAgICBuZXh0Q2hhciA9IHN0cmluZy5jaGFyQ29kZUF0KGkgKyAxKTtcbiAgICAgIGlmIChuZXh0Q2hhciA+PSAweERDMDAgJiYgbmV4dENoYXIgPD0gMHhERkZGLyogbG93IHN1cnJvZ2F0ZSAqLykge1xuICAgICAgICAvLyBDb21iaW5lIHRoZSBzdXJyb2dhdGUgcGFpciBhbmQgc3RvcmUgaXQgZXNjYXBlZC5cbiAgICAgICAgcmVzdWx0ICs9IGVuY29kZUhleCgoY2hhciAtIDB4RDgwMCkgKiAweDQwMCArIG5leHRDaGFyIC0gMHhEQzAwICsgMHgxMDAwMCk7XG4gICAgICAgIC8vIEFkdmFuY2UgaW5kZXggb25lIGV4dHJhIHNpbmNlIHdlIGFscmVhZHkgdXNlZCB0aGF0IGNoYXIgaGVyZS5cbiAgICAgICAgaSsrOyBjb250aW51ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgZXNjYXBlU2VxID0gRVNDQVBFX1NFUVVFTkNFU1tjaGFyXTtcbiAgICByZXN1bHQgKz0gIWVzY2FwZVNlcSAmJiBpc1ByaW50YWJsZShjaGFyKVxuICAgICAgPyBzdHJpbmdbaV1cbiAgICAgIDogZXNjYXBlU2VxIHx8IGVuY29kZUhleChjaGFyKTtcbiAgfVxuXG4gIHJldHVybiByZXN1bHQ7XG59XG5cbmZ1bmN0aW9uIHdyaXRlRmxvd1NlcXVlbmNlKHN0YXRlLCBsZXZlbCwgb2JqZWN0KSB7XG4gIHZhciBfcmVzdWx0ID0gJycsXG4gICAgICBfdGFnICAgID0gc3RhdGUudGFnLFxuICAgICAgaW5kZXgsXG4gICAgICBsZW5ndGg7XG5cbiAgZm9yIChpbmRleCA9IDAsIGxlbmd0aCA9IG9iamVjdC5sZW5ndGg7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCArPSAxKSB7XG4gICAgLy8gV3JpdGUgb25seSB2YWxpZCBlbGVtZW50cy5cbiAgICBpZiAod3JpdGVOb2RlKHN0YXRlLCBsZXZlbCwgb2JqZWN0W2luZGV4XSwgZmFsc2UsIGZhbHNlKSkge1xuICAgICAgaWYgKGluZGV4ICE9PSAwKSBfcmVzdWx0ICs9ICcsJyArICghc3RhdGUuY29uZGVuc2VGbG93ID8gJyAnIDogJycpO1xuICAgICAgX3Jlc3VsdCArPSBzdGF0ZS5kdW1wO1xuICAgIH1cbiAgfVxuXG4gIHN0YXRlLnRhZyA9IF90YWc7XG4gIHN0YXRlLmR1bXAgPSAnWycgKyBfcmVzdWx0ICsgJ10nO1xufVxuXG5mdW5jdGlvbiB3cml0ZUJsb2NrU2VxdWVuY2Uoc3RhdGUsIGxldmVsLCBvYmplY3QsIGNvbXBhY3QpIHtcbiAgdmFyIF9yZXN1bHQgPSAnJyxcbiAgICAgIF90YWcgICAgPSBzdGF0ZS50YWcsXG4gICAgICBpbmRleCxcbiAgICAgIGxlbmd0aDtcblxuICBmb3IgKGluZGV4ID0gMCwgbGVuZ3RoID0gb2JqZWN0Lmxlbmd0aDsgaW5kZXggPCBsZW5ndGg7IGluZGV4ICs9IDEpIHtcbiAgICAvLyBXcml0ZSBvbmx5IHZhbGlkIGVsZW1lbnRzLlxuICAgIGlmICh3cml0ZU5vZGUoc3RhdGUsIGxldmVsICsgMSwgb2JqZWN0W2luZGV4XSwgdHJ1ZSwgdHJ1ZSkpIHtcbiAgICAgIGlmICghY29tcGFjdCB8fCBpbmRleCAhPT0gMCkge1xuICAgICAgICBfcmVzdWx0ICs9IGdlbmVyYXRlTmV4dExpbmUoc3RhdGUsIGxldmVsKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHN0YXRlLmR1bXAgJiYgQ0hBUl9MSU5FX0ZFRUQgPT09IHN0YXRlLmR1bXAuY2hhckNvZGVBdCgwKSkge1xuICAgICAgICBfcmVzdWx0ICs9ICctJztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIF9yZXN1bHQgKz0gJy0gJztcbiAgICAgIH1cblxuICAgICAgX3Jlc3VsdCArPSBzdGF0ZS5kdW1wO1xuICAgIH1cbiAgfVxuXG4gIHN0YXRlLnRhZyA9IF90YWc7XG4gIHN0YXRlLmR1bXAgPSBfcmVzdWx0IHx8ICdbXSc7IC8vIEVtcHR5IHNlcXVlbmNlIGlmIG5vIHZhbGlkIHZhbHVlcy5cbn1cblxuZnVuY3Rpb24gd3JpdGVGbG93TWFwcGluZyhzdGF0ZSwgbGV2ZWwsIG9iamVjdCkge1xuICB2YXIgX3Jlc3VsdCAgICAgICA9ICcnLFxuICAgICAgX3RhZyAgICAgICAgICA9IHN0YXRlLnRhZyxcbiAgICAgIG9iamVjdEtleUxpc3QgPSBPYmplY3Qua2V5cyhvYmplY3QpLFxuICAgICAgaW5kZXgsXG4gICAgICBsZW5ndGgsXG4gICAgICBvYmplY3RLZXksXG4gICAgICBvYmplY3RWYWx1ZSxcbiAgICAgIHBhaXJCdWZmZXI7XG5cbiAgZm9yIChpbmRleCA9IDAsIGxlbmd0aCA9IG9iamVjdEtleUxpc3QubGVuZ3RoOyBpbmRleCA8IGxlbmd0aDsgaW5kZXggKz0gMSkge1xuICAgIHBhaXJCdWZmZXIgPSBzdGF0ZS5jb25kZW5zZUZsb3cgPyAnXCInIDogJyc7XG5cbiAgICBpZiAoaW5kZXggIT09IDApIHBhaXJCdWZmZXIgKz0gJywgJztcblxuICAgIG9iamVjdEtleSA9IG9iamVjdEtleUxpc3RbaW5kZXhdO1xuICAgIG9iamVjdFZhbHVlID0gb2JqZWN0W29iamVjdEtleV07XG5cbiAgICBpZiAoIXdyaXRlTm9kZShzdGF0ZSwgbGV2ZWwsIG9iamVjdEtleSwgZmFsc2UsIGZhbHNlKSkge1xuICAgICAgY29udGludWU7IC8vIFNraXAgdGhpcyBwYWlyIGJlY2F1c2Ugb2YgaW52YWxpZCBrZXk7XG4gICAgfVxuXG4gICAgaWYgKHN0YXRlLmR1bXAubGVuZ3RoID4gMTAyNCkgcGFpckJ1ZmZlciArPSAnPyAnO1xuXG4gICAgcGFpckJ1ZmZlciArPSBzdGF0ZS5kdW1wICsgKHN0YXRlLmNvbmRlbnNlRmxvdyA/ICdcIicgOiAnJykgKyAnOicgKyAoc3RhdGUuY29uZGVuc2VGbG93ID8gJycgOiAnICcpO1xuXG4gICAgaWYgKCF3cml0ZU5vZGUoc3RhdGUsIGxldmVsLCBvYmplY3RWYWx1ZSwgZmFsc2UsIGZhbHNlKSkge1xuICAgICAgY29udGludWU7IC8vIFNraXAgdGhpcyBwYWlyIGJlY2F1c2Ugb2YgaW52YWxpZCB2YWx1ZS5cbiAgICB9XG5cbiAgICBwYWlyQnVmZmVyICs9IHN0YXRlLmR1bXA7XG5cbiAgICAvLyBCb3RoIGtleSBhbmQgdmFsdWUgYXJlIHZhbGlkLlxuICAgIF9yZXN1bHQgKz0gcGFpckJ1ZmZlcjtcbiAgfVxuXG4gIHN0YXRlLnRhZyA9IF90YWc7XG4gIHN0YXRlLmR1bXAgPSAneycgKyBfcmVzdWx0ICsgJ30nO1xufVxuXG5mdW5jdGlvbiB3cml0ZUJsb2NrTWFwcGluZyhzdGF0ZSwgbGV2ZWwsIG9iamVjdCwgY29tcGFjdCkge1xuICB2YXIgX3Jlc3VsdCAgICAgICA9ICcnLFxuICAgICAgX3RhZyAgICAgICAgICA9IHN0YXRlLnRhZyxcbiAgICAgIG9iamVjdEtleUxpc3QgPSBPYmplY3Qua2V5cyhvYmplY3QpLFxuICAgICAgaW5kZXgsXG4gICAgICBsZW5ndGgsXG4gICAgICBvYmplY3RLZXksXG4gICAgICBvYmplY3RWYWx1ZSxcbiAgICAgIGV4cGxpY2l0UGFpcixcbiAgICAgIHBhaXJCdWZmZXI7XG5cbiAgLy8gQWxsb3cgc29ydGluZyBrZXlzIHNvIHRoYXQgdGhlIG91dHB1dCBmaWxlIGlzIGRldGVybWluaXN0aWNcbiAgaWYgKHN0YXRlLnNvcnRLZXlzID09PSB0cnVlKSB7XG4gICAgLy8gRGVmYXVsdCBzb3J0aW5nXG4gICAgb2JqZWN0S2V5TGlzdC5zb3J0KCk7XG4gIH0gZWxzZSBpZiAodHlwZW9mIHN0YXRlLnNvcnRLZXlzID09PSAnZnVuY3Rpb24nKSB7XG4gICAgLy8gQ3VzdG9tIHNvcnQgZnVuY3Rpb25cbiAgICBvYmplY3RLZXlMaXN0LnNvcnQoc3RhdGUuc29ydEtleXMpO1xuICB9IGVsc2UgaWYgKHN0YXRlLnNvcnRLZXlzKSB7XG4gICAgLy8gU29tZXRoaW5nIGlzIHdyb25nXG4gICAgdGhyb3cgbmV3IFlBTUxFeGNlcHRpb24oJ3NvcnRLZXlzIG11c3QgYmUgYSBib29sZWFuIG9yIGEgZnVuY3Rpb24nKTtcbiAgfVxuXG4gIGZvciAoaW5kZXggPSAwLCBsZW5ndGggPSBvYmplY3RLZXlMaXN0Lmxlbmd0aDsgaW5kZXggPCBsZW5ndGg7IGluZGV4ICs9IDEpIHtcbiAgICBwYWlyQnVmZmVyID0gJyc7XG5cbiAgICBpZiAoIWNvbXBhY3QgfHwgaW5kZXggIT09IDApIHtcbiAgICAgIHBhaXJCdWZmZXIgKz0gZ2VuZXJhdGVOZXh0TGluZShzdGF0ZSwgbGV2ZWwpO1xuICAgIH1cblxuICAgIG9iamVjdEtleSA9IG9iamVjdEtleUxpc3RbaW5kZXhdO1xuICAgIG9iamVjdFZhbHVlID0gb2JqZWN0W29iamVjdEtleV07XG5cbiAgICBpZiAoIXdyaXRlTm9kZShzdGF0ZSwgbGV2ZWwgKyAxLCBvYmplY3RLZXksIHRydWUsIHRydWUsIHRydWUpKSB7XG4gICAgICBjb250aW51ZTsgLy8gU2tpcCB0aGlzIHBhaXIgYmVjYXVzZSBvZiBpbnZhbGlkIGtleS5cbiAgICB9XG5cbiAgICBleHBsaWNpdFBhaXIgPSAoc3RhdGUudGFnICE9PSBudWxsICYmIHN0YXRlLnRhZyAhPT0gJz8nKSB8fFxuICAgICAgICAgICAgICAgICAgIChzdGF0ZS5kdW1wICYmIHN0YXRlLmR1bXAubGVuZ3RoID4gMTAyNCk7XG5cbiAgICBpZiAoZXhwbGljaXRQYWlyKSB7XG4gICAgICBpZiAoc3RhdGUuZHVtcCAmJiBDSEFSX0xJTkVfRkVFRCA9PT0gc3RhdGUuZHVtcC5jaGFyQ29kZUF0KDApKSB7XG4gICAgICAgIHBhaXJCdWZmZXIgKz0gJz8nO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcGFpckJ1ZmZlciArPSAnPyAnO1xuICAgICAgfVxuICAgIH1cblxuICAgIHBhaXJCdWZmZXIgKz0gc3RhdGUuZHVtcDtcblxuICAgIGlmIChleHBsaWNpdFBhaXIpIHtcbiAgICAgIHBhaXJCdWZmZXIgKz0gZ2VuZXJhdGVOZXh0TGluZShzdGF0ZSwgbGV2ZWwpO1xuICAgIH1cblxuICAgIGlmICghd3JpdGVOb2RlKHN0YXRlLCBsZXZlbCArIDEsIG9iamVjdFZhbHVlLCB0cnVlLCBleHBsaWNpdFBhaXIpKSB7XG4gICAgICBjb250aW51ZTsgLy8gU2tpcCB0aGlzIHBhaXIgYmVjYXVzZSBvZiBpbnZhbGlkIHZhbHVlLlxuICAgIH1cblxuICAgIGlmIChzdGF0ZS5kdW1wICYmIENIQVJfTElORV9GRUVEID09PSBzdGF0ZS5kdW1wLmNoYXJDb2RlQXQoMCkpIHtcbiAgICAgIHBhaXJCdWZmZXIgKz0gJzonO1xuICAgIH0gZWxzZSB7XG4gICAgICBwYWlyQnVmZmVyICs9ICc6ICc7XG4gICAgfVxuXG4gICAgcGFpckJ1ZmZlciArPSBzdGF0ZS5kdW1wO1xuXG4gICAgLy8gQm90aCBrZXkgYW5kIHZhbHVlIGFyZSB2YWxpZC5cbiAgICBfcmVzdWx0ICs9IHBhaXJCdWZmZXI7XG4gIH1cblxuICBzdGF0ZS50YWcgPSBfdGFnO1xuICBzdGF0ZS5kdW1wID0gX3Jlc3VsdCB8fCAne30nOyAvLyBFbXB0eSBtYXBwaW5nIGlmIG5vIHZhbGlkIHBhaXJzLlxufVxuXG5mdW5jdGlvbiBkZXRlY3RUeXBlKHN0YXRlLCBvYmplY3QsIGV4cGxpY2l0KSB7XG4gIHZhciBfcmVzdWx0LCB0eXBlTGlzdCwgaW5kZXgsIGxlbmd0aCwgdHlwZSwgc3R5bGU7XG5cbiAgdHlwZUxpc3QgPSBleHBsaWNpdCA/IHN0YXRlLmV4cGxpY2l0VHlwZXMgOiBzdGF0ZS5pbXBsaWNpdFR5cGVzO1xuXG4gIGZvciAoaW5kZXggPSAwLCBsZW5ndGggPSB0eXBlTGlzdC5sZW5ndGg7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCArPSAxKSB7XG4gICAgdHlwZSA9IHR5cGVMaXN0W2luZGV4XTtcblxuICAgIGlmICgodHlwZS5pbnN0YW5jZU9mICB8fCB0eXBlLnByZWRpY2F0ZSkgJiZcbiAgICAgICAgKCF0eXBlLmluc3RhbmNlT2YgfHwgKCh0eXBlb2Ygb2JqZWN0ID09PSAnb2JqZWN0JykgJiYgKG9iamVjdCBpbnN0YW5jZW9mIHR5cGUuaW5zdGFuY2VPZikpKSAmJlxuICAgICAgICAoIXR5cGUucHJlZGljYXRlICB8fCB0eXBlLnByZWRpY2F0ZShvYmplY3QpKSkge1xuXG4gICAgICBzdGF0ZS50YWcgPSBleHBsaWNpdCA/IHR5cGUudGFnIDogJz8nO1xuXG4gICAgICBpZiAodHlwZS5yZXByZXNlbnQpIHtcbiAgICAgICAgc3R5bGUgPSBzdGF0ZS5zdHlsZU1hcFt0eXBlLnRhZ10gfHwgdHlwZS5kZWZhdWx0U3R5bGU7XG5cbiAgICAgICAgaWYgKF90b1N0cmluZy5jYWxsKHR5cGUucmVwcmVzZW50KSA9PT0gJ1tvYmplY3QgRnVuY3Rpb25dJykge1xuICAgICAgICAgIF9yZXN1bHQgPSB0eXBlLnJlcHJlc2VudChvYmplY3QsIHN0eWxlKTtcbiAgICAgICAgfSBlbHNlIGlmIChfaGFzT3duUHJvcGVydHkuY2FsbCh0eXBlLnJlcHJlc2VudCwgc3R5bGUpKSB7XG4gICAgICAgICAgX3Jlc3VsdCA9IHR5cGUucmVwcmVzZW50W3N0eWxlXShvYmplY3QsIHN0eWxlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aHJvdyBuZXcgWUFNTEV4Y2VwdGlvbignITwnICsgdHlwZS50YWcgKyAnPiB0YWcgcmVzb2x2ZXIgYWNjZXB0cyBub3QgXCInICsgc3R5bGUgKyAnXCIgc3R5bGUnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHN0YXRlLmR1bXAgPSBfcmVzdWx0O1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5cbi8vIFNlcmlhbGl6ZXMgYG9iamVjdGAgYW5kIHdyaXRlcyBpdCB0byBnbG9iYWwgYHJlc3VsdGAuXG4vLyBSZXR1cm5zIHRydWUgb24gc3VjY2Vzcywgb3IgZmFsc2Ugb24gaW52YWxpZCBvYmplY3QuXG4vL1xuZnVuY3Rpb24gd3JpdGVOb2RlKHN0YXRlLCBsZXZlbCwgb2JqZWN0LCBibG9jaywgY29tcGFjdCwgaXNrZXkpIHtcbiAgc3RhdGUudGFnID0gbnVsbDtcbiAgc3RhdGUuZHVtcCA9IG9iamVjdDtcblxuICBpZiAoIWRldGVjdFR5cGUoc3RhdGUsIG9iamVjdCwgZmFsc2UpKSB7XG4gICAgZGV0ZWN0VHlwZShzdGF0ZSwgb2JqZWN0LCB0cnVlKTtcbiAgfVxuXG4gIHZhciB0eXBlID0gX3RvU3RyaW5nLmNhbGwoc3RhdGUuZHVtcCk7XG5cbiAgaWYgKGJsb2NrKSB7XG4gICAgYmxvY2sgPSAoc3RhdGUuZmxvd0xldmVsIDwgMCB8fCBzdGF0ZS5mbG93TGV2ZWwgPiBsZXZlbCk7XG4gIH1cblxuICB2YXIgb2JqZWN0T3JBcnJheSA9IHR5cGUgPT09ICdbb2JqZWN0IE9iamVjdF0nIHx8IHR5cGUgPT09ICdbb2JqZWN0IEFycmF5XScsXG4gICAgICBkdXBsaWNhdGVJbmRleCxcbiAgICAgIGR1cGxpY2F0ZTtcblxuICBpZiAob2JqZWN0T3JBcnJheSkge1xuICAgIGR1cGxpY2F0ZUluZGV4ID0gc3RhdGUuZHVwbGljYXRlcy5pbmRleE9mKG9iamVjdCk7XG4gICAgZHVwbGljYXRlID0gZHVwbGljYXRlSW5kZXggIT09IC0xO1xuICB9XG5cbiAgaWYgKChzdGF0ZS50YWcgIT09IG51bGwgJiYgc3RhdGUudGFnICE9PSAnPycpIHx8IGR1cGxpY2F0ZSB8fCAoc3RhdGUuaW5kZW50ICE9PSAyICYmIGxldmVsID4gMCkpIHtcbiAgICBjb21wYWN0ID0gZmFsc2U7XG4gIH1cblxuICBpZiAoZHVwbGljYXRlICYmIHN0YXRlLnVzZWREdXBsaWNhdGVzW2R1cGxpY2F0ZUluZGV4XSkge1xuICAgIHN0YXRlLmR1bXAgPSAnKnJlZl8nICsgZHVwbGljYXRlSW5kZXg7XG4gIH0gZWxzZSB7XG4gICAgaWYgKG9iamVjdE9yQXJyYXkgJiYgZHVwbGljYXRlICYmICFzdGF0ZS51c2VkRHVwbGljYXRlc1tkdXBsaWNhdGVJbmRleF0pIHtcbiAgICAgIHN0YXRlLnVzZWREdXBsaWNhdGVzW2R1cGxpY2F0ZUluZGV4XSA9IHRydWU7XG4gICAgfVxuICAgIGlmICh0eXBlID09PSAnW29iamVjdCBPYmplY3RdJykge1xuICAgICAgaWYgKGJsb2NrICYmIChPYmplY3Qua2V5cyhzdGF0ZS5kdW1wKS5sZW5ndGggIT09IDApKSB7XG4gICAgICAgIHdyaXRlQmxvY2tNYXBwaW5nKHN0YXRlLCBsZXZlbCwgc3RhdGUuZHVtcCwgY29tcGFjdCk7XG4gICAgICAgIGlmIChkdXBsaWNhdGUpIHtcbiAgICAgICAgICBzdGF0ZS5kdW1wID0gJyZyZWZfJyArIGR1cGxpY2F0ZUluZGV4ICsgc3RhdGUuZHVtcDtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgd3JpdGVGbG93TWFwcGluZyhzdGF0ZSwgbGV2ZWwsIHN0YXRlLmR1bXApO1xuICAgICAgICBpZiAoZHVwbGljYXRlKSB7XG4gICAgICAgICAgc3RhdGUuZHVtcCA9ICcmcmVmXycgKyBkdXBsaWNhdGVJbmRleCArICcgJyArIHN0YXRlLmR1bXA7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHR5cGUgPT09ICdbb2JqZWN0IEFycmF5XScpIHtcbiAgICAgIGlmIChibG9jayAmJiAoc3RhdGUuZHVtcC5sZW5ndGggIT09IDApKSB7XG4gICAgICAgIHdyaXRlQmxvY2tTZXF1ZW5jZShzdGF0ZSwgbGV2ZWwsIHN0YXRlLmR1bXAsIGNvbXBhY3QpO1xuICAgICAgICBpZiAoZHVwbGljYXRlKSB7XG4gICAgICAgICAgc3RhdGUuZHVtcCA9ICcmcmVmXycgKyBkdXBsaWNhdGVJbmRleCArIHN0YXRlLmR1bXA7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHdyaXRlRmxvd1NlcXVlbmNlKHN0YXRlLCBsZXZlbCwgc3RhdGUuZHVtcCk7XG4gICAgICAgIGlmIChkdXBsaWNhdGUpIHtcbiAgICAgICAgICBzdGF0ZS5kdW1wID0gJyZyZWZfJyArIGR1cGxpY2F0ZUluZGV4ICsgJyAnICsgc3RhdGUuZHVtcDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gJ1tvYmplY3QgU3RyaW5nXScpIHtcbiAgICAgIGlmIChzdGF0ZS50YWcgIT09ICc/Jykge1xuICAgICAgICB3cml0ZVNjYWxhcihzdGF0ZSwgc3RhdGUuZHVtcCwgbGV2ZWwsIGlza2V5KTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHN0YXRlLnNraXBJbnZhbGlkKSByZXR1cm4gZmFsc2U7XG4gICAgICB0aHJvdyBuZXcgWUFNTEV4Y2VwdGlvbigndW5hY2NlcHRhYmxlIGtpbmQgb2YgYW4gb2JqZWN0IHRvIGR1bXAgJyArIHR5cGUpO1xuICAgIH1cblxuICAgIGlmIChzdGF0ZS50YWcgIT09IG51bGwgJiYgc3RhdGUudGFnICE9PSAnPycpIHtcbiAgICAgIHN0YXRlLmR1bXAgPSAnITwnICsgc3RhdGUudGFnICsgJz4gJyArIHN0YXRlLmR1bXA7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59XG5cbmZ1bmN0aW9uIGdldER1cGxpY2F0ZVJlZmVyZW5jZXMob2JqZWN0LCBzdGF0ZSkge1xuICB2YXIgb2JqZWN0cyA9IFtdLFxuICAgICAgZHVwbGljYXRlc0luZGV4ZXMgPSBbXSxcbiAgICAgIGluZGV4LFxuICAgICAgbGVuZ3RoO1xuXG4gIGluc3BlY3ROb2RlKG9iamVjdCwgb2JqZWN0cywgZHVwbGljYXRlc0luZGV4ZXMpO1xuXG4gIGZvciAoaW5kZXggPSAwLCBsZW5ndGggPSBkdXBsaWNhdGVzSW5kZXhlcy5sZW5ndGg7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCArPSAxKSB7XG4gICAgc3RhdGUuZHVwbGljYXRlcy5wdXNoKG9iamVjdHNbZHVwbGljYXRlc0luZGV4ZXNbaW5kZXhdXSk7XG4gIH1cbiAgc3RhdGUudXNlZER1cGxpY2F0ZXMgPSBuZXcgQXJyYXkobGVuZ3RoKTtcbn1cblxuZnVuY3Rpb24gaW5zcGVjdE5vZGUob2JqZWN0LCBvYmplY3RzLCBkdXBsaWNhdGVzSW5kZXhlcykge1xuICB2YXIgb2JqZWN0S2V5TGlzdCxcbiAgICAgIGluZGV4LFxuICAgICAgbGVuZ3RoO1xuXG4gIGlmIChvYmplY3QgIT09IG51bGwgJiYgdHlwZW9mIG9iamVjdCA9PT0gJ29iamVjdCcpIHtcbiAgICBpbmRleCA9IG9iamVjdHMuaW5kZXhPZihvYmplY3QpO1xuICAgIGlmIChpbmRleCAhPT0gLTEpIHtcbiAgICAgIGlmIChkdXBsaWNhdGVzSW5kZXhlcy5pbmRleE9mKGluZGV4KSA9PT0gLTEpIHtcbiAgICAgICAgZHVwbGljYXRlc0luZGV4ZXMucHVzaChpbmRleCk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIG9iamVjdHMucHVzaChvYmplY3QpO1xuXG4gICAgICBpZiAoQXJyYXkuaXNBcnJheShvYmplY3QpKSB7XG4gICAgICAgIGZvciAoaW5kZXggPSAwLCBsZW5ndGggPSBvYmplY3QubGVuZ3RoOyBpbmRleCA8IGxlbmd0aDsgaW5kZXggKz0gMSkge1xuICAgICAgICAgIGluc3BlY3ROb2RlKG9iamVjdFtpbmRleF0sIG9iamVjdHMsIGR1cGxpY2F0ZXNJbmRleGVzKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgb2JqZWN0S2V5TGlzdCA9IE9iamVjdC5rZXlzKG9iamVjdCk7XG5cbiAgICAgICAgZm9yIChpbmRleCA9IDAsIGxlbmd0aCA9IG9iamVjdEtleUxpc3QubGVuZ3RoOyBpbmRleCA8IGxlbmd0aDsgaW5kZXggKz0gMSkge1xuICAgICAgICAgIGluc3BlY3ROb2RlKG9iamVjdFtvYmplY3RLZXlMaXN0W2luZGV4XV0sIG9iamVjdHMsIGR1cGxpY2F0ZXNJbmRleGVzKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBkdW1wKGlucHV0LCBvcHRpb25zKSB7XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gIHZhciBzdGF0ZSA9IG5ldyBTdGF0ZShvcHRpb25zKTtcblxuICBpZiAoIXN0YXRlLm5vUmVmcykgZ2V0RHVwbGljYXRlUmVmZXJlbmNlcyhpbnB1dCwgc3RhdGUpO1xuXG4gIGlmICh3cml0ZU5vZGUoc3RhdGUsIDAsIGlucHV0LCB0cnVlLCB0cnVlKSkgcmV0dXJuIHN0YXRlLmR1bXAgKyAnXFxuJztcblxuICByZXR1cm4gJyc7XG59XG5cbmZ1bmN0aW9uIHNhZmVEdW1wKGlucHV0LCBvcHRpb25zKSB7XG4gIHJldHVybiBkdW1wKGlucHV0LCBjb21tb24uZXh0ZW5kKHsgc2NoZW1hOiBERUZBVUxUX1NBRkVfU0NIRU1BIH0sIG9wdGlvbnMpKTtcbn1cblxubW9kdWxlLmV4cG9ydHMuZHVtcCAgICAgPSBkdW1wO1xubW9kdWxlLmV4cG9ydHMuc2FmZUR1bXAgPSBzYWZlRHVtcDtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9qcy15YW1sL2xpYi9qcy15YW1sL2R1bXBlci5qcyIsIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICB2YWx1ZTogdHJ1ZVxufSk7XG5jbGFzcyBMYXp5IHtcbiAgICBjb25zdHJ1Y3RvcihjcmVhdG9yKSB7XG4gICAgICAgIHRoaXMuY3JlYXRvciA9IGNyZWF0b3I7XG4gICAgfVxuICAgIGdldCBoYXNWYWx1ZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY3JlYXRvciA9PSBudWxsO1xuICAgIH1cbiAgICBnZXQgdmFsdWUoKSB7XG4gICAgICAgIGlmICh0aGlzLmNyZWF0b3IgPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3ZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudmFsdWUgPSB0aGlzLmNyZWF0b3IoKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3ZhbHVlO1xuICAgIH1cbiAgICBzZXQgdmFsdWUodmFsdWUpIHtcbiAgICAgICAgdGhpcy5fdmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgdGhpcy5jcmVhdG9yID0gbnVsbDtcbiAgICB9XG59XG5leHBvcnRzLkxhenkgPSBMYXp5OyAvLyMgc291cmNlTWFwcGluZ1VSTD1tYWluLmpzLm1hcFxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9lbGVjdHJvbi11cGRhdGVyL25vZGVfbW9kdWxlcy9sYXp5LXZhbC9vdXQvbWFpbi5qcyIsInZhciBTb3VyY2VNYXBDb25zdW1lciA9IHJlcXVpcmUoJ3NvdXJjZS1tYXAnKS5Tb3VyY2VNYXBDb25zdW1lcjtcbnZhciBwYXRoID0gcmVxdWlyZSgncGF0aCcpO1xuXG52YXIgZnM7XG50cnkge1xuICBmcyA9IHJlcXVpcmUoJ2ZzJyk7XG4gIGlmICghZnMuZXhpc3RzU3luYyB8fCAhZnMucmVhZEZpbGVTeW5jKSB7XG4gICAgLy8gZnMgZG9lc24ndCBoYXZlIGFsbCBtZXRob2RzIHdlIG5lZWRcbiAgICBmcyA9IG51bGw7XG4gIH1cbn0gY2F0Y2ggKGVycikge1xuICAvKiBub3AgKi9cbn1cblxuLy8gT25seSBpbnN0YWxsIG9uY2UgaWYgY2FsbGVkIG11bHRpcGxlIHRpbWVzXG52YXIgZXJyb3JGb3JtYXR0ZXJJbnN0YWxsZWQgPSBmYWxzZTtcbnZhciB1bmNhdWdodFNoaW1JbnN0YWxsZWQgPSBmYWxzZTtcblxuLy8gSWYgdHJ1ZSwgdGhlIGNhY2hlcyBhcmUgcmVzZXQgYmVmb3JlIGEgc3RhY2sgdHJhY2UgZm9ybWF0dGluZyBvcGVyYXRpb25cbnZhciBlbXB0eUNhY2hlQmV0d2Vlbk9wZXJhdGlvbnMgPSBmYWxzZTtcblxuLy8gU3VwcG9ydHMge2Jyb3dzZXIsIG5vZGUsIGF1dG99XG52YXIgZW52aXJvbm1lbnQgPSBcImF1dG9cIjtcblxuLy8gTWFwcyBhIGZpbGUgcGF0aCB0byBhIHN0cmluZyBjb250YWluaW5nIHRoZSBmaWxlIGNvbnRlbnRzXG52YXIgZmlsZUNvbnRlbnRzQ2FjaGUgPSB7fTtcblxuLy8gTWFwcyBhIGZpbGUgcGF0aCB0byBhIHNvdXJjZSBtYXAgZm9yIHRoYXQgZmlsZVxudmFyIHNvdXJjZU1hcENhY2hlID0ge307XG5cbi8vIFJlZ2V4IGZvciBkZXRlY3Rpbmcgc291cmNlIG1hcHNcbnZhciByZVNvdXJjZU1hcCA9IC9eZGF0YTphcHBsaWNhdGlvblxcL2pzb25bXixdK2Jhc2U2NCwvO1xuXG4vLyBQcmlvcml0eSBsaXN0IG9mIHJldHJpZXZlIGhhbmRsZXJzXG52YXIgcmV0cmlldmVGaWxlSGFuZGxlcnMgPSBbXTtcbnZhciByZXRyaWV2ZU1hcEhhbmRsZXJzID0gW107XG5cbmZ1bmN0aW9uIGlzSW5Ccm93c2VyKCkge1xuICBpZiAoZW52aXJvbm1lbnQgPT09IFwiYnJvd3NlclwiKVxuICAgIHJldHVybiB0cnVlO1xuICBpZiAoZW52aXJvbm1lbnQgPT09IFwibm9kZVwiKVxuICAgIHJldHVybiBmYWxzZTtcbiAgcmV0dXJuICgodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcpICYmICh0eXBlb2YgWE1MSHR0cFJlcXVlc3QgPT09ICdmdW5jdGlvbicpICYmICEod2luZG93LnJlcXVpcmUgJiYgd2luZG93Lm1vZHVsZSAmJiB3aW5kb3cucHJvY2VzcyAmJiB3aW5kb3cucHJvY2Vzcy50eXBlID09PSBcInJlbmRlcmVyXCIpKTtcbn1cblxuZnVuY3Rpb24gaGFzR2xvYmFsUHJvY2Vzc0V2ZW50RW1pdHRlcigpIHtcbiAgcmV0dXJuICgodHlwZW9mIHByb2Nlc3MgPT09ICdvYmplY3QnKSAmJiAocHJvY2VzcyAhPT0gbnVsbCkgJiYgKHR5cGVvZiBwcm9jZXNzLm9uID09PSAnZnVuY3Rpb24nKSk7XG59XG5cbmZ1bmN0aW9uIGhhbmRsZXJFeGVjKGxpc3QpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKGFyZykge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHJldCA9IGxpc3RbaV0oYXJnKTtcbiAgICAgIGlmIChyZXQpIHtcbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH07XG59XG5cbnZhciByZXRyaWV2ZUZpbGUgPSBoYW5kbGVyRXhlYyhyZXRyaWV2ZUZpbGVIYW5kbGVycyk7XG5cbnJldHJpZXZlRmlsZUhhbmRsZXJzLnB1c2goZnVuY3Rpb24ocGF0aCkge1xuICAvLyBUcmltIHRoZSBwYXRoIHRvIG1ha2Ugc3VyZSB0aGVyZSBpcyBubyBleHRyYSB3aGl0ZXNwYWNlLlxuICBwYXRoID0gcGF0aC50cmltKCk7XG4gIGlmIChwYXRoIGluIGZpbGVDb250ZW50c0NhY2hlKSB7XG4gICAgcmV0dXJuIGZpbGVDb250ZW50c0NhY2hlW3BhdGhdO1xuICB9XG5cbiAgdmFyIGNvbnRlbnRzID0gbnVsbDtcbiAgaWYgKCFmcykge1xuICAgIC8vIFVzZSBTSkFYIGlmIHdlIGFyZSBpbiB0aGUgYnJvd3NlclxuICAgIHZhciB4aHIgPSBuZXcgWE1MSHR0cFJlcXVlc3QoKTtcbiAgICB4aHIub3BlbignR0VUJywgcGF0aCwgZmFsc2UpO1xuICAgIHhoci5zZW5kKG51bGwpO1xuICAgIHZhciBjb250ZW50cyA9IG51bGxcbiAgICBpZiAoeGhyLnJlYWR5U3RhdGUgPT09IDQgJiYgeGhyLnN0YXR1cyA9PT0gMjAwKSB7XG4gICAgICBjb250ZW50cyA9IHhoci5yZXNwb25zZVRleHRcbiAgICB9XG4gIH0gZWxzZSBpZiAoZnMuZXhpc3RzU3luYyhwYXRoKSkge1xuICAgIC8vIE90aGVyd2lzZSwgdXNlIHRoZSBmaWxlc3lzdGVtXG4gICAgdHJ5IHtcbiAgICAgIGNvbnRlbnRzID0gZnMucmVhZEZpbGVTeW5jKHBhdGgsICd1dGY4Jyk7XG4gICAgfSBjYXRjaCAoZXIpIHtcbiAgICAgIGNvbnRlbnRzID0gJyc7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZpbGVDb250ZW50c0NhY2hlW3BhdGhdID0gY29udGVudHM7XG59KTtcblxuLy8gU3VwcG9ydCBVUkxzIHJlbGF0aXZlIHRvIGEgZGlyZWN0b3J5LCBidXQgYmUgY2FyZWZ1bCBhYm91dCBhIHByb3RvY29sIHByZWZpeFxuLy8gaW4gY2FzZSB3ZSBhcmUgaW4gdGhlIGJyb3dzZXIgKGkuZS4gZGlyZWN0b3JpZXMgbWF5IHN0YXJ0IHdpdGggXCJodHRwOi8vXCIpXG5mdW5jdGlvbiBzdXBwb3J0UmVsYXRpdmVVUkwoZmlsZSwgdXJsKSB7XG4gIGlmICghZmlsZSkgcmV0dXJuIHVybDtcbiAgdmFyIGRpciA9IHBhdGguZGlybmFtZShmaWxlKTtcbiAgdmFyIG1hdGNoID0gL15cXHcrOlxcL1xcL1teXFwvXSovLmV4ZWMoZGlyKTtcbiAgdmFyIHByb3RvY29sID0gbWF0Y2ggPyBtYXRjaFswXSA6ICcnO1xuICByZXR1cm4gcHJvdG9jb2wgKyBwYXRoLnJlc29sdmUoZGlyLnNsaWNlKHByb3RvY29sLmxlbmd0aCksIHVybCk7XG59XG5cbmZ1bmN0aW9uIHJldHJpZXZlU291cmNlTWFwVVJMKHNvdXJjZSkge1xuICB2YXIgZmlsZURhdGE7XG5cbiAgaWYgKGlzSW5Ccm93c2VyKCkpIHtcbiAgICAgdHJ5IHtcbiAgICAgICB2YXIgeGhyID0gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7XG4gICAgICAgeGhyLm9wZW4oJ0dFVCcsIHNvdXJjZSwgZmFsc2UpO1xuICAgICAgIHhoci5zZW5kKG51bGwpO1xuICAgICAgIGZpbGVEYXRhID0geGhyLnJlYWR5U3RhdGUgPT09IDQgPyB4aHIucmVzcG9uc2VUZXh0IDogbnVsbDtcblxuICAgICAgIC8vIFN1cHBvcnQgcHJvdmlkaW5nIGEgc291cmNlTWFwcGluZ1VSTCB2aWEgdGhlIFNvdXJjZU1hcCBoZWFkZXJcbiAgICAgICB2YXIgc291cmNlTWFwSGVhZGVyID0geGhyLmdldFJlc3BvbnNlSGVhZGVyKFwiU291cmNlTWFwXCIpIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIHhoci5nZXRSZXNwb25zZUhlYWRlcihcIlgtU291cmNlTWFwXCIpO1xuICAgICAgIGlmIChzb3VyY2VNYXBIZWFkZXIpIHtcbiAgICAgICAgIHJldHVybiBzb3VyY2VNYXBIZWFkZXI7XG4gICAgICAgfVxuICAgICB9IGNhdGNoIChlKSB7XG4gICAgIH1cbiAgfVxuXG4gIC8vIEdldCB0aGUgVVJMIG9mIHRoZSBzb3VyY2UgbWFwXG4gIGZpbGVEYXRhID0gcmV0cmlldmVGaWxlKHNvdXJjZSk7XG4gIHZhciByZSA9IC8oPzpcXC9cXC9bQCNdWyBcXHRdK3NvdXJjZU1hcHBpbmdVUkw9KFteXFxzJ1wiXSs/KVsgXFx0XSokKXwoPzpcXC9cXCpbQCNdWyBcXHRdK3NvdXJjZU1hcHBpbmdVUkw9KFteXFwqXSs/KVsgXFx0XSooPzpcXCpcXC8pWyBcXHRdKiQpL21nO1xuICAvLyBLZWVwIGV4ZWN1dGluZyB0aGUgc2VhcmNoIHRvIGZpbmQgdGhlICpsYXN0KiBzb3VyY2VNYXBwaW5nVVJMIHRvIGF2b2lkXG4gIC8vIHBpY2tpbmcgdXAgc291cmNlTWFwcGluZ1VSTHMgZnJvbSBjb21tZW50cywgc3RyaW5ncywgZXRjLlxuICB2YXIgbGFzdE1hdGNoLCBtYXRjaDtcbiAgd2hpbGUgKG1hdGNoID0gcmUuZXhlYyhmaWxlRGF0YSkpIGxhc3RNYXRjaCA9IG1hdGNoO1xuICBpZiAoIWxhc3RNYXRjaCkgcmV0dXJuIG51bGw7XG4gIHJldHVybiBsYXN0TWF0Y2hbMV07XG59O1xuXG4vLyBDYW4gYmUgb3ZlcnJpZGRlbiBieSB0aGUgcmV0cmlldmVTb3VyY2VNYXAgb3B0aW9uIHRvIGluc3RhbGwuIFRha2VzIGFcbi8vIGdlbmVyYXRlZCBzb3VyY2UgZmlsZW5hbWU7IHJldHVybnMgYSB7bWFwLCBvcHRpb25hbCB1cmx9IG9iamVjdCwgb3IgbnVsbCBpZlxuLy8gdGhlcmUgaXMgbm8gc291cmNlIG1hcC4gIFRoZSBtYXAgZmllbGQgbWF5IGJlIGVpdGhlciBhIHN0cmluZyBvciB0aGUgcGFyc2VkXG4vLyBKU09OIG9iamVjdCAoaWUsIGl0IG11c3QgYmUgYSB2YWxpZCBhcmd1bWVudCB0byB0aGUgU291cmNlTWFwQ29uc3VtZXJcbi8vIGNvbnN0cnVjdG9yKS5cbnZhciByZXRyaWV2ZVNvdXJjZU1hcCA9IGhhbmRsZXJFeGVjKHJldHJpZXZlTWFwSGFuZGxlcnMpO1xucmV0cmlldmVNYXBIYW5kbGVycy5wdXNoKGZ1bmN0aW9uKHNvdXJjZSkge1xuICB2YXIgc291cmNlTWFwcGluZ1VSTCA9IHJldHJpZXZlU291cmNlTWFwVVJMKHNvdXJjZSk7XG4gIGlmICghc291cmNlTWFwcGluZ1VSTCkgcmV0dXJuIG51bGw7XG5cbiAgLy8gUmVhZCB0aGUgY29udGVudHMgb2YgdGhlIHNvdXJjZSBtYXBcbiAgdmFyIHNvdXJjZU1hcERhdGE7XG4gIGlmIChyZVNvdXJjZU1hcC50ZXN0KHNvdXJjZU1hcHBpbmdVUkwpKSB7XG4gICAgLy8gU3VwcG9ydCBzb3VyY2UgbWFwIFVSTCBhcyBhIGRhdGEgdXJsXG4gICAgdmFyIHJhd0RhdGEgPSBzb3VyY2VNYXBwaW5nVVJMLnNsaWNlKHNvdXJjZU1hcHBpbmdVUkwuaW5kZXhPZignLCcpICsgMSk7XG4gICAgc291cmNlTWFwRGF0YSA9IG5ldyBCdWZmZXIocmF3RGF0YSwgXCJiYXNlNjRcIikudG9TdHJpbmcoKTtcbiAgICBzb3VyY2VNYXBwaW5nVVJMID0gc291cmNlO1xuICB9IGVsc2Uge1xuICAgIC8vIFN1cHBvcnQgc291cmNlIG1hcCBVUkxzIHJlbGF0aXZlIHRvIHRoZSBzb3VyY2UgVVJMXG4gICAgc291cmNlTWFwcGluZ1VSTCA9IHN1cHBvcnRSZWxhdGl2ZVVSTChzb3VyY2UsIHNvdXJjZU1hcHBpbmdVUkwpO1xuICAgIHNvdXJjZU1hcERhdGEgPSByZXRyaWV2ZUZpbGUoc291cmNlTWFwcGluZ1VSTCk7XG4gIH1cblxuICBpZiAoIXNvdXJjZU1hcERhdGEpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgdXJsOiBzb3VyY2VNYXBwaW5nVVJMLFxuICAgIG1hcDogc291cmNlTWFwRGF0YVxuICB9O1xufSk7XG5cbmZ1bmN0aW9uIG1hcFNvdXJjZVBvc2l0aW9uKHBvc2l0aW9uKSB7XG4gIHZhciBzb3VyY2VNYXAgPSBzb3VyY2VNYXBDYWNoZVtwb3NpdGlvbi5zb3VyY2VdO1xuICBpZiAoIXNvdXJjZU1hcCkge1xuICAgIC8vIENhbGwgdGhlIChvdmVycmlkZWFibGUpIHJldHJpZXZlU291cmNlTWFwIGZ1bmN0aW9uIHRvIGdldCB0aGUgc291cmNlIG1hcC5cbiAgICB2YXIgdXJsQW5kTWFwID0gcmV0cmlldmVTb3VyY2VNYXAocG9zaXRpb24uc291cmNlKTtcbiAgICBpZiAodXJsQW5kTWFwKSB7XG4gICAgICBzb3VyY2VNYXAgPSBzb3VyY2VNYXBDYWNoZVtwb3NpdGlvbi5zb3VyY2VdID0ge1xuICAgICAgICB1cmw6IHVybEFuZE1hcC51cmwsXG4gICAgICAgIG1hcDogbmV3IFNvdXJjZU1hcENvbnN1bWVyKHVybEFuZE1hcC5tYXApXG4gICAgICB9O1xuXG4gICAgICAvLyBMb2FkIGFsbCBzb3VyY2VzIHN0b3JlZCBpbmxpbmUgd2l0aCB0aGUgc291cmNlIG1hcCBpbnRvIHRoZSBmaWxlIGNhY2hlXG4gICAgICAvLyB0byBwcmV0ZW5kIGxpa2UgdGhleSBhcmUgYWxyZWFkeSBsb2FkZWQuIFRoZXkgbWF5IG5vdCBleGlzdCBvbiBkaXNrLlxuICAgICAgaWYgKHNvdXJjZU1hcC5tYXAuc291cmNlc0NvbnRlbnQpIHtcbiAgICAgICAgc291cmNlTWFwLm1hcC5zb3VyY2VzLmZvckVhY2goZnVuY3Rpb24oc291cmNlLCBpKSB7XG4gICAgICAgICAgdmFyIGNvbnRlbnRzID0gc291cmNlTWFwLm1hcC5zb3VyY2VzQ29udGVudFtpXTtcbiAgICAgICAgICBpZiAoY29udGVudHMpIHtcbiAgICAgICAgICAgIHZhciB1cmwgPSBzdXBwb3J0UmVsYXRpdmVVUkwoc291cmNlTWFwLnVybCwgc291cmNlKTtcbiAgICAgICAgICAgIGZpbGVDb250ZW50c0NhY2hlW3VybF0gPSBjb250ZW50cztcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBzb3VyY2VNYXAgPSBzb3VyY2VNYXBDYWNoZVtwb3NpdGlvbi5zb3VyY2VdID0ge1xuICAgICAgICB1cmw6IG51bGwsXG4gICAgICAgIG1hcDogbnVsbFxuICAgICAgfTtcbiAgICB9XG4gIH1cblxuICAvLyBSZXNvbHZlIHRoZSBzb3VyY2UgVVJMIHJlbGF0aXZlIHRvIHRoZSBVUkwgb2YgdGhlIHNvdXJjZSBtYXBcbiAgaWYgKHNvdXJjZU1hcCAmJiBzb3VyY2VNYXAubWFwKSB7XG4gICAgdmFyIG9yaWdpbmFsUG9zaXRpb24gPSBzb3VyY2VNYXAubWFwLm9yaWdpbmFsUG9zaXRpb25Gb3IocG9zaXRpb24pO1xuXG4gICAgLy8gT25seSByZXR1cm4gdGhlIG9yaWdpbmFsIHBvc2l0aW9uIGlmIGEgbWF0Y2hpbmcgbGluZSB3YXMgZm91bmQuIElmIG5vXG4gICAgLy8gbWF0Y2hpbmcgbGluZSBpcyBmb3VuZCB0aGVuIHdlIHJldHVybiBwb3NpdGlvbiBpbnN0ZWFkLCB3aGljaCB3aWxsIGNhdXNlXG4gICAgLy8gdGhlIHN0YWNrIHRyYWNlIHRvIHByaW50IHRoZSBwYXRoIGFuZCBsaW5lIGZvciB0aGUgY29tcGlsZWQgZmlsZS4gSXQgaXNcbiAgICAvLyBiZXR0ZXIgdG8gZ2l2ZSBhIHByZWNpc2UgbG9jYXRpb24gaW4gdGhlIGNvbXBpbGVkIGZpbGUgdGhhbiBhIHZhZ3VlXG4gICAgLy8gbG9jYXRpb24gaW4gdGhlIG9yaWdpbmFsIGZpbGUuXG4gICAgaWYgKG9yaWdpbmFsUG9zaXRpb24uc291cmNlICE9PSBudWxsKSB7XG4gICAgICBvcmlnaW5hbFBvc2l0aW9uLnNvdXJjZSA9IHN1cHBvcnRSZWxhdGl2ZVVSTChcbiAgICAgICAgc291cmNlTWFwLnVybCwgb3JpZ2luYWxQb3NpdGlvbi5zb3VyY2UpO1xuICAgICAgcmV0dXJuIG9yaWdpbmFsUG9zaXRpb247XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHBvc2l0aW9uO1xufVxuXG4vLyBQYXJzZXMgY29kZSBnZW5lcmF0ZWQgYnkgRm9ybWF0RXZhbE9yaWdpbigpLCBhIGZ1bmN0aW9uIGluc2lkZSBWODpcbi8vIGh0dHBzOi8vY29kZS5nb29nbGUuY29tL3Avdjgvc291cmNlL2Jyb3dzZS90cnVuay9zcmMvbWVzc2FnZXMuanNcbmZ1bmN0aW9uIG1hcEV2YWxPcmlnaW4ob3JpZ2luKSB7XG4gIC8vIE1vc3QgZXZhbCgpIGNhbGxzIGFyZSBpbiB0aGlzIGZvcm1hdFxuICB2YXIgbWF0Y2ggPSAvXmV2YWwgYXQgKFteKF0rKSBcXCgoLispOihcXGQrKTooXFxkKylcXCkkLy5leGVjKG9yaWdpbik7XG4gIGlmIChtYXRjaCkge1xuICAgIHZhciBwb3NpdGlvbiA9IG1hcFNvdXJjZVBvc2l0aW9uKHtcbiAgICAgIHNvdXJjZTogbWF0Y2hbMl0sXG4gICAgICBsaW5lOiArbWF0Y2hbM10sXG4gICAgICBjb2x1bW46IG1hdGNoWzRdIC0gMVxuICAgIH0pO1xuICAgIHJldHVybiAnZXZhbCBhdCAnICsgbWF0Y2hbMV0gKyAnICgnICsgcG9zaXRpb24uc291cmNlICsgJzonICtcbiAgICAgIHBvc2l0aW9uLmxpbmUgKyAnOicgKyAocG9zaXRpb24uY29sdW1uICsgMSkgKyAnKSc7XG4gIH1cblxuICAvLyBQYXJzZSBuZXN0ZWQgZXZhbCgpIGNhbGxzIHVzaW5nIHJlY3Vyc2lvblxuICBtYXRjaCA9IC9eZXZhbCBhdCAoW14oXSspIFxcKCguKylcXCkkLy5leGVjKG9yaWdpbik7XG4gIGlmIChtYXRjaCkge1xuICAgIHJldHVybiAnZXZhbCBhdCAnICsgbWF0Y2hbMV0gKyAnICgnICsgbWFwRXZhbE9yaWdpbihtYXRjaFsyXSkgKyAnKSc7XG4gIH1cblxuICAvLyBNYWtlIHN1cmUgd2Ugc3RpbGwgcmV0dXJuIHVzZWZ1bCBpbmZvcm1hdGlvbiBpZiB3ZSBkaWRuJ3QgZmluZCBhbnl0aGluZ1xuICByZXR1cm4gb3JpZ2luO1xufVxuXG4vLyBUaGlzIGlzIGNvcGllZCBhbG1vc3QgdmVyYmF0aW0gZnJvbSB0aGUgVjggc291cmNlIGNvZGUgYXRcbi8vIGh0dHBzOi8vY29kZS5nb29nbGUuY29tL3Avdjgvc291cmNlL2Jyb3dzZS90cnVuay9zcmMvbWVzc2FnZXMuanMuIFRoZVxuLy8gaW1wbGVtZW50YXRpb24gb2Ygd3JhcENhbGxTaXRlKCkgdXNlZCB0byBqdXN0IGZvcndhcmQgdG8gdGhlIGFjdHVhbCBzb3VyY2Vcbi8vIGNvZGUgb2YgQ2FsbFNpdGUucHJvdG90eXBlLnRvU3RyaW5nIGJ1dCB1bmZvcnR1bmF0ZWx5IGEgbmV3IHJlbGVhc2Ugb2YgVjhcbi8vIGRpZCBzb21ldGhpbmcgdG8gdGhlIHByb3RvdHlwZSBjaGFpbiBhbmQgYnJva2UgdGhlIHNoaW0uIFRoZSBvbmx5IGZpeCBJXG4vLyBjb3VsZCBmaW5kIHdhcyBjb3B5L3Bhc3RlLlxuZnVuY3Rpb24gQ2FsbFNpdGVUb1N0cmluZygpIHtcbiAgdmFyIGZpbGVOYW1lO1xuICB2YXIgZmlsZUxvY2F0aW9uID0gXCJcIjtcbiAgaWYgKHRoaXMuaXNOYXRpdmUoKSkge1xuICAgIGZpbGVMb2NhdGlvbiA9IFwibmF0aXZlXCI7XG4gIH0gZWxzZSB7XG4gICAgZmlsZU5hbWUgPSB0aGlzLmdldFNjcmlwdE5hbWVPclNvdXJjZVVSTCgpO1xuICAgIGlmICghZmlsZU5hbWUgJiYgdGhpcy5pc0V2YWwoKSkge1xuICAgICAgZmlsZUxvY2F0aW9uID0gdGhpcy5nZXRFdmFsT3JpZ2luKCk7XG4gICAgICBmaWxlTG9jYXRpb24gKz0gXCIsIFwiOyAgLy8gRXhwZWN0aW5nIHNvdXJjZSBwb3NpdGlvbiB0byBmb2xsb3cuXG4gICAgfVxuXG4gICAgaWYgKGZpbGVOYW1lKSB7XG4gICAgICBmaWxlTG9jYXRpb24gKz0gZmlsZU5hbWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFNvdXJjZSBjb2RlIGRvZXMgbm90IG9yaWdpbmF0ZSBmcm9tIGEgZmlsZSBhbmQgaXMgbm90IG5hdGl2ZSwgYnV0IHdlXG4gICAgICAvLyBjYW4gc3RpbGwgZ2V0IHRoZSBzb3VyY2UgcG9zaXRpb24gaW5zaWRlIHRoZSBzb3VyY2Ugc3RyaW5nLCBlLmcuIGluXG4gICAgICAvLyBhbiBldmFsIHN0cmluZy5cbiAgICAgIGZpbGVMb2NhdGlvbiArPSBcIjxhbm9ueW1vdXM+XCI7XG4gICAgfVxuICAgIHZhciBsaW5lTnVtYmVyID0gdGhpcy5nZXRMaW5lTnVtYmVyKCk7XG4gICAgaWYgKGxpbmVOdW1iZXIgIT0gbnVsbCkge1xuICAgICAgZmlsZUxvY2F0aW9uICs9IFwiOlwiICsgbGluZU51bWJlcjtcbiAgICAgIHZhciBjb2x1bW5OdW1iZXIgPSB0aGlzLmdldENvbHVtbk51bWJlcigpO1xuICAgICAgaWYgKGNvbHVtbk51bWJlcikge1xuICAgICAgICBmaWxlTG9jYXRpb24gKz0gXCI6XCIgKyBjb2x1bW5OdW1iZXI7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgdmFyIGxpbmUgPSBcIlwiO1xuICB2YXIgZnVuY3Rpb25OYW1lID0gdGhpcy5nZXRGdW5jdGlvbk5hbWUoKTtcbiAgdmFyIGFkZFN1ZmZpeCA9IHRydWU7XG4gIHZhciBpc0NvbnN0cnVjdG9yID0gdGhpcy5pc0NvbnN0cnVjdG9yKCk7XG4gIHZhciBpc01ldGhvZENhbGwgPSAhKHRoaXMuaXNUb3BsZXZlbCgpIHx8IGlzQ29uc3RydWN0b3IpO1xuICBpZiAoaXNNZXRob2RDYWxsKSB7XG4gICAgdmFyIHR5cGVOYW1lID0gdGhpcy5nZXRUeXBlTmFtZSgpO1xuICAgIC8vIEZpeGVzIHNoaW0gdG8gYmUgYmFja3dhcmQgY29tcGF0YWJsZSB3aXRoIE5vZGUgdjAgdG8gdjRcbiAgICBpZiAodHlwZU5hbWUgPT09IFwiW29iamVjdCBPYmplY3RdXCIpIHtcbiAgICAgIHR5cGVOYW1lID0gXCJudWxsXCI7XG4gICAgfVxuICAgIHZhciBtZXRob2ROYW1lID0gdGhpcy5nZXRNZXRob2ROYW1lKCk7XG4gICAgaWYgKGZ1bmN0aW9uTmFtZSkge1xuICAgICAgaWYgKHR5cGVOYW1lICYmIGZ1bmN0aW9uTmFtZS5pbmRleE9mKHR5cGVOYW1lKSAhPSAwKSB7XG4gICAgICAgIGxpbmUgKz0gdHlwZU5hbWUgKyBcIi5cIjtcbiAgICAgIH1cbiAgICAgIGxpbmUgKz0gZnVuY3Rpb25OYW1lO1xuICAgICAgaWYgKG1ldGhvZE5hbWUgJiYgZnVuY3Rpb25OYW1lLmluZGV4T2YoXCIuXCIgKyBtZXRob2ROYW1lKSAhPSBmdW5jdGlvbk5hbWUubGVuZ3RoIC0gbWV0aG9kTmFtZS5sZW5ndGggLSAxKSB7XG4gICAgICAgIGxpbmUgKz0gXCIgW2FzIFwiICsgbWV0aG9kTmFtZSArIFwiXVwiO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBsaW5lICs9IHR5cGVOYW1lICsgXCIuXCIgKyAobWV0aG9kTmFtZSB8fCBcIjxhbm9ueW1vdXM+XCIpO1xuICAgIH1cbiAgfSBlbHNlIGlmIChpc0NvbnN0cnVjdG9yKSB7XG4gICAgbGluZSArPSBcIm5ldyBcIiArIChmdW5jdGlvbk5hbWUgfHwgXCI8YW5vbnltb3VzPlwiKTtcbiAgfSBlbHNlIGlmIChmdW5jdGlvbk5hbWUpIHtcbiAgICBsaW5lICs9IGZ1bmN0aW9uTmFtZTtcbiAgfSBlbHNlIHtcbiAgICBsaW5lICs9IGZpbGVMb2NhdGlvbjtcbiAgICBhZGRTdWZmaXggPSBmYWxzZTtcbiAgfVxuICBpZiAoYWRkU3VmZml4KSB7XG4gICAgbGluZSArPSBcIiAoXCIgKyBmaWxlTG9jYXRpb24gKyBcIilcIjtcbiAgfVxuICByZXR1cm4gbGluZTtcbn1cblxuZnVuY3Rpb24gY2xvbmVDYWxsU2l0ZShmcmFtZSkge1xuICB2YXIgb2JqZWN0ID0ge307XG4gIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKE9iamVjdC5nZXRQcm90b3R5cGVPZihmcmFtZSkpLmZvckVhY2goZnVuY3Rpb24obmFtZSkge1xuICAgIG9iamVjdFtuYW1lXSA9IC9eKD86aXN8Z2V0KS8udGVzdChuYW1lKSA/IGZ1bmN0aW9uKCkgeyByZXR1cm4gZnJhbWVbbmFtZV0uY2FsbChmcmFtZSk7IH0gOiBmcmFtZVtuYW1lXTtcbiAgfSk7XG4gIG9iamVjdC50b1N0cmluZyA9IENhbGxTaXRlVG9TdHJpbmc7XG4gIHJldHVybiBvYmplY3Q7XG59XG5cbmZ1bmN0aW9uIHdyYXBDYWxsU2l0ZShmcmFtZSkge1xuICBpZihmcmFtZS5pc05hdGl2ZSgpKSB7XG4gICAgcmV0dXJuIGZyYW1lO1xuICB9XG5cbiAgLy8gTW9zdCBjYWxsIHNpdGVzIHdpbGwgcmV0dXJuIHRoZSBzb3VyY2UgZmlsZSBmcm9tIGdldEZpbGVOYW1lKCksIGJ1dCBjb2RlXG4gIC8vIHBhc3NlZCB0byBldmFsKCkgZW5kaW5nIGluIFwiLy8jIHNvdXJjZVVSTD0uLi5cIiB3aWxsIHJldHVybiB0aGUgc291cmNlIGZpbGVcbiAgLy8gZnJvbSBnZXRTY3JpcHROYW1lT3JTb3VyY2VVUkwoKSBpbnN0ZWFkXG4gIHZhciBzb3VyY2UgPSBmcmFtZS5nZXRGaWxlTmFtZSgpIHx8IGZyYW1lLmdldFNjcmlwdE5hbWVPclNvdXJjZVVSTCgpO1xuICBpZiAoc291cmNlKSB7XG4gICAgdmFyIGxpbmUgPSBmcmFtZS5nZXRMaW5lTnVtYmVyKCk7XG4gICAgdmFyIGNvbHVtbiA9IGZyYW1lLmdldENvbHVtbk51bWJlcigpIC0gMTtcblxuICAgIC8vIEZpeCBwb3NpdGlvbiBpbiBOb2RlIHdoZXJlIHNvbWUgKGludGVybmFsKSBjb2RlIGlzIHByZXBlbmRlZC5cbiAgICAvLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL2V2YW53L25vZGUtc291cmNlLW1hcC1zdXBwb3J0L2lzc3Vlcy8zNlxuICAgIHZhciBoZWFkZXJMZW5ndGggPSA2MjtcbiAgICBpZiAobGluZSA9PT0gMSAmJiBjb2x1bW4gPiBoZWFkZXJMZW5ndGggJiYgIWlzSW5Ccm93c2VyKCkgJiYgIWZyYW1lLmlzRXZhbCgpKSB7XG4gICAgICBjb2x1bW4gLT0gaGVhZGVyTGVuZ3RoO1xuICAgIH1cblxuICAgIHZhciBwb3NpdGlvbiA9IG1hcFNvdXJjZVBvc2l0aW9uKHtcbiAgICAgIHNvdXJjZTogc291cmNlLFxuICAgICAgbGluZTogbGluZSxcbiAgICAgIGNvbHVtbjogY29sdW1uXG4gICAgfSk7XG4gICAgZnJhbWUgPSBjbG9uZUNhbGxTaXRlKGZyYW1lKTtcbiAgICBmcmFtZS5nZXRGaWxlTmFtZSA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gcG9zaXRpb24uc291cmNlOyB9O1xuICAgIGZyYW1lLmdldExpbmVOdW1iZXIgPSBmdW5jdGlvbigpIHsgcmV0dXJuIHBvc2l0aW9uLmxpbmU7IH07XG4gICAgZnJhbWUuZ2V0Q29sdW1uTnVtYmVyID0gZnVuY3Rpb24oKSB7IHJldHVybiBwb3NpdGlvbi5jb2x1bW4gKyAxOyB9O1xuICAgIGZyYW1lLmdldFNjcmlwdE5hbWVPclNvdXJjZVVSTCA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gcG9zaXRpb24uc291cmNlOyB9O1xuICAgIHJldHVybiBmcmFtZTtcbiAgfVxuXG4gIC8vIENvZGUgY2FsbGVkIHVzaW5nIGV2YWwoKSBuZWVkcyBzcGVjaWFsIGhhbmRsaW5nXG4gIHZhciBvcmlnaW4gPSBmcmFtZS5pc0V2YWwoKSAmJiBmcmFtZS5nZXRFdmFsT3JpZ2luKCk7XG4gIGlmIChvcmlnaW4pIHtcbiAgICBvcmlnaW4gPSBtYXBFdmFsT3JpZ2luKG9yaWdpbik7XG4gICAgZnJhbWUgPSBjbG9uZUNhbGxTaXRlKGZyYW1lKTtcbiAgICBmcmFtZS5nZXRFdmFsT3JpZ2luID0gZnVuY3Rpb24oKSB7IHJldHVybiBvcmlnaW47IH07XG4gICAgcmV0dXJuIGZyYW1lO1xuICB9XG5cbiAgLy8gSWYgd2UgZ2V0IGhlcmUgdGhlbiB3ZSB3ZXJlIHVuYWJsZSB0byBjaGFuZ2UgdGhlIHNvdXJjZSBwb3NpdGlvblxuICByZXR1cm4gZnJhbWU7XG59XG5cbi8vIFRoaXMgZnVuY3Rpb24gaXMgcGFydCBvZiB0aGUgVjggc3RhY2sgdHJhY2UgQVBJLCBmb3IgbW9yZSBpbmZvIHNlZTpcbi8vIGh0dHA6Ly9jb2RlLmdvb2dsZS5jb20vcC92OC93aWtpL0phdmFTY3JpcHRTdGFja1RyYWNlQXBpXG5mdW5jdGlvbiBwcmVwYXJlU3RhY2tUcmFjZShlcnJvciwgc3RhY2spIHtcbiAgaWYgKGVtcHR5Q2FjaGVCZXR3ZWVuT3BlcmF0aW9ucykge1xuICAgIGZpbGVDb250ZW50c0NhY2hlID0ge307XG4gICAgc291cmNlTWFwQ2FjaGUgPSB7fTtcbiAgfVxuXG4gIHJldHVybiBlcnJvciArIHN0YWNrLm1hcChmdW5jdGlvbihmcmFtZSkge1xuICAgIHJldHVybiAnXFxuICAgIGF0ICcgKyB3cmFwQ2FsbFNpdGUoZnJhbWUpO1xuICB9KS5qb2luKCcnKTtcbn1cblxuLy8gR2VuZXJhdGUgcG9zaXRpb24gYW5kIHNuaXBwZXQgb2Ygb3JpZ2luYWwgc291cmNlIHdpdGggcG9pbnRlclxuZnVuY3Rpb24gZ2V0RXJyb3JTb3VyY2UoZXJyb3IpIHtcbiAgdmFyIG1hdGNoID0gL1xcbiAgICBhdCBbXihdKyBcXCgoLiopOihcXGQrKTooXFxkKylcXCkvLmV4ZWMoZXJyb3Iuc3RhY2spO1xuICBpZiAobWF0Y2gpIHtcbiAgICB2YXIgc291cmNlID0gbWF0Y2hbMV07XG4gICAgdmFyIGxpbmUgPSArbWF0Y2hbMl07XG4gICAgdmFyIGNvbHVtbiA9ICttYXRjaFszXTtcblxuICAgIC8vIFN1cHBvcnQgdGhlIGlubGluZSBzb3VyY2VDb250ZW50cyBpbnNpZGUgdGhlIHNvdXJjZSBtYXBcbiAgICB2YXIgY29udGVudHMgPSBmaWxlQ29udGVudHNDYWNoZVtzb3VyY2VdO1xuXG4gICAgLy8gU3VwcG9ydCBmaWxlcyBvbiBkaXNrXG4gICAgaWYgKCFjb250ZW50cyAmJiBmcyAmJiBmcy5leGlzdHNTeW5jKHNvdXJjZSkpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnRlbnRzID0gZnMucmVhZEZpbGVTeW5jKHNvdXJjZSwgJ3V0ZjgnKTtcbiAgICAgIH0gY2F0Y2ggKGVyKSB7XG4gICAgICAgIGNvbnRlbnRzID0gJyc7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gRm9ybWF0IHRoZSBsaW5lIGZyb20gdGhlIG9yaWdpbmFsIHNvdXJjZSBjb2RlIGxpa2Ugbm9kZSBkb2VzXG4gICAgaWYgKGNvbnRlbnRzKSB7XG4gICAgICB2YXIgY29kZSA9IGNvbnRlbnRzLnNwbGl0KC8oPzpcXHJcXG58XFxyfFxcbikvKVtsaW5lIC0gMV07XG4gICAgICBpZiAoY29kZSkge1xuICAgICAgICByZXR1cm4gc291cmNlICsgJzonICsgbGluZSArICdcXG4nICsgY29kZSArICdcXG4nICtcbiAgICAgICAgICBuZXcgQXJyYXkoY29sdW1uKS5qb2luKCcgJykgKyAnXic7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBudWxsO1xufVxuXG5mdW5jdGlvbiBwcmludEVycm9yQW5kRXhpdCAoZXJyb3IpIHtcbiAgdmFyIHNvdXJjZSA9IGdldEVycm9yU291cmNlKGVycm9yKTtcblxuICBpZiAoc291cmNlKSB7XG4gICAgY29uc29sZS5lcnJvcigpO1xuICAgIGNvbnNvbGUuZXJyb3Ioc291cmNlKTtcbiAgfVxuXG4gIGNvbnNvbGUuZXJyb3IoZXJyb3Iuc3RhY2spO1xuICBwcm9jZXNzLmV4aXQoMSk7XG59XG5cbmZ1bmN0aW9uIHNoaW1FbWl0VW5jYXVnaHRFeGNlcHRpb24gKCkge1xuICB2YXIgb3JpZ0VtaXQgPSBwcm9jZXNzLmVtaXQ7XG5cbiAgcHJvY2Vzcy5lbWl0ID0gZnVuY3Rpb24gKHR5cGUpIHtcbiAgICBpZiAodHlwZSA9PT0gJ3VuY2F1Z2h0RXhjZXB0aW9uJykge1xuICAgICAgdmFyIGhhc1N0YWNrID0gKGFyZ3VtZW50c1sxXSAmJiBhcmd1bWVudHNbMV0uc3RhY2spO1xuICAgICAgdmFyIGhhc0xpc3RlbmVycyA9ICh0aGlzLmxpc3RlbmVycyh0eXBlKS5sZW5ndGggPiAwKTtcblxuICAgICAgaWYgKGhhc1N0YWNrICYmICFoYXNMaXN0ZW5lcnMpIHtcbiAgICAgICAgcmV0dXJuIHByaW50RXJyb3JBbmRFeGl0KGFyZ3VtZW50c1sxXSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIG9yaWdFbWl0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gIH07XG59XG5cbmV4cG9ydHMud3JhcENhbGxTaXRlID0gd3JhcENhbGxTaXRlO1xuZXhwb3J0cy5nZXRFcnJvclNvdXJjZSA9IGdldEVycm9yU291cmNlO1xuZXhwb3J0cy5tYXBTb3VyY2VQb3NpdGlvbiA9IG1hcFNvdXJjZVBvc2l0aW9uO1xuZXhwb3J0cy5yZXRyaWV2ZVNvdXJjZU1hcCA9IHJldHJpZXZlU291cmNlTWFwO1xuXG5leHBvcnRzLmluc3RhbGwgPSBmdW5jdGlvbihvcHRpb25zKSB7XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gIGlmIChvcHRpb25zLmVudmlyb25tZW50KSB7XG4gICAgZW52aXJvbm1lbnQgPSBvcHRpb25zLmVudmlyb25tZW50O1xuICAgIGlmIChbXCJub2RlXCIsIFwiYnJvd3NlclwiLCBcImF1dG9cIl0uaW5kZXhPZihlbnZpcm9ubWVudCkgPT09IC0xKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJlbnZpcm9ubWVudCBcIiArIGVudmlyb25tZW50ICsgXCIgd2FzIHVua25vd24uIEF2YWlsYWJsZSBvcHRpb25zIGFyZSB7YXV0bywgYnJvd3Nlciwgbm9kZX1cIilcbiAgICB9XG4gIH1cblxuICAvLyBBbGxvdyBzb3VyY2VzIHRvIGJlIGZvdW5kIGJ5IG1ldGhvZHMgb3RoZXIgdGhhbiByZWFkaW5nIHRoZSBmaWxlc1xuICAvLyBkaXJlY3RseSBmcm9tIGRpc2suXG4gIGlmIChvcHRpb25zLnJldHJpZXZlRmlsZSkge1xuICAgIGlmIChvcHRpb25zLm92ZXJyaWRlUmV0cmlldmVGaWxlKSB7XG4gICAgICByZXRyaWV2ZUZpbGVIYW5kbGVycy5sZW5ndGggPSAwO1xuICAgIH1cblxuICAgIHJldHJpZXZlRmlsZUhhbmRsZXJzLnVuc2hpZnQob3B0aW9ucy5yZXRyaWV2ZUZpbGUpO1xuICB9XG5cbiAgLy8gQWxsb3cgc291cmNlIG1hcHMgdG8gYmUgZm91bmQgYnkgbWV0aG9kcyBvdGhlciB0aGFuIHJlYWRpbmcgdGhlIGZpbGVzXG4gIC8vIGRpcmVjdGx5IGZyb20gZGlzay5cbiAgaWYgKG9wdGlvbnMucmV0cmlldmVTb3VyY2VNYXApIHtcbiAgICBpZiAob3B0aW9ucy5vdmVycmlkZVJldHJpZXZlU291cmNlTWFwKSB7XG4gICAgICByZXRyaWV2ZU1hcEhhbmRsZXJzLmxlbmd0aCA9IDA7XG4gICAgfVxuXG4gICAgcmV0cmlldmVNYXBIYW5kbGVycy51bnNoaWZ0KG9wdGlvbnMucmV0cmlldmVTb3VyY2VNYXApO1xuICB9XG5cbiAgLy8gU3VwcG9ydCBydW50aW1lIHRyYW5zcGlsZXJzIHRoYXQgaW5jbHVkZSBpbmxpbmUgc291cmNlIG1hcHNcbiAgaWYgKG9wdGlvbnMuaG9va1JlcXVpcmUgJiYgIWlzSW5Ccm93c2VyKCkpIHtcbiAgICB2YXIgTW9kdWxlO1xuICAgIHRyeSB7XG4gICAgICBNb2R1bGUgPSByZXF1aXJlKCdtb2R1bGUnKTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIC8vIE5PUDogTG9hZGluZyBpbiBjYXRjaCBibG9jayB0byBjb252ZXJ0IHdlYnBhY2sgZXJyb3IgdG8gd2FybmluZy5cbiAgICB9XG4gICAgdmFyICRjb21waWxlID0gTW9kdWxlLnByb3RvdHlwZS5fY29tcGlsZTtcblxuICAgIGlmICghJGNvbXBpbGUuX19zb3VyY2VNYXBTdXBwb3J0KSB7XG4gICAgICBNb2R1bGUucHJvdG90eXBlLl9jb21waWxlID0gZnVuY3Rpb24oY29udGVudCwgZmlsZW5hbWUpIHtcbiAgICAgICAgZmlsZUNvbnRlbnRzQ2FjaGVbZmlsZW5hbWVdID0gY29udGVudDtcbiAgICAgICAgc291cmNlTWFwQ2FjaGVbZmlsZW5hbWVdID0gdW5kZWZpbmVkO1xuICAgICAgICByZXR1cm4gJGNvbXBpbGUuY2FsbCh0aGlzLCBjb250ZW50LCBmaWxlbmFtZSk7XG4gICAgICB9O1xuXG4gICAgICBNb2R1bGUucHJvdG90eXBlLl9jb21waWxlLl9fc291cmNlTWFwU3VwcG9ydCA9IHRydWU7XG4gICAgfVxuICB9XG5cbiAgLy8gQ29uZmlndXJlIG9wdGlvbnNcbiAgaWYgKCFlbXB0eUNhY2hlQmV0d2Vlbk9wZXJhdGlvbnMpIHtcbiAgICBlbXB0eUNhY2hlQmV0d2Vlbk9wZXJhdGlvbnMgPSAnZW1wdHlDYWNoZUJldHdlZW5PcGVyYXRpb25zJyBpbiBvcHRpb25zID9cbiAgICAgIG9wdGlvbnMuZW1wdHlDYWNoZUJldHdlZW5PcGVyYXRpb25zIDogZmFsc2U7XG4gIH1cblxuICAvLyBJbnN0YWxsIHRoZSBlcnJvciByZWZvcm1hdHRlclxuICBpZiAoIWVycm9yRm9ybWF0dGVySW5zdGFsbGVkKSB7XG4gICAgZXJyb3JGb3JtYXR0ZXJJbnN0YWxsZWQgPSB0cnVlO1xuICAgIEVycm9yLnByZXBhcmVTdGFja1RyYWNlID0gcHJlcGFyZVN0YWNrVHJhY2U7XG4gIH1cblxuICBpZiAoIXVuY2F1Z2h0U2hpbUluc3RhbGxlZCkge1xuICAgIHZhciBpbnN0YWxsSGFuZGxlciA9ICdoYW5kbGVVbmNhdWdodEV4Y2VwdGlvbnMnIGluIG9wdGlvbnMgP1xuICAgICAgb3B0aW9ucy5oYW5kbGVVbmNhdWdodEV4Y2VwdGlvbnMgOiB0cnVlO1xuXG4gICAgLy8gUHJvdmlkZSB0aGUgb3B0aW9uIHRvIG5vdCBpbnN0YWxsIHRoZSB1bmNhdWdodCBleGNlcHRpb24gaGFuZGxlci4gVGhpcyBpc1xuICAgIC8vIHRvIHN1cHBvcnQgb3RoZXIgdW5jYXVnaHQgZXhjZXB0aW9uIGhhbmRsZXJzIChpbiB0ZXN0IGZyYW1ld29ya3MsIGZvclxuICAgIC8vIGV4YW1wbGUpLiBJZiB0aGlzIGhhbmRsZXIgaXMgbm90IGluc3RhbGxlZCBhbmQgdGhlcmUgYXJlIG5vIG90aGVyIHVuY2F1Z2h0XG4gICAgLy8gZXhjZXB0aW9uIGhhbmRsZXJzLCB1bmNhdWdodCBleGNlcHRpb25zIHdpbGwgYmUgY2F1Z2h0IGJ5IG5vZGUncyBidWlsdC1pblxuICAgIC8vIGV4Y2VwdGlvbiBoYW5kbGVyIGFuZCB0aGUgcHJvY2VzcyB3aWxsIHN0aWxsIGJlIHRlcm1pbmF0ZWQuIEhvd2V2ZXIsIHRoZVxuICAgIC8vIGdlbmVyYXRlZCBKYXZhU2NyaXB0IGNvZGUgd2lsbCBiZSBzaG93biBhYm92ZSB0aGUgc3RhY2sgdHJhY2UgaW5zdGVhZCBvZlxuICAgIC8vIHRoZSBvcmlnaW5hbCBzb3VyY2UgY29kZS5cbiAgICBpZiAoaW5zdGFsbEhhbmRsZXIgJiYgaGFzR2xvYmFsUHJvY2Vzc0V2ZW50RW1pdHRlcigpKSB7XG4gICAgICB1bmNhdWdodFNoaW1JbnN0YWxsZWQgPSB0cnVlO1xuICAgICAgc2hpbUVtaXRVbmNhdWdodEV4Y2VwdGlvbigpO1xuICAgIH1cbiAgfVxufTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9lbGVjdHJvbi11cGRhdGVyL25vZGVfbW9kdWxlcy9zb3VyY2UtbWFwLXN1cHBvcnQvc291cmNlLW1hcC1zdXBwb3J0LmpzIiwiLypcbiAqIENvcHlyaWdodCAyMDA5LTIwMTEgTW96aWxsYSBGb3VuZGF0aW9uIGFuZCBjb250cmlidXRvcnNcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBOZXcgQlNEIGxpY2Vuc2UuIFNlZSBMSUNFTlNFLnR4dCBvcjpcbiAqIGh0dHA6Ly9vcGVuc291cmNlLm9yZy9saWNlbnNlcy9CU0QtMy1DbGF1c2VcbiAqL1xuZXhwb3J0cy5Tb3VyY2VNYXBHZW5lcmF0b3IgPSByZXF1aXJlKCcuL2xpYi9zb3VyY2UtbWFwLWdlbmVyYXRvcicpLlNvdXJjZU1hcEdlbmVyYXRvcjtcbmV4cG9ydHMuU291cmNlTWFwQ29uc3VtZXIgPSByZXF1aXJlKCcuL2xpYi9zb3VyY2UtbWFwLWNvbnN1bWVyJykuU291cmNlTWFwQ29uc3VtZXI7XG5leHBvcnRzLlNvdXJjZU5vZGUgPSByZXF1aXJlKCcuL2xpYi9zb3VyY2Utbm9kZScpLlNvdXJjZU5vZGU7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvZWxlY3Ryb24tdXBkYXRlci9ub2RlX21vZHVsZXMvc291cmNlLW1hcC9zb3VyY2UtbWFwLmpzIiwiLyogLSotIE1vZGU6IGpzOyBqcy1pbmRlbnQtbGV2ZWw6IDI7IC0qLSAqL1xuLypcbiAqIENvcHlyaWdodCAyMDExIE1vemlsbGEgRm91bmRhdGlvbiBhbmQgY29udHJpYnV0b3JzXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTmV3IEJTRCBsaWNlbnNlLiBTZWUgTElDRU5TRSBvcjpcbiAqIGh0dHA6Ly9vcGVuc291cmNlLm9yZy9saWNlbnNlcy9CU0QtMy1DbGF1c2VcbiAqL1xuXG52YXIgaW50VG9DaGFyTWFwID0gJ0FCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDU2Nzg5Ky8nLnNwbGl0KCcnKTtcblxuLyoqXG4gKiBFbmNvZGUgYW4gaW50ZWdlciBpbiB0aGUgcmFuZ2Ugb2YgMCB0byA2MyB0byBhIHNpbmdsZSBiYXNlIDY0IGRpZ2l0LlxuICovXG5leHBvcnRzLmVuY29kZSA9IGZ1bmN0aW9uIChudW1iZXIpIHtcbiAgaWYgKDAgPD0gbnVtYmVyICYmIG51bWJlciA8IGludFRvQ2hhck1hcC5sZW5ndGgpIHtcbiAgICByZXR1cm4gaW50VG9DaGFyTWFwW251bWJlcl07XG4gIH1cbiAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIk11c3QgYmUgYmV0d2VlbiAwIGFuZCA2MzogXCIgKyBudW1iZXIpO1xufTtcblxuLyoqXG4gKiBEZWNvZGUgYSBzaW5nbGUgYmFzZSA2NCBjaGFyYWN0ZXIgY29kZSBkaWdpdCB0byBhbiBpbnRlZ2VyLiBSZXR1cm5zIC0xIG9uXG4gKiBmYWlsdXJlLlxuICovXG5leHBvcnRzLmRlY29kZSA9IGZ1bmN0aW9uIChjaGFyQ29kZSkge1xuICB2YXIgYmlnQSA9IDY1OyAgICAgLy8gJ0EnXG4gIHZhciBiaWdaID0gOTA7ICAgICAvLyAnWidcblxuICB2YXIgbGl0dGxlQSA9IDk3OyAgLy8gJ2EnXG4gIHZhciBsaXR0bGVaID0gMTIyOyAvLyAneidcblxuICB2YXIgemVybyA9IDQ4OyAgICAgLy8gJzAnXG4gIHZhciBuaW5lID0gNTc7ICAgICAvLyAnOSdcblxuICB2YXIgcGx1cyA9IDQzOyAgICAgLy8gJysnXG4gIHZhciBzbGFzaCA9IDQ3OyAgICAvLyAnLydcblxuICB2YXIgbGl0dGxlT2Zmc2V0ID0gMjY7XG4gIHZhciBudW1iZXJPZmZzZXQgPSA1MjtcblxuICAvLyAwIC0gMjU6IEFCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaXG4gIGlmIChiaWdBIDw9IGNoYXJDb2RlICYmIGNoYXJDb2RlIDw9IGJpZ1opIHtcbiAgICByZXR1cm4gKGNoYXJDb2RlIC0gYmlnQSk7XG4gIH1cblxuICAvLyAyNiAtIDUxOiBhYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5elxuICBpZiAobGl0dGxlQSA8PSBjaGFyQ29kZSAmJiBjaGFyQ29kZSA8PSBsaXR0bGVaKSB7XG4gICAgcmV0dXJuIChjaGFyQ29kZSAtIGxpdHRsZUEgKyBsaXR0bGVPZmZzZXQpO1xuICB9XG5cbiAgLy8gNTIgLSA2MTogMDEyMzQ1Njc4OVxuICBpZiAoemVybyA8PSBjaGFyQ29kZSAmJiBjaGFyQ29kZSA8PSBuaW5lKSB7XG4gICAgcmV0dXJuIChjaGFyQ29kZSAtIHplcm8gKyBudW1iZXJPZmZzZXQpO1xuICB9XG5cbiAgLy8gNjI6ICtcbiAgaWYgKGNoYXJDb2RlID09IHBsdXMpIHtcbiAgICByZXR1cm4gNjI7XG4gIH1cblxuICAvLyA2MzogL1xuICBpZiAoY2hhckNvZGUgPT0gc2xhc2gpIHtcbiAgICByZXR1cm4gNjM7XG4gIH1cblxuICAvLyBJbnZhbGlkIGJhc2U2NCBkaWdpdC5cbiAgcmV0dXJuIC0xO1xufTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9lbGVjdHJvbi11cGRhdGVyL25vZGVfbW9kdWxlcy9zb3VyY2UtbWFwL2xpYi9iYXNlNjQuanMiLCIvKiAtKi0gTW9kZToganM7IGpzLWluZGVudC1sZXZlbDogMjsgLSotICovXG4vKlxuICogQ29weXJpZ2h0IDIwMTQgTW96aWxsYSBGb3VuZGF0aW9uIGFuZCBjb250cmlidXRvcnNcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBOZXcgQlNEIGxpY2Vuc2UuIFNlZSBMSUNFTlNFIG9yOlxuICogaHR0cDovL29wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL0JTRC0zLUNsYXVzZVxuICovXG5cbnZhciB1dGlsID0gcmVxdWlyZSgnLi91dGlsJyk7XG5cbi8qKlxuICogRGV0ZXJtaW5lIHdoZXRoZXIgbWFwcGluZ0IgaXMgYWZ0ZXIgbWFwcGluZ0Egd2l0aCByZXNwZWN0IHRvIGdlbmVyYXRlZFxuICogcG9zaXRpb24uXG4gKi9cbmZ1bmN0aW9uIGdlbmVyYXRlZFBvc2l0aW9uQWZ0ZXIobWFwcGluZ0EsIG1hcHBpbmdCKSB7XG4gIC8vIE9wdGltaXplZCBmb3IgbW9zdCBjb21tb24gY2FzZVxuICB2YXIgbGluZUEgPSBtYXBwaW5nQS5nZW5lcmF0ZWRMaW5lO1xuICB2YXIgbGluZUIgPSBtYXBwaW5nQi5nZW5lcmF0ZWRMaW5lO1xuICB2YXIgY29sdW1uQSA9IG1hcHBpbmdBLmdlbmVyYXRlZENvbHVtbjtcbiAgdmFyIGNvbHVtbkIgPSBtYXBwaW5nQi5nZW5lcmF0ZWRDb2x1bW47XG4gIHJldHVybiBsaW5lQiA+IGxpbmVBIHx8IGxpbmVCID09IGxpbmVBICYmIGNvbHVtbkIgPj0gY29sdW1uQSB8fFxuICAgICAgICAgdXRpbC5jb21wYXJlQnlHZW5lcmF0ZWRQb3NpdGlvbnNJbmZsYXRlZChtYXBwaW5nQSwgbWFwcGluZ0IpIDw9IDA7XG59XG5cbi8qKlxuICogQSBkYXRhIHN0cnVjdHVyZSB0byBwcm92aWRlIGEgc29ydGVkIHZpZXcgb2YgYWNjdW11bGF0ZWQgbWFwcGluZ3MgaW4gYVxuICogcGVyZm9ybWFuY2UgY29uc2Npb3VzIG1hbm5lci4gSXQgdHJhZGVzIGEgbmVnbGliYWJsZSBvdmVyaGVhZCBpbiBnZW5lcmFsXG4gKiBjYXNlIGZvciBhIGxhcmdlIHNwZWVkdXAgaW4gY2FzZSBvZiBtYXBwaW5ncyBiZWluZyBhZGRlZCBpbiBvcmRlci5cbiAqL1xuZnVuY3Rpb24gTWFwcGluZ0xpc3QoKSB7XG4gIHRoaXMuX2FycmF5ID0gW107XG4gIHRoaXMuX3NvcnRlZCA9IHRydWU7XG4gIC8vIFNlcnZlcyBhcyBpbmZpbXVtXG4gIHRoaXMuX2xhc3QgPSB7Z2VuZXJhdGVkTGluZTogLTEsIGdlbmVyYXRlZENvbHVtbjogMH07XG59XG5cbi8qKlxuICogSXRlcmF0ZSB0aHJvdWdoIGludGVybmFsIGl0ZW1zLiBUaGlzIG1ldGhvZCB0YWtlcyB0aGUgc2FtZSBhcmd1bWVudHMgdGhhdFxuICogYEFycmF5LnByb3RvdHlwZS5mb3JFYWNoYCB0YWtlcy5cbiAqXG4gKiBOT1RFOiBUaGUgb3JkZXIgb2YgdGhlIG1hcHBpbmdzIGlzIE5PVCBndWFyYW50ZWVkLlxuICovXG5NYXBwaW5nTGlzdC5wcm90b3R5cGUudW5zb3J0ZWRGb3JFYWNoID1cbiAgZnVuY3Rpb24gTWFwcGluZ0xpc3RfZm9yRWFjaChhQ2FsbGJhY2ssIGFUaGlzQXJnKSB7XG4gICAgdGhpcy5fYXJyYXkuZm9yRWFjaChhQ2FsbGJhY2ssIGFUaGlzQXJnKTtcbiAgfTtcblxuLyoqXG4gKiBBZGQgdGhlIGdpdmVuIHNvdXJjZSBtYXBwaW5nLlxuICpcbiAqIEBwYXJhbSBPYmplY3QgYU1hcHBpbmdcbiAqL1xuTWFwcGluZ0xpc3QucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uIE1hcHBpbmdMaXN0X2FkZChhTWFwcGluZykge1xuICBpZiAoZ2VuZXJhdGVkUG9zaXRpb25BZnRlcih0aGlzLl9sYXN0LCBhTWFwcGluZykpIHtcbiAgICB0aGlzLl9sYXN0ID0gYU1hcHBpbmc7XG4gICAgdGhpcy5fYXJyYXkucHVzaChhTWFwcGluZyk7XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5fc29ydGVkID0gZmFsc2U7XG4gICAgdGhpcy5fYXJyYXkucHVzaChhTWFwcGluZyk7XG4gIH1cbn07XG5cbi8qKlxuICogUmV0dXJucyB0aGUgZmxhdCwgc29ydGVkIGFycmF5IG9mIG1hcHBpbmdzLiBUaGUgbWFwcGluZ3MgYXJlIHNvcnRlZCBieVxuICogZ2VuZXJhdGVkIHBvc2l0aW9uLlxuICpcbiAqIFdBUk5JTkc6IFRoaXMgbWV0aG9kIHJldHVybnMgaW50ZXJuYWwgZGF0YSB3aXRob3V0IGNvcHlpbmcsIGZvclxuICogcGVyZm9ybWFuY2UuIFRoZSByZXR1cm4gdmFsdWUgbXVzdCBOT1QgYmUgbXV0YXRlZCwgYW5kIHNob3VsZCBiZSB0cmVhdGVkIGFzXG4gKiBhbiBpbW11dGFibGUgYm9ycm93LiBJZiB5b3Ugd2FudCB0byB0YWtlIG93bmVyc2hpcCwgeW91IG11c3QgbWFrZSB5b3VyIG93blxuICogY29weS5cbiAqL1xuTWFwcGluZ0xpc3QucHJvdG90eXBlLnRvQXJyYXkgPSBmdW5jdGlvbiBNYXBwaW5nTGlzdF90b0FycmF5KCkge1xuICBpZiAoIXRoaXMuX3NvcnRlZCkge1xuICAgIHRoaXMuX2FycmF5LnNvcnQodXRpbC5jb21wYXJlQnlHZW5lcmF0ZWRQb3NpdGlvbnNJbmZsYXRlZCk7XG4gICAgdGhpcy5fc29ydGVkID0gdHJ1ZTtcbiAgfVxuICByZXR1cm4gdGhpcy5fYXJyYXk7XG59O1xuXG5leHBvcnRzLk1hcHBpbmdMaXN0ID0gTWFwcGluZ0xpc3Q7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvZWxlY3Ryb24tdXBkYXRlci9ub2RlX21vZHVsZXMvc291cmNlLW1hcC9saWIvbWFwcGluZy1saXN0LmpzIiwiLyogLSotIE1vZGU6IGpzOyBqcy1pbmRlbnQtbGV2ZWw6IDI7IC0qLSAqL1xuLypcbiAqIENvcHlyaWdodCAyMDExIE1vemlsbGEgRm91bmRhdGlvbiBhbmQgY29udHJpYnV0b3JzXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTmV3IEJTRCBsaWNlbnNlLiBTZWUgTElDRU5TRSBvcjpcbiAqIGh0dHA6Ly9vcGVuc291cmNlLm9yZy9saWNlbnNlcy9CU0QtMy1DbGF1c2VcbiAqL1xuXG52YXIgdXRpbCA9IHJlcXVpcmUoJy4vdXRpbCcpO1xudmFyIGJpbmFyeVNlYXJjaCA9IHJlcXVpcmUoJy4vYmluYXJ5LXNlYXJjaCcpO1xudmFyIEFycmF5U2V0ID0gcmVxdWlyZSgnLi9hcnJheS1zZXQnKS5BcnJheVNldDtcbnZhciBiYXNlNjRWTFEgPSByZXF1aXJlKCcuL2Jhc2U2NC12bHEnKTtcbnZhciBxdWlja1NvcnQgPSByZXF1aXJlKCcuL3F1aWNrLXNvcnQnKS5xdWlja1NvcnQ7XG5cbmZ1bmN0aW9uIFNvdXJjZU1hcENvbnN1bWVyKGFTb3VyY2VNYXAsIGFTb3VyY2VNYXBVUkwpIHtcbiAgdmFyIHNvdXJjZU1hcCA9IGFTb3VyY2VNYXA7XG4gIGlmICh0eXBlb2YgYVNvdXJjZU1hcCA9PT0gJ3N0cmluZycpIHtcbiAgICBzb3VyY2VNYXAgPSB1dGlsLnBhcnNlU291cmNlTWFwSW5wdXQoYVNvdXJjZU1hcCk7XG4gIH1cblxuICByZXR1cm4gc291cmNlTWFwLnNlY3Rpb25zICE9IG51bGxcbiAgICA/IG5ldyBJbmRleGVkU291cmNlTWFwQ29uc3VtZXIoc291cmNlTWFwLCBhU291cmNlTWFwVVJMKVxuICAgIDogbmV3IEJhc2ljU291cmNlTWFwQ29uc3VtZXIoc291cmNlTWFwLCBhU291cmNlTWFwVVJMKTtcbn1cblxuU291cmNlTWFwQ29uc3VtZXIuZnJvbVNvdXJjZU1hcCA9IGZ1bmN0aW9uKGFTb3VyY2VNYXAsIGFTb3VyY2VNYXBVUkwpIHtcbiAgcmV0dXJuIEJhc2ljU291cmNlTWFwQ29uc3VtZXIuZnJvbVNvdXJjZU1hcChhU291cmNlTWFwLCBhU291cmNlTWFwVVJMKTtcbn1cblxuLyoqXG4gKiBUaGUgdmVyc2lvbiBvZiB0aGUgc291cmNlIG1hcHBpbmcgc3BlYyB0aGF0IHdlIGFyZSBjb25zdW1pbmcuXG4gKi9cblNvdXJjZU1hcENvbnN1bWVyLnByb3RvdHlwZS5fdmVyc2lvbiA9IDM7XG5cbi8vIGBfX2dlbmVyYXRlZE1hcHBpbmdzYCBhbmQgYF9fb3JpZ2luYWxNYXBwaW5nc2AgYXJlIGFycmF5cyB0aGF0IGhvbGQgdGhlXG4vLyBwYXJzZWQgbWFwcGluZyBjb29yZGluYXRlcyBmcm9tIHRoZSBzb3VyY2UgbWFwJ3MgXCJtYXBwaW5nc1wiIGF0dHJpYnV0ZS4gVGhleVxuLy8gYXJlIGxhemlseSBpbnN0YW50aWF0ZWQsIGFjY2Vzc2VkIHZpYSB0aGUgYF9nZW5lcmF0ZWRNYXBwaW5nc2AgYW5kXG4vLyBgX29yaWdpbmFsTWFwcGluZ3NgIGdldHRlcnMgcmVzcGVjdGl2ZWx5LCBhbmQgd2Ugb25seSBwYXJzZSB0aGUgbWFwcGluZ3Ncbi8vIGFuZCBjcmVhdGUgdGhlc2UgYXJyYXlzIG9uY2UgcXVlcmllZCBmb3IgYSBzb3VyY2UgbG9jYXRpb24uIFdlIGp1bXAgdGhyb3VnaFxuLy8gdGhlc2UgaG9vcHMgYmVjYXVzZSB0aGVyZSBjYW4gYmUgbWFueSB0aG91c2FuZHMgb2YgbWFwcGluZ3MsIGFuZCBwYXJzaW5nXG4vLyB0aGVtIGlzIGV4cGVuc2l2ZSwgc28gd2Ugb25seSB3YW50IHRvIGRvIGl0IGlmIHdlIG11c3QuXG4vL1xuLy8gRWFjaCBvYmplY3QgaW4gdGhlIGFycmF5cyBpcyBvZiB0aGUgZm9ybTpcbi8vXG4vLyAgICAge1xuLy8gICAgICAgZ2VuZXJhdGVkTGluZTogVGhlIGxpbmUgbnVtYmVyIGluIHRoZSBnZW5lcmF0ZWQgY29kZSxcbi8vICAgICAgIGdlbmVyYXRlZENvbHVtbjogVGhlIGNvbHVtbiBudW1iZXIgaW4gdGhlIGdlbmVyYXRlZCBjb2RlLFxuLy8gICAgICAgc291cmNlOiBUaGUgcGF0aCB0byB0aGUgb3JpZ2luYWwgc291cmNlIGZpbGUgdGhhdCBnZW5lcmF0ZWQgdGhpc1xuLy8gICAgICAgICAgICAgICBjaHVuayBvZiBjb2RlLFxuLy8gICAgICAgb3JpZ2luYWxMaW5lOiBUaGUgbGluZSBudW1iZXIgaW4gdGhlIG9yaWdpbmFsIHNvdXJjZSB0aGF0XG4vLyAgICAgICAgICAgICAgICAgICAgIGNvcnJlc3BvbmRzIHRvIHRoaXMgY2h1bmsgb2YgZ2VuZXJhdGVkIGNvZGUsXG4vLyAgICAgICBvcmlnaW5hbENvbHVtbjogVGhlIGNvbHVtbiBudW1iZXIgaW4gdGhlIG9yaWdpbmFsIHNvdXJjZSB0aGF0XG4vLyAgICAgICAgICAgICAgICAgICAgICAgY29ycmVzcG9uZHMgdG8gdGhpcyBjaHVuayBvZiBnZW5lcmF0ZWQgY29kZSxcbi8vICAgICAgIG5hbWU6IFRoZSBuYW1lIG9mIHRoZSBvcmlnaW5hbCBzeW1ib2wgd2hpY2ggZ2VuZXJhdGVkIHRoaXMgY2h1bmsgb2Zcbi8vICAgICAgICAgICAgIGNvZGUuXG4vLyAgICAgfVxuLy9cbi8vIEFsbCBwcm9wZXJ0aWVzIGV4Y2VwdCBmb3IgYGdlbmVyYXRlZExpbmVgIGFuZCBgZ2VuZXJhdGVkQ29sdW1uYCBjYW4gYmVcbi8vIGBudWxsYC5cbi8vXG4vLyBgX2dlbmVyYXRlZE1hcHBpbmdzYCBpcyBvcmRlcmVkIGJ5IHRoZSBnZW5lcmF0ZWQgcG9zaXRpb25zLlxuLy9cbi8vIGBfb3JpZ2luYWxNYXBwaW5nc2AgaXMgb3JkZXJlZCBieSB0aGUgb3JpZ2luYWwgcG9zaXRpb25zLlxuXG5Tb3VyY2VNYXBDb25zdW1lci5wcm90b3R5cGUuX19nZW5lcmF0ZWRNYXBwaW5ncyA9IG51bGw7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoU291cmNlTWFwQ29uc3VtZXIucHJvdG90eXBlLCAnX2dlbmVyYXRlZE1hcHBpbmdzJywge1xuICBjb25maWd1cmFibGU6IHRydWUsXG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIGlmICghdGhpcy5fX2dlbmVyYXRlZE1hcHBpbmdzKSB7XG4gICAgICB0aGlzLl9wYXJzZU1hcHBpbmdzKHRoaXMuX21hcHBpbmdzLCB0aGlzLnNvdXJjZVJvb3QpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLl9fZ2VuZXJhdGVkTWFwcGluZ3M7XG4gIH1cbn0pO1xuXG5Tb3VyY2VNYXBDb25zdW1lci5wcm90b3R5cGUuX19vcmlnaW5hbE1hcHBpbmdzID0gbnVsbDtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShTb3VyY2VNYXBDb25zdW1lci5wcm90b3R5cGUsICdfb3JpZ2luYWxNYXBwaW5ncycsIHtcbiAgY29uZmlndXJhYmxlOiB0cnVlLFxuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoIXRoaXMuX19vcmlnaW5hbE1hcHBpbmdzKSB7XG4gICAgICB0aGlzLl9wYXJzZU1hcHBpbmdzKHRoaXMuX21hcHBpbmdzLCB0aGlzLnNvdXJjZVJvb3QpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLl9fb3JpZ2luYWxNYXBwaW5ncztcbiAgfVxufSk7XG5cblNvdXJjZU1hcENvbnN1bWVyLnByb3RvdHlwZS5fY2hhcklzTWFwcGluZ1NlcGFyYXRvciA9XG4gIGZ1bmN0aW9uIFNvdXJjZU1hcENvbnN1bWVyX2NoYXJJc01hcHBpbmdTZXBhcmF0b3IoYVN0ciwgaW5kZXgpIHtcbiAgICB2YXIgYyA9IGFTdHIuY2hhckF0KGluZGV4KTtcbiAgICByZXR1cm4gYyA9PT0gXCI7XCIgfHwgYyA9PT0gXCIsXCI7XG4gIH07XG5cbi8qKlxuICogUGFyc2UgdGhlIG1hcHBpbmdzIGluIGEgc3RyaW5nIGluIHRvIGEgZGF0YSBzdHJ1Y3R1cmUgd2hpY2ggd2UgY2FuIGVhc2lseVxuICogcXVlcnkgKHRoZSBvcmRlcmVkIGFycmF5cyBpbiB0aGUgYHRoaXMuX19nZW5lcmF0ZWRNYXBwaW5nc2AgYW5kXG4gKiBgdGhpcy5fX29yaWdpbmFsTWFwcGluZ3NgIHByb3BlcnRpZXMpLlxuICovXG5Tb3VyY2VNYXBDb25zdW1lci5wcm90b3R5cGUuX3BhcnNlTWFwcGluZ3MgPVxuICBmdW5jdGlvbiBTb3VyY2VNYXBDb25zdW1lcl9wYXJzZU1hcHBpbmdzKGFTdHIsIGFTb3VyY2VSb290KSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiU3ViY2xhc3NlcyBtdXN0IGltcGxlbWVudCBfcGFyc2VNYXBwaW5nc1wiKTtcbiAgfTtcblxuU291cmNlTWFwQ29uc3VtZXIuR0VORVJBVEVEX09SREVSID0gMTtcblNvdXJjZU1hcENvbnN1bWVyLk9SSUdJTkFMX09SREVSID0gMjtcblxuU291cmNlTWFwQ29uc3VtZXIuR1JFQVRFU1RfTE9XRVJfQk9VTkQgPSAxO1xuU291cmNlTWFwQ29uc3VtZXIuTEVBU1RfVVBQRVJfQk9VTkQgPSAyO1xuXG4vKipcbiAqIEl0ZXJhdGUgb3ZlciBlYWNoIG1hcHBpbmcgYmV0d2VlbiBhbiBvcmlnaW5hbCBzb3VyY2UvbGluZS9jb2x1bW4gYW5kIGFcbiAqIGdlbmVyYXRlZCBsaW5lL2NvbHVtbiBpbiB0aGlzIHNvdXJjZSBtYXAuXG4gKlxuICogQHBhcmFtIEZ1bmN0aW9uIGFDYWxsYmFja1xuICogICAgICAgIFRoZSBmdW5jdGlvbiB0aGF0IGlzIGNhbGxlZCB3aXRoIGVhY2ggbWFwcGluZy5cbiAqIEBwYXJhbSBPYmplY3QgYUNvbnRleHRcbiAqICAgICAgICBPcHRpb25hbC4gSWYgc3BlY2lmaWVkLCB0aGlzIG9iamVjdCB3aWxsIGJlIHRoZSB2YWx1ZSBvZiBgdGhpc2AgZXZlcnlcbiAqICAgICAgICB0aW1lIHRoYXQgYGFDYWxsYmFja2AgaXMgY2FsbGVkLlxuICogQHBhcmFtIGFPcmRlclxuICogICAgICAgIEVpdGhlciBgU291cmNlTWFwQ29uc3VtZXIuR0VORVJBVEVEX09SREVSYCBvclxuICogICAgICAgIGBTb3VyY2VNYXBDb25zdW1lci5PUklHSU5BTF9PUkRFUmAuIFNwZWNpZmllcyB3aGV0aGVyIHlvdSB3YW50IHRvXG4gKiAgICAgICAgaXRlcmF0ZSBvdmVyIHRoZSBtYXBwaW5ncyBzb3J0ZWQgYnkgdGhlIGdlbmVyYXRlZCBmaWxlJ3MgbGluZS9jb2x1bW5cbiAqICAgICAgICBvcmRlciBvciB0aGUgb3JpZ2luYWwncyBzb3VyY2UvbGluZS9jb2x1bW4gb3JkZXIsIHJlc3BlY3RpdmVseS4gRGVmYXVsdHMgdG9cbiAqICAgICAgICBgU291cmNlTWFwQ29uc3VtZXIuR0VORVJBVEVEX09SREVSYC5cbiAqL1xuU291cmNlTWFwQ29uc3VtZXIucHJvdG90eXBlLmVhY2hNYXBwaW5nID1cbiAgZnVuY3Rpb24gU291cmNlTWFwQ29uc3VtZXJfZWFjaE1hcHBpbmcoYUNhbGxiYWNrLCBhQ29udGV4dCwgYU9yZGVyKSB7XG4gICAgdmFyIGNvbnRleHQgPSBhQ29udGV4dCB8fCBudWxsO1xuICAgIHZhciBvcmRlciA9IGFPcmRlciB8fCBTb3VyY2VNYXBDb25zdW1lci5HRU5FUkFURURfT1JERVI7XG5cbiAgICB2YXIgbWFwcGluZ3M7XG4gICAgc3dpdGNoIChvcmRlcikge1xuICAgIGNhc2UgU291cmNlTWFwQ29uc3VtZXIuR0VORVJBVEVEX09SREVSOlxuICAgICAgbWFwcGluZ3MgPSB0aGlzLl9nZW5lcmF0ZWRNYXBwaW5ncztcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgU291cmNlTWFwQ29uc3VtZXIuT1JJR0lOQUxfT1JERVI6XG4gICAgICBtYXBwaW5ncyA9IHRoaXMuX29yaWdpbmFsTWFwcGluZ3M7XG4gICAgICBicmVhaztcbiAgICBkZWZhdWx0OlxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5rbm93biBvcmRlciBvZiBpdGVyYXRpb24uXCIpO1xuICAgIH1cblxuICAgIHZhciBzb3VyY2VSb290ID0gdGhpcy5zb3VyY2VSb290O1xuICAgIG1hcHBpbmdzLm1hcChmdW5jdGlvbiAobWFwcGluZykge1xuICAgICAgdmFyIHNvdXJjZSA9IG1hcHBpbmcuc291cmNlID09PSBudWxsID8gbnVsbCA6IHRoaXMuX3NvdXJjZXMuYXQobWFwcGluZy5zb3VyY2UpO1xuICAgICAgc291cmNlID0gdXRpbC5jb21wdXRlU291cmNlVVJMKHNvdXJjZVJvb3QsIHNvdXJjZSwgdGhpcy5fc291cmNlTWFwVVJMKTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHNvdXJjZTogc291cmNlLFxuICAgICAgICBnZW5lcmF0ZWRMaW5lOiBtYXBwaW5nLmdlbmVyYXRlZExpbmUsXG4gICAgICAgIGdlbmVyYXRlZENvbHVtbjogbWFwcGluZy5nZW5lcmF0ZWRDb2x1bW4sXG4gICAgICAgIG9yaWdpbmFsTGluZTogbWFwcGluZy5vcmlnaW5hbExpbmUsXG4gICAgICAgIG9yaWdpbmFsQ29sdW1uOiBtYXBwaW5nLm9yaWdpbmFsQ29sdW1uLFxuICAgICAgICBuYW1lOiBtYXBwaW5nLm5hbWUgPT09IG51bGwgPyBudWxsIDogdGhpcy5fbmFtZXMuYXQobWFwcGluZy5uYW1lKVxuICAgICAgfTtcbiAgICB9LCB0aGlzKS5mb3JFYWNoKGFDYWxsYmFjaywgY29udGV4dCk7XG4gIH07XG5cbi8qKlxuICogUmV0dXJucyBhbGwgZ2VuZXJhdGVkIGxpbmUgYW5kIGNvbHVtbiBpbmZvcm1hdGlvbiBmb3IgdGhlIG9yaWdpbmFsIHNvdXJjZSxcbiAqIGxpbmUsIGFuZCBjb2x1bW4gcHJvdmlkZWQuIElmIG5vIGNvbHVtbiBpcyBwcm92aWRlZCwgcmV0dXJucyBhbGwgbWFwcGluZ3NcbiAqIGNvcnJlc3BvbmRpbmcgdG8gYSBlaXRoZXIgdGhlIGxpbmUgd2UgYXJlIHNlYXJjaGluZyBmb3Igb3IgdGhlIG5leHRcbiAqIGNsb3Nlc3QgbGluZSB0aGF0IGhhcyBhbnkgbWFwcGluZ3MuIE90aGVyd2lzZSwgcmV0dXJucyBhbGwgbWFwcGluZ3NcbiAqIGNvcnJlc3BvbmRpbmcgdG8gdGhlIGdpdmVuIGxpbmUgYW5kIGVpdGhlciB0aGUgY29sdW1uIHdlIGFyZSBzZWFyY2hpbmcgZm9yXG4gKiBvciB0aGUgbmV4dCBjbG9zZXN0IGNvbHVtbiB0aGF0IGhhcyBhbnkgb2Zmc2V0cy5cbiAqXG4gKiBUaGUgb25seSBhcmd1bWVudCBpcyBhbiBvYmplY3Qgd2l0aCB0aGUgZm9sbG93aW5nIHByb3BlcnRpZXM6XG4gKlxuICogICAtIHNvdXJjZTogVGhlIGZpbGVuYW1lIG9mIHRoZSBvcmlnaW5hbCBzb3VyY2UuXG4gKiAgIC0gbGluZTogVGhlIGxpbmUgbnVtYmVyIGluIHRoZSBvcmlnaW5hbCBzb3VyY2UuICBUaGUgbGluZSBudW1iZXIgaXMgMS1iYXNlZC5cbiAqICAgLSBjb2x1bW46IE9wdGlvbmFsLiB0aGUgY29sdW1uIG51bWJlciBpbiB0aGUgb3JpZ2luYWwgc291cmNlLlxuICogICAgVGhlIGNvbHVtbiBudW1iZXIgaXMgMC1iYXNlZC5cbiAqXG4gKiBhbmQgYW4gYXJyYXkgb2Ygb2JqZWN0cyBpcyByZXR1cm5lZCwgZWFjaCB3aXRoIHRoZSBmb2xsb3dpbmcgcHJvcGVydGllczpcbiAqXG4gKiAgIC0gbGluZTogVGhlIGxpbmUgbnVtYmVyIGluIHRoZSBnZW5lcmF0ZWQgc291cmNlLCBvciBudWxsLiAgVGhlXG4gKiAgICBsaW5lIG51bWJlciBpcyAxLWJhc2VkLlxuICogICAtIGNvbHVtbjogVGhlIGNvbHVtbiBudW1iZXIgaW4gdGhlIGdlbmVyYXRlZCBzb3VyY2UsIG9yIG51bGwuXG4gKiAgICBUaGUgY29sdW1uIG51bWJlciBpcyAwLWJhc2VkLlxuICovXG5Tb3VyY2VNYXBDb25zdW1lci5wcm90b3R5cGUuYWxsR2VuZXJhdGVkUG9zaXRpb25zRm9yID1cbiAgZnVuY3Rpb24gU291cmNlTWFwQ29uc3VtZXJfYWxsR2VuZXJhdGVkUG9zaXRpb25zRm9yKGFBcmdzKSB7XG4gICAgdmFyIGxpbmUgPSB1dGlsLmdldEFyZyhhQXJncywgJ2xpbmUnKTtcblxuICAgIC8vIFdoZW4gdGhlcmUgaXMgbm8gZXhhY3QgbWF0Y2gsIEJhc2ljU291cmNlTWFwQ29uc3VtZXIucHJvdG90eXBlLl9maW5kTWFwcGluZ1xuICAgIC8vIHJldHVybnMgdGhlIGluZGV4IG9mIHRoZSBjbG9zZXN0IG1hcHBpbmcgbGVzcyB0aGFuIHRoZSBuZWVkbGUuIEJ5XG4gICAgLy8gc2V0dGluZyBuZWVkbGUub3JpZ2luYWxDb2x1bW4gdG8gMCwgd2UgdGh1cyBmaW5kIHRoZSBsYXN0IG1hcHBpbmcgZm9yXG4gICAgLy8gdGhlIGdpdmVuIGxpbmUsIHByb3ZpZGVkIHN1Y2ggYSBtYXBwaW5nIGV4aXN0cy5cbiAgICB2YXIgbmVlZGxlID0ge1xuICAgICAgc291cmNlOiB1dGlsLmdldEFyZyhhQXJncywgJ3NvdXJjZScpLFxuICAgICAgb3JpZ2luYWxMaW5lOiBsaW5lLFxuICAgICAgb3JpZ2luYWxDb2x1bW46IHV0aWwuZ2V0QXJnKGFBcmdzLCAnY29sdW1uJywgMClcbiAgICB9O1xuXG4gICAgbmVlZGxlLnNvdXJjZSA9IHRoaXMuX2ZpbmRTb3VyY2VJbmRleChuZWVkbGUuc291cmNlKTtcbiAgICBpZiAobmVlZGxlLnNvdXJjZSA8IDApIHtcbiAgICAgIHJldHVybiBbXTtcbiAgICB9XG5cbiAgICB2YXIgbWFwcGluZ3MgPSBbXTtcblxuICAgIHZhciBpbmRleCA9IHRoaXMuX2ZpbmRNYXBwaW5nKG5lZWRsZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9vcmlnaW5hbE1hcHBpbmdzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwib3JpZ2luYWxMaW5lXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJvcmlnaW5hbENvbHVtblwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHV0aWwuY29tcGFyZUJ5T3JpZ2luYWxQb3NpdGlvbnMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYmluYXJ5U2VhcmNoLkxFQVNUX1VQUEVSX0JPVU5EKTtcbiAgICBpZiAoaW5kZXggPj0gMCkge1xuICAgICAgdmFyIG1hcHBpbmcgPSB0aGlzLl9vcmlnaW5hbE1hcHBpbmdzW2luZGV4XTtcblxuICAgICAgaWYgKGFBcmdzLmNvbHVtbiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHZhciBvcmlnaW5hbExpbmUgPSBtYXBwaW5nLm9yaWdpbmFsTGluZTtcblxuICAgICAgICAvLyBJdGVyYXRlIHVudGlsIGVpdGhlciB3ZSBydW4gb3V0IG9mIG1hcHBpbmdzLCBvciB3ZSBydW4gaW50b1xuICAgICAgICAvLyBhIG1hcHBpbmcgZm9yIGEgZGlmZmVyZW50IGxpbmUgdGhhbiB0aGUgb25lIHdlIGZvdW5kLiBTaW5jZVxuICAgICAgICAvLyBtYXBwaW5ncyBhcmUgc29ydGVkLCB0aGlzIGlzIGd1YXJhbnRlZWQgdG8gZmluZCBhbGwgbWFwcGluZ3MgZm9yXG4gICAgICAgIC8vIHRoZSBsaW5lIHdlIGZvdW5kLlxuICAgICAgICB3aGlsZSAobWFwcGluZyAmJiBtYXBwaW5nLm9yaWdpbmFsTGluZSA9PT0gb3JpZ2luYWxMaW5lKSB7XG4gICAgICAgICAgbWFwcGluZ3MucHVzaCh7XG4gICAgICAgICAgICBsaW5lOiB1dGlsLmdldEFyZyhtYXBwaW5nLCAnZ2VuZXJhdGVkTGluZScsIG51bGwpLFxuICAgICAgICAgICAgY29sdW1uOiB1dGlsLmdldEFyZyhtYXBwaW5nLCAnZ2VuZXJhdGVkQ29sdW1uJywgbnVsbCksXG4gICAgICAgICAgICBsYXN0Q29sdW1uOiB1dGlsLmdldEFyZyhtYXBwaW5nLCAnbGFzdEdlbmVyYXRlZENvbHVtbicsIG51bGwpXG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICBtYXBwaW5nID0gdGhpcy5fb3JpZ2luYWxNYXBwaW5nc1srK2luZGV4XTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIG9yaWdpbmFsQ29sdW1uID0gbWFwcGluZy5vcmlnaW5hbENvbHVtbjtcblxuICAgICAgICAvLyBJdGVyYXRlIHVudGlsIGVpdGhlciB3ZSBydW4gb3V0IG9mIG1hcHBpbmdzLCBvciB3ZSBydW4gaW50b1xuICAgICAgICAvLyBhIG1hcHBpbmcgZm9yIGEgZGlmZmVyZW50IGxpbmUgdGhhbiB0aGUgb25lIHdlIHdlcmUgc2VhcmNoaW5nIGZvci5cbiAgICAgICAgLy8gU2luY2UgbWFwcGluZ3MgYXJlIHNvcnRlZCwgdGhpcyBpcyBndWFyYW50ZWVkIHRvIGZpbmQgYWxsIG1hcHBpbmdzIGZvclxuICAgICAgICAvLyB0aGUgbGluZSB3ZSBhcmUgc2VhcmNoaW5nIGZvci5cbiAgICAgICAgd2hpbGUgKG1hcHBpbmcgJiZcbiAgICAgICAgICAgICAgIG1hcHBpbmcub3JpZ2luYWxMaW5lID09PSBsaW5lICYmXG4gICAgICAgICAgICAgICBtYXBwaW5nLm9yaWdpbmFsQ29sdW1uID09IG9yaWdpbmFsQ29sdW1uKSB7XG4gICAgICAgICAgbWFwcGluZ3MucHVzaCh7XG4gICAgICAgICAgICBsaW5lOiB1dGlsLmdldEFyZyhtYXBwaW5nLCAnZ2VuZXJhdGVkTGluZScsIG51bGwpLFxuICAgICAgICAgICAgY29sdW1uOiB1dGlsLmdldEFyZyhtYXBwaW5nLCAnZ2VuZXJhdGVkQ29sdW1uJywgbnVsbCksXG4gICAgICAgICAgICBsYXN0Q29sdW1uOiB1dGlsLmdldEFyZyhtYXBwaW5nLCAnbGFzdEdlbmVyYXRlZENvbHVtbicsIG51bGwpXG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICBtYXBwaW5nID0gdGhpcy5fb3JpZ2luYWxNYXBwaW5nc1srK2luZGV4XTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBtYXBwaW5ncztcbiAgfTtcblxuZXhwb3J0cy5Tb3VyY2VNYXBDb25zdW1lciA9IFNvdXJjZU1hcENvbnN1bWVyO1xuXG4vKipcbiAqIEEgQmFzaWNTb3VyY2VNYXBDb25zdW1lciBpbnN0YW5jZSByZXByZXNlbnRzIGEgcGFyc2VkIHNvdXJjZSBtYXAgd2hpY2ggd2UgY2FuXG4gKiBxdWVyeSBmb3IgaW5mb3JtYXRpb24gYWJvdXQgdGhlIG9yaWdpbmFsIGZpbGUgcG9zaXRpb25zIGJ5IGdpdmluZyBpdCBhIGZpbGVcbiAqIHBvc2l0aW9uIGluIHRoZSBnZW5lcmF0ZWQgc291cmNlLlxuICpcbiAqIFRoZSBmaXJzdCBwYXJhbWV0ZXIgaXMgdGhlIHJhdyBzb3VyY2UgbWFwIChlaXRoZXIgYXMgYSBKU09OIHN0cmluZywgb3JcbiAqIGFscmVhZHkgcGFyc2VkIHRvIGFuIG9iamVjdCkuIEFjY29yZGluZyB0byB0aGUgc3BlYywgc291cmNlIG1hcHMgaGF2ZSB0aGVcbiAqIGZvbGxvd2luZyBhdHRyaWJ1dGVzOlxuICpcbiAqICAgLSB2ZXJzaW9uOiBXaGljaCB2ZXJzaW9uIG9mIHRoZSBzb3VyY2UgbWFwIHNwZWMgdGhpcyBtYXAgaXMgZm9sbG93aW5nLlxuICogICAtIHNvdXJjZXM6IEFuIGFycmF5IG9mIFVSTHMgdG8gdGhlIG9yaWdpbmFsIHNvdXJjZSBmaWxlcy5cbiAqICAgLSBuYW1lczogQW4gYXJyYXkgb2YgaWRlbnRpZmllcnMgd2hpY2ggY2FuIGJlIHJlZmVycmVuY2VkIGJ5IGluZGl2aWR1YWwgbWFwcGluZ3MuXG4gKiAgIC0gc291cmNlUm9vdDogT3B0aW9uYWwuIFRoZSBVUkwgcm9vdCBmcm9tIHdoaWNoIGFsbCBzb3VyY2VzIGFyZSByZWxhdGl2ZS5cbiAqICAgLSBzb3VyY2VzQ29udGVudDogT3B0aW9uYWwuIEFuIGFycmF5IG9mIGNvbnRlbnRzIG9mIHRoZSBvcmlnaW5hbCBzb3VyY2UgZmlsZXMuXG4gKiAgIC0gbWFwcGluZ3M6IEEgc3RyaW5nIG9mIGJhc2U2NCBWTFFzIHdoaWNoIGNvbnRhaW4gdGhlIGFjdHVhbCBtYXBwaW5ncy5cbiAqICAgLSBmaWxlOiBPcHRpb25hbC4gVGhlIGdlbmVyYXRlZCBmaWxlIHRoaXMgc291cmNlIG1hcCBpcyBhc3NvY2lhdGVkIHdpdGguXG4gKlxuICogSGVyZSBpcyBhbiBleGFtcGxlIHNvdXJjZSBtYXAsIHRha2VuIGZyb20gdGhlIHNvdXJjZSBtYXAgc3BlY1swXTpcbiAqXG4gKiAgICAge1xuICogICAgICAgdmVyc2lvbiA6IDMsXG4gKiAgICAgICBmaWxlOiBcIm91dC5qc1wiLFxuICogICAgICAgc291cmNlUm9vdCA6IFwiXCIsXG4gKiAgICAgICBzb3VyY2VzOiBbXCJmb28uanNcIiwgXCJiYXIuanNcIl0sXG4gKiAgICAgICBuYW1lczogW1wic3JjXCIsIFwibWFwc1wiLCBcImFyZVwiLCBcImZ1blwiXSxcbiAqICAgICAgIG1hcHBpbmdzOiBcIkFBLEFCOztBQkNERTtcIlxuICogICAgIH1cbiAqXG4gKiBUaGUgc2Vjb25kIHBhcmFtZXRlciwgaWYgZ2l2ZW4sIGlzIGEgc3RyaW5nIHdob3NlIHZhbHVlIGlzIHRoZSBVUkxcbiAqIGF0IHdoaWNoIHRoZSBzb3VyY2UgbWFwIHdhcyBmb3VuZC4gIFRoaXMgVVJMIGlzIHVzZWQgdG8gY29tcHV0ZSB0aGVcbiAqIHNvdXJjZXMgYXJyYXkuXG4gKlxuICogWzBdOiBodHRwczovL2RvY3MuZ29vZ2xlLmNvbS9kb2N1bWVudC9kLzFVMVJHQWVoUXdSeXBVVG92RjFLUmxwaU9GemUwYi1fMmdjNmZBSDBLWTBrL2VkaXQ/cGxpPTEjXG4gKi9cbmZ1bmN0aW9uIEJhc2ljU291cmNlTWFwQ29uc3VtZXIoYVNvdXJjZU1hcCwgYVNvdXJjZU1hcFVSTCkge1xuICB2YXIgc291cmNlTWFwID0gYVNvdXJjZU1hcDtcbiAgaWYgKHR5cGVvZiBhU291cmNlTWFwID09PSAnc3RyaW5nJykge1xuICAgIHNvdXJjZU1hcCA9IHV0aWwucGFyc2VTb3VyY2VNYXBJbnB1dChhU291cmNlTWFwKTtcbiAgfVxuXG4gIHZhciB2ZXJzaW9uID0gdXRpbC5nZXRBcmcoc291cmNlTWFwLCAndmVyc2lvbicpO1xuICB2YXIgc291cmNlcyA9IHV0aWwuZ2V0QXJnKHNvdXJjZU1hcCwgJ3NvdXJjZXMnKTtcbiAgLy8gU2FzcyAzLjMgbGVhdmVzIG91dCB0aGUgJ25hbWVzJyBhcnJheSwgc28gd2UgZGV2aWF0ZSBmcm9tIHRoZSBzcGVjICh3aGljaFxuICAvLyByZXF1aXJlcyB0aGUgYXJyYXkpIHRvIHBsYXkgbmljZSBoZXJlLlxuICB2YXIgbmFtZXMgPSB1dGlsLmdldEFyZyhzb3VyY2VNYXAsICduYW1lcycsIFtdKTtcbiAgdmFyIHNvdXJjZVJvb3QgPSB1dGlsLmdldEFyZyhzb3VyY2VNYXAsICdzb3VyY2VSb290JywgbnVsbCk7XG4gIHZhciBzb3VyY2VzQ29udGVudCA9IHV0aWwuZ2V0QXJnKHNvdXJjZU1hcCwgJ3NvdXJjZXNDb250ZW50JywgbnVsbCk7XG4gIHZhciBtYXBwaW5ncyA9IHV0aWwuZ2V0QXJnKHNvdXJjZU1hcCwgJ21hcHBpbmdzJyk7XG4gIHZhciBmaWxlID0gdXRpbC5nZXRBcmcoc291cmNlTWFwLCAnZmlsZScsIG51bGwpO1xuXG4gIC8vIE9uY2UgYWdhaW4sIFNhc3MgZGV2aWF0ZXMgZnJvbSB0aGUgc3BlYyBhbmQgc3VwcGxpZXMgdGhlIHZlcnNpb24gYXMgYVxuICAvLyBzdHJpbmcgcmF0aGVyIHRoYW4gYSBudW1iZXIsIHNvIHdlIHVzZSBsb29zZSBlcXVhbGl0eSBjaGVja2luZyBoZXJlLlxuICBpZiAodmVyc2lvbiAhPSB0aGlzLl92ZXJzaW9uKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdVbnN1cHBvcnRlZCB2ZXJzaW9uOiAnICsgdmVyc2lvbik7XG4gIH1cblxuICBpZiAoc291cmNlUm9vdCkge1xuICAgIHNvdXJjZVJvb3QgPSB1dGlsLm5vcm1hbGl6ZShzb3VyY2VSb290KTtcbiAgfVxuXG4gIHNvdXJjZXMgPSBzb3VyY2VzXG4gICAgLm1hcChTdHJpbmcpXG4gICAgLy8gU29tZSBzb3VyY2UgbWFwcyBwcm9kdWNlIHJlbGF0aXZlIHNvdXJjZSBwYXRocyBsaWtlIFwiLi9mb28uanNcIiBpbnN0ZWFkIG9mXG4gICAgLy8gXCJmb28uanNcIi4gIE5vcm1hbGl6ZSB0aGVzZSBmaXJzdCBzbyB0aGF0IGZ1dHVyZSBjb21wYXJpc29ucyB3aWxsIHN1Y2NlZWQuXG4gICAgLy8gU2VlIGJ1Z3ppbC5sYS8xMDkwNzY4LlxuICAgIC5tYXAodXRpbC5ub3JtYWxpemUpXG4gICAgLy8gQWx3YXlzIGVuc3VyZSB0aGF0IGFic29sdXRlIHNvdXJjZXMgYXJlIGludGVybmFsbHkgc3RvcmVkIHJlbGF0aXZlIHRvXG4gICAgLy8gdGhlIHNvdXJjZSByb290LCBpZiB0aGUgc291cmNlIHJvb3QgaXMgYWJzb2x1dGUuIE5vdCBkb2luZyB0aGlzIHdvdWxkXG4gICAgLy8gYmUgcGFydGljdWxhcmx5IHByb2JsZW1hdGljIHdoZW4gdGhlIHNvdXJjZSByb290IGlzIGEgcHJlZml4IG9mIHRoZVxuICAgIC8vIHNvdXJjZSAodmFsaWQsIGJ1dCB3aHk/PykuIFNlZSBnaXRodWIgaXNzdWUgIzE5OSBhbmQgYnVnemlsLmxhLzExODg5ODIuXG4gICAgLm1hcChmdW5jdGlvbiAoc291cmNlKSB7XG4gICAgICByZXR1cm4gc291cmNlUm9vdCAmJiB1dGlsLmlzQWJzb2x1dGUoc291cmNlUm9vdCkgJiYgdXRpbC5pc0Fic29sdXRlKHNvdXJjZSlcbiAgICAgICAgPyB1dGlsLnJlbGF0aXZlKHNvdXJjZVJvb3QsIHNvdXJjZSlcbiAgICAgICAgOiBzb3VyY2U7XG4gICAgfSk7XG5cbiAgLy8gUGFzcyBgdHJ1ZWAgYmVsb3cgdG8gYWxsb3cgZHVwbGljYXRlIG5hbWVzIGFuZCBzb3VyY2VzLiBXaGlsZSBzb3VyY2UgbWFwc1xuICAvLyBhcmUgaW50ZW5kZWQgdG8gYmUgY29tcHJlc3NlZCBhbmQgZGVkdXBsaWNhdGVkLCB0aGUgVHlwZVNjcmlwdCBjb21waWxlclxuICAvLyBzb21ldGltZXMgZ2VuZXJhdGVzIHNvdXJjZSBtYXBzIHdpdGggZHVwbGljYXRlcyBpbiB0aGVtLiBTZWUgR2l0aHViIGlzc3VlXG4gIC8vICM3MiBhbmQgYnVnemlsLmxhLzg4OTQ5Mi5cbiAgdGhpcy5fbmFtZXMgPSBBcnJheVNldC5mcm9tQXJyYXkobmFtZXMubWFwKFN0cmluZyksIHRydWUpO1xuICB0aGlzLl9zb3VyY2VzID0gQXJyYXlTZXQuZnJvbUFycmF5KHNvdXJjZXMsIHRydWUpO1xuXG4gIHRoaXMuX2Fic29sdXRlU291cmNlcyA9IHRoaXMuX3NvdXJjZXMudG9BcnJheSgpLm1hcChmdW5jdGlvbiAocykge1xuICAgIHJldHVybiB1dGlsLmNvbXB1dGVTb3VyY2VVUkwoc291cmNlUm9vdCwgcywgYVNvdXJjZU1hcFVSTCk7XG4gIH0pO1xuXG4gIHRoaXMuc291cmNlUm9vdCA9IHNvdXJjZVJvb3Q7XG4gIHRoaXMuc291cmNlc0NvbnRlbnQgPSBzb3VyY2VzQ29udGVudDtcbiAgdGhpcy5fbWFwcGluZ3MgPSBtYXBwaW5ncztcbiAgdGhpcy5fc291cmNlTWFwVVJMID0gYVNvdXJjZU1hcFVSTDtcbiAgdGhpcy5maWxlID0gZmlsZTtcbn1cblxuQmFzaWNTb3VyY2VNYXBDb25zdW1lci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKFNvdXJjZU1hcENvbnN1bWVyLnByb3RvdHlwZSk7XG5CYXNpY1NvdXJjZU1hcENvbnN1bWVyLnByb3RvdHlwZS5jb25zdW1lciA9IFNvdXJjZU1hcENvbnN1bWVyO1xuXG4vKipcbiAqIFV0aWxpdHkgZnVuY3Rpb24gdG8gZmluZCB0aGUgaW5kZXggb2YgYSBzb3VyY2UuICBSZXR1cm5zIC0xIGlmIG5vdFxuICogZm91bmQuXG4gKi9cbkJhc2ljU291cmNlTWFwQ29uc3VtZXIucHJvdG90eXBlLl9maW5kU291cmNlSW5kZXggPSBmdW5jdGlvbihhU291cmNlKSB7XG4gIHZhciByZWxhdGl2ZVNvdXJjZSA9IGFTb3VyY2U7XG4gIGlmICh0aGlzLnNvdXJjZVJvb3QgIT0gbnVsbCkge1xuICAgIHJlbGF0aXZlU291cmNlID0gdXRpbC5yZWxhdGl2ZSh0aGlzLnNvdXJjZVJvb3QsIHJlbGF0aXZlU291cmNlKTtcbiAgfVxuXG4gIGlmICh0aGlzLl9zb3VyY2VzLmhhcyhyZWxhdGl2ZVNvdXJjZSkpIHtcbiAgICByZXR1cm4gdGhpcy5fc291cmNlcy5pbmRleE9mKHJlbGF0aXZlU291cmNlKTtcbiAgfVxuXG4gIC8vIE1heWJlIGFTb3VyY2UgaXMgYW4gYWJzb2x1dGUgVVJMIGFzIHJldHVybmVkIGJ5IHxzb3VyY2VzfC4gIEluXG4gIC8vIHRoaXMgY2FzZSB3ZSBjYW4ndCBzaW1wbHkgdW5kbyB0aGUgdHJhbnNmb3JtLlxuICB2YXIgaTtcbiAgZm9yIChpID0gMDsgaSA8IHRoaXMuX2Fic29sdXRlU291cmNlcy5sZW5ndGg7ICsraSkge1xuICAgIGlmICh0aGlzLl9hYnNvbHV0ZVNvdXJjZXNbaV0gPT0gYVNvdXJjZSkge1xuICAgICAgcmV0dXJuIGk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIC0xO1xufTtcblxuLyoqXG4gKiBDcmVhdGUgYSBCYXNpY1NvdXJjZU1hcENvbnN1bWVyIGZyb20gYSBTb3VyY2VNYXBHZW5lcmF0b3IuXG4gKlxuICogQHBhcmFtIFNvdXJjZU1hcEdlbmVyYXRvciBhU291cmNlTWFwXG4gKiAgICAgICAgVGhlIHNvdXJjZSBtYXAgdGhhdCB3aWxsIGJlIGNvbnN1bWVkLlxuICogQHBhcmFtIFN0cmluZyBhU291cmNlTWFwVVJMXG4gKiAgICAgICAgVGhlIFVSTCBhdCB3aGljaCB0aGUgc291cmNlIG1hcCBjYW4gYmUgZm91bmQgKG9wdGlvbmFsKVxuICogQHJldHVybnMgQmFzaWNTb3VyY2VNYXBDb25zdW1lclxuICovXG5CYXNpY1NvdXJjZU1hcENvbnN1bWVyLmZyb21Tb3VyY2VNYXAgPVxuICBmdW5jdGlvbiBTb3VyY2VNYXBDb25zdW1lcl9mcm9tU291cmNlTWFwKGFTb3VyY2VNYXAsIGFTb3VyY2VNYXBVUkwpIHtcbiAgICB2YXIgc21jID0gT2JqZWN0LmNyZWF0ZShCYXNpY1NvdXJjZU1hcENvbnN1bWVyLnByb3RvdHlwZSk7XG5cbiAgICB2YXIgbmFtZXMgPSBzbWMuX25hbWVzID0gQXJyYXlTZXQuZnJvbUFycmF5KGFTb3VyY2VNYXAuX25hbWVzLnRvQXJyYXkoKSwgdHJ1ZSk7XG4gICAgdmFyIHNvdXJjZXMgPSBzbWMuX3NvdXJjZXMgPSBBcnJheVNldC5mcm9tQXJyYXkoYVNvdXJjZU1hcC5fc291cmNlcy50b0FycmF5KCksIHRydWUpO1xuICAgIHNtYy5zb3VyY2VSb290ID0gYVNvdXJjZU1hcC5fc291cmNlUm9vdDtcbiAgICBzbWMuc291cmNlc0NvbnRlbnQgPSBhU291cmNlTWFwLl9nZW5lcmF0ZVNvdXJjZXNDb250ZW50KHNtYy5fc291cmNlcy50b0FycmF5KCksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzbWMuc291cmNlUm9vdCk7XG4gICAgc21jLmZpbGUgPSBhU291cmNlTWFwLl9maWxlO1xuICAgIHNtYy5fc291cmNlTWFwVVJMID0gYVNvdXJjZU1hcFVSTDtcbiAgICBzbWMuX2Fic29sdXRlU291cmNlcyA9IHNtYy5fc291cmNlcy50b0FycmF5KCkubWFwKGZ1bmN0aW9uIChzKSB7XG4gICAgICByZXR1cm4gdXRpbC5jb21wdXRlU291cmNlVVJMKHNtYy5zb3VyY2VSb290LCBzLCBhU291cmNlTWFwVVJMKTtcbiAgICB9KTtcblxuICAgIC8vIEJlY2F1c2Ugd2UgYXJlIG1vZGlmeWluZyB0aGUgZW50cmllcyAoYnkgY29udmVydGluZyBzdHJpbmcgc291cmNlcyBhbmRcbiAgICAvLyBuYW1lcyB0byBpbmRpY2VzIGludG8gdGhlIHNvdXJjZXMgYW5kIG5hbWVzIEFycmF5U2V0cyksIHdlIGhhdmUgdG8gbWFrZVxuICAgIC8vIGEgY29weSBvZiB0aGUgZW50cnkgb3IgZWxzZSBiYWQgdGhpbmdzIGhhcHBlbi4gU2hhcmVkIG11dGFibGUgc3RhdGVcbiAgICAvLyBzdHJpa2VzIGFnYWluISBTZWUgZ2l0aHViIGlzc3VlICMxOTEuXG5cbiAgICB2YXIgZ2VuZXJhdGVkTWFwcGluZ3MgPSBhU291cmNlTWFwLl9tYXBwaW5ncy50b0FycmF5KCkuc2xpY2UoKTtcbiAgICB2YXIgZGVzdEdlbmVyYXRlZE1hcHBpbmdzID0gc21jLl9fZ2VuZXJhdGVkTWFwcGluZ3MgPSBbXTtcbiAgICB2YXIgZGVzdE9yaWdpbmFsTWFwcGluZ3MgPSBzbWMuX19vcmlnaW5hbE1hcHBpbmdzID0gW107XG5cbiAgICBmb3IgKHZhciBpID0gMCwgbGVuZ3RoID0gZ2VuZXJhdGVkTWFwcGluZ3MubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBzcmNNYXBwaW5nID0gZ2VuZXJhdGVkTWFwcGluZ3NbaV07XG4gICAgICB2YXIgZGVzdE1hcHBpbmcgPSBuZXcgTWFwcGluZztcbiAgICAgIGRlc3RNYXBwaW5nLmdlbmVyYXRlZExpbmUgPSBzcmNNYXBwaW5nLmdlbmVyYXRlZExpbmU7XG4gICAgICBkZXN0TWFwcGluZy5nZW5lcmF0ZWRDb2x1bW4gPSBzcmNNYXBwaW5nLmdlbmVyYXRlZENvbHVtbjtcblxuICAgICAgaWYgKHNyY01hcHBpbmcuc291cmNlKSB7XG4gICAgICAgIGRlc3RNYXBwaW5nLnNvdXJjZSA9IHNvdXJjZXMuaW5kZXhPZihzcmNNYXBwaW5nLnNvdXJjZSk7XG4gICAgICAgIGRlc3RNYXBwaW5nLm9yaWdpbmFsTGluZSA9IHNyY01hcHBpbmcub3JpZ2luYWxMaW5lO1xuICAgICAgICBkZXN0TWFwcGluZy5vcmlnaW5hbENvbHVtbiA9IHNyY01hcHBpbmcub3JpZ2luYWxDb2x1bW47XG5cbiAgICAgICAgaWYgKHNyY01hcHBpbmcubmFtZSkge1xuICAgICAgICAgIGRlc3RNYXBwaW5nLm5hbWUgPSBuYW1lcy5pbmRleE9mKHNyY01hcHBpbmcubmFtZSk7XG4gICAgICAgIH1cblxuICAgICAgICBkZXN0T3JpZ2luYWxNYXBwaW5ncy5wdXNoKGRlc3RNYXBwaW5nKTtcbiAgICAgIH1cblxuICAgICAgZGVzdEdlbmVyYXRlZE1hcHBpbmdzLnB1c2goZGVzdE1hcHBpbmcpO1xuICAgIH1cblxuICAgIHF1aWNrU29ydChzbWMuX19vcmlnaW5hbE1hcHBpbmdzLCB1dGlsLmNvbXBhcmVCeU9yaWdpbmFsUG9zaXRpb25zKTtcblxuICAgIHJldHVybiBzbWM7XG4gIH07XG5cbi8qKlxuICogVGhlIHZlcnNpb24gb2YgdGhlIHNvdXJjZSBtYXBwaW5nIHNwZWMgdGhhdCB3ZSBhcmUgY29uc3VtaW5nLlxuICovXG5CYXNpY1NvdXJjZU1hcENvbnN1bWVyLnByb3RvdHlwZS5fdmVyc2lvbiA9IDM7XG5cbi8qKlxuICogVGhlIGxpc3Qgb2Ygb3JpZ2luYWwgc291cmNlcy5cbiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KEJhc2ljU291cmNlTWFwQ29uc3VtZXIucHJvdG90eXBlLCAnc291cmNlcycsIHtcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2Fic29sdXRlU291cmNlcy5zbGljZSgpO1xuICB9XG59KTtcblxuLyoqXG4gKiBQcm92aWRlIHRoZSBKSVQgd2l0aCBhIG5pY2Ugc2hhcGUgLyBoaWRkZW4gY2xhc3MuXG4gKi9cbmZ1bmN0aW9uIE1hcHBpbmcoKSB7XG4gIHRoaXMuZ2VuZXJhdGVkTGluZSA9IDA7XG4gIHRoaXMuZ2VuZXJhdGVkQ29sdW1uID0gMDtcbiAgdGhpcy5zb3VyY2UgPSBudWxsO1xuICB0aGlzLm9yaWdpbmFsTGluZSA9IG51bGw7XG4gIHRoaXMub3JpZ2luYWxDb2x1bW4gPSBudWxsO1xuICB0aGlzLm5hbWUgPSBudWxsO1xufVxuXG4vKipcbiAqIFBhcnNlIHRoZSBtYXBwaW5ncyBpbiBhIHN0cmluZyBpbiB0byBhIGRhdGEgc3RydWN0dXJlIHdoaWNoIHdlIGNhbiBlYXNpbHlcbiAqIHF1ZXJ5ICh0aGUgb3JkZXJlZCBhcnJheXMgaW4gdGhlIGB0aGlzLl9fZ2VuZXJhdGVkTWFwcGluZ3NgIGFuZFxuICogYHRoaXMuX19vcmlnaW5hbE1hcHBpbmdzYCBwcm9wZXJ0aWVzKS5cbiAqL1xuQmFzaWNTb3VyY2VNYXBDb25zdW1lci5wcm90b3R5cGUuX3BhcnNlTWFwcGluZ3MgPVxuICBmdW5jdGlvbiBTb3VyY2VNYXBDb25zdW1lcl9wYXJzZU1hcHBpbmdzKGFTdHIsIGFTb3VyY2VSb290KSB7XG4gICAgdmFyIGdlbmVyYXRlZExpbmUgPSAxO1xuICAgIHZhciBwcmV2aW91c0dlbmVyYXRlZENvbHVtbiA9IDA7XG4gICAgdmFyIHByZXZpb3VzT3JpZ2luYWxMaW5lID0gMDtcbiAgICB2YXIgcHJldmlvdXNPcmlnaW5hbENvbHVtbiA9IDA7XG4gICAgdmFyIHByZXZpb3VzU291cmNlID0gMDtcbiAgICB2YXIgcHJldmlvdXNOYW1lID0gMDtcbiAgICB2YXIgbGVuZ3RoID0gYVN0ci5sZW5ndGg7XG4gICAgdmFyIGluZGV4ID0gMDtcbiAgICB2YXIgY2FjaGVkU2VnbWVudHMgPSB7fTtcbiAgICB2YXIgdGVtcCA9IHt9O1xuICAgIHZhciBvcmlnaW5hbE1hcHBpbmdzID0gW107XG4gICAgdmFyIGdlbmVyYXRlZE1hcHBpbmdzID0gW107XG4gICAgdmFyIG1hcHBpbmcsIHN0ciwgc2VnbWVudCwgZW5kLCB2YWx1ZTtcblxuICAgIHdoaWxlIChpbmRleCA8IGxlbmd0aCkge1xuICAgICAgaWYgKGFTdHIuY2hhckF0KGluZGV4KSA9PT0gJzsnKSB7XG4gICAgICAgIGdlbmVyYXRlZExpbmUrKztcbiAgICAgICAgaW5kZXgrKztcbiAgICAgICAgcHJldmlvdXNHZW5lcmF0ZWRDb2x1bW4gPSAwO1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAoYVN0ci5jaGFyQXQoaW5kZXgpID09PSAnLCcpIHtcbiAgICAgICAgaW5kZXgrKztcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICBtYXBwaW5nID0gbmV3IE1hcHBpbmcoKTtcbiAgICAgICAgbWFwcGluZy5nZW5lcmF0ZWRMaW5lID0gZ2VuZXJhdGVkTGluZTtcblxuICAgICAgICAvLyBCZWNhdXNlIGVhY2ggb2Zmc2V0IGlzIGVuY29kZWQgcmVsYXRpdmUgdG8gdGhlIHByZXZpb3VzIG9uZSxcbiAgICAgICAgLy8gbWFueSBzZWdtZW50cyBvZnRlbiBoYXZlIHRoZSBzYW1lIGVuY29kaW5nLiBXZSBjYW4gZXhwbG9pdCB0aGlzXG4gICAgICAgIC8vIGZhY3QgYnkgY2FjaGluZyB0aGUgcGFyc2VkIHZhcmlhYmxlIGxlbmd0aCBmaWVsZHMgb2YgZWFjaCBzZWdtZW50LFxuICAgICAgICAvLyBhbGxvd2luZyB1cyB0byBhdm9pZCBhIHNlY29uZCBwYXJzZSBpZiB3ZSBlbmNvdW50ZXIgdGhlIHNhbWVcbiAgICAgICAgLy8gc2VnbWVudCBhZ2Fpbi5cbiAgICAgICAgZm9yIChlbmQgPSBpbmRleDsgZW5kIDwgbGVuZ3RoOyBlbmQrKykge1xuICAgICAgICAgIGlmICh0aGlzLl9jaGFySXNNYXBwaW5nU2VwYXJhdG9yKGFTdHIsIGVuZCkpIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBzdHIgPSBhU3RyLnNsaWNlKGluZGV4LCBlbmQpO1xuXG4gICAgICAgIHNlZ21lbnQgPSBjYWNoZWRTZWdtZW50c1tzdHJdO1xuICAgICAgICBpZiAoc2VnbWVudCkge1xuICAgICAgICAgIGluZGV4ICs9IHN0ci5sZW5ndGg7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc2VnbWVudCA9IFtdO1xuICAgICAgICAgIHdoaWxlIChpbmRleCA8IGVuZCkge1xuICAgICAgICAgICAgYmFzZTY0VkxRLmRlY29kZShhU3RyLCBpbmRleCwgdGVtcCk7XG4gICAgICAgICAgICB2YWx1ZSA9IHRlbXAudmFsdWU7XG4gICAgICAgICAgICBpbmRleCA9IHRlbXAucmVzdDtcbiAgICAgICAgICAgIHNlZ21lbnQucHVzaCh2YWx1ZSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKHNlZ21lbnQubGVuZ3RoID09PSAyKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ZvdW5kIGEgc291cmNlLCBidXQgbm8gbGluZSBhbmQgY29sdW1uJyk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKHNlZ21lbnQubGVuZ3RoID09PSAzKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ZvdW5kIGEgc291cmNlIGFuZCBsaW5lLCBidXQgbm8gY29sdW1uJyk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY2FjaGVkU2VnbWVudHNbc3RyXSA9IHNlZ21lbnQ7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBHZW5lcmF0ZWQgY29sdW1uLlxuICAgICAgICBtYXBwaW5nLmdlbmVyYXRlZENvbHVtbiA9IHByZXZpb3VzR2VuZXJhdGVkQ29sdW1uICsgc2VnbWVudFswXTtcbiAgICAgICAgcHJldmlvdXNHZW5lcmF0ZWRDb2x1bW4gPSBtYXBwaW5nLmdlbmVyYXRlZENvbHVtbjtcblxuICAgICAgICBpZiAoc2VnbWVudC5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgLy8gT3JpZ2luYWwgc291cmNlLlxuICAgICAgICAgIG1hcHBpbmcuc291cmNlID0gcHJldmlvdXNTb3VyY2UgKyBzZWdtZW50WzFdO1xuICAgICAgICAgIHByZXZpb3VzU291cmNlICs9IHNlZ21lbnRbMV07XG5cbiAgICAgICAgICAvLyBPcmlnaW5hbCBsaW5lLlxuICAgICAgICAgIG1hcHBpbmcub3JpZ2luYWxMaW5lID0gcHJldmlvdXNPcmlnaW5hbExpbmUgKyBzZWdtZW50WzJdO1xuICAgICAgICAgIHByZXZpb3VzT3JpZ2luYWxMaW5lID0gbWFwcGluZy5vcmlnaW5hbExpbmU7XG4gICAgICAgICAgLy8gTGluZXMgYXJlIHN0b3JlZCAwLWJhc2VkXG4gICAgICAgICAgbWFwcGluZy5vcmlnaW5hbExpbmUgKz0gMTtcblxuICAgICAgICAgIC8vIE9yaWdpbmFsIGNvbHVtbi5cbiAgICAgICAgICBtYXBwaW5nLm9yaWdpbmFsQ29sdW1uID0gcHJldmlvdXNPcmlnaW5hbENvbHVtbiArIHNlZ21lbnRbM107XG4gICAgICAgICAgcHJldmlvdXNPcmlnaW5hbENvbHVtbiA9IG1hcHBpbmcub3JpZ2luYWxDb2x1bW47XG5cbiAgICAgICAgICBpZiAoc2VnbWVudC5sZW5ndGggPiA0KSB7XG4gICAgICAgICAgICAvLyBPcmlnaW5hbCBuYW1lLlxuICAgICAgICAgICAgbWFwcGluZy5uYW1lID0gcHJldmlvdXNOYW1lICsgc2VnbWVudFs0XTtcbiAgICAgICAgICAgIHByZXZpb3VzTmFtZSArPSBzZWdtZW50WzRdO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGdlbmVyYXRlZE1hcHBpbmdzLnB1c2gobWFwcGluZyk7XG4gICAgICAgIGlmICh0eXBlb2YgbWFwcGluZy5vcmlnaW5hbExpbmUgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgb3JpZ2luYWxNYXBwaW5ncy5wdXNoKG1hcHBpbmcpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcXVpY2tTb3J0KGdlbmVyYXRlZE1hcHBpbmdzLCB1dGlsLmNvbXBhcmVCeUdlbmVyYXRlZFBvc2l0aW9uc0RlZmxhdGVkKTtcbiAgICB0aGlzLl9fZ2VuZXJhdGVkTWFwcGluZ3MgPSBnZW5lcmF0ZWRNYXBwaW5ncztcblxuICAgIHF1aWNrU29ydChvcmlnaW5hbE1hcHBpbmdzLCB1dGlsLmNvbXBhcmVCeU9yaWdpbmFsUG9zaXRpb25zKTtcbiAgICB0aGlzLl9fb3JpZ2luYWxNYXBwaW5ncyA9IG9yaWdpbmFsTWFwcGluZ3M7XG4gIH07XG5cbi8qKlxuICogRmluZCB0aGUgbWFwcGluZyB0aGF0IGJlc3QgbWF0Y2hlcyB0aGUgaHlwb3RoZXRpY2FsIFwibmVlZGxlXCIgbWFwcGluZyB0aGF0XG4gKiB3ZSBhcmUgc2VhcmNoaW5nIGZvciBpbiB0aGUgZ2l2ZW4gXCJoYXlzdGFja1wiIG9mIG1hcHBpbmdzLlxuICovXG5CYXNpY1NvdXJjZU1hcENvbnN1bWVyLnByb3RvdHlwZS5fZmluZE1hcHBpbmcgPVxuICBmdW5jdGlvbiBTb3VyY2VNYXBDb25zdW1lcl9maW5kTWFwcGluZyhhTmVlZGxlLCBhTWFwcGluZ3MsIGFMaW5lTmFtZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYUNvbHVtbk5hbWUsIGFDb21wYXJhdG9yLCBhQmlhcykge1xuICAgIC8vIFRvIHJldHVybiB0aGUgcG9zaXRpb24gd2UgYXJlIHNlYXJjaGluZyBmb3IsIHdlIG11c3QgZmlyc3QgZmluZCB0aGVcbiAgICAvLyBtYXBwaW5nIGZvciB0aGUgZ2l2ZW4gcG9zaXRpb24gYW5kIHRoZW4gcmV0dXJuIHRoZSBvcHBvc2l0ZSBwb3NpdGlvbiBpdFxuICAgIC8vIHBvaW50cyB0by4gQmVjYXVzZSB0aGUgbWFwcGluZ3MgYXJlIHNvcnRlZCwgd2UgY2FuIHVzZSBiaW5hcnkgc2VhcmNoIHRvXG4gICAgLy8gZmluZCB0aGUgYmVzdCBtYXBwaW5nLlxuXG4gICAgaWYgKGFOZWVkbGVbYUxpbmVOYW1lXSA8PSAwKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdMaW5lIG11c3QgYmUgZ3JlYXRlciB0aGFuIG9yIGVxdWFsIHRvIDEsIGdvdCAnXG4gICAgICAgICAgICAgICAgICAgICAgICAgICsgYU5lZWRsZVthTGluZU5hbWVdKTtcbiAgICB9XG4gICAgaWYgKGFOZWVkbGVbYUNvbHVtbk5hbWVdIDwgMCkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQ29sdW1uIG11c3QgYmUgZ3JlYXRlciB0aGFuIG9yIGVxdWFsIHRvIDAsIGdvdCAnXG4gICAgICAgICAgICAgICAgICAgICAgICAgICsgYU5lZWRsZVthQ29sdW1uTmFtZV0pO1xuICAgIH1cblxuICAgIHJldHVybiBiaW5hcnlTZWFyY2guc2VhcmNoKGFOZWVkbGUsIGFNYXBwaW5ncywgYUNvbXBhcmF0b3IsIGFCaWFzKTtcbiAgfTtcblxuLyoqXG4gKiBDb21wdXRlIHRoZSBsYXN0IGNvbHVtbiBmb3IgZWFjaCBnZW5lcmF0ZWQgbWFwcGluZy4gVGhlIGxhc3QgY29sdW1uIGlzXG4gKiBpbmNsdXNpdmUuXG4gKi9cbkJhc2ljU291cmNlTWFwQ29uc3VtZXIucHJvdG90eXBlLmNvbXB1dGVDb2x1bW5TcGFucyA9XG4gIGZ1bmN0aW9uIFNvdXJjZU1hcENvbnN1bWVyX2NvbXB1dGVDb2x1bW5TcGFucygpIHtcbiAgICBmb3IgKHZhciBpbmRleCA9IDA7IGluZGV4IDwgdGhpcy5fZ2VuZXJhdGVkTWFwcGluZ3MubGVuZ3RoOyArK2luZGV4KSB7XG4gICAgICB2YXIgbWFwcGluZyA9IHRoaXMuX2dlbmVyYXRlZE1hcHBpbmdzW2luZGV4XTtcblxuICAgICAgLy8gTWFwcGluZ3MgZG8gbm90IGNvbnRhaW4gYSBmaWVsZCBmb3IgdGhlIGxhc3QgZ2VuZXJhdGVkIGNvbHVtbnQuIFdlXG4gICAgICAvLyBjYW4gY29tZSB1cCB3aXRoIGFuIG9wdGltaXN0aWMgZXN0aW1hdGUsIGhvd2V2ZXIsIGJ5IGFzc3VtaW5nIHRoYXRcbiAgICAgIC8vIG1hcHBpbmdzIGFyZSBjb250aWd1b3VzIChpLmUuIGdpdmVuIHR3byBjb25zZWN1dGl2ZSBtYXBwaW5ncywgdGhlXG4gICAgICAvLyBmaXJzdCBtYXBwaW5nIGVuZHMgd2hlcmUgdGhlIHNlY29uZCBvbmUgc3RhcnRzKS5cbiAgICAgIGlmIChpbmRleCArIDEgPCB0aGlzLl9nZW5lcmF0ZWRNYXBwaW5ncy5sZW5ndGgpIHtcbiAgICAgICAgdmFyIG5leHRNYXBwaW5nID0gdGhpcy5fZ2VuZXJhdGVkTWFwcGluZ3NbaW5kZXggKyAxXTtcblxuICAgICAgICBpZiAobWFwcGluZy5nZW5lcmF0ZWRMaW5lID09PSBuZXh0TWFwcGluZy5nZW5lcmF0ZWRMaW5lKSB7XG4gICAgICAgICAgbWFwcGluZy5sYXN0R2VuZXJhdGVkQ29sdW1uID0gbmV4dE1hcHBpbmcuZ2VuZXJhdGVkQ29sdW1uIC0gMTtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBUaGUgbGFzdCBtYXBwaW5nIGZvciBlYWNoIGxpbmUgc3BhbnMgdGhlIGVudGlyZSBsaW5lLlxuICAgICAgbWFwcGluZy5sYXN0R2VuZXJhdGVkQ29sdW1uID0gSW5maW5pdHk7XG4gICAgfVxuICB9O1xuXG4vKipcbiAqIFJldHVybnMgdGhlIG9yaWdpbmFsIHNvdXJjZSwgbGluZSwgYW5kIGNvbHVtbiBpbmZvcm1hdGlvbiBmb3IgdGhlIGdlbmVyYXRlZFxuICogc291cmNlJ3MgbGluZSBhbmQgY29sdW1uIHBvc2l0aW9ucyBwcm92aWRlZC4gVGhlIG9ubHkgYXJndW1lbnQgaXMgYW4gb2JqZWN0XG4gKiB3aXRoIHRoZSBmb2xsb3dpbmcgcHJvcGVydGllczpcbiAqXG4gKiAgIC0gbGluZTogVGhlIGxpbmUgbnVtYmVyIGluIHRoZSBnZW5lcmF0ZWQgc291cmNlLiAgVGhlIGxpbmUgbnVtYmVyXG4gKiAgICAgaXMgMS1iYXNlZC5cbiAqICAgLSBjb2x1bW46IFRoZSBjb2x1bW4gbnVtYmVyIGluIHRoZSBnZW5lcmF0ZWQgc291cmNlLiAgVGhlIGNvbHVtblxuICogICAgIG51bWJlciBpcyAwLWJhc2VkLlxuICogICAtIGJpYXM6IEVpdGhlciAnU291cmNlTWFwQ29uc3VtZXIuR1JFQVRFU1RfTE9XRVJfQk9VTkQnIG9yXG4gKiAgICAgJ1NvdXJjZU1hcENvbnN1bWVyLkxFQVNUX1VQUEVSX0JPVU5EJy4gU3BlY2lmaWVzIHdoZXRoZXIgdG8gcmV0dXJuIHRoZVxuICogICAgIGNsb3Nlc3QgZWxlbWVudCB0aGF0IGlzIHNtYWxsZXIgdGhhbiBvciBncmVhdGVyIHRoYW4gdGhlIG9uZSB3ZSBhcmVcbiAqICAgICBzZWFyY2hpbmcgZm9yLCByZXNwZWN0aXZlbHksIGlmIHRoZSBleGFjdCBlbGVtZW50IGNhbm5vdCBiZSBmb3VuZC5cbiAqICAgICBEZWZhdWx0cyB0byAnU291cmNlTWFwQ29uc3VtZXIuR1JFQVRFU1RfTE9XRVJfQk9VTkQnLlxuICpcbiAqIGFuZCBhbiBvYmplY3QgaXMgcmV0dXJuZWQgd2l0aCB0aGUgZm9sbG93aW5nIHByb3BlcnRpZXM6XG4gKlxuICogICAtIHNvdXJjZTogVGhlIG9yaWdpbmFsIHNvdXJjZSBmaWxlLCBvciBudWxsLlxuICogICAtIGxpbmU6IFRoZSBsaW5lIG51bWJlciBpbiB0aGUgb3JpZ2luYWwgc291cmNlLCBvciBudWxsLiAgVGhlXG4gKiAgICAgbGluZSBudW1iZXIgaXMgMS1iYXNlZC5cbiAqICAgLSBjb2x1bW46IFRoZSBjb2x1bW4gbnVtYmVyIGluIHRoZSBvcmlnaW5hbCBzb3VyY2UsIG9yIG51bGwuICBUaGVcbiAqICAgICBjb2x1bW4gbnVtYmVyIGlzIDAtYmFzZWQuXG4gKiAgIC0gbmFtZTogVGhlIG9yaWdpbmFsIGlkZW50aWZpZXIsIG9yIG51bGwuXG4gKi9cbkJhc2ljU291cmNlTWFwQ29uc3VtZXIucHJvdG90eXBlLm9yaWdpbmFsUG9zaXRpb25Gb3IgPVxuICBmdW5jdGlvbiBTb3VyY2VNYXBDb25zdW1lcl9vcmlnaW5hbFBvc2l0aW9uRm9yKGFBcmdzKSB7XG4gICAgdmFyIG5lZWRsZSA9IHtcbiAgICAgIGdlbmVyYXRlZExpbmU6IHV0aWwuZ2V0QXJnKGFBcmdzLCAnbGluZScpLFxuICAgICAgZ2VuZXJhdGVkQ29sdW1uOiB1dGlsLmdldEFyZyhhQXJncywgJ2NvbHVtbicpXG4gICAgfTtcblxuICAgIHZhciBpbmRleCA9IHRoaXMuX2ZpbmRNYXBwaW5nKFxuICAgICAgbmVlZGxlLFxuICAgICAgdGhpcy5fZ2VuZXJhdGVkTWFwcGluZ3MsXG4gICAgICBcImdlbmVyYXRlZExpbmVcIixcbiAgICAgIFwiZ2VuZXJhdGVkQ29sdW1uXCIsXG4gICAgICB1dGlsLmNvbXBhcmVCeUdlbmVyYXRlZFBvc2l0aW9uc0RlZmxhdGVkLFxuICAgICAgdXRpbC5nZXRBcmcoYUFyZ3MsICdiaWFzJywgU291cmNlTWFwQ29uc3VtZXIuR1JFQVRFU1RfTE9XRVJfQk9VTkQpXG4gICAgKTtcblxuICAgIGlmIChpbmRleCA+PSAwKSB7XG4gICAgICB2YXIgbWFwcGluZyA9IHRoaXMuX2dlbmVyYXRlZE1hcHBpbmdzW2luZGV4XTtcblxuICAgICAgaWYgKG1hcHBpbmcuZ2VuZXJhdGVkTGluZSA9PT0gbmVlZGxlLmdlbmVyYXRlZExpbmUpIHtcbiAgICAgICAgdmFyIHNvdXJjZSA9IHV0aWwuZ2V0QXJnKG1hcHBpbmcsICdzb3VyY2UnLCBudWxsKTtcbiAgICAgICAgaWYgKHNvdXJjZSAhPT0gbnVsbCkge1xuICAgICAgICAgIHNvdXJjZSA9IHRoaXMuX3NvdXJjZXMuYXQoc291cmNlKTtcbiAgICAgICAgICBzb3VyY2UgPSB1dGlsLmNvbXB1dGVTb3VyY2VVUkwodGhpcy5zb3VyY2VSb290LCBzb3VyY2UsIHRoaXMuX3NvdXJjZU1hcFVSTCk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG5hbWUgPSB1dGlsLmdldEFyZyhtYXBwaW5nLCAnbmFtZScsIG51bGwpO1xuICAgICAgICBpZiAobmFtZSAhPT0gbnVsbCkge1xuICAgICAgICAgIG5hbWUgPSB0aGlzLl9uYW1lcy5hdChuYW1lKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHNvdXJjZTogc291cmNlLFxuICAgICAgICAgIGxpbmU6IHV0aWwuZ2V0QXJnKG1hcHBpbmcsICdvcmlnaW5hbExpbmUnLCBudWxsKSxcbiAgICAgICAgICBjb2x1bW46IHV0aWwuZ2V0QXJnKG1hcHBpbmcsICdvcmlnaW5hbENvbHVtbicsIG51bGwpLFxuICAgICAgICAgIG5hbWU6IG5hbWVcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgc291cmNlOiBudWxsLFxuICAgICAgbGluZTogbnVsbCxcbiAgICAgIGNvbHVtbjogbnVsbCxcbiAgICAgIG5hbWU6IG51bGxcbiAgICB9O1xuICB9O1xuXG4vKipcbiAqIFJldHVybiB0cnVlIGlmIHdlIGhhdmUgdGhlIHNvdXJjZSBjb250ZW50IGZvciBldmVyeSBzb3VyY2UgaW4gdGhlIHNvdXJjZVxuICogbWFwLCBmYWxzZSBvdGhlcndpc2UuXG4gKi9cbkJhc2ljU291cmNlTWFwQ29uc3VtZXIucHJvdG90eXBlLmhhc0NvbnRlbnRzT2ZBbGxTb3VyY2VzID1cbiAgZnVuY3Rpb24gQmFzaWNTb3VyY2VNYXBDb25zdW1lcl9oYXNDb250ZW50c09mQWxsU291cmNlcygpIHtcbiAgICBpZiAoIXRoaXMuc291cmNlc0NvbnRlbnQpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuc291cmNlc0NvbnRlbnQubGVuZ3RoID49IHRoaXMuX3NvdXJjZXMuc2l6ZSgpICYmXG4gICAgICAhdGhpcy5zb3VyY2VzQ29udGVudC5zb21lKGZ1bmN0aW9uIChzYykgeyByZXR1cm4gc2MgPT0gbnVsbDsgfSk7XG4gIH07XG5cbi8qKlxuICogUmV0dXJucyB0aGUgb3JpZ2luYWwgc291cmNlIGNvbnRlbnQuIFRoZSBvbmx5IGFyZ3VtZW50IGlzIHRoZSB1cmwgb2YgdGhlXG4gKiBvcmlnaW5hbCBzb3VyY2UgZmlsZS4gUmV0dXJucyBudWxsIGlmIG5vIG9yaWdpbmFsIHNvdXJjZSBjb250ZW50IGlzXG4gKiBhdmFpbGFibGUuXG4gKi9cbkJhc2ljU291cmNlTWFwQ29uc3VtZXIucHJvdG90eXBlLnNvdXJjZUNvbnRlbnRGb3IgPVxuICBmdW5jdGlvbiBTb3VyY2VNYXBDb25zdW1lcl9zb3VyY2VDb250ZW50Rm9yKGFTb3VyY2UsIG51bGxPbk1pc3NpbmcpIHtcbiAgICBpZiAoIXRoaXMuc291cmNlc0NvbnRlbnQpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIHZhciBpbmRleCA9IHRoaXMuX2ZpbmRTb3VyY2VJbmRleChhU291cmNlKTtcbiAgICBpZiAoaW5kZXggPj0gMCkge1xuICAgICAgcmV0dXJuIHRoaXMuc291cmNlc0NvbnRlbnRbaW5kZXhdO1xuICAgIH1cblxuICAgIHZhciByZWxhdGl2ZVNvdXJjZSA9IGFTb3VyY2U7XG4gICAgaWYgKHRoaXMuc291cmNlUm9vdCAhPSBudWxsKSB7XG4gICAgICByZWxhdGl2ZVNvdXJjZSA9IHV0aWwucmVsYXRpdmUodGhpcy5zb3VyY2VSb290LCByZWxhdGl2ZVNvdXJjZSk7XG4gICAgfVxuXG4gICAgdmFyIHVybDtcbiAgICBpZiAodGhpcy5zb3VyY2VSb290ICE9IG51bGxcbiAgICAgICAgJiYgKHVybCA9IHV0aWwudXJsUGFyc2UodGhpcy5zb3VyY2VSb290KSkpIHtcbiAgICAgIC8vIFhYWDogZmlsZTovLyBVUklzIGFuZCBhYnNvbHV0ZSBwYXRocyBsZWFkIHRvIHVuZXhwZWN0ZWQgYmVoYXZpb3IgZm9yXG4gICAgICAvLyBtYW55IHVzZXJzLiBXZSBjYW4gaGVscCB0aGVtIG91dCB3aGVuIHRoZXkgZXhwZWN0IGZpbGU6Ly8gVVJJcyB0b1xuICAgICAgLy8gYmVoYXZlIGxpa2UgaXQgd291bGQgaWYgdGhleSB3ZXJlIHJ1bm5pbmcgYSBsb2NhbCBIVFRQIHNlcnZlci4gU2VlXG4gICAgICAvLyBodHRwczovL2J1Z3ppbGxhLm1vemlsbGEub3JnL3Nob3dfYnVnLmNnaT9pZD04ODU1OTcuXG4gICAgICB2YXIgZmlsZVVyaUFic1BhdGggPSByZWxhdGl2ZVNvdXJjZS5yZXBsYWNlKC9eZmlsZTpcXC9cXC8vLCBcIlwiKTtcbiAgICAgIGlmICh1cmwuc2NoZW1lID09IFwiZmlsZVwiXG4gICAgICAgICAgJiYgdGhpcy5fc291cmNlcy5oYXMoZmlsZVVyaUFic1BhdGgpKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNvdXJjZXNDb250ZW50W3RoaXMuX3NvdXJjZXMuaW5kZXhPZihmaWxlVXJpQWJzUGF0aCldXG4gICAgICB9XG5cbiAgICAgIGlmICgoIXVybC5wYXRoIHx8IHVybC5wYXRoID09IFwiL1wiKVxuICAgICAgICAgICYmIHRoaXMuX3NvdXJjZXMuaGFzKFwiL1wiICsgcmVsYXRpdmVTb3VyY2UpKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNvdXJjZXNDb250ZW50W3RoaXMuX3NvdXJjZXMuaW5kZXhPZihcIi9cIiArIHJlbGF0aXZlU291cmNlKV07XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gVGhpcyBmdW5jdGlvbiBpcyB1c2VkIHJlY3Vyc2l2ZWx5IGZyb21cbiAgICAvLyBJbmRleGVkU291cmNlTWFwQ29uc3VtZXIucHJvdG90eXBlLnNvdXJjZUNvbnRlbnRGb3IuIEluIHRoYXQgY2FzZSwgd2VcbiAgICAvLyBkb24ndCB3YW50IHRvIHRocm93IGlmIHdlIGNhbid0IGZpbmQgdGhlIHNvdXJjZSAtIHdlIGp1c3Qgd2FudCB0b1xuICAgIC8vIHJldHVybiBudWxsLCBzbyB3ZSBwcm92aWRlIGEgZmxhZyB0byBleGl0IGdyYWNlZnVsbHkuXG4gICAgaWYgKG51bGxPbk1pc3NpbmcpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignXCInICsgcmVsYXRpdmVTb3VyY2UgKyAnXCIgaXMgbm90IGluIHRoZSBTb3VyY2VNYXAuJyk7XG4gICAgfVxuICB9O1xuXG4vKipcbiAqIFJldHVybnMgdGhlIGdlbmVyYXRlZCBsaW5lIGFuZCBjb2x1bW4gaW5mb3JtYXRpb24gZm9yIHRoZSBvcmlnaW5hbCBzb3VyY2UsXG4gKiBsaW5lLCBhbmQgY29sdW1uIHBvc2l0aW9ucyBwcm92aWRlZC4gVGhlIG9ubHkgYXJndW1lbnQgaXMgYW4gb2JqZWN0IHdpdGhcbiAqIHRoZSBmb2xsb3dpbmcgcHJvcGVydGllczpcbiAqXG4gKiAgIC0gc291cmNlOiBUaGUgZmlsZW5hbWUgb2YgdGhlIG9yaWdpbmFsIHNvdXJjZS5cbiAqICAgLSBsaW5lOiBUaGUgbGluZSBudW1iZXIgaW4gdGhlIG9yaWdpbmFsIHNvdXJjZS4gIFRoZSBsaW5lIG51bWJlclxuICogICAgIGlzIDEtYmFzZWQuXG4gKiAgIC0gY29sdW1uOiBUaGUgY29sdW1uIG51bWJlciBpbiB0aGUgb3JpZ2luYWwgc291cmNlLiAgVGhlIGNvbHVtblxuICogICAgIG51bWJlciBpcyAwLWJhc2VkLlxuICogICAtIGJpYXM6IEVpdGhlciAnU291cmNlTWFwQ29uc3VtZXIuR1JFQVRFU1RfTE9XRVJfQk9VTkQnIG9yXG4gKiAgICAgJ1NvdXJjZU1hcENvbnN1bWVyLkxFQVNUX1VQUEVSX0JPVU5EJy4gU3BlY2lmaWVzIHdoZXRoZXIgdG8gcmV0dXJuIHRoZVxuICogICAgIGNsb3Nlc3QgZWxlbWVudCB0aGF0IGlzIHNtYWxsZXIgdGhhbiBvciBncmVhdGVyIHRoYW4gdGhlIG9uZSB3ZSBhcmVcbiAqICAgICBzZWFyY2hpbmcgZm9yLCByZXNwZWN0aXZlbHksIGlmIHRoZSBleGFjdCBlbGVtZW50IGNhbm5vdCBiZSBmb3VuZC5cbiAqICAgICBEZWZhdWx0cyB0byAnU291cmNlTWFwQ29uc3VtZXIuR1JFQVRFU1RfTE9XRVJfQk9VTkQnLlxuICpcbiAqIGFuZCBhbiBvYmplY3QgaXMgcmV0dXJuZWQgd2l0aCB0aGUgZm9sbG93aW5nIHByb3BlcnRpZXM6XG4gKlxuICogICAtIGxpbmU6IFRoZSBsaW5lIG51bWJlciBpbiB0aGUgZ2VuZXJhdGVkIHNvdXJjZSwgb3IgbnVsbC4gIFRoZVxuICogICAgIGxpbmUgbnVtYmVyIGlzIDEtYmFzZWQuXG4gKiAgIC0gY29sdW1uOiBUaGUgY29sdW1uIG51bWJlciBpbiB0aGUgZ2VuZXJhdGVkIHNvdXJjZSwgb3IgbnVsbC5cbiAqICAgICBUaGUgY29sdW1uIG51bWJlciBpcyAwLWJhc2VkLlxuICovXG5CYXNpY1NvdXJjZU1hcENvbnN1bWVyLnByb3RvdHlwZS5nZW5lcmF0ZWRQb3NpdGlvbkZvciA9XG4gIGZ1bmN0aW9uIFNvdXJjZU1hcENvbnN1bWVyX2dlbmVyYXRlZFBvc2l0aW9uRm9yKGFBcmdzKSB7XG4gICAgdmFyIHNvdXJjZSA9IHV0aWwuZ2V0QXJnKGFBcmdzLCAnc291cmNlJyk7XG4gICAgc291cmNlID0gdGhpcy5fZmluZFNvdXJjZUluZGV4KHNvdXJjZSk7XG4gICAgaWYgKHNvdXJjZSA8IDApIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGxpbmU6IG51bGwsXG4gICAgICAgIGNvbHVtbjogbnVsbCxcbiAgICAgICAgbGFzdENvbHVtbjogbnVsbFxuICAgICAgfTtcbiAgICB9XG5cbiAgICB2YXIgbmVlZGxlID0ge1xuICAgICAgc291cmNlOiBzb3VyY2UsXG4gICAgICBvcmlnaW5hbExpbmU6IHV0aWwuZ2V0QXJnKGFBcmdzLCAnbGluZScpLFxuICAgICAgb3JpZ2luYWxDb2x1bW46IHV0aWwuZ2V0QXJnKGFBcmdzLCAnY29sdW1uJylcbiAgICB9O1xuXG4gICAgdmFyIGluZGV4ID0gdGhpcy5fZmluZE1hcHBpbmcoXG4gICAgICBuZWVkbGUsXG4gICAgICB0aGlzLl9vcmlnaW5hbE1hcHBpbmdzLFxuICAgICAgXCJvcmlnaW5hbExpbmVcIixcbiAgICAgIFwib3JpZ2luYWxDb2x1bW5cIixcbiAgICAgIHV0aWwuY29tcGFyZUJ5T3JpZ2luYWxQb3NpdGlvbnMsXG4gICAgICB1dGlsLmdldEFyZyhhQXJncywgJ2JpYXMnLCBTb3VyY2VNYXBDb25zdW1lci5HUkVBVEVTVF9MT1dFUl9CT1VORClcbiAgICApO1xuXG4gICAgaWYgKGluZGV4ID49IDApIHtcbiAgICAgIHZhciBtYXBwaW5nID0gdGhpcy5fb3JpZ2luYWxNYXBwaW5nc1tpbmRleF07XG5cbiAgICAgIGlmIChtYXBwaW5nLnNvdXJjZSA9PT0gbmVlZGxlLnNvdXJjZSkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGxpbmU6IHV0aWwuZ2V0QXJnKG1hcHBpbmcsICdnZW5lcmF0ZWRMaW5lJywgbnVsbCksXG4gICAgICAgICAgY29sdW1uOiB1dGlsLmdldEFyZyhtYXBwaW5nLCAnZ2VuZXJhdGVkQ29sdW1uJywgbnVsbCksXG4gICAgICAgICAgbGFzdENvbHVtbjogdXRpbC5nZXRBcmcobWFwcGluZywgJ2xhc3RHZW5lcmF0ZWRDb2x1bW4nLCBudWxsKVxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICBsaW5lOiBudWxsLFxuICAgICAgY29sdW1uOiBudWxsLFxuICAgICAgbGFzdENvbHVtbjogbnVsbFxuICAgIH07XG4gIH07XG5cbmV4cG9ydHMuQmFzaWNTb3VyY2VNYXBDb25zdW1lciA9IEJhc2ljU291cmNlTWFwQ29uc3VtZXI7XG5cbi8qKlxuICogQW4gSW5kZXhlZFNvdXJjZU1hcENvbnN1bWVyIGluc3RhbmNlIHJlcHJlc2VudHMgYSBwYXJzZWQgc291cmNlIG1hcCB3aGljaFxuICogd2UgY2FuIHF1ZXJ5IGZvciBpbmZvcm1hdGlvbi4gSXQgZGlmZmVycyBmcm9tIEJhc2ljU291cmNlTWFwQ29uc3VtZXIgaW5cbiAqIHRoYXQgaXQgdGFrZXMgXCJpbmRleGVkXCIgc291cmNlIG1hcHMgKGkuZS4gb25lcyB3aXRoIGEgXCJzZWN0aW9uc1wiIGZpZWxkKSBhc1xuICogaW5wdXQuXG4gKlxuICogVGhlIGZpcnN0IHBhcmFtZXRlciBpcyBhIHJhdyBzb3VyY2UgbWFwIChlaXRoZXIgYXMgYSBKU09OIHN0cmluZywgb3IgYWxyZWFkeVxuICogcGFyc2VkIHRvIGFuIG9iamVjdCkuIEFjY29yZGluZyB0byB0aGUgc3BlYyBmb3IgaW5kZXhlZCBzb3VyY2UgbWFwcywgdGhleVxuICogaGF2ZSB0aGUgZm9sbG93aW5nIGF0dHJpYnV0ZXM6XG4gKlxuICogICAtIHZlcnNpb246IFdoaWNoIHZlcnNpb24gb2YgdGhlIHNvdXJjZSBtYXAgc3BlYyB0aGlzIG1hcCBpcyBmb2xsb3dpbmcuXG4gKiAgIC0gZmlsZTogT3B0aW9uYWwuIFRoZSBnZW5lcmF0ZWQgZmlsZSB0aGlzIHNvdXJjZSBtYXAgaXMgYXNzb2NpYXRlZCB3aXRoLlxuICogICAtIHNlY3Rpb25zOiBBIGxpc3Qgb2Ygc2VjdGlvbiBkZWZpbml0aW9ucy5cbiAqXG4gKiBFYWNoIHZhbHVlIHVuZGVyIHRoZSBcInNlY3Rpb25zXCIgZmllbGQgaGFzIHR3byBmaWVsZHM6XG4gKiAgIC0gb2Zmc2V0OiBUaGUgb2Zmc2V0IGludG8gdGhlIG9yaWdpbmFsIHNwZWNpZmllZCBhdCB3aGljaCB0aGlzIHNlY3Rpb25cbiAqICAgICAgIGJlZ2lucyB0byBhcHBseSwgZGVmaW5lZCBhcyBhbiBvYmplY3Qgd2l0aCBhIFwibGluZVwiIGFuZCBcImNvbHVtblwiXG4gKiAgICAgICBmaWVsZC5cbiAqICAgLSBtYXA6IEEgc291cmNlIG1hcCBkZWZpbml0aW9uLiBUaGlzIHNvdXJjZSBtYXAgY291bGQgYWxzbyBiZSBpbmRleGVkLFxuICogICAgICAgYnV0IGRvZXNuJ3QgaGF2ZSB0byBiZS5cbiAqXG4gKiBJbnN0ZWFkIG9mIHRoZSBcIm1hcFwiIGZpZWxkLCBpdCdzIGFsc28gcG9zc2libGUgdG8gaGF2ZSBhIFwidXJsXCIgZmllbGRcbiAqIHNwZWNpZnlpbmcgYSBVUkwgdG8gcmV0cmlldmUgYSBzb3VyY2UgbWFwIGZyb20sIGJ1dCB0aGF0J3MgY3VycmVudGx5XG4gKiB1bnN1cHBvcnRlZC5cbiAqXG4gKiBIZXJlJ3MgYW4gZXhhbXBsZSBzb3VyY2UgbWFwLCB0YWtlbiBmcm9tIHRoZSBzb3VyY2UgbWFwIHNwZWNbMF0sIGJ1dFxuICogbW9kaWZpZWQgdG8gb21pdCBhIHNlY3Rpb24gd2hpY2ggdXNlcyB0aGUgXCJ1cmxcIiBmaWVsZC5cbiAqXG4gKiAge1xuICogICAgdmVyc2lvbiA6IDMsXG4gKiAgICBmaWxlOiBcImFwcC5qc1wiLFxuICogICAgc2VjdGlvbnM6IFt7XG4gKiAgICAgIG9mZnNldDoge2xpbmU6MTAwLCBjb2x1bW46MTB9LFxuICogICAgICBtYXA6IHtcbiAqICAgICAgICB2ZXJzaW9uIDogMyxcbiAqICAgICAgICBmaWxlOiBcInNlY3Rpb24uanNcIixcbiAqICAgICAgICBzb3VyY2VzOiBbXCJmb28uanNcIiwgXCJiYXIuanNcIl0sXG4gKiAgICAgICAgbmFtZXM6IFtcInNyY1wiLCBcIm1hcHNcIiwgXCJhcmVcIiwgXCJmdW5cIl0sXG4gKiAgICAgICAgbWFwcGluZ3M6IFwiQUFBQSxFOztBQkNERTtcIlxuICogICAgICB9XG4gKiAgICB9XSxcbiAqICB9XG4gKlxuICogVGhlIHNlY29uZCBwYXJhbWV0ZXIsIGlmIGdpdmVuLCBpcyBhIHN0cmluZyB3aG9zZSB2YWx1ZSBpcyB0aGUgVVJMXG4gKiBhdCB3aGljaCB0aGUgc291cmNlIG1hcCB3YXMgZm91bmQuICBUaGlzIFVSTCBpcyB1c2VkIHRvIGNvbXB1dGUgdGhlXG4gKiBzb3VyY2VzIGFycmF5LlxuICpcbiAqIFswXTogaHR0cHM6Ly9kb2NzLmdvb2dsZS5jb20vZG9jdW1lbnQvZC8xVTFSR0FlaFF3UnlwVVRvdkYxS1JscGlPRnplMGItXzJnYzZmQUgwS1kway9lZGl0I2hlYWRpbmc9aC41MzVlczN4ZXByZ3RcbiAqL1xuZnVuY3Rpb24gSW5kZXhlZFNvdXJjZU1hcENvbnN1bWVyKGFTb3VyY2VNYXAsIGFTb3VyY2VNYXBVUkwpIHtcbiAgdmFyIHNvdXJjZU1hcCA9IGFTb3VyY2VNYXA7XG4gIGlmICh0eXBlb2YgYVNvdXJjZU1hcCA9PT0gJ3N0cmluZycpIHtcbiAgICBzb3VyY2VNYXAgPSB1dGlsLnBhcnNlU291cmNlTWFwSW5wdXQoYVNvdXJjZU1hcCk7XG4gIH1cblxuICB2YXIgdmVyc2lvbiA9IHV0aWwuZ2V0QXJnKHNvdXJjZU1hcCwgJ3ZlcnNpb24nKTtcbiAgdmFyIHNlY3Rpb25zID0gdXRpbC5nZXRBcmcoc291cmNlTWFwLCAnc2VjdGlvbnMnKTtcblxuICBpZiAodmVyc2lvbiAhPSB0aGlzLl92ZXJzaW9uKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdVbnN1cHBvcnRlZCB2ZXJzaW9uOiAnICsgdmVyc2lvbik7XG4gIH1cblxuICB0aGlzLl9zb3VyY2VzID0gbmV3IEFycmF5U2V0KCk7XG4gIHRoaXMuX25hbWVzID0gbmV3IEFycmF5U2V0KCk7XG5cbiAgdmFyIGxhc3RPZmZzZXQgPSB7XG4gICAgbGluZTogLTEsXG4gICAgY29sdW1uOiAwXG4gIH07XG4gIHRoaXMuX3NlY3Rpb25zID0gc2VjdGlvbnMubWFwKGZ1bmN0aW9uIChzKSB7XG4gICAgaWYgKHMudXJsKSB7XG4gICAgICAvLyBUaGUgdXJsIGZpZWxkIHdpbGwgcmVxdWlyZSBzdXBwb3J0IGZvciBhc3luY2hyb25pY2l0eS5cbiAgICAgIC8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vbW96aWxsYS9zb3VyY2UtbWFwL2lzc3Vlcy8xNlxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdTdXBwb3J0IGZvciB1cmwgZmllbGQgaW4gc2VjdGlvbnMgbm90IGltcGxlbWVudGVkLicpO1xuICAgIH1cbiAgICB2YXIgb2Zmc2V0ID0gdXRpbC5nZXRBcmcocywgJ29mZnNldCcpO1xuICAgIHZhciBvZmZzZXRMaW5lID0gdXRpbC5nZXRBcmcob2Zmc2V0LCAnbGluZScpO1xuICAgIHZhciBvZmZzZXRDb2x1bW4gPSB1dGlsLmdldEFyZyhvZmZzZXQsICdjb2x1bW4nKTtcblxuICAgIGlmIChvZmZzZXRMaW5lIDwgbGFzdE9mZnNldC5saW5lIHx8XG4gICAgICAgIChvZmZzZXRMaW5lID09PSBsYXN0T2Zmc2V0LmxpbmUgJiYgb2Zmc2V0Q29sdW1uIDwgbGFzdE9mZnNldC5jb2x1bW4pKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1NlY3Rpb24gb2Zmc2V0cyBtdXN0IGJlIG9yZGVyZWQgYW5kIG5vbi1vdmVybGFwcGluZy4nKTtcbiAgICB9XG4gICAgbGFzdE9mZnNldCA9IG9mZnNldDtcblxuICAgIHJldHVybiB7XG4gICAgICBnZW5lcmF0ZWRPZmZzZXQ6IHtcbiAgICAgICAgLy8gVGhlIG9mZnNldCBmaWVsZHMgYXJlIDAtYmFzZWQsIGJ1dCB3ZSB1c2UgMS1iYXNlZCBpbmRpY2VzIHdoZW5cbiAgICAgICAgLy8gZW5jb2RpbmcvZGVjb2RpbmcgZnJvbSBWTFEuXG4gICAgICAgIGdlbmVyYXRlZExpbmU6IG9mZnNldExpbmUgKyAxLFxuICAgICAgICBnZW5lcmF0ZWRDb2x1bW46IG9mZnNldENvbHVtbiArIDFcbiAgICAgIH0sXG4gICAgICBjb25zdW1lcjogbmV3IFNvdXJjZU1hcENvbnN1bWVyKHV0aWwuZ2V0QXJnKHMsICdtYXAnKSwgYVNvdXJjZU1hcFVSTClcbiAgICB9XG4gIH0pO1xufVxuXG5JbmRleGVkU291cmNlTWFwQ29uc3VtZXIucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShTb3VyY2VNYXBDb25zdW1lci5wcm90b3R5cGUpO1xuSW5kZXhlZFNvdXJjZU1hcENvbnN1bWVyLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFNvdXJjZU1hcENvbnN1bWVyO1xuXG4vKipcbiAqIFRoZSB2ZXJzaW9uIG9mIHRoZSBzb3VyY2UgbWFwcGluZyBzcGVjIHRoYXQgd2UgYXJlIGNvbnN1bWluZy5cbiAqL1xuSW5kZXhlZFNvdXJjZU1hcENvbnN1bWVyLnByb3RvdHlwZS5fdmVyc2lvbiA9IDM7XG5cbi8qKlxuICogVGhlIGxpc3Qgb2Ygb3JpZ2luYWwgc291cmNlcy5cbiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KEluZGV4ZWRTb3VyY2VNYXBDb25zdW1lci5wcm90b3R5cGUsICdzb3VyY2VzJywge1xuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgc291cmNlcyA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5fc2VjdGlvbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgdGhpcy5fc2VjdGlvbnNbaV0uY29uc3VtZXIuc291cmNlcy5sZW5ndGg7IGorKykge1xuICAgICAgICBzb3VyY2VzLnB1c2godGhpcy5fc2VjdGlvbnNbaV0uY29uc3VtZXIuc291cmNlc1tqXSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBzb3VyY2VzO1xuICB9XG59KTtcblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBvcmlnaW5hbCBzb3VyY2UsIGxpbmUsIGFuZCBjb2x1bW4gaW5mb3JtYXRpb24gZm9yIHRoZSBnZW5lcmF0ZWRcbiAqIHNvdXJjZSdzIGxpbmUgYW5kIGNvbHVtbiBwb3NpdGlvbnMgcHJvdmlkZWQuIFRoZSBvbmx5IGFyZ3VtZW50IGlzIGFuIG9iamVjdFxuICogd2l0aCB0aGUgZm9sbG93aW5nIHByb3BlcnRpZXM6XG4gKlxuICogICAtIGxpbmU6IFRoZSBsaW5lIG51bWJlciBpbiB0aGUgZ2VuZXJhdGVkIHNvdXJjZS4gIFRoZSBsaW5lIG51bWJlclxuICogICAgIGlzIDEtYmFzZWQuXG4gKiAgIC0gY29sdW1uOiBUaGUgY29sdW1uIG51bWJlciBpbiB0aGUgZ2VuZXJhdGVkIHNvdXJjZS4gIFRoZSBjb2x1bW5cbiAqICAgICBudW1iZXIgaXMgMC1iYXNlZC5cbiAqXG4gKiBhbmQgYW4gb2JqZWN0IGlzIHJldHVybmVkIHdpdGggdGhlIGZvbGxvd2luZyBwcm9wZXJ0aWVzOlxuICpcbiAqICAgLSBzb3VyY2U6IFRoZSBvcmlnaW5hbCBzb3VyY2UgZmlsZSwgb3IgbnVsbC5cbiAqICAgLSBsaW5lOiBUaGUgbGluZSBudW1iZXIgaW4gdGhlIG9yaWdpbmFsIHNvdXJjZSwgb3IgbnVsbC4gIFRoZVxuICogICAgIGxpbmUgbnVtYmVyIGlzIDEtYmFzZWQuXG4gKiAgIC0gY29sdW1uOiBUaGUgY29sdW1uIG51bWJlciBpbiB0aGUgb3JpZ2luYWwgc291cmNlLCBvciBudWxsLiAgVGhlXG4gKiAgICAgY29sdW1uIG51bWJlciBpcyAwLWJhc2VkLlxuICogICAtIG5hbWU6IFRoZSBvcmlnaW5hbCBpZGVudGlmaWVyLCBvciBudWxsLlxuICovXG5JbmRleGVkU291cmNlTWFwQ29uc3VtZXIucHJvdG90eXBlLm9yaWdpbmFsUG9zaXRpb25Gb3IgPVxuICBmdW5jdGlvbiBJbmRleGVkU291cmNlTWFwQ29uc3VtZXJfb3JpZ2luYWxQb3NpdGlvbkZvcihhQXJncykge1xuICAgIHZhciBuZWVkbGUgPSB7XG4gICAgICBnZW5lcmF0ZWRMaW5lOiB1dGlsLmdldEFyZyhhQXJncywgJ2xpbmUnKSxcbiAgICAgIGdlbmVyYXRlZENvbHVtbjogdXRpbC5nZXRBcmcoYUFyZ3MsICdjb2x1bW4nKVxuICAgIH07XG5cbiAgICAvLyBGaW5kIHRoZSBzZWN0aW9uIGNvbnRhaW5pbmcgdGhlIGdlbmVyYXRlZCBwb3NpdGlvbiB3ZSdyZSB0cnlpbmcgdG8gbWFwXG4gICAgLy8gdG8gYW4gb3JpZ2luYWwgcG9zaXRpb24uXG4gICAgdmFyIHNlY3Rpb25JbmRleCA9IGJpbmFyeVNlYXJjaC5zZWFyY2gobmVlZGxlLCB0aGlzLl9zZWN0aW9ucyxcbiAgICAgIGZ1bmN0aW9uKG5lZWRsZSwgc2VjdGlvbikge1xuICAgICAgICB2YXIgY21wID0gbmVlZGxlLmdlbmVyYXRlZExpbmUgLSBzZWN0aW9uLmdlbmVyYXRlZE9mZnNldC5nZW5lcmF0ZWRMaW5lO1xuICAgICAgICBpZiAoY21wKSB7XG4gICAgICAgICAgcmV0dXJuIGNtcDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiAobmVlZGxlLmdlbmVyYXRlZENvbHVtbiAtXG4gICAgICAgICAgICAgICAgc2VjdGlvbi5nZW5lcmF0ZWRPZmZzZXQuZ2VuZXJhdGVkQ29sdW1uKTtcbiAgICAgIH0pO1xuICAgIHZhciBzZWN0aW9uID0gdGhpcy5fc2VjdGlvbnNbc2VjdGlvbkluZGV4XTtcblxuICAgIGlmICghc2VjdGlvbikge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgc291cmNlOiBudWxsLFxuICAgICAgICBsaW5lOiBudWxsLFxuICAgICAgICBjb2x1bW46IG51bGwsXG4gICAgICAgIG5hbWU6IG51bGxcbiAgICAgIH07XG4gICAgfVxuXG4gICAgcmV0dXJuIHNlY3Rpb24uY29uc3VtZXIub3JpZ2luYWxQb3NpdGlvbkZvcih7XG4gICAgICBsaW5lOiBuZWVkbGUuZ2VuZXJhdGVkTGluZSAtXG4gICAgICAgIChzZWN0aW9uLmdlbmVyYXRlZE9mZnNldC5nZW5lcmF0ZWRMaW5lIC0gMSksXG4gICAgICBjb2x1bW46IG5lZWRsZS5nZW5lcmF0ZWRDb2x1bW4gLVxuICAgICAgICAoc2VjdGlvbi5nZW5lcmF0ZWRPZmZzZXQuZ2VuZXJhdGVkTGluZSA9PT0gbmVlZGxlLmdlbmVyYXRlZExpbmVcbiAgICAgICAgID8gc2VjdGlvbi5nZW5lcmF0ZWRPZmZzZXQuZ2VuZXJhdGVkQ29sdW1uIC0gMVxuICAgICAgICAgOiAwKSxcbiAgICAgIGJpYXM6IGFBcmdzLmJpYXNcbiAgICB9KTtcbiAgfTtcblxuLyoqXG4gKiBSZXR1cm4gdHJ1ZSBpZiB3ZSBoYXZlIHRoZSBzb3VyY2UgY29udGVudCBmb3IgZXZlcnkgc291cmNlIGluIHRoZSBzb3VyY2VcbiAqIG1hcCwgZmFsc2Ugb3RoZXJ3aXNlLlxuICovXG5JbmRleGVkU291cmNlTWFwQ29uc3VtZXIucHJvdG90eXBlLmhhc0NvbnRlbnRzT2ZBbGxTb3VyY2VzID1cbiAgZnVuY3Rpb24gSW5kZXhlZFNvdXJjZU1hcENvbnN1bWVyX2hhc0NvbnRlbnRzT2ZBbGxTb3VyY2VzKCkge1xuICAgIHJldHVybiB0aGlzLl9zZWN0aW9ucy5ldmVyeShmdW5jdGlvbiAocykge1xuICAgICAgcmV0dXJuIHMuY29uc3VtZXIuaGFzQ29udGVudHNPZkFsbFNvdXJjZXMoKTtcbiAgICB9KTtcbiAgfTtcblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBvcmlnaW5hbCBzb3VyY2UgY29udGVudC4gVGhlIG9ubHkgYXJndW1lbnQgaXMgdGhlIHVybCBvZiB0aGVcbiAqIG9yaWdpbmFsIHNvdXJjZSBmaWxlLiBSZXR1cm5zIG51bGwgaWYgbm8gb3JpZ2luYWwgc291cmNlIGNvbnRlbnQgaXNcbiAqIGF2YWlsYWJsZS5cbiAqL1xuSW5kZXhlZFNvdXJjZU1hcENvbnN1bWVyLnByb3RvdHlwZS5zb3VyY2VDb250ZW50Rm9yID1cbiAgZnVuY3Rpb24gSW5kZXhlZFNvdXJjZU1hcENvbnN1bWVyX3NvdXJjZUNvbnRlbnRGb3IoYVNvdXJjZSwgbnVsbE9uTWlzc2luZykge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5fc2VjdGlvbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBzZWN0aW9uID0gdGhpcy5fc2VjdGlvbnNbaV07XG5cbiAgICAgIHZhciBjb250ZW50ID0gc2VjdGlvbi5jb25zdW1lci5zb3VyY2VDb250ZW50Rm9yKGFTb3VyY2UsIHRydWUpO1xuICAgICAgaWYgKGNvbnRlbnQpIHtcbiAgICAgICAgcmV0dXJuIGNvbnRlbnQ7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChudWxsT25NaXNzaW5nKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1wiJyArIGFTb3VyY2UgKyAnXCIgaXMgbm90IGluIHRoZSBTb3VyY2VNYXAuJyk7XG4gICAgfVxuICB9O1xuXG4vKipcbiAqIFJldHVybnMgdGhlIGdlbmVyYXRlZCBsaW5lIGFuZCBjb2x1bW4gaW5mb3JtYXRpb24gZm9yIHRoZSBvcmlnaW5hbCBzb3VyY2UsXG4gKiBsaW5lLCBhbmQgY29sdW1uIHBvc2l0aW9ucyBwcm92aWRlZC4gVGhlIG9ubHkgYXJndW1lbnQgaXMgYW4gb2JqZWN0IHdpdGhcbiAqIHRoZSBmb2xsb3dpbmcgcHJvcGVydGllczpcbiAqXG4gKiAgIC0gc291cmNlOiBUaGUgZmlsZW5hbWUgb2YgdGhlIG9yaWdpbmFsIHNvdXJjZS5cbiAqICAgLSBsaW5lOiBUaGUgbGluZSBudW1iZXIgaW4gdGhlIG9yaWdpbmFsIHNvdXJjZS4gIFRoZSBsaW5lIG51bWJlclxuICogICAgIGlzIDEtYmFzZWQuXG4gKiAgIC0gY29sdW1uOiBUaGUgY29sdW1uIG51bWJlciBpbiB0aGUgb3JpZ2luYWwgc291cmNlLiAgVGhlIGNvbHVtblxuICogICAgIG51bWJlciBpcyAwLWJhc2VkLlxuICpcbiAqIGFuZCBhbiBvYmplY3QgaXMgcmV0dXJuZWQgd2l0aCB0aGUgZm9sbG93aW5nIHByb3BlcnRpZXM6XG4gKlxuICogICAtIGxpbmU6IFRoZSBsaW5lIG51bWJlciBpbiB0aGUgZ2VuZXJhdGVkIHNvdXJjZSwgb3IgbnVsbC4gIFRoZVxuICogICAgIGxpbmUgbnVtYmVyIGlzIDEtYmFzZWQuIFxuICogICAtIGNvbHVtbjogVGhlIGNvbHVtbiBudW1iZXIgaW4gdGhlIGdlbmVyYXRlZCBzb3VyY2UsIG9yIG51bGwuXG4gKiAgICAgVGhlIGNvbHVtbiBudW1iZXIgaXMgMC1iYXNlZC5cbiAqL1xuSW5kZXhlZFNvdXJjZU1hcENvbnN1bWVyLnByb3RvdHlwZS5nZW5lcmF0ZWRQb3NpdGlvbkZvciA9XG4gIGZ1bmN0aW9uIEluZGV4ZWRTb3VyY2VNYXBDb25zdW1lcl9nZW5lcmF0ZWRQb3NpdGlvbkZvcihhQXJncykge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5fc2VjdGlvbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBzZWN0aW9uID0gdGhpcy5fc2VjdGlvbnNbaV07XG5cbiAgICAgIC8vIE9ubHkgY29uc2lkZXIgdGhpcyBzZWN0aW9uIGlmIHRoZSByZXF1ZXN0ZWQgc291cmNlIGlzIGluIHRoZSBsaXN0IG9mXG4gICAgICAvLyBzb3VyY2VzIG9mIHRoZSBjb25zdW1lci5cbiAgICAgIGlmIChzZWN0aW9uLmNvbnN1bWVyLl9maW5kU291cmNlSW5kZXgodXRpbC5nZXRBcmcoYUFyZ3MsICdzb3VyY2UnKSkgPT09IC0xKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgdmFyIGdlbmVyYXRlZFBvc2l0aW9uID0gc2VjdGlvbi5jb25zdW1lci5nZW5lcmF0ZWRQb3NpdGlvbkZvcihhQXJncyk7XG4gICAgICBpZiAoZ2VuZXJhdGVkUG9zaXRpb24pIHtcbiAgICAgICAgdmFyIHJldCA9IHtcbiAgICAgICAgICBsaW5lOiBnZW5lcmF0ZWRQb3NpdGlvbi5saW5lICtcbiAgICAgICAgICAgIChzZWN0aW9uLmdlbmVyYXRlZE9mZnNldC5nZW5lcmF0ZWRMaW5lIC0gMSksXG4gICAgICAgICAgY29sdW1uOiBnZW5lcmF0ZWRQb3NpdGlvbi5jb2x1bW4gK1xuICAgICAgICAgICAgKHNlY3Rpb24uZ2VuZXJhdGVkT2Zmc2V0LmdlbmVyYXRlZExpbmUgPT09IGdlbmVyYXRlZFBvc2l0aW9uLmxpbmVcbiAgICAgICAgICAgICA/IHNlY3Rpb24uZ2VuZXJhdGVkT2Zmc2V0LmdlbmVyYXRlZENvbHVtbiAtIDFcbiAgICAgICAgICAgICA6IDApXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiByZXQ7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIGxpbmU6IG51bGwsXG4gICAgICBjb2x1bW46IG51bGxcbiAgICB9O1xuICB9O1xuXG4vKipcbiAqIFBhcnNlIHRoZSBtYXBwaW5ncyBpbiBhIHN0cmluZyBpbiB0byBhIGRhdGEgc3RydWN0dXJlIHdoaWNoIHdlIGNhbiBlYXNpbHlcbiAqIHF1ZXJ5ICh0aGUgb3JkZXJlZCBhcnJheXMgaW4gdGhlIGB0aGlzLl9fZ2VuZXJhdGVkTWFwcGluZ3NgIGFuZFxuICogYHRoaXMuX19vcmlnaW5hbE1hcHBpbmdzYCBwcm9wZXJ0aWVzKS5cbiAqL1xuSW5kZXhlZFNvdXJjZU1hcENvbnN1bWVyLnByb3RvdHlwZS5fcGFyc2VNYXBwaW5ncyA9XG4gIGZ1bmN0aW9uIEluZGV4ZWRTb3VyY2VNYXBDb25zdW1lcl9wYXJzZU1hcHBpbmdzKGFTdHIsIGFTb3VyY2VSb290KSB7XG4gICAgdGhpcy5fX2dlbmVyYXRlZE1hcHBpbmdzID0gW107XG4gICAgdGhpcy5fX29yaWdpbmFsTWFwcGluZ3MgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuX3NlY3Rpb25zLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgc2VjdGlvbiA9IHRoaXMuX3NlY3Rpb25zW2ldO1xuICAgICAgdmFyIHNlY3Rpb25NYXBwaW5ncyA9IHNlY3Rpb24uY29uc3VtZXIuX2dlbmVyYXRlZE1hcHBpbmdzO1xuICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBzZWN0aW9uTWFwcGluZ3MubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgdmFyIG1hcHBpbmcgPSBzZWN0aW9uTWFwcGluZ3Nbal07XG5cbiAgICAgICAgdmFyIHNvdXJjZSA9IHNlY3Rpb24uY29uc3VtZXIuX3NvdXJjZXMuYXQobWFwcGluZy5zb3VyY2UpO1xuICAgICAgICBzb3VyY2UgPSB1dGlsLmNvbXB1dGVTb3VyY2VVUkwoc2VjdGlvbi5jb25zdW1lci5zb3VyY2VSb290LCBzb3VyY2UsIHRoaXMuX3NvdXJjZU1hcFVSTCk7XG4gICAgICAgIHRoaXMuX3NvdXJjZXMuYWRkKHNvdXJjZSk7XG4gICAgICAgIHNvdXJjZSA9IHRoaXMuX3NvdXJjZXMuaW5kZXhPZihzb3VyY2UpO1xuXG4gICAgICAgIHZhciBuYW1lID0gbnVsbDtcbiAgICAgICAgaWYgKG1hcHBpbmcubmFtZSkge1xuICAgICAgICAgIG5hbWUgPSBzZWN0aW9uLmNvbnN1bWVyLl9uYW1lcy5hdChtYXBwaW5nLm5hbWUpO1xuICAgICAgICAgIHRoaXMuX25hbWVzLmFkZChuYW1lKTtcbiAgICAgICAgICBuYW1lID0gdGhpcy5fbmFtZXMuaW5kZXhPZihuYW1lKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFRoZSBtYXBwaW5ncyBjb21pbmcgZnJvbSB0aGUgY29uc3VtZXIgZm9yIHRoZSBzZWN0aW9uIGhhdmVcbiAgICAgICAgLy8gZ2VuZXJhdGVkIHBvc2l0aW9ucyByZWxhdGl2ZSB0byB0aGUgc3RhcnQgb2YgdGhlIHNlY3Rpb24sIHNvIHdlXG4gICAgICAgIC8vIG5lZWQgdG8gb2Zmc2V0IHRoZW0gdG8gYmUgcmVsYXRpdmUgdG8gdGhlIHN0YXJ0IG9mIHRoZSBjb25jYXRlbmF0ZWRcbiAgICAgICAgLy8gZ2VuZXJhdGVkIGZpbGUuXG4gICAgICAgIHZhciBhZGp1c3RlZE1hcHBpbmcgPSB7XG4gICAgICAgICAgc291cmNlOiBzb3VyY2UsXG4gICAgICAgICAgZ2VuZXJhdGVkTGluZTogbWFwcGluZy5nZW5lcmF0ZWRMaW5lICtcbiAgICAgICAgICAgIChzZWN0aW9uLmdlbmVyYXRlZE9mZnNldC5nZW5lcmF0ZWRMaW5lIC0gMSksXG4gICAgICAgICAgZ2VuZXJhdGVkQ29sdW1uOiBtYXBwaW5nLmdlbmVyYXRlZENvbHVtbiArXG4gICAgICAgICAgICAoc2VjdGlvbi5nZW5lcmF0ZWRPZmZzZXQuZ2VuZXJhdGVkTGluZSA9PT0gbWFwcGluZy5nZW5lcmF0ZWRMaW5lXG4gICAgICAgICAgICA/IHNlY3Rpb24uZ2VuZXJhdGVkT2Zmc2V0LmdlbmVyYXRlZENvbHVtbiAtIDFcbiAgICAgICAgICAgIDogMCksXG4gICAgICAgICAgb3JpZ2luYWxMaW5lOiBtYXBwaW5nLm9yaWdpbmFsTGluZSxcbiAgICAgICAgICBvcmlnaW5hbENvbHVtbjogbWFwcGluZy5vcmlnaW5hbENvbHVtbixcbiAgICAgICAgICBuYW1lOiBuYW1lXG4gICAgICAgIH07XG5cbiAgICAgICAgdGhpcy5fX2dlbmVyYXRlZE1hcHBpbmdzLnB1c2goYWRqdXN0ZWRNYXBwaW5nKTtcbiAgICAgICAgaWYgKHR5cGVvZiBhZGp1c3RlZE1hcHBpbmcub3JpZ2luYWxMaW5lID09PSAnbnVtYmVyJykge1xuICAgICAgICAgIHRoaXMuX19vcmlnaW5hbE1hcHBpbmdzLnB1c2goYWRqdXN0ZWRNYXBwaW5nKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHF1aWNrU29ydCh0aGlzLl9fZ2VuZXJhdGVkTWFwcGluZ3MsIHV0aWwuY29tcGFyZUJ5R2VuZXJhdGVkUG9zaXRpb25zRGVmbGF0ZWQpO1xuICAgIHF1aWNrU29ydCh0aGlzLl9fb3JpZ2luYWxNYXBwaW5ncywgdXRpbC5jb21wYXJlQnlPcmlnaW5hbFBvc2l0aW9ucyk7XG4gIH07XG5cbmV4cG9ydHMuSW5kZXhlZFNvdXJjZU1hcENvbnN1bWVyID0gSW5kZXhlZFNvdXJjZU1hcENvbnN1bWVyO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2VsZWN0cm9uLXVwZGF0ZXIvbm9kZV9tb2R1bGVzL3NvdXJjZS1tYXAvbGliL3NvdXJjZS1tYXAtY29uc3VtZXIuanMiLCIvKiAtKi0gTW9kZToganM7IGpzLWluZGVudC1sZXZlbDogMjsgLSotICovXG4vKlxuICogQ29weXJpZ2h0IDIwMTEgTW96aWxsYSBGb3VuZGF0aW9uIGFuZCBjb250cmlidXRvcnNcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBOZXcgQlNEIGxpY2Vuc2UuIFNlZSBMSUNFTlNFIG9yOlxuICogaHR0cDovL29wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL0JTRC0zLUNsYXVzZVxuICovXG5cbmV4cG9ydHMuR1JFQVRFU1RfTE9XRVJfQk9VTkQgPSAxO1xuZXhwb3J0cy5MRUFTVF9VUFBFUl9CT1VORCA9IDI7XG5cbi8qKlxuICogUmVjdXJzaXZlIGltcGxlbWVudGF0aW9uIG9mIGJpbmFyeSBzZWFyY2guXG4gKlxuICogQHBhcmFtIGFMb3cgSW5kaWNlcyBoZXJlIGFuZCBsb3dlciBkbyBub3QgY29udGFpbiB0aGUgbmVlZGxlLlxuICogQHBhcmFtIGFIaWdoIEluZGljZXMgaGVyZSBhbmQgaGlnaGVyIGRvIG5vdCBjb250YWluIHRoZSBuZWVkbGUuXG4gKiBAcGFyYW0gYU5lZWRsZSBUaGUgZWxlbWVudCBiZWluZyBzZWFyY2hlZCBmb3IuXG4gKiBAcGFyYW0gYUhheXN0YWNrIFRoZSBub24tZW1wdHkgYXJyYXkgYmVpbmcgc2VhcmNoZWQuXG4gKiBAcGFyYW0gYUNvbXBhcmUgRnVuY3Rpb24gd2hpY2ggdGFrZXMgdHdvIGVsZW1lbnRzIGFuZCByZXR1cm5zIC0xLCAwLCBvciAxLlxuICogQHBhcmFtIGFCaWFzIEVpdGhlciAnYmluYXJ5U2VhcmNoLkdSRUFURVNUX0xPV0VSX0JPVU5EJyBvclxuICogICAgICdiaW5hcnlTZWFyY2guTEVBU1RfVVBQRVJfQk9VTkQnLiBTcGVjaWZpZXMgd2hldGhlciB0byByZXR1cm4gdGhlXG4gKiAgICAgY2xvc2VzdCBlbGVtZW50IHRoYXQgaXMgc21hbGxlciB0aGFuIG9yIGdyZWF0ZXIgdGhhbiB0aGUgb25lIHdlIGFyZVxuICogICAgIHNlYXJjaGluZyBmb3IsIHJlc3BlY3RpdmVseSwgaWYgdGhlIGV4YWN0IGVsZW1lbnQgY2Fubm90IGJlIGZvdW5kLlxuICovXG5mdW5jdGlvbiByZWN1cnNpdmVTZWFyY2goYUxvdywgYUhpZ2gsIGFOZWVkbGUsIGFIYXlzdGFjaywgYUNvbXBhcmUsIGFCaWFzKSB7XG4gIC8vIFRoaXMgZnVuY3Rpb24gdGVybWluYXRlcyB3aGVuIG9uZSBvZiB0aGUgZm9sbG93aW5nIGlzIHRydWU6XG4gIC8vXG4gIC8vICAgMS4gV2UgZmluZCB0aGUgZXhhY3QgZWxlbWVudCB3ZSBhcmUgbG9va2luZyBmb3IuXG4gIC8vXG4gIC8vICAgMi4gV2UgZGlkIG5vdCBmaW5kIHRoZSBleGFjdCBlbGVtZW50LCBidXQgd2UgY2FuIHJldHVybiB0aGUgaW5kZXggb2ZcbiAgLy8gICAgICB0aGUgbmV4dC1jbG9zZXN0IGVsZW1lbnQuXG4gIC8vXG4gIC8vICAgMy4gV2UgZGlkIG5vdCBmaW5kIHRoZSBleGFjdCBlbGVtZW50LCBhbmQgdGhlcmUgaXMgbm8gbmV4dC1jbG9zZXN0XG4gIC8vICAgICAgZWxlbWVudCB0aGFuIHRoZSBvbmUgd2UgYXJlIHNlYXJjaGluZyBmb3IsIHNvIHdlIHJldHVybiAtMS5cbiAgdmFyIG1pZCA9IE1hdGguZmxvb3IoKGFIaWdoIC0gYUxvdykgLyAyKSArIGFMb3c7XG4gIHZhciBjbXAgPSBhQ29tcGFyZShhTmVlZGxlLCBhSGF5c3RhY2tbbWlkXSwgdHJ1ZSk7XG4gIGlmIChjbXAgPT09IDApIHtcbiAgICAvLyBGb3VuZCB0aGUgZWxlbWVudCB3ZSBhcmUgbG9va2luZyBmb3IuXG4gICAgcmV0dXJuIG1pZDtcbiAgfVxuICBlbHNlIGlmIChjbXAgPiAwKSB7XG4gICAgLy8gT3VyIG5lZWRsZSBpcyBncmVhdGVyIHRoYW4gYUhheXN0YWNrW21pZF0uXG4gICAgaWYgKGFIaWdoIC0gbWlkID4gMSkge1xuICAgICAgLy8gVGhlIGVsZW1lbnQgaXMgaW4gdGhlIHVwcGVyIGhhbGYuXG4gICAgICByZXR1cm4gcmVjdXJzaXZlU2VhcmNoKG1pZCwgYUhpZ2gsIGFOZWVkbGUsIGFIYXlzdGFjaywgYUNvbXBhcmUsIGFCaWFzKTtcbiAgICB9XG5cbiAgICAvLyBUaGUgZXhhY3QgbmVlZGxlIGVsZW1lbnQgd2FzIG5vdCBmb3VuZCBpbiB0aGlzIGhheXN0YWNrLiBEZXRlcm1pbmUgaWZcbiAgICAvLyB3ZSBhcmUgaW4gdGVybWluYXRpb24gY2FzZSAoMykgb3IgKDIpIGFuZCByZXR1cm4gdGhlIGFwcHJvcHJpYXRlIHRoaW5nLlxuICAgIGlmIChhQmlhcyA9PSBleHBvcnRzLkxFQVNUX1VQUEVSX0JPVU5EKSB7XG4gICAgICByZXR1cm4gYUhpZ2ggPCBhSGF5c3RhY2subGVuZ3RoID8gYUhpZ2ggOiAtMTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIG1pZDtcbiAgICB9XG4gIH1cbiAgZWxzZSB7XG4gICAgLy8gT3VyIG5lZWRsZSBpcyBsZXNzIHRoYW4gYUhheXN0YWNrW21pZF0uXG4gICAgaWYgKG1pZCAtIGFMb3cgPiAxKSB7XG4gICAgICAvLyBUaGUgZWxlbWVudCBpcyBpbiB0aGUgbG93ZXIgaGFsZi5cbiAgICAgIHJldHVybiByZWN1cnNpdmVTZWFyY2goYUxvdywgbWlkLCBhTmVlZGxlLCBhSGF5c3RhY2ssIGFDb21wYXJlLCBhQmlhcyk7XG4gICAgfVxuXG4gICAgLy8gd2UgYXJlIGluIHRlcm1pbmF0aW9uIGNhc2UgKDMpIG9yICgyKSBhbmQgcmV0dXJuIHRoZSBhcHByb3ByaWF0ZSB0aGluZy5cbiAgICBpZiAoYUJpYXMgPT0gZXhwb3J0cy5MRUFTVF9VUFBFUl9CT1VORCkge1xuICAgICAgcmV0dXJuIG1pZDtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGFMb3cgPCAwID8gLTEgOiBhTG93O1xuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIFRoaXMgaXMgYW4gaW1wbGVtZW50YXRpb24gb2YgYmluYXJ5IHNlYXJjaCB3aGljaCB3aWxsIGFsd2F5cyB0cnkgYW5kIHJldHVyblxuICogdGhlIGluZGV4IG9mIHRoZSBjbG9zZXN0IGVsZW1lbnQgaWYgdGhlcmUgaXMgbm8gZXhhY3QgaGl0LiBUaGlzIGlzIGJlY2F1c2VcbiAqIG1hcHBpbmdzIGJldHdlZW4gb3JpZ2luYWwgYW5kIGdlbmVyYXRlZCBsaW5lL2NvbCBwYWlycyBhcmUgc2luZ2xlIHBvaW50cyxcbiAqIGFuZCB0aGVyZSBpcyBhbiBpbXBsaWNpdCByZWdpb24gYmV0d2VlbiBlYWNoIG9mIHRoZW0sIHNvIGEgbWlzcyBqdXN0IG1lYW5zXG4gKiB0aGF0IHlvdSBhcmVuJ3Qgb24gdGhlIHZlcnkgc3RhcnQgb2YgYSByZWdpb24uXG4gKlxuICogQHBhcmFtIGFOZWVkbGUgVGhlIGVsZW1lbnQgeW91IGFyZSBsb29raW5nIGZvci5cbiAqIEBwYXJhbSBhSGF5c3RhY2sgVGhlIGFycmF5IHRoYXQgaXMgYmVpbmcgc2VhcmNoZWQuXG4gKiBAcGFyYW0gYUNvbXBhcmUgQSBmdW5jdGlvbiB3aGljaCB0YWtlcyB0aGUgbmVlZGxlIGFuZCBhbiBlbGVtZW50IGluIHRoZVxuICogICAgIGFycmF5IGFuZCByZXR1cm5zIC0xLCAwLCBvciAxIGRlcGVuZGluZyBvbiB3aGV0aGVyIHRoZSBuZWVkbGUgaXMgbGVzc1xuICogICAgIHRoYW4sIGVxdWFsIHRvLCBvciBncmVhdGVyIHRoYW4gdGhlIGVsZW1lbnQsIHJlc3BlY3RpdmVseS5cbiAqIEBwYXJhbSBhQmlhcyBFaXRoZXIgJ2JpbmFyeVNlYXJjaC5HUkVBVEVTVF9MT1dFUl9CT1VORCcgb3JcbiAqICAgICAnYmluYXJ5U2VhcmNoLkxFQVNUX1VQUEVSX0JPVU5EJy4gU3BlY2lmaWVzIHdoZXRoZXIgdG8gcmV0dXJuIHRoZVxuICogICAgIGNsb3Nlc3QgZWxlbWVudCB0aGF0IGlzIHNtYWxsZXIgdGhhbiBvciBncmVhdGVyIHRoYW4gdGhlIG9uZSB3ZSBhcmVcbiAqICAgICBzZWFyY2hpbmcgZm9yLCByZXNwZWN0aXZlbHksIGlmIHRoZSBleGFjdCBlbGVtZW50IGNhbm5vdCBiZSBmb3VuZC5cbiAqICAgICBEZWZhdWx0cyB0byAnYmluYXJ5U2VhcmNoLkdSRUFURVNUX0xPV0VSX0JPVU5EJy5cbiAqL1xuZXhwb3J0cy5zZWFyY2ggPSBmdW5jdGlvbiBzZWFyY2goYU5lZWRsZSwgYUhheXN0YWNrLCBhQ29tcGFyZSwgYUJpYXMpIHtcbiAgaWYgKGFIYXlzdGFjay5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gLTE7XG4gIH1cblxuICB2YXIgaW5kZXggPSByZWN1cnNpdmVTZWFyY2goLTEsIGFIYXlzdGFjay5sZW5ndGgsIGFOZWVkbGUsIGFIYXlzdGFjayxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFDb21wYXJlLCBhQmlhcyB8fCBleHBvcnRzLkdSRUFURVNUX0xPV0VSX0JPVU5EKTtcbiAgaWYgKGluZGV4IDwgMCkge1xuICAgIHJldHVybiAtMTtcbiAgfVxuXG4gIC8vIFdlIGhhdmUgZm91bmQgZWl0aGVyIHRoZSBleGFjdCBlbGVtZW50LCBvciB0aGUgbmV4dC1jbG9zZXN0IGVsZW1lbnQgdGhhblxuICAvLyB0aGUgb25lIHdlIGFyZSBzZWFyY2hpbmcgZm9yLiBIb3dldmVyLCB0aGVyZSBtYXkgYmUgbW9yZSB0aGFuIG9uZSBzdWNoXG4gIC8vIGVsZW1lbnQuIE1ha2Ugc3VyZSB3ZSBhbHdheXMgcmV0dXJuIHRoZSBzbWFsbGVzdCBvZiB0aGVzZS5cbiAgd2hpbGUgKGluZGV4IC0gMSA+PSAwKSB7XG4gICAgaWYgKGFDb21wYXJlKGFIYXlzdGFja1tpbmRleF0sIGFIYXlzdGFja1tpbmRleCAtIDFdLCB0cnVlKSAhPT0gMCkge1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIC0taW5kZXg7XG4gIH1cblxuICByZXR1cm4gaW5kZXg7XG59O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2VsZWN0cm9uLXVwZGF0ZXIvbm9kZV9tb2R1bGVzL3NvdXJjZS1tYXAvbGliL2JpbmFyeS1zZWFyY2guanMiLCIvKiAtKi0gTW9kZToganM7IGpzLWluZGVudC1sZXZlbDogMjsgLSotICovXG4vKlxuICogQ29weXJpZ2h0IDIwMTEgTW96aWxsYSBGb3VuZGF0aW9uIGFuZCBjb250cmlidXRvcnNcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBOZXcgQlNEIGxpY2Vuc2UuIFNlZSBMSUNFTlNFIG9yOlxuICogaHR0cDovL29wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL0JTRC0zLUNsYXVzZVxuICovXG5cbi8vIEl0IHR1cm5zIG91dCB0aGF0IHNvbWUgKG1vc3Q/KSBKYXZhU2NyaXB0IGVuZ2luZXMgZG9uJ3Qgc2VsZi1ob3N0XG4vLyBgQXJyYXkucHJvdG90eXBlLnNvcnRgLiBUaGlzIG1ha2VzIHNlbnNlIGJlY2F1c2UgQysrIHdpbGwgbGlrZWx5IHJlbWFpblxuLy8gZmFzdGVyIHRoYW4gSlMgd2hlbiBkb2luZyByYXcgQ1BVLWludGVuc2l2ZSBzb3J0aW5nLiBIb3dldmVyLCB3aGVuIHVzaW5nIGFcbi8vIGN1c3RvbSBjb21wYXJhdG9yIGZ1bmN0aW9uLCBjYWxsaW5nIGJhY2sgYW5kIGZvcnRoIGJldHdlZW4gdGhlIFZNJ3MgQysrIGFuZFxuLy8gSklUJ2QgSlMgaXMgcmF0aGVyIHNsb3cgKmFuZCogbG9zZXMgSklUIHR5cGUgaW5mb3JtYXRpb24sIHJlc3VsdGluZyBpblxuLy8gd29yc2UgZ2VuZXJhdGVkIGNvZGUgZm9yIHRoZSBjb21wYXJhdG9yIGZ1bmN0aW9uIHRoYW4gd291bGQgYmUgb3B0aW1hbC4gSW5cbi8vIGZhY3QsIHdoZW4gc29ydGluZyB3aXRoIGEgY29tcGFyYXRvciwgdGhlc2UgY29zdHMgb3V0d2VpZ2ggdGhlIGJlbmVmaXRzIG9mXG4vLyBzb3J0aW5nIGluIEMrKy4gQnkgdXNpbmcgb3VyIG93biBKUy1pbXBsZW1lbnRlZCBRdWljayBTb3J0IChiZWxvdyksIHdlIGdldFxuLy8gYSB+MzUwMG1zIG1lYW4gc3BlZWQtdXAgaW4gYGJlbmNoL2JlbmNoLmh0bWxgLlxuXG4vKipcbiAqIFN3YXAgdGhlIGVsZW1lbnRzIGluZGV4ZWQgYnkgYHhgIGFuZCBgeWAgaW4gdGhlIGFycmF5IGBhcnlgLlxuICpcbiAqIEBwYXJhbSB7QXJyYXl9IGFyeVxuICogICAgICAgIFRoZSBhcnJheS5cbiAqIEBwYXJhbSB7TnVtYmVyfSB4XG4gKiAgICAgICAgVGhlIGluZGV4IG9mIHRoZSBmaXJzdCBpdGVtLlxuICogQHBhcmFtIHtOdW1iZXJ9IHlcbiAqICAgICAgICBUaGUgaW5kZXggb2YgdGhlIHNlY29uZCBpdGVtLlxuICovXG5mdW5jdGlvbiBzd2FwKGFyeSwgeCwgeSkge1xuICB2YXIgdGVtcCA9IGFyeVt4XTtcbiAgYXJ5W3hdID0gYXJ5W3ldO1xuICBhcnlbeV0gPSB0ZW1wO1xufVxuXG4vKipcbiAqIFJldHVybnMgYSByYW5kb20gaW50ZWdlciB3aXRoaW4gdGhlIHJhbmdlIGBsb3cgLi4gaGlnaGAgaW5jbHVzaXZlLlxuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSBsb3dcbiAqICAgICAgICBUaGUgbG93ZXIgYm91bmQgb24gdGhlIHJhbmdlLlxuICogQHBhcmFtIHtOdW1iZXJ9IGhpZ2hcbiAqICAgICAgICBUaGUgdXBwZXIgYm91bmQgb24gdGhlIHJhbmdlLlxuICovXG5mdW5jdGlvbiByYW5kb21JbnRJblJhbmdlKGxvdywgaGlnaCkge1xuICByZXR1cm4gTWF0aC5yb3VuZChsb3cgKyAoTWF0aC5yYW5kb20oKSAqIChoaWdoIC0gbG93KSkpO1xufVxuXG4vKipcbiAqIFRoZSBRdWljayBTb3J0IGFsZ29yaXRobS5cbiAqXG4gKiBAcGFyYW0ge0FycmF5fSBhcnlcbiAqICAgICAgICBBbiBhcnJheSB0byBzb3J0LlxuICogQHBhcmFtIHtmdW5jdGlvbn0gY29tcGFyYXRvclxuICogICAgICAgIEZ1bmN0aW9uIHRvIHVzZSB0byBjb21wYXJlIHR3byBpdGVtcy5cbiAqIEBwYXJhbSB7TnVtYmVyfSBwXG4gKiAgICAgICAgU3RhcnQgaW5kZXggb2YgdGhlIGFycmF5XG4gKiBAcGFyYW0ge051bWJlcn0gclxuICogICAgICAgIEVuZCBpbmRleCBvZiB0aGUgYXJyYXlcbiAqL1xuZnVuY3Rpb24gZG9RdWlja1NvcnQoYXJ5LCBjb21wYXJhdG9yLCBwLCByKSB7XG4gIC8vIElmIG91ciBsb3dlciBib3VuZCBpcyBsZXNzIHRoYW4gb3VyIHVwcGVyIGJvdW5kLCB3ZSAoMSkgcGFydGl0aW9uIHRoZVxuICAvLyBhcnJheSBpbnRvIHR3byBwaWVjZXMgYW5kICgyKSByZWN1cnNlIG9uIGVhY2ggaGFsZi4gSWYgaXQgaXMgbm90LCB0aGlzIGlzXG4gIC8vIHRoZSBlbXB0eSBhcnJheSBhbmQgb3VyIGJhc2UgY2FzZS5cblxuICBpZiAocCA8IHIpIHtcbiAgICAvLyAoMSkgUGFydGl0aW9uaW5nLlxuICAgIC8vXG4gICAgLy8gVGhlIHBhcnRpdGlvbmluZyBjaG9vc2VzIGEgcGl2b3QgYmV0d2VlbiBgcGAgYW5kIGByYCBhbmQgbW92ZXMgYWxsXG4gICAgLy8gZWxlbWVudHMgdGhhdCBhcmUgbGVzcyB0aGFuIG9yIGVxdWFsIHRvIHRoZSBwaXZvdCB0byB0aGUgYmVmb3JlIGl0LCBhbmRcbiAgICAvLyBhbGwgdGhlIGVsZW1lbnRzIHRoYXQgYXJlIGdyZWF0ZXIgdGhhbiBpdCBhZnRlciBpdC4gVGhlIGVmZmVjdCBpcyB0aGF0XG4gICAgLy8gb25jZSBwYXJ0aXRpb24gaXMgZG9uZSwgdGhlIHBpdm90IGlzIGluIHRoZSBleGFjdCBwbGFjZSBpdCB3aWxsIGJlIHdoZW5cbiAgICAvLyB0aGUgYXJyYXkgaXMgcHV0IGluIHNvcnRlZCBvcmRlciwgYW5kIGl0IHdpbGwgbm90IG5lZWQgdG8gYmUgbW92ZWRcbiAgICAvLyBhZ2Fpbi4gVGhpcyBydW5zIGluIE8obikgdGltZS5cblxuICAgIC8vIEFsd2F5cyBjaG9vc2UgYSByYW5kb20gcGl2b3Qgc28gdGhhdCBhbiBpbnB1dCBhcnJheSB3aGljaCBpcyByZXZlcnNlXG4gICAgLy8gc29ydGVkIGRvZXMgbm90IGNhdXNlIE8obl4yKSBydW5uaW5nIHRpbWUuXG4gICAgdmFyIHBpdm90SW5kZXggPSByYW5kb21JbnRJblJhbmdlKHAsIHIpO1xuICAgIHZhciBpID0gcCAtIDE7XG5cbiAgICBzd2FwKGFyeSwgcGl2b3RJbmRleCwgcik7XG4gICAgdmFyIHBpdm90ID0gYXJ5W3JdO1xuXG4gICAgLy8gSW1tZWRpYXRlbHkgYWZ0ZXIgYGpgIGlzIGluY3JlbWVudGVkIGluIHRoaXMgbG9vcCwgdGhlIGZvbGxvd2luZyBob2xkXG4gICAgLy8gdHJ1ZTpcbiAgICAvL1xuICAgIC8vICAgKiBFdmVyeSBlbGVtZW50IGluIGBhcnlbcCAuLiBpXWAgaXMgbGVzcyB0aGFuIG9yIGVxdWFsIHRvIHRoZSBwaXZvdC5cbiAgICAvL1xuICAgIC8vICAgKiBFdmVyeSBlbGVtZW50IGluIGBhcnlbaSsxIC4uIGotMV1gIGlzIGdyZWF0ZXIgdGhhbiB0aGUgcGl2b3QuXG4gICAgZm9yICh2YXIgaiA9IHA7IGogPCByOyBqKyspIHtcbiAgICAgIGlmIChjb21wYXJhdG9yKGFyeVtqXSwgcGl2b3QpIDw9IDApIHtcbiAgICAgICAgaSArPSAxO1xuICAgICAgICBzd2FwKGFyeSwgaSwgaik7XG4gICAgICB9XG4gICAgfVxuXG4gICAgc3dhcChhcnksIGkgKyAxLCBqKTtcbiAgICB2YXIgcSA9IGkgKyAxO1xuXG4gICAgLy8gKDIpIFJlY3Vyc2Ugb24gZWFjaCBoYWxmLlxuXG4gICAgZG9RdWlja1NvcnQoYXJ5LCBjb21wYXJhdG9yLCBwLCBxIC0gMSk7XG4gICAgZG9RdWlja1NvcnQoYXJ5LCBjb21wYXJhdG9yLCBxICsgMSwgcik7XG4gIH1cbn1cblxuLyoqXG4gKiBTb3J0IHRoZSBnaXZlbiBhcnJheSBpbi1wbGFjZSB3aXRoIHRoZSBnaXZlbiBjb21wYXJhdG9yIGZ1bmN0aW9uLlxuICpcbiAqIEBwYXJhbSB7QXJyYXl9IGFyeVxuICogICAgICAgIEFuIGFycmF5IHRvIHNvcnQuXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBjb21wYXJhdG9yXG4gKiAgICAgICAgRnVuY3Rpb24gdG8gdXNlIHRvIGNvbXBhcmUgdHdvIGl0ZW1zLlxuICovXG5leHBvcnRzLnF1aWNrU29ydCA9IGZ1bmN0aW9uIChhcnksIGNvbXBhcmF0b3IpIHtcbiAgZG9RdWlja1NvcnQoYXJ5LCBjb21wYXJhdG9yLCAwLCBhcnkubGVuZ3RoIC0gMSk7XG59O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2VsZWN0cm9uLXVwZGF0ZXIvbm9kZV9tb2R1bGVzL3NvdXJjZS1tYXAvbGliL3F1aWNrLXNvcnQuanMiLCIvKiAtKi0gTW9kZToganM7IGpzLWluZGVudC1sZXZlbDogMjsgLSotICovXG4vKlxuICogQ29weXJpZ2h0IDIwMTEgTW96aWxsYSBGb3VuZGF0aW9uIGFuZCBjb250cmlidXRvcnNcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBOZXcgQlNEIGxpY2Vuc2UuIFNlZSBMSUNFTlNFIG9yOlxuICogaHR0cDovL29wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL0JTRC0zLUNsYXVzZVxuICovXG5cbnZhciBTb3VyY2VNYXBHZW5lcmF0b3IgPSByZXF1aXJlKCcuL3NvdXJjZS1tYXAtZ2VuZXJhdG9yJykuU291cmNlTWFwR2VuZXJhdG9yO1xudmFyIHV0aWwgPSByZXF1aXJlKCcuL3V0aWwnKTtcblxuLy8gTWF0Y2hlcyBhIFdpbmRvd3Mtc3R5bGUgYFxcclxcbmAgbmV3bGluZSBvciBhIGBcXG5gIG5ld2xpbmUgdXNlZCBieSBhbGwgb3RoZXJcbi8vIG9wZXJhdGluZyBzeXN0ZW1zIHRoZXNlIGRheXMgKGNhcHR1cmluZyB0aGUgcmVzdWx0KS5cbnZhciBSRUdFWF9ORVdMSU5FID0gLyhcXHI/XFxuKS87XG5cbi8vIE5ld2xpbmUgY2hhcmFjdGVyIGNvZGUgZm9yIGNoYXJDb2RlQXQoKSBjb21wYXJpc29uc1xudmFyIE5FV0xJTkVfQ09ERSA9IDEwO1xuXG4vLyBQcml2YXRlIHN5bWJvbCBmb3IgaWRlbnRpZnlpbmcgYFNvdXJjZU5vZGVgcyB3aGVuIG11bHRpcGxlIHZlcnNpb25zIG9mXG4vLyB0aGUgc291cmNlLW1hcCBsaWJyYXJ5IGFyZSBsb2FkZWQuIFRoaXMgTVVTVCBOT1QgQ0hBTkdFIGFjcm9zc1xuLy8gdmVyc2lvbnMhXG52YXIgaXNTb3VyY2VOb2RlID0gXCIkJCRpc1NvdXJjZU5vZGUkJCRcIjtcblxuLyoqXG4gKiBTb3VyY2VOb2RlcyBwcm92aWRlIGEgd2F5IHRvIGFic3RyYWN0IG92ZXIgaW50ZXJwb2xhdGluZy9jb25jYXRlbmF0aW5nXG4gKiBzbmlwcGV0cyBvZiBnZW5lcmF0ZWQgSmF2YVNjcmlwdCBzb3VyY2UgY29kZSB3aGlsZSBtYWludGFpbmluZyB0aGUgbGluZSBhbmRcbiAqIGNvbHVtbiBpbmZvcm1hdGlvbiBhc3NvY2lhdGVkIHdpdGggdGhlIG9yaWdpbmFsIHNvdXJjZSBjb2RlLlxuICpcbiAqIEBwYXJhbSBhTGluZSBUaGUgb3JpZ2luYWwgbGluZSBudW1iZXIuXG4gKiBAcGFyYW0gYUNvbHVtbiBUaGUgb3JpZ2luYWwgY29sdW1uIG51bWJlci5cbiAqIEBwYXJhbSBhU291cmNlIFRoZSBvcmlnaW5hbCBzb3VyY2UncyBmaWxlbmFtZS5cbiAqIEBwYXJhbSBhQ2h1bmtzIE9wdGlvbmFsLiBBbiBhcnJheSBvZiBzdHJpbmdzIHdoaWNoIGFyZSBzbmlwcGV0cyBvZlxuICogICAgICAgIGdlbmVyYXRlZCBKUywgb3Igb3RoZXIgU291cmNlTm9kZXMuXG4gKiBAcGFyYW0gYU5hbWUgVGhlIG9yaWdpbmFsIGlkZW50aWZpZXIuXG4gKi9cbmZ1bmN0aW9uIFNvdXJjZU5vZGUoYUxpbmUsIGFDb2x1bW4sIGFTb3VyY2UsIGFDaHVua3MsIGFOYW1lKSB7XG4gIHRoaXMuY2hpbGRyZW4gPSBbXTtcbiAgdGhpcy5zb3VyY2VDb250ZW50cyA9IHt9O1xuICB0aGlzLmxpbmUgPSBhTGluZSA9PSBudWxsID8gbnVsbCA6IGFMaW5lO1xuICB0aGlzLmNvbHVtbiA9IGFDb2x1bW4gPT0gbnVsbCA/IG51bGwgOiBhQ29sdW1uO1xuICB0aGlzLnNvdXJjZSA9IGFTb3VyY2UgPT0gbnVsbCA/IG51bGwgOiBhU291cmNlO1xuICB0aGlzLm5hbWUgPSBhTmFtZSA9PSBudWxsID8gbnVsbCA6IGFOYW1lO1xuICB0aGlzW2lzU291cmNlTm9kZV0gPSB0cnVlO1xuICBpZiAoYUNodW5rcyAhPSBudWxsKSB0aGlzLmFkZChhQ2h1bmtzKTtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgU291cmNlTm9kZSBmcm9tIGdlbmVyYXRlZCBjb2RlIGFuZCBhIFNvdXJjZU1hcENvbnN1bWVyLlxuICpcbiAqIEBwYXJhbSBhR2VuZXJhdGVkQ29kZSBUaGUgZ2VuZXJhdGVkIGNvZGVcbiAqIEBwYXJhbSBhU291cmNlTWFwQ29uc3VtZXIgVGhlIFNvdXJjZU1hcCBmb3IgdGhlIGdlbmVyYXRlZCBjb2RlXG4gKiBAcGFyYW0gYVJlbGF0aXZlUGF0aCBPcHRpb25hbC4gVGhlIHBhdGggdGhhdCByZWxhdGl2ZSBzb3VyY2VzIGluIHRoZVxuICogICAgICAgIFNvdXJjZU1hcENvbnN1bWVyIHNob3VsZCBiZSByZWxhdGl2ZSB0by5cbiAqL1xuU291cmNlTm9kZS5mcm9tU3RyaW5nV2l0aFNvdXJjZU1hcCA9XG4gIGZ1bmN0aW9uIFNvdXJjZU5vZGVfZnJvbVN0cmluZ1dpdGhTb3VyY2VNYXAoYUdlbmVyYXRlZENvZGUsIGFTb3VyY2VNYXBDb25zdW1lciwgYVJlbGF0aXZlUGF0aCkge1xuICAgIC8vIFRoZSBTb3VyY2VOb2RlIHdlIHdhbnQgdG8gZmlsbCB3aXRoIHRoZSBnZW5lcmF0ZWQgY29kZVxuICAgIC8vIGFuZCB0aGUgU291cmNlTWFwXG4gICAgdmFyIG5vZGUgPSBuZXcgU291cmNlTm9kZSgpO1xuXG4gICAgLy8gQWxsIGV2ZW4gaW5kaWNlcyBvZiB0aGlzIGFycmF5IGFyZSBvbmUgbGluZSBvZiB0aGUgZ2VuZXJhdGVkIGNvZGUsXG4gICAgLy8gd2hpbGUgYWxsIG9kZCBpbmRpY2VzIGFyZSB0aGUgbmV3bGluZXMgYmV0d2VlbiB0d28gYWRqYWNlbnQgbGluZXNcbiAgICAvLyAoc2luY2UgYFJFR0VYX05FV0xJTkVgIGNhcHR1cmVzIGl0cyBtYXRjaCkuXG4gICAgLy8gUHJvY2Vzc2VkIGZyYWdtZW50cyBhcmUgYWNjZXNzZWQgYnkgY2FsbGluZyBgc2hpZnROZXh0TGluZWAuXG4gICAgdmFyIHJlbWFpbmluZ0xpbmVzID0gYUdlbmVyYXRlZENvZGUuc3BsaXQoUkVHRVhfTkVXTElORSk7XG4gICAgdmFyIHJlbWFpbmluZ0xpbmVzSW5kZXggPSAwO1xuICAgIHZhciBzaGlmdE5leHRMaW5lID0gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgbGluZUNvbnRlbnRzID0gZ2V0TmV4dExpbmUoKTtcbiAgICAgIC8vIFRoZSBsYXN0IGxpbmUgb2YgYSBmaWxlIG1pZ2h0IG5vdCBoYXZlIGEgbmV3bGluZS5cbiAgICAgIHZhciBuZXdMaW5lID0gZ2V0TmV4dExpbmUoKSB8fCBcIlwiO1xuICAgICAgcmV0dXJuIGxpbmVDb250ZW50cyArIG5ld0xpbmU7XG5cbiAgICAgIGZ1bmN0aW9uIGdldE5leHRMaW5lKCkge1xuICAgICAgICByZXR1cm4gcmVtYWluaW5nTGluZXNJbmRleCA8IHJlbWFpbmluZ0xpbmVzLmxlbmd0aCA/XG4gICAgICAgICAgICByZW1haW5pbmdMaW5lc1tyZW1haW5pbmdMaW5lc0luZGV4KytdIDogdW5kZWZpbmVkO1xuICAgICAgfVxuICAgIH07XG5cbiAgICAvLyBXZSBuZWVkIHRvIHJlbWVtYmVyIHRoZSBwb3NpdGlvbiBvZiBcInJlbWFpbmluZ0xpbmVzXCJcbiAgICB2YXIgbGFzdEdlbmVyYXRlZExpbmUgPSAxLCBsYXN0R2VuZXJhdGVkQ29sdW1uID0gMDtcblxuICAgIC8vIFRoZSBnZW5lcmF0ZSBTb3VyY2VOb2RlcyB3ZSBuZWVkIGEgY29kZSByYW5nZS5cbiAgICAvLyBUbyBleHRyYWN0IGl0IGN1cnJlbnQgYW5kIGxhc3QgbWFwcGluZyBpcyB1c2VkLlxuICAgIC8vIEhlcmUgd2Ugc3RvcmUgdGhlIGxhc3QgbWFwcGluZy5cbiAgICB2YXIgbGFzdE1hcHBpbmcgPSBudWxsO1xuXG4gICAgYVNvdXJjZU1hcENvbnN1bWVyLmVhY2hNYXBwaW5nKGZ1bmN0aW9uIChtYXBwaW5nKSB7XG4gICAgICBpZiAobGFzdE1hcHBpbmcgIT09IG51bGwpIHtcbiAgICAgICAgLy8gV2UgYWRkIHRoZSBjb2RlIGZyb20gXCJsYXN0TWFwcGluZ1wiIHRvIFwibWFwcGluZ1wiOlxuICAgICAgICAvLyBGaXJzdCBjaGVjayBpZiB0aGVyZSBpcyBhIG5ldyBsaW5lIGluIGJldHdlZW4uXG4gICAgICAgIGlmIChsYXN0R2VuZXJhdGVkTGluZSA8IG1hcHBpbmcuZ2VuZXJhdGVkTGluZSkge1xuICAgICAgICAgIC8vIEFzc29jaWF0ZSBmaXJzdCBsaW5lIHdpdGggXCJsYXN0TWFwcGluZ1wiXG4gICAgICAgICAgYWRkTWFwcGluZ1dpdGhDb2RlKGxhc3RNYXBwaW5nLCBzaGlmdE5leHRMaW5lKCkpO1xuICAgICAgICAgIGxhc3RHZW5lcmF0ZWRMaW5lKys7XG4gICAgICAgICAgbGFzdEdlbmVyYXRlZENvbHVtbiA9IDA7XG4gICAgICAgICAgLy8gVGhlIHJlbWFpbmluZyBjb2RlIGlzIGFkZGVkIHdpdGhvdXQgbWFwcGluZ1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIFRoZXJlIGlzIG5vIG5ldyBsaW5lIGluIGJldHdlZW4uXG4gICAgICAgICAgLy8gQXNzb2NpYXRlIHRoZSBjb2RlIGJldHdlZW4gXCJsYXN0R2VuZXJhdGVkQ29sdW1uXCIgYW5kXG4gICAgICAgICAgLy8gXCJtYXBwaW5nLmdlbmVyYXRlZENvbHVtblwiIHdpdGggXCJsYXN0TWFwcGluZ1wiXG4gICAgICAgICAgdmFyIG5leHRMaW5lID0gcmVtYWluaW5nTGluZXNbcmVtYWluaW5nTGluZXNJbmRleF0gfHwgJyc7XG4gICAgICAgICAgdmFyIGNvZGUgPSBuZXh0TGluZS5zdWJzdHIoMCwgbWFwcGluZy5nZW5lcmF0ZWRDb2x1bW4gLVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxhc3RHZW5lcmF0ZWRDb2x1bW4pO1xuICAgICAgICAgIHJlbWFpbmluZ0xpbmVzW3JlbWFpbmluZ0xpbmVzSW5kZXhdID0gbmV4dExpbmUuc3Vic3RyKG1hcHBpbmcuZ2VuZXJhdGVkQ29sdW1uIC1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsYXN0R2VuZXJhdGVkQ29sdW1uKTtcbiAgICAgICAgICBsYXN0R2VuZXJhdGVkQ29sdW1uID0gbWFwcGluZy5nZW5lcmF0ZWRDb2x1bW47XG4gICAgICAgICAgYWRkTWFwcGluZ1dpdGhDb2RlKGxhc3RNYXBwaW5nLCBjb2RlKTtcbiAgICAgICAgICAvLyBObyBtb3JlIHJlbWFpbmluZyBjb2RlLCBjb250aW51ZVxuICAgICAgICAgIGxhc3RNYXBwaW5nID0gbWFwcGluZztcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIC8vIFdlIGFkZCB0aGUgZ2VuZXJhdGVkIGNvZGUgdW50aWwgdGhlIGZpcnN0IG1hcHBpbmdcbiAgICAgIC8vIHRvIHRoZSBTb3VyY2VOb2RlIHdpdGhvdXQgYW55IG1hcHBpbmcuXG4gICAgICAvLyBFYWNoIGxpbmUgaXMgYWRkZWQgYXMgc2VwYXJhdGUgc3RyaW5nLlxuICAgICAgd2hpbGUgKGxhc3RHZW5lcmF0ZWRMaW5lIDwgbWFwcGluZy5nZW5lcmF0ZWRMaW5lKSB7XG4gICAgICAgIG5vZGUuYWRkKHNoaWZ0TmV4dExpbmUoKSk7XG4gICAgICAgIGxhc3RHZW5lcmF0ZWRMaW5lKys7XG4gICAgICB9XG4gICAgICBpZiAobGFzdEdlbmVyYXRlZENvbHVtbiA8IG1hcHBpbmcuZ2VuZXJhdGVkQ29sdW1uKSB7XG4gICAgICAgIHZhciBuZXh0TGluZSA9IHJlbWFpbmluZ0xpbmVzW3JlbWFpbmluZ0xpbmVzSW5kZXhdIHx8ICcnO1xuICAgICAgICBub2RlLmFkZChuZXh0TGluZS5zdWJzdHIoMCwgbWFwcGluZy5nZW5lcmF0ZWRDb2x1bW4pKTtcbiAgICAgICAgcmVtYWluaW5nTGluZXNbcmVtYWluaW5nTGluZXNJbmRleF0gPSBuZXh0TGluZS5zdWJzdHIobWFwcGluZy5nZW5lcmF0ZWRDb2x1bW4pO1xuICAgICAgICBsYXN0R2VuZXJhdGVkQ29sdW1uID0gbWFwcGluZy5nZW5lcmF0ZWRDb2x1bW47XG4gICAgICB9XG4gICAgICBsYXN0TWFwcGluZyA9IG1hcHBpbmc7XG4gICAgfSwgdGhpcyk7XG4gICAgLy8gV2UgaGF2ZSBwcm9jZXNzZWQgYWxsIG1hcHBpbmdzLlxuICAgIGlmIChyZW1haW5pbmdMaW5lc0luZGV4IDwgcmVtYWluaW5nTGluZXMubGVuZ3RoKSB7XG4gICAgICBpZiAobGFzdE1hcHBpbmcpIHtcbiAgICAgICAgLy8gQXNzb2NpYXRlIHRoZSByZW1haW5pbmcgY29kZSBpbiB0aGUgY3VycmVudCBsaW5lIHdpdGggXCJsYXN0TWFwcGluZ1wiXG4gICAgICAgIGFkZE1hcHBpbmdXaXRoQ29kZShsYXN0TWFwcGluZywgc2hpZnROZXh0TGluZSgpKTtcbiAgICAgIH1cbiAgICAgIC8vIGFuZCBhZGQgdGhlIHJlbWFpbmluZyBsaW5lcyB3aXRob3V0IGFueSBtYXBwaW5nXG4gICAgICBub2RlLmFkZChyZW1haW5pbmdMaW5lcy5zcGxpY2UocmVtYWluaW5nTGluZXNJbmRleCkuam9pbihcIlwiKSk7XG4gICAgfVxuXG4gICAgLy8gQ29weSBzb3VyY2VzQ29udGVudCBpbnRvIFNvdXJjZU5vZGVcbiAgICBhU291cmNlTWFwQ29uc3VtZXIuc291cmNlcy5mb3JFYWNoKGZ1bmN0aW9uIChzb3VyY2VGaWxlKSB7XG4gICAgICB2YXIgY29udGVudCA9IGFTb3VyY2VNYXBDb25zdW1lci5zb3VyY2VDb250ZW50Rm9yKHNvdXJjZUZpbGUpO1xuICAgICAgaWYgKGNvbnRlbnQgIT0gbnVsbCkge1xuICAgICAgICBpZiAoYVJlbGF0aXZlUGF0aCAhPSBudWxsKSB7XG4gICAgICAgICAgc291cmNlRmlsZSA9IHV0aWwuam9pbihhUmVsYXRpdmVQYXRoLCBzb3VyY2VGaWxlKTtcbiAgICAgICAgfVxuICAgICAgICBub2RlLnNldFNvdXJjZUNvbnRlbnQoc291cmNlRmlsZSwgY29udGVudCk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICByZXR1cm4gbm9kZTtcblxuICAgIGZ1bmN0aW9uIGFkZE1hcHBpbmdXaXRoQ29kZShtYXBwaW5nLCBjb2RlKSB7XG4gICAgICBpZiAobWFwcGluZyA9PT0gbnVsbCB8fCBtYXBwaW5nLnNvdXJjZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIG5vZGUuYWRkKGNvZGUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIHNvdXJjZSA9IGFSZWxhdGl2ZVBhdGhcbiAgICAgICAgICA/IHV0aWwuam9pbihhUmVsYXRpdmVQYXRoLCBtYXBwaW5nLnNvdXJjZSlcbiAgICAgICAgICA6IG1hcHBpbmcuc291cmNlO1xuICAgICAgICBub2RlLmFkZChuZXcgU291cmNlTm9kZShtYXBwaW5nLm9yaWdpbmFsTGluZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWFwcGluZy5vcmlnaW5hbENvbHVtbixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc291cmNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2RlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXBwaW5nLm5hbWUpKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbi8qKlxuICogQWRkIGEgY2h1bmsgb2YgZ2VuZXJhdGVkIEpTIHRvIHRoaXMgc291cmNlIG5vZGUuXG4gKlxuICogQHBhcmFtIGFDaHVuayBBIHN0cmluZyBzbmlwcGV0IG9mIGdlbmVyYXRlZCBKUyBjb2RlLCBhbm90aGVyIGluc3RhbmNlIG9mXG4gKiAgICAgICAgU291cmNlTm9kZSwgb3IgYW4gYXJyYXkgd2hlcmUgZWFjaCBtZW1iZXIgaXMgb25lIG9mIHRob3NlIHRoaW5ncy5cbiAqL1xuU291cmNlTm9kZS5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24gU291cmNlTm9kZV9hZGQoYUNodW5rKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KGFDaHVuaykpIHtcbiAgICBhQ2h1bmsuZm9yRWFjaChmdW5jdGlvbiAoY2h1bmspIHtcbiAgICAgIHRoaXMuYWRkKGNodW5rKTtcbiAgICB9LCB0aGlzKTtcbiAgfVxuICBlbHNlIGlmIChhQ2h1bmtbaXNTb3VyY2VOb2RlXSB8fCB0eXBlb2YgYUNodW5rID09PSBcInN0cmluZ1wiKSB7XG4gICAgaWYgKGFDaHVuaykge1xuICAgICAgdGhpcy5jaGlsZHJlbi5wdXNoKGFDaHVuayk7XG4gICAgfVxuICB9XG4gIGVsc2Uge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgICBcIkV4cGVjdGVkIGEgU291cmNlTm9kZSwgc3RyaW5nLCBvciBhbiBhcnJheSBvZiBTb3VyY2VOb2RlcyBhbmQgc3RyaW5ncy4gR290IFwiICsgYUNodW5rXG4gICAgKTtcbiAgfVxuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogQWRkIGEgY2h1bmsgb2YgZ2VuZXJhdGVkIEpTIHRvIHRoZSBiZWdpbm5pbmcgb2YgdGhpcyBzb3VyY2Ugbm9kZS5cbiAqXG4gKiBAcGFyYW0gYUNodW5rIEEgc3RyaW5nIHNuaXBwZXQgb2YgZ2VuZXJhdGVkIEpTIGNvZGUsIGFub3RoZXIgaW5zdGFuY2Ugb2ZcbiAqICAgICAgICBTb3VyY2VOb2RlLCBvciBhbiBhcnJheSB3aGVyZSBlYWNoIG1lbWJlciBpcyBvbmUgb2YgdGhvc2UgdGhpbmdzLlxuICovXG5Tb3VyY2VOb2RlLnByb3RvdHlwZS5wcmVwZW5kID0gZnVuY3Rpb24gU291cmNlTm9kZV9wcmVwZW5kKGFDaHVuaykge1xuICBpZiAoQXJyYXkuaXNBcnJheShhQ2h1bmspKSB7XG4gICAgZm9yICh2YXIgaSA9IGFDaHVuay5sZW5ndGgtMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgIHRoaXMucHJlcGVuZChhQ2h1bmtbaV0pO1xuICAgIH1cbiAgfVxuICBlbHNlIGlmIChhQ2h1bmtbaXNTb3VyY2VOb2RlXSB8fCB0eXBlb2YgYUNodW5rID09PSBcInN0cmluZ1wiKSB7XG4gICAgdGhpcy5jaGlsZHJlbi51bnNoaWZ0KGFDaHVuayk7XG4gIH1cbiAgZWxzZSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgIFwiRXhwZWN0ZWQgYSBTb3VyY2VOb2RlLCBzdHJpbmcsIG9yIGFuIGFycmF5IG9mIFNvdXJjZU5vZGVzIGFuZCBzdHJpbmdzLiBHb3QgXCIgKyBhQ2h1bmtcbiAgICApO1xuICB9XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBXYWxrIG92ZXIgdGhlIHRyZWUgb2YgSlMgc25pcHBldHMgaW4gdGhpcyBub2RlIGFuZCBpdHMgY2hpbGRyZW4uIFRoZVxuICogd2Fsa2luZyBmdW5jdGlvbiBpcyBjYWxsZWQgb25jZSBmb3IgZWFjaCBzbmlwcGV0IG9mIEpTIGFuZCBpcyBwYXNzZWQgdGhhdFxuICogc25pcHBldCBhbmQgdGhlIGl0cyBvcmlnaW5hbCBhc3NvY2lhdGVkIHNvdXJjZSdzIGxpbmUvY29sdW1uIGxvY2F0aW9uLlxuICpcbiAqIEBwYXJhbSBhRm4gVGhlIHRyYXZlcnNhbCBmdW5jdGlvbi5cbiAqL1xuU291cmNlTm9kZS5wcm90b3R5cGUud2FsayA9IGZ1bmN0aW9uIFNvdXJjZU5vZGVfd2FsayhhRm4pIHtcbiAgdmFyIGNodW5rO1xuICBmb3IgKHZhciBpID0gMCwgbGVuID0gdGhpcy5jaGlsZHJlbi5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgIGNodW5rID0gdGhpcy5jaGlsZHJlbltpXTtcbiAgICBpZiAoY2h1bmtbaXNTb3VyY2VOb2RlXSkge1xuICAgICAgY2h1bmsud2FsayhhRm4pO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIGlmIChjaHVuayAhPT0gJycpIHtcbiAgICAgICAgYUZuKGNodW5rLCB7IHNvdXJjZTogdGhpcy5zb3VyY2UsXG4gICAgICAgICAgICAgICAgICAgICBsaW5lOiB0aGlzLmxpbmUsXG4gICAgICAgICAgICAgICAgICAgICBjb2x1bW46IHRoaXMuY29sdW1uLFxuICAgICAgICAgICAgICAgICAgICAgbmFtZTogdGhpcy5uYW1lIH0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxufTtcblxuLyoqXG4gKiBMaWtlIGBTdHJpbmcucHJvdG90eXBlLmpvaW5gIGV4Y2VwdCBmb3IgU291cmNlTm9kZXMuIEluc2VydHMgYGFTdHJgIGJldHdlZW5cbiAqIGVhY2ggb2YgYHRoaXMuY2hpbGRyZW5gLlxuICpcbiAqIEBwYXJhbSBhU2VwIFRoZSBzZXBhcmF0b3IuXG4gKi9cblNvdXJjZU5vZGUucHJvdG90eXBlLmpvaW4gPSBmdW5jdGlvbiBTb3VyY2VOb2RlX2pvaW4oYVNlcCkge1xuICB2YXIgbmV3Q2hpbGRyZW47XG4gIHZhciBpO1xuICB2YXIgbGVuID0gdGhpcy5jaGlsZHJlbi5sZW5ndGg7XG4gIGlmIChsZW4gPiAwKSB7XG4gICAgbmV3Q2hpbGRyZW4gPSBbXTtcbiAgICBmb3IgKGkgPSAwOyBpIDwgbGVuLTE7IGkrKykge1xuICAgICAgbmV3Q2hpbGRyZW4ucHVzaCh0aGlzLmNoaWxkcmVuW2ldKTtcbiAgICAgIG5ld0NoaWxkcmVuLnB1c2goYVNlcCk7XG4gICAgfVxuICAgIG5ld0NoaWxkcmVuLnB1c2godGhpcy5jaGlsZHJlbltpXSk7XG4gICAgdGhpcy5jaGlsZHJlbiA9IG5ld0NoaWxkcmVuO1xuICB9XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBDYWxsIFN0cmluZy5wcm90b3R5cGUucmVwbGFjZSBvbiB0aGUgdmVyeSByaWdodC1tb3N0IHNvdXJjZSBzbmlwcGV0LiBVc2VmdWxcbiAqIGZvciB0cmltbWluZyB3aGl0ZXNwYWNlIGZyb20gdGhlIGVuZCBvZiBhIHNvdXJjZSBub2RlLCBldGMuXG4gKlxuICogQHBhcmFtIGFQYXR0ZXJuIFRoZSBwYXR0ZXJuIHRvIHJlcGxhY2UuXG4gKiBAcGFyYW0gYVJlcGxhY2VtZW50IFRoZSB0aGluZyB0byByZXBsYWNlIHRoZSBwYXR0ZXJuIHdpdGguXG4gKi9cblNvdXJjZU5vZGUucHJvdG90eXBlLnJlcGxhY2VSaWdodCA9IGZ1bmN0aW9uIFNvdXJjZU5vZGVfcmVwbGFjZVJpZ2h0KGFQYXR0ZXJuLCBhUmVwbGFjZW1lbnQpIHtcbiAgdmFyIGxhc3RDaGlsZCA9IHRoaXMuY2hpbGRyZW5bdGhpcy5jaGlsZHJlbi5sZW5ndGggLSAxXTtcbiAgaWYgKGxhc3RDaGlsZFtpc1NvdXJjZU5vZGVdKSB7XG4gICAgbGFzdENoaWxkLnJlcGxhY2VSaWdodChhUGF0dGVybiwgYVJlcGxhY2VtZW50KTtcbiAgfVxuICBlbHNlIGlmICh0eXBlb2YgbGFzdENoaWxkID09PSAnc3RyaW5nJykge1xuICAgIHRoaXMuY2hpbGRyZW5bdGhpcy5jaGlsZHJlbi5sZW5ndGggLSAxXSA9IGxhc3RDaGlsZC5yZXBsYWNlKGFQYXR0ZXJuLCBhUmVwbGFjZW1lbnQpO1xuICB9XG4gIGVsc2Uge1xuICAgIHRoaXMuY2hpbGRyZW4ucHVzaCgnJy5yZXBsYWNlKGFQYXR0ZXJuLCBhUmVwbGFjZW1lbnQpKTtcbiAgfVxuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogU2V0IHRoZSBzb3VyY2UgY29udGVudCBmb3IgYSBzb3VyY2UgZmlsZS4gVGhpcyB3aWxsIGJlIGFkZGVkIHRvIHRoZSBTb3VyY2VNYXBHZW5lcmF0b3JcbiAqIGluIHRoZSBzb3VyY2VzQ29udGVudCBmaWVsZC5cbiAqXG4gKiBAcGFyYW0gYVNvdXJjZUZpbGUgVGhlIGZpbGVuYW1lIG9mIHRoZSBzb3VyY2UgZmlsZVxuICogQHBhcmFtIGFTb3VyY2VDb250ZW50IFRoZSBjb250ZW50IG9mIHRoZSBzb3VyY2UgZmlsZVxuICovXG5Tb3VyY2VOb2RlLnByb3RvdHlwZS5zZXRTb3VyY2VDb250ZW50ID1cbiAgZnVuY3Rpb24gU291cmNlTm9kZV9zZXRTb3VyY2VDb250ZW50KGFTb3VyY2VGaWxlLCBhU291cmNlQ29udGVudCkge1xuICAgIHRoaXMuc291cmNlQ29udGVudHNbdXRpbC50b1NldFN0cmluZyhhU291cmNlRmlsZSldID0gYVNvdXJjZUNvbnRlbnQ7XG4gIH07XG5cbi8qKlxuICogV2FsayBvdmVyIHRoZSB0cmVlIG9mIFNvdXJjZU5vZGVzLiBUaGUgd2Fsa2luZyBmdW5jdGlvbiBpcyBjYWxsZWQgZm9yIGVhY2hcbiAqIHNvdXJjZSBmaWxlIGNvbnRlbnQgYW5kIGlzIHBhc3NlZCB0aGUgZmlsZW5hbWUgYW5kIHNvdXJjZSBjb250ZW50LlxuICpcbiAqIEBwYXJhbSBhRm4gVGhlIHRyYXZlcnNhbCBmdW5jdGlvbi5cbiAqL1xuU291cmNlTm9kZS5wcm90b3R5cGUud2Fsa1NvdXJjZUNvbnRlbnRzID1cbiAgZnVuY3Rpb24gU291cmNlTm9kZV93YWxrU291cmNlQ29udGVudHMoYUZuKSB7XG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHRoaXMuY2hpbGRyZW4ubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIGlmICh0aGlzLmNoaWxkcmVuW2ldW2lzU291cmNlTm9kZV0pIHtcbiAgICAgICAgdGhpcy5jaGlsZHJlbltpXS53YWxrU291cmNlQ29udGVudHMoYUZuKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgc291cmNlcyA9IE9iamVjdC5rZXlzKHRoaXMuc291cmNlQ29udGVudHMpO1xuICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBzb3VyY2VzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICBhRm4odXRpbC5mcm9tU2V0U3RyaW5nKHNvdXJjZXNbaV0pLCB0aGlzLnNvdXJjZUNvbnRlbnRzW3NvdXJjZXNbaV1dKTtcbiAgICB9XG4gIH07XG5cbi8qKlxuICogUmV0dXJuIHRoZSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhpcyBzb3VyY2Ugbm9kZS4gV2Fsa3Mgb3ZlciB0aGUgdHJlZVxuICogYW5kIGNvbmNhdGVuYXRlcyBhbGwgdGhlIHZhcmlvdXMgc25pcHBldHMgdG9nZXRoZXIgdG8gb25lIHN0cmluZy5cbiAqL1xuU291cmNlTm9kZS5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiBTb3VyY2VOb2RlX3RvU3RyaW5nKCkge1xuICB2YXIgc3RyID0gXCJcIjtcbiAgdGhpcy53YWxrKGZ1bmN0aW9uIChjaHVuaykge1xuICAgIHN0ciArPSBjaHVuaztcbiAgfSk7XG4gIHJldHVybiBzdHI7XG59O1xuXG4vKipcbiAqIFJldHVybnMgdGhlIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGlzIHNvdXJjZSBub2RlIGFsb25nIHdpdGggYSBzb3VyY2VcbiAqIG1hcC5cbiAqL1xuU291cmNlTm9kZS5wcm90b3R5cGUudG9TdHJpbmdXaXRoU291cmNlTWFwID0gZnVuY3Rpb24gU291cmNlTm9kZV90b1N0cmluZ1dpdGhTb3VyY2VNYXAoYUFyZ3MpIHtcbiAgdmFyIGdlbmVyYXRlZCA9IHtcbiAgICBjb2RlOiBcIlwiLFxuICAgIGxpbmU6IDEsXG4gICAgY29sdW1uOiAwXG4gIH07XG4gIHZhciBtYXAgPSBuZXcgU291cmNlTWFwR2VuZXJhdG9yKGFBcmdzKTtcbiAgdmFyIHNvdXJjZU1hcHBpbmdBY3RpdmUgPSBmYWxzZTtcbiAgdmFyIGxhc3RPcmlnaW5hbFNvdXJjZSA9IG51bGw7XG4gIHZhciBsYXN0T3JpZ2luYWxMaW5lID0gbnVsbDtcbiAgdmFyIGxhc3RPcmlnaW5hbENvbHVtbiA9IG51bGw7XG4gIHZhciBsYXN0T3JpZ2luYWxOYW1lID0gbnVsbDtcbiAgdGhpcy53YWxrKGZ1bmN0aW9uIChjaHVuaywgb3JpZ2luYWwpIHtcbiAgICBnZW5lcmF0ZWQuY29kZSArPSBjaHVuaztcbiAgICBpZiAob3JpZ2luYWwuc291cmNlICE9PSBudWxsXG4gICAgICAgICYmIG9yaWdpbmFsLmxpbmUgIT09IG51bGxcbiAgICAgICAgJiYgb3JpZ2luYWwuY29sdW1uICE9PSBudWxsKSB7XG4gICAgICBpZihsYXN0T3JpZ2luYWxTb3VyY2UgIT09IG9yaWdpbmFsLnNvdXJjZVxuICAgICAgICAgfHwgbGFzdE9yaWdpbmFsTGluZSAhPT0gb3JpZ2luYWwubGluZVxuICAgICAgICAgfHwgbGFzdE9yaWdpbmFsQ29sdW1uICE9PSBvcmlnaW5hbC5jb2x1bW5cbiAgICAgICAgIHx8IGxhc3RPcmlnaW5hbE5hbWUgIT09IG9yaWdpbmFsLm5hbWUpIHtcbiAgICAgICAgbWFwLmFkZE1hcHBpbmcoe1xuICAgICAgICAgIHNvdXJjZTogb3JpZ2luYWwuc291cmNlLFxuICAgICAgICAgIG9yaWdpbmFsOiB7XG4gICAgICAgICAgICBsaW5lOiBvcmlnaW5hbC5saW5lLFxuICAgICAgICAgICAgY29sdW1uOiBvcmlnaW5hbC5jb2x1bW5cbiAgICAgICAgICB9LFxuICAgICAgICAgIGdlbmVyYXRlZDoge1xuICAgICAgICAgICAgbGluZTogZ2VuZXJhdGVkLmxpbmUsXG4gICAgICAgICAgICBjb2x1bW46IGdlbmVyYXRlZC5jb2x1bW5cbiAgICAgICAgICB9LFxuICAgICAgICAgIG5hbWU6IG9yaWdpbmFsLm5hbWVcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBsYXN0T3JpZ2luYWxTb3VyY2UgPSBvcmlnaW5hbC5zb3VyY2U7XG4gICAgICBsYXN0T3JpZ2luYWxMaW5lID0gb3JpZ2luYWwubGluZTtcbiAgICAgIGxhc3RPcmlnaW5hbENvbHVtbiA9IG9yaWdpbmFsLmNvbHVtbjtcbiAgICAgIGxhc3RPcmlnaW5hbE5hbWUgPSBvcmlnaW5hbC5uYW1lO1xuICAgICAgc291cmNlTWFwcGluZ0FjdGl2ZSA9IHRydWU7XG4gICAgfSBlbHNlIGlmIChzb3VyY2VNYXBwaW5nQWN0aXZlKSB7XG4gICAgICBtYXAuYWRkTWFwcGluZyh7XG4gICAgICAgIGdlbmVyYXRlZDoge1xuICAgICAgICAgIGxpbmU6IGdlbmVyYXRlZC5saW5lLFxuICAgICAgICAgIGNvbHVtbjogZ2VuZXJhdGVkLmNvbHVtblxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIGxhc3RPcmlnaW5hbFNvdXJjZSA9IG51bGw7XG4gICAgICBzb3VyY2VNYXBwaW5nQWN0aXZlID0gZmFsc2U7XG4gICAgfVxuICAgIGZvciAodmFyIGlkeCA9IDAsIGxlbmd0aCA9IGNodW5rLmxlbmd0aDsgaWR4IDwgbGVuZ3RoOyBpZHgrKykge1xuICAgICAgaWYgKGNodW5rLmNoYXJDb2RlQXQoaWR4KSA9PT0gTkVXTElORV9DT0RFKSB7XG4gICAgICAgIGdlbmVyYXRlZC5saW5lKys7XG4gICAgICAgIGdlbmVyYXRlZC5jb2x1bW4gPSAwO1xuICAgICAgICAvLyBNYXBwaW5ncyBlbmQgYXQgZW9sXG4gICAgICAgIGlmIChpZHggKyAxID09PSBsZW5ndGgpIHtcbiAgICAgICAgICBsYXN0T3JpZ2luYWxTb3VyY2UgPSBudWxsO1xuICAgICAgICAgIHNvdXJjZU1hcHBpbmdBY3RpdmUgPSBmYWxzZTtcbiAgICAgICAgfSBlbHNlIGlmIChzb3VyY2VNYXBwaW5nQWN0aXZlKSB7XG4gICAgICAgICAgbWFwLmFkZE1hcHBpbmcoe1xuICAgICAgICAgICAgc291cmNlOiBvcmlnaW5hbC5zb3VyY2UsXG4gICAgICAgICAgICBvcmlnaW5hbDoge1xuICAgICAgICAgICAgICBsaW5lOiBvcmlnaW5hbC5saW5lLFxuICAgICAgICAgICAgICBjb2x1bW46IG9yaWdpbmFsLmNvbHVtblxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGdlbmVyYXRlZDoge1xuICAgICAgICAgICAgICBsaW5lOiBnZW5lcmF0ZWQubGluZSxcbiAgICAgICAgICAgICAgY29sdW1uOiBnZW5lcmF0ZWQuY29sdW1uXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgbmFtZTogb3JpZ2luYWwubmFtZVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBnZW5lcmF0ZWQuY29sdW1uKys7XG4gICAgICB9XG4gICAgfVxuICB9KTtcbiAgdGhpcy53YWxrU291cmNlQ29udGVudHMoZnVuY3Rpb24gKHNvdXJjZUZpbGUsIHNvdXJjZUNvbnRlbnQpIHtcbiAgICBtYXAuc2V0U291cmNlQ29udGVudChzb3VyY2VGaWxlLCBzb3VyY2VDb250ZW50KTtcbiAgfSk7XG5cbiAgcmV0dXJuIHsgY29kZTogZ2VuZXJhdGVkLmNvZGUsIG1hcDogbWFwIH07XG59O1xuXG5leHBvcnRzLlNvdXJjZU5vZGUgPSBTb3VyY2VOb2RlO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2VsZWN0cm9uLXVwZGF0ZXIvbm9kZV9tb2R1bGVzL3NvdXJjZS1tYXAvbGliL3NvdXJjZS1ub2RlLmpzIiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwibW9kdWxlXCIpO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIGV4dGVybmFsIFwibW9kdWxlXCJcbi8vIG1vZHVsZSBpZCA9IDE2OFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5FbGVjdHJvbkh0dHBFeGVjdXRvciA9IHVuZGVmaW5lZDtcblxudmFyIF9ibHVlYmlyZExzdDtcblxuZnVuY3Rpb24gX2xvYWRfYmx1ZWJpcmRMc3QoKSB7XG4gICAgcmV0dXJuIF9ibHVlYmlyZExzdCA9IHJlcXVpcmUoXCJibHVlYmlyZC1sc3RcIik7XG59XG5cbnZhciBfYnVpbGRlclV0aWxSdW50aW1lO1xuXG5mdW5jdGlvbiBfbG9hZF9idWlsZGVyVXRpbFJ1bnRpbWUoKSB7XG4gICAgcmV0dXJuIF9idWlsZGVyVXRpbFJ1bnRpbWUgPSByZXF1aXJlKFwiYnVpbGRlci11dGlsLXJ1bnRpbWVcIik7XG59XG5cbnZhciBfZWxlY3Ryb247XG5cbmZ1bmN0aW9uIF9sb2FkX2VsZWN0cm9uKCkge1xuICAgIHJldHVybiBfZWxlY3Ryb24gPSByZXF1aXJlKFwiZWxlY3Ryb25cIik7XG59XG5cbnZhciBfZnNFeHRyYVA7XG5cbmZ1bmN0aW9uIF9sb2FkX2ZzRXh0cmFQKCkge1xuICAgIHJldHVybiBfZnNFeHRyYVAgPSByZXF1aXJlKFwiZnMtZXh0cmEtcFwiKTtcbn1cblxudmFyIF9wYXRoID0gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQocmVxdWlyZShcInBhdGhcIikpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChvYmopIHsgaWYgKG9iaiAmJiBvYmouX19lc01vZHVsZSkgeyByZXR1cm4gb2JqOyB9IGVsc2UgeyB2YXIgbmV3T2JqID0ge307IGlmIChvYmogIT0gbnVsbCkgeyBmb3IgKHZhciBrZXkgaW4gb2JqKSB7IGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBrZXkpKSBuZXdPYmpba2V5XSA9IG9ialtrZXldOyB9IH0gbmV3T2JqLmRlZmF1bHQgPSBvYmo7IHJldHVybiBuZXdPYmo7IH0gfVxuXG5jbGFzcyBFbGVjdHJvbkh0dHBFeGVjdXRvciBleHRlbmRzIChfYnVpbGRlclV0aWxSdW50aW1lIHx8IF9sb2FkX2J1aWxkZXJVdGlsUnVudGltZSgpKS5IdHRwRXhlY3V0b3Ige1xuICAgIGNvbnN0cnVjdG9yKHByb3h5TG9naW5DYWxsYmFjaykge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLnByb3h5TG9naW5DYWxsYmFjayA9IHByb3h5TG9naW5DYWxsYmFjaztcbiAgICB9XG4gICAgZG93bmxvYWQodXJsLCBkZXN0aW5hdGlvbiwgb3B0aW9ucykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgICAgIHJldHVybiAoMCwgKF9ibHVlYmlyZExzdCB8fCBfbG9hZF9ibHVlYmlyZExzdCgpKS5jb3JvdXRpbmUpKGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBpZiAob3B0aW9ucyA9PSBudWxsIHx8ICFvcHRpb25zLnNraXBEaXJDcmVhdGlvbikge1xuICAgICAgICAgICAgICAgIHlpZWxkICgwLCAoX2ZzRXh0cmFQIHx8IF9sb2FkX2ZzRXh0cmFQKCkpLmVuc3VyZURpcikoX3BhdGguZGlybmFtZShkZXN0aW5hdGlvbikpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHlpZWxkIG9wdGlvbnMuY2FuY2VsbGF0aW9uVG9rZW4uY3JlYXRlUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0LCBvbkNhbmNlbCkge1xuICAgICAgICAgICAgICAgIF90aGlzLmRvRG93bmxvYWQoT2JqZWN0LmFzc2lnbih7fSwgKDAsIChfYnVpbGRlclV0aWxSdW50aW1lIHx8IF9sb2FkX2J1aWxkZXJVdGlsUnVudGltZSgpKS5jb25maWd1cmVSZXF1ZXN0T3B0aW9uc0Zyb21VcmwpKHVybCwge1xuICAgICAgICAgICAgICAgICAgICBoZWFkZXJzOiBvcHRpb25zLmhlYWRlcnMgfHwgdW5kZWZpbmVkXG4gICAgICAgICAgICAgICAgfSksIHsgcmVkaXJlY3Q6IFwibWFudWFsXCIgfSksIGRlc3RpbmF0aW9uLCAwLCBvcHRpb25zLCBmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGVycm9yID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmUoZGVzdGluYXRpb24pO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVqZWN0KGVycm9yKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0sIG9uQ2FuY2VsKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KSgpO1xuICAgIH1cbiAgICBkb1JlcXVlc3Qob3B0aW9ucywgY2FsbGJhY2spIHtcbiAgICAgICAgY29uc3QgcmVxdWVzdCA9IChfZWxlY3Ryb24gfHwgX2xvYWRfZWxlY3Ryb24oKSkubmV0LnJlcXVlc3Qob3B0aW9ucyk7XG4gICAgICAgIHJlcXVlc3Qub24oXCJyZXNwb25zZVwiLCBjYWxsYmFjayk7XG4gICAgICAgIHRoaXMuYWRkUHJveHlMb2dpbkhhbmRsZXIocmVxdWVzdCk7XG4gICAgICAgIHJldHVybiByZXF1ZXN0O1xuICAgIH1cbiAgICBhZGRQcm94eUxvZ2luSGFuZGxlcihyZXF1ZXN0KSB7XG4gICAgICAgIGlmICh0aGlzLnByb3h5TG9naW5DYWxsYmFjayAhPSBudWxsKSB7XG4gICAgICAgICAgICByZXF1ZXN0Lm9uKFwibG9naW5cIiwgdGhpcy5wcm94eUxvZ2luQ2FsbGJhY2spO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFkZFJlZGlyZWN0SGFuZGxlcnMocmVxdWVzdCwgb3B0aW9ucywgcmVqZWN0LCByZWRpcmVjdENvdW50LCBoYW5kbGVyKSB7XG4gICAgICAgIHJlcXVlc3Qub24oXCJyZWRpcmVjdFwiLCAoc3RhdHVzQ29kZSwgbWV0aG9kLCByZWRpcmVjdFVybCkgPT4ge1xuICAgICAgICAgICAgaWYgKHJlZGlyZWN0Q291bnQgPiAxMCkge1xuICAgICAgICAgICAgICAgIHJlamVjdChuZXcgRXJyb3IoXCJUb28gbWFueSByZWRpcmVjdHMgKD4gMTApXCIpKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBoYW5kbGVyKChfYnVpbGRlclV0aWxSdW50aW1lIHx8IF9sb2FkX2J1aWxkZXJVdGlsUnVudGltZSgpKS5IdHRwRXhlY3V0b3IucHJlcGFyZVJlZGlyZWN0VXJsT3B0aW9ucyhyZWRpcmVjdFVybCwgb3B0aW9ucykpO1xuICAgICAgICB9KTtcbiAgICB9XG59XG5leHBvcnRzLkVsZWN0cm9uSHR0cEV4ZWN1dG9yID0gRWxlY3Ryb25IdHRwRXhlY3V0b3I7IC8vIyBzb3VyY2VNYXBwaW5nVVJMPWVsZWN0cm9uSHR0cEV4ZWN1dG9yLmpzLm1hcFxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9lbGVjdHJvbi11cGRhdGVyL291dC9lbGVjdHJvbkh0dHBFeGVjdXRvci5qcyIsIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmNyZWF0ZUNsaWVudCA9IGNyZWF0ZUNsaWVudDtcblxudmFyIF9idWlsZGVyVXRpbFJ1bnRpbWU7XG5cbmZ1bmN0aW9uIF9sb2FkX2J1aWxkZXJVdGlsUnVudGltZSgpIHtcbiAgICByZXR1cm4gX2J1aWxkZXJVdGlsUnVudGltZSA9IHJlcXVpcmUoXCJidWlsZGVyLXV0aWwtcnVudGltZVwiKTtcbn1cblxudmFyIF9CaW50cmF5UHJvdmlkZXI7XG5cbmZ1bmN0aW9uIF9sb2FkX0JpbnRyYXlQcm92aWRlcigpIHtcbiAgICByZXR1cm4gX0JpbnRyYXlQcm92aWRlciA9IHJlcXVpcmUoXCIuL0JpbnRyYXlQcm92aWRlclwiKTtcbn1cblxudmFyIF9HZW5lcmljUHJvdmlkZXI7XG5cbmZ1bmN0aW9uIF9sb2FkX0dlbmVyaWNQcm92aWRlcigpIHtcbiAgICByZXR1cm4gX0dlbmVyaWNQcm92aWRlciA9IHJlcXVpcmUoXCIuL0dlbmVyaWNQcm92aWRlclwiKTtcbn1cblxudmFyIF9HaXRIdWJQcm92aWRlcjtcblxuZnVuY3Rpb24gX2xvYWRfR2l0SHViUHJvdmlkZXIoKSB7XG4gICAgcmV0dXJuIF9HaXRIdWJQcm92aWRlciA9IHJlcXVpcmUoXCIuL0dpdEh1YlByb3ZpZGVyXCIpO1xufVxuXG52YXIgX1ByaXZhdGVHaXRIdWJQcm92aWRlcjtcblxuZnVuY3Rpb24gX2xvYWRfUHJpdmF0ZUdpdEh1YlByb3ZpZGVyKCkge1xuICAgIHJldHVybiBfUHJpdmF0ZUdpdEh1YlByb3ZpZGVyID0gcmVxdWlyZShcIi4vUHJpdmF0ZUdpdEh1YlByb3ZpZGVyXCIpO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVDbGllbnQoZGF0YSwgdXBkYXRlcikge1xuICAgIGlmICh0eXBlb2YgZGF0YSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICB0aHJvdyAoMCwgKF9idWlsZGVyVXRpbFJ1bnRpbWUgfHwgX2xvYWRfYnVpbGRlclV0aWxSdW50aW1lKCkpLm5ld0Vycm9yKShcIlBsZWFzZSBwYXNzIFB1Ymxpc2hDb25maWd1cmF0aW9uIG9iamVjdFwiLCBcIkVSUl9VUERBVEVSX0lOVkFMSURfUFJPVklERVJfQ09ORklHVVJBVElPTlwiKTtcbiAgICB9XG4gICAgY29uc3QgaHR0cEV4ZWN1dG9yID0gdXBkYXRlci5odHRwRXhlY3V0b3I7XG4gICAgY29uc3QgcHJvdmlkZXIgPSBkYXRhLnByb3ZpZGVyO1xuICAgIHN3aXRjaCAocHJvdmlkZXIpIHtcbiAgICAgICAgY2FzZSBcImdpdGh1YlwiOlxuICAgICAgICAgICAgY29uc3QgZ2l0aHViT3B0aW9ucyA9IGRhdGE7XG4gICAgICAgICAgICBjb25zdCB0b2tlbiA9IChnaXRodWJPcHRpb25zLnByaXZhdGUgPyBwcm9jZXNzLmVudi5HSF9UT0tFTiA6IG51bGwpIHx8IGdpdGh1Yk9wdGlvbnMudG9rZW47XG4gICAgICAgICAgICBpZiAodG9rZW4gPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgKF9HaXRIdWJQcm92aWRlciB8fCBfbG9hZF9HaXRIdWJQcm92aWRlcigpKS5HaXRIdWJQcm92aWRlcihnaXRodWJPcHRpb25zLCB1cGRhdGVyLCBodHRwRXhlY3V0b3IpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IChfUHJpdmF0ZUdpdEh1YlByb3ZpZGVyIHx8IF9sb2FkX1ByaXZhdGVHaXRIdWJQcm92aWRlcigpKS5Qcml2YXRlR2l0SHViUHJvdmlkZXIoZ2l0aHViT3B0aW9ucywgdG9rZW4sIGh0dHBFeGVjdXRvcik7XG4gICAgICAgICAgICB9XG4gICAgICAgIGNhc2UgXCJzM1wiOlxuICAgICAgICBjYXNlIFwic3BhY2VzXCI6XG4gICAgICAgICAgICByZXR1cm4gbmV3IChfR2VuZXJpY1Byb3ZpZGVyIHx8IF9sb2FkX0dlbmVyaWNQcm92aWRlcigpKS5HZW5lcmljUHJvdmlkZXIoe1xuICAgICAgICAgICAgICAgIHByb3ZpZGVyOiBcImdlbmVyaWNcIixcbiAgICAgICAgICAgICAgICB1cmw6ICgwLCAoX2J1aWxkZXJVdGlsUnVudGltZSB8fCBfbG9hZF9idWlsZGVyVXRpbFJ1bnRpbWUoKSkuZ2V0UzNMaWtlUHJvdmlkZXJCYXNlVXJsKShkYXRhKSxcbiAgICAgICAgICAgICAgICBjaGFubmVsOiBkYXRhLmNoYW5uZWwgfHwgbnVsbFxuICAgICAgICAgICAgfSwgdXBkYXRlciwgcHJvdmlkZXIgPT09IFwic3BhY2VzXCIgLyogaHR0cHM6Ly9naXRodWIuY29tL21pbmlvL21pbmlvL2lzc3Vlcy81Mjg1I2lzc3VlY29tbWVudC0zNTA0Mjg5NTUgKi8pO1xuICAgICAgICBjYXNlIFwiZ2VuZXJpY1wiOlxuICAgICAgICAgICAgcmV0dXJuIG5ldyAoX0dlbmVyaWNQcm92aWRlciB8fCBfbG9hZF9HZW5lcmljUHJvdmlkZXIoKSkuR2VuZXJpY1Byb3ZpZGVyKGRhdGEsIHVwZGF0ZXIsIHRydWUpO1xuICAgICAgICBjYXNlIFwiYmludHJheVwiOlxuICAgICAgICAgICAgcmV0dXJuIG5ldyAoX0JpbnRyYXlQcm92aWRlciB8fCBfbG9hZF9CaW50cmF5UHJvdmlkZXIoKSkuQmludHJheVByb3ZpZGVyKGRhdGEsIGh0dHBFeGVjdXRvcik7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICB0aHJvdyAoMCwgKF9idWlsZGVyVXRpbFJ1bnRpbWUgfHwgX2xvYWRfYnVpbGRlclV0aWxSdW50aW1lKCkpLm5ld0Vycm9yKShgVW5zdXBwb3J0ZWQgcHJvdmlkZXI6ICR7cHJvdmlkZXJ9YCwgXCJFUlJfVVBEQVRFUl9VTlNVUFBPUlRFRF9QUk9WSURFUlwiKTtcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1wcm92aWRlckZhY3RvcnkuanMubWFwXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2VsZWN0cm9uLXVwZGF0ZXIvb3V0L3Byb3ZpZGVyRmFjdG9yeS5qcyIsIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLkJpbnRyYXlQcm92aWRlciA9IHVuZGVmaW5lZDtcblxudmFyIF9ibHVlYmlyZExzdDtcblxuZnVuY3Rpb24gX2xvYWRfYmx1ZWJpcmRMc3QoKSB7XG4gICAgcmV0dXJuIF9ibHVlYmlyZExzdCA9IHJlcXVpcmUoXCJibHVlYmlyZC1sc3RcIik7XG59XG5cbnZhciBfYnVpbGRlclV0aWxSdW50aW1lO1xuXG5mdW5jdGlvbiBfbG9hZF9idWlsZGVyVXRpbFJ1bnRpbWUoKSB7XG4gICAgcmV0dXJuIF9idWlsZGVyVXRpbFJ1bnRpbWUgPSByZXF1aXJlKFwiYnVpbGRlci11dGlsLXJ1bnRpbWVcIik7XG59XG5cbnZhciBfYmludHJheTtcblxuZnVuY3Rpb24gX2xvYWRfYmludHJheSgpIHtcbiAgICByZXR1cm4gX2JpbnRyYXkgPSByZXF1aXJlKFwiYnVpbGRlci11dGlsLXJ1bnRpbWUvb3V0L2JpbnRyYXlcIik7XG59XG5cbnZhciBfdXJsO1xuXG5mdW5jdGlvbiBfbG9hZF91cmwoKSB7XG4gICAgcmV0dXJuIF91cmwgPSByZXF1aXJlKFwidXJsXCIpO1xufVxuXG52YXIgX21haW47XG5cbmZ1bmN0aW9uIF9sb2FkX21haW4oKSB7XG4gICAgcmV0dXJuIF9tYWluID0gcmVxdWlyZShcIi4vbWFpblwiKTtcbn1cblxudmFyIF9Qcm92aWRlcjtcblxuZnVuY3Rpb24gX2xvYWRfUHJvdmlkZXIoKSB7XG4gICAgcmV0dXJuIF9Qcm92aWRlciA9IHJlcXVpcmUoXCIuL1Byb3ZpZGVyXCIpO1xufVxuXG5jbGFzcyBCaW50cmF5UHJvdmlkZXIgZXh0ZW5kcyAoX21haW4gfHwgX2xvYWRfbWFpbigpKS5Qcm92aWRlciB7XG4gICAgY29uc3RydWN0b3IoY29uZmlndXJhdGlvbiwgaHR0cEV4ZWN1dG9yKSB7XG4gICAgICAgIHN1cGVyKGh0dHBFeGVjdXRvcik7XG4gICAgICAgIHRoaXMuY2xpZW50ID0gbmV3IChfYmludHJheSB8fCBfbG9hZF9iaW50cmF5KCkpLkJpbnRyYXlDbGllbnQoY29uZmlndXJhdGlvbiwgaHR0cEV4ZWN1dG9yLCBuZXcgKF9idWlsZGVyVXRpbFJ1bnRpbWUgfHwgX2xvYWRfYnVpbGRlclV0aWxSdW50aW1lKCkpLkNhbmNlbGxhdGlvblRva2VuKCkpO1xuICAgICAgICB0aGlzLmJhc2VVcmwgPSAoMCwgKF9tYWluIHx8IF9sb2FkX21haW4oKSkubmV3QmFzZVVybCkoYGh0dHBzOi8vZGwuYmludHJheS5jb20vJHt0aGlzLmNsaWVudC5vd25lcn0vJHt0aGlzLmNsaWVudC5yZXBvfWApO1xuICAgIH1cbiAgICBzZXRSZXF1ZXN0SGVhZGVycyh2YWx1ZSkge1xuICAgICAgICBzdXBlci5zZXRSZXF1ZXN0SGVhZGVycyh2YWx1ZSk7XG4gICAgICAgIHRoaXMuY2xpZW50LnNldFJlcXVlc3RIZWFkZXJzKHZhbHVlKTtcbiAgICB9XG4gICAgZ2V0TGF0ZXN0VmVyc2lvbigpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgICAgICByZXR1cm4gKDAsIChfYmx1ZWJpcmRMc3QgfHwgX2xvYWRfYmx1ZWJpcmRMc3QoKSkuY29yb3V0aW5lKShmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBjb25zdCBkYXRhID0geWllbGQgX3RoaXMuY2xpZW50LmdldFZlcnNpb24oXCJfbGF0ZXN0XCIpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGNoYW5uZWxGaWxlbmFtZSA9ICgwLCAoX21haW4gfHwgX2xvYWRfbWFpbigpKS5nZXRDaGFubmVsRmlsZW5hbWUpKCgwLCAoX21haW4gfHwgX2xvYWRfbWFpbigpKS5nZXREZWZhdWx0Q2hhbm5lbE5hbWUpKCkpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGZpbGVzID0geWllbGQgX3RoaXMuY2xpZW50LmdldFZlcnNpb25GaWxlcyhkYXRhLm5hbWUpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGNoYW5uZWxGaWxlID0gZmlsZXMuZmluZChmdW5jdGlvbiAoaXQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGl0Lm5hbWUuZW5kc1dpdGgoYF8ke2NoYW5uZWxGaWxlbmFtZX1gKSB8fCBpdC5uYW1lLmVuZHNXaXRoKGAtJHtjaGFubmVsRmlsZW5hbWV9YCk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgaWYgKGNoYW5uZWxGaWxlID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gbm9pbnNwZWN0aW9uIEV4Y2VwdGlvbkNhdWdodExvY2FsbHlKU1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyAoMCwgKF9idWlsZGVyVXRpbFJ1bnRpbWUgfHwgX2xvYWRfYnVpbGRlclV0aWxSdW50aW1lKCkpLm5ld0Vycm9yKShgQ2Fubm90IGZpbmQgY2hhbm5lbCBmaWxlIFwiJHtjaGFubmVsRmlsZW5hbWV9XCIsIGV4aXN0aW5nIGZpbGVzOlxcbiR7ZmlsZXMubWFwKGZ1bmN0aW9uIChpdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KGl0LCBudWxsLCAyKTtcbiAgICAgICAgICAgICAgICAgICAgfSkuam9pbihcIixcXG5cIil9YCwgXCJFUlJfVVBEQVRFUl9DSEFOTkVMX0ZJTEVfTk9UX0ZPVU5EXCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCBjaGFubmVsRmlsZVVybCA9IG5ldyAoX3VybCB8fCBfbG9hZF91cmwoKSkuVVJMKGBodHRwczovL2RsLmJpbnRyYXkuY29tLyR7X3RoaXMuY2xpZW50Lm93bmVyfS8ke190aGlzLmNsaWVudC5yZXBvfS8ke2NoYW5uZWxGaWxlLm5hbWV9YCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuICgwLCAoX1Byb3ZpZGVyIHx8IF9sb2FkX1Byb3ZpZGVyKCkpLnBhcnNlVXBkYXRlSW5mbykoKHlpZWxkIF90aGlzLmh0dHBSZXF1ZXN0KGNoYW5uZWxGaWxlVXJsKSksIGNoYW5uZWxGaWxlbmFtZSwgY2hhbm5lbEZpbGVVcmwpO1xuICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIGlmIChcInN0YXR1c0NvZGVcIiBpbiBlICYmIGUuc3RhdHVzQ29kZSA9PT0gNDA0KSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93ICgwLCAoX2J1aWxkZXJVdGlsUnVudGltZSB8fCBfbG9hZF9idWlsZGVyVXRpbFJ1bnRpbWUoKSkubmV3RXJyb3IpKGBObyBsYXRlc3QgdmVyc2lvbiwgcGxlYXNlIGVuc3VyZSB0aGF0IHVzZXIsIHBhY2thZ2UgYW5kIHJlcG9zaXRvcnkgY29ycmVjdGx5IGNvbmZpZ3VyZWQuIE9yIGF0IGxlYXN0IG9uZSB2ZXJzaW9uIGlzIHB1Ymxpc2hlZC4gJHtlLnN0YWNrIHx8IGUubWVzc2FnZX1gLCBcIkVSUl9VUERBVEVSX0xBVEVTVF9WRVJTSU9OX05PVF9GT1VORFwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSkoKTtcbiAgICB9XG4gICAgcmVzb2x2ZUZpbGVzKHVwZGF0ZUluZm8pIHtcbiAgICAgICAgcmV0dXJuICgwLCAoX1Byb3ZpZGVyIHx8IF9sb2FkX1Byb3ZpZGVyKCkpLnJlc29sdmVGaWxlcykodXBkYXRlSW5mbywgdGhpcy5iYXNlVXJsKTtcbiAgICB9XG59XG5leHBvcnRzLkJpbnRyYXlQcm92aWRlciA9IEJpbnRyYXlQcm92aWRlcjsgLy8jIHNvdXJjZU1hcHBpbmdVUkw9QmludHJheVByb3ZpZGVyLmpzLm1hcFxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9lbGVjdHJvbi11cGRhdGVyL291dC9CaW50cmF5UHJvdmlkZXIuanMiLCJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5CaW50cmF5Q2xpZW50ID0gdW5kZWZpbmVkO1xuXG52YXIgX2h0dHBFeGVjdXRvcjtcblxuZnVuY3Rpb24gX2xvYWRfaHR0cEV4ZWN1dG9yKCkge1xuICAgIHJldHVybiBfaHR0cEV4ZWN1dG9yID0gcmVxdWlyZShcIi4vaHR0cEV4ZWN1dG9yXCIpO1xufVxuXG5jbGFzcyBCaW50cmF5Q2xpZW50IHtcbiAgICBjb25zdHJ1Y3RvcihvcHRpb25zLCBodHRwRXhlY3V0b3IsIGNhbmNlbGxhdGlvblRva2VuLCBhcGlLZXkpIHtcbiAgICAgICAgdGhpcy5odHRwRXhlY3V0b3IgPSBodHRwRXhlY3V0b3I7XG4gICAgICAgIHRoaXMuY2FuY2VsbGF0aW9uVG9rZW4gPSBjYW5jZWxsYXRpb25Ub2tlbjtcbiAgICAgICAgaWYgKG9wdGlvbnMub3duZXIgPT0gbnVsbCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwib3duZXIgaXMgbm90IHNwZWNpZmllZFwiKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob3B0aW9ucy5wYWNrYWdlID09IG51bGwpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcInBhY2thZ2UgaXMgbm90IHNwZWNpZmllZFwiKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnJlcG8gPSBvcHRpb25zLnJlcG8gfHwgXCJnZW5lcmljXCI7XG4gICAgICAgIHRoaXMucGFja2FnZU5hbWUgPSBvcHRpb25zLnBhY2thZ2U7XG4gICAgICAgIHRoaXMub3duZXIgPSBvcHRpb25zLm93bmVyO1xuICAgICAgICB0aGlzLnVzZXIgPSBvcHRpb25zLnVzZXIgfHwgb3B0aW9ucy5vd25lcjtcbiAgICAgICAgdGhpcy5jb21wb25lbnQgPSBvcHRpb25zLmNvbXBvbmVudCB8fCBudWxsO1xuICAgICAgICB0aGlzLmRpc3RyaWJ1dGlvbiA9IG9wdGlvbnMuZGlzdHJpYnV0aW9uIHx8IFwic3RhYmxlXCI7XG4gICAgICAgIHRoaXMuYXV0aCA9IGFwaUtleSA9PSBudWxsID8gbnVsbCA6IGBCYXNpYyAke0J1ZmZlci5mcm9tKGAke3RoaXMudXNlcn06JHthcGlLZXl9YCkudG9TdHJpbmcoXCJiYXNlNjRcIil9YDtcbiAgICAgICAgdGhpcy5iYXNlUGF0aCA9IGAvcGFja2FnZXMvJHt0aGlzLm93bmVyfS8ke3RoaXMucmVwb30vJHt0aGlzLnBhY2thZ2VOYW1lfWA7XG4gICAgfVxuICAgIHNldFJlcXVlc3RIZWFkZXJzKHZhbHVlKSB7XG4gICAgICAgIHRoaXMucmVxdWVzdEhlYWRlcnMgPSB2YWx1ZTtcbiAgICB9XG4gICAgYmludHJheVJlcXVlc3QocGF0aCwgYXV0aCwgZGF0YSA9IG51bGwsIGNhbmNlbGxhdGlvblRva2VuLCBtZXRob2QpIHtcbiAgICAgICAgcmV0dXJuICgwLCAoX2h0dHBFeGVjdXRvciB8fCBfbG9hZF9odHRwRXhlY3V0b3IoKSkucGFyc2VKc29uKSh0aGlzLmh0dHBFeGVjdXRvci5yZXF1ZXN0KCgwLCAoX2h0dHBFeGVjdXRvciB8fCBfbG9hZF9odHRwRXhlY3V0b3IoKSkuY29uZmlndXJlUmVxdWVzdE9wdGlvbnMpKHsgaG9zdG5hbWU6IFwiYXBpLmJpbnRyYXkuY29tXCIsIHBhdGgsIGhlYWRlcnM6IHRoaXMucmVxdWVzdEhlYWRlcnMgfHwgdW5kZWZpbmVkIH0sIGF1dGgsIG1ldGhvZCksIGNhbmNlbGxhdGlvblRva2VuLCBkYXRhKSk7XG4gICAgfVxuICAgIGdldFZlcnNpb24odmVyc2lvbikge1xuICAgICAgICByZXR1cm4gdGhpcy5iaW50cmF5UmVxdWVzdChgJHt0aGlzLmJhc2VQYXRofS92ZXJzaW9ucy8ke3ZlcnNpb259YCwgdGhpcy5hdXRoLCBudWxsLCB0aGlzLmNhbmNlbGxhdGlvblRva2VuKTtcbiAgICB9XG4gICAgZ2V0VmVyc2lvbkZpbGVzKHZlcnNpb24pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYmludHJheVJlcXVlc3QoYCR7dGhpcy5iYXNlUGF0aH0vdmVyc2lvbnMvJHt2ZXJzaW9ufS9maWxlc2AsIHRoaXMuYXV0aCwgbnVsbCwgdGhpcy5jYW5jZWxsYXRpb25Ub2tlbik7XG4gICAgfVxuICAgIGNyZWF0ZVZlcnNpb24odmVyc2lvbikge1xuICAgICAgICByZXR1cm4gdGhpcy5iaW50cmF5UmVxdWVzdChgJHt0aGlzLmJhc2VQYXRofS92ZXJzaW9uc2AsIHRoaXMuYXV0aCwge1xuICAgICAgICAgICAgbmFtZTogdmVyc2lvblxuICAgICAgICB9LCB0aGlzLmNhbmNlbGxhdGlvblRva2VuKTtcbiAgICB9XG4gICAgZGVsZXRlVmVyc2lvbih2ZXJzaW9uKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmJpbnRyYXlSZXF1ZXN0KGAke3RoaXMuYmFzZVBhdGh9L3ZlcnNpb25zLyR7dmVyc2lvbn1gLCB0aGlzLmF1dGgsIG51bGwsIHRoaXMuY2FuY2VsbGF0aW9uVG9rZW4sIFwiREVMRVRFXCIpO1xuICAgIH1cbn1cbmV4cG9ydHMuQmludHJheUNsaWVudCA9IEJpbnRyYXlDbGllbnQ7IC8vIyBzb3VyY2VNYXBwaW5nVVJMPWJpbnRyYXkuanMubWFwXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2VsZWN0cm9uLXVwZGF0ZXIvbm9kZV9tb2R1bGVzL2J1aWxkZXItdXRpbC1ydW50aW1lL291dC9iaW50cmF5LmpzIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuUHJpdmF0ZUdpdEh1YlByb3ZpZGVyID0gdW5kZWZpbmVkO1xuXG52YXIgX2JsdWViaXJkTHN0O1xuXG5mdW5jdGlvbiBfbG9hZF9ibHVlYmlyZExzdCgpIHtcbiAgICByZXR1cm4gX2JsdWViaXJkTHN0ID0gcmVxdWlyZShcImJsdWViaXJkLWxzdFwiKTtcbn1cblxudmFyIF9idWlsZGVyVXRpbFJ1bnRpbWU7XG5cbmZ1bmN0aW9uIF9sb2FkX2J1aWxkZXJVdGlsUnVudGltZSgpIHtcbiAgICByZXR1cm4gX2J1aWxkZXJVdGlsUnVudGltZSA9IHJlcXVpcmUoXCJidWlsZGVyLXV0aWwtcnVudGltZVwiKTtcbn1cblxudmFyIF9qc1lhbWw7XG5cbmZ1bmN0aW9uIF9sb2FkX2pzWWFtbCgpIHtcbiAgICByZXR1cm4gX2pzWWFtbCA9IHJlcXVpcmUoXCJqcy15YW1sXCIpO1xufVxuXG52YXIgX3BhdGggPSBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChyZXF1aXJlKFwicGF0aFwiKSk7XG5cbnZhciBfdXJsO1xuXG5mdW5jdGlvbiBfbG9hZF91cmwoKSB7XG4gICAgcmV0dXJuIF91cmwgPSByZXF1aXJlKFwidXJsXCIpO1xufVxuXG52YXIgX0dpdEh1YlByb3ZpZGVyO1xuXG5mdW5jdGlvbiBfbG9hZF9HaXRIdWJQcm92aWRlcigpIHtcbiAgICByZXR1cm4gX0dpdEh1YlByb3ZpZGVyID0gcmVxdWlyZShcIi4vR2l0SHViUHJvdmlkZXJcIik7XG59XG5cbnZhciBfbWFpbjtcblxuZnVuY3Rpb24gX2xvYWRfbWFpbigpIHtcbiAgICByZXR1cm4gX21haW4gPSByZXF1aXJlKFwiLi9tYWluXCIpO1xufVxuXG52YXIgX1Byb3ZpZGVyO1xuXG5mdW5jdGlvbiBfbG9hZF9Qcm92aWRlcigpIHtcbiAgICByZXR1cm4gX1Byb3ZpZGVyID0gcmVxdWlyZShcIi4vUHJvdmlkZXJcIik7XG59XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKG9iaikgeyBpZiAob2JqICYmIG9iai5fX2VzTW9kdWxlKSB7IHJldHVybiBvYmo7IH0gZWxzZSB7IHZhciBuZXdPYmogPSB7fTsgaWYgKG9iaiAhPSBudWxsKSB7IGZvciAodmFyIGtleSBpbiBvYmopIHsgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGtleSkpIG5ld09ialtrZXldID0gb2JqW2tleV07IH0gfSBuZXdPYmouZGVmYXVsdCA9IG9iajsgcmV0dXJuIG5ld09iajsgfSB9XG5cbmNsYXNzIFByaXZhdGVHaXRIdWJQcm92aWRlciBleHRlbmRzIChfR2l0SHViUHJvdmlkZXIgfHwgX2xvYWRfR2l0SHViUHJvdmlkZXIoKSkuQmFzZUdpdEh1YlByb3ZpZGVyIHtcbiAgICBjb25zdHJ1Y3RvcihvcHRpb25zLCB0b2tlbiwgZXhlY3V0b3IpIHtcbiAgICAgICAgc3VwZXIob3B0aW9ucywgXCJhcGkuZ2l0aHViLmNvbVwiLCBleGVjdXRvcik7XG4gICAgICAgIHRoaXMudG9rZW4gPSB0b2tlbjtcbiAgICB9XG4gICAgY3JlYXRlUmVxdWVzdE9wdGlvbnModXJsLCBoZWFkZXJzKSB7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IHN1cGVyLmNyZWF0ZVJlcXVlc3RPcHRpb25zKHVybCwgaGVhZGVycyk7XG4gICAgICAgIHJlc3VsdC5yZWRpcmVjdCA9IFwibWFudWFsXCI7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIGdldExhdGVzdFZlcnNpb24oKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICAgICAgcmV0dXJuICgwLCAoX2JsdWViaXJkTHN0IHx8IF9sb2FkX2JsdWViaXJkTHN0KCkpLmNvcm91dGluZSkoZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGNvbnN0IGJhc2VQYXRoID0gX3RoaXMuYmFzZVBhdGg7XG4gICAgICAgICAgICBjb25zdCBjYW5jZWxsYXRpb25Ub2tlbiA9IG5ldyAoX2J1aWxkZXJVdGlsUnVudGltZSB8fCBfbG9hZF9idWlsZGVyVXRpbFJ1bnRpbWUoKSkuQ2FuY2VsbGF0aW9uVG9rZW4oKTtcbiAgICAgICAgICAgIGNvbnN0IGNoYW5uZWxGaWxlID0gKDAsIChfbWFpbiB8fCBfbG9hZF9tYWluKCkpLmdldENoYW5uZWxGaWxlbmFtZSkoKDAsIChfbWFpbiB8fCBfbG9hZF9tYWluKCkpLmdldERlZmF1bHRDaGFubmVsTmFtZSkoKSk7XG4gICAgICAgICAgICBjb25zdCByZWxlYXNlSW5mbyA9IHlpZWxkIF90aGlzLmdldExhdGVzdFZlcnNpb25JbmZvKGJhc2VQYXRoLCBjYW5jZWxsYXRpb25Ub2tlbik7XG4gICAgICAgICAgICBjb25zdCBhc3NldCA9IHJlbGVhc2VJbmZvLmFzc2V0cy5maW5kKGZ1bmN0aW9uIChpdCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBpdC5uYW1lID09PSBjaGFubmVsRmlsZTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaWYgKGFzc2V0ID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAvLyBodG1sX3VybCBtdXN0IGJlIGFsd2F5cywgYnV0IGp1c3QgdG8gYmUgc3VyZVxuICAgICAgICAgICAgICAgIHRocm93ICgwLCAoX2J1aWxkZXJVdGlsUnVudGltZSB8fCBfbG9hZF9idWlsZGVyVXRpbFJ1bnRpbWUoKSkubmV3RXJyb3IpKGBDYW5ub3QgZmluZCAke2NoYW5uZWxGaWxlfSBpbiB0aGUgcmVsZWFzZSAke3JlbGVhc2VJbmZvLmh0bWxfdXJsIHx8IHJlbGVhc2VJbmZvLm5hbWV9YCwgXCJFUlJfVVBEQVRFUl9DSEFOTkVMX0ZJTEVfTk9UX0ZPVU5EXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgdXJsID0gbmV3IChfdXJsIHx8IF9sb2FkX3VybCgpKS5VUkwoYXNzZXQudXJsKTtcbiAgICAgICAgICAgIGxldCByZXN1bHQ7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9ICgwLCAoX2pzWWFtbCB8fCBfbG9hZF9qc1lhbWwoKSkuc2FmZUxvYWQpKCh5aWVsZCBfdGhpcy5odHRwUmVxdWVzdCh1cmwsIF90aGlzLmNvbmZpZ3VyZUhlYWRlcnMoXCJhcHBsaWNhdGlvbi9vY3RldC1zdHJlYW1cIiksIGNhbmNlbGxhdGlvblRva2VuKSkpO1xuICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIGlmIChlIGluc3RhbmNlb2YgKF9idWlsZGVyVXRpbFJ1bnRpbWUgfHwgX2xvYWRfYnVpbGRlclV0aWxSdW50aW1lKCkpLkh0dHBFcnJvciAmJiBlLnN0YXR1c0NvZGUgPT09IDQwNCkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyAoMCwgKF9idWlsZGVyVXRpbFJ1bnRpbWUgfHwgX2xvYWRfYnVpbGRlclV0aWxSdW50aW1lKCkpLm5ld0Vycm9yKShgQ2Fubm90IGZpbmQgJHtjaGFubmVsRmlsZX0gaW4gdGhlIGxhdGVzdCByZWxlYXNlIGFydGlmYWN0cyAoJHt1cmx9KTogJHtlLnN0YWNrIHx8IGUubWVzc2FnZX1gLCBcIkVSUl9VUERBVEVSX0NIQU5ORUxfRklMRV9OT1RfRk9VTkRcIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRocm93IGU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXN1bHQuYXNzZXRzID0gcmVsZWFzZUluZm8uYXNzZXRzO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfSkoKTtcbiAgICB9XG4gICAgZ2V0IGZpbGVFeHRyYURvd25sb2FkSGVhZGVycygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29uZmlndXJlSGVhZGVycyhcImFwcGxpY2F0aW9uL29jdGV0LXN0cmVhbVwiKTtcbiAgICB9XG4gICAgY29uZmlndXJlSGVhZGVycyhhY2NlcHQpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIEFjY2VwdDogYWNjZXB0LFxuICAgICAgICAgICAgQXV0aG9yaXphdGlvbjogYHRva2VuICR7dGhpcy50b2tlbn1gXG4gICAgICAgIH07XG4gICAgfVxuICAgIGdldExhdGVzdFZlcnNpb25JbmZvKGJhc2VQYXRoLCBjYW5jZWxsYXRpb25Ub2tlbikge1xuICAgICAgICB2YXIgX3RoaXMyID0gdGhpcztcblxuICAgICAgICByZXR1cm4gKDAsIChfYmx1ZWJpcmRMc3QgfHwgX2xvYWRfYmx1ZWJpcmRMc3QoKSkuY29yb3V0aW5lKShmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3QgdXJsID0gKDAsIChfbWFpbiB8fCBfbG9hZF9tYWluKCkpLm5ld1VybEZyb21CYXNlKShgJHtiYXNlUGF0aH0vbGF0ZXN0YCwgX3RoaXMyLmJhc2VVcmwpO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gSlNPTi5wYXJzZSgoeWllbGQgX3RoaXMyLmh0dHBSZXF1ZXN0KHVybCwgX3RoaXMyLmNvbmZpZ3VyZUhlYWRlcnMoXCJhcHBsaWNhdGlvbi92bmQuZ2l0aHViLnYzK2pzb25cIiksIGNhbmNlbGxhdGlvblRva2VuKSkpO1xuICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIHRocm93ICgwLCAoX2J1aWxkZXJVdGlsUnVudGltZSB8fCBfbG9hZF9idWlsZGVyVXRpbFJ1bnRpbWUoKSkubmV3RXJyb3IpKGBVbmFibGUgdG8gZmluZCBsYXRlc3QgdmVyc2lvbiBvbiBHaXRIdWIgKCR7dXJsfSksIHBsZWFzZSBlbnN1cmUgYSBwcm9kdWN0aW9uIHJlbGVhc2UgZXhpc3RzOiAke2Uuc3RhY2sgfHwgZS5tZXNzYWdlfWAsIFwiRVJSX1VQREFURVJfTEFURVNUX1ZFUlNJT05fTk9UX0ZPVU5EXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KSgpO1xuICAgIH1cbiAgICBnZXQgYmFzZVBhdGgoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbXB1dGVHaXRodWJCYXNlUGF0aChgL3JlcG9zLyR7dGhpcy5vcHRpb25zLm93bmVyfS8ke3RoaXMub3B0aW9ucy5yZXBvfS9yZWxlYXNlc2ApO1xuICAgIH1cbiAgICByZXNvbHZlRmlsZXModXBkYXRlSW5mbykge1xuICAgICAgICByZXR1cm4gKDAsIChfUHJvdmlkZXIgfHwgX2xvYWRfUHJvdmlkZXIoKSkuZ2V0RmlsZUxpc3QpKHVwZGF0ZUluZm8pLm1hcChpdCA9PiB7XG4gICAgICAgICAgICBjb25zdCBuYW1lID0gX3BhdGgucG9zaXguYmFzZW5hbWUoaXQudXJsKS5yZXBsYWNlKC8gL2csIFwiLVwiKTtcbiAgICAgICAgICAgIGNvbnN0IGFzc2V0ID0gdXBkYXRlSW5mby5hc3NldHMuZmluZChpdCA9PiBpdCAhPSBudWxsICYmIGl0Lm5hbWUgPT09IG5hbWUpO1xuICAgICAgICAgICAgaWYgKGFzc2V0ID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyAoMCwgKF9idWlsZGVyVXRpbFJ1bnRpbWUgfHwgX2xvYWRfYnVpbGRlclV0aWxSdW50aW1lKCkpLm5ld0Vycm9yKShgQ2Fubm90IGZpbmQgYXNzZXQgXCIke25hbWV9XCIgaW46ICR7SlNPTi5zdHJpbmdpZnkodXBkYXRlSW5mby5hc3NldHMsIG51bGwsIDIpfWAsIFwiRVJSX1VQREFURVJfQVNTRVRfTk9UX0ZPVU5EXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB1cmw6IG5ldyAoX3VybCB8fCBfbG9hZF91cmwoKSkuVVJMKGFzc2V0LnVybCksXG4gICAgICAgICAgICAgICAgaW5mbzogaXRcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0pO1xuICAgIH1cbn1cbmV4cG9ydHMuUHJpdmF0ZUdpdEh1YlByb3ZpZGVyID0gUHJpdmF0ZUdpdEh1YlByb3ZpZGVyOyAvLyMgc291cmNlTWFwcGluZ1VSTD1Qcml2YXRlR2l0SHViUHJvdmlkZXIuanMubWFwXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2VsZWN0cm9uLXVwZGF0ZXIvb3V0L1ByaXZhdGVHaXRIdWJQcm92aWRlci5qcyIsIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLk5zaXNVcGRhdGVyID0gdW5kZWZpbmVkO1xuXG52YXIgX2JsdWViaXJkTHN0O1xuXG5mdW5jdGlvbiBfbG9hZF9ibHVlYmlyZExzdCgpIHtcbiAgICByZXR1cm4gX2JsdWViaXJkTHN0ID0gcmVxdWlyZShcImJsdWViaXJkLWxzdFwiKTtcbn1cblxudmFyIF9idWlsZGVyVXRpbFJ1bnRpbWU7XG5cbmZ1bmN0aW9uIF9sb2FkX2J1aWxkZXJVdGlsUnVudGltZSgpIHtcbiAgICByZXR1cm4gX2J1aWxkZXJVdGlsUnVudGltZSA9IHJlcXVpcmUoXCJidWlsZGVyLXV0aWwtcnVudGltZVwiKTtcbn1cblxudmFyIF9jaGlsZF9wcm9jZXNzO1xuXG5mdW5jdGlvbiBfbG9hZF9jaGlsZF9wcm9jZXNzKCkge1xuICAgIHJldHVybiBfY2hpbGRfcHJvY2VzcyA9IHJlcXVpcmUoXCJjaGlsZF9wcm9jZXNzXCIpO1xufVxuXG52YXIgX3BhdGggPSBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChyZXF1aXJlKFwicGF0aFwiKSk7XG5cbnJlcXVpcmUoXCJzb3VyY2UtbWFwLXN1cHBvcnQvcmVnaXN0ZXJcIik7XG5cbnZhciBfQmFzZVVwZGF0ZXI7XG5cbmZ1bmN0aW9uIF9sb2FkX0Jhc2VVcGRhdGVyKCkge1xuICAgIHJldHVybiBfQmFzZVVwZGF0ZXIgPSByZXF1aXJlKFwiLi9CYXNlVXBkYXRlclwiKTtcbn1cblxudmFyIF9GaWxlV2l0aEVtYmVkZGVkQmxvY2tNYXBEaWZmZXJlbnRpYWxEb3dubG9hZGVyO1xuXG5mdW5jdGlvbiBfbG9hZF9GaWxlV2l0aEVtYmVkZGVkQmxvY2tNYXBEaWZmZXJlbnRpYWxEb3dubG9hZGVyKCkge1xuICAgIHJldHVybiBfRmlsZVdpdGhFbWJlZGRlZEJsb2NrTWFwRGlmZmVyZW50aWFsRG93bmxvYWRlciA9IHJlcXVpcmUoXCIuL2RpZmZlcmVudGlhbERvd25sb2FkZXIvRmlsZVdpdGhFbWJlZGRlZEJsb2NrTWFwRGlmZmVyZW50aWFsRG93bmxvYWRlclwiKTtcbn1cblxudmFyIF9HZW5lcmljRGlmZmVyZW50aWFsRG93bmxvYWRlcjtcblxuZnVuY3Rpb24gX2xvYWRfR2VuZXJpY0RpZmZlcmVudGlhbERvd25sb2FkZXIoKSB7XG4gICAgcmV0dXJuIF9HZW5lcmljRGlmZmVyZW50aWFsRG93bmxvYWRlciA9IHJlcXVpcmUoXCIuL2RpZmZlcmVudGlhbERvd25sb2FkZXIvR2VuZXJpY0RpZmZlcmVudGlhbERvd25sb2FkZXJcIik7XG59XG5cbnZhciBfbWFpbjtcblxuZnVuY3Rpb24gX2xvYWRfbWFpbigpIHtcbiAgICByZXR1cm4gX21haW4gPSByZXF1aXJlKFwiLi9tYWluXCIpO1xufVxuXG52YXIgX1Byb3ZpZGVyO1xuXG5mdW5jdGlvbiBfbG9hZF9Qcm92aWRlcigpIHtcbiAgICByZXR1cm4gX1Byb3ZpZGVyID0gcmVxdWlyZShcIi4vUHJvdmlkZXJcIik7XG59XG5cbnZhciBfd2luZG93c0V4ZWN1dGFibGVDb2RlU2lnbmF0dXJlVmVyaWZpZXI7XG5cbmZ1bmN0aW9uIF9sb2FkX3dpbmRvd3NFeGVjdXRhYmxlQ29kZVNpZ25hdHVyZVZlcmlmaWVyKCkge1xuICAgIHJldHVybiBfd2luZG93c0V4ZWN1dGFibGVDb2RlU2lnbmF0dXJlVmVyaWZpZXIgPSByZXF1aXJlKFwiLi93aW5kb3dzRXhlY3V0YWJsZUNvZGVTaWduYXR1cmVWZXJpZmllclwiKTtcbn1cblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQob2JqKSB7IGlmIChvYmogJiYgb2JqLl9fZXNNb2R1bGUpIHsgcmV0dXJuIG9iajsgfSBlbHNlIHsgdmFyIG5ld09iaiA9IHt9OyBpZiAob2JqICE9IG51bGwpIHsgZm9yICh2YXIga2V5IGluIG9iaikgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwga2V5KSkgbmV3T2JqW2tleV0gPSBvYmpba2V5XTsgfSB9IG5ld09iai5kZWZhdWx0ID0gb2JqOyByZXR1cm4gbmV3T2JqOyB9IH1cblxuY2xhc3MgTnNpc1VwZGF0ZXIgZXh0ZW5kcyAoX0Jhc2VVcGRhdGVyIHx8IF9sb2FkX0Jhc2VVcGRhdGVyKCkpLkJhc2VVcGRhdGVyIHtcbiAgICBjb25zdHJ1Y3RvcihvcHRpb25zLCBhcHApIHtcbiAgICAgICAgc3VwZXIob3B0aW9ucywgYXBwKTtcbiAgICB9XG4gICAgLyoqKiBAcHJpdmF0ZSAqL1xuICAgIGRvRG93bmxvYWRVcGRhdGUodXBkYXRlSW5mbywgY2FuY2VsbGF0aW9uVG9rZW4pIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgICAgICByZXR1cm4gKDAsIChfYmx1ZWJpcmRMc3QgfHwgX2xvYWRfYmx1ZWJpcmRMc3QoKSkuY29yb3V0aW5lKShmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3QgcHJvdmlkZXIgPSB5aWVsZCBfdGhpcy5wcm92aWRlcjtcbiAgICAgICAgICAgIGNvbnN0IGZpbGVJbmZvID0gKDAsIChfUHJvdmlkZXIgfHwgX2xvYWRfUHJvdmlkZXIoKSkuZmluZEZpbGUpKHByb3ZpZGVyLnJlc29sdmVGaWxlcyh1cGRhdGVJbmZvKSwgXCJleGVcIik7XG4gICAgICAgICAgICBjb25zdCByZXF1ZXN0SGVhZGVycyA9IHlpZWxkIF90aGlzLmNvbXB1dGVSZXF1ZXN0SGVhZGVycygpO1xuICAgICAgICAgICAgY29uc3QgZG93bmxvYWRPcHRpb25zID0ge1xuICAgICAgICAgICAgICAgIHNraXBEaXJDcmVhdGlvbjogdHJ1ZSxcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiByZXF1ZXN0SGVhZGVycyxcbiAgICAgICAgICAgICAgICBjYW5jZWxsYXRpb25Ub2tlbixcbiAgICAgICAgICAgICAgICBzaGE1MTI6IGZpbGVJbmZvLmluZm8uc2hhNTEyXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgbGV0IHBhY2thZ2VQYXRoID0gX3RoaXMuZG93bmxvYWRlZFVwZGF0ZUhlbHBlci5wYWNrYWdlUGF0aDtcbiAgICAgICAgICAgIGxldCBpbnN0YWxsZXJQYXRoID0gX3RoaXMuZG93bmxvYWRlZFVwZGF0ZUhlbHBlci5nZXREb3dubG9hZGVkRmlsZSh1cGRhdGVJbmZvLCBmaWxlSW5mbyk7XG4gICAgICAgICAgICBpZiAoaW5zdGFsbGVyUGF0aCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHBhY2thZ2VQYXRoID09IG51bGwgPyBbaW5zdGFsbGVyUGF0aF0gOiBbaW5zdGFsbGVyUGF0aCwgcGFja2FnZVBhdGhdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgeWllbGQgX3RoaXMuZXhlY3V0ZURvd25sb2FkKGRvd25sb2FkT3B0aW9ucywgZmlsZUluZm8sICgoKSA9PiB7XG4gICAgICAgICAgICAgICAgdmFyIF9yZWYgPSAoMCwgKF9ibHVlYmlyZExzdCB8fCBfbG9hZF9ibHVlYmlyZExzdCgpKS5jb3JvdXRpbmUpKGZ1bmN0aW9uKiAodGVtcERpciwgZGVzdGluYXRpb25GaWxlLCByZW1vdmVUZW1wRGlySWZBbnkpIHtcbiAgICAgICAgICAgICAgICAgICAgaW5zdGFsbGVyUGF0aCA9IGRlc3RpbmF0aW9uRmlsZTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHlpZWxkIF90aGlzLmRpZmZlcmVudGlhbERvd25sb2FkSW5zdGFsbGVyKGZpbGVJbmZvLCBcIk9MRFwiLCBpbnN0YWxsZXJQYXRoLCByZXF1ZXN0SGVhZGVycywgcHJvdmlkZXIpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB5aWVsZCBfdGhpcy5odHRwRXhlY3V0b3IuZG93bmxvYWQoZmlsZUluZm8udXJsLmhyZWYsIGluc3RhbGxlclBhdGgsIGRvd25sb2FkT3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgc2lnbmF0dXJlVmVyaWZpY2F0aW9uU3RhdHVzID0geWllbGQgX3RoaXMudmVyaWZ5U2lnbmF0dXJlKGluc3RhbGxlclBhdGgpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoc2lnbmF0dXJlVmVyaWZpY2F0aW9uU3RhdHVzICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHlpZWxkIHJlbW92ZVRlbXBEaXJJZkFueSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gbm9pbnNwZWN0aW9uIFRocm93SW5zaWRlRmluYWxseUJsb2NrSlNcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93ICgwLCAoX2J1aWxkZXJVdGlsUnVudGltZSB8fCBfbG9hZF9idWlsZGVyVXRpbFJ1bnRpbWUoKSkubmV3RXJyb3IpKGBOZXcgdmVyc2lvbiAke190aGlzLnVwZGF0ZUluZm8udmVyc2lvbn0gaXMgbm90IHNpZ25lZCBieSB0aGUgYXBwbGljYXRpb24gb3duZXI6ICR7c2lnbmF0dXJlVmVyaWZpY2F0aW9uU3RhdHVzfWAsIFwiRVJSX1VQREFURVJfSU5WQUxJRF9TSUdOQVRVUkVcIik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcGFja2FnZUluZm8gPSBmaWxlSW5mby5wYWNrYWdlSW5mbztcbiAgICAgICAgICAgICAgICAgICAgaWYgKHBhY2thZ2VJbmZvICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhY2thZ2VQYXRoID0gX3BhdGguam9pbih0ZW1wRGlyLCBgcGFja2FnZS0ke3VwZGF0ZUluZm8udmVyc2lvbn0ke19wYXRoLmV4dG5hbWUocGFja2FnZUluZm8ucGF0aCkgfHwgXCIuN3pcIn1gKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh5aWVsZCBfdGhpcy5kaWZmZXJlbnRpYWxEb3dubG9hZFdlYlBhY2thZ2UocGFja2FnZUluZm8sIHBhY2thZ2VQYXRoLCBwcm92aWRlcikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB5aWVsZCBfdGhpcy5odHRwRXhlY3V0b3IuZG93bmxvYWQocGFja2FnZUluZm8ucGF0aCwgcGFja2FnZVBhdGgsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2tpcERpckNyZWF0aW9uOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBoZWFkZXJzOiByZXF1ZXN0SGVhZGVycyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FuY2VsbGF0aW9uVG9rZW4sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNoYTUxMjogcGFja2FnZUluZm8uc2hhNTEyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoX3gsIF94MiwgX3gzKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBfcmVmLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0pKCkpO1xuICAgICAgICAgICAgX3RoaXMuZG93bmxvYWRlZFVwZGF0ZUhlbHBlci5zZXREb3dubG9hZGVkRmlsZShpbnN0YWxsZXJQYXRoLCBwYWNrYWdlUGF0aCwgdXBkYXRlSW5mbywgZmlsZUluZm8pO1xuICAgICAgICAgICAgX3RoaXMuYWRkUXVpdEhhbmRsZXIoKTtcbiAgICAgICAgICAgIF90aGlzLmVtaXQoKF9tYWluIHx8IF9sb2FkX21haW4oKSkuVVBEQVRFX0RPV05MT0FERUQsIF90aGlzLnVwZGF0ZUluZm8pO1xuICAgICAgICAgICAgcmV0dXJuIHBhY2thZ2VQYXRoID09IG51bGwgPyBbaW5zdGFsbGVyUGF0aF0gOiBbaW5zdGFsbGVyUGF0aCwgcGFja2FnZVBhdGhdO1xuICAgICAgICB9KSgpO1xuICAgIH1cbiAgICAvLyAkY2VydGlmaWNhdGVJbmZvID0gKEdldC1BdXRoZW50aWNvZGVTaWduYXR1cmUgJ3h4eFxceXl5LmV4ZSdcbiAgICAvLyB8IHdoZXJlIHskXy5TdGF0dXMuRXF1YWxzKFtTeXN0ZW0uTWFuYWdlbWVudC5BdXRvbWF0aW9uLlNpZ25hdHVyZVN0YXR1c106OlZhbGlkKSAtYW5kICRfLlNpZ25lckNlcnRpZmljYXRlLlN1YmplY3QuQ29udGFpbnMoXCJDTj1zaWVtZW5zLmNvbVwiKX0pXG4gICAgLy8gfCBPdXQtU3RyaW5nIDsgaWYgKCRjZXJ0aWZpY2F0ZUluZm8pIHsgZXhpdCAwIH0gZWxzZSB7IGV4aXQgMSB9XG4gICAgdmVyaWZ5U2lnbmF0dXJlKHRlbXBVcGRhdGVGaWxlKSB7XG4gICAgICAgIHZhciBfdGhpczIgPSB0aGlzO1xuXG4gICAgICAgIHJldHVybiAoMCwgKF9ibHVlYmlyZExzdCB8fCBfbG9hZF9ibHVlYmlyZExzdCgpKS5jb3JvdXRpbmUpKGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBsZXQgcHVibGlzaGVyTmFtZTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgcHVibGlzaGVyTmFtZSA9ICh5aWVsZCBfdGhpczIuY29uZmlnT25EaXNrLnZhbHVlKS5wdWJsaXNoZXJOYW1lO1xuICAgICAgICAgICAgICAgIGlmIChwdWJsaXNoZXJOYW1lID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIGlmIChlLmNvZGUgPT09IFwiRU5PRU5UXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gbm8gYXBwLXVwZGF0ZS55bWxcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRocm93IGU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4geWllbGQgKDAsIChfd2luZG93c0V4ZWN1dGFibGVDb2RlU2lnbmF0dXJlVmVyaWZpZXIgfHwgX2xvYWRfd2luZG93c0V4ZWN1dGFibGVDb2RlU2lnbmF0dXJlVmVyaWZpZXIoKSkudmVyaWZ5U2lnbmF0dXJlKShBcnJheS5pc0FycmF5KHB1Ymxpc2hlck5hbWUpID8gcHVibGlzaGVyTmFtZSA6IFtwdWJsaXNoZXJOYW1lXSwgdGVtcFVwZGF0ZUZpbGUsIF90aGlzMi5fbG9nZ2VyKTtcbiAgICAgICAgfSkoKTtcbiAgICB9XG4gICAgZG9JbnN0YWxsKGluc3RhbGxlclBhdGgsIGlzU2lsZW50LCBpc0ZvcmNlUnVuQWZ0ZXIpIHtcbiAgICAgICAgY29uc3QgYXJncyA9IFtcIi0tdXBkYXRlZFwiXTtcbiAgICAgICAgaWYgKGlzU2lsZW50KSB7XG4gICAgICAgICAgICBhcmdzLnB1c2goXCIvU1wiKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNGb3JjZVJ1bkFmdGVyKSB7XG4gICAgICAgICAgICBhcmdzLnB1c2goXCItLWZvcmNlLXJ1blwiKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBwYWNrYWdlUGF0aCA9IHRoaXMuZG93bmxvYWRlZFVwZGF0ZUhlbHBlci5wYWNrYWdlUGF0aDtcbiAgICAgICAgaWYgKHBhY2thZ2VQYXRoICE9IG51bGwpIHtcbiAgICAgICAgICAgIC8vIG9ubHkgPSBmb3JtIGlzIHN1cHBvcnRlZFxuICAgICAgICAgICAgYXJncy5wdXNoKGAtLXBhY2thZ2UtZmlsZT0ke3BhY2thZ2VQYXRofWApO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHNwYXduT3B0aW9ucyA9IHtcbiAgICAgICAgICAgIGRldGFjaGVkOiB0cnVlLFxuICAgICAgICAgICAgc3RkaW86IFwiaWdub3JlXCJcbiAgICAgICAgfTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICgwLCAoX2NoaWxkX3Byb2Nlc3MgfHwgX2xvYWRfY2hpbGRfcHJvY2VzcygpKS5zcGF3bikoaW5zdGFsbGVyUGF0aCwgYXJncywgc3Bhd25PcHRpb25zKS51bnJlZigpO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAvLyB5ZXMsIHN1Y2ggZXJyb3JzIGRpc3BhdGNoZWQgbm90IGFzIGVycm9yIGV2ZW50XG4gICAgICAgICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vZWxlY3Ryb24tdXNlcmxhbmQvZWxlY3Ryb24tYnVpbGRlci9pc3N1ZXMvMTEyOVxuICAgICAgICAgICAgaWYgKGUuY29kZSA9PT0gXCJVTktOT1dOXCIgfHwgZS5jb2RlID09PSBcIkVBQ0NFU1wiKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fbG9nZ2VyLmluZm8oXCJBY2Nlc3MgZGVuaWVkIG9yIFVOS05PV04gZXJyb3IgY29kZSBvbiBzcGF3biwgd2lsbCBiZSBleGVjdXRlZCBhZ2FpbiB1c2luZyBlbGV2YXRlXCIpO1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICgwLCAoX2NoaWxkX3Byb2Nlc3MgfHwgX2xvYWRfY2hpbGRfcHJvY2VzcygpKS5zcGF3bikoX3BhdGguam9pbihwcm9jZXNzLnJlc291cmNlc1BhdGgsIFwiZWxldmF0ZS5leGVcIiksIFtpbnN0YWxsZXJQYXRoXS5jb25jYXQoYXJncyksIHNwYXduT3B0aW9ucykudW5yZWYoKTtcbiAgICAgICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZGlzcGF0Y2hFcnJvcihlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuZGlzcGF0Y2hFcnJvcihlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgZGlmZmVyZW50aWFsRG93bmxvYWRJbnN0YWxsZXIoZmlsZUluZm8sIG9sZEZpbGUsIGluc3RhbGxlclBhdGgsIHJlcXVlc3RIZWFkZXJzLCBwcm92aWRlcikge1xuICAgICAgICB2YXIgX3RoaXMzID0gdGhpcztcblxuICAgICAgICByZXR1cm4gKDAsIChfYmx1ZWJpcmRMc3QgfHwgX2xvYWRfYmx1ZWJpcmRMc3QoKSkuY29yb3V0aW5lKShmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgaWYgKHByb2Nlc3MuZW52Ll9fTlNJU19ESUZGRVJFTlRJQUxfVVBEQVRFX18gPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBjb25zdCBibG9ja01hcERhdGEgPSBKU09OLnBhcnNlKCh5aWVsZCBwcm92aWRlci5odHRwUmVxdWVzdCgoMCwgKF9tYWluIHx8IF9sb2FkX21haW4oKSkubmV3VXJsRnJvbUJhc2UpKGAke2ZpbGVJbmZvLnVybC5wYXRobmFtZX0uYmxvY2tNYXAuanNvbmAsIGZpbGVJbmZvLnVybCkpKSk7XG4gICAgICAgICAgICAgICAgeWllbGQgbmV3IChfR2VuZXJpY0RpZmZlcmVudGlhbERvd25sb2FkZXIgfHwgX2xvYWRfR2VuZXJpY0RpZmZlcmVudGlhbERvd25sb2FkZXIoKSkuR2VuZXJpY0RpZmZlcmVudGlhbERvd25sb2FkZXIoZmlsZUluZm8uaW5mbywgX3RoaXMzLmh0dHBFeGVjdXRvciwge1xuICAgICAgICAgICAgICAgICAgICBuZXdVcmw6IGZpbGVJbmZvLnVybC5ocmVmLFxuICAgICAgICAgICAgICAgICAgICBvbGRGaWxlLFxuICAgICAgICAgICAgICAgICAgICBsb2dnZXI6IF90aGlzMy5fbG9nZ2VyLFxuICAgICAgICAgICAgICAgICAgICBuZXdGaWxlOiBpbnN0YWxsZXJQYXRoLFxuICAgICAgICAgICAgICAgICAgICB1c2VNdWx0aXBsZVJhbmdlUmVxdWVzdDogcHJvdmlkZXIudXNlTXVsdGlwbGVSYW5nZVJlcXVlc3QsXG4gICAgICAgICAgICAgICAgICAgIHJlcXVlc3RIZWFkZXJzXG4gICAgICAgICAgICAgICAgfSkuZG93bmxvYWQoYmxvY2tNYXBEYXRhKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICBfdGhpczMuX2xvZ2dlci5lcnJvcihgQ2Fubm90IGRvd25sb2FkIGRpZmZlcmVudGlhbGx5LCBmYWxsYmFjayB0byBmdWxsIGRvd25sb2FkOiAke2Uuc3RhY2sgfHwgZX1gKTtcbiAgICAgICAgICAgICAgICAvLyBkdXJpbmcgdGVzdCAoZGV2ZWxvcGVyIG1hY2hpbmUgbWFjKSB3ZSBtdXN0IHRocm93IGVycm9yXG4gICAgICAgICAgICAgICAgcmV0dXJuIHByb2Nlc3MucGxhdGZvcm0gPT09IFwid2luMzJcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfSkoKTtcbiAgICB9XG4gICAgZGlmZmVyZW50aWFsRG93bmxvYWRXZWJQYWNrYWdlKHBhY2thZ2VJbmZvLCBwYWNrYWdlUGF0aCwgcHJvdmlkZXIpIHtcbiAgICAgICAgdmFyIF90aGlzNCA9IHRoaXM7XG5cbiAgICAgICAgcmV0dXJuICgwLCAoX2JsdWViaXJkTHN0IHx8IF9sb2FkX2JsdWViaXJkTHN0KCkpLmNvcm91dGluZSkoZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGlmIChwYWNrYWdlSW5mby5ibG9ja01hcFNpemUgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICB5aWVsZCBuZXcgKF9GaWxlV2l0aEVtYmVkZGVkQmxvY2tNYXBEaWZmZXJlbnRpYWxEb3dubG9hZGVyIHx8IF9sb2FkX0ZpbGVXaXRoRW1iZWRkZWRCbG9ja01hcERpZmZlcmVudGlhbERvd25sb2FkZXIoKSkuRmlsZVdpdGhFbWJlZGRlZEJsb2NrTWFwRGlmZmVyZW50aWFsRG93bmxvYWRlcihwYWNrYWdlSW5mbywgX3RoaXM0Lmh0dHBFeGVjdXRvciwge1xuICAgICAgICAgICAgICAgICAgICBuZXdVcmw6IHBhY2thZ2VJbmZvLnBhdGgsXG4gICAgICAgICAgICAgICAgICAgIG9sZEZpbGU6IF9wYXRoLmpvaW4ocHJvY2Vzcy5yZXNvdXJjZXNQYXRoLCBcIi4uXCIsIFwicGFja2FnZS43elwiKSxcbiAgICAgICAgICAgICAgICAgICAgbG9nZ2VyOiBfdGhpczQuX2xvZ2dlcixcbiAgICAgICAgICAgICAgICAgICAgbmV3RmlsZTogcGFja2FnZVBhdGgsXG4gICAgICAgICAgICAgICAgICAgIHJlcXVlc3RIZWFkZXJzOiBfdGhpczQucmVxdWVzdEhlYWRlcnMsXG4gICAgICAgICAgICAgICAgICAgIHVzZU11bHRpcGxlUmFuZ2VSZXF1ZXN0OiBwcm92aWRlci51c2VNdWx0aXBsZVJhbmdlUmVxdWVzdFxuICAgICAgICAgICAgICAgIH0pLmRvd25sb2FkKCk7XG4gICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgX3RoaXM0Ll9sb2dnZXIuZXJyb3IoYENhbm5vdCBkb3dubG9hZCBkaWZmZXJlbnRpYWxseSwgZmFsbGJhY2sgdG8gZnVsbCBkb3dubG9hZDogJHtlLnN0YWNrIHx8IGV9YCk7XG4gICAgICAgICAgICAgICAgLy8gZHVyaW5nIHRlc3QgKGRldmVsb3BlciBtYWNoaW5lIG1hYyBvciBsaW51eCkgd2UgbXVzdCB0aHJvdyBlcnJvclxuICAgICAgICAgICAgICAgIHJldHVybiBwcm9jZXNzLnBsYXRmb3JtID09PSBcIndpbjMyXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH0pKCk7XG4gICAgfVxufVxuZXhwb3J0cy5Oc2lzVXBkYXRlciA9IE5zaXNVcGRhdGVyOyAvLyMgc291cmNlTWFwcGluZ1VSTD1Oc2lzVXBkYXRlci5qcy5tYXBcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvZWxlY3Ryb24tdXBkYXRlci9vdXQvTnNpc1VwZGF0ZXIuanMiLCJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5Eb3dubG9hZGVkVXBkYXRlSGVscGVyID0gdW5kZWZpbmVkO1xuXG52YXIgX2xvZGFzaDtcblxuZnVuY3Rpb24gX2xvYWRfbG9kYXNoKCkge1xuICAgIHJldHVybiBfbG9kYXNoID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwibG9kYXNoLmlzZXF1YWxcIikpO1xufVxuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG4vKiogQHByaXZhdGUgKiovXG5jbGFzcyBEb3dubG9hZGVkVXBkYXRlSGVscGVyIHtcbiAgICBnZXQgZmlsZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2V0dXBQYXRoO1xuICAgIH1cbiAgICBnZXQgcGFja2FnZVBhdGgoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9wYWNrYWdlUGF0aDtcbiAgICB9XG4gICAgZ2V0RG93bmxvYWRlZEZpbGUodmVyc2lvbkluZm8sIGZpbGVJbmZvKSB7XG4gICAgICAgIGlmICh0aGlzLnNldHVwUGF0aCA9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gKDAsIChfbG9kYXNoIHx8IF9sb2FkX2xvZGFzaCgpKS5kZWZhdWx0KSh0aGlzLnZlcnNpb25JbmZvLCB2ZXJzaW9uSW5mbykgJiYgKDAsIChfbG9kYXNoIHx8IF9sb2FkX2xvZGFzaCgpKS5kZWZhdWx0KSh0aGlzLmZpbGVJbmZvLCBmaWxlSW5mbykgPyB0aGlzLnNldHVwUGF0aCA6IG51bGw7XG4gICAgfVxuICAgIHNldERvd25sb2FkZWRGaWxlKGZpbGUsIHBhY2thZ2VQYXRoLCB2ZXJzaW9uSW5mbywgZmlsZUluZm8pIHtcbiAgICAgICAgdGhpcy5zZXR1cFBhdGggPSBmaWxlO1xuICAgICAgICB0aGlzLl9wYWNrYWdlUGF0aCA9IHBhY2thZ2VQYXRoO1xuICAgICAgICB0aGlzLnZlcnNpb25JbmZvID0gdmVyc2lvbkluZm87XG4gICAgICAgIHRoaXMuZmlsZUluZm8gPSBmaWxlSW5mbztcbiAgICB9XG4gICAgY2xlYXIoKSB7XG4gICAgICAgIHRoaXMuc2V0dXBQYXRoID0gbnVsbDtcbiAgICAgICAgdGhpcy5fcGFja2FnZVBhdGggPSBudWxsO1xuICAgICAgICB0aGlzLnZlcnNpb25JbmZvID0gbnVsbDtcbiAgICAgICAgdGhpcy5maWxlSW5mbyA9IG51bGw7XG4gICAgfVxufVxuZXhwb3J0cy5Eb3dubG9hZGVkVXBkYXRlSGVscGVyID0gRG93bmxvYWRlZFVwZGF0ZUhlbHBlcjsgLy8jIHNvdXJjZU1hcHBpbmdVUkw9RG93bmxvYWRlZFVwZGF0ZUhlbHBlci5qcy5tYXBcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvZWxlY3Ryb24tdXBkYXRlci9vdXQvRG93bmxvYWRlZFVwZGF0ZUhlbHBlci5qcyIsIi8qKlxuICogTG9kYXNoIChDdXN0b20gQnVpbGQpIDxodHRwczovL2xvZGFzaC5jb20vPlxuICogQnVpbGQ6IGBsb2Rhc2ggbW9kdWxhcml6ZSBleHBvcnRzPVwibnBtXCIgLW8gLi9gXG4gKiBDb3B5cmlnaHQgSlMgRm91bmRhdGlvbiBhbmQgb3RoZXIgY29udHJpYnV0b3JzIDxodHRwczovL2pzLmZvdW5kYXRpb24vPlxuICogUmVsZWFzZWQgdW5kZXIgTUlUIGxpY2Vuc2UgPGh0dHBzOi8vbG9kYXNoLmNvbS9saWNlbnNlPlxuICogQmFzZWQgb24gVW5kZXJzY29yZS5qcyAxLjguMyA8aHR0cDovL3VuZGVyc2NvcmVqcy5vcmcvTElDRU5TRT5cbiAqIENvcHlyaWdodCBKZXJlbXkgQXNoa2VuYXMsIERvY3VtZW50Q2xvdWQgYW5kIEludmVzdGlnYXRpdmUgUmVwb3J0ZXJzICYgRWRpdG9yc1xuICovXG5cbi8qKiBVc2VkIGFzIHRoZSBzaXplIHRvIGVuYWJsZSBsYXJnZSBhcnJheSBvcHRpbWl6YXRpb25zLiAqL1xudmFyIExBUkdFX0FSUkFZX1NJWkUgPSAyMDA7XG5cbi8qKiBVc2VkIHRvIHN0YW5kLWluIGZvciBgdW5kZWZpbmVkYCBoYXNoIHZhbHVlcy4gKi9cbnZhciBIQVNIX1VOREVGSU5FRCA9ICdfX2xvZGFzaF9oYXNoX3VuZGVmaW5lZF9fJztcblxuLyoqIFVzZWQgdG8gY29tcG9zZSBiaXRtYXNrcyBmb3IgdmFsdWUgY29tcGFyaXNvbnMuICovXG52YXIgQ09NUEFSRV9QQVJUSUFMX0ZMQUcgPSAxLFxuICAgIENPTVBBUkVfVU5PUkRFUkVEX0ZMQUcgPSAyO1xuXG4vKiogVXNlZCBhcyByZWZlcmVuY2VzIGZvciB2YXJpb3VzIGBOdW1iZXJgIGNvbnN0YW50cy4gKi9cbnZhciBNQVhfU0FGRV9JTlRFR0VSID0gOTAwNzE5OTI1NDc0MDk5MTtcblxuLyoqIGBPYmplY3QjdG9TdHJpbmdgIHJlc3VsdCByZWZlcmVuY2VzLiAqL1xudmFyIGFyZ3NUYWcgPSAnW29iamVjdCBBcmd1bWVudHNdJyxcbiAgICBhcnJheVRhZyA9ICdbb2JqZWN0IEFycmF5XScsXG4gICAgYXN5bmNUYWcgPSAnW29iamVjdCBBc3luY0Z1bmN0aW9uXScsXG4gICAgYm9vbFRhZyA9ICdbb2JqZWN0IEJvb2xlYW5dJyxcbiAgICBkYXRlVGFnID0gJ1tvYmplY3QgRGF0ZV0nLFxuICAgIGVycm9yVGFnID0gJ1tvYmplY3QgRXJyb3JdJyxcbiAgICBmdW5jVGFnID0gJ1tvYmplY3QgRnVuY3Rpb25dJyxcbiAgICBnZW5UYWcgPSAnW29iamVjdCBHZW5lcmF0b3JGdW5jdGlvbl0nLFxuICAgIG1hcFRhZyA9ICdbb2JqZWN0IE1hcF0nLFxuICAgIG51bWJlclRhZyA9ICdbb2JqZWN0IE51bWJlcl0nLFxuICAgIG51bGxUYWcgPSAnW29iamVjdCBOdWxsXScsXG4gICAgb2JqZWN0VGFnID0gJ1tvYmplY3QgT2JqZWN0XScsXG4gICAgcHJvbWlzZVRhZyA9ICdbb2JqZWN0IFByb21pc2VdJyxcbiAgICBwcm94eVRhZyA9ICdbb2JqZWN0IFByb3h5XScsXG4gICAgcmVnZXhwVGFnID0gJ1tvYmplY3QgUmVnRXhwXScsXG4gICAgc2V0VGFnID0gJ1tvYmplY3QgU2V0XScsXG4gICAgc3RyaW5nVGFnID0gJ1tvYmplY3QgU3RyaW5nXScsXG4gICAgc3ltYm9sVGFnID0gJ1tvYmplY3QgU3ltYm9sXScsXG4gICAgdW5kZWZpbmVkVGFnID0gJ1tvYmplY3QgVW5kZWZpbmVkXScsXG4gICAgd2Vha01hcFRhZyA9ICdbb2JqZWN0IFdlYWtNYXBdJztcblxudmFyIGFycmF5QnVmZmVyVGFnID0gJ1tvYmplY3QgQXJyYXlCdWZmZXJdJyxcbiAgICBkYXRhVmlld1RhZyA9ICdbb2JqZWN0IERhdGFWaWV3XScsXG4gICAgZmxvYXQzMlRhZyA9ICdbb2JqZWN0IEZsb2F0MzJBcnJheV0nLFxuICAgIGZsb2F0NjRUYWcgPSAnW29iamVjdCBGbG9hdDY0QXJyYXldJyxcbiAgICBpbnQ4VGFnID0gJ1tvYmplY3QgSW50OEFycmF5XScsXG4gICAgaW50MTZUYWcgPSAnW29iamVjdCBJbnQxNkFycmF5XScsXG4gICAgaW50MzJUYWcgPSAnW29iamVjdCBJbnQzMkFycmF5XScsXG4gICAgdWludDhUYWcgPSAnW29iamVjdCBVaW50OEFycmF5XScsXG4gICAgdWludDhDbGFtcGVkVGFnID0gJ1tvYmplY3QgVWludDhDbGFtcGVkQXJyYXldJyxcbiAgICB1aW50MTZUYWcgPSAnW29iamVjdCBVaW50MTZBcnJheV0nLFxuICAgIHVpbnQzMlRhZyA9ICdbb2JqZWN0IFVpbnQzMkFycmF5XSc7XG5cbi8qKlxuICogVXNlZCB0byBtYXRjaCBgUmVnRXhwYFxuICogW3N5bnRheCBjaGFyYWN0ZXJzXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1wYXR0ZXJucykuXG4gKi9cbnZhciByZVJlZ0V4cENoYXIgPSAvW1xcXFxeJC4qKz8oKVtcXF17fXxdL2c7XG5cbi8qKiBVc2VkIHRvIGRldGVjdCBob3N0IGNvbnN0cnVjdG9ycyAoU2FmYXJpKS4gKi9cbnZhciByZUlzSG9zdEN0b3IgPSAvXlxcW29iamVjdCAuKz9Db25zdHJ1Y3RvclxcXSQvO1xuXG4vKiogVXNlZCB0byBkZXRlY3QgdW5zaWduZWQgaW50ZWdlciB2YWx1ZXMuICovXG52YXIgcmVJc1VpbnQgPSAvXig/OjB8WzEtOV1cXGQqKSQvO1xuXG4vKiogVXNlZCB0byBpZGVudGlmeSBgdG9TdHJpbmdUYWdgIHZhbHVlcyBvZiB0eXBlZCBhcnJheXMuICovXG52YXIgdHlwZWRBcnJheVRhZ3MgPSB7fTtcbnR5cGVkQXJyYXlUYWdzW2Zsb2F0MzJUYWddID0gdHlwZWRBcnJheVRhZ3NbZmxvYXQ2NFRhZ10gPVxudHlwZWRBcnJheVRhZ3NbaW50OFRhZ10gPSB0eXBlZEFycmF5VGFnc1tpbnQxNlRhZ10gPVxudHlwZWRBcnJheVRhZ3NbaW50MzJUYWddID0gdHlwZWRBcnJheVRhZ3NbdWludDhUYWddID1cbnR5cGVkQXJyYXlUYWdzW3VpbnQ4Q2xhbXBlZFRhZ10gPSB0eXBlZEFycmF5VGFnc1t1aW50MTZUYWddID1cbnR5cGVkQXJyYXlUYWdzW3VpbnQzMlRhZ10gPSB0cnVlO1xudHlwZWRBcnJheVRhZ3NbYXJnc1RhZ10gPSB0eXBlZEFycmF5VGFnc1thcnJheVRhZ10gPVxudHlwZWRBcnJheVRhZ3NbYXJyYXlCdWZmZXJUYWddID0gdHlwZWRBcnJheVRhZ3NbYm9vbFRhZ10gPVxudHlwZWRBcnJheVRhZ3NbZGF0YVZpZXdUYWddID0gdHlwZWRBcnJheVRhZ3NbZGF0ZVRhZ10gPVxudHlwZWRBcnJheVRhZ3NbZXJyb3JUYWddID0gdHlwZWRBcnJheVRhZ3NbZnVuY1RhZ10gPVxudHlwZWRBcnJheVRhZ3NbbWFwVGFnXSA9IHR5cGVkQXJyYXlUYWdzW251bWJlclRhZ10gPVxudHlwZWRBcnJheVRhZ3Nbb2JqZWN0VGFnXSA9IHR5cGVkQXJyYXlUYWdzW3JlZ2V4cFRhZ10gPVxudHlwZWRBcnJheVRhZ3Nbc2V0VGFnXSA9IHR5cGVkQXJyYXlUYWdzW3N0cmluZ1RhZ10gPVxudHlwZWRBcnJheVRhZ3Nbd2Vha01hcFRhZ10gPSBmYWxzZTtcblxuLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBnbG9iYWxgIGZyb20gTm9kZS5qcy4gKi9cbnZhciBmcmVlR2xvYmFsID0gdHlwZW9mIGdsb2JhbCA9PSAnb2JqZWN0JyAmJiBnbG9iYWwgJiYgZ2xvYmFsLk9iamVjdCA9PT0gT2JqZWN0ICYmIGdsb2JhbDtcblxuLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBzZWxmYC4gKi9cbnZhciBmcmVlU2VsZiA9IHR5cGVvZiBzZWxmID09ICdvYmplY3QnICYmIHNlbGYgJiYgc2VsZi5PYmplY3QgPT09IE9iamVjdCAmJiBzZWxmO1xuXG4vKiogVXNlZCBhcyBhIHJlZmVyZW5jZSB0byB0aGUgZ2xvYmFsIG9iamVjdC4gKi9cbnZhciByb290ID0gZnJlZUdsb2JhbCB8fCBmcmVlU2VsZiB8fCBGdW5jdGlvbigncmV0dXJuIHRoaXMnKSgpO1xuXG4vKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYGV4cG9ydHNgLiAqL1xudmFyIGZyZWVFeHBvcnRzID0gdHlwZW9mIGV4cG9ydHMgPT0gJ29iamVjdCcgJiYgZXhwb3J0cyAmJiAhZXhwb3J0cy5ub2RlVHlwZSAmJiBleHBvcnRzO1xuXG4vKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYG1vZHVsZWAuICovXG52YXIgZnJlZU1vZHVsZSA9IGZyZWVFeHBvcnRzICYmIHR5cGVvZiBtb2R1bGUgPT0gJ29iamVjdCcgJiYgbW9kdWxlICYmICFtb2R1bGUubm9kZVR5cGUgJiYgbW9kdWxlO1xuXG4vKiogRGV0ZWN0IHRoZSBwb3B1bGFyIENvbW1vbkpTIGV4dGVuc2lvbiBgbW9kdWxlLmV4cG9ydHNgLiAqL1xudmFyIG1vZHVsZUV4cG9ydHMgPSBmcmVlTW9kdWxlICYmIGZyZWVNb2R1bGUuZXhwb3J0cyA9PT0gZnJlZUV4cG9ydHM7XG5cbi8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgcHJvY2Vzc2AgZnJvbSBOb2RlLmpzLiAqL1xudmFyIGZyZWVQcm9jZXNzID0gbW9kdWxlRXhwb3J0cyAmJiBmcmVlR2xvYmFsLnByb2Nlc3M7XG5cbi8qKiBVc2VkIHRvIGFjY2VzcyBmYXN0ZXIgTm9kZS5qcyBoZWxwZXJzLiAqL1xudmFyIG5vZGVVdGlsID0gKGZ1bmN0aW9uKCkge1xuICB0cnkge1xuICAgIHJldHVybiBmcmVlUHJvY2VzcyAmJiBmcmVlUHJvY2Vzcy5iaW5kaW5nICYmIGZyZWVQcm9jZXNzLmJpbmRpbmcoJ3V0aWwnKTtcbiAgfSBjYXRjaCAoZSkge31cbn0oKSk7XG5cbi8qIE5vZGUuanMgaGVscGVyIHJlZmVyZW5jZXMuICovXG52YXIgbm9kZUlzVHlwZWRBcnJheSA9IG5vZGVVdGlsICYmIG5vZGVVdGlsLmlzVHlwZWRBcnJheTtcblxuLyoqXG4gKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYF8uZmlsdGVyYCBmb3IgYXJyYXlzIHdpdGhvdXQgc3VwcG9ydCBmb3JcbiAqIGl0ZXJhdGVlIHNob3J0aGFuZHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IFthcnJheV0gVGhlIGFycmF5IHRvIGl0ZXJhdGUgb3Zlci5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IHByZWRpY2F0ZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgZmlsdGVyZWQgYXJyYXkuXG4gKi9cbmZ1bmN0aW9uIGFycmF5RmlsdGVyKGFycmF5LCBwcmVkaWNhdGUpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aCxcbiAgICAgIHJlc0luZGV4ID0gMCxcbiAgICAgIHJlc3VsdCA9IFtdO1xuXG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgdmFyIHZhbHVlID0gYXJyYXlbaW5kZXhdO1xuICAgIGlmIChwcmVkaWNhdGUodmFsdWUsIGluZGV4LCBhcnJheSkpIHtcbiAgICAgIHJlc3VsdFtyZXNJbmRleCsrXSA9IHZhbHVlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG4vKipcbiAqIEFwcGVuZHMgdGhlIGVsZW1lbnRzIG9mIGB2YWx1ZXNgIHRvIGBhcnJheWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBtb2RpZnkuXG4gKiBAcGFyYW0ge0FycmF5fSB2YWx1ZXMgVGhlIHZhbHVlcyB0byBhcHBlbmQuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgYGFycmF5YC5cbiAqL1xuZnVuY3Rpb24gYXJyYXlQdXNoKGFycmF5LCB2YWx1ZXMpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSB2YWx1ZXMubGVuZ3RoLFxuICAgICAgb2Zmc2V0ID0gYXJyYXkubGVuZ3RoO1xuXG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgYXJyYXlbb2Zmc2V0ICsgaW5kZXhdID0gdmFsdWVzW2luZGV4XTtcbiAgfVxuICByZXR1cm4gYXJyYXk7XG59XG5cbi8qKlxuICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBfLnNvbWVgIGZvciBhcnJheXMgd2l0aG91dCBzdXBwb3J0IGZvciBpdGVyYXRlZVxuICogc2hvcnRoYW5kcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gW2FycmF5XSBUaGUgYXJyYXkgdG8gaXRlcmF0ZSBvdmVyLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gcHJlZGljYXRlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYW55IGVsZW1lbnQgcGFzc2VzIHRoZSBwcmVkaWNhdGUgY2hlY2ssXG4gKiAgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBhcnJheVNvbWUoYXJyYXksIHByZWRpY2F0ZSkge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IGFycmF5ID09IG51bGwgPyAwIDogYXJyYXkubGVuZ3RoO1xuXG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgaWYgKHByZWRpY2F0ZShhcnJheVtpbmRleF0sIGluZGV4LCBhcnJheSkpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8udGltZXNgIHdpdGhvdXQgc3VwcG9ydCBmb3IgaXRlcmF0ZWUgc2hvcnRoYW5kc1xuICogb3IgbWF4IGFycmF5IGxlbmd0aCBjaGVja3MuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7bnVtYmVyfSBuIFRoZSBudW1iZXIgb2YgdGltZXMgdG8gaW52b2tlIGBpdGVyYXRlZWAuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRlZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiByZXN1bHRzLlxuICovXG5mdW5jdGlvbiBiYXNlVGltZXMobiwgaXRlcmF0ZWUpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICByZXN1bHQgPSBBcnJheShuKTtcblxuICB3aGlsZSAoKytpbmRleCA8IG4pIHtcbiAgICByZXN1bHRbaW5kZXhdID0gaXRlcmF0ZWUoaW5kZXgpO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8udW5hcnlgIHdpdGhvdXQgc3VwcG9ydCBmb3Igc3RvcmluZyBtZXRhZGF0YS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gY2FwIGFyZ3VtZW50cyBmb3IuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBjYXBwZWQgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIGJhc2VVbmFyeShmdW5jKSB7XG4gIHJldHVybiBmdW5jdGlvbih2YWx1ZSkge1xuICAgIHJldHVybiBmdW5jKHZhbHVlKTtcbiAgfTtcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYSBgY2FjaGVgIHZhbHVlIGZvciBga2V5YCBleGlzdHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBjYWNoZSBUaGUgY2FjaGUgdG8gcXVlcnkuXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIGVudHJ5IHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGFuIGVudHJ5IGZvciBga2V5YCBleGlzdHMsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gY2FjaGVIYXMoY2FjaGUsIGtleSkge1xuICByZXR1cm4gY2FjaGUuaGFzKGtleSk7XG59XG5cbi8qKlxuICogR2V0cyB0aGUgdmFsdWUgYXQgYGtleWAgb2YgYG9iamVjdGAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb2JqZWN0XSBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBwcm9wZXJ0eSB0byBnZXQuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgcHJvcGVydHkgdmFsdWUuXG4gKi9cbmZ1bmN0aW9uIGdldFZhbHVlKG9iamVjdCwga2V5KSB7XG4gIHJldHVybiBvYmplY3QgPT0gbnVsbCA/IHVuZGVmaW5lZCA6IG9iamVjdFtrZXldO1xufVxuXG4vKipcbiAqIENvbnZlcnRzIGBtYXBgIHRvIGl0cyBrZXktdmFsdWUgcGFpcnMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBtYXAgVGhlIG1hcCB0byBjb252ZXJ0LlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBrZXktdmFsdWUgcGFpcnMuXG4gKi9cbmZ1bmN0aW9uIG1hcFRvQXJyYXkobWFwKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgcmVzdWx0ID0gQXJyYXkobWFwLnNpemUpO1xuXG4gIG1hcC5mb3JFYWNoKGZ1bmN0aW9uKHZhbHVlLCBrZXkpIHtcbiAgICByZXN1bHRbKytpbmRleF0gPSBba2V5LCB2YWx1ZV07XG4gIH0pO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG4vKipcbiAqIENyZWF0ZXMgYSB1bmFyeSBmdW5jdGlvbiB0aGF0IGludm9rZXMgYGZ1bmNgIHdpdGggaXRzIGFyZ3VtZW50IHRyYW5zZm9ybWVkLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byB3cmFwLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gdHJhbnNmb3JtIFRoZSBhcmd1bWVudCB0cmFuc2Zvcm0uXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gb3ZlckFyZyhmdW5jLCB0cmFuc2Zvcm0pIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKGFyZykge1xuICAgIHJldHVybiBmdW5jKHRyYW5zZm9ybShhcmcpKTtcbiAgfTtcbn1cblxuLyoqXG4gKiBDb252ZXJ0cyBgc2V0YCB0byBhbiBhcnJheSBvZiBpdHMgdmFsdWVzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gc2V0IFRoZSBzZXQgdG8gY29udmVydC5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgdmFsdWVzLlxuICovXG5mdW5jdGlvbiBzZXRUb0FycmF5KHNldCkge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIHJlc3VsdCA9IEFycmF5KHNldC5zaXplKTtcblxuICBzZXQuZm9yRWFjaChmdW5jdGlvbih2YWx1ZSkge1xuICAgIHJlc3VsdFsrK2luZGV4XSA9IHZhbHVlO1xuICB9KTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIGFycmF5UHJvdG8gPSBBcnJheS5wcm90b3R5cGUsXG4gICAgZnVuY1Byb3RvID0gRnVuY3Rpb24ucHJvdG90eXBlLFxuICAgIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqIFVzZWQgdG8gZGV0ZWN0IG92ZXJyZWFjaGluZyBjb3JlLWpzIHNoaW1zLiAqL1xudmFyIGNvcmVKc0RhdGEgPSByb290WydfX2NvcmUtanNfc2hhcmVkX18nXTtcblxuLyoqIFVzZWQgdG8gcmVzb2x2ZSB0aGUgZGVjb21waWxlZCBzb3VyY2Ugb2YgZnVuY3Rpb25zLiAqL1xudmFyIGZ1bmNUb1N0cmluZyA9IGZ1bmNQcm90by50b1N0cmluZztcblxuLyoqIFVzZWQgdG8gY2hlY2sgb2JqZWN0cyBmb3Igb3duIHByb3BlcnRpZXMuICovXG52YXIgaGFzT3duUHJvcGVydHkgPSBvYmplY3RQcm90by5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqIFVzZWQgdG8gZGV0ZWN0IG1ldGhvZHMgbWFzcXVlcmFkaW5nIGFzIG5hdGl2ZS4gKi9cbnZhciBtYXNrU3JjS2V5ID0gKGZ1bmN0aW9uKCkge1xuICB2YXIgdWlkID0gL1teLl0rJC8uZXhlYyhjb3JlSnNEYXRhICYmIGNvcmVKc0RhdGEua2V5cyAmJiBjb3JlSnNEYXRhLmtleXMuSUVfUFJPVE8gfHwgJycpO1xuICByZXR1cm4gdWlkID8gKCdTeW1ib2woc3JjKV8xLicgKyB1aWQpIDogJyc7XG59KCkpO1xuXG4vKipcbiAqIFVzZWQgdG8gcmVzb2x2ZSB0aGVcbiAqIFtgdG9TdHJpbmdUYWdgXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1vYmplY3QucHJvdG90eXBlLnRvc3RyaW5nKVxuICogb2YgdmFsdWVzLlxuICovXG52YXIgbmF0aXZlT2JqZWN0VG9TdHJpbmcgPSBvYmplY3RQcm90by50b1N0cmluZztcblxuLyoqIFVzZWQgdG8gZGV0ZWN0IGlmIGEgbWV0aG9kIGlzIG5hdGl2ZS4gKi9cbnZhciByZUlzTmF0aXZlID0gUmVnRXhwKCdeJyArXG4gIGZ1bmNUb1N0cmluZy5jYWxsKGhhc093blByb3BlcnR5KS5yZXBsYWNlKHJlUmVnRXhwQ2hhciwgJ1xcXFwkJicpXG4gIC5yZXBsYWNlKC9oYXNPd25Qcm9wZXJ0eXwoZnVuY3Rpb24pLio/KD89XFxcXFxcKCl8IGZvciAuKz8oPz1cXFxcXFxdKS9nLCAnJDEuKj8nKSArICckJ1xuKTtcblxuLyoqIEJ1aWx0LWluIHZhbHVlIHJlZmVyZW5jZXMuICovXG52YXIgQnVmZmVyID0gbW9kdWxlRXhwb3J0cyA/IHJvb3QuQnVmZmVyIDogdW5kZWZpbmVkLFxuICAgIFN5bWJvbCA9IHJvb3QuU3ltYm9sLFxuICAgIFVpbnQ4QXJyYXkgPSByb290LlVpbnQ4QXJyYXksXG4gICAgcHJvcGVydHlJc0VudW1lcmFibGUgPSBvYmplY3RQcm90by5wcm9wZXJ0eUlzRW51bWVyYWJsZSxcbiAgICBzcGxpY2UgPSBhcnJheVByb3RvLnNwbGljZSxcbiAgICBzeW1Ub1N0cmluZ1RhZyA9IFN5bWJvbCA/IFN5bWJvbC50b1N0cmluZ1RhZyA6IHVuZGVmaW5lZDtcblxuLyogQnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMgZm9yIHRob3NlIHdpdGggdGhlIHNhbWUgbmFtZSBhcyBvdGhlciBgbG9kYXNoYCBtZXRob2RzLiAqL1xudmFyIG5hdGl2ZUdldFN5bWJvbHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzLFxuICAgIG5hdGl2ZUlzQnVmZmVyID0gQnVmZmVyID8gQnVmZmVyLmlzQnVmZmVyIDogdW5kZWZpbmVkLFxuICAgIG5hdGl2ZUtleXMgPSBvdmVyQXJnKE9iamVjdC5rZXlzLCBPYmplY3QpO1xuXG4vKiBCdWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcyB0aGF0IGFyZSB2ZXJpZmllZCB0byBiZSBuYXRpdmUuICovXG52YXIgRGF0YVZpZXcgPSBnZXROYXRpdmUocm9vdCwgJ0RhdGFWaWV3JyksXG4gICAgTWFwID0gZ2V0TmF0aXZlKHJvb3QsICdNYXAnKSxcbiAgICBQcm9taXNlID0gZ2V0TmF0aXZlKHJvb3QsICdQcm9taXNlJyksXG4gICAgU2V0ID0gZ2V0TmF0aXZlKHJvb3QsICdTZXQnKSxcbiAgICBXZWFrTWFwID0gZ2V0TmF0aXZlKHJvb3QsICdXZWFrTWFwJyksXG4gICAgbmF0aXZlQ3JlYXRlID0gZ2V0TmF0aXZlKE9iamVjdCwgJ2NyZWF0ZScpO1xuXG4vKiogVXNlZCB0byBkZXRlY3QgbWFwcywgc2V0cywgYW5kIHdlYWttYXBzLiAqL1xudmFyIGRhdGFWaWV3Q3RvclN0cmluZyA9IHRvU291cmNlKERhdGFWaWV3KSxcbiAgICBtYXBDdG9yU3RyaW5nID0gdG9Tb3VyY2UoTWFwKSxcbiAgICBwcm9taXNlQ3RvclN0cmluZyA9IHRvU291cmNlKFByb21pc2UpLFxuICAgIHNldEN0b3JTdHJpbmcgPSB0b1NvdXJjZShTZXQpLFxuICAgIHdlYWtNYXBDdG9yU3RyaW5nID0gdG9Tb3VyY2UoV2Vha01hcCk7XG5cbi8qKiBVc2VkIHRvIGNvbnZlcnQgc3ltYm9scyB0byBwcmltaXRpdmVzIGFuZCBzdHJpbmdzLiAqL1xudmFyIHN5bWJvbFByb3RvID0gU3ltYm9sID8gU3ltYm9sLnByb3RvdHlwZSA6IHVuZGVmaW5lZCxcbiAgICBzeW1ib2xWYWx1ZU9mID0gc3ltYm9sUHJvdG8gPyBzeW1ib2xQcm90by52YWx1ZU9mIDogdW5kZWZpbmVkO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBoYXNoIG9iamVjdC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge0FycmF5fSBbZW50cmllc10gVGhlIGtleS12YWx1ZSBwYWlycyB0byBjYWNoZS5cbiAqL1xuZnVuY3Rpb24gSGFzaChlbnRyaWVzKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gZW50cmllcyA9PSBudWxsID8gMCA6IGVudHJpZXMubGVuZ3RoO1xuXG4gIHRoaXMuY2xlYXIoKTtcbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICB2YXIgZW50cnkgPSBlbnRyaWVzW2luZGV4XTtcbiAgICB0aGlzLnNldChlbnRyeVswXSwgZW50cnlbMV0pO1xuICB9XG59XG5cbi8qKlxuICogUmVtb3ZlcyBhbGwga2V5LXZhbHVlIGVudHJpZXMgZnJvbSB0aGUgaGFzaC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgY2xlYXJcbiAqIEBtZW1iZXJPZiBIYXNoXG4gKi9cbmZ1bmN0aW9uIGhhc2hDbGVhcigpIHtcbiAgdGhpcy5fX2RhdGFfXyA9IG5hdGl2ZUNyZWF0ZSA/IG5hdGl2ZUNyZWF0ZShudWxsKSA6IHt9O1xuICB0aGlzLnNpemUgPSAwO1xufVxuXG4vKipcbiAqIFJlbW92ZXMgYGtleWAgYW5kIGl0cyB2YWx1ZSBmcm9tIHRoZSBoYXNoLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBkZWxldGVcbiAqIEBtZW1iZXJPZiBIYXNoXG4gKiBAcGFyYW0ge09iamVjdH0gaGFzaCBUaGUgaGFzaCB0byBtb2RpZnkuXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIHJlbW92ZS5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgZW50cnkgd2FzIHJlbW92ZWQsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaGFzaERlbGV0ZShrZXkpIHtcbiAgdmFyIHJlc3VsdCA9IHRoaXMuaGFzKGtleSkgJiYgZGVsZXRlIHRoaXMuX19kYXRhX19ba2V5XTtcbiAgdGhpcy5zaXplIC09IHJlc3VsdCA/IDEgOiAwO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG4vKipcbiAqIEdldHMgdGhlIGhhc2ggdmFsdWUgZm9yIGBrZXlgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBnZXRcbiAqIEBtZW1iZXJPZiBIYXNoXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIGdldC5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBlbnRyeSB2YWx1ZS5cbiAqL1xuZnVuY3Rpb24gaGFzaEdldChrZXkpIHtcbiAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fO1xuICBpZiAobmF0aXZlQ3JlYXRlKSB7XG4gICAgdmFyIHJlc3VsdCA9IGRhdGFba2V5XTtcbiAgICByZXR1cm4gcmVzdWx0ID09PSBIQVNIX1VOREVGSU5FRCA/IHVuZGVmaW5lZCA6IHJlc3VsdDtcbiAgfVxuICByZXR1cm4gaGFzT3duUHJvcGVydHkuY2FsbChkYXRhLCBrZXkpID8gZGF0YVtrZXldIDogdW5kZWZpbmVkO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBhIGhhc2ggdmFsdWUgZm9yIGBrZXlgIGV4aXN0cy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgaGFzXG4gKiBAbWVtYmVyT2YgSGFzaFxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBlbnRyeSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBhbiBlbnRyeSBmb3IgYGtleWAgZXhpc3RzLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGhhc2hIYXMoa2V5KSB7XG4gIHZhciBkYXRhID0gdGhpcy5fX2RhdGFfXztcbiAgcmV0dXJuIG5hdGl2ZUNyZWF0ZSA/IChkYXRhW2tleV0gIT09IHVuZGVmaW5lZCkgOiBoYXNPd25Qcm9wZXJ0eS5jYWxsKGRhdGEsIGtleSk7XG59XG5cbi8qKlxuICogU2V0cyB0aGUgaGFzaCBga2V5YCB0byBgdmFsdWVgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBzZXRcbiAqIEBtZW1iZXJPZiBIYXNoXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIHNldC5cbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHNldC5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGhhc2ggaW5zdGFuY2UuXG4gKi9cbmZ1bmN0aW9uIGhhc2hTZXQoa2V5LCB2YWx1ZSkge1xuICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX187XG4gIHRoaXMuc2l6ZSArPSB0aGlzLmhhcyhrZXkpID8gMCA6IDE7XG4gIGRhdGFba2V5XSA9IChuYXRpdmVDcmVhdGUgJiYgdmFsdWUgPT09IHVuZGVmaW5lZCkgPyBIQVNIX1VOREVGSU5FRCA6IHZhbHVlO1xuICByZXR1cm4gdGhpcztcbn1cblxuLy8gQWRkIG1ldGhvZHMgdG8gYEhhc2hgLlxuSGFzaC5wcm90b3R5cGUuY2xlYXIgPSBoYXNoQ2xlYXI7XG5IYXNoLnByb3RvdHlwZVsnZGVsZXRlJ10gPSBoYXNoRGVsZXRlO1xuSGFzaC5wcm90b3R5cGUuZ2V0ID0gaGFzaEdldDtcbkhhc2gucHJvdG90eXBlLmhhcyA9IGhhc2hIYXM7XG5IYXNoLnByb3RvdHlwZS5zZXQgPSBoYXNoU2V0O1xuXG4vKipcbiAqIENyZWF0ZXMgYW4gbGlzdCBjYWNoZSBvYmplY3QuXG4gKlxuICogQHByaXZhdGVcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtBcnJheX0gW2VudHJpZXNdIFRoZSBrZXktdmFsdWUgcGFpcnMgdG8gY2FjaGUuXG4gKi9cbmZ1bmN0aW9uIExpc3RDYWNoZShlbnRyaWVzKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gZW50cmllcyA9PSBudWxsID8gMCA6IGVudHJpZXMubGVuZ3RoO1xuXG4gIHRoaXMuY2xlYXIoKTtcbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICB2YXIgZW50cnkgPSBlbnRyaWVzW2luZGV4XTtcbiAgICB0aGlzLnNldChlbnRyeVswXSwgZW50cnlbMV0pO1xuICB9XG59XG5cbi8qKlxuICogUmVtb3ZlcyBhbGwga2V5LXZhbHVlIGVudHJpZXMgZnJvbSB0aGUgbGlzdCBjYWNoZS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgY2xlYXJcbiAqIEBtZW1iZXJPZiBMaXN0Q2FjaGVcbiAqL1xuZnVuY3Rpb24gbGlzdENhY2hlQ2xlYXIoKSB7XG4gIHRoaXMuX19kYXRhX18gPSBbXTtcbiAgdGhpcy5zaXplID0gMDtcbn1cblxuLyoqXG4gKiBSZW1vdmVzIGBrZXlgIGFuZCBpdHMgdmFsdWUgZnJvbSB0aGUgbGlzdCBjYWNoZS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgZGVsZXRlXG4gKiBAbWVtYmVyT2YgTGlzdENhY2hlXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIHJlbW92ZS5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgZW50cnkgd2FzIHJlbW92ZWQsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gbGlzdENhY2hlRGVsZXRlKGtleSkge1xuICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX18sXG4gICAgICBpbmRleCA9IGFzc29jSW5kZXhPZihkYXRhLCBrZXkpO1xuXG4gIGlmIChpbmRleCA8IDApIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgdmFyIGxhc3RJbmRleCA9IGRhdGEubGVuZ3RoIC0gMTtcbiAgaWYgKGluZGV4ID09IGxhc3RJbmRleCkge1xuICAgIGRhdGEucG9wKCk7XG4gIH0gZWxzZSB7XG4gICAgc3BsaWNlLmNhbGwoZGF0YSwgaW5kZXgsIDEpO1xuICB9XG4gIC0tdGhpcy5zaXplO1xuICByZXR1cm4gdHJ1ZTtcbn1cblxuLyoqXG4gKiBHZXRzIHRoZSBsaXN0IGNhY2hlIHZhbHVlIGZvciBga2V5YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgZ2V0XG4gKiBAbWVtYmVyT2YgTGlzdENhY2hlXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIGdldC5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBlbnRyeSB2YWx1ZS5cbiAqL1xuZnVuY3Rpb24gbGlzdENhY2hlR2V0KGtleSkge1xuICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX18sXG4gICAgICBpbmRleCA9IGFzc29jSW5kZXhPZihkYXRhLCBrZXkpO1xuXG4gIHJldHVybiBpbmRleCA8IDAgPyB1bmRlZmluZWQgOiBkYXRhW2luZGV4XVsxXTtcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYSBsaXN0IGNhY2hlIHZhbHVlIGZvciBga2V5YCBleGlzdHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGhhc1xuICogQG1lbWJlck9mIExpc3RDYWNoZVxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBlbnRyeSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBhbiBlbnRyeSBmb3IgYGtleWAgZXhpc3RzLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGxpc3RDYWNoZUhhcyhrZXkpIHtcbiAgcmV0dXJuIGFzc29jSW5kZXhPZih0aGlzLl9fZGF0YV9fLCBrZXkpID4gLTE7XG59XG5cbi8qKlxuICogU2V0cyB0aGUgbGlzdCBjYWNoZSBga2V5YCB0byBgdmFsdWVgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBzZXRcbiAqIEBtZW1iZXJPZiBMaXN0Q2FjaGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gc2V0LlxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gc2V0LlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgbGlzdCBjYWNoZSBpbnN0YW5jZS5cbiAqL1xuZnVuY3Rpb24gbGlzdENhY2hlU2V0KGtleSwgdmFsdWUpIHtcbiAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fLFxuICAgICAgaW5kZXggPSBhc3NvY0luZGV4T2YoZGF0YSwga2V5KTtcblxuICBpZiAoaW5kZXggPCAwKSB7XG4gICAgKyt0aGlzLnNpemU7XG4gICAgZGF0YS5wdXNoKFtrZXksIHZhbHVlXSk7XG4gIH0gZWxzZSB7XG4gICAgZGF0YVtpbmRleF1bMV0gPSB2YWx1ZTtcbiAgfVxuICByZXR1cm4gdGhpcztcbn1cblxuLy8gQWRkIG1ldGhvZHMgdG8gYExpc3RDYWNoZWAuXG5MaXN0Q2FjaGUucHJvdG90eXBlLmNsZWFyID0gbGlzdENhY2hlQ2xlYXI7XG5MaXN0Q2FjaGUucHJvdG90eXBlWydkZWxldGUnXSA9IGxpc3RDYWNoZURlbGV0ZTtcbkxpc3RDYWNoZS5wcm90b3R5cGUuZ2V0ID0gbGlzdENhY2hlR2V0O1xuTGlzdENhY2hlLnByb3RvdHlwZS5oYXMgPSBsaXN0Q2FjaGVIYXM7XG5MaXN0Q2FjaGUucHJvdG90eXBlLnNldCA9IGxpc3RDYWNoZVNldDtcblxuLyoqXG4gKiBDcmVhdGVzIGEgbWFwIGNhY2hlIG9iamVjdCB0byBzdG9yZSBrZXktdmFsdWUgcGFpcnMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtBcnJheX0gW2VudHJpZXNdIFRoZSBrZXktdmFsdWUgcGFpcnMgdG8gY2FjaGUuXG4gKi9cbmZ1bmN0aW9uIE1hcENhY2hlKGVudHJpZXMpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSBlbnRyaWVzID09IG51bGwgPyAwIDogZW50cmllcy5sZW5ndGg7XG5cbiAgdGhpcy5jbGVhcigpO1xuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIHZhciBlbnRyeSA9IGVudHJpZXNbaW5kZXhdO1xuICAgIHRoaXMuc2V0KGVudHJ5WzBdLCBlbnRyeVsxXSk7XG4gIH1cbn1cblxuLyoqXG4gKiBSZW1vdmVzIGFsbCBrZXktdmFsdWUgZW50cmllcyBmcm9tIHRoZSBtYXAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGNsZWFyXG4gKiBAbWVtYmVyT2YgTWFwQ2FjaGVcbiAqL1xuZnVuY3Rpb24gbWFwQ2FjaGVDbGVhcigpIHtcbiAgdGhpcy5zaXplID0gMDtcbiAgdGhpcy5fX2RhdGFfXyA9IHtcbiAgICAnaGFzaCc6IG5ldyBIYXNoLFxuICAgICdtYXAnOiBuZXcgKE1hcCB8fCBMaXN0Q2FjaGUpLFxuICAgICdzdHJpbmcnOiBuZXcgSGFzaFxuICB9O1xufVxuXG4vKipcbiAqIFJlbW92ZXMgYGtleWAgYW5kIGl0cyB2YWx1ZSBmcm9tIHRoZSBtYXAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGRlbGV0ZVxuICogQG1lbWJlck9mIE1hcENhY2hlXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIHJlbW92ZS5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgZW50cnkgd2FzIHJlbW92ZWQsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gbWFwQ2FjaGVEZWxldGUoa2V5KSB7XG4gIHZhciByZXN1bHQgPSBnZXRNYXBEYXRhKHRoaXMsIGtleSlbJ2RlbGV0ZSddKGtleSk7XG4gIHRoaXMuc2l6ZSAtPSByZXN1bHQgPyAxIDogMDtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqXG4gKiBHZXRzIHRoZSBtYXAgdmFsdWUgZm9yIGBrZXlgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBnZXRcbiAqIEBtZW1iZXJPZiBNYXBDYWNoZVxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBnZXQuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgZW50cnkgdmFsdWUuXG4gKi9cbmZ1bmN0aW9uIG1hcENhY2hlR2V0KGtleSkge1xuICByZXR1cm4gZ2V0TWFwRGF0YSh0aGlzLCBrZXkpLmdldChrZXkpO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBhIG1hcCB2YWx1ZSBmb3IgYGtleWAgZXhpc3RzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBoYXNcbiAqIEBtZW1iZXJPZiBNYXBDYWNoZVxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBlbnRyeSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBhbiBlbnRyeSBmb3IgYGtleWAgZXhpc3RzLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIG1hcENhY2hlSGFzKGtleSkge1xuICByZXR1cm4gZ2V0TWFwRGF0YSh0aGlzLCBrZXkpLmhhcyhrZXkpO1xufVxuXG4vKipcbiAqIFNldHMgdGhlIG1hcCBga2V5YCB0byBgdmFsdWVgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBzZXRcbiAqIEBtZW1iZXJPZiBNYXBDYWNoZVxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBzZXQuXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBzZXQuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBtYXAgY2FjaGUgaW5zdGFuY2UuXG4gKi9cbmZ1bmN0aW9uIG1hcENhY2hlU2V0KGtleSwgdmFsdWUpIHtcbiAgdmFyIGRhdGEgPSBnZXRNYXBEYXRhKHRoaXMsIGtleSksXG4gICAgICBzaXplID0gZGF0YS5zaXplO1xuXG4gIGRhdGEuc2V0KGtleSwgdmFsdWUpO1xuICB0aGlzLnNpemUgKz0gZGF0YS5zaXplID09IHNpemUgPyAwIDogMTtcbiAgcmV0dXJuIHRoaXM7XG59XG5cbi8vIEFkZCBtZXRob2RzIHRvIGBNYXBDYWNoZWAuXG5NYXBDYWNoZS5wcm90b3R5cGUuY2xlYXIgPSBtYXBDYWNoZUNsZWFyO1xuTWFwQ2FjaGUucHJvdG90eXBlWydkZWxldGUnXSA9IG1hcENhY2hlRGVsZXRlO1xuTWFwQ2FjaGUucHJvdG90eXBlLmdldCA9IG1hcENhY2hlR2V0O1xuTWFwQ2FjaGUucHJvdG90eXBlLmhhcyA9IG1hcENhY2hlSGFzO1xuTWFwQ2FjaGUucHJvdG90eXBlLnNldCA9IG1hcENhY2hlU2V0O1xuXG4vKipcbiAqXG4gKiBDcmVhdGVzIGFuIGFycmF5IGNhY2hlIG9iamVjdCB0byBzdG9yZSB1bmlxdWUgdmFsdWVzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7QXJyYXl9IFt2YWx1ZXNdIFRoZSB2YWx1ZXMgdG8gY2FjaGUuXG4gKi9cbmZ1bmN0aW9uIFNldENhY2hlKHZhbHVlcykge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IHZhbHVlcyA9PSBudWxsID8gMCA6IHZhbHVlcy5sZW5ndGg7XG5cbiAgdGhpcy5fX2RhdGFfXyA9IG5ldyBNYXBDYWNoZTtcbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICB0aGlzLmFkZCh2YWx1ZXNbaW5kZXhdKTtcbiAgfVxufVxuXG4vKipcbiAqIEFkZHMgYHZhbHVlYCB0byB0aGUgYXJyYXkgY2FjaGUuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGFkZFxuICogQG1lbWJlck9mIFNldENhY2hlXG4gKiBAYWxpYXMgcHVzaFxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2FjaGUuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBjYWNoZSBpbnN0YW5jZS5cbiAqL1xuZnVuY3Rpb24gc2V0Q2FjaGVBZGQodmFsdWUpIHtcbiAgdGhpcy5fX2RhdGFfXy5zZXQodmFsdWUsIEhBU0hfVU5ERUZJTkVEKTtcbiAgcmV0dXJuIHRoaXM7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgaW4gdGhlIGFycmF5IGNhY2hlLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBoYXNcbiAqIEBtZW1iZXJPZiBTZXRDYWNoZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gc2VhcmNoIGZvci5cbiAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgZm91bmQsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gc2V0Q2FjaGVIYXModmFsdWUpIHtcbiAgcmV0dXJuIHRoaXMuX19kYXRhX18uaGFzKHZhbHVlKTtcbn1cblxuLy8gQWRkIG1ldGhvZHMgdG8gYFNldENhY2hlYC5cblNldENhY2hlLnByb3RvdHlwZS5hZGQgPSBTZXRDYWNoZS5wcm90b3R5cGUucHVzaCA9IHNldENhY2hlQWRkO1xuU2V0Q2FjaGUucHJvdG90eXBlLmhhcyA9IHNldENhY2hlSGFzO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBzdGFjayBjYWNoZSBvYmplY3QgdG8gc3RvcmUga2V5LXZhbHVlIHBhaXJzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7QXJyYXl9IFtlbnRyaWVzXSBUaGUga2V5LXZhbHVlIHBhaXJzIHRvIGNhY2hlLlxuICovXG5mdW5jdGlvbiBTdGFjayhlbnRyaWVzKSB7XG4gIHZhciBkYXRhID0gdGhpcy5fX2RhdGFfXyA9IG5ldyBMaXN0Q2FjaGUoZW50cmllcyk7XG4gIHRoaXMuc2l6ZSA9IGRhdGEuc2l6ZTtcbn1cblxuLyoqXG4gKiBSZW1vdmVzIGFsbCBrZXktdmFsdWUgZW50cmllcyBmcm9tIHRoZSBzdGFjay5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgY2xlYXJcbiAqIEBtZW1iZXJPZiBTdGFja1xuICovXG5mdW5jdGlvbiBzdGFja0NsZWFyKCkge1xuICB0aGlzLl9fZGF0YV9fID0gbmV3IExpc3RDYWNoZTtcbiAgdGhpcy5zaXplID0gMDtcbn1cblxuLyoqXG4gKiBSZW1vdmVzIGBrZXlgIGFuZCBpdHMgdmFsdWUgZnJvbSB0aGUgc3RhY2suXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGRlbGV0ZVxuICogQG1lbWJlck9mIFN0YWNrXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIHJlbW92ZS5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgZW50cnkgd2FzIHJlbW92ZWQsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gc3RhY2tEZWxldGUoa2V5KSB7XG4gIHZhciBkYXRhID0gdGhpcy5fX2RhdGFfXyxcbiAgICAgIHJlc3VsdCA9IGRhdGFbJ2RlbGV0ZSddKGtleSk7XG5cbiAgdGhpcy5zaXplID0gZGF0YS5zaXplO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG4vKipcbiAqIEdldHMgdGhlIHN0YWNrIHZhbHVlIGZvciBga2V5YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgZ2V0XG4gKiBAbWVtYmVyT2YgU3RhY2tcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gZ2V0LlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGVudHJ5IHZhbHVlLlxuICovXG5mdW5jdGlvbiBzdGFja0dldChrZXkpIHtcbiAgcmV0dXJuIHRoaXMuX19kYXRhX18uZ2V0KGtleSk7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGEgc3RhY2sgdmFsdWUgZm9yIGBrZXlgIGV4aXN0cy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgaGFzXG4gKiBAbWVtYmVyT2YgU3RhY2tcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgZW50cnkgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYW4gZW50cnkgZm9yIGBrZXlgIGV4aXN0cywgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBzdGFja0hhcyhrZXkpIHtcbiAgcmV0dXJuIHRoaXMuX19kYXRhX18uaGFzKGtleSk7XG59XG5cbi8qKlxuICogU2V0cyB0aGUgc3RhY2sgYGtleWAgdG8gYHZhbHVlYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgc2V0XG4gKiBAbWVtYmVyT2YgU3RhY2tcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gc2V0LlxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gc2V0LlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgc3RhY2sgY2FjaGUgaW5zdGFuY2UuXG4gKi9cbmZ1bmN0aW9uIHN0YWNrU2V0KGtleSwgdmFsdWUpIHtcbiAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fO1xuICBpZiAoZGF0YSBpbnN0YW5jZW9mIExpc3RDYWNoZSkge1xuICAgIHZhciBwYWlycyA9IGRhdGEuX19kYXRhX187XG4gICAgaWYgKCFNYXAgfHwgKHBhaXJzLmxlbmd0aCA8IExBUkdFX0FSUkFZX1NJWkUgLSAxKSkge1xuICAgICAgcGFpcnMucHVzaChba2V5LCB2YWx1ZV0pO1xuICAgICAgdGhpcy5zaXplID0gKytkYXRhLnNpemU7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgZGF0YSA9IHRoaXMuX19kYXRhX18gPSBuZXcgTWFwQ2FjaGUocGFpcnMpO1xuICB9XG4gIGRhdGEuc2V0KGtleSwgdmFsdWUpO1xuICB0aGlzLnNpemUgPSBkYXRhLnNpemU7XG4gIHJldHVybiB0aGlzO1xufVxuXG4vLyBBZGQgbWV0aG9kcyB0byBgU3RhY2tgLlxuU3RhY2sucHJvdG90eXBlLmNsZWFyID0gc3RhY2tDbGVhcjtcblN0YWNrLnByb3RvdHlwZVsnZGVsZXRlJ10gPSBzdGFja0RlbGV0ZTtcblN0YWNrLnByb3RvdHlwZS5nZXQgPSBzdGFja0dldDtcblN0YWNrLnByb3RvdHlwZS5oYXMgPSBzdGFja0hhcztcblN0YWNrLnByb3RvdHlwZS5zZXQgPSBzdGFja1NldDtcblxuLyoqXG4gKiBDcmVhdGVzIGFuIGFycmF5IG9mIHRoZSBlbnVtZXJhYmxlIHByb3BlcnR5IG5hbWVzIG9mIHRoZSBhcnJheS1saWtlIGB2YWx1ZWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHF1ZXJ5LlxuICogQHBhcmFtIHtib29sZWFufSBpbmhlcml0ZWQgU3BlY2lmeSByZXR1cm5pbmcgaW5oZXJpdGVkIHByb3BlcnR5IG5hbWVzLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBwcm9wZXJ0eSBuYW1lcy5cbiAqL1xuZnVuY3Rpb24gYXJyYXlMaWtlS2V5cyh2YWx1ZSwgaW5oZXJpdGVkKSB7XG4gIHZhciBpc0FyciA9IGlzQXJyYXkodmFsdWUpLFxuICAgICAgaXNBcmcgPSAhaXNBcnIgJiYgaXNBcmd1bWVudHModmFsdWUpLFxuICAgICAgaXNCdWZmID0gIWlzQXJyICYmICFpc0FyZyAmJiBpc0J1ZmZlcih2YWx1ZSksXG4gICAgICBpc1R5cGUgPSAhaXNBcnIgJiYgIWlzQXJnICYmICFpc0J1ZmYgJiYgaXNUeXBlZEFycmF5KHZhbHVlKSxcbiAgICAgIHNraXBJbmRleGVzID0gaXNBcnIgfHwgaXNBcmcgfHwgaXNCdWZmIHx8IGlzVHlwZSxcbiAgICAgIHJlc3VsdCA9IHNraXBJbmRleGVzID8gYmFzZVRpbWVzKHZhbHVlLmxlbmd0aCwgU3RyaW5nKSA6IFtdLFxuICAgICAgbGVuZ3RoID0gcmVzdWx0Lmxlbmd0aDtcblxuICBmb3IgKHZhciBrZXkgaW4gdmFsdWUpIHtcbiAgICBpZiAoKGluaGVyaXRlZCB8fCBoYXNPd25Qcm9wZXJ0eS5jYWxsKHZhbHVlLCBrZXkpKSAmJlxuICAgICAgICAhKHNraXBJbmRleGVzICYmIChcbiAgICAgICAgICAgLy8gU2FmYXJpIDkgaGFzIGVudW1lcmFibGUgYGFyZ3VtZW50cy5sZW5ndGhgIGluIHN0cmljdCBtb2RlLlxuICAgICAgICAgICBrZXkgPT0gJ2xlbmd0aCcgfHxcbiAgICAgICAgICAgLy8gTm9kZS5qcyAwLjEwIGhhcyBlbnVtZXJhYmxlIG5vbi1pbmRleCBwcm9wZXJ0aWVzIG9uIGJ1ZmZlcnMuXG4gICAgICAgICAgIChpc0J1ZmYgJiYgKGtleSA9PSAnb2Zmc2V0JyB8fCBrZXkgPT0gJ3BhcmVudCcpKSB8fFxuICAgICAgICAgICAvLyBQaGFudG9tSlMgMiBoYXMgZW51bWVyYWJsZSBub24taW5kZXggcHJvcGVydGllcyBvbiB0eXBlZCBhcnJheXMuXG4gICAgICAgICAgIChpc1R5cGUgJiYgKGtleSA9PSAnYnVmZmVyJyB8fCBrZXkgPT0gJ2J5dGVMZW5ndGgnIHx8IGtleSA9PSAnYnl0ZU9mZnNldCcpKSB8fFxuICAgICAgICAgICAvLyBTa2lwIGluZGV4IHByb3BlcnRpZXMuXG4gICAgICAgICAgIGlzSW5kZXgoa2V5LCBsZW5ndGgpXG4gICAgICAgICkpKSB7XG4gICAgICByZXN1bHQucHVzaChrZXkpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG4vKipcbiAqIEdldHMgdGhlIGluZGV4IGF0IHdoaWNoIHRoZSBga2V5YCBpcyBmb3VuZCBpbiBgYXJyYXlgIG9mIGtleS12YWx1ZSBwYWlycy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGluc3BlY3QuXG4gKiBAcGFyYW0geyp9IGtleSBUaGUga2V5IHRvIHNlYXJjaCBmb3IuXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBpbmRleCBvZiB0aGUgbWF0Y2hlZCB2YWx1ZSwgZWxzZSBgLTFgLlxuICovXG5mdW5jdGlvbiBhc3NvY0luZGV4T2YoYXJyYXksIGtleSkge1xuICB2YXIgbGVuZ3RoID0gYXJyYXkubGVuZ3RoO1xuICB3aGlsZSAobGVuZ3RoLS0pIHtcbiAgICBpZiAoZXEoYXJyYXlbbGVuZ3RoXVswXSwga2V5KSkge1xuICAgICAgcmV0dXJuIGxlbmd0aDtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIC0xO1xufVxuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBnZXRBbGxLZXlzYCBhbmQgYGdldEFsbEtleXNJbmAgd2hpY2ggdXNlc1xuICogYGtleXNGdW5jYCBhbmQgYHN5bWJvbHNGdW5jYCB0byBnZXQgdGhlIGVudW1lcmFibGUgcHJvcGVydHkgbmFtZXMgYW5kXG4gKiBzeW1ib2xzIG9mIGBvYmplY3RgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBrZXlzRnVuYyBUaGUgZnVuY3Rpb24gdG8gZ2V0IHRoZSBrZXlzIG9mIGBvYmplY3RgLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gc3ltYm9sc0Z1bmMgVGhlIGZ1bmN0aW9uIHRvIGdldCB0aGUgc3ltYm9scyBvZiBgb2JqZWN0YC5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgbmFtZXMgYW5kIHN5bWJvbHMuXG4gKi9cbmZ1bmN0aW9uIGJhc2VHZXRBbGxLZXlzKG9iamVjdCwga2V5c0Z1bmMsIHN5bWJvbHNGdW5jKSB7XG4gIHZhciByZXN1bHQgPSBrZXlzRnVuYyhvYmplY3QpO1xuICByZXR1cm4gaXNBcnJheShvYmplY3QpID8gcmVzdWx0IDogYXJyYXlQdXNoKHJlc3VsdCwgc3ltYm9sc0Z1bmMob2JqZWN0KSk7XG59XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYGdldFRhZ2Agd2l0aG91dCBmYWxsYmFja3MgZm9yIGJ1Z2d5IGVudmlyb25tZW50cy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBgdG9TdHJpbmdUYWdgLlxuICovXG5mdW5jdGlvbiBiYXNlR2V0VGFnKHZhbHVlKSB7XG4gIGlmICh2YWx1ZSA9PSBudWxsKSB7XG4gICAgcmV0dXJuIHZhbHVlID09PSB1bmRlZmluZWQgPyB1bmRlZmluZWRUYWcgOiBudWxsVGFnO1xuICB9XG4gIHJldHVybiAoc3ltVG9TdHJpbmdUYWcgJiYgc3ltVG9TdHJpbmdUYWcgaW4gT2JqZWN0KHZhbHVlKSlcbiAgICA/IGdldFJhd1RhZyh2YWx1ZSlcbiAgICA6IG9iamVjdFRvU3RyaW5nKHZhbHVlKTtcbn1cblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5pc0FyZ3VtZW50c2AuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYW4gYGFyZ3VtZW50c2Agb2JqZWN0LFxuICovXG5mdW5jdGlvbiBiYXNlSXNBcmd1bWVudHModmFsdWUpIHtcbiAgcmV0dXJuIGlzT2JqZWN0TGlrZSh2YWx1ZSkgJiYgYmFzZUdldFRhZyh2YWx1ZSkgPT0gYXJnc1RhZztcbn1cblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5pc0VxdWFsYCB3aGljaCBzdXBwb3J0cyBwYXJ0aWFsIGNvbXBhcmlzb25zXG4gKiBhbmQgdHJhY2tzIHRyYXZlcnNlZCBvYmplY3RzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjb21wYXJlLlxuICogQHBhcmFtIHsqfSBvdGhlciBUaGUgb3RoZXIgdmFsdWUgdG8gY29tcGFyZS5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gYml0bWFzayBUaGUgYml0bWFzayBmbGFncy5cbiAqICAxIC0gVW5vcmRlcmVkIGNvbXBhcmlzb25cbiAqICAyIC0gUGFydGlhbCBjb21wYXJpc29uXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY3VzdG9taXplcl0gVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBjb21wYXJpc29ucy5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbc3RhY2tdIFRyYWNrcyB0cmF2ZXJzZWQgYHZhbHVlYCBhbmQgYG90aGVyYCBvYmplY3RzLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSB2YWx1ZXMgYXJlIGVxdWl2YWxlbnQsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gYmFzZUlzRXF1YWwodmFsdWUsIG90aGVyLCBiaXRtYXNrLCBjdXN0b21pemVyLCBzdGFjaykge1xuICBpZiAodmFsdWUgPT09IG90aGVyKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgaWYgKHZhbHVlID09IG51bGwgfHwgb3RoZXIgPT0gbnVsbCB8fCAoIWlzT2JqZWN0TGlrZSh2YWx1ZSkgJiYgIWlzT2JqZWN0TGlrZShvdGhlcikpKSB7XG4gICAgcmV0dXJuIHZhbHVlICE9PSB2YWx1ZSAmJiBvdGhlciAhPT0gb3RoZXI7XG4gIH1cbiAgcmV0dXJuIGJhc2VJc0VxdWFsRGVlcCh2YWx1ZSwgb3RoZXIsIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIGJhc2VJc0VxdWFsLCBzdGFjayk7XG59XG5cbi8qKlxuICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBiYXNlSXNFcXVhbGAgZm9yIGFycmF5cyBhbmQgb2JqZWN0cyB3aGljaCBwZXJmb3Jtc1xuICogZGVlcCBjb21wYXJpc29ucyBhbmQgdHJhY2tzIHRyYXZlcnNlZCBvYmplY3RzIGVuYWJsaW5nIG9iamVjdHMgd2l0aCBjaXJjdWxhclxuICogcmVmZXJlbmNlcyB0byBiZSBjb21wYXJlZC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGNvbXBhcmUuXG4gKiBAcGFyYW0ge09iamVjdH0gb3RoZXIgVGhlIG90aGVyIG9iamVjdCB0byBjb21wYXJlLlxuICogQHBhcmFtIHtudW1iZXJ9IGJpdG1hc2sgVGhlIGJpdG1hc2sgZmxhZ3MuIFNlZSBgYmFzZUlzRXF1YWxgIGZvciBtb3JlIGRldGFpbHMuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjdXN0b21pemVyIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgY29tcGFyaXNvbnMuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBlcXVhbEZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGRldGVybWluZSBlcXVpdmFsZW50cyBvZiB2YWx1ZXMuXG4gKiBAcGFyYW0ge09iamVjdH0gW3N0YWNrXSBUcmFja3MgdHJhdmVyc2VkIGBvYmplY3RgIGFuZCBgb3RoZXJgIG9iamVjdHMuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIG9iamVjdHMgYXJlIGVxdWl2YWxlbnQsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gYmFzZUlzRXF1YWxEZWVwKG9iamVjdCwgb3RoZXIsIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIGVxdWFsRnVuYywgc3RhY2spIHtcbiAgdmFyIG9iaklzQXJyID0gaXNBcnJheShvYmplY3QpLFxuICAgICAgb3RoSXNBcnIgPSBpc0FycmF5KG90aGVyKSxcbiAgICAgIG9ialRhZyA9IG9iaklzQXJyID8gYXJyYXlUYWcgOiBnZXRUYWcob2JqZWN0KSxcbiAgICAgIG90aFRhZyA9IG90aElzQXJyID8gYXJyYXlUYWcgOiBnZXRUYWcob3RoZXIpO1xuXG4gIG9ialRhZyA9IG9ialRhZyA9PSBhcmdzVGFnID8gb2JqZWN0VGFnIDogb2JqVGFnO1xuICBvdGhUYWcgPSBvdGhUYWcgPT0gYXJnc1RhZyA/IG9iamVjdFRhZyA6IG90aFRhZztcblxuICB2YXIgb2JqSXNPYmogPSBvYmpUYWcgPT0gb2JqZWN0VGFnLFxuICAgICAgb3RoSXNPYmogPSBvdGhUYWcgPT0gb2JqZWN0VGFnLFxuICAgICAgaXNTYW1lVGFnID0gb2JqVGFnID09IG90aFRhZztcblxuICBpZiAoaXNTYW1lVGFnICYmIGlzQnVmZmVyKG9iamVjdCkpIHtcbiAgICBpZiAoIWlzQnVmZmVyKG90aGVyKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBvYmpJc0FyciA9IHRydWU7XG4gICAgb2JqSXNPYmogPSBmYWxzZTtcbiAgfVxuICBpZiAoaXNTYW1lVGFnICYmICFvYmpJc09iaikge1xuICAgIHN0YWNrIHx8IChzdGFjayA9IG5ldyBTdGFjayk7XG4gICAgcmV0dXJuIChvYmpJc0FyciB8fCBpc1R5cGVkQXJyYXkob2JqZWN0KSlcbiAgICAgID8gZXF1YWxBcnJheXMob2JqZWN0LCBvdGhlciwgYml0bWFzaywgY3VzdG9taXplciwgZXF1YWxGdW5jLCBzdGFjaylcbiAgICAgIDogZXF1YWxCeVRhZyhvYmplY3QsIG90aGVyLCBvYmpUYWcsIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIGVxdWFsRnVuYywgc3RhY2spO1xuICB9XG4gIGlmICghKGJpdG1hc2sgJiBDT01QQVJFX1BBUlRJQUxfRkxBRykpIHtcbiAgICB2YXIgb2JqSXNXcmFwcGVkID0gb2JqSXNPYmogJiYgaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsICdfX3dyYXBwZWRfXycpLFxuICAgICAgICBvdGhJc1dyYXBwZWQgPSBvdGhJc09iaiAmJiBoYXNPd25Qcm9wZXJ0eS5jYWxsKG90aGVyLCAnX193cmFwcGVkX18nKTtcblxuICAgIGlmIChvYmpJc1dyYXBwZWQgfHwgb3RoSXNXcmFwcGVkKSB7XG4gICAgICB2YXIgb2JqVW53cmFwcGVkID0gb2JqSXNXcmFwcGVkID8gb2JqZWN0LnZhbHVlKCkgOiBvYmplY3QsXG4gICAgICAgICAgb3RoVW53cmFwcGVkID0gb3RoSXNXcmFwcGVkID8gb3RoZXIudmFsdWUoKSA6IG90aGVyO1xuXG4gICAgICBzdGFjayB8fCAoc3RhY2sgPSBuZXcgU3RhY2spO1xuICAgICAgcmV0dXJuIGVxdWFsRnVuYyhvYmpVbndyYXBwZWQsIG90aFVud3JhcHBlZCwgYml0bWFzaywgY3VzdG9taXplciwgc3RhY2spO1xuICAgIH1cbiAgfVxuICBpZiAoIWlzU2FtZVRhZykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBzdGFjayB8fCAoc3RhY2sgPSBuZXcgU3RhY2spO1xuICByZXR1cm4gZXF1YWxPYmplY3RzKG9iamVjdCwgb3RoZXIsIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIGVxdWFsRnVuYywgc3RhY2spO1xufVxuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmlzTmF0aXZlYCB3aXRob3V0IGJhZCBzaGltIGNoZWNrcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIG5hdGl2ZSBmdW5jdGlvbixcbiAqICBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGJhc2VJc05hdGl2ZSh2YWx1ZSkge1xuICBpZiAoIWlzT2JqZWN0KHZhbHVlKSB8fCBpc01hc2tlZCh2YWx1ZSkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgdmFyIHBhdHRlcm4gPSBpc0Z1bmN0aW9uKHZhbHVlKSA/IHJlSXNOYXRpdmUgOiByZUlzSG9zdEN0b3I7XG4gIHJldHVybiBwYXR0ZXJuLnRlc3QodG9Tb3VyY2UodmFsdWUpKTtcbn1cblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5pc1R5cGVkQXJyYXlgIHdpdGhvdXQgTm9kZS5qcyBvcHRpbWl6YXRpb25zLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgdHlwZWQgYXJyYXksIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gYmFzZUlzVHlwZWRBcnJheSh2YWx1ZSkge1xuICByZXR1cm4gaXNPYmplY3RMaWtlKHZhbHVlKSAmJlxuICAgIGlzTGVuZ3RoKHZhbHVlLmxlbmd0aCkgJiYgISF0eXBlZEFycmF5VGFnc1tiYXNlR2V0VGFnKHZhbHVlKV07XG59XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8ua2V5c2Agd2hpY2ggZG9lc24ndCB0cmVhdCBzcGFyc2UgYXJyYXlzIGFzIGRlbnNlLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHByb3BlcnR5IG5hbWVzLlxuICovXG5mdW5jdGlvbiBiYXNlS2V5cyhvYmplY3QpIHtcbiAgaWYgKCFpc1Byb3RvdHlwZShvYmplY3QpKSB7XG4gICAgcmV0dXJuIG5hdGl2ZUtleXMob2JqZWN0KTtcbiAgfVxuICB2YXIgcmVzdWx0ID0gW107XG4gIGZvciAodmFyIGtleSBpbiBPYmplY3Qob2JqZWN0KSkge1xuICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwga2V5KSAmJiBrZXkgIT0gJ2NvbnN0cnVjdG9yJykge1xuICAgICAgcmVzdWx0LnB1c2goa2V5KTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqXG4gKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYGJhc2VJc0VxdWFsRGVlcGAgZm9yIGFycmF5cyB3aXRoIHN1cHBvcnQgZm9yXG4gKiBwYXJ0aWFsIGRlZXAgY29tcGFyaXNvbnMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBjb21wYXJlLlxuICogQHBhcmFtIHtBcnJheX0gb3RoZXIgVGhlIG90aGVyIGFycmF5IHRvIGNvbXBhcmUuXG4gKiBAcGFyYW0ge251bWJlcn0gYml0bWFzayBUaGUgYml0bWFzayBmbGFncy4gU2VlIGBiYXNlSXNFcXVhbGAgZm9yIG1vcmUgZGV0YWlscy5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGN1c3RvbWl6ZXIgVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBjb21wYXJpc29ucy5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGVxdWFsRnVuYyBUaGUgZnVuY3Rpb24gdG8gZGV0ZXJtaW5lIGVxdWl2YWxlbnRzIG9mIHZhbHVlcy5cbiAqIEBwYXJhbSB7T2JqZWN0fSBzdGFjayBUcmFja3MgdHJhdmVyc2VkIGBhcnJheWAgYW5kIGBvdGhlcmAgb2JqZWN0cy5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgYXJyYXlzIGFyZSBlcXVpdmFsZW50LCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGVxdWFsQXJyYXlzKGFycmF5LCBvdGhlciwgYml0bWFzaywgY3VzdG9taXplciwgZXF1YWxGdW5jLCBzdGFjaykge1xuICB2YXIgaXNQYXJ0aWFsID0gYml0bWFzayAmIENPTVBBUkVfUEFSVElBTF9GTEFHLFxuICAgICAgYXJyTGVuZ3RoID0gYXJyYXkubGVuZ3RoLFxuICAgICAgb3RoTGVuZ3RoID0gb3RoZXIubGVuZ3RoO1xuXG4gIGlmIChhcnJMZW5ndGggIT0gb3RoTGVuZ3RoICYmICEoaXNQYXJ0aWFsICYmIG90aExlbmd0aCA+IGFyckxlbmd0aCkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgLy8gQXNzdW1lIGN5Y2xpYyB2YWx1ZXMgYXJlIGVxdWFsLlxuICB2YXIgc3RhY2tlZCA9IHN0YWNrLmdldChhcnJheSk7XG4gIGlmIChzdGFja2VkICYmIHN0YWNrLmdldChvdGhlcikpIHtcbiAgICByZXR1cm4gc3RhY2tlZCA9PSBvdGhlcjtcbiAgfVxuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIHJlc3VsdCA9IHRydWUsXG4gICAgICBzZWVuID0gKGJpdG1hc2sgJiBDT01QQVJFX1VOT1JERVJFRF9GTEFHKSA/IG5ldyBTZXRDYWNoZSA6IHVuZGVmaW5lZDtcblxuICBzdGFjay5zZXQoYXJyYXksIG90aGVyKTtcbiAgc3RhY2suc2V0KG90aGVyLCBhcnJheSk7XG5cbiAgLy8gSWdub3JlIG5vbi1pbmRleCBwcm9wZXJ0aWVzLlxuICB3aGlsZSAoKytpbmRleCA8IGFyckxlbmd0aCkge1xuICAgIHZhciBhcnJWYWx1ZSA9IGFycmF5W2luZGV4XSxcbiAgICAgICAgb3RoVmFsdWUgPSBvdGhlcltpbmRleF07XG5cbiAgICBpZiAoY3VzdG9taXplcikge1xuICAgICAgdmFyIGNvbXBhcmVkID0gaXNQYXJ0aWFsXG4gICAgICAgID8gY3VzdG9taXplcihvdGhWYWx1ZSwgYXJyVmFsdWUsIGluZGV4LCBvdGhlciwgYXJyYXksIHN0YWNrKVxuICAgICAgICA6IGN1c3RvbWl6ZXIoYXJyVmFsdWUsIG90aFZhbHVlLCBpbmRleCwgYXJyYXksIG90aGVyLCBzdGFjayk7XG4gICAgfVxuICAgIGlmIChjb21wYXJlZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBpZiAoY29tcGFyZWQpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICByZXN1bHQgPSBmYWxzZTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICAvLyBSZWN1cnNpdmVseSBjb21wYXJlIGFycmF5cyAoc3VzY2VwdGlibGUgdG8gY2FsbCBzdGFjayBsaW1pdHMpLlxuICAgIGlmIChzZWVuKSB7XG4gICAgICBpZiAoIWFycmF5U29tZShvdGhlciwgZnVuY3Rpb24ob3RoVmFsdWUsIG90aEluZGV4KSB7XG4gICAgICAgICAgICBpZiAoIWNhY2hlSGFzKHNlZW4sIG90aEluZGV4KSAmJlxuICAgICAgICAgICAgICAgIChhcnJWYWx1ZSA9PT0gb3RoVmFsdWUgfHwgZXF1YWxGdW5jKGFyclZhbHVlLCBvdGhWYWx1ZSwgYml0bWFzaywgY3VzdG9taXplciwgc3RhY2spKSkge1xuICAgICAgICAgICAgICByZXR1cm4gc2Vlbi5wdXNoKG90aEluZGV4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KSkge1xuICAgICAgICByZXN1bHQgPSBmYWxzZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICghKFxuICAgICAgICAgIGFyclZhbHVlID09PSBvdGhWYWx1ZSB8fFxuICAgICAgICAgICAgZXF1YWxGdW5jKGFyclZhbHVlLCBvdGhWYWx1ZSwgYml0bWFzaywgY3VzdG9taXplciwgc3RhY2spXG4gICAgICAgICkpIHtcbiAgICAgIHJlc3VsdCA9IGZhbHNlO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG4gIHN0YWNrWydkZWxldGUnXShhcnJheSk7XG4gIHN0YWNrWydkZWxldGUnXShvdGhlcik7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbi8qKlxuICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBiYXNlSXNFcXVhbERlZXBgIGZvciBjb21wYXJpbmcgb2JqZWN0cyBvZlxuICogdGhlIHNhbWUgYHRvU3RyaW5nVGFnYC5cbiAqXG4gKiAqKk5vdGU6KiogVGhpcyBmdW5jdGlvbiBvbmx5IHN1cHBvcnRzIGNvbXBhcmluZyB2YWx1ZXMgd2l0aCB0YWdzIG9mXG4gKiBgQm9vbGVhbmAsIGBEYXRlYCwgYEVycm9yYCwgYE51bWJlcmAsIGBSZWdFeHBgLCBvciBgU3RyaW5nYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGNvbXBhcmUuXG4gKiBAcGFyYW0ge09iamVjdH0gb3RoZXIgVGhlIG90aGVyIG9iamVjdCB0byBjb21wYXJlLlxuICogQHBhcmFtIHtzdHJpbmd9IHRhZyBUaGUgYHRvU3RyaW5nVGFnYCBvZiB0aGUgb2JqZWN0cyB0byBjb21wYXJlLlxuICogQHBhcmFtIHtudW1iZXJ9IGJpdG1hc2sgVGhlIGJpdG1hc2sgZmxhZ3MuIFNlZSBgYmFzZUlzRXF1YWxgIGZvciBtb3JlIGRldGFpbHMuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjdXN0b21pemVyIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgY29tcGFyaXNvbnMuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBlcXVhbEZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGRldGVybWluZSBlcXVpdmFsZW50cyBvZiB2YWx1ZXMuXG4gKiBAcGFyYW0ge09iamVjdH0gc3RhY2sgVHJhY2tzIHRyYXZlcnNlZCBgb2JqZWN0YCBhbmQgYG90aGVyYCBvYmplY3RzLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBvYmplY3RzIGFyZSBlcXVpdmFsZW50LCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGVxdWFsQnlUYWcob2JqZWN0LCBvdGhlciwgdGFnLCBiaXRtYXNrLCBjdXN0b21pemVyLCBlcXVhbEZ1bmMsIHN0YWNrKSB7XG4gIHN3aXRjaCAodGFnKSB7XG4gICAgY2FzZSBkYXRhVmlld1RhZzpcbiAgICAgIGlmICgob2JqZWN0LmJ5dGVMZW5ndGggIT0gb3RoZXIuYnl0ZUxlbmd0aCkgfHxcbiAgICAgICAgICAob2JqZWN0LmJ5dGVPZmZzZXQgIT0gb3RoZXIuYnl0ZU9mZnNldCkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgb2JqZWN0ID0gb2JqZWN0LmJ1ZmZlcjtcbiAgICAgIG90aGVyID0gb3RoZXIuYnVmZmVyO1xuXG4gICAgY2FzZSBhcnJheUJ1ZmZlclRhZzpcbiAgICAgIGlmICgob2JqZWN0LmJ5dGVMZW5ndGggIT0gb3RoZXIuYnl0ZUxlbmd0aCkgfHxcbiAgICAgICAgICAhZXF1YWxGdW5jKG5ldyBVaW50OEFycmF5KG9iamVjdCksIG5ldyBVaW50OEFycmF5KG90aGVyKSkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRydWU7XG5cbiAgICBjYXNlIGJvb2xUYWc6XG4gICAgY2FzZSBkYXRlVGFnOlxuICAgIGNhc2UgbnVtYmVyVGFnOlxuICAgICAgLy8gQ29lcmNlIGJvb2xlYW5zIHRvIGAxYCBvciBgMGAgYW5kIGRhdGVzIHRvIG1pbGxpc2Vjb25kcy5cbiAgICAgIC8vIEludmFsaWQgZGF0ZXMgYXJlIGNvZXJjZWQgdG8gYE5hTmAuXG4gICAgICByZXR1cm4gZXEoK29iamVjdCwgK290aGVyKTtcblxuICAgIGNhc2UgZXJyb3JUYWc6XG4gICAgICByZXR1cm4gb2JqZWN0Lm5hbWUgPT0gb3RoZXIubmFtZSAmJiBvYmplY3QubWVzc2FnZSA9PSBvdGhlci5tZXNzYWdlO1xuXG4gICAgY2FzZSByZWdleHBUYWc6XG4gICAgY2FzZSBzdHJpbmdUYWc6XG4gICAgICAvLyBDb2VyY2UgcmVnZXhlcyB0byBzdHJpbmdzIGFuZCB0cmVhdCBzdHJpbmdzLCBwcmltaXRpdmVzIGFuZCBvYmplY3RzLFxuICAgICAgLy8gYXMgZXF1YWwuIFNlZSBodHRwOi8vd3d3LmVjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtcmVnZXhwLnByb3RvdHlwZS50b3N0cmluZ1xuICAgICAgLy8gZm9yIG1vcmUgZGV0YWlscy5cbiAgICAgIHJldHVybiBvYmplY3QgPT0gKG90aGVyICsgJycpO1xuXG4gICAgY2FzZSBtYXBUYWc6XG4gICAgICB2YXIgY29udmVydCA9IG1hcFRvQXJyYXk7XG5cbiAgICBjYXNlIHNldFRhZzpcbiAgICAgIHZhciBpc1BhcnRpYWwgPSBiaXRtYXNrICYgQ09NUEFSRV9QQVJUSUFMX0ZMQUc7XG4gICAgICBjb252ZXJ0IHx8IChjb252ZXJ0ID0gc2V0VG9BcnJheSk7XG5cbiAgICAgIGlmIChvYmplY3Quc2l6ZSAhPSBvdGhlci5zaXplICYmICFpc1BhcnRpYWwpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgLy8gQXNzdW1lIGN5Y2xpYyB2YWx1ZXMgYXJlIGVxdWFsLlxuICAgICAgdmFyIHN0YWNrZWQgPSBzdGFjay5nZXQob2JqZWN0KTtcbiAgICAgIGlmIChzdGFja2VkKSB7XG4gICAgICAgIHJldHVybiBzdGFja2VkID09IG90aGVyO1xuICAgICAgfVxuICAgICAgYml0bWFzayB8PSBDT01QQVJFX1VOT1JERVJFRF9GTEFHO1xuXG4gICAgICAvLyBSZWN1cnNpdmVseSBjb21wYXJlIG9iamVjdHMgKHN1c2NlcHRpYmxlIHRvIGNhbGwgc3RhY2sgbGltaXRzKS5cbiAgICAgIHN0YWNrLnNldChvYmplY3QsIG90aGVyKTtcbiAgICAgIHZhciByZXN1bHQgPSBlcXVhbEFycmF5cyhjb252ZXJ0KG9iamVjdCksIGNvbnZlcnQob3RoZXIpLCBiaXRtYXNrLCBjdXN0b21pemVyLCBlcXVhbEZ1bmMsIHN0YWNrKTtcbiAgICAgIHN0YWNrWydkZWxldGUnXShvYmplY3QpO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcblxuICAgIGNhc2Ugc3ltYm9sVGFnOlxuICAgICAgaWYgKHN5bWJvbFZhbHVlT2YpIHtcbiAgICAgICAgcmV0dXJuIHN5bWJvbFZhbHVlT2YuY2FsbChvYmplY3QpID09IHN5bWJvbFZhbHVlT2YuY2FsbChvdGhlcik7XG4gICAgICB9XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG4vKipcbiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgYmFzZUlzRXF1YWxEZWVwYCBmb3Igb2JqZWN0cyB3aXRoIHN1cHBvcnQgZm9yXG4gKiBwYXJ0aWFsIGRlZXAgY29tcGFyaXNvbnMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBjb21wYXJlLlxuICogQHBhcmFtIHtPYmplY3R9IG90aGVyIFRoZSBvdGhlciBvYmplY3QgdG8gY29tcGFyZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBiaXRtYXNrIFRoZSBiaXRtYXNrIGZsYWdzLiBTZWUgYGJhc2VJc0VxdWFsYCBmb3IgbW9yZSBkZXRhaWxzLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gY3VzdG9taXplciBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIGNvbXBhcmlzb25zLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZXF1YWxGdW5jIFRoZSBmdW5jdGlvbiB0byBkZXRlcm1pbmUgZXF1aXZhbGVudHMgb2YgdmFsdWVzLlxuICogQHBhcmFtIHtPYmplY3R9IHN0YWNrIFRyYWNrcyB0cmF2ZXJzZWQgYG9iamVjdGAgYW5kIGBvdGhlcmAgb2JqZWN0cy5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgb2JqZWN0cyBhcmUgZXF1aXZhbGVudCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBlcXVhbE9iamVjdHMob2JqZWN0LCBvdGhlciwgYml0bWFzaywgY3VzdG9taXplciwgZXF1YWxGdW5jLCBzdGFjaykge1xuICB2YXIgaXNQYXJ0aWFsID0gYml0bWFzayAmIENPTVBBUkVfUEFSVElBTF9GTEFHLFxuICAgICAgb2JqUHJvcHMgPSBnZXRBbGxLZXlzKG9iamVjdCksXG4gICAgICBvYmpMZW5ndGggPSBvYmpQcm9wcy5sZW5ndGgsXG4gICAgICBvdGhQcm9wcyA9IGdldEFsbEtleXMob3RoZXIpLFxuICAgICAgb3RoTGVuZ3RoID0gb3RoUHJvcHMubGVuZ3RoO1xuXG4gIGlmIChvYmpMZW5ndGggIT0gb3RoTGVuZ3RoICYmICFpc1BhcnRpYWwpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgdmFyIGluZGV4ID0gb2JqTGVuZ3RoO1xuICB3aGlsZSAoaW5kZXgtLSkge1xuICAgIHZhciBrZXkgPSBvYmpQcm9wc1tpbmRleF07XG4gICAgaWYgKCEoaXNQYXJ0aWFsID8ga2V5IGluIG90aGVyIDogaGFzT3duUHJvcGVydHkuY2FsbChvdGhlciwga2V5KSkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbiAgLy8gQXNzdW1lIGN5Y2xpYyB2YWx1ZXMgYXJlIGVxdWFsLlxuICB2YXIgc3RhY2tlZCA9IHN0YWNrLmdldChvYmplY3QpO1xuICBpZiAoc3RhY2tlZCAmJiBzdGFjay5nZXQob3RoZXIpKSB7XG4gICAgcmV0dXJuIHN0YWNrZWQgPT0gb3RoZXI7XG4gIH1cbiAgdmFyIHJlc3VsdCA9IHRydWU7XG4gIHN0YWNrLnNldChvYmplY3QsIG90aGVyKTtcbiAgc3RhY2suc2V0KG90aGVyLCBvYmplY3QpO1xuXG4gIHZhciBza2lwQ3RvciA9IGlzUGFydGlhbDtcbiAgd2hpbGUgKCsraW5kZXggPCBvYmpMZW5ndGgpIHtcbiAgICBrZXkgPSBvYmpQcm9wc1tpbmRleF07XG4gICAgdmFyIG9ialZhbHVlID0gb2JqZWN0W2tleV0sXG4gICAgICAgIG90aFZhbHVlID0gb3RoZXJba2V5XTtcblxuICAgIGlmIChjdXN0b21pemVyKSB7XG4gICAgICB2YXIgY29tcGFyZWQgPSBpc1BhcnRpYWxcbiAgICAgICAgPyBjdXN0b21pemVyKG90aFZhbHVlLCBvYmpWYWx1ZSwga2V5LCBvdGhlciwgb2JqZWN0LCBzdGFjaylcbiAgICAgICAgOiBjdXN0b21pemVyKG9ialZhbHVlLCBvdGhWYWx1ZSwga2V5LCBvYmplY3QsIG90aGVyLCBzdGFjayk7XG4gICAgfVxuICAgIC8vIFJlY3Vyc2l2ZWx5IGNvbXBhcmUgb2JqZWN0cyAoc3VzY2VwdGlibGUgdG8gY2FsbCBzdGFjayBsaW1pdHMpLlxuICAgIGlmICghKGNvbXBhcmVkID09PSB1bmRlZmluZWRcbiAgICAgICAgICA/IChvYmpWYWx1ZSA9PT0gb3RoVmFsdWUgfHwgZXF1YWxGdW5jKG9ialZhbHVlLCBvdGhWYWx1ZSwgYml0bWFzaywgY3VzdG9taXplciwgc3RhY2spKVxuICAgICAgICAgIDogY29tcGFyZWRcbiAgICAgICAgKSkge1xuICAgICAgcmVzdWx0ID0gZmFsc2U7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgc2tpcEN0b3IgfHwgKHNraXBDdG9yID0ga2V5ID09ICdjb25zdHJ1Y3RvcicpO1xuICB9XG4gIGlmIChyZXN1bHQgJiYgIXNraXBDdG9yKSB7XG4gICAgdmFyIG9iakN0b3IgPSBvYmplY3QuY29uc3RydWN0b3IsXG4gICAgICAgIG90aEN0b3IgPSBvdGhlci5jb25zdHJ1Y3RvcjtcblxuICAgIC8vIE5vbiBgT2JqZWN0YCBvYmplY3QgaW5zdGFuY2VzIHdpdGggZGlmZmVyZW50IGNvbnN0cnVjdG9ycyBhcmUgbm90IGVxdWFsLlxuICAgIGlmIChvYmpDdG9yICE9IG90aEN0b3IgJiZcbiAgICAgICAgKCdjb25zdHJ1Y3RvcicgaW4gb2JqZWN0ICYmICdjb25zdHJ1Y3RvcicgaW4gb3RoZXIpICYmXG4gICAgICAgICEodHlwZW9mIG9iakN0b3IgPT0gJ2Z1bmN0aW9uJyAmJiBvYmpDdG9yIGluc3RhbmNlb2Ygb2JqQ3RvciAmJlxuICAgICAgICAgIHR5cGVvZiBvdGhDdG9yID09ICdmdW5jdGlvbicgJiYgb3RoQ3RvciBpbnN0YW5jZW9mIG90aEN0b3IpKSB7XG4gICAgICByZXN1bHQgPSBmYWxzZTtcbiAgICB9XG4gIH1cbiAgc3RhY2tbJ2RlbGV0ZSddKG9iamVjdCk7XG4gIHN0YWNrWydkZWxldGUnXShvdGhlcik7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhbiBhcnJheSBvZiBvd24gZW51bWVyYWJsZSBwcm9wZXJ0eSBuYW1lcyBhbmQgc3ltYm9scyBvZiBgb2JqZWN0YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBwcm9wZXJ0eSBuYW1lcyBhbmQgc3ltYm9scy5cbiAqL1xuZnVuY3Rpb24gZ2V0QWxsS2V5cyhvYmplY3QpIHtcbiAgcmV0dXJuIGJhc2VHZXRBbGxLZXlzKG9iamVjdCwga2V5cywgZ2V0U3ltYm9scyk7XG59XG5cbi8qKlxuICogR2V0cyB0aGUgZGF0YSBmb3IgYG1hcGAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBtYXAgVGhlIG1hcCB0byBxdWVyeS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIHJlZmVyZW5jZSBrZXkuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgbWFwIGRhdGEuXG4gKi9cbmZ1bmN0aW9uIGdldE1hcERhdGEobWFwLCBrZXkpIHtcbiAgdmFyIGRhdGEgPSBtYXAuX19kYXRhX187XG4gIHJldHVybiBpc0tleWFibGUoa2V5KVxuICAgID8gZGF0YVt0eXBlb2Yga2V5ID09ICdzdHJpbmcnID8gJ3N0cmluZycgOiAnaGFzaCddXG4gICAgOiBkYXRhLm1hcDtcbn1cblxuLyoqXG4gKiBHZXRzIHRoZSBuYXRpdmUgZnVuY3Rpb24gYXQgYGtleWAgb2YgYG9iamVjdGAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgbWV0aG9kIHRvIGdldC5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBmdW5jdGlvbiBpZiBpdCdzIG5hdGl2ZSwgZWxzZSBgdW5kZWZpbmVkYC5cbiAqL1xuZnVuY3Rpb24gZ2V0TmF0aXZlKG9iamVjdCwga2V5KSB7XG4gIHZhciB2YWx1ZSA9IGdldFZhbHVlKG9iamVjdCwga2V5KTtcbiAgcmV0dXJuIGJhc2VJc05hdGl2ZSh2YWx1ZSkgPyB2YWx1ZSA6IHVuZGVmaW5lZDtcbn1cblxuLyoqXG4gKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYGJhc2VHZXRUYWdgIHdoaWNoIGlnbm9yZXMgYFN5bWJvbC50b1N0cmluZ1RhZ2AgdmFsdWVzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIHJhdyBgdG9TdHJpbmdUYWdgLlxuICovXG5mdW5jdGlvbiBnZXRSYXdUYWcodmFsdWUpIHtcbiAgdmFyIGlzT3duID0gaGFzT3duUHJvcGVydHkuY2FsbCh2YWx1ZSwgc3ltVG9TdHJpbmdUYWcpLFxuICAgICAgdGFnID0gdmFsdWVbc3ltVG9TdHJpbmdUYWddO1xuXG4gIHRyeSB7XG4gICAgdmFsdWVbc3ltVG9TdHJpbmdUYWddID0gdW5kZWZpbmVkO1xuICAgIHZhciB1bm1hc2tlZCA9IHRydWU7XG4gIH0gY2F0Y2ggKGUpIHt9XG5cbiAgdmFyIHJlc3VsdCA9IG5hdGl2ZU9iamVjdFRvU3RyaW5nLmNhbGwodmFsdWUpO1xuICBpZiAodW5tYXNrZWQpIHtcbiAgICBpZiAoaXNPd24pIHtcbiAgICAgIHZhbHVlW3N5bVRvU3RyaW5nVGFnXSA9IHRhZztcbiAgICB9IGVsc2Uge1xuICAgICAgZGVsZXRlIHZhbHVlW3N5bVRvU3RyaW5nVGFnXTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGFuIGFycmF5IG9mIHRoZSBvd24gZW51bWVyYWJsZSBzeW1ib2xzIG9mIGBvYmplY3RgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHN5bWJvbHMuXG4gKi9cbnZhciBnZXRTeW1ib2xzID0gIW5hdGl2ZUdldFN5bWJvbHMgPyBzdHViQXJyYXkgOiBmdW5jdGlvbihvYmplY3QpIHtcbiAgaWYgKG9iamVjdCA9PSBudWxsKSB7XG4gICAgcmV0dXJuIFtdO1xuICB9XG4gIG9iamVjdCA9IE9iamVjdChvYmplY3QpO1xuICByZXR1cm4gYXJyYXlGaWx0ZXIobmF0aXZlR2V0U3ltYm9scyhvYmplY3QpLCBmdW5jdGlvbihzeW1ib2wpIHtcbiAgICByZXR1cm4gcHJvcGVydHlJc0VudW1lcmFibGUuY2FsbChvYmplY3QsIHN5bWJvbCk7XG4gIH0pO1xufTtcblxuLyoqXG4gKiBHZXRzIHRoZSBgdG9TdHJpbmdUYWdgIG9mIGB2YWx1ZWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHF1ZXJ5LlxuICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgYHRvU3RyaW5nVGFnYC5cbiAqL1xudmFyIGdldFRhZyA9IGJhc2VHZXRUYWc7XG5cbi8vIEZhbGxiYWNrIGZvciBkYXRhIHZpZXdzLCBtYXBzLCBzZXRzLCBhbmQgd2VhayBtYXBzIGluIElFIDExIGFuZCBwcm9taXNlcyBpbiBOb2RlLmpzIDwgNi5cbmlmICgoRGF0YVZpZXcgJiYgZ2V0VGFnKG5ldyBEYXRhVmlldyhuZXcgQXJyYXlCdWZmZXIoMSkpKSAhPSBkYXRhVmlld1RhZykgfHxcbiAgICAoTWFwICYmIGdldFRhZyhuZXcgTWFwKSAhPSBtYXBUYWcpIHx8XG4gICAgKFByb21pc2UgJiYgZ2V0VGFnKFByb21pc2UucmVzb2x2ZSgpKSAhPSBwcm9taXNlVGFnKSB8fFxuICAgIChTZXQgJiYgZ2V0VGFnKG5ldyBTZXQpICE9IHNldFRhZykgfHxcbiAgICAoV2Vha01hcCAmJiBnZXRUYWcobmV3IFdlYWtNYXApICE9IHdlYWtNYXBUYWcpKSB7XG4gIGdldFRhZyA9IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgdmFyIHJlc3VsdCA9IGJhc2VHZXRUYWcodmFsdWUpLFxuICAgICAgICBDdG9yID0gcmVzdWx0ID09IG9iamVjdFRhZyA/IHZhbHVlLmNvbnN0cnVjdG9yIDogdW5kZWZpbmVkLFxuICAgICAgICBjdG9yU3RyaW5nID0gQ3RvciA/IHRvU291cmNlKEN0b3IpIDogJyc7XG5cbiAgICBpZiAoY3RvclN0cmluZykge1xuICAgICAgc3dpdGNoIChjdG9yU3RyaW5nKSB7XG4gICAgICAgIGNhc2UgZGF0YVZpZXdDdG9yU3RyaW5nOiByZXR1cm4gZGF0YVZpZXdUYWc7XG4gICAgICAgIGNhc2UgbWFwQ3RvclN0cmluZzogcmV0dXJuIG1hcFRhZztcbiAgICAgICAgY2FzZSBwcm9taXNlQ3RvclN0cmluZzogcmV0dXJuIHByb21pc2VUYWc7XG4gICAgICAgIGNhc2Ugc2V0Q3RvclN0cmluZzogcmV0dXJuIHNldFRhZztcbiAgICAgICAgY2FzZSB3ZWFrTWFwQ3RvclN0cmluZzogcmV0dXJuIHdlYWtNYXBUYWc7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYSB2YWxpZCBhcnJheS1saWtlIGluZGV4LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbbGVuZ3RoPU1BWF9TQUZFX0lOVEVHRVJdIFRoZSB1cHBlciBib3VuZHMgb2YgYSB2YWxpZCBpbmRleC5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgdmFsaWQgaW5kZXgsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaXNJbmRleCh2YWx1ZSwgbGVuZ3RoKSB7XG4gIGxlbmd0aCA9IGxlbmd0aCA9PSBudWxsID8gTUFYX1NBRkVfSU5URUdFUiA6IGxlbmd0aDtcbiAgcmV0dXJuICEhbGVuZ3RoICYmXG4gICAgKHR5cGVvZiB2YWx1ZSA9PSAnbnVtYmVyJyB8fCByZUlzVWludC50ZXN0KHZhbHVlKSkgJiZcbiAgICAodmFsdWUgPiAtMSAmJiB2YWx1ZSAlIDEgPT0gMCAmJiB2YWx1ZSA8IGxlbmd0aCk7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgc3VpdGFibGUgZm9yIHVzZSBhcyB1bmlxdWUgb2JqZWN0IGtleS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBzdWl0YWJsZSwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBpc0tleWFibGUodmFsdWUpIHtcbiAgdmFyIHR5cGUgPSB0eXBlb2YgdmFsdWU7XG4gIHJldHVybiAodHlwZSA9PSAnc3RyaW5nJyB8fCB0eXBlID09ICdudW1iZXInIHx8IHR5cGUgPT0gJ3N5bWJvbCcgfHwgdHlwZSA9PSAnYm9vbGVhbicpXG4gICAgPyAodmFsdWUgIT09ICdfX3Byb3RvX18nKVxuICAgIDogKHZhbHVlID09PSBudWxsKTtcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYGZ1bmNgIGhhcyBpdHMgc291cmNlIG1hc2tlZC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYGZ1bmNgIGlzIG1hc2tlZCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBpc01hc2tlZChmdW5jKSB7XG4gIHJldHVybiAhIW1hc2tTcmNLZXkgJiYgKG1hc2tTcmNLZXkgaW4gZnVuYyk7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgbGlrZWx5IGEgcHJvdG90eXBlIG9iamVjdC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHByb3RvdHlwZSwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBpc1Byb3RvdHlwZSh2YWx1ZSkge1xuICB2YXIgQ3RvciA9IHZhbHVlICYmIHZhbHVlLmNvbnN0cnVjdG9yLFxuICAgICAgcHJvdG8gPSAodHlwZW9mIEN0b3IgPT0gJ2Z1bmN0aW9uJyAmJiBDdG9yLnByb3RvdHlwZSkgfHwgb2JqZWN0UHJvdG87XG5cbiAgcmV0dXJuIHZhbHVlID09PSBwcm90bztcbn1cblxuLyoqXG4gKiBDb252ZXJ0cyBgdmFsdWVgIHRvIGEgc3RyaW5nIHVzaW5nIGBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY29udmVydC5cbiAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIGNvbnZlcnRlZCBzdHJpbmcuXG4gKi9cbmZ1bmN0aW9uIG9iamVjdFRvU3RyaW5nKHZhbHVlKSB7XG4gIHJldHVybiBuYXRpdmVPYmplY3RUb1N0cmluZy5jYWxsKHZhbHVlKTtcbn1cblxuLyoqXG4gKiBDb252ZXJ0cyBgZnVuY2AgdG8gaXRzIHNvdXJjZSBjb2RlLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBjb252ZXJ0LlxuICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgc291cmNlIGNvZGUuXG4gKi9cbmZ1bmN0aW9uIHRvU291cmNlKGZ1bmMpIHtcbiAgaWYgKGZ1bmMgIT0gbnVsbCkge1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4gZnVuY1RvU3RyaW5nLmNhbGwoZnVuYyk7XG4gICAgfSBjYXRjaCAoZSkge31cbiAgICB0cnkge1xuICAgICAgcmV0dXJuIChmdW5jICsgJycpO1xuICAgIH0gY2F0Y2ggKGUpIHt9XG4gIH1cbiAgcmV0dXJuICcnO1xufVxuXG4vKipcbiAqIFBlcmZvcm1zIGFcbiAqIFtgU2FtZVZhbHVlWmVyb2BdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLXNhbWV2YWx1ZXplcm8pXG4gKiBjb21wYXJpc29uIGJldHdlZW4gdHdvIHZhbHVlcyB0byBkZXRlcm1pbmUgaWYgdGhleSBhcmUgZXF1aXZhbGVudC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY29tcGFyZS5cbiAqIEBwYXJhbSB7Kn0gb3RoZXIgVGhlIG90aGVyIHZhbHVlIHRvIGNvbXBhcmUuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIHZhbHVlcyBhcmUgZXF1aXZhbGVudCwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiB2YXIgb2JqZWN0ID0geyAnYSc6IDEgfTtcbiAqIHZhciBvdGhlciA9IHsgJ2EnOiAxIH07XG4gKlxuICogXy5lcShvYmplY3QsIG9iamVjdCk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5lcShvYmplY3QsIG90aGVyKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5lcSgnYScsICdhJyk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5lcSgnYScsIE9iamVjdCgnYScpKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5lcShOYU4sIE5hTik7XG4gKiAvLyA9PiB0cnVlXG4gKi9cbmZ1bmN0aW9uIGVxKHZhbHVlLCBvdGhlcikge1xuICByZXR1cm4gdmFsdWUgPT09IG90aGVyIHx8ICh2YWx1ZSAhPT0gdmFsdWUgJiYgb3RoZXIgIT09IG90aGVyKTtcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBsaWtlbHkgYW4gYGFyZ3VtZW50c2Agb2JqZWN0LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGFuIGBhcmd1bWVudHNgIG9iamVjdCxcbiAqICBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNBcmd1bWVudHMoZnVuY3Rpb24oKSB7IHJldHVybiBhcmd1bWVudHM7IH0oKSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0FyZ3VtZW50cyhbMSwgMiwgM10pO1xuICogLy8gPT4gZmFsc2VcbiAqL1xudmFyIGlzQXJndW1lbnRzID0gYmFzZUlzQXJndW1lbnRzKGZ1bmN0aW9uKCkgeyByZXR1cm4gYXJndW1lbnRzOyB9KCkpID8gYmFzZUlzQXJndW1lbnRzIDogZnVuY3Rpb24odmFsdWUpIHtcbiAgcmV0dXJuIGlzT2JqZWN0TGlrZSh2YWx1ZSkgJiYgaGFzT3duUHJvcGVydHkuY2FsbCh2YWx1ZSwgJ2NhbGxlZScpICYmXG4gICAgIXByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwodmFsdWUsICdjYWxsZWUnKTtcbn07XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgY2xhc3NpZmllZCBhcyBhbiBgQXJyYXlgIG9iamVjdC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuMS4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhbiBhcnJheSwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzQXJyYXkoWzEsIDIsIDNdKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzQXJyYXkoZG9jdW1lbnQuYm9keS5jaGlsZHJlbik7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uaXNBcnJheSgnYWJjJyk7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uaXNBcnJheShfLm5vb3ApO1xuICogLy8gPT4gZmFsc2VcbiAqL1xudmFyIGlzQXJyYXkgPSBBcnJheS5pc0FycmF5O1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGFycmF5LWxpa2UuIEEgdmFsdWUgaXMgY29uc2lkZXJlZCBhcnJheS1saWtlIGlmIGl0J3NcbiAqIG5vdCBhIGZ1bmN0aW9uIGFuZCBoYXMgYSBgdmFsdWUubGVuZ3RoYCB0aGF0J3MgYW4gaW50ZWdlciBncmVhdGVyIHRoYW4gb3JcbiAqIGVxdWFsIHRvIGAwYCBhbmQgbGVzcyB0aGFuIG9yIGVxdWFsIHRvIGBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUmAuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYXJyYXktbGlrZSwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzQXJyYXlMaWtlKFsxLCAyLCAzXSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0FycmF5TGlrZShkb2N1bWVudC5ib2R5LmNoaWxkcmVuKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzQXJyYXlMaWtlKCdhYmMnKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzQXJyYXlMaWtlKF8ubm9vcCk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc0FycmF5TGlrZSh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgIT0gbnVsbCAmJiBpc0xlbmd0aCh2YWx1ZS5sZW5ndGgpICYmICFpc0Z1bmN0aW9uKHZhbHVlKTtcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhIGJ1ZmZlci5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMy4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIGJ1ZmZlciwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzQnVmZmVyKG5ldyBCdWZmZXIoMikpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNCdWZmZXIobmV3IFVpbnQ4QXJyYXkoMikpO1xuICogLy8gPT4gZmFsc2VcbiAqL1xudmFyIGlzQnVmZmVyID0gbmF0aXZlSXNCdWZmZXIgfHwgc3R1YkZhbHNlO1xuXG4vKipcbiAqIFBlcmZvcm1zIGEgZGVlcCBjb21wYXJpc29uIGJldHdlZW4gdHdvIHZhbHVlcyB0byBkZXRlcm1pbmUgaWYgdGhleSBhcmVcbiAqIGVxdWl2YWxlbnQuXG4gKlxuICogKipOb3RlOioqIFRoaXMgbWV0aG9kIHN1cHBvcnRzIGNvbXBhcmluZyBhcnJheXMsIGFycmF5IGJ1ZmZlcnMsIGJvb2xlYW5zLFxuICogZGF0ZSBvYmplY3RzLCBlcnJvciBvYmplY3RzLCBtYXBzLCBudW1iZXJzLCBgT2JqZWN0YCBvYmplY3RzLCByZWdleGVzLFxuICogc2V0cywgc3RyaW5ncywgc3ltYm9scywgYW5kIHR5cGVkIGFycmF5cy4gYE9iamVjdGAgb2JqZWN0cyBhcmUgY29tcGFyZWRcbiAqIGJ5IHRoZWlyIG93biwgbm90IGluaGVyaXRlZCwgZW51bWVyYWJsZSBwcm9wZXJ0aWVzLiBGdW5jdGlvbnMgYW5kIERPTVxuICogbm9kZXMgYXJlIGNvbXBhcmVkIGJ5IHN0cmljdCBlcXVhbGl0eSwgaS5lLiBgPT09YC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuMS4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY29tcGFyZS5cbiAqIEBwYXJhbSB7Kn0gb3RoZXIgVGhlIG90aGVyIHZhbHVlIHRvIGNvbXBhcmUuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIHZhbHVlcyBhcmUgZXF1aXZhbGVudCwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiB2YXIgb2JqZWN0ID0geyAnYSc6IDEgfTtcbiAqIHZhciBvdGhlciA9IHsgJ2EnOiAxIH07XG4gKlxuICogXy5pc0VxdWFsKG9iamVjdCwgb3RoZXIpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIG9iamVjdCA9PT0gb3RoZXI7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc0VxdWFsKHZhbHVlLCBvdGhlcikge1xuICByZXR1cm4gYmFzZUlzRXF1YWwodmFsdWUsIG90aGVyKTtcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBjbGFzc2lmaWVkIGFzIGEgYEZ1bmN0aW9uYCBvYmplY3QuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjEuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBmdW5jdGlvbiwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzRnVuY3Rpb24oXyk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0Z1bmN0aW9uKC9hYmMvKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzRnVuY3Rpb24odmFsdWUpIHtcbiAgaWYgKCFpc09iamVjdCh2YWx1ZSkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgLy8gVGhlIHVzZSBvZiBgT2JqZWN0I3RvU3RyaW5nYCBhdm9pZHMgaXNzdWVzIHdpdGggdGhlIGB0eXBlb2ZgIG9wZXJhdG9yXG4gIC8vIGluIFNhZmFyaSA5IHdoaWNoIHJldHVybnMgJ29iamVjdCcgZm9yIHR5cGVkIGFycmF5cyBhbmQgb3RoZXIgY29uc3RydWN0b3JzLlxuICB2YXIgdGFnID0gYmFzZUdldFRhZyh2YWx1ZSk7XG4gIHJldHVybiB0YWcgPT0gZnVuY1RhZyB8fCB0YWcgPT0gZ2VuVGFnIHx8IHRhZyA9PSBhc3luY1RhZyB8fCB0YWcgPT0gcHJveHlUYWc7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYSB2YWxpZCBhcnJheS1saWtlIGxlbmd0aC5cbiAqXG4gKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgaXMgbG9vc2VseSBiYXNlZCBvblxuICogW2BUb0xlbmd0aGBdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLXRvbGVuZ3RoKS5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHZhbGlkIGxlbmd0aCwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzTGVuZ3RoKDMpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNMZW5ndGgoTnVtYmVyLk1JTl9WQUxVRSk7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uaXNMZW5ndGgoSW5maW5pdHkpO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmlzTGVuZ3RoKCczJyk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc0xlbmd0aCh2YWx1ZSkge1xuICByZXR1cm4gdHlwZW9mIHZhbHVlID09ICdudW1iZXInICYmXG4gICAgdmFsdWUgPiAtMSAmJiB2YWx1ZSAlIDEgPT0gMCAmJiB2YWx1ZSA8PSBNQVhfU0FGRV9JTlRFR0VSO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIHRoZVxuICogW2xhbmd1YWdlIHR5cGVdKGh0dHA6Ly93d3cuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1lY21hc2NyaXB0LWxhbmd1YWdlLXR5cGVzKVxuICogb2YgYE9iamVjdGAuIChlLmcuIGFycmF5cywgZnVuY3Rpb25zLCBvYmplY3RzLCByZWdleGVzLCBgbmV3IE51bWJlcigwKWAsIGFuZCBgbmV3IFN0cmluZygnJylgKVxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGFuIG9iamVjdCwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzT2JqZWN0KHt9KTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzT2JqZWN0KFsxLCAyLCAzXSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc09iamVjdChfLm5vb3ApO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNPYmplY3QobnVsbCk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc09iamVjdCh2YWx1ZSkge1xuICB2YXIgdHlwZSA9IHR5cGVvZiB2YWx1ZTtcbiAgcmV0dXJuIHZhbHVlICE9IG51bGwgJiYgKHR5cGUgPT0gJ29iamVjdCcgfHwgdHlwZSA9PSAnZnVuY3Rpb24nKTtcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBvYmplY3QtbGlrZS4gQSB2YWx1ZSBpcyBvYmplY3QtbGlrZSBpZiBpdCdzIG5vdCBgbnVsbGBcbiAqIGFuZCBoYXMgYSBgdHlwZW9mYCByZXN1bHQgb2YgXCJvYmplY3RcIi5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBvYmplY3QtbGlrZSwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzT2JqZWN0TGlrZSh7fSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc09iamVjdExpa2UoWzEsIDIsIDNdKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzT2JqZWN0TGlrZShfLm5vb3ApO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmlzT2JqZWN0TGlrZShudWxsKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzT2JqZWN0TGlrZSh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgIT0gbnVsbCAmJiB0eXBlb2YgdmFsdWUgPT0gJ29iamVjdCc7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgY2xhc3NpZmllZCBhcyBhIHR5cGVkIGFycmF5LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMy4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgdHlwZWQgYXJyYXksIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc1R5cGVkQXJyYXkobmV3IFVpbnQ4QXJyYXkpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNUeXBlZEFycmF5KFtdKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbnZhciBpc1R5cGVkQXJyYXkgPSBub2RlSXNUeXBlZEFycmF5ID8gYmFzZVVuYXJ5KG5vZGVJc1R5cGVkQXJyYXkpIDogYmFzZUlzVHlwZWRBcnJheTtcblxuLyoqXG4gKiBDcmVhdGVzIGFuIGFycmF5IG9mIHRoZSBvd24gZW51bWVyYWJsZSBwcm9wZXJ0eSBuYW1lcyBvZiBgb2JqZWN0YC5cbiAqXG4gKiAqKk5vdGU6KiogTm9uLW9iamVjdCB2YWx1ZXMgYXJlIGNvZXJjZWQgdG8gb2JqZWN0cy4gU2VlIHRoZVxuICogW0VTIHNwZWNdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLW9iamVjdC5rZXlzKVxuICogZm9yIG1vcmUgZGV0YWlscy5cbiAqXG4gKiBAc3RhdGljXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBtZW1iZXJPZiBfXG4gKiBAY2F0ZWdvcnkgT2JqZWN0XG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHByb3BlcnR5IG5hbWVzLlxuICogQGV4YW1wbGVcbiAqXG4gKiBmdW5jdGlvbiBGb28oKSB7XG4gKiAgIHRoaXMuYSA9IDE7XG4gKiAgIHRoaXMuYiA9IDI7XG4gKiB9XG4gKlxuICogRm9vLnByb3RvdHlwZS5jID0gMztcbiAqXG4gKiBfLmtleXMobmV3IEZvbyk7XG4gKiAvLyA9PiBbJ2EnLCAnYiddIChpdGVyYXRpb24gb3JkZXIgaXMgbm90IGd1YXJhbnRlZWQpXG4gKlxuICogXy5rZXlzKCdoaScpO1xuICogLy8gPT4gWycwJywgJzEnXVxuICovXG5mdW5jdGlvbiBrZXlzKG9iamVjdCkge1xuICByZXR1cm4gaXNBcnJheUxpa2Uob2JqZWN0KSA/IGFycmF5TGlrZUtleXMob2JqZWN0KSA6IGJhc2VLZXlzKG9iamVjdCk7XG59XG5cbi8qKlxuICogVGhpcyBtZXRob2QgcmV0dXJucyBhIG5ldyBlbXB0eSBhcnJheS5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMTMuMFxuICogQGNhdGVnb3J5IFV0aWxcbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGVtcHR5IGFycmF5LlxuICogQGV4YW1wbGVcbiAqXG4gKiB2YXIgYXJyYXlzID0gXy50aW1lcygyLCBfLnN0dWJBcnJheSk7XG4gKlxuICogY29uc29sZS5sb2coYXJyYXlzKTtcbiAqIC8vID0+IFtbXSwgW11dXG4gKlxuICogY29uc29sZS5sb2coYXJyYXlzWzBdID09PSBhcnJheXNbMV0pO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gc3R1YkFycmF5KCkge1xuICByZXR1cm4gW107XG59XG5cbi8qKlxuICogVGhpcyBtZXRob2QgcmV0dXJucyBgZmFsc2VgLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4xMy4wXG4gKiBAY2F0ZWdvcnkgVXRpbFxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy50aW1lcygyLCBfLnN0dWJGYWxzZSk7XG4gKiAvLyA9PiBbZmFsc2UsIGZhbHNlXVxuICovXG5mdW5jdGlvbiBzdHViRmFsc2UoKSB7XG4gIHJldHVybiBmYWxzZTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpc0VxdWFsO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2xvZGFzaC5pc2VxdWFsL2luZGV4LmpzIiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihtb2R1bGUpIHtcclxuXHRpZighbW9kdWxlLndlYnBhY2tQb2x5ZmlsbCkge1xyXG5cdFx0bW9kdWxlLmRlcHJlY2F0ZSA9IGZ1bmN0aW9uKCkge307XHJcblx0XHRtb2R1bGUucGF0aHMgPSBbXTtcclxuXHRcdC8vIG1vZHVsZS5wYXJlbnQgPSB1bmRlZmluZWQgYnkgZGVmYXVsdFxyXG5cdFx0aWYoIW1vZHVsZS5jaGlsZHJlbikgbW9kdWxlLmNoaWxkcmVuID0gW107XHJcblx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkobW9kdWxlLCBcImxvYWRlZFwiLCB7XHJcblx0XHRcdGVudW1lcmFibGU6IHRydWUsXHJcblx0XHRcdGdldDogZnVuY3Rpb24oKSB7XHJcblx0XHRcdFx0cmV0dXJuIG1vZHVsZS5sO1xyXG5cdFx0XHR9XHJcblx0XHR9KTtcclxuXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShtb2R1bGUsIFwiaWRcIiwge1xyXG5cdFx0XHRlbnVtZXJhYmxlOiB0cnVlLFxyXG5cdFx0XHRnZXQ6IGZ1bmN0aW9uKCkge1xyXG5cdFx0XHRcdHJldHVybiBtb2R1bGUuaTtcclxuXHRcdFx0fVxyXG5cdFx0fSk7XHJcblx0XHRtb2R1bGUud2VicGFja1BvbHlmaWxsID0gMTtcclxuXHR9XHJcblx0cmV0dXJuIG1vZHVsZTtcclxufTtcclxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vICh3ZWJwYWNrKS9idWlsZGluL21vZHVsZS5qcyIsIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmV4ZWN1dGVUYXNrcyA9IGV4ZWN1dGVUYXNrcztcbmV4cG9ydHMuX2V4ZWN1dGVUYXNrcyA9IF9leGVjdXRlVGFza3M7XG5leHBvcnRzLmNoZWNrSXNSYW5nZXNTdXBwb3J0ZWQgPSBjaGVja0lzUmFuZ2VzU3VwcG9ydGVkO1xuXG52YXIgX2J1aWxkZXJVdGlsUnVudGltZTtcblxuZnVuY3Rpb24gX2xvYWRfYnVpbGRlclV0aWxSdW50aW1lKCkge1xuICAgIHJldHVybiBfYnVpbGRlclV0aWxSdW50aW1lID0gcmVxdWlyZShcImJ1aWxkZXItdXRpbC1ydW50aW1lXCIpO1xufVxuXG52YXIgX0RhdGFTcGxpdHRlcjtcblxuZnVuY3Rpb24gX2xvYWRfRGF0YVNwbGl0dGVyKCkge1xuICAgIHJldHVybiBfRGF0YVNwbGl0dGVyID0gcmVxdWlyZShcIi4vRGF0YVNwbGl0dGVyXCIpO1xufVxuXG52YXIgX2Rvd25sb2FkUGxhbkJ1aWxkZXI7XG5cbmZ1bmN0aW9uIF9sb2FkX2Rvd25sb2FkUGxhbkJ1aWxkZXIoKSB7XG4gICAgcmV0dXJuIF9kb3dubG9hZFBsYW5CdWlsZGVyID0gcmVxdWlyZShcIi4vZG93bmxvYWRQbGFuQnVpbGRlclwiKTtcbn1cblxuZnVuY3Rpb24gZXhlY3V0ZVRhc2tzKGRpZmZlcmVudGlhbERvd25sb2FkZXIsIHRhc2tzLCBvdXQsIG9sZEZpbGVGZCwgcmVqZWN0KSB7XG4gICAgY29uc3QgdyA9IHRhc2tPZmZzZXQgPT4ge1xuICAgICAgICBpZiAodGFza09mZnNldCA+PSB0YXNrcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGlmIChkaWZmZXJlbnRpYWxEb3dubG9hZGVyLmZpbGVNZXRhZGF0YUJ1ZmZlciAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgb3V0LndyaXRlKGRpZmZlcmVudGlhbERvd25sb2FkZXIuZmlsZU1ldGFkYXRhQnVmZmVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG91dC5lbmQoKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBuZXh0T2Zmc2V0ID0gdGFza09mZnNldCArIChkaWZmZXJlbnRpYWxEb3dubG9hZGVyLm9wdGlvbnMudXNlTXVsdGlwbGVSYW5nZVJlcXVlc3QgPT09IGZhbHNlID8gMSA6IDEwMDApO1xuICAgICAgICBfZXhlY3V0ZVRhc2tzKGRpZmZlcmVudGlhbERvd25sb2FkZXIsIHtcbiAgICAgICAgICAgIHRhc2tzLFxuICAgICAgICAgICAgc3RhcnQ6IHRhc2tPZmZzZXQsXG4gICAgICAgICAgICBlbmQ6IE1hdGgubWluKHRhc2tzLmxlbmd0aCwgbmV4dE9mZnNldCksXG4gICAgICAgICAgICBvbGRGaWxlRmRcbiAgICAgICAgfSwgb3V0LCAoKSA9PiB3KG5leHRPZmZzZXQpLCByZWplY3QpO1xuICAgIH07XG4gICAgcmV0dXJuIHc7XG59XG5mdW5jdGlvbiBfZXhlY3V0ZVRhc2tzKGRpZmZlcmVudGlhbERvd25sb2FkZXIsIG9wdGlvbnMsIG91dCwgcmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgbGV0IHJhbmdlcyA9IFwiYnl0ZXM9XCI7XG4gICAgbGV0IHBhcnRDb3VudCA9IDA7XG4gICAgY29uc3QgcGFydEluZGV4VG9UYXNrSW5kZXggPSBuZXcgTWFwKCk7XG4gICAgY29uc3QgcGFydEluZGV4VG9MZW5ndGggPSBbXTtcbiAgICBmb3IgKGxldCBpID0gb3B0aW9ucy5zdGFydDsgaSA8IG9wdGlvbnMuZW5kOyBpKyspIHtcbiAgICAgICAgY29uc3QgdGFzayA9IG9wdGlvbnMudGFza3NbaV07XG4gICAgICAgIGlmICh0YXNrLmtpbmQgPT09IChfZG93bmxvYWRQbGFuQnVpbGRlciB8fCBfbG9hZF9kb3dubG9hZFBsYW5CdWlsZGVyKCkpLk9wZXJhdGlvbktpbmQuRE9XTkxPQUQpIHtcbiAgICAgICAgICAgIHJhbmdlcyArPSBgJHt0YXNrLnN0YXJ0fS0ke3Rhc2suZW5kIC0gMX0sIGA7XG4gICAgICAgICAgICBwYXJ0SW5kZXhUb1Rhc2tJbmRleC5zZXQocGFydENvdW50LCBpKTtcbiAgICAgICAgICAgIHBhcnRDb3VudCsrO1xuICAgICAgICAgICAgcGFydEluZGV4VG9MZW5ndGgucHVzaCh0YXNrLmVuZCAtIHRhc2suc3RhcnQpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChwYXJ0Q291bnQgPD0gMSkge1xuICAgICAgICAvLyB0aGUgb25seSByZW1vdGUgcmFuZ2UgLSBjb3B5XG4gICAgICAgIGNvbnN0IHcgPSBpbmRleCA9PiB7XG4gICAgICAgICAgICBpZiAoaW5kZXggPj0gb3B0aW9ucy5lbmQpIHtcbiAgICAgICAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgdGFzayA9IG9wdGlvbnMudGFza3NbaW5kZXgrK107XG4gICAgICAgICAgICBpZiAodGFzay5raW5kID09PSAoX2Rvd25sb2FkUGxhbkJ1aWxkZXIgfHwgX2xvYWRfZG93bmxvYWRQbGFuQnVpbGRlcigpKS5PcGVyYXRpb25LaW5kLkNPUFkpIHtcbiAgICAgICAgICAgICAgICAoMCwgKF9EYXRhU3BsaXR0ZXIgfHwgX2xvYWRfRGF0YVNwbGl0dGVyKCkpLmNvcHlEYXRhKSh0YXNrLCBvdXQsIG9wdGlvbnMub2xkRmlsZUZkLCByZWplY3QsICgpID0+IHcoaW5kZXgpKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVxdWVzdE9wdGlvbnMgPSBkaWZmZXJlbnRpYWxEb3dubG9hZGVyLmNyZWF0ZVJlcXVlc3RPcHRpb25zKFwiZ2V0XCIpO1xuICAgICAgICAgICAgICAgIHJlcXVlc3RPcHRpb25zLmhlYWRlcnMuUmFuZ2UgPSBgYnl0ZXM9JHt0YXNrLnN0YXJ0fS0ke3Rhc2suZW5kIC0gMX1gO1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlcXVlc3QgPSBkaWZmZXJlbnRpYWxEb3dubG9hZGVyLmh0dHBFeGVjdXRvci5kb1JlcXVlc3QocmVxdWVzdE9wdGlvbnMsIHJlc3BvbnNlID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFjaGVja0lzUmFuZ2VzU3VwcG9ydGVkKHJlc3BvbnNlLCByZWplY3QpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2UucGlwZShvdXQsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVuZDogZmFsc2VcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlLm9uY2UoXCJlbmRcIiwgKCkgPT4gdyhpbmRleCkpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGRpZmZlcmVudGlhbERvd25sb2FkZXIuaHR0cEV4ZWN1dG9yLmFkZEVycm9yQW5kVGltZW91dEhhbmRsZXJzKHJlcXVlc3QsIHJlamVjdCk7XG4gICAgICAgICAgICAgICAgcmVxdWVzdC5lbmQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgdyhvcHRpb25zLnN0YXJ0KTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCByZXF1ZXN0T3B0aW9ucyA9IGRpZmZlcmVudGlhbERvd25sb2FkZXIuY3JlYXRlUmVxdWVzdE9wdGlvbnMoXCJnZXRcIik7XG4gICAgcmVxdWVzdE9wdGlvbnMuaGVhZGVycy5SYW5nZSA9IHJhbmdlcy5zdWJzdHJpbmcoMCwgcmFuZ2VzLmxlbmd0aCAtIDIpO1xuICAgIGNvbnN0IHJlcXVlc3QgPSBkaWZmZXJlbnRpYWxEb3dubG9hZGVyLmh0dHBFeGVjdXRvci5kb1JlcXVlc3QocmVxdWVzdE9wdGlvbnMsIHJlc3BvbnNlID0+IHtcbiAgICAgICAgaWYgKCFjaGVja0lzUmFuZ2VzU3VwcG9ydGVkKHJlc3BvbnNlLCByZWplY3QpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgY29udGVudFR5cGUgPSAoMCwgKF9idWlsZGVyVXRpbFJ1bnRpbWUgfHwgX2xvYWRfYnVpbGRlclV0aWxSdW50aW1lKCkpLnNhZmVHZXRIZWFkZXIpKHJlc3BvbnNlLCBcImNvbnRlbnQtdHlwZVwiKTtcbiAgICAgICAgY29uc3QgbSA9IC9ebXVsdGlwYXJ0XFwvLis/KD86OyBib3VuZGFyeT0oPzooPzpcIiguKylcIil8KD86KFteXFxzXSspKSkpJC9pLmV4ZWMoY29udGVudFR5cGUpO1xuICAgICAgICBpZiAobSA9PSBudWxsKSB7XG4gICAgICAgICAgICByZWplY3QobmV3IEVycm9yKGBDb250ZW50LVR5cGUgXCJtdWx0aXBhcnQvYnl0ZXJhbmdlc1wiIGlzIGV4cGVjdGVkLCBidXQgZ290IFwiJHtjb250ZW50VHlwZX1cImApKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBkaWNlciA9IG5ldyAoX0RhdGFTcGxpdHRlciB8fCBfbG9hZF9EYXRhU3BsaXR0ZXIoKSkuRGF0YVNwbGl0dGVyKG91dCwgb3B0aW9ucywgcGFydEluZGV4VG9UYXNrSW5kZXgsIG1bMV0gfHwgbVsyXSwgcGFydEluZGV4VG9MZW5ndGgsIHJlc29sdmUpO1xuICAgICAgICBkaWNlci5vbihcImVycm9yXCIsIHJlamVjdCk7XG4gICAgICAgIHJlc3BvbnNlLnBpcGUoZGljZXIpO1xuICAgIH0pO1xuICAgIGRpZmZlcmVudGlhbERvd25sb2FkZXIuaHR0cEV4ZWN1dG9yLmFkZEVycm9yQW5kVGltZW91dEhhbmRsZXJzKHJlcXVlc3QsIHJlamVjdCk7XG4gICAgcmVxdWVzdC5lbmQoKTtcbn1cbmZ1bmN0aW9uIGNoZWNrSXNSYW5nZXNTdXBwb3J0ZWQocmVzcG9uc2UsIHJlamVjdCkge1xuICAgIC8vIEVsZWN0cm9uIG5ldCBoYW5kbGVzIHJlZGlyZWN0cyBhdXRvbWF0aWNhbGx5LCBvdXIgTm9kZUpTIHRlc3Qgc2VydmVyIGRvZXNuJ3QgdXNlIHJlZGlyZWN0cyAtIHNvLCB3ZSBkb24ndCBjaGVjayAzeHggY29kZXMuXG4gICAgaWYgKHJlc3BvbnNlLnN0YXR1c0NvZGUgPj0gNDAwKSB7XG4gICAgICAgIHJlamVjdCgoMCwgKF9idWlsZGVyVXRpbFJ1bnRpbWUgfHwgX2xvYWRfYnVpbGRlclV0aWxSdW50aW1lKCkpLmNyZWF0ZUh0dHBFcnJvcikocmVzcG9uc2UpKTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpZiAocmVzcG9uc2Uuc3RhdHVzQ29kZSAhPT0gMjA2KSB7XG4gICAgICAgIGNvbnN0IGFjY2VwdFJhbmdlcyA9ICgwLCAoX2J1aWxkZXJVdGlsUnVudGltZSB8fCBfbG9hZF9idWlsZGVyVXRpbFJ1bnRpbWUoKSkuc2FmZUdldEhlYWRlcikocmVzcG9uc2UsIFwiYWNjZXB0LXJhbmdlc1wiKTtcbiAgICAgICAgaWYgKGFjY2VwdFJhbmdlcyA9PSBudWxsIHx8IGFjY2VwdFJhbmdlcyA9PT0gXCJub25lXCIpIHtcbiAgICAgICAgICAgIHJlamVjdChuZXcgRXJyb3IoXCJTZXJ2ZXIgZG9lc24ndCBzdXBwb3J0IEFjY2VwdC1SYW5nZXNcIikpO1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bXVsdGlwbGVSYW5nZURvd25sb2FkZXIuanMubWFwXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2VsZWN0cm9uLXVwZGF0ZXIvb3V0L2RpZmZlcmVudGlhbERvd25sb2FkZXIvbXVsdGlwbGVSYW5nZURvd25sb2FkZXIuanMiLCJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5HZW5lcmljRGlmZmVyZW50aWFsRG93bmxvYWRlciA9IHVuZGVmaW5lZDtcblxudmFyIF9ibHVlYmlyZExzdDtcblxuZnVuY3Rpb24gX2xvYWRfYmx1ZWJpcmRMc3QoKSB7XG4gICAgcmV0dXJuIF9ibHVlYmlyZExzdCA9IHJlcXVpcmUoXCJibHVlYmlyZC1sc3RcIik7XG59XG5cbnZhciBfYmxvY2tNYXBBcGk7XG5cbmZ1bmN0aW9uIF9sb2FkX2Jsb2NrTWFwQXBpKCkge1xuICAgIHJldHVybiBfYmxvY2tNYXBBcGkgPSByZXF1aXJlKFwiYnVpbGRlci11dGlsLXJ1bnRpbWUvb3V0L2Jsb2NrTWFwQXBpXCIpO1xufVxuXG52YXIgX2ZzRXh0cmFQO1xuXG5mdW5jdGlvbiBfbG9hZF9mc0V4dHJhUCgpIHtcbiAgICByZXR1cm4gX2ZzRXh0cmFQID0gcmVxdWlyZShcImZzLWV4dHJhLXBcIik7XG59XG5cbnZhciBfcGF0aCA9IF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKHJlcXVpcmUoXCJwYXRoXCIpKTtcblxudmFyIF9EaWZmZXJlbnRpYWxEb3dubG9hZGVyO1xuXG5mdW5jdGlvbiBfbG9hZF9EaWZmZXJlbnRpYWxEb3dubG9hZGVyKCkge1xuICAgIHJldHVybiBfRGlmZmVyZW50aWFsRG93bmxvYWRlciA9IHJlcXVpcmUoXCIuL0RpZmZlcmVudGlhbERvd25sb2FkZXJcIik7XG59XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKG9iaikgeyBpZiAob2JqICYmIG9iai5fX2VzTW9kdWxlKSB7IHJldHVybiBvYmo7IH0gZWxzZSB7IHZhciBuZXdPYmogPSB7fTsgaWYgKG9iaiAhPSBudWxsKSB7IGZvciAodmFyIGtleSBpbiBvYmopIHsgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGtleSkpIG5ld09ialtrZXldID0gb2JqW2tleV07IH0gfSBuZXdPYmouZGVmYXVsdCA9IG9iajsgcmV0dXJuIG5ld09iajsgfSB9XG5cbmNsYXNzIEdlbmVyaWNEaWZmZXJlbnRpYWxEb3dubG9hZGVyIGV4dGVuZHMgKF9EaWZmZXJlbnRpYWxEb3dubG9hZGVyIHx8IF9sb2FkX0RpZmZlcmVudGlhbERvd25sb2FkZXIoKSkuRGlmZmVyZW50aWFsRG93bmxvYWRlciB7XG4gICAgZG93bmxvYWQobmV3QmxvY2tNYXApIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgICAgICByZXR1cm4gKDAsIChfYmx1ZWJpcmRMc3QgfHwgX2xvYWRfYmx1ZWJpcmRMc3QoKSkuY29yb3V0aW5lKShmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgeWllbGQgX3RoaXMuZG9Eb3dubG9hZCgoeWllbGQgKDAsIChfZnNFeHRyYVAgfHwgX2xvYWRfZnNFeHRyYVAoKSkucmVhZEpzb24pKF9wYXRoLmpvaW4ocHJvY2Vzcy5yZXNvdXJjZXNQYXRoLCBcIi4uXCIsIChfYmxvY2tNYXBBcGkgfHwgX2xvYWRfYmxvY2tNYXBBcGkoKSkuQkxPQ0tfTUFQX0ZJTEVfTkFNRSkpKSwgbmV3QmxvY2tNYXApO1xuICAgICAgICB9KSgpO1xuICAgIH1cbn1cbmV4cG9ydHMuR2VuZXJpY0RpZmZlcmVudGlhbERvd25sb2FkZXIgPSBHZW5lcmljRGlmZmVyZW50aWFsRG93bmxvYWRlcjsgLy8jIHNvdXJjZU1hcHBpbmdVUkw9R2VuZXJpY0RpZmZlcmVudGlhbERvd25sb2FkZXIuanMubWFwXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2VsZWN0cm9uLXVwZGF0ZXIvb3V0L2RpZmZlcmVudGlhbERvd25sb2FkZXIvR2VuZXJpY0RpZmZlcmVudGlhbERvd25sb2FkZXIuanMiLCJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy52ZXJpZnlTaWduYXR1cmUgPSB2ZXJpZnlTaWduYXR1cmU7XG5cbnZhciBfYmx1ZWJpcmRMc3Q7XG5cbmZ1bmN0aW9uIF9sb2FkX2JsdWViaXJkTHN0KCkge1xuICAgIHJldHVybiBfYmx1ZWJpcmRMc3QgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJibHVlYmlyZC1sc3RcIikpO1xufVxuXG52YXIgX2J1aWxkZXJVdGlsUnVudGltZTtcblxuZnVuY3Rpb24gX2xvYWRfYnVpbGRlclV0aWxSdW50aW1lKCkge1xuICAgIHJldHVybiBfYnVpbGRlclV0aWxSdW50aW1lID0gcmVxdWlyZShcImJ1aWxkZXItdXRpbC1ydW50aW1lXCIpO1xufVxuXG52YXIgX2NoaWxkX3Byb2Nlc3M7XG5cbmZ1bmN0aW9uIF9sb2FkX2NoaWxkX3Byb2Nlc3MoKSB7XG4gICAgcmV0dXJuIF9jaGlsZF9wcm9jZXNzID0gcmVxdWlyZShcImNoaWxkX3Byb2Nlc3NcIik7XG59XG5cbnZhciBfb3M7XG5cbmZ1bmN0aW9uIF9sb2FkX29zKCkge1xuICAgIHJldHVybiBfb3MgPSBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChyZXF1aXJlKFwib3NcIikpO1xufVxuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChvYmopIHsgaWYgKG9iaiAmJiBvYmouX19lc01vZHVsZSkgeyByZXR1cm4gb2JqOyB9IGVsc2UgeyB2YXIgbmV3T2JqID0ge307IGlmIChvYmogIT0gbnVsbCkgeyBmb3IgKHZhciBrZXkgaW4gb2JqKSB7IGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBrZXkpKSBuZXdPYmpba2V5XSA9IG9ialtrZXldOyB9IH0gbmV3T2JqLmRlZmF1bHQgPSBvYmo7IHJldHVybiBuZXdPYmo7IH0gfVxuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG4vLyAkY2VydGlmaWNhdGVJbmZvID0gKEdldC1BdXRoZW50aWNvZGVTaWduYXR1cmUgJ3h4eFxceXl5LmV4ZSdcbi8vIHwgd2hlcmUgeyRfLlN0YXR1cy5FcXVhbHMoW1N5c3RlbS5NYW5hZ2VtZW50LkF1dG9tYXRpb24uU2lnbmF0dXJlU3RhdHVzXTo6VmFsaWQpIC1hbmQgJF8uU2lnbmVyQ2VydGlmaWNhdGUuU3ViamVjdC5Db250YWlucyhcIkNOPXNpZW1lbnMuY29tXCIpfSlcbi8vIHwgT3V0LVN0cmluZyA7IGlmICgkY2VydGlmaWNhdGVJbmZvKSB7IGV4aXQgMCB9IGVsc2UgeyBleGl0IDEgfVxuZnVuY3Rpb24gdmVyaWZ5U2lnbmF0dXJlKHB1Ymxpc2hlck5hbWVzLCB0ZW1wVXBkYXRlRmlsZSwgbG9nZ2VyKSB7XG4gICAgcmV0dXJuIG5ldyAoX2JsdWViaXJkTHN0IHx8IF9sb2FkX2JsdWViaXJkTHN0KCkpLmRlZmF1bHQoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vZWxlY3Ryb24tdXNlcmxhbmQvZWxlY3Ryb24tYnVpbGRlci9pc3N1ZXMvMjQyMVxuICAgICAgICAoMCwgKF9jaGlsZF9wcm9jZXNzIHx8IF9sb2FkX2NoaWxkX3Byb2Nlc3MoKSkuZXhlY0ZpbGUpKFwicG93ZXJzaGVsbC5leGVcIiwgW2BHZXQtQXV0aGVudGljb2RlU2lnbmF0dXJlICcke3RlbXBVcGRhdGVGaWxlfScgfCBDb252ZXJ0VG8tSnNvbiAtQ29tcHJlc3NgXSwge1xuICAgICAgICAgICAgdGltZW91dDogMzAgKiAxMDAwXG4gICAgICAgIH0sIChlcnJvciwgc3Rkb3V0LCBzdGRlcnIpID0+IHtcbiAgICAgICAgICAgIGlmIChlcnJvciAhPSBudWxsIHx8IHN0ZGVycikge1xuICAgICAgICAgICAgICAgIGlmIChpc09sZFdpbjYoKSkge1xuICAgICAgICAgICAgICAgICAgICBsb2dnZXIud2FybihgQ2Fubm90IGV4ZWN1dGUgR2V0LUF1dGhlbnRpY29kZVNpZ25hdHVyZTogJHtlcnJvciB8fCBzdGRlcnJ9LiBJZ25vcmluZyBzaWduYXR1cmUgdmFsaWRhdGlvbiBkdWUgdG8gdW5zdXBwb3J0ZWQgcG93ZXJzaGVsbCB2ZXJzaW9uLiBQbGVhc2UgdXBncmFkZSB0byBwb3dlcnNoZWxsIDMgb3IgaGlnaGVyLmApO1xuICAgICAgICAgICAgICAgICAgICByZXNvbHZlKG51bGwpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICgwLCAoX2NoaWxkX3Byb2Nlc3MgfHwgX2xvYWRfY2hpbGRfcHJvY2VzcygpKS5leGVjRmlsZVN5bmMpKFwicG93ZXJzaGVsbC5leGVcIiwgW1wiQ29udmVydFRvLUpzb24gdGVzdFwiXSwgeyB0aW1lb3V0OiAxMCAqIDEwMDAgfSk7XG4gICAgICAgICAgICAgICAgfSBjYXRjaCAodGVzdEVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIGxvZ2dlci53YXJuKGBDYW5ub3QgZXhlY3V0ZSBDb252ZXJ0VG8tSnNvbjogJHt0ZXN0RXJyb3IubWVzc2FnZX0uIElnbm9yaW5nIHNpZ25hdHVyZSB2YWxpZGF0aW9uIGR1ZSB0byB1bnN1cHBvcnRlZCBwb3dlcnNoZWxsIHZlcnNpb24uIFBsZWFzZSB1cGdyYWRlIHRvIHBvd2Vyc2hlbGwgMyBvciBoaWdoZXIuYCk7XG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmUobnVsbCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGVycm9yICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVqZWN0KGVycm9yKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoc3RkZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlamVjdChuZXcgRXJyb3IoYENhbm5vdCBleGVjdXRlIEdldC1BdXRoZW50aWNvZGVTaWduYXR1cmU6ICR7c3RkZXJyfWApKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGRhdGEgPSBKU09OLnBhcnNlKHN0ZG91dCk7XG4gICAgICAgICAgICBkZWxldGUgZGF0YS5Qcml2YXRlS2V5O1xuICAgICAgICAgICAgZGVsZXRlIGRhdGEuSXNPU0JpbmFyeTtcbiAgICAgICAgICAgIGRlbGV0ZSBkYXRhLlNpZ25hdHVyZVR5cGU7XG4gICAgICAgICAgICBjb25zdCBzaWduZXJDZXJ0aWZpY2F0ZSA9IGRhdGEuU2lnbmVyQ2VydGlmaWNhdGU7XG4gICAgICAgICAgICBpZiAoc2lnbmVyQ2VydGlmaWNhdGUgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGRlbGV0ZSBzaWduZXJDZXJ0aWZpY2F0ZS5BcmNoaXZlZDtcbiAgICAgICAgICAgICAgICBkZWxldGUgc2lnbmVyQ2VydGlmaWNhdGUuRXh0ZW5zaW9ucztcbiAgICAgICAgICAgICAgICBkZWxldGUgc2lnbmVyQ2VydGlmaWNhdGUuSGFuZGxlO1xuICAgICAgICAgICAgICAgIGRlbGV0ZSBzaWduZXJDZXJ0aWZpY2F0ZS5IYXNQcml2YXRlS2V5O1xuICAgICAgICAgICAgICAgIC8vIGR1cGxpY2F0ZXMgZGF0YS5TaWduZXJDZXJ0aWZpY2F0ZSAoY29udGFpbnMgUmF3RGF0YSlcbiAgICAgICAgICAgICAgICBkZWxldGUgc2lnbmVyQ2VydGlmaWNhdGUuU3ViamVjdE5hbWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkZWxldGUgZGF0YS5QYXRoO1xuICAgICAgICAgICAgaWYgKGRhdGEuU3RhdHVzID09PSAwKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgbmFtZSA9ICgwLCAoX2J1aWxkZXJVdGlsUnVudGltZSB8fCBfbG9hZF9idWlsZGVyVXRpbFJ1bnRpbWUoKSkucGFyc2VEbikoZGF0YS5TaWduZXJDZXJ0aWZpY2F0ZS5TdWJqZWN0KS5nZXQoXCJDTlwiKTtcbiAgICAgICAgICAgICAgICBpZiAocHVibGlzaGVyTmFtZXMuaW5jbHVkZXMobmFtZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShudWxsKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGBwdWJsaXNoZXJOYW1lczogJHtwdWJsaXNoZXJOYW1lcy5qb2luKFwiIHwgXCIpfSwgcmF3IGluZm86IGAgKyBKU09OLnN0cmluZ2lmeShkYXRhLCAobmFtZSwgdmFsdWUpID0+IG5hbWUgPT09IFwiUmF3RGF0YVwiID8gdW5kZWZpbmVkIDogdmFsdWUsIDIpO1xuICAgICAgICAgICAgbG9nZ2VyLmluZm8oYFNpZ24gdmVyaWZpY2F0aW9uIGZhaWxlZCwgaW5zdGFsbGVyIHNpZ25lZCB3aXRoIGluY29ycmVjdCBjZXJ0aWZpY2F0ZTogJHtyZXN1bHR9YCk7XG4gICAgICAgICAgICByZXNvbHZlKHJlc3VsdCk7XG4gICAgICAgIH0pO1xuICAgIH0pO1xufVxuZnVuY3Rpb24gaXNPbGRXaW42KCkge1xuICAgIGNvbnN0IHdpblZlcnNpb24gPSAoX29zIHx8IF9sb2FkX29zKCkpLnJlbGVhc2UoKTtcbiAgICByZXR1cm4gd2luVmVyc2lvbi5zdGFydHNXaXRoKFwiNi5cIikgJiYgIXdpblZlcnNpb24uc3RhcnRzV2l0aChcIjYuM1wiKTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXdpbmRvd3NFeGVjdXRhYmxlQ29kZVNpZ25hdHVyZVZlcmlmaWVyLmpzLm1hcFxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9lbGVjdHJvbi11cGRhdGVyL291dC93aW5kb3dzRXhlY3V0YWJsZUNvZGVTaWduYXR1cmVWZXJpZmllci5qcyIsIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLk1hY1VwZGF0ZXIgPSB1bmRlZmluZWQ7XG5cbnZhciBfYmx1ZWJpcmRMc3Q7XG5cbmZ1bmN0aW9uIF9sb2FkX2JsdWViaXJkTHN0KCkge1xuICAgIHJldHVybiBfYmx1ZWJpcmRMc3QgPSByZXF1aXJlKFwiYmx1ZWJpcmQtbHN0XCIpO1xufVxuXG52YXIgX2JsdWViaXJkTHN0MjtcblxuZnVuY3Rpb24gX2xvYWRfYmx1ZWJpcmRMc3QyKCkge1xuICAgIHJldHVybiBfYmx1ZWJpcmRMc3QyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiYmx1ZWJpcmQtbHN0XCIpKTtcbn1cblxudmFyIF9idWlsZGVyVXRpbFJ1bnRpbWU7XG5cbmZ1bmN0aW9uIF9sb2FkX2J1aWxkZXJVdGlsUnVudGltZSgpIHtcbiAgICByZXR1cm4gX2J1aWxkZXJVdGlsUnVudGltZSA9IHJlcXVpcmUoXCJidWlsZGVyLXV0aWwtcnVudGltZVwiKTtcbn1cblxudmFyIF9odHRwO1xuXG5mdW5jdGlvbiBfbG9hZF9odHRwKCkge1xuICAgIHJldHVybiBfaHR0cCA9IHJlcXVpcmUoXCJodHRwXCIpO1xufVxuXG52YXIgX0FwcFVwZGF0ZXI7XG5cbmZ1bmN0aW9uIF9sb2FkX0FwcFVwZGF0ZXIoKSB7XG4gICAgcmV0dXJuIF9BcHBVcGRhdGVyID0gcmVxdWlyZShcIi4vQXBwVXBkYXRlclwiKTtcbn1cblxudmFyIF9tYWluO1xuXG5mdW5jdGlvbiBfbG9hZF9tYWluKCkge1xuICAgIHJldHVybiBfbWFpbiA9IHJlcXVpcmUoXCIuL21haW5cIik7XG59XG5cbnZhciBfUHJvdmlkZXI7XG5cbmZ1bmN0aW9uIF9sb2FkX1Byb3ZpZGVyKCkge1xuICAgIHJldHVybiBfUHJvdmlkZXIgPSByZXF1aXJlKFwiLi9Qcm92aWRlclwiKTtcbn1cblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuY2xhc3MgTWFjVXBkYXRlciBleHRlbmRzIChfQXBwVXBkYXRlciB8fCBfbG9hZF9BcHBVcGRhdGVyKCkpLkFwcFVwZGF0ZXIge1xuICAgIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcbiAgICAgICAgc3VwZXIob3B0aW9ucyk7XG4gICAgICAgIHRoaXMubmF0aXZlVXBkYXRlciA9IHJlcXVpcmUoXCJlbGVjdHJvblwiKS5hdXRvVXBkYXRlcjtcbiAgICAgICAgdGhpcy5uYXRpdmVVcGRhdGVyLm9uKFwiZXJyb3JcIiwgaXQgPT4ge1xuICAgICAgICAgICAgdGhpcy5fbG9nZ2VyLndhcm4oaXQpO1xuICAgICAgICAgICAgdGhpcy5lbWl0KFwiZXJyb3JcIiwgaXQpO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5uYXRpdmVVcGRhdGVyLm9uKFwidXBkYXRlLWRvd25sb2FkZWRcIiwgKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5fbG9nZ2VyLmluZm8oYE5ldyB2ZXJzaW9uICR7dGhpcy51cGRhdGVJbmZvLnZlcnNpb259IGhhcyBiZWVuIGRvd25sb2FkZWRgKTtcbiAgICAgICAgICAgIHRoaXMuZW1pdCgoX21haW4gfHwgX2xvYWRfbWFpbigpKS5VUERBVEVfRE9XTkxPQURFRCwgdGhpcy51cGRhdGVJbmZvKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGRvRG93bmxvYWRVcGRhdGUodXBkYXRlSW5mbywgY2FuY2VsbGF0aW9uVG9rZW4pIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgICAgICByZXR1cm4gKDAsIChfYmx1ZWJpcmRMc3QgfHwgX2xvYWRfYmx1ZWJpcmRMc3QoKSkuY29yb3V0aW5lKShmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3QgZmlsZXMgPSAoeWllbGQgX3RoaXMucHJvdmlkZXIpLnJlc29sdmVGaWxlcyh1cGRhdGVJbmZvKTtcbiAgICAgICAgICAgIGNvbnN0IHppcEZpbGVJbmZvID0gKDAsIChfUHJvdmlkZXIgfHwgX2xvYWRfUHJvdmlkZXIoKSkuZmluZEZpbGUpKGZpbGVzLCBcInppcFwiLCBbXCJwa2dcIiwgXCJkbWdcIl0pO1xuICAgICAgICAgICAgaWYgKHppcEZpbGVJbmZvID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyAoMCwgKF9idWlsZGVyVXRpbFJ1bnRpbWUgfHwgX2xvYWRfYnVpbGRlclV0aWxSdW50aW1lKCkpLm5ld0Vycm9yKShgWklQIGZpbGUgbm90IHByb3ZpZGVkOiAkeygwLCAoX2J1aWxkZXJVdGlsUnVudGltZSB8fCBfbG9hZF9idWlsZGVyVXRpbFJ1bnRpbWUoKSkuc2FmZVN0cmluZ2lmeUpzb24pKGZpbGVzKX1gLCBcIkVSUl9VUERBVEVSX1pJUF9GSUxFX05PVF9GT1VORFwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHNlcnZlciA9ICgwLCAoX2h0dHAgfHwgX2xvYWRfaHR0cCgpKS5jcmVhdGVTZXJ2ZXIpKCk7XG4gICAgICAgICAgICBzZXJ2ZXIub24oXCJjbG9zZVwiLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMuX2xvZ2dlci5pbmZvKGBQcm94eSBzZXJ2ZXIgZm9yIG5hdGl2ZSBTcXVpcnJlbC5NYWMgaXMgY2xvc2VkICh3YXMgc3RhcnRlZCB0byBkb3dubG9hZCAke3ppcEZpbGVJbmZvLnVybC5ocmVmfSlgKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgZnVuY3Rpb24gZ2V0U2VydmVyVXJsKCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGFkZHJlc3MgPSBzZXJ2ZXIuYWRkcmVzcygpO1xuICAgICAgICAgICAgICAgIHJldHVybiBgaHR0cDovLyR7YWRkcmVzcy5hZGRyZXNzfToke2FkZHJlc3MucG9ydH1gO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcmVxdWVzdEhlYWRlcnMgPSB5aWVsZCBfdGhpcy5jb21wdXRlUmVxdWVzdEhlYWRlcnMoKTtcbiAgICAgICAgICAgIHJldHVybiB5aWVsZCBuZXcgKF9ibHVlYmlyZExzdDIgfHwgX2xvYWRfYmx1ZWJpcmRMc3QyKCkpLmRlZmF1bHQoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICAgICAgICAgIHNlcnZlci5vbihcInJlcXVlc3RcIiwgZnVuY3Rpb24gKHJlcXVlc3QsIHJlc3BvbnNlKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlcXVlc3RVcmwgPSByZXF1ZXN0LnVybDtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuX2xvZ2dlci5pbmZvKGAke3JlcXVlc3RVcmx9IHJlcXVlc3RlZGApO1xuICAgICAgICAgICAgICAgICAgICBpZiAocmVxdWVzdFVybCA9PT0gXCIvXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGRhdGEgPSBCdWZmZXIuZnJvbShgeyBcInVybFwiOiBcIiR7Z2V0U2VydmVyVXJsKCl9L2FwcC56aXBcIiB9YCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXNwb25zZS53cml0ZUhlYWQoMjAwLCB7IFwiQ29udGVudC1UeXBlXCI6IFwiYXBwbGljYXRpb24vanNvblwiLCBcIkNvbnRlbnQtTGVuZ3RoXCI6IGRhdGEubGVuZ3RoIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2UuZW5kKGRhdGEpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHJlcXVlc3RVcmwuc3RhcnRzV2l0aChcIi9hcHAuemlwXCIpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgZXJyb3JPY2N1cnJlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2Uub24oXCJmaW5pc2hcIiwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNldEltbWVkaWF0ZShmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2VydmVyLmNsb3NlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghZXJyb3JPY2N1cnJlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMubmF0aXZlVXBkYXRlci5yZW1vdmVMaXN0ZW5lcihcImVycm9yXCIsIHJlamVjdCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlKFtdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuZG9Qcm94eVVwZGF0ZUZpbGUocmVzcG9uc2UsIHppcEZpbGVJbmZvLnVybC5ocmVmLCByZXF1ZXN0SGVhZGVycywgemlwRmlsZUluZm8uaW5mby5zaGE1MTIsIGNhbmNlbGxhdGlvblRva2VuLCBmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlcnJvck9jY3VycmVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXNwb25zZS53cml0ZUhlYWQoNTAwKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2UuZW5kKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMubmF0aXZlVXBkYXRlci5yZW1vdmVMaXN0ZW5lcihcImVycm9yXCIsIHJlamVjdCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlamVjdChuZXcgRXJyb3IoYENhbm5vdCBkb3dubG9hZCBcIiR7emlwRmlsZUluZm8udXJsfVwiOiAke2Vycm9yfWApKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLl9sb2dnZXIud2FybihgJHtyZXF1ZXN0VXJsfSByZXF1ZXN0ZWQsIGJ1dCBub3Qgc3VwcG9ydGVkYCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXNwb25zZS53cml0ZUhlYWQoNDA0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlLmVuZCgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgc2VydmVyLmxpc3RlbigwLCBcIjEyNy4wLjAuMVwiLCAxNiwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5uYXRpdmVVcGRhdGVyLnNldEZlZWRVUkwoYCR7Z2V0U2VydmVyVXJsKCl9YCwgeyBcIkNhY2hlLUNvbnRyb2xcIjogXCJuby1jYWNoZVwiIH0pO1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5uYXRpdmVVcGRhdGVyLm9uY2UoXCJlcnJvclwiLCByZWplY3QpO1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5uYXRpdmVVcGRhdGVyLmNoZWNrRm9yVXBkYXRlcygpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pKCk7XG4gICAgfVxuICAgIGRvUHJveHlVcGRhdGVGaWxlKG5hdGl2ZVJlc3BvbnNlLCB1cmwsIGhlYWRlcnMsIHNoYTUxMiwgY2FuY2VsbGF0aW9uVG9rZW4sIGVycm9ySGFuZGxlcikge1xuICAgICAgICBjb25zdCBkb3dubG9hZFJlcXVlc3QgPSB0aGlzLmh0dHBFeGVjdXRvci5kb1JlcXVlc3QoKDAsIChfYnVpbGRlclV0aWxSdW50aW1lIHx8IF9sb2FkX2J1aWxkZXJVdGlsUnVudGltZSgpKS5jb25maWd1cmVSZXF1ZXN0T3B0aW9uc0Zyb21VcmwpKHVybCwgeyBoZWFkZXJzIH0pLCBkb3dubG9hZFJlc3BvbnNlID0+IHtcbiAgICAgICAgICAgIGlmIChkb3dubG9hZFJlc3BvbnNlLnN0YXR1c0NvZGUgPj0gNDAwKSB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgbmF0aXZlUmVzcG9uc2Uud3JpdGVIZWFkKDQwNCk7XG4gICAgICAgICAgICAgICAgICAgIG5hdGl2ZVJlc3BvbnNlLmVuZCgpO1xuICAgICAgICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICAgICAgICAgIGVycm9ySGFuZGxlcihuZXcgRXJyb3IoYENhbm5vdCBkb3dubG9hZCBcIiR7dXJsfVwiLCBzdGF0dXMgJHtkb3dubG9hZFJlc3BvbnNlLnN0YXR1c0NvZGV9OiAke2Rvd25sb2FkUmVzcG9uc2Uuc3RhdHVzTWVzc2FnZX1gKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGluIHRlc3RzIEVsZWN0cm9uIE5FVCBBcGkgaXMgbm90IHVzZWQsIHNvLCB3ZSBoYXZlIHRvIGhhbmRsZSByZWRpcmVjdC5cbiAgICAgICAgICAgIGNvbnN0IHJlZGlyZWN0VXJsID0gKDAsIChfYnVpbGRlclV0aWxSdW50aW1lIHx8IF9sb2FkX2J1aWxkZXJVdGlsUnVudGltZSgpKS5zYWZlR2V0SGVhZGVyKShkb3dubG9hZFJlc3BvbnNlLCBcImxvY2F0aW9uXCIpO1xuICAgICAgICAgICAgaWYgKHJlZGlyZWN0VXJsICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmRvUHJveHlVcGRhdGVGaWxlKG5hdGl2ZVJlc3BvbnNlLCByZWRpcmVjdFVybCwgaGVhZGVycywgc2hhNTEyLCBjYW5jZWxsYXRpb25Ub2tlbiwgZXJyb3JIYW5kbGVyKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBuYXRpdmVIZWFkZXJzID0geyBcIkNvbnRlbnQtVHlwZVwiOiBcImFwcGxpY2F0aW9uL3ppcFwiIH07XG4gICAgICAgICAgICBjb25zdCBzdHJlYW1zID0gW107XG4gICAgICAgICAgICBjb25zdCBkb3dubG9hZExpc3RlbmVyQ291bnQgPSB0aGlzLmxpc3RlbmVyQ291bnQoKF9tYWluIHx8IF9sb2FkX21haW4oKSkuRE9XTkxPQURfUFJPR1JFU1MpO1xuICAgICAgICAgICAgdGhpcy5fbG9nZ2VyLmluZm8oYCR7KF9tYWluIHx8IF9sb2FkX21haW4oKSkuRE9XTkxPQURfUFJPR1JFU1N9IGxpc3RlbmVyIGNvdW50OiAke2Rvd25sb2FkTGlzdGVuZXJDb3VudH1gKTtcbiAgICAgICAgICAgIGlmIChkb3dubG9hZExpc3RlbmVyQ291bnQgPiAwKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgY29udGVudExlbmd0aCA9ICgwLCAoX2J1aWxkZXJVdGlsUnVudGltZSB8fCBfbG9hZF9idWlsZGVyVXRpbFJ1bnRpbWUoKSkuc2FmZUdldEhlYWRlcikoZG93bmxvYWRSZXNwb25zZSwgXCJjb250ZW50LWxlbmd0aFwiKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9sb2dnZXIuaW5mbyhgY29udGVudExlbmd0aDogJHtjb250ZW50TGVuZ3RofWApO1xuICAgICAgICAgICAgICAgIGlmIChjb250ZW50TGVuZ3RoICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgbmF0aXZlSGVhZGVyc1tcIkNvbnRlbnQtTGVuZ3RoXCJdID0gY29udGVudExlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgc3RyZWFtcy5wdXNoKG5ldyAoX2J1aWxkZXJVdGlsUnVudGltZSB8fCBfbG9hZF9idWlsZGVyVXRpbFJ1bnRpbWUoKSkuUHJvZ3Jlc3NDYWxsYmFja1RyYW5zZm9ybShwYXJzZUludChjb250ZW50TGVuZ3RoLCAxMCksIGNhbmNlbGxhdGlvblRva2VuLCBpdCA9PiB0aGlzLmVtaXQoKF9tYWluIHx8IF9sb2FkX21haW4oKSkuRE9XTkxPQURfUFJPR1JFU1MsIGl0KSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG5hdGl2ZVJlc3BvbnNlLndyaXRlSGVhZCgyMDAsIG5hdGl2ZUhlYWRlcnMpO1xuICAgICAgICAgICAgLy8gZm9yIG1hYyBvbmx5IHNoYTUxMiBpcyBwcm9kdWNlZCAoc2hhMjU2IGlzIHB1Ymxpc2hlZCBmb3Igd2luZG93cyBvbmx5IHRvIHByZXNlcnZlIGJhY2t3YXJkIGNvbXBhdGliaWxpdHkpXG4gICAgICAgICAgICBpZiAoc2hhNTEyICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAvLyBcImhleFwiIHRvIGVhc3kgbWlncmF0ZSB0byBuZXcgYmFzZTY0IGVuY29kZWQgaGFzaCAod2UgYWxyZWFkeSBwcm9kdWNlcyBsYXRlc3QtbWFjLnltbCB3aXRoIGhleCBlbmNvZGVkIGhhc2gpXG4gICAgICAgICAgICAgICAgc3RyZWFtcy5wdXNoKG5ldyAoX2J1aWxkZXJVdGlsUnVudGltZSB8fCBfbG9hZF9idWlsZGVyVXRpbFJ1bnRpbWUoKSkuRGlnZXN0VHJhbnNmb3JtKHNoYTUxMiwgXCJzaGE1MTJcIiwgc2hhNTEyLmxlbmd0aCA9PT0gMTI4ICYmICFzaGE1MTIuaW5jbHVkZXMoXCIrXCIpICYmICFzaGE1MTIuaW5jbHVkZXMoXCJaXCIpICYmICFzaGE1MTIuaW5jbHVkZXMoXCI9XCIpID8gXCJoZXhcIiA6IFwiYmFzZTY0XCIpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHN0cmVhbXMucHVzaChuYXRpdmVSZXNwb25zZSk7XG4gICAgICAgICAgICBsZXQgbGFzdFN0cmVhbSA9IGRvd25sb2FkUmVzcG9uc2U7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IHN0cmVhbSBvZiBzdHJlYW1zKSB7XG4gICAgICAgICAgICAgICAgc3RyZWFtLm9uKFwiZXJyb3JcIiwgZXJyb3JIYW5kbGVyKTtcbiAgICAgICAgICAgICAgICBsYXN0U3RyZWFtID0gbGFzdFN0cmVhbS5waXBlKHN0cmVhbSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBkb3dubG9hZFJlcXVlc3Qub24oXCJyZWRpcmVjdFwiLCAoc3RhdHVzQ29kZSwgbWV0aG9kLCByZWRpcmVjdFVybCkgPT4ge1xuICAgICAgICAgICAgaWYgKGhlYWRlcnMuQXV0aG9yaXphdGlvbiAhPSBudWxsICYmIGhlYWRlcnMuQXV0aG9yaXphdGlvbi5zdGFydHNXaXRoKFwidG9rZW5cIikpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBwYXJzZWROZXdVcmwgPSBuZXcgVVJMKHJlZGlyZWN0VXJsKTtcbiAgICAgICAgICAgICAgICBpZiAocGFyc2VkTmV3VXJsLmhvc3RuYW1lLmVuZHNXaXRoKFwiLmFtYXpvbmF3cy5jb21cIikpIHtcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlIGhlYWRlcnMuQXV0aG9yaXphdGlvbjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmRvUHJveHlVcGRhdGVGaWxlKG5hdGl2ZVJlc3BvbnNlLCByZWRpcmVjdFVybCwgaGVhZGVycywgc2hhNTEyLCBjYW5jZWxsYXRpb25Ub2tlbiwgZXJyb3JIYW5kbGVyKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGRvd25sb2FkUmVxdWVzdC5vbihcImVycm9yXCIsIGVycm9ySGFuZGxlcik7XG4gICAgICAgIGRvd25sb2FkUmVxdWVzdC5lbmQoKTtcbiAgICB9XG4gICAgcXVpdEFuZEluc3RhbGwoKSB7XG4gICAgICAgIHRoaXMubmF0aXZlVXBkYXRlci5xdWl0QW5kSW5zdGFsbCgpO1xuICAgIH1cbn1cbmV4cG9ydHMuTWFjVXBkYXRlciA9IE1hY1VwZGF0ZXI7IC8vIyBzb3VyY2VNYXBwaW5nVVJMPU1hY1VwZGF0ZXIuanMubWFwXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2VsZWN0cm9uLXVwZGF0ZXIvb3V0L01hY1VwZGF0ZXIuanMiLCJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5BcHBJbWFnZVVwZGF0ZXIgPSB1bmRlZmluZWQ7XG5cbnZhciBfYmx1ZWJpcmRMc3Q7XG5cbmZ1bmN0aW9uIF9sb2FkX2JsdWViaXJkTHN0KCkge1xuICAgIHJldHVybiBfYmx1ZWJpcmRMc3QgPSByZXF1aXJlKFwiYmx1ZWJpcmQtbHN0XCIpO1xufVxuXG52YXIgX2JsdWViaXJkTHN0MjtcblxuZnVuY3Rpb24gX2xvYWRfYmx1ZWJpcmRMc3QyKCkge1xuICAgIHJldHVybiBfYmx1ZWJpcmRMc3QyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiYmx1ZWJpcmQtbHN0XCIpKTtcbn1cblxudmFyIF9idWlsZGVyVXRpbFJ1bnRpbWU7XG5cbmZ1bmN0aW9uIF9sb2FkX2J1aWxkZXJVdGlsUnVudGltZSgpIHtcbiAgICByZXR1cm4gX2J1aWxkZXJVdGlsUnVudGltZSA9IHJlcXVpcmUoXCJidWlsZGVyLXV0aWwtcnVudGltZVwiKTtcbn1cblxudmFyIF9jaGlsZF9wcm9jZXNzO1xuXG5mdW5jdGlvbiBfbG9hZF9jaGlsZF9wcm9jZXNzKCkge1xuICAgIHJldHVybiBfY2hpbGRfcHJvY2VzcyA9IHJlcXVpcmUoXCJjaGlsZF9wcm9jZXNzXCIpO1xufVxuXG52YXIgX2VsZWN0cm9uSXNEZXY7XG5cbmZ1bmN0aW9uIF9sb2FkX2VsZWN0cm9uSXNEZXYoKSB7XG4gICAgcmV0dXJuIF9lbGVjdHJvbklzRGV2ID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiZWxlY3Ryb24taXMtZGV2XCIpKTtcbn1cblxudmFyIF9mc0V4dHJhUDtcblxuZnVuY3Rpb24gX2xvYWRfZnNFeHRyYVAoKSB7XG4gICAgcmV0dXJuIF9mc0V4dHJhUCA9IHJlcXVpcmUoXCJmcy1leHRyYS1wXCIpO1xufVxuXG52YXIgX3BhdGggPSBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChyZXF1aXJlKFwicGF0aFwiKSk7XG5cbnJlcXVpcmUoXCJzb3VyY2UtbWFwLXN1cHBvcnQvcmVnaXN0ZXJcIik7XG5cbnZhciBfQmFzZVVwZGF0ZXI7XG5cbmZ1bmN0aW9uIF9sb2FkX0Jhc2VVcGRhdGVyKCkge1xuICAgIHJldHVybiBfQmFzZVVwZGF0ZXIgPSByZXF1aXJlKFwiLi9CYXNlVXBkYXRlclwiKTtcbn1cblxudmFyIF9GaWxlV2l0aEVtYmVkZGVkQmxvY2tNYXBEaWZmZXJlbnRpYWxEb3dubG9hZGVyO1xuXG5mdW5jdGlvbiBfbG9hZF9GaWxlV2l0aEVtYmVkZGVkQmxvY2tNYXBEaWZmZXJlbnRpYWxEb3dubG9hZGVyKCkge1xuICAgIHJldHVybiBfRmlsZVdpdGhFbWJlZGRlZEJsb2NrTWFwRGlmZmVyZW50aWFsRG93bmxvYWRlciA9IHJlcXVpcmUoXCIuL2RpZmZlcmVudGlhbERvd25sb2FkZXIvRmlsZVdpdGhFbWJlZGRlZEJsb2NrTWFwRGlmZmVyZW50aWFsRG93bmxvYWRlclwiKTtcbn1cblxudmFyIF9tYWluO1xuXG5mdW5jdGlvbiBfbG9hZF9tYWluKCkge1xuICAgIHJldHVybiBfbWFpbiA9IHJlcXVpcmUoXCIuL21haW5cIik7XG59XG5cbnZhciBfUHJvdmlkZXI7XG5cbmZ1bmN0aW9uIF9sb2FkX1Byb3ZpZGVyKCkge1xuICAgIHJldHVybiBfUHJvdmlkZXIgPSByZXF1aXJlKFwiLi9Qcm92aWRlclwiKTtcbn1cblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQob2JqKSB7IGlmIChvYmogJiYgb2JqLl9fZXNNb2R1bGUpIHsgcmV0dXJuIG9iajsgfSBlbHNlIHsgdmFyIG5ld09iaiA9IHt9OyBpZiAob2JqICE9IG51bGwpIHsgZm9yICh2YXIga2V5IGluIG9iaikgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwga2V5KSkgbmV3T2JqW2tleV0gPSBvYmpba2V5XTsgfSB9IG5ld09iai5kZWZhdWx0ID0gb2JqOyByZXR1cm4gbmV3T2JqOyB9IH1cblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuY2xhc3MgQXBwSW1hZ2VVcGRhdGVyIGV4dGVuZHMgKF9CYXNlVXBkYXRlciB8fCBfbG9hZF9CYXNlVXBkYXRlcigpKS5CYXNlVXBkYXRlciB7XG4gICAgY29uc3RydWN0b3Iob3B0aW9ucywgYXBwKSB7XG4gICAgICAgIHN1cGVyKG9wdGlvbnMsIGFwcCk7XG4gICAgfVxuICAgIGNoZWNrRm9yVXBkYXRlc0FuZE5vdGlmeSgpIHtcbiAgICAgICAgaWYgKChfZWxlY3Ryb25Jc0RldiB8fCBfbG9hZF9lbGVjdHJvbklzRGV2KCkpLmRlZmF1bHQpIHtcbiAgICAgICAgICAgIHJldHVybiAoX2JsdWViaXJkTHN0MiB8fCBfbG9hZF9ibHVlYmlyZExzdDIoKSkuZGVmYXVsdC5yZXNvbHZlKG51bGwpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5BUFBJTUFHRSA9PSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLl9sb2dnZXIud2FybihcIkFQUElNQUdFIGVudiBpcyBub3QgZGVmaW5lZCwgY3VycmVudCBhcHBsaWNhdGlvbiBpcyBub3QgYW4gQXBwSW1hZ2VcIik7XG4gICAgICAgICAgICByZXR1cm4gKF9ibHVlYmlyZExzdDIgfHwgX2xvYWRfYmx1ZWJpcmRMc3QyKCkpLmRlZmF1bHQucmVzb2x2ZShudWxsKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc3VwZXIuY2hlY2tGb3JVcGRhdGVzQW5kTm90aWZ5KCk7XG4gICAgfVxuICAgIC8qKiogQHByaXZhdGUgKi9cbiAgICBkb0Rvd25sb2FkVXBkYXRlKHVwZGF0ZUluZm8sIGNhbmNlbGxhdGlvblRva2VuKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICAgICAgcmV0dXJuICgwLCAoX2JsdWViaXJkTHN0IHx8IF9sb2FkX2JsdWViaXJkTHN0KCkpLmNvcm91dGluZSkoZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGNvbnN0IHByb3ZpZGVyID0geWllbGQgX3RoaXMucHJvdmlkZXI7XG4gICAgICAgICAgICBjb25zdCBmaWxlSW5mbyA9ICgwLCAoX1Byb3ZpZGVyIHx8IF9sb2FkX1Byb3ZpZGVyKCkpLmZpbmRGaWxlKShwcm92aWRlci5yZXNvbHZlRmlsZXModXBkYXRlSW5mbyksIFwiQXBwSW1hZ2VcIik7XG4gICAgICAgICAgICBjb25zdCByZXF1ZXN0SGVhZGVycyA9IHlpZWxkIF90aGlzLmNvbXB1dGVSZXF1ZXN0SGVhZGVycygpO1xuICAgICAgICAgICAgY29uc3QgZG93bmxvYWRPcHRpb25zID0ge1xuICAgICAgICAgICAgICAgIHNraXBEaXJDcmVhdGlvbjogdHJ1ZSxcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiByZXF1ZXN0SGVhZGVycyxcbiAgICAgICAgICAgICAgICBjYW5jZWxsYXRpb25Ub2tlbixcbiAgICAgICAgICAgICAgICBzaGE1MTI6IGZpbGVJbmZvLmluZm8uc2hhNTEyXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgbGV0IGluc3RhbGxlclBhdGggPSBfdGhpcy5kb3dubG9hZGVkVXBkYXRlSGVscGVyLmdldERvd25sb2FkZWRGaWxlKHVwZGF0ZUluZm8sIGZpbGVJbmZvKTtcbiAgICAgICAgICAgIGlmIChpbnN0YWxsZXJQYXRoICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gW2luc3RhbGxlclBhdGhdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgeWllbGQgX3RoaXMuZXhlY3V0ZURvd25sb2FkKGRvd25sb2FkT3B0aW9ucywgZmlsZUluZm8sICgoKSA9PiB7XG4gICAgICAgICAgICAgICAgdmFyIF9yZWYgPSAoMCwgKF9ibHVlYmlyZExzdCB8fCBfbG9hZF9ibHVlYmlyZExzdCgpKS5jb3JvdXRpbmUpKGZ1bmN0aW9uKiAodGVtcERpciwgZGVzdGluYXRpb25GaWxlKSB7XG4gICAgICAgICAgICAgICAgICAgIGluc3RhbGxlclBhdGggPSBkZXN0aW5hdGlvbkZpbGU7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG9sZEZpbGUgPSBwcm9jZXNzLmVudi5BUFBJTUFHRTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG9sZEZpbGUgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgKDAsIChfYnVpbGRlclV0aWxSdW50aW1lIHx8IF9sb2FkX2J1aWxkZXJVdGlsUnVudGltZSgpKS5uZXdFcnJvcikoXCJBUFBJTUFHRSBlbnYgaXMgbm90IGRlZmluZWRcIiwgXCJFUlJfVVBEQVRFUl9PTERfRklMRV9OT1RfRk9VTkRcIik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgbGV0IGlzRG93bmxvYWRGdWxsID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB5aWVsZCBuZXcgKF9GaWxlV2l0aEVtYmVkZGVkQmxvY2tNYXBEaWZmZXJlbnRpYWxEb3dubG9hZGVyIHx8IF9sb2FkX0ZpbGVXaXRoRW1iZWRkZWRCbG9ja01hcERpZmZlcmVudGlhbERvd25sb2FkZXIoKSkuRmlsZVdpdGhFbWJlZGRlZEJsb2NrTWFwRGlmZmVyZW50aWFsRG93bmxvYWRlcihmaWxlSW5mby5pbmZvLCBfdGhpcy5odHRwRXhlY3V0b3IsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXdVcmw6IGZpbGVJbmZvLnVybC5ocmVmLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9sZEZpbGUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbG9nZ2VyOiBfdGhpcy5fbG9nZ2VyLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ld0ZpbGU6IGluc3RhbGxlclBhdGgsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdXNlTXVsdGlwbGVSYW5nZVJlcXVlc3Q6IHByb3ZpZGVyLnVzZU11bHRpcGxlUmFuZ2VSZXF1ZXN0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlcXVlc3RIZWFkZXJzXG4gICAgICAgICAgICAgICAgICAgICAgICB9KS5kb3dubG9hZCgpO1xuICAgICAgICAgICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5fbG9nZ2VyLmVycm9yKGBDYW5ub3QgZG93bmxvYWQgZGlmZmVyZW50aWFsbHksIGZhbGxiYWNrIHRvIGZ1bGwgZG93bmxvYWQ6ICR7ZS5zdGFjayB8fCBlfWApO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gZHVyaW5nIHRlc3QgKGRldmVsb3BlciBtYWNoaW5lIG1hYykgd2UgbXVzdCB0aHJvdyBlcnJvclxuICAgICAgICAgICAgICAgICAgICAgICAgaXNEb3dubG9hZEZ1bGwgPSBwcm9jZXNzLnBsYXRmb3JtID09PSBcImxpbnV4XCI7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzRG93bmxvYWRGdWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB5aWVsZCBfdGhpcy5odHRwRXhlY3V0b3IuZG93bmxvYWQoZmlsZUluZm8udXJsLmhyZWYsIGluc3RhbGxlclBhdGgsIGRvd25sb2FkT3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgeWllbGQgKDAsIChfZnNFeHRyYVAgfHwgX2xvYWRfZnNFeHRyYVAoKSkuY2htb2QpKGluc3RhbGxlclBhdGgsIDBvNzU1KTtcbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoX3gsIF94Mikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gX3JlZi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9KSgpKTtcbiAgICAgICAgICAgIF90aGlzLmRvd25sb2FkZWRVcGRhdGVIZWxwZXIuc2V0RG93bmxvYWRlZEZpbGUoaW5zdGFsbGVyUGF0aCwgbnVsbCwgdXBkYXRlSW5mbywgZmlsZUluZm8pO1xuICAgICAgICAgICAgX3RoaXMuYWRkUXVpdEhhbmRsZXIoKTtcbiAgICAgICAgICAgIF90aGlzLmVtaXQoKF9tYWluIHx8IF9sb2FkX21haW4oKSkuVVBEQVRFX0RPV05MT0FERUQsIF90aGlzLnVwZGF0ZUluZm8pO1xuICAgICAgICAgICAgcmV0dXJuIFtpbnN0YWxsZXJQYXRoXTtcbiAgICAgICAgfSkoKTtcbiAgICB9XG4gICAgZG9JbnN0YWxsKGluc3RhbGxlclBhdGgsIGlzU2lsZW50LCBpc1J1bkFmdGVyKSB7XG4gICAgICAgIGNvbnN0IGFwcEltYWdlRmlsZSA9IHByb2Nlc3MuZW52LkFQUElNQUdFO1xuICAgICAgICBpZiAoYXBwSW1hZ2VGaWxlID09IG51bGwpIHtcbiAgICAgICAgICAgIHRocm93ICgwLCAoX2J1aWxkZXJVdGlsUnVudGltZSB8fCBfbG9hZF9idWlsZGVyVXRpbFJ1bnRpbWUoKSkubmV3RXJyb3IpKFwiQVBQSU1BR0UgZW52IGlzIG5vdCBkZWZpbmVkXCIsIFwiRVJSX1VQREFURVJfT0xEX0ZJTEVfTk9UX0ZPVU5EXCIpO1xuICAgICAgICB9XG4gICAgICAgIC8vIGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8xNzEyMDUxLzE5MTAxOTFcbiAgICAgICAgKDAsIChfZnNFeHRyYVAgfHwgX2xvYWRfZnNFeHRyYVAoKSkudW5saW5rU3luYykoYXBwSW1hZ2VGaWxlKTtcbiAgICAgICAgbGV0IGRlc3RpbmF0aW9uO1xuICAgICAgICBpZiAoX3BhdGguYmFzZW5hbWUoaW5zdGFsbGVyUGF0aCkgPT09IF9wYXRoLmJhc2VuYW1lKGFwcEltYWdlRmlsZSkpIHtcbiAgICAgICAgICAgIC8vIG5vIHZlcnNpb24gaW4gdGhlIGZpbGUgbmFtZSwgb3ZlcndyaXRlIGV4aXN0aW5nXG4gICAgICAgICAgICBkZXN0aW5hdGlvbiA9IGFwcEltYWdlRmlsZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGRlc3RpbmF0aW9uID0gX3BhdGguam9pbihfcGF0aC5kaXJuYW1lKGFwcEltYWdlRmlsZSksIF9wYXRoLmJhc2VuYW1lKGluc3RhbGxlclBhdGgpKTtcbiAgICAgICAgfVxuICAgICAgICAoMCwgKF9jaGlsZF9wcm9jZXNzIHx8IF9sb2FkX2NoaWxkX3Byb2Nlc3MoKSkuZXhlY0ZpbGVTeW5jKShcIm12XCIsIFtcIi1mXCIsIGluc3RhbGxlclBhdGgsIGRlc3RpbmF0aW9uXSk7XG4gICAgICAgIGNvbnN0IGVudiA9IE9iamVjdC5hc3NpZ24oe30sIHByb2Nlc3MuZW52LCB7IEFQUElNQUdFX1NJTEVOVF9JTlNUQUxMOiBcInRydWVcIiB9KTtcbiAgICAgICAgaWYgKGlzUnVuQWZ0ZXIpIHtcbiAgICAgICAgICAgICgwLCAoX2NoaWxkX3Byb2Nlc3MgfHwgX2xvYWRfY2hpbGRfcHJvY2VzcygpKS5zcGF3bikoZGVzdGluYXRpb24sIFtdLCB7XG4gICAgICAgICAgICAgICAgZGV0YWNoZWQ6IHRydWUsXG4gICAgICAgICAgICAgICAgc3RkaW86IFwiaWdub3JlXCIsXG4gICAgICAgICAgICAgICAgZW52XG4gICAgICAgICAgICB9KS51bnJlZigpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZW52LkFQUElNQUdFX0VYSVRfQUZURVJfSU5TVEFMTCA9IFwidHJ1ZVwiO1xuICAgICAgICAgICAgKDAsIChfY2hpbGRfcHJvY2VzcyB8fCBfbG9hZF9jaGlsZF9wcm9jZXNzKCkpLmV4ZWNGaWxlU3luYykoZGVzdGluYXRpb24sIFtdLCB7IGVudiB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG59XG5leHBvcnRzLkFwcEltYWdlVXBkYXRlciA9IEFwcEltYWdlVXBkYXRlcjsgLy8jIHNvdXJjZU1hcHBpbmdVUkw9QXBwSW1hZ2VVcGRhdGVyLmpzLm1hcFxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9lbGVjdHJvbi11cGRhdGVyL291dC9BcHBJbWFnZVVwZGF0ZXIuanMiLCIndXNlIHN0cmljdCc7XG5cbmlmIChwcm9jZXNzLnR5cGUgPT09ICdyZW5kZXJlcicpIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL3JlbmRlcmVyJyk7XG59IGVsc2Uge1xuICBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vbWFpbicpO1xufVxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9lbGVjdHJvbi1sb2cvaW5kZXguanMiLCIndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gbnVsbDtcblxudmFyIGlwY1JlbmRlcmVyO1xudHJ5IHtcbiAgaXBjUmVuZGVyZXIgPSByZXF1aXJlKCdlbGVjdHJvbicpLmlwY1JlbmRlcmVyO1xufSBjYXRjaCAoZSkge1xuICBpcGNSZW5kZXJlciA9IG51bGw7XG59XG5cbnZhciBvcmlnaW5hbENvbnNvbGUgPSByZXF1aXJlKCcuL2xpYi9vcmlnaW5hbC1jb25zb2xlJyk7XG5cbmlmIChpcGNSZW5kZXJlcikge1xuICBtb2R1bGUuZXhwb3J0cyA9IHtcbiAgICBlcnJvcjogICBsb2cuYmluZChudWxsLCAnZXJyb3InKSxcbiAgICB3YXJuOiAgICBsb2cuYmluZChudWxsLCAnd2FybicpLFxuICAgIGluZm86ICAgIGxvZy5iaW5kKG51bGwsICdpbmZvJyksXG4gICAgdmVyYm9zZTogbG9nLmJpbmQobnVsbCwgJ3ZlcmJvc2UnKSxcbiAgICBkZWJ1ZzogICBsb2cuYmluZChudWxsLCAnZGVidWcnKSxcbiAgICBzaWxseTogICBsb2cuYmluZChudWxsLCAnc2lsbHknKSxcbiAgICBsb2c6ICAgICBsb2cuYmluZChudWxsLCAnaW5mbycpXG4gIH07XG5cbiAgbW9kdWxlLmV4cG9ydHMuZGVmYXVsdCA9IG1vZHVsZS5leHBvcnRzO1xuXG4gIGlwY1JlbmRlcmVyLm9uKCdfX0VMRUNUUk9OX0xPR19SRU5ERVJFUl9fJywgZnVuY3Rpb24oZXZlbnQsIGxldmVsLCB0ZXh0KSB7XG4gICAgaWYgKGxldmVsID09PSAndmVyYm9zZScpIHtcbiAgICAgIGxldmVsID0gJ2xvZyc7XG4gICAgfSBlbHNlIGlmIChsZXZlbCA9PT0gJ3NpbGx5Jykge1xuICAgICAgbGV2ZWwgPSAnZGVidWcnO1xuICAgIH1cblxuICAgIG9yaWdpbmFsQ29uc29sZVtsZXZlbF0uY2FsbChvcmlnaW5hbENvbnNvbGUuY29udGV4dCwgdGV4dCk7XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBsb2coKSB7XG4gIHZhciBkYXRhID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKTtcblxuICBkYXRhID0gZGF0YS5tYXAoZnVuY3Rpb24ob2JqKSB7XG4gICAgaWYgKG9iaiBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICBvYmogPSBvYmouc3RhY2sgfHwgb2JqO1xuICAgIH1cblxuICAgIHJldHVybiBvYmo7XG4gIH0pO1xuXG4gIGlwY1JlbmRlcmVyLnNlbmQoJ19fRUxFQ1RST05fTE9HX18nLCBkYXRhKTtcbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9lbGVjdHJvbi1sb2cvcmVuZGVyZXIuanMiLCIndXNlIHN0cmljdCc7XG5cbnZhciBlbGVjdHJvbjtcbnRyeSB7XG4gIGVsZWN0cm9uID0gcmVxdWlyZSgnZWxlY3Ryb24nKTtcbn0gY2F0Y2ggKGUpIHtcbiAgZWxlY3Ryb24gPSBudWxsO1xufVxuXG52YXIgbG9nICAgICAgICAgICAgICAgICAgICAgID0gcmVxdWlyZSgnLi9saWIvbG9nJyk7XG52YXIgdHJhbnNwb3J0Q29uc29sZSAgICAgICAgID0gcmVxdWlyZSgnLi9saWIvdHJhbnNwb3J0cy9jb25zb2xlJyk7XG52YXIgdHJhbnNwb3J0RmlsZSAgICAgICAgICAgID0gcmVxdWlyZSgnLi9saWIvdHJhbnNwb3J0cy9maWxlJyk7XG52YXIgdHJhbnNwb3J0TG9nUyAgICAgICAgICAgID0gcmVxdWlyZSgnLi9saWIvdHJhbnNwb3J0cy9sb2ctcycpO1xudmFyIHRyYW5zcG9ydFJlbmRlcmVyQ29uc29sZSA9IHJlcXVpcmUoJy4vbGliL3RyYW5zcG9ydHMvcmVuZGVyZXItY29uc29sZScpO1xuXG52YXIgdHJhbnNwb3J0cyA9IHtcbiAgY29uc29sZTogdHJhbnNwb3J0Q29uc29sZSxcbiAgZmlsZTogdHJhbnNwb3J0RmlsZSxcbiAgbG9nUzogdHJhbnNwb3J0TG9nUyxcbiAgcmVuZGVyZXJDb25zb2xlOiB0cmFuc3BvcnRSZW5kZXJlckNvbnNvbGVcbn07XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICB0cmFuc3BvcnRzOiB0cmFuc3BvcnRzLFxuXG4gIGVycm9yOiAgIGxvZy5iaW5kKG51bGwsIHRyYW5zcG9ydHMsICdlcnJvcicpLFxuICB3YXJuOiAgICBsb2cuYmluZChudWxsLCB0cmFuc3BvcnRzLCAnd2FybicpLFxuICBpbmZvOiAgICBsb2cuYmluZChudWxsLCB0cmFuc3BvcnRzLCAnaW5mbycpLFxuICB2ZXJib3NlOiBsb2cuYmluZChudWxsLCB0cmFuc3BvcnRzLCAndmVyYm9zZScpLFxuICBkZWJ1ZzogICBsb2cuYmluZChudWxsLCB0cmFuc3BvcnRzLCAnZGVidWcnKSxcbiAgc2lsbHk6ICAgbG9nLmJpbmQobnVsbCwgdHJhbnNwb3J0cywgJ3NpbGx5JyksXG4gIGxvZzogICAgIGxvZy5iaW5kKG51bGwsIHRyYW5zcG9ydHMsICdpbmZvJylcbn07XG5cbm1vZHVsZS5leHBvcnRzLmRlZmF1bHQgPSBtb2R1bGUuZXhwb3J0cztcblxuaWYgKGVsZWN0cm9uICYmIGVsZWN0cm9uLmlwY01haW4pIHtcbiAgZWxlY3Ryb24uaXBjTWFpbi5vbignX19FTEVDVFJPTl9MT0dfXycsIG9uUmVuZGVyZXJMb2cpO1xuICB2YXIgYXBwTmFtZSA9IGVsZWN0cm9uLmFwcC5nZXROYW1lKCk7XG4gIGlmIChhcHBOYW1lICE9PSAnRWxlY3Ryb24nKSB7XG4gICAgdHJhbnNwb3J0RmlsZS5hcHBOYW1lID0gYXBwTmFtZTtcbiAgfVxufVxuXG5mdW5jdGlvbiBvblJlbmRlcmVyTG9nKGV2ZW50LCBkYXRhKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KGRhdGEpKSB7XG4gICAgZGF0YS51bnNoaWZ0KHRyYW5zcG9ydHMpO1xuICAgIGxvZy5hcHBseShudWxsLCBkYXRhKTtcbiAgfVxufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2VsZWN0cm9uLWxvZy9tYWluLmpzIiwiLy8ganNoaW50IC1XMDQwXG4ndXNlIHN0cmljdCc7XG5cbnZhciBMRVZFTFMgPSBbJ2Vycm9yJywgJ3dhcm4nLCAnaW5mbycsICd2ZXJib3NlJywgJ2RlYnVnJywgJ3NpbGx5J107XG5cbm1vZHVsZS5leHBvcnRzID0gbG9nO1xuXG5mdW5jdGlvbiBsb2codHJhbnNwb3J0cywgbGV2ZWwsIHRleHQpIHtcbiAgdmFyIGRhdGEgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDIpO1xuXG4gIHZhciBtc2cgPSB7XG4gICAgZGF0YTogZGF0YSxcbiAgICBkYXRlOiBuZXcgRGF0ZSgpLFxuICAgIGxldmVsOiBsZXZlbFxuICB9O1xuXG4gIGZvciAodmFyIGkgaW4gdHJhbnNwb3J0cykge1xuICAgIC8vIGpzaGludCAtVzA4OVxuICAgIGlmICghdHJhbnNwb3J0cy5oYXNPd25Qcm9wZXJ0eShpKSB8fCB0eXBlb2YgdHJhbnNwb3J0c1tpXSAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgdmFyIHRyYW5zcG9ydCA9IHRyYW5zcG9ydHNbaV07XG5cbiAgICBpZiAodHJhbnNwb3J0ID09PSBmYWxzZSB8fCAhY29tcGFyZUxldmVscyh0cmFuc3BvcnQubGV2ZWwsIGxldmVsKSkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgaWYgKHRyYW5zcG9ydC5sZXZlbCA9PT0gZmFsc2UpIGNvbnRpbnVlO1xuXG4gICAgdHJhbnNwb3J0LmNhbGwobnVsbCwgbXNnKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBjb21wYXJlTGV2ZWxzKHBhc3NMZXZlbCwgY2hlY2tMZXZlbCkge1xuICB2YXIgcGFzcyA9IExFVkVMUy5pbmRleE9mKHBhc3NMZXZlbCk7XG4gIHZhciBjaGVjayA9IExFVkVMUy5pbmRleE9mKGNoZWNrTGV2ZWwpO1xuICBpZiAoY2hlY2sgPT09IC0xIHx8IHBhc3MgPT09IC0xKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgcmV0dXJuIGNoZWNrIDw9IHBhc3M7XG59XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2VsZWN0cm9uLWxvZy9saWIvbG9nLmpzIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgZnMgICAgICAgICAgICAgICA9IHJlcXVpcmUoJ2ZzJyk7XG52YXIgRU9MICAgICAgICAgICAgICA9IHJlcXVpcmUoJ29zJykuRU9MO1xudmFyIGZvcm1hdCAgICAgICAgICAgPSByZXF1aXJlKCcuLi8uLi9mb3JtYXQnKTtcbnZhciBjb25zb2xlVHJhbnNwb3J0ID0gcmVxdWlyZSgnLi4vY29uc29sZScpO1xudmFyIGZpbmRMb2dQYXRoICAgICAgPSByZXF1aXJlKCcuL2ZpbmQtbG9nLXBhdGgnKTtcblxudHJhbnNwb3J0LmZpbmRMb2dQYXRoICA9IGZpbmRMb2dQYXRoO1xudHJhbnNwb3J0LmZvcm1hdCAgICAgICA9ICdbe3l9LXttfS17ZH0ge2h9OntpfTp7c30ue21zfV0gW3tsZXZlbH1dIHt0ZXh0fSc7XG50cmFuc3BvcnQubGV2ZWwgICAgICAgID0gJ3dhcm4nO1xudHJhbnNwb3J0Lm1heFNpemUgICAgICA9IDEwMjQgKiAxMDI0O1xudHJhbnNwb3J0LnN0cmVhbUNvbmZpZyA9IHVuZGVmaW5lZDtcblxubW9kdWxlLmV4cG9ydHMgPSB0cmFuc3BvcnQ7XG5cbmZ1bmN0aW9uIHRyYW5zcG9ydChtc2cpIHtcbiAgdmFyIHRleHQgPSBmb3JtYXQuZm9ybWF0KG1zZywgdHJhbnNwb3J0LmZvcm1hdCkgKyBFT0w7XG5cbiAgaWYgKHRyYW5zcG9ydC5zdHJlYW0gPT09IHVuZGVmaW5lZCkge1xuICAgIGluaXRTdGVhbUNvbmZpZygpO1xuICAgIG9wZW5TdHJlYW0oKTtcbiAgfVxuXG4gIGlmICh0cmFuc3BvcnQubGV2ZWwgPT09IGZhbHNlKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIG5lZWRMb2dSb3RhdGlvbiA9IHRyYW5zcG9ydC5tYXhTaXplID4gMCAmJlxuICAgIGdldFN0cmVhbVNpemUodHJhbnNwb3J0LnN0cmVhbSkgPiB0cmFuc3BvcnQubWF4U2l6ZTtcblxuICBpZiAobmVlZExvZ1JvdGF0aW9uKSB7XG4gICAgYXJjaGl2ZUxvZyh0cmFuc3BvcnQuc3RyZWFtKTtcbiAgICBvcGVuU3RyZWFtKCk7XG4gIH1cblxuICB0cmFuc3BvcnQuc3RyZWFtLndyaXRlKHRleHQpO1xufVxuXG5mdW5jdGlvbiBpbml0U3RlYW1Db25maWcoKSB7XG4gIHRyYW5zcG9ydC5maWxlID0gdHJhbnNwb3J0LmZpbGUgfHwgZmluZExvZ1BhdGgodHJhbnNwb3J0LmFwcE5hbWUpO1xuXG4gIGlmICghdHJhbnNwb3J0LmZpbGUpIHtcbiAgICB0cmFuc3BvcnQubGV2ZWwgPSBmYWxzZTtcbiAgICBsb2dDb25zb2xlKCdDb3VsZCBub3Qgc2V0IGEgbG9nIGZpbGUnKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBvcGVuU3RyZWFtKCkge1xuICBpZiAodHJhbnNwb3J0LmxldmVsID09PSBmYWxzZSkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHRyYW5zcG9ydC5zdHJlYW0gPSBmcy5jcmVhdGVXcml0ZVN0cmVhbShcbiAgICB0cmFuc3BvcnQuZmlsZSxcbiAgICB0cmFuc3BvcnQuc3RyZWFtQ29uZmlnIHx8IHsgZmxhZ3M6ICdhJyB9XG4gICk7XG59XG5cbmZ1bmN0aW9uIGdldFN0cmVhbVNpemUoc3RyZWFtKSB7XG4gIGlmICghc3RyZWFtKSB7XG4gICAgcmV0dXJuIDA7XG4gIH1cblxuICBpZiAoc3RyZWFtLmxvZ1NpemVBdFN0YXJ0ID09PSB1bmRlZmluZWQpIHtcbiAgICB0cnkge1xuICAgICAgc3RyZWFtLmxvZ1NpemVBdFN0YXJ0ID0gZnMuc3RhdFN5bmMoc3RyZWFtLnBhdGgpLnNpemU7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgc3RyZWFtLmxvZ1NpemVBdFN0YXJ0ID0gMDtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gc3RyZWFtLmxvZ1NpemVBdFN0YXJ0ICsgc3RyZWFtLmJ5dGVzV3JpdHRlbjtcbn1cblxuZnVuY3Rpb24gYXJjaGl2ZUxvZyhzdHJlYW0pIHtcbiAgaWYgKHN0cmVhbS5lbmQpIHtcbiAgICBzdHJlYW0uZW5kKCk7XG4gIH1cblxuICB0cnkge1xuICAgIGZzLnJlbmFtZVN5bmMoc3RyZWFtLnBhdGgsIHN0cmVhbS5wYXRoLnJlcGxhY2UoL2xvZyQvLCAnb2xkLmxvZycpKTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIGxvZ0NvbnNvbGUoJ0NvdWxkIG5vdCByb3RhdGUgbG9nJywgZSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gbG9nQ29uc29sZShtZXNzYWdlLCBlcnJvcikge1xuICB2YXIgZGF0YSA9IFsnZWxlY3Ryb24tbG9nLnRyYW5zcG9ydHMuZmlsZTogJyArIG1lc3NhZ2VdO1xuXG4gIGlmIChlcnJvcikge1xuICAgIGRhdGEucHVzaChlcnJvcik7XG4gIH1cblxuICBjb25zb2xlVHJhbnNwb3J0KHsgZGF0YTogZGF0YSwgZGF0ZTogbmV3IERhdGUoKSwgbGV2ZWw6ICd3YXJuJyB9KTtcbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9lbGVjdHJvbi1sb2cvbGliL3RyYW5zcG9ydHMvZmlsZS9pbmRleC5qcyIsIid1c2Ugc3RyaWN0JztcblxudmFyIGZzICAgPSByZXF1aXJlKCdmcycpO1xudmFyIHBhdGggPSByZXF1aXJlKCdwYXRoJyk7XG52YXIgb3MgICA9IHJlcXVpcmUoJ29zJyk7XG52YXIgZ2V0QXBwTmFtZSA9IHJlcXVpcmUoJy4vZ2V0LWFwcC1uYW1lJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZmluZExvZ1BhdGg7XG5cbi8qKlxuICogVHJ5IHRvIGRldGVybWluZSBhIHBsYXRmb3JtLXNwZWNpZmljIHBhdGggd2hlcmUgY2FuIHdyaXRlIGxvZ3NcbiAqIEBwYXJhbSB7c3RyaW5nfSBbYXBwTmFtZV0gVXNlZCB0byBkZXRlcm1pbmUgdGhlIGxhc3QgcGFydCBvZiBhIGxvZyBwYXRoXG4gKiBAcmV0dXJuIHtzdHJpbmd8Ym9vbGVhbn1cbiAqL1xuZnVuY3Rpb24gZmluZExvZ1BhdGgoYXBwTmFtZSkge1xuICBhcHBOYW1lID0gYXBwTmFtZSB8fCBnZXRBcHBOYW1lKCk7XG4gIGlmICghYXBwTmFtZSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHZhciBob21lRGlyID0gb3MuaG9tZWRpciA/IG9zLmhvbWVkaXIoKSA6IHByb2Nlc3MuZW52WydIT01FJ107XG4gIFxuICB2YXIgZGlyO1xuICBzd2l0Y2ggKHByb2Nlc3MucGxhdGZvcm0pIHtcbiAgICBjYXNlICdsaW51eCc6IHtcbiAgICAgIGRpciA9IHByZXBhcmVEaXIocHJvY2Vzcy5lbnZbJ1hER19DT05GSUdfSE9NRSddLCBhcHBOYW1lKVxuICAgICAgICAub3IoaG9tZURpciwgJy5jb25maWcnLCBhcHBOYW1lKVxuICAgICAgICAub3IocHJvY2Vzcy5lbnZbJ1hER19EQVRBX0hPTUUnXSwgYXBwTmFtZSlcbiAgICAgICAgLm9yKGhvbWVEaXIsICcubG9jYWwnLCAnc2hhcmUnLCBhcHBOYW1lKVxuICAgICAgICAucmVzdWx0O1xuICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgY2FzZSAnZGFyd2luJzoge1xuICAgICAgZGlyID0gcHJlcGFyZURpcihob21lRGlyLCAnTGlicmFyeScsICdMb2dzJywgYXBwTmFtZSlcbiAgICAgICAgLm9yKGhvbWVEaXIsICdMaWJyYXJ5JywgJ0FwcGxpY2F0aW9uIFN1cHBvcnQnLCBhcHBOYW1lKVxuICAgICAgICAucmVzdWx0O1xuICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgY2FzZSAnd2luMzInOiB7XG4gICAgICBkaXIgPSBwcmVwYXJlRGlyKHByb2Nlc3MuZW52WydBUFBEQVRBJ10sIGFwcE5hbWUpXG4gICAgICAgIC5vcihob21lRGlyLCAnQXBwRGF0YScsICdSb2FtaW5nJywgYXBwTmFtZSlcbiAgICAgICAgLnJlc3VsdDtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuXG4gIGlmIChkaXIpIHtcbiAgICByZXR1cm4gcGF0aC5qb2luKGRpciwgJ2xvZy5sb2cnKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn1cblxuXG5cbmZ1bmN0aW9uIHByZXBhcmVEaXIoZGlyUGF0aCkge1xuICAvLyBqc2hpbnQgLVcwNDBcbiAgaWYgKCF0aGlzIHx8IHRoaXMub3IgIT09IHByZXBhcmVEaXIgfHwgIXRoaXMucmVzdWx0KSB7XG4gICAgaWYgKCFkaXJQYXRoKSB7XG4gICAgICByZXR1cm4geyBvcjogcHJlcGFyZURpciB9O1xuICAgIH1cblxuICAgIC8vbm9pbnNwZWN0aW9uIEpTQ2hlY2tGdW5jdGlvblNpZ25hdHVyZXNcbiAgICBkaXJQYXRoID0gcGF0aC5qb2luLmFwcGx5KHBhdGgsIGFyZ3VtZW50cyk7XG4gICAgbWtEaXIoZGlyUGF0aCk7XG5cbiAgICB0cnkge1xuICAgICAgZnMuYWNjZXNzU3luYyhkaXJQYXRoLCBmcy5XX09LKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICByZXR1cm4geyBvcjogcHJlcGFyZURpciB9O1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB7XG4gICAgb3I6IHByZXBhcmVEaXIsXG4gICAgcmVzdWx0OiAodGhpcyA/IHRoaXMucmVzdWx0IDogZmFsc2UpIHx8IGRpclBhdGhcbiAgfTtcbn1cblxuZnVuY3Rpb24gbWtEaXIoZGlyUGF0aCwgcm9vdCkge1xuICB2YXIgZGlycyA9IGRpclBhdGguc3BsaXQocGF0aC5zZXApO1xuICB2YXIgZGlyID0gZGlycy5zaGlmdCgpO1xuICByb290ID0gKHJvb3QgfHwgJycpICsgZGlyICsgcGF0aC5zZXA7XG5cbiAgdHJ5IHtcbiAgICBmcy5ta2RpclN5bmMocm9vdCk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICBpZiAoIWZzLnN0YXRTeW5jKHJvb3QpLmlzRGlyZWN0b3J5KCkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihlKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gIWRpcnMubGVuZ3RoIHx8IG1rRGlyKGRpcnMuam9pbihwYXRoLnNlcCksIHJvb3QpO1xufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2VsZWN0cm9uLWxvZy9saWIvdHJhbnNwb3J0cy9maWxlL2ZpbmQtbG9nLXBhdGguanMiLCIvLyBqc2hpbnQgLVcwNzRcbid1c2Ugc3RyaWN0JztcblxuLyoqIEBuYW1lIHByb2Nlc3MucmVzb3VyY2VzUGF0aCAqL1xuXG52YXIgZnMgICA9IHJlcXVpcmUoJ2ZzJyk7XG52YXIgcGF0aCA9IHJlcXVpcmUoJ3BhdGgnKTtcbnZhciBjb25zb2xlVHJhbnNwb3J0ID0gcmVxdWlyZSgnLi4vY29uc29sZScpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGdldEFwcE5hbWU7XG5cbmZ1bmN0aW9uIGdldEFwcE5hbWUoKSB7XG4gIHRyeSB7XG4gICAgdmFyIG5hbWUgPSBsb2FkUGFja2FnZU5hbWUoKTtcbiAgICBpZiAobmFtZSkge1xuICAgICAgcmV0dXJuIG5hbWU7XG4gICAgfVxuICAgIHJldHVybiB3YXJuKCdlbGVjdHJvbi1sb2c6IHVuYWJsZSB0byBsb2FkIHRoZSBhcHAgbmFtZSBmcm9tIHBhY2thZ2UuanNvbicpO1xuICB9IGNhdGNoIChlKSB7XG4gICAgcmV0dXJuIHdhcm4oJ2VsZWN0cm9uLWxvZzogJyArIGUubWVzc2FnZSk7XG4gIH1cbn1cblxuLyoqXG4gKiBUcnkgdG8gbG9hZCBtYWluIGFwcCBwYWNrYWdlXG4gKiBAdGhyb3dzIHtFcnJvcn1cbiAqIEByZXR1cm4ge09iamVjdHxudWxsfVxuICovXG5mdW5jdGlvbiBsb2FkUGFja2FnZU5hbWUoKSB7XG4gIHZhciBwYWNrYWdlRmlsZTtcblxuICB0cnkge1xuICAgIGlmIChyZXF1aXJlLm1haW4uZmlsZW5hbWUpIHtcbiAgICAgIHBhY2thZ2VGaWxlID0gZmluZChwYXRoLmRpcm5hbWUocmVxdWlyZS5tYWluLmZpbGVuYW1lKSk7XG4gICAgfVxuICB9IGNhdGNoIChlKSB7fVxuXG4gIGlmICghcGFja2FnZUZpbGUgJiYgcHJvY2Vzcy5yZXNvdXJjZXNQYXRoKSB7XG4gICAgcGFja2FnZUZpbGUgPSBmaW5kKHBhdGguam9pbihwcm9jZXNzLnJlc291cmNlc1BhdGgsICdhcHAuYXNhcicpKTtcbiAgICB2YXIgZWxlY3Ryb25Nb2R1bGUgPSBwYXRoLmpvaW4oJ25vZGVfbW9kdWxlcycsICdlbGVjdHJvbicsICdwYWNrYWdlLmpzb24nKTtcbiAgICBpZiAocGFja2FnZUZpbGUgJiYgcGFja2FnZUZpbGUuaW5kZXhPZihlbGVjdHJvbk1vZHVsZSkgIT09IC0xKSB7XG4gICAgICBwYWNrYWdlRmlsZSA9IG51bGw7XG4gICAgfVxuICB9XG5cbiAgaWYgKCFwYWNrYWdlRmlsZSkge1xuICAgIHBhY2thZ2VGaWxlID0gZmluZChwcm9jZXNzLmN3ZCgpKTtcbiAgfVxuXG4gIGlmICghcGFja2FnZUZpbGUpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHZhciBjb250ZW50ID0gZnMucmVhZEZpbGVTeW5jKHBhY2thZ2VGaWxlLCAndXRmLTgnKTtcbiAgdmFyIHBhY2thZ2VEYXRhID0gSlNPTi5wYXJzZShjb250ZW50KTtcblxuICAvL25vaW5zcGVjdGlvbiBKU1VucmVzb2x2ZWRWYXJpYWJsZVxuICByZXR1cm4gcGFja2FnZURhdGEgPyBwYWNrYWdlRGF0YS5wcm9kdWN0TmFtZSB8fCBwYWNrYWdlRGF0YS5uYW1lIDogZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGZpbmQocm9vdCkge1xuICB2YXIgZmlsZTtcblxuICB3aGlsZSAoIWZpbGUpIHtcbiAgICB2YXIgcGFyZW50O1xuICAgIGZpbGUgPSBwYXRoLmpvaW4ocm9vdCwgJ3BhY2thZ2UuanNvbicpO1xuXG4gICAgdHJ5IHtcbiAgICAgIGZzLnN0YXRTeW5jKGZpbGUpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHBhcmVudCA9IHBhdGgucmVzb2x2ZShyb290LCAnLi4nKTtcbiAgICAgIGZpbGUgPSBudWxsO1xuICAgIH1cblxuICAgIGlmIChyb290ID09PSBwYXJlbnQpIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIHJvb3QgPSBwYXJlbnQ7XG4gIH1cblxuICByZXR1cm4gZmlsZTtcbn1cblxuZnVuY3Rpb24gd2FybihtZXNzYWdlKSB7XG4gIGNvbnNvbGVUcmFuc3BvcnQoe1xuICAgIGRhdGE6IFttZXNzYWdlXSxcbiAgICBkYXRlOiBuZXcgRGF0ZSgpLFxuICAgIGxldmVsOiAnd2FybidcbiAgfSk7XG59XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2VsZWN0cm9uLWxvZy9saWIvdHJhbnNwb3J0cy9maWxlL2dldC1hcHAtbmFtZS5qcyIsIi8vIGpzaGludCAtVzA3NCwgLVcwODlcbid1c2Ugc3RyaWN0JztcblxudmFyIGh0dHAgID0gcmVxdWlyZSgnaHR0cCcpO1xudmFyIGh0dHBzID0gcmVxdWlyZSgnaHR0cHMnKTtcbnZhciB1cmwgICA9IHJlcXVpcmUoJ3VybCcpO1xuXG50cmFuc3BvcnQuY2xpZW50ID0geyBuYW1lOiAnZWxlY3Ryb24tYXBwbGljYXRpb24nIH07XG50cmFuc3BvcnQuZGVwdGggID0gNjtcbnRyYW5zcG9ydC5sZXZlbCAgPSBmYWxzZTtcbnRyYW5zcG9ydC51cmwgICAgPSBudWxsO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHRyYW5zcG9ydDtcblxuZnVuY3Rpb24gdHJhbnNwb3J0KG1zZykge1xuICBpZiAoIXRyYW5zcG9ydC51cmwpIHJldHVybjtcblxuICB2YXIgZGF0YSA9IGpzb25EZXB0aCh7XG4gICAgY2xpZW50OiB0cmFuc3BvcnQuY2xpZW50LFxuICAgIGRhdGE6IG1zZy5kYXRhLFxuICAgIGRhdGU6IG1zZy5kYXRlLmdldFRpbWUoKSxcbiAgICBsZXZlbDogbXNnLmxldmVsXG4gIH0sIHRyYW5zcG9ydC5kZXB0aCArIDEpO1xuXG4gIHBvc3QodHJhbnNwb3J0LnVybCwgZGF0YSk7XG59XG5cbmZ1bmN0aW9uIHBvc3Qoc2VydmVyVXJsLCBkYXRhKSB7XG4gIHZhciB1cmxPYmplY3QgPSB1cmwucGFyc2Uoc2VydmVyVXJsKTtcbiAgdmFyIHRyYW5zcG9ydCA9IHVybE9iamVjdC5wcm90b2NvbCA9PT0gJ2h0dHBzOicgPyBodHRwcyA6IGh0dHA7XG5cbiAgdmFyIGJvZHkgPSBKU09OLnN0cmluZ2lmeShkYXRhKTtcblxuICB2YXIgb3B0aW9ucyA9IHtcbiAgICBob3N0bmFtZTogdXJsT2JqZWN0Lmhvc3RuYW1lLFxuICAgIHBvcnQ6ICAgICB1cmxPYmplY3QucG9ydCxcbiAgICBwYXRoOiAgICAgdXJsT2JqZWN0LnBhdGgsXG4gICAgbWV0aG9kOiAgICdQT1NUJyxcbiAgICBoZWFkZXJzOiAge1xuICAgICAgJ0NvbnRlbnQtVHlwZSc6ICAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAnQ29udGVudC1MZW5ndGgnOiBib2R5Lmxlbmd0aFxuICAgIH1cbiAgfTtcblxuICB2YXIgcmVxdWVzdCA9IHRyYW5zcG9ydC5yZXF1ZXN0KG9wdGlvbnMpO1xuICByZXF1ZXN0LndyaXRlKGJvZHkpO1xuICByZXF1ZXN0LmVuZCgpO1xufVxuXG5mdW5jdGlvbiBqc29uRGVwdGgoanNvbiwgZGVwdGgpIHtcbiAgaWYgKGRlcHRoIDwgMSkge1xuICAgIGlmIChBcnJheS5pc0FycmF5KGpzb24pKSAgcmV0dXJuICdbYXJyYXldJztcbiAgICBpZiAodHlwZW9mIGpzb24gPT09ICdvYmplY3QnKSAgcmV0dXJuICdbb2JqZWN0XSc7XG4gICAgcmV0dXJuIGpzb247XG4gIH1cblxuICBpZiAoQXJyYXkuaXNBcnJheShqc29uKSkge1xuICAgIHJldHVybiBqc29uLm1hcChmdW5jdGlvbihjaGlsZCkge1xuICAgICAgcmV0dXJuIGpzb25EZXB0aChjaGlsZCwgZGVwdGggLSAxKTtcbiAgICB9KTtcbiAgfVxuXG4gIGlmIChqc29uICYmIHR5cGVvZiBqc29uLmdldE1vbnRoID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIGpzb247XG4gIH1cblxuICBpZiAoanNvbiA9PT0gbnVsbCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgaWYgKHR5cGVvZiBqc29uID09PSAnb2JqZWN0Jykge1xuICAgIGlmICh0eXBlb2YganNvbi50b0pTT04gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGpzb24gPSBqc29uLnRvSlNPTigpO1xuICAgIH1cblxuICAgIHZhciBuZXdKc29uID0ge307XG4gICAgZm9yICh2YXIgaSBpbiBqc29uKSB7XG4gICAgICAvL25vaW5zcGVjdGlvbiBKU1VuZmlsdGVyZWRGb3JJbkxvb3BcbiAgICAgIG5ld0pzb25baV0gPSBqc29uRGVwdGgoanNvbltpXSwgZGVwdGggLSAxKTtcbiAgICB9XG5cbiAgICByZXR1cm4gbmV3SnNvbjtcbiAgfVxuXG4gIHJldHVybiBqc29uO1xufVxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9lbGVjdHJvbi1sb2cvbGliL3RyYW5zcG9ydHMvbG9nLXMuanMiLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCJodHRwc1wiKTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyBleHRlcm5hbCBcImh0dHBzXCJcbi8vIG1vZHVsZSBpZCA9IDE5MVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIndXNlIHN0cmljdCc7XG5cbnZhciBCcm93c2VyV2luZG93O1xudHJ5IHtcbiAgQnJvd3NlcldpbmRvdyA9IHJlcXVpcmUoJ2VsZWN0cm9uJykuQnJvd3NlcldpbmRvdztcbn0gY2F0Y2ggKGUpIHtcbiAgQnJvd3NlcldpbmRvdyA9IG51bGw7XG59XG5cbnZhciBmb3JtYXQgPSByZXF1aXJlKCcuLi9mb3JtYXQnKTtcblxudHJhbnNwb3J0LmxldmVsICA9IEJyb3dzZXJXaW5kb3cgPyAnc2lsbHknIDogZmFsc2U7XG50cmFuc3BvcnQuZm9ybWF0ID0gJ1t7aH06e2l9OntzfS57bXN9XSB7dGV4dH0nO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHRyYW5zcG9ydDtcblxuZnVuY3Rpb24gdHJhbnNwb3J0KG1zZykge1xuICBpZiAoIUJyb3dzZXJXaW5kb3cpIHJldHVybjtcblxuICB2YXIgdGV4dCA9IGZvcm1hdC5mb3JtYXQobXNnLCB0cmFuc3BvcnQuZm9ybWF0KTtcbiAgQnJvd3NlcldpbmRvdy5nZXRBbGxXaW5kb3dzKCkuZm9yRWFjaChmdW5jdGlvbih3bmQpIHtcbiAgICB3bmQud2ViQ29udGVudHMuc2VuZCgnX19FTEVDVFJPTl9MT0dfUkVOREVSRVJfXycsIG1zZy5sZXZlbCwgdGV4dCk7XG4gIH0pO1xufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2VsZWN0cm9uLWxvZy9saWIvdHJhbnNwb3J0cy9yZW5kZXJlci1jb25zb2xlLmpzIiwibW9kdWxlLmV4cG9ydHMgPSB7XCJuYW1lXCI6XCJFTElUXCIsXCJ2ZXJzaW9uXCI6XCIwLjIuMFwiLFwiZGVzY3JpcHRpb25cIjpcIkVMSVQgLSBFdmUgTG9jYWwgSW50ZWwgVG9vbFwiLFwibWFpblwiOlwiZGlzdC9tYWluLmpzXCIsXCJyZXBvc2l0b3J5XCI6XCJnaXRAZ2l0aHViLmNvbTpTcXVhcmVoZWFkcy9FTElULmdpdFwiLFwiYXV0aG9yXCI6XCJPd2VuIFdvcmxleVwiLFwibGljZW5zZVwiOlwiKGMpIFNxdWFyZWhlYWRzIExURCAyMDE4XCIsXCJkZXZEZXBlbmRlbmNpZXNcIjp7XCJAdHlwZXMvY2hhaVwiOlwiXjQuMC44XCIsXCJAdHlwZXMvZWxlY3Ryb25cIjpcIl4xLjYuMTBcIixcIkB0eXBlcy9lbGVjdHJvbi1pcy1kZXZcIjpcIl4wLjMuMFwiLFwiQHR5cGVzL21hdGVyaWFsLXVpXCI6XCJeMC4xOC41XCIsXCJAdHlwZXMvbW9jaGFcIjpcIl4yLjIuNDRcIixcIkB0eXBlcy9tb2NrZXJ5XCI6XCJeMS40LjI5XCIsXCJAdHlwZXMvbm9kZVwiOlwiXjguMC41M1wiLFwiQHR5cGVzL3JlYWN0XCI6XCJeMTYuMC4yNVwiLFwiQHR5cGVzL3JlYWN0LWRvbVwiOlwiXjE2LjAuM1wiLFwiQHR5cGVzL3JlcXVlc3RcIjpcIl4yLjAuOFwiLFwiQHR5cGVzL3JlcXVlc3QtcHJvbWlzZS1uYXRpdmVcIjpcIl4xLjAuMTBcIixcIkB0eXBlcy9zaW5vblwiOlwiXjQuMS4wXCIsXCJAdHlwZXMvdXJsLXBhcnNlXCI6XCJeMS4xLjBcIixcIkB0eXBlcy94MmpzXCI6XCJeMy4xLjBcIixcImJhYmVsLWNvcmVcIjpcIl42LjI2LjBcIixcImJhYmVsLWxvYWRlclwiOlwiXjcuMS4yXCIsXCJiYWJlbC1wbHVnaW4tYWRkLW1vZHVsZS1leHBvcnRzXCI6XCJeMC4yLjFcIixcImJhYmVsLXBsdWdpbi10cmFuc2Zvcm0tcnVudGltZVwiOlwiXjYuMC4wXCIsXCJiYWJlbC1wcmVzZXQtZW52XCI6XCJeMS42LjFcIixcImJhYmVsLXByZXNldC1lczIwMTVcIjpcIl42LjI0LjFcIixcImJhYmVsLXByZXNldC1lczIwMTUtbm9kZVwiOlwiXjYuMS4xXCIsXCJiYWJlbC1wcmVzZXQtZXMyMDE1LW5vZGU1XCI6XCJeMS4yLjBcIixcImJhYmVsLXByZXNldC1yZWFjdFwiOlwiXjYuMjQuMVwiLFwiYmFiZWwtcHJlc2V0LXN0YWdlLTNcIjpcIl42LjI0LjFcIixcImJhYmVsLXByZXNldC10cy1ub2RlNi1ibHVlYmlyZFwiOlwiXjEuMC4xXCIsXCJjaGFpXCI6XCJeNC4xLjJcIixcImVsZWN0cm9uXCI6XCJeMS43LjlcIixcImVsZWN0cm9uLWJ1aWxkZXJcIjpcIl4xOS40Ni45XCIsXCJmYWtlLWluZGV4ZWRkYlwiOlwiXjIuMC4zXCIsXCJodG1sLXdlYnBhY2stcGx1Z2luXCI6XCJeMi4zMC4xXCIsXCJpZ25vcmUtc3R5bGVzXCI6XCJeNS4wLjFcIixcIm1vY2hhXCI6XCJeNC4wLjFcIixcIm1vY2tlcnlcIjpcIl4yLjEuMFwiLFwibm9kZS1ub29wXCI6XCJeMS4wLjBcIixcIm55Y1wiOlwiXjExLjMuMFwiLFwic2lub25cIjpcIl40LjEuM1wiLFwic3RhbmRhcmRcIjpcIl4xMC4wLjNcIixcInN0YW5kYXJkLWxvYWRlclwiOlwiXjYuMC4xXCIsXCJ0cy1sb2FkZXJcIjpcIl4zLjEuMVwiLFwidHMtbW9ja2l0b1wiOlwiXjIuMi43XCIsXCJ0cy1ub2RlXCI6XCJeMy4zLjBcIixcInRzbGludFwiOlwiXjUuOC4wXCIsXCJ0c2xpbnQtY29uZmlnLXN0YW5kYXJkXCI6XCJeNy4wLjBcIixcInRzbGludC1sb2FkZXJcIjpcIl4zLjUuM1wiLFwidHlwZXNjcmlwdFwiOlwiXjIuNi4yXCIsXCJ3ZWJwYWNrXCI6XCJeMy44LjFcIn0sXCJzY3JpcHRzXCI6e1wiYnVpbGRcIjpcIndlYnBhY2sgLS1jb25maWcgd2VicGFjay5jb25maWcuanNcIixcInByZXN0YXJ0XCI6XCJ5YXJuIHJ1biBidWlsZFwiLFwic3RhcnRcIjpcImVsZWN0cm9uIC5cIixcInRlc3RcIjpcInNldCBUU19OT0RFX1BST0pFQ1Q9dHNjb25maWcudGVzdC5qc29uJiZtb2NoYVwiLFwicGFja1wiOlwiZWxlY3Ryb24tYnVpbGRlciAtLWRpclwiLFwiZGlzdFwiOlwiZWxlY3Ryb24tYnVpbGRlclwiLFwiZGlzdC1hbGxcIjpcImVsZWN0cm9uLWJ1aWxkZXIgLW13bFwifSxcImRlcGVuZGVuY2llc1wiOntcImRleGllXCI6XCIyXCIsXCJlbGVjdHJvbi1nb29nbGUtYW5hbHl0aWNzXCI6XCJeMC4wLjI0XCIsXCJlbGVjdHJvbi1pcy1kZXZcIjpcIl4wLjMuMFwiLFwiZWxlY3Ryb24tbG9nXCI6XCJeMi4yLjEzXCIsXCJlbGVjdHJvbi11cGRhdGVyXCI6XCJeMi4xOC4yXCIsXCJldmUtb25saW5lLWVzaVwiOlwiIGh0dHBzOi8vZ2l0aHViLmNvbS9TcXVhcmVoZWFkcy9ldmUtb25saW5lLWVzaS9hcmNoaXZlL2RmNDQwZWZhMzk0ZTM2ZTA2M2E2NTkzYmVkZThkZDhkMjg1ZTExNzkudGFyLmd6XCIsXCJtYXRlcmlhbC11aVwiOlwiXjAuMjAuMFwiLFwibWF0ZXJpYWwtdWktaW1hZ2VcIjpcIl4yLjEuMVwiLFwicXVlcnlzdHJpbmdpZnlcIjpcIl4xLjAuMFwiLFwicmVhY3RcIjpcIl4xNi4yLjBcIixcInJlYWN0LWRvbVwiOlwiXjE2LjIuMFwiLFwicmVhY3QtZWxlY3Ryb24td2ViLXZpZXdcIjpcIl4yLjAuMVwiLFwicmVxdWVzdFwiOlwiXjIuODMuMFwiLFwidHlwZXNjcmlwdC1jb2xsZWN0aW9uc1wiOlwiXjEuMi41XCIsXCJ1cmwtcGFyc2VcIjpcIl4xLjIuMFwiLFwieDJqc1wiOlwiXjMuMS4xXCJ9LFwiYnVpbGRcIjp7XCJhcHBJZFwiOlwiaW8uc3F1YXJlaGVhZHMuZXZlLWludGVsXCIsXCJmaWxlc1wiOlwiLi9kaXN0LyoqLypcIixcImRpcmVjdG9yaWVzXCI6e1wib3V0cHV0XCI6XCJwYWNrYWdlZFwifSxcIm1hY1wiOntcImNhdGVnb3J5XCI6XCJwdWJsaWMuYXBwLWNhdGVnb3J5LnV0aWxpdGllc1wifX0sXCJwZWVyRGVwZW5kZW5jaWVzXCI6e319XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9wYWNrYWdlLmpzb25cbi8vIG1vZHVsZSBpZCA9IDE5M1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9