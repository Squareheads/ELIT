/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 69);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports) {

module.exports = require("path");

/***/ }),
/* 1 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var es5 = __webpack_require__(16);
var canEvaluate = typeof navigator == "undefined";

var errorObj = { e: {} };
var tryCatchTarget;
var globalObject = typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : undefined !== undefined ? undefined : null;

function tryCatcher() {
    try {
        var target = tryCatchTarget;
        tryCatchTarget = null;
        return target.apply(this, arguments);
    } catch (e) {
        errorObj.e = e;
        return errorObj;
    }
}
function tryCatch(fn) {
    tryCatchTarget = fn;
    return tryCatcher;
}

var inherits = function (Child, Parent) {
    var hasProp = {}.hasOwnProperty;

    function T() {
        this.constructor = Child;
        this.constructor$ = Parent;
        for (var propertyName in Parent.prototype) {
            if (hasProp.call(Parent.prototype, propertyName) && propertyName.charAt(propertyName.length - 1) !== "$") {
                this[propertyName + "$"] = Parent.prototype[propertyName];
            }
        }
    }
    T.prototype = Parent.prototype;
    Child.prototype = new T();
    return Child.prototype;
};

function isPrimitive(val) {
    return val == null || val === true || val === false || typeof val === "string" || typeof val === "number";
}

function isObject(value) {
    return typeof value === "function" || typeof value === "object" && value !== null;
}

function maybeWrapAsError(maybeError) {
    if (!isPrimitive(maybeError)) return maybeError;

    return new Error(safeToString(maybeError));
}

function withAppended(target, appendee) {
    var len = target.length;
    var ret = new Array(len + 1);
    var i;
    for (i = 0; i < len; ++i) {
        ret[i] = target[i];
    }
    ret[i] = appendee;
    return ret;
}

function getDataPropertyOrDefault(obj, key, defaultValue) {
    if (es5.isES5) {
        var desc = Object.getOwnPropertyDescriptor(obj, key);

        if (desc != null) {
            return desc.get == null && desc.set == null ? desc.value : defaultValue;
        }
    } else {
        return {}.hasOwnProperty.call(obj, key) ? obj[key] : undefined;
    }
}

function notEnumerableProp(obj, name, value) {
    if (isPrimitive(obj)) return obj;
    var descriptor = {
        value: value,
        configurable: true,
        enumerable: false,
        writable: true
    };
    es5.defineProperty(obj, name, descriptor);
    return obj;
}

function thrower(r) {
    throw r;
}

var inheritedDataKeys = function () {
    var excludedPrototypes = [Array.prototype, Object.prototype, Function.prototype];

    var isExcludedProto = function (val) {
        for (var i = 0; i < excludedPrototypes.length; ++i) {
            if (excludedPrototypes[i] === val) {
                return true;
            }
        }
        return false;
    };

    if (es5.isES5) {
        var getKeys = Object.getOwnPropertyNames;
        return function (obj) {
            var ret = [];
            var visitedKeys = Object.create(null);
            while (obj != null && !isExcludedProto(obj)) {
                var keys;
                try {
                    keys = getKeys(obj);
                } catch (e) {
                    return ret;
                }
                for (var i = 0; i < keys.length; ++i) {
                    var key = keys[i];
                    if (visitedKeys[key]) continue;
                    visitedKeys[key] = true;
                    var desc = Object.getOwnPropertyDescriptor(obj, key);
                    if (desc != null && desc.get == null && desc.set == null) {
                        ret.push(key);
                    }
                }
                obj = es5.getPrototypeOf(obj);
            }
            return ret;
        };
    } else {
        var hasProp = {}.hasOwnProperty;
        return function (obj) {
            if (isExcludedProto(obj)) return [];
            var ret = [];

            /*jshint forin:false */
            enumeration: for (var key in obj) {
                if (hasProp.call(obj, key)) {
                    ret.push(key);
                } else {
                    for (var i = 0; i < excludedPrototypes.length; ++i) {
                        if (hasProp.call(excludedPrototypes[i], key)) {
                            continue enumeration;
                        }
                    }
                    ret.push(key);
                }
            }
            return ret;
        };
    }
}();

var thisAssignmentPattern = /this\s*\.\s*\S+\s*=/;
function isClass(fn) {
    try {
        if (typeof fn === "function") {
            var keys = es5.names(fn.prototype);

            var hasMethods = es5.isES5 && keys.length > 1;
            var hasMethodsOtherThanConstructor = keys.length > 0 && !(keys.length === 1 && keys[0] === "constructor");
            var hasThisAssignmentAndStaticMethods = thisAssignmentPattern.test(fn + "") && es5.names(fn).length > 0;

            if (hasMethods || hasMethodsOtherThanConstructor || hasThisAssignmentAndStaticMethods) {
                return true;
            }
        }
        return false;
    } catch (e) {
        return false;
    }
}

function toFastProperties(obj) {
    /*jshint -W027,-W055,-W031*/
    function FakeConstructor() {}
    FakeConstructor.prototype = obj;
    var l = 8;
    while (l--) new FakeConstructor();
    return obj;
    eval(obj);
}

var rident = /^[a-z$_][a-z$_0-9]*$/i;
function isIdentifier(str) {
    return rident.test(str);
}

function filledRange(count, prefix, suffix) {
    var ret = new Array(count);
    for (var i = 0; i < count; ++i) {
        ret[i] = prefix + i + suffix;
    }
    return ret;
}

function safeToString(obj) {
    try {
        return obj + "";
    } catch (e) {
        return "[no string representation]";
    }
}

function isError(obj) {
    return obj instanceof Error || obj !== null && typeof obj === "object" && typeof obj.message === "string" && typeof obj.name === "string";
}

function markAsOriginatingFromRejection(e) {
    try {
        notEnumerableProp(e, "isOperational", true);
    } catch (ignore) {}
}

function originatesFromRejection(e) {
    if (e == null) return false;
    return e instanceof Error["__BluebirdErrorTypes__"].OperationalError || e["isOperational"] === true;
}

function canAttachTrace(obj) {
    return isError(obj) && es5.propertyIsWritable(obj, "stack");
}

var ensureErrorObject = function () {
    if (!("stack" in new Error())) {
        return function (value) {
            if (canAttachTrace(value)) return value;
            try {
                throw new Error(safeToString(value));
            } catch (err) {
                return err;
            }
        };
    } else {
        return function (value) {
            if (canAttachTrace(value)) return value;
            return new Error(safeToString(value));
        };
    }
}();

function classString(obj) {
    return {}.toString.call(obj);
}

function copyDescriptors(from, to, filter) {
    var keys = es5.names(from);
    for (var i = 0; i < keys.length; ++i) {
        var key = keys[i];
        if (filter(key)) {
            try {
                es5.defineProperty(to, key, es5.getDescriptor(from, key));
            } catch (ignore) {}
        }
    }
}

var asArray = function (v) {
    if (es5.isArray(v)) {
        return v;
    }
    return null;
};

if (typeof Symbol !== "undefined" && Symbol.iterator) {
    var ArrayFrom = typeof Array.from === "function" ? function (v) {
        return Array.from(v);
    } : function (v) {
        var ret = [];
        var it = v[Symbol.iterator]();
        var itResult;
        while (!(itResult = it.next()).done) {
            ret.push(itResult.value);
        }
        return ret;
    };

    asArray = function (v) {
        if (es5.isArray(v)) {
            return v;
        } else if (v != null && typeof v[Symbol.iterator] === "function") {
            return ArrayFrom(v);
        }
        return null;
    };
}

var isNode = typeof process !== "undefined" && classString(process).toLowerCase() === "[object process]";

var hasEnvVariables = typeof process !== "undefined" && typeof process.env !== "undefined";

function env(key) {
    return hasEnvVariables ? process.env[key] : undefined;
}

function getNativePromise() {
    if (typeof Promise === "function") {
        try {
            var promise = new Promise(function () {});
            if ({}.toString.call(promise) === "[object Promise]") {
                return Promise;
            }
        } catch (e) {}
    }
}

function domainBind(self, cb) {
    return self.bind(cb);
}

var ret = {
    isClass: isClass,
    isIdentifier: isIdentifier,
    inheritedDataKeys: inheritedDataKeys,
    getDataPropertyOrDefault: getDataPropertyOrDefault,
    thrower: thrower,
    isArray: es5.isArray,
    asArray: asArray,
    notEnumerableProp: notEnumerableProp,
    isPrimitive: isPrimitive,
    isObject: isObject,
    isError: isError,
    canEvaluate: canEvaluate,
    errorObj: errorObj,
    tryCatch: tryCatch,
    inherits: inherits,
    withAppended: withAppended,
    maybeWrapAsError: maybeWrapAsError,
    toFastProperties: toFastProperties,
    filledRange: filledRange,
    toString: safeToString,
    canAttachTrace: canAttachTrace,
    ensureErrorObject: ensureErrorObject,
    originatesFromRejection: originatesFromRejection,
    markAsOriginatingFromRejection: markAsOriginatingFromRejection,
    classString: classString,
    copyDescriptors: copyDescriptors,
    hasDevTools: typeof chrome !== "undefined" && chrome && typeof chrome.loadTimes === "function",
    isNode: isNode,
    hasEnvVariables: hasEnvVariables,
    env: env,
    global: globalObject,
    getNativePromise: getNativePromise,
    domainBind: domainBind
};
ret.isRecentNode = ret.isNode && function () {
    var version = process.versions.node.split(".").map(Number);
    return version[0] === 0 && version[1] > 10 || version[0] > 0;
}();

if (ret.isNode) ret.toFastProperties(process);

try {
    throw new Error();
} catch (e) {
    ret.lastLineError = e;
}
module.exports = ret;

/***/ }),
/* 2 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const BluebirdPromise = __webpack_require__(70)();
BluebirdPromise.config({
  longStackTraces: true
});
BluebirdPromise.default = BluebirdPromise;
module.exports = BluebirdPromise;

/***/ }),
/* 3 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _CancellationToken;

function _load_CancellationToken() {
    return _CancellationToken = __webpack_require__(40);
}

Object.defineProperty(exports, "CancellationToken", {
    enumerable: true,
    get: function () {
        return (_CancellationToken || _load_CancellationToken()).CancellationToken;
    }
});
Object.defineProperty(exports, "CancellationError", {
    enumerable: true,
    get: function () {
        return (_CancellationToken || _load_CancellationToken()).CancellationError;
    }
});

var _httpExecutor;

function _load_httpExecutor() {
    return _httpExecutor = __webpack_require__(42);
}

Object.defineProperty(exports, "HttpError", {
    enumerable: true,
    get: function () {
        return (_httpExecutor || _load_httpExecutor()).HttpError;
    }
});
Object.defineProperty(exports, "createHttpError", {
    enumerable: true,
    get: function () {
        return (_httpExecutor || _load_httpExecutor()).createHttpError;
    }
});
Object.defineProperty(exports, "HttpExecutor", {
    enumerable: true,
    get: function () {
        return (_httpExecutor || _load_httpExecutor()).HttpExecutor;
    }
});
Object.defineProperty(exports, "DigestTransform", {
    enumerable: true,
    get: function () {
        return (_httpExecutor || _load_httpExecutor()).DigestTransform;
    }
});
Object.defineProperty(exports, "safeGetHeader", {
    enumerable: true,
    get: function () {
        return (_httpExecutor || _load_httpExecutor()).safeGetHeader;
    }
});
Object.defineProperty(exports, "configureRequestOptions", {
    enumerable: true,
    get: function () {
        return (_httpExecutor || _load_httpExecutor()).configureRequestOptions;
    }
});
Object.defineProperty(exports, "configureRequestOptionsFromUrl", {
    enumerable: true,
    get: function () {
        return (_httpExecutor || _load_httpExecutor()).configureRequestOptionsFromUrl;
    }
});
Object.defineProperty(exports, "safeStringifyJson", {
    enumerable: true,
    get: function () {
        return (_httpExecutor || _load_httpExecutor()).safeStringifyJson;
    }
});
Object.defineProperty(exports, "parseJson", {
    enumerable: true,
    get: function () {
        return (_httpExecutor || _load_httpExecutor()).parseJson;
    }
});

var _publishOptions;

function _load_publishOptions() {
    return _publishOptions = __webpack_require__(131);
}

Object.defineProperty(exports, "getS3LikeProviderBaseUrl", {
    enumerable: true,
    get: function () {
        return (_publishOptions || _load_publishOptions()).getS3LikeProviderBaseUrl;
    }
});
Object.defineProperty(exports, "githubUrl", {
    enumerable: true,
    get: function () {
        return (_publishOptions || _load_publishOptions()).githubUrl;
    }
});

var _rfc2253Parser;

function _load_rfc2253Parser() {
    return _rfc2253Parser = __webpack_require__(132);
}

Object.defineProperty(exports, "parseDn", {
    enumerable: true,
    get: function () {
        return (_rfc2253Parser || _load_rfc2253Parser()).parseDn;
    }
});

var _uuid;

function _load_uuid() {
    return _uuid = __webpack_require__(133);
}

Object.defineProperty(exports, "UUID", {
    enumerable: true,
    get: function () {
        return (_uuid || _load_uuid()).UUID;
    }
});

var _ProgressCallbackTransform;

function _load_ProgressCallbackTransform() {
    return _ProgressCallbackTransform = __webpack_require__(52);
}

Object.defineProperty(exports, "ProgressCallbackTransform", {
    enumerable: true,
    get: function () {
        return (_ProgressCallbackTransform || _load_ProgressCallbackTransform()).ProgressCallbackTransform;
    }
});

var _xml;

function _load_xml() {
    return _xml = __webpack_require__(134);
}

Object.defineProperty(exports, "parseXml", {
    enumerable: true,
    get: function () {
        return (_xml || _load_xml()).parseXml;
    }
});
Object.defineProperty(exports, "XElement", {
    enumerable: true,
    get: function () {
        return (_xml || _load_xml()).XElement;
    }
});
exports.asArray = asArray;
exports.newError = newError;
function asArray(v) {
    if (v == null) {
        return [];
    } else if (Array.isArray(v)) {
        return v;
    } else {
        return [v];
    }
}
function newError(message, code) {
    const error = new Error(message);
    error.code = code;
    return error;
}
//# sourceMappingURL=index.js.map

/***/ }),
/* 4 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var YAMLException = __webpack_require__(21);

var TYPE_CONSTRUCTOR_OPTIONS = ['kind', 'resolve', 'construct', 'instanceOf', 'predicate', 'represent', 'defaultStyle', 'styleAliases'];

var YAML_NODE_KINDS = ['scalar', 'sequence', 'mapping'];

function compileStyleAliases(map) {
  var result = {};

  if (map !== null) {
    Object.keys(map).forEach(function (style) {
      map[style].forEach(function (alias) {
        result[String(alias)] = style;
      });
    });
  }

  return result;
}

function Type(tag, options) {
  options = options || {};

  Object.keys(options).forEach(function (name) {
    if (TYPE_CONSTRUCTOR_OPTIONS.indexOf(name) === -1) {
      throw new YAMLException('Unknown option "' + name + '" is met in definition of "' + tag + '" YAML type.');
    }
  });

  // TODO: Add tag format check.
  this.tag = tag;
  this.kind = options['kind'] || null;
  this.resolve = options['resolve'] || function () {
    return true;
  };
  this.construct = options['construct'] || function (data) {
    return data;
  };
  this.instanceOf = options['instanceOf'] || null;
  this.predicate = options['predicate'] || null;
  this.represent = options['represent'] || null;
  this.defaultStyle = options['defaultStyle'] || null;
  this.styleAliases = compileStyleAliases(options['styleAliases'] || null);

  if (YAML_NODE_KINDS.indexOf(this.kind) === -1) {
    throw new YAMLException('Unknown kind "' + this.kind + '" is specified for "' + tag + '" YAML type.');
  }
}

module.exports = Type;

/***/ }),
/* 5 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var fs = __webpack_require__(12);
var polyfills = __webpack_require__(109);
var legacy = __webpack_require__(111);
var queue = [];

var util = __webpack_require__(29);

function noop() {}

var debug = noop;
if (util.debuglog) debug = util.debuglog('gfs4');else if (/\bgfs4\b/i.test(process.env.NODE_DEBUG || '')) debug = function () {
  var m = util.format.apply(util, arguments);
  m = 'GFS4: ' + m.split(/\n/).join('\nGFS4: ');
  console.error(m);
};

if (/\bgfs4\b/i.test(process.env.NODE_DEBUG || '')) {
  process.on('exit', function () {
    debug(queue);
    __webpack_require__(46).equal(queue.length, 0);
  });
}

module.exports = patch(__webpack_require__(45));
if (process.env.TEST_GRACEFUL_FS_GLOBAL_PATCH) {
  module.exports = patch(fs);
}

// Always patch fs.close/closeSync, because we want to
// retry() whenever a close happens *anywhere* in the program.
// This is essential when multiple graceful-fs instances are
// in play at the same time.
module.exports.close = fs.close = function (fs$close) {
  return function (fd, cb) {
    return fs$close.call(fs, fd, function (err) {
      if (!err) retry();

      if (typeof cb === 'function') cb.apply(this, arguments);
    });
  };
}(fs.close);

module.exports.closeSync = fs.closeSync = function (fs$closeSync) {
  return function (fd) {
    // Note that graceful-fs also retries when fs.closeSync() fails.
    // Looks like a bug to me, although it's probably a harmless one.
    var rval = fs$closeSync.apply(fs, arguments);
    retry();
    return rval;
  };
}(fs.closeSync);

function patch(fs) {
  // Everything that references the open() function needs to be in here
  polyfills(fs);
  fs.gracefulify = patch;
  fs.FileReadStream = ReadStream; // Legacy name.
  fs.FileWriteStream = WriteStream; // Legacy name.
  fs.createReadStream = createReadStream;
  fs.createWriteStream = createWriteStream;
  var fs$readFile = fs.readFile;
  fs.readFile = readFile;
  function readFile(path, options, cb) {
    if (typeof options === 'function') cb = options, options = null;

    return go$readFile(path, options, cb);

    function go$readFile(path, options, cb) {
      return fs$readFile(path, options, function (err) {
        if (err && (err.code === 'EMFILE' || err.code === 'ENFILE')) enqueue([go$readFile, [path, options, cb]]);else {
          if (typeof cb === 'function') cb.apply(this, arguments);
          retry();
        }
      });
    }
  }

  var fs$writeFile = fs.writeFile;
  fs.writeFile = writeFile;
  function writeFile(path, data, options, cb) {
    if (typeof options === 'function') cb = options, options = null;

    return go$writeFile(path, data, options, cb);

    function go$writeFile(path, data, options, cb) {
      return fs$writeFile(path, data, options, function (err) {
        if (err && (err.code === 'EMFILE' || err.code === 'ENFILE')) enqueue([go$writeFile, [path, data, options, cb]]);else {
          if (typeof cb === 'function') cb.apply(this, arguments);
          retry();
        }
      });
    }
  }

  var fs$appendFile = fs.appendFile;
  if (fs$appendFile) fs.appendFile = appendFile;
  function appendFile(path, data, options, cb) {
    if (typeof options === 'function') cb = options, options = null;

    return go$appendFile(path, data, options, cb);

    function go$appendFile(path, data, options, cb) {
      return fs$appendFile(path, data, options, function (err) {
        if (err && (err.code === 'EMFILE' || err.code === 'ENFILE')) enqueue([go$appendFile, [path, data, options, cb]]);else {
          if (typeof cb === 'function') cb.apply(this, arguments);
          retry();
        }
      });
    }
  }

  var fs$readdir = fs.readdir;
  fs.readdir = readdir;
  function readdir(path, options, cb) {
    var args = [path];
    if (typeof options !== 'function') {
      args.push(options);
    } else {
      cb = options;
    }
    args.push(go$readdir$cb);

    return go$readdir(args);

    function go$readdir$cb(err, files) {
      if (files && files.sort) files.sort();

      if (err && (err.code === 'EMFILE' || err.code === 'ENFILE')) enqueue([go$readdir, [args]]);else {
        if (typeof cb === 'function') cb.apply(this, arguments);
        retry();
      }
    }
  }

  function go$readdir(args) {
    return fs$readdir.apply(fs, args);
  }

  if (process.version.substr(0, 4) === 'v0.8') {
    var legStreams = legacy(fs);
    ReadStream = legStreams.ReadStream;
    WriteStream = legStreams.WriteStream;
  }

  var fs$ReadStream = fs.ReadStream;
  ReadStream.prototype = Object.create(fs$ReadStream.prototype);
  ReadStream.prototype.open = ReadStream$open;

  var fs$WriteStream = fs.WriteStream;
  WriteStream.prototype = Object.create(fs$WriteStream.prototype);
  WriteStream.prototype.open = WriteStream$open;

  fs.ReadStream = ReadStream;
  fs.WriteStream = WriteStream;

  function ReadStream(path, options) {
    if (this instanceof ReadStream) return fs$ReadStream.apply(this, arguments), this;else return ReadStream.apply(Object.create(ReadStream.prototype), arguments);
  }

  function ReadStream$open() {
    var that = this;
    open(that.path, that.flags, that.mode, function (err, fd) {
      if (err) {
        if (that.autoClose) that.destroy();

        that.emit('error', err);
      } else {
        that.fd = fd;
        that.emit('open', fd);
        that.read();
      }
    });
  }

  function WriteStream(path, options) {
    if (this instanceof WriteStream) return fs$WriteStream.apply(this, arguments), this;else return WriteStream.apply(Object.create(WriteStream.prototype), arguments);
  }

  function WriteStream$open() {
    var that = this;
    open(that.path, that.flags, that.mode, function (err, fd) {
      if (err) {
        that.destroy();
        that.emit('error', err);
      } else {
        that.fd = fd;
        that.emit('open', fd);
      }
    });
  }

  function createReadStream(path, options) {
    return new ReadStream(path, options);
  }

  function createWriteStream(path, options) {
    return new WriteStream(path, options);
  }

  var fs$open = fs.open;
  fs.open = open;
  function open(path, flags, mode, cb) {
    if (typeof mode === 'function') cb = mode, mode = null;

    return go$open(path, flags, mode, cb);

    function go$open(path, flags, mode, cb) {
      return fs$open(path, flags, mode, function (err, fd) {
        if (err && (err.code === 'EMFILE' || err.code === 'ENFILE')) enqueue([go$open, [path, flags, mode, cb]]);else {
          if (typeof cb === 'function') cb.apply(this, arguments);
          retry();
        }
      });
    }
  }

  return fs;
}

function enqueue(elem) {
  debug('ENQUEUE', elem[0].name, elem[1]);
  queue.push(elem);
}

function retry() {
  var elem = queue.shift();
  if (elem) {
    debug('RETRY', elem[0].name, elem[1]);
    elem[0].apply(null, elem[1]);
  }
}

/***/ }),
/* 6 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.fromCallback = function (fn) {
  return Object.defineProperty(function () {
    if (typeof arguments[arguments.length - 1] === 'function') fn.apply(this, arguments);else {
      return new Promise((resolve, reject) => {
        arguments[arguments.length] = (err, res) => {
          if (err) return reject(err);
          resolve(res);
        };
        arguments.length++;
        fn.apply(this, arguments);
      });
    }
  }, 'name', { value: fn.name });
};

exports.fromPromise = function (fn) {
  return Object.defineProperty(function () {
    const cb = arguments[arguments.length - 1];
    if (typeof cb !== 'function') return fn.apply(this, arguments);else fn.apply(this, arguments).then(r => cb(null, r), cb);
  }, 'name', { value: fn.name });
};

/***/ }),
/* 7 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const u = __webpack_require__(6).fromCallback;
const mkdirs = u(__webpack_require__(113));
const mkdirsSync = __webpack_require__(114);

module.exports = {
  mkdirs: mkdirs,
  mkdirsSync: mkdirsSync,
  // alias
  mkdirp: mkdirs,
  mkdirpSync: mkdirsSync,
  ensureDir: mkdirs,
  ensureDirSync: mkdirsSync
};

/***/ }),
/* 8 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.UpdaterSignal = exports.UPDATE_DOWNLOADED = exports.DOWNLOAD_PROGRESS = exports.Provider = exports.CancellationToken = exports.NoOpLogger = exports.AppUpdater = undefined;

var _AppUpdater;

function _load_AppUpdater() {
    return _AppUpdater = __webpack_require__(27);
}

Object.defineProperty(exports, "AppUpdater", {
    enumerable: true,
    get: function () {
        return (_AppUpdater || _load_AppUpdater()).AppUpdater;
    }
});
Object.defineProperty(exports, "NoOpLogger", {
    enumerable: true,
    get: function () {
        return (_AppUpdater || _load_AppUpdater()).NoOpLogger;
    }
});

var _builderUtilRuntime;

function _load_builderUtilRuntime() {
    return _builderUtilRuntime = __webpack_require__(3);
}

Object.defineProperty(exports, "CancellationToken", {
    enumerable: true,
    get: function () {
        return (_builderUtilRuntime || _load_builderUtilRuntime()).CancellationToken;
    }
});

var _Provider;

function _load_Provider() {
    return _Provider = __webpack_require__(14);
}

Object.defineProperty(exports, "Provider", {
    enumerable: true,
    get: function () {
        return (_Provider || _load_Provider()).Provider;
    }
});
exports.getDefaultChannelName = getDefaultChannelName;
exports.getCustomChannelName = getCustomChannelName;
exports.getCurrentPlatform = getCurrentPlatform;
exports.isUseOldMacProvider = isUseOldMacProvider;
exports.getChannelFilename = getChannelFilename;
exports.newBaseUrl = newBaseUrl;
exports.newUrlFromBase = newUrlFromBase;

var _url;

function _load_url() {
    return _url = __webpack_require__(20);
}

// autoUpdater to mimic electron bundled autoUpdater
let _autoUpdater;
function _load_autoUpdater() {
    // tslint:disable:prefer-conditional-expression
    if (process.platform === "win32") {
        _autoUpdater = new (__webpack_require__(174).NsisUpdater)();
    } else if (process.platform === "darwin") {
        _autoUpdater = new (__webpack_require__(181).MacUpdater)();
    } else {
        _autoUpdater = new (__webpack_require__(182).AppImageUpdater)();
    }
    return _autoUpdater;
}
Object.defineProperty(exports, "autoUpdater", {
    enumerable: true,
    get: () => {
        return _autoUpdater || _load_autoUpdater();
    }
});
// due to historical reasons for windows we use channel name without platform specifier
function getDefaultChannelName() {
    return `latest${getChannelFilePrefix()}`;
}
function getChannelFilePrefix() {
    const currentPlatform = getCurrentPlatform();
    if (currentPlatform === "linux") {
        const arch = process.env.TEST_UPDATER_ARCH || process.arch;
        const archSuffix = arch === "x64" ? "" : `-${arch}`;
        return "-linux" + archSuffix;
    } else {
        return currentPlatform === "darwin" ? "-mac" : "";
    }
}
function getCustomChannelName(channel) {
    return `${channel}${getChannelFilePrefix()}`;
}
function getCurrentPlatform() {
    return process.env.TEST_UPDATER_PLATFORM || process.platform;
}
function isUseOldMacProvider() {
    // getCurrentPlatform() === "darwin"
    return false;
}
function getChannelFilename(channel) {
    return `${channel}.yml`;
}
const DOWNLOAD_PROGRESS = exports.DOWNLOAD_PROGRESS = "download-progress";
const UPDATE_DOWNLOADED = exports.UPDATE_DOWNLOADED = "update-downloaded";
class UpdaterSignal {
    constructor(emitter) {
        this.emitter = emitter;
    }
    /**
     * Emitted when an authenticating proxy is [asking for user credentials](https://github.com/electron/electron/blob/master/docs/api/client-request.md#event-login).
     */
    login(handler) {
        addHandler(this.emitter, "login", handler);
    }
    progress(handler) {
        addHandler(this.emitter, DOWNLOAD_PROGRESS, handler);
    }
    updateDownloaded(handler) {
        addHandler(this.emitter, UPDATE_DOWNLOADED, handler);
    }
    updateCancelled(handler) {
        addHandler(this.emitter, "update-cancelled", handler);
    }
}
exports.UpdaterSignal = UpdaterSignal;
const isLogEvent = false;
function addHandler(emitter, event, handler) {
    if (isLogEvent) {
        emitter.on(event, (...args) => {
            console.log("%s %s", event, args);
            handler.apply(null, args);
        });
    } else {
        emitter.on(event, handler);
    }
}
// if baseUrl path doesn't ends with /, this path will be not prepended to passed pathname for new URL(input, base)
/** @internal */
function newBaseUrl(url) {
    const result = new (_url || _load_url()).URL(url);
    if (!result.pathname.endsWith("/")) {
        result.pathname += "/";
    }
    return result;
}
/** @internal */
function newUrlFromBase(pathname, baseUrl) {
    const result = new (_url || _load_url()).URL(pathname, baseUrl);
    // search is not propagated
    if (!result.search && baseUrl.search) {
        result.search = baseUrl.search;
    }
    return result;
}
//# sourceMappingURL=main.js.map

/***/ }),
/* 9 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const fsExtra = __webpack_require__(107);
const Promise = __webpack_require__(2);

function makeFs(Promise) {
  const fs = Object.create(null);

  for (const methodName of Object.keys(fsExtra)) {
    const method = fsExtra[methodName];
    if (methodName === "createFile" || methodName === "mkdirp") {
      continue;
    }

    if (typeof method !== "function" || methodName.endsWith("Sync") || methodName.endsWith("Stream") || methodName.match(/^[A-Z]/) || methodName === "exists" || methodName === "watch" || methodName === "watchFile" || methodName === "unwatchFile") {
      fs[methodName] = method;
    } else {
      fs[methodName] = Promise.promisify(method);
    }
  }

  fs.createFile = fs.ensureFile;
  fs.mkdirp = fs.mkdirs;
  return fs;
}

module.exports = makeFs(Promise);

/***/ }),
/* 10 */
/***/ (function(module, exports) {

module.exports = require("electron");

/***/ }),
/* 11 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var es5 = __webpack_require__(16);
var Objectfreeze = es5.freeze;
var util = __webpack_require__(1);
var inherits = util.inherits;
var notEnumerableProp = util.notEnumerableProp;

function subError(nameProperty, defaultMessage) {
    function SubError(message) {
        if (!(this instanceof SubError)) return new SubError(message);
        notEnumerableProp(this, "message", typeof message === "string" ? message : defaultMessage);
        notEnumerableProp(this, "name", nameProperty);
        if (Error.captureStackTrace) {
            Error.captureStackTrace(this, this.constructor);
        } else {
            Error.call(this);
        }
    }
    inherits(SubError, Error);
    return SubError;
}

var _TypeError, _RangeError;
var Warning = subError("Warning", "warning");
var CancellationError = subError("CancellationError", "cancellation error");
var TimeoutError = subError("TimeoutError", "timeout error");
var AggregateError = subError("AggregateError", "aggregate error");
try {
    _TypeError = TypeError;
    _RangeError = RangeError;
} catch (e) {
    _TypeError = subError("TypeError", "type error");
    _RangeError = subError("RangeError", "range error");
}

var methods = ("join pop push shift unshift slice filter forEach some " + "every map indexOf lastIndexOf reduce reduceRight sort reverse").split(" ");

for (var i = 0; i < methods.length; ++i) {
    if (typeof Array.prototype[methods[i]] === "function") {
        AggregateError.prototype[methods[i]] = Array.prototype[methods[i]];
    }
}

es5.defineProperty(AggregateError.prototype, "length", {
    value: 0,
    configurable: false,
    writable: true,
    enumerable: true
});
AggregateError.prototype["isOperational"] = true;
var level = 0;
AggregateError.prototype.toString = function () {
    var indent = Array(level * 4 + 1).join(" ");
    var ret = "\n" + indent + "AggregateError of:" + "\n";
    level++;
    indent = Array(level * 4 + 1).join(" ");
    for (var i = 0; i < this.length; ++i) {
        var str = this[i] === this ? "[Circular AggregateError]" : this[i] + "";
        var lines = str.split("\n");
        for (var j = 0; j < lines.length; ++j) {
            lines[j] = indent + lines[j];
        }
        str = lines.join("\n");
        ret += str + "\n";
    }
    level--;
    return ret;
};

function OperationalError(message) {
    if (!(this instanceof OperationalError)) return new OperationalError(message);
    notEnumerableProp(this, "name", "OperationalError");
    notEnumerableProp(this, "message", message);
    this.cause = message;
    this["isOperational"] = true;

    if (message instanceof Error) {
        notEnumerableProp(this, "message", message.message);
        notEnumerableProp(this, "stack", message.stack);
    } else if (Error.captureStackTrace) {
        Error.captureStackTrace(this, this.constructor);
    }
}
inherits(OperationalError, Error);

var errorTypes = Error["__BluebirdErrorTypes__"];
if (!errorTypes) {
    errorTypes = Objectfreeze({
        CancellationError: CancellationError,
        TimeoutError: TimeoutError,
        OperationalError: OperationalError,
        RejectionError: OperationalError,
        AggregateError: AggregateError
    });
    es5.defineProperty(Error, "__BluebirdErrorTypes__", {
        value: errorTypes,
        writable: false,
        enumerable: false,
        configurable: false
    });
}

module.exports = {
    Error: Error,
    TypeError: _TypeError,
    RangeError: _RangeError,
    CancellationError: errorTypes.CancellationError,
    OperationalError: errorTypes.OperationalError,
    TimeoutError: errorTypes.TimeoutError,
    AggregateError: errorTypes.AggregateError,
    Warning: Warning
};

/***/ }),
/* 12 */
/***/ (function(module, exports) {

module.exports = require("fs");

/***/ }),
/* 13 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const u = __webpack_require__(6).fromPromise;
const fs = __webpack_require__(44);

function pathExists(path) {
  return fs.access(path).then(() => true).catch(() => false);
}

module.exports = {
  pathExists: u(pathExists),
  pathExistsSync: fs.existsSync
};

/***/ }),
/* 14 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Provider = undefined;
exports.findFile = findFile;
exports.parseUpdateInfo = parseUpdateInfo;
exports.getFileList = getFileList;
exports.resolveFiles = resolveFiles;

var _builderUtilRuntime;

function _load_builderUtilRuntime() {
    return _builderUtilRuntime = __webpack_require__(3);
}

var _jsYaml;

function _load_jsYaml() {
    return _jsYaml = __webpack_require__(31);
}

var _main;

function _load_main() {
    return _main = __webpack_require__(8);
}

class Provider {
    constructor(executor, useMultipleRangeRequest = true) {
        this.executor = executor;
        this.useMultipleRangeRequest = useMultipleRangeRequest;
    }
    get fileExtraDownloadHeaders() {
        return null;
    }
    setRequestHeaders(value) {
        this.requestHeaders = value;
    }
    httpRequest(url, headers, cancellationToken) {
        return this.executor.request(this.createRequestOptions(url, headers), cancellationToken);
    }
    createRequestOptions(url, headers) {
        const result = {};
        if (this.requestHeaders == null) {
            if (headers != null) {
                result.headers = headers;
            }
        } else {
            result.headers = headers == null ? this.requestHeaders : Object.assign({}, this.requestHeaders, headers);
        }
        result.protocol = url.protocol;
        result.hostname = url.hostname;
        if (url.port) {
            result.port = url.port;
        }
        result.path = url.pathname + url.search;
        return result;
    }
}
exports.Provider = Provider;
function findFile(files, extension, not) {
    if (files.length === 0) {
        throw (0, (_builderUtilRuntime || _load_builderUtilRuntime()).newError)("No files provided", "ERR_UPDATER_NO_FILES_PROVIDED");
    }
    const result = files.find(it => it.url.pathname.toLowerCase().endsWith(`.${extension}`));
    if (result != null) {
        return result;
    } else if (not == null) {
        return files[0];
    } else {
        return files.find(fileInfo => !not.some(ext => fileInfo.url.pathname.toLowerCase().endsWith(`.${ext}`)));
    }
}
function parseUpdateInfo(rawData, channelFile, channelFileUrl) {
    if (rawData == null) {
        throw (0, (_builderUtilRuntime || _load_builderUtilRuntime()).newError)(`Cannot parse update info from ${channelFile} in the latest release artifacts (${channelFileUrl}): rawData: null`, "ERR_UPDATER_INVALID_UPDATE_INFO");
    }
    let result;
    try {
        result = (0, (_jsYaml || _load_jsYaml()).safeLoad)(rawData);
    } catch (e) {
        throw (0, (_builderUtilRuntime || _load_builderUtilRuntime()).newError)(`Cannot parse update info from ${channelFile} in the latest release artifacts (${channelFileUrl}): ${e.stack || e.message}, rawData: ${rawData}`, "ERR_UPDATER_INVALID_UPDATE_INFO");
    }
    return result;
}
function getFileList(updateInfo) {
    const files = updateInfo.files;
    if (files != null && files.length > 0) {
        return files;
    }
    if (updateInfo.path != null) {
        return [{
            url: updateInfo.path,
            sha512: updateInfo.sha512
        }];
    } else {
        throw (0, (_builderUtilRuntime || _load_builderUtilRuntime()).newError)(`No files provided: ${(0, (_builderUtilRuntime || _load_builderUtilRuntime()).safeStringifyJson)(updateInfo)}`, "ERR_UPDATER_NO_FILES_PROVIDED");
    }
}
function resolveFiles(updateInfo, baseUrl, pathTransformer = p => p) {
    const files = getFileList(updateInfo);
    const result = files.map(fileInfo => {
        if (fileInfo.sha2 == null && fileInfo.sha512 == null) {
            throw (0, (_builderUtilRuntime || _load_builderUtilRuntime()).newError)(`Update info doesn't contain nor sha256 neither sha512 checksum: ${(0, (_builderUtilRuntime || _load_builderUtilRuntime()).safeStringifyJson)(fileInfo)}`, "ERR_UPDATER_NO_CHECKSUM");
        }
        return {
            url: (0, (_main || _load_main()).newUrlFromBase)(pathTransformer(fileInfo.url), baseUrl),
            info: fileInfo
        };
    });
    const packages = updateInfo.packages;
    const packageInfo = packages == null ? null : packages[process.arch] || packages.ia32;
    if (packageInfo != null) {
        result[0].packageInfo = Object.assign({}, packageInfo, { path: (0, (_main || _load_main()).newUrlFromBase)(pathTransformer(packageInfo.path), baseUrl).href });
    }
    return result;
}
//# sourceMappingURL=Provider.js.map

/***/ }),
/* 15 */
/***/ (function(module, exports) {

module.exports = require("os");

/***/ }),
/* 16 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var isES5 = function () {
    "use strict";

    return this === undefined;
}();

if (isES5) {
    module.exports = {
        freeze: Object.freeze,
        defineProperty: Object.defineProperty,
        getDescriptor: Object.getOwnPropertyDescriptor,
        keys: Object.keys,
        names: Object.getOwnPropertyNames,
        getPrototypeOf: Object.getPrototypeOf,
        isArray: Array.isArray,
        isES5: isES5,
        propertyIsWritable: function (obj, prop) {
            var descriptor = Object.getOwnPropertyDescriptor(obj, prop);
            return !!(!descriptor || descriptor.writable || descriptor.set);
        }
    };
} else {
    var has = {}.hasOwnProperty;
    var str = {}.toString;
    var proto = {}.constructor.prototype;

    var ObjectKeys = function (o) {
        var ret = [];
        for (var key in o) {
            if (has.call(o, key)) {
                ret.push(key);
            }
        }
        return ret;
    };

    var ObjectGetDescriptor = function (o, key) {
        return { value: o[key] };
    };

    var ObjectDefineProperty = function (o, key, desc) {
        o[key] = desc.value;
        return o;
    };

    var ObjectFreeze = function (obj) {
        return obj;
    };

    var ObjectGetPrototypeOf = function (obj) {
        try {
            return Object(obj).constructor.prototype;
        } catch (e) {
            return proto;
        }
    };

    var ArrayIsArray = function (obj) {
        try {
            return str.call(obj) === "[object Array]";
        } catch (e) {
            return false;
        }
    };

    module.exports = {
        isArray: ArrayIsArray,
        keys: ObjectKeys,
        names: ObjectKeys,
        defineProperty: ObjectDefineProperty,
        getDescriptor: ObjectGetDescriptor,
        freeze: ObjectFreeze,
        getPrototypeOf: ObjectGetPrototypeOf,
        isES5: isES5,
        propertyIsWritable: function () {
            return true;
        }
    };
}

/***/ }),
/* 17 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


function isNothing(subject) {
  return typeof subject === 'undefined' || subject === null;
}

function isObject(subject) {
  return typeof subject === 'object' && subject !== null;
}

function toArray(sequence) {
  if (Array.isArray(sequence)) return sequence;else if (isNothing(sequence)) return [];

  return [sequence];
}

function extend(target, source) {
  var index, length, key, sourceKeys;

  if (source) {
    sourceKeys = Object.keys(source);

    for (index = 0, length = sourceKeys.length; index < length; index += 1) {
      key = sourceKeys[index];
      target[key] = source[key];
    }
  }

  return target;
}

function repeat(string, count) {
  var result = '',
      cycle;

  for (cycle = 0; cycle < count; cycle += 1) {
    result += string;
  }

  return result;
}

function isNegativeZero(number) {
  return number === 0 && Number.NEGATIVE_INFINITY === 1 / number;
}

module.exports.isNothing = isNothing;
module.exports.isObject = isObject;
module.exports.toArray = toArray;
module.exports.repeat = repeat;
module.exports.isNegativeZero = isNegativeZero;
module.exports.extend = extend;

/***/ }),
/* 18 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/*eslint-disable max-len*/

var common = __webpack_require__(17);
var YAMLException = __webpack_require__(21);
var Type = __webpack_require__(4);

function compileList(schema, name, result) {
  var exclude = [];

  schema.include.forEach(function (includedSchema) {
    result = compileList(includedSchema, name, result);
  });

  schema[name].forEach(function (currentType) {
    result.forEach(function (previousType, previousIndex) {
      if (previousType.tag === currentType.tag && previousType.kind === currentType.kind) {
        exclude.push(previousIndex);
      }
    });

    result.push(currentType);
  });

  return result.filter(function (type, index) {
    return exclude.indexOf(index) === -1;
  });
}

function compileMap() /* lists... */{
  var result = {
    scalar: {},
    sequence: {},
    mapping: {},
    fallback: {}
  },
      index,
      length;

  function collectType(type) {
    result[type.kind][type.tag] = result['fallback'][type.tag] = type;
  }

  for (index = 0, length = arguments.length; index < length; index += 1) {
    arguments[index].forEach(collectType);
  }
  return result;
}

function Schema(definition) {
  this.include = definition.include || [];
  this.implicit = definition.implicit || [];
  this.explicit = definition.explicit || [];

  this.implicit.forEach(function (type) {
    if (type.loadKind && type.loadKind !== 'scalar') {
      throw new YAMLException('There is a non-scalar type in the implicit list of a schema. Implicit resolving of such types is not supported.');
    }
  });

  this.compiledImplicit = compileList(this, 'implicit', []);
  this.compiledExplicit = compileList(this, 'explicit', []);
  this.compiledTypeMap = compileMap(this.compiledImplicit, this.compiledExplicit);
}

Schema.DEFAULT = null;

Schema.create = function createSchema() {
  var schemas, types;

  switch (arguments.length) {
    case 1:
      schemas = Schema.DEFAULT;
      types = arguments[0];
      break;

    case 2:
      schemas = arguments[0];
      types = arguments[1];
      break;

    default:
      throw new YAMLException('Wrong number of arguments for Schema.create function');
  }

  schemas = common.toArray(schemas);
  types = common.toArray(types);

  if (!schemas.every(function (schema) {
    return schema instanceof Schema;
  })) {
    throw new YAMLException('Specified list of super schemas (or a single Schema object) contains a non-Schema object.');
  }

  if (!types.every(function (type) {
    return type instanceof Type;
  })) {
    throw new YAMLException('Specified list of YAML types (or a single Type object) contains a non-Type object.');
  }

  return new Schema({
    include: schemas,
    explicit: types
  });
};

module.exports = Schema;

/***/ }),
/* 19 */
/***/ (function(module, exports) {

module.exports = require("stream");

/***/ }),
/* 20 */
/***/ (function(module, exports) {

module.exports = require("url");

/***/ }),
/* 21 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// YAML error class. http://stackoverflow.com/questions/8458984
//


function YAMLException(reason, mark) {
  // Super constructor
  Error.call(this);

  this.name = 'YAMLException';
  this.reason = reason;
  this.mark = mark;
  this.message = (this.reason || '(unknown reason)') + (this.mark ? ' ' + this.mark.toString() : '');

  // Include stack trace in error object
  if (Error.captureStackTrace) {
    // Chrome and NodeJS
    Error.captureStackTrace(this, this.constructor);
  } else {
    // FF, IE 10+ and Safari 6+. Fallback for others
    this.stack = new Error().stack || '';
  }
}

// Inherit from Error
YAMLException.prototype = Object.create(Error.prototype);
YAMLException.prototype.constructor = YAMLException;

YAMLException.prototype.toString = function toString(compact) {
  var result = this.name + ': ';

  result += this.reason || '(unknown reason)';

  if (!compact && this.mark) {
    result += ' ' + this.mark.toString();
  }

  return result;
};

module.exports = YAMLException;

/***/ }),
/* 22 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// JS-YAML's default schema for `safeLoad` function.
// It is not described in the YAML specification.
//
// This schema is based on standard YAML's Core schema and includes most of
// extra types described at YAML tag repository. (http://yaml.org/type/)




var Schema = __webpack_require__(18);

module.exports = new Schema({
  include: [__webpack_require__(53)],
  implicit: [__webpack_require__(147), __webpack_require__(148)],
  explicit: [__webpack_require__(149), __webpack_require__(151), __webpack_require__(152), __webpack_require__(153)]
});

/***/ }),
/* 23 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/* -*- Mode: js; js-indent-level: 2; -*- */
/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */

/**
 * This is a helper function for getting values from parameter/options
 * objects.
 *
 * @param args The object we are extracting values from
 * @param name The name of the property we are getting.
 * @param defaultValue An optional value to return if the property is missing
 * from the object. If this is not specified and the property is missing, an
 * error will be thrown.
 */
function getArg(aArgs, aName, aDefaultValue) {
  if (aName in aArgs) {
    return aArgs[aName];
  } else if (arguments.length === 3) {
    return aDefaultValue;
  } else {
    throw new Error('"' + aName + '" is a required argument.');
  }
}
exports.getArg = getArg;

var urlRegexp = /^(?:([\w+\-.]+):)?\/\/(?:(\w+:\w+)@)?([\w.-]*)(?::(\d+))?(.*)$/;
var dataUrlRegexp = /^data:.+\,.+$/;

function urlParse(aUrl) {
  var match = aUrl.match(urlRegexp);
  if (!match) {
    return null;
  }
  return {
    scheme: match[1],
    auth: match[2],
    host: match[3],
    port: match[4],
    path: match[5]
  };
}
exports.urlParse = urlParse;

function urlGenerate(aParsedUrl) {
  var url = '';
  if (aParsedUrl.scheme) {
    url += aParsedUrl.scheme + ':';
  }
  url += '//';
  if (aParsedUrl.auth) {
    url += aParsedUrl.auth + '@';
  }
  if (aParsedUrl.host) {
    url += aParsedUrl.host;
  }
  if (aParsedUrl.port) {
    url += ":" + aParsedUrl.port;
  }
  if (aParsedUrl.path) {
    url += aParsedUrl.path;
  }
  return url;
}
exports.urlGenerate = urlGenerate;

/**
 * Normalizes a path, or the path portion of a URL:
 *
 * - Replaces consecutive slashes with one slash.
 * - Removes unnecessary '.' parts.
 * - Removes unnecessary '<dir>/..' parts.
 *
 * Based on code in the Node.js 'path' core module.
 *
 * @param aPath The path or url to normalize.
 */
function normalize(aPath) {
  var path = aPath;
  var url = urlParse(aPath);
  if (url) {
    if (!url.path) {
      return aPath;
    }
    path = url.path;
  }
  var isAbsolute = exports.isAbsolute(path);

  var parts = path.split(/\/+/);
  for (var part, up = 0, i = parts.length - 1; i >= 0; i--) {
    part = parts[i];
    if (part === '.') {
      parts.splice(i, 1);
    } else if (part === '..') {
      up++;
    } else if (up > 0) {
      if (part === '') {
        // The first part is blank if the path is absolute. Trying to go
        // above the root is a no-op. Therefore we can remove all '..' parts
        // directly after the root.
        parts.splice(i + 1, up);
        up = 0;
      } else {
        parts.splice(i, 2);
        up--;
      }
    }
  }
  path = parts.join('/');

  if (path === '') {
    path = isAbsolute ? '/' : '.';
  }

  if (url) {
    url.path = path;
    return urlGenerate(url);
  }
  return path;
}
exports.normalize = normalize;

/**
 * Joins two paths/URLs.
 *
 * @param aRoot The root path or URL.
 * @param aPath The path or URL to be joined with the root.
 *
 * - If aPath is a URL or a data URI, aPath is returned, unless aPath is a
 *   scheme-relative URL: Then the scheme of aRoot, if any, is prepended
 *   first.
 * - Otherwise aPath is a path. If aRoot is a URL, then its path portion
 *   is updated with the result and aRoot is returned. Otherwise the result
 *   is returned.
 *   - If aPath is absolute, the result is aPath.
 *   - Otherwise the two paths are joined with a slash.
 * - Joining for example 'http://' and 'www.example.com' is also supported.
 */
function join(aRoot, aPath) {
  if (aRoot === "") {
    aRoot = ".";
  }
  if (aPath === "") {
    aPath = ".";
  }
  var aPathUrl = urlParse(aPath);
  var aRootUrl = urlParse(aRoot);
  if (aRootUrl) {
    aRoot = aRootUrl.path || '/';
  }

  // `join(foo, '//www.example.org')`
  if (aPathUrl && !aPathUrl.scheme) {
    if (aRootUrl) {
      aPathUrl.scheme = aRootUrl.scheme;
    }
    return urlGenerate(aPathUrl);
  }

  if (aPathUrl || aPath.match(dataUrlRegexp)) {
    return aPath;
  }

  // `join('http://', 'www.example.com')`
  if (aRootUrl && !aRootUrl.host && !aRootUrl.path) {
    aRootUrl.host = aPath;
    return urlGenerate(aRootUrl);
  }

  var joined = aPath.charAt(0) === '/' ? aPath : normalize(aRoot.replace(/\/+$/, '') + '/' + aPath);

  if (aRootUrl) {
    aRootUrl.path = joined;
    return urlGenerate(aRootUrl);
  }
  return joined;
}
exports.join = join;

exports.isAbsolute = function (aPath) {
  return aPath.charAt(0) === '/' || urlRegexp.test(aPath);
};

/**
 * Make a path relative to a URL or another path.
 *
 * @param aRoot The root path or URL.
 * @param aPath The path or URL to be made relative to aRoot.
 */
function relative(aRoot, aPath) {
  if (aRoot === "") {
    aRoot = ".";
  }

  aRoot = aRoot.replace(/\/$/, '');

  // It is possible for the path to be above the root. In this case, simply
  // checking whether the root is a prefix of the path won't work. Instead, we
  // need to remove components from the root one by one, until either we find
  // a prefix that fits, or we run out of components to remove.
  var level = 0;
  while (aPath.indexOf(aRoot + '/') !== 0) {
    var index = aRoot.lastIndexOf("/");
    if (index < 0) {
      return aPath;
    }

    // If the only part of the root that is left is the scheme (i.e. http://,
    // file:///, etc.), one or more slashes (/), or simply nothing at all, we
    // have exhausted all components, so the path is not relative to the root.
    aRoot = aRoot.slice(0, index);
    if (aRoot.match(/^([^\/]+:\/)?\/*$/)) {
      return aPath;
    }

    ++level;
  }

  // Make sure we add a "../" for each component we removed from the root.
  return Array(level + 1).join("../") + aPath.substr(aRoot.length + 1);
}
exports.relative = relative;

var supportsNullProto = function () {
  var obj = Object.create(null);
  return !('__proto__' in obj);
}();

function identity(s) {
  return s;
}

/**
 * Because behavior goes wacky when you set `__proto__` on objects, we
 * have to prefix all the strings in our set with an arbitrary character.
 *
 * See https://github.com/mozilla/source-map/pull/31 and
 * https://github.com/mozilla/source-map/issues/30
 *
 * @param String aStr
 */
function toSetString(aStr) {
  if (isProtoString(aStr)) {
    return '$' + aStr;
  }

  return aStr;
}
exports.toSetString = supportsNullProto ? identity : toSetString;

function fromSetString(aStr) {
  if (isProtoString(aStr)) {
    return aStr.slice(1);
  }

  return aStr;
}
exports.fromSetString = supportsNullProto ? identity : fromSetString;

function isProtoString(s) {
  if (!s) {
    return false;
  }

  var length = s.length;

  if (length < 9 /* "__proto__".length */) {
      return false;
    }

  if (s.charCodeAt(length - 1) !== 95 /* '_' */ || s.charCodeAt(length - 2) !== 95 /* '_' */ || s.charCodeAt(length - 3) !== 111 /* 'o' */ || s.charCodeAt(length - 4) !== 116 /* 't' */ || s.charCodeAt(length - 5) !== 111 /* 'o' */ || s.charCodeAt(length - 6) !== 114 /* 'r' */ || s.charCodeAt(length - 7) !== 112 /* 'p' */ || s.charCodeAt(length - 8) !== 95 /* '_' */ || s.charCodeAt(length - 9) !== 95 /* '_' */) {
      return false;
    }

  for (var i = length - 10; i >= 0; i--) {
    if (s.charCodeAt(i) !== 36 /* '$' */) {
        return false;
      }
  }

  return true;
}

/**
 * Comparator between two mappings where the original positions are compared.
 *
 * Optionally pass in `true` as `onlyCompareGenerated` to consider two
 * mappings with the same original source/line/column, but different generated
 * line and column the same. Useful when searching for a mapping with a
 * stubbed out mapping.
 */
function compareByOriginalPositions(mappingA, mappingB, onlyCompareOriginal) {
  var cmp = strcmp(mappingA.source, mappingB.source);
  if (cmp !== 0) {
    return cmp;
  }

  cmp = mappingA.originalLine - mappingB.originalLine;
  if (cmp !== 0) {
    return cmp;
  }

  cmp = mappingA.originalColumn - mappingB.originalColumn;
  if (cmp !== 0 || onlyCompareOriginal) {
    return cmp;
  }

  cmp = mappingA.generatedColumn - mappingB.generatedColumn;
  if (cmp !== 0) {
    return cmp;
  }

  cmp = mappingA.generatedLine - mappingB.generatedLine;
  if (cmp !== 0) {
    return cmp;
  }

  return strcmp(mappingA.name, mappingB.name);
}
exports.compareByOriginalPositions = compareByOriginalPositions;

/**
 * Comparator between two mappings with deflated source and name indices where
 * the generated positions are compared.
 *
 * Optionally pass in `true` as `onlyCompareGenerated` to consider two
 * mappings with the same generated line and column, but different
 * source/name/original line and column the same. Useful when searching for a
 * mapping with a stubbed out mapping.
 */
function compareByGeneratedPositionsDeflated(mappingA, mappingB, onlyCompareGenerated) {
  var cmp = mappingA.generatedLine - mappingB.generatedLine;
  if (cmp !== 0) {
    return cmp;
  }

  cmp = mappingA.generatedColumn - mappingB.generatedColumn;
  if (cmp !== 0 || onlyCompareGenerated) {
    return cmp;
  }

  cmp = strcmp(mappingA.source, mappingB.source);
  if (cmp !== 0) {
    return cmp;
  }

  cmp = mappingA.originalLine - mappingB.originalLine;
  if (cmp !== 0) {
    return cmp;
  }

  cmp = mappingA.originalColumn - mappingB.originalColumn;
  if (cmp !== 0) {
    return cmp;
  }

  return strcmp(mappingA.name, mappingB.name);
}
exports.compareByGeneratedPositionsDeflated = compareByGeneratedPositionsDeflated;

function strcmp(aStr1, aStr2) {
  if (aStr1 === aStr2) {
    return 0;
  }

  if (aStr1 === null) {
    return 1; // aStr2 !== null
  }

  if (aStr2 === null) {
    return -1; // aStr1 !== null
  }

  if (aStr1 > aStr2) {
    return 1;
  }

  return -1;
}

/**
 * Comparator between two mappings with inflated source and name strings where
 * the generated positions are compared.
 */
function compareByGeneratedPositionsInflated(mappingA, mappingB) {
  var cmp = mappingA.generatedLine - mappingB.generatedLine;
  if (cmp !== 0) {
    return cmp;
  }

  cmp = mappingA.generatedColumn - mappingB.generatedColumn;
  if (cmp !== 0) {
    return cmp;
  }

  cmp = strcmp(mappingA.source, mappingB.source);
  if (cmp !== 0) {
    return cmp;
  }

  cmp = mappingA.originalLine - mappingB.originalLine;
  if (cmp !== 0) {
    return cmp;
  }

  cmp = mappingA.originalColumn - mappingB.originalColumn;
  if (cmp !== 0) {
    return cmp;
  }

  return strcmp(mappingA.name, mappingB.name);
}
exports.compareByGeneratedPositionsInflated = compareByGeneratedPositionsInflated;

/**
 * Strip any JSON XSSI avoidance prefix from the string (as documented
 * in the source maps specification), and then parse the string as
 * JSON.
 */
function parseSourceMapInput(str) {
  return JSON.parse(str.replace(/^\)]}'[^\n]*\n/, ''));
}
exports.parseSourceMapInput = parseSourceMapInput;

/**
 * Compute the URL of a source given the the source root, the source's
 * URL, and the source map's URL.
 */
function computeSourceURL(sourceRoot, sourceURL, sourceMapURL) {
  sourceURL = sourceURL || '';

  if (sourceRoot) {
    // This follows what Chrome does.
    if (sourceRoot[sourceRoot.length - 1] !== '/' && sourceURL[0] !== '/') {
      sourceRoot += '/';
    }
    // The spec says:
    //   Line 4: An optional source root, useful for relocating source
    //   files on a server or removing repeated values in the
    //   sources entry.  This value is prepended to the individual
    //   entries in the source field.
    sourceURL = sourceRoot + sourceURL;
  }

  // Historically, SourceMapConsumer did not take the sourceMapURL as
  // a parameter.  This mode is still somewhat supported, which is why
  // this code block is conditional.  However, it's preferable to pass
  // the source map URL to SourceMapConsumer, so that this function
  // can implement the source URL resolution algorithm as outlined in
  // the spec.  This block is basically the equivalent of:
  //    new URL(sourceURL, sourceMapURL).toString()
  // ... except it avoids using URL, which wasn't available in the
  // older releases of node still supported by this library.
  //
  // The spec says:
  //   If the sources are not absolute URLs after prepending of the
  //   sourceRoot, the sources are resolved relative to the
  //   SourceMap (like resolving script src in a html document).
  if (sourceMapURL) {
    var parsed = urlParse(sourceMapURL);
    if (!parsed) {
      throw new Error("sourceMapURL could not be parsed");
    }
    if (parsed.path) {
      // Strip the last path component, but keep the "/".
      var index = parsed.path.lastIndexOf('/');
      if (index >= 0) {
        parsed.path = parsed.path.substring(0, index + 1);
      }
    }
    sourceURL = join(urlGenerate(parsed), sourceURL);
  }

  return normalize(sourceURL);
}
exports.computeSourceURL = computeSourceURL;

/***/ }),
/* 24 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const u = __webpack_require__(6).fromCallback;
const rimraf = __webpack_require__(116);

module.exports = {
  remove: u(rimraf),
  removeSync: rimraf.sync
};

/***/ }),
/* 25 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// JS-YAML's default schema for `load` function.
// It is not described in the YAML specification.
//
// This schema is based on JS-YAML's default safe schema and includes
// JavaScript-specific types: !!js/undefined, !!js/regexp and !!js/function.
//
// Also this schema is used as default base schema at `Schema.create` function.




var Schema = __webpack_require__(18);

module.exports = Schema.DEFAULT = new Schema({
  include: [__webpack_require__(22)],
  explicit: [__webpack_require__(154), __webpack_require__(155), __webpack_require__(156)]
});

/***/ }),
/* 26 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const getFromEnv = parseInt(process.env.ELECTRON_IS_DEV, 10) === 1;
const isEnvSet = 'ELECTRON_IS_DEV' in process.env;

module.exports = isEnvSet ? getFromEnv : process.defaultApp || /node_modules[\\/]electron[\\/]/.test(process.execPath);

/***/ }),
/* 27 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.NoOpLogger = exports.AppUpdater = undefined;

var _bluebirdLst;

function _load_bluebirdLst() {
    return _bluebirdLst = __webpack_require__(2);
}

var _bluebirdLst2;

function _load_bluebirdLst2() {
    return _bluebirdLst2 = _interopRequireDefault(__webpack_require__(2));
}

var _builderUtilRuntime;

function _load_builderUtilRuntime() {
    return _builderUtilRuntime = __webpack_require__(3);
}

var _crypto;

function _load_crypto() {
    return _crypto = __webpack_require__(28);
}

var _electron;

function _load_electron() {
    return _electron = __webpack_require__(10);
}

var _electronIsDev;

function _load_electronIsDev() {
    return _electronIsDev = _interopRequireDefault(__webpack_require__(26));
}

var _events;

function _load_events() {
    return _events = __webpack_require__(41);
}

var _fsExtraP;

function _load_fsExtraP() {
    return _fsExtraP = __webpack_require__(9);
}

var _jsYaml;

function _load_jsYaml() {
    return _jsYaml = __webpack_require__(31);
}

var _lazyVal;

function _load_lazyVal() {
    return _lazyVal = __webpack_require__(159);
}

var _path = _interopRequireWildcard(__webpack_require__(0));

var _semver;

function _load_semver() {
    return _semver = __webpack_require__(55);
}

__webpack_require__(33);

var _electronHttpExecutor;

function _load_electronHttpExecutor() {
    return _electronHttpExecutor = __webpack_require__(169);
}

var _GenericProvider;

function _load_GenericProvider() {
    return _GenericProvider = __webpack_require__(59);
}

var _main;

function _load_main() {
    return _main = __webpack_require__(8);
}

var _providerFactory;

function _load_providerFactory() {
    return _providerFactory = __webpack_require__(170);
}

function _interopRequireWildcard(obj) {
    if (obj && obj.__esModule) {
        return obj;
    } else {
        var newObj = {};if (obj != null) {
            for (var key in obj) {
                if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key];
            }
        }newObj.default = obj;return newObj;
    }
}

function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
}

class AppUpdater extends (_events || _load_events()).EventEmitter {
    constructor(options, app) {
        super();
        /**
         * Whether to automatically download an update when it is found.
         */
        this.autoDownload = true;
        /**
         * *GitHub provider only.* Whether to allow update to pre-release versions. Defaults to `true` if application version contains prerelease components (e.g. `0.12.1-alpha.1`, here `alpha` is a prerelease component), otherwise `false`.
         *
         * If `true`, downgrade will be allowed (`allowDowngrade` will be set to `true`).
         */
        this.allowPrerelease = false;
        /**
         * *GitHub provider only.* Get all release notes (from current version to latest), not just the latest.
         * @default false
         */
        this.fullChangelog = false;
        /**
         * Whether to allow version downgrade (when a user from the beta channel wants to go back to the stable channel).
         * @default false
         */
        this.allowDowngrade = false;
        this._channel = null;
        this._logger = console;
        /**
         * For type safety you can use signals, e.g. `autoUpdater.signals.updateDownloaded(() => {})` instead of `autoUpdater.on('update-available', () => {})`
         */
        this.signals = new (_main || _load_main()).UpdaterSignal(this);
        this.updateAvailable = false;
        this.stagingUserIdPromise = new (_lazyVal || _load_lazyVal()).Lazy(() => this.getOrCreateStagingUserId());
        // public, allow to read old config for anyone
        this.configOnDisk = new (_lazyVal || _load_lazyVal()).Lazy(() => this.loadUpdateConfig());
        this.on("error", error => {
            this._logger.error(`Error: ${error.stack || error.message}`);
        });
        if (app != null || global.__test_app != null) {
            this.app = app || global.__test_app;
            this.untilAppReady = (_bluebirdLst2 || _load_bluebirdLst2()).default.resolve();
        } else {
            this.app = __webpack_require__(10).app;
            this.httpExecutor = new (_electronHttpExecutor || _load_electronHttpExecutor()).ElectronHttpExecutor((authInfo, callback) => this.emit("login", authInfo, callback));
            this.untilAppReady = new (_bluebirdLst2 || _load_bluebirdLst2()).default(resolve => {
                if (this.app.isReady()) {
                    resolve();
                } else {
                    this.app.on("ready", resolve);
                }
            });
        }
        const currentVersionString = this.app.getVersion();
        const currentVersion = (0, (_semver || _load_semver()).valid)(currentVersionString);
        if (currentVersion == null) {
            throw (0, (_builderUtilRuntime || _load_builderUtilRuntime()).newError)(`App version is not a valid semver version: "${currentVersionString}`, "ERR_UPDATER_INVALID_VERSION");
        }
        this.currentVersion = currentVersion;
        this.allowPrerelease = hasPrereleaseComponents(this.currentVersion);
        if (options != null) {
            this.setFeedURL(options);
        }
    }
    /**
     * Get the update channel. Not applicable for GitHub. Doesn't return `channel` from the update configuration, only if was previously set.
     */
    get channel() {
        return this._channel;
    }
    /**
     * Set the update channel. Not applicable for GitHub. Overrides `channel` in the update configuration.
     *
     * `allowDowngrade` will be automatically set to `true`. If this behavior is not suitable for you, simple set `allowDowngrade` explicitly after.
     */
    set channel(value) {
        if (this._channel != null) {
            if (typeof value !== "string") {
                throw (0, (_builderUtilRuntime || _load_builderUtilRuntime()).newError)(`Channel must be a string, but got: ${value}`, "ERR_UPDATER_INVALID_CHANNEL");
            } else if (value.length === 0) {
                throw (0, (_builderUtilRuntime || _load_builderUtilRuntime()).newError)(`Channel must be not an empty string`, "ERR_UPDATER_INVALID_CHANNEL");
            }
        }
        this._channel = value;
        this.allowDowngrade = true;
    }
    /**
     * The logger. You can pass [electron-log](https://github.com/megahertz/electron-log), [winston](https://github.com/winstonjs/winston) or another logger with the following interface: `{ info(), warn(), error() }`.
     * Set it to `null` if you would like to disable a logging feature.
     */
    get logger() {
        return this._logger;
    }
    set logger(value) {
        this._logger = value == null ? new NoOpLogger() : value;
    }
    /**
     * test only
     * @private
     */
    set updateConfigPath(value) {
        this.clientPromise = null;
        this._appUpdateConfigPath = value;
        this.configOnDisk = new (_lazyVal || _load_lazyVal()).Lazy(() => this.loadUpdateConfig());
    }
    get provider() {
        return this.clientPromise;
    }
    //noinspection JSMethodCanBeStatic,JSUnusedGlobalSymbols
    getFeedURL() {
        return "Deprecated. Do not use it.";
    }
    /**
     * Configure update provider. If value is `string`, [GenericServerOptions](/configuration/publish.md#genericserveroptions) will be set with value as `url`.
     * @param options If you want to override configuration in the `app-update.yml`.
     */
    setFeedURL(options) {
        // https://github.com/electron-userland/electron-builder/issues/1105
        let provider;
        if (typeof options === "string") {
            provider = new (_GenericProvider || _load_GenericProvider()).GenericProvider({ provider: "generic", url: options }, this);
        } else {
            provider = (0, (_providerFactory || _load_providerFactory()).createClient)(options, this);
        }
        this.clientPromise = Promise.resolve(provider);
    }
    /**
     * Asks the server whether there is an update.
     */
    checkForUpdates() {
        let checkForUpdatesPromise = this.checkForUpdatesPromise;
        if (checkForUpdatesPromise != null) {
            return checkForUpdatesPromise;
        }
        checkForUpdatesPromise = this._checkForUpdates();
        this.checkForUpdatesPromise = checkForUpdatesPromise;
        const nullizePromise = () => this.checkForUpdatesPromise = null;
        checkForUpdatesPromise.then(nullizePromise).catch(nullizePromise);
        return checkForUpdatesPromise;
    }
    checkForUpdatesAndNotify() {
        if ((_electronIsDev || _load_electronIsDev()).default) {
            return (_bluebirdLst2 || _load_bluebirdLst2()).default.resolve(null);
        }
        this.signals.updateDownloaded(it => {
            new (_electron || _load_electron()).Notification({
                title: "A new update is ready to install",
                body: `${this.app.getName()} version ${it.version} is downloaded and will be automatically installed on exit`
            }).show();
        });
        return this.checkForUpdates();
    }
    isStagingMatch(updateInfo) {
        var _this = this;

        return (0, (_bluebirdLst || _load_bluebirdLst()).coroutine)(function* () {
            const rawStagingPercentage = updateInfo.stagingPercentage;
            let stagingPercentage = rawStagingPercentage;
            if (stagingPercentage == null) {
                return true;
            }
            stagingPercentage = parseInt(stagingPercentage, 10);
            if (isNaN(stagingPercentage)) {
                _this._logger.warn(`Staging percentage is NaN: ${rawStagingPercentage}`);
                return true;
            }
            // convert from user 0-100 to internal 0-1
            stagingPercentage = stagingPercentage / 100;
            const stagingUserId = yield _this.stagingUserIdPromise.value;
            const val = (_builderUtilRuntime || _load_builderUtilRuntime()).UUID.parse(stagingUserId).readUInt32BE(12);
            const percentage = val / 0xFFFFFFFF;
            _this._logger.info(`Staging percentage: ${stagingPercentage}, percentage: ${percentage}, user id: ${stagingUserId}`);
            return percentage < stagingPercentage;
        })();
    }
    _checkForUpdates() {
        var _this2 = this;

        return (0, (_bluebirdLst || _load_bluebirdLst()).coroutine)(function* () {
            try {
                yield _this2.untilAppReady;
                _this2._logger.info("Checking for update");
                _this2.emit("checking-for-update");
                return yield _this2.doCheckForUpdates();
            } catch (e) {
                _this2.emit("error", e, `Cannot check for updates: ${(e.stack || e).toString()}`);
                throw e;
            }
        })();
    }
    computeFinalHeaders(headers) {
        if (this.requestHeaders != null) {
            Object.assign(headers, this.requestHeaders);
        }
        return headers;
    }
    doCheckForUpdates() {
        var _this3 = this;

        return (0, (_bluebirdLst || _load_bluebirdLst()).coroutine)(function* () {
            if (_this3.clientPromise == null) {
                _this3.clientPromise = _this3.configOnDisk.value.then(function (it) {
                    return (0, (_providerFactory || _load_providerFactory()).createClient)(it, _this3);
                });
            }
            const client = yield _this3.clientPromise;
            const stagingUserId = yield _this3.stagingUserIdPromise.value;
            client.setRequestHeaders(_this3.computeFinalHeaders({ "X-User-Staging-Id": stagingUserId }));
            const updateInfo = yield client.getLatestVersion();
            const latestVersion = (0, (_semver || _load_semver()).valid)(updateInfo.version);
            if (latestVersion == null) {
                throw (0, (_builderUtilRuntime || _load_builderUtilRuntime()).newError)(`Latest version (from update server) is not valid semver version: "${latestVersion}`, "ERR_UPDATER_INVALID_VERSION");
            }
            const isStagingMatch = yield _this3.isStagingMatch(updateInfo);
            if (!isStagingMatch || (_this3.allowDowngrade && !hasPrereleaseComponents(latestVersion) ? (0, (_semver || _load_semver()).eq)(latestVersion, _this3.currentVersion) : !(0, (_semver || _load_semver()).gt)(latestVersion, _this3.currentVersion))) {
                _this3.updateAvailable = false;
                _this3._logger.info(`Update for version ${_this3.currentVersion} is not available (latest version: ${updateInfo.version}, downgrade is ${_this3.allowDowngrade ? "allowed" : "disallowed"}.`);
                _this3.emit("update-not-available", updateInfo);
                return {
                    versionInfo: updateInfo,
                    updateInfo
                };
            }
            _this3.updateAvailable = true;
            _this3.updateInfo = updateInfo;
            _this3.onUpdateAvailable(updateInfo);
            const cancellationToken = new (_builderUtilRuntime || _load_builderUtilRuntime()).CancellationToken();
            //noinspection ES6MissingAwait
            return {
                versionInfo: updateInfo,
                updateInfo,
                cancellationToken,
                downloadPromise: _this3.autoDownload ? _this3.downloadUpdate(cancellationToken) : null
            };
        })();
    }
    onUpdateAvailable(updateInfo) {
        this._logger.info(`Found version ${updateInfo.version} (url: ${(0, (_builderUtilRuntime || _load_builderUtilRuntime()).asArray)(updateInfo.files).map(it => it.url).join(", ")})`);
        this.emit("update-available", updateInfo);
    }
    /**
     * Start downloading update manually. You can use this method if `autoDownload` option is set to `false`.
     * @returns {Promise<string>} Path to downloaded file.
     */
    downloadUpdate(cancellationToken = new (_builderUtilRuntime || _load_builderUtilRuntime()).CancellationToken()) {
        var _this4 = this;

        return (0, (_bluebirdLst || _load_bluebirdLst()).coroutine)(function* () {
            const updateInfo = _this4.updateInfo;
            if (updateInfo == null) {
                const error = new Error("Please check update first");
                _this4.dispatchError(error);
                throw error;
            }
            _this4._logger.info(`Downloading update from ${(0, (_builderUtilRuntime || _load_builderUtilRuntime()).asArray)(updateInfo.files).map(function (it) {
                return it.url;
            }).join(", ")}`);
            try {
                return yield _this4.doDownloadUpdate(updateInfo, cancellationToken);
            } catch (e) {
                _this4.dispatchError(e);
                throw e;
            }
        })();
    }
    dispatchError(e) {
        this.emit("error", e, (e.stack || e).toString());
    }
    loadUpdateConfig() {
        var _this5 = this;

        return (0, (_bluebirdLst || _load_bluebirdLst()).coroutine)(function* () {
            if (_this5._appUpdateConfigPath == null) {
                _this5._appUpdateConfigPath = (_electronIsDev || _load_electronIsDev()).default ? _path.join(_this5.app.getAppPath(), "dev-app-update.yml") : _path.join(process.resourcesPath, "app-update.yml");
            }
            return (0, (_jsYaml || _load_jsYaml()).safeLoad)((yield (0, (_fsExtraP || _load_fsExtraP()).readFile)(_this5._appUpdateConfigPath, "utf-8")));
        })();
    }
    /*** @private */
    computeRequestHeaders() {
        var _this6 = this;

        return (0, (_bluebirdLst || _load_bluebirdLst()).coroutine)(function* () {
            const fileExtraDownloadHeaders = (yield _this6.provider).fileExtraDownloadHeaders;
            if (fileExtraDownloadHeaders != null) {
                const requestHeaders = _this6.requestHeaders;
                return requestHeaders == null ? fileExtraDownloadHeaders : Object.assign({}, fileExtraDownloadHeaders, requestHeaders);
            }
            return _this6.computeFinalHeaders({ Accept: "*/*" });
        })();
    }
    getOrCreateStagingUserId() {
        var _this7 = this;

        return (0, (_bluebirdLst || _load_bluebirdLst()).coroutine)(function* () {
            const file = _path.join(_this7.app.getPath("userData"), ".updaterId");
            try {
                const id = yield (0, (_fsExtraP || _load_fsExtraP()).readFile)(file, "utf-8");
                if ((_builderUtilRuntime || _load_builderUtilRuntime()).UUID.check(id)) {
                    return id;
                } else {
                    _this7._logger.warn(`Staging user id file exists, but content was invalid: ${id}`);
                }
            } catch (e) {
                if (e.code !== "ENOENT") {
                    _this7._logger.warn(`Couldn't read staging user ID, creating a blank one: ${e}`);
                }
            }
            const id = (_builderUtilRuntime || _load_builderUtilRuntime()).UUID.v5((0, (_crypto || _load_crypto()).randomBytes)(4096), (_builderUtilRuntime || _load_builderUtilRuntime()).UUID.OID);
            _this7._logger.info(`Generated new staging user ID: ${id}`);
            try {
                yield (0, (_fsExtraP || _load_fsExtraP()).outputFile)(file, id);
            } catch (e) {
                _this7._logger.warn(`Couldn't write out staging user ID: ${e}`);
            }
            return id;
        })();
    }
}
exports.AppUpdater = AppUpdater;
function hasPrereleaseComponents(version) {
    const versionPrereleaseComponent = (0, (_semver || _load_semver()).prerelease)(version);
    return versionPrereleaseComponent != null && versionPrereleaseComponent.length > 0;
}
/** @private */
class NoOpLogger {
    info(message) {
        // ignore
    }
    warn(message) {
        // ignore
    }
    error(message) {
        // ignore
    }
}
exports.NoOpLogger = NoOpLogger; //# sourceMappingURL=AppUpdater.js.map

/***/ }),
/* 28 */
/***/ (function(module, exports) {

module.exports = require("crypto");

/***/ }),
/* 29 */
/***/ (function(module, exports) {

module.exports = require("util");

/***/ }),
/* 30 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const u = __webpack_require__(6).fromCallback;
const jsonFile = __webpack_require__(118);

module.exports = {
  // jsonfile exports
  readJson: u(jsonFile.readFile),
  readJsonSync: jsonFile.readFileSync,
  writeJson: u(jsonFile.writeFile),
  writeJsonSync: jsonFile.writeFileSync
};

/***/ }),
/* 31 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var yaml = __webpack_require__(137);

module.exports = yaml;

/***/ }),
/* 32 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Standard YAML's Failsafe schema.
// http://www.yaml.org/spec/1.2/spec.html#id2802346




var Schema = __webpack_require__(18);

module.exports = new Schema({
  explicit: [__webpack_require__(140), __webpack_require__(141), __webpack_require__(142)]
});

/***/ }),
/* 33 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__(160).install();

/***/ }),
/* 34 */
/***/ (function(module, exports) {

module.exports = require("child_process");

/***/ }),
/* 35 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.computeOperations = computeOperations;
var OperationKind = exports.OperationKind = undefined;
(function (OperationKind) {
    OperationKind[OperationKind["COPY"] = 0] = "COPY";
    OperationKind[OperationKind["DOWNLOAD"] = 1] = "DOWNLOAD";
})(OperationKind || (exports.OperationKind = OperationKind = {}));
function computeOperations(oldBlockMap, newBlockMap, logger) {
    const nameToOldBlocks = buildBlockFileMap(oldBlockMap.files);
    const nameToNewBlocks = buildBlockFileMap(newBlockMap.files);
    const oldEntryMap = buildEntryMap(oldBlockMap.files);
    let lastOperation = null;
    const operations = [];
    for (const blockMapFile of newBlockMap.files) {
        const name = blockMapFile.name;
        const oldEntry = oldEntryMap.get(name);
        if (oldEntry == null) {
            // new file
            operations.push({
                kind: OperationKind.DOWNLOAD,
                start: blockMapFile.offset,
                end: blockMapFile.offset + blockMapFile.sizes.reduce((accumulator, currentValue) => accumulator + currentValue)
            });
            continue;
        }
        const newFile = nameToNewBlocks.get(name);
        let changedBlockCount = 0;
        const { checksumToOffset: checksumToOldOffset, checksumToOldSize } = buildChecksumMap(nameToOldBlocks.get(name), oldEntry.offset);
        let newOffset = blockMapFile.offset;
        for (let i = 0; i < newFile.checksums.length; newOffset += newFile.sizes[i], i++) {
            const blockSize = newFile.sizes[i];
            const checksum = newFile.checksums[i];
            let oldOffset = checksumToOldOffset.get(checksum);
            if (oldOffset != null && checksumToOldSize.get(checksum) !== blockSize) {
                logger.warn(`Checksum ("${checksum}") matches, but size differs (old: ${checksumToOldSize.get(checksum)}, new: ${blockSize})`);
                oldOffset = null;
            }
            if (oldOffset == null) {
                changedBlockCount++;
                if (lastOperation == null || lastOperation.kind !== OperationKind.DOWNLOAD || lastOperation.end !== newOffset) {
                    lastOperation = {
                        kind: OperationKind.DOWNLOAD,
                        start: newOffset,
                        end: newOffset + blockSize
                    };
                    operations.push(lastOperation);
                } else {
                    lastOperation.end += blockSize;
                }
            } else if (lastOperation == null || lastOperation.kind !== OperationKind.COPY || lastOperation.end !== oldOffset) {
                lastOperation = {
                    kind: OperationKind.COPY,
                    start: oldOffset,
                    end: oldOffset + blockSize
                };
                operations.push(lastOperation);
            } else {
                lastOperation.end += blockSize;
            }
        }
        if (changedBlockCount > 0) {
            logger.info(`File${blockMapFile.name === "file" ? "" : " " + blockMapFile.name} has ${changedBlockCount} changed blocks`);
        }
    }
    return operations;
}
function buildChecksumMap(file, fileOffset) {
    const checksumToOffset = new Map();
    const checksumToSize = new Map();
    let offset = fileOffset;
    for (let i = 0; i < file.checksums.length; i++) {
        const checksum = file.checksums[i];
        const size = file.sizes[i];
        checksumToOffset.set(checksum, offset);
        checksumToSize.set(checksum, size);
        offset += size;
    }
    return { checksumToOffset, checksumToOldSize: checksumToSize };
}
function buildEntryMap(list) {
    const result = new Map();
    for (const item of list) {
        result.set(item.name, item);
    }
    return result;
}
function buildBlockFileMap(list) {
    const result = new Map();
    for (const item of list) {
        result.set(item.name, item);
    }
    return result;
}
//# sourceMappingURL=downloadPlanBuilder.js.map

/***/ }),
/* 36 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var format = __webpack_require__(37);
var originalConsole = __webpack_require__(68);

transport.level = 'silly';
transport.format = '[{h}:{i}:{s}.{ms}] [{level}] {text}';

module.exports = transport;

function transport(msg) {
  var text = format.format(msg, transport.format);
  if (originalConsole[msg.level]) {
    originalConsole[msg.level](text);
  } else {
    originalConsole.log(text);
  }
}

/***/ }),
/* 37 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var util = __webpack_require__(29);
var EOL = __webpack_require__(15).EOL;

module.exports = {
  format: format,
  formatTimeZone: formatTimeZone,
  pad: pad,
  stringifyArray: stringifyArray
};

function format(msg, formatter) {
  if (typeof formatter === 'function') {
    return formatter(msg);
  }

  var date = msg.date;

  return formatter.replace('{level}', msg.level).replace('{text}', stringifyArray(msg.data)).replace('{y}', date.getFullYear()).replace('{m}', pad(date.getMonth() + 1)).replace('{d}', pad(date.getDate())).replace('{h}', pad(date.getHours())).replace('{i}', pad(date.getMinutes())).replace('{s}', pad(date.getSeconds())).replace('{ms}', pad(date.getMilliseconds(), 3)).replace('{z}', formatTimeZone(date.getTimezoneOffset()));
}

function stringifyArray(data) {
  data = data.map(function formatErrors(arg) {
    return arg instanceof Error ? arg.stack + EOL : arg;
  });
  return util.format.apply(util, data);
}

function pad(number, zeros) {
  zeros = zeros || 2;
  return (new Array(zeros + 1).join('0') + number).substr(-zeros, zeros);
}

function formatTimeZone(minutesOffset) {
  var m = Math.abs(minutesOffset);
  return (minutesOffset >= 0 ? '-' : '+') + pad(Math.floor(m / 60)) + ':' + pad(m % 60);
}

/***/ }),
/* 38 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = function (NEXT_FILTER) {
    var util = __webpack_require__(1);
    var getKeys = __webpack_require__(16).keys;
    var tryCatch = util.tryCatch;
    var errorObj = util.errorObj;

    function catchFilter(instances, cb, promise) {
        return function (e) {
            var boundTo = promise._boundValue();
            predicateLoop: for (var i = 0; i < instances.length; ++i) {
                var item = instances[i];

                if (item === Error || item != null && item.prototype instanceof Error) {
                    if (e instanceof item) {
                        return tryCatch(cb).call(boundTo, e);
                    }
                } else if (typeof item === "function") {
                    var matchesPredicate = tryCatch(item).call(boundTo, e);
                    if (matchesPredicate === errorObj) {
                        return matchesPredicate;
                    } else if (matchesPredicate) {
                        return tryCatch(cb).call(boundTo, e);
                    }
                } else if (util.isObject(e)) {
                    var keys = getKeys(item);
                    for (var j = 0; j < keys.length; ++j) {
                        var key = keys[j];
                        if (item[key] != e[key]) {
                            continue predicateLoop;
                        }
                    }
                    return tryCatch(cb).call(boundTo, e);
                }
            }
            return NEXT_FILTER;
        };
    }

    return catchFilter;
};

/***/ }),
/* 39 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var util = __webpack_require__(1);
var maybeWrapAsError = util.maybeWrapAsError;
var errors = __webpack_require__(11);
var OperationalError = errors.OperationalError;
var es5 = __webpack_require__(16);

function isUntypedError(obj) {
    return obj instanceof Error && es5.getPrototypeOf(obj) === Error.prototype;
}

var rErrorKey = /^(?:name|message|stack|cause)$/;
function wrapAsOperationalError(obj) {
    var ret;
    if (isUntypedError(obj)) {
        ret = new OperationalError(obj);
        ret.name = obj.name;
        ret.message = obj.message;
        ret.stack = obj.stack;
        var keys = es5.keys(obj);
        for (var i = 0; i < keys.length; ++i) {
            var key = keys[i];
            if (!rErrorKey.test(key)) {
                ret[key] = obj[key];
            }
        }
        return ret;
    }
    util.markAsOriginatingFromRejection(obj);
    return obj;
}

function nodebackForPromise(promise, multiArgs) {
    return function (err, value) {
        if (promise === null) return;
        if (err) {
            var wrapped = wrapAsOperationalError(maybeWrapAsError(err));
            promise._attachExtraTrace(wrapped);
            promise._reject(wrapped);
        } else if (!multiArgs) {
            promise._fulfill(value);
        } else {
            var $_len = arguments.length;var args = new Array(Math.max($_len - 1, 0));for (var $_i = 1; $_i < $_len; ++$_i) {
                args[$_i - 1] = arguments[$_i];
            };
            promise._fulfill(args);
        }
        promise = null;
    };
}

module.exports = nodebackForPromise;

/***/ }),
/* 40 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.CancellationError = exports.CancellationToken = undefined;

var _bluebirdLst;

function _load_bluebirdLst() {
    return _bluebirdLst = _interopRequireDefault(__webpack_require__(2));
}

var _events;

function _load_events() {
    return _events = __webpack_require__(41);
}

function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
}

class CancellationToken extends (_events || _load_events()).EventEmitter {
    // babel cannot compile ... correctly for super calls
    constructor(parent) {
        super();
        this.parentCancelHandler = null;
        this._cancelled = false;
        if (parent != null) {
            this.parent = parent;
        }
    }
    get cancelled() {
        return this._cancelled || this._parent != null && this._parent.cancelled;
    }
    set parent(value) {
        this.removeParentCancelHandler();
        this._parent = value;
        this.parentCancelHandler = () => this.cancel();
        this._parent.onCancel(this.parentCancelHandler);
    }
    cancel() {
        this._cancelled = true;
        this.emit("cancel");
    }
    onCancel(handler) {
        if (this.cancelled) {
            handler();
        } else {
            this.once("cancel", handler);
        }
    }
    createPromise(callback) {
        if (this.cancelled) {
            return (_bluebirdLst || _load_bluebirdLst()).default.reject(new CancellationError());
        }
        let cancelHandler = null;
        return new (_bluebirdLst || _load_bluebirdLst()).default((resolve, reject) => {
            let addedCancelHandler = null;
            cancelHandler = () => {
                try {
                    if (addedCancelHandler != null) {
                        addedCancelHandler();
                        addedCancelHandler = null;
                    }
                } finally {
                    reject(new CancellationError());
                }
            };
            if (this.cancelled) {
                cancelHandler();
                return;
            }
            this.onCancel(cancelHandler);
            callback(resolve, reject, callback => {
                addedCancelHandler = callback;
            });
        }).finally(() => {
            if (cancelHandler != null) {
                this.removeListener("cancel", cancelHandler);
                cancelHandler = null;
            }
        });
    }
    removeParentCancelHandler() {
        const parent = this._parent;
        if (parent != null && this.parentCancelHandler != null) {
            parent.removeListener("cancel", this.parentCancelHandler);
            this.parentCancelHandler = null;
        }
    }
    dispose() {
        try {
            this.removeParentCancelHandler();
        } finally {
            this.removeAllListeners();
            this._parent = null;
        }
    }
}
exports.CancellationToken = CancellationToken;
class CancellationError extends Error {
    constructor() {
        super("Cancelled");
    }
}
exports.CancellationError = CancellationError; //# sourceMappingURL=CancellationToken.js.map

/***/ }),
/* 41 */
/***/ (function(module, exports) {

module.exports = require("events");

/***/ }),
/* 42 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.DigestTransform = exports.HttpExecutor = exports.HttpError = undefined;
exports.createHttpError = createHttpError;
exports.parseJson = parseJson;
exports.configureRequestOptionsFromUrl = configureRequestOptionsFromUrl;
exports.safeGetHeader = safeGetHeader;
exports.configureRequestOptions = configureRequestOptions;
exports.safeStringifyJson = safeStringifyJson;

var _crypto;

function _load_crypto() {
    return _crypto = __webpack_require__(28);
}

var _debug2 = _interopRequireDefault(__webpack_require__(100));

var _fsExtraP;

function _load_fsExtraP() {
    return _fsExtraP = __webpack_require__(9);
}

var _stream;

function _load_stream() {
    return _stream = __webpack_require__(19);
}

var _url;

function _load_url() {
    return _url = __webpack_require__(20);
}

var _CancellationToken;

function _load_CancellationToken() {
    return _CancellationToken = __webpack_require__(40);
}

var _index;

function _load_index() {
    return _index = __webpack_require__(3);
}

var _ProgressCallbackTransform;

function _load_ProgressCallbackTransform() {
    return _ProgressCallbackTransform = __webpack_require__(52);
}

function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
}

const debug = (0, _debug2.default)("electron-builder");
function createHttpError(response, description = null) {
    return new HttpError(response.statusCode || -1, `${response.statusCode} ${response.statusMessage}` + (description == null ? "" : "\n" + JSON.stringify(description, null, "  ")) + "\nHeaders: " + safeStringifyJson(response.headers), description);
}
const HTTP_STATUS_CODES = new Map([[429, "Too many requests"], [400, "Bad request"], [403, "Forbidden"], [404, "Not found"], [405, "Method not allowed"], [406, "Not acceptable"], [408, "Request timeout"], [413, "Request entity too large"], [500, "Internal server error"], [502, "Bad gateway"], [503, "Service unavailable"], [504, "Gateway timeout"], [505, "HTTP version not supported"]]);
class HttpError extends Error {
    constructor(statusCode, message = `HTTP error: ${HTTP_STATUS_CODES.get(statusCode) || statusCode}`, description = null) {
        super(message);
        this.statusCode = statusCode;
        this.description = description;
        this.name = "HttpError";
    }
}
exports.HttpError = HttpError;
function parseJson(result) {
    return result.then(it => it == null || it.length === 0 ? null : JSON.parse(it));
}
class HttpExecutor {
    constructor() {
        this.maxRedirects = 10;
    }
    request(options, cancellationToken = new (_CancellationToken || _load_CancellationToken()).CancellationToken(), data) {
        configureRequestOptions(options);
        const encodedData = data == null ? undefined : Buffer.from(JSON.stringify(data));
        if (encodedData != null) {
            options.method = "post";
            options.headers["Content-Type"] = "application/json";
            options.headers["Content-Length"] = encodedData.length;
        }
        return this.doApiRequest(options, cancellationToken, it => it.end(encodedData));
    }
    doApiRequest(options, cancellationToken, requestProcessor, redirectCount = 0) {
        if (debug.enabled) {
            debug(`Request: ${safeStringifyJson(options)}`);
        }
        return cancellationToken.createPromise((resolve, reject, onCancel) => {
            const request = this.doRequest(options, response => {
                try {
                    this.handleResponse(response, options, cancellationToken, resolve, reject, redirectCount, requestProcessor);
                } catch (e) {
                    reject(e);
                }
            });
            this.addErrorAndTimeoutHandlers(request, reject);
            this.addRedirectHandlers(request, options, reject, redirectCount, options => {
                this.doApiRequest(options, cancellationToken, requestProcessor, redirectCount).then(resolve).catch(reject);
            });
            requestProcessor(request, reject);
            onCancel(() => request.abort());
        });
    }
    // noinspection JSUnusedLocalSymbols
    addRedirectHandlers(request, options, reject, redirectCount, handler) {
        // not required for NodeJS
    }
    addErrorAndTimeoutHandlers(request, reject) {
        this.addTimeOutHandler(request, reject);
        request.on("error", reject);
        request.on("aborted", () => {
            reject(new Error("Request has been aborted by the server"));
        });
    }
    handleResponse(response, options, cancellationToken, resolve, reject, redirectCount, requestProcessor) {
        if (debug.enabled) {
            debug(`Response: ${response.statusCode} ${response.statusMessage}, request options: ${safeStringifyJson(options)}`);
        }
        // we handle any other >= 400 error on request end (read detailed message in the response body)
        if (response.statusCode === 404) {
            // error is clear, we don't need to read detailed error description
            reject(createHttpError(response, `method: ${options.method} url: ${options.protocol || "https:"}//${options.hostname}${options.path}

Please double check that your authentication token is correct. Due to security reasons actual status maybe not reported, but 404.
`));
            return;
        } else if (response.statusCode === 204) {
            // on DELETE request
            resolve();
            return;
        }
        const redirectUrl = safeGetHeader(response, "location");
        if (redirectUrl != null) {
            if (redirectCount > 10) {
                reject(new Error("Too many redirects (> 10)"));
                return;
            }
            this.doApiRequest(HttpExecutor.prepareRedirectUrlOptions(redirectUrl, options), cancellationToken, requestProcessor, redirectCount).then(resolve).catch(reject);
            return;
        }
        let data = "";
        response.setEncoding("utf8");
        response.on("data", chunk => data += chunk);
        response.on("end", () => {
            try {
                if (response.statusCode != null && response.statusCode >= 400) {
                    const contentType = safeGetHeader(response, "content-type");
                    const isJson = contentType != null && (Array.isArray(contentType) ? contentType.find(it => it.includes("json")) != null : contentType.includes("json"));
                    reject(createHttpError(response, isJson ? JSON.parse(data) : data));
                } else {
                    resolve(data.length === 0 ? null : data);
                }
            } catch (e) {
                reject(e);
            }
        });
    }
    doDownload(requestOptions, destination, redirectCount, options, callback, onCancel) {
        const request = this.doRequest(requestOptions, response => {
            if (response.statusCode >= 400) {
                callback(new Error(`Cannot download "${requestOptions.protocol || "https:"}//${requestOptions.hostname}${requestOptions.path}", status ${response.statusCode}: ${response.statusMessage}`));
                return;
            }
            const redirectUrl = safeGetHeader(response, "location");
            if (redirectUrl != null) {
                if (redirectCount < this.maxRedirects) {
                    this.doDownload(HttpExecutor.prepareRedirectUrlOptions(redirectUrl, requestOptions), destination, redirectCount++, options, callback, onCancel);
                } else {
                    callback(new Error(`Too many redirects (> ${this.maxRedirects})`));
                }
                return;
            }
            configurePipes(options, response, destination, callback, options.cancellationToken);
        });
        this.addErrorAndTimeoutHandlers(request, callback);
        this.addRedirectHandlers(request, requestOptions, callback, redirectCount, requestOptions => {
            this.doDownload(requestOptions, destination, redirectCount++, options, callback, onCancel);
        });
        onCancel(() => request.abort());
        request.end();
    }
    addTimeOutHandler(request, callback) {
        request.on("socket", socket => {
            socket.setTimeout(60 * 1000, () => {
                callback(new Error("Request timed out"));
                request.abort();
            });
        });
    }
    static prepareRedirectUrlOptions(redirectUrl, options) {
        const newOptions = configureRequestOptionsFromUrl(redirectUrl, Object.assign({}, options));
        if (newOptions.headers != null && newOptions.headers.Authorization != null && newOptions.headers.Authorization.startsWith("token")) {
            const parsedNewUrl = new (_url || _load_url()).URL(redirectUrl);
            if (parsedNewUrl.hostname.endsWith(".amazonaws.com")) {
                delete newOptions.headers.Authorization;
            }
        }
        return newOptions;
    }
}
exports.HttpExecutor = HttpExecutor;
function configureRequestOptionsFromUrl(url, options) {
    const parsedUrl = (0, (_url || _load_url()).parse)(url);
    options.protocol = parsedUrl.protocol;
    options.hostname = parsedUrl.hostname;
    if (parsedUrl.port == null) {
        if (options.port != null) {
            delete options.port;
        }
    } else {
        options.port = parsedUrl.port;
    }
    options.path = parsedUrl.path;
    return configureRequestOptions(options);
}
class DigestTransform extends (_stream || _load_stream()).Transform {
    constructor(expected, algorithm = "sha512", encoding = "base64") {
        super();
        this.expected = expected;
        this.algorithm = algorithm;
        this.encoding = encoding;
        this.isValidateOnEnd = true;
        this.digester = (0, (_crypto || _load_crypto()).createHash)(algorithm);
    }
    // noinspection JSUnusedGlobalSymbols
    get actual() {
        return this._actual;
    }
    // noinspection JSUnusedGlobalSymbols
    _transform(chunk, encoding, callback) {
        this.digester.update(chunk);
        callback(null, chunk);
    }
    // noinspection JSUnusedGlobalSymbols
    _flush(callback) {
        this._actual = this.digester.digest(this.encoding);
        if (this.isValidateOnEnd) {
            try {
                this.validate();
            } catch (e) {
                callback(e);
                return;
            }
        }
        callback(null);
    }
    validate() {
        if (this._actual == null) {
            throw (0, (_index || _load_index()).newError)("Not finished yet", "ERR_STREAM_NOT_FINISHED");
        }
        if (this._actual !== this.expected) {
            throw (0, (_index || _load_index()).newError)(`${this.algorithm} checksum mismatch, expected ${this.expected}, got ${this._actual}`, "ERR_CHECKSUM_MISMATCH");
        }
        return null;
    }
}
exports.DigestTransform = DigestTransform;
function checkSha2(sha2Header, sha2, callback) {
    if (sha2Header != null && sha2 != null) {
        // todo why bintray doesn't send this header always
        if (sha2Header == null) {
            callback(new Error("checksum is required, but server response doesn't contain X-Checksum-Sha2 header"));
            return false;
        } else if (sha2Header !== sha2) {
            callback(new Error(`checksum mismatch: expected ${sha2} but got ${sha2Header} (X-Checksum-Sha2 header)`));
            return false;
        }
    }
    return true;
}
function safeGetHeader(response, headerKey) {
    const value = response.headers[headerKey];
    if (value == null) {
        return null;
    } else if (Array.isArray(value)) {
        // electron API
        return value.length === 0 ? null : value[value.length - 1];
    } else {
        return value;
    }
}
function configurePipes(options, response, destination, callback, cancellationToken) {
    if (!checkSha2(safeGetHeader(response, "X-Checksum-Sha2"), options.sha2, callback)) {
        return;
    }
    const streams = [];
    if (options.onProgress != null) {
        const contentLength = safeGetHeader(response, "content-length");
        if (contentLength != null) {
            streams.push(new (_ProgressCallbackTransform || _load_ProgressCallbackTransform()).ProgressCallbackTransform(parseInt(contentLength, 10), options.cancellationToken, options.onProgress));
        }
    }
    const sha512 = options.sha512;
    if (sha512 != null) {
        streams.push(new DigestTransform(sha512, "sha512", sha512.length === 128 && !sha512.includes("+") && !sha512.includes("Z") && !sha512.includes("=") ? "hex" : "base64"));
    } else if (options.sha2 != null) {
        streams.push(new DigestTransform(options.sha2, "sha256", "hex"));
    }
    const fileOut = (0, (_fsExtraP || _load_fsExtraP()).createWriteStream)(destination);
    streams.push(fileOut);
    let lastStream = response;
    for (const stream of streams) {
        stream.on("error", error => {
            if (!cancellationToken.cancelled) {
                callback(error);
            }
        });
        lastStream = lastStream.pipe(stream);
    }
    fileOut.on("finish", () => {
        fileOut.close(callback);
    });
}
function configureRequestOptions(options, token, method) {
    if (method != null) {
        options.method = method;
    }
    let headers = options.headers;
    if (headers == null) {
        headers = {};
        options.headers = headers;
    }
    if (token != null) {
        headers.authorization = token.startsWith("Basic") ? token : `token ${token}`;
    }
    if (headers["User-Agent"] == null) {
        headers["User-Agent"] = "electron-builder";
    }
    if (method == null || method === "GET" || headers["Cache-Control"] == null) {
        headers["Cache-Control"] = "no-cache";
    }
    // do not specify for node (in any case we use https module)
    if (options.protocol == null && process.versions.electron != null) {
        options.protocol = "https:";
    }
    return options;
}
function safeStringifyJson(data, skippedNames) {
    return JSON.stringify(data, (name, value) => {
        if (name.endsWith("authorization") || name.endsWith("Password") || name.endsWith("PASSWORD") || name.endsWith("Token") || name.includes("password") || name.includes("token") || skippedNames != null && skippedNames.has(name)) {
            return "<stripped sensitive data>";
        }
        return value;
    }, 2);
}
//# sourceMappingURL=httpExecutor.js.map

/***/ }),
/* 43 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * This is the common logic for both the Node.js and web browser
 * implementations of `debug()`.
 *
 * Expose `debug()` as the module.
 */

exports = module.exports = createDebug.debug = createDebug['default'] = createDebug;
exports.coerce = coerce;
exports.disable = disable;
exports.enable = enable;
exports.enabled = enabled;
exports.humanize = __webpack_require__(102);

/**
 * Active `debug` instances.
 */
exports.instances = [];

/**
 * The currently active debug mode names, and names to skip.
 */

exports.names = [];
exports.skips = [];

/**
 * Map of special "%n" handling functions, for the debug "format" argument.
 *
 * Valid key names are a single, lower or upper-case letter, i.e. "n" and "N".
 */

exports.formatters = {};

/**
 * Select a color.
 * @param {String} namespace
 * @return {Number}
 * @api private
 */

function selectColor(namespace) {
  var hash = 0,
      i;

  for (i in namespace) {
    hash = (hash << 5) - hash + namespace.charCodeAt(i);
    hash |= 0; // Convert to 32bit integer
  }

  return exports.colors[Math.abs(hash) % exports.colors.length];
}

/**
 * Create a debugger with the given `namespace`.
 *
 * @param {String} namespace
 * @return {Function}
 * @api public
 */

function createDebug(namespace) {

  var prevTime;

  function debug() {
    // disabled?
    if (!debug.enabled) return;

    var self = debug;

    // set `diff` timestamp
    var curr = +new Date();
    var ms = curr - (prevTime || curr);
    self.diff = ms;
    self.prev = prevTime;
    self.curr = curr;
    prevTime = curr;

    // turn the `arguments` into a proper Array
    var args = new Array(arguments.length);
    for (var i = 0; i < args.length; i++) {
      args[i] = arguments[i];
    }

    args[0] = exports.coerce(args[0]);

    if ('string' !== typeof args[0]) {
      // anything else let's inspect with %O
      args.unshift('%O');
    }

    // apply any `formatters` transformations
    var index = 0;
    args[0] = args[0].replace(/%([a-zA-Z%])/g, function (match, format) {
      // if we encounter an escaped % then don't increase the array index
      if (match === '%%') return match;
      index++;
      var formatter = exports.formatters[format];
      if ('function' === typeof formatter) {
        var val = args[index];
        match = formatter.call(self, val);

        // now we need to remove `args[index]` since it's inlined in the `format`
        args.splice(index, 1);
        index--;
      }
      return match;
    });

    // apply env-specific formatting (colors, etc.)
    exports.formatArgs.call(self, args);

    var logFn = debug.log || exports.log || console.log.bind(console);
    logFn.apply(self, args);
  }

  debug.namespace = namespace;
  debug.enabled = exports.enabled(namespace);
  debug.useColors = exports.useColors();
  debug.color = selectColor(namespace);
  debug.destroy = destroy;

  // env-specific initialization logic for debug instances
  if ('function' === typeof exports.init) {
    exports.init(debug);
  }

  exports.instances.push(debug);

  return debug;
}

function destroy() {
  var index = exports.instances.indexOf(this);
  if (index !== -1) {
    exports.instances.splice(index, 1);
    return true;
  } else {
    return false;
  }
}

/**
 * Enables a debug mode by namespaces. This can include modes
 * separated by a colon and wildcards.
 *
 * @param {String} namespaces
 * @api public
 */

function enable(namespaces) {
  exports.save(namespaces);

  exports.names = [];
  exports.skips = [];

  var i;
  var split = (typeof namespaces === 'string' ? namespaces : '').split(/[\s,]+/);
  var len = split.length;

  for (i = 0; i < len; i++) {
    if (!split[i]) continue; // ignore empty strings
    namespaces = split[i].replace(/\*/g, '.*?');
    if (namespaces[0] === '-') {
      exports.skips.push(new RegExp('^' + namespaces.substr(1) + '$'));
    } else {
      exports.names.push(new RegExp('^' + namespaces + '$'));
    }
  }

  for (i = 0; i < exports.instances.length; i++) {
    var instance = exports.instances[i];
    instance.enabled = exports.enabled(instance.namespace);
  }
}

/**
 * Disable debug output.
 *
 * @api public
 */

function disable() {
  exports.enable('');
}

/**
 * Returns true if the given mode name is enabled, false otherwise.
 *
 * @param {String} name
 * @return {Boolean}
 * @api public
 */

function enabled(name) {
  if (name[name.length - 1] === '*') {
    return true;
  }
  var i, len;
  for (i = 0, len = exports.skips.length; i < len; i++) {
    if (exports.skips[i].test(name)) {
      return false;
    }
  }
  for (i = 0, len = exports.names.length; i < len; i++) {
    if (exports.names[i].test(name)) {
      return true;
    }
  }
  return false;
}

/**
 * Coerce `val`.
 *
 * @param {Mixed} val
 * @return {Mixed}
 * @api private
 */

function coerce(val) {
  if (val instanceof Error) return val.stack || val.message;
  return val;
}

/***/ }),
/* 44 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// This is adapted from https://github.com/normalize/mz
// Copyright (c) 2014-2016 Jonathan Ong me@jongleberry.com and Contributors
const u = __webpack_require__(6).fromCallback;
const fs = __webpack_require__(5);

const api = ['access', 'appendFile', 'chmod', 'chown', 'close', 'copyFile', 'fchmod', 'fchown', 'fdatasync', 'fstat', 'fsync', 'ftruncate', 'futimes', 'lchown', 'link', 'lstat', 'mkdir', 'mkdtemp', 'open', 'readFile', 'readdir', 'readlink', 'realpath', 'rename', 'rmdir', 'stat', 'symlink', 'truncate', 'unlink', 'utimes', 'writeFile'].filter(key => {
  // Some commands are not available on some systems. Ex:
  // fs.copyFile was added in Node.js v8.5.0
  // fs.mkdtemp was added in Node.js v5.10.0
  // fs.lchown is not available on at least some Linux
  return typeof fs[key] === 'function';
});

// Export all keys:
Object.keys(fs).forEach(key => {
  exports[key] = fs[key];
});

// Universalify async methods:
api.forEach(method => {
  exports[method] = u(fs[method]);
});

// We differ from mz/fs in that we still ship the old, broken, fs.exists()
// since we are a drop-in replacement for the native module
exports.exists = function (filename, callback) {
  if (typeof callback === 'function') {
    return fs.exists(filename, callback);
  }
  return new Promise(resolve => {
    return fs.exists(filename, resolve);
  });
};

// fs.read() & fs.write need special treatment due to multiple callback args

exports.read = function (fd, buffer, offset, length, position, callback) {
  if (typeof callback === 'function') {
    return fs.read(fd, buffer, offset, length, position, callback);
  }
  return new Promise((resolve, reject) => {
    fs.read(fd, buffer, offset, length, position, (err, bytesRead, buffer) => {
      if (err) return reject(err);
      resolve({ bytesRead, buffer });
    });
  });
};

// Function signature can be
// fs.write(fd, buffer[, offset[, length[, position]]], callback)
// OR
// fs.write(fd, string[, position[, encoding]], callback)
// so we need to handle both cases
exports.write = function (fd, buffer, a, b, c, callback) {
  if (typeof arguments[arguments.length - 1] === 'function') {
    return fs.write(fd, buffer, a, b, c, callback);
  }

  // Check for old, depricated fs.write(fd, string[, position[, encoding]], callback)
  if (typeof buffer === 'string') {
    return new Promise((resolve, reject) => {
      fs.write(fd, buffer, a, b, (err, bytesWritten, buffer) => {
        if (err) return reject(err);
        resolve({ bytesWritten, buffer });
      });
    });
  }

  return new Promise((resolve, reject) => {
    fs.write(fd, buffer, a, b, c, (err, bytesWritten, buffer) => {
      if (err) return reject(err);
      resolve({ bytesWritten, buffer });
    });
  });
};

/***/ }),
/* 45 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var fs = __webpack_require__(12);

module.exports = clone(fs);

function clone(obj) {
  if (obj === null || typeof obj !== 'object') return obj;

  if (obj instanceof Object) var copy = { __proto__: obj.__proto__ };else var copy = Object.create(null);

  Object.getOwnPropertyNames(obj).forEach(function (key) {
    Object.defineProperty(copy, key, Object.getOwnPropertyDescriptor(obj, key));
  });

  return copy;
}

/***/ }),
/* 46 */
/***/ (function(module, exports) {

module.exports = require("assert");

/***/ }),
/* 47 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const fs = __webpack_require__(5);
const path = __webpack_require__(0);
const mkdirp = __webpack_require__(7).mkdirs;
const pathExists = __webpack_require__(13).pathExists;
const utimes = __webpack_require__(49).utimesMillis;

const notExist = Symbol('notExist');
const existsReg = Symbol('existsReg');

function copy(src, dest, opts, cb) {
  if (typeof opts === 'function' && !cb) {
    cb = opts;
    opts = {};
  } else if (typeof opts === 'function') {
    opts = { filter: opts };
  }

  cb = cb || function () {};
  opts = opts || {};

  opts.clobber = 'clobber' in opts ? !!opts.clobber : true; // default to true for now
  opts.overwrite = 'overwrite' in opts ? !!opts.overwrite : opts.clobber; // overwrite falls back to clobber

  // Warn about using preserveTimestamps on 32-bit node
  if (opts.preserveTimestamps && process.arch === 'ia32') {
    console.warn(`fs-extra: Using the preserveTimestamps option in 32-bit node is not recommended;\n
    see https://github.com/jprichardson/node-fs-extra/issues/269`);
  }

  src = path.resolve(src);
  dest = path.resolve(dest);

  // don't allow src and dest to be the same
  if (src === dest) return cb(new Error('Source and destination must not be the same.'));

  if (opts.filter) return handleFilter(checkParentDir, src, dest, opts, cb);
  return checkParentDir(src, dest, opts, cb);
}

function checkParentDir(src, dest, opts, cb) {
  const destParent = path.dirname(dest);
  pathExists(destParent, (err, dirExists) => {
    if (err) return cb(err);
    if (dirExists) return startCopy(src, dest, opts, cb);
    mkdirp(destParent, err => {
      if (err) return cb(err);
      return startCopy(src, dest, opts, cb);
    });
  });
}

function startCopy(src, dest, opts, cb) {
  if (opts.filter) return handleFilter(getStats, src, dest, opts, cb);
  return getStats(src, dest, opts, cb);
}

function handleFilter(onInclude, src, dest, opts, cb) {
  Promise.resolve(opts.filter(src, dest)).then(include => {
    if (include) return onInclude(src, dest, opts, cb);
    return cb();
  }, error => cb(error));
}

function getStats(src, dest, opts, cb) {
  const stat = opts.dereference ? fs.stat : fs.lstat;
  stat(src, (err, st) => {
    if (err) return cb(err);

    if (st.isDirectory()) return onDir(st, src, dest, opts, cb);else if (st.isFile() || st.isCharacterDevice() || st.isBlockDevice()) return onFile(st, src, dest, opts, cb);else if (st.isSymbolicLink()) return onLink(src, dest, opts, cb);
  });
}

function onFile(srcStat, src, dest, opts, cb) {
  checkDest(dest, (err, resolvedPath) => {
    if (err) return cb(err);
    if (resolvedPath === notExist) {
      return copyFile(srcStat, src, dest, opts, cb);
    } else if (resolvedPath === existsReg) {
      return mayCopyFile(srcStat, src, dest, opts, cb);
    } else {
      if (src === resolvedPath) return cb();
      return mayCopyFile(srcStat, src, dest, opts, cb);
    }
  });
}

function mayCopyFile(srcStat, src, dest, opts, cb) {
  if (opts.overwrite) {
    fs.unlink(dest, err => {
      if (err) return cb(err);
      return copyFile(srcStat, src, dest, opts, cb);
    });
  } else if (opts.errorOnExist) {
    return cb(new Error(`'${dest}' already exists`));
  } else return cb();
}

function copyFile(srcStat, src, dest, opts, cb) {
  if (typeof fs.copyFile === 'function') {
    return fs.copyFile(src, dest, err => {
      if (err) return cb(err);
      return setDestModeAndTimestamps(srcStat, dest, opts, cb);
    });
  }
  return copyFileFallback(srcStat, src, dest, opts, cb);
}

function copyFileFallback(srcStat, src, dest, opts, cb) {
  const rs = fs.createReadStream(src);
  rs.on('error', err => cb(err)).once('open', () => {
    const ws = fs.createWriteStream(dest, { mode: srcStat.mode });
    ws.on('error', err => cb(err)).on('open', () => rs.pipe(ws)).once('close', () => setDestModeAndTimestamps(srcStat, dest, opts, cb));
  });
}

function setDestModeAndTimestamps(srcStat, dest, opts, cb) {
  fs.chmod(dest, srcStat.mode, err => {
    if (err) return cb(err);
    if (opts.preserveTimestamps) {
      return utimes(dest, srcStat.atime, srcStat.mtime, cb);
    }
    return cb();
  });
}

function onDir(srcStat, src, dest, opts, cb) {
  checkDest(dest, (err, resolvedPath) => {
    if (err) return cb(err);
    if (resolvedPath === notExist) {
      if (isSrcSubdir(src, dest)) {
        return cb(new Error(`Cannot copy '${src}' to a subdirectory of itself, '${dest}'.`));
      }
      return mkDirAndCopy(srcStat, src, dest, opts, cb);
    } else if (resolvedPath === existsReg) {
      if (isSrcSubdir(src, dest)) {
        return cb(new Error(`Cannot copy '${src}' to a subdirectory of itself, '${dest}'.`));
      }
      return mayCopyDir(src, dest, opts, cb);
    } else {
      if (src === resolvedPath) return cb();
      return copyDir(src, dest, opts, cb);
    }
  });
}

function mayCopyDir(src, dest, opts, cb) {
  fs.stat(dest, (err, st) => {
    if (err) return cb(err);
    if (!st.isDirectory()) {
      return cb(new Error(`Cannot overwrite non-directory '${dest}' with directory '${src}'.`));
    }
    return copyDir(src, dest, opts, cb);
  });
}

function mkDirAndCopy(srcStat, src, dest, opts, cb) {
  fs.mkdir(dest, srcStat.mode, err => {
    if (err) return cb(err);
    fs.chmod(dest, srcStat.mode, err => {
      if (err) return cb(err);
      return copyDir(src, dest, opts, cb);
    });
  });
}

function copyDir(src, dest, opts, cb) {
  fs.readdir(src, (err, items) => {
    if (err) return cb(err);
    return copyDirItems(items, src, dest, opts, cb);
  });
}

function copyDirItems(items, src, dest, opts, cb) {
  const item = items.pop();
  if (!item) return cb();
  startCopy(path.join(src, item), path.join(dest, item), opts, err => {
    if (err) return cb(err);
    return copyDirItems(items, src, dest, opts, cb);
  });
}

function onLink(src, dest, opts, cb) {
  fs.readlink(src, (err, resolvedSrcPath) => {
    if (err) return cb(err);

    if (opts.dereference) {
      resolvedSrcPath = path.resolve(process.cwd(), resolvedSrcPath);
    }

    checkDest(dest, (err, resolvedDestPath) => {
      if (err) return cb(err);

      if (resolvedDestPath === notExist || resolvedDestPath === existsReg) {
        // if dest already exists, fs throws error anyway,
        // so no need to guard against it here.
        return fs.symlink(resolvedSrcPath, dest, cb);
      } else {
        if (opts.dereference) {
          resolvedDestPath = path.resolve(process.cwd(), resolvedDestPath);
        }
        if (resolvedDestPath === resolvedSrcPath) return cb();

        // prevent copy if src is a subdir of dest since unlinking
        // dest in this case would result in removing src contents
        // and therefore a broken symlink would be created.
        fs.stat(dest, (err, st) => {
          if (err) return cb(err);
          if (st.isDirectory() && isSrcSubdir(resolvedDestPath, resolvedSrcPath)) {
            return cb(new Error(`Cannot overwrite '${resolvedDestPath}' with '${resolvedSrcPath}'.`));
          }
          return copyLink(resolvedSrcPath, dest, cb);
        });
      }
    });
  });
}

function copyLink(resolvedSrcPath, dest, cb) {
  fs.unlink(dest, err => {
    if (err) return cb(err);
    return fs.symlink(resolvedSrcPath, dest, cb);
  });
}

// check if dest exists and/or is a symlink
function checkDest(dest, cb) {
  fs.readlink(dest, (err, resolvedPath) => {
    if (err) {
      if (err.code === 'ENOENT') return cb(null, notExist);

      // dest exists and is a regular file or directory, Windows may throw UNKNOWN error.
      if (err.code === 'EINVAL' || err.code === 'UNKNOWN') return cb(null, existsReg);

      return cb(err);
    }
    return cb(null, resolvedPath); // dest exists and is a symlink
  });
}

// return true if dest is a subdir of src, otherwise false.
// extract dest base dir and check if that is the same as src basename
function isSrcSubdir(src, dest) {
  const baseDir = dest.split(path.dirname(src) + path.sep)[1];
  if (baseDir) {
    const destBasename = baseDir.split(path.sep)[0];
    if (destBasename) {
      return src !== dest && dest.indexOf(src) > -1 && destBasename === path.basename(src);
    }
    return false;
  }
  return false;
}

module.exports = copy;

/***/ }),
/* 48 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const path = __webpack_require__(0);

// get drive on windows
function getRootPath(p) {
  p = path.normalize(path.resolve(p)).split(path.sep);
  if (p.length > 0) return p[0];
  return null;
}

// http://stackoverflow.com/a/62888/10333 contains more accurate
// TODO: expand to include the rest
const INVALID_PATH_CHARS = /[<>:"|?*]/;

function invalidWin32Path(p) {
  const rp = getRootPath(p);
  p = p.replace(rp, '');
  return INVALID_PATH_CHARS.test(p);
}

module.exports = {
  getRootPath,
  invalidWin32Path
};

/***/ }),
/* 49 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const fs = __webpack_require__(5);
const os = __webpack_require__(15);
const path = __webpack_require__(0);

// HFS, ext{2,3}, FAT do not, Node.js v0.10 does not
function hasMillisResSync() {
  let tmpfile = path.join('millis-test-sync' + Date.now().toString() + Math.random().toString().slice(2));
  tmpfile = path.join(os.tmpdir(), tmpfile);

  // 550 millis past UNIX epoch
  const d = new Date(1435410243862);
  fs.writeFileSync(tmpfile, 'https://github.com/jprichardson/node-fs-extra/pull/141');
  const fd = fs.openSync(tmpfile, 'r+');
  fs.futimesSync(fd, d, d);
  fs.closeSync(fd);
  return fs.statSync(tmpfile).mtime > 1435410243000;
}

function hasMillisRes(callback) {
  let tmpfile = path.join('millis-test' + Date.now().toString() + Math.random().toString().slice(2));
  tmpfile = path.join(os.tmpdir(), tmpfile);

  // 550 millis past UNIX epoch
  const d = new Date(1435410243862);
  fs.writeFile(tmpfile, 'https://github.com/jprichardson/node-fs-extra/pull/141', err => {
    if (err) return callback(err);
    fs.open(tmpfile, 'r+', (err, fd) => {
      if (err) return callback(err);
      fs.futimes(fd, d, d, err => {
        if (err) return callback(err);
        fs.close(fd, err => {
          if (err) return callback(err);
          fs.stat(tmpfile, (err, stats) => {
            if (err) return callback(err);
            callback(null, stats.mtime > 1435410243000);
          });
        });
      });
    });
  });
}

function timeRemoveMillis(timestamp) {
  if (typeof timestamp === 'number') {
    return Math.floor(timestamp / 1000) * 1000;
  } else if (timestamp instanceof Date) {
    return new Date(Math.floor(timestamp.getTime() / 1000) * 1000);
  } else {
    throw new Error('fs-extra: timeRemoveMillis() unknown parameter type');
  }
}

function utimesMillis(path, atime, mtime, callback) {
  // if (!HAS_MILLIS_RES) return fs.utimes(path, atime, mtime, callback)
  fs.open(path, 'r+', (err, fd) => {
    if (err) return callback(err);
    fs.futimes(fd, atime, mtime, futimesErr => {
      fs.close(fd, closeErr => {
        if (callback) callback(futimesErr || closeErr);
      });
    });
  });
}

function utimesMillisSync(path, atime, mtime) {
  const fd = fs.openSync(path, 'r+');
  fs.futimesSync(fd, atime, mtime);
  return fs.closeSync(fd);
}

module.exports = {
  hasMillisRes,
  hasMillisResSync,
  timeRemoveMillis,
  utimesMillis,
  utimesMillisSync
};

/***/ }),
/* 50 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = {
  copySync: __webpack_require__(115)
};

/***/ }),
/* 51 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/* eslint-disable node/no-deprecated-api */
module.exports = function (size) {
  if (typeof Buffer.allocUnsafe === 'function') {
    try {
      return Buffer.allocUnsafe(size);
    } catch (e) {
      return new Buffer(size);
    }
  }
  return new Buffer(size);
};

/***/ }),
/* 52 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.ProgressCallbackTransform = undefined;

var _stream;

function _load_stream() {
    return _stream = __webpack_require__(19);
}

class ProgressCallbackTransform extends (_stream || _load_stream()).Transform {
    constructor(total, cancellationToken, onProgress) {
        super();
        this.total = total;
        this.cancellationToken = cancellationToken;
        this.onProgress = onProgress;
        this.start = Date.now();
        this.transferred = 0;
        this.delta = 0;
        this.nextUpdate = this.start + 1000;
    }
    _transform(chunk, encoding, callback) {
        if (this.cancellationToken.cancelled) {
            callback(new Error("Cancelled"), null);
            return;
        }
        this.transferred += chunk.length;
        this.delta += chunk.length;
        const now = Date.now();
        if (now >= this.nextUpdate && this.transferred !== this.total /* will be emitted on _flush */) {
                this.nextUpdate = now + 1000;
                this.onProgress({
                    total: this.total,
                    delta: this.delta,
                    transferred: this.transferred,
                    percent: this.transferred / this.total * 100,
                    bytesPerSecond: Math.round(this.transferred / ((now - this.start) / 1000))
                });
                this.delta = 0;
            }
        callback(null, chunk);
    }
    _flush(callback) {
        if (this.cancellationToken.cancelled) {
            callback(new Error("Cancelled"));
            return;
        }
        this.onProgress({
            total: this.total,
            delta: this.delta,
            transferred: this.total,
            percent: 100,
            bytesPerSecond: Math.round(this.transferred / ((Date.now() - this.start) / 1000))
        });
        this.delta = 0;
        callback(null);
    }
}
exports.ProgressCallbackTransform = ProgressCallbackTransform; //# sourceMappingURL=ProgressCallbackTransform.js.map

/***/ }),
/* 53 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Standard YAML's Core schema.
// http://www.yaml.org/spec/1.2/spec.html#id2804923
//
// NOTE: JS-YAML does not support schema-specific tag resolution restrictions.
// So, Core schema has no distinctions from JSON schema is JS-YAML.




var Schema = __webpack_require__(18);

module.exports = new Schema({
  include: [__webpack_require__(54)]
});

/***/ }),
/* 54 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Standard YAML's JSON schema.
// http://www.yaml.org/spec/1.2/spec.html#id2803231
//
// NOTE: JS-YAML does not support schema-specific tag resolution restrictions.
// So, this schema is not such strict as defined in the YAML specification.
// It allows numbers in binary notaion, use `Null` and `NULL` as `null`, etc.




var Schema = __webpack_require__(18);

module.exports = new Schema({
  include: [__webpack_require__(32)],
  implicit: [__webpack_require__(143), __webpack_require__(144), __webpack_require__(145), __webpack_require__(146)]
});

/***/ }),
/* 55 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports = module.exports = SemVer;

// The debug function is excluded entirely from the minified version.
/* nomin */var debug;
/* nomin */if (typeof process === 'object' &&
/* nomin */process.env &&
/* nomin */process.env.NODE_DEBUG &&
/* nomin *//\bsemver\b/i.test(process.env.NODE_DEBUG))
  /* nomin */debug = function () {
    /* nomin */var args = Array.prototype.slice.call(arguments, 0);
    /* nomin */args.unshift('SEMVER');
    /* nomin */console.log.apply(console, args);
    /* nomin */
  };
  /* nomin */else
  /* nomin */debug = function () {};

// Note: this is the semver.org version of the spec that it implements
// Not necessarily the package version of this code.
exports.SEMVER_SPEC_VERSION = '2.0.0';

var MAX_LENGTH = 256;
var MAX_SAFE_INTEGER = Number.MAX_SAFE_INTEGER || 9007199254740991;

// The actual regexps go on exports.re
var re = exports.re = [];
var src = exports.src = [];
var R = 0;

// The following Regular Expressions can be used for tokenizing,
// validating, and parsing SemVer version strings.

// ## Numeric Identifier
// A single `0`, or a non-zero digit followed by zero or more digits.

var NUMERICIDENTIFIER = R++;
src[NUMERICIDENTIFIER] = '0|[1-9]\\d*';
var NUMERICIDENTIFIERLOOSE = R++;
src[NUMERICIDENTIFIERLOOSE] = '[0-9]+';

// ## Non-numeric Identifier
// Zero or more digits, followed by a letter or hyphen, and then zero or
// more letters, digits, or hyphens.

var NONNUMERICIDENTIFIER = R++;
src[NONNUMERICIDENTIFIER] = '\\d*[a-zA-Z-][a-zA-Z0-9-]*';

// ## Main Version
// Three dot-separated numeric identifiers.

var MAINVERSION = R++;
src[MAINVERSION] = '(' + src[NUMERICIDENTIFIER] + ')\\.' + '(' + src[NUMERICIDENTIFIER] + ')\\.' + '(' + src[NUMERICIDENTIFIER] + ')';

var MAINVERSIONLOOSE = R++;
src[MAINVERSIONLOOSE] = '(' + src[NUMERICIDENTIFIERLOOSE] + ')\\.' + '(' + src[NUMERICIDENTIFIERLOOSE] + ')\\.' + '(' + src[NUMERICIDENTIFIERLOOSE] + ')';

// ## Pre-release Version Identifier
// A numeric identifier, or a non-numeric identifier.

var PRERELEASEIDENTIFIER = R++;
src[PRERELEASEIDENTIFIER] = '(?:' + src[NUMERICIDENTIFIER] + '|' + src[NONNUMERICIDENTIFIER] + ')';

var PRERELEASEIDENTIFIERLOOSE = R++;
src[PRERELEASEIDENTIFIERLOOSE] = '(?:' + src[NUMERICIDENTIFIERLOOSE] + '|' + src[NONNUMERICIDENTIFIER] + ')';

// ## Pre-release Version
// Hyphen, followed by one or more dot-separated pre-release version
// identifiers.

var PRERELEASE = R++;
src[PRERELEASE] = '(?:-(' + src[PRERELEASEIDENTIFIER] + '(?:\\.' + src[PRERELEASEIDENTIFIER] + ')*))';

var PRERELEASELOOSE = R++;
src[PRERELEASELOOSE] = '(?:-?(' + src[PRERELEASEIDENTIFIERLOOSE] + '(?:\\.' + src[PRERELEASEIDENTIFIERLOOSE] + ')*))';

// ## Build Metadata Identifier
// Any combination of digits, letters, or hyphens.

var BUILDIDENTIFIER = R++;
src[BUILDIDENTIFIER] = '[0-9A-Za-z-]+';

// ## Build Metadata
// Plus sign, followed by one or more period-separated build metadata
// identifiers.

var BUILD = R++;
src[BUILD] = '(?:\\+(' + src[BUILDIDENTIFIER] + '(?:\\.' + src[BUILDIDENTIFIER] + ')*))';

// ## Full Version String
// A main version, followed optionally by a pre-release version and
// build metadata.

// Note that the only major, minor, patch, and pre-release sections of
// the version string are capturing groups.  The build metadata is not a
// capturing group, because it should not ever be used in version
// comparison.

var FULL = R++;
var FULLPLAIN = 'v?' + src[MAINVERSION] + src[PRERELEASE] + '?' + src[BUILD] + '?';

src[FULL] = '^' + FULLPLAIN + '$';

// like full, but allows v1.2.3 and =1.2.3, which people do sometimes.
// also, 1.0.0alpha1 (prerelease without the hyphen) which is pretty
// common in the npm registry.
var LOOSEPLAIN = '[v=\\s]*' + src[MAINVERSIONLOOSE] + src[PRERELEASELOOSE] + '?' + src[BUILD] + '?';

var LOOSE = R++;
src[LOOSE] = '^' + LOOSEPLAIN + '$';

var GTLT = R++;
src[GTLT] = '((?:<|>)?=?)';

// Something like "2.*" or "1.2.x".
// Note that "x.x" is a valid xRange identifer, meaning "any version"
// Only the first item is strictly required.
var XRANGEIDENTIFIERLOOSE = R++;
src[XRANGEIDENTIFIERLOOSE] = src[NUMERICIDENTIFIERLOOSE] + '|x|X|\\*';
var XRANGEIDENTIFIER = R++;
src[XRANGEIDENTIFIER] = src[NUMERICIDENTIFIER] + '|x|X|\\*';

var XRANGEPLAIN = R++;
src[XRANGEPLAIN] = '[v=\\s]*(' + src[XRANGEIDENTIFIER] + ')' + '(?:\\.(' + src[XRANGEIDENTIFIER] + ')' + '(?:\\.(' + src[XRANGEIDENTIFIER] + ')' + '(?:' + src[PRERELEASE] + ')?' + src[BUILD] + '?' + ')?)?';

var XRANGEPLAINLOOSE = R++;
src[XRANGEPLAINLOOSE] = '[v=\\s]*(' + src[XRANGEIDENTIFIERLOOSE] + ')' + '(?:\\.(' + src[XRANGEIDENTIFIERLOOSE] + ')' + '(?:\\.(' + src[XRANGEIDENTIFIERLOOSE] + ')' + '(?:' + src[PRERELEASELOOSE] + ')?' + src[BUILD] + '?' + ')?)?';

var XRANGE = R++;
src[XRANGE] = '^' + src[GTLT] + '\\s*' + src[XRANGEPLAIN] + '$';
var XRANGELOOSE = R++;
src[XRANGELOOSE] = '^' + src[GTLT] + '\\s*' + src[XRANGEPLAINLOOSE] + '$';

// Tilde ranges.
// Meaning is "reasonably at or greater than"
var LONETILDE = R++;
src[LONETILDE] = '(?:~>?)';

var TILDETRIM = R++;
src[TILDETRIM] = '(\\s*)' + src[LONETILDE] + '\\s+';
re[TILDETRIM] = new RegExp(src[TILDETRIM], 'g');
var tildeTrimReplace = '$1~';

var TILDE = R++;
src[TILDE] = '^' + src[LONETILDE] + src[XRANGEPLAIN] + '$';
var TILDELOOSE = R++;
src[TILDELOOSE] = '^' + src[LONETILDE] + src[XRANGEPLAINLOOSE] + '$';

// Caret ranges.
// Meaning is "at least and backwards compatible with"
var LONECARET = R++;
src[LONECARET] = '(?:\\^)';

var CARETTRIM = R++;
src[CARETTRIM] = '(\\s*)' + src[LONECARET] + '\\s+';
re[CARETTRIM] = new RegExp(src[CARETTRIM], 'g');
var caretTrimReplace = '$1^';

var CARET = R++;
src[CARET] = '^' + src[LONECARET] + src[XRANGEPLAIN] + '$';
var CARETLOOSE = R++;
src[CARETLOOSE] = '^' + src[LONECARET] + src[XRANGEPLAINLOOSE] + '$';

// A simple gt/lt/eq thing, or just "" to indicate "any version"
var COMPARATORLOOSE = R++;
src[COMPARATORLOOSE] = '^' + src[GTLT] + '\\s*(' + LOOSEPLAIN + ')$|^$';
var COMPARATOR = R++;
src[COMPARATOR] = '^' + src[GTLT] + '\\s*(' + FULLPLAIN + ')$|^$';

// An expression to strip any whitespace between the gtlt and the thing
// it modifies, so that `> 1.2.3` ==> `>1.2.3`
var COMPARATORTRIM = R++;
src[COMPARATORTRIM] = '(\\s*)' + src[GTLT] + '\\s*(' + LOOSEPLAIN + '|' + src[XRANGEPLAIN] + ')';

// this one has to use the /g flag
re[COMPARATORTRIM] = new RegExp(src[COMPARATORTRIM], 'g');
var comparatorTrimReplace = '$1$2$3';

// Something like `1.2.3 - 1.2.4`
// Note that these all use the loose form, because they'll be
// checked against either the strict or loose comparator form
// later.
var HYPHENRANGE = R++;
src[HYPHENRANGE] = '^\\s*(' + src[XRANGEPLAIN] + ')' + '\\s+-\\s+' + '(' + src[XRANGEPLAIN] + ')' + '\\s*$';

var HYPHENRANGELOOSE = R++;
src[HYPHENRANGELOOSE] = '^\\s*(' + src[XRANGEPLAINLOOSE] + ')' + '\\s+-\\s+' + '(' + src[XRANGEPLAINLOOSE] + ')' + '\\s*$';

// Star ranges basically just allow anything at all.
var STAR = R++;
src[STAR] = '(<|>)?=?\\s*\\*';

// Compile to actual regexp objects.
// All are flag-free, unless they were created above with a flag.
for (var i = 0; i < R; i++) {
  debug(i, src[i]);
  if (!re[i]) re[i] = new RegExp(src[i]);
}

exports.parse = parse;
function parse(version, loose) {
  if (version instanceof SemVer) return version;

  if (typeof version !== 'string') return null;

  if (version.length > MAX_LENGTH) return null;

  var r = loose ? re[LOOSE] : re[FULL];
  if (!r.test(version)) return null;

  try {
    return new SemVer(version, loose);
  } catch (er) {
    return null;
  }
}

exports.valid = valid;
function valid(version, loose) {
  var v = parse(version, loose);
  return v ? v.version : null;
}

exports.clean = clean;
function clean(version, loose) {
  var s = parse(version.trim().replace(/^[=v]+/, ''), loose);
  return s ? s.version : null;
}

exports.SemVer = SemVer;

function SemVer(version, loose) {
  if (version instanceof SemVer) {
    if (version.loose === loose) return version;else version = version.version;
  } else if (typeof version !== 'string') {
    throw new TypeError('Invalid Version: ' + version);
  }

  if (version.length > MAX_LENGTH) throw new TypeError('version is longer than ' + MAX_LENGTH + ' characters');

  if (!(this instanceof SemVer)) return new SemVer(version, loose);

  debug('SemVer', version, loose);
  this.loose = loose;
  var m = version.trim().match(loose ? re[LOOSE] : re[FULL]);

  if (!m) throw new TypeError('Invalid Version: ' + version);

  this.raw = version;

  // these are actually numbers
  this.major = +m[1];
  this.minor = +m[2];
  this.patch = +m[3];

  if (this.major > MAX_SAFE_INTEGER || this.major < 0) throw new TypeError('Invalid major version');

  if (this.minor > MAX_SAFE_INTEGER || this.minor < 0) throw new TypeError('Invalid minor version');

  if (this.patch > MAX_SAFE_INTEGER || this.patch < 0) throw new TypeError('Invalid patch version');

  // numberify any prerelease numeric ids
  if (!m[4]) this.prerelease = [];else this.prerelease = m[4].split('.').map(function (id) {
    if (/^[0-9]+$/.test(id)) {
      var num = +id;
      if (num >= 0 && num < MAX_SAFE_INTEGER) return num;
    }
    return id;
  });

  this.build = m[5] ? m[5].split('.') : [];
  this.format();
}

SemVer.prototype.format = function () {
  this.version = this.major + '.' + this.minor + '.' + this.patch;
  if (this.prerelease.length) this.version += '-' + this.prerelease.join('.');
  return this.version;
};

SemVer.prototype.toString = function () {
  return this.version;
};

SemVer.prototype.compare = function (other) {
  debug('SemVer.compare', this.version, this.loose, other);
  if (!(other instanceof SemVer)) other = new SemVer(other, this.loose);

  return this.compareMain(other) || this.comparePre(other);
};

SemVer.prototype.compareMain = function (other) {
  if (!(other instanceof SemVer)) other = new SemVer(other, this.loose);

  return compareIdentifiers(this.major, other.major) || compareIdentifiers(this.minor, other.minor) || compareIdentifiers(this.patch, other.patch);
};

SemVer.prototype.comparePre = function (other) {
  if (!(other instanceof SemVer)) other = new SemVer(other, this.loose);

  // NOT having a prerelease is > having one
  if (this.prerelease.length && !other.prerelease.length) return -1;else if (!this.prerelease.length && other.prerelease.length) return 1;else if (!this.prerelease.length && !other.prerelease.length) return 0;

  var i = 0;
  do {
    var a = this.prerelease[i];
    var b = other.prerelease[i];
    debug('prerelease compare', i, a, b);
    if (a === undefined && b === undefined) return 0;else if (b === undefined) return 1;else if (a === undefined) return -1;else if (a === b) continue;else return compareIdentifiers(a, b);
  } while (++i);
};

// preminor will bump the version up to the next minor release, and immediately
// down to pre-release. premajor and prepatch work the same way.
SemVer.prototype.inc = function (release, identifier) {
  switch (release) {
    case 'premajor':
      this.prerelease.length = 0;
      this.patch = 0;
      this.minor = 0;
      this.major++;
      this.inc('pre', identifier);
      break;
    case 'preminor':
      this.prerelease.length = 0;
      this.patch = 0;
      this.minor++;
      this.inc('pre', identifier);
      break;
    case 'prepatch':
      // If this is already a prerelease, it will bump to the next version
      // drop any prereleases that might already exist, since they are not
      // relevant at this point.
      this.prerelease.length = 0;
      this.inc('patch', identifier);
      this.inc('pre', identifier);
      break;
    // If the input is a non-prerelease version, this acts the same as
    // prepatch.
    case 'prerelease':
      if (this.prerelease.length === 0) this.inc('patch', identifier);
      this.inc('pre', identifier);
      break;

    case 'major':
      // If this is a pre-major version, bump up to the same major version.
      // Otherwise increment major.
      // 1.0.0-5 bumps to 1.0.0
      // 1.1.0 bumps to 2.0.0
      if (this.minor !== 0 || this.patch !== 0 || this.prerelease.length === 0) this.major++;
      this.minor = 0;
      this.patch = 0;
      this.prerelease = [];
      break;
    case 'minor':
      // If this is a pre-minor version, bump up to the same minor version.
      // Otherwise increment minor.
      // 1.2.0-5 bumps to 1.2.0
      // 1.2.1 bumps to 1.3.0
      if (this.patch !== 0 || this.prerelease.length === 0) this.minor++;
      this.patch = 0;
      this.prerelease = [];
      break;
    case 'patch':
      // If this is not a pre-release version, it will increment the patch.
      // If it is a pre-release it will bump up to the same patch version.
      // 1.2.0-5 patches to 1.2.0
      // 1.2.0 patches to 1.2.1
      if (this.prerelease.length === 0) this.patch++;
      this.prerelease = [];
      break;
    // This probably shouldn't be used publicly.
    // 1.0.0 "pre" would become 1.0.0-0 which is the wrong direction.
    case 'pre':
      if (this.prerelease.length === 0) this.prerelease = [0];else {
        var i = this.prerelease.length;
        while (--i >= 0) {
          if (typeof this.prerelease[i] === 'number') {
            this.prerelease[i]++;
            i = -2;
          }
        }
        if (i === -1) // didn't increment anything
          this.prerelease.push(0);
      }
      if (identifier) {
        // 1.2.0-beta.1 bumps to 1.2.0-beta.2,
        // 1.2.0-beta.fooblz or 1.2.0-beta bumps to 1.2.0-beta.0
        if (this.prerelease[0] === identifier) {
          if (isNaN(this.prerelease[1])) this.prerelease = [identifier, 0];
        } else this.prerelease = [identifier, 0];
      }
      break;

    default:
      throw new Error('invalid increment argument: ' + release);
  }
  this.format();
  this.raw = this.version;
  return this;
};

exports.inc = inc;
function inc(version, release, loose, identifier) {
  if (typeof loose === 'string') {
    identifier = loose;
    loose = undefined;
  }

  try {
    return new SemVer(version, loose).inc(release, identifier).version;
  } catch (er) {
    return null;
  }
}

exports.diff = diff;
function diff(version1, version2) {
  if (eq(version1, version2)) {
    return null;
  } else {
    var v1 = parse(version1);
    var v2 = parse(version2);
    if (v1.prerelease.length || v2.prerelease.length) {
      for (var key in v1) {
        if (key === 'major' || key === 'minor' || key === 'patch') {
          if (v1[key] !== v2[key]) {
            return 'pre' + key;
          }
        }
      }
      return 'prerelease';
    }
    for (var key in v1) {
      if (key === 'major' || key === 'minor' || key === 'patch') {
        if (v1[key] !== v2[key]) {
          return key;
        }
      }
    }
  }
}

exports.compareIdentifiers = compareIdentifiers;

var numeric = /^[0-9]+$/;
function compareIdentifiers(a, b) {
  var anum = numeric.test(a);
  var bnum = numeric.test(b);

  if (anum && bnum) {
    a = +a;
    b = +b;
  }

  return anum && !bnum ? -1 : bnum && !anum ? 1 : a < b ? -1 : a > b ? 1 : 0;
}

exports.rcompareIdentifiers = rcompareIdentifiers;
function rcompareIdentifiers(a, b) {
  return compareIdentifiers(b, a);
}

exports.major = major;
function major(a, loose) {
  return new SemVer(a, loose).major;
}

exports.minor = minor;
function minor(a, loose) {
  return new SemVer(a, loose).minor;
}

exports.patch = patch;
function patch(a, loose) {
  return new SemVer(a, loose).patch;
}

exports.compare = compare;
function compare(a, b, loose) {
  return new SemVer(a, loose).compare(new SemVer(b, loose));
}

exports.compareLoose = compareLoose;
function compareLoose(a, b) {
  return compare(a, b, true);
}

exports.rcompare = rcompare;
function rcompare(a, b, loose) {
  return compare(b, a, loose);
}

exports.sort = sort;
function sort(list, loose) {
  return list.sort(function (a, b) {
    return exports.compare(a, b, loose);
  });
}

exports.rsort = rsort;
function rsort(list, loose) {
  return list.sort(function (a, b) {
    return exports.rcompare(a, b, loose);
  });
}

exports.gt = gt;
function gt(a, b, loose) {
  return compare(a, b, loose) > 0;
}

exports.lt = lt;
function lt(a, b, loose) {
  return compare(a, b, loose) < 0;
}

exports.eq = eq;
function eq(a, b, loose) {
  return compare(a, b, loose) === 0;
}

exports.neq = neq;
function neq(a, b, loose) {
  return compare(a, b, loose) !== 0;
}

exports.gte = gte;
function gte(a, b, loose) {
  return compare(a, b, loose) >= 0;
}

exports.lte = lte;
function lte(a, b, loose) {
  return compare(a, b, loose) <= 0;
}

exports.cmp = cmp;
function cmp(a, op, b, loose) {
  var ret;
  switch (op) {
    case '===':
      if (typeof a === 'object') a = a.version;
      if (typeof b === 'object') b = b.version;
      ret = a === b;
      break;
    case '!==':
      if (typeof a === 'object') a = a.version;
      if (typeof b === 'object') b = b.version;
      ret = a !== b;
      break;
    case '':case '=':case '==':
      ret = eq(a, b, loose);break;
    case '!=':
      ret = neq(a, b, loose);break;
    case '>':
      ret = gt(a, b, loose);break;
    case '>=':
      ret = gte(a, b, loose);break;
    case '<':
      ret = lt(a, b, loose);break;
    case '<=':
      ret = lte(a, b, loose);break;
    default:
      throw new TypeError('Invalid operator: ' + op);
  }
  return ret;
}

exports.Comparator = Comparator;
function Comparator(comp, loose) {
  if (comp instanceof Comparator) {
    if (comp.loose === loose) return comp;else comp = comp.value;
  }

  if (!(this instanceof Comparator)) return new Comparator(comp, loose);

  debug('comparator', comp, loose);
  this.loose = loose;
  this.parse(comp);

  if (this.semver === ANY) this.value = '';else this.value = this.operator + this.semver.version;

  debug('comp', this);
}

var ANY = {};
Comparator.prototype.parse = function (comp) {
  var r = this.loose ? re[COMPARATORLOOSE] : re[COMPARATOR];
  var m = comp.match(r);

  if (!m) throw new TypeError('Invalid comparator: ' + comp);

  this.operator = m[1];
  if (this.operator === '=') this.operator = '';

  // if it literally is just '>' or '' then allow anything.
  if (!m[2]) this.semver = ANY;else this.semver = new SemVer(m[2], this.loose);
};

Comparator.prototype.toString = function () {
  return this.value;
};

Comparator.prototype.test = function (version) {
  debug('Comparator.test', version, this.loose);

  if (this.semver === ANY) return true;

  if (typeof version === 'string') version = new SemVer(version, this.loose);

  return cmp(version, this.operator, this.semver, this.loose);
};

Comparator.prototype.intersects = function (comp, loose) {
  if (!(comp instanceof Comparator)) {
    throw new TypeError('a Comparator is required');
  }

  var rangeTmp;

  if (this.operator === '') {
    rangeTmp = new Range(comp.value, loose);
    return satisfies(this.value, rangeTmp, loose);
  } else if (comp.operator === '') {
    rangeTmp = new Range(this.value, loose);
    return satisfies(comp.semver, rangeTmp, loose);
  }

  var sameDirectionIncreasing = (this.operator === '>=' || this.operator === '>') && (comp.operator === '>=' || comp.operator === '>');
  var sameDirectionDecreasing = (this.operator === '<=' || this.operator === '<') && (comp.operator === '<=' || comp.operator === '<');
  var sameSemVer = this.semver.version === comp.semver.version;
  var differentDirectionsInclusive = (this.operator === '>=' || this.operator === '<=') && (comp.operator === '>=' || comp.operator === '<=');
  var oppositeDirectionsLessThan = cmp(this.semver, '<', comp.semver, loose) && (this.operator === '>=' || this.operator === '>') && (comp.operator === '<=' || comp.operator === '<');
  var oppositeDirectionsGreaterThan = cmp(this.semver, '>', comp.semver, loose) && (this.operator === '<=' || this.operator === '<') && (comp.operator === '>=' || comp.operator === '>');

  return sameDirectionIncreasing || sameDirectionDecreasing || sameSemVer && differentDirectionsInclusive || oppositeDirectionsLessThan || oppositeDirectionsGreaterThan;
};

exports.Range = Range;
function Range(range, loose) {
  if (range instanceof Range) {
    if (range.loose === loose) {
      return range;
    } else {
      return new Range(range.raw, loose);
    }
  }

  if (range instanceof Comparator) {
    return new Range(range.value, loose);
  }

  if (!(this instanceof Range)) return new Range(range, loose);

  this.loose = loose;

  // First, split based on boolean or ||
  this.raw = range;
  this.set = range.split(/\s*\|\|\s*/).map(function (range) {
    return this.parseRange(range.trim());
  }, this).filter(function (c) {
    // throw out any that are not relevant for whatever reason
    return c.length;
  });

  if (!this.set.length) {
    throw new TypeError('Invalid SemVer Range: ' + range);
  }

  this.format();
}

Range.prototype.format = function () {
  this.range = this.set.map(function (comps) {
    return comps.join(' ').trim();
  }).join('||').trim();
  return this.range;
};

Range.prototype.toString = function () {
  return this.range;
};

Range.prototype.parseRange = function (range) {
  var loose = this.loose;
  range = range.trim();
  debug('range', range, loose);
  // `1.2.3 - 1.2.4` => `>=1.2.3 <=1.2.4`
  var hr = loose ? re[HYPHENRANGELOOSE] : re[HYPHENRANGE];
  range = range.replace(hr, hyphenReplace);
  debug('hyphen replace', range);
  // `> 1.2.3 < 1.2.5` => `>1.2.3 <1.2.5`
  range = range.replace(re[COMPARATORTRIM], comparatorTrimReplace);
  debug('comparator trim', range, re[COMPARATORTRIM]);

  // `~ 1.2.3` => `~1.2.3`
  range = range.replace(re[TILDETRIM], tildeTrimReplace);

  // `^ 1.2.3` => `^1.2.3`
  range = range.replace(re[CARETTRIM], caretTrimReplace);

  // normalize spaces
  range = range.split(/\s+/).join(' ');

  // At this point, the range is completely trimmed and
  // ready to be split into comparators.

  var compRe = loose ? re[COMPARATORLOOSE] : re[COMPARATOR];
  var set = range.split(' ').map(function (comp) {
    return parseComparator(comp, loose);
  }).join(' ').split(/\s+/);
  if (this.loose) {
    // in loose mode, throw out any that are not valid comparators
    set = set.filter(function (comp) {
      return !!comp.match(compRe);
    });
  }
  set = set.map(function (comp) {
    return new Comparator(comp, loose);
  });

  return set;
};

Range.prototype.intersects = function (range, loose) {
  if (!(range instanceof Range)) {
    throw new TypeError('a Range is required');
  }

  return this.set.some(function (thisComparators) {
    return thisComparators.every(function (thisComparator) {
      return range.set.some(function (rangeComparators) {
        return rangeComparators.every(function (rangeComparator) {
          return thisComparator.intersects(rangeComparator, loose);
        });
      });
    });
  });
};

// Mostly just for testing and legacy API reasons
exports.toComparators = toComparators;
function toComparators(range, loose) {
  return new Range(range, loose).set.map(function (comp) {
    return comp.map(function (c) {
      return c.value;
    }).join(' ').trim().split(' ');
  });
}

// comprised of xranges, tildes, stars, and gtlt's at this point.
// already replaced the hyphen ranges
// turn into a set of JUST comparators.
function parseComparator(comp, loose) {
  debug('comp', comp);
  comp = replaceCarets(comp, loose);
  debug('caret', comp);
  comp = replaceTildes(comp, loose);
  debug('tildes', comp);
  comp = replaceXRanges(comp, loose);
  debug('xrange', comp);
  comp = replaceStars(comp, loose);
  debug('stars', comp);
  return comp;
}

function isX(id) {
  return !id || id.toLowerCase() === 'x' || id === '*';
}

// ~, ~> --> * (any, kinda silly)
// ~2, ~2.x, ~2.x.x, ~>2, ~>2.x ~>2.x.x --> >=2.0.0 <3.0.0
// ~2.0, ~2.0.x, ~>2.0, ~>2.0.x --> >=2.0.0 <2.1.0
// ~1.2, ~1.2.x, ~>1.2, ~>1.2.x --> >=1.2.0 <1.3.0
// ~1.2.3, ~>1.2.3 --> >=1.2.3 <1.3.0
// ~1.2.0, ~>1.2.0 --> >=1.2.0 <1.3.0
function replaceTildes(comp, loose) {
  return comp.trim().split(/\s+/).map(function (comp) {
    return replaceTilde(comp, loose);
  }).join(' ');
}

function replaceTilde(comp, loose) {
  var r = loose ? re[TILDELOOSE] : re[TILDE];
  return comp.replace(r, function (_, M, m, p, pr) {
    debug('tilde', comp, _, M, m, p, pr);
    var ret;

    if (isX(M)) ret = '';else if (isX(m)) ret = '>=' + M + '.0.0 <' + (+M + 1) + '.0.0';else if (isX(p))
      // ~1.2 == >=1.2.0 <1.3.0
      ret = '>=' + M + '.' + m + '.0 <' + M + '.' + (+m + 1) + '.0';else if (pr) {
      debug('replaceTilde pr', pr);
      if (pr.charAt(0) !== '-') pr = '-' + pr;
      ret = '>=' + M + '.' + m + '.' + p + pr + ' <' + M + '.' + (+m + 1) + '.0';
    } else
      // ~1.2.3 == >=1.2.3 <1.3.0
      ret = '>=' + M + '.' + m + '.' + p + ' <' + M + '.' + (+m + 1) + '.0';

    debug('tilde return', ret);
    return ret;
  });
}

// ^ --> * (any, kinda silly)
// ^2, ^2.x, ^2.x.x --> >=2.0.0 <3.0.0
// ^2.0, ^2.0.x --> >=2.0.0 <3.0.0
// ^1.2, ^1.2.x --> >=1.2.0 <2.0.0
// ^1.2.3 --> >=1.2.3 <2.0.0
// ^1.2.0 --> >=1.2.0 <2.0.0
function replaceCarets(comp, loose) {
  return comp.trim().split(/\s+/).map(function (comp) {
    return replaceCaret(comp, loose);
  }).join(' ');
}

function replaceCaret(comp, loose) {
  debug('caret', comp, loose);
  var r = loose ? re[CARETLOOSE] : re[CARET];
  return comp.replace(r, function (_, M, m, p, pr) {
    debug('caret', comp, _, M, m, p, pr);
    var ret;

    if (isX(M)) ret = '';else if (isX(m)) ret = '>=' + M + '.0.0 <' + (+M + 1) + '.0.0';else if (isX(p)) {
      if (M === '0') ret = '>=' + M + '.' + m + '.0 <' + M + '.' + (+m + 1) + '.0';else ret = '>=' + M + '.' + m + '.0 <' + (+M + 1) + '.0.0';
    } else if (pr) {
      debug('replaceCaret pr', pr);
      if (pr.charAt(0) !== '-') pr = '-' + pr;
      if (M === '0') {
        if (m === '0') ret = '>=' + M + '.' + m + '.' + p + pr + ' <' + M + '.' + m + '.' + (+p + 1);else ret = '>=' + M + '.' + m + '.' + p + pr + ' <' + M + '.' + (+m + 1) + '.0';
      } else ret = '>=' + M + '.' + m + '.' + p + pr + ' <' + (+M + 1) + '.0.0';
    } else {
      debug('no pr');
      if (M === '0') {
        if (m === '0') ret = '>=' + M + '.' + m + '.' + p + ' <' + M + '.' + m + '.' + (+p + 1);else ret = '>=' + M + '.' + m + '.' + p + ' <' + M + '.' + (+m + 1) + '.0';
      } else ret = '>=' + M + '.' + m + '.' + p + ' <' + (+M + 1) + '.0.0';
    }

    debug('caret return', ret);
    return ret;
  });
}

function replaceXRanges(comp, loose) {
  debug('replaceXRanges', comp, loose);
  return comp.split(/\s+/).map(function (comp) {
    return replaceXRange(comp, loose);
  }).join(' ');
}

function replaceXRange(comp, loose) {
  comp = comp.trim();
  var r = loose ? re[XRANGELOOSE] : re[XRANGE];
  return comp.replace(r, function (ret, gtlt, M, m, p, pr) {
    debug('xRange', comp, ret, gtlt, M, m, p, pr);
    var xM = isX(M);
    var xm = xM || isX(m);
    var xp = xm || isX(p);
    var anyX = xp;

    if (gtlt === '=' && anyX) gtlt = '';

    if (xM) {
      if (gtlt === '>' || gtlt === '<') {
        // nothing is allowed
        ret = '<0.0.0';
      } else {
        // nothing is forbidden
        ret = '*';
      }
    } else if (gtlt && anyX) {
      // replace X with 0
      if (xm) m = 0;
      if (xp) p = 0;

      if (gtlt === '>') {
        // >1 => >=2.0.0
        // >1.2 => >=1.3.0
        // >1.2.3 => >= 1.2.4
        gtlt = '>=';
        if (xm) {
          M = +M + 1;
          m = 0;
          p = 0;
        } else if (xp) {
          m = +m + 1;
          p = 0;
        }
      } else if (gtlt === '<=') {
        // <=0.7.x is actually <0.8.0, since any 0.7.x should
        // pass.  Similarly, <=7.x is actually <8.0.0, etc.
        gtlt = '<';
        if (xm) M = +M + 1;else m = +m + 1;
      }

      ret = gtlt + M + '.' + m + '.' + p;
    } else if (xm) {
      ret = '>=' + M + '.0.0 <' + (+M + 1) + '.0.0';
    } else if (xp) {
      ret = '>=' + M + '.' + m + '.0 <' + M + '.' + (+m + 1) + '.0';
    }

    debug('xRange return', ret);

    return ret;
  });
}

// Because * is AND-ed with everything else in the comparator,
// and '' means "any version", just remove the *s entirely.
function replaceStars(comp, loose) {
  debug('replaceStars', comp, loose);
  // Looseness is ignored here.  star is always as loose as it gets!
  return comp.trim().replace(re[STAR], '');
}

// This function is passed to string.replace(re[HYPHENRANGE])
// M, m, patch, prerelease, build
// 1.2 - 3.4.5 => >=1.2.0 <=3.4.5
// 1.2.3 - 3.4 => >=1.2.0 <3.5.0 Any 3.4.x will do
// 1.2 - 3.4 => >=1.2.0 <3.5.0
function hyphenReplace($0, from, fM, fm, fp, fpr, fb, to, tM, tm, tp, tpr, tb) {

  if (isX(fM)) from = '';else if (isX(fm)) from = '>=' + fM + '.0.0';else if (isX(fp)) from = '>=' + fM + '.' + fm + '.0';else from = '>=' + from;

  if (isX(tM)) to = '';else if (isX(tm)) to = '<' + (+tM + 1) + '.0.0';else if (isX(tp)) to = '<' + tM + '.' + (+tm + 1) + '.0';else if (tpr) to = '<=' + tM + '.' + tm + '.' + tp + '-' + tpr;else to = '<=' + to;

  return (from + ' ' + to).trim();
}

// if ANY of the sets match ALL of its comparators, then pass
Range.prototype.test = function (version) {
  if (!version) return false;

  if (typeof version === 'string') version = new SemVer(version, this.loose);

  for (var i = 0; i < this.set.length; i++) {
    if (testSet(this.set[i], version)) return true;
  }
  return false;
};

function testSet(set, version) {
  for (var i = 0; i < set.length; i++) {
    if (!set[i].test(version)) return false;
  }

  if (version.prerelease.length) {
    // Find the set of versions that are allowed to have prereleases
    // For example, ^1.2.3-pr.1 desugars to >=1.2.3-pr.1 <2.0.0
    // That should allow `1.2.3-pr.2` to pass.
    // However, `1.2.4-alpha.notready` should NOT be allowed,
    // even though it's within the range set by the comparators.
    for (var i = 0; i < set.length; i++) {
      debug(set[i].semver);
      if (set[i].semver === ANY) continue;

      if (set[i].semver.prerelease.length > 0) {
        var allowed = set[i].semver;
        if (allowed.major === version.major && allowed.minor === version.minor && allowed.patch === version.patch) return true;
      }
    }

    // Version has a -pre, but it's not one of the ones we like.
    return false;
  }

  return true;
}

exports.satisfies = satisfies;
function satisfies(version, range, loose) {
  try {
    range = new Range(range, loose);
  } catch (er) {
    return false;
  }
  return range.test(version);
}

exports.maxSatisfying = maxSatisfying;
function maxSatisfying(versions, range, loose) {
  var max = null;
  var maxSV = null;
  try {
    var rangeObj = new Range(range, loose);
  } catch (er) {
    return null;
  }
  versions.forEach(function (v) {
    if (rangeObj.test(v)) {
      // satisfies(v, range, loose)
      if (!max || maxSV.compare(v) === -1) {
        // compare(max, v, true)
        max = v;
        maxSV = new SemVer(max, loose);
      }
    }
  });
  return max;
}

exports.minSatisfying = minSatisfying;
function minSatisfying(versions, range, loose) {
  var min = null;
  var minSV = null;
  try {
    var rangeObj = new Range(range, loose);
  } catch (er) {
    return null;
  }
  versions.forEach(function (v) {
    if (rangeObj.test(v)) {
      // satisfies(v, range, loose)
      if (!min || minSV.compare(v) === 1) {
        // compare(min, v, true)
        min = v;
        minSV = new SemVer(min, loose);
      }
    }
  });
  return min;
}

exports.validRange = validRange;
function validRange(range, loose) {
  try {
    // Return '*' instead of '' so that truthiness works.
    // This will throw if it's invalid anyway
    return new Range(range, loose).range || '*';
  } catch (er) {
    return null;
  }
}

// Determine if version is less than all the versions possible in the range
exports.ltr = ltr;
function ltr(version, range, loose) {
  return outside(version, range, '<', loose);
}

// Determine if version is greater than all the versions possible in the range.
exports.gtr = gtr;
function gtr(version, range, loose) {
  return outside(version, range, '>', loose);
}

exports.outside = outside;
function outside(version, range, hilo, loose) {
  version = new SemVer(version, loose);
  range = new Range(range, loose);

  var gtfn, ltefn, ltfn, comp, ecomp;
  switch (hilo) {
    case '>':
      gtfn = gt;
      ltefn = lte;
      ltfn = lt;
      comp = '>';
      ecomp = '>=';
      break;
    case '<':
      gtfn = lt;
      ltefn = gte;
      ltfn = gt;
      comp = '<';
      ecomp = '<=';
      break;
    default:
      throw new TypeError('Must provide a hilo val of "<" or ">"');
  }

  // If it satisifes the range it is not outside
  if (satisfies(version, range, loose)) {
    return false;
  }

  // From now on, variable terms are as if we're in "gtr" mode.
  // but note that everything is flipped for the "ltr" function.

  for (var i = 0; i < range.set.length; ++i) {
    var comparators = range.set[i];

    var high = null;
    var low = null;

    comparators.forEach(function (comparator) {
      if (comparator.semver === ANY) {
        comparator = new Comparator('>=0.0.0');
      }
      high = high || comparator;
      low = low || comparator;
      if (gtfn(comparator.semver, high.semver, loose)) {
        high = comparator;
      } else if (ltfn(comparator.semver, low.semver, loose)) {
        low = comparator;
      }
    });

    // If the edge version comparator has a operator then our version
    // isn't outside it
    if (high.operator === comp || high.operator === ecomp) {
      return false;
    }

    // If the lowest version comparator has an operator and our version
    // is less than it then it isn't higher than the range
    if ((!low.operator || low.operator === comp) && ltefn(version, low.semver)) {
      return false;
    } else if (low.operator === ecomp && ltfn(version, low.semver)) {
      return false;
    }
  }
  return true;
}

exports.prerelease = prerelease;
function prerelease(version, loose) {
  var parsed = parse(version, loose);
  return parsed && parsed.prerelease.length ? parsed.prerelease : null;
}

exports.intersects = intersects;
function intersects(r1, r2, loose) {
  r1 = new Range(r1, loose);
  r2 = new Range(r2, loose);
  return r1.intersects(r2);
}

/***/ }),
/* 56 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/* -*- Mode: js; js-indent-level: 2; -*- */
/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */

var base64VLQ = __webpack_require__(57);
var util = __webpack_require__(23);
var ArraySet = __webpack_require__(58).ArraySet;
var MappingList = __webpack_require__(163).MappingList;

/**
 * An instance of the SourceMapGenerator represents a source map which is
 * being built incrementally. You may pass an object with the following
 * properties:
 *
 *   - file: The filename of the generated source.
 *   - sourceRoot: A root for all relative URLs in this source map.
 */
function SourceMapGenerator(aArgs) {
  if (!aArgs) {
    aArgs = {};
  }
  this._file = util.getArg(aArgs, 'file', null);
  this._sourceRoot = util.getArg(aArgs, 'sourceRoot', null);
  this._skipValidation = util.getArg(aArgs, 'skipValidation', false);
  this._sources = new ArraySet();
  this._names = new ArraySet();
  this._mappings = new MappingList();
  this._sourcesContents = null;
}

SourceMapGenerator.prototype._version = 3;

/**
 * Creates a new SourceMapGenerator based on a SourceMapConsumer
 *
 * @param aSourceMapConsumer The SourceMap.
 */
SourceMapGenerator.fromSourceMap = function SourceMapGenerator_fromSourceMap(aSourceMapConsumer) {
  var sourceRoot = aSourceMapConsumer.sourceRoot;
  var generator = new SourceMapGenerator({
    file: aSourceMapConsumer.file,
    sourceRoot: sourceRoot
  });
  aSourceMapConsumer.eachMapping(function (mapping) {
    var newMapping = {
      generated: {
        line: mapping.generatedLine,
        column: mapping.generatedColumn
      }
    };

    if (mapping.source != null) {
      newMapping.source = mapping.source;
      if (sourceRoot != null) {
        newMapping.source = util.relative(sourceRoot, newMapping.source);
      }

      newMapping.original = {
        line: mapping.originalLine,
        column: mapping.originalColumn
      };

      if (mapping.name != null) {
        newMapping.name = mapping.name;
      }
    }

    generator.addMapping(newMapping);
  });
  aSourceMapConsumer.sources.forEach(function (sourceFile) {
    var sourceRelative = sourceFile;
    if (sourceRoot !== null) {
      sourceRelative = util.relative(sourceRoot, sourceFile);
    }

    if (!generator._sources.has(sourceRelative)) {
      generator._sources.add(sourceRelative);
    }

    var content = aSourceMapConsumer.sourceContentFor(sourceFile);
    if (content != null) {
      generator.setSourceContent(sourceFile, content);
    }
  });
  return generator;
};

/**
 * Add a single mapping from original source line and column to the generated
 * source's line and column for this source map being created. The mapping
 * object should have the following properties:
 *
 *   - generated: An object with the generated line and column positions.
 *   - original: An object with the original line and column positions.
 *   - source: The original source file (relative to the sourceRoot).
 *   - name: An optional original token name for this mapping.
 */
SourceMapGenerator.prototype.addMapping = function SourceMapGenerator_addMapping(aArgs) {
  var generated = util.getArg(aArgs, 'generated');
  var original = util.getArg(aArgs, 'original', null);
  var source = util.getArg(aArgs, 'source', null);
  var name = util.getArg(aArgs, 'name', null);

  if (!this._skipValidation) {
    this._validateMapping(generated, original, source, name);
  }

  if (source != null) {
    source = String(source);
    if (!this._sources.has(source)) {
      this._sources.add(source);
    }
  }

  if (name != null) {
    name = String(name);
    if (!this._names.has(name)) {
      this._names.add(name);
    }
  }

  this._mappings.add({
    generatedLine: generated.line,
    generatedColumn: generated.column,
    originalLine: original != null && original.line,
    originalColumn: original != null && original.column,
    source: source,
    name: name
  });
};

/**
 * Set the source content for a source file.
 */
SourceMapGenerator.prototype.setSourceContent = function SourceMapGenerator_setSourceContent(aSourceFile, aSourceContent) {
  var source = aSourceFile;
  if (this._sourceRoot != null) {
    source = util.relative(this._sourceRoot, source);
  }

  if (aSourceContent != null) {
    // Add the source content to the _sourcesContents map.
    // Create a new _sourcesContents map if the property is null.
    if (!this._sourcesContents) {
      this._sourcesContents = Object.create(null);
    }
    this._sourcesContents[util.toSetString(source)] = aSourceContent;
  } else if (this._sourcesContents) {
    // Remove the source file from the _sourcesContents map.
    // If the _sourcesContents map is empty, set the property to null.
    delete this._sourcesContents[util.toSetString(source)];
    if (Object.keys(this._sourcesContents).length === 0) {
      this._sourcesContents = null;
    }
  }
};

/**
 * Applies the mappings of a sub-source-map for a specific source file to the
 * source map being generated. Each mapping to the supplied source file is
 * rewritten using the supplied source map. Note: The resolution for the
 * resulting mappings is the minimium of this map and the supplied map.
 *
 * @param aSourceMapConsumer The source map to be applied.
 * @param aSourceFile Optional. The filename of the source file.
 *        If omitted, SourceMapConsumer's file property will be used.
 * @param aSourceMapPath Optional. The dirname of the path to the source map
 *        to be applied. If relative, it is relative to the SourceMapConsumer.
 *        This parameter is needed when the two source maps aren't in the same
 *        directory, and the source map to be applied contains relative source
 *        paths. If so, those relative source paths need to be rewritten
 *        relative to the SourceMapGenerator.
 */
SourceMapGenerator.prototype.applySourceMap = function SourceMapGenerator_applySourceMap(aSourceMapConsumer, aSourceFile, aSourceMapPath) {
  var sourceFile = aSourceFile;
  // If aSourceFile is omitted, we will use the file property of the SourceMap
  if (aSourceFile == null) {
    if (aSourceMapConsumer.file == null) {
      throw new Error('SourceMapGenerator.prototype.applySourceMap requires either an explicit source file, ' + 'or the source map\'s "file" property. Both were omitted.');
    }
    sourceFile = aSourceMapConsumer.file;
  }
  var sourceRoot = this._sourceRoot;
  // Make "sourceFile" relative if an absolute Url is passed.
  if (sourceRoot != null) {
    sourceFile = util.relative(sourceRoot, sourceFile);
  }
  // Applying the SourceMap can add and remove items from the sources and
  // the names array.
  var newSources = new ArraySet();
  var newNames = new ArraySet();

  // Find mappings for the "sourceFile"
  this._mappings.unsortedForEach(function (mapping) {
    if (mapping.source === sourceFile && mapping.originalLine != null) {
      // Check if it can be mapped by the source map, then update the mapping.
      var original = aSourceMapConsumer.originalPositionFor({
        line: mapping.originalLine,
        column: mapping.originalColumn
      });
      if (original.source != null) {
        // Copy mapping
        mapping.source = original.source;
        if (aSourceMapPath != null) {
          mapping.source = util.join(aSourceMapPath, mapping.source);
        }
        if (sourceRoot != null) {
          mapping.source = util.relative(sourceRoot, mapping.source);
        }
        mapping.originalLine = original.line;
        mapping.originalColumn = original.column;
        if (original.name != null) {
          mapping.name = original.name;
        }
      }
    }

    var source = mapping.source;
    if (source != null && !newSources.has(source)) {
      newSources.add(source);
    }

    var name = mapping.name;
    if (name != null && !newNames.has(name)) {
      newNames.add(name);
    }
  }, this);
  this._sources = newSources;
  this._names = newNames;

  // Copy sourcesContents of applied map.
  aSourceMapConsumer.sources.forEach(function (sourceFile) {
    var content = aSourceMapConsumer.sourceContentFor(sourceFile);
    if (content != null) {
      if (aSourceMapPath != null) {
        sourceFile = util.join(aSourceMapPath, sourceFile);
      }
      if (sourceRoot != null) {
        sourceFile = util.relative(sourceRoot, sourceFile);
      }
      this.setSourceContent(sourceFile, content);
    }
  }, this);
};

/**
 * A mapping can have one of the three levels of data:
 *
 *   1. Just the generated position.
 *   2. The Generated position, original position, and original source.
 *   3. Generated and original position, original source, as well as a name
 *      token.
 *
 * To maintain consistency, we validate that any new mapping being added falls
 * in to one of these categories.
 */
SourceMapGenerator.prototype._validateMapping = function SourceMapGenerator_validateMapping(aGenerated, aOriginal, aSource, aName) {
  // When aOriginal is truthy but has empty values for .line and .column,
  // it is most likely a programmer error. In this case we throw a very
  // specific error message to try to guide them the right way.
  // For example: https://github.com/Polymer/polymer-bundler/pull/519
  if (aOriginal && typeof aOriginal.line !== 'number' && typeof aOriginal.column !== 'number') {
    throw new Error('original.line and original.column are not numbers -- you probably meant to omit ' + 'the original mapping entirely and only map the generated position. If so, pass ' + 'null for the original mapping instead of an object with empty or null values.');
  }

  if (aGenerated && 'line' in aGenerated && 'column' in aGenerated && aGenerated.line > 0 && aGenerated.column >= 0 && !aOriginal && !aSource && !aName) {
    // Case 1.
    return;
  } else if (aGenerated && 'line' in aGenerated && 'column' in aGenerated && aOriginal && 'line' in aOriginal && 'column' in aOriginal && aGenerated.line > 0 && aGenerated.column >= 0 && aOriginal.line > 0 && aOriginal.column >= 0 && aSource) {
    // Cases 2 and 3.
    return;
  } else {
    throw new Error('Invalid mapping: ' + JSON.stringify({
      generated: aGenerated,
      source: aSource,
      original: aOriginal,
      name: aName
    }));
  }
};

/**
 * Serialize the accumulated mappings in to the stream of base 64 VLQs
 * specified by the source map format.
 */
SourceMapGenerator.prototype._serializeMappings = function SourceMapGenerator_serializeMappings() {
  var previousGeneratedColumn = 0;
  var previousGeneratedLine = 1;
  var previousOriginalColumn = 0;
  var previousOriginalLine = 0;
  var previousName = 0;
  var previousSource = 0;
  var result = '';
  var next;
  var mapping;
  var nameIdx;
  var sourceIdx;

  var mappings = this._mappings.toArray();
  for (var i = 0, len = mappings.length; i < len; i++) {
    mapping = mappings[i];
    next = '';

    if (mapping.generatedLine !== previousGeneratedLine) {
      previousGeneratedColumn = 0;
      while (mapping.generatedLine !== previousGeneratedLine) {
        next += ';';
        previousGeneratedLine++;
      }
    } else {
      if (i > 0) {
        if (!util.compareByGeneratedPositionsInflated(mapping, mappings[i - 1])) {
          continue;
        }
        next += ',';
      }
    }

    next += base64VLQ.encode(mapping.generatedColumn - previousGeneratedColumn);
    previousGeneratedColumn = mapping.generatedColumn;

    if (mapping.source != null) {
      sourceIdx = this._sources.indexOf(mapping.source);
      next += base64VLQ.encode(sourceIdx - previousSource);
      previousSource = sourceIdx;

      // lines are stored 0-based in SourceMap spec version 3
      next += base64VLQ.encode(mapping.originalLine - 1 - previousOriginalLine);
      previousOriginalLine = mapping.originalLine - 1;

      next += base64VLQ.encode(mapping.originalColumn - previousOriginalColumn);
      previousOriginalColumn = mapping.originalColumn;

      if (mapping.name != null) {
        nameIdx = this._names.indexOf(mapping.name);
        next += base64VLQ.encode(nameIdx - previousName);
        previousName = nameIdx;
      }
    }

    result += next;
  }

  return result;
};

SourceMapGenerator.prototype._generateSourcesContent = function SourceMapGenerator_generateSourcesContent(aSources, aSourceRoot) {
  return aSources.map(function (source) {
    if (!this._sourcesContents) {
      return null;
    }
    if (aSourceRoot != null) {
      source = util.relative(aSourceRoot, source);
    }
    var key = util.toSetString(source);
    return Object.prototype.hasOwnProperty.call(this._sourcesContents, key) ? this._sourcesContents[key] : null;
  }, this);
};

/**
 * Externalize the source map.
 */
SourceMapGenerator.prototype.toJSON = function SourceMapGenerator_toJSON() {
  var map = {
    version: this._version,
    sources: this._sources.toArray(),
    names: this._names.toArray(),
    mappings: this._serializeMappings()
  };
  if (this._file != null) {
    map.file = this._file;
  }
  if (this._sourceRoot != null) {
    map.sourceRoot = this._sourceRoot;
  }
  if (this._sourcesContents) {
    map.sourcesContent = this._generateSourcesContent(map.sources, map.sourceRoot);
  }

  return map;
};

/**
 * Render the source map being generated to a string.
 */
SourceMapGenerator.prototype.toString = function SourceMapGenerator_toString() {
  return JSON.stringify(this.toJSON());
};

exports.SourceMapGenerator = SourceMapGenerator;

/***/ }),
/* 57 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/* -*- Mode: js; js-indent-level: 2; -*- */
/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 *
 * Based on the Base 64 VLQ implementation in Closure Compiler:
 * https://code.google.com/p/closure-compiler/source/browse/trunk/src/com/google/debugging/sourcemap/Base64VLQ.java
 *
 * Copyright 2011 The Closure Compiler Authors. All rights reserved.
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are
 * met:
 *
 *  * Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *  * Redistributions in binary form must reproduce the above
 *    copyright notice, this list of conditions and the following
 *    disclaimer in the documentation and/or other materials provided
 *    with the distribution.
 *  * Neither the name of Google Inc. nor the names of its
 *    contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

var base64 = __webpack_require__(162);

// A single base 64 digit can contain 6 bits of data. For the base 64 variable
// length quantities we use in the source map spec, the first bit is the sign,
// the next four bits are the actual value, and the 6th bit is the
// continuation bit. The continuation bit tells us whether there are more
// digits in this value following this digit.
//
//   Continuation
//   |    Sign
//   |    |
//   V    V
//   101011

var VLQ_BASE_SHIFT = 5;

// binary: 100000
var VLQ_BASE = 1 << VLQ_BASE_SHIFT;

// binary: 011111
var VLQ_BASE_MASK = VLQ_BASE - 1;

// binary: 100000
var VLQ_CONTINUATION_BIT = VLQ_BASE;

/**
 * Converts from a two-complement value to a value where the sign bit is
 * placed in the least significant bit.  For example, as decimals:
 *   1 becomes 2 (10 binary), -1 becomes 3 (11 binary)
 *   2 becomes 4 (100 binary), -2 becomes 5 (101 binary)
 */
function toVLQSigned(aValue) {
  return aValue < 0 ? (-aValue << 1) + 1 : (aValue << 1) + 0;
}

/**
 * Converts to a two-complement value from a value where the sign bit is
 * placed in the least significant bit.  For example, as decimals:
 *   2 (10 binary) becomes 1, 3 (11 binary) becomes -1
 *   4 (100 binary) becomes 2, 5 (101 binary) becomes -2
 */
function fromVLQSigned(aValue) {
  var isNegative = (aValue & 1) === 1;
  var shifted = aValue >> 1;
  return isNegative ? -shifted : shifted;
}

/**
 * Returns the base 64 VLQ encoded value.
 */
exports.encode = function base64VLQ_encode(aValue) {
  var encoded = "";
  var digit;

  var vlq = toVLQSigned(aValue);

  do {
    digit = vlq & VLQ_BASE_MASK;
    vlq >>>= VLQ_BASE_SHIFT;
    if (vlq > 0) {
      // There are still more digits in this value, so we must make sure the
      // continuation bit is marked.
      digit |= VLQ_CONTINUATION_BIT;
    }
    encoded += base64.encode(digit);
  } while (vlq > 0);

  return encoded;
};

/**
 * Decodes the next base 64 VLQ value from the given string and returns the
 * value and the rest of the string via the out parameter.
 */
exports.decode = function base64VLQ_decode(aStr, aIndex, aOutParam) {
  var strLen = aStr.length;
  var result = 0;
  var shift = 0;
  var continuation, digit;

  do {
    if (aIndex >= strLen) {
      throw new Error("Expected more digits in base 64 VLQ value.");
    }

    digit = base64.decode(aStr.charCodeAt(aIndex++));
    if (digit === -1) {
      throw new Error("Invalid base64 digit: " + aStr.charAt(aIndex - 1));
    }

    continuation = !!(digit & VLQ_CONTINUATION_BIT);
    digit &= VLQ_BASE_MASK;
    result = result + (digit << shift);
    shift += VLQ_BASE_SHIFT;
  } while (continuation);

  aOutParam.value = fromVLQSigned(result);
  aOutParam.rest = aIndex;
};

/***/ }),
/* 58 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/* -*- Mode: js; js-indent-level: 2; -*- */
/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */

var util = __webpack_require__(23);
var has = Object.prototype.hasOwnProperty;
var hasNativeMap = typeof Map !== "undefined";

/**
 * A data structure which is a combination of an array and a set. Adding a new
 * member is O(1), testing for membership is O(1), and finding the index of an
 * element is O(1). Removing elements from the set is not supported. Only
 * strings are supported for membership.
 */
function ArraySet() {
  this._array = [];
  this._set = hasNativeMap ? new Map() : Object.create(null);
}

/**
 * Static method for creating ArraySet instances from an existing array.
 */
ArraySet.fromArray = function ArraySet_fromArray(aArray, aAllowDuplicates) {
  var set = new ArraySet();
  for (var i = 0, len = aArray.length; i < len; i++) {
    set.add(aArray[i], aAllowDuplicates);
  }
  return set;
};

/**
 * Return how many unique items are in this ArraySet. If duplicates have been
 * added, than those do not count towards the size.
 *
 * @returns Number
 */
ArraySet.prototype.size = function ArraySet_size() {
  return hasNativeMap ? this._set.size : Object.getOwnPropertyNames(this._set).length;
};

/**
 * Add the given string to this set.
 *
 * @param String aStr
 */
ArraySet.prototype.add = function ArraySet_add(aStr, aAllowDuplicates) {
  var sStr = hasNativeMap ? aStr : util.toSetString(aStr);
  var isDuplicate = hasNativeMap ? this.has(aStr) : has.call(this._set, sStr);
  var idx = this._array.length;
  if (!isDuplicate || aAllowDuplicates) {
    this._array.push(aStr);
  }
  if (!isDuplicate) {
    if (hasNativeMap) {
      this._set.set(aStr, idx);
    } else {
      this._set[sStr] = idx;
    }
  }
};

/**
 * Is the given string a member of this set?
 *
 * @param String aStr
 */
ArraySet.prototype.has = function ArraySet_has(aStr) {
  if (hasNativeMap) {
    return this._set.has(aStr);
  } else {
    var sStr = util.toSetString(aStr);
    return has.call(this._set, sStr);
  }
};

/**
 * What is the index of the given string in the array?
 *
 * @param String aStr
 */
ArraySet.prototype.indexOf = function ArraySet_indexOf(aStr) {
  if (hasNativeMap) {
    var idx = this._set.get(aStr);
    if (idx >= 0) {
      return idx;
    }
  } else {
    var sStr = util.toSetString(aStr);
    if (has.call(this._set, sStr)) {
      return this._set[sStr];
    }
  }

  throw new Error('"' + aStr + '" is not in the set.');
};

/**
 * What is the element at the given index?
 *
 * @param Number aIdx
 */
ArraySet.prototype.at = function ArraySet_at(aIdx) {
  if (aIdx >= 0 && aIdx < this._array.length) {
    return this._array[aIdx];
  }
  throw new Error('No element indexed by ' + aIdx);
};

/**
 * Returns the array representation of this set (which has the proper indices
 * indicated by indexOf). Note that this is a copy of the internal array used
 * for storing the members so that no one can mess with internal state.
 */
ArraySet.prototype.toArray = function ArraySet_toArray() {
  return this._array.slice();
};

exports.ArraySet = ArraySet;

/***/ }),
/* 59 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.GenericProvider = undefined;

var _bluebirdLst;

function _load_bluebirdLst() {
    return _bluebirdLst = __webpack_require__(2);
}

var _builderUtilRuntime;

function _load_builderUtilRuntime() {
    return _builderUtilRuntime = __webpack_require__(3);
}

var _main;

function _load_main() {
    return _main = __webpack_require__(8);
}

var _Provider;

function _load_Provider() {
    return _Provider = __webpack_require__(14);
}

class GenericProvider extends (_main || _load_main()).Provider {
    constructor(configuration, updater, useMultipleRangeRequest = true) {
        super(updater.httpExecutor, useMultipleRangeRequest);
        this.configuration = configuration;
        this.updater = updater;
        this.baseUrl = (0, (_main || _load_main()).newBaseUrl)(this.configuration.url);
    }
    get channel() {
        const result = this.updater.channel || this.configuration.channel;
        return result == null ? (0, (_main || _load_main()).getDefaultChannelName)() : (0, (_main || _load_main()).getCustomChannelName)(result);
    }
    getLatestVersion() {
        var _this = this;

        return (0, (_bluebirdLst || _load_bluebirdLst()).coroutine)(function* () {
            let result;
            const channelFile = (0, (_main || _load_main()).getChannelFilename)(_this.channel);
            const channelUrl = (0, (_main || _load_main()).newUrlFromBase)(channelFile, _this.baseUrl);
            for (let attemptNumber = 0;; attemptNumber++) {
                try {
                    result = (0, (_Provider || _load_Provider()).parseUpdateInfo)((yield _this.httpRequest(channelUrl)), channelFile, channelUrl);
                    break;
                } catch (e) {
                    if (e instanceof (_builderUtilRuntime || _load_builderUtilRuntime()).HttpError && e.statusCode === 404) {
                        throw (0, (_builderUtilRuntime || _load_builderUtilRuntime()).newError)(`Cannot find channel "${channelFile}" update info: ${e.stack || e.message}`, "ERR_UPDATER_CHANNEL_FILE_NOT_FOUND");
                    } else if (e.code === "ECONNREFUSED") {
                        if (attemptNumber < 3) {
                            yield new Promise(function (resolve, reject) {
                                try {
                                    setTimeout(resolve, 1000 * attemptNumber);
                                } catch (e) {
                                    reject(e);
                                }
                            });
                            continue;
                        }
                    }
                    throw e;
                }
            }
            if ((0, (_main || _load_main()).isUseOldMacProvider)()) {
                result.releaseJsonUrl = channelUrl.href;
            }
            return result;
        })();
    }
    resolveFiles(updateInfo) {
        return (0, (_Provider || _load_Provider()).resolveFiles)(updateInfo, this.baseUrl);
    }
}
exports.GenericProvider = GenericProvider; //# sourceMappingURL=GenericProvider.js.map

/***/ }),
/* 60 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.GitHubProvider = exports.BaseGitHubProvider = undefined;

var _bluebirdLst;

function _load_bluebirdLst() {
    return _bluebirdLst = __webpack_require__(2);
}

exports.computeReleaseNotes = computeReleaseNotes;

var _builderUtilRuntime;

function _load_builderUtilRuntime() {
    return _builderUtilRuntime = __webpack_require__(3);
}

var _semver;

function _load_semver() {
    return _semver = _interopRequireWildcard(__webpack_require__(55));
}

var _main;

function _load_main() {
    return _main = __webpack_require__(8);
}

var _Provider;

function _load_Provider() {
    return _Provider = __webpack_require__(14);
}

function _interopRequireWildcard(obj) {
    if (obj && obj.__esModule) {
        return obj;
    } else {
        var newObj = {};if (obj != null) {
            for (var key in obj) {
                if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key];
            }
        }newObj.default = obj;return newObj;
    }
}

class BaseGitHubProvider extends (_main || _load_main()).Provider {
    constructor(options, defaultHost, executor) {
        super(executor, false /* because GitHib uses S3 */);
        this.options = options;
        this.baseUrl = (0, (_main || _load_main()).newBaseUrl)((0, (_builderUtilRuntime || _load_builderUtilRuntime()).githubUrl)(options, defaultHost));
    }
    computeGithubBasePath(result) {
        // https://github.com/electron-userland/electron-builder/issues/1903#issuecomment-320881211
        const host = this.options.host;
        return host != null && host !== "github.com" && host !== "api.github.com" ? `/api/v3${result}` : result;
    }
}
exports.BaseGitHubProvider = BaseGitHubProvider;
class GitHubProvider extends BaseGitHubProvider {
    constructor(options, updater, executor) {
        super(options, "github.com", executor);
        this.options = options;
        this.updater = updater;
    }
    getLatestVersion() {
        var _this = this;

        return (0, (_bluebirdLst || _load_bluebirdLst()).coroutine)(function* () {
            const basePath = _this.basePath;
            const cancellationToken = new (_builderUtilRuntime || _load_builderUtilRuntime()).CancellationToken();
            const feedXml = yield _this.httpRequest((0, (_main || _load_main()).newUrlFromBase)(`${basePath}.atom`, _this.baseUrl), {
                Accept: "application/xml, application/atom+xml, text/xml, */*"
            }, cancellationToken);
            const feed = (0, (_builderUtilRuntime || _load_builderUtilRuntime()).parseXml)(feedXml);
            const latestRelease = feed.element("entry", false, `No published versions on GitHub`);
            let version;
            try {
                if (_this.updater.allowPrerelease) {
                    // noinspection TypeScriptValidateJSTypes
                    version = latestRelease.element("link").attribute("href").match(/\/tag\/v?([^\/]+)$/)[1];
                } else {
                    version = yield _this.getLatestVersionString(basePath, cancellationToken);
                }
            } catch (e) {
                throw (0, (_builderUtilRuntime || _load_builderUtilRuntime()).newError)(`Cannot parse releases feed: ${e.stack || e.message},\nXML:\n${feedXml}`, "ERR_UPDATER_INVALID_RELEASE_FEED");
            }
            if (version == null) {
                throw (0, (_builderUtilRuntime || _load_builderUtilRuntime()).newError)(`No published versions on GitHub`, "ERR_UPDATER_NO_PUBLISHED_VERSIONS");
            }
            const channelFile = (0, (_main || _load_main()).getChannelFilename)((0, (_main || _load_main()).getDefaultChannelName)());
            const channelFileUrl = (0, (_main || _load_main()).newUrlFromBase)(_this.getBaseDownloadPath(version, channelFile), _this.baseUrl);
            const requestOptions = _this.createRequestOptions(channelFileUrl);
            let rawData;
            try {
                rawData = yield _this.executor.request(requestOptions, cancellationToken);
            } catch (e) {
                if (!_this.updater.allowPrerelease && e instanceof (_builderUtilRuntime || _load_builderUtilRuntime()).HttpError && e.statusCode === 404) {
                    throw (0, (_builderUtilRuntime || _load_builderUtilRuntime()).newError)(`Cannot find ${channelFile} in the latest release artifacts (${channelFileUrl}): ${e.stack || e.message}`, "ERR_UPDATER_CHANNEL_FILE_NOT_FOUND");
                }
                throw e;
            }
            const result = (0, (_Provider || _load_Provider()).parseUpdateInfo)(rawData, channelFile, channelFileUrl);
            if ((0, (_main || _load_main()).isUseOldMacProvider)()) {
                result.releaseJsonUrl = `${(0, (_builderUtilRuntime || _load_builderUtilRuntime()).githubUrl)(_this.options)}/${requestOptions.path}`;
            }
            if (result.releaseName == null) {
                result.releaseName = latestRelease.elementValueOrEmpty("title");
            }
            if (result.releaseNotes == null) {
                result.releaseNotes = computeReleaseNotes(_this.updater.currentVersion, _this.updater.fullChangelog, feed, latestRelease);
            }
            return result;
        })();
    }
    getLatestVersionString(basePath, cancellationToken) {
        var _this2 = this;

        return (0, (_bluebirdLst || _load_bluebirdLst()).coroutine)(function* () {
            const url = (0, (_main || _load_main()).newUrlFromBase)(`${basePath}/latest`, _this2.baseUrl);
            try {
                // do not use API to avoid limit
                const rawData = yield _this2.httpRequest(url, { Accept: "application/json" }, cancellationToken);
                if (rawData == null) {
                    return null;
                }
                const releaseInfo = JSON.parse(rawData);
                return releaseInfo.tag_name.startsWith("v") ? releaseInfo.tag_name.substring(1) : releaseInfo.tag_name;
            } catch (e) {
                throw (0, (_builderUtilRuntime || _load_builderUtilRuntime()).newError)(`Unable to find latest version on GitHub (${url}), please ensure a production release exists: ${e.stack || e.message}`, "ERR_UPDATER_LATEST_VERSION_NOT_FOUND");
            }
        })();
    }
    get basePath() {
        return this.computeGithubBasePath(`/${this.options.owner}/${this.options.repo}/releases`);
    }
    resolveFiles(updateInfo) {
        // still replace space to - due to backward compatibility
        return (0, (_Provider || _load_Provider()).resolveFiles)(updateInfo, this.baseUrl, p => this.getBaseDownloadPath(updateInfo.version, p.replace(/ /g, "-")));
    }
    getBaseDownloadPath(version, fileName) {
        return `${this.basePath}/download/${this.options.vPrefixedTagName === false ? "" : "v"}${version}/${fileName}`;
    }
}
exports.GitHubProvider = GitHubProvider;
function getNoteValue(parent) {
    const result = parent.elementValueOrEmpty("content");
    // GitHub reports empty notes as <content>No content.</content>
    return result === "No content." ? "" : result;
}
function computeReleaseNotes(currentVersion, isFullChangelog, feed, latestRelease) {
    if (!isFullChangelog) {
        return getNoteValue(latestRelease);
    }
    const releaseNotes = [];
    for (const release of feed.getElements("entry")) {
        // noinspection TypeScriptValidateJSTypes
        const versionRelease = release.element("link").attribute("href").match(/\/tag\/v?([^\/]+)$/)[1];
        if ((_semver || _load_semver()).lt(currentVersion, versionRelease)) {
            releaseNotes.push({
                version: versionRelease,
                note: getNoteValue(release)
            });
        }
    }
    return releaseNotes.sort((a, b) => (_semver || _load_semver()).rcompare(a.version, b.version));
}
//# sourceMappingURL=GitHubProvider.js.map

/***/ }),
/* 61 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.BaseUpdater = undefined;

var _bluebirdLst;

function _load_bluebirdLst() {
    return _bluebirdLst = __webpack_require__(2);
}

var _builderUtilRuntime;

function _load_builderUtilRuntime() {
    return _builderUtilRuntime = __webpack_require__(3);
}

var _fsExtraP;

function _load_fsExtraP() {
    return _fsExtraP = __webpack_require__(9);
}

var _os;

function _load_os() {
    return _os = __webpack_require__(15);
}

var _path = _interopRequireWildcard(__webpack_require__(0));

var _AppUpdater;

function _load_AppUpdater() {
    return _AppUpdater = __webpack_require__(27);
}

var _DownloadedUpdateHelper;

function _load_DownloadedUpdateHelper() {
    return _DownloadedUpdateHelper = __webpack_require__(175);
}

var _main;

function _load_main() {
    return _main = __webpack_require__(8);
}

function _interopRequireWildcard(obj) {
    if (obj && obj.__esModule) {
        return obj;
    } else {
        var newObj = {};if (obj != null) {
            for (var key in obj) {
                if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key];
            }
        }newObj.default = obj;return newObj;
    }
}

class BaseUpdater extends (_AppUpdater || _load_AppUpdater()).AppUpdater {
    constructor(options, app) {
        super(options, app);
        this.downloadedUpdateHelper = new (_DownloadedUpdateHelper || _load_DownloadedUpdateHelper()).DownloadedUpdateHelper();
        this.quitAndInstallCalled = false;
        this.quitHandlerAdded = false;
    }
    quitAndInstall(isSilent = false, isForceRunAfter = false) {
        this._logger.info(`Install on explicit quitAndInstall`);
        if (this.install(isSilent, isSilent ? isForceRunAfter : true)) {
            setImmediate(() => {
                this.app.quit();
            });
        }
    }
    executeDownload(downloadOptions, fileInfo, task) {
        var _this = this;

        return (0, (_bluebirdLst || _load_bluebirdLst()).coroutine)(function* () {
            if (_this.listenerCount((_main || _load_main()).DOWNLOAD_PROGRESS) > 0) {
                downloadOptions.onProgress = function (it) {
                    return _this.emit((_main || _load_main()).DOWNLOAD_PROGRESS, it);
                };
            }
            // use TEST_APP_TMP_DIR if defined and developer machine (must be not windows due to security reasons - we must not use env var in the production)
            const tempDir = yield (0, (_fsExtraP || _load_fsExtraP()).mkdtemp)(`${_path.join((process.platform === "darwin" ? process.env.TEST_APP_TMP_DIR : null) || (0, (_os || _load_os()).tmpdir)(), "up")}-`);
            const removeTempDirIfAny = function () {
                _this.downloadedUpdateHelper.clear();
                return (0, (_fsExtraP || _load_fsExtraP()).remove)(tempDir).catch(function () {
                    // ignored
                });
            };
            try {
                const destinationFile = _path.join(tempDir, _path.posix.basename(fileInfo.info.url));
                yield task(tempDir, destinationFile, removeTempDirIfAny);
                _this._logger.info(`New version ${_this.updateInfo.version} has been downloaded to ${destinationFile}`);
            } catch (e) {
                yield removeTempDirIfAny();
                if (e instanceof (_builderUtilRuntime || _load_builderUtilRuntime()).CancellationError) {
                    _this.emit("update-cancelled", _this.updateInfo);
                    _this._logger.info("Cancelled");
                }
                throw e;
            }
        })();
    }
    install(isSilent, isRunAfter) {
        if (this.quitAndInstallCalled) {
            this._logger.warn("install call ignored: quitAndInstallCalled is set to true");
            return false;
        }
        const installerPath = this.downloadedUpdateHelper.file;
        if (!this.updateAvailable || installerPath == null) {
            this.dispatchError(new Error("No update available, can't quit and install"));
            return false;
        }
        // prevent calling several times
        this.quitAndInstallCalled = true;
        try {
            this._logger.info(`Install: isSilent: ${isSilent}, isRunAfter: ${isRunAfter}`);
            return this.doInstall(installerPath, isSilent, isRunAfter);
        } catch (e) {
            this.dispatchError(e);
            return false;
        }
    }
    addQuitHandler() {
        if (this.quitHandlerAdded) {
            return;
        }
        this.quitHandlerAdded = true;
        this.app.once("quit", () => {
            if (!this.quitAndInstallCalled) {
                this._logger.info("Auto install update on quit");
                this.install(true, false);
            }
        });
    }
}
exports.BaseUpdater = BaseUpdater; //# sourceMappingURL=BaseUpdater.js.map

/***/ }),
/* 62 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.FileWithEmbeddedBlockMapDifferentialDownloader = undefined;

var _bluebirdLst;

function _load_bluebirdLst() {
    return _bluebirdLst = __webpack_require__(2);
}

var _blockMapApi;

function _load_blockMapApi() {
    return _blockMapApi = __webpack_require__(63);
}

var _DifferentialDownloader;

function _load_DifferentialDownloader() {
    return _DifferentialDownloader = __webpack_require__(65);
}

class FileWithEmbeddedBlockMapDifferentialDownloader extends (_DifferentialDownloader || _load_DifferentialDownloader()).DifferentialDownloader {
    download() {
        var _this = this;

        return (0, (_bluebirdLst || _load_bluebirdLst()).coroutine)(function* () {
            const packageInfo = _this.blockAwareFileInfo;
            const fileSize = packageInfo.size;
            const offset = fileSize - (packageInfo.blockMapSize + 4);
            _this.fileMetadataBuffer = yield _this.readRemoteBytes(offset, fileSize - 1);
            const newBlockMap = yield (0, (_DifferentialDownloader || _load_DifferentialDownloader()).readBlockMap)(_this.fileMetadataBuffer.slice(0, _this.fileMetadataBuffer.length - 4));
            yield _this.doDownload(JSON.parse((yield (0, (_blockMapApi || _load_blockMapApi()).readEmbeddedBlockMapData)(_this.options.oldFile))), newBlockMap);
        })();
    }
}
exports.FileWithEmbeddedBlockMapDifferentialDownloader = FileWithEmbeddedBlockMapDifferentialDownloader; //# sourceMappingURL=FileWithEmbeddedBlockMapDifferentialDownloader.js.map

/***/ }),
/* 63 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.readEmbeddedBlockMapData = exports.BLOCK_MAP_FILE_NAME = undefined;

var _bluebirdLst;

function _load_bluebirdLst() {
    return _bluebirdLst = __webpack_require__(2);
}

var _bluebirdLst2;

function _load_bluebirdLst2() {
    return _bluebirdLst2 = _interopRequireDefault(__webpack_require__(2));
}

let readEmbeddedBlockMapData = exports.readEmbeddedBlockMapData = (() => {
    var _ref = (0, (_bluebirdLst || _load_bluebirdLst()).coroutine)(function* (file) {
        const fd = yield (0, (_fsExtraP || _load_fsExtraP()).open)(file, "r");
        try {
            const fileSize = (yield (0, (_fsExtraP || _load_fsExtraP()).fstat)(fd)).size;
            const sizeBuffer = Buffer.allocUnsafe(4);
            yield (0, (_fsExtraP || _load_fsExtraP()).read)(fd, sizeBuffer, 0, sizeBuffer.length, fileSize - sizeBuffer.length);
            const dataBuffer = Buffer.allocUnsafe(sizeBuffer.readUInt32BE(0));
            yield (0, (_fsExtraP || _load_fsExtraP()).read)(fd, dataBuffer, 0, dataBuffer.length, fileSize - sizeBuffer.length - dataBuffer.length);
            yield (0, (_fsExtraP || _load_fsExtraP()).close)(fd);
            const inflateRaw = (_bluebirdLst2 || _load_bluebirdLst2()).default.promisify(__webpack_require__(64).inflateRaw);
            return (yield inflateRaw(dataBuffer)).toString();
        } catch (e) {
            yield (0, (_fsExtraP || _load_fsExtraP()).close)(fd);
            throw e;
        }
    });

    return function readEmbeddedBlockMapData(_x) {
        return _ref.apply(this, arguments);
    };
})();
//# sourceMappingURL=blockMapApi.js.map


var _fsExtraP;

function _load_fsExtraP() {
    return _fsExtraP = __webpack_require__(9);
}

function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
}

const BLOCK_MAP_FILE_NAME = exports.BLOCK_MAP_FILE_NAME = "_blockMap.blockmap";

/***/ }),
/* 64 */
/***/ (function(module, exports) {

module.exports = require("zlib");

/***/ }),
/* 65 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.readBlockMap = exports.DifferentialDownloader = exports.DifferentialDownloaderOptions = undefined;

var _bluebirdLst;

function _load_bluebirdLst() {
    return _bluebirdLst = __webpack_require__(2);
}

var _bluebirdLst2;

function _load_bluebirdLst2() {
    return _bluebirdLst2 = _interopRequireDefault(__webpack_require__(2));
}

let readBlockMap = exports.readBlockMap = (() => {
    var _ref = (0, (_bluebirdLst || _load_bluebirdLst()).coroutine)(function* (data) {
        return JSON.parse((yield inflateRaw(data)).toString());
    });

    return function readBlockMap(_x) {
        return _ref.apply(this, arguments);
    };
})();

var _builderUtilRuntime;

function _load_builderUtilRuntime() {
    return _builderUtilRuntime = __webpack_require__(3);
}

var _fsExtraP;

function _load_fsExtraP() {
    return _fsExtraP = __webpack_require__(9);
}

var _DataSplitter;

function _load_DataSplitter() {
    return _DataSplitter = __webpack_require__(66);
}

var _downloadPlanBuilder;

function _load_downloadPlanBuilder() {
    return _downloadPlanBuilder = __webpack_require__(35);
}

var _multipleRangeDownloader;

function _load_multipleRangeDownloader() {
    return _multipleRangeDownloader = __webpack_require__(178);
}

function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
}

const inflateRaw = (_bluebirdLst2 || _load_bluebirdLst2()).default.promisify(__webpack_require__(64).inflateRaw);
class DifferentialDownloaderOptions {}
exports.DifferentialDownloaderOptions = DifferentialDownloaderOptions;
class DifferentialDownloader {
    // noinspection TypeScriptAbstractClassConstructorCanBeMadeProtected
    constructor(blockAwareFileInfo, httpExecutor, options) {
        this.blockAwareFileInfo = blockAwareFileInfo;
        this.httpExecutor = httpExecutor;
        this.options = options;
        this.logger = options.logger;
        this.baseRequestOptions = (0, (_builderUtilRuntime || _load_builderUtilRuntime()).configureRequestOptionsFromUrl)(options.newUrl, {});
    }
    get signatureSize() {
        return 0;
    }
    createRequestOptions(method = "get", newUrl) {
        return Object.assign({}, newUrl == null ? this.baseRequestOptions : (0, (_builderUtilRuntime || _load_builderUtilRuntime()).configureRequestOptionsFromUrl)(newUrl, {}), { method, headers: Object.assign({}, this.options.requestHeaders, { Accept: "*/*" }) });
    }
    doDownload(oldBlockMap, newBlockMap) {
        // we don't check other metadata like compressionMethod - generic check that it is make sense to differentially update is suitable for it
        if (oldBlockMap.version !== newBlockMap.version) {
            throw new Error(`version is different (${oldBlockMap.version} - ${newBlockMap.version}), full download is required`);
        }
        const logger = this.logger;
        const operations = (0, (_downloadPlanBuilder || _load_downloadPlanBuilder()).computeOperations)(oldBlockMap, newBlockMap, logger);
        if (logger.debug != null) {
            logger.debug(JSON.stringify(operations, null, 2));
        }
        let downloadSize = 0;
        let copySize = 0;
        for (const operation of operations) {
            const length = operation.end - operation.start;
            if (operation.kind === (_downloadPlanBuilder || _load_downloadPlanBuilder()).OperationKind.DOWNLOAD) {
                downloadSize += length;
            } else {
                copySize += length;
            }
        }
        const newPackageSize = this.blockAwareFileInfo.size;
        if (downloadSize + copySize + (this.fileMetadataBuffer == null ? 0 : this.fileMetadataBuffer.length) + this.signatureSize !== newPackageSize) {
            throw new Error(`Internal error, size mismatch: downloadSize: ${downloadSize}, copySize: ${copySize}, newPackageSize: ${newPackageSize}`);
        }
        logger.info(`Full: ${formatBytes(newPackageSize)}, To download: ${formatBytes(downloadSize)} (${Math.round(downloadSize / (newPackageSize / 100))}%)`);
        return this.downloadFile(operations);
    }
    downloadFile(tasks) {
        var _this = this;

        return (0, (_bluebirdLst || _load_bluebirdLst()).coroutine)(function* () {
            const signature = _this.signatureSize === 0 ? null : yield _this.readRemoteBytes(0, _this.signatureSize - 1);
            const oldFileFd = yield (0, (_fsExtraP || _load_fsExtraP()).open)(_this.options.oldFile, "r");
            const newFileFd = yield (0, (_fsExtraP || _load_fsExtraP()).open)(_this.options.newFile, "w");
            const fileOut = (0, (_fsExtraP || _load_fsExtraP()).createWriteStream)(_this.options.newFile, { fd: newFileFd });
            yield new (_bluebirdLst2 || _load_bluebirdLst2()).default(function (resolve, reject) {
                const streams = [];
                const digestTransform = new (_builderUtilRuntime || _load_builderUtilRuntime()).DigestTransform(_this.blockAwareFileInfo.sha512);
                // to simply debug, do manual validation to allow file to be fully written
                digestTransform.isValidateOnEnd = false;
                streams.push(digestTransform);
                // noinspection JSArrowFunctionCanBeReplacedWithShorthand
                fileOut.on("finish", function () {
                    fileOut.close(function () {
                        try {
                            digestTransform.validate();
                        } catch (e) {
                            reject(e);
                            return;
                        }
                        resolve();
                    });
                });
                streams.push(fileOut);
                let lastStream = null;
                for (const stream of streams) {
                    stream.on("error", reject);
                    if (lastStream == null) {
                        lastStream = stream;
                    } else {
                        lastStream = lastStream.pipe(stream);
                    }
                }
                const firstStream = streams[0];
                let w;
                if (_this.options.useMultipleRangeRequest) {
                    w = (0, (_multipleRangeDownloader || _load_multipleRangeDownloader()).executeTasks)(_this, tasks, firstStream, oldFileFd, reject);
                } else {
                    let attemptCount = 0;
                    let actualUrl = null;
                    _this.logger.info(`Differential download: ${_this.options.newUrl}`);
                    w = function (index) {
                        if (index >= tasks.length) {
                            if (_this.fileMetadataBuffer != null) {
                                firstStream.write(_this.fileMetadataBuffer);
                            }
                            firstStream.end();
                            return;
                        }
                        const operation = tasks[index++];
                        if (operation.kind === (_downloadPlanBuilder || _load_downloadPlanBuilder()).OperationKind.COPY) {
                            (0, (_DataSplitter || _load_DataSplitter()).copyData)(operation, firstStream, oldFileFd, reject, function () {
                                return w(index);
                            });
                        } else {
                            const requestOptions = _this.createRequestOptions("get", actualUrl);
                            const range = `bytes=${operation.start}-${operation.end - 1}`;
                            requestOptions.headers.Range = range;
                            requestOptions.redirect = "manual";
                            const debug = _this.logger.debug;
                            if (debug != null) {
                                debug(`effective url: ${actualUrl == null ? "" : removeQuery(actualUrl)}, range: ${range}`);
                            }
                            const request = _this.httpExecutor.doRequest(requestOptions, function (response) {
                                // Electron net handles redirects automatically, our NodeJS test server doesn't use redirects - so, we don't check 3xx codes.
                                if (response.statusCode >= 400) {
                                    reject((0, (_builderUtilRuntime || _load_builderUtilRuntime()).createHttpError)(response));
                                }
                                response.pipe(firstStream, {
                                    end: false
                                });
                                response.once("end", function () {
                                    if (++attemptCount === 100) {
                                        attemptCount = 0;
                                        setTimeout(function () {
                                            return w(index);
                                        }, 1000);
                                    } else {
                                        w(index);
                                    }
                                });
                            });
                            request.on("redirect", function (statusCode, method, redirectUrl) {
                                _this.logger.info(`Redirect to ${removeQuery(redirectUrl)}`);
                                actualUrl = redirectUrl;
                                request.followRedirect();
                            });
                            _this.httpExecutor.addErrorAndTimeoutHandlers(request, reject);
                            request.end();
                        }
                    };
                }
                if (signature == null) {
                    w(0);
                } else {
                    firstStream.write(signature, function () {
                        return w(0);
                    });
                }
            }).then(function () {
                return (0, (_fsExtraP || _load_fsExtraP()).close)(oldFileFd);
            }).catch(function (error) {
                (0, (_fsExtraP || _load_fsExtraP()).closeSync)(oldFileFd);
                (0, (_fsExtraP || _load_fsExtraP()).closeSync)(newFileFd);
                throw error;
            });
        })();
    }
    readRemoteBytes(start, endInclusive) {
        var _this2 = this;

        return (0, (_bluebirdLst || _load_bluebirdLst()).coroutine)(function* () {
            const buffer = Buffer.allocUnsafe(endInclusive + 1 - start);
            const requestOptions = _this2.createRequestOptions();
            requestOptions.headers.Range = `bytes=${start}-${endInclusive}`;
            let position = 0;
            yield _this2.request(requestOptions, function (chunk) {
                chunk.copy(buffer, position);
                position += chunk.length;
            });
            return buffer;
        })();
    }
    request(requestOptions, dataHandler) {
        return new (_bluebirdLst2 || _load_bluebirdLst2()).default((resolve, reject) => {
            const request = this.httpExecutor.doRequest(requestOptions, response => {
                if (!(0, (_multipleRangeDownloader || _load_multipleRangeDownloader()).checkIsRangesSupported)(response, reject)) {
                    return;
                }
                response.on("data", dataHandler);
                response.on("end", () => resolve());
            });
            this.httpExecutor.addErrorAndTimeoutHandlers(request, reject);
            request.end();
        });
    }
}
exports.DifferentialDownloader = DifferentialDownloader;

function formatBytes(value, symbol = " KB") {
    return new Intl.NumberFormat("en").format((value / 1024).toFixed(2)) + symbol;
}
// safety
function removeQuery(url) {
    const index = url.indexOf("?");
    return index < 0 ? url : url.substring(0, index);
}
//# sourceMappingURL=DifferentialDownloader.js.map

/***/ }),
/* 66 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.DataSplitter = undefined;

var _bluebirdLst;

function _load_bluebirdLst() {
    return _bluebirdLst = __webpack_require__(2);
}

var _bluebirdLst2;

function _load_bluebirdLst2() {
    return _bluebirdLst2 = _interopRequireDefault(__webpack_require__(2));
}

exports.copyData = copyData;

var _builderUtilRuntime;

function _load_builderUtilRuntime() {
    return _builderUtilRuntime = __webpack_require__(3);
}

var _fsExtraP;

function _load_fsExtraP() {
    return _fsExtraP = __webpack_require__(9);
}

var _stream;

function _load_stream() {
    return _stream = __webpack_require__(19);
}

var _downloadPlanBuilder;

function _load_downloadPlanBuilder() {
    return _downloadPlanBuilder = __webpack_require__(35);
}

function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
}

const DOUBLE_CRLF = Buffer.from("\r\n\r\n");
var ReadState;
(function (ReadState) {
    ReadState[ReadState["INIT"] = 0] = "INIT";
    ReadState[ReadState["HEADER"] = 1] = "HEADER";
    ReadState[ReadState["BODY"] = 2] = "BODY";
})(ReadState || (ReadState = {}));
function copyData(task, out, oldFileFd, reject, resolve) {
    const readStream = (0, (_fsExtraP || _load_fsExtraP()).createReadStream)("", {
        fd: oldFileFd,
        autoClose: false,
        start: task.start,
        // end is inclusive
        end: task.end - 1
    });
    readStream.on("error", reject);
    readStream.once("end", resolve);
    readStream.pipe(out, {
        end: false
    });
}
class DataSplitter extends (_stream || _load_stream()).Writable {
    constructor(out, options, partIndexToTaskIndex, boundary, partIndexToLength, finishHandler) {
        super();
        this.out = out;
        this.options = options;
        this.partIndexToTaskIndex = partIndexToTaskIndex;
        this.partIndexToLength = partIndexToLength;
        this.finishHandler = finishHandler;
        this.partIndex = -1;
        this.headerListBuffer = null;
        this.readState = ReadState.INIT;
        this.ignoreByteCount = 0;
        this.remainingPartDataCount = 0;
        this.actualPartLength = 0;
        this.boundaryLength = boundary.length + 4; /* size of \r\n-- */
        // first chunk doesn't start with \r\n
        this.ignoreByteCount = this.boundaryLength - 2;
    }
    get isFinished() {
        return this.partIndex === this.partIndexToLength.length;
    }
    // noinspection JSUnusedGlobalSymbols
    _write(data, encoding, callback) {
        if (this.isFinished) {
            console.error(`Trailing ignored data: ${data.length} bytes`);
            return;
        }
        this.handleData(data).then(callback).catch(callback);
    }
    handleData(chunk) {
        var _this = this;

        return (0, (_bluebirdLst || _load_bluebirdLst()).coroutine)(function* () {
            let start = 0;
            if (_this.ignoreByteCount !== 0 && _this.remainingPartDataCount !== 0) {
                throw (0, (_builderUtilRuntime || _load_builderUtilRuntime()).newError)("Internal error", "ERR_DATA_SPLITTER_BYTE_COUNT_MISMATCH");
            }
            if (_this.ignoreByteCount > 0) {
                const toIgnore = Math.min(_this.ignoreByteCount, chunk.length);
                _this.ignoreByteCount -= toIgnore;
                start = toIgnore;
            } else if (_this.remainingPartDataCount > 0) {
                const toRead = Math.min(_this.remainingPartDataCount, chunk.length);
                _this.remainingPartDataCount -= toRead;
                yield _this.processPartData(chunk, 0, toRead);
                start = toRead;
            }
            if (start === chunk.length) {
                return;
            }
            if (_this.readState === ReadState.HEADER) {
                const headerListEnd = _this.searchHeaderListEnd(chunk, start);
                if (headerListEnd === -1) {
                    return;
                }
                start = headerListEnd;
                _this.readState = ReadState.BODY;
                // header list is ignored, we don't need it
                _this.headerListBuffer = null;
            }
            while (true) {
                if (_this.readState === ReadState.BODY) {
                    _this.readState = ReadState.INIT;
                } else {
                    _this.partIndex++;
                    let taskIndex = _this.partIndexToTaskIndex.get(_this.partIndex);
                    if (taskIndex == null) {
                        if (_this.isFinished) {
                            taskIndex = _this.options.end;
                        } else {
                            throw (0, (_builderUtilRuntime || _load_builderUtilRuntime()).newError)("taskIndex is null", "ERR_DATA_SPLITTER_TASK_INDEX_IS_NULL");
                        }
                    }
                    const prevTaskIndex = _this.partIndex === 0 ? _this.options.start : _this.partIndexToTaskIndex.get(_this.partIndex - 1) + 1 /* prev part is download, next maybe copy */;
                    if (prevTaskIndex < taskIndex) {
                        yield _this.copyExistingData(prevTaskIndex, taskIndex);
                    } else if (prevTaskIndex > taskIndex) {
                        throw (0, (_builderUtilRuntime || _load_builderUtilRuntime()).newError)("prevTaskIndex must be < taskIndex", "ERR_DATA_SPLITTER_TASK_INDEX_ASSERT_FAILED");
                    }
                    if (_this.isFinished) {
                        _this.onPartEnd();
                        _this.finishHandler();
                        return;
                    }
                    start = _this.searchHeaderListEnd(chunk, start);
                    if (start === -1) {
                        _this.readState = ReadState.HEADER;
                        return;
                    }
                }
                const partLength = _this.partIndexToLength[_this.partIndex];
                const end = start + partLength;
                const effectiveEnd = Math.min(end, chunk.length);
                yield _this.processPartStarted(chunk, start, effectiveEnd);
                _this.remainingPartDataCount = partLength - (effectiveEnd - start);
                if (_this.remainingPartDataCount > 0) {
                    return;
                }
                start = end + _this.boundaryLength;
                if (start >= chunk.length) {
                    _this.ignoreByteCount = _this.boundaryLength - (chunk.length - end);
                    return;
                }
            }
        })();
    }
    copyExistingData(index, end) {
        return new (_bluebirdLst2 || _load_bluebirdLst2()).default((resolve, reject) => {
            const w = () => {
                if (index === end) {
                    resolve();
                    return;
                }
                const task = this.options.tasks[index];
                if (task.kind !== (_downloadPlanBuilder || _load_downloadPlanBuilder()).OperationKind.COPY) {
                    reject(new Error("Task kind must be COPY"));
                    return;
                }
                copyData(task, this.out, this.options.oldFileFd, reject, () => {
                    index++;
                    w();
                });
            };
            w();
        });
    }
    searchHeaderListEnd(chunk, readOffset) {
        const headerListEnd = chunk.indexOf(DOUBLE_CRLF, readOffset);
        if (headerListEnd !== -1) {
            return headerListEnd + DOUBLE_CRLF.length;
        }
        // not all headers data were received, save to buffer
        const partialChunk = readOffset === 0 ? chunk : chunk.slice(readOffset);
        if (this.headerListBuffer == null) {
            this.headerListBuffer = partialChunk;
        } else {
            this.headerListBuffer = Buffer.concat([this.headerListBuffer, partialChunk]);
        }
        return -1;
    }
    onPartEnd() {
        const expectedLength = this.partIndexToLength[this.partIndex - 1];
        if (this.actualPartLength !== expectedLength) {
            throw (0, (_builderUtilRuntime || _load_builderUtilRuntime()).newError)(`Expected length: ${expectedLength} differs from actual: ${this.actualPartLength}`, "ERR_DATA_SPLITTER_LENGTH_MISMATCH");
        }
        this.actualPartLength = 0;
    }
    processPartStarted(data, start, end) {
        if (this.partIndex !== 0) {
            this.onPartEnd();
        }
        return this.processPartData(data, start, end);
    }
    processPartData(data, start, end) {
        this.actualPartLength += end - start;
        const out = this.out;
        if (out.write(start === 0 && data.length === end ? data : data.slice(start, end))) {
            return (_bluebirdLst2 || _load_bluebirdLst2()).default.resolve();
        } else {
            return new (_bluebirdLst2 || _load_bluebirdLst2()).default((resolve, reject) => {
                out.on("error", reject);
                out.once("drain", () => {
                    out.removeListener("error", reject);
                    resolve();
                });
            });
        }
    }
}
exports.DataSplitter = DataSplitter; //# sourceMappingURL=DataSplitter.js.map

/***/ }),
/* 67 */
/***/ (function(module, exports) {

module.exports = require("http");

/***/ }),
/* 68 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * Save console methods for using when originals are overridden
 */

module.exports = {
  context: console,
  error: console.error,
  warn: console.warn,
  info: console.info,
  verbose: console.verbose,
  debug: console.debug,
  silly: console.silly,
  log: console.log
};

/***/ }),
/* 69 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _electron = __webpack_require__(10);

var _electronIsDev = __webpack_require__(26);

var _electronIsDev2 = _interopRequireDefault(_electronIsDev);

var _electronUpdater = __webpack_require__(8);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

let mainWindow;
const log = __webpack_require__(183);
log.transports.file.level = 'debug';
function onReady() {
    mainWindow = new _electron.BrowserWindow({
        width: 800,
        height: 600,
        webPreferences: {
            webSecurity: false
        }
    });
    mainWindow.setTitle(__webpack_require__(193).name);
    const fileName = `file://${__dirname}/index.html`;
    mainWindow.loadURL(fileName);
    mainWindow.on('close', () => _electron.app.quit());
    if (_electronIsDev2.default) {
        mainWindow.webContents.openDevTools();
    }
    if (!_electronIsDev2.default) {
        configureAppUpdate();
        setTimeout(() => {
            performAppUpdate();
        }, 5000);
    }
}
_electron.app.on('ready', () => onReady());
_electron.app.on('window-all-closed', () => _electron.app.quit());
_electron.app.on('browser-window-created', function (_e, window) {
    window.setMenu(null);
});
function performAppUpdate() {
    log.debug('sending updater checking-for-update');
    _electronUpdater.autoUpdater.autoDownload = false;
    _electronUpdater.autoUpdater.checkForUpdates();
}
function configureAppUpdate() {
    _electronUpdater.autoUpdater.logger = log;
    _electronUpdater.autoUpdater.on('checking-for-update', () => {
        log.debug('sending updater checking-for-update');
        mainWindow.webContents.send('updater', 'checking-for-update');
    });
    _electronUpdater.autoUpdater.on('update-available', info => {
        log.debug('sending updater update-available');
        mainWindow.webContents.send('updater', 'update-available', info);
    });
    _electronUpdater.autoUpdater.on('update-not-available', info => {
        log.debug('sending updater update-not-available');
        mainWindow.webContents.send('updater', 'update-not-available', info);
    });
    _electronUpdater.autoUpdater.on('error', err => {
        log.debug('sending updater error');
        mainWindow.webContents.send('updater', 'error', err);
    });
    _electronUpdater.autoUpdater.on('download-progress', progressObj => {
        log.debug('sending updater download-progress');
        mainWindow.webContents.send('updater', 'download-progress', progressObj);
    });
    _electronUpdater.autoUpdater.on('update-downloaded', info => {
        log.debug('sending updater update-downloaded');
        mainWindow.webContents.send('updater', 'update-downloaded', info);
    });
    _electron.ipcMain.on('updater', (_event, type) => {
        if (type === 'download') {
            _electronUpdater.autoUpdater.downloadUpdate();
        }
        if (type === 'install') {
            _electronUpdater.autoUpdater.quitAndInstall();
        }
    });
}

/***/ }),
/* 70 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = function () {
    var makeSelfResolutionError = function () {
        return new TypeError("circular promise resolution chain\u000a\u000a    See http://goo.gl/MqrFmX\u000a");
    };
    var reflectHandler = function () {
        return new Promise.PromiseInspection(this._target());
    };
    var apiRejection = function (msg) {
        return Promise.reject(new TypeError(msg));
    };
    function Proxyable() {}
    var UNDEFINED_BINDING = {};
    var util = __webpack_require__(1);

    var getDomain;
    if (util.isNode) {
        getDomain = function () {
            var ret = process.domain;
            if (ret === undefined) ret = null;
            return ret;
        };
    } else {
        getDomain = function () {
            return null;
        };
    }
    util.notEnumerableProp(Promise, "_getDomain", getDomain);

    var es5 = __webpack_require__(16);
    var Async = __webpack_require__(71);
    var async = new Async();
    es5.defineProperty(Promise, "_async", { value: async });
    var errors = __webpack_require__(11);
    var TypeError = Promise.TypeError = errors.TypeError;
    Promise.RangeError = errors.RangeError;
    var CancellationError = Promise.CancellationError = errors.CancellationError;
    Promise.TimeoutError = errors.TimeoutError;
    Promise.OperationalError = errors.OperationalError;
    Promise.RejectionError = errors.OperationalError;
    Promise.AggregateError = errors.AggregateError;
    var INTERNAL = function () {};
    var APPLY = {};
    var NEXT_FILTER = {};
    var tryConvertToPromise = __webpack_require__(74)(Promise, INTERNAL);
    var PromiseArray = __webpack_require__(75)(Promise, INTERNAL, tryConvertToPromise, apiRejection, Proxyable);
    var Context = __webpack_require__(76)(Promise);
    /*jshint unused:false*/
    var createContext = Context.create;
    var debug = __webpack_require__(77)(Promise, Context);
    var CapturedTrace = debug.CapturedTrace;
    var PassThroughHandlerContext = __webpack_require__(78)(Promise, tryConvertToPromise, NEXT_FILTER);
    var catchFilter = __webpack_require__(38)(NEXT_FILTER);
    var nodebackForPromise = __webpack_require__(39);
    var errorObj = util.errorObj;
    var tryCatch = util.tryCatch;
    function check(self, executor) {
        if (self == null || self.constructor !== Promise) {
            throw new TypeError("the promise constructor cannot be invoked directly\u000a\u000a    See http://goo.gl/MqrFmX\u000a");
        }
        if (typeof executor !== "function") {
            throw new TypeError("expecting a function but got " + util.classString(executor));
        }
    }

    function Promise(executor) {
        if (executor !== INTERNAL) {
            check(this, executor);
        }
        this._bitField = 0;
        this._fulfillmentHandler0 = undefined;
        this._rejectionHandler0 = undefined;
        this._promise0 = undefined;
        this._receiver0 = undefined;
        this._resolveFromExecutor(executor);
        this._promiseCreated();
        this._fireEvent("promiseCreated", this);
    }

    Promise.prototype.toString = function () {
        return "[object Promise]";
    };

    Promise.prototype.caught = Promise.prototype["catch"] = function (fn) {
        var len = arguments.length;
        if (len > 1) {
            var catchInstances = new Array(len - 1),
                j = 0,
                i;
            for (i = 0; i < len - 1; ++i) {
                var item = arguments[i];
                if (util.isObject(item)) {
                    catchInstances[j++] = item;
                } else {
                    return apiRejection("Catch statement predicate: " + "expecting an object but got " + util.classString(item));
                }
            }
            catchInstances.length = j;
            fn = arguments[i];
            return this.then(undefined, catchFilter(catchInstances, fn, this));
        }
        return this.then(undefined, fn);
    };

    Promise.prototype.reflect = function () {
        return this._then(reflectHandler, reflectHandler, undefined, this, undefined);
    };

    Promise.prototype.then = function (didFulfill, didReject) {
        if (debug.warnings() && arguments.length > 0 && typeof didFulfill !== "function" && typeof didReject !== "function") {
            var msg = ".then() only accepts functions but was passed: " + util.classString(didFulfill);
            if (arguments.length > 1) {
                msg += ", " + util.classString(didReject);
            }
            this._warn(msg);
        }
        return this._then(didFulfill, didReject, undefined, undefined, undefined);
    };

    Promise.prototype.done = function (didFulfill, didReject) {
        var promise = this._then(didFulfill, didReject, undefined, undefined, undefined);
        promise._setIsFinal();
    };

    Promise.prototype.spread = function (fn) {
        if (typeof fn !== "function") {
            return apiRejection("expecting a function but got " + util.classString(fn));
        }
        return this.all()._then(fn, undefined, undefined, APPLY, undefined);
    };

    Promise.prototype.toJSON = function () {
        var ret = {
            isFulfilled: false,
            isRejected: false,
            fulfillmentValue: undefined,
            rejectionReason: undefined
        };
        if (this.isFulfilled()) {
            ret.fulfillmentValue = this.value();
            ret.isFulfilled = true;
        } else if (this.isRejected()) {
            ret.rejectionReason = this.reason();
            ret.isRejected = true;
        }
        return ret;
    };

    Promise.prototype.all = function () {
        if (arguments.length > 0) {
            this._warn(".all() was passed arguments but it does not take any");
        }
        return new PromiseArray(this).promise();
    };

    Promise.prototype.error = function (fn) {
        return this.caught(util.originatesFromRejection, fn);
    };

    Promise.getNewLibraryCopy = module.exports;

    Promise.is = function (val) {
        return val instanceof Promise;
    };

    Promise.fromNode = Promise.fromCallback = function (fn) {
        var ret = new Promise(INTERNAL);
        ret._captureStackTrace();
        var multiArgs = arguments.length > 1 ? !!Object(arguments[1]).multiArgs : false;
        var result = tryCatch(fn)(nodebackForPromise(ret, multiArgs));
        if (result === errorObj) {
            ret._rejectCallback(result.e, true);
        }
        if (!ret._isFateSealed()) ret._setAsyncGuaranteed();
        return ret;
    };

    Promise.all = function (promises) {
        return new PromiseArray(promises).promise();
    };

    Promise.cast = function (obj) {
        var ret = tryConvertToPromise(obj);
        if (!(ret instanceof Promise)) {
            ret = new Promise(INTERNAL);
            ret._captureStackTrace();
            ret._setFulfilled();
            ret._rejectionHandler0 = obj;
        }
        return ret;
    };

    Promise.resolve = Promise.fulfilled = Promise.cast;

    Promise.reject = Promise.rejected = function (reason) {
        var ret = new Promise(INTERNAL);
        ret._captureStackTrace();
        ret._rejectCallback(reason, true);
        return ret;
    };

    Promise.setScheduler = function (fn) {
        if (typeof fn !== "function") {
            throw new TypeError("expecting a function but got " + util.classString(fn));
        }
        return async.setScheduler(fn);
    };

    Promise.prototype._then = function (didFulfill, didReject, _, receiver, internalData) {
        var haveInternalData = internalData !== undefined;
        var promise = haveInternalData ? internalData : new Promise(INTERNAL);
        var target = this._target();
        var bitField = target._bitField;

        if (!haveInternalData) {
            promise._propagateFrom(this, 3);
            promise._captureStackTrace();
            if (receiver === undefined && (this._bitField & 2097152) !== 0) {
                if (!((bitField & 50397184) === 0)) {
                    receiver = this._boundValue();
                } else {
                    receiver = target === this ? undefined : this._boundTo;
                }
            }
            this._fireEvent("promiseChained", this, promise);
        }

        var domain = getDomain();
        if (!((bitField & 50397184) === 0)) {
            var handler,
                value,
                settler = target._settlePromiseCtx;
            if ((bitField & 33554432) !== 0) {
                value = target._rejectionHandler0;
                handler = didFulfill;
            } else if ((bitField & 16777216) !== 0) {
                value = target._fulfillmentHandler0;
                handler = didReject;
                target._unsetRejectionIsUnhandled();
            } else {
                settler = target._settlePromiseLateCancellationObserver;
                value = new CancellationError("late cancellation observer");
                target._attachExtraTrace(value);
                handler = didReject;
            }

            async.invoke(settler, target, {
                handler: domain === null ? handler : typeof handler === "function" && util.domainBind(domain, handler),
                promise: promise,
                receiver: receiver,
                value: value
            });
        } else {
            target._addCallbacks(didFulfill, didReject, promise, receiver, domain);
        }

        return promise;
    };

    Promise.prototype._length = function () {
        return this._bitField & 65535;
    };

    Promise.prototype._isFateSealed = function () {
        return (this._bitField & 117506048) !== 0;
    };

    Promise.prototype._isFollowing = function () {
        return (this._bitField & 67108864) === 67108864;
    };

    Promise.prototype._setLength = function (len) {
        this._bitField = this._bitField & -65536 | len & 65535;
    };

    Promise.prototype._setFulfilled = function () {
        this._bitField = this._bitField | 33554432;
        this._fireEvent("promiseFulfilled", this);
    };

    Promise.prototype._setRejected = function () {
        this._bitField = this._bitField | 16777216;
        this._fireEvent("promiseRejected", this);
    };

    Promise.prototype._setFollowing = function () {
        this._bitField = this._bitField | 67108864;
        this._fireEvent("promiseResolved", this);
    };

    Promise.prototype._setIsFinal = function () {
        this._bitField = this._bitField | 4194304;
    };

    Promise.prototype._isFinal = function () {
        return (this._bitField & 4194304) > 0;
    };

    Promise.prototype._unsetCancelled = function () {
        this._bitField = this._bitField & ~65536;
    };

    Promise.prototype._setCancelled = function () {
        this._bitField = this._bitField | 65536;
        this._fireEvent("promiseCancelled", this);
    };

    Promise.prototype._setWillBeCancelled = function () {
        this._bitField = this._bitField | 8388608;
    };

    Promise.prototype._setAsyncGuaranteed = function () {
        if (async.hasCustomScheduler()) return;
        this._bitField = this._bitField | 134217728;
    };

    Promise.prototype._receiverAt = function (index) {
        var ret = index === 0 ? this._receiver0 : this[index * 4 - 4 + 3];
        if (ret === UNDEFINED_BINDING) {
            return undefined;
        } else if (ret === undefined && this._isBound()) {
            return this._boundValue();
        }
        return ret;
    };

    Promise.prototype._promiseAt = function (index) {
        return this[index * 4 - 4 + 2];
    };

    Promise.prototype._fulfillmentHandlerAt = function (index) {
        return this[index * 4 - 4 + 0];
    };

    Promise.prototype._rejectionHandlerAt = function (index) {
        return this[index * 4 - 4 + 1];
    };

    Promise.prototype._boundValue = function () {};

    Promise.prototype._migrateCallback0 = function (follower) {
        var bitField = follower._bitField;
        var fulfill = follower._fulfillmentHandler0;
        var reject = follower._rejectionHandler0;
        var promise = follower._promise0;
        var receiver = follower._receiverAt(0);
        if (receiver === undefined) receiver = UNDEFINED_BINDING;
        this._addCallbacks(fulfill, reject, promise, receiver, null);
    };

    Promise.prototype._migrateCallbackAt = function (follower, index) {
        var fulfill = follower._fulfillmentHandlerAt(index);
        var reject = follower._rejectionHandlerAt(index);
        var promise = follower._promiseAt(index);
        var receiver = follower._receiverAt(index);
        if (receiver === undefined) receiver = UNDEFINED_BINDING;
        this._addCallbacks(fulfill, reject, promise, receiver, null);
    };

    Promise.prototype._addCallbacks = function (fulfill, reject, promise, receiver, domain) {
        var index = this._length();

        if (index >= 65535 - 4) {
            index = 0;
            this._setLength(0);
        }

        if (index === 0) {
            this._promise0 = promise;
            this._receiver0 = receiver;
            if (typeof fulfill === "function") {
                this._fulfillmentHandler0 = domain === null ? fulfill : util.domainBind(domain, fulfill);
            }
            if (typeof reject === "function") {
                this._rejectionHandler0 = domain === null ? reject : util.domainBind(domain, reject);
            }
        } else {
            var base = index * 4 - 4;
            this[base + 2] = promise;
            this[base + 3] = receiver;
            if (typeof fulfill === "function") {
                this[base + 0] = domain === null ? fulfill : util.domainBind(domain, fulfill);
            }
            if (typeof reject === "function") {
                this[base + 1] = domain === null ? reject : util.domainBind(domain, reject);
            }
        }
        this._setLength(index + 1);
        return index;
    };

    Promise.prototype._proxy = function (proxyable, arg) {
        this._addCallbacks(undefined, undefined, arg, proxyable, null);
    };

    Promise.prototype._resolveCallback = function (value, shouldBind) {
        if ((this._bitField & 117506048) !== 0) return;
        if (value === this) return this._rejectCallback(makeSelfResolutionError(), false);
        var maybePromise = tryConvertToPromise(value, this);
        if (!(maybePromise instanceof Promise)) return this._fulfill(value);

        if (shouldBind) this._propagateFrom(maybePromise, 2);

        var promise = maybePromise._target();

        if (promise === this) {
            this._reject(makeSelfResolutionError());
            return;
        }

        var bitField = promise._bitField;
        if ((bitField & 50397184) === 0) {
            var len = this._length();
            if (len > 0) promise._migrateCallback0(this);
            for (var i = 1; i < len; ++i) {
                promise._migrateCallbackAt(this, i);
            }
            this._setFollowing();
            this._setLength(0);
            this._setFollowee(promise);
        } else if ((bitField & 33554432) !== 0) {
            this._fulfill(promise._value());
        } else if ((bitField & 16777216) !== 0) {
            this._reject(promise._reason());
        } else {
            var reason = new CancellationError("late cancellation observer");
            promise._attachExtraTrace(reason);
            this._reject(reason);
        }
    };

    Promise.prototype._rejectCallback = function (reason, synchronous, ignoreNonErrorWarnings) {
        var trace = util.ensureErrorObject(reason);
        var hasStack = trace === reason;
        if (!hasStack && !ignoreNonErrorWarnings && debug.warnings()) {
            var message = "a promise was rejected with a non-error: " + util.classString(reason);
            this._warn(message, true);
        }
        this._attachExtraTrace(trace, synchronous ? hasStack : false);
        this._reject(reason);
    };

    Promise.prototype._resolveFromExecutor = function (executor) {
        if (executor === INTERNAL) return;
        var promise = this;
        this._captureStackTrace();
        this._pushContext();
        var synchronous = true;
        var r = this._execute(executor, function (value) {
            promise._resolveCallback(value);
        }, function (reason) {
            promise._rejectCallback(reason, synchronous);
        });
        synchronous = false;
        this._popContext();

        if (r !== undefined) {
            promise._rejectCallback(r, true);
        }
    };

    Promise.prototype._settlePromiseFromHandler = function (handler, receiver, value, promise) {
        var bitField = promise._bitField;
        if ((bitField & 65536) !== 0) return;
        promise._pushContext();
        var x;
        if (receiver === APPLY) {
            if (!value || typeof value.length !== "number") {
                x = errorObj;
                x.e = new TypeError("cannot .spread() a non-array: " + util.classString(value));
            } else {
                x = tryCatch(handler).apply(this._boundValue(), value);
            }
        } else {
            x = tryCatch(handler).call(receiver, value);
        }
        var promiseCreated = promise._popContext();
        bitField = promise._bitField;
        if ((bitField & 65536) !== 0) return;

        if (x === NEXT_FILTER) {
            promise._reject(value);
        } else if (x === errorObj) {
            promise._rejectCallback(x.e, false);
        } else {
            debug.checkForgottenReturns(x, promiseCreated, "", promise, this);
            promise._resolveCallback(x);
        }
    };

    Promise.prototype._target = function () {
        var ret = this;
        while (ret._isFollowing()) ret = ret._followee();
        return ret;
    };

    Promise.prototype._followee = function () {
        return this._rejectionHandler0;
    };

    Promise.prototype._setFollowee = function (promise) {
        this._rejectionHandler0 = promise;
    };

    Promise.prototype._settlePromise = function (promise, handler, receiver, value) {
        var isPromise = promise instanceof Promise;
        var bitField = this._bitField;
        var asyncGuaranteed = (bitField & 134217728) !== 0;
        if ((bitField & 65536) !== 0) {
            if (isPromise) promise._invokeInternalOnCancel();

            if (receiver instanceof PassThroughHandlerContext && receiver.isFinallyHandler()) {
                receiver.cancelPromise = promise;
                if (tryCatch(handler).call(receiver, value) === errorObj) {
                    promise._reject(errorObj.e);
                }
            } else if (handler === reflectHandler) {
                promise._fulfill(reflectHandler.call(receiver));
            } else if (receiver instanceof Proxyable) {
                receiver._promiseCancelled(promise);
            } else if (isPromise || promise instanceof PromiseArray) {
                promise._cancel();
            } else {
                receiver.cancel();
            }
        } else if (typeof handler === "function") {
            if (!isPromise) {
                handler.call(receiver, value, promise);
            } else {
                if (asyncGuaranteed) promise._setAsyncGuaranteed();
                this._settlePromiseFromHandler(handler, receiver, value, promise);
            }
        } else if (receiver instanceof Proxyable) {
            if (!receiver._isResolved()) {
                if ((bitField & 33554432) !== 0) {
                    receiver._promiseFulfilled(value, promise);
                } else {
                    receiver._promiseRejected(value, promise);
                }
            }
        } else if (isPromise) {
            if (asyncGuaranteed) promise._setAsyncGuaranteed();
            if ((bitField & 33554432) !== 0) {
                promise._fulfill(value);
            } else {
                promise._reject(value);
            }
        }
    };

    Promise.prototype._settlePromiseLateCancellationObserver = function (ctx) {
        var handler = ctx.handler;
        var promise = ctx.promise;
        var receiver = ctx.receiver;
        var value = ctx.value;
        if (typeof handler === "function") {
            if (!(promise instanceof Promise)) {
                handler.call(receiver, value, promise);
            } else {
                this._settlePromiseFromHandler(handler, receiver, value, promise);
            }
        } else if (promise instanceof Promise) {
            promise._reject(value);
        }
    };

    Promise.prototype._settlePromiseCtx = function (ctx) {
        this._settlePromise(ctx.promise, ctx.handler, ctx.receiver, ctx.value);
    };

    Promise.prototype._settlePromise0 = function (handler, value, bitField) {
        var promise = this._promise0;
        var receiver = this._receiverAt(0);
        this._promise0 = undefined;
        this._receiver0 = undefined;
        this._settlePromise(promise, handler, receiver, value);
    };

    Promise.prototype._clearCallbackDataAtIndex = function (index) {
        var base = index * 4 - 4;
        this[base + 2] = this[base + 3] = this[base + 0] = this[base + 1] = undefined;
    };

    Promise.prototype._fulfill = function (value) {
        var bitField = this._bitField;
        if ((bitField & 117506048) >>> 16) return;
        if (value === this) {
            var err = makeSelfResolutionError();
            this._attachExtraTrace(err);
            return this._reject(err);
        }
        this._setFulfilled();
        this._rejectionHandler0 = value;

        if ((bitField & 65535) > 0) {
            if ((bitField & 134217728) !== 0) {
                this._settlePromises();
            } else {
                async.settlePromises(this);
            }
        }
    };

    Promise.prototype._reject = function (reason) {
        var bitField = this._bitField;
        if ((bitField & 117506048) >>> 16) return;
        this._setRejected();
        this._fulfillmentHandler0 = reason;

        if (this._isFinal()) {
            return async.fatalError(reason, util.isNode);
        }

        if ((bitField & 65535) > 0) {
            async.settlePromises(this);
        } else {
            this._ensurePossibleRejectionHandled();
        }
    };

    Promise.prototype._fulfillPromises = function (len, value) {
        for (var i = 1; i < len; i++) {
            var handler = this._fulfillmentHandlerAt(i);
            var promise = this._promiseAt(i);
            var receiver = this._receiverAt(i);
            this._clearCallbackDataAtIndex(i);
            this._settlePromise(promise, handler, receiver, value);
        }
    };

    Promise.prototype._rejectPromises = function (len, reason) {
        for (var i = 1; i < len; i++) {
            var handler = this._rejectionHandlerAt(i);
            var promise = this._promiseAt(i);
            var receiver = this._receiverAt(i);
            this._clearCallbackDataAtIndex(i);
            this._settlePromise(promise, handler, receiver, reason);
        }
    };

    Promise.prototype._settlePromises = function () {
        var bitField = this._bitField;
        var len = bitField & 65535;

        if (len > 0) {
            if ((bitField & 16842752) !== 0) {
                var reason = this._fulfillmentHandler0;
                this._settlePromise0(this._rejectionHandler0, reason, bitField);
                this._rejectPromises(len, reason);
            } else {
                var value = this._rejectionHandler0;
                this._settlePromise0(this._fulfillmentHandler0, value, bitField);
                this._fulfillPromises(len, value);
            }
            this._setLength(0);
        }
        this._clearCancellationData();
    };

    Promise.prototype._settledValue = function () {
        var bitField = this._bitField;
        if ((bitField & 33554432) !== 0) {
            return this._rejectionHandler0;
        } else if ((bitField & 16777216) !== 0) {
            return this._fulfillmentHandler0;
        }
    };

    function deferResolve(v) {
        this.promise._resolveCallback(v);
    }
    function deferReject(v) {
        this.promise._rejectCallback(v, false);
    }

    Promise.defer = Promise.pending = function () {
        debug.deprecated("Promise.defer", "new Promise");
        var promise = new Promise(INTERNAL);
        return {
            promise: promise,
            resolve: deferResolve,
            reject: deferReject
        };
    };

    util.notEnumerableProp(Promise, "_makeSelfResolutionError", makeSelfResolutionError);

    __webpack_require__(79)(Promise, INTERNAL, tryConvertToPromise, apiRejection, debug);
    __webpack_require__(80)(Promise, INTERNAL, tryConvertToPromise, debug);
    __webpack_require__(81)(Promise, PromiseArray, apiRejection, debug);
    __webpack_require__(82)(Promise);
    __webpack_require__(83)(Promise);
    __webpack_require__(84)(Promise, PromiseArray, tryConvertToPromise, INTERNAL, async, getDomain);
    Promise.Promise = Promise;
    Promise.version = "3.5.1";
    __webpack_require__(85)(Promise, PromiseArray, apiRejection, tryConvertToPromise, INTERNAL, debug);
    __webpack_require__(86)(Promise);
    __webpack_require__(87)(Promise, apiRejection, tryConvertToPromise, createContext, INTERNAL, debug);
    __webpack_require__(88)(Promise, INTERNAL, debug);
    __webpack_require__(89)(Promise, apiRejection, INTERNAL, tryConvertToPromise, Proxyable, debug);
    __webpack_require__(90)(Promise);
    __webpack_require__(91)(Promise, INTERNAL);
    __webpack_require__(92)(Promise, PromiseArray, tryConvertToPromise, apiRejection);
    __webpack_require__(93)(Promise, INTERNAL, tryConvertToPromise, apiRejection);
    __webpack_require__(94)(Promise, PromiseArray, apiRejection, tryConvertToPromise, INTERNAL, debug);
    __webpack_require__(95)(Promise, PromiseArray, debug);
    __webpack_require__(96)(Promise, PromiseArray, apiRejection);
    __webpack_require__(97)(Promise, INTERNAL);
    __webpack_require__(98)(Promise, INTERNAL);
    __webpack_require__(99)(Promise);

    util.toFastProperties(Promise);
    util.toFastProperties(Promise.prototype);
    function fillTypes(value) {
        var p = new Promise(INTERNAL);
        p._fulfillmentHandler0 = value;
        p._rejectionHandler0 = value;
        p._promise0 = value;
        p._receiver0 = value;
    }
    // Complete slack tracking, opt out of field-type tracking and           
    // stabilize map                                                         
    fillTypes({ a: 1 });
    fillTypes({ b: 2 });
    fillTypes({ c: 3 });
    fillTypes(1);
    fillTypes(function () {});
    fillTypes(undefined);
    fillTypes(false);
    fillTypes(new Promise(INTERNAL));
    debug.setBounds(Async.firstLineError, util.lastLineError);
    return Promise;
};

/***/ }),
/* 71 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var firstLineError;
try {
    throw new Error();
} catch (e) {
    firstLineError = e;
}
var schedule = __webpack_require__(72);
var Queue = __webpack_require__(73);
var util = __webpack_require__(1);

function Async() {
    this._customScheduler = false;
    this._isTickUsed = false;
    this._lateQueue = new Queue(16);
    this._normalQueue = new Queue(16);
    this._haveDrainedQueues = false;
    this._trampolineEnabled = true;
    var self = this;
    this.drainQueues = function () {
        self._drainQueues();
    };
    this._schedule = schedule;
}

Async.prototype.setScheduler = function (fn) {
    var prev = this._schedule;
    this._schedule = fn;
    this._customScheduler = true;
    return prev;
};

Async.prototype.hasCustomScheduler = function () {
    return this._customScheduler;
};

Async.prototype.enableTrampoline = function () {
    this._trampolineEnabled = true;
};

Async.prototype.disableTrampolineIfNecessary = function () {
    if (util.hasDevTools) {
        this._trampolineEnabled = false;
    }
};

Async.prototype.haveItemsQueued = function () {
    return this._isTickUsed || this._haveDrainedQueues;
};

Async.prototype.fatalError = function (e, isNode) {
    if (isNode) {
        process.stderr.write("Fatal " + (e instanceof Error ? e.stack : e) + "\n");
        process.exit(2);
    } else {
        this.throwLater(e);
    }
};

Async.prototype.throwLater = function (fn, arg) {
    if (arguments.length === 1) {
        arg = fn;
        fn = function () {
            throw arg;
        };
    }
    if (typeof setTimeout !== "undefined") {
        setTimeout(function () {
            fn(arg);
        }, 0);
    } else try {
        this._schedule(function () {
            fn(arg);
        });
    } catch (e) {
        throw new Error("No async scheduler available\u000a\u000a    See http://goo.gl/MqrFmX\u000a");
    }
};

function AsyncInvokeLater(fn, receiver, arg) {
    this._lateQueue.push(fn, receiver, arg);
    this._queueTick();
}

function AsyncInvoke(fn, receiver, arg) {
    this._normalQueue.push(fn, receiver, arg);
    this._queueTick();
}

function AsyncSettlePromises(promise) {
    this._normalQueue._pushOne(promise);
    this._queueTick();
}

if (!util.hasDevTools) {
    Async.prototype.invokeLater = AsyncInvokeLater;
    Async.prototype.invoke = AsyncInvoke;
    Async.prototype.settlePromises = AsyncSettlePromises;
} else {
    Async.prototype.invokeLater = function (fn, receiver, arg) {
        if (this._trampolineEnabled) {
            AsyncInvokeLater.call(this, fn, receiver, arg);
        } else {
            this._schedule(function () {
                setTimeout(function () {
                    fn.call(receiver, arg);
                }, 100);
            });
        }
    };

    Async.prototype.invoke = function (fn, receiver, arg) {
        if (this._trampolineEnabled) {
            AsyncInvoke.call(this, fn, receiver, arg);
        } else {
            this._schedule(function () {
                fn.call(receiver, arg);
            });
        }
    };

    Async.prototype.settlePromises = function (promise) {
        if (this._trampolineEnabled) {
            AsyncSettlePromises.call(this, promise);
        } else {
            this._schedule(function () {
                promise._settlePromises();
            });
        }
    };
}

Async.prototype._drainQueue = function (queue) {
    while (queue.length() > 0) {
        var fn = queue.shift();
        if (typeof fn !== "function") {
            fn._settlePromises();
            continue;
        }
        var receiver = queue.shift();
        var arg = queue.shift();
        fn.call(receiver, arg);
    }
};

Async.prototype._drainQueues = function () {
    this._drainQueue(this._normalQueue);
    this._reset();
    this._haveDrainedQueues = true;
    this._drainQueue(this._lateQueue);
};

Async.prototype._queueTick = function () {
    if (!this._isTickUsed) {
        this._isTickUsed = true;
        this._schedule(this.drainQueues);
    }
};

Async.prototype._reset = function () {
    this._isTickUsed = false;
};

module.exports = Async;
module.exports.firstLineError = firstLineError;

/***/ }),
/* 72 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var util = __webpack_require__(1);
var schedule;
var noAsyncScheduler = function () {
    throw new Error("No async scheduler available\u000a\u000a    See http://goo.gl/MqrFmX\u000a");
};
var NativePromise = util.getNativePromise();
if (util.isNode && typeof MutationObserver === "undefined") {
    var GlobalSetImmediate = global.setImmediate;
    var ProcessNextTick = process.nextTick;
    schedule = util.isRecentNode ? function (fn) {
        GlobalSetImmediate.call(global, fn);
    } : function (fn) {
        ProcessNextTick.call(process, fn);
    };
} else if (typeof NativePromise === "function" && typeof NativePromise.resolve === "function") {
    var nativePromise = NativePromise.resolve();
    schedule = function (fn) {
        nativePromise.then(fn);
    };
} else if (typeof MutationObserver !== "undefined" && !(typeof window !== "undefined" && window.navigator && (window.navigator.standalone || window.cordova))) {
    schedule = function () {
        var div = document.createElement("div");
        var opts = { attributes: true };
        var toggleScheduled = false;
        var div2 = document.createElement("div");
        var o2 = new MutationObserver(function () {
            div.classList.toggle("foo");
            toggleScheduled = false;
        });
        o2.observe(div2, opts);

        var scheduleToggle = function () {
            if (toggleScheduled) return;
            toggleScheduled = true;
            div2.classList.toggle("foo");
        };

        return function schedule(fn) {
            var o = new MutationObserver(function () {
                o.disconnect();
                fn();
            });
            o.observe(div, opts);
            scheduleToggle();
        };
    }();
} else if (typeof setImmediate !== "undefined") {
    schedule = function (fn) {
        setImmediate(fn);
    };
} else if (typeof setTimeout !== "undefined") {
    schedule = function (fn) {
        setTimeout(fn, 0);
    };
} else {
    schedule = noAsyncScheduler;
}
module.exports = schedule;

/***/ }),
/* 73 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


function arrayMove(src, srcIndex, dst, dstIndex, len) {
    for (var j = 0; j < len; ++j) {
        dst[j + dstIndex] = src[j + srcIndex];
        src[j + srcIndex] = void 0;
    }
}

function Queue(capacity) {
    this._capacity = capacity;
    this._length = 0;
    this._front = 0;
}

Queue.prototype._willBeOverCapacity = function (size) {
    return this._capacity < size;
};

Queue.prototype._pushOne = function (arg) {
    var length = this.length();
    this._checkCapacity(length + 1);
    var i = this._front + length & this._capacity - 1;
    this[i] = arg;
    this._length = length + 1;
};

Queue.prototype.push = function (fn, receiver, arg) {
    var length = this.length() + 3;
    if (this._willBeOverCapacity(length)) {
        this._pushOne(fn);
        this._pushOne(receiver);
        this._pushOne(arg);
        return;
    }
    var j = this._front + length - 3;
    this._checkCapacity(length);
    var wrapMask = this._capacity - 1;
    this[j + 0 & wrapMask] = fn;
    this[j + 1 & wrapMask] = receiver;
    this[j + 2 & wrapMask] = arg;
    this._length = length;
};

Queue.prototype.shift = function () {
    var front = this._front,
        ret = this[front];

    this[front] = undefined;
    this._front = front + 1 & this._capacity - 1;
    this._length--;
    return ret;
};

Queue.prototype.length = function () {
    return this._length;
};

Queue.prototype._checkCapacity = function (size) {
    if (this._capacity < size) {
        this._resizeTo(this._capacity << 1);
    }
};

Queue.prototype._resizeTo = function (capacity) {
    var oldCapacity = this._capacity;
    this._capacity = capacity;
    var front = this._front;
    var length = this._length;
    var moveItemsCount = front + length & oldCapacity - 1;
    arrayMove(this, 0, this, oldCapacity, moveItemsCount);
};

module.exports = Queue;

/***/ }),
/* 74 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = function (Promise, INTERNAL) {
    var util = __webpack_require__(1);
    var errorObj = util.errorObj;
    var isObject = util.isObject;

    function tryConvertToPromise(obj, context) {
        if (isObject(obj)) {
            if (obj instanceof Promise) return obj;
            var then = getThen(obj);
            if (then === errorObj) {
                if (context) context._pushContext();
                var ret = Promise.reject(then.e);
                if (context) context._popContext();
                return ret;
            } else if (typeof then === "function") {
                if (isAnyBluebirdPromise(obj)) {
                    var ret = new Promise(INTERNAL);
                    obj._then(ret._fulfill, ret._reject, undefined, ret, null);
                    return ret;
                }
                return doThenable(obj, then, context);
            }
        }
        return obj;
    }

    function doGetThen(obj) {
        return obj.then;
    }

    function getThen(obj) {
        try {
            return doGetThen(obj);
        } catch (e) {
            errorObj.e = e;
            return errorObj;
        }
    }

    var hasProp = {}.hasOwnProperty;
    function isAnyBluebirdPromise(obj) {
        try {
            return hasProp.call(obj, "_promise0");
        } catch (e) {
            return false;
        }
    }

    function doThenable(x, then, context) {
        var promise = new Promise(INTERNAL);
        var ret = promise;
        if (context) context._pushContext();
        promise._captureStackTrace();
        if (context) context._popContext();
        var synchronous = true;
        var result = util.tryCatch(then).call(x, resolve, reject);
        synchronous = false;

        if (promise && result === errorObj) {
            promise._rejectCallback(result.e, true, true);
            promise = null;
        }

        function resolve(value) {
            if (!promise) return;
            promise._resolveCallback(value);
            promise = null;
        }

        function reject(reason) {
            if (!promise) return;
            promise._rejectCallback(reason, synchronous, true);
            promise = null;
        }
        return ret;
    }

    return tryConvertToPromise;
};

/***/ }),
/* 75 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = function (Promise, INTERNAL, tryConvertToPromise, apiRejection, Proxyable) {
    var util = __webpack_require__(1);
    var isArray = util.isArray;

    function toResolutionValue(val) {
        switch (val) {
            case -2:
                return [];
            case -3:
                return {};
            case -6:
                return new Map();
        }
    }

    function PromiseArray(values) {
        var promise = this._promise = new Promise(INTERNAL);
        if (values instanceof Promise) {
            promise._propagateFrom(values, 3);
        }
        promise._setOnCancel(this);
        this._values = values;
        this._length = 0;
        this._totalResolved = 0;
        this._init(undefined, -2);
    }
    util.inherits(PromiseArray, Proxyable);

    PromiseArray.prototype.length = function () {
        return this._length;
    };

    PromiseArray.prototype.promise = function () {
        return this._promise;
    };

    PromiseArray.prototype._init = function init(_, resolveValueIfEmpty) {
        var values = tryConvertToPromise(this._values, this._promise);
        if (values instanceof Promise) {
            values = values._target();
            var bitField = values._bitField;
            ;
            this._values = values;

            if ((bitField & 50397184) === 0) {
                this._promise._setAsyncGuaranteed();
                return values._then(init, this._reject, undefined, this, resolveValueIfEmpty);
            } else if ((bitField & 33554432) !== 0) {
                values = values._value();
            } else if ((bitField & 16777216) !== 0) {
                return this._reject(values._reason());
            } else {
                return this._cancel();
            }
        }
        values = util.asArray(values);
        if (values === null) {
            var err = apiRejection("expecting an array or an iterable object but got " + util.classString(values)).reason();
            this._promise._rejectCallback(err, false);
            return;
        }

        if (values.length === 0) {
            if (resolveValueIfEmpty === -5) {
                this._resolveEmptyArray();
            } else {
                this._resolve(toResolutionValue(resolveValueIfEmpty));
            }
            return;
        }
        this._iterate(values);
    };

    PromiseArray.prototype._iterate = function (values) {
        var len = this.getActualLength(values.length);
        this._length = len;
        this._values = this.shouldCopyValues() ? new Array(len) : this._values;
        var result = this._promise;
        var isResolved = false;
        var bitField = null;
        for (var i = 0; i < len; ++i) {
            var maybePromise = tryConvertToPromise(values[i], result);

            if (maybePromise instanceof Promise) {
                maybePromise = maybePromise._target();
                bitField = maybePromise._bitField;
            } else {
                bitField = null;
            }

            if (isResolved) {
                if (bitField !== null) {
                    maybePromise.suppressUnhandledRejections();
                }
            } else if (bitField !== null) {
                if ((bitField & 50397184) === 0) {
                    maybePromise._proxy(this, i);
                    this._values[i] = maybePromise;
                } else if ((bitField & 33554432) !== 0) {
                    isResolved = this._promiseFulfilled(maybePromise._value(), i);
                } else if ((bitField & 16777216) !== 0) {
                    isResolved = this._promiseRejected(maybePromise._reason(), i);
                } else {
                    isResolved = this._promiseCancelled(i);
                }
            } else {
                isResolved = this._promiseFulfilled(maybePromise, i);
            }
        }
        if (!isResolved) result._setAsyncGuaranteed();
    };

    PromiseArray.prototype._isResolved = function () {
        return this._values === null;
    };

    PromiseArray.prototype._resolve = function (value) {
        this._values = null;
        this._promise._fulfill(value);
    };

    PromiseArray.prototype._cancel = function () {
        if (this._isResolved() || !this._promise._isCancellable()) return;
        this._values = null;
        this._promise._cancel();
    };

    PromiseArray.prototype._reject = function (reason) {
        this._values = null;
        this._promise._rejectCallback(reason, false);
    };

    PromiseArray.prototype._promiseFulfilled = function (value, index) {
        this._values[index] = value;
        var totalResolved = ++this._totalResolved;
        if (totalResolved >= this._length) {
            this._resolve(this._values);
            return true;
        }
        return false;
    };

    PromiseArray.prototype._promiseCancelled = function () {
        this._cancel();
        return true;
    };

    PromiseArray.prototype._promiseRejected = function (reason) {
        this._totalResolved++;
        this._reject(reason);
        return true;
    };

    PromiseArray.prototype._resultCancelled = function () {
        if (this._isResolved()) return;
        var values = this._values;
        this._cancel();
        if (values instanceof Promise) {
            values.cancel();
        } else {
            for (var i = 0; i < values.length; ++i) {
                if (values[i] instanceof Promise) {
                    values[i].cancel();
                }
            }
        }
    };

    PromiseArray.prototype.shouldCopyValues = function () {
        return true;
    };

    PromiseArray.prototype.getActualLength = function (len) {
        return len;
    };

    return PromiseArray;
};

/***/ }),
/* 76 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = function (Promise) {
    var longStackTraces = false;
    var contextStack = [];

    Promise.prototype._promiseCreated = function () {};
    Promise.prototype._pushContext = function () {};
    Promise.prototype._popContext = function () {
        return null;
    };
    Promise._peekContext = Promise.prototype._peekContext = function () {};

    function Context() {
        this._trace = new Context.CapturedTrace(peekContext());
    }
    Context.prototype._pushContext = function () {
        if (this._trace !== undefined) {
            this._trace._promiseCreated = null;
            contextStack.push(this._trace);
        }
    };

    Context.prototype._popContext = function () {
        if (this._trace !== undefined) {
            var trace = contextStack.pop();
            var ret = trace._promiseCreated;
            trace._promiseCreated = null;
            return ret;
        }
        return null;
    };

    function createContext() {
        if (longStackTraces) return new Context();
    }

    function peekContext() {
        var lastIndex = contextStack.length - 1;
        if (lastIndex >= 0) {
            return contextStack[lastIndex];
        }
        return undefined;
    }
    Context.CapturedTrace = null;
    Context.create = createContext;
    Context.deactivateLongStackTraces = function () {};
    Context.activateLongStackTraces = function () {
        var Promise_pushContext = Promise.prototype._pushContext;
        var Promise_popContext = Promise.prototype._popContext;
        var Promise_PeekContext = Promise._peekContext;
        var Promise_peekContext = Promise.prototype._peekContext;
        var Promise_promiseCreated = Promise.prototype._promiseCreated;
        Context.deactivateLongStackTraces = function () {
            Promise.prototype._pushContext = Promise_pushContext;
            Promise.prototype._popContext = Promise_popContext;
            Promise._peekContext = Promise_PeekContext;
            Promise.prototype._peekContext = Promise_peekContext;
            Promise.prototype._promiseCreated = Promise_promiseCreated;
            longStackTraces = false;
        };
        longStackTraces = true;
        Promise.prototype._pushContext = Context.prototype._pushContext;
        Promise.prototype._popContext = Context.prototype._popContext;
        Promise._peekContext = Promise.prototype._peekContext = peekContext;
        Promise.prototype._promiseCreated = function () {
            var ctx = this._peekContext();
            if (ctx && ctx._promiseCreated == null) ctx._promiseCreated = this;
        };
    };
    return Context;
};

/***/ }),
/* 77 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = function (Promise, Context) {
    var getDomain = Promise._getDomain;
    var async = Promise._async;
    var Warning = __webpack_require__(11).Warning;
    var util = __webpack_require__(1);
    var canAttachTrace = util.canAttachTrace;
    var unhandledRejectionHandled;
    var possiblyUnhandledRejection;
    var bluebirdFramePattern = /[\\\/]bluebird[\\\/]js[\\\/](release|debug|instrumented)/;
    var nodeFramePattern = /\((?:timers\.js):\d+:\d+\)/;
    var parseLinePattern = /[\/<\(](.+?):(\d+):(\d+)\)?\s*$/;
    var stackFramePattern = null;
    var formatStack = null;
    var indentStackFrames = false;
    var printWarning;
    var debugging = !!(util.env("BLUEBIRD_DEBUG") != 0 && (false || util.env("BLUEBIRD_DEBUG") || util.env("NODE_ENV") === "development"));

    var warnings = !!(util.env("BLUEBIRD_WARNINGS") != 0 && (debugging || util.env("BLUEBIRD_WARNINGS")));

    var longStackTraces = !!(util.env("BLUEBIRD_LONG_STACK_TRACES") != 0 && (debugging || util.env("BLUEBIRD_LONG_STACK_TRACES")));

    var wForgottenReturn = util.env("BLUEBIRD_W_FORGOTTEN_RETURN") != 0 && (warnings || !!util.env("BLUEBIRD_W_FORGOTTEN_RETURN"));

    Promise.prototype.suppressUnhandledRejections = function () {
        var target = this._target();
        target._bitField = target._bitField & ~1048576 | 524288;
    };

    Promise.prototype._ensurePossibleRejectionHandled = function () {
        if ((this._bitField & 524288) !== 0) return;
        this._setRejectionIsUnhandled();
        var self = this;
        setTimeout(function () {
            self._notifyUnhandledRejection();
        }, 1);
    };

    Promise.prototype._notifyUnhandledRejectionIsHandled = function () {
        fireRejectionEvent("rejectionHandled", unhandledRejectionHandled, undefined, this);
    };

    Promise.prototype._setReturnedNonUndefined = function () {
        this._bitField = this._bitField | 268435456;
    };

    Promise.prototype._returnedNonUndefined = function () {
        return (this._bitField & 268435456) !== 0;
    };

    Promise.prototype._notifyUnhandledRejection = function () {
        if (this._isRejectionUnhandled()) {
            var reason = this._settledValue();
            this._setUnhandledRejectionIsNotified();
            fireRejectionEvent("unhandledRejection", possiblyUnhandledRejection, reason, this);
        }
    };

    Promise.prototype._setUnhandledRejectionIsNotified = function () {
        this._bitField = this._bitField | 262144;
    };

    Promise.prototype._unsetUnhandledRejectionIsNotified = function () {
        this._bitField = this._bitField & ~262144;
    };

    Promise.prototype._isUnhandledRejectionNotified = function () {
        return (this._bitField & 262144) > 0;
    };

    Promise.prototype._setRejectionIsUnhandled = function () {
        this._bitField = this._bitField | 1048576;
    };

    Promise.prototype._unsetRejectionIsUnhandled = function () {
        this._bitField = this._bitField & ~1048576;
        if (this._isUnhandledRejectionNotified()) {
            this._unsetUnhandledRejectionIsNotified();
            this._notifyUnhandledRejectionIsHandled();
        }
    };

    Promise.prototype._isRejectionUnhandled = function () {
        return (this._bitField & 1048576) > 0;
    };

    Promise.prototype._warn = function (message, shouldUseOwnTrace, promise) {
        return warn(message, shouldUseOwnTrace, promise || this);
    };

    Promise.onPossiblyUnhandledRejection = function (fn) {
        var domain = getDomain();
        possiblyUnhandledRejection = typeof fn === "function" ? domain === null ? fn : util.domainBind(domain, fn) : undefined;
    };

    Promise.onUnhandledRejectionHandled = function (fn) {
        var domain = getDomain();
        unhandledRejectionHandled = typeof fn === "function" ? domain === null ? fn : util.domainBind(domain, fn) : undefined;
    };

    var disableLongStackTraces = function () {};
    Promise.longStackTraces = function () {
        if (async.haveItemsQueued() && !config.longStackTraces) {
            throw new Error("cannot enable long stack traces after promises have been created\u000a\u000a    See http://goo.gl/MqrFmX\u000a");
        }
        if (!config.longStackTraces && longStackTracesIsSupported()) {
            var Promise_captureStackTrace = Promise.prototype._captureStackTrace;
            var Promise_attachExtraTrace = Promise.prototype._attachExtraTrace;
            config.longStackTraces = true;
            disableLongStackTraces = function () {
                if (async.haveItemsQueued() && !config.longStackTraces) {
                    throw new Error("cannot enable long stack traces after promises have been created\u000a\u000a    See http://goo.gl/MqrFmX\u000a");
                }
                Promise.prototype._captureStackTrace = Promise_captureStackTrace;
                Promise.prototype._attachExtraTrace = Promise_attachExtraTrace;
                Context.deactivateLongStackTraces();
                async.enableTrampoline();
                config.longStackTraces = false;
            };
            Promise.prototype._captureStackTrace = longStackTracesCaptureStackTrace;
            Promise.prototype._attachExtraTrace = longStackTracesAttachExtraTrace;
            Context.activateLongStackTraces();
            async.disableTrampolineIfNecessary();
        }
    };

    Promise.hasLongStackTraces = function () {
        return config.longStackTraces && longStackTracesIsSupported();
    };

    var fireDomEvent = function () {
        try {
            if (typeof CustomEvent === "function") {
                var event = new CustomEvent("CustomEvent");
                util.global.dispatchEvent(event);
                return function (name, event) {
                    var domEvent = new CustomEvent(name.toLowerCase(), {
                        detail: event,
                        cancelable: true
                    });
                    return !util.global.dispatchEvent(domEvent);
                };
            } else if (typeof Event === "function") {
                var event = new Event("CustomEvent");
                util.global.dispatchEvent(event);
                return function (name, event) {
                    var domEvent = new Event(name.toLowerCase(), {
                        cancelable: true
                    });
                    domEvent.detail = event;
                    return !util.global.dispatchEvent(domEvent);
                };
            } else {
                var event = document.createEvent("CustomEvent");
                event.initCustomEvent("testingtheevent", false, true, {});
                util.global.dispatchEvent(event);
                return function (name, event) {
                    var domEvent = document.createEvent("CustomEvent");
                    domEvent.initCustomEvent(name.toLowerCase(), false, true, event);
                    return !util.global.dispatchEvent(domEvent);
                };
            }
        } catch (e) {}
        return function () {
            return false;
        };
    }();

    var fireGlobalEvent = function () {
        if (util.isNode) {
            return function () {
                return process.emit.apply(process, arguments);
            };
        } else {
            if (!util.global) {
                return function () {
                    return false;
                };
            }
            return function (name) {
                var methodName = "on" + name.toLowerCase();
                var method = util.global[methodName];
                if (!method) return false;
                method.apply(util.global, [].slice.call(arguments, 1));
                return true;
            };
        }
    }();

    function generatePromiseLifecycleEventObject(name, promise) {
        return { promise: promise };
    }

    var eventToObjectGenerator = {
        promiseCreated: generatePromiseLifecycleEventObject,
        promiseFulfilled: generatePromiseLifecycleEventObject,
        promiseRejected: generatePromiseLifecycleEventObject,
        promiseResolved: generatePromiseLifecycleEventObject,
        promiseCancelled: generatePromiseLifecycleEventObject,
        promiseChained: function (name, promise, child) {
            return { promise: promise, child: child };
        },
        warning: function (name, warning) {
            return { warning: warning };
        },
        unhandledRejection: function (name, reason, promise) {
            return { reason: reason, promise: promise };
        },
        rejectionHandled: generatePromiseLifecycleEventObject
    };

    var activeFireEvent = function (name) {
        var globalEventFired = false;
        try {
            globalEventFired = fireGlobalEvent.apply(null, arguments);
        } catch (e) {
            async.throwLater(e);
            globalEventFired = true;
        }

        var domEventFired = false;
        try {
            domEventFired = fireDomEvent(name, eventToObjectGenerator[name].apply(null, arguments));
        } catch (e) {
            async.throwLater(e);
            domEventFired = true;
        }

        return domEventFired || globalEventFired;
    };

    Promise.config = function (opts) {
        opts = Object(opts);
        if ("longStackTraces" in opts) {
            if (opts.longStackTraces) {
                Promise.longStackTraces();
            } else if (!opts.longStackTraces && Promise.hasLongStackTraces()) {
                disableLongStackTraces();
            }
        }
        if ("warnings" in opts) {
            var warningsOption = opts.warnings;
            config.warnings = !!warningsOption;
            wForgottenReturn = config.warnings;

            if (util.isObject(warningsOption)) {
                if ("wForgottenReturn" in warningsOption) {
                    wForgottenReturn = !!warningsOption.wForgottenReturn;
                }
            }
        }
        if ("cancellation" in opts && opts.cancellation && !config.cancellation) {
            if (async.haveItemsQueued()) {
                throw new Error("cannot enable cancellation after promises are in use");
            }
            Promise.prototype._clearCancellationData = cancellationClearCancellationData;
            Promise.prototype._propagateFrom = cancellationPropagateFrom;
            Promise.prototype._onCancel = cancellationOnCancel;
            Promise.prototype._setOnCancel = cancellationSetOnCancel;
            Promise.prototype._attachCancellationCallback = cancellationAttachCancellationCallback;
            Promise.prototype._execute = cancellationExecute;
            propagateFromFunction = cancellationPropagateFrom;
            config.cancellation = true;
        }
        if ("monitoring" in opts) {
            if (opts.monitoring && !config.monitoring) {
                config.monitoring = true;
                Promise.prototype._fireEvent = activeFireEvent;
            } else if (!opts.monitoring && config.monitoring) {
                config.monitoring = false;
                Promise.prototype._fireEvent = defaultFireEvent;
            }
        }
        return Promise;
    };

    function defaultFireEvent() {
        return false;
    }

    Promise.prototype._fireEvent = defaultFireEvent;
    Promise.prototype._execute = function (executor, resolve, reject) {
        try {
            executor(resolve, reject);
        } catch (e) {
            return e;
        }
    };
    Promise.prototype._onCancel = function () {};
    Promise.prototype._setOnCancel = function (handler) {
        ;
    };
    Promise.prototype._attachCancellationCallback = function (onCancel) {
        ;
    };
    Promise.prototype._captureStackTrace = function () {};
    Promise.prototype._attachExtraTrace = function () {};
    Promise.prototype._clearCancellationData = function () {};
    Promise.prototype._propagateFrom = function (parent, flags) {
        ;
        ;
    };

    function cancellationExecute(executor, resolve, reject) {
        var promise = this;
        try {
            executor(resolve, reject, function (onCancel) {
                if (typeof onCancel !== "function") {
                    throw new TypeError("onCancel must be a function, got: " + util.toString(onCancel));
                }
                promise._attachCancellationCallback(onCancel);
            });
        } catch (e) {
            return e;
        }
    }

    function cancellationAttachCancellationCallback(onCancel) {
        if (!this._isCancellable()) return this;

        var previousOnCancel = this._onCancel();
        if (previousOnCancel !== undefined) {
            if (util.isArray(previousOnCancel)) {
                previousOnCancel.push(onCancel);
            } else {
                this._setOnCancel([previousOnCancel, onCancel]);
            }
        } else {
            this._setOnCancel(onCancel);
        }
    }

    function cancellationOnCancel() {
        return this._onCancelField;
    }

    function cancellationSetOnCancel(onCancel) {
        this._onCancelField = onCancel;
    }

    function cancellationClearCancellationData() {
        this._cancellationParent = undefined;
        this._onCancelField = undefined;
    }

    function cancellationPropagateFrom(parent, flags) {
        if ((flags & 1) !== 0) {
            this._cancellationParent = parent;
            var branchesRemainingToCancel = parent._branchesRemainingToCancel;
            if (branchesRemainingToCancel === undefined) {
                branchesRemainingToCancel = 0;
            }
            parent._branchesRemainingToCancel = branchesRemainingToCancel + 1;
        }
        if ((flags & 2) !== 0 && parent._isBound()) {
            this._setBoundTo(parent._boundTo);
        }
    }

    function bindingPropagateFrom(parent, flags) {
        if ((flags & 2) !== 0 && parent._isBound()) {
            this._setBoundTo(parent._boundTo);
        }
    }
    var propagateFromFunction = bindingPropagateFrom;

    function boundValueFunction() {
        var ret = this._boundTo;
        if (ret !== undefined) {
            if (ret instanceof Promise) {
                if (ret.isFulfilled()) {
                    return ret.value();
                } else {
                    return undefined;
                }
            }
        }
        return ret;
    }

    function longStackTracesCaptureStackTrace() {
        this._trace = new CapturedTrace(this._peekContext());
    }

    function longStackTracesAttachExtraTrace(error, ignoreSelf) {
        if (canAttachTrace(error)) {
            var trace = this._trace;
            if (trace !== undefined) {
                if (ignoreSelf) trace = trace._parent;
            }
            if (trace !== undefined) {
                trace.attachExtraTrace(error);
            } else if (!error.__stackCleaned__) {
                var parsed = parseStackAndMessage(error);
                util.notEnumerableProp(error, "stack", parsed.message + "\n" + parsed.stack.join("\n"));
                util.notEnumerableProp(error, "__stackCleaned__", true);
            }
        }
    }

    function checkForgottenReturns(returnValue, promiseCreated, name, promise, parent) {
        if (returnValue === undefined && promiseCreated !== null && wForgottenReturn) {
            if (parent !== undefined && parent._returnedNonUndefined()) return;
            if ((promise._bitField & 65535) === 0) return;

            if (name) name = name + " ";
            var handlerLine = "";
            var creatorLine = "";
            if (promiseCreated._trace) {
                var traceLines = promiseCreated._trace.stack.split("\n");
                var stack = cleanStack(traceLines);
                for (var i = stack.length - 1; i >= 0; --i) {
                    var line = stack[i];
                    if (!nodeFramePattern.test(line)) {
                        var lineMatches = line.match(parseLinePattern);
                        if (lineMatches) {
                            handlerLine = "at " + lineMatches[1] + ":" + lineMatches[2] + ":" + lineMatches[3] + " ";
                        }
                        break;
                    }
                }

                if (stack.length > 0) {
                    var firstUserLine = stack[0];
                    for (var i = 0; i < traceLines.length; ++i) {

                        if (traceLines[i] === firstUserLine) {
                            if (i > 0) {
                                creatorLine = "\n" + traceLines[i - 1];
                            }
                            break;
                        }
                    }
                }
            }
            var msg = "a promise was created in a " + name + "handler " + handlerLine + "but was not returned from it, " + "see http://goo.gl/rRqMUw" + creatorLine;
            promise._warn(msg, true, promiseCreated);
        }
    }

    function deprecated(name, replacement) {
        var message = name + " is deprecated and will be removed in a future version.";
        if (replacement) message += " Use " + replacement + " instead.";
        return warn(message);
    }

    function warn(message, shouldUseOwnTrace, promise) {
        if (!config.warnings) return;
        var warning = new Warning(message);
        var ctx;
        if (shouldUseOwnTrace) {
            promise._attachExtraTrace(warning);
        } else if (config.longStackTraces && (ctx = Promise._peekContext())) {
            ctx.attachExtraTrace(warning);
        } else {
            var parsed = parseStackAndMessage(warning);
            warning.stack = parsed.message + "\n" + parsed.stack.join("\n");
        }

        if (!activeFireEvent("warning", warning)) {
            formatAndLogError(warning, "", true);
        }
    }

    function reconstructStack(message, stacks) {
        for (var i = 0; i < stacks.length - 1; ++i) {
            stacks[i].push("From previous event:");
            stacks[i] = stacks[i].join("\n");
        }
        if (i < stacks.length) {
            stacks[i] = stacks[i].join("\n");
        }
        return message + "\n" + stacks.join("\n");
    }

    function removeDuplicateOrEmptyJumps(stacks) {
        for (var i = 0; i < stacks.length; ++i) {
            if (stacks[i].length === 0 || i + 1 < stacks.length && stacks[i][0] === stacks[i + 1][0]) {
                stacks.splice(i, 1);
                i--;
            }
        }
    }

    function removeCommonRoots(stacks) {
        var current = stacks[0];
        for (var i = 1; i < stacks.length; ++i) {
            var prev = stacks[i];
            var currentLastIndex = current.length - 1;
            var currentLastLine = current[currentLastIndex];
            var commonRootMeetPoint = -1;

            for (var j = prev.length - 1; j >= 0; --j) {
                if (prev[j] === currentLastLine) {
                    commonRootMeetPoint = j;
                    break;
                }
            }

            for (var j = commonRootMeetPoint; j >= 0; --j) {
                var line = prev[j];
                if (current[currentLastIndex] === line) {
                    current.pop();
                    currentLastIndex--;
                } else {
                    break;
                }
            }
            current = prev;
        }
    }

    function cleanStack(stack) {
        var ret = [];
        for (var i = 0; i < stack.length; ++i) {
            var line = stack[i];
            var isTraceLine = "    (No stack trace)" === line || stackFramePattern.test(line);
            var isInternalFrame = isTraceLine && shouldIgnore(line);
            if (isTraceLine && !isInternalFrame) {
                if (indentStackFrames && line.charAt(0) !== " ") {
                    line = "    " + line;
                }
                ret.push(line);
            }
        }
        return ret;
    }

    function stackFramesAsArray(error) {
        var stack = error.stack.replace(/\s+$/g, "").split("\n");
        for (var i = 0; i < stack.length; ++i) {
            var line = stack[i];
            if ("    (No stack trace)" === line || stackFramePattern.test(line)) {
                break;
            }
        }
        if (i > 0 && error.name != "SyntaxError") {
            stack = stack.slice(i);
        }
        return stack;
    }

    function parseStackAndMessage(error) {
        var stack = error.stack;
        var message = error.toString();
        stack = typeof stack === "string" && stack.length > 0 ? stackFramesAsArray(error) : ["    (No stack trace)"];
        return {
            message: message,
            stack: error.name == "SyntaxError" ? stack : cleanStack(stack)
        };
    }

    function formatAndLogError(error, title, isSoft) {
        if (typeof console !== "undefined") {
            var message;
            if (util.isObject(error)) {
                var stack = error.stack;
                message = title + formatStack(stack, error);
            } else {
                message = title + String(error);
            }
            if (typeof printWarning === "function") {
                printWarning(message, isSoft);
            } else if (typeof console.log === "function" || typeof console.log === "object") {
                console.log(message);
            }
        }
    }

    function fireRejectionEvent(name, localHandler, reason, promise) {
        var localEventFired = false;
        try {
            if (typeof localHandler === "function") {
                localEventFired = true;
                if (name === "rejectionHandled") {
                    localHandler(promise);
                } else {
                    localHandler(reason, promise);
                }
            }
        } catch (e) {
            async.throwLater(e);
        }

        if (name === "unhandledRejection") {
            if (!activeFireEvent(name, reason, promise) && !localEventFired) {
                formatAndLogError(reason, "Unhandled rejection ");
            }
        } else {
            activeFireEvent(name, promise);
        }
    }

    function formatNonError(obj) {
        var str;
        if (typeof obj === "function") {
            str = "[function " + (obj.name || "anonymous") + "]";
        } else {
            str = obj && typeof obj.toString === "function" ? obj.toString() : util.toString(obj);
            var ruselessToString = /\[object [a-zA-Z0-9$_]+\]/;
            if (ruselessToString.test(str)) {
                try {
                    var newStr = JSON.stringify(obj);
                    str = newStr;
                } catch (e) {}
            }
            if (str.length === 0) {
                str = "(empty array)";
            }
        }
        return "(<" + snip(str) + ">, no stack trace)";
    }

    function snip(str) {
        var maxChars = 41;
        if (str.length < maxChars) {
            return str;
        }
        return str.substr(0, maxChars - 3) + "...";
    }

    function longStackTracesIsSupported() {
        return typeof captureStackTrace === "function";
    }

    var shouldIgnore = function () {
        return false;
    };
    var parseLineInfoRegex = /[\/<\(]([^:\/]+):(\d+):(?:\d+)\)?\s*$/;
    function parseLineInfo(line) {
        var matches = line.match(parseLineInfoRegex);
        if (matches) {
            return {
                fileName: matches[1],
                line: parseInt(matches[2], 10)
            };
        }
    }

    function setBounds(firstLineError, lastLineError) {
        if (!longStackTracesIsSupported()) return;
        var firstStackLines = firstLineError.stack.split("\n");
        var lastStackLines = lastLineError.stack.split("\n");
        var firstIndex = -1;
        var lastIndex = -1;
        var firstFileName;
        var lastFileName;
        for (var i = 0; i < firstStackLines.length; ++i) {
            var result = parseLineInfo(firstStackLines[i]);
            if (result) {
                firstFileName = result.fileName;
                firstIndex = result.line;
                break;
            }
        }
        for (var i = 0; i < lastStackLines.length; ++i) {
            var result = parseLineInfo(lastStackLines[i]);
            if (result) {
                lastFileName = result.fileName;
                lastIndex = result.line;
                break;
            }
        }
        if (firstIndex < 0 || lastIndex < 0 || !firstFileName || !lastFileName || firstFileName !== lastFileName || firstIndex >= lastIndex) {
            return;
        }

        shouldIgnore = function (line) {
            if (bluebirdFramePattern.test(line)) return true;
            var info = parseLineInfo(line);
            if (info) {
                if (info.fileName === firstFileName && firstIndex <= info.line && info.line <= lastIndex) {
                    return true;
                }
            }
            return false;
        };
    }

    function CapturedTrace(parent) {
        this._parent = parent;
        this._promisesCreated = 0;
        var length = this._length = 1 + (parent === undefined ? 0 : parent._length);
        captureStackTrace(this, CapturedTrace);
        if (length > 32) this.uncycle();
    }
    util.inherits(CapturedTrace, Error);
    Context.CapturedTrace = CapturedTrace;

    CapturedTrace.prototype.uncycle = function () {
        var length = this._length;
        if (length < 2) return;
        var nodes = [];
        var stackToIndex = {};

        for (var i = 0, node = this; node !== undefined; ++i) {
            nodes.push(node);
            node = node._parent;
        }
        length = this._length = i;
        for (var i = length - 1; i >= 0; --i) {
            var stack = nodes[i].stack;
            if (stackToIndex[stack] === undefined) {
                stackToIndex[stack] = i;
            }
        }
        for (var i = 0; i < length; ++i) {
            var currentStack = nodes[i].stack;
            var index = stackToIndex[currentStack];
            if (index !== undefined && index !== i) {
                if (index > 0) {
                    nodes[index - 1]._parent = undefined;
                    nodes[index - 1]._length = 1;
                }
                nodes[i]._parent = undefined;
                nodes[i]._length = 1;
                var cycleEdgeNode = i > 0 ? nodes[i - 1] : this;

                if (index < length - 1) {
                    cycleEdgeNode._parent = nodes[index + 1];
                    cycleEdgeNode._parent.uncycle();
                    cycleEdgeNode._length = cycleEdgeNode._parent._length + 1;
                } else {
                    cycleEdgeNode._parent = undefined;
                    cycleEdgeNode._length = 1;
                }
                var currentChildLength = cycleEdgeNode._length + 1;
                for (var j = i - 2; j >= 0; --j) {
                    nodes[j]._length = currentChildLength;
                    currentChildLength++;
                }
                return;
            }
        }
    };

    CapturedTrace.prototype.attachExtraTrace = function (error) {
        if (error.__stackCleaned__) return;
        this.uncycle();
        var parsed = parseStackAndMessage(error);
        var message = parsed.message;
        var stacks = [parsed.stack];

        var trace = this;
        while (trace !== undefined) {
            stacks.push(cleanStack(trace.stack.split("\n")));
            trace = trace._parent;
        }
        removeCommonRoots(stacks);
        removeDuplicateOrEmptyJumps(stacks);
        util.notEnumerableProp(error, "stack", reconstructStack(message, stacks));
        util.notEnumerableProp(error, "__stackCleaned__", true);
    };

    var captureStackTrace = function stackDetection() {
        var v8stackFramePattern = /^\s*at\s*/;
        var v8stackFormatter = function (stack, error) {
            if (typeof stack === "string") return stack;

            if (error.name !== undefined && error.message !== undefined) {
                return error.toString();
            }
            return formatNonError(error);
        };

        if (typeof Error.stackTraceLimit === "number" && typeof Error.captureStackTrace === "function") {
            Error.stackTraceLimit += 6;
            stackFramePattern = v8stackFramePattern;
            formatStack = v8stackFormatter;
            var captureStackTrace = Error.captureStackTrace;

            shouldIgnore = function (line) {
                return bluebirdFramePattern.test(line);
            };
            return function (receiver, ignoreUntil) {
                Error.stackTraceLimit += 6;
                captureStackTrace(receiver, ignoreUntil);
                Error.stackTraceLimit -= 6;
            };
        }
        var err = new Error();

        if (typeof err.stack === "string" && err.stack.split("\n")[0].indexOf("stackDetection@") >= 0) {
            stackFramePattern = /@/;
            formatStack = v8stackFormatter;
            indentStackFrames = true;
            return function captureStackTrace(o) {
                o.stack = new Error().stack;
            };
        }

        var hasStackAfterThrow;
        try {
            throw new Error();
        } catch (e) {
            hasStackAfterThrow = "stack" in e;
        }
        if (!("stack" in err) && hasStackAfterThrow && typeof Error.stackTraceLimit === "number") {
            stackFramePattern = v8stackFramePattern;
            formatStack = v8stackFormatter;
            return function captureStackTrace(o) {
                Error.stackTraceLimit += 6;
                try {
                    throw new Error();
                } catch (e) {
                    o.stack = e.stack;
                }
                Error.stackTraceLimit -= 6;
            };
        }

        formatStack = function (stack, error) {
            if (typeof stack === "string") return stack;

            if ((typeof error === "object" || typeof error === "function") && error.name !== undefined && error.message !== undefined) {
                return error.toString();
            }
            return formatNonError(error);
        };

        return null;
    }([]);

    if (typeof console !== "undefined" && typeof console.warn !== "undefined") {
        printWarning = function (message) {
            console.warn(message);
        };
        if (util.isNode && process.stderr.isTTY) {
            printWarning = function (message, isSoft) {
                var color = isSoft ? "\u001b[33m" : "\u001b[31m";
                console.warn(color + message + "\u001b[0m\n");
            };
        } else if (!util.isNode && typeof new Error().stack === "string") {
            printWarning = function (message, isSoft) {
                console.warn("%c" + message, isSoft ? "color: darkorange" : "color: red");
            };
        }
    }

    var config = {
        warnings: warnings,
        longStackTraces: false,
        cancellation: false,
        monitoring: false
    };

    if (longStackTraces) Promise.longStackTraces();

    return {
        longStackTraces: function () {
            return config.longStackTraces;
        },
        warnings: function () {
            return config.warnings;
        },
        cancellation: function () {
            return config.cancellation;
        },
        monitoring: function () {
            return config.monitoring;
        },
        propagateFromFunction: function () {
            return propagateFromFunction;
        },
        boundValueFunction: function () {
            return boundValueFunction;
        },
        checkForgottenReturns: checkForgottenReturns,
        setBounds: setBounds,
        warn: warn,
        deprecated: deprecated,
        CapturedTrace: CapturedTrace,
        fireDomEvent: fireDomEvent,
        fireGlobalEvent: fireGlobalEvent
    };
};

/***/ }),
/* 78 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = function (Promise, tryConvertToPromise, NEXT_FILTER) {
    var util = __webpack_require__(1);
    var CancellationError = Promise.CancellationError;
    var errorObj = util.errorObj;
    var catchFilter = __webpack_require__(38)(NEXT_FILTER);

    function PassThroughHandlerContext(promise, type, handler) {
        this.promise = promise;
        this.type = type;
        this.handler = handler;
        this.called = false;
        this.cancelPromise = null;
    }

    PassThroughHandlerContext.prototype.isFinallyHandler = function () {
        return this.type === 0;
    };

    function FinallyHandlerCancelReaction(finallyHandler) {
        this.finallyHandler = finallyHandler;
    }

    FinallyHandlerCancelReaction.prototype._resultCancelled = function () {
        checkCancel(this.finallyHandler);
    };

    function checkCancel(ctx, reason) {
        if (ctx.cancelPromise != null) {
            if (arguments.length > 1) {
                ctx.cancelPromise._reject(reason);
            } else {
                ctx.cancelPromise._cancel();
            }
            ctx.cancelPromise = null;
            return true;
        }
        return false;
    }

    function succeed() {
        return finallyHandler.call(this, this.promise._target()._settledValue());
    }
    function fail(reason) {
        if (checkCancel(this, reason)) return;
        errorObj.e = reason;
        return errorObj;
    }
    function finallyHandler(reasonOrValue) {
        var promise = this.promise;
        var handler = this.handler;

        if (!this.called) {
            this.called = true;
            var ret = this.isFinallyHandler() ? handler.call(promise._boundValue()) : handler.call(promise._boundValue(), reasonOrValue);
            if (ret === NEXT_FILTER) {
                return ret;
            } else if (ret !== undefined) {
                promise._setReturnedNonUndefined();
                var maybePromise = tryConvertToPromise(ret, promise);
                if (maybePromise instanceof Promise) {
                    if (this.cancelPromise != null) {
                        if (maybePromise._isCancelled()) {
                            var reason = new CancellationError("late cancellation observer");
                            promise._attachExtraTrace(reason);
                            errorObj.e = reason;
                            return errorObj;
                        } else if (maybePromise.isPending()) {
                            maybePromise._attachCancellationCallback(new FinallyHandlerCancelReaction(this));
                        }
                    }
                    return maybePromise._then(succeed, fail, undefined, this, undefined);
                }
            }
        }

        if (promise.isRejected()) {
            checkCancel(this);
            errorObj.e = reasonOrValue;
            return errorObj;
        } else {
            checkCancel(this);
            return reasonOrValue;
        }
    }

    Promise.prototype._passThrough = function (handler, type, success, fail) {
        if (typeof handler !== "function") return this.then();
        return this._then(success, fail, undefined, new PassThroughHandlerContext(this, type, handler), undefined);
    };

    Promise.prototype.lastly = Promise.prototype["finally"] = function (handler) {
        return this._passThrough(handler, 0, finallyHandler, finallyHandler);
    };

    Promise.prototype.tap = function (handler) {
        return this._passThrough(handler, 1, finallyHandler);
    };

    Promise.prototype.tapCatch = function (handlerOrPredicate) {
        var len = arguments.length;
        if (len === 1) {
            return this._passThrough(handlerOrPredicate, 1, undefined, finallyHandler);
        } else {
            var catchInstances = new Array(len - 1),
                j = 0,
                i;
            for (i = 0; i < len - 1; ++i) {
                var item = arguments[i];
                if (util.isObject(item)) {
                    catchInstances[j++] = item;
                } else {
                    return Promise.reject(new TypeError("tapCatch statement predicate: " + "expecting an object but got " + util.classString(item)));
                }
            }
            catchInstances.length = j;
            var handler = arguments[i];
            return this._passThrough(catchFilter(catchInstances, handler, this), 1, undefined, finallyHandler);
        }
    };

    return PassThroughHandlerContext;
};

/***/ }),
/* 79 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = function (Promise, INTERNAL, tryConvertToPromise, apiRejection, debug) {
    var util = __webpack_require__(1);
    var tryCatch = util.tryCatch;

    Promise.method = function (fn) {
        if (typeof fn !== "function") {
            throw new Promise.TypeError("expecting a function but got " + util.classString(fn));
        }
        return function () {
            var ret = new Promise(INTERNAL);
            ret._captureStackTrace();
            ret._pushContext();
            var value = tryCatch(fn).apply(this, arguments);
            var promiseCreated = ret._popContext();
            debug.checkForgottenReturns(value, promiseCreated, "Promise.method", ret);
            ret._resolveFromSyncValue(value);
            return ret;
        };
    };

    Promise.attempt = Promise["try"] = function (fn) {
        if (typeof fn !== "function") {
            return apiRejection("expecting a function but got " + util.classString(fn));
        }
        var ret = new Promise(INTERNAL);
        ret._captureStackTrace();
        ret._pushContext();
        var value;
        if (arguments.length > 1) {
            debug.deprecated("calling Promise.try with more than 1 argument");
            var arg = arguments[1];
            var ctx = arguments[2];
            value = util.isArray(arg) ? tryCatch(fn).apply(ctx, arg) : tryCatch(fn).call(ctx, arg);
        } else {
            value = tryCatch(fn)();
        }
        var promiseCreated = ret._popContext();
        debug.checkForgottenReturns(value, promiseCreated, "Promise.try", ret);
        ret._resolveFromSyncValue(value);
        return ret;
    };

    Promise.prototype._resolveFromSyncValue = function (value) {
        if (value === util.errorObj) {
            this._rejectCallback(value.e, false);
        } else {
            this._resolveCallback(value, true);
        }
    };
};

/***/ }),
/* 80 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = function (Promise, INTERNAL, tryConvertToPromise, debug) {
    var calledBind = false;
    var rejectThis = function (_, e) {
        this._reject(e);
    };

    var targetRejected = function (e, context) {
        context.promiseRejectionQueued = true;
        context.bindingPromise._then(rejectThis, rejectThis, null, this, e);
    };

    var bindingResolved = function (thisArg, context) {
        if ((this._bitField & 50397184) === 0) {
            this._resolveCallback(context.target);
        }
    };

    var bindingRejected = function (e, context) {
        if (!context.promiseRejectionQueued) this._reject(e);
    };

    Promise.prototype.bind = function (thisArg) {
        if (!calledBind) {
            calledBind = true;
            Promise.prototype._propagateFrom = debug.propagateFromFunction();
            Promise.prototype._boundValue = debug.boundValueFunction();
        }
        var maybePromise = tryConvertToPromise(thisArg);
        var ret = new Promise(INTERNAL);
        ret._propagateFrom(this, 1);
        var target = this._target();
        ret._setBoundTo(maybePromise);
        if (maybePromise instanceof Promise) {
            var context = {
                promiseRejectionQueued: false,
                promise: ret,
                target: target,
                bindingPromise: maybePromise
            };
            target._then(INTERNAL, targetRejected, undefined, ret, context);
            maybePromise._then(bindingResolved, bindingRejected, undefined, ret, context);
            ret._setOnCancel(maybePromise);
        } else {
            ret._resolveCallback(target);
        }
        return ret;
    };

    Promise.prototype._setBoundTo = function (obj) {
        if (obj !== undefined) {
            this._bitField = this._bitField | 2097152;
            this._boundTo = obj;
        } else {
            this._bitField = this._bitField & ~2097152;
        }
    };

    Promise.prototype._isBound = function () {
        return (this._bitField & 2097152) === 2097152;
    };

    Promise.bind = function (thisArg, value) {
        return Promise.resolve(value).bind(thisArg);
    };
};

/***/ }),
/* 81 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = function (Promise, PromiseArray, apiRejection, debug) {
    var util = __webpack_require__(1);
    var tryCatch = util.tryCatch;
    var errorObj = util.errorObj;
    var async = Promise._async;

    Promise.prototype["break"] = Promise.prototype.cancel = function () {
        if (!debug.cancellation()) return this._warn("cancellation is disabled");

        var promise = this;
        var child = promise;
        while (promise._isCancellable()) {
            if (!promise._cancelBy(child)) {
                if (child._isFollowing()) {
                    child._followee().cancel();
                } else {
                    child._cancelBranched();
                }
                break;
            }

            var parent = promise._cancellationParent;
            if (parent == null || !parent._isCancellable()) {
                if (promise._isFollowing()) {
                    promise._followee().cancel();
                } else {
                    promise._cancelBranched();
                }
                break;
            } else {
                if (promise._isFollowing()) promise._followee().cancel();
                promise._setWillBeCancelled();
                child = promise;
                promise = parent;
            }
        }
    };

    Promise.prototype._branchHasCancelled = function () {
        this._branchesRemainingToCancel--;
    };

    Promise.prototype._enoughBranchesHaveCancelled = function () {
        return this._branchesRemainingToCancel === undefined || this._branchesRemainingToCancel <= 0;
    };

    Promise.prototype._cancelBy = function (canceller) {
        if (canceller === this) {
            this._branchesRemainingToCancel = 0;
            this._invokeOnCancel();
            return true;
        } else {
            this._branchHasCancelled();
            if (this._enoughBranchesHaveCancelled()) {
                this._invokeOnCancel();
                return true;
            }
        }
        return false;
    };

    Promise.prototype._cancelBranched = function () {
        if (this._enoughBranchesHaveCancelled()) {
            this._cancel();
        }
    };

    Promise.prototype._cancel = function () {
        if (!this._isCancellable()) return;
        this._setCancelled();
        async.invoke(this._cancelPromises, this, undefined);
    };

    Promise.prototype._cancelPromises = function () {
        if (this._length() > 0) this._settlePromises();
    };

    Promise.prototype._unsetOnCancel = function () {
        this._onCancelField = undefined;
    };

    Promise.prototype._isCancellable = function () {
        return this.isPending() && !this._isCancelled();
    };

    Promise.prototype.isCancellable = function () {
        return this.isPending() && !this.isCancelled();
    };

    Promise.prototype._doInvokeOnCancel = function (onCancelCallback, internalOnly) {
        if (util.isArray(onCancelCallback)) {
            for (var i = 0; i < onCancelCallback.length; ++i) {
                this._doInvokeOnCancel(onCancelCallback[i], internalOnly);
            }
        } else if (onCancelCallback !== undefined) {
            if (typeof onCancelCallback === "function") {
                if (!internalOnly) {
                    var e = tryCatch(onCancelCallback).call(this._boundValue());
                    if (e === errorObj) {
                        this._attachExtraTrace(e.e);
                        async.throwLater(e.e);
                    }
                }
            } else {
                onCancelCallback._resultCancelled(this);
            }
        }
    };

    Promise.prototype._invokeOnCancel = function () {
        var onCancelCallback = this._onCancel();
        this._unsetOnCancel();
        async.invoke(this._doInvokeOnCancel, this, onCancelCallback);
    };

    Promise.prototype._invokeInternalOnCancel = function () {
        if (this._isCancellable()) {
            this._doInvokeOnCancel(this._onCancel(), true);
            this._unsetOnCancel();
        }
    };

    Promise.prototype._resultCancelled = function () {
        this.cancel();
    };
};

/***/ }),
/* 82 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = function (Promise) {
    function returner() {
        return this.value;
    }
    function thrower() {
        throw this.reason;
    }

    Promise.prototype["return"] = Promise.prototype.thenReturn = function (value) {
        if (value instanceof Promise) value.suppressUnhandledRejections();
        return this._then(returner, undefined, undefined, { value: value }, undefined);
    };

    Promise.prototype["throw"] = Promise.prototype.thenThrow = function (reason) {
        return this._then(thrower, undefined, undefined, { reason: reason }, undefined);
    };

    Promise.prototype.catchThrow = function (reason) {
        if (arguments.length <= 1) {
            return this._then(undefined, thrower, undefined, { reason: reason }, undefined);
        } else {
            var _reason = arguments[1];
            var handler = function () {
                throw _reason;
            };
            return this.caught(reason, handler);
        }
    };

    Promise.prototype.catchReturn = function (value) {
        if (arguments.length <= 1) {
            if (value instanceof Promise) value.suppressUnhandledRejections();
            return this._then(undefined, returner, undefined, { value: value }, undefined);
        } else {
            var _value = arguments[1];
            if (_value instanceof Promise) _value.suppressUnhandledRejections();
            var handler = function () {
                return _value;
            };
            return this.caught(value, handler);
        }
    };
};

/***/ }),
/* 83 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = function (Promise) {
    function PromiseInspection(promise) {
        if (promise !== undefined) {
            promise = promise._target();
            this._bitField = promise._bitField;
            this._settledValueField = promise._isFateSealed() ? promise._settledValue() : undefined;
        } else {
            this._bitField = 0;
            this._settledValueField = undefined;
        }
    }

    PromiseInspection.prototype._settledValue = function () {
        return this._settledValueField;
    };

    var value = PromiseInspection.prototype.value = function () {
        if (!this.isFulfilled()) {
            throw new TypeError("cannot get fulfillment value of a non-fulfilled promise\u000a\u000a    See http://goo.gl/MqrFmX\u000a");
        }
        return this._settledValue();
    };

    var reason = PromiseInspection.prototype.error = PromiseInspection.prototype.reason = function () {
        if (!this.isRejected()) {
            throw new TypeError("cannot get rejection reason of a non-rejected promise\u000a\u000a    See http://goo.gl/MqrFmX\u000a");
        }
        return this._settledValue();
    };

    var isFulfilled = PromiseInspection.prototype.isFulfilled = function () {
        return (this._bitField & 33554432) !== 0;
    };

    var isRejected = PromiseInspection.prototype.isRejected = function () {
        return (this._bitField & 16777216) !== 0;
    };

    var isPending = PromiseInspection.prototype.isPending = function () {
        return (this._bitField & 50397184) === 0;
    };

    var isResolved = PromiseInspection.prototype.isResolved = function () {
        return (this._bitField & 50331648) !== 0;
    };

    PromiseInspection.prototype.isCancelled = function () {
        return (this._bitField & 8454144) !== 0;
    };

    Promise.prototype.__isCancelled = function () {
        return (this._bitField & 65536) === 65536;
    };

    Promise.prototype._isCancelled = function () {
        return this._target().__isCancelled();
    };

    Promise.prototype.isCancelled = function () {
        return (this._target()._bitField & 8454144) !== 0;
    };

    Promise.prototype.isPending = function () {
        return isPending.call(this._target());
    };

    Promise.prototype.isRejected = function () {
        return isRejected.call(this._target());
    };

    Promise.prototype.isFulfilled = function () {
        return isFulfilled.call(this._target());
    };

    Promise.prototype.isResolved = function () {
        return isResolved.call(this._target());
    };

    Promise.prototype.value = function () {
        return value.call(this._target());
    };

    Promise.prototype.reason = function () {
        var target = this._target();
        target._unsetRejectionIsUnhandled();
        return reason.call(target);
    };

    Promise.prototype._value = function () {
        return this._settledValue();
    };

    Promise.prototype._reason = function () {
        this._unsetRejectionIsUnhandled();
        return this._settledValue();
    };

    Promise.PromiseInspection = PromiseInspection;
};

/***/ }),
/* 84 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = function (Promise, PromiseArray, tryConvertToPromise, INTERNAL, async, getDomain) {
    var util = __webpack_require__(1);
    var canEvaluate = util.canEvaluate;
    var tryCatch = util.tryCatch;
    var errorObj = util.errorObj;
    var reject;

    if (true) {
        if (canEvaluate) {
            var thenCallback = function (i) {
                return new Function("value", "holder", "                             \n\
            'use strict';                                                    \n\
            holder.pIndex = value;                                           \n\
            holder.checkFulfillment(this);                                   \n\
            ".replace(/Index/g, i));
            };

            var promiseSetter = function (i) {
                return new Function("promise", "holder", "                           \n\
            'use strict';                                                    \n\
            holder.pIndex = promise;                                         \n\
            ".replace(/Index/g, i));
            };

            var generateHolderClass = function (total) {
                var props = new Array(total);
                for (var i = 0; i < props.length; ++i) {
                    props[i] = "this.p" + (i + 1);
                }
                var assignment = props.join(" = ") + " = null;";
                var cancellationCode = "var promise;\n" + props.map(function (prop) {
                    return "                                                         \n\
                promise = " + prop + ";                                      \n\
                if (promise instanceof Promise) {                            \n\
                    promise.cancel();                                        \n\
                }                                                            \n\
            ";
                }).join("\n");
                var passedArguments = props.join(", ");
                var name = "Holder$" + total;

                var code = "return function(tryCatch, errorObj, Promise, async) {    \n\
            'use strict';                                                    \n\
            function [TheName](fn) {                                         \n\
                [TheProperties]                                              \n\
                this.fn = fn;                                                \n\
                this.asyncNeeded = true;                                     \n\
                this.now = 0;                                                \n\
            }                                                                \n\
                                                                             \n\
            [TheName].prototype._callFunction = function(promise) {          \n\
                promise._pushContext();                                      \n\
                var ret = tryCatch(this.fn)([ThePassedArguments]);           \n\
                promise._popContext();                                       \n\
                if (ret === errorObj) {                                      \n\
                    promise._rejectCallback(ret.e, false);                   \n\
                } else {                                                     \n\
                    promise._resolveCallback(ret);                           \n\
                }                                                            \n\
            };                                                               \n\
                                                                             \n\
            [TheName].prototype.checkFulfillment = function(promise) {       \n\
                var now = ++this.now;                                        \n\
                if (now === [TheTotal]) {                                    \n\
                    if (this.asyncNeeded) {                                  \n\
                        async.invoke(this._callFunction, this, promise);     \n\
                    } else {                                                 \n\
                        this._callFunction(promise);                         \n\
                    }                                                        \n\
                                                                             \n\
                }                                                            \n\
            };                                                               \n\
                                                                             \n\
            [TheName].prototype._resultCancelled = function() {              \n\
                [CancellationCode]                                           \n\
            };                                                               \n\
                                                                             \n\
            return [TheName];                                                \n\
        }(tryCatch, errorObj, Promise, async);                               \n\
        ";

                code = code.replace(/\[TheName\]/g, name).replace(/\[TheTotal\]/g, total).replace(/\[ThePassedArguments\]/g, passedArguments).replace(/\[TheProperties\]/g, assignment).replace(/\[CancellationCode\]/g, cancellationCode);

                return new Function("tryCatch", "errorObj", "Promise", "async", code)(tryCatch, errorObj, Promise, async);
            };

            var holderClasses = [];
            var thenCallbacks = [];
            var promiseSetters = [];

            for (var i = 0; i < 8; ++i) {
                holderClasses.push(generateHolderClass(i + 1));
                thenCallbacks.push(thenCallback(i + 1));
                promiseSetters.push(promiseSetter(i + 1));
            }

            reject = function (reason) {
                this._reject(reason);
            };
        }
    }

    Promise.join = function () {
        var last = arguments.length - 1;
        var fn;
        if (last > 0 && typeof arguments[last] === "function") {
            fn = arguments[last];
            if (true) {
                if (last <= 8 && canEvaluate) {
                    var ret = new Promise(INTERNAL);
                    ret._captureStackTrace();
                    var HolderClass = holderClasses[last - 1];
                    var holder = new HolderClass(fn);
                    var callbacks = thenCallbacks;

                    for (var i = 0; i < last; ++i) {
                        var maybePromise = tryConvertToPromise(arguments[i], ret);
                        if (maybePromise instanceof Promise) {
                            maybePromise = maybePromise._target();
                            var bitField = maybePromise._bitField;
                            ;
                            if ((bitField & 50397184) === 0) {
                                maybePromise._then(callbacks[i], reject, undefined, ret, holder);
                                promiseSetters[i](maybePromise, holder);
                                holder.asyncNeeded = false;
                            } else if ((bitField & 33554432) !== 0) {
                                callbacks[i].call(ret, maybePromise._value(), holder);
                            } else if ((bitField & 16777216) !== 0) {
                                ret._reject(maybePromise._reason());
                            } else {
                                ret._cancel();
                            }
                        } else {
                            callbacks[i].call(ret, maybePromise, holder);
                        }
                    }

                    if (!ret._isFateSealed()) {
                        if (holder.asyncNeeded) {
                            var domain = getDomain();
                            if (domain !== null) {
                                holder.fn = util.domainBind(domain, holder.fn);
                            }
                        }
                        ret._setAsyncGuaranteed();
                        ret._setOnCancel(holder);
                    }
                    return ret;
                }
            }
        }
        var $_len = arguments.length;var args = new Array($_len);for (var $_i = 0; $_i < $_len; ++$_i) {
            args[$_i] = arguments[$_i];
        };
        if (fn) args.pop();
        var ret = new PromiseArray(args).promise();
        return fn !== undefined ? ret.spread(fn) : ret;
    };
};

/***/ }),
/* 85 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = function (Promise, PromiseArray, apiRejection, tryConvertToPromise, INTERNAL, debug) {
    var getDomain = Promise._getDomain;
    var util = __webpack_require__(1);
    var tryCatch = util.tryCatch;
    var errorObj = util.errorObj;
    var async = Promise._async;

    function MappingPromiseArray(promises, fn, limit, _filter) {
        this.constructor$(promises);
        this._promise._captureStackTrace();
        var domain = getDomain();
        this._callback = domain === null ? fn : util.domainBind(domain, fn);
        this._preservedValues = _filter === INTERNAL ? new Array(this.length()) : null;
        this._limit = limit;
        this._inFlight = 0;
        this._queue = [];
        async.invoke(this._asyncInit, this, undefined);
    }
    util.inherits(MappingPromiseArray, PromiseArray);

    MappingPromiseArray.prototype._asyncInit = function () {
        this._init$(undefined, -2);
    };

    MappingPromiseArray.prototype._init = function () {};

    MappingPromiseArray.prototype._promiseFulfilled = function (value, index) {
        var values = this._values;
        var length = this.length();
        var preservedValues = this._preservedValues;
        var limit = this._limit;

        if (index < 0) {
            index = index * -1 - 1;
            values[index] = value;
            if (limit >= 1) {
                this._inFlight--;
                this._drainQueue();
                if (this._isResolved()) return true;
            }
        } else {
            if (limit >= 1 && this._inFlight >= limit) {
                values[index] = value;
                this._queue.push(index);
                return false;
            }
            if (preservedValues !== null) preservedValues[index] = value;

            var promise = this._promise;
            var callback = this._callback;
            var receiver = promise._boundValue();
            promise._pushContext();
            var ret = tryCatch(callback).call(receiver, value, index, length);
            var promiseCreated = promise._popContext();
            debug.checkForgottenReturns(ret, promiseCreated, preservedValues !== null ? "Promise.filter" : "Promise.map", promise);
            if (ret === errorObj) {
                this._reject(ret.e);
                return true;
            }

            var maybePromise = tryConvertToPromise(ret, this._promise);
            if (maybePromise instanceof Promise) {
                maybePromise = maybePromise._target();
                var bitField = maybePromise._bitField;
                ;
                if ((bitField & 50397184) === 0) {
                    if (limit >= 1) this._inFlight++;
                    values[index] = maybePromise;
                    maybePromise._proxy(this, (index + 1) * -1);
                    return false;
                } else if ((bitField & 33554432) !== 0) {
                    ret = maybePromise._value();
                } else if ((bitField & 16777216) !== 0) {
                    this._reject(maybePromise._reason());
                    return true;
                } else {
                    this._cancel();
                    return true;
                }
            }
            values[index] = ret;
        }
        var totalResolved = ++this._totalResolved;
        if (totalResolved >= length) {
            if (preservedValues !== null) {
                this._filter(values, preservedValues);
            } else {
                this._resolve(values);
            }
            return true;
        }
        return false;
    };

    MappingPromiseArray.prototype._drainQueue = function () {
        var queue = this._queue;
        var limit = this._limit;
        var values = this._values;
        while (queue.length > 0 && this._inFlight < limit) {
            if (this._isResolved()) return;
            var index = queue.pop();
            this._promiseFulfilled(values[index], index);
        }
    };

    MappingPromiseArray.prototype._filter = function (booleans, values) {
        var len = values.length;
        var ret = new Array(len);
        var j = 0;
        for (var i = 0; i < len; ++i) {
            if (booleans[i]) ret[j++] = values[i];
        }
        ret.length = j;
        this._resolve(ret);
    };

    MappingPromiseArray.prototype.preservedValues = function () {
        return this._preservedValues;
    };

    function map(promises, fn, options, _filter) {
        if (typeof fn !== "function") {
            return apiRejection("expecting a function but got " + util.classString(fn));
        }

        var limit = 0;
        if (options !== undefined) {
            if (typeof options === "object" && options !== null) {
                if (typeof options.concurrency !== "number") {
                    return Promise.reject(new TypeError("'concurrency' must be a number but it is " + util.classString(options.concurrency)));
                }
                limit = options.concurrency;
            } else {
                return Promise.reject(new TypeError("options argument must be an object but it is " + util.classString(options)));
            }
        }
        limit = typeof limit === "number" && isFinite(limit) && limit >= 1 ? limit : 0;
        return new MappingPromiseArray(promises, fn, limit, _filter).promise();
    }

    Promise.prototype.map = function (fn, options) {
        return map(this, fn, options, null);
    };

    Promise.map = function (promises, fn, options, _filter) {
        return map(promises, fn, options, _filter);
    };
};

/***/ }),
/* 86 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var cr = Object.create;
if (cr) {
    var callerCache = cr(null);
    var getterCache = cr(null);
    callerCache[" size"] = getterCache[" size"] = 0;
}

module.exports = function (Promise) {
    var util = __webpack_require__(1);
    var canEvaluate = util.canEvaluate;
    var isIdentifier = util.isIdentifier;

    var getMethodCaller;
    var getGetter;
    if (true) {
        var makeMethodCaller = function (methodName) {
            return new Function("ensureMethod", "                                    \n\
        return function(obj) {                                               \n\
            'use strict'                                                     \n\
            var len = this.length;                                           \n\
            ensureMethod(obj, 'methodName');                                 \n\
            switch(len) {                                                    \n\
                case 1: return obj.methodName(this[0]);                      \n\
                case 2: return obj.methodName(this[0], this[1]);             \n\
                case 3: return obj.methodName(this[0], this[1], this[2]);    \n\
                case 0: return obj.methodName();                             \n\
                default:                                                     \n\
                    return obj.methodName.apply(obj, this);                  \n\
            }                                                                \n\
        };                                                                   \n\
        ".replace(/methodName/g, methodName))(ensureMethod);
        };

        var makeGetter = function (propertyName) {
            return new Function("obj", "                                             \n\
        'use strict';                                                        \n\
        return obj.propertyName;                                             \n\
        ".replace("propertyName", propertyName));
        };

        var getCompiled = function (name, compiler, cache) {
            var ret = cache[name];
            if (typeof ret !== "function") {
                if (!isIdentifier(name)) {
                    return null;
                }
                ret = compiler(name);
                cache[name] = ret;
                cache[" size"]++;
                if (cache[" size"] > 512) {
                    var keys = Object.keys(cache);
                    for (var i = 0; i < 256; ++i) delete cache[keys[i]];
                    cache[" size"] = keys.length - 256;
                }
            }
            return ret;
        };

        getMethodCaller = function (name) {
            return getCompiled(name, makeMethodCaller, callerCache);
        };

        getGetter = function (name) {
            return getCompiled(name, makeGetter, getterCache);
        };
    }

    function ensureMethod(obj, methodName) {
        var fn;
        if (obj != null) fn = obj[methodName];
        if (typeof fn !== "function") {
            var message = "Object " + util.classString(obj) + " has no method '" + util.toString(methodName) + "'";
            throw new Promise.TypeError(message);
        }
        return fn;
    }

    function caller(obj) {
        var methodName = this.pop();
        var fn = ensureMethod(obj, methodName);
        return fn.apply(obj, this);
    }
    Promise.prototype.call = function (methodName) {
        var $_len = arguments.length;var args = new Array(Math.max($_len - 1, 0));for (var $_i = 1; $_i < $_len; ++$_i) {
            args[$_i - 1] = arguments[$_i];
        };
        if (true) {
            if (canEvaluate) {
                var maybeCaller = getMethodCaller(methodName);
                if (maybeCaller !== null) {
                    return this._then(maybeCaller, undefined, undefined, args, undefined);
                }
            }
        }
        args.push(methodName);
        return this._then(caller, undefined, undefined, args, undefined);
    };

    function namedGetter(obj) {
        return obj[this];
    }
    function indexedGetter(obj) {
        var index = +this;
        if (index < 0) index = Math.max(0, index + obj.length);
        return obj[index];
    }
    Promise.prototype.get = function (propertyName) {
        var isIndex = typeof propertyName === "number";
        var getter;
        if (!isIndex) {
            if (canEvaluate) {
                var maybeGetter = getGetter(propertyName);
                getter = maybeGetter !== null ? maybeGetter : namedGetter;
            } else {
                getter = namedGetter;
            }
        } else {
            getter = indexedGetter;
        }
        return this._then(getter, undefined, undefined, propertyName, undefined);
    };
};

/***/ }),
/* 87 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = function (Promise, apiRejection, tryConvertToPromise, createContext, INTERNAL, debug) {
    var util = __webpack_require__(1);
    var TypeError = __webpack_require__(11).TypeError;
    var inherits = __webpack_require__(1).inherits;
    var errorObj = util.errorObj;
    var tryCatch = util.tryCatch;
    var NULL = {};

    function thrower(e) {
        setTimeout(function () {
            throw e;
        }, 0);
    }

    function castPreservingDisposable(thenable) {
        var maybePromise = tryConvertToPromise(thenable);
        if (maybePromise !== thenable && typeof thenable._isDisposable === "function" && typeof thenable._getDisposer === "function" && thenable._isDisposable()) {
            maybePromise._setDisposable(thenable._getDisposer());
        }
        return maybePromise;
    }
    function dispose(resources, inspection) {
        var i = 0;
        var len = resources.length;
        var ret = new Promise(INTERNAL);
        function iterator() {
            if (i >= len) return ret._fulfill();
            var maybePromise = castPreservingDisposable(resources[i++]);
            if (maybePromise instanceof Promise && maybePromise._isDisposable()) {
                try {
                    maybePromise = tryConvertToPromise(maybePromise._getDisposer().tryDispose(inspection), resources.promise);
                } catch (e) {
                    return thrower(e);
                }
                if (maybePromise instanceof Promise) {
                    return maybePromise._then(iterator, thrower, null, null, null);
                }
            }
            iterator();
        }
        iterator();
        return ret;
    }

    function Disposer(data, promise, context) {
        this._data = data;
        this._promise = promise;
        this._context = context;
    }

    Disposer.prototype.data = function () {
        return this._data;
    };

    Disposer.prototype.promise = function () {
        return this._promise;
    };

    Disposer.prototype.resource = function () {
        if (this.promise().isFulfilled()) {
            return this.promise().value();
        }
        return NULL;
    };

    Disposer.prototype.tryDispose = function (inspection) {
        var resource = this.resource();
        var context = this._context;
        if (context !== undefined) context._pushContext();
        var ret = resource !== NULL ? this.doDispose(resource, inspection) : null;
        if (context !== undefined) context._popContext();
        this._promise._unsetDisposable();
        this._data = null;
        return ret;
    };

    Disposer.isDisposer = function (d) {
        return d != null && typeof d.resource === "function" && typeof d.tryDispose === "function";
    };

    function FunctionDisposer(fn, promise, context) {
        this.constructor$(fn, promise, context);
    }
    inherits(FunctionDisposer, Disposer);

    FunctionDisposer.prototype.doDispose = function (resource, inspection) {
        var fn = this.data();
        return fn.call(resource, resource, inspection);
    };

    function maybeUnwrapDisposer(value) {
        if (Disposer.isDisposer(value)) {
            this.resources[this.index]._setDisposable(value);
            return value.promise();
        }
        return value;
    }

    function ResourceList(length) {
        this.length = length;
        this.promise = null;
        this[length - 1] = null;
    }

    ResourceList.prototype._resultCancelled = function () {
        var len = this.length;
        for (var i = 0; i < len; ++i) {
            var item = this[i];
            if (item instanceof Promise) {
                item.cancel();
            }
        }
    };

    Promise.using = function () {
        var len = arguments.length;
        if (len < 2) return apiRejection("you must pass at least 2 arguments to Promise.using");
        var fn = arguments[len - 1];
        if (typeof fn !== "function") {
            return apiRejection("expecting a function but got " + util.classString(fn));
        }
        var input;
        var spreadArgs = true;
        if (len === 2 && Array.isArray(arguments[0])) {
            input = arguments[0];
            len = input.length;
            spreadArgs = false;
        } else {
            input = arguments;
            len--;
        }
        var resources = new ResourceList(len);
        for (var i = 0; i < len; ++i) {
            var resource = input[i];
            if (Disposer.isDisposer(resource)) {
                var disposer = resource;
                resource = resource.promise();
                resource._setDisposable(disposer);
            } else {
                var maybePromise = tryConvertToPromise(resource);
                if (maybePromise instanceof Promise) {
                    resource = maybePromise._then(maybeUnwrapDisposer, null, null, {
                        resources: resources,
                        index: i
                    }, undefined);
                }
            }
            resources[i] = resource;
        }

        var reflectedResources = new Array(resources.length);
        for (var i = 0; i < reflectedResources.length; ++i) {
            reflectedResources[i] = Promise.resolve(resources[i]).reflect();
        }

        var resultPromise = Promise.all(reflectedResources).then(function (inspections) {
            for (var i = 0; i < inspections.length; ++i) {
                var inspection = inspections[i];
                if (inspection.isRejected()) {
                    errorObj.e = inspection.error();
                    return errorObj;
                } else if (!inspection.isFulfilled()) {
                    resultPromise.cancel();
                    return;
                }
                inspections[i] = inspection.value();
            }
            promise._pushContext();

            fn = tryCatch(fn);
            var ret = spreadArgs ? fn.apply(undefined, inspections) : fn(inspections);
            var promiseCreated = promise._popContext();
            debug.checkForgottenReturns(ret, promiseCreated, "Promise.using", promise);
            return ret;
        });

        var promise = resultPromise.lastly(function () {
            var inspection = new Promise.PromiseInspection(resultPromise);
            return dispose(resources, inspection);
        });
        resources.promise = promise;
        promise._setOnCancel(resources);
        return promise;
    };

    Promise.prototype._setDisposable = function (disposer) {
        this._bitField = this._bitField | 131072;
        this._disposer = disposer;
    };

    Promise.prototype._isDisposable = function () {
        return (this._bitField & 131072) > 0;
    };

    Promise.prototype._getDisposer = function () {
        return this._disposer;
    };

    Promise.prototype._unsetDisposable = function () {
        this._bitField = this._bitField & ~131072;
        this._disposer = undefined;
    };

    Promise.prototype.disposer = function (fn) {
        if (typeof fn === "function") {
            return new FunctionDisposer(fn, this, createContext());
        }
        throw new TypeError();
    };
};

/***/ }),
/* 88 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = function (Promise, INTERNAL, debug) {
    var util = __webpack_require__(1);
    var TimeoutError = Promise.TimeoutError;

    function HandleWrapper(handle) {
        this.handle = handle;
    }

    HandleWrapper.prototype._resultCancelled = function () {
        clearTimeout(this.handle);
    };

    var afterValue = function (value) {
        return delay(+this).thenReturn(value);
    };
    var delay = Promise.delay = function (ms, value) {
        var ret;
        var handle;
        if (value !== undefined) {
            ret = Promise.resolve(value)._then(afterValue, null, null, ms, undefined);
            if (debug.cancellation() && value instanceof Promise) {
                ret._setOnCancel(value);
            }
        } else {
            ret = new Promise(INTERNAL);
            handle = setTimeout(function () {
                ret._fulfill();
            }, +ms);
            if (debug.cancellation()) {
                ret._setOnCancel(new HandleWrapper(handle));
            }
            ret._captureStackTrace();
        }
        ret._setAsyncGuaranteed();
        return ret;
    };

    Promise.prototype.delay = function (ms) {
        return delay(ms, this);
    };

    var afterTimeout = function (promise, message, parent) {
        var err;
        if (typeof message !== "string") {
            if (message instanceof Error) {
                err = message;
            } else {
                err = new TimeoutError("operation timed out");
            }
        } else {
            err = new TimeoutError(message);
        }
        util.markAsOriginatingFromRejection(err);
        promise._attachExtraTrace(err);
        promise._reject(err);

        if (parent != null) {
            parent.cancel();
        }
    };

    function successClear(value) {
        clearTimeout(this.handle);
        return value;
    }

    function failureClear(reason) {
        clearTimeout(this.handle);
        throw reason;
    }

    Promise.prototype.timeout = function (ms, message) {
        ms = +ms;
        var ret, parent;

        var handleWrapper = new HandleWrapper(setTimeout(function timeoutTimeout() {
            if (ret.isPending()) {
                afterTimeout(ret, message, parent);
            }
        }, ms));

        if (debug.cancellation()) {
            parent = this.then();
            ret = parent._then(successClear, failureClear, undefined, handleWrapper, undefined);
            ret._setOnCancel(handleWrapper);
        } else {
            ret = this._then(successClear, failureClear, undefined, handleWrapper, undefined);
        }

        return ret;
    };
};

/***/ }),
/* 89 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = function (Promise, apiRejection, INTERNAL, tryConvertToPromise, Proxyable, debug) {
    var errors = __webpack_require__(11);
    var TypeError = errors.TypeError;
    var util = __webpack_require__(1);
    var errorObj = util.errorObj;
    var tryCatch = util.tryCatch;
    var yieldHandlers = [];

    function promiseFromYieldHandler(value, yieldHandlers, traceParent) {
        for (var i = 0; i < yieldHandlers.length; ++i) {
            traceParent._pushContext();
            var result = tryCatch(yieldHandlers[i])(value);
            traceParent._popContext();
            if (result === errorObj) {
                traceParent._pushContext();
                var ret = Promise.reject(errorObj.e);
                traceParent._popContext();
                return ret;
            }
            var maybePromise = tryConvertToPromise(result, traceParent);
            if (maybePromise instanceof Promise) return maybePromise;
        }
        return null;
    }

    function PromiseSpawn(generatorFunction, receiver, yieldHandler, stack) {
        if (debug.cancellation()) {
            var internal = new Promise(INTERNAL);
            var _finallyPromise = this._finallyPromise = new Promise(INTERNAL);
            this._promise = internal.lastly(function () {
                return _finallyPromise;
            });
            internal._captureStackTrace();
            internal._setOnCancel(this);
        } else {
            var promise = this._promise = new Promise(INTERNAL);
            promise._captureStackTrace();
        }
        this._stack = stack;
        this._generatorFunction = generatorFunction;
        this._receiver = receiver;
        this._generator = undefined;
        this._yieldHandlers = typeof yieldHandler === "function" ? [yieldHandler].concat(yieldHandlers) : yieldHandlers;
        this._yieldedPromise = null;
        this._cancellationPhase = false;
    }
    util.inherits(PromiseSpawn, Proxyable);

    PromiseSpawn.prototype._isResolved = function () {
        return this._promise === null;
    };

    PromiseSpawn.prototype._cleanup = function () {
        this._promise = this._generator = null;
        if (debug.cancellation() && this._finallyPromise !== null) {
            this._finallyPromise._fulfill();
            this._finallyPromise = null;
        }
    };

    PromiseSpawn.prototype._promiseCancelled = function () {
        if (this._isResolved()) return;
        var implementsReturn = typeof this._generator["return"] !== "undefined";

        var result;
        if (!implementsReturn) {
            var reason = new Promise.CancellationError("generator .return() sentinel");
            Promise.coroutine.returnSentinel = reason;
            this._promise._attachExtraTrace(reason);
            this._promise._pushContext();
            result = tryCatch(this._generator["throw"]).call(this._generator, reason);
            this._promise._popContext();
        } else {
            this._promise._pushContext();
            result = tryCatch(this._generator["return"]).call(this._generator, undefined);
            this._promise._popContext();
        }
        this._cancellationPhase = true;
        this._yieldedPromise = null;
        this._continue(result);
    };

    PromiseSpawn.prototype._promiseFulfilled = function (value) {
        this._yieldedPromise = null;
        this._promise._pushContext();
        var result = tryCatch(this._generator.next).call(this._generator, value);
        this._promise._popContext();
        this._continue(result);
    };

    PromiseSpawn.prototype._promiseRejected = function (reason) {
        this._yieldedPromise = null;
        this._promise._attachExtraTrace(reason);
        this._promise._pushContext();
        var result = tryCatch(this._generator["throw"]).call(this._generator, reason);
        this._promise._popContext();
        this._continue(result);
    };

    PromiseSpawn.prototype._resultCancelled = function () {
        if (this._yieldedPromise instanceof Promise) {
            var promise = this._yieldedPromise;
            this._yieldedPromise = null;
            promise.cancel();
        }
    };

    PromiseSpawn.prototype.promise = function () {
        return this._promise;
    };

    PromiseSpawn.prototype._run = function () {
        this._generator = this._generatorFunction.call(this._receiver);
        this._receiver = this._generatorFunction = undefined;
        this._promiseFulfilled(undefined);
    };

    PromiseSpawn.prototype._continue = function (result) {
        var promise = this._promise;
        if (result === errorObj) {
            this._cleanup();
            if (this._cancellationPhase) {
                return promise.cancel();
            } else {
                return promise._rejectCallback(result.e, false);
            }
        }

        var value = result.value;
        if (result.done === true) {
            this._cleanup();
            if (this._cancellationPhase) {
                return promise.cancel();
            } else {
                return promise._resolveCallback(value);
            }
        } else {
            var maybePromise = tryConvertToPromise(value, this._promise);
            if (!(maybePromise instanceof Promise)) {
                maybePromise = promiseFromYieldHandler(maybePromise, this._yieldHandlers, this._promise);
                if (maybePromise === null) {
                    this._promiseRejected(new TypeError("A value %s was yielded that could not be treated as a promise\u000a\u000a    See http://goo.gl/MqrFmX\u000a\u000a".replace("%s", String(value)) + "From coroutine:\u000a" + this._stack.split("\n").slice(1, -7).join("\n")));
                    return;
                }
            }
            maybePromise = maybePromise._target();
            var bitField = maybePromise._bitField;
            ;
            if ((bitField & 50397184) === 0) {
                this._yieldedPromise = maybePromise;
                maybePromise._proxy(this, null);
            } else if ((bitField & 33554432) !== 0) {
                Promise._async.invoke(this._promiseFulfilled, this, maybePromise._value());
            } else if ((bitField & 16777216) !== 0) {
                Promise._async.invoke(this._promiseRejected, this, maybePromise._reason());
            } else {
                this._promiseCancelled();
            }
        }
    };

    Promise.coroutine = function (generatorFunction, options) {
        if (typeof generatorFunction !== "function") {
            throw new TypeError("generatorFunction must be a function\u000a\u000a    See http://goo.gl/MqrFmX\u000a");
        }
        var yieldHandler = Object(options).yieldHandler;
        var PromiseSpawn$ = PromiseSpawn;
        var stack = new Error().stack;
        return function () {
            var generator = generatorFunction.apply(this, arguments);
            var spawn = new PromiseSpawn$(undefined, undefined, yieldHandler, stack);
            var ret = spawn.promise();
            spawn._generator = generator;
            spawn._promiseFulfilled(undefined);
            return ret;
        };
    };

    Promise.coroutine.addYieldHandler = function (fn) {
        if (typeof fn !== "function") {
            throw new TypeError("expecting a function but got " + util.classString(fn));
        }
        yieldHandlers.push(fn);
    };

    Promise.spawn = function (generatorFunction) {
        debug.deprecated("Promise.spawn()", "Promise.coroutine()");
        if (typeof generatorFunction !== "function") {
            return apiRejection("generatorFunction must be a function\u000a\u000a    See http://goo.gl/MqrFmX\u000a");
        }
        var spawn = new PromiseSpawn(generatorFunction, this);
        var ret = spawn.promise();
        spawn._run(Promise.spawn);
        return ret;
    };
};

/***/ }),
/* 90 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = function (Promise) {
    var util = __webpack_require__(1);
    var async = Promise._async;
    var tryCatch = util.tryCatch;
    var errorObj = util.errorObj;

    function spreadAdapter(val, nodeback) {
        var promise = this;
        if (!util.isArray(val)) return successAdapter.call(promise, val, nodeback);
        var ret = tryCatch(nodeback).apply(promise._boundValue(), [null].concat(val));
        if (ret === errorObj) {
            async.throwLater(ret.e);
        }
    }

    function successAdapter(val, nodeback) {
        var promise = this;
        var receiver = promise._boundValue();
        var ret = val === undefined ? tryCatch(nodeback).call(receiver, null) : tryCatch(nodeback).call(receiver, null, val);
        if (ret === errorObj) {
            async.throwLater(ret.e);
        }
    }
    function errorAdapter(reason, nodeback) {
        var promise = this;
        if (!reason) {
            var newReason = new Error(reason + "");
            newReason.cause = reason;
            reason = newReason;
        }
        var ret = tryCatch(nodeback).call(promise._boundValue(), reason);
        if (ret === errorObj) {
            async.throwLater(ret.e);
        }
    }

    Promise.prototype.asCallback = Promise.prototype.nodeify = function (nodeback, options) {
        if (typeof nodeback == "function") {
            var adapter = successAdapter;
            if (options !== undefined && Object(options).spread) {
                adapter = spreadAdapter;
            }
            this._then(adapter, errorAdapter, undefined, this, nodeback);
        }
        return this;
    };
};

/***/ }),
/* 91 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = function (Promise, INTERNAL) {
    var THIS = {};
    var util = __webpack_require__(1);
    var nodebackForPromise = __webpack_require__(39);
    var withAppended = util.withAppended;
    var maybeWrapAsError = util.maybeWrapAsError;
    var canEvaluate = util.canEvaluate;
    var TypeError = __webpack_require__(11).TypeError;
    var defaultSuffix = "Async";
    var defaultPromisified = { __isPromisified__: true };
    var noCopyProps = ["arity", "length", "name", "arguments", "caller", "callee", "prototype", "__isPromisified__"];
    var noCopyPropsPattern = new RegExp("^(?:" + noCopyProps.join("|") + ")$");

    var defaultFilter = function (name) {
        return util.isIdentifier(name) && name.charAt(0) !== "_" && name !== "constructor";
    };

    function propsFilter(key) {
        return !noCopyPropsPattern.test(key);
    }

    function isPromisified(fn) {
        try {
            return fn.__isPromisified__ === true;
        } catch (e) {
            return false;
        }
    }

    function hasPromisified(obj, key, suffix) {
        var val = util.getDataPropertyOrDefault(obj, key + suffix, defaultPromisified);
        return val ? isPromisified(val) : false;
    }
    function checkValid(ret, suffix, suffixRegexp) {
        for (var i = 0; i < ret.length; i += 2) {
            var key = ret[i];
            if (suffixRegexp.test(key)) {
                var keyWithoutAsyncSuffix = key.replace(suffixRegexp, "");
                for (var j = 0; j < ret.length; j += 2) {
                    if (ret[j] === keyWithoutAsyncSuffix) {
                        throw new TypeError("Cannot promisify an API that has normal methods with '%s'-suffix\u000a\u000a    See http://goo.gl/MqrFmX\u000a".replace("%s", suffix));
                    }
                }
            }
        }
    }

    function promisifiableMethods(obj, suffix, suffixRegexp, filter) {
        var keys = util.inheritedDataKeys(obj);
        var ret = [];
        for (var i = 0; i < keys.length; ++i) {
            var key = keys[i];
            var value = obj[key];
            var passesDefaultFilter = filter === defaultFilter ? true : defaultFilter(key, value, obj);
            if (typeof value === "function" && !isPromisified(value) && !hasPromisified(obj, key, suffix) && filter(key, value, obj, passesDefaultFilter)) {
                ret.push(key, value);
            }
        }
        checkValid(ret, suffix, suffixRegexp);
        return ret;
    }

    var escapeIdentRegex = function (str) {
        return str.replace(/([$])/, "\\$");
    };

    var makeNodePromisifiedEval;
    if (true) {
        var switchCaseArgumentOrder = function (likelyArgumentCount) {
            var ret = [likelyArgumentCount];
            var min = Math.max(0, likelyArgumentCount - 1 - 3);
            for (var i = likelyArgumentCount - 1; i >= min; --i) {
                ret.push(i);
            }
            for (var i = likelyArgumentCount + 1; i <= 3; ++i) {
                ret.push(i);
            }
            return ret;
        };

        var argumentSequence = function (argumentCount) {
            return util.filledRange(argumentCount, "_arg", "");
        };

        var parameterDeclaration = function (parameterCount) {
            return util.filledRange(Math.max(parameterCount, 3), "_arg", "");
        };

        var parameterCount = function (fn) {
            if (typeof fn.length === "number") {
                return Math.max(Math.min(fn.length, 1023 + 1), 0);
            }
            return 0;
        };

        makeNodePromisifiedEval = function (callback, receiver, originalName, fn, _, multiArgs) {
            var newParameterCount = Math.max(0, parameterCount(fn) - 1);
            var argumentOrder = switchCaseArgumentOrder(newParameterCount);
            var shouldProxyThis = typeof callback === "string" || receiver === THIS;

            function generateCallForArgumentCount(count) {
                var args = argumentSequence(count).join(", ");
                var comma = count > 0 ? ", " : "";
                var ret;
                if (shouldProxyThis) {
                    ret = "ret = callback.call(this, {{args}}, nodeback); break;\n";
                } else {
                    ret = receiver === undefined ? "ret = callback({{args}}, nodeback); break;\n" : "ret = callback.call(receiver, {{args}}, nodeback); break;\n";
                }
                return ret.replace("{{args}}", args).replace(", ", comma);
            }

            function generateArgumentSwitchCase() {
                var ret = "";
                for (var i = 0; i < argumentOrder.length; ++i) {
                    ret += "case " + argumentOrder[i] + ":" + generateCallForArgumentCount(argumentOrder[i]);
                }

                ret += "                                                             \n\
        default:                                                             \n\
            var args = new Array(len + 1);                                   \n\
            var i = 0;                                                       \n\
            for (var i = 0; i < len; ++i) {                                  \n\
               args[i] = arguments[i];                                       \n\
            }                                                                \n\
            args[i] = nodeback;                                              \n\
            [CodeForCall]                                                    \n\
            break;                                                           \n\
        ".replace("[CodeForCall]", shouldProxyThis ? "ret = callback.apply(this, args);\n" : "ret = callback.apply(receiver, args);\n");
                return ret;
            }

            var getFunctionCode = typeof callback === "string" ? "this != null ? this['" + callback + "'] : fn" : "fn";
            var body = "'use strict';                                                \n\
        var ret = function (Parameters) {                                    \n\
            'use strict';                                                    \n\
            var len = arguments.length;                                      \n\
            var promise = new Promise(INTERNAL);                             \n\
            promise._captureStackTrace();                                    \n\
            var nodeback = nodebackForPromise(promise, " + multiArgs + ");   \n\
            var ret;                                                         \n\
            var callback = tryCatch([GetFunctionCode]);                      \n\
            switch(len) {                                                    \n\
                [CodeForSwitchCase]                                          \n\
            }                                                                \n\
            if (ret === errorObj) {                                          \n\
                promise._rejectCallback(maybeWrapAsError(ret.e), true, true);\n\
            }                                                                \n\
            if (!promise._isFateSealed()) promise._setAsyncGuaranteed();     \n\
            return promise;                                                  \n\
        };                                                                   \n\
        notEnumerableProp(ret, '__isPromisified__', true);                   \n\
        return ret;                                                          \n\
    ".replace("[CodeForSwitchCase]", generateArgumentSwitchCase()).replace("[GetFunctionCode]", getFunctionCode);
            body = body.replace("Parameters", parameterDeclaration(newParameterCount));
            return new Function("Promise", "fn", "receiver", "withAppended", "maybeWrapAsError", "nodebackForPromise", "tryCatch", "errorObj", "notEnumerableProp", "INTERNAL", body)(Promise, fn, receiver, withAppended, maybeWrapAsError, nodebackForPromise, util.tryCatch, util.errorObj, util.notEnumerableProp, INTERNAL);
        };
    }

    function makeNodePromisifiedClosure(callback, receiver, _, fn, __, multiArgs) {
        var defaultThis = function () {
            return this;
        }();
        var method = callback;
        if (typeof method === "string") {
            callback = fn;
        }
        function promisified() {
            var _receiver = receiver;
            if (receiver === THIS) _receiver = this;
            var promise = new Promise(INTERNAL);
            promise._captureStackTrace();
            var cb = typeof method === "string" && this !== defaultThis ? this[method] : callback;
            var fn = nodebackForPromise(promise, multiArgs);
            try {
                cb.apply(_receiver, withAppended(arguments, fn));
            } catch (e) {
                promise._rejectCallback(maybeWrapAsError(e), true, true);
            }
            if (!promise._isFateSealed()) promise._setAsyncGuaranteed();
            return promise;
        }
        util.notEnumerableProp(promisified, "__isPromisified__", true);
        return promisified;
    }

    var makeNodePromisified = canEvaluate ? makeNodePromisifiedEval : makeNodePromisifiedClosure;

    function promisifyAll(obj, suffix, filter, promisifier, multiArgs) {
        var suffixRegexp = new RegExp(escapeIdentRegex(suffix) + "$");
        var methods = promisifiableMethods(obj, suffix, suffixRegexp, filter);

        for (var i = 0, len = methods.length; i < len; i += 2) {
            var key = methods[i];
            var fn = methods[i + 1];
            var promisifiedKey = key + suffix;
            if (promisifier === makeNodePromisified) {
                obj[promisifiedKey] = makeNodePromisified(key, THIS, key, fn, suffix, multiArgs);
            } else {
                var promisified = promisifier(fn, function () {
                    return makeNodePromisified(key, THIS, key, fn, suffix, multiArgs);
                });
                util.notEnumerableProp(promisified, "__isPromisified__", true);
                obj[promisifiedKey] = promisified;
            }
        }
        util.toFastProperties(obj);
        return obj;
    }

    function promisify(callback, receiver, multiArgs) {
        return makeNodePromisified(callback, receiver, undefined, callback, null, multiArgs);
    }

    Promise.promisify = function (fn, options) {
        if (typeof fn !== "function") {
            throw new TypeError("expecting a function but got " + util.classString(fn));
        }
        if (isPromisified(fn)) {
            return fn;
        }
        options = Object(options);
        var receiver = options.context === undefined ? THIS : options.context;
        var multiArgs = !!options.multiArgs;
        var ret = promisify(fn, receiver, multiArgs);
        util.copyDescriptors(fn, ret, propsFilter);
        return ret;
    };

    Promise.promisifyAll = function (target, options) {
        if (typeof target !== "function" && typeof target !== "object") {
            throw new TypeError("the target of promisifyAll must be an object or a function\u000a\u000a    See http://goo.gl/MqrFmX\u000a");
        }
        options = Object(options);
        var multiArgs = !!options.multiArgs;
        var suffix = options.suffix;
        if (typeof suffix !== "string") suffix = defaultSuffix;
        var filter = options.filter;
        if (typeof filter !== "function") filter = defaultFilter;
        var promisifier = options.promisifier;
        if (typeof promisifier !== "function") promisifier = makeNodePromisified;

        if (!util.isIdentifier(suffix)) {
            throw new RangeError("suffix must be a valid identifier\u000a\u000a    See http://goo.gl/MqrFmX\u000a");
        }

        var keys = util.inheritedDataKeys(target);
        for (var i = 0; i < keys.length; ++i) {
            var value = target[keys[i]];
            if (keys[i] !== "constructor" && util.isClass(value)) {
                promisifyAll(value.prototype, suffix, filter, promisifier, multiArgs);
                promisifyAll(value, suffix, filter, promisifier, multiArgs);
            }
        }

        return promisifyAll(target, suffix, filter, promisifier, multiArgs);
    };
};

/***/ }),
/* 92 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = function (Promise, PromiseArray, tryConvertToPromise, apiRejection) {
    var util = __webpack_require__(1);
    var isObject = util.isObject;
    var es5 = __webpack_require__(16);
    var Es6Map;
    if (typeof Map === "function") Es6Map = Map;

    var mapToEntries = function () {
        var index = 0;
        var size = 0;

        function extractEntry(value, key) {
            this[index] = value;
            this[index + size] = key;
            index++;
        }

        return function mapToEntries(map) {
            size = map.size;
            index = 0;
            var ret = new Array(map.size * 2);
            map.forEach(extractEntry, ret);
            return ret;
        };
    }();

    var entriesToMap = function (entries) {
        var ret = new Es6Map();
        var length = entries.length / 2 | 0;
        for (var i = 0; i < length; ++i) {
            var key = entries[length + i];
            var value = entries[i];
            ret.set(key, value);
        }
        return ret;
    };

    function PropertiesPromiseArray(obj) {
        var isMap = false;
        var entries;
        if (Es6Map !== undefined && obj instanceof Es6Map) {
            entries = mapToEntries(obj);
            isMap = true;
        } else {
            var keys = es5.keys(obj);
            var len = keys.length;
            entries = new Array(len * 2);
            for (var i = 0; i < len; ++i) {
                var key = keys[i];
                entries[i] = obj[key];
                entries[i + len] = key;
            }
        }
        this.constructor$(entries);
        this._isMap = isMap;
        this._init$(undefined, isMap ? -6 : -3);
    }
    util.inherits(PropertiesPromiseArray, PromiseArray);

    PropertiesPromiseArray.prototype._init = function () {};

    PropertiesPromiseArray.prototype._promiseFulfilled = function (value, index) {
        this._values[index] = value;
        var totalResolved = ++this._totalResolved;
        if (totalResolved >= this._length) {
            var val;
            if (this._isMap) {
                val = entriesToMap(this._values);
            } else {
                val = {};
                var keyOffset = this.length();
                for (var i = 0, len = this.length(); i < len; ++i) {
                    val[this._values[i + keyOffset]] = this._values[i];
                }
            }
            this._resolve(val);
            return true;
        }
        return false;
    };

    PropertiesPromiseArray.prototype.shouldCopyValues = function () {
        return false;
    };

    PropertiesPromiseArray.prototype.getActualLength = function (len) {
        return len >> 1;
    };

    function props(promises) {
        var ret;
        var castValue = tryConvertToPromise(promises);

        if (!isObject(castValue)) {
            return apiRejection("cannot await properties of a non-object\u000a\u000a    See http://goo.gl/MqrFmX\u000a");
        } else if (castValue instanceof Promise) {
            ret = castValue._then(Promise.props, undefined, undefined, undefined, undefined);
        } else {
            ret = new PropertiesPromiseArray(castValue).promise();
        }

        if (castValue instanceof Promise) {
            ret._propagateFrom(castValue, 2);
        }
        return ret;
    }

    Promise.prototype.props = function () {
        return props(this);
    };

    Promise.props = function (promises) {
        return props(promises);
    };
};

/***/ }),
/* 93 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = function (Promise, INTERNAL, tryConvertToPromise, apiRejection) {
    var util = __webpack_require__(1);

    var raceLater = function (promise) {
        return promise.then(function (array) {
            return race(array, promise);
        });
    };

    function race(promises, parent) {
        var maybePromise = tryConvertToPromise(promises);

        if (maybePromise instanceof Promise) {
            return raceLater(maybePromise);
        } else {
            promises = util.asArray(promises);
            if (promises === null) return apiRejection("expecting an array or an iterable object but got " + util.classString(promises));
        }

        var ret = new Promise(INTERNAL);
        if (parent !== undefined) {
            ret._propagateFrom(parent, 3);
        }
        var fulfill = ret._fulfill;
        var reject = ret._reject;
        for (var i = 0, len = promises.length; i < len; ++i) {
            var val = promises[i];

            if (val === undefined && !(i in promises)) {
                continue;
            }

            Promise.cast(val)._then(fulfill, reject, undefined, ret, null);
        }
        return ret;
    }

    Promise.race = function (promises) {
        return race(promises, undefined);
    };

    Promise.prototype.race = function () {
        return race(this, undefined);
    };
};

/***/ }),
/* 94 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = function (Promise, PromiseArray, apiRejection, tryConvertToPromise, INTERNAL, debug) {
    var getDomain = Promise._getDomain;
    var util = __webpack_require__(1);
    var tryCatch = util.tryCatch;

    function ReductionPromiseArray(promises, fn, initialValue, _each) {
        this.constructor$(promises);
        var domain = getDomain();
        this._fn = domain === null ? fn : util.domainBind(domain, fn);
        if (initialValue !== undefined) {
            initialValue = Promise.resolve(initialValue);
            initialValue._attachCancellationCallback(this);
        }
        this._initialValue = initialValue;
        this._currentCancellable = null;
        if (_each === INTERNAL) {
            this._eachValues = Array(this._length);
        } else if (_each === 0) {
            this._eachValues = null;
        } else {
            this._eachValues = undefined;
        }
        this._promise._captureStackTrace();
        this._init$(undefined, -5);
    }
    util.inherits(ReductionPromiseArray, PromiseArray);

    ReductionPromiseArray.prototype._gotAccum = function (accum) {
        if (this._eachValues !== undefined && this._eachValues !== null && accum !== INTERNAL) {
            this._eachValues.push(accum);
        }
    };

    ReductionPromiseArray.prototype._eachComplete = function (value) {
        if (this._eachValues !== null) {
            this._eachValues.push(value);
        }
        return this._eachValues;
    };

    ReductionPromiseArray.prototype._init = function () {};

    ReductionPromiseArray.prototype._resolveEmptyArray = function () {
        this._resolve(this._eachValues !== undefined ? this._eachValues : this._initialValue);
    };

    ReductionPromiseArray.prototype.shouldCopyValues = function () {
        return false;
    };

    ReductionPromiseArray.prototype._resolve = function (value) {
        this._promise._resolveCallback(value);
        this._values = null;
    };

    ReductionPromiseArray.prototype._resultCancelled = function (sender) {
        if (sender === this._initialValue) return this._cancel();
        if (this._isResolved()) return;
        this._resultCancelled$();
        if (this._currentCancellable instanceof Promise) {
            this._currentCancellable.cancel();
        }
        if (this._initialValue instanceof Promise) {
            this._initialValue.cancel();
        }
    };

    ReductionPromiseArray.prototype._iterate = function (values) {
        this._values = values;
        var value;
        var i;
        var length = values.length;
        if (this._initialValue !== undefined) {
            value = this._initialValue;
            i = 0;
        } else {
            value = Promise.resolve(values[0]);
            i = 1;
        }

        this._currentCancellable = value;

        if (!value.isRejected()) {
            for (; i < length; ++i) {
                var ctx = {
                    accum: null,
                    value: values[i],
                    index: i,
                    length: length,
                    array: this
                };
                value = value._then(gotAccum, undefined, undefined, ctx, undefined);
            }
        }

        if (this._eachValues !== undefined) {
            value = value._then(this._eachComplete, undefined, undefined, this, undefined);
        }
        value._then(completed, completed, undefined, value, this);
    };

    Promise.prototype.reduce = function (fn, initialValue) {
        return reduce(this, fn, initialValue, null);
    };

    Promise.reduce = function (promises, fn, initialValue, _each) {
        return reduce(promises, fn, initialValue, _each);
    };

    function completed(valueOrReason, array) {
        if (this.isFulfilled()) {
            array._resolve(valueOrReason);
        } else {
            array._reject(valueOrReason);
        }
    }

    function reduce(promises, fn, initialValue, _each) {
        if (typeof fn !== "function") {
            return apiRejection("expecting a function but got " + util.classString(fn));
        }
        var array = new ReductionPromiseArray(promises, fn, initialValue, _each);
        return array.promise();
    }

    function gotAccum(accum) {
        this.accum = accum;
        this.array._gotAccum(accum);
        var value = tryConvertToPromise(this.value, this.array._promise);
        if (value instanceof Promise) {
            this.array._currentCancellable = value;
            return value._then(gotValue, undefined, undefined, this, undefined);
        } else {
            return gotValue.call(this, value);
        }
    }

    function gotValue(value) {
        var array = this.array;
        var promise = array._promise;
        var fn = tryCatch(array._fn);
        promise._pushContext();
        var ret;
        if (array._eachValues !== undefined) {
            ret = fn.call(promise._boundValue(), value, this.index, this.length);
        } else {
            ret = fn.call(promise._boundValue(), this.accum, value, this.index, this.length);
        }
        if (ret instanceof Promise) {
            array._currentCancellable = ret;
        }
        var promiseCreated = promise._popContext();
        debug.checkForgottenReturns(ret, promiseCreated, array._eachValues !== undefined ? "Promise.each" : "Promise.reduce", promise);
        return ret;
    }
};

/***/ }),
/* 95 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = function (Promise, PromiseArray, debug) {
    var PromiseInspection = Promise.PromiseInspection;
    var util = __webpack_require__(1);

    function SettledPromiseArray(values) {
        this.constructor$(values);
    }
    util.inherits(SettledPromiseArray, PromiseArray);

    SettledPromiseArray.prototype._promiseResolved = function (index, inspection) {
        this._values[index] = inspection;
        var totalResolved = ++this._totalResolved;
        if (totalResolved >= this._length) {
            this._resolve(this._values);
            return true;
        }
        return false;
    };

    SettledPromiseArray.prototype._promiseFulfilled = function (value, index) {
        var ret = new PromiseInspection();
        ret._bitField = 33554432;
        ret._settledValueField = value;
        return this._promiseResolved(index, ret);
    };
    SettledPromiseArray.prototype._promiseRejected = function (reason, index) {
        var ret = new PromiseInspection();
        ret._bitField = 16777216;
        ret._settledValueField = reason;
        return this._promiseResolved(index, ret);
    };

    Promise.settle = function (promises) {
        debug.deprecated(".settle()", ".reflect()");
        return new SettledPromiseArray(promises).promise();
    };

    Promise.prototype.settle = function () {
        return Promise.settle(this);
    };
};

/***/ }),
/* 96 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = function (Promise, PromiseArray, apiRejection) {
    var util = __webpack_require__(1);
    var RangeError = __webpack_require__(11).RangeError;
    var AggregateError = __webpack_require__(11).AggregateError;
    var isArray = util.isArray;
    var CANCELLATION = {};

    function SomePromiseArray(values) {
        this.constructor$(values);
        this._howMany = 0;
        this._unwrap = false;
        this._initialized = false;
    }
    util.inherits(SomePromiseArray, PromiseArray);

    SomePromiseArray.prototype._init = function () {
        if (!this._initialized) {
            return;
        }
        if (this._howMany === 0) {
            this._resolve([]);
            return;
        }
        this._init$(undefined, -5);
        var isArrayResolved = isArray(this._values);
        if (!this._isResolved() && isArrayResolved && this._howMany > this._canPossiblyFulfill()) {
            this._reject(this._getRangeError(this.length()));
        }
    };

    SomePromiseArray.prototype.init = function () {
        this._initialized = true;
        this._init();
    };

    SomePromiseArray.prototype.setUnwrap = function () {
        this._unwrap = true;
    };

    SomePromiseArray.prototype.howMany = function () {
        return this._howMany;
    };

    SomePromiseArray.prototype.setHowMany = function (count) {
        this._howMany = count;
    };

    SomePromiseArray.prototype._promiseFulfilled = function (value) {
        this._addFulfilled(value);
        if (this._fulfilled() === this.howMany()) {
            this._values.length = this.howMany();
            if (this.howMany() === 1 && this._unwrap) {
                this._resolve(this._values[0]);
            } else {
                this._resolve(this._values);
            }
            return true;
        }
        return false;
    };
    SomePromiseArray.prototype._promiseRejected = function (reason) {
        this._addRejected(reason);
        return this._checkOutcome();
    };

    SomePromiseArray.prototype._promiseCancelled = function () {
        if (this._values instanceof Promise || this._values == null) {
            return this._cancel();
        }
        this._addRejected(CANCELLATION);
        return this._checkOutcome();
    };

    SomePromiseArray.prototype._checkOutcome = function () {
        if (this.howMany() > this._canPossiblyFulfill()) {
            var e = new AggregateError();
            for (var i = this.length(); i < this._values.length; ++i) {
                if (this._values[i] !== CANCELLATION) {
                    e.push(this._values[i]);
                }
            }
            if (e.length > 0) {
                this._reject(e);
            } else {
                this._cancel();
            }
            return true;
        }
        return false;
    };

    SomePromiseArray.prototype._fulfilled = function () {
        return this._totalResolved;
    };

    SomePromiseArray.prototype._rejected = function () {
        return this._values.length - this.length();
    };

    SomePromiseArray.prototype._addRejected = function (reason) {
        this._values.push(reason);
    };

    SomePromiseArray.prototype._addFulfilled = function (value) {
        this._values[this._totalResolved++] = value;
    };

    SomePromiseArray.prototype._canPossiblyFulfill = function () {
        return this.length() - this._rejected();
    };

    SomePromiseArray.prototype._getRangeError = function (count) {
        var message = "Input array must contain at least " + this._howMany + " items but contains only " + count + " items";
        return new RangeError(message);
    };

    SomePromiseArray.prototype._resolveEmptyArray = function () {
        this._reject(this._getRangeError(0));
    };

    function some(promises, howMany) {
        if ((howMany | 0) !== howMany || howMany < 0) {
            return apiRejection("expecting a positive integer\u000a\u000a    See http://goo.gl/MqrFmX\u000a");
        }
        var ret = new SomePromiseArray(promises);
        var promise = ret.promise();
        ret.setHowMany(howMany);
        ret.init();
        return promise;
    }

    Promise.some = function (promises, howMany) {
        return some(promises, howMany);
    };

    Promise.prototype.some = function (howMany) {
        return some(this, howMany);
    };

    Promise._SomePromiseArray = SomePromiseArray;
};

/***/ }),
/* 97 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = function (Promise, INTERNAL) {
    var PromiseMap = Promise.map;

    Promise.prototype.filter = function (fn, options) {
        return PromiseMap(this, fn, options, INTERNAL);
    };

    Promise.filter = function (promises, fn, options) {
        return PromiseMap(promises, fn, options, INTERNAL);
    };
};

/***/ }),
/* 98 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = function (Promise, INTERNAL) {
    var PromiseReduce = Promise.reduce;
    var PromiseAll = Promise.all;

    function promiseAllThis() {
        return PromiseAll(this);
    }

    function PromiseMapSeries(promises, fn) {
        return PromiseReduce(promises, fn, INTERNAL, INTERNAL);
    }

    Promise.prototype.each = function (fn) {
        return PromiseReduce(this, fn, INTERNAL, 0)._then(promiseAllThis, undefined, undefined, this, undefined);
    };

    Promise.prototype.mapSeries = function (fn) {
        return PromiseReduce(this, fn, INTERNAL, INTERNAL);
    };

    Promise.each = function (promises, fn) {
        return PromiseReduce(promises, fn, INTERNAL, 0)._then(promiseAllThis, undefined, undefined, promises, undefined);
    };

    Promise.mapSeries = PromiseMapSeries;
};

/***/ }),
/* 99 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = function (Promise) {
    var SomePromiseArray = Promise._SomePromiseArray;
    function any(promises) {
        var ret = new SomePromiseArray(promises);
        var promise = ret.promise();
        ret.setHowMany(1);
        ret.setUnwrap();
        ret.init();
        return promise;
    }

    Promise.any = function (promises) {
        return any(promises);
    };

    Promise.prototype.any = function () {
        return any(this);
    };
};

/***/ }),
/* 100 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * Detect Electron renderer process, which is node, but we should
 * treat as a browser.
 */

if (typeof process === 'undefined' || process.type === 'renderer') {
  module.exports = __webpack_require__(101);
} else {
  module.exports = __webpack_require__(103);
}

/***/ }),
/* 101 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * This is the web browser implementation of `debug()`.
 *
 * Expose `debug()` as the module.
 */

exports = module.exports = __webpack_require__(43);
exports.log = log;
exports.formatArgs = formatArgs;
exports.save = save;
exports.load = load;
exports.useColors = useColors;
exports.storage = 'undefined' != typeof chrome && 'undefined' != typeof chrome.storage ? chrome.storage.local : localstorage();

/**
 * Colors.
 */

exports.colors = ['#0000CC', '#0000FF', '#0033CC', '#0033FF', '#0066CC', '#0066FF', '#0099CC', '#0099FF', '#00CC00', '#00CC33', '#00CC66', '#00CC99', '#00CCCC', '#00CCFF', '#3300CC', '#3300FF', '#3333CC', '#3333FF', '#3366CC', '#3366FF', '#3399CC', '#3399FF', '#33CC00', '#33CC33', '#33CC66', '#33CC99', '#33CCCC', '#33CCFF', '#6600CC', '#6600FF', '#6633CC', '#6633FF', '#66CC00', '#66CC33', '#9900CC', '#9900FF', '#9933CC', '#9933FF', '#99CC00', '#99CC33', '#CC0000', '#CC0033', '#CC0066', '#CC0099', '#CC00CC', '#CC00FF', '#CC3300', '#CC3333', '#CC3366', '#CC3399', '#CC33CC', '#CC33FF', '#CC6600', '#CC6633', '#CC9900', '#CC9933', '#CCCC00', '#CCCC33', '#FF0000', '#FF0033', '#FF0066', '#FF0099', '#FF00CC', '#FF00FF', '#FF3300', '#FF3333', '#FF3366', '#FF3399', '#FF33CC', '#FF33FF', '#FF6600', '#FF6633', '#FF9900', '#FF9933', '#FFCC00', '#FFCC33'];

/**
 * Currently only WebKit-based Web Inspectors, Firefox >= v31,
 * and the Firebug extension (any Firefox version) are known
 * to support "%c" CSS customizations.
 *
 * TODO: add a `localStorage` variable to explicitly enable/disable colors
 */

function useColors() {
  // NB: In an Electron preload script, document will be defined but not fully
  // initialized. Since we know we're in Chrome, we'll just detect this case
  // explicitly
  if (typeof window !== 'undefined' && window.process && window.process.type === 'renderer') {
    return true;
  }

  // Internet Explorer and Edge do not support colors.
  if (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
    return false;
  }

  // is webkit? http://stackoverflow.com/a/16459606/376773
  // document is undefined in react-native: https://github.com/facebook/react-native/pull/1632
  return typeof document !== 'undefined' && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance ||
  // is firebug? http://stackoverflow.com/a/398120/376773
  typeof window !== 'undefined' && window.console && (window.console.firebug || window.console.exception && window.console.table) ||
  // is firefox >= v31?
  // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
  typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31 ||
  // double check webkit in userAgent just in case we are in a worker
  typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
}

/**
 * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.
 */

exports.formatters.j = function (v) {
  try {
    return JSON.stringify(v);
  } catch (err) {
    return '[UnexpectedJSONParseError]: ' + err.message;
  }
};

/**
 * Colorize log arguments if enabled.
 *
 * @api public
 */

function formatArgs(args) {
  var useColors = this.useColors;

  args[0] = (useColors ? '%c' : '') + this.namespace + (useColors ? ' %c' : ' ') + args[0] + (useColors ? '%c ' : ' ') + '+' + exports.humanize(this.diff);

  if (!useColors) return;

  var c = 'color: ' + this.color;
  args.splice(1, 0, c, 'color: inherit');

  // the final "%c" is somewhat tricky, because there could be other
  // arguments passed either before or after the %c, so we need to
  // figure out the correct index to insert the CSS into
  var index = 0;
  var lastC = 0;
  args[0].replace(/%[a-zA-Z%]/g, function (match) {
    if ('%%' === match) return;
    index++;
    if ('%c' === match) {
      // we only are interested in the *last* %c
      // (the user may have provided their own)
      lastC = index;
    }
  });

  args.splice(lastC, 0, c);
}

/**
 * Invokes `console.log()` when available.
 * No-op when `console.log` is not a "function".
 *
 * @api public
 */

function log() {
  // this hackery is required for IE8/9, where
  // the `console.log` function doesn't have 'apply'
  return 'object' === typeof console && console.log && Function.prototype.apply.call(console.log, console, arguments);
}

/**
 * Save `namespaces`.
 *
 * @param {String} namespaces
 * @api private
 */

function save(namespaces) {
  try {
    if (null == namespaces) {
      exports.storage.removeItem('debug');
    } else {
      exports.storage.debug = namespaces;
    }
  } catch (e) {}
}

/**
 * Load `namespaces`.
 *
 * @return {String} returns the previously persisted debug modes
 * @api private
 */

function load() {
  var r;
  try {
    r = exports.storage.debug;
  } catch (e) {}

  // If debug isn't set in LS, and we're in Electron, try to load $DEBUG
  if (!r && typeof process !== 'undefined' && 'env' in process) {
    r = process.env.DEBUG;
  }

  return r;
}

/**
 * Enable namespaces listed in `localStorage.debug` initially.
 */

exports.enable(load());

/**
 * Localstorage attempts to return the localstorage.
 *
 * This is necessary because safari throws
 * when a user disables cookies/localstorage
 * and you attempt to access it.
 *
 * @return {LocalStorage}
 * @api private
 */

function localstorage() {
  try {
    return window.localStorage;
  } catch (e) {}
}

/***/ }),
/* 102 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * Helpers.
 */

var s = 1000;
var m = s * 60;
var h = m * 60;
var d = h * 24;
var y = d * 365.25;

/**
 * Parse or format the given `val`.
 *
 * Options:
 *
 *  - `long` verbose formatting [false]
 *
 * @param {String|Number} val
 * @param {Object} [options]
 * @throws {Error} throw an error if val is not a non-empty string or a number
 * @return {String|Number}
 * @api public
 */

module.exports = function (val, options) {
  options = options || {};
  var type = typeof val;
  if (type === 'string' && val.length > 0) {
    return parse(val);
  } else if (type === 'number' && isNaN(val) === false) {
    return options.long ? fmtLong(val) : fmtShort(val);
  }
  throw new Error('val is not a non-empty string or a valid number. val=' + JSON.stringify(val));
};

/**
 * Parse the given `str` and return milliseconds.
 *
 * @param {String} str
 * @return {Number}
 * @api private
 */

function parse(str) {
  str = String(str);
  if (str.length > 100) {
    return;
  }
  var match = /^((?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|years?|yrs?|y)?$/i.exec(str);
  if (!match) {
    return;
  }
  var n = parseFloat(match[1]);
  var type = (match[2] || 'ms').toLowerCase();
  switch (type) {
    case 'years':
    case 'year':
    case 'yrs':
    case 'yr':
    case 'y':
      return n * y;
    case 'days':
    case 'day':
    case 'd':
      return n * d;
    case 'hours':
    case 'hour':
    case 'hrs':
    case 'hr':
    case 'h':
      return n * h;
    case 'minutes':
    case 'minute':
    case 'mins':
    case 'min':
    case 'm':
      return n * m;
    case 'seconds':
    case 'second':
    case 'secs':
    case 'sec':
    case 's':
      return n * s;
    case 'milliseconds':
    case 'millisecond':
    case 'msecs':
    case 'msec':
    case 'ms':
      return n;
    default:
      return undefined;
  }
}

/**
 * Short format for `ms`.
 *
 * @param {Number} ms
 * @return {String}
 * @api private
 */

function fmtShort(ms) {
  if (ms >= d) {
    return Math.round(ms / d) + 'd';
  }
  if (ms >= h) {
    return Math.round(ms / h) + 'h';
  }
  if (ms >= m) {
    return Math.round(ms / m) + 'm';
  }
  if (ms >= s) {
    return Math.round(ms / s) + 's';
  }
  return ms + 'ms';
}

/**
 * Long format for `ms`.
 *
 * @param {Number} ms
 * @return {String}
 * @api private
 */

function fmtLong(ms) {
  return plural(ms, d, 'day') || plural(ms, h, 'hour') || plural(ms, m, 'minute') || plural(ms, s, 'second') || ms + ' ms';
}

/**
 * Pluralization helper.
 */

function plural(ms, n, name) {
  if (ms < n) {
    return;
  }
  if (ms < n * 1.5) {
    return Math.floor(ms / n) + ' ' + name;
  }
  return Math.ceil(ms / n) + ' ' + name + 's';
}

/***/ }),
/* 103 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * Module dependencies.
 */

var tty = __webpack_require__(104);
var util = __webpack_require__(29);

/**
 * This is the Node.js implementation of `debug()`.
 *
 * Expose `debug()` as the module.
 */

exports = module.exports = __webpack_require__(43);
exports.init = init;
exports.log = log;
exports.formatArgs = formatArgs;
exports.save = save;
exports.load = load;
exports.useColors = useColors;

/**
 * Colors.
 */

exports.colors = [6, 2, 3, 4, 5, 1];

try {
  var supportsColor = __webpack_require__(105);
  if (supportsColor && supportsColor.level >= 2) {
    exports.colors = [20, 21, 26, 27, 32, 33, 38, 39, 40, 41, 42, 43, 44, 45, 56, 57, 62, 63, 68, 69, 74, 75, 76, 77, 78, 79, 80, 81, 92, 93, 98, 99, 112, 113, 128, 129, 134, 135, 148, 149, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 178, 179, 184, 185, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 214, 215, 220, 221];
  }
} catch (err) {}
// swallow - we only care if `supports-color` is available; it doesn't have to be.


/**
 * Build up the default `inspectOpts` object from the environment variables.
 *
 *   $ DEBUG_COLORS=no DEBUG_DEPTH=10 DEBUG_SHOW_HIDDEN=enabled node script.js
 */

exports.inspectOpts = Object.keys(process.env).filter(function (key) {
  return (/^debug_/i.test(key)
  );
}).reduce(function (obj, key) {
  // camel-case
  var prop = key.substring(6).toLowerCase().replace(/_([a-z])/g, function (_, k) {
    return k.toUpperCase();
  });

  // coerce string value into JS value
  var val = process.env[key];
  if (/^(yes|on|true|enabled)$/i.test(val)) val = true;else if (/^(no|off|false|disabled)$/i.test(val)) val = false;else if (val === 'null') val = null;else val = Number(val);

  obj[prop] = val;
  return obj;
}, {});

/**
 * Is stdout a TTY? Colored output is enabled when `true`.
 */

function useColors() {
  return 'colors' in exports.inspectOpts ? Boolean(exports.inspectOpts.colors) : tty.isatty(process.stderr.fd);
}

/**
 * Map %o to `util.inspect()`, all on a single line.
 */

exports.formatters.o = function (v) {
  this.inspectOpts.colors = this.useColors;
  return util.inspect(v, this.inspectOpts).split('\n').map(function (str) {
    return str.trim();
  }).join(' ');
};

/**
 * Map %o to `util.inspect()`, allowing multiple lines if needed.
 */

exports.formatters.O = function (v) {
  this.inspectOpts.colors = this.useColors;
  return util.inspect(v, this.inspectOpts);
};

/**
 * Adds ANSI color escape codes if enabled.
 *
 * @api public
 */

function formatArgs(args) {
  var name = this.namespace;
  var useColors = this.useColors;

  if (useColors) {
    var c = this.color;
    var colorCode = '\u001b[3' + (c < 8 ? c : '8;5;' + c);
    var prefix = '  ' + colorCode + ';1m' + name + ' ' + '\u001b[0m';

    args[0] = prefix + args[0].split('\n').join('\n' + prefix);
    args.push(colorCode + 'm+' + exports.humanize(this.diff) + '\u001b[0m');
  } else {
    args[0] = getDate() + name + ' ' + args[0];
  }
}

function getDate() {
  if (exports.inspectOpts.hideDate) {
    return '';
  } else {
    return new Date().toISOString() + ' ';
  }
}

/**
 * Invokes `util.format()` with the specified arguments and writes to stderr.
 */

function log() {
  return process.stderr.write(util.format.apply(util, arguments) + '\n');
}

/**
 * Save `namespaces`.
 *
 * @param {String} namespaces
 * @api private
 */

function save(namespaces) {
  if (null == namespaces) {
    // If you set a process.env field to null or undefined, it gets cast to the
    // string 'null' or 'undefined'. Just delete instead.
    delete process.env.DEBUG;
  } else {
    process.env.DEBUG = namespaces;
  }
}

/**
 * Load `namespaces`.
 *
 * @return {String} returns the previously persisted debug modes
 * @api private
 */

function load() {
  return process.env.DEBUG;
}

/**
 * Init logic for `debug` instances.
 *
 * Create a new `inspectOpts` object in case `useColors` is set
 * differently for a particular `debug` instance.
 */

function init(debug) {
  debug.inspectOpts = {};

  var keys = Object.keys(exports.inspectOpts);
  for (var i = 0; i < keys.length; i++) {
    debug.inspectOpts[keys[i]] = exports.inspectOpts[keys[i]];
  }
}

/**
 * Enable namespaces listed in `process.env.DEBUG` initially.
 */

exports.enable(load());

/***/ }),
/* 104 */
/***/ (function(module, exports) {

module.exports = require("tty");

/***/ }),
/* 105 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const os = __webpack_require__(15);
const hasFlag = __webpack_require__(106);

const env = process.env;

const support = level => {
	if (level === 0) {
		return false;
	}

	return {
		level,
		hasBasic: true,
		has256: level >= 2,
		has16m: level >= 3
	};
};

let supportLevel = (() => {
	if (hasFlag('no-color') || hasFlag('no-colors') || hasFlag('color=false')) {
		return 0;
	}

	if (hasFlag('color=16m') || hasFlag('color=full') || hasFlag('color=truecolor')) {
		return 3;
	}

	if (hasFlag('color=256')) {
		return 2;
	}

	if (hasFlag('color') || hasFlag('colors') || hasFlag('color=true') || hasFlag('color=always')) {
		return 1;
	}

	if (process.stdout && !process.stdout.isTTY) {
		return 0;
	}

	if (process.platform === 'win32') {
		// Node.js 7.5.0 is the first version of Node.js to include a patch to
		// libuv that enables 256 color output on Windows. Anything earlier and it
		// won't work. However, here we target Node.js 8 at minimum as it is an LTS
		// release, and Node.js 7 is not. Windows 10 build 10586 is the first Windows
		// release that supports 256 colors.
		const osRelease = os.release().split('.');
		if (Number(process.versions.node.split('.')[0]) >= 8 && Number(osRelease[0]) >= 10 && Number(osRelease[2]) >= 10586) {
			return 2;
		}

		return 1;
	}

	if ('CI' in env) {
		if (['TRAVIS', 'CIRCLECI', 'APPVEYOR', 'GITLAB_CI'].some(sign => sign in env) || env.CI_NAME === 'codeship') {
			return 1;
		}

		return 0;
	}

	if ('TEAMCITY_VERSION' in env) {
		return (/^(9\.(0*[1-9]\d*)\.|\d{2,}\.)/.test(env.TEAMCITY_VERSION) ? 1 : 0
		);
	}

	if ('TERM_PROGRAM' in env) {
		const version = parseInt((env.TERM_PROGRAM_VERSION || '').split('.')[0], 10);

		switch (env.TERM_PROGRAM) {
			case 'iTerm.app':
				return version >= 3 ? 3 : 2;
			case 'Hyper':
				return 3;
			case 'Apple_Terminal':
				return 2;
			// No default
		}
	}

	if (/-256(color)?$/i.test(env.TERM)) {
		return 2;
	}

	if (/^screen|^xterm|^vt100|^rxvt|color|ansi|cygwin|linux/i.test(env.TERM)) {
		return 1;
	}

	if ('COLORTERM' in env) {
		return 1;
	}

	if (env.TERM === 'dumb') {
		return 0;
	}

	return 0;
})();

if ('FORCE_COLOR' in env) {
	supportLevel = parseInt(env.FORCE_COLOR, 10) === 0 ? 0 : supportLevel || 1;
}

module.exports = process && support(supportLevel);

/***/ }),
/* 106 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = function (flag, argv) {
	argv = argv || process.argv;

	var terminatorPos = argv.indexOf('--');
	var prefix = /^-{1,2}/.test(flag) ? '' : '--';
	var pos = argv.indexOf(prefix + flag);

	return pos !== -1 && (terminatorPos === -1 ? true : pos < terminatorPos);
};

/***/ }),
/* 107 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const assign = __webpack_require__(108);

const fs = {};

// Export graceful-fs:
assign(fs, __webpack_require__(44));
// Export extra methods:
assign(fs, __webpack_require__(112));
assign(fs, __webpack_require__(50));
assign(fs, __webpack_require__(7));
assign(fs, __webpack_require__(24));
assign(fs, __webpack_require__(117));
assign(fs, __webpack_require__(121));
assign(fs, __webpack_require__(122));
assign(fs, __webpack_require__(123));
assign(fs, __webpack_require__(124));
assign(fs, __webpack_require__(130));
assign(fs, __webpack_require__(13));

module.exports = fs;

/***/ }),
/* 108 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// simple mutable assign

function assign() {
  const args = [].slice.call(arguments).filter(i => i);
  const dest = args.shift();
  args.forEach(src => {
    Object.keys(src).forEach(key => {
      dest[key] = src[key];
    });
  });

  return dest;
}

module.exports = assign;

/***/ }),
/* 109 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var fs = __webpack_require__(45);
var constants = __webpack_require__(110);

var origCwd = process.cwd;
var cwd = null;

var platform = process.env.GRACEFUL_FS_PLATFORM || process.platform;

process.cwd = function () {
  if (!cwd) cwd = origCwd.call(process);
  return cwd;
};
try {
  process.cwd();
} catch (er) {}

var chdir = process.chdir;
process.chdir = function (d) {
  cwd = null;
  chdir.call(process, d);
};

module.exports = patch;

function patch(fs) {
  // (re-)implement some things that are known busted or missing.

  // lchmod, broken prior to 0.6.2
  // back-port the fix here.
  if (constants.hasOwnProperty('O_SYMLINK') && process.version.match(/^v0\.6\.[0-2]|^v0\.5\./)) {
    patchLchmod(fs);
  }

  // lutimes implementation, or no-op
  if (!fs.lutimes) {
    patchLutimes(fs);
  }

  // https://github.com/isaacs/node-graceful-fs/issues/4
  // Chown should not fail on einval or eperm if non-root.
  // It should not fail on enosys ever, as this just indicates
  // that a fs doesn't support the intended operation.

  fs.chown = chownFix(fs.chown);
  fs.fchown = chownFix(fs.fchown);
  fs.lchown = chownFix(fs.lchown);

  fs.chmod = chmodFix(fs.chmod);
  fs.fchmod = chmodFix(fs.fchmod);
  fs.lchmod = chmodFix(fs.lchmod);

  fs.chownSync = chownFixSync(fs.chownSync);
  fs.fchownSync = chownFixSync(fs.fchownSync);
  fs.lchownSync = chownFixSync(fs.lchownSync);

  fs.chmodSync = chmodFixSync(fs.chmodSync);
  fs.fchmodSync = chmodFixSync(fs.fchmodSync);
  fs.lchmodSync = chmodFixSync(fs.lchmodSync);

  fs.stat = statFix(fs.stat);
  fs.fstat = statFix(fs.fstat);
  fs.lstat = statFix(fs.lstat);

  fs.statSync = statFixSync(fs.statSync);
  fs.fstatSync = statFixSync(fs.fstatSync);
  fs.lstatSync = statFixSync(fs.lstatSync);

  // if lchmod/lchown do not exist, then make them no-ops
  if (!fs.lchmod) {
    fs.lchmod = function (path, mode, cb) {
      if (cb) process.nextTick(cb);
    };
    fs.lchmodSync = function () {};
  }
  if (!fs.lchown) {
    fs.lchown = function (path, uid, gid, cb) {
      if (cb) process.nextTick(cb);
    };
    fs.lchownSync = function () {};
  }

  // on Windows, A/V software can lock the directory, causing this
  // to fail with an EACCES or EPERM if the directory contains newly
  // created files.  Try again on failure, for up to 60 seconds.

  // Set the timeout this long because some Windows Anti-Virus, such as Parity
  // bit9, may lock files for up to a minute, causing npm package install
  // failures. Also, take care to yield the scheduler. Windows scheduling gives
  // CPU to a busy looping process, which can cause the program causing the lock
  // contention to be starved of CPU by node, so the contention doesn't resolve.
  if (platform === "win32") {
    fs.rename = function (fs$rename) {
      return function (from, to, cb) {
        var start = Date.now();
        var backoff = 0;
        fs$rename(from, to, function CB(er) {
          if (er && (er.code === "EACCES" || er.code === "EPERM") && Date.now() - start < 60000) {
            setTimeout(function () {
              fs.stat(to, function (stater, st) {
                if (stater && stater.code === "ENOENT") fs$rename(from, to, CB);else cb(er);
              });
            }, backoff);
            if (backoff < 100) backoff += 10;
            return;
          }
          if (cb) cb(er);
        });
      };
    }(fs.rename);
  }

  // if read() returns EAGAIN, then just try it again.
  fs.read = function (fs$read) {
    return function (fd, buffer, offset, length, position, callback_) {
      var callback;
      if (callback_ && typeof callback_ === 'function') {
        var eagCounter = 0;
        callback = function (er, _, __) {
          if (er && er.code === 'EAGAIN' && eagCounter < 10) {
            eagCounter++;
            return fs$read.call(fs, fd, buffer, offset, length, position, callback);
          }
          callback_.apply(this, arguments);
        };
      }
      return fs$read.call(fs, fd, buffer, offset, length, position, callback);
    };
  }(fs.read);

  fs.readSync = function (fs$readSync) {
    return function (fd, buffer, offset, length, position) {
      var eagCounter = 0;
      while (true) {
        try {
          return fs$readSync.call(fs, fd, buffer, offset, length, position);
        } catch (er) {
          if (er.code === 'EAGAIN' && eagCounter < 10) {
            eagCounter++;
            continue;
          }
          throw er;
        }
      }
    };
  }(fs.readSync);
}

function patchLchmod(fs) {
  fs.lchmod = function (path, mode, callback) {
    fs.open(path, constants.O_WRONLY | constants.O_SYMLINK, mode, function (err, fd) {
      if (err) {
        if (callback) callback(err);
        return;
      }
      // prefer to return the chmod error, if one occurs,
      // but still try to close, and report closing errors if they occur.
      fs.fchmod(fd, mode, function (err) {
        fs.close(fd, function (err2) {
          if (callback) callback(err || err2);
        });
      });
    });
  };

  fs.lchmodSync = function (path, mode) {
    var fd = fs.openSync(path, constants.O_WRONLY | constants.O_SYMLINK, mode);

    // prefer to return the chmod error, if one occurs,
    // but still try to close, and report closing errors if they occur.
    var threw = true;
    var ret;
    try {
      ret = fs.fchmodSync(fd, mode);
      threw = false;
    } finally {
      if (threw) {
        try {
          fs.closeSync(fd);
        } catch (er) {}
      } else {
        fs.closeSync(fd);
      }
    }
    return ret;
  };
}

function patchLutimes(fs) {
  if (constants.hasOwnProperty("O_SYMLINK")) {
    fs.lutimes = function (path, at, mt, cb) {
      fs.open(path, constants.O_SYMLINK, function (er, fd) {
        if (er) {
          if (cb) cb(er);
          return;
        }
        fs.futimes(fd, at, mt, function (er) {
          fs.close(fd, function (er2) {
            if (cb) cb(er || er2);
          });
        });
      });
    };

    fs.lutimesSync = function (path, at, mt) {
      var fd = fs.openSync(path, constants.O_SYMLINK);
      var ret;
      var threw = true;
      try {
        ret = fs.futimesSync(fd, at, mt);
        threw = false;
      } finally {
        if (threw) {
          try {
            fs.closeSync(fd);
          } catch (er) {}
        } else {
          fs.closeSync(fd);
        }
      }
      return ret;
    };
  } else {
    fs.lutimes = function (_a, _b, _c, cb) {
      if (cb) process.nextTick(cb);
    };
    fs.lutimesSync = function () {};
  }
}

function chmodFix(orig) {
  if (!orig) return orig;
  return function (target, mode, cb) {
    return orig.call(fs, target, mode, function (er) {
      if (chownErOk(er)) er = null;
      if (cb) cb.apply(this, arguments);
    });
  };
}

function chmodFixSync(orig) {
  if (!orig) return orig;
  return function (target, mode) {
    try {
      return orig.call(fs, target, mode);
    } catch (er) {
      if (!chownErOk(er)) throw er;
    }
  };
}

function chownFix(orig) {
  if (!orig) return orig;
  return function (target, uid, gid, cb) {
    return orig.call(fs, target, uid, gid, function (er) {
      if (chownErOk(er)) er = null;
      if (cb) cb.apply(this, arguments);
    });
  };
}

function chownFixSync(orig) {
  if (!orig) return orig;
  return function (target, uid, gid) {
    try {
      return orig.call(fs, target, uid, gid);
    } catch (er) {
      if (!chownErOk(er)) throw er;
    }
  };
}

function statFix(orig) {
  if (!orig) return orig;
  // Older versions of Node erroneously returned signed integers for
  // uid + gid.
  return function (target, cb) {
    return orig.call(fs, target, function (er, stats) {
      if (!stats) return cb.apply(this, arguments);
      if (stats.uid < 0) stats.uid += 0x100000000;
      if (stats.gid < 0) stats.gid += 0x100000000;
      if (cb) cb.apply(this, arguments);
    });
  };
}

function statFixSync(orig) {
  if (!orig) return orig;
  // Older versions of Node erroneously returned signed integers for
  // uid + gid.
  return function (target) {
    var stats = orig.call(fs, target);
    if (stats.uid < 0) stats.uid += 0x100000000;
    if (stats.gid < 0) stats.gid += 0x100000000;
    return stats;
  };
}

// ENOSYS means that the fs doesn't support the op. Just ignore
// that, because it doesn't matter.
//
// if there's no getuid, or if getuid() is something other
// than 0, and the error is EINVAL or EPERM, then just ignore
// it.
//
// This specific case is a silent failure in cp, install, tar,
// and most other unix tools that manage permissions.
//
// When running as root, or if other types of errors are
// encountered, then it's strict.
function chownErOk(er) {
  if (!er) return true;

  if (er.code === "ENOSYS") return true;

  var nonroot = !process.getuid || process.getuid() !== 0;
  if (nonroot) {
    if (er.code === "EINVAL" || er.code === "EPERM") return true;
  }

  return false;
}

/***/ }),
/* 110 */
/***/ (function(module, exports) {

module.exports = require("constants");

/***/ }),
/* 111 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var Stream = __webpack_require__(19).Stream;

module.exports = legacy;

function legacy(fs) {
  return {
    ReadStream: ReadStream,
    WriteStream: WriteStream
  };

  function ReadStream(path, options) {
    if (!(this instanceof ReadStream)) return new ReadStream(path, options);

    Stream.call(this);

    var self = this;

    this.path = path;
    this.fd = null;
    this.readable = true;
    this.paused = false;

    this.flags = 'r';
    this.mode = 438; /*=0666*/
    this.bufferSize = 64 * 1024;

    options = options || {};

    // Mixin options into this
    var keys = Object.keys(options);
    for (var index = 0, length = keys.length; index < length; index++) {
      var key = keys[index];
      this[key] = options[key];
    }

    if (this.encoding) this.setEncoding(this.encoding);

    if (this.start !== undefined) {
      if ('number' !== typeof this.start) {
        throw TypeError('start must be a Number');
      }
      if (this.end === undefined) {
        this.end = Infinity;
      } else if ('number' !== typeof this.end) {
        throw TypeError('end must be a Number');
      }

      if (this.start > this.end) {
        throw new Error('start must be <= end');
      }

      this.pos = this.start;
    }

    if (this.fd !== null) {
      process.nextTick(function () {
        self._read();
      });
      return;
    }

    fs.open(this.path, this.flags, this.mode, function (err, fd) {
      if (err) {
        self.emit('error', err);
        self.readable = false;
        return;
      }

      self.fd = fd;
      self.emit('open', fd);
      self._read();
    });
  }

  function WriteStream(path, options) {
    if (!(this instanceof WriteStream)) return new WriteStream(path, options);

    Stream.call(this);

    this.path = path;
    this.fd = null;
    this.writable = true;

    this.flags = 'w';
    this.encoding = 'binary';
    this.mode = 438; /*=0666*/
    this.bytesWritten = 0;

    options = options || {};

    // Mixin options into this
    var keys = Object.keys(options);
    for (var index = 0, length = keys.length; index < length; index++) {
      var key = keys[index];
      this[key] = options[key];
    }

    if (this.start !== undefined) {
      if ('number' !== typeof this.start) {
        throw TypeError('start must be a Number');
      }
      if (this.start < 0) {
        throw new Error('start must be >= zero');
      }

      this.pos = this.start;
    }

    this.busy = false;
    this._queue = [];

    if (this.fd === null) {
      this._open = fs.open;
      this._queue.push([this._open, this.path, this.flags, this.mode, undefined]);
      this.flush();
    }
  }
}

/***/ }),
/* 112 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const u = __webpack_require__(6).fromCallback;
module.exports = {
  copy: u(__webpack_require__(47))
};

/***/ }),
/* 113 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const fs = __webpack_require__(5);
const path = __webpack_require__(0);
const invalidWin32Path = __webpack_require__(48).invalidWin32Path;

const o777 = parseInt('0777', 8);

function mkdirs(p, opts, callback, made) {
  if (typeof opts === 'function') {
    callback = opts;
    opts = {};
  } else if (!opts || typeof opts !== 'object') {
    opts = { mode: opts };
  }

  if (process.platform === 'win32' && invalidWin32Path(p)) {
    const errInval = new Error(p + ' contains invalid WIN32 path characters.');
    errInval.code = 'EINVAL';
    return callback(errInval);
  }

  let mode = opts.mode;
  const xfs = opts.fs || fs;

  if (mode === undefined) {
    mode = o777 & ~process.umask();
  }
  if (!made) made = null;

  callback = callback || function () {};
  p = path.resolve(p);

  xfs.mkdir(p, mode, er => {
    if (!er) {
      made = made || p;
      return callback(null, made);
    }
    switch (er.code) {
      case 'ENOENT':
        if (path.dirname(p) === p) return callback(er);
        mkdirs(path.dirname(p), opts, (er, made) => {
          if (er) callback(er, made);else mkdirs(p, opts, callback, made);
        });
        break;

      // In the case of any other error, just see if there's a dir
      // there already.  If so, then hooray!  If not, then something
      // is borked.
      default:
        xfs.stat(p, (er2, stat) => {
          // if the stat fails, then that's super weird.
          // let the original error be the failure reason.
          if (er2 || !stat.isDirectory()) callback(er, made);else callback(null, made);
        });
        break;
    }
  });
}

module.exports = mkdirs;

/***/ }),
/* 114 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const fs = __webpack_require__(5);
const path = __webpack_require__(0);
const invalidWin32Path = __webpack_require__(48).invalidWin32Path;

const o777 = parseInt('0777', 8);

function mkdirsSync(p, opts, made) {
  if (!opts || typeof opts !== 'object') {
    opts = { mode: opts };
  }

  let mode = opts.mode;
  const xfs = opts.fs || fs;

  if (process.platform === 'win32' && invalidWin32Path(p)) {
    const errInval = new Error(p + ' contains invalid WIN32 path characters.');
    errInval.code = 'EINVAL';
    throw errInval;
  }

  if (mode === undefined) {
    mode = o777 & ~process.umask();
  }
  if (!made) made = null;

  p = path.resolve(p);

  try {
    xfs.mkdirSync(p, mode);
    made = made || p;
  } catch (err0) {
    switch (err0.code) {
      case 'ENOENT':
        if (path.dirname(p) === p) throw err0;
        made = mkdirsSync(path.dirname(p), opts, made);
        mkdirsSync(p, opts, made);
        break;

      // In the case of any other error, just see if there's a dir
      // there already.  If so, then hooray!  If not, then something
      // is borked.
      default:
        let stat;
        try {
          stat = xfs.statSync(p);
        } catch (err1) {
          throw err0;
        }
        if (!stat.isDirectory()) throw err0;
        break;
    }
  }

  return made;
}

module.exports = mkdirsSync;

/***/ }),
/* 115 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const fs = __webpack_require__(5);
const path = __webpack_require__(0);
const mkdirpSync = __webpack_require__(7).mkdirsSync;
const utimesSync = __webpack_require__(49).utimesMillisSync;

const notExist = Symbol('notExist');
const existsReg = Symbol('existsReg');

function copySync(src, dest, opts) {
  if (typeof opts === 'function') {
    opts = { filter: opts };
  }

  opts = opts || {};
  opts.clobber = 'clobber' in opts ? !!opts.clobber : true; // default to true for now
  opts.overwrite = 'overwrite' in opts ? !!opts.overwrite : opts.clobber; // overwrite falls back to clobber

  // Warn about using preserveTimestamps on 32-bit node
  if (opts.preserveTimestamps && process.arch === 'ia32') {
    console.warn(`fs-extra: Using the preserveTimestamps option in 32-bit node is not recommended;\n
    see https://github.com/jprichardson/node-fs-extra/issues/269`);
  }

  src = path.resolve(src);
  dest = path.resolve(dest);

  // don't allow src and dest to be the same
  if (src === dest) throw new Error('Source and destination must not be the same.');

  if (opts.filter && !opts.filter(src, dest)) return;

  const destParent = path.dirname(dest);
  if (!fs.existsSync(destParent)) mkdirpSync(destParent);
  return startCopy(src, dest, opts);
}

function startCopy(src, dest, opts) {
  if (opts.filter && !opts.filter(src, dest)) return;
  return getStats(src, dest, opts);
}

function getStats(src, dest, opts) {
  const statSync = opts.dereference ? fs.statSync : fs.lstatSync;
  const st = statSync(src);

  if (st.isDirectory()) return onDir(st, src, dest, opts);else if (st.isFile() || st.isCharacterDevice() || st.isBlockDevice()) return onFile(st, src, dest, opts);else if (st.isSymbolicLink()) return onLink(src, dest, opts);
}

function onFile(srcStat, src, dest, opts) {
  const resolvedPath = checkDest(dest);
  if (resolvedPath === notExist) {
    return copyFile(srcStat, src, dest, opts);
  } else if (resolvedPath === existsReg) {
    return mayCopyFile(srcStat, src, dest, opts);
  } else {
    if (src === resolvedPath) return;
    return mayCopyFile(srcStat, src, dest, opts);
  }
}

function mayCopyFile(srcStat, src, dest, opts) {
  if (opts.overwrite) {
    fs.unlinkSync(dest);
    return copyFile(srcStat, src, dest, opts);
  } else if (opts.errorOnExist) {
    throw new Error(`'${dest}' already exists`);
  }
}

function copyFile(srcStat, src, dest, opts) {
  if (typeof fs.copyFileSync === 'function') {
    fs.copyFileSync(src, dest);
    fs.chmodSync(dest, srcStat.mode);
    if (opts.preserveTimestamps) {
      return utimesSync(dest, srcStat.atime, srcStat.mtime);
    }
    return;
  }
  return copyFileFallback(srcStat, src, dest, opts);
}

function copyFileFallback(srcStat, src, dest, opts) {
  const BUF_LENGTH = 64 * 1024;
  const _buff = __webpack_require__(51)(BUF_LENGTH);

  const fdr = fs.openSync(src, 'r');
  const fdw = fs.openSync(dest, 'w', srcStat.mode);
  let bytesRead = 1;
  let pos = 0;

  while (bytesRead > 0) {
    bytesRead = fs.readSync(fdr, _buff, 0, BUF_LENGTH, pos);
    fs.writeSync(fdw, _buff, 0, bytesRead);
    pos += bytesRead;
  }

  if (opts.preserveTimestamps) fs.futimesSync(fdw, srcStat.atime, srcStat.mtime);

  fs.closeSync(fdr);
  fs.closeSync(fdw);
}

function onDir(srcStat, src, dest, opts) {
  const resolvedPath = checkDest(dest);
  if (resolvedPath === notExist) {
    if (isSrcSubdir(src, dest)) {
      throw new Error(`Cannot copy '${src}' to a subdirectory of itself, '${dest}'.`);
    }
    return mkDirAndCopy(srcStat, src, dest, opts);
  } else if (resolvedPath === existsReg) {
    if (isSrcSubdir(src, dest)) {
      throw new Error(`Cannot copy '${src}' to a subdirectory of itself, '${dest}'.`);
    }
    return mayCopyDir(src, dest, opts);
  } else {
    if (src === resolvedPath) return;
    return copyDir(src, dest, opts);
  }
}

function mayCopyDir(src, dest, opts) {
  if (!fs.statSync(dest).isDirectory()) {
    throw new Error(`Cannot overwrite non-directory '${dest}' with directory '${src}'.`);
  }
  return copyDir(src, dest, opts);
}

function mkDirAndCopy(srcStat, src, dest, opts) {
  fs.mkdirSync(dest, srcStat.mode);
  fs.chmodSync(dest, srcStat.mode);
  return copyDir(src, dest, opts);
}

function copyDir(src, dest, opts) {
  fs.readdirSync(src).forEach(item => {
    startCopy(path.join(src, item), path.join(dest, item), opts);
  });
}

function onLink(src, dest, opts) {
  let resolvedSrcPath = fs.readlinkSync(src);

  if (opts.dereference) {
    resolvedSrcPath = path.resolve(process.cwd(), resolvedSrcPath);
  }

  let resolvedDestPath = checkDest(dest);
  if (resolvedDestPath === notExist || resolvedDestPath === existsReg) {
    // if dest already exists, fs throws error anyway,
    // so no need to guard against it here.
    return fs.symlinkSync(resolvedSrcPath, dest);
  } else {
    if (opts.dereference) {
      resolvedDestPath = path.resolve(process.cwd(), resolvedDestPath);
    }
    if (resolvedDestPath === resolvedSrcPath) return;

    // prevent copy if src is a subdir of dest since unlinking
    // dest in this case would result in removing src contents
    // and therefore a broken symlink would be created.
    if (fs.statSync(dest).isDirectory() && isSrcSubdir(resolvedDestPath, resolvedSrcPath)) {
      throw new Error(`Cannot overwrite '${resolvedDestPath}' with '${resolvedSrcPath}'.`);
    }
    return copyLink(resolvedSrcPath, dest);
  }
}

function copyLink(resolvedSrcPath, dest) {
  fs.unlinkSync(dest);
  return fs.symlinkSync(resolvedSrcPath, dest);
}

// check if dest exists and/or is a symlink
function checkDest(dest) {
  let resolvedPath;
  try {
    resolvedPath = fs.readlinkSync(dest);
  } catch (err) {
    if (err.code === 'ENOENT') return notExist;

    // dest exists and is a regular file or directory, Windows may throw UNKNOWN error
    if (err.code === 'EINVAL' || err.code === 'UNKNOWN') return existsReg;

    throw err;
  }
  return resolvedPath; // dest exists and is a symlink
}

// return true if dest is a subdir of src, otherwise false.
// extract dest base dir and check if that is the same as src basename
function isSrcSubdir(src, dest) {
  const baseDir = dest.split(path.dirname(src) + path.sep)[1];
  if (baseDir) {
    const destBasename = baseDir.split(path.sep)[0];
    if (destBasename) {
      return src !== dest && dest.indexOf(src) > -1 && destBasename === path.basename(src);
    }
    return false;
  }
  return false;
}

module.exports = copySync;

/***/ }),
/* 116 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const fs = __webpack_require__(5);
const path = __webpack_require__(0);
const assert = __webpack_require__(46);

const isWindows = process.platform === 'win32';

function defaults(options) {
  const methods = ['unlink', 'chmod', 'stat', 'lstat', 'rmdir', 'readdir'];
  methods.forEach(m => {
    options[m] = options[m] || fs[m];
    m = m + 'Sync';
    options[m] = options[m] || fs[m];
  });

  options.maxBusyTries = options.maxBusyTries || 3;
}

function rimraf(p, options, cb) {
  let busyTries = 0;

  if (typeof options === 'function') {
    cb = options;
    options = {};
  }

  assert(p, 'rimraf: missing path');
  assert.equal(typeof p, 'string', 'rimraf: path should be a string');
  assert.equal(typeof cb, 'function', 'rimraf: callback function required');
  assert(options, 'rimraf: invalid options argument provided');
  assert.equal(typeof options, 'object', 'rimraf: options should be object');

  defaults(options);

  rimraf_(p, options, function CB(er) {
    if (er) {
      if ((er.code === 'EBUSY' || er.code === 'ENOTEMPTY' || er.code === 'EPERM') && busyTries < options.maxBusyTries) {
        busyTries++;
        let time = busyTries * 100;
        // try again, with the same exact callback as this one.
        return setTimeout(() => rimraf_(p, options, CB), time);
      }

      // already gone
      if (er.code === 'ENOENT') er = null;
    }

    cb(er);
  });
}

// Two possible strategies.
// 1. Assume it's a file.  unlink it, then do the dir stuff on EPERM or EISDIR
// 2. Assume it's a directory.  readdir, then do the file stuff on ENOTDIR
//
// Both result in an extra syscall when you guess wrong.  However, there
// are likely far more normal files in the world than directories.  This
// is based on the assumption that a the average number of files per
// directory is >= 1.
//
// If anyone ever complains about this, then I guess the strategy could
// be made configurable somehow.  But until then, YAGNI.
function rimraf_(p, options, cb) {
  assert(p);
  assert(options);
  assert(typeof cb === 'function');

  // sunos lets the root user unlink directories, which is... weird.
  // so we have to lstat here and make sure it's not a dir.
  options.lstat(p, (er, st) => {
    if (er && er.code === 'ENOENT') {
      return cb(null);
    }

    // Windows can EPERM on stat.  Life is suffering.
    if (er && er.code === 'EPERM' && isWindows) {
      return fixWinEPERM(p, options, er, cb);
    }

    if (st && st.isDirectory()) {
      return rmdir(p, options, er, cb);
    }

    options.unlink(p, er => {
      if (er) {
        if (er.code === 'ENOENT') {
          return cb(null);
        }
        if (er.code === 'EPERM') {
          return isWindows ? fixWinEPERM(p, options, er, cb) : rmdir(p, options, er, cb);
        }
        if (er.code === 'EISDIR') {
          return rmdir(p, options, er, cb);
        }
      }
      return cb(er);
    });
  });
}

function fixWinEPERM(p, options, er, cb) {
  assert(p);
  assert(options);
  assert(typeof cb === 'function');
  if (er) {
    assert(er instanceof Error);
  }

  options.chmod(p, 0o666, er2 => {
    if (er2) {
      cb(er2.code === 'ENOENT' ? null : er);
    } else {
      options.stat(p, (er3, stats) => {
        if (er3) {
          cb(er3.code === 'ENOENT' ? null : er);
        } else if (stats.isDirectory()) {
          rmdir(p, options, er, cb);
        } else {
          options.unlink(p, cb);
        }
      });
    }
  });
}

function fixWinEPERMSync(p, options, er) {
  let stats;

  assert(p);
  assert(options);
  if (er) {
    assert(er instanceof Error);
  }

  try {
    options.chmodSync(p, 0o666);
  } catch (er2) {
    if (er2.code === 'ENOENT') {
      return;
    } else {
      throw er;
    }
  }

  try {
    stats = options.statSync(p);
  } catch (er3) {
    if (er3.code === 'ENOENT') {
      return;
    } else {
      throw er;
    }
  }

  if (stats.isDirectory()) {
    rmdirSync(p, options, er);
  } else {
    options.unlinkSync(p);
  }
}

function rmdir(p, options, originalEr, cb) {
  assert(p);
  assert(options);
  if (originalEr) {
    assert(originalEr instanceof Error);
  }
  assert(typeof cb === 'function');

  // try to rmdir first, and only readdir on ENOTEMPTY or EEXIST (SunOS)
  // if we guessed wrong, and it's not a directory, then
  // raise the original error.
  options.rmdir(p, er => {
    if (er && (er.code === 'ENOTEMPTY' || er.code === 'EEXIST' || er.code === 'EPERM')) {
      rmkids(p, options, cb);
    } else if (er && er.code === 'ENOTDIR') {
      cb(originalEr);
    } else {
      cb(er);
    }
  });
}

function rmkids(p, options, cb) {
  assert(p);
  assert(options);
  assert(typeof cb === 'function');

  options.readdir(p, (er, files) => {
    if (er) return cb(er);

    let n = files.length;
    let errState;

    if (n === 0) return options.rmdir(p, cb);

    files.forEach(f => {
      rimraf(path.join(p, f), options, er => {
        if (errState) {
          return;
        }
        if (er) return cb(errState = er);
        if (--n === 0) {
          options.rmdir(p, cb);
        }
      });
    });
  });
}

// this looks simpler, and is strictly *faster*, but will
// tie up the JavaScript thread and fail on excessively
// deep directory trees.
function rimrafSync(p, options) {
  let st;

  options = options || {};
  defaults(options);

  assert(p, 'rimraf: missing path');
  assert.equal(typeof p, 'string', 'rimraf: path should be a string');
  assert(options, 'rimraf: missing options');
  assert.equal(typeof options, 'object', 'rimraf: options should be object');

  try {
    st = options.lstatSync(p);
  } catch (er) {
    if (er.code === 'ENOENT') {
      return;
    }

    // Windows can EPERM on stat.  Life is suffering.
    if (er.code === 'EPERM' && isWindows) {
      fixWinEPERMSync(p, options, er);
    }
  }

  try {
    // sunos lets the root user unlink directories, which is... weird.
    if (st && st.isDirectory()) {
      rmdirSync(p, options, null);
    } else {
      options.unlinkSync(p);
    }
  } catch (er) {
    if (er.code === 'ENOENT') {
      return;
    } else if (er.code === 'EPERM') {
      return isWindows ? fixWinEPERMSync(p, options, er) : rmdirSync(p, options, er);
    } else if (er.code !== 'EISDIR') {
      throw er;
    }
    rmdirSync(p, options, er);
  }
}

function rmdirSync(p, options, originalEr) {
  assert(p);
  assert(options);
  if (originalEr) {
    assert(originalEr instanceof Error);
  }

  try {
    options.rmdirSync(p);
  } catch (er) {
    if (er.code === 'ENOTDIR') {
      throw originalEr;
    } else if (er.code === 'ENOTEMPTY' || er.code === 'EEXIST' || er.code === 'EPERM') {
      rmkidsSync(p, options);
    } else if (er.code !== 'ENOENT') {
      throw er;
    }
  }
}

function rmkidsSync(p, options) {
  assert(p);
  assert(options);
  options.readdirSync(p).forEach(f => rimrafSync(path.join(p, f), options));

  // We only end up here once we got ENOTEMPTY at least once, and
  // at this point, we are guaranteed to have removed all the kids.
  // So, we know that it won't be ENOENT or ENOTDIR or anything else.
  // try really hard to delete stuff on windows, because it has a
  // PROFOUNDLY annoying habit of not closing handles promptly when
  // files are deleted, resulting in spurious ENOTEMPTY errors.
  const retries = isWindows ? 100 : 1;
  let i = 0;
  do {
    let threw = true;
    try {
      const ret = options.rmdirSync(p, options);
      threw = false;
      return ret;
    } finally {
      if (++i < retries && threw) continue; // eslint-disable-line
    }
  } while (true);
}

module.exports = rimraf;
rimraf.sync = rimrafSync;

/***/ }),
/* 117 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const u = __webpack_require__(6).fromCallback;
const jsonFile = __webpack_require__(30);

jsonFile.outputJson = u(__webpack_require__(119));
jsonFile.outputJsonSync = __webpack_require__(120);
// aliases
jsonFile.outputJSON = jsonFile.outputJson;
jsonFile.outputJSONSync = jsonFile.outputJsonSync;
jsonFile.writeJSON = jsonFile.writeJson;
jsonFile.writeJSONSync = jsonFile.writeJsonSync;
jsonFile.readJSON = jsonFile.readJson;
jsonFile.readJSONSync = jsonFile.readJsonSync;

module.exports = jsonFile;

/***/ }),
/* 118 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _fs;
try {
  _fs = __webpack_require__(5);
} catch (_) {
  _fs = __webpack_require__(12);
}

function readFile(file, options, callback) {
  if (callback == null) {
    callback = options;
    options = {};
  }

  if (typeof options === 'string') {
    options = { encoding: options };
  }

  options = options || {};
  var fs = options.fs || _fs;

  var shouldThrow = true;
  if ('throws' in options) {
    shouldThrow = options.throws;
  }

  fs.readFile(file, options, function (err, data) {
    if (err) return callback(err);

    data = stripBom(data);

    var obj;
    try {
      obj = JSON.parse(data, options ? options.reviver : null);
    } catch (err2) {
      if (shouldThrow) {
        err2.message = file + ': ' + err2.message;
        return callback(err2);
      } else {
        return callback(null, null);
      }
    }

    callback(null, obj);
  });
}

function readFileSync(file, options) {
  options = options || {};
  if (typeof options === 'string') {
    options = { encoding: options };
  }

  var fs = options.fs || _fs;

  var shouldThrow = true;
  if ('throws' in options) {
    shouldThrow = options.throws;
  }

  try {
    var content = fs.readFileSync(file, options);
    content = stripBom(content);
    return JSON.parse(content, options.reviver);
  } catch (err) {
    if (shouldThrow) {
      err.message = file + ': ' + err.message;
      throw err;
    } else {
      return null;
    }
  }
}

function stringify(obj, options) {
  var spaces;
  var EOL = '\n';
  if (typeof options === 'object' && options !== null) {
    if (options.spaces) {
      spaces = options.spaces;
    }
    if (options.EOL) {
      EOL = options.EOL;
    }
  }

  var str = JSON.stringify(obj, options ? options.replacer : null, spaces);

  return str.replace(/\n/g, EOL) + EOL;
}

function writeFile(file, obj, options, callback) {
  if (callback == null) {
    callback = options;
    options = {};
  }
  options = options || {};
  var fs = options.fs || _fs;

  var str = '';
  try {
    str = stringify(obj, options);
  } catch (err) {
    // Need to return whether a callback was passed or not
    if (callback) callback(err, null);
    return;
  }

  fs.writeFile(file, str, options, callback);
}

function writeFileSync(file, obj, options) {
  options = options || {};
  var fs = options.fs || _fs;

  var str = stringify(obj, options);
  // not sure if fs.writeFileSync returns anything, but just in case
  return fs.writeFileSync(file, str, options);
}

function stripBom(content) {
  // we do this because JSON.parse would convert it to a utf8 string if encoding wasn't specified
  if (Buffer.isBuffer(content)) content = content.toString('utf8');
  content = content.replace(/^\uFEFF/, '');
  return content;
}

var jsonfile = {
  readFile: readFile,
  readFileSync: readFileSync,
  writeFile: writeFile,
  writeFileSync: writeFileSync
};

module.exports = jsonfile;

/***/ }),
/* 119 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const path = __webpack_require__(0);
const mkdir = __webpack_require__(7);
const pathExists = __webpack_require__(13).pathExists;
const jsonFile = __webpack_require__(30);

function outputJson(file, data, options, callback) {
  if (typeof options === 'function') {
    callback = options;
    options = {};
  }

  const dir = path.dirname(file);

  pathExists(dir, (err, itDoes) => {
    if (err) return callback(err);
    if (itDoes) return jsonFile.writeJson(file, data, options, callback);

    mkdir.mkdirs(dir, err => {
      if (err) return callback(err);
      jsonFile.writeJson(file, data, options, callback);
    });
  });
}

module.exports = outputJson;

/***/ }),
/* 120 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const fs = __webpack_require__(5);
const path = __webpack_require__(0);
const mkdir = __webpack_require__(7);
const jsonFile = __webpack_require__(30);

function outputJsonSync(file, data, options) {
  const dir = path.dirname(file);

  if (!fs.existsSync(dir)) {
    mkdir.mkdirsSync(dir);
  }

  jsonFile.writeJsonSync(file, data, options);
}

module.exports = outputJsonSync;

/***/ }),
/* 121 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// most of this code was written by Andrew Kelley
// licensed under the BSD license: see
// https://github.com/andrewrk/node-mv/blob/master/package.json

// this needs a cleanup

const u = __webpack_require__(6).fromCallback;
const fs = __webpack_require__(5);
const copy = __webpack_require__(47);
const path = __webpack_require__(0);
const remove = __webpack_require__(24).remove;
const mkdirp = __webpack_require__(7).mkdirs;

function move(src, dest, options, callback) {
  if (typeof options === 'function') {
    callback = options;
    options = {};
  }

  const overwrite = options.overwrite || options.clobber || false;

  isSrcSubdir(src, dest, (err, itIs) => {
    if (err) return callback(err);
    if (itIs) return callback(new Error(`Cannot move '${src}' to a subdirectory of itself, '${dest}'.`));
    mkdirp(path.dirname(dest), err => {
      if (err) return callback(err);
      doRename();
    });
  });

  function doRename() {
    if (path.resolve(src) === path.resolve(dest)) {
      fs.access(src, callback);
    } else if (overwrite) {
      fs.rename(src, dest, err => {
        if (!err) return callback();

        if (err.code === 'ENOTEMPTY' || err.code === 'EEXIST') {
          remove(dest, err => {
            if (err) return callback(err);
            options.overwrite = false; // just overwriteed it, no need to do it again
            move(src, dest, options, callback);
          });
          return;
        }

        // weird Windows shit
        if (err.code === 'EPERM') {
          setTimeout(() => {
            remove(dest, err => {
              if (err) return callback(err);
              options.overwrite = false;
              move(src, dest, options, callback);
            });
          }, 200);
          return;
        }

        if (err.code !== 'EXDEV') return callback(err);
        moveAcrossDevice(src, dest, overwrite, callback);
      });
    } else {
      fs.link(src, dest, err => {
        if (err) {
          if (err.code === 'EXDEV' || err.code === 'EISDIR' || err.code === 'EPERM' || err.code === 'ENOTSUP') {
            return moveAcrossDevice(src, dest, overwrite, callback);
          }
          return callback(err);
        }
        return fs.unlink(src, callback);
      });
    }
  }
}

function moveAcrossDevice(src, dest, overwrite, callback) {
  fs.stat(src, (err, stat) => {
    if (err) return callback(err);

    if (stat.isDirectory()) {
      moveDirAcrossDevice(src, dest, overwrite, callback);
    } else {
      moveFileAcrossDevice(src, dest, overwrite, callback);
    }
  });
}

function moveFileAcrossDevice(src, dest, overwrite, callback) {
  const flags = overwrite ? 'w' : 'wx';
  const ins = fs.createReadStream(src);
  const outs = fs.createWriteStream(dest, { flags });

  ins.on('error', err => {
    ins.destroy();
    outs.destroy();
    outs.removeListener('close', onClose);

    // may want to create a directory but `out` line above
    // creates an empty file for us: See #108
    // don't care about error here
    fs.unlink(dest, () => {
      // note: `err` here is from the input stream errror
      if (err.code === 'EISDIR' || err.code === 'EPERM') {
        moveDirAcrossDevice(src, dest, overwrite, callback);
      } else {
        callback(err);
      }
    });
  });

  outs.on('error', err => {
    ins.destroy();
    outs.destroy();
    outs.removeListener('close', onClose);
    callback(err);
  });

  outs.once('close', onClose);
  ins.pipe(outs);

  function onClose() {
    fs.unlink(src, callback);
  }
}

function moveDirAcrossDevice(src, dest, overwrite, callback) {
  const options = {
    overwrite: false
  };

  if (overwrite) {
    remove(dest, err => {
      if (err) return callback(err);
      startCopy();
    });
  } else {
    startCopy();
  }

  function startCopy() {
    copy(src, dest, options, err => {
      if (err) return callback(err);
      remove(src, callback);
    });
  }
}

// return true if dest is a subdir of src, otherwise false.
// extract dest base dir and check if that is the same as src basename
function isSrcSubdir(src, dest, cb) {
  fs.stat(src, (err, st) => {
    if (err) return cb(err);
    if (st.isDirectory()) {
      const baseDir = dest.split(path.dirname(src) + path.sep)[1];
      if (baseDir) {
        const destBasename = baseDir.split(path.sep)[0];
        if (destBasename) return cb(null, src !== dest && dest.indexOf(src) > -1 && destBasename === path.basename(src));
        return cb(null, false);
      }
      return cb(null, false);
    }
    return cb(null, false);
  });
}

module.exports = {
  move: u(move)
};

/***/ }),
/* 122 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const fs = __webpack_require__(5);
const path = __webpack_require__(0);
const copySync = __webpack_require__(50).copySync;
const removeSync = __webpack_require__(24).removeSync;
const mkdirpSync = __webpack_require__(7).mkdirsSync;
const buffer = __webpack_require__(51);

function moveSync(src, dest, options) {
  options = options || {};
  const overwrite = options.overwrite || options.clobber || false;

  src = path.resolve(src);
  dest = path.resolve(dest);

  if (src === dest) return fs.accessSync(src);

  if (isSrcSubdir(src, dest)) throw new Error(`Cannot move '${src}' into itself '${dest}'.`);

  mkdirpSync(path.dirname(dest));
  tryRenameSync();

  function tryRenameSync() {
    if (overwrite) {
      try {
        return fs.renameSync(src, dest);
      } catch (err) {
        if (err.code === 'ENOTEMPTY' || err.code === 'EEXIST' || err.code === 'EPERM') {
          removeSync(dest);
          options.overwrite = false; // just overwriteed it, no need to do it again
          return moveSync(src, dest, options);
        }

        if (err.code !== 'EXDEV') throw err;
        return moveSyncAcrossDevice(src, dest, overwrite);
      }
    } else {
      try {
        fs.linkSync(src, dest);
        return fs.unlinkSync(src);
      } catch (err) {
        if (err.code === 'EXDEV' || err.code === 'EISDIR' || err.code === 'EPERM' || err.code === 'ENOTSUP') {
          return moveSyncAcrossDevice(src, dest, overwrite);
        }
        throw err;
      }
    }
  }
}

function moveSyncAcrossDevice(src, dest, overwrite) {
  const stat = fs.statSync(src);

  if (stat.isDirectory()) {
    return moveDirSyncAcrossDevice(src, dest, overwrite);
  } else {
    return moveFileSyncAcrossDevice(src, dest, overwrite);
  }
}

function moveFileSyncAcrossDevice(src, dest, overwrite) {
  const BUF_LENGTH = 64 * 1024;
  const _buff = buffer(BUF_LENGTH);

  const flags = overwrite ? 'w' : 'wx';

  const fdr = fs.openSync(src, 'r');
  const stat = fs.fstatSync(fdr);
  const fdw = fs.openSync(dest, flags, stat.mode);
  let bytesRead = 1;
  let pos = 0;

  while (bytesRead > 0) {
    bytesRead = fs.readSync(fdr, _buff, 0, BUF_LENGTH, pos);
    fs.writeSync(fdw, _buff, 0, bytesRead);
    pos += bytesRead;
  }

  fs.closeSync(fdr);
  fs.closeSync(fdw);
  return fs.unlinkSync(src);
}

function moveDirSyncAcrossDevice(src, dest, overwrite) {
  const options = {
    overwrite: false
  };

  if (overwrite) {
    removeSync(dest);
    tryCopySync();
  } else {
    tryCopySync();
  }

  function tryCopySync() {
    copySync(src, dest, options);
    return removeSync(src);
  }
}

// return true if dest is a subdir of src, otherwise false.
// extract dest base dir and check if that is the same as src basename
function isSrcSubdir(src, dest) {
  try {
    return fs.statSync(src).isDirectory() && src !== dest && dest.indexOf(src) > -1 && dest.split(path.dirname(src) + path.sep)[1].split(path.sep)[0] === path.basename(src);
  } catch (e) {
    return false;
  }
}

module.exports = {
  moveSync
};

/***/ }),
/* 123 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const u = __webpack_require__(6).fromCallback;
const fs = __webpack_require__(12);
const path = __webpack_require__(0);
const mkdir = __webpack_require__(7);
const remove = __webpack_require__(24);

const emptyDir = u(function emptyDir(dir, callback) {
  callback = callback || function () {};
  fs.readdir(dir, (err, items) => {
    if (err) return mkdir.mkdirs(dir, callback);

    items = items.map(item => path.join(dir, item));

    deleteItem();

    function deleteItem() {
      const item = items.pop();
      if (!item) return callback();
      remove.remove(item, err => {
        if (err) return callback(err);
        deleteItem();
      });
    }
  });
});

function emptyDirSync(dir) {
  let items;
  try {
    items = fs.readdirSync(dir);
  } catch (err) {
    return mkdir.mkdirsSync(dir);
  }

  items.forEach(item => {
    item = path.join(dir, item);
    remove.removeSync(item);
  });
}

module.exports = {
  emptyDirSync,
  emptydirSync: emptyDirSync,
  emptyDir,
  emptydir: emptyDir
};

/***/ }),
/* 124 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const file = __webpack_require__(125);
const link = __webpack_require__(126);
const symlink = __webpack_require__(127);

module.exports = {
  // file
  createFile: file.createFile,
  createFileSync: file.createFileSync,
  ensureFile: file.createFile,
  ensureFileSync: file.createFileSync,
  // link
  createLink: link.createLink,
  createLinkSync: link.createLinkSync,
  ensureLink: link.createLink,
  ensureLinkSync: link.createLinkSync,
  // symlink
  createSymlink: symlink.createSymlink,
  createSymlinkSync: symlink.createSymlinkSync,
  ensureSymlink: symlink.createSymlink,
  ensureSymlinkSync: symlink.createSymlinkSync
};

/***/ }),
/* 125 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const u = __webpack_require__(6).fromCallback;
const path = __webpack_require__(0);
const fs = __webpack_require__(5);
const mkdir = __webpack_require__(7);
const pathExists = __webpack_require__(13).pathExists;

function createFile(file, callback) {
  function makeFile() {
    fs.writeFile(file, '', err => {
      if (err) return callback(err);
      callback();
    });
  }

  fs.stat(file, (err, stats) => {
    // eslint-disable-line handle-callback-err
    if (!err && stats.isFile()) return callback();
    const dir = path.dirname(file);
    pathExists(dir, (err, dirExists) => {
      if (err) return callback(err);
      if (dirExists) return makeFile();
      mkdir.mkdirs(dir, err => {
        if (err) return callback(err);
        makeFile();
      });
    });
  });
}

function createFileSync(file) {
  let stats;
  try {
    stats = fs.statSync(file);
  } catch (e) {}
  if (stats && stats.isFile()) return;

  const dir = path.dirname(file);
  if (!fs.existsSync(dir)) {
    mkdir.mkdirsSync(dir);
  }

  fs.writeFileSync(file, '');
}

module.exports = {
  createFile: u(createFile),
  createFileSync
};

/***/ }),
/* 126 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const u = __webpack_require__(6).fromCallback;
const path = __webpack_require__(0);
const fs = __webpack_require__(5);
const mkdir = __webpack_require__(7);
const pathExists = __webpack_require__(13).pathExists;

function createLink(srcpath, dstpath, callback) {
  function makeLink(srcpath, dstpath) {
    fs.link(srcpath, dstpath, err => {
      if (err) return callback(err);
      callback(null);
    });
  }

  pathExists(dstpath, (err, destinationExists) => {
    if (err) return callback(err);
    if (destinationExists) return callback(null);
    fs.lstat(srcpath, (err, stat) => {
      if (err) {
        err.message = err.message.replace('lstat', 'ensureLink');
        return callback(err);
      }

      const dir = path.dirname(dstpath);
      pathExists(dir, (err, dirExists) => {
        if (err) return callback(err);
        if (dirExists) return makeLink(srcpath, dstpath);
        mkdir.mkdirs(dir, err => {
          if (err) return callback(err);
          makeLink(srcpath, dstpath);
        });
      });
    });
  });
}

function createLinkSync(srcpath, dstpath, callback) {
  const destinationExists = fs.existsSync(dstpath);
  if (destinationExists) return undefined;

  try {
    fs.lstatSync(srcpath);
  } catch (err) {
    err.message = err.message.replace('lstat', 'ensureLink');
    throw err;
  }

  const dir = path.dirname(dstpath);
  const dirExists = fs.existsSync(dir);
  if (dirExists) return fs.linkSync(srcpath, dstpath);
  mkdir.mkdirsSync(dir);

  return fs.linkSync(srcpath, dstpath);
}

module.exports = {
  createLink: u(createLink),
  createLinkSync
};

/***/ }),
/* 127 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const u = __webpack_require__(6).fromCallback;
const path = __webpack_require__(0);
const fs = __webpack_require__(5);
const _mkdirs = __webpack_require__(7);
const mkdirs = _mkdirs.mkdirs;
const mkdirsSync = _mkdirs.mkdirsSync;

const _symlinkPaths = __webpack_require__(128);
const symlinkPaths = _symlinkPaths.symlinkPaths;
const symlinkPathsSync = _symlinkPaths.symlinkPathsSync;

const _symlinkType = __webpack_require__(129);
const symlinkType = _symlinkType.symlinkType;
const symlinkTypeSync = _symlinkType.symlinkTypeSync;

const pathExists = __webpack_require__(13).pathExists;

function createSymlink(srcpath, dstpath, type, callback) {
  callback = typeof type === 'function' ? type : callback;
  type = typeof type === 'function' ? false : type;

  pathExists(dstpath, (err, destinationExists) => {
    if (err) return callback(err);
    if (destinationExists) return callback(null);
    symlinkPaths(srcpath, dstpath, (err, relative) => {
      if (err) return callback(err);
      srcpath = relative.toDst;
      symlinkType(relative.toCwd, type, (err, type) => {
        if (err) return callback(err);
        const dir = path.dirname(dstpath);
        pathExists(dir, (err, dirExists) => {
          if (err) return callback(err);
          if (dirExists) return fs.symlink(srcpath, dstpath, type, callback);
          mkdirs(dir, err => {
            if (err) return callback(err);
            fs.symlink(srcpath, dstpath, type, callback);
          });
        });
      });
    });
  });
}

function createSymlinkSync(srcpath, dstpath, type, callback) {
  callback = typeof type === 'function' ? type : callback;
  type = typeof type === 'function' ? false : type;

  const destinationExists = fs.existsSync(dstpath);
  if (destinationExists) return undefined;

  const relative = symlinkPathsSync(srcpath, dstpath);
  srcpath = relative.toDst;
  type = symlinkTypeSync(relative.toCwd, type);
  const dir = path.dirname(dstpath);
  const exists = fs.existsSync(dir);
  if (exists) return fs.symlinkSync(srcpath, dstpath, type);
  mkdirsSync(dir);
  return fs.symlinkSync(srcpath, dstpath, type);
}

module.exports = {
  createSymlink: u(createSymlink),
  createSymlinkSync
};

/***/ }),
/* 128 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const path = __webpack_require__(0);
const fs = __webpack_require__(5);
const pathExists = __webpack_require__(13).pathExists;

/**
 * Function that returns two types of paths, one relative to symlink, and one
 * relative to the current working directory. Checks if path is absolute or
 * relative. If the path is relative, this function checks if the path is
 * relative to symlink or relative to current working directory. This is an
 * initiative to find a smarter `srcpath` to supply when building symlinks.
 * This allows you to determine which path to use out of one of three possible
 * types of source paths. The first is an absolute path. This is detected by
 * `path.isAbsolute()`. When an absolute path is provided, it is checked to
 * see if it exists. If it does it's used, if not an error is returned
 * (callback)/ thrown (sync). The other two options for `srcpath` are a
 * relative url. By default Node's `fs.symlink` works by creating a symlink
 * using `dstpath` and expects the `srcpath` to be relative to the newly
 * created symlink. If you provide a `srcpath` that does not exist on the file
 * system it results in a broken symlink. To minimize this, the function
 * checks to see if the 'relative to symlink' source file exists, and if it
 * does it will use it. If it does not, it checks if there's a file that
 * exists that is relative to the current working directory, if does its used.
 * This preserves the expectations of the original fs.symlink spec and adds
 * the ability to pass in `relative to current working direcotry` paths.
 */

function symlinkPaths(srcpath, dstpath, callback) {
  if (path.isAbsolute(srcpath)) {
    return fs.lstat(srcpath, (err, stat) => {
      if (err) {
        err.message = err.message.replace('lstat', 'ensureSymlink');
        return callback(err);
      }
      return callback(null, {
        'toCwd': srcpath,
        'toDst': srcpath
      });
    });
  } else {
    const dstdir = path.dirname(dstpath);
    const relativeToDst = path.join(dstdir, srcpath);
    return pathExists(relativeToDst, (err, exists) => {
      if (err) return callback(err);
      if (exists) {
        return callback(null, {
          'toCwd': relativeToDst,
          'toDst': srcpath
        });
      } else {
        return fs.lstat(srcpath, (err, stat) => {
          if (err) {
            err.message = err.message.replace('lstat', 'ensureSymlink');
            return callback(err);
          }
          return callback(null, {
            'toCwd': srcpath,
            'toDst': path.relative(dstdir, srcpath)
          });
        });
      }
    });
  }
}

function symlinkPathsSync(srcpath, dstpath) {
  let exists;
  if (path.isAbsolute(srcpath)) {
    exists = fs.existsSync(srcpath);
    if (!exists) throw new Error('absolute srcpath does not exist');
    return {
      'toCwd': srcpath,
      'toDst': srcpath
    };
  } else {
    const dstdir = path.dirname(dstpath);
    const relativeToDst = path.join(dstdir, srcpath);
    exists = fs.existsSync(relativeToDst);
    if (exists) {
      return {
        'toCwd': relativeToDst,
        'toDst': srcpath
      };
    } else {
      exists = fs.existsSync(srcpath);
      if (!exists) throw new Error('relative srcpath does not exist');
      return {
        'toCwd': srcpath,
        'toDst': path.relative(dstdir, srcpath)
      };
    }
  }
}

module.exports = {
  symlinkPaths,
  symlinkPathsSync
};

/***/ }),
/* 129 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const fs = __webpack_require__(5);

function symlinkType(srcpath, type, callback) {
  callback = typeof type === 'function' ? type : callback;
  type = typeof type === 'function' ? false : type;
  if (type) return callback(null, type);
  fs.lstat(srcpath, (err, stats) => {
    if (err) return callback(null, 'file');
    type = stats && stats.isDirectory() ? 'dir' : 'file';
    callback(null, type);
  });
}

function symlinkTypeSync(srcpath, type) {
  let stats;

  if (type) return type;
  try {
    stats = fs.lstatSync(srcpath);
  } catch (e) {
    return 'file';
  }
  return stats && stats.isDirectory() ? 'dir' : 'file';
}

module.exports = {
  symlinkType,
  symlinkTypeSync
};

/***/ }),
/* 130 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const u = __webpack_require__(6).fromCallback;
const fs = __webpack_require__(5);
const path = __webpack_require__(0);
const mkdir = __webpack_require__(7);
const pathExists = __webpack_require__(13).pathExists;

function outputFile(file, data, encoding, callback) {
  if (typeof encoding === 'function') {
    callback = encoding;
    encoding = 'utf8';
  }

  const dir = path.dirname(file);
  pathExists(dir, (err, itDoes) => {
    if (err) return callback(err);
    if (itDoes) return fs.writeFile(file, data, encoding, callback);

    mkdir.mkdirs(dir, err => {
      if (err) return callback(err);

      fs.writeFile(file, data, encoding, callback);
    });
  });
}

function outputFileSync(file, data, encoding) {
  const dir = path.dirname(file);
  if (fs.existsSync(dir)) {
    return fs.writeFileSync.apply(fs, arguments);
  }
  mkdir.mkdirsSync(dir);
  fs.writeFileSync.apply(fs, arguments);
}

module.exports = {
  outputFile: u(outputFile),
  outputFileSync
};

/***/ }),
/* 131 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.githubUrl = githubUrl;
exports.getS3LikeProviderBaseUrl = getS3LikeProviderBaseUrl;
/** @private */
function githubUrl(options, defaultHost = "github.com") {
    return `${options.protocol || "https"}://${options.host || defaultHost}`;
}
function getS3LikeProviderBaseUrl(configuration) {
    const provider = configuration.provider;
    if (provider === "s3") {
        return s3Url(configuration);
    }
    if (provider === "spaces") {
        return spacesUrl(configuration);
    }
    throw new Error(`Not supported provider: ${provider}`);
}
function s3Url(options) {
    let url;
    if (options.endpoint != null) {
        url = `${options.endpoint}/${options.bucket}`;
    } else {
        if (!options.bucket.includes(".")) {
            if (options.region === "cn-north-1") {
                url = `https://${options.bucket}.s3.${options.region}.amazonaws.com.cn`;
            } else {
                url = `https://${options.bucket}.s3.amazonaws.com`;
            }
        } else {
            if (options.region == null) {
                throw new Error(`Bucket name "${options.bucket}" includes a dot, but S3 region is missing`);
            }
            // special case, see http://docs.aws.amazon.com/AmazonS3/latest/dev/UsingBucket.html#access-bucket-intro
            url = options.region === "us-east-1" ? `https://s3.amazonaws.com/${options.bucket}` : `https://s3-${options.region}.amazonaws.com/${options.bucket}`;
        }
    }
    if (options.path != null) {
        url += `/${options.path}`;
    }
    return url;
}
function spacesUrl(options) {
    if (options.name == null) {
        throw new Error(`name is missing`);
    }
    if (options.region == null) {
        throw new Error(`region is missing`);
    }
    let url = `https://${options.name}.${options.region}.digitaloceanspaces.com`;
    if (options.path != null) {
        url += `/${options.path}`;
    }
    return url;
}
//# sourceMappingURL=publishOptions.js.map

/***/ }),
/* 132 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.parseDn = parseDn;
function parseDn(seq) {
    let quoted = false;
    let key = null;
    let token = "";
    let nextNonSpace = 0;
    seq = seq.trim();
    const result = new Map();
    for (let i = 0; i <= seq.length; i++) {
        if (i === seq.length) {
            if (key !== null) {
                result.set(key, token);
            }
            break;
        }
        const ch = seq[i];
        if (quoted) {
            if (ch === '"') {
                quoted = false;
                continue;
            }
        } else {
            if (ch === '"') {
                quoted = true;
                continue;
            }
            if (ch === "\\") {
                i++;
                const ord = parseInt(seq.slice(i, i + 2), 16);
                if (Number.isNaN(ord)) {
                    token += seq[i];
                } else {
                    i++;
                    token += String.fromCharCode(ord);
                }
                continue;
            }
            if (key === null && ch === "=") {
                key = token;
                token = "";
                continue;
            }
            if (ch === "," || ch === ";" || ch === "+") {
                if (key !== null) {
                    result.set(key, token);
                }
                key = null;
                token = "";
                continue;
            }
        }
        if (ch === " " && !quoted) {
            if (token.length === 0) {
                continue;
            }
            if (i > nextNonSpace) {
                let j = i;
                while (seq[j] === " ") {
                    j++;
                }
                nextNonSpace = j;
            }
            if (nextNonSpace >= seq.length || seq[nextNonSpace] === "," || seq[nextNonSpace] === ";" || key === null && seq[nextNonSpace] === "=" || key !== null && seq[nextNonSpace] === "+") {
                i = nextNonSpace - 1;
                continue;
            }
        }
        token += ch;
    }
    return result;
}
//# sourceMappingURL=rfc2253Parser.js.map

/***/ }),
/* 133 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.nil = exports.UUID = undefined;

var _crypto;

function _load_crypto() {
    return _crypto = __webpack_require__(28);
}

var _index;

function _load_index() {
    return _index = __webpack_require__(3);
}

const invalidName = "options.name must be either a string or a Buffer";
const moreThan10000 = "can not generate more than 10000 UUIDs per second";
// Node ID according to rfc4122#section-4.5
const randomHost = (0, (_crypto || _load_crypto()).randomBytes)(16);
randomHost[0] = randomHost[0] | 0x01;
// randomize clockSeq initially, as per rfc4122#section-4.1.5
const seed = (0, (_crypto || _load_crypto()).randomBytes)(2);
let clockSeq = (seed[0] | seed[1] << 8) & 0x3fff;
// clock values
let lastMTime = 0;
let lastNTime = 0;
// lookup table hex to byte
const hex2byte = {};
// lookup table byte to hex
const byte2hex = [];
// populate lookup tables
for (let i = 0; i < 256; i++) {
    const hex = (i + 0x100).toString(16).substr(1);
    hex2byte[hex] = i;
    byte2hex[i] = hex;
}
// UUID class
class UUID {
    constructor(uuid) {
        const check = UUID.check(uuid);
        if (!check) {
            throw new Error("not a UUID");
        }
        this.version = check.version;
        if (check.format === "ascii") {
            this.ascii = uuid;
        } else {
            this.binary = uuid;
        }
    }
    static v1() {
        return uuidTimeBased(randomHost);
    }
    static v5(name, namespace) {
        return uuidNamed(name, "sha1", 0x50, namespace);
    }
    toString() {
        if (this.ascii == null) {
            this.ascii = stringify(this.binary);
        }
        return this.ascii;
    }
    toBuffer() {
        if (this.binary == null) {
            this.binary = UUID.parse(this.ascii);
        }
        return Buffer.from(this.binary);
    }
    inspect() {
        return `UUID v${this.version} ${this.toString()}`;
    }
    static check(uuid, offset = 0) {
        if (typeof uuid === "string") {
            uuid = uuid.toLowerCase();
            if (!/^[a-f0-9]{8}(\-[a-f0-9]{4}){3}\-([a-f0-9]{12})$/.test(uuid)) {
                return false;
            }
            if (uuid === "00000000-0000-0000-0000-000000000000") {
                return { version: undefined, variant: "nil", format: "ascii" };
            }
            return {
                version: (hex2byte[uuid[14] + uuid[15]] & 0xf0) >> 4,
                variant: getVariant((hex2byte[uuid[19] + uuid[20]] & 0xe0) >> 5),
                format: "ascii"
            };
        }
        if (Buffer.isBuffer(uuid)) {
            if (uuid.length < offset + 16) {
                return false;
            }
            let i = 0;
            for (; i < 16; i++) {
                if (uuid[offset + i] !== 0) {
                    break;
                }
            }
            if (i === 16) {
                return { version: undefined, variant: "nil", format: "binary" };
            }
            return {
                version: (uuid[offset + 6] & 0xf0) >> 4,
                variant: getVariant((uuid[offset + 8] & 0xe0) >> 5),
                format: "binary"
            };
        }
        throw (0, (_index || _load_index()).newError)("Unknown type of uuid", "ERR_UNKNOWN_UUID_TYPE");
    }
    // read stringified uuid into a Buffer
    static parse(input) {
        const buffer = Buffer.allocUnsafe(16);
        let j = 0;
        for (let i = 0; i < 16; i++) {
            buffer[i] = hex2byte[input[j++] + input[j++]];
            if (i === 3 || i === 5 || i === 7 || i === 9) {
                j += 1;
            }
        }
        return buffer;
    }
}
exports.UUID = UUID; // from rfc4122#appendix-C

UUID.URL = new UUID("6ba7b811-9dad-11d1-80b4-00c04fd430c8");
UUID.OID = UUID.parse("6ba7b812-9dad-11d1-80b4-00c04fd430c8");
// according to rfc4122#section-4.1.1
function getVariant(bits) {
    switch (bits) {
        case 0:
        case 1:
        case 3:
            return "ncs";
        case 4:
        case 5:
            return "rfc4122";
        case 6:
            return "microsoft";
        default:
            return "future";
    }
}
var UuidEncoding;
(function (UuidEncoding) {
    UuidEncoding[UuidEncoding["ASCII"] = 0] = "ASCII";
    UuidEncoding[UuidEncoding["BINARY"] = 1] = "BINARY";
    UuidEncoding[UuidEncoding["OBJECT"] = 2] = "OBJECT";
})(UuidEncoding || (UuidEncoding = {}));
// v1
function uuidTimeBased(nodeId, encoding = UuidEncoding.ASCII) {
    let mTime = Date.now();
    let nTime = lastNTime + 1;
    const delta = mTime - lastMTime + (nTime - lastNTime) / 10000;
    if (delta < 0) {
        clockSeq = clockSeq + 1 & 0x3fff;
        nTime = 0;
    } else if (mTime > lastMTime) {
        nTime = 0;
    } else if (nTime >= 10000) {
        return moreThan10000;
    }
    lastMTime = mTime;
    lastNTime = nTime;
    // unix timestamp to gregorian epoch as per rfc4122#section-4.5
    mTime += 12219292800000;
    const buffer = Buffer.allocUnsafe(16);
    const myClockSeq = clockSeq;
    const timeLow = ((mTime & 0xfffffff) * 10000 + nTime) % 0x100000000;
    const timeHigh = mTime / 0x100000000 * 10000 & 0xfffffff;
    buffer[0] = timeLow >>> 24 & 0xff;
    buffer[1] = timeLow >>> 16 & 0xff;
    buffer[2] = timeLow >>> 8 & 0xff;
    buffer[3] = timeLow & 0xff;
    buffer[4] = timeHigh >>> 8 & 0xff;
    buffer[5] = timeHigh & 0xff;
    buffer[6] = timeHigh >>> 24 & 0x0f | 0x10;
    buffer[7] = timeHigh >>> 16 & 0x3f | 0x80;
    buffer[8] = myClockSeq >>> 8;
    buffer[9] = myClockSeq & 0xff;
    let result;
    switch (encoding) {
        case UuidEncoding.BINARY:
            buffer[10] = nodeId[0];
            buffer[11] = nodeId[1];
            buffer[12] = nodeId[2];
            buffer[13] = nodeId[3];
            buffer[14] = nodeId[4];
            buffer[15] = nodeId[5];
            result = buffer;
            break;
        case UuidEncoding.OBJECT:
            buffer[10] = nodeId[0];
            buffer[11] = nodeId[1];
            buffer[12] = nodeId[2];
            buffer[13] = nodeId[3];
            buffer[14] = nodeId[4];
            buffer[15] = nodeId[5];
            result = new UUID(buffer);
            break;
        default:
            result = byte2hex[buffer[0]] + byte2hex[buffer[1]] + byte2hex[buffer[2]] + byte2hex[buffer[3]] + "-" + byte2hex[buffer[4]] + byte2hex[buffer[5]] + "-" + byte2hex[buffer[6]] + byte2hex[buffer[7]] + "-" + byte2hex[buffer[8]] + byte2hex[buffer[9]] + "-" + byte2hex[nodeId[0]] + byte2hex[nodeId[1]] + byte2hex[nodeId[2]] + byte2hex[nodeId[3]] + byte2hex[nodeId[4]] + byte2hex[nodeId[5]];
            break;
    }
    return result;
}
// v3 + v5
function uuidNamed(name, hashMethod, version, namespace, encoding = UuidEncoding.ASCII) {
    const hash = (0, (_crypto || _load_crypto()).createHash)(hashMethod);
    const nameIsNotAString = typeof name !== "string";
    if (nameIsNotAString && !Buffer.isBuffer(name)) {
        throw (0, (_index || _load_index()).newError)(invalidName, "ERR_INVALID_UUID_NAME");
    }
    hash.update(namespace);
    hash.update(name, nameIsNotAString ? "latin1" : "utf8");
    const buffer = hash.digest();
    let result;
    switch (encoding) {
        case UuidEncoding.BINARY:
            buffer[6] = buffer[6] & 0x0f | version;
            buffer[8] = buffer[8] & 0x3f | 0x80;
            result = buffer;
            break;
        case UuidEncoding.OBJECT:
            buffer[6] = buffer[6] & 0x0f | version;
            buffer[8] = buffer[8] & 0x3f | 0x80;
            result = new UUID(buffer);
            break;
        default:
            result = byte2hex[buffer[0]] + byte2hex[buffer[1]] + byte2hex[buffer[2]] + byte2hex[buffer[3]] + "-" + byte2hex[buffer[4]] + byte2hex[buffer[5]] + "-" + byte2hex[buffer[6] & 0x0f | version] + byte2hex[buffer[7]] + "-" + byte2hex[buffer[8] & 0x3f | 0x80] + byte2hex[buffer[9]] + "-" + byte2hex[buffer[10]] + byte2hex[buffer[11]] + byte2hex[buffer[12]] + byte2hex[buffer[13]] + byte2hex[buffer[14]] + byte2hex[buffer[15]];
            break;
    }
    return result;
}
function stringify(buffer) {
    return byte2hex[buffer[0]] + byte2hex[buffer[1]] + byte2hex[buffer[2]] + byte2hex[buffer[3]] + "-" + byte2hex[buffer[4]] + byte2hex[buffer[5]] + "-" + byte2hex[buffer[6]] + byte2hex[buffer[7]] + "-" + byte2hex[buffer[8]] + byte2hex[buffer[9]] + "-" + byte2hex[buffer[10]] + byte2hex[buffer[11]] + byte2hex[buffer[12]] + byte2hex[buffer[13]] + byte2hex[buffer[14]] + byte2hex[buffer[15]];
}
// according to rfc4122#section-4.1.7
const nil = exports.nil = new UUID("00000000-0000-0000-0000-000000000000");
// UUID.v4 = uuidRandom
// UUID.v4fast = uuidRandomFast
// UUID.v3 = function(options, callback) {
//     return uuidNamed("md5", 0x30, options, callback)
// } 
//# sourceMappingURL=uuid.js.map

/***/ }),
/* 134 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.XElement = undefined;
exports.parseXml = parseXml;

var _sax;

function _load_sax() {
    return _sax = _interopRequireWildcard(__webpack_require__(135));
}

var _index;

function _load_index() {
    return _index = __webpack_require__(3);
}

function _interopRequireWildcard(obj) {
    if (obj && obj.__esModule) {
        return obj;
    } else {
        var newObj = {};if (obj != null) {
            for (var key in obj) {
                if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key];
            }
        }newObj.default = obj;return newObj;
    }
}

class XElement {
    constructor(name) {
        this.name = name;
        this.value = "";
        this.attributes = null;
        this.isCData = false;
        this.elements = null;
        if (!name) {
            throw (0, (_index || _load_index()).newError)("Element name cannot be empty", "ERR_XML_ELEMENT_NAME_EMPTY");
        }
        if (!isValidName(name)) {
            throw (0, (_index || _load_index()).newError)(`Invalid element name: ${name}`, "ERR_XML_ELEMENT_INVALID_NAME");
        }
    }
    attribute(name) {
        const result = this.attributes === null ? null : this.attributes[name];
        if (result == null) {
            throw (0, (_index || _load_index()).newError)(`No attribute "${name}"`, "ERR_XML_MISSED_ATTRIBUTE");
        }
        return result;
    }
    removeAttribute(name) {
        if (this.attributes !== null) {
            delete this.attributes[name];
        }
    }
    element(name, ignoreCase = false, errorIfMissed = null) {
        const result = this.elementOrNull(name, ignoreCase);
        if (result === null) {
            throw (0, (_index || _load_index()).newError)(errorIfMissed || `No element "${name}"`, "ERR_XML_MISSED_ELEMENT");
        }
        return result;
    }
    elementOrNull(name, ignoreCase = false) {
        if (this.elements === null) {
            return null;
        }
        for (const element of this.elements) {
            if (isNameEquals(element, name, ignoreCase)) {
                return element;
            }
        }
        return null;
    }
    getElements(name, ignoreCase = false) {
        if (this.elements === null) {
            return [];
        }
        return this.elements.filter(it => isNameEquals(it, name, ignoreCase));
    }
    elementValueOrEmpty(name, ignoreCase = false) {
        const element = this.elementOrNull(name, ignoreCase);
        return element === null ? "" : element.value;
    }
}
exports.XElement = XElement;
const NAME_REG_EXP = new RegExp(/^[A-Za-z_][:A-Za-z0-9_-]*$/i);
function isValidName(name) {
    return NAME_REG_EXP.test(name);
}
function isNameEquals(element, name, ignoreCase) {
    const elementName = element.name;
    return elementName === name || ignoreCase === true && elementName.length === name.length && elementName.toLowerCase() === name.toLowerCase();
}
function parseXml(data) {
    let rootElement = null;
    const parser = (_sax || _load_sax()).parser(true, {});
    const elements = [];
    parser.onopentag = saxElement => {
        const element = new XElement(saxElement.name);
        element.attributes = saxElement.attributes;
        if (rootElement === null) {
            rootElement = element;
        } else {
            const parent = elements[elements.length - 1];
            if (parent.elements == null) {
                parent.elements = [];
            }
            parent.elements.push(element);
        }
        elements.push(element);
    };
    parser.onclosetag = () => {
        elements.pop();
    };
    parser.ontext = text => {
        if (elements.length > 0) {
            elements[elements.length - 1].value = text;
        }
    };
    parser.oncdata = cdata => {
        const element = elements[elements.length - 1];
        element.value = cdata;
        element.isCData = true;
    };
    parser.onerror = err => {
        throw err;
    };
    parser.write(data);
    return rootElement;
}
//# sourceMappingURL=xml.js.map

/***/ }),
/* 135 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


;(function (sax) {
  // wrapper for non-node envs
  sax.parser = function (strict, opt) {
    return new SAXParser(strict, opt);
  };
  sax.SAXParser = SAXParser;
  sax.SAXStream = SAXStream;
  sax.createStream = createStream;

  // When we pass the MAX_BUFFER_LENGTH position, start checking for buffer overruns.
  // When we check, schedule the next check for MAX_BUFFER_LENGTH - (max(buffer lengths)),
  // since that's the earliest that a buffer overrun could occur.  This way, checks are
  // as rare as required, but as often as necessary to ensure never crossing this bound.
  // Furthermore, buffers are only tested at most once per write(), so passing a very
  // large string into write() might have undesirable effects, but this is manageable by
  // the caller, so it is assumed to be safe.  Thus, a call to write() may, in the extreme
  // edge case, result in creating at most one complete copy of the string passed in.
  // Set to Infinity to have unlimited buffers.
  sax.MAX_BUFFER_LENGTH = 64 * 1024;

  var buffers = ['comment', 'sgmlDecl', 'textNode', 'tagName', 'doctype', 'procInstName', 'procInstBody', 'entity', 'attribName', 'attribValue', 'cdata', 'script'];

  sax.EVENTS = ['text', 'processinginstruction', 'sgmldeclaration', 'doctype', 'comment', 'opentagstart', 'attribute', 'opentag', 'closetag', 'opencdata', 'cdata', 'closecdata', 'error', 'end', 'ready', 'script', 'opennamespace', 'closenamespace'];

  function SAXParser(strict, opt) {
    if (!(this instanceof SAXParser)) {
      return new SAXParser(strict, opt);
    }

    var parser = this;
    clearBuffers(parser);
    parser.q = parser.c = '';
    parser.bufferCheckPosition = sax.MAX_BUFFER_LENGTH;
    parser.opt = opt || {};
    parser.opt.lowercase = parser.opt.lowercase || parser.opt.lowercasetags;
    parser.looseCase = parser.opt.lowercase ? 'toLowerCase' : 'toUpperCase';
    parser.tags = [];
    parser.closed = parser.closedRoot = parser.sawRoot = false;
    parser.tag = parser.error = null;
    parser.strict = !!strict;
    parser.noscript = !!(strict || parser.opt.noscript);
    parser.state = S.BEGIN;
    parser.strictEntities = parser.opt.strictEntities;
    parser.ENTITIES = parser.strictEntities ? Object.create(sax.XML_ENTITIES) : Object.create(sax.ENTITIES);
    parser.attribList = [];

    // namespaces form a prototype chain.
    // it always points at the current tag,
    // which protos to its parent tag.
    if (parser.opt.xmlns) {
      parser.ns = Object.create(rootNS);
    }

    // mostly just for error reporting
    parser.trackPosition = parser.opt.position !== false;
    if (parser.trackPosition) {
      parser.position = parser.line = parser.column = 0;
    }
    emit(parser, 'onready');
  }

  if (!Object.create) {
    Object.create = function (o) {
      function F() {}
      F.prototype = o;
      var newf = new F();
      return newf;
    };
  }

  if (!Object.keys) {
    Object.keys = function (o) {
      var a = [];
      for (var i in o) if (o.hasOwnProperty(i)) a.push(i);
      return a;
    };
  }

  function checkBufferLength(parser) {
    var maxAllowed = Math.max(sax.MAX_BUFFER_LENGTH, 10);
    var maxActual = 0;
    for (var i = 0, l = buffers.length; i < l; i++) {
      var len = parser[buffers[i]].length;
      if (len > maxAllowed) {
        // Text/cdata nodes can get big, and since they're buffered,
        // we can get here under normal conditions.
        // Avoid issues by emitting the text node now,
        // so at least it won't get any bigger.
        switch (buffers[i]) {
          case 'textNode':
            closeText(parser);
            break;

          case 'cdata':
            emitNode(parser, 'oncdata', parser.cdata);
            parser.cdata = '';
            break;

          case 'script':
            emitNode(parser, 'onscript', parser.script);
            parser.script = '';
            break;

          default:
            error(parser, 'Max buffer length exceeded: ' + buffers[i]);
        }
      }
      maxActual = Math.max(maxActual, len);
    }
    // schedule the next check for the earliest possible buffer overrun.
    var m = sax.MAX_BUFFER_LENGTH - maxActual;
    parser.bufferCheckPosition = m + parser.position;
  }

  function clearBuffers(parser) {
    for (var i = 0, l = buffers.length; i < l; i++) {
      parser[buffers[i]] = '';
    }
  }

  function flushBuffers(parser) {
    closeText(parser);
    if (parser.cdata !== '') {
      emitNode(parser, 'oncdata', parser.cdata);
      parser.cdata = '';
    }
    if (parser.script !== '') {
      emitNode(parser, 'onscript', parser.script);
      parser.script = '';
    }
  }

  SAXParser.prototype = {
    end: function () {
      end(this);
    },
    write: write,
    resume: function () {
      this.error = null;return this;
    },
    close: function () {
      return this.write(null);
    },
    flush: function () {
      flushBuffers(this);
    }
  };

  var Stream;
  try {
    Stream = __webpack_require__(19).Stream;
  } catch (ex) {
    Stream = function () {};
  }

  var streamWraps = sax.EVENTS.filter(function (ev) {
    return ev !== 'error' && ev !== 'end';
  });

  function createStream(strict, opt) {
    return new SAXStream(strict, opt);
  }

  function SAXStream(strict, opt) {
    if (!(this instanceof SAXStream)) {
      return new SAXStream(strict, opt);
    }

    Stream.apply(this);

    this._parser = new SAXParser(strict, opt);
    this.writable = true;
    this.readable = true;

    var me = this;

    this._parser.onend = function () {
      me.emit('end');
    };

    this._parser.onerror = function (er) {
      me.emit('error', er);

      // if didn't throw, then means error was handled.
      // go ahead and clear error, so we can write again.
      me._parser.error = null;
    };

    this._decoder = null;

    streamWraps.forEach(function (ev) {
      Object.defineProperty(me, 'on' + ev, {
        get: function () {
          return me._parser['on' + ev];
        },
        set: function (h) {
          if (!h) {
            me.removeAllListeners(ev);
            me._parser['on' + ev] = h;
            return h;
          }
          me.on(ev, h);
        },
        enumerable: true,
        configurable: false
      });
    });
  }

  SAXStream.prototype = Object.create(Stream.prototype, {
    constructor: {
      value: SAXStream
    }
  });

  SAXStream.prototype.write = function (data) {
    if (typeof Buffer === 'function' && typeof Buffer.isBuffer === 'function' && Buffer.isBuffer(data)) {
      if (!this._decoder) {
        var SD = __webpack_require__(136).StringDecoder;
        this._decoder = new SD('utf8');
      }
      data = this._decoder.write(data);
    }

    this._parser.write(data.toString());
    this.emit('data', data);
    return true;
  };

  SAXStream.prototype.end = function (chunk) {
    if (chunk && chunk.length) {
      this.write(chunk);
    }
    this._parser.end();
    return true;
  };

  SAXStream.prototype.on = function (ev, handler) {
    var me = this;
    if (!me._parser['on' + ev] && streamWraps.indexOf(ev) !== -1) {
      me._parser['on' + ev] = function () {
        var args = arguments.length === 1 ? [arguments[0]] : Array.apply(null, arguments);
        args.splice(0, 0, ev);
        me.emit.apply(me, args);
      };
    }

    return Stream.prototype.on.call(me, ev, handler);
  };

  // this really needs to be replaced with character classes.
  // XML allows all manner of ridiculous numbers and digits.
  var CDATA = '[CDATA[';
  var DOCTYPE = 'DOCTYPE';
  var XML_NAMESPACE = 'http://www.w3.org/XML/1998/namespace';
  var XMLNS_NAMESPACE = 'http://www.w3.org/2000/xmlns/';
  var rootNS = { xml: XML_NAMESPACE, xmlns: XMLNS_NAMESPACE

    // http://www.w3.org/TR/REC-xml/#NT-NameStartChar
    // This implementation works on strings, a single character at a time
    // as such, it cannot ever support astral-plane characters (10000-EFFFF)
    // without a significant breaking change to either this  parser, or the
    // JavaScript language.  Implementation of an emoji-capable xml parser
    // is left as an exercise for the reader.
  };var nameStart = /[:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]/;

  var nameBody = /[:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\u00B7\u0300-\u036F\u203F-\u2040.\d-]/;

  var entityStart = /[#:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]/;
  var entityBody = /[#:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\u00B7\u0300-\u036F\u203F-\u2040.\d-]/;

  function isWhitespace(c) {
    return c === ' ' || c === '\n' || c === '\r' || c === '\t';
  }

  function isQuote(c) {
    return c === '"' || c === '\'';
  }

  function isAttribEnd(c) {
    return c === '>' || isWhitespace(c);
  }

  function isMatch(regex, c) {
    return regex.test(c);
  }

  function notMatch(regex, c) {
    return !isMatch(regex, c);
  }

  var S = 0;
  sax.STATE = {
    BEGIN: S++, // leading byte order mark or whitespace
    BEGIN_WHITESPACE: S++, // leading whitespace
    TEXT: S++, // general stuff
    TEXT_ENTITY: S++, // &amp and such.
    OPEN_WAKA: S++, // <
    SGML_DECL: S++, // <!BLARG
    SGML_DECL_QUOTED: S++, // <!BLARG foo "bar
    DOCTYPE: S++, // <!DOCTYPE
    DOCTYPE_QUOTED: S++, // <!DOCTYPE "//blah
    DOCTYPE_DTD: S++, // <!DOCTYPE "//blah" [ ...
    DOCTYPE_DTD_QUOTED: S++, // <!DOCTYPE "//blah" [ "foo
    COMMENT_STARTING: S++, // <!-
    COMMENT: S++, // <!--
    COMMENT_ENDING: S++, // <!-- blah -
    COMMENT_ENDED: S++, // <!-- blah --
    CDATA: S++, // <![CDATA[ something
    CDATA_ENDING: S++, // ]
    CDATA_ENDING_2: S++, // ]]
    PROC_INST: S++, // <?hi
    PROC_INST_BODY: S++, // <?hi there
    PROC_INST_ENDING: S++, // <?hi "there" ?
    OPEN_TAG: S++, // <strong
    OPEN_TAG_SLASH: S++, // <strong /
    ATTRIB: S++, // <a
    ATTRIB_NAME: S++, // <a foo
    ATTRIB_NAME_SAW_WHITE: S++, // <a foo _
    ATTRIB_VALUE: S++, // <a foo=
    ATTRIB_VALUE_QUOTED: S++, // <a foo="bar
    ATTRIB_VALUE_CLOSED: S++, // <a foo="bar"
    ATTRIB_VALUE_UNQUOTED: S++, // <a foo=bar
    ATTRIB_VALUE_ENTITY_Q: S++, // <foo bar="&quot;"
    ATTRIB_VALUE_ENTITY_U: S++, // <foo bar=&quot
    CLOSE_TAG: S++, // </a
    CLOSE_TAG_SAW_WHITE: S++, // </a   >
    SCRIPT: S++, // <script> ...
    SCRIPT_ENDING: S++ // <script> ... <
  };

  sax.XML_ENTITIES = {
    'amp': '&',
    'gt': '>',
    'lt': '<',
    'quot': '"',
    'apos': "'"
  };

  sax.ENTITIES = {
    'amp': '&',
    'gt': '>',
    'lt': '<',
    'quot': '"',
    'apos': "'",
    'AElig': 198,
    'Aacute': 193,
    'Acirc': 194,
    'Agrave': 192,
    'Aring': 197,
    'Atilde': 195,
    'Auml': 196,
    'Ccedil': 199,
    'ETH': 208,
    'Eacute': 201,
    'Ecirc': 202,
    'Egrave': 200,
    'Euml': 203,
    'Iacute': 205,
    'Icirc': 206,
    'Igrave': 204,
    'Iuml': 207,
    'Ntilde': 209,
    'Oacute': 211,
    'Ocirc': 212,
    'Ograve': 210,
    'Oslash': 216,
    'Otilde': 213,
    'Ouml': 214,
    'THORN': 222,
    'Uacute': 218,
    'Ucirc': 219,
    'Ugrave': 217,
    'Uuml': 220,
    'Yacute': 221,
    'aacute': 225,
    'acirc': 226,
    'aelig': 230,
    'agrave': 224,
    'aring': 229,
    'atilde': 227,
    'auml': 228,
    'ccedil': 231,
    'eacute': 233,
    'ecirc': 234,
    'egrave': 232,
    'eth': 240,
    'euml': 235,
    'iacute': 237,
    'icirc': 238,
    'igrave': 236,
    'iuml': 239,
    'ntilde': 241,
    'oacute': 243,
    'ocirc': 244,
    'ograve': 242,
    'oslash': 248,
    'otilde': 245,
    'ouml': 246,
    'szlig': 223,
    'thorn': 254,
    'uacute': 250,
    'ucirc': 251,
    'ugrave': 249,
    'uuml': 252,
    'yacute': 253,
    'yuml': 255,
    'copy': 169,
    'reg': 174,
    'nbsp': 160,
    'iexcl': 161,
    'cent': 162,
    'pound': 163,
    'curren': 164,
    'yen': 165,
    'brvbar': 166,
    'sect': 167,
    'uml': 168,
    'ordf': 170,
    'laquo': 171,
    'not': 172,
    'shy': 173,
    'macr': 175,
    'deg': 176,
    'plusmn': 177,
    'sup1': 185,
    'sup2': 178,
    'sup3': 179,
    'acute': 180,
    'micro': 181,
    'para': 182,
    'middot': 183,
    'cedil': 184,
    'ordm': 186,
    'raquo': 187,
    'frac14': 188,
    'frac12': 189,
    'frac34': 190,
    'iquest': 191,
    'times': 215,
    'divide': 247,
    'OElig': 338,
    'oelig': 339,
    'Scaron': 352,
    'scaron': 353,
    'Yuml': 376,
    'fnof': 402,
    'circ': 710,
    'tilde': 732,
    'Alpha': 913,
    'Beta': 914,
    'Gamma': 915,
    'Delta': 916,
    'Epsilon': 917,
    'Zeta': 918,
    'Eta': 919,
    'Theta': 920,
    'Iota': 921,
    'Kappa': 922,
    'Lambda': 923,
    'Mu': 924,
    'Nu': 925,
    'Xi': 926,
    'Omicron': 927,
    'Pi': 928,
    'Rho': 929,
    'Sigma': 931,
    'Tau': 932,
    'Upsilon': 933,
    'Phi': 934,
    'Chi': 935,
    'Psi': 936,
    'Omega': 937,
    'alpha': 945,
    'beta': 946,
    'gamma': 947,
    'delta': 948,
    'epsilon': 949,
    'zeta': 950,
    'eta': 951,
    'theta': 952,
    'iota': 953,
    'kappa': 954,
    'lambda': 955,
    'mu': 956,
    'nu': 957,
    'xi': 958,
    'omicron': 959,
    'pi': 960,
    'rho': 961,
    'sigmaf': 962,
    'sigma': 963,
    'tau': 964,
    'upsilon': 965,
    'phi': 966,
    'chi': 967,
    'psi': 968,
    'omega': 969,
    'thetasym': 977,
    'upsih': 978,
    'piv': 982,
    'ensp': 8194,
    'emsp': 8195,
    'thinsp': 8201,
    'zwnj': 8204,
    'zwj': 8205,
    'lrm': 8206,
    'rlm': 8207,
    'ndash': 8211,
    'mdash': 8212,
    'lsquo': 8216,
    'rsquo': 8217,
    'sbquo': 8218,
    'ldquo': 8220,
    'rdquo': 8221,
    'bdquo': 8222,
    'dagger': 8224,
    'Dagger': 8225,
    'bull': 8226,
    'hellip': 8230,
    'permil': 8240,
    'prime': 8242,
    'Prime': 8243,
    'lsaquo': 8249,
    'rsaquo': 8250,
    'oline': 8254,
    'frasl': 8260,
    'euro': 8364,
    'image': 8465,
    'weierp': 8472,
    'real': 8476,
    'trade': 8482,
    'alefsym': 8501,
    'larr': 8592,
    'uarr': 8593,
    'rarr': 8594,
    'darr': 8595,
    'harr': 8596,
    'crarr': 8629,
    'lArr': 8656,
    'uArr': 8657,
    'rArr': 8658,
    'dArr': 8659,
    'hArr': 8660,
    'forall': 8704,
    'part': 8706,
    'exist': 8707,
    'empty': 8709,
    'nabla': 8711,
    'isin': 8712,
    'notin': 8713,
    'ni': 8715,
    'prod': 8719,
    'sum': 8721,
    'minus': 8722,
    'lowast': 8727,
    'radic': 8730,
    'prop': 8733,
    'infin': 8734,
    'ang': 8736,
    'and': 8743,
    'or': 8744,
    'cap': 8745,
    'cup': 8746,
    'int': 8747,
    'there4': 8756,
    'sim': 8764,
    'cong': 8773,
    'asymp': 8776,
    'ne': 8800,
    'equiv': 8801,
    'le': 8804,
    'ge': 8805,
    'sub': 8834,
    'sup': 8835,
    'nsub': 8836,
    'sube': 8838,
    'supe': 8839,
    'oplus': 8853,
    'otimes': 8855,
    'perp': 8869,
    'sdot': 8901,
    'lceil': 8968,
    'rceil': 8969,
    'lfloor': 8970,
    'rfloor': 8971,
    'lang': 9001,
    'rang': 9002,
    'loz': 9674,
    'spades': 9824,
    'clubs': 9827,
    'hearts': 9829,
    'diams': 9830
  };

  Object.keys(sax.ENTITIES).forEach(function (key) {
    var e = sax.ENTITIES[key];
    var s = typeof e === 'number' ? String.fromCharCode(e) : e;
    sax.ENTITIES[key] = s;
  });

  for (var s in sax.STATE) {
    sax.STATE[sax.STATE[s]] = s;
  }

  // shorthand
  S = sax.STATE;

  function emit(parser, event, data) {
    parser[event] && parser[event](data);
  }

  function emitNode(parser, nodeType, data) {
    if (parser.textNode) closeText(parser);
    emit(parser, nodeType, data);
  }

  function closeText(parser) {
    parser.textNode = textopts(parser.opt, parser.textNode);
    if (parser.textNode) emit(parser, 'ontext', parser.textNode);
    parser.textNode = '';
  }

  function textopts(opt, text) {
    if (opt.trim) text = text.trim();
    if (opt.normalize) text = text.replace(/\s+/g, ' ');
    return text;
  }

  function error(parser, er) {
    closeText(parser);
    if (parser.trackPosition) {
      er += '\nLine: ' + parser.line + '\nColumn: ' + parser.column + '\nChar: ' + parser.c;
    }
    er = new Error(er);
    parser.error = er;
    emit(parser, 'onerror', er);
    return parser;
  }

  function end(parser) {
    if (parser.sawRoot && !parser.closedRoot) strictFail(parser, 'Unclosed root tag');
    if (parser.state !== S.BEGIN && parser.state !== S.BEGIN_WHITESPACE && parser.state !== S.TEXT) {
      error(parser, 'Unexpected end');
    }
    closeText(parser);
    parser.c = '';
    parser.closed = true;
    emit(parser, 'onend');
    SAXParser.call(parser, parser.strict, parser.opt);
    return parser;
  }

  function strictFail(parser, message) {
    if (typeof parser !== 'object' || !(parser instanceof SAXParser)) {
      throw new Error('bad call to strictFail');
    }
    if (parser.strict) {
      error(parser, message);
    }
  }

  function newTag(parser) {
    if (!parser.strict) parser.tagName = parser.tagName[parser.looseCase]();
    var parent = parser.tags[parser.tags.length - 1] || parser;
    var tag = parser.tag = { name: parser.tagName, attributes: {}

      // will be overridden if tag contails an xmlns="foo" or xmlns:foo="bar"
    };if (parser.opt.xmlns) {
      tag.ns = parent.ns;
    }
    parser.attribList.length = 0;
    emitNode(parser, 'onopentagstart', tag);
  }

  function qname(name, attribute) {
    var i = name.indexOf(':');
    var qualName = i < 0 ? ['', name] : name.split(':');
    var prefix = qualName[0];
    var local = qualName[1];

    // <x "xmlns"="http://foo">
    if (attribute && name === 'xmlns') {
      prefix = 'xmlns';
      local = '';
    }

    return { prefix: prefix, local: local };
  }

  function attrib(parser) {
    if (!parser.strict) {
      parser.attribName = parser.attribName[parser.looseCase]();
    }

    if (parser.attribList.indexOf(parser.attribName) !== -1 || parser.tag.attributes.hasOwnProperty(parser.attribName)) {
      parser.attribName = parser.attribValue = '';
      return;
    }

    if (parser.opt.xmlns) {
      var qn = qname(parser.attribName, true);
      var prefix = qn.prefix;
      var local = qn.local;

      if (prefix === 'xmlns') {
        // namespace binding attribute. push the binding into scope
        if (local === 'xml' && parser.attribValue !== XML_NAMESPACE) {
          strictFail(parser, 'xml: prefix must be bound to ' + XML_NAMESPACE + '\n' + 'Actual: ' + parser.attribValue);
        } else if (local === 'xmlns' && parser.attribValue !== XMLNS_NAMESPACE) {
          strictFail(parser, 'xmlns: prefix must be bound to ' + XMLNS_NAMESPACE + '\n' + 'Actual: ' + parser.attribValue);
        } else {
          var tag = parser.tag;
          var parent = parser.tags[parser.tags.length - 1] || parser;
          if (tag.ns === parent.ns) {
            tag.ns = Object.create(parent.ns);
          }
          tag.ns[local] = parser.attribValue;
        }
      }

      // defer onattribute events until all attributes have been seen
      // so any new bindings can take effect. preserve attribute order
      // so deferred events can be emitted in document order
      parser.attribList.push([parser.attribName, parser.attribValue]);
    } else {
      // in non-xmlns mode, we can emit the event right away
      parser.tag.attributes[parser.attribName] = parser.attribValue;
      emitNode(parser, 'onattribute', {
        name: parser.attribName,
        value: parser.attribValue
      });
    }

    parser.attribName = parser.attribValue = '';
  }

  function openTag(parser, selfClosing) {
    if (parser.opt.xmlns) {
      // emit namespace binding events
      var tag = parser.tag;

      // add namespace info to tag
      var qn = qname(parser.tagName);
      tag.prefix = qn.prefix;
      tag.local = qn.local;
      tag.uri = tag.ns[qn.prefix] || '';

      if (tag.prefix && !tag.uri) {
        strictFail(parser, 'Unbound namespace prefix: ' + JSON.stringify(parser.tagName));
        tag.uri = qn.prefix;
      }

      var parent = parser.tags[parser.tags.length - 1] || parser;
      if (tag.ns && parent.ns !== tag.ns) {
        Object.keys(tag.ns).forEach(function (p) {
          emitNode(parser, 'onopennamespace', {
            prefix: p,
            uri: tag.ns[p]
          });
        });
      }

      // handle deferred onattribute events
      // Note: do not apply default ns to attributes:
      //   http://www.w3.org/TR/REC-xml-names/#defaulting
      for (var i = 0, l = parser.attribList.length; i < l; i++) {
        var nv = parser.attribList[i];
        var name = nv[0];
        var value = nv[1];
        var qualName = qname(name, true);
        var prefix = qualName.prefix;
        var local = qualName.local;
        var uri = prefix === '' ? '' : tag.ns[prefix] || '';
        var a = {
          name: name,
          value: value,
          prefix: prefix,
          local: local,
          uri: uri

          // if there's any attributes with an undefined namespace,
          // then fail on them now.
        };if (prefix && prefix !== 'xmlns' && !uri) {
          strictFail(parser, 'Unbound namespace prefix: ' + JSON.stringify(prefix));
          a.uri = prefix;
        }
        parser.tag.attributes[name] = a;
        emitNode(parser, 'onattribute', a);
      }
      parser.attribList.length = 0;
    }

    parser.tag.isSelfClosing = !!selfClosing;

    // process the tag
    parser.sawRoot = true;
    parser.tags.push(parser.tag);
    emitNode(parser, 'onopentag', parser.tag);
    if (!selfClosing) {
      // special case for <script> in non-strict mode.
      if (!parser.noscript && parser.tagName.toLowerCase() === 'script') {
        parser.state = S.SCRIPT;
      } else {
        parser.state = S.TEXT;
      }
      parser.tag = null;
      parser.tagName = '';
    }
    parser.attribName = parser.attribValue = '';
    parser.attribList.length = 0;
  }

  function closeTag(parser) {
    if (!parser.tagName) {
      strictFail(parser, 'Weird empty close tag.');
      parser.textNode += '</>';
      parser.state = S.TEXT;
      return;
    }

    if (parser.script) {
      if (parser.tagName !== 'script') {
        parser.script += '</' + parser.tagName + '>';
        parser.tagName = '';
        parser.state = S.SCRIPT;
        return;
      }
      emitNode(parser, 'onscript', parser.script);
      parser.script = '';
    }

    // first make sure that the closing tag actually exists.
    // <a><b></c></b></a> will close everything, otherwise.
    var t = parser.tags.length;
    var tagName = parser.tagName;
    if (!parser.strict) {
      tagName = tagName[parser.looseCase]();
    }
    var closeTo = tagName;
    while (t--) {
      var close = parser.tags[t];
      if (close.name !== closeTo) {
        // fail the first time in strict mode
        strictFail(parser, 'Unexpected close tag');
      } else {
        break;
      }
    }

    // didn't find it.  we already failed for strict, so just abort.
    if (t < 0) {
      strictFail(parser, 'Unmatched closing tag: ' + parser.tagName);
      parser.textNode += '</' + parser.tagName + '>';
      parser.state = S.TEXT;
      return;
    }
    parser.tagName = tagName;
    var s = parser.tags.length;
    while (s-- > t) {
      var tag = parser.tag = parser.tags.pop();
      parser.tagName = parser.tag.name;
      emitNode(parser, 'onclosetag', parser.tagName);

      var x = {};
      for (var i in tag.ns) {
        x[i] = tag.ns[i];
      }

      var parent = parser.tags[parser.tags.length - 1] || parser;
      if (parser.opt.xmlns && tag.ns !== parent.ns) {
        // remove namespace bindings introduced by tag
        Object.keys(tag.ns).forEach(function (p) {
          var n = tag.ns[p];
          emitNode(parser, 'onclosenamespace', { prefix: p, uri: n });
        });
      }
    }
    if (t === 0) parser.closedRoot = true;
    parser.tagName = parser.attribValue = parser.attribName = '';
    parser.attribList.length = 0;
    parser.state = S.TEXT;
  }

  function parseEntity(parser) {
    var entity = parser.entity;
    var entityLC = entity.toLowerCase();
    var num;
    var numStr = '';

    if (parser.ENTITIES[entity]) {
      return parser.ENTITIES[entity];
    }
    if (parser.ENTITIES[entityLC]) {
      return parser.ENTITIES[entityLC];
    }
    entity = entityLC;
    if (entity.charAt(0) === '#') {
      if (entity.charAt(1) === 'x') {
        entity = entity.slice(2);
        num = parseInt(entity, 16);
        numStr = num.toString(16);
      } else {
        entity = entity.slice(1);
        num = parseInt(entity, 10);
        numStr = num.toString(10);
      }
    }
    entity = entity.replace(/^0+/, '');
    if (isNaN(num) || numStr.toLowerCase() !== entity) {
      strictFail(parser, 'Invalid character entity');
      return '&' + parser.entity + ';';
    }

    return String.fromCodePoint(num);
  }

  function beginWhiteSpace(parser, c) {
    if (c === '<') {
      parser.state = S.OPEN_WAKA;
      parser.startTagPosition = parser.position;
    } else if (!isWhitespace(c)) {
      // have to process this as a text node.
      // weird, but happens.
      strictFail(parser, 'Non-whitespace before first tag.');
      parser.textNode = c;
      parser.state = S.TEXT;
    }
  }

  function charAt(chunk, i) {
    var result = '';
    if (i < chunk.length) {
      result = chunk.charAt(i);
    }
    return result;
  }

  function write(chunk) {
    var parser = this;
    if (this.error) {
      throw this.error;
    }
    if (parser.closed) {
      return error(parser, 'Cannot write after close. Assign an onready handler.');
    }
    if (chunk === null) {
      return end(parser);
    }
    if (typeof chunk === 'object') {
      chunk = chunk.toString();
    }
    var i = 0;
    var c = '';
    while (true) {
      c = charAt(chunk, i++);
      parser.c = c;

      if (!c) {
        break;
      }

      if (parser.trackPosition) {
        parser.position++;
        if (c === '\n') {
          parser.line++;
          parser.column = 0;
        } else {
          parser.column++;
        }
      }

      switch (parser.state) {
        case S.BEGIN:
          parser.state = S.BEGIN_WHITESPACE;
          if (c === '\uFEFF') {
            continue;
          }
          beginWhiteSpace(parser, c);
          continue;

        case S.BEGIN_WHITESPACE:
          beginWhiteSpace(parser, c);
          continue;

        case S.TEXT:
          if (parser.sawRoot && !parser.closedRoot) {
            var starti = i - 1;
            while (c && c !== '<' && c !== '&') {
              c = charAt(chunk, i++);
              if (c && parser.trackPosition) {
                parser.position++;
                if (c === '\n') {
                  parser.line++;
                  parser.column = 0;
                } else {
                  parser.column++;
                }
              }
            }
            parser.textNode += chunk.substring(starti, i - 1);
          }
          if (c === '<' && !(parser.sawRoot && parser.closedRoot && !parser.strict)) {
            parser.state = S.OPEN_WAKA;
            parser.startTagPosition = parser.position;
          } else {
            if (!isWhitespace(c) && (!parser.sawRoot || parser.closedRoot)) {
              strictFail(parser, 'Text data outside of root node.');
            }
            if (c === '&') {
              parser.state = S.TEXT_ENTITY;
            } else {
              parser.textNode += c;
            }
          }
          continue;

        case S.SCRIPT:
          // only non-strict
          if (c === '<') {
            parser.state = S.SCRIPT_ENDING;
          } else {
            parser.script += c;
          }
          continue;

        case S.SCRIPT_ENDING:
          if (c === '/') {
            parser.state = S.CLOSE_TAG;
          } else {
            parser.script += '<' + c;
            parser.state = S.SCRIPT;
          }
          continue;

        case S.OPEN_WAKA:
          // either a /, ?, !, or text is coming next.
          if (c === '!') {
            parser.state = S.SGML_DECL;
            parser.sgmlDecl = '';
          } else if (isWhitespace(c)) {
            // wait for it...
          } else if (isMatch(nameStart, c)) {
            parser.state = S.OPEN_TAG;
            parser.tagName = c;
          } else if (c === '/') {
            parser.state = S.CLOSE_TAG;
            parser.tagName = '';
          } else if (c === '?') {
            parser.state = S.PROC_INST;
            parser.procInstName = parser.procInstBody = '';
          } else {
            strictFail(parser, 'Unencoded <');
            // if there was some whitespace, then add that in.
            if (parser.startTagPosition + 1 < parser.position) {
              var pad = parser.position - parser.startTagPosition;
              c = new Array(pad).join(' ') + c;
            }
            parser.textNode += '<' + c;
            parser.state = S.TEXT;
          }
          continue;

        case S.SGML_DECL:
          if ((parser.sgmlDecl + c).toUpperCase() === CDATA) {
            emitNode(parser, 'onopencdata');
            parser.state = S.CDATA;
            parser.sgmlDecl = '';
            parser.cdata = '';
          } else if (parser.sgmlDecl + c === '--') {
            parser.state = S.COMMENT;
            parser.comment = '';
            parser.sgmlDecl = '';
          } else if ((parser.sgmlDecl + c).toUpperCase() === DOCTYPE) {
            parser.state = S.DOCTYPE;
            if (parser.doctype || parser.sawRoot) {
              strictFail(parser, 'Inappropriately located doctype declaration');
            }
            parser.doctype = '';
            parser.sgmlDecl = '';
          } else if (c === '>') {
            emitNode(parser, 'onsgmldeclaration', parser.sgmlDecl);
            parser.sgmlDecl = '';
            parser.state = S.TEXT;
          } else if (isQuote(c)) {
            parser.state = S.SGML_DECL_QUOTED;
            parser.sgmlDecl += c;
          } else {
            parser.sgmlDecl += c;
          }
          continue;

        case S.SGML_DECL_QUOTED:
          if (c === parser.q) {
            parser.state = S.SGML_DECL;
            parser.q = '';
          }
          parser.sgmlDecl += c;
          continue;

        case S.DOCTYPE:
          if (c === '>') {
            parser.state = S.TEXT;
            emitNode(parser, 'ondoctype', parser.doctype);
            parser.doctype = true; // just remember that we saw it.
          } else {
            parser.doctype += c;
            if (c === '[') {
              parser.state = S.DOCTYPE_DTD;
            } else if (isQuote(c)) {
              parser.state = S.DOCTYPE_QUOTED;
              parser.q = c;
            }
          }
          continue;

        case S.DOCTYPE_QUOTED:
          parser.doctype += c;
          if (c === parser.q) {
            parser.q = '';
            parser.state = S.DOCTYPE;
          }
          continue;

        case S.DOCTYPE_DTD:
          parser.doctype += c;
          if (c === ']') {
            parser.state = S.DOCTYPE;
          } else if (isQuote(c)) {
            parser.state = S.DOCTYPE_DTD_QUOTED;
            parser.q = c;
          }
          continue;

        case S.DOCTYPE_DTD_QUOTED:
          parser.doctype += c;
          if (c === parser.q) {
            parser.state = S.DOCTYPE_DTD;
            parser.q = '';
          }
          continue;

        case S.COMMENT:
          if (c === '-') {
            parser.state = S.COMMENT_ENDING;
          } else {
            parser.comment += c;
          }
          continue;

        case S.COMMENT_ENDING:
          if (c === '-') {
            parser.state = S.COMMENT_ENDED;
            parser.comment = textopts(parser.opt, parser.comment);
            if (parser.comment) {
              emitNode(parser, 'oncomment', parser.comment);
            }
            parser.comment = '';
          } else {
            parser.comment += '-' + c;
            parser.state = S.COMMENT;
          }
          continue;

        case S.COMMENT_ENDED:
          if (c !== '>') {
            strictFail(parser, 'Malformed comment');
            // allow <!-- blah -- bloo --> in non-strict mode,
            // which is a comment of " blah -- bloo "
            parser.comment += '--' + c;
            parser.state = S.COMMENT;
          } else {
            parser.state = S.TEXT;
          }
          continue;

        case S.CDATA:
          if (c === ']') {
            parser.state = S.CDATA_ENDING;
          } else {
            parser.cdata += c;
          }
          continue;

        case S.CDATA_ENDING:
          if (c === ']') {
            parser.state = S.CDATA_ENDING_2;
          } else {
            parser.cdata += ']' + c;
            parser.state = S.CDATA;
          }
          continue;

        case S.CDATA_ENDING_2:
          if (c === '>') {
            if (parser.cdata) {
              emitNode(parser, 'oncdata', parser.cdata);
            }
            emitNode(parser, 'onclosecdata');
            parser.cdata = '';
            parser.state = S.TEXT;
          } else if (c === ']') {
            parser.cdata += ']';
          } else {
            parser.cdata += ']]' + c;
            parser.state = S.CDATA;
          }
          continue;

        case S.PROC_INST:
          if (c === '?') {
            parser.state = S.PROC_INST_ENDING;
          } else if (isWhitespace(c)) {
            parser.state = S.PROC_INST_BODY;
          } else {
            parser.procInstName += c;
          }
          continue;

        case S.PROC_INST_BODY:
          if (!parser.procInstBody && isWhitespace(c)) {
            continue;
          } else if (c === '?') {
            parser.state = S.PROC_INST_ENDING;
          } else {
            parser.procInstBody += c;
          }
          continue;

        case S.PROC_INST_ENDING:
          if (c === '>') {
            emitNode(parser, 'onprocessinginstruction', {
              name: parser.procInstName,
              body: parser.procInstBody
            });
            parser.procInstName = parser.procInstBody = '';
            parser.state = S.TEXT;
          } else {
            parser.procInstBody += '?' + c;
            parser.state = S.PROC_INST_BODY;
          }
          continue;

        case S.OPEN_TAG:
          if (isMatch(nameBody, c)) {
            parser.tagName += c;
          } else {
            newTag(parser);
            if (c === '>') {
              openTag(parser);
            } else if (c === '/') {
              parser.state = S.OPEN_TAG_SLASH;
            } else {
              if (!isWhitespace(c)) {
                strictFail(parser, 'Invalid character in tag name');
              }
              parser.state = S.ATTRIB;
            }
          }
          continue;

        case S.OPEN_TAG_SLASH:
          if (c === '>') {
            openTag(parser, true);
            closeTag(parser);
          } else {
            strictFail(parser, 'Forward-slash in opening tag not followed by >');
            parser.state = S.ATTRIB;
          }
          continue;

        case S.ATTRIB:
          // haven't read the attribute name yet.
          if (isWhitespace(c)) {
            continue;
          } else if (c === '>') {
            openTag(parser);
          } else if (c === '/') {
            parser.state = S.OPEN_TAG_SLASH;
          } else if (isMatch(nameStart, c)) {
            parser.attribName = c;
            parser.attribValue = '';
            parser.state = S.ATTRIB_NAME;
          } else {
            strictFail(parser, 'Invalid attribute name');
          }
          continue;

        case S.ATTRIB_NAME:
          if (c === '=') {
            parser.state = S.ATTRIB_VALUE;
          } else if (c === '>') {
            strictFail(parser, 'Attribute without value');
            parser.attribValue = parser.attribName;
            attrib(parser);
            openTag(parser);
          } else if (isWhitespace(c)) {
            parser.state = S.ATTRIB_NAME_SAW_WHITE;
          } else if (isMatch(nameBody, c)) {
            parser.attribName += c;
          } else {
            strictFail(parser, 'Invalid attribute name');
          }
          continue;

        case S.ATTRIB_NAME_SAW_WHITE:
          if (c === '=') {
            parser.state = S.ATTRIB_VALUE;
          } else if (isWhitespace(c)) {
            continue;
          } else {
            strictFail(parser, 'Attribute without value');
            parser.tag.attributes[parser.attribName] = '';
            parser.attribValue = '';
            emitNode(parser, 'onattribute', {
              name: parser.attribName,
              value: ''
            });
            parser.attribName = '';
            if (c === '>') {
              openTag(parser);
            } else if (isMatch(nameStart, c)) {
              parser.attribName = c;
              parser.state = S.ATTRIB_NAME;
            } else {
              strictFail(parser, 'Invalid attribute name');
              parser.state = S.ATTRIB;
            }
          }
          continue;

        case S.ATTRIB_VALUE:
          if (isWhitespace(c)) {
            continue;
          } else if (isQuote(c)) {
            parser.q = c;
            parser.state = S.ATTRIB_VALUE_QUOTED;
          } else {
            strictFail(parser, 'Unquoted attribute value');
            parser.state = S.ATTRIB_VALUE_UNQUOTED;
            parser.attribValue = c;
          }
          continue;

        case S.ATTRIB_VALUE_QUOTED:
          if (c !== parser.q) {
            if (c === '&') {
              parser.state = S.ATTRIB_VALUE_ENTITY_Q;
            } else {
              parser.attribValue += c;
            }
            continue;
          }
          attrib(parser);
          parser.q = '';
          parser.state = S.ATTRIB_VALUE_CLOSED;
          continue;

        case S.ATTRIB_VALUE_CLOSED:
          if (isWhitespace(c)) {
            parser.state = S.ATTRIB;
          } else if (c === '>') {
            openTag(parser);
          } else if (c === '/') {
            parser.state = S.OPEN_TAG_SLASH;
          } else if (isMatch(nameStart, c)) {
            strictFail(parser, 'No whitespace between attributes');
            parser.attribName = c;
            parser.attribValue = '';
            parser.state = S.ATTRIB_NAME;
          } else {
            strictFail(parser, 'Invalid attribute name');
          }
          continue;

        case S.ATTRIB_VALUE_UNQUOTED:
          if (!isAttribEnd(c)) {
            if (c === '&') {
              parser.state = S.ATTRIB_VALUE_ENTITY_U;
            } else {
              parser.attribValue += c;
            }
            continue;
          }
          attrib(parser);
          if (c === '>') {
            openTag(parser);
          } else {
            parser.state = S.ATTRIB;
          }
          continue;

        case S.CLOSE_TAG:
          if (!parser.tagName) {
            if (isWhitespace(c)) {
              continue;
            } else if (notMatch(nameStart, c)) {
              if (parser.script) {
                parser.script += '</' + c;
                parser.state = S.SCRIPT;
              } else {
                strictFail(parser, 'Invalid tagname in closing tag.');
              }
            } else {
              parser.tagName = c;
            }
          } else if (c === '>') {
            closeTag(parser);
          } else if (isMatch(nameBody, c)) {
            parser.tagName += c;
          } else if (parser.script) {
            parser.script += '</' + parser.tagName;
            parser.tagName = '';
            parser.state = S.SCRIPT;
          } else {
            if (!isWhitespace(c)) {
              strictFail(parser, 'Invalid tagname in closing tag');
            }
            parser.state = S.CLOSE_TAG_SAW_WHITE;
          }
          continue;

        case S.CLOSE_TAG_SAW_WHITE:
          if (isWhitespace(c)) {
            continue;
          }
          if (c === '>') {
            closeTag(parser);
          } else {
            strictFail(parser, 'Invalid characters in closing tag');
          }
          continue;

        case S.TEXT_ENTITY:
        case S.ATTRIB_VALUE_ENTITY_Q:
        case S.ATTRIB_VALUE_ENTITY_U:
          var returnState;
          var buffer;
          switch (parser.state) {
            case S.TEXT_ENTITY:
              returnState = S.TEXT;
              buffer = 'textNode';
              break;

            case S.ATTRIB_VALUE_ENTITY_Q:
              returnState = S.ATTRIB_VALUE_QUOTED;
              buffer = 'attribValue';
              break;

            case S.ATTRIB_VALUE_ENTITY_U:
              returnState = S.ATTRIB_VALUE_UNQUOTED;
              buffer = 'attribValue';
              break;
          }

          if (c === ';') {
            parser[buffer] += parseEntity(parser);
            parser.entity = '';
            parser.state = returnState;
          } else if (isMatch(parser.entity.length ? entityBody : entityStart, c)) {
            parser.entity += c;
          } else {
            strictFail(parser, 'Invalid character in entity name');
            parser[buffer] += '&' + parser.entity + c;
            parser.entity = '';
            parser.state = returnState;
          }

          continue;

        default:
          throw new Error(parser, 'Unknown state: ' + parser.state);
      }
    } // while

    if (parser.position >= parser.bufferCheckPosition) {
      checkBufferLength(parser);
    }
    return parser;
  }

  /*! http://mths.be/fromcodepoint v0.1.0 by @mathias */
  /* istanbul ignore next */
  if (!String.fromCodePoint) {
    (function () {
      var stringFromCharCode = String.fromCharCode;
      var floor = Math.floor;
      var fromCodePoint = function () {
        var MAX_SIZE = 0x4000;
        var codeUnits = [];
        var highSurrogate;
        var lowSurrogate;
        var index = -1;
        var length = arguments.length;
        if (!length) {
          return '';
        }
        var result = '';
        while (++index < length) {
          var codePoint = Number(arguments[index]);
          if (!isFinite(codePoint) || // `NaN`, `+Infinity`, or `-Infinity`
          codePoint < 0 || // not a valid Unicode code point
          codePoint > 0x10FFFF || // not a valid Unicode code point
          floor(codePoint) !== codePoint // not an integer
          ) {
              throw RangeError('Invalid code point: ' + codePoint);
            }
          if (codePoint <= 0xFFFF) {
            // BMP code point
            codeUnits.push(codePoint);
          } else {
            // Astral code point; split in surrogate halves
            // http://mathiasbynens.be/notes/javascript-encoding#surrogate-formulae
            codePoint -= 0x10000;
            highSurrogate = (codePoint >> 10) + 0xD800;
            lowSurrogate = codePoint % 0x400 + 0xDC00;
            codeUnits.push(highSurrogate, lowSurrogate);
          }
          if (index + 1 === length || codeUnits.length > MAX_SIZE) {
            result += stringFromCharCode.apply(null, codeUnits);
            codeUnits.length = 0;
          }
        }
        return result;
      };
      /* istanbul ignore next */
      if (Object.defineProperty) {
        Object.defineProperty(String, 'fromCodePoint', {
          value: fromCodePoint,
          configurable: true,
          writable: true
        });
      } else {
        String.fromCodePoint = fromCodePoint;
      }
    })();
  }
})( false ? undefined.sax = {} : exports);

/***/ }),
/* 136 */
/***/ (function(module, exports) {

module.exports = require("string_decoder");

/***/ }),
/* 137 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var loader = __webpack_require__(138);
var dumper = __webpack_require__(158);

function deprecated(name) {
  return function () {
    throw new Error('Function ' + name + ' is deprecated and cannot be used.');
  };
}

module.exports.Type = __webpack_require__(4);
module.exports.Schema = __webpack_require__(18);
module.exports.FAILSAFE_SCHEMA = __webpack_require__(32);
module.exports.JSON_SCHEMA = __webpack_require__(54);
module.exports.CORE_SCHEMA = __webpack_require__(53);
module.exports.DEFAULT_SAFE_SCHEMA = __webpack_require__(22);
module.exports.DEFAULT_FULL_SCHEMA = __webpack_require__(25);
module.exports.load = loader.load;
module.exports.loadAll = loader.loadAll;
module.exports.safeLoad = loader.safeLoad;
module.exports.safeLoadAll = loader.safeLoadAll;
module.exports.dump = dumper.dump;
module.exports.safeDump = dumper.safeDump;
module.exports.YAMLException = __webpack_require__(21);

// Deprecated schema names from JS-YAML 2.0.x
module.exports.MINIMAL_SCHEMA = __webpack_require__(32);
module.exports.SAFE_SCHEMA = __webpack_require__(22);
module.exports.DEFAULT_SCHEMA = __webpack_require__(25);

// Deprecated functions from JS-YAML 1.x.x
module.exports.scan = deprecated('scan');
module.exports.parse = deprecated('parse');
module.exports.compose = deprecated('compose');
module.exports.addConstructor = deprecated('addConstructor');

/***/ }),
/* 138 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/*eslint-disable max-len,no-use-before-define*/

var common = __webpack_require__(17);
var YAMLException = __webpack_require__(21);
var Mark = __webpack_require__(139);
var DEFAULT_SAFE_SCHEMA = __webpack_require__(22);
var DEFAULT_FULL_SCHEMA = __webpack_require__(25);

var _hasOwnProperty = Object.prototype.hasOwnProperty;

var CONTEXT_FLOW_IN = 1;
var CONTEXT_FLOW_OUT = 2;
var CONTEXT_BLOCK_IN = 3;
var CONTEXT_BLOCK_OUT = 4;

var CHOMPING_CLIP = 1;
var CHOMPING_STRIP = 2;
var CHOMPING_KEEP = 3;

var PATTERN_NON_PRINTABLE = /[\x00-\x08\x0B\x0C\x0E-\x1F\x7F-\x84\x86-\x9F\uFFFE\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]/;
var PATTERN_NON_ASCII_LINE_BREAKS = /[\x85\u2028\u2029]/;
var PATTERN_FLOW_INDICATORS = /[,\[\]\{\}]/;
var PATTERN_TAG_HANDLE = /^(?:!|!!|![a-z\-]+!)$/i;
var PATTERN_TAG_URI = /^(?:!|[^,\[\]\{\}])(?:%[0-9a-f]{2}|[0-9a-z\-#;\/\?:@&=\+\$,_\.!~\*'\(\)\[\]])*$/i;

function is_EOL(c) {
  return c === 0x0A /* LF */ || c === 0x0D /* CR */;
}

function is_WHITE_SPACE(c) {
  return c === 0x09 /* Tab */ || c === 0x20 /* Space */;
}

function is_WS_OR_EOL(c) {
  return c === 0x09 /* Tab */ || c === 0x20 /* Space */ || c === 0x0A /* LF */ || c === 0x0D /* CR */;
}

function is_FLOW_INDICATOR(c) {
  return c === 0x2C /* , */ || c === 0x5B /* [ */ || c === 0x5D /* ] */ || c === 0x7B /* { */ || c === 0x7D /* } */;
}

function fromHexCode(c) {
  var lc;

  if (0x30 /* 0 */ <= c && c <= 0x39 /* 9 */) {
    return c - 0x30;
  }

  /*eslint-disable no-bitwise*/
  lc = c | 0x20;

  if (0x61 /* a */ <= lc && lc <= 0x66 /* f */) {
    return lc - 0x61 + 10;
  }

  return -1;
}

function escapedHexLen(c) {
  if (c === 0x78 /* x */) {
      return 2;
    }
  if (c === 0x75 /* u */) {
      return 4;
    }
  if (c === 0x55 /* U */) {
      return 8;
    }
  return 0;
}

function fromDecimalCode(c) {
  if (0x30 /* 0 */ <= c && c <= 0x39 /* 9 */) {
    return c - 0x30;
  }

  return -1;
}

function simpleEscapeSequence(c) {
  /* eslint-disable indent */
  return c === 0x30 /* 0 */ ? '\x00' : c === 0x61 /* a */ ? '\x07' : c === 0x62 /* b */ ? '\x08' : c === 0x74 /* t */ ? '\x09' : c === 0x09 /* Tab */ ? '\x09' : c === 0x6E /* n */ ? '\x0A' : c === 0x76 /* v */ ? '\x0B' : c === 0x66 /* f */ ? '\x0C' : c === 0x72 /* r */ ? '\x0D' : c === 0x65 /* e */ ? '\x1B' : c === 0x20 /* Space */ ? ' ' : c === 0x22 /* " */ ? '\x22' : c === 0x2F /* / */ ? '/' : c === 0x5C /* \ */ ? '\x5C' : c === 0x4E /* N */ ? '\x85' : c === 0x5F /* _ */ ? '\xA0' : c === 0x4C /* L */ ? '\u2028' : c === 0x50 /* P */ ? '\u2029' : '';
}

function charFromCodepoint(c) {
  if (c <= 0xFFFF) {
    return String.fromCharCode(c);
  }
  // Encode UTF-16 surrogate pair
  // https://en.wikipedia.org/wiki/UTF-16#Code_points_U.2B010000_to_U.2B10FFFF
  return String.fromCharCode((c - 0x010000 >> 10) + 0xD800, (c - 0x010000 & 0x03FF) + 0xDC00);
}

var simpleEscapeCheck = new Array(256); // integer, for fast access
var simpleEscapeMap = new Array(256);
for (var i = 0; i < 256; i++) {
  simpleEscapeCheck[i] = simpleEscapeSequence(i) ? 1 : 0;
  simpleEscapeMap[i] = simpleEscapeSequence(i);
}

function State(input, options) {
  this.input = input;

  this.filename = options['filename'] || null;
  this.schema = options['schema'] || DEFAULT_FULL_SCHEMA;
  this.onWarning = options['onWarning'] || null;
  this.legacy = options['legacy'] || false;
  this.json = options['json'] || false;
  this.listener = options['listener'] || null;

  this.implicitTypes = this.schema.compiledImplicit;
  this.typeMap = this.schema.compiledTypeMap;

  this.length = input.length;
  this.position = 0;
  this.line = 0;
  this.lineStart = 0;
  this.lineIndent = 0;

  this.documents = [];

  /*
  this.version;
  this.checkLineBreaks;
  this.tagMap;
  this.anchorMap;
  this.tag;
  this.anchor;
  this.kind;
  this.result;*/
}

function generateError(state, message) {
  return new YAMLException(message, new Mark(state.filename, state.input, state.position, state.line, state.position - state.lineStart));
}

function throwError(state, message) {
  throw generateError(state, message);
}

function throwWarning(state, message) {
  if (state.onWarning) {
    state.onWarning.call(null, generateError(state, message));
  }
}

var directiveHandlers = {

  YAML: function handleYamlDirective(state, name, args) {

    var match, major, minor;

    if (state.version !== null) {
      throwError(state, 'duplication of %YAML directive');
    }

    if (args.length !== 1) {
      throwError(state, 'YAML directive accepts exactly one argument');
    }

    match = /^([0-9]+)\.([0-9]+)$/.exec(args[0]);

    if (match === null) {
      throwError(state, 'ill-formed argument of the YAML directive');
    }

    major = parseInt(match[1], 10);
    minor = parseInt(match[2], 10);

    if (major !== 1) {
      throwError(state, 'unacceptable YAML version of the document');
    }

    state.version = args[0];
    state.checkLineBreaks = minor < 2;

    if (minor !== 1 && minor !== 2) {
      throwWarning(state, 'unsupported YAML version of the document');
    }
  },

  TAG: function handleTagDirective(state, name, args) {

    var handle, prefix;

    if (args.length !== 2) {
      throwError(state, 'TAG directive accepts exactly two arguments');
    }

    handle = args[0];
    prefix = args[1];

    if (!PATTERN_TAG_HANDLE.test(handle)) {
      throwError(state, 'ill-formed tag handle (first argument) of the TAG directive');
    }

    if (_hasOwnProperty.call(state.tagMap, handle)) {
      throwError(state, 'there is a previously declared suffix for "' + handle + '" tag handle');
    }

    if (!PATTERN_TAG_URI.test(prefix)) {
      throwError(state, 'ill-formed tag prefix (second argument) of the TAG directive');
    }

    state.tagMap[handle] = prefix;
  }
};

function captureSegment(state, start, end, checkJson) {
  var _position, _length, _character, _result;

  if (start < end) {
    _result = state.input.slice(start, end);

    if (checkJson) {
      for (_position = 0, _length = _result.length; _position < _length; _position += 1) {
        _character = _result.charCodeAt(_position);
        if (!(_character === 0x09 || 0x20 <= _character && _character <= 0x10FFFF)) {
          throwError(state, 'expected valid JSON character');
        }
      }
    } else if (PATTERN_NON_PRINTABLE.test(_result)) {
      throwError(state, 'the stream contains non-printable characters');
    }

    state.result += _result;
  }
}

function mergeMappings(state, destination, source, overridableKeys) {
  var sourceKeys, key, index, quantity;

  if (!common.isObject(source)) {
    throwError(state, 'cannot merge mappings; the provided source object is unacceptable');
  }

  sourceKeys = Object.keys(source);

  for (index = 0, quantity = sourceKeys.length; index < quantity; index += 1) {
    key = sourceKeys[index];

    if (!_hasOwnProperty.call(destination, key)) {
      destination[key] = source[key];
      overridableKeys[key] = true;
    }
  }
}

function storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, valueNode, startLine, startPos) {
  var index, quantity;

  keyNode = String(keyNode);

  if (_result === null) {
    _result = {};
  }

  if (keyTag === 'tag:yaml.org,2002:merge') {
    if (Array.isArray(valueNode)) {
      for (index = 0, quantity = valueNode.length; index < quantity; index += 1) {
        mergeMappings(state, _result, valueNode[index], overridableKeys);
      }
    } else {
      mergeMappings(state, _result, valueNode, overridableKeys);
    }
  } else {
    if (!state.json && !_hasOwnProperty.call(overridableKeys, keyNode) && _hasOwnProperty.call(_result, keyNode)) {
      state.line = startLine || state.line;
      state.position = startPos || state.position;
      throwError(state, 'duplicated mapping key');
    }
    _result[keyNode] = valueNode;
    delete overridableKeys[keyNode];
  }

  return _result;
}

function readLineBreak(state) {
  var ch;

  ch = state.input.charCodeAt(state.position);

  if (ch === 0x0A /* LF */) {
      state.position++;
    } else if (ch === 0x0D /* CR */) {
      state.position++;
      if (state.input.charCodeAt(state.position) === 0x0A /* LF */) {
          state.position++;
        }
    } else {
    throwError(state, 'a line break is expected');
  }

  state.line += 1;
  state.lineStart = state.position;
}

function skipSeparationSpace(state, allowComments, checkIndent) {
  var lineBreaks = 0,
      ch = state.input.charCodeAt(state.position);

  while (ch !== 0) {
    while (is_WHITE_SPACE(ch)) {
      ch = state.input.charCodeAt(++state.position);
    }

    if (allowComments && ch === 0x23 /* # */) {
        do {
          ch = state.input.charCodeAt(++state.position);
        } while (ch !== 0x0A /* LF */ && ch !== 0x0D /* CR */ && ch !== 0);
      }

    if (is_EOL(ch)) {
      readLineBreak(state);

      ch = state.input.charCodeAt(state.position);
      lineBreaks++;
      state.lineIndent = 0;

      while (ch === 0x20 /* Space */) {
        state.lineIndent++;
        ch = state.input.charCodeAt(++state.position);
      }
    } else {
      break;
    }
  }

  if (checkIndent !== -1 && lineBreaks !== 0 && state.lineIndent < checkIndent) {
    throwWarning(state, 'deficient indentation');
  }

  return lineBreaks;
}

function testDocumentSeparator(state) {
  var _position = state.position,
      ch;

  ch = state.input.charCodeAt(_position);

  // Condition state.position === state.lineStart is tested
  // in parent on each call, for efficiency. No needs to test here again.
  if ((ch === 0x2D /* - */ || ch === 0x2E /* . */) && ch === state.input.charCodeAt(_position + 1) && ch === state.input.charCodeAt(_position + 2)) {

    _position += 3;

    ch = state.input.charCodeAt(_position);

    if (ch === 0 || is_WS_OR_EOL(ch)) {
      return true;
    }
  }

  return false;
}

function writeFoldedLines(state, count) {
  if (count === 1) {
    state.result += ' ';
  } else if (count > 1) {
    state.result += common.repeat('\n', count - 1);
  }
}

function readPlainScalar(state, nodeIndent, withinFlowCollection) {
  var preceding,
      following,
      captureStart,
      captureEnd,
      hasPendingContent,
      _line,
      _lineStart,
      _lineIndent,
      _kind = state.kind,
      _result = state.result,
      ch;

  ch = state.input.charCodeAt(state.position);

  if (is_WS_OR_EOL(ch) || is_FLOW_INDICATOR(ch) || ch === 0x23 /* # */ || ch === 0x26 /* & */ || ch === 0x2A /* * */ || ch === 0x21 /* ! */ || ch === 0x7C /* | */ || ch === 0x3E /* > */ || ch === 0x27 /* ' */ || ch === 0x22 /* " */ || ch === 0x25 /* % */ || ch === 0x40 /* @ */ || ch === 0x60 /* ` */) {
      return false;
    }

  if (ch === 0x3F /* ? */ || ch === 0x2D /* - */) {
      following = state.input.charCodeAt(state.position + 1);

      if (is_WS_OR_EOL(following) || withinFlowCollection && is_FLOW_INDICATOR(following)) {
        return false;
      }
    }

  state.kind = 'scalar';
  state.result = '';
  captureStart = captureEnd = state.position;
  hasPendingContent = false;

  while (ch !== 0) {
    if (ch === 0x3A /* : */) {
        following = state.input.charCodeAt(state.position + 1);

        if (is_WS_OR_EOL(following) || withinFlowCollection && is_FLOW_INDICATOR(following)) {
          break;
        }
      } else if (ch === 0x23 /* # */) {
        preceding = state.input.charCodeAt(state.position - 1);

        if (is_WS_OR_EOL(preceding)) {
          break;
        }
      } else if (state.position === state.lineStart && testDocumentSeparator(state) || withinFlowCollection && is_FLOW_INDICATOR(ch)) {
      break;
    } else if (is_EOL(ch)) {
      _line = state.line;
      _lineStart = state.lineStart;
      _lineIndent = state.lineIndent;
      skipSeparationSpace(state, false, -1);

      if (state.lineIndent >= nodeIndent) {
        hasPendingContent = true;
        ch = state.input.charCodeAt(state.position);
        continue;
      } else {
        state.position = captureEnd;
        state.line = _line;
        state.lineStart = _lineStart;
        state.lineIndent = _lineIndent;
        break;
      }
    }

    if (hasPendingContent) {
      captureSegment(state, captureStart, captureEnd, false);
      writeFoldedLines(state, state.line - _line);
      captureStart = captureEnd = state.position;
      hasPendingContent = false;
    }

    if (!is_WHITE_SPACE(ch)) {
      captureEnd = state.position + 1;
    }

    ch = state.input.charCodeAt(++state.position);
  }

  captureSegment(state, captureStart, captureEnd, false);

  if (state.result) {
    return true;
  }

  state.kind = _kind;
  state.result = _result;
  return false;
}

function readSingleQuotedScalar(state, nodeIndent) {
  var ch, captureStart, captureEnd;

  ch = state.input.charCodeAt(state.position);

  if (ch !== 0x27 /* ' */) {
      return false;
    }

  state.kind = 'scalar';
  state.result = '';
  state.position++;
  captureStart = captureEnd = state.position;

  while ((ch = state.input.charCodeAt(state.position)) !== 0) {
    if (ch === 0x27 /* ' */) {
        captureSegment(state, captureStart, state.position, true);
        ch = state.input.charCodeAt(++state.position);

        if (ch === 0x27 /* ' */) {
            captureStart = state.position;
            state.position++;
            captureEnd = state.position;
          } else {
          return true;
        }
      } else if (is_EOL(ch)) {
      captureSegment(state, captureStart, captureEnd, true);
      writeFoldedLines(state, skipSeparationSpace(state, false, nodeIndent));
      captureStart = captureEnd = state.position;
    } else if (state.position === state.lineStart && testDocumentSeparator(state)) {
      throwError(state, 'unexpected end of the document within a single quoted scalar');
    } else {
      state.position++;
      captureEnd = state.position;
    }
  }

  throwError(state, 'unexpected end of the stream within a single quoted scalar');
}

function readDoubleQuotedScalar(state, nodeIndent) {
  var captureStart, captureEnd, hexLength, hexResult, tmp, ch;

  ch = state.input.charCodeAt(state.position);

  if (ch !== 0x22 /* " */) {
      return false;
    }

  state.kind = 'scalar';
  state.result = '';
  state.position++;
  captureStart = captureEnd = state.position;

  while ((ch = state.input.charCodeAt(state.position)) !== 0) {
    if (ch === 0x22 /* " */) {
        captureSegment(state, captureStart, state.position, true);
        state.position++;
        return true;
      } else if (ch === 0x5C /* \ */) {
        captureSegment(state, captureStart, state.position, true);
        ch = state.input.charCodeAt(++state.position);

        if (is_EOL(ch)) {
          skipSeparationSpace(state, false, nodeIndent);

          // TODO: rework to inline fn with no type cast?
        } else if (ch < 256 && simpleEscapeCheck[ch]) {
          state.result += simpleEscapeMap[ch];
          state.position++;
        } else if ((tmp = escapedHexLen(ch)) > 0) {
          hexLength = tmp;
          hexResult = 0;

          for (; hexLength > 0; hexLength--) {
            ch = state.input.charCodeAt(++state.position);

            if ((tmp = fromHexCode(ch)) >= 0) {
              hexResult = (hexResult << 4) + tmp;
            } else {
              throwError(state, 'expected hexadecimal character');
            }
          }

          state.result += charFromCodepoint(hexResult);

          state.position++;
        } else {
          throwError(state, 'unknown escape sequence');
        }

        captureStart = captureEnd = state.position;
      } else if (is_EOL(ch)) {
      captureSegment(state, captureStart, captureEnd, true);
      writeFoldedLines(state, skipSeparationSpace(state, false, nodeIndent));
      captureStart = captureEnd = state.position;
    } else if (state.position === state.lineStart && testDocumentSeparator(state)) {
      throwError(state, 'unexpected end of the document within a double quoted scalar');
    } else {
      state.position++;
      captureEnd = state.position;
    }
  }

  throwError(state, 'unexpected end of the stream within a double quoted scalar');
}

function readFlowCollection(state, nodeIndent) {
  var readNext = true,
      _line,
      _tag = state.tag,
      _result,
      _anchor = state.anchor,
      following,
      terminator,
      isPair,
      isExplicitPair,
      isMapping,
      overridableKeys = {},
      keyNode,
      keyTag,
      valueNode,
      ch;

  ch = state.input.charCodeAt(state.position);

  if (ch === 0x5B /* [ */) {
      terminator = 0x5D; /* ] */
      isMapping = false;
      _result = [];
    } else if (ch === 0x7B /* { */) {
      terminator = 0x7D; /* } */
      isMapping = true;
      _result = {};
    } else {
    return false;
  }

  if (state.anchor !== null) {
    state.anchorMap[state.anchor] = _result;
  }

  ch = state.input.charCodeAt(++state.position);

  while (ch !== 0) {
    skipSeparationSpace(state, true, nodeIndent);

    ch = state.input.charCodeAt(state.position);

    if (ch === terminator) {
      state.position++;
      state.tag = _tag;
      state.anchor = _anchor;
      state.kind = isMapping ? 'mapping' : 'sequence';
      state.result = _result;
      return true;
    } else if (!readNext) {
      throwError(state, 'missed comma between flow collection entries');
    }

    keyTag = keyNode = valueNode = null;
    isPair = isExplicitPair = false;

    if (ch === 0x3F /* ? */) {
        following = state.input.charCodeAt(state.position + 1);

        if (is_WS_OR_EOL(following)) {
          isPair = isExplicitPair = true;
          state.position++;
          skipSeparationSpace(state, true, nodeIndent);
        }
      }

    _line = state.line;
    composeNode(state, nodeIndent, CONTEXT_FLOW_IN, false, true);
    keyTag = state.tag;
    keyNode = state.result;
    skipSeparationSpace(state, true, nodeIndent);

    ch = state.input.charCodeAt(state.position);

    if ((isExplicitPair || state.line === _line) && ch === 0x3A /* : */) {
        isPair = true;
        ch = state.input.charCodeAt(++state.position);
        skipSeparationSpace(state, true, nodeIndent);
        composeNode(state, nodeIndent, CONTEXT_FLOW_IN, false, true);
        valueNode = state.result;
      }

    if (isMapping) {
      storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, valueNode);
    } else if (isPair) {
      _result.push(storeMappingPair(state, null, overridableKeys, keyTag, keyNode, valueNode));
    } else {
      _result.push(keyNode);
    }

    skipSeparationSpace(state, true, nodeIndent);

    ch = state.input.charCodeAt(state.position);

    if (ch === 0x2C /* , */) {
        readNext = true;
        ch = state.input.charCodeAt(++state.position);
      } else {
      readNext = false;
    }
  }

  throwError(state, 'unexpected end of the stream within a flow collection');
}

function readBlockScalar(state, nodeIndent) {
  var captureStart,
      folding,
      chomping = CHOMPING_CLIP,
      didReadContent = false,
      detectedIndent = false,
      textIndent = nodeIndent,
      emptyLines = 0,
      atMoreIndented = false,
      tmp,
      ch;

  ch = state.input.charCodeAt(state.position);

  if (ch === 0x7C /* | */) {
      folding = false;
    } else if (ch === 0x3E /* > */) {
      folding = true;
    } else {
    return false;
  }

  state.kind = 'scalar';
  state.result = '';

  while (ch !== 0) {
    ch = state.input.charCodeAt(++state.position);

    if (ch === 0x2B /* + */ || ch === 0x2D /* - */) {
        if (CHOMPING_CLIP === chomping) {
          chomping = ch === 0x2B /* + */ ? CHOMPING_KEEP : CHOMPING_STRIP;
        } else {
          throwError(state, 'repeat of a chomping mode identifier');
        }
      } else if ((tmp = fromDecimalCode(ch)) >= 0) {
      if (tmp === 0) {
        throwError(state, 'bad explicit indentation width of a block scalar; it cannot be less than one');
      } else if (!detectedIndent) {
        textIndent = nodeIndent + tmp - 1;
        detectedIndent = true;
      } else {
        throwError(state, 'repeat of an indentation width identifier');
      }
    } else {
      break;
    }
  }

  if (is_WHITE_SPACE(ch)) {
    do {
      ch = state.input.charCodeAt(++state.position);
    } while (is_WHITE_SPACE(ch));

    if (ch === 0x23 /* # */) {
        do {
          ch = state.input.charCodeAt(++state.position);
        } while (!is_EOL(ch) && ch !== 0);
      }
  }

  while (ch !== 0) {
    readLineBreak(state);
    state.lineIndent = 0;

    ch = state.input.charCodeAt(state.position);

    while ((!detectedIndent || state.lineIndent < textIndent) && ch === 0x20 /* Space */) {
      state.lineIndent++;
      ch = state.input.charCodeAt(++state.position);
    }

    if (!detectedIndent && state.lineIndent > textIndent) {
      textIndent = state.lineIndent;
    }

    if (is_EOL(ch)) {
      emptyLines++;
      continue;
    }

    // End of the scalar.
    if (state.lineIndent < textIndent) {

      // Perform the chomping.
      if (chomping === CHOMPING_KEEP) {
        state.result += common.repeat('\n', didReadContent ? 1 + emptyLines : emptyLines);
      } else if (chomping === CHOMPING_CLIP) {
        if (didReadContent) {
          // i.e. only if the scalar is not empty.
          state.result += '\n';
        }
      }

      // Break this `while` cycle and go to the funciton's epilogue.
      break;
    }

    // Folded style: use fancy rules to handle line breaks.
    if (folding) {

      // Lines starting with white space characters (more-indented lines) are not folded.
      if (is_WHITE_SPACE(ch)) {
        atMoreIndented = true;
        // except for the first content line (cf. Example 8.1)
        state.result += common.repeat('\n', didReadContent ? 1 + emptyLines : emptyLines);

        // End of more-indented block.
      } else if (atMoreIndented) {
        atMoreIndented = false;
        state.result += common.repeat('\n', emptyLines + 1);

        // Just one line break - perceive as the same line.
      } else if (emptyLines === 0) {
        if (didReadContent) {
          // i.e. only if we have already read some scalar content.
          state.result += ' ';
        }

        // Several line breaks - perceive as different lines.
      } else {
        state.result += common.repeat('\n', emptyLines);
      }

      // Literal style: just add exact number of line breaks between content lines.
    } else {
      // Keep all line breaks except the header line break.
      state.result += common.repeat('\n', didReadContent ? 1 + emptyLines : emptyLines);
    }

    didReadContent = true;
    detectedIndent = true;
    emptyLines = 0;
    captureStart = state.position;

    while (!is_EOL(ch) && ch !== 0) {
      ch = state.input.charCodeAt(++state.position);
    }

    captureSegment(state, captureStart, state.position, false);
  }

  return true;
}

function readBlockSequence(state, nodeIndent) {
  var _line,
      _tag = state.tag,
      _anchor = state.anchor,
      _result = [],
      following,
      detected = false,
      ch;

  if (state.anchor !== null) {
    state.anchorMap[state.anchor] = _result;
  }

  ch = state.input.charCodeAt(state.position);

  while (ch !== 0) {

    if (ch !== 0x2D /* - */) {
        break;
      }

    following = state.input.charCodeAt(state.position + 1);

    if (!is_WS_OR_EOL(following)) {
      break;
    }

    detected = true;
    state.position++;

    if (skipSeparationSpace(state, true, -1)) {
      if (state.lineIndent <= nodeIndent) {
        _result.push(null);
        ch = state.input.charCodeAt(state.position);
        continue;
      }
    }

    _line = state.line;
    composeNode(state, nodeIndent, CONTEXT_BLOCK_IN, false, true);
    _result.push(state.result);
    skipSeparationSpace(state, true, -1);

    ch = state.input.charCodeAt(state.position);

    if ((state.line === _line || state.lineIndent > nodeIndent) && ch !== 0) {
      throwError(state, 'bad indentation of a sequence entry');
    } else if (state.lineIndent < nodeIndent) {
      break;
    }
  }

  if (detected) {
    state.tag = _tag;
    state.anchor = _anchor;
    state.kind = 'sequence';
    state.result = _result;
    return true;
  }
  return false;
}

function readBlockMapping(state, nodeIndent, flowIndent) {
  var following,
      allowCompact,
      _line,
      _pos,
      _tag = state.tag,
      _anchor = state.anchor,
      _result = {},
      overridableKeys = {},
      keyTag = null,
      keyNode = null,
      valueNode = null,
      atExplicitKey = false,
      detected = false,
      ch;

  if (state.anchor !== null) {
    state.anchorMap[state.anchor] = _result;
  }

  ch = state.input.charCodeAt(state.position);

  while (ch !== 0) {
    following = state.input.charCodeAt(state.position + 1);
    _line = state.line; // Save the current line.
    _pos = state.position;

    //
    // Explicit notation case. There are two separate blocks:
    // first for the key (denoted by "?") and second for the value (denoted by ":")
    //
    if ((ch === 0x3F /* ? */ || ch === 0x3A /* : */) && is_WS_OR_EOL(following)) {

      if (ch === 0x3F /* ? */) {
          if (atExplicitKey) {
            storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, null);
            keyTag = keyNode = valueNode = null;
          }

          detected = true;
          atExplicitKey = true;
          allowCompact = true;
        } else if (atExplicitKey) {
        // i.e. 0x3A/* : */ === character after the explicit key.
        atExplicitKey = false;
        allowCompact = true;
      } else {
        throwError(state, 'incomplete explicit mapping pair; a key node is missed; or followed by a non-tabulated empty line');
      }

      state.position += 1;
      ch = following;

      //
      // Implicit notation case. Flow-style node as the key first, then ":", and the value.
      //
    } else if (composeNode(state, flowIndent, CONTEXT_FLOW_OUT, false, true)) {

      if (state.line === _line) {
        ch = state.input.charCodeAt(state.position);

        while (is_WHITE_SPACE(ch)) {
          ch = state.input.charCodeAt(++state.position);
        }

        if (ch === 0x3A /* : */) {
            ch = state.input.charCodeAt(++state.position);

            if (!is_WS_OR_EOL(ch)) {
              throwError(state, 'a whitespace character is expected after the key-value separator within a block mapping');
            }

            if (atExplicitKey) {
              storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, null);
              keyTag = keyNode = valueNode = null;
            }

            detected = true;
            atExplicitKey = false;
            allowCompact = false;
            keyTag = state.tag;
            keyNode = state.result;
          } else if (detected) {
          throwError(state, 'can not read an implicit mapping pair; a colon is missed');
        } else {
          state.tag = _tag;
          state.anchor = _anchor;
          return true; // Keep the result of `composeNode`.
        }
      } else if (detected) {
        throwError(state, 'can not read a block mapping entry; a multiline key may not be an implicit key');
      } else {
        state.tag = _tag;
        state.anchor = _anchor;
        return true; // Keep the result of `composeNode`.
      }
    } else {
        break; // Reading is done. Go to the epilogue.
      }

    //
    // Common reading code for both explicit and implicit notations.
    //
    if (state.line === _line || state.lineIndent > nodeIndent) {
      if (composeNode(state, nodeIndent, CONTEXT_BLOCK_OUT, true, allowCompact)) {
        if (atExplicitKey) {
          keyNode = state.result;
        } else {
          valueNode = state.result;
        }
      }

      if (!atExplicitKey) {
        storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, valueNode, _line, _pos);
        keyTag = keyNode = valueNode = null;
      }

      skipSeparationSpace(state, true, -1);
      ch = state.input.charCodeAt(state.position);
    }

    if (state.lineIndent > nodeIndent && ch !== 0) {
      throwError(state, 'bad indentation of a mapping entry');
    } else if (state.lineIndent < nodeIndent) {
      break;
    }
  }

  //
  // Epilogue.
  //

  // Special case: last mapping's node contains only the key in explicit notation.
  if (atExplicitKey) {
    storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, null);
  }

  // Expose the resulting mapping.
  if (detected) {
    state.tag = _tag;
    state.anchor = _anchor;
    state.kind = 'mapping';
    state.result = _result;
  }

  return detected;
}

function readTagProperty(state) {
  var _position,
      isVerbatim = false,
      isNamed = false,
      tagHandle,
      tagName,
      ch;

  ch = state.input.charCodeAt(state.position);

  if (ch !== 0x21 /* ! */) return false;

  if (state.tag !== null) {
    throwError(state, 'duplication of a tag property');
  }

  ch = state.input.charCodeAt(++state.position);

  if (ch === 0x3C /* < */) {
      isVerbatim = true;
      ch = state.input.charCodeAt(++state.position);
    } else if (ch === 0x21 /* ! */) {
      isNamed = true;
      tagHandle = '!!';
      ch = state.input.charCodeAt(++state.position);
    } else {
    tagHandle = '!';
  }

  _position = state.position;

  if (isVerbatim) {
    do {
      ch = state.input.charCodeAt(++state.position);
    } while (ch !== 0 && ch !== 0x3E /* > */);

    if (state.position < state.length) {
      tagName = state.input.slice(_position, state.position);
      ch = state.input.charCodeAt(++state.position);
    } else {
      throwError(state, 'unexpected end of the stream within a verbatim tag');
    }
  } else {
    while (ch !== 0 && !is_WS_OR_EOL(ch)) {

      if (ch === 0x21 /* ! */) {
          if (!isNamed) {
            tagHandle = state.input.slice(_position - 1, state.position + 1);

            if (!PATTERN_TAG_HANDLE.test(tagHandle)) {
              throwError(state, 'named tag handle cannot contain such characters');
            }

            isNamed = true;
            _position = state.position + 1;
          } else {
            throwError(state, 'tag suffix cannot contain exclamation marks');
          }
        }

      ch = state.input.charCodeAt(++state.position);
    }

    tagName = state.input.slice(_position, state.position);

    if (PATTERN_FLOW_INDICATORS.test(tagName)) {
      throwError(state, 'tag suffix cannot contain flow indicator characters');
    }
  }

  if (tagName && !PATTERN_TAG_URI.test(tagName)) {
    throwError(state, 'tag name cannot contain such characters: ' + tagName);
  }

  if (isVerbatim) {
    state.tag = tagName;
  } else if (_hasOwnProperty.call(state.tagMap, tagHandle)) {
    state.tag = state.tagMap[tagHandle] + tagName;
  } else if (tagHandle === '!') {
    state.tag = '!' + tagName;
  } else if (tagHandle === '!!') {
    state.tag = 'tag:yaml.org,2002:' + tagName;
  } else {
    throwError(state, 'undeclared tag handle "' + tagHandle + '"');
  }

  return true;
}

function readAnchorProperty(state) {
  var _position, ch;

  ch = state.input.charCodeAt(state.position);

  if (ch !== 0x26 /* & */) return false;

  if (state.anchor !== null) {
    throwError(state, 'duplication of an anchor property');
  }

  ch = state.input.charCodeAt(++state.position);
  _position = state.position;

  while (ch !== 0 && !is_WS_OR_EOL(ch) && !is_FLOW_INDICATOR(ch)) {
    ch = state.input.charCodeAt(++state.position);
  }

  if (state.position === _position) {
    throwError(state, 'name of an anchor node must contain at least one character');
  }

  state.anchor = state.input.slice(_position, state.position);
  return true;
}

function readAlias(state) {
  var _position, alias, ch;

  ch = state.input.charCodeAt(state.position);

  if (ch !== 0x2A /* * */) return false;

  ch = state.input.charCodeAt(++state.position);
  _position = state.position;

  while (ch !== 0 && !is_WS_OR_EOL(ch) && !is_FLOW_INDICATOR(ch)) {
    ch = state.input.charCodeAt(++state.position);
  }

  if (state.position === _position) {
    throwError(state, 'name of an alias node must contain at least one character');
  }

  alias = state.input.slice(_position, state.position);

  if (!state.anchorMap.hasOwnProperty(alias)) {
    throwError(state, 'unidentified alias "' + alias + '"');
  }

  state.result = state.anchorMap[alias];
  skipSeparationSpace(state, true, -1);
  return true;
}

function composeNode(state, parentIndent, nodeContext, allowToSeek, allowCompact) {
  var allowBlockStyles,
      allowBlockScalars,
      allowBlockCollections,
      indentStatus = 1,
      // 1: this>parent, 0: this=parent, -1: this<parent
  atNewLine = false,
      hasContent = false,
      typeIndex,
      typeQuantity,
      type,
      flowIndent,
      blockIndent;

  if (state.listener !== null) {
    state.listener('open', state);
  }

  state.tag = null;
  state.anchor = null;
  state.kind = null;
  state.result = null;

  allowBlockStyles = allowBlockScalars = allowBlockCollections = CONTEXT_BLOCK_OUT === nodeContext || CONTEXT_BLOCK_IN === nodeContext;

  if (allowToSeek) {
    if (skipSeparationSpace(state, true, -1)) {
      atNewLine = true;

      if (state.lineIndent > parentIndent) {
        indentStatus = 1;
      } else if (state.lineIndent === parentIndent) {
        indentStatus = 0;
      } else if (state.lineIndent < parentIndent) {
        indentStatus = -1;
      }
    }
  }

  if (indentStatus === 1) {
    while (readTagProperty(state) || readAnchorProperty(state)) {
      if (skipSeparationSpace(state, true, -1)) {
        atNewLine = true;
        allowBlockCollections = allowBlockStyles;

        if (state.lineIndent > parentIndent) {
          indentStatus = 1;
        } else if (state.lineIndent === parentIndent) {
          indentStatus = 0;
        } else if (state.lineIndent < parentIndent) {
          indentStatus = -1;
        }
      } else {
        allowBlockCollections = false;
      }
    }
  }

  if (allowBlockCollections) {
    allowBlockCollections = atNewLine || allowCompact;
  }

  if (indentStatus === 1 || CONTEXT_BLOCK_OUT === nodeContext) {
    if (CONTEXT_FLOW_IN === nodeContext || CONTEXT_FLOW_OUT === nodeContext) {
      flowIndent = parentIndent;
    } else {
      flowIndent = parentIndent + 1;
    }

    blockIndent = state.position - state.lineStart;

    if (indentStatus === 1) {
      if (allowBlockCollections && (readBlockSequence(state, blockIndent) || readBlockMapping(state, blockIndent, flowIndent)) || readFlowCollection(state, flowIndent)) {
        hasContent = true;
      } else {
        if (allowBlockScalars && readBlockScalar(state, flowIndent) || readSingleQuotedScalar(state, flowIndent) || readDoubleQuotedScalar(state, flowIndent)) {
          hasContent = true;
        } else if (readAlias(state)) {
          hasContent = true;

          if (state.tag !== null || state.anchor !== null) {
            throwError(state, 'alias node should not have any properties');
          }
        } else if (readPlainScalar(state, flowIndent, CONTEXT_FLOW_IN === nodeContext)) {
          hasContent = true;

          if (state.tag === null) {
            state.tag = '?';
          }
        }

        if (state.anchor !== null) {
          state.anchorMap[state.anchor] = state.result;
        }
      }
    } else if (indentStatus === 0) {
      // Special case: block sequences are allowed to have same indentation level as the parent.
      // http://www.yaml.org/spec/1.2/spec.html#id2799784
      hasContent = allowBlockCollections && readBlockSequence(state, blockIndent);
    }
  }

  if (state.tag !== null && state.tag !== '!') {
    if (state.tag === '?') {
      for (typeIndex = 0, typeQuantity = state.implicitTypes.length; typeIndex < typeQuantity; typeIndex += 1) {
        type = state.implicitTypes[typeIndex];

        // Implicit resolving is not allowed for non-scalar types, and '?'
        // non-specific tag is only assigned to plain scalars. So, it isn't
        // needed to check for 'kind' conformity.

        if (type.resolve(state.result)) {
          // `state.result` updated in resolver if matched
          state.result = type.construct(state.result);
          state.tag = type.tag;
          if (state.anchor !== null) {
            state.anchorMap[state.anchor] = state.result;
          }
          break;
        }
      }
    } else if (_hasOwnProperty.call(state.typeMap[state.kind || 'fallback'], state.tag)) {
      type = state.typeMap[state.kind || 'fallback'][state.tag];

      if (state.result !== null && type.kind !== state.kind) {
        throwError(state, 'unacceptable node kind for !<' + state.tag + '> tag; it should be "' + type.kind + '", not "' + state.kind + '"');
      }

      if (!type.resolve(state.result)) {
        // `state.result` updated in resolver if matched
        throwError(state, 'cannot resolve a node with !<' + state.tag + '> explicit tag');
      } else {
        state.result = type.construct(state.result);
        if (state.anchor !== null) {
          state.anchorMap[state.anchor] = state.result;
        }
      }
    } else {
      throwError(state, 'unknown tag !<' + state.tag + '>');
    }
  }

  if (state.listener !== null) {
    state.listener('close', state);
  }
  return state.tag !== null || state.anchor !== null || hasContent;
}

function readDocument(state) {
  var documentStart = state.position,
      _position,
      directiveName,
      directiveArgs,
      hasDirectives = false,
      ch;

  state.version = null;
  state.checkLineBreaks = state.legacy;
  state.tagMap = {};
  state.anchorMap = {};

  while ((ch = state.input.charCodeAt(state.position)) !== 0) {
    skipSeparationSpace(state, true, -1);

    ch = state.input.charCodeAt(state.position);

    if (state.lineIndent > 0 || ch !== 0x25 /* % */) {
        break;
      }

    hasDirectives = true;
    ch = state.input.charCodeAt(++state.position);
    _position = state.position;

    while (ch !== 0 && !is_WS_OR_EOL(ch)) {
      ch = state.input.charCodeAt(++state.position);
    }

    directiveName = state.input.slice(_position, state.position);
    directiveArgs = [];

    if (directiveName.length < 1) {
      throwError(state, 'directive name must not be less than one character in length');
    }

    while (ch !== 0) {
      while (is_WHITE_SPACE(ch)) {
        ch = state.input.charCodeAt(++state.position);
      }

      if (ch === 0x23 /* # */) {
          do {
            ch = state.input.charCodeAt(++state.position);
          } while (ch !== 0 && !is_EOL(ch));
          break;
        }

      if (is_EOL(ch)) break;

      _position = state.position;

      while (ch !== 0 && !is_WS_OR_EOL(ch)) {
        ch = state.input.charCodeAt(++state.position);
      }

      directiveArgs.push(state.input.slice(_position, state.position));
    }

    if (ch !== 0) readLineBreak(state);

    if (_hasOwnProperty.call(directiveHandlers, directiveName)) {
      directiveHandlers[directiveName](state, directiveName, directiveArgs);
    } else {
      throwWarning(state, 'unknown document directive "' + directiveName + '"');
    }
  }

  skipSeparationSpace(state, true, -1);

  if (state.lineIndent === 0 && state.input.charCodeAt(state.position) === 0x2D /* - */ && state.input.charCodeAt(state.position + 1) === 0x2D /* - */ && state.input.charCodeAt(state.position + 2) === 0x2D /* - */) {
      state.position += 3;
      skipSeparationSpace(state, true, -1);
    } else if (hasDirectives) {
    throwError(state, 'directives end mark is expected');
  }

  composeNode(state, state.lineIndent - 1, CONTEXT_BLOCK_OUT, false, true);
  skipSeparationSpace(state, true, -1);

  if (state.checkLineBreaks && PATTERN_NON_ASCII_LINE_BREAKS.test(state.input.slice(documentStart, state.position))) {
    throwWarning(state, 'non-ASCII line breaks are interpreted as content');
  }

  state.documents.push(state.result);

  if (state.position === state.lineStart && testDocumentSeparator(state)) {

    if (state.input.charCodeAt(state.position) === 0x2E /* . */) {
        state.position += 3;
        skipSeparationSpace(state, true, -1);
      }
    return;
  }

  if (state.position < state.length - 1) {
    throwError(state, 'end of the stream or a document separator is expected');
  } else {
    return;
  }
}

function loadDocuments(input, options) {
  input = String(input);
  options = options || {};

  if (input.length !== 0) {

    // Add tailing `\n` if not exists
    if (input.charCodeAt(input.length - 1) !== 0x0A /* LF */ && input.charCodeAt(input.length - 1) !== 0x0D /* CR */) {
        input += '\n';
      }

    // Strip BOM
    if (input.charCodeAt(0) === 0xFEFF) {
      input = input.slice(1);
    }
  }

  var state = new State(input, options);

  // Use 0 as string terminator. That significantly simplifies bounds check.
  state.input += '\0';

  while (state.input.charCodeAt(state.position) === 0x20 /* Space */) {
    state.lineIndent += 1;
    state.position += 1;
  }

  while (state.position < state.length - 1) {
    readDocument(state);
  }

  return state.documents;
}

function loadAll(input, iterator, options) {
  var documents = loadDocuments(input, options),
      index,
      length;

  if (typeof iterator !== 'function') {
    return documents;
  }

  for (index = 0, length = documents.length; index < length; index += 1) {
    iterator(documents[index]);
  }
}

function load(input, options) {
  var documents = loadDocuments(input, options);

  if (documents.length === 0) {
    /*eslint-disable no-undefined*/
    return undefined;
  } else if (documents.length === 1) {
    return documents[0];
  }
  throw new YAMLException('expected a single document in the stream, but found more');
}

function safeLoadAll(input, output, options) {
  if (typeof output === 'function') {
    loadAll(input, output, common.extend({ schema: DEFAULT_SAFE_SCHEMA }, options));
  } else {
    return loadAll(input, common.extend({ schema: DEFAULT_SAFE_SCHEMA }, options));
  }
}

function safeLoad(input, options) {
  return load(input, common.extend({ schema: DEFAULT_SAFE_SCHEMA }, options));
}

module.exports.loadAll = loadAll;
module.exports.load = load;
module.exports.safeLoadAll = safeLoadAll;
module.exports.safeLoad = safeLoad;

/***/ }),
/* 139 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var common = __webpack_require__(17);

function Mark(name, buffer, position, line, column) {
  this.name = name;
  this.buffer = buffer;
  this.position = position;
  this.line = line;
  this.column = column;
}

Mark.prototype.getSnippet = function getSnippet(indent, maxLength) {
  var head, start, tail, end, snippet;

  if (!this.buffer) return null;

  indent = indent || 4;
  maxLength = maxLength || 75;

  head = '';
  start = this.position;

  while (start > 0 && '\x00\r\n\x85\u2028\u2029'.indexOf(this.buffer.charAt(start - 1)) === -1) {
    start -= 1;
    if (this.position - start > maxLength / 2 - 1) {
      head = ' ... ';
      start += 5;
      break;
    }
  }

  tail = '';
  end = this.position;

  while (end < this.buffer.length && '\x00\r\n\x85\u2028\u2029'.indexOf(this.buffer.charAt(end)) === -1) {
    end += 1;
    if (end - this.position > maxLength / 2 - 1) {
      tail = ' ... ';
      end -= 5;
      break;
    }
  }

  snippet = this.buffer.slice(start, end);

  return common.repeat(' ', indent) + head + snippet + tail + '\n' + common.repeat(' ', indent + this.position - start + head.length) + '^';
};

Mark.prototype.toString = function toString(compact) {
  var snippet,
      where = '';

  if (this.name) {
    where += 'in "' + this.name + '" ';
  }

  where += 'at line ' + (this.line + 1) + ', column ' + (this.column + 1);

  if (!compact) {
    snippet = this.getSnippet();

    if (snippet) {
      where += ':\n' + snippet;
    }
  }

  return where;
};

module.exports = Mark;

/***/ }),
/* 140 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var Type = __webpack_require__(4);

module.exports = new Type('tag:yaml.org,2002:str', {
  kind: 'scalar',
  construct: function (data) {
    return data !== null ? data : '';
  }
});

/***/ }),
/* 141 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var Type = __webpack_require__(4);

module.exports = new Type('tag:yaml.org,2002:seq', {
  kind: 'sequence',
  construct: function (data) {
    return data !== null ? data : [];
  }
});

/***/ }),
/* 142 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var Type = __webpack_require__(4);

module.exports = new Type('tag:yaml.org,2002:map', {
  kind: 'mapping',
  construct: function (data) {
    return data !== null ? data : {};
  }
});

/***/ }),
/* 143 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var Type = __webpack_require__(4);

function resolveYamlNull(data) {
  if (data === null) return true;

  var max = data.length;

  return max === 1 && data === '~' || max === 4 && (data === 'null' || data === 'Null' || data === 'NULL');
}

function constructYamlNull() {
  return null;
}

function isNull(object) {
  return object === null;
}

module.exports = new Type('tag:yaml.org,2002:null', {
  kind: 'scalar',
  resolve: resolveYamlNull,
  construct: constructYamlNull,
  predicate: isNull,
  represent: {
    canonical: function () {
      return '~';
    },
    lowercase: function () {
      return 'null';
    },
    uppercase: function () {
      return 'NULL';
    },
    camelcase: function () {
      return 'Null';
    }
  },
  defaultStyle: 'lowercase'
});

/***/ }),
/* 144 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var Type = __webpack_require__(4);

function resolveYamlBoolean(data) {
  if (data === null) return false;

  var max = data.length;

  return max === 4 && (data === 'true' || data === 'True' || data === 'TRUE') || max === 5 && (data === 'false' || data === 'False' || data === 'FALSE');
}

function constructYamlBoolean(data) {
  return data === 'true' || data === 'True' || data === 'TRUE';
}

function isBoolean(object) {
  return Object.prototype.toString.call(object) === '[object Boolean]';
}

module.exports = new Type('tag:yaml.org,2002:bool', {
  kind: 'scalar',
  resolve: resolveYamlBoolean,
  construct: constructYamlBoolean,
  predicate: isBoolean,
  represent: {
    lowercase: function (object) {
      return object ? 'true' : 'false';
    },
    uppercase: function (object) {
      return object ? 'TRUE' : 'FALSE';
    },
    camelcase: function (object) {
      return object ? 'True' : 'False';
    }
  },
  defaultStyle: 'lowercase'
});

/***/ }),
/* 145 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var common = __webpack_require__(17);
var Type = __webpack_require__(4);

function isHexCode(c) {
  return 0x30 /* 0 */ <= c && c <= 0x39 /* 9 */ || 0x41 /* A */ <= c && c <= 0x46 /* F */ || 0x61 /* a */ <= c && c <= 0x66 /* f */;
}

function isOctCode(c) {
  return 0x30 /* 0 */ <= c && c <= 0x37 /* 7 */;
}

function isDecCode(c) {
  return 0x30 /* 0 */ <= c && c <= 0x39 /* 9 */;
}

function resolveYamlInteger(data) {
  if (data === null) return false;

  var max = data.length,
      index = 0,
      hasDigits = false,
      ch;

  if (!max) return false;

  ch = data[index];

  // sign
  if (ch === '-' || ch === '+') {
    ch = data[++index];
  }

  if (ch === '0') {
    // 0
    if (index + 1 === max) return true;
    ch = data[++index];

    // base 2, base 8, base 16

    if (ch === 'b') {
      // base 2
      index++;

      for (; index < max; index++) {
        ch = data[index];
        if (ch === '_') continue;
        if (ch !== '0' && ch !== '1') return false;
        hasDigits = true;
      }
      return hasDigits && ch !== '_';
    }

    if (ch === 'x') {
      // base 16
      index++;

      for (; index < max; index++) {
        ch = data[index];
        if (ch === '_') continue;
        if (!isHexCode(data.charCodeAt(index))) return false;
        hasDigits = true;
      }
      return hasDigits && ch !== '_';
    }

    // base 8
    for (; index < max; index++) {
      ch = data[index];
      if (ch === '_') continue;
      if (!isOctCode(data.charCodeAt(index))) return false;
      hasDigits = true;
    }
    return hasDigits && ch !== '_';
  }

  // base 10 (except 0) or base 60

  // value should not start with `_`;
  if (ch === '_') return false;

  for (; index < max; index++) {
    ch = data[index];
    if (ch === '_') continue;
    if (ch === ':') break;
    if (!isDecCode(data.charCodeAt(index))) {
      return false;
    }
    hasDigits = true;
  }

  // Should have digits and should not end with `_`
  if (!hasDigits || ch === '_') return false;

  // if !base60 - done;
  if (ch !== ':') return true;

  // base60 almost not used, no needs to optimize
  return (/^(:[0-5]?[0-9])+$/.test(data.slice(index))
  );
}

function constructYamlInteger(data) {
  var value = data,
      sign = 1,
      ch,
      base,
      digits = [];

  if (value.indexOf('_') !== -1) {
    value = value.replace(/_/g, '');
  }

  ch = value[0];

  if (ch === '-' || ch === '+') {
    if (ch === '-') sign = -1;
    value = value.slice(1);
    ch = value[0];
  }

  if (value === '0') return 0;

  if (ch === '0') {
    if (value[1] === 'b') return sign * parseInt(value.slice(2), 2);
    if (value[1] === 'x') return sign * parseInt(value, 16);
    return sign * parseInt(value, 8);
  }

  if (value.indexOf(':') !== -1) {
    value.split(':').forEach(function (v) {
      digits.unshift(parseInt(v, 10));
    });

    value = 0;
    base = 1;

    digits.forEach(function (d) {
      value += d * base;
      base *= 60;
    });

    return sign * value;
  }

  return sign * parseInt(value, 10);
}

function isInteger(object) {
  return Object.prototype.toString.call(object) === '[object Number]' && object % 1 === 0 && !common.isNegativeZero(object);
}

module.exports = new Type('tag:yaml.org,2002:int', {
  kind: 'scalar',
  resolve: resolveYamlInteger,
  construct: constructYamlInteger,
  predicate: isInteger,
  represent: {
    binary: function (object) {
      return '0b' + object.toString(2);
    },
    octal: function (object) {
      return '0' + object.toString(8);
    },
    decimal: function (object) {
      return object.toString(10);
    },
    hexadecimal: function (object) {
      return '0x' + object.toString(16).toUpperCase();
    }
  },
  defaultStyle: 'decimal',
  styleAliases: {
    binary: [2, 'bin'],
    octal: [8, 'oct'],
    decimal: [10, 'dec'],
    hexadecimal: [16, 'hex']
  }
});

/***/ }),
/* 146 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var common = __webpack_require__(17);
var Type = __webpack_require__(4);

var YAML_FLOAT_PATTERN = new RegExp(
// 2.5e4, 2.5 and integers
'^(?:[-+]?(?:0|[1-9][0-9_]*)(?:\\.[0-9_]*)?(?:[eE][-+]?[0-9]+)?' +
// .2e4, .2
// special case, seems not from spec
'|\\.[0-9_]+(?:[eE][-+]?[0-9]+)?' +
// 20:59
'|[-+]?[0-9][0-9_]*(?::[0-5]?[0-9])+\\.[0-9_]*' +
// .inf
'|[-+]?\\.(?:inf|Inf|INF)' +
// .nan
'|\\.(?:nan|NaN|NAN))$');

function resolveYamlFloat(data) {
  if (data === null) return false;

  if (!YAML_FLOAT_PATTERN.test(data) ||
  // Quick hack to not allow integers end with `_`
  // Probably should update regexp & check speed
  data[data.length - 1] === '_') {
    return false;
  }

  return true;
}

function constructYamlFloat(data) {
  var value, sign, base, digits;

  value = data.replace(/_/g, '').toLowerCase();
  sign = value[0] === '-' ? -1 : 1;
  digits = [];

  if ('+-'.indexOf(value[0]) >= 0) {
    value = value.slice(1);
  }

  if (value === '.inf') {
    return sign === 1 ? Number.POSITIVE_INFINITY : Number.NEGATIVE_INFINITY;
  } else if (value === '.nan') {
    return NaN;
  } else if (value.indexOf(':') >= 0) {
    value.split(':').forEach(function (v) {
      digits.unshift(parseFloat(v, 10));
    });

    value = 0.0;
    base = 1;

    digits.forEach(function (d) {
      value += d * base;
      base *= 60;
    });

    return sign * value;
  }
  return sign * parseFloat(value, 10);
}

var SCIENTIFIC_WITHOUT_DOT = /^[-+]?[0-9]+e/;

function representYamlFloat(object, style) {
  var res;

  if (isNaN(object)) {
    switch (style) {
      case 'lowercase':
        return '.nan';
      case 'uppercase':
        return '.NAN';
      case 'camelcase':
        return '.NaN';
    }
  } else if (Number.POSITIVE_INFINITY === object) {
    switch (style) {
      case 'lowercase':
        return '.inf';
      case 'uppercase':
        return '.INF';
      case 'camelcase':
        return '.Inf';
    }
  } else if (Number.NEGATIVE_INFINITY === object) {
    switch (style) {
      case 'lowercase':
        return '-.inf';
      case 'uppercase':
        return '-.INF';
      case 'camelcase':
        return '-.Inf';
    }
  } else if (common.isNegativeZero(object)) {
    return '-0.0';
  }

  res = object.toString(10);

  // JS stringifier can build scientific format without dots: 5e-100,
  // while YAML requres dot: 5.e-100. Fix it with simple hack

  return SCIENTIFIC_WITHOUT_DOT.test(res) ? res.replace('e', '.e') : res;
}

function isFloat(object) {
  return Object.prototype.toString.call(object) === '[object Number]' && (object % 1 !== 0 || common.isNegativeZero(object));
}

module.exports = new Type('tag:yaml.org,2002:float', {
  kind: 'scalar',
  resolve: resolveYamlFloat,
  construct: constructYamlFloat,
  predicate: isFloat,
  represent: representYamlFloat,
  defaultStyle: 'lowercase'
});

/***/ }),
/* 147 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var Type = __webpack_require__(4);

var YAML_DATE_REGEXP = new RegExp('^([0-9][0-9][0-9][0-9])' + // [1] year
'-([0-9][0-9])' + // [2] month
'-([0-9][0-9])$'); // [3] day

var YAML_TIMESTAMP_REGEXP = new RegExp('^([0-9][0-9][0-9][0-9])' + // [1] year
'-([0-9][0-9]?)' + // [2] month
'-([0-9][0-9]?)' + // [3] day
'(?:[Tt]|[ \\t]+)' + // ...
'([0-9][0-9]?)' + // [4] hour
':([0-9][0-9])' + // [5] minute
':([0-9][0-9])' + // [6] second
'(?:\\.([0-9]*))?' + // [7] fraction
'(?:[ \\t]*(Z|([-+])([0-9][0-9]?)' + // [8] tz [9] tz_sign [10] tz_hour
'(?::([0-9][0-9]))?))?$'); // [11] tz_minute

function resolveYamlTimestamp(data) {
  if (data === null) return false;
  if (YAML_DATE_REGEXP.exec(data) !== null) return true;
  if (YAML_TIMESTAMP_REGEXP.exec(data) !== null) return true;
  return false;
}

function constructYamlTimestamp(data) {
  var match,
      year,
      month,
      day,
      hour,
      minute,
      second,
      fraction = 0,
      delta = null,
      tz_hour,
      tz_minute,
      date;

  match = YAML_DATE_REGEXP.exec(data);
  if (match === null) match = YAML_TIMESTAMP_REGEXP.exec(data);

  if (match === null) throw new Error('Date resolve error');

  // match: [1] year [2] month [3] day

  year = +match[1];
  month = +match[2] - 1; // JS month starts with 0
  day = +match[3];

  if (!match[4]) {
    // no hour
    return new Date(Date.UTC(year, month, day));
  }

  // match: [4] hour [5] minute [6] second [7] fraction

  hour = +match[4];
  minute = +match[5];
  second = +match[6];

  if (match[7]) {
    fraction = match[7].slice(0, 3);
    while (fraction.length < 3) {
      // milli-seconds
      fraction += '0';
    }
    fraction = +fraction;
  }

  // match: [8] tz [9] tz_sign [10] tz_hour [11] tz_minute

  if (match[9]) {
    tz_hour = +match[10];
    tz_minute = +(match[11] || 0);
    delta = (tz_hour * 60 + tz_minute) * 60000; // delta in mili-seconds
    if (match[9] === '-') delta = -delta;
  }

  date = new Date(Date.UTC(year, month, day, hour, minute, second, fraction));

  if (delta) date.setTime(date.getTime() - delta);

  return date;
}

function representYamlTimestamp(object /*, style*/) {
  return object.toISOString();
}

module.exports = new Type('tag:yaml.org,2002:timestamp', {
  kind: 'scalar',
  resolve: resolveYamlTimestamp,
  construct: constructYamlTimestamp,
  instanceOf: Date,
  represent: representYamlTimestamp
});

/***/ }),
/* 148 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var Type = __webpack_require__(4);

function resolveYamlMerge(data) {
  return data === '<<' || data === null;
}

module.exports = new Type('tag:yaml.org,2002:merge', {
  kind: 'scalar',
  resolve: resolveYamlMerge
});

/***/ }),
/* 149 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var require;

/*eslint-disable no-bitwise*/

var NodeBuffer;

try {
  // A trick for browserified version, to not include `Buffer` shim
  var _require = require;
  NodeBuffer = __webpack_require__(150).Buffer;
} catch (__) {}

var Type = __webpack_require__(4);

// [ 64, 65, 66 ] -> [ padding, CR, LF ]
var BASE64_MAP = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\n\r';

function resolveYamlBinary(data) {
  if (data === null) return false;

  var code,
      idx,
      bitlen = 0,
      max = data.length,
      map = BASE64_MAP;

  // Convert one by one.
  for (idx = 0; idx < max; idx++) {
    code = map.indexOf(data.charAt(idx));

    // Skip CR/LF
    if (code > 64) continue;

    // Fail on illegal characters
    if (code < 0) return false;

    bitlen += 6;
  }

  // If there are any bits left, source was corrupted
  return bitlen % 8 === 0;
}

function constructYamlBinary(data) {
  var idx,
      tailbits,
      input = data.replace(/[\r\n=]/g, ''),
      // remove CR/LF & padding to simplify scan
  max = input.length,
      map = BASE64_MAP,
      bits = 0,
      result = [];

  // Collect by 6*4 bits (3 bytes)

  for (idx = 0; idx < max; idx++) {
    if (idx % 4 === 0 && idx) {
      result.push(bits >> 16 & 0xFF);
      result.push(bits >> 8 & 0xFF);
      result.push(bits & 0xFF);
    }

    bits = bits << 6 | map.indexOf(input.charAt(idx));
  }

  // Dump tail

  tailbits = max % 4 * 6;

  if (tailbits === 0) {
    result.push(bits >> 16 & 0xFF);
    result.push(bits >> 8 & 0xFF);
    result.push(bits & 0xFF);
  } else if (tailbits === 18) {
    result.push(bits >> 10 & 0xFF);
    result.push(bits >> 2 & 0xFF);
  } else if (tailbits === 12) {
    result.push(bits >> 4 & 0xFF);
  }

  // Wrap into Buffer for NodeJS and leave Array for browser
  if (NodeBuffer) {
    // Support node 6.+ Buffer API when available
    return NodeBuffer.from ? NodeBuffer.from(result) : new NodeBuffer(result);
  }

  return result;
}

function representYamlBinary(object /*, style*/) {
  var result = '',
      bits = 0,
      idx,
      tail,
      max = object.length,
      map = BASE64_MAP;

  // Convert every three bytes to 4 ASCII characters.

  for (idx = 0; idx < max; idx++) {
    if (idx % 3 === 0 && idx) {
      result += map[bits >> 18 & 0x3F];
      result += map[bits >> 12 & 0x3F];
      result += map[bits >> 6 & 0x3F];
      result += map[bits & 0x3F];
    }

    bits = (bits << 8) + object[idx];
  }

  // Dump tail

  tail = max % 3;

  if (tail === 0) {
    result += map[bits >> 18 & 0x3F];
    result += map[bits >> 12 & 0x3F];
    result += map[bits >> 6 & 0x3F];
    result += map[bits & 0x3F];
  } else if (tail === 2) {
    result += map[bits >> 10 & 0x3F];
    result += map[bits >> 4 & 0x3F];
    result += map[bits << 2 & 0x3F];
    result += map[64];
  } else if (tail === 1) {
    result += map[bits >> 2 & 0x3F];
    result += map[bits << 4 & 0x3F];
    result += map[64];
    result += map[64];
  }

  return result;
}

function isBinary(object) {
  return NodeBuffer && NodeBuffer.isBuffer(object);
}

module.exports = new Type('tag:yaml.org,2002:binary', {
  kind: 'scalar',
  resolve: resolveYamlBinary,
  construct: constructYamlBinary,
  predicate: isBinary,
  represent: representYamlBinary
});

/***/ }),
/* 150 */
/***/ (function(module, exports) {

module.exports = require("buffer");

/***/ }),
/* 151 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var Type = __webpack_require__(4);

var _hasOwnProperty = Object.prototype.hasOwnProperty;
var _toString = Object.prototype.toString;

function resolveYamlOmap(data) {
  if (data === null) return true;

  var objectKeys = [],
      index,
      length,
      pair,
      pairKey,
      pairHasKey,
      object = data;

  for (index = 0, length = object.length; index < length; index += 1) {
    pair = object[index];
    pairHasKey = false;

    if (_toString.call(pair) !== '[object Object]') return false;

    for (pairKey in pair) {
      if (_hasOwnProperty.call(pair, pairKey)) {
        if (!pairHasKey) pairHasKey = true;else return false;
      }
    }

    if (!pairHasKey) return false;

    if (objectKeys.indexOf(pairKey) === -1) objectKeys.push(pairKey);else return false;
  }

  return true;
}

function constructYamlOmap(data) {
  return data !== null ? data : [];
}

module.exports = new Type('tag:yaml.org,2002:omap', {
  kind: 'sequence',
  resolve: resolveYamlOmap,
  construct: constructYamlOmap
});

/***/ }),
/* 152 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var Type = __webpack_require__(4);

var _toString = Object.prototype.toString;

function resolveYamlPairs(data) {
  if (data === null) return true;

  var index,
      length,
      pair,
      keys,
      result,
      object = data;

  result = new Array(object.length);

  for (index = 0, length = object.length; index < length; index += 1) {
    pair = object[index];

    if (_toString.call(pair) !== '[object Object]') return false;

    keys = Object.keys(pair);

    if (keys.length !== 1) return false;

    result[index] = [keys[0], pair[keys[0]]];
  }

  return true;
}

function constructYamlPairs(data) {
  if (data === null) return [];

  var index,
      length,
      pair,
      keys,
      result,
      object = data;

  result = new Array(object.length);

  for (index = 0, length = object.length; index < length; index += 1) {
    pair = object[index];

    keys = Object.keys(pair);

    result[index] = [keys[0], pair[keys[0]]];
  }

  return result;
}

module.exports = new Type('tag:yaml.org,2002:pairs', {
  kind: 'sequence',
  resolve: resolveYamlPairs,
  construct: constructYamlPairs
});

/***/ }),
/* 153 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var Type = __webpack_require__(4);

var _hasOwnProperty = Object.prototype.hasOwnProperty;

function resolveYamlSet(data) {
  if (data === null) return true;

  var key,
      object = data;

  for (key in object) {
    if (_hasOwnProperty.call(object, key)) {
      if (object[key] !== null) return false;
    }
  }

  return true;
}

function constructYamlSet(data) {
  return data !== null ? data : {};
}

module.exports = new Type('tag:yaml.org,2002:set', {
  kind: 'mapping',
  resolve: resolveYamlSet,
  construct: constructYamlSet
});

/***/ }),
/* 154 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var Type = __webpack_require__(4);

function resolveJavascriptUndefined() {
  return true;
}

function constructJavascriptUndefined() {
  /*eslint-disable no-undefined*/
  return undefined;
}

function representJavascriptUndefined() {
  return '';
}

function isUndefined(object) {
  return typeof object === 'undefined';
}

module.exports = new Type('tag:yaml.org,2002:js/undefined', {
  kind: 'scalar',
  resolve: resolveJavascriptUndefined,
  construct: constructJavascriptUndefined,
  predicate: isUndefined,
  represent: representJavascriptUndefined
});

/***/ }),
/* 155 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var Type = __webpack_require__(4);

function resolveJavascriptRegExp(data) {
  if (data === null) return false;
  if (data.length === 0) return false;

  var regexp = data,
      tail = /\/([gim]*)$/.exec(data),
      modifiers = '';

  // if regexp starts with '/' it can have modifiers and must be properly closed
  // `/foo/gim` - modifiers tail can be maximum 3 chars
  if (regexp[0] === '/') {
    if (tail) modifiers = tail[1];

    if (modifiers.length > 3) return false;
    // if expression starts with /, is should be properly terminated
    if (regexp[regexp.length - modifiers.length - 1] !== '/') return false;
  }

  return true;
}

function constructJavascriptRegExp(data) {
  var regexp = data,
      tail = /\/([gim]*)$/.exec(data),
      modifiers = '';

  // `/foo/gim` - tail can be maximum 4 chars
  if (regexp[0] === '/') {
    if (tail) modifiers = tail[1];
    regexp = regexp.slice(1, regexp.length - modifiers.length - 1);
  }

  return new RegExp(regexp, modifiers);
}

function representJavascriptRegExp(object /*, style*/) {
  var result = '/' + object.source + '/';

  if (object.global) result += 'g';
  if (object.multiline) result += 'm';
  if (object.ignoreCase) result += 'i';

  return result;
}

function isRegExp(object) {
  return Object.prototype.toString.call(object) === '[object RegExp]';
}

module.exports = new Type('tag:yaml.org,2002:js/regexp', {
  kind: 'scalar',
  resolve: resolveJavascriptRegExp,
  construct: constructJavascriptRegExp,
  predicate: isRegExp,
  represent: representJavascriptRegExp
});

/***/ }),
/* 156 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var require;

var esprima;

// Browserified version does not have esprima
//
// 1. For node.js just require module as deps
// 2. For browser try to require mudule via external AMD system.
//    If not found - try to fallback to window.esprima. If not
//    found too - then fail to parse.
//
try {
  // workaround to exclude package from browserify list.
  var _require = require;
  esprima = __webpack_require__(157);
} catch (_) {
  /*global window */
  if (typeof window !== 'undefined') esprima = window.esprima;
}

var Type = __webpack_require__(4);

function resolveJavascriptFunction(data) {
  if (data === null) return false;

  try {
    var source = '(' + data + ')',
        ast = esprima.parse(source, { range: true });

    if (ast.type !== 'Program' || ast.body.length !== 1 || ast.body[0].type !== 'ExpressionStatement' || ast.body[0].expression.type !== 'FunctionExpression') {
      return false;
    }

    return true;
  } catch (err) {
    return false;
  }
}

function constructJavascriptFunction(data) {
  /*jslint evil:true*/

  var source = '(' + data + ')',
      ast = esprima.parse(source, { range: true }),
      params = [],
      body;

  if (ast.type !== 'Program' || ast.body.length !== 1 || ast.body[0].type !== 'ExpressionStatement' || ast.body[0].expression.type !== 'FunctionExpression') {
    throw new Error('Failed to resolve function');
  }

  ast.body[0].expression.params.forEach(function (param) {
    params.push(param.name);
  });

  body = ast.body[0].expression.body.range;

  // Esprima's ranges include the first '{' and the last '}' characters on
  // function expressions. So cut them out.
  /*eslint-disable no-new-func*/
  return new Function(params, source.slice(body[0] + 1, body[1] - 1));
}

function representJavascriptFunction(object /*, style*/) {
  return object.toString();
}

function isFunction(object) {
  return Object.prototype.toString.call(object) === '[object Function]';
}

module.exports = new Type('tag:yaml.org,2002:js/function', {
  kind: 'scalar',
  resolve: resolveJavascriptFunction,
  construct: constructJavascriptFunction,
  predicate: isFunction,
  represent: representJavascriptFunction
});

/***/ }),
/* 157 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


(function webpackUniversalModuleDefinition(root, factory) {
	/* istanbul ignore next */
	if (true) module.exports = factory();else if (typeof define === 'function' && define.amd) define([], factory);
	/* istanbul ignore next */
	else if (typeof exports === 'object') exports["esprima"] = factory();else root["esprima"] = factory();
})(undefined, function () {
	return (/******/function (modules) {
			// webpackBootstrap
			/******/ // The module cache
			/******/var installedModules = {};

			/******/ // The require function
			/******/function __webpack_require__(moduleId) {

				/******/ // Check if module is in cache
				/* istanbul ignore if */
				/******/if (installedModules[moduleId])
					/******/return installedModules[moduleId].exports;

				/******/ // Create a new module (and put it into the cache)
				/******/var module = installedModules[moduleId] = {
					/******/exports: {},
					/******/id: moduleId,
					/******/loaded: false
					/******/ };

				/******/ // Execute the module function
				/******/modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);

				/******/ // Flag the module as loaded
				/******/module.loaded = true;

				/******/ // Return the exports of the module
				/******/return module.exports;
				/******/
			}

			/******/ // expose the modules object (__webpack_modules__)
			/******/__webpack_require__.m = modules;

			/******/ // expose the module cache
			/******/__webpack_require__.c = installedModules;

			/******/ // __webpack_public_path__
			/******/__webpack_require__.p = "";

			/******/ // Load entry module and return exports
			/******/return __webpack_require__(0);
			/******/
		}(
		/************************************************************************/
		/******/[
		/* 0 */
		/***/function (module, exports, __webpack_require__) {

			"use strict";
			/*
     Copyright JS Foundation and other contributors, https://js.foundation/
   
     Redistribution and use in source and binary forms, with or without
     modification, are permitted provided that the following conditions are met:
   
       * Redistributions of source code must retain the above copyright
         notice, this list of conditions and the following disclaimer.
       * Redistributions in binary form must reproduce the above copyright
         notice, this list of conditions and the following disclaimer in the
         documentation and/or other materials provided with the distribution.
   
     THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
     AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
     IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
     ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY
     DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
     (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
     LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
     ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
     (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
     THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
   */

			Object.defineProperty(exports, "__esModule", { value: true });
			var comment_handler_1 = __webpack_require__(1);
			var jsx_parser_1 = __webpack_require__(3);
			var parser_1 = __webpack_require__(8);
			var tokenizer_1 = __webpack_require__(15);
			function parse(code, options, delegate) {
				var commentHandler = null;
				var proxyDelegate = function (node, metadata) {
					if (delegate) {
						delegate(node, metadata);
					}
					if (commentHandler) {
						commentHandler.visit(node, metadata);
					}
				};
				var parserDelegate = typeof delegate === 'function' ? proxyDelegate : null;
				var collectComment = false;
				if (options) {
					collectComment = typeof options.comment === 'boolean' && options.comment;
					var attachComment = typeof options.attachComment === 'boolean' && options.attachComment;
					if (collectComment || attachComment) {
						commentHandler = new comment_handler_1.CommentHandler();
						commentHandler.attach = attachComment;
						options.comment = true;
						parserDelegate = proxyDelegate;
					}
				}
				var isModule = false;
				if (options && typeof options.sourceType === 'string') {
					isModule = options.sourceType === 'module';
				}
				var parser;
				if (options && typeof options.jsx === 'boolean' && options.jsx) {
					parser = new jsx_parser_1.JSXParser(code, options, parserDelegate);
				} else {
					parser = new parser_1.Parser(code, options, parserDelegate);
				}
				var program = isModule ? parser.parseModule() : parser.parseScript();
				var ast = program;
				if (collectComment && commentHandler) {
					ast.comments = commentHandler.comments;
				}
				if (parser.config.tokens) {
					ast.tokens = parser.tokens;
				}
				if (parser.config.tolerant) {
					ast.errors = parser.errorHandler.errors;
				}
				return ast;
			}
			exports.parse = parse;
			function parseModule(code, options, delegate) {
				var parsingOptions = options || {};
				parsingOptions.sourceType = 'module';
				return parse(code, parsingOptions, delegate);
			}
			exports.parseModule = parseModule;
			function parseScript(code, options, delegate) {
				var parsingOptions = options || {};
				parsingOptions.sourceType = 'script';
				return parse(code, parsingOptions, delegate);
			}
			exports.parseScript = parseScript;
			function tokenize(code, options, delegate) {
				var tokenizer = new tokenizer_1.Tokenizer(code, options);
				var tokens;
				tokens = [];
				try {
					while (true) {
						var token = tokenizer.getNextToken();
						if (!token) {
							break;
						}
						if (delegate) {
							token = delegate(token);
						}
						tokens.push(token);
					}
				} catch (e) {
					tokenizer.errorHandler.tolerate(e);
				}
				if (tokenizer.errorHandler.tolerant) {
					tokens.errors = tokenizer.errors();
				}
				return tokens;
			}
			exports.tokenize = tokenize;
			var syntax_1 = __webpack_require__(2);
			exports.Syntax = syntax_1.Syntax;
			// Sync with *.json manifests.
			exports.version = '4.0.0';

			/***/
		},
		/* 1 */
		/***/function (module, exports, __webpack_require__) {

			"use strict";

			Object.defineProperty(exports, "__esModule", { value: true });
			var syntax_1 = __webpack_require__(2);
			var CommentHandler = function () {
				function CommentHandler() {
					this.attach = false;
					this.comments = [];
					this.stack = [];
					this.leading = [];
					this.trailing = [];
				}
				CommentHandler.prototype.insertInnerComments = function (node, metadata) {
					//  innnerComments for properties empty block
					//  `function a() {/** comments **\/}`
					if (node.type === syntax_1.Syntax.BlockStatement && node.body.length === 0) {
						var innerComments = [];
						for (var i = this.leading.length - 1; i >= 0; --i) {
							var entry = this.leading[i];
							if (metadata.end.offset >= entry.start) {
								innerComments.unshift(entry.comment);
								this.leading.splice(i, 1);
								this.trailing.splice(i, 1);
							}
						}
						if (innerComments.length) {
							node.innerComments = innerComments;
						}
					}
				};
				CommentHandler.prototype.findTrailingComments = function (metadata) {
					var trailingComments = [];
					if (this.trailing.length > 0) {
						for (var i = this.trailing.length - 1; i >= 0; --i) {
							var entry_1 = this.trailing[i];
							if (entry_1.start >= metadata.end.offset) {
								trailingComments.unshift(entry_1.comment);
							}
						}
						this.trailing.length = 0;
						return trailingComments;
					}
					var entry = this.stack[this.stack.length - 1];
					if (entry && entry.node.trailingComments) {
						var firstComment = entry.node.trailingComments[0];
						if (firstComment && firstComment.range[0] >= metadata.end.offset) {
							trailingComments = entry.node.trailingComments;
							delete entry.node.trailingComments;
						}
					}
					return trailingComments;
				};
				CommentHandler.prototype.findLeadingComments = function (metadata) {
					var leadingComments = [];
					var target;
					while (this.stack.length > 0) {
						var entry = this.stack[this.stack.length - 1];
						if (entry && entry.start >= metadata.start.offset) {
							target = entry.node;
							this.stack.pop();
						} else {
							break;
						}
					}
					if (target) {
						var count = target.leadingComments ? target.leadingComments.length : 0;
						for (var i = count - 1; i >= 0; --i) {
							var comment = target.leadingComments[i];
							if (comment.range[1] <= metadata.start.offset) {
								leadingComments.unshift(comment);
								target.leadingComments.splice(i, 1);
							}
						}
						if (target.leadingComments && target.leadingComments.length === 0) {
							delete target.leadingComments;
						}
						return leadingComments;
					}
					for (var i = this.leading.length - 1; i >= 0; --i) {
						var entry = this.leading[i];
						if (entry.start <= metadata.start.offset) {
							leadingComments.unshift(entry.comment);
							this.leading.splice(i, 1);
						}
					}
					return leadingComments;
				};
				CommentHandler.prototype.visitNode = function (node, metadata) {
					if (node.type === syntax_1.Syntax.Program && node.body.length > 0) {
						return;
					}
					this.insertInnerComments(node, metadata);
					var trailingComments = this.findTrailingComments(metadata);
					var leadingComments = this.findLeadingComments(metadata);
					if (leadingComments.length > 0) {
						node.leadingComments = leadingComments;
					}
					if (trailingComments.length > 0) {
						node.trailingComments = trailingComments;
					}
					this.stack.push({
						node: node,
						start: metadata.start.offset
					});
				};
				CommentHandler.prototype.visitComment = function (node, metadata) {
					var type = node.type[0] === 'L' ? 'Line' : 'Block';
					var comment = {
						type: type,
						value: node.value
					};
					if (node.range) {
						comment.range = node.range;
					}
					if (node.loc) {
						comment.loc = node.loc;
					}
					this.comments.push(comment);
					if (this.attach) {
						var entry = {
							comment: {
								type: type,
								value: node.value,
								range: [metadata.start.offset, metadata.end.offset]
							},
							start: metadata.start.offset
						};
						if (node.loc) {
							entry.comment.loc = node.loc;
						}
						node.type = type;
						this.leading.push(entry);
						this.trailing.push(entry);
					}
				};
				CommentHandler.prototype.visit = function (node, metadata) {
					if (node.type === 'LineComment') {
						this.visitComment(node, metadata);
					} else if (node.type === 'BlockComment') {
						this.visitComment(node, metadata);
					} else if (this.attach) {
						this.visitNode(node, metadata);
					}
				};
				return CommentHandler;
			}();
			exports.CommentHandler = CommentHandler;

			/***/
		},
		/* 2 */
		/***/function (module, exports) {

			"use strict";

			Object.defineProperty(exports, "__esModule", { value: true });
			exports.Syntax = {
				AssignmentExpression: 'AssignmentExpression',
				AssignmentPattern: 'AssignmentPattern',
				ArrayExpression: 'ArrayExpression',
				ArrayPattern: 'ArrayPattern',
				ArrowFunctionExpression: 'ArrowFunctionExpression',
				AwaitExpression: 'AwaitExpression',
				BlockStatement: 'BlockStatement',
				BinaryExpression: 'BinaryExpression',
				BreakStatement: 'BreakStatement',
				CallExpression: 'CallExpression',
				CatchClause: 'CatchClause',
				ClassBody: 'ClassBody',
				ClassDeclaration: 'ClassDeclaration',
				ClassExpression: 'ClassExpression',
				ConditionalExpression: 'ConditionalExpression',
				ContinueStatement: 'ContinueStatement',
				DoWhileStatement: 'DoWhileStatement',
				DebuggerStatement: 'DebuggerStatement',
				EmptyStatement: 'EmptyStatement',
				ExportAllDeclaration: 'ExportAllDeclaration',
				ExportDefaultDeclaration: 'ExportDefaultDeclaration',
				ExportNamedDeclaration: 'ExportNamedDeclaration',
				ExportSpecifier: 'ExportSpecifier',
				ExpressionStatement: 'ExpressionStatement',
				ForStatement: 'ForStatement',
				ForOfStatement: 'ForOfStatement',
				ForInStatement: 'ForInStatement',
				FunctionDeclaration: 'FunctionDeclaration',
				FunctionExpression: 'FunctionExpression',
				Identifier: 'Identifier',
				IfStatement: 'IfStatement',
				ImportDeclaration: 'ImportDeclaration',
				ImportDefaultSpecifier: 'ImportDefaultSpecifier',
				ImportNamespaceSpecifier: 'ImportNamespaceSpecifier',
				ImportSpecifier: 'ImportSpecifier',
				Literal: 'Literal',
				LabeledStatement: 'LabeledStatement',
				LogicalExpression: 'LogicalExpression',
				MemberExpression: 'MemberExpression',
				MetaProperty: 'MetaProperty',
				MethodDefinition: 'MethodDefinition',
				NewExpression: 'NewExpression',
				ObjectExpression: 'ObjectExpression',
				ObjectPattern: 'ObjectPattern',
				Program: 'Program',
				Property: 'Property',
				RestElement: 'RestElement',
				ReturnStatement: 'ReturnStatement',
				SequenceExpression: 'SequenceExpression',
				SpreadElement: 'SpreadElement',
				Super: 'Super',
				SwitchCase: 'SwitchCase',
				SwitchStatement: 'SwitchStatement',
				TaggedTemplateExpression: 'TaggedTemplateExpression',
				TemplateElement: 'TemplateElement',
				TemplateLiteral: 'TemplateLiteral',
				ThisExpression: 'ThisExpression',
				ThrowStatement: 'ThrowStatement',
				TryStatement: 'TryStatement',
				UnaryExpression: 'UnaryExpression',
				UpdateExpression: 'UpdateExpression',
				VariableDeclaration: 'VariableDeclaration',
				VariableDeclarator: 'VariableDeclarator',
				WhileStatement: 'WhileStatement',
				WithStatement: 'WithStatement',
				YieldExpression: 'YieldExpression'
			};

			/***/
		},
		/* 3 */
		/***/function (module, exports, __webpack_require__) {

			"use strict";
			/* istanbul ignore next */

			var __extends = this && this.__extends || function () {
				var extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function (d, b) {
					d.__proto__ = b;
				} || function (d, b) {
					for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
				};
				return function (d, b) {
					extendStatics(d, b);
					function __() {
						this.constructor = d;
					}
					d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
				};
			}();
			Object.defineProperty(exports, "__esModule", { value: true });
			var character_1 = __webpack_require__(4);
			var JSXNode = __webpack_require__(5);
			var jsx_syntax_1 = __webpack_require__(6);
			var Node = __webpack_require__(7);
			var parser_1 = __webpack_require__(8);
			var token_1 = __webpack_require__(13);
			var xhtml_entities_1 = __webpack_require__(14);
			token_1.TokenName[100 /* Identifier */] = 'JSXIdentifier';
			token_1.TokenName[101 /* Text */] = 'JSXText';
			// Fully qualified element name, e.g. <svg:path> returns "svg:path"
			function getQualifiedElementName(elementName) {
				var qualifiedName;
				switch (elementName.type) {
					case jsx_syntax_1.JSXSyntax.JSXIdentifier:
						var id = elementName;
						qualifiedName = id.name;
						break;
					case jsx_syntax_1.JSXSyntax.JSXNamespacedName:
						var ns = elementName;
						qualifiedName = getQualifiedElementName(ns.namespace) + ':' + getQualifiedElementName(ns.name);
						break;
					case jsx_syntax_1.JSXSyntax.JSXMemberExpression:
						var expr = elementName;
						qualifiedName = getQualifiedElementName(expr.object) + '.' + getQualifiedElementName(expr.property);
						break;
					/* istanbul ignore next */
					default:
						break;
				}
				return qualifiedName;
			}
			var JSXParser = function (_super) {
				__extends(JSXParser, _super);
				function JSXParser(code, options, delegate) {
					return _super.call(this, code, options, delegate) || this;
				}
				JSXParser.prototype.parsePrimaryExpression = function () {
					return this.match('<') ? this.parseJSXRoot() : _super.prototype.parsePrimaryExpression.call(this);
				};
				JSXParser.prototype.startJSX = function () {
					// Unwind the scanner before the lookahead token.
					this.scanner.index = this.startMarker.index;
					this.scanner.lineNumber = this.startMarker.line;
					this.scanner.lineStart = this.startMarker.index - this.startMarker.column;
				};
				JSXParser.prototype.finishJSX = function () {
					// Prime the next lookahead.
					this.nextToken();
				};
				JSXParser.prototype.reenterJSX = function () {
					this.startJSX();
					this.expectJSX('}');
					// Pop the closing '}' added from the lookahead.
					if (this.config.tokens) {
						this.tokens.pop();
					}
				};
				JSXParser.prototype.createJSXNode = function () {
					this.collectComments();
					return {
						index: this.scanner.index,
						line: this.scanner.lineNumber,
						column: this.scanner.index - this.scanner.lineStart
					};
				};
				JSXParser.prototype.createJSXChildNode = function () {
					return {
						index: this.scanner.index,
						line: this.scanner.lineNumber,
						column: this.scanner.index - this.scanner.lineStart
					};
				};
				JSXParser.prototype.scanXHTMLEntity = function (quote) {
					var result = '&';
					var valid = true;
					var terminated = false;
					var numeric = false;
					var hex = false;
					while (!this.scanner.eof() && valid && !terminated) {
						var ch = this.scanner.source[this.scanner.index];
						if (ch === quote) {
							break;
						}
						terminated = ch === ';';
						result += ch;
						++this.scanner.index;
						if (!terminated) {
							switch (result.length) {
								case 2:
									// e.g. '&#123;'
									numeric = ch === '#';
									break;
								case 3:
									if (numeric) {
										// e.g. '&#x41;'
										hex = ch === 'x';
										valid = hex || character_1.Character.isDecimalDigit(ch.charCodeAt(0));
										numeric = numeric && !hex;
									}
									break;
								default:
									valid = valid && !(numeric && !character_1.Character.isDecimalDigit(ch.charCodeAt(0)));
									valid = valid && !(hex && !character_1.Character.isHexDigit(ch.charCodeAt(0)));
									break;
							}
						}
					}
					if (valid && terminated && result.length > 2) {
						// e.g. '&#x41;' becomes just '#x41'
						var str = result.substr(1, result.length - 2);
						if (numeric && str.length > 1) {
							result = String.fromCharCode(parseInt(str.substr(1), 10));
						} else if (hex && str.length > 2) {
							result = String.fromCharCode(parseInt('0' + str.substr(1), 16));
						} else if (!numeric && !hex && xhtml_entities_1.XHTMLEntities[str]) {
							result = xhtml_entities_1.XHTMLEntities[str];
						}
					}
					return result;
				};
				// Scan the next JSX token. This replaces Scanner#lex when in JSX mode.
				JSXParser.prototype.lexJSX = function () {
					var cp = this.scanner.source.charCodeAt(this.scanner.index);
					// < > / : = { }
					if (cp === 60 || cp === 62 || cp === 47 || cp === 58 || cp === 61 || cp === 123 || cp === 125) {
						var value = this.scanner.source[this.scanner.index++];
						return {
							type: 7 /* Punctuator */
							, value: value,
							lineNumber: this.scanner.lineNumber,
							lineStart: this.scanner.lineStart,
							start: this.scanner.index - 1,
							end: this.scanner.index
						};
					}
					// " '
					if (cp === 34 || cp === 39) {
						var start = this.scanner.index;
						var quote = this.scanner.source[this.scanner.index++];
						var str = '';
						while (!this.scanner.eof()) {
							var ch = this.scanner.source[this.scanner.index++];
							if (ch === quote) {
								break;
							} else if (ch === '&') {
								str += this.scanXHTMLEntity(quote);
							} else {
								str += ch;
							}
						}
						return {
							type: 8 /* StringLiteral */
							, value: str,
							lineNumber: this.scanner.lineNumber,
							lineStart: this.scanner.lineStart,
							start: start,
							end: this.scanner.index
						};
					}
					// ... or .
					if (cp === 46) {
						var n1 = this.scanner.source.charCodeAt(this.scanner.index + 1);
						var n2 = this.scanner.source.charCodeAt(this.scanner.index + 2);
						var value = n1 === 46 && n2 === 46 ? '...' : '.';
						var start = this.scanner.index;
						this.scanner.index += value.length;
						return {
							type: 7 /* Punctuator */
							, value: value,
							lineNumber: this.scanner.lineNumber,
							lineStart: this.scanner.lineStart,
							start: start,
							end: this.scanner.index
						};
					}
					// `
					if (cp === 96) {
						// Only placeholder, since it will be rescanned as a real assignment expression.
						return {
							type: 10 /* Template */
							, value: '',
							lineNumber: this.scanner.lineNumber,
							lineStart: this.scanner.lineStart,
							start: this.scanner.index,
							end: this.scanner.index
						};
					}
					// Identifer can not contain backslash (char code 92).
					if (character_1.Character.isIdentifierStart(cp) && cp !== 92) {
						var start = this.scanner.index;
						++this.scanner.index;
						while (!this.scanner.eof()) {
							var ch = this.scanner.source.charCodeAt(this.scanner.index);
							if (character_1.Character.isIdentifierPart(ch) && ch !== 92) {
								++this.scanner.index;
							} else if (ch === 45) {
								// Hyphen (char code 45) can be part of an identifier.
								++this.scanner.index;
							} else {
								break;
							}
						}
						var id = this.scanner.source.slice(start, this.scanner.index);
						return {
							type: 100 /* Identifier */
							, value: id,
							lineNumber: this.scanner.lineNumber,
							lineStart: this.scanner.lineStart,
							start: start,
							end: this.scanner.index
						};
					}
					return this.scanner.lex();
				};
				JSXParser.prototype.nextJSXToken = function () {
					this.collectComments();
					this.startMarker.index = this.scanner.index;
					this.startMarker.line = this.scanner.lineNumber;
					this.startMarker.column = this.scanner.index - this.scanner.lineStart;
					var token = this.lexJSX();
					this.lastMarker.index = this.scanner.index;
					this.lastMarker.line = this.scanner.lineNumber;
					this.lastMarker.column = this.scanner.index - this.scanner.lineStart;
					if (this.config.tokens) {
						this.tokens.push(this.convertToken(token));
					}
					return token;
				};
				JSXParser.prototype.nextJSXText = function () {
					this.startMarker.index = this.scanner.index;
					this.startMarker.line = this.scanner.lineNumber;
					this.startMarker.column = this.scanner.index - this.scanner.lineStart;
					var start = this.scanner.index;
					var text = '';
					while (!this.scanner.eof()) {
						var ch = this.scanner.source[this.scanner.index];
						if (ch === '{' || ch === '<') {
							break;
						}
						++this.scanner.index;
						text += ch;
						if (character_1.Character.isLineTerminator(ch.charCodeAt(0))) {
							++this.scanner.lineNumber;
							if (ch === '\r' && this.scanner.source[this.scanner.index] === '\n') {
								++this.scanner.index;
							}
							this.scanner.lineStart = this.scanner.index;
						}
					}
					this.lastMarker.index = this.scanner.index;
					this.lastMarker.line = this.scanner.lineNumber;
					this.lastMarker.column = this.scanner.index - this.scanner.lineStart;
					var token = {
						type: 101 /* Text */
						, value: text,
						lineNumber: this.scanner.lineNumber,
						lineStart: this.scanner.lineStart,
						start: start,
						end: this.scanner.index
					};
					if (text.length > 0 && this.config.tokens) {
						this.tokens.push(this.convertToken(token));
					}
					return token;
				};
				JSXParser.prototype.peekJSXToken = function () {
					var state = this.scanner.saveState();
					this.scanner.scanComments();
					var next = this.lexJSX();
					this.scanner.restoreState(state);
					return next;
				};
				// Expect the next JSX token to match the specified punctuator.
				// If not, an exception will be thrown.
				JSXParser.prototype.expectJSX = function (value) {
					var token = this.nextJSXToken();
					if (token.type !== 7 /* Punctuator */ || token.value !== value) {
						this.throwUnexpectedToken(token);
					}
				};
				// Return true if the next JSX token matches the specified punctuator.
				JSXParser.prototype.matchJSX = function (value) {
					var next = this.peekJSXToken();
					return next.type === 7 /* Punctuator */ && next.value === value;
				};
				JSXParser.prototype.parseJSXIdentifier = function () {
					var node = this.createJSXNode();
					var token = this.nextJSXToken();
					if (token.type !== 100 /* Identifier */) {
							this.throwUnexpectedToken(token);
						}
					return this.finalize(node, new JSXNode.JSXIdentifier(token.value));
				};
				JSXParser.prototype.parseJSXElementName = function () {
					var node = this.createJSXNode();
					var elementName = this.parseJSXIdentifier();
					if (this.matchJSX(':')) {
						var namespace = elementName;
						this.expectJSX(':');
						var name_1 = this.parseJSXIdentifier();
						elementName = this.finalize(node, new JSXNode.JSXNamespacedName(namespace, name_1));
					} else if (this.matchJSX('.')) {
						while (this.matchJSX('.')) {
							var object = elementName;
							this.expectJSX('.');
							var property = this.parseJSXIdentifier();
							elementName = this.finalize(node, new JSXNode.JSXMemberExpression(object, property));
						}
					}
					return elementName;
				};
				JSXParser.prototype.parseJSXAttributeName = function () {
					var node = this.createJSXNode();
					var attributeName;
					var identifier = this.parseJSXIdentifier();
					if (this.matchJSX(':')) {
						var namespace = identifier;
						this.expectJSX(':');
						var name_2 = this.parseJSXIdentifier();
						attributeName = this.finalize(node, new JSXNode.JSXNamespacedName(namespace, name_2));
					} else {
						attributeName = identifier;
					}
					return attributeName;
				};
				JSXParser.prototype.parseJSXStringLiteralAttribute = function () {
					var node = this.createJSXNode();
					var token = this.nextJSXToken();
					if (token.type !== 8 /* StringLiteral */) {
							this.throwUnexpectedToken(token);
						}
					var raw = this.getTokenRaw(token);
					return this.finalize(node, new Node.Literal(token.value, raw));
				};
				JSXParser.prototype.parseJSXExpressionAttribute = function () {
					var node = this.createJSXNode();
					this.expectJSX('{');
					this.finishJSX();
					if (this.match('}')) {
						this.tolerateError('JSX attributes must only be assigned a non-empty expression');
					}
					var expression = this.parseAssignmentExpression();
					this.reenterJSX();
					return this.finalize(node, new JSXNode.JSXExpressionContainer(expression));
				};
				JSXParser.prototype.parseJSXAttributeValue = function () {
					return this.matchJSX('{') ? this.parseJSXExpressionAttribute() : this.matchJSX('<') ? this.parseJSXElement() : this.parseJSXStringLiteralAttribute();
				};
				JSXParser.prototype.parseJSXNameValueAttribute = function () {
					var node = this.createJSXNode();
					var name = this.parseJSXAttributeName();
					var value = null;
					if (this.matchJSX('=')) {
						this.expectJSX('=');
						value = this.parseJSXAttributeValue();
					}
					return this.finalize(node, new JSXNode.JSXAttribute(name, value));
				};
				JSXParser.prototype.parseJSXSpreadAttribute = function () {
					var node = this.createJSXNode();
					this.expectJSX('{');
					this.expectJSX('...');
					this.finishJSX();
					var argument = this.parseAssignmentExpression();
					this.reenterJSX();
					return this.finalize(node, new JSXNode.JSXSpreadAttribute(argument));
				};
				JSXParser.prototype.parseJSXAttributes = function () {
					var attributes = [];
					while (!this.matchJSX('/') && !this.matchJSX('>')) {
						var attribute = this.matchJSX('{') ? this.parseJSXSpreadAttribute() : this.parseJSXNameValueAttribute();
						attributes.push(attribute);
					}
					return attributes;
				};
				JSXParser.prototype.parseJSXOpeningElement = function () {
					var node = this.createJSXNode();
					this.expectJSX('<');
					var name = this.parseJSXElementName();
					var attributes = this.parseJSXAttributes();
					var selfClosing = this.matchJSX('/');
					if (selfClosing) {
						this.expectJSX('/');
					}
					this.expectJSX('>');
					return this.finalize(node, new JSXNode.JSXOpeningElement(name, selfClosing, attributes));
				};
				JSXParser.prototype.parseJSXBoundaryElement = function () {
					var node = this.createJSXNode();
					this.expectJSX('<');
					if (this.matchJSX('/')) {
						this.expectJSX('/');
						var name_3 = this.parseJSXElementName();
						this.expectJSX('>');
						return this.finalize(node, new JSXNode.JSXClosingElement(name_3));
					}
					var name = this.parseJSXElementName();
					var attributes = this.parseJSXAttributes();
					var selfClosing = this.matchJSX('/');
					if (selfClosing) {
						this.expectJSX('/');
					}
					this.expectJSX('>');
					return this.finalize(node, new JSXNode.JSXOpeningElement(name, selfClosing, attributes));
				};
				JSXParser.prototype.parseJSXEmptyExpression = function () {
					var node = this.createJSXChildNode();
					this.collectComments();
					this.lastMarker.index = this.scanner.index;
					this.lastMarker.line = this.scanner.lineNumber;
					this.lastMarker.column = this.scanner.index - this.scanner.lineStart;
					return this.finalize(node, new JSXNode.JSXEmptyExpression());
				};
				JSXParser.prototype.parseJSXExpressionContainer = function () {
					var node = this.createJSXNode();
					this.expectJSX('{');
					var expression;
					if (this.matchJSX('}')) {
						expression = this.parseJSXEmptyExpression();
						this.expectJSX('}');
					} else {
						this.finishJSX();
						expression = this.parseAssignmentExpression();
						this.reenterJSX();
					}
					return this.finalize(node, new JSXNode.JSXExpressionContainer(expression));
				};
				JSXParser.prototype.parseJSXChildren = function () {
					var children = [];
					while (!this.scanner.eof()) {
						var node = this.createJSXChildNode();
						var token = this.nextJSXText();
						if (token.start < token.end) {
							var raw = this.getTokenRaw(token);
							var child = this.finalize(node, new JSXNode.JSXText(token.value, raw));
							children.push(child);
						}
						if (this.scanner.source[this.scanner.index] === '{') {
							var container = this.parseJSXExpressionContainer();
							children.push(container);
						} else {
							break;
						}
					}
					return children;
				};
				JSXParser.prototype.parseComplexJSXElement = function (el) {
					var stack = [];
					while (!this.scanner.eof()) {
						el.children = el.children.concat(this.parseJSXChildren());
						var node = this.createJSXChildNode();
						var element = this.parseJSXBoundaryElement();
						if (element.type === jsx_syntax_1.JSXSyntax.JSXOpeningElement) {
							var opening = element;
							if (opening.selfClosing) {
								var child = this.finalize(node, new JSXNode.JSXElement(opening, [], null));
								el.children.push(child);
							} else {
								stack.push(el);
								el = { node: node, opening: opening, closing: null, children: [] };
							}
						}
						if (element.type === jsx_syntax_1.JSXSyntax.JSXClosingElement) {
							el.closing = element;
							var open_1 = getQualifiedElementName(el.opening.name);
							var close_1 = getQualifiedElementName(el.closing.name);
							if (open_1 !== close_1) {
								this.tolerateError('Expected corresponding JSX closing tag for %0', open_1);
							}
							if (stack.length > 0) {
								var child = this.finalize(el.node, new JSXNode.JSXElement(el.opening, el.children, el.closing));
								el = stack[stack.length - 1];
								el.children.push(child);
								stack.pop();
							} else {
								break;
							}
						}
					}
					return el;
				};
				JSXParser.prototype.parseJSXElement = function () {
					var node = this.createJSXNode();
					var opening = this.parseJSXOpeningElement();
					var children = [];
					var closing = null;
					if (!opening.selfClosing) {
						var el = this.parseComplexJSXElement({ node: node, opening: opening, closing: closing, children: children });
						children = el.children;
						closing = el.closing;
					}
					return this.finalize(node, new JSXNode.JSXElement(opening, children, closing));
				};
				JSXParser.prototype.parseJSXRoot = function () {
					// Pop the opening '<' added from the lookahead.
					if (this.config.tokens) {
						this.tokens.pop();
					}
					this.startJSX();
					var element = this.parseJSXElement();
					this.finishJSX();
					return element;
				};
				JSXParser.prototype.isStartOfExpression = function () {
					return _super.prototype.isStartOfExpression.call(this) || this.match('<');
				};
				return JSXParser;
			}(parser_1.Parser);
			exports.JSXParser = JSXParser;

			/***/
		},
		/* 4 */
		/***/function (module, exports) {

			"use strict";

			Object.defineProperty(exports, "__esModule", { value: true });
			// See also tools/generate-unicode-regex.js.
			var Regex = {
				// Unicode v8.0.0 NonAsciiIdentifierStart:
				NonAsciiIdentifierStart: /[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u05D0-\u05EA\u05F0-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u08A0-\u08B4\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C60\u0C61\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1877\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF5\u1CF6\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309B-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FD5\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AD\uA7B0-\uA7B7\uA7F7-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD40-\uDD74\uDE80-\uDE9C\uDEA0-\uDED0\uDF00-\uDF1F\uDF30-\uDF4A\uDF50-\uDF75\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00\uDE10-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE4\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2]|\uD804[\uDC03-\uDC37\uDC83-\uDCAF\uDCD0-\uDCE8\uDD03-\uDD26\uDD50-\uDD72\uDD76\uDD83-\uDDB2\uDDC1-\uDDC4\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE2B\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEDE\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3D\uDF50\uDF5D-\uDF61]|\uD805[\uDC80-\uDCAF\uDCC4\uDCC5\uDCC7\uDD80-\uDDAE\uDDD8-\uDDDB\uDE00-\uDE2F\uDE44\uDE80-\uDEAA\uDF00-\uDF19]|\uD806[\uDCA0-\uDCDF\uDCFF\uDEC0-\uDEF8]|\uD808[\uDC00-\uDF99]|\uD809[\uDC00-\uDC6E\uDC80-\uDD43]|[\uD80C\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDED0-\uDEED\uDF00-\uDF2F\uDF40-\uDF43\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDF00-\uDF44\uDF50\uDF93-\uDF9F]|\uD82C[\uDC00\uDC01]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB]|\uD83A[\uDC00-\uDCC4]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1]|\uD87E[\uDC00-\uDE1D]/,
				// Unicode v8.0.0 NonAsciiIdentifierPart:
				NonAsciiIdentifierPart: /[\xAA\xB5\xB7\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0300-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u0483-\u0487\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u05D0-\u05EA\u05F0-\u05F2\u0610-\u061A\u0620-\u0669\u066E-\u06D3\u06D5-\u06DC\u06DF-\u06E8\u06EA-\u06FC\u06FF\u0710-\u074A\u074D-\u07B1\u07C0-\u07F5\u07FA\u0800-\u082D\u0840-\u085B\u08A0-\u08B4\u08E3-\u0963\u0966-\u096F\u0971-\u0983\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BC-\u09C4\u09C7\u09C8\u09CB-\u09CE\u09D7\u09DC\u09DD\u09DF-\u09E3\u09E6-\u09F1\u0A01-\u0A03\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A59-\u0A5C\u0A5E\u0A66-\u0A75\u0A81-\u0A83\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABC-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AD0\u0AE0-\u0AE3\u0AE6-\u0AEF\u0AF9\u0B01-\u0B03\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3C-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B56\u0B57\u0B5C\u0B5D\u0B5F-\u0B63\u0B66-\u0B6F\u0B71\u0B82\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD0\u0BD7\u0BE6-\u0BEF\u0C00-\u0C03\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C58-\u0C5A\u0C60-\u0C63\u0C66-\u0C6F\u0C81-\u0C83\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBC-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CDE\u0CE0-\u0CE3\u0CE6-\u0CEF\u0CF1\u0CF2\u0D01-\u0D03\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D-\u0D44\u0D46-\u0D48\u0D4A-\u0D4E\u0D57\u0D5F-\u0D63\u0D66-\u0D6F\u0D7A-\u0D7F\u0D82\u0D83\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E01-\u0E3A\u0E40-\u0E4E\u0E50-\u0E59\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB9\u0EBB-\u0EBD\u0EC0-\u0EC4\u0EC6\u0EC8-\u0ECD\u0ED0-\u0ED9\u0EDC-\u0EDF\u0F00\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E-\u0F47\u0F49-\u0F6C\u0F71-\u0F84\u0F86-\u0F97\u0F99-\u0FBC\u0FC6\u1000-\u1049\u1050-\u109D\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u135D-\u135F\u1369-\u1371\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1714\u1720-\u1734\u1740-\u1753\u1760-\u176C\u176E-\u1770\u1772\u1773\u1780-\u17D3\u17D7\u17DC\u17DD\u17E0-\u17E9\u180B-\u180D\u1810-\u1819\u1820-\u1877\u1880-\u18AA\u18B0-\u18F5\u1900-\u191E\u1920-\u192B\u1930-\u193B\u1946-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u19D0-\u19DA\u1A00-\u1A1B\u1A20-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AA7\u1AB0-\u1ABD\u1B00-\u1B4B\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1BF3\u1C00-\u1C37\u1C40-\u1C49\u1C4D-\u1C7D\u1CD0-\u1CD2\u1CD4-\u1CF6\u1CF8\u1CF9\u1D00-\u1DF5\u1DFC-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u200C\u200D\u203F\u2040\u2054\u2071\u207F\u2090-\u209C\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D7F-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2DE0-\u2DFF\u3005-\u3007\u3021-\u302F\u3031-\u3035\u3038-\u303C\u3041-\u3096\u3099-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FD5\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA62B\uA640-\uA66F\uA674-\uA67D\uA67F-\uA6F1\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AD\uA7B0-\uA7B7\uA7F7-\uA827\uA840-\uA873\uA880-\uA8C4\uA8D0-\uA8D9\uA8E0-\uA8F7\uA8FB\uA8FD\uA900-\uA92D\uA930-\uA953\uA960-\uA97C\uA980-\uA9C0\uA9CF-\uA9D9\uA9E0-\uA9FE\uAA00-\uAA36\uAA40-\uAA4D\uAA50-\uAA59\uAA60-\uAA76\uAA7A-\uAAC2\uAADB-\uAADD\uAAE0-\uAAEF\uAAF2-\uAAF6\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABEA\uABEC\uABED\uABF0-\uABF9\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE00-\uFE0F\uFE20-\uFE2F\uFE33\uFE34\uFE4D-\uFE4F\uFE70-\uFE74\uFE76-\uFEFC\uFF10-\uFF19\uFF21-\uFF3A\uFF3F\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD40-\uDD74\uDDFD\uDE80-\uDE9C\uDEA0-\uDED0\uDEE0\uDF00-\uDF1F\uDF30-\uDF4A\uDF50-\uDF7A\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDCA0-\uDCA9\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00-\uDE03\uDE05\uDE06\uDE0C-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE38-\uDE3A\uDE3F\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE6\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2]|\uD804[\uDC00-\uDC46\uDC66-\uDC6F\uDC7F-\uDCBA\uDCD0-\uDCE8\uDCF0-\uDCF9\uDD00-\uDD34\uDD36-\uDD3F\uDD50-\uDD73\uDD76\uDD80-\uDDC4\uDDCA-\uDDCC\uDDD0-\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE37\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEEA\uDEF0-\uDEF9\uDF00-\uDF03\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3C-\uDF44\uDF47\uDF48\uDF4B-\uDF4D\uDF50\uDF57\uDF5D-\uDF63\uDF66-\uDF6C\uDF70-\uDF74]|\uD805[\uDC80-\uDCC5\uDCC7\uDCD0-\uDCD9\uDD80-\uDDB5\uDDB8-\uDDC0\uDDD8-\uDDDD\uDE00-\uDE40\uDE44\uDE50-\uDE59\uDE80-\uDEB7\uDEC0-\uDEC9\uDF00-\uDF19\uDF1D-\uDF2B\uDF30-\uDF39]|\uD806[\uDCA0-\uDCE9\uDCFF\uDEC0-\uDEF8]|\uD808[\uDC00-\uDF99]|\uD809[\uDC00-\uDC6E\uDC80-\uDD43]|[\uD80C\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDE60-\uDE69\uDED0-\uDEED\uDEF0-\uDEF4\uDF00-\uDF36\uDF40-\uDF43\uDF50-\uDF59\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDF00-\uDF44\uDF50-\uDF7E\uDF8F-\uDF9F]|\uD82C[\uDC00\uDC01]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99\uDC9D\uDC9E]|\uD834[\uDD65-\uDD69\uDD6D-\uDD72\uDD7B-\uDD82\uDD85-\uDD8B\uDDAA-\uDDAD\uDE42-\uDE44]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB\uDFCE-\uDFFF]|\uD836[\uDE00-\uDE36\uDE3B-\uDE6C\uDE75\uDE84\uDE9B-\uDE9F\uDEA1-\uDEAF]|\uD83A[\uDC00-\uDCC4\uDCD0-\uDCD6]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1]|\uD87E[\uDC00-\uDE1D]|\uDB40[\uDD00-\uDDEF]/
			};
			exports.Character = {
				/* tslint:disable:no-bitwise */
				fromCodePoint: function (cp) {
					return cp < 0x10000 ? String.fromCharCode(cp) : String.fromCharCode(0xD800 + (cp - 0x10000 >> 10)) + String.fromCharCode(0xDC00 + (cp - 0x10000 & 1023));
				},
				// https://tc39.github.io/ecma262/#sec-white-space
				isWhiteSpace: function (cp) {
					return cp === 0x20 || cp === 0x09 || cp === 0x0B || cp === 0x0C || cp === 0xA0 || cp >= 0x1680 && [0x1680, 0x2000, 0x2001, 0x2002, 0x2003, 0x2004, 0x2005, 0x2006, 0x2007, 0x2008, 0x2009, 0x200A, 0x202F, 0x205F, 0x3000, 0xFEFF].indexOf(cp) >= 0;
				},
				// https://tc39.github.io/ecma262/#sec-line-terminators
				isLineTerminator: function (cp) {
					return cp === 0x0A || cp === 0x0D || cp === 0x2028 || cp === 0x2029;
				},
				// https://tc39.github.io/ecma262/#sec-names-and-keywords
				isIdentifierStart: function (cp) {
					return cp === 0x24 || cp === 0x5F || cp >= 0x41 && cp <= 0x5A || cp >= 0x61 && cp <= 0x7A || cp === 0x5C || cp >= 0x80 && Regex.NonAsciiIdentifierStart.test(exports.Character.fromCodePoint(cp));
				},
				isIdentifierPart: function (cp) {
					return cp === 0x24 || cp === 0x5F || cp >= 0x41 && cp <= 0x5A || cp >= 0x61 && cp <= 0x7A || cp >= 0x30 && cp <= 0x39 || cp === 0x5C || cp >= 0x80 && Regex.NonAsciiIdentifierPart.test(exports.Character.fromCodePoint(cp));
				},
				// https://tc39.github.io/ecma262/#sec-literals-numeric-literals
				isDecimalDigit: function (cp) {
					return cp >= 0x30 && cp <= 0x39; // 0..9
				},
				isHexDigit: function (cp) {
					return cp >= 0x30 && cp <= 0x39 || cp >= 0x41 && cp <= 0x46 || cp >= 0x61 && cp <= 0x66; // a..f
				},
				isOctalDigit: function (cp) {
					return cp >= 0x30 && cp <= 0x37; // 0..7
				}
			};

			/***/
		},
		/* 5 */
		/***/function (module, exports, __webpack_require__) {

			"use strict";

			Object.defineProperty(exports, "__esModule", { value: true });
			var jsx_syntax_1 = __webpack_require__(6);
			/* tslint:disable:max-classes-per-file */
			var JSXClosingElement = function () {
				function JSXClosingElement(name) {
					this.type = jsx_syntax_1.JSXSyntax.JSXClosingElement;
					this.name = name;
				}
				return JSXClosingElement;
			}();
			exports.JSXClosingElement = JSXClosingElement;
			var JSXElement = function () {
				function JSXElement(openingElement, children, closingElement) {
					this.type = jsx_syntax_1.JSXSyntax.JSXElement;
					this.openingElement = openingElement;
					this.children = children;
					this.closingElement = closingElement;
				}
				return JSXElement;
			}();
			exports.JSXElement = JSXElement;
			var JSXEmptyExpression = function () {
				function JSXEmptyExpression() {
					this.type = jsx_syntax_1.JSXSyntax.JSXEmptyExpression;
				}
				return JSXEmptyExpression;
			}();
			exports.JSXEmptyExpression = JSXEmptyExpression;
			var JSXExpressionContainer = function () {
				function JSXExpressionContainer(expression) {
					this.type = jsx_syntax_1.JSXSyntax.JSXExpressionContainer;
					this.expression = expression;
				}
				return JSXExpressionContainer;
			}();
			exports.JSXExpressionContainer = JSXExpressionContainer;
			var JSXIdentifier = function () {
				function JSXIdentifier(name) {
					this.type = jsx_syntax_1.JSXSyntax.JSXIdentifier;
					this.name = name;
				}
				return JSXIdentifier;
			}();
			exports.JSXIdentifier = JSXIdentifier;
			var JSXMemberExpression = function () {
				function JSXMemberExpression(object, property) {
					this.type = jsx_syntax_1.JSXSyntax.JSXMemberExpression;
					this.object = object;
					this.property = property;
				}
				return JSXMemberExpression;
			}();
			exports.JSXMemberExpression = JSXMemberExpression;
			var JSXAttribute = function () {
				function JSXAttribute(name, value) {
					this.type = jsx_syntax_1.JSXSyntax.JSXAttribute;
					this.name = name;
					this.value = value;
				}
				return JSXAttribute;
			}();
			exports.JSXAttribute = JSXAttribute;
			var JSXNamespacedName = function () {
				function JSXNamespacedName(namespace, name) {
					this.type = jsx_syntax_1.JSXSyntax.JSXNamespacedName;
					this.namespace = namespace;
					this.name = name;
				}
				return JSXNamespacedName;
			}();
			exports.JSXNamespacedName = JSXNamespacedName;
			var JSXOpeningElement = function () {
				function JSXOpeningElement(name, selfClosing, attributes) {
					this.type = jsx_syntax_1.JSXSyntax.JSXOpeningElement;
					this.name = name;
					this.selfClosing = selfClosing;
					this.attributes = attributes;
				}
				return JSXOpeningElement;
			}();
			exports.JSXOpeningElement = JSXOpeningElement;
			var JSXSpreadAttribute = function () {
				function JSXSpreadAttribute(argument) {
					this.type = jsx_syntax_1.JSXSyntax.JSXSpreadAttribute;
					this.argument = argument;
				}
				return JSXSpreadAttribute;
			}();
			exports.JSXSpreadAttribute = JSXSpreadAttribute;
			var JSXText = function () {
				function JSXText(value, raw) {
					this.type = jsx_syntax_1.JSXSyntax.JSXText;
					this.value = value;
					this.raw = raw;
				}
				return JSXText;
			}();
			exports.JSXText = JSXText;

			/***/
		},
		/* 6 */
		/***/function (module, exports) {

			"use strict";

			Object.defineProperty(exports, "__esModule", { value: true });
			exports.JSXSyntax = {
				JSXAttribute: 'JSXAttribute',
				JSXClosingElement: 'JSXClosingElement',
				JSXElement: 'JSXElement',
				JSXEmptyExpression: 'JSXEmptyExpression',
				JSXExpressionContainer: 'JSXExpressionContainer',
				JSXIdentifier: 'JSXIdentifier',
				JSXMemberExpression: 'JSXMemberExpression',
				JSXNamespacedName: 'JSXNamespacedName',
				JSXOpeningElement: 'JSXOpeningElement',
				JSXSpreadAttribute: 'JSXSpreadAttribute',
				JSXText: 'JSXText'
			};

			/***/
		},
		/* 7 */
		/***/function (module, exports, __webpack_require__) {

			"use strict";

			Object.defineProperty(exports, "__esModule", { value: true });
			var syntax_1 = __webpack_require__(2);
			/* tslint:disable:max-classes-per-file */
			var ArrayExpression = function () {
				function ArrayExpression(elements) {
					this.type = syntax_1.Syntax.ArrayExpression;
					this.elements = elements;
				}
				return ArrayExpression;
			}();
			exports.ArrayExpression = ArrayExpression;
			var ArrayPattern = function () {
				function ArrayPattern(elements) {
					this.type = syntax_1.Syntax.ArrayPattern;
					this.elements = elements;
				}
				return ArrayPattern;
			}();
			exports.ArrayPattern = ArrayPattern;
			var ArrowFunctionExpression = function () {
				function ArrowFunctionExpression(params, body, expression) {
					this.type = syntax_1.Syntax.ArrowFunctionExpression;
					this.id = null;
					this.params = params;
					this.body = body;
					this.generator = false;
					this.expression = expression;
					this.async = false;
				}
				return ArrowFunctionExpression;
			}();
			exports.ArrowFunctionExpression = ArrowFunctionExpression;
			var AssignmentExpression = function () {
				function AssignmentExpression(operator, left, right) {
					this.type = syntax_1.Syntax.AssignmentExpression;
					this.operator = operator;
					this.left = left;
					this.right = right;
				}
				return AssignmentExpression;
			}();
			exports.AssignmentExpression = AssignmentExpression;
			var AssignmentPattern = function () {
				function AssignmentPattern(left, right) {
					this.type = syntax_1.Syntax.AssignmentPattern;
					this.left = left;
					this.right = right;
				}
				return AssignmentPattern;
			}();
			exports.AssignmentPattern = AssignmentPattern;
			var AsyncArrowFunctionExpression = function () {
				function AsyncArrowFunctionExpression(params, body, expression) {
					this.type = syntax_1.Syntax.ArrowFunctionExpression;
					this.id = null;
					this.params = params;
					this.body = body;
					this.generator = false;
					this.expression = expression;
					this.async = true;
				}
				return AsyncArrowFunctionExpression;
			}();
			exports.AsyncArrowFunctionExpression = AsyncArrowFunctionExpression;
			var AsyncFunctionDeclaration = function () {
				function AsyncFunctionDeclaration(id, params, body) {
					this.type = syntax_1.Syntax.FunctionDeclaration;
					this.id = id;
					this.params = params;
					this.body = body;
					this.generator = false;
					this.expression = false;
					this.async = true;
				}
				return AsyncFunctionDeclaration;
			}();
			exports.AsyncFunctionDeclaration = AsyncFunctionDeclaration;
			var AsyncFunctionExpression = function () {
				function AsyncFunctionExpression(id, params, body) {
					this.type = syntax_1.Syntax.FunctionExpression;
					this.id = id;
					this.params = params;
					this.body = body;
					this.generator = false;
					this.expression = false;
					this.async = true;
				}
				return AsyncFunctionExpression;
			}();
			exports.AsyncFunctionExpression = AsyncFunctionExpression;
			var AwaitExpression = function () {
				function AwaitExpression(argument) {
					this.type = syntax_1.Syntax.AwaitExpression;
					this.argument = argument;
				}
				return AwaitExpression;
			}();
			exports.AwaitExpression = AwaitExpression;
			var BinaryExpression = function () {
				function BinaryExpression(operator, left, right) {
					var logical = operator === '||' || operator === '&&';
					this.type = logical ? syntax_1.Syntax.LogicalExpression : syntax_1.Syntax.BinaryExpression;
					this.operator = operator;
					this.left = left;
					this.right = right;
				}
				return BinaryExpression;
			}();
			exports.BinaryExpression = BinaryExpression;
			var BlockStatement = function () {
				function BlockStatement(body) {
					this.type = syntax_1.Syntax.BlockStatement;
					this.body = body;
				}
				return BlockStatement;
			}();
			exports.BlockStatement = BlockStatement;
			var BreakStatement = function () {
				function BreakStatement(label) {
					this.type = syntax_1.Syntax.BreakStatement;
					this.label = label;
				}
				return BreakStatement;
			}();
			exports.BreakStatement = BreakStatement;
			var CallExpression = function () {
				function CallExpression(callee, args) {
					this.type = syntax_1.Syntax.CallExpression;
					this.callee = callee;
					this.arguments = args;
				}
				return CallExpression;
			}();
			exports.CallExpression = CallExpression;
			var CatchClause = function () {
				function CatchClause(param, body) {
					this.type = syntax_1.Syntax.CatchClause;
					this.param = param;
					this.body = body;
				}
				return CatchClause;
			}();
			exports.CatchClause = CatchClause;
			var ClassBody = function () {
				function ClassBody(body) {
					this.type = syntax_1.Syntax.ClassBody;
					this.body = body;
				}
				return ClassBody;
			}();
			exports.ClassBody = ClassBody;
			var ClassDeclaration = function () {
				function ClassDeclaration(id, superClass, body) {
					this.type = syntax_1.Syntax.ClassDeclaration;
					this.id = id;
					this.superClass = superClass;
					this.body = body;
				}
				return ClassDeclaration;
			}();
			exports.ClassDeclaration = ClassDeclaration;
			var ClassExpression = function () {
				function ClassExpression(id, superClass, body) {
					this.type = syntax_1.Syntax.ClassExpression;
					this.id = id;
					this.superClass = superClass;
					this.body = body;
				}
				return ClassExpression;
			}();
			exports.ClassExpression = ClassExpression;
			var ComputedMemberExpression = function () {
				function ComputedMemberExpression(object, property) {
					this.type = syntax_1.Syntax.MemberExpression;
					this.computed = true;
					this.object = object;
					this.property = property;
				}
				return ComputedMemberExpression;
			}();
			exports.ComputedMemberExpression = ComputedMemberExpression;
			var ConditionalExpression = function () {
				function ConditionalExpression(test, consequent, alternate) {
					this.type = syntax_1.Syntax.ConditionalExpression;
					this.test = test;
					this.consequent = consequent;
					this.alternate = alternate;
				}
				return ConditionalExpression;
			}();
			exports.ConditionalExpression = ConditionalExpression;
			var ContinueStatement = function () {
				function ContinueStatement(label) {
					this.type = syntax_1.Syntax.ContinueStatement;
					this.label = label;
				}
				return ContinueStatement;
			}();
			exports.ContinueStatement = ContinueStatement;
			var DebuggerStatement = function () {
				function DebuggerStatement() {
					this.type = syntax_1.Syntax.DebuggerStatement;
				}
				return DebuggerStatement;
			}();
			exports.DebuggerStatement = DebuggerStatement;
			var Directive = function () {
				function Directive(expression, directive) {
					this.type = syntax_1.Syntax.ExpressionStatement;
					this.expression = expression;
					this.directive = directive;
				}
				return Directive;
			}();
			exports.Directive = Directive;
			var DoWhileStatement = function () {
				function DoWhileStatement(body, test) {
					this.type = syntax_1.Syntax.DoWhileStatement;
					this.body = body;
					this.test = test;
				}
				return DoWhileStatement;
			}();
			exports.DoWhileStatement = DoWhileStatement;
			var EmptyStatement = function () {
				function EmptyStatement() {
					this.type = syntax_1.Syntax.EmptyStatement;
				}
				return EmptyStatement;
			}();
			exports.EmptyStatement = EmptyStatement;
			var ExportAllDeclaration = function () {
				function ExportAllDeclaration(source) {
					this.type = syntax_1.Syntax.ExportAllDeclaration;
					this.source = source;
				}
				return ExportAllDeclaration;
			}();
			exports.ExportAllDeclaration = ExportAllDeclaration;
			var ExportDefaultDeclaration = function () {
				function ExportDefaultDeclaration(declaration) {
					this.type = syntax_1.Syntax.ExportDefaultDeclaration;
					this.declaration = declaration;
				}
				return ExportDefaultDeclaration;
			}();
			exports.ExportDefaultDeclaration = ExportDefaultDeclaration;
			var ExportNamedDeclaration = function () {
				function ExportNamedDeclaration(declaration, specifiers, source) {
					this.type = syntax_1.Syntax.ExportNamedDeclaration;
					this.declaration = declaration;
					this.specifiers = specifiers;
					this.source = source;
				}
				return ExportNamedDeclaration;
			}();
			exports.ExportNamedDeclaration = ExportNamedDeclaration;
			var ExportSpecifier = function () {
				function ExportSpecifier(local, exported) {
					this.type = syntax_1.Syntax.ExportSpecifier;
					this.exported = exported;
					this.local = local;
				}
				return ExportSpecifier;
			}();
			exports.ExportSpecifier = ExportSpecifier;
			var ExpressionStatement = function () {
				function ExpressionStatement(expression) {
					this.type = syntax_1.Syntax.ExpressionStatement;
					this.expression = expression;
				}
				return ExpressionStatement;
			}();
			exports.ExpressionStatement = ExpressionStatement;
			var ForInStatement = function () {
				function ForInStatement(left, right, body) {
					this.type = syntax_1.Syntax.ForInStatement;
					this.left = left;
					this.right = right;
					this.body = body;
					this.each = false;
				}
				return ForInStatement;
			}();
			exports.ForInStatement = ForInStatement;
			var ForOfStatement = function () {
				function ForOfStatement(left, right, body) {
					this.type = syntax_1.Syntax.ForOfStatement;
					this.left = left;
					this.right = right;
					this.body = body;
				}
				return ForOfStatement;
			}();
			exports.ForOfStatement = ForOfStatement;
			var ForStatement = function () {
				function ForStatement(init, test, update, body) {
					this.type = syntax_1.Syntax.ForStatement;
					this.init = init;
					this.test = test;
					this.update = update;
					this.body = body;
				}
				return ForStatement;
			}();
			exports.ForStatement = ForStatement;
			var FunctionDeclaration = function () {
				function FunctionDeclaration(id, params, body, generator) {
					this.type = syntax_1.Syntax.FunctionDeclaration;
					this.id = id;
					this.params = params;
					this.body = body;
					this.generator = generator;
					this.expression = false;
					this.async = false;
				}
				return FunctionDeclaration;
			}();
			exports.FunctionDeclaration = FunctionDeclaration;
			var FunctionExpression = function () {
				function FunctionExpression(id, params, body, generator) {
					this.type = syntax_1.Syntax.FunctionExpression;
					this.id = id;
					this.params = params;
					this.body = body;
					this.generator = generator;
					this.expression = false;
					this.async = false;
				}
				return FunctionExpression;
			}();
			exports.FunctionExpression = FunctionExpression;
			var Identifier = function () {
				function Identifier(name) {
					this.type = syntax_1.Syntax.Identifier;
					this.name = name;
				}
				return Identifier;
			}();
			exports.Identifier = Identifier;
			var IfStatement = function () {
				function IfStatement(test, consequent, alternate) {
					this.type = syntax_1.Syntax.IfStatement;
					this.test = test;
					this.consequent = consequent;
					this.alternate = alternate;
				}
				return IfStatement;
			}();
			exports.IfStatement = IfStatement;
			var ImportDeclaration = function () {
				function ImportDeclaration(specifiers, source) {
					this.type = syntax_1.Syntax.ImportDeclaration;
					this.specifiers = specifiers;
					this.source = source;
				}
				return ImportDeclaration;
			}();
			exports.ImportDeclaration = ImportDeclaration;
			var ImportDefaultSpecifier = function () {
				function ImportDefaultSpecifier(local) {
					this.type = syntax_1.Syntax.ImportDefaultSpecifier;
					this.local = local;
				}
				return ImportDefaultSpecifier;
			}();
			exports.ImportDefaultSpecifier = ImportDefaultSpecifier;
			var ImportNamespaceSpecifier = function () {
				function ImportNamespaceSpecifier(local) {
					this.type = syntax_1.Syntax.ImportNamespaceSpecifier;
					this.local = local;
				}
				return ImportNamespaceSpecifier;
			}();
			exports.ImportNamespaceSpecifier = ImportNamespaceSpecifier;
			var ImportSpecifier = function () {
				function ImportSpecifier(local, imported) {
					this.type = syntax_1.Syntax.ImportSpecifier;
					this.local = local;
					this.imported = imported;
				}
				return ImportSpecifier;
			}();
			exports.ImportSpecifier = ImportSpecifier;
			var LabeledStatement = function () {
				function LabeledStatement(label, body) {
					this.type = syntax_1.Syntax.LabeledStatement;
					this.label = label;
					this.body = body;
				}
				return LabeledStatement;
			}();
			exports.LabeledStatement = LabeledStatement;
			var Literal = function () {
				function Literal(value, raw) {
					this.type = syntax_1.Syntax.Literal;
					this.value = value;
					this.raw = raw;
				}
				return Literal;
			}();
			exports.Literal = Literal;
			var MetaProperty = function () {
				function MetaProperty(meta, property) {
					this.type = syntax_1.Syntax.MetaProperty;
					this.meta = meta;
					this.property = property;
				}
				return MetaProperty;
			}();
			exports.MetaProperty = MetaProperty;
			var MethodDefinition = function () {
				function MethodDefinition(key, computed, value, kind, isStatic) {
					this.type = syntax_1.Syntax.MethodDefinition;
					this.key = key;
					this.computed = computed;
					this.value = value;
					this.kind = kind;
					this.static = isStatic;
				}
				return MethodDefinition;
			}();
			exports.MethodDefinition = MethodDefinition;
			var Module = function () {
				function Module(body) {
					this.type = syntax_1.Syntax.Program;
					this.body = body;
					this.sourceType = 'module';
				}
				return Module;
			}();
			exports.Module = Module;
			var NewExpression = function () {
				function NewExpression(callee, args) {
					this.type = syntax_1.Syntax.NewExpression;
					this.callee = callee;
					this.arguments = args;
				}
				return NewExpression;
			}();
			exports.NewExpression = NewExpression;
			var ObjectExpression = function () {
				function ObjectExpression(properties) {
					this.type = syntax_1.Syntax.ObjectExpression;
					this.properties = properties;
				}
				return ObjectExpression;
			}();
			exports.ObjectExpression = ObjectExpression;
			var ObjectPattern = function () {
				function ObjectPattern(properties) {
					this.type = syntax_1.Syntax.ObjectPattern;
					this.properties = properties;
				}
				return ObjectPattern;
			}();
			exports.ObjectPattern = ObjectPattern;
			var Property = function () {
				function Property(kind, key, computed, value, method, shorthand) {
					this.type = syntax_1.Syntax.Property;
					this.key = key;
					this.computed = computed;
					this.value = value;
					this.kind = kind;
					this.method = method;
					this.shorthand = shorthand;
				}
				return Property;
			}();
			exports.Property = Property;
			var RegexLiteral = function () {
				function RegexLiteral(value, raw, pattern, flags) {
					this.type = syntax_1.Syntax.Literal;
					this.value = value;
					this.raw = raw;
					this.regex = { pattern: pattern, flags: flags };
				}
				return RegexLiteral;
			}();
			exports.RegexLiteral = RegexLiteral;
			var RestElement = function () {
				function RestElement(argument) {
					this.type = syntax_1.Syntax.RestElement;
					this.argument = argument;
				}
				return RestElement;
			}();
			exports.RestElement = RestElement;
			var ReturnStatement = function () {
				function ReturnStatement(argument) {
					this.type = syntax_1.Syntax.ReturnStatement;
					this.argument = argument;
				}
				return ReturnStatement;
			}();
			exports.ReturnStatement = ReturnStatement;
			var Script = function () {
				function Script(body) {
					this.type = syntax_1.Syntax.Program;
					this.body = body;
					this.sourceType = 'script';
				}
				return Script;
			}();
			exports.Script = Script;
			var SequenceExpression = function () {
				function SequenceExpression(expressions) {
					this.type = syntax_1.Syntax.SequenceExpression;
					this.expressions = expressions;
				}
				return SequenceExpression;
			}();
			exports.SequenceExpression = SequenceExpression;
			var SpreadElement = function () {
				function SpreadElement(argument) {
					this.type = syntax_1.Syntax.SpreadElement;
					this.argument = argument;
				}
				return SpreadElement;
			}();
			exports.SpreadElement = SpreadElement;
			var StaticMemberExpression = function () {
				function StaticMemberExpression(object, property) {
					this.type = syntax_1.Syntax.MemberExpression;
					this.computed = false;
					this.object = object;
					this.property = property;
				}
				return StaticMemberExpression;
			}();
			exports.StaticMemberExpression = StaticMemberExpression;
			var Super = function () {
				function Super() {
					this.type = syntax_1.Syntax.Super;
				}
				return Super;
			}();
			exports.Super = Super;
			var SwitchCase = function () {
				function SwitchCase(test, consequent) {
					this.type = syntax_1.Syntax.SwitchCase;
					this.test = test;
					this.consequent = consequent;
				}
				return SwitchCase;
			}();
			exports.SwitchCase = SwitchCase;
			var SwitchStatement = function () {
				function SwitchStatement(discriminant, cases) {
					this.type = syntax_1.Syntax.SwitchStatement;
					this.discriminant = discriminant;
					this.cases = cases;
				}
				return SwitchStatement;
			}();
			exports.SwitchStatement = SwitchStatement;
			var TaggedTemplateExpression = function () {
				function TaggedTemplateExpression(tag, quasi) {
					this.type = syntax_1.Syntax.TaggedTemplateExpression;
					this.tag = tag;
					this.quasi = quasi;
				}
				return TaggedTemplateExpression;
			}();
			exports.TaggedTemplateExpression = TaggedTemplateExpression;
			var TemplateElement = function () {
				function TemplateElement(value, tail) {
					this.type = syntax_1.Syntax.TemplateElement;
					this.value = value;
					this.tail = tail;
				}
				return TemplateElement;
			}();
			exports.TemplateElement = TemplateElement;
			var TemplateLiteral = function () {
				function TemplateLiteral(quasis, expressions) {
					this.type = syntax_1.Syntax.TemplateLiteral;
					this.quasis = quasis;
					this.expressions = expressions;
				}
				return TemplateLiteral;
			}();
			exports.TemplateLiteral = TemplateLiteral;
			var ThisExpression = function () {
				function ThisExpression() {
					this.type = syntax_1.Syntax.ThisExpression;
				}
				return ThisExpression;
			}();
			exports.ThisExpression = ThisExpression;
			var ThrowStatement = function () {
				function ThrowStatement(argument) {
					this.type = syntax_1.Syntax.ThrowStatement;
					this.argument = argument;
				}
				return ThrowStatement;
			}();
			exports.ThrowStatement = ThrowStatement;
			var TryStatement = function () {
				function TryStatement(block, handler, finalizer) {
					this.type = syntax_1.Syntax.TryStatement;
					this.block = block;
					this.handler = handler;
					this.finalizer = finalizer;
				}
				return TryStatement;
			}();
			exports.TryStatement = TryStatement;
			var UnaryExpression = function () {
				function UnaryExpression(operator, argument) {
					this.type = syntax_1.Syntax.UnaryExpression;
					this.operator = operator;
					this.argument = argument;
					this.prefix = true;
				}
				return UnaryExpression;
			}();
			exports.UnaryExpression = UnaryExpression;
			var UpdateExpression = function () {
				function UpdateExpression(operator, argument, prefix) {
					this.type = syntax_1.Syntax.UpdateExpression;
					this.operator = operator;
					this.argument = argument;
					this.prefix = prefix;
				}
				return UpdateExpression;
			}();
			exports.UpdateExpression = UpdateExpression;
			var VariableDeclaration = function () {
				function VariableDeclaration(declarations, kind) {
					this.type = syntax_1.Syntax.VariableDeclaration;
					this.declarations = declarations;
					this.kind = kind;
				}
				return VariableDeclaration;
			}();
			exports.VariableDeclaration = VariableDeclaration;
			var VariableDeclarator = function () {
				function VariableDeclarator(id, init) {
					this.type = syntax_1.Syntax.VariableDeclarator;
					this.id = id;
					this.init = init;
				}
				return VariableDeclarator;
			}();
			exports.VariableDeclarator = VariableDeclarator;
			var WhileStatement = function () {
				function WhileStatement(test, body) {
					this.type = syntax_1.Syntax.WhileStatement;
					this.test = test;
					this.body = body;
				}
				return WhileStatement;
			}();
			exports.WhileStatement = WhileStatement;
			var WithStatement = function () {
				function WithStatement(object, body) {
					this.type = syntax_1.Syntax.WithStatement;
					this.object = object;
					this.body = body;
				}
				return WithStatement;
			}();
			exports.WithStatement = WithStatement;
			var YieldExpression = function () {
				function YieldExpression(argument, delegate) {
					this.type = syntax_1.Syntax.YieldExpression;
					this.argument = argument;
					this.delegate = delegate;
				}
				return YieldExpression;
			}();
			exports.YieldExpression = YieldExpression;

			/***/
		},
		/* 8 */
		/***/function (module, exports, __webpack_require__) {

			"use strict";

			Object.defineProperty(exports, "__esModule", { value: true });
			var assert_1 = __webpack_require__(9);
			var error_handler_1 = __webpack_require__(10);
			var messages_1 = __webpack_require__(11);
			var Node = __webpack_require__(7);
			var scanner_1 = __webpack_require__(12);
			var syntax_1 = __webpack_require__(2);
			var token_1 = __webpack_require__(13);
			var ArrowParameterPlaceHolder = 'ArrowParameterPlaceHolder';
			var Parser = function () {
				function Parser(code, options, delegate) {
					if (options === void 0) {
						options = {};
					}
					this.config = {
						range: typeof options.range === 'boolean' && options.range,
						loc: typeof options.loc === 'boolean' && options.loc,
						source: null,
						tokens: typeof options.tokens === 'boolean' && options.tokens,
						comment: typeof options.comment === 'boolean' && options.comment,
						tolerant: typeof options.tolerant === 'boolean' && options.tolerant
					};
					if (this.config.loc && options.source && options.source !== null) {
						this.config.source = String(options.source);
					}
					this.delegate = delegate;
					this.errorHandler = new error_handler_1.ErrorHandler();
					this.errorHandler.tolerant = this.config.tolerant;
					this.scanner = new scanner_1.Scanner(code, this.errorHandler);
					this.scanner.trackComment = this.config.comment;
					this.operatorPrecedence = {
						')': 0,
						';': 0,
						',': 0,
						'=': 0,
						']': 0,
						'||': 1,
						'&&': 2,
						'|': 3,
						'^': 4,
						'&': 5,
						'==': 6,
						'!=': 6,
						'===': 6,
						'!==': 6,
						'<': 7,
						'>': 7,
						'<=': 7,
						'>=': 7,
						'<<': 8,
						'>>': 8,
						'>>>': 8,
						'+': 9,
						'-': 9,
						'*': 11,
						'/': 11,
						'%': 11
					};
					this.lookahead = {
						type: 2 /* EOF */
						, value: '',
						lineNumber: this.scanner.lineNumber,
						lineStart: 0,
						start: 0,
						end: 0
					};
					this.hasLineTerminator = false;
					this.context = {
						isModule: false,
						await: false,
						allowIn: true,
						allowStrictDirective: true,
						allowYield: true,
						firstCoverInitializedNameError: null,
						isAssignmentTarget: false,
						isBindingElement: false,
						inFunctionBody: false,
						inIteration: false,
						inSwitch: false,
						labelSet: {},
						strict: false
					};
					this.tokens = [];
					this.startMarker = {
						index: 0,
						line: this.scanner.lineNumber,
						column: 0
					};
					this.lastMarker = {
						index: 0,
						line: this.scanner.lineNumber,
						column: 0
					};
					this.nextToken();
					this.lastMarker = {
						index: this.scanner.index,
						line: this.scanner.lineNumber,
						column: this.scanner.index - this.scanner.lineStart
					};
				}
				Parser.prototype.throwError = function (messageFormat) {
					var values = [];
					for (var _i = 1; _i < arguments.length; _i++) {
						values[_i - 1] = arguments[_i];
					}
					var args = Array.prototype.slice.call(arguments, 1);
					var msg = messageFormat.replace(/%(\d)/g, function (whole, idx) {
						assert_1.assert(idx < args.length, 'Message reference must be in range');
						return args[idx];
					});
					var index = this.lastMarker.index;
					var line = this.lastMarker.line;
					var column = this.lastMarker.column + 1;
					throw this.errorHandler.createError(index, line, column, msg);
				};
				Parser.prototype.tolerateError = function (messageFormat) {
					var values = [];
					for (var _i = 1; _i < arguments.length; _i++) {
						values[_i - 1] = arguments[_i];
					}
					var args = Array.prototype.slice.call(arguments, 1);
					var msg = messageFormat.replace(/%(\d)/g, function (whole, idx) {
						assert_1.assert(idx < args.length, 'Message reference must be in range');
						return args[idx];
					});
					var index = this.lastMarker.index;
					var line = this.scanner.lineNumber;
					var column = this.lastMarker.column + 1;
					this.errorHandler.tolerateError(index, line, column, msg);
				};
				// Throw an exception because of the token.
				Parser.prototype.unexpectedTokenError = function (token, message) {
					var msg = message || messages_1.Messages.UnexpectedToken;
					var value;
					if (token) {
						if (!message) {
							msg = token.type === 2 /* EOF */ ? messages_1.Messages.UnexpectedEOS : token.type === 3 /* Identifier */ ? messages_1.Messages.UnexpectedIdentifier : token.type === 6 /* NumericLiteral */ ? messages_1.Messages.UnexpectedNumber : token.type === 8 /* StringLiteral */ ? messages_1.Messages.UnexpectedString : token.type === 10 /* Template */ ? messages_1.Messages.UnexpectedTemplate : messages_1.Messages.UnexpectedToken;
							if (token.type === 4 /* Keyword */) {
									if (this.scanner.isFutureReservedWord(token.value)) {
										msg = messages_1.Messages.UnexpectedReserved;
									} else if (this.context.strict && this.scanner.isStrictModeReservedWord(token.value)) {
										msg = messages_1.Messages.StrictReservedWord;
									}
								}
						}
						value = token.value;
					} else {
						value = 'ILLEGAL';
					}
					msg = msg.replace('%0', value);
					if (token && typeof token.lineNumber === 'number') {
						var index = token.start;
						var line = token.lineNumber;
						var lastMarkerLineStart = this.lastMarker.index - this.lastMarker.column;
						var column = token.start - lastMarkerLineStart + 1;
						return this.errorHandler.createError(index, line, column, msg);
					} else {
						var index = this.lastMarker.index;
						var line = this.lastMarker.line;
						var column = this.lastMarker.column + 1;
						return this.errorHandler.createError(index, line, column, msg);
					}
				};
				Parser.prototype.throwUnexpectedToken = function (token, message) {
					throw this.unexpectedTokenError(token, message);
				};
				Parser.prototype.tolerateUnexpectedToken = function (token, message) {
					this.errorHandler.tolerate(this.unexpectedTokenError(token, message));
				};
				Parser.prototype.collectComments = function () {
					if (!this.config.comment) {
						this.scanner.scanComments();
					} else {
						var comments = this.scanner.scanComments();
						if (comments.length > 0 && this.delegate) {
							for (var i = 0; i < comments.length; ++i) {
								var e = comments[i];
								var node = void 0;
								node = {
									type: e.multiLine ? 'BlockComment' : 'LineComment',
									value: this.scanner.source.slice(e.slice[0], e.slice[1])
								};
								if (this.config.range) {
									node.range = e.range;
								}
								if (this.config.loc) {
									node.loc = e.loc;
								}
								var metadata = {
									start: {
										line: e.loc.start.line,
										column: e.loc.start.column,
										offset: e.range[0]
									},
									end: {
										line: e.loc.end.line,
										column: e.loc.end.column,
										offset: e.range[1]
									}
								};
								this.delegate(node, metadata);
							}
						}
					}
				};
				// From internal representation to an external structure
				Parser.prototype.getTokenRaw = function (token) {
					return this.scanner.source.slice(token.start, token.end);
				};
				Parser.prototype.convertToken = function (token) {
					var t = {
						type: token_1.TokenName[token.type],
						value: this.getTokenRaw(token)
					};
					if (this.config.range) {
						t.range = [token.start, token.end];
					}
					if (this.config.loc) {
						t.loc = {
							start: {
								line: this.startMarker.line,
								column: this.startMarker.column
							},
							end: {
								line: this.scanner.lineNumber,
								column: this.scanner.index - this.scanner.lineStart
							}
						};
					}
					if (token.type === 9 /* RegularExpression */) {
							var pattern = token.pattern;
							var flags = token.flags;
							t.regex = { pattern: pattern, flags: flags };
						}
					return t;
				};
				Parser.prototype.nextToken = function () {
					var token = this.lookahead;
					this.lastMarker.index = this.scanner.index;
					this.lastMarker.line = this.scanner.lineNumber;
					this.lastMarker.column = this.scanner.index - this.scanner.lineStart;
					this.collectComments();
					if (this.scanner.index !== this.startMarker.index) {
						this.startMarker.index = this.scanner.index;
						this.startMarker.line = this.scanner.lineNumber;
						this.startMarker.column = this.scanner.index - this.scanner.lineStart;
					}
					var next = this.scanner.lex();
					this.hasLineTerminator = token.lineNumber !== next.lineNumber;
					if (next && this.context.strict && next.type === 3 /* Identifier */) {
							if (this.scanner.isStrictModeReservedWord(next.value)) {
								next.type = 4 /* Keyword */;
							}
						}
					this.lookahead = next;
					if (this.config.tokens && next.type !== 2 /* EOF */) {
							this.tokens.push(this.convertToken(next));
						}
					return token;
				};
				Parser.prototype.nextRegexToken = function () {
					this.collectComments();
					var token = this.scanner.scanRegExp();
					if (this.config.tokens) {
						// Pop the previous token, '/' or '/='
						// This is added from the lookahead token.
						this.tokens.pop();
						this.tokens.push(this.convertToken(token));
					}
					// Prime the next lookahead.
					this.lookahead = token;
					this.nextToken();
					return token;
				};
				Parser.prototype.createNode = function () {
					return {
						index: this.startMarker.index,
						line: this.startMarker.line,
						column: this.startMarker.column
					};
				};
				Parser.prototype.startNode = function (token) {
					return {
						index: token.start,
						line: token.lineNumber,
						column: token.start - token.lineStart
					};
				};
				Parser.prototype.finalize = function (marker, node) {
					if (this.config.range) {
						node.range = [marker.index, this.lastMarker.index];
					}
					if (this.config.loc) {
						node.loc = {
							start: {
								line: marker.line,
								column: marker.column
							},
							end: {
								line: this.lastMarker.line,
								column: this.lastMarker.column
							}
						};
						if (this.config.source) {
							node.loc.source = this.config.source;
						}
					}
					if (this.delegate) {
						var metadata = {
							start: {
								line: marker.line,
								column: marker.column,
								offset: marker.index
							},
							end: {
								line: this.lastMarker.line,
								column: this.lastMarker.column,
								offset: this.lastMarker.index
							}
						};
						this.delegate(node, metadata);
					}
					return node;
				};
				// Expect the next token to match the specified punctuator.
				// If not, an exception will be thrown.
				Parser.prototype.expect = function (value) {
					var token = this.nextToken();
					if (token.type !== 7 /* Punctuator */ || token.value !== value) {
						this.throwUnexpectedToken(token);
					}
				};
				// Quietly expect a comma when in tolerant mode, otherwise delegates to expect().
				Parser.prototype.expectCommaSeparator = function () {
					if (this.config.tolerant) {
						var token = this.lookahead;
						if (token.type === 7 /* Punctuator */ && token.value === ',') {
							this.nextToken();
						} else if (token.type === 7 /* Punctuator */ && token.value === ';') {
							this.nextToken();
							this.tolerateUnexpectedToken(token);
						} else {
							this.tolerateUnexpectedToken(token, messages_1.Messages.UnexpectedToken);
						}
					} else {
						this.expect(',');
					}
				};
				// Expect the next token to match the specified keyword.
				// If not, an exception will be thrown.
				Parser.prototype.expectKeyword = function (keyword) {
					var token = this.nextToken();
					if (token.type !== 4 /* Keyword */ || token.value !== keyword) {
						this.throwUnexpectedToken(token);
					}
				};
				// Return true if the next token matches the specified punctuator.
				Parser.prototype.match = function (value) {
					return this.lookahead.type === 7 /* Punctuator */ && this.lookahead.value === value;
				};
				// Return true if the next token matches the specified keyword
				Parser.prototype.matchKeyword = function (keyword) {
					return this.lookahead.type === 4 /* Keyword */ && this.lookahead.value === keyword;
				};
				// Return true if the next token matches the specified contextual keyword
				// (where an identifier is sometimes a keyword depending on the context)
				Parser.prototype.matchContextualKeyword = function (keyword) {
					return this.lookahead.type === 3 /* Identifier */ && this.lookahead.value === keyword;
				};
				// Return true if the next token is an assignment operator
				Parser.prototype.matchAssign = function () {
					if (this.lookahead.type !== 7 /* Punctuator */) {
							return false;
						}
					var op = this.lookahead.value;
					return op === '=' || op === '*=' || op === '**=' || op === '/=' || op === '%=' || op === '+=' || op === '-=' || op === '<<=' || op === '>>=' || op === '>>>=' || op === '&=' || op === '^=' || op === '|=';
				};
				// Cover grammar support.
				//
				// When an assignment expression position starts with an left parenthesis, the determination of the type
				// of the syntax is to be deferred arbitrarily long until the end of the parentheses pair (plus a lookahead)
				// or the first comma. This situation also defers the determination of all the expressions nested in the pair.
				//
				// There are three productions that can be parsed in a parentheses pair that needs to be determined
				// after the outermost pair is closed. They are:
				//
				//   1. AssignmentExpression
				//   2. BindingElements
				//   3. AssignmentTargets
				//
				// In order to avoid exponential backtracking, we use two flags to denote if the production can be
				// binding element or assignment target.
				//
				// The three productions have the relationship:
				//
				//   BindingElements  AssignmentTargets  AssignmentExpression
				//
				// with a single exception that CoverInitializedName when used directly in an Expression, generates
				// an early error. Therefore, we need the third state, firstCoverInitializedNameError, to track the
				// first usage of CoverInitializedName and report it when we reached the end of the parentheses pair.
				//
				// isolateCoverGrammar function runs the given parser function with a new cover grammar context, and it does not
				// effect the current flags. This means the production the parser parses is only used as an expression. Therefore
				// the CoverInitializedName check is conducted.
				//
				// inheritCoverGrammar function runs the given parse function with a new cover grammar context, and it propagates
				// the flags outside of the parser. This means the production the parser parses is used as a part of a potential
				// pattern. The CoverInitializedName check is deferred.
				Parser.prototype.isolateCoverGrammar = function (parseFunction) {
					var previousIsBindingElement = this.context.isBindingElement;
					var previousIsAssignmentTarget = this.context.isAssignmentTarget;
					var previousFirstCoverInitializedNameError = this.context.firstCoverInitializedNameError;
					this.context.isBindingElement = true;
					this.context.isAssignmentTarget = true;
					this.context.firstCoverInitializedNameError = null;
					var result = parseFunction.call(this);
					if (this.context.firstCoverInitializedNameError !== null) {
						this.throwUnexpectedToken(this.context.firstCoverInitializedNameError);
					}
					this.context.isBindingElement = previousIsBindingElement;
					this.context.isAssignmentTarget = previousIsAssignmentTarget;
					this.context.firstCoverInitializedNameError = previousFirstCoverInitializedNameError;
					return result;
				};
				Parser.prototype.inheritCoverGrammar = function (parseFunction) {
					var previousIsBindingElement = this.context.isBindingElement;
					var previousIsAssignmentTarget = this.context.isAssignmentTarget;
					var previousFirstCoverInitializedNameError = this.context.firstCoverInitializedNameError;
					this.context.isBindingElement = true;
					this.context.isAssignmentTarget = true;
					this.context.firstCoverInitializedNameError = null;
					var result = parseFunction.call(this);
					this.context.isBindingElement = this.context.isBindingElement && previousIsBindingElement;
					this.context.isAssignmentTarget = this.context.isAssignmentTarget && previousIsAssignmentTarget;
					this.context.firstCoverInitializedNameError = previousFirstCoverInitializedNameError || this.context.firstCoverInitializedNameError;
					return result;
				};
				Parser.prototype.consumeSemicolon = function () {
					if (this.match(';')) {
						this.nextToken();
					} else if (!this.hasLineTerminator) {
						if (this.lookahead.type !== 2 /* EOF */ && !this.match('}')) {
							this.throwUnexpectedToken(this.lookahead);
						}
						this.lastMarker.index = this.startMarker.index;
						this.lastMarker.line = this.startMarker.line;
						this.lastMarker.column = this.startMarker.column;
					}
				};
				// https://tc39.github.io/ecma262/#sec-primary-expression
				Parser.prototype.parsePrimaryExpression = function () {
					var node = this.createNode();
					var expr;
					var token, raw;
					switch (this.lookahead.type) {
						case 3 /* Identifier */:
							if ((this.context.isModule || this.context.await) && this.lookahead.value === 'await') {
								this.tolerateUnexpectedToken(this.lookahead);
							}
							expr = this.matchAsyncFunction() ? this.parseFunctionExpression() : this.finalize(node, new Node.Identifier(this.nextToken().value));
							break;
						case 6 /* NumericLiteral */:
						case 8 /* StringLiteral */:
							if (this.context.strict && this.lookahead.octal) {
								this.tolerateUnexpectedToken(this.lookahead, messages_1.Messages.StrictOctalLiteral);
							}
							this.context.isAssignmentTarget = false;
							this.context.isBindingElement = false;
							token = this.nextToken();
							raw = this.getTokenRaw(token);
							expr = this.finalize(node, new Node.Literal(token.value, raw));
							break;
						case 1 /* BooleanLiteral */:
							this.context.isAssignmentTarget = false;
							this.context.isBindingElement = false;
							token = this.nextToken();
							raw = this.getTokenRaw(token);
							expr = this.finalize(node, new Node.Literal(token.value === 'true', raw));
							break;
						case 5 /* NullLiteral */:
							this.context.isAssignmentTarget = false;
							this.context.isBindingElement = false;
							token = this.nextToken();
							raw = this.getTokenRaw(token);
							expr = this.finalize(node, new Node.Literal(null, raw));
							break;
						case 10 /* Template */:
							expr = this.parseTemplateLiteral();
							break;
						case 7 /* Punctuator */:
							switch (this.lookahead.value) {
								case '(':
									this.context.isBindingElement = false;
									expr = this.inheritCoverGrammar(this.parseGroupExpression);
									break;
								case '[':
									expr = this.inheritCoverGrammar(this.parseArrayInitializer);
									break;
								case '{':
									expr = this.inheritCoverGrammar(this.parseObjectInitializer);
									break;
								case '/':
								case '/=':
									this.context.isAssignmentTarget = false;
									this.context.isBindingElement = false;
									this.scanner.index = this.startMarker.index;
									token = this.nextRegexToken();
									raw = this.getTokenRaw(token);
									expr = this.finalize(node, new Node.RegexLiteral(token.regex, raw, token.pattern, token.flags));
									break;
								default:
									expr = this.throwUnexpectedToken(this.nextToken());
							}
							break;
						case 4 /* Keyword */:
							if (!this.context.strict && this.context.allowYield && this.matchKeyword('yield')) {
								expr = this.parseIdentifierName();
							} else if (!this.context.strict && this.matchKeyword('let')) {
								expr = this.finalize(node, new Node.Identifier(this.nextToken().value));
							} else {
								this.context.isAssignmentTarget = false;
								this.context.isBindingElement = false;
								if (this.matchKeyword('function')) {
									expr = this.parseFunctionExpression();
								} else if (this.matchKeyword('this')) {
									this.nextToken();
									expr = this.finalize(node, new Node.ThisExpression());
								} else if (this.matchKeyword('class')) {
									expr = this.parseClassExpression();
								} else {
									expr = this.throwUnexpectedToken(this.nextToken());
								}
							}
							break;
						default:
							expr = this.throwUnexpectedToken(this.nextToken());
					}
					return expr;
				};
				// https://tc39.github.io/ecma262/#sec-array-initializer
				Parser.prototype.parseSpreadElement = function () {
					var node = this.createNode();
					this.expect('...');
					var arg = this.inheritCoverGrammar(this.parseAssignmentExpression);
					return this.finalize(node, new Node.SpreadElement(arg));
				};
				Parser.prototype.parseArrayInitializer = function () {
					var node = this.createNode();
					var elements = [];
					this.expect('[');
					while (!this.match(']')) {
						if (this.match(',')) {
							this.nextToken();
							elements.push(null);
						} else if (this.match('...')) {
							var element = this.parseSpreadElement();
							if (!this.match(']')) {
								this.context.isAssignmentTarget = false;
								this.context.isBindingElement = false;
								this.expect(',');
							}
							elements.push(element);
						} else {
							elements.push(this.inheritCoverGrammar(this.parseAssignmentExpression));
							if (!this.match(']')) {
								this.expect(',');
							}
						}
					}
					this.expect(']');
					return this.finalize(node, new Node.ArrayExpression(elements));
				};
				// https://tc39.github.io/ecma262/#sec-object-initializer
				Parser.prototype.parsePropertyMethod = function (params) {
					this.context.isAssignmentTarget = false;
					this.context.isBindingElement = false;
					var previousStrict = this.context.strict;
					var previousAllowStrictDirective = this.context.allowStrictDirective;
					this.context.allowStrictDirective = params.simple;
					var body = this.isolateCoverGrammar(this.parseFunctionSourceElements);
					if (this.context.strict && params.firstRestricted) {
						this.tolerateUnexpectedToken(params.firstRestricted, params.message);
					}
					if (this.context.strict && params.stricted) {
						this.tolerateUnexpectedToken(params.stricted, params.message);
					}
					this.context.strict = previousStrict;
					this.context.allowStrictDirective = previousAllowStrictDirective;
					return body;
				};
				Parser.prototype.parsePropertyMethodFunction = function () {
					var isGenerator = false;
					var node = this.createNode();
					var previousAllowYield = this.context.allowYield;
					this.context.allowYield = false;
					var params = this.parseFormalParameters();
					var method = this.parsePropertyMethod(params);
					this.context.allowYield = previousAllowYield;
					return this.finalize(node, new Node.FunctionExpression(null, params.params, method, isGenerator));
				};
				Parser.prototype.parsePropertyMethodAsyncFunction = function () {
					var node = this.createNode();
					var previousAllowYield = this.context.allowYield;
					var previousAwait = this.context.await;
					this.context.allowYield = false;
					this.context.await = true;
					var params = this.parseFormalParameters();
					var method = this.parsePropertyMethod(params);
					this.context.allowYield = previousAllowYield;
					this.context.await = previousAwait;
					return this.finalize(node, new Node.AsyncFunctionExpression(null, params.params, method));
				};
				Parser.prototype.parseObjectPropertyKey = function () {
					var node = this.createNode();
					var token = this.nextToken();
					var key;
					switch (token.type) {
						case 8 /* StringLiteral */:
						case 6 /* NumericLiteral */:
							if (this.context.strict && token.octal) {
								this.tolerateUnexpectedToken(token, messages_1.Messages.StrictOctalLiteral);
							}
							var raw = this.getTokenRaw(token);
							key = this.finalize(node, new Node.Literal(token.value, raw));
							break;
						case 3 /* Identifier */:
						case 1 /* BooleanLiteral */:
						case 5 /* NullLiteral */:
						case 4 /* Keyword */:
							key = this.finalize(node, new Node.Identifier(token.value));
							break;
						case 7 /* Punctuator */:
							if (token.value === '[') {
								key = this.isolateCoverGrammar(this.parseAssignmentExpression);
								this.expect(']');
							} else {
								key = this.throwUnexpectedToken(token);
							}
							break;
						default:
							key = this.throwUnexpectedToken(token);
					}
					return key;
				};
				Parser.prototype.isPropertyKey = function (key, value) {
					return key.type === syntax_1.Syntax.Identifier && key.name === value || key.type === syntax_1.Syntax.Literal && key.value === value;
				};
				Parser.prototype.parseObjectProperty = function (hasProto) {
					var node = this.createNode();
					var token = this.lookahead;
					var kind;
					var key = null;
					var value = null;
					var computed = false;
					var method = false;
					var shorthand = false;
					var isAsync = false;
					if (token.type === 3 /* Identifier */) {
							var id = token.value;
							this.nextToken();
							computed = this.match('[');
							isAsync = !this.hasLineTerminator && id === 'async' && !this.match(':') && !this.match('(') && !this.match('*');
							key = isAsync ? this.parseObjectPropertyKey() : this.finalize(node, new Node.Identifier(id));
						} else if (this.match('*')) {
						this.nextToken();
					} else {
						computed = this.match('[');
						key = this.parseObjectPropertyKey();
					}
					var lookaheadPropertyKey = this.qualifiedPropertyName(this.lookahead);
					if (token.type === 3 /* Identifier */ && !isAsync && token.value === 'get' && lookaheadPropertyKey) {
						kind = 'get';
						computed = this.match('[');
						key = this.parseObjectPropertyKey();
						this.context.allowYield = false;
						value = this.parseGetterMethod();
					} else if (token.type === 3 /* Identifier */ && !isAsync && token.value === 'set' && lookaheadPropertyKey) {
						kind = 'set';
						computed = this.match('[');
						key = this.parseObjectPropertyKey();
						value = this.parseSetterMethod();
					} else if (token.type === 7 /* Punctuator */ && token.value === '*' && lookaheadPropertyKey) {
						kind = 'init';
						computed = this.match('[');
						key = this.parseObjectPropertyKey();
						value = this.parseGeneratorMethod();
						method = true;
					} else {
						if (!key) {
							this.throwUnexpectedToken(this.lookahead);
						}
						kind = 'init';
						if (this.match(':') && !isAsync) {
							if (!computed && this.isPropertyKey(key, '__proto__')) {
								if (hasProto.value) {
									this.tolerateError(messages_1.Messages.DuplicateProtoProperty);
								}
								hasProto.value = true;
							}
							this.nextToken();
							value = this.inheritCoverGrammar(this.parseAssignmentExpression);
						} else if (this.match('(')) {
							value = isAsync ? this.parsePropertyMethodAsyncFunction() : this.parsePropertyMethodFunction();
							method = true;
						} else if (token.type === 3 /* Identifier */) {
								var id = this.finalize(node, new Node.Identifier(token.value));
								if (this.match('=')) {
									this.context.firstCoverInitializedNameError = this.lookahead;
									this.nextToken();
									shorthand = true;
									var init = this.isolateCoverGrammar(this.parseAssignmentExpression);
									value = this.finalize(node, new Node.AssignmentPattern(id, init));
								} else {
									shorthand = true;
									value = id;
								}
							} else {
							this.throwUnexpectedToken(this.nextToken());
						}
					}
					return this.finalize(node, new Node.Property(kind, key, computed, value, method, shorthand));
				};
				Parser.prototype.parseObjectInitializer = function () {
					var node = this.createNode();
					this.expect('{');
					var properties = [];
					var hasProto = { value: false };
					while (!this.match('}')) {
						properties.push(this.parseObjectProperty(hasProto));
						if (!this.match('}')) {
							this.expectCommaSeparator();
						}
					}
					this.expect('}');
					return this.finalize(node, new Node.ObjectExpression(properties));
				};
				// https://tc39.github.io/ecma262/#sec-template-literals
				Parser.prototype.parseTemplateHead = function () {
					assert_1.assert(this.lookahead.head, 'Template literal must start with a template head');
					var node = this.createNode();
					var token = this.nextToken();
					var raw = token.value;
					var cooked = token.cooked;
					return this.finalize(node, new Node.TemplateElement({ raw: raw, cooked: cooked }, token.tail));
				};
				Parser.prototype.parseTemplateElement = function () {
					if (this.lookahead.type !== 10 /* Template */) {
							this.throwUnexpectedToken();
						}
					var node = this.createNode();
					var token = this.nextToken();
					var raw = token.value;
					var cooked = token.cooked;
					return this.finalize(node, new Node.TemplateElement({ raw: raw, cooked: cooked }, token.tail));
				};
				Parser.prototype.parseTemplateLiteral = function () {
					var node = this.createNode();
					var expressions = [];
					var quasis = [];
					var quasi = this.parseTemplateHead();
					quasis.push(quasi);
					while (!quasi.tail) {
						expressions.push(this.parseExpression());
						quasi = this.parseTemplateElement();
						quasis.push(quasi);
					}
					return this.finalize(node, new Node.TemplateLiteral(quasis, expressions));
				};
				// https://tc39.github.io/ecma262/#sec-grouping-operator
				Parser.prototype.reinterpretExpressionAsPattern = function (expr) {
					switch (expr.type) {
						case syntax_1.Syntax.Identifier:
						case syntax_1.Syntax.MemberExpression:
						case syntax_1.Syntax.RestElement:
						case syntax_1.Syntax.AssignmentPattern:
							break;
						case syntax_1.Syntax.SpreadElement:
							expr.type = syntax_1.Syntax.RestElement;
							this.reinterpretExpressionAsPattern(expr.argument);
							break;
						case syntax_1.Syntax.ArrayExpression:
							expr.type = syntax_1.Syntax.ArrayPattern;
							for (var i = 0; i < expr.elements.length; i++) {
								if (expr.elements[i] !== null) {
									this.reinterpretExpressionAsPattern(expr.elements[i]);
								}
							}
							break;
						case syntax_1.Syntax.ObjectExpression:
							expr.type = syntax_1.Syntax.ObjectPattern;
							for (var i = 0; i < expr.properties.length; i++) {
								this.reinterpretExpressionAsPattern(expr.properties[i].value);
							}
							break;
						case syntax_1.Syntax.AssignmentExpression:
							expr.type = syntax_1.Syntax.AssignmentPattern;
							delete expr.operator;
							this.reinterpretExpressionAsPattern(expr.left);
							break;
						default:
							// Allow other node type for tolerant parsing.
							break;
					}
				};
				Parser.prototype.parseGroupExpression = function () {
					var expr;
					this.expect('(');
					if (this.match(')')) {
						this.nextToken();
						if (!this.match('=>')) {
							this.expect('=>');
						}
						expr = {
							type: ArrowParameterPlaceHolder,
							params: [],
							async: false
						};
					} else {
						var startToken = this.lookahead;
						var params = [];
						if (this.match('...')) {
							expr = this.parseRestElement(params);
							this.expect(')');
							if (!this.match('=>')) {
								this.expect('=>');
							}
							expr = {
								type: ArrowParameterPlaceHolder,
								params: [expr],
								async: false
							};
						} else {
							var arrow = false;
							this.context.isBindingElement = true;
							expr = this.inheritCoverGrammar(this.parseAssignmentExpression);
							if (this.match(',')) {
								var expressions = [];
								this.context.isAssignmentTarget = false;
								expressions.push(expr);
								while (this.lookahead.type !== 2 /* EOF */) {
									if (!this.match(',')) {
										break;
									}
									this.nextToken();
									if (this.match(')')) {
										this.nextToken();
										for (var i = 0; i < expressions.length; i++) {
											this.reinterpretExpressionAsPattern(expressions[i]);
										}
										arrow = true;
										expr = {
											type: ArrowParameterPlaceHolder,
											params: expressions,
											async: false
										};
									} else if (this.match('...')) {
										if (!this.context.isBindingElement) {
											this.throwUnexpectedToken(this.lookahead);
										}
										expressions.push(this.parseRestElement(params));
										this.expect(')');
										if (!this.match('=>')) {
											this.expect('=>');
										}
										this.context.isBindingElement = false;
										for (var i = 0; i < expressions.length; i++) {
											this.reinterpretExpressionAsPattern(expressions[i]);
										}
										arrow = true;
										expr = {
											type: ArrowParameterPlaceHolder,
											params: expressions,
											async: false
										};
									} else {
										expressions.push(this.inheritCoverGrammar(this.parseAssignmentExpression));
									}
									if (arrow) {
										break;
									}
								}
								if (!arrow) {
									expr = this.finalize(this.startNode(startToken), new Node.SequenceExpression(expressions));
								}
							}
							if (!arrow) {
								this.expect(')');
								if (this.match('=>')) {
									if (expr.type === syntax_1.Syntax.Identifier && expr.name === 'yield') {
										arrow = true;
										expr = {
											type: ArrowParameterPlaceHolder,
											params: [expr],
											async: false
										};
									}
									if (!arrow) {
										if (!this.context.isBindingElement) {
											this.throwUnexpectedToken(this.lookahead);
										}
										if (expr.type === syntax_1.Syntax.SequenceExpression) {
											for (var i = 0; i < expr.expressions.length; i++) {
												this.reinterpretExpressionAsPattern(expr.expressions[i]);
											}
										} else {
											this.reinterpretExpressionAsPattern(expr);
										}
										var parameters = expr.type === syntax_1.Syntax.SequenceExpression ? expr.expressions : [expr];
										expr = {
											type: ArrowParameterPlaceHolder,
											params: parameters,
											async: false
										};
									}
								}
								this.context.isBindingElement = false;
							}
						}
					}
					return expr;
				};
				// https://tc39.github.io/ecma262/#sec-left-hand-side-expressions
				Parser.prototype.parseArguments = function () {
					this.expect('(');
					var args = [];
					if (!this.match(')')) {
						while (true) {
							var expr = this.match('...') ? this.parseSpreadElement() : this.isolateCoverGrammar(this.parseAssignmentExpression);
							args.push(expr);
							if (this.match(')')) {
								break;
							}
							this.expectCommaSeparator();
							if (this.match(')')) {
								break;
							}
						}
					}
					this.expect(')');
					return args;
				};
				Parser.prototype.isIdentifierName = function (token) {
					return token.type === 3 /* Identifier */ || token.type === 4 /* Keyword */ || token.type === 1 /* BooleanLiteral */ || token.type === 5 /* NullLiteral */;
				};
				Parser.prototype.parseIdentifierName = function () {
					var node = this.createNode();
					var token = this.nextToken();
					if (!this.isIdentifierName(token)) {
						this.throwUnexpectedToken(token);
					}
					return this.finalize(node, new Node.Identifier(token.value));
				};
				Parser.prototype.parseNewExpression = function () {
					var node = this.createNode();
					var id = this.parseIdentifierName();
					assert_1.assert(id.name === 'new', 'New expression must start with `new`');
					var expr;
					if (this.match('.')) {
						this.nextToken();
						if (this.lookahead.type === 3 /* Identifier */ && this.context.inFunctionBody && this.lookahead.value === 'target') {
							var property = this.parseIdentifierName();
							expr = new Node.MetaProperty(id, property);
						} else {
							this.throwUnexpectedToken(this.lookahead);
						}
					} else {
						var callee = this.isolateCoverGrammar(this.parseLeftHandSideExpression);
						var args = this.match('(') ? this.parseArguments() : [];
						expr = new Node.NewExpression(callee, args);
						this.context.isAssignmentTarget = false;
						this.context.isBindingElement = false;
					}
					return this.finalize(node, expr);
				};
				Parser.prototype.parseAsyncArgument = function () {
					var arg = this.parseAssignmentExpression();
					this.context.firstCoverInitializedNameError = null;
					return arg;
				};
				Parser.prototype.parseAsyncArguments = function () {
					this.expect('(');
					var args = [];
					if (!this.match(')')) {
						while (true) {
							var expr = this.match('...') ? this.parseSpreadElement() : this.isolateCoverGrammar(this.parseAsyncArgument);
							args.push(expr);
							if (this.match(')')) {
								break;
							}
							this.expectCommaSeparator();
							if (this.match(')')) {
								break;
							}
						}
					}
					this.expect(')');
					return args;
				};
				Parser.prototype.parseLeftHandSideExpressionAllowCall = function () {
					var startToken = this.lookahead;
					var maybeAsync = this.matchContextualKeyword('async');
					var previousAllowIn = this.context.allowIn;
					this.context.allowIn = true;
					var expr;
					if (this.matchKeyword('super') && this.context.inFunctionBody) {
						expr = this.createNode();
						this.nextToken();
						expr = this.finalize(expr, new Node.Super());
						if (!this.match('(') && !this.match('.') && !this.match('[')) {
							this.throwUnexpectedToken(this.lookahead);
						}
					} else {
						expr = this.inheritCoverGrammar(this.matchKeyword('new') ? this.parseNewExpression : this.parsePrimaryExpression);
					}
					while (true) {
						if (this.match('.')) {
							this.context.isBindingElement = false;
							this.context.isAssignmentTarget = true;
							this.expect('.');
							var property = this.parseIdentifierName();
							expr = this.finalize(this.startNode(startToken), new Node.StaticMemberExpression(expr, property));
						} else if (this.match('(')) {
							var asyncArrow = maybeAsync && startToken.lineNumber === this.lookahead.lineNumber;
							this.context.isBindingElement = false;
							this.context.isAssignmentTarget = false;
							var args = asyncArrow ? this.parseAsyncArguments() : this.parseArguments();
							expr = this.finalize(this.startNode(startToken), new Node.CallExpression(expr, args));
							if (asyncArrow && this.match('=>')) {
								for (var i = 0; i < args.length; ++i) {
									this.reinterpretExpressionAsPattern(args[i]);
								}
								expr = {
									type: ArrowParameterPlaceHolder,
									params: args,
									async: true
								};
							}
						} else if (this.match('[')) {
							this.context.isBindingElement = false;
							this.context.isAssignmentTarget = true;
							this.expect('[');
							var property = this.isolateCoverGrammar(this.parseExpression);
							this.expect(']');
							expr = this.finalize(this.startNode(startToken), new Node.ComputedMemberExpression(expr, property));
						} else if (this.lookahead.type === 10 /* Template */ && this.lookahead.head) {
							var quasi = this.parseTemplateLiteral();
							expr = this.finalize(this.startNode(startToken), new Node.TaggedTemplateExpression(expr, quasi));
						} else {
							break;
						}
					}
					this.context.allowIn = previousAllowIn;
					return expr;
				};
				Parser.prototype.parseSuper = function () {
					var node = this.createNode();
					this.expectKeyword('super');
					if (!this.match('[') && !this.match('.')) {
						this.throwUnexpectedToken(this.lookahead);
					}
					return this.finalize(node, new Node.Super());
				};
				Parser.prototype.parseLeftHandSideExpression = function () {
					assert_1.assert(this.context.allowIn, 'callee of new expression always allow in keyword.');
					var node = this.startNode(this.lookahead);
					var expr = this.matchKeyword('super') && this.context.inFunctionBody ? this.parseSuper() : this.inheritCoverGrammar(this.matchKeyword('new') ? this.parseNewExpression : this.parsePrimaryExpression);
					while (true) {
						if (this.match('[')) {
							this.context.isBindingElement = false;
							this.context.isAssignmentTarget = true;
							this.expect('[');
							var property = this.isolateCoverGrammar(this.parseExpression);
							this.expect(']');
							expr = this.finalize(node, new Node.ComputedMemberExpression(expr, property));
						} else if (this.match('.')) {
							this.context.isBindingElement = false;
							this.context.isAssignmentTarget = true;
							this.expect('.');
							var property = this.parseIdentifierName();
							expr = this.finalize(node, new Node.StaticMemberExpression(expr, property));
						} else if (this.lookahead.type === 10 /* Template */ && this.lookahead.head) {
							var quasi = this.parseTemplateLiteral();
							expr = this.finalize(node, new Node.TaggedTemplateExpression(expr, quasi));
						} else {
							break;
						}
					}
					return expr;
				};
				// https://tc39.github.io/ecma262/#sec-update-expressions
				Parser.prototype.parseUpdateExpression = function () {
					var expr;
					var startToken = this.lookahead;
					if (this.match('++') || this.match('--')) {
						var node = this.startNode(startToken);
						var token = this.nextToken();
						expr = this.inheritCoverGrammar(this.parseUnaryExpression);
						if (this.context.strict && expr.type === syntax_1.Syntax.Identifier && this.scanner.isRestrictedWord(expr.name)) {
							this.tolerateError(messages_1.Messages.StrictLHSPrefix);
						}
						if (!this.context.isAssignmentTarget) {
							this.tolerateError(messages_1.Messages.InvalidLHSInAssignment);
						}
						var prefix = true;
						expr = this.finalize(node, new Node.UpdateExpression(token.value, expr, prefix));
						this.context.isAssignmentTarget = false;
						this.context.isBindingElement = false;
					} else {
						expr = this.inheritCoverGrammar(this.parseLeftHandSideExpressionAllowCall);
						if (!this.hasLineTerminator && this.lookahead.type === 7 /* Punctuator */) {
								if (this.match('++') || this.match('--')) {
									if (this.context.strict && expr.type === syntax_1.Syntax.Identifier && this.scanner.isRestrictedWord(expr.name)) {
										this.tolerateError(messages_1.Messages.StrictLHSPostfix);
									}
									if (!this.context.isAssignmentTarget) {
										this.tolerateError(messages_1.Messages.InvalidLHSInAssignment);
									}
									this.context.isAssignmentTarget = false;
									this.context.isBindingElement = false;
									var operator = this.nextToken().value;
									var prefix = false;
									expr = this.finalize(this.startNode(startToken), new Node.UpdateExpression(operator, expr, prefix));
								}
							}
					}
					return expr;
				};
				// https://tc39.github.io/ecma262/#sec-unary-operators
				Parser.prototype.parseAwaitExpression = function () {
					var node = this.createNode();
					this.nextToken();
					var argument = this.parseUnaryExpression();
					return this.finalize(node, new Node.AwaitExpression(argument));
				};
				Parser.prototype.parseUnaryExpression = function () {
					var expr;
					if (this.match('+') || this.match('-') || this.match('~') || this.match('!') || this.matchKeyword('delete') || this.matchKeyword('void') || this.matchKeyword('typeof')) {
						var node = this.startNode(this.lookahead);
						var token = this.nextToken();
						expr = this.inheritCoverGrammar(this.parseUnaryExpression);
						expr = this.finalize(node, new Node.UnaryExpression(token.value, expr));
						if (this.context.strict && expr.operator === 'delete' && expr.argument.type === syntax_1.Syntax.Identifier) {
							this.tolerateError(messages_1.Messages.StrictDelete);
						}
						this.context.isAssignmentTarget = false;
						this.context.isBindingElement = false;
					} else if (this.context.await && this.matchContextualKeyword('await')) {
						expr = this.parseAwaitExpression();
					} else {
						expr = this.parseUpdateExpression();
					}
					return expr;
				};
				Parser.prototype.parseExponentiationExpression = function () {
					var startToken = this.lookahead;
					var expr = this.inheritCoverGrammar(this.parseUnaryExpression);
					if (expr.type !== syntax_1.Syntax.UnaryExpression && this.match('**')) {
						this.nextToken();
						this.context.isAssignmentTarget = false;
						this.context.isBindingElement = false;
						var left = expr;
						var right = this.isolateCoverGrammar(this.parseExponentiationExpression);
						expr = this.finalize(this.startNode(startToken), new Node.BinaryExpression('**', left, right));
					}
					return expr;
				};
				// https://tc39.github.io/ecma262/#sec-exp-operator
				// https://tc39.github.io/ecma262/#sec-multiplicative-operators
				// https://tc39.github.io/ecma262/#sec-additive-operators
				// https://tc39.github.io/ecma262/#sec-bitwise-shift-operators
				// https://tc39.github.io/ecma262/#sec-relational-operators
				// https://tc39.github.io/ecma262/#sec-equality-operators
				// https://tc39.github.io/ecma262/#sec-binary-bitwise-operators
				// https://tc39.github.io/ecma262/#sec-binary-logical-operators
				Parser.prototype.binaryPrecedence = function (token) {
					var op = token.value;
					var precedence;
					if (token.type === 7 /* Punctuator */) {
							precedence = this.operatorPrecedence[op] || 0;
						} else if (token.type === 4 /* Keyword */) {
							precedence = op === 'instanceof' || this.context.allowIn && op === 'in' ? 7 : 0;
						} else {
						precedence = 0;
					}
					return precedence;
				};
				Parser.prototype.parseBinaryExpression = function () {
					var startToken = this.lookahead;
					var expr = this.inheritCoverGrammar(this.parseExponentiationExpression);
					var token = this.lookahead;
					var prec = this.binaryPrecedence(token);
					if (prec > 0) {
						this.nextToken();
						this.context.isAssignmentTarget = false;
						this.context.isBindingElement = false;
						var markers = [startToken, this.lookahead];
						var left = expr;
						var right = this.isolateCoverGrammar(this.parseExponentiationExpression);
						var stack = [left, token.value, right];
						var precedences = [prec];
						while (true) {
							prec = this.binaryPrecedence(this.lookahead);
							if (prec <= 0) {
								break;
							}
							// Reduce: make a binary expression from the three topmost entries.
							while (stack.length > 2 && prec <= precedences[precedences.length - 1]) {
								right = stack.pop();
								var operator = stack.pop();
								precedences.pop();
								left = stack.pop();
								markers.pop();
								var node = this.startNode(markers[markers.length - 1]);
								stack.push(this.finalize(node, new Node.BinaryExpression(operator, left, right)));
							}
							// Shift.
							stack.push(this.nextToken().value);
							precedences.push(prec);
							markers.push(this.lookahead);
							stack.push(this.isolateCoverGrammar(this.parseExponentiationExpression));
						}
						// Final reduce to clean-up the stack.
						var i = stack.length - 1;
						expr = stack[i];
						markers.pop();
						while (i > 1) {
							var node = this.startNode(markers.pop());
							var operator = stack[i - 1];
							expr = this.finalize(node, new Node.BinaryExpression(operator, stack[i - 2], expr));
							i -= 2;
						}
					}
					return expr;
				};
				// https://tc39.github.io/ecma262/#sec-conditional-operator
				Parser.prototype.parseConditionalExpression = function () {
					var startToken = this.lookahead;
					var expr = this.inheritCoverGrammar(this.parseBinaryExpression);
					if (this.match('?')) {
						this.nextToken();
						var previousAllowIn = this.context.allowIn;
						this.context.allowIn = true;
						var consequent = this.isolateCoverGrammar(this.parseAssignmentExpression);
						this.context.allowIn = previousAllowIn;
						this.expect(':');
						var alternate = this.isolateCoverGrammar(this.parseAssignmentExpression);
						expr = this.finalize(this.startNode(startToken), new Node.ConditionalExpression(expr, consequent, alternate));
						this.context.isAssignmentTarget = false;
						this.context.isBindingElement = false;
					}
					return expr;
				};
				// https://tc39.github.io/ecma262/#sec-assignment-operators
				Parser.prototype.checkPatternParam = function (options, param) {
					switch (param.type) {
						case syntax_1.Syntax.Identifier:
							this.validateParam(options, param, param.name);
							break;
						case syntax_1.Syntax.RestElement:
							this.checkPatternParam(options, param.argument);
							break;
						case syntax_1.Syntax.AssignmentPattern:
							this.checkPatternParam(options, param.left);
							break;
						case syntax_1.Syntax.ArrayPattern:
							for (var i = 0; i < param.elements.length; i++) {
								if (param.elements[i] !== null) {
									this.checkPatternParam(options, param.elements[i]);
								}
							}
							break;
						case syntax_1.Syntax.ObjectPattern:
							for (var i = 0; i < param.properties.length; i++) {
								this.checkPatternParam(options, param.properties[i].value);
							}
							break;
						default:
							break;
					}
					options.simple = options.simple && param instanceof Node.Identifier;
				};
				Parser.prototype.reinterpretAsCoverFormalsList = function (expr) {
					var params = [expr];
					var options;
					var asyncArrow = false;
					switch (expr.type) {
						case syntax_1.Syntax.Identifier:
							break;
						case ArrowParameterPlaceHolder:
							params = expr.params;
							asyncArrow = expr.async;
							break;
						default:
							return null;
					}
					options = {
						simple: true,
						paramSet: {}
					};
					for (var i = 0; i < params.length; ++i) {
						var param = params[i];
						if (param.type === syntax_1.Syntax.AssignmentPattern) {
							if (param.right.type === syntax_1.Syntax.YieldExpression) {
								if (param.right.argument) {
									this.throwUnexpectedToken(this.lookahead);
								}
								param.right.type = syntax_1.Syntax.Identifier;
								param.right.name = 'yield';
								delete param.right.argument;
								delete param.right.delegate;
							}
						} else if (asyncArrow && param.type === syntax_1.Syntax.Identifier && param.name === 'await') {
							this.throwUnexpectedToken(this.lookahead);
						}
						this.checkPatternParam(options, param);
						params[i] = param;
					}
					if (this.context.strict || !this.context.allowYield) {
						for (var i = 0; i < params.length; ++i) {
							var param = params[i];
							if (param.type === syntax_1.Syntax.YieldExpression) {
								this.throwUnexpectedToken(this.lookahead);
							}
						}
					}
					if (options.message === messages_1.Messages.StrictParamDupe) {
						var token = this.context.strict ? options.stricted : options.firstRestricted;
						this.throwUnexpectedToken(token, options.message);
					}
					return {
						simple: options.simple,
						params: params,
						stricted: options.stricted,
						firstRestricted: options.firstRestricted,
						message: options.message
					};
				};
				Parser.prototype.parseAssignmentExpression = function () {
					var expr;
					if (!this.context.allowYield && this.matchKeyword('yield')) {
						expr = this.parseYieldExpression();
					} else {
						var startToken = this.lookahead;
						var token = startToken;
						expr = this.parseConditionalExpression();
						if (token.type === 3 /* Identifier */ && token.lineNumber === this.lookahead.lineNumber && token.value === 'async') {
							if (this.lookahead.type === 3 /* Identifier */ || this.matchKeyword('yield')) {
								var arg = this.parsePrimaryExpression();
								this.reinterpretExpressionAsPattern(arg);
								expr = {
									type: ArrowParameterPlaceHolder,
									params: [arg],
									async: true
								};
							}
						}
						if (expr.type === ArrowParameterPlaceHolder || this.match('=>')) {
							// https://tc39.github.io/ecma262/#sec-arrow-function-definitions
							this.context.isAssignmentTarget = false;
							this.context.isBindingElement = false;
							var isAsync = expr.async;
							var list = this.reinterpretAsCoverFormalsList(expr);
							if (list) {
								if (this.hasLineTerminator) {
									this.tolerateUnexpectedToken(this.lookahead);
								}
								this.context.firstCoverInitializedNameError = null;
								var previousStrict = this.context.strict;
								var previousAllowStrictDirective = this.context.allowStrictDirective;
								this.context.allowStrictDirective = list.simple;
								var previousAllowYield = this.context.allowYield;
								var previousAwait = this.context.await;
								this.context.allowYield = true;
								this.context.await = isAsync;
								var node = this.startNode(startToken);
								this.expect('=>');
								var body = void 0;
								if (this.match('{')) {
									var previousAllowIn = this.context.allowIn;
									this.context.allowIn = true;
									body = this.parseFunctionSourceElements();
									this.context.allowIn = previousAllowIn;
								} else {
									body = this.isolateCoverGrammar(this.parseAssignmentExpression);
								}
								var expression = body.type !== syntax_1.Syntax.BlockStatement;
								if (this.context.strict && list.firstRestricted) {
									this.throwUnexpectedToken(list.firstRestricted, list.message);
								}
								if (this.context.strict && list.stricted) {
									this.tolerateUnexpectedToken(list.stricted, list.message);
								}
								expr = isAsync ? this.finalize(node, new Node.AsyncArrowFunctionExpression(list.params, body, expression)) : this.finalize(node, new Node.ArrowFunctionExpression(list.params, body, expression));
								this.context.strict = previousStrict;
								this.context.allowStrictDirective = previousAllowStrictDirective;
								this.context.allowYield = previousAllowYield;
								this.context.await = previousAwait;
							}
						} else {
							if (this.matchAssign()) {
								if (!this.context.isAssignmentTarget) {
									this.tolerateError(messages_1.Messages.InvalidLHSInAssignment);
								}
								if (this.context.strict && expr.type === syntax_1.Syntax.Identifier) {
									var id = expr;
									if (this.scanner.isRestrictedWord(id.name)) {
										this.tolerateUnexpectedToken(token, messages_1.Messages.StrictLHSAssignment);
									}
									if (this.scanner.isStrictModeReservedWord(id.name)) {
										this.tolerateUnexpectedToken(token, messages_1.Messages.StrictReservedWord);
									}
								}
								if (!this.match('=')) {
									this.context.isAssignmentTarget = false;
									this.context.isBindingElement = false;
								} else {
									this.reinterpretExpressionAsPattern(expr);
								}
								token = this.nextToken();
								var operator = token.value;
								var right = this.isolateCoverGrammar(this.parseAssignmentExpression);
								expr = this.finalize(this.startNode(startToken), new Node.AssignmentExpression(operator, expr, right));
								this.context.firstCoverInitializedNameError = null;
							}
						}
					}
					return expr;
				};
				// https://tc39.github.io/ecma262/#sec-comma-operator
				Parser.prototype.parseExpression = function () {
					var startToken = this.lookahead;
					var expr = this.isolateCoverGrammar(this.parseAssignmentExpression);
					if (this.match(',')) {
						var expressions = [];
						expressions.push(expr);
						while (this.lookahead.type !== 2 /* EOF */) {
							if (!this.match(',')) {
								break;
							}
							this.nextToken();
							expressions.push(this.isolateCoverGrammar(this.parseAssignmentExpression));
						}
						expr = this.finalize(this.startNode(startToken), new Node.SequenceExpression(expressions));
					}
					return expr;
				};
				// https://tc39.github.io/ecma262/#sec-block
				Parser.prototype.parseStatementListItem = function () {
					var statement;
					this.context.isAssignmentTarget = true;
					this.context.isBindingElement = true;
					if (this.lookahead.type === 4 /* Keyword */) {
							switch (this.lookahead.value) {
								case 'export':
									if (!this.context.isModule) {
										this.tolerateUnexpectedToken(this.lookahead, messages_1.Messages.IllegalExportDeclaration);
									}
									statement = this.parseExportDeclaration();
									break;
								case 'import':
									if (!this.context.isModule) {
										this.tolerateUnexpectedToken(this.lookahead, messages_1.Messages.IllegalImportDeclaration);
									}
									statement = this.parseImportDeclaration();
									break;
								case 'const':
									statement = this.parseLexicalDeclaration({ inFor: false });
									break;
								case 'function':
									statement = this.parseFunctionDeclaration();
									break;
								case 'class':
									statement = this.parseClassDeclaration();
									break;
								case 'let':
									statement = this.isLexicalDeclaration() ? this.parseLexicalDeclaration({ inFor: false }) : this.parseStatement();
									break;
								default:
									statement = this.parseStatement();
									break;
							}
						} else {
						statement = this.parseStatement();
					}
					return statement;
				};
				Parser.prototype.parseBlock = function () {
					var node = this.createNode();
					this.expect('{');
					var block = [];
					while (true) {
						if (this.match('}')) {
							break;
						}
						block.push(this.parseStatementListItem());
					}
					this.expect('}');
					return this.finalize(node, new Node.BlockStatement(block));
				};
				// https://tc39.github.io/ecma262/#sec-let-and-const-declarations
				Parser.prototype.parseLexicalBinding = function (kind, options) {
					var node = this.createNode();
					var params = [];
					var id = this.parsePattern(params, kind);
					if (this.context.strict && id.type === syntax_1.Syntax.Identifier) {
						if (this.scanner.isRestrictedWord(id.name)) {
							this.tolerateError(messages_1.Messages.StrictVarName);
						}
					}
					var init = null;
					if (kind === 'const') {
						if (!this.matchKeyword('in') && !this.matchContextualKeyword('of')) {
							if (this.match('=')) {
								this.nextToken();
								init = this.isolateCoverGrammar(this.parseAssignmentExpression);
							} else {
								this.throwError(messages_1.Messages.DeclarationMissingInitializer, 'const');
							}
						}
					} else if (!options.inFor && id.type !== syntax_1.Syntax.Identifier || this.match('=')) {
						this.expect('=');
						init = this.isolateCoverGrammar(this.parseAssignmentExpression);
					}
					return this.finalize(node, new Node.VariableDeclarator(id, init));
				};
				Parser.prototype.parseBindingList = function (kind, options) {
					var list = [this.parseLexicalBinding(kind, options)];
					while (this.match(',')) {
						this.nextToken();
						list.push(this.parseLexicalBinding(kind, options));
					}
					return list;
				};
				Parser.prototype.isLexicalDeclaration = function () {
					var state = this.scanner.saveState();
					this.scanner.scanComments();
					var next = this.scanner.lex();
					this.scanner.restoreState(state);
					return next.type === 3 /* Identifier */ || next.type === 7 /* Punctuator */ && next.value === '[' || next.type === 7 /* Punctuator */ && next.value === '{' || next.type === 4 /* Keyword */ && next.value === 'let' || next.type === 4 /* Keyword */ && next.value === 'yield';
				};
				Parser.prototype.parseLexicalDeclaration = function (options) {
					var node = this.createNode();
					var kind = this.nextToken().value;
					assert_1.assert(kind === 'let' || kind === 'const', 'Lexical declaration must be either let or const');
					var declarations = this.parseBindingList(kind, options);
					this.consumeSemicolon();
					return this.finalize(node, new Node.VariableDeclaration(declarations, kind));
				};
				// https://tc39.github.io/ecma262/#sec-destructuring-binding-patterns
				Parser.prototype.parseBindingRestElement = function (params, kind) {
					var node = this.createNode();
					this.expect('...');
					var arg = this.parsePattern(params, kind);
					return this.finalize(node, new Node.RestElement(arg));
				};
				Parser.prototype.parseArrayPattern = function (params, kind) {
					var node = this.createNode();
					this.expect('[');
					var elements = [];
					while (!this.match(']')) {
						if (this.match(',')) {
							this.nextToken();
							elements.push(null);
						} else {
							if (this.match('...')) {
								elements.push(this.parseBindingRestElement(params, kind));
								break;
							} else {
								elements.push(this.parsePatternWithDefault(params, kind));
							}
							if (!this.match(']')) {
								this.expect(',');
							}
						}
					}
					this.expect(']');
					return this.finalize(node, new Node.ArrayPattern(elements));
				};
				Parser.prototype.parsePropertyPattern = function (params, kind) {
					var node = this.createNode();
					var computed = false;
					var shorthand = false;
					var method = false;
					var key;
					var value;
					if (this.lookahead.type === 3 /* Identifier */) {
							var keyToken = this.lookahead;
							key = this.parseVariableIdentifier();
							var init = this.finalize(node, new Node.Identifier(keyToken.value));
							if (this.match('=')) {
								params.push(keyToken);
								shorthand = true;
								this.nextToken();
								var expr = this.parseAssignmentExpression();
								value = this.finalize(this.startNode(keyToken), new Node.AssignmentPattern(init, expr));
							} else if (!this.match(':')) {
								params.push(keyToken);
								shorthand = true;
								value = init;
							} else {
								this.expect(':');
								value = this.parsePatternWithDefault(params, kind);
							}
						} else {
						computed = this.match('[');
						key = this.parseObjectPropertyKey();
						this.expect(':');
						value = this.parsePatternWithDefault(params, kind);
					}
					return this.finalize(node, new Node.Property('init', key, computed, value, method, shorthand));
				};
				Parser.prototype.parseObjectPattern = function (params, kind) {
					var node = this.createNode();
					var properties = [];
					this.expect('{');
					while (!this.match('}')) {
						properties.push(this.parsePropertyPattern(params, kind));
						if (!this.match('}')) {
							this.expect(',');
						}
					}
					this.expect('}');
					return this.finalize(node, new Node.ObjectPattern(properties));
				};
				Parser.prototype.parsePattern = function (params, kind) {
					var pattern;
					if (this.match('[')) {
						pattern = this.parseArrayPattern(params, kind);
					} else if (this.match('{')) {
						pattern = this.parseObjectPattern(params, kind);
					} else {
						if (this.matchKeyword('let') && (kind === 'const' || kind === 'let')) {
							this.tolerateUnexpectedToken(this.lookahead, messages_1.Messages.LetInLexicalBinding);
						}
						params.push(this.lookahead);
						pattern = this.parseVariableIdentifier(kind);
					}
					return pattern;
				};
				Parser.prototype.parsePatternWithDefault = function (params, kind) {
					var startToken = this.lookahead;
					var pattern = this.parsePattern(params, kind);
					if (this.match('=')) {
						this.nextToken();
						var previousAllowYield = this.context.allowYield;
						this.context.allowYield = true;
						var right = this.isolateCoverGrammar(this.parseAssignmentExpression);
						this.context.allowYield = previousAllowYield;
						pattern = this.finalize(this.startNode(startToken), new Node.AssignmentPattern(pattern, right));
					}
					return pattern;
				};
				// https://tc39.github.io/ecma262/#sec-variable-statement
				Parser.prototype.parseVariableIdentifier = function (kind) {
					var node = this.createNode();
					var token = this.nextToken();
					if (token.type === 4 /* Keyword */ && token.value === 'yield') {
						if (this.context.strict) {
							this.tolerateUnexpectedToken(token, messages_1.Messages.StrictReservedWord);
						} else if (!this.context.allowYield) {
							this.throwUnexpectedToken(token);
						}
					} else if (token.type !== 3 /* Identifier */) {
							if (this.context.strict && token.type === 4 /* Keyword */ && this.scanner.isStrictModeReservedWord(token.value)) {
								this.tolerateUnexpectedToken(token, messages_1.Messages.StrictReservedWord);
							} else {
								if (this.context.strict || token.value !== 'let' || kind !== 'var') {
									this.throwUnexpectedToken(token);
								}
							}
						} else if ((this.context.isModule || this.context.await) && token.type === 3 /* Identifier */ && token.value === 'await') {
						this.tolerateUnexpectedToken(token);
					}
					return this.finalize(node, new Node.Identifier(token.value));
				};
				Parser.prototype.parseVariableDeclaration = function (options) {
					var node = this.createNode();
					var params = [];
					var id = this.parsePattern(params, 'var');
					if (this.context.strict && id.type === syntax_1.Syntax.Identifier) {
						if (this.scanner.isRestrictedWord(id.name)) {
							this.tolerateError(messages_1.Messages.StrictVarName);
						}
					}
					var init = null;
					if (this.match('=')) {
						this.nextToken();
						init = this.isolateCoverGrammar(this.parseAssignmentExpression);
					} else if (id.type !== syntax_1.Syntax.Identifier && !options.inFor) {
						this.expect('=');
					}
					return this.finalize(node, new Node.VariableDeclarator(id, init));
				};
				Parser.prototype.parseVariableDeclarationList = function (options) {
					var opt = { inFor: options.inFor };
					var list = [];
					list.push(this.parseVariableDeclaration(opt));
					while (this.match(',')) {
						this.nextToken();
						list.push(this.parseVariableDeclaration(opt));
					}
					return list;
				};
				Parser.prototype.parseVariableStatement = function () {
					var node = this.createNode();
					this.expectKeyword('var');
					var declarations = this.parseVariableDeclarationList({ inFor: false });
					this.consumeSemicolon();
					return this.finalize(node, new Node.VariableDeclaration(declarations, 'var'));
				};
				// https://tc39.github.io/ecma262/#sec-empty-statement
				Parser.prototype.parseEmptyStatement = function () {
					var node = this.createNode();
					this.expect(';');
					return this.finalize(node, new Node.EmptyStatement());
				};
				// https://tc39.github.io/ecma262/#sec-expression-statement
				Parser.prototype.parseExpressionStatement = function () {
					var node = this.createNode();
					var expr = this.parseExpression();
					this.consumeSemicolon();
					return this.finalize(node, new Node.ExpressionStatement(expr));
				};
				// https://tc39.github.io/ecma262/#sec-if-statement
				Parser.prototype.parseIfClause = function () {
					if (this.context.strict && this.matchKeyword('function')) {
						this.tolerateError(messages_1.Messages.StrictFunction);
					}
					return this.parseStatement();
				};
				Parser.prototype.parseIfStatement = function () {
					var node = this.createNode();
					var consequent;
					var alternate = null;
					this.expectKeyword('if');
					this.expect('(');
					var test = this.parseExpression();
					if (!this.match(')') && this.config.tolerant) {
						this.tolerateUnexpectedToken(this.nextToken());
						consequent = this.finalize(this.createNode(), new Node.EmptyStatement());
					} else {
						this.expect(')');
						consequent = this.parseIfClause();
						if (this.matchKeyword('else')) {
							this.nextToken();
							alternate = this.parseIfClause();
						}
					}
					return this.finalize(node, new Node.IfStatement(test, consequent, alternate));
				};
				// https://tc39.github.io/ecma262/#sec-do-while-statement
				Parser.prototype.parseDoWhileStatement = function () {
					var node = this.createNode();
					this.expectKeyword('do');
					var previousInIteration = this.context.inIteration;
					this.context.inIteration = true;
					var body = this.parseStatement();
					this.context.inIteration = previousInIteration;
					this.expectKeyword('while');
					this.expect('(');
					var test = this.parseExpression();
					if (!this.match(')') && this.config.tolerant) {
						this.tolerateUnexpectedToken(this.nextToken());
					} else {
						this.expect(')');
						if (this.match(';')) {
							this.nextToken();
						}
					}
					return this.finalize(node, new Node.DoWhileStatement(body, test));
				};
				// https://tc39.github.io/ecma262/#sec-while-statement
				Parser.prototype.parseWhileStatement = function () {
					var node = this.createNode();
					var body;
					this.expectKeyword('while');
					this.expect('(');
					var test = this.parseExpression();
					if (!this.match(')') && this.config.tolerant) {
						this.tolerateUnexpectedToken(this.nextToken());
						body = this.finalize(this.createNode(), new Node.EmptyStatement());
					} else {
						this.expect(')');
						var previousInIteration = this.context.inIteration;
						this.context.inIteration = true;
						body = this.parseStatement();
						this.context.inIteration = previousInIteration;
					}
					return this.finalize(node, new Node.WhileStatement(test, body));
				};
				// https://tc39.github.io/ecma262/#sec-for-statement
				// https://tc39.github.io/ecma262/#sec-for-in-and-for-of-statements
				Parser.prototype.parseForStatement = function () {
					var init = null;
					var test = null;
					var update = null;
					var forIn = true;
					var left, right;
					var node = this.createNode();
					this.expectKeyword('for');
					this.expect('(');
					if (this.match(';')) {
						this.nextToken();
					} else {
						if (this.matchKeyword('var')) {
							init = this.createNode();
							this.nextToken();
							var previousAllowIn = this.context.allowIn;
							this.context.allowIn = false;
							var declarations = this.parseVariableDeclarationList({ inFor: true });
							this.context.allowIn = previousAllowIn;
							if (declarations.length === 1 && this.matchKeyword('in')) {
								var decl = declarations[0];
								if (decl.init && (decl.id.type === syntax_1.Syntax.ArrayPattern || decl.id.type === syntax_1.Syntax.ObjectPattern || this.context.strict)) {
									this.tolerateError(messages_1.Messages.ForInOfLoopInitializer, 'for-in');
								}
								init = this.finalize(init, new Node.VariableDeclaration(declarations, 'var'));
								this.nextToken();
								left = init;
								right = this.parseExpression();
								init = null;
							} else if (declarations.length === 1 && declarations[0].init === null && this.matchContextualKeyword('of')) {
								init = this.finalize(init, new Node.VariableDeclaration(declarations, 'var'));
								this.nextToken();
								left = init;
								right = this.parseAssignmentExpression();
								init = null;
								forIn = false;
							} else {
								init = this.finalize(init, new Node.VariableDeclaration(declarations, 'var'));
								this.expect(';');
							}
						} else if (this.matchKeyword('const') || this.matchKeyword('let')) {
							init = this.createNode();
							var kind = this.nextToken().value;
							if (!this.context.strict && this.lookahead.value === 'in') {
								init = this.finalize(init, new Node.Identifier(kind));
								this.nextToken();
								left = init;
								right = this.parseExpression();
								init = null;
							} else {
								var previousAllowIn = this.context.allowIn;
								this.context.allowIn = false;
								var declarations = this.parseBindingList(kind, { inFor: true });
								this.context.allowIn = previousAllowIn;
								if (declarations.length === 1 && declarations[0].init === null && this.matchKeyword('in')) {
									init = this.finalize(init, new Node.VariableDeclaration(declarations, kind));
									this.nextToken();
									left = init;
									right = this.parseExpression();
									init = null;
								} else if (declarations.length === 1 && declarations[0].init === null && this.matchContextualKeyword('of')) {
									init = this.finalize(init, new Node.VariableDeclaration(declarations, kind));
									this.nextToken();
									left = init;
									right = this.parseAssignmentExpression();
									init = null;
									forIn = false;
								} else {
									this.consumeSemicolon();
									init = this.finalize(init, new Node.VariableDeclaration(declarations, kind));
								}
							}
						} else {
							var initStartToken = this.lookahead;
							var previousAllowIn = this.context.allowIn;
							this.context.allowIn = false;
							init = this.inheritCoverGrammar(this.parseAssignmentExpression);
							this.context.allowIn = previousAllowIn;
							if (this.matchKeyword('in')) {
								if (!this.context.isAssignmentTarget || init.type === syntax_1.Syntax.AssignmentExpression) {
									this.tolerateError(messages_1.Messages.InvalidLHSInForIn);
								}
								this.nextToken();
								this.reinterpretExpressionAsPattern(init);
								left = init;
								right = this.parseExpression();
								init = null;
							} else if (this.matchContextualKeyword('of')) {
								if (!this.context.isAssignmentTarget || init.type === syntax_1.Syntax.AssignmentExpression) {
									this.tolerateError(messages_1.Messages.InvalidLHSInForLoop);
								}
								this.nextToken();
								this.reinterpretExpressionAsPattern(init);
								left = init;
								right = this.parseAssignmentExpression();
								init = null;
								forIn = false;
							} else {
								if (this.match(',')) {
									var initSeq = [init];
									while (this.match(',')) {
										this.nextToken();
										initSeq.push(this.isolateCoverGrammar(this.parseAssignmentExpression));
									}
									init = this.finalize(this.startNode(initStartToken), new Node.SequenceExpression(initSeq));
								}
								this.expect(';');
							}
						}
					}
					if (typeof left === 'undefined') {
						if (!this.match(';')) {
							test = this.parseExpression();
						}
						this.expect(';');
						if (!this.match(')')) {
							update = this.parseExpression();
						}
					}
					var body;
					if (!this.match(')') && this.config.tolerant) {
						this.tolerateUnexpectedToken(this.nextToken());
						body = this.finalize(this.createNode(), new Node.EmptyStatement());
					} else {
						this.expect(')');
						var previousInIteration = this.context.inIteration;
						this.context.inIteration = true;
						body = this.isolateCoverGrammar(this.parseStatement);
						this.context.inIteration = previousInIteration;
					}
					return typeof left === 'undefined' ? this.finalize(node, new Node.ForStatement(init, test, update, body)) : forIn ? this.finalize(node, new Node.ForInStatement(left, right, body)) : this.finalize(node, new Node.ForOfStatement(left, right, body));
				};
				// https://tc39.github.io/ecma262/#sec-continue-statement
				Parser.prototype.parseContinueStatement = function () {
					var node = this.createNode();
					this.expectKeyword('continue');
					var label = null;
					if (this.lookahead.type === 3 /* Identifier */ && !this.hasLineTerminator) {
						var id = this.parseVariableIdentifier();
						label = id;
						var key = '$' + id.name;
						if (!Object.prototype.hasOwnProperty.call(this.context.labelSet, key)) {
							this.throwError(messages_1.Messages.UnknownLabel, id.name);
						}
					}
					this.consumeSemicolon();
					if (label === null && !this.context.inIteration) {
						this.throwError(messages_1.Messages.IllegalContinue);
					}
					return this.finalize(node, new Node.ContinueStatement(label));
				};
				// https://tc39.github.io/ecma262/#sec-break-statement
				Parser.prototype.parseBreakStatement = function () {
					var node = this.createNode();
					this.expectKeyword('break');
					var label = null;
					if (this.lookahead.type === 3 /* Identifier */ && !this.hasLineTerminator) {
						var id = this.parseVariableIdentifier();
						var key = '$' + id.name;
						if (!Object.prototype.hasOwnProperty.call(this.context.labelSet, key)) {
							this.throwError(messages_1.Messages.UnknownLabel, id.name);
						}
						label = id;
					}
					this.consumeSemicolon();
					if (label === null && !this.context.inIteration && !this.context.inSwitch) {
						this.throwError(messages_1.Messages.IllegalBreak);
					}
					return this.finalize(node, new Node.BreakStatement(label));
				};
				// https://tc39.github.io/ecma262/#sec-return-statement
				Parser.prototype.parseReturnStatement = function () {
					if (!this.context.inFunctionBody) {
						this.tolerateError(messages_1.Messages.IllegalReturn);
					}
					var node = this.createNode();
					this.expectKeyword('return');
					var hasArgument = !this.match(';') && !this.match('}') && !this.hasLineTerminator && this.lookahead.type !== 2 /* EOF */;
					var argument = hasArgument ? this.parseExpression() : null;
					this.consumeSemicolon();
					return this.finalize(node, new Node.ReturnStatement(argument));
				};
				// https://tc39.github.io/ecma262/#sec-with-statement
				Parser.prototype.parseWithStatement = function () {
					if (this.context.strict) {
						this.tolerateError(messages_1.Messages.StrictModeWith);
					}
					var node = this.createNode();
					var body;
					this.expectKeyword('with');
					this.expect('(');
					var object = this.parseExpression();
					if (!this.match(')') && this.config.tolerant) {
						this.tolerateUnexpectedToken(this.nextToken());
						body = this.finalize(this.createNode(), new Node.EmptyStatement());
					} else {
						this.expect(')');
						body = this.parseStatement();
					}
					return this.finalize(node, new Node.WithStatement(object, body));
				};
				// https://tc39.github.io/ecma262/#sec-switch-statement
				Parser.prototype.parseSwitchCase = function () {
					var node = this.createNode();
					var test;
					if (this.matchKeyword('default')) {
						this.nextToken();
						test = null;
					} else {
						this.expectKeyword('case');
						test = this.parseExpression();
					}
					this.expect(':');
					var consequent = [];
					while (true) {
						if (this.match('}') || this.matchKeyword('default') || this.matchKeyword('case')) {
							break;
						}
						consequent.push(this.parseStatementListItem());
					}
					return this.finalize(node, new Node.SwitchCase(test, consequent));
				};
				Parser.prototype.parseSwitchStatement = function () {
					var node = this.createNode();
					this.expectKeyword('switch');
					this.expect('(');
					var discriminant = this.parseExpression();
					this.expect(')');
					var previousInSwitch = this.context.inSwitch;
					this.context.inSwitch = true;
					var cases = [];
					var defaultFound = false;
					this.expect('{');
					while (true) {
						if (this.match('}')) {
							break;
						}
						var clause = this.parseSwitchCase();
						if (clause.test === null) {
							if (defaultFound) {
								this.throwError(messages_1.Messages.MultipleDefaultsInSwitch);
							}
							defaultFound = true;
						}
						cases.push(clause);
					}
					this.expect('}');
					this.context.inSwitch = previousInSwitch;
					return this.finalize(node, new Node.SwitchStatement(discriminant, cases));
				};
				// https://tc39.github.io/ecma262/#sec-labelled-statements
				Parser.prototype.parseLabelledStatement = function () {
					var node = this.createNode();
					var expr = this.parseExpression();
					var statement;
					if (expr.type === syntax_1.Syntax.Identifier && this.match(':')) {
						this.nextToken();
						var id = expr;
						var key = '$' + id.name;
						if (Object.prototype.hasOwnProperty.call(this.context.labelSet, key)) {
							this.throwError(messages_1.Messages.Redeclaration, 'Label', id.name);
						}
						this.context.labelSet[key] = true;
						var body = void 0;
						if (this.matchKeyword('class')) {
							this.tolerateUnexpectedToken(this.lookahead);
							body = this.parseClassDeclaration();
						} else if (this.matchKeyword('function')) {
							var token = this.lookahead;
							var declaration = this.parseFunctionDeclaration();
							if (this.context.strict) {
								this.tolerateUnexpectedToken(token, messages_1.Messages.StrictFunction);
							} else if (declaration.generator) {
								this.tolerateUnexpectedToken(token, messages_1.Messages.GeneratorInLegacyContext);
							}
							body = declaration;
						} else {
							body = this.parseStatement();
						}
						delete this.context.labelSet[key];
						statement = new Node.LabeledStatement(id, body);
					} else {
						this.consumeSemicolon();
						statement = new Node.ExpressionStatement(expr);
					}
					return this.finalize(node, statement);
				};
				// https://tc39.github.io/ecma262/#sec-throw-statement
				Parser.prototype.parseThrowStatement = function () {
					var node = this.createNode();
					this.expectKeyword('throw');
					if (this.hasLineTerminator) {
						this.throwError(messages_1.Messages.NewlineAfterThrow);
					}
					var argument = this.parseExpression();
					this.consumeSemicolon();
					return this.finalize(node, new Node.ThrowStatement(argument));
				};
				// https://tc39.github.io/ecma262/#sec-try-statement
				Parser.prototype.parseCatchClause = function () {
					var node = this.createNode();
					this.expectKeyword('catch');
					this.expect('(');
					if (this.match(')')) {
						this.throwUnexpectedToken(this.lookahead);
					}
					var params = [];
					var param = this.parsePattern(params);
					var paramMap = {};
					for (var i = 0; i < params.length; i++) {
						var key = '$' + params[i].value;
						if (Object.prototype.hasOwnProperty.call(paramMap, key)) {
							this.tolerateError(messages_1.Messages.DuplicateBinding, params[i].value);
						}
						paramMap[key] = true;
					}
					if (this.context.strict && param.type === syntax_1.Syntax.Identifier) {
						if (this.scanner.isRestrictedWord(param.name)) {
							this.tolerateError(messages_1.Messages.StrictCatchVariable);
						}
					}
					this.expect(')');
					var body = this.parseBlock();
					return this.finalize(node, new Node.CatchClause(param, body));
				};
				Parser.prototype.parseFinallyClause = function () {
					this.expectKeyword('finally');
					return this.parseBlock();
				};
				Parser.prototype.parseTryStatement = function () {
					var node = this.createNode();
					this.expectKeyword('try');
					var block = this.parseBlock();
					var handler = this.matchKeyword('catch') ? this.parseCatchClause() : null;
					var finalizer = this.matchKeyword('finally') ? this.parseFinallyClause() : null;
					if (!handler && !finalizer) {
						this.throwError(messages_1.Messages.NoCatchOrFinally);
					}
					return this.finalize(node, new Node.TryStatement(block, handler, finalizer));
				};
				// https://tc39.github.io/ecma262/#sec-debugger-statement
				Parser.prototype.parseDebuggerStatement = function () {
					var node = this.createNode();
					this.expectKeyword('debugger');
					this.consumeSemicolon();
					return this.finalize(node, new Node.DebuggerStatement());
				};
				// https://tc39.github.io/ecma262/#sec-ecmascript-language-statements-and-declarations
				Parser.prototype.parseStatement = function () {
					var statement;
					switch (this.lookahead.type) {
						case 1 /* BooleanLiteral */:
						case 5 /* NullLiteral */:
						case 6 /* NumericLiteral */:
						case 8 /* StringLiteral */:
						case 10 /* Template */:
						case 9 /* RegularExpression */:
							statement = this.parseExpressionStatement();
							break;
						case 7 /* Punctuator */:
							var value = this.lookahead.value;
							if (value === '{') {
								statement = this.parseBlock();
							} else if (value === '(') {
								statement = this.parseExpressionStatement();
							} else if (value === ';') {
								statement = this.parseEmptyStatement();
							} else {
								statement = this.parseExpressionStatement();
							}
							break;
						case 3 /* Identifier */:
							statement = this.matchAsyncFunction() ? this.parseFunctionDeclaration() : this.parseLabelledStatement();
							break;
						case 4 /* Keyword */:
							switch (this.lookahead.value) {
								case 'break':
									statement = this.parseBreakStatement();
									break;
								case 'continue':
									statement = this.parseContinueStatement();
									break;
								case 'debugger':
									statement = this.parseDebuggerStatement();
									break;
								case 'do':
									statement = this.parseDoWhileStatement();
									break;
								case 'for':
									statement = this.parseForStatement();
									break;
								case 'function':
									statement = this.parseFunctionDeclaration();
									break;
								case 'if':
									statement = this.parseIfStatement();
									break;
								case 'return':
									statement = this.parseReturnStatement();
									break;
								case 'switch':
									statement = this.parseSwitchStatement();
									break;
								case 'throw':
									statement = this.parseThrowStatement();
									break;
								case 'try':
									statement = this.parseTryStatement();
									break;
								case 'var':
									statement = this.parseVariableStatement();
									break;
								case 'while':
									statement = this.parseWhileStatement();
									break;
								case 'with':
									statement = this.parseWithStatement();
									break;
								default:
									statement = this.parseExpressionStatement();
									break;
							}
							break;
						default:
							statement = this.throwUnexpectedToken(this.lookahead);
					}
					return statement;
				};
				// https://tc39.github.io/ecma262/#sec-function-definitions
				Parser.prototype.parseFunctionSourceElements = function () {
					var node = this.createNode();
					this.expect('{');
					var body = this.parseDirectivePrologues();
					var previousLabelSet = this.context.labelSet;
					var previousInIteration = this.context.inIteration;
					var previousInSwitch = this.context.inSwitch;
					var previousInFunctionBody = this.context.inFunctionBody;
					this.context.labelSet = {};
					this.context.inIteration = false;
					this.context.inSwitch = false;
					this.context.inFunctionBody = true;
					while (this.lookahead.type !== 2 /* EOF */) {
						if (this.match('}')) {
							break;
						}
						body.push(this.parseStatementListItem());
					}
					this.expect('}');
					this.context.labelSet = previousLabelSet;
					this.context.inIteration = previousInIteration;
					this.context.inSwitch = previousInSwitch;
					this.context.inFunctionBody = previousInFunctionBody;
					return this.finalize(node, new Node.BlockStatement(body));
				};
				Parser.prototype.validateParam = function (options, param, name) {
					var key = '$' + name;
					if (this.context.strict) {
						if (this.scanner.isRestrictedWord(name)) {
							options.stricted = param;
							options.message = messages_1.Messages.StrictParamName;
						}
						if (Object.prototype.hasOwnProperty.call(options.paramSet, key)) {
							options.stricted = param;
							options.message = messages_1.Messages.StrictParamDupe;
						}
					} else if (!options.firstRestricted) {
						if (this.scanner.isRestrictedWord(name)) {
							options.firstRestricted = param;
							options.message = messages_1.Messages.StrictParamName;
						} else if (this.scanner.isStrictModeReservedWord(name)) {
							options.firstRestricted = param;
							options.message = messages_1.Messages.StrictReservedWord;
						} else if (Object.prototype.hasOwnProperty.call(options.paramSet, key)) {
							options.stricted = param;
							options.message = messages_1.Messages.StrictParamDupe;
						}
					}
					/* istanbul ignore next */
					if (typeof Object.defineProperty === 'function') {
						Object.defineProperty(options.paramSet, key, { value: true, enumerable: true, writable: true, configurable: true });
					} else {
						options.paramSet[key] = true;
					}
				};
				Parser.prototype.parseRestElement = function (params) {
					var node = this.createNode();
					this.expect('...');
					var arg = this.parsePattern(params);
					if (this.match('=')) {
						this.throwError(messages_1.Messages.DefaultRestParameter);
					}
					if (!this.match(')')) {
						this.throwError(messages_1.Messages.ParameterAfterRestParameter);
					}
					return this.finalize(node, new Node.RestElement(arg));
				};
				Parser.prototype.parseFormalParameter = function (options) {
					var params = [];
					var param = this.match('...') ? this.parseRestElement(params) : this.parsePatternWithDefault(params);
					for (var i = 0; i < params.length; i++) {
						this.validateParam(options, params[i], params[i].value);
					}
					options.simple = options.simple && param instanceof Node.Identifier;
					options.params.push(param);
				};
				Parser.prototype.parseFormalParameters = function (firstRestricted) {
					var options;
					options = {
						simple: true,
						params: [],
						firstRestricted: firstRestricted
					};
					this.expect('(');
					if (!this.match(')')) {
						options.paramSet = {};
						while (this.lookahead.type !== 2 /* EOF */) {
							this.parseFormalParameter(options);
							if (this.match(')')) {
								break;
							}
							this.expect(',');
							if (this.match(')')) {
								break;
							}
						}
					}
					this.expect(')');
					return {
						simple: options.simple,
						params: options.params,
						stricted: options.stricted,
						firstRestricted: options.firstRestricted,
						message: options.message
					};
				};
				Parser.prototype.matchAsyncFunction = function () {
					var match = this.matchContextualKeyword('async');
					if (match) {
						var state = this.scanner.saveState();
						this.scanner.scanComments();
						var next = this.scanner.lex();
						this.scanner.restoreState(state);
						match = state.lineNumber === next.lineNumber && next.type === 4 /* Keyword */ && next.value === 'function';
					}
					return match;
				};
				Parser.prototype.parseFunctionDeclaration = function (identifierIsOptional) {
					var node = this.createNode();
					var isAsync = this.matchContextualKeyword('async');
					if (isAsync) {
						this.nextToken();
					}
					this.expectKeyword('function');
					var isGenerator = isAsync ? false : this.match('*');
					if (isGenerator) {
						this.nextToken();
					}
					var message;
					var id = null;
					var firstRestricted = null;
					if (!identifierIsOptional || !this.match('(')) {
						var token = this.lookahead;
						id = this.parseVariableIdentifier();
						if (this.context.strict) {
							if (this.scanner.isRestrictedWord(token.value)) {
								this.tolerateUnexpectedToken(token, messages_1.Messages.StrictFunctionName);
							}
						} else {
							if (this.scanner.isRestrictedWord(token.value)) {
								firstRestricted = token;
								message = messages_1.Messages.StrictFunctionName;
							} else if (this.scanner.isStrictModeReservedWord(token.value)) {
								firstRestricted = token;
								message = messages_1.Messages.StrictReservedWord;
							}
						}
					}
					var previousAllowAwait = this.context.await;
					var previousAllowYield = this.context.allowYield;
					this.context.await = isAsync;
					this.context.allowYield = !isGenerator;
					var formalParameters = this.parseFormalParameters(firstRestricted);
					var params = formalParameters.params;
					var stricted = formalParameters.stricted;
					firstRestricted = formalParameters.firstRestricted;
					if (formalParameters.message) {
						message = formalParameters.message;
					}
					var previousStrict = this.context.strict;
					var previousAllowStrictDirective = this.context.allowStrictDirective;
					this.context.allowStrictDirective = formalParameters.simple;
					var body = this.parseFunctionSourceElements();
					if (this.context.strict && firstRestricted) {
						this.throwUnexpectedToken(firstRestricted, message);
					}
					if (this.context.strict && stricted) {
						this.tolerateUnexpectedToken(stricted, message);
					}
					this.context.strict = previousStrict;
					this.context.allowStrictDirective = previousAllowStrictDirective;
					this.context.await = previousAllowAwait;
					this.context.allowYield = previousAllowYield;
					return isAsync ? this.finalize(node, new Node.AsyncFunctionDeclaration(id, params, body)) : this.finalize(node, new Node.FunctionDeclaration(id, params, body, isGenerator));
				};
				Parser.prototype.parseFunctionExpression = function () {
					var node = this.createNode();
					var isAsync = this.matchContextualKeyword('async');
					if (isAsync) {
						this.nextToken();
					}
					this.expectKeyword('function');
					var isGenerator = isAsync ? false : this.match('*');
					if (isGenerator) {
						this.nextToken();
					}
					var message;
					var id = null;
					var firstRestricted;
					var previousAllowAwait = this.context.await;
					var previousAllowYield = this.context.allowYield;
					this.context.await = isAsync;
					this.context.allowYield = !isGenerator;
					if (!this.match('(')) {
						var token = this.lookahead;
						id = !this.context.strict && !isGenerator && this.matchKeyword('yield') ? this.parseIdentifierName() : this.parseVariableIdentifier();
						if (this.context.strict) {
							if (this.scanner.isRestrictedWord(token.value)) {
								this.tolerateUnexpectedToken(token, messages_1.Messages.StrictFunctionName);
							}
						} else {
							if (this.scanner.isRestrictedWord(token.value)) {
								firstRestricted = token;
								message = messages_1.Messages.StrictFunctionName;
							} else if (this.scanner.isStrictModeReservedWord(token.value)) {
								firstRestricted = token;
								message = messages_1.Messages.StrictReservedWord;
							}
						}
					}
					var formalParameters = this.parseFormalParameters(firstRestricted);
					var params = formalParameters.params;
					var stricted = formalParameters.stricted;
					firstRestricted = formalParameters.firstRestricted;
					if (formalParameters.message) {
						message = formalParameters.message;
					}
					var previousStrict = this.context.strict;
					var previousAllowStrictDirective = this.context.allowStrictDirective;
					this.context.allowStrictDirective = formalParameters.simple;
					var body = this.parseFunctionSourceElements();
					if (this.context.strict && firstRestricted) {
						this.throwUnexpectedToken(firstRestricted, message);
					}
					if (this.context.strict && stricted) {
						this.tolerateUnexpectedToken(stricted, message);
					}
					this.context.strict = previousStrict;
					this.context.allowStrictDirective = previousAllowStrictDirective;
					this.context.await = previousAllowAwait;
					this.context.allowYield = previousAllowYield;
					return isAsync ? this.finalize(node, new Node.AsyncFunctionExpression(id, params, body)) : this.finalize(node, new Node.FunctionExpression(id, params, body, isGenerator));
				};
				// https://tc39.github.io/ecma262/#sec-directive-prologues-and-the-use-strict-directive
				Parser.prototype.parseDirective = function () {
					var token = this.lookahead;
					var node = this.createNode();
					var expr = this.parseExpression();
					var directive = expr.type === syntax_1.Syntax.Literal ? this.getTokenRaw(token).slice(1, -1) : null;
					this.consumeSemicolon();
					return this.finalize(node, directive ? new Node.Directive(expr, directive) : new Node.ExpressionStatement(expr));
				};
				Parser.prototype.parseDirectivePrologues = function () {
					var firstRestricted = null;
					var body = [];
					while (true) {
						var token = this.lookahead;
						if (token.type !== 8 /* StringLiteral */) {
								break;
							}
						var statement = this.parseDirective();
						body.push(statement);
						var directive = statement.directive;
						if (typeof directive !== 'string') {
							break;
						}
						if (directive === 'use strict') {
							this.context.strict = true;
							if (firstRestricted) {
								this.tolerateUnexpectedToken(firstRestricted, messages_1.Messages.StrictOctalLiteral);
							}
							if (!this.context.allowStrictDirective) {
								this.tolerateUnexpectedToken(token, messages_1.Messages.IllegalLanguageModeDirective);
							}
						} else {
							if (!firstRestricted && token.octal) {
								firstRestricted = token;
							}
						}
					}
					return body;
				};
				// https://tc39.github.io/ecma262/#sec-method-definitions
				Parser.prototype.qualifiedPropertyName = function (token) {
					switch (token.type) {
						case 3 /* Identifier */:
						case 8 /* StringLiteral */:
						case 1 /* BooleanLiteral */:
						case 5 /* NullLiteral */:
						case 6 /* NumericLiteral */:
						case 4 /* Keyword */:
							return true;
						case 7 /* Punctuator */:
							return token.value === '[';
						default:
							break;
					}
					return false;
				};
				Parser.prototype.parseGetterMethod = function () {
					var node = this.createNode();
					var isGenerator = false;
					var previousAllowYield = this.context.allowYield;
					this.context.allowYield = false;
					var formalParameters = this.parseFormalParameters();
					if (formalParameters.params.length > 0) {
						this.tolerateError(messages_1.Messages.BadGetterArity);
					}
					var method = this.parsePropertyMethod(formalParameters);
					this.context.allowYield = previousAllowYield;
					return this.finalize(node, new Node.FunctionExpression(null, formalParameters.params, method, isGenerator));
				};
				Parser.prototype.parseSetterMethod = function () {
					var node = this.createNode();
					var isGenerator = false;
					var previousAllowYield = this.context.allowYield;
					this.context.allowYield = false;
					var formalParameters = this.parseFormalParameters();
					if (formalParameters.params.length !== 1) {
						this.tolerateError(messages_1.Messages.BadSetterArity);
					} else if (formalParameters.params[0] instanceof Node.RestElement) {
						this.tolerateError(messages_1.Messages.BadSetterRestParameter);
					}
					var method = this.parsePropertyMethod(formalParameters);
					this.context.allowYield = previousAllowYield;
					return this.finalize(node, new Node.FunctionExpression(null, formalParameters.params, method, isGenerator));
				};
				Parser.prototype.parseGeneratorMethod = function () {
					var node = this.createNode();
					var isGenerator = true;
					var previousAllowYield = this.context.allowYield;
					this.context.allowYield = true;
					var params = this.parseFormalParameters();
					this.context.allowYield = false;
					var method = this.parsePropertyMethod(params);
					this.context.allowYield = previousAllowYield;
					return this.finalize(node, new Node.FunctionExpression(null, params.params, method, isGenerator));
				};
				// https://tc39.github.io/ecma262/#sec-generator-function-definitions
				Parser.prototype.isStartOfExpression = function () {
					var start = true;
					var value = this.lookahead.value;
					switch (this.lookahead.type) {
						case 7 /* Punctuator */:
							start = value === '[' || value === '(' || value === '{' || value === '+' || value === '-' || value === '!' || value === '~' || value === '++' || value === '--' || value === '/' || value === '/='; // regular expression literal
							break;
						case 4 /* Keyword */:
							start = value === 'class' || value === 'delete' || value === 'function' || value === 'let' || value === 'new' || value === 'super' || value === 'this' || value === 'typeof' || value === 'void' || value === 'yield';
							break;
						default:
							break;
					}
					return start;
				};
				Parser.prototype.parseYieldExpression = function () {
					var node = this.createNode();
					this.expectKeyword('yield');
					var argument = null;
					var delegate = false;
					if (!this.hasLineTerminator) {
						var previousAllowYield = this.context.allowYield;
						this.context.allowYield = false;
						delegate = this.match('*');
						if (delegate) {
							this.nextToken();
							argument = this.parseAssignmentExpression();
						} else if (this.isStartOfExpression()) {
							argument = this.parseAssignmentExpression();
						}
						this.context.allowYield = previousAllowYield;
					}
					return this.finalize(node, new Node.YieldExpression(argument, delegate));
				};
				// https://tc39.github.io/ecma262/#sec-class-definitions
				Parser.prototype.parseClassElement = function (hasConstructor) {
					var token = this.lookahead;
					var node = this.createNode();
					var kind = '';
					var key = null;
					var value = null;
					var computed = false;
					var method = false;
					var isStatic = false;
					var isAsync = false;
					if (this.match('*')) {
						this.nextToken();
					} else {
						computed = this.match('[');
						key = this.parseObjectPropertyKey();
						var id = key;
						if (id.name === 'static' && (this.qualifiedPropertyName(this.lookahead) || this.match('*'))) {
							token = this.lookahead;
							isStatic = true;
							computed = this.match('[');
							if (this.match('*')) {
								this.nextToken();
							} else {
								key = this.parseObjectPropertyKey();
							}
						}
						if (token.type === 3 /* Identifier */ && !this.hasLineTerminator && token.value === 'async') {
							var punctuator = this.lookahead.value;
							if (punctuator !== ':' && punctuator !== '(' && punctuator !== '*') {
								isAsync = true;
								token = this.lookahead;
								key = this.parseObjectPropertyKey();
								if (token.type === 3 /* Identifier */) {
										if (token.value === 'get' || token.value === 'set') {
											this.tolerateUnexpectedToken(token);
										} else if (token.value === 'constructor') {
											this.tolerateUnexpectedToken(token, messages_1.Messages.ConstructorIsAsync);
										}
									}
							}
						}
					}
					var lookaheadPropertyKey = this.qualifiedPropertyName(this.lookahead);
					if (token.type === 3 /* Identifier */) {
							if (token.value === 'get' && lookaheadPropertyKey) {
								kind = 'get';
								computed = this.match('[');
								key = this.parseObjectPropertyKey();
								this.context.allowYield = false;
								value = this.parseGetterMethod();
							} else if (token.value === 'set' && lookaheadPropertyKey) {
								kind = 'set';
								computed = this.match('[');
								key = this.parseObjectPropertyKey();
								value = this.parseSetterMethod();
							}
						} else if (token.type === 7 /* Punctuator */ && token.value === '*' && lookaheadPropertyKey) {
						kind = 'init';
						computed = this.match('[');
						key = this.parseObjectPropertyKey();
						value = this.parseGeneratorMethod();
						method = true;
					}
					if (!kind && key && this.match('(')) {
						kind = 'init';
						value = isAsync ? this.parsePropertyMethodAsyncFunction() : this.parsePropertyMethodFunction();
						method = true;
					}
					if (!kind) {
						this.throwUnexpectedToken(this.lookahead);
					}
					if (kind === 'init') {
						kind = 'method';
					}
					if (!computed) {
						if (isStatic && this.isPropertyKey(key, 'prototype')) {
							this.throwUnexpectedToken(token, messages_1.Messages.StaticPrototype);
						}
						if (!isStatic && this.isPropertyKey(key, 'constructor')) {
							if (kind !== 'method' || !method || value && value.generator) {
								this.throwUnexpectedToken(token, messages_1.Messages.ConstructorSpecialMethod);
							}
							if (hasConstructor.value) {
								this.throwUnexpectedToken(token, messages_1.Messages.DuplicateConstructor);
							} else {
								hasConstructor.value = true;
							}
							kind = 'constructor';
						}
					}
					return this.finalize(node, new Node.MethodDefinition(key, computed, value, kind, isStatic));
				};
				Parser.prototype.parseClassElementList = function () {
					var body = [];
					var hasConstructor = { value: false };
					this.expect('{');
					while (!this.match('}')) {
						if (this.match(';')) {
							this.nextToken();
						} else {
							body.push(this.parseClassElement(hasConstructor));
						}
					}
					this.expect('}');
					return body;
				};
				Parser.prototype.parseClassBody = function () {
					var node = this.createNode();
					var elementList = this.parseClassElementList();
					return this.finalize(node, new Node.ClassBody(elementList));
				};
				Parser.prototype.parseClassDeclaration = function (identifierIsOptional) {
					var node = this.createNode();
					var previousStrict = this.context.strict;
					this.context.strict = true;
					this.expectKeyword('class');
					var id = identifierIsOptional && this.lookahead.type !== 3 /* Identifier */ ? null : this.parseVariableIdentifier();
					var superClass = null;
					if (this.matchKeyword('extends')) {
						this.nextToken();
						superClass = this.isolateCoverGrammar(this.parseLeftHandSideExpressionAllowCall);
					}
					var classBody = this.parseClassBody();
					this.context.strict = previousStrict;
					return this.finalize(node, new Node.ClassDeclaration(id, superClass, classBody));
				};
				Parser.prototype.parseClassExpression = function () {
					var node = this.createNode();
					var previousStrict = this.context.strict;
					this.context.strict = true;
					this.expectKeyword('class');
					var id = this.lookahead.type === 3 /* Identifier */ ? this.parseVariableIdentifier() : null;
					var superClass = null;
					if (this.matchKeyword('extends')) {
						this.nextToken();
						superClass = this.isolateCoverGrammar(this.parseLeftHandSideExpressionAllowCall);
					}
					var classBody = this.parseClassBody();
					this.context.strict = previousStrict;
					return this.finalize(node, new Node.ClassExpression(id, superClass, classBody));
				};
				// https://tc39.github.io/ecma262/#sec-scripts
				// https://tc39.github.io/ecma262/#sec-modules
				Parser.prototype.parseModule = function () {
					this.context.strict = true;
					this.context.isModule = true;
					var node = this.createNode();
					var body = this.parseDirectivePrologues();
					while (this.lookahead.type !== 2 /* EOF */) {
						body.push(this.parseStatementListItem());
					}
					return this.finalize(node, new Node.Module(body));
				};
				Parser.prototype.parseScript = function () {
					var node = this.createNode();
					var body = this.parseDirectivePrologues();
					while (this.lookahead.type !== 2 /* EOF */) {
						body.push(this.parseStatementListItem());
					}
					return this.finalize(node, new Node.Script(body));
				};
				// https://tc39.github.io/ecma262/#sec-imports
				Parser.prototype.parseModuleSpecifier = function () {
					var node = this.createNode();
					if (this.lookahead.type !== 8 /* StringLiteral */) {
							this.throwError(messages_1.Messages.InvalidModuleSpecifier);
						}
					var token = this.nextToken();
					var raw = this.getTokenRaw(token);
					return this.finalize(node, new Node.Literal(token.value, raw));
				};
				// import {<foo as bar>} ...;
				Parser.prototype.parseImportSpecifier = function () {
					var node = this.createNode();
					var imported;
					var local;
					if (this.lookahead.type === 3 /* Identifier */) {
							imported = this.parseVariableIdentifier();
							local = imported;
							if (this.matchContextualKeyword('as')) {
								this.nextToken();
								local = this.parseVariableIdentifier();
							}
						} else {
						imported = this.parseIdentifierName();
						local = imported;
						if (this.matchContextualKeyword('as')) {
							this.nextToken();
							local = this.parseVariableIdentifier();
						} else {
							this.throwUnexpectedToken(this.nextToken());
						}
					}
					return this.finalize(node, new Node.ImportSpecifier(local, imported));
				};
				// {foo, bar as bas}
				Parser.prototype.parseNamedImports = function () {
					this.expect('{');
					var specifiers = [];
					while (!this.match('}')) {
						specifiers.push(this.parseImportSpecifier());
						if (!this.match('}')) {
							this.expect(',');
						}
					}
					this.expect('}');
					return specifiers;
				};
				// import <foo> ...;
				Parser.prototype.parseImportDefaultSpecifier = function () {
					var node = this.createNode();
					var local = this.parseIdentifierName();
					return this.finalize(node, new Node.ImportDefaultSpecifier(local));
				};
				// import <* as foo> ...;
				Parser.prototype.parseImportNamespaceSpecifier = function () {
					var node = this.createNode();
					this.expect('*');
					if (!this.matchContextualKeyword('as')) {
						this.throwError(messages_1.Messages.NoAsAfterImportNamespace);
					}
					this.nextToken();
					var local = this.parseIdentifierName();
					return this.finalize(node, new Node.ImportNamespaceSpecifier(local));
				};
				Parser.prototype.parseImportDeclaration = function () {
					if (this.context.inFunctionBody) {
						this.throwError(messages_1.Messages.IllegalImportDeclaration);
					}
					var node = this.createNode();
					this.expectKeyword('import');
					var src;
					var specifiers = [];
					if (this.lookahead.type === 8 /* StringLiteral */) {
							// import 'foo';
							src = this.parseModuleSpecifier();
						} else {
						if (this.match('{')) {
							// import {bar}
							specifiers = specifiers.concat(this.parseNamedImports());
						} else if (this.match('*')) {
							// import * as foo
							specifiers.push(this.parseImportNamespaceSpecifier());
						} else if (this.isIdentifierName(this.lookahead) && !this.matchKeyword('default')) {
							// import foo
							specifiers.push(this.parseImportDefaultSpecifier());
							if (this.match(',')) {
								this.nextToken();
								if (this.match('*')) {
									// import foo, * as foo
									specifiers.push(this.parseImportNamespaceSpecifier());
								} else if (this.match('{')) {
									// import foo, {bar}
									specifiers = specifiers.concat(this.parseNamedImports());
								} else {
									this.throwUnexpectedToken(this.lookahead);
								}
							}
						} else {
							this.throwUnexpectedToken(this.nextToken());
						}
						if (!this.matchContextualKeyword('from')) {
							var message = this.lookahead.value ? messages_1.Messages.UnexpectedToken : messages_1.Messages.MissingFromClause;
							this.throwError(message, this.lookahead.value);
						}
						this.nextToken();
						src = this.parseModuleSpecifier();
					}
					this.consumeSemicolon();
					return this.finalize(node, new Node.ImportDeclaration(specifiers, src));
				};
				// https://tc39.github.io/ecma262/#sec-exports
				Parser.prototype.parseExportSpecifier = function () {
					var node = this.createNode();
					var local = this.parseIdentifierName();
					var exported = local;
					if (this.matchContextualKeyword('as')) {
						this.nextToken();
						exported = this.parseIdentifierName();
					}
					return this.finalize(node, new Node.ExportSpecifier(local, exported));
				};
				Parser.prototype.parseExportDeclaration = function () {
					if (this.context.inFunctionBody) {
						this.throwError(messages_1.Messages.IllegalExportDeclaration);
					}
					var node = this.createNode();
					this.expectKeyword('export');
					var exportDeclaration;
					if (this.matchKeyword('default')) {
						// export default ...
						this.nextToken();
						if (this.matchKeyword('function')) {
							// export default function foo () {}
							// export default function () {}
							var declaration = this.parseFunctionDeclaration(true);
							exportDeclaration = this.finalize(node, new Node.ExportDefaultDeclaration(declaration));
						} else if (this.matchKeyword('class')) {
							// export default class foo {}
							var declaration = this.parseClassDeclaration(true);
							exportDeclaration = this.finalize(node, new Node.ExportDefaultDeclaration(declaration));
						} else if (this.matchContextualKeyword('async')) {
							// export default async function f () {}
							// export default async function () {}
							// export default async x => x
							var declaration = this.matchAsyncFunction() ? this.parseFunctionDeclaration(true) : this.parseAssignmentExpression();
							exportDeclaration = this.finalize(node, new Node.ExportDefaultDeclaration(declaration));
						} else {
							if (this.matchContextualKeyword('from')) {
								this.throwError(messages_1.Messages.UnexpectedToken, this.lookahead.value);
							}
							// export default {};
							// export default [];
							// export default (1 + 2);
							var declaration = this.match('{') ? this.parseObjectInitializer() : this.match('[') ? this.parseArrayInitializer() : this.parseAssignmentExpression();
							this.consumeSemicolon();
							exportDeclaration = this.finalize(node, new Node.ExportDefaultDeclaration(declaration));
						}
					} else if (this.match('*')) {
						// export * from 'foo';
						this.nextToken();
						if (!this.matchContextualKeyword('from')) {
							var message = this.lookahead.value ? messages_1.Messages.UnexpectedToken : messages_1.Messages.MissingFromClause;
							this.throwError(message, this.lookahead.value);
						}
						this.nextToken();
						var src = this.parseModuleSpecifier();
						this.consumeSemicolon();
						exportDeclaration = this.finalize(node, new Node.ExportAllDeclaration(src));
					} else if (this.lookahead.type === 4 /* Keyword */) {
							// export var f = 1;
							var declaration = void 0;
							switch (this.lookahead.value) {
								case 'let':
								case 'const':
									declaration = this.parseLexicalDeclaration({ inFor: false });
									break;
								case 'var':
								case 'class':
								case 'function':
									declaration = this.parseStatementListItem();
									break;
								default:
									this.throwUnexpectedToken(this.lookahead);
							}
							exportDeclaration = this.finalize(node, new Node.ExportNamedDeclaration(declaration, [], null));
						} else if (this.matchAsyncFunction()) {
						var declaration = this.parseFunctionDeclaration();
						exportDeclaration = this.finalize(node, new Node.ExportNamedDeclaration(declaration, [], null));
					} else {
						var specifiers = [];
						var source = null;
						var isExportFromIdentifier = false;
						this.expect('{');
						while (!this.match('}')) {
							isExportFromIdentifier = isExportFromIdentifier || this.matchKeyword('default');
							specifiers.push(this.parseExportSpecifier());
							if (!this.match('}')) {
								this.expect(',');
							}
						}
						this.expect('}');
						if (this.matchContextualKeyword('from')) {
							// export {default} from 'foo';
							// export {foo} from 'foo';
							this.nextToken();
							source = this.parseModuleSpecifier();
							this.consumeSemicolon();
						} else if (isExportFromIdentifier) {
							// export {default}; // missing fromClause
							var message = this.lookahead.value ? messages_1.Messages.UnexpectedToken : messages_1.Messages.MissingFromClause;
							this.throwError(message, this.lookahead.value);
						} else {
							// export {foo};
							this.consumeSemicolon();
						}
						exportDeclaration = this.finalize(node, new Node.ExportNamedDeclaration(null, specifiers, source));
					}
					return exportDeclaration;
				};
				return Parser;
			}();
			exports.Parser = Parser;

			/***/
		},
		/* 9 */
		/***/function (module, exports) {

			"use strict";
			// Ensure the condition is true, otherwise throw an error.
			// This is only to have a better contract semantic, i.e. another safety net
			// to catch a logic error. The condition shall be fulfilled in normal case.
			// Do NOT use this to enforce a certain condition on any user input.

			Object.defineProperty(exports, "__esModule", { value: true });
			function assert(condition, message) {
				/* istanbul ignore if */
				if (!condition) {
					throw new Error('ASSERT: ' + message);
				}
			}
			exports.assert = assert;

			/***/
		},
		/* 10 */
		/***/function (module, exports) {

			"use strict";
			/* tslint:disable:max-classes-per-file */

			Object.defineProperty(exports, "__esModule", { value: true });
			var ErrorHandler = function () {
				function ErrorHandler() {
					this.errors = [];
					this.tolerant = false;
				}
				ErrorHandler.prototype.recordError = function (error) {
					this.errors.push(error);
				};
				ErrorHandler.prototype.tolerate = function (error) {
					if (this.tolerant) {
						this.recordError(error);
					} else {
						throw error;
					}
				};
				ErrorHandler.prototype.constructError = function (msg, column) {
					var error = new Error(msg);
					try {
						throw error;
					} catch (base) {
						/* istanbul ignore else */
						if (Object.create && Object.defineProperty) {
							error = Object.create(base);
							Object.defineProperty(error, 'column', { value: column });
						}
					}
					/* istanbul ignore next */
					return error;
				};
				ErrorHandler.prototype.createError = function (index, line, col, description) {
					var msg = 'Line ' + line + ': ' + description;
					var error = this.constructError(msg, col);
					error.index = index;
					error.lineNumber = line;
					error.description = description;
					return error;
				};
				ErrorHandler.prototype.throwError = function (index, line, col, description) {
					throw this.createError(index, line, col, description);
				};
				ErrorHandler.prototype.tolerateError = function (index, line, col, description) {
					var error = this.createError(index, line, col, description);
					if (this.tolerant) {
						this.recordError(error);
					} else {
						throw error;
					}
				};
				return ErrorHandler;
			}();
			exports.ErrorHandler = ErrorHandler;

			/***/
		},
		/* 11 */
		/***/function (module, exports) {

			"use strict";

			Object.defineProperty(exports, "__esModule", { value: true });
			// Error messages should be identical to V8.
			exports.Messages = {
				BadGetterArity: 'Getter must not have any formal parameters',
				BadSetterArity: 'Setter must have exactly one formal parameter',
				BadSetterRestParameter: 'Setter function argument must not be a rest parameter',
				ConstructorIsAsync: 'Class constructor may not be an async method',
				ConstructorSpecialMethod: 'Class constructor may not be an accessor',
				DeclarationMissingInitializer: 'Missing initializer in %0 declaration',
				DefaultRestParameter: 'Unexpected token =',
				DuplicateBinding: 'Duplicate binding %0',
				DuplicateConstructor: 'A class may only have one constructor',
				DuplicateProtoProperty: 'Duplicate __proto__ fields are not allowed in object literals',
				ForInOfLoopInitializer: '%0 loop variable declaration may not have an initializer',
				GeneratorInLegacyContext: 'Generator declarations are not allowed in legacy contexts',
				IllegalBreak: 'Illegal break statement',
				IllegalContinue: 'Illegal continue statement',
				IllegalExportDeclaration: 'Unexpected token',
				IllegalImportDeclaration: 'Unexpected token',
				IllegalLanguageModeDirective: 'Illegal \'use strict\' directive in function with non-simple parameter list',
				IllegalReturn: 'Illegal return statement',
				InvalidEscapedReservedWord: 'Keyword must not contain escaped characters',
				InvalidHexEscapeSequence: 'Invalid hexadecimal escape sequence',
				InvalidLHSInAssignment: 'Invalid left-hand side in assignment',
				InvalidLHSInForIn: 'Invalid left-hand side in for-in',
				InvalidLHSInForLoop: 'Invalid left-hand side in for-loop',
				InvalidModuleSpecifier: 'Unexpected token',
				InvalidRegExp: 'Invalid regular expression',
				LetInLexicalBinding: 'let is disallowed as a lexically bound name',
				MissingFromClause: 'Unexpected token',
				MultipleDefaultsInSwitch: 'More than one default clause in switch statement',
				NewlineAfterThrow: 'Illegal newline after throw',
				NoAsAfterImportNamespace: 'Unexpected token',
				NoCatchOrFinally: 'Missing catch or finally after try',
				ParameterAfterRestParameter: 'Rest parameter must be last formal parameter',
				Redeclaration: '%0 \'%1\' has already been declared',
				StaticPrototype: 'Classes may not have static property named prototype',
				StrictCatchVariable: 'Catch variable may not be eval or arguments in strict mode',
				StrictDelete: 'Delete of an unqualified identifier in strict mode.',
				StrictFunction: 'In strict mode code, functions can only be declared at top level or inside a block',
				StrictFunctionName: 'Function name may not be eval or arguments in strict mode',
				StrictLHSAssignment: 'Assignment to eval or arguments is not allowed in strict mode',
				StrictLHSPostfix: 'Postfix increment/decrement may not have eval or arguments operand in strict mode',
				StrictLHSPrefix: 'Prefix increment/decrement may not have eval or arguments operand in strict mode',
				StrictModeWith: 'Strict mode code may not include a with statement',
				StrictOctalLiteral: 'Octal literals are not allowed in strict mode.',
				StrictParamDupe: 'Strict mode function may not have duplicate parameter names',
				StrictParamName: 'Parameter name eval or arguments is not allowed in strict mode',
				StrictReservedWord: 'Use of future reserved word in strict mode',
				StrictVarName: 'Variable name may not be eval or arguments in strict mode',
				TemplateOctalLiteral: 'Octal literals are not allowed in template strings.',
				UnexpectedEOS: 'Unexpected end of input',
				UnexpectedIdentifier: 'Unexpected identifier',
				UnexpectedNumber: 'Unexpected number',
				UnexpectedReserved: 'Unexpected reserved word',
				UnexpectedString: 'Unexpected string',
				UnexpectedTemplate: 'Unexpected quasi %0',
				UnexpectedToken: 'Unexpected token %0',
				UnexpectedTokenIllegal: 'Unexpected token ILLEGAL',
				UnknownLabel: 'Undefined label \'%0\'',
				UnterminatedRegExp: 'Invalid regular expression: missing /'
			};

			/***/
		},
		/* 12 */
		/***/function (module, exports, __webpack_require__) {

			"use strict";

			Object.defineProperty(exports, "__esModule", { value: true });
			var assert_1 = __webpack_require__(9);
			var character_1 = __webpack_require__(4);
			var messages_1 = __webpack_require__(11);
			function hexValue(ch) {
				return '0123456789abcdef'.indexOf(ch.toLowerCase());
			}
			function octalValue(ch) {
				return '01234567'.indexOf(ch);
			}
			var Scanner = function () {
				function Scanner(code, handler) {
					this.source = code;
					this.errorHandler = handler;
					this.trackComment = false;
					this.length = code.length;
					this.index = 0;
					this.lineNumber = code.length > 0 ? 1 : 0;
					this.lineStart = 0;
					this.curlyStack = [];
				}
				Scanner.prototype.saveState = function () {
					return {
						index: this.index,
						lineNumber: this.lineNumber,
						lineStart: this.lineStart
					};
				};
				Scanner.prototype.restoreState = function (state) {
					this.index = state.index;
					this.lineNumber = state.lineNumber;
					this.lineStart = state.lineStart;
				};
				Scanner.prototype.eof = function () {
					return this.index >= this.length;
				};
				Scanner.prototype.throwUnexpectedToken = function (message) {
					if (message === void 0) {
						message = messages_1.Messages.UnexpectedTokenIllegal;
					}
					return this.errorHandler.throwError(this.index, this.lineNumber, this.index - this.lineStart + 1, message);
				};
				Scanner.prototype.tolerateUnexpectedToken = function (message) {
					if (message === void 0) {
						message = messages_1.Messages.UnexpectedTokenIllegal;
					}
					this.errorHandler.tolerateError(this.index, this.lineNumber, this.index - this.lineStart + 1, message);
				};
				// https://tc39.github.io/ecma262/#sec-comments
				Scanner.prototype.skipSingleLineComment = function (offset) {
					var comments = [];
					var start, loc;
					if (this.trackComment) {
						comments = [];
						start = this.index - offset;
						loc = {
							start: {
								line: this.lineNumber,
								column: this.index - this.lineStart - offset
							},
							end: {}
						};
					}
					while (!this.eof()) {
						var ch = this.source.charCodeAt(this.index);
						++this.index;
						if (character_1.Character.isLineTerminator(ch)) {
							if (this.trackComment) {
								loc.end = {
									line: this.lineNumber,
									column: this.index - this.lineStart - 1
								};
								var entry = {
									multiLine: false,
									slice: [start + offset, this.index - 1],
									range: [start, this.index - 1],
									loc: loc
								};
								comments.push(entry);
							}
							if (ch === 13 && this.source.charCodeAt(this.index) === 10) {
								++this.index;
							}
							++this.lineNumber;
							this.lineStart = this.index;
							return comments;
						}
					}
					if (this.trackComment) {
						loc.end = {
							line: this.lineNumber,
							column: this.index - this.lineStart
						};
						var entry = {
							multiLine: false,
							slice: [start + offset, this.index],
							range: [start, this.index],
							loc: loc
						};
						comments.push(entry);
					}
					return comments;
				};
				Scanner.prototype.skipMultiLineComment = function () {
					var comments = [];
					var start, loc;
					if (this.trackComment) {
						comments = [];
						start = this.index - 2;
						loc = {
							start: {
								line: this.lineNumber,
								column: this.index - this.lineStart - 2
							},
							end: {}
						};
					}
					while (!this.eof()) {
						var ch = this.source.charCodeAt(this.index);
						if (character_1.Character.isLineTerminator(ch)) {
							if (ch === 0x0D && this.source.charCodeAt(this.index + 1) === 0x0A) {
								++this.index;
							}
							++this.lineNumber;
							++this.index;
							this.lineStart = this.index;
						} else if (ch === 0x2A) {
							// Block comment ends with '*/'.
							if (this.source.charCodeAt(this.index + 1) === 0x2F) {
								this.index += 2;
								if (this.trackComment) {
									loc.end = {
										line: this.lineNumber,
										column: this.index - this.lineStart
									};
									var entry = {
										multiLine: true,
										slice: [start + 2, this.index - 2],
										range: [start, this.index],
										loc: loc
									};
									comments.push(entry);
								}
								return comments;
							}
							++this.index;
						} else {
							++this.index;
						}
					}
					// Ran off the end of the file - the whole thing is a comment
					if (this.trackComment) {
						loc.end = {
							line: this.lineNumber,
							column: this.index - this.lineStart
						};
						var entry = {
							multiLine: true,
							slice: [start + 2, this.index],
							range: [start, this.index],
							loc: loc
						};
						comments.push(entry);
					}
					this.tolerateUnexpectedToken();
					return comments;
				};
				Scanner.prototype.scanComments = function () {
					var comments;
					if (this.trackComment) {
						comments = [];
					}
					var start = this.index === 0;
					while (!this.eof()) {
						var ch = this.source.charCodeAt(this.index);
						if (character_1.Character.isWhiteSpace(ch)) {
							++this.index;
						} else if (character_1.Character.isLineTerminator(ch)) {
							++this.index;
							if (ch === 0x0D && this.source.charCodeAt(this.index) === 0x0A) {
								++this.index;
							}
							++this.lineNumber;
							this.lineStart = this.index;
							start = true;
						} else if (ch === 0x2F) {
							ch = this.source.charCodeAt(this.index + 1);
							if (ch === 0x2F) {
								this.index += 2;
								var comment = this.skipSingleLineComment(2);
								if (this.trackComment) {
									comments = comments.concat(comment);
								}
								start = true;
							} else if (ch === 0x2A) {
								this.index += 2;
								var comment = this.skipMultiLineComment();
								if (this.trackComment) {
									comments = comments.concat(comment);
								}
							} else {
								break;
							}
						} else if (start && ch === 0x2D) {
							// U+003E is '>'
							if (this.source.charCodeAt(this.index + 1) === 0x2D && this.source.charCodeAt(this.index + 2) === 0x3E) {
								// '-->' is a single-line comment
								this.index += 3;
								var comment = this.skipSingleLineComment(3);
								if (this.trackComment) {
									comments = comments.concat(comment);
								}
							} else {
								break;
							}
						} else if (ch === 0x3C) {
							if (this.source.slice(this.index + 1, this.index + 4) === '!--') {
								this.index += 4; // `<!--`
								var comment = this.skipSingleLineComment(4);
								if (this.trackComment) {
									comments = comments.concat(comment);
								}
							} else {
								break;
							}
						} else {
							break;
						}
					}
					return comments;
				};
				// https://tc39.github.io/ecma262/#sec-future-reserved-words
				Scanner.prototype.isFutureReservedWord = function (id) {
					switch (id) {
						case 'enum':
						case 'export':
						case 'import':
						case 'super':
							return true;
						default:
							return false;
					}
				};
				Scanner.prototype.isStrictModeReservedWord = function (id) {
					switch (id) {
						case 'implements':
						case 'interface':
						case 'package':
						case 'private':
						case 'protected':
						case 'public':
						case 'static':
						case 'yield':
						case 'let':
							return true;
						default:
							return false;
					}
				};
				Scanner.prototype.isRestrictedWord = function (id) {
					return id === 'eval' || id === 'arguments';
				};
				// https://tc39.github.io/ecma262/#sec-keywords
				Scanner.prototype.isKeyword = function (id) {
					switch (id.length) {
						case 2:
							return id === 'if' || id === 'in' || id === 'do';
						case 3:
							return id === 'var' || id === 'for' || id === 'new' || id === 'try' || id === 'let';
						case 4:
							return id === 'this' || id === 'else' || id === 'case' || id === 'void' || id === 'with' || id === 'enum';
						case 5:
							return id === 'while' || id === 'break' || id === 'catch' || id === 'throw' || id === 'const' || id === 'yield' || id === 'class' || id === 'super';
						case 6:
							return id === 'return' || id === 'typeof' || id === 'delete' || id === 'switch' || id === 'export' || id === 'import';
						case 7:
							return id === 'default' || id === 'finally' || id === 'extends';
						case 8:
							return id === 'function' || id === 'continue' || id === 'debugger';
						case 10:
							return id === 'instanceof';
						default:
							return false;
					}
				};
				Scanner.prototype.codePointAt = function (i) {
					var cp = this.source.charCodeAt(i);
					if (cp >= 0xD800 && cp <= 0xDBFF) {
						var second = this.source.charCodeAt(i + 1);
						if (second >= 0xDC00 && second <= 0xDFFF) {
							var first = cp;
							cp = (first - 0xD800) * 0x400 + second - 0xDC00 + 0x10000;
						}
					}
					return cp;
				};
				Scanner.prototype.scanHexEscape = function (prefix) {
					var len = prefix === 'u' ? 4 : 2;
					var code = 0;
					for (var i = 0; i < len; ++i) {
						if (!this.eof() && character_1.Character.isHexDigit(this.source.charCodeAt(this.index))) {
							code = code * 16 + hexValue(this.source[this.index++]);
						} else {
							return null;
						}
					}
					return String.fromCharCode(code);
				};
				Scanner.prototype.scanUnicodeCodePointEscape = function () {
					var ch = this.source[this.index];
					var code = 0;
					// At least, one hex digit is required.
					if (ch === '}') {
						this.throwUnexpectedToken();
					}
					while (!this.eof()) {
						ch = this.source[this.index++];
						if (!character_1.Character.isHexDigit(ch.charCodeAt(0))) {
							break;
						}
						code = code * 16 + hexValue(ch);
					}
					if (code > 0x10FFFF || ch !== '}') {
						this.throwUnexpectedToken();
					}
					return character_1.Character.fromCodePoint(code);
				};
				Scanner.prototype.getIdentifier = function () {
					var start = this.index++;
					while (!this.eof()) {
						var ch = this.source.charCodeAt(this.index);
						if (ch === 0x5C) {
							// Blackslash (U+005C) marks Unicode escape sequence.
							this.index = start;
							return this.getComplexIdentifier();
						} else if (ch >= 0xD800 && ch < 0xDFFF) {
							// Need to handle surrogate pairs.
							this.index = start;
							return this.getComplexIdentifier();
						}
						if (character_1.Character.isIdentifierPart(ch)) {
							++this.index;
						} else {
							break;
						}
					}
					return this.source.slice(start, this.index);
				};
				Scanner.prototype.getComplexIdentifier = function () {
					var cp = this.codePointAt(this.index);
					var id = character_1.Character.fromCodePoint(cp);
					this.index += id.length;
					// '\u' (U+005C, U+0075) denotes an escaped character.
					var ch;
					if (cp === 0x5C) {
						if (this.source.charCodeAt(this.index) !== 0x75) {
							this.throwUnexpectedToken();
						}
						++this.index;
						if (this.source[this.index] === '{') {
							++this.index;
							ch = this.scanUnicodeCodePointEscape();
						} else {
							ch = this.scanHexEscape('u');
							if (ch === null || ch === '\\' || !character_1.Character.isIdentifierStart(ch.charCodeAt(0))) {
								this.throwUnexpectedToken();
							}
						}
						id = ch;
					}
					while (!this.eof()) {
						cp = this.codePointAt(this.index);
						if (!character_1.Character.isIdentifierPart(cp)) {
							break;
						}
						ch = character_1.Character.fromCodePoint(cp);
						id += ch;
						this.index += ch.length;
						// '\u' (U+005C, U+0075) denotes an escaped character.
						if (cp === 0x5C) {
							id = id.substr(0, id.length - 1);
							if (this.source.charCodeAt(this.index) !== 0x75) {
								this.throwUnexpectedToken();
							}
							++this.index;
							if (this.source[this.index] === '{') {
								++this.index;
								ch = this.scanUnicodeCodePointEscape();
							} else {
								ch = this.scanHexEscape('u');
								if (ch === null || ch === '\\' || !character_1.Character.isIdentifierPart(ch.charCodeAt(0))) {
									this.throwUnexpectedToken();
								}
							}
							id += ch;
						}
					}
					return id;
				};
				Scanner.prototype.octalToDecimal = function (ch) {
					// \0 is not octal escape sequence
					var octal = ch !== '0';
					var code = octalValue(ch);
					if (!this.eof() && character_1.Character.isOctalDigit(this.source.charCodeAt(this.index))) {
						octal = true;
						code = code * 8 + octalValue(this.source[this.index++]);
						// 3 digits are only allowed when string starts
						// with 0, 1, 2, 3
						if ('0123'.indexOf(ch) >= 0 && !this.eof() && character_1.Character.isOctalDigit(this.source.charCodeAt(this.index))) {
							code = code * 8 + octalValue(this.source[this.index++]);
						}
					}
					return {
						code: code,
						octal: octal
					};
				};
				// https://tc39.github.io/ecma262/#sec-names-and-keywords
				Scanner.prototype.scanIdentifier = function () {
					var type;
					var start = this.index;
					// Backslash (U+005C) starts an escaped character.
					var id = this.source.charCodeAt(start) === 0x5C ? this.getComplexIdentifier() : this.getIdentifier();
					// There is no keyword or literal with only one character.
					// Thus, it must be an identifier.
					if (id.length === 1) {
						type = 3 /* Identifier */;
					} else if (this.isKeyword(id)) {
						type = 4 /* Keyword */;
					} else if (id === 'null') {
						type = 5 /* NullLiteral */;
					} else if (id === 'true' || id === 'false') {
						type = 1 /* BooleanLiteral */;
					} else {
						type = 3 /* Identifier */;
					}
					if (type !== 3 /* Identifier */ && start + id.length !== this.index) {
						var restore = this.index;
						this.index = start;
						this.tolerateUnexpectedToken(messages_1.Messages.InvalidEscapedReservedWord);
						this.index = restore;
					}
					return {
						type: type,
						value: id,
						lineNumber: this.lineNumber,
						lineStart: this.lineStart,
						start: start,
						end: this.index
					};
				};
				// https://tc39.github.io/ecma262/#sec-punctuators
				Scanner.prototype.scanPunctuator = function () {
					var start = this.index;
					// Check for most common single-character punctuators.
					var str = this.source[this.index];
					switch (str) {
						case '(':
						case '{':
							if (str === '{') {
								this.curlyStack.push('{');
							}
							++this.index;
							break;
						case '.':
							++this.index;
							if (this.source[this.index] === '.' && this.source[this.index + 1] === '.') {
								// Spread operator: ...
								this.index += 2;
								str = '...';
							}
							break;
						case '}':
							++this.index;
							this.curlyStack.pop();
							break;
						case ')':
						case ';':
						case ',':
						case '[':
						case ']':
						case ':':
						case '?':
						case '~':
							++this.index;
							break;
						default:
							// 4-character punctuator.
							str = this.source.substr(this.index, 4);
							if (str === '>>>=') {
								this.index += 4;
							} else {
								// 3-character punctuators.
								str = str.substr(0, 3);
								if (str === '===' || str === '!==' || str === '>>>' || str === '<<=' || str === '>>=' || str === '**=') {
									this.index += 3;
								} else {
									// 2-character punctuators.
									str = str.substr(0, 2);
									if (str === '&&' || str === '||' || str === '==' || str === '!=' || str === '+=' || str === '-=' || str === '*=' || str === '/=' || str === '++' || str === '--' || str === '<<' || str === '>>' || str === '&=' || str === '|=' || str === '^=' || str === '%=' || str === '<=' || str === '>=' || str === '=>' || str === '**') {
										this.index += 2;
									} else {
										// 1-character punctuators.
										str = this.source[this.index];
										if ('<>=!+-*%&|^/'.indexOf(str) >= 0) {
											++this.index;
										}
									}
								}
							}
					}
					if (this.index === start) {
						this.throwUnexpectedToken();
					}
					return {
						type: 7 /* Punctuator */
						, value: str,
						lineNumber: this.lineNumber,
						lineStart: this.lineStart,
						start: start,
						end: this.index
					};
				};
				// https://tc39.github.io/ecma262/#sec-literals-numeric-literals
				Scanner.prototype.scanHexLiteral = function (start) {
					var num = '';
					while (!this.eof()) {
						if (!character_1.Character.isHexDigit(this.source.charCodeAt(this.index))) {
							break;
						}
						num += this.source[this.index++];
					}
					if (num.length === 0) {
						this.throwUnexpectedToken();
					}
					if (character_1.Character.isIdentifierStart(this.source.charCodeAt(this.index))) {
						this.throwUnexpectedToken();
					}
					return {
						type: 6 /* NumericLiteral */
						, value: parseInt('0x' + num, 16),
						lineNumber: this.lineNumber,
						lineStart: this.lineStart,
						start: start,
						end: this.index
					};
				};
				Scanner.prototype.scanBinaryLiteral = function (start) {
					var num = '';
					var ch;
					while (!this.eof()) {
						ch = this.source[this.index];
						if (ch !== '0' && ch !== '1') {
							break;
						}
						num += this.source[this.index++];
					}
					if (num.length === 0) {
						// only 0b or 0B
						this.throwUnexpectedToken();
					}
					if (!this.eof()) {
						ch = this.source.charCodeAt(this.index);
						/* istanbul ignore else */
						if (character_1.Character.isIdentifierStart(ch) || character_1.Character.isDecimalDigit(ch)) {
							this.throwUnexpectedToken();
						}
					}
					return {
						type: 6 /* NumericLiteral */
						, value: parseInt(num, 2),
						lineNumber: this.lineNumber,
						lineStart: this.lineStart,
						start: start,
						end: this.index
					};
				};
				Scanner.prototype.scanOctalLiteral = function (prefix, start) {
					var num = '';
					var octal = false;
					if (character_1.Character.isOctalDigit(prefix.charCodeAt(0))) {
						octal = true;
						num = '0' + this.source[this.index++];
					} else {
						++this.index;
					}
					while (!this.eof()) {
						if (!character_1.Character.isOctalDigit(this.source.charCodeAt(this.index))) {
							break;
						}
						num += this.source[this.index++];
					}
					if (!octal && num.length === 0) {
						// only 0o or 0O
						this.throwUnexpectedToken();
					}
					if (character_1.Character.isIdentifierStart(this.source.charCodeAt(this.index)) || character_1.Character.isDecimalDigit(this.source.charCodeAt(this.index))) {
						this.throwUnexpectedToken();
					}
					return {
						type: 6 /* NumericLiteral */
						, value: parseInt(num, 8),
						octal: octal,
						lineNumber: this.lineNumber,
						lineStart: this.lineStart,
						start: start,
						end: this.index
					};
				};
				Scanner.prototype.isImplicitOctalLiteral = function () {
					// Implicit octal, unless there is a non-octal digit.
					// (Annex B.1.1 on Numeric Literals)
					for (var i = this.index + 1; i < this.length; ++i) {
						var ch = this.source[i];
						if (ch === '8' || ch === '9') {
							return false;
						}
						if (!character_1.Character.isOctalDigit(ch.charCodeAt(0))) {
							return true;
						}
					}
					return true;
				};
				Scanner.prototype.scanNumericLiteral = function () {
					var start = this.index;
					var ch = this.source[start];
					assert_1.assert(character_1.Character.isDecimalDigit(ch.charCodeAt(0)) || ch === '.', 'Numeric literal must start with a decimal digit or a decimal point');
					var num = '';
					if (ch !== '.') {
						num = this.source[this.index++];
						ch = this.source[this.index];
						// Hex number starts with '0x'.
						// Octal number starts with '0'.
						// Octal number in ES6 starts with '0o'.
						// Binary number in ES6 starts with '0b'.
						if (num === '0') {
							if (ch === 'x' || ch === 'X') {
								++this.index;
								return this.scanHexLiteral(start);
							}
							if (ch === 'b' || ch === 'B') {
								++this.index;
								return this.scanBinaryLiteral(start);
							}
							if (ch === 'o' || ch === 'O') {
								return this.scanOctalLiteral(ch, start);
							}
							if (ch && character_1.Character.isOctalDigit(ch.charCodeAt(0))) {
								if (this.isImplicitOctalLiteral()) {
									return this.scanOctalLiteral(ch, start);
								}
							}
						}
						while (character_1.Character.isDecimalDigit(this.source.charCodeAt(this.index))) {
							num += this.source[this.index++];
						}
						ch = this.source[this.index];
					}
					if (ch === '.') {
						num += this.source[this.index++];
						while (character_1.Character.isDecimalDigit(this.source.charCodeAt(this.index))) {
							num += this.source[this.index++];
						}
						ch = this.source[this.index];
					}
					if (ch === 'e' || ch === 'E') {
						num += this.source[this.index++];
						ch = this.source[this.index];
						if (ch === '+' || ch === '-') {
							num += this.source[this.index++];
						}
						if (character_1.Character.isDecimalDigit(this.source.charCodeAt(this.index))) {
							while (character_1.Character.isDecimalDigit(this.source.charCodeAt(this.index))) {
								num += this.source[this.index++];
							}
						} else {
							this.throwUnexpectedToken();
						}
					}
					if (character_1.Character.isIdentifierStart(this.source.charCodeAt(this.index))) {
						this.throwUnexpectedToken();
					}
					return {
						type: 6 /* NumericLiteral */
						, value: parseFloat(num),
						lineNumber: this.lineNumber,
						lineStart: this.lineStart,
						start: start,
						end: this.index
					};
				};
				// https://tc39.github.io/ecma262/#sec-literals-string-literals
				Scanner.prototype.scanStringLiteral = function () {
					var start = this.index;
					var quote = this.source[start];
					assert_1.assert(quote === '\'' || quote === '"', 'String literal must starts with a quote');
					++this.index;
					var octal = false;
					var str = '';
					while (!this.eof()) {
						var ch = this.source[this.index++];
						if (ch === quote) {
							quote = '';
							break;
						} else if (ch === '\\') {
							ch = this.source[this.index++];
							if (!ch || !character_1.Character.isLineTerminator(ch.charCodeAt(0))) {
								switch (ch) {
									case 'u':
										if (this.source[this.index] === '{') {
											++this.index;
											str += this.scanUnicodeCodePointEscape();
										} else {
											var unescaped_1 = this.scanHexEscape(ch);
											if (unescaped_1 === null) {
												this.throwUnexpectedToken();
											}
											str += unescaped_1;
										}
										break;
									case 'x':
										var unescaped = this.scanHexEscape(ch);
										if (unescaped === null) {
											this.throwUnexpectedToken(messages_1.Messages.InvalidHexEscapeSequence);
										}
										str += unescaped;
										break;
									case 'n':
										str += '\n';
										break;
									case 'r':
										str += '\r';
										break;
									case 't':
										str += '\t';
										break;
									case 'b':
										str += '\b';
										break;
									case 'f':
										str += '\f';
										break;
									case 'v':
										str += '\x0B';
										break;
									case '8':
									case '9':
										str += ch;
										this.tolerateUnexpectedToken();
										break;
									default:
										if (ch && character_1.Character.isOctalDigit(ch.charCodeAt(0))) {
											var octToDec = this.octalToDecimal(ch);
											octal = octToDec.octal || octal;
											str += String.fromCharCode(octToDec.code);
										} else {
											str += ch;
										}
										break;
								}
							} else {
								++this.lineNumber;
								if (ch === '\r' && this.source[this.index] === '\n') {
									++this.index;
								}
								this.lineStart = this.index;
							}
						} else if (character_1.Character.isLineTerminator(ch.charCodeAt(0))) {
							break;
						} else {
							str += ch;
						}
					}
					if (quote !== '') {
						this.index = start;
						this.throwUnexpectedToken();
					}
					return {
						type: 8 /* StringLiteral */
						, value: str,
						octal: octal,
						lineNumber: this.lineNumber,
						lineStart: this.lineStart,
						start: start,
						end: this.index
					};
				};
				// https://tc39.github.io/ecma262/#sec-template-literal-lexical-components
				Scanner.prototype.scanTemplate = function () {
					var cooked = '';
					var terminated = false;
					var start = this.index;
					var head = this.source[start] === '`';
					var tail = false;
					var rawOffset = 2;
					++this.index;
					while (!this.eof()) {
						var ch = this.source[this.index++];
						if (ch === '`') {
							rawOffset = 1;
							tail = true;
							terminated = true;
							break;
						} else if (ch === '$') {
							if (this.source[this.index] === '{') {
								this.curlyStack.push('${');
								++this.index;
								terminated = true;
								break;
							}
							cooked += ch;
						} else if (ch === '\\') {
							ch = this.source[this.index++];
							if (!character_1.Character.isLineTerminator(ch.charCodeAt(0))) {
								switch (ch) {
									case 'n':
										cooked += '\n';
										break;
									case 'r':
										cooked += '\r';
										break;
									case 't':
										cooked += '\t';
										break;
									case 'u':
										if (this.source[this.index] === '{') {
											++this.index;
											cooked += this.scanUnicodeCodePointEscape();
										} else {
											var restore = this.index;
											var unescaped_2 = this.scanHexEscape(ch);
											if (unescaped_2 !== null) {
												cooked += unescaped_2;
											} else {
												this.index = restore;
												cooked += ch;
											}
										}
										break;
									case 'x':
										var unescaped = this.scanHexEscape(ch);
										if (unescaped === null) {
											this.throwUnexpectedToken(messages_1.Messages.InvalidHexEscapeSequence);
										}
										cooked += unescaped;
										break;
									case 'b':
										cooked += '\b';
										break;
									case 'f':
										cooked += '\f';
										break;
									case 'v':
										cooked += '\v';
										break;
									default:
										if (ch === '0') {
											if (character_1.Character.isDecimalDigit(this.source.charCodeAt(this.index))) {
												// Illegal: \01 \02 and so on
												this.throwUnexpectedToken(messages_1.Messages.TemplateOctalLiteral);
											}
											cooked += '\0';
										} else if (character_1.Character.isOctalDigit(ch.charCodeAt(0))) {
											// Illegal: \1 \2
											this.throwUnexpectedToken(messages_1.Messages.TemplateOctalLiteral);
										} else {
											cooked += ch;
										}
										break;
								}
							} else {
								++this.lineNumber;
								if (ch === '\r' && this.source[this.index] === '\n') {
									++this.index;
								}
								this.lineStart = this.index;
							}
						} else if (character_1.Character.isLineTerminator(ch.charCodeAt(0))) {
							++this.lineNumber;
							if (ch === '\r' && this.source[this.index] === '\n') {
								++this.index;
							}
							this.lineStart = this.index;
							cooked += '\n';
						} else {
							cooked += ch;
						}
					}
					if (!terminated) {
						this.throwUnexpectedToken();
					}
					if (!head) {
						this.curlyStack.pop();
					}
					return {
						type: 10 /* Template */
						, value: this.source.slice(start + 1, this.index - rawOffset),
						cooked: cooked,
						head: head,
						tail: tail,
						lineNumber: this.lineNumber,
						lineStart: this.lineStart,
						start: start,
						end: this.index
					};
				};
				// https://tc39.github.io/ecma262/#sec-literals-regular-expression-literals
				Scanner.prototype.testRegExp = function (pattern, flags) {
					// The BMP character to use as a replacement for astral symbols when
					// translating an ES6 "u"-flagged pattern to an ES5-compatible
					// approximation.
					// Note: replacing with '\uFFFF' enables false positives in unlikely
					// scenarios. For example, `[\u{1044f}-\u{10440}]` is an invalid
					// pattern that would not be detected by this substitution.
					var astralSubstitute = '\uFFFF';
					var tmp = pattern;
					var self = this;
					if (flags.indexOf('u') >= 0) {
						tmp = tmp.replace(/\\u\{([0-9a-fA-F]+)\}|\\u([a-fA-F0-9]{4})/g, function ($0, $1, $2) {
							var codePoint = parseInt($1 || $2, 16);
							if (codePoint > 0x10FFFF) {
								self.throwUnexpectedToken(messages_1.Messages.InvalidRegExp);
							}
							if (codePoint <= 0xFFFF) {
								return String.fromCharCode(codePoint);
							}
							return astralSubstitute;
						}).replace(/[\uD800-\uDBFF][\uDC00-\uDFFF]/g, astralSubstitute);
					}
					// First, detect invalid regular expressions.
					try {
						RegExp(tmp);
					} catch (e) {
						this.throwUnexpectedToken(messages_1.Messages.InvalidRegExp);
					}
					// Return a regular expression object for this pattern-flag pair, or
					// `null` in case the current environment doesn't support the flags it
					// uses.
					try {
						return new RegExp(pattern, flags);
					} catch (exception) {
						/* istanbul ignore next */
						return null;
					}
				};
				Scanner.prototype.scanRegExpBody = function () {
					var ch = this.source[this.index];
					assert_1.assert(ch === '/', 'Regular expression literal must start with a slash');
					var str = this.source[this.index++];
					var classMarker = false;
					var terminated = false;
					while (!this.eof()) {
						ch = this.source[this.index++];
						str += ch;
						if (ch === '\\') {
							ch = this.source[this.index++];
							// https://tc39.github.io/ecma262/#sec-literals-regular-expression-literals
							if (character_1.Character.isLineTerminator(ch.charCodeAt(0))) {
								this.throwUnexpectedToken(messages_1.Messages.UnterminatedRegExp);
							}
							str += ch;
						} else if (character_1.Character.isLineTerminator(ch.charCodeAt(0))) {
							this.throwUnexpectedToken(messages_1.Messages.UnterminatedRegExp);
						} else if (classMarker) {
							if (ch === ']') {
								classMarker = false;
							}
						} else {
							if (ch === '/') {
								terminated = true;
								break;
							} else if (ch === '[') {
								classMarker = true;
							}
						}
					}
					if (!terminated) {
						this.throwUnexpectedToken(messages_1.Messages.UnterminatedRegExp);
					}
					// Exclude leading and trailing slash.
					return str.substr(1, str.length - 2);
				};
				Scanner.prototype.scanRegExpFlags = function () {
					var str = '';
					var flags = '';
					while (!this.eof()) {
						var ch = this.source[this.index];
						if (!character_1.Character.isIdentifierPart(ch.charCodeAt(0))) {
							break;
						}
						++this.index;
						if (ch === '\\' && !this.eof()) {
							ch = this.source[this.index];
							if (ch === 'u') {
								++this.index;
								var restore = this.index;
								var char = this.scanHexEscape('u');
								if (char !== null) {
									flags += char;
									for (str += '\\u'; restore < this.index; ++restore) {
										str += this.source[restore];
									}
								} else {
									this.index = restore;
									flags += 'u';
									str += '\\u';
								}
								this.tolerateUnexpectedToken();
							} else {
								str += '\\';
								this.tolerateUnexpectedToken();
							}
						} else {
							flags += ch;
							str += ch;
						}
					}
					return flags;
				};
				Scanner.prototype.scanRegExp = function () {
					var start = this.index;
					var pattern = this.scanRegExpBody();
					var flags = this.scanRegExpFlags();
					var value = this.testRegExp(pattern, flags);
					return {
						type: 9 /* RegularExpression */
						, value: '',
						pattern: pattern,
						flags: flags,
						regex: value,
						lineNumber: this.lineNumber,
						lineStart: this.lineStart,
						start: start,
						end: this.index
					};
				};
				Scanner.prototype.lex = function () {
					if (this.eof()) {
						return {
							type: 2 /* EOF */
							, value: '',
							lineNumber: this.lineNumber,
							lineStart: this.lineStart,
							start: this.index,
							end: this.index
						};
					}
					var cp = this.source.charCodeAt(this.index);
					if (character_1.Character.isIdentifierStart(cp)) {
						return this.scanIdentifier();
					}
					// Very common: ( and ) and ;
					if (cp === 0x28 || cp === 0x29 || cp === 0x3B) {
						return this.scanPunctuator();
					}
					// String literal starts with single quote (U+0027) or double quote (U+0022).
					if (cp === 0x27 || cp === 0x22) {
						return this.scanStringLiteral();
					}
					// Dot (.) U+002E can also start a floating-point number, hence the need
					// to check the next character.
					if (cp === 0x2E) {
						if (character_1.Character.isDecimalDigit(this.source.charCodeAt(this.index + 1))) {
							return this.scanNumericLiteral();
						}
						return this.scanPunctuator();
					}
					if (character_1.Character.isDecimalDigit(cp)) {
						return this.scanNumericLiteral();
					}
					// Template literals start with ` (U+0060) for template head
					// or } (U+007D) for template middle or template tail.
					if (cp === 0x60 || cp === 0x7D && this.curlyStack[this.curlyStack.length - 1] === '${') {
						return this.scanTemplate();
					}
					// Possible identifier start in a surrogate pair.
					if (cp >= 0xD800 && cp < 0xDFFF) {
						if (character_1.Character.isIdentifierStart(this.codePointAt(this.index))) {
							return this.scanIdentifier();
						}
					}
					return this.scanPunctuator();
				};
				return Scanner;
			}();
			exports.Scanner = Scanner;

			/***/
		},
		/* 13 */
		/***/function (module, exports) {

			"use strict";

			Object.defineProperty(exports, "__esModule", { value: true });
			exports.TokenName = {};
			exports.TokenName[1 /* BooleanLiteral */] = 'Boolean';
			exports.TokenName[2 /* EOF */] = '<end>';
			exports.TokenName[3 /* Identifier */] = 'Identifier';
			exports.TokenName[4 /* Keyword */] = 'Keyword';
			exports.TokenName[5 /* NullLiteral */] = 'Null';
			exports.TokenName[6 /* NumericLiteral */] = 'Numeric';
			exports.TokenName[7 /* Punctuator */] = 'Punctuator';
			exports.TokenName[8 /* StringLiteral */] = 'String';
			exports.TokenName[9 /* RegularExpression */] = 'RegularExpression';
			exports.TokenName[10 /* Template */] = 'Template';

			/***/
		},
		/* 14 */
		/***/function (module, exports) {

			"use strict";
			// Generated by generate-xhtml-entities.js. DO NOT MODIFY!

			Object.defineProperty(exports, "__esModule", { value: true });
			exports.XHTMLEntities = {
				quot: '\u0022',
				amp: '\u0026',
				apos: '\u0027',
				gt: '\u003E',
				nbsp: '\u00A0',
				iexcl: '\u00A1',
				cent: '\u00A2',
				pound: '\u00A3',
				curren: '\u00A4',
				yen: '\u00A5',
				brvbar: '\u00A6',
				sect: '\u00A7',
				uml: '\u00A8',
				copy: '\u00A9',
				ordf: '\u00AA',
				laquo: '\u00AB',
				not: '\u00AC',
				shy: '\u00AD',
				reg: '\u00AE',
				macr: '\u00AF',
				deg: '\u00B0',
				plusmn: '\u00B1',
				sup2: '\u00B2',
				sup3: '\u00B3',
				acute: '\u00B4',
				micro: '\u00B5',
				para: '\u00B6',
				middot: '\u00B7',
				cedil: '\u00B8',
				sup1: '\u00B9',
				ordm: '\u00BA',
				raquo: '\u00BB',
				frac14: '\u00BC',
				frac12: '\u00BD',
				frac34: '\u00BE',
				iquest: '\u00BF',
				Agrave: '\u00C0',
				Aacute: '\u00C1',
				Acirc: '\u00C2',
				Atilde: '\u00C3',
				Auml: '\u00C4',
				Aring: '\u00C5',
				AElig: '\u00C6',
				Ccedil: '\u00C7',
				Egrave: '\u00C8',
				Eacute: '\u00C9',
				Ecirc: '\u00CA',
				Euml: '\u00CB',
				Igrave: '\u00CC',
				Iacute: '\u00CD',
				Icirc: '\u00CE',
				Iuml: '\u00CF',
				ETH: '\u00D0',
				Ntilde: '\u00D1',
				Ograve: '\u00D2',
				Oacute: '\u00D3',
				Ocirc: '\u00D4',
				Otilde: '\u00D5',
				Ouml: '\u00D6',
				times: '\u00D7',
				Oslash: '\u00D8',
				Ugrave: '\u00D9',
				Uacute: '\u00DA',
				Ucirc: '\u00DB',
				Uuml: '\u00DC',
				Yacute: '\u00DD',
				THORN: '\u00DE',
				szlig: '\u00DF',
				agrave: '\u00E0',
				aacute: '\u00E1',
				acirc: '\u00E2',
				atilde: '\u00E3',
				auml: '\u00E4',
				aring: '\u00E5',
				aelig: '\u00E6',
				ccedil: '\u00E7',
				egrave: '\u00E8',
				eacute: '\u00E9',
				ecirc: '\u00EA',
				euml: '\u00EB',
				igrave: '\u00EC',
				iacute: '\u00ED',
				icirc: '\u00EE',
				iuml: '\u00EF',
				eth: '\u00F0',
				ntilde: '\u00F1',
				ograve: '\u00F2',
				oacute: '\u00F3',
				ocirc: '\u00F4',
				otilde: '\u00F5',
				ouml: '\u00F6',
				divide: '\u00F7',
				oslash: '\u00F8',
				ugrave: '\u00F9',
				uacute: '\u00FA',
				ucirc: '\u00FB',
				uuml: '\u00FC',
				yacute: '\u00FD',
				thorn: '\u00FE',
				yuml: '\u00FF',
				OElig: '\u0152',
				oelig: '\u0153',
				Scaron: '\u0160',
				scaron: '\u0161',
				Yuml: '\u0178',
				fnof: '\u0192',
				circ: '\u02C6',
				tilde: '\u02DC',
				Alpha: '\u0391',
				Beta: '\u0392',
				Gamma: '\u0393',
				Delta: '\u0394',
				Epsilon: '\u0395',
				Zeta: '\u0396',
				Eta: '\u0397',
				Theta: '\u0398',
				Iota: '\u0399',
				Kappa: '\u039A',
				Lambda: '\u039B',
				Mu: '\u039C',
				Nu: '\u039D',
				Xi: '\u039E',
				Omicron: '\u039F',
				Pi: '\u03A0',
				Rho: '\u03A1',
				Sigma: '\u03A3',
				Tau: '\u03A4',
				Upsilon: '\u03A5',
				Phi: '\u03A6',
				Chi: '\u03A7',
				Psi: '\u03A8',
				Omega: '\u03A9',
				alpha: '\u03B1',
				beta: '\u03B2',
				gamma: '\u03B3',
				delta: '\u03B4',
				epsilon: '\u03B5',
				zeta: '\u03B6',
				eta: '\u03B7',
				theta: '\u03B8',
				iota: '\u03B9',
				kappa: '\u03BA',
				lambda: '\u03BB',
				mu: '\u03BC',
				nu: '\u03BD',
				xi: '\u03BE',
				omicron: '\u03BF',
				pi: '\u03C0',
				rho: '\u03C1',
				sigmaf: '\u03C2',
				sigma: '\u03C3',
				tau: '\u03C4',
				upsilon: '\u03C5',
				phi: '\u03C6',
				chi: '\u03C7',
				psi: '\u03C8',
				omega: '\u03C9',
				thetasym: '\u03D1',
				upsih: '\u03D2',
				piv: '\u03D6',
				ensp: '\u2002',
				emsp: '\u2003',
				thinsp: '\u2009',
				zwnj: '\u200C',
				zwj: '\u200D',
				lrm: '\u200E',
				rlm: '\u200F',
				ndash: '\u2013',
				mdash: '\u2014',
				lsquo: '\u2018',
				rsquo: '\u2019',
				sbquo: '\u201A',
				ldquo: '\u201C',
				rdquo: '\u201D',
				bdquo: '\u201E',
				dagger: '\u2020',
				Dagger: '\u2021',
				bull: '\u2022',
				hellip: '\u2026',
				permil: '\u2030',
				prime: '\u2032',
				Prime: '\u2033',
				lsaquo: '\u2039',
				rsaquo: '\u203A',
				oline: '\u203E',
				frasl: '\u2044',
				euro: '\u20AC',
				image: '\u2111',
				weierp: '\u2118',
				real: '\u211C',
				trade: '\u2122',
				alefsym: '\u2135',
				larr: '\u2190',
				uarr: '\u2191',
				rarr: '\u2192',
				darr: '\u2193',
				harr: '\u2194',
				crarr: '\u21B5',
				lArr: '\u21D0',
				uArr: '\u21D1',
				rArr: '\u21D2',
				dArr: '\u21D3',
				hArr: '\u21D4',
				forall: '\u2200',
				part: '\u2202',
				exist: '\u2203',
				empty: '\u2205',
				nabla: '\u2207',
				isin: '\u2208',
				notin: '\u2209',
				ni: '\u220B',
				prod: '\u220F',
				sum: '\u2211',
				minus: '\u2212',
				lowast: '\u2217',
				radic: '\u221A',
				prop: '\u221D',
				infin: '\u221E',
				ang: '\u2220',
				and: '\u2227',
				or: '\u2228',
				cap: '\u2229',
				cup: '\u222A',
				int: '\u222B',
				there4: '\u2234',
				sim: '\u223C',
				cong: '\u2245',
				asymp: '\u2248',
				ne: '\u2260',
				equiv: '\u2261',
				le: '\u2264',
				ge: '\u2265',
				sub: '\u2282',
				sup: '\u2283',
				nsub: '\u2284',
				sube: '\u2286',
				supe: '\u2287',
				oplus: '\u2295',
				otimes: '\u2297',
				perp: '\u22A5',
				sdot: '\u22C5',
				lceil: '\u2308',
				rceil: '\u2309',
				lfloor: '\u230A',
				rfloor: '\u230B',
				loz: '\u25CA',
				spades: '\u2660',
				clubs: '\u2663',
				hearts: '\u2665',
				diams: '\u2666',
				lang: '\u27E8',
				rang: '\u27E9'
			};

			/***/
		},
		/* 15 */
		/***/function (module, exports, __webpack_require__) {

			"use strict";

			Object.defineProperty(exports, "__esModule", { value: true });
			var error_handler_1 = __webpack_require__(10);
			var scanner_1 = __webpack_require__(12);
			var token_1 = __webpack_require__(13);
			var Reader = function () {
				function Reader() {
					this.values = [];
					this.curly = this.paren = -1;
				}
				// A function following one of those tokens is an expression.
				Reader.prototype.beforeFunctionExpression = function (t) {
					return ['(', '{', '[', 'in', 'typeof', 'instanceof', 'new', 'return', 'case', 'delete', 'throw', 'void',
					// assignment operators
					'=', '+=', '-=', '*=', '**=', '/=', '%=', '<<=', '>>=', '>>>=', '&=', '|=', '^=', ',',
					// binary/unary operators
					'+', '-', '*', '**', '/', '%', '++', '--', '<<', '>>', '>>>', '&', '|', '^', '!', '~', '&&', '||', '?', ':', '===', '==', '>=', '<=', '<', '>', '!=', '!=='].indexOf(t) >= 0;
				};
				// Determine if forward slash (/) is an operator or part of a regular expression
				// https://github.com/mozilla/sweet.js/wiki/design
				Reader.prototype.isRegexStart = function () {
					var previous = this.values[this.values.length - 1];
					var regex = previous !== null;
					switch (previous) {
						case 'this':
						case ']':
							regex = false;
							break;
						case ')':
							var keyword = this.values[this.paren - 1];
							regex = keyword === 'if' || keyword === 'while' || keyword === 'for' || keyword === 'with';
							break;
						case '}':
							// Dividing a function by anything makes little sense,
							// but we have to check for that.
							regex = false;
							if (this.values[this.curly - 3] === 'function') {
								// Anonymous function, e.g. function(){} /42
								var check = this.values[this.curly - 4];
								regex = check ? !this.beforeFunctionExpression(check) : false;
							} else if (this.values[this.curly - 4] === 'function') {
								// Named function, e.g. function f(){} /42/
								var check = this.values[this.curly - 5];
								regex = check ? !this.beforeFunctionExpression(check) : true;
							}
							break;
						default:
							break;
					}
					return regex;
				};
				Reader.prototype.push = function (token) {
					if (token.type === 7 /* Punctuator */ || token.type === 4 /* Keyword */) {
							if (token.value === '{') {
								this.curly = this.values.length;
							} else if (token.value === '(') {
								this.paren = this.values.length;
							}
							this.values.push(token.value);
						} else {
						this.values.push(null);
					}
				};
				return Reader;
			}();
			var Tokenizer = function () {
				function Tokenizer(code, config) {
					this.errorHandler = new error_handler_1.ErrorHandler();
					this.errorHandler.tolerant = config ? typeof config.tolerant === 'boolean' && config.tolerant : false;
					this.scanner = new scanner_1.Scanner(code, this.errorHandler);
					this.scanner.trackComment = config ? typeof config.comment === 'boolean' && config.comment : false;
					this.trackRange = config ? typeof config.range === 'boolean' && config.range : false;
					this.trackLoc = config ? typeof config.loc === 'boolean' && config.loc : false;
					this.buffer = [];
					this.reader = new Reader();
				}
				Tokenizer.prototype.errors = function () {
					return this.errorHandler.errors;
				};
				Tokenizer.prototype.getNextToken = function () {
					if (this.buffer.length === 0) {
						var comments = this.scanner.scanComments();
						if (this.scanner.trackComment) {
							for (var i = 0; i < comments.length; ++i) {
								var e = comments[i];
								var value = this.scanner.source.slice(e.slice[0], e.slice[1]);
								var comment = {
									type: e.multiLine ? 'BlockComment' : 'LineComment',
									value: value
								};
								if (this.trackRange) {
									comment.range = e.range;
								}
								if (this.trackLoc) {
									comment.loc = e.loc;
								}
								this.buffer.push(comment);
							}
						}
						if (!this.scanner.eof()) {
							var loc = void 0;
							if (this.trackLoc) {
								loc = {
									start: {
										line: this.scanner.lineNumber,
										column: this.scanner.index - this.scanner.lineStart
									},
									end: {}
								};
							}
							var startRegex = this.scanner.source[this.scanner.index] === '/' && this.reader.isRegexStart();
							var token = startRegex ? this.scanner.scanRegExp() : this.scanner.lex();
							this.reader.push(token);
							var entry = {
								type: token_1.TokenName[token.type],
								value: this.scanner.source.slice(token.start, token.end)
							};
							if (this.trackRange) {
								entry.range = [token.start, token.end];
							}
							if (this.trackLoc) {
								loc.end = {
									line: this.scanner.lineNumber,
									column: this.scanner.index - this.scanner.lineStart
								};
								entry.loc = loc;
							}
							if (token.type === 9 /* RegularExpression */) {
									var pattern = token.pattern;
									var flags = token.flags;
									entry.regex = { pattern: pattern, flags: flags };
								}
							this.buffer.push(entry);
						}
					}
					return this.buffer.shift();
				};
				return Tokenizer;
			}();
			exports.Tokenizer = Tokenizer;

			/***/
		}
		/******/])
	);
});
;

/***/ }),
/* 158 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/*eslint-disable no-use-before-define*/

var common = __webpack_require__(17);
var YAMLException = __webpack_require__(21);
var DEFAULT_FULL_SCHEMA = __webpack_require__(25);
var DEFAULT_SAFE_SCHEMA = __webpack_require__(22);

var _toString = Object.prototype.toString;
var _hasOwnProperty = Object.prototype.hasOwnProperty;

var CHAR_TAB = 0x09; /* Tab */
var CHAR_LINE_FEED = 0x0A; /* LF */
var CHAR_SPACE = 0x20; /* Space */
var CHAR_EXCLAMATION = 0x21; /* ! */
var CHAR_DOUBLE_QUOTE = 0x22; /* " */
var CHAR_SHARP = 0x23; /* # */
var CHAR_PERCENT = 0x25; /* % */
var CHAR_AMPERSAND = 0x26; /* & */
var CHAR_SINGLE_QUOTE = 0x27; /* ' */
var CHAR_ASTERISK = 0x2A; /* * */
var CHAR_COMMA = 0x2C; /* , */
var CHAR_MINUS = 0x2D; /* - */
var CHAR_COLON = 0x3A; /* : */
var CHAR_GREATER_THAN = 0x3E; /* > */
var CHAR_QUESTION = 0x3F; /* ? */
var CHAR_COMMERCIAL_AT = 0x40; /* @ */
var CHAR_LEFT_SQUARE_BRACKET = 0x5B; /* [ */
var CHAR_RIGHT_SQUARE_BRACKET = 0x5D; /* ] */
var CHAR_GRAVE_ACCENT = 0x60; /* ` */
var CHAR_LEFT_CURLY_BRACKET = 0x7B; /* { */
var CHAR_VERTICAL_LINE = 0x7C; /* | */
var CHAR_RIGHT_CURLY_BRACKET = 0x7D; /* } */

var ESCAPE_SEQUENCES = {};

ESCAPE_SEQUENCES[0x00] = '\\0';
ESCAPE_SEQUENCES[0x07] = '\\a';
ESCAPE_SEQUENCES[0x08] = '\\b';
ESCAPE_SEQUENCES[0x09] = '\\t';
ESCAPE_SEQUENCES[0x0A] = '\\n';
ESCAPE_SEQUENCES[0x0B] = '\\v';
ESCAPE_SEQUENCES[0x0C] = '\\f';
ESCAPE_SEQUENCES[0x0D] = '\\r';
ESCAPE_SEQUENCES[0x1B] = '\\e';
ESCAPE_SEQUENCES[0x22] = '\\"';
ESCAPE_SEQUENCES[0x5C] = '\\\\';
ESCAPE_SEQUENCES[0x85] = '\\N';
ESCAPE_SEQUENCES[0xA0] = '\\_';
ESCAPE_SEQUENCES[0x2028] = '\\L';
ESCAPE_SEQUENCES[0x2029] = '\\P';

var DEPRECATED_BOOLEANS_SYNTAX = ['y', 'Y', 'yes', 'Yes', 'YES', 'on', 'On', 'ON', 'n', 'N', 'no', 'No', 'NO', 'off', 'Off', 'OFF'];

function compileStyleMap(schema, map) {
  var result, keys, index, length, tag, style, type;

  if (map === null) return {};

  result = {};
  keys = Object.keys(map);

  for (index = 0, length = keys.length; index < length; index += 1) {
    tag = keys[index];
    style = String(map[tag]);

    if (tag.slice(0, 2) === '!!') {
      tag = 'tag:yaml.org,2002:' + tag.slice(2);
    }
    type = schema.compiledTypeMap['fallback'][tag];

    if (type && _hasOwnProperty.call(type.styleAliases, style)) {
      style = type.styleAliases[style];
    }

    result[tag] = style;
  }

  return result;
}

function encodeHex(character) {
  var string, handle, length;

  string = character.toString(16).toUpperCase();

  if (character <= 0xFF) {
    handle = 'x';
    length = 2;
  } else if (character <= 0xFFFF) {
    handle = 'u';
    length = 4;
  } else if (character <= 0xFFFFFFFF) {
    handle = 'U';
    length = 8;
  } else {
    throw new YAMLException('code point within a string may not be greater than 0xFFFFFFFF');
  }

  return '\\' + handle + common.repeat('0', length - string.length) + string;
}

function State(options) {
  this.schema = options['schema'] || DEFAULT_FULL_SCHEMA;
  this.indent = Math.max(1, options['indent'] || 2);
  this.skipInvalid = options['skipInvalid'] || false;
  this.flowLevel = common.isNothing(options['flowLevel']) ? -1 : options['flowLevel'];
  this.styleMap = compileStyleMap(this.schema, options['styles'] || null);
  this.sortKeys = options['sortKeys'] || false;
  this.lineWidth = options['lineWidth'] || 80;
  this.noRefs = options['noRefs'] || false;
  this.noCompatMode = options['noCompatMode'] || false;
  this.condenseFlow = options['condenseFlow'] || false;

  this.implicitTypes = this.schema.compiledImplicit;
  this.explicitTypes = this.schema.compiledExplicit;

  this.tag = null;
  this.result = '';

  this.duplicates = [];
  this.usedDuplicates = null;
}

// Indents every line in a string. Empty lines (\n only) are not indented.
function indentString(string, spaces) {
  var ind = common.repeat(' ', spaces),
      position = 0,
      next = -1,
      result = '',
      line,
      length = string.length;

  while (position < length) {
    next = string.indexOf('\n', position);
    if (next === -1) {
      line = string.slice(position);
      position = length;
    } else {
      line = string.slice(position, next + 1);
      position = next + 1;
    }

    if (line.length && line !== '\n') result += ind;

    result += line;
  }

  return result;
}

function generateNextLine(state, level) {
  return '\n' + common.repeat(' ', state.indent * level);
}

function testImplicitResolving(state, str) {
  var index, length, type;

  for (index = 0, length = state.implicitTypes.length; index < length; index += 1) {
    type = state.implicitTypes[index];

    if (type.resolve(str)) {
      return true;
    }
  }

  return false;
}

// [33] s-white ::= s-space | s-tab
function isWhitespace(c) {
  return c === CHAR_SPACE || c === CHAR_TAB;
}

// Returns true if the character can be printed without escaping.
// From YAML 1.2: "any allowed characters known to be non-printable
// should also be escaped. [However,] This isnt mandatory"
// Derived from nb-char - \t - #x85 - #xA0 - #x2028 - #x2029.
function isPrintable(c) {
  return 0x00020 <= c && c <= 0x00007E || 0x000A1 <= c && c <= 0x00D7FF && c !== 0x2028 && c !== 0x2029 || 0x0E000 <= c && c <= 0x00FFFD && c !== 0xFEFF /* BOM */ || 0x10000 <= c && c <= 0x10FFFF;
}

// Simplified test for values allowed after the first character in plain style.
function isPlainSafe(c) {
  // Uses a subset of nb-char - c-flow-indicator - ":" - "#"
  // where nb-char ::= c-printable - b-char - c-byte-order-mark.
  return isPrintable(c) && c !== 0xFEFF
  // - c-flow-indicator
  && c !== CHAR_COMMA && c !== CHAR_LEFT_SQUARE_BRACKET && c !== CHAR_RIGHT_SQUARE_BRACKET && c !== CHAR_LEFT_CURLY_BRACKET && c !== CHAR_RIGHT_CURLY_BRACKET
  // - ":" - "#"
  && c !== CHAR_COLON && c !== CHAR_SHARP;
}

// Simplified test for values allowed as the first character in plain style.
function isPlainSafeFirst(c) {
  // Uses a subset of ns-char - c-indicator
  // where ns-char = nb-char - s-white.
  return isPrintable(c) && c !== 0xFEFF && !isWhitespace(c) // - s-white
  // - (c-indicator ::=
  // - | ? | : | , | [ | ] | { | }
  && c !== CHAR_MINUS && c !== CHAR_QUESTION && c !== CHAR_COLON && c !== CHAR_COMMA && c !== CHAR_LEFT_SQUARE_BRACKET && c !== CHAR_RIGHT_SQUARE_BRACKET && c !== CHAR_LEFT_CURLY_BRACKET && c !== CHAR_RIGHT_CURLY_BRACKET
  // | # | & | * | ! | | | > | ' | "
  && c !== CHAR_SHARP && c !== CHAR_AMPERSAND && c !== CHAR_ASTERISK && c !== CHAR_EXCLAMATION && c !== CHAR_VERTICAL_LINE && c !== CHAR_GREATER_THAN && c !== CHAR_SINGLE_QUOTE && c !== CHAR_DOUBLE_QUOTE
  // | % | @ | `)
  && c !== CHAR_PERCENT && c !== CHAR_COMMERCIAL_AT && c !== CHAR_GRAVE_ACCENT;
}

var STYLE_PLAIN = 1,
    STYLE_SINGLE = 2,
    STYLE_LITERAL = 3,
    STYLE_FOLDED = 4,
    STYLE_DOUBLE = 5;

// Determines which scalar styles are possible and returns the preferred style.
// lineWidth = -1 => no limit.
// Pre-conditions: str.length > 0.
// Post-conditions:
//    STYLE_PLAIN or STYLE_SINGLE => no \n are in the string.
//    STYLE_LITERAL => no lines are suitable for folding (or lineWidth is -1).
//    STYLE_FOLDED => a line > lineWidth and can be folded (and lineWidth != -1).
function chooseScalarStyle(string, singleLineOnly, indentPerLevel, lineWidth, testAmbiguousType) {
  var i;
  var char;
  var hasLineBreak = false;
  var hasFoldableLine = false; // only checked if shouldTrackWidth
  var shouldTrackWidth = lineWidth !== -1;
  var previousLineBreak = -1; // count the first line correctly
  var plain = isPlainSafeFirst(string.charCodeAt(0)) && !isWhitespace(string.charCodeAt(string.length - 1));

  if (singleLineOnly) {
    // Case: no block styles.
    // Check for disallowed characters to rule out plain and single.
    for (i = 0; i < string.length; i++) {
      char = string.charCodeAt(i);
      if (!isPrintable(char)) {
        return STYLE_DOUBLE;
      }
      plain = plain && isPlainSafe(char);
    }
  } else {
    // Case: block styles permitted.
    for (i = 0; i < string.length; i++) {
      char = string.charCodeAt(i);
      if (char === CHAR_LINE_FEED) {
        hasLineBreak = true;
        // Check if any line can be folded.
        if (shouldTrackWidth) {
          hasFoldableLine = hasFoldableLine ||
          // Foldable line = too long, and not more-indented.
          i - previousLineBreak - 1 > lineWidth && string[previousLineBreak + 1] !== ' ';
          previousLineBreak = i;
        }
      } else if (!isPrintable(char)) {
        return STYLE_DOUBLE;
      }
      plain = plain && isPlainSafe(char);
    }
    // in case the end is missing a \n
    hasFoldableLine = hasFoldableLine || shouldTrackWidth && i - previousLineBreak - 1 > lineWidth && string[previousLineBreak + 1] !== ' ';
  }
  // Although every style can represent \n without escaping, prefer block styles
  // for multiline, since they're more readable and they don't add empty lines.
  // Also prefer folding a super-long line.
  if (!hasLineBreak && !hasFoldableLine) {
    // Strings interpretable as another type have to be quoted;
    // e.g. the string 'true' vs. the boolean true.
    return plain && !testAmbiguousType(string) ? STYLE_PLAIN : STYLE_SINGLE;
  }
  // Edge case: block indentation indicator can only have one digit.
  if (string[0] === ' ' && indentPerLevel > 9) {
    return STYLE_DOUBLE;
  }
  // At this point we know block styles are valid.
  // Prefer literal style unless we want to fold.
  return hasFoldableLine ? STYLE_FOLDED : STYLE_LITERAL;
}

// Note: line breaking/folding is implemented for only the folded style.
// NB. We drop the last trailing newline (if any) of a returned block scalar
//  since the dumper adds its own newline. This always works:
//     No ending newline => unaffected; already using strip "-" chomping.
//     Ending newline    => removed then restored.
//  Importantly, this keeps the "+" chomp indicator from gaining an extra line.
function writeScalar(state, string, level, iskey) {
  state.dump = function () {
    if (string.length === 0) {
      return "''";
    }
    if (!state.noCompatMode && DEPRECATED_BOOLEANS_SYNTAX.indexOf(string) !== -1) {
      return "'" + string + "'";
    }

    var indent = state.indent * Math.max(1, level); // no 0-indent scalars
    // As indentation gets deeper, let the width decrease monotonically
    // to the lower bound min(state.lineWidth, 40).
    // Note that this implies
    //  state.lineWidth  40 + state.indent: width is fixed at the lower bound.
    //  state.lineWidth > 40 + state.indent: width decreases until the lower bound.
    // This behaves better than a constant minimum width which disallows narrower options,
    // or an indent threshold which causes the width to suddenly increase.
    var lineWidth = state.lineWidth === -1 ? -1 : Math.max(Math.min(state.lineWidth, 40), state.lineWidth - indent);

    // Without knowing if keys are implicit/explicit, assume implicit for safety.
    var singleLineOnly = iskey
    // No block styles in flow mode.
    || state.flowLevel > -1 && level >= state.flowLevel;
    function testAmbiguity(string) {
      return testImplicitResolving(state, string);
    }

    switch (chooseScalarStyle(string, singleLineOnly, state.indent, lineWidth, testAmbiguity)) {
      case STYLE_PLAIN:
        return string;
      case STYLE_SINGLE:
        return "'" + string.replace(/'/g, "''") + "'";
      case STYLE_LITERAL:
        return '|' + blockHeader(string, state.indent) + dropEndingNewline(indentString(string, indent));
      case STYLE_FOLDED:
        return '>' + blockHeader(string, state.indent) + dropEndingNewline(indentString(foldString(string, lineWidth), indent));
      case STYLE_DOUBLE:
        return '"' + escapeString(string, lineWidth) + '"';
      default:
        throw new YAMLException('impossible error: invalid scalar style');
    }
  }();
}

// Pre-conditions: string is valid for a block scalar, 1 <= indentPerLevel <= 9.
function blockHeader(string, indentPerLevel) {
  var indentIndicator = string[0] === ' ' ? String(indentPerLevel) : '';

  // note the special case: the string '\n' counts as a "trailing" empty line.
  var clip = string[string.length - 1] === '\n';
  var keep = clip && (string[string.length - 2] === '\n' || string === '\n');
  var chomp = keep ? '+' : clip ? '' : '-';

  return indentIndicator + chomp + '\n';
}

// (See the note for writeScalar.)
function dropEndingNewline(string) {
  return string[string.length - 1] === '\n' ? string.slice(0, -1) : string;
}

// Note: a long line without a suitable break point will exceed the width limit.
// Pre-conditions: every char in str isPrintable, str.length > 0, width > 0.
function foldString(string, width) {
  // In folded style, $k$ consecutive newlines output as $k+1$ newlines
  // unless they're before or after a more-indented line, or at the very
  // beginning or end, in which case $k$ maps to $k$.
  // Therefore, parse each chunk as newline(s) followed by a content line.
  var lineRe = /(\n+)([^\n]*)/g;

  // first line (possibly an empty line)
  var result = function () {
    var nextLF = string.indexOf('\n');
    nextLF = nextLF !== -1 ? nextLF : string.length;
    lineRe.lastIndex = nextLF;
    return foldLine(string.slice(0, nextLF), width);
  }();
  // If we haven't reached the first content line yet, don't add an extra \n.
  var prevMoreIndented = string[0] === '\n' || string[0] === ' ';
  var moreIndented;

  // rest of the lines
  var match;
  while (match = lineRe.exec(string)) {
    var prefix = match[1],
        line = match[2];
    moreIndented = line[0] === ' ';
    result += prefix + (!prevMoreIndented && !moreIndented && line !== '' ? '\n' : '') + foldLine(line, width);
    prevMoreIndented = moreIndented;
  }

  return result;
}

// Greedy line breaking.
// Picks the longest line under the limit each time,
// otherwise settles for the shortest line over the limit.
// NB. More-indented lines *cannot* be folded, as that would add an extra \n.
function foldLine(line, width) {
  if (line === '' || line[0] === ' ') return line;

  // Since a more-indented line adds a \n, breaks can't be followed by a space.
  var breakRe = / [^ ]/g; // note: the match index will always be <= length-2.
  var match;
  // start is an inclusive index. end, curr, and next are exclusive.
  var start = 0,
      end,
      curr = 0,
      next = 0;
  var result = '';

  // Invariants: 0 <= start <= length-1.
  //   0 <= curr <= next <= max(0, length-2). curr - start <= width.
  // Inside the loop:
  //   A match implies length >= 2, so curr and next are <= length-2.
  while (match = breakRe.exec(line)) {
    next = match.index;
    // maintain invariant: curr - start <= width
    if (next - start > width) {
      end = curr > start ? curr : next; // derive end <= length-2
      result += '\n' + line.slice(start, end);
      // skip the space that was output as \n
      start = end + 1; // derive start <= length-1
    }
    curr = next;
  }

  // By the invariants, start <= length-1, so there is something left over.
  // It is either the whole string or a part starting from non-whitespace.
  result += '\n';
  // Insert a break if the remainder is too long and there is a break available.
  if (line.length - start > width && curr > start) {
    result += line.slice(start, curr) + '\n' + line.slice(curr + 1);
  } else {
    result += line.slice(start);
  }

  return result.slice(1); // drop extra \n joiner
}

// Escapes a double-quoted string.
function escapeString(string) {
  var result = '';
  var char, nextChar;
  var escapeSeq;

  for (var i = 0; i < string.length; i++) {
    char = string.charCodeAt(i);
    // Check for surrogate pairs (reference Unicode 3.0 section "3.7 Surrogates").
    if (char >= 0xD800 && char <= 0xDBFF /* high surrogate */) {
        nextChar = string.charCodeAt(i + 1);
        if (nextChar >= 0xDC00 && nextChar <= 0xDFFF /* low surrogate */) {
            // Combine the surrogate pair and store it escaped.
            result += encodeHex((char - 0xD800) * 0x400 + nextChar - 0xDC00 + 0x10000);
            // Advance index one extra since we already used that char here.
            i++;continue;
          }
      }
    escapeSeq = ESCAPE_SEQUENCES[char];
    result += !escapeSeq && isPrintable(char) ? string[i] : escapeSeq || encodeHex(char);
  }

  return result;
}

function writeFlowSequence(state, level, object) {
  var _result = '',
      _tag = state.tag,
      index,
      length;

  for (index = 0, length = object.length; index < length; index += 1) {
    // Write only valid elements.
    if (writeNode(state, level, object[index], false, false)) {
      if (index !== 0) _result += ',' + (!state.condenseFlow ? ' ' : '');
      _result += state.dump;
    }
  }

  state.tag = _tag;
  state.dump = '[' + _result + ']';
}

function writeBlockSequence(state, level, object, compact) {
  var _result = '',
      _tag = state.tag,
      index,
      length;

  for (index = 0, length = object.length; index < length; index += 1) {
    // Write only valid elements.
    if (writeNode(state, level + 1, object[index], true, true)) {
      if (!compact || index !== 0) {
        _result += generateNextLine(state, level);
      }

      if (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0)) {
        _result += '-';
      } else {
        _result += '- ';
      }

      _result += state.dump;
    }
  }

  state.tag = _tag;
  state.dump = _result || '[]'; // Empty sequence if no valid values.
}

function writeFlowMapping(state, level, object) {
  var _result = '',
      _tag = state.tag,
      objectKeyList = Object.keys(object),
      index,
      length,
      objectKey,
      objectValue,
      pairBuffer;

  for (index = 0, length = objectKeyList.length; index < length; index += 1) {
    pairBuffer = state.condenseFlow ? '"' : '';

    if (index !== 0) pairBuffer += ', ';

    objectKey = objectKeyList[index];
    objectValue = object[objectKey];

    if (!writeNode(state, level, objectKey, false, false)) {
      continue; // Skip this pair because of invalid key;
    }

    if (state.dump.length > 1024) pairBuffer += '? ';

    pairBuffer += state.dump + (state.condenseFlow ? '"' : '') + ':' + (state.condenseFlow ? '' : ' ');

    if (!writeNode(state, level, objectValue, false, false)) {
      continue; // Skip this pair because of invalid value.
    }

    pairBuffer += state.dump;

    // Both key and value are valid.
    _result += pairBuffer;
  }

  state.tag = _tag;
  state.dump = '{' + _result + '}';
}

function writeBlockMapping(state, level, object, compact) {
  var _result = '',
      _tag = state.tag,
      objectKeyList = Object.keys(object),
      index,
      length,
      objectKey,
      objectValue,
      explicitPair,
      pairBuffer;

  // Allow sorting keys so that the output file is deterministic
  if (state.sortKeys === true) {
    // Default sorting
    objectKeyList.sort();
  } else if (typeof state.sortKeys === 'function') {
    // Custom sort function
    objectKeyList.sort(state.sortKeys);
  } else if (state.sortKeys) {
    // Something is wrong
    throw new YAMLException('sortKeys must be a boolean or a function');
  }

  for (index = 0, length = objectKeyList.length; index < length; index += 1) {
    pairBuffer = '';

    if (!compact || index !== 0) {
      pairBuffer += generateNextLine(state, level);
    }

    objectKey = objectKeyList[index];
    objectValue = object[objectKey];

    if (!writeNode(state, level + 1, objectKey, true, true, true)) {
      continue; // Skip this pair because of invalid key.
    }

    explicitPair = state.tag !== null && state.tag !== '?' || state.dump && state.dump.length > 1024;

    if (explicitPair) {
      if (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0)) {
        pairBuffer += '?';
      } else {
        pairBuffer += '? ';
      }
    }

    pairBuffer += state.dump;

    if (explicitPair) {
      pairBuffer += generateNextLine(state, level);
    }

    if (!writeNode(state, level + 1, objectValue, true, explicitPair)) {
      continue; // Skip this pair because of invalid value.
    }

    if (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0)) {
      pairBuffer += ':';
    } else {
      pairBuffer += ': ';
    }

    pairBuffer += state.dump;

    // Both key and value are valid.
    _result += pairBuffer;
  }

  state.tag = _tag;
  state.dump = _result || '{}'; // Empty mapping if no valid pairs.
}

function detectType(state, object, explicit) {
  var _result, typeList, index, length, type, style;

  typeList = explicit ? state.explicitTypes : state.implicitTypes;

  for (index = 0, length = typeList.length; index < length; index += 1) {
    type = typeList[index];

    if ((type.instanceOf || type.predicate) && (!type.instanceOf || typeof object === 'object' && object instanceof type.instanceOf) && (!type.predicate || type.predicate(object))) {

      state.tag = explicit ? type.tag : '?';

      if (type.represent) {
        style = state.styleMap[type.tag] || type.defaultStyle;

        if (_toString.call(type.represent) === '[object Function]') {
          _result = type.represent(object, style);
        } else if (_hasOwnProperty.call(type.represent, style)) {
          _result = type.represent[style](object, style);
        } else {
          throw new YAMLException('!<' + type.tag + '> tag resolver accepts not "' + style + '" style');
        }

        state.dump = _result;
      }

      return true;
    }
  }

  return false;
}

// Serializes `object` and writes it to global `result`.
// Returns true on success, or false on invalid object.
//
function writeNode(state, level, object, block, compact, iskey) {
  state.tag = null;
  state.dump = object;

  if (!detectType(state, object, false)) {
    detectType(state, object, true);
  }

  var type = _toString.call(state.dump);

  if (block) {
    block = state.flowLevel < 0 || state.flowLevel > level;
  }

  var objectOrArray = type === '[object Object]' || type === '[object Array]',
      duplicateIndex,
      duplicate;

  if (objectOrArray) {
    duplicateIndex = state.duplicates.indexOf(object);
    duplicate = duplicateIndex !== -1;
  }

  if (state.tag !== null && state.tag !== '?' || duplicate || state.indent !== 2 && level > 0) {
    compact = false;
  }

  if (duplicate && state.usedDuplicates[duplicateIndex]) {
    state.dump = '*ref_' + duplicateIndex;
  } else {
    if (objectOrArray && duplicate && !state.usedDuplicates[duplicateIndex]) {
      state.usedDuplicates[duplicateIndex] = true;
    }
    if (type === '[object Object]') {
      if (block && Object.keys(state.dump).length !== 0) {
        writeBlockMapping(state, level, state.dump, compact);
        if (duplicate) {
          state.dump = '&ref_' + duplicateIndex + state.dump;
        }
      } else {
        writeFlowMapping(state, level, state.dump);
        if (duplicate) {
          state.dump = '&ref_' + duplicateIndex + ' ' + state.dump;
        }
      }
    } else if (type === '[object Array]') {
      if (block && state.dump.length !== 0) {
        writeBlockSequence(state, level, state.dump, compact);
        if (duplicate) {
          state.dump = '&ref_' + duplicateIndex + state.dump;
        }
      } else {
        writeFlowSequence(state, level, state.dump);
        if (duplicate) {
          state.dump = '&ref_' + duplicateIndex + ' ' + state.dump;
        }
      }
    } else if (type === '[object String]') {
      if (state.tag !== '?') {
        writeScalar(state, state.dump, level, iskey);
      }
    } else {
      if (state.skipInvalid) return false;
      throw new YAMLException('unacceptable kind of an object to dump ' + type);
    }

    if (state.tag !== null && state.tag !== '?') {
      state.dump = '!<' + state.tag + '> ' + state.dump;
    }
  }

  return true;
}

function getDuplicateReferences(object, state) {
  var objects = [],
      duplicatesIndexes = [],
      index,
      length;

  inspectNode(object, objects, duplicatesIndexes);

  for (index = 0, length = duplicatesIndexes.length; index < length; index += 1) {
    state.duplicates.push(objects[duplicatesIndexes[index]]);
  }
  state.usedDuplicates = new Array(length);
}

function inspectNode(object, objects, duplicatesIndexes) {
  var objectKeyList, index, length;

  if (object !== null && typeof object === 'object') {
    index = objects.indexOf(object);
    if (index !== -1) {
      if (duplicatesIndexes.indexOf(index) === -1) {
        duplicatesIndexes.push(index);
      }
    } else {
      objects.push(object);

      if (Array.isArray(object)) {
        for (index = 0, length = object.length; index < length; index += 1) {
          inspectNode(object[index], objects, duplicatesIndexes);
        }
      } else {
        objectKeyList = Object.keys(object);

        for (index = 0, length = objectKeyList.length; index < length; index += 1) {
          inspectNode(object[objectKeyList[index]], objects, duplicatesIndexes);
        }
      }
    }
  }
}

function dump(input, options) {
  options = options || {};

  var state = new State(options);

  if (!state.noRefs) getDuplicateReferences(input, state);

  if (writeNode(state, 0, input, true, true)) return state.dump + '\n';

  return '';
}

function safeDump(input, options) {
  return dump(input, common.extend({ schema: DEFAULT_SAFE_SCHEMA }, options));
}

module.exports.dump = dump;
module.exports.safeDump = safeDump;

/***/ }),
/* 159 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
class Lazy {
    constructor(creator) {
        this.creator = creator;
    }
    get hasValue() {
        return this.creator == null;
    }
    get value() {
        if (this.creator == null) {
            return this._value;
        }
        this.value = this.creator();
        return this._value;
    }
    set value(value) {
        this._value = value;
        this.creator = null;
    }
}
exports.Lazy = Lazy; //# sourceMappingURL=main.js.map

/***/ }),
/* 160 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var SourceMapConsumer = __webpack_require__(161).SourceMapConsumer;
var path = __webpack_require__(0);

var fs;
try {
  fs = __webpack_require__(12);
  if (!fs.existsSync || !fs.readFileSync) {
    // fs doesn't have all methods we need
    fs = null;
  }
} catch (err) {}
/* nop */


// Only install once if called multiple times
var errorFormatterInstalled = false;
var uncaughtShimInstalled = false;

// If true, the caches are reset before a stack trace formatting operation
var emptyCacheBetweenOperations = false;

// Supports {browser, node, auto}
var environment = "auto";

// Maps a file path to a string containing the file contents
var fileContentsCache = {};

// Maps a file path to a source map for that file
var sourceMapCache = {};

// Regex for detecting source maps
var reSourceMap = /^data:application\/json[^,]+base64,/;

// Priority list of retrieve handlers
var retrieveFileHandlers = [];
var retrieveMapHandlers = [];

function isInBrowser() {
  if (environment === "browser") return true;
  if (environment === "node") return false;
  return typeof window !== 'undefined' && typeof XMLHttpRequest === 'function' && !(window.require && window.module && window.process && window.process.type === "renderer");
}

function hasGlobalProcessEventEmitter() {
  return typeof process === 'object' && process !== null && typeof process.on === 'function';
}

function handlerExec(list) {
  return function (arg) {
    for (var i = 0; i < list.length; i++) {
      var ret = list[i](arg);
      if (ret) {
        return ret;
      }
    }
    return null;
  };
}

var retrieveFile = handlerExec(retrieveFileHandlers);

retrieveFileHandlers.push(function (path) {
  // Trim the path to make sure there is no extra whitespace.
  path = path.trim();
  if (path in fileContentsCache) {
    return fileContentsCache[path];
  }

  var contents = null;
  if (!fs) {
    // Use SJAX if we are in the browser
    var xhr = new XMLHttpRequest();
    xhr.open('GET', path, false);
    xhr.send(null);
    var contents = null;
    if (xhr.readyState === 4 && xhr.status === 200) {
      contents = xhr.responseText;
    }
  } else if (fs.existsSync(path)) {
    // Otherwise, use the filesystem
    try {
      contents = fs.readFileSync(path, 'utf8');
    } catch (er) {
      contents = '';
    }
  }

  return fileContentsCache[path] = contents;
});

// Support URLs relative to a directory, but be careful about a protocol prefix
// in case we are in the browser (i.e. directories may start with "http://")
function supportRelativeURL(file, url) {
  if (!file) return url;
  var dir = path.dirname(file);
  var match = /^\w+:\/\/[^\/]*/.exec(dir);
  var protocol = match ? match[0] : '';
  return protocol + path.resolve(dir.slice(protocol.length), url);
}

function retrieveSourceMapURL(source) {
  var fileData;

  if (isInBrowser()) {
    try {
      var xhr = new XMLHttpRequest();
      xhr.open('GET', source, false);
      xhr.send(null);
      fileData = xhr.readyState === 4 ? xhr.responseText : null;

      // Support providing a sourceMappingURL via the SourceMap header
      var sourceMapHeader = xhr.getResponseHeader("SourceMap") || xhr.getResponseHeader("X-SourceMap");
      if (sourceMapHeader) {
        return sourceMapHeader;
      }
    } catch (e) {}
  }

  // Get the URL of the source map
  fileData = retrieveFile(source);
  var re = /(?:\/\/[@#][ \t]+sourceMappingURL=([^\s'"]+?)[ \t]*$)|(?:\/\*[@#][ \t]+sourceMappingURL=([^\*]+?)[ \t]*(?:\*\/)[ \t]*$)/mg;
  // Keep executing the search to find the *last* sourceMappingURL to avoid
  // picking up sourceMappingURLs from comments, strings, etc.
  var lastMatch, match;
  while (match = re.exec(fileData)) lastMatch = match;
  if (!lastMatch) return null;
  return lastMatch[1];
};

// Can be overridden by the retrieveSourceMap option to install. Takes a
// generated source filename; returns a {map, optional url} object, or null if
// there is no source map.  The map field may be either a string or the parsed
// JSON object (ie, it must be a valid argument to the SourceMapConsumer
// constructor).
var retrieveSourceMap = handlerExec(retrieveMapHandlers);
retrieveMapHandlers.push(function (source) {
  var sourceMappingURL = retrieveSourceMapURL(source);
  if (!sourceMappingURL) return null;

  // Read the contents of the source map
  var sourceMapData;
  if (reSourceMap.test(sourceMappingURL)) {
    // Support source map URL as a data url
    var rawData = sourceMappingURL.slice(sourceMappingURL.indexOf(',') + 1);
    sourceMapData = new Buffer(rawData, "base64").toString();
    sourceMappingURL = source;
  } else {
    // Support source map URLs relative to the source URL
    sourceMappingURL = supportRelativeURL(source, sourceMappingURL);
    sourceMapData = retrieveFile(sourceMappingURL);
  }

  if (!sourceMapData) {
    return null;
  }

  return {
    url: sourceMappingURL,
    map: sourceMapData
  };
});

function mapSourcePosition(position) {
  var sourceMap = sourceMapCache[position.source];
  if (!sourceMap) {
    // Call the (overrideable) retrieveSourceMap function to get the source map.
    var urlAndMap = retrieveSourceMap(position.source);
    if (urlAndMap) {
      sourceMap = sourceMapCache[position.source] = {
        url: urlAndMap.url,
        map: new SourceMapConsumer(urlAndMap.map)
      };

      // Load all sources stored inline with the source map into the file cache
      // to pretend like they are already loaded. They may not exist on disk.
      if (sourceMap.map.sourcesContent) {
        sourceMap.map.sources.forEach(function (source, i) {
          var contents = sourceMap.map.sourcesContent[i];
          if (contents) {
            var url = supportRelativeURL(sourceMap.url, source);
            fileContentsCache[url] = contents;
          }
        });
      }
    } else {
      sourceMap = sourceMapCache[position.source] = {
        url: null,
        map: null
      };
    }
  }

  // Resolve the source URL relative to the URL of the source map
  if (sourceMap && sourceMap.map) {
    var originalPosition = sourceMap.map.originalPositionFor(position);

    // Only return the original position if a matching line was found. If no
    // matching line is found then we return position instead, which will cause
    // the stack trace to print the path and line for the compiled file. It is
    // better to give a precise location in the compiled file than a vague
    // location in the original file.
    if (originalPosition.source !== null) {
      originalPosition.source = supportRelativeURL(sourceMap.url, originalPosition.source);
      return originalPosition;
    }
  }

  return position;
}

// Parses code generated by FormatEvalOrigin(), a function inside V8:
// https://code.google.com/p/v8/source/browse/trunk/src/messages.js
function mapEvalOrigin(origin) {
  // Most eval() calls are in this format
  var match = /^eval at ([^(]+) \((.+):(\d+):(\d+)\)$/.exec(origin);
  if (match) {
    var position = mapSourcePosition({
      source: match[2],
      line: +match[3],
      column: match[4] - 1
    });
    return 'eval at ' + match[1] + ' (' + position.source + ':' + position.line + ':' + (position.column + 1) + ')';
  }

  // Parse nested eval() calls using recursion
  match = /^eval at ([^(]+) \((.+)\)$/.exec(origin);
  if (match) {
    return 'eval at ' + match[1] + ' (' + mapEvalOrigin(match[2]) + ')';
  }

  // Make sure we still return useful information if we didn't find anything
  return origin;
}

// This is copied almost verbatim from the V8 source code at
// https://code.google.com/p/v8/source/browse/trunk/src/messages.js. The
// implementation of wrapCallSite() used to just forward to the actual source
// code of CallSite.prototype.toString but unfortunately a new release of V8
// did something to the prototype chain and broke the shim. The only fix I
// could find was copy/paste.
function CallSiteToString() {
  var fileName;
  var fileLocation = "";
  if (this.isNative()) {
    fileLocation = "native";
  } else {
    fileName = this.getScriptNameOrSourceURL();
    if (!fileName && this.isEval()) {
      fileLocation = this.getEvalOrigin();
      fileLocation += ", "; // Expecting source position to follow.
    }

    if (fileName) {
      fileLocation += fileName;
    } else {
      // Source code does not originate from a file and is not native, but we
      // can still get the source position inside the source string, e.g. in
      // an eval string.
      fileLocation += "<anonymous>";
    }
    var lineNumber = this.getLineNumber();
    if (lineNumber != null) {
      fileLocation += ":" + lineNumber;
      var columnNumber = this.getColumnNumber();
      if (columnNumber) {
        fileLocation += ":" + columnNumber;
      }
    }
  }

  var line = "";
  var functionName = this.getFunctionName();
  var addSuffix = true;
  var isConstructor = this.isConstructor();
  var isMethodCall = !(this.isToplevel() || isConstructor);
  if (isMethodCall) {
    var typeName = this.getTypeName();
    // Fixes shim to be backward compatable with Node v0 to v4
    if (typeName === "[object Object]") {
      typeName = "null";
    }
    var methodName = this.getMethodName();
    if (functionName) {
      if (typeName && functionName.indexOf(typeName) != 0) {
        line += typeName + ".";
      }
      line += functionName;
      if (methodName && functionName.indexOf("." + methodName) != functionName.length - methodName.length - 1) {
        line += " [as " + methodName + "]";
      }
    } else {
      line += typeName + "." + (methodName || "<anonymous>");
    }
  } else if (isConstructor) {
    line += "new " + (functionName || "<anonymous>");
  } else if (functionName) {
    line += functionName;
  } else {
    line += fileLocation;
    addSuffix = false;
  }
  if (addSuffix) {
    line += " (" + fileLocation + ")";
  }
  return line;
}

function cloneCallSite(frame) {
  var object = {};
  Object.getOwnPropertyNames(Object.getPrototypeOf(frame)).forEach(function (name) {
    object[name] = /^(?:is|get)/.test(name) ? function () {
      return frame[name].call(frame);
    } : frame[name];
  });
  object.toString = CallSiteToString;
  return object;
}

function wrapCallSite(frame) {
  if (frame.isNative()) {
    return frame;
  }

  // Most call sites will return the source file from getFileName(), but code
  // passed to eval() ending in "//# sourceURL=..." will return the source file
  // from getScriptNameOrSourceURL() instead
  var source = frame.getFileName() || frame.getScriptNameOrSourceURL();
  if (source) {
    var line = frame.getLineNumber();
    var column = frame.getColumnNumber() - 1;

    // Fix position in Node where some (internal) code is prepended.
    // See https://github.com/evanw/node-source-map-support/issues/36
    var headerLength = 62;
    if (line === 1 && column > headerLength && !isInBrowser() && !frame.isEval()) {
      column -= headerLength;
    }

    var position = mapSourcePosition({
      source: source,
      line: line,
      column: column
    });
    frame = cloneCallSite(frame);
    frame.getFileName = function () {
      return position.source;
    };
    frame.getLineNumber = function () {
      return position.line;
    };
    frame.getColumnNumber = function () {
      return position.column + 1;
    };
    frame.getScriptNameOrSourceURL = function () {
      return position.source;
    };
    return frame;
  }

  // Code called using eval() needs special handling
  var origin = frame.isEval() && frame.getEvalOrigin();
  if (origin) {
    origin = mapEvalOrigin(origin);
    frame = cloneCallSite(frame);
    frame.getEvalOrigin = function () {
      return origin;
    };
    return frame;
  }

  // If we get here then we were unable to change the source position
  return frame;
}

// This function is part of the V8 stack trace API, for more info see:
// http://code.google.com/p/v8/wiki/JavaScriptStackTraceApi
function prepareStackTrace(error, stack) {
  if (emptyCacheBetweenOperations) {
    fileContentsCache = {};
    sourceMapCache = {};
  }

  return error + stack.map(function (frame) {
    return '\n    at ' + wrapCallSite(frame);
  }).join('');
}

// Generate position and snippet of original source with pointer
function getErrorSource(error) {
  var match = /\n    at [^(]+ \((.*):(\d+):(\d+)\)/.exec(error.stack);
  if (match) {
    var source = match[1];
    var line = +match[2];
    var column = +match[3];

    // Support the inline sourceContents inside the source map
    var contents = fileContentsCache[source];

    // Support files on disk
    if (!contents && fs && fs.existsSync(source)) {
      try {
        contents = fs.readFileSync(source, 'utf8');
      } catch (er) {
        contents = '';
      }
    }

    // Format the line from the original source code like node does
    if (contents) {
      var code = contents.split(/(?:\r\n|\r|\n)/)[line - 1];
      if (code) {
        return source + ':' + line + '\n' + code + '\n' + new Array(column).join(' ') + '^';
      }
    }
  }
  return null;
}

function printErrorAndExit(error) {
  var source = getErrorSource(error);

  if (source) {
    console.error();
    console.error(source);
  }

  console.error(error.stack);
  process.exit(1);
}

function shimEmitUncaughtException() {
  var origEmit = process.emit;

  process.emit = function (type) {
    if (type === 'uncaughtException') {
      var hasStack = arguments[1] && arguments[1].stack;
      var hasListeners = this.listeners(type).length > 0;

      if (hasStack && !hasListeners) {
        return printErrorAndExit(arguments[1]);
      }
    }

    return origEmit.apply(this, arguments);
  };
}

exports.wrapCallSite = wrapCallSite;
exports.getErrorSource = getErrorSource;
exports.mapSourcePosition = mapSourcePosition;
exports.retrieveSourceMap = retrieveSourceMap;

exports.install = function (options) {
  options = options || {};

  if (options.environment) {
    environment = options.environment;
    if (["node", "browser", "auto"].indexOf(environment) === -1) {
      throw new Error("environment " + environment + " was unknown. Available options are {auto, browser, node}");
    }
  }

  // Allow sources to be found by methods other than reading the files
  // directly from disk.
  if (options.retrieveFile) {
    if (options.overrideRetrieveFile) {
      retrieveFileHandlers.length = 0;
    }

    retrieveFileHandlers.unshift(options.retrieveFile);
  }

  // Allow source maps to be found by methods other than reading the files
  // directly from disk.
  if (options.retrieveSourceMap) {
    if (options.overrideRetrieveSourceMap) {
      retrieveMapHandlers.length = 0;
    }

    retrieveMapHandlers.unshift(options.retrieveSourceMap);
  }

  // Support runtime transpilers that include inline source maps
  if (options.hookRequire && !isInBrowser()) {
    var Module;
    try {
      Module = __webpack_require__(168);
    } catch (err) {
      // NOP: Loading in catch block to convert webpack error to warning.
    }
    var $compile = Module.prototype._compile;

    if (!$compile.__sourceMapSupport) {
      Module.prototype._compile = function (content, filename) {
        fileContentsCache[filename] = content;
        sourceMapCache[filename] = undefined;
        return $compile.call(this, content, filename);
      };

      Module.prototype._compile.__sourceMapSupport = true;
    }
  }

  // Configure options
  if (!emptyCacheBetweenOperations) {
    emptyCacheBetweenOperations = 'emptyCacheBetweenOperations' in options ? options.emptyCacheBetweenOperations : false;
  }

  // Install the error reformatter
  if (!errorFormatterInstalled) {
    errorFormatterInstalled = true;
    Error.prepareStackTrace = prepareStackTrace;
  }

  if (!uncaughtShimInstalled) {
    var installHandler = 'handleUncaughtExceptions' in options ? options.handleUncaughtExceptions : true;

    // Provide the option to not install the uncaught exception handler. This is
    // to support other uncaught exception handlers (in test frameworks, for
    // example). If this handler is not installed and there are no other uncaught
    // exception handlers, uncaught exceptions will be caught by node's built-in
    // exception handler and the process will still be terminated. However, the
    // generated JavaScript code will be shown above the stack trace instead of
    // the original source code.
    if (installHandler && hasGlobalProcessEventEmitter()) {
      uncaughtShimInstalled = true;
      shimEmitUncaughtException();
    }
  }
};

/***/ }),
/* 161 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/*
 * Copyright 2009-2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE.txt or:
 * http://opensource.org/licenses/BSD-3-Clause
 */
exports.SourceMapGenerator = __webpack_require__(56).SourceMapGenerator;
exports.SourceMapConsumer = __webpack_require__(164).SourceMapConsumer;
exports.SourceNode = __webpack_require__(167).SourceNode;

/***/ }),
/* 162 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/* -*- Mode: js; js-indent-level: 2; -*- */
/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */

var intToCharMap = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'.split('');

/**
 * Encode an integer in the range of 0 to 63 to a single base 64 digit.
 */
exports.encode = function (number) {
  if (0 <= number && number < intToCharMap.length) {
    return intToCharMap[number];
  }
  throw new TypeError("Must be between 0 and 63: " + number);
};

/**
 * Decode a single base 64 character code digit to an integer. Returns -1 on
 * failure.
 */
exports.decode = function (charCode) {
  var bigA = 65; // 'A'
  var bigZ = 90; // 'Z'

  var littleA = 97; // 'a'
  var littleZ = 122; // 'z'

  var zero = 48; // '0'
  var nine = 57; // '9'

  var plus = 43; // '+'
  var slash = 47; // '/'

  var littleOffset = 26;
  var numberOffset = 52;

  // 0 - 25: ABCDEFGHIJKLMNOPQRSTUVWXYZ
  if (bigA <= charCode && charCode <= bigZ) {
    return charCode - bigA;
  }

  // 26 - 51: abcdefghijklmnopqrstuvwxyz
  if (littleA <= charCode && charCode <= littleZ) {
    return charCode - littleA + littleOffset;
  }

  // 52 - 61: 0123456789
  if (zero <= charCode && charCode <= nine) {
    return charCode - zero + numberOffset;
  }

  // 62: +
  if (charCode == plus) {
    return 62;
  }

  // 63: /
  if (charCode == slash) {
    return 63;
  }

  // Invalid base64 digit.
  return -1;
};

/***/ }),
/* 163 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/* -*- Mode: js; js-indent-level: 2; -*- */
/*
 * Copyright 2014 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */

var util = __webpack_require__(23);

/**
 * Determine whether mappingB is after mappingA with respect to generated
 * position.
 */
function generatedPositionAfter(mappingA, mappingB) {
  // Optimized for most common case
  var lineA = mappingA.generatedLine;
  var lineB = mappingB.generatedLine;
  var columnA = mappingA.generatedColumn;
  var columnB = mappingB.generatedColumn;
  return lineB > lineA || lineB == lineA && columnB >= columnA || util.compareByGeneratedPositionsInflated(mappingA, mappingB) <= 0;
}

/**
 * A data structure to provide a sorted view of accumulated mappings in a
 * performance conscious manner. It trades a neglibable overhead in general
 * case for a large speedup in case of mappings being added in order.
 */
function MappingList() {
  this._array = [];
  this._sorted = true;
  // Serves as infimum
  this._last = { generatedLine: -1, generatedColumn: 0 };
}

/**
 * Iterate through internal items. This method takes the same arguments that
 * `Array.prototype.forEach` takes.
 *
 * NOTE: The order of the mappings is NOT guaranteed.
 */
MappingList.prototype.unsortedForEach = function MappingList_forEach(aCallback, aThisArg) {
  this._array.forEach(aCallback, aThisArg);
};

/**
 * Add the given source mapping.
 *
 * @param Object aMapping
 */
MappingList.prototype.add = function MappingList_add(aMapping) {
  if (generatedPositionAfter(this._last, aMapping)) {
    this._last = aMapping;
    this._array.push(aMapping);
  } else {
    this._sorted = false;
    this._array.push(aMapping);
  }
};

/**
 * Returns the flat, sorted array of mappings. The mappings are sorted by
 * generated position.
 *
 * WARNING: This method returns internal data without copying, for
 * performance. The return value must NOT be mutated, and should be treated as
 * an immutable borrow. If you want to take ownership, you must make your own
 * copy.
 */
MappingList.prototype.toArray = function MappingList_toArray() {
  if (!this._sorted) {
    this._array.sort(util.compareByGeneratedPositionsInflated);
    this._sorted = true;
  }
  return this._array;
};

exports.MappingList = MappingList;

/***/ }),
/* 164 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/* -*- Mode: js; js-indent-level: 2; -*- */
/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */

var util = __webpack_require__(23);
var binarySearch = __webpack_require__(165);
var ArraySet = __webpack_require__(58).ArraySet;
var base64VLQ = __webpack_require__(57);
var quickSort = __webpack_require__(166).quickSort;

function SourceMapConsumer(aSourceMap, aSourceMapURL) {
  var sourceMap = aSourceMap;
  if (typeof aSourceMap === 'string') {
    sourceMap = util.parseSourceMapInput(aSourceMap);
  }

  return sourceMap.sections != null ? new IndexedSourceMapConsumer(sourceMap, aSourceMapURL) : new BasicSourceMapConsumer(sourceMap, aSourceMapURL);
}

SourceMapConsumer.fromSourceMap = function (aSourceMap, aSourceMapURL) {
  return BasicSourceMapConsumer.fromSourceMap(aSourceMap, aSourceMapURL);
};

/**
 * The version of the source mapping spec that we are consuming.
 */
SourceMapConsumer.prototype._version = 3;

// `__generatedMappings` and `__originalMappings` are arrays that hold the
// parsed mapping coordinates from the source map's "mappings" attribute. They
// are lazily instantiated, accessed via the `_generatedMappings` and
// `_originalMappings` getters respectively, and we only parse the mappings
// and create these arrays once queried for a source location. We jump through
// these hoops because there can be many thousands of mappings, and parsing
// them is expensive, so we only want to do it if we must.
//
// Each object in the arrays is of the form:
//
//     {
//       generatedLine: The line number in the generated code,
//       generatedColumn: The column number in the generated code,
//       source: The path to the original source file that generated this
//               chunk of code,
//       originalLine: The line number in the original source that
//                     corresponds to this chunk of generated code,
//       originalColumn: The column number in the original source that
//                       corresponds to this chunk of generated code,
//       name: The name of the original symbol which generated this chunk of
//             code.
//     }
//
// All properties except for `generatedLine` and `generatedColumn` can be
// `null`.
//
// `_generatedMappings` is ordered by the generated positions.
//
// `_originalMappings` is ordered by the original positions.

SourceMapConsumer.prototype.__generatedMappings = null;
Object.defineProperty(SourceMapConsumer.prototype, '_generatedMappings', {
  configurable: true,
  enumerable: true,
  get: function () {
    if (!this.__generatedMappings) {
      this._parseMappings(this._mappings, this.sourceRoot);
    }

    return this.__generatedMappings;
  }
});

SourceMapConsumer.prototype.__originalMappings = null;
Object.defineProperty(SourceMapConsumer.prototype, '_originalMappings', {
  configurable: true,
  enumerable: true,
  get: function () {
    if (!this.__originalMappings) {
      this._parseMappings(this._mappings, this.sourceRoot);
    }

    return this.__originalMappings;
  }
});

SourceMapConsumer.prototype._charIsMappingSeparator = function SourceMapConsumer_charIsMappingSeparator(aStr, index) {
  var c = aStr.charAt(index);
  return c === ";" || c === ",";
};

/**
 * Parse the mappings in a string in to a data structure which we can easily
 * query (the ordered arrays in the `this.__generatedMappings` and
 * `this.__originalMappings` properties).
 */
SourceMapConsumer.prototype._parseMappings = function SourceMapConsumer_parseMappings(aStr, aSourceRoot) {
  throw new Error("Subclasses must implement _parseMappings");
};

SourceMapConsumer.GENERATED_ORDER = 1;
SourceMapConsumer.ORIGINAL_ORDER = 2;

SourceMapConsumer.GREATEST_LOWER_BOUND = 1;
SourceMapConsumer.LEAST_UPPER_BOUND = 2;

/**
 * Iterate over each mapping between an original source/line/column and a
 * generated line/column in this source map.
 *
 * @param Function aCallback
 *        The function that is called with each mapping.
 * @param Object aContext
 *        Optional. If specified, this object will be the value of `this` every
 *        time that `aCallback` is called.
 * @param aOrder
 *        Either `SourceMapConsumer.GENERATED_ORDER` or
 *        `SourceMapConsumer.ORIGINAL_ORDER`. Specifies whether you want to
 *        iterate over the mappings sorted by the generated file's line/column
 *        order or the original's source/line/column order, respectively. Defaults to
 *        `SourceMapConsumer.GENERATED_ORDER`.
 */
SourceMapConsumer.prototype.eachMapping = function SourceMapConsumer_eachMapping(aCallback, aContext, aOrder) {
  var context = aContext || null;
  var order = aOrder || SourceMapConsumer.GENERATED_ORDER;

  var mappings;
  switch (order) {
    case SourceMapConsumer.GENERATED_ORDER:
      mappings = this._generatedMappings;
      break;
    case SourceMapConsumer.ORIGINAL_ORDER:
      mappings = this._originalMappings;
      break;
    default:
      throw new Error("Unknown order of iteration.");
  }

  var sourceRoot = this.sourceRoot;
  mappings.map(function (mapping) {
    var source = mapping.source === null ? null : this._sources.at(mapping.source);
    source = util.computeSourceURL(sourceRoot, source, this._sourceMapURL);
    return {
      source: source,
      generatedLine: mapping.generatedLine,
      generatedColumn: mapping.generatedColumn,
      originalLine: mapping.originalLine,
      originalColumn: mapping.originalColumn,
      name: mapping.name === null ? null : this._names.at(mapping.name)
    };
  }, this).forEach(aCallback, context);
};

/**
 * Returns all generated line and column information for the original source,
 * line, and column provided. If no column is provided, returns all mappings
 * corresponding to a either the line we are searching for or the next
 * closest line that has any mappings. Otherwise, returns all mappings
 * corresponding to the given line and either the column we are searching for
 * or the next closest column that has any offsets.
 *
 * The only argument is an object with the following properties:
 *
 *   - source: The filename of the original source.
 *   - line: The line number in the original source.  The line number is 1-based.
 *   - column: Optional. the column number in the original source.
 *    The column number is 0-based.
 *
 * and an array of objects is returned, each with the following properties:
 *
 *   - line: The line number in the generated source, or null.  The
 *    line number is 1-based.
 *   - column: The column number in the generated source, or null.
 *    The column number is 0-based.
 */
SourceMapConsumer.prototype.allGeneratedPositionsFor = function SourceMapConsumer_allGeneratedPositionsFor(aArgs) {
  var line = util.getArg(aArgs, 'line');

  // When there is no exact match, BasicSourceMapConsumer.prototype._findMapping
  // returns the index of the closest mapping less than the needle. By
  // setting needle.originalColumn to 0, we thus find the last mapping for
  // the given line, provided such a mapping exists.
  var needle = {
    source: util.getArg(aArgs, 'source'),
    originalLine: line,
    originalColumn: util.getArg(aArgs, 'column', 0)
  };

  needle.source = this._findSourceIndex(needle.source);
  if (needle.source < 0) {
    return [];
  }

  var mappings = [];

  var index = this._findMapping(needle, this._originalMappings, "originalLine", "originalColumn", util.compareByOriginalPositions, binarySearch.LEAST_UPPER_BOUND);
  if (index >= 0) {
    var mapping = this._originalMappings[index];

    if (aArgs.column === undefined) {
      var originalLine = mapping.originalLine;

      // Iterate until either we run out of mappings, or we run into
      // a mapping for a different line than the one we found. Since
      // mappings are sorted, this is guaranteed to find all mappings for
      // the line we found.
      while (mapping && mapping.originalLine === originalLine) {
        mappings.push({
          line: util.getArg(mapping, 'generatedLine', null),
          column: util.getArg(mapping, 'generatedColumn', null),
          lastColumn: util.getArg(mapping, 'lastGeneratedColumn', null)
        });

        mapping = this._originalMappings[++index];
      }
    } else {
      var originalColumn = mapping.originalColumn;

      // Iterate until either we run out of mappings, or we run into
      // a mapping for a different line than the one we were searching for.
      // Since mappings are sorted, this is guaranteed to find all mappings for
      // the line we are searching for.
      while (mapping && mapping.originalLine === line && mapping.originalColumn == originalColumn) {
        mappings.push({
          line: util.getArg(mapping, 'generatedLine', null),
          column: util.getArg(mapping, 'generatedColumn', null),
          lastColumn: util.getArg(mapping, 'lastGeneratedColumn', null)
        });

        mapping = this._originalMappings[++index];
      }
    }
  }

  return mappings;
};

exports.SourceMapConsumer = SourceMapConsumer;

/**
 * A BasicSourceMapConsumer instance represents a parsed source map which we can
 * query for information about the original file positions by giving it a file
 * position in the generated source.
 *
 * The first parameter is the raw source map (either as a JSON string, or
 * already parsed to an object). According to the spec, source maps have the
 * following attributes:
 *
 *   - version: Which version of the source map spec this map is following.
 *   - sources: An array of URLs to the original source files.
 *   - names: An array of identifiers which can be referrenced by individual mappings.
 *   - sourceRoot: Optional. The URL root from which all sources are relative.
 *   - sourcesContent: Optional. An array of contents of the original source files.
 *   - mappings: A string of base64 VLQs which contain the actual mappings.
 *   - file: Optional. The generated file this source map is associated with.
 *
 * Here is an example source map, taken from the source map spec[0]:
 *
 *     {
 *       version : 3,
 *       file: "out.js",
 *       sourceRoot : "",
 *       sources: ["foo.js", "bar.js"],
 *       names: ["src", "maps", "are", "fun"],
 *       mappings: "AA,AB;;ABCDE;"
 *     }
 *
 * The second parameter, if given, is a string whose value is the URL
 * at which the source map was found.  This URL is used to compute the
 * sources array.
 *
 * [0]: https://docs.google.com/document/d/1U1RGAehQwRypUTovF1KRlpiOFze0b-_2gc6fAH0KY0k/edit?pli=1#
 */
function BasicSourceMapConsumer(aSourceMap, aSourceMapURL) {
  var sourceMap = aSourceMap;
  if (typeof aSourceMap === 'string') {
    sourceMap = util.parseSourceMapInput(aSourceMap);
  }

  var version = util.getArg(sourceMap, 'version');
  var sources = util.getArg(sourceMap, 'sources');
  // Sass 3.3 leaves out the 'names' array, so we deviate from the spec (which
  // requires the array) to play nice here.
  var names = util.getArg(sourceMap, 'names', []);
  var sourceRoot = util.getArg(sourceMap, 'sourceRoot', null);
  var sourcesContent = util.getArg(sourceMap, 'sourcesContent', null);
  var mappings = util.getArg(sourceMap, 'mappings');
  var file = util.getArg(sourceMap, 'file', null);

  // Once again, Sass deviates from the spec and supplies the version as a
  // string rather than a number, so we use loose equality checking here.
  if (version != this._version) {
    throw new Error('Unsupported version: ' + version);
  }

  if (sourceRoot) {
    sourceRoot = util.normalize(sourceRoot);
  }

  sources = sources.map(String)
  // Some source maps produce relative source paths like "./foo.js" instead of
  // "foo.js".  Normalize these first so that future comparisons will succeed.
  // See bugzil.la/1090768.
  .map(util.normalize)
  // Always ensure that absolute sources are internally stored relative to
  // the source root, if the source root is absolute. Not doing this would
  // be particularly problematic when the source root is a prefix of the
  // source (valid, but why??). See github issue #199 and bugzil.la/1188982.
  .map(function (source) {
    return sourceRoot && util.isAbsolute(sourceRoot) && util.isAbsolute(source) ? util.relative(sourceRoot, source) : source;
  });

  // Pass `true` below to allow duplicate names and sources. While source maps
  // are intended to be compressed and deduplicated, the TypeScript compiler
  // sometimes generates source maps with duplicates in them. See Github issue
  // #72 and bugzil.la/889492.
  this._names = ArraySet.fromArray(names.map(String), true);
  this._sources = ArraySet.fromArray(sources, true);

  this._absoluteSources = this._sources.toArray().map(function (s) {
    return util.computeSourceURL(sourceRoot, s, aSourceMapURL);
  });

  this.sourceRoot = sourceRoot;
  this.sourcesContent = sourcesContent;
  this._mappings = mappings;
  this._sourceMapURL = aSourceMapURL;
  this.file = file;
}

BasicSourceMapConsumer.prototype = Object.create(SourceMapConsumer.prototype);
BasicSourceMapConsumer.prototype.consumer = SourceMapConsumer;

/**
 * Utility function to find the index of a source.  Returns -1 if not
 * found.
 */
BasicSourceMapConsumer.prototype._findSourceIndex = function (aSource) {
  var relativeSource = aSource;
  if (this.sourceRoot != null) {
    relativeSource = util.relative(this.sourceRoot, relativeSource);
  }

  if (this._sources.has(relativeSource)) {
    return this._sources.indexOf(relativeSource);
  }

  // Maybe aSource is an absolute URL as returned by |sources|.  In
  // this case we can't simply undo the transform.
  var i;
  for (i = 0; i < this._absoluteSources.length; ++i) {
    if (this._absoluteSources[i] == aSource) {
      return i;
    }
  }

  return -1;
};

/**
 * Create a BasicSourceMapConsumer from a SourceMapGenerator.
 *
 * @param SourceMapGenerator aSourceMap
 *        The source map that will be consumed.
 * @param String aSourceMapURL
 *        The URL at which the source map can be found (optional)
 * @returns BasicSourceMapConsumer
 */
BasicSourceMapConsumer.fromSourceMap = function SourceMapConsumer_fromSourceMap(aSourceMap, aSourceMapURL) {
  var smc = Object.create(BasicSourceMapConsumer.prototype);

  var names = smc._names = ArraySet.fromArray(aSourceMap._names.toArray(), true);
  var sources = smc._sources = ArraySet.fromArray(aSourceMap._sources.toArray(), true);
  smc.sourceRoot = aSourceMap._sourceRoot;
  smc.sourcesContent = aSourceMap._generateSourcesContent(smc._sources.toArray(), smc.sourceRoot);
  smc.file = aSourceMap._file;
  smc._sourceMapURL = aSourceMapURL;
  smc._absoluteSources = smc._sources.toArray().map(function (s) {
    return util.computeSourceURL(smc.sourceRoot, s, aSourceMapURL);
  });

  // Because we are modifying the entries (by converting string sources and
  // names to indices into the sources and names ArraySets), we have to make
  // a copy of the entry or else bad things happen. Shared mutable state
  // strikes again! See github issue #191.

  var generatedMappings = aSourceMap._mappings.toArray().slice();
  var destGeneratedMappings = smc.__generatedMappings = [];
  var destOriginalMappings = smc.__originalMappings = [];

  for (var i = 0, length = generatedMappings.length; i < length; i++) {
    var srcMapping = generatedMappings[i];
    var destMapping = new Mapping();
    destMapping.generatedLine = srcMapping.generatedLine;
    destMapping.generatedColumn = srcMapping.generatedColumn;

    if (srcMapping.source) {
      destMapping.source = sources.indexOf(srcMapping.source);
      destMapping.originalLine = srcMapping.originalLine;
      destMapping.originalColumn = srcMapping.originalColumn;

      if (srcMapping.name) {
        destMapping.name = names.indexOf(srcMapping.name);
      }

      destOriginalMappings.push(destMapping);
    }

    destGeneratedMappings.push(destMapping);
  }

  quickSort(smc.__originalMappings, util.compareByOriginalPositions);

  return smc;
};

/**
 * The version of the source mapping spec that we are consuming.
 */
BasicSourceMapConsumer.prototype._version = 3;

/**
 * The list of original sources.
 */
Object.defineProperty(BasicSourceMapConsumer.prototype, 'sources', {
  get: function () {
    return this._absoluteSources.slice();
  }
});

/**
 * Provide the JIT with a nice shape / hidden class.
 */
function Mapping() {
  this.generatedLine = 0;
  this.generatedColumn = 0;
  this.source = null;
  this.originalLine = null;
  this.originalColumn = null;
  this.name = null;
}

/**
 * Parse the mappings in a string in to a data structure which we can easily
 * query (the ordered arrays in the `this.__generatedMappings` and
 * `this.__originalMappings` properties).
 */
BasicSourceMapConsumer.prototype._parseMappings = function SourceMapConsumer_parseMappings(aStr, aSourceRoot) {
  var generatedLine = 1;
  var previousGeneratedColumn = 0;
  var previousOriginalLine = 0;
  var previousOriginalColumn = 0;
  var previousSource = 0;
  var previousName = 0;
  var length = aStr.length;
  var index = 0;
  var cachedSegments = {};
  var temp = {};
  var originalMappings = [];
  var generatedMappings = [];
  var mapping, str, segment, end, value;

  while (index < length) {
    if (aStr.charAt(index) === ';') {
      generatedLine++;
      index++;
      previousGeneratedColumn = 0;
    } else if (aStr.charAt(index) === ',') {
      index++;
    } else {
      mapping = new Mapping();
      mapping.generatedLine = generatedLine;

      // Because each offset is encoded relative to the previous one,
      // many segments often have the same encoding. We can exploit this
      // fact by caching the parsed variable length fields of each segment,
      // allowing us to avoid a second parse if we encounter the same
      // segment again.
      for (end = index; end < length; end++) {
        if (this._charIsMappingSeparator(aStr, end)) {
          break;
        }
      }
      str = aStr.slice(index, end);

      segment = cachedSegments[str];
      if (segment) {
        index += str.length;
      } else {
        segment = [];
        while (index < end) {
          base64VLQ.decode(aStr, index, temp);
          value = temp.value;
          index = temp.rest;
          segment.push(value);
        }

        if (segment.length === 2) {
          throw new Error('Found a source, but no line and column');
        }

        if (segment.length === 3) {
          throw new Error('Found a source and line, but no column');
        }

        cachedSegments[str] = segment;
      }

      // Generated column.
      mapping.generatedColumn = previousGeneratedColumn + segment[0];
      previousGeneratedColumn = mapping.generatedColumn;

      if (segment.length > 1) {
        // Original source.
        mapping.source = previousSource + segment[1];
        previousSource += segment[1];

        // Original line.
        mapping.originalLine = previousOriginalLine + segment[2];
        previousOriginalLine = mapping.originalLine;
        // Lines are stored 0-based
        mapping.originalLine += 1;

        // Original column.
        mapping.originalColumn = previousOriginalColumn + segment[3];
        previousOriginalColumn = mapping.originalColumn;

        if (segment.length > 4) {
          // Original name.
          mapping.name = previousName + segment[4];
          previousName += segment[4];
        }
      }

      generatedMappings.push(mapping);
      if (typeof mapping.originalLine === 'number') {
        originalMappings.push(mapping);
      }
    }
  }

  quickSort(generatedMappings, util.compareByGeneratedPositionsDeflated);
  this.__generatedMappings = generatedMappings;

  quickSort(originalMappings, util.compareByOriginalPositions);
  this.__originalMappings = originalMappings;
};

/**
 * Find the mapping that best matches the hypothetical "needle" mapping that
 * we are searching for in the given "haystack" of mappings.
 */
BasicSourceMapConsumer.prototype._findMapping = function SourceMapConsumer_findMapping(aNeedle, aMappings, aLineName, aColumnName, aComparator, aBias) {
  // To return the position we are searching for, we must first find the
  // mapping for the given position and then return the opposite position it
  // points to. Because the mappings are sorted, we can use binary search to
  // find the best mapping.

  if (aNeedle[aLineName] <= 0) {
    throw new TypeError('Line must be greater than or equal to 1, got ' + aNeedle[aLineName]);
  }
  if (aNeedle[aColumnName] < 0) {
    throw new TypeError('Column must be greater than or equal to 0, got ' + aNeedle[aColumnName]);
  }

  return binarySearch.search(aNeedle, aMappings, aComparator, aBias);
};

/**
 * Compute the last column for each generated mapping. The last column is
 * inclusive.
 */
BasicSourceMapConsumer.prototype.computeColumnSpans = function SourceMapConsumer_computeColumnSpans() {
  for (var index = 0; index < this._generatedMappings.length; ++index) {
    var mapping = this._generatedMappings[index];

    // Mappings do not contain a field for the last generated columnt. We
    // can come up with an optimistic estimate, however, by assuming that
    // mappings are contiguous (i.e. given two consecutive mappings, the
    // first mapping ends where the second one starts).
    if (index + 1 < this._generatedMappings.length) {
      var nextMapping = this._generatedMappings[index + 1];

      if (mapping.generatedLine === nextMapping.generatedLine) {
        mapping.lastGeneratedColumn = nextMapping.generatedColumn - 1;
        continue;
      }
    }

    // The last mapping for each line spans the entire line.
    mapping.lastGeneratedColumn = Infinity;
  }
};

/**
 * Returns the original source, line, and column information for the generated
 * source's line and column positions provided. The only argument is an object
 * with the following properties:
 *
 *   - line: The line number in the generated source.  The line number
 *     is 1-based.
 *   - column: The column number in the generated source.  The column
 *     number is 0-based.
 *   - bias: Either 'SourceMapConsumer.GREATEST_LOWER_BOUND' or
 *     'SourceMapConsumer.LEAST_UPPER_BOUND'. Specifies whether to return the
 *     closest element that is smaller than or greater than the one we are
 *     searching for, respectively, if the exact element cannot be found.
 *     Defaults to 'SourceMapConsumer.GREATEST_LOWER_BOUND'.
 *
 * and an object is returned with the following properties:
 *
 *   - source: The original source file, or null.
 *   - line: The line number in the original source, or null.  The
 *     line number is 1-based.
 *   - column: The column number in the original source, or null.  The
 *     column number is 0-based.
 *   - name: The original identifier, or null.
 */
BasicSourceMapConsumer.prototype.originalPositionFor = function SourceMapConsumer_originalPositionFor(aArgs) {
  var needle = {
    generatedLine: util.getArg(aArgs, 'line'),
    generatedColumn: util.getArg(aArgs, 'column')
  };

  var index = this._findMapping(needle, this._generatedMappings, "generatedLine", "generatedColumn", util.compareByGeneratedPositionsDeflated, util.getArg(aArgs, 'bias', SourceMapConsumer.GREATEST_LOWER_BOUND));

  if (index >= 0) {
    var mapping = this._generatedMappings[index];

    if (mapping.generatedLine === needle.generatedLine) {
      var source = util.getArg(mapping, 'source', null);
      if (source !== null) {
        source = this._sources.at(source);
        source = util.computeSourceURL(this.sourceRoot, source, this._sourceMapURL);
      }
      var name = util.getArg(mapping, 'name', null);
      if (name !== null) {
        name = this._names.at(name);
      }
      return {
        source: source,
        line: util.getArg(mapping, 'originalLine', null),
        column: util.getArg(mapping, 'originalColumn', null),
        name: name
      };
    }
  }

  return {
    source: null,
    line: null,
    column: null,
    name: null
  };
};

/**
 * Return true if we have the source content for every source in the source
 * map, false otherwise.
 */
BasicSourceMapConsumer.prototype.hasContentsOfAllSources = function BasicSourceMapConsumer_hasContentsOfAllSources() {
  if (!this.sourcesContent) {
    return false;
  }
  return this.sourcesContent.length >= this._sources.size() && !this.sourcesContent.some(function (sc) {
    return sc == null;
  });
};

/**
 * Returns the original source content. The only argument is the url of the
 * original source file. Returns null if no original source content is
 * available.
 */
BasicSourceMapConsumer.prototype.sourceContentFor = function SourceMapConsumer_sourceContentFor(aSource, nullOnMissing) {
  if (!this.sourcesContent) {
    return null;
  }

  var index = this._findSourceIndex(aSource);
  if (index >= 0) {
    return this.sourcesContent[index];
  }

  var relativeSource = aSource;
  if (this.sourceRoot != null) {
    relativeSource = util.relative(this.sourceRoot, relativeSource);
  }

  var url;
  if (this.sourceRoot != null && (url = util.urlParse(this.sourceRoot))) {
    // XXX: file:// URIs and absolute paths lead to unexpected behavior for
    // many users. We can help them out when they expect file:// URIs to
    // behave like it would if they were running a local HTTP server. See
    // https://bugzilla.mozilla.org/show_bug.cgi?id=885597.
    var fileUriAbsPath = relativeSource.replace(/^file:\/\//, "");
    if (url.scheme == "file" && this._sources.has(fileUriAbsPath)) {
      return this.sourcesContent[this._sources.indexOf(fileUriAbsPath)];
    }

    if ((!url.path || url.path == "/") && this._sources.has("/" + relativeSource)) {
      return this.sourcesContent[this._sources.indexOf("/" + relativeSource)];
    }
  }

  // This function is used recursively from
  // IndexedSourceMapConsumer.prototype.sourceContentFor. In that case, we
  // don't want to throw if we can't find the source - we just want to
  // return null, so we provide a flag to exit gracefully.
  if (nullOnMissing) {
    return null;
  } else {
    throw new Error('"' + relativeSource + '" is not in the SourceMap.');
  }
};

/**
 * Returns the generated line and column information for the original source,
 * line, and column positions provided. The only argument is an object with
 * the following properties:
 *
 *   - source: The filename of the original source.
 *   - line: The line number in the original source.  The line number
 *     is 1-based.
 *   - column: The column number in the original source.  The column
 *     number is 0-based.
 *   - bias: Either 'SourceMapConsumer.GREATEST_LOWER_BOUND' or
 *     'SourceMapConsumer.LEAST_UPPER_BOUND'. Specifies whether to return the
 *     closest element that is smaller than or greater than the one we are
 *     searching for, respectively, if the exact element cannot be found.
 *     Defaults to 'SourceMapConsumer.GREATEST_LOWER_BOUND'.
 *
 * and an object is returned with the following properties:
 *
 *   - line: The line number in the generated source, or null.  The
 *     line number is 1-based.
 *   - column: The column number in the generated source, or null.
 *     The column number is 0-based.
 */
BasicSourceMapConsumer.prototype.generatedPositionFor = function SourceMapConsumer_generatedPositionFor(aArgs) {
  var source = util.getArg(aArgs, 'source');
  source = this._findSourceIndex(source);
  if (source < 0) {
    return {
      line: null,
      column: null,
      lastColumn: null
    };
  }

  var needle = {
    source: source,
    originalLine: util.getArg(aArgs, 'line'),
    originalColumn: util.getArg(aArgs, 'column')
  };

  var index = this._findMapping(needle, this._originalMappings, "originalLine", "originalColumn", util.compareByOriginalPositions, util.getArg(aArgs, 'bias', SourceMapConsumer.GREATEST_LOWER_BOUND));

  if (index >= 0) {
    var mapping = this._originalMappings[index];

    if (mapping.source === needle.source) {
      return {
        line: util.getArg(mapping, 'generatedLine', null),
        column: util.getArg(mapping, 'generatedColumn', null),
        lastColumn: util.getArg(mapping, 'lastGeneratedColumn', null)
      };
    }
  }

  return {
    line: null,
    column: null,
    lastColumn: null
  };
};

exports.BasicSourceMapConsumer = BasicSourceMapConsumer;

/**
 * An IndexedSourceMapConsumer instance represents a parsed source map which
 * we can query for information. It differs from BasicSourceMapConsumer in
 * that it takes "indexed" source maps (i.e. ones with a "sections" field) as
 * input.
 *
 * The first parameter is a raw source map (either as a JSON string, or already
 * parsed to an object). According to the spec for indexed source maps, they
 * have the following attributes:
 *
 *   - version: Which version of the source map spec this map is following.
 *   - file: Optional. The generated file this source map is associated with.
 *   - sections: A list of section definitions.
 *
 * Each value under the "sections" field has two fields:
 *   - offset: The offset into the original specified at which this section
 *       begins to apply, defined as an object with a "line" and "column"
 *       field.
 *   - map: A source map definition. This source map could also be indexed,
 *       but doesn't have to be.
 *
 * Instead of the "map" field, it's also possible to have a "url" field
 * specifying a URL to retrieve a source map from, but that's currently
 * unsupported.
 *
 * Here's an example source map, taken from the source map spec[0], but
 * modified to omit a section which uses the "url" field.
 *
 *  {
 *    version : 3,
 *    file: "app.js",
 *    sections: [{
 *      offset: {line:100, column:10},
 *      map: {
 *        version : 3,
 *        file: "section.js",
 *        sources: ["foo.js", "bar.js"],
 *        names: ["src", "maps", "are", "fun"],
 *        mappings: "AAAA,E;;ABCDE;"
 *      }
 *    }],
 *  }
 *
 * The second parameter, if given, is a string whose value is the URL
 * at which the source map was found.  This URL is used to compute the
 * sources array.
 *
 * [0]: https://docs.google.com/document/d/1U1RGAehQwRypUTovF1KRlpiOFze0b-_2gc6fAH0KY0k/edit#heading=h.535es3xeprgt
 */
function IndexedSourceMapConsumer(aSourceMap, aSourceMapURL) {
  var sourceMap = aSourceMap;
  if (typeof aSourceMap === 'string') {
    sourceMap = util.parseSourceMapInput(aSourceMap);
  }

  var version = util.getArg(sourceMap, 'version');
  var sections = util.getArg(sourceMap, 'sections');

  if (version != this._version) {
    throw new Error('Unsupported version: ' + version);
  }

  this._sources = new ArraySet();
  this._names = new ArraySet();

  var lastOffset = {
    line: -1,
    column: 0
  };
  this._sections = sections.map(function (s) {
    if (s.url) {
      // The url field will require support for asynchronicity.
      // See https://github.com/mozilla/source-map/issues/16
      throw new Error('Support for url field in sections not implemented.');
    }
    var offset = util.getArg(s, 'offset');
    var offsetLine = util.getArg(offset, 'line');
    var offsetColumn = util.getArg(offset, 'column');

    if (offsetLine < lastOffset.line || offsetLine === lastOffset.line && offsetColumn < lastOffset.column) {
      throw new Error('Section offsets must be ordered and non-overlapping.');
    }
    lastOffset = offset;

    return {
      generatedOffset: {
        // The offset fields are 0-based, but we use 1-based indices when
        // encoding/decoding from VLQ.
        generatedLine: offsetLine + 1,
        generatedColumn: offsetColumn + 1
      },
      consumer: new SourceMapConsumer(util.getArg(s, 'map'), aSourceMapURL)
    };
  });
}

IndexedSourceMapConsumer.prototype = Object.create(SourceMapConsumer.prototype);
IndexedSourceMapConsumer.prototype.constructor = SourceMapConsumer;

/**
 * The version of the source mapping spec that we are consuming.
 */
IndexedSourceMapConsumer.prototype._version = 3;

/**
 * The list of original sources.
 */
Object.defineProperty(IndexedSourceMapConsumer.prototype, 'sources', {
  get: function () {
    var sources = [];
    for (var i = 0; i < this._sections.length; i++) {
      for (var j = 0; j < this._sections[i].consumer.sources.length; j++) {
        sources.push(this._sections[i].consumer.sources[j]);
      }
    }
    return sources;
  }
});

/**
 * Returns the original source, line, and column information for the generated
 * source's line and column positions provided. The only argument is an object
 * with the following properties:
 *
 *   - line: The line number in the generated source.  The line number
 *     is 1-based.
 *   - column: The column number in the generated source.  The column
 *     number is 0-based.
 *
 * and an object is returned with the following properties:
 *
 *   - source: The original source file, or null.
 *   - line: The line number in the original source, or null.  The
 *     line number is 1-based.
 *   - column: The column number in the original source, or null.  The
 *     column number is 0-based.
 *   - name: The original identifier, or null.
 */
IndexedSourceMapConsumer.prototype.originalPositionFor = function IndexedSourceMapConsumer_originalPositionFor(aArgs) {
  var needle = {
    generatedLine: util.getArg(aArgs, 'line'),
    generatedColumn: util.getArg(aArgs, 'column')
  };

  // Find the section containing the generated position we're trying to map
  // to an original position.
  var sectionIndex = binarySearch.search(needle, this._sections, function (needle, section) {
    var cmp = needle.generatedLine - section.generatedOffset.generatedLine;
    if (cmp) {
      return cmp;
    }

    return needle.generatedColumn - section.generatedOffset.generatedColumn;
  });
  var section = this._sections[sectionIndex];

  if (!section) {
    return {
      source: null,
      line: null,
      column: null,
      name: null
    };
  }

  return section.consumer.originalPositionFor({
    line: needle.generatedLine - (section.generatedOffset.generatedLine - 1),
    column: needle.generatedColumn - (section.generatedOffset.generatedLine === needle.generatedLine ? section.generatedOffset.generatedColumn - 1 : 0),
    bias: aArgs.bias
  });
};

/**
 * Return true if we have the source content for every source in the source
 * map, false otherwise.
 */
IndexedSourceMapConsumer.prototype.hasContentsOfAllSources = function IndexedSourceMapConsumer_hasContentsOfAllSources() {
  return this._sections.every(function (s) {
    return s.consumer.hasContentsOfAllSources();
  });
};

/**
 * Returns the original source content. The only argument is the url of the
 * original source file. Returns null if no original source content is
 * available.
 */
IndexedSourceMapConsumer.prototype.sourceContentFor = function IndexedSourceMapConsumer_sourceContentFor(aSource, nullOnMissing) {
  for (var i = 0; i < this._sections.length; i++) {
    var section = this._sections[i];

    var content = section.consumer.sourceContentFor(aSource, true);
    if (content) {
      return content;
    }
  }
  if (nullOnMissing) {
    return null;
  } else {
    throw new Error('"' + aSource + '" is not in the SourceMap.');
  }
};

/**
 * Returns the generated line and column information for the original source,
 * line, and column positions provided. The only argument is an object with
 * the following properties:
 *
 *   - source: The filename of the original source.
 *   - line: The line number in the original source.  The line number
 *     is 1-based.
 *   - column: The column number in the original source.  The column
 *     number is 0-based.
 *
 * and an object is returned with the following properties:
 *
 *   - line: The line number in the generated source, or null.  The
 *     line number is 1-based. 
 *   - column: The column number in the generated source, or null.
 *     The column number is 0-based.
 */
IndexedSourceMapConsumer.prototype.generatedPositionFor = function IndexedSourceMapConsumer_generatedPositionFor(aArgs) {
  for (var i = 0; i < this._sections.length; i++) {
    var section = this._sections[i];

    // Only consider this section if the requested source is in the list of
    // sources of the consumer.
    if (section.consumer._findSourceIndex(util.getArg(aArgs, 'source')) === -1) {
      continue;
    }
    var generatedPosition = section.consumer.generatedPositionFor(aArgs);
    if (generatedPosition) {
      var ret = {
        line: generatedPosition.line + (section.generatedOffset.generatedLine - 1),
        column: generatedPosition.column + (section.generatedOffset.generatedLine === generatedPosition.line ? section.generatedOffset.generatedColumn - 1 : 0)
      };
      return ret;
    }
  }

  return {
    line: null,
    column: null
  };
};

/**
 * Parse the mappings in a string in to a data structure which we can easily
 * query (the ordered arrays in the `this.__generatedMappings` and
 * `this.__originalMappings` properties).
 */
IndexedSourceMapConsumer.prototype._parseMappings = function IndexedSourceMapConsumer_parseMappings(aStr, aSourceRoot) {
  this.__generatedMappings = [];
  this.__originalMappings = [];
  for (var i = 0; i < this._sections.length; i++) {
    var section = this._sections[i];
    var sectionMappings = section.consumer._generatedMappings;
    for (var j = 0; j < sectionMappings.length; j++) {
      var mapping = sectionMappings[j];

      var source = section.consumer._sources.at(mapping.source);
      source = util.computeSourceURL(section.consumer.sourceRoot, source, this._sourceMapURL);
      this._sources.add(source);
      source = this._sources.indexOf(source);

      var name = null;
      if (mapping.name) {
        name = section.consumer._names.at(mapping.name);
        this._names.add(name);
        name = this._names.indexOf(name);
      }

      // The mappings coming from the consumer for the section have
      // generated positions relative to the start of the section, so we
      // need to offset them to be relative to the start of the concatenated
      // generated file.
      var adjustedMapping = {
        source: source,
        generatedLine: mapping.generatedLine + (section.generatedOffset.generatedLine - 1),
        generatedColumn: mapping.generatedColumn + (section.generatedOffset.generatedLine === mapping.generatedLine ? section.generatedOffset.generatedColumn - 1 : 0),
        originalLine: mapping.originalLine,
        originalColumn: mapping.originalColumn,
        name: name
      };

      this.__generatedMappings.push(adjustedMapping);
      if (typeof adjustedMapping.originalLine === 'number') {
        this.__originalMappings.push(adjustedMapping);
      }
    }
  }

  quickSort(this.__generatedMappings, util.compareByGeneratedPositionsDeflated);
  quickSort(this.__originalMappings, util.compareByOriginalPositions);
};

exports.IndexedSourceMapConsumer = IndexedSourceMapConsumer;

/***/ }),
/* 165 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/* -*- Mode: js; js-indent-level: 2; -*- */
/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */

exports.GREATEST_LOWER_BOUND = 1;
exports.LEAST_UPPER_BOUND = 2;

/**
 * Recursive implementation of binary search.
 *
 * @param aLow Indices here and lower do not contain the needle.
 * @param aHigh Indices here and higher do not contain the needle.
 * @param aNeedle The element being searched for.
 * @param aHaystack The non-empty array being searched.
 * @param aCompare Function which takes two elements and returns -1, 0, or 1.
 * @param aBias Either 'binarySearch.GREATEST_LOWER_BOUND' or
 *     'binarySearch.LEAST_UPPER_BOUND'. Specifies whether to return the
 *     closest element that is smaller than or greater than the one we are
 *     searching for, respectively, if the exact element cannot be found.
 */
function recursiveSearch(aLow, aHigh, aNeedle, aHaystack, aCompare, aBias) {
  // This function terminates when one of the following is true:
  //
  //   1. We find the exact element we are looking for.
  //
  //   2. We did not find the exact element, but we can return the index of
  //      the next-closest element.
  //
  //   3. We did not find the exact element, and there is no next-closest
  //      element than the one we are searching for, so we return -1.
  var mid = Math.floor((aHigh - aLow) / 2) + aLow;
  var cmp = aCompare(aNeedle, aHaystack[mid], true);
  if (cmp === 0) {
    // Found the element we are looking for.
    return mid;
  } else if (cmp > 0) {
    // Our needle is greater than aHaystack[mid].
    if (aHigh - mid > 1) {
      // The element is in the upper half.
      return recursiveSearch(mid, aHigh, aNeedle, aHaystack, aCompare, aBias);
    }

    // The exact needle element was not found in this haystack. Determine if
    // we are in termination case (3) or (2) and return the appropriate thing.
    if (aBias == exports.LEAST_UPPER_BOUND) {
      return aHigh < aHaystack.length ? aHigh : -1;
    } else {
      return mid;
    }
  } else {
    // Our needle is less than aHaystack[mid].
    if (mid - aLow > 1) {
      // The element is in the lower half.
      return recursiveSearch(aLow, mid, aNeedle, aHaystack, aCompare, aBias);
    }

    // we are in termination case (3) or (2) and return the appropriate thing.
    if (aBias == exports.LEAST_UPPER_BOUND) {
      return mid;
    } else {
      return aLow < 0 ? -1 : aLow;
    }
  }
}

/**
 * This is an implementation of binary search which will always try and return
 * the index of the closest element if there is no exact hit. This is because
 * mappings between original and generated line/col pairs are single points,
 * and there is an implicit region between each of them, so a miss just means
 * that you aren't on the very start of a region.
 *
 * @param aNeedle The element you are looking for.
 * @param aHaystack The array that is being searched.
 * @param aCompare A function which takes the needle and an element in the
 *     array and returns -1, 0, or 1 depending on whether the needle is less
 *     than, equal to, or greater than the element, respectively.
 * @param aBias Either 'binarySearch.GREATEST_LOWER_BOUND' or
 *     'binarySearch.LEAST_UPPER_BOUND'. Specifies whether to return the
 *     closest element that is smaller than or greater than the one we are
 *     searching for, respectively, if the exact element cannot be found.
 *     Defaults to 'binarySearch.GREATEST_LOWER_BOUND'.
 */
exports.search = function search(aNeedle, aHaystack, aCompare, aBias) {
  if (aHaystack.length === 0) {
    return -1;
  }

  var index = recursiveSearch(-1, aHaystack.length, aNeedle, aHaystack, aCompare, aBias || exports.GREATEST_LOWER_BOUND);
  if (index < 0) {
    return -1;
  }

  // We have found either the exact element, or the next-closest element than
  // the one we are searching for. However, there may be more than one such
  // element. Make sure we always return the smallest of these.
  while (index - 1 >= 0) {
    if (aCompare(aHaystack[index], aHaystack[index - 1], true) !== 0) {
      break;
    }
    --index;
  }

  return index;
};

/***/ }),
/* 166 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/* -*- Mode: js; js-indent-level: 2; -*- */
/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */

// It turns out that some (most?) JavaScript engines don't self-host
// `Array.prototype.sort`. This makes sense because C++ will likely remain
// faster than JS when doing raw CPU-intensive sorting. However, when using a
// custom comparator function, calling back and forth between the VM's C++ and
// JIT'd JS is rather slow *and* loses JIT type information, resulting in
// worse generated code for the comparator function than would be optimal. In
// fact, when sorting with a comparator, these costs outweigh the benefits of
// sorting in C++. By using our own JS-implemented Quick Sort (below), we get
// a ~3500ms mean speed-up in `bench/bench.html`.

/**
 * Swap the elements indexed by `x` and `y` in the array `ary`.
 *
 * @param {Array} ary
 *        The array.
 * @param {Number} x
 *        The index of the first item.
 * @param {Number} y
 *        The index of the second item.
 */
function swap(ary, x, y) {
  var temp = ary[x];
  ary[x] = ary[y];
  ary[y] = temp;
}

/**
 * Returns a random integer within the range `low .. high` inclusive.
 *
 * @param {Number} low
 *        The lower bound on the range.
 * @param {Number} high
 *        The upper bound on the range.
 */
function randomIntInRange(low, high) {
  return Math.round(low + Math.random() * (high - low));
}

/**
 * The Quick Sort algorithm.
 *
 * @param {Array} ary
 *        An array to sort.
 * @param {function} comparator
 *        Function to use to compare two items.
 * @param {Number} p
 *        Start index of the array
 * @param {Number} r
 *        End index of the array
 */
function doQuickSort(ary, comparator, p, r) {
  // If our lower bound is less than our upper bound, we (1) partition the
  // array into two pieces and (2) recurse on each half. If it is not, this is
  // the empty array and our base case.

  if (p < r) {
    // (1) Partitioning.
    //
    // The partitioning chooses a pivot between `p` and `r` and moves all
    // elements that are less than or equal to the pivot to the before it, and
    // all the elements that are greater than it after it. The effect is that
    // once partition is done, the pivot is in the exact place it will be when
    // the array is put in sorted order, and it will not need to be moved
    // again. This runs in O(n) time.

    // Always choose a random pivot so that an input array which is reverse
    // sorted does not cause O(n^2) running time.
    var pivotIndex = randomIntInRange(p, r);
    var i = p - 1;

    swap(ary, pivotIndex, r);
    var pivot = ary[r];

    // Immediately after `j` is incremented in this loop, the following hold
    // true:
    //
    //   * Every element in `ary[p .. i]` is less than or equal to the pivot.
    //
    //   * Every element in `ary[i+1 .. j-1]` is greater than the pivot.
    for (var j = p; j < r; j++) {
      if (comparator(ary[j], pivot) <= 0) {
        i += 1;
        swap(ary, i, j);
      }
    }

    swap(ary, i + 1, j);
    var q = i + 1;

    // (2) Recurse on each half.

    doQuickSort(ary, comparator, p, q - 1);
    doQuickSort(ary, comparator, q + 1, r);
  }
}

/**
 * Sort the given array in-place with the given comparator function.
 *
 * @param {Array} ary
 *        An array to sort.
 * @param {function} comparator
 *        Function to use to compare two items.
 */
exports.quickSort = function (ary, comparator) {
  doQuickSort(ary, comparator, 0, ary.length - 1);
};

/***/ }),
/* 167 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/* -*- Mode: js; js-indent-level: 2; -*- */
/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */

var SourceMapGenerator = __webpack_require__(56).SourceMapGenerator;
var util = __webpack_require__(23);

// Matches a Windows-style `\r\n` newline or a `\n` newline used by all other
// operating systems these days (capturing the result).
var REGEX_NEWLINE = /(\r?\n)/;

// Newline character code for charCodeAt() comparisons
var NEWLINE_CODE = 10;

// Private symbol for identifying `SourceNode`s when multiple versions of
// the source-map library are loaded. This MUST NOT CHANGE across
// versions!
var isSourceNode = "$$$isSourceNode$$$";

/**
 * SourceNodes provide a way to abstract over interpolating/concatenating
 * snippets of generated JavaScript source code while maintaining the line and
 * column information associated with the original source code.
 *
 * @param aLine The original line number.
 * @param aColumn The original column number.
 * @param aSource The original source's filename.
 * @param aChunks Optional. An array of strings which are snippets of
 *        generated JS, or other SourceNodes.
 * @param aName The original identifier.
 */
function SourceNode(aLine, aColumn, aSource, aChunks, aName) {
  this.children = [];
  this.sourceContents = {};
  this.line = aLine == null ? null : aLine;
  this.column = aColumn == null ? null : aColumn;
  this.source = aSource == null ? null : aSource;
  this.name = aName == null ? null : aName;
  this[isSourceNode] = true;
  if (aChunks != null) this.add(aChunks);
}

/**
 * Creates a SourceNode from generated code and a SourceMapConsumer.
 *
 * @param aGeneratedCode The generated code
 * @param aSourceMapConsumer The SourceMap for the generated code
 * @param aRelativePath Optional. The path that relative sources in the
 *        SourceMapConsumer should be relative to.
 */
SourceNode.fromStringWithSourceMap = function SourceNode_fromStringWithSourceMap(aGeneratedCode, aSourceMapConsumer, aRelativePath) {
  // The SourceNode we want to fill with the generated code
  // and the SourceMap
  var node = new SourceNode();

  // All even indices of this array are one line of the generated code,
  // while all odd indices are the newlines between two adjacent lines
  // (since `REGEX_NEWLINE` captures its match).
  // Processed fragments are accessed by calling `shiftNextLine`.
  var remainingLines = aGeneratedCode.split(REGEX_NEWLINE);
  var remainingLinesIndex = 0;
  var shiftNextLine = function () {
    var lineContents = getNextLine();
    // The last line of a file might not have a newline.
    var newLine = getNextLine() || "";
    return lineContents + newLine;

    function getNextLine() {
      return remainingLinesIndex < remainingLines.length ? remainingLines[remainingLinesIndex++] : undefined;
    }
  };

  // We need to remember the position of "remainingLines"
  var lastGeneratedLine = 1,
      lastGeneratedColumn = 0;

  // The generate SourceNodes we need a code range.
  // To extract it current and last mapping is used.
  // Here we store the last mapping.
  var lastMapping = null;

  aSourceMapConsumer.eachMapping(function (mapping) {
    if (lastMapping !== null) {
      // We add the code from "lastMapping" to "mapping":
      // First check if there is a new line in between.
      if (lastGeneratedLine < mapping.generatedLine) {
        // Associate first line with "lastMapping"
        addMappingWithCode(lastMapping, shiftNextLine());
        lastGeneratedLine++;
        lastGeneratedColumn = 0;
        // The remaining code is added without mapping
      } else {
        // There is no new line in between.
        // Associate the code between "lastGeneratedColumn" and
        // "mapping.generatedColumn" with "lastMapping"
        var nextLine = remainingLines[remainingLinesIndex] || '';
        var code = nextLine.substr(0, mapping.generatedColumn - lastGeneratedColumn);
        remainingLines[remainingLinesIndex] = nextLine.substr(mapping.generatedColumn - lastGeneratedColumn);
        lastGeneratedColumn = mapping.generatedColumn;
        addMappingWithCode(lastMapping, code);
        // No more remaining code, continue
        lastMapping = mapping;
        return;
      }
    }
    // We add the generated code until the first mapping
    // to the SourceNode without any mapping.
    // Each line is added as separate string.
    while (lastGeneratedLine < mapping.generatedLine) {
      node.add(shiftNextLine());
      lastGeneratedLine++;
    }
    if (lastGeneratedColumn < mapping.generatedColumn) {
      var nextLine = remainingLines[remainingLinesIndex] || '';
      node.add(nextLine.substr(0, mapping.generatedColumn));
      remainingLines[remainingLinesIndex] = nextLine.substr(mapping.generatedColumn);
      lastGeneratedColumn = mapping.generatedColumn;
    }
    lastMapping = mapping;
  }, this);
  // We have processed all mappings.
  if (remainingLinesIndex < remainingLines.length) {
    if (lastMapping) {
      // Associate the remaining code in the current line with "lastMapping"
      addMappingWithCode(lastMapping, shiftNextLine());
    }
    // and add the remaining lines without any mapping
    node.add(remainingLines.splice(remainingLinesIndex).join(""));
  }

  // Copy sourcesContent into SourceNode
  aSourceMapConsumer.sources.forEach(function (sourceFile) {
    var content = aSourceMapConsumer.sourceContentFor(sourceFile);
    if (content != null) {
      if (aRelativePath != null) {
        sourceFile = util.join(aRelativePath, sourceFile);
      }
      node.setSourceContent(sourceFile, content);
    }
  });

  return node;

  function addMappingWithCode(mapping, code) {
    if (mapping === null || mapping.source === undefined) {
      node.add(code);
    } else {
      var source = aRelativePath ? util.join(aRelativePath, mapping.source) : mapping.source;
      node.add(new SourceNode(mapping.originalLine, mapping.originalColumn, source, code, mapping.name));
    }
  }
};

/**
 * Add a chunk of generated JS to this source node.
 *
 * @param aChunk A string snippet of generated JS code, another instance of
 *        SourceNode, or an array where each member is one of those things.
 */
SourceNode.prototype.add = function SourceNode_add(aChunk) {
  if (Array.isArray(aChunk)) {
    aChunk.forEach(function (chunk) {
      this.add(chunk);
    }, this);
  } else if (aChunk[isSourceNode] || typeof aChunk === "string") {
    if (aChunk) {
      this.children.push(aChunk);
    }
  } else {
    throw new TypeError("Expected a SourceNode, string, or an array of SourceNodes and strings. Got " + aChunk);
  }
  return this;
};

/**
 * Add a chunk of generated JS to the beginning of this source node.
 *
 * @param aChunk A string snippet of generated JS code, another instance of
 *        SourceNode, or an array where each member is one of those things.
 */
SourceNode.prototype.prepend = function SourceNode_prepend(aChunk) {
  if (Array.isArray(aChunk)) {
    for (var i = aChunk.length - 1; i >= 0; i--) {
      this.prepend(aChunk[i]);
    }
  } else if (aChunk[isSourceNode] || typeof aChunk === "string") {
    this.children.unshift(aChunk);
  } else {
    throw new TypeError("Expected a SourceNode, string, or an array of SourceNodes and strings. Got " + aChunk);
  }
  return this;
};

/**
 * Walk over the tree of JS snippets in this node and its children. The
 * walking function is called once for each snippet of JS and is passed that
 * snippet and the its original associated source's line/column location.
 *
 * @param aFn The traversal function.
 */
SourceNode.prototype.walk = function SourceNode_walk(aFn) {
  var chunk;
  for (var i = 0, len = this.children.length; i < len; i++) {
    chunk = this.children[i];
    if (chunk[isSourceNode]) {
      chunk.walk(aFn);
    } else {
      if (chunk !== '') {
        aFn(chunk, { source: this.source,
          line: this.line,
          column: this.column,
          name: this.name });
      }
    }
  }
};

/**
 * Like `String.prototype.join` except for SourceNodes. Inserts `aStr` between
 * each of `this.children`.
 *
 * @param aSep The separator.
 */
SourceNode.prototype.join = function SourceNode_join(aSep) {
  var newChildren;
  var i;
  var len = this.children.length;
  if (len > 0) {
    newChildren = [];
    for (i = 0; i < len - 1; i++) {
      newChildren.push(this.children[i]);
      newChildren.push(aSep);
    }
    newChildren.push(this.children[i]);
    this.children = newChildren;
  }
  return this;
};

/**
 * Call String.prototype.replace on the very right-most source snippet. Useful
 * for trimming whitespace from the end of a source node, etc.
 *
 * @param aPattern The pattern to replace.
 * @param aReplacement The thing to replace the pattern with.
 */
SourceNode.prototype.replaceRight = function SourceNode_replaceRight(aPattern, aReplacement) {
  var lastChild = this.children[this.children.length - 1];
  if (lastChild[isSourceNode]) {
    lastChild.replaceRight(aPattern, aReplacement);
  } else if (typeof lastChild === 'string') {
    this.children[this.children.length - 1] = lastChild.replace(aPattern, aReplacement);
  } else {
    this.children.push(''.replace(aPattern, aReplacement));
  }
  return this;
};

/**
 * Set the source content for a source file. This will be added to the SourceMapGenerator
 * in the sourcesContent field.
 *
 * @param aSourceFile The filename of the source file
 * @param aSourceContent The content of the source file
 */
SourceNode.prototype.setSourceContent = function SourceNode_setSourceContent(aSourceFile, aSourceContent) {
  this.sourceContents[util.toSetString(aSourceFile)] = aSourceContent;
};

/**
 * Walk over the tree of SourceNodes. The walking function is called for each
 * source file content and is passed the filename and source content.
 *
 * @param aFn The traversal function.
 */
SourceNode.prototype.walkSourceContents = function SourceNode_walkSourceContents(aFn) {
  for (var i = 0, len = this.children.length; i < len; i++) {
    if (this.children[i][isSourceNode]) {
      this.children[i].walkSourceContents(aFn);
    }
  }

  var sources = Object.keys(this.sourceContents);
  for (var i = 0, len = sources.length; i < len; i++) {
    aFn(util.fromSetString(sources[i]), this.sourceContents[sources[i]]);
  }
};

/**
 * Return the string representation of this source node. Walks over the tree
 * and concatenates all the various snippets together to one string.
 */
SourceNode.prototype.toString = function SourceNode_toString() {
  var str = "";
  this.walk(function (chunk) {
    str += chunk;
  });
  return str;
};

/**
 * Returns the string representation of this source node along with a source
 * map.
 */
SourceNode.prototype.toStringWithSourceMap = function SourceNode_toStringWithSourceMap(aArgs) {
  var generated = {
    code: "",
    line: 1,
    column: 0
  };
  var map = new SourceMapGenerator(aArgs);
  var sourceMappingActive = false;
  var lastOriginalSource = null;
  var lastOriginalLine = null;
  var lastOriginalColumn = null;
  var lastOriginalName = null;
  this.walk(function (chunk, original) {
    generated.code += chunk;
    if (original.source !== null && original.line !== null && original.column !== null) {
      if (lastOriginalSource !== original.source || lastOriginalLine !== original.line || lastOriginalColumn !== original.column || lastOriginalName !== original.name) {
        map.addMapping({
          source: original.source,
          original: {
            line: original.line,
            column: original.column
          },
          generated: {
            line: generated.line,
            column: generated.column
          },
          name: original.name
        });
      }
      lastOriginalSource = original.source;
      lastOriginalLine = original.line;
      lastOriginalColumn = original.column;
      lastOriginalName = original.name;
      sourceMappingActive = true;
    } else if (sourceMappingActive) {
      map.addMapping({
        generated: {
          line: generated.line,
          column: generated.column
        }
      });
      lastOriginalSource = null;
      sourceMappingActive = false;
    }
    for (var idx = 0, length = chunk.length; idx < length; idx++) {
      if (chunk.charCodeAt(idx) === NEWLINE_CODE) {
        generated.line++;
        generated.column = 0;
        // Mappings end at eol
        if (idx + 1 === length) {
          lastOriginalSource = null;
          sourceMappingActive = false;
        } else if (sourceMappingActive) {
          map.addMapping({
            source: original.source,
            original: {
              line: original.line,
              column: original.column
            },
            generated: {
              line: generated.line,
              column: generated.column
            },
            name: original.name
          });
        }
      } else {
        generated.column++;
      }
    }
  });
  this.walkSourceContents(function (sourceFile, sourceContent) {
    map.setSourceContent(sourceFile, sourceContent);
  });

  return { code: generated.code, map: map };
};

exports.SourceNode = SourceNode;

/***/ }),
/* 168 */
/***/ (function(module, exports) {

module.exports = require("module");

/***/ }),
/* 169 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.ElectronHttpExecutor = undefined;

var _bluebirdLst;

function _load_bluebirdLst() {
    return _bluebirdLst = __webpack_require__(2);
}

var _builderUtilRuntime;

function _load_builderUtilRuntime() {
    return _builderUtilRuntime = __webpack_require__(3);
}

var _electron;

function _load_electron() {
    return _electron = __webpack_require__(10);
}

var _fsExtraP;

function _load_fsExtraP() {
    return _fsExtraP = __webpack_require__(9);
}

var _path = _interopRequireWildcard(__webpack_require__(0));

function _interopRequireWildcard(obj) {
    if (obj && obj.__esModule) {
        return obj;
    } else {
        var newObj = {};if (obj != null) {
            for (var key in obj) {
                if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key];
            }
        }newObj.default = obj;return newObj;
    }
}

class ElectronHttpExecutor extends (_builderUtilRuntime || _load_builderUtilRuntime()).HttpExecutor {
    constructor(proxyLoginCallback) {
        super();
        this.proxyLoginCallback = proxyLoginCallback;
    }
    download(url, destination, options) {
        var _this = this;

        return (0, (_bluebirdLst || _load_bluebirdLst()).coroutine)(function* () {
            if (options == null || !options.skipDirCreation) {
                yield (0, (_fsExtraP || _load_fsExtraP()).ensureDir)(_path.dirname(destination));
            }
            return yield options.cancellationToken.createPromise(function (resolve, reject, onCancel) {
                _this.doDownload(Object.assign({}, (0, (_builderUtilRuntime || _load_builderUtilRuntime()).configureRequestOptionsFromUrl)(url, {
                    headers: options.headers || undefined
                }), { redirect: "manual" }), destination, 0, options, function (error) {
                    if (error == null) {
                        resolve(destination);
                    } else {
                        reject(error);
                    }
                }, onCancel);
            });
        })();
    }
    doRequest(options, callback) {
        const request = (_electron || _load_electron()).net.request(options);
        request.on("response", callback);
        this.addProxyLoginHandler(request);
        return request;
    }
    addProxyLoginHandler(request) {
        if (this.proxyLoginCallback != null) {
            request.on("login", this.proxyLoginCallback);
        }
    }
    addRedirectHandlers(request, options, reject, redirectCount, handler) {
        request.on("redirect", (statusCode, method, redirectUrl) => {
            if (redirectCount > 10) {
                reject(new Error("Too many redirects (> 10)"));
                return;
            }
            handler((_builderUtilRuntime || _load_builderUtilRuntime()).HttpExecutor.prepareRedirectUrlOptions(redirectUrl, options));
        });
    }
}
exports.ElectronHttpExecutor = ElectronHttpExecutor; //# sourceMappingURL=electronHttpExecutor.js.map

/***/ }),
/* 170 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.createClient = createClient;

var _builderUtilRuntime;

function _load_builderUtilRuntime() {
    return _builderUtilRuntime = __webpack_require__(3);
}

var _BintrayProvider;

function _load_BintrayProvider() {
    return _BintrayProvider = __webpack_require__(171);
}

var _GenericProvider;

function _load_GenericProvider() {
    return _GenericProvider = __webpack_require__(59);
}

var _GitHubProvider;

function _load_GitHubProvider() {
    return _GitHubProvider = __webpack_require__(60);
}

var _PrivateGitHubProvider;

function _load_PrivateGitHubProvider() {
    return _PrivateGitHubProvider = __webpack_require__(173);
}

function createClient(data, updater) {
    if (typeof data === "string") {
        throw (0, (_builderUtilRuntime || _load_builderUtilRuntime()).newError)("Please pass PublishConfiguration object", "ERR_UPDATER_INVALID_PROVIDER_CONFIGURATION");
    }
    const httpExecutor = updater.httpExecutor;
    const provider = data.provider;
    switch (provider) {
        case "github":
            const githubOptions = data;
            const token = (githubOptions.private ? process.env.GH_TOKEN : null) || githubOptions.token;
            if (token == null) {
                return new (_GitHubProvider || _load_GitHubProvider()).GitHubProvider(githubOptions, updater, httpExecutor);
            } else {
                return new (_PrivateGitHubProvider || _load_PrivateGitHubProvider()).PrivateGitHubProvider(githubOptions, token, httpExecutor);
            }
        case "s3":
        case "spaces":
            return new (_GenericProvider || _load_GenericProvider()).GenericProvider({
                provider: "generic",
                url: (0, (_builderUtilRuntime || _load_builderUtilRuntime()).getS3LikeProviderBaseUrl)(data),
                channel: data.channel || null
            }, updater, provider === "spaces" /* https://github.com/minio/minio/issues/5285#issuecomment-350428955 */);
        case "generic":
            return new (_GenericProvider || _load_GenericProvider()).GenericProvider(data, updater, true);
        case "bintray":
            return new (_BintrayProvider || _load_BintrayProvider()).BintrayProvider(data, httpExecutor);
        default:
            throw (0, (_builderUtilRuntime || _load_builderUtilRuntime()).newError)(`Unsupported provider: ${provider}`, "ERR_UPDATER_UNSUPPORTED_PROVIDER");
    }
}
//# sourceMappingURL=providerFactory.js.map

/***/ }),
/* 171 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.BintrayProvider = undefined;

var _bluebirdLst;

function _load_bluebirdLst() {
    return _bluebirdLst = __webpack_require__(2);
}

var _builderUtilRuntime;

function _load_builderUtilRuntime() {
    return _builderUtilRuntime = __webpack_require__(3);
}

var _bintray;

function _load_bintray() {
    return _bintray = __webpack_require__(172);
}

var _url;

function _load_url() {
    return _url = __webpack_require__(20);
}

var _main;

function _load_main() {
    return _main = __webpack_require__(8);
}

var _Provider;

function _load_Provider() {
    return _Provider = __webpack_require__(14);
}

class BintrayProvider extends (_main || _load_main()).Provider {
    constructor(configuration, httpExecutor) {
        super(httpExecutor);
        this.client = new (_bintray || _load_bintray()).BintrayClient(configuration, httpExecutor, new (_builderUtilRuntime || _load_builderUtilRuntime()).CancellationToken());
        this.baseUrl = (0, (_main || _load_main()).newBaseUrl)(`https://dl.bintray.com/${this.client.owner}/${this.client.repo}`);
    }
    setRequestHeaders(value) {
        super.setRequestHeaders(value);
        this.client.setRequestHeaders(value);
    }
    getLatestVersion() {
        var _this = this;

        return (0, (_bluebirdLst || _load_bluebirdLst()).coroutine)(function* () {
            try {
                const data = yield _this.client.getVersion("_latest");
                const channelFilename = (0, (_main || _load_main()).getChannelFilename)((0, (_main || _load_main()).getDefaultChannelName)());
                const files = yield _this.client.getVersionFiles(data.name);
                const channelFile = files.find(function (it) {
                    return it.name.endsWith(`_${channelFilename}`) || it.name.endsWith(`-${channelFilename}`);
                });
                if (channelFile == null) {
                    // noinspection ExceptionCaughtLocallyJS
                    throw (0, (_builderUtilRuntime || _load_builderUtilRuntime()).newError)(`Cannot find channel file "${channelFilename}", existing files:\n${files.map(function (it) {
                        return JSON.stringify(it, null, 2);
                    }).join(",\n")}`, "ERR_UPDATER_CHANNEL_FILE_NOT_FOUND");
                }
                const channelFileUrl = new (_url || _load_url()).URL(`https://dl.bintray.com/${_this.client.owner}/${_this.client.repo}/${channelFile.name}`);
                return (0, (_Provider || _load_Provider()).parseUpdateInfo)((yield _this.httpRequest(channelFileUrl)), channelFilename, channelFileUrl);
            } catch (e) {
                if ("statusCode" in e && e.statusCode === 404) {
                    throw (0, (_builderUtilRuntime || _load_builderUtilRuntime()).newError)(`No latest version, please ensure that user, package and repository correctly configured. Or at least one version is published. ${e.stack || e.message}`, "ERR_UPDATER_LATEST_VERSION_NOT_FOUND");
                }
                throw e;
            }
        })();
    }
    resolveFiles(updateInfo) {
        return (0, (_Provider || _load_Provider()).resolveFiles)(updateInfo, this.baseUrl);
    }
}
exports.BintrayProvider = BintrayProvider; //# sourceMappingURL=BintrayProvider.js.map

/***/ }),
/* 172 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.BintrayClient = undefined;

var _httpExecutor;

function _load_httpExecutor() {
    return _httpExecutor = __webpack_require__(42);
}

class BintrayClient {
    constructor(options, httpExecutor, cancellationToken, apiKey) {
        this.httpExecutor = httpExecutor;
        this.cancellationToken = cancellationToken;
        if (options.owner == null) {
            throw new Error("owner is not specified");
        }
        if (options.package == null) {
            throw new Error("package is not specified");
        }
        this.repo = options.repo || "generic";
        this.packageName = options.package;
        this.owner = options.owner;
        this.user = options.user || options.owner;
        this.component = options.component || null;
        this.distribution = options.distribution || "stable";
        this.auth = apiKey == null ? null : `Basic ${Buffer.from(`${this.user}:${apiKey}`).toString("base64")}`;
        this.basePath = `/packages/${this.owner}/${this.repo}/${this.packageName}`;
    }
    setRequestHeaders(value) {
        this.requestHeaders = value;
    }
    bintrayRequest(path, auth, data = null, cancellationToken, method) {
        return (0, (_httpExecutor || _load_httpExecutor()).parseJson)(this.httpExecutor.request((0, (_httpExecutor || _load_httpExecutor()).configureRequestOptions)({ hostname: "api.bintray.com", path, headers: this.requestHeaders || undefined }, auth, method), cancellationToken, data));
    }
    getVersion(version) {
        return this.bintrayRequest(`${this.basePath}/versions/${version}`, this.auth, null, this.cancellationToken);
    }
    getVersionFiles(version) {
        return this.bintrayRequest(`${this.basePath}/versions/${version}/files`, this.auth, null, this.cancellationToken);
    }
    createVersion(version) {
        return this.bintrayRequest(`${this.basePath}/versions`, this.auth, {
            name: version
        }, this.cancellationToken);
    }
    deleteVersion(version) {
        return this.bintrayRequest(`${this.basePath}/versions/${version}`, this.auth, null, this.cancellationToken, "DELETE");
    }
}
exports.BintrayClient = BintrayClient; //# sourceMappingURL=bintray.js.map

/***/ }),
/* 173 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.PrivateGitHubProvider = undefined;

var _bluebirdLst;

function _load_bluebirdLst() {
    return _bluebirdLst = __webpack_require__(2);
}

var _builderUtilRuntime;

function _load_builderUtilRuntime() {
    return _builderUtilRuntime = __webpack_require__(3);
}

var _jsYaml;

function _load_jsYaml() {
    return _jsYaml = __webpack_require__(31);
}

var _path = _interopRequireWildcard(__webpack_require__(0));

var _url;

function _load_url() {
    return _url = __webpack_require__(20);
}

var _GitHubProvider;

function _load_GitHubProvider() {
    return _GitHubProvider = __webpack_require__(60);
}

var _main;

function _load_main() {
    return _main = __webpack_require__(8);
}

var _Provider;

function _load_Provider() {
    return _Provider = __webpack_require__(14);
}

function _interopRequireWildcard(obj) {
    if (obj && obj.__esModule) {
        return obj;
    } else {
        var newObj = {};if (obj != null) {
            for (var key in obj) {
                if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key];
            }
        }newObj.default = obj;return newObj;
    }
}

class PrivateGitHubProvider extends (_GitHubProvider || _load_GitHubProvider()).BaseGitHubProvider {
    constructor(options, token, executor) {
        super(options, "api.github.com", executor);
        this.token = token;
    }
    createRequestOptions(url, headers) {
        const result = super.createRequestOptions(url, headers);
        result.redirect = "manual";
        return result;
    }
    getLatestVersion() {
        var _this = this;

        return (0, (_bluebirdLst || _load_bluebirdLst()).coroutine)(function* () {
            const basePath = _this.basePath;
            const cancellationToken = new (_builderUtilRuntime || _load_builderUtilRuntime()).CancellationToken();
            const channelFile = (0, (_main || _load_main()).getChannelFilename)((0, (_main || _load_main()).getDefaultChannelName)());
            const releaseInfo = yield _this.getLatestVersionInfo(basePath, cancellationToken);
            const asset = releaseInfo.assets.find(function (it) {
                return it.name === channelFile;
            });
            if (asset == null) {
                // html_url must be always, but just to be sure
                throw (0, (_builderUtilRuntime || _load_builderUtilRuntime()).newError)(`Cannot find ${channelFile} in the release ${releaseInfo.html_url || releaseInfo.name}`, "ERR_UPDATER_CHANNEL_FILE_NOT_FOUND");
            }
            const url = new (_url || _load_url()).URL(asset.url);
            let result;
            try {
                result = (0, (_jsYaml || _load_jsYaml()).safeLoad)((yield _this.httpRequest(url, _this.configureHeaders("application/octet-stream"), cancellationToken)));
            } catch (e) {
                if (e instanceof (_builderUtilRuntime || _load_builderUtilRuntime()).HttpError && e.statusCode === 404) {
                    throw (0, (_builderUtilRuntime || _load_builderUtilRuntime()).newError)(`Cannot find ${channelFile} in the latest release artifacts (${url}): ${e.stack || e.message}`, "ERR_UPDATER_CHANNEL_FILE_NOT_FOUND");
                }
                throw e;
            }
            result.assets = releaseInfo.assets;
            return result;
        })();
    }
    get fileExtraDownloadHeaders() {
        return this.configureHeaders("application/octet-stream");
    }
    configureHeaders(accept) {
        return {
            Accept: accept,
            Authorization: `token ${this.token}`
        };
    }
    getLatestVersionInfo(basePath, cancellationToken) {
        var _this2 = this;

        return (0, (_bluebirdLst || _load_bluebirdLst()).coroutine)(function* () {
            const url = (0, (_main || _load_main()).newUrlFromBase)(`${basePath}/latest`, _this2.baseUrl);
            try {
                return JSON.parse((yield _this2.httpRequest(url, _this2.configureHeaders("application/vnd.github.v3+json"), cancellationToken)));
            } catch (e) {
                throw (0, (_builderUtilRuntime || _load_builderUtilRuntime()).newError)(`Unable to find latest version on GitHub (${url}), please ensure a production release exists: ${e.stack || e.message}`, "ERR_UPDATER_LATEST_VERSION_NOT_FOUND");
            }
        })();
    }
    get basePath() {
        return this.computeGithubBasePath(`/repos/${this.options.owner}/${this.options.repo}/releases`);
    }
    resolveFiles(updateInfo) {
        return (0, (_Provider || _load_Provider()).getFileList)(updateInfo).map(it => {
            const name = _path.posix.basename(it.url).replace(/ /g, "-");
            const asset = updateInfo.assets.find(it => it != null && it.name === name);
            if (asset == null) {
                throw (0, (_builderUtilRuntime || _load_builderUtilRuntime()).newError)(`Cannot find asset "${name}" in: ${JSON.stringify(updateInfo.assets, null, 2)}`, "ERR_UPDATER_ASSET_NOT_FOUND");
            }
            return {
                url: new (_url || _load_url()).URL(asset.url),
                info: it
            };
        });
    }
}
exports.PrivateGitHubProvider = PrivateGitHubProvider; //# sourceMappingURL=PrivateGitHubProvider.js.map

/***/ }),
/* 174 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.NsisUpdater = undefined;

var _bluebirdLst;

function _load_bluebirdLst() {
    return _bluebirdLst = __webpack_require__(2);
}

var _builderUtilRuntime;

function _load_builderUtilRuntime() {
    return _builderUtilRuntime = __webpack_require__(3);
}

var _child_process;

function _load_child_process() {
    return _child_process = __webpack_require__(34);
}

var _path = _interopRequireWildcard(__webpack_require__(0));

__webpack_require__(33);

var _BaseUpdater;

function _load_BaseUpdater() {
    return _BaseUpdater = __webpack_require__(61);
}

var _FileWithEmbeddedBlockMapDifferentialDownloader;

function _load_FileWithEmbeddedBlockMapDifferentialDownloader() {
    return _FileWithEmbeddedBlockMapDifferentialDownloader = __webpack_require__(62);
}

var _GenericDifferentialDownloader;

function _load_GenericDifferentialDownloader() {
    return _GenericDifferentialDownloader = __webpack_require__(179);
}

var _main;

function _load_main() {
    return _main = __webpack_require__(8);
}

var _Provider;

function _load_Provider() {
    return _Provider = __webpack_require__(14);
}

var _windowsExecutableCodeSignatureVerifier;

function _load_windowsExecutableCodeSignatureVerifier() {
    return _windowsExecutableCodeSignatureVerifier = __webpack_require__(180);
}

function _interopRequireWildcard(obj) {
    if (obj && obj.__esModule) {
        return obj;
    } else {
        var newObj = {};if (obj != null) {
            for (var key in obj) {
                if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key];
            }
        }newObj.default = obj;return newObj;
    }
}

class NsisUpdater extends (_BaseUpdater || _load_BaseUpdater()).BaseUpdater {
    constructor(options, app) {
        super(options, app);
    }
    /*** @private */
    doDownloadUpdate(updateInfo, cancellationToken) {
        var _this = this;

        return (0, (_bluebirdLst || _load_bluebirdLst()).coroutine)(function* () {
            const provider = yield _this.provider;
            const fileInfo = (0, (_Provider || _load_Provider()).findFile)(provider.resolveFiles(updateInfo), "exe");
            const requestHeaders = yield _this.computeRequestHeaders();
            const downloadOptions = {
                skipDirCreation: true,
                headers: requestHeaders,
                cancellationToken,
                sha512: fileInfo.info.sha512
            };
            let packagePath = _this.downloadedUpdateHelper.packagePath;
            let installerPath = _this.downloadedUpdateHelper.getDownloadedFile(updateInfo, fileInfo);
            if (installerPath != null) {
                return packagePath == null ? [installerPath] : [installerPath, packagePath];
            }
            yield _this.executeDownload(downloadOptions, fileInfo, (() => {
                var _ref = (0, (_bluebirdLst || _load_bluebirdLst()).coroutine)(function* (tempDir, destinationFile, removeTempDirIfAny) {
                    installerPath = destinationFile;
                    if (yield _this.differentialDownloadInstaller(fileInfo, "OLD", installerPath, requestHeaders, provider)) {
                        yield _this.httpExecutor.download(fileInfo.url.href, installerPath, downloadOptions);
                    }
                    const signatureVerificationStatus = yield _this.verifySignature(installerPath);
                    if (signatureVerificationStatus != null) {
                        yield removeTempDirIfAny();
                        // noinspection ThrowInsideFinallyBlockJS
                        throw (0, (_builderUtilRuntime || _load_builderUtilRuntime()).newError)(`New version ${_this.updateInfo.version} is not signed by the application owner: ${signatureVerificationStatus}`, "ERR_UPDATER_INVALID_SIGNATURE");
                    }
                    const packageInfo = fileInfo.packageInfo;
                    if (packageInfo != null) {
                        packagePath = _path.join(tempDir, `package-${updateInfo.version}${_path.extname(packageInfo.path) || ".7z"}`);
                        if (yield _this.differentialDownloadWebPackage(packageInfo, packagePath, provider)) {
                            yield _this.httpExecutor.download(packageInfo.path, packagePath, {
                                skipDirCreation: true,
                                headers: requestHeaders,
                                cancellationToken,
                                sha512: packageInfo.sha512
                            });
                        }
                    }
                });

                return function (_x, _x2, _x3) {
                    return _ref.apply(this, arguments);
                };
            })());
            _this.downloadedUpdateHelper.setDownloadedFile(installerPath, packagePath, updateInfo, fileInfo);
            _this.addQuitHandler();
            _this.emit((_main || _load_main()).UPDATE_DOWNLOADED, _this.updateInfo);
            return packagePath == null ? [installerPath] : [installerPath, packagePath];
        })();
    }
    // $certificateInfo = (Get-AuthenticodeSignature 'xxx\yyy.exe'
    // | where {$_.Status.Equals([System.Management.Automation.SignatureStatus]::Valid) -and $_.SignerCertificate.Subject.Contains("CN=siemens.com")})
    // | Out-String ; if ($certificateInfo) { exit 0 } else { exit 1 }
    verifySignature(tempUpdateFile) {
        var _this2 = this;

        return (0, (_bluebirdLst || _load_bluebirdLst()).coroutine)(function* () {
            let publisherName;
            try {
                publisherName = (yield _this2.configOnDisk.value).publisherName;
                if (publisherName == null) {
                    return null;
                }
            } catch (e) {
                if (e.code === "ENOENT") {
                    // no app-update.yml
                    return null;
                }
                throw e;
            }
            return yield (0, (_windowsExecutableCodeSignatureVerifier || _load_windowsExecutableCodeSignatureVerifier()).verifySignature)(Array.isArray(publisherName) ? publisherName : [publisherName], tempUpdateFile, _this2._logger);
        })();
    }
    doInstall(installerPath, isSilent, isForceRunAfter) {
        const args = ["--updated"];
        if (isSilent) {
            args.push("/S");
        }
        if (isForceRunAfter) {
            args.push("--force-run");
        }
        const packagePath = this.downloadedUpdateHelper.packagePath;
        if (packagePath != null) {
            // only = form is supported
            args.push(`--package-file=${packagePath}`);
        }
        const spawnOptions = {
            detached: true,
            stdio: "ignore"
        };
        try {
            (0, (_child_process || _load_child_process()).spawn)(installerPath, args, spawnOptions).unref();
        } catch (e) {
            // yes, such errors dispatched not as error event
            // https://github.com/electron-userland/electron-builder/issues/1129
            if (e.code === "UNKNOWN" || e.code === "EACCES") {
                this._logger.info("Access denied or UNKNOWN error code on spawn, will be executed again using elevate");
                try {
                    (0, (_child_process || _load_child_process()).spawn)(_path.join(process.resourcesPath, "elevate.exe"), [installerPath].concat(args), spawnOptions).unref();
                } catch (e) {
                    this.dispatchError(e);
                }
            } else {
                this.dispatchError(e);
            }
        }
        return true;
    }
    differentialDownloadInstaller(fileInfo, oldFile, installerPath, requestHeaders, provider) {
        var _this3 = this;

        return (0, (_bluebirdLst || _load_bluebirdLst()).coroutine)(function* () {
            if (process.env.__NSIS_DIFFERENTIAL_UPDATE__ == null) {
                return true;
            }
            try {
                const blockMapData = JSON.parse((yield provider.httpRequest((0, (_main || _load_main()).newUrlFromBase)(`${fileInfo.url.pathname}.blockMap.json`, fileInfo.url))));
                yield new (_GenericDifferentialDownloader || _load_GenericDifferentialDownloader()).GenericDifferentialDownloader(fileInfo.info, _this3.httpExecutor, {
                    newUrl: fileInfo.url.href,
                    oldFile,
                    logger: _this3._logger,
                    newFile: installerPath,
                    useMultipleRangeRequest: provider.useMultipleRangeRequest,
                    requestHeaders
                }).download(blockMapData);
            } catch (e) {
                _this3._logger.error(`Cannot download differentially, fallback to full download: ${e.stack || e}`);
                // during test (developer machine mac) we must throw error
                return process.platform === "win32";
            }
            return false;
        })();
    }
    differentialDownloadWebPackage(packageInfo, packagePath, provider) {
        var _this4 = this;

        return (0, (_bluebirdLst || _load_bluebirdLst()).coroutine)(function* () {
            if (packageInfo.blockMapSize == null) {
                return true;
            }
            try {
                yield new (_FileWithEmbeddedBlockMapDifferentialDownloader || _load_FileWithEmbeddedBlockMapDifferentialDownloader()).FileWithEmbeddedBlockMapDifferentialDownloader(packageInfo, _this4.httpExecutor, {
                    newUrl: packageInfo.path,
                    oldFile: _path.join(process.resourcesPath, "..", "package.7z"),
                    logger: _this4._logger,
                    newFile: packagePath,
                    requestHeaders: _this4.requestHeaders,
                    useMultipleRangeRequest: provider.useMultipleRangeRequest
                }).download();
            } catch (e) {
                _this4._logger.error(`Cannot download differentially, fallback to full download: ${e.stack || e}`);
                // during test (developer machine mac or linux) we must throw error
                return process.platform === "win32";
            }
            return false;
        })();
    }
}
exports.NsisUpdater = NsisUpdater; //# sourceMappingURL=NsisUpdater.js.map

/***/ }),
/* 175 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.DownloadedUpdateHelper = undefined;

var _lodash;

function _load_lodash() {
    return _lodash = _interopRequireDefault(__webpack_require__(176));
}

function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
}

/** @private **/
class DownloadedUpdateHelper {
    get file() {
        return this.setupPath;
    }
    get packagePath() {
        return this._packagePath;
    }
    getDownloadedFile(versionInfo, fileInfo) {
        if (this.setupPath == null) {
            return null;
        }
        return (0, (_lodash || _load_lodash()).default)(this.versionInfo, versionInfo) && (0, (_lodash || _load_lodash()).default)(this.fileInfo, fileInfo) ? this.setupPath : null;
    }
    setDownloadedFile(file, packagePath, versionInfo, fileInfo) {
        this.setupPath = file;
        this._packagePath = packagePath;
        this.versionInfo = versionInfo;
        this.fileInfo = fileInfo;
    }
    clear() {
        this.setupPath = null;
        this._packagePath = null;
        this.versionInfo = null;
        this.fileInfo = null;
    }
}
exports.DownloadedUpdateHelper = DownloadedUpdateHelper; //# sourceMappingURL=DownloadedUpdateHelper.js.map

/***/ }),
/* 176 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(module) {

/**
 * Lodash (Custom Build) <https://lodash.com/>
 * Build: `lodash modularize exports="npm" -o ./`
 * Copyright JS Foundation and other contributors <https://js.foundation/>
 * Released under MIT license <https://lodash.com/license>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 */

/** Used as the size to enable large array optimizations. */
var LARGE_ARRAY_SIZE = 200;

/** Used to stand-in for `undefined` hash values. */
var HASH_UNDEFINED = '__lodash_hash_undefined__';

/** Used to compose bitmasks for value comparisons. */
var COMPARE_PARTIAL_FLAG = 1,
    COMPARE_UNORDERED_FLAG = 2;

/** Used as references for various `Number` constants. */
var MAX_SAFE_INTEGER = 9007199254740991;

/** `Object#toString` result references. */
var argsTag = '[object Arguments]',
    arrayTag = '[object Array]',
    asyncTag = '[object AsyncFunction]',
    boolTag = '[object Boolean]',
    dateTag = '[object Date]',
    errorTag = '[object Error]',
    funcTag = '[object Function]',
    genTag = '[object GeneratorFunction]',
    mapTag = '[object Map]',
    numberTag = '[object Number]',
    nullTag = '[object Null]',
    objectTag = '[object Object]',
    promiseTag = '[object Promise]',
    proxyTag = '[object Proxy]',
    regexpTag = '[object RegExp]',
    setTag = '[object Set]',
    stringTag = '[object String]',
    symbolTag = '[object Symbol]',
    undefinedTag = '[object Undefined]',
    weakMapTag = '[object WeakMap]';

var arrayBufferTag = '[object ArrayBuffer]',
    dataViewTag = '[object DataView]',
    float32Tag = '[object Float32Array]',
    float64Tag = '[object Float64Array]',
    int8Tag = '[object Int8Array]',
    int16Tag = '[object Int16Array]',
    int32Tag = '[object Int32Array]',
    uint8Tag = '[object Uint8Array]',
    uint8ClampedTag = '[object Uint8ClampedArray]',
    uint16Tag = '[object Uint16Array]',
    uint32Tag = '[object Uint32Array]';

/**
 * Used to match `RegExp`
 * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).
 */
var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;

/** Used to detect host constructors (Safari). */
var reIsHostCtor = /^\[object .+?Constructor\]$/;

/** Used to detect unsigned integer values. */
var reIsUint = /^(?:0|[1-9]\d*)$/;

/** Used to identify `toStringTag` values of typed arrays. */
var typedArrayTags = {};
typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;
typedArrayTags[argsTag] = typedArrayTags[arrayTag] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] = typedArrayTags[dataViewTag] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag] = typedArrayTags[mapTag] = typedArrayTags[numberTag] = typedArrayTags[objectTag] = typedArrayTags[regexpTag] = typedArrayTags[setTag] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;

/** Detect free variable `global` from Node.js. */
var freeGlobal = typeof global == 'object' && global && global.Object === Object && global;

/** Detect free variable `self`. */
var freeSelf = typeof self == 'object' && self && self.Object === Object && self;

/** Used as a reference to the global object. */
var root = freeGlobal || freeSelf || Function('return this')();

/** Detect free variable `exports`. */
var freeExports = typeof exports == 'object' && exports && !exports.nodeType && exports;

/** Detect free variable `module`. */
var freeModule = freeExports && typeof module == 'object' && module && !module.nodeType && module;

/** Detect the popular CommonJS extension `module.exports`. */
var moduleExports = freeModule && freeModule.exports === freeExports;

/** Detect free variable `process` from Node.js. */
var freeProcess = moduleExports && freeGlobal.process;

/** Used to access faster Node.js helpers. */
var nodeUtil = function () {
  try {
    return freeProcess && freeProcess.binding && freeProcess.binding('util');
  } catch (e) {}
}();

/* Node.js helper references. */
var nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;

/**
 * A specialized version of `_.filter` for arrays without support for
 * iteratee shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} predicate The function invoked per iteration.
 * @returns {Array} Returns the new filtered array.
 */
function arrayFilter(array, predicate) {
  var index = -1,
      length = array == null ? 0 : array.length,
      resIndex = 0,
      result = [];

  while (++index < length) {
    var value = array[index];
    if (predicate(value, index, array)) {
      result[resIndex++] = value;
    }
  }
  return result;
}

/**
 * Appends the elements of `values` to `array`.
 *
 * @private
 * @param {Array} array The array to modify.
 * @param {Array} values The values to append.
 * @returns {Array} Returns `array`.
 */
function arrayPush(array, values) {
  var index = -1,
      length = values.length,
      offset = array.length;

  while (++index < length) {
    array[offset + index] = values[index];
  }
  return array;
}

/**
 * A specialized version of `_.some` for arrays without support for iteratee
 * shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} predicate The function invoked per iteration.
 * @returns {boolean} Returns `true` if any element passes the predicate check,
 *  else `false`.
 */
function arraySome(array, predicate) {
  var index = -1,
      length = array == null ? 0 : array.length;

  while (++index < length) {
    if (predicate(array[index], index, array)) {
      return true;
    }
  }
  return false;
}

/**
 * The base implementation of `_.times` without support for iteratee shorthands
 * or max array length checks.
 *
 * @private
 * @param {number} n The number of times to invoke `iteratee`.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns the array of results.
 */
function baseTimes(n, iteratee) {
  var index = -1,
      result = Array(n);

  while (++index < n) {
    result[index] = iteratee(index);
  }
  return result;
}

/**
 * The base implementation of `_.unary` without support for storing metadata.
 *
 * @private
 * @param {Function} func The function to cap arguments for.
 * @returns {Function} Returns the new capped function.
 */
function baseUnary(func) {
  return function (value) {
    return func(value);
  };
}

/**
 * Checks if a `cache` value for `key` exists.
 *
 * @private
 * @param {Object} cache The cache to query.
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function cacheHas(cache, key) {
  return cache.has(key);
}

/**
 * Gets the value at `key` of `object`.
 *
 * @private
 * @param {Object} [object] The object to query.
 * @param {string} key The key of the property to get.
 * @returns {*} Returns the property value.
 */
function getValue(object, key) {
  return object == null ? undefined : object[key];
}

/**
 * Converts `map` to its key-value pairs.
 *
 * @private
 * @param {Object} map The map to convert.
 * @returns {Array} Returns the key-value pairs.
 */
function mapToArray(map) {
  var index = -1,
      result = Array(map.size);

  map.forEach(function (value, key) {
    result[++index] = [key, value];
  });
  return result;
}

/**
 * Creates a unary function that invokes `func` with its argument transformed.
 *
 * @private
 * @param {Function} func The function to wrap.
 * @param {Function} transform The argument transform.
 * @returns {Function} Returns the new function.
 */
function overArg(func, transform) {
  return function (arg) {
    return func(transform(arg));
  };
}

/**
 * Converts `set` to an array of its values.
 *
 * @private
 * @param {Object} set The set to convert.
 * @returns {Array} Returns the values.
 */
function setToArray(set) {
  var index = -1,
      result = Array(set.size);

  set.forEach(function (value) {
    result[++index] = value;
  });
  return result;
}

/** Used for built-in method references. */
var arrayProto = Array.prototype,
    funcProto = Function.prototype,
    objectProto = Object.prototype;

/** Used to detect overreaching core-js shims. */
var coreJsData = root['__core-js_shared__'];

/** Used to resolve the decompiled source of functions. */
var funcToString = funcProto.toString;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/** Used to detect methods masquerading as native. */
var maskSrcKey = function () {
  var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');
  return uid ? 'Symbol(src)_1.' + uid : '';
}();

/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */
var nativeObjectToString = objectProto.toString;

/** Used to detect if a method is native. */
var reIsNative = RegExp('^' + funcToString.call(hasOwnProperty).replace(reRegExpChar, '\\$&').replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$');

/** Built-in value references. */
var Buffer = moduleExports ? root.Buffer : undefined,
    Symbol = root.Symbol,
    Uint8Array = root.Uint8Array,
    propertyIsEnumerable = objectProto.propertyIsEnumerable,
    splice = arrayProto.splice,
    symToStringTag = Symbol ? Symbol.toStringTag : undefined;

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeGetSymbols = Object.getOwnPropertySymbols,
    nativeIsBuffer = Buffer ? Buffer.isBuffer : undefined,
    nativeKeys = overArg(Object.keys, Object);

/* Built-in method references that are verified to be native. */
var DataView = getNative(root, 'DataView'),
    Map = getNative(root, 'Map'),
    Promise = getNative(root, 'Promise'),
    Set = getNative(root, 'Set'),
    WeakMap = getNative(root, 'WeakMap'),
    nativeCreate = getNative(Object, 'create');

/** Used to detect maps, sets, and weakmaps. */
var dataViewCtorString = toSource(DataView),
    mapCtorString = toSource(Map),
    promiseCtorString = toSource(Promise),
    setCtorString = toSource(Set),
    weakMapCtorString = toSource(WeakMap);

/** Used to convert symbols to primitives and strings. */
var symbolProto = Symbol ? Symbol.prototype : undefined,
    symbolValueOf = symbolProto ? symbolProto.valueOf : undefined;

/**
 * Creates a hash object.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function Hash(entries) {
  var index = -1,
      length = entries == null ? 0 : entries.length;

  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}

/**
 * Removes all key-value entries from the hash.
 *
 * @private
 * @name clear
 * @memberOf Hash
 */
function hashClear() {
  this.__data__ = nativeCreate ? nativeCreate(null) : {};
  this.size = 0;
}

/**
 * Removes `key` and its value from the hash.
 *
 * @private
 * @name delete
 * @memberOf Hash
 * @param {Object} hash The hash to modify.
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function hashDelete(key) {
  var result = this.has(key) && delete this.__data__[key];
  this.size -= result ? 1 : 0;
  return result;
}

/**
 * Gets the hash value for `key`.
 *
 * @private
 * @name get
 * @memberOf Hash
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function hashGet(key) {
  var data = this.__data__;
  if (nativeCreate) {
    var result = data[key];
    return result === HASH_UNDEFINED ? undefined : result;
  }
  return hasOwnProperty.call(data, key) ? data[key] : undefined;
}

/**
 * Checks if a hash value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf Hash
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function hashHas(key) {
  var data = this.__data__;
  return nativeCreate ? data[key] !== undefined : hasOwnProperty.call(data, key);
}

/**
 * Sets the hash `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf Hash
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the hash instance.
 */
function hashSet(key, value) {
  var data = this.__data__;
  this.size += this.has(key) ? 0 : 1;
  data[key] = nativeCreate && value === undefined ? HASH_UNDEFINED : value;
  return this;
}

// Add methods to `Hash`.
Hash.prototype.clear = hashClear;
Hash.prototype['delete'] = hashDelete;
Hash.prototype.get = hashGet;
Hash.prototype.has = hashHas;
Hash.prototype.set = hashSet;

/**
 * Creates an list cache object.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function ListCache(entries) {
  var index = -1,
      length = entries == null ? 0 : entries.length;

  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}

/**
 * Removes all key-value entries from the list cache.
 *
 * @private
 * @name clear
 * @memberOf ListCache
 */
function listCacheClear() {
  this.__data__ = [];
  this.size = 0;
}

/**
 * Removes `key` and its value from the list cache.
 *
 * @private
 * @name delete
 * @memberOf ListCache
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function listCacheDelete(key) {
  var data = this.__data__,
      index = assocIndexOf(data, key);

  if (index < 0) {
    return false;
  }
  var lastIndex = data.length - 1;
  if (index == lastIndex) {
    data.pop();
  } else {
    splice.call(data, index, 1);
  }
  --this.size;
  return true;
}

/**
 * Gets the list cache value for `key`.
 *
 * @private
 * @name get
 * @memberOf ListCache
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function listCacheGet(key) {
  var data = this.__data__,
      index = assocIndexOf(data, key);

  return index < 0 ? undefined : data[index][1];
}

/**
 * Checks if a list cache value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf ListCache
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function listCacheHas(key) {
  return assocIndexOf(this.__data__, key) > -1;
}

/**
 * Sets the list cache `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf ListCache
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the list cache instance.
 */
function listCacheSet(key, value) {
  var data = this.__data__,
      index = assocIndexOf(data, key);

  if (index < 0) {
    ++this.size;
    data.push([key, value]);
  } else {
    data[index][1] = value;
  }
  return this;
}

// Add methods to `ListCache`.
ListCache.prototype.clear = listCacheClear;
ListCache.prototype['delete'] = listCacheDelete;
ListCache.prototype.get = listCacheGet;
ListCache.prototype.has = listCacheHas;
ListCache.prototype.set = listCacheSet;

/**
 * Creates a map cache object to store key-value pairs.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function MapCache(entries) {
  var index = -1,
      length = entries == null ? 0 : entries.length;

  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}

/**
 * Removes all key-value entries from the map.
 *
 * @private
 * @name clear
 * @memberOf MapCache
 */
function mapCacheClear() {
  this.size = 0;
  this.__data__ = {
    'hash': new Hash(),
    'map': new (Map || ListCache)(),
    'string': new Hash()
  };
}

/**
 * Removes `key` and its value from the map.
 *
 * @private
 * @name delete
 * @memberOf MapCache
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function mapCacheDelete(key) {
  var result = getMapData(this, key)['delete'](key);
  this.size -= result ? 1 : 0;
  return result;
}

/**
 * Gets the map value for `key`.
 *
 * @private
 * @name get
 * @memberOf MapCache
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function mapCacheGet(key) {
  return getMapData(this, key).get(key);
}

/**
 * Checks if a map value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf MapCache
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function mapCacheHas(key) {
  return getMapData(this, key).has(key);
}

/**
 * Sets the map `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf MapCache
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the map cache instance.
 */
function mapCacheSet(key, value) {
  var data = getMapData(this, key),
      size = data.size;

  data.set(key, value);
  this.size += data.size == size ? 0 : 1;
  return this;
}

// Add methods to `MapCache`.
MapCache.prototype.clear = mapCacheClear;
MapCache.prototype['delete'] = mapCacheDelete;
MapCache.prototype.get = mapCacheGet;
MapCache.prototype.has = mapCacheHas;
MapCache.prototype.set = mapCacheSet;

/**
 *
 * Creates an array cache object to store unique values.
 *
 * @private
 * @constructor
 * @param {Array} [values] The values to cache.
 */
function SetCache(values) {
  var index = -1,
      length = values == null ? 0 : values.length;

  this.__data__ = new MapCache();
  while (++index < length) {
    this.add(values[index]);
  }
}

/**
 * Adds `value` to the array cache.
 *
 * @private
 * @name add
 * @memberOf SetCache
 * @alias push
 * @param {*} value The value to cache.
 * @returns {Object} Returns the cache instance.
 */
function setCacheAdd(value) {
  this.__data__.set(value, HASH_UNDEFINED);
  return this;
}

/**
 * Checks if `value` is in the array cache.
 *
 * @private
 * @name has
 * @memberOf SetCache
 * @param {*} value The value to search for.
 * @returns {number} Returns `true` if `value` is found, else `false`.
 */
function setCacheHas(value) {
  return this.__data__.has(value);
}

// Add methods to `SetCache`.
SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
SetCache.prototype.has = setCacheHas;

/**
 * Creates a stack cache object to store key-value pairs.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function Stack(entries) {
  var data = this.__data__ = new ListCache(entries);
  this.size = data.size;
}

/**
 * Removes all key-value entries from the stack.
 *
 * @private
 * @name clear
 * @memberOf Stack
 */
function stackClear() {
  this.__data__ = new ListCache();
  this.size = 0;
}

/**
 * Removes `key` and its value from the stack.
 *
 * @private
 * @name delete
 * @memberOf Stack
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function stackDelete(key) {
  var data = this.__data__,
      result = data['delete'](key);

  this.size = data.size;
  return result;
}

/**
 * Gets the stack value for `key`.
 *
 * @private
 * @name get
 * @memberOf Stack
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function stackGet(key) {
  return this.__data__.get(key);
}

/**
 * Checks if a stack value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf Stack
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function stackHas(key) {
  return this.__data__.has(key);
}

/**
 * Sets the stack `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf Stack
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the stack cache instance.
 */
function stackSet(key, value) {
  var data = this.__data__;
  if (data instanceof ListCache) {
    var pairs = data.__data__;
    if (!Map || pairs.length < LARGE_ARRAY_SIZE - 1) {
      pairs.push([key, value]);
      this.size = ++data.size;
      return this;
    }
    data = this.__data__ = new MapCache(pairs);
  }
  data.set(key, value);
  this.size = data.size;
  return this;
}

// Add methods to `Stack`.
Stack.prototype.clear = stackClear;
Stack.prototype['delete'] = stackDelete;
Stack.prototype.get = stackGet;
Stack.prototype.has = stackHas;
Stack.prototype.set = stackSet;

/**
 * Creates an array of the enumerable property names of the array-like `value`.
 *
 * @private
 * @param {*} value The value to query.
 * @param {boolean} inherited Specify returning inherited property names.
 * @returns {Array} Returns the array of property names.
 */
function arrayLikeKeys(value, inherited) {
  var isArr = isArray(value),
      isArg = !isArr && isArguments(value),
      isBuff = !isArr && !isArg && isBuffer(value),
      isType = !isArr && !isArg && !isBuff && isTypedArray(value),
      skipIndexes = isArr || isArg || isBuff || isType,
      result = skipIndexes ? baseTimes(value.length, String) : [],
      length = result.length;

  for (var key in value) {
    if ((inherited || hasOwnProperty.call(value, key)) && !(skipIndexes && (
    // Safari 9 has enumerable `arguments.length` in strict mode.
    key == 'length' ||
    // Node.js 0.10 has enumerable non-index properties on buffers.
    isBuff && (key == 'offset' || key == 'parent') ||
    // PhantomJS 2 has enumerable non-index properties on typed arrays.
    isType && (key == 'buffer' || key == 'byteLength' || key == 'byteOffset') ||
    // Skip index properties.
    isIndex(key, length)))) {
      result.push(key);
    }
  }
  return result;
}

/**
 * Gets the index at which the `key` is found in `array` of key-value pairs.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {*} key The key to search for.
 * @returns {number} Returns the index of the matched value, else `-1`.
 */
function assocIndexOf(array, key) {
  var length = array.length;
  while (length--) {
    if (eq(array[length][0], key)) {
      return length;
    }
  }
  return -1;
}

/**
 * The base implementation of `getAllKeys` and `getAllKeysIn` which uses
 * `keysFunc` and `symbolsFunc` to get the enumerable property names and
 * symbols of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {Function} keysFunc The function to get the keys of `object`.
 * @param {Function} symbolsFunc The function to get the symbols of `object`.
 * @returns {Array} Returns the array of property names and symbols.
 */
function baseGetAllKeys(object, keysFunc, symbolsFunc) {
  var result = keysFunc(object);
  return isArray(object) ? result : arrayPush(result, symbolsFunc(object));
}

/**
 * The base implementation of `getTag` without fallbacks for buggy environments.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the `toStringTag`.
 */
function baseGetTag(value) {
  if (value == null) {
    return value === undefined ? undefinedTag : nullTag;
  }
  return symToStringTag && symToStringTag in Object(value) ? getRawTag(value) : objectToString(value);
}

/**
 * The base implementation of `_.isArguments`.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an `arguments` object,
 */
function baseIsArguments(value) {
  return isObjectLike(value) && baseGetTag(value) == argsTag;
}

/**
 * The base implementation of `_.isEqual` which supports partial comparisons
 * and tracks traversed objects.
 *
 * @private
 * @param {*} value The value to compare.
 * @param {*} other The other value to compare.
 * @param {boolean} bitmask The bitmask flags.
 *  1 - Unordered comparison
 *  2 - Partial comparison
 * @param {Function} [customizer] The function to customize comparisons.
 * @param {Object} [stack] Tracks traversed `value` and `other` objects.
 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
 */
function baseIsEqual(value, other, bitmask, customizer, stack) {
  if (value === other) {
    return true;
  }
  if (value == null || other == null || !isObjectLike(value) && !isObjectLike(other)) {
    return value !== value && other !== other;
  }
  return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack);
}

/**
 * A specialized version of `baseIsEqual` for arrays and objects which performs
 * deep comparisons and tracks traversed objects enabling objects with circular
 * references to be compared.
 *
 * @private
 * @param {Object} object The object to compare.
 * @param {Object} other The other object to compare.
 * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
 * @param {Function} customizer The function to customize comparisons.
 * @param {Function} equalFunc The function to determine equivalents of values.
 * @param {Object} [stack] Tracks traversed `object` and `other` objects.
 * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
 */
function baseIsEqualDeep(object, other, bitmask, customizer, equalFunc, stack) {
  var objIsArr = isArray(object),
      othIsArr = isArray(other),
      objTag = objIsArr ? arrayTag : getTag(object),
      othTag = othIsArr ? arrayTag : getTag(other);

  objTag = objTag == argsTag ? objectTag : objTag;
  othTag = othTag == argsTag ? objectTag : othTag;

  var objIsObj = objTag == objectTag,
      othIsObj = othTag == objectTag,
      isSameTag = objTag == othTag;

  if (isSameTag && isBuffer(object)) {
    if (!isBuffer(other)) {
      return false;
    }
    objIsArr = true;
    objIsObj = false;
  }
  if (isSameTag && !objIsObj) {
    stack || (stack = new Stack());
    return objIsArr || isTypedArray(object) ? equalArrays(object, other, bitmask, customizer, equalFunc, stack) : equalByTag(object, other, objTag, bitmask, customizer, equalFunc, stack);
  }
  if (!(bitmask & COMPARE_PARTIAL_FLAG)) {
    var objIsWrapped = objIsObj && hasOwnProperty.call(object, '__wrapped__'),
        othIsWrapped = othIsObj && hasOwnProperty.call(other, '__wrapped__');

    if (objIsWrapped || othIsWrapped) {
      var objUnwrapped = objIsWrapped ? object.value() : object,
          othUnwrapped = othIsWrapped ? other.value() : other;

      stack || (stack = new Stack());
      return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);
    }
  }
  if (!isSameTag) {
    return false;
  }
  stack || (stack = new Stack());
  return equalObjects(object, other, bitmask, customizer, equalFunc, stack);
}

/**
 * The base implementation of `_.isNative` without bad shim checks.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a native function,
 *  else `false`.
 */
function baseIsNative(value) {
  if (!isObject(value) || isMasked(value)) {
    return false;
  }
  var pattern = isFunction(value) ? reIsNative : reIsHostCtor;
  return pattern.test(toSource(value));
}

/**
 * The base implementation of `_.isTypedArray` without Node.js optimizations.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
 */
function baseIsTypedArray(value) {
  return isObjectLike(value) && isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
}

/**
 * The base implementation of `_.keys` which doesn't treat sparse arrays as dense.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 */
function baseKeys(object) {
  if (!isPrototype(object)) {
    return nativeKeys(object);
  }
  var result = [];
  for (var key in Object(object)) {
    if (hasOwnProperty.call(object, key) && key != 'constructor') {
      result.push(key);
    }
  }
  return result;
}

/**
 * A specialized version of `baseIsEqualDeep` for arrays with support for
 * partial deep comparisons.
 *
 * @private
 * @param {Array} array The array to compare.
 * @param {Array} other The other array to compare.
 * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
 * @param {Function} customizer The function to customize comparisons.
 * @param {Function} equalFunc The function to determine equivalents of values.
 * @param {Object} stack Tracks traversed `array` and `other` objects.
 * @returns {boolean} Returns `true` if the arrays are equivalent, else `false`.
 */
function equalArrays(array, other, bitmask, customizer, equalFunc, stack) {
  var isPartial = bitmask & COMPARE_PARTIAL_FLAG,
      arrLength = array.length,
      othLength = other.length;

  if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
    return false;
  }
  // Assume cyclic values are equal.
  var stacked = stack.get(array);
  if (stacked && stack.get(other)) {
    return stacked == other;
  }
  var index = -1,
      result = true,
      seen = bitmask & COMPARE_UNORDERED_FLAG ? new SetCache() : undefined;

  stack.set(array, other);
  stack.set(other, array);

  // Ignore non-index properties.
  while (++index < arrLength) {
    var arrValue = array[index],
        othValue = other[index];

    if (customizer) {
      var compared = isPartial ? customizer(othValue, arrValue, index, other, array, stack) : customizer(arrValue, othValue, index, array, other, stack);
    }
    if (compared !== undefined) {
      if (compared) {
        continue;
      }
      result = false;
      break;
    }
    // Recursively compare arrays (susceptible to call stack limits).
    if (seen) {
      if (!arraySome(other, function (othValue, othIndex) {
        if (!cacheHas(seen, othIndex) && (arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
          return seen.push(othIndex);
        }
      })) {
        result = false;
        break;
      }
    } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
      result = false;
      break;
    }
  }
  stack['delete'](array);
  stack['delete'](other);
  return result;
}

/**
 * A specialized version of `baseIsEqualDeep` for comparing objects of
 * the same `toStringTag`.
 *
 * **Note:** This function only supports comparing values with tags of
 * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.
 *
 * @private
 * @param {Object} object The object to compare.
 * @param {Object} other The other object to compare.
 * @param {string} tag The `toStringTag` of the objects to compare.
 * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
 * @param {Function} customizer The function to customize comparisons.
 * @param {Function} equalFunc The function to determine equivalents of values.
 * @param {Object} stack Tracks traversed `object` and `other` objects.
 * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
 */
function equalByTag(object, other, tag, bitmask, customizer, equalFunc, stack) {
  switch (tag) {
    case dataViewTag:
      if (object.byteLength != other.byteLength || object.byteOffset != other.byteOffset) {
        return false;
      }
      object = object.buffer;
      other = other.buffer;

    case arrayBufferTag:
      if (object.byteLength != other.byteLength || !equalFunc(new Uint8Array(object), new Uint8Array(other))) {
        return false;
      }
      return true;

    case boolTag:
    case dateTag:
    case numberTag:
      // Coerce booleans to `1` or `0` and dates to milliseconds.
      // Invalid dates are coerced to `NaN`.
      return eq(+object, +other);

    case errorTag:
      return object.name == other.name && object.message == other.message;

    case regexpTag:
    case stringTag:
      // Coerce regexes to strings and treat strings, primitives and objects,
      // as equal. See http://www.ecma-international.org/ecma-262/7.0/#sec-regexp.prototype.tostring
      // for more details.
      return object == other + '';

    case mapTag:
      var convert = mapToArray;

    case setTag:
      var isPartial = bitmask & COMPARE_PARTIAL_FLAG;
      convert || (convert = setToArray);

      if (object.size != other.size && !isPartial) {
        return false;
      }
      // Assume cyclic values are equal.
      var stacked = stack.get(object);
      if (stacked) {
        return stacked == other;
      }
      bitmask |= COMPARE_UNORDERED_FLAG;

      // Recursively compare objects (susceptible to call stack limits).
      stack.set(object, other);
      var result = equalArrays(convert(object), convert(other), bitmask, customizer, equalFunc, stack);
      stack['delete'](object);
      return result;

    case symbolTag:
      if (symbolValueOf) {
        return symbolValueOf.call(object) == symbolValueOf.call(other);
      }
  }
  return false;
}

/**
 * A specialized version of `baseIsEqualDeep` for objects with support for
 * partial deep comparisons.
 *
 * @private
 * @param {Object} object The object to compare.
 * @param {Object} other The other object to compare.
 * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
 * @param {Function} customizer The function to customize comparisons.
 * @param {Function} equalFunc The function to determine equivalents of values.
 * @param {Object} stack Tracks traversed `object` and `other` objects.
 * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
 */
function equalObjects(object, other, bitmask, customizer, equalFunc, stack) {
  var isPartial = bitmask & COMPARE_PARTIAL_FLAG,
      objProps = getAllKeys(object),
      objLength = objProps.length,
      othProps = getAllKeys(other),
      othLength = othProps.length;

  if (objLength != othLength && !isPartial) {
    return false;
  }
  var index = objLength;
  while (index--) {
    var key = objProps[index];
    if (!(isPartial ? key in other : hasOwnProperty.call(other, key))) {
      return false;
    }
  }
  // Assume cyclic values are equal.
  var stacked = stack.get(object);
  if (stacked && stack.get(other)) {
    return stacked == other;
  }
  var result = true;
  stack.set(object, other);
  stack.set(other, object);

  var skipCtor = isPartial;
  while (++index < objLength) {
    key = objProps[index];
    var objValue = object[key],
        othValue = other[key];

    if (customizer) {
      var compared = isPartial ? customizer(othValue, objValue, key, other, object, stack) : customizer(objValue, othValue, key, object, other, stack);
    }
    // Recursively compare objects (susceptible to call stack limits).
    if (!(compared === undefined ? objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack) : compared)) {
      result = false;
      break;
    }
    skipCtor || (skipCtor = key == 'constructor');
  }
  if (result && !skipCtor) {
    var objCtor = object.constructor,
        othCtor = other.constructor;

    // Non `Object` object instances with different constructors are not equal.
    if (objCtor != othCtor && 'constructor' in object && 'constructor' in other && !(typeof objCtor == 'function' && objCtor instanceof objCtor && typeof othCtor == 'function' && othCtor instanceof othCtor)) {
      result = false;
    }
  }
  stack['delete'](object);
  stack['delete'](other);
  return result;
}

/**
 * Creates an array of own enumerable property names and symbols of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names and symbols.
 */
function getAllKeys(object) {
  return baseGetAllKeys(object, keys, getSymbols);
}

/**
 * Gets the data for `map`.
 *
 * @private
 * @param {Object} map The map to query.
 * @param {string} key The reference key.
 * @returns {*} Returns the map data.
 */
function getMapData(map, key) {
  var data = map.__data__;
  return isKeyable(key) ? data[typeof key == 'string' ? 'string' : 'hash'] : data.map;
}

/**
 * Gets the native function at `key` of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {string} key The key of the method to get.
 * @returns {*} Returns the function if it's native, else `undefined`.
 */
function getNative(object, key) {
  var value = getValue(object, key);
  return baseIsNative(value) ? value : undefined;
}

/**
 * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the raw `toStringTag`.
 */
function getRawTag(value) {
  var isOwn = hasOwnProperty.call(value, symToStringTag),
      tag = value[symToStringTag];

  try {
    value[symToStringTag] = undefined;
    var unmasked = true;
  } catch (e) {}

  var result = nativeObjectToString.call(value);
  if (unmasked) {
    if (isOwn) {
      value[symToStringTag] = tag;
    } else {
      delete value[symToStringTag];
    }
  }
  return result;
}

/**
 * Creates an array of the own enumerable symbols of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of symbols.
 */
var getSymbols = !nativeGetSymbols ? stubArray : function (object) {
  if (object == null) {
    return [];
  }
  object = Object(object);
  return arrayFilter(nativeGetSymbols(object), function (symbol) {
    return propertyIsEnumerable.call(object, symbol);
  });
};

/**
 * Gets the `toStringTag` of `value`.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the `toStringTag`.
 */
var getTag = baseGetTag;

// Fallback for data views, maps, sets, and weak maps in IE 11 and promises in Node.js < 6.
if (DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag || Map && getTag(new Map()) != mapTag || Promise && getTag(Promise.resolve()) != promiseTag || Set && getTag(new Set()) != setTag || WeakMap && getTag(new WeakMap()) != weakMapTag) {
  getTag = function (value) {
    var result = baseGetTag(value),
        Ctor = result == objectTag ? value.constructor : undefined,
        ctorString = Ctor ? toSource(Ctor) : '';

    if (ctorString) {
      switch (ctorString) {
        case dataViewCtorString:
          return dataViewTag;
        case mapCtorString:
          return mapTag;
        case promiseCtorString:
          return promiseTag;
        case setCtorString:
          return setTag;
        case weakMapCtorString:
          return weakMapTag;
      }
    }
    return result;
  };
}

/**
 * Checks if `value` is a valid array-like index.
 *
 * @private
 * @param {*} value The value to check.
 * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
 * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
 */
function isIndex(value, length) {
  length = length == null ? MAX_SAFE_INTEGER : length;
  return !!length && (typeof value == 'number' || reIsUint.test(value)) && value > -1 && value % 1 == 0 && value < length;
}

/**
 * Checks if `value` is suitable for use as unique object key.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is suitable, else `false`.
 */
function isKeyable(value) {
  var type = typeof value;
  return type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean' ? value !== '__proto__' : value === null;
}

/**
 * Checks if `func` has its source masked.
 *
 * @private
 * @param {Function} func The function to check.
 * @returns {boolean} Returns `true` if `func` is masked, else `false`.
 */
function isMasked(func) {
  return !!maskSrcKey && maskSrcKey in func;
}

/**
 * Checks if `value` is likely a prototype object.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.
 */
function isPrototype(value) {
  var Ctor = value && value.constructor,
      proto = typeof Ctor == 'function' && Ctor.prototype || objectProto;

  return value === proto;
}

/**
 * Converts `value` to a string using `Object.prototype.toString`.
 *
 * @private
 * @param {*} value The value to convert.
 * @returns {string} Returns the converted string.
 */
function objectToString(value) {
  return nativeObjectToString.call(value);
}

/**
 * Converts `func` to its source code.
 *
 * @private
 * @param {Function} func The function to convert.
 * @returns {string} Returns the source code.
 */
function toSource(func) {
  if (func != null) {
    try {
      return funcToString.call(func);
    } catch (e) {}
    try {
      return func + '';
    } catch (e) {}
  }
  return '';
}

/**
 * Performs a
 * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * comparison between two values to determine if they are equivalent.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to compare.
 * @param {*} other The other value to compare.
 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
 * @example
 *
 * var object = { 'a': 1 };
 * var other = { 'a': 1 };
 *
 * _.eq(object, object);
 * // => true
 *
 * _.eq(object, other);
 * // => false
 *
 * _.eq('a', 'a');
 * // => true
 *
 * _.eq('a', Object('a'));
 * // => false
 *
 * _.eq(NaN, NaN);
 * // => true
 */
function eq(value, other) {
  return value === other || value !== value && other !== other;
}

/**
 * Checks if `value` is likely an `arguments` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an `arguments` object,
 *  else `false`.
 * @example
 *
 * _.isArguments(function() { return arguments; }());
 * // => true
 *
 * _.isArguments([1, 2, 3]);
 * // => false
 */
var isArguments = baseIsArguments(function () {
  return arguments;
}()) ? baseIsArguments : function (value) {
  return isObjectLike(value) && hasOwnProperty.call(value, 'callee') && !propertyIsEnumerable.call(value, 'callee');
};

/**
 * Checks if `value` is classified as an `Array` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an array, else `false`.
 * @example
 *
 * _.isArray([1, 2, 3]);
 * // => true
 *
 * _.isArray(document.body.children);
 * // => false
 *
 * _.isArray('abc');
 * // => false
 *
 * _.isArray(_.noop);
 * // => false
 */
var isArray = Array.isArray;

/**
 * Checks if `value` is array-like. A value is considered array-like if it's
 * not a function and has a `value.length` that's an integer greater than or
 * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
 * @example
 *
 * _.isArrayLike([1, 2, 3]);
 * // => true
 *
 * _.isArrayLike(document.body.children);
 * // => true
 *
 * _.isArrayLike('abc');
 * // => true
 *
 * _.isArrayLike(_.noop);
 * // => false
 */
function isArrayLike(value) {
  return value != null && isLength(value.length) && !isFunction(value);
}

/**
 * Checks if `value` is a buffer.
 *
 * @static
 * @memberOf _
 * @since 4.3.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a buffer, else `false`.
 * @example
 *
 * _.isBuffer(new Buffer(2));
 * // => true
 *
 * _.isBuffer(new Uint8Array(2));
 * // => false
 */
var isBuffer = nativeIsBuffer || stubFalse;

/**
 * Performs a deep comparison between two values to determine if they are
 * equivalent.
 *
 * **Note:** This method supports comparing arrays, array buffers, booleans,
 * date objects, error objects, maps, numbers, `Object` objects, regexes,
 * sets, strings, symbols, and typed arrays. `Object` objects are compared
 * by their own, not inherited, enumerable properties. Functions and DOM
 * nodes are compared by strict equality, i.e. `===`.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to compare.
 * @param {*} other The other value to compare.
 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
 * @example
 *
 * var object = { 'a': 1 };
 * var other = { 'a': 1 };
 *
 * _.isEqual(object, other);
 * // => true
 *
 * object === other;
 * // => false
 */
function isEqual(value, other) {
  return baseIsEqual(value, other);
}

/**
 * Checks if `value` is classified as a `Function` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a function, else `false`.
 * @example
 *
 * _.isFunction(_);
 * // => true
 *
 * _.isFunction(/abc/);
 * // => false
 */
function isFunction(value) {
  if (!isObject(value)) {
    return false;
  }
  // The use of `Object#toString` avoids issues with the `typeof` operator
  // in Safari 9 which returns 'object' for typed arrays and other constructors.
  var tag = baseGetTag(value);
  return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
}

/**
 * Checks if `value` is a valid array-like length.
 *
 * **Note:** This method is loosely based on
 * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
 * @example
 *
 * _.isLength(3);
 * // => true
 *
 * _.isLength(Number.MIN_VALUE);
 * // => false
 *
 * _.isLength(Infinity);
 * // => false
 *
 * _.isLength('3');
 * // => false
 */
function isLength(value) {
  return typeof value == 'number' && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
}

/**
 * Checks if `value` is the
 * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
 * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
 * @example
 *
 * _.isObject({});
 * // => true
 *
 * _.isObject([1, 2, 3]);
 * // => true
 *
 * _.isObject(_.noop);
 * // => true
 *
 * _.isObject(null);
 * // => false
 */
function isObject(value) {
  var type = typeof value;
  return value != null && (type == 'object' || type == 'function');
}

/**
 * Checks if `value` is object-like. A value is object-like if it's not `null`
 * and has a `typeof` result of "object".
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
 * @example
 *
 * _.isObjectLike({});
 * // => true
 *
 * _.isObjectLike([1, 2, 3]);
 * // => true
 *
 * _.isObjectLike(_.noop);
 * // => false
 *
 * _.isObjectLike(null);
 * // => false
 */
function isObjectLike(value) {
  return value != null && typeof value == 'object';
}

/**
 * Checks if `value` is classified as a typed array.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
 * @example
 *
 * _.isTypedArray(new Uint8Array);
 * // => true
 *
 * _.isTypedArray([]);
 * // => false
 */
var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;

/**
 * Creates an array of the own enumerable property names of `object`.
 *
 * **Note:** Non-object values are coerced to objects. See the
 * [ES spec](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
 * for more details.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Object
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 *   this.b = 2;
 * }
 *
 * Foo.prototype.c = 3;
 *
 * _.keys(new Foo);
 * // => ['a', 'b'] (iteration order is not guaranteed)
 *
 * _.keys('hi');
 * // => ['0', '1']
 */
function keys(object) {
  return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
}

/**
 * This method returns a new empty array.
 *
 * @static
 * @memberOf _
 * @since 4.13.0
 * @category Util
 * @returns {Array} Returns the new empty array.
 * @example
 *
 * var arrays = _.times(2, _.stubArray);
 *
 * console.log(arrays);
 * // => [[], []]
 *
 * console.log(arrays[0] === arrays[1]);
 * // => false
 */
function stubArray() {
  return [];
}

/**
 * This method returns `false`.
 *
 * @static
 * @memberOf _
 * @since 4.13.0
 * @category Util
 * @returns {boolean} Returns `false`.
 * @example
 *
 * _.times(2, _.stubFalse);
 * // => [false, false]
 */
function stubFalse() {
  return false;
}

module.exports = isEqual;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(177)(module)))

/***/ }),
/* 177 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = function (module) {
	if (!module.webpackPolyfill) {
		module.deprecate = function () {};
		module.paths = [];
		// module.parent = undefined by default
		if (!module.children) module.children = [];
		Object.defineProperty(module, "loaded", {
			enumerable: true,
			get: function () {
				return module.l;
			}
		});
		Object.defineProperty(module, "id", {
			enumerable: true,
			get: function () {
				return module.i;
			}
		});
		module.webpackPolyfill = 1;
	}
	return module;
};

/***/ }),
/* 178 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.executeTasks = executeTasks;
exports._executeTasks = _executeTasks;
exports.checkIsRangesSupported = checkIsRangesSupported;

var _builderUtilRuntime;

function _load_builderUtilRuntime() {
    return _builderUtilRuntime = __webpack_require__(3);
}

var _DataSplitter;

function _load_DataSplitter() {
    return _DataSplitter = __webpack_require__(66);
}

var _downloadPlanBuilder;

function _load_downloadPlanBuilder() {
    return _downloadPlanBuilder = __webpack_require__(35);
}

function executeTasks(differentialDownloader, tasks, out, oldFileFd, reject) {
    const w = taskOffset => {
        if (taskOffset >= tasks.length) {
            if (differentialDownloader.fileMetadataBuffer != null) {
                out.write(differentialDownloader.fileMetadataBuffer);
            }
            out.end();
            return;
        }
        const nextOffset = taskOffset + (differentialDownloader.options.useMultipleRangeRequest === false ? 1 : 1000);
        _executeTasks(differentialDownloader, {
            tasks,
            start: taskOffset,
            end: Math.min(tasks.length, nextOffset),
            oldFileFd
        }, out, () => w(nextOffset), reject);
    };
    return w;
}
function _executeTasks(differentialDownloader, options, out, resolve, reject) {
    let ranges = "bytes=";
    let partCount = 0;
    const partIndexToTaskIndex = new Map();
    const partIndexToLength = [];
    for (let i = options.start; i < options.end; i++) {
        const task = options.tasks[i];
        if (task.kind === (_downloadPlanBuilder || _load_downloadPlanBuilder()).OperationKind.DOWNLOAD) {
            ranges += `${task.start}-${task.end - 1}, `;
            partIndexToTaskIndex.set(partCount, i);
            partCount++;
            partIndexToLength.push(task.end - task.start);
        }
    }
    if (partCount <= 1) {
        // the only remote range - copy
        const w = index => {
            if (index >= options.end) {
                resolve();
                return;
            }
            const task = options.tasks[index++];
            if (task.kind === (_downloadPlanBuilder || _load_downloadPlanBuilder()).OperationKind.COPY) {
                (0, (_DataSplitter || _load_DataSplitter()).copyData)(task, out, options.oldFileFd, reject, () => w(index));
            } else {
                const requestOptions = differentialDownloader.createRequestOptions("get");
                requestOptions.headers.Range = `bytes=${task.start}-${task.end - 1}`;
                const request = differentialDownloader.httpExecutor.doRequest(requestOptions, response => {
                    if (!checkIsRangesSupported(response, reject)) {
                        return;
                    }
                    response.pipe(out, {
                        end: false
                    });
                    response.once("end", () => w(index));
                });
                differentialDownloader.httpExecutor.addErrorAndTimeoutHandlers(request, reject);
                request.end();
            }
        };
        w(options.start);
        return;
    }
    const requestOptions = differentialDownloader.createRequestOptions("get");
    requestOptions.headers.Range = ranges.substring(0, ranges.length - 2);
    const request = differentialDownloader.httpExecutor.doRequest(requestOptions, response => {
        if (!checkIsRangesSupported(response, reject)) {
            return;
        }
        const contentType = (0, (_builderUtilRuntime || _load_builderUtilRuntime()).safeGetHeader)(response, "content-type");
        const m = /^multipart\/.+?(?:; boundary=(?:(?:"(.+)")|(?:([^\s]+))))$/i.exec(contentType);
        if (m == null) {
            reject(new Error(`Content-Type "multipart/byteranges" is expected, but got "${contentType}"`));
            return;
        }
        const dicer = new (_DataSplitter || _load_DataSplitter()).DataSplitter(out, options, partIndexToTaskIndex, m[1] || m[2], partIndexToLength, resolve);
        dicer.on("error", reject);
        response.pipe(dicer);
    });
    differentialDownloader.httpExecutor.addErrorAndTimeoutHandlers(request, reject);
    request.end();
}
function checkIsRangesSupported(response, reject) {
    // Electron net handles redirects automatically, our NodeJS test server doesn't use redirects - so, we don't check 3xx codes.
    if (response.statusCode >= 400) {
        reject((0, (_builderUtilRuntime || _load_builderUtilRuntime()).createHttpError)(response));
        return false;
    }
    if (response.statusCode !== 206) {
        const acceptRanges = (0, (_builderUtilRuntime || _load_builderUtilRuntime()).safeGetHeader)(response, "accept-ranges");
        if (acceptRanges == null || acceptRanges === "none") {
            reject(new Error("Server doesn't support Accept-Ranges"));
            return false;
        }
    }
    return true;
}
//# sourceMappingURL=multipleRangeDownloader.js.map

/***/ }),
/* 179 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.GenericDifferentialDownloader = undefined;

var _bluebirdLst;

function _load_bluebirdLst() {
    return _bluebirdLst = __webpack_require__(2);
}

var _blockMapApi;

function _load_blockMapApi() {
    return _blockMapApi = __webpack_require__(63);
}

var _fsExtraP;

function _load_fsExtraP() {
    return _fsExtraP = __webpack_require__(9);
}

var _path = _interopRequireWildcard(__webpack_require__(0));

var _DifferentialDownloader;

function _load_DifferentialDownloader() {
    return _DifferentialDownloader = __webpack_require__(65);
}

function _interopRequireWildcard(obj) {
    if (obj && obj.__esModule) {
        return obj;
    } else {
        var newObj = {};if (obj != null) {
            for (var key in obj) {
                if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key];
            }
        }newObj.default = obj;return newObj;
    }
}

class GenericDifferentialDownloader extends (_DifferentialDownloader || _load_DifferentialDownloader()).DifferentialDownloader {
    download(newBlockMap) {
        var _this = this;

        return (0, (_bluebirdLst || _load_bluebirdLst()).coroutine)(function* () {
            yield _this.doDownload((yield (0, (_fsExtraP || _load_fsExtraP()).readJson)(_path.join(process.resourcesPath, "..", (_blockMapApi || _load_blockMapApi()).BLOCK_MAP_FILE_NAME))), newBlockMap);
        })();
    }
}
exports.GenericDifferentialDownloader = GenericDifferentialDownloader; //# sourceMappingURL=GenericDifferentialDownloader.js.map

/***/ }),
/* 180 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.verifySignature = verifySignature;

var _bluebirdLst;

function _load_bluebirdLst() {
    return _bluebirdLst = _interopRequireDefault(__webpack_require__(2));
}

var _builderUtilRuntime;

function _load_builderUtilRuntime() {
    return _builderUtilRuntime = __webpack_require__(3);
}

var _child_process;

function _load_child_process() {
    return _child_process = __webpack_require__(34);
}

var _os;

function _load_os() {
    return _os = _interopRequireWildcard(__webpack_require__(15));
}

function _interopRequireWildcard(obj) {
    if (obj && obj.__esModule) {
        return obj;
    } else {
        var newObj = {};if (obj != null) {
            for (var key in obj) {
                if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key];
            }
        }newObj.default = obj;return newObj;
    }
}

function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
}

// $certificateInfo = (Get-AuthenticodeSignature 'xxx\yyy.exe'
// | where {$_.Status.Equals([System.Management.Automation.SignatureStatus]::Valid) -and $_.SignerCertificate.Subject.Contains("CN=siemens.com")})
// | Out-String ; if ($certificateInfo) { exit 0 } else { exit 1 }
function verifySignature(publisherNames, tempUpdateFile, logger) {
    return new (_bluebirdLst || _load_bluebirdLst()).default((resolve, reject) => {
        // https://github.com/electron-userland/electron-builder/issues/2421
        (0, (_child_process || _load_child_process()).execFile)("powershell.exe", [`Get-AuthenticodeSignature '${tempUpdateFile}' | ConvertTo-Json -Compress`], {
            timeout: 30 * 1000
        }, (error, stdout, stderr) => {
            if (error != null || stderr) {
                if (isOldWin6()) {
                    logger.warn(`Cannot execute Get-AuthenticodeSignature: ${error || stderr}. Ignoring signature validation due to unsupported powershell version. Please upgrade to powershell 3 or higher.`);
                    resolve(null);
                    return;
                }
                try {
                    (0, (_child_process || _load_child_process()).execFileSync)("powershell.exe", ["ConvertTo-Json test"], { timeout: 10 * 1000 });
                } catch (testError) {
                    logger.warn(`Cannot execute ConvertTo-Json: ${testError.message}. Ignoring signature validation due to unsupported powershell version. Please upgrade to powershell 3 or higher.`);
                    resolve(null);
                    return;
                }
                if (error != null) {
                    reject(error);
                    return;
                }
                if (stderr) {
                    reject(new Error(`Cannot execute Get-AuthenticodeSignature: ${stderr}`));
                    return;
                }
            }
            const data = JSON.parse(stdout);
            delete data.PrivateKey;
            delete data.IsOSBinary;
            delete data.SignatureType;
            const signerCertificate = data.SignerCertificate;
            if (signerCertificate != null) {
                delete signerCertificate.Archived;
                delete signerCertificate.Extensions;
                delete signerCertificate.Handle;
                delete signerCertificate.HasPrivateKey;
                // duplicates data.SignerCertificate (contains RawData)
                delete signerCertificate.SubjectName;
            }
            delete data.Path;
            if (data.Status === 0) {
                const name = (0, (_builderUtilRuntime || _load_builderUtilRuntime()).parseDn)(data.SignerCertificate.Subject).get("CN");
                if (publisherNames.includes(name)) {
                    resolve(null);
                    return;
                }
            }
            const result = `publisherNames: ${publisherNames.join(" | ")}, raw info: ` + JSON.stringify(data, (name, value) => name === "RawData" ? undefined : value, 2);
            logger.info(`Sign verification failed, installer signed with incorrect certificate: ${result}`);
            resolve(result);
        });
    });
}
function isOldWin6() {
    const winVersion = (_os || _load_os()).release();
    return winVersion.startsWith("6.") && !winVersion.startsWith("6.3");
}
//# sourceMappingURL=windowsExecutableCodeSignatureVerifier.js.map

/***/ }),
/* 181 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.MacUpdater = undefined;

var _bluebirdLst;

function _load_bluebirdLst() {
    return _bluebirdLst = __webpack_require__(2);
}

var _bluebirdLst2;

function _load_bluebirdLst2() {
    return _bluebirdLst2 = _interopRequireDefault(__webpack_require__(2));
}

var _builderUtilRuntime;

function _load_builderUtilRuntime() {
    return _builderUtilRuntime = __webpack_require__(3);
}

var _http;

function _load_http() {
    return _http = __webpack_require__(67);
}

var _AppUpdater;

function _load_AppUpdater() {
    return _AppUpdater = __webpack_require__(27);
}

var _main;

function _load_main() {
    return _main = __webpack_require__(8);
}

var _Provider;

function _load_Provider() {
    return _Provider = __webpack_require__(14);
}

function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
}

class MacUpdater extends (_AppUpdater || _load_AppUpdater()).AppUpdater {
    constructor(options) {
        super(options);
        this.nativeUpdater = __webpack_require__(10).autoUpdater;
        this.nativeUpdater.on("error", it => {
            this._logger.warn(it);
            this.emit("error", it);
        });
        this.nativeUpdater.on("update-downloaded", () => {
            this._logger.info(`New version ${this.updateInfo.version} has been downloaded`);
            this.emit((_main || _load_main()).UPDATE_DOWNLOADED, this.updateInfo);
        });
    }
    doDownloadUpdate(updateInfo, cancellationToken) {
        var _this = this;

        return (0, (_bluebirdLst || _load_bluebirdLst()).coroutine)(function* () {
            const files = (yield _this.provider).resolveFiles(updateInfo);
            const zipFileInfo = (0, (_Provider || _load_Provider()).findFile)(files, "zip", ["pkg", "dmg"]);
            if (zipFileInfo == null) {
                throw (0, (_builderUtilRuntime || _load_builderUtilRuntime()).newError)(`ZIP file not provided: ${(0, (_builderUtilRuntime || _load_builderUtilRuntime()).safeStringifyJson)(files)}`, "ERR_UPDATER_ZIP_FILE_NOT_FOUND");
            }
            const server = (0, (_http || _load_http()).createServer)();
            server.on("close", function () {
                _this._logger.info(`Proxy server for native Squirrel.Mac is closed (was started to download ${zipFileInfo.url.href})`);
            });
            function getServerUrl() {
                const address = server.address();
                return `http://${address.address}:${address.port}`;
            }
            const requestHeaders = yield _this.computeRequestHeaders();
            return yield new (_bluebirdLst2 || _load_bluebirdLst2()).default(function (resolve, reject) {
                server.on("request", function (request, response) {
                    const requestUrl = request.url;
                    _this._logger.info(`${requestUrl} requested`);
                    if (requestUrl === "/") {
                        const data = Buffer.from(`{ "url": "${getServerUrl()}/app.zip" }`);
                        response.writeHead(200, { "Content-Type": "application/json", "Content-Length": data.length });
                        response.end(data);
                    } else if (requestUrl.startsWith("/app.zip")) {
                        let errorOccurred = false;
                        response.on("finish", function () {
                            try {
                                setImmediate(function () {
                                    return server.close();
                                });
                            } finally {
                                if (!errorOccurred) {
                                    _this.nativeUpdater.removeListener("error", reject);
                                    resolve([]);
                                }
                            }
                        });
                        _this.doProxyUpdateFile(response, zipFileInfo.url.href, requestHeaders, zipFileInfo.info.sha512, cancellationToken, function (error) {
                            errorOccurred = true;
                            try {
                                response.writeHead(500);
                                response.end();
                            } finally {
                                _this.nativeUpdater.removeListener("error", reject);
                                reject(new Error(`Cannot download "${zipFileInfo.url}": ${error}`));
                            }
                        });
                    } else {
                        _this._logger.warn(`${requestUrl} requested, but not supported`);
                        response.writeHead(404);
                        response.end();
                    }
                });
                server.listen(0, "127.0.0.1", 16, function () {
                    _this.nativeUpdater.setFeedURL(`${getServerUrl()}`, { "Cache-Control": "no-cache" });
                    _this.nativeUpdater.once("error", reject);
                    _this.nativeUpdater.checkForUpdates();
                });
            });
        })();
    }
    doProxyUpdateFile(nativeResponse, url, headers, sha512, cancellationToken, errorHandler) {
        const downloadRequest = this.httpExecutor.doRequest((0, (_builderUtilRuntime || _load_builderUtilRuntime()).configureRequestOptionsFromUrl)(url, { headers }), downloadResponse => {
            if (downloadResponse.statusCode >= 400) {
                try {
                    nativeResponse.writeHead(404);
                    nativeResponse.end();
                } finally {
                    errorHandler(new Error(`Cannot download "${url}", status ${downloadResponse.statusCode}: ${downloadResponse.statusMessage}`));
                }
                return;
            }
            // in tests Electron NET Api is not used, so, we have to handle redirect.
            const redirectUrl = (0, (_builderUtilRuntime || _load_builderUtilRuntime()).safeGetHeader)(downloadResponse, "location");
            if (redirectUrl != null) {
                this.doProxyUpdateFile(nativeResponse, redirectUrl, headers, sha512, cancellationToken, errorHandler);
                return;
            }
            const nativeHeaders = { "Content-Type": "application/zip" };
            const streams = [];
            const downloadListenerCount = this.listenerCount((_main || _load_main()).DOWNLOAD_PROGRESS);
            this._logger.info(`${(_main || _load_main()).DOWNLOAD_PROGRESS} listener count: ${downloadListenerCount}`);
            if (downloadListenerCount > 0) {
                const contentLength = (0, (_builderUtilRuntime || _load_builderUtilRuntime()).safeGetHeader)(downloadResponse, "content-length");
                this._logger.info(`contentLength: ${contentLength}`);
                if (contentLength != null) {
                    nativeHeaders["Content-Length"] = contentLength;
                    streams.push(new (_builderUtilRuntime || _load_builderUtilRuntime()).ProgressCallbackTransform(parseInt(contentLength, 10), cancellationToken, it => this.emit((_main || _load_main()).DOWNLOAD_PROGRESS, it)));
                }
            }
            nativeResponse.writeHead(200, nativeHeaders);
            // for mac only sha512 is produced (sha256 is published for windows only to preserve backward compatibility)
            if (sha512 != null) {
                // "hex" to easy migrate to new base64 encoded hash (we already produces latest-mac.yml with hex encoded hash)
                streams.push(new (_builderUtilRuntime || _load_builderUtilRuntime()).DigestTransform(sha512, "sha512", sha512.length === 128 && !sha512.includes("+") && !sha512.includes("Z") && !sha512.includes("=") ? "hex" : "base64"));
            }
            streams.push(nativeResponse);
            let lastStream = downloadResponse;
            for (const stream of streams) {
                stream.on("error", errorHandler);
                lastStream = lastStream.pipe(stream);
            }
        });
        downloadRequest.on("redirect", (statusCode, method, redirectUrl) => {
            if (headers.Authorization != null && headers.Authorization.startsWith("token")) {
                const parsedNewUrl = new URL(redirectUrl);
                if (parsedNewUrl.hostname.endsWith(".amazonaws.com")) {
                    delete headers.Authorization;
                }
            }
            this.doProxyUpdateFile(nativeResponse, redirectUrl, headers, sha512, cancellationToken, errorHandler);
        });
        downloadRequest.on("error", errorHandler);
        downloadRequest.end();
    }
    quitAndInstall() {
        this.nativeUpdater.quitAndInstall();
    }
}
exports.MacUpdater = MacUpdater; //# sourceMappingURL=MacUpdater.js.map

/***/ }),
/* 182 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.AppImageUpdater = undefined;

var _bluebirdLst;

function _load_bluebirdLst() {
    return _bluebirdLst = __webpack_require__(2);
}

var _bluebirdLst2;

function _load_bluebirdLst2() {
    return _bluebirdLst2 = _interopRequireDefault(__webpack_require__(2));
}

var _builderUtilRuntime;

function _load_builderUtilRuntime() {
    return _builderUtilRuntime = __webpack_require__(3);
}

var _child_process;

function _load_child_process() {
    return _child_process = __webpack_require__(34);
}

var _electronIsDev;

function _load_electronIsDev() {
    return _electronIsDev = _interopRequireDefault(__webpack_require__(26));
}

var _fsExtraP;

function _load_fsExtraP() {
    return _fsExtraP = __webpack_require__(9);
}

var _path = _interopRequireWildcard(__webpack_require__(0));

__webpack_require__(33);

var _BaseUpdater;

function _load_BaseUpdater() {
    return _BaseUpdater = __webpack_require__(61);
}

var _FileWithEmbeddedBlockMapDifferentialDownloader;

function _load_FileWithEmbeddedBlockMapDifferentialDownloader() {
    return _FileWithEmbeddedBlockMapDifferentialDownloader = __webpack_require__(62);
}

var _main;

function _load_main() {
    return _main = __webpack_require__(8);
}

var _Provider;

function _load_Provider() {
    return _Provider = __webpack_require__(14);
}

function _interopRequireWildcard(obj) {
    if (obj && obj.__esModule) {
        return obj;
    } else {
        var newObj = {};if (obj != null) {
            for (var key in obj) {
                if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key];
            }
        }newObj.default = obj;return newObj;
    }
}

function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
}

class AppImageUpdater extends (_BaseUpdater || _load_BaseUpdater()).BaseUpdater {
    constructor(options, app) {
        super(options, app);
    }
    checkForUpdatesAndNotify() {
        if ((_electronIsDev || _load_electronIsDev()).default) {
            return (_bluebirdLst2 || _load_bluebirdLst2()).default.resolve(null);
        }
        if (process.env.APPIMAGE == null) {
            this._logger.warn("APPIMAGE env is not defined, current application is not an AppImage");
            return (_bluebirdLst2 || _load_bluebirdLst2()).default.resolve(null);
        }
        return super.checkForUpdatesAndNotify();
    }
    /*** @private */
    doDownloadUpdate(updateInfo, cancellationToken) {
        var _this = this;

        return (0, (_bluebirdLst || _load_bluebirdLst()).coroutine)(function* () {
            const provider = yield _this.provider;
            const fileInfo = (0, (_Provider || _load_Provider()).findFile)(provider.resolveFiles(updateInfo), "AppImage");
            const requestHeaders = yield _this.computeRequestHeaders();
            const downloadOptions = {
                skipDirCreation: true,
                headers: requestHeaders,
                cancellationToken,
                sha512: fileInfo.info.sha512
            };
            let installerPath = _this.downloadedUpdateHelper.getDownloadedFile(updateInfo, fileInfo);
            if (installerPath != null) {
                return [installerPath];
            }
            yield _this.executeDownload(downloadOptions, fileInfo, (() => {
                var _ref = (0, (_bluebirdLst || _load_bluebirdLst()).coroutine)(function* (tempDir, destinationFile) {
                    installerPath = destinationFile;
                    const oldFile = process.env.APPIMAGE;
                    if (oldFile == null) {
                        throw (0, (_builderUtilRuntime || _load_builderUtilRuntime()).newError)("APPIMAGE env is not defined", "ERR_UPDATER_OLD_FILE_NOT_FOUND");
                    }
                    let isDownloadFull = false;
                    try {
                        yield new (_FileWithEmbeddedBlockMapDifferentialDownloader || _load_FileWithEmbeddedBlockMapDifferentialDownloader()).FileWithEmbeddedBlockMapDifferentialDownloader(fileInfo.info, _this.httpExecutor, {
                            newUrl: fileInfo.url.href,
                            oldFile,
                            logger: _this._logger,
                            newFile: installerPath,
                            useMultipleRangeRequest: provider.useMultipleRangeRequest,
                            requestHeaders
                        }).download();
                    } catch (e) {
                        _this._logger.error(`Cannot download differentially, fallback to full download: ${e.stack || e}`);
                        // during test (developer machine mac) we must throw error
                        isDownloadFull = process.platform === "linux";
                    }
                    if (isDownloadFull) {
                        yield _this.httpExecutor.download(fileInfo.url.href, installerPath, downloadOptions);
                    }
                    yield (0, (_fsExtraP || _load_fsExtraP()).chmod)(installerPath, 0o755);
                });

                return function (_x, _x2) {
                    return _ref.apply(this, arguments);
                };
            })());
            _this.downloadedUpdateHelper.setDownloadedFile(installerPath, null, updateInfo, fileInfo);
            _this.addQuitHandler();
            _this.emit((_main || _load_main()).UPDATE_DOWNLOADED, _this.updateInfo);
            return [installerPath];
        })();
    }
    doInstall(installerPath, isSilent, isRunAfter) {
        const appImageFile = process.env.APPIMAGE;
        if (appImageFile == null) {
            throw (0, (_builderUtilRuntime || _load_builderUtilRuntime()).newError)("APPIMAGE env is not defined", "ERR_UPDATER_OLD_FILE_NOT_FOUND");
        }
        // https://stackoverflow.com/a/1712051/1910191
        (0, (_fsExtraP || _load_fsExtraP()).unlinkSync)(appImageFile);
        let destination;
        if (_path.basename(installerPath) === _path.basename(appImageFile)) {
            // no version in the file name, overwrite existing
            destination = appImageFile;
        } else {
            destination = _path.join(_path.dirname(appImageFile), _path.basename(installerPath));
        }
        (0, (_child_process || _load_child_process()).execFileSync)("mv", ["-f", installerPath, destination]);
        const env = Object.assign({}, process.env, { APPIMAGE_SILENT_INSTALL: "true" });
        if (isRunAfter) {
            (0, (_child_process || _load_child_process()).spawn)(destination, [], {
                detached: true,
                stdio: "ignore",
                env
            }).unref();
        } else {
            env.APPIMAGE_EXIT_AFTER_INSTALL = "true";
            (0, (_child_process || _load_child_process()).execFileSync)(destination, [], { env });
        }
        return true;
    }
}
exports.AppImageUpdater = AppImageUpdater; //# sourceMappingURL=AppImageUpdater.js.map

/***/ }),
/* 183 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


if (process.type === 'renderer') {
  module.exports = __webpack_require__(184);
} else {
  module.exports = __webpack_require__(185);
}

/***/ }),
/* 184 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = null;

var ipcRenderer;
try {
  ipcRenderer = __webpack_require__(10).ipcRenderer;
} catch (e) {
  ipcRenderer = null;
}

var originalConsole = __webpack_require__(68);

if (ipcRenderer) {
  module.exports = {
    error: log.bind(null, 'error'),
    warn: log.bind(null, 'warn'),
    info: log.bind(null, 'info'),
    verbose: log.bind(null, 'verbose'),
    debug: log.bind(null, 'debug'),
    silly: log.bind(null, 'silly'),
    log: log.bind(null, 'info')
  };

  module.exports.default = module.exports;

  ipcRenderer.on('__ELECTRON_LOG_RENDERER__', function (event, level, text) {
    if (level === 'verbose') {
      level = 'log';
    } else if (level === 'silly') {
      level = 'debug';
    }

    originalConsole[level].call(originalConsole.context, text);
  });
}

function log() {
  var data = Array.prototype.slice.call(arguments);

  data = data.map(function (obj) {
    if (obj instanceof Error) {
      obj = obj.stack || obj;
    }

    return obj;
  });

  ipcRenderer.send('__ELECTRON_LOG__', data);
}

/***/ }),
/* 185 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var electron;
try {
  electron = __webpack_require__(10);
} catch (e) {
  electron = null;
}

var log = __webpack_require__(186);
var transportConsole = __webpack_require__(36);
var transportFile = __webpack_require__(187);
var transportLogS = __webpack_require__(190);
var transportRendererConsole = __webpack_require__(192);

var transports = {
  console: transportConsole,
  file: transportFile,
  logS: transportLogS,
  rendererConsole: transportRendererConsole
};

module.exports = {
  transports: transports,

  error: log.bind(null, transports, 'error'),
  warn: log.bind(null, transports, 'warn'),
  info: log.bind(null, transports, 'info'),
  verbose: log.bind(null, transports, 'verbose'),
  debug: log.bind(null, transports, 'debug'),
  silly: log.bind(null, transports, 'silly'),
  log: log.bind(null, transports, 'info')
};

module.exports.default = module.exports;

if (electron && electron.ipcMain) {
  electron.ipcMain.on('__ELECTRON_LOG__', onRendererLog);
  var appName = electron.app.getName();
  if (appName !== 'Electron') {
    transportFile.appName = appName;
  }
}

function onRendererLog(event, data) {
  if (Array.isArray(data)) {
    data.unshift(transports);
    log.apply(null, data);
  }
}

/***/ }),
/* 186 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// jshint -W040


var LEVELS = ['error', 'warn', 'info', 'verbose', 'debug', 'silly'];

module.exports = log;

function log(transports, level, text) {
  var data = Array.prototype.slice.call(arguments, 2);

  var msg = {
    data: data,
    date: new Date(),
    level: level
  };

  for (var i in transports) {
    // jshint -W089
    if (!transports.hasOwnProperty(i) || typeof transports[i] !== 'function') {
      continue;
    }

    var transport = transports[i];

    if (transport === false || !compareLevels(transport.level, level)) {
      continue;
    }

    if (transport.level === false) continue;

    transport.call(null, msg);
  }
}

function compareLevels(passLevel, checkLevel) {
  var pass = LEVELS.indexOf(passLevel);
  var check = LEVELS.indexOf(checkLevel);
  if (check === -1 || pass === -1) {
    return true;
  }
  return check <= pass;
}

/***/ }),
/* 187 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var fs = __webpack_require__(12);
var EOL = __webpack_require__(15).EOL;
var format = __webpack_require__(37);
var consoleTransport = __webpack_require__(36);
var findLogPath = __webpack_require__(188);

transport.findLogPath = findLogPath;
transport.format = '[{y}-{m}-{d} {h}:{i}:{s}.{ms}] [{level}] {text}';
transport.level = 'warn';
transport.maxSize = 1024 * 1024;
transport.streamConfig = undefined;

module.exports = transport;

function transport(msg) {
  var text = format.format(msg, transport.format) + EOL;

  if (transport.stream === undefined) {
    initSteamConfig();
    openStream();
  }

  if (transport.level === false) {
    return;
  }

  var needLogRotation = transport.maxSize > 0 && getStreamSize(transport.stream) > transport.maxSize;

  if (needLogRotation) {
    archiveLog(transport.stream);
    openStream();
  }

  transport.stream.write(text);
}

function initSteamConfig() {
  transport.file = transport.file || findLogPath(transport.appName);

  if (!transport.file) {
    transport.level = false;
    logConsole('Could not set a log file');
  }
}

function openStream() {
  if (transport.level === false) {
    return;
  }

  transport.stream = fs.createWriteStream(transport.file, transport.streamConfig || { flags: 'a' });
}

function getStreamSize(stream) {
  if (!stream) {
    return 0;
  }

  if (stream.logSizeAtStart === undefined) {
    try {
      stream.logSizeAtStart = fs.statSync(stream.path).size;
    } catch (e) {
      stream.logSizeAtStart = 0;
    }
  }

  return stream.logSizeAtStart + stream.bytesWritten;
}

function archiveLog(stream) {
  if (stream.end) {
    stream.end();
  }

  try {
    fs.renameSync(stream.path, stream.path.replace(/log$/, 'old.log'));
  } catch (e) {
    logConsole('Could not rotate log', e);
  }
}

function logConsole(message, error) {
  var data = ['electron-log.transports.file: ' + message];

  if (error) {
    data.push(error);
  }

  consoleTransport({ data: data, date: new Date(), level: 'warn' });
}

/***/ }),
/* 188 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var fs = __webpack_require__(12);
var path = __webpack_require__(0);
var os = __webpack_require__(15);
var getAppName = __webpack_require__(189);

module.exports = findLogPath;

/**
 * Try to determine a platform-specific path where can write logs
 * @param {string} [appName] Used to determine the last part of a log path
 * @return {string|boolean}
 */
function findLogPath(appName) {
  appName = appName || getAppName();
  if (!appName) {
    return false;
  }

  var homeDir = os.homedir ? os.homedir() : process.env['HOME'];

  var dir;
  switch (process.platform) {
    case 'linux':
      {
        dir = prepareDir(process.env['XDG_CONFIG_HOME'], appName).or(homeDir, '.config', appName).or(process.env['XDG_DATA_HOME'], appName).or(homeDir, '.local', 'share', appName).result;
        break;
      }

    case 'darwin':
      {
        dir = prepareDir(homeDir, 'Library', 'Logs', appName).or(homeDir, 'Library', 'Application Support', appName).result;
        break;
      }

    case 'win32':
      {
        dir = prepareDir(process.env['APPDATA'], appName).or(homeDir, 'AppData', 'Roaming', appName).result;
        break;
      }
  }

  if (dir) {
    return path.join(dir, 'log.log');
  } else {
    return false;
  }
}

function prepareDir(dirPath) {
  // jshint -W040
  if (!this || this.or !== prepareDir || !this.result) {
    if (!dirPath) {
      return { or: prepareDir };
    }

    //noinspection JSCheckFunctionSignatures
    dirPath = path.join.apply(path, arguments);
    mkDir(dirPath);

    try {
      fs.accessSync(dirPath, fs.W_OK);
    } catch (e) {
      return { or: prepareDir };
    }
  }

  return {
    or: prepareDir,
    result: (this ? this.result : false) || dirPath
  };
}

function mkDir(dirPath, root) {
  var dirs = dirPath.split(path.sep);
  var dir = dirs.shift();
  root = (root || '') + dir + path.sep;

  try {
    fs.mkdirSync(root);
  } catch (e) {
    if (!fs.statSync(root).isDirectory()) {
      throw new Error(e);
    }
  }

  return !dirs.length || mkDir(dirs.join(path.sep), root);
}

/***/ }),
/* 189 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// jshint -W074


/** @name process.resourcesPath */

var fs = __webpack_require__(12);
var path = __webpack_require__(0);
var consoleTransport = __webpack_require__(36);

module.exports = getAppName;

function getAppName() {
  try {
    var name = loadPackageName();
    if (name) {
      return name;
    }
    return warn('electron-log: unable to load the app name from package.json');
  } catch (e) {
    return warn('electron-log: ' + e.message);
  }
}

/**
 * Try to load main app package
 * @throws {Error}
 * @return {Object|null}
 */
function loadPackageName() {
  var packageFile;

  try {
    if (__webpack_require__.c[__webpack_require__.s].filename) {
      packageFile = find(path.dirname(__webpack_require__.c[__webpack_require__.s].filename));
    }
  } catch (e) {}

  if (!packageFile && process.resourcesPath) {
    packageFile = find(path.join(process.resourcesPath, 'app.asar'));
    var electronModule = path.join('node_modules', 'electron', 'package.json');
    if (packageFile && packageFile.indexOf(electronModule) !== -1) {
      packageFile = null;
    }
  }

  if (!packageFile) {
    packageFile = find(process.cwd());
  }

  if (!packageFile) {
    return null;
  }

  var content = fs.readFileSync(packageFile, 'utf-8');
  var packageData = JSON.parse(content);

  //noinspection JSUnresolvedVariable
  return packageData ? packageData.productName || packageData.name : false;
}

function find(root) {
  var file;

  while (!file) {
    var parent;
    file = path.join(root, 'package.json');

    try {
      fs.statSync(file);
    } catch (e) {
      parent = path.resolve(root, '..');
      file = null;
    }

    if (root === parent) {
      break;
    }

    root = parent;
  }

  return file;
}

function warn(message) {
  consoleTransport({
    data: [message],
    date: new Date(),
    level: 'warn'
  });
}

/***/ }),
/* 190 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// jshint -W074, -W089


var http = __webpack_require__(67);
var https = __webpack_require__(191);
var url = __webpack_require__(20);

transport.client = { name: 'electron-application' };
transport.depth = 6;
transport.level = false;
transport.url = null;

module.exports = transport;

function transport(msg) {
  if (!transport.url) return;

  var data = jsonDepth({
    client: transport.client,
    data: msg.data,
    date: msg.date.getTime(),
    level: msg.level
  }, transport.depth + 1);

  post(transport.url, data);
}

function post(serverUrl, data) {
  var urlObject = url.parse(serverUrl);
  var transport = urlObject.protocol === 'https:' ? https : http;

  var body = JSON.stringify(data);

  var options = {
    hostname: urlObject.hostname,
    port: urlObject.port,
    path: urlObject.path,
    method: 'POST',
    headers: {
      'Content-Type': 'application/json',
      'Content-Length': body.length
    }
  };

  var request = transport.request(options);
  request.write(body);
  request.end();
}

function jsonDepth(json, depth) {
  if (depth < 1) {
    if (Array.isArray(json)) return '[array]';
    if (typeof json === 'object') return '[object]';
    return json;
  }

  if (Array.isArray(json)) {
    return json.map(function (child) {
      return jsonDepth(child, depth - 1);
    });
  }

  if (json && typeof json.getMonth === 'function') {
    return json;
  }

  if (json === null) {
    return null;
  }

  if (typeof json === 'object') {
    if (typeof json.toJSON === 'function') {
      json = json.toJSON();
    }

    var newJson = {};
    for (var i in json) {
      //noinspection JSUnfilteredForInLoop
      newJson[i] = jsonDepth(json[i], depth - 1);
    }

    return newJson;
  }

  return json;
}

/***/ }),
/* 191 */
/***/ (function(module, exports) {

module.exports = require("https");

/***/ }),
/* 192 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var BrowserWindow;
try {
  BrowserWindow = __webpack_require__(10).BrowserWindow;
} catch (e) {
  BrowserWindow = null;
}

var format = __webpack_require__(37);

transport.level = BrowserWindow ? 'silly' : false;
transport.format = '[{h}:{i}:{s}.{ms}] {text}';

module.exports = transport;

function transport(msg) {
  if (!BrowserWindow) return;

  var text = format.format(msg, transport.format);
  BrowserWindow.getAllWindows().forEach(function (wnd) {
    wnd.webContents.send('__ELECTRON_LOG_RENDERER__', msg.level, text);
  });
}

/***/ }),
/* 193 */
/***/ (function(module, exports) {

module.exports = {"name":"ELIT","version":"0.0.17","description":"ELIT - Eve Local Intel Tool","main":"dist/main.js","repository":"git@github.com:Squareheads/ELIT.git","author":"Owen Worley","license":"(c) Squareheads LTD 2018","devDependencies":{"@types/chai":"^4.0.8","@types/electron":"^1.6.10","@types/electron-is-dev":"^0.3.0","@types/material-ui":"^0.18.5","@types/mocha":"^2.2.44","@types/mockery":"^1.4.29","@types/node":"^8.0.53","@types/react":"^16.0.25","@types/react-dom":"^16.0.3","@types/request":"^2.0.8","@types/request-promise-native":"^1.0.10","@types/sinon":"^4.1.0","@types/url-parse":"^1.1.0","@types/x2js":"^3.1.0","babel-core":"^6.26.0","babel-loader":"^7.1.2","babel-plugin-add-module-exports":"^0.2.1","babel-plugin-transform-runtime":"^6.0.0","babel-preset-env":"^1.6.1","babel-preset-es2015":"^6.24.1","babel-preset-es2015-node":"^6.1.1","babel-preset-es2015-node5":"^1.2.0","babel-preset-react":"^6.24.1","babel-preset-stage-3":"^6.24.1","babel-preset-ts-node6-bluebird":"^1.0.1","chai":"^4.1.2","electron":"^1.7.9","electron-builder":"^19.46.9","html-webpack-plugin":"^2.30.1","ignore-styles":"^5.0.1","mocha":"^4.0.1","mockery":"^2.1.0","node-noop":"^1.0.0","nyc":"^11.3.0","sinon":"^4.1.3","standard":"^10.0.3","standard-loader":"^6.0.1","ts-loader":"^3.1.1","ts-mockito":"^2.2.7","ts-node":"^3.3.0","tslint":"^5.8.0","tslint-config-standard":"^7.0.0","tslint-loader":"^3.5.3","typescript":"^2.6.2","webpack":"^3.8.1"},"scripts":{"build":"webpack --config webpack.config.js","prestart":"yarn run build","start":"electron .","test":"set TS_NODE_PROJECT=tsconfig.test.json&&mocha","pack":"electron-builder --dir","dist":"electron-builder","dist-all":"electron-builder -mwl"},"dependencies":{"dexie":"2","electron-google-analytics":"^0.0.24","electron-is-dev":"^0.3.0","electron-log":"^2.2.13","electron-updater":"^2.18.2","eve-online-esi":" https://github.com/Squareheads/eve-online-esi/archive/df440efa394e36e063a6593bede8dd8d285e1179.tar.gz","material-ui":"^0.20.0","material-ui-image":"^2.1.1","querystringify":"^1.0.0","react":"^16.2.0","react-dom":"^16.2.0","react-electron-web-view":"^2.0.1","request":"^2.83.0","typescript-collections":"^1.2.5","url-parse":"^1.2.0","x2js":"^3.1.1"},"build":{"appId":"io.squareheads.eve-intel","files":"./dist/**/*","directories":{"output":"packaged"},"mac":{"category":"public.app-category.utilities"}},"peerDependencies":{}}

/***/ })
/******/ ]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vd2VicGFjay9ib290c3RyYXAgNGUzYTdkYWNmNjM1M2NkMmUwZDUiLCJ3ZWJwYWNrOi8vL2V4dGVybmFsIFwicGF0aFwiIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9ibHVlYmlyZC9qcy9yZWxlYXNlL3V0aWwuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2JsdWViaXJkLWxzdC9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZWxlY3Ryb24tdXBkYXRlci9ub2RlX21vZHVsZXMvYnVpbGRlci11dGlsLXJ1bnRpbWUvb3V0L2luZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9qcy15YW1sL2xpYi9qcy15YW1sL3R5cGUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2dyYWNlZnVsLWZzL2dyYWNlZnVsLWZzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy91bml2ZXJzYWxpZnkvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2VsZWN0cm9uLXVwZGF0ZXIvbm9kZV9tb2R1bGVzL2ZzLWV4dHJhL2xpYi9ta2RpcnMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2VsZWN0cm9uLXVwZGF0ZXIvb3V0L21haW4uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2VsZWN0cm9uLXVwZGF0ZXIvbm9kZV9tb2R1bGVzL2ZzLWV4dHJhLXAvaW5kZXguanMiLCJ3ZWJwYWNrOi8vL2V4dGVybmFsIFwiZWxlY3Ryb25cIiIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYmx1ZWJpcmQvanMvcmVsZWFzZS9lcnJvcnMuanMiLCJ3ZWJwYWNrOi8vL2V4dGVybmFsIFwiZnNcIiIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZWxlY3Ryb24tdXBkYXRlci9ub2RlX21vZHVsZXMvZnMtZXh0cmEvbGliL3BhdGgtZXhpc3RzL2luZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9lbGVjdHJvbi11cGRhdGVyL291dC9Qcm92aWRlci5qcyIsIndlYnBhY2s6Ly8vZXh0ZXJuYWwgXCJvc1wiIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9ibHVlYmlyZC9qcy9yZWxlYXNlL2VzNS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvanMteWFtbC9saWIvanMteWFtbC9jb21tb24uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2pzLXlhbWwvbGliL2pzLXlhbWwvc2NoZW1hLmpzIiwid2VicGFjazovLy9leHRlcm5hbCBcInN0cmVhbVwiIiwid2VicGFjazovLy9leHRlcm5hbCBcInVybFwiIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9qcy15YW1sL2xpYi9qcy15YW1sL2V4Y2VwdGlvbi5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvanMteWFtbC9saWIvanMteWFtbC9zY2hlbWEvZGVmYXVsdF9zYWZlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9lbGVjdHJvbi11cGRhdGVyL25vZGVfbW9kdWxlcy9zb3VyY2UtbWFwL2xpYi91dGlsLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9lbGVjdHJvbi11cGRhdGVyL25vZGVfbW9kdWxlcy9mcy1leHRyYS9saWIvcmVtb3ZlL2luZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9qcy15YW1sL2xpYi9qcy15YW1sL3NjaGVtYS9kZWZhdWx0X2Z1bGwuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2VsZWN0cm9uLWlzLWRldi9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZWxlY3Ryb24tdXBkYXRlci9vdXQvQXBwVXBkYXRlci5qcyIsIndlYnBhY2s6Ly8vZXh0ZXJuYWwgXCJjcnlwdG9cIiIsIndlYnBhY2s6Ly8vZXh0ZXJuYWwgXCJ1dGlsXCIiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2VsZWN0cm9uLXVwZGF0ZXIvbm9kZV9tb2R1bGVzL2ZzLWV4dHJhL2xpYi9qc29uL2pzb25maWxlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9qcy15YW1sL2luZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9qcy15YW1sL2xpYi9qcy15YW1sL3NjaGVtYS9mYWlsc2FmZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZWxlY3Ryb24tdXBkYXRlci9ub2RlX21vZHVsZXMvc291cmNlLW1hcC1zdXBwb3J0L3JlZ2lzdGVyLmpzIiwid2VicGFjazovLy9leHRlcm5hbCBcImNoaWxkX3Byb2Nlc3NcIiIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZWxlY3Ryb24tdXBkYXRlci9vdXQvZGlmZmVyZW50aWFsRG93bmxvYWRlci9kb3dubG9hZFBsYW5CdWlsZGVyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9lbGVjdHJvbi1sb2cvbGliL3RyYW5zcG9ydHMvY29uc29sZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZWxlY3Ryb24tbG9nL2xpYi9mb3JtYXQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2JsdWViaXJkL2pzL3JlbGVhc2UvY2F0Y2hfZmlsdGVyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9ibHVlYmlyZC9qcy9yZWxlYXNlL25vZGViYWNrLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9lbGVjdHJvbi11cGRhdGVyL25vZGVfbW9kdWxlcy9idWlsZGVyLXV0aWwtcnVudGltZS9vdXQvQ2FuY2VsbGF0aW9uVG9rZW4uanMiLCJ3ZWJwYWNrOi8vL2V4dGVybmFsIFwiZXZlbnRzXCIiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2VsZWN0cm9uLXVwZGF0ZXIvbm9kZV9tb2R1bGVzL2J1aWxkZXItdXRpbC1ydW50aW1lL291dC9odHRwRXhlY3V0b3IuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2VsZWN0cm9uLXVwZGF0ZXIvbm9kZV9tb2R1bGVzL2RlYnVnL3NyYy9kZWJ1Zy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZWxlY3Ryb24tdXBkYXRlci9ub2RlX21vZHVsZXMvZnMtZXh0cmEvbGliL2ZzL2luZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9ncmFjZWZ1bC1mcy9mcy5qcyIsIndlYnBhY2s6Ly8vZXh0ZXJuYWwgXCJhc3NlcnRcIiIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZWxlY3Ryb24tdXBkYXRlci9ub2RlX21vZHVsZXMvZnMtZXh0cmEvbGliL2NvcHkvY29weS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZWxlY3Ryb24tdXBkYXRlci9ub2RlX21vZHVsZXMvZnMtZXh0cmEvbGliL21rZGlycy93aW4zMi5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZWxlY3Ryb24tdXBkYXRlci9ub2RlX21vZHVsZXMvZnMtZXh0cmEvbGliL3V0aWwvdXRpbWVzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9lbGVjdHJvbi11cGRhdGVyL25vZGVfbW9kdWxlcy9mcy1leHRyYS9saWIvY29weS1zeW5jL2luZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9lbGVjdHJvbi11cGRhdGVyL25vZGVfbW9kdWxlcy9mcy1leHRyYS9saWIvdXRpbC9idWZmZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2VsZWN0cm9uLXVwZGF0ZXIvbm9kZV9tb2R1bGVzL2J1aWxkZXItdXRpbC1ydW50aW1lL291dC9Qcm9ncmVzc0NhbGxiYWNrVHJhbnNmb3JtLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9qcy15YW1sL2xpYi9qcy15YW1sL3NjaGVtYS9jb3JlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9qcy15YW1sL2xpYi9qcy15YW1sL3NjaGVtYS9qc29uLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9zZW12ZXIvc2VtdmVyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9lbGVjdHJvbi11cGRhdGVyL25vZGVfbW9kdWxlcy9zb3VyY2UtbWFwL2xpYi9zb3VyY2UtbWFwLWdlbmVyYXRvci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZWxlY3Ryb24tdXBkYXRlci9ub2RlX21vZHVsZXMvc291cmNlLW1hcC9saWIvYmFzZTY0LXZscS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZWxlY3Ryb24tdXBkYXRlci9ub2RlX21vZHVsZXMvc291cmNlLW1hcC9saWIvYXJyYXktc2V0LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9lbGVjdHJvbi11cGRhdGVyL291dC9HZW5lcmljUHJvdmlkZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2VsZWN0cm9uLXVwZGF0ZXIvb3V0L0dpdEh1YlByb3ZpZGVyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9lbGVjdHJvbi11cGRhdGVyL291dC9CYXNlVXBkYXRlci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZWxlY3Ryb24tdXBkYXRlci9vdXQvZGlmZmVyZW50aWFsRG93bmxvYWRlci9GaWxlV2l0aEVtYmVkZGVkQmxvY2tNYXBEaWZmZXJlbnRpYWxEb3dubG9hZGVyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9lbGVjdHJvbi11cGRhdGVyL25vZGVfbW9kdWxlcy9idWlsZGVyLXV0aWwtcnVudGltZS9vdXQvYmxvY2tNYXBBcGkuanMiLCJ3ZWJwYWNrOi8vL2V4dGVybmFsIFwiemxpYlwiIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9lbGVjdHJvbi11cGRhdGVyL291dC9kaWZmZXJlbnRpYWxEb3dubG9hZGVyL0RpZmZlcmVudGlhbERvd25sb2FkZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2VsZWN0cm9uLXVwZGF0ZXIvb3V0L2RpZmZlcmVudGlhbERvd25sb2FkZXIvRGF0YVNwbGl0dGVyLmpzIiwid2VicGFjazovLy9leHRlcm5hbCBcImh0dHBcIiIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZWxlY3Ryb24tbG9nL2xpYi9vcmlnaW5hbC1jb25zb2xlLmpzIiwid2VicGFjazovLy8uL3NyYy9tYWluLnRzeCIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYmx1ZWJpcmQvanMvcmVsZWFzZS9wcm9taXNlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9ibHVlYmlyZC9qcy9yZWxlYXNlL2FzeW5jLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9ibHVlYmlyZC9qcy9yZWxlYXNlL3NjaGVkdWxlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9ibHVlYmlyZC9qcy9yZWxlYXNlL3F1ZXVlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9ibHVlYmlyZC9qcy9yZWxlYXNlL3RoZW5hYmxlcy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYmx1ZWJpcmQvanMvcmVsZWFzZS9wcm9taXNlX2FycmF5LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9ibHVlYmlyZC9qcy9yZWxlYXNlL2NvbnRleHQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2JsdWViaXJkL2pzL3JlbGVhc2UvZGVidWdnYWJpbGl0eS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYmx1ZWJpcmQvanMvcmVsZWFzZS9maW5hbGx5LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9ibHVlYmlyZC9qcy9yZWxlYXNlL21ldGhvZC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYmx1ZWJpcmQvanMvcmVsZWFzZS9iaW5kLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9ibHVlYmlyZC9qcy9yZWxlYXNlL2NhbmNlbC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYmx1ZWJpcmQvanMvcmVsZWFzZS9kaXJlY3RfcmVzb2x2ZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYmx1ZWJpcmQvanMvcmVsZWFzZS9zeW5jaHJvbm91c19pbnNwZWN0aW9uLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9ibHVlYmlyZC9qcy9yZWxlYXNlL2pvaW4uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2JsdWViaXJkL2pzL3JlbGVhc2UvbWFwLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9ibHVlYmlyZC9qcy9yZWxlYXNlL2NhbGxfZ2V0LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9ibHVlYmlyZC9qcy9yZWxlYXNlL3VzaW5nLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9ibHVlYmlyZC9qcy9yZWxlYXNlL3RpbWVycy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYmx1ZWJpcmQvanMvcmVsZWFzZS9nZW5lcmF0b3JzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9ibHVlYmlyZC9qcy9yZWxlYXNlL25vZGVpZnkuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2JsdWViaXJkL2pzL3JlbGVhc2UvcHJvbWlzaWZ5LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9ibHVlYmlyZC9qcy9yZWxlYXNlL3Byb3BzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9ibHVlYmlyZC9qcy9yZWxlYXNlL3JhY2UuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2JsdWViaXJkL2pzL3JlbGVhc2UvcmVkdWNlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9ibHVlYmlyZC9qcy9yZWxlYXNlL3NldHRsZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYmx1ZWJpcmQvanMvcmVsZWFzZS9zb21lLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9ibHVlYmlyZC9qcy9yZWxlYXNlL2ZpbHRlci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYmx1ZWJpcmQvanMvcmVsZWFzZS9lYWNoLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9ibHVlYmlyZC9qcy9yZWxlYXNlL2FueS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZWxlY3Ryb24tdXBkYXRlci9ub2RlX21vZHVsZXMvZGVidWcvc3JjL2luZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9lbGVjdHJvbi11cGRhdGVyL25vZGVfbW9kdWxlcy9kZWJ1Zy9zcmMvYnJvd3Nlci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbXMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2VsZWN0cm9uLXVwZGF0ZXIvbm9kZV9tb2R1bGVzL2RlYnVnL3NyYy9ub2RlLmpzIiwid2VicGFjazovLy9leHRlcm5hbCBcInR0eVwiIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9zdXBwb3J0cy1jb2xvci9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvaGFzLWZsYWcvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2VsZWN0cm9uLXVwZGF0ZXIvbm9kZV9tb2R1bGVzL2ZzLWV4dHJhL2xpYi9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZWxlY3Ryb24tdXBkYXRlci9ub2RlX21vZHVsZXMvZnMtZXh0cmEvbGliL3V0aWwvYXNzaWduLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9ncmFjZWZ1bC1mcy9wb2x5ZmlsbHMuanMiLCJ3ZWJwYWNrOi8vL2V4dGVybmFsIFwiY29uc3RhbnRzXCIiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2dyYWNlZnVsLWZzL2xlZ2FjeS1zdHJlYW1zLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9lbGVjdHJvbi11cGRhdGVyL25vZGVfbW9kdWxlcy9mcy1leHRyYS9saWIvY29weS9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZWxlY3Ryb24tdXBkYXRlci9ub2RlX21vZHVsZXMvZnMtZXh0cmEvbGliL21rZGlycy9ta2RpcnMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2VsZWN0cm9uLXVwZGF0ZXIvbm9kZV9tb2R1bGVzL2ZzLWV4dHJhL2xpYi9ta2RpcnMvbWtkaXJzLXN5bmMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2VsZWN0cm9uLXVwZGF0ZXIvbm9kZV9tb2R1bGVzL2ZzLWV4dHJhL2xpYi9jb3B5LXN5bmMvY29weS1zeW5jLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9lbGVjdHJvbi11cGRhdGVyL25vZGVfbW9kdWxlcy9mcy1leHRyYS9saWIvcmVtb3ZlL3JpbXJhZi5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZWxlY3Ryb24tdXBkYXRlci9ub2RlX21vZHVsZXMvZnMtZXh0cmEvbGliL2pzb24vaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2pzb25maWxlL2luZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9lbGVjdHJvbi11cGRhdGVyL25vZGVfbW9kdWxlcy9mcy1leHRyYS9saWIvanNvbi9vdXRwdXQtanNvbi5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZWxlY3Ryb24tdXBkYXRlci9ub2RlX21vZHVsZXMvZnMtZXh0cmEvbGliL2pzb24vb3V0cHV0LWpzb24tc3luYy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZWxlY3Ryb24tdXBkYXRlci9ub2RlX21vZHVsZXMvZnMtZXh0cmEvbGliL21vdmUvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2VsZWN0cm9uLXVwZGF0ZXIvbm9kZV9tb2R1bGVzL2ZzLWV4dHJhL2xpYi9tb3ZlLXN5bmMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2VsZWN0cm9uLXVwZGF0ZXIvbm9kZV9tb2R1bGVzL2ZzLWV4dHJhL2xpYi9lbXB0eS9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZWxlY3Ryb24tdXBkYXRlci9ub2RlX21vZHVsZXMvZnMtZXh0cmEvbGliL2Vuc3VyZS9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZWxlY3Ryb24tdXBkYXRlci9ub2RlX21vZHVsZXMvZnMtZXh0cmEvbGliL2Vuc3VyZS9maWxlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9lbGVjdHJvbi11cGRhdGVyL25vZGVfbW9kdWxlcy9mcy1leHRyYS9saWIvZW5zdXJlL2xpbmsuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2VsZWN0cm9uLXVwZGF0ZXIvbm9kZV9tb2R1bGVzL2ZzLWV4dHJhL2xpYi9lbnN1cmUvc3ltbGluay5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZWxlY3Ryb24tdXBkYXRlci9ub2RlX21vZHVsZXMvZnMtZXh0cmEvbGliL2Vuc3VyZS9zeW1saW5rLXBhdGhzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9lbGVjdHJvbi11cGRhdGVyL25vZGVfbW9kdWxlcy9mcy1leHRyYS9saWIvZW5zdXJlL3N5bWxpbmstdHlwZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZWxlY3Ryb24tdXBkYXRlci9ub2RlX21vZHVsZXMvZnMtZXh0cmEvbGliL291dHB1dC9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZWxlY3Ryb24tdXBkYXRlci9ub2RlX21vZHVsZXMvYnVpbGRlci11dGlsLXJ1bnRpbWUvb3V0L3B1Ymxpc2hPcHRpb25zLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9lbGVjdHJvbi11cGRhdGVyL25vZGVfbW9kdWxlcy9idWlsZGVyLXV0aWwtcnVudGltZS9vdXQvcmZjMjI1M1BhcnNlci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZWxlY3Ryb24tdXBkYXRlci9ub2RlX21vZHVsZXMvYnVpbGRlci11dGlsLXJ1bnRpbWUvb3V0L3V1aWQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2VsZWN0cm9uLXVwZGF0ZXIvbm9kZV9tb2R1bGVzL2J1aWxkZXItdXRpbC1ydW50aW1lL291dC94bWwuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3NheC9saWIvc2F4LmpzIiwid2VicGFjazovLy9leHRlcm5hbCBcInN0cmluZ19kZWNvZGVyXCIiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2pzLXlhbWwvbGliL2pzLXlhbWwuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2pzLXlhbWwvbGliL2pzLXlhbWwvbG9hZGVyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9qcy15YW1sL2xpYi9qcy15YW1sL21hcmsuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2pzLXlhbWwvbGliL2pzLXlhbWwvdHlwZS9zdHIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2pzLXlhbWwvbGliL2pzLXlhbWwvdHlwZS9zZXEuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2pzLXlhbWwvbGliL2pzLXlhbWwvdHlwZS9tYXAuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2pzLXlhbWwvbGliL2pzLXlhbWwvdHlwZS9udWxsLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9qcy15YW1sL2xpYi9qcy15YW1sL3R5cGUvYm9vbC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvanMteWFtbC9saWIvanMteWFtbC90eXBlL2ludC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvanMteWFtbC9saWIvanMteWFtbC90eXBlL2Zsb2F0LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9qcy15YW1sL2xpYi9qcy15YW1sL3R5cGUvdGltZXN0YW1wLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9qcy15YW1sL2xpYi9qcy15YW1sL3R5cGUvbWVyZ2UuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2pzLXlhbWwvbGliL2pzLXlhbWwvdHlwZS9iaW5hcnkuanMiLCJ3ZWJwYWNrOi8vL2V4dGVybmFsIFwiYnVmZmVyXCIiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2pzLXlhbWwvbGliL2pzLXlhbWwvdHlwZS9vbWFwLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9qcy15YW1sL2xpYi9qcy15YW1sL3R5cGUvcGFpcnMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2pzLXlhbWwvbGliL2pzLXlhbWwvdHlwZS9zZXQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2pzLXlhbWwvbGliL2pzLXlhbWwvdHlwZS9qcy91bmRlZmluZWQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2pzLXlhbWwvbGliL2pzLXlhbWwvdHlwZS9qcy9yZWdleHAuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2pzLXlhbWwvbGliL2pzLXlhbWwvdHlwZS9qcy9mdW5jdGlvbi5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZXNwcmltYS9kaXN0L2VzcHJpbWEuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2pzLXlhbWwvbGliL2pzLXlhbWwvZHVtcGVyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9lbGVjdHJvbi11cGRhdGVyL25vZGVfbW9kdWxlcy9sYXp5LXZhbC9vdXQvbWFpbi5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZWxlY3Ryb24tdXBkYXRlci9ub2RlX21vZHVsZXMvc291cmNlLW1hcC1zdXBwb3J0L3NvdXJjZS1tYXAtc3VwcG9ydC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZWxlY3Ryb24tdXBkYXRlci9ub2RlX21vZHVsZXMvc291cmNlLW1hcC9zb3VyY2UtbWFwLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9lbGVjdHJvbi11cGRhdGVyL25vZGVfbW9kdWxlcy9zb3VyY2UtbWFwL2xpYi9iYXNlNjQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2VsZWN0cm9uLXVwZGF0ZXIvbm9kZV9tb2R1bGVzL3NvdXJjZS1tYXAvbGliL21hcHBpbmctbGlzdC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZWxlY3Ryb24tdXBkYXRlci9ub2RlX21vZHVsZXMvc291cmNlLW1hcC9saWIvc291cmNlLW1hcC1jb25zdW1lci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZWxlY3Ryb24tdXBkYXRlci9ub2RlX21vZHVsZXMvc291cmNlLW1hcC9saWIvYmluYXJ5LXNlYXJjaC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZWxlY3Ryb24tdXBkYXRlci9ub2RlX21vZHVsZXMvc291cmNlLW1hcC9saWIvcXVpY2stc29ydC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZWxlY3Ryb24tdXBkYXRlci9ub2RlX21vZHVsZXMvc291cmNlLW1hcC9saWIvc291cmNlLW5vZGUuanMiLCJ3ZWJwYWNrOi8vL2V4dGVybmFsIFwibW9kdWxlXCIiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2VsZWN0cm9uLXVwZGF0ZXIvb3V0L2VsZWN0cm9uSHR0cEV4ZWN1dG9yLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9lbGVjdHJvbi11cGRhdGVyL291dC9wcm92aWRlckZhY3RvcnkuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2VsZWN0cm9uLXVwZGF0ZXIvb3V0L0JpbnRyYXlQcm92aWRlci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZWxlY3Ryb24tdXBkYXRlci9ub2RlX21vZHVsZXMvYnVpbGRlci11dGlsLXJ1bnRpbWUvb3V0L2JpbnRyYXkuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2VsZWN0cm9uLXVwZGF0ZXIvb3V0L1ByaXZhdGVHaXRIdWJQcm92aWRlci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZWxlY3Ryb24tdXBkYXRlci9vdXQvTnNpc1VwZGF0ZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2VsZWN0cm9uLXVwZGF0ZXIvb3V0L0Rvd25sb2FkZWRVcGRhdGVIZWxwZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC5pc2VxdWFsL2luZGV4LmpzIiwid2VicGFjazovLy8od2VicGFjaykvYnVpbGRpbi9tb2R1bGUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2VsZWN0cm9uLXVwZGF0ZXIvb3V0L2RpZmZlcmVudGlhbERvd25sb2FkZXIvbXVsdGlwbGVSYW5nZURvd25sb2FkZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2VsZWN0cm9uLXVwZGF0ZXIvb3V0L2RpZmZlcmVudGlhbERvd25sb2FkZXIvR2VuZXJpY0RpZmZlcmVudGlhbERvd25sb2FkZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2VsZWN0cm9uLXVwZGF0ZXIvb3V0L3dpbmRvd3NFeGVjdXRhYmxlQ29kZVNpZ25hdHVyZVZlcmlmaWVyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9lbGVjdHJvbi11cGRhdGVyL291dC9NYWNVcGRhdGVyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9lbGVjdHJvbi11cGRhdGVyL291dC9BcHBJbWFnZVVwZGF0ZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2VsZWN0cm9uLWxvZy9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZWxlY3Ryb24tbG9nL3JlbmRlcmVyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9lbGVjdHJvbi1sb2cvbWFpbi5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZWxlY3Ryb24tbG9nL2xpYi9sb2cuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2VsZWN0cm9uLWxvZy9saWIvdHJhbnNwb3J0cy9maWxlL2luZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9lbGVjdHJvbi1sb2cvbGliL3RyYW5zcG9ydHMvZmlsZS9maW5kLWxvZy1wYXRoLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9lbGVjdHJvbi1sb2cvbGliL3RyYW5zcG9ydHMvZmlsZS9nZXQtYXBwLW5hbWUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2VsZWN0cm9uLWxvZy9saWIvdHJhbnNwb3J0cy9sb2ctcy5qcyIsIndlYnBhY2s6Ly8vZXh0ZXJuYWwgXCJodHRwc1wiIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9lbGVjdHJvbi1sb2cvbGliL3RyYW5zcG9ydHMvcmVuZGVyZXItY29uc29sZS5qcyIsIndlYnBhY2s6Ly8vLi9wYWNrYWdlLmpzb24iXSwibmFtZXMiOlsiZXM1IiwicmVxdWlyZSIsImNhbkV2YWx1YXRlIiwibmF2aWdhdG9yIiwiZXJyb3JPYmoiLCJlIiwidHJ5Q2F0Y2hUYXJnZXQiLCJnbG9iYWxPYmplY3QiLCJzZWxmIiwid2luZG93IiwiZ2xvYmFsIiwidW5kZWZpbmVkIiwidHJ5Q2F0Y2hlciIsInRhcmdldCIsImFwcGx5IiwiYXJndW1lbnRzIiwidHJ5Q2F0Y2giLCJmbiIsImluaGVyaXRzIiwiQ2hpbGQiLCJQYXJlbnQiLCJoYXNQcm9wIiwiaGFzT3duUHJvcGVydHkiLCJUIiwiY29uc3RydWN0b3IiLCJjb25zdHJ1Y3RvciQiLCJwcm9wZXJ0eU5hbWUiLCJwcm90b3R5cGUiLCJjYWxsIiwiY2hhckF0IiwibGVuZ3RoIiwiaXNQcmltaXRpdmUiLCJ2YWwiLCJpc09iamVjdCIsInZhbHVlIiwibWF5YmVXcmFwQXNFcnJvciIsIm1heWJlRXJyb3IiLCJFcnJvciIsInNhZmVUb1N0cmluZyIsIndpdGhBcHBlbmRlZCIsImFwcGVuZGVlIiwibGVuIiwicmV0IiwiQXJyYXkiLCJpIiwiZ2V0RGF0YVByb3BlcnR5T3JEZWZhdWx0Iiwib2JqIiwia2V5IiwiZGVmYXVsdFZhbHVlIiwiaXNFUzUiLCJkZXNjIiwiT2JqZWN0IiwiZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yIiwiZ2V0Iiwic2V0Iiwibm90RW51bWVyYWJsZVByb3AiLCJuYW1lIiwiZGVzY3JpcHRvciIsImNvbmZpZ3VyYWJsZSIsImVudW1lcmFibGUiLCJ3cml0YWJsZSIsImRlZmluZVByb3BlcnR5IiwidGhyb3dlciIsInIiLCJpbmhlcml0ZWREYXRhS2V5cyIsImV4Y2x1ZGVkUHJvdG90eXBlcyIsIkZ1bmN0aW9uIiwiaXNFeGNsdWRlZFByb3RvIiwiZ2V0S2V5cyIsImdldE93blByb3BlcnR5TmFtZXMiLCJ2aXNpdGVkS2V5cyIsImNyZWF0ZSIsImtleXMiLCJwdXNoIiwiZ2V0UHJvdG90eXBlT2YiLCJlbnVtZXJhdGlvbiIsInRoaXNBc3NpZ25tZW50UGF0dGVybiIsImlzQ2xhc3MiLCJuYW1lcyIsImhhc01ldGhvZHMiLCJoYXNNZXRob2RzT3RoZXJUaGFuQ29uc3RydWN0b3IiLCJoYXNUaGlzQXNzaWdubWVudEFuZFN0YXRpY01ldGhvZHMiLCJ0ZXN0IiwidG9GYXN0UHJvcGVydGllcyIsIkZha2VDb25zdHJ1Y3RvciIsImwiLCJldmFsIiwicmlkZW50IiwiaXNJZGVudGlmaWVyIiwic3RyIiwiZmlsbGVkUmFuZ2UiLCJjb3VudCIsInByZWZpeCIsInN1ZmZpeCIsImlzRXJyb3IiLCJtZXNzYWdlIiwibWFya0FzT3JpZ2luYXRpbmdGcm9tUmVqZWN0aW9uIiwiaWdub3JlIiwib3JpZ2luYXRlc0Zyb21SZWplY3Rpb24iLCJPcGVyYXRpb25hbEVycm9yIiwiY2FuQXR0YWNoVHJhY2UiLCJwcm9wZXJ0eUlzV3JpdGFibGUiLCJlbnN1cmVFcnJvck9iamVjdCIsImVyciIsImNsYXNzU3RyaW5nIiwidG9TdHJpbmciLCJjb3B5RGVzY3JpcHRvcnMiLCJmcm9tIiwidG8iLCJmaWx0ZXIiLCJnZXREZXNjcmlwdG9yIiwiYXNBcnJheSIsInYiLCJpc0FycmF5IiwiU3ltYm9sIiwiaXRlcmF0b3IiLCJBcnJheUZyb20iLCJpdCIsIml0UmVzdWx0IiwibmV4dCIsImRvbmUiLCJpc05vZGUiLCJwcm9jZXNzIiwidG9Mb3dlckNhc2UiLCJoYXNFbnZWYXJpYWJsZXMiLCJlbnYiLCJnZXROYXRpdmVQcm9taXNlIiwiUHJvbWlzZSIsInByb21pc2UiLCJkb21haW5CaW5kIiwiY2IiLCJiaW5kIiwiaGFzRGV2VG9vbHMiLCJjaHJvbWUiLCJsb2FkVGltZXMiLCJpc1JlY2VudE5vZGUiLCJ2ZXJzaW9uIiwidmVyc2lvbnMiLCJub2RlIiwic3BsaXQiLCJtYXAiLCJOdW1iZXIiLCJsYXN0TGluZUVycm9yIiwibW9kdWxlIiwiZXhwb3J0cyIsIkJsdWViaXJkUHJvbWlzZSIsImNvbmZpZyIsImxvbmdTdGFja1RyYWNlcyIsImRlZmF1bHQiLCJfQ2FuY2VsbGF0aW9uVG9rZW4iLCJfbG9hZF9DYW5jZWxsYXRpb25Ub2tlbiIsIkNhbmNlbGxhdGlvblRva2VuIiwiQ2FuY2VsbGF0aW9uRXJyb3IiLCJfaHR0cEV4ZWN1dG9yIiwiX2xvYWRfaHR0cEV4ZWN1dG9yIiwiSHR0cEVycm9yIiwiY3JlYXRlSHR0cEVycm9yIiwiSHR0cEV4ZWN1dG9yIiwiRGlnZXN0VHJhbnNmb3JtIiwic2FmZUdldEhlYWRlciIsImNvbmZpZ3VyZVJlcXVlc3RPcHRpb25zIiwiY29uZmlndXJlUmVxdWVzdE9wdGlvbnNGcm9tVXJsIiwic2FmZVN0cmluZ2lmeUpzb24iLCJwYXJzZUpzb24iLCJfcHVibGlzaE9wdGlvbnMiLCJfbG9hZF9wdWJsaXNoT3B0aW9ucyIsImdldFMzTGlrZVByb3ZpZGVyQmFzZVVybCIsImdpdGh1YlVybCIsIl9yZmMyMjUzUGFyc2VyIiwiX2xvYWRfcmZjMjI1M1BhcnNlciIsInBhcnNlRG4iLCJfdXVpZCIsIl9sb2FkX3V1aWQiLCJVVUlEIiwiX1Byb2dyZXNzQ2FsbGJhY2tUcmFuc2Zvcm0iLCJfbG9hZF9Qcm9ncmVzc0NhbGxiYWNrVHJhbnNmb3JtIiwiUHJvZ3Jlc3NDYWxsYmFja1RyYW5zZm9ybSIsIl94bWwiLCJfbG9hZF94bWwiLCJwYXJzZVhtbCIsIlhFbGVtZW50IiwibmV3RXJyb3IiLCJjb2RlIiwiZXJyb3IiLCJZQU1MRXhjZXB0aW9uIiwiVFlQRV9DT05TVFJVQ1RPUl9PUFRJT05TIiwiWUFNTF9OT0RFX0tJTkRTIiwiY29tcGlsZVN0eWxlQWxpYXNlcyIsInJlc3VsdCIsImZvckVhY2giLCJzdHlsZSIsImFsaWFzIiwiU3RyaW5nIiwiVHlwZSIsInRhZyIsIm9wdGlvbnMiLCJpbmRleE9mIiwia2luZCIsInJlc29sdmUiLCJjb25zdHJ1Y3QiLCJkYXRhIiwiaW5zdGFuY2VPZiIsInByZWRpY2F0ZSIsInJlcHJlc2VudCIsImRlZmF1bHRTdHlsZSIsInN0eWxlQWxpYXNlcyIsImZzIiwicG9seWZpbGxzIiwibGVnYWN5IiwicXVldWUiLCJ1dGlsIiwibm9vcCIsImRlYnVnIiwiZGVidWdsb2ciLCJOT0RFX0RFQlVHIiwibSIsImZvcm1hdCIsImpvaW4iLCJjb25zb2xlIiwib24iLCJlcXVhbCIsInBhdGNoIiwiVEVTVF9HUkFDRUZVTF9GU19HTE9CQUxfUEFUQ0giLCJjbG9zZSIsImZzJGNsb3NlIiwiZmQiLCJyZXRyeSIsImNsb3NlU3luYyIsImZzJGNsb3NlU3luYyIsInJ2YWwiLCJncmFjZWZ1bGlmeSIsIkZpbGVSZWFkU3RyZWFtIiwiUmVhZFN0cmVhbSIsIkZpbGVXcml0ZVN0cmVhbSIsIldyaXRlU3RyZWFtIiwiY3JlYXRlUmVhZFN0cmVhbSIsImNyZWF0ZVdyaXRlU3RyZWFtIiwiZnMkcmVhZEZpbGUiLCJyZWFkRmlsZSIsInBhdGgiLCJnbyRyZWFkRmlsZSIsImVucXVldWUiLCJmcyR3cml0ZUZpbGUiLCJ3cml0ZUZpbGUiLCJnbyR3cml0ZUZpbGUiLCJmcyRhcHBlbmRGaWxlIiwiYXBwZW5kRmlsZSIsImdvJGFwcGVuZEZpbGUiLCJmcyRyZWFkZGlyIiwicmVhZGRpciIsImFyZ3MiLCJnbyRyZWFkZGlyJGNiIiwiZ28kcmVhZGRpciIsImZpbGVzIiwic29ydCIsInN1YnN0ciIsImxlZ1N0cmVhbXMiLCJmcyRSZWFkU3RyZWFtIiwib3BlbiIsIlJlYWRTdHJlYW0kb3BlbiIsImZzJFdyaXRlU3RyZWFtIiwiV3JpdGVTdHJlYW0kb3BlbiIsInRoYXQiLCJmbGFncyIsIm1vZGUiLCJhdXRvQ2xvc2UiLCJkZXN0cm95IiwiZW1pdCIsInJlYWQiLCJmcyRvcGVuIiwiZ28kb3BlbiIsImVsZW0iLCJzaGlmdCIsImZyb21DYWxsYmFjayIsInJlamVjdCIsInJlcyIsImZyb21Qcm9taXNlIiwidGhlbiIsInUiLCJta2RpcnMiLCJta2RpcnNTeW5jIiwibWtkaXJwIiwibWtkaXJwU3luYyIsImVuc3VyZURpciIsImVuc3VyZURpclN5bmMiLCJVcGRhdGVyU2lnbmFsIiwiVVBEQVRFX0RPV05MT0FERUQiLCJET1dOTE9BRF9QUk9HUkVTUyIsIlByb3ZpZGVyIiwiTm9PcExvZ2dlciIsIkFwcFVwZGF0ZXIiLCJfQXBwVXBkYXRlciIsIl9sb2FkX0FwcFVwZGF0ZXIiLCJfYnVpbGRlclV0aWxSdW50aW1lIiwiX2xvYWRfYnVpbGRlclV0aWxSdW50aW1lIiwiX1Byb3ZpZGVyIiwiX2xvYWRfUHJvdmlkZXIiLCJnZXREZWZhdWx0Q2hhbm5lbE5hbWUiLCJnZXRDdXN0b21DaGFubmVsTmFtZSIsImdldEN1cnJlbnRQbGF0Zm9ybSIsImlzVXNlT2xkTWFjUHJvdmlkZXIiLCJnZXRDaGFubmVsRmlsZW5hbWUiLCJuZXdCYXNlVXJsIiwibmV3VXJsRnJvbUJhc2UiLCJfdXJsIiwiX2xvYWRfdXJsIiwiX2F1dG9VcGRhdGVyIiwiX2xvYWRfYXV0b1VwZGF0ZXIiLCJwbGF0Zm9ybSIsIk5zaXNVcGRhdGVyIiwiTWFjVXBkYXRlciIsIkFwcEltYWdlVXBkYXRlciIsImdldENoYW5uZWxGaWxlUHJlZml4IiwiY3VycmVudFBsYXRmb3JtIiwiYXJjaCIsIlRFU1RfVVBEQVRFUl9BUkNIIiwiYXJjaFN1ZmZpeCIsImNoYW5uZWwiLCJURVNUX1VQREFURVJfUExBVEZPUk0iLCJlbWl0dGVyIiwibG9naW4iLCJoYW5kbGVyIiwiYWRkSGFuZGxlciIsInByb2dyZXNzIiwidXBkYXRlRG93bmxvYWRlZCIsInVwZGF0ZUNhbmNlbGxlZCIsImlzTG9nRXZlbnQiLCJldmVudCIsImxvZyIsInVybCIsIlVSTCIsInBhdGhuYW1lIiwiZW5kc1dpdGgiLCJiYXNlVXJsIiwic2VhcmNoIiwiZnNFeHRyYSIsIm1ha2VGcyIsIm1ldGhvZE5hbWUiLCJtZXRob2QiLCJtYXRjaCIsInByb21pc2lmeSIsImNyZWF0ZUZpbGUiLCJlbnN1cmVGaWxlIiwiT2JqZWN0ZnJlZXplIiwiZnJlZXplIiwic3ViRXJyb3IiLCJuYW1lUHJvcGVydHkiLCJkZWZhdWx0TWVzc2FnZSIsIlN1YkVycm9yIiwiY2FwdHVyZVN0YWNrVHJhY2UiLCJfVHlwZUVycm9yIiwiX1JhbmdlRXJyb3IiLCJXYXJuaW5nIiwiVGltZW91dEVycm9yIiwiQWdncmVnYXRlRXJyb3IiLCJUeXBlRXJyb3IiLCJSYW5nZUVycm9yIiwibWV0aG9kcyIsImxldmVsIiwiaW5kZW50IiwibGluZXMiLCJqIiwiY2F1c2UiLCJzdGFjayIsImVycm9yVHlwZXMiLCJSZWplY3Rpb25FcnJvciIsInBhdGhFeGlzdHMiLCJhY2Nlc3MiLCJjYXRjaCIsInBhdGhFeGlzdHNTeW5jIiwiZXhpc3RzU3luYyIsImZpbmRGaWxlIiwicGFyc2VVcGRhdGVJbmZvIiwiZ2V0RmlsZUxpc3QiLCJyZXNvbHZlRmlsZXMiLCJfanNZYW1sIiwiX2xvYWRfanNZYW1sIiwiX21haW4iLCJfbG9hZF9tYWluIiwiZXhlY3V0b3IiLCJ1c2VNdWx0aXBsZVJhbmdlUmVxdWVzdCIsImZpbGVFeHRyYURvd25sb2FkSGVhZGVycyIsInNldFJlcXVlc3RIZWFkZXJzIiwicmVxdWVzdEhlYWRlcnMiLCJodHRwUmVxdWVzdCIsImhlYWRlcnMiLCJjYW5jZWxsYXRpb25Ub2tlbiIsInJlcXVlc3QiLCJjcmVhdGVSZXF1ZXN0T3B0aW9ucyIsImFzc2lnbiIsInByb3RvY29sIiwiaG9zdG5hbWUiLCJwb3J0IiwiZXh0ZW5zaW9uIiwibm90IiwiZmluZCIsImZpbGVJbmZvIiwic29tZSIsImV4dCIsInJhd0RhdGEiLCJjaGFubmVsRmlsZSIsImNoYW5uZWxGaWxlVXJsIiwic2FmZUxvYWQiLCJ1cGRhdGVJbmZvIiwic2hhNTEyIiwicGF0aFRyYW5zZm9ybWVyIiwicCIsInNoYTIiLCJpbmZvIiwicGFja2FnZXMiLCJwYWNrYWdlSW5mbyIsImlhMzIiLCJocmVmIiwicHJvcCIsImhhcyIsInByb3RvIiwiT2JqZWN0S2V5cyIsIm8iLCJPYmplY3RHZXREZXNjcmlwdG9yIiwiT2JqZWN0RGVmaW5lUHJvcGVydHkiLCJPYmplY3RGcmVlemUiLCJPYmplY3RHZXRQcm90b3R5cGVPZiIsIkFycmF5SXNBcnJheSIsImlzTm90aGluZyIsInN1YmplY3QiLCJ0b0FycmF5Iiwic2VxdWVuY2UiLCJleHRlbmQiLCJzb3VyY2UiLCJpbmRleCIsInNvdXJjZUtleXMiLCJyZXBlYXQiLCJzdHJpbmciLCJjeWNsZSIsImlzTmVnYXRpdmVaZXJvIiwibnVtYmVyIiwiTkVHQVRJVkVfSU5GSU5JVFkiLCJjb21tb24iLCJjb21waWxlTGlzdCIsInNjaGVtYSIsImV4Y2x1ZGUiLCJpbmNsdWRlIiwiaW5jbHVkZWRTY2hlbWEiLCJjdXJyZW50VHlwZSIsInByZXZpb3VzVHlwZSIsInByZXZpb3VzSW5kZXgiLCJ0eXBlIiwiY29tcGlsZU1hcCIsInNjYWxhciIsIm1hcHBpbmciLCJmYWxsYmFjayIsImNvbGxlY3RUeXBlIiwiU2NoZW1hIiwiZGVmaW5pdGlvbiIsImltcGxpY2l0IiwiZXhwbGljaXQiLCJsb2FkS2luZCIsImNvbXBpbGVkSW1wbGljaXQiLCJjb21waWxlZEV4cGxpY2l0IiwiY29tcGlsZWRUeXBlTWFwIiwiREVGQVVMVCIsImNyZWF0ZVNjaGVtYSIsInNjaGVtYXMiLCJ0eXBlcyIsImV2ZXJ5IiwicmVhc29uIiwibWFyayIsImNvbXBhY3QiLCJnZXRBcmciLCJhQXJncyIsImFOYW1lIiwiYURlZmF1bHRWYWx1ZSIsInVybFJlZ2V4cCIsImRhdGFVcmxSZWdleHAiLCJ1cmxQYXJzZSIsImFVcmwiLCJzY2hlbWUiLCJhdXRoIiwiaG9zdCIsInVybEdlbmVyYXRlIiwiYVBhcnNlZFVybCIsIm5vcm1hbGl6ZSIsImFQYXRoIiwiaXNBYnNvbHV0ZSIsInBhcnRzIiwicGFydCIsInVwIiwic3BsaWNlIiwiYVJvb3QiLCJhUGF0aFVybCIsImFSb290VXJsIiwiam9pbmVkIiwicmVwbGFjZSIsInJlbGF0aXZlIiwibGFzdEluZGV4T2YiLCJzbGljZSIsInN1cHBvcnRzTnVsbFByb3RvIiwiaWRlbnRpdHkiLCJzIiwidG9TZXRTdHJpbmciLCJhU3RyIiwiaXNQcm90b1N0cmluZyIsImZyb21TZXRTdHJpbmciLCJjaGFyQ29kZUF0IiwiY29tcGFyZUJ5T3JpZ2luYWxQb3NpdGlvbnMiLCJtYXBwaW5nQSIsIm1hcHBpbmdCIiwib25seUNvbXBhcmVPcmlnaW5hbCIsImNtcCIsInN0cmNtcCIsIm9yaWdpbmFsTGluZSIsIm9yaWdpbmFsQ29sdW1uIiwiZ2VuZXJhdGVkQ29sdW1uIiwiZ2VuZXJhdGVkTGluZSIsImNvbXBhcmVCeUdlbmVyYXRlZFBvc2l0aW9uc0RlZmxhdGVkIiwib25seUNvbXBhcmVHZW5lcmF0ZWQiLCJhU3RyMSIsImFTdHIyIiwiY29tcGFyZUJ5R2VuZXJhdGVkUG9zaXRpb25zSW5mbGF0ZWQiLCJwYXJzZVNvdXJjZU1hcElucHV0IiwiSlNPTiIsInBhcnNlIiwiY29tcHV0ZVNvdXJjZVVSTCIsInNvdXJjZVJvb3QiLCJzb3VyY2VVUkwiLCJzb3VyY2VNYXBVUkwiLCJwYXJzZWQiLCJzdWJzdHJpbmciLCJyaW1yYWYiLCJyZW1vdmUiLCJyZW1vdmVTeW5jIiwic3luYyIsImdldEZyb21FbnYiLCJwYXJzZUludCIsIkVMRUNUUk9OX0lTX0RFViIsImlzRW52U2V0IiwiZGVmYXVsdEFwcCIsImV4ZWNQYXRoIiwiX2JsdWViaXJkTHN0IiwiX2xvYWRfYmx1ZWJpcmRMc3QiLCJfYmx1ZWJpcmRMc3QyIiwiX2xvYWRfYmx1ZWJpcmRMc3QyIiwiX2ludGVyb3BSZXF1aXJlRGVmYXVsdCIsIl9jcnlwdG8iLCJfbG9hZF9jcnlwdG8iLCJfZWxlY3Ryb24iLCJfbG9hZF9lbGVjdHJvbiIsIl9lbGVjdHJvbklzRGV2IiwiX2xvYWRfZWxlY3Ryb25Jc0RldiIsIl9ldmVudHMiLCJfbG9hZF9ldmVudHMiLCJfZnNFeHRyYVAiLCJfbG9hZF9mc0V4dHJhUCIsIl9sYXp5VmFsIiwiX2xvYWRfbGF6eVZhbCIsIl9wYXRoIiwiX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQiLCJfc2VtdmVyIiwiX2xvYWRfc2VtdmVyIiwiX2VsZWN0cm9uSHR0cEV4ZWN1dG9yIiwiX2xvYWRfZWxlY3Ryb25IdHRwRXhlY3V0b3IiLCJfR2VuZXJpY1Byb3ZpZGVyIiwiX2xvYWRfR2VuZXJpY1Byb3ZpZGVyIiwiX3Byb3ZpZGVyRmFjdG9yeSIsIl9sb2FkX3Byb3ZpZGVyRmFjdG9yeSIsIl9fZXNNb2R1bGUiLCJuZXdPYmoiLCJFdmVudEVtaXR0ZXIiLCJhcHAiLCJhdXRvRG93bmxvYWQiLCJhbGxvd1ByZXJlbGVhc2UiLCJmdWxsQ2hhbmdlbG9nIiwiYWxsb3dEb3duZ3JhZGUiLCJfY2hhbm5lbCIsIl9sb2dnZXIiLCJzaWduYWxzIiwidXBkYXRlQXZhaWxhYmxlIiwic3RhZ2luZ1VzZXJJZFByb21pc2UiLCJMYXp5IiwiZ2V0T3JDcmVhdGVTdGFnaW5nVXNlcklkIiwiY29uZmlnT25EaXNrIiwibG9hZFVwZGF0ZUNvbmZpZyIsIl9fdGVzdF9hcHAiLCJ1bnRpbEFwcFJlYWR5IiwiaHR0cEV4ZWN1dG9yIiwiRWxlY3Ryb25IdHRwRXhlY3V0b3IiLCJhdXRoSW5mbyIsImNhbGxiYWNrIiwiaXNSZWFkeSIsImN1cnJlbnRWZXJzaW9uU3RyaW5nIiwiZ2V0VmVyc2lvbiIsImN1cnJlbnRWZXJzaW9uIiwidmFsaWQiLCJoYXNQcmVyZWxlYXNlQ29tcG9uZW50cyIsInNldEZlZWRVUkwiLCJsb2dnZXIiLCJ1cGRhdGVDb25maWdQYXRoIiwiY2xpZW50UHJvbWlzZSIsIl9hcHBVcGRhdGVDb25maWdQYXRoIiwicHJvdmlkZXIiLCJnZXRGZWVkVVJMIiwiR2VuZXJpY1Byb3ZpZGVyIiwiY3JlYXRlQ2xpZW50IiwiY2hlY2tGb3JVcGRhdGVzIiwiY2hlY2tGb3JVcGRhdGVzUHJvbWlzZSIsIl9jaGVja0ZvclVwZGF0ZXMiLCJudWxsaXplUHJvbWlzZSIsImNoZWNrRm9yVXBkYXRlc0FuZE5vdGlmeSIsIk5vdGlmaWNhdGlvbiIsInRpdGxlIiwiYm9keSIsImdldE5hbWUiLCJzaG93IiwiaXNTdGFnaW5nTWF0Y2giLCJfdGhpcyIsImNvcm91dGluZSIsInJhd1N0YWdpbmdQZXJjZW50YWdlIiwic3RhZ2luZ1BlcmNlbnRhZ2UiLCJpc05hTiIsIndhcm4iLCJzdGFnaW5nVXNlcklkIiwicmVhZFVJbnQzMkJFIiwicGVyY2VudGFnZSIsIl90aGlzMiIsImRvQ2hlY2tGb3JVcGRhdGVzIiwiY29tcHV0ZUZpbmFsSGVhZGVycyIsIl90aGlzMyIsImNsaWVudCIsImdldExhdGVzdFZlcnNpb24iLCJsYXRlc3RWZXJzaW9uIiwiZXEiLCJndCIsInZlcnNpb25JbmZvIiwib25VcGRhdGVBdmFpbGFibGUiLCJkb3dubG9hZFByb21pc2UiLCJkb3dubG9hZFVwZGF0ZSIsIl90aGlzNCIsImRpc3BhdGNoRXJyb3IiLCJkb0Rvd25sb2FkVXBkYXRlIiwiX3RoaXM1IiwiZ2V0QXBwUGF0aCIsInJlc291cmNlc1BhdGgiLCJjb21wdXRlUmVxdWVzdEhlYWRlcnMiLCJfdGhpczYiLCJBY2NlcHQiLCJfdGhpczciLCJmaWxlIiwiZ2V0UGF0aCIsImlkIiwiY2hlY2siLCJ2NSIsInJhbmRvbUJ5dGVzIiwiT0lEIiwib3V0cHV0RmlsZSIsInZlcnNpb25QcmVyZWxlYXNlQ29tcG9uZW50IiwicHJlcmVsZWFzZSIsImpzb25GaWxlIiwicmVhZEpzb24iLCJyZWFkSnNvblN5bmMiLCJyZWFkRmlsZVN5bmMiLCJ3cml0ZUpzb24iLCJ3cml0ZUpzb25TeW5jIiwid3JpdGVGaWxlU3luYyIsInlhbWwiLCJpbnN0YWxsIiwiY29tcHV0ZU9wZXJhdGlvbnMiLCJPcGVyYXRpb25LaW5kIiwib2xkQmxvY2tNYXAiLCJuZXdCbG9ja01hcCIsIm5hbWVUb09sZEJsb2NrcyIsImJ1aWxkQmxvY2tGaWxlTWFwIiwibmFtZVRvTmV3QmxvY2tzIiwib2xkRW50cnlNYXAiLCJidWlsZEVudHJ5TWFwIiwibGFzdE9wZXJhdGlvbiIsIm9wZXJhdGlvbnMiLCJibG9ja01hcEZpbGUiLCJvbGRFbnRyeSIsIkRPV05MT0FEIiwic3RhcnQiLCJvZmZzZXQiLCJlbmQiLCJzaXplcyIsInJlZHVjZSIsImFjY3VtdWxhdG9yIiwiY3VycmVudFZhbHVlIiwibmV3RmlsZSIsImNoYW5nZWRCbG9ja0NvdW50IiwiY2hlY2tzdW1Ub09mZnNldCIsImNoZWNrc3VtVG9PbGRPZmZzZXQiLCJjaGVja3N1bVRvT2xkU2l6ZSIsImJ1aWxkQ2hlY2tzdW1NYXAiLCJuZXdPZmZzZXQiLCJjaGVja3N1bXMiLCJibG9ja1NpemUiLCJjaGVja3N1bSIsIm9sZE9mZnNldCIsIkNPUFkiLCJmaWxlT2Zmc2V0IiwiTWFwIiwiY2hlY2tzdW1Ub1NpemUiLCJzaXplIiwibGlzdCIsIml0ZW0iLCJvcmlnaW5hbENvbnNvbGUiLCJ0cmFuc3BvcnQiLCJtc2ciLCJ0ZXh0IiwiRU9MIiwiZm9ybWF0VGltZVpvbmUiLCJwYWQiLCJzdHJpbmdpZnlBcnJheSIsImZvcm1hdHRlciIsImRhdGUiLCJnZXRGdWxsWWVhciIsImdldE1vbnRoIiwiZ2V0RGF0ZSIsImdldEhvdXJzIiwiZ2V0TWludXRlcyIsImdldFNlY29uZHMiLCJnZXRNaWxsaXNlY29uZHMiLCJnZXRUaW1lem9uZU9mZnNldCIsImZvcm1hdEVycm9ycyIsImFyZyIsInplcm9zIiwibWludXRlc09mZnNldCIsIk1hdGgiLCJhYnMiLCJmbG9vciIsIk5FWFRfRklMVEVSIiwiY2F0Y2hGaWx0ZXIiLCJpbnN0YW5jZXMiLCJib3VuZFRvIiwiX2JvdW5kVmFsdWUiLCJwcmVkaWNhdGVMb29wIiwibWF0Y2hlc1ByZWRpY2F0ZSIsImVycm9ycyIsImlzVW50eXBlZEVycm9yIiwickVycm9yS2V5Iiwid3JhcEFzT3BlcmF0aW9uYWxFcnJvciIsIm5vZGViYWNrRm9yUHJvbWlzZSIsIm11bHRpQXJncyIsIndyYXBwZWQiLCJfYXR0YWNoRXh0cmFUcmFjZSIsIl9yZWplY3QiLCJfZnVsZmlsbCIsIiRfbGVuIiwibWF4IiwiJF9pIiwicGFyZW50IiwicGFyZW50Q2FuY2VsSGFuZGxlciIsIl9jYW5jZWxsZWQiLCJjYW5jZWxsZWQiLCJfcGFyZW50IiwicmVtb3ZlUGFyZW50Q2FuY2VsSGFuZGxlciIsImNhbmNlbCIsIm9uQ2FuY2VsIiwib25jZSIsImNyZWF0ZVByb21pc2UiLCJjYW5jZWxIYW5kbGVyIiwiYWRkZWRDYW5jZWxIYW5kbGVyIiwiZmluYWxseSIsInJlbW92ZUxpc3RlbmVyIiwiZGlzcG9zZSIsInJlbW92ZUFsbExpc3RlbmVycyIsIl9kZWJ1ZzIiLCJfc3RyZWFtIiwiX2xvYWRfc3RyZWFtIiwiX2luZGV4IiwiX2xvYWRfaW5kZXgiLCJyZXNwb25zZSIsImRlc2NyaXB0aW9uIiwic3RhdHVzQ29kZSIsInN0YXR1c01lc3NhZ2UiLCJzdHJpbmdpZnkiLCJIVFRQX1NUQVRVU19DT0RFUyIsIm1heFJlZGlyZWN0cyIsImVuY29kZWREYXRhIiwiQnVmZmVyIiwiZG9BcGlSZXF1ZXN0IiwicmVxdWVzdFByb2Nlc3NvciIsInJlZGlyZWN0Q291bnQiLCJlbmFibGVkIiwiZG9SZXF1ZXN0IiwiaGFuZGxlUmVzcG9uc2UiLCJhZGRFcnJvckFuZFRpbWVvdXRIYW5kbGVycyIsImFkZFJlZGlyZWN0SGFuZGxlcnMiLCJhYm9ydCIsImFkZFRpbWVPdXRIYW5kbGVyIiwicmVkaXJlY3RVcmwiLCJwcmVwYXJlUmVkaXJlY3RVcmxPcHRpb25zIiwic2V0RW5jb2RpbmciLCJjaHVuayIsImNvbnRlbnRUeXBlIiwiaXNKc29uIiwiaW5jbHVkZXMiLCJkb0Rvd25sb2FkIiwicmVxdWVzdE9wdGlvbnMiLCJkZXN0aW5hdGlvbiIsImNvbmZpZ3VyZVBpcGVzIiwic29ja2V0Iiwic2V0VGltZW91dCIsIm5ld09wdGlvbnMiLCJBdXRob3JpemF0aW9uIiwic3RhcnRzV2l0aCIsInBhcnNlZE5ld1VybCIsInBhcnNlZFVybCIsIlRyYW5zZm9ybSIsImV4cGVjdGVkIiwiYWxnb3JpdGhtIiwiZW5jb2RpbmciLCJpc1ZhbGlkYXRlT25FbmQiLCJkaWdlc3RlciIsImNyZWF0ZUhhc2giLCJhY3R1YWwiLCJfYWN0dWFsIiwiX3RyYW5zZm9ybSIsInVwZGF0ZSIsIl9mbHVzaCIsImRpZ2VzdCIsInZhbGlkYXRlIiwiY2hlY2tTaGEyIiwic2hhMkhlYWRlciIsImhlYWRlcktleSIsInN0cmVhbXMiLCJvblByb2dyZXNzIiwiY29udGVudExlbmd0aCIsImZpbGVPdXQiLCJsYXN0U3RyZWFtIiwic3RyZWFtIiwicGlwZSIsInRva2VuIiwiYXV0aG9yaXphdGlvbiIsImVsZWN0cm9uIiwic2tpcHBlZE5hbWVzIiwiY3JlYXRlRGVidWciLCJjb2VyY2UiLCJkaXNhYmxlIiwiZW5hYmxlIiwiaHVtYW5pemUiLCJza2lwcyIsImZvcm1hdHRlcnMiLCJzZWxlY3RDb2xvciIsIm5hbWVzcGFjZSIsImhhc2giLCJjb2xvcnMiLCJwcmV2VGltZSIsImN1cnIiLCJEYXRlIiwibXMiLCJkaWZmIiwicHJldiIsInVuc2hpZnQiLCJmb3JtYXRBcmdzIiwibG9nRm4iLCJ1c2VDb2xvcnMiLCJjb2xvciIsImluaXQiLCJuYW1lc3BhY2VzIiwic2F2ZSIsIlJlZ0V4cCIsImluc3RhbmNlIiwiYXBpIiwiZXhpc3RzIiwiZmlsZW5hbWUiLCJidWZmZXIiLCJwb3NpdGlvbiIsImJ5dGVzUmVhZCIsIndyaXRlIiwiYSIsImIiLCJjIiwiYnl0ZXNXcml0dGVuIiwiY2xvbmUiLCJjb3B5IiwiX19wcm90b19fIiwidXRpbWVzIiwidXRpbWVzTWlsbGlzIiwibm90RXhpc3QiLCJleGlzdHNSZWciLCJzcmMiLCJkZXN0Iiwib3B0cyIsImNsb2JiZXIiLCJvdmVyd3JpdGUiLCJwcmVzZXJ2ZVRpbWVzdGFtcHMiLCJoYW5kbGVGaWx0ZXIiLCJjaGVja1BhcmVudERpciIsImRlc3RQYXJlbnQiLCJkaXJuYW1lIiwiZGlyRXhpc3RzIiwic3RhcnRDb3B5IiwiZ2V0U3RhdHMiLCJvbkluY2x1ZGUiLCJzdGF0IiwiZGVyZWZlcmVuY2UiLCJsc3RhdCIsInN0IiwiaXNEaXJlY3RvcnkiLCJvbkRpciIsImlzRmlsZSIsImlzQ2hhcmFjdGVyRGV2aWNlIiwiaXNCbG9ja0RldmljZSIsIm9uRmlsZSIsImlzU3ltYm9saWNMaW5rIiwib25MaW5rIiwic3JjU3RhdCIsImNoZWNrRGVzdCIsInJlc29sdmVkUGF0aCIsImNvcHlGaWxlIiwibWF5Q29weUZpbGUiLCJ1bmxpbmsiLCJlcnJvck9uRXhpc3QiLCJzZXREZXN0TW9kZUFuZFRpbWVzdGFtcHMiLCJjb3B5RmlsZUZhbGxiYWNrIiwicnMiLCJ3cyIsImNobW9kIiwiYXRpbWUiLCJtdGltZSIsImlzU3JjU3ViZGlyIiwibWtEaXJBbmRDb3B5IiwibWF5Q29weURpciIsImNvcHlEaXIiLCJta2RpciIsIml0ZW1zIiwiY29weURpckl0ZW1zIiwicG9wIiwicmVhZGxpbmsiLCJyZXNvbHZlZFNyY1BhdGgiLCJjd2QiLCJyZXNvbHZlZERlc3RQYXRoIiwic3ltbGluayIsImNvcHlMaW5rIiwiYmFzZURpciIsInNlcCIsImRlc3RCYXNlbmFtZSIsImJhc2VuYW1lIiwiZ2V0Um9vdFBhdGgiLCJJTlZBTElEX1BBVEhfQ0hBUlMiLCJpbnZhbGlkV2luMzJQYXRoIiwicnAiLCJvcyIsImhhc01pbGxpc1Jlc1N5bmMiLCJ0bXBmaWxlIiwibm93IiwicmFuZG9tIiwidG1wZGlyIiwiZCIsIm9wZW5TeW5jIiwiZnV0aW1lc1N5bmMiLCJzdGF0U3luYyIsImhhc01pbGxpc1JlcyIsImZ1dGltZXMiLCJzdGF0cyIsInRpbWVSZW1vdmVNaWxsaXMiLCJ0aW1lc3RhbXAiLCJnZXRUaW1lIiwiZnV0aW1lc0VyciIsImNsb3NlRXJyIiwidXRpbWVzTWlsbGlzU3luYyIsImNvcHlTeW5jIiwiYWxsb2NVbnNhZmUiLCJ0b3RhbCIsInRyYW5zZmVycmVkIiwiZGVsdGEiLCJuZXh0VXBkYXRlIiwicGVyY2VudCIsImJ5dGVzUGVyU2Vjb25kIiwicm91bmQiLCJTZW1WZXIiLCJTRU1WRVJfU1BFQ19WRVJTSU9OIiwiTUFYX0xFTkdUSCIsIk1BWF9TQUZFX0lOVEVHRVIiLCJyZSIsIlIiLCJOVU1FUklDSURFTlRJRklFUiIsIk5VTUVSSUNJREVOVElGSUVSTE9PU0UiLCJOT05OVU1FUklDSURFTlRJRklFUiIsIk1BSU5WRVJTSU9OIiwiTUFJTlZFUlNJT05MT09TRSIsIlBSRVJFTEVBU0VJREVOVElGSUVSIiwiUFJFUkVMRUFTRUlERU5USUZJRVJMT09TRSIsIlBSRVJFTEVBU0UiLCJQUkVSRUxFQVNFTE9PU0UiLCJCVUlMRElERU5USUZJRVIiLCJCVUlMRCIsIkZVTEwiLCJGVUxMUExBSU4iLCJMT09TRVBMQUlOIiwiTE9PU0UiLCJHVExUIiwiWFJBTkdFSURFTlRJRklFUkxPT1NFIiwiWFJBTkdFSURFTlRJRklFUiIsIlhSQU5HRVBMQUlOIiwiWFJBTkdFUExBSU5MT09TRSIsIlhSQU5HRSIsIlhSQU5HRUxPT1NFIiwiTE9ORVRJTERFIiwiVElMREVUUklNIiwidGlsZGVUcmltUmVwbGFjZSIsIlRJTERFIiwiVElMREVMT09TRSIsIkxPTkVDQVJFVCIsIkNBUkVUVFJJTSIsImNhcmV0VHJpbVJlcGxhY2UiLCJDQVJFVCIsIkNBUkVUTE9PU0UiLCJDT01QQVJBVE9STE9PU0UiLCJDT01QQVJBVE9SIiwiQ09NUEFSQVRPUlRSSU0iLCJjb21wYXJhdG9yVHJpbVJlcGxhY2UiLCJIWVBIRU5SQU5HRSIsIkhZUEhFTlJBTkdFTE9PU0UiLCJTVEFSIiwibG9vc2UiLCJlciIsImNsZWFuIiwidHJpbSIsInJhdyIsIm1ham9yIiwibWlub3IiLCJudW0iLCJidWlsZCIsImNvbXBhcmUiLCJvdGhlciIsImNvbXBhcmVNYWluIiwiY29tcGFyZVByZSIsImNvbXBhcmVJZGVudGlmaWVycyIsImluYyIsInJlbGVhc2UiLCJpZGVudGlmaWVyIiwidmVyc2lvbjEiLCJ2ZXJzaW9uMiIsInYxIiwidjIiLCJudW1lcmljIiwiYW51bSIsImJudW0iLCJyY29tcGFyZUlkZW50aWZpZXJzIiwiY29tcGFyZUxvb3NlIiwicmNvbXBhcmUiLCJyc29ydCIsImx0IiwibmVxIiwiZ3RlIiwibHRlIiwib3AiLCJDb21wYXJhdG9yIiwiY29tcCIsInNlbXZlciIsIkFOWSIsIm9wZXJhdG9yIiwiaW50ZXJzZWN0cyIsInJhbmdlVG1wIiwiUmFuZ2UiLCJzYXRpc2ZpZXMiLCJzYW1lRGlyZWN0aW9uSW5jcmVhc2luZyIsInNhbWVEaXJlY3Rpb25EZWNyZWFzaW5nIiwic2FtZVNlbVZlciIsImRpZmZlcmVudERpcmVjdGlvbnNJbmNsdXNpdmUiLCJvcHBvc2l0ZURpcmVjdGlvbnNMZXNzVGhhbiIsIm9wcG9zaXRlRGlyZWN0aW9uc0dyZWF0ZXJUaGFuIiwicmFuZ2UiLCJwYXJzZVJhbmdlIiwiY29tcHMiLCJociIsImh5cGhlblJlcGxhY2UiLCJjb21wUmUiLCJwYXJzZUNvbXBhcmF0b3IiLCJ0aGlzQ29tcGFyYXRvcnMiLCJ0aGlzQ29tcGFyYXRvciIsInJhbmdlQ29tcGFyYXRvcnMiLCJyYW5nZUNvbXBhcmF0b3IiLCJ0b0NvbXBhcmF0b3JzIiwicmVwbGFjZUNhcmV0cyIsInJlcGxhY2VUaWxkZXMiLCJyZXBsYWNlWFJhbmdlcyIsInJlcGxhY2VTdGFycyIsImlzWCIsInJlcGxhY2VUaWxkZSIsIl8iLCJNIiwicHIiLCJyZXBsYWNlQ2FyZXQiLCJyZXBsYWNlWFJhbmdlIiwiZ3RsdCIsInhNIiwieG0iLCJ4cCIsImFueVgiLCIkMCIsImZNIiwiZm0iLCJmcCIsImZwciIsImZiIiwidE0iLCJ0bSIsInRwIiwidHByIiwidGIiLCJ0ZXN0U2V0IiwiYWxsb3dlZCIsIm1heFNhdGlzZnlpbmciLCJtYXhTViIsInJhbmdlT2JqIiwibWluU2F0aXNmeWluZyIsIm1pbiIsIm1pblNWIiwidmFsaWRSYW5nZSIsImx0ciIsIm91dHNpZGUiLCJndHIiLCJoaWxvIiwiZ3RmbiIsImx0ZWZuIiwibHRmbiIsImVjb21wIiwiY29tcGFyYXRvcnMiLCJoaWdoIiwibG93IiwiY29tcGFyYXRvciIsInIxIiwicjIiLCJiYXNlNjRWTFEiLCJBcnJheVNldCIsIk1hcHBpbmdMaXN0IiwiU291cmNlTWFwR2VuZXJhdG9yIiwiX2ZpbGUiLCJfc291cmNlUm9vdCIsIl9za2lwVmFsaWRhdGlvbiIsIl9zb3VyY2VzIiwiX25hbWVzIiwiX21hcHBpbmdzIiwiX3NvdXJjZXNDb250ZW50cyIsIl92ZXJzaW9uIiwiZnJvbVNvdXJjZU1hcCIsIlNvdXJjZU1hcEdlbmVyYXRvcl9mcm9tU291cmNlTWFwIiwiYVNvdXJjZU1hcENvbnN1bWVyIiwiZ2VuZXJhdG9yIiwiZWFjaE1hcHBpbmciLCJuZXdNYXBwaW5nIiwiZ2VuZXJhdGVkIiwibGluZSIsImNvbHVtbiIsIm9yaWdpbmFsIiwiYWRkTWFwcGluZyIsInNvdXJjZXMiLCJzb3VyY2VGaWxlIiwic291cmNlUmVsYXRpdmUiLCJhZGQiLCJjb250ZW50Iiwic291cmNlQ29udGVudEZvciIsInNldFNvdXJjZUNvbnRlbnQiLCJTb3VyY2VNYXBHZW5lcmF0b3JfYWRkTWFwcGluZyIsIl92YWxpZGF0ZU1hcHBpbmciLCJTb3VyY2VNYXBHZW5lcmF0b3Jfc2V0U291cmNlQ29udGVudCIsImFTb3VyY2VGaWxlIiwiYVNvdXJjZUNvbnRlbnQiLCJhcHBseVNvdXJjZU1hcCIsIlNvdXJjZU1hcEdlbmVyYXRvcl9hcHBseVNvdXJjZU1hcCIsImFTb3VyY2VNYXBQYXRoIiwibmV3U291cmNlcyIsIm5ld05hbWVzIiwidW5zb3J0ZWRGb3JFYWNoIiwib3JpZ2luYWxQb3NpdGlvbkZvciIsIlNvdXJjZU1hcEdlbmVyYXRvcl92YWxpZGF0ZU1hcHBpbmciLCJhR2VuZXJhdGVkIiwiYU9yaWdpbmFsIiwiYVNvdXJjZSIsIl9zZXJpYWxpemVNYXBwaW5ncyIsIlNvdXJjZU1hcEdlbmVyYXRvcl9zZXJpYWxpemVNYXBwaW5ncyIsInByZXZpb3VzR2VuZXJhdGVkQ29sdW1uIiwicHJldmlvdXNHZW5lcmF0ZWRMaW5lIiwicHJldmlvdXNPcmlnaW5hbENvbHVtbiIsInByZXZpb3VzT3JpZ2luYWxMaW5lIiwicHJldmlvdXNOYW1lIiwicHJldmlvdXNTb3VyY2UiLCJuYW1lSWR4Iiwic291cmNlSWR4IiwibWFwcGluZ3MiLCJlbmNvZGUiLCJfZ2VuZXJhdGVTb3VyY2VzQ29udGVudCIsIlNvdXJjZU1hcEdlbmVyYXRvcl9nZW5lcmF0ZVNvdXJjZXNDb250ZW50IiwiYVNvdXJjZXMiLCJhU291cmNlUm9vdCIsInRvSlNPTiIsIlNvdXJjZU1hcEdlbmVyYXRvcl90b0pTT04iLCJzb3VyY2VzQ29udGVudCIsIlNvdXJjZU1hcEdlbmVyYXRvcl90b1N0cmluZyIsImJhc2U2NCIsIlZMUV9CQVNFX1NISUZUIiwiVkxRX0JBU0UiLCJWTFFfQkFTRV9NQVNLIiwiVkxRX0NPTlRJTlVBVElPTl9CSVQiLCJ0b1ZMUVNpZ25lZCIsImFWYWx1ZSIsImZyb21WTFFTaWduZWQiLCJpc05lZ2F0aXZlIiwic2hpZnRlZCIsImJhc2U2NFZMUV9lbmNvZGUiLCJlbmNvZGVkIiwiZGlnaXQiLCJ2bHEiLCJkZWNvZGUiLCJiYXNlNjRWTFFfZGVjb2RlIiwiYUluZGV4IiwiYU91dFBhcmFtIiwic3RyTGVuIiwiY29udGludWF0aW9uIiwicmVzdCIsImhhc05hdGl2ZU1hcCIsIl9hcnJheSIsIl9zZXQiLCJmcm9tQXJyYXkiLCJBcnJheVNldF9mcm9tQXJyYXkiLCJhQXJyYXkiLCJhQWxsb3dEdXBsaWNhdGVzIiwiQXJyYXlTZXRfc2l6ZSIsIkFycmF5U2V0X2FkZCIsInNTdHIiLCJpc0R1cGxpY2F0ZSIsImlkeCIsIkFycmF5U2V0X2hhcyIsIkFycmF5U2V0X2luZGV4T2YiLCJhdCIsIkFycmF5U2V0X2F0IiwiYUlkeCIsIkFycmF5U2V0X3RvQXJyYXkiLCJjb25maWd1cmF0aW9uIiwidXBkYXRlciIsImNoYW5uZWxVcmwiLCJhdHRlbXB0TnVtYmVyIiwicmVsZWFzZUpzb25VcmwiLCJHaXRIdWJQcm92aWRlciIsIkJhc2VHaXRIdWJQcm92aWRlciIsImNvbXB1dGVSZWxlYXNlTm90ZXMiLCJkZWZhdWx0SG9zdCIsImNvbXB1dGVHaXRodWJCYXNlUGF0aCIsImJhc2VQYXRoIiwiZmVlZFhtbCIsImZlZWQiLCJsYXRlc3RSZWxlYXNlIiwiZWxlbWVudCIsImF0dHJpYnV0ZSIsImdldExhdGVzdFZlcnNpb25TdHJpbmciLCJnZXRCYXNlRG93bmxvYWRQYXRoIiwicmVsZWFzZU5hbWUiLCJlbGVtZW50VmFsdWVPckVtcHR5IiwicmVsZWFzZU5vdGVzIiwicmVsZWFzZUluZm8iLCJ0YWdfbmFtZSIsIm93bmVyIiwicmVwbyIsImZpbGVOYW1lIiwidlByZWZpeGVkVGFnTmFtZSIsImdldE5vdGVWYWx1ZSIsImlzRnVsbENoYW5nZWxvZyIsImdldEVsZW1lbnRzIiwidmVyc2lvblJlbGVhc2UiLCJub3RlIiwiQmFzZVVwZGF0ZXIiLCJfb3MiLCJfbG9hZF9vcyIsIl9Eb3dubG9hZGVkVXBkYXRlSGVscGVyIiwiX2xvYWRfRG93bmxvYWRlZFVwZGF0ZUhlbHBlciIsImRvd25sb2FkZWRVcGRhdGVIZWxwZXIiLCJEb3dubG9hZGVkVXBkYXRlSGVscGVyIiwicXVpdEFuZEluc3RhbGxDYWxsZWQiLCJxdWl0SGFuZGxlckFkZGVkIiwicXVpdEFuZEluc3RhbGwiLCJpc1NpbGVudCIsImlzRm9yY2VSdW5BZnRlciIsInNldEltbWVkaWF0ZSIsInF1aXQiLCJleGVjdXRlRG93bmxvYWQiLCJkb3dubG9hZE9wdGlvbnMiLCJ0YXNrIiwibGlzdGVuZXJDb3VudCIsInRlbXBEaXIiLCJta2R0ZW1wIiwiVEVTVF9BUFBfVE1QX0RJUiIsInJlbW92ZVRlbXBEaXJJZkFueSIsImNsZWFyIiwiZGVzdGluYXRpb25GaWxlIiwicG9zaXgiLCJpc1J1bkFmdGVyIiwiaW5zdGFsbGVyUGF0aCIsImRvSW5zdGFsbCIsImFkZFF1aXRIYW5kbGVyIiwiRmlsZVdpdGhFbWJlZGRlZEJsb2NrTWFwRGlmZmVyZW50aWFsRG93bmxvYWRlciIsIl9ibG9ja01hcEFwaSIsIl9sb2FkX2Jsb2NrTWFwQXBpIiwiX0RpZmZlcmVudGlhbERvd25sb2FkZXIiLCJfbG9hZF9EaWZmZXJlbnRpYWxEb3dubG9hZGVyIiwiRGlmZmVyZW50aWFsRG93bmxvYWRlciIsImRvd25sb2FkIiwiYmxvY2tBd2FyZUZpbGVJbmZvIiwiZmlsZVNpemUiLCJibG9ja01hcFNpemUiLCJmaWxlTWV0YWRhdGFCdWZmZXIiLCJyZWFkUmVtb3RlQnl0ZXMiLCJyZWFkQmxvY2tNYXAiLCJyZWFkRW1iZWRkZWRCbG9ja01hcERhdGEiLCJvbGRGaWxlIiwiQkxPQ0tfTUFQX0ZJTEVfTkFNRSIsIl9yZWYiLCJmc3RhdCIsInNpemVCdWZmZXIiLCJkYXRhQnVmZmVyIiwiaW5mbGF0ZVJhdyIsIl94IiwiRGlmZmVyZW50aWFsRG93bmxvYWRlck9wdGlvbnMiLCJfRGF0YVNwbGl0dGVyIiwiX2xvYWRfRGF0YVNwbGl0dGVyIiwiX2Rvd25sb2FkUGxhbkJ1aWxkZXIiLCJfbG9hZF9kb3dubG9hZFBsYW5CdWlsZGVyIiwiX211bHRpcGxlUmFuZ2VEb3dubG9hZGVyIiwiX2xvYWRfbXVsdGlwbGVSYW5nZURvd25sb2FkZXIiLCJiYXNlUmVxdWVzdE9wdGlvbnMiLCJuZXdVcmwiLCJzaWduYXR1cmVTaXplIiwiZG93bmxvYWRTaXplIiwiY29weVNpemUiLCJvcGVyYXRpb24iLCJuZXdQYWNrYWdlU2l6ZSIsImZvcm1hdEJ5dGVzIiwiZG93bmxvYWRGaWxlIiwidGFza3MiLCJzaWduYXR1cmUiLCJvbGRGaWxlRmQiLCJuZXdGaWxlRmQiLCJkaWdlc3RUcmFuc2Zvcm0iLCJmaXJzdFN0cmVhbSIsInciLCJleGVjdXRlVGFza3MiLCJhdHRlbXB0Q291bnQiLCJhY3R1YWxVcmwiLCJjb3B5RGF0YSIsInJlZGlyZWN0IiwicmVtb3ZlUXVlcnkiLCJmb2xsb3dSZWRpcmVjdCIsImVuZEluY2x1c2l2ZSIsImRhdGFIYW5kbGVyIiwiY2hlY2tJc1Jhbmdlc1N1cHBvcnRlZCIsInN5bWJvbCIsIkludGwiLCJOdW1iZXJGb3JtYXQiLCJ0b0ZpeGVkIiwiRGF0YVNwbGl0dGVyIiwiRE9VQkxFX0NSTEYiLCJSZWFkU3RhdGUiLCJvdXQiLCJyZWFkU3RyZWFtIiwiV3JpdGFibGUiLCJwYXJ0SW5kZXhUb1Rhc2tJbmRleCIsImJvdW5kYXJ5IiwicGFydEluZGV4VG9MZW5ndGgiLCJmaW5pc2hIYW5kbGVyIiwicGFydEluZGV4IiwiaGVhZGVyTGlzdEJ1ZmZlciIsInJlYWRTdGF0ZSIsIklOSVQiLCJpZ25vcmVCeXRlQ291bnQiLCJyZW1haW5pbmdQYXJ0RGF0YUNvdW50IiwiYWN0dWFsUGFydExlbmd0aCIsImJvdW5kYXJ5TGVuZ3RoIiwiaXNGaW5pc2hlZCIsIl93cml0ZSIsImhhbmRsZURhdGEiLCJ0b0lnbm9yZSIsInRvUmVhZCIsInByb2Nlc3NQYXJ0RGF0YSIsIkhFQURFUiIsImhlYWRlckxpc3RFbmQiLCJzZWFyY2hIZWFkZXJMaXN0RW5kIiwiQk9EWSIsInRhc2tJbmRleCIsInByZXZUYXNrSW5kZXgiLCJjb3B5RXhpc3RpbmdEYXRhIiwib25QYXJ0RW5kIiwicGFydExlbmd0aCIsImVmZmVjdGl2ZUVuZCIsInByb2Nlc3NQYXJ0U3RhcnRlZCIsInJlYWRPZmZzZXQiLCJwYXJ0aWFsQ2h1bmsiLCJjb25jYXQiLCJleHBlY3RlZExlbmd0aCIsImNvbnRleHQiLCJ2ZXJib3NlIiwic2lsbHkiLCJtYWtlU2VsZlJlc29sdXRpb25FcnJvciIsInJlZmxlY3RIYW5kbGVyIiwiUHJvbWlzZUluc3BlY3Rpb24iLCJfdGFyZ2V0IiwiYXBpUmVqZWN0aW9uIiwiUHJveHlhYmxlIiwiVU5ERUZJTkVEX0JJTkRJTkciLCJnZXREb21haW4iLCJkb21haW4iLCJBc3luYyIsImFzeW5jIiwiSU5URVJOQUwiLCJBUFBMWSIsInRyeUNvbnZlcnRUb1Byb21pc2UiLCJQcm9taXNlQXJyYXkiLCJDb250ZXh0IiwiY3JlYXRlQ29udGV4dCIsIkNhcHR1cmVkVHJhY2UiLCJQYXNzVGhyb3VnaEhhbmRsZXJDb250ZXh0IiwiX2JpdEZpZWxkIiwiX2Z1bGZpbGxtZW50SGFuZGxlcjAiLCJfcmVqZWN0aW9uSGFuZGxlcjAiLCJfcHJvbWlzZTAiLCJfcmVjZWl2ZXIwIiwiX3Jlc29sdmVGcm9tRXhlY3V0b3IiLCJfcHJvbWlzZUNyZWF0ZWQiLCJfZmlyZUV2ZW50IiwiY2F1Z2h0IiwiY2F0Y2hJbnN0YW5jZXMiLCJyZWZsZWN0IiwiX3RoZW4iLCJkaWRGdWxmaWxsIiwiZGlkUmVqZWN0Iiwid2FybmluZ3MiLCJfd2FybiIsIl9zZXRJc0ZpbmFsIiwic3ByZWFkIiwiYWxsIiwiaXNGdWxmaWxsZWQiLCJpc1JlamVjdGVkIiwiZnVsZmlsbG1lbnRWYWx1ZSIsInJlamVjdGlvblJlYXNvbiIsImdldE5ld0xpYnJhcnlDb3B5IiwiaXMiLCJmcm9tTm9kZSIsIl9jYXB0dXJlU3RhY2tUcmFjZSIsIl9yZWplY3RDYWxsYmFjayIsIl9pc0ZhdGVTZWFsZWQiLCJfc2V0QXN5bmNHdWFyYW50ZWVkIiwicHJvbWlzZXMiLCJjYXN0IiwiX3NldEZ1bGZpbGxlZCIsImZ1bGZpbGxlZCIsInJlamVjdGVkIiwic2V0U2NoZWR1bGVyIiwicmVjZWl2ZXIiLCJpbnRlcm5hbERhdGEiLCJoYXZlSW50ZXJuYWxEYXRhIiwiYml0RmllbGQiLCJfcHJvcGFnYXRlRnJvbSIsIl9ib3VuZFRvIiwic2V0dGxlciIsIl9zZXR0bGVQcm9taXNlQ3R4IiwiX3Vuc2V0UmVqZWN0aW9uSXNVbmhhbmRsZWQiLCJfc2V0dGxlUHJvbWlzZUxhdGVDYW5jZWxsYXRpb25PYnNlcnZlciIsImludm9rZSIsIl9hZGRDYWxsYmFja3MiLCJfbGVuZ3RoIiwiX2lzRm9sbG93aW5nIiwiX3NldExlbmd0aCIsIl9zZXRSZWplY3RlZCIsIl9zZXRGb2xsb3dpbmciLCJfaXNGaW5hbCIsIl91bnNldENhbmNlbGxlZCIsIl9zZXRDYW5jZWxsZWQiLCJfc2V0V2lsbEJlQ2FuY2VsbGVkIiwiaGFzQ3VzdG9tU2NoZWR1bGVyIiwiX3JlY2VpdmVyQXQiLCJfaXNCb3VuZCIsIl9wcm9taXNlQXQiLCJfZnVsZmlsbG1lbnRIYW5kbGVyQXQiLCJfcmVqZWN0aW9uSGFuZGxlckF0IiwiX21pZ3JhdGVDYWxsYmFjazAiLCJmb2xsb3dlciIsImZ1bGZpbGwiLCJfbWlncmF0ZUNhbGxiYWNrQXQiLCJiYXNlIiwiX3Byb3h5IiwicHJveHlhYmxlIiwiX3Jlc29sdmVDYWxsYmFjayIsInNob3VsZEJpbmQiLCJtYXliZVByb21pc2UiLCJfc2V0Rm9sbG93ZWUiLCJfdmFsdWUiLCJfcmVhc29uIiwic3luY2hyb25vdXMiLCJpZ25vcmVOb25FcnJvcldhcm5pbmdzIiwidHJhY2UiLCJoYXNTdGFjayIsIl9wdXNoQ29udGV4dCIsIl9leGVjdXRlIiwiX3BvcENvbnRleHQiLCJfc2V0dGxlUHJvbWlzZUZyb21IYW5kbGVyIiwieCIsInByb21pc2VDcmVhdGVkIiwiY2hlY2tGb3Jnb3R0ZW5SZXR1cm5zIiwiX2ZvbGxvd2VlIiwiX3NldHRsZVByb21pc2UiLCJpc1Byb21pc2UiLCJhc3luY0d1YXJhbnRlZWQiLCJfaW52b2tlSW50ZXJuYWxPbkNhbmNlbCIsImlzRmluYWxseUhhbmRsZXIiLCJjYW5jZWxQcm9taXNlIiwiX3Byb21pc2VDYW5jZWxsZWQiLCJfY2FuY2VsIiwiX2lzUmVzb2x2ZWQiLCJfcHJvbWlzZUZ1bGZpbGxlZCIsIl9wcm9taXNlUmVqZWN0ZWQiLCJjdHgiLCJfc2V0dGxlUHJvbWlzZTAiLCJfY2xlYXJDYWxsYmFja0RhdGFBdEluZGV4IiwiX3NldHRsZVByb21pc2VzIiwic2V0dGxlUHJvbWlzZXMiLCJmYXRhbEVycm9yIiwiX2Vuc3VyZVBvc3NpYmxlUmVqZWN0aW9uSGFuZGxlZCIsIl9mdWxmaWxsUHJvbWlzZXMiLCJfcmVqZWN0UHJvbWlzZXMiLCJfY2xlYXJDYW5jZWxsYXRpb25EYXRhIiwiX3NldHRsZWRWYWx1ZSIsImRlZmVyUmVzb2x2ZSIsImRlZmVyUmVqZWN0IiwiZGVmZXIiLCJwZW5kaW5nIiwiZGVwcmVjYXRlZCIsImZpbGxUeXBlcyIsInNldEJvdW5kcyIsImZpcnN0TGluZUVycm9yIiwic2NoZWR1bGUiLCJRdWV1ZSIsIl9jdXN0b21TY2hlZHVsZXIiLCJfaXNUaWNrVXNlZCIsIl9sYXRlUXVldWUiLCJfbm9ybWFsUXVldWUiLCJfaGF2ZURyYWluZWRRdWV1ZXMiLCJfdHJhbXBvbGluZUVuYWJsZWQiLCJkcmFpblF1ZXVlcyIsIl9kcmFpblF1ZXVlcyIsIl9zY2hlZHVsZSIsImVuYWJsZVRyYW1wb2xpbmUiLCJkaXNhYmxlVHJhbXBvbGluZUlmTmVjZXNzYXJ5IiwiaGF2ZUl0ZW1zUXVldWVkIiwic3RkZXJyIiwiZXhpdCIsInRocm93TGF0ZXIiLCJBc3luY0ludm9rZUxhdGVyIiwiX3F1ZXVlVGljayIsIkFzeW5jSW52b2tlIiwiQXN5bmNTZXR0bGVQcm9taXNlcyIsIl9wdXNoT25lIiwiaW52b2tlTGF0ZXIiLCJfZHJhaW5RdWV1ZSIsIl9yZXNldCIsIm5vQXN5bmNTY2hlZHVsZXIiLCJOYXRpdmVQcm9taXNlIiwiTXV0YXRpb25PYnNlcnZlciIsIkdsb2JhbFNldEltbWVkaWF0ZSIsIlByb2Nlc3NOZXh0VGljayIsIm5leHRUaWNrIiwibmF0aXZlUHJvbWlzZSIsInN0YW5kYWxvbmUiLCJjb3Jkb3ZhIiwiZGl2IiwiZG9jdW1lbnQiLCJjcmVhdGVFbGVtZW50IiwiYXR0cmlidXRlcyIsInRvZ2dsZVNjaGVkdWxlZCIsImRpdjIiLCJvMiIsImNsYXNzTGlzdCIsInRvZ2dsZSIsIm9ic2VydmUiLCJzY2hlZHVsZVRvZ2dsZSIsImRpc2Nvbm5lY3QiLCJhcnJheU1vdmUiLCJzcmNJbmRleCIsImRzdCIsImRzdEluZGV4IiwiY2FwYWNpdHkiLCJfY2FwYWNpdHkiLCJfZnJvbnQiLCJfd2lsbEJlT3ZlckNhcGFjaXR5IiwiX2NoZWNrQ2FwYWNpdHkiLCJ3cmFwTWFzayIsImZyb250IiwiX3Jlc2l6ZVRvIiwib2xkQ2FwYWNpdHkiLCJtb3ZlSXRlbXNDb3VudCIsImdldFRoZW4iLCJpc0FueUJsdWViaXJkUHJvbWlzZSIsImRvVGhlbmFibGUiLCJkb0dldFRoZW4iLCJ0b1Jlc29sdXRpb25WYWx1ZSIsInZhbHVlcyIsIl9wcm9taXNlIiwiX3NldE9uQ2FuY2VsIiwiX3ZhbHVlcyIsIl90b3RhbFJlc29sdmVkIiwiX2luaXQiLCJyZXNvbHZlVmFsdWVJZkVtcHR5IiwiX3Jlc29sdmVFbXB0eUFycmF5IiwiX3Jlc29sdmUiLCJfaXRlcmF0ZSIsImdldEFjdHVhbExlbmd0aCIsInNob3VsZENvcHlWYWx1ZXMiLCJpc1Jlc29sdmVkIiwic3VwcHJlc3NVbmhhbmRsZWRSZWplY3Rpb25zIiwiX2lzQ2FuY2VsbGFibGUiLCJ0b3RhbFJlc29sdmVkIiwiX3Jlc3VsdENhbmNlbGxlZCIsImNvbnRleHRTdGFjayIsIl9wZWVrQ29udGV4dCIsIl90cmFjZSIsInBlZWtDb250ZXh0IiwibGFzdEluZGV4IiwiZGVhY3RpdmF0ZUxvbmdTdGFja1RyYWNlcyIsImFjdGl2YXRlTG9uZ1N0YWNrVHJhY2VzIiwiUHJvbWlzZV9wdXNoQ29udGV4dCIsIlByb21pc2VfcG9wQ29udGV4dCIsIlByb21pc2VfUGVla0NvbnRleHQiLCJQcm9taXNlX3BlZWtDb250ZXh0IiwiUHJvbWlzZV9wcm9taXNlQ3JlYXRlZCIsIl9nZXREb21haW4iLCJfYXN5bmMiLCJ1bmhhbmRsZWRSZWplY3Rpb25IYW5kbGVkIiwicG9zc2libHlVbmhhbmRsZWRSZWplY3Rpb24iLCJibHVlYmlyZEZyYW1lUGF0dGVybiIsIm5vZGVGcmFtZVBhdHRlcm4iLCJwYXJzZUxpbmVQYXR0ZXJuIiwic3RhY2tGcmFtZVBhdHRlcm4iLCJmb3JtYXRTdGFjayIsImluZGVudFN0YWNrRnJhbWVzIiwicHJpbnRXYXJuaW5nIiwiZGVidWdnaW5nIiwid0ZvcmdvdHRlblJldHVybiIsIl9zZXRSZWplY3Rpb25Jc1VuaGFuZGxlZCIsIl9ub3RpZnlVbmhhbmRsZWRSZWplY3Rpb24iLCJfbm90aWZ5VW5oYW5kbGVkUmVqZWN0aW9uSXNIYW5kbGVkIiwiZmlyZVJlamVjdGlvbkV2ZW50IiwiX3NldFJldHVybmVkTm9uVW5kZWZpbmVkIiwiX3JldHVybmVkTm9uVW5kZWZpbmVkIiwiX2lzUmVqZWN0aW9uVW5oYW5kbGVkIiwiX3NldFVuaGFuZGxlZFJlamVjdGlvbklzTm90aWZpZWQiLCJfdW5zZXRVbmhhbmRsZWRSZWplY3Rpb25Jc05vdGlmaWVkIiwiX2lzVW5oYW5kbGVkUmVqZWN0aW9uTm90aWZpZWQiLCJzaG91bGRVc2VPd25UcmFjZSIsIm9uUG9zc2libHlVbmhhbmRsZWRSZWplY3Rpb24iLCJvblVuaGFuZGxlZFJlamVjdGlvbkhhbmRsZWQiLCJkaXNhYmxlTG9uZ1N0YWNrVHJhY2VzIiwibG9uZ1N0YWNrVHJhY2VzSXNTdXBwb3J0ZWQiLCJQcm9taXNlX2NhcHR1cmVTdGFja1RyYWNlIiwiUHJvbWlzZV9hdHRhY2hFeHRyYVRyYWNlIiwibG9uZ1N0YWNrVHJhY2VzQ2FwdHVyZVN0YWNrVHJhY2UiLCJsb25nU3RhY2tUcmFjZXNBdHRhY2hFeHRyYVRyYWNlIiwiaGFzTG9uZ1N0YWNrVHJhY2VzIiwiZmlyZURvbUV2ZW50IiwiQ3VzdG9tRXZlbnQiLCJkaXNwYXRjaEV2ZW50IiwiZG9tRXZlbnQiLCJkZXRhaWwiLCJjYW5jZWxhYmxlIiwiRXZlbnQiLCJjcmVhdGVFdmVudCIsImluaXRDdXN0b21FdmVudCIsImZpcmVHbG9iYWxFdmVudCIsImdlbmVyYXRlUHJvbWlzZUxpZmVjeWNsZUV2ZW50T2JqZWN0IiwiZXZlbnRUb09iamVjdEdlbmVyYXRvciIsInByb21pc2VGdWxmaWxsZWQiLCJwcm9taXNlUmVqZWN0ZWQiLCJwcm9taXNlUmVzb2x2ZWQiLCJwcm9taXNlQ2FuY2VsbGVkIiwicHJvbWlzZUNoYWluZWQiLCJjaGlsZCIsIndhcm5pbmciLCJ1bmhhbmRsZWRSZWplY3Rpb24iLCJyZWplY3Rpb25IYW5kbGVkIiwiYWN0aXZlRmlyZUV2ZW50IiwiZ2xvYmFsRXZlbnRGaXJlZCIsImRvbUV2ZW50RmlyZWQiLCJ3YXJuaW5nc09wdGlvbiIsImNhbmNlbGxhdGlvbiIsImNhbmNlbGxhdGlvbkNsZWFyQ2FuY2VsbGF0aW9uRGF0YSIsImNhbmNlbGxhdGlvblByb3BhZ2F0ZUZyb20iLCJfb25DYW5jZWwiLCJjYW5jZWxsYXRpb25PbkNhbmNlbCIsImNhbmNlbGxhdGlvblNldE9uQ2FuY2VsIiwiX2F0dGFjaENhbmNlbGxhdGlvbkNhbGxiYWNrIiwiY2FuY2VsbGF0aW9uQXR0YWNoQ2FuY2VsbGF0aW9uQ2FsbGJhY2siLCJjYW5jZWxsYXRpb25FeGVjdXRlIiwicHJvcGFnYXRlRnJvbUZ1bmN0aW9uIiwibW9uaXRvcmluZyIsImRlZmF1bHRGaXJlRXZlbnQiLCJwcmV2aW91c09uQ2FuY2VsIiwiX29uQ2FuY2VsRmllbGQiLCJfY2FuY2VsbGF0aW9uUGFyZW50IiwiYnJhbmNoZXNSZW1haW5pbmdUb0NhbmNlbCIsIl9icmFuY2hlc1JlbWFpbmluZ1RvQ2FuY2VsIiwiX3NldEJvdW5kVG8iLCJiaW5kaW5nUHJvcGFnYXRlRnJvbSIsImJvdW5kVmFsdWVGdW5jdGlvbiIsImlnbm9yZVNlbGYiLCJhdHRhY2hFeHRyYVRyYWNlIiwiX19zdGFja0NsZWFuZWRfXyIsInBhcnNlU3RhY2tBbmRNZXNzYWdlIiwicmV0dXJuVmFsdWUiLCJoYW5kbGVyTGluZSIsImNyZWF0b3JMaW5lIiwidHJhY2VMaW5lcyIsImNsZWFuU3RhY2siLCJsaW5lTWF0Y2hlcyIsImZpcnN0VXNlckxpbmUiLCJyZXBsYWNlbWVudCIsImZvcm1hdEFuZExvZ0Vycm9yIiwicmVjb25zdHJ1Y3RTdGFjayIsInN0YWNrcyIsInJlbW92ZUR1cGxpY2F0ZU9yRW1wdHlKdW1wcyIsInJlbW92ZUNvbW1vblJvb3RzIiwiY3VycmVudCIsImN1cnJlbnRMYXN0SW5kZXgiLCJjdXJyZW50TGFzdExpbmUiLCJjb21tb25Sb290TWVldFBvaW50IiwiaXNUcmFjZUxpbmUiLCJpc0ludGVybmFsRnJhbWUiLCJzaG91bGRJZ25vcmUiLCJzdGFja0ZyYW1lc0FzQXJyYXkiLCJpc1NvZnQiLCJsb2NhbEhhbmRsZXIiLCJsb2NhbEV2ZW50RmlyZWQiLCJmb3JtYXROb25FcnJvciIsInJ1c2VsZXNzVG9TdHJpbmciLCJuZXdTdHIiLCJzbmlwIiwibWF4Q2hhcnMiLCJwYXJzZUxpbmVJbmZvUmVnZXgiLCJwYXJzZUxpbmVJbmZvIiwibWF0Y2hlcyIsImZpcnN0U3RhY2tMaW5lcyIsImxhc3RTdGFja0xpbmVzIiwiZmlyc3RJbmRleCIsImZpcnN0RmlsZU5hbWUiLCJsYXN0RmlsZU5hbWUiLCJfcHJvbWlzZXNDcmVhdGVkIiwidW5jeWNsZSIsIm5vZGVzIiwic3RhY2tUb0luZGV4IiwiY3VycmVudFN0YWNrIiwiY3ljbGVFZGdlTm9kZSIsImN1cnJlbnRDaGlsZExlbmd0aCIsInN0YWNrRGV0ZWN0aW9uIiwidjhzdGFja0ZyYW1lUGF0dGVybiIsInY4c3RhY2tGb3JtYXR0ZXIiLCJzdGFja1RyYWNlTGltaXQiLCJpZ25vcmVVbnRpbCIsImhhc1N0YWNrQWZ0ZXJUaHJvdyIsImlzVFRZIiwiY2FsbGVkIiwiRmluYWxseUhhbmRsZXJDYW5jZWxSZWFjdGlvbiIsImZpbmFsbHlIYW5kbGVyIiwiY2hlY2tDYW5jZWwiLCJzdWNjZWVkIiwiZmFpbCIsInJlYXNvbk9yVmFsdWUiLCJfaXNDYW5jZWxsZWQiLCJpc1BlbmRpbmciLCJfcGFzc1Rocm91Z2giLCJzdWNjZXNzIiwibGFzdGx5IiwidGFwIiwidGFwQ2F0Y2giLCJoYW5kbGVyT3JQcmVkaWNhdGUiLCJfcmVzb2x2ZUZyb21TeW5jVmFsdWUiLCJhdHRlbXB0IiwiY2FsbGVkQmluZCIsInJlamVjdFRoaXMiLCJ0YXJnZXRSZWplY3RlZCIsInByb21pc2VSZWplY3Rpb25RdWV1ZWQiLCJiaW5kaW5nUHJvbWlzZSIsImJpbmRpbmdSZXNvbHZlZCIsInRoaXNBcmciLCJiaW5kaW5nUmVqZWN0ZWQiLCJfY2FuY2VsQnkiLCJfY2FuY2VsQnJhbmNoZWQiLCJfYnJhbmNoSGFzQ2FuY2VsbGVkIiwiX2Vub3VnaEJyYW5jaGVzSGF2ZUNhbmNlbGxlZCIsImNhbmNlbGxlciIsIl9pbnZva2VPbkNhbmNlbCIsIl9jYW5jZWxQcm9taXNlcyIsIl91bnNldE9uQ2FuY2VsIiwiaXNDYW5jZWxsYWJsZSIsImlzQ2FuY2VsbGVkIiwiX2RvSW52b2tlT25DYW5jZWwiLCJvbkNhbmNlbENhbGxiYWNrIiwiaW50ZXJuYWxPbmx5IiwicmV0dXJuZXIiLCJ0aGVuUmV0dXJuIiwidGhlblRocm93IiwiY2F0Y2hUaHJvdyIsImNhdGNoUmV0dXJuIiwiX3NldHRsZWRWYWx1ZUZpZWxkIiwiX19pc0NhbmNlbGxlZCIsInRoZW5DYWxsYmFjayIsInByb21pc2VTZXR0ZXIiLCJnZW5lcmF0ZUhvbGRlckNsYXNzIiwicHJvcHMiLCJhc3NpZ25tZW50IiwiY2FuY2VsbGF0aW9uQ29kZSIsInBhc3NlZEFyZ3VtZW50cyIsImhvbGRlckNsYXNzZXMiLCJ0aGVuQ2FsbGJhY2tzIiwicHJvbWlzZVNldHRlcnMiLCJsYXN0IiwiSG9sZGVyQ2xhc3MiLCJob2xkZXIiLCJjYWxsYmFja3MiLCJhc3luY05lZWRlZCIsIk1hcHBpbmdQcm9taXNlQXJyYXkiLCJsaW1pdCIsIl9maWx0ZXIiLCJfY2FsbGJhY2siLCJfcHJlc2VydmVkVmFsdWVzIiwiX2xpbWl0IiwiX2luRmxpZ2h0IiwiX3F1ZXVlIiwiX2FzeW5jSW5pdCIsIl9pbml0JCIsInByZXNlcnZlZFZhbHVlcyIsImJvb2xlYW5zIiwiY29uY3VycmVuY3kiLCJpc0Zpbml0ZSIsImNyIiwiY2FsbGVyQ2FjaGUiLCJnZXR0ZXJDYWNoZSIsImdldE1ldGhvZENhbGxlciIsImdldEdldHRlciIsIm1ha2VNZXRob2RDYWxsZXIiLCJlbnN1cmVNZXRob2QiLCJtYWtlR2V0dGVyIiwiZ2V0Q29tcGlsZWQiLCJjb21waWxlciIsImNhY2hlIiwiY2FsbGVyIiwibWF5YmVDYWxsZXIiLCJuYW1lZEdldHRlciIsImluZGV4ZWRHZXR0ZXIiLCJpc0luZGV4IiwiZ2V0dGVyIiwibWF5YmVHZXR0ZXIiLCJOVUxMIiwiY2FzdFByZXNlcnZpbmdEaXNwb3NhYmxlIiwidGhlbmFibGUiLCJfaXNEaXNwb3NhYmxlIiwiX2dldERpc3Bvc2VyIiwiX3NldERpc3Bvc2FibGUiLCJyZXNvdXJjZXMiLCJpbnNwZWN0aW9uIiwidHJ5RGlzcG9zZSIsIkRpc3Bvc2VyIiwiX2RhdGEiLCJfY29udGV4dCIsInJlc291cmNlIiwiZG9EaXNwb3NlIiwiX3Vuc2V0RGlzcG9zYWJsZSIsImlzRGlzcG9zZXIiLCJGdW5jdGlvbkRpc3Bvc2VyIiwibWF5YmVVbndyYXBEaXNwb3NlciIsIlJlc291cmNlTGlzdCIsInVzaW5nIiwiaW5wdXQiLCJzcHJlYWRBcmdzIiwiZGlzcG9zZXIiLCJyZWZsZWN0ZWRSZXNvdXJjZXMiLCJyZXN1bHRQcm9taXNlIiwiaW5zcGVjdGlvbnMiLCJfZGlzcG9zZXIiLCJIYW5kbGVXcmFwcGVyIiwiaGFuZGxlIiwiY2xlYXJUaW1lb3V0IiwiYWZ0ZXJWYWx1ZSIsImRlbGF5IiwiYWZ0ZXJUaW1lb3V0Iiwic3VjY2Vzc0NsZWFyIiwiZmFpbHVyZUNsZWFyIiwidGltZW91dCIsImhhbmRsZVdyYXBwZXIiLCJ0aW1lb3V0VGltZW91dCIsInlpZWxkSGFuZGxlcnMiLCJwcm9taXNlRnJvbVlpZWxkSGFuZGxlciIsInRyYWNlUGFyZW50IiwiUHJvbWlzZVNwYXduIiwiZ2VuZXJhdG9yRnVuY3Rpb24iLCJ5aWVsZEhhbmRsZXIiLCJpbnRlcm5hbCIsIl9maW5hbGx5UHJvbWlzZSIsIl9zdGFjayIsIl9nZW5lcmF0b3JGdW5jdGlvbiIsIl9yZWNlaXZlciIsIl9nZW5lcmF0b3IiLCJfeWllbGRIYW5kbGVycyIsIl95aWVsZGVkUHJvbWlzZSIsIl9jYW5jZWxsYXRpb25QaGFzZSIsIl9jbGVhbnVwIiwiaW1wbGVtZW50c1JldHVybiIsInJldHVyblNlbnRpbmVsIiwiX2NvbnRpbnVlIiwiX3J1biIsIlByb21pc2VTcGF3biQiLCJzcGF3biIsImFkZFlpZWxkSGFuZGxlciIsInNwcmVhZEFkYXB0ZXIiLCJub2RlYmFjayIsInN1Y2Nlc3NBZGFwdGVyIiwiZXJyb3JBZGFwdGVyIiwibmV3UmVhc29uIiwiYXNDYWxsYmFjayIsIm5vZGVpZnkiLCJhZGFwdGVyIiwiVEhJUyIsImRlZmF1bHRTdWZmaXgiLCJkZWZhdWx0UHJvbWlzaWZpZWQiLCJfX2lzUHJvbWlzaWZpZWRfXyIsIm5vQ29weVByb3BzIiwibm9Db3B5UHJvcHNQYXR0ZXJuIiwiZGVmYXVsdEZpbHRlciIsInByb3BzRmlsdGVyIiwiaXNQcm9taXNpZmllZCIsImhhc1Byb21pc2lmaWVkIiwiY2hlY2tWYWxpZCIsInN1ZmZpeFJlZ2V4cCIsImtleVdpdGhvdXRBc3luY1N1ZmZpeCIsInByb21pc2lmaWFibGVNZXRob2RzIiwicGFzc2VzRGVmYXVsdEZpbHRlciIsImVzY2FwZUlkZW50UmVnZXgiLCJtYWtlTm9kZVByb21pc2lmaWVkRXZhbCIsInN3aXRjaENhc2VBcmd1bWVudE9yZGVyIiwibGlrZWx5QXJndW1lbnRDb3VudCIsImFyZ3VtZW50U2VxdWVuY2UiLCJhcmd1bWVudENvdW50IiwicGFyYW1ldGVyRGVjbGFyYXRpb24iLCJwYXJhbWV0ZXJDb3VudCIsIm9yaWdpbmFsTmFtZSIsIm5ld1BhcmFtZXRlckNvdW50IiwiYXJndW1lbnRPcmRlciIsInNob3VsZFByb3h5VGhpcyIsImdlbmVyYXRlQ2FsbEZvckFyZ3VtZW50Q291bnQiLCJjb21tYSIsImdlbmVyYXRlQXJndW1lbnRTd2l0Y2hDYXNlIiwiZ2V0RnVuY3Rpb25Db2RlIiwibWFrZU5vZGVQcm9taXNpZmllZENsb3N1cmUiLCJfXyIsImRlZmF1bHRUaGlzIiwicHJvbWlzaWZpZWQiLCJtYWtlTm9kZVByb21pc2lmaWVkIiwicHJvbWlzaWZ5QWxsIiwicHJvbWlzaWZpZXIiLCJwcm9taXNpZmllZEtleSIsIkVzNk1hcCIsIm1hcFRvRW50cmllcyIsImV4dHJhY3RFbnRyeSIsImVudHJpZXNUb01hcCIsImVudHJpZXMiLCJQcm9wZXJ0aWVzUHJvbWlzZUFycmF5IiwiaXNNYXAiLCJfaXNNYXAiLCJrZXlPZmZzZXQiLCJjYXN0VmFsdWUiLCJyYWNlTGF0ZXIiLCJhcnJheSIsInJhY2UiLCJSZWR1Y3Rpb25Qcm9taXNlQXJyYXkiLCJpbml0aWFsVmFsdWUiLCJfZWFjaCIsIl9mbiIsIl9pbml0aWFsVmFsdWUiLCJfY3VycmVudENhbmNlbGxhYmxlIiwiX2VhY2hWYWx1ZXMiLCJfZ290QWNjdW0iLCJhY2N1bSIsIl9lYWNoQ29tcGxldGUiLCJzZW5kZXIiLCJfcmVzdWx0Q2FuY2VsbGVkJCIsImdvdEFjY3VtIiwiY29tcGxldGVkIiwidmFsdWVPclJlYXNvbiIsImdvdFZhbHVlIiwiU2V0dGxlZFByb21pc2VBcnJheSIsIl9wcm9taXNlUmVzb2x2ZWQiLCJzZXR0bGUiLCJDQU5DRUxMQVRJT04iLCJTb21lUHJvbWlzZUFycmF5IiwiX2hvd01hbnkiLCJfdW53cmFwIiwiX2luaXRpYWxpemVkIiwiaXNBcnJheVJlc29sdmVkIiwiX2NhblBvc3NpYmx5RnVsZmlsbCIsIl9nZXRSYW5nZUVycm9yIiwic2V0VW53cmFwIiwiaG93TWFueSIsInNldEhvd01hbnkiLCJfYWRkRnVsZmlsbGVkIiwiX2Z1bGZpbGxlZCIsIl9hZGRSZWplY3RlZCIsIl9jaGVja091dGNvbWUiLCJfcmVqZWN0ZWQiLCJfU29tZVByb21pc2VBcnJheSIsIlByb21pc2VNYXAiLCJQcm9taXNlUmVkdWNlIiwiUHJvbWlzZUFsbCIsInByb21pc2VBbGxUaGlzIiwiUHJvbWlzZU1hcFNlcmllcyIsImVhY2giLCJtYXBTZXJpZXMiLCJhbnkiLCJsb2FkIiwic3RvcmFnZSIsImxvY2FsIiwibG9jYWxzdG9yYWdlIiwidXNlckFnZW50IiwiZG9jdW1lbnRFbGVtZW50IiwiV2Via2l0QXBwZWFyYW5jZSIsImZpcmVidWciLCJleGNlcHRpb24iLCJ0YWJsZSIsIiQxIiwibGFzdEMiLCJyZW1vdmVJdGVtIiwiREVCVUciLCJsb2NhbFN0b3JhZ2UiLCJoIiwieSIsImxvbmciLCJmbXRMb25nIiwiZm10U2hvcnQiLCJleGVjIiwibiIsInBhcnNlRmxvYXQiLCJwbHVyYWwiLCJjZWlsIiwidHR5Iiwic3VwcG9ydHNDb2xvciIsImluc3BlY3RPcHRzIiwiayIsInRvVXBwZXJDYXNlIiwiQm9vbGVhbiIsImlzYXR0eSIsImluc3BlY3QiLCJPIiwiY29sb3JDb2RlIiwiaGlkZURhdGUiLCJ0b0lTT1N0cmluZyIsImhhc0ZsYWciLCJzdXBwb3J0IiwiaGFzQmFzaWMiLCJoYXMyNTYiLCJoYXMxNm0iLCJzdXBwb3J0TGV2ZWwiLCJzdGRvdXQiLCJvc1JlbGVhc2UiLCJzaWduIiwiQ0lfTkFNRSIsIlRFQU1DSVRZX1ZFUlNJT04iLCJURVJNX1BST0dSQU1fVkVSU0lPTiIsIlRFUk1fUFJPR1JBTSIsIlRFUk0iLCJGT1JDRV9DT0xPUiIsImZsYWciLCJhcmd2IiwidGVybWluYXRvclBvcyIsInBvcyIsImNvbnN0YW50cyIsIm9yaWdDd2QiLCJHUkFDRUZVTF9GU19QTEFURk9STSIsImNoZGlyIiwicGF0Y2hMY2htb2QiLCJsdXRpbWVzIiwicGF0Y2hMdXRpbWVzIiwiY2hvd24iLCJjaG93bkZpeCIsImZjaG93biIsImxjaG93biIsImNobW9kRml4IiwiZmNobW9kIiwibGNobW9kIiwiY2hvd25TeW5jIiwiY2hvd25GaXhTeW5jIiwiZmNob3duU3luYyIsImxjaG93blN5bmMiLCJjaG1vZFN5bmMiLCJjaG1vZEZpeFN5bmMiLCJmY2htb2RTeW5jIiwibGNobW9kU3luYyIsInN0YXRGaXgiLCJzdGF0Rml4U3luYyIsImZzdGF0U3luYyIsImxzdGF0U3luYyIsInVpZCIsImdpZCIsInJlbmFtZSIsImZzJHJlbmFtZSIsImJhY2tvZmYiLCJDQiIsInN0YXRlciIsImZzJHJlYWQiLCJjYWxsYmFja18iLCJlYWdDb3VudGVyIiwicmVhZFN5bmMiLCJmcyRyZWFkU3luYyIsIk9fV1JPTkxZIiwiT19TWU1MSU5LIiwiZXJyMiIsInRocmV3IiwibXQiLCJlcjIiLCJsdXRpbWVzU3luYyIsIl9hIiwiX2IiLCJfYyIsIm9yaWciLCJjaG93bkVyT2siLCJub25yb290IiwiZ2V0dWlkIiwiU3RyZWFtIiwicmVhZGFibGUiLCJwYXVzZWQiLCJidWZmZXJTaXplIiwiSW5maW5pdHkiLCJfcmVhZCIsImJ1c3kiLCJfb3BlbiIsImZsdXNoIiwibzc3NyIsIm1hZGUiLCJlcnJJbnZhbCIsInhmcyIsInVtYXNrIiwibWtkaXJTeW5jIiwiZXJyMCIsImVycjEiLCJ1dGltZXNTeW5jIiwidW5saW5rU3luYyIsImNvcHlGaWxlU3luYyIsIkJVRl9MRU5HVEgiLCJfYnVmZiIsImZkciIsImZkdyIsIndyaXRlU3luYyIsInJlYWRkaXJTeW5jIiwicmVhZGxpbmtTeW5jIiwic3ltbGlua1N5bmMiLCJhc3NlcnQiLCJpc1dpbmRvd3MiLCJkZWZhdWx0cyIsIm1heEJ1c3lUcmllcyIsImJ1c3lUcmllcyIsInJpbXJhZl8iLCJ0aW1lIiwiZml4V2luRVBFUk0iLCJybWRpciIsImVyMyIsImZpeFdpbkVQRVJNU3luYyIsInJtZGlyU3luYyIsIm9yaWdpbmFsRXIiLCJybWtpZHMiLCJlcnJTdGF0ZSIsImYiLCJyaW1yYWZTeW5jIiwicm1raWRzU3luYyIsInJldHJpZXMiLCJvdXRwdXRKc29uIiwib3V0cHV0SnNvblN5bmMiLCJvdXRwdXRKU09OIiwib3V0cHV0SlNPTlN5bmMiLCJ3cml0ZUpTT04iLCJ3cml0ZUpTT05TeW5jIiwicmVhZEpTT04iLCJyZWFkSlNPTlN5bmMiLCJfZnMiLCJzaG91bGRUaHJvdyIsInRocm93cyIsInN0cmlwQm9tIiwicmV2aXZlciIsInNwYWNlcyIsInJlcGxhY2VyIiwiaXNCdWZmZXIiLCJqc29uZmlsZSIsImRpciIsIml0RG9lcyIsIm1vdmUiLCJpdElzIiwiZG9SZW5hbWUiLCJtb3ZlQWNyb3NzRGV2aWNlIiwibGluayIsIm1vdmVEaXJBY3Jvc3NEZXZpY2UiLCJtb3ZlRmlsZUFjcm9zc0RldmljZSIsImlucyIsIm91dHMiLCJvbkNsb3NlIiwibW92ZVN5bmMiLCJhY2Nlc3NTeW5jIiwidHJ5UmVuYW1lU3luYyIsInJlbmFtZVN5bmMiLCJtb3ZlU3luY0Fjcm9zc0RldmljZSIsImxpbmtTeW5jIiwibW92ZURpclN5bmNBY3Jvc3NEZXZpY2UiLCJtb3ZlRmlsZVN5bmNBY3Jvc3NEZXZpY2UiLCJ0cnlDb3B5U3luYyIsImVtcHR5RGlyIiwiZGVsZXRlSXRlbSIsImVtcHR5RGlyU3luYyIsImVtcHR5ZGlyU3luYyIsImVtcHR5ZGlyIiwiY3JlYXRlRmlsZVN5bmMiLCJlbnN1cmVGaWxlU3luYyIsImNyZWF0ZUxpbmsiLCJjcmVhdGVMaW5rU3luYyIsImVuc3VyZUxpbmsiLCJlbnN1cmVMaW5rU3luYyIsImNyZWF0ZVN5bWxpbmsiLCJjcmVhdGVTeW1saW5rU3luYyIsImVuc3VyZVN5bWxpbmsiLCJlbnN1cmVTeW1saW5rU3luYyIsIm1ha2VGaWxlIiwic3JjcGF0aCIsImRzdHBhdGgiLCJtYWtlTGluayIsImRlc3RpbmF0aW9uRXhpc3RzIiwiX21rZGlycyIsIl9zeW1saW5rUGF0aHMiLCJzeW1saW5rUGF0aHMiLCJzeW1saW5rUGF0aHNTeW5jIiwiX3N5bWxpbmtUeXBlIiwic3ltbGlua1R5cGUiLCJzeW1saW5rVHlwZVN5bmMiLCJ0b0RzdCIsInRvQ3dkIiwiZHN0ZGlyIiwicmVsYXRpdmVUb0RzdCIsIm91dHB1dEZpbGVTeW5jIiwiczNVcmwiLCJzcGFjZXNVcmwiLCJlbmRwb2ludCIsImJ1Y2tldCIsInJlZ2lvbiIsInNlcSIsInF1b3RlZCIsIm5leHROb25TcGFjZSIsImNoIiwib3JkIiwiZnJvbUNoYXJDb2RlIiwibmlsIiwiaW52YWxpZE5hbWUiLCJtb3JlVGhhbjEwMDAwIiwicmFuZG9tSG9zdCIsInNlZWQiLCJjbG9ja1NlcSIsImxhc3RNVGltZSIsImxhc3ROVGltZSIsImhleDJieXRlIiwiYnl0ZTJoZXgiLCJoZXgiLCJ1dWlkIiwiYXNjaWkiLCJiaW5hcnkiLCJ1dWlkVGltZUJhc2VkIiwidXVpZE5hbWVkIiwidG9CdWZmZXIiLCJ2YXJpYW50IiwiZ2V0VmFyaWFudCIsImJpdHMiLCJVdWlkRW5jb2RpbmciLCJub2RlSWQiLCJBU0NJSSIsIm1UaW1lIiwiblRpbWUiLCJteUNsb2NrU2VxIiwidGltZUxvdyIsInRpbWVIaWdoIiwiQklOQVJZIiwiT0JKRUNUIiwiaGFzaE1ldGhvZCIsIm5hbWVJc05vdEFTdHJpbmciLCJfc2F4IiwiX2xvYWRfc2F4IiwiaXNDRGF0YSIsImVsZW1lbnRzIiwiaXNWYWxpZE5hbWUiLCJyZW1vdmVBdHRyaWJ1dGUiLCJpZ25vcmVDYXNlIiwiZXJyb3JJZk1pc3NlZCIsImVsZW1lbnRPck51bGwiLCJpc05hbWVFcXVhbHMiLCJOQU1FX1JFR19FWFAiLCJlbGVtZW50TmFtZSIsInJvb3RFbGVtZW50IiwicGFyc2VyIiwib25vcGVudGFnIiwic2F4RWxlbWVudCIsIm9uY2xvc2V0YWciLCJvbnRleHQiLCJvbmNkYXRhIiwiY2RhdGEiLCJvbmVycm9yIiwic2F4Iiwic3RyaWN0Iiwib3B0IiwiU0FYUGFyc2VyIiwiU0FYU3RyZWFtIiwiY3JlYXRlU3RyZWFtIiwiTUFYX0JVRkZFUl9MRU5HVEgiLCJidWZmZXJzIiwiRVZFTlRTIiwiY2xlYXJCdWZmZXJzIiwicSIsImJ1ZmZlckNoZWNrUG9zaXRpb24iLCJsb3dlcmNhc2UiLCJsb3dlcmNhc2V0YWdzIiwibG9vc2VDYXNlIiwidGFncyIsImNsb3NlZCIsImNsb3NlZFJvb3QiLCJzYXdSb290Iiwibm9zY3JpcHQiLCJzdGF0ZSIsIlMiLCJCRUdJTiIsInN0cmljdEVudGl0aWVzIiwiRU5USVRJRVMiLCJYTUxfRU5USVRJRVMiLCJhdHRyaWJMaXN0IiwieG1sbnMiLCJucyIsInJvb3ROUyIsInRyYWNrUG9zaXRpb24iLCJGIiwibmV3ZiIsImNoZWNrQnVmZmVyTGVuZ3RoIiwibWF4QWxsb3dlZCIsIm1heEFjdHVhbCIsImNsb3NlVGV4dCIsImVtaXROb2RlIiwic2NyaXB0IiwiZmx1c2hCdWZmZXJzIiwicmVzdW1lIiwiZXgiLCJzdHJlYW1XcmFwcyIsImV2IiwiX3BhcnNlciIsIm1lIiwib25lbmQiLCJfZGVjb2RlciIsIlNEIiwiU3RyaW5nRGVjb2RlciIsIkNEQVRBIiwiRE9DVFlQRSIsIlhNTF9OQU1FU1BBQ0UiLCJYTUxOU19OQU1FU1BBQ0UiLCJ4bWwiLCJuYW1lU3RhcnQiLCJuYW1lQm9keSIsImVudGl0eVN0YXJ0IiwiZW50aXR5Qm9keSIsImlzV2hpdGVzcGFjZSIsImlzUXVvdGUiLCJpc0F0dHJpYkVuZCIsImlzTWF0Y2giLCJyZWdleCIsIm5vdE1hdGNoIiwiU1RBVEUiLCJCRUdJTl9XSElURVNQQUNFIiwiVEVYVCIsIlRFWFRfRU5USVRZIiwiT1BFTl9XQUtBIiwiU0dNTF9ERUNMIiwiU0dNTF9ERUNMX1FVT1RFRCIsIkRPQ1RZUEVfUVVPVEVEIiwiRE9DVFlQRV9EVEQiLCJET0NUWVBFX0RURF9RVU9URUQiLCJDT01NRU5UX1NUQVJUSU5HIiwiQ09NTUVOVCIsIkNPTU1FTlRfRU5ESU5HIiwiQ09NTUVOVF9FTkRFRCIsIkNEQVRBX0VORElORyIsIkNEQVRBX0VORElOR18yIiwiUFJPQ19JTlNUIiwiUFJPQ19JTlNUX0JPRFkiLCJQUk9DX0lOU1RfRU5ESU5HIiwiT1BFTl9UQUciLCJPUEVOX1RBR19TTEFTSCIsIkFUVFJJQiIsIkFUVFJJQl9OQU1FIiwiQVRUUklCX05BTUVfU0FXX1dISVRFIiwiQVRUUklCX1ZBTFVFIiwiQVRUUklCX1ZBTFVFX1FVT1RFRCIsIkFUVFJJQl9WQUxVRV9DTE9TRUQiLCJBVFRSSUJfVkFMVUVfVU5RVU9URUQiLCJBVFRSSUJfVkFMVUVfRU5USVRZX1EiLCJBVFRSSUJfVkFMVUVfRU5USVRZX1UiLCJDTE9TRV9UQUciLCJDTE9TRV9UQUdfU0FXX1dISVRFIiwiU0NSSVBUIiwiU0NSSVBUX0VORElORyIsIm5vZGVUeXBlIiwidGV4dE5vZGUiLCJ0ZXh0b3B0cyIsInN0cmljdEZhaWwiLCJuZXdUYWciLCJ0YWdOYW1lIiwicW5hbWUiLCJxdWFsTmFtZSIsImF0dHJpYiIsImF0dHJpYk5hbWUiLCJhdHRyaWJWYWx1ZSIsInFuIiwib3BlblRhZyIsInNlbGZDbG9zaW5nIiwidXJpIiwibnYiLCJpc1NlbGZDbG9zaW5nIiwiY2xvc2VUYWciLCJ0IiwiY2xvc2VUbyIsInBhcnNlRW50aXR5IiwiZW50aXR5IiwiZW50aXR5TEMiLCJudW1TdHIiLCJmcm9tQ29kZVBvaW50IiwiYmVnaW5XaGl0ZVNwYWNlIiwic3RhcnRUYWdQb3NpdGlvbiIsInN0YXJ0aSIsInNnbWxEZWNsIiwicHJvY0luc3ROYW1lIiwicHJvY0luc3RCb2R5IiwiY29tbWVudCIsImRvY3R5cGUiLCJyZXR1cm5TdGF0ZSIsInN0cmluZ0Zyb21DaGFyQ29kZSIsIk1BWF9TSVpFIiwiY29kZVVuaXRzIiwiaGlnaFN1cnJvZ2F0ZSIsImxvd1N1cnJvZ2F0ZSIsImNvZGVQb2ludCIsImxvYWRlciIsImR1bXBlciIsIkZBSUxTQUZFX1NDSEVNQSIsIkpTT05fU0NIRU1BIiwiQ09SRV9TQ0hFTUEiLCJERUZBVUxUX1NBRkVfU0NIRU1BIiwiREVGQVVMVF9GVUxMX1NDSEVNQSIsImxvYWRBbGwiLCJzYWZlTG9hZEFsbCIsImR1bXAiLCJzYWZlRHVtcCIsIk1JTklNQUxfU0NIRU1BIiwiU0FGRV9TQ0hFTUEiLCJERUZBVUxUX1NDSEVNQSIsInNjYW4iLCJjb21wb3NlIiwiYWRkQ29uc3RydWN0b3IiLCJNYXJrIiwiX2hhc093blByb3BlcnR5IiwiQ09OVEVYVF9GTE9XX0lOIiwiQ09OVEVYVF9GTE9XX09VVCIsIkNPTlRFWFRfQkxPQ0tfSU4iLCJDT05URVhUX0JMT0NLX09VVCIsIkNIT01QSU5HX0NMSVAiLCJDSE9NUElOR19TVFJJUCIsIkNIT01QSU5HX0tFRVAiLCJQQVRURVJOX05PTl9QUklOVEFCTEUiLCJQQVRURVJOX05PTl9BU0NJSV9MSU5FX0JSRUFLUyIsIlBBVFRFUk5fRkxPV19JTkRJQ0FUT1JTIiwiUEFUVEVSTl9UQUdfSEFORExFIiwiUEFUVEVSTl9UQUdfVVJJIiwiaXNfRU9MIiwiaXNfV0hJVEVfU1BBQ0UiLCJpc19XU19PUl9FT0wiLCJpc19GTE9XX0lORElDQVRPUiIsImZyb21IZXhDb2RlIiwibGMiLCJlc2NhcGVkSGV4TGVuIiwiZnJvbURlY2ltYWxDb2RlIiwic2ltcGxlRXNjYXBlU2VxdWVuY2UiLCJjaGFyRnJvbUNvZGVwb2ludCIsInNpbXBsZUVzY2FwZUNoZWNrIiwic2ltcGxlRXNjYXBlTWFwIiwiU3RhdGUiLCJvbldhcm5pbmciLCJqc29uIiwibGlzdGVuZXIiLCJpbXBsaWNpdFR5cGVzIiwidHlwZU1hcCIsImxpbmVTdGFydCIsImxpbmVJbmRlbnQiLCJkb2N1bWVudHMiLCJnZW5lcmF0ZUVycm9yIiwidGhyb3dFcnJvciIsInRocm93V2FybmluZyIsImRpcmVjdGl2ZUhhbmRsZXJzIiwiWUFNTCIsImhhbmRsZVlhbWxEaXJlY3RpdmUiLCJjaGVja0xpbmVCcmVha3MiLCJUQUciLCJoYW5kbGVUYWdEaXJlY3RpdmUiLCJ0YWdNYXAiLCJjYXB0dXJlU2VnbWVudCIsImNoZWNrSnNvbiIsIl9wb3NpdGlvbiIsIl9jaGFyYWN0ZXIiLCJfcmVzdWx0IiwibWVyZ2VNYXBwaW5ncyIsIm92ZXJyaWRhYmxlS2V5cyIsInF1YW50aXR5Iiwic3RvcmVNYXBwaW5nUGFpciIsImtleVRhZyIsImtleU5vZGUiLCJ2YWx1ZU5vZGUiLCJzdGFydExpbmUiLCJzdGFydFBvcyIsInJlYWRMaW5lQnJlYWsiLCJza2lwU2VwYXJhdGlvblNwYWNlIiwiYWxsb3dDb21tZW50cyIsImNoZWNrSW5kZW50IiwibGluZUJyZWFrcyIsInRlc3REb2N1bWVudFNlcGFyYXRvciIsIndyaXRlRm9sZGVkTGluZXMiLCJyZWFkUGxhaW5TY2FsYXIiLCJub2RlSW5kZW50Iiwid2l0aGluRmxvd0NvbGxlY3Rpb24iLCJwcmVjZWRpbmciLCJmb2xsb3dpbmciLCJjYXB0dXJlU3RhcnQiLCJjYXB0dXJlRW5kIiwiaGFzUGVuZGluZ0NvbnRlbnQiLCJfbGluZSIsIl9saW5lU3RhcnQiLCJfbGluZUluZGVudCIsIl9raW5kIiwicmVhZFNpbmdsZVF1b3RlZFNjYWxhciIsInJlYWREb3VibGVRdW90ZWRTY2FsYXIiLCJoZXhMZW5ndGgiLCJoZXhSZXN1bHQiLCJ0bXAiLCJyZWFkRmxvd0NvbGxlY3Rpb24iLCJyZWFkTmV4dCIsIl90YWciLCJfYW5jaG9yIiwiYW5jaG9yIiwidGVybWluYXRvciIsImlzUGFpciIsImlzRXhwbGljaXRQYWlyIiwiaXNNYXBwaW5nIiwiYW5jaG9yTWFwIiwiY29tcG9zZU5vZGUiLCJyZWFkQmxvY2tTY2FsYXIiLCJmb2xkaW5nIiwiY2hvbXBpbmciLCJkaWRSZWFkQ29udGVudCIsImRldGVjdGVkSW5kZW50IiwidGV4dEluZGVudCIsImVtcHR5TGluZXMiLCJhdE1vcmVJbmRlbnRlZCIsInJlYWRCbG9ja1NlcXVlbmNlIiwiZGV0ZWN0ZWQiLCJyZWFkQmxvY2tNYXBwaW5nIiwiZmxvd0luZGVudCIsImFsbG93Q29tcGFjdCIsIl9wb3MiLCJhdEV4cGxpY2l0S2V5IiwicmVhZFRhZ1Byb3BlcnR5IiwiaXNWZXJiYXRpbSIsImlzTmFtZWQiLCJ0YWdIYW5kbGUiLCJyZWFkQW5jaG9yUHJvcGVydHkiLCJyZWFkQWxpYXMiLCJwYXJlbnRJbmRlbnQiLCJub2RlQ29udGV4dCIsImFsbG93VG9TZWVrIiwiYWxsb3dCbG9ja1N0eWxlcyIsImFsbG93QmxvY2tTY2FsYXJzIiwiYWxsb3dCbG9ja0NvbGxlY3Rpb25zIiwiaW5kZW50U3RhdHVzIiwiYXROZXdMaW5lIiwiaGFzQ29udGVudCIsInR5cGVJbmRleCIsInR5cGVRdWFudGl0eSIsImJsb2NrSW5kZW50IiwicmVhZERvY3VtZW50IiwiZG9jdW1lbnRTdGFydCIsImRpcmVjdGl2ZU5hbWUiLCJkaXJlY3RpdmVBcmdzIiwiaGFzRGlyZWN0aXZlcyIsImxvYWREb2N1bWVudHMiLCJvdXRwdXQiLCJnZXRTbmlwcGV0IiwibWF4TGVuZ3RoIiwiaGVhZCIsInRhaWwiLCJzbmlwcGV0Iiwid2hlcmUiLCJyZXNvbHZlWWFtbE51bGwiLCJjb25zdHJ1Y3RZYW1sTnVsbCIsImlzTnVsbCIsIm9iamVjdCIsImNhbm9uaWNhbCIsInVwcGVyY2FzZSIsImNhbWVsY2FzZSIsInJlc29sdmVZYW1sQm9vbGVhbiIsImNvbnN0cnVjdFlhbWxCb29sZWFuIiwiaXNCb29sZWFuIiwiaXNIZXhDb2RlIiwiaXNPY3RDb2RlIiwiaXNEZWNDb2RlIiwicmVzb2x2ZVlhbWxJbnRlZ2VyIiwiaGFzRGlnaXRzIiwiY29uc3RydWN0WWFtbEludGVnZXIiLCJkaWdpdHMiLCJpc0ludGVnZXIiLCJvY3RhbCIsImRlY2ltYWwiLCJoZXhhZGVjaW1hbCIsIllBTUxfRkxPQVRfUEFUVEVSTiIsInJlc29sdmVZYW1sRmxvYXQiLCJjb25zdHJ1Y3RZYW1sRmxvYXQiLCJQT1NJVElWRV9JTkZJTklUWSIsIk5hTiIsIlNDSUVOVElGSUNfV0lUSE9VVF9ET1QiLCJyZXByZXNlbnRZYW1sRmxvYXQiLCJpc0Zsb2F0IiwiWUFNTF9EQVRFX1JFR0VYUCIsIllBTUxfVElNRVNUQU1QX1JFR0VYUCIsInJlc29sdmVZYW1sVGltZXN0YW1wIiwiY29uc3RydWN0WWFtbFRpbWVzdGFtcCIsInllYXIiLCJtb250aCIsImRheSIsImhvdXIiLCJtaW51dGUiLCJzZWNvbmQiLCJmcmFjdGlvbiIsInR6X2hvdXIiLCJ0el9taW51dGUiLCJVVEMiLCJzZXRUaW1lIiwicmVwcmVzZW50WWFtbFRpbWVzdGFtcCIsInJlc29sdmVZYW1sTWVyZ2UiLCJOb2RlQnVmZmVyIiwiX3JlcXVpcmUiLCJCQVNFNjRfTUFQIiwicmVzb2x2ZVlhbWxCaW5hcnkiLCJiaXRsZW4iLCJjb25zdHJ1Y3RZYW1sQmluYXJ5IiwidGFpbGJpdHMiLCJyZXByZXNlbnRZYW1sQmluYXJ5IiwiaXNCaW5hcnkiLCJfdG9TdHJpbmciLCJyZXNvbHZlWWFtbE9tYXAiLCJvYmplY3RLZXlzIiwicGFpciIsInBhaXJLZXkiLCJwYWlySGFzS2V5IiwiY29uc3RydWN0WWFtbE9tYXAiLCJyZXNvbHZlWWFtbFBhaXJzIiwiY29uc3RydWN0WWFtbFBhaXJzIiwicmVzb2x2ZVlhbWxTZXQiLCJjb25zdHJ1Y3RZYW1sU2V0IiwicmVzb2x2ZUphdmFzY3JpcHRVbmRlZmluZWQiLCJjb25zdHJ1Y3RKYXZhc2NyaXB0VW5kZWZpbmVkIiwicmVwcmVzZW50SmF2YXNjcmlwdFVuZGVmaW5lZCIsImlzVW5kZWZpbmVkIiwicmVzb2x2ZUphdmFzY3JpcHRSZWdFeHAiLCJyZWdleHAiLCJtb2RpZmllcnMiLCJjb25zdHJ1Y3RKYXZhc2NyaXB0UmVnRXhwIiwicmVwcmVzZW50SmF2YXNjcmlwdFJlZ0V4cCIsIm11bHRpbGluZSIsImlzUmVnRXhwIiwiZXNwcmltYSIsInJlc29sdmVKYXZhc2NyaXB0RnVuY3Rpb24iLCJhc3QiLCJleHByZXNzaW9uIiwiY29uc3RydWN0SmF2YXNjcmlwdEZ1bmN0aW9uIiwicGFyYW1zIiwicGFyYW0iLCJyZXByZXNlbnRKYXZhc2NyaXB0RnVuY3Rpb24iLCJpc0Z1bmN0aW9uIiwid2VicGFja1VuaXZlcnNhbE1vZHVsZURlZmluaXRpb24iLCJyb290IiwiZmFjdG9yeSIsImRlZmluZSIsImFtZCIsIm1vZHVsZXMiLCJpbnN0YWxsZWRNb2R1bGVzIiwiX193ZWJwYWNrX3JlcXVpcmVfXyIsIm1vZHVsZUlkIiwibG9hZGVkIiwiY29tbWVudF9oYW5kbGVyXzEiLCJqc3hfcGFyc2VyXzEiLCJwYXJzZXJfMSIsInRva2VuaXplcl8xIiwiZGVsZWdhdGUiLCJjb21tZW50SGFuZGxlciIsInByb3h5RGVsZWdhdGUiLCJtZXRhZGF0YSIsInZpc2l0IiwicGFyc2VyRGVsZWdhdGUiLCJjb2xsZWN0Q29tbWVudCIsImF0dGFjaENvbW1lbnQiLCJDb21tZW50SGFuZGxlciIsImF0dGFjaCIsImlzTW9kdWxlIiwic291cmNlVHlwZSIsImpzeCIsIkpTWFBhcnNlciIsIlBhcnNlciIsInByb2dyYW0iLCJwYXJzZU1vZHVsZSIsInBhcnNlU2NyaXB0IiwiY29tbWVudHMiLCJ0b2tlbnMiLCJ0b2xlcmFudCIsImVycm9ySGFuZGxlciIsInBhcnNpbmdPcHRpb25zIiwidG9rZW5pemUiLCJ0b2tlbml6ZXIiLCJUb2tlbml6ZXIiLCJnZXROZXh0VG9rZW4iLCJ0b2xlcmF0ZSIsInN5bnRheF8xIiwiU3ludGF4IiwibGVhZGluZyIsInRyYWlsaW5nIiwiaW5zZXJ0SW5uZXJDb21tZW50cyIsIkJsb2NrU3RhdGVtZW50IiwiaW5uZXJDb21tZW50cyIsImVudHJ5IiwiZmluZFRyYWlsaW5nQ29tbWVudHMiLCJ0cmFpbGluZ0NvbW1lbnRzIiwiZW50cnlfMSIsImZpcnN0Q29tbWVudCIsImZpbmRMZWFkaW5nQ29tbWVudHMiLCJsZWFkaW5nQ29tbWVudHMiLCJ2aXNpdE5vZGUiLCJQcm9ncmFtIiwidmlzaXRDb21tZW50IiwibG9jIiwiQXNzaWdubWVudEV4cHJlc3Npb24iLCJBc3NpZ25tZW50UGF0dGVybiIsIkFycmF5RXhwcmVzc2lvbiIsIkFycmF5UGF0dGVybiIsIkFycm93RnVuY3Rpb25FeHByZXNzaW9uIiwiQXdhaXRFeHByZXNzaW9uIiwiQmluYXJ5RXhwcmVzc2lvbiIsIkJyZWFrU3RhdGVtZW50IiwiQ2FsbEV4cHJlc3Npb24iLCJDYXRjaENsYXVzZSIsIkNsYXNzQm9keSIsIkNsYXNzRGVjbGFyYXRpb24iLCJDbGFzc0V4cHJlc3Npb24iLCJDb25kaXRpb25hbEV4cHJlc3Npb24iLCJDb250aW51ZVN0YXRlbWVudCIsIkRvV2hpbGVTdGF0ZW1lbnQiLCJEZWJ1Z2dlclN0YXRlbWVudCIsIkVtcHR5U3RhdGVtZW50IiwiRXhwb3J0QWxsRGVjbGFyYXRpb24iLCJFeHBvcnREZWZhdWx0RGVjbGFyYXRpb24iLCJFeHBvcnROYW1lZERlY2xhcmF0aW9uIiwiRXhwb3J0U3BlY2lmaWVyIiwiRXhwcmVzc2lvblN0YXRlbWVudCIsIkZvclN0YXRlbWVudCIsIkZvck9mU3RhdGVtZW50IiwiRm9ySW5TdGF0ZW1lbnQiLCJGdW5jdGlvbkRlY2xhcmF0aW9uIiwiRnVuY3Rpb25FeHByZXNzaW9uIiwiSWRlbnRpZmllciIsIklmU3RhdGVtZW50IiwiSW1wb3J0RGVjbGFyYXRpb24iLCJJbXBvcnREZWZhdWx0U3BlY2lmaWVyIiwiSW1wb3J0TmFtZXNwYWNlU3BlY2lmaWVyIiwiSW1wb3J0U3BlY2lmaWVyIiwiTGl0ZXJhbCIsIkxhYmVsZWRTdGF0ZW1lbnQiLCJMb2dpY2FsRXhwcmVzc2lvbiIsIk1lbWJlckV4cHJlc3Npb24iLCJNZXRhUHJvcGVydHkiLCJNZXRob2REZWZpbml0aW9uIiwiTmV3RXhwcmVzc2lvbiIsIk9iamVjdEV4cHJlc3Npb24iLCJPYmplY3RQYXR0ZXJuIiwiUHJvcGVydHkiLCJSZXN0RWxlbWVudCIsIlJldHVyblN0YXRlbWVudCIsIlNlcXVlbmNlRXhwcmVzc2lvbiIsIlNwcmVhZEVsZW1lbnQiLCJTdXBlciIsIlN3aXRjaENhc2UiLCJTd2l0Y2hTdGF0ZW1lbnQiLCJUYWdnZWRUZW1wbGF0ZUV4cHJlc3Npb24iLCJUZW1wbGF0ZUVsZW1lbnQiLCJUZW1wbGF0ZUxpdGVyYWwiLCJUaGlzRXhwcmVzc2lvbiIsIlRocm93U3RhdGVtZW50IiwiVHJ5U3RhdGVtZW50IiwiVW5hcnlFeHByZXNzaW9uIiwiVXBkYXRlRXhwcmVzc2lvbiIsIlZhcmlhYmxlRGVjbGFyYXRpb24iLCJWYXJpYWJsZURlY2xhcmF0b3IiLCJXaGlsZVN0YXRlbWVudCIsIldpdGhTdGF0ZW1lbnQiLCJZaWVsZEV4cHJlc3Npb24iLCJfX2V4dGVuZHMiLCJleHRlbmRTdGF0aWNzIiwic2V0UHJvdG90eXBlT2YiLCJjaGFyYWN0ZXJfMSIsIkpTWE5vZGUiLCJqc3hfc3ludGF4XzEiLCJOb2RlIiwidG9rZW5fMSIsInhodG1sX2VudGl0aWVzXzEiLCJUb2tlbk5hbWUiLCJnZXRRdWFsaWZpZWRFbGVtZW50TmFtZSIsInF1YWxpZmllZE5hbWUiLCJKU1hTeW50YXgiLCJKU1hJZGVudGlmaWVyIiwiSlNYTmFtZXNwYWNlZE5hbWUiLCJKU1hNZW1iZXJFeHByZXNzaW9uIiwiZXhwciIsInByb3BlcnR5IiwiX3N1cGVyIiwicGFyc2VQcmltYXJ5RXhwcmVzc2lvbiIsInBhcnNlSlNYUm9vdCIsInN0YXJ0SlNYIiwic2Nhbm5lciIsInN0YXJ0TWFya2VyIiwibGluZU51bWJlciIsImZpbmlzaEpTWCIsIm5leHRUb2tlbiIsInJlZW50ZXJKU1giLCJleHBlY3RKU1giLCJjcmVhdGVKU1hOb2RlIiwiY29sbGVjdENvbW1lbnRzIiwiY3JlYXRlSlNYQ2hpbGROb2RlIiwic2NhblhIVE1MRW50aXR5IiwicXVvdGUiLCJ0ZXJtaW5hdGVkIiwiZW9mIiwiQ2hhcmFjdGVyIiwiaXNEZWNpbWFsRGlnaXQiLCJpc0hleERpZ2l0IiwiWEhUTUxFbnRpdGllcyIsImxleEpTWCIsImNwIiwibjEiLCJuMiIsImlzSWRlbnRpZmllclN0YXJ0IiwiaXNJZGVudGlmaWVyUGFydCIsImxleCIsIm5leHRKU1hUb2tlbiIsImxhc3RNYXJrZXIiLCJjb252ZXJ0VG9rZW4iLCJuZXh0SlNYVGV4dCIsImlzTGluZVRlcm1pbmF0b3IiLCJwZWVrSlNYVG9rZW4iLCJzYXZlU3RhdGUiLCJzY2FuQ29tbWVudHMiLCJyZXN0b3JlU3RhdGUiLCJ0aHJvd1VuZXhwZWN0ZWRUb2tlbiIsIm1hdGNoSlNYIiwicGFyc2VKU1hJZGVudGlmaWVyIiwiZmluYWxpemUiLCJwYXJzZUpTWEVsZW1lbnROYW1lIiwibmFtZV8xIiwicGFyc2VKU1hBdHRyaWJ1dGVOYW1lIiwiYXR0cmlidXRlTmFtZSIsIm5hbWVfMiIsInBhcnNlSlNYU3RyaW5nTGl0ZXJhbEF0dHJpYnV0ZSIsImdldFRva2VuUmF3IiwicGFyc2VKU1hFeHByZXNzaW9uQXR0cmlidXRlIiwidG9sZXJhdGVFcnJvciIsInBhcnNlQXNzaWdubWVudEV4cHJlc3Npb24iLCJKU1hFeHByZXNzaW9uQ29udGFpbmVyIiwicGFyc2VKU1hBdHRyaWJ1dGVWYWx1ZSIsInBhcnNlSlNYRWxlbWVudCIsInBhcnNlSlNYTmFtZVZhbHVlQXR0cmlidXRlIiwiSlNYQXR0cmlidXRlIiwicGFyc2VKU1hTcHJlYWRBdHRyaWJ1dGUiLCJhcmd1bWVudCIsIkpTWFNwcmVhZEF0dHJpYnV0ZSIsInBhcnNlSlNYQXR0cmlidXRlcyIsInBhcnNlSlNYT3BlbmluZ0VsZW1lbnQiLCJKU1hPcGVuaW5nRWxlbWVudCIsInBhcnNlSlNYQm91bmRhcnlFbGVtZW50IiwibmFtZV8zIiwiSlNYQ2xvc2luZ0VsZW1lbnQiLCJwYXJzZUpTWEVtcHR5RXhwcmVzc2lvbiIsIkpTWEVtcHR5RXhwcmVzc2lvbiIsInBhcnNlSlNYRXhwcmVzc2lvbkNvbnRhaW5lciIsInBhcnNlSlNYQ2hpbGRyZW4iLCJjaGlsZHJlbiIsIkpTWFRleHQiLCJjb250YWluZXIiLCJwYXJzZUNvbXBsZXhKU1hFbGVtZW50IiwiZWwiLCJvcGVuaW5nIiwiSlNYRWxlbWVudCIsImNsb3NpbmciLCJvcGVuXzEiLCJjbG9zZV8xIiwiaXNTdGFydE9mRXhwcmVzc2lvbiIsIlJlZ2V4IiwiTm9uQXNjaWlJZGVudGlmaWVyU3RhcnQiLCJOb25Bc2NpaUlkZW50aWZpZXJQYXJ0IiwiaXNXaGl0ZVNwYWNlIiwiaXNPY3RhbERpZ2l0Iiwib3BlbmluZ0VsZW1lbnQiLCJjbG9zaW5nRWxlbWVudCIsImxlZnQiLCJyaWdodCIsIkFzeW5jQXJyb3dGdW5jdGlvbkV4cHJlc3Npb24iLCJBc3luY0Z1bmN0aW9uRGVjbGFyYXRpb24iLCJBc3luY0Z1bmN0aW9uRXhwcmVzc2lvbiIsImxvZ2ljYWwiLCJsYWJlbCIsImNhbGxlZSIsInN1cGVyQ2xhc3MiLCJDb21wdXRlZE1lbWJlckV4cHJlc3Npb24iLCJjb21wdXRlZCIsImNvbnNlcXVlbnQiLCJhbHRlcm5hdGUiLCJEaXJlY3RpdmUiLCJkaXJlY3RpdmUiLCJkZWNsYXJhdGlvbiIsInNwZWNpZmllcnMiLCJleHBvcnRlZCIsImltcG9ydGVkIiwibWV0YSIsImlzU3RhdGljIiwic3RhdGljIiwiTW9kdWxlIiwicHJvcGVydGllcyIsInNob3J0aGFuZCIsIlJlZ2V4TGl0ZXJhbCIsInBhdHRlcm4iLCJTY3JpcHQiLCJleHByZXNzaW9ucyIsIlN0YXRpY01lbWJlckV4cHJlc3Npb24iLCJkaXNjcmltaW5hbnQiLCJjYXNlcyIsInF1YXNpIiwicXVhc2lzIiwiYmxvY2siLCJmaW5hbGl6ZXIiLCJkZWNsYXJhdGlvbnMiLCJhc3NlcnRfMSIsImVycm9yX2hhbmRsZXJfMSIsIm1lc3NhZ2VzXzEiLCJzY2FubmVyXzEiLCJBcnJvd1BhcmFtZXRlclBsYWNlSG9sZGVyIiwiRXJyb3JIYW5kbGVyIiwiU2Nhbm5lciIsInRyYWNrQ29tbWVudCIsIm9wZXJhdG9yUHJlY2VkZW5jZSIsImxvb2thaGVhZCIsImhhc0xpbmVUZXJtaW5hdG9yIiwiYXdhaXQiLCJhbGxvd0luIiwiYWxsb3dTdHJpY3REaXJlY3RpdmUiLCJhbGxvd1lpZWxkIiwiZmlyc3RDb3ZlckluaXRpYWxpemVkTmFtZUVycm9yIiwiaXNBc3NpZ25tZW50VGFyZ2V0IiwiaXNCaW5kaW5nRWxlbWVudCIsImluRnVuY3Rpb25Cb2R5IiwiaW5JdGVyYXRpb24iLCJpblN3aXRjaCIsImxhYmVsU2V0IiwibWVzc2FnZUZvcm1hdCIsIl9pIiwid2hvbGUiLCJjcmVhdGVFcnJvciIsInVuZXhwZWN0ZWRUb2tlbkVycm9yIiwiTWVzc2FnZXMiLCJVbmV4cGVjdGVkVG9rZW4iLCJVbmV4cGVjdGVkRU9TIiwiVW5leHBlY3RlZElkZW50aWZpZXIiLCJVbmV4cGVjdGVkTnVtYmVyIiwiVW5leHBlY3RlZFN0cmluZyIsIlVuZXhwZWN0ZWRUZW1wbGF0ZSIsImlzRnV0dXJlUmVzZXJ2ZWRXb3JkIiwiVW5leHBlY3RlZFJlc2VydmVkIiwiaXNTdHJpY3RNb2RlUmVzZXJ2ZWRXb3JkIiwiU3RyaWN0UmVzZXJ2ZWRXb3JkIiwibGFzdE1hcmtlckxpbmVTdGFydCIsInRvbGVyYXRlVW5leHBlY3RlZFRva2VuIiwibXVsdGlMaW5lIiwibmV4dFJlZ2V4VG9rZW4iLCJzY2FuUmVnRXhwIiwiY3JlYXRlTm9kZSIsInN0YXJ0Tm9kZSIsIm1hcmtlciIsImV4cGVjdCIsImV4cGVjdENvbW1hU2VwYXJhdG9yIiwiZXhwZWN0S2V5d29yZCIsImtleXdvcmQiLCJtYXRjaEtleXdvcmQiLCJtYXRjaENvbnRleHR1YWxLZXl3b3JkIiwibWF0Y2hBc3NpZ24iLCJpc29sYXRlQ292ZXJHcmFtbWFyIiwicGFyc2VGdW5jdGlvbiIsInByZXZpb3VzSXNCaW5kaW5nRWxlbWVudCIsInByZXZpb3VzSXNBc3NpZ25tZW50VGFyZ2V0IiwicHJldmlvdXNGaXJzdENvdmVySW5pdGlhbGl6ZWROYW1lRXJyb3IiLCJpbmhlcml0Q292ZXJHcmFtbWFyIiwiY29uc3VtZVNlbWljb2xvbiIsIm1hdGNoQXN5bmNGdW5jdGlvbiIsInBhcnNlRnVuY3Rpb25FeHByZXNzaW9uIiwiU3RyaWN0T2N0YWxMaXRlcmFsIiwicGFyc2VUZW1wbGF0ZUxpdGVyYWwiLCJwYXJzZUdyb3VwRXhwcmVzc2lvbiIsInBhcnNlQXJyYXlJbml0aWFsaXplciIsInBhcnNlT2JqZWN0SW5pdGlhbGl6ZXIiLCJwYXJzZUlkZW50aWZpZXJOYW1lIiwicGFyc2VDbGFzc0V4cHJlc3Npb24iLCJwYXJzZVNwcmVhZEVsZW1lbnQiLCJwYXJzZVByb3BlcnR5TWV0aG9kIiwicHJldmlvdXNTdHJpY3QiLCJwcmV2aW91c0FsbG93U3RyaWN0RGlyZWN0aXZlIiwic2ltcGxlIiwicGFyc2VGdW5jdGlvblNvdXJjZUVsZW1lbnRzIiwiZmlyc3RSZXN0cmljdGVkIiwic3RyaWN0ZWQiLCJwYXJzZVByb3BlcnR5TWV0aG9kRnVuY3Rpb24iLCJpc0dlbmVyYXRvciIsInByZXZpb3VzQWxsb3dZaWVsZCIsInBhcnNlRm9ybWFsUGFyYW1ldGVycyIsInBhcnNlUHJvcGVydHlNZXRob2RBc3luY0Z1bmN0aW9uIiwicHJldmlvdXNBd2FpdCIsInBhcnNlT2JqZWN0UHJvcGVydHlLZXkiLCJpc1Byb3BlcnR5S2V5IiwicGFyc2VPYmplY3RQcm9wZXJ0eSIsImhhc1Byb3RvIiwiaXNBc3luYyIsImxvb2thaGVhZFByb3BlcnR5S2V5IiwicXVhbGlmaWVkUHJvcGVydHlOYW1lIiwicGFyc2VHZXR0ZXJNZXRob2QiLCJwYXJzZVNldHRlck1ldGhvZCIsInBhcnNlR2VuZXJhdG9yTWV0aG9kIiwiRHVwbGljYXRlUHJvdG9Qcm9wZXJ0eSIsInBhcnNlVGVtcGxhdGVIZWFkIiwiY29va2VkIiwicGFyc2VUZW1wbGF0ZUVsZW1lbnQiLCJwYXJzZUV4cHJlc3Npb24iLCJyZWludGVycHJldEV4cHJlc3Npb25Bc1BhdHRlcm4iLCJzdGFydFRva2VuIiwicGFyc2VSZXN0RWxlbWVudCIsImFycm93IiwicGFyYW1ldGVycyIsInBhcnNlQXJndW1lbnRzIiwiaXNJZGVudGlmaWVyTmFtZSIsInBhcnNlTmV3RXhwcmVzc2lvbiIsInBhcnNlTGVmdEhhbmRTaWRlRXhwcmVzc2lvbiIsInBhcnNlQXN5bmNBcmd1bWVudCIsInBhcnNlQXN5bmNBcmd1bWVudHMiLCJwYXJzZUxlZnRIYW5kU2lkZUV4cHJlc3Npb25BbGxvd0NhbGwiLCJtYXliZUFzeW5jIiwicHJldmlvdXNBbGxvd0luIiwiYXN5bmNBcnJvdyIsInBhcnNlU3VwZXIiLCJwYXJzZVVwZGF0ZUV4cHJlc3Npb24iLCJwYXJzZVVuYXJ5RXhwcmVzc2lvbiIsImlzUmVzdHJpY3RlZFdvcmQiLCJTdHJpY3RMSFNQcmVmaXgiLCJJbnZhbGlkTEhTSW5Bc3NpZ25tZW50IiwiU3RyaWN0TEhTUG9zdGZpeCIsInBhcnNlQXdhaXRFeHByZXNzaW9uIiwiU3RyaWN0RGVsZXRlIiwicGFyc2VFeHBvbmVudGlhdGlvbkV4cHJlc3Npb24iLCJiaW5hcnlQcmVjZWRlbmNlIiwicHJlY2VkZW5jZSIsInBhcnNlQmluYXJ5RXhwcmVzc2lvbiIsInByZWMiLCJtYXJrZXJzIiwicHJlY2VkZW5jZXMiLCJwYXJzZUNvbmRpdGlvbmFsRXhwcmVzc2lvbiIsImNoZWNrUGF0dGVyblBhcmFtIiwidmFsaWRhdGVQYXJhbSIsInJlaW50ZXJwcmV0QXNDb3ZlckZvcm1hbHNMaXN0IiwicGFyYW1TZXQiLCJTdHJpY3RQYXJhbUR1cGUiLCJwYXJzZVlpZWxkRXhwcmVzc2lvbiIsIlN0cmljdExIU0Fzc2lnbm1lbnQiLCJwYXJzZVN0YXRlbWVudExpc3RJdGVtIiwic3RhdGVtZW50IiwiSWxsZWdhbEV4cG9ydERlY2xhcmF0aW9uIiwicGFyc2VFeHBvcnREZWNsYXJhdGlvbiIsIklsbGVnYWxJbXBvcnREZWNsYXJhdGlvbiIsInBhcnNlSW1wb3J0RGVjbGFyYXRpb24iLCJwYXJzZUxleGljYWxEZWNsYXJhdGlvbiIsImluRm9yIiwicGFyc2VGdW5jdGlvbkRlY2xhcmF0aW9uIiwicGFyc2VDbGFzc0RlY2xhcmF0aW9uIiwiaXNMZXhpY2FsRGVjbGFyYXRpb24iLCJwYXJzZVN0YXRlbWVudCIsInBhcnNlQmxvY2siLCJwYXJzZUxleGljYWxCaW5kaW5nIiwicGFyc2VQYXR0ZXJuIiwiU3RyaWN0VmFyTmFtZSIsIkRlY2xhcmF0aW9uTWlzc2luZ0luaXRpYWxpemVyIiwicGFyc2VCaW5kaW5nTGlzdCIsInBhcnNlQmluZGluZ1Jlc3RFbGVtZW50IiwicGFyc2VBcnJheVBhdHRlcm4iLCJwYXJzZVBhdHRlcm5XaXRoRGVmYXVsdCIsInBhcnNlUHJvcGVydHlQYXR0ZXJuIiwia2V5VG9rZW4iLCJwYXJzZVZhcmlhYmxlSWRlbnRpZmllciIsInBhcnNlT2JqZWN0UGF0dGVybiIsIkxldEluTGV4aWNhbEJpbmRpbmciLCJwYXJzZVZhcmlhYmxlRGVjbGFyYXRpb24iLCJwYXJzZVZhcmlhYmxlRGVjbGFyYXRpb25MaXN0IiwicGFyc2VWYXJpYWJsZVN0YXRlbWVudCIsInBhcnNlRW1wdHlTdGF0ZW1lbnQiLCJwYXJzZUV4cHJlc3Npb25TdGF0ZW1lbnQiLCJwYXJzZUlmQ2xhdXNlIiwiU3RyaWN0RnVuY3Rpb24iLCJwYXJzZUlmU3RhdGVtZW50IiwicGFyc2VEb1doaWxlU3RhdGVtZW50IiwicHJldmlvdXNJbkl0ZXJhdGlvbiIsInBhcnNlV2hpbGVTdGF0ZW1lbnQiLCJwYXJzZUZvclN0YXRlbWVudCIsImZvckluIiwiZGVjbCIsIkZvckluT2ZMb29wSW5pdGlhbGl6ZXIiLCJpbml0U3RhcnRUb2tlbiIsIkludmFsaWRMSFNJbkZvckluIiwiSW52YWxpZExIU0luRm9yTG9vcCIsImluaXRTZXEiLCJwYXJzZUNvbnRpbnVlU3RhdGVtZW50IiwiVW5rbm93bkxhYmVsIiwiSWxsZWdhbENvbnRpbnVlIiwicGFyc2VCcmVha1N0YXRlbWVudCIsIklsbGVnYWxCcmVhayIsInBhcnNlUmV0dXJuU3RhdGVtZW50IiwiSWxsZWdhbFJldHVybiIsImhhc0FyZ3VtZW50IiwicGFyc2VXaXRoU3RhdGVtZW50IiwiU3RyaWN0TW9kZVdpdGgiLCJwYXJzZVN3aXRjaENhc2UiLCJwYXJzZVN3aXRjaFN0YXRlbWVudCIsInByZXZpb3VzSW5Td2l0Y2giLCJkZWZhdWx0Rm91bmQiLCJjbGF1c2UiLCJNdWx0aXBsZURlZmF1bHRzSW5Td2l0Y2giLCJwYXJzZUxhYmVsbGVkU3RhdGVtZW50IiwiUmVkZWNsYXJhdGlvbiIsIkdlbmVyYXRvckluTGVnYWN5Q29udGV4dCIsInBhcnNlVGhyb3dTdGF0ZW1lbnQiLCJOZXdsaW5lQWZ0ZXJUaHJvdyIsInBhcnNlQ2F0Y2hDbGF1c2UiLCJwYXJhbU1hcCIsIkR1cGxpY2F0ZUJpbmRpbmciLCJTdHJpY3RDYXRjaFZhcmlhYmxlIiwicGFyc2VGaW5hbGx5Q2xhdXNlIiwicGFyc2VUcnlTdGF0ZW1lbnQiLCJOb0NhdGNoT3JGaW5hbGx5IiwicGFyc2VEZWJ1Z2dlclN0YXRlbWVudCIsInBhcnNlRGlyZWN0aXZlUHJvbG9ndWVzIiwicHJldmlvdXNMYWJlbFNldCIsInByZXZpb3VzSW5GdW5jdGlvbkJvZHkiLCJTdHJpY3RQYXJhbU5hbWUiLCJEZWZhdWx0UmVzdFBhcmFtZXRlciIsIlBhcmFtZXRlckFmdGVyUmVzdFBhcmFtZXRlciIsInBhcnNlRm9ybWFsUGFyYW1ldGVyIiwiaWRlbnRpZmllcklzT3B0aW9uYWwiLCJTdHJpY3RGdW5jdGlvbk5hbWUiLCJwcmV2aW91c0FsbG93QXdhaXQiLCJmb3JtYWxQYXJhbWV0ZXJzIiwicGFyc2VEaXJlY3RpdmUiLCJJbGxlZ2FsTGFuZ3VhZ2VNb2RlRGlyZWN0aXZlIiwiQmFkR2V0dGVyQXJpdHkiLCJCYWRTZXR0ZXJBcml0eSIsIkJhZFNldHRlclJlc3RQYXJhbWV0ZXIiLCJwYXJzZUNsYXNzRWxlbWVudCIsImhhc0NvbnN0cnVjdG9yIiwicHVuY3R1YXRvciIsIkNvbnN0cnVjdG9ySXNBc3luYyIsIlN0YXRpY1Byb3RvdHlwZSIsIkNvbnN0cnVjdG9yU3BlY2lhbE1ldGhvZCIsIkR1cGxpY2F0ZUNvbnN0cnVjdG9yIiwicGFyc2VDbGFzc0VsZW1lbnRMaXN0IiwicGFyc2VDbGFzc0JvZHkiLCJlbGVtZW50TGlzdCIsImNsYXNzQm9keSIsInBhcnNlTW9kdWxlU3BlY2lmaWVyIiwiSW52YWxpZE1vZHVsZVNwZWNpZmllciIsInBhcnNlSW1wb3J0U3BlY2lmaWVyIiwicGFyc2VOYW1lZEltcG9ydHMiLCJwYXJzZUltcG9ydERlZmF1bHRTcGVjaWZpZXIiLCJwYXJzZUltcG9ydE5hbWVzcGFjZVNwZWNpZmllciIsIk5vQXNBZnRlckltcG9ydE5hbWVzcGFjZSIsIk1pc3NpbmdGcm9tQ2xhdXNlIiwicGFyc2VFeHBvcnRTcGVjaWZpZXIiLCJleHBvcnREZWNsYXJhdGlvbiIsImlzRXhwb3J0RnJvbUlkZW50aWZpZXIiLCJjb25kaXRpb24iLCJyZWNvcmRFcnJvciIsImNvbnN0cnVjdEVycm9yIiwiY29sIiwiSW52YWxpZEVzY2FwZWRSZXNlcnZlZFdvcmQiLCJJbnZhbGlkSGV4RXNjYXBlU2VxdWVuY2UiLCJJbnZhbGlkUmVnRXhwIiwiVGVtcGxhdGVPY3RhbExpdGVyYWwiLCJVbmV4cGVjdGVkVG9rZW5JbGxlZ2FsIiwiVW50ZXJtaW5hdGVkUmVnRXhwIiwiaGV4VmFsdWUiLCJvY3RhbFZhbHVlIiwiY3VybHlTdGFjayIsInNraXBTaW5nbGVMaW5lQ29tbWVudCIsInNraXBNdWx0aUxpbmVDb21tZW50IiwiaXNLZXl3b3JkIiwiY29kZVBvaW50QXQiLCJmaXJzdCIsInNjYW5IZXhFc2NhcGUiLCJzY2FuVW5pY29kZUNvZGVQb2ludEVzY2FwZSIsImdldElkZW50aWZpZXIiLCJnZXRDb21wbGV4SWRlbnRpZmllciIsIm9jdGFsVG9EZWNpbWFsIiwic2NhbklkZW50aWZpZXIiLCJyZXN0b3JlIiwic2NhblB1bmN0dWF0b3IiLCJzY2FuSGV4TGl0ZXJhbCIsInNjYW5CaW5hcnlMaXRlcmFsIiwic2Nhbk9jdGFsTGl0ZXJhbCIsImlzSW1wbGljaXRPY3RhbExpdGVyYWwiLCJzY2FuTnVtZXJpY0xpdGVyYWwiLCJzY2FuU3RyaW5nTGl0ZXJhbCIsInVuZXNjYXBlZF8xIiwidW5lc2NhcGVkIiwib2N0VG9EZWMiLCJzY2FuVGVtcGxhdGUiLCJyYXdPZmZzZXQiLCJ1bmVzY2FwZWRfMiIsInRlc3RSZWdFeHAiLCJhc3RyYWxTdWJzdGl0dXRlIiwiJDIiLCJzY2FuUmVnRXhwQm9keSIsImNsYXNzTWFya2VyIiwic2NhblJlZ0V4cEZsYWdzIiwiY2hhciIsInF1b3QiLCJhbXAiLCJhcG9zIiwibmJzcCIsImlleGNsIiwiY2VudCIsInBvdW5kIiwiY3VycmVuIiwieWVuIiwiYnJ2YmFyIiwic2VjdCIsInVtbCIsIm9yZGYiLCJsYXF1byIsInNoeSIsInJlZyIsIm1hY3IiLCJkZWciLCJwbHVzbW4iLCJzdXAyIiwic3VwMyIsImFjdXRlIiwibWljcm8iLCJwYXJhIiwibWlkZG90IiwiY2VkaWwiLCJzdXAxIiwib3JkbSIsInJhcXVvIiwiZnJhYzE0IiwiZnJhYzEyIiwiZnJhYzM0IiwiaXF1ZXN0IiwiQWdyYXZlIiwiQWFjdXRlIiwiQWNpcmMiLCJBdGlsZGUiLCJBdW1sIiwiQXJpbmciLCJBRWxpZyIsIkNjZWRpbCIsIkVncmF2ZSIsIkVhY3V0ZSIsIkVjaXJjIiwiRXVtbCIsIklncmF2ZSIsIklhY3V0ZSIsIkljaXJjIiwiSXVtbCIsIkVUSCIsIk50aWxkZSIsIk9ncmF2ZSIsIk9hY3V0ZSIsIk9jaXJjIiwiT3RpbGRlIiwiT3VtbCIsInRpbWVzIiwiT3NsYXNoIiwiVWdyYXZlIiwiVWFjdXRlIiwiVWNpcmMiLCJVdW1sIiwiWWFjdXRlIiwiVEhPUk4iLCJzemxpZyIsImFncmF2ZSIsImFhY3V0ZSIsImFjaXJjIiwiYXRpbGRlIiwiYXVtbCIsImFyaW5nIiwiYWVsaWciLCJjY2VkaWwiLCJlZ3JhdmUiLCJlYWN1dGUiLCJlY2lyYyIsImV1bWwiLCJpZ3JhdmUiLCJpYWN1dGUiLCJpY2lyYyIsIml1bWwiLCJldGgiLCJudGlsZGUiLCJvZ3JhdmUiLCJvYWN1dGUiLCJvY2lyYyIsIm90aWxkZSIsIm91bWwiLCJkaXZpZGUiLCJvc2xhc2giLCJ1Z3JhdmUiLCJ1YWN1dGUiLCJ1Y2lyYyIsInV1bWwiLCJ5YWN1dGUiLCJ0aG9ybiIsInl1bWwiLCJPRWxpZyIsIm9lbGlnIiwiU2Nhcm9uIiwic2Nhcm9uIiwiWXVtbCIsImZub2YiLCJjaXJjIiwidGlsZGUiLCJBbHBoYSIsIkJldGEiLCJHYW1tYSIsIkRlbHRhIiwiRXBzaWxvbiIsIlpldGEiLCJFdGEiLCJUaGV0YSIsIklvdGEiLCJLYXBwYSIsIkxhbWJkYSIsIk11IiwiTnUiLCJYaSIsIk9taWNyb24iLCJQaSIsIlJobyIsIlNpZ21hIiwiVGF1IiwiVXBzaWxvbiIsIlBoaSIsIkNoaSIsIlBzaSIsIk9tZWdhIiwiYWxwaGEiLCJiZXRhIiwiZ2FtbWEiLCJlcHNpbG9uIiwiemV0YSIsImV0YSIsInRoZXRhIiwiaW90YSIsImthcHBhIiwibGFtYmRhIiwibXUiLCJudSIsInhpIiwib21pY3JvbiIsInBpIiwicmhvIiwic2lnbWFmIiwic2lnbWEiLCJ0YXUiLCJ1cHNpbG9uIiwicGhpIiwiY2hpIiwicHNpIiwib21lZ2EiLCJ0aGV0YXN5bSIsInVwc2loIiwicGl2IiwiZW5zcCIsImVtc3AiLCJ0aGluc3AiLCJ6d25qIiwiendqIiwibHJtIiwicmxtIiwibmRhc2giLCJtZGFzaCIsImxzcXVvIiwicnNxdW8iLCJzYnF1byIsImxkcXVvIiwicmRxdW8iLCJiZHF1byIsImRhZ2dlciIsIkRhZ2dlciIsImJ1bGwiLCJoZWxsaXAiLCJwZXJtaWwiLCJwcmltZSIsIlByaW1lIiwibHNhcXVvIiwicnNhcXVvIiwib2xpbmUiLCJmcmFzbCIsImV1cm8iLCJpbWFnZSIsIndlaWVycCIsInJlYWwiLCJ0cmFkZSIsImFsZWZzeW0iLCJsYXJyIiwidWFyciIsInJhcnIiLCJkYXJyIiwiaGFyciIsImNyYXJyIiwibEFyciIsInVBcnIiLCJyQXJyIiwiZEFyciIsImhBcnIiLCJmb3JhbGwiLCJleGlzdCIsImVtcHR5IiwibmFibGEiLCJpc2luIiwibm90aW4iLCJuaSIsInByb2QiLCJzdW0iLCJtaW51cyIsImxvd2FzdCIsInJhZGljIiwiaW5maW4iLCJhbmciLCJhbmQiLCJvciIsImNhcCIsImN1cCIsImludCIsInRoZXJlNCIsInNpbSIsImNvbmciLCJhc3ltcCIsIm5lIiwiZXF1aXYiLCJsZSIsImdlIiwic3ViIiwic3VwIiwibnN1YiIsInN1YmUiLCJzdXBlIiwib3BsdXMiLCJvdGltZXMiLCJwZXJwIiwic2RvdCIsImxjZWlsIiwicmNlaWwiLCJsZmxvb3IiLCJyZmxvb3IiLCJsb3oiLCJzcGFkZXMiLCJjbHVicyIsImhlYXJ0cyIsImRpYW1zIiwibGFuZyIsInJhbmciLCJSZWFkZXIiLCJjdXJseSIsInBhcmVuIiwiYmVmb3JlRnVuY3Rpb25FeHByZXNzaW9uIiwiaXNSZWdleFN0YXJ0IiwicHJldmlvdXMiLCJ0cmFja1JhbmdlIiwidHJhY2tMb2MiLCJyZWFkZXIiLCJzdGFydFJlZ2V4IiwiQ0hBUl9UQUIiLCJDSEFSX0xJTkVfRkVFRCIsIkNIQVJfU1BBQ0UiLCJDSEFSX0VYQ0xBTUFUSU9OIiwiQ0hBUl9ET1VCTEVfUVVPVEUiLCJDSEFSX1NIQVJQIiwiQ0hBUl9QRVJDRU5UIiwiQ0hBUl9BTVBFUlNBTkQiLCJDSEFSX1NJTkdMRV9RVU9URSIsIkNIQVJfQVNURVJJU0siLCJDSEFSX0NPTU1BIiwiQ0hBUl9NSU5VUyIsIkNIQVJfQ09MT04iLCJDSEFSX0dSRUFURVJfVEhBTiIsIkNIQVJfUVVFU1RJT04iLCJDSEFSX0NPTU1FUkNJQUxfQVQiLCJDSEFSX0xFRlRfU1FVQVJFX0JSQUNLRVQiLCJDSEFSX1JJR0hUX1NRVUFSRV9CUkFDS0VUIiwiQ0hBUl9HUkFWRV9BQ0NFTlQiLCJDSEFSX0xFRlRfQ1VSTFlfQlJBQ0tFVCIsIkNIQVJfVkVSVElDQUxfTElORSIsIkNIQVJfUklHSFRfQ1VSTFlfQlJBQ0tFVCIsIkVTQ0FQRV9TRVFVRU5DRVMiLCJERVBSRUNBVEVEX0JPT0xFQU5TX1NZTlRBWCIsImNvbXBpbGVTdHlsZU1hcCIsImVuY29kZUhleCIsImNoYXJhY3RlciIsInNraXBJbnZhbGlkIiwiZmxvd0xldmVsIiwic3R5bGVNYXAiLCJzb3J0S2V5cyIsImxpbmVXaWR0aCIsIm5vUmVmcyIsIm5vQ29tcGF0TW9kZSIsImNvbmRlbnNlRmxvdyIsImV4cGxpY2l0VHlwZXMiLCJkdXBsaWNhdGVzIiwidXNlZER1cGxpY2F0ZXMiLCJpbmRlbnRTdHJpbmciLCJpbmQiLCJnZW5lcmF0ZU5leHRMaW5lIiwidGVzdEltcGxpY2l0UmVzb2x2aW5nIiwiaXNQcmludGFibGUiLCJpc1BsYWluU2FmZSIsImlzUGxhaW5TYWZlRmlyc3QiLCJTVFlMRV9QTEFJTiIsIlNUWUxFX1NJTkdMRSIsIlNUWUxFX0xJVEVSQUwiLCJTVFlMRV9GT0xERUQiLCJTVFlMRV9ET1VCTEUiLCJjaG9vc2VTY2FsYXJTdHlsZSIsInNpbmdsZUxpbmVPbmx5IiwiaW5kZW50UGVyTGV2ZWwiLCJ0ZXN0QW1iaWd1b3VzVHlwZSIsImhhc0xpbmVCcmVhayIsImhhc0ZvbGRhYmxlTGluZSIsInNob3VsZFRyYWNrV2lkdGgiLCJwcmV2aW91c0xpbmVCcmVhayIsInBsYWluIiwid3JpdGVTY2FsYXIiLCJpc2tleSIsInRlc3RBbWJpZ3VpdHkiLCJibG9ja0hlYWRlciIsImRyb3BFbmRpbmdOZXdsaW5lIiwiZm9sZFN0cmluZyIsImVzY2FwZVN0cmluZyIsImluZGVudEluZGljYXRvciIsImNsaXAiLCJrZWVwIiwiY2hvbXAiLCJ3aWR0aCIsImxpbmVSZSIsIm5leHRMRiIsImZvbGRMaW5lIiwicHJldk1vcmVJbmRlbnRlZCIsIm1vcmVJbmRlbnRlZCIsImJyZWFrUmUiLCJuZXh0Q2hhciIsImVzY2FwZVNlcSIsIndyaXRlRmxvd1NlcXVlbmNlIiwid3JpdGVOb2RlIiwid3JpdGVCbG9ja1NlcXVlbmNlIiwid3JpdGVGbG93TWFwcGluZyIsIm9iamVjdEtleUxpc3QiLCJvYmplY3RLZXkiLCJvYmplY3RWYWx1ZSIsInBhaXJCdWZmZXIiLCJ3cml0ZUJsb2NrTWFwcGluZyIsImV4cGxpY2l0UGFpciIsImRldGVjdFR5cGUiLCJ0eXBlTGlzdCIsIm9iamVjdE9yQXJyYXkiLCJkdXBsaWNhdGVJbmRleCIsImR1cGxpY2F0ZSIsImdldER1cGxpY2F0ZVJlZmVyZW5jZXMiLCJvYmplY3RzIiwiZHVwbGljYXRlc0luZGV4ZXMiLCJpbnNwZWN0Tm9kZSIsImNyZWF0b3IiLCJoYXNWYWx1ZSIsIlNvdXJjZU1hcENvbnN1bWVyIiwiZXJyb3JGb3JtYXR0ZXJJbnN0YWxsZWQiLCJ1bmNhdWdodFNoaW1JbnN0YWxsZWQiLCJlbXB0eUNhY2hlQmV0d2Vlbk9wZXJhdGlvbnMiLCJlbnZpcm9ubWVudCIsImZpbGVDb250ZW50c0NhY2hlIiwic291cmNlTWFwQ2FjaGUiLCJyZVNvdXJjZU1hcCIsInJldHJpZXZlRmlsZUhhbmRsZXJzIiwicmV0cmlldmVNYXBIYW5kbGVycyIsImlzSW5Ccm93c2VyIiwiWE1MSHR0cFJlcXVlc3QiLCJoYXNHbG9iYWxQcm9jZXNzRXZlbnRFbWl0dGVyIiwiaGFuZGxlckV4ZWMiLCJyZXRyaWV2ZUZpbGUiLCJjb250ZW50cyIsInhociIsInNlbmQiLCJyZWFkeVN0YXRlIiwic3RhdHVzIiwicmVzcG9uc2VUZXh0Iiwic3VwcG9ydFJlbGF0aXZlVVJMIiwicmV0cmlldmVTb3VyY2VNYXBVUkwiLCJmaWxlRGF0YSIsInNvdXJjZU1hcEhlYWRlciIsImdldFJlc3BvbnNlSGVhZGVyIiwibGFzdE1hdGNoIiwicmV0cmlldmVTb3VyY2VNYXAiLCJzb3VyY2VNYXBwaW5nVVJMIiwic291cmNlTWFwRGF0YSIsIm1hcFNvdXJjZVBvc2l0aW9uIiwic291cmNlTWFwIiwidXJsQW5kTWFwIiwib3JpZ2luYWxQb3NpdGlvbiIsIm1hcEV2YWxPcmlnaW4iLCJvcmlnaW4iLCJDYWxsU2l0ZVRvU3RyaW5nIiwiZmlsZUxvY2F0aW9uIiwiaXNOYXRpdmUiLCJnZXRTY3JpcHROYW1lT3JTb3VyY2VVUkwiLCJpc0V2YWwiLCJnZXRFdmFsT3JpZ2luIiwiZ2V0TGluZU51bWJlciIsImNvbHVtbk51bWJlciIsImdldENvbHVtbk51bWJlciIsImZ1bmN0aW9uTmFtZSIsImdldEZ1bmN0aW9uTmFtZSIsImFkZFN1ZmZpeCIsImlzQ29uc3RydWN0b3IiLCJpc01ldGhvZENhbGwiLCJpc1RvcGxldmVsIiwidHlwZU5hbWUiLCJnZXRUeXBlTmFtZSIsImdldE1ldGhvZE5hbWUiLCJjbG9uZUNhbGxTaXRlIiwiZnJhbWUiLCJ3cmFwQ2FsbFNpdGUiLCJnZXRGaWxlTmFtZSIsImhlYWRlckxlbmd0aCIsInByZXBhcmVTdGFja1RyYWNlIiwiZ2V0RXJyb3JTb3VyY2UiLCJwcmludEVycm9yQW5kRXhpdCIsInNoaW1FbWl0VW5jYXVnaHRFeGNlcHRpb24iLCJvcmlnRW1pdCIsImhhc0xpc3RlbmVycyIsImxpc3RlbmVycyIsIm92ZXJyaWRlUmV0cmlldmVGaWxlIiwib3ZlcnJpZGVSZXRyaWV2ZVNvdXJjZU1hcCIsImhvb2tSZXF1aXJlIiwiJGNvbXBpbGUiLCJfY29tcGlsZSIsIl9fc291cmNlTWFwU3VwcG9ydCIsImluc3RhbGxIYW5kbGVyIiwiaGFuZGxlVW5jYXVnaHRFeGNlcHRpb25zIiwiU291cmNlTm9kZSIsImludFRvQ2hhck1hcCIsImNoYXJDb2RlIiwiYmlnQSIsImJpZ1oiLCJsaXR0bGVBIiwibGl0dGxlWiIsInplcm8iLCJuaW5lIiwicGx1cyIsInNsYXNoIiwibGl0dGxlT2Zmc2V0IiwibnVtYmVyT2Zmc2V0IiwiZ2VuZXJhdGVkUG9zaXRpb25BZnRlciIsImxpbmVBIiwibGluZUIiLCJjb2x1bW5BIiwiY29sdW1uQiIsIl9zb3J0ZWQiLCJfbGFzdCIsIk1hcHBpbmdMaXN0X2ZvckVhY2giLCJhQ2FsbGJhY2siLCJhVGhpc0FyZyIsIk1hcHBpbmdMaXN0X2FkZCIsImFNYXBwaW5nIiwiTWFwcGluZ0xpc3RfdG9BcnJheSIsImJpbmFyeVNlYXJjaCIsInF1aWNrU29ydCIsImFTb3VyY2VNYXAiLCJhU291cmNlTWFwVVJMIiwic2VjdGlvbnMiLCJJbmRleGVkU291cmNlTWFwQ29uc3VtZXIiLCJCYXNpY1NvdXJjZU1hcENvbnN1bWVyIiwiX19nZW5lcmF0ZWRNYXBwaW5ncyIsIl9wYXJzZU1hcHBpbmdzIiwiX19vcmlnaW5hbE1hcHBpbmdzIiwiX2NoYXJJc01hcHBpbmdTZXBhcmF0b3IiLCJTb3VyY2VNYXBDb25zdW1lcl9jaGFySXNNYXBwaW5nU2VwYXJhdG9yIiwiU291cmNlTWFwQ29uc3VtZXJfcGFyc2VNYXBwaW5ncyIsIkdFTkVSQVRFRF9PUkRFUiIsIk9SSUdJTkFMX09SREVSIiwiR1JFQVRFU1RfTE9XRVJfQk9VTkQiLCJMRUFTVF9VUFBFUl9CT1VORCIsIlNvdXJjZU1hcENvbnN1bWVyX2VhY2hNYXBwaW5nIiwiYUNvbnRleHQiLCJhT3JkZXIiLCJvcmRlciIsIl9nZW5lcmF0ZWRNYXBwaW5ncyIsIl9vcmlnaW5hbE1hcHBpbmdzIiwiX3NvdXJjZU1hcFVSTCIsImFsbEdlbmVyYXRlZFBvc2l0aW9uc0ZvciIsIlNvdXJjZU1hcENvbnN1bWVyX2FsbEdlbmVyYXRlZFBvc2l0aW9uc0ZvciIsIm5lZWRsZSIsIl9maW5kU291cmNlSW5kZXgiLCJfZmluZE1hcHBpbmciLCJsYXN0Q29sdW1uIiwiX2Fic29sdXRlU291cmNlcyIsImNvbnN1bWVyIiwicmVsYXRpdmVTb3VyY2UiLCJTb3VyY2VNYXBDb25zdW1lcl9mcm9tU291cmNlTWFwIiwic21jIiwiZ2VuZXJhdGVkTWFwcGluZ3MiLCJkZXN0R2VuZXJhdGVkTWFwcGluZ3MiLCJkZXN0T3JpZ2luYWxNYXBwaW5ncyIsInNyY01hcHBpbmciLCJkZXN0TWFwcGluZyIsIk1hcHBpbmciLCJjYWNoZWRTZWdtZW50cyIsInRlbXAiLCJvcmlnaW5hbE1hcHBpbmdzIiwic2VnbWVudCIsIlNvdXJjZU1hcENvbnN1bWVyX2ZpbmRNYXBwaW5nIiwiYU5lZWRsZSIsImFNYXBwaW5ncyIsImFMaW5lTmFtZSIsImFDb2x1bW5OYW1lIiwiYUNvbXBhcmF0b3IiLCJhQmlhcyIsImNvbXB1dGVDb2x1bW5TcGFucyIsIlNvdXJjZU1hcENvbnN1bWVyX2NvbXB1dGVDb2x1bW5TcGFucyIsIm5leHRNYXBwaW5nIiwibGFzdEdlbmVyYXRlZENvbHVtbiIsIlNvdXJjZU1hcENvbnN1bWVyX29yaWdpbmFsUG9zaXRpb25Gb3IiLCJoYXNDb250ZW50c09mQWxsU291cmNlcyIsIkJhc2ljU291cmNlTWFwQ29uc3VtZXJfaGFzQ29udGVudHNPZkFsbFNvdXJjZXMiLCJzYyIsIlNvdXJjZU1hcENvbnN1bWVyX3NvdXJjZUNvbnRlbnRGb3IiLCJudWxsT25NaXNzaW5nIiwiZmlsZVVyaUFic1BhdGgiLCJnZW5lcmF0ZWRQb3NpdGlvbkZvciIsIlNvdXJjZU1hcENvbnN1bWVyX2dlbmVyYXRlZFBvc2l0aW9uRm9yIiwibGFzdE9mZnNldCIsIl9zZWN0aW9ucyIsIm9mZnNldExpbmUiLCJvZmZzZXRDb2x1bW4iLCJnZW5lcmF0ZWRPZmZzZXQiLCJJbmRleGVkU291cmNlTWFwQ29uc3VtZXJfb3JpZ2luYWxQb3NpdGlvbkZvciIsInNlY3Rpb25JbmRleCIsInNlY3Rpb24iLCJiaWFzIiwiSW5kZXhlZFNvdXJjZU1hcENvbnN1bWVyX2hhc0NvbnRlbnRzT2ZBbGxTb3VyY2VzIiwiSW5kZXhlZFNvdXJjZU1hcENvbnN1bWVyX3NvdXJjZUNvbnRlbnRGb3IiLCJJbmRleGVkU291cmNlTWFwQ29uc3VtZXJfZ2VuZXJhdGVkUG9zaXRpb25Gb3IiLCJnZW5lcmF0ZWRQb3NpdGlvbiIsIkluZGV4ZWRTb3VyY2VNYXBDb25zdW1lcl9wYXJzZU1hcHBpbmdzIiwic2VjdGlvbk1hcHBpbmdzIiwiYWRqdXN0ZWRNYXBwaW5nIiwicmVjdXJzaXZlU2VhcmNoIiwiYUxvdyIsImFIaWdoIiwiYUhheXN0YWNrIiwiYUNvbXBhcmUiLCJtaWQiLCJzd2FwIiwiYXJ5IiwicmFuZG9tSW50SW5SYW5nZSIsImRvUXVpY2tTb3J0IiwicGl2b3RJbmRleCIsInBpdm90IiwiUkVHRVhfTkVXTElORSIsIk5FV0xJTkVfQ09ERSIsImlzU291cmNlTm9kZSIsImFMaW5lIiwiYUNvbHVtbiIsImFDaHVua3MiLCJzb3VyY2VDb250ZW50cyIsImZyb21TdHJpbmdXaXRoU291cmNlTWFwIiwiU291cmNlTm9kZV9mcm9tU3RyaW5nV2l0aFNvdXJjZU1hcCIsImFHZW5lcmF0ZWRDb2RlIiwiYVJlbGF0aXZlUGF0aCIsInJlbWFpbmluZ0xpbmVzIiwicmVtYWluaW5nTGluZXNJbmRleCIsInNoaWZ0TmV4dExpbmUiLCJsaW5lQ29udGVudHMiLCJnZXROZXh0TGluZSIsIm5ld0xpbmUiLCJsYXN0R2VuZXJhdGVkTGluZSIsImxhc3RNYXBwaW5nIiwiYWRkTWFwcGluZ1dpdGhDb2RlIiwibmV4dExpbmUiLCJTb3VyY2VOb2RlX2FkZCIsImFDaHVuayIsInByZXBlbmQiLCJTb3VyY2VOb2RlX3ByZXBlbmQiLCJ3YWxrIiwiU291cmNlTm9kZV93YWxrIiwiYUZuIiwiU291cmNlTm9kZV9qb2luIiwiYVNlcCIsIm5ld0NoaWxkcmVuIiwicmVwbGFjZVJpZ2h0IiwiU291cmNlTm9kZV9yZXBsYWNlUmlnaHQiLCJhUGF0dGVybiIsImFSZXBsYWNlbWVudCIsImxhc3RDaGlsZCIsIlNvdXJjZU5vZGVfc2V0U291cmNlQ29udGVudCIsIndhbGtTb3VyY2VDb250ZW50cyIsIlNvdXJjZU5vZGVfd2Fsa1NvdXJjZUNvbnRlbnRzIiwiU291cmNlTm9kZV90b1N0cmluZyIsInRvU3RyaW5nV2l0aFNvdXJjZU1hcCIsIlNvdXJjZU5vZGVfdG9TdHJpbmdXaXRoU291cmNlTWFwIiwic291cmNlTWFwcGluZ0FjdGl2ZSIsImxhc3RPcmlnaW5hbFNvdXJjZSIsImxhc3RPcmlnaW5hbExpbmUiLCJsYXN0T3JpZ2luYWxDb2x1bW4iLCJsYXN0T3JpZ2luYWxOYW1lIiwic291cmNlQ29udGVudCIsInByb3h5TG9naW5DYWxsYmFjayIsInNraXBEaXJDcmVhdGlvbiIsIm5ldCIsImFkZFByb3h5TG9naW5IYW5kbGVyIiwiX0JpbnRyYXlQcm92aWRlciIsIl9sb2FkX0JpbnRyYXlQcm92aWRlciIsIl9HaXRIdWJQcm92aWRlciIsIl9sb2FkX0dpdEh1YlByb3ZpZGVyIiwiX1ByaXZhdGVHaXRIdWJQcm92aWRlciIsIl9sb2FkX1ByaXZhdGVHaXRIdWJQcm92aWRlciIsImdpdGh1Yk9wdGlvbnMiLCJwcml2YXRlIiwiR0hfVE9LRU4iLCJQcml2YXRlR2l0SHViUHJvdmlkZXIiLCJCaW50cmF5UHJvdmlkZXIiLCJfYmludHJheSIsIl9sb2FkX2JpbnRyYXkiLCJCaW50cmF5Q2xpZW50IiwiY2hhbm5lbEZpbGVuYW1lIiwiZ2V0VmVyc2lvbkZpbGVzIiwiYXBpS2V5IiwicGFja2FnZSIsInBhY2thZ2VOYW1lIiwidXNlciIsImNvbXBvbmVudCIsImRpc3RyaWJ1dGlvbiIsImJpbnRyYXlSZXF1ZXN0IiwiY3JlYXRlVmVyc2lvbiIsImRlbGV0ZVZlcnNpb24iLCJnZXRMYXRlc3RWZXJzaW9uSW5mbyIsImFzc2V0IiwiYXNzZXRzIiwiaHRtbF91cmwiLCJjb25maWd1cmVIZWFkZXJzIiwiYWNjZXB0IiwiX2NoaWxkX3Byb2Nlc3MiLCJfbG9hZF9jaGlsZF9wcm9jZXNzIiwiX0Jhc2VVcGRhdGVyIiwiX2xvYWRfQmFzZVVwZGF0ZXIiLCJfRmlsZVdpdGhFbWJlZGRlZEJsb2NrTWFwRGlmZmVyZW50aWFsRG93bmxvYWRlciIsIl9sb2FkX0ZpbGVXaXRoRW1iZWRkZWRCbG9ja01hcERpZmZlcmVudGlhbERvd25sb2FkZXIiLCJfR2VuZXJpY0RpZmZlcmVudGlhbERvd25sb2FkZXIiLCJfbG9hZF9HZW5lcmljRGlmZmVyZW50aWFsRG93bmxvYWRlciIsIl93aW5kb3dzRXhlY3V0YWJsZUNvZGVTaWduYXR1cmVWZXJpZmllciIsIl9sb2FkX3dpbmRvd3NFeGVjdXRhYmxlQ29kZVNpZ25hdHVyZVZlcmlmaWVyIiwicGFja2FnZVBhdGgiLCJnZXREb3dubG9hZGVkRmlsZSIsImRpZmZlcmVudGlhbERvd25sb2FkSW5zdGFsbGVyIiwic2lnbmF0dXJlVmVyaWZpY2F0aW9uU3RhdHVzIiwidmVyaWZ5U2lnbmF0dXJlIiwiZXh0bmFtZSIsImRpZmZlcmVudGlhbERvd25sb2FkV2ViUGFja2FnZSIsIl94MiIsIl94MyIsInNldERvd25sb2FkZWRGaWxlIiwidGVtcFVwZGF0ZUZpbGUiLCJwdWJsaXNoZXJOYW1lIiwic3Bhd25PcHRpb25zIiwiZGV0YWNoZWQiLCJzdGRpbyIsInVucmVmIiwiX19OU0lTX0RJRkZFUkVOVElBTF9VUERBVEVfXyIsImJsb2NrTWFwRGF0YSIsIkdlbmVyaWNEaWZmZXJlbnRpYWxEb3dubG9hZGVyIiwiX2xvZGFzaCIsIl9sb2FkX2xvZGFzaCIsInNldHVwUGF0aCIsIl9wYWNrYWdlUGF0aCIsIkxBUkdFX0FSUkFZX1NJWkUiLCJIQVNIX1VOREVGSU5FRCIsIkNPTVBBUkVfUEFSVElBTF9GTEFHIiwiQ09NUEFSRV9VTk9SREVSRURfRkxBRyIsImFyZ3NUYWciLCJhcnJheVRhZyIsImFzeW5jVGFnIiwiYm9vbFRhZyIsImRhdGVUYWciLCJlcnJvclRhZyIsImZ1bmNUYWciLCJnZW5UYWciLCJtYXBUYWciLCJudW1iZXJUYWciLCJudWxsVGFnIiwib2JqZWN0VGFnIiwicHJvbWlzZVRhZyIsInByb3h5VGFnIiwicmVnZXhwVGFnIiwic2V0VGFnIiwic3RyaW5nVGFnIiwic3ltYm9sVGFnIiwidW5kZWZpbmVkVGFnIiwid2Vha01hcFRhZyIsImFycmF5QnVmZmVyVGFnIiwiZGF0YVZpZXdUYWciLCJmbG9hdDMyVGFnIiwiZmxvYXQ2NFRhZyIsImludDhUYWciLCJpbnQxNlRhZyIsImludDMyVGFnIiwidWludDhUYWciLCJ1aW50OENsYW1wZWRUYWciLCJ1aW50MTZUYWciLCJ1aW50MzJUYWciLCJyZVJlZ0V4cENoYXIiLCJyZUlzSG9zdEN0b3IiLCJyZUlzVWludCIsInR5cGVkQXJyYXlUYWdzIiwiZnJlZUdsb2JhbCIsImZyZWVTZWxmIiwiZnJlZUV4cG9ydHMiLCJmcmVlTW9kdWxlIiwibW9kdWxlRXhwb3J0cyIsImZyZWVQcm9jZXNzIiwibm9kZVV0aWwiLCJiaW5kaW5nIiwibm9kZUlzVHlwZWRBcnJheSIsImlzVHlwZWRBcnJheSIsImFycmF5RmlsdGVyIiwicmVzSW5kZXgiLCJhcnJheVB1c2giLCJhcnJheVNvbWUiLCJiYXNlVGltZXMiLCJpdGVyYXRlZSIsImJhc2VVbmFyeSIsImZ1bmMiLCJjYWNoZUhhcyIsImdldFZhbHVlIiwibWFwVG9BcnJheSIsIm92ZXJBcmciLCJ0cmFuc2Zvcm0iLCJzZXRUb0FycmF5IiwiYXJyYXlQcm90byIsImZ1bmNQcm90byIsIm9iamVjdFByb3RvIiwiY29yZUpzRGF0YSIsImZ1bmNUb1N0cmluZyIsIm1hc2tTcmNLZXkiLCJJRV9QUk9UTyIsIm5hdGl2ZU9iamVjdFRvU3RyaW5nIiwicmVJc05hdGl2ZSIsIlVpbnQ4QXJyYXkiLCJwcm9wZXJ0eUlzRW51bWVyYWJsZSIsInN5bVRvU3RyaW5nVGFnIiwidG9TdHJpbmdUYWciLCJuYXRpdmVHZXRTeW1ib2xzIiwiZ2V0T3duUHJvcGVydHlTeW1ib2xzIiwibmF0aXZlSXNCdWZmZXIiLCJuYXRpdmVLZXlzIiwiRGF0YVZpZXciLCJnZXROYXRpdmUiLCJTZXQiLCJXZWFrTWFwIiwibmF0aXZlQ3JlYXRlIiwiZGF0YVZpZXdDdG9yU3RyaW5nIiwidG9Tb3VyY2UiLCJtYXBDdG9yU3RyaW5nIiwicHJvbWlzZUN0b3JTdHJpbmciLCJzZXRDdG9yU3RyaW5nIiwid2Vha01hcEN0b3JTdHJpbmciLCJzeW1ib2xQcm90byIsInN5bWJvbFZhbHVlT2YiLCJ2YWx1ZU9mIiwiSGFzaCIsImhhc2hDbGVhciIsIl9fZGF0YV9fIiwiaGFzaERlbGV0ZSIsImhhc2hHZXQiLCJoYXNoSGFzIiwiaGFzaFNldCIsIkxpc3RDYWNoZSIsImxpc3RDYWNoZUNsZWFyIiwibGlzdENhY2hlRGVsZXRlIiwiYXNzb2NJbmRleE9mIiwibGlzdENhY2hlR2V0IiwibGlzdENhY2hlSGFzIiwibGlzdENhY2hlU2V0IiwiTWFwQ2FjaGUiLCJtYXBDYWNoZUNsZWFyIiwibWFwQ2FjaGVEZWxldGUiLCJnZXRNYXBEYXRhIiwibWFwQ2FjaGVHZXQiLCJtYXBDYWNoZUhhcyIsIm1hcENhY2hlU2V0IiwiU2V0Q2FjaGUiLCJzZXRDYWNoZUFkZCIsInNldENhY2hlSGFzIiwiU3RhY2siLCJzdGFja0NsZWFyIiwic3RhY2tEZWxldGUiLCJzdGFja0dldCIsInN0YWNrSGFzIiwic3RhY2tTZXQiLCJwYWlycyIsImFycmF5TGlrZUtleXMiLCJpbmhlcml0ZWQiLCJpc0FyciIsImlzQXJnIiwiaXNBcmd1bWVudHMiLCJpc0J1ZmYiLCJpc1R5cGUiLCJza2lwSW5kZXhlcyIsImJhc2VHZXRBbGxLZXlzIiwia2V5c0Z1bmMiLCJzeW1ib2xzRnVuYyIsImJhc2VHZXRUYWciLCJnZXRSYXdUYWciLCJvYmplY3RUb1N0cmluZyIsImJhc2VJc0FyZ3VtZW50cyIsImlzT2JqZWN0TGlrZSIsImJhc2VJc0VxdWFsIiwiYml0bWFzayIsImN1c3RvbWl6ZXIiLCJiYXNlSXNFcXVhbERlZXAiLCJlcXVhbEZ1bmMiLCJvYmpJc0FyciIsIm90aElzQXJyIiwib2JqVGFnIiwiZ2V0VGFnIiwib3RoVGFnIiwib2JqSXNPYmoiLCJvdGhJc09iaiIsImlzU2FtZVRhZyIsImVxdWFsQXJyYXlzIiwiZXF1YWxCeVRhZyIsIm9iaklzV3JhcHBlZCIsIm90aElzV3JhcHBlZCIsIm9ialVud3JhcHBlZCIsIm90aFVud3JhcHBlZCIsImVxdWFsT2JqZWN0cyIsImJhc2VJc05hdGl2ZSIsImlzTWFza2VkIiwiYmFzZUlzVHlwZWRBcnJheSIsImlzTGVuZ3RoIiwiYmFzZUtleXMiLCJpc1Byb3RvdHlwZSIsImlzUGFydGlhbCIsImFyckxlbmd0aCIsIm90aExlbmd0aCIsInN0YWNrZWQiLCJzZWVuIiwiYXJyVmFsdWUiLCJvdGhWYWx1ZSIsImNvbXBhcmVkIiwib3RoSW5kZXgiLCJieXRlTGVuZ3RoIiwiYnl0ZU9mZnNldCIsImNvbnZlcnQiLCJvYmpQcm9wcyIsImdldEFsbEtleXMiLCJvYmpMZW5ndGgiLCJvdGhQcm9wcyIsInNraXBDdG9yIiwib2JqVmFsdWUiLCJvYmpDdG9yIiwib3RoQ3RvciIsImdldFN5bWJvbHMiLCJpc0tleWFibGUiLCJpc093biIsInVubWFza2VkIiwic3R1YkFycmF5IiwiQXJyYXlCdWZmZXIiLCJDdG9yIiwiY3RvclN0cmluZyIsImlzQXJyYXlMaWtlIiwic3R1YkZhbHNlIiwiaXNFcXVhbCIsIndlYnBhY2tQb2x5ZmlsbCIsImRlcHJlY2F0ZSIsInBhdGhzIiwiX2V4ZWN1dGVUYXNrcyIsImRpZmZlcmVudGlhbERvd25sb2FkZXIiLCJ0YXNrT2Zmc2V0IiwibmV4dE9mZnNldCIsInJhbmdlcyIsInBhcnRDb3VudCIsImRpY2VyIiwiYWNjZXB0UmFuZ2VzIiwicHVibGlzaGVyTmFtZXMiLCJleGVjRmlsZSIsImlzT2xkV2luNiIsImV4ZWNGaWxlU3luYyIsInRlc3RFcnJvciIsIlByaXZhdGVLZXkiLCJJc09TQmluYXJ5IiwiU2lnbmF0dXJlVHlwZSIsInNpZ25lckNlcnRpZmljYXRlIiwiU2lnbmVyQ2VydGlmaWNhdGUiLCJBcmNoaXZlZCIsIkV4dGVuc2lvbnMiLCJIYW5kbGUiLCJIYXNQcml2YXRlS2V5IiwiU3ViamVjdE5hbWUiLCJQYXRoIiwiU3RhdHVzIiwiU3ViamVjdCIsIndpblZlcnNpb24iLCJfaHR0cCIsIl9sb2FkX2h0dHAiLCJuYXRpdmVVcGRhdGVyIiwiYXV0b1VwZGF0ZXIiLCJ6aXBGaWxlSW5mbyIsInNlcnZlciIsImNyZWF0ZVNlcnZlciIsImdldFNlcnZlclVybCIsImFkZHJlc3MiLCJyZXF1ZXN0VXJsIiwid3JpdGVIZWFkIiwiZXJyb3JPY2N1cnJlZCIsImRvUHJveHlVcGRhdGVGaWxlIiwibGlzdGVuIiwibmF0aXZlUmVzcG9uc2UiLCJkb3dubG9hZFJlcXVlc3QiLCJkb3dubG9hZFJlc3BvbnNlIiwibmF0aXZlSGVhZGVycyIsImRvd25sb2FkTGlzdGVuZXJDb3VudCIsIkFQUElNQUdFIiwiaXNEb3dubG9hZEZ1bGwiLCJhcHBJbWFnZUZpbGUiLCJBUFBJTUFHRV9TSUxFTlRfSU5TVEFMTCIsIkFQUElNQUdFX0VYSVRfQUZURVJfSU5TVEFMTCIsImlwY1JlbmRlcmVyIiwidHJhbnNwb3J0Q29uc29sZSIsInRyYW5zcG9ydEZpbGUiLCJ0cmFuc3BvcnRMb2dTIiwidHJhbnNwb3J0UmVuZGVyZXJDb25zb2xlIiwidHJhbnNwb3J0cyIsImxvZ1MiLCJyZW5kZXJlckNvbnNvbGUiLCJpcGNNYWluIiwib25SZW5kZXJlckxvZyIsImFwcE5hbWUiLCJMRVZFTFMiLCJjb21wYXJlTGV2ZWxzIiwicGFzc0xldmVsIiwiY2hlY2tMZXZlbCIsInBhc3MiLCJjb25zb2xlVHJhbnNwb3J0IiwiZmluZExvZ1BhdGgiLCJtYXhTaXplIiwic3RyZWFtQ29uZmlnIiwiaW5pdFN0ZWFtQ29uZmlnIiwib3BlblN0cmVhbSIsIm5lZWRMb2dSb3RhdGlvbiIsImdldFN0cmVhbVNpemUiLCJhcmNoaXZlTG9nIiwibG9nQ29uc29sZSIsImxvZ1NpemVBdFN0YXJ0IiwiZ2V0QXBwTmFtZSIsImhvbWVEaXIiLCJob21lZGlyIiwicHJlcGFyZURpciIsImRpclBhdGgiLCJta0RpciIsIldfT0siLCJkaXJzIiwibG9hZFBhY2thZ2VOYW1lIiwicGFja2FnZUZpbGUiLCJlbGVjdHJvbk1vZHVsZSIsInBhY2thZ2VEYXRhIiwicHJvZHVjdE5hbWUiLCJodHRwIiwiaHR0cHMiLCJkZXB0aCIsImpzb25EZXB0aCIsInBvc3QiLCJzZXJ2ZXJVcmwiLCJ1cmxPYmplY3QiLCJuZXdKc29uIiwiQnJvd3NlcldpbmRvdyIsImdldEFsbFdpbmRvd3MiLCJ3bmQiLCJ3ZWJDb250ZW50cyJdLCJtYXBwaW5ncyI6IjtBQUFBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFLO0FBQ0w7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SixDQUFnQm5sQixJQUFoQixDQUFxQiwyQkFBckIsRUFBa0RoMkYsSUFBSTVWLEtBQXRELEVBQTZENlYsSUFBN0Q7QUFDRCxHQUZEO0FBR0QsQzs7Ozs7O0FDdkJELGtCQUFrQixxT0FBcU8sa3JDQUFrckMsWUFBWSxrUEFBa1AsaUJBQWlCLGtmQUFrZixVQUFVLHdFQUF3RSxvQkFBb0IsUUFBUSw0Q0FBNEMsdUIiLCJmaWxlIjoibWFpbi5qcyIsInNvdXJjZXNDb250ZW50IjpbIiBcdC8vIFRoZSBtb2R1bGUgY2FjaGVcbiBcdHZhciBpbnN0YWxsZWRNb2R1bGVzID0ge307XG5cbiBcdC8vIFRoZSByZXF1aXJlIGZ1bmN0aW9uXG4gXHRmdW5jdGlvbiBfX3dlYnBhY2tfcmVxdWlyZV9fKG1vZHVsZUlkKSB7XG5cbiBcdFx0Ly8gQ2hlY2sgaWYgbW9kdWxlIGlzIGluIGNhY2hlXG4gXHRcdGlmKGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdKSB7XG4gXHRcdFx0cmV0dXJuIGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdLmV4cG9ydHM7XG4gXHRcdH1cbiBcdFx0Ly8gQ3JlYXRlIGEgbmV3IG1vZHVsZSAoYW5kIHB1dCBpdCBpbnRvIHRoZSBjYWNoZSlcbiBcdFx0dmFyIG1vZHVsZSA9IGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdID0ge1xuIFx0XHRcdGk6IG1vZHVsZUlkLFxuIFx0XHRcdGw6IGZhbHNlLFxuIFx0XHRcdGV4cG9ydHM6IHt9XG4gXHRcdH07XG5cbiBcdFx0Ly8gRXhlY3V0ZSB0aGUgbW9kdWxlIGZ1bmN0aW9uXG4gXHRcdG1vZHVsZXNbbW9kdWxlSWRdLmNhbGwobW9kdWxlLmV4cG9ydHMsIG1vZHVsZSwgbW9kdWxlLmV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pO1xuXG4gXHRcdC8vIEZsYWcgdGhlIG1vZHVsZSBhcyBsb2FkZWRcbiBcdFx0bW9kdWxlLmwgPSB0cnVlO1xuXG4gXHRcdC8vIFJldHVybiB0aGUgZXhwb3J0cyBvZiB0aGUgbW9kdWxlXG4gXHRcdHJldHVybiBtb2R1bGUuZXhwb3J0cztcbiBcdH1cblxuXG4gXHQvLyBleHBvc2UgdGhlIG1vZHVsZXMgb2JqZWN0IChfX3dlYnBhY2tfbW9kdWxlc19fKVxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5tID0gbW9kdWxlcztcblxuIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGUgY2FjaGVcbiBcdF9fd2VicGFja19yZXF1aXJlX18uYyA9IGluc3RhbGxlZE1vZHVsZXM7XG5cbiBcdC8vIGRlZmluZSBnZXR0ZXIgZnVuY3Rpb24gZm9yIGhhcm1vbnkgZXhwb3J0c1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5kID0gZnVuY3Rpb24oZXhwb3J0cywgbmFtZSwgZ2V0dGVyKSB7XG4gXHRcdGlmKCFfX3dlYnBhY2tfcmVxdWlyZV9fLm8oZXhwb3J0cywgbmFtZSkpIHtcbiBcdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgbmFtZSwge1xuIFx0XHRcdFx0Y29uZmlndXJhYmxlOiBmYWxzZSxcbiBcdFx0XHRcdGVudW1lcmFibGU6IHRydWUsXG4gXHRcdFx0XHRnZXQ6IGdldHRlclxuIFx0XHRcdH0pO1xuIFx0XHR9XG4gXHR9O1xuXG4gXHQvLyBnZXREZWZhdWx0RXhwb3J0IGZ1bmN0aW9uIGZvciBjb21wYXRpYmlsaXR5IHdpdGggbm9uLWhhcm1vbnkgbW9kdWxlc1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5uID0gZnVuY3Rpb24obW9kdWxlKSB7XG4gXHRcdHZhciBnZXR0ZXIgPSBtb2R1bGUgJiYgbW9kdWxlLl9fZXNNb2R1bGUgP1xuIFx0XHRcdGZ1bmN0aW9uIGdldERlZmF1bHQoKSB7IHJldHVybiBtb2R1bGVbJ2RlZmF1bHQnXTsgfSA6XG4gXHRcdFx0ZnVuY3Rpb24gZ2V0TW9kdWxlRXhwb3J0cygpIHsgcmV0dXJuIG1vZHVsZTsgfTtcbiBcdFx0X193ZWJwYWNrX3JlcXVpcmVfXy5kKGdldHRlciwgJ2EnLCBnZXR0ZXIpO1xuIFx0XHRyZXR1cm4gZ2V0dGVyO1xuIFx0fTtcblxuIFx0Ly8gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm8gPSBmdW5jdGlvbihvYmplY3QsIHByb3BlcnR5KSB7IHJldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBwcm9wZXJ0eSk7IH07XG5cbiBcdC8vIF9fd2VicGFja19wdWJsaWNfcGF0aF9fXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLnAgPSBcIlwiO1xuXG4gXHQvLyBMb2FkIGVudHJ5IG1vZHVsZSBhbmQgcmV0dXJuIGV4cG9ydHNcbiBcdHJldHVybiBfX3dlYnBhY2tfcmVxdWlyZV9fKF9fd2VicGFja19yZXF1aXJlX18ucyA9IDY5KTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyB3ZWJwYWNrL2Jvb3RzdHJhcCA0ZTNhN2RhY2Y2MzUzY2QyZTBkNSIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcInBhdGhcIik7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gZXh0ZXJuYWwgXCJwYXRoXCJcbi8vIG1vZHVsZSBpZCA9IDBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgZXM1ID0gcmVxdWlyZShcIi4vZXM1XCIpO1xudmFyIGNhbkV2YWx1YXRlID0gdHlwZW9mIG5hdmlnYXRvciA9PSBcInVuZGVmaW5lZFwiO1xuXG52YXIgZXJyb3JPYmogPSB7ZToge319O1xudmFyIHRyeUNhdGNoVGFyZ2V0O1xudmFyIGdsb2JhbE9iamVjdCA9IHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiID8gc2VsZiA6XG4gICAgdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdyA6XG4gICAgdHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiA/IGdsb2JhbCA6XG4gICAgdGhpcyAhPT0gdW5kZWZpbmVkID8gdGhpcyA6IG51bGw7XG5cbmZ1bmN0aW9uIHRyeUNhdGNoZXIoKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgdmFyIHRhcmdldCA9IHRyeUNhdGNoVGFyZ2V0O1xuICAgICAgICB0cnlDYXRjaFRhcmdldCA9IG51bGw7XG4gICAgICAgIHJldHVybiB0YXJnZXQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGVycm9yT2JqLmUgPSBlO1xuICAgICAgICByZXR1cm4gZXJyb3JPYmo7XG4gICAgfVxufVxuZnVuY3Rpb24gdHJ5Q2F0Y2goZm4pIHtcbiAgICB0cnlDYXRjaFRhcmdldCA9IGZuO1xuICAgIHJldHVybiB0cnlDYXRjaGVyO1xufVxuXG52YXIgaW5oZXJpdHMgPSBmdW5jdGlvbihDaGlsZCwgUGFyZW50KSB7XG4gICAgdmFyIGhhc1Byb3AgPSB7fS5oYXNPd25Qcm9wZXJ0eTtcblxuICAgIGZ1bmN0aW9uIFQoKSB7XG4gICAgICAgIHRoaXMuY29uc3RydWN0b3IgPSBDaGlsZDtcbiAgICAgICAgdGhpcy5jb25zdHJ1Y3RvciQgPSBQYXJlbnQ7XG4gICAgICAgIGZvciAodmFyIHByb3BlcnR5TmFtZSBpbiBQYXJlbnQucHJvdG90eXBlKSB7XG4gICAgICAgICAgICBpZiAoaGFzUHJvcC5jYWxsKFBhcmVudC5wcm90b3R5cGUsIHByb3BlcnR5TmFtZSkgJiZcbiAgICAgICAgICAgICAgICBwcm9wZXJ0eU5hbWUuY2hhckF0KHByb3BlcnR5TmFtZS5sZW5ndGgtMSkgIT09IFwiJFwiXG4gICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgIHRoaXNbcHJvcGVydHlOYW1lICsgXCIkXCJdID0gUGFyZW50LnByb3RvdHlwZVtwcm9wZXJ0eU5hbWVdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIFQucHJvdG90eXBlID0gUGFyZW50LnByb3RvdHlwZTtcbiAgICBDaGlsZC5wcm90b3R5cGUgPSBuZXcgVCgpO1xuICAgIHJldHVybiBDaGlsZC5wcm90b3R5cGU7XG59O1xuXG5cbmZ1bmN0aW9uIGlzUHJpbWl0aXZlKHZhbCkge1xuICAgIHJldHVybiB2YWwgPT0gbnVsbCB8fCB2YWwgPT09IHRydWUgfHwgdmFsID09PSBmYWxzZSB8fFxuICAgICAgICB0eXBlb2YgdmFsID09PSBcInN0cmluZ1wiIHx8IHR5cGVvZiB2YWwgPT09IFwibnVtYmVyXCI7XG5cbn1cblxuZnVuY3Rpb24gaXNPYmplY3QodmFsdWUpIHtcbiAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSBcImZ1bmN0aW9uXCIgfHxcbiAgICAgICAgICAgdHlwZW9mIHZhbHVlID09PSBcIm9iamVjdFwiICYmIHZhbHVlICE9PSBudWxsO1xufVxuXG5mdW5jdGlvbiBtYXliZVdyYXBBc0Vycm9yKG1heWJlRXJyb3IpIHtcbiAgICBpZiAoIWlzUHJpbWl0aXZlKG1heWJlRXJyb3IpKSByZXR1cm4gbWF5YmVFcnJvcjtcblxuICAgIHJldHVybiBuZXcgRXJyb3Ioc2FmZVRvU3RyaW5nKG1heWJlRXJyb3IpKTtcbn1cblxuZnVuY3Rpb24gd2l0aEFwcGVuZGVkKHRhcmdldCwgYXBwZW5kZWUpIHtcbiAgICB2YXIgbGVuID0gdGFyZ2V0Lmxlbmd0aDtcbiAgICB2YXIgcmV0ID0gbmV3IEFycmF5KGxlbiArIDEpO1xuICAgIHZhciBpO1xuICAgIGZvciAoaSA9IDA7IGkgPCBsZW47ICsraSkge1xuICAgICAgICByZXRbaV0gPSB0YXJnZXRbaV07XG4gICAgfVxuICAgIHJldFtpXSA9IGFwcGVuZGVlO1xuICAgIHJldHVybiByZXQ7XG59XG5cbmZ1bmN0aW9uIGdldERhdGFQcm9wZXJ0eU9yRGVmYXVsdChvYmosIGtleSwgZGVmYXVsdFZhbHVlKSB7XG4gICAgaWYgKGVzNS5pc0VTNSkge1xuICAgICAgICB2YXIgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqLCBrZXkpO1xuXG4gICAgICAgIGlmIChkZXNjICE9IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBkZXNjLmdldCA9PSBudWxsICYmIGRlc2Muc2V0ID09IG51bGxcbiAgICAgICAgICAgICAgICAgICAgPyBkZXNjLnZhbHVlXG4gICAgICAgICAgICAgICAgICAgIDogZGVmYXVsdFZhbHVlO1xuICAgICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHt9Lmhhc093blByb3BlcnR5LmNhbGwob2JqLCBrZXkpID8gb2JqW2tleV0gOiB1bmRlZmluZWQ7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBub3RFbnVtZXJhYmxlUHJvcChvYmosIG5hbWUsIHZhbHVlKSB7XG4gICAgaWYgKGlzUHJpbWl0aXZlKG9iaikpIHJldHVybiBvYmo7XG4gICAgdmFyIGRlc2NyaXB0b3IgPSB7XG4gICAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgd3JpdGFibGU6IHRydWVcbiAgICB9O1xuICAgIGVzNS5kZWZpbmVQcm9wZXJ0eShvYmosIG5hbWUsIGRlc2NyaXB0b3IpO1xuICAgIHJldHVybiBvYmo7XG59XG5cbmZ1bmN0aW9uIHRocm93ZXIocikge1xuICAgIHRocm93IHI7XG59XG5cbnZhciBpbmhlcml0ZWREYXRhS2V5cyA9IChmdW5jdGlvbigpIHtcbiAgICB2YXIgZXhjbHVkZWRQcm90b3R5cGVzID0gW1xuICAgICAgICBBcnJheS5wcm90b3R5cGUsXG4gICAgICAgIE9iamVjdC5wcm90b3R5cGUsXG4gICAgICAgIEZ1bmN0aW9uLnByb3RvdHlwZVxuICAgIF07XG5cbiAgICB2YXIgaXNFeGNsdWRlZFByb3RvID0gZnVuY3Rpb24odmFsKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZXhjbHVkZWRQcm90b3R5cGVzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICBpZiAoZXhjbHVkZWRQcm90b3R5cGVzW2ldID09PSB2YWwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfTtcblxuICAgIGlmIChlczUuaXNFUzUpIHtcbiAgICAgICAgdmFyIGdldEtleXMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcztcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKG9iaikge1xuICAgICAgICAgICAgdmFyIHJldCA9IFtdO1xuICAgICAgICAgICAgdmFyIHZpc2l0ZWRLZXlzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgICAgICAgIHdoaWxlIChvYmogIT0gbnVsbCAmJiAhaXNFeGNsdWRlZFByb3RvKG9iaikpIHtcbiAgICAgICAgICAgICAgICB2YXIga2V5cztcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBrZXlzID0gZ2V0S2V5cyhvYmopO1xuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJldDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBrZXkgPSBrZXlzW2ldO1xuICAgICAgICAgICAgICAgICAgICBpZiAodmlzaXRlZEtleXNba2V5XSkgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgIHZpc2l0ZWRLZXlzW2tleV0gPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB2YXIgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqLCBrZXkpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZGVzYyAhPSBudWxsICYmIGRlc2MuZ2V0ID09IG51bGwgJiYgZGVzYy5zZXQgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0LnB1c2goa2V5KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBvYmogPSBlczUuZ2V0UHJvdG90eXBlT2Yob2JqKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXQ7XG4gICAgICAgIH07XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIGhhc1Byb3AgPSB7fS5oYXNPd25Qcm9wZXJ0eTtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKG9iaikge1xuICAgICAgICAgICAgaWYgKGlzRXhjbHVkZWRQcm90byhvYmopKSByZXR1cm4gW107XG4gICAgICAgICAgICB2YXIgcmV0ID0gW107XG5cbiAgICAgICAgICAgIC8qanNoaW50IGZvcmluOmZhbHNlICovXG4gICAgICAgICAgICBlbnVtZXJhdGlvbjogZm9yICh2YXIga2V5IGluIG9iaikge1xuICAgICAgICAgICAgICAgIGlmIChoYXNQcm9wLmNhbGwob2JqLCBrZXkpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldC5wdXNoKGtleSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBleGNsdWRlZFByb3RvdHlwZXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChoYXNQcm9wLmNhbGwoZXhjbHVkZWRQcm90b3R5cGVzW2ldLCBrZXkpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWUgZW51bWVyYXRpb247XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0LnB1c2goa2V5KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmV0O1xuICAgICAgICB9O1xuICAgIH1cblxufSkoKTtcblxudmFyIHRoaXNBc3NpZ25tZW50UGF0dGVybiA9IC90aGlzXFxzKlxcLlxccypcXFMrXFxzKj0vO1xuZnVuY3Rpb24gaXNDbGFzcyhmbikge1xuICAgIHRyeSB7XG4gICAgICAgIGlmICh0eXBlb2YgZm4gPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgdmFyIGtleXMgPSBlczUubmFtZXMoZm4ucHJvdG90eXBlKTtcblxuICAgICAgICAgICAgdmFyIGhhc01ldGhvZHMgPSBlczUuaXNFUzUgJiYga2V5cy5sZW5ndGggPiAxO1xuICAgICAgICAgICAgdmFyIGhhc01ldGhvZHNPdGhlclRoYW5Db25zdHJ1Y3RvciA9IGtleXMubGVuZ3RoID4gMCAmJlxuICAgICAgICAgICAgICAgICEoa2V5cy5sZW5ndGggPT09IDEgJiYga2V5c1swXSA9PT0gXCJjb25zdHJ1Y3RvclwiKTtcbiAgICAgICAgICAgIHZhciBoYXNUaGlzQXNzaWdubWVudEFuZFN0YXRpY01ldGhvZHMgPVxuICAgICAgICAgICAgICAgIHRoaXNBc3NpZ25tZW50UGF0dGVybi50ZXN0KGZuICsgXCJcIikgJiYgZXM1Lm5hbWVzKGZuKS5sZW5ndGggPiAwO1xuXG4gICAgICAgICAgICBpZiAoaGFzTWV0aG9kcyB8fCBoYXNNZXRob2RzT3RoZXJUaGFuQ29uc3RydWN0b3IgfHxcbiAgICAgICAgICAgICAgICBoYXNUaGlzQXNzaWdubWVudEFuZFN0YXRpY01ldGhvZHMpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxufVxuXG5mdW5jdGlvbiB0b0Zhc3RQcm9wZXJ0aWVzKG9iaikge1xuICAgIC8qanNoaW50IC1XMDI3LC1XMDU1LC1XMDMxKi9cbiAgICBmdW5jdGlvbiBGYWtlQ29uc3RydWN0b3IoKSB7fVxuICAgIEZha2VDb25zdHJ1Y3Rvci5wcm90b3R5cGUgPSBvYmo7XG4gICAgdmFyIGwgPSA4O1xuICAgIHdoaWxlIChsLS0pIG5ldyBGYWtlQ29uc3RydWN0b3IoKTtcbiAgICByZXR1cm4gb2JqO1xuICAgIGV2YWwob2JqKTtcbn1cblxudmFyIHJpZGVudCA9IC9eW2EteiRfXVthLXokXzAtOV0qJC9pO1xuZnVuY3Rpb24gaXNJZGVudGlmaWVyKHN0cikge1xuICAgIHJldHVybiByaWRlbnQudGVzdChzdHIpO1xufVxuXG5mdW5jdGlvbiBmaWxsZWRSYW5nZShjb3VudCwgcHJlZml4LCBzdWZmaXgpIHtcbiAgICB2YXIgcmV0ID0gbmV3IEFycmF5KGNvdW50KTtcbiAgICBmb3IodmFyIGkgPSAwOyBpIDwgY291bnQ7ICsraSkge1xuICAgICAgICByZXRbaV0gPSBwcmVmaXggKyBpICsgc3VmZml4O1xuICAgIH1cbiAgICByZXR1cm4gcmV0O1xufVxuXG5mdW5jdGlvbiBzYWZlVG9TdHJpbmcob2JqKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIG9iaiArIFwiXCI7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgICByZXR1cm4gXCJbbm8gc3RyaW5nIHJlcHJlc2VudGF0aW9uXVwiO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gaXNFcnJvcihvYmopIHtcbiAgICByZXR1cm4gb2JqIGluc3RhbmNlb2YgRXJyb3IgfHxcbiAgICAgICAgKG9iaiAhPT0gbnVsbCAmJlxuICAgICAgICAgICB0eXBlb2Ygb2JqID09PSBcIm9iamVjdFwiICYmXG4gICAgICAgICAgIHR5cGVvZiBvYmoubWVzc2FnZSA9PT0gXCJzdHJpbmdcIiAmJlxuICAgICAgICAgICB0eXBlb2Ygb2JqLm5hbWUgPT09IFwic3RyaW5nXCIpO1xufVxuXG5mdW5jdGlvbiBtYXJrQXNPcmlnaW5hdGluZ0Zyb21SZWplY3Rpb24oZSkge1xuICAgIHRyeSB7XG4gICAgICAgIG5vdEVudW1lcmFibGVQcm9wKGUsIFwiaXNPcGVyYXRpb25hbFwiLCB0cnVlKTtcbiAgICB9XG4gICAgY2F0Y2goaWdub3JlKSB7fVxufVxuXG5mdW5jdGlvbiBvcmlnaW5hdGVzRnJvbVJlamVjdGlvbihlKSB7XG4gICAgaWYgKGUgPT0gbnVsbCkgcmV0dXJuIGZhbHNlO1xuICAgIHJldHVybiAoKGUgaW5zdGFuY2VvZiBFcnJvcltcIl9fQmx1ZWJpcmRFcnJvclR5cGVzX19cIl0uT3BlcmF0aW9uYWxFcnJvcikgfHxcbiAgICAgICAgZVtcImlzT3BlcmF0aW9uYWxcIl0gPT09IHRydWUpO1xufVxuXG5mdW5jdGlvbiBjYW5BdHRhY2hUcmFjZShvYmopIHtcbiAgICByZXR1cm4gaXNFcnJvcihvYmopICYmIGVzNS5wcm9wZXJ0eUlzV3JpdGFibGUob2JqLCBcInN0YWNrXCIpO1xufVxuXG52YXIgZW5zdXJlRXJyb3JPYmplY3QgPSAoZnVuY3Rpb24oKSB7XG4gICAgaWYgKCEoXCJzdGFja1wiIGluIG5ldyBFcnJvcigpKSkge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgICAgIGlmIChjYW5BdHRhY2hUcmFjZSh2YWx1ZSkpIHJldHVybiB2YWx1ZTtcbiAgICAgICAgICAgIHRyeSB7dGhyb3cgbmV3IEVycm9yKHNhZmVUb1N0cmluZyh2YWx1ZSkpO31cbiAgICAgICAgICAgIGNhdGNoKGVycikge3JldHVybiBlcnI7fVxuICAgICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICAgICAgaWYgKGNhbkF0dGFjaFRyYWNlKHZhbHVlKSkgcmV0dXJuIHZhbHVlO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBFcnJvcihzYWZlVG9TdHJpbmcodmFsdWUpKTtcbiAgICAgICAgfTtcbiAgICB9XG59KSgpO1xuXG5mdW5jdGlvbiBjbGFzc1N0cmluZyhvYmopIHtcbiAgICByZXR1cm4ge30udG9TdHJpbmcuY2FsbChvYmopO1xufVxuXG5mdW5jdGlvbiBjb3B5RGVzY3JpcHRvcnMoZnJvbSwgdG8sIGZpbHRlcikge1xuICAgIHZhciBrZXlzID0gZXM1Lm5hbWVzKGZyb20pO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7ICsraSkge1xuICAgICAgICB2YXIga2V5ID0ga2V5c1tpXTtcbiAgICAgICAgaWYgKGZpbHRlcihrZXkpKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGVzNS5kZWZpbmVQcm9wZXJ0eSh0bywga2V5LCBlczUuZ2V0RGVzY3JpcHRvcihmcm9tLCBrZXkpKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGlnbm9yZSkge31cbiAgICAgICAgfVxuICAgIH1cbn1cblxudmFyIGFzQXJyYXkgPSBmdW5jdGlvbih2KSB7XG4gICAgaWYgKGVzNS5pc0FycmF5KHYpKSB7XG4gICAgICAgIHJldHVybiB2O1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbn07XG5cbmlmICh0eXBlb2YgU3ltYm9sICE9PSBcInVuZGVmaW5lZFwiICYmIFN5bWJvbC5pdGVyYXRvcikge1xuICAgIHZhciBBcnJheUZyb20gPSB0eXBlb2YgQXJyYXkuZnJvbSA9PT0gXCJmdW5jdGlvblwiID8gZnVuY3Rpb24odikge1xuICAgICAgICByZXR1cm4gQXJyYXkuZnJvbSh2KTtcbiAgICB9IDogZnVuY3Rpb24odikge1xuICAgICAgICB2YXIgcmV0ID0gW107XG4gICAgICAgIHZhciBpdCA9IHZbU3ltYm9sLml0ZXJhdG9yXSgpO1xuICAgICAgICB2YXIgaXRSZXN1bHQ7XG4gICAgICAgIHdoaWxlICghKChpdFJlc3VsdCA9IGl0Lm5leHQoKSkuZG9uZSkpIHtcbiAgICAgICAgICAgIHJldC5wdXNoKGl0UmVzdWx0LnZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmV0O1xuICAgIH07XG5cbiAgICBhc0FycmF5ID0gZnVuY3Rpb24odikge1xuICAgICAgICBpZiAoZXM1LmlzQXJyYXkodikpIHtcbiAgICAgICAgICAgIHJldHVybiB2O1xuICAgICAgICB9IGVsc2UgaWYgKHYgIT0gbnVsbCAmJiB0eXBlb2YgdltTeW1ib2wuaXRlcmF0b3JdID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgIHJldHVybiBBcnJheUZyb20odik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfTtcbn1cblxudmFyIGlzTm9kZSA9IHR5cGVvZiBwcm9jZXNzICE9PSBcInVuZGVmaW5lZFwiICYmXG4gICAgICAgIGNsYXNzU3RyaW5nKHByb2Nlc3MpLnRvTG93ZXJDYXNlKCkgPT09IFwiW29iamVjdCBwcm9jZXNzXVwiO1xuXG52YXIgaGFzRW52VmFyaWFibGVzID0gdHlwZW9mIHByb2Nlc3MgIT09IFwidW5kZWZpbmVkXCIgJiZcbiAgICB0eXBlb2YgcHJvY2Vzcy5lbnYgIT09IFwidW5kZWZpbmVkXCI7XG5cbmZ1bmN0aW9uIGVudihrZXkpIHtcbiAgICByZXR1cm4gaGFzRW52VmFyaWFibGVzID8gcHJvY2Vzcy5lbnZba2V5XSA6IHVuZGVmaW5lZDtcbn1cblxuZnVuY3Rpb24gZ2V0TmF0aXZlUHJvbWlzZSgpIHtcbiAgICBpZiAodHlwZW9mIFByb21pc2UgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgdmFyIHByb21pc2UgPSBuZXcgUHJvbWlzZShmdW5jdGlvbigpe30pO1xuICAgICAgICAgICAgaWYgKHt9LnRvU3RyaW5nLmNhbGwocHJvbWlzZSkgPT09IFwiW29iamVjdCBQcm9taXNlXVwiKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gY2F0Y2ggKGUpIHt9XG4gICAgfVxufVxuXG5mdW5jdGlvbiBkb21haW5CaW5kKHNlbGYsIGNiKSB7XG4gICAgcmV0dXJuIHNlbGYuYmluZChjYik7XG59XG5cbnZhciByZXQgPSB7XG4gICAgaXNDbGFzczogaXNDbGFzcyxcbiAgICBpc0lkZW50aWZpZXI6IGlzSWRlbnRpZmllcixcbiAgICBpbmhlcml0ZWREYXRhS2V5czogaW5oZXJpdGVkRGF0YUtleXMsXG4gICAgZ2V0RGF0YVByb3BlcnR5T3JEZWZhdWx0OiBnZXREYXRhUHJvcGVydHlPckRlZmF1bHQsXG4gICAgdGhyb3dlcjogdGhyb3dlcixcbiAgICBpc0FycmF5OiBlczUuaXNBcnJheSxcbiAgICBhc0FycmF5OiBhc0FycmF5LFxuICAgIG5vdEVudW1lcmFibGVQcm9wOiBub3RFbnVtZXJhYmxlUHJvcCxcbiAgICBpc1ByaW1pdGl2ZTogaXNQcmltaXRpdmUsXG4gICAgaXNPYmplY3Q6IGlzT2JqZWN0LFxuICAgIGlzRXJyb3I6IGlzRXJyb3IsXG4gICAgY2FuRXZhbHVhdGU6IGNhbkV2YWx1YXRlLFxuICAgIGVycm9yT2JqOiBlcnJvck9iaixcbiAgICB0cnlDYXRjaDogdHJ5Q2F0Y2gsXG4gICAgaW5oZXJpdHM6IGluaGVyaXRzLFxuICAgIHdpdGhBcHBlbmRlZDogd2l0aEFwcGVuZGVkLFxuICAgIG1heWJlV3JhcEFzRXJyb3I6IG1heWJlV3JhcEFzRXJyb3IsXG4gICAgdG9GYXN0UHJvcGVydGllczogdG9GYXN0UHJvcGVydGllcyxcbiAgICBmaWxsZWRSYW5nZTogZmlsbGVkUmFuZ2UsXG4gICAgdG9TdHJpbmc6IHNhZmVUb1N0cmluZyxcbiAgICBjYW5BdHRhY2hUcmFjZTogY2FuQXR0YWNoVHJhY2UsXG4gICAgZW5zdXJlRXJyb3JPYmplY3Q6IGVuc3VyZUVycm9yT2JqZWN0LFxuICAgIG9yaWdpbmF0ZXNGcm9tUmVqZWN0aW9uOiBvcmlnaW5hdGVzRnJvbVJlamVjdGlvbixcbiAgICBtYXJrQXNPcmlnaW5hdGluZ0Zyb21SZWplY3Rpb246IG1hcmtBc09yaWdpbmF0aW5nRnJvbVJlamVjdGlvbixcbiAgICBjbGFzc1N0cmluZzogY2xhc3NTdHJpbmcsXG4gICAgY29weURlc2NyaXB0b3JzOiBjb3B5RGVzY3JpcHRvcnMsXG4gICAgaGFzRGV2VG9vbHM6IHR5cGVvZiBjaHJvbWUgIT09IFwidW5kZWZpbmVkXCIgJiYgY2hyb21lICYmXG4gICAgICAgICAgICAgICAgIHR5cGVvZiBjaHJvbWUubG9hZFRpbWVzID09PSBcImZ1bmN0aW9uXCIsXG4gICAgaXNOb2RlOiBpc05vZGUsXG4gICAgaGFzRW52VmFyaWFibGVzOiBoYXNFbnZWYXJpYWJsZXMsXG4gICAgZW52OiBlbnYsXG4gICAgZ2xvYmFsOiBnbG9iYWxPYmplY3QsXG4gICAgZ2V0TmF0aXZlUHJvbWlzZTogZ2V0TmF0aXZlUHJvbWlzZSxcbiAgICBkb21haW5CaW5kOiBkb21haW5CaW5kXG59O1xucmV0LmlzUmVjZW50Tm9kZSA9IHJldC5pc05vZGUgJiYgKGZ1bmN0aW9uKCkge1xuICAgIHZhciB2ZXJzaW9uID0gcHJvY2Vzcy52ZXJzaW9ucy5ub2RlLnNwbGl0KFwiLlwiKS5tYXAoTnVtYmVyKTtcbiAgICByZXR1cm4gKHZlcnNpb25bMF0gPT09IDAgJiYgdmVyc2lvblsxXSA+IDEwKSB8fCAodmVyc2lvblswXSA+IDApO1xufSkoKTtcblxuaWYgKHJldC5pc05vZGUpIHJldC50b0Zhc3RQcm9wZXJ0aWVzKHByb2Nlc3MpO1xuXG50cnkge3Rocm93IG5ldyBFcnJvcigpOyB9IGNhdGNoIChlKSB7cmV0Lmxhc3RMaW5lRXJyb3IgPSBlO31cbm1vZHVsZS5leHBvcnRzID0gcmV0O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2JsdWViaXJkL2pzL3JlbGVhc2UvdXRpbC5qcyIsImNvbnN0IEJsdWViaXJkUHJvbWlzZSA9IHJlcXVpcmUoXCJibHVlYmlyZC9qcy9yZWxlYXNlL3Byb21pc2VcIikoKVxuQmx1ZWJpcmRQcm9taXNlLmNvbmZpZyh7XG4gIGxvbmdTdGFja1RyYWNlczogdHJ1ZSxcbn0pXG5CbHVlYmlyZFByb21pc2UuZGVmYXVsdCA9IEJsdWViaXJkUHJvbWlzZVxubW9kdWxlLmV4cG9ydHMgPSBCbHVlYmlyZFByb21pc2VcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvYmx1ZWJpcmQtbHN0L2luZGV4LmpzIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgIHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF9DYW5jZWxsYXRpb25Ub2tlbjtcblxuZnVuY3Rpb24gX2xvYWRfQ2FuY2VsbGF0aW9uVG9rZW4oKSB7XG4gICAgcmV0dXJuIF9DYW5jZWxsYXRpb25Ub2tlbiA9IHJlcXVpcmUoXCIuL0NhbmNlbGxhdGlvblRva2VuXCIpO1xufVxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJDYW5jZWxsYXRpb25Ub2tlblwiLCB7XG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIChfQ2FuY2VsbGF0aW9uVG9rZW4gfHwgX2xvYWRfQ2FuY2VsbGF0aW9uVG9rZW4oKSkuQ2FuY2VsbGF0aW9uVG9rZW47XG4gICAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJDYW5jZWxsYXRpb25FcnJvclwiLCB7XG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIChfQ2FuY2VsbGF0aW9uVG9rZW4gfHwgX2xvYWRfQ2FuY2VsbGF0aW9uVG9rZW4oKSkuQ2FuY2VsbGF0aW9uRXJyb3I7XG4gICAgfVxufSk7XG5cbnZhciBfaHR0cEV4ZWN1dG9yO1xuXG5mdW5jdGlvbiBfbG9hZF9odHRwRXhlY3V0b3IoKSB7XG4gICAgcmV0dXJuIF9odHRwRXhlY3V0b3IgPSByZXF1aXJlKFwiLi9odHRwRXhlY3V0b3JcIik7XG59XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkh0dHBFcnJvclwiLCB7XG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIChfaHR0cEV4ZWN1dG9yIHx8IF9sb2FkX2h0dHBFeGVjdXRvcigpKS5IdHRwRXJyb3I7XG4gICAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJjcmVhdGVIdHRwRXJyb3JcIiwge1xuICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiAoX2h0dHBFeGVjdXRvciB8fCBfbG9hZF9odHRwRXhlY3V0b3IoKSkuY3JlYXRlSHR0cEVycm9yO1xuICAgIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiSHR0cEV4ZWN1dG9yXCIsIHtcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gKF9odHRwRXhlY3V0b3IgfHwgX2xvYWRfaHR0cEV4ZWN1dG9yKCkpLkh0dHBFeGVjdXRvcjtcbiAgICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkRpZ2VzdFRyYW5zZm9ybVwiLCB7XG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIChfaHR0cEV4ZWN1dG9yIHx8IF9sb2FkX2h0dHBFeGVjdXRvcigpKS5EaWdlc3RUcmFuc2Zvcm07XG4gICAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJzYWZlR2V0SGVhZGVyXCIsIHtcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gKF9odHRwRXhlY3V0b3IgfHwgX2xvYWRfaHR0cEV4ZWN1dG9yKCkpLnNhZmVHZXRIZWFkZXI7XG4gICAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJjb25maWd1cmVSZXF1ZXN0T3B0aW9uc1wiLCB7XG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIChfaHR0cEV4ZWN1dG9yIHx8IF9sb2FkX2h0dHBFeGVjdXRvcigpKS5jb25maWd1cmVSZXF1ZXN0T3B0aW9ucztcbiAgICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImNvbmZpZ3VyZVJlcXVlc3RPcHRpb25zRnJvbVVybFwiLCB7XG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIChfaHR0cEV4ZWN1dG9yIHx8IF9sb2FkX2h0dHBFeGVjdXRvcigpKS5jb25maWd1cmVSZXF1ZXN0T3B0aW9uc0Zyb21Vcmw7XG4gICAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJzYWZlU3RyaW5naWZ5SnNvblwiLCB7XG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIChfaHR0cEV4ZWN1dG9yIHx8IF9sb2FkX2h0dHBFeGVjdXRvcigpKS5zYWZlU3RyaW5naWZ5SnNvbjtcbiAgICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcInBhcnNlSnNvblwiLCB7XG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIChfaHR0cEV4ZWN1dG9yIHx8IF9sb2FkX2h0dHBFeGVjdXRvcigpKS5wYXJzZUpzb247XG4gICAgfVxufSk7XG5cbnZhciBfcHVibGlzaE9wdGlvbnM7XG5cbmZ1bmN0aW9uIF9sb2FkX3B1Ymxpc2hPcHRpb25zKCkge1xuICAgIHJldHVybiBfcHVibGlzaE9wdGlvbnMgPSByZXF1aXJlKFwiLi9wdWJsaXNoT3B0aW9uc1wiKTtcbn1cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiZ2V0UzNMaWtlUHJvdmlkZXJCYXNlVXJsXCIsIHtcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gKF9wdWJsaXNoT3B0aW9ucyB8fCBfbG9hZF9wdWJsaXNoT3B0aW9ucygpKS5nZXRTM0xpa2VQcm92aWRlckJhc2VVcmw7XG4gICAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJnaXRodWJVcmxcIiwge1xuICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiAoX3B1Ymxpc2hPcHRpb25zIHx8IF9sb2FkX3B1Ymxpc2hPcHRpb25zKCkpLmdpdGh1YlVybDtcbiAgICB9XG59KTtcblxudmFyIF9yZmMyMjUzUGFyc2VyO1xuXG5mdW5jdGlvbiBfbG9hZF9yZmMyMjUzUGFyc2VyKCkge1xuICAgIHJldHVybiBfcmZjMjI1M1BhcnNlciA9IHJlcXVpcmUoXCIuL3JmYzIyNTNQYXJzZXJcIik7XG59XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcInBhcnNlRG5cIiwge1xuICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiAoX3JmYzIyNTNQYXJzZXIgfHwgX2xvYWRfcmZjMjI1M1BhcnNlcigpKS5wYXJzZURuO1xuICAgIH1cbn0pO1xuXG52YXIgX3V1aWQ7XG5cbmZ1bmN0aW9uIF9sb2FkX3V1aWQoKSB7XG4gICAgcmV0dXJuIF91dWlkID0gcmVxdWlyZShcIi4vdXVpZFwiKTtcbn1cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiVVVJRFwiLCB7XG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIChfdXVpZCB8fCBfbG9hZF91dWlkKCkpLlVVSUQ7XG4gICAgfVxufSk7XG5cbnZhciBfUHJvZ3Jlc3NDYWxsYmFja1RyYW5zZm9ybTtcblxuZnVuY3Rpb24gX2xvYWRfUHJvZ3Jlc3NDYWxsYmFja1RyYW5zZm9ybSgpIHtcbiAgICByZXR1cm4gX1Byb2dyZXNzQ2FsbGJhY2tUcmFuc2Zvcm0gPSByZXF1aXJlKFwiLi9Qcm9ncmVzc0NhbGxiYWNrVHJhbnNmb3JtXCIpO1xufVxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJQcm9ncmVzc0NhbGxiYWNrVHJhbnNmb3JtXCIsIHtcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gKF9Qcm9ncmVzc0NhbGxiYWNrVHJhbnNmb3JtIHx8IF9sb2FkX1Byb2dyZXNzQ2FsbGJhY2tUcmFuc2Zvcm0oKSkuUHJvZ3Jlc3NDYWxsYmFja1RyYW5zZm9ybTtcbiAgICB9XG59KTtcblxudmFyIF94bWw7XG5cbmZ1bmN0aW9uIF9sb2FkX3htbCgpIHtcbiAgICByZXR1cm4gX3htbCA9IHJlcXVpcmUoXCIuL3htbFwiKTtcbn1cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwicGFyc2VYbWxcIiwge1xuICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiAoX3htbCB8fCBfbG9hZF94bWwoKSkucGFyc2VYbWw7XG4gICAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJYRWxlbWVudFwiLCB7XG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIChfeG1sIHx8IF9sb2FkX3htbCgpKS5YRWxlbWVudDtcbiAgICB9XG59KTtcbmV4cG9ydHMuYXNBcnJheSA9IGFzQXJyYXk7XG5leHBvcnRzLm5ld0Vycm9yID0gbmV3RXJyb3I7XG5mdW5jdGlvbiBhc0FycmF5KHYpIHtcbiAgICBpZiAodiA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkodikpIHtcbiAgICAgICAgcmV0dXJuIHY7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIFt2XTtcbiAgICB9XG59XG5mdW5jdGlvbiBuZXdFcnJvcihtZXNzYWdlLCBjb2RlKSB7XG4gICAgY29uc3QgZXJyb3IgPSBuZXcgRXJyb3IobWVzc2FnZSk7XG4gICAgZXJyb3IuY29kZSA9IGNvZGU7XG4gICAgcmV0dXJuIGVycm9yO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2VsZWN0cm9uLXVwZGF0ZXIvbm9kZV9tb2R1bGVzL2J1aWxkZXItdXRpbC1ydW50aW1lL291dC9pbmRleC5qcyIsIid1c2Ugc3RyaWN0JztcblxudmFyIFlBTUxFeGNlcHRpb24gPSByZXF1aXJlKCcuL2V4Y2VwdGlvbicpO1xuXG52YXIgVFlQRV9DT05TVFJVQ1RPUl9PUFRJT05TID0gW1xuICAna2luZCcsXG4gICdyZXNvbHZlJyxcbiAgJ2NvbnN0cnVjdCcsXG4gICdpbnN0YW5jZU9mJyxcbiAgJ3ByZWRpY2F0ZScsXG4gICdyZXByZXNlbnQnLFxuICAnZGVmYXVsdFN0eWxlJyxcbiAgJ3N0eWxlQWxpYXNlcydcbl07XG5cbnZhciBZQU1MX05PREVfS0lORFMgPSBbXG4gICdzY2FsYXInLFxuICAnc2VxdWVuY2UnLFxuICAnbWFwcGluZydcbl07XG5cbmZ1bmN0aW9uIGNvbXBpbGVTdHlsZUFsaWFzZXMobWFwKSB7XG4gIHZhciByZXN1bHQgPSB7fTtcblxuICBpZiAobWFwICE9PSBudWxsKSB7XG4gICAgT2JqZWN0LmtleXMobWFwKS5mb3JFYWNoKGZ1bmN0aW9uIChzdHlsZSkge1xuICAgICAgbWFwW3N0eWxlXS5mb3JFYWNoKGZ1bmN0aW9uIChhbGlhcykge1xuICAgICAgICByZXN1bHRbU3RyaW5nKGFsaWFzKV0gPSBzdHlsZTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuZnVuY3Rpb24gVHlwZSh0YWcsIG9wdGlvbnMpIHtcbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgT2JqZWN0LmtleXMob3B0aW9ucykuZm9yRWFjaChmdW5jdGlvbiAobmFtZSkge1xuICAgIGlmIChUWVBFX0NPTlNUUlVDVE9SX09QVElPTlMuaW5kZXhPZihuYW1lKSA9PT0gLTEpIHtcbiAgICAgIHRocm93IG5ldyBZQU1MRXhjZXB0aW9uKCdVbmtub3duIG9wdGlvbiBcIicgKyBuYW1lICsgJ1wiIGlzIG1ldCBpbiBkZWZpbml0aW9uIG9mIFwiJyArIHRhZyArICdcIiBZQU1MIHR5cGUuJyk7XG4gICAgfVxuICB9KTtcblxuICAvLyBUT0RPOiBBZGQgdGFnIGZvcm1hdCBjaGVjay5cbiAgdGhpcy50YWcgICAgICAgICAgPSB0YWc7XG4gIHRoaXMua2luZCAgICAgICAgID0gb3B0aW9uc1sna2luZCddICAgICAgICAgfHwgbnVsbDtcbiAgdGhpcy5yZXNvbHZlICAgICAgPSBvcHRpb25zWydyZXNvbHZlJ10gICAgICB8fCBmdW5jdGlvbiAoKSB7IHJldHVybiB0cnVlOyB9O1xuICB0aGlzLmNvbnN0cnVjdCAgICA9IG9wdGlvbnNbJ2NvbnN0cnVjdCddICAgIHx8IGZ1bmN0aW9uIChkYXRhKSB7IHJldHVybiBkYXRhOyB9O1xuICB0aGlzLmluc3RhbmNlT2YgICA9IG9wdGlvbnNbJ2luc3RhbmNlT2YnXSAgIHx8IG51bGw7XG4gIHRoaXMucHJlZGljYXRlICAgID0gb3B0aW9uc1sncHJlZGljYXRlJ10gICAgfHwgbnVsbDtcbiAgdGhpcy5yZXByZXNlbnQgICAgPSBvcHRpb25zWydyZXByZXNlbnQnXSAgICB8fCBudWxsO1xuICB0aGlzLmRlZmF1bHRTdHlsZSA9IG9wdGlvbnNbJ2RlZmF1bHRTdHlsZSddIHx8IG51bGw7XG4gIHRoaXMuc3R5bGVBbGlhc2VzID0gY29tcGlsZVN0eWxlQWxpYXNlcyhvcHRpb25zWydzdHlsZUFsaWFzZXMnXSB8fCBudWxsKTtcblxuICBpZiAoWUFNTF9OT0RFX0tJTkRTLmluZGV4T2YodGhpcy5raW5kKSA9PT0gLTEpIHtcbiAgICB0aHJvdyBuZXcgWUFNTEV4Y2VwdGlvbignVW5rbm93biBraW5kIFwiJyArIHRoaXMua2luZCArICdcIiBpcyBzcGVjaWZpZWQgZm9yIFwiJyArIHRhZyArICdcIiBZQU1MIHR5cGUuJyk7XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBUeXBlO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2pzLXlhbWwvbGliL2pzLXlhbWwvdHlwZS5qcyIsInZhciBmcyA9IHJlcXVpcmUoJ2ZzJylcbnZhciBwb2x5ZmlsbHMgPSByZXF1aXJlKCcuL3BvbHlmaWxscy5qcycpXG52YXIgbGVnYWN5ID0gcmVxdWlyZSgnLi9sZWdhY3ktc3RyZWFtcy5qcycpXG52YXIgcXVldWUgPSBbXVxuXG52YXIgdXRpbCA9IHJlcXVpcmUoJ3V0aWwnKVxuXG5mdW5jdGlvbiBub29wICgpIHt9XG5cbnZhciBkZWJ1ZyA9IG5vb3BcbmlmICh1dGlsLmRlYnVnbG9nKVxuICBkZWJ1ZyA9IHV0aWwuZGVidWdsb2coJ2dmczQnKVxuZWxzZSBpZiAoL1xcYmdmczRcXGIvaS50ZXN0KHByb2Nlc3MuZW52Lk5PREVfREVCVUcgfHwgJycpKVxuICBkZWJ1ZyA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBtID0gdXRpbC5mb3JtYXQuYXBwbHkodXRpbCwgYXJndW1lbnRzKVxuICAgIG0gPSAnR0ZTNDogJyArIG0uc3BsaXQoL1xcbi8pLmpvaW4oJ1xcbkdGUzQ6ICcpXG4gICAgY29uc29sZS5lcnJvcihtKVxuICB9XG5cbmlmICgvXFxiZ2ZzNFxcYi9pLnRlc3QocHJvY2Vzcy5lbnYuTk9ERV9ERUJVRyB8fCAnJykpIHtcbiAgcHJvY2Vzcy5vbignZXhpdCcsIGZ1bmN0aW9uKCkge1xuICAgIGRlYnVnKHF1ZXVlKVxuICAgIHJlcXVpcmUoJ2Fzc2VydCcpLmVxdWFsKHF1ZXVlLmxlbmd0aCwgMClcbiAgfSlcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBwYXRjaChyZXF1aXJlKCcuL2ZzLmpzJykpXG5pZiAocHJvY2Vzcy5lbnYuVEVTVF9HUkFDRUZVTF9GU19HTE9CQUxfUEFUQ0gpIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSBwYXRjaChmcylcbn1cblxuLy8gQWx3YXlzIHBhdGNoIGZzLmNsb3NlL2Nsb3NlU3luYywgYmVjYXVzZSB3ZSB3YW50IHRvXG4vLyByZXRyeSgpIHdoZW5ldmVyIGEgY2xvc2UgaGFwcGVucyAqYW55d2hlcmUqIGluIHRoZSBwcm9ncmFtLlxuLy8gVGhpcyBpcyBlc3NlbnRpYWwgd2hlbiBtdWx0aXBsZSBncmFjZWZ1bC1mcyBpbnN0YW5jZXMgYXJlXG4vLyBpbiBwbGF5IGF0IHRoZSBzYW1lIHRpbWUuXG5tb2R1bGUuZXhwb3J0cy5jbG9zZSA9XG5mcy5jbG9zZSA9IChmdW5jdGlvbiAoZnMkY2xvc2UpIHsgcmV0dXJuIGZ1bmN0aW9uIChmZCwgY2IpIHtcbiAgcmV0dXJuIGZzJGNsb3NlLmNhbGwoZnMsIGZkLCBmdW5jdGlvbiAoZXJyKSB7XG4gICAgaWYgKCFlcnIpXG4gICAgICByZXRyeSgpXG5cbiAgICBpZiAodHlwZW9mIGNiID09PSAnZnVuY3Rpb24nKVxuICAgICAgY2IuYXBwbHkodGhpcywgYXJndW1lbnRzKVxuICB9KVxufX0pKGZzLmNsb3NlKVxuXG5tb2R1bGUuZXhwb3J0cy5jbG9zZVN5bmMgPVxuZnMuY2xvc2VTeW5jID0gKGZ1bmN0aW9uIChmcyRjbG9zZVN5bmMpIHsgcmV0dXJuIGZ1bmN0aW9uIChmZCkge1xuICAvLyBOb3RlIHRoYXQgZ3JhY2VmdWwtZnMgYWxzbyByZXRyaWVzIHdoZW4gZnMuY2xvc2VTeW5jKCkgZmFpbHMuXG4gIC8vIExvb2tzIGxpa2UgYSBidWcgdG8gbWUsIGFsdGhvdWdoIGl0J3MgcHJvYmFibHkgYSBoYXJtbGVzcyBvbmUuXG4gIHZhciBydmFsID0gZnMkY2xvc2VTeW5jLmFwcGx5KGZzLCBhcmd1bWVudHMpXG4gIHJldHJ5KClcbiAgcmV0dXJuIHJ2YWxcbn19KShmcy5jbG9zZVN5bmMpXG5cbmZ1bmN0aW9uIHBhdGNoIChmcykge1xuICAvLyBFdmVyeXRoaW5nIHRoYXQgcmVmZXJlbmNlcyB0aGUgb3BlbigpIGZ1bmN0aW9uIG5lZWRzIHRvIGJlIGluIGhlcmVcbiAgcG9seWZpbGxzKGZzKVxuICBmcy5ncmFjZWZ1bGlmeSA9IHBhdGNoXG4gIGZzLkZpbGVSZWFkU3RyZWFtID0gUmVhZFN0cmVhbTsgIC8vIExlZ2FjeSBuYW1lLlxuICBmcy5GaWxlV3JpdGVTdHJlYW0gPSBXcml0ZVN0cmVhbTsgIC8vIExlZ2FjeSBuYW1lLlxuICBmcy5jcmVhdGVSZWFkU3RyZWFtID0gY3JlYXRlUmVhZFN0cmVhbVxuICBmcy5jcmVhdGVXcml0ZVN0cmVhbSA9IGNyZWF0ZVdyaXRlU3RyZWFtXG4gIHZhciBmcyRyZWFkRmlsZSA9IGZzLnJlYWRGaWxlXG4gIGZzLnJlYWRGaWxlID0gcmVhZEZpbGVcbiAgZnVuY3Rpb24gcmVhZEZpbGUgKHBhdGgsIG9wdGlvbnMsIGNiKSB7XG4gICAgaWYgKHR5cGVvZiBvcHRpb25zID09PSAnZnVuY3Rpb24nKVxuICAgICAgY2IgPSBvcHRpb25zLCBvcHRpb25zID0gbnVsbFxuXG4gICAgcmV0dXJuIGdvJHJlYWRGaWxlKHBhdGgsIG9wdGlvbnMsIGNiKVxuXG4gICAgZnVuY3Rpb24gZ28kcmVhZEZpbGUgKHBhdGgsIG9wdGlvbnMsIGNiKSB7XG4gICAgICByZXR1cm4gZnMkcmVhZEZpbGUocGF0aCwgb3B0aW9ucywgZnVuY3Rpb24gKGVycikge1xuICAgICAgICBpZiAoZXJyICYmIChlcnIuY29kZSA9PT0gJ0VNRklMRScgfHwgZXJyLmNvZGUgPT09ICdFTkZJTEUnKSlcbiAgICAgICAgICBlbnF1ZXVlKFtnbyRyZWFkRmlsZSwgW3BhdGgsIG9wdGlvbnMsIGNiXV0pXG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIGlmICh0eXBlb2YgY2IgPT09ICdmdW5jdGlvbicpXG4gICAgICAgICAgICBjYi5hcHBseSh0aGlzLCBhcmd1bWVudHMpXG4gICAgICAgICAgcmV0cnkoKVxuICAgICAgICB9XG4gICAgICB9KVxuICAgIH1cbiAgfVxuXG4gIHZhciBmcyR3cml0ZUZpbGUgPSBmcy53cml0ZUZpbGVcbiAgZnMud3JpdGVGaWxlID0gd3JpdGVGaWxlXG4gIGZ1bmN0aW9uIHdyaXRlRmlsZSAocGF0aCwgZGF0YSwgb3B0aW9ucywgY2IpIHtcbiAgICBpZiAodHlwZW9mIG9wdGlvbnMgPT09ICdmdW5jdGlvbicpXG4gICAgICBjYiA9IG9wdGlvbnMsIG9wdGlvbnMgPSBudWxsXG5cbiAgICByZXR1cm4gZ28kd3JpdGVGaWxlKHBhdGgsIGRhdGEsIG9wdGlvbnMsIGNiKVxuXG4gICAgZnVuY3Rpb24gZ28kd3JpdGVGaWxlIChwYXRoLCBkYXRhLCBvcHRpb25zLCBjYikge1xuICAgICAgcmV0dXJuIGZzJHdyaXRlRmlsZShwYXRoLCBkYXRhLCBvcHRpb25zLCBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgIGlmIChlcnIgJiYgKGVyci5jb2RlID09PSAnRU1GSUxFJyB8fCBlcnIuY29kZSA9PT0gJ0VORklMRScpKVxuICAgICAgICAgIGVucXVldWUoW2dvJHdyaXRlRmlsZSwgW3BhdGgsIGRhdGEsIG9wdGlvbnMsIGNiXV0pXG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIGlmICh0eXBlb2YgY2IgPT09ICdmdW5jdGlvbicpXG4gICAgICAgICAgICBjYi5hcHBseSh0aGlzLCBhcmd1bWVudHMpXG4gICAgICAgICAgcmV0cnkoKVxuICAgICAgICB9XG4gICAgICB9KVxuICAgIH1cbiAgfVxuXG4gIHZhciBmcyRhcHBlbmRGaWxlID0gZnMuYXBwZW5kRmlsZVxuICBpZiAoZnMkYXBwZW5kRmlsZSlcbiAgICBmcy5hcHBlbmRGaWxlID0gYXBwZW5kRmlsZVxuICBmdW5jdGlvbiBhcHBlbmRGaWxlIChwYXRoLCBkYXRhLCBvcHRpb25zLCBjYikge1xuICAgIGlmICh0eXBlb2Ygb3B0aW9ucyA9PT0gJ2Z1bmN0aW9uJylcbiAgICAgIGNiID0gb3B0aW9ucywgb3B0aW9ucyA9IG51bGxcblxuICAgIHJldHVybiBnbyRhcHBlbmRGaWxlKHBhdGgsIGRhdGEsIG9wdGlvbnMsIGNiKVxuXG4gICAgZnVuY3Rpb24gZ28kYXBwZW5kRmlsZSAocGF0aCwgZGF0YSwgb3B0aW9ucywgY2IpIHtcbiAgICAgIHJldHVybiBmcyRhcHBlbmRGaWxlKHBhdGgsIGRhdGEsIG9wdGlvbnMsIGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgaWYgKGVyciAmJiAoZXJyLmNvZGUgPT09ICdFTUZJTEUnIHx8IGVyci5jb2RlID09PSAnRU5GSUxFJykpXG4gICAgICAgICAgZW5xdWV1ZShbZ28kYXBwZW5kRmlsZSwgW3BhdGgsIGRhdGEsIG9wdGlvbnMsIGNiXV0pXG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIGlmICh0eXBlb2YgY2IgPT09ICdmdW5jdGlvbicpXG4gICAgICAgICAgICBjYi5hcHBseSh0aGlzLCBhcmd1bWVudHMpXG4gICAgICAgICAgcmV0cnkoKVxuICAgICAgICB9XG4gICAgICB9KVxuICAgIH1cbiAgfVxuXG4gIHZhciBmcyRyZWFkZGlyID0gZnMucmVhZGRpclxuICBmcy5yZWFkZGlyID0gcmVhZGRpclxuICBmdW5jdGlvbiByZWFkZGlyIChwYXRoLCBvcHRpb25zLCBjYikge1xuICAgIHZhciBhcmdzID0gW3BhdGhdXG4gICAgaWYgKHR5cGVvZiBvcHRpb25zICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICBhcmdzLnB1c2gob3B0aW9ucylcbiAgICB9IGVsc2Uge1xuICAgICAgY2IgPSBvcHRpb25zXG4gICAgfVxuICAgIGFyZ3MucHVzaChnbyRyZWFkZGlyJGNiKVxuXG4gICAgcmV0dXJuIGdvJHJlYWRkaXIoYXJncylcblxuICAgIGZ1bmN0aW9uIGdvJHJlYWRkaXIkY2IgKGVyciwgZmlsZXMpIHtcbiAgICAgIGlmIChmaWxlcyAmJiBmaWxlcy5zb3J0KVxuICAgICAgICBmaWxlcy5zb3J0KClcblxuICAgICAgaWYgKGVyciAmJiAoZXJyLmNvZGUgPT09ICdFTUZJTEUnIHx8IGVyci5jb2RlID09PSAnRU5GSUxFJykpXG4gICAgICAgIGVucXVldWUoW2dvJHJlYWRkaXIsIFthcmdzXV0pXG4gICAgICBlbHNlIHtcbiAgICAgICAgaWYgKHR5cGVvZiBjYiA9PT0gJ2Z1bmN0aW9uJylcbiAgICAgICAgICBjYi5hcHBseSh0aGlzLCBhcmd1bWVudHMpXG4gICAgICAgIHJldHJ5KClcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBnbyRyZWFkZGlyIChhcmdzKSB7XG4gICAgcmV0dXJuIGZzJHJlYWRkaXIuYXBwbHkoZnMsIGFyZ3MpXG4gIH1cblxuICBpZiAocHJvY2Vzcy52ZXJzaW9uLnN1YnN0cigwLCA0KSA9PT0gJ3YwLjgnKSB7XG4gICAgdmFyIGxlZ1N0cmVhbXMgPSBsZWdhY3koZnMpXG4gICAgUmVhZFN0cmVhbSA9IGxlZ1N0cmVhbXMuUmVhZFN0cmVhbVxuICAgIFdyaXRlU3RyZWFtID0gbGVnU3RyZWFtcy5Xcml0ZVN0cmVhbVxuICB9XG5cbiAgdmFyIGZzJFJlYWRTdHJlYW0gPSBmcy5SZWFkU3RyZWFtXG4gIFJlYWRTdHJlYW0ucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShmcyRSZWFkU3RyZWFtLnByb3RvdHlwZSlcbiAgUmVhZFN0cmVhbS5wcm90b3R5cGUub3BlbiA9IFJlYWRTdHJlYW0kb3BlblxuXG4gIHZhciBmcyRXcml0ZVN0cmVhbSA9IGZzLldyaXRlU3RyZWFtXG4gIFdyaXRlU3RyZWFtLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoZnMkV3JpdGVTdHJlYW0ucHJvdG90eXBlKVxuICBXcml0ZVN0cmVhbS5wcm90b3R5cGUub3BlbiA9IFdyaXRlU3RyZWFtJG9wZW5cblxuICBmcy5SZWFkU3RyZWFtID0gUmVhZFN0cmVhbVxuICBmcy5Xcml0ZVN0cmVhbSA9IFdyaXRlU3RyZWFtXG5cbiAgZnVuY3Rpb24gUmVhZFN0cmVhbSAocGF0aCwgb3B0aW9ucykge1xuICAgIGlmICh0aGlzIGluc3RhbmNlb2YgUmVhZFN0cmVhbSlcbiAgICAgIHJldHVybiBmcyRSZWFkU3RyZWFtLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyksIHRoaXNcbiAgICBlbHNlXG4gICAgICByZXR1cm4gUmVhZFN0cmVhbS5hcHBseShPYmplY3QuY3JlYXRlKFJlYWRTdHJlYW0ucHJvdG90eXBlKSwgYXJndW1lbnRzKVxuICB9XG5cbiAgZnVuY3Rpb24gUmVhZFN0cmVhbSRvcGVuICgpIHtcbiAgICB2YXIgdGhhdCA9IHRoaXNcbiAgICBvcGVuKHRoYXQucGF0aCwgdGhhdC5mbGFncywgdGhhdC5tb2RlLCBmdW5jdGlvbiAoZXJyLCBmZCkge1xuICAgICAgaWYgKGVycikge1xuICAgICAgICBpZiAodGhhdC5hdXRvQ2xvc2UpXG4gICAgICAgICAgdGhhdC5kZXN0cm95KClcblxuICAgICAgICB0aGF0LmVtaXQoJ2Vycm9yJywgZXJyKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhhdC5mZCA9IGZkXG4gICAgICAgIHRoYXQuZW1pdCgnb3BlbicsIGZkKVxuICAgICAgICB0aGF0LnJlYWQoKVxuICAgICAgfVxuICAgIH0pXG4gIH1cblxuICBmdW5jdGlvbiBXcml0ZVN0cmVhbSAocGF0aCwgb3B0aW9ucykge1xuICAgIGlmICh0aGlzIGluc3RhbmNlb2YgV3JpdGVTdHJlYW0pXG4gICAgICByZXR1cm4gZnMkV3JpdGVTdHJlYW0uYXBwbHkodGhpcywgYXJndW1lbnRzKSwgdGhpc1xuICAgIGVsc2VcbiAgICAgIHJldHVybiBXcml0ZVN0cmVhbS5hcHBseShPYmplY3QuY3JlYXRlKFdyaXRlU3RyZWFtLnByb3RvdHlwZSksIGFyZ3VtZW50cylcbiAgfVxuXG4gIGZ1bmN0aW9uIFdyaXRlU3RyZWFtJG9wZW4gKCkge1xuICAgIHZhciB0aGF0ID0gdGhpc1xuICAgIG9wZW4odGhhdC5wYXRoLCB0aGF0LmZsYWdzLCB0aGF0Lm1vZGUsIGZ1bmN0aW9uIChlcnIsIGZkKSB7XG4gICAgICBpZiAoZXJyKSB7XG4gICAgICAgIHRoYXQuZGVzdHJveSgpXG4gICAgICAgIHRoYXQuZW1pdCgnZXJyb3InLCBlcnIpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGF0LmZkID0gZmRcbiAgICAgICAgdGhhdC5lbWl0KCdvcGVuJywgZmQpXG4gICAgICB9XG4gICAgfSlcbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZVJlYWRTdHJlYW0gKHBhdGgsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gbmV3IFJlYWRTdHJlYW0ocGF0aCwgb3B0aW9ucylcbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZVdyaXRlU3RyZWFtIChwYXRoLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIG5ldyBXcml0ZVN0cmVhbShwYXRoLCBvcHRpb25zKVxuICB9XG5cbiAgdmFyIGZzJG9wZW4gPSBmcy5vcGVuXG4gIGZzLm9wZW4gPSBvcGVuXG4gIGZ1bmN0aW9uIG9wZW4gKHBhdGgsIGZsYWdzLCBtb2RlLCBjYikge1xuICAgIGlmICh0eXBlb2YgbW9kZSA9PT0gJ2Z1bmN0aW9uJylcbiAgICAgIGNiID0gbW9kZSwgbW9kZSA9IG51bGxcblxuICAgIHJldHVybiBnbyRvcGVuKHBhdGgsIGZsYWdzLCBtb2RlLCBjYilcblxuICAgIGZ1bmN0aW9uIGdvJG9wZW4gKHBhdGgsIGZsYWdzLCBtb2RlLCBjYikge1xuICAgICAgcmV0dXJuIGZzJG9wZW4ocGF0aCwgZmxhZ3MsIG1vZGUsIGZ1bmN0aW9uIChlcnIsIGZkKSB7XG4gICAgICAgIGlmIChlcnIgJiYgKGVyci5jb2RlID09PSAnRU1GSUxFJyB8fCBlcnIuY29kZSA9PT0gJ0VORklMRScpKVxuICAgICAgICAgIGVucXVldWUoW2dvJG9wZW4sIFtwYXRoLCBmbGFncywgbW9kZSwgY2JdXSlcbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgaWYgKHR5cGVvZiBjYiA9PT0gJ2Z1bmN0aW9uJylcbiAgICAgICAgICAgIGNiLmFwcGx5KHRoaXMsIGFyZ3VtZW50cylcbiAgICAgICAgICByZXRyeSgpXG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZzXG59XG5cbmZ1bmN0aW9uIGVucXVldWUgKGVsZW0pIHtcbiAgZGVidWcoJ0VOUVVFVUUnLCBlbGVtWzBdLm5hbWUsIGVsZW1bMV0pXG4gIHF1ZXVlLnB1c2goZWxlbSlcbn1cblxuZnVuY3Rpb24gcmV0cnkgKCkge1xuICB2YXIgZWxlbSA9IHF1ZXVlLnNoaWZ0KClcbiAgaWYgKGVsZW0pIHtcbiAgICBkZWJ1ZygnUkVUUlknLCBlbGVtWzBdLm5hbWUsIGVsZW1bMV0pXG4gICAgZWxlbVswXS5hcHBseShudWxsLCBlbGVtWzFdKVxuICB9XG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvZ3JhY2VmdWwtZnMvZ3JhY2VmdWwtZnMuanMiLCIndXNlIHN0cmljdCdcblxuZXhwb3J0cy5mcm9tQ2FsbGJhY2sgPSBmdW5jdGlvbiAoZm4pIHtcbiAgcmV0dXJuIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHR5cGVvZiBhcmd1bWVudHNbYXJndW1lbnRzLmxlbmd0aCAtIDFdID09PSAnZnVuY3Rpb24nKSBmbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpXG4gICAgZWxzZSB7XG4gICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICBhcmd1bWVudHNbYXJndW1lbnRzLmxlbmd0aF0gPSAoZXJyLCByZXMpID0+IHtcbiAgICAgICAgICBpZiAoZXJyKSByZXR1cm4gcmVqZWN0KGVycilcbiAgICAgICAgICByZXNvbHZlKHJlcylcbiAgICAgICAgfVxuICAgICAgICBhcmd1bWVudHMubGVuZ3RoKytcbiAgICAgICAgZm4uYXBwbHkodGhpcywgYXJndW1lbnRzKVxuICAgICAgfSlcbiAgICB9XG4gIH0sICduYW1lJywgeyB2YWx1ZTogZm4ubmFtZSB9KVxufVxuXG5leHBvcnRzLmZyb21Qcm9taXNlID0gZnVuY3Rpb24gKGZuKSB7XG4gIHJldHVybiBPYmplY3QuZGVmaW5lUHJvcGVydHkoZnVuY3Rpb24gKCkge1xuICAgIGNvbnN0IGNiID0gYXJndW1lbnRzW2FyZ3VtZW50cy5sZW5ndGggLSAxXVxuICAgIGlmICh0eXBlb2YgY2IgIT09ICdmdW5jdGlvbicpIHJldHVybiBmbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpXG4gICAgZWxzZSBmbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpLnRoZW4ociA9PiBjYihudWxsLCByKSwgY2IpXG4gIH0sICduYW1lJywgeyB2YWx1ZTogZm4ubmFtZSB9KVxufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL3VuaXZlcnNhbGlmeS9pbmRleC5qcyIsIid1c2Ugc3RyaWN0J1xuY29uc3QgdSA9IHJlcXVpcmUoJ3VuaXZlcnNhbGlmeScpLmZyb21DYWxsYmFja1xuY29uc3QgbWtkaXJzID0gdShyZXF1aXJlKCcuL21rZGlycycpKVxuY29uc3QgbWtkaXJzU3luYyA9IHJlcXVpcmUoJy4vbWtkaXJzLXN5bmMnKVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgbWtkaXJzOiBta2RpcnMsXG4gIG1rZGlyc1N5bmM6IG1rZGlyc1N5bmMsXG4gIC8vIGFsaWFzXG4gIG1rZGlycDogbWtkaXJzLFxuICBta2RpcnBTeW5jOiBta2RpcnNTeW5jLFxuICBlbnN1cmVEaXI6IG1rZGlycyxcbiAgZW5zdXJlRGlyU3luYzogbWtkaXJzU3luY1xufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2VsZWN0cm9uLXVwZGF0ZXIvbm9kZV9tb2R1bGVzL2ZzLWV4dHJhL2xpYi9ta2RpcnMvaW5kZXguanMiLCJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5VcGRhdGVyU2lnbmFsID0gZXhwb3J0cy5VUERBVEVfRE9XTkxPQURFRCA9IGV4cG9ydHMuRE9XTkxPQURfUFJPR1JFU1MgPSBleHBvcnRzLlByb3ZpZGVyID0gZXhwb3J0cy5DYW5jZWxsYXRpb25Ub2tlbiA9IGV4cG9ydHMuTm9PcExvZ2dlciA9IGV4cG9ydHMuQXBwVXBkYXRlciA9IHVuZGVmaW5lZDtcblxudmFyIF9BcHBVcGRhdGVyO1xuXG5mdW5jdGlvbiBfbG9hZF9BcHBVcGRhdGVyKCkge1xuICAgIHJldHVybiBfQXBwVXBkYXRlciA9IHJlcXVpcmUoXCIuL0FwcFVwZGF0ZXJcIik7XG59XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkFwcFVwZGF0ZXJcIiwge1xuICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiAoX0FwcFVwZGF0ZXIgfHwgX2xvYWRfQXBwVXBkYXRlcigpKS5BcHBVcGRhdGVyO1xuICAgIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiTm9PcExvZ2dlclwiLCB7XG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIChfQXBwVXBkYXRlciB8fCBfbG9hZF9BcHBVcGRhdGVyKCkpLk5vT3BMb2dnZXI7XG4gICAgfVxufSk7XG5cbnZhciBfYnVpbGRlclV0aWxSdW50aW1lO1xuXG5mdW5jdGlvbiBfbG9hZF9idWlsZGVyVXRpbFJ1bnRpbWUoKSB7XG4gICAgcmV0dXJuIF9idWlsZGVyVXRpbFJ1bnRpbWUgPSByZXF1aXJlKFwiYnVpbGRlci11dGlsLXJ1bnRpbWVcIik7XG59XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkNhbmNlbGxhdGlvblRva2VuXCIsIHtcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gKF9idWlsZGVyVXRpbFJ1bnRpbWUgfHwgX2xvYWRfYnVpbGRlclV0aWxSdW50aW1lKCkpLkNhbmNlbGxhdGlvblRva2VuO1xuICAgIH1cbn0pO1xuXG52YXIgX1Byb3ZpZGVyO1xuXG5mdW5jdGlvbiBfbG9hZF9Qcm92aWRlcigpIHtcbiAgICByZXR1cm4gX1Byb3ZpZGVyID0gcmVxdWlyZShcIi4vUHJvdmlkZXJcIik7XG59XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlByb3ZpZGVyXCIsIHtcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gKF9Qcm92aWRlciB8fCBfbG9hZF9Qcm92aWRlcigpKS5Qcm92aWRlcjtcbiAgICB9XG59KTtcbmV4cG9ydHMuZ2V0RGVmYXVsdENoYW5uZWxOYW1lID0gZ2V0RGVmYXVsdENoYW5uZWxOYW1lO1xuZXhwb3J0cy5nZXRDdXN0b21DaGFubmVsTmFtZSA9IGdldEN1c3RvbUNoYW5uZWxOYW1lO1xuZXhwb3J0cy5nZXRDdXJyZW50UGxhdGZvcm0gPSBnZXRDdXJyZW50UGxhdGZvcm07XG5leHBvcnRzLmlzVXNlT2xkTWFjUHJvdmlkZXIgPSBpc1VzZU9sZE1hY1Byb3ZpZGVyO1xuZXhwb3J0cy5nZXRDaGFubmVsRmlsZW5hbWUgPSBnZXRDaGFubmVsRmlsZW5hbWU7XG5leHBvcnRzLm5ld0Jhc2VVcmwgPSBuZXdCYXNlVXJsO1xuZXhwb3J0cy5uZXdVcmxGcm9tQmFzZSA9IG5ld1VybEZyb21CYXNlO1xuXG52YXIgX3VybDtcblxuZnVuY3Rpb24gX2xvYWRfdXJsKCkge1xuICAgIHJldHVybiBfdXJsID0gcmVxdWlyZShcInVybFwiKTtcbn1cblxuLy8gYXV0b1VwZGF0ZXIgdG8gbWltaWMgZWxlY3Ryb24gYnVuZGxlZCBhdXRvVXBkYXRlclxubGV0IF9hdXRvVXBkYXRlcjtcbmZ1bmN0aW9uIF9sb2FkX2F1dG9VcGRhdGVyKCkge1xuICAgIC8vIHRzbGludDpkaXNhYmxlOnByZWZlci1jb25kaXRpb25hbC1leHByZXNzaW9uXG4gICAgaWYgKHByb2Nlc3MucGxhdGZvcm0gPT09IFwid2luMzJcIikge1xuICAgICAgICBfYXV0b1VwZGF0ZXIgPSBuZXcgKHJlcXVpcmUoXCIuL05zaXNVcGRhdGVyXCIpLk5zaXNVcGRhdGVyKSgpO1xuICAgIH0gZWxzZSBpZiAocHJvY2Vzcy5wbGF0Zm9ybSA9PT0gXCJkYXJ3aW5cIikge1xuICAgICAgICBfYXV0b1VwZGF0ZXIgPSBuZXcgKHJlcXVpcmUoXCIuL01hY1VwZGF0ZXJcIikuTWFjVXBkYXRlcikoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBfYXV0b1VwZGF0ZXIgPSBuZXcgKHJlcXVpcmUoXCIuL0FwcEltYWdlVXBkYXRlclwiKS5BcHBJbWFnZVVwZGF0ZXIpKCk7XG4gICAgfVxuICAgIHJldHVybiBfYXV0b1VwZGF0ZXI7XG59XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJhdXRvVXBkYXRlclwiLCB7XG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICBnZXQ6ICgpID0+IHtcbiAgICAgICAgcmV0dXJuIF9hdXRvVXBkYXRlciB8fCBfbG9hZF9hdXRvVXBkYXRlcigpO1xuICAgIH1cbn0pO1xuLy8gZHVlIHRvIGhpc3RvcmljYWwgcmVhc29ucyBmb3Igd2luZG93cyB3ZSB1c2UgY2hhbm5lbCBuYW1lIHdpdGhvdXQgcGxhdGZvcm0gc3BlY2lmaWVyXG5mdW5jdGlvbiBnZXREZWZhdWx0Q2hhbm5lbE5hbWUoKSB7XG4gICAgcmV0dXJuIGBsYXRlc3Qke2dldENoYW5uZWxGaWxlUHJlZml4KCl9YDtcbn1cbmZ1bmN0aW9uIGdldENoYW5uZWxGaWxlUHJlZml4KCkge1xuICAgIGNvbnN0IGN1cnJlbnRQbGF0Zm9ybSA9IGdldEN1cnJlbnRQbGF0Zm9ybSgpO1xuICAgIGlmIChjdXJyZW50UGxhdGZvcm0gPT09IFwibGludXhcIikge1xuICAgICAgICBjb25zdCBhcmNoID0gcHJvY2Vzcy5lbnYuVEVTVF9VUERBVEVSX0FSQ0ggfHwgcHJvY2Vzcy5hcmNoO1xuICAgICAgICBjb25zdCBhcmNoU3VmZml4ID0gYXJjaCA9PT0gXCJ4NjRcIiA/IFwiXCIgOiBgLSR7YXJjaH1gO1xuICAgICAgICByZXR1cm4gXCItbGludXhcIiArIGFyY2hTdWZmaXg7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGN1cnJlbnRQbGF0Zm9ybSA9PT0gXCJkYXJ3aW5cIiA/IFwiLW1hY1wiIDogXCJcIjtcbiAgICB9XG59XG5mdW5jdGlvbiBnZXRDdXN0b21DaGFubmVsTmFtZShjaGFubmVsKSB7XG4gICAgcmV0dXJuIGAke2NoYW5uZWx9JHtnZXRDaGFubmVsRmlsZVByZWZpeCgpfWA7XG59XG5mdW5jdGlvbiBnZXRDdXJyZW50UGxhdGZvcm0oKSB7XG4gICAgcmV0dXJuIHByb2Nlc3MuZW52LlRFU1RfVVBEQVRFUl9QTEFURk9STSB8fCBwcm9jZXNzLnBsYXRmb3JtO1xufVxuZnVuY3Rpb24gaXNVc2VPbGRNYWNQcm92aWRlcigpIHtcbiAgICAvLyBnZXRDdXJyZW50UGxhdGZvcm0oKSA9PT0gXCJkYXJ3aW5cIlxuICAgIHJldHVybiBmYWxzZTtcbn1cbmZ1bmN0aW9uIGdldENoYW5uZWxGaWxlbmFtZShjaGFubmVsKSB7XG4gICAgcmV0dXJuIGAke2NoYW5uZWx9LnltbGA7XG59XG5jb25zdCBET1dOTE9BRF9QUk9HUkVTUyA9IGV4cG9ydHMuRE9XTkxPQURfUFJPR1JFU1MgPSBcImRvd25sb2FkLXByb2dyZXNzXCI7XG5jb25zdCBVUERBVEVfRE9XTkxPQURFRCA9IGV4cG9ydHMuVVBEQVRFX0RPV05MT0FERUQgPSBcInVwZGF0ZS1kb3dubG9hZGVkXCI7XG5jbGFzcyBVcGRhdGVyU2lnbmFsIHtcbiAgICBjb25zdHJ1Y3RvcihlbWl0dGVyKSB7XG4gICAgICAgIHRoaXMuZW1pdHRlciA9IGVtaXR0ZXI7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEVtaXR0ZWQgd2hlbiBhbiBhdXRoZW50aWNhdGluZyBwcm94eSBpcyBbYXNraW5nIGZvciB1c2VyIGNyZWRlbnRpYWxzXShodHRwczovL2dpdGh1Yi5jb20vZWxlY3Ryb24vZWxlY3Ryb24vYmxvYi9tYXN0ZXIvZG9jcy9hcGkvY2xpZW50LXJlcXVlc3QubWQjZXZlbnQtbG9naW4pLlxuICAgICAqL1xuICAgIGxvZ2luKGhhbmRsZXIpIHtcbiAgICAgICAgYWRkSGFuZGxlcih0aGlzLmVtaXR0ZXIsIFwibG9naW5cIiwgaGFuZGxlcik7XG4gICAgfVxuICAgIHByb2dyZXNzKGhhbmRsZXIpIHtcbiAgICAgICAgYWRkSGFuZGxlcih0aGlzLmVtaXR0ZXIsIERPV05MT0FEX1BST0dSRVNTLCBoYW5kbGVyKTtcbiAgICB9XG4gICAgdXBkYXRlRG93bmxvYWRlZChoYW5kbGVyKSB7XG4gICAgICAgIGFkZEhhbmRsZXIodGhpcy5lbWl0dGVyLCBVUERBVEVfRE9XTkxPQURFRCwgaGFuZGxlcik7XG4gICAgfVxuICAgIHVwZGF0ZUNhbmNlbGxlZChoYW5kbGVyKSB7XG4gICAgICAgIGFkZEhhbmRsZXIodGhpcy5lbWl0dGVyLCBcInVwZGF0ZS1jYW5jZWxsZWRcIiwgaGFuZGxlcik7XG4gICAgfVxufVxuZXhwb3J0cy5VcGRhdGVyU2lnbmFsID0gVXBkYXRlclNpZ25hbDtcbmNvbnN0IGlzTG9nRXZlbnQgPSBmYWxzZTtcbmZ1bmN0aW9uIGFkZEhhbmRsZXIoZW1pdHRlciwgZXZlbnQsIGhhbmRsZXIpIHtcbiAgICBpZiAoaXNMb2dFdmVudCkge1xuICAgICAgICBlbWl0dGVyLm9uKGV2ZW50LCAoLi4uYXJncykgPT4ge1xuICAgICAgICAgICAgY29uc29sZS5sb2coXCIlcyAlc1wiLCBldmVudCwgYXJncyk7XG4gICAgICAgICAgICBoYW5kbGVyLmFwcGx5KG51bGwsIGFyZ3MpO1xuICAgICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBlbWl0dGVyLm9uKGV2ZW50LCBoYW5kbGVyKTtcbiAgICB9XG59XG4vLyBpZiBiYXNlVXJsIHBhdGggZG9lc24ndCBlbmRzIHdpdGggLywgdGhpcyBwYXRoIHdpbGwgYmUgbm90IHByZXBlbmRlZCB0byBwYXNzZWQgcGF0aG5hbWUgZm9yIG5ldyBVUkwoaW5wdXQsIGJhc2UpXG4vKiogQGludGVybmFsICovXG5mdW5jdGlvbiBuZXdCYXNlVXJsKHVybCkge1xuICAgIGNvbnN0IHJlc3VsdCA9IG5ldyAoX3VybCB8fCBfbG9hZF91cmwoKSkuVVJMKHVybCk7XG4gICAgaWYgKCFyZXN1bHQucGF0aG5hbWUuZW5kc1dpdGgoXCIvXCIpKSB7XG4gICAgICAgIHJlc3VsdC5wYXRobmFtZSArPSBcIi9cIjtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbi8qKiBAaW50ZXJuYWwgKi9cbmZ1bmN0aW9uIG5ld1VybEZyb21CYXNlKHBhdGhuYW1lLCBiYXNlVXJsKSB7XG4gICAgY29uc3QgcmVzdWx0ID0gbmV3IChfdXJsIHx8IF9sb2FkX3VybCgpKS5VUkwocGF0aG5hbWUsIGJhc2VVcmwpO1xuICAgIC8vIHNlYXJjaCBpcyBub3QgcHJvcGFnYXRlZFxuICAgIGlmICghcmVzdWx0LnNlYXJjaCAmJiBiYXNlVXJsLnNlYXJjaCkge1xuICAgICAgICByZXN1bHQuc2VhcmNoID0gYmFzZVVybC5zZWFyY2g7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1tYWluLmpzLm1hcFxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9lbGVjdHJvbi11cGRhdGVyL291dC9tYWluLmpzIiwiXCJ1c2Ugc3RyaWN0XCJcblxuY29uc3QgZnNFeHRyYSA9IHJlcXVpcmUoXCJmcy1leHRyYVwiKVxuY29uc3QgUHJvbWlzZSA9IHJlcXVpcmUoJ2JsdWViaXJkLWxzdCcpXG5cbmZ1bmN0aW9uIG1ha2VGcyhQcm9taXNlKSB7XG4gIGNvbnN0IGZzID0gT2JqZWN0LmNyZWF0ZShudWxsKVxuXG4gIGZvciAoY29uc3QgbWV0aG9kTmFtZSBvZiBPYmplY3Qua2V5cyhmc0V4dHJhKSkge1xuICAgIGNvbnN0IG1ldGhvZCA9IGZzRXh0cmFbbWV0aG9kTmFtZV1cbiAgICBpZiAobWV0aG9kTmFtZSA9PT0gXCJjcmVhdGVGaWxlXCIgfHwgbWV0aG9kTmFtZSA9PT0gXCJta2RpcnBcIikge1xuICAgICAgY29udGludWVcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIG1ldGhvZCAhPT0gXCJmdW5jdGlvblwiIHx8XG4gICAgICAgIG1ldGhvZE5hbWUuZW5kc1dpdGgoXCJTeW5jXCIpIHx8XG4gICAgICAgIG1ldGhvZE5hbWUuZW5kc1dpdGgoXCJTdHJlYW1cIikgfHxcbiAgICAgICAgbWV0aG9kTmFtZS5tYXRjaCgvXltBLVpdLykgfHxcbiAgICAgICAgbWV0aG9kTmFtZSA9PT0gXCJleGlzdHNcIiB8fFxuICAgICAgICBtZXRob2ROYW1lID09PSBcIndhdGNoXCIgfHxcbiAgICAgICAgbWV0aG9kTmFtZSA9PT0gXCJ3YXRjaEZpbGVcIiB8fFxuICAgICAgICBtZXRob2ROYW1lID09PSBcInVud2F0Y2hGaWxlXCIpIHtcbiAgICAgIGZzW21ldGhvZE5hbWVdID0gbWV0aG9kXG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgZnNbbWV0aG9kTmFtZV0gPSBQcm9taXNlLnByb21pc2lmeShtZXRob2QpXG4gICAgfVxuICB9XG5cbiAgZnMuY3JlYXRlRmlsZSA9IGZzLmVuc3VyZUZpbGVcbiAgZnMubWtkaXJwID0gZnMubWtkaXJzXG4gIHJldHVybiBmc1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IG1ha2VGcyhQcm9taXNlKVxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9lbGVjdHJvbi11cGRhdGVyL25vZGVfbW9kdWxlcy9mcy1leHRyYS1wL2luZGV4LmpzIiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwiZWxlY3Ryb25cIik7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gZXh0ZXJuYWwgXCJlbGVjdHJvblwiXG4vLyBtb2R1bGUgaWQgPSAxMFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBlczUgPSByZXF1aXJlKFwiLi9lczVcIik7XG52YXIgT2JqZWN0ZnJlZXplID0gZXM1LmZyZWV6ZTtcbnZhciB1dGlsID0gcmVxdWlyZShcIi4vdXRpbFwiKTtcbnZhciBpbmhlcml0cyA9IHV0aWwuaW5oZXJpdHM7XG52YXIgbm90RW51bWVyYWJsZVByb3AgPSB1dGlsLm5vdEVudW1lcmFibGVQcm9wO1xuXG5mdW5jdGlvbiBzdWJFcnJvcihuYW1lUHJvcGVydHksIGRlZmF1bHRNZXNzYWdlKSB7XG4gICAgZnVuY3Rpb24gU3ViRXJyb3IobWVzc2FnZSkge1xuICAgICAgICBpZiAoISh0aGlzIGluc3RhbmNlb2YgU3ViRXJyb3IpKSByZXR1cm4gbmV3IFN1YkVycm9yKG1lc3NhZ2UpO1xuICAgICAgICBub3RFbnVtZXJhYmxlUHJvcCh0aGlzLCBcIm1lc3NhZ2VcIixcbiAgICAgICAgICAgIHR5cGVvZiBtZXNzYWdlID09PSBcInN0cmluZ1wiID8gbWVzc2FnZSA6IGRlZmF1bHRNZXNzYWdlKTtcbiAgICAgICAgbm90RW51bWVyYWJsZVByb3AodGhpcywgXCJuYW1lXCIsIG5hbWVQcm9wZXJ0eSk7XG4gICAgICAgIGlmIChFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSkge1xuICAgICAgICAgICAgRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UodGhpcywgdGhpcy5jb25zdHJ1Y3Rvcik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBFcnJvci5jYWxsKHRoaXMpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGluaGVyaXRzKFN1YkVycm9yLCBFcnJvcik7XG4gICAgcmV0dXJuIFN1YkVycm9yO1xufVxuXG52YXIgX1R5cGVFcnJvciwgX1JhbmdlRXJyb3I7XG52YXIgV2FybmluZyA9IHN1YkVycm9yKFwiV2FybmluZ1wiLCBcIndhcm5pbmdcIik7XG52YXIgQ2FuY2VsbGF0aW9uRXJyb3IgPSBzdWJFcnJvcihcIkNhbmNlbGxhdGlvbkVycm9yXCIsIFwiY2FuY2VsbGF0aW9uIGVycm9yXCIpO1xudmFyIFRpbWVvdXRFcnJvciA9IHN1YkVycm9yKFwiVGltZW91dEVycm9yXCIsIFwidGltZW91dCBlcnJvclwiKTtcbnZhciBBZ2dyZWdhdGVFcnJvciA9IHN1YkVycm9yKFwiQWdncmVnYXRlRXJyb3JcIiwgXCJhZ2dyZWdhdGUgZXJyb3JcIik7XG50cnkge1xuICAgIF9UeXBlRXJyb3IgPSBUeXBlRXJyb3I7XG4gICAgX1JhbmdlRXJyb3IgPSBSYW5nZUVycm9yO1xufSBjYXRjaChlKSB7XG4gICAgX1R5cGVFcnJvciA9IHN1YkVycm9yKFwiVHlwZUVycm9yXCIsIFwidHlwZSBlcnJvclwiKTtcbiAgICBfUmFuZ2VFcnJvciA9IHN1YkVycm9yKFwiUmFuZ2VFcnJvclwiLCBcInJhbmdlIGVycm9yXCIpO1xufVxuXG52YXIgbWV0aG9kcyA9IChcImpvaW4gcG9wIHB1c2ggc2hpZnQgdW5zaGlmdCBzbGljZSBmaWx0ZXIgZm9yRWFjaCBzb21lIFwiICtcbiAgICBcImV2ZXJ5IG1hcCBpbmRleE9mIGxhc3RJbmRleE9mIHJlZHVjZSByZWR1Y2VSaWdodCBzb3J0IHJldmVyc2VcIikuc3BsaXQoXCIgXCIpO1xuXG5mb3IgKHZhciBpID0gMDsgaSA8IG1ldGhvZHMubGVuZ3RoOyArK2kpIHtcbiAgICBpZiAodHlwZW9mIEFycmF5LnByb3RvdHlwZVttZXRob2RzW2ldXSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIEFnZ3JlZ2F0ZUVycm9yLnByb3RvdHlwZVttZXRob2RzW2ldXSA9IEFycmF5LnByb3RvdHlwZVttZXRob2RzW2ldXTtcbiAgICB9XG59XG5cbmVzNS5kZWZpbmVQcm9wZXJ0eShBZ2dyZWdhdGVFcnJvci5wcm90b3R5cGUsIFwibGVuZ3RoXCIsIHtcbiAgICB2YWx1ZTogMCxcbiAgICBjb25maWd1cmFibGU6IGZhbHNlLFxuICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgIGVudW1lcmFibGU6IHRydWVcbn0pO1xuQWdncmVnYXRlRXJyb3IucHJvdG90eXBlW1wiaXNPcGVyYXRpb25hbFwiXSA9IHRydWU7XG52YXIgbGV2ZWwgPSAwO1xuQWdncmVnYXRlRXJyb3IucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGluZGVudCA9IEFycmF5KGxldmVsICogNCArIDEpLmpvaW4oXCIgXCIpO1xuICAgIHZhciByZXQgPSBcIlxcblwiICsgaW5kZW50ICsgXCJBZ2dyZWdhdGVFcnJvciBvZjpcIiArIFwiXFxuXCI7XG4gICAgbGV2ZWwrKztcbiAgICBpbmRlbnQgPSBBcnJheShsZXZlbCAqIDQgKyAxKS5qb2luKFwiIFwiKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgdmFyIHN0ciA9IHRoaXNbaV0gPT09IHRoaXMgPyBcIltDaXJjdWxhciBBZ2dyZWdhdGVFcnJvcl1cIiA6IHRoaXNbaV0gKyBcIlwiO1xuICAgICAgICB2YXIgbGluZXMgPSBzdHIuc3BsaXQoXCJcXG5cIik7XG4gICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgbGluZXMubGVuZ3RoOyArK2opIHtcbiAgICAgICAgICAgIGxpbmVzW2pdID0gaW5kZW50ICsgbGluZXNbal07XG4gICAgICAgIH1cbiAgICAgICAgc3RyID0gbGluZXMuam9pbihcIlxcblwiKTtcbiAgICAgICAgcmV0ICs9IHN0ciArIFwiXFxuXCI7XG4gICAgfVxuICAgIGxldmVsLS07XG4gICAgcmV0dXJuIHJldDtcbn07XG5cbmZ1bmN0aW9uIE9wZXJhdGlvbmFsRXJyb3IobWVzc2FnZSkge1xuICAgIGlmICghKHRoaXMgaW5zdGFuY2VvZiBPcGVyYXRpb25hbEVycm9yKSlcbiAgICAgICAgcmV0dXJuIG5ldyBPcGVyYXRpb25hbEVycm9yKG1lc3NhZ2UpO1xuICAgIG5vdEVudW1lcmFibGVQcm9wKHRoaXMsIFwibmFtZVwiLCBcIk9wZXJhdGlvbmFsRXJyb3JcIik7XG4gICAgbm90RW51bWVyYWJsZVByb3AodGhpcywgXCJtZXNzYWdlXCIsIG1lc3NhZ2UpO1xuICAgIHRoaXMuY2F1c2UgPSBtZXNzYWdlO1xuICAgIHRoaXNbXCJpc09wZXJhdGlvbmFsXCJdID0gdHJ1ZTtcblxuICAgIGlmIChtZXNzYWdlIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgICAgbm90RW51bWVyYWJsZVByb3AodGhpcywgXCJtZXNzYWdlXCIsIG1lc3NhZ2UubWVzc2FnZSk7XG4gICAgICAgIG5vdEVudW1lcmFibGVQcm9wKHRoaXMsIFwic3RhY2tcIiwgbWVzc2FnZS5zdGFjayk7XG4gICAgfSBlbHNlIGlmIChFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSkge1xuICAgICAgICBFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSh0aGlzLCB0aGlzLmNvbnN0cnVjdG9yKTtcbiAgICB9XG5cbn1cbmluaGVyaXRzKE9wZXJhdGlvbmFsRXJyb3IsIEVycm9yKTtcblxudmFyIGVycm9yVHlwZXMgPSBFcnJvcltcIl9fQmx1ZWJpcmRFcnJvclR5cGVzX19cIl07XG5pZiAoIWVycm9yVHlwZXMpIHtcbiAgICBlcnJvclR5cGVzID0gT2JqZWN0ZnJlZXplKHtcbiAgICAgICAgQ2FuY2VsbGF0aW9uRXJyb3I6IENhbmNlbGxhdGlvbkVycm9yLFxuICAgICAgICBUaW1lb3V0RXJyb3I6IFRpbWVvdXRFcnJvcixcbiAgICAgICAgT3BlcmF0aW9uYWxFcnJvcjogT3BlcmF0aW9uYWxFcnJvcixcbiAgICAgICAgUmVqZWN0aW9uRXJyb3I6IE9wZXJhdGlvbmFsRXJyb3IsXG4gICAgICAgIEFnZ3JlZ2F0ZUVycm9yOiBBZ2dyZWdhdGVFcnJvclxuICAgIH0pO1xuICAgIGVzNS5kZWZpbmVQcm9wZXJ0eShFcnJvciwgXCJfX0JsdWViaXJkRXJyb3JUeXBlc19fXCIsIHtcbiAgICAgICAgdmFsdWU6IGVycm9yVHlwZXMsXG4gICAgICAgIHdyaXRhYmxlOiBmYWxzZSxcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogZmFsc2VcbiAgICB9KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgRXJyb3I6IEVycm9yLFxuICAgIFR5cGVFcnJvcjogX1R5cGVFcnJvcixcbiAgICBSYW5nZUVycm9yOiBfUmFuZ2VFcnJvcixcbiAgICBDYW5jZWxsYXRpb25FcnJvcjogZXJyb3JUeXBlcy5DYW5jZWxsYXRpb25FcnJvcixcbiAgICBPcGVyYXRpb25hbEVycm9yOiBlcnJvclR5cGVzLk9wZXJhdGlvbmFsRXJyb3IsXG4gICAgVGltZW91dEVycm9yOiBlcnJvclR5cGVzLlRpbWVvdXRFcnJvcixcbiAgICBBZ2dyZWdhdGVFcnJvcjogZXJyb3JUeXBlcy5BZ2dyZWdhdGVFcnJvcixcbiAgICBXYXJuaW5nOiBXYXJuaW5nXG59O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2JsdWViaXJkL2pzL3JlbGVhc2UvZXJyb3JzLmpzIiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwiZnNcIik7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gZXh0ZXJuYWwgXCJmc1wiXG4vLyBtb2R1bGUgaWQgPSAxMlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIndXNlIHN0cmljdCdcbmNvbnN0IHUgPSByZXF1aXJlKCd1bml2ZXJzYWxpZnknKS5mcm9tUHJvbWlzZVxuY29uc3QgZnMgPSByZXF1aXJlKCcuLi9mcycpXG5cbmZ1bmN0aW9uIHBhdGhFeGlzdHMgKHBhdGgpIHtcbiAgcmV0dXJuIGZzLmFjY2VzcyhwYXRoKS50aGVuKCgpID0+IHRydWUpLmNhdGNoKCgpID0+IGZhbHNlKVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgcGF0aEV4aXN0czogdShwYXRoRXhpc3RzKSxcbiAgcGF0aEV4aXN0c1N5bmM6IGZzLmV4aXN0c1N5bmNcbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9lbGVjdHJvbi11cGRhdGVyL25vZGVfbW9kdWxlcy9mcy1leHRyYS9saWIvcGF0aC1leGlzdHMvaW5kZXguanMiLCJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5Qcm92aWRlciA9IHVuZGVmaW5lZDtcbmV4cG9ydHMuZmluZEZpbGUgPSBmaW5kRmlsZTtcbmV4cG9ydHMucGFyc2VVcGRhdGVJbmZvID0gcGFyc2VVcGRhdGVJbmZvO1xuZXhwb3J0cy5nZXRGaWxlTGlzdCA9IGdldEZpbGVMaXN0O1xuZXhwb3J0cy5yZXNvbHZlRmlsZXMgPSByZXNvbHZlRmlsZXM7XG5cbnZhciBfYnVpbGRlclV0aWxSdW50aW1lO1xuXG5mdW5jdGlvbiBfbG9hZF9idWlsZGVyVXRpbFJ1bnRpbWUoKSB7XG4gICAgcmV0dXJuIF9idWlsZGVyVXRpbFJ1bnRpbWUgPSByZXF1aXJlKFwiYnVpbGRlci11dGlsLXJ1bnRpbWVcIik7XG59XG5cbnZhciBfanNZYW1sO1xuXG5mdW5jdGlvbiBfbG9hZF9qc1lhbWwoKSB7XG4gICAgcmV0dXJuIF9qc1lhbWwgPSByZXF1aXJlKFwianMteWFtbFwiKTtcbn1cblxudmFyIF9tYWluO1xuXG5mdW5jdGlvbiBfbG9hZF9tYWluKCkge1xuICAgIHJldHVybiBfbWFpbiA9IHJlcXVpcmUoXCIuL21haW5cIik7XG59XG5cbmNsYXNzIFByb3ZpZGVyIHtcbiAgICBjb25zdHJ1Y3RvcihleGVjdXRvciwgdXNlTXVsdGlwbGVSYW5nZVJlcXVlc3QgPSB0cnVlKSB7XG4gICAgICAgIHRoaXMuZXhlY3V0b3IgPSBleGVjdXRvcjtcbiAgICAgICAgdGhpcy51c2VNdWx0aXBsZVJhbmdlUmVxdWVzdCA9IHVzZU11bHRpcGxlUmFuZ2VSZXF1ZXN0O1xuICAgIH1cbiAgICBnZXQgZmlsZUV4dHJhRG93bmxvYWRIZWFkZXJzKCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgc2V0UmVxdWVzdEhlYWRlcnModmFsdWUpIHtcbiAgICAgICAgdGhpcy5yZXF1ZXN0SGVhZGVycyA9IHZhbHVlO1xuICAgIH1cbiAgICBodHRwUmVxdWVzdCh1cmwsIGhlYWRlcnMsIGNhbmNlbGxhdGlvblRva2VuKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmV4ZWN1dG9yLnJlcXVlc3QodGhpcy5jcmVhdGVSZXF1ZXN0T3B0aW9ucyh1cmwsIGhlYWRlcnMpLCBjYW5jZWxsYXRpb25Ub2tlbik7XG4gICAgfVxuICAgIGNyZWF0ZVJlcXVlc3RPcHRpb25zKHVybCwgaGVhZGVycykge1xuICAgICAgICBjb25zdCByZXN1bHQgPSB7fTtcbiAgICAgICAgaWYgKHRoaXMucmVxdWVzdEhlYWRlcnMgPT0gbnVsbCkge1xuICAgICAgICAgICAgaWYgKGhlYWRlcnMgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJlc3VsdC5oZWFkZXJzID0gaGVhZGVycztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlc3VsdC5oZWFkZXJzID0gaGVhZGVycyA9PSBudWxsID8gdGhpcy5yZXF1ZXN0SGVhZGVycyA6IE9iamVjdC5hc3NpZ24oe30sIHRoaXMucmVxdWVzdEhlYWRlcnMsIGhlYWRlcnMpO1xuICAgICAgICB9XG4gICAgICAgIHJlc3VsdC5wcm90b2NvbCA9IHVybC5wcm90b2NvbDtcbiAgICAgICAgcmVzdWx0Lmhvc3RuYW1lID0gdXJsLmhvc3RuYW1lO1xuICAgICAgICBpZiAodXJsLnBvcnQpIHtcbiAgICAgICAgICAgIHJlc3VsdC5wb3J0ID0gdXJsLnBvcnQ7XG4gICAgICAgIH1cbiAgICAgICAgcmVzdWx0LnBhdGggPSB1cmwucGF0aG5hbWUgKyB1cmwuc2VhcmNoO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbn1cbmV4cG9ydHMuUHJvdmlkZXIgPSBQcm92aWRlcjtcbmZ1bmN0aW9uIGZpbmRGaWxlKGZpbGVzLCBleHRlbnNpb24sIG5vdCkge1xuICAgIGlmIChmaWxlcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgdGhyb3cgKDAsIChfYnVpbGRlclV0aWxSdW50aW1lIHx8IF9sb2FkX2J1aWxkZXJVdGlsUnVudGltZSgpKS5uZXdFcnJvcikoXCJObyBmaWxlcyBwcm92aWRlZFwiLCBcIkVSUl9VUERBVEVSX05PX0ZJTEVTX1BST1ZJREVEXCIpO1xuICAgIH1cbiAgICBjb25zdCByZXN1bHQgPSBmaWxlcy5maW5kKGl0ID0+IGl0LnVybC5wYXRobmFtZS50b0xvd2VyQ2FzZSgpLmVuZHNXaXRoKGAuJHtleHRlbnNpb259YCkpO1xuICAgIGlmIChyZXN1bHQgIT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0gZWxzZSBpZiAobm90ID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIGZpbGVzWzBdO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBmaWxlcy5maW5kKGZpbGVJbmZvID0+ICFub3Quc29tZShleHQgPT4gZmlsZUluZm8udXJsLnBhdGhuYW1lLnRvTG93ZXJDYXNlKCkuZW5kc1dpdGgoYC4ke2V4dH1gKSkpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHBhcnNlVXBkYXRlSW5mbyhyYXdEYXRhLCBjaGFubmVsRmlsZSwgY2hhbm5lbEZpbGVVcmwpIHtcbiAgICBpZiAocmF3RGF0YSA9PSBudWxsKSB7XG4gICAgICAgIHRocm93ICgwLCAoX2J1aWxkZXJVdGlsUnVudGltZSB8fCBfbG9hZF9idWlsZGVyVXRpbFJ1bnRpbWUoKSkubmV3RXJyb3IpKGBDYW5ub3QgcGFyc2UgdXBkYXRlIGluZm8gZnJvbSAke2NoYW5uZWxGaWxlfSBpbiB0aGUgbGF0ZXN0IHJlbGVhc2UgYXJ0aWZhY3RzICgke2NoYW5uZWxGaWxlVXJsfSk6IHJhd0RhdGE6IG51bGxgLCBcIkVSUl9VUERBVEVSX0lOVkFMSURfVVBEQVRFX0lORk9cIik7XG4gICAgfVxuICAgIGxldCByZXN1bHQ7XG4gICAgdHJ5IHtcbiAgICAgICAgcmVzdWx0ID0gKDAsIChfanNZYW1sIHx8IF9sb2FkX2pzWWFtbCgpKS5zYWZlTG9hZCkocmF3RGF0YSk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgICB0aHJvdyAoMCwgKF9idWlsZGVyVXRpbFJ1bnRpbWUgfHwgX2xvYWRfYnVpbGRlclV0aWxSdW50aW1lKCkpLm5ld0Vycm9yKShgQ2Fubm90IHBhcnNlIHVwZGF0ZSBpbmZvIGZyb20gJHtjaGFubmVsRmlsZX0gaW4gdGhlIGxhdGVzdCByZWxlYXNlIGFydGlmYWN0cyAoJHtjaGFubmVsRmlsZVVybH0pOiAke2Uuc3RhY2sgfHwgZS5tZXNzYWdlfSwgcmF3RGF0YTogJHtyYXdEYXRhfWAsIFwiRVJSX1VQREFURVJfSU5WQUxJRF9VUERBVEVfSU5GT1wiKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIGdldEZpbGVMaXN0KHVwZGF0ZUluZm8pIHtcbiAgICBjb25zdCBmaWxlcyA9IHVwZGF0ZUluZm8uZmlsZXM7XG4gICAgaWYgKGZpbGVzICE9IG51bGwgJiYgZmlsZXMubGVuZ3RoID4gMCkge1xuICAgICAgICByZXR1cm4gZmlsZXM7XG4gICAgfVxuICAgIGlmICh1cGRhdGVJbmZvLnBhdGggIT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gW3tcbiAgICAgICAgICAgIHVybDogdXBkYXRlSW5mby5wYXRoLFxuICAgICAgICAgICAgc2hhNTEyOiB1cGRhdGVJbmZvLnNoYTUxMlxuICAgICAgICB9XTtcbiAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyAoMCwgKF9idWlsZGVyVXRpbFJ1bnRpbWUgfHwgX2xvYWRfYnVpbGRlclV0aWxSdW50aW1lKCkpLm5ld0Vycm9yKShgTm8gZmlsZXMgcHJvdmlkZWQ6ICR7KDAsIChfYnVpbGRlclV0aWxSdW50aW1lIHx8IF9sb2FkX2J1aWxkZXJVdGlsUnVudGltZSgpKS5zYWZlU3RyaW5naWZ5SnNvbikodXBkYXRlSW5mbyl9YCwgXCJFUlJfVVBEQVRFUl9OT19GSUxFU19QUk9WSURFRFwiKTtcbiAgICB9XG59XG5mdW5jdGlvbiByZXNvbHZlRmlsZXModXBkYXRlSW5mbywgYmFzZVVybCwgcGF0aFRyYW5zZm9ybWVyID0gcCA9PiBwKSB7XG4gICAgY29uc3QgZmlsZXMgPSBnZXRGaWxlTGlzdCh1cGRhdGVJbmZvKTtcbiAgICBjb25zdCByZXN1bHQgPSBmaWxlcy5tYXAoZmlsZUluZm8gPT4ge1xuICAgICAgICBpZiAoZmlsZUluZm8uc2hhMiA9PSBudWxsICYmIGZpbGVJbmZvLnNoYTUxMiA9PSBudWxsKSB7XG4gICAgICAgICAgICB0aHJvdyAoMCwgKF9idWlsZGVyVXRpbFJ1bnRpbWUgfHwgX2xvYWRfYnVpbGRlclV0aWxSdW50aW1lKCkpLm5ld0Vycm9yKShgVXBkYXRlIGluZm8gZG9lc24ndCBjb250YWluIG5vciBzaGEyNTYgbmVpdGhlciBzaGE1MTIgY2hlY2tzdW06ICR7KDAsIChfYnVpbGRlclV0aWxSdW50aW1lIHx8IF9sb2FkX2J1aWxkZXJVdGlsUnVudGltZSgpKS5zYWZlU3RyaW5naWZ5SnNvbikoZmlsZUluZm8pfWAsIFwiRVJSX1VQREFURVJfTk9fQ0hFQ0tTVU1cIik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHVybDogKDAsIChfbWFpbiB8fCBfbG9hZF9tYWluKCkpLm5ld1VybEZyb21CYXNlKShwYXRoVHJhbnNmb3JtZXIoZmlsZUluZm8udXJsKSwgYmFzZVVybCksXG4gICAgICAgICAgICBpbmZvOiBmaWxlSW5mb1xuICAgICAgICB9O1xuICAgIH0pO1xuICAgIGNvbnN0IHBhY2thZ2VzID0gdXBkYXRlSW5mby5wYWNrYWdlcztcbiAgICBjb25zdCBwYWNrYWdlSW5mbyA9IHBhY2thZ2VzID09IG51bGwgPyBudWxsIDogcGFja2FnZXNbcHJvY2Vzcy5hcmNoXSB8fCBwYWNrYWdlcy5pYTMyO1xuICAgIGlmIChwYWNrYWdlSW5mbyAhPSBudWxsKSB7XG4gICAgICAgIHJlc3VsdFswXS5wYWNrYWdlSW5mbyA9IE9iamVjdC5hc3NpZ24oe30sIHBhY2thZ2VJbmZvLCB7IHBhdGg6ICgwLCAoX21haW4gfHwgX2xvYWRfbWFpbigpKS5uZXdVcmxGcm9tQmFzZSkocGF0aFRyYW5zZm9ybWVyKHBhY2thZ2VJbmZvLnBhdGgpLCBiYXNlVXJsKS5ocmVmIH0pO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9UHJvdmlkZXIuanMubWFwXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2VsZWN0cm9uLXVwZGF0ZXIvb3V0L1Byb3ZpZGVyLmpzIiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwib3NcIik7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gZXh0ZXJuYWwgXCJvc1wiXG4vLyBtb2R1bGUgaWQgPSAxNVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgaXNFUzUgPSAoZnVuY3Rpb24oKXtcbiAgICBcInVzZSBzdHJpY3RcIjtcbiAgICByZXR1cm4gdGhpcyA9PT0gdW5kZWZpbmVkO1xufSkoKTtcblxuaWYgKGlzRVM1KSB7XG4gICAgbW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgICAgIGZyZWV6ZTogT2JqZWN0LmZyZWV6ZSxcbiAgICAgICAgZGVmaW5lUHJvcGVydHk6IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSxcbiAgICAgICAgZ2V0RGVzY3JpcHRvcjogT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcixcbiAgICAgICAga2V5czogT2JqZWN0LmtleXMsXG4gICAgICAgIG5hbWVzOiBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyxcbiAgICAgICAgZ2V0UHJvdG90eXBlT2Y6IE9iamVjdC5nZXRQcm90b3R5cGVPZixcbiAgICAgICAgaXNBcnJheTogQXJyYXkuaXNBcnJheSxcbiAgICAgICAgaXNFUzU6IGlzRVM1LFxuICAgICAgICBwcm9wZXJ0eUlzV3JpdGFibGU6IGZ1bmN0aW9uKG9iaiwgcHJvcCkge1xuICAgICAgICAgICAgdmFyIGRlc2NyaXB0b3IgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iaiwgcHJvcCk7XG4gICAgICAgICAgICByZXR1cm4gISEoIWRlc2NyaXB0b3IgfHwgZGVzY3JpcHRvci53cml0YWJsZSB8fCBkZXNjcmlwdG9yLnNldCk7XG4gICAgICAgIH1cbiAgICB9O1xufSBlbHNlIHtcbiAgICB2YXIgaGFzID0ge30uaGFzT3duUHJvcGVydHk7XG4gICAgdmFyIHN0ciA9IHt9LnRvU3RyaW5nO1xuICAgIHZhciBwcm90byA9IHt9LmNvbnN0cnVjdG9yLnByb3RvdHlwZTtcblxuICAgIHZhciBPYmplY3RLZXlzID0gZnVuY3Rpb24gKG8pIHtcbiAgICAgICAgdmFyIHJldCA9IFtdO1xuICAgICAgICBmb3IgKHZhciBrZXkgaW4gbykge1xuICAgICAgICAgICAgaWYgKGhhcy5jYWxsKG8sIGtleSkpIHtcbiAgICAgICAgICAgICAgICByZXQucHVzaChrZXkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXQ7XG4gICAgfTtcblxuICAgIHZhciBPYmplY3RHZXREZXNjcmlwdG9yID0gZnVuY3Rpb24obywga2V5KSB7XG4gICAgICAgIHJldHVybiB7dmFsdWU6IG9ba2V5XX07XG4gICAgfTtcblxuICAgIHZhciBPYmplY3REZWZpbmVQcm9wZXJ0eSA9IGZ1bmN0aW9uIChvLCBrZXksIGRlc2MpIHtcbiAgICAgICAgb1trZXldID0gZGVzYy52YWx1ZTtcbiAgICAgICAgcmV0dXJuIG87XG4gICAgfTtcblxuICAgIHZhciBPYmplY3RGcmVlemUgPSBmdW5jdGlvbiAob2JqKSB7XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfTtcblxuICAgIHZhciBPYmplY3RHZXRQcm90b3R5cGVPZiA9IGZ1bmN0aW9uIChvYmopIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybiBPYmplY3Qob2JqKS5jb25zdHJ1Y3Rvci5wcm90b3R5cGU7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIHJldHVybiBwcm90bztcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICB2YXIgQXJyYXlJc0FycmF5ID0gZnVuY3Rpb24gKG9iaikge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmV0dXJuIHN0ci5jYWxsKG9iaikgPT09IFwiW29iamVjdCBBcnJheV1cIjtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaChlKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgICAgIGlzQXJyYXk6IEFycmF5SXNBcnJheSxcbiAgICAgICAga2V5czogT2JqZWN0S2V5cyxcbiAgICAgICAgbmFtZXM6IE9iamVjdEtleXMsXG4gICAgICAgIGRlZmluZVByb3BlcnR5OiBPYmplY3REZWZpbmVQcm9wZXJ0eSxcbiAgICAgICAgZ2V0RGVzY3JpcHRvcjogT2JqZWN0R2V0RGVzY3JpcHRvcixcbiAgICAgICAgZnJlZXplOiBPYmplY3RGcmVlemUsXG4gICAgICAgIGdldFByb3RvdHlwZU9mOiBPYmplY3RHZXRQcm90b3R5cGVPZixcbiAgICAgICAgaXNFUzU6IGlzRVM1LFxuICAgICAgICBwcm9wZXJ0eUlzV3JpdGFibGU6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICB9O1xufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2JsdWViaXJkL2pzL3JlbGVhc2UvZXM1LmpzIiwiJ3VzZSBzdHJpY3QnO1xuXG5cbmZ1bmN0aW9uIGlzTm90aGluZyhzdWJqZWN0KSB7XG4gIHJldHVybiAodHlwZW9mIHN1YmplY3QgPT09ICd1bmRlZmluZWQnKSB8fCAoc3ViamVjdCA9PT0gbnVsbCk7XG59XG5cblxuZnVuY3Rpb24gaXNPYmplY3Qoc3ViamVjdCkge1xuICByZXR1cm4gKHR5cGVvZiBzdWJqZWN0ID09PSAnb2JqZWN0JykgJiYgKHN1YmplY3QgIT09IG51bGwpO1xufVxuXG5cbmZ1bmN0aW9uIHRvQXJyYXkoc2VxdWVuY2UpIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkoc2VxdWVuY2UpKSByZXR1cm4gc2VxdWVuY2U7XG4gIGVsc2UgaWYgKGlzTm90aGluZyhzZXF1ZW5jZSkpIHJldHVybiBbXTtcblxuICByZXR1cm4gWyBzZXF1ZW5jZSBdO1xufVxuXG5cbmZ1bmN0aW9uIGV4dGVuZCh0YXJnZXQsIHNvdXJjZSkge1xuICB2YXIgaW5kZXgsIGxlbmd0aCwga2V5LCBzb3VyY2VLZXlzO1xuXG4gIGlmIChzb3VyY2UpIHtcbiAgICBzb3VyY2VLZXlzID0gT2JqZWN0LmtleXMoc291cmNlKTtcblxuICAgIGZvciAoaW5kZXggPSAwLCBsZW5ndGggPSBzb3VyY2VLZXlzLmxlbmd0aDsgaW5kZXggPCBsZW5ndGg7IGluZGV4ICs9IDEpIHtcbiAgICAgIGtleSA9IHNvdXJjZUtleXNbaW5kZXhdO1xuICAgICAgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdGFyZ2V0O1xufVxuXG5cbmZ1bmN0aW9uIHJlcGVhdChzdHJpbmcsIGNvdW50KSB7XG4gIHZhciByZXN1bHQgPSAnJywgY3ljbGU7XG5cbiAgZm9yIChjeWNsZSA9IDA7IGN5Y2xlIDwgY291bnQ7IGN5Y2xlICs9IDEpIHtcbiAgICByZXN1bHQgKz0gc3RyaW5nO1xuICB9XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuXG5mdW5jdGlvbiBpc05lZ2F0aXZlWmVybyhudW1iZXIpIHtcbiAgcmV0dXJuIChudW1iZXIgPT09IDApICYmIChOdW1iZXIuTkVHQVRJVkVfSU5GSU5JVFkgPT09IDEgLyBudW1iZXIpO1xufVxuXG5cbm1vZHVsZS5leHBvcnRzLmlzTm90aGluZyAgICAgID0gaXNOb3RoaW5nO1xubW9kdWxlLmV4cG9ydHMuaXNPYmplY3QgICAgICAgPSBpc09iamVjdDtcbm1vZHVsZS5leHBvcnRzLnRvQXJyYXkgICAgICAgID0gdG9BcnJheTtcbm1vZHVsZS5leHBvcnRzLnJlcGVhdCAgICAgICAgID0gcmVwZWF0O1xubW9kdWxlLmV4cG9ydHMuaXNOZWdhdGl2ZVplcm8gPSBpc05lZ2F0aXZlWmVybztcbm1vZHVsZS5leHBvcnRzLmV4dGVuZCAgICAgICAgID0gZXh0ZW5kO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2pzLXlhbWwvbGliL2pzLXlhbWwvY29tbW9uLmpzIiwiJ3VzZSBzdHJpY3QnO1xuXG4vKmVzbGludC1kaXNhYmxlIG1heC1sZW4qL1xuXG52YXIgY29tbW9uICAgICAgICA9IHJlcXVpcmUoJy4vY29tbW9uJyk7XG52YXIgWUFNTEV4Y2VwdGlvbiA9IHJlcXVpcmUoJy4vZXhjZXB0aW9uJyk7XG52YXIgVHlwZSAgICAgICAgICA9IHJlcXVpcmUoJy4vdHlwZScpO1xuXG5cbmZ1bmN0aW9uIGNvbXBpbGVMaXN0KHNjaGVtYSwgbmFtZSwgcmVzdWx0KSB7XG4gIHZhciBleGNsdWRlID0gW107XG5cbiAgc2NoZW1hLmluY2x1ZGUuZm9yRWFjaChmdW5jdGlvbiAoaW5jbHVkZWRTY2hlbWEpIHtcbiAgICByZXN1bHQgPSBjb21waWxlTGlzdChpbmNsdWRlZFNjaGVtYSwgbmFtZSwgcmVzdWx0KTtcbiAgfSk7XG5cbiAgc2NoZW1hW25hbWVdLmZvckVhY2goZnVuY3Rpb24gKGN1cnJlbnRUeXBlKSB7XG4gICAgcmVzdWx0LmZvckVhY2goZnVuY3Rpb24gKHByZXZpb3VzVHlwZSwgcHJldmlvdXNJbmRleCkge1xuICAgICAgaWYgKHByZXZpb3VzVHlwZS50YWcgPT09IGN1cnJlbnRUeXBlLnRhZyAmJiBwcmV2aW91c1R5cGUua2luZCA9PT0gY3VycmVudFR5cGUua2luZCkge1xuICAgICAgICBleGNsdWRlLnB1c2gocHJldmlvdXNJbmRleCk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICByZXN1bHQucHVzaChjdXJyZW50VHlwZSk7XG4gIH0pO1xuXG4gIHJldHVybiByZXN1bHQuZmlsdGVyKGZ1bmN0aW9uICh0eXBlLCBpbmRleCkge1xuICAgIHJldHVybiBleGNsdWRlLmluZGV4T2YoaW5kZXgpID09PSAtMTtcbiAgfSk7XG59XG5cblxuZnVuY3Rpb24gY29tcGlsZU1hcCgvKiBsaXN0cy4uLiAqLykge1xuICB2YXIgcmVzdWx0ID0ge1xuICAgICAgICBzY2FsYXI6IHt9LFxuICAgICAgICBzZXF1ZW5jZToge30sXG4gICAgICAgIG1hcHBpbmc6IHt9LFxuICAgICAgICBmYWxsYmFjazoge31cbiAgICAgIH0sIGluZGV4LCBsZW5ndGg7XG5cbiAgZnVuY3Rpb24gY29sbGVjdFR5cGUodHlwZSkge1xuICAgIHJlc3VsdFt0eXBlLmtpbmRdW3R5cGUudGFnXSA9IHJlc3VsdFsnZmFsbGJhY2snXVt0eXBlLnRhZ10gPSB0eXBlO1xuICB9XG5cbiAgZm9yIChpbmRleCA9IDAsIGxlbmd0aCA9IGFyZ3VtZW50cy5sZW5ndGg7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCArPSAxKSB7XG4gICAgYXJndW1lbnRzW2luZGV4XS5mb3JFYWNoKGNvbGxlY3RUeXBlKTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5cbmZ1bmN0aW9uIFNjaGVtYShkZWZpbml0aW9uKSB7XG4gIHRoaXMuaW5jbHVkZSAgPSBkZWZpbml0aW9uLmluY2x1ZGUgIHx8IFtdO1xuICB0aGlzLmltcGxpY2l0ID0gZGVmaW5pdGlvbi5pbXBsaWNpdCB8fCBbXTtcbiAgdGhpcy5leHBsaWNpdCA9IGRlZmluaXRpb24uZXhwbGljaXQgfHwgW107XG5cbiAgdGhpcy5pbXBsaWNpdC5mb3JFYWNoKGZ1bmN0aW9uICh0eXBlKSB7XG4gICAgaWYgKHR5cGUubG9hZEtpbmQgJiYgdHlwZS5sb2FkS2luZCAhPT0gJ3NjYWxhcicpIHtcbiAgICAgIHRocm93IG5ldyBZQU1MRXhjZXB0aW9uKCdUaGVyZSBpcyBhIG5vbi1zY2FsYXIgdHlwZSBpbiB0aGUgaW1wbGljaXQgbGlzdCBvZiBhIHNjaGVtYS4gSW1wbGljaXQgcmVzb2x2aW5nIG9mIHN1Y2ggdHlwZXMgaXMgbm90IHN1cHBvcnRlZC4nKTtcbiAgICB9XG4gIH0pO1xuXG4gIHRoaXMuY29tcGlsZWRJbXBsaWNpdCA9IGNvbXBpbGVMaXN0KHRoaXMsICdpbXBsaWNpdCcsIFtdKTtcbiAgdGhpcy5jb21waWxlZEV4cGxpY2l0ID0gY29tcGlsZUxpc3QodGhpcywgJ2V4cGxpY2l0JywgW10pO1xuICB0aGlzLmNvbXBpbGVkVHlwZU1hcCAgPSBjb21waWxlTWFwKHRoaXMuY29tcGlsZWRJbXBsaWNpdCwgdGhpcy5jb21waWxlZEV4cGxpY2l0KTtcbn1cblxuXG5TY2hlbWEuREVGQVVMVCA9IG51bGw7XG5cblxuU2NoZW1hLmNyZWF0ZSA9IGZ1bmN0aW9uIGNyZWF0ZVNjaGVtYSgpIHtcbiAgdmFyIHNjaGVtYXMsIHR5cGVzO1xuXG4gIHN3aXRjaCAoYXJndW1lbnRzLmxlbmd0aCkge1xuICAgIGNhc2UgMTpcbiAgICAgIHNjaGVtYXMgPSBTY2hlbWEuREVGQVVMVDtcbiAgICAgIHR5cGVzID0gYXJndW1lbnRzWzBdO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlIDI6XG4gICAgICBzY2hlbWFzID0gYXJndW1lbnRzWzBdO1xuICAgICAgdHlwZXMgPSBhcmd1bWVudHNbMV07XG4gICAgICBicmVhaztcblxuICAgIGRlZmF1bHQ6XG4gICAgICB0aHJvdyBuZXcgWUFNTEV4Y2VwdGlvbignV3JvbmcgbnVtYmVyIG9mIGFyZ3VtZW50cyBmb3IgU2NoZW1hLmNyZWF0ZSBmdW5jdGlvbicpO1xuICB9XG5cbiAgc2NoZW1hcyA9IGNvbW1vbi50b0FycmF5KHNjaGVtYXMpO1xuICB0eXBlcyA9IGNvbW1vbi50b0FycmF5KHR5cGVzKTtcblxuICBpZiAoIXNjaGVtYXMuZXZlcnkoZnVuY3Rpb24gKHNjaGVtYSkgeyByZXR1cm4gc2NoZW1hIGluc3RhbmNlb2YgU2NoZW1hOyB9KSkge1xuICAgIHRocm93IG5ldyBZQU1MRXhjZXB0aW9uKCdTcGVjaWZpZWQgbGlzdCBvZiBzdXBlciBzY2hlbWFzIChvciBhIHNpbmdsZSBTY2hlbWEgb2JqZWN0KSBjb250YWlucyBhIG5vbi1TY2hlbWEgb2JqZWN0LicpO1xuICB9XG5cbiAgaWYgKCF0eXBlcy5ldmVyeShmdW5jdGlvbiAodHlwZSkgeyByZXR1cm4gdHlwZSBpbnN0YW5jZW9mIFR5cGU7IH0pKSB7XG4gICAgdGhyb3cgbmV3IFlBTUxFeGNlcHRpb24oJ1NwZWNpZmllZCBsaXN0IG9mIFlBTUwgdHlwZXMgKG9yIGEgc2luZ2xlIFR5cGUgb2JqZWN0KSBjb250YWlucyBhIG5vbi1UeXBlIG9iamVjdC4nKTtcbiAgfVxuXG4gIHJldHVybiBuZXcgU2NoZW1hKHtcbiAgICBpbmNsdWRlOiBzY2hlbWFzLFxuICAgIGV4cGxpY2l0OiB0eXBlc1xuICB9KTtcbn07XG5cblxubW9kdWxlLmV4cG9ydHMgPSBTY2hlbWE7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvanMteWFtbC9saWIvanMteWFtbC9zY2hlbWEuanMiLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCJzdHJlYW1cIik7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gZXh0ZXJuYWwgXCJzdHJlYW1cIlxuLy8gbW9kdWxlIGlkID0gMTlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwidXJsXCIpO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIGV4dGVybmFsIFwidXJsXCJcbi8vIG1vZHVsZSBpZCA9IDIwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8vIFlBTUwgZXJyb3IgY2xhc3MuIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvODQ1ODk4NFxuLy9cbid1c2Ugc3RyaWN0JztcblxuZnVuY3Rpb24gWUFNTEV4Y2VwdGlvbihyZWFzb24sIG1hcmspIHtcbiAgLy8gU3VwZXIgY29uc3RydWN0b3JcbiAgRXJyb3IuY2FsbCh0aGlzKTtcblxuICB0aGlzLm5hbWUgPSAnWUFNTEV4Y2VwdGlvbic7XG4gIHRoaXMucmVhc29uID0gcmVhc29uO1xuICB0aGlzLm1hcmsgPSBtYXJrO1xuICB0aGlzLm1lc3NhZ2UgPSAodGhpcy5yZWFzb24gfHwgJyh1bmtub3duIHJlYXNvbiknKSArICh0aGlzLm1hcmsgPyAnICcgKyB0aGlzLm1hcmsudG9TdHJpbmcoKSA6ICcnKTtcblxuICAvLyBJbmNsdWRlIHN0YWNrIHRyYWNlIGluIGVycm9yIG9iamVjdFxuICBpZiAoRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UpIHtcbiAgICAvLyBDaHJvbWUgYW5kIE5vZGVKU1xuICAgIEVycm9yLmNhcHR1cmVTdGFja1RyYWNlKHRoaXMsIHRoaXMuY29uc3RydWN0b3IpO1xuICB9IGVsc2Uge1xuICAgIC8vIEZGLCBJRSAxMCsgYW5kIFNhZmFyaSA2Ky4gRmFsbGJhY2sgZm9yIG90aGVyc1xuICAgIHRoaXMuc3RhY2sgPSAobmV3IEVycm9yKCkpLnN0YWNrIHx8ICcnO1xuICB9XG59XG5cblxuLy8gSW5oZXJpdCBmcm9tIEVycm9yXG5ZQU1MRXhjZXB0aW9uLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoRXJyb3IucHJvdG90eXBlKTtcbllBTUxFeGNlcHRpb24ucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gWUFNTEV4Y2VwdGlvbjtcblxuXG5ZQU1MRXhjZXB0aW9uLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nKGNvbXBhY3QpIHtcbiAgdmFyIHJlc3VsdCA9IHRoaXMubmFtZSArICc6ICc7XG5cbiAgcmVzdWx0ICs9IHRoaXMucmVhc29uIHx8ICcodW5rbm93biByZWFzb24pJztcblxuICBpZiAoIWNvbXBhY3QgJiYgdGhpcy5tYXJrKSB7XG4gICAgcmVzdWx0ICs9ICcgJyArIHRoaXMubWFyay50b1N0cmluZygpO1xuICB9XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cblxubW9kdWxlLmV4cG9ydHMgPSBZQU1MRXhjZXB0aW9uO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2pzLXlhbWwvbGliL2pzLXlhbWwvZXhjZXB0aW9uLmpzIiwiLy8gSlMtWUFNTCdzIGRlZmF1bHQgc2NoZW1hIGZvciBgc2FmZUxvYWRgIGZ1bmN0aW9uLlxuLy8gSXQgaXMgbm90IGRlc2NyaWJlZCBpbiB0aGUgWUFNTCBzcGVjaWZpY2F0aW9uLlxuLy9cbi8vIFRoaXMgc2NoZW1hIGlzIGJhc2VkIG9uIHN0YW5kYXJkIFlBTUwncyBDb3JlIHNjaGVtYSBhbmQgaW5jbHVkZXMgbW9zdCBvZlxuLy8gZXh0cmEgdHlwZXMgZGVzY3JpYmVkIGF0IFlBTUwgdGFnIHJlcG9zaXRvcnkuIChodHRwOi8veWFtbC5vcmcvdHlwZS8pXG5cblxuJ3VzZSBzdHJpY3QnO1xuXG5cbnZhciBTY2hlbWEgPSByZXF1aXJlKCcuLi9zY2hlbWEnKTtcblxuXG5tb2R1bGUuZXhwb3J0cyA9IG5ldyBTY2hlbWEoe1xuICBpbmNsdWRlOiBbXG4gICAgcmVxdWlyZSgnLi9jb3JlJylcbiAgXSxcbiAgaW1wbGljaXQ6IFtcbiAgICByZXF1aXJlKCcuLi90eXBlL3RpbWVzdGFtcCcpLFxuICAgIHJlcXVpcmUoJy4uL3R5cGUvbWVyZ2UnKVxuICBdLFxuICBleHBsaWNpdDogW1xuICAgIHJlcXVpcmUoJy4uL3R5cGUvYmluYXJ5JyksXG4gICAgcmVxdWlyZSgnLi4vdHlwZS9vbWFwJyksXG4gICAgcmVxdWlyZSgnLi4vdHlwZS9wYWlycycpLFxuICAgIHJlcXVpcmUoJy4uL3R5cGUvc2V0JylcbiAgXVxufSk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvanMteWFtbC9saWIvanMteWFtbC9zY2hlbWEvZGVmYXVsdF9zYWZlLmpzIiwiLyogLSotIE1vZGU6IGpzOyBqcy1pbmRlbnQtbGV2ZWw6IDI7IC0qLSAqL1xuLypcbiAqIENvcHlyaWdodCAyMDExIE1vemlsbGEgRm91bmRhdGlvbiBhbmQgY29udHJpYnV0b3JzXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTmV3IEJTRCBsaWNlbnNlLiBTZWUgTElDRU5TRSBvcjpcbiAqIGh0dHA6Ly9vcGVuc291cmNlLm9yZy9saWNlbnNlcy9CU0QtMy1DbGF1c2VcbiAqL1xuXG4vKipcbiAqIFRoaXMgaXMgYSBoZWxwZXIgZnVuY3Rpb24gZm9yIGdldHRpbmcgdmFsdWVzIGZyb20gcGFyYW1ldGVyL29wdGlvbnNcbiAqIG9iamVjdHMuXG4gKlxuICogQHBhcmFtIGFyZ3MgVGhlIG9iamVjdCB3ZSBhcmUgZXh0cmFjdGluZyB2YWx1ZXMgZnJvbVxuICogQHBhcmFtIG5hbWUgVGhlIG5hbWUgb2YgdGhlIHByb3BlcnR5IHdlIGFyZSBnZXR0aW5nLlxuICogQHBhcmFtIGRlZmF1bHRWYWx1ZSBBbiBvcHRpb25hbCB2YWx1ZSB0byByZXR1cm4gaWYgdGhlIHByb3BlcnR5IGlzIG1pc3NpbmdcbiAqIGZyb20gdGhlIG9iamVjdC4gSWYgdGhpcyBpcyBub3Qgc3BlY2lmaWVkIGFuZCB0aGUgcHJvcGVydHkgaXMgbWlzc2luZywgYW5cbiAqIGVycm9yIHdpbGwgYmUgdGhyb3duLlxuICovXG5mdW5jdGlvbiBnZXRBcmcoYUFyZ3MsIGFOYW1lLCBhRGVmYXVsdFZhbHVlKSB7XG4gIGlmIChhTmFtZSBpbiBhQXJncykge1xuICAgIHJldHVybiBhQXJnc1thTmFtZV07XG4gIH0gZWxzZSBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMykge1xuICAgIHJldHVybiBhRGVmYXVsdFZhbHVlO1xuICB9IGVsc2Uge1xuICAgIHRocm93IG5ldyBFcnJvcignXCInICsgYU5hbWUgKyAnXCIgaXMgYSByZXF1aXJlZCBhcmd1bWVudC4nKTtcbiAgfVxufVxuZXhwb3J0cy5nZXRBcmcgPSBnZXRBcmc7XG5cbnZhciB1cmxSZWdleHAgPSAvXig/OihbXFx3K1xcLS5dKyk6KT9cXC9cXC8oPzooXFx3KzpcXHcrKUApPyhbXFx3Li1dKikoPzo6KFxcZCspKT8oLiopJC87XG52YXIgZGF0YVVybFJlZ2V4cCA9IC9eZGF0YTouK1xcLC4rJC87XG5cbmZ1bmN0aW9uIHVybFBhcnNlKGFVcmwpIHtcbiAgdmFyIG1hdGNoID0gYVVybC5tYXRjaCh1cmxSZWdleHApO1xuICBpZiAoIW1hdGNoKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBzY2hlbWU6IG1hdGNoWzFdLFxuICAgIGF1dGg6IG1hdGNoWzJdLFxuICAgIGhvc3Q6IG1hdGNoWzNdLFxuICAgIHBvcnQ6IG1hdGNoWzRdLFxuICAgIHBhdGg6IG1hdGNoWzVdXG4gIH07XG59XG5leHBvcnRzLnVybFBhcnNlID0gdXJsUGFyc2U7XG5cbmZ1bmN0aW9uIHVybEdlbmVyYXRlKGFQYXJzZWRVcmwpIHtcbiAgdmFyIHVybCA9ICcnO1xuICBpZiAoYVBhcnNlZFVybC5zY2hlbWUpIHtcbiAgICB1cmwgKz0gYVBhcnNlZFVybC5zY2hlbWUgKyAnOic7XG4gIH1cbiAgdXJsICs9ICcvLyc7XG4gIGlmIChhUGFyc2VkVXJsLmF1dGgpIHtcbiAgICB1cmwgKz0gYVBhcnNlZFVybC5hdXRoICsgJ0AnO1xuICB9XG4gIGlmIChhUGFyc2VkVXJsLmhvc3QpIHtcbiAgICB1cmwgKz0gYVBhcnNlZFVybC5ob3N0O1xuICB9XG4gIGlmIChhUGFyc2VkVXJsLnBvcnQpIHtcbiAgICB1cmwgKz0gXCI6XCIgKyBhUGFyc2VkVXJsLnBvcnRcbiAgfVxuICBpZiAoYVBhcnNlZFVybC5wYXRoKSB7XG4gICAgdXJsICs9IGFQYXJzZWRVcmwucGF0aDtcbiAgfVxuICByZXR1cm4gdXJsO1xufVxuZXhwb3J0cy51cmxHZW5lcmF0ZSA9IHVybEdlbmVyYXRlO1xuXG4vKipcbiAqIE5vcm1hbGl6ZXMgYSBwYXRoLCBvciB0aGUgcGF0aCBwb3J0aW9uIG9mIGEgVVJMOlxuICpcbiAqIC0gUmVwbGFjZXMgY29uc2VjdXRpdmUgc2xhc2hlcyB3aXRoIG9uZSBzbGFzaC5cbiAqIC0gUmVtb3ZlcyB1bm5lY2Vzc2FyeSAnLicgcGFydHMuXG4gKiAtIFJlbW92ZXMgdW5uZWNlc3NhcnkgJzxkaXI+Ly4uJyBwYXJ0cy5cbiAqXG4gKiBCYXNlZCBvbiBjb2RlIGluIHRoZSBOb2RlLmpzICdwYXRoJyBjb3JlIG1vZHVsZS5cbiAqXG4gKiBAcGFyYW0gYVBhdGggVGhlIHBhdGggb3IgdXJsIHRvIG5vcm1hbGl6ZS5cbiAqL1xuZnVuY3Rpb24gbm9ybWFsaXplKGFQYXRoKSB7XG4gIHZhciBwYXRoID0gYVBhdGg7XG4gIHZhciB1cmwgPSB1cmxQYXJzZShhUGF0aCk7XG4gIGlmICh1cmwpIHtcbiAgICBpZiAoIXVybC5wYXRoKSB7XG4gICAgICByZXR1cm4gYVBhdGg7XG4gICAgfVxuICAgIHBhdGggPSB1cmwucGF0aDtcbiAgfVxuICB2YXIgaXNBYnNvbHV0ZSA9IGV4cG9ydHMuaXNBYnNvbHV0ZShwYXRoKTtcblxuICB2YXIgcGFydHMgPSBwYXRoLnNwbGl0KC9cXC8rLyk7XG4gIGZvciAodmFyIHBhcnQsIHVwID0gMCwgaSA9IHBhcnRzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgcGFydCA9IHBhcnRzW2ldO1xuICAgIGlmIChwYXJ0ID09PSAnLicpIHtcbiAgICAgIHBhcnRzLnNwbGljZShpLCAxKTtcbiAgICB9IGVsc2UgaWYgKHBhcnQgPT09ICcuLicpIHtcbiAgICAgIHVwKys7XG4gICAgfSBlbHNlIGlmICh1cCA+IDApIHtcbiAgICAgIGlmIChwYXJ0ID09PSAnJykge1xuICAgICAgICAvLyBUaGUgZmlyc3QgcGFydCBpcyBibGFuayBpZiB0aGUgcGF0aCBpcyBhYnNvbHV0ZS4gVHJ5aW5nIHRvIGdvXG4gICAgICAgIC8vIGFib3ZlIHRoZSByb290IGlzIGEgbm8tb3AuIFRoZXJlZm9yZSB3ZSBjYW4gcmVtb3ZlIGFsbCAnLi4nIHBhcnRzXG4gICAgICAgIC8vIGRpcmVjdGx5IGFmdGVyIHRoZSByb290LlxuICAgICAgICBwYXJ0cy5zcGxpY2UoaSArIDEsIHVwKTtcbiAgICAgICAgdXAgPSAwO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcGFydHMuc3BsaWNlKGksIDIpO1xuICAgICAgICB1cC0tO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBwYXRoID0gcGFydHMuam9pbignLycpO1xuXG4gIGlmIChwYXRoID09PSAnJykge1xuICAgIHBhdGggPSBpc0Fic29sdXRlID8gJy8nIDogJy4nO1xuICB9XG5cbiAgaWYgKHVybCkge1xuICAgIHVybC5wYXRoID0gcGF0aDtcbiAgICByZXR1cm4gdXJsR2VuZXJhdGUodXJsKTtcbiAgfVxuICByZXR1cm4gcGF0aDtcbn1cbmV4cG9ydHMubm9ybWFsaXplID0gbm9ybWFsaXplO1xuXG4vKipcbiAqIEpvaW5zIHR3byBwYXRocy9VUkxzLlxuICpcbiAqIEBwYXJhbSBhUm9vdCBUaGUgcm9vdCBwYXRoIG9yIFVSTC5cbiAqIEBwYXJhbSBhUGF0aCBUaGUgcGF0aCBvciBVUkwgdG8gYmUgam9pbmVkIHdpdGggdGhlIHJvb3QuXG4gKlxuICogLSBJZiBhUGF0aCBpcyBhIFVSTCBvciBhIGRhdGEgVVJJLCBhUGF0aCBpcyByZXR1cm5lZCwgdW5sZXNzIGFQYXRoIGlzIGFcbiAqICAgc2NoZW1lLXJlbGF0aXZlIFVSTDogVGhlbiB0aGUgc2NoZW1lIG9mIGFSb290LCBpZiBhbnksIGlzIHByZXBlbmRlZFxuICogICBmaXJzdC5cbiAqIC0gT3RoZXJ3aXNlIGFQYXRoIGlzIGEgcGF0aC4gSWYgYVJvb3QgaXMgYSBVUkwsIHRoZW4gaXRzIHBhdGggcG9ydGlvblxuICogICBpcyB1cGRhdGVkIHdpdGggdGhlIHJlc3VsdCBhbmQgYVJvb3QgaXMgcmV0dXJuZWQuIE90aGVyd2lzZSB0aGUgcmVzdWx0XG4gKiAgIGlzIHJldHVybmVkLlxuICogICAtIElmIGFQYXRoIGlzIGFic29sdXRlLCB0aGUgcmVzdWx0IGlzIGFQYXRoLlxuICogICAtIE90aGVyd2lzZSB0aGUgdHdvIHBhdGhzIGFyZSBqb2luZWQgd2l0aCBhIHNsYXNoLlxuICogLSBKb2luaW5nIGZvciBleGFtcGxlICdodHRwOi8vJyBhbmQgJ3d3dy5leGFtcGxlLmNvbScgaXMgYWxzbyBzdXBwb3J0ZWQuXG4gKi9cbmZ1bmN0aW9uIGpvaW4oYVJvb3QsIGFQYXRoKSB7XG4gIGlmIChhUm9vdCA9PT0gXCJcIikge1xuICAgIGFSb290ID0gXCIuXCI7XG4gIH1cbiAgaWYgKGFQYXRoID09PSBcIlwiKSB7XG4gICAgYVBhdGggPSBcIi5cIjtcbiAgfVxuICB2YXIgYVBhdGhVcmwgPSB1cmxQYXJzZShhUGF0aCk7XG4gIHZhciBhUm9vdFVybCA9IHVybFBhcnNlKGFSb290KTtcbiAgaWYgKGFSb290VXJsKSB7XG4gICAgYVJvb3QgPSBhUm9vdFVybC5wYXRoIHx8ICcvJztcbiAgfVxuXG4gIC8vIGBqb2luKGZvbywgJy8vd3d3LmV4YW1wbGUub3JnJylgXG4gIGlmIChhUGF0aFVybCAmJiAhYVBhdGhVcmwuc2NoZW1lKSB7XG4gICAgaWYgKGFSb290VXJsKSB7XG4gICAgICBhUGF0aFVybC5zY2hlbWUgPSBhUm9vdFVybC5zY2hlbWU7XG4gICAgfVxuICAgIHJldHVybiB1cmxHZW5lcmF0ZShhUGF0aFVybCk7XG4gIH1cblxuICBpZiAoYVBhdGhVcmwgfHwgYVBhdGgubWF0Y2goZGF0YVVybFJlZ2V4cCkpIHtcbiAgICByZXR1cm4gYVBhdGg7XG4gIH1cblxuICAvLyBgam9pbignaHR0cDovLycsICd3d3cuZXhhbXBsZS5jb20nKWBcbiAgaWYgKGFSb290VXJsICYmICFhUm9vdFVybC5ob3N0ICYmICFhUm9vdFVybC5wYXRoKSB7XG4gICAgYVJvb3RVcmwuaG9zdCA9IGFQYXRoO1xuICAgIHJldHVybiB1cmxHZW5lcmF0ZShhUm9vdFVybCk7XG4gIH1cblxuICB2YXIgam9pbmVkID0gYVBhdGguY2hhckF0KDApID09PSAnLydcbiAgICA/IGFQYXRoXG4gICAgOiBub3JtYWxpemUoYVJvb3QucmVwbGFjZSgvXFwvKyQvLCAnJykgKyAnLycgKyBhUGF0aCk7XG5cbiAgaWYgKGFSb290VXJsKSB7XG4gICAgYVJvb3RVcmwucGF0aCA9IGpvaW5lZDtcbiAgICByZXR1cm4gdXJsR2VuZXJhdGUoYVJvb3RVcmwpO1xuICB9XG4gIHJldHVybiBqb2luZWQ7XG59XG5leHBvcnRzLmpvaW4gPSBqb2luO1xuXG5leHBvcnRzLmlzQWJzb2x1dGUgPSBmdW5jdGlvbiAoYVBhdGgpIHtcbiAgcmV0dXJuIGFQYXRoLmNoYXJBdCgwKSA9PT0gJy8nIHx8IHVybFJlZ2V4cC50ZXN0KGFQYXRoKTtcbn07XG5cbi8qKlxuICogTWFrZSBhIHBhdGggcmVsYXRpdmUgdG8gYSBVUkwgb3IgYW5vdGhlciBwYXRoLlxuICpcbiAqIEBwYXJhbSBhUm9vdCBUaGUgcm9vdCBwYXRoIG9yIFVSTC5cbiAqIEBwYXJhbSBhUGF0aCBUaGUgcGF0aCBvciBVUkwgdG8gYmUgbWFkZSByZWxhdGl2ZSB0byBhUm9vdC5cbiAqL1xuZnVuY3Rpb24gcmVsYXRpdmUoYVJvb3QsIGFQYXRoKSB7XG4gIGlmIChhUm9vdCA9PT0gXCJcIikge1xuICAgIGFSb290ID0gXCIuXCI7XG4gIH1cblxuICBhUm9vdCA9IGFSb290LnJlcGxhY2UoL1xcLyQvLCAnJyk7XG5cbiAgLy8gSXQgaXMgcG9zc2libGUgZm9yIHRoZSBwYXRoIHRvIGJlIGFib3ZlIHRoZSByb290LiBJbiB0aGlzIGNhc2UsIHNpbXBseVxuICAvLyBjaGVja2luZyB3aGV0aGVyIHRoZSByb290IGlzIGEgcHJlZml4IG9mIHRoZSBwYXRoIHdvbid0IHdvcmsuIEluc3RlYWQsIHdlXG4gIC8vIG5lZWQgdG8gcmVtb3ZlIGNvbXBvbmVudHMgZnJvbSB0aGUgcm9vdCBvbmUgYnkgb25lLCB1bnRpbCBlaXRoZXIgd2UgZmluZFxuICAvLyBhIHByZWZpeCB0aGF0IGZpdHMsIG9yIHdlIHJ1biBvdXQgb2YgY29tcG9uZW50cyB0byByZW1vdmUuXG4gIHZhciBsZXZlbCA9IDA7XG4gIHdoaWxlIChhUGF0aC5pbmRleE9mKGFSb290ICsgJy8nKSAhPT0gMCkge1xuICAgIHZhciBpbmRleCA9IGFSb290Lmxhc3RJbmRleE9mKFwiL1wiKTtcbiAgICBpZiAoaW5kZXggPCAwKSB7XG4gICAgICByZXR1cm4gYVBhdGg7XG4gICAgfVxuXG4gICAgLy8gSWYgdGhlIG9ubHkgcGFydCBvZiB0aGUgcm9vdCB0aGF0IGlzIGxlZnQgaXMgdGhlIHNjaGVtZSAoaS5lLiBodHRwOi8vLFxuICAgIC8vIGZpbGU6Ly8vLCBldGMuKSwgb25lIG9yIG1vcmUgc2xhc2hlcyAoLyksIG9yIHNpbXBseSBub3RoaW5nIGF0IGFsbCwgd2VcbiAgICAvLyBoYXZlIGV4aGF1c3RlZCBhbGwgY29tcG9uZW50cywgc28gdGhlIHBhdGggaXMgbm90IHJlbGF0aXZlIHRvIHRoZSByb290LlxuICAgIGFSb290ID0gYVJvb3Quc2xpY2UoMCwgaW5kZXgpO1xuICAgIGlmIChhUm9vdC5tYXRjaCgvXihbXlxcL10rOlxcLyk/XFwvKiQvKSkge1xuICAgICAgcmV0dXJuIGFQYXRoO1xuICAgIH1cblxuICAgICsrbGV2ZWw7XG4gIH1cblxuICAvLyBNYWtlIHN1cmUgd2UgYWRkIGEgXCIuLi9cIiBmb3IgZWFjaCBjb21wb25lbnQgd2UgcmVtb3ZlZCBmcm9tIHRoZSByb290LlxuICByZXR1cm4gQXJyYXkobGV2ZWwgKyAxKS5qb2luKFwiLi4vXCIpICsgYVBhdGguc3Vic3RyKGFSb290Lmxlbmd0aCArIDEpO1xufVxuZXhwb3J0cy5yZWxhdGl2ZSA9IHJlbGF0aXZlO1xuXG52YXIgc3VwcG9ydHNOdWxsUHJvdG8gPSAoZnVuY3Rpb24gKCkge1xuICB2YXIgb2JqID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgcmV0dXJuICEoJ19fcHJvdG9fXycgaW4gb2JqKTtcbn0oKSk7XG5cbmZ1bmN0aW9uIGlkZW50aXR5IChzKSB7XG4gIHJldHVybiBzO1xufVxuXG4vKipcbiAqIEJlY2F1c2UgYmVoYXZpb3IgZ29lcyB3YWNreSB3aGVuIHlvdSBzZXQgYF9fcHJvdG9fX2Agb24gb2JqZWN0cywgd2VcbiAqIGhhdmUgdG8gcHJlZml4IGFsbCB0aGUgc3RyaW5ncyBpbiBvdXIgc2V0IHdpdGggYW4gYXJiaXRyYXJ5IGNoYXJhY3Rlci5cbiAqXG4gKiBTZWUgaHR0cHM6Ly9naXRodWIuY29tL21vemlsbGEvc291cmNlLW1hcC9wdWxsLzMxIGFuZFxuICogaHR0cHM6Ly9naXRodWIuY29tL21vemlsbGEvc291cmNlLW1hcC9pc3N1ZXMvMzBcbiAqXG4gKiBAcGFyYW0gU3RyaW5nIGFTdHJcbiAqL1xuZnVuY3Rpb24gdG9TZXRTdHJpbmcoYVN0cikge1xuICBpZiAoaXNQcm90b1N0cmluZyhhU3RyKSkge1xuICAgIHJldHVybiAnJCcgKyBhU3RyO1xuICB9XG5cbiAgcmV0dXJuIGFTdHI7XG59XG5leHBvcnRzLnRvU2V0U3RyaW5nID0gc3VwcG9ydHNOdWxsUHJvdG8gPyBpZGVudGl0eSA6IHRvU2V0U3RyaW5nO1xuXG5mdW5jdGlvbiBmcm9tU2V0U3RyaW5nKGFTdHIpIHtcbiAgaWYgKGlzUHJvdG9TdHJpbmcoYVN0cikpIHtcbiAgICByZXR1cm4gYVN0ci5zbGljZSgxKTtcbiAgfVxuXG4gIHJldHVybiBhU3RyO1xufVxuZXhwb3J0cy5mcm9tU2V0U3RyaW5nID0gc3VwcG9ydHNOdWxsUHJvdG8gPyBpZGVudGl0eSA6IGZyb21TZXRTdHJpbmc7XG5cbmZ1bmN0aW9uIGlzUHJvdG9TdHJpbmcocykge1xuICBpZiAoIXMpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICB2YXIgbGVuZ3RoID0gcy5sZW5ndGg7XG5cbiAgaWYgKGxlbmd0aCA8IDkgLyogXCJfX3Byb3RvX19cIi5sZW5ndGggKi8pIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBpZiAocy5jaGFyQ29kZUF0KGxlbmd0aCAtIDEpICE9PSA5NSAgLyogJ18nICovIHx8XG4gICAgICBzLmNoYXJDb2RlQXQobGVuZ3RoIC0gMikgIT09IDk1ICAvKiAnXycgKi8gfHxcbiAgICAgIHMuY2hhckNvZGVBdChsZW5ndGggLSAzKSAhPT0gMTExIC8qICdvJyAqLyB8fFxuICAgICAgcy5jaGFyQ29kZUF0KGxlbmd0aCAtIDQpICE9PSAxMTYgLyogJ3QnICovIHx8XG4gICAgICBzLmNoYXJDb2RlQXQobGVuZ3RoIC0gNSkgIT09IDExMSAvKiAnbycgKi8gfHxcbiAgICAgIHMuY2hhckNvZGVBdChsZW5ndGggLSA2KSAhPT0gMTE0IC8qICdyJyAqLyB8fFxuICAgICAgcy5jaGFyQ29kZUF0KGxlbmd0aCAtIDcpICE9PSAxMTIgLyogJ3AnICovIHx8XG4gICAgICBzLmNoYXJDb2RlQXQobGVuZ3RoIC0gOCkgIT09IDk1ICAvKiAnXycgKi8gfHxcbiAgICAgIHMuY2hhckNvZGVBdChsZW5ndGggLSA5KSAhPT0gOTUgIC8qICdfJyAqLykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGZvciAodmFyIGkgPSBsZW5ndGggLSAxMDsgaSA+PSAwOyBpLS0pIHtcbiAgICBpZiAocy5jaGFyQ29kZUF0KGkpICE9PSAzNiAvKiAnJCcgKi8pIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn1cblxuLyoqXG4gKiBDb21wYXJhdG9yIGJldHdlZW4gdHdvIG1hcHBpbmdzIHdoZXJlIHRoZSBvcmlnaW5hbCBwb3NpdGlvbnMgYXJlIGNvbXBhcmVkLlxuICpcbiAqIE9wdGlvbmFsbHkgcGFzcyBpbiBgdHJ1ZWAgYXMgYG9ubHlDb21wYXJlR2VuZXJhdGVkYCB0byBjb25zaWRlciB0d29cbiAqIG1hcHBpbmdzIHdpdGggdGhlIHNhbWUgb3JpZ2luYWwgc291cmNlL2xpbmUvY29sdW1uLCBidXQgZGlmZmVyZW50IGdlbmVyYXRlZFxuICogbGluZSBhbmQgY29sdW1uIHRoZSBzYW1lLiBVc2VmdWwgd2hlbiBzZWFyY2hpbmcgZm9yIGEgbWFwcGluZyB3aXRoIGFcbiAqIHN0dWJiZWQgb3V0IG1hcHBpbmcuXG4gKi9cbmZ1bmN0aW9uIGNvbXBhcmVCeU9yaWdpbmFsUG9zaXRpb25zKG1hcHBpbmdBLCBtYXBwaW5nQiwgb25seUNvbXBhcmVPcmlnaW5hbCkge1xuICB2YXIgY21wID0gc3RyY21wKG1hcHBpbmdBLnNvdXJjZSwgbWFwcGluZ0Iuc291cmNlKTtcbiAgaWYgKGNtcCAhPT0gMCkge1xuICAgIHJldHVybiBjbXA7XG4gIH1cblxuICBjbXAgPSBtYXBwaW5nQS5vcmlnaW5hbExpbmUgLSBtYXBwaW5nQi5vcmlnaW5hbExpbmU7XG4gIGlmIChjbXAgIT09IDApIHtcbiAgICByZXR1cm4gY21wO1xuICB9XG5cbiAgY21wID0gbWFwcGluZ0Eub3JpZ2luYWxDb2x1bW4gLSBtYXBwaW5nQi5vcmlnaW5hbENvbHVtbjtcbiAgaWYgKGNtcCAhPT0gMCB8fCBvbmx5Q29tcGFyZU9yaWdpbmFsKSB7XG4gICAgcmV0dXJuIGNtcDtcbiAgfVxuXG4gIGNtcCA9IG1hcHBpbmdBLmdlbmVyYXRlZENvbHVtbiAtIG1hcHBpbmdCLmdlbmVyYXRlZENvbHVtbjtcbiAgaWYgKGNtcCAhPT0gMCkge1xuICAgIHJldHVybiBjbXA7XG4gIH1cblxuICBjbXAgPSBtYXBwaW5nQS5nZW5lcmF0ZWRMaW5lIC0gbWFwcGluZ0IuZ2VuZXJhdGVkTGluZTtcbiAgaWYgKGNtcCAhPT0gMCkge1xuICAgIHJldHVybiBjbXA7XG4gIH1cblxuICByZXR1cm4gc3RyY21wKG1hcHBpbmdBLm5hbWUsIG1hcHBpbmdCLm5hbWUpO1xufVxuZXhwb3J0cy5jb21wYXJlQnlPcmlnaW5hbFBvc2l0aW9ucyA9IGNvbXBhcmVCeU9yaWdpbmFsUG9zaXRpb25zO1xuXG4vKipcbiAqIENvbXBhcmF0b3IgYmV0d2VlbiB0d28gbWFwcGluZ3Mgd2l0aCBkZWZsYXRlZCBzb3VyY2UgYW5kIG5hbWUgaW5kaWNlcyB3aGVyZVxuICogdGhlIGdlbmVyYXRlZCBwb3NpdGlvbnMgYXJlIGNvbXBhcmVkLlxuICpcbiAqIE9wdGlvbmFsbHkgcGFzcyBpbiBgdHJ1ZWAgYXMgYG9ubHlDb21wYXJlR2VuZXJhdGVkYCB0byBjb25zaWRlciB0d29cbiAqIG1hcHBpbmdzIHdpdGggdGhlIHNhbWUgZ2VuZXJhdGVkIGxpbmUgYW5kIGNvbHVtbiwgYnV0IGRpZmZlcmVudFxuICogc291cmNlL25hbWUvb3JpZ2luYWwgbGluZSBhbmQgY29sdW1uIHRoZSBzYW1lLiBVc2VmdWwgd2hlbiBzZWFyY2hpbmcgZm9yIGFcbiAqIG1hcHBpbmcgd2l0aCBhIHN0dWJiZWQgb3V0IG1hcHBpbmcuXG4gKi9cbmZ1bmN0aW9uIGNvbXBhcmVCeUdlbmVyYXRlZFBvc2l0aW9uc0RlZmxhdGVkKG1hcHBpbmdBLCBtYXBwaW5nQiwgb25seUNvbXBhcmVHZW5lcmF0ZWQpIHtcbiAgdmFyIGNtcCA9IG1hcHBpbmdBLmdlbmVyYXRlZExpbmUgLSBtYXBwaW5nQi5nZW5lcmF0ZWRMaW5lO1xuICBpZiAoY21wICE9PSAwKSB7XG4gICAgcmV0dXJuIGNtcDtcbiAgfVxuXG4gIGNtcCA9IG1hcHBpbmdBLmdlbmVyYXRlZENvbHVtbiAtIG1hcHBpbmdCLmdlbmVyYXRlZENvbHVtbjtcbiAgaWYgKGNtcCAhPT0gMCB8fCBvbmx5Q29tcGFyZUdlbmVyYXRlZCkge1xuICAgIHJldHVybiBjbXA7XG4gIH1cblxuICBjbXAgPSBzdHJjbXAobWFwcGluZ0Euc291cmNlLCBtYXBwaW5nQi5zb3VyY2UpO1xuICBpZiAoY21wICE9PSAwKSB7XG4gICAgcmV0dXJuIGNtcDtcbiAgfVxuXG4gIGNtcCA9IG1hcHBpbmdBLm9yaWdpbmFsTGluZSAtIG1hcHBpbmdCLm9yaWdpbmFsTGluZTtcbiAgaWYgKGNtcCAhPT0gMCkge1xuICAgIHJldHVybiBjbXA7XG4gIH1cblxuICBjbXAgPSBtYXBwaW5nQS5vcmlnaW5hbENvbHVtbiAtIG1hcHBpbmdCLm9yaWdpbmFsQ29sdW1uO1xuICBpZiAoY21wICE9PSAwKSB7XG4gICAgcmV0dXJuIGNtcDtcbiAgfVxuXG4gIHJldHVybiBzdHJjbXAobWFwcGluZ0EubmFtZSwgbWFwcGluZ0IubmFtZSk7XG59XG5leHBvcnRzLmNvbXBhcmVCeUdlbmVyYXRlZFBvc2l0aW9uc0RlZmxhdGVkID0gY29tcGFyZUJ5R2VuZXJhdGVkUG9zaXRpb25zRGVmbGF0ZWQ7XG5cbmZ1bmN0aW9uIHN0cmNtcChhU3RyMSwgYVN0cjIpIHtcbiAgaWYgKGFTdHIxID09PSBhU3RyMikge1xuICAgIHJldHVybiAwO1xuICB9XG5cbiAgaWYgKGFTdHIxID09PSBudWxsKSB7XG4gICAgcmV0dXJuIDE7IC8vIGFTdHIyICE9PSBudWxsXG4gIH1cblxuICBpZiAoYVN0cjIgPT09IG51bGwpIHtcbiAgICByZXR1cm4gLTE7IC8vIGFTdHIxICE9PSBudWxsXG4gIH1cblxuICBpZiAoYVN0cjEgPiBhU3RyMikge1xuICAgIHJldHVybiAxO1xuICB9XG5cbiAgcmV0dXJuIC0xO1xufVxuXG4vKipcbiAqIENvbXBhcmF0b3IgYmV0d2VlbiB0d28gbWFwcGluZ3Mgd2l0aCBpbmZsYXRlZCBzb3VyY2UgYW5kIG5hbWUgc3RyaW5ncyB3aGVyZVxuICogdGhlIGdlbmVyYXRlZCBwb3NpdGlvbnMgYXJlIGNvbXBhcmVkLlxuICovXG5mdW5jdGlvbiBjb21wYXJlQnlHZW5lcmF0ZWRQb3NpdGlvbnNJbmZsYXRlZChtYXBwaW5nQSwgbWFwcGluZ0IpIHtcbiAgdmFyIGNtcCA9IG1hcHBpbmdBLmdlbmVyYXRlZExpbmUgLSBtYXBwaW5nQi5nZW5lcmF0ZWRMaW5lO1xuICBpZiAoY21wICE9PSAwKSB7XG4gICAgcmV0dXJuIGNtcDtcbiAgfVxuXG4gIGNtcCA9IG1hcHBpbmdBLmdlbmVyYXRlZENvbHVtbiAtIG1hcHBpbmdCLmdlbmVyYXRlZENvbHVtbjtcbiAgaWYgKGNtcCAhPT0gMCkge1xuICAgIHJldHVybiBjbXA7XG4gIH1cblxuICBjbXAgPSBzdHJjbXAobWFwcGluZ0Euc291cmNlLCBtYXBwaW5nQi5zb3VyY2UpO1xuICBpZiAoY21wICE9PSAwKSB7XG4gICAgcmV0dXJuIGNtcDtcbiAgfVxuXG4gIGNtcCA9IG1hcHBpbmdBLm9yaWdpbmFsTGluZSAtIG1hcHBpbmdCLm9yaWdpbmFsTGluZTtcbiAgaWYgKGNtcCAhPT0gMCkge1xuICAgIHJldHVybiBjbXA7XG4gIH1cblxuICBjbXAgPSBtYXBwaW5nQS5vcmlnaW5hbENvbHVtbiAtIG1hcHBpbmdCLm9yaWdpbmFsQ29sdW1uO1xuICBpZiAoY21wICE9PSAwKSB7XG4gICAgcmV0dXJuIGNtcDtcbiAgfVxuXG4gIHJldHVybiBzdHJjbXAobWFwcGluZ0EubmFtZSwgbWFwcGluZ0IubmFtZSk7XG59XG5leHBvcnRzLmNvbXBhcmVCeUdlbmVyYXRlZFBvc2l0aW9uc0luZmxhdGVkID0gY29tcGFyZUJ5R2VuZXJhdGVkUG9zaXRpb25zSW5mbGF0ZWQ7XG5cbi8qKlxuICogU3RyaXAgYW55IEpTT04gWFNTSSBhdm9pZGFuY2UgcHJlZml4IGZyb20gdGhlIHN0cmluZyAoYXMgZG9jdW1lbnRlZFxuICogaW4gdGhlIHNvdXJjZSBtYXBzIHNwZWNpZmljYXRpb24pLCBhbmQgdGhlbiBwYXJzZSB0aGUgc3RyaW5nIGFzXG4gKiBKU09OLlxuICovXG5mdW5jdGlvbiBwYXJzZVNvdXJjZU1hcElucHV0KHN0cikge1xuICByZXR1cm4gSlNPTi5wYXJzZShzdHIucmVwbGFjZSgvXlxcKV19J1teXFxuXSpcXG4vLCAnJykpO1xufVxuZXhwb3J0cy5wYXJzZVNvdXJjZU1hcElucHV0ID0gcGFyc2VTb3VyY2VNYXBJbnB1dDtcblxuLyoqXG4gKiBDb21wdXRlIHRoZSBVUkwgb2YgYSBzb3VyY2UgZ2l2ZW4gdGhlIHRoZSBzb3VyY2Ugcm9vdCwgdGhlIHNvdXJjZSdzXG4gKiBVUkwsIGFuZCB0aGUgc291cmNlIG1hcCdzIFVSTC5cbiAqL1xuZnVuY3Rpb24gY29tcHV0ZVNvdXJjZVVSTChzb3VyY2VSb290LCBzb3VyY2VVUkwsIHNvdXJjZU1hcFVSTCkge1xuICBzb3VyY2VVUkwgPSBzb3VyY2VVUkwgfHwgJyc7XG5cbiAgaWYgKHNvdXJjZVJvb3QpIHtcbiAgICAvLyBUaGlzIGZvbGxvd3Mgd2hhdCBDaHJvbWUgZG9lcy5cbiAgICBpZiAoc291cmNlUm9vdFtzb3VyY2VSb290Lmxlbmd0aCAtIDFdICE9PSAnLycgJiYgc291cmNlVVJMWzBdICE9PSAnLycpIHtcbiAgICAgIHNvdXJjZVJvb3QgKz0gJy8nO1xuICAgIH1cbiAgICAvLyBUaGUgc3BlYyBzYXlzOlxuICAgIC8vICAgTGluZSA0OiBBbiBvcHRpb25hbCBzb3VyY2Ugcm9vdCwgdXNlZnVsIGZvciByZWxvY2F0aW5nIHNvdXJjZVxuICAgIC8vICAgZmlsZXMgb24gYSBzZXJ2ZXIgb3IgcmVtb3ZpbmcgcmVwZWF0ZWQgdmFsdWVzIGluIHRoZVxuICAgIC8vICAg4oCcc291cmNlc+KAnSBlbnRyeS4gIFRoaXMgdmFsdWUgaXMgcHJlcGVuZGVkIHRvIHRoZSBpbmRpdmlkdWFsXG4gICAgLy8gICBlbnRyaWVzIGluIHRoZSDigJxzb3VyY2XigJ0gZmllbGQuXG4gICAgc291cmNlVVJMID0gc291cmNlUm9vdCArIHNvdXJjZVVSTDtcbiAgfVxuXG4gIC8vIEhpc3RvcmljYWxseSwgU291cmNlTWFwQ29uc3VtZXIgZGlkIG5vdCB0YWtlIHRoZSBzb3VyY2VNYXBVUkwgYXNcbiAgLy8gYSBwYXJhbWV0ZXIuICBUaGlzIG1vZGUgaXMgc3RpbGwgc29tZXdoYXQgc3VwcG9ydGVkLCB3aGljaCBpcyB3aHlcbiAgLy8gdGhpcyBjb2RlIGJsb2NrIGlzIGNvbmRpdGlvbmFsLiAgSG93ZXZlciwgaXQncyBwcmVmZXJhYmxlIHRvIHBhc3NcbiAgLy8gdGhlIHNvdXJjZSBtYXAgVVJMIHRvIFNvdXJjZU1hcENvbnN1bWVyLCBzbyB0aGF0IHRoaXMgZnVuY3Rpb25cbiAgLy8gY2FuIGltcGxlbWVudCB0aGUgc291cmNlIFVSTCByZXNvbHV0aW9uIGFsZ29yaXRobSBhcyBvdXRsaW5lZCBpblxuICAvLyB0aGUgc3BlYy4gIFRoaXMgYmxvY2sgaXMgYmFzaWNhbGx5IHRoZSBlcXVpdmFsZW50IG9mOlxuICAvLyAgICBuZXcgVVJMKHNvdXJjZVVSTCwgc291cmNlTWFwVVJMKS50b1N0cmluZygpXG4gIC8vIC4uLiBleGNlcHQgaXQgYXZvaWRzIHVzaW5nIFVSTCwgd2hpY2ggd2Fzbid0IGF2YWlsYWJsZSBpbiB0aGVcbiAgLy8gb2xkZXIgcmVsZWFzZXMgb2Ygbm9kZSBzdGlsbCBzdXBwb3J0ZWQgYnkgdGhpcyBsaWJyYXJ5LlxuICAvL1xuICAvLyBUaGUgc3BlYyBzYXlzOlxuICAvLyAgIElmIHRoZSBzb3VyY2VzIGFyZSBub3QgYWJzb2x1dGUgVVJMcyBhZnRlciBwcmVwZW5kaW5nIG9mIHRoZVxuICAvLyAgIOKAnHNvdXJjZVJvb3TigJ0sIHRoZSBzb3VyY2VzIGFyZSByZXNvbHZlZCByZWxhdGl2ZSB0byB0aGVcbiAgLy8gICBTb3VyY2VNYXAgKGxpa2UgcmVzb2x2aW5nIHNjcmlwdCBzcmMgaW4gYSBodG1sIGRvY3VtZW50KS5cbiAgaWYgKHNvdXJjZU1hcFVSTCkge1xuICAgIHZhciBwYXJzZWQgPSB1cmxQYXJzZShzb3VyY2VNYXBVUkwpO1xuICAgIGlmICghcGFyc2VkKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJzb3VyY2VNYXBVUkwgY291bGQgbm90IGJlIHBhcnNlZFwiKTtcbiAgICB9XG4gICAgaWYgKHBhcnNlZC5wYXRoKSB7XG4gICAgICAvLyBTdHJpcCB0aGUgbGFzdCBwYXRoIGNvbXBvbmVudCwgYnV0IGtlZXAgdGhlIFwiL1wiLlxuICAgICAgdmFyIGluZGV4ID0gcGFyc2VkLnBhdGgubGFzdEluZGV4T2YoJy8nKTtcbiAgICAgIGlmIChpbmRleCA+PSAwKSB7XG4gICAgICAgIHBhcnNlZC5wYXRoID0gcGFyc2VkLnBhdGguc3Vic3RyaW5nKDAsIGluZGV4ICsgMSk7XG4gICAgICB9XG4gICAgfVxuICAgIHNvdXJjZVVSTCA9IGpvaW4odXJsR2VuZXJhdGUocGFyc2VkKSwgc291cmNlVVJMKTtcbiAgfVxuXG4gIHJldHVybiBub3JtYWxpemUoc291cmNlVVJMKTtcbn1cbmV4cG9ydHMuY29tcHV0ZVNvdXJjZVVSTCA9IGNvbXB1dGVTb3VyY2VVUkw7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvZWxlY3Ryb24tdXBkYXRlci9ub2RlX21vZHVsZXMvc291cmNlLW1hcC9saWIvdXRpbC5qcyIsIid1c2Ugc3RyaWN0J1xuXG5jb25zdCB1ID0gcmVxdWlyZSgndW5pdmVyc2FsaWZ5JykuZnJvbUNhbGxiYWNrXG5jb25zdCByaW1yYWYgPSByZXF1aXJlKCcuL3JpbXJhZicpXG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICByZW1vdmU6IHUocmltcmFmKSxcbiAgcmVtb3ZlU3luYzogcmltcmFmLnN5bmNcbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9lbGVjdHJvbi11cGRhdGVyL25vZGVfbW9kdWxlcy9mcy1leHRyYS9saWIvcmVtb3ZlL2luZGV4LmpzIiwiLy8gSlMtWUFNTCdzIGRlZmF1bHQgc2NoZW1hIGZvciBgbG9hZGAgZnVuY3Rpb24uXG4vLyBJdCBpcyBub3QgZGVzY3JpYmVkIGluIHRoZSBZQU1MIHNwZWNpZmljYXRpb24uXG4vL1xuLy8gVGhpcyBzY2hlbWEgaXMgYmFzZWQgb24gSlMtWUFNTCdzIGRlZmF1bHQgc2FmZSBzY2hlbWEgYW5kIGluY2x1ZGVzXG4vLyBKYXZhU2NyaXB0LXNwZWNpZmljIHR5cGVzOiAhIWpzL3VuZGVmaW5lZCwgISFqcy9yZWdleHAgYW5kICEhanMvZnVuY3Rpb24uXG4vL1xuLy8gQWxzbyB0aGlzIHNjaGVtYSBpcyB1c2VkIGFzIGRlZmF1bHQgYmFzZSBzY2hlbWEgYXQgYFNjaGVtYS5jcmVhdGVgIGZ1bmN0aW9uLlxuXG5cbid1c2Ugc3RyaWN0JztcblxuXG52YXIgU2NoZW1hID0gcmVxdWlyZSgnLi4vc2NoZW1hJyk7XG5cblxubW9kdWxlLmV4cG9ydHMgPSBTY2hlbWEuREVGQVVMVCA9IG5ldyBTY2hlbWEoe1xuICBpbmNsdWRlOiBbXG4gICAgcmVxdWlyZSgnLi9kZWZhdWx0X3NhZmUnKVxuICBdLFxuICBleHBsaWNpdDogW1xuICAgIHJlcXVpcmUoJy4uL3R5cGUvanMvdW5kZWZpbmVkJyksXG4gICAgcmVxdWlyZSgnLi4vdHlwZS9qcy9yZWdleHAnKSxcbiAgICByZXF1aXJlKCcuLi90eXBlL2pzL2Z1bmN0aW9uJylcbiAgXVxufSk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvanMteWFtbC9saWIvanMteWFtbC9zY2hlbWEvZGVmYXVsdF9mdWxsLmpzIiwiJ3VzZSBzdHJpY3QnO1xuY29uc3QgZ2V0RnJvbUVudiA9IHBhcnNlSW50KHByb2Nlc3MuZW52LkVMRUNUUk9OX0lTX0RFViwgMTApID09PSAxO1xuY29uc3QgaXNFbnZTZXQgPSAnRUxFQ1RST05fSVNfREVWJyBpbiBwcm9jZXNzLmVudjtcblxubW9kdWxlLmV4cG9ydHMgPSBpc0VudlNldCA/IGdldEZyb21FbnYgOiAocHJvY2Vzcy5kZWZhdWx0QXBwIHx8IC9ub2RlX21vZHVsZXNbXFxcXC9dZWxlY3Ryb25bXFxcXC9dLy50ZXN0KHByb2Nlc3MuZXhlY1BhdGgpKTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9lbGVjdHJvbi1pcy1kZXYvaW5kZXguanMiLCJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5Ob09wTG9nZ2VyID0gZXhwb3J0cy5BcHBVcGRhdGVyID0gdW5kZWZpbmVkO1xuXG52YXIgX2JsdWViaXJkTHN0O1xuXG5mdW5jdGlvbiBfbG9hZF9ibHVlYmlyZExzdCgpIHtcbiAgICByZXR1cm4gX2JsdWViaXJkTHN0ID0gcmVxdWlyZShcImJsdWViaXJkLWxzdFwiKTtcbn1cblxudmFyIF9ibHVlYmlyZExzdDI7XG5cbmZ1bmN0aW9uIF9sb2FkX2JsdWViaXJkTHN0MigpIHtcbiAgICByZXR1cm4gX2JsdWViaXJkTHN0MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcImJsdWViaXJkLWxzdFwiKSk7XG59XG5cbnZhciBfYnVpbGRlclV0aWxSdW50aW1lO1xuXG5mdW5jdGlvbiBfbG9hZF9idWlsZGVyVXRpbFJ1bnRpbWUoKSB7XG4gICAgcmV0dXJuIF9idWlsZGVyVXRpbFJ1bnRpbWUgPSByZXF1aXJlKFwiYnVpbGRlci11dGlsLXJ1bnRpbWVcIik7XG59XG5cbnZhciBfY3J5cHRvO1xuXG5mdW5jdGlvbiBfbG9hZF9jcnlwdG8oKSB7XG4gICAgcmV0dXJuIF9jcnlwdG8gPSByZXF1aXJlKFwiY3J5cHRvXCIpO1xufVxuXG52YXIgX2VsZWN0cm9uO1xuXG5mdW5jdGlvbiBfbG9hZF9lbGVjdHJvbigpIHtcbiAgICByZXR1cm4gX2VsZWN0cm9uID0gcmVxdWlyZShcImVsZWN0cm9uXCIpO1xufVxuXG52YXIgX2VsZWN0cm9uSXNEZXY7XG5cbmZ1bmN0aW9uIF9sb2FkX2VsZWN0cm9uSXNEZXYoKSB7XG4gICAgcmV0dXJuIF9lbGVjdHJvbklzRGV2ID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiZWxlY3Ryb24taXMtZGV2XCIpKTtcbn1cblxudmFyIF9ldmVudHM7XG5cbmZ1bmN0aW9uIF9sb2FkX2V2ZW50cygpIHtcbiAgICByZXR1cm4gX2V2ZW50cyA9IHJlcXVpcmUoXCJldmVudHNcIik7XG59XG5cbnZhciBfZnNFeHRyYVA7XG5cbmZ1bmN0aW9uIF9sb2FkX2ZzRXh0cmFQKCkge1xuICAgIHJldHVybiBfZnNFeHRyYVAgPSByZXF1aXJlKFwiZnMtZXh0cmEtcFwiKTtcbn1cblxudmFyIF9qc1lhbWw7XG5cbmZ1bmN0aW9uIF9sb2FkX2pzWWFtbCgpIHtcbiAgICByZXR1cm4gX2pzWWFtbCA9IHJlcXVpcmUoXCJqcy15YW1sXCIpO1xufVxuXG52YXIgX2xhenlWYWw7XG5cbmZ1bmN0aW9uIF9sb2FkX2xhenlWYWwoKSB7XG4gICAgcmV0dXJuIF9sYXp5VmFsID0gcmVxdWlyZShcImxhenktdmFsXCIpO1xufVxuXG52YXIgX3BhdGggPSBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChyZXF1aXJlKFwicGF0aFwiKSk7XG5cbnZhciBfc2VtdmVyO1xuXG5mdW5jdGlvbiBfbG9hZF9zZW12ZXIoKSB7XG4gICAgcmV0dXJuIF9zZW12ZXIgPSByZXF1aXJlKFwic2VtdmVyXCIpO1xufVxuXG5yZXF1aXJlKFwic291cmNlLW1hcC1zdXBwb3J0L3JlZ2lzdGVyXCIpO1xuXG52YXIgX2VsZWN0cm9uSHR0cEV4ZWN1dG9yO1xuXG5mdW5jdGlvbiBfbG9hZF9lbGVjdHJvbkh0dHBFeGVjdXRvcigpIHtcbiAgICByZXR1cm4gX2VsZWN0cm9uSHR0cEV4ZWN1dG9yID0gcmVxdWlyZShcIi4vZWxlY3Ryb25IdHRwRXhlY3V0b3JcIik7XG59XG5cbnZhciBfR2VuZXJpY1Byb3ZpZGVyO1xuXG5mdW5jdGlvbiBfbG9hZF9HZW5lcmljUHJvdmlkZXIoKSB7XG4gICAgcmV0dXJuIF9HZW5lcmljUHJvdmlkZXIgPSByZXF1aXJlKFwiLi9HZW5lcmljUHJvdmlkZXJcIik7XG59XG5cbnZhciBfbWFpbjtcblxuZnVuY3Rpb24gX2xvYWRfbWFpbigpIHtcbiAgICByZXR1cm4gX21haW4gPSByZXF1aXJlKFwiLi9tYWluXCIpO1xufVxuXG52YXIgX3Byb3ZpZGVyRmFjdG9yeTtcblxuZnVuY3Rpb24gX2xvYWRfcHJvdmlkZXJGYWN0b3J5KCkge1xuICAgIHJldHVybiBfcHJvdmlkZXJGYWN0b3J5ID0gcmVxdWlyZShcIi4vcHJvdmlkZXJGYWN0b3J5XCIpO1xufVxuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChvYmopIHsgaWYgKG9iaiAmJiBvYmouX19lc01vZHVsZSkgeyByZXR1cm4gb2JqOyB9IGVsc2UgeyB2YXIgbmV3T2JqID0ge307IGlmIChvYmogIT0gbnVsbCkgeyBmb3IgKHZhciBrZXkgaW4gb2JqKSB7IGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBrZXkpKSBuZXdPYmpba2V5XSA9IG9ialtrZXldOyB9IH0gbmV3T2JqLmRlZmF1bHQgPSBvYmo7IHJldHVybiBuZXdPYmo7IH0gfVxuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5jbGFzcyBBcHBVcGRhdGVyIGV4dGVuZHMgKF9ldmVudHMgfHwgX2xvYWRfZXZlbnRzKCkpLkV2ZW50RW1pdHRlciB7XG4gICAgY29uc3RydWN0b3Iob3B0aW9ucywgYXBwKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBXaGV0aGVyIHRvIGF1dG9tYXRpY2FsbHkgZG93bmxvYWQgYW4gdXBkYXRlIHdoZW4gaXQgaXMgZm91bmQuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmF1dG9Eb3dubG9hZCA9IHRydWU7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiAqR2l0SHViIHByb3ZpZGVyIG9ubHkuKiBXaGV0aGVyIHRvIGFsbG93IHVwZGF0ZSB0byBwcmUtcmVsZWFzZSB2ZXJzaW9ucy4gRGVmYXVsdHMgdG8gYHRydWVgIGlmIGFwcGxpY2F0aW9uIHZlcnNpb24gY29udGFpbnMgcHJlcmVsZWFzZSBjb21wb25lbnRzIChlLmcuIGAwLjEyLjEtYWxwaGEuMWAsIGhlcmUgYGFscGhhYCBpcyBhIHByZXJlbGVhc2UgY29tcG9uZW50KSwgb3RoZXJ3aXNlIGBmYWxzZWAuXG4gICAgICAgICAqXG4gICAgICAgICAqIElmIGB0cnVlYCwgZG93bmdyYWRlIHdpbGwgYmUgYWxsb3dlZCAoYGFsbG93RG93bmdyYWRlYCB3aWxsIGJlIHNldCB0byBgdHJ1ZWApLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5hbGxvd1ByZXJlbGVhc2UgPSBmYWxzZTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqICpHaXRIdWIgcHJvdmlkZXIgb25seS4qIEdldCBhbGwgcmVsZWFzZSBub3RlcyAoZnJvbSBjdXJyZW50IHZlcnNpb24gdG8gbGF0ZXN0KSwgbm90IGp1c3QgdGhlIGxhdGVzdC5cbiAgICAgICAgICogQGRlZmF1bHQgZmFsc2VcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuZnVsbENoYW5nZWxvZyA9IGZhbHNlO1xuICAgICAgICAvKipcbiAgICAgICAgICogV2hldGhlciB0byBhbGxvdyB2ZXJzaW9uIGRvd25ncmFkZSAod2hlbiBhIHVzZXIgZnJvbSB0aGUgYmV0YSBjaGFubmVsIHdhbnRzIHRvIGdvIGJhY2sgdG8gdGhlIHN0YWJsZSBjaGFubmVsKS5cbiAgICAgICAgICogQGRlZmF1bHQgZmFsc2VcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuYWxsb3dEb3duZ3JhZGUgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5fY2hhbm5lbCA9IG51bGw7XG4gICAgICAgIHRoaXMuX2xvZ2dlciA9IGNvbnNvbGU7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBGb3IgdHlwZSBzYWZldHkgeW91IGNhbiB1c2Ugc2lnbmFscywgZS5nLiBgYXV0b1VwZGF0ZXIuc2lnbmFscy51cGRhdGVEb3dubG9hZGVkKCgpID0+IHt9KWAgaW5zdGVhZCBvZiBgYXV0b1VwZGF0ZXIub24oJ3VwZGF0ZS1hdmFpbGFibGUnLCAoKSA9PiB7fSlgXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnNpZ25hbHMgPSBuZXcgKF9tYWluIHx8IF9sb2FkX21haW4oKSkuVXBkYXRlclNpZ25hbCh0aGlzKTtcbiAgICAgICAgdGhpcy51cGRhdGVBdmFpbGFibGUgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5zdGFnaW5nVXNlcklkUHJvbWlzZSA9IG5ldyAoX2xhenlWYWwgfHwgX2xvYWRfbGF6eVZhbCgpKS5MYXp5KCgpID0+IHRoaXMuZ2V0T3JDcmVhdGVTdGFnaW5nVXNlcklkKCkpO1xuICAgICAgICAvLyBwdWJsaWMsIGFsbG93IHRvIHJlYWQgb2xkIGNvbmZpZyBmb3IgYW55b25lXG4gICAgICAgIHRoaXMuY29uZmlnT25EaXNrID0gbmV3IChfbGF6eVZhbCB8fCBfbG9hZF9sYXp5VmFsKCkpLkxhenkoKCkgPT4gdGhpcy5sb2FkVXBkYXRlQ29uZmlnKCkpO1xuICAgICAgICB0aGlzLm9uKFwiZXJyb3JcIiwgZXJyb3IgPT4ge1xuICAgICAgICAgICAgdGhpcy5fbG9nZ2VyLmVycm9yKGBFcnJvcjogJHtlcnJvci5zdGFjayB8fCBlcnJvci5tZXNzYWdlfWApO1xuICAgICAgICB9KTtcbiAgICAgICAgaWYgKGFwcCAhPSBudWxsIHx8IGdsb2JhbC5fX3Rlc3RfYXBwICE9IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuYXBwID0gYXBwIHx8IGdsb2JhbC5fX3Rlc3RfYXBwO1xuICAgICAgICAgICAgdGhpcy51bnRpbEFwcFJlYWR5ID0gKF9ibHVlYmlyZExzdDIgfHwgX2xvYWRfYmx1ZWJpcmRMc3QyKCkpLmRlZmF1bHQucmVzb2x2ZSgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5hcHAgPSByZXF1aXJlKFwiZWxlY3Ryb25cIikuYXBwO1xuICAgICAgICAgICAgdGhpcy5odHRwRXhlY3V0b3IgPSBuZXcgKF9lbGVjdHJvbkh0dHBFeGVjdXRvciB8fCBfbG9hZF9lbGVjdHJvbkh0dHBFeGVjdXRvcigpKS5FbGVjdHJvbkh0dHBFeGVjdXRvcigoYXV0aEluZm8sIGNhbGxiYWNrKSA9PiB0aGlzLmVtaXQoXCJsb2dpblwiLCBhdXRoSW5mbywgY2FsbGJhY2spKTtcbiAgICAgICAgICAgIHRoaXMudW50aWxBcHBSZWFkeSA9IG5ldyAoX2JsdWViaXJkTHN0MiB8fCBfbG9hZF9ibHVlYmlyZExzdDIoKSkuZGVmYXVsdChyZXNvbHZlID0+IHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5hcHAuaXNSZWFkeSgpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmUoKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmFwcC5vbihcInJlYWR5XCIsIHJlc29sdmUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGN1cnJlbnRWZXJzaW9uU3RyaW5nID0gdGhpcy5hcHAuZ2V0VmVyc2lvbigpO1xuICAgICAgICBjb25zdCBjdXJyZW50VmVyc2lvbiA9ICgwLCAoX3NlbXZlciB8fCBfbG9hZF9zZW12ZXIoKSkudmFsaWQpKGN1cnJlbnRWZXJzaW9uU3RyaW5nKTtcbiAgICAgICAgaWYgKGN1cnJlbnRWZXJzaW9uID09IG51bGwpIHtcbiAgICAgICAgICAgIHRocm93ICgwLCAoX2J1aWxkZXJVdGlsUnVudGltZSB8fCBfbG9hZF9idWlsZGVyVXRpbFJ1bnRpbWUoKSkubmV3RXJyb3IpKGBBcHAgdmVyc2lvbiBpcyBub3QgYSB2YWxpZCBzZW12ZXIgdmVyc2lvbjogXCIke2N1cnJlbnRWZXJzaW9uU3RyaW5nfWAsIFwiRVJSX1VQREFURVJfSU5WQUxJRF9WRVJTSU9OXCIpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuY3VycmVudFZlcnNpb24gPSBjdXJyZW50VmVyc2lvbjtcbiAgICAgICAgdGhpcy5hbGxvd1ByZXJlbGVhc2UgPSBoYXNQcmVyZWxlYXNlQ29tcG9uZW50cyh0aGlzLmN1cnJlbnRWZXJzaW9uKTtcbiAgICAgICAgaWYgKG9wdGlvbnMgIT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5zZXRGZWVkVVJMKG9wdGlvbnMpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgdXBkYXRlIGNoYW5uZWwuIE5vdCBhcHBsaWNhYmxlIGZvciBHaXRIdWIuIERvZXNuJ3QgcmV0dXJuIGBjaGFubmVsYCBmcm9tIHRoZSB1cGRhdGUgY29uZmlndXJhdGlvbiwgb25seSBpZiB3YXMgcHJldmlvdXNseSBzZXQuXG4gICAgICovXG4gICAgZ2V0IGNoYW5uZWwoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9jaGFubmVsO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXQgdGhlIHVwZGF0ZSBjaGFubmVsLiBOb3QgYXBwbGljYWJsZSBmb3IgR2l0SHViLiBPdmVycmlkZXMgYGNoYW5uZWxgIGluIHRoZSB1cGRhdGUgY29uZmlndXJhdGlvbi5cbiAgICAgKlxuICAgICAqIGBhbGxvd0Rvd25ncmFkZWAgd2lsbCBiZSBhdXRvbWF0aWNhbGx5IHNldCB0byBgdHJ1ZWAuIElmIHRoaXMgYmVoYXZpb3IgaXMgbm90IHN1aXRhYmxlIGZvciB5b3UsIHNpbXBsZSBzZXQgYGFsbG93RG93bmdyYWRlYCBleHBsaWNpdGx5IGFmdGVyLlxuICAgICAqL1xuICAgIHNldCBjaGFubmVsKHZhbHVlKSB7XG4gICAgICAgIGlmICh0aGlzLl9jaGFubmVsICE9IG51bGwpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgIT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyAoMCwgKF9idWlsZGVyVXRpbFJ1bnRpbWUgfHwgX2xvYWRfYnVpbGRlclV0aWxSdW50aW1lKCkpLm5ld0Vycm9yKShgQ2hhbm5lbCBtdXN0IGJlIGEgc3RyaW5nLCBidXQgZ290OiAke3ZhbHVlfWAsIFwiRVJSX1VQREFURVJfSU5WQUxJRF9DSEFOTkVMXCIpO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh2YWx1ZS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICB0aHJvdyAoMCwgKF9idWlsZGVyVXRpbFJ1bnRpbWUgfHwgX2xvYWRfYnVpbGRlclV0aWxSdW50aW1lKCkpLm5ld0Vycm9yKShgQ2hhbm5lbCBtdXN0IGJlIG5vdCBhbiBlbXB0eSBzdHJpbmdgLCBcIkVSUl9VUERBVEVSX0lOVkFMSURfQ0hBTk5FTFwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9jaGFubmVsID0gdmFsdWU7XG4gICAgICAgIHRoaXMuYWxsb3dEb3duZ3JhZGUgPSB0cnVlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUaGUgbG9nZ2VyLiBZb3UgY2FuIHBhc3MgW2VsZWN0cm9uLWxvZ10oaHR0cHM6Ly9naXRodWIuY29tL21lZ2FoZXJ0ei9lbGVjdHJvbi1sb2cpLCBbd2luc3Rvbl0oaHR0cHM6Ly9naXRodWIuY29tL3dpbnN0b25qcy93aW5zdG9uKSBvciBhbm90aGVyIGxvZ2dlciB3aXRoIHRoZSBmb2xsb3dpbmcgaW50ZXJmYWNlOiBgeyBpbmZvKCksIHdhcm4oKSwgZXJyb3IoKSB9YC5cbiAgICAgKiBTZXQgaXQgdG8gYG51bGxgIGlmIHlvdSB3b3VsZCBsaWtlIHRvIGRpc2FibGUgYSBsb2dnaW5nIGZlYXR1cmUuXG4gICAgICovXG4gICAgZ2V0IGxvZ2dlcigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2xvZ2dlcjtcbiAgICB9XG4gICAgc2V0IGxvZ2dlcih2YWx1ZSkge1xuICAgICAgICB0aGlzLl9sb2dnZXIgPSB2YWx1ZSA9PSBudWxsID8gbmV3IE5vT3BMb2dnZXIoKSA6IHZhbHVlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiB0ZXN0IG9ubHlcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHNldCB1cGRhdGVDb25maWdQYXRoKHZhbHVlKSB7XG4gICAgICAgIHRoaXMuY2xpZW50UHJvbWlzZSA9IG51bGw7XG4gICAgICAgIHRoaXMuX2FwcFVwZGF0ZUNvbmZpZ1BhdGggPSB2YWx1ZTtcbiAgICAgICAgdGhpcy5jb25maWdPbkRpc2sgPSBuZXcgKF9sYXp5VmFsIHx8IF9sb2FkX2xhenlWYWwoKSkuTGF6eSgoKSA9PiB0aGlzLmxvYWRVcGRhdGVDb25maWcoKSk7XG4gICAgfVxuICAgIGdldCBwcm92aWRlcigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2xpZW50UHJvbWlzZTtcbiAgICB9XG4gICAgLy9ub2luc3BlY3Rpb24gSlNNZXRob2RDYW5CZVN0YXRpYyxKU1VudXNlZEdsb2JhbFN5bWJvbHNcbiAgICBnZXRGZWVkVVJMKCkge1xuICAgICAgICByZXR1cm4gXCJEZXByZWNhdGVkLiBEbyBub3QgdXNlIGl0LlwiO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDb25maWd1cmUgdXBkYXRlIHByb3ZpZGVyLiBJZiB2YWx1ZSBpcyBgc3RyaW5nYCwgW0dlbmVyaWNTZXJ2ZXJPcHRpb25zXSgvY29uZmlndXJhdGlvbi9wdWJsaXNoLm1kI2dlbmVyaWNzZXJ2ZXJvcHRpb25zKSB3aWxsIGJlIHNldCB3aXRoIHZhbHVlIGFzIGB1cmxgLlxuICAgICAqIEBwYXJhbSBvcHRpb25zIElmIHlvdSB3YW50IHRvIG92ZXJyaWRlIGNvbmZpZ3VyYXRpb24gaW4gdGhlIGBhcHAtdXBkYXRlLnltbGAuXG4gICAgICovXG4gICAgc2V0RmVlZFVSTChvcHRpb25zKSB7XG4gICAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9lbGVjdHJvbi11c2VybGFuZC9lbGVjdHJvbi1idWlsZGVyL2lzc3Vlcy8xMTA1XG4gICAgICAgIGxldCBwcm92aWRlcjtcbiAgICAgICAgaWYgKHR5cGVvZiBvcHRpb25zID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICBwcm92aWRlciA9IG5ldyAoX0dlbmVyaWNQcm92aWRlciB8fCBfbG9hZF9HZW5lcmljUHJvdmlkZXIoKSkuR2VuZXJpY1Byb3ZpZGVyKHsgcHJvdmlkZXI6IFwiZ2VuZXJpY1wiLCB1cmw6IG9wdGlvbnMgfSwgdGhpcyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBwcm92aWRlciA9ICgwLCAoX3Byb3ZpZGVyRmFjdG9yeSB8fCBfbG9hZF9wcm92aWRlckZhY3RvcnkoKSkuY3JlYXRlQ2xpZW50KShvcHRpb25zLCB0aGlzKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmNsaWVudFByb21pc2UgPSBQcm9taXNlLnJlc29sdmUocHJvdmlkZXIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBc2tzIHRoZSBzZXJ2ZXIgd2hldGhlciB0aGVyZSBpcyBhbiB1cGRhdGUuXG4gICAgICovXG4gICAgY2hlY2tGb3JVcGRhdGVzKCkge1xuICAgICAgICBsZXQgY2hlY2tGb3JVcGRhdGVzUHJvbWlzZSA9IHRoaXMuY2hlY2tGb3JVcGRhdGVzUHJvbWlzZTtcbiAgICAgICAgaWYgKGNoZWNrRm9yVXBkYXRlc1Byb21pc2UgIT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIGNoZWNrRm9yVXBkYXRlc1Byb21pc2U7XG4gICAgICAgIH1cbiAgICAgICAgY2hlY2tGb3JVcGRhdGVzUHJvbWlzZSA9IHRoaXMuX2NoZWNrRm9yVXBkYXRlcygpO1xuICAgICAgICB0aGlzLmNoZWNrRm9yVXBkYXRlc1Byb21pc2UgPSBjaGVja0ZvclVwZGF0ZXNQcm9taXNlO1xuICAgICAgICBjb25zdCBudWxsaXplUHJvbWlzZSA9ICgpID0+IHRoaXMuY2hlY2tGb3JVcGRhdGVzUHJvbWlzZSA9IG51bGw7XG4gICAgICAgIGNoZWNrRm9yVXBkYXRlc1Byb21pc2UudGhlbihudWxsaXplUHJvbWlzZSkuY2F0Y2gobnVsbGl6ZVByb21pc2UpO1xuICAgICAgICByZXR1cm4gY2hlY2tGb3JVcGRhdGVzUHJvbWlzZTtcbiAgICB9XG4gICAgY2hlY2tGb3JVcGRhdGVzQW5kTm90aWZ5KCkge1xuICAgICAgICBpZiAoKF9lbGVjdHJvbklzRGV2IHx8IF9sb2FkX2VsZWN0cm9uSXNEZXYoKSkuZGVmYXVsdCkge1xuICAgICAgICAgICAgcmV0dXJuIChfYmx1ZWJpcmRMc3QyIHx8IF9sb2FkX2JsdWViaXJkTHN0MigpKS5kZWZhdWx0LnJlc29sdmUobnVsbCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zaWduYWxzLnVwZGF0ZURvd25sb2FkZWQoaXQgPT4ge1xuICAgICAgICAgICAgbmV3IChfZWxlY3Ryb24gfHwgX2xvYWRfZWxlY3Ryb24oKSkuTm90aWZpY2F0aW9uKHtcbiAgICAgICAgICAgICAgICB0aXRsZTogXCJBIG5ldyB1cGRhdGUgaXMgcmVhZHkgdG8gaW5zdGFsbFwiLFxuICAgICAgICAgICAgICAgIGJvZHk6IGAke3RoaXMuYXBwLmdldE5hbWUoKX0gdmVyc2lvbiAke2l0LnZlcnNpb259IGlzIGRvd25sb2FkZWQgYW5kIHdpbGwgYmUgYXV0b21hdGljYWxseSBpbnN0YWxsZWQgb24gZXhpdGBcbiAgICAgICAgICAgIH0pLnNob3coKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB0aGlzLmNoZWNrRm9yVXBkYXRlcygpO1xuICAgIH1cbiAgICBpc1N0YWdpbmdNYXRjaCh1cGRhdGVJbmZvKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICAgICAgcmV0dXJuICgwLCAoX2JsdWViaXJkTHN0IHx8IF9sb2FkX2JsdWViaXJkTHN0KCkpLmNvcm91dGluZSkoZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGNvbnN0IHJhd1N0YWdpbmdQZXJjZW50YWdlID0gdXBkYXRlSW5mby5zdGFnaW5nUGVyY2VudGFnZTtcbiAgICAgICAgICAgIGxldCBzdGFnaW5nUGVyY2VudGFnZSA9IHJhd1N0YWdpbmdQZXJjZW50YWdlO1xuICAgICAgICAgICAgaWYgKHN0YWdpbmdQZXJjZW50YWdlID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHN0YWdpbmdQZXJjZW50YWdlID0gcGFyc2VJbnQoc3RhZ2luZ1BlcmNlbnRhZ2UsIDEwKTtcbiAgICAgICAgICAgIGlmIChpc05hTihzdGFnaW5nUGVyY2VudGFnZSkpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5fbG9nZ2VyLndhcm4oYFN0YWdpbmcgcGVyY2VudGFnZSBpcyBOYU46ICR7cmF3U3RhZ2luZ1BlcmNlbnRhZ2V9YCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBjb252ZXJ0IGZyb20gdXNlciAwLTEwMCB0byBpbnRlcm5hbCAwLTFcbiAgICAgICAgICAgIHN0YWdpbmdQZXJjZW50YWdlID0gc3RhZ2luZ1BlcmNlbnRhZ2UgLyAxMDA7XG4gICAgICAgICAgICBjb25zdCBzdGFnaW5nVXNlcklkID0geWllbGQgX3RoaXMuc3RhZ2luZ1VzZXJJZFByb21pc2UudmFsdWU7XG4gICAgICAgICAgICBjb25zdCB2YWwgPSAoX2J1aWxkZXJVdGlsUnVudGltZSB8fCBfbG9hZF9idWlsZGVyVXRpbFJ1bnRpbWUoKSkuVVVJRC5wYXJzZShzdGFnaW5nVXNlcklkKS5yZWFkVUludDMyQkUoMTIpO1xuICAgICAgICAgICAgY29uc3QgcGVyY2VudGFnZSA9IHZhbCAvIDB4RkZGRkZGRkY7XG4gICAgICAgICAgICBfdGhpcy5fbG9nZ2VyLmluZm8oYFN0YWdpbmcgcGVyY2VudGFnZTogJHtzdGFnaW5nUGVyY2VudGFnZX0sIHBlcmNlbnRhZ2U6ICR7cGVyY2VudGFnZX0sIHVzZXIgaWQ6ICR7c3RhZ2luZ1VzZXJJZH1gKTtcbiAgICAgICAgICAgIHJldHVybiBwZXJjZW50YWdlIDwgc3RhZ2luZ1BlcmNlbnRhZ2U7XG4gICAgICAgIH0pKCk7XG4gICAgfVxuICAgIF9jaGVja0ZvclVwZGF0ZXMoKSB7XG4gICAgICAgIHZhciBfdGhpczIgPSB0aGlzO1xuXG4gICAgICAgIHJldHVybiAoMCwgKF9ibHVlYmlyZExzdCB8fCBfbG9hZF9ibHVlYmlyZExzdCgpKS5jb3JvdXRpbmUpKGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHlpZWxkIF90aGlzMi51bnRpbEFwcFJlYWR5O1xuICAgICAgICAgICAgICAgIF90aGlzMi5fbG9nZ2VyLmluZm8oXCJDaGVja2luZyBmb3IgdXBkYXRlXCIpO1xuICAgICAgICAgICAgICAgIF90aGlzMi5lbWl0KFwiY2hlY2tpbmctZm9yLXVwZGF0ZVwiKTtcbiAgICAgICAgICAgICAgICByZXR1cm4geWllbGQgX3RoaXMyLmRvQ2hlY2tGb3JVcGRhdGVzKCk7XG4gICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMyLmVtaXQoXCJlcnJvclwiLCBlLCBgQ2Fubm90IGNoZWNrIGZvciB1cGRhdGVzOiAkeyhlLnN0YWNrIHx8IGUpLnRvU3RyaW5nKCl9YCk7XG4gICAgICAgICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSkoKTtcbiAgICB9XG4gICAgY29tcHV0ZUZpbmFsSGVhZGVycyhoZWFkZXJzKSB7XG4gICAgICAgIGlmICh0aGlzLnJlcXVlc3RIZWFkZXJzICE9IG51bGwpIHtcbiAgICAgICAgICAgIE9iamVjdC5hc3NpZ24oaGVhZGVycywgdGhpcy5yZXF1ZXN0SGVhZGVycyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGhlYWRlcnM7XG4gICAgfVxuICAgIGRvQ2hlY2tGb3JVcGRhdGVzKCkge1xuICAgICAgICB2YXIgX3RoaXMzID0gdGhpcztcblxuICAgICAgICByZXR1cm4gKDAsIChfYmx1ZWJpcmRMc3QgfHwgX2xvYWRfYmx1ZWJpcmRMc3QoKSkuY29yb3V0aW5lKShmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgaWYgKF90aGlzMy5jbGllbnRQcm9taXNlID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBfdGhpczMuY2xpZW50UHJvbWlzZSA9IF90aGlzMy5jb25maWdPbkRpc2sudmFsdWUudGhlbihmdW5jdGlvbiAoaXQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICgwLCAoX3Byb3ZpZGVyRmFjdG9yeSB8fCBfbG9hZF9wcm92aWRlckZhY3RvcnkoKSkuY3JlYXRlQ2xpZW50KShpdCwgX3RoaXMzKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGNsaWVudCA9IHlpZWxkIF90aGlzMy5jbGllbnRQcm9taXNlO1xuICAgICAgICAgICAgY29uc3Qgc3RhZ2luZ1VzZXJJZCA9IHlpZWxkIF90aGlzMy5zdGFnaW5nVXNlcklkUHJvbWlzZS52YWx1ZTtcbiAgICAgICAgICAgIGNsaWVudC5zZXRSZXF1ZXN0SGVhZGVycyhfdGhpczMuY29tcHV0ZUZpbmFsSGVhZGVycyh7IFwiWC1Vc2VyLVN0YWdpbmctSWRcIjogc3RhZ2luZ1VzZXJJZCB9KSk7XG4gICAgICAgICAgICBjb25zdCB1cGRhdGVJbmZvID0geWllbGQgY2xpZW50LmdldExhdGVzdFZlcnNpb24oKTtcbiAgICAgICAgICAgIGNvbnN0IGxhdGVzdFZlcnNpb24gPSAoMCwgKF9zZW12ZXIgfHwgX2xvYWRfc2VtdmVyKCkpLnZhbGlkKSh1cGRhdGVJbmZvLnZlcnNpb24pO1xuICAgICAgICAgICAgaWYgKGxhdGVzdFZlcnNpb24gPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRocm93ICgwLCAoX2J1aWxkZXJVdGlsUnVudGltZSB8fCBfbG9hZF9idWlsZGVyVXRpbFJ1bnRpbWUoKSkubmV3RXJyb3IpKGBMYXRlc3QgdmVyc2lvbiAoZnJvbSB1cGRhdGUgc2VydmVyKSBpcyBub3QgdmFsaWQgc2VtdmVyIHZlcnNpb246IFwiJHtsYXRlc3RWZXJzaW9ufWAsIFwiRVJSX1VQREFURVJfSU5WQUxJRF9WRVJTSU9OXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgaXNTdGFnaW5nTWF0Y2ggPSB5aWVsZCBfdGhpczMuaXNTdGFnaW5nTWF0Y2godXBkYXRlSW5mbyk7XG4gICAgICAgICAgICBpZiAoIWlzU3RhZ2luZ01hdGNoIHx8IChfdGhpczMuYWxsb3dEb3duZ3JhZGUgJiYgIWhhc1ByZXJlbGVhc2VDb21wb25lbnRzKGxhdGVzdFZlcnNpb24pID8gKDAsIChfc2VtdmVyIHx8IF9sb2FkX3NlbXZlcigpKS5lcSkobGF0ZXN0VmVyc2lvbiwgX3RoaXMzLmN1cnJlbnRWZXJzaW9uKSA6ICEoMCwgKF9zZW12ZXIgfHwgX2xvYWRfc2VtdmVyKCkpLmd0KShsYXRlc3RWZXJzaW9uLCBfdGhpczMuY3VycmVudFZlcnNpb24pKSkge1xuICAgICAgICAgICAgICAgIF90aGlzMy51cGRhdGVBdmFpbGFibGUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBfdGhpczMuX2xvZ2dlci5pbmZvKGBVcGRhdGUgZm9yIHZlcnNpb24gJHtfdGhpczMuY3VycmVudFZlcnNpb259IGlzIG5vdCBhdmFpbGFibGUgKGxhdGVzdCB2ZXJzaW9uOiAke3VwZGF0ZUluZm8udmVyc2lvbn0sIGRvd25ncmFkZSBpcyAke190aGlzMy5hbGxvd0Rvd25ncmFkZSA/IFwiYWxsb3dlZFwiIDogXCJkaXNhbGxvd2VkXCJ9LmApO1xuICAgICAgICAgICAgICAgIF90aGlzMy5lbWl0KFwidXBkYXRlLW5vdC1hdmFpbGFibGVcIiwgdXBkYXRlSW5mbyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgdmVyc2lvbkluZm86IHVwZGF0ZUluZm8sXG4gICAgICAgICAgICAgICAgICAgIHVwZGF0ZUluZm9cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgX3RoaXMzLnVwZGF0ZUF2YWlsYWJsZSA9IHRydWU7XG4gICAgICAgICAgICBfdGhpczMudXBkYXRlSW5mbyA9IHVwZGF0ZUluZm87XG4gICAgICAgICAgICBfdGhpczMub25VcGRhdGVBdmFpbGFibGUodXBkYXRlSW5mbyk7XG4gICAgICAgICAgICBjb25zdCBjYW5jZWxsYXRpb25Ub2tlbiA9IG5ldyAoX2J1aWxkZXJVdGlsUnVudGltZSB8fCBfbG9hZF9idWlsZGVyVXRpbFJ1bnRpbWUoKSkuQ2FuY2VsbGF0aW9uVG9rZW4oKTtcbiAgICAgICAgICAgIC8vbm9pbnNwZWN0aW9uIEVTNk1pc3NpbmdBd2FpdFxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB2ZXJzaW9uSW5mbzogdXBkYXRlSW5mbyxcbiAgICAgICAgICAgICAgICB1cGRhdGVJbmZvLFxuICAgICAgICAgICAgICAgIGNhbmNlbGxhdGlvblRva2VuLFxuICAgICAgICAgICAgICAgIGRvd25sb2FkUHJvbWlzZTogX3RoaXMzLmF1dG9Eb3dubG9hZCA/IF90aGlzMy5kb3dubG9hZFVwZGF0ZShjYW5jZWxsYXRpb25Ub2tlbikgOiBudWxsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9KSgpO1xuICAgIH1cbiAgICBvblVwZGF0ZUF2YWlsYWJsZSh1cGRhdGVJbmZvKSB7XG4gICAgICAgIHRoaXMuX2xvZ2dlci5pbmZvKGBGb3VuZCB2ZXJzaW9uICR7dXBkYXRlSW5mby52ZXJzaW9ufSAodXJsOiAkeygwLCAoX2J1aWxkZXJVdGlsUnVudGltZSB8fCBfbG9hZF9idWlsZGVyVXRpbFJ1bnRpbWUoKSkuYXNBcnJheSkodXBkYXRlSW5mby5maWxlcykubWFwKGl0ID0+IGl0LnVybCkuam9pbihcIiwgXCIpfSlgKTtcbiAgICAgICAgdGhpcy5lbWl0KFwidXBkYXRlLWF2YWlsYWJsZVwiLCB1cGRhdGVJbmZvKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU3RhcnQgZG93bmxvYWRpbmcgdXBkYXRlIG1hbnVhbGx5LiBZb3UgY2FuIHVzZSB0aGlzIG1ldGhvZCBpZiBgYXV0b0Rvd25sb2FkYCBvcHRpb24gaXMgc2V0IHRvIGBmYWxzZWAuXG4gICAgICogQHJldHVybnMge1Byb21pc2U8c3RyaW5nPn0gUGF0aCB0byBkb3dubG9hZGVkIGZpbGUuXG4gICAgICovXG4gICAgZG93bmxvYWRVcGRhdGUoY2FuY2VsbGF0aW9uVG9rZW4gPSBuZXcgKF9idWlsZGVyVXRpbFJ1bnRpbWUgfHwgX2xvYWRfYnVpbGRlclV0aWxSdW50aW1lKCkpLkNhbmNlbGxhdGlvblRva2VuKCkpIHtcbiAgICAgICAgdmFyIF90aGlzNCA9IHRoaXM7XG5cbiAgICAgICAgcmV0dXJuICgwLCAoX2JsdWViaXJkTHN0IHx8IF9sb2FkX2JsdWViaXJkTHN0KCkpLmNvcm91dGluZSkoZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGNvbnN0IHVwZGF0ZUluZm8gPSBfdGhpczQudXBkYXRlSW5mbztcbiAgICAgICAgICAgIGlmICh1cGRhdGVJbmZvID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBlcnJvciA9IG5ldyBFcnJvcihcIlBsZWFzZSBjaGVjayB1cGRhdGUgZmlyc3RcIik7XG4gICAgICAgICAgICAgICAgX3RoaXM0LmRpc3BhdGNoRXJyb3IoZXJyb3IpO1xuICAgICAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgX3RoaXM0Ll9sb2dnZXIuaW5mbyhgRG93bmxvYWRpbmcgdXBkYXRlIGZyb20gJHsoMCwgKF9idWlsZGVyVXRpbFJ1bnRpbWUgfHwgX2xvYWRfYnVpbGRlclV0aWxSdW50aW1lKCkpLmFzQXJyYXkpKHVwZGF0ZUluZm8uZmlsZXMpLm1hcChmdW5jdGlvbiAoaXQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaXQudXJsO1xuICAgICAgICAgICAgfSkuam9pbihcIiwgXCIpfWApO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICByZXR1cm4geWllbGQgX3RoaXM0LmRvRG93bmxvYWRVcGRhdGUodXBkYXRlSW5mbywgY2FuY2VsbGF0aW9uVG9rZW4pO1xuICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIF90aGlzNC5kaXNwYXRjaEVycm9yKGUpO1xuICAgICAgICAgICAgICAgIHRocm93IGU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pKCk7XG4gICAgfVxuICAgIGRpc3BhdGNoRXJyb3IoZSkge1xuICAgICAgICB0aGlzLmVtaXQoXCJlcnJvclwiLCBlLCAoZS5zdGFjayB8fCBlKS50b1N0cmluZygpKTtcbiAgICB9XG4gICAgbG9hZFVwZGF0ZUNvbmZpZygpIHtcbiAgICAgICAgdmFyIF90aGlzNSA9IHRoaXM7XG5cbiAgICAgICAgcmV0dXJuICgwLCAoX2JsdWViaXJkTHN0IHx8IF9sb2FkX2JsdWViaXJkTHN0KCkpLmNvcm91dGluZSkoZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGlmIChfdGhpczUuX2FwcFVwZGF0ZUNvbmZpZ1BhdGggPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIF90aGlzNS5fYXBwVXBkYXRlQ29uZmlnUGF0aCA9IChfZWxlY3Ryb25Jc0RldiB8fCBfbG9hZF9lbGVjdHJvbklzRGV2KCkpLmRlZmF1bHQgPyBfcGF0aC5qb2luKF90aGlzNS5hcHAuZ2V0QXBwUGF0aCgpLCBcImRldi1hcHAtdXBkYXRlLnltbFwiKSA6IF9wYXRoLmpvaW4ocHJvY2Vzcy5yZXNvdXJjZXNQYXRoLCBcImFwcC11cGRhdGUueW1sXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuICgwLCAoX2pzWWFtbCB8fCBfbG9hZF9qc1lhbWwoKSkuc2FmZUxvYWQpKCh5aWVsZCAoMCwgKF9mc0V4dHJhUCB8fCBfbG9hZF9mc0V4dHJhUCgpKS5yZWFkRmlsZSkoX3RoaXM1Ll9hcHBVcGRhdGVDb25maWdQYXRoLCBcInV0Zi04XCIpKSk7XG4gICAgICAgIH0pKCk7XG4gICAgfVxuICAgIC8qKiogQHByaXZhdGUgKi9cbiAgICBjb21wdXRlUmVxdWVzdEhlYWRlcnMoKSB7XG4gICAgICAgIHZhciBfdGhpczYgPSB0aGlzO1xuXG4gICAgICAgIHJldHVybiAoMCwgKF9ibHVlYmlyZExzdCB8fCBfbG9hZF9ibHVlYmlyZExzdCgpKS5jb3JvdXRpbmUpKGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCBmaWxlRXh0cmFEb3dubG9hZEhlYWRlcnMgPSAoeWllbGQgX3RoaXM2LnByb3ZpZGVyKS5maWxlRXh0cmFEb3dubG9hZEhlYWRlcnM7XG4gICAgICAgICAgICBpZiAoZmlsZUV4dHJhRG93bmxvYWRIZWFkZXJzICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBjb25zdCByZXF1ZXN0SGVhZGVycyA9IF90aGlzNi5yZXF1ZXN0SGVhZGVycztcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVxdWVzdEhlYWRlcnMgPT0gbnVsbCA/IGZpbGVFeHRyYURvd25sb2FkSGVhZGVycyA6IE9iamVjdC5hc3NpZ24oe30sIGZpbGVFeHRyYURvd25sb2FkSGVhZGVycywgcmVxdWVzdEhlYWRlcnMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIF90aGlzNi5jb21wdXRlRmluYWxIZWFkZXJzKHsgQWNjZXB0OiBcIiovKlwiIH0pO1xuICAgICAgICB9KSgpO1xuICAgIH1cbiAgICBnZXRPckNyZWF0ZVN0YWdpbmdVc2VySWQoKSB7XG4gICAgICAgIHZhciBfdGhpczcgPSB0aGlzO1xuXG4gICAgICAgIHJldHVybiAoMCwgKF9ibHVlYmlyZExzdCB8fCBfbG9hZF9ibHVlYmlyZExzdCgpKS5jb3JvdXRpbmUpKGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCBmaWxlID0gX3BhdGguam9pbihfdGhpczcuYXBwLmdldFBhdGgoXCJ1c2VyRGF0YVwiKSwgXCIudXBkYXRlcklkXCIpO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBjb25zdCBpZCA9IHlpZWxkICgwLCAoX2ZzRXh0cmFQIHx8IF9sb2FkX2ZzRXh0cmFQKCkpLnJlYWRGaWxlKShmaWxlLCBcInV0Zi04XCIpO1xuICAgICAgICAgICAgICAgIGlmICgoX2J1aWxkZXJVdGlsUnVudGltZSB8fCBfbG9hZF9idWlsZGVyVXRpbFJ1bnRpbWUoKSkuVVVJRC5jaGVjayhpZCkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGlkO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzNy5fbG9nZ2VyLndhcm4oYFN0YWdpbmcgdXNlciBpZCBmaWxlIGV4aXN0cywgYnV0IGNvbnRlbnQgd2FzIGludmFsaWQ6ICR7aWR9YCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIGlmIChlLmNvZGUgIT09IFwiRU5PRU5UXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXM3Ll9sb2dnZXIud2FybihgQ291bGRuJ3QgcmVhZCBzdGFnaW5nIHVzZXIgSUQsIGNyZWF0aW5nIGEgYmxhbmsgb25lOiAke2V9YCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgaWQgPSAoX2J1aWxkZXJVdGlsUnVudGltZSB8fCBfbG9hZF9idWlsZGVyVXRpbFJ1bnRpbWUoKSkuVVVJRC52NSgoMCwgKF9jcnlwdG8gfHwgX2xvYWRfY3J5cHRvKCkpLnJhbmRvbUJ5dGVzKSg0MDk2KSwgKF9idWlsZGVyVXRpbFJ1bnRpbWUgfHwgX2xvYWRfYnVpbGRlclV0aWxSdW50aW1lKCkpLlVVSUQuT0lEKTtcbiAgICAgICAgICAgIF90aGlzNy5fbG9nZ2VyLmluZm8oYEdlbmVyYXRlZCBuZXcgc3RhZ2luZyB1c2VyIElEOiAke2lkfWApO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICB5aWVsZCAoMCwgKF9mc0V4dHJhUCB8fCBfbG9hZF9mc0V4dHJhUCgpKS5vdXRwdXRGaWxlKShmaWxlLCBpZCk7XG4gICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgX3RoaXM3Ll9sb2dnZXIud2FybihgQ291bGRuJ3Qgd3JpdGUgb3V0IHN0YWdpbmcgdXNlciBJRDogJHtlfWApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGlkO1xuICAgICAgICB9KSgpO1xuICAgIH1cbn1cbmV4cG9ydHMuQXBwVXBkYXRlciA9IEFwcFVwZGF0ZXI7XG5mdW5jdGlvbiBoYXNQcmVyZWxlYXNlQ29tcG9uZW50cyh2ZXJzaW9uKSB7XG4gICAgY29uc3QgdmVyc2lvblByZXJlbGVhc2VDb21wb25lbnQgPSAoMCwgKF9zZW12ZXIgfHwgX2xvYWRfc2VtdmVyKCkpLnByZXJlbGVhc2UpKHZlcnNpb24pO1xuICAgIHJldHVybiB2ZXJzaW9uUHJlcmVsZWFzZUNvbXBvbmVudCAhPSBudWxsICYmIHZlcnNpb25QcmVyZWxlYXNlQ29tcG9uZW50Lmxlbmd0aCA+IDA7XG59XG4vKiogQHByaXZhdGUgKi9cbmNsYXNzIE5vT3BMb2dnZXIge1xuICAgIGluZm8obWVzc2FnZSkge1xuICAgICAgICAvLyBpZ25vcmVcbiAgICB9XG4gICAgd2FybihtZXNzYWdlKSB7XG4gICAgICAgIC8vIGlnbm9yZVxuICAgIH1cbiAgICBlcnJvcihtZXNzYWdlKSB7XG4gICAgICAgIC8vIGlnbm9yZVxuICAgIH1cbn1cbmV4cG9ydHMuTm9PcExvZ2dlciA9IE5vT3BMb2dnZXI7IC8vIyBzb3VyY2VNYXBwaW5nVVJMPUFwcFVwZGF0ZXIuanMubWFwXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2VsZWN0cm9uLXVwZGF0ZXIvb3V0L0FwcFVwZGF0ZXIuanMiLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCJjcnlwdG9cIik7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gZXh0ZXJuYWwgXCJjcnlwdG9cIlxuLy8gbW9kdWxlIGlkID0gMjhcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwidXRpbFwiKTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyBleHRlcm5hbCBcInV0aWxcIlxuLy8gbW9kdWxlIGlkID0gMjlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IHUgPSByZXF1aXJlKCd1bml2ZXJzYWxpZnknKS5mcm9tQ2FsbGJhY2tcbmNvbnN0IGpzb25GaWxlID0gcmVxdWlyZSgnanNvbmZpbGUnKVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgLy8ganNvbmZpbGUgZXhwb3J0c1xuICByZWFkSnNvbjogdShqc29uRmlsZS5yZWFkRmlsZSksXG4gIHJlYWRKc29uU3luYzoganNvbkZpbGUucmVhZEZpbGVTeW5jLFxuICB3cml0ZUpzb246IHUoanNvbkZpbGUud3JpdGVGaWxlKSxcbiAgd3JpdGVKc29uU3luYzoganNvbkZpbGUud3JpdGVGaWxlU3luY1xufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2VsZWN0cm9uLXVwZGF0ZXIvbm9kZV9tb2R1bGVzL2ZzLWV4dHJhL2xpYi9qc29uL2pzb25maWxlLmpzIiwiJ3VzZSBzdHJpY3QnO1xuXG5cbnZhciB5YW1sID0gcmVxdWlyZSgnLi9saWIvanMteWFtbC5qcycpO1xuXG5cbm1vZHVsZS5leHBvcnRzID0geWFtbDtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9qcy15YW1sL2luZGV4LmpzIiwiLy8gU3RhbmRhcmQgWUFNTCdzIEZhaWxzYWZlIHNjaGVtYS5cbi8vIGh0dHA6Ly93d3cueWFtbC5vcmcvc3BlYy8xLjIvc3BlYy5odG1sI2lkMjgwMjM0NlxuXG5cbid1c2Ugc3RyaWN0JztcblxuXG52YXIgU2NoZW1hID0gcmVxdWlyZSgnLi4vc2NoZW1hJyk7XG5cblxubW9kdWxlLmV4cG9ydHMgPSBuZXcgU2NoZW1hKHtcbiAgZXhwbGljaXQ6IFtcbiAgICByZXF1aXJlKCcuLi90eXBlL3N0cicpLFxuICAgIHJlcXVpcmUoJy4uL3R5cGUvc2VxJyksXG4gICAgcmVxdWlyZSgnLi4vdHlwZS9tYXAnKVxuICBdXG59KTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9qcy15YW1sL2xpYi9qcy15YW1sL3NjaGVtYS9mYWlsc2FmZS5qcyIsInJlcXVpcmUoJy4vJykuaW5zdGFsbCgpO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2VsZWN0cm9uLXVwZGF0ZXIvbm9kZV9tb2R1bGVzL3NvdXJjZS1tYXAtc3VwcG9ydC9yZWdpc3Rlci5qcyIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcImNoaWxkX3Byb2Nlc3NcIik7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gZXh0ZXJuYWwgXCJjaGlsZF9wcm9jZXNzXCJcbi8vIG1vZHVsZSBpZCA9IDM0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmNvbXB1dGVPcGVyYXRpb25zID0gY29tcHV0ZU9wZXJhdGlvbnM7XG52YXIgT3BlcmF0aW9uS2luZCA9IGV4cG9ydHMuT3BlcmF0aW9uS2luZCA9IHVuZGVmaW5lZDtcbihmdW5jdGlvbiAoT3BlcmF0aW9uS2luZCkge1xuICAgIE9wZXJhdGlvbktpbmRbT3BlcmF0aW9uS2luZFtcIkNPUFlcIl0gPSAwXSA9IFwiQ09QWVwiO1xuICAgIE9wZXJhdGlvbktpbmRbT3BlcmF0aW9uS2luZFtcIkRPV05MT0FEXCJdID0gMV0gPSBcIkRPV05MT0FEXCI7XG59KShPcGVyYXRpb25LaW5kIHx8IChleHBvcnRzLk9wZXJhdGlvbktpbmQgPSBPcGVyYXRpb25LaW5kID0ge30pKTtcbmZ1bmN0aW9uIGNvbXB1dGVPcGVyYXRpb25zKG9sZEJsb2NrTWFwLCBuZXdCbG9ja01hcCwgbG9nZ2VyKSB7XG4gICAgY29uc3QgbmFtZVRvT2xkQmxvY2tzID0gYnVpbGRCbG9ja0ZpbGVNYXAob2xkQmxvY2tNYXAuZmlsZXMpO1xuICAgIGNvbnN0IG5hbWVUb05ld0Jsb2NrcyA9IGJ1aWxkQmxvY2tGaWxlTWFwKG5ld0Jsb2NrTWFwLmZpbGVzKTtcbiAgICBjb25zdCBvbGRFbnRyeU1hcCA9IGJ1aWxkRW50cnlNYXAob2xkQmxvY2tNYXAuZmlsZXMpO1xuICAgIGxldCBsYXN0T3BlcmF0aW9uID0gbnVsbDtcbiAgICBjb25zdCBvcGVyYXRpb25zID0gW107XG4gICAgZm9yIChjb25zdCBibG9ja01hcEZpbGUgb2YgbmV3QmxvY2tNYXAuZmlsZXMpIHtcbiAgICAgICAgY29uc3QgbmFtZSA9IGJsb2NrTWFwRmlsZS5uYW1lO1xuICAgICAgICBjb25zdCBvbGRFbnRyeSA9IG9sZEVudHJ5TWFwLmdldChuYW1lKTtcbiAgICAgICAgaWYgKG9sZEVudHJ5ID09IG51bGwpIHtcbiAgICAgICAgICAgIC8vIG5ldyBmaWxlXG4gICAgICAgICAgICBvcGVyYXRpb25zLnB1c2goe1xuICAgICAgICAgICAgICAgIGtpbmQ6IE9wZXJhdGlvbktpbmQuRE9XTkxPQUQsXG4gICAgICAgICAgICAgICAgc3RhcnQ6IGJsb2NrTWFwRmlsZS5vZmZzZXQsXG4gICAgICAgICAgICAgICAgZW5kOiBibG9ja01hcEZpbGUub2Zmc2V0ICsgYmxvY2tNYXBGaWxlLnNpemVzLnJlZHVjZSgoYWNjdW11bGF0b3IsIGN1cnJlbnRWYWx1ZSkgPT4gYWNjdW11bGF0b3IgKyBjdXJyZW50VmFsdWUpXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG5ld0ZpbGUgPSBuYW1lVG9OZXdCbG9ja3MuZ2V0KG5hbWUpO1xuICAgICAgICBsZXQgY2hhbmdlZEJsb2NrQ291bnQgPSAwO1xuICAgICAgICBjb25zdCB7IGNoZWNrc3VtVG9PZmZzZXQ6IGNoZWNrc3VtVG9PbGRPZmZzZXQsIGNoZWNrc3VtVG9PbGRTaXplIH0gPSBidWlsZENoZWNrc3VtTWFwKG5hbWVUb09sZEJsb2Nrcy5nZXQobmFtZSksIG9sZEVudHJ5Lm9mZnNldCk7XG4gICAgICAgIGxldCBuZXdPZmZzZXQgPSBibG9ja01hcEZpbGUub2Zmc2V0O1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG5ld0ZpbGUuY2hlY2tzdW1zLmxlbmd0aDsgbmV3T2Zmc2V0ICs9IG5ld0ZpbGUuc2l6ZXNbaV0sIGkrKykge1xuICAgICAgICAgICAgY29uc3QgYmxvY2tTaXplID0gbmV3RmlsZS5zaXplc1tpXTtcbiAgICAgICAgICAgIGNvbnN0IGNoZWNrc3VtID0gbmV3RmlsZS5jaGVja3N1bXNbaV07XG4gICAgICAgICAgICBsZXQgb2xkT2Zmc2V0ID0gY2hlY2tzdW1Ub09sZE9mZnNldC5nZXQoY2hlY2tzdW0pO1xuICAgICAgICAgICAgaWYgKG9sZE9mZnNldCAhPSBudWxsICYmIGNoZWNrc3VtVG9PbGRTaXplLmdldChjaGVja3N1bSkgIT09IGJsb2NrU2l6ZSkge1xuICAgICAgICAgICAgICAgIGxvZ2dlci53YXJuKGBDaGVja3N1bSAoXCIke2NoZWNrc3VtfVwiKSBtYXRjaGVzLCBidXQgc2l6ZSBkaWZmZXJzIChvbGQ6ICR7Y2hlY2tzdW1Ub09sZFNpemUuZ2V0KGNoZWNrc3VtKX0sIG5ldzogJHtibG9ja1NpemV9KWApO1xuICAgICAgICAgICAgICAgIG9sZE9mZnNldCA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAob2xkT2Zmc2V0ID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBjaGFuZ2VkQmxvY2tDb3VudCsrO1xuICAgICAgICAgICAgICAgIGlmIChsYXN0T3BlcmF0aW9uID09IG51bGwgfHwgbGFzdE9wZXJhdGlvbi5raW5kICE9PSBPcGVyYXRpb25LaW5kLkRPV05MT0FEIHx8IGxhc3RPcGVyYXRpb24uZW5kICE9PSBuZXdPZmZzZXQpIHtcbiAgICAgICAgICAgICAgICAgICAgbGFzdE9wZXJhdGlvbiA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGtpbmQ6IE9wZXJhdGlvbktpbmQuRE9XTkxPQUQsXG4gICAgICAgICAgICAgICAgICAgICAgICBzdGFydDogbmV3T2Zmc2V0LFxuICAgICAgICAgICAgICAgICAgICAgICAgZW5kOiBuZXdPZmZzZXQgKyBibG9ja1NpemVcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgb3BlcmF0aW9ucy5wdXNoKGxhc3RPcGVyYXRpb24pO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGxhc3RPcGVyYXRpb24uZW5kICs9IGJsb2NrU2l6ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGxhc3RPcGVyYXRpb24gPT0gbnVsbCB8fCBsYXN0T3BlcmF0aW9uLmtpbmQgIT09IE9wZXJhdGlvbktpbmQuQ09QWSB8fCBsYXN0T3BlcmF0aW9uLmVuZCAhPT0gb2xkT2Zmc2V0KSB7XG4gICAgICAgICAgICAgICAgbGFzdE9wZXJhdGlvbiA9IHtcbiAgICAgICAgICAgICAgICAgICAga2luZDogT3BlcmF0aW9uS2luZC5DT1BZLFxuICAgICAgICAgICAgICAgICAgICBzdGFydDogb2xkT2Zmc2V0LFxuICAgICAgICAgICAgICAgICAgICBlbmQ6IG9sZE9mZnNldCArIGJsb2NrU2l6ZVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgb3BlcmF0aW9ucy5wdXNoKGxhc3RPcGVyYXRpb24pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBsYXN0T3BlcmF0aW9uLmVuZCArPSBibG9ja1NpemU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNoYW5nZWRCbG9ja0NvdW50ID4gMCkge1xuICAgICAgICAgICAgbG9nZ2VyLmluZm8oYEZpbGUke2Jsb2NrTWFwRmlsZS5uYW1lID09PSBcImZpbGVcIiA/IFwiXCIgOiBcIiBcIiArIGJsb2NrTWFwRmlsZS5uYW1lfSBoYXMgJHtjaGFuZ2VkQmxvY2tDb3VudH0gY2hhbmdlZCBibG9ja3NgKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gb3BlcmF0aW9ucztcbn1cbmZ1bmN0aW9uIGJ1aWxkQ2hlY2tzdW1NYXAoZmlsZSwgZmlsZU9mZnNldCkge1xuICAgIGNvbnN0IGNoZWNrc3VtVG9PZmZzZXQgPSBuZXcgTWFwKCk7XG4gICAgY29uc3QgY2hlY2tzdW1Ub1NpemUgPSBuZXcgTWFwKCk7XG4gICAgbGV0IG9mZnNldCA9IGZpbGVPZmZzZXQ7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBmaWxlLmNoZWNrc3Vtcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCBjaGVja3N1bSA9IGZpbGUuY2hlY2tzdW1zW2ldO1xuICAgICAgICBjb25zdCBzaXplID0gZmlsZS5zaXplc1tpXTtcbiAgICAgICAgY2hlY2tzdW1Ub09mZnNldC5zZXQoY2hlY2tzdW0sIG9mZnNldCk7XG4gICAgICAgIGNoZWNrc3VtVG9TaXplLnNldChjaGVja3N1bSwgc2l6ZSk7XG4gICAgICAgIG9mZnNldCArPSBzaXplO1xuICAgIH1cbiAgICByZXR1cm4geyBjaGVja3N1bVRvT2Zmc2V0LCBjaGVja3N1bVRvT2xkU2l6ZTogY2hlY2tzdW1Ub1NpemUgfTtcbn1cbmZ1bmN0aW9uIGJ1aWxkRW50cnlNYXAobGlzdCkge1xuICAgIGNvbnN0IHJlc3VsdCA9IG5ldyBNYXAoKTtcbiAgICBmb3IgKGNvbnN0IGl0ZW0gb2YgbGlzdCkge1xuICAgICAgICByZXN1bHQuc2V0KGl0ZW0ubmFtZSwgaXRlbSk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiBidWlsZEJsb2NrRmlsZU1hcChsaXN0KSB7XG4gICAgY29uc3QgcmVzdWx0ID0gbmV3IE1hcCgpO1xuICAgIGZvciAoY29uc3QgaXRlbSBvZiBsaXN0KSB7XG4gICAgICAgIHJlc3VsdC5zZXQoaXRlbS5uYW1lLCBpdGVtKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRvd25sb2FkUGxhbkJ1aWxkZXIuanMubWFwXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2VsZWN0cm9uLXVwZGF0ZXIvb3V0L2RpZmZlcmVudGlhbERvd25sb2FkZXIvZG93bmxvYWRQbGFuQnVpbGRlci5qcyIsIid1c2Ugc3RyaWN0JztcblxudmFyIGZvcm1hdCAgICAgICAgICA9IHJlcXVpcmUoJy4uL2Zvcm1hdCcpO1xudmFyIG9yaWdpbmFsQ29uc29sZSA9IHJlcXVpcmUoJy4uL29yaWdpbmFsLWNvbnNvbGUnKTtcblxudHJhbnNwb3J0LmxldmVsICA9ICdzaWxseSc7XG50cmFuc3BvcnQuZm9ybWF0ID0gJ1t7aH06e2l9OntzfS57bXN9XSBbe2xldmVsfV0ge3RleHR9JztcblxubW9kdWxlLmV4cG9ydHMgPSB0cmFuc3BvcnQ7XG5cbmZ1bmN0aW9uIHRyYW5zcG9ydChtc2cpIHtcbiAgdmFyIHRleHQgPSBmb3JtYXQuZm9ybWF0KG1zZywgdHJhbnNwb3J0LmZvcm1hdCk7XG4gIGlmIChvcmlnaW5hbENvbnNvbGVbbXNnLmxldmVsXSkge1xuICAgIG9yaWdpbmFsQ29uc29sZVttc2cubGV2ZWxdKHRleHQpO1xuICB9IGVsc2Uge1xuICAgIG9yaWdpbmFsQ29uc29sZS5sb2codGV4dCk7XG4gIH1cbn1cblxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2VsZWN0cm9uLWxvZy9saWIvdHJhbnNwb3J0cy9jb25zb2xlLmpzIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgdXRpbCA9IHJlcXVpcmUoJ3V0aWwnKTtcbnZhciBFT0wgID0gcmVxdWlyZSgnb3MnKS5FT0w7XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBmb3JtYXQ6IGZvcm1hdCxcbiAgZm9ybWF0VGltZVpvbmU6IGZvcm1hdFRpbWVab25lLFxuICBwYWQ6IHBhZCxcbiAgc3RyaW5naWZ5QXJyYXk6IHN0cmluZ2lmeUFycmF5XG59O1xuXG5mdW5jdGlvbiBmb3JtYXQobXNnLCBmb3JtYXR0ZXIpIHtcbiAgaWYgKHR5cGVvZiBmb3JtYXR0ZXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gZm9ybWF0dGVyKG1zZyk7XG4gIH1cblxuICB2YXIgZGF0ZSA9IG1zZy5kYXRlO1xuXG4gIHJldHVybiBmb3JtYXR0ZXJcbiAgICAucmVwbGFjZSgne2xldmVsfScsIG1zZy5sZXZlbClcbiAgICAucmVwbGFjZSgne3RleHR9Jywgc3RyaW5naWZ5QXJyYXkobXNnLmRhdGEpKVxuICAgIC5yZXBsYWNlKCd7eX0nLCBkYXRlLmdldEZ1bGxZZWFyKCkpXG4gICAgLnJlcGxhY2UoJ3ttfScsIHBhZChkYXRlLmdldE1vbnRoKCkgKyAxKSlcbiAgICAucmVwbGFjZSgne2R9JywgcGFkKGRhdGUuZ2V0RGF0ZSgpKSlcbiAgICAucmVwbGFjZSgne2h9JywgcGFkKGRhdGUuZ2V0SG91cnMoKSkpXG4gICAgLnJlcGxhY2UoJ3tpfScsIHBhZChkYXRlLmdldE1pbnV0ZXMoKSkpXG4gICAgLnJlcGxhY2UoJ3tzfScsIHBhZChkYXRlLmdldFNlY29uZHMoKSkpXG4gICAgLnJlcGxhY2UoJ3ttc30nLCBwYWQoZGF0ZS5nZXRNaWxsaXNlY29uZHMoKSwgMykpXG4gICAgLnJlcGxhY2UoJ3t6fScsIGZvcm1hdFRpbWVab25lKGRhdGUuZ2V0VGltZXpvbmVPZmZzZXQoKSkpO1xufVxuXG5mdW5jdGlvbiBzdHJpbmdpZnlBcnJheShkYXRhKSB7XG4gIGRhdGEgPSBkYXRhLm1hcChmdW5jdGlvbiBmb3JtYXRFcnJvcnMoYXJnKSB7XG4gICAgcmV0dXJuIGFyZyBpbnN0YW5jZW9mIEVycm9yID8gYXJnLnN0YWNrICsgRU9MIDogYXJnO1xuICB9KTtcbiAgcmV0dXJuIHV0aWwuZm9ybWF0LmFwcGx5KHV0aWwsIGRhdGEpO1xufVxuXG5mdW5jdGlvbiBwYWQobnVtYmVyLCB6ZXJvcykge1xuICB6ZXJvcyA9IHplcm9zIHx8IDI7XG4gIHJldHVybiAobmV3IEFycmF5KHplcm9zICsgMSkuam9pbignMCcpICsgbnVtYmVyKS5zdWJzdHIoLXplcm9zLCB6ZXJvcyk7XG59XG5cbmZ1bmN0aW9uIGZvcm1hdFRpbWVab25lKG1pbnV0ZXNPZmZzZXQpIHtcbiAgdmFyIG0gPSBNYXRoLmFicyhtaW51dGVzT2Zmc2V0KTtcbiAgcmV0dXJuIChtaW51dGVzT2Zmc2V0ID49IDAgPyAnLScgOiAnKycpICtcbiAgICBwYWQoTWF0aC5mbG9vcihtIC8gNjApKSArICc6JyArXG4gICAgcGFkKG0gJSA2MCk7XG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvZWxlY3Ryb24tbG9nL2xpYi9mb3JtYXQuanMiLCJcInVzZSBzdHJpY3RcIjtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oTkVYVF9GSUxURVIpIHtcbnZhciB1dGlsID0gcmVxdWlyZShcIi4vdXRpbFwiKTtcbnZhciBnZXRLZXlzID0gcmVxdWlyZShcIi4vZXM1XCIpLmtleXM7XG52YXIgdHJ5Q2F0Y2ggPSB1dGlsLnRyeUNhdGNoO1xudmFyIGVycm9yT2JqID0gdXRpbC5lcnJvck9iajtcblxuZnVuY3Rpb24gY2F0Y2hGaWx0ZXIoaW5zdGFuY2VzLCBjYiwgcHJvbWlzZSkge1xuICAgIHJldHVybiBmdW5jdGlvbihlKSB7XG4gICAgICAgIHZhciBib3VuZFRvID0gcHJvbWlzZS5fYm91bmRWYWx1ZSgpO1xuICAgICAgICBwcmVkaWNhdGVMb29wOiBmb3IgKHZhciBpID0gMDsgaSA8IGluc3RhbmNlcy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgdmFyIGl0ZW0gPSBpbnN0YW5jZXNbaV07XG5cbiAgICAgICAgICAgIGlmIChpdGVtID09PSBFcnJvciB8fFxuICAgICAgICAgICAgICAgIChpdGVtICE9IG51bGwgJiYgaXRlbS5wcm90b3R5cGUgaW5zdGFuY2VvZiBFcnJvcikpIHtcbiAgICAgICAgICAgICAgICBpZiAoZSBpbnN0YW5jZW9mIGl0ZW0pIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRyeUNhdGNoKGNiKS5jYWxsKGJvdW5kVG8sIGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGl0ZW0gPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgICAgIHZhciBtYXRjaGVzUHJlZGljYXRlID0gdHJ5Q2F0Y2goaXRlbSkuY2FsbChib3VuZFRvLCBlKTtcbiAgICAgICAgICAgICAgICBpZiAobWF0Y2hlc1ByZWRpY2F0ZSA9PT0gZXJyb3JPYmopIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG1hdGNoZXNQcmVkaWNhdGU7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChtYXRjaGVzUHJlZGljYXRlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnlDYXRjaChjYikuY2FsbChib3VuZFRvLCBlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHV0aWwuaXNPYmplY3QoZSkpIHtcbiAgICAgICAgICAgICAgICB2YXIga2V5cyA9IGdldEtleXMoaXRlbSk7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBrZXlzLmxlbmd0aDsgKytqKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBrZXkgPSBrZXlzW2pdO1xuICAgICAgICAgICAgICAgICAgICBpZiAoaXRlbVtrZXldICE9IGVba2V5XSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWUgcHJlZGljYXRlTG9vcDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ5Q2F0Y2goY2IpLmNhbGwoYm91bmRUbywgZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIE5FWFRfRklMVEVSO1xuICAgIH07XG59XG5cbnJldHVybiBjYXRjaEZpbHRlcjtcbn07XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvYmx1ZWJpcmQvanMvcmVsZWFzZS9jYXRjaF9maWx0ZXIuanMiLCJcInVzZSBzdHJpY3RcIjtcbnZhciB1dGlsID0gcmVxdWlyZShcIi4vdXRpbFwiKTtcbnZhciBtYXliZVdyYXBBc0Vycm9yID0gdXRpbC5tYXliZVdyYXBBc0Vycm9yO1xudmFyIGVycm9ycyA9IHJlcXVpcmUoXCIuL2Vycm9yc1wiKTtcbnZhciBPcGVyYXRpb25hbEVycm9yID0gZXJyb3JzLk9wZXJhdGlvbmFsRXJyb3I7XG52YXIgZXM1ID0gcmVxdWlyZShcIi4vZXM1XCIpO1xuXG5mdW5jdGlvbiBpc1VudHlwZWRFcnJvcihvYmopIHtcbiAgICByZXR1cm4gb2JqIGluc3RhbmNlb2YgRXJyb3IgJiZcbiAgICAgICAgZXM1LmdldFByb3RvdHlwZU9mKG9iaikgPT09IEVycm9yLnByb3RvdHlwZTtcbn1cblxudmFyIHJFcnJvcktleSA9IC9eKD86bmFtZXxtZXNzYWdlfHN0YWNrfGNhdXNlKSQvO1xuZnVuY3Rpb24gd3JhcEFzT3BlcmF0aW9uYWxFcnJvcihvYmopIHtcbiAgICB2YXIgcmV0O1xuICAgIGlmIChpc1VudHlwZWRFcnJvcihvYmopKSB7XG4gICAgICAgIHJldCA9IG5ldyBPcGVyYXRpb25hbEVycm9yKG9iaik7XG4gICAgICAgIHJldC5uYW1lID0gb2JqLm5hbWU7XG4gICAgICAgIHJldC5tZXNzYWdlID0gb2JqLm1lc3NhZ2U7XG4gICAgICAgIHJldC5zdGFjayA9IG9iai5zdGFjaztcbiAgICAgICAgdmFyIGtleXMgPSBlczUua2V5cyhvYmopO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIHZhciBrZXkgPSBrZXlzW2ldO1xuICAgICAgICAgICAgaWYgKCFyRXJyb3JLZXkudGVzdChrZXkpKSB7XG4gICAgICAgICAgICAgICAgcmV0W2tleV0gPSBvYmpba2V5XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmV0O1xuICAgIH1cbiAgICB1dGlsLm1hcmtBc09yaWdpbmF0aW5nRnJvbVJlamVjdGlvbihvYmopO1xuICAgIHJldHVybiBvYmo7XG59XG5cbmZ1bmN0aW9uIG5vZGViYWNrRm9yUHJvbWlzZShwcm9taXNlLCBtdWx0aUFyZ3MpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oZXJyLCB2YWx1ZSkge1xuICAgICAgICBpZiAocHJvbWlzZSA9PT0gbnVsbCkgcmV0dXJuO1xuICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICB2YXIgd3JhcHBlZCA9IHdyYXBBc09wZXJhdGlvbmFsRXJyb3IobWF5YmVXcmFwQXNFcnJvcihlcnIpKTtcbiAgICAgICAgICAgIHByb21pc2UuX2F0dGFjaEV4dHJhVHJhY2Uod3JhcHBlZCk7XG4gICAgICAgICAgICBwcm9taXNlLl9yZWplY3Qod3JhcHBlZCk7XG4gICAgICAgIH0gZWxzZSBpZiAoIW11bHRpQXJncykge1xuICAgICAgICAgICAgcHJvbWlzZS5fZnVsZmlsbCh2YWx1ZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YXIgJF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoO3ZhciBhcmdzID0gbmV3IEFycmF5KE1hdGgubWF4KCRfbGVuIC0gMSwgMCkpOyBmb3IodmFyICRfaSA9IDE7ICRfaSA8ICRfbGVuOyArKyRfaSkge2FyZ3NbJF9pIC0gMV0gPSBhcmd1bWVudHNbJF9pXTt9O1xuICAgICAgICAgICAgcHJvbWlzZS5fZnVsZmlsbChhcmdzKTtcbiAgICAgICAgfVxuICAgICAgICBwcm9taXNlID0gbnVsbDtcbiAgICB9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IG5vZGViYWNrRm9yUHJvbWlzZTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9ibHVlYmlyZC9qcy9yZWxlYXNlL25vZGViYWNrLmpzIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuQ2FuY2VsbGF0aW9uRXJyb3IgPSBleHBvcnRzLkNhbmNlbGxhdGlvblRva2VuID0gdW5kZWZpbmVkO1xuXG52YXIgX2JsdWViaXJkTHN0O1xuXG5mdW5jdGlvbiBfbG9hZF9ibHVlYmlyZExzdCgpIHtcbiAgICByZXR1cm4gX2JsdWViaXJkTHN0ID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiYmx1ZWJpcmQtbHN0XCIpKTtcbn1cblxudmFyIF9ldmVudHM7XG5cbmZ1bmN0aW9uIF9sb2FkX2V2ZW50cygpIHtcbiAgICByZXR1cm4gX2V2ZW50cyA9IHJlcXVpcmUoXCJldmVudHNcIik7XG59XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmNsYXNzIENhbmNlbGxhdGlvblRva2VuIGV4dGVuZHMgKF9ldmVudHMgfHwgX2xvYWRfZXZlbnRzKCkpLkV2ZW50RW1pdHRlciB7XG4gICAgLy8gYmFiZWwgY2Fubm90IGNvbXBpbGUgLi4uIGNvcnJlY3RseSBmb3Igc3VwZXIgY2FsbHNcbiAgICBjb25zdHJ1Y3RvcihwYXJlbnQpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5wYXJlbnRDYW5jZWxIYW5kbGVyID0gbnVsbDtcbiAgICAgICAgdGhpcy5fY2FuY2VsbGVkID0gZmFsc2U7XG4gICAgICAgIGlmIChwYXJlbnQgIT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5wYXJlbnQgPSBwYXJlbnQ7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0IGNhbmNlbGxlZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2NhbmNlbGxlZCB8fCB0aGlzLl9wYXJlbnQgIT0gbnVsbCAmJiB0aGlzLl9wYXJlbnQuY2FuY2VsbGVkO1xuICAgIH1cbiAgICBzZXQgcGFyZW50KHZhbHVlKSB7XG4gICAgICAgIHRoaXMucmVtb3ZlUGFyZW50Q2FuY2VsSGFuZGxlcigpO1xuICAgICAgICB0aGlzLl9wYXJlbnQgPSB2YWx1ZTtcbiAgICAgICAgdGhpcy5wYXJlbnRDYW5jZWxIYW5kbGVyID0gKCkgPT4gdGhpcy5jYW5jZWwoKTtcbiAgICAgICAgdGhpcy5fcGFyZW50Lm9uQ2FuY2VsKHRoaXMucGFyZW50Q2FuY2VsSGFuZGxlcik7XG4gICAgfVxuICAgIGNhbmNlbCgpIHtcbiAgICAgICAgdGhpcy5fY2FuY2VsbGVkID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5lbWl0KFwiY2FuY2VsXCIpO1xuICAgIH1cbiAgICBvbkNhbmNlbChoYW5kbGVyKSB7XG4gICAgICAgIGlmICh0aGlzLmNhbmNlbGxlZCkge1xuICAgICAgICAgICAgaGFuZGxlcigpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5vbmNlKFwiY2FuY2VsXCIsIGhhbmRsZXIpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNyZWF0ZVByb21pc2UoY2FsbGJhY2spIHtcbiAgICAgICAgaWYgKHRoaXMuY2FuY2VsbGVkKSB7XG4gICAgICAgICAgICByZXR1cm4gKF9ibHVlYmlyZExzdCB8fCBfbG9hZF9ibHVlYmlyZExzdCgpKS5kZWZhdWx0LnJlamVjdChuZXcgQ2FuY2VsbGF0aW9uRXJyb3IoKSk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGNhbmNlbEhhbmRsZXIgPSBudWxsO1xuICAgICAgICByZXR1cm4gbmV3IChfYmx1ZWJpcmRMc3QgfHwgX2xvYWRfYmx1ZWJpcmRMc3QoKSkuZGVmYXVsdCgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICBsZXQgYWRkZWRDYW5jZWxIYW5kbGVyID0gbnVsbDtcbiAgICAgICAgICAgIGNhbmNlbEhhbmRsZXIgPSAoKSA9PiB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGFkZGVkQ2FuY2VsSGFuZGxlciAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhZGRlZENhbmNlbEhhbmRsZXIoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFkZGVkQ2FuY2VsSGFuZGxlciA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgICAgICAgICByZWplY3QobmV3IENhbmNlbGxhdGlvbkVycm9yKCkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBpZiAodGhpcy5jYW5jZWxsZWQpIHtcbiAgICAgICAgICAgICAgICBjYW5jZWxIYW5kbGVyKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5vbkNhbmNlbChjYW5jZWxIYW5kbGVyKTtcbiAgICAgICAgICAgIGNhbGxiYWNrKHJlc29sdmUsIHJlamVjdCwgY2FsbGJhY2sgPT4ge1xuICAgICAgICAgICAgICAgIGFkZGVkQ2FuY2VsSGFuZGxlciA9IGNhbGxiYWNrO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pLmZpbmFsbHkoKCkgPT4ge1xuICAgICAgICAgICAgaWYgKGNhbmNlbEhhbmRsZXIgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRoaXMucmVtb3ZlTGlzdGVuZXIoXCJjYW5jZWxcIiwgY2FuY2VsSGFuZGxlcik7XG4gICAgICAgICAgICAgICAgY2FuY2VsSGFuZGxlciA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICByZW1vdmVQYXJlbnRDYW5jZWxIYW5kbGVyKCkge1xuICAgICAgICBjb25zdCBwYXJlbnQgPSB0aGlzLl9wYXJlbnQ7XG4gICAgICAgIGlmIChwYXJlbnQgIT0gbnVsbCAmJiB0aGlzLnBhcmVudENhbmNlbEhhbmRsZXIgIT0gbnVsbCkge1xuICAgICAgICAgICAgcGFyZW50LnJlbW92ZUxpc3RlbmVyKFwiY2FuY2VsXCIsIHRoaXMucGFyZW50Q2FuY2VsSGFuZGxlcik7XG4gICAgICAgICAgICB0aGlzLnBhcmVudENhbmNlbEhhbmRsZXIgPSBudWxsO1xuICAgICAgICB9XG4gICAgfVxuICAgIGRpc3Bvc2UoKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICB0aGlzLnJlbW92ZVBhcmVudENhbmNlbEhhbmRsZXIoKTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIHRoaXMucmVtb3ZlQWxsTGlzdGVuZXJzKCk7XG4gICAgICAgICAgICB0aGlzLl9wYXJlbnQgPSBudWxsO1xuICAgICAgICB9XG4gICAgfVxufVxuZXhwb3J0cy5DYW5jZWxsYXRpb25Ub2tlbiA9IENhbmNlbGxhdGlvblRva2VuO1xuY2xhc3MgQ2FuY2VsbGF0aW9uRXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKFwiQ2FuY2VsbGVkXCIpO1xuICAgIH1cbn1cbmV4cG9ydHMuQ2FuY2VsbGF0aW9uRXJyb3IgPSBDYW5jZWxsYXRpb25FcnJvcjsgLy8jIHNvdXJjZU1hcHBpbmdVUkw9Q2FuY2VsbGF0aW9uVG9rZW4uanMubWFwXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2VsZWN0cm9uLXVwZGF0ZXIvbm9kZV9tb2R1bGVzL2J1aWxkZXItdXRpbC1ydW50aW1lL291dC9DYW5jZWxsYXRpb25Ub2tlbi5qcyIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcImV2ZW50c1wiKTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyBleHRlcm5hbCBcImV2ZW50c1wiXG4vLyBtb2R1bGUgaWQgPSA0MVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5EaWdlc3RUcmFuc2Zvcm0gPSBleHBvcnRzLkh0dHBFeGVjdXRvciA9IGV4cG9ydHMuSHR0cEVycm9yID0gdW5kZWZpbmVkO1xuZXhwb3J0cy5jcmVhdGVIdHRwRXJyb3IgPSBjcmVhdGVIdHRwRXJyb3I7XG5leHBvcnRzLnBhcnNlSnNvbiA9IHBhcnNlSnNvbjtcbmV4cG9ydHMuY29uZmlndXJlUmVxdWVzdE9wdGlvbnNGcm9tVXJsID0gY29uZmlndXJlUmVxdWVzdE9wdGlvbnNGcm9tVXJsO1xuZXhwb3J0cy5zYWZlR2V0SGVhZGVyID0gc2FmZUdldEhlYWRlcjtcbmV4cG9ydHMuY29uZmlndXJlUmVxdWVzdE9wdGlvbnMgPSBjb25maWd1cmVSZXF1ZXN0T3B0aW9ucztcbmV4cG9ydHMuc2FmZVN0cmluZ2lmeUpzb24gPSBzYWZlU3RyaW5naWZ5SnNvbjtcblxudmFyIF9jcnlwdG87XG5cbmZ1bmN0aW9uIF9sb2FkX2NyeXB0bygpIHtcbiAgICByZXR1cm4gX2NyeXB0byA9IHJlcXVpcmUoXCJjcnlwdG9cIik7XG59XG5cbnZhciBfZGVidWcyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiZGVidWdcIikpO1xuXG52YXIgX2ZzRXh0cmFQO1xuXG5mdW5jdGlvbiBfbG9hZF9mc0V4dHJhUCgpIHtcbiAgICByZXR1cm4gX2ZzRXh0cmFQID0gcmVxdWlyZShcImZzLWV4dHJhLXBcIik7XG59XG5cbnZhciBfc3RyZWFtO1xuXG5mdW5jdGlvbiBfbG9hZF9zdHJlYW0oKSB7XG4gICAgcmV0dXJuIF9zdHJlYW0gPSByZXF1aXJlKFwic3RyZWFtXCIpO1xufVxuXG52YXIgX3VybDtcblxuZnVuY3Rpb24gX2xvYWRfdXJsKCkge1xuICAgIHJldHVybiBfdXJsID0gcmVxdWlyZShcInVybFwiKTtcbn1cblxudmFyIF9DYW5jZWxsYXRpb25Ub2tlbjtcblxuZnVuY3Rpb24gX2xvYWRfQ2FuY2VsbGF0aW9uVG9rZW4oKSB7XG4gICAgcmV0dXJuIF9DYW5jZWxsYXRpb25Ub2tlbiA9IHJlcXVpcmUoXCIuL0NhbmNlbGxhdGlvblRva2VuXCIpO1xufVxuXG52YXIgX2luZGV4O1xuXG5mdW5jdGlvbiBfbG9hZF9pbmRleCgpIHtcbiAgICByZXR1cm4gX2luZGV4ID0gcmVxdWlyZShcIi4vaW5kZXhcIik7XG59XG5cbnZhciBfUHJvZ3Jlc3NDYWxsYmFja1RyYW5zZm9ybTtcblxuZnVuY3Rpb24gX2xvYWRfUHJvZ3Jlc3NDYWxsYmFja1RyYW5zZm9ybSgpIHtcbiAgICByZXR1cm4gX1Byb2dyZXNzQ2FsbGJhY2tUcmFuc2Zvcm0gPSByZXF1aXJlKFwiLi9Qcm9ncmVzc0NhbGxiYWNrVHJhbnNmb3JtXCIpO1xufVxuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5jb25zdCBkZWJ1ZyA9ICgwLCBfZGVidWcyLmRlZmF1bHQpKFwiZWxlY3Ryb24tYnVpbGRlclwiKTtcbmZ1bmN0aW9uIGNyZWF0ZUh0dHBFcnJvcihyZXNwb25zZSwgZGVzY3JpcHRpb24gPSBudWxsKSB7XG4gICAgcmV0dXJuIG5ldyBIdHRwRXJyb3IocmVzcG9uc2Uuc3RhdHVzQ29kZSB8fCAtMSwgYCR7cmVzcG9uc2Uuc3RhdHVzQ29kZX0gJHtyZXNwb25zZS5zdGF0dXNNZXNzYWdlfWAgKyAoZGVzY3JpcHRpb24gPT0gbnVsbCA/IFwiXCIgOiBcIlxcblwiICsgSlNPTi5zdHJpbmdpZnkoZGVzY3JpcHRpb24sIG51bGwsIFwiICBcIikpICsgXCJcXG5IZWFkZXJzOiBcIiArIHNhZmVTdHJpbmdpZnlKc29uKHJlc3BvbnNlLmhlYWRlcnMpLCBkZXNjcmlwdGlvbik7XG59XG5jb25zdCBIVFRQX1NUQVRVU19DT0RFUyA9IG5ldyBNYXAoW1s0MjksIFwiVG9vIG1hbnkgcmVxdWVzdHNcIl0sIFs0MDAsIFwiQmFkIHJlcXVlc3RcIl0sIFs0MDMsIFwiRm9yYmlkZGVuXCJdLCBbNDA0LCBcIk5vdCBmb3VuZFwiXSwgWzQwNSwgXCJNZXRob2Qgbm90IGFsbG93ZWRcIl0sIFs0MDYsIFwiTm90IGFjY2VwdGFibGVcIl0sIFs0MDgsIFwiUmVxdWVzdCB0aW1lb3V0XCJdLCBbNDEzLCBcIlJlcXVlc3QgZW50aXR5IHRvbyBsYXJnZVwiXSwgWzUwMCwgXCJJbnRlcm5hbCBzZXJ2ZXIgZXJyb3JcIl0sIFs1MDIsIFwiQmFkIGdhdGV3YXlcIl0sIFs1MDMsIFwiU2VydmljZSB1bmF2YWlsYWJsZVwiXSwgWzUwNCwgXCJHYXRld2F5IHRpbWVvdXRcIl0sIFs1MDUsIFwiSFRUUCB2ZXJzaW9uIG5vdCBzdXBwb3J0ZWRcIl1dKTtcbmNsYXNzIEh0dHBFcnJvciBleHRlbmRzIEVycm9yIHtcbiAgICBjb25zdHJ1Y3RvcihzdGF0dXNDb2RlLCBtZXNzYWdlID0gYEhUVFAgZXJyb3I6ICR7SFRUUF9TVEFUVVNfQ09ERVMuZ2V0KHN0YXR1c0NvZGUpIHx8IHN0YXR1c0NvZGV9YCwgZGVzY3JpcHRpb24gPSBudWxsKSB7XG4gICAgICAgIHN1cGVyKG1lc3NhZ2UpO1xuICAgICAgICB0aGlzLnN0YXR1c0NvZGUgPSBzdGF0dXNDb2RlO1xuICAgICAgICB0aGlzLmRlc2NyaXB0aW9uID0gZGVzY3JpcHRpb247XG4gICAgICAgIHRoaXMubmFtZSA9IFwiSHR0cEVycm9yXCI7XG4gICAgfVxufVxuZXhwb3J0cy5IdHRwRXJyb3IgPSBIdHRwRXJyb3I7XG5mdW5jdGlvbiBwYXJzZUpzb24ocmVzdWx0KSB7XG4gICAgcmV0dXJuIHJlc3VsdC50aGVuKGl0ID0+IGl0ID09IG51bGwgfHwgaXQubGVuZ3RoID09PSAwID8gbnVsbCA6IEpTT04ucGFyc2UoaXQpKTtcbn1cbmNsYXNzIEh0dHBFeGVjdXRvciB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMubWF4UmVkaXJlY3RzID0gMTA7XG4gICAgfVxuICAgIHJlcXVlc3Qob3B0aW9ucywgY2FuY2VsbGF0aW9uVG9rZW4gPSBuZXcgKF9DYW5jZWxsYXRpb25Ub2tlbiB8fCBfbG9hZF9DYW5jZWxsYXRpb25Ub2tlbigpKS5DYW5jZWxsYXRpb25Ub2tlbigpLCBkYXRhKSB7XG4gICAgICAgIGNvbmZpZ3VyZVJlcXVlc3RPcHRpb25zKG9wdGlvbnMpO1xuICAgICAgICBjb25zdCBlbmNvZGVkRGF0YSA9IGRhdGEgPT0gbnVsbCA/IHVuZGVmaW5lZCA6IEJ1ZmZlci5mcm9tKEpTT04uc3RyaW5naWZ5KGRhdGEpKTtcbiAgICAgICAgaWYgKGVuY29kZWREYXRhICE9IG51bGwpIHtcbiAgICAgICAgICAgIG9wdGlvbnMubWV0aG9kID0gXCJwb3N0XCI7XG4gICAgICAgICAgICBvcHRpb25zLmhlYWRlcnNbXCJDb250ZW50LVR5cGVcIl0gPSBcImFwcGxpY2F0aW9uL2pzb25cIjtcbiAgICAgICAgICAgIG9wdGlvbnMuaGVhZGVyc1tcIkNvbnRlbnQtTGVuZ3RoXCJdID0gZW5jb2RlZERhdGEubGVuZ3RoO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmRvQXBpUmVxdWVzdChvcHRpb25zLCBjYW5jZWxsYXRpb25Ub2tlbiwgaXQgPT4gaXQuZW5kKGVuY29kZWREYXRhKSk7XG4gICAgfVxuICAgIGRvQXBpUmVxdWVzdChvcHRpb25zLCBjYW5jZWxsYXRpb25Ub2tlbiwgcmVxdWVzdFByb2Nlc3NvciwgcmVkaXJlY3RDb3VudCA9IDApIHtcbiAgICAgICAgaWYgKGRlYnVnLmVuYWJsZWQpIHtcbiAgICAgICAgICAgIGRlYnVnKGBSZXF1ZXN0OiAke3NhZmVTdHJpbmdpZnlKc29uKG9wdGlvbnMpfWApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjYW5jZWxsYXRpb25Ub2tlbi5jcmVhdGVQcm9taXNlKChyZXNvbHZlLCByZWplY3QsIG9uQ2FuY2VsKSA9PiB7XG4gICAgICAgICAgICBjb25zdCByZXF1ZXN0ID0gdGhpcy5kb1JlcXVlc3Qob3B0aW9ucywgcmVzcG9uc2UgPT4ge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaGFuZGxlUmVzcG9uc2UocmVzcG9uc2UsIG9wdGlvbnMsIGNhbmNlbGxhdGlvblRva2VuLCByZXNvbHZlLCByZWplY3QsIHJlZGlyZWN0Q291bnQsIHJlcXVlc3RQcm9jZXNzb3IpO1xuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVqZWN0KGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdGhpcy5hZGRFcnJvckFuZFRpbWVvdXRIYW5kbGVycyhyZXF1ZXN0LCByZWplY3QpO1xuICAgICAgICAgICAgdGhpcy5hZGRSZWRpcmVjdEhhbmRsZXJzKHJlcXVlc3QsIG9wdGlvbnMsIHJlamVjdCwgcmVkaXJlY3RDb3VudCwgb3B0aW9ucyA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5kb0FwaVJlcXVlc3Qob3B0aW9ucywgY2FuY2VsbGF0aW9uVG9rZW4sIHJlcXVlc3RQcm9jZXNzb3IsIHJlZGlyZWN0Q291bnQpLnRoZW4ocmVzb2x2ZSkuY2F0Y2gocmVqZWN0KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmVxdWVzdFByb2Nlc3NvcihyZXF1ZXN0LCByZWplY3QpO1xuICAgICAgICAgICAgb25DYW5jZWwoKCkgPT4gcmVxdWVzdC5hYm9ydCgpKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8vIG5vaW5zcGVjdGlvbiBKU1VudXNlZExvY2FsU3ltYm9sc1xuICAgIGFkZFJlZGlyZWN0SGFuZGxlcnMocmVxdWVzdCwgb3B0aW9ucywgcmVqZWN0LCByZWRpcmVjdENvdW50LCBoYW5kbGVyKSB7XG4gICAgICAgIC8vIG5vdCByZXF1aXJlZCBmb3IgTm9kZUpTXG4gICAgfVxuICAgIGFkZEVycm9yQW5kVGltZW91dEhhbmRsZXJzKHJlcXVlc3QsIHJlamVjdCkge1xuICAgICAgICB0aGlzLmFkZFRpbWVPdXRIYW5kbGVyKHJlcXVlc3QsIHJlamVjdCk7XG4gICAgICAgIHJlcXVlc3Qub24oXCJlcnJvclwiLCByZWplY3QpO1xuICAgICAgICByZXF1ZXN0Lm9uKFwiYWJvcnRlZFwiLCAoKSA9PiB7XG4gICAgICAgICAgICByZWplY3QobmV3IEVycm9yKFwiUmVxdWVzdCBoYXMgYmVlbiBhYm9ydGVkIGJ5IHRoZSBzZXJ2ZXJcIikpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgaGFuZGxlUmVzcG9uc2UocmVzcG9uc2UsIG9wdGlvbnMsIGNhbmNlbGxhdGlvblRva2VuLCByZXNvbHZlLCByZWplY3QsIHJlZGlyZWN0Q291bnQsIHJlcXVlc3RQcm9jZXNzb3IpIHtcbiAgICAgICAgaWYgKGRlYnVnLmVuYWJsZWQpIHtcbiAgICAgICAgICAgIGRlYnVnKGBSZXNwb25zZTogJHtyZXNwb25zZS5zdGF0dXNDb2RlfSAke3Jlc3BvbnNlLnN0YXR1c01lc3NhZ2V9LCByZXF1ZXN0IG9wdGlvbnM6ICR7c2FmZVN0cmluZ2lmeUpzb24ob3B0aW9ucyl9YCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gd2UgaGFuZGxlIGFueSBvdGhlciA+PSA0MDAgZXJyb3Igb24gcmVxdWVzdCBlbmQgKHJlYWQgZGV0YWlsZWQgbWVzc2FnZSBpbiB0aGUgcmVzcG9uc2UgYm9keSlcbiAgICAgICAgaWYgKHJlc3BvbnNlLnN0YXR1c0NvZGUgPT09IDQwNCkge1xuICAgICAgICAgICAgLy8gZXJyb3IgaXMgY2xlYXIsIHdlIGRvbid0IG5lZWQgdG8gcmVhZCBkZXRhaWxlZCBlcnJvciBkZXNjcmlwdGlvblxuICAgICAgICAgICAgcmVqZWN0KGNyZWF0ZUh0dHBFcnJvcihyZXNwb25zZSwgYG1ldGhvZDogJHtvcHRpb25zLm1ldGhvZH0gdXJsOiAke29wdGlvbnMucHJvdG9jb2wgfHwgXCJodHRwczpcIn0vLyR7b3B0aW9ucy5ob3N0bmFtZX0ke29wdGlvbnMucGF0aH1cblxuUGxlYXNlIGRvdWJsZSBjaGVjayB0aGF0IHlvdXIgYXV0aGVudGljYXRpb24gdG9rZW4gaXMgY29ycmVjdC4gRHVlIHRvIHNlY3VyaXR5IHJlYXNvbnMgYWN0dWFsIHN0YXR1cyBtYXliZSBub3QgcmVwb3J0ZWQsIGJ1dCA0MDQuXG5gKSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH0gZWxzZSBpZiAocmVzcG9uc2Uuc3RhdHVzQ29kZSA9PT0gMjA0KSB7XG4gICAgICAgICAgICAvLyBvbiBERUxFVEUgcmVxdWVzdFxuICAgICAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJlZGlyZWN0VXJsID0gc2FmZUdldEhlYWRlcihyZXNwb25zZSwgXCJsb2NhdGlvblwiKTtcbiAgICAgICAgaWYgKHJlZGlyZWN0VXJsICE9IG51bGwpIHtcbiAgICAgICAgICAgIGlmIChyZWRpcmVjdENvdW50ID4gMTApIHtcbiAgICAgICAgICAgICAgICByZWplY3QobmV3IEVycm9yKFwiVG9vIG1hbnkgcmVkaXJlY3RzICg+IDEwKVwiKSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5kb0FwaVJlcXVlc3QoSHR0cEV4ZWN1dG9yLnByZXBhcmVSZWRpcmVjdFVybE9wdGlvbnMocmVkaXJlY3RVcmwsIG9wdGlvbnMpLCBjYW5jZWxsYXRpb25Ub2tlbiwgcmVxdWVzdFByb2Nlc3NvciwgcmVkaXJlY3RDb3VudCkudGhlbihyZXNvbHZlKS5jYXRjaChyZWplY3QpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGxldCBkYXRhID0gXCJcIjtcbiAgICAgICAgcmVzcG9uc2Uuc2V0RW5jb2RpbmcoXCJ1dGY4XCIpO1xuICAgICAgICByZXNwb25zZS5vbihcImRhdGFcIiwgY2h1bmsgPT4gZGF0YSArPSBjaHVuayk7XG4gICAgICAgIHJlc3BvbnNlLm9uKFwiZW5kXCIsICgpID0+IHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgaWYgKHJlc3BvbnNlLnN0YXR1c0NvZGUgIT0gbnVsbCAmJiByZXNwb25zZS5zdGF0dXNDb2RlID49IDQwMCkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBjb250ZW50VHlwZSA9IHNhZmVHZXRIZWFkZXIocmVzcG9uc2UsIFwiY29udGVudC10eXBlXCIpO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBpc0pzb24gPSBjb250ZW50VHlwZSAhPSBudWxsICYmIChBcnJheS5pc0FycmF5KGNvbnRlbnRUeXBlKSA/IGNvbnRlbnRUeXBlLmZpbmQoaXQgPT4gaXQuaW5jbHVkZXMoXCJqc29uXCIpKSAhPSBudWxsIDogY29udGVudFR5cGUuaW5jbHVkZXMoXCJqc29uXCIpKTtcbiAgICAgICAgICAgICAgICAgICAgcmVqZWN0KGNyZWF0ZUh0dHBFcnJvcihyZXNwb25zZSwgaXNKc29uID8gSlNPTi5wYXJzZShkYXRhKSA6IGRhdGEpKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXNvbHZlKGRhdGEubGVuZ3RoID09PSAwID8gbnVsbCA6IGRhdGEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICByZWplY3QoZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBkb0Rvd25sb2FkKHJlcXVlc3RPcHRpb25zLCBkZXN0aW5hdGlvbiwgcmVkaXJlY3RDb3VudCwgb3B0aW9ucywgY2FsbGJhY2ssIG9uQ2FuY2VsKSB7XG4gICAgICAgIGNvbnN0IHJlcXVlc3QgPSB0aGlzLmRvUmVxdWVzdChyZXF1ZXN0T3B0aW9ucywgcmVzcG9uc2UgPT4ge1xuICAgICAgICAgICAgaWYgKHJlc3BvbnNlLnN0YXR1c0NvZGUgPj0gNDAwKSB7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2sobmV3IEVycm9yKGBDYW5ub3QgZG93bmxvYWQgXCIke3JlcXVlc3RPcHRpb25zLnByb3RvY29sIHx8IFwiaHR0cHM6XCJ9Ly8ke3JlcXVlc3RPcHRpb25zLmhvc3RuYW1lfSR7cmVxdWVzdE9wdGlvbnMucGF0aH1cIiwgc3RhdHVzICR7cmVzcG9uc2Uuc3RhdHVzQ29kZX06ICR7cmVzcG9uc2Uuc3RhdHVzTWVzc2FnZX1gKSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcmVkaXJlY3RVcmwgPSBzYWZlR2V0SGVhZGVyKHJlc3BvbnNlLCBcImxvY2F0aW9uXCIpO1xuICAgICAgICAgICAgaWYgKHJlZGlyZWN0VXJsICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBpZiAocmVkaXJlY3RDb3VudCA8IHRoaXMubWF4UmVkaXJlY3RzKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZG9Eb3dubG9hZChIdHRwRXhlY3V0b3IucHJlcGFyZVJlZGlyZWN0VXJsT3B0aW9ucyhyZWRpcmVjdFVybCwgcmVxdWVzdE9wdGlvbnMpLCBkZXN0aW5hdGlvbiwgcmVkaXJlY3RDb3VudCsrLCBvcHRpb25zLCBjYWxsYmFjaywgb25DYW5jZWwpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKG5ldyBFcnJvcihgVG9vIG1hbnkgcmVkaXJlY3RzICg+ICR7dGhpcy5tYXhSZWRpcmVjdHN9KWApKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uZmlndXJlUGlwZXMob3B0aW9ucywgcmVzcG9uc2UsIGRlc3RpbmF0aW9uLCBjYWxsYmFjaywgb3B0aW9ucy5jYW5jZWxsYXRpb25Ub2tlbik7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmFkZEVycm9yQW5kVGltZW91dEhhbmRsZXJzKHJlcXVlc3QsIGNhbGxiYWNrKTtcbiAgICAgICAgdGhpcy5hZGRSZWRpcmVjdEhhbmRsZXJzKHJlcXVlc3QsIHJlcXVlc3RPcHRpb25zLCBjYWxsYmFjaywgcmVkaXJlY3RDb3VudCwgcmVxdWVzdE9wdGlvbnMgPT4ge1xuICAgICAgICAgICAgdGhpcy5kb0Rvd25sb2FkKHJlcXVlc3RPcHRpb25zLCBkZXN0aW5hdGlvbiwgcmVkaXJlY3RDb3VudCsrLCBvcHRpb25zLCBjYWxsYmFjaywgb25DYW5jZWwpO1xuICAgICAgICB9KTtcbiAgICAgICAgb25DYW5jZWwoKCkgPT4gcmVxdWVzdC5hYm9ydCgpKTtcbiAgICAgICAgcmVxdWVzdC5lbmQoKTtcbiAgICB9XG4gICAgYWRkVGltZU91dEhhbmRsZXIocmVxdWVzdCwgY2FsbGJhY2spIHtcbiAgICAgICAgcmVxdWVzdC5vbihcInNvY2tldFwiLCBzb2NrZXQgPT4ge1xuICAgICAgICAgICAgc29ja2V0LnNldFRpbWVvdXQoNjAgKiAxMDAwLCAoKSA9PiB7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2sobmV3IEVycm9yKFwiUmVxdWVzdCB0aW1lZCBvdXRcIikpO1xuICAgICAgICAgICAgICAgIHJlcXVlc3QuYWJvcnQoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgc3RhdGljIHByZXBhcmVSZWRpcmVjdFVybE9wdGlvbnMocmVkaXJlY3RVcmwsIG9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgbmV3T3B0aW9ucyA9IGNvbmZpZ3VyZVJlcXVlc3RPcHRpb25zRnJvbVVybChyZWRpcmVjdFVybCwgT2JqZWN0LmFzc2lnbih7fSwgb3B0aW9ucykpO1xuICAgICAgICBpZiAobmV3T3B0aW9ucy5oZWFkZXJzICE9IG51bGwgJiYgbmV3T3B0aW9ucy5oZWFkZXJzLkF1dGhvcml6YXRpb24gIT0gbnVsbCAmJiBuZXdPcHRpb25zLmhlYWRlcnMuQXV0aG9yaXphdGlvbi5zdGFydHNXaXRoKFwidG9rZW5cIikpIHtcbiAgICAgICAgICAgIGNvbnN0IHBhcnNlZE5ld1VybCA9IG5ldyAoX3VybCB8fCBfbG9hZF91cmwoKSkuVVJMKHJlZGlyZWN0VXJsKTtcbiAgICAgICAgICAgIGlmIChwYXJzZWROZXdVcmwuaG9zdG5hbWUuZW5kc1dpdGgoXCIuYW1hem9uYXdzLmNvbVwiKSkge1xuICAgICAgICAgICAgICAgIGRlbGV0ZSBuZXdPcHRpb25zLmhlYWRlcnMuQXV0aG9yaXphdGlvbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3T3B0aW9ucztcbiAgICB9XG59XG5leHBvcnRzLkh0dHBFeGVjdXRvciA9IEh0dHBFeGVjdXRvcjtcbmZ1bmN0aW9uIGNvbmZpZ3VyZVJlcXVlc3RPcHRpb25zRnJvbVVybCh1cmwsIG9wdGlvbnMpIHtcbiAgICBjb25zdCBwYXJzZWRVcmwgPSAoMCwgKF91cmwgfHwgX2xvYWRfdXJsKCkpLnBhcnNlKSh1cmwpO1xuICAgIG9wdGlvbnMucHJvdG9jb2wgPSBwYXJzZWRVcmwucHJvdG9jb2w7XG4gICAgb3B0aW9ucy5ob3N0bmFtZSA9IHBhcnNlZFVybC5ob3N0bmFtZTtcbiAgICBpZiAocGFyc2VkVXJsLnBvcnQgPT0gbnVsbCkge1xuICAgICAgICBpZiAob3B0aW9ucy5wb3J0ICE9IG51bGwpIHtcbiAgICAgICAgICAgIGRlbGV0ZSBvcHRpb25zLnBvcnQ7XG4gICAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgICBvcHRpb25zLnBvcnQgPSBwYXJzZWRVcmwucG9ydDtcbiAgICB9XG4gICAgb3B0aW9ucy5wYXRoID0gcGFyc2VkVXJsLnBhdGg7XG4gICAgcmV0dXJuIGNvbmZpZ3VyZVJlcXVlc3RPcHRpb25zKG9wdGlvbnMpO1xufVxuY2xhc3MgRGlnZXN0VHJhbnNmb3JtIGV4dGVuZHMgKF9zdHJlYW0gfHwgX2xvYWRfc3RyZWFtKCkpLlRyYW5zZm9ybSB7XG4gICAgY29uc3RydWN0b3IoZXhwZWN0ZWQsIGFsZ29yaXRobSA9IFwic2hhNTEyXCIsIGVuY29kaW5nID0gXCJiYXNlNjRcIikge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLmV4cGVjdGVkID0gZXhwZWN0ZWQ7XG4gICAgICAgIHRoaXMuYWxnb3JpdGhtID0gYWxnb3JpdGhtO1xuICAgICAgICB0aGlzLmVuY29kaW5nID0gZW5jb2Rpbmc7XG4gICAgICAgIHRoaXMuaXNWYWxpZGF0ZU9uRW5kID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5kaWdlc3RlciA9ICgwLCAoX2NyeXB0byB8fCBfbG9hZF9jcnlwdG8oKSkuY3JlYXRlSGFzaCkoYWxnb3JpdGhtKTtcbiAgICB9XG4gICAgLy8gbm9pbnNwZWN0aW9uIEpTVW51c2VkR2xvYmFsU3ltYm9sc1xuICAgIGdldCBhY3R1YWwoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9hY3R1YWw7XG4gICAgfVxuICAgIC8vIG5vaW5zcGVjdGlvbiBKU1VudXNlZEdsb2JhbFN5bWJvbHNcbiAgICBfdHJhbnNmb3JtKGNodW5rLCBlbmNvZGluZywgY2FsbGJhY2spIHtcbiAgICAgICAgdGhpcy5kaWdlc3Rlci51cGRhdGUoY2h1bmspO1xuICAgICAgICBjYWxsYmFjayhudWxsLCBjaHVuayk7XG4gICAgfVxuICAgIC8vIG5vaW5zcGVjdGlvbiBKU1VudXNlZEdsb2JhbFN5bWJvbHNcbiAgICBfZmx1c2goY2FsbGJhY2spIHtcbiAgICAgICAgdGhpcy5fYWN0dWFsID0gdGhpcy5kaWdlc3Rlci5kaWdlc3QodGhpcy5lbmNvZGluZyk7XG4gICAgICAgIGlmICh0aGlzLmlzVmFsaWRhdGVPbkVuZCkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICB0aGlzLnZhbGlkYXRlKCk7XG4gICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2soZSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNhbGxiYWNrKG51bGwpO1xuICAgIH1cbiAgICB2YWxpZGF0ZSgpIHtcbiAgICAgICAgaWYgKHRoaXMuX2FjdHVhbCA9PSBudWxsKSB7XG4gICAgICAgICAgICB0aHJvdyAoMCwgKF9pbmRleCB8fCBfbG9hZF9pbmRleCgpKS5uZXdFcnJvcikoXCJOb3QgZmluaXNoZWQgeWV0XCIsIFwiRVJSX1NUUkVBTV9OT1RfRklOSVNIRURcIik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuX2FjdHVhbCAhPT0gdGhpcy5leHBlY3RlZCkge1xuICAgICAgICAgICAgdGhyb3cgKDAsIChfaW5kZXggfHwgX2xvYWRfaW5kZXgoKSkubmV3RXJyb3IpKGAke3RoaXMuYWxnb3JpdGhtfSBjaGVja3N1bSBtaXNtYXRjaCwgZXhwZWN0ZWQgJHt0aGlzLmV4cGVjdGVkfSwgZ290ICR7dGhpcy5fYWN0dWFsfWAsIFwiRVJSX0NIRUNLU1VNX01JU01BVENIXCIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbn1cbmV4cG9ydHMuRGlnZXN0VHJhbnNmb3JtID0gRGlnZXN0VHJhbnNmb3JtO1xuZnVuY3Rpb24gY2hlY2tTaGEyKHNoYTJIZWFkZXIsIHNoYTIsIGNhbGxiYWNrKSB7XG4gICAgaWYgKHNoYTJIZWFkZXIgIT0gbnVsbCAmJiBzaGEyICE9IG51bGwpIHtcbiAgICAgICAgLy8gdG9kbyB3aHkgYmludHJheSBkb2Vzbid0IHNlbmQgdGhpcyBoZWFkZXIgYWx3YXlzXG4gICAgICAgIGlmIChzaGEySGVhZGVyID09IG51bGwpIHtcbiAgICAgICAgICAgIGNhbGxiYWNrKG5ldyBFcnJvcihcImNoZWNrc3VtIGlzIHJlcXVpcmVkLCBidXQgc2VydmVyIHJlc3BvbnNlIGRvZXNuJ3QgY29udGFpbiBYLUNoZWNrc3VtLVNoYTIgaGVhZGVyXCIpKTtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfSBlbHNlIGlmIChzaGEySGVhZGVyICE9PSBzaGEyKSB7XG4gICAgICAgICAgICBjYWxsYmFjayhuZXcgRXJyb3IoYGNoZWNrc3VtIG1pc21hdGNoOiBleHBlY3RlZCAke3NoYTJ9IGJ1dCBnb3QgJHtzaGEySGVhZGVyfSAoWC1DaGVja3N1bS1TaGEyIGhlYWRlcilgKSk7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG59XG5mdW5jdGlvbiBzYWZlR2V0SGVhZGVyKHJlc3BvbnNlLCBoZWFkZXJLZXkpIHtcbiAgICBjb25zdCB2YWx1ZSA9IHJlc3BvbnNlLmhlYWRlcnNbaGVhZGVyS2V5XTtcbiAgICBpZiAodmFsdWUgPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgIC8vIGVsZWN0cm9uIEFQSVxuICAgICAgICByZXR1cm4gdmFsdWUubGVuZ3RoID09PSAwID8gbnVsbCA6IHZhbHVlW3ZhbHVlLmxlbmd0aCAtIDFdO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG59XG5mdW5jdGlvbiBjb25maWd1cmVQaXBlcyhvcHRpb25zLCByZXNwb25zZSwgZGVzdGluYXRpb24sIGNhbGxiYWNrLCBjYW5jZWxsYXRpb25Ub2tlbikge1xuICAgIGlmICghY2hlY2tTaGEyKHNhZmVHZXRIZWFkZXIocmVzcG9uc2UsIFwiWC1DaGVja3N1bS1TaGEyXCIpLCBvcHRpb25zLnNoYTIsIGNhbGxiYWNrKSkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHN0cmVhbXMgPSBbXTtcbiAgICBpZiAob3B0aW9ucy5vblByb2dyZXNzICE9IG51bGwpIHtcbiAgICAgICAgY29uc3QgY29udGVudExlbmd0aCA9IHNhZmVHZXRIZWFkZXIocmVzcG9uc2UsIFwiY29udGVudC1sZW5ndGhcIik7XG4gICAgICAgIGlmIChjb250ZW50TGVuZ3RoICE9IG51bGwpIHtcbiAgICAgICAgICAgIHN0cmVhbXMucHVzaChuZXcgKF9Qcm9ncmVzc0NhbGxiYWNrVHJhbnNmb3JtIHx8IF9sb2FkX1Byb2dyZXNzQ2FsbGJhY2tUcmFuc2Zvcm0oKSkuUHJvZ3Jlc3NDYWxsYmFja1RyYW5zZm9ybShwYXJzZUludChjb250ZW50TGVuZ3RoLCAxMCksIG9wdGlvbnMuY2FuY2VsbGF0aW9uVG9rZW4sIG9wdGlvbnMub25Qcm9ncmVzcykpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNvbnN0IHNoYTUxMiA9IG9wdGlvbnMuc2hhNTEyO1xuICAgIGlmIChzaGE1MTIgIT0gbnVsbCkge1xuICAgICAgICBzdHJlYW1zLnB1c2gobmV3IERpZ2VzdFRyYW5zZm9ybShzaGE1MTIsIFwic2hhNTEyXCIsIHNoYTUxMi5sZW5ndGggPT09IDEyOCAmJiAhc2hhNTEyLmluY2x1ZGVzKFwiK1wiKSAmJiAhc2hhNTEyLmluY2x1ZGVzKFwiWlwiKSAmJiAhc2hhNTEyLmluY2x1ZGVzKFwiPVwiKSA/IFwiaGV4XCIgOiBcImJhc2U2NFwiKSk7XG4gICAgfSBlbHNlIGlmIChvcHRpb25zLnNoYTIgIT0gbnVsbCkge1xuICAgICAgICBzdHJlYW1zLnB1c2gobmV3IERpZ2VzdFRyYW5zZm9ybShvcHRpb25zLnNoYTIsIFwic2hhMjU2XCIsIFwiaGV4XCIpKTtcbiAgICB9XG4gICAgY29uc3QgZmlsZU91dCA9ICgwLCAoX2ZzRXh0cmFQIHx8IF9sb2FkX2ZzRXh0cmFQKCkpLmNyZWF0ZVdyaXRlU3RyZWFtKShkZXN0aW5hdGlvbik7XG4gICAgc3RyZWFtcy5wdXNoKGZpbGVPdXQpO1xuICAgIGxldCBsYXN0U3RyZWFtID0gcmVzcG9uc2U7XG4gICAgZm9yIChjb25zdCBzdHJlYW0gb2Ygc3RyZWFtcykge1xuICAgICAgICBzdHJlYW0ub24oXCJlcnJvclwiLCBlcnJvciA9PiB7XG4gICAgICAgICAgICBpZiAoIWNhbmNlbGxhdGlvblRva2VuLmNhbmNlbGxlZCkge1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrKGVycm9yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGxhc3RTdHJlYW0gPSBsYXN0U3RyZWFtLnBpcGUoc3RyZWFtKTtcbiAgICB9XG4gICAgZmlsZU91dC5vbihcImZpbmlzaFwiLCAoKSA9PiB7XG4gICAgICAgIGZpbGVPdXQuY2xvc2UoY2FsbGJhY2spO1xuICAgIH0pO1xufVxuZnVuY3Rpb24gY29uZmlndXJlUmVxdWVzdE9wdGlvbnMob3B0aW9ucywgdG9rZW4sIG1ldGhvZCkge1xuICAgIGlmIChtZXRob2QgIT0gbnVsbCkge1xuICAgICAgICBvcHRpb25zLm1ldGhvZCA9IG1ldGhvZDtcbiAgICB9XG4gICAgbGV0IGhlYWRlcnMgPSBvcHRpb25zLmhlYWRlcnM7XG4gICAgaWYgKGhlYWRlcnMgPT0gbnVsbCkge1xuICAgICAgICBoZWFkZXJzID0ge307XG4gICAgICAgIG9wdGlvbnMuaGVhZGVycyA9IGhlYWRlcnM7XG4gICAgfVxuICAgIGlmICh0b2tlbiAhPSBudWxsKSB7XG4gICAgICAgIGhlYWRlcnMuYXV0aG9yaXphdGlvbiA9IHRva2VuLnN0YXJ0c1dpdGgoXCJCYXNpY1wiKSA/IHRva2VuIDogYHRva2VuICR7dG9rZW59YDtcbiAgICB9XG4gICAgaWYgKGhlYWRlcnNbXCJVc2VyLUFnZW50XCJdID09IG51bGwpIHtcbiAgICAgICAgaGVhZGVyc1tcIlVzZXItQWdlbnRcIl0gPSBcImVsZWN0cm9uLWJ1aWxkZXJcIjtcbiAgICB9XG4gICAgaWYgKG1ldGhvZCA9PSBudWxsIHx8IG1ldGhvZCA9PT0gXCJHRVRcIiB8fCBoZWFkZXJzW1wiQ2FjaGUtQ29udHJvbFwiXSA9PSBudWxsKSB7XG4gICAgICAgIGhlYWRlcnNbXCJDYWNoZS1Db250cm9sXCJdID0gXCJuby1jYWNoZVwiO1xuICAgIH1cbiAgICAvLyBkbyBub3Qgc3BlY2lmeSBmb3Igbm9kZSAoaW4gYW55IGNhc2Ugd2UgdXNlIGh0dHBzIG1vZHVsZSlcbiAgICBpZiAob3B0aW9ucy5wcm90b2NvbCA9PSBudWxsICYmIHByb2Nlc3MudmVyc2lvbnMuZWxlY3Ryb24gIT0gbnVsbCkge1xuICAgICAgICBvcHRpb25zLnByb3RvY29sID0gXCJodHRwczpcIjtcbiAgICB9XG4gICAgcmV0dXJuIG9wdGlvbnM7XG59XG5mdW5jdGlvbiBzYWZlU3RyaW5naWZ5SnNvbihkYXRhLCBza2lwcGVkTmFtZXMpIHtcbiAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkoZGF0YSwgKG5hbWUsIHZhbHVlKSA9PiB7XG4gICAgICAgIGlmIChuYW1lLmVuZHNXaXRoKFwiYXV0aG9yaXphdGlvblwiKSB8fCBuYW1lLmVuZHNXaXRoKFwiUGFzc3dvcmRcIikgfHwgbmFtZS5lbmRzV2l0aChcIlBBU1NXT1JEXCIpIHx8IG5hbWUuZW5kc1dpdGgoXCJUb2tlblwiKSB8fCBuYW1lLmluY2x1ZGVzKFwicGFzc3dvcmRcIikgfHwgbmFtZS5pbmNsdWRlcyhcInRva2VuXCIpIHx8IHNraXBwZWROYW1lcyAhPSBudWxsICYmIHNraXBwZWROYW1lcy5oYXMobmFtZSkpIHtcbiAgICAgICAgICAgIHJldHVybiBcIjxzdHJpcHBlZCBzZW5zaXRpdmUgZGF0YT5cIjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfSwgMik7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1odHRwRXhlY3V0b3IuanMubWFwXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2VsZWN0cm9uLXVwZGF0ZXIvbm9kZV9tb2R1bGVzL2J1aWxkZXItdXRpbC1ydW50aW1lL291dC9odHRwRXhlY3V0b3IuanMiLCJcbi8qKlxuICogVGhpcyBpcyB0aGUgY29tbW9uIGxvZ2ljIGZvciBib3RoIHRoZSBOb2RlLmpzIGFuZCB3ZWIgYnJvd3NlclxuICogaW1wbGVtZW50YXRpb25zIG9mIGBkZWJ1ZygpYC5cbiAqXG4gKiBFeHBvc2UgYGRlYnVnKClgIGFzIHRoZSBtb2R1bGUuXG4gKi9cblxuZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gY3JlYXRlRGVidWcuZGVidWcgPSBjcmVhdGVEZWJ1Z1snZGVmYXVsdCddID0gY3JlYXRlRGVidWc7XG5leHBvcnRzLmNvZXJjZSA9IGNvZXJjZTtcbmV4cG9ydHMuZGlzYWJsZSA9IGRpc2FibGU7XG5leHBvcnRzLmVuYWJsZSA9IGVuYWJsZTtcbmV4cG9ydHMuZW5hYmxlZCA9IGVuYWJsZWQ7XG5leHBvcnRzLmh1bWFuaXplID0gcmVxdWlyZSgnbXMnKTtcblxuLyoqXG4gKiBBY3RpdmUgYGRlYnVnYCBpbnN0YW5jZXMuXG4gKi9cbmV4cG9ydHMuaW5zdGFuY2VzID0gW107XG5cbi8qKlxuICogVGhlIGN1cnJlbnRseSBhY3RpdmUgZGVidWcgbW9kZSBuYW1lcywgYW5kIG5hbWVzIHRvIHNraXAuXG4gKi9cblxuZXhwb3J0cy5uYW1lcyA9IFtdO1xuZXhwb3J0cy5za2lwcyA9IFtdO1xuXG4vKipcbiAqIE1hcCBvZiBzcGVjaWFsIFwiJW5cIiBoYW5kbGluZyBmdW5jdGlvbnMsIGZvciB0aGUgZGVidWcgXCJmb3JtYXRcIiBhcmd1bWVudC5cbiAqXG4gKiBWYWxpZCBrZXkgbmFtZXMgYXJlIGEgc2luZ2xlLCBsb3dlciBvciB1cHBlci1jYXNlIGxldHRlciwgaS5lLiBcIm5cIiBhbmQgXCJOXCIuXG4gKi9cblxuZXhwb3J0cy5mb3JtYXR0ZXJzID0ge307XG5cbi8qKlxuICogU2VsZWN0IGEgY29sb3IuXG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZXNwYWNlXG4gKiBAcmV0dXJuIHtOdW1iZXJ9XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBzZWxlY3RDb2xvcihuYW1lc3BhY2UpIHtcbiAgdmFyIGhhc2ggPSAwLCBpO1xuXG4gIGZvciAoaSBpbiBuYW1lc3BhY2UpIHtcbiAgICBoYXNoICA9ICgoaGFzaCA8PCA1KSAtIGhhc2gpICsgbmFtZXNwYWNlLmNoYXJDb2RlQXQoaSk7XG4gICAgaGFzaCB8PSAwOyAvLyBDb252ZXJ0IHRvIDMyYml0IGludGVnZXJcbiAgfVxuXG4gIHJldHVybiBleHBvcnRzLmNvbG9yc1tNYXRoLmFicyhoYXNoKSAlIGV4cG9ydHMuY29sb3JzLmxlbmd0aF07XG59XG5cbi8qKlxuICogQ3JlYXRlIGEgZGVidWdnZXIgd2l0aCB0aGUgZ2l2ZW4gYG5hbWVzcGFjZWAuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IG5hbWVzcGFjZVxuICogQHJldHVybiB7RnVuY3Rpb259XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIGNyZWF0ZURlYnVnKG5hbWVzcGFjZSkge1xuXG4gIHZhciBwcmV2VGltZTtcblxuICBmdW5jdGlvbiBkZWJ1ZygpIHtcbiAgICAvLyBkaXNhYmxlZD9cbiAgICBpZiAoIWRlYnVnLmVuYWJsZWQpIHJldHVybjtcblxuICAgIHZhciBzZWxmID0gZGVidWc7XG5cbiAgICAvLyBzZXQgYGRpZmZgIHRpbWVzdGFtcFxuICAgIHZhciBjdXJyID0gK25ldyBEYXRlKCk7XG4gICAgdmFyIG1zID0gY3VyciAtIChwcmV2VGltZSB8fCBjdXJyKTtcbiAgICBzZWxmLmRpZmYgPSBtcztcbiAgICBzZWxmLnByZXYgPSBwcmV2VGltZTtcbiAgICBzZWxmLmN1cnIgPSBjdXJyO1xuICAgIHByZXZUaW1lID0gY3VycjtcblxuICAgIC8vIHR1cm4gdGhlIGBhcmd1bWVudHNgIGludG8gYSBwcm9wZXIgQXJyYXlcbiAgICB2YXIgYXJncyA9IG5ldyBBcnJheShhcmd1bWVudHMubGVuZ3RoKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFyZ3MubGVuZ3RoOyBpKyspIHtcbiAgICAgIGFyZ3NbaV0gPSBhcmd1bWVudHNbaV07XG4gICAgfVxuXG4gICAgYXJnc1swXSA9IGV4cG9ydHMuY29lcmNlKGFyZ3NbMF0pO1xuXG4gICAgaWYgKCdzdHJpbmcnICE9PSB0eXBlb2YgYXJnc1swXSkge1xuICAgICAgLy8gYW55dGhpbmcgZWxzZSBsZXQncyBpbnNwZWN0IHdpdGggJU9cbiAgICAgIGFyZ3MudW5zaGlmdCgnJU8nKTtcbiAgICB9XG5cbiAgICAvLyBhcHBseSBhbnkgYGZvcm1hdHRlcnNgIHRyYW5zZm9ybWF0aW9uc1xuICAgIHZhciBpbmRleCA9IDA7XG4gICAgYXJnc1swXSA9IGFyZ3NbMF0ucmVwbGFjZSgvJShbYS16QS1aJV0pL2csIGZ1bmN0aW9uKG1hdGNoLCBmb3JtYXQpIHtcbiAgICAgIC8vIGlmIHdlIGVuY291bnRlciBhbiBlc2NhcGVkICUgdGhlbiBkb24ndCBpbmNyZWFzZSB0aGUgYXJyYXkgaW5kZXhcbiAgICAgIGlmIChtYXRjaCA9PT0gJyUlJykgcmV0dXJuIG1hdGNoO1xuICAgICAgaW5kZXgrKztcbiAgICAgIHZhciBmb3JtYXR0ZXIgPSBleHBvcnRzLmZvcm1hdHRlcnNbZm9ybWF0XTtcbiAgICAgIGlmICgnZnVuY3Rpb24nID09PSB0eXBlb2YgZm9ybWF0dGVyKSB7XG4gICAgICAgIHZhciB2YWwgPSBhcmdzW2luZGV4XTtcbiAgICAgICAgbWF0Y2ggPSBmb3JtYXR0ZXIuY2FsbChzZWxmLCB2YWwpO1xuXG4gICAgICAgIC8vIG5vdyB3ZSBuZWVkIHRvIHJlbW92ZSBgYXJnc1tpbmRleF1gIHNpbmNlIGl0J3MgaW5saW5lZCBpbiB0aGUgYGZvcm1hdGBcbiAgICAgICAgYXJncy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICBpbmRleC0tO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG1hdGNoO1xuICAgIH0pO1xuXG4gICAgLy8gYXBwbHkgZW52LXNwZWNpZmljIGZvcm1hdHRpbmcgKGNvbG9ycywgZXRjLilcbiAgICBleHBvcnRzLmZvcm1hdEFyZ3MuY2FsbChzZWxmLCBhcmdzKTtcblxuICAgIHZhciBsb2dGbiA9IGRlYnVnLmxvZyB8fCBleHBvcnRzLmxvZyB8fCBjb25zb2xlLmxvZy5iaW5kKGNvbnNvbGUpO1xuICAgIGxvZ0ZuLmFwcGx5KHNlbGYsIGFyZ3MpO1xuICB9XG5cbiAgZGVidWcubmFtZXNwYWNlID0gbmFtZXNwYWNlO1xuICBkZWJ1Zy5lbmFibGVkID0gZXhwb3J0cy5lbmFibGVkKG5hbWVzcGFjZSk7XG4gIGRlYnVnLnVzZUNvbG9ycyA9IGV4cG9ydHMudXNlQ29sb3JzKCk7XG4gIGRlYnVnLmNvbG9yID0gc2VsZWN0Q29sb3IobmFtZXNwYWNlKTtcbiAgZGVidWcuZGVzdHJveSA9IGRlc3Ryb3k7XG5cbiAgLy8gZW52LXNwZWNpZmljIGluaXRpYWxpemF0aW9uIGxvZ2ljIGZvciBkZWJ1ZyBpbnN0YW5jZXNcbiAgaWYgKCdmdW5jdGlvbicgPT09IHR5cGVvZiBleHBvcnRzLmluaXQpIHtcbiAgICBleHBvcnRzLmluaXQoZGVidWcpO1xuICB9XG5cbiAgZXhwb3J0cy5pbnN0YW5jZXMucHVzaChkZWJ1Zyk7XG5cbiAgcmV0dXJuIGRlYnVnO1xufVxuXG5mdW5jdGlvbiBkZXN0cm95ICgpIHtcbiAgdmFyIGluZGV4ID0gZXhwb3J0cy5pbnN0YW5jZXMuaW5kZXhPZih0aGlzKTtcbiAgaWYgKGluZGV4ICE9PSAtMSkge1xuICAgIGV4cG9ydHMuaW5zdGFuY2VzLnNwbGljZShpbmRleCwgMSk7XG4gICAgcmV0dXJuIHRydWU7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59XG5cbi8qKlxuICogRW5hYmxlcyBhIGRlYnVnIG1vZGUgYnkgbmFtZXNwYWNlcy4gVGhpcyBjYW4gaW5jbHVkZSBtb2Rlc1xuICogc2VwYXJhdGVkIGJ5IGEgY29sb24gYW5kIHdpbGRjYXJkcy5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZXNwYWNlc1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBlbmFibGUobmFtZXNwYWNlcykge1xuICBleHBvcnRzLnNhdmUobmFtZXNwYWNlcyk7XG5cbiAgZXhwb3J0cy5uYW1lcyA9IFtdO1xuICBleHBvcnRzLnNraXBzID0gW107XG5cbiAgdmFyIGk7XG4gIHZhciBzcGxpdCA9ICh0eXBlb2YgbmFtZXNwYWNlcyA9PT0gJ3N0cmluZycgPyBuYW1lc3BhY2VzIDogJycpLnNwbGl0KC9bXFxzLF0rLyk7XG4gIHZhciBsZW4gPSBzcGxpdC5sZW5ndGg7XG5cbiAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgaWYgKCFzcGxpdFtpXSkgY29udGludWU7IC8vIGlnbm9yZSBlbXB0eSBzdHJpbmdzXG4gICAgbmFtZXNwYWNlcyA9IHNwbGl0W2ldLnJlcGxhY2UoL1xcKi9nLCAnLio/Jyk7XG4gICAgaWYgKG5hbWVzcGFjZXNbMF0gPT09ICctJykge1xuICAgICAgZXhwb3J0cy5za2lwcy5wdXNoKG5ldyBSZWdFeHAoJ14nICsgbmFtZXNwYWNlcy5zdWJzdHIoMSkgKyAnJCcpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZXhwb3J0cy5uYW1lcy5wdXNoKG5ldyBSZWdFeHAoJ14nICsgbmFtZXNwYWNlcyArICckJykpO1xuICAgIH1cbiAgfVxuXG4gIGZvciAoaSA9IDA7IGkgPCBleHBvcnRzLmluc3RhbmNlcy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBpbnN0YW5jZSA9IGV4cG9ydHMuaW5zdGFuY2VzW2ldO1xuICAgIGluc3RhbmNlLmVuYWJsZWQgPSBleHBvcnRzLmVuYWJsZWQoaW5zdGFuY2UubmFtZXNwYWNlKTtcbiAgfVxufVxuXG4vKipcbiAqIERpc2FibGUgZGVidWcgb3V0cHV0LlxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gZGlzYWJsZSgpIHtcbiAgZXhwb3J0cy5lbmFibGUoJycpO1xufVxuXG4vKipcbiAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgZ2l2ZW4gbW9kZSBuYW1lIGlzIGVuYWJsZWQsIGZhbHNlIG90aGVyd2lzZS5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZVxuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gZW5hYmxlZChuYW1lKSB7XG4gIGlmIChuYW1lW25hbWUubGVuZ3RoIC0gMV0gPT09ICcqJykge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHZhciBpLCBsZW47XG4gIGZvciAoaSA9IDAsIGxlbiA9IGV4cG9ydHMuc2tpcHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICBpZiAoZXhwb3J0cy5za2lwc1tpXS50ZXN0KG5hbWUpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG4gIGZvciAoaSA9IDAsIGxlbiA9IGV4cG9ydHMubmFtZXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICBpZiAoZXhwb3J0cy5uYW1lc1tpXS50ZXN0KG5hbWUpKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG4vKipcbiAqIENvZXJjZSBgdmFsYC5cbiAqXG4gKiBAcGFyYW0ge01peGVkfSB2YWxcbiAqIEByZXR1cm4ge01peGVkfVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gY29lcmNlKHZhbCkge1xuICBpZiAodmFsIGluc3RhbmNlb2YgRXJyb3IpIHJldHVybiB2YWwuc3RhY2sgfHwgdmFsLm1lc3NhZ2U7XG4gIHJldHVybiB2YWw7XG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvZWxlY3Ryb24tdXBkYXRlci9ub2RlX21vZHVsZXMvZGVidWcvc3JjL2RlYnVnLmpzIiwiLy8gVGhpcyBpcyBhZGFwdGVkIGZyb20gaHR0cHM6Ly9naXRodWIuY29tL25vcm1hbGl6ZS9telxuLy8gQ29weXJpZ2h0IChjKSAyMDE0LTIwMTYgSm9uYXRoYW4gT25nIG1lQGpvbmdsZWJlcnJ5LmNvbSBhbmQgQ29udHJpYnV0b3JzXG5jb25zdCB1ID0gcmVxdWlyZSgndW5pdmVyc2FsaWZ5JykuZnJvbUNhbGxiYWNrXG5jb25zdCBmcyA9IHJlcXVpcmUoJ2dyYWNlZnVsLWZzJylcblxuY29uc3QgYXBpID0gW1xuICAnYWNjZXNzJyxcbiAgJ2FwcGVuZEZpbGUnLFxuICAnY2htb2QnLFxuICAnY2hvd24nLFxuICAnY2xvc2UnLFxuICAnY29weUZpbGUnLFxuICAnZmNobW9kJyxcbiAgJ2ZjaG93bicsXG4gICdmZGF0YXN5bmMnLFxuICAnZnN0YXQnLFxuICAnZnN5bmMnLFxuICAnZnRydW5jYXRlJyxcbiAgJ2Z1dGltZXMnLFxuICAnbGNob3duJyxcbiAgJ2xpbmsnLFxuICAnbHN0YXQnLFxuICAnbWtkaXInLFxuICAnbWtkdGVtcCcsXG4gICdvcGVuJyxcbiAgJ3JlYWRGaWxlJyxcbiAgJ3JlYWRkaXInLFxuICAncmVhZGxpbmsnLFxuICAncmVhbHBhdGgnLFxuICAncmVuYW1lJyxcbiAgJ3JtZGlyJyxcbiAgJ3N0YXQnLFxuICAnc3ltbGluaycsXG4gICd0cnVuY2F0ZScsXG4gICd1bmxpbmsnLFxuICAndXRpbWVzJyxcbiAgJ3dyaXRlRmlsZSdcbl0uZmlsdGVyKGtleSA9PiB7XG4gIC8vIFNvbWUgY29tbWFuZHMgYXJlIG5vdCBhdmFpbGFibGUgb24gc29tZSBzeXN0ZW1zLiBFeDpcbiAgLy8gZnMuY29weUZpbGUgd2FzIGFkZGVkIGluIE5vZGUuanMgdjguNS4wXG4gIC8vIGZzLm1rZHRlbXAgd2FzIGFkZGVkIGluIE5vZGUuanMgdjUuMTAuMFxuICAvLyBmcy5sY2hvd24gaXMgbm90IGF2YWlsYWJsZSBvbiBhdCBsZWFzdCBzb21lIExpbnV4XG4gIHJldHVybiB0eXBlb2YgZnNba2V5XSA9PT0gJ2Z1bmN0aW9uJ1xufSlcblxuLy8gRXhwb3J0IGFsbCBrZXlzOlxuT2JqZWN0LmtleXMoZnMpLmZvckVhY2goa2V5ID0+IHtcbiAgZXhwb3J0c1trZXldID0gZnNba2V5XVxufSlcblxuLy8gVW5pdmVyc2FsaWZ5IGFzeW5jIG1ldGhvZHM6XG5hcGkuZm9yRWFjaChtZXRob2QgPT4ge1xuICBleHBvcnRzW21ldGhvZF0gPSB1KGZzW21ldGhvZF0pXG59KVxuXG4vLyBXZSBkaWZmZXIgZnJvbSBtei9mcyBpbiB0aGF0IHdlIHN0aWxsIHNoaXAgdGhlIG9sZCwgYnJva2VuLCBmcy5leGlzdHMoKVxuLy8gc2luY2Ugd2UgYXJlIGEgZHJvcC1pbiByZXBsYWNlbWVudCBmb3IgdGhlIG5hdGl2ZSBtb2R1bGVcbmV4cG9ydHMuZXhpc3RzID0gZnVuY3Rpb24gKGZpbGVuYW1lLCBjYWxsYmFjaykge1xuICBpZiAodHlwZW9mIGNhbGxiYWNrID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIGZzLmV4aXN0cyhmaWxlbmFtZSwgY2FsbGJhY2spXG4gIH1cbiAgcmV0dXJuIG5ldyBQcm9taXNlKHJlc29sdmUgPT4ge1xuICAgIHJldHVybiBmcy5leGlzdHMoZmlsZW5hbWUsIHJlc29sdmUpXG4gIH0pXG59XG5cbi8vIGZzLnJlYWQoKSAmIGZzLndyaXRlIG5lZWQgc3BlY2lhbCB0cmVhdG1lbnQgZHVlIHRvIG11bHRpcGxlIGNhbGxiYWNrIGFyZ3NcblxuZXhwb3J0cy5yZWFkID0gZnVuY3Rpb24gKGZkLCBidWZmZXIsIG9mZnNldCwgbGVuZ3RoLCBwb3NpdGlvbiwgY2FsbGJhY2spIHtcbiAgaWYgKHR5cGVvZiBjYWxsYmFjayA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiBmcy5yZWFkKGZkLCBidWZmZXIsIG9mZnNldCwgbGVuZ3RoLCBwb3NpdGlvbiwgY2FsbGJhY2spXG4gIH1cbiAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICBmcy5yZWFkKGZkLCBidWZmZXIsIG9mZnNldCwgbGVuZ3RoLCBwb3NpdGlvbiwgKGVyciwgYnl0ZXNSZWFkLCBidWZmZXIpID0+IHtcbiAgICAgIGlmIChlcnIpIHJldHVybiByZWplY3QoZXJyKVxuICAgICAgcmVzb2x2ZSh7IGJ5dGVzUmVhZCwgYnVmZmVyIH0pXG4gICAgfSlcbiAgfSlcbn1cblxuLy8gRnVuY3Rpb24gc2lnbmF0dXJlIGNhbiBiZVxuLy8gZnMud3JpdGUoZmQsIGJ1ZmZlclssIG9mZnNldFssIGxlbmd0aFssIHBvc2l0aW9uXV1dLCBjYWxsYmFjaylcbi8vIE9SXG4vLyBmcy53cml0ZShmZCwgc3RyaW5nWywgcG9zaXRpb25bLCBlbmNvZGluZ11dLCBjYWxsYmFjaylcbi8vIHNvIHdlIG5lZWQgdG8gaGFuZGxlIGJvdGggY2FzZXNcbmV4cG9ydHMud3JpdGUgPSBmdW5jdGlvbiAoZmQsIGJ1ZmZlciwgYSwgYiwgYywgY2FsbGJhY2spIHtcbiAgaWYgKHR5cGVvZiBhcmd1bWVudHNbYXJndW1lbnRzLmxlbmd0aCAtIDFdID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIGZzLndyaXRlKGZkLCBidWZmZXIsIGEsIGIsIGMsIGNhbGxiYWNrKVxuICB9XG5cbiAgLy8gQ2hlY2sgZm9yIG9sZCwgZGVwcmljYXRlZCBmcy53cml0ZShmZCwgc3RyaW5nWywgcG9zaXRpb25bLCBlbmNvZGluZ11dLCBjYWxsYmFjaylcbiAgaWYgKHR5cGVvZiBidWZmZXIgPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIGZzLndyaXRlKGZkLCBidWZmZXIsIGEsIGIsIChlcnIsIGJ5dGVzV3JpdHRlbiwgYnVmZmVyKSA9PiB7XG4gICAgICAgIGlmIChlcnIpIHJldHVybiByZWplY3QoZXJyKVxuICAgICAgICByZXNvbHZlKHsgYnl0ZXNXcml0dGVuLCBidWZmZXIgfSlcbiAgICAgIH0pXG4gICAgfSlcbiAgfVxuXG4gIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgZnMud3JpdGUoZmQsIGJ1ZmZlciwgYSwgYiwgYywgKGVyciwgYnl0ZXNXcml0dGVuLCBidWZmZXIpID0+IHtcbiAgICAgIGlmIChlcnIpIHJldHVybiByZWplY3QoZXJyKVxuICAgICAgcmVzb2x2ZSh7IGJ5dGVzV3JpdHRlbiwgYnVmZmVyIH0pXG4gICAgfSlcbiAgfSlcbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9lbGVjdHJvbi11cGRhdGVyL25vZGVfbW9kdWxlcy9mcy1leHRyYS9saWIvZnMvaW5kZXguanMiLCIndXNlIHN0cmljdCdcblxudmFyIGZzID0gcmVxdWlyZSgnZnMnKVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNsb25lKGZzKVxuXG5mdW5jdGlvbiBjbG9uZSAob2JqKSB7XG4gIGlmIChvYmogPT09IG51bGwgfHwgdHlwZW9mIG9iaiAhPT0gJ29iamVjdCcpXG4gICAgcmV0dXJuIG9ialxuXG4gIGlmIChvYmogaW5zdGFuY2VvZiBPYmplY3QpXG4gICAgdmFyIGNvcHkgPSB7IF9fcHJvdG9fXzogb2JqLl9fcHJvdG9fXyB9XG4gIGVsc2VcbiAgICB2YXIgY29weSA9IE9iamVjdC5jcmVhdGUobnVsbClcblxuICBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhvYmopLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShjb3B5LCBrZXksIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqLCBrZXkpKVxuICB9KVxuXG4gIHJldHVybiBjb3B5XG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvZ3JhY2VmdWwtZnMvZnMuanMiLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCJhc3NlcnRcIik7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gZXh0ZXJuYWwgXCJhc3NlcnRcIlxuLy8gbW9kdWxlIGlkID0gNDZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IGZzID0gcmVxdWlyZSgnZ3JhY2VmdWwtZnMnKVxuY29uc3QgcGF0aCA9IHJlcXVpcmUoJ3BhdGgnKVxuY29uc3QgbWtkaXJwID0gcmVxdWlyZSgnLi4vbWtkaXJzJykubWtkaXJzXG5jb25zdCBwYXRoRXhpc3RzID0gcmVxdWlyZSgnLi4vcGF0aC1leGlzdHMnKS5wYXRoRXhpc3RzXG5jb25zdCB1dGltZXMgPSByZXF1aXJlKCcuLi91dGlsL3V0aW1lcycpLnV0aW1lc01pbGxpc1xuXG5jb25zdCBub3RFeGlzdCA9IFN5bWJvbCgnbm90RXhpc3QnKVxuY29uc3QgZXhpc3RzUmVnID0gU3ltYm9sKCdleGlzdHNSZWcnKVxuXG5mdW5jdGlvbiBjb3B5IChzcmMsIGRlc3QsIG9wdHMsIGNiKSB7XG4gIGlmICh0eXBlb2Ygb3B0cyA9PT0gJ2Z1bmN0aW9uJyAmJiAhY2IpIHtcbiAgICBjYiA9IG9wdHNcbiAgICBvcHRzID0ge31cbiAgfSBlbHNlIGlmICh0eXBlb2Ygb3B0cyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIG9wdHMgPSB7ZmlsdGVyOiBvcHRzfVxuICB9XG5cbiAgY2IgPSBjYiB8fCBmdW5jdGlvbiAoKSB7fVxuICBvcHRzID0gb3B0cyB8fCB7fVxuXG4gIG9wdHMuY2xvYmJlciA9ICdjbG9iYmVyJyBpbiBvcHRzID8gISFvcHRzLmNsb2JiZXIgOiB0cnVlIC8vIGRlZmF1bHQgdG8gdHJ1ZSBmb3Igbm93XG4gIG9wdHMub3ZlcndyaXRlID0gJ292ZXJ3cml0ZScgaW4gb3B0cyA/ICEhb3B0cy5vdmVyd3JpdGUgOiBvcHRzLmNsb2JiZXIgLy8gb3ZlcndyaXRlIGZhbGxzIGJhY2sgdG8gY2xvYmJlclxuXG4gIC8vIFdhcm4gYWJvdXQgdXNpbmcgcHJlc2VydmVUaW1lc3RhbXBzIG9uIDMyLWJpdCBub2RlXG4gIGlmIChvcHRzLnByZXNlcnZlVGltZXN0YW1wcyAmJiBwcm9jZXNzLmFyY2ggPT09ICdpYTMyJykge1xuICAgIGNvbnNvbGUud2FybihgZnMtZXh0cmE6IFVzaW5nIHRoZSBwcmVzZXJ2ZVRpbWVzdGFtcHMgb3B0aW9uIGluIDMyLWJpdCBub2RlIGlzIG5vdCByZWNvbW1lbmRlZDtcXG5cbiAgICBzZWUgaHR0cHM6Ly9naXRodWIuY29tL2pwcmljaGFyZHNvbi9ub2RlLWZzLWV4dHJhL2lzc3Vlcy8yNjlgKVxuICB9XG5cbiAgc3JjID0gcGF0aC5yZXNvbHZlKHNyYylcbiAgZGVzdCA9IHBhdGgucmVzb2x2ZShkZXN0KVxuXG4gIC8vIGRvbid0IGFsbG93IHNyYyBhbmQgZGVzdCB0byBiZSB0aGUgc2FtZVxuICBpZiAoc3JjID09PSBkZXN0KSByZXR1cm4gY2IobmV3IEVycm9yKCdTb3VyY2UgYW5kIGRlc3RpbmF0aW9uIG11c3Qgbm90IGJlIHRoZSBzYW1lLicpKVxuXG4gIGlmIChvcHRzLmZpbHRlcikgcmV0dXJuIGhhbmRsZUZpbHRlcihjaGVja1BhcmVudERpciwgc3JjLCBkZXN0LCBvcHRzLCBjYilcbiAgcmV0dXJuIGNoZWNrUGFyZW50RGlyKHNyYywgZGVzdCwgb3B0cywgY2IpXG59XG5cbmZ1bmN0aW9uIGNoZWNrUGFyZW50RGlyIChzcmMsIGRlc3QsIG9wdHMsIGNiKSB7XG4gIGNvbnN0IGRlc3RQYXJlbnQgPSBwYXRoLmRpcm5hbWUoZGVzdClcbiAgcGF0aEV4aXN0cyhkZXN0UGFyZW50LCAoZXJyLCBkaXJFeGlzdHMpID0+IHtcbiAgICBpZiAoZXJyKSByZXR1cm4gY2IoZXJyKVxuICAgIGlmIChkaXJFeGlzdHMpIHJldHVybiBzdGFydENvcHkoc3JjLCBkZXN0LCBvcHRzLCBjYilcbiAgICBta2RpcnAoZGVzdFBhcmVudCwgZXJyID0+IHtcbiAgICAgIGlmIChlcnIpIHJldHVybiBjYihlcnIpXG4gICAgICByZXR1cm4gc3RhcnRDb3B5KHNyYywgZGVzdCwgb3B0cywgY2IpXG4gICAgfSlcbiAgfSlcbn1cblxuZnVuY3Rpb24gc3RhcnRDb3B5IChzcmMsIGRlc3QsIG9wdHMsIGNiKSB7XG4gIGlmIChvcHRzLmZpbHRlcikgcmV0dXJuIGhhbmRsZUZpbHRlcihnZXRTdGF0cywgc3JjLCBkZXN0LCBvcHRzLCBjYilcbiAgcmV0dXJuIGdldFN0YXRzKHNyYywgZGVzdCwgb3B0cywgY2IpXG59XG5cbmZ1bmN0aW9uIGhhbmRsZUZpbHRlciAob25JbmNsdWRlLCBzcmMsIGRlc3QsIG9wdHMsIGNiKSB7XG4gIFByb21pc2UucmVzb2x2ZShvcHRzLmZpbHRlcihzcmMsIGRlc3QpKVxuICAgIC50aGVuKGluY2x1ZGUgPT4ge1xuICAgICAgaWYgKGluY2x1ZGUpIHJldHVybiBvbkluY2x1ZGUoc3JjLCBkZXN0LCBvcHRzLCBjYilcbiAgICAgIHJldHVybiBjYigpXG4gICAgfSwgZXJyb3IgPT4gY2IoZXJyb3IpKVxufVxuXG5mdW5jdGlvbiBnZXRTdGF0cyAoc3JjLCBkZXN0LCBvcHRzLCBjYikge1xuICBjb25zdCBzdGF0ID0gb3B0cy5kZXJlZmVyZW5jZSA/IGZzLnN0YXQgOiBmcy5sc3RhdFxuICBzdGF0KHNyYywgKGVyciwgc3QpID0+IHtcbiAgICBpZiAoZXJyKSByZXR1cm4gY2IoZXJyKVxuXG4gICAgaWYgKHN0LmlzRGlyZWN0b3J5KCkpIHJldHVybiBvbkRpcihzdCwgc3JjLCBkZXN0LCBvcHRzLCBjYilcbiAgICBlbHNlIGlmIChzdC5pc0ZpbGUoKSB8fFxuICAgICAgICAgICAgIHN0LmlzQ2hhcmFjdGVyRGV2aWNlKCkgfHxcbiAgICAgICAgICAgICBzdC5pc0Jsb2NrRGV2aWNlKCkpIHJldHVybiBvbkZpbGUoc3QsIHNyYywgZGVzdCwgb3B0cywgY2IpXG4gICAgZWxzZSBpZiAoc3QuaXNTeW1ib2xpY0xpbmsoKSkgcmV0dXJuIG9uTGluayhzcmMsIGRlc3QsIG9wdHMsIGNiKVxuICB9KVxufVxuXG5mdW5jdGlvbiBvbkZpbGUgKHNyY1N0YXQsIHNyYywgZGVzdCwgb3B0cywgY2IpIHtcbiAgY2hlY2tEZXN0KGRlc3QsIChlcnIsIHJlc29sdmVkUGF0aCkgPT4ge1xuICAgIGlmIChlcnIpIHJldHVybiBjYihlcnIpXG4gICAgaWYgKHJlc29sdmVkUGF0aCA9PT0gbm90RXhpc3QpIHtcbiAgICAgIHJldHVybiBjb3B5RmlsZShzcmNTdGF0LCBzcmMsIGRlc3QsIG9wdHMsIGNiKVxuICAgIH0gZWxzZSBpZiAocmVzb2x2ZWRQYXRoID09PSBleGlzdHNSZWcpIHtcbiAgICAgIHJldHVybiBtYXlDb3B5RmlsZShzcmNTdGF0LCBzcmMsIGRlc3QsIG9wdHMsIGNiKVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoc3JjID09PSByZXNvbHZlZFBhdGgpIHJldHVybiBjYigpXG4gICAgICByZXR1cm4gbWF5Q29weUZpbGUoc3JjU3RhdCwgc3JjLCBkZXN0LCBvcHRzLCBjYilcbiAgICB9XG4gIH0pXG59XG5cbmZ1bmN0aW9uIG1heUNvcHlGaWxlIChzcmNTdGF0LCBzcmMsIGRlc3QsIG9wdHMsIGNiKSB7XG4gIGlmIChvcHRzLm92ZXJ3cml0ZSkge1xuICAgIGZzLnVubGluayhkZXN0LCBlcnIgPT4ge1xuICAgICAgaWYgKGVycikgcmV0dXJuIGNiKGVycilcbiAgICAgIHJldHVybiBjb3B5RmlsZShzcmNTdGF0LCBzcmMsIGRlc3QsIG9wdHMsIGNiKVxuICAgIH0pXG4gIH0gZWxzZSBpZiAob3B0cy5lcnJvck9uRXhpc3QpIHtcbiAgICByZXR1cm4gY2IobmV3IEVycm9yKGAnJHtkZXN0fScgYWxyZWFkeSBleGlzdHNgKSlcbiAgfSBlbHNlIHJldHVybiBjYigpXG59XG5cbmZ1bmN0aW9uIGNvcHlGaWxlIChzcmNTdGF0LCBzcmMsIGRlc3QsIG9wdHMsIGNiKSB7XG4gIGlmICh0eXBlb2YgZnMuY29weUZpbGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gZnMuY29weUZpbGUoc3JjLCBkZXN0LCBlcnIgPT4ge1xuICAgICAgaWYgKGVycikgcmV0dXJuIGNiKGVycilcbiAgICAgIHJldHVybiBzZXREZXN0TW9kZUFuZFRpbWVzdGFtcHMoc3JjU3RhdCwgZGVzdCwgb3B0cywgY2IpXG4gICAgfSlcbiAgfVxuICByZXR1cm4gY29weUZpbGVGYWxsYmFjayhzcmNTdGF0LCBzcmMsIGRlc3QsIG9wdHMsIGNiKVxufVxuXG5mdW5jdGlvbiBjb3B5RmlsZUZhbGxiYWNrIChzcmNTdGF0LCBzcmMsIGRlc3QsIG9wdHMsIGNiKSB7XG4gIGNvbnN0IHJzID0gZnMuY3JlYXRlUmVhZFN0cmVhbShzcmMpXG4gIHJzLm9uKCdlcnJvcicsIGVyciA9PiBjYihlcnIpKVxuICAgIC5vbmNlKCdvcGVuJywgKCkgPT4ge1xuICAgICAgY29uc3Qgd3MgPSBmcy5jcmVhdGVXcml0ZVN0cmVhbShkZXN0LCB7IG1vZGU6IHNyY1N0YXQubW9kZSB9KVxuICAgICAgd3Mub24oJ2Vycm9yJywgZXJyID0+IGNiKGVycikpXG4gICAgICAgIC5vbignb3BlbicsICgpID0+IHJzLnBpcGUod3MpKVxuICAgICAgICAub25jZSgnY2xvc2UnLCAoKSA9PiBzZXREZXN0TW9kZUFuZFRpbWVzdGFtcHMoc3JjU3RhdCwgZGVzdCwgb3B0cywgY2IpKVxuICAgIH0pXG59XG5cbmZ1bmN0aW9uIHNldERlc3RNb2RlQW5kVGltZXN0YW1wcyAoc3JjU3RhdCwgZGVzdCwgb3B0cywgY2IpIHtcbiAgZnMuY2htb2QoZGVzdCwgc3JjU3RhdC5tb2RlLCBlcnIgPT4ge1xuICAgIGlmIChlcnIpIHJldHVybiBjYihlcnIpXG4gICAgaWYgKG9wdHMucHJlc2VydmVUaW1lc3RhbXBzKSB7XG4gICAgICByZXR1cm4gdXRpbWVzKGRlc3QsIHNyY1N0YXQuYXRpbWUsIHNyY1N0YXQubXRpbWUsIGNiKVxuICAgIH1cbiAgICByZXR1cm4gY2IoKVxuICB9KVxufVxuXG5mdW5jdGlvbiBvbkRpciAoc3JjU3RhdCwgc3JjLCBkZXN0LCBvcHRzLCBjYikge1xuICBjaGVja0Rlc3QoZGVzdCwgKGVyciwgcmVzb2x2ZWRQYXRoKSA9PiB7XG4gICAgaWYgKGVycikgcmV0dXJuIGNiKGVycilcbiAgICBpZiAocmVzb2x2ZWRQYXRoID09PSBub3RFeGlzdCkge1xuICAgICAgaWYgKGlzU3JjU3ViZGlyKHNyYywgZGVzdCkpIHtcbiAgICAgICAgcmV0dXJuIGNiKG5ldyBFcnJvcihgQ2Fubm90IGNvcHkgJyR7c3JjfScgdG8gYSBzdWJkaXJlY3Rvcnkgb2YgaXRzZWxmLCAnJHtkZXN0fScuYCkpXG4gICAgICB9XG4gICAgICByZXR1cm4gbWtEaXJBbmRDb3B5KHNyY1N0YXQsIHNyYywgZGVzdCwgb3B0cywgY2IpXG4gICAgfSBlbHNlIGlmIChyZXNvbHZlZFBhdGggPT09IGV4aXN0c1JlZykge1xuICAgICAgaWYgKGlzU3JjU3ViZGlyKHNyYywgZGVzdCkpIHtcbiAgICAgICAgcmV0dXJuIGNiKG5ldyBFcnJvcihgQ2Fubm90IGNvcHkgJyR7c3JjfScgdG8gYSBzdWJkaXJlY3Rvcnkgb2YgaXRzZWxmLCAnJHtkZXN0fScuYCkpXG4gICAgICB9XG4gICAgICByZXR1cm4gbWF5Q29weURpcihzcmMsIGRlc3QsIG9wdHMsIGNiKVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoc3JjID09PSByZXNvbHZlZFBhdGgpIHJldHVybiBjYigpXG4gICAgICByZXR1cm4gY29weURpcihzcmMsIGRlc3QsIG9wdHMsIGNiKVxuICAgIH1cbiAgfSlcbn1cblxuZnVuY3Rpb24gbWF5Q29weURpciAoc3JjLCBkZXN0LCBvcHRzLCBjYikge1xuICBmcy5zdGF0KGRlc3QsIChlcnIsIHN0KSA9PiB7XG4gICAgaWYgKGVycikgcmV0dXJuIGNiKGVycilcbiAgICBpZiAoIXN0LmlzRGlyZWN0b3J5KCkpIHtcbiAgICAgIHJldHVybiBjYihuZXcgRXJyb3IoYENhbm5vdCBvdmVyd3JpdGUgbm9uLWRpcmVjdG9yeSAnJHtkZXN0fScgd2l0aCBkaXJlY3RvcnkgJyR7c3JjfScuYCkpXG4gICAgfVxuICAgIHJldHVybiBjb3B5RGlyKHNyYywgZGVzdCwgb3B0cywgY2IpXG4gIH0pXG59XG5cbmZ1bmN0aW9uIG1rRGlyQW5kQ29weSAoc3JjU3RhdCwgc3JjLCBkZXN0LCBvcHRzLCBjYikge1xuICBmcy5ta2RpcihkZXN0LCBzcmNTdGF0Lm1vZGUsIGVyciA9PiB7XG4gICAgaWYgKGVycikgcmV0dXJuIGNiKGVycilcbiAgICBmcy5jaG1vZChkZXN0LCBzcmNTdGF0Lm1vZGUsIGVyciA9PiB7XG4gICAgICBpZiAoZXJyKSByZXR1cm4gY2IoZXJyKVxuICAgICAgcmV0dXJuIGNvcHlEaXIoc3JjLCBkZXN0LCBvcHRzLCBjYilcbiAgICB9KVxuICB9KVxufVxuXG5mdW5jdGlvbiBjb3B5RGlyIChzcmMsIGRlc3QsIG9wdHMsIGNiKSB7XG4gIGZzLnJlYWRkaXIoc3JjLCAoZXJyLCBpdGVtcykgPT4ge1xuICAgIGlmIChlcnIpIHJldHVybiBjYihlcnIpXG4gICAgcmV0dXJuIGNvcHlEaXJJdGVtcyhpdGVtcywgc3JjLCBkZXN0LCBvcHRzLCBjYilcbiAgfSlcbn1cblxuZnVuY3Rpb24gY29weURpckl0ZW1zIChpdGVtcywgc3JjLCBkZXN0LCBvcHRzLCBjYikge1xuICBjb25zdCBpdGVtID0gaXRlbXMucG9wKClcbiAgaWYgKCFpdGVtKSByZXR1cm4gY2IoKVxuICBzdGFydENvcHkocGF0aC5qb2luKHNyYywgaXRlbSksIHBhdGguam9pbihkZXN0LCBpdGVtKSwgb3B0cywgZXJyID0+IHtcbiAgICBpZiAoZXJyKSByZXR1cm4gY2IoZXJyKVxuICAgIHJldHVybiBjb3B5RGlySXRlbXMoaXRlbXMsIHNyYywgZGVzdCwgb3B0cywgY2IpXG4gIH0pXG59XG5cbmZ1bmN0aW9uIG9uTGluayAoc3JjLCBkZXN0LCBvcHRzLCBjYikge1xuICBmcy5yZWFkbGluayhzcmMsIChlcnIsIHJlc29sdmVkU3JjUGF0aCkgPT4ge1xuICAgIGlmIChlcnIpIHJldHVybiBjYihlcnIpXG5cbiAgICBpZiAob3B0cy5kZXJlZmVyZW5jZSkge1xuICAgICAgcmVzb2x2ZWRTcmNQYXRoID0gcGF0aC5yZXNvbHZlKHByb2Nlc3MuY3dkKCksIHJlc29sdmVkU3JjUGF0aClcbiAgICB9XG5cbiAgICBjaGVja0Rlc3QoZGVzdCwgKGVyciwgcmVzb2x2ZWREZXN0UGF0aCkgPT4ge1xuICAgICAgaWYgKGVycikgcmV0dXJuIGNiKGVycilcblxuICAgICAgaWYgKHJlc29sdmVkRGVzdFBhdGggPT09IG5vdEV4aXN0IHx8IHJlc29sdmVkRGVzdFBhdGggPT09IGV4aXN0c1JlZykge1xuICAgICAgICAvLyBpZiBkZXN0IGFscmVhZHkgZXhpc3RzLCBmcyB0aHJvd3MgZXJyb3IgYW55d2F5LFxuICAgICAgICAvLyBzbyBubyBuZWVkIHRvIGd1YXJkIGFnYWluc3QgaXQgaGVyZS5cbiAgICAgICAgcmV0dXJuIGZzLnN5bWxpbmsocmVzb2x2ZWRTcmNQYXRoLCBkZXN0LCBjYilcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChvcHRzLmRlcmVmZXJlbmNlKSB7XG4gICAgICAgICAgcmVzb2x2ZWREZXN0UGF0aCA9IHBhdGgucmVzb2x2ZShwcm9jZXNzLmN3ZCgpLCByZXNvbHZlZERlc3RQYXRoKVxuICAgICAgICB9XG4gICAgICAgIGlmIChyZXNvbHZlZERlc3RQYXRoID09PSByZXNvbHZlZFNyY1BhdGgpIHJldHVybiBjYigpXG5cbiAgICAgICAgLy8gcHJldmVudCBjb3B5IGlmIHNyYyBpcyBhIHN1YmRpciBvZiBkZXN0IHNpbmNlIHVubGlua2luZ1xuICAgICAgICAvLyBkZXN0IGluIHRoaXMgY2FzZSB3b3VsZCByZXN1bHQgaW4gcmVtb3Zpbmcgc3JjIGNvbnRlbnRzXG4gICAgICAgIC8vIGFuZCB0aGVyZWZvcmUgYSBicm9rZW4gc3ltbGluayB3b3VsZCBiZSBjcmVhdGVkLlxuICAgICAgICBmcy5zdGF0KGRlc3QsIChlcnIsIHN0KSA9PiB7XG4gICAgICAgICAgaWYgKGVycikgcmV0dXJuIGNiKGVycilcbiAgICAgICAgICBpZiAoc3QuaXNEaXJlY3RvcnkoKSAmJiBpc1NyY1N1YmRpcihyZXNvbHZlZERlc3RQYXRoLCByZXNvbHZlZFNyY1BhdGgpKSB7XG4gICAgICAgICAgICByZXR1cm4gY2IobmV3IEVycm9yKGBDYW5ub3Qgb3ZlcndyaXRlICcke3Jlc29sdmVkRGVzdFBhdGh9JyB3aXRoICcke3Jlc29sdmVkU3JjUGF0aH0nLmApKVxuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gY29weUxpbmsocmVzb2x2ZWRTcmNQYXRoLCBkZXN0LCBjYilcbiAgICAgICAgfSlcbiAgICAgIH1cbiAgICB9KVxuICB9KVxufVxuXG5mdW5jdGlvbiBjb3B5TGluayAocmVzb2x2ZWRTcmNQYXRoLCBkZXN0LCBjYikge1xuICBmcy51bmxpbmsoZGVzdCwgZXJyID0+IHtcbiAgICBpZiAoZXJyKSByZXR1cm4gY2IoZXJyKVxuICAgIHJldHVybiBmcy5zeW1saW5rKHJlc29sdmVkU3JjUGF0aCwgZGVzdCwgY2IpXG4gIH0pXG59XG5cbi8vIGNoZWNrIGlmIGRlc3QgZXhpc3RzIGFuZC9vciBpcyBhIHN5bWxpbmtcbmZ1bmN0aW9uIGNoZWNrRGVzdCAoZGVzdCwgY2IpIHtcbiAgZnMucmVhZGxpbmsoZGVzdCwgKGVyciwgcmVzb2x2ZWRQYXRoKSA9PiB7XG4gICAgaWYgKGVycikge1xuICAgICAgaWYgKGVyci5jb2RlID09PSAnRU5PRU5UJykgcmV0dXJuIGNiKG51bGwsIG5vdEV4aXN0KVxuXG4gICAgICAvLyBkZXN0IGV4aXN0cyBhbmQgaXMgYSByZWd1bGFyIGZpbGUgb3IgZGlyZWN0b3J5LCBXaW5kb3dzIG1heSB0aHJvdyBVTktOT1dOIGVycm9yLlxuICAgICAgaWYgKGVyci5jb2RlID09PSAnRUlOVkFMJyB8fCBlcnIuY29kZSA9PT0gJ1VOS05PV04nKSByZXR1cm4gY2IobnVsbCwgZXhpc3RzUmVnKVxuXG4gICAgICByZXR1cm4gY2IoZXJyKVxuICAgIH1cbiAgICByZXR1cm4gY2IobnVsbCwgcmVzb2x2ZWRQYXRoKSAvLyBkZXN0IGV4aXN0cyBhbmQgaXMgYSBzeW1saW5rXG4gIH0pXG59XG5cbi8vIHJldHVybiB0cnVlIGlmIGRlc3QgaXMgYSBzdWJkaXIgb2Ygc3JjLCBvdGhlcndpc2UgZmFsc2UuXG4vLyBleHRyYWN0IGRlc3QgYmFzZSBkaXIgYW5kIGNoZWNrIGlmIHRoYXQgaXMgdGhlIHNhbWUgYXMgc3JjIGJhc2VuYW1lXG5mdW5jdGlvbiBpc1NyY1N1YmRpciAoc3JjLCBkZXN0KSB7XG4gIGNvbnN0IGJhc2VEaXIgPSBkZXN0LnNwbGl0KHBhdGguZGlybmFtZShzcmMpICsgcGF0aC5zZXApWzFdXG4gIGlmIChiYXNlRGlyKSB7XG4gICAgY29uc3QgZGVzdEJhc2VuYW1lID0gYmFzZURpci5zcGxpdChwYXRoLnNlcClbMF1cbiAgICBpZiAoZGVzdEJhc2VuYW1lKSB7XG4gICAgICByZXR1cm4gc3JjICE9PSBkZXN0ICYmIGRlc3QuaW5kZXhPZihzcmMpID4gLTEgJiYgZGVzdEJhc2VuYW1lID09PSBwYXRoLmJhc2VuYW1lKHNyYylcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cbiAgcmV0dXJuIGZhbHNlXG59XG5cbm1vZHVsZS5leHBvcnRzID0gY29weVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2VsZWN0cm9uLXVwZGF0ZXIvbm9kZV9tb2R1bGVzL2ZzLWV4dHJhL2xpYi9jb3B5L2NvcHkuanMiLCIndXNlIHN0cmljdCdcblxuY29uc3QgcGF0aCA9IHJlcXVpcmUoJ3BhdGgnKVxuXG4vLyBnZXQgZHJpdmUgb24gd2luZG93c1xuZnVuY3Rpb24gZ2V0Um9vdFBhdGggKHApIHtcbiAgcCA9IHBhdGgubm9ybWFsaXplKHBhdGgucmVzb2x2ZShwKSkuc3BsaXQocGF0aC5zZXApXG4gIGlmIChwLmxlbmd0aCA+IDApIHJldHVybiBwWzBdXG4gIHJldHVybiBudWxsXG59XG5cbi8vIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9hLzYyODg4LzEwMzMzIGNvbnRhaW5zIG1vcmUgYWNjdXJhdGVcbi8vIFRPRE86IGV4cGFuZCB0byBpbmNsdWRlIHRoZSByZXN0XG5jb25zdCBJTlZBTElEX1BBVEhfQ0hBUlMgPSAvWzw+OlwifD8qXS9cblxuZnVuY3Rpb24gaW52YWxpZFdpbjMyUGF0aCAocCkge1xuICBjb25zdCBycCA9IGdldFJvb3RQYXRoKHApXG4gIHAgPSBwLnJlcGxhY2UocnAsICcnKVxuICByZXR1cm4gSU5WQUxJRF9QQVRIX0NIQVJTLnRlc3QocClcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGdldFJvb3RQYXRoLFxuICBpbnZhbGlkV2luMzJQYXRoXG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvZWxlY3Ryb24tdXBkYXRlci9ub2RlX21vZHVsZXMvZnMtZXh0cmEvbGliL21rZGlycy93aW4zMi5qcyIsIid1c2Ugc3RyaWN0J1xuXG5jb25zdCBmcyA9IHJlcXVpcmUoJ2dyYWNlZnVsLWZzJylcbmNvbnN0IG9zID0gcmVxdWlyZSgnb3MnKVxuY29uc3QgcGF0aCA9IHJlcXVpcmUoJ3BhdGgnKVxuXG4vLyBIRlMsIGV4dHsyLDN9LCBGQVQgZG8gbm90LCBOb2RlLmpzIHYwLjEwIGRvZXMgbm90XG5mdW5jdGlvbiBoYXNNaWxsaXNSZXNTeW5jICgpIHtcbiAgbGV0IHRtcGZpbGUgPSBwYXRoLmpvaW4oJ21pbGxpcy10ZXN0LXN5bmMnICsgRGF0ZS5ub3coKS50b1N0cmluZygpICsgTWF0aC5yYW5kb20oKS50b1N0cmluZygpLnNsaWNlKDIpKVxuICB0bXBmaWxlID0gcGF0aC5qb2luKG9zLnRtcGRpcigpLCB0bXBmaWxlKVxuXG4gIC8vIDU1MCBtaWxsaXMgcGFzdCBVTklYIGVwb2NoXG4gIGNvbnN0IGQgPSBuZXcgRGF0ZSgxNDM1NDEwMjQzODYyKVxuICBmcy53cml0ZUZpbGVTeW5jKHRtcGZpbGUsICdodHRwczovL2dpdGh1Yi5jb20vanByaWNoYXJkc29uL25vZGUtZnMtZXh0cmEvcHVsbC8xNDEnKVxuICBjb25zdCBmZCA9IGZzLm9wZW5TeW5jKHRtcGZpbGUsICdyKycpXG4gIGZzLmZ1dGltZXNTeW5jKGZkLCBkLCBkKVxuICBmcy5jbG9zZVN5bmMoZmQpXG4gIHJldHVybiBmcy5zdGF0U3luYyh0bXBmaWxlKS5tdGltZSA+IDE0MzU0MTAyNDMwMDBcbn1cblxuZnVuY3Rpb24gaGFzTWlsbGlzUmVzIChjYWxsYmFjaykge1xuICBsZXQgdG1wZmlsZSA9IHBhdGguam9pbignbWlsbGlzLXRlc3QnICsgRGF0ZS5ub3coKS50b1N0cmluZygpICsgTWF0aC5yYW5kb20oKS50b1N0cmluZygpLnNsaWNlKDIpKVxuICB0bXBmaWxlID0gcGF0aC5qb2luKG9zLnRtcGRpcigpLCB0bXBmaWxlKVxuXG4gIC8vIDU1MCBtaWxsaXMgcGFzdCBVTklYIGVwb2NoXG4gIGNvbnN0IGQgPSBuZXcgRGF0ZSgxNDM1NDEwMjQzODYyKVxuICBmcy53cml0ZUZpbGUodG1wZmlsZSwgJ2h0dHBzOi8vZ2l0aHViLmNvbS9qcHJpY2hhcmRzb24vbm9kZS1mcy1leHRyYS9wdWxsLzE0MScsIGVyciA9PiB7XG4gICAgaWYgKGVycikgcmV0dXJuIGNhbGxiYWNrKGVycilcbiAgICBmcy5vcGVuKHRtcGZpbGUsICdyKycsIChlcnIsIGZkKSA9PiB7XG4gICAgICBpZiAoZXJyKSByZXR1cm4gY2FsbGJhY2soZXJyKVxuICAgICAgZnMuZnV0aW1lcyhmZCwgZCwgZCwgZXJyID0+IHtcbiAgICAgICAgaWYgKGVycikgcmV0dXJuIGNhbGxiYWNrKGVycilcbiAgICAgICAgZnMuY2xvc2UoZmQsIGVyciA9PiB7XG4gICAgICAgICAgaWYgKGVycikgcmV0dXJuIGNhbGxiYWNrKGVycilcbiAgICAgICAgICBmcy5zdGF0KHRtcGZpbGUsIChlcnIsIHN0YXRzKSA9PiB7XG4gICAgICAgICAgICBpZiAoZXJyKSByZXR1cm4gY2FsbGJhY2soZXJyKVxuICAgICAgICAgICAgY2FsbGJhY2sobnVsbCwgc3RhdHMubXRpbWUgPiAxNDM1NDEwMjQzMDAwKVxuICAgICAgICAgIH0pXG4gICAgICAgIH0pXG4gICAgICB9KVxuICAgIH0pXG4gIH0pXG59XG5cbmZ1bmN0aW9uIHRpbWVSZW1vdmVNaWxsaXMgKHRpbWVzdGFtcCkge1xuICBpZiAodHlwZW9mIHRpbWVzdGFtcCA9PT0gJ251bWJlcicpIHtcbiAgICByZXR1cm4gTWF0aC5mbG9vcih0aW1lc3RhbXAgLyAxMDAwKSAqIDEwMDBcbiAgfSBlbHNlIGlmICh0aW1lc3RhbXAgaW5zdGFuY2VvZiBEYXRlKSB7XG4gICAgcmV0dXJuIG5ldyBEYXRlKE1hdGguZmxvb3IodGltZXN0YW1wLmdldFRpbWUoKSAvIDEwMDApICogMTAwMClcbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2ZzLWV4dHJhOiB0aW1lUmVtb3ZlTWlsbGlzKCkgdW5rbm93biBwYXJhbWV0ZXIgdHlwZScpXG4gIH1cbn1cblxuZnVuY3Rpb24gdXRpbWVzTWlsbGlzIChwYXRoLCBhdGltZSwgbXRpbWUsIGNhbGxiYWNrKSB7XG4gIC8vIGlmICghSEFTX01JTExJU19SRVMpIHJldHVybiBmcy51dGltZXMocGF0aCwgYXRpbWUsIG10aW1lLCBjYWxsYmFjaylcbiAgZnMub3BlbihwYXRoLCAncisnLCAoZXJyLCBmZCkgPT4ge1xuICAgIGlmIChlcnIpIHJldHVybiBjYWxsYmFjayhlcnIpXG4gICAgZnMuZnV0aW1lcyhmZCwgYXRpbWUsIG10aW1lLCBmdXRpbWVzRXJyID0+IHtcbiAgICAgIGZzLmNsb3NlKGZkLCBjbG9zZUVyciA9PiB7XG4gICAgICAgIGlmIChjYWxsYmFjaykgY2FsbGJhY2soZnV0aW1lc0VyciB8fCBjbG9zZUVycilcbiAgICAgIH0pXG4gICAgfSlcbiAgfSlcbn1cblxuZnVuY3Rpb24gdXRpbWVzTWlsbGlzU3luYyAocGF0aCwgYXRpbWUsIG10aW1lKSB7XG4gIGNvbnN0IGZkID0gZnMub3BlblN5bmMocGF0aCwgJ3IrJylcbiAgZnMuZnV0aW1lc1N5bmMoZmQsIGF0aW1lLCBtdGltZSlcbiAgcmV0dXJuIGZzLmNsb3NlU3luYyhmZClcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGhhc01pbGxpc1JlcyxcbiAgaGFzTWlsbGlzUmVzU3luYyxcbiAgdGltZVJlbW92ZU1pbGxpcyxcbiAgdXRpbWVzTWlsbGlzLFxuICB1dGltZXNNaWxsaXNTeW5jXG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvZWxlY3Ryb24tdXBkYXRlci9ub2RlX21vZHVsZXMvZnMtZXh0cmEvbGliL3V0aWwvdXRpbWVzLmpzIiwibW9kdWxlLmV4cG9ydHMgPSB7XG4gIGNvcHlTeW5jOiByZXF1aXJlKCcuL2NvcHktc3luYycpXG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvZWxlY3Ryb24tdXBkYXRlci9ub2RlX21vZHVsZXMvZnMtZXh0cmEvbGliL2NvcHktc3luYy9pbmRleC5qcyIsIi8qIGVzbGludC1kaXNhYmxlIG5vZGUvbm8tZGVwcmVjYXRlZC1hcGkgKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKHNpemUpIHtcbiAgaWYgKHR5cGVvZiBCdWZmZXIuYWxsb2NVbnNhZmUgPT09ICdmdW5jdGlvbicpIHtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIEJ1ZmZlci5hbGxvY1Vuc2FmZShzaXplKVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHJldHVybiBuZXcgQnVmZmVyKHNpemUpXG4gICAgfVxuICB9XG4gIHJldHVybiBuZXcgQnVmZmVyKHNpemUpXG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvZWxlY3Ryb24tdXBkYXRlci9ub2RlX21vZHVsZXMvZnMtZXh0cmEvbGliL3V0aWwvYnVmZmVyLmpzIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuUHJvZ3Jlc3NDYWxsYmFja1RyYW5zZm9ybSA9IHVuZGVmaW5lZDtcblxudmFyIF9zdHJlYW07XG5cbmZ1bmN0aW9uIF9sb2FkX3N0cmVhbSgpIHtcbiAgICByZXR1cm4gX3N0cmVhbSA9IHJlcXVpcmUoXCJzdHJlYW1cIik7XG59XG5cbmNsYXNzIFByb2dyZXNzQ2FsbGJhY2tUcmFuc2Zvcm0gZXh0ZW5kcyAoX3N0cmVhbSB8fCBfbG9hZF9zdHJlYW0oKSkuVHJhbnNmb3JtIHtcbiAgICBjb25zdHJ1Y3Rvcih0b3RhbCwgY2FuY2VsbGF0aW9uVG9rZW4sIG9uUHJvZ3Jlc3MpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy50b3RhbCA9IHRvdGFsO1xuICAgICAgICB0aGlzLmNhbmNlbGxhdGlvblRva2VuID0gY2FuY2VsbGF0aW9uVG9rZW47XG4gICAgICAgIHRoaXMub25Qcm9ncmVzcyA9IG9uUHJvZ3Jlc3M7XG4gICAgICAgIHRoaXMuc3RhcnQgPSBEYXRlLm5vdygpO1xuICAgICAgICB0aGlzLnRyYW5zZmVycmVkID0gMDtcbiAgICAgICAgdGhpcy5kZWx0YSA9IDA7XG4gICAgICAgIHRoaXMubmV4dFVwZGF0ZSA9IHRoaXMuc3RhcnQgKyAxMDAwO1xuICAgIH1cbiAgICBfdHJhbnNmb3JtKGNodW5rLCBlbmNvZGluZywgY2FsbGJhY2spIHtcbiAgICAgICAgaWYgKHRoaXMuY2FuY2VsbGF0aW9uVG9rZW4uY2FuY2VsbGVkKSB7XG4gICAgICAgICAgICBjYWxsYmFjayhuZXcgRXJyb3IoXCJDYW5jZWxsZWRcIiksIG51bGwpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudHJhbnNmZXJyZWQgKz0gY2h1bmsubGVuZ3RoO1xuICAgICAgICB0aGlzLmRlbHRhICs9IGNodW5rLmxlbmd0aDtcbiAgICAgICAgY29uc3Qgbm93ID0gRGF0ZS5ub3coKTtcbiAgICAgICAgaWYgKG5vdyA+PSB0aGlzLm5leHRVcGRhdGUgJiYgdGhpcy50cmFuc2ZlcnJlZCAhPT0gdGhpcy50b3RhbCAvKiB3aWxsIGJlIGVtaXR0ZWQgb24gX2ZsdXNoICovKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5uZXh0VXBkYXRlID0gbm93ICsgMTAwMDtcbiAgICAgICAgICAgICAgICB0aGlzLm9uUHJvZ3Jlc3Moe1xuICAgICAgICAgICAgICAgICAgICB0b3RhbDogdGhpcy50b3RhbCxcbiAgICAgICAgICAgICAgICAgICAgZGVsdGE6IHRoaXMuZGVsdGEsXG4gICAgICAgICAgICAgICAgICAgIHRyYW5zZmVycmVkOiB0aGlzLnRyYW5zZmVycmVkLFxuICAgICAgICAgICAgICAgICAgICBwZXJjZW50OiB0aGlzLnRyYW5zZmVycmVkIC8gdGhpcy50b3RhbCAqIDEwMCxcbiAgICAgICAgICAgICAgICAgICAgYnl0ZXNQZXJTZWNvbmQ6IE1hdGgucm91bmQodGhpcy50cmFuc2ZlcnJlZCAvICgobm93IC0gdGhpcy5zdGFydCkgLyAxMDAwKSlcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB0aGlzLmRlbHRhID0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgY2FsbGJhY2sobnVsbCwgY2h1bmspO1xuICAgIH1cbiAgICBfZmx1c2goY2FsbGJhY2spIHtcbiAgICAgICAgaWYgKHRoaXMuY2FuY2VsbGF0aW9uVG9rZW4uY2FuY2VsbGVkKSB7XG4gICAgICAgICAgICBjYWxsYmFjayhuZXcgRXJyb3IoXCJDYW5jZWxsZWRcIikpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMub25Qcm9ncmVzcyh7XG4gICAgICAgICAgICB0b3RhbDogdGhpcy50b3RhbCxcbiAgICAgICAgICAgIGRlbHRhOiB0aGlzLmRlbHRhLFxuICAgICAgICAgICAgdHJhbnNmZXJyZWQ6IHRoaXMudG90YWwsXG4gICAgICAgICAgICBwZXJjZW50OiAxMDAsXG4gICAgICAgICAgICBieXRlc1BlclNlY29uZDogTWF0aC5yb3VuZCh0aGlzLnRyYW5zZmVycmVkIC8gKChEYXRlLm5vdygpIC0gdGhpcy5zdGFydCkgLyAxMDAwKSlcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuZGVsdGEgPSAwO1xuICAgICAgICBjYWxsYmFjayhudWxsKTtcbiAgICB9XG59XG5leHBvcnRzLlByb2dyZXNzQ2FsbGJhY2tUcmFuc2Zvcm0gPSBQcm9ncmVzc0NhbGxiYWNrVHJhbnNmb3JtOyAvLyMgc291cmNlTWFwcGluZ1VSTD1Qcm9ncmVzc0NhbGxiYWNrVHJhbnNmb3JtLmpzLm1hcFxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9lbGVjdHJvbi11cGRhdGVyL25vZGVfbW9kdWxlcy9idWlsZGVyLXV0aWwtcnVudGltZS9vdXQvUHJvZ3Jlc3NDYWxsYmFja1RyYW5zZm9ybS5qcyIsIi8vIFN0YW5kYXJkIFlBTUwncyBDb3JlIHNjaGVtYS5cbi8vIGh0dHA6Ly93d3cueWFtbC5vcmcvc3BlYy8xLjIvc3BlYy5odG1sI2lkMjgwNDkyM1xuLy9cbi8vIE5PVEU6IEpTLVlBTUwgZG9lcyBub3Qgc3VwcG9ydCBzY2hlbWEtc3BlY2lmaWMgdGFnIHJlc29sdXRpb24gcmVzdHJpY3Rpb25zLlxuLy8gU28sIENvcmUgc2NoZW1hIGhhcyBubyBkaXN0aW5jdGlvbnMgZnJvbSBKU09OIHNjaGVtYSBpcyBKUy1ZQU1MLlxuXG5cbid1c2Ugc3RyaWN0JztcblxuXG52YXIgU2NoZW1hID0gcmVxdWlyZSgnLi4vc2NoZW1hJyk7XG5cblxubW9kdWxlLmV4cG9ydHMgPSBuZXcgU2NoZW1hKHtcbiAgaW5jbHVkZTogW1xuICAgIHJlcXVpcmUoJy4vanNvbicpXG4gIF1cbn0pO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2pzLXlhbWwvbGliL2pzLXlhbWwvc2NoZW1hL2NvcmUuanMiLCIvLyBTdGFuZGFyZCBZQU1MJ3MgSlNPTiBzY2hlbWEuXG4vLyBodHRwOi8vd3d3LnlhbWwub3JnL3NwZWMvMS4yL3NwZWMuaHRtbCNpZDI4MDMyMzFcbi8vXG4vLyBOT1RFOiBKUy1ZQU1MIGRvZXMgbm90IHN1cHBvcnQgc2NoZW1hLXNwZWNpZmljIHRhZyByZXNvbHV0aW9uIHJlc3RyaWN0aW9ucy5cbi8vIFNvLCB0aGlzIHNjaGVtYSBpcyBub3Qgc3VjaCBzdHJpY3QgYXMgZGVmaW5lZCBpbiB0aGUgWUFNTCBzcGVjaWZpY2F0aW9uLlxuLy8gSXQgYWxsb3dzIG51bWJlcnMgaW4gYmluYXJ5IG5vdGFpb24sIHVzZSBgTnVsbGAgYW5kIGBOVUxMYCBhcyBgbnVsbGAsIGV0Yy5cblxuXG4ndXNlIHN0cmljdCc7XG5cblxudmFyIFNjaGVtYSA9IHJlcXVpcmUoJy4uL3NjaGVtYScpO1xuXG5cbm1vZHVsZS5leHBvcnRzID0gbmV3IFNjaGVtYSh7XG4gIGluY2x1ZGU6IFtcbiAgICByZXF1aXJlKCcuL2ZhaWxzYWZlJylcbiAgXSxcbiAgaW1wbGljaXQ6IFtcbiAgICByZXF1aXJlKCcuLi90eXBlL251bGwnKSxcbiAgICByZXF1aXJlKCcuLi90eXBlL2Jvb2wnKSxcbiAgICByZXF1aXJlKCcuLi90eXBlL2ludCcpLFxuICAgIHJlcXVpcmUoJy4uL3R5cGUvZmxvYXQnKVxuICBdXG59KTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9qcy15YW1sL2xpYi9qcy15YW1sL3NjaGVtYS9qc29uLmpzIiwiZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gU2VtVmVyO1xuXG4vLyBUaGUgZGVidWcgZnVuY3Rpb24gaXMgZXhjbHVkZWQgZW50aXJlbHkgZnJvbSB0aGUgbWluaWZpZWQgdmVyc2lvbi5cbi8qIG5vbWluICovIHZhciBkZWJ1Zztcbi8qIG5vbWluICovIGlmICh0eXBlb2YgcHJvY2VzcyA9PT0gJ29iamVjdCcgJiZcbiAgICAvKiBub21pbiAqLyBwcm9jZXNzLmVudiAmJlxuICAgIC8qIG5vbWluICovIHByb2Nlc3MuZW52Lk5PREVfREVCVUcgJiZcbiAgICAvKiBub21pbiAqLyAvXFxic2VtdmVyXFxiL2kudGVzdChwcm9jZXNzLmVudi5OT0RFX0RFQlVHKSlcbiAgLyogbm9taW4gKi8gZGVidWcgPSBmdW5jdGlvbigpIHtcbiAgICAvKiBub21pbiAqLyB2YXIgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMCk7XG4gICAgLyogbm9taW4gKi8gYXJncy51bnNoaWZ0KCdTRU1WRVInKTtcbiAgICAvKiBub21pbiAqLyBjb25zb2xlLmxvZy5hcHBseShjb25zb2xlLCBhcmdzKTtcbiAgICAvKiBub21pbiAqLyB9O1xuLyogbm9taW4gKi8gZWxzZVxuICAvKiBub21pbiAqLyBkZWJ1ZyA9IGZ1bmN0aW9uKCkge307XG5cbi8vIE5vdGU6IHRoaXMgaXMgdGhlIHNlbXZlci5vcmcgdmVyc2lvbiBvZiB0aGUgc3BlYyB0aGF0IGl0IGltcGxlbWVudHNcbi8vIE5vdCBuZWNlc3NhcmlseSB0aGUgcGFja2FnZSB2ZXJzaW9uIG9mIHRoaXMgY29kZS5cbmV4cG9ydHMuU0VNVkVSX1NQRUNfVkVSU0lPTiA9ICcyLjAuMCc7XG5cbnZhciBNQVhfTEVOR1RIID0gMjU2O1xudmFyIE1BWF9TQUZFX0lOVEVHRVIgPSBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUiB8fCA5MDA3MTk5MjU0NzQwOTkxO1xuXG4vLyBUaGUgYWN0dWFsIHJlZ2V4cHMgZ28gb24gZXhwb3J0cy5yZVxudmFyIHJlID0gZXhwb3J0cy5yZSA9IFtdO1xudmFyIHNyYyA9IGV4cG9ydHMuc3JjID0gW107XG52YXIgUiA9IDA7XG5cbi8vIFRoZSBmb2xsb3dpbmcgUmVndWxhciBFeHByZXNzaW9ucyBjYW4gYmUgdXNlZCBmb3IgdG9rZW5pemluZyxcbi8vIHZhbGlkYXRpbmcsIGFuZCBwYXJzaW5nIFNlbVZlciB2ZXJzaW9uIHN0cmluZ3MuXG5cbi8vICMjIE51bWVyaWMgSWRlbnRpZmllclxuLy8gQSBzaW5nbGUgYDBgLCBvciBhIG5vbi16ZXJvIGRpZ2l0IGZvbGxvd2VkIGJ5IHplcm8gb3IgbW9yZSBkaWdpdHMuXG5cbnZhciBOVU1FUklDSURFTlRJRklFUiA9IFIrKztcbnNyY1tOVU1FUklDSURFTlRJRklFUl0gPSAnMHxbMS05XVxcXFxkKic7XG52YXIgTlVNRVJJQ0lERU5USUZJRVJMT09TRSA9IFIrKztcbnNyY1tOVU1FUklDSURFTlRJRklFUkxPT1NFXSA9ICdbMC05XSsnO1xuXG5cbi8vICMjIE5vbi1udW1lcmljIElkZW50aWZpZXJcbi8vIFplcm8gb3IgbW9yZSBkaWdpdHMsIGZvbGxvd2VkIGJ5IGEgbGV0dGVyIG9yIGh5cGhlbiwgYW5kIHRoZW4gemVybyBvclxuLy8gbW9yZSBsZXR0ZXJzLCBkaWdpdHMsIG9yIGh5cGhlbnMuXG5cbnZhciBOT05OVU1FUklDSURFTlRJRklFUiA9IFIrKztcbnNyY1tOT05OVU1FUklDSURFTlRJRklFUl0gPSAnXFxcXGQqW2EtekEtWi1dW2EtekEtWjAtOS1dKic7XG5cblxuLy8gIyMgTWFpbiBWZXJzaW9uXG4vLyBUaHJlZSBkb3Qtc2VwYXJhdGVkIG51bWVyaWMgaWRlbnRpZmllcnMuXG5cbnZhciBNQUlOVkVSU0lPTiA9IFIrKztcbnNyY1tNQUlOVkVSU0lPTl0gPSAnKCcgKyBzcmNbTlVNRVJJQ0lERU5USUZJRVJdICsgJylcXFxcLicgK1xuICAgICAgICAgICAgICAgICAgICcoJyArIHNyY1tOVU1FUklDSURFTlRJRklFUl0gKyAnKVxcXFwuJyArXG4gICAgICAgICAgICAgICAgICAgJygnICsgc3JjW05VTUVSSUNJREVOVElGSUVSXSArICcpJztcblxudmFyIE1BSU5WRVJTSU9OTE9PU0UgPSBSKys7XG5zcmNbTUFJTlZFUlNJT05MT09TRV0gPSAnKCcgKyBzcmNbTlVNRVJJQ0lERU5USUZJRVJMT09TRV0gKyAnKVxcXFwuJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAnKCcgKyBzcmNbTlVNRVJJQ0lERU5USUZJRVJMT09TRV0gKyAnKVxcXFwuJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAnKCcgKyBzcmNbTlVNRVJJQ0lERU5USUZJRVJMT09TRV0gKyAnKSc7XG5cbi8vICMjIFByZS1yZWxlYXNlIFZlcnNpb24gSWRlbnRpZmllclxuLy8gQSBudW1lcmljIGlkZW50aWZpZXIsIG9yIGEgbm9uLW51bWVyaWMgaWRlbnRpZmllci5cblxudmFyIFBSRVJFTEVBU0VJREVOVElGSUVSID0gUisrO1xuc3JjW1BSRVJFTEVBU0VJREVOVElGSUVSXSA9ICcoPzonICsgc3JjW05VTUVSSUNJREVOVElGSUVSXSArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJ3wnICsgc3JjW05PTk5VTUVSSUNJREVOVElGSUVSXSArICcpJztcblxudmFyIFBSRVJFTEVBU0VJREVOVElGSUVSTE9PU0UgPSBSKys7XG5zcmNbUFJFUkVMRUFTRUlERU5USUZJRVJMT09TRV0gPSAnKD86JyArIHNyY1tOVU1FUklDSURFTlRJRklFUkxPT1NFXSArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnfCcgKyBzcmNbTk9OTlVNRVJJQ0lERU5USUZJRVJdICsgJyknO1xuXG5cbi8vICMjIFByZS1yZWxlYXNlIFZlcnNpb25cbi8vIEh5cGhlbiwgZm9sbG93ZWQgYnkgb25lIG9yIG1vcmUgZG90LXNlcGFyYXRlZCBwcmUtcmVsZWFzZSB2ZXJzaW9uXG4vLyBpZGVudGlmaWVycy5cblxudmFyIFBSRVJFTEVBU0UgPSBSKys7XG5zcmNbUFJFUkVMRUFTRV0gPSAnKD86LSgnICsgc3JjW1BSRVJFTEVBU0VJREVOVElGSUVSXSArXG4gICAgICAgICAgICAgICAgICAnKD86XFxcXC4nICsgc3JjW1BSRVJFTEVBU0VJREVOVElGSUVSXSArICcpKikpJztcblxudmFyIFBSRVJFTEVBU0VMT09TRSA9IFIrKztcbnNyY1tQUkVSRUxFQVNFTE9PU0VdID0gJyg/Oi0/KCcgKyBzcmNbUFJFUkVMRUFTRUlERU5USUZJRVJMT09TRV0gK1xuICAgICAgICAgICAgICAgICAgICAgICAnKD86XFxcXC4nICsgc3JjW1BSRVJFTEVBU0VJREVOVElGSUVSTE9PU0VdICsgJykqKSknO1xuXG4vLyAjIyBCdWlsZCBNZXRhZGF0YSBJZGVudGlmaWVyXG4vLyBBbnkgY29tYmluYXRpb24gb2YgZGlnaXRzLCBsZXR0ZXJzLCBvciBoeXBoZW5zLlxuXG52YXIgQlVJTERJREVOVElGSUVSID0gUisrO1xuc3JjW0JVSUxESURFTlRJRklFUl0gPSAnWzAtOUEtWmEtei1dKyc7XG5cbi8vICMjIEJ1aWxkIE1ldGFkYXRhXG4vLyBQbHVzIHNpZ24sIGZvbGxvd2VkIGJ5IG9uZSBvciBtb3JlIHBlcmlvZC1zZXBhcmF0ZWQgYnVpbGQgbWV0YWRhdGFcbi8vIGlkZW50aWZpZXJzLlxuXG52YXIgQlVJTEQgPSBSKys7XG5zcmNbQlVJTERdID0gJyg/OlxcXFwrKCcgKyBzcmNbQlVJTERJREVOVElGSUVSXSArXG4gICAgICAgICAgICAgJyg/OlxcXFwuJyArIHNyY1tCVUlMRElERU5USUZJRVJdICsgJykqKSknO1xuXG5cbi8vICMjIEZ1bGwgVmVyc2lvbiBTdHJpbmdcbi8vIEEgbWFpbiB2ZXJzaW9uLCBmb2xsb3dlZCBvcHRpb25hbGx5IGJ5IGEgcHJlLXJlbGVhc2UgdmVyc2lvbiBhbmRcbi8vIGJ1aWxkIG1ldGFkYXRhLlxuXG4vLyBOb3RlIHRoYXQgdGhlIG9ubHkgbWFqb3IsIG1pbm9yLCBwYXRjaCwgYW5kIHByZS1yZWxlYXNlIHNlY3Rpb25zIG9mXG4vLyB0aGUgdmVyc2lvbiBzdHJpbmcgYXJlIGNhcHR1cmluZyBncm91cHMuICBUaGUgYnVpbGQgbWV0YWRhdGEgaXMgbm90IGFcbi8vIGNhcHR1cmluZyBncm91cCwgYmVjYXVzZSBpdCBzaG91bGQgbm90IGV2ZXIgYmUgdXNlZCBpbiB2ZXJzaW9uXG4vLyBjb21wYXJpc29uLlxuXG52YXIgRlVMTCA9IFIrKztcbnZhciBGVUxMUExBSU4gPSAndj8nICsgc3JjW01BSU5WRVJTSU9OXSArXG4gICAgICAgICAgICAgICAgc3JjW1BSRVJFTEVBU0VdICsgJz8nICtcbiAgICAgICAgICAgICAgICBzcmNbQlVJTERdICsgJz8nO1xuXG5zcmNbRlVMTF0gPSAnXicgKyBGVUxMUExBSU4gKyAnJCc7XG5cbi8vIGxpa2UgZnVsbCwgYnV0IGFsbG93cyB2MS4yLjMgYW5kID0xLjIuMywgd2hpY2ggcGVvcGxlIGRvIHNvbWV0aW1lcy5cbi8vIGFsc28sIDEuMC4wYWxwaGExIChwcmVyZWxlYXNlIHdpdGhvdXQgdGhlIGh5cGhlbikgd2hpY2ggaXMgcHJldHR5XG4vLyBjb21tb24gaW4gdGhlIG5wbSByZWdpc3RyeS5cbnZhciBMT09TRVBMQUlOID0gJ1t2PVxcXFxzXSonICsgc3JjW01BSU5WRVJTSU9OTE9PU0VdICtcbiAgICAgICAgICAgICAgICAgc3JjW1BSRVJFTEVBU0VMT09TRV0gKyAnPycgK1xuICAgICAgICAgICAgICAgICBzcmNbQlVJTERdICsgJz8nO1xuXG52YXIgTE9PU0UgPSBSKys7XG5zcmNbTE9PU0VdID0gJ14nICsgTE9PU0VQTEFJTiArICckJztcblxudmFyIEdUTFQgPSBSKys7XG5zcmNbR1RMVF0gPSAnKCg/Ojx8Pik/PT8pJztcblxuLy8gU29tZXRoaW5nIGxpa2UgXCIyLipcIiBvciBcIjEuMi54XCIuXG4vLyBOb3RlIHRoYXQgXCJ4LnhcIiBpcyBhIHZhbGlkIHhSYW5nZSBpZGVudGlmZXIsIG1lYW5pbmcgXCJhbnkgdmVyc2lvblwiXG4vLyBPbmx5IHRoZSBmaXJzdCBpdGVtIGlzIHN0cmljdGx5IHJlcXVpcmVkLlxudmFyIFhSQU5HRUlERU5USUZJRVJMT09TRSA9IFIrKztcbnNyY1tYUkFOR0VJREVOVElGSUVSTE9PU0VdID0gc3JjW05VTUVSSUNJREVOVElGSUVSTE9PU0VdICsgJ3x4fFh8XFxcXConO1xudmFyIFhSQU5HRUlERU5USUZJRVIgPSBSKys7XG5zcmNbWFJBTkdFSURFTlRJRklFUl0gPSBzcmNbTlVNRVJJQ0lERU5USUZJRVJdICsgJ3x4fFh8XFxcXConO1xuXG52YXIgWFJBTkdFUExBSU4gPSBSKys7XG5zcmNbWFJBTkdFUExBSU5dID0gJ1t2PVxcXFxzXSooJyArIHNyY1tYUkFOR0VJREVOVElGSUVSXSArICcpJyArXG4gICAgICAgICAgICAgICAgICAgJyg/OlxcXFwuKCcgKyBzcmNbWFJBTkdFSURFTlRJRklFUl0gKyAnKScgK1xuICAgICAgICAgICAgICAgICAgICcoPzpcXFxcLignICsgc3JjW1hSQU5HRUlERU5USUZJRVJdICsgJyknICtcbiAgICAgICAgICAgICAgICAgICAnKD86JyArIHNyY1tQUkVSRUxFQVNFXSArICcpPycgK1xuICAgICAgICAgICAgICAgICAgIHNyY1tCVUlMRF0gKyAnPycgK1xuICAgICAgICAgICAgICAgICAgICcpPyk/JztcblxudmFyIFhSQU5HRVBMQUlOTE9PU0UgPSBSKys7XG5zcmNbWFJBTkdFUExBSU5MT09TRV0gPSAnW3Y9XFxcXHNdKignICsgc3JjW1hSQU5HRUlERU5USUZJRVJMT09TRV0gKyAnKScgK1xuICAgICAgICAgICAgICAgICAgICAgICAgJyg/OlxcXFwuKCcgKyBzcmNbWFJBTkdFSURFTlRJRklFUkxPT1NFXSArICcpJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAnKD86XFxcXC4oJyArIHNyY1tYUkFOR0VJREVOVElGSUVSTE9PU0VdICsgJyknICtcbiAgICAgICAgICAgICAgICAgICAgICAgICcoPzonICsgc3JjW1BSRVJFTEVBU0VMT09TRV0gKyAnKT8nICtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNyY1tCVUlMRF0gKyAnPycgK1xuICAgICAgICAgICAgICAgICAgICAgICAgJyk/KT8nO1xuXG52YXIgWFJBTkdFID0gUisrO1xuc3JjW1hSQU5HRV0gPSAnXicgKyBzcmNbR1RMVF0gKyAnXFxcXHMqJyArIHNyY1tYUkFOR0VQTEFJTl0gKyAnJCc7XG52YXIgWFJBTkdFTE9PU0UgPSBSKys7XG5zcmNbWFJBTkdFTE9PU0VdID0gJ14nICsgc3JjW0dUTFRdICsgJ1xcXFxzKicgKyBzcmNbWFJBTkdFUExBSU5MT09TRV0gKyAnJCc7XG5cbi8vIFRpbGRlIHJhbmdlcy5cbi8vIE1lYW5pbmcgaXMgXCJyZWFzb25hYmx5IGF0IG9yIGdyZWF0ZXIgdGhhblwiXG52YXIgTE9ORVRJTERFID0gUisrO1xuc3JjW0xPTkVUSUxERV0gPSAnKD86fj4/KSc7XG5cbnZhciBUSUxERVRSSU0gPSBSKys7XG5zcmNbVElMREVUUklNXSA9ICcoXFxcXHMqKScgKyBzcmNbTE9ORVRJTERFXSArICdcXFxccysnO1xucmVbVElMREVUUklNXSA9IG5ldyBSZWdFeHAoc3JjW1RJTERFVFJJTV0sICdnJyk7XG52YXIgdGlsZGVUcmltUmVwbGFjZSA9ICckMX4nO1xuXG52YXIgVElMREUgPSBSKys7XG5zcmNbVElMREVdID0gJ14nICsgc3JjW0xPTkVUSUxERV0gKyBzcmNbWFJBTkdFUExBSU5dICsgJyQnO1xudmFyIFRJTERFTE9PU0UgPSBSKys7XG5zcmNbVElMREVMT09TRV0gPSAnXicgKyBzcmNbTE9ORVRJTERFXSArIHNyY1tYUkFOR0VQTEFJTkxPT1NFXSArICckJztcblxuLy8gQ2FyZXQgcmFuZ2VzLlxuLy8gTWVhbmluZyBpcyBcImF0IGxlYXN0IGFuZCBiYWNrd2FyZHMgY29tcGF0aWJsZSB3aXRoXCJcbnZhciBMT05FQ0FSRVQgPSBSKys7XG5zcmNbTE9ORUNBUkVUXSA9ICcoPzpcXFxcXiknO1xuXG52YXIgQ0FSRVRUUklNID0gUisrO1xuc3JjW0NBUkVUVFJJTV0gPSAnKFxcXFxzKiknICsgc3JjW0xPTkVDQVJFVF0gKyAnXFxcXHMrJztcbnJlW0NBUkVUVFJJTV0gPSBuZXcgUmVnRXhwKHNyY1tDQVJFVFRSSU1dLCAnZycpO1xudmFyIGNhcmV0VHJpbVJlcGxhY2UgPSAnJDFeJztcblxudmFyIENBUkVUID0gUisrO1xuc3JjW0NBUkVUXSA9ICdeJyArIHNyY1tMT05FQ0FSRVRdICsgc3JjW1hSQU5HRVBMQUlOXSArICckJztcbnZhciBDQVJFVExPT1NFID0gUisrO1xuc3JjW0NBUkVUTE9PU0VdID0gJ14nICsgc3JjW0xPTkVDQVJFVF0gKyBzcmNbWFJBTkdFUExBSU5MT09TRV0gKyAnJCc7XG5cbi8vIEEgc2ltcGxlIGd0L2x0L2VxIHRoaW5nLCBvciBqdXN0IFwiXCIgdG8gaW5kaWNhdGUgXCJhbnkgdmVyc2lvblwiXG52YXIgQ09NUEFSQVRPUkxPT1NFID0gUisrO1xuc3JjW0NPTVBBUkFUT1JMT09TRV0gPSAnXicgKyBzcmNbR1RMVF0gKyAnXFxcXHMqKCcgKyBMT09TRVBMQUlOICsgJykkfF4kJztcbnZhciBDT01QQVJBVE9SID0gUisrO1xuc3JjW0NPTVBBUkFUT1JdID0gJ14nICsgc3JjW0dUTFRdICsgJ1xcXFxzKignICsgRlVMTFBMQUlOICsgJykkfF4kJztcblxuXG4vLyBBbiBleHByZXNzaW9uIHRvIHN0cmlwIGFueSB3aGl0ZXNwYWNlIGJldHdlZW4gdGhlIGd0bHQgYW5kIHRoZSB0aGluZ1xuLy8gaXQgbW9kaWZpZXMsIHNvIHRoYXQgYD4gMS4yLjNgID09PiBgPjEuMi4zYFxudmFyIENPTVBBUkFUT1JUUklNID0gUisrO1xuc3JjW0NPTVBBUkFUT1JUUklNXSA9ICcoXFxcXHMqKScgKyBzcmNbR1RMVF0gK1xuICAgICAgICAgICAgICAgICAgICAgICdcXFxccyooJyArIExPT1NFUExBSU4gKyAnfCcgKyBzcmNbWFJBTkdFUExBSU5dICsgJyknO1xuXG4vLyB0aGlzIG9uZSBoYXMgdG8gdXNlIHRoZSAvZyBmbGFnXG5yZVtDT01QQVJBVE9SVFJJTV0gPSBuZXcgUmVnRXhwKHNyY1tDT01QQVJBVE9SVFJJTV0sICdnJyk7XG52YXIgY29tcGFyYXRvclRyaW1SZXBsYWNlID0gJyQxJDIkMyc7XG5cblxuLy8gU29tZXRoaW5nIGxpa2UgYDEuMi4zIC0gMS4yLjRgXG4vLyBOb3RlIHRoYXQgdGhlc2UgYWxsIHVzZSB0aGUgbG9vc2UgZm9ybSwgYmVjYXVzZSB0aGV5J2xsIGJlXG4vLyBjaGVja2VkIGFnYWluc3QgZWl0aGVyIHRoZSBzdHJpY3Qgb3IgbG9vc2UgY29tcGFyYXRvciBmb3JtXG4vLyBsYXRlci5cbnZhciBIWVBIRU5SQU5HRSA9IFIrKztcbnNyY1tIWVBIRU5SQU5HRV0gPSAnXlxcXFxzKignICsgc3JjW1hSQU5HRVBMQUlOXSArICcpJyArXG4gICAgICAgICAgICAgICAgICAgJ1xcXFxzKy1cXFxccysnICtcbiAgICAgICAgICAgICAgICAgICAnKCcgKyBzcmNbWFJBTkdFUExBSU5dICsgJyknICtcbiAgICAgICAgICAgICAgICAgICAnXFxcXHMqJCc7XG5cbnZhciBIWVBIRU5SQU5HRUxPT1NFID0gUisrO1xuc3JjW0hZUEhFTlJBTkdFTE9PU0VdID0gJ15cXFxccyooJyArIHNyY1tYUkFOR0VQTEFJTkxPT1NFXSArICcpJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAnXFxcXHMrLVxcXFxzKycgK1xuICAgICAgICAgICAgICAgICAgICAgICAgJygnICsgc3JjW1hSQU5HRVBMQUlOTE9PU0VdICsgJyknICtcbiAgICAgICAgICAgICAgICAgICAgICAgICdcXFxccyokJztcblxuLy8gU3RhciByYW5nZXMgYmFzaWNhbGx5IGp1c3QgYWxsb3cgYW55dGhpbmcgYXQgYWxsLlxudmFyIFNUQVIgPSBSKys7XG5zcmNbU1RBUl0gPSAnKDx8Pik/PT9cXFxccypcXFxcKic7XG5cbi8vIENvbXBpbGUgdG8gYWN0dWFsIHJlZ2V4cCBvYmplY3RzLlxuLy8gQWxsIGFyZSBmbGFnLWZyZWUsIHVubGVzcyB0aGV5IHdlcmUgY3JlYXRlZCBhYm92ZSB3aXRoIGEgZmxhZy5cbmZvciAodmFyIGkgPSAwOyBpIDwgUjsgaSsrKSB7XG4gIGRlYnVnKGksIHNyY1tpXSk7XG4gIGlmICghcmVbaV0pXG4gICAgcmVbaV0gPSBuZXcgUmVnRXhwKHNyY1tpXSk7XG59XG5cbmV4cG9ydHMucGFyc2UgPSBwYXJzZTtcbmZ1bmN0aW9uIHBhcnNlKHZlcnNpb24sIGxvb3NlKSB7XG4gIGlmICh2ZXJzaW9uIGluc3RhbmNlb2YgU2VtVmVyKVxuICAgIHJldHVybiB2ZXJzaW9uO1xuXG4gIGlmICh0eXBlb2YgdmVyc2lvbiAhPT0gJ3N0cmluZycpXG4gICAgcmV0dXJuIG51bGw7XG5cbiAgaWYgKHZlcnNpb24ubGVuZ3RoID4gTUFYX0xFTkdUSClcbiAgICByZXR1cm4gbnVsbDtcblxuICB2YXIgciA9IGxvb3NlID8gcmVbTE9PU0VdIDogcmVbRlVMTF07XG4gIGlmICghci50ZXN0KHZlcnNpb24pKVxuICAgIHJldHVybiBudWxsO1xuXG4gIHRyeSB7XG4gICAgcmV0dXJuIG5ldyBTZW1WZXIodmVyc2lvbiwgbG9vc2UpO1xuICB9IGNhdGNoIChlcikge1xuICAgIHJldHVybiBudWxsO1xuICB9XG59XG5cbmV4cG9ydHMudmFsaWQgPSB2YWxpZDtcbmZ1bmN0aW9uIHZhbGlkKHZlcnNpb24sIGxvb3NlKSB7XG4gIHZhciB2ID0gcGFyc2UodmVyc2lvbiwgbG9vc2UpO1xuICByZXR1cm4gdiA/IHYudmVyc2lvbiA6IG51bGw7XG59XG5cblxuZXhwb3J0cy5jbGVhbiA9IGNsZWFuO1xuZnVuY3Rpb24gY2xlYW4odmVyc2lvbiwgbG9vc2UpIHtcbiAgdmFyIHMgPSBwYXJzZSh2ZXJzaW9uLnRyaW0oKS5yZXBsYWNlKC9eWz12XSsvLCAnJyksIGxvb3NlKTtcbiAgcmV0dXJuIHMgPyBzLnZlcnNpb24gOiBudWxsO1xufVxuXG5leHBvcnRzLlNlbVZlciA9IFNlbVZlcjtcblxuZnVuY3Rpb24gU2VtVmVyKHZlcnNpb24sIGxvb3NlKSB7XG4gIGlmICh2ZXJzaW9uIGluc3RhbmNlb2YgU2VtVmVyKSB7XG4gICAgaWYgKHZlcnNpb24ubG9vc2UgPT09IGxvb3NlKVxuICAgICAgcmV0dXJuIHZlcnNpb247XG4gICAgZWxzZVxuICAgICAgdmVyc2lvbiA9IHZlcnNpb24udmVyc2lvbjtcbiAgfSBlbHNlIGlmICh0eXBlb2YgdmVyc2lvbiAhPT0gJ3N0cmluZycpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdJbnZhbGlkIFZlcnNpb246ICcgKyB2ZXJzaW9uKTtcbiAgfVxuXG4gIGlmICh2ZXJzaW9uLmxlbmd0aCA+IE1BWF9MRU5HVEgpXG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcigndmVyc2lvbiBpcyBsb25nZXIgdGhhbiAnICsgTUFYX0xFTkdUSCArICcgY2hhcmFjdGVycycpXG5cbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIFNlbVZlcikpXG4gICAgcmV0dXJuIG5ldyBTZW1WZXIodmVyc2lvbiwgbG9vc2UpO1xuXG4gIGRlYnVnKCdTZW1WZXInLCB2ZXJzaW9uLCBsb29zZSk7XG4gIHRoaXMubG9vc2UgPSBsb29zZTtcbiAgdmFyIG0gPSB2ZXJzaW9uLnRyaW0oKS5tYXRjaChsb29zZSA/IHJlW0xPT1NFXSA6IHJlW0ZVTExdKTtcblxuICBpZiAoIW0pXG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignSW52YWxpZCBWZXJzaW9uOiAnICsgdmVyc2lvbik7XG5cbiAgdGhpcy5yYXcgPSB2ZXJzaW9uO1xuXG4gIC8vIHRoZXNlIGFyZSBhY3R1YWxseSBudW1iZXJzXG4gIHRoaXMubWFqb3IgPSArbVsxXTtcbiAgdGhpcy5taW5vciA9ICttWzJdO1xuICB0aGlzLnBhdGNoID0gK21bM107XG5cbiAgaWYgKHRoaXMubWFqb3IgPiBNQVhfU0FGRV9JTlRFR0VSIHx8IHRoaXMubWFqb3IgPCAwKVxuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0ludmFsaWQgbWFqb3IgdmVyc2lvbicpXG5cbiAgaWYgKHRoaXMubWlub3IgPiBNQVhfU0FGRV9JTlRFR0VSIHx8IHRoaXMubWlub3IgPCAwKVxuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0ludmFsaWQgbWlub3IgdmVyc2lvbicpXG5cbiAgaWYgKHRoaXMucGF0Y2ggPiBNQVhfU0FGRV9JTlRFR0VSIHx8IHRoaXMucGF0Y2ggPCAwKVxuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0ludmFsaWQgcGF0Y2ggdmVyc2lvbicpXG5cbiAgLy8gbnVtYmVyaWZ5IGFueSBwcmVyZWxlYXNlIG51bWVyaWMgaWRzXG4gIGlmICghbVs0XSlcbiAgICB0aGlzLnByZXJlbGVhc2UgPSBbXTtcbiAgZWxzZVxuICAgIHRoaXMucHJlcmVsZWFzZSA9IG1bNF0uc3BsaXQoJy4nKS5tYXAoZnVuY3Rpb24oaWQpIHtcbiAgICAgIGlmICgvXlswLTldKyQvLnRlc3QoaWQpKSB7XG4gICAgICAgIHZhciBudW0gPSAraWQ7XG4gICAgICAgIGlmIChudW0gPj0gMCAmJiBudW0gPCBNQVhfU0FGRV9JTlRFR0VSKVxuICAgICAgICAgIHJldHVybiBudW07XG4gICAgICB9XG4gICAgICByZXR1cm4gaWQ7XG4gICAgfSk7XG5cbiAgdGhpcy5idWlsZCA9IG1bNV0gPyBtWzVdLnNwbGl0KCcuJykgOiBbXTtcbiAgdGhpcy5mb3JtYXQoKTtcbn1cblxuU2VtVmVyLnByb3RvdHlwZS5mb3JtYXQgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy52ZXJzaW9uID0gdGhpcy5tYWpvciArICcuJyArIHRoaXMubWlub3IgKyAnLicgKyB0aGlzLnBhdGNoO1xuICBpZiAodGhpcy5wcmVyZWxlYXNlLmxlbmd0aClcbiAgICB0aGlzLnZlcnNpb24gKz0gJy0nICsgdGhpcy5wcmVyZWxlYXNlLmpvaW4oJy4nKTtcbiAgcmV0dXJuIHRoaXMudmVyc2lvbjtcbn07XG5cblNlbVZlci5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMudmVyc2lvbjtcbn07XG5cblNlbVZlci5wcm90b3R5cGUuY29tcGFyZSA9IGZ1bmN0aW9uKG90aGVyKSB7XG4gIGRlYnVnKCdTZW1WZXIuY29tcGFyZScsIHRoaXMudmVyc2lvbiwgdGhpcy5sb29zZSwgb3RoZXIpO1xuICBpZiAoIShvdGhlciBpbnN0YW5jZW9mIFNlbVZlcikpXG4gICAgb3RoZXIgPSBuZXcgU2VtVmVyKG90aGVyLCB0aGlzLmxvb3NlKTtcblxuICByZXR1cm4gdGhpcy5jb21wYXJlTWFpbihvdGhlcikgfHwgdGhpcy5jb21wYXJlUHJlKG90aGVyKTtcbn07XG5cblNlbVZlci5wcm90b3R5cGUuY29tcGFyZU1haW4gPSBmdW5jdGlvbihvdGhlcikge1xuICBpZiAoIShvdGhlciBpbnN0YW5jZW9mIFNlbVZlcikpXG4gICAgb3RoZXIgPSBuZXcgU2VtVmVyKG90aGVyLCB0aGlzLmxvb3NlKTtcblxuICByZXR1cm4gY29tcGFyZUlkZW50aWZpZXJzKHRoaXMubWFqb3IsIG90aGVyLm1ham9yKSB8fFxuICAgICAgICAgY29tcGFyZUlkZW50aWZpZXJzKHRoaXMubWlub3IsIG90aGVyLm1pbm9yKSB8fFxuICAgICAgICAgY29tcGFyZUlkZW50aWZpZXJzKHRoaXMucGF0Y2gsIG90aGVyLnBhdGNoKTtcbn07XG5cblNlbVZlci5wcm90b3R5cGUuY29tcGFyZVByZSA9IGZ1bmN0aW9uKG90aGVyKSB7XG4gIGlmICghKG90aGVyIGluc3RhbmNlb2YgU2VtVmVyKSlcbiAgICBvdGhlciA9IG5ldyBTZW1WZXIob3RoZXIsIHRoaXMubG9vc2UpO1xuXG4gIC8vIE5PVCBoYXZpbmcgYSBwcmVyZWxlYXNlIGlzID4gaGF2aW5nIG9uZVxuICBpZiAodGhpcy5wcmVyZWxlYXNlLmxlbmd0aCAmJiAhb3RoZXIucHJlcmVsZWFzZS5sZW5ndGgpXG4gICAgcmV0dXJuIC0xO1xuICBlbHNlIGlmICghdGhpcy5wcmVyZWxlYXNlLmxlbmd0aCAmJiBvdGhlci5wcmVyZWxlYXNlLmxlbmd0aClcbiAgICByZXR1cm4gMTtcbiAgZWxzZSBpZiAoIXRoaXMucHJlcmVsZWFzZS5sZW5ndGggJiYgIW90aGVyLnByZXJlbGVhc2UubGVuZ3RoKVxuICAgIHJldHVybiAwO1xuXG4gIHZhciBpID0gMDtcbiAgZG8ge1xuICAgIHZhciBhID0gdGhpcy5wcmVyZWxlYXNlW2ldO1xuICAgIHZhciBiID0gb3RoZXIucHJlcmVsZWFzZVtpXTtcbiAgICBkZWJ1ZygncHJlcmVsZWFzZSBjb21wYXJlJywgaSwgYSwgYik7XG4gICAgaWYgKGEgPT09IHVuZGVmaW5lZCAmJiBiID09PSB1bmRlZmluZWQpXG4gICAgICByZXR1cm4gMDtcbiAgICBlbHNlIGlmIChiID09PSB1bmRlZmluZWQpXG4gICAgICByZXR1cm4gMTtcbiAgICBlbHNlIGlmIChhID09PSB1bmRlZmluZWQpXG4gICAgICByZXR1cm4gLTE7XG4gICAgZWxzZSBpZiAoYSA9PT0gYilcbiAgICAgIGNvbnRpbnVlO1xuICAgIGVsc2VcbiAgICAgIHJldHVybiBjb21wYXJlSWRlbnRpZmllcnMoYSwgYik7XG4gIH0gd2hpbGUgKCsraSk7XG59O1xuXG4vLyBwcmVtaW5vciB3aWxsIGJ1bXAgdGhlIHZlcnNpb24gdXAgdG8gdGhlIG5leHQgbWlub3IgcmVsZWFzZSwgYW5kIGltbWVkaWF0ZWx5XG4vLyBkb3duIHRvIHByZS1yZWxlYXNlLiBwcmVtYWpvciBhbmQgcHJlcGF0Y2ggd29yayB0aGUgc2FtZSB3YXkuXG5TZW1WZXIucHJvdG90eXBlLmluYyA9IGZ1bmN0aW9uKHJlbGVhc2UsIGlkZW50aWZpZXIpIHtcbiAgc3dpdGNoIChyZWxlYXNlKSB7XG4gICAgY2FzZSAncHJlbWFqb3InOlxuICAgICAgdGhpcy5wcmVyZWxlYXNlLmxlbmd0aCA9IDA7XG4gICAgICB0aGlzLnBhdGNoID0gMDtcbiAgICAgIHRoaXMubWlub3IgPSAwO1xuICAgICAgdGhpcy5tYWpvcisrO1xuICAgICAgdGhpcy5pbmMoJ3ByZScsIGlkZW50aWZpZXIpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAncHJlbWlub3InOlxuICAgICAgdGhpcy5wcmVyZWxlYXNlLmxlbmd0aCA9IDA7XG4gICAgICB0aGlzLnBhdGNoID0gMDtcbiAgICAgIHRoaXMubWlub3IrKztcbiAgICAgIHRoaXMuaW5jKCdwcmUnLCBpZGVudGlmaWVyKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ3ByZXBhdGNoJzpcbiAgICAgIC8vIElmIHRoaXMgaXMgYWxyZWFkeSBhIHByZXJlbGVhc2UsIGl0IHdpbGwgYnVtcCB0byB0aGUgbmV4dCB2ZXJzaW9uXG4gICAgICAvLyBkcm9wIGFueSBwcmVyZWxlYXNlcyB0aGF0IG1pZ2h0IGFscmVhZHkgZXhpc3QsIHNpbmNlIHRoZXkgYXJlIG5vdFxuICAgICAgLy8gcmVsZXZhbnQgYXQgdGhpcyBwb2ludC5cbiAgICAgIHRoaXMucHJlcmVsZWFzZS5sZW5ndGggPSAwO1xuICAgICAgdGhpcy5pbmMoJ3BhdGNoJywgaWRlbnRpZmllcik7XG4gICAgICB0aGlzLmluYygncHJlJywgaWRlbnRpZmllcik7XG4gICAgICBicmVhaztcbiAgICAvLyBJZiB0aGUgaW5wdXQgaXMgYSBub24tcHJlcmVsZWFzZSB2ZXJzaW9uLCB0aGlzIGFjdHMgdGhlIHNhbWUgYXNcbiAgICAvLyBwcmVwYXRjaC5cbiAgICBjYXNlICdwcmVyZWxlYXNlJzpcbiAgICAgIGlmICh0aGlzLnByZXJlbGVhc2UubGVuZ3RoID09PSAwKVxuICAgICAgICB0aGlzLmluYygncGF0Y2gnLCBpZGVudGlmaWVyKTtcbiAgICAgIHRoaXMuaW5jKCdwcmUnLCBpZGVudGlmaWVyKTtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSAnbWFqb3InOlxuICAgICAgLy8gSWYgdGhpcyBpcyBhIHByZS1tYWpvciB2ZXJzaW9uLCBidW1wIHVwIHRvIHRoZSBzYW1lIG1ham9yIHZlcnNpb24uXG4gICAgICAvLyBPdGhlcndpc2UgaW5jcmVtZW50IG1ham9yLlxuICAgICAgLy8gMS4wLjAtNSBidW1wcyB0byAxLjAuMFxuICAgICAgLy8gMS4xLjAgYnVtcHMgdG8gMi4wLjBcbiAgICAgIGlmICh0aGlzLm1pbm9yICE9PSAwIHx8IHRoaXMucGF0Y2ggIT09IDAgfHwgdGhpcy5wcmVyZWxlYXNlLmxlbmd0aCA9PT0gMClcbiAgICAgICAgdGhpcy5tYWpvcisrO1xuICAgICAgdGhpcy5taW5vciA9IDA7XG4gICAgICB0aGlzLnBhdGNoID0gMDtcbiAgICAgIHRoaXMucHJlcmVsZWFzZSA9IFtdO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnbWlub3InOlxuICAgICAgLy8gSWYgdGhpcyBpcyBhIHByZS1taW5vciB2ZXJzaW9uLCBidW1wIHVwIHRvIHRoZSBzYW1lIG1pbm9yIHZlcnNpb24uXG4gICAgICAvLyBPdGhlcndpc2UgaW5jcmVtZW50IG1pbm9yLlxuICAgICAgLy8gMS4yLjAtNSBidW1wcyB0byAxLjIuMFxuICAgICAgLy8gMS4yLjEgYnVtcHMgdG8gMS4zLjBcbiAgICAgIGlmICh0aGlzLnBhdGNoICE9PSAwIHx8IHRoaXMucHJlcmVsZWFzZS5sZW5ndGggPT09IDApXG4gICAgICAgIHRoaXMubWlub3IrKztcbiAgICAgIHRoaXMucGF0Y2ggPSAwO1xuICAgICAgdGhpcy5wcmVyZWxlYXNlID0gW107XG4gICAgICBicmVhaztcbiAgICBjYXNlICdwYXRjaCc6XG4gICAgICAvLyBJZiB0aGlzIGlzIG5vdCBhIHByZS1yZWxlYXNlIHZlcnNpb24sIGl0IHdpbGwgaW5jcmVtZW50IHRoZSBwYXRjaC5cbiAgICAgIC8vIElmIGl0IGlzIGEgcHJlLXJlbGVhc2UgaXQgd2lsbCBidW1wIHVwIHRvIHRoZSBzYW1lIHBhdGNoIHZlcnNpb24uXG4gICAgICAvLyAxLjIuMC01IHBhdGNoZXMgdG8gMS4yLjBcbiAgICAgIC8vIDEuMi4wIHBhdGNoZXMgdG8gMS4yLjFcbiAgICAgIGlmICh0aGlzLnByZXJlbGVhc2UubGVuZ3RoID09PSAwKVxuICAgICAgICB0aGlzLnBhdGNoKys7XG4gICAgICB0aGlzLnByZXJlbGVhc2UgPSBbXTtcbiAgICAgIGJyZWFrO1xuICAgIC8vIFRoaXMgcHJvYmFibHkgc2hvdWxkbid0IGJlIHVzZWQgcHVibGljbHkuXG4gICAgLy8gMS4wLjAgXCJwcmVcIiB3b3VsZCBiZWNvbWUgMS4wLjAtMCB3aGljaCBpcyB0aGUgd3JvbmcgZGlyZWN0aW9uLlxuICAgIGNhc2UgJ3ByZSc6XG4gICAgICBpZiAodGhpcy5wcmVyZWxlYXNlLmxlbmd0aCA9PT0gMClcbiAgICAgICAgdGhpcy5wcmVyZWxlYXNlID0gWzBdO1xuICAgICAgZWxzZSB7XG4gICAgICAgIHZhciBpID0gdGhpcy5wcmVyZWxlYXNlLmxlbmd0aDtcbiAgICAgICAgd2hpbGUgKC0taSA+PSAwKSB7XG4gICAgICAgICAgaWYgKHR5cGVvZiB0aGlzLnByZXJlbGVhc2VbaV0gPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICB0aGlzLnByZXJlbGVhc2VbaV0rKztcbiAgICAgICAgICAgIGkgPSAtMjtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGkgPT09IC0xKSAvLyBkaWRuJ3QgaW5jcmVtZW50IGFueXRoaW5nXG4gICAgICAgICAgdGhpcy5wcmVyZWxlYXNlLnB1c2goMCk7XG4gICAgICB9XG4gICAgICBpZiAoaWRlbnRpZmllcikge1xuICAgICAgICAvLyAxLjIuMC1iZXRhLjEgYnVtcHMgdG8gMS4yLjAtYmV0YS4yLFxuICAgICAgICAvLyAxLjIuMC1iZXRhLmZvb2JseiBvciAxLjIuMC1iZXRhIGJ1bXBzIHRvIDEuMi4wLWJldGEuMFxuICAgICAgICBpZiAodGhpcy5wcmVyZWxlYXNlWzBdID09PSBpZGVudGlmaWVyKSB7XG4gICAgICAgICAgaWYgKGlzTmFOKHRoaXMucHJlcmVsZWFzZVsxXSkpXG4gICAgICAgICAgICB0aGlzLnByZXJlbGVhc2UgPSBbaWRlbnRpZmllciwgMF07XG4gICAgICAgIH0gZWxzZVxuICAgICAgICAgIHRoaXMucHJlcmVsZWFzZSA9IFtpZGVudGlmaWVyLCAwXTtcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuXG4gICAgZGVmYXVsdDpcbiAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBpbmNyZW1lbnQgYXJndW1lbnQ6ICcgKyByZWxlYXNlKTtcbiAgfVxuICB0aGlzLmZvcm1hdCgpO1xuICB0aGlzLnJhdyA9IHRoaXMudmVyc2lvbjtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5leHBvcnRzLmluYyA9IGluYztcbmZ1bmN0aW9uIGluYyh2ZXJzaW9uLCByZWxlYXNlLCBsb29zZSwgaWRlbnRpZmllcikge1xuICBpZiAodHlwZW9mKGxvb3NlKSA9PT0gJ3N0cmluZycpIHtcbiAgICBpZGVudGlmaWVyID0gbG9vc2U7XG4gICAgbG9vc2UgPSB1bmRlZmluZWQ7XG4gIH1cblxuICB0cnkge1xuICAgIHJldHVybiBuZXcgU2VtVmVyKHZlcnNpb24sIGxvb3NlKS5pbmMocmVsZWFzZSwgaWRlbnRpZmllcikudmVyc2lvbjtcbiAgfSBjYXRjaCAoZXIpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxufVxuXG5leHBvcnRzLmRpZmYgPSBkaWZmO1xuZnVuY3Rpb24gZGlmZih2ZXJzaW9uMSwgdmVyc2lvbjIpIHtcbiAgaWYgKGVxKHZlcnNpb24xLCB2ZXJzaW9uMikpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfSBlbHNlIHtcbiAgICB2YXIgdjEgPSBwYXJzZSh2ZXJzaW9uMSk7XG4gICAgdmFyIHYyID0gcGFyc2UodmVyc2lvbjIpO1xuICAgIGlmICh2MS5wcmVyZWxlYXNlLmxlbmd0aCB8fCB2Mi5wcmVyZWxlYXNlLmxlbmd0aCkge1xuICAgICAgZm9yICh2YXIga2V5IGluIHYxKSB7XG4gICAgICAgIGlmIChrZXkgPT09ICdtYWpvcicgfHwga2V5ID09PSAnbWlub3InIHx8IGtleSA9PT0gJ3BhdGNoJykge1xuICAgICAgICAgIGlmICh2MVtrZXldICE9PSB2MltrZXldKSB7XG4gICAgICAgICAgICByZXR1cm4gJ3ByZScra2V5O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuICdwcmVyZWxlYXNlJztcbiAgICB9XG4gICAgZm9yICh2YXIga2V5IGluIHYxKSB7XG4gICAgICBpZiAoa2V5ID09PSAnbWFqb3InIHx8IGtleSA9PT0gJ21pbm9yJyB8fCBrZXkgPT09ICdwYXRjaCcpIHtcbiAgICAgICAgaWYgKHYxW2tleV0gIT09IHYyW2tleV0pIHtcbiAgICAgICAgICByZXR1cm4ga2V5O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmV4cG9ydHMuY29tcGFyZUlkZW50aWZpZXJzID0gY29tcGFyZUlkZW50aWZpZXJzO1xuXG52YXIgbnVtZXJpYyA9IC9eWzAtOV0rJC87XG5mdW5jdGlvbiBjb21wYXJlSWRlbnRpZmllcnMoYSwgYikge1xuICB2YXIgYW51bSA9IG51bWVyaWMudGVzdChhKTtcbiAgdmFyIGJudW0gPSBudW1lcmljLnRlc3QoYik7XG5cbiAgaWYgKGFudW0gJiYgYm51bSkge1xuICAgIGEgPSArYTtcbiAgICBiID0gK2I7XG4gIH1cblxuICByZXR1cm4gKGFudW0gJiYgIWJudW0pID8gLTEgOlxuICAgICAgICAgKGJudW0gJiYgIWFudW0pID8gMSA6XG4gICAgICAgICBhIDwgYiA/IC0xIDpcbiAgICAgICAgIGEgPiBiID8gMSA6XG4gICAgICAgICAwO1xufVxuXG5leHBvcnRzLnJjb21wYXJlSWRlbnRpZmllcnMgPSByY29tcGFyZUlkZW50aWZpZXJzO1xuZnVuY3Rpb24gcmNvbXBhcmVJZGVudGlmaWVycyhhLCBiKSB7XG4gIHJldHVybiBjb21wYXJlSWRlbnRpZmllcnMoYiwgYSk7XG59XG5cbmV4cG9ydHMubWFqb3IgPSBtYWpvcjtcbmZ1bmN0aW9uIG1ham9yKGEsIGxvb3NlKSB7XG4gIHJldHVybiBuZXcgU2VtVmVyKGEsIGxvb3NlKS5tYWpvcjtcbn1cblxuZXhwb3J0cy5taW5vciA9IG1pbm9yO1xuZnVuY3Rpb24gbWlub3IoYSwgbG9vc2UpIHtcbiAgcmV0dXJuIG5ldyBTZW1WZXIoYSwgbG9vc2UpLm1pbm9yO1xufVxuXG5leHBvcnRzLnBhdGNoID0gcGF0Y2g7XG5mdW5jdGlvbiBwYXRjaChhLCBsb29zZSkge1xuICByZXR1cm4gbmV3IFNlbVZlcihhLCBsb29zZSkucGF0Y2g7XG59XG5cbmV4cG9ydHMuY29tcGFyZSA9IGNvbXBhcmU7XG5mdW5jdGlvbiBjb21wYXJlKGEsIGIsIGxvb3NlKSB7XG4gIHJldHVybiBuZXcgU2VtVmVyKGEsIGxvb3NlKS5jb21wYXJlKG5ldyBTZW1WZXIoYiwgbG9vc2UpKTtcbn1cblxuZXhwb3J0cy5jb21wYXJlTG9vc2UgPSBjb21wYXJlTG9vc2U7XG5mdW5jdGlvbiBjb21wYXJlTG9vc2UoYSwgYikge1xuICByZXR1cm4gY29tcGFyZShhLCBiLCB0cnVlKTtcbn1cblxuZXhwb3J0cy5yY29tcGFyZSA9IHJjb21wYXJlO1xuZnVuY3Rpb24gcmNvbXBhcmUoYSwgYiwgbG9vc2UpIHtcbiAgcmV0dXJuIGNvbXBhcmUoYiwgYSwgbG9vc2UpO1xufVxuXG5leHBvcnRzLnNvcnQgPSBzb3J0O1xuZnVuY3Rpb24gc29ydChsaXN0LCBsb29zZSkge1xuICByZXR1cm4gbGlzdC5zb3J0KGZ1bmN0aW9uKGEsIGIpIHtcbiAgICByZXR1cm4gZXhwb3J0cy5jb21wYXJlKGEsIGIsIGxvb3NlKTtcbiAgfSk7XG59XG5cbmV4cG9ydHMucnNvcnQgPSByc29ydDtcbmZ1bmN0aW9uIHJzb3J0KGxpc3QsIGxvb3NlKSB7XG4gIHJldHVybiBsaXN0LnNvcnQoZnVuY3Rpb24oYSwgYikge1xuICAgIHJldHVybiBleHBvcnRzLnJjb21wYXJlKGEsIGIsIGxvb3NlKTtcbiAgfSk7XG59XG5cbmV4cG9ydHMuZ3QgPSBndDtcbmZ1bmN0aW9uIGd0KGEsIGIsIGxvb3NlKSB7XG4gIHJldHVybiBjb21wYXJlKGEsIGIsIGxvb3NlKSA+IDA7XG59XG5cbmV4cG9ydHMubHQgPSBsdDtcbmZ1bmN0aW9uIGx0KGEsIGIsIGxvb3NlKSB7XG4gIHJldHVybiBjb21wYXJlKGEsIGIsIGxvb3NlKSA8IDA7XG59XG5cbmV4cG9ydHMuZXEgPSBlcTtcbmZ1bmN0aW9uIGVxKGEsIGIsIGxvb3NlKSB7XG4gIHJldHVybiBjb21wYXJlKGEsIGIsIGxvb3NlKSA9PT0gMDtcbn1cblxuZXhwb3J0cy5uZXEgPSBuZXE7XG5mdW5jdGlvbiBuZXEoYSwgYiwgbG9vc2UpIHtcbiAgcmV0dXJuIGNvbXBhcmUoYSwgYiwgbG9vc2UpICE9PSAwO1xufVxuXG5leHBvcnRzLmd0ZSA9IGd0ZTtcbmZ1bmN0aW9uIGd0ZShhLCBiLCBsb29zZSkge1xuICByZXR1cm4gY29tcGFyZShhLCBiLCBsb29zZSkgPj0gMDtcbn1cblxuZXhwb3J0cy5sdGUgPSBsdGU7XG5mdW5jdGlvbiBsdGUoYSwgYiwgbG9vc2UpIHtcbiAgcmV0dXJuIGNvbXBhcmUoYSwgYiwgbG9vc2UpIDw9IDA7XG59XG5cbmV4cG9ydHMuY21wID0gY21wO1xuZnVuY3Rpb24gY21wKGEsIG9wLCBiLCBsb29zZSkge1xuICB2YXIgcmV0O1xuICBzd2l0Y2ggKG9wKSB7XG4gICAgY2FzZSAnPT09JzpcbiAgICAgIGlmICh0eXBlb2YgYSA9PT0gJ29iamVjdCcpIGEgPSBhLnZlcnNpb247XG4gICAgICBpZiAodHlwZW9mIGIgPT09ICdvYmplY3QnKSBiID0gYi52ZXJzaW9uO1xuICAgICAgcmV0ID0gYSA9PT0gYjtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJyE9PSc6XG4gICAgICBpZiAodHlwZW9mIGEgPT09ICdvYmplY3QnKSBhID0gYS52ZXJzaW9uO1xuICAgICAgaWYgKHR5cGVvZiBiID09PSAnb2JqZWN0JykgYiA9IGIudmVyc2lvbjtcbiAgICAgIHJldCA9IGEgIT09IGI7XG4gICAgICBicmVhaztcbiAgICBjYXNlICcnOiBjYXNlICc9JzogY2FzZSAnPT0nOiByZXQgPSBlcShhLCBiLCBsb29zZSk7IGJyZWFrO1xuICAgIGNhc2UgJyE9JzogcmV0ID0gbmVxKGEsIGIsIGxvb3NlKTsgYnJlYWs7XG4gICAgY2FzZSAnPic6IHJldCA9IGd0KGEsIGIsIGxvb3NlKTsgYnJlYWs7XG4gICAgY2FzZSAnPj0nOiByZXQgPSBndGUoYSwgYiwgbG9vc2UpOyBicmVhaztcbiAgICBjYXNlICc8JzogcmV0ID0gbHQoYSwgYiwgbG9vc2UpOyBicmVhaztcbiAgICBjYXNlICc8PSc6IHJldCA9IGx0ZShhLCBiLCBsb29zZSk7IGJyZWFrO1xuICAgIGRlZmF1bHQ6IHRocm93IG5ldyBUeXBlRXJyb3IoJ0ludmFsaWQgb3BlcmF0b3I6ICcgKyBvcCk7XG4gIH1cbiAgcmV0dXJuIHJldDtcbn1cblxuZXhwb3J0cy5Db21wYXJhdG9yID0gQ29tcGFyYXRvcjtcbmZ1bmN0aW9uIENvbXBhcmF0b3IoY29tcCwgbG9vc2UpIHtcbiAgaWYgKGNvbXAgaW5zdGFuY2VvZiBDb21wYXJhdG9yKSB7XG4gICAgaWYgKGNvbXAubG9vc2UgPT09IGxvb3NlKVxuICAgICAgcmV0dXJuIGNvbXA7XG4gICAgZWxzZVxuICAgICAgY29tcCA9IGNvbXAudmFsdWU7XG4gIH1cblxuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgQ29tcGFyYXRvcikpXG4gICAgcmV0dXJuIG5ldyBDb21wYXJhdG9yKGNvbXAsIGxvb3NlKTtcblxuICBkZWJ1ZygnY29tcGFyYXRvcicsIGNvbXAsIGxvb3NlKTtcbiAgdGhpcy5sb29zZSA9IGxvb3NlO1xuICB0aGlzLnBhcnNlKGNvbXApO1xuXG4gIGlmICh0aGlzLnNlbXZlciA9PT0gQU5ZKVxuICAgIHRoaXMudmFsdWUgPSAnJztcbiAgZWxzZVxuICAgIHRoaXMudmFsdWUgPSB0aGlzLm9wZXJhdG9yICsgdGhpcy5zZW12ZXIudmVyc2lvbjtcblxuICBkZWJ1ZygnY29tcCcsIHRoaXMpO1xufVxuXG52YXIgQU5ZID0ge307XG5Db21wYXJhdG9yLnByb3RvdHlwZS5wYXJzZSA9IGZ1bmN0aW9uKGNvbXApIHtcbiAgdmFyIHIgPSB0aGlzLmxvb3NlID8gcmVbQ09NUEFSQVRPUkxPT1NFXSA6IHJlW0NPTVBBUkFUT1JdO1xuICB2YXIgbSA9IGNvbXAubWF0Y2gocik7XG5cbiAgaWYgKCFtKVxuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0ludmFsaWQgY29tcGFyYXRvcjogJyArIGNvbXApO1xuXG4gIHRoaXMub3BlcmF0b3IgPSBtWzFdO1xuICBpZiAodGhpcy5vcGVyYXRvciA9PT0gJz0nKVxuICAgIHRoaXMub3BlcmF0b3IgPSAnJztcblxuICAvLyBpZiBpdCBsaXRlcmFsbHkgaXMganVzdCAnPicgb3IgJycgdGhlbiBhbGxvdyBhbnl0aGluZy5cbiAgaWYgKCFtWzJdKVxuICAgIHRoaXMuc2VtdmVyID0gQU5ZO1xuICBlbHNlXG4gICAgdGhpcy5zZW12ZXIgPSBuZXcgU2VtVmVyKG1bMl0sIHRoaXMubG9vc2UpO1xufTtcblxuQ29tcGFyYXRvci5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMudmFsdWU7XG59O1xuXG5Db21wYXJhdG9yLnByb3RvdHlwZS50ZXN0ID0gZnVuY3Rpb24odmVyc2lvbikge1xuICBkZWJ1ZygnQ29tcGFyYXRvci50ZXN0JywgdmVyc2lvbiwgdGhpcy5sb29zZSk7XG5cbiAgaWYgKHRoaXMuc2VtdmVyID09PSBBTlkpXG4gICAgcmV0dXJuIHRydWU7XG5cbiAgaWYgKHR5cGVvZiB2ZXJzaW9uID09PSAnc3RyaW5nJylcbiAgICB2ZXJzaW9uID0gbmV3IFNlbVZlcih2ZXJzaW9uLCB0aGlzLmxvb3NlKTtcblxuICByZXR1cm4gY21wKHZlcnNpb24sIHRoaXMub3BlcmF0b3IsIHRoaXMuc2VtdmVyLCB0aGlzLmxvb3NlKTtcbn07XG5cbkNvbXBhcmF0b3IucHJvdG90eXBlLmludGVyc2VjdHMgPSBmdW5jdGlvbihjb21wLCBsb29zZSkge1xuICBpZiAoIShjb21wIGluc3RhbmNlb2YgQ29tcGFyYXRvcikpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdhIENvbXBhcmF0b3IgaXMgcmVxdWlyZWQnKTtcbiAgfVxuXG4gIHZhciByYW5nZVRtcDtcblxuICBpZiAodGhpcy5vcGVyYXRvciA9PT0gJycpIHtcbiAgICByYW5nZVRtcCA9IG5ldyBSYW5nZShjb21wLnZhbHVlLCBsb29zZSk7XG4gICAgcmV0dXJuIHNhdGlzZmllcyh0aGlzLnZhbHVlLCByYW5nZVRtcCwgbG9vc2UpO1xuICB9IGVsc2UgaWYgKGNvbXAub3BlcmF0b3IgPT09ICcnKSB7XG4gICAgcmFuZ2VUbXAgPSBuZXcgUmFuZ2UodGhpcy52YWx1ZSwgbG9vc2UpO1xuICAgIHJldHVybiBzYXRpc2ZpZXMoY29tcC5zZW12ZXIsIHJhbmdlVG1wLCBsb29zZSk7XG4gIH1cblxuICB2YXIgc2FtZURpcmVjdGlvbkluY3JlYXNpbmcgPVxuICAgICh0aGlzLm9wZXJhdG9yID09PSAnPj0nIHx8IHRoaXMub3BlcmF0b3IgPT09ICc+JykgJiZcbiAgICAoY29tcC5vcGVyYXRvciA9PT0gJz49JyB8fCBjb21wLm9wZXJhdG9yID09PSAnPicpO1xuICB2YXIgc2FtZURpcmVjdGlvbkRlY3JlYXNpbmcgPVxuICAgICh0aGlzLm9wZXJhdG9yID09PSAnPD0nIHx8IHRoaXMub3BlcmF0b3IgPT09ICc8JykgJiZcbiAgICAoY29tcC5vcGVyYXRvciA9PT0gJzw9JyB8fCBjb21wLm9wZXJhdG9yID09PSAnPCcpO1xuICB2YXIgc2FtZVNlbVZlciA9IHRoaXMuc2VtdmVyLnZlcnNpb24gPT09IGNvbXAuc2VtdmVyLnZlcnNpb247XG4gIHZhciBkaWZmZXJlbnREaXJlY3Rpb25zSW5jbHVzaXZlID1cbiAgICAodGhpcy5vcGVyYXRvciA9PT0gJz49JyB8fCB0aGlzLm9wZXJhdG9yID09PSAnPD0nKSAmJlxuICAgIChjb21wLm9wZXJhdG9yID09PSAnPj0nIHx8IGNvbXAub3BlcmF0b3IgPT09ICc8PScpO1xuICB2YXIgb3Bwb3NpdGVEaXJlY3Rpb25zTGVzc1RoYW4gPVxuICAgIGNtcCh0aGlzLnNlbXZlciwgJzwnLCBjb21wLnNlbXZlciwgbG9vc2UpICYmXG4gICAgKCh0aGlzLm9wZXJhdG9yID09PSAnPj0nIHx8IHRoaXMub3BlcmF0b3IgPT09ICc+JykgJiZcbiAgICAoY29tcC5vcGVyYXRvciA9PT0gJzw9JyB8fCBjb21wLm9wZXJhdG9yID09PSAnPCcpKTtcbiAgdmFyIG9wcG9zaXRlRGlyZWN0aW9uc0dyZWF0ZXJUaGFuID1cbiAgICBjbXAodGhpcy5zZW12ZXIsICc+JywgY29tcC5zZW12ZXIsIGxvb3NlKSAmJlxuICAgICgodGhpcy5vcGVyYXRvciA9PT0gJzw9JyB8fCB0aGlzLm9wZXJhdG9yID09PSAnPCcpICYmXG4gICAgKGNvbXAub3BlcmF0b3IgPT09ICc+PScgfHwgY29tcC5vcGVyYXRvciA9PT0gJz4nKSk7XG5cbiAgcmV0dXJuIHNhbWVEaXJlY3Rpb25JbmNyZWFzaW5nIHx8IHNhbWVEaXJlY3Rpb25EZWNyZWFzaW5nIHx8XG4gICAgKHNhbWVTZW1WZXIgJiYgZGlmZmVyZW50RGlyZWN0aW9uc0luY2x1c2l2ZSkgfHxcbiAgICBvcHBvc2l0ZURpcmVjdGlvbnNMZXNzVGhhbiB8fCBvcHBvc2l0ZURpcmVjdGlvbnNHcmVhdGVyVGhhbjtcbn07XG5cblxuZXhwb3J0cy5SYW5nZSA9IFJhbmdlO1xuZnVuY3Rpb24gUmFuZ2UocmFuZ2UsIGxvb3NlKSB7XG4gIGlmIChyYW5nZSBpbnN0YW5jZW9mIFJhbmdlKSB7XG4gICAgaWYgKHJhbmdlLmxvb3NlID09PSBsb29zZSkge1xuICAgICAgcmV0dXJuIHJhbmdlO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gbmV3IFJhbmdlKHJhbmdlLnJhdywgbG9vc2UpO1xuICAgIH1cbiAgfVxuXG4gIGlmIChyYW5nZSBpbnN0YW5jZW9mIENvbXBhcmF0b3IpIHtcbiAgICByZXR1cm4gbmV3IFJhbmdlKHJhbmdlLnZhbHVlLCBsb29zZSk7XG4gIH1cblxuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgUmFuZ2UpKVxuICAgIHJldHVybiBuZXcgUmFuZ2UocmFuZ2UsIGxvb3NlKTtcblxuICB0aGlzLmxvb3NlID0gbG9vc2U7XG5cbiAgLy8gRmlyc3QsIHNwbGl0IGJhc2VkIG9uIGJvb2xlYW4gb3IgfHxcbiAgdGhpcy5yYXcgPSByYW5nZTtcbiAgdGhpcy5zZXQgPSByYW5nZS5zcGxpdCgvXFxzKlxcfFxcfFxccyovKS5tYXAoZnVuY3Rpb24ocmFuZ2UpIHtcbiAgICByZXR1cm4gdGhpcy5wYXJzZVJhbmdlKHJhbmdlLnRyaW0oKSk7XG4gIH0sIHRoaXMpLmZpbHRlcihmdW5jdGlvbihjKSB7XG4gICAgLy8gdGhyb3cgb3V0IGFueSB0aGF0IGFyZSBub3QgcmVsZXZhbnQgZm9yIHdoYXRldmVyIHJlYXNvblxuICAgIHJldHVybiBjLmxlbmd0aDtcbiAgfSk7XG5cbiAgaWYgKCF0aGlzLnNldC5sZW5ndGgpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdJbnZhbGlkIFNlbVZlciBSYW5nZTogJyArIHJhbmdlKTtcbiAgfVxuXG4gIHRoaXMuZm9ybWF0KCk7XG59XG5cblJhbmdlLnByb3RvdHlwZS5mb3JtYXQgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5yYW5nZSA9IHRoaXMuc2V0Lm1hcChmdW5jdGlvbihjb21wcykge1xuICAgIHJldHVybiBjb21wcy5qb2luKCcgJykudHJpbSgpO1xuICB9KS5qb2luKCd8fCcpLnRyaW0oKTtcbiAgcmV0dXJuIHRoaXMucmFuZ2U7XG59O1xuXG5SYW5nZS5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMucmFuZ2U7XG59O1xuXG5SYW5nZS5wcm90b3R5cGUucGFyc2VSYW5nZSA9IGZ1bmN0aW9uKHJhbmdlKSB7XG4gIHZhciBsb29zZSA9IHRoaXMubG9vc2U7XG4gIHJhbmdlID0gcmFuZ2UudHJpbSgpO1xuICBkZWJ1ZygncmFuZ2UnLCByYW5nZSwgbG9vc2UpO1xuICAvLyBgMS4yLjMgLSAxLjIuNGAgPT4gYD49MS4yLjMgPD0xLjIuNGBcbiAgdmFyIGhyID0gbG9vc2UgPyByZVtIWVBIRU5SQU5HRUxPT1NFXSA6IHJlW0hZUEhFTlJBTkdFXTtcbiAgcmFuZ2UgPSByYW5nZS5yZXBsYWNlKGhyLCBoeXBoZW5SZXBsYWNlKTtcbiAgZGVidWcoJ2h5cGhlbiByZXBsYWNlJywgcmFuZ2UpO1xuICAvLyBgPiAxLjIuMyA8IDEuMi41YCA9PiBgPjEuMi4zIDwxLjIuNWBcbiAgcmFuZ2UgPSByYW5nZS5yZXBsYWNlKHJlW0NPTVBBUkFUT1JUUklNXSwgY29tcGFyYXRvclRyaW1SZXBsYWNlKTtcbiAgZGVidWcoJ2NvbXBhcmF0b3IgdHJpbScsIHJhbmdlLCByZVtDT01QQVJBVE9SVFJJTV0pO1xuXG4gIC8vIGB+IDEuMi4zYCA9PiBgfjEuMi4zYFxuICByYW5nZSA9IHJhbmdlLnJlcGxhY2UocmVbVElMREVUUklNXSwgdGlsZGVUcmltUmVwbGFjZSk7XG5cbiAgLy8gYF4gMS4yLjNgID0+IGBeMS4yLjNgXG4gIHJhbmdlID0gcmFuZ2UucmVwbGFjZShyZVtDQVJFVFRSSU1dLCBjYXJldFRyaW1SZXBsYWNlKTtcblxuICAvLyBub3JtYWxpemUgc3BhY2VzXG4gIHJhbmdlID0gcmFuZ2Uuc3BsaXQoL1xccysvKS5qb2luKCcgJyk7XG5cbiAgLy8gQXQgdGhpcyBwb2ludCwgdGhlIHJhbmdlIGlzIGNvbXBsZXRlbHkgdHJpbW1lZCBhbmRcbiAgLy8gcmVhZHkgdG8gYmUgc3BsaXQgaW50byBjb21wYXJhdG9ycy5cblxuICB2YXIgY29tcFJlID0gbG9vc2UgPyByZVtDT01QQVJBVE9STE9PU0VdIDogcmVbQ09NUEFSQVRPUl07XG4gIHZhciBzZXQgPSByYW5nZS5zcGxpdCgnICcpLm1hcChmdW5jdGlvbihjb21wKSB7XG4gICAgcmV0dXJuIHBhcnNlQ29tcGFyYXRvcihjb21wLCBsb29zZSk7XG4gIH0pLmpvaW4oJyAnKS5zcGxpdCgvXFxzKy8pO1xuICBpZiAodGhpcy5sb29zZSkge1xuICAgIC8vIGluIGxvb3NlIG1vZGUsIHRocm93IG91dCBhbnkgdGhhdCBhcmUgbm90IHZhbGlkIGNvbXBhcmF0b3JzXG4gICAgc2V0ID0gc2V0LmZpbHRlcihmdW5jdGlvbihjb21wKSB7XG4gICAgICByZXR1cm4gISFjb21wLm1hdGNoKGNvbXBSZSk7XG4gICAgfSk7XG4gIH1cbiAgc2V0ID0gc2V0Lm1hcChmdW5jdGlvbihjb21wKSB7XG4gICAgcmV0dXJuIG5ldyBDb21wYXJhdG9yKGNvbXAsIGxvb3NlKTtcbiAgfSk7XG5cbiAgcmV0dXJuIHNldDtcbn07XG5cblJhbmdlLnByb3RvdHlwZS5pbnRlcnNlY3RzID0gZnVuY3Rpb24ocmFuZ2UsIGxvb3NlKSB7XG4gIGlmICghKHJhbmdlIGluc3RhbmNlb2YgUmFuZ2UpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignYSBSYW5nZSBpcyByZXF1aXJlZCcpO1xuICB9XG5cbiAgcmV0dXJuIHRoaXMuc2V0LnNvbWUoZnVuY3Rpb24odGhpc0NvbXBhcmF0b3JzKSB7XG4gICAgcmV0dXJuIHRoaXNDb21wYXJhdG9ycy5ldmVyeShmdW5jdGlvbih0aGlzQ29tcGFyYXRvcikge1xuICAgICAgcmV0dXJuIHJhbmdlLnNldC5zb21lKGZ1bmN0aW9uKHJhbmdlQ29tcGFyYXRvcnMpIHtcbiAgICAgICAgcmV0dXJuIHJhbmdlQ29tcGFyYXRvcnMuZXZlcnkoZnVuY3Rpb24ocmFuZ2VDb21wYXJhdG9yKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXNDb21wYXJhdG9yLmludGVyc2VjdHMocmFuZ2VDb21wYXJhdG9yLCBsb29zZSk7XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH0pO1xufTtcblxuLy8gTW9zdGx5IGp1c3QgZm9yIHRlc3RpbmcgYW5kIGxlZ2FjeSBBUEkgcmVhc29uc1xuZXhwb3J0cy50b0NvbXBhcmF0b3JzID0gdG9Db21wYXJhdG9ycztcbmZ1bmN0aW9uIHRvQ29tcGFyYXRvcnMocmFuZ2UsIGxvb3NlKSB7XG4gIHJldHVybiBuZXcgUmFuZ2UocmFuZ2UsIGxvb3NlKS5zZXQubWFwKGZ1bmN0aW9uKGNvbXApIHtcbiAgICByZXR1cm4gY29tcC5tYXAoZnVuY3Rpb24oYykge1xuICAgICAgcmV0dXJuIGMudmFsdWU7XG4gICAgfSkuam9pbignICcpLnRyaW0oKS5zcGxpdCgnICcpO1xuICB9KTtcbn1cblxuLy8gY29tcHJpc2VkIG9mIHhyYW5nZXMsIHRpbGRlcywgc3RhcnMsIGFuZCBndGx0J3MgYXQgdGhpcyBwb2ludC5cbi8vIGFscmVhZHkgcmVwbGFjZWQgdGhlIGh5cGhlbiByYW5nZXNcbi8vIHR1cm4gaW50byBhIHNldCBvZiBKVVNUIGNvbXBhcmF0b3JzLlxuZnVuY3Rpb24gcGFyc2VDb21wYXJhdG9yKGNvbXAsIGxvb3NlKSB7XG4gIGRlYnVnKCdjb21wJywgY29tcCk7XG4gIGNvbXAgPSByZXBsYWNlQ2FyZXRzKGNvbXAsIGxvb3NlKTtcbiAgZGVidWcoJ2NhcmV0JywgY29tcCk7XG4gIGNvbXAgPSByZXBsYWNlVGlsZGVzKGNvbXAsIGxvb3NlKTtcbiAgZGVidWcoJ3RpbGRlcycsIGNvbXApO1xuICBjb21wID0gcmVwbGFjZVhSYW5nZXMoY29tcCwgbG9vc2UpO1xuICBkZWJ1ZygneHJhbmdlJywgY29tcCk7XG4gIGNvbXAgPSByZXBsYWNlU3RhcnMoY29tcCwgbG9vc2UpO1xuICBkZWJ1Zygnc3RhcnMnLCBjb21wKTtcbiAgcmV0dXJuIGNvbXA7XG59XG5cbmZ1bmN0aW9uIGlzWChpZCkge1xuICByZXR1cm4gIWlkIHx8IGlkLnRvTG93ZXJDYXNlKCkgPT09ICd4JyB8fCBpZCA9PT0gJyonO1xufVxuXG4vLyB+LCB+PiAtLT4gKiAoYW55LCBraW5kYSBzaWxseSlcbi8vIH4yLCB+Mi54LCB+Mi54LngsIH4+Miwgfj4yLnggfj4yLngueCAtLT4gPj0yLjAuMCA8My4wLjBcbi8vIH4yLjAsIH4yLjAueCwgfj4yLjAsIH4+Mi4wLnggLS0+ID49Mi4wLjAgPDIuMS4wXG4vLyB+MS4yLCB+MS4yLngsIH4+MS4yLCB+PjEuMi54IC0tPiA+PTEuMi4wIDwxLjMuMFxuLy8gfjEuMi4zLCB+PjEuMi4zIC0tPiA+PTEuMi4zIDwxLjMuMFxuLy8gfjEuMi4wLCB+PjEuMi4wIC0tPiA+PTEuMi4wIDwxLjMuMFxuZnVuY3Rpb24gcmVwbGFjZVRpbGRlcyhjb21wLCBsb29zZSkge1xuICByZXR1cm4gY29tcC50cmltKCkuc3BsaXQoL1xccysvKS5tYXAoZnVuY3Rpb24oY29tcCkge1xuICAgIHJldHVybiByZXBsYWNlVGlsZGUoY29tcCwgbG9vc2UpO1xuICB9KS5qb2luKCcgJyk7XG59XG5cbmZ1bmN0aW9uIHJlcGxhY2VUaWxkZShjb21wLCBsb29zZSkge1xuICB2YXIgciA9IGxvb3NlID8gcmVbVElMREVMT09TRV0gOiByZVtUSUxERV07XG4gIHJldHVybiBjb21wLnJlcGxhY2UociwgZnVuY3Rpb24oXywgTSwgbSwgcCwgcHIpIHtcbiAgICBkZWJ1ZygndGlsZGUnLCBjb21wLCBfLCBNLCBtLCBwLCBwcik7XG4gICAgdmFyIHJldDtcblxuICAgIGlmIChpc1goTSkpXG4gICAgICByZXQgPSAnJztcbiAgICBlbHNlIGlmIChpc1gobSkpXG4gICAgICByZXQgPSAnPj0nICsgTSArICcuMC4wIDwnICsgKCtNICsgMSkgKyAnLjAuMCc7XG4gICAgZWxzZSBpZiAoaXNYKHApKVxuICAgICAgLy8gfjEuMiA9PSA+PTEuMi4wIDwxLjMuMFxuICAgICAgcmV0ID0gJz49JyArIE0gKyAnLicgKyBtICsgJy4wIDwnICsgTSArICcuJyArICgrbSArIDEpICsgJy4wJztcbiAgICBlbHNlIGlmIChwcikge1xuICAgICAgZGVidWcoJ3JlcGxhY2VUaWxkZSBwcicsIHByKTtcbiAgICAgIGlmIChwci5jaGFyQXQoMCkgIT09ICctJylcbiAgICAgICAgcHIgPSAnLScgKyBwcjtcbiAgICAgIHJldCA9ICc+PScgKyBNICsgJy4nICsgbSArICcuJyArIHAgKyBwciArXG4gICAgICAgICAgICAnIDwnICsgTSArICcuJyArICgrbSArIDEpICsgJy4wJztcbiAgICB9IGVsc2VcbiAgICAgIC8vIH4xLjIuMyA9PSA+PTEuMi4zIDwxLjMuMFxuICAgICAgcmV0ID0gJz49JyArIE0gKyAnLicgKyBtICsgJy4nICsgcCArXG4gICAgICAgICAgICAnIDwnICsgTSArICcuJyArICgrbSArIDEpICsgJy4wJztcblxuICAgIGRlYnVnKCd0aWxkZSByZXR1cm4nLCByZXQpO1xuICAgIHJldHVybiByZXQ7XG4gIH0pO1xufVxuXG4vLyBeIC0tPiAqIChhbnksIGtpbmRhIHNpbGx5KVxuLy8gXjIsIF4yLngsIF4yLngueCAtLT4gPj0yLjAuMCA8My4wLjBcbi8vIF4yLjAsIF4yLjAueCAtLT4gPj0yLjAuMCA8My4wLjBcbi8vIF4xLjIsIF4xLjIueCAtLT4gPj0xLjIuMCA8Mi4wLjBcbi8vIF4xLjIuMyAtLT4gPj0xLjIuMyA8Mi4wLjBcbi8vIF4xLjIuMCAtLT4gPj0xLjIuMCA8Mi4wLjBcbmZ1bmN0aW9uIHJlcGxhY2VDYXJldHMoY29tcCwgbG9vc2UpIHtcbiAgcmV0dXJuIGNvbXAudHJpbSgpLnNwbGl0KC9cXHMrLykubWFwKGZ1bmN0aW9uKGNvbXApIHtcbiAgICByZXR1cm4gcmVwbGFjZUNhcmV0KGNvbXAsIGxvb3NlKTtcbiAgfSkuam9pbignICcpO1xufVxuXG5mdW5jdGlvbiByZXBsYWNlQ2FyZXQoY29tcCwgbG9vc2UpIHtcbiAgZGVidWcoJ2NhcmV0JywgY29tcCwgbG9vc2UpO1xuICB2YXIgciA9IGxvb3NlID8gcmVbQ0FSRVRMT09TRV0gOiByZVtDQVJFVF07XG4gIHJldHVybiBjb21wLnJlcGxhY2UociwgZnVuY3Rpb24oXywgTSwgbSwgcCwgcHIpIHtcbiAgICBkZWJ1ZygnY2FyZXQnLCBjb21wLCBfLCBNLCBtLCBwLCBwcik7XG4gICAgdmFyIHJldDtcblxuICAgIGlmIChpc1goTSkpXG4gICAgICByZXQgPSAnJztcbiAgICBlbHNlIGlmIChpc1gobSkpXG4gICAgICByZXQgPSAnPj0nICsgTSArICcuMC4wIDwnICsgKCtNICsgMSkgKyAnLjAuMCc7XG4gICAgZWxzZSBpZiAoaXNYKHApKSB7XG4gICAgICBpZiAoTSA9PT0gJzAnKVxuICAgICAgICByZXQgPSAnPj0nICsgTSArICcuJyArIG0gKyAnLjAgPCcgKyBNICsgJy4nICsgKCttICsgMSkgKyAnLjAnO1xuICAgICAgZWxzZVxuICAgICAgICByZXQgPSAnPj0nICsgTSArICcuJyArIG0gKyAnLjAgPCcgKyAoK00gKyAxKSArICcuMC4wJztcbiAgICB9IGVsc2UgaWYgKHByKSB7XG4gICAgICBkZWJ1ZygncmVwbGFjZUNhcmV0IHByJywgcHIpO1xuICAgICAgaWYgKHByLmNoYXJBdCgwKSAhPT0gJy0nKVxuICAgICAgICBwciA9ICctJyArIHByO1xuICAgICAgaWYgKE0gPT09ICcwJykge1xuICAgICAgICBpZiAobSA9PT0gJzAnKVxuICAgICAgICAgIHJldCA9ICc+PScgKyBNICsgJy4nICsgbSArICcuJyArIHAgKyBwciArXG4gICAgICAgICAgICAgICAgJyA8JyArIE0gKyAnLicgKyBtICsgJy4nICsgKCtwICsgMSk7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICByZXQgPSAnPj0nICsgTSArICcuJyArIG0gKyAnLicgKyBwICsgcHIgK1xuICAgICAgICAgICAgICAgICcgPCcgKyBNICsgJy4nICsgKCttICsgMSkgKyAnLjAnO1xuICAgICAgfSBlbHNlXG4gICAgICAgIHJldCA9ICc+PScgKyBNICsgJy4nICsgbSArICcuJyArIHAgKyBwciArXG4gICAgICAgICAgICAgICcgPCcgKyAoK00gKyAxKSArICcuMC4wJztcbiAgICB9IGVsc2Uge1xuICAgICAgZGVidWcoJ25vIHByJyk7XG4gICAgICBpZiAoTSA9PT0gJzAnKSB7XG4gICAgICAgIGlmIChtID09PSAnMCcpXG4gICAgICAgICAgcmV0ID0gJz49JyArIE0gKyAnLicgKyBtICsgJy4nICsgcCArXG4gICAgICAgICAgICAgICAgJyA8JyArIE0gKyAnLicgKyBtICsgJy4nICsgKCtwICsgMSk7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICByZXQgPSAnPj0nICsgTSArICcuJyArIG0gKyAnLicgKyBwICtcbiAgICAgICAgICAgICAgICAnIDwnICsgTSArICcuJyArICgrbSArIDEpICsgJy4wJztcbiAgICAgIH0gZWxzZVxuICAgICAgICByZXQgPSAnPj0nICsgTSArICcuJyArIG0gKyAnLicgKyBwICtcbiAgICAgICAgICAgICAgJyA8JyArICgrTSArIDEpICsgJy4wLjAnO1xuICAgIH1cblxuICAgIGRlYnVnKCdjYXJldCByZXR1cm4nLCByZXQpO1xuICAgIHJldHVybiByZXQ7XG4gIH0pO1xufVxuXG5mdW5jdGlvbiByZXBsYWNlWFJhbmdlcyhjb21wLCBsb29zZSkge1xuICBkZWJ1ZygncmVwbGFjZVhSYW5nZXMnLCBjb21wLCBsb29zZSk7XG4gIHJldHVybiBjb21wLnNwbGl0KC9cXHMrLykubWFwKGZ1bmN0aW9uKGNvbXApIHtcbiAgICByZXR1cm4gcmVwbGFjZVhSYW5nZShjb21wLCBsb29zZSk7XG4gIH0pLmpvaW4oJyAnKTtcbn1cblxuZnVuY3Rpb24gcmVwbGFjZVhSYW5nZShjb21wLCBsb29zZSkge1xuICBjb21wID0gY29tcC50cmltKCk7XG4gIHZhciByID0gbG9vc2UgPyByZVtYUkFOR0VMT09TRV0gOiByZVtYUkFOR0VdO1xuICByZXR1cm4gY29tcC5yZXBsYWNlKHIsIGZ1bmN0aW9uKHJldCwgZ3RsdCwgTSwgbSwgcCwgcHIpIHtcbiAgICBkZWJ1ZygneFJhbmdlJywgY29tcCwgcmV0LCBndGx0LCBNLCBtLCBwLCBwcik7XG4gICAgdmFyIHhNID0gaXNYKE0pO1xuICAgIHZhciB4bSA9IHhNIHx8IGlzWChtKTtcbiAgICB2YXIgeHAgPSB4bSB8fCBpc1gocCk7XG4gICAgdmFyIGFueVggPSB4cDtcblxuICAgIGlmIChndGx0ID09PSAnPScgJiYgYW55WClcbiAgICAgIGd0bHQgPSAnJztcblxuICAgIGlmICh4TSkge1xuICAgICAgaWYgKGd0bHQgPT09ICc+JyB8fCBndGx0ID09PSAnPCcpIHtcbiAgICAgICAgLy8gbm90aGluZyBpcyBhbGxvd2VkXG4gICAgICAgIHJldCA9ICc8MC4wLjAnO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gbm90aGluZyBpcyBmb3JiaWRkZW5cbiAgICAgICAgcmV0ID0gJyonO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoZ3RsdCAmJiBhbnlYKSB7XG4gICAgICAvLyByZXBsYWNlIFggd2l0aCAwXG4gICAgICBpZiAoeG0pXG4gICAgICAgIG0gPSAwO1xuICAgICAgaWYgKHhwKVxuICAgICAgICBwID0gMDtcblxuICAgICAgaWYgKGd0bHQgPT09ICc+Jykge1xuICAgICAgICAvLyA+MSA9PiA+PTIuMC4wXG4gICAgICAgIC8vID4xLjIgPT4gPj0xLjMuMFxuICAgICAgICAvLyA+MS4yLjMgPT4gPj0gMS4yLjRcbiAgICAgICAgZ3RsdCA9ICc+PSc7XG4gICAgICAgIGlmICh4bSkge1xuICAgICAgICAgIE0gPSArTSArIDE7XG4gICAgICAgICAgbSA9IDA7XG4gICAgICAgICAgcCA9IDA7XG4gICAgICAgIH0gZWxzZSBpZiAoeHApIHtcbiAgICAgICAgICBtID0gK20gKyAxO1xuICAgICAgICAgIHAgPSAwO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGd0bHQgPT09ICc8PScpIHtcbiAgICAgICAgLy8gPD0wLjcueCBpcyBhY3R1YWxseSA8MC44LjAsIHNpbmNlIGFueSAwLjcueCBzaG91bGRcbiAgICAgICAgLy8gcGFzcy4gIFNpbWlsYXJseSwgPD03LnggaXMgYWN0dWFsbHkgPDguMC4wLCBldGMuXG4gICAgICAgIGd0bHQgPSAnPCc7XG4gICAgICAgIGlmICh4bSlcbiAgICAgICAgICBNID0gK00gKyAxO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgbSA9ICttICsgMTtcbiAgICAgIH1cblxuICAgICAgcmV0ID0gZ3RsdCArIE0gKyAnLicgKyBtICsgJy4nICsgcDtcbiAgICB9IGVsc2UgaWYgKHhtKSB7XG4gICAgICByZXQgPSAnPj0nICsgTSArICcuMC4wIDwnICsgKCtNICsgMSkgKyAnLjAuMCc7XG4gICAgfSBlbHNlIGlmICh4cCkge1xuICAgICAgcmV0ID0gJz49JyArIE0gKyAnLicgKyBtICsgJy4wIDwnICsgTSArICcuJyArICgrbSArIDEpICsgJy4wJztcbiAgICB9XG5cbiAgICBkZWJ1ZygneFJhbmdlIHJldHVybicsIHJldCk7XG5cbiAgICByZXR1cm4gcmV0O1xuICB9KTtcbn1cblxuLy8gQmVjYXVzZSAqIGlzIEFORC1lZCB3aXRoIGV2ZXJ5dGhpbmcgZWxzZSBpbiB0aGUgY29tcGFyYXRvcixcbi8vIGFuZCAnJyBtZWFucyBcImFueSB2ZXJzaW9uXCIsIGp1c3QgcmVtb3ZlIHRoZSAqcyBlbnRpcmVseS5cbmZ1bmN0aW9uIHJlcGxhY2VTdGFycyhjb21wLCBsb29zZSkge1xuICBkZWJ1ZygncmVwbGFjZVN0YXJzJywgY29tcCwgbG9vc2UpO1xuICAvLyBMb29zZW5lc3MgaXMgaWdub3JlZCBoZXJlLiAgc3RhciBpcyBhbHdheXMgYXMgbG9vc2UgYXMgaXQgZ2V0cyFcbiAgcmV0dXJuIGNvbXAudHJpbSgpLnJlcGxhY2UocmVbU1RBUl0sICcnKTtcbn1cblxuLy8gVGhpcyBmdW5jdGlvbiBpcyBwYXNzZWQgdG8gc3RyaW5nLnJlcGxhY2UocmVbSFlQSEVOUkFOR0VdKVxuLy8gTSwgbSwgcGF0Y2gsIHByZXJlbGVhc2UsIGJ1aWxkXG4vLyAxLjIgLSAzLjQuNSA9PiA+PTEuMi4wIDw9My40LjVcbi8vIDEuMi4zIC0gMy40ID0+ID49MS4yLjAgPDMuNS4wIEFueSAzLjQueCB3aWxsIGRvXG4vLyAxLjIgLSAzLjQgPT4gPj0xLjIuMCA8My41LjBcbmZ1bmN0aW9uIGh5cGhlblJlcGxhY2UoJDAsXG4gICAgICAgICAgICAgICAgICAgICAgIGZyb20sIGZNLCBmbSwgZnAsIGZwciwgZmIsXG4gICAgICAgICAgICAgICAgICAgICAgIHRvLCB0TSwgdG0sIHRwLCB0cHIsIHRiKSB7XG5cbiAgaWYgKGlzWChmTSkpXG4gICAgZnJvbSA9ICcnO1xuICBlbHNlIGlmIChpc1goZm0pKVxuICAgIGZyb20gPSAnPj0nICsgZk0gKyAnLjAuMCc7XG4gIGVsc2UgaWYgKGlzWChmcCkpXG4gICAgZnJvbSA9ICc+PScgKyBmTSArICcuJyArIGZtICsgJy4wJztcbiAgZWxzZVxuICAgIGZyb20gPSAnPj0nICsgZnJvbTtcblxuICBpZiAoaXNYKHRNKSlcbiAgICB0byA9ICcnO1xuICBlbHNlIGlmIChpc1godG0pKVxuICAgIHRvID0gJzwnICsgKCt0TSArIDEpICsgJy4wLjAnO1xuICBlbHNlIGlmIChpc1godHApKVxuICAgIHRvID0gJzwnICsgdE0gKyAnLicgKyAoK3RtICsgMSkgKyAnLjAnO1xuICBlbHNlIGlmICh0cHIpXG4gICAgdG8gPSAnPD0nICsgdE0gKyAnLicgKyB0bSArICcuJyArIHRwICsgJy0nICsgdHByO1xuICBlbHNlXG4gICAgdG8gPSAnPD0nICsgdG87XG5cbiAgcmV0dXJuIChmcm9tICsgJyAnICsgdG8pLnRyaW0oKTtcbn1cblxuXG4vLyBpZiBBTlkgb2YgdGhlIHNldHMgbWF0Y2ggQUxMIG9mIGl0cyBjb21wYXJhdG9ycywgdGhlbiBwYXNzXG5SYW5nZS5wcm90b3R5cGUudGVzdCA9IGZ1bmN0aW9uKHZlcnNpb24pIHtcbiAgaWYgKCF2ZXJzaW9uKVxuICAgIHJldHVybiBmYWxzZTtcblxuICBpZiAodHlwZW9mIHZlcnNpb24gPT09ICdzdHJpbmcnKVxuICAgIHZlcnNpb24gPSBuZXcgU2VtVmVyKHZlcnNpb24sIHRoaXMubG9vc2UpO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5zZXQubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAodGVzdFNldCh0aGlzLnNldFtpXSwgdmVyc2lvbikpXG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59O1xuXG5mdW5jdGlvbiB0ZXN0U2V0KHNldCwgdmVyc2lvbikge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHNldC5sZW5ndGg7IGkrKykge1xuICAgIGlmICghc2V0W2ldLnRlc3QodmVyc2lvbikpXG4gICAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBpZiAodmVyc2lvbi5wcmVyZWxlYXNlLmxlbmd0aCkge1xuICAgIC8vIEZpbmQgdGhlIHNldCBvZiB2ZXJzaW9ucyB0aGF0IGFyZSBhbGxvd2VkIHRvIGhhdmUgcHJlcmVsZWFzZXNcbiAgICAvLyBGb3IgZXhhbXBsZSwgXjEuMi4zLXByLjEgZGVzdWdhcnMgdG8gPj0xLjIuMy1wci4xIDwyLjAuMFxuICAgIC8vIFRoYXQgc2hvdWxkIGFsbG93IGAxLjIuMy1wci4yYCB0byBwYXNzLlxuICAgIC8vIEhvd2V2ZXIsIGAxLjIuNC1hbHBoYS5ub3RyZWFkeWAgc2hvdWxkIE5PVCBiZSBhbGxvd2VkLFxuICAgIC8vIGV2ZW4gdGhvdWdoIGl0J3Mgd2l0aGluIHRoZSByYW5nZSBzZXQgYnkgdGhlIGNvbXBhcmF0b3JzLlxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2V0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICBkZWJ1ZyhzZXRbaV0uc2VtdmVyKTtcbiAgICAgIGlmIChzZXRbaV0uc2VtdmVyID09PSBBTlkpXG4gICAgICAgIGNvbnRpbnVlO1xuXG4gICAgICBpZiAoc2V0W2ldLnNlbXZlci5wcmVyZWxlYXNlLmxlbmd0aCA+IDApIHtcbiAgICAgICAgdmFyIGFsbG93ZWQgPSBzZXRbaV0uc2VtdmVyO1xuICAgICAgICBpZiAoYWxsb3dlZC5tYWpvciA9PT0gdmVyc2lvbi5tYWpvciAmJlxuICAgICAgICAgICAgYWxsb3dlZC5taW5vciA9PT0gdmVyc2lvbi5taW5vciAmJlxuICAgICAgICAgICAgYWxsb3dlZC5wYXRjaCA9PT0gdmVyc2lvbi5wYXRjaClcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBWZXJzaW9uIGhhcyBhIC1wcmUsIGJ1dCBpdCdzIG5vdCBvbmUgb2YgdGhlIG9uZXMgd2UgbGlrZS5cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn1cblxuZXhwb3J0cy5zYXRpc2ZpZXMgPSBzYXRpc2ZpZXM7XG5mdW5jdGlvbiBzYXRpc2ZpZXModmVyc2lvbiwgcmFuZ2UsIGxvb3NlKSB7XG4gIHRyeSB7XG4gICAgcmFuZ2UgPSBuZXcgUmFuZ2UocmFuZ2UsIGxvb3NlKTtcbiAgfSBjYXRjaCAoZXIpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIHJhbmdlLnRlc3QodmVyc2lvbik7XG59XG5cbmV4cG9ydHMubWF4U2F0aXNmeWluZyA9IG1heFNhdGlzZnlpbmc7XG5mdW5jdGlvbiBtYXhTYXRpc2Z5aW5nKHZlcnNpb25zLCByYW5nZSwgbG9vc2UpIHtcbiAgdmFyIG1heCA9IG51bGw7XG4gIHZhciBtYXhTViA9IG51bGw7XG4gIHRyeSB7XG4gICAgdmFyIHJhbmdlT2JqID0gbmV3IFJhbmdlKHJhbmdlLCBsb29zZSk7XG4gIH0gY2F0Y2ggKGVyKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgdmVyc2lvbnMuZm9yRWFjaChmdW5jdGlvbiAodikge1xuICAgIGlmIChyYW5nZU9iai50ZXN0KHYpKSB7IC8vIHNhdGlzZmllcyh2LCByYW5nZSwgbG9vc2UpXG4gICAgICBpZiAoIW1heCB8fCBtYXhTVi5jb21wYXJlKHYpID09PSAtMSkgeyAvLyBjb21wYXJlKG1heCwgdiwgdHJ1ZSlcbiAgICAgICAgbWF4ID0gdjtcbiAgICAgICAgbWF4U1YgPSBuZXcgU2VtVmVyKG1heCwgbG9vc2UpO1xuICAgICAgfVxuICAgIH1cbiAgfSlcbiAgcmV0dXJuIG1heDtcbn1cblxuZXhwb3J0cy5taW5TYXRpc2Z5aW5nID0gbWluU2F0aXNmeWluZztcbmZ1bmN0aW9uIG1pblNhdGlzZnlpbmcodmVyc2lvbnMsIHJhbmdlLCBsb29zZSkge1xuICB2YXIgbWluID0gbnVsbDtcbiAgdmFyIG1pblNWID0gbnVsbDtcbiAgdHJ5IHtcbiAgICB2YXIgcmFuZ2VPYmogPSBuZXcgUmFuZ2UocmFuZ2UsIGxvb3NlKTtcbiAgfSBjYXRjaCAoZXIpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICB2ZXJzaW9ucy5mb3JFYWNoKGZ1bmN0aW9uICh2KSB7XG4gICAgaWYgKHJhbmdlT2JqLnRlc3QodikpIHsgLy8gc2F0aXNmaWVzKHYsIHJhbmdlLCBsb29zZSlcbiAgICAgIGlmICghbWluIHx8IG1pblNWLmNvbXBhcmUodikgPT09IDEpIHsgLy8gY29tcGFyZShtaW4sIHYsIHRydWUpXG4gICAgICAgIG1pbiA9IHY7XG4gICAgICAgIG1pblNWID0gbmV3IFNlbVZlcihtaW4sIGxvb3NlKTtcbiAgICAgIH1cbiAgICB9XG4gIH0pXG4gIHJldHVybiBtaW47XG59XG5cbmV4cG9ydHMudmFsaWRSYW5nZSA9IHZhbGlkUmFuZ2U7XG5mdW5jdGlvbiB2YWxpZFJhbmdlKHJhbmdlLCBsb29zZSkge1xuICB0cnkge1xuICAgIC8vIFJldHVybiAnKicgaW5zdGVhZCBvZiAnJyBzbyB0aGF0IHRydXRoaW5lc3Mgd29ya3MuXG4gICAgLy8gVGhpcyB3aWxsIHRocm93IGlmIGl0J3MgaW52YWxpZCBhbnl3YXlcbiAgICByZXR1cm4gbmV3IFJhbmdlKHJhbmdlLCBsb29zZSkucmFuZ2UgfHwgJyonO1xuICB9IGNhdGNoIChlcikge1xuICAgIHJldHVybiBudWxsO1xuICB9XG59XG5cbi8vIERldGVybWluZSBpZiB2ZXJzaW9uIGlzIGxlc3MgdGhhbiBhbGwgdGhlIHZlcnNpb25zIHBvc3NpYmxlIGluIHRoZSByYW5nZVxuZXhwb3J0cy5sdHIgPSBsdHI7XG5mdW5jdGlvbiBsdHIodmVyc2lvbiwgcmFuZ2UsIGxvb3NlKSB7XG4gIHJldHVybiBvdXRzaWRlKHZlcnNpb24sIHJhbmdlLCAnPCcsIGxvb3NlKTtcbn1cblxuLy8gRGV0ZXJtaW5lIGlmIHZlcnNpb24gaXMgZ3JlYXRlciB0aGFuIGFsbCB0aGUgdmVyc2lvbnMgcG9zc2libGUgaW4gdGhlIHJhbmdlLlxuZXhwb3J0cy5ndHIgPSBndHI7XG5mdW5jdGlvbiBndHIodmVyc2lvbiwgcmFuZ2UsIGxvb3NlKSB7XG4gIHJldHVybiBvdXRzaWRlKHZlcnNpb24sIHJhbmdlLCAnPicsIGxvb3NlKTtcbn1cblxuZXhwb3J0cy5vdXRzaWRlID0gb3V0c2lkZTtcbmZ1bmN0aW9uIG91dHNpZGUodmVyc2lvbiwgcmFuZ2UsIGhpbG8sIGxvb3NlKSB7XG4gIHZlcnNpb24gPSBuZXcgU2VtVmVyKHZlcnNpb24sIGxvb3NlKTtcbiAgcmFuZ2UgPSBuZXcgUmFuZ2UocmFuZ2UsIGxvb3NlKTtcblxuICB2YXIgZ3RmbiwgbHRlZm4sIGx0Zm4sIGNvbXAsIGVjb21wO1xuICBzd2l0Y2ggKGhpbG8pIHtcbiAgICBjYXNlICc+JzpcbiAgICAgIGd0Zm4gPSBndDtcbiAgICAgIGx0ZWZuID0gbHRlO1xuICAgICAgbHRmbiA9IGx0O1xuICAgICAgY29tcCA9ICc+JztcbiAgICAgIGVjb21wID0gJz49JztcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJzwnOlxuICAgICAgZ3RmbiA9IGx0O1xuICAgICAgbHRlZm4gPSBndGU7XG4gICAgICBsdGZuID0gZ3Q7XG4gICAgICBjb21wID0gJzwnO1xuICAgICAgZWNvbXAgPSAnPD0nO1xuICAgICAgYnJlYWs7XG4gICAgZGVmYXVsdDpcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ011c3QgcHJvdmlkZSBhIGhpbG8gdmFsIG9mIFwiPFwiIG9yIFwiPlwiJyk7XG4gIH1cblxuICAvLyBJZiBpdCBzYXRpc2lmZXMgdGhlIHJhbmdlIGl0IGlzIG5vdCBvdXRzaWRlXG4gIGlmIChzYXRpc2ZpZXModmVyc2lvbiwgcmFuZ2UsIGxvb3NlKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIC8vIEZyb20gbm93IG9uLCB2YXJpYWJsZSB0ZXJtcyBhcmUgYXMgaWYgd2UncmUgaW4gXCJndHJcIiBtb2RlLlxuICAvLyBidXQgbm90ZSB0aGF0IGV2ZXJ5dGhpbmcgaXMgZmxpcHBlZCBmb3IgdGhlIFwibHRyXCIgZnVuY3Rpb24uXG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCByYW5nZS5zZXQubGVuZ3RoOyArK2kpIHtcbiAgICB2YXIgY29tcGFyYXRvcnMgPSByYW5nZS5zZXRbaV07XG5cbiAgICB2YXIgaGlnaCA9IG51bGw7XG4gICAgdmFyIGxvdyA9IG51bGw7XG5cbiAgICBjb21wYXJhdG9ycy5mb3JFYWNoKGZ1bmN0aW9uKGNvbXBhcmF0b3IpIHtcbiAgICAgIGlmIChjb21wYXJhdG9yLnNlbXZlciA9PT0gQU5ZKSB7XG4gICAgICAgIGNvbXBhcmF0b3IgPSBuZXcgQ29tcGFyYXRvcignPj0wLjAuMCcpXG4gICAgICB9XG4gICAgICBoaWdoID0gaGlnaCB8fCBjb21wYXJhdG9yO1xuICAgICAgbG93ID0gbG93IHx8IGNvbXBhcmF0b3I7XG4gICAgICBpZiAoZ3Rmbihjb21wYXJhdG9yLnNlbXZlciwgaGlnaC5zZW12ZXIsIGxvb3NlKSkge1xuICAgICAgICBoaWdoID0gY29tcGFyYXRvcjtcbiAgICAgIH0gZWxzZSBpZiAobHRmbihjb21wYXJhdG9yLnNlbXZlciwgbG93LnNlbXZlciwgbG9vc2UpKSB7XG4gICAgICAgIGxvdyA9IGNvbXBhcmF0b3I7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICAvLyBJZiB0aGUgZWRnZSB2ZXJzaW9uIGNvbXBhcmF0b3IgaGFzIGEgb3BlcmF0b3IgdGhlbiBvdXIgdmVyc2lvblxuICAgIC8vIGlzbid0IG91dHNpZGUgaXRcbiAgICBpZiAoaGlnaC5vcGVyYXRvciA9PT0gY29tcCB8fCBoaWdoLm9wZXJhdG9yID09PSBlY29tcCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIC8vIElmIHRoZSBsb3dlc3QgdmVyc2lvbiBjb21wYXJhdG9yIGhhcyBhbiBvcGVyYXRvciBhbmQgb3VyIHZlcnNpb25cbiAgICAvLyBpcyBsZXNzIHRoYW4gaXQgdGhlbiBpdCBpc24ndCBoaWdoZXIgdGhhbiB0aGUgcmFuZ2VcbiAgICBpZiAoKCFsb3cub3BlcmF0b3IgfHwgbG93Lm9wZXJhdG9yID09PSBjb21wKSAmJlxuICAgICAgICBsdGVmbih2ZXJzaW9uLCBsb3cuc2VtdmVyKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0gZWxzZSBpZiAobG93Lm9wZXJhdG9yID09PSBlY29tcCAmJiBsdGZuKHZlcnNpb24sIGxvdy5zZW12ZXIpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG4gIHJldHVybiB0cnVlO1xufVxuXG5leHBvcnRzLnByZXJlbGVhc2UgPSBwcmVyZWxlYXNlO1xuZnVuY3Rpb24gcHJlcmVsZWFzZSh2ZXJzaW9uLCBsb29zZSkge1xuICB2YXIgcGFyc2VkID0gcGFyc2UodmVyc2lvbiwgbG9vc2UpO1xuICByZXR1cm4gKHBhcnNlZCAmJiBwYXJzZWQucHJlcmVsZWFzZS5sZW5ndGgpID8gcGFyc2VkLnByZXJlbGVhc2UgOiBudWxsO1xufVxuXG5leHBvcnRzLmludGVyc2VjdHMgPSBpbnRlcnNlY3RzO1xuZnVuY3Rpb24gaW50ZXJzZWN0cyhyMSwgcjIsIGxvb3NlKSB7XG4gIHIxID0gbmV3IFJhbmdlKHIxLCBsb29zZSlcbiAgcjIgPSBuZXcgUmFuZ2UocjIsIGxvb3NlKVxuICByZXR1cm4gcjEuaW50ZXJzZWN0cyhyMilcbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9zZW12ZXIvc2VtdmVyLmpzIiwiLyogLSotIE1vZGU6IGpzOyBqcy1pbmRlbnQtbGV2ZWw6IDI7IC0qLSAqL1xuLypcbiAqIENvcHlyaWdodCAyMDExIE1vemlsbGEgRm91bmRhdGlvbiBhbmQgY29udHJpYnV0b3JzXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTmV3IEJTRCBsaWNlbnNlLiBTZWUgTElDRU5TRSBvcjpcbiAqIGh0dHA6Ly9vcGVuc291cmNlLm9yZy9saWNlbnNlcy9CU0QtMy1DbGF1c2VcbiAqL1xuXG52YXIgYmFzZTY0VkxRID0gcmVxdWlyZSgnLi9iYXNlNjQtdmxxJyk7XG52YXIgdXRpbCA9IHJlcXVpcmUoJy4vdXRpbCcpO1xudmFyIEFycmF5U2V0ID0gcmVxdWlyZSgnLi9hcnJheS1zZXQnKS5BcnJheVNldDtcbnZhciBNYXBwaW5nTGlzdCA9IHJlcXVpcmUoJy4vbWFwcGluZy1saXN0JykuTWFwcGluZ0xpc3Q7XG5cbi8qKlxuICogQW4gaW5zdGFuY2Ugb2YgdGhlIFNvdXJjZU1hcEdlbmVyYXRvciByZXByZXNlbnRzIGEgc291cmNlIG1hcCB3aGljaCBpc1xuICogYmVpbmcgYnVpbHQgaW5jcmVtZW50YWxseS4gWW91IG1heSBwYXNzIGFuIG9iamVjdCB3aXRoIHRoZSBmb2xsb3dpbmdcbiAqIHByb3BlcnRpZXM6XG4gKlxuICogICAtIGZpbGU6IFRoZSBmaWxlbmFtZSBvZiB0aGUgZ2VuZXJhdGVkIHNvdXJjZS5cbiAqICAgLSBzb3VyY2VSb290OiBBIHJvb3QgZm9yIGFsbCByZWxhdGl2ZSBVUkxzIGluIHRoaXMgc291cmNlIG1hcC5cbiAqL1xuZnVuY3Rpb24gU291cmNlTWFwR2VuZXJhdG9yKGFBcmdzKSB7XG4gIGlmICghYUFyZ3MpIHtcbiAgICBhQXJncyA9IHt9O1xuICB9XG4gIHRoaXMuX2ZpbGUgPSB1dGlsLmdldEFyZyhhQXJncywgJ2ZpbGUnLCBudWxsKTtcbiAgdGhpcy5fc291cmNlUm9vdCA9IHV0aWwuZ2V0QXJnKGFBcmdzLCAnc291cmNlUm9vdCcsIG51bGwpO1xuICB0aGlzLl9za2lwVmFsaWRhdGlvbiA9IHV0aWwuZ2V0QXJnKGFBcmdzLCAnc2tpcFZhbGlkYXRpb24nLCBmYWxzZSk7XG4gIHRoaXMuX3NvdXJjZXMgPSBuZXcgQXJyYXlTZXQoKTtcbiAgdGhpcy5fbmFtZXMgPSBuZXcgQXJyYXlTZXQoKTtcbiAgdGhpcy5fbWFwcGluZ3MgPSBuZXcgTWFwcGluZ0xpc3QoKTtcbiAgdGhpcy5fc291cmNlc0NvbnRlbnRzID0gbnVsbDtcbn1cblxuU291cmNlTWFwR2VuZXJhdG9yLnByb3RvdHlwZS5fdmVyc2lvbiA9IDM7XG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyBTb3VyY2VNYXBHZW5lcmF0b3IgYmFzZWQgb24gYSBTb3VyY2VNYXBDb25zdW1lclxuICpcbiAqIEBwYXJhbSBhU291cmNlTWFwQ29uc3VtZXIgVGhlIFNvdXJjZU1hcC5cbiAqL1xuU291cmNlTWFwR2VuZXJhdG9yLmZyb21Tb3VyY2VNYXAgPVxuICBmdW5jdGlvbiBTb3VyY2VNYXBHZW5lcmF0b3JfZnJvbVNvdXJjZU1hcChhU291cmNlTWFwQ29uc3VtZXIpIHtcbiAgICB2YXIgc291cmNlUm9vdCA9IGFTb3VyY2VNYXBDb25zdW1lci5zb3VyY2VSb290O1xuICAgIHZhciBnZW5lcmF0b3IgPSBuZXcgU291cmNlTWFwR2VuZXJhdG9yKHtcbiAgICAgIGZpbGU6IGFTb3VyY2VNYXBDb25zdW1lci5maWxlLFxuICAgICAgc291cmNlUm9vdDogc291cmNlUm9vdFxuICAgIH0pO1xuICAgIGFTb3VyY2VNYXBDb25zdW1lci5lYWNoTWFwcGluZyhmdW5jdGlvbiAobWFwcGluZykge1xuICAgICAgdmFyIG5ld01hcHBpbmcgPSB7XG4gICAgICAgIGdlbmVyYXRlZDoge1xuICAgICAgICAgIGxpbmU6IG1hcHBpbmcuZ2VuZXJhdGVkTGluZSxcbiAgICAgICAgICBjb2x1bW46IG1hcHBpbmcuZ2VuZXJhdGVkQ29sdW1uXG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIGlmIChtYXBwaW5nLnNvdXJjZSAhPSBudWxsKSB7XG4gICAgICAgIG5ld01hcHBpbmcuc291cmNlID0gbWFwcGluZy5zb3VyY2U7XG4gICAgICAgIGlmIChzb3VyY2VSb290ICE9IG51bGwpIHtcbiAgICAgICAgICBuZXdNYXBwaW5nLnNvdXJjZSA9IHV0aWwucmVsYXRpdmUoc291cmNlUm9vdCwgbmV3TWFwcGluZy5zb3VyY2UpO1xuICAgICAgICB9XG5cbiAgICAgICAgbmV3TWFwcGluZy5vcmlnaW5hbCA9IHtcbiAgICAgICAgICBsaW5lOiBtYXBwaW5nLm9yaWdpbmFsTGluZSxcbiAgICAgICAgICBjb2x1bW46IG1hcHBpbmcub3JpZ2luYWxDb2x1bW5cbiAgICAgICAgfTtcblxuICAgICAgICBpZiAobWFwcGluZy5uYW1lICE9IG51bGwpIHtcbiAgICAgICAgICBuZXdNYXBwaW5nLm5hbWUgPSBtYXBwaW5nLm5hbWU7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgZ2VuZXJhdG9yLmFkZE1hcHBpbmcobmV3TWFwcGluZyk7XG4gICAgfSk7XG4gICAgYVNvdXJjZU1hcENvbnN1bWVyLnNvdXJjZXMuZm9yRWFjaChmdW5jdGlvbiAoc291cmNlRmlsZSkge1xuICAgICAgdmFyIHNvdXJjZVJlbGF0aXZlID0gc291cmNlRmlsZTtcbiAgICAgIGlmIChzb3VyY2VSb290ICE9PSBudWxsKSB7XG4gICAgICAgIHNvdXJjZVJlbGF0aXZlID0gdXRpbC5yZWxhdGl2ZShzb3VyY2VSb290LCBzb3VyY2VGaWxlKTtcbiAgICAgIH1cblxuICAgICAgaWYgKCFnZW5lcmF0b3IuX3NvdXJjZXMuaGFzKHNvdXJjZVJlbGF0aXZlKSkge1xuICAgICAgICBnZW5lcmF0b3IuX3NvdXJjZXMuYWRkKHNvdXJjZVJlbGF0aXZlKTtcbiAgICAgIH1cblxuICAgICAgdmFyIGNvbnRlbnQgPSBhU291cmNlTWFwQ29uc3VtZXIuc291cmNlQ29udGVudEZvcihzb3VyY2VGaWxlKTtcbiAgICAgIGlmIChjb250ZW50ICE9IG51bGwpIHtcbiAgICAgICAgZ2VuZXJhdG9yLnNldFNvdXJjZUNvbnRlbnQoc291cmNlRmlsZSwgY29udGVudCk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIGdlbmVyYXRvcjtcbiAgfTtcblxuLyoqXG4gKiBBZGQgYSBzaW5nbGUgbWFwcGluZyBmcm9tIG9yaWdpbmFsIHNvdXJjZSBsaW5lIGFuZCBjb2x1bW4gdG8gdGhlIGdlbmVyYXRlZFxuICogc291cmNlJ3MgbGluZSBhbmQgY29sdW1uIGZvciB0aGlzIHNvdXJjZSBtYXAgYmVpbmcgY3JlYXRlZC4gVGhlIG1hcHBpbmdcbiAqIG9iamVjdCBzaG91bGQgaGF2ZSB0aGUgZm9sbG93aW5nIHByb3BlcnRpZXM6XG4gKlxuICogICAtIGdlbmVyYXRlZDogQW4gb2JqZWN0IHdpdGggdGhlIGdlbmVyYXRlZCBsaW5lIGFuZCBjb2x1bW4gcG9zaXRpb25zLlxuICogICAtIG9yaWdpbmFsOiBBbiBvYmplY3Qgd2l0aCB0aGUgb3JpZ2luYWwgbGluZSBhbmQgY29sdW1uIHBvc2l0aW9ucy5cbiAqICAgLSBzb3VyY2U6IFRoZSBvcmlnaW5hbCBzb3VyY2UgZmlsZSAocmVsYXRpdmUgdG8gdGhlIHNvdXJjZVJvb3QpLlxuICogICAtIG5hbWU6IEFuIG9wdGlvbmFsIG9yaWdpbmFsIHRva2VuIG5hbWUgZm9yIHRoaXMgbWFwcGluZy5cbiAqL1xuU291cmNlTWFwR2VuZXJhdG9yLnByb3RvdHlwZS5hZGRNYXBwaW5nID1cbiAgZnVuY3Rpb24gU291cmNlTWFwR2VuZXJhdG9yX2FkZE1hcHBpbmcoYUFyZ3MpIHtcbiAgICB2YXIgZ2VuZXJhdGVkID0gdXRpbC5nZXRBcmcoYUFyZ3MsICdnZW5lcmF0ZWQnKTtcbiAgICB2YXIgb3JpZ2luYWwgPSB1dGlsLmdldEFyZyhhQXJncywgJ29yaWdpbmFsJywgbnVsbCk7XG4gICAgdmFyIHNvdXJjZSA9IHV0aWwuZ2V0QXJnKGFBcmdzLCAnc291cmNlJywgbnVsbCk7XG4gICAgdmFyIG5hbWUgPSB1dGlsLmdldEFyZyhhQXJncywgJ25hbWUnLCBudWxsKTtcblxuICAgIGlmICghdGhpcy5fc2tpcFZhbGlkYXRpb24pIHtcbiAgICAgIHRoaXMuX3ZhbGlkYXRlTWFwcGluZyhnZW5lcmF0ZWQsIG9yaWdpbmFsLCBzb3VyY2UsIG5hbWUpO1xuICAgIH1cblxuICAgIGlmIChzb3VyY2UgIT0gbnVsbCkge1xuICAgICAgc291cmNlID0gU3RyaW5nKHNvdXJjZSk7XG4gICAgICBpZiAoIXRoaXMuX3NvdXJjZXMuaGFzKHNvdXJjZSkpIHtcbiAgICAgICAgdGhpcy5fc291cmNlcy5hZGQoc291cmNlKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAobmFtZSAhPSBudWxsKSB7XG4gICAgICBuYW1lID0gU3RyaW5nKG5hbWUpO1xuICAgICAgaWYgKCF0aGlzLl9uYW1lcy5oYXMobmFtZSkpIHtcbiAgICAgICAgdGhpcy5fbmFtZXMuYWRkKG5hbWUpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMuX21hcHBpbmdzLmFkZCh7XG4gICAgICBnZW5lcmF0ZWRMaW5lOiBnZW5lcmF0ZWQubGluZSxcbiAgICAgIGdlbmVyYXRlZENvbHVtbjogZ2VuZXJhdGVkLmNvbHVtbixcbiAgICAgIG9yaWdpbmFsTGluZTogb3JpZ2luYWwgIT0gbnVsbCAmJiBvcmlnaW5hbC5saW5lLFxuICAgICAgb3JpZ2luYWxDb2x1bW46IG9yaWdpbmFsICE9IG51bGwgJiYgb3JpZ2luYWwuY29sdW1uLFxuICAgICAgc291cmNlOiBzb3VyY2UsXG4gICAgICBuYW1lOiBuYW1lXG4gICAgfSk7XG4gIH07XG5cbi8qKlxuICogU2V0IHRoZSBzb3VyY2UgY29udGVudCBmb3IgYSBzb3VyY2UgZmlsZS5cbiAqL1xuU291cmNlTWFwR2VuZXJhdG9yLnByb3RvdHlwZS5zZXRTb3VyY2VDb250ZW50ID1cbiAgZnVuY3Rpb24gU291cmNlTWFwR2VuZXJhdG9yX3NldFNvdXJjZUNvbnRlbnQoYVNvdXJjZUZpbGUsIGFTb3VyY2VDb250ZW50KSB7XG4gICAgdmFyIHNvdXJjZSA9IGFTb3VyY2VGaWxlO1xuICAgIGlmICh0aGlzLl9zb3VyY2VSb290ICE9IG51bGwpIHtcbiAgICAgIHNvdXJjZSA9IHV0aWwucmVsYXRpdmUodGhpcy5fc291cmNlUm9vdCwgc291cmNlKTtcbiAgICB9XG5cbiAgICBpZiAoYVNvdXJjZUNvbnRlbnQgIT0gbnVsbCkge1xuICAgICAgLy8gQWRkIHRoZSBzb3VyY2UgY29udGVudCB0byB0aGUgX3NvdXJjZXNDb250ZW50cyBtYXAuXG4gICAgICAvLyBDcmVhdGUgYSBuZXcgX3NvdXJjZXNDb250ZW50cyBtYXAgaWYgdGhlIHByb3BlcnR5IGlzIG51bGwuXG4gICAgICBpZiAoIXRoaXMuX3NvdXJjZXNDb250ZW50cykge1xuICAgICAgICB0aGlzLl9zb3VyY2VzQ29udGVudHMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgfVxuICAgICAgdGhpcy5fc291cmNlc0NvbnRlbnRzW3V0aWwudG9TZXRTdHJpbmcoc291cmNlKV0gPSBhU291cmNlQ29udGVudDtcbiAgICB9IGVsc2UgaWYgKHRoaXMuX3NvdXJjZXNDb250ZW50cykge1xuICAgICAgLy8gUmVtb3ZlIHRoZSBzb3VyY2UgZmlsZSBmcm9tIHRoZSBfc291cmNlc0NvbnRlbnRzIG1hcC5cbiAgICAgIC8vIElmIHRoZSBfc291cmNlc0NvbnRlbnRzIG1hcCBpcyBlbXB0eSwgc2V0IHRoZSBwcm9wZXJ0eSB0byBudWxsLlxuICAgICAgZGVsZXRlIHRoaXMuX3NvdXJjZXNDb250ZW50c1t1dGlsLnRvU2V0U3RyaW5nKHNvdXJjZSldO1xuICAgICAgaWYgKE9iamVjdC5rZXlzKHRoaXMuX3NvdXJjZXNDb250ZW50cykubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHRoaXMuX3NvdXJjZXNDb250ZW50cyA9IG51bGw7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4vKipcbiAqIEFwcGxpZXMgdGhlIG1hcHBpbmdzIG9mIGEgc3ViLXNvdXJjZS1tYXAgZm9yIGEgc3BlY2lmaWMgc291cmNlIGZpbGUgdG8gdGhlXG4gKiBzb3VyY2UgbWFwIGJlaW5nIGdlbmVyYXRlZC4gRWFjaCBtYXBwaW5nIHRvIHRoZSBzdXBwbGllZCBzb3VyY2UgZmlsZSBpc1xuICogcmV3cml0dGVuIHVzaW5nIHRoZSBzdXBwbGllZCBzb3VyY2UgbWFwLiBOb3RlOiBUaGUgcmVzb2x1dGlvbiBmb3IgdGhlXG4gKiByZXN1bHRpbmcgbWFwcGluZ3MgaXMgdGhlIG1pbmltaXVtIG9mIHRoaXMgbWFwIGFuZCB0aGUgc3VwcGxpZWQgbWFwLlxuICpcbiAqIEBwYXJhbSBhU291cmNlTWFwQ29uc3VtZXIgVGhlIHNvdXJjZSBtYXAgdG8gYmUgYXBwbGllZC5cbiAqIEBwYXJhbSBhU291cmNlRmlsZSBPcHRpb25hbC4gVGhlIGZpbGVuYW1lIG9mIHRoZSBzb3VyY2UgZmlsZS5cbiAqICAgICAgICBJZiBvbWl0dGVkLCBTb3VyY2VNYXBDb25zdW1lcidzIGZpbGUgcHJvcGVydHkgd2lsbCBiZSB1c2VkLlxuICogQHBhcmFtIGFTb3VyY2VNYXBQYXRoIE9wdGlvbmFsLiBUaGUgZGlybmFtZSBvZiB0aGUgcGF0aCB0byB0aGUgc291cmNlIG1hcFxuICogICAgICAgIHRvIGJlIGFwcGxpZWQuIElmIHJlbGF0aXZlLCBpdCBpcyByZWxhdGl2ZSB0byB0aGUgU291cmNlTWFwQ29uc3VtZXIuXG4gKiAgICAgICAgVGhpcyBwYXJhbWV0ZXIgaXMgbmVlZGVkIHdoZW4gdGhlIHR3byBzb3VyY2UgbWFwcyBhcmVuJ3QgaW4gdGhlIHNhbWVcbiAqICAgICAgICBkaXJlY3RvcnksIGFuZCB0aGUgc291cmNlIG1hcCB0byBiZSBhcHBsaWVkIGNvbnRhaW5zIHJlbGF0aXZlIHNvdXJjZVxuICogICAgICAgIHBhdGhzLiBJZiBzbywgdGhvc2UgcmVsYXRpdmUgc291cmNlIHBhdGhzIG5lZWQgdG8gYmUgcmV3cml0dGVuXG4gKiAgICAgICAgcmVsYXRpdmUgdG8gdGhlIFNvdXJjZU1hcEdlbmVyYXRvci5cbiAqL1xuU291cmNlTWFwR2VuZXJhdG9yLnByb3RvdHlwZS5hcHBseVNvdXJjZU1hcCA9XG4gIGZ1bmN0aW9uIFNvdXJjZU1hcEdlbmVyYXRvcl9hcHBseVNvdXJjZU1hcChhU291cmNlTWFwQ29uc3VtZXIsIGFTb3VyY2VGaWxlLCBhU291cmNlTWFwUGF0aCkge1xuICAgIHZhciBzb3VyY2VGaWxlID0gYVNvdXJjZUZpbGU7XG4gICAgLy8gSWYgYVNvdXJjZUZpbGUgaXMgb21pdHRlZCwgd2Ugd2lsbCB1c2UgdGhlIGZpbGUgcHJvcGVydHkgb2YgdGhlIFNvdXJjZU1hcFxuICAgIGlmIChhU291cmNlRmlsZSA9PSBudWxsKSB7XG4gICAgICBpZiAoYVNvdXJjZU1hcENvbnN1bWVyLmZpbGUgPT0gbnVsbCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgJ1NvdXJjZU1hcEdlbmVyYXRvci5wcm90b3R5cGUuYXBwbHlTb3VyY2VNYXAgcmVxdWlyZXMgZWl0aGVyIGFuIGV4cGxpY2l0IHNvdXJjZSBmaWxlLCAnICtcbiAgICAgICAgICAnb3IgdGhlIHNvdXJjZSBtYXBcXCdzIFwiZmlsZVwiIHByb3BlcnR5LiBCb3RoIHdlcmUgb21pdHRlZC4nXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICBzb3VyY2VGaWxlID0gYVNvdXJjZU1hcENvbnN1bWVyLmZpbGU7XG4gICAgfVxuICAgIHZhciBzb3VyY2VSb290ID0gdGhpcy5fc291cmNlUm9vdDtcbiAgICAvLyBNYWtlIFwic291cmNlRmlsZVwiIHJlbGF0aXZlIGlmIGFuIGFic29sdXRlIFVybCBpcyBwYXNzZWQuXG4gICAgaWYgKHNvdXJjZVJvb3QgIT0gbnVsbCkge1xuICAgICAgc291cmNlRmlsZSA9IHV0aWwucmVsYXRpdmUoc291cmNlUm9vdCwgc291cmNlRmlsZSk7XG4gICAgfVxuICAgIC8vIEFwcGx5aW5nIHRoZSBTb3VyY2VNYXAgY2FuIGFkZCBhbmQgcmVtb3ZlIGl0ZW1zIGZyb20gdGhlIHNvdXJjZXMgYW5kXG4gICAgLy8gdGhlIG5hbWVzIGFycmF5LlxuICAgIHZhciBuZXdTb3VyY2VzID0gbmV3IEFycmF5U2V0KCk7XG4gICAgdmFyIG5ld05hbWVzID0gbmV3IEFycmF5U2V0KCk7XG5cbiAgICAvLyBGaW5kIG1hcHBpbmdzIGZvciB0aGUgXCJzb3VyY2VGaWxlXCJcbiAgICB0aGlzLl9tYXBwaW5ncy51bnNvcnRlZEZvckVhY2goZnVuY3Rpb24gKG1hcHBpbmcpIHtcbiAgICAgIGlmIChtYXBwaW5nLnNvdXJjZSA9PT0gc291cmNlRmlsZSAmJiBtYXBwaW5nLm9yaWdpbmFsTGluZSAhPSBudWxsKSB7XG4gICAgICAgIC8vIENoZWNrIGlmIGl0IGNhbiBiZSBtYXBwZWQgYnkgdGhlIHNvdXJjZSBtYXAsIHRoZW4gdXBkYXRlIHRoZSBtYXBwaW5nLlxuICAgICAgICB2YXIgb3JpZ2luYWwgPSBhU291cmNlTWFwQ29uc3VtZXIub3JpZ2luYWxQb3NpdGlvbkZvcih7XG4gICAgICAgICAgbGluZTogbWFwcGluZy5vcmlnaW5hbExpbmUsXG4gICAgICAgICAgY29sdW1uOiBtYXBwaW5nLm9yaWdpbmFsQ29sdW1uXG4gICAgICAgIH0pO1xuICAgICAgICBpZiAob3JpZ2luYWwuc291cmNlICE9IG51bGwpIHtcbiAgICAgICAgICAvLyBDb3B5IG1hcHBpbmdcbiAgICAgICAgICBtYXBwaW5nLnNvdXJjZSA9IG9yaWdpbmFsLnNvdXJjZTtcbiAgICAgICAgICBpZiAoYVNvdXJjZU1hcFBhdGggIT0gbnVsbCkge1xuICAgICAgICAgICAgbWFwcGluZy5zb3VyY2UgPSB1dGlsLmpvaW4oYVNvdXJjZU1hcFBhdGgsIG1hcHBpbmcuc291cmNlKVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoc291cmNlUm9vdCAhPSBudWxsKSB7XG4gICAgICAgICAgICBtYXBwaW5nLnNvdXJjZSA9IHV0aWwucmVsYXRpdmUoc291cmNlUm9vdCwgbWFwcGluZy5zb3VyY2UpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBtYXBwaW5nLm9yaWdpbmFsTGluZSA9IG9yaWdpbmFsLmxpbmU7XG4gICAgICAgICAgbWFwcGluZy5vcmlnaW5hbENvbHVtbiA9IG9yaWdpbmFsLmNvbHVtbjtcbiAgICAgICAgICBpZiAob3JpZ2luYWwubmFtZSAhPSBudWxsKSB7XG4gICAgICAgICAgICBtYXBwaW5nLm5hbWUgPSBvcmlnaW5hbC5uYW1lO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB2YXIgc291cmNlID0gbWFwcGluZy5zb3VyY2U7XG4gICAgICBpZiAoc291cmNlICE9IG51bGwgJiYgIW5ld1NvdXJjZXMuaGFzKHNvdXJjZSkpIHtcbiAgICAgICAgbmV3U291cmNlcy5hZGQoc291cmNlKTtcbiAgICAgIH1cblxuICAgICAgdmFyIG5hbWUgPSBtYXBwaW5nLm5hbWU7XG4gICAgICBpZiAobmFtZSAhPSBudWxsICYmICFuZXdOYW1lcy5oYXMobmFtZSkpIHtcbiAgICAgICAgbmV3TmFtZXMuYWRkKG5hbWUpO1xuICAgICAgfVxuXG4gICAgfSwgdGhpcyk7XG4gICAgdGhpcy5fc291cmNlcyA9IG5ld1NvdXJjZXM7XG4gICAgdGhpcy5fbmFtZXMgPSBuZXdOYW1lcztcblxuICAgIC8vIENvcHkgc291cmNlc0NvbnRlbnRzIG9mIGFwcGxpZWQgbWFwLlxuICAgIGFTb3VyY2VNYXBDb25zdW1lci5zb3VyY2VzLmZvckVhY2goZnVuY3Rpb24gKHNvdXJjZUZpbGUpIHtcbiAgICAgIHZhciBjb250ZW50ID0gYVNvdXJjZU1hcENvbnN1bWVyLnNvdXJjZUNvbnRlbnRGb3Ioc291cmNlRmlsZSk7XG4gICAgICBpZiAoY29udGVudCAhPSBudWxsKSB7XG4gICAgICAgIGlmIChhU291cmNlTWFwUGF0aCAhPSBudWxsKSB7XG4gICAgICAgICAgc291cmNlRmlsZSA9IHV0aWwuam9pbihhU291cmNlTWFwUGF0aCwgc291cmNlRmlsZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNvdXJjZVJvb3QgIT0gbnVsbCkge1xuICAgICAgICAgIHNvdXJjZUZpbGUgPSB1dGlsLnJlbGF0aXZlKHNvdXJjZVJvb3QsIHNvdXJjZUZpbGUpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc2V0U291cmNlQ29udGVudChzb3VyY2VGaWxlLCBjb250ZW50KTtcbiAgICAgIH1cbiAgICB9LCB0aGlzKTtcbiAgfTtcblxuLyoqXG4gKiBBIG1hcHBpbmcgY2FuIGhhdmUgb25lIG9mIHRoZSB0aHJlZSBsZXZlbHMgb2YgZGF0YTpcbiAqXG4gKiAgIDEuIEp1c3QgdGhlIGdlbmVyYXRlZCBwb3NpdGlvbi5cbiAqICAgMi4gVGhlIEdlbmVyYXRlZCBwb3NpdGlvbiwgb3JpZ2luYWwgcG9zaXRpb24sIGFuZCBvcmlnaW5hbCBzb3VyY2UuXG4gKiAgIDMuIEdlbmVyYXRlZCBhbmQgb3JpZ2luYWwgcG9zaXRpb24sIG9yaWdpbmFsIHNvdXJjZSwgYXMgd2VsbCBhcyBhIG5hbWVcbiAqICAgICAgdG9rZW4uXG4gKlxuICogVG8gbWFpbnRhaW4gY29uc2lzdGVuY3ksIHdlIHZhbGlkYXRlIHRoYXQgYW55IG5ldyBtYXBwaW5nIGJlaW5nIGFkZGVkIGZhbGxzXG4gKiBpbiB0byBvbmUgb2YgdGhlc2UgY2F0ZWdvcmllcy5cbiAqL1xuU291cmNlTWFwR2VuZXJhdG9yLnByb3RvdHlwZS5fdmFsaWRhdGVNYXBwaW5nID1cbiAgZnVuY3Rpb24gU291cmNlTWFwR2VuZXJhdG9yX3ZhbGlkYXRlTWFwcGluZyhhR2VuZXJhdGVkLCBhT3JpZ2luYWwsIGFTb3VyY2UsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYU5hbWUpIHtcbiAgICAvLyBXaGVuIGFPcmlnaW5hbCBpcyB0cnV0aHkgYnV0IGhhcyBlbXB0eSB2YWx1ZXMgZm9yIC5saW5lIGFuZCAuY29sdW1uLFxuICAgIC8vIGl0IGlzIG1vc3QgbGlrZWx5IGEgcHJvZ3JhbW1lciBlcnJvci4gSW4gdGhpcyBjYXNlIHdlIHRocm93IGEgdmVyeVxuICAgIC8vIHNwZWNpZmljIGVycm9yIG1lc3NhZ2UgdG8gdHJ5IHRvIGd1aWRlIHRoZW0gdGhlIHJpZ2h0IHdheS5cbiAgICAvLyBGb3IgZXhhbXBsZTogaHR0cHM6Ly9naXRodWIuY29tL1BvbHltZXIvcG9seW1lci1idW5kbGVyL3B1bGwvNTE5XG4gICAgaWYgKGFPcmlnaW5hbCAmJiB0eXBlb2YgYU9yaWdpbmFsLmxpbmUgIT09ICdudW1iZXInICYmIHR5cGVvZiBhT3JpZ2luYWwuY29sdW1uICE9PSAnbnVtYmVyJykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgICAnb3JpZ2luYWwubGluZSBhbmQgb3JpZ2luYWwuY29sdW1uIGFyZSBub3QgbnVtYmVycyAtLSB5b3UgcHJvYmFibHkgbWVhbnQgdG8gb21pdCAnICtcbiAgICAgICAgICAgICd0aGUgb3JpZ2luYWwgbWFwcGluZyBlbnRpcmVseSBhbmQgb25seSBtYXAgdGhlIGdlbmVyYXRlZCBwb3NpdGlvbi4gSWYgc28sIHBhc3MgJyArXG4gICAgICAgICAgICAnbnVsbCBmb3IgdGhlIG9yaWdpbmFsIG1hcHBpbmcgaW5zdGVhZCBvZiBhbiBvYmplY3Qgd2l0aCBlbXB0eSBvciBudWxsIHZhbHVlcy4nXG4gICAgICAgICk7XG4gICAgfVxuXG4gICAgaWYgKGFHZW5lcmF0ZWQgJiYgJ2xpbmUnIGluIGFHZW5lcmF0ZWQgJiYgJ2NvbHVtbicgaW4gYUdlbmVyYXRlZFxuICAgICAgICAmJiBhR2VuZXJhdGVkLmxpbmUgPiAwICYmIGFHZW5lcmF0ZWQuY29sdW1uID49IDBcbiAgICAgICAgJiYgIWFPcmlnaW5hbCAmJiAhYVNvdXJjZSAmJiAhYU5hbWUpIHtcbiAgICAgIC8vIENhc2UgMS5cbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZWxzZSBpZiAoYUdlbmVyYXRlZCAmJiAnbGluZScgaW4gYUdlbmVyYXRlZCAmJiAnY29sdW1uJyBpbiBhR2VuZXJhdGVkXG4gICAgICAgICAgICAgJiYgYU9yaWdpbmFsICYmICdsaW5lJyBpbiBhT3JpZ2luYWwgJiYgJ2NvbHVtbicgaW4gYU9yaWdpbmFsXG4gICAgICAgICAgICAgJiYgYUdlbmVyYXRlZC5saW5lID4gMCAmJiBhR2VuZXJhdGVkLmNvbHVtbiA+PSAwXG4gICAgICAgICAgICAgJiYgYU9yaWdpbmFsLmxpbmUgPiAwICYmIGFPcmlnaW5hbC5jb2x1bW4gPj0gMFxuICAgICAgICAgICAgICYmIGFTb3VyY2UpIHtcbiAgICAgIC8vIENhc2VzIDIgYW5kIDMuXG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIG1hcHBpbmc6ICcgKyBKU09OLnN0cmluZ2lmeSh7XG4gICAgICAgIGdlbmVyYXRlZDogYUdlbmVyYXRlZCxcbiAgICAgICAgc291cmNlOiBhU291cmNlLFxuICAgICAgICBvcmlnaW5hbDogYU9yaWdpbmFsLFxuICAgICAgICBuYW1lOiBhTmFtZVxuICAgICAgfSkpO1xuICAgIH1cbiAgfTtcblxuLyoqXG4gKiBTZXJpYWxpemUgdGhlIGFjY3VtdWxhdGVkIG1hcHBpbmdzIGluIHRvIHRoZSBzdHJlYW0gb2YgYmFzZSA2NCBWTFFzXG4gKiBzcGVjaWZpZWQgYnkgdGhlIHNvdXJjZSBtYXAgZm9ybWF0LlxuICovXG5Tb3VyY2VNYXBHZW5lcmF0b3IucHJvdG90eXBlLl9zZXJpYWxpemVNYXBwaW5ncyA9XG4gIGZ1bmN0aW9uIFNvdXJjZU1hcEdlbmVyYXRvcl9zZXJpYWxpemVNYXBwaW5ncygpIHtcbiAgICB2YXIgcHJldmlvdXNHZW5lcmF0ZWRDb2x1bW4gPSAwO1xuICAgIHZhciBwcmV2aW91c0dlbmVyYXRlZExpbmUgPSAxO1xuICAgIHZhciBwcmV2aW91c09yaWdpbmFsQ29sdW1uID0gMDtcbiAgICB2YXIgcHJldmlvdXNPcmlnaW5hbExpbmUgPSAwO1xuICAgIHZhciBwcmV2aW91c05hbWUgPSAwO1xuICAgIHZhciBwcmV2aW91c1NvdXJjZSA9IDA7XG4gICAgdmFyIHJlc3VsdCA9ICcnO1xuICAgIHZhciBuZXh0O1xuICAgIHZhciBtYXBwaW5nO1xuICAgIHZhciBuYW1lSWR4O1xuICAgIHZhciBzb3VyY2VJZHg7XG5cbiAgICB2YXIgbWFwcGluZ3MgPSB0aGlzLl9tYXBwaW5ncy50b0FycmF5KCk7XG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IG1hcHBpbmdzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICBtYXBwaW5nID0gbWFwcGluZ3NbaV07XG4gICAgICBuZXh0ID0gJydcblxuICAgICAgaWYgKG1hcHBpbmcuZ2VuZXJhdGVkTGluZSAhPT0gcHJldmlvdXNHZW5lcmF0ZWRMaW5lKSB7XG4gICAgICAgIHByZXZpb3VzR2VuZXJhdGVkQ29sdW1uID0gMDtcbiAgICAgICAgd2hpbGUgKG1hcHBpbmcuZ2VuZXJhdGVkTGluZSAhPT0gcHJldmlvdXNHZW5lcmF0ZWRMaW5lKSB7XG4gICAgICAgICAgbmV4dCArPSAnOyc7XG4gICAgICAgICAgcHJldmlvdXNHZW5lcmF0ZWRMaW5lKys7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICBpZiAoaSA+IDApIHtcbiAgICAgICAgICBpZiAoIXV0aWwuY29tcGFyZUJ5R2VuZXJhdGVkUG9zaXRpb25zSW5mbGF0ZWQobWFwcGluZywgbWFwcGluZ3NbaSAtIDFdKSkge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIG5leHQgKz0gJywnO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIG5leHQgKz0gYmFzZTY0VkxRLmVuY29kZShtYXBwaW5nLmdlbmVyYXRlZENvbHVtblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLSBwcmV2aW91c0dlbmVyYXRlZENvbHVtbik7XG4gICAgICBwcmV2aW91c0dlbmVyYXRlZENvbHVtbiA9IG1hcHBpbmcuZ2VuZXJhdGVkQ29sdW1uO1xuXG4gICAgICBpZiAobWFwcGluZy5zb3VyY2UgIT0gbnVsbCkge1xuICAgICAgICBzb3VyY2VJZHggPSB0aGlzLl9zb3VyY2VzLmluZGV4T2YobWFwcGluZy5zb3VyY2UpO1xuICAgICAgICBuZXh0ICs9IGJhc2U2NFZMUS5lbmNvZGUoc291cmNlSWR4IC0gcHJldmlvdXNTb3VyY2UpO1xuICAgICAgICBwcmV2aW91c1NvdXJjZSA9IHNvdXJjZUlkeDtcblxuICAgICAgICAvLyBsaW5lcyBhcmUgc3RvcmVkIDAtYmFzZWQgaW4gU291cmNlTWFwIHNwZWMgdmVyc2lvbiAzXG4gICAgICAgIG5leHQgKz0gYmFzZTY0VkxRLmVuY29kZShtYXBwaW5nLm9yaWdpbmFsTGluZSAtIDFcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLSBwcmV2aW91c09yaWdpbmFsTGluZSk7XG4gICAgICAgIHByZXZpb3VzT3JpZ2luYWxMaW5lID0gbWFwcGluZy5vcmlnaW5hbExpbmUgLSAxO1xuXG4gICAgICAgIG5leHQgKz0gYmFzZTY0VkxRLmVuY29kZShtYXBwaW5nLm9yaWdpbmFsQ29sdW1uXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC0gcHJldmlvdXNPcmlnaW5hbENvbHVtbik7XG4gICAgICAgIHByZXZpb3VzT3JpZ2luYWxDb2x1bW4gPSBtYXBwaW5nLm9yaWdpbmFsQ29sdW1uO1xuXG4gICAgICAgIGlmIChtYXBwaW5nLm5hbWUgIT0gbnVsbCkge1xuICAgICAgICAgIG5hbWVJZHggPSB0aGlzLl9uYW1lcy5pbmRleE9mKG1hcHBpbmcubmFtZSk7XG4gICAgICAgICAgbmV4dCArPSBiYXNlNjRWTFEuZW5jb2RlKG5hbWVJZHggLSBwcmV2aW91c05hbWUpO1xuICAgICAgICAgIHByZXZpb3VzTmFtZSA9IG5hbWVJZHg7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmVzdWx0ICs9IG5leHQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcblxuU291cmNlTWFwR2VuZXJhdG9yLnByb3RvdHlwZS5fZ2VuZXJhdGVTb3VyY2VzQ29udGVudCA9XG4gIGZ1bmN0aW9uIFNvdXJjZU1hcEdlbmVyYXRvcl9nZW5lcmF0ZVNvdXJjZXNDb250ZW50KGFTb3VyY2VzLCBhU291cmNlUm9vdCkge1xuICAgIHJldHVybiBhU291cmNlcy5tYXAoZnVuY3Rpb24gKHNvdXJjZSkge1xuICAgICAgaWYgKCF0aGlzLl9zb3VyY2VzQ29udGVudHMpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgICBpZiAoYVNvdXJjZVJvb3QgIT0gbnVsbCkge1xuICAgICAgICBzb3VyY2UgPSB1dGlsLnJlbGF0aXZlKGFTb3VyY2VSb290LCBzb3VyY2UpO1xuICAgICAgfVxuICAgICAgdmFyIGtleSA9IHV0aWwudG9TZXRTdHJpbmcoc291cmNlKTtcbiAgICAgIHJldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodGhpcy5fc291cmNlc0NvbnRlbnRzLCBrZXkpXG4gICAgICAgID8gdGhpcy5fc291cmNlc0NvbnRlbnRzW2tleV1cbiAgICAgICAgOiBudWxsO1xuICAgIH0sIHRoaXMpO1xuICB9O1xuXG4vKipcbiAqIEV4dGVybmFsaXplIHRoZSBzb3VyY2UgbWFwLlxuICovXG5Tb3VyY2VNYXBHZW5lcmF0b3IucHJvdG90eXBlLnRvSlNPTiA9XG4gIGZ1bmN0aW9uIFNvdXJjZU1hcEdlbmVyYXRvcl90b0pTT04oKSB7XG4gICAgdmFyIG1hcCA9IHtcbiAgICAgIHZlcnNpb246IHRoaXMuX3ZlcnNpb24sXG4gICAgICBzb3VyY2VzOiB0aGlzLl9zb3VyY2VzLnRvQXJyYXkoKSxcbiAgICAgIG5hbWVzOiB0aGlzLl9uYW1lcy50b0FycmF5KCksXG4gICAgICBtYXBwaW5nczogdGhpcy5fc2VyaWFsaXplTWFwcGluZ3MoKVxuICAgIH07XG4gICAgaWYgKHRoaXMuX2ZpbGUgIT0gbnVsbCkge1xuICAgICAgbWFwLmZpbGUgPSB0aGlzLl9maWxlO1xuICAgIH1cbiAgICBpZiAodGhpcy5fc291cmNlUm9vdCAhPSBudWxsKSB7XG4gICAgICBtYXAuc291cmNlUm9vdCA9IHRoaXMuX3NvdXJjZVJvb3Q7XG4gICAgfVxuICAgIGlmICh0aGlzLl9zb3VyY2VzQ29udGVudHMpIHtcbiAgICAgIG1hcC5zb3VyY2VzQ29udGVudCA9IHRoaXMuX2dlbmVyYXRlU291cmNlc0NvbnRlbnQobWFwLnNvdXJjZXMsIG1hcC5zb3VyY2VSb290KTtcbiAgICB9XG5cbiAgICByZXR1cm4gbWFwO1xuICB9O1xuXG4vKipcbiAqIFJlbmRlciB0aGUgc291cmNlIG1hcCBiZWluZyBnZW5lcmF0ZWQgdG8gYSBzdHJpbmcuXG4gKi9cblNvdXJjZU1hcEdlbmVyYXRvci5wcm90b3R5cGUudG9TdHJpbmcgPVxuICBmdW5jdGlvbiBTb3VyY2VNYXBHZW5lcmF0b3JfdG9TdHJpbmcoKSB7XG4gICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHRoaXMudG9KU09OKCkpO1xuICB9O1xuXG5leHBvcnRzLlNvdXJjZU1hcEdlbmVyYXRvciA9IFNvdXJjZU1hcEdlbmVyYXRvcjtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9lbGVjdHJvbi11cGRhdGVyL25vZGVfbW9kdWxlcy9zb3VyY2UtbWFwL2xpYi9zb3VyY2UtbWFwLWdlbmVyYXRvci5qcyIsIi8qIC0qLSBNb2RlOiBqczsganMtaW5kZW50LWxldmVsOiAyOyAtKi0gKi9cbi8qXG4gKiBDb3B5cmlnaHQgMjAxMSBNb3ppbGxhIEZvdW5kYXRpb24gYW5kIGNvbnRyaWJ1dG9yc1xuICogTGljZW5zZWQgdW5kZXIgdGhlIE5ldyBCU0QgbGljZW5zZS4gU2VlIExJQ0VOU0Ugb3I6XG4gKiBodHRwOi8vb3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvQlNELTMtQ2xhdXNlXG4gKlxuICogQmFzZWQgb24gdGhlIEJhc2UgNjQgVkxRIGltcGxlbWVudGF0aW9uIGluIENsb3N1cmUgQ29tcGlsZXI6XG4gKiBodHRwczovL2NvZGUuZ29vZ2xlLmNvbS9wL2Nsb3N1cmUtY29tcGlsZXIvc291cmNlL2Jyb3dzZS90cnVuay9zcmMvY29tL2dvb2dsZS9kZWJ1Z2dpbmcvc291cmNlbWFwL0Jhc2U2NFZMUS5qYXZhXG4gKlxuICogQ29weXJpZ2h0IDIwMTEgVGhlIENsb3N1cmUgQ29tcGlsZXIgQXV0aG9ycy4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIFJlZGlzdHJpYnV0aW9uIGFuZCB1c2UgaW4gc291cmNlIGFuZCBiaW5hcnkgZm9ybXMsIHdpdGggb3Igd2l0aG91dFxuICogbW9kaWZpY2F0aW9uLCBhcmUgcGVybWl0dGVkIHByb3ZpZGVkIHRoYXQgdGhlIGZvbGxvd2luZyBjb25kaXRpb25zIGFyZVxuICogbWV0OlxuICpcbiAqICAqIFJlZGlzdHJpYnV0aW9ucyBvZiBzb3VyY2UgY29kZSBtdXN0IHJldGFpbiB0aGUgYWJvdmUgY29weXJpZ2h0XG4gKiAgICBub3RpY2UsIHRoaXMgbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nIGRpc2NsYWltZXIuXG4gKiAgKiBSZWRpc3RyaWJ1dGlvbnMgaW4gYmluYXJ5IGZvcm0gbXVzdCByZXByb2R1Y2UgdGhlIGFib3ZlXG4gKiAgICBjb3B5cmlnaHQgbm90aWNlLCB0aGlzIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZ1xuICogICAgZGlzY2xhaW1lciBpbiB0aGUgZG9jdW1lbnRhdGlvbiBhbmQvb3Igb3RoZXIgbWF0ZXJpYWxzIHByb3ZpZGVkXG4gKiAgICB3aXRoIHRoZSBkaXN0cmlidXRpb24uXG4gKiAgKiBOZWl0aGVyIHRoZSBuYW1lIG9mIEdvb2dsZSBJbmMuIG5vciB0aGUgbmFtZXMgb2YgaXRzXG4gKiAgICBjb250cmlidXRvcnMgbWF5IGJlIHVzZWQgdG8gZW5kb3JzZSBvciBwcm9tb3RlIHByb2R1Y3RzIGRlcml2ZWRcbiAqICAgIGZyb20gdGhpcyBzb2Z0d2FyZSB3aXRob3V0IHNwZWNpZmljIHByaW9yIHdyaXR0ZW4gcGVybWlzc2lvbi5cbiAqXG4gKiBUSElTIFNPRlRXQVJFIElTIFBST1ZJREVEIEJZIFRIRSBDT1BZUklHSFQgSE9MREVSUyBBTkQgQ09OVFJJQlVUT1JTXG4gKiBcIkFTIElTXCIgQU5EIEFOWSBFWFBSRVNTIE9SIElNUExJRUQgV0FSUkFOVElFUywgSU5DTFVESU5HLCBCVVQgTk9UXG4gKiBMSU1JVEVEIFRPLCBUSEUgSU1QTElFRCBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSBBTkQgRklUTkVTUyBGT1JcbiAqIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFSRSBESVNDTEFJTUVELiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQ09QWVJJR0hUXG4gKiBPV05FUiBPUiBDT05UUklCVVRPUlMgQkUgTElBQkxFIEZPUiBBTlkgRElSRUNULCBJTkRJUkVDVCwgSU5DSURFTlRBTCxcbiAqIFNQRUNJQUwsIEVYRU1QTEFSWSwgT1IgQ09OU0VRVUVOVElBTCBEQU1BR0VTIChJTkNMVURJTkcsIEJVVCBOT1RcbiAqIExJTUlURUQgVE8sIFBST0NVUkVNRU5UIE9GIFNVQlNUSVRVVEUgR09PRFMgT1IgU0VSVklDRVM7IExPU1MgT0YgVVNFLFxuICogREFUQSwgT1IgUFJPRklUUzsgT1IgQlVTSU5FU1MgSU5URVJSVVBUSU9OKSBIT1dFVkVSIENBVVNFRCBBTkQgT04gQU5ZXG4gKiBUSEVPUlkgT0YgTElBQklMSVRZLCBXSEVUSEVSIElOIENPTlRSQUNULCBTVFJJQ1QgTElBQklMSVRZLCBPUiBUT1JUXG4gKiAoSU5DTFVESU5HIE5FR0xJR0VOQ0UgT1IgT1RIRVJXSVNFKSBBUklTSU5HIElOIEFOWSBXQVkgT1VUIE9GIFRIRSBVU0VcbiAqIE9GIFRISVMgU09GVFdBUkUsIEVWRU4gSUYgQURWSVNFRCBPRiBUSEUgUE9TU0lCSUxJVFkgT0YgU1VDSCBEQU1BR0UuXG4gKi9cblxudmFyIGJhc2U2NCA9IHJlcXVpcmUoJy4vYmFzZTY0Jyk7XG5cbi8vIEEgc2luZ2xlIGJhc2UgNjQgZGlnaXQgY2FuIGNvbnRhaW4gNiBiaXRzIG9mIGRhdGEuIEZvciB0aGUgYmFzZSA2NCB2YXJpYWJsZVxuLy8gbGVuZ3RoIHF1YW50aXRpZXMgd2UgdXNlIGluIHRoZSBzb3VyY2UgbWFwIHNwZWMsIHRoZSBmaXJzdCBiaXQgaXMgdGhlIHNpZ24sXG4vLyB0aGUgbmV4dCBmb3VyIGJpdHMgYXJlIHRoZSBhY3R1YWwgdmFsdWUsIGFuZCB0aGUgNnRoIGJpdCBpcyB0aGVcbi8vIGNvbnRpbnVhdGlvbiBiaXQuIFRoZSBjb250aW51YXRpb24gYml0IHRlbGxzIHVzIHdoZXRoZXIgdGhlcmUgYXJlIG1vcmVcbi8vIGRpZ2l0cyBpbiB0aGlzIHZhbHVlIGZvbGxvd2luZyB0aGlzIGRpZ2l0LlxuLy9cbi8vICAgQ29udGludWF0aW9uXG4vLyAgIHwgICAgU2lnblxuLy8gICB8ICAgIHxcbi8vICAgViAgICBWXG4vLyAgIDEwMTAxMVxuXG52YXIgVkxRX0JBU0VfU0hJRlQgPSA1O1xuXG4vLyBiaW5hcnk6IDEwMDAwMFxudmFyIFZMUV9CQVNFID0gMSA8PCBWTFFfQkFTRV9TSElGVDtcblxuLy8gYmluYXJ5OiAwMTExMTFcbnZhciBWTFFfQkFTRV9NQVNLID0gVkxRX0JBU0UgLSAxO1xuXG4vLyBiaW5hcnk6IDEwMDAwMFxudmFyIFZMUV9DT05USU5VQVRJT05fQklUID0gVkxRX0JBU0U7XG5cbi8qKlxuICogQ29udmVydHMgZnJvbSBhIHR3by1jb21wbGVtZW50IHZhbHVlIHRvIGEgdmFsdWUgd2hlcmUgdGhlIHNpZ24gYml0IGlzXG4gKiBwbGFjZWQgaW4gdGhlIGxlYXN0IHNpZ25pZmljYW50IGJpdC4gIEZvciBleGFtcGxlLCBhcyBkZWNpbWFsczpcbiAqICAgMSBiZWNvbWVzIDIgKDEwIGJpbmFyeSksIC0xIGJlY29tZXMgMyAoMTEgYmluYXJ5KVxuICogICAyIGJlY29tZXMgNCAoMTAwIGJpbmFyeSksIC0yIGJlY29tZXMgNSAoMTAxIGJpbmFyeSlcbiAqL1xuZnVuY3Rpb24gdG9WTFFTaWduZWQoYVZhbHVlKSB7XG4gIHJldHVybiBhVmFsdWUgPCAwXG4gICAgPyAoKC1hVmFsdWUpIDw8IDEpICsgMVxuICAgIDogKGFWYWx1ZSA8PCAxKSArIDA7XG59XG5cbi8qKlxuICogQ29udmVydHMgdG8gYSB0d28tY29tcGxlbWVudCB2YWx1ZSBmcm9tIGEgdmFsdWUgd2hlcmUgdGhlIHNpZ24gYml0IGlzXG4gKiBwbGFjZWQgaW4gdGhlIGxlYXN0IHNpZ25pZmljYW50IGJpdC4gIEZvciBleGFtcGxlLCBhcyBkZWNpbWFsczpcbiAqICAgMiAoMTAgYmluYXJ5KSBiZWNvbWVzIDEsIDMgKDExIGJpbmFyeSkgYmVjb21lcyAtMVxuICogICA0ICgxMDAgYmluYXJ5KSBiZWNvbWVzIDIsIDUgKDEwMSBiaW5hcnkpIGJlY29tZXMgLTJcbiAqL1xuZnVuY3Rpb24gZnJvbVZMUVNpZ25lZChhVmFsdWUpIHtcbiAgdmFyIGlzTmVnYXRpdmUgPSAoYVZhbHVlICYgMSkgPT09IDE7XG4gIHZhciBzaGlmdGVkID0gYVZhbHVlID4+IDE7XG4gIHJldHVybiBpc05lZ2F0aXZlXG4gICAgPyAtc2hpZnRlZFxuICAgIDogc2hpZnRlZDtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBiYXNlIDY0IFZMUSBlbmNvZGVkIHZhbHVlLlxuICovXG5leHBvcnRzLmVuY29kZSA9IGZ1bmN0aW9uIGJhc2U2NFZMUV9lbmNvZGUoYVZhbHVlKSB7XG4gIHZhciBlbmNvZGVkID0gXCJcIjtcbiAgdmFyIGRpZ2l0O1xuXG4gIHZhciB2bHEgPSB0b1ZMUVNpZ25lZChhVmFsdWUpO1xuXG4gIGRvIHtcbiAgICBkaWdpdCA9IHZscSAmIFZMUV9CQVNFX01BU0s7XG4gICAgdmxxID4+Pj0gVkxRX0JBU0VfU0hJRlQ7XG4gICAgaWYgKHZscSA+IDApIHtcbiAgICAgIC8vIFRoZXJlIGFyZSBzdGlsbCBtb3JlIGRpZ2l0cyBpbiB0aGlzIHZhbHVlLCBzbyB3ZSBtdXN0IG1ha2Ugc3VyZSB0aGVcbiAgICAgIC8vIGNvbnRpbnVhdGlvbiBiaXQgaXMgbWFya2VkLlxuICAgICAgZGlnaXQgfD0gVkxRX0NPTlRJTlVBVElPTl9CSVQ7XG4gICAgfVxuICAgIGVuY29kZWQgKz0gYmFzZTY0LmVuY29kZShkaWdpdCk7XG4gIH0gd2hpbGUgKHZscSA+IDApO1xuXG4gIHJldHVybiBlbmNvZGVkO1xufTtcblxuLyoqXG4gKiBEZWNvZGVzIHRoZSBuZXh0IGJhc2UgNjQgVkxRIHZhbHVlIGZyb20gdGhlIGdpdmVuIHN0cmluZyBhbmQgcmV0dXJucyB0aGVcbiAqIHZhbHVlIGFuZCB0aGUgcmVzdCBvZiB0aGUgc3RyaW5nIHZpYSB0aGUgb3V0IHBhcmFtZXRlci5cbiAqL1xuZXhwb3J0cy5kZWNvZGUgPSBmdW5jdGlvbiBiYXNlNjRWTFFfZGVjb2RlKGFTdHIsIGFJbmRleCwgYU91dFBhcmFtKSB7XG4gIHZhciBzdHJMZW4gPSBhU3RyLmxlbmd0aDtcbiAgdmFyIHJlc3VsdCA9IDA7XG4gIHZhciBzaGlmdCA9IDA7XG4gIHZhciBjb250aW51YXRpb24sIGRpZ2l0O1xuXG4gIGRvIHtcbiAgICBpZiAoYUluZGV4ID49IHN0ckxlbikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRXhwZWN0ZWQgbW9yZSBkaWdpdHMgaW4gYmFzZSA2NCBWTFEgdmFsdWUuXCIpO1xuICAgIH1cblxuICAgIGRpZ2l0ID0gYmFzZTY0LmRlY29kZShhU3RyLmNoYXJDb2RlQXQoYUluZGV4KyspKTtcbiAgICBpZiAoZGlnaXQgPT09IC0xKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIGJhc2U2NCBkaWdpdDogXCIgKyBhU3RyLmNoYXJBdChhSW5kZXggLSAxKSk7XG4gICAgfVxuXG4gICAgY29udGludWF0aW9uID0gISEoZGlnaXQgJiBWTFFfQ09OVElOVUFUSU9OX0JJVCk7XG4gICAgZGlnaXQgJj0gVkxRX0JBU0VfTUFTSztcbiAgICByZXN1bHQgPSByZXN1bHQgKyAoZGlnaXQgPDwgc2hpZnQpO1xuICAgIHNoaWZ0ICs9IFZMUV9CQVNFX1NISUZUO1xuICB9IHdoaWxlIChjb250aW51YXRpb24pO1xuXG4gIGFPdXRQYXJhbS52YWx1ZSA9IGZyb21WTFFTaWduZWQocmVzdWx0KTtcbiAgYU91dFBhcmFtLnJlc3QgPSBhSW5kZXg7XG59O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2VsZWN0cm9uLXVwZGF0ZXIvbm9kZV9tb2R1bGVzL3NvdXJjZS1tYXAvbGliL2Jhc2U2NC12bHEuanMiLCIvKiAtKi0gTW9kZToganM7IGpzLWluZGVudC1sZXZlbDogMjsgLSotICovXG4vKlxuICogQ29weXJpZ2h0IDIwMTEgTW96aWxsYSBGb3VuZGF0aW9uIGFuZCBjb250cmlidXRvcnNcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBOZXcgQlNEIGxpY2Vuc2UuIFNlZSBMSUNFTlNFIG9yOlxuICogaHR0cDovL29wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL0JTRC0zLUNsYXVzZVxuICovXG5cbnZhciB1dGlsID0gcmVxdWlyZSgnLi91dGlsJyk7XG52YXIgaGFzID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcbnZhciBoYXNOYXRpdmVNYXAgPSB0eXBlb2YgTWFwICE9PSBcInVuZGVmaW5lZFwiO1xuXG4vKipcbiAqIEEgZGF0YSBzdHJ1Y3R1cmUgd2hpY2ggaXMgYSBjb21iaW5hdGlvbiBvZiBhbiBhcnJheSBhbmQgYSBzZXQuIEFkZGluZyBhIG5ld1xuICogbWVtYmVyIGlzIE8oMSksIHRlc3RpbmcgZm9yIG1lbWJlcnNoaXAgaXMgTygxKSwgYW5kIGZpbmRpbmcgdGhlIGluZGV4IG9mIGFuXG4gKiBlbGVtZW50IGlzIE8oMSkuIFJlbW92aW5nIGVsZW1lbnRzIGZyb20gdGhlIHNldCBpcyBub3Qgc3VwcG9ydGVkLiBPbmx5XG4gKiBzdHJpbmdzIGFyZSBzdXBwb3J0ZWQgZm9yIG1lbWJlcnNoaXAuXG4gKi9cbmZ1bmN0aW9uIEFycmF5U2V0KCkge1xuICB0aGlzLl9hcnJheSA9IFtdO1xuICB0aGlzLl9zZXQgPSBoYXNOYXRpdmVNYXAgPyBuZXcgTWFwKCkgOiBPYmplY3QuY3JlYXRlKG51bGwpO1xufVxuXG4vKipcbiAqIFN0YXRpYyBtZXRob2QgZm9yIGNyZWF0aW5nIEFycmF5U2V0IGluc3RhbmNlcyBmcm9tIGFuIGV4aXN0aW5nIGFycmF5LlxuICovXG5BcnJheVNldC5mcm9tQXJyYXkgPSBmdW5jdGlvbiBBcnJheVNldF9mcm9tQXJyYXkoYUFycmF5LCBhQWxsb3dEdXBsaWNhdGVzKSB7XG4gIHZhciBzZXQgPSBuZXcgQXJyYXlTZXQoKTtcbiAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGFBcnJheS5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgIHNldC5hZGQoYUFycmF5W2ldLCBhQWxsb3dEdXBsaWNhdGVzKTtcbiAgfVxuICByZXR1cm4gc2V0O1xufTtcblxuLyoqXG4gKiBSZXR1cm4gaG93IG1hbnkgdW5pcXVlIGl0ZW1zIGFyZSBpbiB0aGlzIEFycmF5U2V0LiBJZiBkdXBsaWNhdGVzIGhhdmUgYmVlblxuICogYWRkZWQsIHRoYW4gdGhvc2UgZG8gbm90IGNvdW50IHRvd2FyZHMgdGhlIHNpemUuXG4gKlxuICogQHJldHVybnMgTnVtYmVyXG4gKi9cbkFycmF5U2V0LnByb3RvdHlwZS5zaXplID0gZnVuY3Rpb24gQXJyYXlTZXRfc2l6ZSgpIHtcbiAgcmV0dXJuIGhhc05hdGl2ZU1hcCA/IHRoaXMuX3NldC5zaXplIDogT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXModGhpcy5fc2V0KS5sZW5ndGg7XG59O1xuXG4vKipcbiAqIEFkZCB0aGUgZ2l2ZW4gc3RyaW5nIHRvIHRoaXMgc2V0LlxuICpcbiAqIEBwYXJhbSBTdHJpbmcgYVN0clxuICovXG5BcnJheVNldC5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24gQXJyYXlTZXRfYWRkKGFTdHIsIGFBbGxvd0R1cGxpY2F0ZXMpIHtcbiAgdmFyIHNTdHIgPSBoYXNOYXRpdmVNYXAgPyBhU3RyIDogdXRpbC50b1NldFN0cmluZyhhU3RyKTtcbiAgdmFyIGlzRHVwbGljYXRlID0gaGFzTmF0aXZlTWFwID8gdGhpcy5oYXMoYVN0cikgOiBoYXMuY2FsbCh0aGlzLl9zZXQsIHNTdHIpO1xuICB2YXIgaWR4ID0gdGhpcy5fYXJyYXkubGVuZ3RoO1xuICBpZiAoIWlzRHVwbGljYXRlIHx8IGFBbGxvd0R1cGxpY2F0ZXMpIHtcbiAgICB0aGlzLl9hcnJheS5wdXNoKGFTdHIpO1xuICB9XG4gIGlmICghaXNEdXBsaWNhdGUpIHtcbiAgICBpZiAoaGFzTmF0aXZlTWFwKSB7XG4gICAgICB0aGlzLl9zZXQuc2V0KGFTdHIsIGlkeCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX3NldFtzU3RyXSA9IGlkeDtcbiAgICB9XG4gIH1cbn07XG5cbi8qKlxuICogSXMgdGhlIGdpdmVuIHN0cmluZyBhIG1lbWJlciBvZiB0aGlzIHNldD9cbiAqXG4gKiBAcGFyYW0gU3RyaW5nIGFTdHJcbiAqL1xuQXJyYXlTZXQucHJvdG90eXBlLmhhcyA9IGZ1bmN0aW9uIEFycmF5U2V0X2hhcyhhU3RyKSB7XG4gIGlmIChoYXNOYXRpdmVNYXApIHtcbiAgICByZXR1cm4gdGhpcy5fc2V0LmhhcyhhU3RyKTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgc1N0ciA9IHV0aWwudG9TZXRTdHJpbmcoYVN0cik7XG4gICAgcmV0dXJuIGhhcy5jYWxsKHRoaXMuX3NldCwgc1N0cik7XG4gIH1cbn07XG5cbi8qKlxuICogV2hhdCBpcyB0aGUgaW5kZXggb2YgdGhlIGdpdmVuIHN0cmluZyBpbiB0aGUgYXJyYXk/XG4gKlxuICogQHBhcmFtIFN0cmluZyBhU3RyXG4gKi9cbkFycmF5U2V0LnByb3RvdHlwZS5pbmRleE9mID0gZnVuY3Rpb24gQXJyYXlTZXRfaW5kZXhPZihhU3RyKSB7XG4gIGlmIChoYXNOYXRpdmVNYXApIHtcbiAgICB2YXIgaWR4ID0gdGhpcy5fc2V0LmdldChhU3RyKTtcbiAgICBpZiAoaWR4ID49IDApIHtcbiAgICAgICAgcmV0dXJuIGlkeDtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdmFyIHNTdHIgPSB1dGlsLnRvU2V0U3RyaW5nKGFTdHIpO1xuICAgIGlmIChoYXMuY2FsbCh0aGlzLl9zZXQsIHNTdHIpKSB7XG4gICAgICByZXR1cm4gdGhpcy5fc2V0W3NTdHJdO1xuICAgIH1cbiAgfVxuXG4gIHRocm93IG5ldyBFcnJvcignXCInICsgYVN0ciArICdcIiBpcyBub3QgaW4gdGhlIHNldC4nKTtcbn07XG5cbi8qKlxuICogV2hhdCBpcyB0aGUgZWxlbWVudCBhdCB0aGUgZ2l2ZW4gaW5kZXg/XG4gKlxuICogQHBhcmFtIE51bWJlciBhSWR4XG4gKi9cbkFycmF5U2V0LnByb3RvdHlwZS5hdCA9IGZ1bmN0aW9uIEFycmF5U2V0X2F0KGFJZHgpIHtcbiAgaWYgKGFJZHggPj0gMCAmJiBhSWR4IDwgdGhpcy5fYXJyYXkubGVuZ3RoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2FycmF5W2FJZHhdO1xuICB9XG4gIHRocm93IG5ldyBFcnJvcignTm8gZWxlbWVudCBpbmRleGVkIGJ5ICcgKyBhSWR4KTtcbn07XG5cbi8qKlxuICogUmV0dXJucyB0aGUgYXJyYXkgcmVwcmVzZW50YXRpb24gb2YgdGhpcyBzZXQgKHdoaWNoIGhhcyB0aGUgcHJvcGVyIGluZGljZXNcbiAqIGluZGljYXRlZCBieSBpbmRleE9mKS4gTm90ZSB0aGF0IHRoaXMgaXMgYSBjb3B5IG9mIHRoZSBpbnRlcm5hbCBhcnJheSB1c2VkXG4gKiBmb3Igc3RvcmluZyB0aGUgbWVtYmVycyBzbyB0aGF0IG5vIG9uZSBjYW4gbWVzcyB3aXRoIGludGVybmFsIHN0YXRlLlxuICovXG5BcnJheVNldC5wcm90b3R5cGUudG9BcnJheSA9IGZ1bmN0aW9uIEFycmF5U2V0X3RvQXJyYXkoKSB7XG4gIHJldHVybiB0aGlzLl9hcnJheS5zbGljZSgpO1xufTtcblxuZXhwb3J0cy5BcnJheVNldCA9IEFycmF5U2V0O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2VsZWN0cm9uLXVwZGF0ZXIvbm9kZV9tb2R1bGVzL3NvdXJjZS1tYXAvbGliL2FycmF5LXNldC5qcyIsIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLkdlbmVyaWNQcm92aWRlciA9IHVuZGVmaW5lZDtcblxudmFyIF9ibHVlYmlyZExzdDtcblxuZnVuY3Rpb24gX2xvYWRfYmx1ZWJpcmRMc3QoKSB7XG4gICAgcmV0dXJuIF9ibHVlYmlyZExzdCA9IHJlcXVpcmUoXCJibHVlYmlyZC1sc3RcIik7XG59XG5cbnZhciBfYnVpbGRlclV0aWxSdW50aW1lO1xuXG5mdW5jdGlvbiBfbG9hZF9idWlsZGVyVXRpbFJ1bnRpbWUoKSB7XG4gICAgcmV0dXJuIF9idWlsZGVyVXRpbFJ1bnRpbWUgPSByZXF1aXJlKFwiYnVpbGRlci11dGlsLXJ1bnRpbWVcIik7XG59XG5cbnZhciBfbWFpbjtcblxuZnVuY3Rpb24gX2xvYWRfbWFpbigpIHtcbiAgICByZXR1cm4gX21haW4gPSByZXF1aXJlKFwiLi9tYWluXCIpO1xufVxuXG52YXIgX1Byb3ZpZGVyO1xuXG5mdW5jdGlvbiBfbG9hZF9Qcm92aWRlcigpIHtcbiAgICByZXR1cm4gX1Byb3ZpZGVyID0gcmVxdWlyZShcIi4vUHJvdmlkZXJcIik7XG59XG5cbmNsYXNzIEdlbmVyaWNQcm92aWRlciBleHRlbmRzIChfbWFpbiB8fCBfbG9hZF9tYWluKCkpLlByb3ZpZGVyIHtcbiAgICBjb25zdHJ1Y3Rvcihjb25maWd1cmF0aW9uLCB1cGRhdGVyLCB1c2VNdWx0aXBsZVJhbmdlUmVxdWVzdCA9IHRydWUpIHtcbiAgICAgICAgc3VwZXIodXBkYXRlci5odHRwRXhlY3V0b3IsIHVzZU11bHRpcGxlUmFuZ2VSZXF1ZXN0KTtcbiAgICAgICAgdGhpcy5jb25maWd1cmF0aW9uID0gY29uZmlndXJhdGlvbjtcbiAgICAgICAgdGhpcy51cGRhdGVyID0gdXBkYXRlcjtcbiAgICAgICAgdGhpcy5iYXNlVXJsID0gKDAsIChfbWFpbiB8fCBfbG9hZF9tYWluKCkpLm5ld0Jhc2VVcmwpKHRoaXMuY29uZmlndXJhdGlvbi51cmwpO1xuICAgIH1cbiAgICBnZXQgY2hhbm5lbCgpIHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gdGhpcy51cGRhdGVyLmNoYW5uZWwgfHwgdGhpcy5jb25maWd1cmF0aW9uLmNoYW5uZWw7XG4gICAgICAgIHJldHVybiByZXN1bHQgPT0gbnVsbCA/ICgwLCAoX21haW4gfHwgX2xvYWRfbWFpbigpKS5nZXREZWZhdWx0Q2hhbm5lbE5hbWUpKCkgOiAoMCwgKF9tYWluIHx8IF9sb2FkX21haW4oKSkuZ2V0Q3VzdG9tQ2hhbm5lbE5hbWUpKHJlc3VsdCk7XG4gICAgfVxuICAgIGdldExhdGVzdFZlcnNpb24oKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICAgICAgcmV0dXJuICgwLCAoX2JsdWViaXJkTHN0IHx8IF9sb2FkX2JsdWViaXJkTHN0KCkpLmNvcm91dGluZSkoZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGxldCByZXN1bHQ7XG4gICAgICAgICAgICBjb25zdCBjaGFubmVsRmlsZSA9ICgwLCAoX21haW4gfHwgX2xvYWRfbWFpbigpKS5nZXRDaGFubmVsRmlsZW5hbWUpKF90aGlzLmNoYW5uZWwpO1xuICAgICAgICAgICAgY29uc3QgY2hhbm5lbFVybCA9ICgwLCAoX21haW4gfHwgX2xvYWRfbWFpbigpKS5uZXdVcmxGcm9tQmFzZSkoY2hhbm5lbEZpbGUsIF90aGlzLmJhc2VVcmwpO1xuICAgICAgICAgICAgZm9yIChsZXQgYXR0ZW1wdE51bWJlciA9IDA7OyBhdHRlbXB0TnVtYmVyKyspIHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSAoMCwgKF9Qcm92aWRlciB8fCBfbG9hZF9Qcm92aWRlcigpKS5wYXJzZVVwZGF0ZUluZm8pKCh5aWVsZCBfdGhpcy5odHRwUmVxdWVzdChjaGFubmVsVXJsKSksIGNoYW5uZWxGaWxlLCBjaGFubmVsVXJsKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZSBpbnN0YW5jZW9mIChfYnVpbGRlclV0aWxSdW50aW1lIHx8IF9sb2FkX2J1aWxkZXJVdGlsUnVudGltZSgpKS5IdHRwRXJyb3IgJiYgZS5zdGF0dXNDb2RlID09PSA0MDQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93ICgwLCAoX2J1aWxkZXJVdGlsUnVudGltZSB8fCBfbG9hZF9idWlsZGVyVXRpbFJ1bnRpbWUoKSkubmV3RXJyb3IpKGBDYW5ub3QgZmluZCBjaGFubmVsIFwiJHtjaGFubmVsRmlsZX1cIiB1cGRhdGUgaW5mbzogJHtlLnN0YWNrIHx8IGUubWVzc2FnZX1gLCBcIkVSUl9VUERBVEVSX0NIQU5ORUxfRklMRV9OT1RfRk9VTkRcIik7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoZS5jb2RlID09PSBcIkVDT05OUkVGVVNFRFwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoYXR0ZW1wdE51bWJlciA8IDMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB5aWVsZCBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KHJlc29sdmUsIDEwMDAgKiBhdHRlbXB0TnVtYmVyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVqZWN0KGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoKDAsIChfbWFpbiB8fCBfbG9hZF9tYWluKCkpLmlzVXNlT2xkTWFjUHJvdmlkZXIpKCkpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQucmVsZWFzZUpzb25VcmwgPSBjaGFubmVsVXJsLmhyZWY7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9KSgpO1xuICAgIH1cbiAgICByZXNvbHZlRmlsZXModXBkYXRlSW5mbykge1xuICAgICAgICByZXR1cm4gKDAsIChfUHJvdmlkZXIgfHwgX2xvYWRfUHJvdmlkZXIoKSkucmVzb2x2ZUZpbGVzKSh1cGRhdGVJbmZvLCB0aGlzLmJhc2VVcmwpO1xuICAgIH1cbn1cbmV4cG9ydHMuR2VuZXJpY1Byb3ZpZGVyID0gR2VuZXJpY1Byb3ZpZGVyOyAvLyMgc291cmNlTWFwcGluZ1VSTD1HZW5lcmljUHJvdmlkZXIuanMubWFwXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2VsZWN0cm9uLXVwZGF0ZXIvb3V0L0dlbmVyaWNQcm92aWRlci5qcyIsIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLkdpdEh1YlByb3ZpZGVyID0gZXhwb3J0cy5CYXNlR2l0SHViUHJvdmlkZXIgPSB1bmRlZmluZWQ7XG5cbnZhciBfYmx1ZWJpcmRMc3Q7XG5cbmZ1bmN0aW9uIF9sb2FkX2JsdWViaXJkTHN0KCkge1xuICAgIHJldHVybiBfYmx1ZWJpcmRMc3QgPSByZXF1aXJlKFwiYmx1ZWJpcmQtbHN0XCIpO1xufVxuXG5leHBvcnRzLmNvbXB1dGVSZWxlYXNlTm90ZXMgPSBjb21wdXRlUmVsZWFzZU5vdGVzO1xuXG52YXIgX2J1aWxkZXJVdGlsUnVudGltZTtcblxuZnVuY3Rpb24gX2xvYWRfYnVpbGRlclV0aWxSdW50aW1lKCkge1xuICAgIHJldHVybiBfYnVpbGRlclV0aWxSdW50aW1lID0gcmVxdWlyZShcImJ1aWxkZXItdXRpbC1ydW50aW1lXCIpO1xufVxuXG52YXIgX3NlbXZlcjtcblxuZnVuY3Rpb24gX2xvYWRfc2VtdmVyKCkge1xuICAgIHJldHVybiBfc2VtdmVyID0gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQocmVxdWlyZShcInNlbXZlclwiKSk7XG59XG5cbnZhciBfbWFpbjtcblxuZnVuY3Rpb24gX2xvYWRfbWFpbigpIHtcbiAgICByZXR1cm4gX21haW4gPSByZXF1aXJlKFwiLi9tYWluXCIpO1xufVxuXG52YXIgX1Byb3ZpZGVyO1xuXG5mdW5jdGlvbiBfbG9hZF9Qcm92aWRlcigpIHtcbiAgICByZXR1cm4gX1Byb3ZpZGVyID0gcmVxdWlyZShcIi4vUHJvdmlkZXJcIik7XG59XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKG9iaikgeyBpZiAob2JqICYmIG9iai5fX2VzTW9kdWxlKSB7IHJldHVybiBvYmo7IH0gZWxzZSB7IHZhciBuZXdPYmogPSB7fTsgaWYgKG9iaiAhPSBudWxsKSB7IGZvciAodmFyIGtleSBpbiBvYmopIHsgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGtleSkpIG5ld09ialtrZXldID0gb2JqW2tleV07IH0gfSBuZXdPYmouZGVmYXVsdCA9IG9iajsgcmV0dXJuIG5ld09iajsgfSB9XG5cbmNsYXNzIEJhc2VHaXRIdWJQcm92aWRlciBleHRlbmRzIChfbWFpbiB8fCBfbG9hZF9tYWluKCkpLlByb3ZpZGVyIHtcbiAgICBjb25zdHJ1Y3RvcihvcHRpb25zLCBkZWZhdWx0SG9zdCwgZXhlY3V0b3IpIHtcbiAgICAgICAgc3VwZXIoZXhlY3V0b3IsIGZhbHNlIC8qIGJlY2F1c2UgR2l0SGliIHVzZXMgUzMgKi8pO1xuICAgICAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuICAgICAgICB0aGlzLmJhc2VVcmwgPSAoMCwgKF9tYWluIHx8IF9sb2FkX21haW4oKSkubmV3QmFzZVVybCkoKDAsIChfYnVpbGRlclV0aWxSdW50aW1lIHx8IF9sb2FkX2J1aWxkZXJVdGlsUnVudGltZSgpKS5naXRodWJVcmwpKG9wdGlvbnMsIGRlZmF1bHRIb3N0KSk7XG4gICAgfVxuICAgIGNvbXB1dGVHaXRodWJCYXNlUGF0aChyZXN1bHQpIHtcbiAgICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2VsZWN0cm9uLXVzZXJsYW5kL2VsZWN0cm9uLWJ1aWxkZXIvaXNzdWVzLzE5MDMjaXNzdWVjb21tZW50LTMyMDg4MTIxMVxuICAgICAgICBjb25zdCBob3N0ID0gdGhpcy5vcHRpb25zLmhvc3Q7XG4gICAgICAgIHJldHVybiBob3N0ICE9IG51bGwgJiYgaG9zdCAhPT0gXCJnaXRodWIuY29tXCIgJiYgaG9zdCAhPT0gXCJhcGkuZ2l0aHViLmNvbVwiID8gYC9hcGkvdjMke3Jlc3VsdH1gIDogcmVzdWx0O1xuICAgIH1cbn1cbmV4cG9ydHMuQmFzZUdpdEh1YlByb3ZpZGVyID0gQmFzZUdpdEh1YlByb3ZpZGVyO1xuY2xhc3MgR2l0SHViUHJvdmlkZXIgZXh0ZW5kcyBCYXNlR2l0SHViUHJvdmlkZXIge1xuICAgIGNvbnN0cnVjdG9yKG9wdGlvbnMsIHVwZGF0ZXIsIGV4ZWN1dG9yKSB7XG4gICAgICAgIHN1cGVyKG9wdGlvbnMsIFwiZ2l0aHViLmNvbVwiLCBleGVjdXRvcik7XG4gICAgICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgICAgIHRoaXMudXBkYXRlciA9IHVwZGF0ZXI7XG4gICAgfVxuICAgIGdldExhdGVzdFZlcnNpb24oKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICAgICAgcmV0dXJuICgwLCAoX2JsdWViaXJkTHN0IHx8IF9sb2FkX2JsdWViaXJkTHN0KCkpLmNvcm91dGluZSkoZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGNvbnN0IGJhc2VQYXRoID0gX3RoaXMuYmFzZVBhdGg7XG4gICAgICAgICAgICBjb25zdCBjYW5jZWxsYXRpb25Ub2tlbiA9IG5ldyAoX2J1aWxkZXJVdGlsUnVudGltZSB8fCBfbG9hZF9idWlsZGVyVXRpbFJ1bnRpbWUoKSkuQ2FuY2VsbGF0aW9uVG9rZW4oKTtcbiAgICAgICAgICAgIGNvbnN0IGZlZWRYbWwgPSB5aWVsZCBfdGhpcy5odHRwUmVxdWVzdCgoMCwgKF9tYWluIHx8IF9sb2FkX21haW4oKSkubmV3VXJsRnJvbUJhc2UpKGAke2Jhc2VQYXRofS5hdG9tYCwgX3RoaXMuYmFzZVVybCksIHtcbiAgICAgICAgICAgICAgICBBY2NlcHQ6IFwiYXBwbGljYXRpb24veG1sLCBhcHBsaWNhdGlvbi9hdG9tK3htbCwgdGV4dC94bWwsICovKlwiXG4gICAgICAgICAgICB9LCBjYW5jZWxsYXRpb25Ub2tlbik7XG4gICAgICAgICAgICBjb25zdCBmZWVkID0gKDAsIChfYnVpbGRlclV0aWxSdW50aW1lIHx8IF9sb2FkX2J1aWxkZXJVdGlsUnVudGltZSgpKS5wYXJzZVhtbCkoZmVlZFhtbCk7XG4gICAgICAgICAgICBjb25zdCBsYXRlc3RSZWxlYXNlID0gZmVlZC5lbGVtZW50KFwiZW50cnlcIiwgZmFsc2UsIGBObyBwdWJsaXNoZWQgdmVyc2lvbnMgb24gR2l0SHViYCk7XG4gICAgICAgICAgICBsZXQgdmVyc2lvbjtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgaWYgKF90aGlzLnVwZGF0ZXIuYWxsb3dQcmVyZWxlYXNlKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIG5vaW5zcGVjdGlvbiBUeXBlU2NyaXB0VmFsaWRhdGVKU1R5cGVzXG4gICAgICAgICAgICAgICAgICAgIHZlcnNpb24gPSBsYXRlc3RSZWxlYXNlLmVsZW1lbnQoXCJsaW5rXCIpLmF0dHJpYnV0ZShcImhyZWZcIikubWF0Y2goL1xcL3RhZ1xcL3Y/KFteXFwvXSspJC8pWzFdO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHZlcnNpb24gPSB5aWVsZCBfdGhpcy5nZXRMYXRlc3RWZXJzaW9uU3RyaW5nKGJhc2VQYXRoLCBjYW5jZWxsYXRpb25Ub2tlbik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIHRocm93ICgwLCAoX2J1aWxkZXJVdGlsUnVudGltZSB8fCBfbG9hZF9idWlsZGVyVXRpbFJ1bnRpbWUoKSkubmV3RXJyb3IpKGBDYW5ub3QgcGFyc2UgcmVsZWFzZXMgZmVlZDogJHtlLnN0YWNrIHx8IGUubWVzc2FnZX0sXFxuWE1MOlxcbiR7ZmVlZFhtbH1gLCBcIkVSUl9VUERBVEVSX0lOVkFMSURfUkVMRUFTRV9GRUVEXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHZlcnNpb24gPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRocm93ICgwLCAoX2J1aWxkZXJVdGlsUnVudGltZSB8fCBfbG9hZF9idWlsZGVyVXRpbFJ1bnRpbWUoKSkubmV3RXJyb3IpKGBObyBwdWJsaXNoZWQgdmVyc2lvbnMgb24gR2l0SHViYCwgXCJFUlJfVVBEQVRFUl9OT19QVUJMSVNIRURfVkVSU0lPTlNcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBjaGFubmVsRmlsZSA9ICgwLCAoX21haW4gfHwgX2xvYWRfbWFpbigpKS5nZXRDaGFubmVsRmlsZW5hbWUpKCgwLCAoX21haW4gfHwgX2xvYWRfbWFpbigpKS5nZXREZWZhdWx0Q2hhbm5lbE5hbWUpKCkpO1xuICAgICAgICAgICAgY29uc3QgY2hhbm5lbEZpbGVVcmwgPSAoMCwgKF9tYWluIHx8IF9sb2FkX21haW4oKSkubmV3VXJsRnJvbUJhc2UpKF90aGlzLmdldEJhc2VEb3dubG9hZFBhdGgodmVyc2lvbiwgY2hhbm5lbEZpbGUpLCBfdGhpcy5iYXNlVXJsKTtcbiAgICAgICAgICAgIGNvbnN0IHJlcXVlc3RPcHRpb25zID0gX3RoaXMuY3JlYXRlUmVxdWVzdE9wdGlvbnMoY2hhbm5lbEZpbGVVcmwpO1xuICAgICAgICAgICAgbGV0IHJhd0RhdGE7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHJhd0RhdGEgPSB5aWVsZCBfdGhpcy5leGVjdXRvci5yZXF1ZXN0KHJlcXVlc3RPcHRpb25zLCBjYW5jZWxsYXRpb25Ub2tlbik7XG4gICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFfdGhpcy51cGRhdGVyLmFsbG93UHJlcmVsZWFzZSAmJiBlIGluc3RhbmNlb2YgKF9idWlsZGVyVXRpbFJ1bnRpbWUgfHwgX2xvYWRfYnVpbGRlclV0aWxSdW50aW1lKCkpLkh0dHBFcnJvciAmJiBlLnN0YXR1c0NvZGUgPT09IDQwNCkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyAoMCwgKF9idWlsZGVyVXRpbFJ1bnRpbWUgfHwgX2xvYWRfYnVpbGRlclV0aWxSdW50aW1lKCkpLm5ld0Vycm9yKShgQ2Fubm90IGZpbmQgJHtjaGFubmVsRmlsZX0gaW4gdGhlIGxhdGVzdCByZWxlYXNlIGFydGlmYWN0cyAoJHtjaGFubmVsRmlsZVVybH0pOiAke2Uuc3RhY2sgfHwgZS5tZXNzYWdlfWAsIFwiRVJSX1VQREFURVJfQ0hBTk5FTF9GSUxFX05PVF9GT1VORFwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9ICgwLCAoX1Byb3ZpZGVyIHx8IF9sb2FkX1Byb3ZpZGVyKCkpLnBhcnNlVXBkYXRlSW5mbykocmF3RGF0YSwgY2hhbm5lbEZpbGUsIGNoYW5uZWxGaWxlVXJsKTtcbiAgICAgICAgICAgIGlmICgoMCwgKF9tYWluIHx8IF9sb2FkX21haW4oKSkuaXNVc2VPbGRNYWNQcm92aWRlcikoKSkge1xuICAgICAgICAgICAgICAgIHJlc3VsdC5yZWxlYXNlSnNvblVybCA9IGAkeygwLCAoX2J1aWxkZXJVdGlsUnVudGltZSB8fCBfbG9hZF9idWlsZGVyVXRpbFJ1bnRpbWUoKSkuZ2l0aHViVXJsKShfdGhpcy5vcHRpb25zKX0vJHtyZXF1ZXN0T3B0aW9ucy5wYXRofWA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocmVzdWx0LnJlbGVhc2VOYW1lID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQucmVsZWFzZU5hbWUgPSBsYXRlc3RSZWxlYXNlLmVsZW1lbnRWYWx1ZU9yRW1wdHkoXCJ0aXRsZVwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChyZXN1bHQucmVsZWFzZU5vdGVzID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQucmVsZWFzZU5vdGVzID0gY29tcHV0ZVJlbGVhc2VOb3RlcyhfdGhpcy51cGRhdGVyLmN1cnJlbnRWZXJzaW9uLCBfdGhpcy51cGRhdGVyLmZ1bGxDaGFuZ2Vsb2csIGZlZWQsIGxhdGVzdFJlbGVhc2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfSkoKTtcbiAgICB9XG4gICAgZ2V0TGF0ZXN0VmVyc2lvblN0cmluZyhiYXNlUGF0aCwgY2FuY2VsbGF0aW9uVG9rZW4pIHtcbiAgICAgICAgdmFyIF90aGlzMiA9IHRoaXM7XG5cbiAgICAgICAgcmV0dXJuICgwLCAoX2JsdWViaXJkTHN0IHx8IF9sb2FkX2JsdWViaXJkTHN0KCkpLmNvcm91dGluZSkoZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGNvbnN0IHVybCA9ICgwLCAoX21haW4gfHwgX2xvYWRfbWFpbigpKS5uZXdVcmxGcm9tQmFzZSkoYCR7YmFzZVBhdGh9L2xhdGVzdGAsIF90aGlzMi5iYXNlVXJsKTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgLy8gZG8gbm90IHVzZSBBUEkgdG8gYXZvaWQgbGltaXRcbiAgICAgICAgICAgICAgICBjb25zdCByYXdEYXRhID0geWllbGQgX3RoaXMyLmh0dHBSZXF1ZXN0KHVybCwgeyBBY2NlcHQ6IFwiYXBwbGljYXRpb24vanNvblwiIH0sIGNhbmNlbGxhdGlvblRva2VuKTtcbiAgICAgICAgICAgICAgICBpZiAocmF3RGF0YSA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCByZWxlYXNlSW5mbyA9IEpTT04ucGFyc2UocmF3RGF0YSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlbGVhc2VJbmZvLnRhZ19uYW1lLnN0YXJ0c1dpdGgoXCJ2XCIpID8gcmVsZWFzZUluZm8udGFnX25hbWUuc3Vic3RyaW5nKDEpIDogcmVsZWFzZUluZm8udGFnX25hbWU7XG4gICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgKDAsIChfYnVpbGRlclV0aWxSdW50aW1lIHx8IF9sb2FkX2J1aWxkZXJVdGlsUnVudGltZSgpKS5uZXdFcnJvcikoYFVuYWJsZSB0byBmaW5kIGxhdGVzdCB2ZXJzaW9uIG9uIEdpdEh1YiAoJHt1cmx9KSwgcGxlYXNlIGVuc3VyZSBhIHByb2R1Y3Rpb24gcmVsZWFzZSBleGlzdHM6ICR7ZS5zdGFjayB8fCBlLm1lc3NhZ2V9YCwgXCJFUlJfVVBEQVRFUl9MQVRFU1RfVkVSU0lPTl9OT1RfRk9VTkRcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pKCk7XG4gICAgfVxuICAgIGdldCBiYXNlUGF0aCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29tcHV0ZUdpdGh1YkJhc2VQYXRoKGAvJHt0aGlzLm9wdGlvbnMub3duZXJ9LyR7dGhpcy5vcHRpb25zLnJlcG99L3JlbGVhc2VzYCk7XG4gICAgfVxuICAgIHJlc29sdmVGaWxlcyh1cGRhdGVJbmZvKSB7XG4gICAgICAgIC8vIHN0aWxsIHJlcGxhY2Ugc3BhY2UgdG8gLSBkdWUgdG8gYmFja3dhcmQgY29tcGF0aWJpbGl0eVxuICAgICAgICByZXR1cm4gKDAsIChfUHJvdmlkZXIgfHwgX2xvYWRfUHJvdmlkZXIoKSkucmVzb2x2ZUZpbGVzKSh1cGRhdGVJbmZvLCB0aGlzLmJhc2VVcmwsIHAgPT4gdGhpcy5nZXRCYXNlRG93bmxvYWRQYXRoKHVwZGF0ZUluZm8udmVyc2lvbiwgcC5yZXBsYWNlKC8gL2csIFwiLVwiKSkpO1xuICAgIH1cbiAgICBnZXRCYXNlRG93bmxvYWRQYXRoKHZlcnNpb24sIGZpbGVOYW1lKSB7XG4gICAgICAgIHJldHVybiBgJHt0aGlzLmJhc2VQYXRofS9kb3dubG9hZC8ke3RoaXMub3B0aW9ucy52UHJlZml4ZWRUYWdOYW1lID09PSBmYWxzZSA/IFwiXCIgOiBcInZcIn0ke3ZlcnNpb259LyR7ZmlsZU5hbWV9YDtcbiAgICB9XG59XG5leHBvcnRzLkdpdEh1YlByb3ZpZGVyID0gR2l0SHViUHJvdmlkZXI7XG5mdW5jdGlvbiBnZXROb3RlVmFsdWUocGFyZW50KSB7XG4gICAgY29uc3QgcmVzdWx0ID0gcGFyZW50LmVsZW1lbnRWYWx1ZU9yRW1wdHkoXCJjb250ZW50XCIpO1xuICAgIC8vIEdpdEh1YiByZXBvcnRzIGVtcHR5IG5vdGVzIGFzIDxjb250ZW50Pk5vIGNvbnRlbnQuPC9jb250ZW50PlxuICAgIHJldHVybiByZXN1bHQgPT09IFwiTm8gY29udGVudC5cIiA/IFwiXCIgOiByZXN1bHQ7XG59XG5mdW5jdGlvbiBjb21wdXRlUmVsZWFzZU5vdGVzKGN1cnJlbnRWZXJzaW9uLCBpc0Z1bGxDaGFuZ2Vsb2csIGZlZWQsIGxhdGVzdFJlbGVhc2UpIHtcbiAgICBpZiAoIWlzRnVsbENoYW5nZWxvZykge1xuICAgICAgICByZXR1cm4gZ2V0Tm90ZVZhbHVlKGxhdGVzdFJlbGVhc2UpO1xuICAgIH1cbiAgICBjb25zdCByZWxlYXNlTm90ZXMgPSBbXTtcbiAgICBmb3IgKGNvbnN0IHJlbGVhc2Ugb2YgZmVlZC5nZXRFbGVtZW50cyhcImVudHJ5XCIpKSB7XG4gICAgICAgIC8vIG5vaW5zcGVjdGlvbiBUeXBlU2NyaXB0VmFsaWRhdGVKU1R5cGVzXG4gICAgICAgIGNvbnN0IHZlcnNpb25SZWxlYXNlID0gcmVsZWFzZS5lbGVtZW50KFwibGlua1wiKS5hdHRyaWJ1dGUoXCJocmVmXCIpLm1hdGNoKC9cXC90YWdcXC92PyhbXlxcL10rKSQvKVsxXTtcbiAgICAgICAgaWYgKChfc2VtdmVyIHx8IF9sb2FkX3NlbXZlcigpKS5sdChjdXJyZW50VmVyc2lvbiwgdmVyc2lvblJlbGVhc2UpKSB7XG4gICAgICAgICAgICByZWxlYXNlTm90ZXMucHVzaCh7XG4gICAgICAgICAgICAgICAgdmVyc2lvbjogdmVyc2lvblJlbGVhc2UsXG4gICAgICAgICAgICAgICAgbm90ZTogZ2V0Tm90ZVZhbHVlKHJlbGVhc2UpXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVsZWFzZU5vdGVzLnNvcnQoKGEsIGIpID0+IChfc2VtdmVyIHx8IF9sb2FkX3NlbXZlcigpKS5yY29tcGFyZShhLnZlcnNpb24sIGIudmVyc2lvbikpO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9R2l0SHViUHJvdmlkZXIuanMubWFwXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2VsZWN0cm9uLXVwZGF0ZXIvb3V0L0dpdEh1YlByb3ZpZGVyLmpzIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuQmFzZVVwZGF0ZXIgPSB1bmRlZmluZWQ7XG5cbnZhciBfYmx1ZWJpcmRMc3Q7XG5cbmZ1bmN0aW9uIF9sb2FkX2JsdWViaXJkTHN0KCkge1xuICAgIHJldHVybiBfYmx1ZWJpcmRMc3QgPSByZXF1aXJlKFwiYmx1ZWJpcmQtbHN0XCIpO1xufVxuXG52YXIgX2J1aWxkZXJVdGlsUnVudGltZTtcblxuZnVuY3Rpb24gX2xvYWRfYnVpbGRlclV0aWxSdW50aW1lKCkge1xuICAgIHJldHVybiBfYnVpbGRlclV0aWxSdW50aW1lID0gcmVxdWlyZShcImJ1aWxkZXItdXRpbC1ydW50aW1lXCIpO1xufVxuXG52YXIgX2ZzRXh0cmFQO1xuXG5mdW5jdGlvbiBfbG9hZF9mc0V4dHJhUCgpIHtcbiAgICByZXR1cm4gX2ZzRXh0cmFQID0gcmVxdWlyZShcImZzLWV4dHJhLXBcIik7XG59XG5cbnZhciBfb3M7XG5cbmZ1bmN0aW9uIF9sb2FkX29zKCkge1xuICAgIHJldHVybiBfb3MgPSByZXF1aXJlKFwib3NcIik7XG59XG5cbnZhciBfcGF0aCA9IF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKHJlcXVpcmUoXCJwYXRoXCIpKTtcblxudmFyIF9BcHBVcGRhdGVyO1xuXG5mdW5jdGlvbiBfbG9hZF9BcHBVcGRhdGVyKCkge1xuICAgIHJldHVybiBfQXBwVXBkYXRlciA9IHJlcXVpcmUoXCIuL0FwcFVwZGF0ZXJcIik7XG59XG5cbnZhciBfRG93bmxvYWRlZFVwZGF0ZUhlbHBlcjtcblxuZnVuY3Rpb24gX2xvYWRfRG93bmxvYWRlZFVwZGF0ZUhlbHBlcigpIHtcbiAgICByZXR1cm4gX0Rvd25sb2FkZWRVcGRhdGVIZWxwZXIgPSByZXF1aXJlKFwiLi9Eb3dubG9hZGVkVXBkYXRlSGVscGVyXCIpO1xufVxuXG52YXIgX21haW47XG5cbmZ1bmN0aW9uIF9sb2FkX21haW4oKSB7XG4gICAgcmV0dXJuIF9tYWluID0gcmVxdWlyZShcIi4vbWFpblwiKTtcbn1cblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQob2JqKSB7IGlmIChvYmogJiYgb2JqLl9fZXNNb2R1bGUpIHsgcmV0dXJuIG9iajsgfSBlbHNlIHsgdmFyIG5ld09iaiA9IHt9OyBpZiAob2JqICE9IG51bGwpIHsgZm9yICh2YXIga2V5IGluIG9iaikgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwga2V5KSkgbmV3T2JqW2tleV0gPSBvYmpba2V5XTsgfSB9IG5ld09iai5kZWZhdWx0ID0gb2JqOyByZXR1cm4gbmV3T2JqOyB9IH1cblxuY2xhc3MgQmFzZVVwZGF0ZXIgZXh0ZW5kcyAoX0FwcFVwZGF0ZXIgfHwgX2xvYWRfQXBwVXBkYXRlcigpKS5BcHBVcGRhdGVyIHtcbiAgICBjb25zdHJ1Y3RvcihvcHRpb25zLCBhcHApIHtcbiAgICAgICAgc3VwZXIob3B0aW9ucywgYXBwKTtcbiAgICAgICAgdGhpcy5kb3dubG9hZGVkVXBkYXRlSGVscGVyID0gbmV3IChfRG93bmxvYWRlZFVwZGF0ZUhlbHBlciB8fCBfbG9hZF9Eb3dubG9hZGVkVXBkYXRlSGVscGVyKCkpLkRvd25sb2FkZWRVcGRhdGVIZWxwZXIoKTtcbiAgICAgICAgdGhpcy5xdWl0QW5kSW5zdGFsbENhbGxlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLnF1aXRIYW5kbGVyQWRkZWQgPSBmYWxzZTtcbiAgICB9XG4gICAgcXVpdEFuZEluc3RhbGwoaXNTaWxlbnQgPSBmYWxzZSwgaXNGb3JjZVJ1bkFmdGVyID0gZmFsc2UpIHtcbiAgICAgICAgdGhpcy5fbG9nZ2VyLmluZm8oYEluc3RhbGwgb24gZXhwbGljaXQgcXVpdEFuZEluc3RhbGxgKTtcbiAgICAgICAgaWYgKHRoaXMuaW5zdGFsbChpc1NpbGVudCwgaXNTaWxlbnQgPyBpc0ZvcmNlUnVuQWZ0ZXIgOiB0cnVlKSkge1xuICAgICAgICAgICAgc2V0SW1tZWRpYXRlKCgpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLmFwcC5xdWl0KCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBleGVjdXRlRG93bmxvYWQoZG93bmxvYWRPcHRpb25zLCBmaWxlSW5mbywgdGFzaykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgICAgIHJldHVybiAoMCwgKF9ibHVlYmlyZExzdCB8fCBfbG9hZF9ibHVlYmlyZExzdCgpKS5jb3JvdXRpbmUpKGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBpZiAoX3RoaXMubGlzdGVuZXJDb3VudCgoX21haW4gfHwgX2xvYWRfbWFpbigpKS5ET1dOTE9BRF9QUk9HUkVTUykgPiAwKSB7XG4gICAgICAgICAgICAgICAgZG93bmxvYWRPcHRpb25zLm9uUHJvZ3Jlc3MgPSBmdW5jdGlvbiAoaXQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF90aGlzLmVtaXQoKF9tYWluIHx8IF9sb2FkX21haW4oKSkuRE9XTkxPQURfUFJPR1JFU1MsIGl0KTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gdXNlIFRFU1RfQVBQX1RNUF9ESVIgaWYgZGVmaW5lZCBhbmQgZGV2ZWxvcGVyIG1hY2hpbmUgKG11c3QgYmUgbm90IHdpbmRvd3MgZHVlIHRvIHNlY3VyaXR5IHJlYXNvbnMgLSB3ZSBtdXN0IG5vdCB1c2UgZW52IHZhciBpbiB0aGUgcHJvZHVjdGlvbilcbiAgICAgICAgICAgIGNvbnN0IHRlbXBEaXIgPSB5aWVsZCAoMCwgKF9mc0V4dHJhUCB8fCBfbG9hZF9mc0V4dHJhUCgpKS5ta2R0ZW1wKShgJHtfcGF0aC5qb2luKChwcm9jZXNzLnBsYXRmb3JtID09PSBcImRhcndpblwiID8gcHJvY2Vzcy5lbnYuVEVTVF9BUFBfVE1QX0RJUiA6IG51bGwpIHx8ICgwLCAoX29zIHx8IF9sb2FkX29zKCkpLnRtcGRpcikoKSwgXCJ1cFwiKX0tYCk7XG4gICAgICAgICAgICBjb25zdCByZW1vdmVUZW1wRGlySWZBbnkgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMuZG93bmxvYWRlZFVwZGF0ZUhlbHBlci5jbGVhcigpO1xuICAgICAgICAgICAgICAgIHJldHVybiAoMCwgKF9mc0V4dHJhUCB8fCBfbG9hZF9mc0V4dHJhUCgpKS5yZW1vdmUpKHRlbXBEaXIpLmNhdGNoKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gaWdub3JlZFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZGVzdGluYXRpb25GaWxlID0gX3BhdGguam9pbih0ZW1wRGlyLCBfcGF0aC5wb3NpeC5iYXNlbmFtZShmaWxlSW5mby5pbmZvLnVybCkpO1xuICAgICAgICAgICAgICAgIHlpZWxkIHRhc2sodGVtcERpciwgZGVzdGluYXRpb25GaWxlLCByZW1vdmVUZW1wRGlySWZBbnkpO1xuICAgICAgICAgICAgICAgIF90aGlzLl9sb2dnZXIuaW5mbyhgTmV3IHZlcnNpb24gJHtfdGhpcy51cGRhdGVJbmZvLnZlcnNpb259IGhhcyBiZWVuIGRvd25sb2FkZWQgdG8gJHtkZXN0aW5hdGlvbkZpbGV9YCk7XG4gICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgeWllbGQgcmVtb3ZlVGVtcERpcklmQW55KCk7XG4gICAgICAgICAgICAgICAgaWYgKGUgaW5zdGFuY2VvZiAoX2J1aWxkZXJVdGlsUnVudGltZSB8fCBfbG9hZF9idWlsZGVyVXRpbFJ1bnRpbWUoKSkuQ2FuY2VsbGF0aW9uRXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuZW1pdChcInVwZGF0ZS1jYW5jZWxsZWRcIiwgX3RoaXMudXBkYXRlSW5mbyk7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLl9sb2dnZXIuaW5mbyhcIkNhbmNlbGxlZFwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSkoKTtcbiAgICB9XG4gICAgaW5zdGFsbChpc1NpbGVudCwgaXNSdW5BZnRlcikge1xuICAgICAgICBpZiAodGhpcy5xdWl0QW5kSW5zdGFsbENhbGxlZCkge1xuICAgICAgICAgICAgdGhpcy5fbG9nZ2VyLndhcm4oXCJpbnN0YWxsIGNhbGwgaWdub3JlZDogcXVpdEFuZEluc3RhbGxDYWxsZWQgaXMgc2V0IHRvIHRydWVcIik7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgaW5zdGFsbGVyUGF0aCA9IHRoaXMuZG93bmxvYWRlZFVwZGF0ZUhlbHBlci5maWxlO1xuICAgICAgICBpZiAoIXRoaXMudXBkYXRlQXZhaWxhYmxlIHx8IGluc3RhbGxlclBhdGggPT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5kaXNwYXRjaEVycm9yKG5ldyBFcnJvcihcIk5vIHVwZGF0ZSBhdmFpbGFibGUsIGNhbid0IHF1aXQgYW5kIGluc3RhbGxcIikpO1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIC8vIHByZXZlbnQgY2FsbGluZyBzZXZlcmFsIHRpbWVzXG4gICAgICAgIHRoaXMucXVpdEFuZEluc3RhbGxDYWxsZWQgPSB0cnVlO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgdGhpcy5fbG9nZ2VyLmluZm8oYEluc3RhbGw6IGlzU2lsZW50OiAke2lzU2lsZW50fSwgaXNSdW5BZnRlcjogJHtpc1J1bkFmdGVyfWApO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZG9JbnN0YWxsKGluc3RhbGxlclBhdGgsIGlzU2lsZW50LCBpc1J1bkFmdGVyKTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgdGhpcy5kaXNwYXRjaEVycm9yKGUpO1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFkZFF1aXRIYW5kbGVyKCkge1xuICAgICAgICBpZiAodGhpcy5xdWl0SGFuZGxlckFkZGVkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5xdWl0SGFuZGxlckFkZGVkID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5hcHAub25jZShcInF1aXRcIiwgKCkgPT4ge1xuICAgICAgICAgICAgaWYgKCF0aGlzLnF1aXRBbmRJbnN0YWxsQ2FsbGVkKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fbG9nZ2VyLmluZm8oXCJBdXRvIGluc3RhbGwgdXBkYXRlIG9uIHF1aXRcIik7XG4gICAgICAgICAgICAgICAgdGhpcy5pbnN0YWxsKHRydWUsIGZhbHNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxufVxuZXhwb3J0cy5CYXNlVXBkYXRlciA9IEJhc2VVcGRhdGVyOyAvLyMgc291cmNlTWFwcGluZ1VSTD1CYXNlVXBkYXRlci5qcy5tYXBcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvZWxlY3Ryb24tdXBkYXRlci9vdXQvQmFzZVVwZGF0ZXIuanMiLCJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5GaWxlV2l0aEVtYmVkZGVkQmxvY2tNYXBEaWZmZXJlbnRpYWxEb3dubG9hZGVyID0gdW5kZWZpbmVkO1xuXG52YXIgX2JsdWViaXJkTHN0O1xuXG5mdW5jdGlvbiBfbG9hZF9ibHVlYmlyZExzdCgpIHtcbiAgICByZXR1cm4gX2JsdWViaXJkTHN0ID0gcmVxdWlyZShcImJsdWViaXJkLWxzdFwiKTtcbn1cblxudmFyIF9ibG9ja01hcEFwaTtcblxuZnVuY3Rpb24gX2xvYWRfYmxvY2tNYXBBcGkoKSB7XG4gICAgcmV0dXJuIF9ibG9ja01hcEFwaSA9IHJlcXVpcmUoXCJidWlsZGVyLXV0aWwtcnVudGltZS9vdXQvYmxvY2tNYXBBcGlcIik7XG59XG5cbnZhciBfRGlmZmVyZW50aWFsRG93bmxvYWRlcjtcblxuZnVuY3Rpb24gX2xvYWRfRGlmZmVyZW50aWFsRG93bmxvYWRlcigpIHtcbiAgICByZXR1cm4gX0RpZmZlcmVudGlhbERvd25sb2FkZXIgPSByZXF1aXJlKFwiLi9EaWZmZXJlbnRpYWxEb3dubG9hZGVyXCIpO1xufVxuXG5jbGFzcyBGaWxlV2l0aEVtYmVkZGVkQmxvY2tNYXBEaWZmZXJlbnRpYWxEb3dubG9hZGVyIGV4dGVuZHMgKF9EaWZmZXJlbnRpYWxEb3dubG9hZGVyIHx8IF9sb2FkX0RpZmZlcmVudGlhbERvd25sb2FkZXIoKSkuRGlmZmVyZW50aWFsRG93bmxvYWRlciB7XG4gICAgZG93bmxvYWQoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICAgICAgcmV0dXJuICgwLCAoX2JsdWViaXJkTHN0IHx8IF9sb2FkX2JsdWViaXJkTHN0KCkpLmNvcm91dGluZSkoZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGNvbnN0IHBhY2thZ2VJbmZvID0gX3RoaXMuYmxvY2tBd2FyZUZpbGVJbmZvO1xuICAgICAgICAgICAgY29uc3QgZmlsZVNpemUgPSBwYWNrYWdlSW5mby5zaXplO1xuICAgICAgICAgICAgY29uc3Qgb2Zmc2V0ID0gZmlsZVNpemUgLSAocGFja2FnZUluZm8uYmxvY2tNYXBTaXplICsgNCk7XG4gICAgICAgICAgICBfdGhpcy5maWxlTWV0YWRhdGFCdWZmZXIgPSB5aWVsZCBfdGhpcy5yZWFkUmVtb3RlQnl0ZXMob2Zmc2V0LCBmaWxlU2l6ZSAtIDEpO1xuICAgICAgICAgICAgY29uc3QgbmV3QmxvY2tNYXAgPSB5aWVsZCAoMCwgKF9EaWZmZXJlbnRpYWxEb3dubG9hZGVyIHx8IF9sb2FkX0RpZmZlcmVudGlhbERvd25sb2FkZXIoKSkucmVhZEJsb2NrTWFwKShfdGhpcy5maWxlTWV0YWRhdGFCdWZmZXIuc2xpY2UoMCwgX3RoaXMuZmlsZU1ldGFkYXRhQnVmZmVyLmxlbmd0aCAtIDQpKTtcbiAgICAgICAgICAgIHlpZWxkIF90aGlzLmRvRG93bmxvYWQoSlNPTi5wYXJzZSgoeWllbGQgKDAsIChfYmxvY2tNYXBBcGkgfHwgX2xvYWRfYmxvY2tNYXBBcGkoKSkucmVhZEVtYmVkZGVkQmxvY2tNYXBEYXRhKShfdGhpcy5vcHRpb25zLm9sZEZpbGUpKSksIG5ld0Jsb2NrTWFwKTtcbiAgICAgICAgfSkoKTtcbiAgICB9XG59XG5leHBvcnRzLkZpbGVXaXRoRW1iZWRkZWRCbG9ja01hcERpZmZlcmVudGlhbERvd25sb2FkZXIgPSBGaWxlV2l0aEVtYmVkZGVkQmxvY2tNYXBEaWZmZXJlbnRpYWxEb3dubG9hZGVyOyAvLyMgc291cmNlTWFwcGluZ1VSTD1GaWxlV2l0aEVtYmVkZGVkQmxvY2tNYXBEaWZmZXJlbnRpYWxEb3dubG9hZGVyLmpzLm1hcFxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9lbGVjdHJvbi11cGRhdGVyL291dC9kaWZmZXJlbnRpYWxEb3dubG9hZGVyL0ZpbGVXaXRoRW1iZWRkZWRCbG9ja01hcERpZmZlcmVudGlhbERvd25sb2FkZXIuanMiLCJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5yZWFkRW1iZWRkZWRCbG9ja01hcERhdGEgPSBleHBvcnRzLkJMT0NLX01BUF9GSUxFX05BTUUgPSB1bmRlZmluZWQ7XG5cbnZhciBfYmx1ZWJpcmRMc3Q7XG5cbmZ1bmN0aW9uIF9sb2FkX2JsdWViaXJkTHN0KCkge1xuICAgIHJldHVybiBfYmx1ZWJpcmRMc3QgPSByZXF1aXJlKFwiYmx1ZWJpcmQtbHN0XCIpO1xufVxuXG52YXIgX2JsdWViaXJkTHN0MjtcblxuZnVuY3Rpb24gX2xvYWRfYmx1ZWJpcmRMc3QyKCkge1xuICAgIHJldHVybiBfYmx1ZWJpcmRMc3QyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiYmx1ZWJpcmQtbHN0XCIpKTtcbn1cblxubGV0IHJlYWRFbWJlZGRlZEJsb2NrTWFwRGF0YSA9IGV4cG9ydHMucmVhZEVtYmVkZGVkQmxvY2tNYXBEYXRhID0gKCgpID0+IHtcbiAgICB2YXIgX3JlZiA9ICgwLCAoX2JsdWViaXJkTHN0IHx8IF9sb2FkX2JsdWViaXJkTHN0KCkpLmNvcm91dGluZSkoZnVuY3Rpb24qIChmaWxlKSB7XG4gICAgICAgIGNvbnN0IGZkID0geWllbGQgKDAsIChfZnNFeHRyYVAgfHwgX2xvYWRfZnNFeHRyYVAoKSkub3BlbikoZmlsZSwgXCJyXCIpO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgZmlsZVNpemUgPSAoeWllbGQgKDAsIChfZnNFeHRyYVAgfHwgX2xvYWRfZnNFeHRyYVAoKSkuZnN0YXQpKGZkKSkuc2l6ZTtcbiAgICAgICAgICAgIGNvbnN0IHNpemVCdWZmZXIgPSBCdWZmZXIuYWxsb2NVbnNhZmUoNCk7XG4gICAgICAgICAgICB5aWVsZCAoMCwgKF9mc0V4dHJhUCB8fCBfbG9hZF9mc0V4dHJhUCgpKS5yZWFkKShmZCwgc2l6ZUJ1ZmZlciwgMCwgc2l6ZUJ1ZmZlci5sZW5ndGgsIGZpbGVTaXplIC0gc2l6ZUJ1ZmZlci5sZW5ndGgpO1xuICAgICAgICAgICAgY29uc3QgZGF0YUJ1ZmZlciA9IEJ1ZmZlci5hbGxvY1Vuc2FmZShzaXplQnVmZmVyLnJlYWRVSW50MzJCRSgwKSk7XG4gICAgICAgICAgICB5aWVsZCAoMCwgKF9mc0V4dHJhUCB8fCBfbG9hZF9mc0V4dHJhUCgpKS5yZWFkKShmZCwgZGF0YUJ1ZmZlciwgMCwgZGF0YUJ1ZmZlci5sZW5ndGgsIGZpbGVTaXplIC0gc2l6ZUJ1ZmZlci5sZW5ndGggLSBkYXRhQnVmZmVyLmxlbmd0aCk7XG4gICAgICAgICAgICB5aWVsZCAoMCwgKF9mc0V4dHJhUCB8fCBfbG9hZF9mc0V4dHJhUCgpKS5jbG9zZSkoZmQpO1xuICAgICAgICAgICAgY29uc3QgaW5mbGF0ZVJhdyA9IChfYmx1ZWJpcmRMc3QyIHx8IF9sb2FkX2JsdWViaXJkTHN0MigpKS5kZWZhdWx0LnByb21pc2lmeShyZXF1aXJlKFwiemxpYlwiKS5pbmZsYXRlUmF3KTtcbiAgICAgICAgICAgIHJldHVybiAoeWllbGQgaW5mbGF0ZVJhdyhkYXRhQnVmZmVyKSkudG9TdHJpbmcoKTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgeWllbGQgKDAsIChfZnNFeHRyYVAgfHwgX2xvYWRfZnNFeHRyYVAoKSkuY2xvc2UpKGZkKTtcbiAgICAgICAgICAgIHRocm93IGU7XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIHJldHVybiBmdW5jdGlvbiByZWFkRW1iZWRkZWRCbG9ja01hcERhdGEoX3gpIHtcbiAgICAgICAgcmV0dXJuIF9yZWYuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9O1xufSkoKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWJsb2NrTWFwQXBpLmpzLm1hcFxuXG5cbnZhciBfZnNFeHRyYVA7XG5cbmZ1bmN0aW9uIF9sb2FkX2ZzRXh0cmFQKCkge1xuICAgIHJldHVybiBfZnNFeHRyYVAgPSByZXF1aXJlKFwiZnMtZXh0cmEtcFwiKTtcbn1cblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuY29uc3QgQkxPQ0tfTUFQX0ZJTEVfTkFNRSA9IGV4cG9ydHMuQkxPQ0tfTUFQX0ZJTEVfTkFNRSA9IFwiX2Jsb2NrTWFwLmJsb2NrbWFwXCI7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2VsZWN0cm9uLXVwZGF0ZXIvbm9kZV9tb2R1bGVzL2J1aWxkZXItdXRpbC1ydW50aW1lL291dC9ibG9ja01hcEFwaS5qcyIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcInpsaWJcIik7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gZXh0ZXJuYWwgXCJ6bGliXCJcbi8vIG1vZHVsZSBpZCA9IDY0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLnJlYWRCbG9ja01hcCA9IGV4cG9ydHMuRGlmZmVyZW50aWFsRG93bmxvYWRlciA9IGV4cG9ydHMuRGlmZmVyZW50aWFsRG93bmxvYWRlck9wdGlvbnMgPSB1bmRlZmluZWQ7XG5cbnZhciBfYmx1ZWJpcmRMc3Q7XG5cbmZ1bmN0aW9uIF9sb2FkX2JsdWViaXJkTHN0KCkge1xuICAgIHJldHVybiBfYmx1ZWJpcmRMc3QgPSByZXF1aXJlKFwiYmx1ZWJpcmQtbHN0XCIpO1xufVxuXG52YXIgX2JsdWViaXJkTHN0MjtcblxuZnVuY3Rpb24gX2xvYWRfYmx1ZWJpcmRMc3QyKCkge1xuICAgIHJldHVybiBfYmx1ZWJpcmRMc3QyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiYmx1ZWJpcmQtbHN0XCIpKTtcbn1cblxubGV0IHJlYWRCbG9ja01hcCA9IGV4cG9ydHMucmVhZEJsb2NrTWFwID0gKCgpID0+IHtcbiAgICB2YXIgX3JlZiA9ICgwLCAoX2JsdWViaXJkTHN0IHx8IF9sb2FkX2JsdWViaXJkTHN0KCkpLmNvcm91dGluZSkoZnVuY3Rpb24qIChkYXRhKSB7XG4gICAgICAgIHJldHVybiBKU09OLnBhcnNlKCh5aWVsZCBpbmZsYXRlUmF3KGRhdGEpKS50b1N0cmluZygpKTtcbiAgICB9KTtcblxuICAgIHJldHVybiBmdW5jdGlvbiByZWFkQmxvY2tNYXAoX3gpIHtcbiAgICAgICAgcmV0dXJuIF9yZWYuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9O1xufSkoKTtcblxudmFyIF9idWlsZGVyVXRpbFJ1bnRpbWU7XG5cbmZ1bmN0aW9uIF9sb2FkX2J1aWxkZXJVdGlsUnVudGltZSgpIHtcbiAgICByZXR1cm4gX2J1aWxkZXJVdGlsUnVudGltZSA9IHJlcXVpcmUoXCJidWlsZGVyLXV0aWwtcnVudGltZVwiKTtcbn1cblxudmFyIF9mc0V4dHJhUDtcblxuZnVuY3Rpb24gX2xvYWRfZnNFeHRyYVAoKSB7XG4gICAgcmV0dXJuIF9mc0V4dHJhUCA9IHJlcXVpcmUoXCJmcy1leHRyYS1wXCIpO1xufVxuXG52YXIgX0RhdGFTcGxpdHRlcjtcblxuZnVuY3Rpb24gX2xvYWRfRGF0YVNwbGl0dGVyKCkge1xuICAgIHJldHVybiBfRGF0YVNwbGl0dGVyID0gcmVxdWlyZShcIi4vRGF0YVNwbGl0dGVyXCIpO1xufVxuXG52YXIgX2Rvd25sb2FkUGxhbkJ1aWxkZXI7XG5cbmZ1bmN0aW9uIF9sb2FkX2Rvd25sb2FkUGxhbkJ1aWxkZXIoKSB7XG4gICAgcmV0dXJuIF9kb3dubG9hZFBsYW5CdWlsZGVyID0gcmVxdWlyZShcIi4vZG93bmxvYWRQbGFuQnVpbGRlclwiKTtcbn1cblxudmFyIF9tdWx0aXBsZVJhbmdlRG93bmxvYWRlcjtcblxuZnVuY3Rpb24gX2xvYWRfbXVsdGlwbGVSYW5nZURvd25sb2FkZXIoKSB7XG4gICAgcmV0dXJuIF9tdWx0aXBsZVJhbmdlRG93bmxvYWRlciA9IHJlcXVpcmUoXCIuL211bHRpcGxlUmFuZ2VEb3dubG9hZGVyXCIpO1xufVxuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5jb25zdCBpbmZsYXRlUmF3ID0gKF9ibHVlYmlyZExzdDIgfHwgX2xvYWRfYmx1ZWJpcmRMc3QyKCkpLmRlZmF1bHQucHJvbWlzaWZ5KHJlcXVpcmUoXCJ6bGliXCIpLmluZmxhdGVSYXcpO1xuY2xhc3MgRGlmZmVyZW50aWFsRG93bmxvYWRlck9wdGlvbnMge31cbmV4cG9ydHMuRGlmZmVyZW50aWFsRG93bmxvYWRlck9wdGlvbnMgPSBEaWZmZXJlbnRpYWxEb3dubG9hZGVyT3B0aW9ucztcbmNsYXNzIERpZmZlcmVudGlhbERvd25sb2FkZXIge1xuICAgIC8vIG5vaW5zcGVjdGlvbiBUeXBlU2NyaXB0QWJzdHJhY3RDbGFzc0NvbnN0cnVjdG9yQ2FuQmVNYWRlUHJvdGVjdGVkXG4gICAgY29uc3RydWN0b3IoYmxvY2tBd2FyZUZpbGVJbmZvLCBodHRwRXhlY3V0b3IsIG9wdGlvbnMpIHtcbiAgICAgICAgdGhpcy5ibG9ja0F3YXJlRmlsZUluZm8gPSBibG9ja0F3YXJlRmlsZUluZm87XG4gICAgICAgIHRoaXMuaHR0cEV4ZWN1dG9yID0gaHR0cEV4ZWN1dG9yO1xuICAgICAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuICAgICAgICB0aGlzLmxvZ2dlciA9IG9wdGlvbnMubG9nZ2VyO1xuICAgICAgICB0aGlzLmJhc2VSZXF1ZXN0T3B0aW9ucyA9ICgwLCAoX2J1aWxkZXJVdGlsUnVudGltZSB8fCBfbG9hZF9idWlsZGVyVXRpbFJ1bnRpbWUoKSkuY29uZmlndXJlUmVxdWVzdE9wdGlvbnNGcm9tVXJsKShvcHRpb25zLm5ld1VybCwge30pO1xuICAgIH1cbiAgICBnZXQgc2lnbmF0dXJlU2l6ZSgpIHtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgfVxuICAgIGNyZWF0ZVJlcXVlc3RPcHRpb25zKG1ldGhvZCA9IFwiZ2V0XCIsIG5ld1VybCkge1xuICAgICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbih7fSwgbmV3VXJsID09IG51bGwgPyB0aGlzLmJhc2VSZXF1ZXN0T3B0aW9ucyA6ICgwLCAoX2J1aWxkZXJVdGlsUnVudGltZSB8fCBfbG9hZF9idWlsZGVyVXRpbFJ1bnRpbWUoKSkuY29uZmlndXJlUmVxdWVzdE9wdGlvbnNGcm9tVXJsKShuZXdVcmwsIHt9KSwgeyBtZXRob2QsIGhlYWRlcnM6IE9iamVjdC5hc3NpZ24oe30sIHRoaXMub3B0aW9ucy5yZXF1ZXN0SGVhZGVycywgeyBBY2NlcHQ6IFwiKi8qXCIgfSkgfSk7XG4gICAgfVxuICAgIGRvRG93bmxvYWQob2xkQmxvY2tNYXAsIG5ld0Jsb2NrTWFwKSB7XG4gICAgICAgIC8vIHdlIGRvbid0IGNoZWNrIG90aGVyIG1ldGFkYXRhIGxpa2UgY29tcHJlc3Npb25NZXRob2QgLSBnZW5lcmljIGNoZWNrIHRoYXQgaXQgaXMgbWFrZSBzZW5zZSB0byBkaWZmZXJlbnRpYWxseSB1cGRhdGUgaXMgc3VpdGFibGUgZm9yIGl0XG4gICAgICAgIGlmIChvbGRCbG9ja01hcC52ZXJzaW9uICE9PSBuZXdCbG9ja01hcC52ZXJzaW9uKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYHZlcnNpb24gaXMgZGlmZmVyZW50ICgke29sZEJsb2NrTWFwLnZlcnNpb259IC0gJHtuZXdCbG9ja01hcC52ZXJzaW9ufSksIGZ1bGwgZG93bmxvYWQgaXMgcmVxdWlyZWRgKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBsb2dnZXIgPSB0aGlzLmxvZ2dlcjtcbiAgICAgICAgY29uc3Qgb3BlcmF0aW9ucyA9ICgwLCAoX2Rvd25sb2FkUGxhbkJ1aWxkZXIgfHwgX2xvYWRfZG93bmxvYWRQbGFuQnVpbGRlcigpKS5jb21wdXRlT3BlcmF0aW9ucykob2xkQmxvY2tNYXAsIG5ld0Jsb2NrTWFwLCBsb2dnZXIpO1xuICAgICAgICBpZiAobG9nZ2VyLmRlYnVnICE9IG51bGwpIHtcbiAgICAgICAgICAgIGxvZ2dlci5kZWJ1ZyhKU09OLnN0cmluZ2lmeShvcGVyYXRpb25zLCBudWxsLCAyKSk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGRvd25sb2FkU2l6ZSA9IDA7XG4gICAgICAgIGxldCBjb3B5U2l6ZSA9IDA7XG4gICAgICAgIGZvciAoY29uc3Qgb3BlcmF0aW9uIG9mIG9wZXJhdGlvbnMpIHtcbiAgICAgICAgICAgIGNvbnN0IGxlbmd0aCA9IG9wZXJhdGlvbi5lbmQgLSBvcGVyYXRpb24uc3RhcnQ7XG4gICAgICAgICAgICBpZiAob3BlcmF0aW9uLmtpbmQgPT09IChfZG93bmxvYWRQbGFuQnVpbGRlciB8fCBfbG9hZF9kb3dubG9hZFBsYW5CdWlsZGVyKCkpLk9wZXJhdGlvbktpbmQuRE9XTkxPQUQpIHtcbiAgICAgICAgICAgICAgICBkb3dubG9hZFNpemUgKz0gbGVuZ3RoO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb3B5U2l6ZSArPSBsZW5ndGg7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbmV3UGFja2FnZVNpemUgPSB0aGlzLmJsb2NrQXdhcmVGaWxlSW5mby5zaXplO1xuICAgICAgICBpZiAoZG93bmxvYWRTaXplICsgY29weVNpemUgKyAodGhpcy5maWxlTWV0YWRhdGFCdWZmZXIgPT0gbnVsbCA/IDAgOiB0aGlzLmZpbGVNZXRhZGF0YUJ1ZmZlci5sZW5ndGgpICsgdGhpcy5zaWduYXR1cmVTaXplICE9PSBuZXdQYWNrYWdlU2l6ZSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnRlcm5hbCBlcnJvciwgc2l6ZSBtaXNtYXRjaDogZG93bmxvYWRTaXplOiAke2Rvd25sb2FkU2l6ZX0sIGNvcHlTaXplOiAke2NvcHlTaXplfSwgbmV3UGFja2FnZVNpemU6ICR7bmV3UGFja2FnZVNpemV9YCk7XG4gICAgICAgIH1cbiAgICAgICAgbG9nZ2VyLmluZm8oYEZ1bGw6ICR7Zm9ybWF0Qnl0ZXMobmV3UGFja2FnZVNpemUpfSwgVG8gZG93bmxvYWQ6ICR7Zm9ybWF0Qnl0ZXMoZG93bmxvYWRTaXplKX0gKCR7TWF0aC5yb3VuZChkb3dubG9hZFNpemUgLyAobmV3UGFja2FnZVNpemUgLyAxMDApKX0lKWApO1xuICAgICAgICByZXR1cm4gdGhpcy5kb3dubG9hZEZpbGUob3BlcmF0aW9ucyk7XG4gICAgfVxuICAgIGRvd25sb2FkRmlsZSh0YXNrcykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgICAgIHJldHVybiAoMCwgKF9ibHVlYmlyZExzdCB8fCBfbG9hZF9ibHVlYmlyZExzdCgpKS5jb3JvdXRpbmUpKGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCBzaWduYXR1cmUgPSBfdGhpcy5zaWduYXR1cmVTaXplID09PSAwID8gbnVsbCA6IHlpZWxkIF90aGlzLnJlYWRSZW1vdGVCeXRlcygwLCBfdGhpcy5zaWduYXR1cmVTaXplIC0gMSk7XG4gICAgICAgICAgICBjb25zdCBvbGRGaWxlRmQgPSB5aWVsZCAoMCwgKF9mc0V4dHJhUCB8fCBfbG9hZF9mc0V4dHJhUCgpKS5vcGVuKShfdGhpcy5vcHRpb25zLm9sZEZpbGUsIFwiclwiKTtcbiAgICAgICAgICAgIGNvbnN0IG5ld0ZpbGVGZCA9IHlpZWxkICgwLCAoX2ZzRXh0cmFQIHx8IF9sb2FkX2ZzRXh0cmFQKCkpLm9wZW4pKF90aGlzLm9wdGlvbnMubmV3RmlsZSwgXCJ3XCIpO1xuICAgICAgICAgICAgY29uc3QgZmlsZU91dCA9ICgwLCAoX2ZzRXh0cmFQIHx8IF9sb2FkX2ZzRXh0cmFQKCkpLmNyZWF0ZVdyaXRlU3RyZWFtKShfdGhpcy5vcHRpb25zLm5ld0ZpbGUsIHsgZmQ6IG5ld0ZpbGVGZCB9KTtcbiAgICAgICAgICAgIHlpZWxkIG5ldyAoX2JsdWViaXJkTHN0MiB8fCBfbG9hZF9ibHVlYmlyZExzdDIoKSkuZGVmYXVsdChmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgc3RyZWFtcyA9IFtdO1xuICAgICAgICAgICAgICAgIGNvbnN0IGRpZ2VzdFRyYW5zZm9ybSA9IG5ldyAoX2J1aWxkZXJVdGlsUnVudGltZSB8fCBfbG9hZF9idWlsZGVyVXRpbFJ1bnRpbWUoKSkuRGlnZXN0VHJhbnNmb3JtKF90aGlzLmJsb2NrQXdhcmVGaWxlSW5mby5zaGE1MTIpO1xuICAgICAgICAgICAgICAgIC8vIHRvIHNpbXBseSBkZWJ1ZywgZG8gbWFudWFsIHZhbGlkYXRpb24gdG8gYWxsb3cgZmlsZSB0byBiZSBmdWxseSB3cml0dGVuXG4gICAgICAgICAgICAgICAgZGlnZXN0VHJhbnNmb3JtLmlzVmFsaWRhdGVPbkVuZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIHN0cmVhbXMucHVzaChkaWdlc3RUcmFuc2Zvcm0pO1xuICAgICAgICAgICAgICAgIC8vIG5vaW5zcGVjdGlvbiBKU0Fycm93RnVuY3Rpb25DYW5CZVJlcGxhY2VkV2l0aFNob3J0aGFuZFxuICAgICAgICAgICAgICAgIGZpbGVPdXQub24oXCJmaW5pc2hcIiwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICBmaWxlT3V0LmNsb3NlKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGlnZXN0VHJhbnNmb3JtLnZhbGlkYXRlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVqZWN0KGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmUoKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgc3RyZWFtcy5wdXNoKGZpbGVPdXQpO1xuICAgICAgICAgICAgICAgIGxldCBsYXN0U3RyZWFtID0gbnVsbDtcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IHN0cmVhbSBvZiBzdHJlYW1zKSB7XG4gICAgICAgICAgICAgICAgICAgIHN0cmVhbS5vbihcImVycm9yXCIsIHJlamVjdCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChsYXN0U3RyZWFtID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxhc3RTdHJlYW0gPSBzdHJlYW07XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsYXN0U3RyZWFtID0gbGFzdFN0cmVhbS5waXBlKHN0cmVhbSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgZmlyc3RTdHJlYW0gPSBzdHJlYW1zWzBdO1xuICAgICAgICAgICAgICAgIGxldCB3O1xuICAgICAgICAgICAgICAgIGlmIChfdGhpcy5vcHRpb25zLnVzZU11bHRpcGxlUmFuZ2VSZXF1ZXN0KSB7XG4gICAgICAgICAgICAgICAgICAgIHcgPSAoMCwgKF9tdWx0aXBsZVJhbmdlRG93bmxvYWRlciB8fCBfbG9hZF9tdWx0aXBsZVJhbmdlRG93bmxvYWRlcigpKS5leGVjdXRlVGFza3MpKF90aGlzLCB0YXNrcywgZmlyc3RTdHJlYW0sIG9sZEZpbGVGZCwgcmVqZWN0KTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBsZXQgYXR0ZW1wdENvdW50ID0gMDtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGFjdHVhbFVybCA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLmxvZ2dlci5pbmZvKGBEaWZmZXJlbnRpYWwgZG93bmxvYWQ6ICR7X3RoaXMub3B0aW9ucy5uZXdVcmx9YCk7XG4gICAgICAgICAgICAgICAgICAgIHcgPSBmdW5jdGlvbiAoaW5kZXgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpbmRleCA+PSB0YXNrcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoX3RoaXMuZmlsZU1ldGFkYXRhQnVmZmVyICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZmlyc3RTdHJlYW0ud3JpdGUoX3RoaXMuZmlsZU1ldGFkYXRhQnVmZmVyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZmlyc3RTdHJlYW0uZW5kKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3Qgb3BlcmF0aW9uID0gdGFza3NbaW5kZXgrK107XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAob3BlcmF0aW9uLmtpbmQgPT09IChfZG93bmxvYWRQbGFuQnVpbGRlciB8fCBfbG9hZF9kb3dubG9hZFBsYW5CdWlsZGVyKCkpLk9wZXJhdGlvbktpbmQuQ09QWSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICgwLCAoX0RhdGFTcGxpdHRlciB8fCBfbG9hZF9EYXRhU3BsaXR0ZXIoKSkuY29weURhdGEpKG9wZXJhdGlvbiwgZmlyc3RTdHJlYW0sIG9sZEZpbGVGZCwgcmVqZWN0LCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB3KGluZGV4KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVxdWVzdE9wdGlvbnMgPSBfdGhpcy5jcmVhdGVSZXF1ZXN0T3B0aW9ucyhcImdldFwiLCBhY3R1YWxVcmwpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHJhbmdlID0gYGJ5dGVzPSR7b3BlcmF0aW9uLnN0YXJ0fS0ke29wZXJhdGlvbi5lbmQgLSAxfWA7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVxdWVzdE9wdGlvbnMuaGVhZGVycy5SYW5nZSA9IHJhbmdlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlcXVlc3RPcHRpb25zLnJlZGlyZWN0ID0gXCJtYW51YWxcIjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBkZWJ1ZyA9IF90aGlzLmxvZ2dlci5kZWJ1ZztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZGVidWcgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWJ1ZyhgZWZmZWN0aXZlIHVybDogJHthY3R1YWxVcmwgPT0gbnVsbCA/IFwiXCIgOiByZW1vdmVRdWVyeShhY3R1YWxVcmwpfSwgcmFuZ2U6ICR7cmFuZ2V9YCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlcXVlc3QgPSBfdGhpcy5odHRwRXhlY3V0b3IuZG9SZXF1ZXN0KHJlcXVlc3RPcHRpb25zLCBmdW5jdGlvbiAocmVzcG9uc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gRWxlY3Ryb24gbmV0IGhhbmRsZXMgcmVkaXJlY3RzIGF1dG9tYXRpY2FsbHksIG91ciBOb2RlSlMgdGVzdCBzZXJ2ZXIgZG9lc24ndCB1c2UgcmVkaXJlY3RzIC0gc28sIHdlIGRvbid0IGNoZWNrIDN4eCBjb2Rlcy5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJlc3BvbnNlLnN0YXR1c0NvZGUgPj0gNDAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWplY3QoKDAsIChfYnVpbGRlclV0aWxSdW50aW1lIHx8IF9sb2FkX2J1aWxkZXJVdGlsUnVudGltZSgpKS5jcmVhdGVIdHRwRXJyb3IpKHJlc3BvbnNlKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2UucGlwZShmaXJzdFN0cmVhbSwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZW5kOiBmYWxzZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2Uub25jZShcImVuZFwiLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoKythdHRlbXB0Q291bnQgPT09IDEwMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGF0dGVtcHRDb3VudCA9IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB3KGluZGV4KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LCAxMDAwKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdyhpbmRleCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlcXVlc3Qub24oXCJyZWRpcmVjdFwiLCBmdW5jdGlvbiAoc3RhdHVzQ29kZSwgbWV0aG9kLCByZWRpcmVjdFVybCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5sb2dnZXIuaW5mbyhgUmVkaXJlY3QgdG8gJHtyZW1vdmVRdWVyeShyZWRpcmVjdFVybCl9YCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFjdHVhbFVybCA9IHJlZGlyZWN0VXJsO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXF1ZXN0LmZvbGxvd1JlZGlyZWN0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuaHR0cEV4ZWN1dG9yLmFkZEVycm9yQW5kVGltZW91dEhhbmRsZXJzKHJlcXVlc3QsIHJlamVjdCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVxdWVzdC5lbmQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHNpZ25hdHVyZSA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHcoMCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZmlyc3RTdHJlYW0ud3JpdGUoc2lnbmF0dXJlLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdygwKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSkudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICgwLCAoX2ZzRXh0cmFQIHx8IF9sb2FkX2ZzRXh0cmFQKCkpLmNsb3NlKShvbGRGaWxlRmQpO1xuICAgICAgICAgICAgfSkuY2F0Y2goZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgKDAsIChfZnNFeHRyYVAgfHwgX2xvYWRfZnNFeHRyYVAoKSkuY2xvc2VTeW5jKShvbGRGaWxlRmQpO1xuICAgICAgICAgICAgICAgICgwLCAoX2ZzRXh0cmFQIHx8IF9sb2FkX2ZzRXh0cmFQKCkpLmNsb3NlU3luYykobmV3RmlsZUZkKTtcbiAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KSgpO1xuICAgIH1cbiAgICByZWFkUmVtb3RlQnl0ZXMoc3RhcnQsIGVuZEluY2x1c2l2ZSkge1xuICAgICAgICB2YXIgX3RoaXMyID0gdGhpcztcblxuICAgICAgICByZXR1cm4gKDAsIChfYmx1ZWJpcmRMc3QgfHwgX2xvYWRfYmx1ZWJpcmRMc3QoKSkuY29yb3V0aW5lKShmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3QgYnVmZmVyID0gQnVmZmVyLmFsbG9jVW5zYWZlKGVuZEluY2x1c2l2ZSArIDEgLSBzdGFydCk7XG4gICAgICAgICAgICBjb25zdCByZXF1ZXN0T3B0aW9ucyA9IF90aGlzMi5jcmVhdGVSZXF1ZXN0T3B0aW9ucygpO1xuICAgICAgICAgICAgcmVxdWVzdE9wdGlvbnMuaGVhZGVycy5SYW5nZSA9IGBieXRlcz0ke3N0YXJ0fS0ke2VuZEluY2x1c2l2ZX1gO1xuICAgICAgICAgICAgbGV0IHBvc2l0aW9uID0gMDtcbiAgICAgICAgICAgIHlpZWxkIF90aGlzMi5yZXF1ZXN0KHJlcXVlc3RPcHRpb25zLCBmdW5jdGlvbiAoY2h1bmspIHtcbiAgICAgICAgICAgICAgICBjaHVuay5jb3B5KGJ1ZmZlciwgcG9zaXRpb24pO1xuICAgICAgICAgICAgICAgIHBvc2l0aW9uICs9IGNodW5rLmxlbmd0aDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIGJ1ZmZlcjtcbiAgICAgICAgfSkoKTtcbiAgICB9XG4gICAgcmVxdWVzdChyZXF1ZXN0T3B0aW9ucywgZGF0YUhhbmRsZXIpIHtcbiAgICAgICAgcmV0dXJuIG5ldyAoX2JsdWViaXJkTHN0MiB8fCBfbG9hZF9ibHVlYmlyZExzdDIoKSkuZGVmYXVsdCgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICBjb25zdCByZXF1ZXN0ID0gdGhpcy5odHRwRXhlY3V0b3IuZG9SZXF1ZXN0KHJlcXVlc3RPcHRpb25zLCByZXNwb25zZSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKCEoMCwgKF9tdWx0aXBsZVJhbmdlRG93bmxvYWRlciB8fCBfbG9hZF9tdWx0aXBsZVJhbmdlRG93bmxvYWRlcigpKS5jaGVja0lzUmFuZ2VzU3VwcG9ydGVkKShyZXNwb25zZSwgcmVqZWN0KSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJlc3BvbnNlLm9uKFwiZGF0YVwiLCBkYXRhSGFuZGxlcik7XG4gICAgICAgICAgICAgICAgcmVzcG9uc2Uub24oXCJlbmRcIiwgKCkgPT4gcmVzb2x2ZSgpKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdGhpcy5odHRwRXhlY3V0b3IuYWRkRXJyb3JBbmRUaW1lb3V0SGFuZGxlcnMocmVxdWVzdCwgcmVqZWN0KTtcbiAgICAgICAgICAgIHJlcXVlc3QuZW5kKCk7XG4gICAgICAgIH0pO1xuICAgIH1cbn1cbmV4cG9ydHMuRGlmZmVyZW50aWFsRG93bmxvYWRlciA9IERpZmZlcmVudGlhbERvd25sb2FkZXI7XG5cbmZ1bmN0aW9uIGZvcm1hdEJ5dGVzKHZhbHVlLCBzeW1ib2wgPSBcIiBLQlwiKSB7XG4gICAgcmV0dXJuIG5ldyBJbnRsLk51bWJlckZvcm1hdChcImVuXCIpLmZvcm1hdCgodmFsdWUgLyAxMDI0KS50b0ZpeGVkKDIpKSArIHN5bWJvbDtcbn1cbi8vIHNhZmV0eVxuZnVuY3Rpb24gcmVtb3ZlUXVlcnkodXJsKSB7XG4gICAgY29uc3QgaW5kZXggPSB1cmwuaW5kZXhPZihcIj9cIik7XG4gICAgcmV0dXJuIGluZGV4IDwgMCA/IHVybCA6IHVybC5zdWJzdHJpbmcoMCwgaW5kZXgpO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9RGlmZmVyZW50aWFsRG93bmxvYWRlci5qcy5tYXBcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvZWxlY3Ryb24tdXBkYXRlci9vdXQvZGlmZmVyZW50aWFsRG93bmxvYWRlci9EaWZmZXJlbnRpYWxEb3dubG9hZGVyLmpzIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuRGF0YVNwbGl0dGVyID0gdW5kZWZpbmVkO1xuXG52YXIgX2JsdWViaXJkTHN0O1xuXG5mdW5jdGlvbiBfbG9hZF9ibHVlYmlyZExzdCgpIHtcbiAgICByZXR1cm4gX2JsdWViaXJkTHN0ID0gcmVxdWlyZShcImJsdWViaXJkLWxzdFwiKTtcbn1cblxudmFyIF9ibHVlYmlyZExzdDI7XG5cbmZ1bmN0aW9uIF9sb2FkX2JsdWViaXJkTHN0MigpIHtcbiAgICByZXR1cm4gX2JsdWViaXJkTHN0MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcImJsdWViaXJkLWxzdFwiKSk7XG59XG5cbmV4cG9ydHMuY29weURhdGEgPSBjb3B5RGF0YTtcblxudmFyIF9idWlsZGVyVXRpbFJ1bnRpbWU7XG5cbmZ1bmN0aW9uIF9sb2FkX2J1aWxkZXJVdGlsUnVudGltZSgpIHtcbiAgICByZXR1cm4gX2J1aWxkZXJVdGlsUnVudGltZSA9IHJlcXVpcmUoXCJidWlsZGVyLXV0aWwtcnVudGltZVwiKTtcbn1cblxudmFyIF9mc0V4dHJhUDtcblxuZnVuY3Rpb24gX2xvYWRfZnNFeHRyYVAoKSB7XG4gICAgcmV0dXJuIF9mc0V4dHJhUCA9IHJlcXVpcmUoXCJmcy1leHRyYS1wXCIpO1xufVxuXG52YXIgX3N0cmVhbTtcblxuZnVuY3Rpb24gX2xvYWRfc3RyZWFtKCkge1xuICAgIHJldHVybiBfc3RyZWFtID0gcmVxdWlyZShcInN0cmVhbVwiKTtcbn1cblxudmFyIF9kb3dubG9hZFBsYW5CdWlsZGVyO1xuXG5mdW5jdGlvbiBfbG9hZF9kb3dubG9hZFBsYW5CdWlsZGVyKCkge1xuICAgIHJldHVybiBfZG93bmxvYWRQbGFuQnVpbGRlciA9IHJlcXVpcmUoXCIuL2Rvd25sb2FkUGxhbkJ1aWxkZXJcIik7XG59XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmNvbnN0IERPVUJMRV9DUkxGID0gQnVmZmVyLmZyb20oXCJcXHJcXG5cXHJcXG5cIik7XG52YXIgUmVhZFN0YXRlO1xuKGZ1bmN0aW9uIChSZWFkU3RhdGUpIHtcbiAgICBSZWFkU3RhdGVbUmVhZFN0YXRlW1wiSU5JVFwiXSA9IDBdID0gXCJJTklUXCI7XG4gICAgUmVhZFN0YXRlW1JlYWRTdGF0ZVtcIkhFQURFUlwiXSA9IDFdID0gXCJIRUFERVJcIjtcbiAgICBSZWFkU3RhdGVbUmVhZFN0YXRlW1wiQk9EWVwiXSA9IDJdID0gXCJCT0RZXCI7XG59KShSZWFkU3RhdGUgfHwgKFJlYWRTdGF0ZSA9IHt9KSk7XG5mdW5jdGlvbiBjb3B5RGF0YSh0YXNrLCBvdXQsIG9sZEZpbGVGZCwgcmVqZWN0LCByZXNvbHZlKSB7XG4gICAgY29uc3QgcmVhZFN0cmVhbSA9ICgwLCAoX2ZzRXh0cmFQIHx8IF9sb2FkX2ZzRXh0cmFQKCkpLmNyZWF0ZVJlYWRTdHJlYW0pKFwiXCIsIHtcbiAgICAgICAgZmQ6IG9sZEZpbGVGZCxcbiAgICAgICAgYXV0b0Nsb3NlOiBmYWxzZSxcbiAgICAgICAgc3RhcnQ6IHRhc2suc3RhcnQsXG4gICAgICAgIC8vIGVuZCBpcyBpbmNsdXNpdmVcbiAgICAgICAgZW5kOiB0YXNrLmVuZCAtIDFcbiAgICB9KTtcbiAgICByZWFkU3RyZWFtLm9uKFwiZXJyb3JcIiwgcmVqZWN0KTtcbiAgICByZWFkU3RyZWFtLm9uY2UoXCJlbmRcIiwgcmVzb2x2ZSk7XG4gICAgcmVhZFN0cmVhbS5waXBlKG91dCwge1xuICAgICAgICBlbmQ6IGZhbHNlXG4gICAgfSk7XG59XG5jbGFzcyBEYXRhU3BsaXR0ZXIgZXh0ZW5kcyAoX3N0cmVhbSB8fCBfbG9hZF9zdHJlYW0oKSkuV3JpdGFibGUge1xuICAgIGNvbnN0cnVjdG9yKG91dCwgb3B0aW9ucywgcGFydEluZGV4VG9UYXNrSW5kZXgsIGJvdW5kYXJ5LCBwYXJ0SW5kZXhUb0xlbmd0aCwgZmluaXNoSGFuZGxlcikge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLm91dCA9IG91dDtcbiAgICAgICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgICAgICAgdGhpcy5wYXJ0SW5kZXhUb1Rhc2tJbmRleCA9IHBhcnRJbmRleFRvVGFza0luZGV4O1xuICAgICAgICB0aGlzLnBhcnRJbmRleFRvTGVuZ3RoID0gcGFydEluZGV4VG9MZW5ndGg7XG4gICAgICAgIHRoaXMuZmluaXNoSGFuZGxlciA9IGZpbmlzaEhhbmRsZXI7XG4gICAgICAgIHRoaXMucGFydEluZGV4ID0gLTE7XG4gICAgICAgIHRoaXMuaGVhZGVyTGlzdEJ1ZmZlciA9IG51bGw7XG4gICAgICAgIHRoaXMucmVhZFN0YXRlID0gUmVhZFN0YXRlLklOSVQ7XG4gICAgICAgIHRoaXMuaWdub3JlQnl0ZUNvdW50ID0gMDtcbiAgICAgICAgdGhpcy5yZW1haW5pbmdQYXJ0RGF0YUNvdW50ID0gMDtcbiAgICAgICAgdGhpcy5hY3R1YWxQYXJ0TGVuZ3RoID0gMDtcbiAgICAgICAgdGhpcy5ib3VuZGFyeUxlbmd0aCA9IGJvdW5kYXJ5Lmxlbmd0aCArIDQ7IC8qIHNpemUgb2YgXFxyXFxuLS0gKi9cbiAgICAgICAgLy8gZmlyc3QgY2h1bmsgZG9lc24ndCBzdGFydCB3aXRoIFxcclxcblxuICAgICAgICB0aGlzLmlnbm9yZUJ5dGVDb3VudCA9IHRoaXMuYm91bmRhcnlMZW5ndGggLSAyO1xuICAgIH1cbiAgICBnZXQgaXNGaW5pc2hlZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucGFydEluZGV4ID09PSB0aGlzLnBhcnRJbmRleFRvTGVuZ3RoLmxlbmd0aDtcbiAgICB9XG4gICAgLy8gbm9pbnNwZWN0aW9uIEpTVW51c2VkR2xvYmFsU3ltYm9sc1xuICAgIF93cml0ZShkYXRhLCBlbmNvZGluZywgY2FsbGJhY2spIHtcbiAgICAgICAgaWYgKHRoaXMuaXNGaW5pc2hlZCkge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcihgVHJhaWxpbmcgaWdub3JlZCBkYXRhOiAke2RhdGEubGVuZ3RofSBieXRlc2ApO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuaGFuZGxlRGF0YShkYXRhKS50aGVuKGNhbGxiYWNrKS5jYXRjaChjYWxsYmFjayk7XG4gICAgfVxuICAgIGhhbmRsZURhdGEoY2h1bmspIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgICAgICByZXR1cm4gKDAsIChfYmx1ZWJpcmRMc3QgfHwgX2xvYWRfYmx1ZWJpcmRMc3QoKSkuY29yb3V0aW5lKShmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgbGV0IHN0YXJ0ID0gMDtcbiAgICAgICAgICAgIGlmIChfdGhpcy5pZ25vcmVCeXRlQ291bnQgIT09IDAgJiYgX3RoaXMucmVtYWluaW5nUGFydERhdGFDb3VudCAhPT0gMCkge1xuICAgICAgICAgICAgICAgIHRocm93ICgwLCAoX2J1aWxkZXJVdGlsUnVudGltZSB8fCBfbG9hZF9idWlsZGVyVXRpbFJ1bnRpbWUoKSkubmV3RXJyb3IpKFwiSW50ZXJuYWwgZXJyb3JcIiwgXCJFUlJfREFUQV9TUExJVFRFUl9CWVRFX0NPVU5UX01JU01BVENIXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKF90aGlzLmlnbm9yZUJ5dGVDb3VudCA+IDApIHtcbiAgICAgICAgICAgICAgICBjb25zdCB0b0lnbm9yZSA9IE1hdGgubWluKF90aGlzLmlnbm9yZUJ5dGVDb3VudCwgY2h1bmsubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICBfdGhpcy5pZ25vcmVCeXRlQ291bnQgLT0gdG9JZ25vcmU7XG4gICAgICAgICAgICAgICAgc3RhcnQgPSB0b0lnbm9yZTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoX3RoaXMucmVtYWluaW5nUGFydERhdGFDb3VudCA+IDApIHtcbiAgICAgICAgICAgICAgICBjb25zdCB0b1JlYWQgPSBNYXRoLm1pbihfdGhpcy5yZW1haW5pbmdQYXJ0RGF0YUNvdW50LCBjaHVuay5sZW5ndGgpO1xuICAgICAgICAgICAgICAgIF90aGlzLnJlbWFpbmluZ1BhcnREYXRhQ291bnQgLT0gdG9SZWFkO1xuICAgICAgICAgICAgICAgIHlpZWxkIF90aGlzLnByb2Nlc3NQYXJ0RGF0YShjaHVuaywgMCwgdG9SZWFkKTtcbiAgICAgICAgICAgICAgICBzdGFydCA9IHRvUmVhZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzdGFydCA9PT0gY2h1bmsubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKF90aGlzLnJlYWRTdGF0ZSA9PT0gUmVhZFN0YXRlLkhFQURFUikge1xuICAgICAgICAgICAgICAgIGNvbnN0IGhlYWRlckxpc3RFbmQgPSBfdGhpcy5zZWFyY2hIZWFkZXJMaXN0RW5kKGNodW5rLCBzdGFydCk7XG4gICAgICAgICAgICAgICAgaWYgKGhlYWRlckxpc3RFbmQgPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgc3RhcnQgPSBoZWFkZXJMaXN0RW5kO1xuICAgICAgICAgICAgICAgIF90aGlzLnJlYWRTdGF0ZSA9IFJlYWRTdGF0ZS5CT0RZO1xuICAgICAgICAgICAgICAgIC8vIGhlYWRlciBsaXN0IGlzIGlnbm9yZWQsIHdlIGRvbid0IG5lZWQgaXRcbiAgICAgICAgICAgICAgICBfdGhpcy5oZWFkZXJMaXN0QnVmZmVyID0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgICAgICAgICAgaWYgKF90aGlzLnJlYWRTdGF0ZSA9PT0gUmVhZFN0YXRlLkJPRFkpIHtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMucmVhZFN0YXRlID0gUmVhZFN0YXRlLklOSVQ7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMucGFydEluZGV4Kys7XG4gICAgICAgICAgICAgICAgICAgIGxldCB0YXNrSW5kZXggPSBfdGhpcy5wYXJ0SW5kZXhUb1Rhc2tJbmRleC5nZXQoX3RoaXMucGFydEluZGV4KTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRhc2tJbmRleCA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoX3RoaXMuaXNGaW5pc2hlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRhc2tJbmRleCA9IF90aGlzLm9wdGlvbnMuZW5kO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyAoMCwgKF9idWlsZGVyVXRpbFJ1bnRpbWUgfHwgX2xvYWRfYnVpbGRlclV0aWxSdW50aW1lKCkpLm5ld0Vycm9yKShcInRhc2tJbmRleCBpcyBudWxsXCIsIFwiRVJSX0RBVEFfU1BMSVRURVJfVEFTS19JTkRFWF9JU19OVUxMXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHByZXZUYXNrSW5kZXggPSBfdGhpcy5wYXJ0SW5kZXggPT09IDAgPyBfdGhpcy5vcHRpb25zLnN0YXJ0IDogX3RoaXMucGFydEluZGV4VG9UYXNrSW5kZXguZ2V0KF90aGlzLnBhcnRJbmRleCAtIDEpICsgMSAvKiBwcmV2IHBhcnQgaXMgZG93bmxvYWQsIG5leHQgbWF5YmUgY29weSAqLztcbiAgICAgICAgICAgICAgICAgICAgaWYgKHByZXZUYXNrSW5kZXggPCB0YXNrSW5kZXgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHlpZWxkIF90aGlzLmNvcHlFeGlzdGluZ0RhdGEocHJldlRhc2tJbmRleCwgdGFza0luZGV4KTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChwcmV2VGFza0luZGV4ID4gdGFza0luZGV4KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyAoMCwgKF9idWlsZGVyVXRpbFJ1bnRpbWUgfHwgX2xvYWRfYnVpbGRlclV0aWxSdW50aW1lKCkpLm5ld0Vycm9yKShcInByZXZUYXNrSW5kZXggbXVzdCBiZSA8IHRhc2tJbmRleFwiLCBcIkVSUl9EQVRBX1NQTElUVEVSX1RBU0tfSU5ERVhfQVNTRVJUX0ZBSUxFRFwiKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoX3RoaXMuaXNGaW5pc2hlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMub25QYXJ0RW5kKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5maW5pc2hIYW5kbGVyKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgc3RhcnQgPSBfdGhpcy5zZWFyY2hIZWFkZXJMaXN0RW5kKGNodW5rLCBzdGFydCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzdGFydCA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLnJlYWRTdGF0ZSA9IFJlYWRTdGF0ZS5IRUFERVI7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgcGFydExlbmd0aCA9IF90aGlzLnBhcnRJbmRleFRvTGVuZ3RoW190aGlzLnBhcnRJbmRleF07XG4gICAgICAgICAgICAgICAgY29uc3QgZW5kID0gc3RhcnQgKyBwYXJ0TGVuZ3RoO1xuICAgICAgICAgICAgICAgIGNvbnN0IGVmZmVjdGl2ZUVuZCA9IE1hdGgubWluKGVuZCwgY2h1bmsubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICB5aWVsZCBfdGhpcy5wcm9jZXNzUGFydFN0YXJ0ZWQoY2h1bmssIHN0YXJ0LCBlZmZlY3RpdmVFbmQpO1xuICAgICAgICAgICAgICAgIF90aGlzLnJlbWFpbmluZ1BhcnREYXRhQ291bnQgPSBwYXJ0TGVuZ3RoIC0gKGVmZmVjdGl2ZUVuZCAtIHN0YXJ0KTtcbiAgICAgICAgICAgICAgICBpZiAoX3RoaXMucmVtYWluaW5nUGFydERhdGFDb3VudCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBzdGFydCA9IGVuZCArIF90aGlzLmJvdW5kYXJ5TGVuZ3RoO1xuICAgICAgICAgICAgICAgIGlmIChzdGFydCA+PSBjaHVuay5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuaWdub3JlQnl0ZUNvdW50ID0gX3RoaXMuYm91bmRhcnlMZW5ndGggLSAoY2h1bmsubGVuZ3RoIC0gZW5kKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSkoKTtcbiAgICB9XG4gICAgY29weUV4aXN0aW5nRGF0YShpbmRleCwgZW5kKSB7XG4gICAgICAgIHJldHVybiBuZXcgKF9ibHVlYmlyZExzdDIgfHwgX2xvYWRfYmx1ZWJpcmRMc3QyKCkpLmRlZmF1bHQoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgdyA9ICgpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoaW5kZXggPT09IGVuZCkge1xuICAgICAgICAgICAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgdGFzayA9IHRoaXMub3B0aW9ucy50YXNrc1tpbmRleF07XG4gICAgICAgICAgICAgICAgaWYgKHRhc2sua2luZCAhPT0gKF9kb3dubG9hZFBsYW5CdWlsZGVyIHx8IF9sb2FkX2Rvd25sb2FkUGxhbkJ1aWxkZXIoKSkuT3BlcmF0aW9uS2luZC5DT1BZKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlamVjdChuZXcgRXJyb3IoXCJUYXNrIGtpbmQgbXVzdCBiZSBDT1BZXCIpKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb3B5RGF0YSh0YXNrLCB0aGlzLm91dCwgdGhpcy5vcHRpb25zLm9sZEZpbGVGZCwgcmVqZWN0LCAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGluZGV4Kys7XG4gICAgICAgICAgICAgICAgICAgIHcoKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB3KCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBzZWFyY2hIZWFkZXJMaXN0RW5kKGNodW5rLCByZWFkT2Zmc2V0KSB7XG4gICAgICAgIGNvbnN0IGhlYWRlckxpc3RFbmQgPSBjaHVuay5pbmRleE9mKERPVUJMRV9DUkxGLCByZWFkT2Zmc2V0KTtcbiAgICAgICAgaWYgKGhlYWRlckxpc3RFbmQgIT09IC0xKSB7XG4gICAgICAgICAgICByZXR1cm4gaGVhZGVyTGlzdEVuZCArIERPVUJMRV9DUkxGLmxlbmd0aDtcbiAgICAgICAgfVxuICAgICAgICAvLyBub3QgYWxsIGhlYWRlcnMgZGF0YSB3ZXJlIHJlY2VpdmVkLCBzYXZlIHRvIGJ1ZmZlclxuICAgICAgICBjb25zdCBwYXJ0aWFsQ2h1bmsgPSByZWFkT2Zmc2V0ID09PSAwID8gY2h1bmsgOiBjaHVuay5zbGljZShyZWFkT2Zmc2V0KTtcbiAgICAgICAgaWYgKHRoaXMuaGVhZGVyTGlzdEJ1ZmZlciA9PSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLmhlYWRlckxpc3RCdWZmZXIgPSBwYXJ0aWFsQ2h1bms7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmhlYWRlckxpc3RCdWZmZXIgPSBCdWZmZXIuY29uY2F0KFt0aGlzLmhlYWRlckxpc3RCdWZmZXIsIHBhcnRpYWxDaHVua10pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAtMTtcbiAgICB9XG4gICAgb25QYXJ0RW5kKCkge1xuICAgICAgICBjb25zdCBleHBlY3RlZExlbmd0aCA9IHRoaXMucGFydEluZGV4VG9MZW5ndGhbdGhpcy5wYXJ0SW5kZXggLSAxXTtcbiAgICAgICAgaWYgKHRoaXMuYWN0dWFsUGFydExlbmd0aCAhPT0gZXhwZWN0ZWRMZW5ndGgpIHtcbiAgICAgICAgICAgIHRocm93ICgwLCAoX2J1aWxkZXJVdGlsUnVudGltZSB8fCBfbG9hZF9idWlsZGVyVXRpbFJ1bnRpbWUoKSkubmV3RXJyb3IpKGBFeHBlY3RlZCBsZW5ndGg6ICR7ZXhwZWN0ZWRMZW5ndGh9IGRpZmZlcnMgZnJvbSBhY3R1YWw6ICR7dGhpcy5hY3R1YWxQYXJ0TGVuZ3RofWAsIFwiRVJSX0RBVEFfU1BMSVRURVJfTEVOR1RIX01JU01BVENIXCIpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuYWN0dWFsUGFydExlbmd0aCA9IDA7XG4gICAgfVxuICAgIHByb2Nlc3NQYXJ0U3RhcnRlZChkYXRhLCBzdGFydCwgZW5kKSB7XG4gICAgICAgIGlmICh0aGlzLnBhcnRJbmRleCAhPT0gMCkge1xuICAgICAgICAgICAgdGhpcy5vblBhcnRFbmQoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5wcm9jZXNzUGFydERhdGEoZGF0YSwgc3RhcnQsIGVuZCk7XG4gICAgfVxuICAgIHByb2Nlc3NQYXJ0RGF0YShkYXRhLCBzdGFydCwgZW5kKSB7XG4gICAgICAgIHRoaXMuYWN0dWFsUGFydExlbmd0aCArPSBlbmQgLSBzdGFydDtcbiAgICAgICAgY29uc3Qgb3V0ID0gdGhpcy5vdXQ7XG4gICAgICAgIGlmIChvdXQud3JpdGUoc3RhcnQgPT09IDAgJiYgZGF0YS5sZW5ndGggPT09IGVuZCA/IGRhdGEgOiBkYXRhLnNsaWNlKHN0YXJ0LCBlbmQpKSkge1xuICAgICAgICAgICAgcmV0dXJuIChfYmx1ZWJpcmRMc3QyIHx8IF9sb2FkX2JsdWViaXJkTHN0MigpKS5kZWZhdWx0LnJlc29sdmUoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgKF9ibHVlYmlyZExzdDIgfHwgX2xvYWRfYmx1ZWJpcmRMc3QyKCkpLmRlZmF1bHQoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgICAgIG91dC5vbihcImVycm9yXCIsIHJlamVjdCk7XG4gICAgICAgICAgICAgICAgb3V0Lm9uY2UoXCJkcmFpblwiLCAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIG91dC5yZW1vdmVMaXN0ZW5lcihcImVycm9yXCIsIHJlamVjdCk7XG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmUoKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxufVxuZXhwb3J0cy5EYXRhU3BsaXR0ZXIgPSBEYXRhU3BsaXR0ZXI7IC8vIyBzb3VyY2VNYXBwaW5nVVJMPURhdGFTcGxpdHRlci5qcy5tYXBcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvZWxlY3Ryb24tdXBkYXRlci9vdXQvZGlmZmVyZW50aWFsRG93bmxvYWRlci9EYXRhU3BsaXR0ZXIuanMiLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCJodHRwXCIpO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIGV4dGVybmFsIFwiaHR0cFwiXG4vLyBtb2R1bGUgaWQgPSA2N1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIndXNlIHN0cmljdCc7XG5cbi8qKlxuICogU2F2ZSBjb25zb2xlIG1ldGhvZHMgZm9yIHVzaW5nIHdoZW4gb3JpZ2luYWxzIGFyZSBvdmVycmlkZGVuXG4gKi9cbm1vZHVsZS5leHBvcnRzID0ge1xuICBjb250ZXh0OiBjb25zb2xlLFxuICBlcnJvcjogICBjb25zb2xlLmVycm9yLFxuICB3YXJuOiAgICBjb25zb2xlLndhcm4sXG4gIGluZm86ICAgIGNvbnNvbGUuaW5mbyxcbiAgdmVyYm9zZTogY29uc29sZS52ZXJib3NlLFxuICBkZWJ1ZzogICBjb25zb2xlLmRlYnVnLFxuICBzaWxseTogICBjb25zb2xlLnNpbGx5LFxuICBsb2c6ICAgICBjb25zb2xlLmxvZ1xufTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9lbGVjdHJvbi1sb2cvbGliL29yaWdpbmFsLWNvbnNvbGUuanMiLCJpbXBvcnQgeyBhcHAsIEJyb3dzZXJXaW5kb3csIGlwY01haW4gfSBmcm9tICdlbGVjdHJvbidcbmltcG9ydCBpc0RldiBmcm9tICdlbGVjdHJvbi1pcy1kZXYnXG5pbXBvcnQgeyBhdXRvVXBkYXRlciB9IGZyb20gJ2VsZWN0cm9uLXVwZGF0ZXInXG5cbmRlY2xhcmUgdmFyIF9fZGlybmFtZTogc3RyaW5nXG5sZXQgbWFpbldpbmRvdzogRWxlY3Ryb24uQnJvd3NlcldpbmRvd1xuY29uc3QgbG9nID0gcmVxdWlyZSgnZWxlY3Ryb24tbG9nJylcbmxvZy50cmFuc3BvcnRzLmZpbGUubGV2ZWwgPSAnZGVidWcnXG5cbmZ1bmN0aW9uIG9uUmVhZHkoKSB7XG4gIG1haW5XaW5kb3cgPSBuZXcgQnJvd3NlcldpbmRvdyh7XG4gICAgd2lkdGg6IDgwMCxcbiAgICBoZWlnaHQ6IDYwMCxcbiAgICB3ZWJQcmVmZXJlbmNlczoge1xuICAgICAgd2ViU2VjdXJpdHk6IGZhbHNlXG4gICAgfVxuICB9KVxuICBtYWluV2luZG93LnNldFRpdGxlKHJlcXVpcmUoJy4uL3BhY2thZ2UuanNvbicpLm5hbWUpXG5cbiAgY29uc3QgZmlsZU5hbWUgPSBgZmlsZTovLyR7X19kaXJuYW1lfS9pbmRleC5odG1sYFxuICBtYWluV2luZG93LmxvYWRVUkwoZmlsZU5hbWUpXG4gIG1haW5XaW5kb3cub24oJ2Nsb3NlJywgKCkgPT4gYXBwLnF1aXQoKSlcblxuICBpZiAoaXNEZXYpIHtcbiAgICBtYWluV2luZG93LndlYkNvbnRlbnRzLm9wZW5EZXZUb29scygpXG4gIH1cblxuICBpZiAoIWlzRGV2KSB7XG4gICAgY29uZmlndXJlQXBwVXBkYXRlKClcbiAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIHBlcmZvcm1BcHBVcGRhdGUoKVxuICAgIH0sIDUwMDApXG4gIH1cbn1cblxuYXBwLm9uKCdyZWFkeScsICgpID0+IG9uUmVhZHkoKSlcbmFwcC5vbignd2luZG93LWFsbC1jbG9zZWQnLCAoKSA9PiBhcHAucXVpdCgpKVxuYXBwLm9uKCdicm93c2VyLXdpbmRvdy1jcmVhdGVkJyxmdW5jdGlvbihfZSwgd2luZG93KSB7XG4gIHdpbmRvdy5zZXRNZW51KG51bGwpXG59KVxuXG5mdW5jdGlvbiBwZXJmb3JtQXBwVXBkYXRlKCkge1xuICBsb2cuZGVidWcoJ3NlbmRpbmcgdXBkYXRlciBjaGVja2luZy1mb3ItdXBkYXRlJylcbiAgYXV0b1VwZGF0ZXIuYXV0b0Rvd25sb2FkID0gZmFsc2VcbiAgYXV0b1VwZGF0ZXIuY2hlY2tGb3JVcGRhdGVzKClcbn1cblxuZnVuY3Rpb24gY29uZmlndXJlQXBwVXBkYXRlKCkge1xuICBhdXRvVXBkYXRlci5sb2dnZXIgPSBsb2dcblxuICBhdXRvVXBkYXRlci5vbignY2hlY2tpbmctZm9yLXVwZGF0ZScsICgpID0+IHtcbiAgICBsb2cuZGVidWcoJ3NlbmRpbmcgdXBkYXRlciBjaGVja2luZy1mb3ItdXBkYXRlJylcbiAgICBtYWluV2luZG93LndlYkNvbnRlbnRzLnNlbmQoJ3VwZGF0ZXInLCAnY2hlY2tpbmctZm9yLXVwZGF0ZScpXG4gIH0pXG4gIGF1dG9VcGRhdGVyLm9uKCd1cGRhdGUtYXZhaWxhYmxlJywgKGluZm8pID0+IHtcbiAgICBsb2cuZGVidWcoJ3NlbmRpbmcgdXBkYXRlciB1cGRhdGUtYXZhaWxhYmxlJylcbiAgICBtYWluV2luZG93LndlYkNvbnRlbnRzLnNlbmQoJ3VwZGF0ZXInLCAndXBkYXRlLWF2YWlsYWJsZScsIGluZm8pXG4gIH0pXG4gIGF1dG9VcGRhdGVyLm9uKCd1cGRhdGUtbm90LWF2YWlsYWJsZScsIChpbmZvKSA9PiB7XG4gICAgbG9nLmRlYnVnKCdzZW5kaW5nIHVwZGF0ZXIgdXBkYXRlLW5vdC1hdmFpbGFibGUnKVxuICAgIG1haW5XaW5kb3cud2ViQ29udGVudHMuc2VuZCgndXBkYXRlcicsICd1cGRhdGUtbm90LWF2YWlsYWJsZScsIGluZm8pXG4gIH0pXG4gIGF1dG9VcGRhdGVyLm9uKCdlcnJvcicsIChlcnIpID0+IHtcbiAgICBsb2cuZGVidWcoJ3NlbmRpbmcgdXBkYXRlciBlcnJvcicpXG4gICAgbWFpbldpbmRvdy53ZWJDb250ZW50cy5zZW5kKCd1cGRhdGVyJywgJ2Vycm9yJywgZXJyKVxuICB9KVxuICBhdXRvVXBkYXRlci5vbignZG93bmxvYWQtcHJvZ3Jlc3MnLCAocHJvZ3Jlc3NPYmopID0+IHtcbiAgICBsb2cuZGVidWcoJ3NlbmRpbmcgdXBkYXRlciBkb3dubG9hZC1wcm9ncmVzcycpXG4gICAgbWFpbldpbmRvdy53ZWJDb250ZW50cy5zZW5kKCd1cGRhdGVyJywgJ2Rvd25sb2FkLXByb2dyZXNzJywgcHJvZ3Jlc3NPYmopXG4gIH0pXG4gIGF1dG9VcGRhdGVyLm9uKCd1cGRhdGUtZG93bmxvYWRlZCcsIChpbmZvKSA9PiB7XG4gICAgbG9nLmRlYnVnKCdzZW5kaW5nIHVwZGF0ZXIgdXBkYXRlLWRvd25sb2FkZWQnKVxuICAgIG1haW5XaW5kb3cud2ViQ29udGVudHMuc2VuZCgndXBkYXRlcicsICd1cGRhdGUtZG93bmxvYWRlZCcsIGluZm8pXG4gIH0pXG5cbiAgaXBjTWFpbi5vbigndXBkYXRlcicsIChfZXZlbnQ6IGFueSwgdHlwZTogc3RyaW5nKSA9PiB7XG4gICAgaWYgKHR5cGUgPT09ICdkb3dubG9hZCcpIHtcbiAgICAgIGF1dG9VcGRhdGVyLmRvd25sb2FkVXBkYXRlKClcbiAgICB9XG4gICAgaWYgKHR5cGUgPT09ICdpbnN0YWxsJykge1xuICAgICAgYXV0b1VwZGF0ZXIucXVpdEFuZEluc3RhbGwoKVxuICAgIH1cbiAgfSlcbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9tYWluLnRzeCIsIlwidXNlIHN0cmljdFwiO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbigpIHtcbnZhciBtYWtlU2VsZlJlc29sdXRpb25FcnJvciA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gbmV3IFR5cGVFcnJvcihcImNpcmN1bGFyIHByb21pc2UgcmVzb2x1dGlvbiBjaGFpblxcdTAwMGFcXHUwMDBhICAgIFNlZSBodHRwOi8vZ29vLmdsL01xckZtWFxcdTAwMGFcIik7XG59O1xudmFyIHJlZmxlY3RIYW5kbGVyID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlLlByb21pc2VJbnNwZWN0aW9uKHRoaXMuX3RhcmdldCgpKTtcbn07XG52YXIgYXBpUmVqZWN0aW9uID0gZnVuY3Rpb24obXNnKSB7XG4gICAgcmV0dXJuIFByb21pc2UucmVqZWN0KG5ldyBUeXBlRXJyb3IobXNnKSk7XG59O1xuZnVuY3Rpb24gUHJveHlhYmxlKCkge31cbnZhciBVTkRFRklORURfQklORElORyA9IHt9O1xudmFyIHV0aWwgPSByZXF1aXJlKFwiLi91dGlsXCIpO1xuXG52YXIgZ2V0RG9tYWluO1xuaWYgKHV0aWwuaXNOb2RlKSB7XG4gICAgZ2V0RG9tYWluID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciByZXQgPSBwcm9jZXNzLmRvbWFpbjtcbiAgICAgICAgaWYgKHJldCA9PT0gdW5kZWZpbmVkKSByZXQgPSBudWxsO1xuICAgICAgICByZXR1cm4gcmV0O1xuICAgIH07XG59IGVsc2Uge1xuICAgIGdldERvbWFpbiA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9O1xufVxudXRpbC5ub3RFbnVtZXJhYmxlUHJvcChQcm9taXNlLCBcIl9nZXREb21haW5cIiwgZ2V0RG9tYWluKTtcblxudmFyIGVzNSA9IHJlcXVpcmUoXCIuL2VzNVwiKTtcbnZhciBBc3luYyA9IHJlcXVpcmUoXCIuL2FzeW5jXCIpO1xudmFyIGFzeW5jID0gbmV3IEFzeW5jKCk7XG5lczUuZGVmaW5lUHJvcGVydHkoUHJvbWlzZSwgXCJfYXN5bmNcIiwge3ZhbHVlOiBhc3luY30pO1xudmFyIGVycm9ycyA9IHJlcXVpcmUoXCIuL2Vycm9yc1wiKTtcbnZhciBUeXBlRXJyb3IgPSBQcm9taXNlLlR5cGVFcnJvciA9IGVycm9ycy5UeXBlRXJyb3I7XG5Qcm9taXNlLlJhbmdlRXJyb3IgPSBlcnJvcnMuUmFuZ2VFcnJvcjtcbnZhciBDYW5jZWxsYXRpb25FcnJvciA9IFByb21pc2UuQ2FuY2VsbGF0aW9uRXJyb3IgPSBlcnJvcnMuQ2FuY2VsbGF0aW9uRXJyb3I7XG5Qcm9taXNlLlRpbWVvdXRFcnJvciA9IGVycm9ycy5UaW1lb3V0RXJyb3I7XG5Qcm9taXNlLk9wZXJhdGlvbmFsRXJyb3IgPSBlcnJvcnMuT3BlcmF0aW9uYWxFcnJvcjtcblByb21pc2UuUmVqZWN0aW9uRXJyb3IgPSBlcnJvcnMuT3BlcmF0aW9uYWxFcnJvcjtcblByb21pc2UuQWdncmVnYXRlRXJyb3IgPSBlcnJvcnMuQWdncmVnYXRlRXJyb3I7XG52YXIgSU5URVJOQUwgPSBmdW5jdGlvbigpe307XG52YXIgQVBQTFkgPSB7fTtcbnZhciBORVhUX0ZJTFRFUiA9IHt9O1xudmFyIHRyeUNvbnZlcnRUb1Byb21pc2UgPSByZXF1aXJlKFwiLi90aGVuYWJsZXNcIikoUHJvbWlzZSwgSU5URVJOQUwpO1xudmFyIFByb21pc2VBcnJheSA9XG4gICAgcmVxdWlyZShcIi4vcHJvbWlzZV9hcnJheVwiKShQcm9taXNlLCBJTlRFUk5BTCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cnlDb252ZXJ0VG9Qcm9taXNlLCBhcGlSZWplY3Rpb24sIFByb3h5YWJsZSk7XG52YXIgQ29udGV4dCA9IHJlcXVpcmUoXCIuL2NvbnRleHRcIikoUHJvbWlzZSk7XG4gLypqc2hpbnQgdW51c2VkOmZhbHNlKi9cbnZhciBjcmVhdGVDb250ZXh0ID0gQ29udGV4dC5jcmVhdGU7XG52YXIgZGVidWcgPSByZXF1aXJlKFwiLi9kZWJ1Z2dhYmlsaXR5XCIpKFByb21pc2UsIENvbnRleHQpO1xudmFyIENhcHR1cmVkVHJhY2UgPSBkZWJ1Zy5DYXB0dXJlZFRyYWNlO1xudmFyIFBhc3NUaHJvdWdoSGFuZGxlckNvbnRleHQgPVxuICAgIHJlcXVpcmUoXCIuL2ZpbmFsbHlcIikoUHJvbWlzZSwgdHJ5Q29udmVydFRvUHJvbWlzZSwgTkVYVF9GSUxURVIpO1xudmFyIGNhdGNoRmlsdGVyID0gcmVxdWlyZShcIi4vY2F0Y2hfZmlsdGVyXCIpKE5FWFRfRklMVEVSKTtcbnZhciBub2RlYmFja0ZvclByb21pc2UgPSByZXF1aXJlKFwiLi9ub2RlYmFja1wiKTtcbnZhciBlcnJvck9iaiA9IHV0aWwuZXJyb3JPYmo7XG52YXIgdHJ5Q2F0Y2ggPSB1dGlsLnRyeUNhdGNoO1xuZnVuY3Rpb24gY2hlY2soc2VsZiwgZXhlY3V0b3IpIHtcbiAgICBpZiAoc2VsZiA9PSBudWxsIHx8IHNlbGYuY29uc3RydWN0b3IgIT09IFByb21pc2UpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcInRoZSBwcm9taXNlIGNvbnN0cnVjdG9yIGNhbm5vdCBiZSBpbnZva2VkIGRpcmVjdGx5XFx1MDAwYVxcdTAwMGEgICAgU2VlIGh0dHA6Ly9nb28uZ2wvTXFyRm1YXFx1MDAwYVwiKTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBleGVjdXRvciAhPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJleHBlY3RpbmcgYSBmdW5jdGlvbiBidXQgZ290IFwiICsgdXRpbC5jbGFzc1N0cmluZyhleGVjdXRvcikpO1xuICAgIH1cblxufVxuXG5mdW5jdGlvbiBQcm9taXNlKGV4ZWN1dG9yKSB7XG4gICAgaWYgKGV4ZWN1dG9yICE9PSBJTlRFUk5BTCkge1xuICAgICAgICBjaGVjayh0aGlzLCBleGVjdXRvcik7XG4gICAgfVxuICAgIHRoaXMuX2JpdEZpZWxkID0gMDtcbiAgICB0aGlzLl9mdWxmaWxsbWVudEhhbmRsZXIwID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuX3JlamVjdGlvbkhhbmRsZXIwID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuX3Byb21pc2UwID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuX3JlY2VpdmVyMCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLl9yZXNvbHZlRnJvbUV4ZWN1dG9yKGV4ZWN1dG9yKTtcbiAgICB0aGlzLl9wcm9taXNlQ3JlYXRlZCgpO1xuICAgIHRoaXMuX2ZpcmVFdmVudChcInByb21pc2VDcmVhdGVkXCIsIHRoaXMpO1xufVxuXG5Qcm9taXNlLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gXCJbb2JqZWN0IFByb21pc2VdXCI7XG59O1xuXG5Qcm9taXNlLnByb3RvdHlwZS5jYXVnaHQgPSBQcm9taXNlLnByb3RvdHlwZVtcImNhdGNoXCJdID0gZnVuY3Rpb24gKGZuKSB7XG4gICAgdmFyIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgaWYgKGxlbiA+IDEpIHtcbiAgICAgICAgdmFyIGNhdGNoSW5zdGFuY2VzID0gbmV3IEFycmF5KGxlbiAtIDEpLFxuICAgICAgICAgICAgaiA9IDAsIGk7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW4gLSAxOyArK2kpIHtcbiAgICAgICAgICAgIHZhciBpdGVtID0gYXJndW1lbnRzW2ldO1xuICAgICAgICAgICAgaWYgKHV0aWwuaXNPYmplY3QoaXRlbSkpIHtcbiAgICAgICAgICAgICAgICBjYXRjaEluc3RhbmNlc1tqKytdID0gaXRlbTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGFwaVJlamVjdGlvbihcIkNhdGNoIHN0YXRlbWVudCBwcmVkaWNhdGU6IFwiICtcbiAgICAgICAgICAgICAgICAgICAgXCJleHBlY3RpbmcgYW4gb2JqZWN0IGJ1dCBnb3QgXCIgKyB1dGlsLmNsYXNzU3RyaW5nKGl0ZW0pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjYXRjaEluc3RhbmNlcy5sZW5ndGggPSBqO1xuICAgICAgICBmbiA9IGFyZ3VtZW50c1tpXTtcbiAgICAgICAgcmV0dXJuIHRoaXMudGhlbih1bmRlZmluZWQsIGNhdGNoRmlsdGVyKGNhdGNoSW5zdGFuY2VzLCBmbiwgdGhpcykpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy50aGVuKHVuZGVmaW5lZCwgZm4pO1xufTtcblxuUHJvbWlzZS5wcm90b3R5cGUucmVmbGVjdCA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5fdGhlbihyZWZsZWN0SGFuZGxlcixcbiAgICAgICAgcmVmbGVjdEhhbmRsZXIsIHVuZGVmaW5lZCwgdGhpcywgdW5kZWZpbmVkKTtcbn07XG5cblByb21pc2UucHJvdG90eXBlLnRoZW4gPSBmdW5jdGlvbiAoZGlkRnVsZmlsbCwgZGlkUmVqZWN0KSB7XG4gICAgaWYgKGRlYnVnLndhcm5pbmdzKCkgJiYgYXJndW1lbnRzLmxlbmd0aCA+IDAgJiZcbiAgICAgICAgdHlwZW9mIGRpZEZ1bGZpbGwgIT09IFwiZnVuY3Rpb25cIiAmJlxuICAgICAgICB0eXBlb2YgZGlkUmVqZWN0ICE9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgdmFyIG1zZyA9IFwiLnRoZW4oKSBvbmx5IGFjY2VwdHMgZnVuY3Rpb25zIGJ1dCB3YXMgcGFzc2VkOiBcIiArXG4gICAgICAgICAgICAgICAgdXRpbC5jbGFzc1N0cmluZyhkaWRGdWxmaWxsKTtcbiAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICBtc2cgKz0gXCIsIFwiICsgdXRpbC5jbGFzc1N0cmluZyhkaWRSZWplY3QpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3dhcm4obXNnKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX3RoZW4oZGlkRnVsZmlsbCwgZGlkUmVqZWN0LCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgdW5kZWZpbmVkKTtcbn07XG5cblByb21pc2UucHJvdG90eXBlLmRvbmUgPSBmdW5jdGlvbiAoZGlkRnVsZmlsbCwgZGlkUmVqZWN0KSB7XG4gICAgdmFyIHByb21pc2UgPVxuICAgICAgICB0aGlzLl90aGVuKGRpZEZ1bGZpbGwsIGRpZFJlamVjdCwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIHVuZGVmaW5lZCk7XG4gICAgcHJvbWlzZS5fc2V0SXNGaW5hbCgpO1xufTtcblxuUHJvbWlzZS5wcm90b3R5cGUuc3ByZWFkID0gZnVuY3Rpb24gKGZuKSB7XG4gICAgaWYgKHR5cGVvZiBmbiAhPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIHJldHVybiBhcGlSZWplY3Rpb24oXCJleHBlY3RpbmcgYSBmdW5jdGlvbiBidXQgZ290IFwiICsgdXRpbC5jbGFzc1N0cmluZyhmbikpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5hbGwoKS5fdGhlbihmbiwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIEFQUExZLCB1bmRlZmluZWQpO1xufTtcblxuUHJvbWlzZS5wcm90b3R5cGUudG9KU09OID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciByZXQgPSB7XG4gICAgICAgIGlzRnVsZmlsbGVkOiBmYWxzZSxcbiAgICAgICAgaXNSZWplY3RlZDogZmFsc2UsXG4gICAgICAgIGZ1bGZpbGxtZW50VmFsdWU6IHVuZGVmaW5lZCxcbiAgICAgICAgcmVqZWN0aW9uUmVhc29uOiB1bmRlZmluZWRcbiAgICB9O1xuICAgIGlmICh0aGlzLmlzRnVsZmlsbGVkKCkpIHtcbiAgICAgICAgcmV0LmZ1bGZpbGxtZW50VmFsdWUgPSB0aGlzLnZhbHVlKCk7XG4gICAgICAgIHJldC5pc0Z1bGZpbGxlZCA9IHRydWU7XG4gICAgfSBlbHNlIGlmICh0aGlzLmlzUmVqZWN0ZWQoKSkge1xuICAgICAgICByZXQucmVqZWN0aW9uUmVhc29uID0gdGhpcy5yZWFzb24oKTtcbiAgICAgICAgcmV0LmlzUmVqZWN0ZWQgPSB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gcmV0O1xufTtcblxuUHJvbWlzZS5wcm90b3R5cGUuYWxsID0gZnVuY3Rpb24gKCkge1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMCkge1xuICAgICAgICB0aGlzLl93YXJuKFwiLmFsbCgpIHdhcyBwYXNzZWQgYXJndW1lbnRzIGJ1dCBpdCBkb2VzIG5vdCB0YWtlIGFueVwiKTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlQXJyYXkodGhpcykucHJvbWlzZSgpO1xufTtcblxuUHJvbWlzZS5wcm90b3R5cGUuZXJyb3IgPSBmdW5jdGlvbiAoZm4pIHtcbiAgICByZXR1cm4gdGhpcy5jYXVnaHQodXRpbC5vcmlnaW5hdGVzRnJvbVJlamVjdGlvbiwgZm4pO1xufTtcblxuUHJvbWlzZS5nZXROZXdMaWJyYXJ5Q29weSA9IG1vZHVsZS5leHBvcnRzO1xuXG5Qcm9taXNlLmlzID0gZnVuY3Rpb24gKHZhbCkge1xuICAgIHJldHVybiB2YWwgaW5zdGFuY2VvZiBQcm9taXNlO1xufTtcblxuUHJvbWlzZS5mcm9tTm9kZSA9IFByb21pc2UuZnJvbUNhbGxiYWNrID0gZnVuY3Rpb24oZm4pIHtcbiAgICB2YXIgcmV0ID0gbmV3IFByb21pc2UoSU5URVJOQUwpO1xuICAgIHJldC5fY2FwdHVyZVN0YWNrVHJhY2UoKTtcbiAgICB2YXIgbXVsdGlBcmdzID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgPyAhIU9iamVjdChhcmd1bWVudHNbMV0pLm11bHRpQXJnc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IGZhbHNlO1xuICAgIHZhciByZXN1bHQgPSB0cnlDYXRjaChmbikobm9kZWJhY2tGb3JQcm9taXNlKHJldCwgbXVsdGlBcmdzKSk7XG4gICAgaWYgKHJlc3VsdCA9PT0gZXJyb3JPYmopIHtcbiAgICAgICAgcmV0Ll9yZWplY3RDYWxsYmFjayhyZXN1bHQuZSwgdHJ1ZSk7XG4gICAgfVxuICAgIGlmICghcmV0Ll9pc0ZhdGVTZWFsZWQoKSkgcmV0Ll9zZXRBc3luY0d1YXJhbnRlZWQoKTtcbiAgICByZXR1cm4gcmV0O1xufTtcblxuUHJvbWlzZS5hbGwgPSBmdW5jdGlvbiAocHJvbWlzZXMpIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2VBcnJheShwcm9taXNlcykucHJvbWlzZSgpO1xufTtcblxuUHJvbWlzZS5jYXN0ID0gZnVuY3Rpb24gKG9iaikge1xuICAgIHZhciByZXQgPSB0cnlDb252ZXJ0VG9Qcm9taXNlKG9iaik7XG4gICAgaWYgKCEocmV0IGluc3RhbmNlb2YgUHJvbWlzZSkpIHtcbiAgICAgICAgcmV0ID0gbmV3IFByb21pc2UoSU5URVJOQUwpO1xuICAgICAgICByZXQuX2NhcHR1cmVTdGFja1RyYWNlKCk7XG4gICAgICAgIHJldC5fc2V0RnVsZmlsbGVkKCk7XG4gICAgICAgIHJldC5fcmVqZWN0aW9uSGFuZGxlcjAgPSBvYmo7XG4gICAgfVxuICAgIHJldHVybiByZXQ7XG59O1xuXG5Qcm9taXNlLnJlc29sdmUgPSBQcm9taXNlLmZ1bGZpbGxlZCA9IFByb21pc2UuY2FzdDtcblxuUHJvbWlzZS5yZWplY3QgPSBQcm9taXNlLnJlamVjdGVkID0gZnVuY3Rpb24gKHJlYXNvbikge1xuICAgIHZhciByZXQgPSBuZXcgUHJvbWlzZShJTlRFUk5BTCk7XG4gICAgcmV0Ll9jYXB0dXJlU3RhY2tUcmFjZSgpO1xuICAgIHJldC5fcmVqZWN0Q2FsbGJhY2socmVhc29uLCB0cnVlKTtcbiAgICByZXR1cm4gcmV0O1xufTtcblxuUHJvbWlzZS5zZXRTY2hlZHVsZXIgPSBmdW5jdGlvbihmbikge1xuICAgIGlmICh0eXBlb2YgZm4gIT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiZXhwZWN0aW5nIGEgZnVuY3Rpb24gYnV0IGdvdCBcIiArIHV0aWwuY2xhc3NTdHJpbmcoZm4pKTtcbiAgICB9XG4gICAgcmV0dXJuIGFzeW5jLnNldFNjaGVkdWxlcihmbik7XG59O1xuXG5Qcm9taXNlLnByb3RvdHlwZS5fdGhlbiA9IGZ1bmN0aW9uIChcbiAgICBkaWRGdWxmaWxsLFxuICAgIGRpZFJlamVjdCxcbiAgICBfLCAgICByZWNlaXZlcixcbiAgICBpbnRlcm5hbERhdGFcbikge1xuICAgIHZhciBoYXZlSW50ZXJuYWxEYXRhID0gaW50ZXJuYWxEYXRhICE9PSB1bmRlZmluZWQ7XG4gICAgdmFyIHByb21pc2UgPSBoYXZlSW50ZXJuYWxEYXRhID8gaW50ZXJuYWxEYXRhIDogbmV3IFByb21pc2UoSU5URVJOQUwpO1xuICAgIHZhciB0YXJnZXQgPSB0aGlzLl90YXJnZXQoKTtcbiAgICB2YXIgYml0RmllbGQgPSB0YXJnZXQuX2JpdEZpZWxkO1xuXG4gICAgaWYgKCFoYXZlSW50ZXJuYWxEYXRhKSB7XG4gICAgICAgIHByb21pc2UuX3Byb3BhZ2F0ZUZyb20odGhpcywgMyk7XG4gICAgICAgIHByb21pc2UuX2NhcHR1cmVTdGFja1RyYWNlKCk7XG4gICAgICAgIGlmIChyZWNlaXZlciA9PT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICAoKHRoaXMuX2JpdEZpZWxkICYgMjA5NzE1MikgIT09IDApKSB7XG4gICAgICAgICAgICBpZiAoISgoYml0RmllbGQgJiA1MDM5NzE4NCkgPT09IDApKSB7XG4gICAgICAgICAgICAgICAgcmVjZWl2ZXIgPSB0aGlzLl9ib3VuZFZhbHVlKCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJlY2VpdmVyID0gdGFyZ2V0ID09PSB0aGlzID8gdW5kZWZpbmVkIDogdGhpcy5fYm91bmRUbztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9maXJlRXZlbnQoXCJwcm9taXNlQ2hhaW5lZFwiLCB0aGlzLCBwcm9taXNlKTtcbiAgICB9XG5cbiAgICB2YXIgZG9tYWluID0gZ2V0RG9tYWluKCk7XG4gICAgaWYgKCEoKGJpdEZpZWxkICYgNTAzOTcxODQpID09PSAwKSkge1xuICAgICAgICB2YXIgaGFuZGxlciwgdmFsdWUsIHNldHRsZXIgPSB0YXJnZXQuX3NldHRsZVByb21pc2VDdHg7XG4gICAgICAgIGlmICgoKGJpdEZpZWxkICYgMzM1NTQ0MzIpICE9PSAwKSkge1xuICAgICAgICAgICAgdmFsdWUgPSB0YXJnZXQuX3JlamVjdGlvbkhhbmRsZXIwO1xuICAgICAgICAgICAgaGFuZGxlciA9IGRpZEZ1bGZpbGw7XG4gICAgICAgIH0gZWxzZSBpZiAoKChiaXRGaWVsZCAmIDE2Nzc3MjE2KSAhPT0gMCkpIHtcbiAgICAgICAgICAgIHZhbHVlID0gdGFyZ2V0Ll9mdWxmaWxsbWVudEhhbmRsZXIwO1xuICAgICAgICAgICAgaGFuZGxlciA9IGRpZFJlamVjdDtcbiAgICAgICAgICAgIHRhcmdldC5fdW5zZXRSZWplY3Rpb25Jc1VuaGFuZGxlZCgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc2V0dGxlciA9IHRhcmdldC5fc2V0dGxlUHJvbWlzZUxhdGVDYW5jZWxsYXRpb25PYnNlcnZlcjtcbiAgICAgICAgICAgIHZhbHVlID0gbmV3IENhbmNlbGxhdGlvbkVycm9yKFwibGF0ZSBjYW5jZWxsYXRpb24gb2JzZXJ2ZXJcIik7XG4gICAgICAgICAgICB0YXJnZXQuX2F0dGFjaEV4dHJhVHJhY2UodmFsdWUpO1xuICAgICAgICAgICAgaGFuZGxlciA9IGRpZFJlamVjdDtcbiAgICAgICAgfVxuXG4gICAgICAgIGFzeW5jLmludm9rZShzZXR0bGVyLCB0YXJnZXQsIHtcbiAgICAgICAgICAgIGhhbmRsZXI6IGRvbWFpbiA9PT0gbnVsbCA/IGhhbmRsZXJcbiAgICAgICAgICAgICAgICA6ICh0eXBlb2YgaGFuZGxlciA9PT0gXCJmdW5jdGlvblwiICYmXG4gICAgICAgICAgICAgICAgICAgIHV0aWwuZG9tYWluQmluZChkb21haW4sIGhhbmRsZXIpKSxcbiAgICAgICAgICAgIHByb21pc2U6IHByb21pc2UsXG4gICAgICAgICAgICByZWNlaXZlcjogcmVjZWl2ZXIsXG4gICAgICAgICAgICB2YWx1ZTogdmFsdWVcbiAgICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdGFyZ2V0Ll9hZGRDYWxsYmFja3MoZGlkRnVsZmlsbCwgZGlkUmVqZWN0LCBwcm9taXNlLCByZWNlaXZlciwgZG9tYWluKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcHJvbWlzZTtcbn07XG5cblByb21pc2UucHJvdG90eXBlLl9sZW5ndGggPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2JpdEZpZWxkICYgNjU1MzU7XG59O1xuXG5Qcm9taXNlLnByb3RvdHlwZS5faXNGYXRlU2VhbGVkID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiAodGhpcy5fYml0RmllbGQgJiAxMTc1MDYwNDgpICE9PSAwO1xufTtcblxuUHJvbWlzZS5wcm90b3R5cGUuX2lzRm9sbG93aW5nID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiAodGhpcy5fYml0RmllbGQgJiA2NzEwODg2NCkgPT09IDY3MTA4ODY0O1xufTtcblxuUHJvbWlzZS5wcm90b3R5cGUuX3NldExlbmd0aCA9IGZ1bmN0aW9uIChsZW4pIHtcbiAgICB0aGlzLl9iaXRGaWVsZCA9ICh0aGlzLl9iaXRGaWVsZCAmIC02NTUzNikgfFxuICAgICAgICAobGVuICYgNjU1MzUpO1xufTtcblxuUHJvbWlzZS5wcm90b3R5cGUuX3NldEZ1bGZpbGxlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLl9iaXRGaWVsZCA9IHRoaXMuX2JpdEZpZWxkIHwgMzM1NTQ0MzI7XG4gICAgdGhpcy5fZmlyZUV2ZW50KFwicHJvbWlzZUZ1bGZpbGxlZFwiLCB0aGlzKTtcbn07XG5cblByb21pc2UucHJvdG90eXBlLl9zZXRSZWplY3RlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLl9iaXRGaWVsZCA9IHRoaXMuX2JpdEZpZWxkIHwgMTY3NzcyMTY7XG4gICAgdGhpcy5fZmlyZUV2ZW50KFwicHJvbWlzZVJlamVjdGVkXCIsIHRoaXMpO1xufTtcblxuUHJvbWlzZS5wcm90b3R5cGUuX3NldEZvbGxvd2luZyA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLl9iaXRGaWVsZCA9IHRoaXMuX2JpdEZpZWxkIHwgNjcxMDg4NjQ7XG4gICAgdGhpcy5fZmlyZUV2ZW50KFwicHJvbWlzZVJlc29sdmVkXCIsIHRoaXMpO1xufTtcblxuUHJvbWlzZS5wcm90b3R5cGUuX3NldElzRmluYWwgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5fYml0RmllbGQgPSB0aGlzLl9iaXRGaWVsZCB8IDQxOTQzMDQ7XG59O1xuXG5Qcm9taXNlLnByb3RvdHlwZS5faXNGaW5hbCA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gKHRoaXMuX2JpdEZpZWxkICYgNDE5NDMwNCkgPiAwO1xufTtcblxuUHJvbWlzZS5wcm90b3R5cGUuX3Vuc2V0Q2FuY2VsbGVkID0gZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5fYml0RmllbGQgPSB0aGlzLl9iaXRGaWVsZCAmICh+NjU1MzYpO1xufTtcblxuUHJvbWlzZS5wcm90b3R5cGUuX3NldENhbmNlbGxlZCA9IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuX2JpdEZpZWxkID0gdGhpcy5fYml0RmllbGQgfCA2NTUzNjtcbiAgICB0aGlzLl9maXJlRXZlbnQoXCJwcm9taXNlQ2FuY2VsbGVkXCIsIHRoaXMpO1xufTtcblxuUHJvbWlzZS5wcm90b3R5cGUuX3NldFdpbGxCZUNhbmNlbGxlZCA9IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuX2JpdEZpZWxkID0gdGhpcy5fYml0RmllbGQgfCA4Mzg4NjA4O1xufTtcblxuUHJvbWlzZS5wcm90b3R5cGUuX3NldEFzeW5jR3VhcmFudGVlZCA9IGZ1bmN0aW9uKCkge1xuICAgIGlmIChhc3luYy5oYXNDdXN0b21TY2hlZHVsZXIoKSkgcmV0dXJuO1xuICAgIHRoaXMuX2JpdEZpZWxkID0gdGhpcy5fYml0RmllbGQgfCAxMzQyMTc3Mjg7XG59O1xuXG5Qcm9taXNlLnByb3RvdHlwZS5fcmVjZWl2ZXJBdCA9IGZ1bmN0aW9uIChpbmRleCkge1xuICAgIHZhciByZXQgPSBpbmRleCA9PT0gMCA/IHRoaXMuX3JlY2VpdmVyMCA6IHRoaXNbXG4gICAgICAgICAgICBpbmRleCAqIDQgLSA0ICsgM107XG4gICAgaWYgKHJldCA9PT0gVU5ERUZJTkVEX0JJTkRJTkcpIHtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9IGVsc2UgaWYgKHJldCA9PT0gdW5kZWZpbmVkICYmIHRoaXMuX2lzQm91bmQoKSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fYm91bmRWYWx1ZSgpO1xuICAgIH1cbiAgICByZXR1cm4gcmV0O1xufTtcblxuUHJvbWlzZS5wcm90b3R5cGUuX3Byb21pc2VBdCA9IGZ1bmN0aW9uIChpbmRleCkge1xuICAgIHJldHVybiB0aGlzW1xuICAgICAgICAgICAgaW5kZXggKiA0IC0gNCArIDJdO1xufTtcblxuUHJvbWlzZS5wcm90b3R5cGUuX2Z1bGZpbGxtZW50SGFuZGxlckF0ID0gZnVuY3Rpb24gKGluZGV4KSB7XG4gICAgcmV0dXJuIHRoaXNbXG4gICAgICAgICAgICBpbmRleCAqIDQgLSA0ICsgMF07XG59O1xuXG5Qcm9taXNlLnByb3RvdHlwZS5fcmVqZWN0aW9uSGFuZGxlckF0ID0gZnVuY3Rpb24gKGluZGV4KSB7XG4gICAgcmV0dXJuIHRoaXNbXG4gICAgICAgICAgICBpbmRleCAqIDQgLSA0ICsgMV07XG59O1xuXG5Qcm9taXNlLnByb3RvdHlwZS5fYm91bmRWYWx1ZSA9IGZ1bmN0aW9uKCkge307XG5cblByb21pc2UucHJvdG90eXBlLl9taWdyYXRlQ2FsbGJhY2swID0gZnVuY3Rpb24gKGZvbGxvd2VyKSB7XG4gICAgdmFyIGJpdEZpZWxkID0gZm9sbG93ZXIuX2JpdEZpZWxkO1xuICAgIHZhciBmdWxmaWxsID0gZm9sbG93ZXIuX2Z1bGZpbGxtZW50SGFuZGxlcjA7XG4gICAgdmFyIHJlamVjdCA9IGZvbGxvd2VyLl9yZWplY3Rpb25IYW5kbGVyMDtcbiAgICB2YXIgcHJvbWlzZSA9IGZvbGxvd2VyLl9wcm9taXNlMDtcbiAgICB2YXIgcmVjZWl2ZXIgPSBmb2xsb3dlci5fcmVjZWl2ZXJBdCgwKTtcbiAgICBpZiAocmVjZWl2ZXIgPT09IHVuZGVmaW5lZCkgcmVjZWl2ZXIgPSBVTkRFRklORURfQklORElORztcbiAgICB0aGlzLl9hZGRDYWxsYmFja3MoZnVsZmlsbCwgcmVqZWN0LCBwcm9taXNlLCByZWNlaXZlciwgbnVsbCk7XG59O1xuXG5Qcm9taXNlLnByb3RvdHlwZS5fbWlncmF0ZUNhbGxiYWNrQXQgPSBmdW5jdGlvbiAoZm9sbG93ZXIsIGluZGV4KSB7XG4gICAgdmFyIGZ1bGZpbGwgPSBmb2xsb3dlci5fZnVsZmlsbG1lbnRIYW5kbGVyQXQoaW5kZXgpO1xuICAgIHZhciByZWplY3QgPSBmb2xsb3dlci5fcmVqZWN0aW9uSGFuZGxlckF0KGluZGV4KTtcbiAgICB2YXIgcHJvbWlzZSA9IGZvbGxvd2VyLl9wcm9taXNlQXQoaW5kZXgpO1xuICAgIHZhciByZWNlaXZlciA9IGZvbGxvd2VyLl9yZWNlaXZlckF0KGluZGV4KTtcbiAgICBpZiAocmVjZWl2ZXIgPT09IHVuZGVmaW5lZCkgcmVjZWl2ZXIgPSBVTkRFRklORURfQklORElORztcbiAgICB0aGlzLl9hZGRDYWxsYmFja3MoZnVsZmlsbCwgcmVqZWN0LCBwcm9taXNlLCByZWNlaXZlciwgbnVsbCk7XG59O1xuXG5Qcm9taXNlLnByb3RvdHlwZS5fYWRkQ2FsbGJhY2tzID0gZnVuY3Rpb24gKFxuICAgIGZ1bGZpbGwsXG4gICAgcmVqZWN0LFxuICAgIHByb21pc2UsXG4gICAgcmVjZWl2ZXIsXG4gICAgZG9tYWluXG4pIHtcbiAgICB2YXIgaW5kZXggPSB0aGlzLl9sZW5ndGgoKTtcblxuICAgIGlmIChpbmRleCA+PSA2NTUzNSAtIDQpIHtcbiAgICAgICAgaW5kZXggPSAwO1xuICAgICAgICB0aGlzLl9zZXRMZW5ndGgoMCk7XG4gICAgfVxuXG4gICAgaWYgKGluZGV4ID09PSAwKSB7XG4gICAgICAgIHRoaXMuX3Byb21pc2UwID0gcHJvbWlzZTtcbiAgICAgICAgdGhpcy5fcmVjZWl2ZXIwID0gcmVjZWl2ZXI7XG4gICAgICAgIGlmICh0eXBlb2YgZnVsZmlsbCA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICB0aGlzLl9mdWxmaWxsbWVudEhhbmRsZXIwID1cbiAgICAgICAgICAgICAgICBkb21haW4gPT09IG51bGwgPyBmdWxmaWxsIDogdXRpbC5kb21haW5CaW5kKGRvbWFpbiwgZnVsZmlsbCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiByZWplY3QgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgdGhpcy5fcmVqZWN0aW9uSGFuZGxlcjAgPVxuICAgICAgICAgICAgICAgIGRvbWFpbiA9PT0gbnVsbCA/IHJlamVjdCA6IHV0aWwuZG9tYWluQmluZChkb21haW4sIHJlamVjdCk7XG4gICAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgYmFzZSA9IGluZGV4ICogNCAtIDQ7XG4gICAgICAgIHRoaXNbYmFzZSArIDJdID0gcHJvbWlzZTtcbiAgICAgICAgdGhpc1tiYXNlICsgM10gPSByZWNlaXZlcjtcbiAgICAgICAgaWYgKHR5cGVvZiBmdWxmaWxsID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgIHRoaXNbYmFzZSArIDBdID1cbiAgICAgICAgICAgICAgICBkb21haW4gPT09IG51bGwgPyBmdWxmaWxsIDogdXRpbC5kb21haW5CaW5kKGRvbWFpbiwgZnVsZmlsbCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiByZWplY3QgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgdGhpc1tiYXNlICsgMV0gPVxuICAgICAgICAgICAgICAgIGRvbWFpbiA9PT0gbnVsbCA/IHJlamVjdCA6IHV0aWwuZG9tYWluQmluZChkb21haW4sIHJlamVjdCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5fc2V0TGVuZ3RoKGluZGV4ICsgMSk7XG4gICAgcmV0dXJuIGluZGV4O1xufTtcblxuUHJvbWlzZS5wcm90b3R5cGUuX3Byb3h5ID0gZnVuY3Rpb24gKHByb3h5YWJsZSwgYXJnKSB7XG4gICAgdGhpcy5fYWRkQ2FsbGJhY2tzKHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBhcmcsIHByb3h5YWJsZSwgbnVsbCk7XG59O1xuXG5Qcm9taXNlLnByb3RvdHlwZS5fcmVzb2x2ZUNhbGxiYWNrID0gZnVuY3Rpb24odmFsdWUsIHNob3VsZEJpbmQpIHtcbiAgICBpZiAoKCh0aGlzLl9iaXRGaWVsZCAmIDExNzUwNjA0OCkgIT09IDApKSByZXR1cm47XG4gICAgaWYgKHZhbHVlID09PSB0aGlzKVxuICAgICAgICByZXR1cm4gdGhpcy5fcmVqZWN0Q2FsbGJhY2sobWFrZVNlbGZSZXNvbHV0aW9uRXJyb3IoKSwgZmFsc2UpO1xuICAgIHZhciBtYXliZVByb21pc2UgPSB0cnlDb252ZXJ0VG9Qcm9taXNlKHZhbHVlLCB0aGlzKTtcbiAgICBpZiAoIShtYXliZVByb21pc2UgaW5zdGFuY2VvZiBQcm9taXNlKSkgcmV0dXJuIHRoaXMuX2Z1bGZpbGwodmFsdWUpO1xuXG4gICAgaWYgKHNob3VsZEJpbmQpIHRoaXMuX3Byb3BhZ2F0ZUZyb20obWF5YmVQcm9taXNlLCAyKTtcblxuICAgIHZhciBwcm9taXNlID0gbWF5YmVQcm9taXNlLl90YXJnZXQoKTtcblxuICAgIGlmIChwcm9taXNlID09PSB0aGlzKSB7XG4gICAgICAgIHRoaXMuX3JlamVjdChtYWtlU2VsZlJlc29sdXRpb25FcnJvcigpKTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBiaXRGaWVsZCA9IHByb21pc2UuX2JpdEZpZWxkO1xuICAgIGlmICgoKGJpdEZpZWxkICYgNTAzOTcxODQpID09PSAwKSkge1xuICAgICAgICB2YXIgbGVuID0gdGhpcy5fbGVuZ3RoKCk7XG4gICAgICAgIGlmIChsZW4gPiAwKSBwcm9taXNlLl9taWdyYXRlQ2FsbGJhY2swKHRoaXMpO1xuICAgICAgICBmb3IgKHZhciBpID0gMTsgaSA8IGxlbjsgKytpKSB7XG4gICAgICAgICAgICBwcm9taXNlLl9taWdyYXRlQ2FsbGJhY2tBdCh0aGlzLCBpKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9zZXRGb2xsb3dpbmcoKTtcbiAgICAgICAgdGhpcy5fc2V0TGVuZ3RoKDApO1xuICAgICAgICB0aGlzLl9zZXRGb2xsb3dlZShwcm9taXNlKTtcbiAgICB9IGVsc2UgaWYgKCgoYml0RmllbGQgJiAzMzU1NDQzMikgIT09IDApKSB7XG4gICAgICAgIHRoaXMuX2Z1bGZpbGwocHJvbWlzZS5fdmFsdWUoKSk7XG4gICAgfSBlbHNlIGlmICgoKGJpdEZpZWxkICYgMTY3NzcyMTYpICE9PSAwKSkge1xuICAgICAgICB0aGlzLl9yZWplY3QocHJvbWlzZS5fcmVhc29uKCkpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciByZWFzb24gPSBuZXcgQ2FuY2VsbGF0aW9uRXJyb3IoXCJsYXRlIGNhbmNlbGxhdGlvbiBvYnNlcnZlclwiKTtcbiAgICAgICAgcHJvbWlzZS5fYXR0YWNoRXh0cmFUcmFjZShyZWFzb24pO1xuICAgICAgICB0aGlzLl9yZWplY3QocmVhc29uKTtcbiAgICB9XG59O1xuXG5Qcm9taXNlLnByb3RvdHlwZS5fcmVqZWN0Q2FsbGJhY2sgPVxuZnVuY3Rpb24ocmVhc29uLCBzeW5jaHJvbm91cywgaWdub3JlTm9uRXJyb3JXYXJuaW5ncykge1xuICAgIHZhciB0cmFjZSA9IHV0aWwuZW5zdXJlRXJyb3JPYmplY3QocmVhc29uKTtcbiAgICB2YXIgaGFzU3RhY2sgPSB0cmFjZSA9PT0gcmVhc29uO1xuICAgIGlmICghaGFzU3RhY2sgJiYgIWlnbm9yZU5vbkVycm9yV2FybmluZ3MgJiYgZGVidWcud2FybmluZ3MoKSkge1xuICAgICAgICB2YXIgbWVzc2FnZSA9IFwiYSBwcm9taXNlIHdhcyByZWplY3RlZCB3aXRoIGEgbm9uLWVycm9yOiBcIiArXG4gICAgICAgICAgICB1dGlsLmNsYXNzU3RyaW5nKHJlYXNvbik7XG4gICAgICAgIHRoaXMuX3dhcm4obWVzc2FnZSwgdHJ1ZSk7XG4gICAgfVxuICAgIHRoaXMuX2F0dGFjaEV4dHJhVHJhY2UodHJhY2UsIHN5bmNocm9ub3VzID8gaGFzU3RhY2sgOiBmYWxzZSk7XG4gICAgdGhpcy5fcmVqZWN0KHJlYXNvbik7XG59O1xuXG5Qcm9taXNlLnByb3RvdHlwZS5fcmVzb2x2ZUZyb21FeGVjdXRvciA9IGZ1bmN0aW9uIChleGVjdXRvcikge1xuICAgIGlmIChleGVjdXRvciA9PT0gSU5URVJOQUwpIHJldHVybjtcbiAgICB2YXIgcHJvbWlzZSA9IHRoaXM7XG4gICAgdGhpcy5fY2FwdHVyZVN0YWNrVHJhY2UoKTtcbiAgICB0aGlzLl9wdXNoQ29udGV4dCgpO1xuICAgIHZhciBzeW5jaHJvbm91cyA9IHRydWU7XG4gICAgdmFyIHIgPSB0aGlzLl9leGVjdXRlKGV4ZWN1dG9yLCBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICBwcm9taXNlLl9yZXNvbHZlQ2FsbGJhY2sodmFsdWUpO1xuICAgIH0sIGZ1bmN0aW9uIChyZWFzb24pIHtcbiAgICAgICAgcHJvbWlzZS5fcmVqZWN0Q2FsbGJhY2socmVhc29uLCBzeW5jaHJvbm91cyk7XG4gICAgfSk7XG4gICAgc3luY2hyb25vdXMgPSBmYWxzZTtcbiAgICB0aGlzLl9wb3BDb250ZXh0KCk7XG5cbiAgICBpZiAociAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHByb21pc2UuX3JlamVjdENhbGxiYWNrKHIsIHRydWUpO1xuICAgIH1cbn07XG5cblByb21pc2UucHJvdG90eXBlLl9zZXR0bGVQcm9taXNlRnJvbUhhbmRsZXIgPSBmdW5jdGlvbiAoXG4gICAgaGFuZGxlciwgcmVjZWl2ZXIsIHZhbHVlLCBwcm9taXNlXG4pIHtcbiAgICB2YXIgYml0RmllbGQgPSBwcm9taXNlLl9iaXRGaWVsZDtcbiAgICBpZiAoKChiaXRGaWVsZCAmIDY1NTM2KSAhPT0gMCkpIHJldHVybjtcbiAgICBwcm9taXNlLl9wdXNoQ29udGV4dCgpO1xuICAgIHZhciB4O1xuICAgIGlmIChyZWNlaXZlciA9PT0gQVBQTFkpIHtcbiAgICAgICAgaWYgKCF2YWx1ZSB8fCB0eXBlb2YgdmFsdWUubGVuZ3RoICE9PSBcIm51bWJlclwiKSB7XG4gICAgICAgICAgICB4ID0gZXJyb3JPYmo7XG4gICAgICAgICAgICB4LmUgPSBuZXcgVHlwZUVycm9yKFwiY2Fubm90IC5zcHJlYWQoKSBhIG5vbi1hcnJheTogXCIgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdXRpbC5jbGFzc1N0cmluZyh2YWx1ZSkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgeCA9IHRyeUNhdGNoKGhhbmRsZXIpLmFwcGx5KHRoaXMuX2JvdW5kVmFsdWUoKSwgdmFsdWUpO1xuICAgICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgICAgeCA9IHRyeUNhdGNoKGhhbmRsZXIpLmNhbGwocmVjZWl2ZXIsIHZhbHVlKTtcbiAgICB9XG4gICAgdmFyIHByb21pc2VDcmVhdGVkID0gcHJvbWlzZS5fcG9wQ29udGV4dCgpO1xuICAgIGJpdEZpZWxkID0gcHJvbWlzZS5fYml0RmllbGQ7XG4gICAgaWYgKCgoYml0RmllbGQgJiA2NTUzNikgIT09IDApKSByZXR1cm47XG5cbiAgICBpZiAoeCA9PT0gTkVYVF9GSUxURVIpIHtcbiAgICAgICAgcHJvbWlzZS5fcmVqZWN0KHZhbHVlKTtcbiAgICB9IGVsc2UgaWYgKHggPT09IGVycm9yT2JqKSB7XG4gICAgICAgIHByb21pc2UuX3JlamVjdENhbGxiYWNrKHguZSwgZmFsc2UpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGRlYnVnLmNoZWNrRm9yZ290dGVuUmV0dXJucyh4LCBwcm9taXNlQ3JlYXRlZCwgXCJcIiwgIHByb21pc2UsIHRoaXMpO1xuICAgICAgICBwcm9taXNlLl9yZXNvbHZlQ2FsbGJhY2soeCk7XG4gICAgfVxufTtcblxuUHJvbWlzZS5wcm90b3R5cGUuX3RhcmdldCA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciByZXQgPSB0aGlzO1xuICAgIHdoaWxlIChyZXQuX2lzRm9sbG93aW5nKCkpIHJldCA9IHJldC5fZm9sbG93ZWUoKTtcbiAgICByZXR1cm4gcmV0O1xufTtcblxuUHJvbWlzZS5wcm90b3R5cGUuX2ZvbGxvd2VlID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuX3JlamVjdGlvbkhhbmRsZXIwO1xufTtcblxuUHJvbWlzZS5wcm90b3R5cGUuX3NldEZvbGxvd2VlID0gZnVuY3Rpb24ocHJvbWlzZSkge1xuICAgIHRoaXMuX3JlamVjdGlvbkhhbmRsZXIwID0gcHJvbWlzZTtcbn07XG5cblByb21pc2UucHJvdG90eXBlLl9zZXR0bGVQcm9taXNlID0gZnVuY3Rpb24ocHJvbWlzZSwgaGFuZGxlciwgcmVjZWl2ZXIsIHZhbHVlKSB7XG4gICAgdmFyIGlzUHJvbWlzZSA9IHByb21pc2UgaW5zdGFuY2VvZiBQcm9taXNlO1xuICAgIHZhciBiaXRGaWVsZCA9IHRoaXMuX2JpdEZpZWxkO1xuICAgIHZhciBhc3luY0d1YXJhbnRlZWQgPSAoKGJpdEZpZWxkICYgMTM0MjE3NzI4KSAhPT0gMCk7XG4gICAgaWYgKCgoYml0RmllbGQgJiA2NTUzNikgIT09IDApKSB7XG4gICAgICAgIGlmIChpc1Byb21pc2UpIHByb21pc2UuX2ludm9rZUludGVybmFsT25DYW5jZWwoKTtcblxuICAgICAgICBpZiAocmVjZWl2ZXIgaW5zdGFuY2VvZiBQYXNzVGhyb3VnaEhhbmRsZXJDb250ZXh0ICYmXG4gICAgICAgICAgICByZWNlaXZlci5pc0ZpbmFsbHlIYW5kbGVyKCkpIHtcbiAgICAgICAgICAgIHJlY2VpdmVyLmNhbmNlbFByb21pc2UgPSBwcm9taXNlO1xuICAgICAgICAgICAgaWYgKHRyeUNhdGNoKGhhbmRsZXIpLmNhbGwocmVjZWl2ZXIsIHZhbHVlKSA9PT0gZXJyb3JPYmopIHtcbiAgICAgICAgICAgICAgICBwcm9taXNlLl9yZWplY3QoZXJyb3JPYmouZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoaGFuZGxlciA9PT0gcmVmbGVjdEhhbmRsZXIpIHtcbiAgICAgICAgICAgIHByb21pc2UuX2Z1bGZpbGwocmVmbGVjdEhhbmRsZXIuY2FsbChyZWNlaXZlcikpO1xuICAgICAgICB9IGVsc2UgaWYgKHJlY2VpdmVyIGluc3RhbmNlb2YgUHJveHlhYmxlKSB7XG4gICAgICAgICAgICByZWNlaXZlci5fcHJvbWlzZUNhbmNlbGxlZChwcm9taXNlKTtcbiAgICAgICAgfSBlbHNlIGlmIChpc1Byb21pc2UgfHwgcHJvbWlzZSBpbnN0YW5jZW9mIFByb21pc2VBcnJheSkge1xuICAgICAgICAgICAgcHJvbWlzZS5fY2FuY2VsKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZWNlaXZlci5jYW5jZWwoKTtcbiAgICAgICAgfVxuICAgIH0gZWxzZSBpZiAodHlwZW9mIGhhbmRsZXIgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICBpZiAoIWlzUHJvbWlzZSkge1xuICAgICAgICAgICAgaGFuZGxlci5jYWxsKHJlY2VpdmVyLCB2YWx1ZSwgcHJvbWlzZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAoYXN5bmNHdWFyYW50ZWVkKSBwcm9taXNlLl9zZXRBc3luY0d1YXJhbnRlZWQoKTtcbiAgICAgICAgICAgIHRoaXMuX3NldHRsZVByb21pc2VGcm9tSGFuZGxlcihoYW5kbGVyLCByZWNlaXZlciwgdmFsdWUsIHByb21pc2UpO1xuICAgICAgICB9XG4gICAgfSBlbHNlIGlmIChyZWNlaXZlciBpbnN0YW5jZW9mIFByb3h5YWJsZSkge1xuICAgICAgICBpZiAoIXJlY2VpdmVyLl9pc1Jlc29sdmVkKCkpIHtcbiAgICAgICAgICAgIGlmICgoKGJpdEZpZWxkICYgMzM1NTQ0MzIpICE9PSAwKSkge1xuICAgICAgICAgICAgICAgIHJlY2VpdmVyLl9wcm9taXNlRnVsZmlsbGVkKHZhbHVlLCBwcm9taXNlKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmVjZWl2ZXIuX3Byb21pc2VSZWplY3RlZCh2YWx1ZSwgcHJvbWlzZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGlzUHJvbWlzZSkge1xuICAgICAgICBpZiAoYXN5bmNHdWFyYW50ZWVkKSBwcm9taXNlLl9zZXRBc3luY0d1YXJhbnRlZWQoKTtcbiAgICAgICAgaWYgKCgoYml0RmllbGQgJiAzMzU1NDQzMikgIT09IDApKSB7XG4gICAgICAgICAgICBwcm9taXNlLl9mdWxmaWxsKHZhbHVlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHByb21pc2UuX3JlamVjdCh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICB9XG59O1xuXG5Qcm9taXNlLnByb3RvdHlwZS5fc2V0dGxlUHJvbWlzZUxhdGVDYW5jZWxsYXRpb25PYnNlcnZlciA9IGZ1bmN0aW9uKGN0eCkge1xuICAgIHZhciBoYW5kbGVyID0gY3R4LmhhbmRsZXI7XG4gICAgdmFyIHByb21pc2UgPSBjdHgucHJvbWlzZTtcbiAgICB2YXIgcmVjZWl2ZXIgPSBjdHgucmVjZWl2ZXI7XG4gICAgdmFyIHZhbHVlID0gY3R4LnZhbHVlO1xuICAgIGlmICh0eXBlb2YgaGFuZGxlciA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIGlmICghKHByb21pc2UgaW5zdGFuY2VvZiBQcm9taXNlKSkge1xuICAgICAgICAgICAgaGFuZGxlci5jYWxsKHJlY2VpdmVyLCB2YWx1ZSwgcHJvbWlzZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl9zZXR0bGVQcm9taXNlRnJvbUhhbmRsZXIoaGFuZGxlciwgcmVjZWl2ZXIsIHZhbHVlLCBwcm9taXNlKTtcbiAgICAgICAgfVxuICAgIH0gZWxzZSBpZiAocHJvbWlzZSBpbnN0YW5jZW9mIFByb21pc2UpIHtcbiAgICAgICAgcHJvbWlzZS5fcmVqZWN0KHZhbHVlKTtcbiAgICB9XG59O1xuXG5Qcm9taXNlLnByb3RvdHlwZS5fc2V0dGxlUHJvbWlzZUN0eCA9IGZ1bmN0aW9uKGN0eCkge1xuICAgIHRoaXMuX3NldHRsZVByb21pc2UoY3R4LnByb21pc2UsIGN0eC5oYW5kbGVyLCBjdHgucmVjZWl2ZXIsIGN0eC52YWx1ZSk7XG59O1xuXG5Qcm9taXNlLnByb3RvdHlwZS5fc2V0dGxlUHJvbWlzZTAgPSBmdW5jdGlvbihoYW5kbGVyLCB2YWx1ZSwgYml0RmllbGQpIHtcbiAgICB2YXIgcHJvbWlzZSA9IHRoaXMuX3Byb21pc2UwO1xuICAgIHZhciByZWNlaXZlciA9IHRoaXMuX3JlY2VpdmVyQXQoMCk7XG4gICAgdGhpcy5fcHJvbWlzZTAgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5fcmVjZWl2ZXIwID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuX3NldHRsZVByb21pc2UocHJvbWlzZSwgaGFuZGxlciwgcmVjZWl2ZXIsIHZhbHVlKTtcbn07XG5cblByb21pc2UucHJvdG90eXBlLl9jbGVhckNhbGxiYWNrRGF0YUF0SW5kZXggPSBmdW5jdGlvbihpbmRleCkge1xuICAgIHZhciBiYXNlID0gaW5kZXggKiA0IC0gNDtcbiAgICB0aGlzW2Jhc2UgKyAyXSA9XG4gICAgdGhpc1tiYXNlICsgM10gPVxuICAgIHRoaXNbYmFzZSArIDBdID1cbiAgICB0aGlzW2Jhc2UgKyAxXSA9IHVuZGVmaW5lZDtcbn07XG5cblByb21pc2UucHJvdG90eXBlLl9mdWxmaWxsID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgdmFyIGJpdEZpZWxkID0gdGhpcy5fYml0RmllbGQ7XG4gICAgaWYgKCgoYml0RmllbGQgJiAxMTc1MDYwNDgpID4+PiAxNikpIHJldHVybjtcbiAgICBpZiAodmFsdWUgPT09IHRoaXMpIHtcbiAgICAgICAgdmFyIGVyciA9IG1ha2VTZWxmUmVzb2x1dGlvbkVycm9yKCk7XG4gICAgICAgIHRoaXMuX2F0dGFjaEV4dHJhVHJhY2UoZXJyKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3JlamVjdChlcnIpO1xuICAgIH1cbiAgICB0aGlzLl9zZXRGdWxmaWxsZWQoKTtcbiAgICB0aGlzLl9yZWplY3Rpb25IYW5kbGVyMCA9IHZhbHVlO1xuXG4gICAgaWYgKChiaXRGaWVsZCAmIDY1NTM1KSA+IDApIHtcbiAgICAgICAgaWYgKCgoYml0RmllbGQgJiAxMzQyMTc3MjgpICE9PSAwKSkge1xuICAgICAgICAgICAgdGhpcy5fc2V0dGxlUHJvbWlzZXMoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGFzeW5jLnNldHRsZVByb21pc2VzKHRoaXMpO1xuICAgICAgICB9XG4gICAgfVxufTtcblxuUHJvbWlzZS5wcm90b3R5cGUuX3JlamVjdCA9IGZ1bmN0aW9uIChyZWFzb24pIHtcbiAgICB2YXIgYml0RmllbGQgPSB0aGlzLl9iaXRGaWVsZDtcbiAgICBpZiAoKChiaXRGaWVsZCAmIDExNzUwNjA0OCkgPj4+IDE2KSkgcmV0dXJuO1xuICAgIHRoaXMuX3NldFJlamVjdGVkKCk7XG4gICAgdGhpcy5fZnVsZmlsbG1lbnRIYW5kbGVyMCA9IHJlYXNvbjtcblxuICAgIGlmICh0aGlzLl9pc0ZpbmFsKCkpIHtcbiAgICAgICAgcmV0dXJuIGFzeW5jLmZhdGFsRXJyb3IocmVhc29uLCB1dGlsLmlzTm9kZSk7XG4gICAgfVxuXG4gICAgaWYgKChiaXRGaWVsZCAmIDY1NTM1KSA+IDApIHtcbiAgICAgICAgYXN5bmMuc2V0dGxlUHJvbWlzZXModGhpcyk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5fZW5zdXJlUG9zc2libGVSZWplY3Rpb25IYW5kbGVkKCk7XG4gICAgfVxufTtcblxuUHJvbWlzZS5wcm90b3R5cGUuX2Z1bGZpbGxQcm9taXNlcyA9IGZ1bmN0aW9uIChsZW4sIHZhbHVlKSB7XG4gICAgZm9yICh2YXIgaSA9IDE7IGkgPCBsZW47IGkrKykge1xuICAgICAgICB2YXIgaGFuZGxlciA9IHRoaXMuX2Z1bGZpbGxtZW50SGFuZGxlckF0KGkpO1xuICAgICAgICB2YXIgcHJvbWlzZSA9IHRoaXMuX3Byb21pc2VBdChpKTtcbiAgICAgICAgdmFyIHJlY2VpdmVyID0gdGhpcy5fcmVjZWl2ZXJBdChpKTtcbiAgICAgICAgdGhpcy5fY2xlYXJDYWxsYmFja0RhdGFBdEluZGV4KGkpO1xuICAgICAgICB0aGlzLl9zZXR0bGVQcm9taXNlKHByb21pc2UsIGhhbmRsZXIsIHJlY2VpdmVyLCB2YWx1ZSk7XG4gICAgfVxufTtcblxuUHJvbWlzZS5wcm90b3R5cGUuX3JlamVjdFByb21pc2VzID0gZnVuY3Rpb24gKGxlbiwgcmVhc29uKSB7XG4gICAgZm9yICh2YXIgaSA9IDE7IGkgPCBsZW47IGkrKykge1xuICAgICAgICB2YXIgaGFuZGxlciA9IHRoaXMuX3JlamVjdGlvbkhhbmRsZXJBdChpKTtcbiAgICAgICAgdmFyIHByb21pc2UgPSB0aGlzLl9wcm9taXNlQXQoaSk7XG4gICAgICAgIHZhciByZWNlaXZlciA9IHRoaXMuX3JlY2VpdmVyQXQoaSk7XG4gICAgICAgIHRoaXMuX2NsZWFyQ2FsbGJhY2tEYXRhQXRJbmRleChpKTtcbiAgICAgICAgdGhpcy5fc2V0dGxlUHJvbWlzZShwcm9taXNlLCBoYW5kbGVyLCByZWNlaXZlciwgcmVhc29uKTtcbiAgICB9XG59O1xuXG5Qcm9taXNlLnByb3RvdHlwZS5fc2V0dGxlUHJvbWlzZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGJpdEZpZWxkID0gdGhpcy5fYml0RmllbGQ7XG4gICAgdmFyIGxlbiA9IChiaXRGaWVsZCAmIDY1NTM1KTtcblxuICAgIGlmIChsZW4gPiAwKSB7XG4gICAgICAgIGlmICgoKGJpdEZpZWxkICYgMTY4NDI3NTIpICE9PSAwKSkge1xuICAgICAgICAgICAgdmFyIHJlYXNvbiA9IHRoaXMuX2Z1bGZpbGxtZW50SGFuZGxlcjA7XG4gICAgICAgICAgICB0aGlzLl9zZXR0bGVQcm9taXNlMCh0aGlzLl9yZWplY3Rpb25IYW5kbGVyMCwgcmVhc29uLCBiaXRGaWVsZCk7XG4gICAgICAgICAgICB0aGlzLl9yZWplY3RQcm9taXNlcyhsZW4sIHJlYXNvbik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YXIgdmFsdWUgPSB0aGlzLl9yZWplY3Rpb25IYW5kbGVyMDtcbiAgICAgICAgICAgIHRoaXMuX3NldHRsZVByb21pc2UwKHRoaXMuX2Z1bGZpbGxtZW50SGFuZGxlcjAsIHZhbHVlLCBiaXRGaWVsZCk7XG4gICAgICAgICAgICB0aGlzLl9mdWxmaWxsUHJvbWlzZXMobGVuLCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fc2V0TGVuZ3RoKDApO1xuICAgIH1cbiAgICB0aGlzLl9jbGVhckNhbmNlbGxhdGlvbkRhdGEoKTtcbn07XG5cblByb21pc2UucHJvdG90eXBlLl9zZXR0bGVkVmFsdWUgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgYml0RmllbGQgPSB0aGlzLl9iaXRGaWVsZDtcbiAgICBpZiAoKChiaXRGaWVsZCAmIDMzNTU0NDMyKSAhPT0gMCkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3JlamVjdGlvbkhhbmRsZXIwO1xuICAgIH0gZWxzZSBpZiAoKChiaXRGaWVsZCAmIDE2Nzc3MjE2KSAhPT0gMCkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2Z1bGZpbGxtZW50SGFuZGxlcjA7XG4gICAgfVxufTtcblxuZnVuY3Rpb24gZGVmZXJSZXNvbHZlKHYpIHt0aGlzLnByb21pc2UuX3Jlc29sdmVDYWxsYmFjayh2KTt9XG5mdW5jdGlvbiBkZWZlclJlamVjdCh2KSB7dGhpcy5wcm9taXNlLl9yZWplY3RDYWxsYmFjayh2LCBmYWxzZSk7fVxuXG5Qcm9taXNlLmRlZmVyID0gUHJvbWlzZS5wZW5kaW5nID0gZnVuY3Rpb24oKSB7XG4gICAgZGVidWcuZGVwcmVjYXRlZChcIlByb21pc2UuZGVmZXJcIiwgXCJuZXcgUHJvbWlzZVwiKTtcbiAgICB2YXIgcHJvbWlzZSA9IG5ldyBQcm9taXNlKElOVEVSTkFMKTtcbiAgICByZXR1cm4ge1xuICAgICAgICBwcm9taXNlOiBwcm9taXNlLFxuICAgICAgICByZXNvbHZlOiBkZWZlclJlc29sdmUsXG4gICAgICAgIHJlamVjdDogZGVmZXJSZWplY3RcbiAgICB9O1xufTtcblxudXRpbC5ub3RFbnVtZXJhYmxlUHJvcChQcm9taXNlLFxuICAgICAgICAgICAgICAgICAgICAgICBcIl9tYWtlU2VsZlJlc29sdXRpb25FcnJvclwiLFxuICAgICAgICAgICAgICAgICAgICAgICBtYWtlU2VsZlJlc29sdXRpb25FcnJvcik7XG5cbnJlcXVpcmUoXCIuL21ldGhvZFwiKShQcm9taXNlLCBJTlRFUk5BTCwgdHJ5Q29udmVydFRvUHJvbWlzZSwgYXBpUmVqZWN0aW9uLFxuICAgIGRlYnVnKTtcbnJlcXVpcmUoXCIuL2JpbmRcIikoUHJvbWlzZSwgSU5URVJOQUwsIHRyeUNvbnZlcnRUb1Byb21pc2UsIGRlYnVnKTtcbnJlcXVpcmUoXCIuL2NhbmNlbFwiKShQcm9taXNlLCBQcm9taXNlQXJyYXksIGFwaVJlamVjdGlvbiwgZGVidWcpO1xucmVxdWlyZShcIi4vZGlyZWN0X3Jlc29sdmVcIikoUHJvbWlzZSk7XG5yZXF1aXJlKFwiLi9zeW5jaHJvbm91c19pbnNwZWN0aW9uXCIpKFByb21pc2UpO1xucmVxdWlyZShcIi4vam9pblwiKShcbiAgICBQcm9taXNlLCBQcm9taXNlQXJyYXksIHRyeUNvbnZlcnRUb1Byb21pc2UsIElOVEVSTkFMLCBhc3luYywgZ2V0RG9tYWluKTtcblByb21pc2UuUHJvbWlzZSA9IFByb21pc2U7XG5Qcm9taXNlLnZlcnNpb24gPSBcIjMuNS4xXCI7XG5yZXF1aXJlKCcuL21hcC5qcycpKFByb21pc2UsIFByb21pc2VBcnJheSwgYXBpUmVqZWN0aW9uLCB0cnlDb252ZXJ0VG9Qcm9taXNlLCBJTlRFUk5BTCwgZGVidWcpO1xucmVxdWlyZSgnLi9jYWxsX2dldC5qcycpKFByb21pc2UpO1xucmVxdWlyZSgnLi91c2luZy5qcycpKFByb21pc2UsIGFwaVJlamVjdGlvbiwgdHJ5Q29udmVydFRvUHJvbWlzZSwgY3JlYXRlQ29udGV4dCwgSU5URVJOQUwsIGRlYnVnKTtcbnJlcXVpcmUoJy4vdGltZXJzLmpzJykoUHJvbWlzZSwgSU5URVJOQUwsIGRlYnVnKTtcbnJlcXVpcmUoJy4vZ2VuZXJhdG9ycy5qcycpKFByb21pc2UsIGFwaVJlamVjdGlvbiwgSU5URVJOQUwsIHRyeUNvbnZlcnRUb1Byb21pc2UsIFByb3h5YWJsZSwgZGVidWcpO1xucmVxdWlyZSgnLi9ub2RlaWZ5LmpzJykoUHJvbWlzZSk7XG5yZXF1aXJlKCcuL3Byb21pc2lmeS5qcycpKFByb21pc2UsIElOVEVSTkFMKTtcbnJlcXVpcmUoJy4vcHJvcHMuanMnKShQcm9taXNlLCBQcm9taXNlQXJyYXksIHRyeUNvbnZlcnRUb1Byb21pc2UsIGFwaVJlamVjdGlvbik7XG5yZXF1aXJlKCcuL3JhY2UuanMnKShQcm9taXNlLCBJTlRFUk5BTCwgdHJ5Q29udmVydFRvUHJvbWlzZSwgYXBpUmVqZWN0aW9uKTtcbnJlcXVpcmUoJy4vcmVkdWNlLmpzJykoUHJvbWlzZSwgUHJvbWlzZUFycmF5LCBhcGlSZWplY3Rpb24sIHRyeUNvbnZlcnRUb1Byb21pc2UsIElOVEVSTkFMLCBkZWJ1Zyk7XG5yZXF1aXJlKCcuL3NldHRsZS5qcycpKFByb21pc2UsIFByb21pc2VBcnJheSwgZGVidWcpO1xucmVxdWlyZSgnLi9zb21lLmpzJykoUHJvbWlzZSwgUHJvbWlzZUFycmF5LCBhcGlSZWplY3Rpb24pO1xucmVxdWlyZSgnLi9maWx0ZXIuanMnKShQcm9taXNlLCBJTlRFUk5BTCk7XG5yZXF1aXJlKCcuL2VhY2guanMnKShQcm9taXNlLCBJTlRFUk5BTCk7XG5yZXF1aXJlKCcuL2FueS5qcycpKFByb21pc2UpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgdXRpbC50b0Zhc3RQcm9wZXJ0aWVzKFByb21pc2UpOyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgIHV0aWwudG9GYXN0UHJvcGVydGllcyhQcm9taXNlLnByb3RvdHlwZSk7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcbiAgICBmdW5jdGlvbiBmaWxsVHlwZXModmFsdWUpIHsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgIHZhciBwID0gbmV3IFByb21pc2UoSU5URVJOQUwpOyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICBwLl9mdWxmaWxsbWVudEhhbmRsZXIwID0gdmFsdWU7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgcC5fcmVqZWN0aW9uSGFuZGxlcjAgPSB2YWx1ZTsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgIHAuX3Byb21pc2UwID0gdmFsdWU7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICBwLl9yZWNlaXZlcjAgPSB2YWx1ZTsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcbiAgICB9ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgLy8gQ29tcGxldGUgc2xhY2sgdHJhY2tpbmcsIG9wdCBvdXQgb2YgZmllbGQtdHlwZSB0cmFja2luZyBhbmQgICAgICAgICAgIFxuICAgIC8vIHN0YWJpbGl6ZSBtYXAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcbiAgICBmaWxsVHlwZXMoe2E6IDF9KTsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgZmlsbFR5cGVzKHtiOiAyfSk7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgIGZpbGxUeXBlcyh7YzogM30pOyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcbiAgICBmaWxsVHlwZXMoMSk7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgZmlsbFR5cGVzKGZ1bmN0aW9uKCl7fSk7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgIGZpbGxUeXBlcyh1bmRlZmluZWQpOyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcbiAgICBmaWxsVHlwZXMoZmFsc2UpOyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgZmlsbFR5cGVzKG5ldyBQcm9taXNlKElOVEVSTkFMKSk7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgIGRlYnVnLnNldEJvdW5kcyhBc3luYy5maXJzdExpbmVFcnJvciwgdXRpbC5sYXN0TGluZUVycm9yKTsgICAgICAgICAgICAgICBcbiAgICByZXR1cm4gUHJvbWlzZTsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXG5cbn07XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvYmx1ZWJpcmQvanMvcmVsZWFzZS9wcm9taXNlLmpzIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgZmlyc3RMaW5lRXJyb3I7XG50cnkge3Rocm93IG5ldyBFcnJvcigpOyB9IGNhdGNoIChlKSB7Zmlyc3RMaW5lRXJyb3IgPSBlO31cbnZhciBzY2hlZHVsZSA9IHJlcXVpcmUoXCIuL3NjaGVkdWxlXCIpO1xudmFyIFF1ZXVlID0gcmVxdWlyZShcIi4vcXVldWVcIik7XG52YXIgdXRpbCA9IHJlcXVpcmUoXCIuL3V0aWxcIik7XG5cbmZ1bmN0aW9uIEFzeW5jKCkge1xuICAgIHRoaXMuX2N1c3RvbVNjaGVkdWxlciA9IGZhbHNlO1xuICAgIHRoaXMuX2lzVGlja1VzZWQgPSBmYWxzZTtcbiAgICB0aGlzLl9sYXRlUXVldWUgPSBuZXcgUXVldWUoMTYpO1xuICAgIHRoaXMuX25vcm1hbFF1ZXVlID0gbmV3IFF1ZXVlKDE2KTtcbiAgICB0aGlzLl9oYXZlRHJhaW5lZFF1ZXVlcyA9IGZhbHNlO1xuICAgIHRoaXMuX3RyYW1wb2xpbmVFbmFibGVkID0gdHJ1ZTtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgdGhpcy5kcmFpblF1ZXVlcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgc2VsZi5fZHJhaW5RdWV1ZXMoKTtcbiAgICB9O1xuICAgIHRoaXMuX3NjaGVkdWxlID0gc2NoZWR1bGU7XG59XG5cbkFzeW5jLnByb3RvdHlwZS5zZXRTY2hlZHVsZXIgPSBmdW5jdGlvbihmbikge1xuICAgIHZhciBwcmV2ID0gdGhpcy5fc2NoZWR1bGU7XG4gICAgdGhpcy5fc2NoZWR1bGUgPSBmbjtcbiAgICB0aGlzLl9jdXN0b21TY2hlZHVsZXIgPSB0cnVlO1xuICAgIHJldHVybiBwcmV2O1xufTtcblxuQXN5bmMucHJvdG90eXBlLmhhc0N1c3RvbVNjaGVkdWxlciA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLl9jdXN0b21TY2hlZHVsZXI7XG59O1xuXG5Bc3luYy5wcm90b3R5cGUuZW5hYmxlVHJhbXBvbGluZSA9IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuX3RyYW1wb2xpbmVFbmFibGVkID0gdHJ1ZTtcbn07XG5cbkFzeW5jLnByb3RvdHlwZS5kaXNhYmxlVHJhbXBvbGluZUlmTmVjZXNzYXJ5ID0gZnVuY3Rpb24oKSB7XG4gICAgaWYgKHV0aWwuaGFzRGV2VG9vbHMpIHtcbiAgICAgICAgdGhpcy5fdHJhbXBvbGluZUVuYWJsZWQgPSBmYWxzZTtcbiAgICB9XG59O1xuXG5Bc3luYy5wcm90b3R5cGUuaGF2ZUl0ZW1zUXVldWVkID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLl9pc1RpY2tVc2VkIHx8IHRoaXMuX2hhdmVEcmFpbmVkUXVldWVzO1xufTtcblxuXG5Bc3luYy5wcm90b3R5cGUuZmF0YWxFcnJvciA9IGZ1bmN0aW9uKGUsIGlzTm9kZSkge1xuICAgIGlmIChpc05vZGUpIHtcbiAgICAgICAgcHJvY2Vzcy5zdGRlcnIud3JpdGUoXCJGYXRhbCBcIiArIChlIGluc3RhbmNlb2YgRXJyb3IgPyBlLnN0YWNrIDogZSkgK1xuICAgICAgICAgICAgXCJcXG5cIik7XG4gICAgICAgIHByb2Nlc3MuZXhpdCgyKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnRocm93TGF0ZXIoZSk7XG4gICAgfVxufTtcblxuQXN5bmMucHJvdG90eXBlLnRocm93TGF0ZXIgPSBmdW5jdGlvbihmbiwgYXJnKSB7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgYXJnID0gZm47XG4gICAgICAgIGZuID0gZnVuY3Rpb24gKCkgeyB0aHJvdyBhcmc7IH07XG4gICAgfVxuICAgIGlmICh0eXBlb2Ygc2V0VGltZW91dCAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgZm4oYXJnKTtcbiAgICAgICAgfSwgMCk7XG4gICAgfSBlbHNlIHRyeSB7XG4gICAgICAgIHRoaXMuX3NjaGVkdWxlKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgZm4oYXJnKTtcbiAgICAgICAgfSk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJObyBhc3luYyBzY2hlZHVsZXIgYXZhaWxhYmxlXFx1MDAwYVxcdTAwMGEgICAgU2VlIGh0dHA6Ly9nb28uZ2wvTXFyRm1YXFx1MDAwYVwiKTtcbiAgICB9XG59O1xuXG5mdW5jdGlvbiBBc3luY0ludm9rZUxhdGVyKGZuLCByZWNlaXZlciwgYXJnKSB7XG4gICAgdGhpcy5fbGF0ZVF1ZXVlLnB1c2goZm4sIHJlY2VpdmVyLCBhcmcpO1xuICAgIHRoaXMuX3F1ZXVlVGljaygpO1xufVxuXG5mdW5jdGlvbiBBc3luY0ludm9rZShmbiwgcmVjZWl2ZXIsIGFyZykge1xuICAgIHRoaXMuX25vcm1hbFF1ZXVlLnB1c2goZm4sIHJlY2VpdmVyLCBhcmcpO1xuICAgIHRoaXMuX3F1ZXVlVGljaygpO1xufVxuXG5mdW5jdGlvbiBBc3luY1NldHRsZVByb21pc2VzKHByb21pc2UpIHtcbiAgICB0aGlzLl9ub3JtYWxRdWV1ZS5fcHVzaE9uZShwcm9taXNlKTtcbiAgICB0aGlzLl9xdWV1ZVRpY2soKTtcbn1cblxuaWYgKCF1dGlsLmhhc0RldlRvb2xzKSB7XG4gICAgQXN5bmMucHJvdG90eXBlLmludm9rZUxhdGVyID0gQXN5bmNJbnZva2VMYXRlcjtcbiAgICBBc3luYy5wcm90b3R5cGUuaW52b2tlID0gQXN5bmNJbnZva2U7XG4gICAgQXN5bmMucHJvdG90eXBlLnNldHRsZVByb21pc2VzID0gQXN5bmNTZXR0bGVQcm9taXNlcztcbn0gZWxzZSB7XG4gICAgQXN5bmMucHJvdG90eXBlLmludm9rZUxhdGVyID0gZnVuY3Rpb24gKGZuLCByZWNlaXZlciwgYXJnKSB7XG4gICAgICAgIGlmICh0aGlzLl90cmFtcG9saW5lRW5hYmxlZCkge1xuICAgICAgICAgICAgQXN5bmNJbnZva2VMYXRlci5jYWxsKHRoaXMsIGZuLCByZWNlaXZlciwgYXJnKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX3NjaGVkdWxlKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIGZuLmNhbGwocmVjZWl2ZXIsIGFyZyk7XG4gICAgICAgICAgICAgICAgfSwgMTAwKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIEFzeW5jLnByb3RvdHlwZS5pbnZva2UgPSBmdW5jdGlvbiAoZm4sIHJlY2VpdmVyLCBhcmcpIHtcbiAgICAgICAgaWYgKHRoaXMuX3RyYW1wb2xpbmVFbmFibGVkKSB7XG4gICAgICAgICAgICBBc3luY0ludm9rZS5jYWxsKHRoaXMsIGZuLCByZWNlaXZlciwgYXJnKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX3NjaGVkdWxlKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIGZuLmNhbGwocmVjZWl2ZXIsIGFyZyk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBBc3luYy5wcm90b3R5cGUuc2V0dGxlUHJvbWlzZXMgPSBmdW5jdGlvbihwcm9taXNlKSB7XG4gICAgICAgIGlmICh0aGlzLl90cmFtcG9saW5lRW5hYmxlZCkge1xuICAgICAgICAgICAgQXN5bmNTZXR0bGVQcm9taXNlcy5jYWxsKHRoaXMsIHByb21pc2UpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5fc2NoZWR1bGUoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgcHJvbWlzZS5fc2V0dGxlUHJvbWlzZXMoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfTtcbn1cblxuQXN5bmMucHJvdG90eXBlLl9kcmFpblF1ZXVlID0gZnVuY3Rpb24ocXVldWUpIHtcbiAgICB3aGlsZSAocXVldWUubGVuZ3RoKCkgPiAwKSB7XG4gICAgICAgIHZhciBmbiA9IHF1ZXVlLnNoaWZ0KCk7XG4gICAgICAgIGlmICh0eXBlb2YgZm4gIT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgZm4uX3NldHRsZVByb21pc2VzKCk7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgcmVjZWl2ZXIgPSBxdWV1ZS5zaGlmdCgpO1xuICAgICAgICB2YXIgYXJnID0gcXVldWUuc2hpZnQoKTtcbiAgICAgICAgZm4uY2FsbChyZWNlaXZlciwgYXJnKTtcbiAgICB9XG59O1xuXG5Bc3luYy5wcm90b3R5cGUuX2RyYWluUXVldWVzID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuX2RyYWluUXVldWUodGhpcy5fbm9ybWFsUXVldWUpO1xuICAgIHRoaXMuX3Jlc2V0KCk7XG4gICAgdGhpcy5faGF2ZURyYWluZWRRdWV1ZXMgPSB0cnVlO1xuICAgIHRoaXMuX2RyYWluUXVldWUodGhpcy5fbGF0ZVF1ZXVlKTtcbn07XG5cbkFzeW5jLnByb3RvdHlwZS5fcXVldWVUaWNrID0gZnVuY3Rpb24gKCkge1xuICAgIGlmICghdGhpcy5faXNUaWNrVXNlZCkge1xuICAgICAgICB0aGlzLl9pc1RpY2tVc2VkID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5fc2NoZWR1bGUodGhpcy5kcmFpblF1ZXVlcyk7XG4gICAgfVxufTtcblxuQXN5bmMucHJvdG90eXBlLl9yZXNldCA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLl9pc1RpY2tVc2VkID0gZmFsc2U7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEFzeW5jO1xubW9kdWxlLmV4cG9ydHMuZmlyc3RMaW5lRXJyb3IgPSBmaXJzdExpbmVFcnJvcjtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9ibHVlYmlyZC9qcy9yZWxlYXNlL2FzeW5jLmpzIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgdXRpbCA9IHJlcXVpcmUoXCIuL3V0aWxcIik7XG52YXIgc2NoZWR1bGU7XG52YXIgbm9Bc3luY1NjaGVkdWxlciA9IGZ1bmN0aW9uKCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIk5vIGFzeW5jIHNjaGVkdWxlciBhdmFpbGFibGVcXHUwMDBhXFx1MDAwYSAgICBTZWUgaHR0cDovL2dvby5nbC9NcXJGbVhcXHUwMDBhXCIpO1xufTtcbnZhciBOYXRpdmVQcm9taXNlID0gdXRpbC5nZXROYXRpdmVQcm9taXNlKCk7XG5pZiAodXRpbC5pc05vZGUgJiYgdHlwZW9mIE11dGF0aW9uT2JzZXJ2ZXIgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICB2YXIgR2xvYmFsU2V0SW1tZWRpYXRlID0gZ2xvYmFsLnNldEltbWVkaWF0ZTtcbiAgICB2YXIgUHJvY2Vzc05leHRUaWNrID0gcHJvY2Vzcy5uZXh0VGljaztcbiAgICBzY2hlZHVsZSA9IHV0aWwuaXNSZWNlbnROb2RlXG4gICAgICAgICAgICAgICAgPyBmdW5jdGlvbihmbikgeyBHbG9iYWxTZXRJbW1lZGlhdGUuY2FsbChnbG9iYWwsIGZuKTsgfVxuICAgICAgICAgICAgICAgIDogZnVuY3Rpb24oZm4pIHsgUHJvY2Vzc05leHRUaWNrLmNhbGwocHJvY2VzcywgZm4pOyB9O1xufSBlbHNlIGlmICh0eXBlb2YgTmF0aXZlUHJvbWlzZSA9PT0gXCJmdW5jdGlvblwiICYmXG4gICAgICAgICAgIHR5cGVvZiBOYXRpdmVQcm9taXNlLnJlc29sdmUgPT09IFwiZnVuY3Rpb25cIikge1xuICAgIHZhciBuYXRpdmVQcm9taXNlID0gTmF0aXZlUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgc2NoZWR1bGUgPSBmdW5jdGlvbihmbikge1xuICAgICAgICBuYXRpdmVQcm9taXNlLnRoZW4oZm4pO1xuICAgIH07XG59IGVsc2UgaWYgKCh0eXBlb2YgTXV0YXRpb25PYnNlcnZlciAhPT0gXCJ1bmRlZmluZWRcIikgJiZcbiAgICAgICAgICAhKHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgJiZcbiAgICAgICAgICAgIHdpbmRvdy5uYXZpZ2F0b3IgJiZcbiAgICAgICAgICAgICh3aW5kb3cubmF2aWdhdG9yLnN0YW5kYWxvbmUgfHwgd2luZG93LmNvcmRvdmEpKSkge1xuICAgIHNjaGVkdWxlID0gKGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgZGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICAgICAgdmFyIG9wdHMgPSB7YXR0cmlidXRlczogdHJ1ZX07XG4gICAgICAgIHZhciB0b2dnbGVTY2hlZHVsZWQgPSBmYWxzZTtcbiAgICAgICAgdmFyIGRpdjIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgICAgICB2YXIgbzIgPSBuZXcgTXV0YXRpb25PYnNlcnZlcihmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGRpdi5jbGFzc0xpc3QudG9nZ2xlKFwiZm9vXCIpO1xuICAgICAgICAgICAgdG9nZ2xlU2NoZWR1bGVkID0gZmFsc2U7XG4gICAgICAgIH0pO1xuICAgICAgICBvMi5vYnNlcnZlKGRpdjIsIG9wdHMpO1xuXG4gICAgICAgIHZhciBzY2hlZHVsZVRvZ2dsZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgaWYgKHRvZ2dsZVNjaGVkdWxlZCkgcmV0dXJuO1xuICAgICAgICAgICAgdG9nZ2xlU2NoZWR1bGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIGRpdjIuY2xhc3NMaXN0LnRvZ2dsZShcImZvb1wiKTtcbiAgICAgICAgfTtcblxuICAgICAgICByZXR1cm4gZnVuY3Rpb24gc2NoZWR1bGUoZm4pIHtcbiAgICAgICAgICAgIHZhciBvID0gbmV3IE11dGF0aW9uT2JzZXJ2ZXIoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgby5kaXNjb25uZWN0KCk7XG4gICAgICAgICAgICAgICAgZm4oKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgby5vYnNlcnZlKGRpdiwgb3B0cyk7XG4gICAgICAgICAgICBzY2hlZHVsZVRvZ2dsZSgpO1xuICAgICAgICB9O1xuICAgIH0pKCk7XG59IGVsc2UgaWYgKHR5cGVvZiBzZXRJbW1lZGlhdGUgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICBzY2hlZHVsZSA9IGZ1bmN0aW9uIChmbikge1xuICAgICAgICBzZXRJbW1lZGlhdGUoZm4pO1xuICAgIH07XG59IGVsc2UgaWYgKHR5cGVvZiBzZXRUaW1lb3V0ICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgc2NoZWR1bGUgPSBmdW5jdGlvbiAoZm4pIHtcbiAgICAgICAgc2V0VGltZW91dChmbiwgMCk7XG4gICAgfTtcbn0gZWxzZSB7XG4gICAgc2NoZWR1bGUgPSBub0FzeW5jU2NoZWR1bGVyO1xufVxubW9kdWxlLmV4cG9ydHMgPSBzY2hlZHVsZTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9ibHVlYmlyZC9qcy9yZWxlYXNlL3NjaGVkdWxlLmpzIiwiXCJ1c2Ugc3RyaWN0XCI7XG5mdW5jdGlvbiBhcnJheU1vdmUoc3JjLCBzcmNJbmRleCwgZHN0LCBkc3RJbmRleCwgbGVuKSB7XG4gICAgZm9yICh2YXIgaiA9IDA7IGogPCBsZW47ICsraikge1xuICAgICAgICBkc3RbaiArIGRzdEluZGV4XSA9IHNyY1tqICsgc3JjSW5kZXhdO1xuICAgICAgICBzcmNbaiArIHNyY0luZGV4XSA9IHZvaWQgMDtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIFF1ZXVlKGNhcGFjaXR5KSB7XG4gICAgdGhpcy5fY2FwYWNpdHkgPSBjYXBhY2l0eTtcbiAgICB0aGlzLl9sZW5ndGggPSAwO1xuICAgIHRoaXMuX2Zyb250ID0gMDtcbn1cblxuUXVldWUucHJvdG90eXBlLl93aWxsQmVPdmVyQ2FwYWNpdHkgPSBmdW5jdGlvbiAoc2l6ZSkge1xuICAgIHJldHVybiB0aGlzLl9jYXBhY2l0eSA8IHNpemU7XG59O1xuXG5RdWV1ZS5wcm90b3R5cGUuX3B1c2hPbmUgPSBmdW5jdGlvbiAoYXJnKSB7XG4gICAgdmFyIGxlbmd0aCA9IHRoaXMubGVuZ3RoKCk7XG4gICAgdGhpcy5fY2hlY2tDYXBhY2l0eShsZW5ndGggKyAxKTtcbiAgICB2YXIgaSA9ICh0aGlzLl9mcm9udCArIGxlbmd0aCkgJiAodGhpcy5fY2FwYWNpdHkgLSAxKTtcbiAgICB0aGlzW2ldID0gYXJnO1xuICAgIHRoaXMuX2xlbmd0aCA9IGxlbmd0aCArIDE7XG59O1xuXG5RdWV1ZS5wcm90b3R5cGUucHVzaCA9IGZ1bmN0aW9uIChmbiwgcmVjZWl2ZXIsIGFyZykge1xuICAgIHZhciBsZW5ndGggPSB0aGlzLmxlbmd0aCgpICsgMztcbiAgICBpZiAodGhpcy5fd2lsbEJlT3ZlckNhcGFjaXR5KGxlbmd0aCkpIHtcbiAgICAgICAgdGhpcy5fcHVzaE9uZShmbik7XG4gICAgICAgIHRoaXMuX3B1c2hPbmUocmVjZWl2ZXIpO1xuICAgICAgICB0aGlzLl9wdXNoT25lKGFyZyk7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIGogPSB0aGlzLl9mcm9udCArIGxlbmd0aCAtIDM7XG4gICAgdGhpcy5fY2hlY2tDYXBhY2l0eShsZW5ndGgpO1xuICAgIHZhciB3cmFwTWFzayA9IHRoaXMuX2NhcGFjaXR5IC0gMTtcbiAgICB0aGlzWyhqICsgMCkgJiB3cmFwTWFza10gPSBmbjtcbiAgICB0aGlzWyhqICsgMSkgJiB3cmFwTWFza10gPSByZWNlaXZlcjtcbiAgICB0aGlzWyhqICsgMikgJiB3cmFwTWFza10gPSBhcmc7XG4gICAgdGhpcy5fbGVuZ3RoID0gbGVuZ3RoO1xufTtcblxuUXVldWUucHJvdG90eXBlLnNoaWZ0ID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBmcm9udCA9IHRoaXMuX2Zyb250LFxuICAgICAgICByZXQgPSB0aGlzW2Zyb250XTtcblxuICAgIHRoaXNbZnJvbnRdID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuX2Zyb250ID0gKGZyb250ICsgMSkgJiAodGhpcy5fY2FwYWNpdHkgLSAxKTtcbiAgICB0aGlzLl9sZW5ndGgtLTtcbiAgICByZXR1cm4gcmV0O1xufTtcblxuUXVldWUucHJvdG90eXBlLmxlbmd0aCA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5fbGVuZ3RoO1xufTtcblxuUXVldWUucHJvdG90eXBlLl9jaGVja0NhcGFjaXR5ID0gZnVuY3Rpb24gKHNpemUpIHtcbiAgICBpZiAodGhpcy5fY2FwYWNpdHkgPCBzaXplKSB7XG4gICAgICAgIHRoaXMuX3Jlc2l6ZVRvKHRoaXMuX2NhcGFjaXR5IDw8IDEpO1xuICAgIH1cbn07XG5cblF1ZXVlLnByb3RvdHlwZS5fcmVzaXplVG8gPSBmdW5jdGlvbiAoY2FwYWNpdHkpIHtcbiAgICB2YXIgb2xkQ2FwYWNpdHkgPSB0aGlzLl9jYXBhY2l0eTtcbiAgICB0aGlzLl9jYXBhY2l0eSA9IGNhcGFjaXR5O1xuICAgIHZhciBmcm9udCA9IHRoaXMuX2Zyb250O1xuICAgIHZhciBsZW5ndGggPSB0aGlzLl9sZW5ndGg7XG4gICAgdmFyIG1vdmVJdGVtc0NvdW50ID0gKGZyb250ICsgbGVuZ3RoKSAmIChvbGRDYXBhY2l0eSAtIDEpO1xuICAgIGFycmF5TW92ZSh0aGlzLCAwLCB0aGlzLCBvbGRDYXBhY2l0eSwgbW92ZUl0ZW1zQ291bnQpO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBRdWV1ZTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9ibHVlYmlyZC9qcy9yZWxlYXNlL3F1ZXVlLmpzIiwiXCJ1c2Ugc3RyaWN0XCI7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKFByb21pc2UsIElOVEVSTkFMKSB7XG52YXIgdXRpbCA9IHJlcXVpcmUoXCIuL3V0aWxcIik7XG52YXIgZXJyb3JPYmogPSB1dGlsLmVycm9yT2JqO1xudmFyIGlzT2JqZWN0ID0gdXRpbC5pc09iamVjdDtcblxuZnVuY3Rpb24gdHJ5Q29udmVydFRvUHJvbWlzZShvYmosIGNvbnRleHQpIHtcbiAgICBpZiAoaXNPYmplY3Qob2JqKSkge1xuICAgICAgICBpZiAob2JqIGluc3RhbmNlb2YgUHJvbWlzZSkgcmV0dXJuIG9iajtcbiAgICAgICAgdmFyIHRoZW4gPSBnZXRUaGVuKG9iaik7XG4gICAgICAgIGlmICh0aGVuID09PSBlcnJvck9iaikge1xuICAgICAgICAgICAgaWYgKGNvbnRleHQpIGNvbnRleHQuX3B1c2hDb250ZXh0KCk7XG4gICAgICAgICAgICB2YXIgcmV0ID0gUHJvbWlzZS5yZWplY3QodGhlbi5lKTtcbiAgICAgICAgICAgIGlmIChjb250ZXh0KSBjb250ZXh0Ll9wb3BDb250ZXh0KCk7XG4gICAgICAgICAgICByZXR1cm4gcmV0O1xuICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiB0aGVuID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgIGlmIChpc0FueUJsdWViaXJkUHJvbWlzZShvYmopKSB7XG4gICAgICAgICAgICAgICAgdmFyIHJldCA9IG5ldyBQcm9taXNlKElOVEVSTkFMKTtcbiAgICAgICAgICAgICAgICBvYmouX3RoZW4oXG4gICAgICAgICAgICAgICAgICAgIHJldC5fZnVsZmlsbCxcbiAgICAgICAgICAgICAgICAgICAgcmV0Ll9yZWplY3QsXG4gICAgICAgICAgICAgICAgICAgIHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICAgICAgcmV0LFxuICAgICAgICAgICAgICAgICAgICBudWxsXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmV0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGRvVGhlbmFibGUob2JqLCB0aGVuLCBjb250ZXh0KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gb2JqO1xufVxuXG5mdW5jdGlvbiBkb0dldFRoZW4ob2JqKSB7XG4gICAgcmV0dXJuIG9iai50aGVuO1xufVxuXG5mdW5jdGlvbiBnZXRUaGVuKG9iaikge1xuICAgIHRyeSB7XG4gICAgICAgIHJldHVybiBkb0dldFRoZW4ob2JqKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGVycm9yT2JqLmUgPSBlO1xuICAgICAgICByZXR1cm4gZXJyb3JPYmo7XG4gICAgfVxufVxuXG52YXIgaGFzUHJvcCA9IHt9Lmhhc093blByb3BlcnR5O1xuZnVuY3Rpb24gaXNBbnlCbHVlYmlyZFByb21pc2Uob2JqKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIGhhc1Byb3AuY2FsbChvYmosIFwiX3Byb21pc2UwXCIpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gZG9UaGVuYWJsZSh4LCB0aGVuLCBjb250ZXh0KSB7XG4gICAgdmFyIHByb21pc2UgPSBuZXcgUHJvbWlzZShJTlRFUk5BTCk7XG4gICAgdmFyIHJldCA9IHByb21pc2U7XG4gICAgaWYgKGNvbnRleHQpIGNvbnRleHQuX3B1c2hDb250ZXh0KCk7XG4gICAgcHJvbWlzZS5fY2FwdHVyZVN0YWNrVHJhY2UoKTtcbiAgICBpZiAoY29udGV4dCkgY29udGV4dC5fcG9wQ29udGV4dCgpO1xuICAgIHZhciBzeW5jaHJvbm91cyA9IHRydWU7XG4gICAgdmFyIHJlc3VsdCA9IHV0aWwudHJ5Q2F0Y2godGhlbikuY2FsbCh4LCByZXNvbHZlLCByZWplY3QpO1xuICAgIHN5bmNocm9ub3VzID0gZmFsc2U7XG5cbiAgICBpZiAocHJvbWlzZSAmJiByZXN1bHQgPT09IGVycm9yT2JqKSB7XG4gICAgICAgIHByb21pc2UuX3JlamVjdENhbGxiYWNrKHJlc3VsdC5lLCB0cnVlLCB0cnVlKTtcbiAgICAgICAgcHJvbWlzZSA9IG51bGw7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcmVzb2x2ZSh2YWx1ZSkge1xuICAgICAgICBpZiAoIXByb21pc2UpIHJldHVybjtcbiAgICAgICAgcHJvbWlzZS5fcmVzb2x2ZUNhbGxiYWNrKHZhbHVlKTtcbiAgICAgICAgcHJvbWlzZSA9IG51bGw7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcmVqZWN0KHJlYXNvbikge1xuICAgICAgICBpZiAoIXByb21pc2UpIHJldHVybjtcbiAgICAgICAgcHJvbWlzZS5fcmVqZWN0Q2FsbGJhY2socmVhc29uLCBzeW5jaHJvbm91cywgdHJ1ZSk7XG4gICAgICAgIHByb21pc2UgPSBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gcmV0O1xufVxuXG5yZXR1cm4gdHJ5Q29udmVydFRvUHJvbWlzZTtcbn07XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvYmx1ZWJpcmQvanMvcmVsZWFzZS90aGVuYWJsZXMuanMiLCJcInVzZSBzdHJpY3RcIjtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oUHJvbWlzZSwgSU5URVJOQUwsIHRyeUNvbnZlcnRUb1Byb21pc2UsXG4gICAgYXBpUmVqZWN0aW9uLCBQcm94eWFibGUpIHtcbnZhciB1dGlsID0gcmVxdWlyZShcIi4vdXRpbFwiKTtcbnZhciBpc0FycmF5ID0gdXRpbC5pc0FycmF5O1xuXG5mdW5jdGlvbiB0b1Jlc29sdXRpb25WYWx1ZSh2YWwpIHtcbiAgICBzd2l0Y2godmFsKSB7XG4gICAgY2FzZSAtMjogcmV0dXJuIFtdO1xuICAgIGNhc2UgLTM6IHJldHVybiB7fTtcbiAgICBjYXNlIC02OiByZXR1cm4gbmV3IE1hcCgpO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gUHJvbWlzZUFycmF5KHZhbHVlcykge1xuICAgIHZhciBwcm9taXNlID0gdGhpcy5fcHJvbWlzZSA9IG5ldyBQcm9taXNlKElOVEVSTkFMKTtcbiAgICBpZiAodmFsdWVzIGluc3RhbmNlb2YgUHJvbWlzZSkge1xuICAgICAgICBwcm9taXNlLl9wcm9wYWdhdGVGcm9tKHZhbHVlcywgMyk7XG4gICAgfVxuICAgIHByb21pc2UuX3NldE9uQ2FuY2VsKHRoaXMpO1xuICAgIHRoaXMuX3ZhbHVlcyA9IHZhbHVlcztcbiAgICB0aGlzLl9sZW5ndGggPSAwO1xuICAgIHRoaXMuX3RvdGFsUmVzb2x2ZWQgPSAwO1xuICAgIHRoaXMuX2luaXQodW5kZWZpbmVkLCAtMik7XG59XG51dGlsLmluaGVyaXRzKFByb21pc2VBcnJheSwgUHJveHlhYmxlKTtcblxuUHJvbWlzZUFycmF5LnByb3RvdHlwZS5sZW5ndGggPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2xlbmd0aDtcbn07XG5cblByb21pc2VBcnJheS5wcm90b3R5cGUucHJvbWlzZSA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5fcHJvbWlzZTtcbn07XG5cblByb21pc2VBcnJheS5wcm90b3R5cGUuX2luaXQgPSBmdW5jdGlvbiBpbml0KF8sIHJlc29sdmVWYWx1ZUlmRW1wdHkpIHtcbiAgICB2YXIgdmFsdWVzID0gdHJ5Q29udmVydFRvUHJvbWlzZSh0aGlzLl92YWx1ZXMsIHRoaXMuX3Byb21pc2UpO1xuICAgIGlmICh2YWx1ZXMgaW5zdGFuY2VvZiBQcm9taXNlKSB7XG4gICAgICAgIHZhbHVlcyA9IHZhbHVlcy5fdGFyZ2V0KCk7XG4gICAgICAgIHZhciBiaXRGaWVsZCA9IHZhbHVlcy5fYml0RmllbGQ7XG4gICAgICAgIDtcbiAgICAgICAgdGhpcy5fdmFsdWVzID0gdmFsdWVzO1xuXG4gICAgICAgIGlmICgoKGJpdEZpZWxkICYgNTAzOTcxODQpID09PSAwKSkge1xuICAgICAgICAgICAgdGhpcy5fcHJvbWlzZS5fc2V0QXN5bmNHdWFyYW50ZWVkKCk7XG4gICAgICAgICAgICByZXR1cm4gdmFsdWVzLl90aGVuKFxuICAgICAgICAgICAgICAgIGluaXQsXG4gICAgICAgICAgICAgICAgdGhpcy5fcmVqZWN0LFxuICAgICAgICAgICAgICAgIHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICB0aGlzLFxuICAgICAgICAgICAgICAgIHJlc29sdmVWYWx1ZUlmRW1wdHlcbiAgICAgICAgICAgKTtcbiAgICAgICAgfSBlbHNlIGlmICgoKGJpdEZpZWxkICYgMzM1NTQ0MzIpICE9PSAwKSkge1xuICAgICAgICAgICAgdmFsdWVzID0gdmFsdWVzLl92YWx1ZSgpO1xuICAgICAgICB9IGVsc2UgaWYgKCgoYml0RmllbGQgJiAxNjc3NzIxNikgIT09IDApKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fcmVqZWN0KHZhbHVlcy5fcmVhc29uKCkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2NhbmNlbCgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHZhbHVlcyA9IHV0aWwuYXNBcnJheSh2YWx1ZXMpO1xuICAgIGlmICh2YWx1ZXMgPT09IG51bGwpIHtcbiAgICAgICAgdmFyIGVyciA9IGFwaVJlamVjdGlvbihcbiAgICAgICAgICAgIFwiZXhwZWN0aW5nIGFuIGFycmF5IG9yIGFuIGl0ZXJhYmxlIG9iamVjdCBidXQgZ290IFwiICsgdXRpbC5jbGFzc1N0cmluZyh2YWx1ZXMpKS5yZWFzb24oKTtcbiAgICAgICAgdGhpcy5fcHJvbWlzZS5fcmVqZWN0Q2FsbGJhY2soZXJyLCBmYWxzZSk7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAodmFsdWVzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICBpZiAocmVzb2x2ZVZhbHVlSWZFbXB0eSA9PT0gLTUpIHtcbiAgICAgICAgICAgIHRoaXMuX3Jlc29sdmVFbXB0eUFycmF5KCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl9yZXNvbHZlKHRvUmVzb2x1dGlvblZhbHVlKHJlc29sdmVWYWx1ZUlmRW1wdHkpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuX2l0ZXJhdGUodmFsdWVzKTtcbn07XG5cblByb21pc2VBcnJheS5wcm90b3R5cGUuX2l0ZXJhdGUgPSBmdW5jdGlvbih2YWx1ZXMpIHtcbiAgICB2YXIgbGVuID0gdGhpcy5nZXRBY3R1YWxMZW5ndGgodmFsdWVzLmxlbmd0aCk7XG4gICAgdGhpcy5fbGVuZ3RoID0gbGVuO1xuICAgIHRoaXMuX3ZhbHVlcyA9IHRoaXMuc2hvdWxkQ29weVZhbHVlcygpID8gbmV3IEFycmF5KGxlbikgOiB0aGlzLl92YWx1ZXM7XG4gICAgdmFyIHJlc3VsdCA9IHRoaXMuX3Byb21pc2U7XG4gICAgdmFyIGlzUmVzb2x2ZWQgPSBmYWxzZTtcbiAgICB2YXIgYml0RmllbGQgPSBudWxsO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyArK2kpIHtcbiAgICAgICAgdmFyIG1heWJlUHJvbWlzZSA9IHRyeUNvbnZlcnRUb1Byb21pc2UodmFsdWVzW2ldLCByZXN1bHQpO1xuXG4gICAgICAgIGlmIChtYXliZVByb21pc2UgaW5zdGFuY2VvZiBQcm9taXNlKSB7XG4gICAgICAgICAgICBtYXliZVByb21pc2UgPSBtYXliZVByb21pc2UuX3RhcmdldCgpO1xuICAgICAgICAgICAgYml0RmllbGQgPSBtYXliZVByb21pc2UuX2JpdEZpZWxkO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgYml0RmllbGQgPSBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGlzUmVzb2x2ZWQpIHtcbiAgICAgICAgICAgIGlmIChiaXRGaWVsZCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIG1heWJlUHJvbWlzZS5zdXBwcmVzc1VuaGFuZGxlZFJlamVjdGlvbnMoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChiaXRGaWVsZCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgaWYgKCgoYml0RmllbGQgJiA1MDM5NzE4NCkgPT09IDApKSB7XG4gICAgICAgICAgICAgICAgbWF5YmVQcm9taXNlLl9wcm94eSh0aGlzLCBpKTtcbiAgICAgICAgICAgICAgICB0aGlzLl92YWx1ZXNbaV0gPSBtYXliZVByb21pc2U7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKCgoYml0RmllbGQgJiAzMzU1NDQzMikgIT09IDApKSB7XG4gICAgICAgICAgICAgICAgaXNSZXNvbHZlZCA9IHRoaXMuX3Byb21pc2VGdWxmaWxsZWQobWF5YmVQcm9taXNlLl92YWx1ZSgpLCBpKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoKChiaXRGaWVsZCAmIDE2Nzc3MjE2KSAhPT0gMCkpIHtcbiAgICAgICAgICAgICAgICBpc1Jlc29sdmVkID0gdGhpcy5fcHJvbWlzZVJlamVjdGVkKG1heWJlUHJvbWlzZS5fcmVhc29uKCksIGkpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpc1Jlc29sdmVkID0gdGhpcy5fcHJvbWlzZUNhbmNlbGxlZChpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlzUmVzb2x2ZWQgPSB0aGlzLl9wcm9taXNlRnVsZmlsbGVkKG1heWJlUHJvbWlzZSwgaSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKCFpc1Jlc29sdmVkKSByZXN1bHQuX3NldEFzeW5jR3VhcmFudGVlZCgpO1xufTtcblxuUHJvbWlzZUFycmF5LnByb3RvdHlwZS5faXNSZXNvbHZlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5fdmFsdWVzID09PSBudWxsO1xufTtcblxuUHJvbWlzZUFycmF5LnByb3RvdHlwZS5fcmVzb2x2ZSA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgIHRoaXMuX3ZhbHVlcyA9IG51bGw7XG4gICAgdGhpcy5fcHJvbWlzZS5fZnVsZmlsbCh2YWx1ZSk7XG59O1xuXG5Qcm9taXNlQXJyYXkucHJvdG90eXBlLl9jYW5jZWwgPSBmdW5jdGlvbigpIHtcbiAgICBpZiAodGhpcy5faXNSZXNvbHZlZCgpIHx8ICF0aGlzLl9wcm9taXNlLl9pc0NhbmNlbGxhYmxlKCkpIHJldHVybjtcbiAgICB0aGlzLl92YWx1ZXMgPSBudWxsO1xuICAgIHRoaXMuX3Byb21pc2UuX2NhbmNlbCgpO1xufTtcblxuUHJvbWlzZUFycmF5LnByb3RvdHlwZS5fcmVqZWN0ID0gZnVuY3Rpb24gKHJlYXNvbikge1xuICAgIHRoaXMuX3ZhbHVlcyA9IG51bGw7XG4gICAgdGhpcy5fcHJvbWlzZS5fcmVqZWN0Q2FsbGJhY2socmVhc29uLCBmYWxzZSk7XG59O1xuXG5Qcm9taXNlQXJyYXkucHJvdG90eXBlLl9wcm9taXNlRnVsZmlsbGVkID0gZnVuY3Rpb24gKHZhbHVlLCBpbmRleCkge1xuICAgIHRoaXMuX3ZhbHVlc1tpbmRleF0gPSB2YWx1ZTtcbiAgICB2YXIgdG90YWxSZXNvbHZlZCA9ICsrdGhpcy5fdG90YWxSZXNvbHZlZDtcbiAgICBpZiAodG90YWxSZXNvbHZlZCA+PSB0aGlzLl9sZW5ndGgpIHtcbiAgICAgICAgdGhpcy5fcmVzb2x2ZSh0aGlzLl92YWx1ZXMpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufTtcblxuUHJvbWlzZUFycmF5LnByb3RvdHlwZS5fcHJvbWlzZUNhbmNlbGxlZCA9IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuX2NhbmNlbCgpO1xuICAgIHJldHVybiB0cnVlO1xufTtcblxuUHJvbWlzZUFycmF5LnByb3RvdHlwZS5fcHJvbWlzZVJlamVjdGVkID0gZnVuY3Rpb24gKHJlYXNvbikge1xuICAgIHRoaXMuX3RvdGFsUmVzb2x2ZWQrKztcbiAgICB0aGlzLl9yZWplY3QocmVhc29uKTtcbiAgICByZXR1cm4gdHJ1ZTtcbn07XG5cblByb21pc2VBcnJheS5wcm90b3R5cGUuX3Jlc3VsdENhbmNlbGxlZCA9IGZ1bmN0aW9uKCkge1xuICAgIGlmICh0aGlzLl9pc1Jlc29sdmVkKCkpIHJldHVybjtcbiAgICB2YXIgdmFsdWVzID0gdGhpcy5fdmFsdWVzO1xuICAgIHRoaXMuX2NhbmNlbCgpO1xuICAgIGlmICh2YWx1ZXMgaW5zdGFuY2VvZiBQcm9taXNlKSB7XG4gICAgICAgIHZhbHVlcy5jYW5jZWwoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHZhbHVlcy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgaWYgKHZhbHVlc1tpXSBpbnN0YW5jZW9mIFByb21pc2UpIHtcbiAgICAgICAgICAgICAgICB2YWx1ZXNbaV0uY2FuY2VsKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59O1xuXG5Qcm9taXNlQXJyYXkucHJvdG90eXBlLnNob3VsZENvcHlWYWx1ZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRydWU7XG59O1xuXG5Qcm9taXNlQXJyYXkucHJvdG90eXBlLmdldEFjdHVhbExlbmd0aCA9IGZ1bmN0aW9uIChsZW4pIHtcbiAgICByZXR1cm4gbGVuO1xufTtcblxucmV0dXJuIFByb21pc2VBcnJheTtcbn07XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvYmx1ZWJpcmQvanMvcmVsZWFzZS9wcm9taXNlX2FycmF5LmpzIiwiXCJ1c2Ugc3RyaWN0XCI7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKFByb21pc2UpIHtcbnZhciBsb25nU3RhY2tUcmFjZXMgPSBmYWxzZTtcbnZhciBjb250ZXh0U3RhY2sgPSBbXTtcblxuUHJvbWlzZS5wcm90b3R5cGUuX3Byb21pc2VDcmVhdGVkID0gZnVuY3Rpb24oKSB7fTtcblByb21pc2UucHJvdG90eXBlLl9wdXNoQ29udGV4dCA9IGZ1bmN0aW9uKCkge307XG5Qcm9taXNlLnByb3RvdHlwZS5fcG9wQ29udGV4dCA9IGZ1bmN0aW9uKCkge3JldHVybiBudWxsO307XG5Qcm9taXNlLl9wZWVrQ29udGV4dCA9IFByb21pc2UucHJvdG90eXBlLl9wZWVrQ29udGV4dCA9IGZ1bmN0aW9uKCkge307XG5cbmZ1bmN0aW9uIENvbnRleHQoKSB7XG4gICAgdGhpcy5fdHJhY2UgPSBuZXcgQ29udGV4dC5DYXB0dXJlZFRyYWNlKHBlZWtDb250ZXh0KCkpO1xufVxuQ29udGV4dC5wcm90b3R5cGUuX3B1c2hDb250ZXh0ID0gZnVuY3Rpb24gKCkge1xuICAgIGlmICh0aGlzLl90cmFjZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRoaXMuX3RyYWNlLl9wcm9taXNlQ3JlYXRlZCA9IG51bGw7XG4gICAgICAgIGNvbnRleHRTdGFjay5wdXNoKHRoaXMuX3RyYWNlKTtcbiAgICB9XG59O1xuXG5Db250ZXh0LnByb3RvdHlwZS5fcG9wQ29udGV4dCA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAodGhpcy5fdHJhY2UgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB2YXIgdHJhY2UgPSBjb250ZXh0U3RhY2sucG9wKCk7XG4gICAgICAgIHZhciByZXQgPSB0cmFjZS5fcHJvbWlzZUNyZWF0ZWQ7XG4gICAgICAgIHRyYWNlLl9wcm9taXNlQ3JlYXRlZCA9IG51bGw7XG4gICAgICAgIHJldHVybiByZXQ7XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xufTtcblxuZnVuY3Rpb24gY3JlYXRlQ29udGV4dCgpIHtcbiAgICBpZiAobG9uZ1N0YWNrVHJhY2VzKSByZXR1cm4gbmV3IENvbnRleHQoKTtcbn1cblxuZnVuY3Rpb24gcGVla0NvbnRleHQoKSB7XG4gICAgdmFyIGxhc3RJbmRleCA9IGNvbnRleHRTdGFjay5sZW5ndGggLSAxO1xuICAgIGlmIChsYXN0SW5kZXggPj0gMCkge1xuICAgICAgICByZXR1cm4gY29udGV4dFN0YWNrW2xhc3RJbmRleF07XG4gICAgfVxuICAgIHJldHVybiB1bmRlZmluZWQ7XG59XG5Db250ZXh0LkNhcHR1cmVkVHJhY2UgPSBudWxsO1xuQ29udGV4dC5jcmVhdGUgPSBjcmVhdGVDb250ZXh0O1xuQ29udGV4dC5kZWFjdGl2YXRlTG9uZ1N0YWNrVHJhY2VzID0gZnVuY3Rpb24oKSB7fTtcbkNvbnRleHQuYWN0aXZhdGVMb25nU3RhY2tUcmFjZXMgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgUHJvbWlzZV9wdXNoQ29udGV4dCA9IFByb21pc2UucHJvdG90eXBlLl9wdXNoQ29udGV4dDtcbiAgICB2YXIgUHJvbWlzZV9wb3BDb250ZXh0ID0gUHJvbWlzZS5wcm90b3R5cGUuX3BvcENvbnRleHQ7XG4gICAgdmFyIFByb21pc2VfUGVla0NvbnRleHQgPSBQcm9taXNlLl9wZWVrQ29udGV4dDtcbiAgICB2YXIgUHJvbWlzZV9wZWVrQ29udGV4dCA9IFByb21pc2UucHJvdG90eXBlLl9wZWVrQ29udGV4dDtcbiAgICB2YXIgUHJvbWlzZV9wcm9taXNlQ3JlYXRlZCA9IFByb21pc2UucHJvdG90eXBlLl9wcm9taXNlQ3JlYXRlZDtcbiAgICBDb250ZXh0LmRlYWN0aXZhdGVMb25nU3RhY2tUcmFjZXMgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgUHJvbWlzZS5wcm90b3R5cGUuX3B1c2hDb250ZXh0ID0gUHJvbWlzZV9wdXNoQ29udGV4dDtcbiAgICAgICAgUHJvbWlzZS5wcm90b3R5cGUuX3BvcENvbnRleHQgPSBQcm9taXNlX3BvcENvbnRleHQ7XG4gICAgICAgIFByb21pc2UuX3BlZWtDb250ZXh0ID0gUHJvbWlzZV9QZWVrQ29udGV4dDtcbiAgICAgICAgUHJvbWlzZS5wcm90b3R5cGUuX3BlZWtDb250ZXh0ID0gUHJvbWlzZV9wZWVrQ29udGV4dDtcbiAgICAgICAgUHJvbWlzZS5wcm90b3R5cGUuX3Byb21pc2VDcmVhdGVkID0gUHJvbWlzZV9wcm9taXNlQ3JlYXRlZDtcbiAgICAgICAgbG9uZ1N0YWNrVHJhY2VzID0gZmFsc2U7XG4gICAgfTtcbiAgICBsb25nU3RhY2tUcmFjZXMgPSB0cnVlO1xuICAgIFByb21pc2UucHJvdG90eXBlLl9wdXNoQ29udGV4dCA9IENvbnRleHQucHJvdG90eXBlLl9wdXNoQ29udGV4dDtcbiAgICBQcm9taXNlLnByb3RvdHlwZS5fcG9wQ29udGV4dCA9IENvbnRleHQucHJvdG90eXBlLl9wb3BDb250ZXh0O1xuICAgIFByb21pc2UuX3BlZWtDb250ZXh0ID0gUHJvbWlzZS5wcm90b3R5cGUuX3BlZWtDb250ZXh0ID0gcGVla0NvbnRleHQ7XG4gICAgUHJvbWlzZS5wcm90b3R5cGUuX3Byb21pc2VDcmVhdGVkID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBjdHggPSB0aGlzLl9wZWVrQ29udGV4dCgpO1xuICAgICAgICBpZiAoY3R4ICYmIGN0eC5fcHJvbWlzZUNyZWF0ZWQgPT0gbnVsbCkgY3R4Ll9wcm9taXNlQ3JlYXRlZCA9IHRoaXM7XG4gICAgfTtcbn07XG5yZXR1cm4gQ29udGV4dDtcbn07XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvYmx1ZWJpcmQvanMvcmVsZWFzZS9jb250ZXh0LmpzIiwiXCJ1c2Ugc3RyaWN0XCI7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKFByb21pc2UsIENvbnRleHQpIHtcbnZhciBnZXREb21haW4gPSBQcm9taXNlLl9nZXREb21haW47XG52YXIgYXN5bmMgPSBQcm9taXNlLl9hc3luYztcbnZhciBXYXJuaW5nID0gcmVxdWlyZShcIi4vZXJyb3JzXCIpLldhcm5pbmc7XG52YXIgdXRpbCA9IHJlcXVpcmUoXCIuL3V0aWxcIik7XG52YXIgY2FuQXR0YWNoVHJhY2UgPSB1dGlsLmNhbkF0dGFjaFRyYWNlO1xudmFyIHVuaGFuZGxlZFJlamVjdGlvbkhhbmRsZWQ7XG52YXIgcG9zc2libHlVbmhhbmRsZWRSZWplY3Rpb247XG52YXIgYmx1ZWJpcmRGcmFtZVBhdHRlcm4gPVxuICAgIC9bXFxcXFxcL11ibHVlYmlyZFtcXFxcXFwvXWpzW1xcXFxcXC9dKHJlbGVhc2V8ZGVidWd8aW5zdHJ1bWVudGVkKS87XG52YXIgbm9kZUZyYW1lUGF0dGVybiA9IC9cXCgoPzp0aW1lcnNcXC5qcyk6XFxkKzpcXGQrXFwpLztcbnZhciBwYXJzZUxpbmVQYXR0ZXJuID0gL1tcXC88XFwoXSguKz8pOihcXGQrKTooXFxkKylcXCk/XFxzKiQvO1xudmFyIHN0YWNrRnJhbWVQYXR0ZXJuID0gbnVsbDtcbnZhciBmb3JtYXRTdGFjayA9IG51bGw7XG52YXIgaW5kZW50U3RhY2tGcmFtZXMgPSBmYWxzZTtcbnZhciBwcmludFdhcm5pbmc7XG52YXIgZGVidWdnaW5nID0gISEodXRpbC5lbnYoXCJCTFVFQklSRF9ERUJVR1wiKSAhPSAwICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAoZmFsc2UgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICB1dGlsLmVudihcIkJMVUVCSVJEX0RFQlVHXCIpIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgdXRpbC5lbnYoXCJOT0RFX0VOVlwiKSA9PT0gXCJkZXZlbG9wbWVudFwiKSk7XG5cbnZhciB3YXJuaW5ncyA9ICEhKHV0aWwuZW52KFwiQkxVRUJJUkRfV0FSTklOR1NcIikgIT0gMCAmJlxuICAgIChkZWJ1Z2dpbmcgfHwgdXRpbC5lbnYoXCJCTFVFQklSRF9XQVJOSU5HU1wiKSkpO1xuXG52YXIgbG9uZ1N0YWNrVHJhY2VzID0gISEodXRpbC5lbnYoXCJCTFVFQklSRF9MT05HX1NUQUNLX1RSQUNFU1wiKSAhPSAwICYmXG4gICAgKGRlYnVnZ2luZyB8fCB1dGlsLmVudihcIkJMVUVCSVJEX0xPTkdfU1RBQ0tfVFJBQ0VTXCIpKSk7XG5cbnZhciB3Rm9yZ290dGVuUmV0dXJuID0gdXRpbC5lbnYoXCJCTFVFQklSRF9XX0ZPUkdPVFRFTl9SRVRVUk5cIikgIT0gMCAmJlxuICAgICh3YXJuaW5ncyB8fCAhIXV0aWwuZW52KFwiQkxVRUJJUkRfV19GT1JHT1RURU5fUkVUVVJOXCIpKTtcblxuUHJvbWlzZS5wcm90b3R5cGUuc3VwcHJlc3NVbmhhbmRsZWRSZWplY3Rpb25zID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHRhcmdldCA9IHRoaXMuX3RhcmdldCgpO1xuICAgIHRhcmdldC5fYml0RmllbGQgPSAoKHRhcmdldC5fYml0RmllbGQgJiAofjEwNDg1NzYpKSB8XG4gICAgICAgICAgICAgICAgICAgICAgNTI0Mjg4KTtcbn07XG5cblByb21pc2UucHJvdG90eXBlLl9lbnN1cmVQb3NzaWJsZVJlamVjdGlvbkhhbmRsZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKCh0aGlzLl9iaXRGaWVsZCAmIDUyNDI4OCkgIT09IDApIHJldHVybjtcbiAgICB0aGlzLl9zZXRSZWplY3Rpb25Jc1VuaGFuZGxlZCgpO1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICBzZWxmLl9ub3RpZnlVbmhhbmRsZWRSZWplY3Rpb24oKTtcbiAgICB9LCAxKTtcbn07XG5cblByb21pc2UucHJvdG90eXBlLl9ub3RpZnlVbmhhbmRsZWRSZWplY3Rpb25Jc0hhbmRsZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgZmlyZVJlamVjdGlvbkV2ZW50KFwicmVqZWN0aW9uSGFuZGxlZFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVuaGFuZGxlZFJlamVjdGlvbkhhbmRsZWQsIHVuZGVmaW5lZCwgdGhpcyk7XG59O1xuXG5Qcm9taXNlLnByb3RvdHlwZS5fc2V0UmV0dXJuZWROb25VbmRlZmluZWQgPSBmdW5jdGlvbigpIHtcbiAgICB0aGlzLl9iaXRGaWVsZCA9IHRoaXMuX2JpdEZpZWxkIHwgMjY4NDM1NDU2O1xufTtcblxuUHJvbWlzZS5wcm90b3R5cGUuX3JldHVybmVkTm9uVW5kZWZpbmVkID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuICh0aGlzLl9iaXRGaWVsZCAmIDI2ODQzNTQ1NikgIT09IDA7XG59O1xuXG5Qcm9taXNlLnByb3RvdHlwZS5fbm90aWZ5VW5oYW5kbGVkUmVqZWN0aW9uID0gZnVuY3Rpb24gKCkge1xuICAgIGlmICh0aGlzLl9pc1JlamVjdGlvblVuaGFuZGxlZCgpKSB7XG4gICAgICAgIHZhciByZWFzb24gPSB0aGlzLl9zZXR0bGVkVmFsdWUoKTtcbiAgICAgICAgdGhpcy5fc2V0VW5oYW5kbGVkUmVqZWN0aW9uSXNOb3RpZmllZCgpO1xuICAgICAgICBmaXJlUmVqZWN0aW9uRXZlbnQoXCJ1bmhhbmRsZWRSZWplY3Rpb25cIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcG9zc2libHlVbmhhbmRsZWRSZWplY3Rpb24sIHJlYXNvbiwgdGhpcyk7XG4gICAgfVxufTtcblxuUHJvbWlzZS5wcm90b3R5cGUuX3NldFVuaGFuZGxlZFJlamVjdGlvbklzTm90aWZpZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5fYml0RmllbGQgPSB0aGlzLl9iaXRGaWVsZCB8IDI2MjE0NDtcbn07XG5cblByb21pc2UucHJvdG90eXBlLl91bnNldFVuaGFuZGxlZFJlamVjdGlvbklzTm90aWZpZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5fYml0RmllbGQgPSB0aGlzLl9iaXRGaWVsZCAmICh+MjYyMTQ0KTtcbn07XG5cblByb21pc2UucHJvdG90eXBlLl9pc1VuaGFuZGxlZFJlamVjdGlvbk5vdGlmaWVkID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiAodGhpcy5fYml0RmllbGQgJiAyNjIxNDQpID4gMDtcbn07XG5cblByb21pc2UucHJvdG90eXBlLl9zZXRSZWplY3Rpb25Jc1VuaGFuZGxlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLl9iaXRGaWVsZCA9IHRoaXMuX2JpdEZpZWxkIHwgMTA0ODU3Njtcbn07XG5cblByb21pc2UucHJvdG90eXBlLl91bnNldFJlamVjdGlvbklzVW5oYW5kbGVkID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuX2JpdEZpZWxkID0gdGhpcy5fYml0RmllbGQgJiAofjEwNDg1NzYpO1xuICAgIGlmICh0aGlzLl9pc1VuaGFuZGxlZFJlamVjdGlvbk5vdGlmaWVkKCkpIHtcbiAgICAgICAgdGhpcy5fdW5zZXRVbmhhbmRsZWRSZWplY3Rpb25Jc05vdGlmaWVkKCk7XG4gICAgICAgIHRoaXMuX25vdGlmeVVuaGFuZGxlZFJlamVjdGlvbklzSGFuZGxlZCgpO1xuICAgIH1cbn07XG5cblByb21pc2UucHJvdG90eXBlLl9pc1JlamVjdGlvblVuaGFuZGxlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gKHRoaXMuX2JpdEZpZWxkICYgMTA0ODU3NikgPiAwO1xufTtcblxuUHJvbWlzZS5wcm90b3R5cGUuX3dhcm4gPSBmdW5jdGlvbihtZXNzYWdlLCBzaG91bGRVc2VPd25UcmFjZSwgcHJvbWlzZSkge1xuICAgIHJldHVybiB3YXJuKG1lc3NhZ2UsIHNob3VsZFVzZU93blRyYWNlLCBwcm9taXNlIHx8IHRoaXMpO1xufTtcblxuUHJvbWlzZS5vblBvc3NpYmx5VW5oYW5kbGVkUmVqZWN0aW9uID0gZnVuY3Rpb24gKGZuKSB7XG4gICAgdmFyIGRvbWFpbiA9IGdldERvbWFpbigpO1xuICAgIHBvc3NpYmx5VW5oYW5kbGVkUmVqZWN0aW9uID1cbiAgICAgICAgdHlwZW9mIGZuID09PSBcImZ1bmN0aW9uXCIgPyAoZG9tYWluID09PSBudWxsID9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm4gOiB1dGlsLmRvbWFpbkJpbmQoZG9tYWluLCBmbikpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZDtcbn07XG5cblByb21pc2Uub25VbmhhbmRsZWRSZWplY3Rpb25IYW5kbGVkID0gZnVuY3Rpb24gKGZuKSB7XG4gICAgdmFyIGRvbWFpbiA9IGdldERvbWFpbigpO1xuICAgIHVuaGFuZGxlZFJlamVjdGlvbkhhbmRsZWQgPVxuICAgICAgICB0eXBlb2YgZm4gPT09IFwiZnVuY3Rpb25cIiA/IChkb21haW4gPT09IG51bGwgP1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmbiA6IHV0aWwuZG9tYWluQmluZChkb21haW4sIGZuKSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkO1xufTtcblxudmFyIGRpc2FibGVMb25nU3RhY2tUcmFjZXMgPSBmdW5jdGlvbigpIHt9O1xuUHJvbWlzZS5sb25nU3RhY2tUcmFjZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKGFzeW5jLmhhdmVJdGVtc1F1ZXVlZCgpICYmICFjb25maWcubG9uZ1N0YWNrVHJhY2VzKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcImNhbm5vdCBlbmFibGUgbG9uZyBzdGFjayB0cmFjZXMgYWZ0ZXIgcHJvbWlzZXMgaGF2ZSBiZWVuIGNyZWF0ZWRcXHUwMDBhXFx1MDAwYSAgICBTZWUgaHR0cDovL2dvby5nbC9NcXJGbVhcXHUwMDBhXCIpO1xuICAgIH1cbiAgICBpZiAoIWNvbmZpZy5sb25nU3RhY2tUcmFjZXMgJiYgbG9uZ1N0YWNrVHJhY2VzSXNTdXBwb3J0ZWQoKSkge1xuICAgICAgICB2YXIgUHJvbWlzZV9jYXB0dXJlU3RhY2tUcmFjZSA9IFByb21pc2UucHJvdG90eXBlLl9jYXB0dXJlU3RhY2tUcmFjZTtcbiAgICAgICAgdmFyIFByb21pc2VfYXR0YWNoRXh0cmFUcmFjZSA9IFByb21pc2UucHJvdG90eXBlLl9hdHRhY2hFeHRyYVRyYWNlO1xuICAgICAgICBjb25maWcubG9uZ1N0YWNrVHJhY2VzID0gdHJ1ZTtcbiAgICAgICAgZGlzYWJsZUxvbmdTdGFja1RyYWNlcyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgaWYgKGFzeW5jLmhhdmVJdGVtc1F1ZXVlZCgpICYmICFjb25maWcubG9uZ1N0YWNrVHJhY2VzKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiY2Fubm90IGVuYWJsZSBsb25nIHN0YWNrIHRyYWNlcyBhZnRlciBwcm9taXNlcyBoYXZlIGJlZW4gY3JlYXRlZFxcdTAwMGFcXHUwMDBhICAgIFNlZSBodHRwOi8vZ29vLmdsL01xckZtWFxcdTAwMGFcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBQcm9taXNlLnByb3RvdHlwZS5fY2FwdHVyZVN0YWNrVHJhY2UgPSBQcm9taXNlX2NhcHR1cmVTdGFja1RyYWNlO1xuICAgICAgICAgICAgUHJvbWlzZS5wcm90b3R5cGUuX2F0dGFjaEV4dHJhVHJhY2UgPSBQcm9taXNlX2F0dGFjaEV4dHJhVHJhY2U7XG4gICAgICAgICAgICBDb250ZXh0LmRlYWN0aXZhdGVMb25nU3RhY2tUcmFjZXMoKTtcbiAgICAgICAgICAgIGFzeW5jLmVuYWJsZVRyYW1wb2xpbmUoKTtcbiAgICAgICAgICAgIGNvbmZpZy5sb25nU3RhY2tUcmFjZXMgPSBmYWxzZTtcbiAgICAgICAgfTtcbiAgICAgICAgUHJvbWlzZS5wcm90b3R5cGUuX2NhcHR1cmVTdGFja1RyYWNlID0gbG9uZ1N0YWNrVHJhY2VzQ2FwdHVyZVN0YWNrVHJhY2U7XG4gICAgICAgIFByb21pc2UucHJvdG90eXBlLl9hdHRhY2hFeHRyYVRyYWNlID0gbG9uZ1N0YWNrVHJhY2VzQXR0YWNoRXh0cmFUcmFjZTtcbiAgICAgICAgQ29udGV4dC5hY3RpdmF0ZUxvbmdTdGFja1RyYWNlcygpO1xuICAgICAgICBhc3luYy5kaXNhYmxlVHJhbXBvbGluZUlmTmVjZXNzYXJ5KCk7XG4gICAgfVxufTtcblxuUHJvbWlzZS5oYXNMb25nU3RhY2tUcmFjZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIGNvbmZpZy5sb25nU3RhY2tUcmFjZXMgJiYgbG9uZ1N0YWNrVHJhY2VzSXNTdXBwb3J0ZWQoKTtcbn07XG5cbnZhciBmaXJlRG9tRXZlbnQgPSAoZnVuY3Rpb24oKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgaWYgKHR5cGVvZiBDdXN0b21FdmVudCA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICB2YXIgZXZlbnQgPSBuZXcgQ3VzdG9tRXZlbnQoXCJDdXN0b21FdmVudFwiKTtcbiAgICAgICAgICAgIHV0aWwuZ2xvYmFsLmRpc3BhdGNoRXZlbnQoZXZlbnQpO1xuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKG5hbWUsIGV2ZW50KSB7XG4gICAgICAgICAgICAgICAgdmFyIGRvbUV2ZW50ID0gbmV3IEN1c3RvbUV2ZW50KG5hbWUudG9Mb3dlckNhc2UoKSwge1xuICAgICAgICAgICAgICAgICAgICBkZXRhaWw6IGV2ZW50LFxuICAgICAgICAgICAgICAgICAgICBjYW5jZWxhYmxlOiB0cnVlXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuICF1dGlsLmdsb2JhbC5kaXNwYXRjaEV2ZW50KGRvbUV2ZW50KTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIEV2ZW50ID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgIHZhciBldmVudCA9IG5ldyBFdmVudChcIkN1c3RvbUV2ZW50XCIpO1xuICAgICAgICAgICAgdXRpbC5nbG9iYWwuZGlzcGF0Y2hFdmVudChldmVudCk7XG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24obmFtZSwgZXZlbnQpIHtcbiAgICAgICAgICAgICAgICB2YXIgZG9tRXZlbnQgPSBuZXcgRXZlbnQobmFtZS50b0xvd2VyQ2FzZSgpLCB7XG4gICAgICAgICAgICAgICAgICAgIGNhbmNlbGFibGU6IHRydWVcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBkb21FdmVudC5kZXRhaWwgPSBldmVudDtcbiAgICAgICAgICAgICAgICByZXR1cm4gIXV0aWwuZ2xvYmFsLmRpc3BhdGNoRXZlbnQoZG9tRXZlbnQpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhciBldmVudCA9IGRvY3VtZW50LmNyZWF0ZUV2ZW50KFwiQ3VzdG9tRXZlbnRcIik7XG4gICAgICAgICAgICBldmVudC5pbml0Q3VzdG9tRXZlbnQoXCJ0ZXN0aW5ndGhlZXZlbnRcIiwgZmFsc2UsIHRydWUsIHt9KTtcbiAgICAgICAgICAgIHV0aWwuZ2xvYmFsLmRpc3BhdGNoRXZlbnQoZXZlbnQpO1xuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKG5hbWUsIGV2ZW50KSB7XG4gICAgICAgICAgICAgICAgdmFyIGRvbUV2ZW50ID0gZG9jdW1lbnQuY3JlYXRlRXZlbnQoXCJDdXN0b21FdmVudFwiKTtcbiAgICAgICAgICAgICAgICBkb21FdmVudC5pbml0Q3VzdG9tRXZlbnQobmFtZS50b0xvd2VyQ2FzZSgpLCBmYWxzZSwgdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgZXZlbnQpO1xuICAgICAgICAgICAgICAgIHJldHVybiAhdXRpbC5nbG9iYWwuZGlzcGF0Y2hFdmVudChkb21FdmVudCk7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgfSBjYXRjaCAoZSkge31cbiAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9O1xufSkoKTtcblxudmFyIGZpcmVHbG9iYWxFdmVudCA9IChmdW5jdGlvbigpIHtcbiAgICBpZiAodXRpbC5pc05vZGUpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIHByb2Nlc3MuZW1pdC5hcHBseShwcm9jZXNzLCBhcmd1bWVudHMpO1xuICAgICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGlmICghdXRpbC5nbG9iYWwpIHtcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmdW5jdGlvbihuYW1lKSB7XG4gICAgICAgICAgICB2YXIgbWV0aG9kTmFtZSA9IFwib25cIiArIG5hbWUudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICAgIHZhciBtZXRob2QgPSB1dGlsLmdsb2JhbFttZXRob2ROYW1lXTtcbiAgICAgICAgICAgIGlmICghbWV0aG9kKSByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICBtZXRob2QuYXBwbHkodXRpbC5nbG9iYWwsIFtdLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKSk7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfTtcbiAgICB9XG59KSgpO1xuXG5mdW5jdGlvbiBnZW5lcmF0ZVByb21pc2VMaWZlY3ljbGVFdmVudE9iamVjdChuYW1lLCBwcm9taXNlKSB7XG4gICAgcmV0dXJuIHtwcm9taXNlOiBwcm9taXNlfTtcbn1cblxudmFyIGV2ZW50VG9PYmplY3RHZW5lcmF0b3IgPSB7XG4gICAgcHJvbWlzZUNyZWF0ZWQ6IGdlbmVyYXRlUHJvbWlzZUxpZmVjeWNsZUV2ZW50T2JqZWN0LFxuICAgIHByb21pc2VGdWxmaWxsZWQ6IGdlbmVyYXRlUHJvbWlzZUxpZmVjeWNsZUV2ZW50T2JqZWN0LFxuICAgIHByb21pc2VSZWplY3RlZDogZ2VuZXJhdGVQcm9taXNlTGlmZWN5Y2xlRXZlbnRPYmplY3QsXG4gICAgcHJvbWlzZVJlc29sdmVkOiBnZW5lcmF0ZVByb21pc2VMaWZlY3ljbGVFdmVudE9iamVjdCxcbiAgICBwcm9taXNlQ2FuY2VsbGVkOiBnZW5lcmF0ZVByb21pc2VMaWZlY3ljbGVFdmVudE9iamVjdCxcbiAgICBwcm9taXNlQ2hhaW5lZDogZnVuY3Rpb24obmFtZSwgcHJvbWlzZSwgY2hpbGQpIHtcbiAgICAgICAgcmV0dXJuIHtwcm9taXNlOiBwcm9taXNlLCBjaGlsZDogY2hpbGR9O1xuICAgIH0sXG4gICAgd2FybmluZzogZnVuY3Rpb24obmFtZSwgd2FybmluZykge1xuICAgICAgICByZXR1cm4ge3dhcm5pbmc6IHdhcm5pbmd9O1xuICAgIH0sXG4gICAgdW5oYW5kbGVkUmVqZWN0aW9uOiBmdW5jdGlvbiAobmFtZSwgcmVhc29uLCBwcm9taXNlKSB7XG4gICAgICAgIHJldHVybiB7cmVhc29uOiByZWFzb24sIHByb21pc2U6IHByb21pc2V9O1xuICAgIH0sXG4gICAgcmVqZWN0aW9uSGFuZGxlZDogZ2VuZXJhdGVQcm9taXNlTGlmZWN5Y2xlRXZlbnRPYmplY3Rcbn07XG5cbnZhciBhY3RpdmVGaXJlRXZlbnQgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgIHZhciBnbG9iYWxFdmVudEZpcmVkID0gZmFsc2U7XG4gICAgdHJ5IHtcbiAgICAgICAgZ2xvYmFsRXZlbnRGaXJlZCA9IGZpcmVHbG9iYWxFdmVudC5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgYXN5bmMudGhyb3dMYXRlcihlKTtcbiAgICAgICAgZ2xvYmFsRXZlbnRGaXJlZCA9IHRydWU7XG4gICAgfVxuXG4gICAgdmFyIGRvbUV2ZW50RmlyZWQgPSBmYWxzZTtcbiAgICB0cnkge1xuICAgICAgICBkb21FdmVudEZpcmVkID0gZmlyZURvbUV2ZW50KG5hbWUsXG4gICAgICAgICAgICAgICAgICAgIGV2ZW50VG9PYmplY3RHZW5lcmF0b3JbbmFtZV0uYXBwbHkobnVsbCwgYXJndW1lbnRzKSk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBhc3luYy50aHJvd0xhdGVyKGUpO1xuICAgICAgICBkb21FdmVudEZpcmVkID0gdHJ1ZTtcbiAgICB9XG5cbiAgICByZXR1cm4gZG9tRXZlbnRGaXJlZCB8fCBnbG9iYWxFdmVudEZpcmVkO1xufTtcblxuUHJvbWlzZS5jb25maWcgPSBmdW5jdGlvbihvcHRzKSB7XG4gICAgb3B0cyA9IE9iamVjdChvcHRzKTtcbiAgICBpZiAoXCJsb25nU3RhY2tUcmFjZXNcIiBpbiBvcHRzKSB7XG4gICAgICAgIGlmIChvcHRzLmxvbmdTdGFja1RyYWNlcykge1xuICAgICAgICAgICAgUHJvbWlzZS5sb25nU3RhY2tUcmFjZXMoKTtcbiAgICAgICAgfSBlbHNlIGlmICghb3B0cy5sb25nU3RhY2tUcmFjZXMgJiYgUHJvbWlzZS5oYXNMb25nU3RhY2tUcmFjZXMoKSkge1xuICAgICAgICAgICAgZGlzYWJsZUxvbmdTdGFja1RyYWNlcygpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChcIndhcm5pbmdzXCIgaW4gb3B0cykge1xuICAgICAgICB2YXIgd2FybmluZ3NPcHRpb24gPSBvcHRzLndhcm5pbmdzO1xuICAgICAgICBjb25maWcud2FybmluZ3MgPSAhIXdhcm5pbmdzT3B0aW9uO1xuICAgICAgICB3Rm9yZ290dGVuUmV0dXJuID0gY29uZmlnLndhcm5pbmdzO1xuXG4gICAgICAgIGlmICh1dGlsLmlzT2JqZWN0KHdhcm5pbmdzT3B0aW9uKSkge1xuICAgICAgICAgICAgaWYgKFwid0ZvcmdvdHRlblJldHVyblwiIGluIHdhcm5pbmdzT3B0aW9uKSB7XG4gICAgICAgICAgICAgICAgd0ZvcmdvdHRlblJldHVybiA9ICEhd2FybmluZ3NPcHRpb24ud0ZvcmdvdHRlblJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoXCJjYW5jZWxsYXRpb25cIiBpbiBvcHRzICYmIG9wdHMuY2FuY2VsbGF0aW9uICYmICFjb25maWcuY2FuY2VsbGF0aW9uKSB7XG4gICAgICAgIGlmIChhc3luYy5oYXZlSXRlbXNRdWV1ZWQoKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICAgICAgIFwiY2Fubm90IGVuYWJsZSBjYW5jZWxsYXRpb24gYWZ0ZXIgcHJvbWlzZXMgYXJlIGluIHVzZVwiKTtcbiAgICAgICAgfVxuICAgICAgICBQcm9taXNlLnByb3RvdHlwZS5fY2xlYXJDYW5jZWxsYXRpb25EYXRhID1cbiAgICAgICAgICAgIGNhbmNlbGxhdGlvbkNsZWFyQ2FuY2VsbGF0aW9uRGF0YTtcbiAgICAgICAgUHJvbWlzZS5wcm90b3R5cGUuX3Byb3BhZ2F0ZUZyb20gPSBjYW5jZWxsYXRpb25Qcm9wYWdhdGVGcm9tO1xuICAgICAgICBQcm9taXNlLnByb3RvdHlwZS5fb25DYW5jZWwgPSBjYW5jZWxsYXRpb25PbkNhbmNlbDtcbiAgICAgICAgUHJvbWlzZS5wcm90b3R5cGUuX3NldE9uQ2FuY2VsID0gY2FuY2VsbGF0aW9uU2V0T25DYW5jZWw7XG4gICAgICAgIFByb21pc2UucHJvdG90eXBlLl9hdHRhY2hDYW5jZWxsYXRpb25DYWxsYmFjayA9XG4gICAgICAgICAgICBjYW5jZWxsYXRpb25BdHRhY2hDYW5jZWxsYXRpb25DYWxsYmFjaztcbiAgICAgICAgUHJvbWlzZS5wcm90b3R5cGUuX2V4ZWN1dGUgPSBjYW5jZWxsYXRpb25FeGVjdXRlO1xuICAgICAgICBwcm9wYWdhdGVGcm9tRnVuY3Rpb24gPSBjYW5jZWxsYXRpb25Qcm9wYWdhdGVGcm9tO1xuICAgICAgICBjb25maWcuY2FuY2VsbGF0aW9uID0gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKFwibW9uaXRvcmluZ1wiIGluIG9wdHMpIHtcbiAgICAgICAgaWYgKG9wdHMubW9uaXRvcmluZyAmJiAhY29uZmlnLm1vbml0b3JpbmcpIHtcbiAgICAgICAgICAgIGNvbmZpZy5tb25pdG9yaW5nID0gdHJ1ZTtcbiAgICAgICAgICAgIFByb21pc2UucHJvdG90eXBlLl9maXJlRXZlbnQgPSBhY3RpdmVGaXJlRXZlbnQ7XG4gICAgICAgIH0gZWxzZSBpZiAoIW9wdHMubW9uaXRvcmluZyAmJiBjb25maWcubW9uaXRvcmluZykge1xuICAgICAgICAgICAgY29uZmlnLm1vbml0b3JpbmcgPSBmYWxzZTtcbiAgICAgICAgICAgIFByb21pc2UucHJvdG90eXBlLl9maXJlRXZlbnQgPSBkZWZhdWx0RmlyZUV2ZW50O1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBQcm9taXNlO1xufTtcblxuZnVuY3Rpb24gZGVmYXVsdEZpcmVFdmVudCgpIHsgcmV0dXJuIGZhbHNlOyB9XG5cblByb21pc2UucHJvdG90eXBlLl9maXJlRXZlbnQgPSBkZWZhdWx0RmlyZUV2ZW50O1xuUHJvbWlzZS5wcm90b3R5cGUuX2V4ZWN1dGUgPSBmdW5jdGlvbihleGVjdXRvciwgcmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgdHJ5IHtcbiAgICAgICAgZXhlY3V0b3IocmVzb2x2ZSwgcmVqZWN0KTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIHJldHVybiBlO1xuICAgIH1cbn07XG5Qcm9taXNlLnByb3RvdHlwZS5fb25DYW5jZWwgPSBmdW5jdGlvbiAoKSB7fTtcblByb21pc2UucHJvdG90eXBlLl9zZXRPbkNhbmNlbCA9IGZ1bmN0aW9uIChoYW5kbGVyKSB7IDsgfTtcblByb21pc2UucHJvdG90eXBlLl9hdHRhY2hDYW5jZWxsYXRpb25DYWxsYmFjayA9IGZ1bmN0aW9uKG9uQ2FuY2VsKSB7XG4gICAgO1xufTtcblByb21pc2UucHJvdG90eXBlLl9jYXB0dXJlU3RhY2tUcmFjZSA9IGZ1bmN0aW9uICgpIHt9O1xuUHJvbWlzZS5wcm90b3R5cGUuX2F0dGFjaEV4dHJhVHJhY2UgPSBmdW5jdGlvbiAoKSB7fTtcblByb21pc2UucHJvdG90eXBlLl9jbGVhckNhbmNlbGxhdGlvbkRhdGEgPSBmdW5jdGlvbigpIHt9O1xuUHJvbWlzZS5wcm90b3R5cGUuX3Byb3BhZ2F0ZUZyb20gPSBmdW5jdGlvbiAocGFyZW50LCBmbGFncykge1xuICAgIDtcbiAgICA7XG59O1xuXG5mdW5jdGlvbiBjYW5jZWxsYXRpb25FeGVjdXRlKGV4ZWN1dG9yLCByZXNvbHZlLCByZWplY3QpIHtcbiAgICB2YXIgcHJvbWlzZSA9IHRoaXM7XG4gICAgdHJ5IHtcbiAgICAgICAgZXhlY3V0b3IocmVzb2x2ZSwgcmVqZWN0LCBmdW5jdGlvbihvbkNhbmNlbCkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBvbkNhbmNlbCAhPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIm9uQ2FuY2VsIG11c3QgYmUgYSBmdW5jdGlvbiwgZ290OiBcIiArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB1dGlsLnRvU3RyaW5nKG9uQ2FuY2VsKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwcm9taXNlLl9hdHRhY2hDYW5jZWxsYXRpb25DYWxsYmFjayhvbkNhbmNlbCk7XG4gICAgICAgIH0pO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgcmV0dXJuIGU7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBjYW5jZWxsYXRpb25BdHRhY2hDYW5jZWxsYXRpb25DYWxsYmFjayhvbkNhbmNlbCkge1xuICAgIGlmICghdGhpcy5faXNDYW5jZWxsYWJsZSgpKSByZXR1cm4gdGhpcztcblxuICAgIHZhciBwcmV2aW91c09uQ2FuY2VsID0gdGhpcy5fb25DYW5jZWwoKTtcbiAgICBpZiAocHJldmlvdXNPbkNhbmNlbCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGlmICh1dGlsLmlzQXJyYXkocHJldmlvdXNPbkNhbmNlbCkpIHtcbiAgICAgICAgICAgIHByZXZpb3VzT25DYW5jZWwucHVzaChvbkNhbmNlbCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl9zZXRPbkNhbmNlbChbcHJldmlvdXNPbkNhbmNlbCwgb25DYW5jZWxdKTtcbiAgICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuX3NldE9uQ2FuY2VsKG9uQ2FuY2VsKTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGNhbmNlbGxhdGlvbk9uQ2FuY2VsKCkge1xuICAgIHJldHVybiB0aGlzLl9vbkNhbmNlbEZpZWxkO1xufVxuXG5mdW5jdGlvbiBjYW5jZWxsYXRpb25TZXRPbkNhbmNlbChvbkNhbmNlbCkge1xuICAgIHRoaXMuX29uQ2FuY2VsRmllbGQgPSBvbkNhbmNlbDtcbn1cblxuZnVuY3Rpb24gY2FuY2VsbGF0aW9uQ2xlYXJDYW5jZWxsYXRpb25EYXRhKCkge1xuICAgIHRoaXMuX2NhbmNlbGxhdGlvblBhcmVudCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLl9vbkNhbmNlbEZpZWxkID0gdW5kZWZpbmVkO1xufVxuXG5mdW5jdGlvbiBjYW5jZWxsYXRpb25Qcm9wYWdhdGVGcm9tKHBhcmVudCwgZmxhZ3MpIHtcbiAgICBpZiAoKGZsYWdzICYgMSkgIT09IDApIHtcbiAgICAgICAgdGhpcy5fY2FuY2VsbGF0aW9uUGFyZW50ID0gcGFyZW50O1xuICAgICAgICB2YXIgYnJhbmNoZXNSZW1haW5pbmdUb0NhbmNlbCA9IHBhcmVudC5fYnJhbmNoZXNSZW1haW5pbmdUb0NhbmNlbDtcbiAgICAgICAgaWYgKGJyYW5jaGVzUmVtYWluaW5nVG9DYW5jZWwgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgYnJhbmNoZXNSZW1haW5pbmdUb0NhbmNlbCA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgcGFyZW50Ll9icmFuY2hlc1JlbWFpbmluZ1RvQ2FuY2VsID0gYnJhbmNoZXNSZW1haW5pbmdUb0NhbmNlbCArIDE7XG4gICAgfVxuICAgIGlmICgoZmxhZ3MgJiAyKSAhPT0gMCAmJiBwYXJlbnQuX2lzQm91bmQoKSkge1xuICAgICAgICB0aGlzLl9zZXRCb3VuZFRvKHBhcmVudC5fYm91bmRUbyk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBiaW5kaW5nUHJvcGFnYXRlRnJvbShwYXJlbnQsIGZsYWdzKSB7XG4gICAgaWYgKChmbGFncyAmIDIpICE9PSAwICYmIHBhcmVudC5faXNCb3VuZCgpKSB7XG4gICAgICAgIHRoaXMuX3NldEJvdW5kVG8ocGFyZW50Ll9ib3VuZFRvKTtcbiAgICB9XG59XG52YXIgcHJvcGFnYXRlRnJvbUZ1bmN0aW9uID0gYmluZGluZ1Byb3BhZ2F0ZUZyb207XG5cbmZ1bmN0aW9uIGJvdW5kVmFsdWVGdW5jdGlvbigpIHtcbiAgICB2YXIgcmV0ID0gdGhpcy5fYm91bmRUbztcbiAgICBpZiAocmV0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgaWYgKHJldCBpbnN0YW5jZW9mIFByb21pc2UpIHtcbiAgICAgICAgICAgIGlmIChyZXQuaXNGdWxmaWxsZWQoKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiByZXQudmFsdWUoKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmV0O1xufVxuXG5mdW5jdGlvbiBsb25nU3RhY2tUcmFjZXNDYXB0dXJlU3RhY2tUcmFjZSgpIHtcbiAgICB0aGlzLl90cmFjZSA9IG5ldyBDYXB0dXJlZFRyYWNlKHRoaXMuX3BlZWtDb250ZXh0KCkpO1xufVxuXG5mdW5jdGlvbiBsb25nU3RhY2tUcmFjZXNBdHRhY2hFeHRyYVRyYWNlKGVycm9yLCBpZ25vcmVTZWxmKSB7XG4gICAgaWYgKGNhbkF0dGFjaFRyYWNlKGVycm9yKSkge1xuICAgICAgICB2YXIgdHJhY2UgPSB0aGlzLl90cmFjZTtcbiAgICAgICAgaWYgKHRyYWNlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGlmIChpZ25vcmVTZWxmKSB0cmFjZSA9IHRyYWNlLl9wYXJlbnQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRyYWNlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRyYWNlLmF0dGFjaEV4dHJhVHJhY2UoZXJyb3IpO1xuICAgICAgICB9IGVsc2UgaWYgKCFlcnJvci5fX3N0YWNrQ2xlYW5lZF9fKSB7XG4gICAgICAgICAgICB2YXIgcGFyc2VkID0gcGFyc2VTdGFja0FuZE1lc3NhZ2UoZXJyb3IpO1xuICAgICAgICAgICAgdXRpbC5ub3RFbnVtZXJhYmxlUHJvcChlcnJvciwgXCJzdGFja1wiLFxuICAgICAgICAgICAgICAgIHBhcnNlZC5tZXNzYWdlICsgXCJcXG5cIiArIHBhcnNlZC5zdGFjay5qb2luKFwiXFxuXCIpKTtcbiAgICAgICAgICAgIHV0aWwubm90RW51bWVyYWJsZVByb3AoZXJyb3IsIFwiX19zdGFja0NsZWFuZWRfX1wiLCB0cnVlKTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuZnVuY3Rpb24gY2hlY2tGb3Jnb3R0ZW5SZXR1cm5zKHJldHVyblZhbHVlLCBwcm9taXNlQ3JlYXRlZCwgbmFtZSwgcHJvbWlzZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXJlbnQpIHtcbiAgICBpZiAocmV0dXJuVmFsdWUgPT09IHVuZGVmaW5lZCAmJiBwcm9taXNlQ3JlYXRlZCAhPT0gbnVsbCAmJlxuICAgICAgICB3Rm9yZ290dGVuUmV0dXJuKSB7XG4gICAgICAgIGlmIChwYXJlbnQgIT09IHVuZGVmaW5lZCAmJiBwYXJlbnQuX3JldHVybmVkTm9uVW5kZWZpbmVkKCkpIHJldHVybjtcbiAgICAgICAgaWYgKChwcm9taXNlLl9iaXRGaWVsZCAmIDY1NTM1KSA9PT0gMCkgcmV0dXJuO1xuXG4gICAgICAgIGlmIChuYW1lKSBuYW1lID0gbmFtZSArIFwiIFwiO1xuICAgICAgICB2YXIgaGFuZGxlckxpbmUgPSBcIlwiO1xuICAgICAgICB2YXIgY3JlYXRvckxpbmUgPSBcIlwiO1xuICAgICAgICBpZiAocHJvbWlzZUNyZWF0ZWQuX3RyYWNlKSB7XG4gICAgICAgICAgICB2YXIgdHJhY2VMaW5lcyA9IHByb21pc2VDcmVhdGVkLl90cmFjZS5zdGFjay5zcGxpdChcIlxcblwiKTtcbiAgICAgICAgICAgIHZhciBzdGFjayA9IGNsZWFuU3RhY2sodHJhY2VMaW5lcyk7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gc3RhY2subGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgICAgICAgICAgICB2YXIgbGluZSA9IHN0YWNrW2ldO1xuICAgICAgICAgICAgICAgIGlmICghbm9kZUZyYW1lUGF0dGVybi50ZXN0KGxpbmUpKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBsaW5lTWF0Y2hlcyA9IGxpbmUubWF0Y2gocGFyc2VMaW5lUGF0dGVybik7XG4gICAgICAgICAgICAgICAgICAgIGlmIChsaW5lTWF0Y2hlcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgaGFuZGxlckxpbmUgID0gXCJhdCBcIiArIGxpbmVNYXRjaGVzWzFdICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIjpcIiArIGxpbmVNYXRjaGVzWzJdICsgXCI6XCIgKyBsaW5lTWF0Y2hlc1szXSArIFwiIFwiO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHN0YWNrLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICB2YXIgZmlyc3RVc2VyTGluZSA9IHN0YWNrWzBdO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdHJhY2VMaW5lcy5sZW5ndGg7ICsraSkge1xuXG4gICAgICAgICAgICAgICAgICAgIGlmICh0cmFjZUxpbmVzW2ldID09PSBmaXJzdFVzZXJMaW5lKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaSA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjcmVhdG9yTGluZSA9IFwiXFxuXCIgKyB0cmFjZUxpbmVzW2kgLSAxXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG1zZyA9IFwiYSBwcm9taXNlIHdhcyBjcmVhdGVkIGluIGEgXCIgKyBuYW1lICtcbiAgICAgICAgICAgIFwiaGFuZGxlciBcIiArIGhhbmRsZXJMaW5lICsgXCJidXQgd2FzIG5vdCByZXR1cm5lZCBmcm9tIGl0LCBcIiArXG4gICAgICAgICAgICBcInNlZSBodHRwOi8vZ29vLmdsL3JScU1Vd1wiICtcbiAgICAgICAgICAgIGNyZWF0b3JMaW5lO1xuICAgICAgICBwcm9taXNlLl93YXJuKG1zZywgdHJ1ZSwgcHJvbWlzZUNyZWF0ZWQpO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gZGVwcmVjYXRlZChuYW1lLCByZXBsYWNlbWVudCkge1xuICAgIHZhciBtZXNzYWdlID0gbmFtZSArXG4gICAgICAgIFwiIGlzIGRlcHJlY2F0ZWQgYW5kIHdpbGwgYmUgcmVtb3ZlZCBpbiBhIGZ1dHVyZSB2ZXJzaW9uLlwiO1xuICAgIGlmIChyZXBsYWNlbWVudCkgbWVzc2FnZSArPSBcIiBVc2UgXCIgKyByZXBsYWNlbWVudCArIFwiIGluc3RlYWQuXCI7XG4gICAgcmV0dXJuIHdhcm4obWVzc2FnZSk7XG59XG5cbmZ1bmN0aW9uIHdhcm4obWVzc2FnZSwgc2hvdWxkVXNlT3duVHJhY2UsIHByb21pc2UpIHtcbiAgICBpZiAoIWNvbmZpZy53YXJuaW5ncykgcmV0dXJuO1xuICAgIHZhciB3YXJuaW5nID0gbmV3IFdhcm5pbmcobWVzc2FnZSk7XG4gICAgdmFyIGN0eDtcbiAgICBpZiAoc2hvdWxkVXNlT3duVHJhY2UpIHtcbiAgICAgICAgcHJvbWlzZS5fYXR0YWNoRXh0cmFUcmFjZSh3YXJuaW5nKTtcbiAgICB9IGVsc2UgaWYgKGNvbmZpZy5sb25nU3RhY2tUcmFjZXMgJiYgKGN0eCA9IFByb21pc2UuX3BlZWtDb250ZXh0KCkpKSB7XG4gICAgICAgIGN0eC5hdHRhY2hFeHRyYVRyYWNlKHdhcm5pbmcpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBwYXJzZWQgPSBwYXJzZVN0YWNrQW5kTWVzc2FnZSh3YXJuaW5nKTtcbiAgICAgICAgd2FybmluZy5zdGFjayA9IHBhcnNlZC5tZXNzYWdlICsgXCJcXG5cIiArIHBhcnNlZC5zdGFjay5qb2luKFwiXFxuXCIpO1xuICAgIH1cblxuICAgIGlmICghYWN0aXZlRmlyZUV2ZW50KFwid2FybmluZ1wiLCB3YXJuaW5nKSkge1xuICAgICAgICBmb3JtYXRBbmRMb2dFcnJvcih3YXJuaW5nLCBcIlwiLCB0cnVlKTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIHJlY29uc3RydWN0U3RhY2sobWVzc2FnZSwgc3RhY2tzKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdGFja3MubGVuZ3RoIC0gMTsgKytpKSB7XG4gICAgICAgIHN0YWNrc1tpXS5wdXNoKFwiRnJvbSBwcmV2aW91cyBldmVudDpcIik7XG4gICAgICAgIHN0YWNrc1tpXSA9IHN0YWNrc1tpXS5qb2luKFwiXFxuXCIpO1xuICAgIH1cbiAgICBpZiAoaSA8IHN0YWNrcy5sZW5ndGgpIHtcbiAgICAgICAgc3RhY2tzW2ldID0gc3RhY2tzW2ldLmpvaW4oXCJcXG5cIik7XG4gICAgfVxuICAgIHJldHVybiBtZXNzYWdlICsgXCJcXG5cIiArIHN0YWNrcy5qb2luKFwiXFxuXCIpO1xufVxuXG5mdW5jdGlvbiByZW1vdmVEdXBsaWNhdGVPckVtcHR5SnVtcHMoc3RhY2tzKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdGFja3MubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgaWYgKHN0YWNrc1tpXS5sZW5ndGggPT09IDAgfHxcbiAgICAgICAgICAgICgoaSArIDEgPCBzdGFja3MubGVuZ3RoKSAmJiBzdGFja3NbaV1bMF0gPT09IHN0YWNrc1tpKzFdWzBdKSkge1xuICAgICAgICAgICAgc3RhY2tzLnNwbGljZShpLCAxKTtcbiAgICAgICAgICAgIGktLTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuZnVuY3Rpb24gcmVtb3ZlQ29tbW9uUm9vdHMoc3RhY2tzKSB7XG4gICAgdmFyIGN1cnJlbnQgPSBzdGFja3NbMF07XG4gICAgZm9yICh2YXIgaSA9IDE7IGkgPCBzdGFja3MubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgdmFyIHByZXYgPSBzdGFja3NbaV07XG4gICAgICAgIHZhciBjdXJyZW50TGFzdEluZGV4ID0gY3VycmVudC5sZW5ndGggLSAxO1xuICAgICAgICB2YXIgY3VycmVudExhc3RMaW5lID0gY3VycmVudFtjdXJyZW50TGFzdEluZGV4XTtcbiAgICAgICAgdmFyIGNvbW1vblJvb3RNZWV0UG9pbnQgPSAtMTtcblxuICAgICAgICBmb3IgKHZhciBqID0gcHJldi5sZW5ndGggLSAxOyBqID49IDA7IC0taikge1xuICAgICAgICAgICAgaWYgKHByZXZbal0gPT09IGN1cnJlbnRMYXN0TGluZSkge1xuICAgICAgICAgICAgICAgIGNvbW1vblJvb3RNZWV0UG9pbnQgPSBqO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgZm9yICh2YXIgaiA9IGNvbW1vblJvb3RNZWV0UG9pbnQ7IGogPj0gMDsgLS1qKSB7XG4gICAgICAgICAgICB2YXIgbGluZSA9IHByZXZbal07XG4gICAgICAgICAgICBpZiAoY3VycmVudFtjdXJyZW50TGFzdEluZGV4XSA9PT0gbGluZSkge1xuICAgICAgICAgICAgICAgIGN1cnJlbnQucG9wKCk7XG4gICAgICAgICAgICAgICAgY3VycmVudExhc3RJbmRleC0tO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjdXJyZW50ID0gcHJldjtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGNsZWFuU3RhY2soc3RhY2spIHtcbiAgICB2YXIgcmV0ID0gW107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdGFjay5sZW5ndGg7ICsraSkge1xuICAgICAgICB2YXIgbGluZSA9IHN0YWNrW2ldO1xuICAgICAgICB2YXIgaXNUcmFjZUxpbmUgPSBcIiAgICAoTm8gc3RhY2sgdHJhY2UpXCIgPT09IGxpbmUgfHxcbiAgICAgICAgICAgIHN0YWNrRnJhbWVQYXR0ZXJuLnRlc3QobGluZSk7XG4gICAgICAgIHZhciBpc0ludGVybmFsRnJhbWUgPSBpc1RyYWNlTGluZSAmJiBzaG91bGRJZ25vcmUobGluZSk7XG4gICAgICAgIGlmIChpc1RyYWNlTGluZSAmJiAhaXNJbnRlcm5hbEZyYW1lKSB7XG4gICAgICAgICAgICBpZiAoaW5kZW50U3RhY2tGcmFtZXMgJiYgbGluZS5jaGFyQXQoMCkgIT09IFwiIFwiKSB7XG4gICAgICAgICAgICAgICAgbGluZSA9IFwiICAgIFwiICsgbGluZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldC5wdXNoKGxpbmUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXQ7XG59XG5cbmZ1bmN0aW9uIHN0YWNrRnJhbWVzQXNBcnJheShlcnJvcikge1xuICAgIHZhciBzdGFjayA9IGVycm9yLnN0YWNrLnJlcGxhY2UoL1xccyskL2csIFwiXCIpLnNwbGl0KFwiXFxuXCIpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc3RhY2subGVuZ3RoOyArK2kpIHtcbiAgICAgICAgdmFyIGxpbmUgPSBzdGFja1tpXTtcbiAgICAgICAgaWYgKFwiICAgIChObyBzdGFjayB0cmFjZSlcIiA9PT0gbGluZSB8fCBzdGFja0ZyYW1lUGF0dGVybi50ZXN0KGxpbmUpKSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoaSA+IDAgJiYgZXJyb3IubmFtZSAhPSBcIlN5bnRheEVycm9yXCIpIHtcbiAgICAgICAgc3RhY2sgPSBzdGFjay5zbGljZShpKTtcbiAgICB9XG4gICAgcmV0dXJuIHN0YWNrO1xufVxuXG5mdW5jdGlvbiBwYXJzZVN0YWNrQW5kTWVzc2FnZShlcnJvcikge1xuICAgIHZhciBzdGFjayA9IGVycm9yLnN0YWNrO1xuICAgIHZhciBtZXNzYWdlID0gZXJyb3IudG9TdHJpbmcoKTtcbiAgICBzdGFjayA9IHR5cGVvZiBzdGFjayA9PT0gXCJzdHJpbmdcIiAmJiBzdGFjay5sZW5ndGggPiAwXG4gICAgICAgICAgICAgICAgPyBzdGFja0ZyYW1lc0FzQXJyYXkoZXJyb3IpIDogW1wiICAgIChObyBzdGFjayB0cmFjZSlcIl07XG4gICAgcmV0dXJuIHtcbiAgICAgICAgbWVzc2FnZTogbWVzc2FnZSxcbiAgICAgICAgc3RhY2s6IGVycm9yLm5hbWUgPT0gXCJTeW50YXhFcnJvclwiID8gc3RhY2sgOiBjbGVhblN0YWNrKHN0YWNrKVxuICAgIH07XG59XG5cbmZ1bmN0aW9uIGZvcm1hdEFuZExvZ0Vycm9yKGVycm9yLCB0aXRsZSwgaXNTb2Z0KSB7XG4gICAgaWYgKHR5cGVvZiBjb25zb2xlICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgIHZhciBtZXNzYWdlO1xuICAgICAgICBpZiAodXRpbC5pc09iamVjdChlcnJvcikpIHtcbiAgICAgICAgICAgIHZhciBzdGFjayA9IGVycm9yLnN0YWNrO1xuICAgICAgICAgICAgbWVzc2FnZSA9IHRpdGxlICsgZm9ybWF0U3RhY2soc3RhY2ssIGVycm9yKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG1lc3NhZ2UgPSB0aXRsZSArIFN0cmluZyhlcnJvcik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBwcmludFdhcm5pbmcgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgcHJpbnRXYXJuaW5nKG1lc3NhZ2UsIGlzU29mdCk7XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGNvbnNvbGUubG9nID09PSBcImZ1bmN0aW9uXCIgfHxcbiAgICAgICAgICAgIHR5cGVvZiBjb25zb2xlLmxvZyA9PT0gXCJvYmplY3RcIikge1xuICAgICAgICAgICAgY29uc29sZS5sb2cobWVzc2FnZSk7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbmZ1bmN0aW9uIGZpcmVSZWplY3Rpb25FdmVudChuYW1lLCBsb2NhbEhhbmRsZXIsIHJlYXNvbiwgcHJvbWlzZSkge1xuICAgIHZhciBsb2NhbEV2ZW50RmlyZWQgPSBmYWxzZTtcbiAgICB0cnkge1xuICAgICAgICBpZiAodHlwZW9mIGxvY2FsSGFuZGxlciA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICBsb2NhbEV2ZW50RmlyZWQgPSB0cnVlO1xuICAgICAgICAgICAgaWYgKG5hbWUgPT09IFwicmVqZWN0aW9uSGFuZGxlZFwiKSB7XG4gICAgICAgICAgICAgICAgbG9jYWxIYW5kbGVyKHByb21pc2UpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBsb2NhbEhhbmRsZXIocmVhc29uLCBwcm9taXNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgYXN5bmMudGhyb3dMYXRlcihlKTtcbiAgICB9XG5cbiAgICBpZiAobmFtZSA9PT0gXCJ1bmhhbmRsZWRSZWplY3Rpb25cIikge1xuICAgICAgICBpZiAoIWFjdGl2ZUZpcmVFdmVudChuYW1lLCByZWFzb24sIHByb21pc2UpICYmICFsb2NhbEV2ZW50RmlyZWQpIHtcbiAgICAgICAgICAgIGZvcm1hdEFuZExvZ0Vycm9yKHJlYXNvbiwgXCJVbmhhbmRsZWQgcmVqZWN0aW9uIFwiKTtcbiAgICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAgIGFjdGl2ZUZpcmVFdmVudChuYW1lLCBwcm9taXNlKTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGZvcm1hdE5vbkVycm9yKG9iaikge1xuICAgIHZhciBzdHI7XG4gICAgaWYgKHR5cGVvZiBvYmogPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICBzdHIgPSBcIltmdW5jdGlvbiBcIiArXG4gICAgICAgICAgICAob2JqLm5hbWUgfHwgXCJhbm9ueW1vdXNcIikgK1xuICAgICAgICAgICAgXCJdXCI7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgc3RyID0gb2JqICYmIHR5cGVvZiBvYmoudG9TdHJpbmcgPT09IFwiZnVuY3Rpb25cIlxuICAgICAgICAgICAgPyBvYmoudG9TdHJpbmcoKSA6IHV0aWwudG9TdHJpbmcob2JqKTtcbiAgICAgICAgdmFyIHJ1c2VsZXNzVG9TdHJpbmcgPSAvXFxbb2JqZWN0IFthLXpBLVowLTkkX10rXFxdLztcbiAgICAgICAgaWYgKHJ1c2VsZXNzVG9TdHJpbmcudGVzdChzdHIpKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHZhciBuZXdTdHIgPSBKU09OLnN0cmluZ2lmeShvYmopO1xuICAgICAgICAgICAgICAgIHN0ciA9IG5ld1N0cjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoKGUpIHtcblxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChzdHIubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICBzdHIgPSBcIihlbXB0eSBhcnJheSlcIjtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gKFwiKDxcIiArIHNuaXAoc3RyKSArIFwiPiwgbm8gc3RhY2sgdHJhY2UpXCIpO1xufVxuXG5mdW5jdGlvbiBzbmlwKHN0cikge1xuICAgIHZhciBtYXhDaGFycyA9IDQxO1xuICAgIGlmIChzdHIubGVuZ3RoIDwgbWF4Q2hhcnMpIHtcbiAgICAgICAgcmV0dXJuIHN0cjtcbiAgICB9XG4gICAgcmV0dXJuIHN0ci5zdWJzdHIoMCwgbWF4Q2hhcnMgLSAzKSArIFwiLi4uXCI7XG59XG5cbmZ1bmN0aW9uIGxvbmdTdGFja1RyYWNlc0lzU3VwcG9ydGVkKCkge1xuICAgIHJldHVybiB0eXBlb2YgY2FwdHVyZVN0YWNrVHJhY2UgPT09IFwiZnVuY3Rpb25cIjtcbn1cblxudmFyIHNob3VsZElnbm9yZSA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gZmFsc2U7IH07XG52YXIgcGFyc2VMaW5lSW5mb1JlZ2V4ID0gL1tcXC88XFwoXShbXjpcXC9dKyk6KFxcZCspOig/OlxcZCspXFwpP1xccyokLztcbmZ1bmN0aW9uIHBhcnNlTGluZUluZm8obGluZSkge1xuICAgIHZhciBtYXRjaGVzID0gbGluZS5tYXRjaChwYXJzZUxpbmVJbmZvUmVnZXgpO1xuICAgIGlmIChtYXRjaGVzKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBmaWxlTmFtZTogbWF0Y2hlc1sxXSxcbiAgICAgICAgICAgIGxpbmU6IHBhcnNlSW50KG1hdGNoZXNbMl0sIDEwKVxuICAgICAgICB9O1xuICAgIH1cbn1cblxuZnVuY3Rpb24gc2V0Qm91bmRzKGZpcnN0TGluZUVycm9yLCBsYXN0TGluZUVycm9yKSB7XG4gICAgaWYgKCFsb25nU3RhY2tUcmFjZXNJc1N1cHBvcnRlZCgpKSByZXR1cm47XG4gICAgdmFyIGZpcnN0U3RhY2tMaW5lcyA9IGZpcnN0TGluZUVycm9yLnN0YWNrLnNwbGl0KFwiXFxuXCIpO1xuICAgIHZhciBsYXN0U3RhY2tMaW5lcyA9IGxhc3RMaW5lRXJyb3Iuc3RhY2suc3BsaXQoXCJcXG5cIik7XG4gICAgdmFyIGZpcnN0SW5kZXggPSAtMTtcbiAgICB2YXIgbGFzdEluZGV4ID0gLTE7XG4gICAgdmFyIGZpcnN0RmlsZU5hbWU7XG4gICAgdmFyIGxhc3RGaWxlTmFtZTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGZpcnN0U3RhY2tMaW5lcy5sZW5ndGg7ICsraSkge1xuICAgICAgICB2YXIgcmVzdWx0ID0gcGFyc2VMaW5lSW5mbyhmaXJzdFN0YWNrTGluZXNbaV0pO1xuICAgICAgICBpZiAocmVzdWx0KSB7XG4gICAgICAgICAgICBmaXJzdEZpbGVOYW1lID0gcmVzdWx0LmZpbGVOYW1lO1xuICAgICAgICAgICAgZmlyc3RJbmRleCA9IHJlc3VsdC5saW5lO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsYXN0U3RhY2tMaW5lcy5sZW5ndGg7ICsraSkge1xuICAgICAgICB2YXIgcmVzdWx0ID0gcGFyc2VMaW5lSW5mbyhsYXN0U3RhY2tMaW5lc1tpXSk7XG4gICAgICAgIGlmIChyZXN1bHQpIHtcbiAgICAgICAgICAgIGxhc3RGaWxlTmFtZSA9IHJlc3VsdC5maWxlTmFtZTtcbiAgICAgICAgICAgIGxhc3RJbmRleCA9IHJlc3VsdC5saW5lO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKGZpcnN0SW5kZXggPCAwIHx8IGxhc3RJbmRleCA8IDAgfHwgIWZpcnN0RmlsZU5hbWUgfHwgIWxhc3RGaWxlTmFtZSB8fFxuICAgICAgICBmaXJzdEZpbGVOYW1lICE9PSBsYXN0RmlsZU5hbWUgfHwgZmlyc3RJbmRleCA+PSBsYXN0SW5kZXgpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHNob3VsZElnbm9yZSA9IGZ1bmN0aW9uKGxpbmUpIHtcbiAgICAgICAgaWYgKGJsdWViaXJkRnJhbWVQYXR0ZXJuLnRlc3QobGluZSkpIHJldHVybiB0cnVlO1xuICAgICAgICB2YXIgaW5mbyA9IHBhcnNlTGluZUluZm8obGluZSk7XG4gICAgICAgIGlmIChpbmZvKSB7XG4gICAgICAgICAgICBpZiAoaW5mby5maWxlTmFtZSA9PT0gZmlyc3RGaWxlTmFtZSAmJlxuICAgICAgICAgICAgICAgIChmaXJzdEluZGV4IDw9IGluZm8ubGluZSAmJiBpbmZvLmxpbmUgPD0gbGFzdEluZGV4KSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9O1xufVxuXG5mdW5jdGlvbiBDYXB0dXJlZFRyYWNlKHBhcmVudCkge1xuICAgIHRoaXMuX3BhcmVudCA9IHBhcmVudDtcbiAgICB0aGlzLl9wcm9taXNlc0NyZWF0ZWQgPSAwO1xuICAgIHZhciBsZW5ndGggPSB0aGlzLl9sZW5ndGggPSAxICsgKHBhcmVudCA9PT0gdW5kZWZpbmVkID8gMCA6IHBhcmVudC5fbGVuZ3RoKTtcbiAgICBjYXB0dXJlU3RhY2tUcmFjZSh0aGlzLCBDYXB0dXJlZFRyYWNlKTtcbiAgICBpZiAobGVuZ3RoID4gMzIpIHRoaXMudW5jeWNsZSgpO1xufVxudXRpbC5pbmhlcml0cyhDYXB0dXJlZFRyYWNlLCBFcnJvcik7XG5Db250ZXh0LkNhcHR1cmVkVHJhY2UgPSBDYXB0dXJlZFRyYWNlO1xuXG5DYXB0dXJlZFRyYWNlLnByb3RvdHlwZS51bmN5Y2xlID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGxlbmd0aCA9IHRoaXMuX2xlbmd0aDtcbiAgICBpZiAobGVuZ3RoIDwgMikgcmV0dXJuO1xuICAgIHZhciBub2RlcyA9IFtdO1xuICAgIHZhciBzdGFja1RvSW5kZXggPSB7fTtcblxuICAgIGZvciAodmFyIGkgPSAwLCBub2RlID0gdGhpczsgbm9kZSAhPT0gdW5kZWZpbmVkOyArK2kpIHtcbiAgICAgICAgbm9kZXMucHVzaChub2RlKTtcbiAgICAgICAgbm9kZSA9IG5vZGUuX3BhcmVudDtcbiAgICB9XG4gICAgbGVuZ3RoID0gdGhpcy5fbGVuZ3RoID0gaTtcbiAgICBmb3IgKHZhciBpID0gbGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgICAgdmFyIHN0YWNrID0gbm9kZXNbaV0uc3RhY2s7XG4gICAgICAgIGlmIChzdGFja1RvSW5kZXhbc3RhY2tdID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHN0YWNrVG9JbmRleFtzdGFja10gPSBpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyArK2kpIHtcbiAgICAgICAgdmFyIGN1cnJlbnRTdGFjayA9IG5vZGVzW2ldLnN0YWNrO1xuICAgICAgICB2YXIgaW5kZXggPSBzdGFja1RvSW5kZXhbY3VycmVudFN0YWNrXTtcbiAgICAgICAgaWYgKGluZGV4ICE9PSB1bmRlZmluZWQgJiYgaW5kZXggIT09IGkpIHtcbiAgICAgICAgICAgIGlmIChpbmRleCA+IDApIHtcbiAgICAgICAgICAgICAgICBub2Rlc1tpbmRleCAtIDFdLl9wYXJlbnQgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgbm9kZXNbaW5kZXggLSAxXS5fbGVuZ3RoID0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG5vZGVzW2ldLl9wYXJlbnQgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICBub2Rlc1tpXS5fbGVuZ3RoID0gMTtcbiAgICAgICAgICAgIHZhciBjeWNsZUVkZ2VOb2RlID0gaSA+IDAgPyBub2Rlc1tpIC0gMV0gOiB0aGlzO1xuXG4gICAgICAgICAgICBpZiAoaW5kZXggPCBsZW5ndGggLSAxKSB7XG4gICAgICAgICAgICAgICAgY3ljbGVFZGdlTm9kZS5fcGFyZW50ID0gbm9kZXNbaW5kZXggKyAxXTtcbiAgICAgICAgICAgICAgICBjeWNsZUVkZ2VOb2RlLl9wYXJlbnQudW5jeWNsZSgpO1xuICAgICAgICAgICAgICAgIGN5Y2xlRWRnZU5vZGUuX2xlbmd0aCA9XG4gICAgICAgICAgICAgICAgICAgIGN5Y2xlRWRnZU5vZGUuX3BhcmVudC5fbGVuZ3RoICsgMTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgY3ljbGVFZGdlTm9kZS5fcGFyZW50ID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgIGN5Y2xlRWRnZU5vZGUuX2xlbmd0aCA9IDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgY3VycmVudENoaWxkTGVuZ3RoID0gY3ljbGVFZGdlTm9kZS5fbGVuZ3RoICsgMTtcbiAgICAgICAgICAgIGZvciAodmFyIGogPSBpIC0gMjsgaiA+PSAwOyAtLWopIHtcbiAgICAgICAgICAgICAgICBub2Rlc1tqXS5fbGVuZ3RoID0gY3VycmVudENoaWxkTGVuZ3RoO1xuICAgICAgICAgICAgICAgIGN1cnJlbnRDaGlsZExlbmd0aCsrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgfVxufTtcblxuQ2FwdHVyZWRUcmFjZS5wcm90b3R5cGUuYXR0YWNoRXh0cmFUcmFjZSA9IGZ1bmN0aW9uKGVycm9yKSB7XG4gICAgaWYgKGVycm9yLl9fc3RhY2tDbGVhbmVkX18pIHJldHVybjtcbiAgICB0aGlzLnVuY3ljbGUoKTtcbiAgICB2YXIgcGFyc2VkID0gcGFyc2VTdGFja0FuZE1lc3NhZ2UoZXJyb3IpO1xuICAgIHZhciBtZXNzYWdlID0gcGFyc2VkLm1lc3NhZ2U7XG4gICAgdmFyIHN0YWNrcyA9IFtwYXJzZWQuc3RhY2tdO1xuXG4gICAgdmFyIHRyYWNlID0gdGhpcztcbiAgICB3aGlsZSAodHJhY2UgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBzdGFja3MucHVzaChjbGVhblN0YWNrKHRyYWNlLnN0YWNrLnNwbGl0KFwiXFxuXCIpKSk7XG4gICAgICAgIHRyYWNlID0gdHJhY2UuX3BhcmVudDtcbiAgICB9XG4gICAgcmVtb3ZlQ29tbW9uUm9vdHMoc3RhY2tzKTtcbiAgICByZW1vdmVEdXBsaWNhdGVPckVtcHR5SnVtcHMoc3RhY2tzKTtcbiAgICB1dGlsLm5vdEVudW1lcmFibGVQcm9wKGVycm9yLCBcInN0YWNrXCIsIHJlY29uc3RydWN0U3RhY2sobWVzc2FnZSwgc3RhY2tzKSk7XG4gICAgdXRpbC5ub3RFbnVtZXJhYmxlUHJvcChlcnJvciwgXCJfX3N0YWNrQ2xlYW5lZF9fXCIsIHRydWUpO1xufTtcblxudmFyIGNhcHR1cmVTdGFja1RyYWNlID0gKGZ1bmN0aW9uIHN0YWNrRGV0ZWN0aW9uKCkge1xuICAgIHZhciB2OHN0YWNrRnJhbWVQYXR0ZXJuID0gL15cXHMqYXRcXHMqLztcbiAgICB2YXIgdjhzdGFja0Zvcm1hdHRlciA9IGZ1bmN0aW9uKHN0YWNrLCBlcnJvcikge1xuICAgICAgICBpZiAodHlwZW9mIHN0YWNrID09PSBcInN0cmluZ1wiKSByZXR1cm4gc3RhY2s7XG5cbiAgICAgICAgaWYgKGVycm9yLm5hbWUgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgZXJyb3IubWVzc2FnZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gZXJyb3IudG9TdHJpbmcoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZm9ybWF0Tm9uRXJyb3IoZXJyb3IpO1xuICAgIH07XG5cbiAgICBpZiAodHlwZW9mIEVycm9yLnN0YWNrVHJhY2VMaW1pdCA9PT0gXCJudW1iZXJcIiAmJlxuICAgICAgICB0eXBlb2YgRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICBFcnJvci5zdGFja1RyYWNlTGltaXQgKz0gNjtcbiAgICAgICAgc3RhY2tGcmFtZVBhdHRlcm4gPSB2OHN0YWNrRnJhbWVQYXR0ZXJuO1xuICAgICAgICBmb3JtYXRTdGFjayA9IHY4c3RhY2tGb3JtYXR0ZXI7XG4gICAgICAgIHZhciBjYXB0dXJlU3RhY2tUcmFjZSA9IEVycm9yLmNhcHR1cmVTdGFja1RyYWNlO1xuXG4gICAgICAgIHNob3VsZElnbm9yZSA9IGZ1bmN0aW9uKGxpbmUpIHtcbiAgICAgICAgICAgIHJldHVybiBibHVlYmlyZEZyYW1lUGF0dGVybi50ZXN0KGxpbmUpO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24ocmVjZWl2ZXIsIGlnbm9yZVVudGlsKSB7XG4gICAgICAgICAgICBFcnJvci5zdGFja1RyYWNlTGltaXQgKz0gNjtcbiAgICAgICAgICAgIGNhcHR1cmVTdGFja1RyYWNlKHJlY2VpdmVyLCBpZ25vcmVVbnRpbCk7XG4gICAgICAgICAgICBFcnJvci5zdGFja1RyYWNlTGltaXQgLT0gNjtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgdmFyIGVyciA9IG5ldyBFcnJvcigpO1xuXG4gICAgaWYgKHR5cGVvZiBlcnIuc3RhY2sgPT09IFwic3RyaW5nXCIgJiZcbiAgICAgICAgZXJyLnN0YWNrLnNwbGl0KFwiXFxuXCIpWzBdLmluZGV4T2YoXCJzdGFja0RldGVjdGlvbkBcIikgPj0gMCkge1xuICAgICAgICBzdGFja0ZyYW1lUGF0dGVybiA9IC9ALztcbiAgICAgICAgZm9ybWF0U3RhY2sgPSB2OHN0YWNrRm9ybWF0dGVyO1xuICAgICAgICBpbmRlbnRTdGFja0ZyYW1lcyA9IHRydWU7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiBjYXB0dXJlU3RhY2tUcmFjZShvKSB7XG4gICAgICAgICAgICBvLnN0YWNrID0gbmV3IEVycm9yKCkuc3RhY2s7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgdmFyIGhhc1N0YWNrQWZ0ZXJUaHJvdztcbiAgICB0cnkgeyB0aHJvdyBuZXcgRXJyb3IoKTsgfVxuICAgIGNhdGNoKGUpIHtcbiAgICAgICAgaGFzU3RhY2tBZnRlclRocm93ID0gKFwic3RhY2tcIiBpbiBlKTtcbiAgICB9XG4gICAgaWYgKCEoXCJzdGFja1wiIGluIGVycikgJiYgaGFzU3RhY2tBZnRlclRocm93ICYmXG4gICAgICAgIHR5cGVvZiBFcnJvci5zdGFja1RyYWNlTGltaXQgPT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgc3RhY2tGcmFtZVBhdHRlcm4gPSB2OHN0YWNrRnJhbWVQYXR0ZXJuO1xuICAgICAgICBmb3JtYXRTdGFjayA9IHY4c3RhY2tGb3JtYXR0ZXI7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiBjYXB0dXJlU3RhY2tUcmFjZShvKSB7XG4gICAgICAgICAgICBFcnJvci5zdGFja1RyYWNlTGltaXQgKz0gNjtcbiAgICAgICAgICAgIHRyeSB7IHRocm93IG5ldyBFcnJvcigpOyB9XG4gICAgICAgICAgICBjYXRjaChlKSB7IG8uc3RhY2sgPSBlLnN0YWNrOyB9XG4gICAgICAgICAgICBFcnJvci5zdGFja1RyYWNlTGltaXQgLT0gNjtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBmb3JtYXRTdGFjayA9IGZ1bmN0aW9uKHN0YWNrLCBlcnJvcikge1xuICAgICAgICBpZiAodHlwZW9mIHN0YWNrID09PSBcInN0cmluZ1wiKSByZXR1cm4gc3RhY2s7XG5cbiAgICAgICAgaWYgKCh0eXBlb2YgZXJyb3IgPT09IFwib2JqZWN0XCIgfHxcbiAgICAgICAgICAgIHR5cGVvZiBlcnJvciA9PT0gXCJmdW5jdGlvblwiKSAmJlxuICAgICAgICAgICAgZXJyb3IubmFtZSAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICBlcnJvci5tZXNzYWdlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBlcnJvci50b1N0cmluZygpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmb3JtYXROb25FcnJvcihlcnJvcik7XG4gICAgfTtcblxuICAgIHJldHVybiBudWxsO1xuXG59KShbXSk7XG5cbmlmICh0eXBlb2YgY29uc29sZSAhPT0gXCJ1bmRlZmluZWRcIiAmJiB0eXBlb2YgY29uc29sZS53YXJuICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgcHJpbnRXYXJuaW5nID0gZnVuY3Rpb24gKG1lc3NhZ2UpIHtcbiAgICAgICAgY29uc29sZS53YXJuKG1lc3NhZ2UpO1xuICAgIH07XG4gICAgaWYgKHV0aWwuaXNOb2RlICYmIHByb2Nlc3Muc3RkZXJyLmlzVFRZKSB7XG4gICAgICAgIHByaW50V2FybmluZyA9IGZ1bmN0aW9uKG1lc3NhZ2UsIGlzU29mdCkge1xuICAgICAgICAgICAgdmFyIGNvbG9yID0gaXNTb2Z0ID8gXCJcXHUwMDFiWzMzbVwiIDogXCJcXHUwMDFiWzMxbVwiO1xuICAgICAgICAgICAgY29uc29sZS53YXJuKGNvbG9yICsgbWVzc2FnZSArIFwiXFx1MDAxYlswbVxcblwiKTtcbiAgICAgICAgfTtcbiAgICB9IGVsc2UgaWYgKCF1dGlsLmlzTm9kZSAmJiB0eXBlb2YgKG5ldyBFcnJvcigpLnN0YWNrKSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICBwcmludFdhcm5pbmcgPSBmdW5jdGlvbihtZXNzYWdlLCBpc1NvZnQpIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybihcIiVjXCIgKyBtZXNzYWdlLFxuICAgICAgICAgICAgICAgICAgICAgICAgaXNTb2Z0ID8gXCJjb2xvcjogZGFya29yYW5nZVwiIDogXCJjb2xvcjogcmVkXCIpO1xuICAgICAgICB9O1xuICAgIH1cbn1cblxudmFyIGNvbmZpZyA9IHtcbiAgICB3YXJuaW5nczogd2FybmluZ3MsXG4gICAgbG9uZ1N0YWNrVHJhY2VzOiBmYWxzZSxcbiAgICBjYW5jZWxsYXRpb246IGZhbHNlLFxuICAgIG1vbml0b3Jpbmc6IGZhbHNlXG59O1xuXG5pZiAobG9uZ1N0YWNrVHJhY2VzKSBQcm9taXNlLmxvbmdTdGFja1RyYWNlcygpO1xuXG5yZXR1cm4ge1xuICAgIGxvbmdTdGFja1RyYWNlczogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBjb25maWcubG9uZ1N0YWNrVHJhY2VzO1xuICAgIH0sXG4gICAgd2FybmluZ3M6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gY29uZmlnLndhcm5pbmdzO1xuICAgIH0sXG4gICAgY2FuY2VsbGF0aW9uOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIGNvbmZpZy5jYW5jZWxsYXRpb247XG4gICAgfSxcbiAgICBtb25pdG9yaW5nOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIGNvbmZpZy5tb25pdG9yaW5nO1xuICAgIH0sXG4gICAgcHJvcGFnYXRlRnJvbUZ1bmN0aW9uOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHByb3BhZ2F0ZUZyb21GdW5jdGlvbjtcbiAgICB9LFxuICAgIGJvdW5kVmFsdWVGdW5jdGlvbjogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBib3VuZFZhbHVlRnVuY3Rpb247XG4gICAgfSxcbiAgICBjaGVja0ZvcmdvdHRlblJldHVybnM6IGNoZWNrRm9yZ290dGVuUmV0dXJucyxcbiAgICBzZXRCb3VuZHM6IHNldEJvdW5kcyxcbiAgICB3YXJuOiB3YXJuLFxuICAgIGRlcHJlY2F0ZWQ6IGRlcHJlY2F0ZWQsXG4gICAgQ2FwdHVyZWRUcmFjZTogQ2FwdHVyZWRUcmFjZSxcbiAgICBmaXJlRG9tRXZlbnQ6IGZpcmVEb21FdmVudCxcbiAgICBmaXJlR2xvYmFsRXZlbnQ6IGZpcmVHbG9iYWxFdmVudFxufTtcbn07XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvYmx1ZWJpcmQvanMvcmVsZWFzZS9kZWJ1Z2dhYmlsaXR5LmpzIiwiXCJ1c2Ugc3RyaWN0XCI7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKFByb21pc2UsIHRyeUNvbnZlcnRUb1Byb21pc2UsIE5FWFRfRklMVEVSKSB7XG52YXIgdXRpbCA9IHJlcXVpcmUoXCIuL3V0aWxcIik7XG52YXIgQ2FuY2VsbGF0aW9uRXJyb3IgPSBQcm9taXNlLkNhbmNlbGxhdGlvbkVycm9yO1xudmFyIGVycm9yT2JqID0gdXRpbC5lcnJvck9iajtcbnZhciBjYXRjaEZpbHRlciA9IHJlcXVpcmUoXCIuL2NhdGNoX2ZpbHRlclwiKShORVhUX0ZJTFRFUik7XG5cbmZ1bmN0aW9uIFBhc3NUaHJvdWdoSGFuZGxlckNvbnRleHQocHJvbWlzZSwgdHlwZSwgaGFuZGxlcikge1xuICAgIHRoaXMucHJvbWlzZSA9IHByb21pc2U7XG4gICAgdGhpcy50eXBlID0gdHlwZTtcbiAgICB0aGlzLmhhbmRsZXIgPSBoYW5kbGVyO1xuICAgIHRoaXMuY2FsbGVkID0gZmFsc2U7XG4gICAgdGhpcy5jYW5jZWxQcm9taXNlID0gbnVsbDtcbn1cblxuUGFzc1Rocm91Z2hIYW5kbGVyQ29udGV4dC5wcm90b3R5cGUuaXNGaW5hbGx5SGFuZGxlciA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLnR5cGUgPT09IDA7XG59O1xuXG5mdW5jdGlvbiBGaW5hbGx5SGFuZGxlckNhbmNlbFJlYWN0aW9uKGZpbmFsbHlIYW5kbGVyKSB7XG4gICAgdGhpcy5maW5hbGx5SGFuZGxlciA9IGZpbmFsbHlIYW5kbGVyO1xufVxuXG5GaW5hbGx5SGFuZGxlckNhbmNlbFJlYWN0aW9uLnByb3RvdHlwZS5fcmVzdWx0Q2FuY2VsbGVkID0gZnVuY3Rpb24oKSB7XG4gICAgY2hlY2tDYW5jZWwodGhpcy5maW5hbGx5SGFuZGxlcik7XG59O1xuXG5mdW5jdGlvbiBjaGVja0NhbmNlbChjdHgsIHJlYXNvbikge1xuICAgIGlmIChjdHguY2FuY2VsUHJvbWlzZSAhPSBudWxsKSB7XG4gICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgY3R4LmNhbmNlbFByb21pc2UuX3JlamVjdChyZWFzb24pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY3R4LmNhbmNlbFByb21pc2UuX2NhbmNlbCgpO1xuICAgICAgICB9XG4gICAgICAgIGN0eC5jYW5jZWxQcm9taXNlID0gbnVsbDtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gc3VjY2VlZCgpIHtcbiAgICByZXR1cm4gZmluYWxseUhhbmRsZXIuY2FsbCh0aGlzLCB0aGlzLnByb21pc2UuX3RhcmdldCgpLl9zZXR0bGVkVmFsdWUoKSk7XG59XG5mdW5jdGlvbiBmYWlsKHJlYXNvbikge1xuICAgIGlmIChjaGVja0NhbmNlbCh0aGlzLCByZWFzb24pKSByZXR1cm47XG4gICAgZXJyb3JPYmouZSA9IHJlYXNvbjtcbiAgICByZXR1cm4gZXJyb3JPYmo7XG59XG5mdW5jdGlvbiBmaW5hbGx5SGFuZGxlcihyZWFzb25PclZhbHVlKSB7XG4gICAgdmFyIHByb21pc2UgPSB0aGlzLnByb21pc2U7XG4gICAgdmFyIGhhbmRsZXIgPSB0aGlzLmhhbmRsZXI7XG5cbiAgICBpZiAoIXRoaXMuY2FsbGVkKSB7XG4gICAgICAgIHRoaXMuY2FsbGVkID0gdHJ1ZTtcbiAgICAgICAgdmFyIHJldCA9IHRoaXMuaXNGaW5hbGx5SGFuZGxlcigpXG4gICAgICAgICAgICA/IGhhbmRsZXIuY2FsbChwcm9taXNlLl9ib3VuZFZhbHVlKCkpXG4gICAgICAgICAgICA6IGhhbmRsZXIuY2FsbChwcm9taXNlLl9ib3VuZFZhbHVlKCksIHJlYXNvbk9yVmFsdWUpO1xuICAgICAgICBpZiAocmV0ID09PSBORVhUX0ZJTFRFUikge1xuICAgICAgICAgICAgcmV0dXJuIHJldDtcbiAgICAgICAgfSBlbHNlIGlmIChyZXQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcHJvbWlzZS5fc2V0UmV0dXJuZWROb25VbmRlZmluZWQoKTtcbiAgICAgICAgICAgIHZhciBtYXliZVByb21pc2UgPSB0cnlDb252ZXJ0VG9Qcm9taXNlKHJldCwgcHJvbWlzZSk7XG4gICAgICAgICAgICBpZiAobWF5YmVQcm9taXNlIGluc3RhbmNlb2YgUHJvbWlzZSkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmNhbmNlbFByb21pc2UgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAobWF5YmVQcm9taXNlLl9pc0NhbmNlbGxlZCgpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcmVhc29uID1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXcgQ2FuY2VsbGF0aW9uRXJyb3IoXCJsYXRlIGNhbmNlbGxhdGlvbiBvYnNlcnZlclwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb21pc2UuX2F0dGFjaEV4dHJhVHJhY2UocmVhc29uKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yT2JqLmUgPSByZWFzb247XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZXJyb3JPYmo7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAobWF5YmVQcm9taXNlLmlzUGVuZGluZygpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtYXliZVByb21pc2UuX2F0dGFjaENhbmNlbGxhdGlvbkNhbGxiYWNrKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ldyBGaW5hbGx5SGFuZGxlckNhbmNlbFJlYWN0aW9uKHRoaXMpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gbWF5YmVQcm9taXNlLl90aGVuKFxuICAgICAgICAgICAgICAgICAgICBzdWNjZWVkLCBmYWlsLCB1bmRlZmluZWQsIHRoaXMsIHVuZGVmaW5lZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAocHJvbWlzZS5pc1JlamVjdGVkKCkpIHtcbiAgICAgICAgY2hlY2tDYW5jZWwodGhpcyk7XG4gICAgICAgIGVycm9yT2JqLmUgPSByZWFzb25PclZhbHVlO1xuICAgICAgICByZXR1cm4gZXJyb3JPYmo7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgY2hlY2tDYW5jZWwodGhpcyk7XG4gICAgICAgIHJldHVybiByZWFzb25PclZhbHVlO1xuICAgIH1cbn1cblxuUHJvbWlzZS5wcm90b3R5cGUuX3Bhc3NUaHJvdWdoID0gZnVuY3Rpb24oaGFuZGxlciwgdHlwZSwgc3VjY2VzcywgZmFpbCkge1xuICAgIGlmICh0eXBlb2YgaGFuZGxlciAhPT0gXCJmdW5jdGlvblwiKSByZXR1cm4gdGhpcy50aGVuKCk7XG4gICAgcmV0dXJuIHRoaXMuX3RoZW4oc3VjY2VzcyxcbiAgICAgICAgICAgICAgICAgICAgICBmYWlsLFxuICAgICAgICAgICAgICAgICAgICAgIHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICAgICAgICBuZXcgUGFzc1Rocm91Z2hIYW5kbGVyQ29udGV4dCh0aGlzLCB0eXBlLCBoYW5kbGVyKSxcbiAgICAgICAgICAgICAgICAgICAgICB1bmRlZmluZWQpO1xufTtcblxuUHJvbWlzZS5wcm90b3R5cGUubGFzdGx5ID1cblByb21pc2UucHJvdG90eXBlW1wiZmluYWxseVwiXSA9IGZ1bmN0aW9uIChoYW5kbGVyKSB7XG4gICAgcmV0dXJuIHRoaXMuX3Bhc3NUaHJvdWdoKGhhbmRsZXIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZpbmFsbHlIYW5kbGVyLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmaW5hbGx5SGFuZGxlcik7XG59O1xuXG5cblByb21pc2UucHJvdG90eXBlLnRhcCA9IGZ1bmN0aW9uIChoYW5kbGVyKSB7XG4gICAgcmV0dXJuIHRoaXMuX3Bhc3NUaHJvdWdoKGhhbmRsZXIsIDEsIGZpbmFsbHlIYW5kbGVyKTtcbn07XG5cblByb21pc2UucHJvdG90eXBlLnRhcENhdGNoID0gZnVuY3Rpb24gKGhhbmRsZXJPclByZWRpY2F0ZSkge1xuICAgIHZhciBsZW4gPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgIGlmKGxlbiA9PT0gMSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcGFzc1Rocm91Z2goaGFuZGxlck9yUHJlZGljYXRlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgMSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZpbmFsbHlIYW5kbGVyKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICAgdmFyIGNhdGNoSW5zdGFuY2VzID0gbmV3IEFycmF5KGxlbiAtIDEpLFxuICAgICAgICAgICAgaiA9IDAsIGk7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW4gLSAxOyArK2kpIHtcbiAgICAgICAgICAgIHZhciBpdGVtID0gYXJndW1lbnRzW2ldO1xuICAgICAgICAgICAgaWYgKHV0aWwuaXNPYmplY3QoaXRlbSkpIHtcbiAgICAgICAgICAgICAgICBjYXRjaEluc3RhbmNlc1tqKytdID0gaXRlbTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KG5ldyBUeXBlRXJyb3IoXG4gICAgICAgICAgICAgICAgICAgIFwidGFwQ2F0Y2ggc3RhdGVtZW50IHByZWRpY2F0ZTogXCJcbiAgICAgICAgICAgICAgICAgICAgKyBcImV4cGVjdGluZyBhbiBvYmplY3QgYnV0IGdvdCBcIiArIHV0aWwuY2xhc3NTdHJpbmcoaXRlbSlcbiAgICAgICAgICAgICAgICApKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjYXRjaEluc3RhbmNlcy5sZW5ndGggPSBqO1xuICAgICAgICB2YXIgaGFuZGxlciA9IGFyZ3VtZW50c1tpXTtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3Bhc3NUaHJvdWdoKGNhdGNoRmlsdGVyKGNhdGNoSW5zdGFuY2VzLCBoYW5kbGVyLCB0aGlzKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDEsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmaW5hbGx5SGFuZGxlcik7XG4gICAgfVxuXG59O1xuXG5yZXR1cm4gUGFzc1Rocm91Z2hIYW5kbGVyQ29udGV4dDtcbn07XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvYmx1ZWJpcmQvanMvcmVsZWFzZS9maW5hbGx5LmpzIiwiXCJ1c2Ugc3RyaWN0XCI7XG5tb2R1bGUuZXhwb3J0cyA9XG5mdW5jdGlvbihQcm9taXNlLCBJTlRFUk5BTCwgdHJ5Q29udmVydFRvUHJvbWlzZSwgYXBpUmVqZWN0aW9uLCBkZWJ1Zykge1xudmFyIHV0aWwgPSByZXF1aXJlKFwiLi91dGlsXCIpO1xudmFyIHRyeUNhdGNoID0gdXRpbC50cnlDYXRjaDtcblxuUHJvbWlzZS5tZXRob2QgPSBmdW5jdGlvbiAoZm4pIHtcbiAgICBpZiAodHlwZW9mIGZuICE9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgdGhyb3cgbmV3IFByb21pc2UuVHlwZUVycm9yKFwiZXhwZWN0aW5nIGEgZnVuY3Rpb24gYnV0IGdvdCBcIiArIHV0aWwuY2xhc3NTdHJpbmcoZm4pKTtcbiAgICB9XG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHJldCA9IG5ldyBQcm9taXNlKElOVEVSTkFMKTtcbiAgICAgICAgcmV0Ll9jYXB0dXJlU3RhY2tUcmFjZSgpO1xuICAgICAgICByZXQuX3B1c2hDb250ZXh0KCk7XG4gICAgICAgIHZhciB2YWx1ZSA9IHRyeUNhdGNoKGZuKS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICB2YXIgcHJvbWlzZUNyZWF0ZWQgPSByZXQuX3BvcENvbnRleHQoKTtcbiAgICAgICAgZGVidWcuY2hlY2tGb3Jnb3R0ZW5SZXR1cm5zKFxuICAgICAgICAgICAgdmFsdWUsIHByb21pc2VDcmVhdGVkLCBcIlByb21pc2UubWV0aG9kXCIsIHJldCk7XG4gICAgICAgIHJldC5fcmVzb2x2ZUZyb21TeW5jVmFsdWUodmFsdWUpO1xuICAgICAgICByZXR1cm4gcmV0O1xuICAgIH07XG59O1xuXG5Qcm9taXNlLmF0dGVtcHQgPSBQcm9taXNlW1widHJ5XCJdID0gZnVuY3Rpb24gKGZuKSB7XG4gICAgaWYgKHR5cGVvZiBmbiAhPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIHJldHVybiBhcGlSZWplY3Rpb24oXCJleHBlY3RpbmcgYSBmdW5jdGlvbiBidXQgZ290IFwiICsgdXRpbC5jbGFzc1N0cmluZyhmbikpO1xuICAgIH1cbiAgICB2YXIgcmV0ID0gbmV3IFByb21pc2UoSU5URVJOQUwpO1xuICAgIHJldC5fY2FwdHVyZVN0YWNrVHJhY2UoKTtcbiAgICByZXQuX3B1c2hDb250ZXh0KCk7XG4gICAgdmFyIHZhbHVlO1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMSkge1xuICAgICAgICBkZWJ1Zy5kZXByZWNhdGVkKFwiY2FsbGluZyBQcm9taXNlLnRyeSB3aXRoIG1vcmUgdGhhbiAxIGFyZ3VtZW50XCIpO1xuICAgICAgICB2YXIgYXJnID0gYXJndW1lbnRzWzFdO1xuICAgICAgICB2YXIgY3R4ID0gYXJndW1lbnRzWzJdO1xuICAgICAgICB2YWx1ZSA9IHV0aWwuaXNBcnJheShhcmcpID8gdHJ5Q2F0Y2goZm4pLmFwcGx5KGN0eCwgYXJnKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogdHJ5Q2F0Y2goZm4pLmNhbGwoY3R4LCBhcmcpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHZhbHVlID0gdHJ5Q2F0Y2goZm4pKCk7XG4gICAgfVxuICAgIHZhciBwcm9taXNlQ3JlYXRlZCA9IHJldC5fcG9wQ29udGV4dCgpO1xuICAgIGRlYnVnLmNoZWNrRm9yZ290dGVuUmV0dXJucyhcbiAgICAgICAgdmFsdWUsIHByb21pc2VDcmVhdGVkLCBcIlByb21pc2UudHJ5XCIsIHJldCk7XG4gICAgcmV0Ll9yZXNvbHZlRnJvbVN5bmNWYWx1ZSh2YWx1ZSk7XG4gICAgcmV0dXJuIHJldDtcbn07XG5cblByb21pc2UucHJvdG90eXBlLl9yZXNvbHZlRnJvbVN5bmNWYWx1ZSA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgIGlmICh2YWx1ZSA9PT0gdXRpbC5lcnJvck9iaikge1xuICAgICAgICB0aGlzLl9yZWplY3RDYWxsYmFjayh2YWx1ZS5lLCBmYWxzZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5fcmVzb2x2ZUNhbGxiYWNrKHZhbHVlLCB0cnVlKTtcbiAgICB9XG59O1xufTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9ibHVlYmlyZC9qcy9yZWxlYXNlL21ldGhvZC5qcyIsIlwidXNlIHN0cmljdFwiO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihQcm9taXNlLCBJTlRFUk5BTCwgdHJ5Q29udmVydFRvUHJvbWlzZSwgZGVidWcpIHtcbnZhciBjYWxsZWRCaW5kID0gZmFsc2U7XG52YXIgcmVqZWN0VGhpcyA9IGZ1bmN0aW9uKF8sIGUpIHtcbiAgICB0aGlzLl9yZWplY3QoZSk7XG59O1xuXG52YXIgdGFyZ2V0UmVqZWN0ZWQgPSBmdW5jdGlvbihlLCBjb250ZXh0KSB7XG4gICAgY29udGV4dC5wcm9taXNlUmVqZWN0aW9uUXVldWVkID0gdHJ1ZTtcbiAgICBjb250ZXh0LmJpbmRpbmdQcm9taXNlLl90aGVuKHJlamVjdFRoaXMsIHJlamVjdFRoaXMsIG51bGwsIHRoaXMsIGUpO1xufTtcblxudmFyIGJpbmRpbmdSZXNvbHZlZCA9IGZ1bmN0aW9uKHRoaXNBcmcsIGNvbnRleHQpIHtcbiAgICBpZiAoKCh0aGlzLl9iaXRGaWVsZCAmIDUwMzk3MTg0KSA9PT0gMCkpIHtcbiAgICAgICAgdGhpcy5fcmVzb2x2ZUNhbGxiYWNrKGNvbnRleHQudGFyZ2V0KTtcbiAgICB9XG59O1xuXG52YXIgYmluZGluZ1JlamVjdGVkID0gZnVuY3Rpb24oZSwgY29udGV4dCkge1xuICAgIGlmICghY29udGV4dC5wcm9taXNlUmVqZWN0aW9uUXVldWVkKSB0aGlzLl9yZWplY3QoZSk7XG59O1xuXG5Qcm9taXNlLnByb3RvdHlwZS5iaW5kID0gZnVuY3Rpb24gKHRoaXNBcmcpIHtcbiAgICBpZiAoIWNhbGxlZEJpbmQpIHtcbiAgICAgICAgY2FsbGVkQmluZCA9IHRydWU7XG4gICAgICAgIFByb21pc2UucHJvdG90eXBlLl9wcm9wYWdhdGVGcm9tID0gZGVidWcucHJvcGFnYXRlRnJvbUZ1bmN0aW9uKCk7XG4gICAgICAgIFByb21pc2UucHJvdG90eXBlLl9ib3VuZFZhbHVlID0gZGVidWcuYm91bmRWYWx1ZUZ1bmN0aW9uKCk7XG4gICAgfVxuICAgIHZhciBtYXliZVByb21pc2UgPSB0cnlDb252ZXJ0VG9Qcm9taXNlKHRoaXNBcmcpO1xuICAgIHZhciByZXQgPSBuZXcgUHJvbWlzZShJTlRFUk5BTCk7XG4gICAgcmV0Ll9wcm9wYWdhdGVGcm9tKHRoaXMsIDEpO1xuICAgIHZhciB0YXJnZXQgPSB0aGlzLl90YXJnZXQoKTtcbiAgICByZXQuX3NldEJvdW5kVG8obWF5YmVQcm9taXNlKTtcbiAgICBpZiAobWF5YmVQcm9taXNlIGluc3RhbmNlb2YgUHJvbWlzZSkge1xuICAgICAgICB2YXIgY29udGV4dCA9IHtcbiAgICAgICAgICAgIHByb21pc2VSZWplY3Rpb25RdWV1ZWQ6IGZhbHNlLFxuICAgICAgICAgICAgcHJvbWlzZTogcmV0LFxuICAgICAgICAgICAgdGFyZ2V0OiB0YXJnZXQsXG4gICAgICAgICAgICBiaW5kaW5nUHJvbWlzZTogbWF5YmVQcm9taXNlXG4gICAgICAgIH07XG4gICAgICAgIHRhcmdldC5fdGhlbihJTlRFUk5BTCwgdGFyZ2V0UmVqZWN0ZWQsIHVuZGVmaW5lZCwgcmV0LCBjb250ZXh0KTtcbiAgICAgICAgbWF5YmVQcm9taXNlLl90aGVuKFxuICAgICAgICAgICAgYmluZGluZ1Jlc29sdmVkLCBiaW5kaW5nUmVqZWN0ZWQsIHVuZGVmaW5lZCwgcmV0LCBjb250ZXh0KTtcbiAgICAgICAgcmV0Ll9zZXRPbkNhbmNlbChtYXliZVByb21pc2UpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJldC5fcmVzb2x2ZUNhbGxiYWNrKHRhcmdldCk7XG4gICAgfVxuICAgIHJldHVybiByZXQ7XG59O1xuXG5Qcm9taXNlLnByb3RvdHlwZS5fc2V0Qm91bmRUbyA9IGZ1bmN0aW9uIChvYmopIHtcbiAgICBpZiAob2JqICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhpcy5fYml0RmllbGQgPSB0aGlzLl9iaXRGaWVsZCB8IDIwOTcxNTI7XG4gICAgICAgIHRoaXMuX2JvdW5kVG8gPSBvYmo7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5fYml0RmllbGQgPSB0aGlzLl9iaXRGaWVsZCAmICh+MjA5NzE1Mik7XG4gICAgfVxufTtcblxuUHJvbWlzZS5wcm90b3R5cGUuX2lzQm91bmQgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuICh0aGlzLl9iaXRGaWVsZCAmIDIwOTcxNTIpID09PSAyMDk3MTUyO1xufTtcblxuUHJvbWlzZS5iaW5kID0gZnVuY3Rpb24gKHRoaXNBcmcsIHZhbHVlKSB7XG4gICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh2YWx1ZSkuYmluZCh0aGlzQXJnKTtcbn07XG59O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2JsdWViaXJkL2pzL3JlbGVhc2UvYmluZC5qcyIsIlwidXNlIHN0cmljdFwiO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihQcm9taXNlLCBQcm9taXNlQXJyYXksIGFwaVJlamVjdGlvbiwgZGVidWcpIHtcbnZhciB1dGlsID0gcmVxdWlyZShcIi4vdXRpbFwiKTtcbnZhciB0cnlDYXRjaCA9IHV0aWwudHJ5Q2F0Y2g7XG52YXIgZXJyb3JPYmogPSB1dGlsLmVycm9yT2JqO1xudmFyIGFzeW5jID0gUHJvbWlzZS5fYXN5bmM7XG5cblByb21pc2UucHJvdG90eXBlW1wiYnJlYWtcIl0gPSBQcm9taXNlLnByb3RvdHlwZS5jYW5jZWwgPSBmdW5jdGlvbigpIHtcbiAgICBpZiAoIWRlYnVnLmNhbmNlbGxhdGlvbigpKSByZXR1cm4gdGhpcy5fd2FybihcImNhbmNlbGxhdGlvbiBpcyBkaXNhYmxlZFwiKTtcblxuICAgIHZhciBwcm9taXNlID0gdGhpcztcbiAgICB2YXIgY2hpbGQgPSBwcm9taXNlO1xuICAgIHdoaWxlIChwcm9taXNlLl9pc0NhbmNlbGxhYmxlKCkpIHtcbiAgICAgICAgaWYgKCFwcm9taXNlLl9jYW5jZWxCeShjaGlsZCkpIHtcbiAgICAgICAgICAgIGlmIChjaGlsZC5faXNGb2xsb3dpbmcoKSkge1xuICAgICAgICAgICAgICAgIGNoaWxkLl9mb2xsb3dlZSgpLmNhbmNlbCgpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBjaGlsZC5fY2FuY2VsQnJhbmNoZWQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHBhcmVudCA9IHByb21pc2UuX2NhbmNlbGxhdGlvblBhcmVudDtcbiAgICAgICAgaWYgKHBhcmVudCA9PSBudWxsIHx8ICFwYXJlbnQuX2lzQ2FuY2VsbGFibGUoKSkge1xuICAgICAgICAgICAgaWYgKHByb21pc2UuX2lzRm9sbG93aW5nKCkpIHtcbiAgICAgICAgICAgICAgICBwcm9taXNlLl9mb2xsb3dlZSgpLmNhbmNlbCgpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBwcm9taXNlLl9jYW5jZWxCcmFuY2hlZCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAocHJvbWlzZS5faXNGb2xsb3dpbmcoKSkgcHJvbWlzZS5fZm9sbG93ZWUoKS5jYW5jZWwoKTtcbiAgICAgICAgICAgIHByb21pc2UuX3NldFdpbGxCZUNhbmNlbGxlZCgpO1xuICAgICAgICAgICAgY2hpbGQgPSBwcm9taXNlO1xuICAgICAgICAgICAgcHJvbWlzZSA9IHBhcmVudDtcbiAgICAgICAgfVxuICAgIH1cbn07XG5cblByb21pc2UucHJvdG90eXBlLl9icmFuY2hIYXNDYW5jZWxsZWQgPSBmdW5jdGlvbigpIHtcbiAgICB0aGlzLl9icmFuY2hlc1JlbWFpbmluZ1RvQ2FuY2VsLS07XG59O1xuXG5Qcm9taXNlLnByb3RvdHlwZS5fZW5vdWdoQnJhbmNoZXNIYXZlQ2FuY2VsbGVkID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuX2JyYW5jaGVzUmVtYWluaW5nVG9DYW5jZWwgPT09IHVuZGVmaW5lZCB8fFxuICAgICAgICAgICB0aGlzLl9icmFuY2hlc1JlbWFpbmluZ1RvQ2FuY2VsIDw9IDA7XG59O1xuXG5Qcm9taXNlLnByb3RvdHlwZS5fY2FuY2VsQnkgPSBmdW5jdGlvbihjYW5jZWxsZXIpIHtcbiAgICBpZiAoY2FuY2VsbGVyID09PSB0aGlzKSB7XG4gICAgICAgIHRoaXMuX2JyYW5jaGVzUmVtYWluaW5nVG9DYW5jZWwgPSAwO1xuICAgICAgICB0aGlzLl9pbnZva2VPbkNhbmNlbCgpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLl9icmFuY2hIYXNDYW5jZWxsZWQoKTtcbiAgICAgICAgaWYgKHRoaXMuX2Vub3VnaEJyYW5jaGVzSGF2ZUNhbmNlbGxlZCgpKSB7XG4gICAgICAgICAgICB0aGlzLl9pbnZva2VPbkNhbmNlbCgpO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufTtcblxuUHJvbWlzZS5wcm90b3R5cGUuX2NhbmNlbEJyYW5jaGVkID0gZnVuY3Rpb24oKSB7XG4gICAgaWYgKHRoaXMuX2Vub3VnaEJyYW5jaGVzSGF2ZUNhbmNlbGxlZCgpKSB7XG4gICAgICAgIHRoaXMuX2NhbmNlbCgpO1xuICAgIH1cbn07XG5cblByb21pc2UucHJvdG90eXBlLl9jYW5jZWwgPSBmdW5jdGlvbigpIHtcbiAgICBpZiAoIXRoaXMuX2lzQ2FuY2VsbGFibGUoKSkgcmV0dXJuO1xuICAgIHRoaXMuX3NldENhbmNlbGxlZCgpO1xuICAgIGFzeW5jLmludm9rZSh0aGlzLl9jYW5jZWxQcm9taXNlcywgdGhpcywgdW5kZWZpbmVkKTtcbn07XG5cblByb21pc2UucHJvdG90eXBlLl9jYW5jZWxQcm9taXNlcyA9IGZ1bmN0aW9uKCkge1xuICAgIGlmICh0aGlzLl9sZW5ndGgoKSA+IDApIHRoaXMuX3NldHRsZVByb21pc2VzKCk7XG59O1xuXG5Qcm9taXNlLnByb3RvdHlwZS5fdW5zZXRPbkNhbmNlbCA9IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuX29uQ2FuY2VsRmllbGQgPSB1bmRlZmluZWQ7XG59O1xuXG5Qcm9taXNlLnByb3RvdHlwZS5faXNDYW5jZWxsYWJsZSA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLmlzUGVuZGluZygpICYmICF0aGlzLl9pc0NhbmNlbGxlZCgpO1xufTtcblxuUHJvbWlzZS5wcm90b3R5cGUuaXNDYW5jZWxsYWJsZSA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLmlzUGVuZGluZygpICYmICF0aGlzLmlzQ2FuY2VsbGVkKCk7XG59O1xuXG5Qcm9taXNlLnByb3RvdHlwZS5fZG9JbnZva2VPbkNhbmNlbCA9IGZ1bmN0aW9uKG9uQ2FuY2VsQ2FsbGJhY2ssIGludGVybmFsT25seSkge1xuICAgIGlmICh1dGlsLmlzQXJyYXkob25DYW5jZWxDYWxsYmFjaykpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBvbkNhbmNlbENhbGxiYWNrLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICB0aGlzLl9kb0ludm9rZU9uQ2FuY2VsKG9uQ2FuY2VsQ2FsbGJhY2tbaV0sIGludGVybmFsT25seSk7XG4gICAgICAgIH1cbiAgICB9IGVsc2UgaWYgKG9uQ2FuY2VsQ2FsbGJhY2sgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBpZiAodHlwZW9mIG9uQ2FuY2VsQ2FsbGJhY2sgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgaWYgKCFpbnRlcm5hbE9ubHkpIHtcbiAgICAgICAgICAgICAgICB2YXIgZSA9IHRyeUNhdGNoKG9uQ2FuY2VsQ2FsbGJhY2spLmNhbGwodGhpcy5fYm91bmRWYWx1ZSgpKTtcbiAgICAgICAgICAgICAgICBpZiAoZSA9PT0gZXJyb3JPYmopIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fYXR0YWNoRXh0cmFUcmFjZShlLmUpO1xuICAgICAgICAgICAgICAgICAgICBhc3luYy50aHJvd0xhdGVyKGUuZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgb25DYW5jZWxDYWxsYmFjay5fcmVzdWx0Q2FuY2VsbGVkKHRoaXMpO1xuICAgICAgICB9XG4gICAgfVxufTtcblxuUHJvbWlzZS5wcm90b3R5cGUuX2ludm9rZU9uQ2FuY2VsID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIG9uQ2FuY2VsQ2FsbGJhY2sgPSB0aGlzLl9vbkNhbmNlbCgpO1xuICAgIHRoaXMuX3Vuc2V0T25DYW5jZWwoKTtcbiAgICBhc3luYy5pbnZva2UodGhpcy5fZG9JbnZva2VPbkNhbmNlbCwgdGhpcywgb25DYW5jZWxDYWxsYmFjayk7XG59O1xuXG5Qcm9taXNlLnByb3RvdHlwZS5faW52b2tlSW50ZXJuYWxPbkNhbmNlbCA9IGZ1bmN0aW9uKCkge1xuICAgIGlmICh0aGlzLl9pc0NhbmNlbGxhYmxlKCkpIHtcbiAgICAgICAgdGhpcy5fZG9JbnZva2VPbkNhbmNlbCh0aGlzLl9vbkNhbmNlbCgpLCB0cnVlKTtcbiAgICAgICAgdGhpcy5fdW5zZXRPbkNhbmNlbCgpO1xuICAgIH1cbn07XG5cblByb21pc2UucHJvdG90eXBlLl9yZXN1bHRDYW5jZWxsZWQgPSBmdW5jdGlvbigpIHtcbiAgICB0aGlzLmNhbmNlbCgpO1xufTtcblxufTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9ibHVlYmlyZC9qcy9yZWxlYXNlL2NhbmNlbC5qcyIsIlwidXNlIHN0cmljdFwiO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihQcm9taXNlKSB7XG5mdW5jdGlvbiByZXR1cm5lcigpIHtcbiAgICByZXR1cm4gdGhpcy52YWx1ZTtcbn1cbmZ1bmN0aW9uIHRocm93ZXIoKSB7XG4gICAgdGhyb3cgdGhpcy5yZWFzb247XG59XG5cblByb21pc2UucHJvdG90eXBlW1wicmV0dXJuXCJdID1cblByb21pc2UucHJvdG90eXBlLnRoZW5SZXR1cm4gPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBQcm9taXNlKSB2YWx1ZS5zdXBwcmVzc1VuaGFuZGxlZFJlamVjdGlvbnMoKTtcbiAgICByZXR1cm4gdGhpcy5fdGhlbihcbiAgICAgICAgcmV0dXJuZXIsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCB7dmFsdWU6IHZhbHVlfSwgdW5kZWZpbmVkKTtcbn07XG5cblByb21pc2UucHJvdG90eXBlW1widGhyb3dcIl0gPVxuUHJvbWlzZS5wcm90b3R5cGUudGhlblRocm93ID0gZnVuY3Rpb24gKHJlYXNvbikge1xuICAgIHJldHVybiB0aGlzLl90aGVuKFxuICAgICAgICB0aHJvd2VyLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwge3JlYXNvbjogcmVhc29ufSwgdW5kZWZpbmVkKTtcbn07XG5cblByb21pc2UucHJvdG90eXBlLmNhdGNoVGhyb3cgPSBmdW5jdGlvbiAocmVhc29uKSB7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPD0gMSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fdGhlbihcbiAgICAgICAgICAgIHVuZGVmaW5lZCwgdGhyb3dlciwgdW5kZWZpbmVkLCB7cmVhc29uOiByZWFzb259LCB1bmRlZmluZWQpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBfcmVhc29uID0gYXJndW1lbnRzWzFdO1xuICAgICAgICB2YXIgaGFuZGxlciA9IGZ1bmN0aW9uKCkge3Rocm93IF9yZWFzb247fTtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2F1Z2h0KHJlYXNvbiwgaGFuZGxlcik7XG4gICAgfVxufTtcblxuUHJvbWlzZS5wcm90b3R5cGUuY2F0Y2hSZXR1cm4gPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA8PSAxKSB7XG4gICAgICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIFByb21pc2UpIHZhbHVlLnN1cHByZXNzVW5oYW5kbGVkUmVqZWN0aW9ucygpO1xuICAgICAgICByZXR1cm4gdGhpcy5fdGhlbihcbiAgICAgICAgICAgIHVuZGVmaW5lZCwgcmV0dXJuZXIsIHVuZGVmaW5lZCwge3ZhbHVlOiB2YWx1ZX0sIHVuZGVmaW5lZCk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIF92YWx1ZSA9IGFyZ3VtZW50c1sxXTtcbiAgICAgICAgaWYgKF92YWx1ZSBpbnN0YW5jZW9mIFByb21pc2UpIF92YWx1ZS5zdXBwcmVzc1VuaGFuZGxlZFJlamVjdGlvbnMoKTtcbiAgICAgICAgdmFyIGhhbmRsZXIgPSBmdW5jdGlvbigpIHtyZXR1cm4gX3ZhbHVlO307XG4gICAgICAgIHJldHVybiB0aGlzLmNhdWdodCh2YWx1ZSwgaGFuZGxlcik7XG4gICAgfVxufTtcbn07XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvYmx1ZWJpcmQvanMvcmVsZWFzZS9kaXJlY3RfcmVzb2x2ZS5qcyIsIlwidXNlIHN0cmljdFwiO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihQcm9taXNlKSB7XG5mdW5jdGlvbiBQcm9taXNlSW5zcGVjdGlvbihwcm9taXNlKSB7XG4gICAgaWYgKHByb21pc2UgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBwcm9taXNlID0gcHJvbWlzZS5fdGFyZ2V0KCk7XG4gICAgICAgIHRoaXMuX2JpdEZpZWxkID0gcHJvbWlzZS5fYml0RmllbGQ7XG4gICAgICAgIHRoaXMuX3NldHRsZWRWYWx1ZUZpZWxkID0gcHJvbWlzZS5faXNGYXRlU2VhbGVkKClcbiAgICAgICAgICAgID8gcHJvbWlzZS5fc2V0dGxlZFZhbHVlKCkgOiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB0aGlzLl9iaXRGaWVsZCA9IDA7XG4gICAgICAgIHRoaXMuX3NldHRsZWRWYWx1ZUZpZWxkID0gdW5kZWZpbmVkO1xuICAgIH1cbn1cblxuUHJvbWlzZUluc3BlY3Rpb24ucHJvdG90eXBlLl9zZXR0bGVkVmFsdWUgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5fc2V0dGxlZFZhbHVlRmllbGQ7XG59O1xuXG52YXIgdmFsdWUgPSBQcm9taXNlSW5zcGVjdGlvbi5wcm90b3R5cGUudmFsdWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKCF0aGlzLmlzRnVsZmlsbGVkKCkpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcImNhbm5vdCBnZXQgZnVsZmlsbG1lbnQgdmFsdWUgb2YgYSBub24tZnVsZmlsbGVkIHByb21pc2VcXHUwMDBhXFx1MDAwYSAgICBTZWUgaHR0cDovL2dvby5nbC9NcXJGbVhcXHUwMDBhXCIpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fc2V0dGxlZFZhbHVlKCk7XG59O1xuXG52YXIgcmVhc29uID0gUHJvbWlzZUluc3BlY3Rpb24ucHJvdG90eXBlLmVycm9yID1cblByb21pc2VJbnNwZWN0aW9uLnByb3RvdHlwZS5yZWFzb24gPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKCF0aGlzLmlzUmVqZWN0ZWQoKSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiY2Fubm90IGdldCByZWplY3Rpb24gcmVhc29uIG9mIGEgbm9uLXJlamVjdGVkIHByb21pc2VcXHUwMDBhXFx1MDAwYSAgICBTZWUgaHR0cDovL2dvby5nbC9NcXJGbVhcXHUwMDBhXCIpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fc2V0dGxlZFZhbHVlKCk7XG59O1xuXG52YXIgaXNGdWxmaWxsZWQgPSBQcm9taXNlSW5zcGVjdGlvbi5wcm90b3R5cGUuaXNGdWxmaWxsZWQgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gKHRoaXMuX2JpdEZpZWxkICYgMzM1NTQ0MzIpICE9PSAwO1xufTtcblxudmFyIGlzUmVqZWN0ZWQgPSBQcm9taXNlSW5zcGVjdGlvbi5wcm90b3R5cGUuaXNSZWplY3RlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gKHRoaXMuX2JpdEZpZWxkICYgMTY3NzcyMTYpICE9PSAwO1xufTtcblxudmFyIGlzUGVuZGluZyA9IFByb21pc2VJbnNwZWN0aW9uLnByb3RvdHlwZS5pc1BlbmRpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuICh0aGlzLl9iaXRGaWVsZCAmIDUwMzk3MTg0KSA9PT0gMDtcbn07XG5cbnZhciBpc1Jlc29sdmVkID0gUHJvbWlzZUluc3BlY3Rpb24ucHJvdG90eXBlLmlzUmVzb2x2ZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuICh0aGlzLl9iaXRGaWVsZCAmIDUwMzMxNjQ4KSAhPT0gMDtcbn07XG5cblByb21pc2VJbnNwZWN0aW9uLnByb3RvdHlwZS5pc0NhbmNlbGxlZCA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiAodGhpcy5fYml0RmllbGQgJiA4NDU0MTQ0KSAhPT0gMDtcbn07XG5cblByb21pc2UucHJvdG90eXBlLl9faXNDYW5jZWxsZWQgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gKHRoaXMuX2JpdEZpZWxkICYgNjU1MzYpID09PSA2NTUzNjtcbn07XG5cblByb21pc2UucHJvdG90eXBlLl9pc0NhbmNlbGxlZCA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLl90YXJnZXQoKS5fX2lzQ2FuY2VsbGVkKCk7XG59O1xuXG5Qcm9taXNlLnByb3RvdHlwZS5pc0NhbmNlbGxlZCA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiAodGhpcy5fdGFyZ2V0KCkuX2JpdEZpZWxkICYgODQ1NDE0NCkgIT09IDA7XG59O1xuXG5Qcm9taXNlLnByb3RvdHlwZS5pc1BlbmRpbmcgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gaXNQZW5kaW5nLmNhbGwodGhpcy5fdGFyZ2V0KCkpO1xufTtcblxuUHJvbWlzZS5wcm90b3R5cGUuaXNSZWplY3RlZCA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBpc1JlamVjdGVkLmNhbGwodGhpcy5fdGFyZ2V0KCkpO1xufTtcblxuUHJvbWlzZS5wcm90b3R5cGUuaXNGdWxmaWxsZWQgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gaXNGdWxmaWxsZWQuY2FsbCh0aGlzLl90YXJnZXQoKSk7XG59O1xuXG5Qcm9taXNlLnByb3RvdHlwZS5pc1Jlc29sdmVkID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIGlzUmVzb2x2ZWQuY2FsbCh0aGlzLl90YXJnZXQoKSk7XG59O1xuXG5Qcm9taXNlLnByb3RvdHlwZS52YWx1ZSA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB2YWx1ZS5jYWxsKHRoaXMuX3RhcmdldCgpKTtcbn07XG5cblByb21pc2UucHJvdG90eXBlLnJlYXNvbiA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciB0YXJnZXQgPSB0aGlzLl90YXJnZXQoKTtcbiAgICB0YXJnZXQuX3Vuc2V0UmVqZWN0aW9uSXNVbmhhbmRsZWQoKTtcbiAgICByZXR1cm4gcmVhc29uLmNhbGwodGFyZ2V0KTtcbn07XG5cblByb21pc2UucHJvdG90eXBlLl92YWx1ZSA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLl9zZXR0bGVkVmFsdWUoKTtcbn07XG5cblByb21pc2UucHJvdG90eXBlLl9yZWFzb24gPSBmdW5jdGlvbigpIHtcbiAgICB0aGlzLl91bnNldFJlamVjdGlvbklzVW5oYW5kbGVkKCk7XG4gICAgcmV0dXJuIHRoaXMuX3NldHRsZWRWYWx1ZSgpO1xufTtcblxuUHJvbWlzZS5Qcm9taXNlSW5zcGVjdGlvbiA9IFByb21pc2VJbnNwZWN0aW9uO1xufTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9ibHVlYmlyZC9qcy9yZWxlYXNlL3N5bmNocm9ub3VzX2luc3BlY3Rpb24uanMiLCJcInVzZSBzdHJpY3RcIjtcbm1vZHVsZS5leHBvcnRzID1cbmZ1bmN0aW9uKFByb21pc2UsIFByb21pc2VBcnJheSwgdHJ5Q29udmVydFRvUHJvbWlzZSwgSU5URVJOQUwsIGFzeW5jLFxuICAgICAgICAgZ2V0RG9tYWluKSB7XG52YXIgdXRpbCA9IHJlcXVpcmUoXCIuL3V0aWxcIik7XG52YXIgY2FuRXZhbHVhdGUgPSB1dGlsLmNhbkV2YWx1YXRlO1xudmFyIHRyeUNhdGNoID0gdXRpbC50cnlDYXRjaDtcbnZhciBlcnJvck9iaiA9IHV0aWwuZXJyb3JPYmo7XG52YXIgcmVqZWN0O1xuXG5pZiAoIWZhbHNlKSB7XG5pZiAoY2FuRXZhbHVhdGUpIHtcbiAgICB2YXIgdGhlbkNhbGxiYWNrID0gZnVuY3Rpb24oaSkge1xuICAgICAgICByZXR1cm4gbmV3IEZ1bmN0aW9uKFwidmFsdWVcIiwgXCJob2xkZXJcIiwgXCIgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxcblxcXG4gICAgICAgICAgICAndXNlIHN0cmljdCc7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxcblxcXG4gICAgICAgICAgICBob2xkZXIucEluZGV4ID0gdmFsdWU7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxcblxcXG4gICAgICAgICAgICBob2xkZXIuY2hlY2tGdWxmaWxsbWVudCh0aGlzKTsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxcblxcXG4gICAgICAgICAgICBcIi5yZXBsYWNlKC9JbmRleC9nLCBpKSk7XG4gICAgfTtcblxuICAgIHZhciBwcm9taXNlU2V0dGVyID0gZnVuY3Rpb24oaSkge1xuICAgICAgICByZXR1cm4gbmV3IEZ1bmN0aW9uKFwicHJvbWlzZVwiLCBcImhvbGRlclwiLCBcIiAgICAgICAgICAgICAgICAgICAgICAgICAgIFxcblxcXG4gICAgICAgICAgICAndXNlIHN0cmljdCc7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxcblxcXG4gICAgICAgICAgICBob2xkZXIucEluZGV4ID0gcHJvbWlzZTsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxcblxcXG4gICAgICAgICAgICBcIi5yZXBsYWNlKC9JbmRleC9nLCBpKSk7XG4gICAgfTtcblxuICAgIHZhciBnZW5lcmF0ZUhvbGRlckNsYXNzID0gZnVuY3Rpb24odG90YWwpIHtcbiAgICAgICAgdmFyIHByb3BzID0gbmV3IEFycmF5KHRvdGFsKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgcHJvcHNbaV0gPSBcInRoaXMucFwiICsgKGkrMSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGFzc2lnbm1lbnQgPSBwcm9wcy5qb2luKFwiID0gXCIpICsgXCIgPSBudWxsO1wiO1xuICAgICAgICB2YXIgY2FuY2VsbGF0aW9uQ29kZT0gXCJ2YXIgcHJvbWlzZTtcXG5cIiArIHByb3BzLm1hcChmdW5jdGlvbihwcm9wKSB7XG4gICAgICAgICAgICByZXR1cm4gXCIgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcXG5cXFxuICAgICAgICAgICAgICAgIHByb21pc2UgPSBcIiArIHByb3AgKyBcIjsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxcblxcXG4gICAgICAgICAgICAgICAgaWYgKHByb21pc2UgaW5zdGFuY2VvZiBQcm9taXNlKSB7ICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxcblxcXG4gICAgICAgICAgICAgICAgICAgIHByb21pc2UuY2FuY2VsKCk7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxcblxcXG4gICAgICAgICAgICAgICAgfSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxcblxcXG4gICAgICAgICAgICBcIjtcbiAgICAgICAgfSkuam9pbihcIlxcblwiKTtcbiAgICAgICAgdmFyIHBhc3NlZEFyZ3VtZW50cyA9IHByb3BzLmpvaW4oXCIsIFwiKTtcbiAgICAgICAgdmFyIG5hbWUgPSBcIkhvbGRlciRcIiArIHRvdGFsO1xuXG5cbiAgICAgICAgdmFyIGNvZGUgPSBcInJldHVybiBmdW5jdGlvbih0cnlDYXRjaCwgZXJyb3JPYmosIFByb21pc2UsIGFzeW5jKSB7ICAgIFxcblxcXG4gICAgICAgICAgICAndXNlIHN0cmljdCc7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxcblxcXG4gICAgICAgICAgICBmdW5jdGlvbiBbVGhlTmFtZV0oZm4pIHsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxcblxcXG4gICAgICAgICAgICAgICAgW1RoZVByb3BlcnRpZXNdICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxcblxcXG4gICAgICAgICAgICAgICAgdGhpcy5mbiA9IGZuOyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxcblxcXG4gICAgICAgICAgICAgICAgdGhpcy5hc3luY05lZWRlZCA9IHRydWU7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxcblxcXG4gICAgICAgICAgICAgICAgdGhpcy5ub3cgPSAwOyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxcblxcXG4gICAgICAgICAgICB9ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxcblxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxcblxcXG4gICAgICAgICAgICBbVGhlTmFtZV0ucHJvdG90eXBlLl9jYWxsRnVuY3Rpb24gPSBmdW5jdGlvbihwcm9taXNlKSB7ICAgICAgICAgIFxcblxcXG4gICAgICAgICAgICAgICAgcHJvbWlzZS5fcHVzaENvbnRleHQoKTsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxcblxcXG4gICAgICAgICAgICAgICAgdmFyIHJldCA9IHRyeUNhdGNoKHRoaXMuZm4pKFtUaGVQYXNzZWRBcmd1bWVudHNdKTsgICAgICAgICAgIFxcblxcXG4gICAgICAgICAgICAgICAgcHJvbWlzZS5fcG9wQ29udGV4dCgpOyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxcblxcXG4gICAgICAgICAgICAgICAgaWYgKHJldCA9PT0gZXJyb3JPYmopIHsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxcblxcXG4gICAgICAgICAgICAgICAgICAgIHByb21pc2UuX3JlamVjdENhbGxiYWNrKHJldC5lLCBmYWxzZSk7ICAgICAgICAgICAgICAgICAgIFxcblxcXG4gICAgICAgICAgICAgICAgfSBlbHNlIHsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxcblxcXG4gICAgICAgICAgICAgICAgICAgIHByb21pc2UuX3Jlc29sdmVDYWxsYmFjayhyZXQpOyAgICAgICAgICAgICAgICAgICAgICAgICAgIFxcblxcXG4gICAgICAgICAgICAgICAgfSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxcblxcXG4gICAgICAgICAgICB9OyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxcblxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxcblxcXG4gICAgICAgICAgICBbVGhlTmFtZV0ucHJvdG90eXBlLmNoZWNrRnVsZmlsbG1lbnQgPSBmdW5jdGlvbihwcm9taXNlKSB7ICAgICAgIFxcblxcXG4gICAgICAgICAgICAgICAgdmFyIG5vdyA9ICsrdGhpcy5ub3c7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxcblxcXG4gICAgICAgICAgICAgICAgaWYgKG5vdyA9PT0gW1RoZVRvdGFsXSkgeyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxcblxcXG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmFzeW5jTmVlZGVkKSB7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxcblxcXG4gICAgICAgICAgICAgICAgICAgICAgICBhc3luYy5pbnZva2UodGhpcy5fY2FsbEZ1bmN0aW9uLCB0aGlzLCBwcm9taXNlKTsgICAgIFxcblxcXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxcblxcXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9jYWxsRnVuY3Rpb24ocHJvbWlzZSk7ICAgICAgICAgICAgICAgICAgICAgICAgIFxcblxcXG4gICAgICAgICAgICAgICAgICAgIH0gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxcblxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxcblxcXG4gICAgICAgICAgICAgICAgfSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxcblxcXG4gICAgICAgICAgICB9OyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxcblxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxcblxcXG4gICAgICAgICAgICBbVGhlTmFtZV0ucHJvdG90eXBlLl9yZXN1bHRDYW5jZWxsZWQgPSBmdW5jdGlvbigpIHsgICAgICAgICAgICAgIFxcblxcXG4gICAgICAgICAgICAgICAgW0NhbmNlbGxhdGlvbkNvZGVdICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxcblxcXG4gICAgICAgICAgICB9OyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxcblxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxcblxcXG4gICAgICAgICAgICByZXR1cm4gW1RoZU5hbWVdOyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxcblxcXG4gICAgICAgIH0odHJ5Q2F0Y2gsIGVycm9yT2JqLCBQcm9taXNlLCBhc3luYyk7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxcblxcXG4gICAgICAgIFwiO1xuXG4gICAgICAgIGNvZGUgPSBjb2RlLnJlcGxhY2UoL1xcW1RoZU5hbWVcXF0vZywgbmFtZSlcbiAgICAgICAgICAgIC5yZXBsYWNlKC9cXFtUaGVUb3RhbFxcXS9nLCB0b3RhbClcbiAgICAgICAgICAgIC5yZXBsYWNlKC9cXFtUaGVQYXNzZWRBcmd1bWVudHNcXF0vZywgcGFzc2VkQXJndW1lbnRzKVxuICAgICAgICAgICAgLnJlcGxhY2UoL1xcW1RoZVByb3BlcnRpZXNcXF0vZywgYXNzaWdubWVudClcbiAgICAgICAgICAgIC5yZXBsYWNlKC9cXFtDYW5jZWxsYXRpb25Db2RlXFxdL2csIGNhbmNlbGxhdGlvbkNvZGUpO1xuXG4gICAgICAgIHJldHVybiBuZXcgRnVuY3Rpb24oXCJ0cnlDYXRjaFwiLCBcImVycm9yT2JqXCIsIFwiUHJvbWlzZVwiLCBcImFzeW5jXCIsIGNvZGUpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAodHJ5Q2F0Y2gsIGVycm9yT2JqLCBQcm9taXNlLCBhc3luYyk7XG4gICAgfTtcblxuICAgIHZhciBob2xkZXJDbGFzc2VzID0gW107XG4gICAgdmFyIHRoZW5DYWxsYmFja3MgPSBbXTtcbiAgICB2YXIgcHJvbWlzZVNldHRlcnMgPSBbXTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgODsgKytpKSB7XG4gICAgICAgIGhvbGRlckNsYXNzZXMucHVzaChnZW5lcmF0ZUhvbGRlckNsYXNzKGkgKyAxKSk7XG4gICAgICAgIHRoZW5DYWxsYmFja3MucHVzaCh0aGVuQ2FsbGJhY2soaSArIDEpKTtcbiAgICAgICAgcHJvbWlzZVNldHRlcnMucHVzaChwcm9taXNlU2V0dGVyKGkgKyAxKSk7XG4gICAgfVxuXG4gICAgcmVqZWN0ID0gZnVuY3Rpb24gKHJlYXNvbikge1xuICAgICAgICB0aGlzLl9yZWplY3QocmVhc29uKTtcbiAgICB9O1xufX1cblxuUHJvbWlzZS5qb2luID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBsYXN0ID0gYXJndW1lbnRzLmxlbmd0aCAtIDE7XG4gICAgdmFyIGZuO1xuICAgIGlmIChsYXN0ID4gMCAmJiB0eXBlb2YgYXJndW1lbnRzW2xhc3RdID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgZm4gPSBhcmd1bWVudHNbbGFzdF07XG4gICAgICAgIGlmICghZmFsc2UpIHtcbiAgICAgICAgICAgIGlmIChsYXN0IDw9IDggJiYgY2FuRXZhbHVhdGUpIHtcbiAgICAgICAgICAgICAgICB2YXIgcmV0ID0gbmV3IFByb21pc2UoSU5URVJOQUwpO1xuICAgICAgICAgICAgICAgIHJldC5fY2FwdHVyZVN0YWNrVHJhY2UoKTtcbiAgICAgICAgICAgICAgICB2YXIgSG9sZGVyQ2xhc3MgPSBob2xkZXJDbGFzc2VzW2xhc3QgLSAxXTtcbiAgICAgICAgICAgICAgICB2YXIgaG9sZGVyID0gbmV3IEhvbGRlckNsYXNzKGZuKTtcbiAgICAgICAgICAgICAgICB2YXIgY2FsbGJhY2tzID0gdGhlbkNhbGxiYWNrcztcblxuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGFzdDsgKytpKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBtYXliZVByb21pc2UgPSB0cnlDb252ZXJ0VG9Qcm9taXNlKGFyZ3VtZW50c1tpXSwgcmV0KTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG1heWJlUHJvbWlzZSBpbnN0YW5jZW9mIFByb21pc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1heWJlUHJvbWlzZSA9IG1heWJlUHJvbWlzZS5fdGFyZ2V0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgYml0RmllbGQgPSBtYXliZVByb21pc2UuX2JpdEZpZWxkO1xuICAgICAgICAgICAgICAgICAgICAgICAgO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCgoYml0RmllbGQgJiA1MDM5NzE4NCkgPT09IDApKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWF5YmVQcm9taXNlLl90aGVuKGNhbGxiYWNrc1tpXSwgcmVqZWN0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB1bmRlZmluZWQsIHJldCwgaG9sZGVyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcm9taXNlU2V0dGVyc1tpXShtYXliZVByb21pc2UsIGhvbGRlcik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaG9sZGVyLmFzeW5jTmVlZGVkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKCgoYml0RmllbGQgJiAzMzU1NDQzMikgIT09IDApKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2tzW2ldLmNhbGwocmV0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1heWJlUHJvbWlzZS5fdmFsdWUoKSwgaG9sZGVyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoKChiaXRGaWVsZCAmIDE2Nzc3MjE2KSAhPT0gMCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXQuX3JlamVjdChtYXliZVByb21pc2UuX3JlYXNvbigpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0Ll9jYW5jZWwoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrc1tpXS5jYWxsKHJldCwgbWF5YmVQcm9taXNlLCBob2xkZXIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKCFyZXQuX2lzRmF0ZVNlYWxlZCgpKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChob2xkZXIuYXN5bmNOZWVkZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBkb21haW4gPSBnZXREb21haW4oKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkb21haW4gIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBob2xkZXIuZm4gPSB1dGlsLmRvbWFpbkJpbmQoZG9tYWluLCBob2xkZXIuZm4pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldC5fc2V0QXN5bmNHdWFyYW50ZWVkKCk7XG4gICAgICAgICAgICAgICAgICAgIHJldC5fc2V0T25DYW5jZWwoaG9sZGVyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJldDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICB2YXIgJF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoO3ZhciBhcmdzID0gbmV3IEFycmF5KCRfbGVuKTsgZm9yKHZhciAkX2kgPSAwOyAkX2kgPCAkX2xlbjsgKyskX2kpIHthcmdzWyRfaV0gPSBhcmd1bWVudHNbJF9pXTt9O1xuICAgIGlmIChmbikgYXJncy5wb3AoKTtcbiAgICB2YXIgcmV0ID0gbmV3IFByb21pc2VBcnJheShhcmdzKS5wcm9taXNlKCk7XG4gICAgcmV0dXJuIGZuICE9PSB1bmRlZmluZWQgPyByZXQuc3ByZWFkKGZuKSA6IHJldDtcbn07XG5cbn07XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvYmx1ZWJpcmQvanMvcmVsZWFzZS9qb2luLmpzIiwiXCJ1c2Ugc3RyaWN0XCI7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKFByb21pc2UsXG4gICAgICAgICAgICAgICAgICAgICAgICAgIFByb21pc2VBcnJheSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgYXBpUmVqZWN0aW9uLFxuICAgICAgICAgICAgICAgICAgICAgICAgICB0cnlDb252ZXJ0VG9Qcm9taXNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICBJTlRFUk5BTCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgZGVidWcpIHtcbnZhciBnZXREb21haW4gPSBQcm9taXNlLl9nZXREb21haW47XG52YXIgdXRpbCA9IHJlcXVpcmUoXCIuL3V0aWxcIik7XG52YXIgdHJ5Q2F0Y2ggPSB1dGlsLnRyeUNhdGNoO1xudmFyIGVycm9yT2JqID0gdXRpbC5lcnJvck9iajtcbnZhciBhc3luYyA9IFByb21pc2UuX2FzeW5jO1xuXG5mdW5jdGlvbiBNYXBwaW5nUHJvbWlzZUFycmF5KHByb21pc2VzLCBmbiwgbGltaXQsIF9maWx0ZXIpIHtcbiAgICB0aGlzLmNvbnN0cnVjdG9yJChwcm9taXNlcyk7XG4gICAgdGhpcy5fcHJvbWlzZS5fY2FwdHVyZVN0YWNrVHJhY2UoKTtcbiAgICB2YXIgZG9tYWluID0gZ2V0RG9tYWluKCk7XG4gICAgdGhpcy5fY2FsbGJhY2sgPSBkb21haW4gPT09IG51bGwgPyBmbiA6IHV0aWwuZG9tYWluQmluZChkb21haW4sIGZuKTtcbiAgICB0aGlzLl9wcmVzZXJ2ZWRWYWx1ZXMgPSBfZmlsdGVyID09PSBJTlRFUk5BTFxuICAgICAgICA/IG5ldyBBcnJheSh0aGlzLmxlbmd0aCgpKVxuICAgICAgICA6IG51bGw7XG4gICAgdGhpcy5fbGltaXQgPSBsaW1pdDtcbiAgICB0aGlzLl9pbkZsaWdodCA9IDA7XG4gICAgdGhpcy5fcXVldWUgPSBbXTtcbiAgICBhc3luYy5pbnZva2UodGhpcy5fYXN5bmNJbml0LCB0aGlzLCB1bmRlZmluZWQpO1xufVxudXRpbC5pbmhlcml0cyhNYXBwaW5nUHJvbWlzZUFycmF5LCBQcm9taXNlQXJyYXkpO1xuXG5NYXBwaW5nUHJvbWlzZUFycmF5LnByb3RvdHlwZS5fYXN5bmNJbml0ID0gZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5faW5pdCQodW5kZWZpbmVkLCAtMik7XG59O1xuXG5NYXBwaW5nUHJvbWlzZUFycmF5LnByb3RvdHlwZS5faW5pdCA9IGZ1bmN0aW9uICgpIHt9O1xuXG5NYXBwaW5nUHJvbWlzZUFycmF5LnByb3RvdHlwZS5fcHJvbWlzZUZ1bGZpbGxlZCA9IGZ1bmN0aW9uICh2YWx1ZSwgaW5kZXgpIHtcbiAgICB2YXIgdmFsdWVzID0gdGhpcy5fdmFsdWVzO1xuICAgIHZhciBsZW5ndGggPSB0aGlzLmxlbmd0aCgpO1xuICAgIHZhciBwcmVzZXJ2ZWRWYWx1ZXMgPSB0aGlzLl9wcmVzZXJ2ZWRWYWx1ZXM7XG4gICAgdmFyIGxpbWl0ID0gdGhpcy5fbGltaXQ7XG5cbiAgICBpZiAoaW5kZXggPCAwKSB7XG4gICAgICAgIGluZGV4ID0gKGluZGV4ICogLTEpIC0gMTtcbiAgICAgICAgdmFsdWVzW2luZGV4XSA9IHZhbHVlO1xuICAgICAgICBpZiAobGltaXQgPj0gMSkge1xuICAgICAgICAgICAgdGhpcy5faW5GbGlnaHQtLTtcbiAgICAgICAgICAgIHRoaXMuX2RyYWluUXVldWUoKTtcbiAgICAgICAgICAgIGlmICh0aGlzLl9pc1Jlc29sdmVkKCkpIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKGxpbWl0ID49IDEgJiYgdGhpcy5faW5GbGlnaHQgPj0gbGltaXQpIHtcbiAgICAgICAgICAgIHZhbHVlc1tpbmRleF0gPSB2YWx1ZTtcbiAgICAgICAgICAgIHRoaXMuX3F1ZXVlLnB1c2goaW5kZXgpO1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwcmVzZXJ2ZWRWYWx1ZXMgIT09IG51bGwpIHByZXNlcnZlZFZhbHVlc1tpbmRleF0gPSB2YWx1ZTtcblxuICAgICAgICB2YXIgcHJvbWlzZSA9IHRoaXMuX3Byb21pc2U7XG4gICAgICAgIHZhciBjYWxsYmFjayA9IHRoaXMuX2NhbGxiYWNrO1xuICAgICAgICB2YXIgcmVjZWl2ZXIgPSBwcm9taXNlLl9ib3VuZFZhbHVlKCk7XG4gICAgICAgIHByb21pc2UuX3B1c2hDb250ZXh0KCk7XG4gICAgICAgIHZhciByZXQgPSB0cnlDYXRjaChjYWxsYmFjaykuY2FsbChyZWNlaXZlciwgdmFsdWUsIGluZGV4LCBsZW5ndGgpO1xuICAgICAgICB2YXIgcHJvbWlzZUNyZWF0ZWQgPSBwcm9taXNlLl9wb3BDb250ZXh0KCk7XG4gICAgICAgIGRlYnVnLmNoZWNrRm9yZ290dGVuUmV0dXJucyhcbiAgICAgICAgICAgIHJldCxcbiAgICAgICAgICAgIHByb21pc2VDcmVhdGVkLFxuICAgICAgICAgICAgcHJlc2VydmVkVmFsdWVzICE9PSBudWxsID8gXCJQcm9taXNlLmZpbHRlclwiIDogXCJQcm9taXNlLm1hcFwiLFxuICAgICAgICAgICAgcHJvbWlzZVxuICAgICAgICApO1xuICAgICAgICBpZiAocmV0ID09PSBlcnJvck9iaikge1xuICAgICAgICAgICAgdGhpcy5fcmVqZWN0KHJldC5lKTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIG1heWJlUHJvbWlzZSA9IHRyeUNvbnZlcnRUb1Byb21pc2UocmV0LCB0aGlzLl9wcm9taXNlKTtcbiAgICAgICAgaWYgKG1heWJlUHJvbWlzZSBpbnN0YW5jZW9mIFByb21pc2UpIHtcbiAgICAgICAgICAgIG1heWJlUHJvbWlzZSA9IG1heWJlUHJvbWlzZS5fdGFyZ2V0KCk7XG4gICAgICAgICAgICB2YXIgYml0RmllbGQgPSBtYXliZVByb21pc2UuX2JpdEZpZWxkO1xuICAgICAgICAgICAgO1xuICAgICAgICAgICAgaWYgKCgoYml0RmllbGQgJiA1MDM5NzE4NCkgPT09IDApKSB7XG4gICAgICAgICAgICAgICAgaWYgKGxpbWl0ID49IDEpIHRoaXMuX2luRmxpZ2h0Kys7XG4gICAgICAgICAgICAgICAgdmFsdWVzW2luZGV4XSA9IG1heWJlUHJvbWlzZTtcbiAgICAgICAgICAgICAgICBtYXliZVByb21pc2UuX3Byb3h5KHRoaXMsIChpbmRleCArIDEpICogLTEpO1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoKChiaXRGaWVsZCAmIDMzNTU0NDMyKSAhPT0gMCkpIHtcbiAgICAgICAgICAgICAgICByZXQgPSBtYXliZVByb21pc2UuX3ZhbHVlKCk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKCgoYml0RmllbGQgJiAxNjc3NzIxNikgIT09IDApKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fcmVqZWN0KG1heWJlUHJvbWlzZS5fcmVhc29uKCkpO1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9jYW5jZWwoKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB2YWx1ZXNbaW5kZXhdID0gcmV0O1xuICAgIH1cbiAgICB2YXIgdG90YWxSZXNvbHZlZCA9ICsrdGhpcy5fdG90YWxSZXNvbHZlZDtcbiAgICBpZiAodG90YWxSZXNvbHZlZCA+PSBsZW5ndGgpIHtcbiAgICAgICAgaWYgKHByZXNlcnZlZFZhbHVlcyAhPT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5fZmlsdGVyKHZhbHVlcywgcHJlc2VydmVkVmFsdWVzKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX3Jlc29sdmUodmFsdWVzKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufTtcblxuTWFwcGluZ1Byb21pc2VBcnJheS5wcm90b3R5cGUuX2RyYWluUXVldWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHF1ZXVlID0gdGhpcy5fcXVldWU7XG4gICAgdmFyIGxpbWl0ID0gdGhpcy5fbGltaXQ7XG4gICAgdmFyIHZhbHVlcyA9IHRoaXMuX3ZhbHVlcztcbiAgICB3aGlsZSAocXVldWUubGVuZ3RoID4gMCAmJiB0aGlzLl9pbkZsaWdodCA8IGxpbWl0KSB7XG4gICAgICAgIGlmICh0aGlzLl9pc1Jlc29sdmVkKCkpIHJldHVybjtcbiAgICAgICAgdmFyIGluZGV4ID0gcXVldWUucG9wKCk7XG4gICAgICAgIHRoaXMuX3Byb21pc2VGdWxmaWxsZWQodmFsdWVzW2luZGV4XSwgaW5kZXgpO1xuICAgIH1cbn07XG5cbk1hcHBpbmdQcm9taXNlQXJyYXkucHJvdG90eXBlLl9maWx0ZXIgPSBmdW5jdGlvbiAoYm9vbGVhbnMsIHZhbHVlcykge1xuICAgIHZhciBsZW4gPSB2YWx1ZXMubGVuZ3RoO1xuICAgIHZhciByZXQgPSBuZXcgQXJyYXkobGVuKTtcbiAgICB2YXIgaiA9IDA7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47ICsraSkge1xuICAgICAgICBpZiAoYm9vbGVhbnNbaV0pIHJldFtqKytdID0gdmFsdWVzW2ldO1xuICAgIH1cbiAgICByZXQubGVuZ3RoID0gajtcbiAgICB0aGlzLl9yZXNvbHZlKHJldCk7XG59O1xuXG5NYXBwaW5nUHJvbWlzZUFycmF5LnByb3RvdHlwZS5wcmVzZXJ2ZWRWYWx1ZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3ByZXNlcnZlZFZhbHVlcztcbn07XG5cbmZ1bmN0aW9uIG1hcChwcm9taXNlcywgZm4sIG9wdGlvbnMsIF9maWx0ZXIpIHtcbiAgICBpZiAodHlwZW9mIGZuICE9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgcmV0dXJuIGFwaVJlamVjdGlvbihcImV4cGVjdGluZyBhIGZ1bmN0aW9uIGJ1dCBnb3QgXCIgKyB1dGlsLmNsYXNzU3RyaW5nKGZuKSk7XG4gICAgfVxuXG4gICAgdmFyIGxpbWl0ID0gMDtcbiAgICBpZiAob3B0aW9ucyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGlmICh0eXBlb2Ygb3B0aW9ucyA9PT0gXCJvYmplY3RcIiAmJiBvcHRpb25zICE9PSBudWxsKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIG9wdGlvbnMuY29uY3VycmVuY3kgIT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoXG4gICAgICAgICAgICAgICAgICAgIG5ldyBUeXBlRXJyb3IoXCInY29uY3VycmVuY3knIG11c3QgYmUgYSBudW1iZXIgYnV0IGl0IGlzIFwiICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHV0aWwuY2xhc3NTdHJpbmcob3B0aW9ucy5jb25jdXJyZW5jeSkpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxpbWl0ID0gb3B0aW9ucy5jb25jdXJyZW5jeTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChuZXcgVHlwZUVycm9yKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwib3B0aW9ucyBhcmd1bWVudCBtdXN0IGJlIGFuIG9iamVjdCBidXQgaXQgaXMgXCIgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICB1dGlsLmNsYXNzU3RyaW5nKG9wdGlvbnMpKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgbGltaXQgPSB0eXBlb2YgbGltaXQgPT09IFwibnVtYmVyXCIgJiZcbiAgICAgICAgaXNGaW5pdGUobGltaXQpICYmIGxpbWl0ID49IDEgPyBsaW1pdCA6IDA7XG4gICAgcmV0dXJuIG5ldyBNYXBwaW5nUHJvbWlzZUFycmF5KHByb21pc2VzLCBmbiwgbGltaXQsIF9maWx0ZXIpLnByb21pc2UoKTtcbn1cblxuUHJvbWlzZS5wcm90b3R5cGUubWFwID0gZnVuY3Rpb24gKGZuLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIG1hcCh0aGlzLCBmbiwgb3B0aW9ucywgbnVsbCk7XG59O1xuXG5Qcm9taXNlLm1hcCA9IGZ1bmN0aW9uIChwcm9taXNlcywgZm4sIG9wdGlvbnMsIF9maWx0ZXIpIHtcbiAgICByZXR1cm4gbWFwKHByb21pc2VzLCBmbiwgb3B0aW9ucywgX2ZpbHRlcik7XG59O1xuXG5cbn07XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvYmx1ZWJpcmQvanMvcmVsZWFzZS9tYXAuanMiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBjciA9IE9iamVjdC5jcmVhdGU7XG5pZiAoY3IpIHtcbiAgICB2YXIgY2FsbGVyQ2FjaGUgPSBjcihudWxsKTtcbiAgICB2YXIgZ2V0dGVyQ2FjaGUgPSBjcihudWxsKTtcbiAgICBjYWxsZXJDYWNoZVtcIiBzaXplXCJdID0gZ2V0dGVyQ2FjaGVbXCIgc2l6ZVwiXSA9IDA7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oUHJvbWlzZSkge1xudmFyIHV0aWwgPSByZXF1aXJlKFwiLi91dGlsXCIpO1xudmFyIGNhbkV2YWx1YXRlID0gdXRpbC5jYW5FdmFsdWF0ZTtcbnZhciBpc0lkZW50aWZpZXIgPSB1dGlsLmlzSWRlbnRpZmllcjtcblxudmFyIGdldE1ldGhvZENhbGxlcjtcbnZhciBnZXRHZXR0ZXI7XG5pZiAoIWZhbHNlKSB7XG52YXIgbWFrZU1ldGhvZENhbGxlciA9IGZ1bmN0aW9uIChtZXRob2ROYW1lKSB7XG4gICAgcmV0dXJuIG5ldyBGdW5jdGlvbihcImVuc3VyZU1ldGhvZFwiLCBcIiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxcblxcXG4gICAgICAgIHJldHVybiBmdW5jdGlvbihvYmopIHsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxcblxcXG4gICAgICAgICAgICAndXNlIHN0cmljdCcgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxcblxcXG4gICAgICAgICAgICB2YXIgbGVuID0gdGhpcy5sZW5ndGg7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxcblxcXG4gICAgICAgICAgICBlbnN1cmVNZXRob2Qob2JqLCAnbWV0aG9kTmFtZScpOyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxcblxcXG4gICAgICAgICAgICBzd2l0Y2gobGVuKSB7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxcblxcXG4gICAgICAgICAgICAgICAgY2FzZSAxOiByZXR1cm4gb2JqLm1ldGhvZE5hbWUodGhpc1swXSk7ICAgICAgICAgICAgICAgICAgICAgIFxcblxcXG4gICAgICAgICAgICAgICAgY2FzZSAyOiByZXR1cm4gb2JqLm1ldGhvZE5hbWUodGhpc1swXSwgdGhpc1sxXSk7ICAgICAgICAgICAgIFxcblxcXG4gICAgICAgICAgICAgICAgY2FzZSAzOiByZXR1cm4gb2JqLm1ldGhvZE5hbWUodGhpc1swXSwgdGhpc1sxXSwgdGhpc1syXSk7ICAgIFxcblxcXG4gICAgICAgICAgICAgICAgY2FzZSAwOiByZXR1cm4gb2JqLm1ldGhvZE5hbWUoKTsgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxcblxcXG4gICAgICAgICAgICAgICAgZGVmYXVsdDogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxcblxcXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBvYmoubWV0aG9kTmFtZS5hcHBseShvYmosIHRoaXMpOyAgICAgICAgICAgICAgICAgIFxcblxcXG4gICAgICAgICAgICB9ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxcblxcXG4gICAgICAgIH07ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxcblxcXG4gICAgICAgIFwiLnJlcGxhY2UoL21ldGhvZE5hbWUvZywgbWV0aG9kTmFtZSkpKGVuc3VyZU1ldGhvZCk7XG59O1xuXG52YXIgbWFrZUdldHRlciA9IGZ1bmN0aW9uIChwcm9wZXJ0eU5hbWUpIHtcbiAgICByZXR1cm4gbmV3IEZ1bmN0aW9uKFwib2JqXCIsIFwiICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXFxuXFxcbiAgICAgICAgJ3VzZSBzdHJpY3QnOyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXFxuXFxcbiAgICAgICAgcmV0dXJuIG9iai5wcm9wZXJ0eU5hbWU7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXFxuXFxcbiAgICAgICAgXCIucmVwbGFjZShcInByb3BlcnR5TmFtZVwiLCBwcm9wZXJ0eU5hbWUpKTtcbn07XG5cbnZhciBnZXRDb21waWxlZCA9IGZ1bmN0aW9uKG5hbWUsIGNvbXBpbGVyLCBjYWNoZSkge1xuICAgIHZhciByZXQgPSBjYWNoZVtuYW1lXTtcbiAgICBpZiAodHlwZW9mIHJldCAhPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIGlmICghaXNJZGVudGlmaWVyKG5hbWUpKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICByZXQgPSBjb21waWxlcihuYW1lKTtcbiAgICAgICAgY2FjaGVbbmFtZV0gPSByZXQ7XG4gICAgICAgIGNhY2hlW1wiIHNpemVcIl0rKztcbiAgICAgICAgaWYgKGNhY2hlW1wiIHNpemVcIl0gPiA1MTIpIHtcbiAgICAgICAgICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXMoY2FjaGUpO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCAyNTY7ICsraSkgZGVsZXRlIGNhY2hlW2tleXNbaV1dO1xuICAgICAgICAgICAgY2FjaGVbXCIgc2l6ZVwiXSA9IGtleXMubGVuZ3RoIC0gMjU2O1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXQ7XG59O1xuXG5nZXRNZXRob2RDYWxsZXIgPSBmdW5jdGlvbihuYW1lKSB7XG4gICAgcmV0dXJuIGdldENvbXBpbGVkKG5hbWUsIG1ha2VNZXRob2RDYWxsZXIsIGNhbGxlckNhY2hlKTtcbn07XG5cbmdldEdldHRlciA9IGZ1bmN0aW9uKG5hbWUpIHtcbiAgICByZXR1cm4gZ2V0Q29tcGlsZWQobmFtZSwgbWFrZUdldHRlciwgZ2V0dGVyQ2FjaGUpO1xufTtcbn1cblxuZnVuY3Rpb24gZW5zdXJlTWV0aG9kKG9iaiwgbWV0aG9kTmFtZSkge1xuICAgIHZhciBmbjtcbiAgICBpZiAob2JqICE9IG51bGwpIGZuID0gb2JqW21ldGhvZE5hbWVdO1xuICAgIGlmICh0eXBlb2YgZm4gIT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICB2YXIgbWVzc2FnZSA9IFwiT2JqZWN0IFwiICsgdXRpbC5jbGFzc1N0cmluZyhvYmopICsgXCIgaGFzIG5vIG1ldGhvZCAnXCIgK1xuICAgICAgICAgICAgdXRpbC50b1N0cmluZyhtZXRob2ROYW1lKSArIFwiJ1wiO1xuICAgICAgICB0aHJvdyBuZXcgUHJvbWlzZS5UeXBlRXJyb3IobWVzc2FnZSk7XG4gICAgfVxuICAgIHJldHVybiBmbjtcbn1cblxuZnVuY3Rpb24gY2FsbGVyKG9iaikge1xuICAgIHZhciBtZXRob2ROYW1lID0gdGhpcy5wb3AoKTtcbiAgICB2YXIgZm4gPSBlbnN1cmVNZXRob2Qob2JqLCBtZXRob2ROYW1lKTtcbiAgICByZXR1cm4gZm4uYXBwbHkob2JqLCB0aGlzKTtcbn1cblByb21pc2UucHJvdG90eXBlLmNhbGwgPSBmdW5jdGlvbiAobWV0aG9kTmFtZSkge1xuICAgIHZhciAkX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGg7dmFyIGFyZ3MgPSBuZXcgQXJyYXkoTWF0aC5tYXgoJF9sZW4gLSAxLCAwKSk7IGZvcih2YXIgJF9pID0gMTsgJF9pIDwgJF9sZW47ICsrJF9pKSB7YXJnc1skX2kgLSAxXSA9IGFyZ3VtZW50c1skX2ldO307XG4gICAgaWYgKCFmYWxzZSkge1xuICAgICAgICBpZiAoY2FuRXZhbHVhdGUpIHtcbiAgICAgICAgICAgIHZhciBtYXliZUNhbGxlciA9IGdldE1ldGhvZENhbGxlcihtZXRob2ROYW1lKTtcbiAgICAgICAgICAgIGlmIChtYXliZUNhbGxlciAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl90aGVuKFxuICAgICAgICAgICAgICAgICAgICBtYXliZUNhbGxlciwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIGFyZ3MsIHVuZGVmaW5lZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXJncy5wdXNoKG1ldGhvZE5hbWUpO1xuICAgIHJldHVybiB0aGlzLl90aGVuKGNhbGxlciwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIGFyZ3MsIHVuZGVmaW5lZCk7XG59O1xuXG5mdW5jdGlvbiBuYW1lZEdldHRlcihvYmopIHtcbiAgICByZXR1cm4gb2JqW3RoaXNdO1xufVxuZnVuY3Rpb24gaW5kZXhlZEdldHRlcihvYmopIHtcbiAgICB2YXIgaW5kZXggPSArdGhpcztcbiAgICBpZiAoaW5kZXggPCAwKSBpbmRleCA9IE1hdGgubWF4KDAsIGluZGV4ICsgb2JqLmxlbmd0aCk7XG4gICAgcmV0dXJuIG9ialtpbmRleF07XG59XG5Qcm9taXNlLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbiAocHJvcGVydHlOYW1lKSB7XG4gICAgdmFyIGlzSW5kZXggPSAodHlwZW9mIHByb3BlcnR5TmFtZSA9PT0gXCJudW1iZXJcIik7XG4gICAgdmFyIGdldHRlcjtcbiAgICBpZiAoIWlzSW5kZXgpIHtcbiAgICAgICAgaWYgKGNhbkV2YWx1YXRlKSB7XG4gICAgICAgICAgICB2YXIgbWF5YmVHZXR0ZXIgPSBnZXRHZXR0ZXIocHJvcGVydHlOYW1lKTtcbiAgICAgICAgICAgIGdldHRlciA9IG1heWJlR2V0dGVyICE9PSBudWxsID8gbWF5YmVHZXR0ZXIgOiBuYW1lZEdldHRlcjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGdldHRlciA9IG5hbWVkR2V0dGVyO1xuICAgICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgICAgZ2V0dGVyID0gaW5kZXhlZEdldHRlcjtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX3RoZW4oZ2V0dGVyLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgcHJvcGVydHlOYW1lLCB1bmRlZmluZWQpO1xufTtcbn07XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvYmx1ZWJpcmQvanMvcmVsZWFzZS9jYWxsX2dldC5qcyIsIlwidXNlIHN0cmljdFwiO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoUHJvbWlzZSwgYXBpUmVqZWN0aW9uLCB0cnlDb252ZXJ0VG9Qcm9taXNlLFxuICAgIGNyZWF0ZUNvbnRleHQsIElOVEVSTkFMLCBkZWJ1Zykge1xuICAgIHZhciB1dGlsID0gcmVxdWlyZShcIi4vdXRpbFwiKTtcbiAgICB2YXIgVHlwZUVycm9yID0gcmVxdWlyZShcIi4vZXJyb3JzXCIpLlR5cGVFcnJvcjtcbiAgICB2YXIgaW5oZXJpdHMgPSByZXF1aXJlKFwiLi91dGlsXCIpLmluaGVyaXRzO1xuICAgIHZhciBlcnJvck9iaiA9IHV0aWwuZXJyb3JPYmo7XG4gICAgdmFyIHRyeUNhdGNoID0gdXRpbC50cnlDYXRjaDtcbiAgICB2YXIgTlVMTCA9IHt9O1xuXG4gICAgZnVuY3Rpb24gdGhyb3dlcihlKSB7XG4gICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKXt0aHJvdyBlO30sIDApO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNhc3RQcmVzZXJ2aW5nRGlzcG9zYWJsZSh0aGVuYWJsZSkge1xuICAgICAgICB2YXIgbWF5YmVQcm9taXNlID0gdHJ5Q29udmVydFRvUHJvbWlzZSh0aGVuYWJsZSk7XG4gICAgICAgIGlmIChtYXliZVByb21pc2UgIT09IHRoZW5hYmxlICYmXG4gICAgICAgICAgICB0eXBlb2YgdGhlbmFibGUuX2lzRGlzcG9zYWJsZSA9PT0gXCJmdW5jdGlvblwiICYmXG4gICAgICAgICAgICB0eXBlb2YgdGhlbmFibGUuX2dldERpc3Bvc2VyID09PSBcImZ1bmN0aW9uXCIgJiZcbiAgICAgICAgICAgIHRoZW5hYmxlLl9pc0Rpc3Bvc2FibGUoKSkge1xuICAgICAgICAgICAgbWF5YmVQcm9taXNlLl9zZXREaXNwb3NhYmxlKHRoZW5hYmxlLl9nZXREaXNwb3NlcigpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWF5YmVQcm9taXNlO1xuICAgIH1cbiAgICBmdW5jdGlvbiBkaXNwb3NlKHJlc291cmNlcywgaW5zcGVjdGlvbikge1xuICAgICAgICB2YXIgaSA9IDA7XG4gICAgICAgIHZhciBsZW4gPSByZXNvdXJjZXMubGVuZ3RoO1xuICAgICAgICB2YXIgcmV0ID0gbmV3IFByb21pc2UoSU5URVJOQUwpO1xuICAgICAgICBmdW5jdGlvbiBpdGVyYXRvcigpIHtcbiAgICAgICAgICAgIGlmIChpID49IGxlbikgcmV0dXJuIHJldC5fZnVsZmlsbCgpO1xuICAgICAgICAgICAgdmFyIG1heWJlUHJvbWlzZSA9IGNhc3RQcmVzZXJ2aW5nRGlzcG9zYWJsZShyZXNvdXJjZXNbaSsrXSk7XG4gICAgICAgICAgICBpZiAobWF5YmVQcm9taXNlIGluc3RhbmNlb2YgUHJvbWlzZSAmJlxuICAgICAgICAgICAgICAgIG1heWJlUHJvbWlzZS5faXNEaXNwb3NhYmxlKCkpIHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBtYXliZVByb21pc2UgPSB0cnlDb252ZXJ0VG9Qcm9taXNlKFxuICAgICAgICAgICAgICAgICAgICAgICAgbWF5YmVQcm9taXNlLl9nZXREaXNwb3NlcigpLnRyeURpc3Bvc2UoaW5zcGVjdGlvbiksXG4gICAgICAgICAgICAgICAgICAgICAgICByZXNvdXJjZXMucHJvbWlzZSk7XG4gICAgICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhyb3dlcihlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKG1heWJlUHJvbWlzZSBpbnN0YW5jZW9mIFByb21pc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG1heWJlUHJvbWlzZS5fdGhlbihpdGVyYXRvciwgdGhyb3dlcixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBudWxsLCBudWxsLCBudWxsKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpdGVyYXRvcigpO1xuICAgICAgICB9XG4gICAgICAgIGl0ZXJhdG9yKCk7XG4gICAgICAgIHJldHVybiByZXQ7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gRGlzcG9zZXIoZGF0YSwgcHJvbWlzZSwgY29udGV4dCkge1xuICAgICAgICB0aGlzLl9kYXRhID0gZGF0YTtcbiAgICAgICAgdGhpcy5fcHJvbWlzZSA9IHByb21pc2U7XG4gICAgICAgIHRoaXMuX2NvbnRleHQgPSBjb250ZXh0O1xuICAgIH1cblxuICAgIERpc3Bvc2VyLnByb3RvdHlwZS5kYXRhID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZGF0YTtcbiAgICB9O1xuXG4gICAgRGlzcG9zZXIucHJvdG90eXBlLnByb21pc2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9wcm9taXNlO1xuICAgIH07XG5cbiAgICBEaXNwb3Nlci5wcm90b3R5cGUucmVzb3VyY2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLnByb21pc2UoKS5pc0Z1bGZpbGxlZCgpKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5wcm9taXNlKCkudmFsdWUoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gTlVMTDtcbiAgICB9O1xuXG4gICAgRGlzcG9zZXIucHJvdG90eXBlLnRyeURpc3Bvc2UgPSBmdW5jdGlvbihpbnNwZWN0aW9uKSB7XG4gICAgICAgIHZhciByZXNvdXJjZSA9IHRoaXMucmVzb3VyY2UoKTtcbiAgICAgICAgdmFyIGNvbnRleHQgPSB0aGlzLl9jb250ZXh0O1xuICAgICAgICBpZiAoY29udGV4dCAhPT0gdW5kZWZpbmVkKSBjb250ZXh0Ll9wdXNoQ29udGV4dCgpO1xuICAgICAgICB2YXIgcmV0ID0gcmVzb3VyY2UgIT09IE5VTExcbiAgICAgICAgICAgID8gdGhpcy5kb0Rpc3Bvc2UocmVzb3VyY2UsIGluc3BlY3Rpb24pIDogbnVsbDtcbiAgICAgICAgaWYgKGNvbnRleHQgIT09IHVuZGVmaW5lZCkgY29udGV4dC5fcG9wQ29udGV4dCgpO1xuICAgICAgICB0aGlzLl9wcm9taXNlLl91bnNldERpc3Bvc2FibGUoKTtcbiAgICAgICAgdGhpcy5fZGF0YSA9IG51bGw7XG4gICAgICAgIHJldHVybiByZXQ7XG4gICAgfTtcblxuICAgIERpc3Bvc2VyLmlzRGlzcG9zZXIgPSBmdW5jdGlvbiAoZCkge1xuICAgICAgICByZXR1cm4gKGQgIT0gbnVsbCAmJlxuICAgICAgICAgICAgICAgIHR5cGVvZiBkLnJlc291cmNlID09PSBcImZ1bmN0aW9uXCIgJiZcbiAgICAgICAgICAgICAgICB0eXBlb2YgZC50cnlEaXNwb3NlID09PSBcImZ1bmN0aW9uXCIpO1xuICAgIH07XG5cbiAgICBmdW5jdGlvbiBGdW5jdGlvbkRpc3Bvc2VyKGZuLCBwcm9taXNlLCBjb250ZXh0KSB7XG4gICAgICAgIHRoaXMuY29uc3RydWN0b3IkKGZuLCBwcm9taXNlLCBjb250ZXh0KTtcbiAgICB9XG4gICAgaW5oZXJpdHMoRnVuY3Rpb25EaXNwb3NlciwgRGlzcG9zZXIpO1xuXG4gICAgRnVuY3Rpb25EaXNwb3Nlci5wcm90b3R5cGUuZG9EaXNwb3NlID0gZnVuY3Rpb24gKHJlc291cmNlLCBpbnNwZWN0aW9uKSB7XG4gICAgICAgIHZhciBmbiA9IHRoaXMuZGF0YSgpO1xuICAgICAgICByZXR1cm4gZm4uY2FsbChyZXNvdXJjZSwgcmVzb3VyY2UsIGluc3BlY3Rpb24pO1xuICAgIH07XG5cbiAgICBmdW5jdGlvbiBtYXliZVVud3JhcERpc3Bvc2VyKHZhbHVlKSB7XG4gICAgICAgIGlmIChEaXNwb3Nlci5pc0Rpc3Bvc2VyKHZhbHVlKSkge1xuICAgICAgICAgICAgdGhpcy5yZXNvdXJjZXNbdGhpcy5pbmRleF0uX3NldERpc3Bvc2FibGUodmFsdWUpO1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlLnByb21pc2UoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gUmVzb3VyY2VMaXN0KGxlbmd0aCkge1xuICAgICAgICB0aGlzLmxlbmd0aCA9IGxlbmd0aDtcbiAgICAgICAgdGhpcy5wcm9taXNlID0gbnVsbDtcbiAgICAgICAgdGhpc1tsZW5ndGgtMV0gPSBudWxsO1xuICAgIH1cblxuICAgIFJlc291cmNlTGlzdC5wcm90b3R5cGUuX3Jlc3VsdENhbmNlbGxlZCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgbGVuID0gdGhpcy5sZW5ndGg7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyArK2kpIHtcbiAgICAgICAgICAgIHZhciBpdGVtID0gdGhpc1tpXTtcbiAgICAgICAgICAgIGlmIChpdGVtIGluc3RhbmNlb2YgUHJvbWlzZSkge1xuICAgICAgICAgICAgICAgIGl0ZW0uY2FuY2VsKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgUHJvbWlzZS51c2luZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgICAgIGlmIChsZW4gPCAyKSByZXR1cm4gYXBpUmVqZWN0aW9uKFxuICAgICAgICAgICAgICAgICAgICAgICAgXCJ5b3UgbXVzdCBwYXNzIGF0IGxlYXN0IDIgYXJndW1lbnRzIHRvIFByb21pc2UudXNpbmdcIik7XG4gICAgICAgIHZhciBmbiA9IGFyZ3VtZW50c1tsZW4gLSAxXTtcbiAgICAgICAgaWYgKHR5cGVvZiBmbiAhPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICByZXR1cm4gYXBpUmVqZWN0aW9uKFwiZXhwZWN0aW5nIGEgZnVuY3Rpb24gYnV0IGdvdCBcIiArIHV0aWwuY2xhc3NTdHJpbmcoZm4pKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgaW5wdXQ7XG4gICAgICAgIHZhciBzcHJlYWRBcmdzID0gdHJ1ZTtcbiAgICAgICAgaWYgKGxlbiA9PT0gMiAmJiBBcnJheS5pc0FycmF5KGFyZ3VtZW50c1swXSkpIHtcbiAgICAgICAgICAgIGlucHV0ID0gYXJndW1lbnRzWzBdO1xuICAgICAgICAgICAgbGVuID0gaW5wdXQubGVuZ3RoO1xuICAgICAgICAgICAgc3ByZWFkQXJncyA9IGZhbHNlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaW5wdXQgPSBhcmd1bWVudHM7XG4gICAgICAgICAgICBsZW4tLTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgcmVzb3VyY2VzID0gbmV3IFJlc291cmNlTGlzdChsZW4pO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgKytpKSB7XG4gICAgICAgICAgICB2YXIgcmVzb3VyY2UgPSBpbnB1dFtpXTtcbiAgICAgICAgICAgIGlmIChEaXNwb3Nlci5pc0Rpc3Bvc2VyKHJlc291cmNlKSkge1xuICAgICAgICAgICAgICAgIHZhciBkaXNwb3NlciA9IHJlc291cmNlO1xuICAgICAgICAgICAgICAgIHJlc291cmNlID0gcmVzb3VyY2UucHJvbWlzZSgpO1xuICAgICAgICAgICAgICAgIHJlc291cmNlLl9zZXREaXNwb3NhYmxlKGRpc3Bvc2VyKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdmFyIG1heWJlUHJvbWlzZSA9IHRyeUNvbnZlcnRUb1Byb21pc2UocmVzb3VyY2UpO1xuICAgICAgICAgICAgICAgIGlmIChtYXliZVByb21pc2UgaW5zdGFuY2VvZiBQcm9taXNlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc291cmNlID1cbiAgICAgICAgICAgICAgICAgICAgICAgIG1heWJlUHJvbWlzZS5fdGhlbihtYXliZVVud3JhcERpc3Bvc2VyLCBudWxsLCBudWxsLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzb3VyY2VzOiByZXNvdXJjZXMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5kZXg6IGlcbiAgICAgICAgICAgICAgICAgICAgfSwgdW5kZWZpbmVkKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXNvdXJjZXNbaV0gPSByZXNvdXJjZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciByZWZsZWN0ZWRSZXNvdXJjZXMgPSBuZXcgQXJyYXkocmVzb3VyY2VzLmxlbmd0aCk7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcmVmbGVjdGVkUmVzb3VyY2VzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICByZWZsZWN0ZWRSZXNvdXJjZXNbaV0gPSBQcm9taXNlLnJlc29sdmUocmVzb3VyY2VzW2ldKS5yZWZsZWN0KCk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgcmVzdWx0UHJvbWlzZSA9IFByb21pc2UuYWxsKHJlZmxlY3RlZFJlc291cmNlcylcbiAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uKGluc3BlY3Rpb25zKSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBpbnNwZWN0aW9ucy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgaW5zcGVjdGlvbiA9IGluc3BlY3Rpb25zW2ldO1xuICAgICAgICAgICAgICAgICAgICBpZiAoaW5zcGVjdGlvbi5pc1JlamVjdGVkKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yT2JqLmUgPSBpbnNwZWN0aW9uLmVycm9yKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZXJyb3JPYmo7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoIWluc3BlY3Rpb24uaXNGdWxmaWxsZWQoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0UHJvbWlzZS5jYW5jZWwoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpbnNwZWN0aW9uc1tpXSA9IGluc3BlY3Rpb24udmFsdWUoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcHJvbWlzZS5fcHVzaENvbnRleHQoKTtcblxuICAgICAgICAgICAgICAgIGZuID0gdHJ5Q2F0Y2goZm4pO1xuICAgICAgICAgICAgICAgIHZhciByZXQgPSBzcHJlYWRBcmdzXG4gICAgICAgICAgICAgICAgICAgID8gZm4uYXBwbHkodW5kZWZpbmVkLCBpbnNwZWN0aW9ucykgOiBmbihpbnNwZWN0aW9ucyk7XG4gICAgICAgICAgICAgICAgdmFyIHByb21pc2VDcmVhdGVkID0gcHJvbWlzZS5fcG9wQ29udGV4dCgpO1xuICAgICAgICAgICAgICAgIGRlYnVnLmNoZWNrRm9yZ290dGVuUmV0dXJucyhcbiAgICAgICAgICAgICAgICAgICAgcmV0LCBwcm9taXNlQ3JlYXRlZCwgXCJQcm9taXNlLnVzaW5nXCIsIHByb21pc2UpO1xuICAgICAgICAgICAgICAgIHJldHVybiByZXQ7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICB2YXIgcHJvbWlzZSA9IHJlc3VsdFByb21pc2UubGFzdGx5KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIGluc3BlY3Rpb24gPSBuZXcgUHJvbWlzZS5Qcm9taXNlSW5zcGVjdGlvbihyZXN1bHRQcm9taXNlKTtcbiAgICAgICAgICAgIHJldHVybiBkaXNwb3NlKHJlc291cmNlcywgaW5zcGVjdGlvbik7XG4gICAgICAgIH0pO1xuICAgICAgICByZXNvdXJjZXMucHJvbWlzZSA9IHByb21pc2U7XG4gICAgICAgIHByb21pc2UuX3NldE9uQ2FuY2VsKHJlc291cmNlcyk7XG4gICAgICAgIHJldHVybiBwcm9taXNlO1xuICAgIH07XG5cbiAgICBQcm9taXNlLnByb3RvdHlwZS5fc2V0RGlzcG9zYWJsZSA9IGZ1bmN0aW9uIChkaXNwb3Nlcikge1xuICAgICAgICB0aGlzLl9iaXRGaWVsZCA9IHRoaXMuX2JpdEZpZWxkIHwgMTMxMDcyO1xuICAgICAgICB0aGlzLl9kaXNwb3NlciA9IGRpc3Bvc2VyO1xuICAgIH07XG5cbiAgICBQcm9taXNlLnByb3RvdHlwZS5faXNEaXNwb3NhYmxlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gKHRoaXMuX2JpdEZpZWxkICYgMTMxMDcyKSA+IDA7XG4gICAgfTtcblxuICAgIFByb21pc2UucHJvdG90eXBlLl9nZXREaXNwb3NlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2Rpc3Bvc2VyO1xuICAgIH07XG5cbiAgICBQcm9taXNlLnByb3RvdHlwZS5fdW5zZXREaXNwb3NhYmxlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLl9iaXRGaWVsZCA9IHRoaXMuX2JpdEZpZWxkICYgKH4xMzEwNzIpO1xuICAgICAgICB0aGlzLl9kaXNwb3NlciA9IHVuZGVmaW5lZDtcbiAgICB9O1xuXG4gICAgUHJvbWlzZS5wcm90b3R5cGUuZGlzcG9zZXIgPSBmdW5jdGlvbiAoZm4pIHtcbiAgICAgICAgaWYgKHR5cGVvZiBmbiA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEZ1bmN0aW9uRGlzcG9zZXIoZm4sIHRoaXMsIGNyZWF0ZUNvbnRleHQoKSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcigpO1xuICAgIH07XG5cbn07XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvYmx1ZWJpcmQvanMvcmVsZWFzZS91c2luZy5qcyIsIlwidXNlIHN0cmljdFwiO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihQcm9taXNlLCBJTlRFUk5BTCwgZGVidWcpIHtcbnZhciB1dGlsID0gcmVxdWlyZShcIi4vdXRpbFwiKTtcbnZhciBUaW1lb3V0RXJyb3IgPSBQcm9taXNlLlRpbWVvdXRFcnJvcjtcblxuZnVuY3Rpb24gSGFuZGxlV3JhcHBlcihoYW5kbGUpICB7XG4gICAgdGhpcy5oYW5kbGUgPSBoYW5kbGU7XG59XG5cbkhhbmRsZVdyYXBwZXIucHJvdG90eXBlLl9yZXN1bHRDYW5jZWxsZWQgPSBmdW5jdGlvbigpIHtcbiAgICBjbGVhclRpbWVvdXQodGhpcy5oYW5kbGUpO1xufTtcblxudmFyIGFmdGVyVmFsdWUgPSBmdW5jdGlvbih2YWx1ZSkgeyByZXR1cm4gZGVsYXkoK3RoaXMpLnRoZW5SZXR1cm4odmFsdWUpOyB9O1xudmFyIGRlbGF5ID0gUHJvbWlzZS5kZWxheSA9IGZ1bmN0aW9uIChtcywgdmFsdWUpIHtcbiAgICB2YXIgcmV0O1xuICAgIHZhciBoYW5kbGU7XG4gICAgaWYgKHZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0ID0gUHJvbWlzZS5yZXNvbHZlKHZhbHVlKVxuICAgICAgICAgICAgICAgIC5fdGhlbihhZnRlclZhbHVlLCBudWxsLCBudWxsLCBtcywgdW5kZWZpbmVkKTtcbiAgICAgICAgaWYgKGRlYnVnLmNhbmNlbGxhdGlvbigpICYmIHZhbHVlIGluc3RhbmNlb2YgUHJvbWlzZSkge1xuICAgICAgICAgICAgcmV0Ll9zZXRPbkNhbmNlbCh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgICByZXQgPSBuZXcgUHJvbWlzZShJTlRFUk5BTCk7XG4gICAgICAgIGhhbmRsZSA9IHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7IHJldC5fZnVsZmlsbCgpOyB9LCArbXMpO1xuICAgICAgICBpZiAoZGVidWcuY2FuY2VsbGF0aW9uKCkpIHtcbiAgICAgICAgICAgIHJldC5fc2V0T25DYW5jZWwobmV3IEhhbmRsZVdyYXBwZXIoaGFuZGxlKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0Ll9jYXB0dXJlU3RhY2tUcmFjZSgpO1xuICAgIH1cbiAgICByZXQuX3NldEFzeW5jR3VhcmFudGVlZCgpO1xuICAgIHJldHVybiByZXQ7XG59O1xuXG5Qcm9taXNlLnByb3RvdHlwZS5kZWxheSA9IGZ1bmN0aW9uIChtcykge1xuICAgIHJldHVybiBkZWxheShtcywgdGhpcyk7XG59O1xuXG52YXIgYWZ0ZXJUaW1lb3V0ID0gZnVuY3Rpb24gKHByb21pc2UsIG1lc3NhZ2UsIHBhcmVudCkge1xuICAgIHZhciBlcnI7XG4gICAgaWYgKHR5cGVvZiBtZXNzYWdlICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIGlmIChtZXNzYWdlIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgICAgICAgIGVyciA9IG1lc3NhZ2U7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBlcnIgPSBuZXcgVGltZW91dEVycm9yKFwib3BlcmF0aW9uIHRpbWVkIG91dFwiKTtcbiAgICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAgIGVyciA9IG5ldyBUaW1lb3V0RXJyb3IobWVzc2FnZSk7XG4gICAgfVxuICAgIHV0aWwubWFya0FzT3JpZ2luYXRpbmdGcm9tUmVqZWN0aW9uKGVycik7XG4gICAgcHJvbWlzZS5fYXR0YWNoRXh0cmFUcmFjZShlcnIpO1xuICAgIHByb21pc2UuX3JlamVjdChlcnIpO1xuXG4gICAgaWYgKHBhcmVudCAhPSBudWxsKSB7XG4gICAgICAgIHBhcmVudC5jYW5jZWwoKTtcbiAgICB9XG59O1xuXG5mdW5jdGlvbiBzdWNjZXNzQ2xlYXIodmFsdWUpIHtcbiAgICBjbGVhclRpbWVvdXQodGhpcy5oYW5kbGUpO1xuICAgIHJldHVybiB2YWx1ZTtcbn1cblxuZnVuY3Rpb24gZmFpbHVyZUNsZWFyKHJlYXNvbikge1xuICAgIGNsZWFyVGltZW91dCh0aGlzLmhhbmRsZSk7XG4gICAgdGhyb3cgcmVhc29uO1xufVxuXG5Qcm9taXNlLnByb3RvdHlwZS50aW1lb3V0ID0gZnVuY3Rpb24gKG1zLCBtZXNzYWdlKSB7XG4gICAgbXMgPSArbXM7XG4gICAgdmFyIHJldCwgcGFyZW50O1xuXG4gICAgdmFyIGhhbmRsZVdyYXBwZXIgPSBuZXcgSGFuZGxlV3JhcHBlcihzZXRUaW1lb3V0KGZ1bmN0aW9uIHRpbWVvdXRUaW1lb3V0KCkge1xuICAgICAgICBpZiAocmV0LmlzUGVuZGluZygpKSB7XG4gICAgICAgICAgICBhZnRlclRpbWVvdXQocmV0LCBtZXNzYWdlLCBwYXJlbnQpO1xuICAgICAgICB9XG4gICAgfSwgbXMpKTtcblxuICAgIGlmIChkZWJ1Zy5jYW5jZWxsYXRpb24oKSkge1xuICAgICAgICBwYXJlbnQgPSB0aGlzLnRoZW4oKTtcbiAgICAgICAgcmV0ID0gcGFyZW50Ll90aGVuKHN1Y2Nlc3NDbGVhciwgZmFpbHVyZUNsZWFyLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVuZGVmaW5lZCwgaGFuZGxlV3JhcHBlciwgdW5kZWZpbmVkKTtcbiAgICAgICAgcmV0Ll9zZXRPbkNhbmNlbChoYW5kbGVXcmFwcGVyKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXQgPSB0aGlzLl90aGVuKHN1Y2Nlc3NDbGVhciwgZmFpbHVyZUNsZWFyLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVuZGVmaW5lZCwgaGFuZGxlV3JhcHBlciwgdW5kZWZpbmVkKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcmV0O1xufTtcblxufTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9ibHVlYmlyZC9qcy9yZWxlYXNlL3RpbWVycy5qcyIsIlwidXNlIHN0cmljdFwiO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihQcm9taXNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICBhcGlSZWplY3Rpb24sXG4gICAgICAgICAgICAgICAgICAgICAgICAgIElOVEVSTkFMLFxuICAgICAgICAgICAgICAgICAgICAgICAgICB0cnlDb252ZXJ0VG9Qcm9taXNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICBQcm94eWFibGUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGRlYnVnKSB7XG52YXIgZXJyb3JzID0gcmVxdWlyZShcIi4vZXJyb3JzXCIpO1xudmFyIFR5cGVFcnJvciA9IGVycm9ycy5UeXBlRXJyb3I7XG52YXIgdXRpbCA9IHJlcXVpcmUoXCIuL3V0aWxcIik7XG52YXIgZXJyb3JPYmogPSB1dGlsLmVycm9yT2JqO1xudmFyIHRyeUNhdGNoID0gdXRpbC50cnlDYXRjaDtcbnZhciB5aWVsZEhhbmRsZXJzID0gW107XG5cbmZ1bmN0aW9uIHByb21pc2VGcm9tWWllbGRIYW5kbGVyKHZhbHVlLCB5aWVsZEhhbmRsZXJzLCB0cmFjZVBhcmVudCkge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgeWllbGRIYW5kbGVycy5sZW5ndGg7ICsraSkge1xuICAgICAgICB0cmFjZVBhcmVudC5fcHVzaENvbnRleHQoKTtcbiAgICAgICAgdmFyIHJlc3VsdCA9IHRyeUNhdGNoKHlpZWxkSGFuZGxlcnNbaV0pKHZhbHVlKTtcbiAgICAgICAgdHJhY2VQYXJlbnQuX3BvcENvbnRleHQoKTtcbiAgICAgICAgaWYgKHJlc3VsdCA9PT0gZXJyb3JPYmopIHtcbiAgICAgICAgICAgIHRyYWNlUGFyZW50Ll9wdXNoQ29udGV4dCgpO1xuICAgICAgICAgICAgdmFyIHJldCA9IFByb21pc2UucmVqZWN0KGVycm9yT2JqLmUpO1xuICAgICAgICAgICAgdHJhY2VQYXJlbnQuX3BvcENvbnRleHQoKTtcbiAgICAgICAgICAgIHJldHVybiByZXQ7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG1heWJlUHJvbWlzZSA9IHRyeUNvbnZlcnRUb1Byb21pc2UocmVzdWx0LCB0cmFjZVBhcmVudCk7XG4gICAgICAgIGlmIChtYXliZVByb21pc2UgaW5zdGFuY2VvZiBQcm9taXNlKSByZXR1cm4gbWF5YmVQcm9taXNlO1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbn1cblxuZnVuY3Rpb24gUHJvbWlzZVNwYXduKGdlbmVyYXRvckZ1bmN0aW9uLCByZWNlaXZlciwgeWllbGRIYW5kbGVyLCBzdGFjaykge1xuICAgIGlmIChkZWJ1Zy5jYW5jZWxsYXRpb24oKSkge1xuICAgICAgICB2YXIgaW50ZXJuYWwgPSBuZXcgUHJvbWlzZShJTlRFUk5BTCk7XG4gICAgICAgIHZhciBfZmluYWxseVByb21pc2UgPSB0aGlzLl9maW5hbGx5UHJvbWlzZSA9IG5ldyBQcm9taXNlKElOVEVSTkFMKTtcbiAgICAgICAgdGhpcy5fcHJvbWlzZSA9IGludGVybmFsLmxhc3RseShmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiBfZmluYWxseVByb21pc2U7XG4gICAgICAgIH0pO1xuICAgICAgICBpbnRlcm5hbC5fY2FwdHVyZVN0YWNrVHJhY2UoKTtcbiAgICAgICAgaW50ZXJuYWwuX3NldE9uQ2FuY2VsKHRoaXMpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBwcm9taXNlID0gdGhpcy5fcHJvbWlzZSA9IG5ldyBQcm9taXNlKElOVEVSTkFMKTtcbiAgICAgICAgcHJvbWlzZS5fY2FwdHVyZVN0YWNrVHJhY2UoKTtcbiAgICB9XG4gICAgdGhpcy5fc3RhY2sgPSBzdGFjaztcbiAgICB0aGlzLl9nZW5lcmF0b3JGdW5jdGlvbiA9IGdlbmVyYXRvckZ1bmN0aW9uO1xuICAgIHRoaXMuX3JlY2VpdmVyID0gcmVjZWl2ZXI7XG4gICAgdGhpcy5fZ2VuZXJhdG9yID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuX3lpZWxkSGFuZGxlcnMgPSB0eXBlb2YgeWllbGRIYW5kbGVyID09PSBcImZ1bmN0aW9uXCJcbiAgICAgICAgPyBbeWllbGRIYW5kbGVyXS5jb25jYXQoeWllbGRIYW5kbGVycylcbiAgICAgICAgOiB5aWVsZEhhbmRsZXJzO1xuICAgIHRoaXMuX3lpZWxkZWRQcm9taXNlID0gbnVsbDtcbiAgICB0aGlzLl9jYW5jZWxsYXRpb25QaGFzZSA9IGZhbHNlO1xufVxudXRpbC5pbmhlcml0cyhQcm9taXNlU3Bhd24sIFByb3h5YWJsZSk7XG5cblByb21pc2VTcGF3bi5wcm90b3R5cGUuX2lzUmVzb2x2ZWQgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5fcHJvbWlzZSA9PT0gbnVsbDtcbn07XG5cblByb21pc2VTcGF3bi5wcm90b3R5cGUuX2NsZWFudXAgPSBmdW5jdGlvbigpIHtcbiAgICB0aGlzLl9wcm9taXNlID0gdGhpcy5fZ2VuZXJhdG9yID0gbnVsbDtcbiAgICBpZiAoZGVidWcuY2FuY2VsbGF0aW9uKCkgJiYgdGhpcy5fZmluYWxseVByb21pc2UgIT09IG51bGwpIHtcbiAgICAgICAgdGhpcy5fZmluYWxseVByb21pc2UuX2Z1bGZpbGwoKTtcbiAgICAgICAgdGhpcy5fZmluYWxseVByb21pc2UgPSBudWxsO1xuICAgIH1cbn07XG5cblByb21pc2VTcGF3bi5wcm90b3R5cGUuX3Byb21pc2VDYW5jZWxsZWQgPSBmdW5jdGlvbigpIHtcbiAgICBpZiAodGhpcy5faXNSZXNvbHZlZCgpKSByZXR1cm47XG4gICAgdmFyIGltcGxlbWVudHNSZXR1cm4gPSB0eXBlb2YgdGhpcy5fZ2VuZXJhdG9yW1wicmV0dXJuXCJdICE9PSBcInVuZGVmaW5lZFwiO1xuXG4gICAgdmFyIHJlc3VsdDtcbiAgICBpZiAoIWltcGxlbWVudHNSZXR1cm4pIHtcbiAgICAgICAgdmFyIHJlYXNvbiA9IG5ldyBQcm9taXNlLkNhbmNlbGxhdGlvbkVycm9yKFxuICAgICAgICAgICAgXCJnZW5lcmF0b3IgLnJldHVybigpIHNlbnRpbmVsXCIpO1xuICAgICAgICBQcm9taXNlLmNvcm91dGluZS5yZXR1cm5TZW50aW5lbCA9IHJlYXNvbjtcbiAgICAgICAgdGhpcy5fcHJvbWlzZS5fYXR0YWNoRXh0cmFUcmFjZShyZWFzb24pO1xuICAgICAgICB0aGlzLl9wcm9taXNlLl9wdXNoQ29udGV4dCgpO1xuICAgICAgICByZXN1bHQgPSB0cnlDYXRjaCh0aGlzLl9nZW5lcmF0b3JbXCJ0aHJvd1wiXSkuY2FsbCh0aGlzLl9nZW5lcmF0b3IsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWFzb24pO1xuICAgICAgICB0aGlzLl9wcm9taXNlLl9wb3BDb250ZXh0KCk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5fcHJvbWlzZS5fcHVzaENvbnRleHQoKTtcbiAgICAgICAgcmVzdWx0ID0gdHJ5Q2F0Y2godGhpcy5fZ2VuZXJhdG9yW1wicmV0dXJuXCJdKS5jYWxsKHRoaXMuX2dlbmVyYXRvcixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB1bmRlZmluZWQpO1xuICAgICAgICB0aGlzLl9wcm9taXNlLl9wb3BDb250ZXh0KCk7XG4gICAgfVxuICAgIHRoaXMuX2NhbmNlbGxhdGlvblBoYXNlID0gdHJ1ZTtcbiAgICB0aGlzLl95aWVsZGVkUHJvbWlzZSA9IG51bGw7XG4gICAgdGhpcy5fY29udGludWUocmVzdWx0KTtcbn07XG5cblByb21pc2VTcGF3bi5wcm90b3R5cGUuX3Byb21pc2VGdWxmaWxsZWQgPSBmdW5jdGlvbih2YWx1ZSkge1xuICAgIHRoaXMuX3lpZWxkZWRQcm9taXNlID0gbnVsbDtcbiAgICB0aGlzLl9wcm9taXNlLl9wdXNoQ29udGV4dCgpO1xuICAgIHZhciByZXN1bHQgPSB0cnlDYXRjaCh0aGlzLl9nZW5lcmF0b3IubmV4dCkuY2FsbCh0aGlzLl9nZW5lcmF0b3IsIHZhbHVlKTtcbiAgICB0aGlzLl9wcm9taXNlLl9wb3BDb250ZXh0KCk7XG4gICAgdGhpcy5fY29udGludWUocmVzdWx0KTtcbn07XG5cblByb21pc2VTcGF3bi5wcm90b3R5cGUuX3Byb21pc2VSZWplY3RlZCA9IGZ1bmN0aW9uKHJlYXNvbikge1xuICAgIHRoaXMuX3lpZWxkZWRQcm9taXNlID0gbnVsbDtcbiAgICB0aGlzLl9wcm9taXNlLl9hdHRhY2hFeHRyYVRyYWNlKHJlYXNvbik7XG4gICAgdGhpcy5fcHJvbWlzZS5fcHVzaENvbnRleHQoKTtcbiAgICB2YXIgcmVzdWx0ID0gdHJ5Q2F0Y2godGhpcy5fZ2VuZXJhdG9yW1widGhyb3dcIl0pXG4gICAgICAgIC5jYWxsKHRoaXMuX2dlbmVyYXRvciwgcmVhc29uKTtcbiAgICB0aGlzLl9wcm9taXNlLl9wb3BDb250ZXh0KCk7XG4gICAgdGhpcy5fY29udGludWUocmVzdWx0KTtcbn07XG5cblByb21pc2VTcGF3bi5wcm90b3R5cGUuX3Jlc3VsdENhbmNlbGxlZCA9IGZ1bmN0aW9uKCkge1xuICAgIGlmICh0aGlzLl95aWVsZGVkUHJvbWlzZSBpbnN0YW5jZW9mIFByb21pc2UpIHtcbiAgICAgICAgdmFyIHByb21pc2UgPSB0aGlzLl95aWVsZGVkUHJvbWlzZTtcbiAgICAgICAgdGhpcy5feWllbGRlZFByb21pc2UgPSBudWxsO1xuICAgICAgICBwcm9taXNlLmNhbmNlbCgpO1xuICAgIH1cbn07XG5cblByb21pc2VTcGF3bi5wcm90b3R5cGUucHJvbWlzZSA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5fcHJvbWlzZTtcbn07XG5cblByb21pc2VTcGF3bi5wcm90b3R5cGUuX3J1biA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLl9nZW5lcmF0b3IgPSB0aGlzLl9nZW5lcmF0b3JGdW5jdGlvbi5jYWxsKHRoaXMuX3JlY2VpdmVyKTtcbiAgICB0aGlzLl9yZWNlaXZlciA9XG4gICAgICAgIHRoaXMuX2dlbmVyYXRvckZ1bmN0aW9uID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuX3Byb21pc2VGdWxmaWxsZWQodW5kZWZpbmVkKTtcbn07XG5cblByb21pc2VTcGF3bi5wcm90b3R5cGUuX2NvbnRpbnVlID0gZnVuY3Rpb24gKHJlc3VsdCkge1xuICAgIHZhciBwcm9taXNlID0gdGhpcy5fcHJvbWlzZTtcbiAgICBpZiAocmVzdWx0ID09PSBlcnJvck9iaikge1xuICAgICAgICB0aGlzLl9jbGVhbnVwKCk7XG4gICAgICAgIGlmICh0aGlzLl9jYW5jZWxsYXRpb25QaGFzZSkge1xuICAgICAgICAgICAgcmV0dXJuIHByb21pc2UuY2FuY2VsKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gcHJvbWlzZS5fcmVqZWN0Q2FsbGJhY2socmVzdWx0LmUsIGZhbHNlKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHZhciB2YWx1ZSA9IHJlc3VsdC52YWx1ZTtcbiAgICBpZiAocmVzdWx0LmRvbmUgPT09IHRydWUpIHtcbiAgICAgICAgdGhpcy5fY2xlYW51cCgpO1xuICAgICAgICBpZiAodGhpcy5fY2FuY2VsbGF0aW9uUGhhc2UpIHtcbiAgICAgICAgICAgIHJldHVybiBwcm9taXNlLmNhbmNlbCgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHByb21pc2UuX3Jlc29sdmVDYWxsYmFjayh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgbWF5YmVQcm9taXNlID0gdHJ5Q29udmVydFRvUHJvbWlzZSh2YWx1ZSwgdGhpcy5fcHJvbWlzZSk7XG4gICAgICAgIGlmICghKG1heWJlUHJvbWlzZSBpbnN0YW5jZW9mIFByb21pc2UpKSB7XG4gICAgICAgICAgICBtYXliZVByb21pc2UgPVxuICAgICAgICAgICAgICAgIHByb21pc2VGcm9tWWllbGRIYW5kbGVyKG1heWJlUHJvbWlzZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl95aWVsZEhhbmRsZXJzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3Byb21pc2UpO1xuICAgICAgICAgICAgaWYgKG1heWJlUHJvbWlzZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3Byb21pc2VSZWplY3RlZChcbiAgICAgICAgICAgICAgICAgICAgbmV3IFR5cGVFcnJvcihcbiAgICAgICAgICAgICAgICAgICAgICAgIFwiQSB2YWx1ZSAlcyB3YXMgeWllbGRlZCB0aGF0IGNvdWxkIG5vdCBiZSB0cmVhdGVkIGFzIGEgcHJvbWlzZVxcdTAwMGFcXHUwMDBhICAgIFNlZSBodHRwOi8vZ29vLmdsL01xckZtWFxcdTAwMGFcXHUwMDBhXCIucmVwbGFjZShcIiVzXCIsIFN0cmluZyh2YWx1ZSkpICtcbiAgICAgICAgICAgICAgICAgICAgICAgIFwiRnJvbSBjb3JvdXRpbmU6XFx1MDAwYVwiICtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3N0YWNrLnNwbGl0KFwiXFxuXCIpLnNsaWNlKDEsIC03KS5qb2luKFwiXFxuXCIpXG4gICAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBtYXliZVByb21pc2UgPSBtYXliZVByb21pc2UuX3RhcmdldCgpO1xuICAgICAgICB2YXIgYml0RmllbGQgPSBtYXliZVByb21pc2UuX2JpdEZpZWxkO1xuICAgICAgICA7XG4gICAgICAgIGlmICgoKGJpdEZpZWxkICYgNTAzOTcxODQpID09PSAwKSkge1xuICAgICAgICAgICAgdGhpcy5feWllbGRlZFByb21pc2UgPSBtYXliZVByb21pc2U7XG4gICAgICAgICAgICBtYXliZVByb21pc2UuX3Byb3h5KHRoaXMsIG51bGwpO1xuICAgICAgICB9IGVsc2UgaWYgKCgoYml0RmllbGQgJiAzMzU1NDQzMikgIT09IDApKSB7XG4gICAgICAgICAgICBQcm9taXNlLl9hc3luYy5pbnZva2UoXG4gICAgICAgICAgICAgICAgdGhpcy5fcHJvbWlzZUZ1bGZpbGxlZCwgdGhpcywgbWF5YmVQcm9taXNlLl92YWx1ZSgpXG4gICAgICAgICAgICApO1xuICAgICAgICB9IGVsc2UgaWYgKCgoYml0RmllbGQgJiAxNjc3NzIxNikgIT09IDApKSB7XG4gICAgICAgICAgICBQcm9taXNlLl9hc3luYy5pbnZva2UoXG4gICAgICAgICAgICAgICAgdGhpcy5fcHJvbWlzZVJlamVjdGVkLCB0aGlzLCBtYXliZVByb21pc2UuX3JlYXNvbigpXG4gICAgICAgICAgICApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5fcHJvbWlzZUNhbmNlbGxlZCgpO1xuICAgICAgICB9XG4gICAgfVxufTtcblxuUHJvbWlzZS5jb3JvdXRpbmUgPSBmdW5jdGlvbiAoZ2VuZXJhdG9yRnVuY3Rpb24sIG9wdGlvbnMpIHtcbiAgICBpZiAodHlwZW9mIGdlbmVyYXRvckZ1bmN0aW9uICE9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcImdlbmVyYXRvckZ1bmN0aW9uIG11c3QgYmUgYSBmdW5jdGlvblxcdTAwMGFcXHUwMDBhICAgIFNlZSBodHRwOi8vZ29vLmdsL01xckZtWFxcdTAwMGFcIik7XG4gICAgfVxuICAgIHZhciB5aWVsZEhhbmRsZXIgPSBPYmplY3Qob3B0aW9ucykueWllbGRIYW5kbGVyO1xuICAgIHZhciBQcm9taXNlU3Bhd24kID0gUHJvbWlzZVNwYXduO1xuICAgIHZhciBzdGFjayA9IG5ldyBFcnJvcigpLnN0YWNrO1xuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBnZW5lcmF0b3IgPSBnZW5lcmF0b3JGdW5jdGlvbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICB2YXIgc3Bhd24gPSBuZXcgUHJvbWlzZVNwYXduJCh1bmRlZmluZWQsIHVuZGVmaW5lZCwgeWllbGRIYW5kbGVyLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGFjayk7XG4gICAgICAgIHZhciByZXQgPSBzcGF3bi5wcm9taXNlKCk7XG4gICAgICAgIHNwYXduLl9nZW5lcmF0b3IgPSBnZW5lcmF0b3I7XG4gICAgICAgIHNwYXduLl9wcm9taXNlRnVsZmlsbGVkKHVuZGVmaW5lZCk7XG4gICAgICAgIHJldHVybiByZXQ7XG4gICAgfTtcbn07XG5cblByb21pc2UuY29yb3V0aW5lLmFkZFlpZWxkSGFuZGxlciA9IGZ1bmN0aW9uKGZuKSB7XG4gICAgaWYgKHR5cGVvZiBmbiAhPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJleHBlY3RpbmcgYSBmdW5jdGlvbiBidXQgZ290IFwiICsgdXRpbC5jbGFzc1N0cmluZyhmbikpO1xuICAgIH1cbiAgICB5aWVsZEhhbmRsZXJzLnB1c2goZm4pO1xufTtcblxuUHJvbWlzZS5zcGF3biA9IGZ1bmN0aW9uIChnZW5lcmF0b3JGdW5jdGlvbikge1xuICAgIGRlYnVnLmRlcHJlY2F0ZWQoXCJQcm9taXNlLnNwYXduKClcIiwgXCJQcm9taXNlLmNvcm91dGluZSgpXCIpO1xuICAgIGlmICh0eXBlb2YgZ2VuZXJhdG9yRnVuY3Rpb24gIT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICByZXR1cm4gYXBpUmVqZWN0aW9uKFwiZ2VuZXJhdG9yRnVuY3Rpb24gbXVzdCBiZSBhIGZ1bmN0aW9uXFx1MDAwYVxcdTAwMGEgICAgU2VlIGh0dHA6Ly9nb28uZ2wvTXFyRm1YXFx1MDAwYVwiKTtcbiAgICB9XG4gICAgdmFyIHNwYXduID0gbmV3IFByb21pc2VTcGF3bihnZW5lcmF0b3JGdW5jdGlvbiwgdGhpcyk7XG4gICAgdmFyIHJldCA9IHNwYXduLnByb21pc2UoKTtcbiAgICBzcGF3bi5fcnVuKFByb21pc2Uuc3Bhd24pO1xuICAgIHJldHVybiByZXQ7XG59O1xufTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9ibHVlYmlyZC9qcy9yZWxlYXNlL2dlbmVyYXRvcnMuanMiLCJcInVzZSBzdHJpY3RcIjtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oUHJvbWlzZSkge1xudmFyIHV0aWwgPSByZXF1aXJlKFwiLi91dGlsXCIpO1xudmFyIGFzeW5jID0gUHJvbWlzZS5fYXN5bmM7XG52YXIgdHJ5Q2F0Y2ggPSB1dGlsLnRyeUNhdGNoO1xudmFyIGVycm9yT2JqID0gdXRpbC5lcnJvck9iajtcblxuZnVuY3Rpb24gc3ByZWFkQWRhcHRlcih2YWwsIG5vZGViYWNrKSB7XG4gICAgdmFyIHByb21pc2UgPSB0aGlzO1xuICAgIGlmICghdXRpbC5pc0FycmF5KHZhbCkpIHJldHVybiBzdWNjZXNzQWRhcHRlci5jYWxsKHByb21pc2UsIHZhbCwgbm9kZWJhY2spO1xuICAgIHZhciByZXQgPVxuICAgICAgICB0cnlDYXRjaChub2RlYmFjaykuYXBwbHkocHJvbWlzZS5fYm91bmRWYWx1ZSgpLCBbbnVsbF0uY29uY2F0KHZhbCkpO1xuICAgIGlmIChyZXQgPT09IGVycm9yT2JqKSB7XG4gICAgICAgIGFzeW5jLnRocm93TGF0ZXIocmV0LmUpO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gc3VjY2Vzc0FkYXB0ZXIodmFsLCBub2RlYmFjaykge1xuICAgIHZhciBwcm9taXNlID0gdGhpcztcbiAgICB2YXIgcmVjZWl2ZXIgPSBwcm9taXNlLl9ib3VuZFZhbHVlKCk7XG4gICAgdmFyIHJldCA9IHZhbCA9PT0gdW5kZWZpbmVkXG4gICAgICAgID8gdHJ5Q2F0Y2gobm9kZWJhY2spLmNhbGwocmVjZWl2ZXIsIG51bGwpXG4gICAgICAgIDogdHJ5Q2F0Y2gobm9kZWJhY2spLmNhbGwocmVjZWl2ZXIsIG51bGwsIHZhbCk7XG4gICAgaWYgKHJldCA9PT0gZXJyb3JPYmopIHtcbiAgICAgICAgYXN5bmMudGhyb3dMYXRlcihyZXQuZSk7XG4gICAgfVxufVxuZnVuY3Rpb24gZXJyb3JBZGFwdGVyKHJlYXNvbiwgbm9kZWJhY2spIHtcbiAgICB2YXIgcHJvbWlzZSA9IHRoaXM7XG4gICAgaWYgKCFyZWFzb24pIHtcbiAgICAgICAgdmFyIG5ld1JlYXNvbiA9IG5ldyBFcnJvcihyZWFzb24gKyBcIlwiKTtcbiAgICAgICAgbmV3UmVhc29uLmNhdXNlID0gcmVhc29uO1xuICAgICAgICByZWFzb24gPSBuZXdSZWFzb247XG4gICAgfVxuICAgIHZhciByZXQgPSB0cnlDYXRjaChub2RlYmFjaykuY2FsbChwcm9taXNlLl9ib3VuZFZhbHVlKCksIHJlYXNvbik7XG4gICAgaWYgKHJldCA9PT0gZXJyb3JPYmopIHtcbiAgICAgICAgYXN5bmMudGhyb3dMYXRlcihyZXQuZSk7XG4gICAgfVxufVxuXG5Qcm9taXNlLnByb3RvdHlwZS5hc0NhbGxiYWNrID0gUHJvbWlzZS5wcm90b3R5cGUubm9kZWlmeSA9IGZ1bmN0aW9uIChub2RlYmFjayxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnMpIHtcbiAgICBpZiAodHlwZW9mIG5vZGViYWNrID09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICB2YXIgYWRhcHRlciA9IHN1Y2Nlc3NBZGFwdGVyO1xuICAgICAgICBpZiAob3B0aW9ucyAhPT0gdW5kZWZpbmVkICYmIE9iamVjdChvcHRpb25zKS5zcHJlYWQpIHtcbiAgICAgICAgICAgIGFkYXB0ZXIgPSBzcHJlYWRBZGFwdGVyO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3RoZW4oXG4gICAgICAgICAgICBhZGFwdGVyLFxuICAgICAgICAgICAgZXJyb3JBZGFwdGVyLFxuICAgICAgICAgICAgdW5kZWZpbmVkLFxuICAgICAgICAgICAgdGhpcyxcbiAgICAgICAgICAgIG5vZGViYWNrXG4gICAgICAgICk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xufTtcbn07XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvYmx1ZWJpcmQvanMvcmVsZWFzZS9ub2RlaWZ5LmpzIiwiXCJ1c2Ugc3RyaWN0XCI7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKFByb21pc2UsIElOVEVSTkFMKSB7XG52YXIgVEhJUyA9IHt9O1xudmFyIHV0aWwgPSByZXF1aXJlKFwiLi91dGlsXCIpO1xudmFyIG5vZGViYWNrRm9yUHJvbWlzZSA9IHJlcXVpcmUoXCIuL25vZGViYWNrXCIpO1xudmFyIHdpdGhBcHBlbmRlZCA9IHV0aWwud2l0aEFwcGVuZGVkO1xudmFyIG1heWJlV3JhcEFzRXJyb3IgPSB1dGlsLm1heWJlV3JhcEFzRXJyb3I7XG52YXIgY2FuRXZhbHVhdGUgPSB1dGlsLmNhbkV2YWx1YXRlO1xudmFyIFR5cGVFcnJvciA9IHJlcXVpcmUoXCIuL2Vycm9yc1wiKS5UeXBlRXJyb3I7XG52YXIgZGVmYXVsdFN1ZmZpeCA9IFwiQXN5bmNcIjtcbnZhciBkZWZhdWx0UHJvbWlzaWZpZWQgPSB7X19pc1Byb21pc2lmaWVkX186IHRydWV9O1xudmFyIG5vQ29weVByb3BzID0gW1xuICAgIFwiYXJpdHlcIiwgICAgXCJsZW5ndGhcIixcbiAgICBcIm5hbWVcIixcbiAgICBcImFyZ3VtZW50c1wiLFxuICAgIFwiY2FsbGVyXCIsXG4gICAgXCJjYWxsZWVcIixcbiAgICBcInByb3RvdHlwZVwiLFxuICAgIFwiX19pc1Byb21pc2lmaWVkX19cIlxuXTtcbnZhciBub0NvcHlQcm9wc1BhdHRlcm4gPSBuZXcgUmVnRXhwKFwiXig/OlwiICsgbm9Db3B5UHJvcHMuam9pbihcInxcIikgKyBcIikkXCIpO1xuXG52YXIgZGVmYXVsdEZpbHRlciA9IGZ1bmN0aW9uKG5hbWUpIHtcbiAgICByZXR1cm4gdXRpbC5pc0lkZW50aWZpZXIobmFtZSkgJiZcbiAgICAgICAgbmFtZS5jaGFyQXQoMCkgIT09IFwiX1wiICYmXG4gICAgICAgIG5hbWUgIT09IFwiY29uc3RydWN0b3JcIjtcbn07XG5cbmZ1bmN0aW9uIHByb3BzRmlsdGVyKGtleSkge1xuICAgIHJldHVybiAhbm9Db3B5UHJvcHNQYXR0ZXJuLnRlc3Qoa2V5KTtcbn1cblxuZnVuY3Rpb24gaXNQcm9taXNpZmllZChmbikge1xuICAgIHRyeSB7XG4gICAgICAgIHJldHVybiBmbi5fX2lzUHJvbWlzaWZpZWRfXyA9PT0gdHJ1ZTtcbiAgICB9XG4gICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gaGFzUHJvbWlzaWZpZWQob2JqLCBrZXksIHN1ZmZpeCkge1xuICAgIHZhciB2YWwgPSB1dGlsLmdldERhdGFQcm9wZXJ0eU9yRGVmYXVsdChvYmosIGtleSArIHN1ZmZpeCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVmYXVsdFByb21pc2lmaWVkKTtcbiAgICByZXR1cm4gdmFsID8gaXNQcm9taXNpZmllZCh2YWwpIDogZmFsc2U7XG59XG5mdW5jdGlvbiBjaGVja1ZhbGlkKHJldCwgc3VmZml4LCBzdWZmaXhSZWdleHApIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHJldC5sZW5ndGg7IGkgKz0gMikge1xuICAgICAgICB2YXIga2V5ID0gcmV0W2ldO1xuICAgICAgICBpZiAoc3VmZml4UmVnZXhwLnRlc3Qoa2V5KSkge1xuICAgICAgICAgICAgdmFyIGtleVdpdGhvdXRBc3luY1N1ZmZpeCA9IGtleS5yZXBsYWNlKHN1ZmZpeFJlZ2V4cCwgXCJcIik7XG4gICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHJldC5sZW5ndGg7IGogKz0gMikge1xuICAgICAgICAgICAgICAgIGlmIChyZXRbal0gPT09IGtleVdpdGhvdXRBc3luY1N1ZmZpeCkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IHByb21pc2lmeSBhbiBBUEkgdGhhdCBoYXMgbm9ybWFsIG1ldGhvZHMgd2l0aCAnJXMnLXN1ZmZpeFxcdTAwMGFcXHUwMDBhICAgIFNlZSBodHRwOi8vZ29vLmdsL01xckZtWFxcdTAwMGFcIlxuICAgICAgICAgICAgICAgICAgICAgICAgLnJlcGxhY2UoXCIlc1wiLCBzdWZmaXgpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59XG5cbmZ1bmN0aW9uIHByb21pc2lmaWFibGVNZXRob2RzKG9iaiwgc3VmZml4LCBzdWZmaXhSZWdleHAsIGZpbHRlcikge1xuICAgIHZhciBrZXlzID0gdXRpbC5pbmhlcml0ZWREYXRhS2V5cyhvYmopO1xuICAgIHZhciByZXQgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgdmFyIGtleSA9IGtleXNbaV07XG4gICAgICAgIHZhciB2YWx1ZSA9IG9ialtrZXldO1xuICAgICAgICB2YXIgcGFzc2VzRGVmYXVsdEZpbHRlciA9IGZpbHRlciA9PT0gZGVmYXVsdEZpbHRlclxuICAgICAgICAgICAgPyB0cnVlIDogZGVmYXVsdEZpbHRlcihrZXksIHZhbHVlLCBvYmopO1xuICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSBcImZ1bmN0aW9uXCIgJiZcbiAgICAgICAgICAgICFpc1Byb21pc2lmaWVkKHZhbHVlKSAmJlxuICAgICAgICAgICAgIWhhc1Byb21pc2lmaWVkKG9iaiwga2V5LCBzdWZmaXgpICYmXG4gICAgICAgICAgICBmaWx0ZXIoa2V5LCB2YWx1ZSwgb2JqLCBwYXNzZXNEZWZhdWx0RmlsdGVyKSkge1xuICAgICAgICAgICAgcmV0LnB1c2goa2V5LCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY2hlY2tWYWxpZChyZXQsIHN1ZmZpeCwgc3VmZml4UmVnZXhwKTtcbiAgICByZXR1cm4gcmV0O1xufVxuXG52YXIgZXNjYXBlSWRlbnRSZWdleCA9IGZ1bmN0aW9uKHN0cikge1xuICAgIHJldHVybiBzdHIucmVwbGFjZSgvKFskXSkvLCBcIlxcXFwkXCIpO1xufTtcblxudmFyIG1ha2VOb2RlUHJvbWlzaWZpZWRFdmFsO1xuaWYgKCFmYWxzZSkge1xudmFyIHN3aXRjaENhc2VBcmd1bWVudE9yZGVyID0gZnVuY3Rpb24obGlrZWx5QXJndW1lbnRDb3VudCkge1xuICAgIHZhciByZXQgPSBbbGlrZWx5QXJndW1lbnRDb3VudF07XG4gICAgdmFyIG1pbiA9IE1hdGgubWF4KDAsIGxpa2VseUFyZ3VtZW50Q291bnQgLSAxIC0gMyk7XG4gICAgZm9yKHZhciBpID0gbGlrZWx5QXJndW1lbnRDb3VudCAtIDE7IGkgPj0gbWluOyAtLWkpIHtcbiAgICAgICAgcmV0LnB1c2goaSk7XG4gICAgfVxuICAgIGZvcih2YXIgaSA9IGxpa2VseUFyZ3VtZW50Q291bnQgKyAxOyBpIDw9IDM7ICsraSkge1xuICAgICAgICByZXQucHVzaChpKTtcbiAgICB9XG4gICAgcmV0dXJuIHJldDtcbn07XG5cbnZhciBhcmd1bWVudFNlcXVlbmNlID0gZnVuY3Rpb24oYXJndW1lbnRDb3VudCkge1xuICAgIHJldHVybiB1dGlsLmZpbGxlZFJhbmdlKGFyZ3VtZW50Q291bnQsIFwiX2FyZ1wiLCBcIlwiKTtcbn07XG5cbnZhciBwYXJhbWV0ZXJEZWNsYXJhdGlvbiA9IGZ1bmN0aW9uKHBhcmFtZXRlckNvdW50KSB7XG4gICAgcmV0dXJuIHV0aWwuZmlsbGVkUmFuZ2UoXG4gICAgICAgIE1hdGgubWF4KHBhcmFtZXRlckNvdW50LCAzKSwgXCJfYXJnXCIsIFwiXCIpO1xufTtcblxudmFyIHBhcmFtZXRlckNvdW50ID0gZnVuY3Rpb24oZm4pIHtcbiAgICBpZiAodHlwZW9mIGZuLmxlbmd0aCA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICByZXR1cm4gTWF0aC5tYXgoTWF0aC5taW4oZm4ubGVuZ3RoLCAxMDIzICsgMSksIDApO1xuICAgIH1cbiAgICByZXR1cm4gMDtcbn07XG5cbm1ha2VOb2RlUHJvbWlzaWZpZWRFdmFsID1cbmZ1bmN0aW9uKGNhbGxiYWNrLCByZWNlaXZlciwgb3JpZ2luYWxOYW1lLCBmbiwgXywgbXVsdGlBcmdzKSB7XG4gICAgdmFyIG5ld1BhcmFtZXRlckNvdW50ID0gTWF0aC5tYXgoMCwgcGFyYW1ldGVyQ291bnQoZm4pIC0gMSk7XG4gICAgdmFyIGFyZ3VtZW50T3JkZXIgPSBzd2l0Y2hDYXNlQXJndW1lbnRPcmRlcihuZXdQYXJhbWV0ZXJDb3VudCk7XG4gICAgdmFyIHNob3VsZFByb3h5VGhpcyA9IHR5cGVvZiBjYWxsYmFjayA9PT0gXCJzdHJpbmdcIiB8fCByZWNlaXZlciA9PT0gVEhJUztcblxuICAgIGZ1bmN0aW9uIGdlbmVyYXRlQ2FsbEZvckFyZ3VtZW50Q291bnQoY291bnQpIHtcbiAgICAgICAgdmFyIGFyZ3MgPSBhcmd1bWVudFNlcXVlbmNlKGNvdW50KS5qb2luKFwiLCBcIik7XG4gICAgICAgIHZhciBjb21tYSA9IGNvdW50ID4gMCA/IFwiLCBcIiA6IFwiXCI7XG4gICAgICAgIHZhciByZXQ7XG4gICAgICAgIGlmIChzaG91bGRQcm94eVRoaXMpIHtcbiAgICAgICAgICAgIHJldCA9IFwicmV0ID0gY2FsbGJhY2suY2FsbCh0aGlzLCB7e2FyZ3N9fSwgbm9kZWJhY2spOyBicmVhaztcXG5cIjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldCA9IHJlY2VpdmVyID09PSB1bmRlZmluZWRcbiAgICAgICAgICAgICAgICA/IFwicmV0ID0gY2FsbGJhY2soe3thcmdzfX0sIG5vZGViYWNrKTsgYnJlYWs7XFxuXCJcbiAgICAgICAgICAgICAgICA6IFwicmV0ID0gY2FsbGJhY2suY2FsbChyZWNlaXZlciwge3thcmdzfX0sIG5vZGViYWNrKTsgYnJlYWs7XFxuXCI7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJldC5yZXBsYWNlKFwie3thcmdzfX1cIiwgYXJncykucmVwbGFjZShcIiwgXCIsIGNvbW1hKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZW5lcmF0ZUFyZ3VtZW50U3dpdGNoQ2FzZSgpIHtcbiAgICAgICAgdmFyIHJldCA9IFwiXCI7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJndW1lbnRPcmRlci5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgcmV0ICs9IFwiY2FzZSBcIiArIGFyZ3VtZW50T3JkZXJbaV0gK1wiOlwiICtcbiAgICAgICAgICAgICAgICBnZW5lcmF0ZUNhbGxGb3JBcmd1bWVudENvdW50KGFyZ3VtZW50T3JkZXJbaV0pO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0ICs9IFwiICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxcblxcXG4gICAgICAgIGRlZmF1bHQ6ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxcblxcXG4gICAgICAgICAgICB2YXIgYXJncyA9IG5ldyBBcnJheShsZW4gKyAxKTsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxcblxcXG4gICAgICAgICAgICB2YXIgaSA9IDA7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxcblxcXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgKytpKSB7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxcblxcXG4gICAgICAgICAgICAgICBhcmdzW2ldID0gYXJndW1lbnRzW2ldOyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxcblxcXG4gICAgICAgICAgICB9ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxcblxcXG4gICAgICAgICAgICBhcmdzW2ldID0gbm9kZWJhY2s7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxcblxcXG4gICAgICAgICAgICBbQ29kZUZvckNhbGxdICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxcblxcXG4gICAgICAgICAgICBicmVhazsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxcblxcXG4gICAgICAgIFwiLnJlcGxhY2UoXCJbQ29kZUZvckNhbGxdXCIsIChzaG91bGRQcm94eVRoaXNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPyBcInJldCA9IGNhbGxiYWNrLmFwcGx5KHRoaXMsIGFyZ3MpO1xcblwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogXCJyZXQgPSBjYWxsYmFjay5hcHBseShyZWNlaXZlciwgYXJncyk7XFxuXCIpKTtcbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICB9XG5cbiAgICB2YXIgZ2V0RnVuY3Rpb25Db2RlID0gdHlwZW9mIGNhbGxiYWNrID09PSBcInN0cmluZ1wiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gKFwidGhpcyAhPSBudWxsID8gdGhpc1snXCIrY2FsbGJhY2srXCInXSA6IGZuXCIpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogXCJmblwiO1xuICAgIHZhciBib2R5ID0gXCIndXNlIHN0cmljdCc7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXFxuXFxcbiAgICAgICAgdmFyIHJldCA9IGZ1bmN0aW9uIChQYXJhbWV0ZXJzKSB7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXFxuXFxcbiAgICAgICAgICAgICd1c2Ugc3RyaWN0JzsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXFxuXFxcbiAgICAgICAgICAgIHZhciBsZW4gPSBhcmd1bWVudHMubGVuZ3RoOyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXFxuXFxcbiAgICAgICAgICAgIHZhciBwcm9taXNlID0gbmV3IFByb21pc2UoSU5URVJOQUwpOyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXFxuXFxcbiAgICAgICAgICAgIHByb21pc2UuX2NhcHR1cmVTdGFja1RyYWNlKCk7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXFxuXFxcbiAgICAgICAgICAgIHZhciBub2RlYmFjayA9IG5vZGViYWNrRm9yUHJvbWlzZShwcm9taXNlLCBcIiArIG11bHRpQXJncyArIFwiKTsgICBcXG5cXFxuICAgICAgICAgICAgdmFyIHJldDsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcXG5cXFxuICAgICAgICAgICAgdmFyIGNhbGxiYWNrID0gdHJ5Q2F0Y2goW0dldEZ1bmN0aW9uQ29kZV0pOyAgICAgICAgICAgICAgICAgICAgICBcXG5cXFxuICAgICAgICAgICAgc3dpdGNoKGxlbikgeyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcXG5cXFxuICAgICAgICAgICAgICAgIFtDb2RlRm9yU3dpdGNoQ2FzZV0gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcXG5cXFxuICAgICAgICAgICAgfSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcXG5cXFxuICAgICAgICAgICAgaWYgKHJldCA9PT0gZXJyb3JPYmopIHsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcXG5cXFxuICAgICAgICAgICAgICAgIHByb21pc2UuX3JlamVjdENhbGxiYWNrKG1heWJlV3JhcEFzRXJyb3IocmV0LmUpLCB0cnVlLCB0cnVlKTtcXG5cXFxuICAgICAgICAgICAgfSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcXG5cXFxuICAgICAgICAgICAgaWYgKCFwcm9taXNlLl9pc0ZhdGVTZWFsZWQoKSkgcHJvbWlzZS5fc2V0QXN5bmNHdWFyYW50ZWVkKCk7ICAgICBcXG5cXFxuICAgICAgICAgICAgcmV0dXJuIHByb21pc2U7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcXG5cXFxuICAgICAgICB9OyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcXG5cXFxuICAgICAgICBub3RFbnVtZXJhYmxlUHJvcChyZXQsICdfX2lzUHJvbWlzaWZpZWRfXycsIHRydWUpOyAgICAgICAgICAgICAgICAgICBcXG5cXFxuICAgICAgICByZXR1cm4gcmV0OyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcXG5cXFxuICAgIFwiLnJlcGxhY2UoXCJbQ29kZUZvclN3aXRjaENhc2VdXCIsIGdlbmVyYXRlQXJndW1lbnRTd2l0Y2hDYXNlKCkpXG4gICAgICAgIC5yZXBsYWNlKFwiW0dldEZ1bmN0aW9uQ29kZV1cIiwgZ2V0RnVuY3Rpb25Db2RlKTtcbiAgICBib2R5ID0gYm9keS5yZXBsYWNlKFwiUGFyYW1ldGVyc1wiLCBwYXJhbWV0ZXJEZWNsYXJhdGlvbihuZXdQYXJhbWV0ZXJDb3VudCkpO1xuICAgIHJldHVybiBuZXcgRnVuY3Rpb24oXCJQcm9taXNlXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBcImZuXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBcInJlY2VpdmVyXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBcIndpdGhBcHBlbmRlZFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgXCJtYXliZVdyYXBBc0Vycm9yXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBcIm5vZGViYWNrRm9yUHJvbWlzZVwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgXCJ0cnlDYXRjaFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgXCJlcnJvck9ialwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgXCJub3RFbnVtZXJhYmxlUHJvcFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgXCJJTlRFUk5BTFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgYm9keSkoXG4gICAgICAgICAgICAgICAgICAgIFByb21pc2UsXG4gICAgICAgICAgICAgICAgICAgIGZuLFxuICAgICAgICAgICAgICAgICAgICByZWNlaXZlcixcbiAgICAgICAgICAgICAgICAgICAgd2l0aEFwcGVuZGVkLFxuICAgICAgICAgICAgICAgICAgICBtYXliZVdyYXBBc0Vycm9yLFxuICAgICAgICAgICAgICAgICAgICBub2RlYmFja0ZvclByb21pc2UsXG4gICAgICAgICAgICAgICAgICAgIHV0aWwudHJ5Q2F0Y2gsXG4gICAgICAgICAgICAgICAgICAgIHV0aWwuZXJyb3JPYmosXG4gICAgICAgICAgICAgICAgICAgIHV0aWwubm90RW51bWVyYWJsZVByb3AsXG4gICAgICAgICAgICAgICAgICAgIElOVEVSTkFMKTtcbn07XG59XG5cbmZ1bmN0aW9uIG1ha2VOb2RlUHJvbWlzaWZpZWRDbG9zdXJlKGNhbGxiYWNrLCByZWNlaXZlciwgXywgZm4sIF9fLCBtdWx0aUFyZ3MpIHtcbiAgICB2YXIgZGVmYXVsdFRoaXMgPSAoZnVuY3Rpb24oKSB7cmV0dXJuIHRoaXM7fSkoKTtcbiAgICB2YXIgbWV0aG9kID0gY2FsbGJhY2s7XG4gICAgaWYgKHR5cGVvZiBtZXRob2QgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgY2FsbGJhY2sgPSBmbjtcbiAgICB9XG4gICAgZnVuY3Rpb24gcHJvbWlzaWZpZWQoKSB7XG4gICAgICAgIHZhciBfcmVjZWl2ZXIgPSByZWNlaXZlcjtcbiAgICAgICAgaWYgKHJlY2VpdmVyID09PSBUSElTKSBfcmVjZWl2ZXIgPSB0aGlzO1xuICAgICAgICB2YXIgcHJvbWlzZSA9IG5ldyBQcm9taXNlKElOVEVSTkFMKTtcbiAgICAgICAgcHJvbWlzZS5fY2FwdHVyZVN0YWNrVHJhY2UoKTtcbiAgICAgICAgdmFyIGNiID0gdHlwZW9mIG1ldGhvZCA9PT0gXCJzdHJpbmdcIiAmJiB0aGlzICE9PSBkZWZhdWx0VGhpc1xuICAgICAgICAgICAgPyB0aGlzW21ldGhvZF0gOiBjYWxsYmFjaztcbiAgICAgICAgdmFyIGZuID0gbm9kZWJhY2tGb3JQcm9taXNlKHByb21pc2UsIG11bHRpQXJncyk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjYi5hcHBseShfcmVjZWl2ZXIsIHdpdGhBcHBlbmRlZChhcmd1bWVudHMsIGZuKSk7XG4gICAgICAgIH0gY2F0Y2goZSkge1xuICAgICAgICAgICAgcHJvbWlzZS5fcmVqZWN0Q2FsbGJhY2sobWF5YmVXcmFwQXNFcnJvcihlKSwgdHJ1ZSwgdHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFwcm9taXNlLl9pc0ZhdGVTZWFsZWQoKSkgcHJvbWlzZS5fc2V0QXN5bmNHdWFyYW50ZWVkKCk7XG4gICAgICAgIHJldHVybiBwcm9taXNlO1xuICAgIH1cbiAgICB1dGlsLm5vdEVudW1lcmFibGVQcm9wKHByb21pc2lmaWVkLCBcIl9faXNQcm9taXNpZmllZF9fXCIsIHRydWUpO1xuICAgIHJldHVybiBwcm9taXNpZmllZDtcbn1cblxudmFyIG1ha2VOb2RlUHJvbWlzaWZpZWQgPSBjYW5FdmFsdWF0ZVxuICAgID8gbWFrZU5vZGVQcm9taXNpZmllZEV2YWxcbiAgICA6IG1ha2VOb2RlUHJvbWlzaWZpZWRDbG9zdXJlO1xuXG5mdW5jdGlvbiBwcm9taXNpZnlBbGwob2JqLCBzdWZmaXgsIGZpbHRlciwgcHJvbWlzaWZpZXIsIG11bHRpQXJncykge1xuICAgIHZhciBzdWZmaXhSZWdleHAgPSBuZXcgUmVnRXhwKGVzY2FwZUlkZW50UmVnZXgoc3VmZml4KSArIFwiJFwiKTtcbiAgICB2YXIgbWV0aG9kcyA9XG4gICAgICAgIHByb21pc2lmaWFibGVNZXRob2RzKG9iaiwgc3VmZml4LCBzdWZmaXhSZWdleHAsIGZpbHRlcik7XG5cbiAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gbWV0aG9kcy5sZW5ndGg7IGkgPCBsZW47IGkrPSAyKSB7XG4gICAgICAgIHZhciBrZXkgPSBtZXRob2RzW2ldO1xuICAgICAgICB2YXIgZm4gPSBtZXRob2RzW2krMV07XG4gICAgICAgIHZhciBwcm9taXNpZmllZEtleSA9IGtleSArIHN1ZmZpeDtcbiAgICAgICAgaWYgKHByb21pc2lmaWVyID09PSBtYWtlTm9kZVByb21pc2lmaWVkKSB7XG4gICAgICAgICAgICBvYmpbcHJvbWlzaWZpZWRLZXldID1cbiAgICAgICAgICAgICAgICBtYWtlTm9kZVByb21pc2lmaWVkKGtleSwgVEhJUywga2V5LCBmbiwgc3VmZml4LCBtdWx0aUFyZ3MpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFyIHByb21pc2lmaWVkID0gcHJvbWlzaWZpZXIoZm4sIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBtYWtlTm9kZVByb21pc2lmaWVkKGtleSwgVEhJUywga2V5LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZuLCBzdWZmaXgsIG11bHRpQXJncyk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHV0aWwubm90RW51bWVyYWJsZVByb3AocHJvbWlzaWZpZWQsIFwiX19pc1Byb21pc2lmaWVkX19cIiwgdHJ1ZSk7XG4gICAgICAgICAgICBvYmpbcHJvbWlzaWZpZWRLZXldID0gcHJvbWlzaWZpZWQ7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdXRpbC50b0Zhc3RQcm9wZXJ0aWVzKG9iaik7XG4gICAgcmV0dXJuIG9iajtcbn1cblxuZnVuY3Rpb24gcHJvbWlzaWZ5KGNhbGxiYWNrLCByZWNlaXZlciwgbXVsdGlBcmdzKSB7XG4gICAgcmV0dXJuIG1ha2VOb2RlUHJvbWlzaWZpZWQoY2FsbGJhY2ssIHJlY2VpdmVyLCB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrLCBudWxsLCBtdWx0aUFyZ3MpO1xufVxuXG5Qcm9taXNlLnByb21pc2lmeSA9IGZ1bmN0aW9uIChmbiwgb3B0aW9ucykge1xuICAgIGlmICh0eXBlb2YgZm4gIT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiZXhwZWN0aW5nIGEgZnVuY3Rpb24gYnV0IGdvdCBcIiArIHV0aWwuY2xhc3NTdHJpbmcoZm4pKTtcbiAgICB9XG4gICAgaWYgKGlzUHJvbWlzaWZpZWQoZm4pKSB7XG4gICAgICAgIHJldHVybiBmbjtcbiAgICB9XG4gICAgb3B0aW9ucyA9IE9iamVjdChvcHRpb25zKTtcbiAgICB2YXIgcmVjZWl2ZXIgPSBvcHRpb25zLmNvbnRleHQgPT09IHVuZGVmaW5lZCA/IFRISVMgOiBvcHRpb25zLmNvbnRleHQ7XG4gICAgdmFyIG11bHRpQXJncyA9ICEhb3B0aW9ucy5tdWx0aUFyZ3M7XG4gICAgdmFyIHJldCA9IHByb21pc2lmeShmbiwgcmVjZWl2ZXIsIG11bHRpQXJncyk7XG4gICAgdXRpbC5jb3B5RGVzY3JpcHRvcnMoZm4sIHJldCwgcHJvcHNGaWx0ZXIpO1xuICAgIHJldHVybiByZXQ7XG59O1xuXG5Qcm9taXNlLnByb21pc2lmeUFsbCA9IGZ1bmN0aW9uICh0YXJnZXQsIG9wdGlvbnMpIHtcbiAgICBpZiAodHlwZW9mIHRhcmdldCAhPT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiB0YXJnZXQgIT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcInRoZSB0YXJnZXQgb2YgcHJvbWlzaWZ5QWxsIG11c3QgYmUgYW4gb2JqZWN0IG9yIGEgZnVuY3Rpb25cXHUwMDBhXFx1MDAwYSAgICBTZWUgaHR0cDovL2dvby5nbC9NcXJGbVhcXHUwMDBhXCIpO1xuICAgIH1cbiAgICBvcHRpb25zID0gT2JqZWN0KG9wdGlvbnMpO1xuICAgIHZhciBtdWx0aUFyZ3MgPSAhIW9wdGlvbnMubXVsdGlBcmdzO1xuICAgIHZhciBzdWZmaXggPSBvcHRpb25zLnN1ZmZpeDtcbiAgICBpZiAodHlwZW9mIHN1ZmZpeCAhPT0gXCJzdHJpbmdcIikgc3VmZml4ID0gZGVmYXVsdFN1ZmZpeDtcbiAgICB2YXIgZmlsdGVyID0gb3B0aW9ucy5maWx0ZXI7XG4gICAgaWYgKHR5cGVvZiBmaWx0ZXIgIT09IFwiZnVuY3Rpb25cIikgZmlsdGVyID0gZGVmYXVsdEZpbHRlcjtcbiAgICB2YXIgcHJvbWlzaWZpZXIgPSBvcHRpb25zLnByb21pc2lmaWVyO1xuICAgIGlmICh0eXBlb2YgcHJvbWlzaWZpZXIgIT09IFwiZnVuY3Rpb25cIikgcHJvbWlzaWZpZXIgPSBtYWtlTm9kZVByb21pc2lmaWVkO1xuXG4gICAgaWYgKCF1dGlsLmlzSWRlbnRpZmllcihzdWZmaXgpKSB7XG4gICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwic3VmZml4IG11c3QgYmUgYSB2YWxpZCBpZGVudGlmaWVyXFx1MDAwYVxcdTAwMGEgICAgU2VlIGh0dHA6Ly9nb28uZ2wvTXFyRm1YXFx1MDAwYVwiKTtcbiAgICB9XG5cbiAgICB2YXIga2V5cyA9IHV0aWwuaW5oZXJpdGVkRGF0YUtleXModGFyZ2V0KTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgdmFyIHZhbHVlID0gdGFyZ2V0W2tleXNbaV1dO1xuICAgICAgICBpZiAoa2V5c1tpXSAhPT0gXCJjb25zdHJ1Y3RvclwiICYmXG4gICAgICAgICAgICB1dGlsLmlzQ2xhc3ModmFsdWUpKSB7XG4gICAgICAgICAgICBwcm9taXNpZnlBbGwodmFsdWUucHJvdG90eXBlLCBzdWZmaXgsIGZpbHRlciwgcHJvbWlzaWZpZXIsXG4gICAgICAgICAgICAgICAgbXVsdGlBcmdzKTtcbiAgICAgICAgICAgIHByb21pc2lmeUFsbCh2YWx1ZSwgc3VmZml4LCBmaWx0ZXIsIHByb21pc2lmaWVyLCBtdWx0aUFyZ3MpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHByb21pc2lmeUFsbCh0YXJnZXQsIHN1ZmZpeCwgZmlsdGVyLCBwcm9taXNpZmllciwgbXVsdGlBcmdzKTtcbn07XG59O1xuXG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvYmx1ZWJpcmQvanMvcmVsZWFzZS9wcm9taXNpZnkuanMiLCJcInVzZSBzdHJpY3RcIjtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oXG4gICAgUHJvbWlzZSwgUHJvbWlzZUFycmF5LCB0cnlDb252ZXJ0VG9Qcm9taXNlLCBhcGlSZWplY3Rpb24pIHtcbnZhciB1dGlsID0gcmVxdWlyZShcIi4vdXRpbFwiKTtcbnZhciBpc09iamVjdCA9IHV0aWwuaXNPYmplY3Q7XG52YXIgZXM1ID0gcmVxdWlyZShcIi4vZXM1XCIpO1xudmFyIEVzNk1hcDtcbmlmICh0eXBlb2YgTWFwID09PSBcImZ1bmN0aW9uXCIpIEVzNk1hcCA9IE1hcDtcblxudmFyIG1hcFRvRW50cmllcyA9IChmdW5jdGlvbigpIHtcbiAgICB2YXIgaW5kZXggPSAwO1xuICAgIHZhciBzaXplID0gMDtcblxuICAgIGZ1bmN0aW9uIGV4dHJhY3RFbnRyeSh2YWx1ZSwga2V5KSB7XG4gICAgICAgIHRoaXNbaW5kZXhdID0gdmFsdWU7XG4gICAgICAgIHRoaXNbaW5kZXggKyBzaXplXSA9IGtleTtcbiAgICAgICAgaW5kZXgrKztcbiAgICB9XG5cbiAgICByZXR1cm4gZnVuY3Rpb24gbWFwVG9FbnRyaWVzKG1hcCkge1xuICAgICAgICBzaXplID0gbWFwLnNpemU7XG4gICAgICAgIGluZGV4ID0gMDtcbiAgICAgICAgdmFyIHJldCA9IG5ldyBBcnJheShtYXAuc2l6ZSAqIDIpO1xuICAgICAgICBtYXAuZm9yRWFjaChleHRyYWN0RW50cnksIHJldCk7XG4gICAgICAgIHJldHVybiByZXQ7XG4gICAgfTtcbn0pKCk7XG5cbnZhciBlbnRyaWVzVG9NYXAgPSBmdW5jdGlvbihlbnRyaWVzKSB7XG4gICAgdmFyIHJldCA9IG5ldyBFczZNYXAoKTtcbiAgICB2YXIgbGVuZ3RoID0gZW50cmllcy5sZW5ndGggLyAyIHwgMDtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgKytpKSB7XG4gICAgICAgIHZhciBrZXkgPSBlbnRyaWVzW2xlbmd0aCArIGldO1xuICAgICAgICB2YXIgdmFsdWUgPSBlbnRyaWVzW2ldO1xuICAgICAgICByZXQuc2V0KGtleSwgdmFsdWUpO1xuICAgIH1cbiAgICByZXR1cm4gcmV0O1xufTtcblxuZnVuY3Rpb24gUHJvcGVydGllc1Byb21pc2VBcnJheShvYmopIHtcbiAgICB2YXIgaXNNYXAgPSBmYWxzZTtcbiAgICB2YXIgZW50cmllcztcbiAgICBpZiAoRXM2TWFwICE9PSB1bmRlZmluZWQgJiYgb2JqIGluc3RhbmNlb2YgRXM2TWFwKSB7XG4gICAgICAgIGVudHJpZXMgPSBtYXBUb0VudHJpZXMob2JqKTtcbiAgICAgICAgaXNNYXAgPSB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBrZXlzID0gZXM1LmtleXMob2JqKTtcbiAgICAgICAgdmFyIGxlbiA9IGtleXMubGVuZ3RoO1xuICAgICAgICBlbnRyaWVzID0gbmV3IEFycmF5KGxlbiAqIDIpO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgKytpKSB7XG4gICAgICAgICAgICB2YXIga2V5ID0ga2V5c1tpXTtcbiAgICAgICAgICAgIGVudHJpZXNbaV0gPSBvYmpba2V5XTtcbiAgICAgICAgICAgIGVudHJpZXNbaSArIGxlbl0gPSBrZXk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5jb25zdHJ1Y3RvciQoZW50cmllcyk7XG4gICAgdGhpcy5faXNNYXAgPSBpc01hcDtcbiAgICB0aGlzLl9pbml0JCh1bmRlZmluZWQsIGlzTWFwID8gLTYgOiAtMyk7XG59XG51dGlsLmluaGVyaXRzKFByb3BlcnRpZXNQcm9taXNlQXJyYXksIFByb21pc2VBcnJheSk7XG5cblByb3BlcnRpZXNQcm9taXNlQXJyYXkucHJvdG90eXBlLl9pbml0ID0gZnVuY3Rpb24gKCkge307XG5cblByb3BlcnRpZXNQcm9taXNlQXJyYXkucHJvdG90eXBlLl9wcm9taXNlRnVsZmlsbGVkID0gZnVuY3Rpb24gKHZhbHVlLCBpbmRleCkge1xuICAgIHRoaXMuX3ZhbHVlc1tpbmRleF0gPSB2YWx1ZTtcbiAgICB2YXIgdG90YWxSZXNvbHZlZCA9ICsrdGhpcy5fdG90YWxSZXNvbHZlZDtcbiAgICBpZiAodG90YWxSZXNvbHZlZCA+PSB0aGlzLl9sZW5ndGgpIHtcbiAgICAgICAgdmFyIHZhbDtcbiAgICAgICAgaWYgKHRoaXMuX2lzTWFwKSB7XG4gICAgICAgICAgICB2YWwgPSBlbnRyaWVzVG9NYXAodGhpcy5fdmFsdWVzKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhbCA9IHt9O1xuICAgICAgICAgICAgdmFyIGtleU9mZnNldCA9IHRoaXMubGVuZ3RoKCk7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gdGhpcy5sZW5ndGgoKTsgaSA8IGxlbjsgKytpKSB7XG4gICAgICAgICAgICAgICAgdmFsW3RoaXMuX3ZhbHVlc1tpICsga2V5T2Zmc2V0XV0gPSB0aGlzLl92YWx1ZXNbaV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fcmVzb2x2ZSh2YWwpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufTtcblxuUHJvcGVydGllc1Byb21pc2VBcnJheS5wcm90b3R5cGUuc2hvdWxkQ29weVZhbHVlcyA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gZmFsc2U7XG59O1xuXG5Qcm9wZXJ0aWVzUHJvbWlzZUFycmF5LnByb3RvdHlwZS5nZXRBY3R1YWxMZW5ndGggPSBmdW5jdGlvbiAobGVuKSB7XG4gICAgcmV0dXJuIGxlbiA+PiAxO1xufTtcblxuZnVuY3Rpb24gcHJvcHMocHJvbWlzZXMpIHtcbiAgICB2YXIgcmV0O1xuICAgIHZhciBjYXN0VmFsdWUgPSB0cnlDb252ZXJ0VG9Qcm9taXNlKHByb21pc2VzKTtcblxuICAgIGlmICghaXNPYmplY3QoY2FzdFZhbHVlKSkge1xuICAgICAgICByZXR1cm4gYXBpUmVqZWN0aW9uKFwiY2Fubm90IGF3YWl0IHByb3BlcnRpZXMgb2YgYSBub24tb2JqZWN0XFx1MDAwYVxcdTAwMGEgICAgU2VlIGh0dHA6Ly9nb28uZ2wvTXFyRm1YXFx1MDAwYVwiKTtcbiAgICB9IGVsc2UgaWYgKGNhc3RWYWx1ZSBpbnN0YW5jZW9mIFByb21pc2UpIHtcbiAgICAgICAgcmV0ID0gY2FzdFZhbHVlLl90aGVuKFxuICAgICAgICAgICAgUHJvbWlzZS5wcm9wcywgdW5kZWZpbmVkLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgdW5kZWZpbmVkKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXQgPSBuZXcgUHJvcGVydGllc1Byb21pc2VBcnJheShjYXN0VmFsdWUpLnByb21pc2UoKTtcbiAgICB9XG5cbiAgICBpZiAoY2FzdFZhbHVlIGluc3RhbmNlb2YgUHJvbWlzZSkge1xuICAgICAgICByZXQuX3Byb3BhZ2F0ZUZyb20oY2FzdFZhbHVlLCAyKTtcbiAgICB9XG4gICAgcmV0dXJuIHJldDtcbn1cblxuUHJvbWlzZS5wcm90b3R5cGUucHJvcHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHByb3BzKHRoaXMpO1xufTtcblxuUHJvbWlzZS5wcm9wcyA9IGZ1bmN0aW9uIChwcm9taXNlcykge1xuICAgIHJldHVybiBwcm9wcyhwcm9taXNlcyk7XG59O1xufTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9ibHVlYmlyZC9qcy9yZWxlYXNlL3Byb3BzLmpzIiwiXCJ1c2Ugc3RyaWN0XCI7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKFxuICAgIFByb21pc2UsIElOVEVSTkFMLCB0cnlDb252ZXJ0VG9Qcm9taXNlLCBhcGlSZWplY3Rpb24pIHtcbnZhciB1dGlsID0gcmVxdWlyZShcIi4vdXRpbFwiKTtcblxudmFyIHJhY2VMYXRlciA9IGZ1bmN0aW9uIChwcm9taXNlKSB7XG4gICAgcmV0dXJuIHByb21pc2UudGhlbihmdW5jdGlvbihhcnJheSkge1xuICAgICAgICByZXR1cm4gcmFjZShhcnJheSwgcHJvbWlzZSk7XG4gICAgfSk7XG59O1xuXG5mdW5jdGlvbiByYWNlKHByb21pc2VzLCBwYXJlbnQpIHtcbiAgICB2YXIgbWF5YmVQcm9taXNlID0gdHJ5Q29udmVydFRvUHJvbWlzZShwcm9taXNlcyk7XG5cbiAgICBpZiAobWF5YmVQcm9taXNlIGluc3RhbmNlb2YgUHJvbWlzZSkge1xuICAgICAgICByZXR1cm4gcmFjZUxhdGVyKG1heWJlUHJvbWlzZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcHJvbWlzZXMgPSB1dGlsLmFzQXJyYXkocHJvbWlzZXMpO1xuICAgICAgICBpZiAocHJvbWlzZXMgPT09IG51bGwpXG4gICAgICAgICAgICByZXR1cm4gYXBpUmVqZWN0aW9uKFwiZXhwZWN0aW5nIGFuIGFycmF5IG9yIGFuIGl0ZXJhYmxlIG9iamVjdCBidXQgZ290IFwiICsgdXRpbC5jbGFzc1N0cmluZyhwcm9taXNlcykpO1xuICAgIH1cblxuICAgIHZhciByZXQgPSBuZXcgUHJvbWlzZShJTlRFUk5BTCk7XG4gICAgaWYgKHBhcmVudCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldC5fcHJvcGFnYXRlRnJvbShwYXJlbnQsIDMpO1xuICAgIH1cbiAgICB2YXIgZnVsZmlsbCA9IHJldC5fZnVsZmlsbDtcbiAgICB2YXIgcmVqZWN0ID0gcmV0Ll9yZWplY3Q7XG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHByb21pc2VzLmxlbmd0aDsgaSA8IGxlbjsgKytpKSB7XG4gICAgICAgIHZhciB2YWwgPSBwcm9taXNlc1tpXTtcblxuICAgICAgICBpZiAodmFsID09PSB1bmRlZmluZWQgJiYgIShpIGluIHByb21pc2VzKSkge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICBQcm9taXNlLmNhc3QodmFsKS5fdGhlbihmdWxmaWxsLCByZWplY3QsIHVuZGVmaW5lZCwgcmV0LCBudWxsKTtcbiAgICB9XG4gICAgcmV0dXJuIHJldDtcbn1cblxuUHJvbWlzZS5yYWNlID0gZnVuY3Rpb24gKHByb21pc2VzKSB7XG4gICAgcmV0dXJuIHJhY2UocHJvbWlzZXMsIHVuZGVmaW5lZCk7XG59O1xuXG5Qcm9taXNlLnByb3RvdHlwZS5yYWNlID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiByYWNlKHRoaXMsIHVuZGVmaW5lZCk7XG59O1xuXG59O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2JsdWViaXJkL2pzL3JlbGVhc2UvcmFjZS5qcyIsIlwidXNlIHN0cmljdFwiO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihQcm9taXNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICBQcm9taXNlQXJyYXksXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGFwaVJlamVjdGlvbixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgdHJ5Q29udmVydFRvUHJvbWlzZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgSU5URVJOQUwsXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGRlYnVnKSB7XG52YXIgZ2V0RG9tYWluID0gUHJvbWlzZS5fZ2V0RG9tYWluO1xudmFyIHV0aWwgPSByZXF1aXJlKFwiLi91dGlsXCIpO1xudmFyIHRyeUNhdGNoID0gdXRpbC50cnlDYXRjaDtcblxuZnVuY3Rpb24gUmVkdWN0aW9uUHJvbWlzZUFycmF5KHByb21pc2VzLCBmbiwgaW5pdGlhbFZhbHVlLCBfZWFjaCkge1xuICAgIHRoaXMuY29uc3RydWN0b3IkKHByb21pc2VzKTtcbiAgICB2YXIgZG9tYWluID0gZ2V0RG9tYWluKCk7XG4gICAgdGhpcy5fZm4gPSBkb21haW4gPT09IG51bGwgPyBmbiA6IHV0aWwuZG9tYWluQmluZChkb21haW4sIGZuKTtcbiAgICBpZiAoaW5pdGlhbFZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgaW5pdGlhbFZhbHVlID0gUHJvbWlzZS5yZXNvbHZlKGluaXRpYWxWYWx1ZSk7XG4gICAgICAgIGluaXRpYWxWYWx1ZS5fYXR0YWNoQ2FuY2VsbGF0aW9uQ2FsbGJhY2sodGhpcyk7XG4gICAgfVxuICAgIHRoaXMuX2luaXRpYWxWYWx1ZSA9IGluaXRpYWxWYWx1ZTtcbiAgICB0aGlzLl9jdXJyZW50Q2FuY2VsbGFibGUgPSBudWxsO1xuICAgIGlmKF9lYWNoID09PSBJTlRFUk5BTCkge1xuICAgICAgICB0aGlzLl9lYWNoVmFsdWVzID0gQXJyYXkodGhpcy5fbGVuZ3RoKTtcbiAgICB9IGVsc2UgaWYgKF9lYWNoID09PSAwKSB7XG4gICAgICAgIHRoaXMuX2VhY2hWYWx1ZXMgPSBudWxsO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuX2VhY2hWYWx1ZXMgPSB1bmRlZmluZWQ7XG4gICAgfVxuICAgIHRoaXMuX3Byb21pc2UuX2NhcHR1cmVTdGFja1RyYWNlKCk7XG4gICAgdGhpcy5faW5pdCQodW5kZWZpbmVkLCAtNSk7XG59XG51dGlsLmluaGVyaXRzKFJlZHVjdGlvblByb21pc2VBcnJheSwgUHJvbWlzZUFycmF5KTtcblxuUmVkdWN0aW9uUHJvbWlzZUFycmF5LnByb3RvdHlwZS5fZ290QWNjdW0gPSBmdW5jdGlvbihhY2N1bSkge1xuICAgIGlmICh0aGlzLl9lYWNoVmFsdWVzICE9PSB1bmRlZmluZWQgJiYgXG4gICAgICAgIHRoaXMuX2VhY2hWYWx1ZXMgIT09IG51bGwgJiYgXG4gICAgICAgIGFjY3VtICE9PSBJTlRFUk5BTCkge1xuICAgICAgICB0aGlzLl9lYWNoVmFsdWVzLnB1c2goYWNjdW0pO1xuICAgIH1cbn07XG5cblJlZHVjdGlvblByb21pc2VBcnJheS5wcm90b3R5cGUuX2VhY2hDb21wbGV0ZSA9IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgaWYgKHRoaXMuX2VhY2hWYWx1ZXMgIT09IG51bGwpIHtcbiAgICAgICAgdGhpcy5fZWFjaFZhbHVlcy5wdXNoKHZhbHVlKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX2VhY2hWYWx1ZXM7XG59O1xuXG5SZWR1Y3Rpb25Qcm9taXNlQXJyYXkucHJvdG90eXBlLl9pbml0ID0gZnVuY3Rpb24oKSB7fTtcblxuUmVkdWN0aW9uUHJvbWlzZUFycmF5LnByb3RvdHlwZS5fcmVzb2x2ZUVtcHR5QXJyYXkgPSBmdW5jdGlvbigpIHtcbiAgICB0aGlzLl9yZXNvbHZlKHRoaXMuX2VhY2hWYWx1ZXMgIT09IHVuZGVmaW5lZCA/IHRoaXMuX2VhY2hWYWx1ZXNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IHRoaXMuX2luaXRpYWxWYWx1ZSk7XG59O1xuXG5SZWR1Y3Rpb25Qcm9taXNlQXJyYXkucHJvdG90eXBlLnNob3VsZENvcHlWYWx1ZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xufTtcblxuUmVkdWN0aW9uUHJvbWlzZUFycmF5LnByb3RvdHlwZS5fcmVzb2x2ZSA9IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgdGhpcy5fcHJvbWlzZS5fcmVzb2x2ZUNhbGxiYWNrKHZhbHVlKTtcbiAgICB0aGlzLl92YWx1ZXMgPSBudWxsO1xufTtcblxuUmVkdWN0aW9uUHJvbWlzZUFycmF5LnByb3RvdHlwZS5fcmVzdWx0Q2FuY2VsbGVkID0gZnVuY3Rpb24oc2VuZGVyKSB7XG4gICAgaWYgKHNlbmRlciA9PT0gdGhpcy5faW5pdGlhbFZhbHVlKSByZXR1cm4gdGhpcy5fY2FuY2VsKCk7XG4gICAgaWYgKHRoaXMuX2lzUmVzb2x2ZWQoKSkgcmV0dXJuO1xuICAgIHRoaXMuX3Jlc3VsdENhbmNlbGxlZCQoKTtcbiAgICBpZiAodGhpcy5fY3VycmVudENhbmNlbGxhYmxlIGluc3RhbmNlb2YgUHJvbWlzZSkge1xuICAgICAgICB0aGlzLl9jdXJyZW50Q2FuY2VsbGFibGUuY2FuY2VsKCk7XG4gICAgfVxuICAgIGlmICh0aGlzLl9pbml0aWFsVmFsdWUgaW5zdGFuY2VvZiBQcm9taXNlKSB7XG4gICAgICAgIHRoaXMuX2luaXRpYWxWYWx1ZS5jYW5jZWwoKTtcbiAgICB9XG59O1xuXG5SZWR1Y3Rpb25Qcm9taXNlQXJyYXkucHJvdG90eXBlLl9pdGVyYXRlID0gZnVuY3Rpb24gKHZhbHVlcykge1xuICAgIHRoaXMuX3ZhbHVlcyA9IHZhbHVlcztcbiAgICB2YXIgdmFsdWU7XG4gICAgdmFyIGk7XG4gICAgdmFyIGxlbmd0aCA9IHZhbHVlcy5sZW5ndGg7XG4gICAgaWYgKHRoaXMuX2luaXRpYWxWYWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHZhbHVlID0gdGhpcy5faW5pdGlhbFZhbHVlO1xuICAgICAgICBpID0gMDtcbiAgICB9IGVsc2Uge1xuICAgICAgICB2YWx1ZSA9IFByb21pc2UucmVzb2x2ZSh2YWx1ZXNbMF0pO1xuICAgICAgICBpID0gMTtcbiAgICB9XG5cbiAgICB0aGlzLl9jdXJyZW50Q2FuY2VsbGFibGUgPSB2YWx1ZTtcblxuICAgIGlmICghdmFsdWUuaXNSZWplY3RlZCgpKSB7XG4gICAgICAgIGZvciAoOyBpIDwgbGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIHZhciBjdHggPSB7XG4gICAgICAgICAgICAgICAgYWNjdW06IG51bGwsXG4gICAgICAgICAgICAgICAgdmFsdWU6IHZhbHVlc1tpXSxcbiAgICAgICAgICAgICAgICBpbmRleDogaSxcbiAgICAgICAgICAgICAgICBsZW5ndGg6IGxlbmd0aCxcbiAgICAgICAgICAgICAgICBhcnJheTogdGhpc1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHZhbHVlID0gdmFsdWUuX3RoZW4oZ290QWNjdW0sIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBjdHgsIHVuZGVmaW5lZCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAodGhpcy5fZWFjaFZhbHVlcyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHZhbHVlID0gdmFsdWVcbiAgICAgICAgICAgIC5fdGhlbih0aGlzLl9lYWNoQ29tcGxldGUsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCB0aGlzLCB1bmRlZmluZWQpO1xuICAgIH1cbiAgICB2YWx1ZS5fdGhlbihjb21wbGV0ZWQsIGNvbXBsZXRlZCwgdW5kZWZpbmVkLCB2YWx1ZSwgdGhpcyk7XG59O1xuXG5Qcm9taXNlLnByb3RvdHlwZS5yZWR1Y2UgPSBmdW5jdGlvbiAoZm4sIGluaXRpYWxWYWx1ZSkge1xuICAgIHJldHVybiByZWR1Y2UodGhpcywgZm4sIGluaXRpYWxWYWx1ZSwgbnVsbCk7XG59O1xuXG5Qcm9taXNlLnJlZHVjZSA9IGZ1bmN0aW9uIChwcm9taXNlcywgZm4sIGluaXRpYWxWYWx1ZSwgX2VhY2gpIHtcbiAgICByZXR1cm4gcmVkdWNlKHByb21pc2VzLCBmbiwgaW5pdGlhbFZhbHVlLCBfZWFjaCk7XG59O1xuXG5mdW5jdGlvbiBjb21wbGV0ZWQodmFsdWVPclJlYXNvbiwgYXJyYXkpIHtcbiAgICBpZiAodGhpcy5pc0Z1bGZpbGxlZCgpKSB7XG4gICAgICAgIGFycmF5Ll9yZXNvbHZlKHZhbHVlT3JSZWFzb24pO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGFycmF5Ll9yZWplY3QodmFsdWVPclJlYXNvbik7XG4gICAgfVxufVxuXG5mdW5jdGlvbiByZWR1Y2UocHJvbWlzZXMsIGZuLCBpbml0aWFsVmFsdWUsIF9lYWNoKSB7XG4gICAgaWYgKHR5cGVvZiBmbiAhPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIHJldHVybiBhcGlSZWplY3Rpb24oXCJleHBlY3RpbmcgYSBmdW5jdGlvbiBidXQgZ290IFwiICsgdXRpbC5jbGFzc1N0cmluZyhmbikpO1xuICAgIH1cbiAgICB2YXIgYXJyYXkgPSBuZXcgUmVkdWN0aW9uUHJvbWlzZUFycmF5KHByb21pc2VzLCBmbiwgaW5pdGlhbFZhbHVlLCBfZWFjaCk7XG4gICAgcmV0dXJuIGFycmF5LnByb21pc2UoKTtcbn1cblxuZnVuY3Rpb24gZ290QWNjdW0oYWNjdW0pIHtcbiAgICB0aGlzLmFjY3VtID0gYWNjdW07XG4gICAgdGhpcy5hcnJheS5fZ290QWNjdW0oYWNjdW0pO1xuICAgIHZhciB2YWx1ZSA9IHRyeUNvbnZlcnRUb1Byb21pc2UodGhpcy52YWx1ZSwgdGhpcy5hcnJheS5fcHJvbWlzZSk7XG4gICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgUHJvbWlzZSkge1xuICAgICAgICB0aGlzLmFycmF5Ll9jdXJyZW50Q2FuY2VsbGFibGUgPSB2YWx1ZTtcbiAgICAgICAgcmV0dXJuIHZhbHVlLl90aGVuKGdvdFZhbHVlLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgdGhpcywgdW5kZWZpbmVkKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gZ290VmFsdWUuY2FsbCh0aGlzLCB2YWx1ZSk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBnb3RWYWx1ZSh2YWx1ZSkge1xuICAgIHZhciBhcnJheSA9IHRoaXMuYXJyYXk7XG4gICAgdmFyIHByb21pc2UgPSBhcnJheS5fcHJvbWlzZTtcbiAgICB2YXIgZm4gPSB0cnlDYXRjaChhcnJheS5fZm4pO1xuICAgIHByb21pc2UuX3B1c2hDb250ZXh0KCk7XG4gICAgdmFyIHJldDtcbiAgICBpZiAoYXJyYXkuX2VhY2hWYWx1ZXMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXQgPSBmbi5jYWxsKHByb21pc2UuX2JvdW5kVmFsdWUoKSwgdmFsdWUsIHRoaXMuaW5kZXgsIHRoaXMubGVuZ3RoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXQgPSBmbi5jYWxsKHByb21pc2UuX2JvdW5kVmFsdWUoKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuYWNjdW0sIHZhbHVlLCB0aGlzLmluZGV4LCB0aGlzLmxlbmd0aCk7XG4gICAgfVxuICAgIGlmIChyZXQgaW5zdGFuY2VvZiBQcm9taXNlKSB7XG4gICAgICAgIGFycmF5Ll9jdXJyZW50Q2FuY2VsbGFibGUgPSByZXQ7XG4gICAgfVxuICAgIHZhciBwcm9taXNlQ3JlYXRlZCA9IHByb21pc2UuX3BvcENvbnRleHQoKTtcbiAgICBkZWJ1Zy5jaGVja0ZvcmdvdHRlblJldHVybnMoXG4gICAgICAgIHJldCxcbiAgICAgICAgcHJvbWlzZUNyZWF0ZWQsXG4gICAgICAgIGFycmF5Ll9lYWNoVmFsdWVzICE9PSB1bmRlZmluZWQgPyBcIlByb21pc2UuZWFjaFwiIDogXCJQcm9taXNlLnJlZHVjZVwiLFxuICAgICAgICBwcm9taXNlXG4gICAgKTtcbiAgICByZXR1cm4gcmV0O1xufVxufTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9ibHVlYmlyZC9qcy9yZWxlYXNlL3JlZHVjZS5qcyIsIlwidXNlIHN0cmljdFwiO1xubW9kdWxlLmV4cG9ydHMgPVxuICAgIGZ1bmN0aW9uKFByb21pc2UsIFByb21pc2VBcnJheSwgZGVidWcpIHtcbnZhciBQcm9taXNlSW5zcGVjdGlvbiA9IFByb21pc2UuUHJvbWlzZUluc3BlY3Rpb247XG52YXIgdXRpbCA9IHJlcXVpcmUoXCIuL3V0aWxcIik7XG5cbmZ1bmN0aW9uIFNldHRsZWRQcm9taXNlQXJyYXkodmFsdWVzKSB7XG4gICAgdGhpcy5jb25zdHJ1Y3RvciQodmFsdWVzKTtcbn1cbnV0aWwuaW5oZXJpdHMoU2V0dGxlZFByb21pc2VBcnJheSwgUHJvbWlzZUFycmF5KTtcblxuU2V0dGxlZFByb21pc2VBcnJheS5wcm90b3R5cGUuX3Byb21pc2VSZXNvbHZlZCA9IGZ1bmN0aW9uIChpbmRleCwgaW5zcGVjdGlvbikge1xuICAgIHRoaXMuX3ZhbHVlc1tpbmRleF0gPSBpbnNwZWN0aW9uO1xuICAgIHZhciB0b3RhbFJlc29sdmVkID0gKyt0aGlzLl90b3RhbFJlc29sdmVkO1xuICAgIGlmICh0b3RhbFJlc29sdmVkID49IHRoaXMuX2xlbmd0aCkge1xuICAgICAgICB0aGlzLl9yZXNvbHZlKHRoaXMuX3ZhbHVlcyk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59O1xuXG5TZXR0bGVkUHJvbWlzZUFycmF5LnByb3RvdHlwZS5fcHJvbWlzZUZ1bGZpbGxlZCA9IGZ1bmN0aW9uICh2YWx1ZSwgaW5kZXgpIHtcbiAgICB2YXIgcmV0ID0gbmV3IFByb21pc2VJbnNwZWN0aW9uKCk7XG4gICAgcmV0Ll9iaXRGaWVsZCA9IDMzNTU0NDMyO1xuICAgIHJldC5fc2V0dGxlZFZhbHVlRmllbGQgPSB2YWx1ZTtcbiAgICByZXR1cm4gdGhpcy5fcHJvbWlzZVJlc29sdmVkKGluZGV4LCByZXQpO1xufTtcblNldHRsZWRQcm9taXNlQXJyYXkucHJvdG90eXBlLl9wcm9taXNlUmVqZWN0ZWQgPSBmdW5jdGlvbiAocmVhc29uLCBpbmRleCkge1xuICAgIHZhciByZXQgPSBuZXcgUHJvbWlzZUluc3BlY3Rpb24oKTtcbiAgICByZXQuX2JpdEZpZWxkID0gMTY3NzcyMTY7XG4gICAgcmV0Ll9zZXR0bGVkVmFsdWVGaWVsZCA9IHJlYXNvbjtcbiAgICByZXR1cm4gdGhpcy5fcHJvbWlzZVJlc29sdmVkKGluZGV4LCByZXQpO1xufTtcblxuUHJvbWlzZS5zZXR0bGUgPSBmdW5jdGlvbiAocHJvbWlzZXMpIHtcbiAgICBkZWJ1Zy5kZXByZWNhdGVkKFwiLnNldHRsZSgpXCIsIFwiLnJlZmxlY3QoKVwiKTtcbiAgICByZXR1cm4gbmV3IFNldHRsZWRQcm9taXNlQXJyYXkocHJvbWlzZXMpLnByb21pc2UoKTtcbn07XG5cblByb21pc2UucHJvdG90eXBlLnNldHRsZSA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gUHJvbWlzZS5zZXR0bGUodGhpcyk7XG59O1xufTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9ibHVlYmlyZC9qcy9yZWxlYXNlL3NldHRsZS5qcyIsIlwidXNlIHN0cmljdFwiO1xubW9kdWxlLmV4cG9ydHMgPVxuZnVuY3Rpb24oUHJvbWlzZSwgUHJvbWlzZUFycmF5LCBhcGlSZWplY3Rpb24pIHtcbnZhciB1dGlsID0gcmVxdWlyZShcIi4vdXRpbFwiKTtcbnZhciBSYW5nZUVycm9yID0gcmVxdWlyZShcIi4vZXJyb3JzXCIpLlJhbmdlRXJyb3I7XG52YXIgQWdncmVnYXRlRXJyb3IgPSByZXF1aXJlKFwiLi9lcnJvcnNcIikuQWdncmVnYXRlRXJyb3I7XG52YXIgaXNBcnJheSA9IHV0aWwuaXNBcnJheTtcbnZhciBDQU5DRUxMQVRJT04gPSB7fTtcblxuXG5mdW5jdGlvbiBTb21lUHJvbWlzZUFycmF5KHZhbHVlcykge1xuICAgIHRoaXMuY29uc3RydWN0b3IkKHZhbHVlcyk7XG4gICAgdGhpcy5faG93TWFueSA9IDA7XG4gICAgdGhpcy5fdW53cmFwID0gZmFsc2U7XG4gICAgdGhpcy5faW5pdGlhbGl6ZWQgPSBmYWxzZTtcbn1cbnV0aWwuaW5oZXJpdHMoU29tZVByb21pc2VBcnJheSwgUHJvbWlzZUFycmF5KTtcblxuU29tZVByb21pc2VBcnJheS5wcm90b3R5cGUuX2luaXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKCF0aGlzLl9pbml0aWFsaXplZCkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICh0aGlzLl9ob3dNYW55ID09PSAwKSB7XG4gICAgICAgIHRoaXMuX3Jlc29sdmUoW10pO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuX2luaXQkKHVuZGVmaW5lZCwgLTUpO1xuICAgIHZhciBpc0FycmF5UmVzb2x2ZWQgPSBpc0FycmF5KHRoaXMuX3ZhbHVlcyk7XG4gICAgaWYgKCF0aGlzLl9pc1Jlc29sdmVkKCkgJiZcbiAgICAgICAgaXNBcnJheVJlc29sdmVkICYmXG4gICAgICAgIHRoaXMuX2hvd01hbnkgPiB0aGlzLl9jYW5Qb3NzaWJseUZ1bGZpbGwoKSkge1xuICAgICAgICB0aGlzLl9yZWplY3QodGhpcy5fZ2V0UmFuZ2VFcnJvcih0aGlzLmxlbmd0aCgpKSk7XG4gICAgfVxufTtcblxuU29tZVByb21pc2VBcnJheS5wcm90b3R5cGUuaW5pdCA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLl9pbml0aWFsaXplZCA9IHRydWU7XG4gICAgdGhpcy5faW5pdCgpO1xufTtcblxuU29tZVByb21pc2VBcnJheS5wcm90b3R5cGUuc2V0VW53cmFwID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuX3Vud3JhcCA9IHRydWU7XG59O1xuXG5Tb21lUHJvbWlzZUFycmF5LnByb3RvdHlwZS5ob3dNYW55ID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLl9ob3dNYW55O1xufTtcblxuU29tZVByb21pc2VBcnJheS5wcm90b3R5cGUuc2V0SG93TWFueSA9IGZ1bmN0aW9uIChjb3VudCkge1xuICAgIHRoaXMuX2hvd01hbnkgPSBjb3VudDtcbn07XG5cblNvbWVQcm9taXNlQXJyYXkucHJvdG90eXBlLl9wcm9taXNlRnVsZmlsbGVkID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgdGhpcy5fYWRkRnVsZmlsbGVkKHZhbHVlKTtcbiAgICBpZiAodGhpcy5fZnVsZmlsbGVkKCkgPT09IHRoaXMuaG93TWFueSgpKSB7XG4gICAgICAgIHRoaXMuX3ZhbHVlcy5sZW5ndGggPSB0aGlzLmhvd01hbnkoKTtcbiAgICAgICAgaWYgKHRoaXMuaG93TWFueSgpID09PSAxICYmIHRoaXMuX3Vud3JhcCkge1xuICAgICAgICAgICAgdGhpcy5fcmVzb2x2ZSh0aGlzLl92YWx1ZXNbMF0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5fcmVzb2x2ZSh0aGlzLl92YWx1ZXMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG5cbn07XG5Tb21lUHJvbWlzZUFycmF5LnByb3RvdHlwZS5fcHJvbWlzZVJlamVjdGVkID0gZnVuY3Rpb24gKHJlYXNvbikge1xuICAgIHRoaXMuX2FkZFJlamVjdGVkKHJlYXNvbik7XG4gICAgcmV0dXJuIHRoaXMuX2NoZWNrT3V0Y29tZSgpO1xufTtcblxuU29tZVByb21pc2VBcnJheS5wcm90b3R5cGUuX3Byb21pc2VDYW5jZWxsZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHRoaXMuX3ZhbHVlcyBpbnN0YW5jZW9mIFByb21pc2UgfHwgdGhpcy5fdmFsdWVzID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2NhbmNlbCgpO1xuICAgIH1cbiAgICB0aGlzLl9hZGRSZWplY3RlZChDQU5DRUxMQVRJT04pO1xuICAgIHJldHVybiB0aGlzLl9jaGVja091dGNvbWUoKTtcbn07XG5cblNvbWVQcm9taXNlQXJyYXkucHJvdG90eXBlLl9jaGVja091dGNvbWUgPSBmdW5jdGlvbigpIHtcbiAgICBpZiAodGhpcy5ob3dNYW55KCkgPiB0aGlzLl9jYW5Qb3NzaWJseUZ1bGZpbGwoKSkge1xuICAgICAgICB2YXIgZSA9IG5ldyBBZ2dyZWdhdGVFcnJvcigpO1xuICAgICAgICBmb3IgKHZhciBpID0gdGhpcy5sZW5ndGgoKTsgaSA8IHRoaXMuX3ZhbHVlcy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgaWYgKHRoaXMuX3ZhbHVlc1tpXSAhPT0gQ0FOQ0VMTEFUSU9OKSB7XG4gICAgICAgICAgICAgICAgZS5wdXNoKHRoaXMuX3ZhbHVlc1tpXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGUubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgdGhpcy5fcmVqZWN0KGUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5fY2FuY2VsKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn07XG5cblNvbWVQcm9taXNlQXJyYXkucHJvdG90eXBlLl9mdWxmaWxsZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3RvdGFsUmVzb2x2ZWQ7XG59O1xuXG5Tb21lUHJvbWlzZUFycmF5LnByb3RvdHlwZS5fcmVqZWN0ZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3ZhbHVlcy5sZW5ndGggLSB0aGlzLmxlbmd0aCgpO1xufTtcblxuU29tZVByb21pc2VBcnJheS5wcm90b3R5cGUuX2FkZFJlamVjdGVkID0gZnVuY3Rpb24gKHJlYXNvbikge1xuICAgIHRoaXMuX3ZhbHVlcy5wdXNoKHJlYXNvbik7XG59O1xuXG5Tb21lUHJvbWlzZUFycmF5LnByb3RvdHlwZS5fYWRkRnVsZmlsbGVkID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgdGhpcy5fdmFsdWVzW3RoaXMuX3RvdGFsUmVzb2x2ZWQrK10gPSB2YWx1ZTtcbn07XG5cblNvbWVQcm9taXNlQXJyYXkucHJvdG90eXBlLl9jYW5Qb3NzaWJseUZ1bGZpbGwgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMubGVuZ3RoKCkgLSB0aGlzLl9yZWplY3RlZCgpO1xufTtcblxuU29tZVByb21pc2VBcnJheS5wcm90b3R5cGUuX2dldFJhbmdlRXJyb3IgPSBmdW5jdGlvbiAoY291bnQpIHtcbiAgICB2YXIgbWVzc2FnZSA9IFwiSW5wdXQgYXJyYXkgbXVzdCBjb250YWluIGF0IGxlYXN0IFwiICtcbiAgICAgICAgICAgIHRoaXMuX2hvd01hbnkgKyBcIiBpdGVtcyBidXQgY29udGFpbnMgb25seSBcIiArIGNvdW50ICsgXCIgaXRlbXNcIjtcbiAgICByZXR1cm4gbmV3IFJhbmdlRXJyb3IobWVzc2FnZSk7XG59O1xuXG5Tb21lUHJvbWlzZUFycmF5LnByb3RvdHlwZS5fcmVzb2x2ZUVtcHR5QXJyYXkgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5fcmVqZWN0KHRoaXMuX2dldFJhbmdlRXJyb3IoMCkpO1xufTtcblxuZnVuY3Rpb24gc29tZShwcm9taXNlcywgaG93TWFueSkge1xuICAgIGlmICgoaG93TWFueSB8IDApICE9PSBob3dNYW55IHx8IGhvd01hbnkgPCAwKSB7XG4gICAgICAgIHJldHVybiBhcGlSZWplY3Rpb24oXCJleHBlY3RpbmcgYSBwb3NpdGl2ZSBpbnRlZ2VyXFx1MDAwYVxcdTAwMGEgICAgU2VlIGh0dHA6Ly9nb28uZ2wvTXFyRm1YXFx1MDAwYVwiKTtcbiAgICB9XG4gICAgdmFyIHJldCA9IG5ldyBTb21lUHJvbWlzZUFycmF5KHByb21pc2VzKTtcbiAgICB2YXIgcHJvbWlzZSA9IHJldC5wcm9taXNlKCk7XG4gICAgcmV0LnNldEhvd01hbnkoaG93TWFueSk7XG4gICAgcmV0LmluaXQoKTtcbiAgICByZXR1cm4gcHJvbWlzZTtcbn1cblxuUHJvbWlzZS5zb21lID0gZnVuY3Rpb24gKHByb21pc2VzLCBob3dNYW55KSB7XG4gICAgcmV0dXJuIHNvbWUocHJvbWlzZXMsIGhvd01hbnkpO1xufTtcblxuUHJvbWlzZS5wcm90b3R5cGUuc29tZSA9IGZ1bmN0aW9uIChob3dNYW55KSB7XG4gICAgcmV0dXJuIHNvbWUodGhpcywgaG93TWFueSk7XG59O1xuXG5Qcm9taXNlLl9Tb21lUHJvbWlzZUFycmF5ID0gU29tZVByb21pc2VBcnJheTtcbn07XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvYmx1ZWJpcmQvanMvcmVsZWFzZS9zb21lLmpzIiwiXCJ1c2Ugc3RyaWN0XCI7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKFByb21pc2UsIElOVEVSTkFMKSB7XG52YXIgUHJvbWlzZU1hcCA9IFByb21pc2UubWFwO1xuXG5Qcm9taXNlLnByb3RvdHlwZS5maWx0ZXIgPSBmdW5jdGlvbiAoZm4sIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gUHJvbWlzZU1hcCh0aGlzLCBmbiwgb3B0aW9ucywgSU5URVJOQUwpO1xufTtcblxuUHJvbWlzZS5maWx0ZXIgPSBmdW5jdGlvbiAocHJvbWlzZXMsIGZuLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIFByb21pc2VNYXAocHJvbWlzZXMsIGZuLCBvcHRpb25zLCBJTlRFUk5BTCk7XG59O1xufTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9ibHVlYmlyZC9qcy9yZWxlYXNlL2ZpbHRlci5qcyIsIlwidXNlIHN0cmljdFwiO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihQcm9taXNlLCBJTlRFUk5BTCkge1xudmFyIFByb21pc2VSZWR1Y2UgPSBQcm9taXNlLnJlZHVjZTtcbnZhciBQcm9taXNlQWxsID0gUHJvbWlzZS5hbGw7XG5cbmZ1bmN0aW9uIHByb21pc2VBbGxUaGlzKCkge1xuICAgIHJldHVybiBQcm9taXNlQWxsKHRoaXMpO1xufVxuXG5mdW5jdGlvbiBQcm9taXNlTWFwU2VyaWVzKHByb21pc2VzLCBmbikge1xuICAgIHJldHVybiBQcm9taXNlUmVkdWNlKHByb21pc2VzLCBmbiwgSU5URVJOQUwsIElOVEVSTkFMKTtcbn1cblxuUHJvbWlzZS5wcm90b3R5cGUuZWFjaCA9IGZ1bmN0aW9uIChmbikge1xuICAgIHJldHVybiBQcm9taXNlUmVkdWNlKHRoaXMsIGZuLCBJTlRFUk5BTCwgMClcbiAgICAgICAgICAgICAgLl90aGVuKHByb21pc2VBbGxUaGlzLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgdGhpcywgdW5kZWZpbmVkKTtcbn07XG5cblByb21pc2UucHJvdG90eXBlLm1hcFNlcmllcyA9IGZ1bmN0aW9uIChmbikge1xuICAgIHJldHVybiBQcm9taXNlUmVkdWNlKHRoaXMsIGZuLCBJTlRFUk5BTCwgSU5URVJOQUwpO1xufTtcblxuUHJvbWlzZS5lYWNoID0gZnVuY3Rpb24gKHByb21pc2VzLCBmbikge1xuICAgIHJldHVybiBQcm9taXNlUmVkdWNlKHByb21pc2VzLCBmbiwgSU5URVJOQUwsIDApXG4gICAgICAgICAgICAgIC5fdGhlbihwcm9taXNlQWxsVGhpcywgdW5kZWZpbmVkLCB1bmRlZmluZWQsIHByb21pc2VzLCB1bmRlZmluZWQpO1xufTtcblxuUHJvbWlzZS5tYXBTZXJpZXMgPSBQcm9taXNlTWFwU2VyaWVzO1xufTtcblxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2JsdWViaXJkL2pzL3JlbGVhc2UvZWFjaC5qcyIsIlwidXNlIHN0cmljdFwiO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihQcm9taXNlKSB7XG52YXIgU29tZVByb21pc2VBcnJheSA9IFByb21pc2UuX1NvbWVQcm9taXNlQXJyYXk7XG5mdW5jdGlvbiBhbnkocHJvbWlzZXMpIHtcbiAgICB2YXIgcmV0ID0gbmV3IFNvbWVQcm9taXNlQXJyYXkocHJvbWlzZXMpO1xuICAgIHZhciBwcm9taXNlID0gcmV0LnByb21pc2UoKTtcbiAgICByZXQuc2V0SG93TWFueSgxKTtcbiAgICByZXQuc2V0VW53cmFwKCk7XG4gICAgcmV0LmluaXQoKTtcbiAgICByZXR1cm4gcHJvbWlzZTtcbn1cblxuUHJvbWlzZS5hbnkgPSBmdW5jdGlvbiAocHJvbWlzZXMpIHtcbiAgICByZXR1cm4gYW55KHByb21pc2VzKTtcbn07XG5cblByb21pc2UucHJvdG90eXBlLmFueSA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gYW55KHRoaXMpO1xufTtcblxufTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9ibHVlYmlyZC9qcy9yZWxlYXNlL2FueS5qcyIsIi8qKlxuICogRGV0ZWN0IEVsZWN0cm9uIHJlbmRlcmVyIHByb2Nlc3MsIHdoaWNoIGlzIG5vZGUsIGJ1dCB3ZSBzaG91bGRcbiAqIHRyZWF0IGFzIGEgYnJvd3Nlci5cbiAqL1xuXG5pZiAodHlwZW9mIHByb2Nlc3MgPT09ICd1bmRlZmluZWQnIHx8IHByb2Nlc3MudHlwZSA9PT0gJ3JlbmRlcmVyJykge1xuICBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vYnJvd3Nlci5qcycpO1xufSBlbHNlIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL25vZGUuanMnKTtcbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9lbGVjdHJvbi11cGRhdGVyL25vZGVfbW9kdWxlcy9kZWJ1Zy9zcmMvaW5kZXguanMiLCIvKipcbiAqIFRoaXMgaXMgdGhlIHdlYiBicm93c2VyIGltcGxlbWVudGF0aW9uIG9mIGBkZWJ1ZygpYC5cbiAqXG4gKiBFeHBvc2UgYGRlYnVnKClgIGFzIHRoZSBtb2R1bGUuXG4gKi9cblxuZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9kZWJ1ZycpO1xuZXhwb3J0cy5sb2cgPSBsb2c7XG5leHBvcnRzLmZvcm1hdEFyZ3MgPSBmb3JtYXRBcmdzO1xuZXhwb3J0cy5zYXZlID0gc2F2ZTtcbmV4cG9ydHMubG9hZCA9IGxvYWQ7XG5leHBvcnRzLnVzZUNvbG9ycyA9IHVzZUNvbG9ycztcbmV4cG9ydHMuc3RvcmFnZSA9ICd1bmRlZmluZWQnICE9IHR5cGVvZiBjaHJvbWVcbiAgICAgICAgICAgICAgICYmICd1bmRlZmluZWQnICE9IHR5cGVvZiBjaHJvbWUuc3RvcmFnZVxuICAgICAgICAgICAgICAgICAgPyBjaHJvbWUuc3RvcmFnZS5sb2NhbFxuICAgICAgICAgICAgICAgICAgOiBsb2NhbHN0b3JhZ2UoKTtcblxuLyoqXG4gKiBDb2xvcnMuXG4gKi9cblxuZXhwb3J0cy5jb2xvcnMgPSBbXG4gICcjMDAwMENDJywgJyMwMDAwRkYnLCAnIzAwMzNDQycsICcjMDAzM0ZGJywgJyMwMDY2Q0MnLCAnIzAwNjZGRicsICcjMDA5OUNDJyxcbiAgJyMwMDk5RkYnLCAnIzAwQ0MwMCcsICcjMDBDQzMzJywgJyMwMENDNjYnLCAnIzAwQ0M5OScsICcjMDBDQ0NDJywgJyMwMENDRkYnLFxuICAnIzMzMDBDQycsICcjMzMwMEZGJywgJyMzMzMzQ0MnLCAnIzMzMzNGRicsICcjMzM2NkNDJywgJyMzMzY2RkYnLCAnIzMzOTlDQycsXG4gICcjMzM5OUZGJywgJyMzM0NDMDAnLCAnIzMzQ0MzMycsICcjMzNDQzY2JywgJyMzM0NDOTknLCAnIzMzQ0NDQycsICcjMzNDQ0ZGJyxcbiAgJyM2NjAwQ0MnLCAnIzY2MDBGRicsICcjNjYzM0NDJywgJyM2NjMzRkYnLCAnIzY2Q0MwMCcsICcjNjZDQzMzJywgJyM5OTAwQ0MnLFxuICAnIzk5MDBGRicsICcjOTkzM0NDJywgJyM5OTMzRkYnLCAnIzk5Q0MwMCcsICcjOTlDQzMzJywgJyNDQzAwMDAnLCAnI0NDMDAzMycsXG4gICcjQ0MwMDY2JywgJyNDQzAwOTknLCAnI0NDMDBDQycsICcjQ0MwMEZGJywgJyNDQzMzMDAnLCAnI0NDMzMzMycsICcjQ0MzMzY2JyxcbiAgJyNDQzMzOTknLCAnI0NDMzNDQycsICcjQ0MzM0ZGJywgJyNDQzY2MDAnLCAnI0NDNjYzMycsICcjQ0M5OTAwJywgJyNDQzk5MzMnLFxuICAnI0NDQ0MwMCcsICcjQ0NDQzMzJywgJyNGRjAwMDAnLCAnI0ZGMDAzMycsICcjRkYwMDY2JywgJyNGRjAwOTknLCAnI0ZGMDBDQycsXG4gICcjRkYwMEZGJywgJyNGRjMzMDAnLCAnI0ZGMzMzMycsICcjRkYzMzY2JywgJyNGRjMzOTknLCAnI0ZGMzNDQycsICcjRkYzM0ZGJyxcbiAgJyNGRjY2MDAnLCAnI0ZGNjYzMycsICcjRkY5OTAwJywgJyNGRjk5MzMnLCAnI0ZGQ0MwMCcsICcjRkZDQzMzJ1xuXTtcblxuLyoqXG4gKiBDdXJyZW50bHkgb25seSBXZWJLaXQtYmFzZWQgV2ViIEluc3BlY3RvcnMsIEZpcmVmb3ggPj0gdjMxLFxuICogYW5kIHRoZSBGaXJlYnVnIGV4dGVuc2lvbiAoYW55IEZpcmVmb3ggdmVyc2lvbikgYXJlIGtub3duXG4gKiB0byBzdXBwb3J0IFwiJWNcIiBDU1MgY3VzdG9taXphdGlvbnMuXG4gKlxuICogVE9ETzogYWRkIGEgYGxvY2FsU3RvcmFnZWAgdmFyaWFibGUgdG8gZXhwbGljaXRseSBlbmFibGUvZGlzYWJsZSBjb2xvcnNcbiAqL1xuXG5mdW5jdGlvbiB1c2VDb2xvcnMoKSB7XG4gIC8vIE5COiBJbiBhbiBFbGVjdHJvbiBwcmVsb2FkIHNjcmlwdCwgZG9jdW1lbnQgd2lsbCBiZSBkZWZpbmVkIGJ1dCBub3QgZnVsbHlcbiAgLy8gaW5pdGlhbGl6ZWQuIFNpbmNlIHdlIGtub3cgd2UncmUgaW4gQ2hyb21lLCB3ZSdsbCBqdXN0IGRldGVjdCB0aGlzIGNhc2VcbiAgLy8gZXhwbGljaXRseVxuICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgd2luZG93LnByb2Nlc3MgJiYgd2luZG93LnByb2Nlc3MudHlwZSA9PT0gJ3JlbmRlcmVyJykge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgLy8gSW50ZXJuZXQgRXhwbG9yZXIgYW5kIEVkZ2UgZG8gbm90IHN1cHBvcnQgY29sb3JzLlxuICBpZiAodHlwZW9mIG5hdmlnYXRvciAhPT0gJ3VuZGVmaW5lZCcgJiYgbmF2aWdhdG9yLnVzZXJBZ2VudCAmJiBuYXZpZ2F0b3IudXNlckFnZW50LnRvTG93ZXJDYXNlKCkubWF0Y2goLyhlZGdlfHRyaWRlbnQpXFwvKFxcZCspLykpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICAvLyBpcyB3ZWJraXQ/IGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9hLzE2NDU5NjA2LzM3Njc3M1xuICAvLyBkb2N1bWVudCBpcyB1bmRlZmluZWQgaW4gcmVhY3QtbmF0aXZlOiBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QtbmF0aXZlL3B1bGwvMTYzMlxuICByZXR1cm4gKHR5cGVvZiBkb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCcgJiYgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50ICYmIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zdHlsZSAmJiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc3R5bGUuV2Via2l0QXBwZWFyYW5jZSkgfHxcbiAgICAvLyBpcyBmaXJlYnVnPyBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8zOTgxMjAvMzc2NzczXG4gICAgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHdpbmRvdy5jb25zb2xlICYmICh3aW5kb3cuY29uc29sZS5maXJlYnVnIHx8ICh3aW5kb3cuY29uc29sZS5leGNlcHRpb24gJiYgd2luZG93LmNvbnNvbGUudGFibGUpKSkgfHxcbiAgICAvLyBpcyBmaXJlZm94ID49IHYzMT9cbiAgICAvLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1Rvb2xzL1dlYl9Db25zb2xlI1N0eWxpbmdfbWVzc2FnZXNcbiAgICAodHlwZW9mIG5hdmlnYXRvciAhPT0gJ3VuZGVmaW5lZCcgJiYgbmF2aWdhdG9yLnVzZXJBZ2VudCAmJiBuYXZpZ2F0b3IudXNlckFnZW50LnRvTG93ZXJDYXNlKCkubWF0Y2goL2ZpcmVmb3hcXC8oXFxkKykvKSAmJiBwYXJzZUludChSZWdFeHAuJDEsIDEwKSA+PSAzMSkgfHxcbiAgICAvLyBkb3VibGUgY2hlY2sgd2Via2l0IGluIHVzZXJBZ2VudCBqdXN0IGluIGNhc2Ugd2UgYXJlIGluIGEgd29ya2VyXG4gICAgKHR5cGVvZiBuYXZpZ2F0b3IgIT09ICd1bmRlZmluZWQnICYmIG5hdmlnYXRvci51c2VyQWdlbnQgJiYgbmF2aWdhdG9yLnVzZXJBZ2VudC50b0xvd2VyQ2FzZSgpLm1hdGNoKC9hcHBsZXdlYmtpdFxcLyhcXGQrKS8pKTtcbn1cblxuLyoqXG4gKiBNYXAgJWogdG8gYEpTT04uc3RyaW5naWZ5KClgLCBzaW5jZSBubyBXZWIgSW5zcGVjdG9ycyBkbyB0aGF0IGJ5IGRlZmF1bHQuXG4gKi9cblxuZXhwb3J0cy5mb3JtYXR0ZXJzLmogPSBmdW5jdGlvbih2KSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHYpO1xuICB9IGNhdGNoIChlcnIpIHtcbiAgICByZXR1cm4gJ1tVbmV4cGVjdGVkSlNPTlBhcnNlRXJyb3JdOiAnICsgZXJyLm1lc3NhZ2U7XG4gIH1cbn07XG5cblxuLyoqXG4gKiBDb2xvcml6ZSBsb2cgYXJndW1lbnRzIGlmIGVuYWJsZWQuXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBmb3JtYXRBcmdzKGFyZ3MpIHtcbiAgdmFyIHVzZUNvbG9ycyA9IHRoaXMudXNlQ29sb3JzO1xuXG4gIGFyZ3NbMF0gPSAodXNlQ29sb3JzID8gJyVjJyA6ICcnKVxuICAgICsgdGhpcy5uYW1lc3BhY2VcbiAgICArICh1c2VDb2xvcnMgPyAnICVjJyA6ICcgJylcbiAgICArIGFyZ3NbMF1cbiAgICArICh1c2VDb2xvcnMgPyAnJWMgJyA6ICcgJylcbiAgICArICcrJyArIGV4cG9ydHMuaHVtYW5pemUodGhpcy5kaWZmKTtcblxuICBpZiAoIXVzZUNvbG9ycykgcmV0dXJuO1xuXG4gIHZhciBjID0gJ2NvbG9yOiAnICsgdGhpcy5jb2xvcjtcbiAgYXJncy5zcGxpY2UoMSwgMCwgYywgJ2NvbG9yOiBpbmhlcml0JylcblxuICAvLyB0aGUgZmluYWwgXCIlY1wiIGlzIHNvbWV3aGF0IHRyaWNreSwgYmVjYXVzZSB0aGVyZSBjb3VsZCBiZSBvdGhlclxuICAvLyBhcmd1bWVudHMgcGFzc2VkIGVpdGhlciBiZWZvcmUgb3IgYWZ0ZXIgdGhlICVjLCBzbyB3ZSBuZWVkIHRvXG4gIC8vIGZpZ3VyZSBvdXQgdGhlIGNvcnJlY3QgaW5kZXggdG8gaW5zZXJ0IHRoZSBDU1MgaW50b1xuICB2YXIgaW5kZXggPSAwO1xuICB2YXIgbGFzdEMgPSAwO1xuICBhcmdzWzBdLnJlcGxhY2UoLyVbYS16QS1aJV0vZywgZnVuY3Rpb24obWF0Y2gpIHtcbiAgICBpZiAoJyUlJyA9PT0gbWF0Y2gpIHJldHVybjtcbiAgICBpbmRleCsrO1xuICAgIGlmICgnJWMnID09PSBtYXRjaCkge1xuICAgICAgLy8gd2Ugb25seSBhcmUgaW50ZXJlc3RlZCBpbiB0aGUgKmxhc3QqICVjXG4gICAgICAvLyAodGhlIHVzZXIgbWF5IGhhdmUgcHJvdmlkZWQgdGhlaXIgb3duKVxuICAgICAgbGFzdEMgPSBpbmRleDtcbiAgICB9XG4gIH0pO1xuXG4gIGFyZ3Muc3BsaWNlKGxhc3RDLCAwLCBjKTtcbn1cblxuLyoqXG4gKiBJbnZva2VzIGBjb25zb2xlLmxvZygpYCB3aGVuIGF2YWlsYWJsZS5cbiAqIE5vLW9wIHdoZW4gYGNvbnNvbGUubG9nYCBpcyBub3QgYSBcImZ1bmN0aW9uXCIuXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBsb2coKSB7XG4gIC8vIHRoaXMgaGFja2VyeSBpcyByZXF1aXJlZCBmb3IgSUU4LzksIHdoZXJlXG4gIC8vIHRoZSBgY29uc29sZS5sb2dgIGZ1bmN0aW9uIGRvZXNuJ3QgaGF2ZSAnYXBwbHknXG4gIHJldHVybiAnb2JqZWN0JyA9PT0gdHlwZW9mIGNvbnNvbGVcbiAgICAmJiBjb25zb2xlLmxvZ1xuICAgICYmIEZ1bmN0aW9uLnByb3RvdHlwZS5hcHBseS5jYWxsKGNvbnNvbGUubG9nLCBjb25zb2xlLCBhcmd1bWVudHMpO1xufVxuXG4vKipcbiAqIFNhdmUgYG5hbWVzcGFjZXNgLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lc3BhY2VzXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBzYXZlKG5hbWVzcGFjZXMpIHtcbiAgdHJ5IHtcbiAgICBpZiAobnVsbCA9PSBuYW1lc3BhY2VzKSB7XG4gICAgICBleHBvcnRzLnN0b3JhZ2UucmVtb3ZlSXRlbSgnZGVidWcnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZXhwb3J0cy5zdG9yYWdlLmRlYnVnID0gbmFtZXNwYWNlcztcbiAgICB9XG4gIH0gY2F0Y2goZSkge31cbn1cblxuLyoqXG4gKiBMb2FkIGBuYW1lc3BhY2VzYC5cbiAqXG4gKiBAcmV0dXJuIHtTdHJpbmd9IHJldHVybnMgdGhlIHByZXZpb3VzbHkgcGVyc2lzdGVkIGRlYnVnIG1vZGVzXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBsb2FkKCkge1xuICB2YXIgcjtcbiAgdHJ5IHtcbiAgICByID0gZXhwb3J0cy5zdG9yYWdlLmRlYnVnO1xuICB9IGNhdGNoKGUpIHt9XG5cbiAgLy8gSWYgZGVidWcgaXNuJ3Qgc2V0IGluIExTLCBhbmQgd2UncmUgaW4gRWxlY3Ryb24sIHRyeSB0byBsb2FkICRERUJVR1xuICBpZiAoIXIgJiYgdHlwZW9mIHByb2Nlc3MgIT09ICd1bmRlZmluZWQnICYmICdlbnYnIGluIHByb2Nlc3MpIHtcbiAgICByID0gcHJvY2Vzcy5lbnYuREVCVUc7XG4gIH1cblxuICByZXR1cm4gcjtcbn1cblxuLyoqXG4gKiBFbmFibGUgbmFtZXNwYWNlcyBsaXN0ZWQgaW4gYGxvY2FsU3RvcmFnZS5kZWJ1Z2AgaW5pdGlhbGx5LlxuICovXG5cbmV4cG9ydHMuZW5hYmxlKGxvYWQoKSk7XG5cbi8qKlxuICogTG9jYWxzdG9yYWdlIGF0dGVtcHRzIHRvIHJldHVybiB0aGUgbG9jYWxzdG9yYWdlLlxuICpcbiAqIFRoaXMgaXMgbmVjZXNzYXJ5IGJlY2F1c2Ugc2FmYXJpIHRocm93c1xuICogd2hlbiBhIHVzZXIgZGlzYWJsZXMgY29va2llcy9sb2NhbHN0b3JhZ2VcbiAqIGFuZCB5b3UgYXR0ZW1wdCB0byBhY2Nlc3MgaXQuXG4gKlxuICogQHJldHVybiB7TG9jYWxTdG9yYWdlfVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gbG9jYWxzdG9yYWdlKCkge1xuICB0cnkge1xuICAgIHJldHVybiB3aW5kb3cubG9jYWxTdG9yYWdlO1xuICB9IGNhdGNoIChlKSB7fVxufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2VsZWN0cm9uLXVwZGF0ZXIvbm9kZV9tb2R1bGVzL2RlYnVnL3NyYy9icm93c2VyLmpzIiwiLyoqXG4gKiBIZWxwZXJzLlxuICovXG5cbnZhciBzID0gMTAwMDtcbnZhciBtID0gcyAqIDYwO1xudmFyIGggPSBtICogNjA7XG52YXIgZCA9IGggKiAyNDtcbnZhciB5ID0gZCAqIDM2NS4yNTtcblxuLyoqXG4gKiBQYXJzZSBvciBmb3JtYXQgdGhlIGdpdmVuIGB2YWxgLlxuICpcbiAqIE9wdGlvbnM6XG4gKlxuICogIC0gYGxvbmdgIHZlcmJvc2UgZm9ybWF0dGluZyBbZmFsc2VdXG4gKlxuICogQHBhcmFtIHtTdHJpbmd8TnVtYmVyfSB2YWxcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cbiAqIEB0aHJvd3Mge0Vycm9yfSB0aHJvdyBhbiBlcnJvciBpZiB2YWwgaXMgbm90IGEgbm9uLWVtcHR5IHN0cmluZyBvciBhIG51bWJlclxuICogQHJldHVybiB7U3RyaW5nfE51bWJlcn1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbih2YWwsIG9wdGlvbnMpIHtcbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gIHZhciB0eXBlID0gdHlwZW9mIHZhbDtcbiAgaWYgKHR5cGUgPT09ICdzdHJpbmcnICYmIHZhbC5sZW5ndGggPiAwKSB7XG4gICAgcmV0dXJuIHBhcnNlKHZhbCk7XG4gIH0gZWxzZSBpZiAodHlwZSA9PT0gJ251bWJlcicgJiYgaXNOYU4odmFsKSA9PT0gZmFsc2UpIHtcbiAgICByZXR1cm4gb3B0aW9ucy5sb25nID8gZm10TG9uZyh2YWwpIDogZm10U2hvcnQodmFsKTtcbiAgfVxuICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgJ3ZhbCBpcyBub3QgYSBub24tZW1wdHkgc3RyaW5nIG9yIGEgdmFsaWQgbnVtYmVyLiB2YWw9JyArXG4gICAgICBKU09OLnN0cmluZ2lmeSh2YWwpXG4gICk7XG59O1xuXG4vKipcbiAqIFBhcnNlIHRoZSBnaXZlbiBgc3RyYCBhbmQgcmV0dXJuIG1pbGxpc2Vjb25kcy5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyXG4gKiBAcmV0dXJuIHtOdW1iZXJ9XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBwYXJzZShzdHIpIHtcbiAgc3RyID0gU3RyaW5nKHN0cik7XG4gIGlmIChzdHIubGVuZ3RoID4gMTAwKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHZhciBtYXRjaCA9IC9eKCg/OlxcZCspP1xcLj9cXGQrKSAqKG1pbGxpc2Vjb25kcz98bXNlY3M/fG1zfHNlY29uZHM/fHNlY3M/fHN8bWludXRlcz98bWlucz98bXxob3Vycz98aHJzP3xofGRheXM/fGR8eWVhcnM/fHlycz98eSk/JC9pLmV4ZWMoXG4gICAgc3RyXG4gICk7XG4gIGlmICghbWF0Y2gpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgdmFyIG4gPSBwYXJzZUZsb2F0KG1hdGNoWzFdKTtcbiAgdmFyIHR5cGUgPSAobWF0Y2hbMl0gfHwgJ21zJykudG9Mb3dlckNhc2UoKTtcbiAgc3dpdGNoICh0eXBlKSB7XG4gICAgY2FzZSAneWVhcnMnOlxuICAgIGNhc2UgJ3llYXInOlxuICAgIGNhc2UgJ3lycyc6XG4gICAgY2FzZSAneXInOlxuICAgIGNhc2UgJ3knOlxuICAgICAgcmV0dXJuIG4gKiB5O1xuICAgIGNhc2UgJ2RheXMnOlxuICAgIGNhc2UgJ2RheSc6XG4gICAgY2FzZSAnZCc6XG4gICAgICByZXR1cm4gbiAqIGQ7XG4gICAgY2FzZSAnaG91cnMnOlxuICAgIGNhc2UgJ2hvdXInOlxuICAgIGNhc2UgJ2hycyc6XG4gICAgY2FzZSAnaHInOlxuICAgIGNhc2UgJ2gnOlxuICAgICAgcmV0dXJuIG4gKiBoO1xuICAgIGNhc2UgJ21pbnV0ZXMnOlxuICAgIGNhc2UgJ21pbnV0ZSc6XG4gICAgY2FzZSAnbWlucyc6XG4gICAgY2FzZSAnbWluJzpcbiAgICBjYXNlICdtJzpcbiAgICAgIHJldHVybiBuICogbTtcbiAgICBjYXNlICdzZWNvbmRzJzpcbiAgICBjYXNlICdzZWNvbmQnOlxuICAgIGNhc2UgJ3NlY3MnOlxuICAgIGNhc2UgJ3NlYyc6XG4gICAgY2FzZSAncyc6XG4gICAgICByZXR1cm4gbiAqIHM7XG4gICAgY2FzZSAnbWlsbGlzZWNvbmRzJzpcbiAgICBjYXNlICdtaWxsaXNlY29uZCc6XG4gICAgY2FzZSAnbXNlY3MnOlxuICAgIGNhc2UgJ21zZWMnOlxuICAgIGNhc2UgJ21zJzpcbiAgICAgIHJldHVybiBuO1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG59XG5cbi8qKlxuICogU2hvcnQgZm9ybWF0IGZvciBgbXNgLlxuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSBtc1xuICogQHJldHVybiB7U3RyaW5nfVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gZm10U2hvcnQobXMpIHtcbiAgaWYgKG1zID49IGQpIHtcbiAgICByZXR1cm4gTWF0aC5yb3VuZChtcyAvIGQpICsgJ2QnO1xuICB9XG4gIGlmIChtcyA+PSBoKSB7XG4gICAgcmV0dXJuIE1hdGgucm91bmQobXMgLyBoKSArICdoJztcbiAgfVxuICBpZiAobXMgPj0gbSkge1xuICAgIHJldHVybiBNYXRoLnJvdW5kKG1zIC8gbSkgKyAnbSc7XG4gIH1cbiAgaWYgKG1zID49IHMpIHtcbiAgICByZXR1cm4gTWF0aC5yb3VuZChtcyAvIHMpICsgJ3MnO1xuICB9XG4gIHJldHVybiBtcyArICdtcyc7XG59XG5cbi8qKlxuICogTG9uZyBmb3JtYXQgZm9yIGBtc2AuXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IG1zXG4gKiBAcmV0dXJuIHtTdHJpbmd9XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBmbXRMb25nKG1zKSB7XG4gIHJldHVybiBwbHVyYWwobXMsIGQsICdkYXknKSB8fFxuICAgIHBsdXJhbChtcywgaCwgJ2hvdXInKSB8fFxuICAgIHBsdXJhbChtcywgbSwgJ21pbnV0ZScpIHx8XG4gICAgcGx1cmFsKG1zLCBzLCAnc2Vjb25kJykgfHxcbiAgICBtcyArICcgbXMnO1xufVxuXG4vKipcbiAqIFBsdXJhbGl6YXRpb24gaGVscGVyLlxuICovXG5cbmZ1bmN0aW9uIHBsdXJhbChtcywgbiwgbmFtZSkge1xuICBpZiAobXMgPCBuKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGlmIChtcyA8IG4gKiAxLjUpIHtcbiAgICByZXR1cm4gTWF0aC5mbG9vcihtcyAvIG4pICsgJyAnICsgbmFtZTtcbiAgfVxuICByZXR1cm4gTWF0aC5jZWlsKG1zIC8gbikgKyAnICcgKyBuYW1lICsgJ3MnO1xufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL21zL2luZGV4LmpzIiwiLyoqXG4gKiBNb2R1bGUgZGVwZW5kZW5jaWVzLlxuICovXG5cbnZhciB0dHkgPSByZXF1aXJlKCd0dHknKTtcbnZhciB1dGlsID0gcmVxdWlyZSgndXRpbCcpO1xuXG4vKipcbiAqIFRoaXMgaXMgdGhlIE5vZGUuanMgaW1wbGVtZW50YXRpb24gb2YgYGRlYnVnKClgLlxuICpcbiAqIEV4cG9zZSBgZGVidWcoKWAgYXMgdGhlIG1vZHVsZS5cbiAqL1xuXG5leHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2RlYnVnJyk7XG5leHBvcnRzLmluaXQgPSBpbml0O1xuZXhwb3J0cy5sb2cgPSBsb2c7XG5leHBvcnRzLmZvcm1hdEFyZ3MgPSBmb3JtYXRBcmdzO1xuZXhwb3J0cy5zYXZlID0gc2F2ZTtcbmV4cG9ydHMubG9hZCA9IGxvYWQ7XG5leHBvcnRzLnVzZUNvbG9ycyA9IHVzZUNvbG9ycztcblxuLyoqXG4gKiBDb2xvcnMuXG4gKi9cblxuZXhwb3J0cy5jb2xvcnMgPSBbIDYsIDIsIDMsIDQsIDUsIDEgXTtcblxudHJ5IHtcbiAgdmFyIHN1cHBvcnRzQ29sb3IgPSByZXF1aXJlKCdzdXBwb3J0cy1jb2xvcicpO1xuICBpZiAoc3VwcG9ydHNDb2xvciAmJiBzdXBwb3J0c0NvbG9yLmxldmVsID49IDIpIHtcbiAgICBleHBvcnRzLmNvbG9ycyA9IFtcbiAgICAgIDIwLCAyMSwgMjYsIDI3LCAzMiwgMzMsIDM4LCAzOSwgNDAsIDQxLCA0MiwgNDMsIDQ0LCA0NSwgNTYsIDU3LCA2MiwgNjMsIDY4LFxuICAgICAgNjksIDc0LCA3NSwgNzYsIDc3LCA3OCwgNzksIDgwLCA4MSwgOTIsIDkzLCA5OCwgOTksIDExMiwgMTEzLCAxMjgsIDEyOSwgMTM0LFxuICAgICAgMTM1LCAxNDgsIDE0OSwgMTYwLCAxNjEsIDE2MiwgMTYzLCAxNjQsIDE2NSwgMTY2LCAxNjcsIDE2OCwgMTY5LCAxNzAsIDE3MSxcbiAgICAgIDE3MiwgMTczLCAxNzgsIDE3OSwgMTg0LCAxODUsIDE5NiwgMTk3LCAxOTgsIDE5OSwgMjAwLCAyMDEsIDIwMiwgMjAzLCAyMDQsXG4gICAgICAyMDUsIDIwNiwgMjA3LCAyMDgsIDIwOSwgMjE0LCAyMTUsIDIyMCwgMjIxXG4gICAgXTtcbiAgfVxufSBjYXRjaCAoZXJyKSB7XG4gIC8vIHN3YWxsb3cgLSB3ZSBvbmx5IGNhcmUgaWYgYHN1cHBvcnRzLWNvbG9yYCBpcyBhdmFpbGFibGU7IGl0IGRvZXNuJ3QgaGF2ZSB0byBiZS5cbn1cblxuLyoqXG4gKiBCdWlsZCB1cCB0aGUgZGVmYXVsdCBgaW5zcGVjdE9wdHNgIG9iamVjdCBmcm9tIHRoZSBlbnZpcm9ubWVudCB2YXJpYWJsZXMuXG4gKlxuICogICAkIERFQlVHX0NPTE9SUz1ubyBERUJVR19ERVBUSD0xMCBERUJVR19TSE9XX0hJRERFTj1lbmFibGVkIG5vZGUgc2NyaXB0LmpzXG4gKi9cblxuZXhwb3J0cy5pbnNwZWN0T3B0cyA9IE9iamVjdC5rZXlzKHByb2Nlc3MuZW52KS5maWx0ZXIoZnVuY3Rpb24gKGtleSkge1xuICByZXR1cm4gL15kZWJ1Z18vaS50ZXN0KGtleSk7XG59KS5yZWR1Y2UoZnVuY3Rpb24gKG9iaiwga2V5KSB7XG4gIC8vIGNhbWVsLWNhc2VcbiAgdmFyIHByb3AgPSBrZXlcbiAgICAuc3Vic3RyaW5nKDYpXG4gICAgLnRvTG93ZXJDYXNlKClcbiAgICAucmVwbGFjZSgvXyhbYS16XSkvZywgZnVuY3Rpb24gKF8sIGspIHsgcmV0dXJuIGsudG9VcHBlckNhc2UoKSB9KTtcblxuICAvLyBjb2VyY2Ugc3RyaW5nIHZhbHVlIGludG8gSlMgdmFsdWVcbiAgdmFyIHZhbCA9IHByb2Nlc3MuZW52W2tleV07XG4gIGlmICgvXih5ZXN8b258dHJ1ZXxlbmFibGVkKSQvaS50ZXN0KHZhbCkpIHZhbCA9IHRydWU7XG4gIGVsc2UgaWYgKC9eKG5vfG9mZnxmYWxzZXxkaXNhYmxlZCkkL2kudGVzdCh2YWwpKSB2YWwgPSBmYWxzZTtcbiAgZWxzZSBpZiAodmFsID09PSAnbnVsbCcpIHZhbCA9IG51bGw7XG4gIGVsc2UgdmFsID0gTnVtYmVyKHZhbCk7XG5cbiAgb2JqW3Byb3BdID0gdmFsO1xuICByZXR1cm4gb2JqO1xufSwge30pO1xuXG4vKipcbiAqIElzIHN0ZG91dCBhIFRUWT8gQ29sb3JlZCBvdXRwdXQgaXMgZW5hYmxlZCB3aGVuIGB0cnVlYC5cbiAqL1xuXG5mdW5jdGlvbiB1c2VDb2xvcnMoKSB7XG4gIHJldHVybiAnY29sb3JzJyBpbiBleHBvcnRzLmluc3BlY3RPcHRzXG4gICAgPyBCb29sZWFuKGV4cG9ydHMuaW5zcGVjdE9wdHMuY29sb3JzKVxuICAgIDogdHR5LmlzYXR0eShwcm9jZXNzLnN0ZGVyci5mZCk7XG59XG5cbi8qKlxuICogTWFwICVvIHRvIGB1dGlsLmluc3BlY3QoKWAsIGFsbCBvbiBhIHNpbmdsZSBsaW5lLlxuICovXG5cbmV4cG9ydHMuZm9ybWF0dGVycy5vID0gZnVuY3Rpb24odikge1xuICB0aGlzLmluc3BlY3RPcHRzLmNvbG9ycyA9IHRoaXMudXNlQ29sb3JzO1xuICByZXR1cm4gdXRpbC5pbnNwZWN0KHYsIHRoaXMuaW5zcGVjdE9wdHMpXG4gICAgLnNwbGl0KCdcXG4nKS5tYXAoZnVuY3Rpb24oc3RyKSB7XG4gICAgICByZXR1cm4gc3RyLnRyaW0oKVxuICAgIH0pLmpvaW4oJyAnKTtcbn07XG5cbi8qKlxuICogTWFwICVvIHRvIGB1dGlsLmluc3BlY3QoKWAsIGFsbG93aW5nIG11bHRpcGxlIGxpbmVzIGlmIG5lZWRlZC5cbiAqL1xuXG5leHBvcnRzLmZvcm1hdHRlcnMuTyA9IGZ1bmN0aW9uKHYpIHtcbiAgdGhpcy5pbnNwZWN0T3B0cy5jb2xvcnMgPSB0aGlzLnVzZUNvbG9ycztcbiAgcmV0dXJuIHV0aWwuaW5zcGVjdCh2LCB0aGlzLmluc3BlY3RPcHRzKTtcbn07XG5cbi8qKlxuICogQWRkcyBBTlNJIGNvbG9yIGVzY2FwZSBjb2RlcyBpZiBlbmFibGVkLlxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gZm9ybWF0QXJncyhhcmdzKSB7XG4gIHZhciBuYW1lID0gdGhpcy5uYW1lc3BhY2U7XG4gIHZhciB1c2VDb2xvcnMgPSB0aGlzLnVzZUNvbG9ycztcblxuICBpZiAodXNlQ29sb3JzKSB7XG4gICAgdmFyIGMgPSB0aGlzLmNvbG9yO1xuICAgIHZhciBjb2xvckNvZGUgPSAnXFx1MDAxYlszJyArIChjIDwgOCA/IGMgOiAnODs1OycgKyBjKTtcbiAgICB2YXIgcHJlZml4ID0gJyAgJyArIGNvbG9yQ29kZSArICc7MW0nICsgbmFtZSArICcgJyArICdcXHUwMDFiWzBtJztcblxuICAgIGFyZ3NbMF0gPSBwcmVmaXggKyBhcmdzWzBdLnNwbGl0KCdcXG4nKS5qb2luKCdcXG4nICsgcHJlZml4KTtcbiAgICBhcmdzLnB1c2goY29sb3JDb2RlICsgJ20rJyArIGV4cG9ydHMuaHVtYW5pemUodGhpcy5kaWZmKSArICdcXHUwMDFiWzBtJyk7XG4gIH0gZWxzZSB7XG4gICAgYXJnc1swXSA9IGdldERhdGUoKSArIG5hbWUgKyAnICcgKyBhcmdzWzBdO1xuICB9XG59XG5cbmZ1bmN0aW9uIGdldERhdGUoKSB7XG4gIGlmIChleHBvcnRzLmluc3BlY3RPcHRzLmhpZGVEYXRlKSB7XG4gICAgcmV0dXJuICcnO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCkgKyAnICc7XG4gIH1cbn1cblxuLyoqXG4gKiBJbnZva2VzIGB1dGlsLmZvcm1hdCgpYCB3aXRoIHRoZSBzcGVjaWZpZWQgYXJndW1lbnRzIGFuZCB3cml0ZXMgdG8gc3RkZXJyLlxuICovXG5cbmZ1bmN0aW9uIGxvZygpIHtcbiAgcmV0dXJuIHByb2Nlc3Muc3RkZXJyLndyaXRlKHV0aWwuZm9ybWF0LmFwcGx5KHV0aWwsIGFyZ3VtZW50cykgKyAnXFxuJyk7XG59XG5cbi8qKlxuICogU2F2ZSBgbmFtZXNwYWNlc2AuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IG5hbWVzcGFjZXNcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIHNhdmUobmFtZXNwYWNlcykge1xuICBpZiAobnVsbCA9PSBuYW1lc3BhY2VzKSB7XG4gICAgLy8gSWYgeW91IHNldCBhIHByb2Nlc3MuZW52IGZpZWxkIHRvIG51bGwgb3IgdW5kZWZpbmVkLCBpdCBnZXRzIGNhc3QgdG8gdGhlXG4gICAgLy8gc3RyaW5nICdudWxsJyBvciAndW5kZWZpbmVkJy4gSnVzdCBkZWxldGUgaW5zdGVhZC5cbiAgICBkZWxldGUgcHJvY2Vzcy5lbnYuREVCVUc7XG4gIH0gZWxzZSB7XG4gICAgcHJvY2Vzcy5lbnYuREVCVUcgPSBuYW1lc3BhY2VzO1xuICB9XG59XG5cbi8qKlxuICogTG9hZCBgbmFtZXNwYWNlc2AuXG4gKlxuICogQHJldHVybiB7U3RyaW5nfSByZXR1cm5zIHRoZSBwcmV2aW91c2x5IHBlcnNpc3RlZCBkZWJ1ZyBtb2Rlc1xuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gbG9hZCgpIHtcbiAgcmV0dXJuIHByb2Nlc3MuZW52LkRFQlVHO1xufVxuXG4vKipcbiAqIEluaXQgbG9naWMgZm9yIGBkZWJ1Z2AgaW5zdGFuY2VzLlxuICpcbiAqIENyZWF0ZSBhIG5ldyBgaW5zcGVjdE9wdHNgIG9iamVjdCBpbiBjYXNlIGB1c2VDb2xvcnNgIGlzIHNldFxuICogZGlmZmVyZW50bHkgZm9yIGEgcGFydGljdWxhciBgZGVidWdgIGluc3RhbmNlLlxuICovXG5cbmZ1bmN0aW9uIGluaXQgKGRlYnVnKSB7XG4gIGRlYnVnLmluc3BlY3RPcHRzID0ge307XG5cbiAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhleHBvcnRzLmluc3BlY3RPcHRzKTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgZGVidWcuaW5zcGVjdE9wdHNba2V5c1tpXV0gPSBleHBvcnRzLmluc3BlY3RPcHRzW2tleXNbaV1dO1xuICB9XG59XG5cbi8qKlxuICogRW5hYmxlIG5hbWVzcGFjZXMgbGlzdGVkIGluIGBwcm9jZXNzLmVudi5ERUJVR2AgaW5pdGlhbGx5LlxuICovXG5cbmV4cG9ydHMuZW5hYmxlKGxvYWQoKSk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvZWxlY3Ryb24tdXBkYXRlci9ub2RlX21vZHVsZXMvZGVidWcvc3JjL25vZGUuanMiLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCJ0dHlcIik7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gZXh0ZXJuYWwgXCJ0dHlcIlxuLy8gbW9kdWxlIGlkID0gMTA0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIid1c2Ugc3RyaWN0JztcbmNvbnN0IG9zID0gcmVxdWlyZSgnb3MnKTtcbmNvbnN0IGhhc0ZsYWcgPSByZXF1aXJlKCdoYXMtZmxhZycpO1xuXG5jb25zdCBlbnYgPSBwcm9jZXNzLmVudjtcblxuY29uc3Qgc3VwcG9ydCA9IGxldmVsID0+IHtcblx0aWYgKGxldmVsID09PSAwKSB7XG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9XG5cblx0cmV0dXJuIHtcblx0XHRsZXZlbCxcblx0XHRoYXNCYXNpYzogdHJ1ZSxcblx0XHRoYXMyNTY6IGxldmVsID49IDIsXG5cdFx0aGFzMTZtOiBsZXZlbCA+PSAzXG5cdH07XG59O1xuXG5sZXQgc3VwcG9ydExldmVsID0gKCgpID0+IHtcblx0aWYgKGhhc0ZsYWcoJ25vLWNvbG9yJykgfHxcblx0XHRoYXNGbGFnKCduby1jb2xvcnMnKSB8fFxuXHRcdGhhc0ZsYWcoJ2NvbG9yPWZhbHNlJykpIHtcblx0XHRyZXR1cm4gMDtcblx0fVxuXG5cdGlmIChoYXNGbGFnKCdjb2xvcj0xNm0nKSB8fFxuXHRcdGhhc0ZsYWcoJ2NvbG9yPWZ1bGwnKSB8fFxuXHRcdGhhc0ZsYWcoJ2NvbG9yPXRydWVjb2xvcicpKSB7XG5cdFx0cmV0dXJuIDM7XG5cdH1cblxuXHRpZiAoaGFzRmxhZygnY29sb3I9MjU2JykpIHtcblx0XHRyZXR1cm4gMjtcblx0fVxuXG5cdGlmIChoYXNGbGFnKCdjb2xvcicpIHx8XG5cdFx0aGFzRmxhZygnY29sb3JzJykgfHxcblx0XHRoYXNGbGFnKCdjb2xvcj10cnVlJykgfHxcblx0XHRoYXNGbGFnKCdjb2xvcj1hbHdheXMnKSkge1xuXHRcdHJldHVybiAxO1xuXHR9XG5cblx0aWYgKHByb2Nlc3Muc3Rkb3V0ICYmICFwcm9jZXNzLnN0ZG91dC5pc1RUWSkge1xuXHRcdHJldHVybiAwO1xuXHR9XG5cblx0aWYgKHByb2Nlc3MucGxhdGZvcm0gPT09ICd3aW4zMicpIHtcblx0XHQvLyBOb2RlLmpzIDcuNS4wIGlzIHRoZSBmaXJzdCB2ZXJzaW9uIG9mIE5vZGUuanMgdG8gaW5jbHVkZSBhIHBhdGNoIHRvXG5cdFx0Ly8gbGlidXYgdGhhdCBlbmFibGVzIDI1NiBjb2xvciBvdXRwdXQgb24gV2luZG93cy4gQW55dGhpbmcgZWFybGllciBhbmQgaXRcblx0XHQvLyB3b24ndCB3b3JrLiBIb3dldmVyLCBoZXJlIHdlIHRhcmdldCBOb2RlLmpzIDggYXQgbWluaW11bSBhcyBpdCBpcyBhbiBMVFNcblx0XHQvLyByZWxlYXNlLCBhbmQgTm9kZS5qcyA3IGlzIG5vdC4gV2luZG93cyAxMCBidWlsZCAxMDU4NiBpcyB0aGUgZmlyc3QgV2luZG93c1xuXHRcdC8vIHJlbGVhc2UgdGhhdCBzdXBwb3J0cyAyNTYgY29sb3JzLlxuXHRcdGNvbnN0IG9zUmVsZWFzZSA9IG9zLnJlbGVhc2UoKS5zcGxpdCgnLicpO1xuXHRcdGlmIChcblx0XHRcdE51bWJlcihwcm9jZXNzLnZlcnNpb25zLm5vZGUuc3BsaXQoJy4nKVswXSkgPj0gOCAmJlxuXHRcdFx0TnVtYmVyKG9zUmVsZWFzZVswXSkgPj0gMTAgJiZcblx0XHRcdE51bWJlcihvc1JlbGVhc2VbMl0pID49IDEwNTg2XG5cdFx0KSB7XG5cdFx0XHRyZXR1cm4gMjtcblx0XHR9XG5cblx0XHRyZXR1cm4gMTtcblx0fVxuXG5cdGlmICgnQ0knIGluIGVudikge1xuXHRcdGlmIChbJ1RSQVZJUycsICdDSVJDTEVDSScsICdBUFBWRVlPUicsICdHSVRMQUJfQ0knXS5zb21lKHNpZ24gPT4gc2lnbiBpbiBlbnYpIHx8IGVudi5DSV9OQU1FID09PSAnY29kZXNoaXAnKSB7XG5cdFx0XHRyZXR1cm4gMTtcblx0XHR9XG5cblx0XHRyZXR1cm4gMDtcblx0fVxuXG5cdGlmICgnVEVBTUNJVFlfVkVSU0lPTicgaW4gZW52KSB7XG5cdFx0cmV0dXJuIC9eKDlcXC4oMCpbMS05XVxcZCopXFwufFxcZHsyLH1cXC4pLy50ZXN0KGVudi5URUFNQ0lUWV9WRVJTSU9OKSA/IDEgOiAwO1xuXHR9XG5cblx0aWYgKCdURVJNX1BST0dSQU0nIGluIGVudikge1xuXHRcdGNvbnN0IHZlcnNpb24gPSBwYXJzZUludCgoZW52LlRFUk1fUFJPR1JBTV9WRVJTSU9OIHx8ICcnKS5zcGxpdCgnLicpWzBdLCAxMCk7XG5cblx0XHRzd2l0Y2ggKGVudi5URVJNX1BST0dSQU0pIHtcblx0XHRcdGNhc2UgJ2lUZXJtLmFwcCc6XG5cdFx0XHRcdHJldHVybiB2ZXJzaW9uID49IDMgPyAzIDogMjtcblx0XHRcdGNhc2UgJ0h5cGVyJzpcblx0XHRcdFx0cmV0dXJuIDM7XG5cdFx0XHRjYXNlICdBcHBsZV9UZXJtaW5hbCc6XG5cdFx0XHRcdHJldHVybiAyO1xuXHRcdFx0Ly8gTm8gZGVmYXVsdFxuXHRcdH1cblx0fVxuXG5cdGlmICgvLTI1Nihjb2xvcik/JC9pLnRlc3QoZW52LlRFUk0pKSB7XG5cdFx0cmV0dXJuIDI7XG5cdH1cblxuXHRpZiAoL15zY3JlZW58Xnh0ZXJtfF52dDEwMHxecnh2dHxjb2xvcnxhbnNpfGN5Z3dpbnxsaW51eC9pLnRlc3QoZW52LlRFUk0pKSB7XG5cdFx0cmV0dXJuIDE7XG5cdH1cblxuXHRpZiAoJ0NPTE9SVEVSTScgaW4gZW52KSB7XG5cdFx0cmV0dXJuIDE7XG5cdH1cblxuXHRpZiAoZW52LlRFUk0gPT09ICdkdW1iJykge1xuXHRcdHJldHVybiAwO1xuXHR9XG5cblx0cmV0dXJuIDA7XG59KSgpO1xuXG5pZiAoJ0ZPUkNFX0NPTE9SJyBpbiBlbnYpIHtcblx0c3VwcG9ydExldmVsID0gcGFyc2VJbnQoZW52LkZPUkNFX0NPTE9SLCAxMCkgPT09IDAgPyAwIDogKHN1cHBvcnRMZXZlbCB8fCAxKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBwcm9jZXNzICYmIHN1cHBvcnQoc3VwcG9ydExldmVsKTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9zdXBwb3J0cy1jb2xvci9pbmRleC5qcyIsIid1c2Ugc3RyaWN0Jztcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGZsYWcsIGFyZ3YpIHtcblx0YXJndiA9IGFyZ3YgfHwgcHJvY2Vzcy5hcmd2O1xuXG5cdHZhciB0ZXJtaW5hdG9yUG9zID0gYXJndi5pbmRleE9mKCctLScpO1xuXHR2YXIgcHJlZml4ID0gL14tezEsMn0vLnRlc3QoZmxhZykgPyAnJyA6ICctLSc7XG5cdHZhciBwb3MgPSBhcmd2LmluZGV4T2YocHJlZml4ICsgZmxhZyk7XG5cblx0cmV0dXJuIHBvcyAhPT0gLTEgJiYgKHRlcm1pbmF0b3JQb3MgPT09IC0xID8gdHJ1ZSA6IHBvcyA8IHRlcm1pbmF0b3JQb3MpO1xufTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9oYXMtZmxhZy9pbmRleC5qcyIsIid1c2Ugc3RyaWN0J1xuXG5jb25zdCBhc3NpZ24gPSByZXF1aXJlKCcuL3V0aWwvYXNzaWduJylcblxuY29uc3QgZnMgPSB7fVxuXG4vLyBFeHBvcnQgZ3JhY2VmdWwtZnM6XG5hc3NpZ24oZnMsIHJlcXVpcmUoJy4vZnMnKSlcbi8vIEV4cG9ydCBleHRyYSBtZXRob2RzOlxuYXNzaWduKGZzLCByZXF1aXJlKCcuL2NvcHknKSlcbmFzc2lnbihmcywgcmVxdWlyZSgnLi9jb3B5LXN5bmMnKSlcbmFzc2lnbihmcywgcmVxdWlyZSgnLi9ta2RpcnMnKSlcbmFzc2lnbihmcywgcmVxdWlyZSgnLi9yZW1vdmUnKSlcbmFzc2lnbihmcywgcmVxdWlyZSgnLi9qc29uJykpXG5hc3NpZ24oZnMsIHJlcXVpcmUoJy4vbW92ZScpKVxuYXNzaWduKGZzLCByZXF1aXJlKCcuL21vdmUtc3luYycpKVxuYXNzaWduKGZzLCByZXF1aXJlKCcuL2VtcHR5JykpXG5hc3NpZ24oZnMsIHJlcXVpcmUoJy4vZW5zdXJlJykpXG5hc3NpZ24oZnMsIHJlcXVpcmUoJy4vb3V0cHV0JykpXG5hc3NpZ24oZnMsIHJlcXVpcmUoJy4vcGF0aC1leGlzdHMnKSlcblxubW9kdWxlLmV4cG9ydHMgPSBmc1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2VsZWN0cm9uLXVwZGF0ZXIvbm9kZV9tb2R1bGVzL2ZzLWV4dHJhL2xpYi9pbmRleC5qcyIsIid1c2Ugc3RyaWN0J1xuXG4vLyBzaW1wbGUgbXV0YWJsZSBhc3NpZ25cbmZ1bmN0aW9uIGFzc2lnbiAoKSB7XG4gIGNvbnN0IGFyZ3MgPSBbXS5zbGljZS5jYWxsKGFyZ3VtZW50cykuZmlsdGVyKGkgPT4gaSlcbiAgY29uc3QgZGVzdCA9IGFyZ3Muc2hpZnQoKVxuICBhcmdzLmZvckVhY2goc3JjID0+IHtcbiAgICBPYmplY3Qua2V5cyhzcmMpLmZvckVhY2goa2V5ID0+IHtcbiAgICAgIGRlc3Rba2V5XSA9IHNyY1trZXldXG4gICAgfSlcbiAgfSlcblxuICByZXR1cm4gZGVzdFxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGFzc2lnblxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2VsZWN0cm9uLXVwZGF0ZXIvbm9kZV9tb2R1bGVzL2ZzLWV4dHJhL2xpYi91dGlsL2Fzc2lnbi5qcyIsInZhciBmcyA9IHJlcXVpcmUoJy4vZnMuanMnKVxudmFyIGNvbnN0YW50cyA9IHJlcXVpcmUoJ2NvbnN0YW50cycpXG5cbnZhciBvcmlnQ3dkID0gcHJvY2Vzcy5jd2RcbnZhciBjd2QgPSBudWxsXG5cbnZhciBwbGF0Zm9ybSA9IHByb2Nlc3MuZW52LkdSQUNFRlVMX0ZTX1BMQVRGT1JNIHx8IHByb2Nlc3MucGxhdGZvcm1cblxucHJvY2Vzcy5jd2QgPSBmdW5jdGlvbigpIHtcbiAgaWYgKCFjd2QpXG4gICAgY3dkID0gb3JpZ0N3ZC5jYWxsKHByb2Nlc3MpXG4gIHJldHVybiBjd2Rcbn1cbnRyeSB7XG4gIHByb2Nlc3MuY3dkKClcbn0gY2F0Y2ggKGVyKSB7fVxuXG52YXIgY2hkaXIgPSBwcm9jZXNzLmNoZGlyXG5wcm9jZXNzLmNoZGlyID0gZnVuY3Rpb24oZCkge1xuICBjd2QgPSBudWxsXG4gIGNoZGlyLmNhbGwocHJvY2VzcywgZClcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBwYXRjaFxuXG5mdW5jdGlvbiBwYXRjaCAoZnMpIHtcbiAgLy8gKHJlLSlpbXBsZW1lbnQgc29tZSB0aGluZ3MgdGhhdCBhcmUga25vd24gYnVzdGVkIG9yIG1pc3NpbmcuXG5cbiAgLy8gbGNobW9kLCBicm9rZW4gcHJpb3IgdG8gMC42LjJcbiAgLy8gYmFjay1wb3J0IHRoZSBmaXggaGVyZS5cbiAgaWYgKGNvbnN0YW50cy5oYXNPd25Qcm9wZXJ0eSgnT19TWU1MSU5LJykgJiZcbiAgICAgIHByb2Nlc3MudmVyc2lvbi5tYXRjaCgvXnYwXFwuNlxcLlswLTJdfF52MFxcLjVcXC4vKSkge1xuICAgIHBhdGNoTGNobW9kKGZzKVxuICB9XG5cbiAgLy8gbHV0aW1lcyBpbXBsZW1lbnRhdGlvbiwgb3Igbm8tb3BcbiAgaWYgKCFmcy5sdXRpbWVzKSB7XG4gICAgcGF0Y2hMdXRpbWVzKGZzKVxuICB9XG5cbiAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2lzYWFjcy9ub2RlLWdyYWNlZnVsLWZzL2lzc3Vlcy80XG4gIC8vIENob3duIHNob3VsZCBub3QgZmFpbCBvbiBlaW52YWwgb3IgZXBlcm0gaWYgbm9uLXJvb3QuXG4gIC8vIEl0IHNob3VsZCBub3QgZmFpbCBvbiBlbm9zeXMgZXZlciwgYXMgdGhpcyBqdXN0IGluZGljYXRlc1xuICAvLyB0aGF0IGEgZnMgZG9lc24ndCBzdXBwb3J0IHRoZSBpbnRlbmRlZCBvcGVyYXRpb24uXG5cbiAgZnMuY2hvd24gPSBjaG93bkZpeChmcy5jaG93bilcbiAgZnMuZmNob3duID0gY2hvd25GaXgoZnMuZmNob3duKVxuICBmcy5sY2hvd24gPSBjaG93bkZpeChmcy5sY2hvd24pXG5cbiAgZnMuY2htb2QgPSBjaG1vZEZpeChmcy5jaG1vZClcbiAgZnMuZmNobW9kID0gY2htb2RGaXgoZnMuZmNobW9kKVxuICBmcy5sY2htb2QgPSBjaG1vZEZpeChmcy5sY2htb2QpXG5cbiAgZnMuY2hvd25TeW5jID0gY2hvd25GaXhTeW5jKGZzLmNob3duU3luYylcbiAgZnMuZmNob3duU3luYyA9IGNob3duRml4U3luYyhmcy5mY2hvd25TeW5jKVxuICBmcy5sY2hvd25TeW5jID0gY2hvd25GaXhTeW5jKGZzLmxjaG93blN5bmMpXG5cbiAgZnMuY2htb2RTeW5jID0gY2htb2RGaXhTeW5jKGZzLmNobW9kU3luYylcbiAgZnMuZmNobW9kU3luYyA9IGNobW9kRml4U3luYyhmcy5mY2htb2RTeW5jKVxuICBmcy5sY2htb2RTeW5jID0gY2htb2RGaXhTeW5jKGZzLmxjaG1vZFN5bmMpXG5cbiAgZnMuc3RhdCA9IHN0YXRGaXgoZnMuc3RhdClcbiAgZnMuZnN0YXQgPSBzdGF0Rml4KGZzLmZzdGF0KVxuICBmcy5sc3RhdCA9IHN0YXRGaXgoZnMubHN0YXQpXG5cbiAgZnMuc3RhdFN5bmMgPSBzdGF0Rml4U3luYyhmcy5zdGF0U3luYylcbiAgZnMuZnN0YXRTeW5jID0gc3RhdEZpeFN5bmMoZnMuZnN0YXRTeW5jKVxuICBmcy5sc3RhdFN5bmMgPSBzdGF0Rml4U3luYyhmcy5sc3RhdFN5bmMpXG5cbiAgLy8gaWYgbGNobW9kL2xjaG93biBkbyBub3QgZXhpc3QsIHRoZW4gbWFrZSB0aGVtIG5vLW9wc1xuICBpZiAoIWZzLmxjaG1vZCkge1xuICAgIGZzLmxjaG1vZCA9IGZ1bmN0aW9uIChwYXRoLCBtb2RlLCBjYikge1xuICAgICAgaWYgKGNiKSBwcm9jZXNzLm5leHRUaWNrKGNiKVxuICAgIH1cbiAgICBmcy5sY2htb2RTeW5jID0gZnVuY3Rpb24gKCkge31cbiAgfVxuICBpZiAoIWZzLmxjaG93bikge1xuICAgIGZzLmxjaG93biA9IGZ1bmN0aW9uIChwYXRoLCB1aWQsIGdpZCwgY2IpIHtcbiAgICAgIGlmIChjYikgcHJvY2Vzcy5uZXh0VGljayhjYilcbiAgICB9XG4gICAgZnMubGNob3duU3luYyA9IGZ1bmN0aW9uICgpIHt9XG4gIH1cblxuICAvLyBvbiBXaW5kb3dzLCBBL1Ygc29mdHdhcmUgY2FuIGxvY2sgdGhlIGRpcmVjdG9yeSwgY2F1c2luZyB0aGlzXG4gIC8vIHRvIGZhaWwgd2l0aCBhbiBFQUNDRVMgb3IgRVBFUk0gaWYgdGhlIGRpcmVjdG9yeSBjb250YWlucyBuZXdseVxuICAvLyBjcmVhdGVkIGZpbGVzLiAgVHJ5IGFnYWluIG9uIGZhaWx1cmUsIGZvciB1cCB0byA2MCBzZWNvbmRzLlxuXG4gIC8vIFNldCB0aGUgdGltZW91dCB0aGlzIGxvbmcgYmVjYXVzZSBzb21lIFdpbmRvd3MgQW50aS1WaXJ1cywgc3VjaCBhcyBQYXJpdHlcbiAgLy8gYml0OSwgbWF5IGxvY2sgZmlsZXMgZm9yIHVwIHRvIGEgbWludXRlLCBjYXVzaW5nIG5wbSBwYWNrYWdlIGluc3RhbGxcbiAgLy8gZmFpbHVyZXMuIEFsc28sIHRha2UgY2FyZSB0byB5aWVsZCB0aGUgc2NoZWR1bGVyLiBXaW5kb3dzIHNjaGVkdWxpbmcgZ2l2ZXNcbiAgLy8gQ1BVIHRvIGEgYnVzeSBsb29waW5nIHByb2Nlc3MsIHdoaWNoIGNhbiBjYXVzZSB0aGUgcHJvZ3JhbSBjYXVzaW5nIHRoZSBsb2NrXG4gIC8vIGNvbnRlbnRpb24gdG8gYmUgc3RhcnZlZCBvZiBDUFUgYnkgbm9kZSwgc28gdGhlIGNvbnRlbnRpb24gZG9lc24ndCByZXNvbHZlLlxuICBpZiAocGxhdGZvcm0gPT09IFwid2luMzJcIikge1xuICAgIGZzLnJlbmFtZSA9IChmdW5jdGlvbiAoZnMkcmVuYW1lKSB7IHJldHVybiBmdW5jdGlvbiAoZnJvbSwgdG8sIGNiKSB7XG4gICAgICB2YXIgc3RhcnQgPSBEYXRlLm5vdygpXG4gICAgICB2YXIgYmFja29mZiA9IDA7XG4gICAgICBmcyRyZW5hbWUoZnJvbSwgdG8sIGZ1bmN0aW9uIENCIChlcikge1xuICAgICAgICBpZiAoZXJcbiAgICAgICAgICAgICYmIChlci5jb2RlID09PSBcIkVBQ0NFU1wiIHx8IGVyLmNvZGUgPT09IFwiRVBFUk1cIilcbiAgICAgICAgICAgICYmIERhdGUubm93KCkgLSBzdGFydCA8IDYwMDAwKSB7XG4gICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGZzLnN0YXQodG8sIGZ1bmN0aW9uIChzdGF0ZXIsIHN0KSB7XG4gICAgICAgICAgICAgIGlmIChzdGF0ZXIgJiYgc3RhdGVyLmNvZGUgPT09IFwiRU5PRU5UXCIpXG4gICAgICAgICAgICAgICAgZnMkcmVuYW1lKGZyb20sIHRvLCBDQik7XG4gICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICBjYihlcilcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgfSwgYmFja29mZilcbiAgICAgICAgICBpZiAoYmFja29mZiA8IDEwMClcbiAgICAgICAgICAgIGJhY2tvZmYgKz0gMTA7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjYikgY2IoZXIpXG4gICAgICB9KVxuICAgIH19KShmcy5yZW5hbWUpXG4gIH1cblxuICAvLyBpZiByZWFkKCkgcmV0dXJucyBFQUdBSU4sIHRoZW4ganVzdCB0cnkgaXQgYWdhaW4uXG4gIGZzLnJlYWQgPSAoZnVuY3Rpb24gKGZzJHJlYWQpIHsgcmV0dXJuIGZ1bmN0aW9uIChmZCwgYnVmZmVyLCBvZmZzZXQsIGxlbmd0aCwgcG9zaXRpb24sIGNhbGxiYWNrXykge1xuICAgIHZhciBjYWxsYmFja1xuICAgIGlmIChjYWxsYmFja18gJiYgdHlwZW9mIGNhbGxiYWNrXyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdmFyIGVhZ0NvdW50ZXIgPSAwXG4gICAgICBjYWxsYmFjayA9IGZ1bmN0aW9uIChlciwgXywgX18pIHtcbiAgICAgICAgaWYgKGVyICYmIGVyLmNvZGUgPT09ICdFQUdBSU4nICYmIGVhZ0NvdW50ZXIgPCAxMCkge1xuICAgICAgICAgIGVhZ0NvdW50ZXIgKytcbiAgICAgICAgICByZXR1cm4gZnMkcmVhZC5jYWxsKGZzLCBmZCwgYnVmZmVyLCBvZmZzZXQsIGxlbmd0aCwgcG9zaXRpb24sIGNhbGxiYWNrKVxuICAgICAgICB9XG4gICAgICAgIGNhbGxiYWNrXy5hcHBseSh0aGlzLCBhcmd1bWVudHMpXG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmcyRyZWFkLmNhbGwoZnMsIGZkLCBidWZmZXIsIG9mZnNldCwgbGVuZ3RoLCBwb3NpdGlvbiwgY2FsbGJhY2spXG4gIH19KShmcy5yZWFkKVxuXG4gIGZzLnJlYWRTeW5jID0gKGZ1bmN0aW9uIChmcyRyZWFkU3luYykgeyByZXR1cm4gZnVuY3Rpb24gKGZkLCBidWZmZXIsIG9mZnNldCwgbGVuZ3RoLCBwb3NpdGlvbikge1xuICAgIHZhciBlYWdDb3VudGVyID0gMFxuICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICB0cnkge1xuICAgICAgICByZXR1cm4gZnMkcmVhZFN5bmMuY2FsbChmcywgZmQsIGJ1ZmZlciwgb2Zmc2V0LCBsZW5ndGgsIHBvc2l0aW9uKVxuICAgICAgfSBjYXRjaCAoZXIpIHtcbiAgICAgICAgaWYgKGVyLmNvZGUgPT09ICdFQUdBSU4nICYmIGVhZ0NvdW50ZXIgPCAxMCkge1xuICAgICAgICAgIGVhZ0NvdW50ZXIgKytcbiAgICAgICAgICBjb250aW51ZVxuICAgICAgICB9XG4gICAgICAgIHRocm93IGVyXG4gICAgICB9XG4gICAgfVxuICB9fSkoZnMucmVhZFN5bmMpXG59XG5cbmZ1bmN0aW9uIHBhdGNoTGNobW9kIChmcykge1xuICBmcy5sY2htb2QgPSBmdW5jdGlvbiAocGF0aCwgbW9kZSwgY2FsbGJhY2spIHtcbiAgICBmcy5vcGVuKCBwYXRoXG4gICAgICAgICAgICwgY29uc3RhbnRzLk9fV1JPTkxZIHwgY29uc3RhbnRzLk9fU1lNTElOS1xuICAgICAgICAgICAsIG1vZGVcbiAgICAgICAgICAgLCBmdW5jdGlvbiAoZXJyLCBmZCkge1xuICAgICAgaWYgKGVycikge1xuICAgICAgICBpZiAoY2FsbGJhY2spIGNhbGxiYWNrKGVycilcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG4gICAgICAvLyBwcmVmZXIgdG8gcmV0dXJuIHRoZSBjaG1vZCBlcnJvciwgaWYgb25lIG9jY3VycyxcbiAgICAgIC8vIGJ1dCBzdGlsbCB0cnkgdG8gY2xvc2UsIGFuZCByZXBvcnQgY2xvc2luZyBlcnJvcnMgaWYgdGhleSBvY2N1ci5cbiAgICAgIGZzLmZjaG1vZChmZCwgbW9kZSwgZnVuY3Rpb24gKGVycikge1xuICAgICAgICBmcy5jbG9zZShmZCwgZnVuY3Rpb24oZXJyMikge1xuICAgICAgICAgIGlmIChjYWxsYmFjaykgY2FsbGJhY2soZXJyIHx8IGVycjIpXG4gICAgICAgIH0pXG4gICAgICB9KVxuICAgIH0pXG4gIH1cblxuICBmcy5sY2htb2RTeW5jID0gZnVuY3Rpb24gKHBhdGgsIG1vZGUpIHtcbiAgICB2YXIgZmQgPSBmcy5vcGVuU3luYyhwYXRoLCBjb25zdGFudHMuT19XUk9OTFkgfCBjb25zdGFudHMuT19TWU1MSU5LLCBtb2RlKVxuXG4gICAgLy8gcHJlZmVyIHRvIHJldHVybiB0aGUgY2htb2QgZXJyb3IsIGlmIG9uZSBvY2N1cnMsXG4gICAgLy8gYnV0IHN0aWxsIHRyeSB0byBjbG9zZSwgYW5kIHJlcG9ydCBjbG9zaW5nIGVycm9ycyBpZiB0aGV5IG9jY3VyLlxuICAgIHZhciB0aHJldyA9IHRydWVcbiAgICB2YXIgcmV0XG4gICAgdHJ5IHtcbiAgICAgIHJldCA9IGZzLmZjaG1vZFN5bmMoZmQsIG1vZGUpXG4gICAgICB0aHJldyA9IGZhbHNlXG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIGlmICh0aHJldykge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGZzLmNsb3NlU3luYyhmZClcbiAgICAgICAgfSBjYXRjaCAoZXIpIHt9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBmcy5jbG9zZVN5bmMoZmQpXG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXRcbiAgfVxufVxuXG5mdW5jdGlvbiBwYXRjaEx1dGltZXMgKGZzKSB7XG4gIGlmIChjb25zdGFudHMuaGFzT3duUHJvcGVydHkoXCJPX1NZTUxJTktcIikpIHtcbiAgICBmcy5sdXRpbWVzID0gZnVuY3Rpb24gKHBhdGgsIGF0LCBtdCwgY2IpIHtcbiAgICAgIGZzLm9wZW4ocGF0aCwgY29uc3RhbnRzLk9fU1lNTElOSywgZnVuY3Rpb24gKGVyLCBmZCkge1xuICAgICAgICBpZiAoZXIpIHtcbiAgICAgICAgICBpZiAoY2IpIGNiKGVyKVxuICAgICAgICAgIHJldHVyblxuICAgICAgICB9XG4gICAgICAgIGZzLmZ1dGltZXMoZmQsIGF0LCBtdCwgZnVuY3Rpb24gKGVyKSB7XG4gICAgICAgICAgZnMuY2xvc2UoZmQsIGZ1bmN0aW9uIChlcjIpIHtcbiAgICAgICAgICAgIGlmIChjYikgY2IoZXIgfHwgZXIyKVxuICAgICAgICAgIH0pXG4gICAgICAgIH0pXG4gICAgICB9KVxuICAgIH1cblxuICAgIGZzLmx1dGltZXNTeW5jID0gZnVuY3Rpb24gKHBhdGgsIGF0LCBtdCkge1xuICAgICAgdmFyIGZkID0gZnMub3BlblN5bmMocGF0aCwgY29uc3RhbnRzLk9fU1lNTElOSylcbiAgICAgIHZhciByZXRcbiAgICAgIHZhciB0aHJldyA9IHRydWVcbiAgICAgIHRyeSB7XG4gICAgICAgIHJldCA9IGZzLmZ1dGltZXNTeW5jKGZkLCBhdCwgbXQpXG4gICAgICAgIHRocmV3ID0gZmFsc2VcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIGlmICh0aHJldykge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBmcy5jbG9zZVN5bmMoZmQpXG4gICAgICAgICAgfSBjYXRjaCAoZXIpIHt9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZnMuY2xvc2VTeW5jKGZkKVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gcmV0XG4gICAgfVxuXG4gIH0gZWxzZSB7XG4gICAgZnMubHV0aW1lcyA9IGZ1bmN0aW9uIChfYSwgX2IsIF9jLCBjYikgeyBpZiAoY2IpIHByb2Nlc3MubmV4dFRpY2soY2IpIH1cbiAgICBmcy5sdXRpbWVzU3luYyA9IGZ1bmN0aW9uICgpIHt9XG4gIH1cbn1cblxuZnVuY3Rpb24gY2htb2RGaXggKG9yaWcpIHtcbiAgaWYgKCFvcmlnKSByZXR1cm4gb3JpZ1xuICByZXR1cm4gZnVuY3Rpb24gKHRhcmdldCwgbW9kZSwgY2IpIHtcbiAgICByZXR1cm4gb3JpZy5jYWxsKGZzLCB0YXJnZXQsIG1vZGUsIGZ1bmN0aW9uIChlcikge1xuICAgICAgaWYgKGNob3duRXJPayhlcikpIGVyID0gbnVsbFxuICAgICAgaWYgKGNiKSBjYi5hcHBseSh0aGlzLCBhcmd1bWVudHMpXG4gICAgfSlcbiAgfVxufVxuXG5mdW5jdGlvbiBjaG1vZEZpeFN5bmMgKG9yaWcpIHtcbiAgaWYgKCFvcmlnKSByZXR1cm4gb3JpZ1xuICByZXR1cm4gZnVuY3Rpb24gKHRhcmdldCwgbW9kZSkge1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4gb3JpZy5jYWxsKGZzLCB0YXJnZXQsIG1vZGUpXG4gICAgfSBjYXRjaCAoZXIpIHtcbiAgICAgIGlmICghY2hvd25Fck9rKGVyKSkgdGhyb3cgZXJcbiAgICB9XG4gIH1cbn1cblxuXG5mdW5jdGlvbiBjaG93bkZpeCAob3JpZykge1xuICBpZiAoIW9yaWcpIHJldHVybiBvcmlnXG4gIHJldHVybiBmdW5jdGlvbiAodGFyZ2V0LCB1aWQsIGdpZCwgY2IpIHtcbiAgICByZXR1cm4gb3JpZy5jYWxsKGZzLCB0YXJnZXQsIHVpZCwgZ2lkLCBmdW5jdGlvbiAoZXIpIHtcbiAgICAgIGlmIChjaG93bkVyT2soZXIpKSBlciA9IG51bGxcbiAgICAgIGlmIChjYikgY2IuYXBwbHkodGhpcywgYXJndW1lbnRzKVxuICAgIH0pXG4gIH1cbn1cblxuZnVuY3Rpb24gY2hvd25GaXhTeW5jIChvcmlnKSB7XG4gIGlmICghb3JpZykgcmV0dXJuIG9yaWdcbiAgcmV0dXJuIGZ1bmN0aW9uICh0YXJnZXQsIHVpZCwgZ2lkKSB7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBvcmlnLmNhbGwoZnMsIHRhcmdldCwgdWlkLCBnaWQpXG4gICAgfSBjYXRjaCAoZXIpIHtcbiAgICAgIGlmICghY2hvd25Fck9rKGVyKSkgdGhyb3cgZXJcbiAgICB9XG4gIH1cbn1cblxuXG5mdW5jdGlvbiBzdGF0Rml4IChvcmlnKSB7XG4gIGlmICghb3JpZykgcmV0dXJuIG9yaWdcbiAgLy8gT2xkZXIgdmVyc2lvbnMgb2YgTm9kZSBlcnJvbmVvdXNseSByZXR1cm5lZCBzaWduZWQgaW50ZWdlcnMgZm9yXG4gIC8vIHVpZCArIGdpZC5cbiAgcmV0dXJuIGZ1bmN0aW9uICh0YXJnZXQsIGNiKSB7XG4gICAgcmV0dXJuIG9yaWcuY2FsbChmcywgdGFyZ2V0LCBmdW5jdGlvbiAoZXIsIHN0YXRzKSB7XG4gICAgICBpZiAoIXN0YXRzKSByZXR1cm4gY2IuYXBwbHkodGhpcywgYXJndW1lbnRzKVxuICAgICAgaWYgKHN0YXRzLnVpZCA8IDApIHN0YXRzLnVpZCArPSAweDEwMDAwMDAwMFxuICAgICAgaWYgKHN0YXRzLmdpZCA8IDApIHN0YXRzLmdpZCArPSAweDEwMDAwMDAwMFxuICAgICAgaWYgKGNiKSBjYi5hcHBseSh0aGlzLCBhcmd1bWVudHMpXG4gICAgfSlcbiAgfVxufVxuXG5mdW5jdGlvbiBzdGF0Rml4U3luYyAob3JpZykge1xuICBpZiAoIW9yaWcpIHJldHVybiBvcmlnXG4gIC8vIE9sZGVyIHZlcnNpb25zIG9mIE5vZGUgZXJyb25lb3VzbHkgcmV0dXJuZWQgc2lnbmVkIGludGVnZXJzIGZvclxuICAvLyB1aWQgKyBnaWQuXG4gIHJldHVybiBmdW5jdGlvbiAodGFyZ2V0KSB7XG4gICAgdmFyIHN0YXRzID0gb3JpZy5jYWxsKGZzLCB0YXJnZXQpXG4gICAgaWYgKHN0YXRzLnVpZCA8IDApIHN0YXRzLnVpZCArPSAweDEwMDAwMDAwMFxuICAgIGlmIChzdGF0cy5naWQgPCAwKSBzdGF0cy5naWQgKz0gMHgxMDAwMDAwMDBcbiAgICByZXR1cm4gc3RhdHM7XG4gIH1cbn1cblxuLy8gRU5PU1lTIG1lYW5zIHRoYXQgdGhlIGZzIGRvZXNuJ3Qgc3VwcG9ydCB0aGUgb3AuIEp1c3QgaWdub3JlXG4vLyB0aGF0LCBiZWNhdXNlIGl0IGRvZXNuJ3QgbWF0dGVyLlxuLy9cbi8vIGlmIHRoZXJlJ3Mgbm8gZ2V0dWlkLCBvciBpZiBnZXR1aWQoKSBpcyBzb21ldGhpbmcgb3RoZXJcbi8vIHRoYW4gMCwgYW5kIHRoZSBlcnJvciBpcyBFSU5WQUwgb3IgRVBFUk0sIHRoZW4ganVzdCBpZ25vcmVcbi8vIGl0LlxuLy9cbi8vIFRoaXMgc3BlY2lmaWMgY2FzZSBpcyBhIHNpbGVudCBmYWlsdXJlIGluIGNwLCBpbnN0YWxsLCB0YXIsXG4vLyBhbmQgbW9zdCBvdGhlciB1bml4IHRvb2xzIHRoYXQgbWFuYWdlIHBlcm1pc3Npb25zLlxuLy9cbi8vIFdoZW4gcnVubmluZyBhcyByb290LCBvciBpZiBvdGhlciB0eXBlcyBvZiBlcnJvcnMgYXJlXG4vLyBlbmNvdW50ZXJlZCwgdGhlbiBpdCdzIHN0cmljdC5cbmZ1bmN0aW9uIGNob3duRXJPayAoZXIpIHtcbiAgaWYgKCFlcilcbiAgICByZXR1cm4gdHJ1ZVxuXG4gIGlmIChlci5jb2RlID09PSBcIkVOT1NZU1wiKVxuICAgIHJldHVybiB0cnVlXG5cbiAgdmFyIG5vbnJvb3QgPSAhcHJvY2Vzcy5nZXR1aWQgfHwgcHJvY2Vzcy5nZXR1aWQoKSAhPT0gMFxuICBpZiAobm9ucm9vdCkge1xuICAgIGlmIChlci5jb2RlID09PSBcIkVJTlZBTFwiIHx8IGVyLmNvZGUgPT09IFwiRVBFUk1cIilcbiAgICAgIHJldHVybiB0cnVlXG4gIH1cblxuICByZXR1cm4gZmFsc2Vcbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9ncmFjZWZ1bC1mcy9wb2x5ZmlsbHMuanMiLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCJjb25zdGFudHNcIik7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gZXh0ZXJuYWwgXCJjb25zdGFudHNcIlxuLy8gbW9kdWxlIGlkID0gMTEwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBTdHJlYW0gPSByZXF1aXJlKCdzdHJlYW0nKS5TdHJlYW1cblxubW9kdWxlLmV4cG9ydHMgPSBsZWdhY3lcblxuZnVuY3Rpb24gbGVnYWN5IChmcykge1xuICByZXR1cm4ge1xuICAgIFJlYWRTdHJlYW06IFJlYWRTdHJlYW0sXG4gICAgV3JpdGVTdHJlYW06IFdyaXRlU3RyZWFtXG4gIH1cblxuICBmdW5jdGlvbiBSZWFkU3RyZWFtIChwYXRoLCBvcHRpb25zKSB7XG4gICAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIFJlYWRTdHJlYW0pKSByZXR1cm4gbmV3IFJlYWRTdHJlYW0ocGF0aCwgb3B0aW9ucyk7XG5cbiAgICBTdHJlYW0uY2FsbCh0aGlzKTtcblxuICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgIHRoaXMucGF0aCA9IHBhdGg7XG4gICAgdGhpcy5mZCA9IG51bGw7XG4gICAgdGhpcy5yZWFkYWJsZSA9IHRydWU7XG4gICAgdGhpcy5wYXVzZWQgPSBmYWxzZTtcblxuICAgIHRoaXMuZmxhZ3MgPSAncic7XG4gICAgdGhpcy5tb2RlID0gNDM4OyAvKj0wNjY2Ki9cbiAgICB0aGlzLmJ1ZmZlclNpemUgPSA2NCAqIDEwMjQ7XG5cbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICAgIC8vIE1peGluIG9wdGlvbnMgaW50byB0aGlzXG4gICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhvcHRpb25zKTtcbiAgICBmb3IgKHZhciBpbmRleCA9IDAsIGxlbmd0aCA9IGtleXMubGVuZ3RoOyBpbmRleCA8IGxlbmd0aDsgaW5kZXgrKykge1xuICAgICAgdmFyIGtleSA9IGtleXNbaW5kZXhdO1xuICAgICAgdGhpc1trZXldID0gb3B0aW9uc1trZXldO1xuICAgIH1cblxuICAgIGlmICh0aGlzLmVuY29kaW5nKSB0aGlzLnNldEVuY29kaW5nKHRoaXMuZW5jb2RpbmcpO1xuXG4gICAgaWYgKHRoaXMuc3RhcnQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgaWYgKCdudW1iZXInICE9PSB0eXBlb2YgdGhpcy5zdGFydCkge1xuICAgICAgICB0aHJvdyBUeXBlRXJyb3IoJ3N0YXJ0IG11c3QgYmUgYSBOdW1iZXInKTtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLmVuZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRoaXMuZW5kID0gSW5maW5pdHk7XG4gICAgICB9IGVsc2UgaWYgKCdudW1iZXInICE9PSB0eXBlb2YgdGhpcy5lbmQpIHtcbiAgICAgICAgdGhyb3cgVHlwZUVycm9yKCdlbmQgbXVzdCBiZSBhIE51bWJlcicpO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5zdGFydCA+IHRoaXMuZW5kKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignc3RhcnQgbXVzdCBiZSA8PSBlbmQnKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5wb3MgPSB0aGlzLnN0YXJ0O1xuICAgIH1cblxuICAgIGlmICh0aGlzLmZkICE9PSBudWxsKSB7XG4gICAgICBwcm9jZXNzLm5leHRUaWNrKGZ1bmN0aW9uKCkge1xuICAgICAgICBzZWxmLl9yZWFkKCk7XG4gICAgICB9KTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBmcy5vcGVuKHRoaXMucGF0aCwgdGhpcy5mbGFncywgdGhpcy5tb2RlLCBmdW5jdGlvbiAoZXJyLCBmZCkge1xuICAgICAgaWYgKGVycikge1xuICAgICAgICBzZWxmLmVtaXQoJ2Vycm9yJywgZXJyKTtcbiAgICAgICAgc2VsZi5yZWFkYWJsZSA9IGZhbHNlO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHNlbGYuZmQgPSBmZDtcbiAgICAgIHNlbGYuZW1pdCgnb3BlbicsIGZkKTtcbiAgICAgIHNlbGYuX3JlYWQoKTtcbiAgICB9KVxuICB9XG5cbiAgZnVuY3Rpb24gV3JpdGVTdHJlYW0gKHBhdGgsIG9wdGlvbnMpIHtcbiAgICBpZiAoISh0aGlzIGluc3RhbmNlb2YgV3JpdGVTdHJlYW0pKSByZXR1cm4gbmV3IFdyaXRlU3RyZWFtKHBhdGgsIG9wdGlvbnMpO1xuXG4gICAgU3RyZWFtLmNhbGwodGhpcyk7XG5cbiAgICB0aGlzLnBhdGggPSBwYXRoO1xuICAgIHRoaXMuZmQgPSBudWxsO1xuICAgIHRoaXMud3JpdGFibGUgPSB0cnVlO1xuXG4gICAgdGhpcy5mbGFncyA9ICd3JztcbiAgICB0aGlzLmVuY29kaW5nID0gJ2JpbmFyeSc7XG4gICAgdGhpcy5tb2RlID0gNDM4OyAvKj0wNjY2Ki9cbiAgICB0aGlzLmJ5dGVzV3JpdHRlbiA9IDA7XG5cbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICAgIC8vIE1peGluIG9wdGlvbnMgaW50byB0aGlzXG4gICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhvcHRpb25zKTtcbiAgICBmb3IgKHZhciBpbmRleCA9IDAsIGxlbmd0aCA9IGtleXMubGVuZ3RoOyBpbmRleCA8IGxlbmd0aDsgaW5kZXgrKykge1xuICAgICAgdmFyIGtleSA9IGtleXNbaW5kZXhdO1xuICAgICAgdGhpc1trZXldID0gb3B0aW9uc1trZXldO1xuICAgIH1cblxuICAgIGlmICh0aGlzLnN0YXJ0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGlmICgnbnVtYmVyJyAhPT0gdHlwZW9mIHRoaXMuc3RhcnQpIHtcbiAgICAgICAgdGhyb3cgVHlwZUVycm9yKCdzdGFydCBtdXN0IGJlIGEgTnVtYmVyJyk7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5zdGFydCA8IDApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdzdGFydCBtdXN0IGJlID49IHplcm8nKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5wb3MgPSB0aGlzLnN0YXJ0O1xuICAgIH1cblxuICAgIHRoaXMuYnVzeSA9IGZhbHNlO1xuICAgIHRoaXMuX3F1ZXVlID0gW107XG5cbiAgICBpZiAodGhpcy5mZCA9PT0gbnVsbCkge1xuICAgICAgdGhpcy5fb3BlbiA9IGZzLm9wZW47XG4gICAgICB0aGlzLl9xdWV1ZS5wdXNoKFt0aGlzLl9vcGVuLCB0aGlzLnBhdGgsIHRoaXMuZmxhZ3MsIHRoaXMubW9kZSwgdW5kZWZpbmVkXSk7XG4gICAgICB0aGlzLmZsdXNoKCk7XG4gICAgfVxuICB9XG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvZ3JhY2VmdWwtZnMvbGVnYWN5LXN0cmVhbXMuanMiLCJjb25zdCB1ID0gcmVxdWlyZSgndW5pdmVyc2FsaWZ5JykuZnJvbUNhbGxiYWNrXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgY29weTogdShyZXF1aXJlKCcuL2NvcHknKSlcbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9lbGVjdHJvbi11cGRhdGVyL25vZGVfbW9kdWxlcy9mcy1leHRyYS9saWIvY29weS9pbmRleC5qcyIsIid1c2Ugc3RyaWN0J1xuXG5jb25zdCBmcyA9IHJlcXVpcmUoJ2dyYWNlZnVsLWZzJylcbmNvbnN0IHBhdGggPSByZXF1aXJlKCdwYXRoJylcbmNvbnN0IGludmFsaWRXaW4zMlBhdGggPSByZXF1aXJlKCcuL3dpbjMyJykuaW52YWxpZFdpbjMyUGF0aFxuXG5jb25zdCBvNzc3ID0gcGFyc2VJbnQoJzA3NzcnLCA4KVxuXG5mdW5jdGlvbiBta2RpcnMgKHAsIG9wdHMsIGNhbGxiYWNrLCBtYWRlKSB7XG4gIGlmICh0eXBlb2Ygb3B0cyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGNhbGxiYWNrID0gb3B0c1xuICAgIG9wdHMgPSB7fVxuICB9IGVsc2UgaWYgKCFvcHRzIHx8IHR5cGVvZiBvcHRzICE9PSAnb2JqZWN0Jykge1xuICAgIG9wdHMgPSB7IG1vZGU6IG9wdHMgfVxuICB9XG5cbiAgaWYgKHByb2Nlc3MucGxhdGZvcm0gPT09ICd3aW4zMicgJiYgaW52YWxpZFdpbjMyUGF0aChwKSkge1xuICAgIGNvbnN0IGVyckludmFsID0gbmV3IEVycm9yKHAgKyAnIGNvbnRhaW5zIGludmFsaWQgV0lOMzIgcGF0aCBjaGFyYWN0ZXJzLicpXG4gICAgZXJySW52YWwuY29kZSA9ICdFSU5WQUwnXG4gICAgcmV0dXJuIGNhbGxiYWNrKGVyckludmFsKVxuICB9XG5cbiAgbGV0IG1vZGUgPSBvcHRzLm1vZGVcbiAgY29uc3QgeGZzID0gb3B0cy5mcyB8fCBmc1xuXG4gIGlmIChtb2RlID09PSB1bmRlZmluZWQpIHtcbiAgICBtb2RlID0gbzc3NyAmICh+cHJvY2Vzcy51bWFzaygpKVxuICB9XG4gIGlmICghbWFkZSkgbWFkZSA9IG51bGxcblxuICBjYWxsYmFjayA9IGNhbGxiYWNrIHx8IGZ1bmN0aW9uICgpIHt9XG4gIHAgPSBwYXRoLnJlc29sdmUocClcblxuICB4ZnMubWtkaXIocCwgbW9kZSwgZXIgPT4ge1xuICAgIGlmICghZXIpIHtcbiAgICAgIG1hZGUgPSBtYWRlIHx8IHBcbiAgICAgIHJldHVybiBjYWxsYmFjayhudWxsLCBtYWRlKVxuICAgIH1cbiAgICBzd2l0Y2ggKGVyLmNvZGUpIHtcbiAgICAgIGNhc2UgJ0VOT0VOVCc6XG4gICAgICAgIGlmIChwYXRoLmRpcm5hbWUocCkgPT09IHApIHJldHVybiBjYWxsYmFjayhlcilcbiAgICAgICAgbWtkaXJzKHBhdGguZGlybmFtZShwKSwgb3B0cywgKGVyLCBtYWRlKSA9PiB7XG4gICAgICAgICAgaWYgKGVyKSBjYWxsYmFjayhlciwgbWFkZSlcbiAgICAgICAgICBlbHNlIG1rZGlycyhwLCBvcHRzLCBjYWxsYmFjaywgbWFkZSlcbiAgICAgICAgfSlcbiAgICAgICAgYnJlYWtcblxuICAgICAgLy8gSW4gdGhlIGNhc2Ugb2YgYW55IG90aGVyIGVycm9yLCBqdXN0IHNlZSBpZiB0aGVyZSdzIGEgZGlyXG4gICAgICAvLyB0aGVyZSBhbHJlYWR5LiAgSWYgc28sIHRoZW4gaG9vcmF5ISAgSWYgbm90LCB0aGVuIHNvbWV0aGluZ1xuICAgICAgLy8gaXMgYm9ya2VkLlxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgeGZzLnN0YXQocCwgKGVyMiwgc3RhdCkgPT4ge1xuICAgICAgICAgIC8vIGlmIHRoZSBzdGF0IGZhaWxzLCB0aGVuIHRoYXQncyBzdXBlciB3ZWlyZC5cbiAgICAgICAgICAvLyBsZXQgdGhlIG9yaWdpbmFsIGVycm9yIGJlIHRoZSBmYWlsdXJlIHJlYXNvbi5cbiAgICAgICAgICBpZiAoZXIyIHx8ICFzdGF0LmlzRGlyZWN0b3J5KCkpIGNhbGxiYWNrKGVyLCBtYWRlKVxuICAgICAgICAgIGVsc2UgY2FsbGJhY2sobnVsbCwgbWFkZSlcbiAgICAgICAgfSlcbiAgICAgICAgYnJlYWtcbiAgICB9XG4gIH0pXG59XG5cbm1vZHVsZS5leHBvcnRzID0gbWtkaXJzXG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvZWxlY3Ryb24tdXBkYXRlci9ub2RlX21vZHVsZXMvZnMtZXh0cmEvbGliL21rZGlycy9ta2RpcnMuanMiLCIndXNlIHN0cmljdCdcblxuY29uc3QgZnMgPSByZXF1aXJlKCdncmFjZWZ1bC1mcycpXG5jb25zdCBwYXRoID0gcmVxdWlyZSgncGF0aCcpXG5jb25zdCBpbnZhbGlkV2luMzJQYXRoID0gcmVxdWlyZSgnLi93aW4zMicpLmludmFsaWRXaW4zMlBhdGhcblxuY29uc3Qgbzc3NyA9IHBhcnNlSW50KCcwNzc3JywgOClcblxuZnVuY3Rpb24gbWtkaXJzU3luYyAocCwgb3B0cywgbWFkZSkge1xuICBpZiAoIW9wdHMgfHwgdHlwZW9mIG9wdHMgIT09ICdvYmplY3QnKSB7XG4gICAgb3B0cyA9IHsgbW9kZTogb3B0cyB9XG4gIH1cblxuICBsZXQgbW9kZSA9IG9wdHMubW9kZVxuICBjb25zdCB4ZnMgPSBvcHRzLmZzIHx8IGZzXG5cbiAgaWYgKHByb2Nlc3MucGxhdGZvcm0gPT09ICd3aW4zMicgJiYgaW52YWxpZFdpbjMyUGF0aChwKSkge1xuICAgIGNvbnN0IGVyckludmFsID0gbmV3IEVycm9yKHAgKyAnIGNvbnRhaW5zIGludmFsaWQgV0lOMzIgcGF0aCBjaGFyYWN0ZXJzLicpXG4gICAgZXJySW52YWwuY29kZSA9ICdFSU5WQUwnXG4gICAgdGhyb3cgZXJySW52YWxcbiAgfVxuXG4gIGlmIChtb2RlID09PSB1bmRlZmluZWQpIHtcbiAgICBtb2RlID0gbzc3NyAmICh+cHJvY2Vzcy51bWFzaygpKVxuICB9XG4gIGlmICghbWFkZSkgbWFkZSA9IG51bGxcblxuICBwID0gcGF0aC5yZXNvbHZlKHApXG5cbiAgdHJ5IHtcbiAgICB4ZnMubWtkaXJTeW5jKHAsIG1vZGUpXG4gICAgbWFkZSA9IG1hZGUgfHwgcFxuICB9IGNhdGNoIChlcnIwKSB7XG4gICAgc3dpdGNoIChlcnIwLmNvZGUpIHtcbiAgICAgIGNhc2UgJ0VOT0VOVCc6XG4gICAgICAgIGlmIChwYXRoLmRpcm5hbWUocCkgPT09IHApIHRocm93IGVycjBcbiAgICAgICAgbWFkZSA9IG1rZGlyc1N5bmMocGF0aC5kaXJuYW1lKHApLCBvcHRzLCBtYWRlKVxuICAgICAgICBta2RpcnNTeW5jKHAsIG9wdHMsIG1hZGUpXG4gICAgICAgIGJyZWFrXG5cbiAgICAgIC8vIEluIHRoZSBjYXNlIG9mIGFueSBvdGhlciBlcnJvciwganVzdCBzZWUgaWYgdGhlcmUncyBhIGRpclxuICAgICAgLy8gdGhlcmUgYWxyZWFkeS4gIElmIHNvLCB0aGVuIGhvb3JheSEgIElmIG5vdCwgdGhlbiBzb21ldGhpbmdcbiAgICAgIC8vIGlzIGJvcmtlZC5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGxldCBzdGF0XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgc3RhdCA9IHhmcy5zdGF0U3luYyhwKVxuICAgICAgICB9IGNhdGNoIChlcnIxKSB7XG4gICAgICAgICAgdGhyb3cgZXJyMFxuICAgICAgICB9XG4gICAgICAgIGlmICghc3RhdC5pc0RpcmVjdG9yeSgpKSB0aHJvdyBlcnIwXG4gICAgICAgIGJyZWFrXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG1hZGVcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBta2RpcnNTeW5jXG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvZWxlY3Ryb24tdXBkYXRlci9ub2RlX21vZHVsZXMvZnMtZXh0cmEvbGliL21rZGlycy9ta2RpcnMtc3luYy5qcyIsIid1c2Ugc3RyaWN0J1xuXG5jb25zdCBmcyA9IHJlcXVpcmUoJ2dyYWNlZnVsLWZzJylcbmNvbnN0IHBhdGggPSByZXF1aXJlKCdwYXRoJylcbmNvbnN0IG1rZGlycFN5bmMgPSByZXF1aXJlKCcuLi9ta2RpcnMnKS5ta2RpcnNTeW5jXG5jb25zdCB1dGltZXNTeW5jID0gcmVxdWlyZSgnLi4vdXRpbC91dGltZXMuanMnKS51dGltZXNNaWxsaXNTeW5jXG5cbmNvbnN0IG5vdEV4aXN0ID0gU3ltYm9sKCdub3RFeGlzdCcpXG5jb25zdCBleGlzdHNSZWcgPSBTeW1ib2woJ2V4aXN0c1JlZycpXG5cbmZ1bmN0aW9uIGNvcHlTeW5jIChzcmMsIGRlc3QsIG9wdHMpIHtcbiAgaWYgKHR5cGVvZiBvcHRzID09PSAnZnVuY3Rpb24nKSB7XG4gICAgb3B0cyA9IHtmaWx0ZXI6IG9wdHN9XG4gIH1cblxuICBvcHRzID0gb3B0cyB8fCB7fVxuICBvcHRzLmNsb2JiZXIgPSAnY2xvYmJlcicgaW4gb3B0cyA/ICEhb3B0cy5jbG9iYmVyIDogdHJ1ZSAvLyBkZWZhdWx0IHRvIHRydWUgZm9yIG5vd1xuICBvcHRzLm92ZXJ3cml0ZSA9ICdvdmVyd3JpdGUnIGluIG9wdHMgPyAhIW9wdHMub3ZlcndyaXRlIDogb3B0cy5jbG9iYmVyIC8vIG92ZXJ3cml0ZSBmYWxscyBiYWNrIHRvIGNsb2JiZXJcblxuICAvLyBXYXJuIGFib3V0IHVzaW5nIHByZXNlcnZlVGltZXN0YW1wcyBvbiAzMi1iaXQgbm9kZVxuICBpZiAob3B0cy5wcmVzZXJ2ZVRpbWVzdGFtcHMgJiYgcHJvY2Vzcy5hcmNoID09PSAnaWEzMicpIHtcbiAgICBjb25zb2xlLndhcm4oYGZzLWV4dHJhOiBVc2luZyB0aGUgcHJlc2VydmVUaW1lc3RhbXBzIG9wdGlvbiBpbiAzMi1iaXQgbm9kZSBpcyBub3QgcmVjb21tZW5kZWQ7XFxuXG4gICAgc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9qcHJpY2hhcmRzb24vbm9kZS1mcy1leHRyYS9pc3N1ZXMvMjY5YClcbiAgfVxuXG4gIHNyYyA9IHBhdGgucmVzb2x2ZShzcmMpXG4gIGRlc3QgPSBwYXRoLnJlc29sdmUoZGVzdClcblxuICAvLyBkb24ndCBhbGxvdyBzcmMgYW5kIGRlc3QgdG8gYmUgdGhlIHNhbWVcbiAgaWYgKHNyYyA9PT0gZGVzdCkgdGhyb3cgbmV3IEVycm9yKCdTb3VyY2UgYW5kIGRlc3RpbmF0aW9uIG11c3Qgbm90IGJlIHRoZSBzYW1lLicpXG5cbiAgaWYgKG9wdHMuZmlsdGVyICYmICFvcHRzLmZpbHRlcihzcmMsIGRlc3QpKSByZXR1cm5cblxuICBjb25zdCBkZXN0UGFyZW50ID0gcGF0aC5kaXJuYW1lKGRlc3QpXG4gIGlmICghZnMuZXhpc3RzU3luYyhkZXN0UGFyZW50KSkgbWtkaXJwU3luYyhkZXN0UGFyZW50KVxuICByZXR1cm4gc3RhcnRDb3B5KHNyYywgZGVzdCwgb3B0cylcbn1cblxuZnVuY3Rpb24gc3RhcnRDb3B5IChzcmMsIGRlc3QsIG9wdHMpIHtcbiAgaWYgKG9wdHMuZmlsdGVyICYmICFvcHRzLmZpbHRlcihzcmMsIGRlc3QpKSByZXR1cm5cbiAgcmV0dXJuIGdldFN0YXRzKHNyYywgZGVzdCwgb3B0cylcbn1cblxuZnVuY3Rpb24gZ2V0U3RhdHMgKHNyYywgZGVzdCwgb3B0cykge1xuICBjb25zdCBzdGF0U3luYyA9IG9wdHMuZGVyZWZlcmVuY2UgPyBmcy5zdGF0U3luYyA6IGZzLmxzdGF0U3luY1xuICBjb25zdCBzdCA9IHN0YXRTeW5jKHNyYylcblxuICBpZiAoc3QuaXNEaXJlY3RvcnkoKSkgcmV0dXJuIG9uRGlyKHN0LCBzcmMsIGRlc3QsIG9wdHMpXG4gIGVsc2UgaWYgKHN0LmlzRmlsZSgpIHx8XG4gICAgICAgICAgIHN0LmlzQ2hhcmFjdGVyRGV2aWNlKCkgfHxcbiAgICAgICAgICAgc3QuaXNCbG9ja0RldmljZSgpKSByZXR1cm4gb25GaWxlKHN0LCBzcmMsIGRlc3QsIG9wdHMpXG4gIGVsc2UgaWYgKHN0LmlzU3ltYm9saWNMaW5rKCkpIHJldHVybiBvbkxpbmsoc3JjLCBkZXN0LCBvcHRzKVxufVxuXG5mdW5jdGlvbiBvbkZpbGUgKHNyY1N0YXQsIHNyYywgZGVzdCwgb3B0cykge1xuICBjb25zdCByZXNvbHZlZFBhdGggPSBjaGVja0Rlc3QoZGVzdClcbiAgaWYgKHJlc29sdmVkUGF0aCA9PT0gbm90RXhpc3QpIHtcbiAgICByZXR1cm4gY29weUZpbGUoc3JjU3RhdCwgc3JjLCBkZXN0LCBvcHRzKVxuICB9IGVsc2UgaWYgKHJlc29sdmVkUGF0aCA9PT0gZXhpc3RzUmVnKSB7XG4gICAgcmV0dXJuIG1heUNvcHlGaWxlKHNyY1N0YXQsIHNyYywgZGVzdCwgb3B0cylcbiAgfSBlbHNlIHtcbiAgICBpZiAoc3JjID09PSByZXNvbHZlZFBhdGgpIHJldHVyblxuICAgIHJldHVybiBtYXlDb3B5RmlsZShzcmNTdGF0LCBzcmMsIGRlc3QsIG9wdHMpXG4gIH1cbn1cblxuZnVuY3Rpb24gbWF5Q29weUZpbGUgKHNyY1N0YXQsIHNyYywgZGVzdCwgb3B0cykge1xuICBpZiAob3B0cy5vdmVyd3JpdGUpIHtcbiAgICBmcy51bmxpbmtTeW5jKGRlc3QpXG4gICAgcmV0dXJuIGNvcHlGaWxlKHNyY1N0YXQsIHNyYywgZGVzdCwgb3B0cylcbiAgfSBlbHNlIGlmIChvcHRzLmVycm9yT25FeGlzdCkge1xuICAgIHRocm93IG5ldyBFcnJvcihgJyR7ZGVzdH0nIGFscmVhZHkgZXhpc3RzYClcbiAgfVxufVxuXG5mdW5jdGlvbiBjb3B5RmlsZSAoc3JjU3RhdCwgc3JjLCBkZXN0LCBvcHRzKSB7XG4gIGlmICh0eXBlb2YgZnMuY29weUZpbGVTeW5jID09PSAnZnVuY3Rpb24nKSB7XG4gICAgZnMuY29weUZpbGVTeW5jKHNyYywgZGVzdClcbiAgICBmcy5jaG1vZFN5bmMoZGVzdCwgc3JjU3RhdC5tb2RlKVxuICAgIGlmIChvcHRzLnByZXNlcnZlVGltZXN0YW1wcykge1xuICAgICAgcmV0dXJuIHV0aW1lc1N5bmMoZGVzdCwgc3JjU3RhdC5hdGltZSwgc3JjU3RhdC5tdGltZSlcbiAgICB9XG4gICAgcmV0dXJuXG4gIH1cbiAgcmV0dXJuIGNvcHlGaWxlRmFsbGJhY2soc3JjU3RhdCwgc3JjLCBkZXN0LCBvcHRzKVxufVxuXG5mdW5jdGlvbiBjb3B5RmlsZUZhbGxiYWNrIChzcmNTdGF0LCBzcmMsIGRlc3QsIG9wdHMpIHtcbiAgY29uc3QgQlVGX0xFTkdUSCA9IDY0ICogMTAyNFxuICBjb25zdCBfYnVmZiA9IHJlcXVpcmUoJy4uL3V0aWwvYnVmZmVyJykoQlVGX0xFTkdUSClcblxuICBjb25zdCBmZHIgPSBmcy5vcGVuU3luYyhzcmMsICdyJylcbiAgY29uc3QgZmR3ID0gZnMub3BlblN5bmMoZGVzdCwgJ3cnLCBzcmNTdGF0Lm1vZGUpXG4gIGxldCBieXRlc1JlYWQgPSAxXG4gIGxldCBwb3MgPSAwXG5cbiAgd2hpbGUgKGJ5dGVzUmVhZCA+IDApIHtcbiAgICBieXRlc1JlYWQgPSBmcy5yZWFkU3luYyhmZHIsIF9idWZmLCAwLCBCVUZfTEVOR1RILCBwb3MpXG4gICAgZnMud3JpdGVTeW5jKGZkdywgX2J1ZmYsIDAsIGJ5dGVzUmVhZClcbiAgICBwb3MgKz0gYnl0ZXNSZWFkXG4gIH1cblxuICBpZiAob3B0cy5wcmVzZXJ2ZVRpbWVzdGFtcHMpIGZzLmZ1dGltZXNTeW5jKGZkdywgc3JjU3RhdC5hdGltZSwgc3JjU3RhdC5tdGltZSlcblxuICBmcy5jbG9zZVN5bmMoZmRyKVxuICBmcy5jbG9zZVN5bmMoZmR3KVxufVxuXG5mdW5jdGlvbiBvbkRpciAoc3JjU3RhdCwgc3JjLCBkZXN0LCBvcHRzKSB7XG4gIGNvbnN0IHJlc29sdmVkUGF0aCA9IGNoZWNrRGVzdChkZXN0KVxuICBpZiAocmVzb2x2ZWRQYXRoID09PSBub3RFeGlzdCkge1xuICAgIGlmIChpc1NyY1N1YmRpcihzcmMsIGRlc3QpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYENhbm5vdCBjb3B5ICcke3NyY30nIHRvIGEgc3ViZGlyZWN0b3J5IG9mIGl0c2VsZiwgJyR7ZGVzdH0nLmApXG4gICAgfVxuICAgIHJldHVybiBta0RpckFuZENvcHkoc3JjU3RhdCwgc3JjLCBkZXN0LCBvcHRzKVxuICB9IGVsc2UgaWYgKHJlc29sdmVkUGF0aCA9PT0gZXhpc3RzUmVnKSB7XG4gICAgaWYgKGlzU3JjU3ViZGlyKHNyYywgZGVzdCkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgQ2Fubm90IGNvcHkgJyR7c3JjfScgdG8gYSBzdWJkaXJlY3Rvcnkgb2YgaXRzZWxmLCAnJHtkZXN0fScuYClcbiAgICB9XG4gICAgcmV0dXJuIG1heUNvcHlEaXIoc3JjLCBkZXN0LCBvcHRzKVxuICB9IGVsc2Uge1xuICAgIGlmIChzcmMgPT09IHJlc29sdmVkUGF0aCkgcmV0dXJuXG4gICAgcmV0dXJuIGNvcHlEaXIoc3JjLCBkZXN0LCBvcHRzKVxuICB9XG59XG5cbmZ1bmN0aW9uIG1heUNvcHlEaXIgKHNyYywgZGVzdCwgb3B0cykge1xuICBpZiAoIWZzLnN0YXRTeW5jKGRlc3QpLmlzRGlyZWN0b3J5KCkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYENhbm5vdCBvdmVyd3JpdGUgbm9uLWRpcmVjdG9yeSAnJHtkZXN0fScgd2l0aCBkaXJlY3RvcnkgJyR7c3JjfScuYClcbiAgfVxuICByZXR1cm4gY29weURpcihzcmMsIGRlc3QsIG9wdHMpXG59XG5cbmZ1bmN0aW9uIG1rRGlyQW5kQ29weSAoc3JjU3RhdCwgc3JjLCBkZXN0LCBvcHRzKSB7XG4gIGZzLm1rZGlyU3luYyhkZXN0LCBzcmNTdGF0Lm1vZGUpXG4gIGZzLmNobW9kU3luYyhkZXN0LCBzcmNTdGF0Lm1vZGUpXG4gIHJldHVybiBjb3B5RGlyKHNyYywgZGVzdCwgb3B0cylcbn1cblxuZnVuY3Rpb24gY29weURpciAoc3JjLCBkZXN0LCBvcHRzKSB7XG4gIGZzLnJlYWRkaXJTeW5jKHNyYykuZm9yRWFjaChpdGVtID0+IHtcbiAgICBzdGFydENvcHkocGF0aC5qb2luKHNyYywgaXRlbSksIHBhdGguam9pbihkZXN0LCBpdGVtKSwgb3B0cylcbiAgfSlcbn1cblxuZnVuY3Rpb24gb25MaW5rIChzcmMsIGRlc3QsIG9wdHMpIHtcbiAgbGV0IHJlc29sdmVkU3JjUGF0aCA9IGZzLnJlYWRsaW5rU3luYyhzcmMpXG5cbiAgaWYgKG9wdHMuZGVyZWZlcmVuY2UpIHtcbiAgICByZXNvbHZlZFNyY1BhdGggPSBwYXRoLnJlc29sdmUocHJvY2Vzcy5jd2QoKSwgcmVzb2x2ZWRTcmNQYXRoKVxuICB9XG5cbiAgbGV0IHJlc29sdmVkRGVzdFBhdGggPSBjaGVja0Rlc3QoZGVzdClcbiAgaWYgKHJlc29sdmVkRGVzdFBhdGggPT09IG5vdEV4aXN0IHx8IHJlc29sdmVkRGVzdFBhdGggPT09IGV4aXN0c1JlZykge1xuICAgIC8vIGlmIGRlc3QgYWxyZWFkeSBleGlzdHMsIGZzIHRocm93cyBlcnJvciBhbnl3YXksXG4gICAgLy8gc28gbm8gbmVlZCB0byBndWFyZCBhZ2FpbnN0IGl0IGhlcmUuXG4gICAgcmV0dXJuIGZzLnN5bWxpbmtTeW5jKHJlc29sdmVkU3JjUGF0aCwgZGVzdClcbiAgfSBlbHNlIHtcbiAgICBpZiAob3B0cy5kZXJlZmVyZW5jZSkge1xuICAgICAgcmVzb2x2ZWREZXN0UGF0aCA9IHBhdGgucmVzb2x2ZShwcm9jZXNzLmN3ZCgpLCByZXNvbHZlZERlc3RQYXRoKVxuICAgIH1cbiAgICBpZiAocmVzb2x2ZWREZXN0UGF0aCA9PT0gcmVzb2x2ZWRTcmNQYXRoKSByZXR1cm5cblxuICAgIC8vIHByZXZlbnQgY29weSBpZiBzcmMgaXMgYSBzdWJkaXIgb2YgZGVzdCBzaW5jZSB1bmxpbmtpbmdcbiAgICAvLyBkZXN0IGluIHRoaXMgY2FzZSB3b3VsZCByZXN1bHQgaW4gcmVtb3Zpbmcgc3JjIGNvbnRlbnRzXG4gICAgLy8gYW5kIHRoZXJlZm9yZSBhIGJyb2tlbiBzeW1saW5rIHdvdWxkIGJlIGNyZWF0ZWQuXG4gICAgaWYgKGZzLnN0YXRTeW5jKGRlc3QpLmlzRGlyZWN0b3J5KCkgJiYgaXNTcmNTdWJkaXIocmVzb2x2ZWREZXN0UGF0aCwgcmVzb2x2ZWRTcmNQYXRoKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBDYW5ub3Qgb3ZlcndyaXRlICcke3Jlc29sdmVkRGVzdFBhdGh9JyB3aXRoICcke3Jlc29sdmVkU3JjUGF0aH0nLmApXG4gICAgfVxuICAgIHJldHVybiBjb3B5TGluayhyZXNvbHZlZFNyY1BhdGgsIGRlc3QpXG4gIH1cbn1cblxuZnVuY3Rpb24gY29weUxpbmsgKHJlc29sdmVkU3JjUGF0aCwgZGVzdCkge1xuICBmcy51bmxpbmtTeW5jKGRlc3QpXG4gIHJldHVybiBmcy5zeW1saW5rU3luYyhyZXNvbHZlZFNyY1BhdGgsIGRlc3QpXG59XG5cbi8vIGNoZWNrIGlmIGRlc3QgZXhpc3RzIGFuZC9vciBpcyBhIHN5bWxpbmtcbmZ1bmN0aW9uIGNoZWNrRGVzdCAoZGVzdCkge1xuICBsZXQgcmVzb2x2ZWRQYXRoXG4gIHRyeSB7XG4gICAgcmVzb2x2ZWRQYXRoID0gZnMucmVhZGxpbmtTeW5jKGRlc3QpXG4gIH0gY2F0Y2ggKGVycikge1xuICAgIGlmIChlcnIuY29kZSA9PT0gJ0VOT0VOVCcpIHJldHVybiBub3RFeGlzdFxuXG4gICAgLy8gZGVzdCBleGlzdHMgYW5kIGlzIGEgcmVndWxhciBmaWxlIG9yIGRpcmVjdG9yeSwgV2luZG93cyBtYXkgdGhyb3cgVU5LTk9XTiBlcnJvclxuICAgIGlmIChlcnIuY29kZSA9PT0gJ0VJTlZBTCcgfHwgZXJyLmNvZGUgPT09ICdVTktOT1dOJykgcmV0dXJuIGV4aXN0c1JlZ1xuXG4gICAgdGhyb3cgZXJyXG4gIH1cbiAgcmV0dXJuIHJlc29sdmVkUGF0aCAvLyBkZXN0IGV4aXN0cyBhbmQgaXMgYSBzeW1saW5rXG59XG5cbi8vIHJldHVybiB0cnVlIGlmIGRlc3QgaXMgYSBzdWJkaXIgb2Ygc3JjLCBvdGhlcndpc2UgZmFsc2UuXG4vLyBleHRyYWN0IGRlc3QgYmFzZSBkaXIgYW5kIGNoZWNrIGlmIHRoYXQgaXMgdGhlIHNhbWUgYXMgc3JjIGJhc2VuYW1lXG5mdW5jdGlvbiBpc1NyY1N1YmRpciAoc3JjLCBkZXN0KSB7XG4gIGNvbnN0IGJhc2VEaXIgPSBkZXN0LnNwbGl0KHBhdGguZGlybmFtZShzcmMpICsgcGF0aC5zZXApWzFdXG4gIGlmIChiYXNlRGlyKSB7XG4gICAgY29uc3QgZGVzdEJhc2VuYW1lID0gYmFzZURpci5zcGxpdChwYXRoLnNlcClbMF1cbiAgICBpZiAoZGVzdEJhc2VuYW1lKSB7XG4gICAgICByZXR1cm4gc3JjICE9PSBkZXN0ICYmIGRlc3QuaW5kZXhPZihzcmMpID4gLTEgJiYgZGVzdEJhc2VuYW1lID09PSBwYXRoLmJhc2VuYW1lKHNyYylcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cbiAgcmV0dXJuIGZhbHNlXG59XG5cbm1vZHVsZS5leHBvcnRzID0gY29weVN5bmNcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9lbGVjdHJvbi11cGRhdGVyL25vZGVfbW9kdWxlcy9mcy1leHRyYS9saWIvY29weS1zeW5jL2NvcHktc3luYy5qcyIsIid1c2Ugc3RyaWN0J1xuXG5jb25zdCBmcyA9IHJlcXVpcmUoJ2dyYWNlZnVsLWZzJylcbmNvbnN0IHBhdGggPSByZXF1aXJlKCdwYXRoJylcbmNvbnN0IGFzc2VydCA9IHJlcXVpcmUoJ2Fzc2VydCcpXG5cbmNvbnN0IGlzV2luZG93cyA9IChwcm9jZXNzLnBsYXRmb3JtID09PSAnd2luMzInKVxuXG5mdW5jdGlvbiBkZWZhdWx0cyAob3B0aW9ucykge1xuICBjb25zdCBtZXRob2RzID0gW1xuICAgICd1bmxpbmsnLFxuICAgICdjaG1vZCcsXG4gICAgJ3N0YXQnLFxuICAgICdsc3RhdCcsXG4gICAgJ3JtZGlyJyxcbiAgICAncmVhZGRpcidcbiAgXVxuICBtZXRob2RzLmZvckVhY2gobSA9PiB7XG4gICAgb3B0aW9uc1ttXSA9IG9wdGlvbnNbbV0gfHwgZnNbbV1cbiAgICBtID0gbSArICdTeW5jJ1xuICAgIG9wdGlvbnNbbV0gPSBvcHRpb25zW21dIHx8IGZzW21dXG4gIH0pXG5cbiAgb3B0aW9ucy5tYXhCdXN5VHJpZXMgPSBvcHRpb25zLm1heEJ1c3lUcmllcyB8fCAzXG59XG5cbmZ1bmN0aW9uIHJpbXJhZiAocCwgb3B0aW9ucywgY2IpIHtcbiAgbGV0IGJ1c3lUcmllcyA9IDBcblxuICBpZiAodHlwZW9mIG9wdGlvbnMgPT09ICdmdW5jdGlvbicpIHtcbiAgICBjYiA9IG9wdGlvbnNcbiAgICBvcHRpb25zID0ge31cbiAgfVxuXG4gIGFzc2VydChwLCAncmltcmFmOiBtaXNzaW5nIHBhdGgnKVxuICBhc3NlcnQuZXF1YWwodHlwZW9mIHAsICdzdHJpbmcnLCAncmltcmFmOiBwYXRoIHNob3VsZCBiZSBhIHN0cmluZycpXG4gIGFzc2VydC5lcXVhbCh0eXBlb2YgY2IsICdmdW5jdGlvbicsICdyaW1yYWY6IGNhbGxiYWNrIGZ1bmN0aW9uIHJlcXVpcmVkJylcbiAgYXNzZXJ0KG9wdGlvbnMsICdyaW1yYWY6IGludmFsaWQgb3B0aW9ucyBhcmd1bWVudCBwcm92aWRlZCcpXG4gIGFzc2VydC5lcXVhbCh0eXBlb2Ygb3B0aW9ucywgJ29iamVjdCcsICdyaW1yYWY6IG9wdGlvbnMgc2hvdWxkIGJlIG9iamVjdCcpXG5cbiAgZGVmYXVsdHMob3B0aW9ucylcblxuICByaW1yYWZfKHAsIG9wdGlvbnMsIGZ1bmN0aW9uIENCIChlcikge1xuICAgIGlmIChlcikge1xuICAgICAgaWYgKChlci5jb2RlID09PSAnRUJVU1knIHx8IGVyLmNvZGUgPT09ICdFTk9URU1QVFknIHx8IGVyLmNvZGUgPT09ICdFUEVSTScpICYmXG4gICAgICAgICAgYnVzeVRyaWVzIDwgb3B0aW9ucy5tYXhCdXN5VHJpZXMpIHtcbiAgICAgICAgYnVzeVRyaWVzKytcbiAgICAgICAgbGV0IHRpbWUgPSBidXN5VHJpZXMgKiAxMDBcbiAgICAgICAgLy8gdHJ5IGFnYWluLCB3aXRoIHRoZSBzYW1lIGV4YWN0IGNhbGxiYWNrIGFzIHRoaXMgb25lLlxuICAgICAgICByZXR1cm4gc2V0VGltZW91dCgoKSA9PiByaW1yYWZfKHAsIG9wdGlvbnMsIENCKSwgdGltZSlcbiAgICAgIH1cblxuICAgICAgLy8gYWxyZWFkeSBnb25lXG4gICAgICBpZiAoZXIuY29kZSA9PT0gJ0VOT0VOVCcpIGVyID0gbnVsbFxuICAgIH1cblxuICAgIGNiKGVyKVxuICB9KVxufVxuXG4vLyBUd28gcG9zc2libGUgc3RyYXRlZ2llcy5cbi8vIDEuIEFzc3VtZSBpdCdzIGEgZmlsZS4gIHVubGluayBpdCwgdGhlbiBkbyB0aGUgZGlyIHN0dWZmIG9uIEVQRVJNIG9yIEVJU0RJUlxuLy8gMi4gQXNzdW1lIGl0J3MgYSBkaXJlY3RvcnkuICByZWFkZGlyLCB0aGVuIGRvIHRoZSBmaWxlIHN0dWZmIG9uIEVOT1RESVJcbi8vXG4vLyBCb3RoIHJlc3VsdCBpbiBhbiBleHRyYSBzeXNjYWxsIHdoZW4geW91IGd1ZXNzIHdyb25nLiAgSG93ZXZlciwgdGhlcmVcbi8vIGFyZSBsaWtlbHkgZmFyIG1vcmUgbm9ybWFsIGZpbGVzIGluIHRoZSB3b3JsZCB0aGFuIGRpcmVjdG9yaWVzLiAgVGhpc1xuLy8gaXMgYmFzZWQgb24gdGhlIGFzc3VtcHRpb24gdGhhdCBhIHRoZSBhdmVyYWdlIG51bWJlciBvZiBmaWxlcyBwZXJcbi8vIGRpcmVjdG9yeSBpcyA+PSAxLlxuLy9cbi8vIElmIGFueW9uZSBldmVyIGNvbXBsYWlucyBhYm91dCB0aGlzLCB0aGVuIEkgZ3Vlc3MgdGhlIHN0cmF0ZWd5IGNvdWxkXG4vLyBiZSBtYWRlIGNvbmZpZ3VyYWJsZSBzb21laG93LiAgQnV0IHVudGlsIHRoZW4sIFlBR05JLlxuZnVuY3Rpb24gcmltcmFmXyAocCwgb3B0aW9ucywgY2IpIHtcbiAgYXNzZXJ0KHApXG4gIGFzc2VydChvcHRpb25zKVxuICBhc3NlcnQodHlwZW9mIGNiID09PSAnZnVuY3Rpb24nKVxuXG4gIC8vIHN1bm9zIGxldHMgdGhlIHJvb3QgdXNlciB1bmxpbmsgZGlyZWN0b3JpZXMsIHdoaWNoIGlzLi4uIHdlaXJkLlxuICAvLyBzbyB3ZSBoYXZlIHRvIGxzdGF0IGhlcmUgYW5kIG1ha2Ugc3VyZSBpdCdzIG5vdCBhIGRpci5cbiAgb3B0aW9ucy5sc3RhdChwLCAoZXIsIHN0KSA9PiB7XG4gICAgaWYgKGVyICYmIGVyLmNvZGUgPT09ICdFTk9FTlQnKSB7XG4gICAgICByZXR1cm4gY2IobnVsbClcbiAgICB9XG5cbiAgICAvLyBXaW5kb3dzIGNhbiBFUEVSTSBvbiBzdGF0LiAgTGlmZSBpcyBzdWZmZXJpbmcuXG4gICAgaWYgKGVyICYmIGVyLmNvZGUgPT09ICdFUEVSTScgJiYgaXNXaW5kb3dzKSB7XG4gICAgICByZXR1cm4gZml4V2luRVBFUk0ocCwgb3B0aW9ucywgZXIsIGNiKVxuICAgIH1cblxuICAgIGlmIChzdCAmJiBzdC5pc0RpcmVjdG9yeSgpKSB7XG4gICAgICByZXR1cm4gcm1kaXIocCwgb3B0aW9ucywgZXIsIGNiKVxuICAgIH1cblxuICAgIG9wdGlvbnMudW5saW5rKHAsIGVyID0+IHtcbiAgICAgIGlmIChlcikge1xuICAgICAgICBpZiAoZXIuY29kZSA9PT0gJ0VOT0VOVCcpIHtcbiAgICAgICAgICByZXR1cm4gY2IobnVsbClcbiAgICAgICAgfVxuICAgICAgICBpZiAoZXIuY29kZSA9PT0gJ0VQRVJNJykge1xuICAgICAgICAgIHJldHVybiAoaXNXaW5kb3dzKVxuICAgICAgICAgICAgPyBmaXhXaW5FUEVSTShwLCBvcHRpb25zLCBlciwgY2IpXG4gICAgICAgICAgICA6IHJtZGlyKHAsIG9wdGlvbnMsIGVyLCBjYilcbiAgICAgICAgfVxuICAgICAgICBpZiAoZXIuY29kZSA9PT0gJ0VJU0RJUicpIHtcbiAgICAgICAgICByZXR1cm4gcm1kaXIocCwgb3B0aW9ucywgZXIsIGNiKVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gY2IoZXIpXG4gICAgfSlcbiAgfSlcbn1cblxuZnVuY3Rpb24gZml4V2luRVBFUk0gKHAsIG9wdGlvbnMsIGVyLCBjYikge1xuICBhc3NlcnQocClcbiAgYXNzZXJ0KG9wdGlvbnMpXG4gIGFzc2VydCh0eXBlb2YgY2IgPT09ICdmdW5jdGlvbicpXG4gIGlmIChlcikge1xuICAgIGFzc2VydChlciBpbnN0YW5jZW9mIEVycm9yKVxuICB9XG5cbiAgb3B0aW9ucy5jaG1vZChwLCAwbzY2NiwgZXIyID0+IHtcbiAgICBpZiAoZXIyKSB7XG4gICAgICBjYihlcjIuY29kZSA9PT0gJ0VOT0VOVCcgPyBudWxsIDogZXIpXG4gICAgfSBlbHNlIHtcbiAgICAgIG9wdGlvbnMuc3RhdChwLCAoZXIzLCBzdGF0cykgPT4ge1xuICAgICAgICBpZiAoZXIzKSB7XG4gICAgICAgICAgY2IoZXIzLmNvZGUgPT09ICdFTk9FTlQnID8gbnVsbCA6IGVyKVxuICAgICAgICB9IGVsc2UgaWYgKHN0YXRzLmlzRGlyZWN0b3J5KCkpIHtcbiAgICAgICAgICBybWRpcihwLCBvcHRpb25zLCBlciwgY2IpXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgb3B0aW9ucy51bmxpbmsocCwgY2IpXG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgfVxuICB9KVxufVxuXG5mdW5jdGlvbiBmaXhXaW5FUEVSTVN5bmMgKHAsIG9wdGlvbnMsIGVyKSB7XG4gIGxldCBzdGF0c1xuXG4gIGFzc2VydChwKVxuICBhc3NlcnQob3B0aW9ucylcbiAgaWYgKGVyKSB7XG4gICAgYXNzZXJ0KGVyIGluc3RhbmNlb2YgRXJyb3IpXG4gIH1cblxuICB0cnkge1xuICAgIG9wdGlvbnMuY2htb2RTeW5jKHAsIDBvNjY2KVxuICB9IGNhdGNoIChlcjIpIHtcbiAgICBpZiAoZXIyLmNvZGUgPT09ICdFTk9FTlQnKSB7XG4gICAgICByZXR1cm5cbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgZXJcbiAgICB9XG4gIH1cblxuICB0cnkge1xuICAgIHN0YXRzID0gb3B0aW9ucy5zdGF0U3luYyhwKVxuICB9IGNhdGNoIChlcjMpIHtcbiAgICBpZiAoZXIzLmNvZGUgPT09ICdFTk9FTlQnKSB7XG4gICAgICByZXR1cm5cbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgZXJcbiAgICB9XG4gIH1cblxuICBpZiAoc3RhdHMuaXNEaXJlY3RvcnkoKSkge1xuICAgIHJtZGlyU3luYyhwLCBvcHRpb25zLCBlcilcbiAgfSBlbHNlIHtcbiAgICBvcHRpb25zLnVubGlua1N5bmMocClcbiAgfVxufVxuXG5mdW5jdGlvbiBybWRpciAocCwgb3B0aW9ucywgb3JpZ2luYWxFciwgY2IpIHtcbiAgYXNzZXJ0KHApXG4gIGFzc2VydChvcHRpb25zKVxuICBpZiAob3JpZ2luYWxFcikge1xuICAgIGFzc2VydChvcmlnaW5hbEVyIGluc3RhbmNlb2YgRXJyb3IpXG4gIH1cbiAgYXNzZXJ0KHR5cGVvZiBjYiA9PT0gJ2Z1bmN0aW9uJylcblxuICAvLyB0cnkgdG8gcm1kaXIgZmlyc3QsIGFuZCBvbmx5IHJlYWRkaXIgb24gRU5PVEVNUFRZIG9yIEVFWElTVCAoU3VuT1MpXG4gIC8vIGlmIHdlIGd1ZXNzZWQgd3JvbmcsIGFuZCBpdCdzIG5vdCBhIGRpcmVjdG9yeSwgdGhlblxuICAvLyByYWlzZSB0aGUgb3JpZ2luYWwgZXJyb3IuXG4gIG9wdGlvbnMucm1kaXIocCwgZXIgPT4ge1xuICAgIGlmIChlciAmJiAoZXIuY29kZSA9PT0gJ0VOT1RFTVBUWScgfHwgZXIuY29kZSA9PT0gJ0VFWElTVCcgfHwgZXIuY29kZSA9PT0gJ0VQRVJNJykpIHtcbiAgICAgIHJta2lkcyhwLCBvcHRpb25zLCBjYilcbiAgICB9IGVsc2UgaWYgKGVyICYmIGVyLmNvZGUgPT09ICdFTk9URElSJykge1xuICAgICAgY2Iob3JpZ2luYWxFcilcbiAgICB9IGVsc2Uge1xuICAgICAgY2IoZXIpXG4gICAgfVxuICB9KVxufVxuXG5mdW5jdGlvbiBybWtpZHMgKHAsIG9wdGlvbnMsIGNiKSB7XG4gIGFzc2VydChwKVxuICBhc3NlcnQob3B0aW9ucylcbiAgYXNzZXJ0KHR5cGVvZiBjYiA9PT0gJ2Z1bmN0aW9uJylcblxuICBvcHRpb25zLnJlYWRkaXIocCwgKGVyLCBmaWxlcykgPT4ge1xuICAgIGlmIChlcikgcmV0dXJuIGNiKGVyKVxuXG4gICAgbGV0IG4gPSBmaWxlcy5sZW5ndGhcbiAgICBsZXQgZXJyU3RhdGVcblxuICAgIGlmIChuID09PSAwKSByZXR1cm4gb3B0aW9ucy5ybWRpcihwLCBjYilcblxuICAgIGZpbGVzLmZvckVhY2goZiA9PiB7XG4gICAgICByaW1yYWYocGF0aC5qb2luKHAsIGYpLCBvcHRpb25zLCBlciA9PiB7XG4gICAgICAgIGlmIChlcnJTdGF0ZSkge1xuICAgICAgICAgIHJldHVyblxuICAgICAgICB9XG4gICAgICAgIGlmIChlcikgcmV0dXJuIGNiKGVyclN0YXRlID0gZXIpXG4gICAgICAgIGlmICgtLW4gPT09IDApIHtcbiAgICAgICAgICBvcHRpb25zLnJtZGlyKHAsIGNiKVxuICAgICAgICB9XG4gICAgICB9KVxuICAgIH0pXG4gIH0pXG59XG5cbi8vIHRoaXMgbG9va3Mgc2ltcGxlciwgYW5kIGlzIHN0cmljdGx5ICpmYXN0ZXIqLCBidXQgd2lsbFxuLy8gdGllIHVwIHRoZSBKYXZhU2NyaXB0IHRocmVhZCBhbmQgZmFpbCBvbiBleGNlc3NpdmVseVxuLy8gZGVlcCBkaXJlY3RvcnkgdHJlZXMuXG5mdW5jdGlvbiByaW1yYWZTeW5jIChwLCBvcHRpb25zKSB7XG4gIGxldCBzdFxuXG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9XG4gIGRlZmF1bHRzKG9wdGlvbnMpXG5cbiAgYXNzZXJ0KHAsICdyaW1yYWY6IG1pc3NpbmcgcGF0aCcpXG4gIGFzc2VydC5lcXVhbCh0eXBlb2YgcCwgJ3N0cmluZycsICdyaW1yYWY6IHBhdGggc2hvdWxkIGJlIGEgc3RyaW5nJylcbiAgYXNzZXJ0KG9wdGlvbnMsICdyaW1yYWY6IG1pc3Npbmcgb3B0aW9ucycpXG4gIGFzc2VydC5lcXVhbCh0eXBlb2Ygb3B0aW9ucywgJ29iamVjdCcsICdyaW1yYWY6IG9wdGlvbnMgc2hvdWxkIGJlIG9iamVjdCcpXG5cbiAgdHJ5IHtcbiAgICBzdCA9IG9wdGlvbnMubHN0YXRTeW5jKHApXG4gIH0gY2F0Y2ggKGVyKSB7XG4gICAgaWYgKGVyLmNvZGUgPT09ICdFTk9FTlQnKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICAvLyBXaW5kb3dzIGNhbiBFUEVSTSBvbiBzdGF0LiAgTGlmZSBpcyBzdWZmZXJpbmcuXG4gICAgaWYgKGVyLmNvZGUgPT09ICdFUEVSTScgJiYgaXNXaW5kb3dzKSB7XG4gICAgICBmaXhXaW5FUEVSTVN5bmMocCwgb3B0aW9ucywgZXIpXG4gICAgfVxuICB9XG5cbiAgdHJ5IHtcbiAgICAvLyBzdW5vcyBsZXRzIHRoZSByb290IHVzZXIgdW5saW5rIGRpcmVjdG9yaWVzLCB3aGljaCBpcy4uLiB3ZWlyZC5cbiAgICBpZiAoc3QgJiYgc3QuaXNEaXJlY3RvcnkoKSkge1xuICAgICAgcm1kaXJTeW5jKHAsIG9wdGlvbnMsIG51bGwpXG4gICAgfSBlbHNlIHtcbiAgICAgIG9wdGlvbnMudW5saW5rU3luYyhwKVxuICAgIH1cbiAgfSBjYXRjaCAoZXIpIHtcbiAgICBpZiAoZXIuY29kZSA9PT0gJ0VOT0VOVCcpIHtcbiAgICAgIHJldHVyblxuICAgIH0gZWxzZSBpZiAoZXIuY29kZSA9PT0gJ0VQRVJNJykge1xuICAgICAgcmV0dXJuIGlzV2luZG93cyA/IGZpeFdpbkVQRVJNU3luYyhwLCBvcHRpb25zLCBlcikgOiBybWRpclN5bmMocCwgb3B0aW9ucywgZXIpXG4gICAgfSBlbHNlIGlmIChlci5jb2RlICE9PSAnRUlTRElSJykge1xuICAgICAgdGhyb3cgZXJcbiAgICB9XG4gICAgcm1kaXJTeW5jKHAsIG9wdGlvbnMsIGVyKVxuICB9XG59XG5cbmZ1bmN0aW9uIHJtZGlyU3luYyAocCwgb3B0aW9ucywgb3JpZ2luYWxFcikge1xuICBhc3NlcnQocClcbiAgYXNzZXJ0KG9wdGlvbnMpXG4gIGlmIChvcmlnaW5hbEVyKSB7XG4gICAgYXNzZXJ0KG9yaWdpbmFsRXIgaW5zdGFuY2VvZiBFcnJvcilcbiAgfVxuXG4gIHRyeSB7XG4gICAgb3B0aW9ucy5ybWRpclN5bmMocClcbiAgfSBjYXRjaCAoZXIpIHtcbiAgICBpZiAoZXIuY29kZSA9PT0gJ0VOT1RESVInKSB7XG4gICAgICB0aHJvdyBvcmlnaW5hbEVyXG4gICAgfSBlbHNlIGlmIChlci5jb2RlID09PSAnRU5PVEVNUFRZJyB8fCBlci5jb2RlID09PSAnRUVYSVNUJyB8fCBlci5jb2RlID09PSAnRVBFUk0nKSB7XG4gICAgICBybWtpZHNTeW5jKHAsIG9wdGlvbnMpXG4gICAgfSBlbHNlIGlmIChlci5jb2RlICE9PSAnRU5PRU5UJykge1xuICAgICAgdGhyb3cgZXJcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gcm1raWRzU3luYyAocCwgb3B0aW9ucykge1xuICBhc3NlcnQocClcbiAgYXNzZXJ0KG9wdGlvbnMpXG4gIG9wdGlvbnMucmVhZGRpclN5bmMocCkuZm9yRWFjaChmID0+IHJpbXJhZlN5bmMocGF0aC5qb2luKHAsIGYpLCBvcHRpb25zKSlcblxuICAvLyBXZSBvbmx5IGVuZCB1cCBoZXJlIG9uY2Ugd2UgZ290IEVOT1RFTVBUWSBhdCBsZWFzdCBvbmNlLCBhbmRcbiAgLy8gYXQgdGhpcyBwb2ludCwgd2UgYXJlIGd1YXJhbnRlZWQgdG8gaGF2ZSByZW1vdmVkIGFsbCB0aGUga2lkcy5cbiAgLy8gU28sIHdlIGtub3cgdGhhdCBpdCB3b24ndCBiZSBFTk9FTlQgb3IgRU5PVERJUiBvciBhbnl0aGluZyBlbHNlLlxuICAvLyB0cnkgcmVhbGx5IGhhcmQgdG8gZGVsZXRlIHN0dWZmIG9uIHdpbmRvd3MsIGJlY2F1c2UgaXQgaGFzIGFcbiAgLy8gUFJPRk9VTkRMWSBhbm5veWluZyBoYWJpdCBvZiBub3QgY2xvc2luZyBoYW5kbGVzIHByb21wdGx5IHdoZW5cbiAgLy8gZmlsZXMgYXJlIGRlbGV0ZWQsIHJlc3VsdGluZyBpbiBzcHVyaW91cyBFTk9URU1QVFkgZXJyb3JzLlxuICBjb25zdCByZXRyaWVzID0gaXNXaW5kb3dzID8gMTAwIDogMVxuICBsZXQgaSA9IDBcbiAgZG8ge1xuICAgIGxldCB0aHJldyA9IHRydWVcbiAgICB0cnkge1xuICAgICAgY29uc3QgcmV0ID0gb3B0aW9ucy5ybWRpclN5bmMocCwgb3B0aW9ucylcbiAgICAgIHRocmV3ID0gZmFsc2VcbiAgICAgIHJldHVybiByZXRcbiAgICB9IGZpbmFsbHkge1xuICAgICAgaWYgKCsraSA8IHJldHJpZXMgJiYgdGhyZXcpIGNvbnRpbnVlIC8vIGVzbGludC1kaXNhYmxlLWxpbmVcbiAgICB9XG4gIH0gd2hpbGUgKHRydWUpXG59XG5cbm1vZHVsZS5leHBvcnRzID0gcmltcmFmXG5yaW1yYWYuc3luYyA9IHJpbXJhZlN5bmNcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9lbGVjdHJvbi11cGRhdGVyL25vZGVfbW9kdWxlcy9mcy1leHRyYS9saWIvcmVtb3ZlL3JpbXJhZi5qcyIsIid1c2Ugc3RyaWN0J1xuXG5jb25zdCB1ID0gcmVxdWlyZSgndW5pdmVyc2FsaWZ5JykuZnJvbUNhbGxiYWNrXG5jb25zdCBqc29uRmlsZSA9IHJlcXVpcmUoJy4vanNvbmZpbGUnKVxuXG5qc29uRmlsZS5vdXRwdXRKc29uID0gdShyZXF1aXJlKCcuL291dHB1dC1qc29uJykpXG5qc29uRmlsZS5vdXRwdXRKc29uU3luYyA9IHJlcXVpcmUoJy4vb3V0cHV0LWpzb24tc3luYycpXG4vLyBhbGlhc2VzXG5qc29uRmlsZS5vdXRwdXRKU09OID0ganNvbkZpbGUub3V0cHV0SnNvblxuanNvbkZpbGUub3V0cHV0SlNPTlN5bmMgPSBqc29uRmlsZS5vdXRwdXRKc29uU3luY1xuanNvbkZpbGUud3JpdGVKU09OID0ganNvbkZpbGUud3JpdGVKc29uXG5qc29uRmlsZS53cml0ZUpTT05TeW5jID0ganNvbkZpbGUud3JpdGVKc29uU3luY1xuanNvbkZpbGUucmVhZEpTT04gPSBqc29uRmlsZS5yZWFkSnNvblxuanNvbkZpbGUucmVhZEpTT05TeW5jID0ganNvbkZpbGUucmVhZEpzb25TeW5jXG5cbm1vZHVsZS5leHBvcnRzID0ganNvbkZpbGVcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9lbGVjdHJvbi11cGRhdGVyL25vZGVfbW9kdWxlcy9mcy1leHRyYS9saWIvanNvbi9pbmRleC5qcyIsInZhciBfZnNcbnRyeSB7XG4gIF9mcyA9IHJlcXVpcmUoJ2dyYWNlZnVsLWZzJylcbn0gY2F0Y2ggKF8pIHtcbiAgX2ZzID0gcmVxdWlyZSgnZnMnKVxufVxuXG5mdW5jdGlvbiByZWFkRmlsZSAoZmlsZSwgb3B0aW9ucywgY2FsbGJhY2spIHtcbiAgaWYgKGNhbGxiYWNrID09IG51bGwpIHtcbiAgICBjYWxsYmFjayA9IG9wdGlvbnNcbiAgICBvcHRpb25zID0ge31cbiAgfVxuXG4gIGlmICh0eXBlb2Ygb3B0aW9ucyA9PT0gJ3N0cmluZycpIHtcbiAgICBvcHRpb25zID0ge2VuY29kaW5nOiBvcHRpb25zfVxuICB9XG5cbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge31cbiAgdmFyIGZzID0gb3B0aW9ucy5mcyB8fCBfZnNcblxuICB2YXIgc2hvdWxkVGhyb3cgPSB0cnVlXG4gIGlmICgndGhyb3dzJyBpbiBvcHRpb25zKSB7XG4gICAgc2hvdWxkVGhyb3cgPSBvcHRpb25zLnRocm93c1xuICB9XG5cbiAgZnMucmVhZEZpbGUoZmlsZSwgb3B0aW9ucywgZnVuY3Rpb24gKGVyciwgZGF0YSkge1xuICAgIGlmIChlcnIpIHJldHVybiBjYWxsYmFjayhlcnIpXG5cbiAgICBkYXRhID0gc3RyaXBCb20oZGF0YSlcblxuICAgIHZhciBvYmpcbiAgICB0cnkge1xuICAgICAgb2JqID0gSlNPTi5wYXJzZShkYXRhLCBvcHRpb25zID8gb3B0aW9ucy5yZXZpdmVyIDogbnVsbClcbiAgICB9IGNhdGNoIChlcnIyKSB7XG4gICAgICBpZiAoc2hvdWxkVGhyb3cpIHtcbiAgICAgICAgZXJyMi5tZXNzYWdlID0gZmlsZSArICc6ICcgKyBlcnIyLm1lc3NhZ2VcbiAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGVycjIpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gY2FsbGJhY2sobnVsbCwgbnVsbClcbiAgICAgIH1cbiAgICB9XG5cbiAgICBjYWxsYmFjayhudWxsLCBvYmopXG4gIH0pXG59XG5cbmZ1bmN0aW9uIHJlYWRGaWxlU3luYyAoZmlsZSwgb3B0aW9ucykge1xuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fVxuICBpZiAodHlwZW9mIG9wdGlvbnMgPT09ICdzdHJpbmcnKSB7XG4gICAgb3B0aW9ucyA9IHtlbmNvZGluZzogb3B0aW9uc31cbiAgfVxuXG4gIHZhciBmcyA9IG9wdGlvbnMuZnMgfHwgX2ZzXG5cbiAgdmFyIHNob3VsZFRocm93ID0gdHJ1ZVxuICBpZiAoJ3Rocm93cycgaW4gb3B0aW9ucykge1xuICAgIHNob3VsZFRocm93ID0gb3B0aW9ucy50aHJvd3NcbiAgfVxuXG4gIHRyeSB7XG4gICAgdmFyIGNvbnRlbnQgPSBmcy5yZWFkRmlsZVN5bmMoZmlsZSwgb3B0aW9ucylcbiAgICBjb250ZW50ID0gc3RyaXBCb20oY29udGVudClcbiAgICByZXR1cm4gSlNPTi5wYXJzZShjb250ZW50LCBvcHRpb25zLnJldml2ZXIpXG4gIH0gY2F0Y2ggKGVycikge1xuICAgIGlmIChzaG91bGRUaHJvdykge1xuICAgICAgZXJyLm1lc3NhZ2UgPSBmaWxlICsgJzogJyArIGVyci5tZXNzYWdlXG4gICAgICB0aHJvdyBlcnJcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIG51bGxcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gc3RyaW5naWZ5IChvYmosIG9wdGlvbnMpIHtcbiAgdmFyIHNwYWNlc1xuICB2YXIgRU9MID0gJ1xcbidcbiAgaWYgKHR5cGVvZiBvcHRpb25zID09PSAnb2JqZWN0JyAmJiBvcHRpb25zICE9PSBudWxsKSB7XG4gICAgaWYgKG9wdGlvbnMuc3BhY2VzKSB7XG4gICAgICBzcGFjZXMgPSBvcHRpb25zLnNwYWNlc1xuICAgIH1cbiAgICBpZiAob3B0aW9ucy5FT0wpIHtcbiAgICAgIEVPTCA9IG9wdGlvbnMuRU9MXG4gICAgfVxuICB9XG5cbiAgdmFyIHN0ciA9IEpTT04uc3RyaW5naWZ5KG9iaiwgb3B0aW9ucyA/IG9wdGlvbnMucmVwbGFjZXIgOiBudWxsLCBzcGFjZXMpXG5cbiAgcmV0dXJuIHN0ci5yZXBsYWNlKC9cXG4vZywgRU9MKSArIEVPTFxufVxuXG5mdW5jdGlvbiB3cml0ZUZpbGUgKGZpbGUsIG9iaiwgb3B0aW9ucywgY2FsbGJhY2spIHtcbiAgaWYgKGNhbGxiYWNrID09IG51bGwpIHtcbiAgICBjYWxsYmFjayA9IG9wdGlvbnNcbiAgICBvcHRpb25zID0ge31cbiAgfVxuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fVxuICB2YXIgZnMgPSBvcHRpb25zLmZzIHx8IF9mc1xuXG4gIHZhciBzdHIgPSAnJ1xuICB0cnkge1xuICAgIHN0ciA9IHN0cmluZ2lmeShvYmosIG9wdGlvbnMpXG4gIH0gY2F0Y2ggKGVycikge1xuICAgIC8vIE5lZWQgdG8gcmV0dXJuIHdoZXRoZXIgYSBjYWxsYmFjayB3YXMgcGFzc2VkIG9yIG5vdFxuICAgIGlmIChjYWxsYmFjaykgY2FsbGJhY2soZXJyLCBudWxsKVxuICAgIHJldHVyblxuICB9XG5cbiAgZnMud3JpdGVGaWxlKGZpbGUsIHN0ciwgb3B0aW9ucywgY2FsbGJhY2spXG59XG5cbmZ1bmN0aW9uIHdyaXRlRmlsZVN5bmMgKGZpbGUsIG9iaiwgb3B0aW9ucykge1xuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fVxuICB2YXIgZnMgPSBvcHRpb25zLmZzIHx8IF9mc1xuXG4gIHZhciBzdHIgPSBzdHJpbmdpZnkob2JqLCBvcHRpb25zKVxuICAvLyBub3Qgc3VyZSBpZiBmcy53cml0ZUZpbGVTeW5jIHJldHVybnMgYW55dGhpbmcsIGJ1dCBqdXN0IGluIGNhc2VcbiAgcmV0dXJuIGZzLndyaXRlRmlsZVN5bmMoZmlsZSwgc3RyLCBvcHRpb25zKVxufVxuXG5mdW5jdGlvbiBzdHJpcEJvbSAoY29udGVudCkge1xuICAvLyB3ZSBkbyB0aGlzIGJlY2F1c2UgSlNPTi5wYXJzZSB3b3VsZCBjb252ZXJ0IGl0IHRvIGEgdXRmOCBzdHJpbmcgaWYgZW5jb2Rpbmcgd2Fzbid0IHNwZWNpZmllZFxuICBpZiAoQnVmZmVyLmlzQnVmZmVyKGNvbnRlbnQpKSBjb250ZW50ID0gY29udGVudC50b1N0cmluZygndXRmOCcpXG4gIGNvbnRlbnQgPSBjb250ZW50LnJlcGxhY2UoL15cXHVGRUZGLywgJycpXG4gIHJldHVybiBjb250ZW50XG59XG5cbnZhciBqc29uZmlsZSA9IHtcbiAgcmVhZEZpbGU6IHJlYWRGaWxlLFxuICByZWFkRmlsZVN5bmM6IHJlYWRGaWxlU3luYyxcbiAgd3JpdGVGaWxlOiB3cml0ZUZpbGUsXG4gIHdyaXRlRmlsZVN5bmM6IHdyaXRlRmlsZVN5bmNcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBqc29uZmlsZVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2pzb25maWxlL2luZGV4LmpzIiwiJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IHBhdGggPSByZXF1aXJlKCdwYXRoJylcbmNvbnN0IG1rZGlyID0gcmVxdWlyZSgnLi4vbWtkaXJzJylcbmNvbnN0IHBhdGhFeGlzdHMgPSByZXF1aXJlKCcuLi9wYXRoLWV4aXN0cycpLnBhdGhFeGlzdHNcbmNvbnN0IGpzb25GaWxlID0gcmVxdWlyZSgnLi9qc29uZmlsZScpXG5cbmZ1bmN0aW9uIG91dHB1dEpzb24gKGZpbGUsIGRhdGEsIG9wdGlvbnMsIGNhbGxiYWNrKSB7XG4gIGlmICh0eXBlb2Ygb3B0aW9ucyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGNhbGxiYWNrID0gb3B0aW9uc1xuICAgIG9wdGlvbnMgPSB7fVxuICB9XG5cbiAgY29uc3QgZGlyID0gcGF0aC5kaXJuYW1lKGZpbGUpXG5cbiAgcGF0aEV4aXN0cyhkaXIsIChlcnIsIGl0RG9lcykgPT4ge1xuICAgIGlmIChlcnIpIHJldHVybiBjYWxsYmFjayhlcnIpXG4gICAgaWYgKGl0RG9lcykgcmV0dXJuIGpzb25GaWxlLndyaXRlSnNvbihmaWxlLCBkYXRhLCBvcHRpb25zLCBjYWxsYmFjaylcblxuICAgIG1rZGlyLm1rZGlycyhkaXIsIGVyciA9PiB7XG4gICAgICBpZiAoZXJyKSByZXR1cm4gY2FsbGJhY2soZXJyKVxuICAgICAganNvbkZpbGUud3JpdGVKc29uKGZpbGUsIGRhdGEsIG9wdGlvbnMsIGNhbGxiYWNrKVxuICAgIH0pXG4gIH0pXG59XG5cbm1vZHVsZS5leHBvcnRzID0gb3V0cHV0SnNvblxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2VsZWN0cm9uLXVwZGF0ZXIvbm9kZV9tb2R1bGVzL2ZzLWV4dHJhL2xpYi9qc29uL291dHB1dC1qc29uLmpzIiwiJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IGZzID0gcmVxdWlyZSgnZ3JhY2VmdWwtZnMnKVxuY29uc3QgcGF0aCA9IHJlcXVpcmUoJ3BhdGgnKVxuY29uc3QgbWtkaXIgPSByZXF1aXJlKCcuLi9ta2RpcnMnKVxuY29uc3QganNvbkZpbGUgPSByZXF1aXJlKCcuL2pzb25maWxlJylcblxuZnVuY3Rpb24gb3V0cHV0SnNvblN5bmMgKGZpbGUsIGRhdGEsIG9wdGlvbnMpIHtcbiAgY29uc3QgZGlyID0gcGF0aC5kaXJuYW1lKGZpbGUpXG5cbiAgaWYgKCFmcy5leGlzdHNTeW5jKGRpcikpIHtcbiAgICBta2Rpci5ta2RpcnNTeW5jKGRpcilcbiAgfVxuXG4gIGpzb25GaWxlLndyaXRlSnNvblN5bmMoZmlsZSwgZGF0YSwgb3B0aW9ucylcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBvdXRwdXRKc29uU3luY1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2VsZWN0cm9uLXVwZGF0ZXIvbm9kZV9tb2R1bGVzL2ZzLWV4dHJhL2xpYi9qc29uL291dHB1dC1qc29uLXN5bmMuanMiLCIndXNlIHN0cmljdCdcblxuLy8gbW9zdCBvZiB0aGlzIGNvZGUgd2FzIHdyaXR0ZW4gYnkgQW5kcmV3IEtlbGxleVxuLy8gbGljZW5zZWQgdW5kZXIgdGhlIEJTRCBsaWNlbnNlOiBzZWVcbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9hbmRyZXdyay9ub2RlLW12L2Jsb2IvbWFzdGVyL3BhY2thZ2UuanNvblxuXG4vLyB0aGlzIG5lZWRzIGEgY2xlYW51cFxuXG5jb25zdCB1ID0gcmVxdWlyZSgndW5pdmVyc2FsaWZ5JykuZnJvbUNhbGxiYWNrXG5jb25zdCBmcyA9IHJlcXVpcmUoJ2dyYWNlZnVsLWZzJylcbmNvbnN0IGNvcHkgPSByZXF1aXJlKCcuLi9jb3B5L2NvcHknKVxuY29uc3QgcGF0aCA9IHJlcXVpcmUoJ3BhdGgnKVxuY29uc3QgcmVtb3ZlID0gcmVxdWlyZSgnLi4vcmVtb3ZlJykucmVtb3ZlXG5jb25zdCBta2RpcnAgPSByZXF1aXJlKCcuLi9ta2RpcnMnKS5ta2RpcnNcblxuZnVuY3Rpb24gbW92ZSAoc3JjLCBkZXN0LCBvcHRpb25zLCBjYWxsYmFjaykge1xuICBpZiAodHlwZW9mIG9wdGlvbnMgPT09ICdmdW5jdGlvbicpIHtcbiAgICBjYWxsYmFjayA9IG9wdGlvbnNcbiAgICBvcHRpb25zID0ge31cbiAgfVxuXG4gIGNvbnN0IG92ZXJ3cml0ZSA9IG9wdGlvbnMub3ZlcndyaXRlIHx8IG9wdGlvbnMuY2xvYmJlciB8fCBmYWxzZVxuXG4gIGlzU3JjU3ViZGlyKHNyYywgZGVzdCwgKGVyciwgaXRJcykgPT4ge1xuICAgIGlmIChlcnIpIHJldHVybiBjYWxsYmFjayhlcnIpXG4gICAgaWYgKGl0SXMpIHJldHVybiBjYWxsYmFjayhuZXcgRXJyb3IoYENhbm5vdCBtb3ZlICcke3NyY30nIHRvIGEgc3ViZGlyZWN0b3J5IG9mIGl0c2VsZiwgJyR7ZGVzdH0nLmApKVxuICAgIG1rZGlycChwYXRoLmRpcm5hbWUoZGVzdCksIGVyciA9PiB7XG4gICAgICBpZiAoZXJyKSByZXR1cm4gY2FsbGJhY2soZXJyKVxuICAgICAgZG9SZW5hbWUoKVxuICAgIH0pXG4gIH0pXG5cbiAgZnVuY3Rpb24gZG9SZW5hbWUgKCkge1xuICAgIGlmIChwYXRoLnJlc29sdmUoc3JjKSA9PT0gcGF0aC5yZXNvbHZlKGRlc3QpKSB7XG4gICAgICBmcy5hY2Nlc3Moc3JjLCBjYWxsYmFjaylcbiAgICB9IGVsc2UgaWYgKG92ZXJ3cml0ZSkge1xuICAgICAgZnMucmVuYW1lKHNyYywgZGVzdCwgZXJyID0+IHtcbiAgICAgICAgaWYgKCFlcnIpIHJldHVybiBjYWxsYmFjaygpXG5cbiAgICAgICAgaWYgKGVyci5jb2RlID09PSAnRU5PVEVNUFRZJyB8fCBlcnIuY29kZSA9PT0gJ0VFWElTVCcpIHtcbiAgICAgICAgICByZW1vdmUoZGVzdCwgZXJyID0+IHtcbiAgICAgICAgICAgIGlmIChlcnIpIHJldHVybiBjYWxsYmFjayhlcnIpXG4gICAgICAgICAgICBvcHRpb25zLm92ZXJ3cml0ZSA9IGZhbHNlIC8vIGp1c3Qgb3ZlcndyaXRlZWQgaXQsIG5vIG5lZWQgdG8gZG8gaXQgYWdhaW5cbiAgICAgICAgICAgIG1vdmUoc3JjLCBkZXN0LCBvcHRpb25zLCBjYWxsYmFjaylcbiAgICAgICAgICB9KVxuICAgICAgICAgIHJldHVyblxuICAgICAgICB9XG5cbiAgICAgICAgLy8gd2VpcmQgV2luZG93cyBzaGl0XG4gICAgICAgIGlmIChlcnIuY29kZSA9PT0gJ0VQRVJNJykge1xuICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgcmVtb3ZlKGRlc3QsIGVyciA9PiB7XG4gICAgICAgICAgICAgIGlmIChlcnIpIHJldHVybiBjYWxsYmFjayhlcnIpXG4gICAgICAgICAgICAgIG9wdGlvbnMub3ZlcndyaXRlID0gZmFsc2VcbiAgICAgICAgICAgICAgbW92ZShzcmMsIGRlc3QsIG9wdGlvbnMsIGNhbGxiYWNrKVxuICAgICAgICAgICAgfSlcbiAgICAgICAgICB9LCAyMDApXG4gICAgICAgICAgcmV0dXJuXG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZXJyLmNvZGUgIT09ICdFWERFVicpIHJldHVybiBjYWxsYmFjayhlcnIpXG4gICAgICAgIG1vdmVBY3Jvc3NEZXZpY2Uoc3JjLCBkZXN0LCBvdmVyd3JpdGUsIGNhbGxiYWNrKVxuICAgICAgfSlcbiAgICB9IGVsc2Uge1xuICAgICAgZnMubGluayhzcmMsIGRlc3QsIGVyciA9PiB7XG4gICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICBpZiAoZXJyLmNvZGUgPT09ICdFWERFVicgfHwgZXJyLmNvZGUgPT09ICdFSVNESVInIHx8IGVyci5jb2RlID09PSAnRVBFUk0nIHx8IGVyci5jb2RlID09PSAnRU5PVFNVUCcpIHtcbiAgICAgICAgICAgIHJldHVybiBtb3ZlQWNyb3NzRGV2aWNlKHNyYywgZGVzdCwgb3ZlcndyaXRlLCBjYWxsYmFjaylcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGVycilcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZnMudW5saW5rKHNyYywgY2FsbGJhY2spXG4gICAgICB9KVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBtb3ZlQWNyb3NzRGV2aWNlIChzcmMsIGRlc3QsIG92ZXJ3cml0ZSwgY2FsbGJhY2spIHtcbiAgZnMuc3RhdChzcmMsIChlcnIsIHN0YXQpID0+IHtcbiAgICBpZiAoZXJyKSByZXR1cm4gY2FsbGJhY2soZXJyKVxuXG4gICAgaWYgKHN0YXQuaXNEaXJlY3RvcnkoKSkge1xuICAgICAgbW92ZURpckFjcm9zc0RldmljZShzcmMsIGRlc3QsIG92ZXJ3cml0ZSwgY2FsbGJhY2spXG4gICAgfSBlbHNlIHtcbiAgICAgIG1vdmVGaWxlQWNyb3NzRGV2aWNlKHNyYywgZGVzdCwgb3ZlcndyaXRlLCBjYWxsYmFjaylcbiAgICB9XG4gIH0pXG59XG5cbmZ1bmN0aW9uIG1vdmVGaWxlQWNyb3NzRGV2aWNlIChzcmMsIGRlc3QsIG92ZXJ3cml0ZSwgY2FsbGJhY2spIHtcbiAgY29uc3QgZmxhZ3MgPSBvdmVyd3JpdGUgPyAndycgOiAnd3gnXG4gIGNvbnN0IGlucyA9IGZzLmNyZWF0ZVJlYWRTdHJlYW0oc3JjKVxuICBjb25zdCBvdXRzID0gZnMuY3JlYXRlV3JpdGVTdHJlYW0oZGVzdCwgeyBmbGFncyB9KVxuXG4gIGlucy5vbignZXJyb3InLCBlcnIgPT4ge1xuICAgIGlucy5kZXN0cm95KClcbiAgICBvdXRzLmRlc3Ryb3koKVxuICAgIG91dHMucmVtb3ZlTGlzdGVuZXIoJ2Nsb3NlJywgb25DbG9zZSlcblxuICAgIC8vIG1heSB3YW50IHRvIGNyZWF0ZSBhIGRpcmVjdG9yeSBidXQgYG91dGAgbGluZSBhYm92ZVxuICAgIC8vIGNyZWF0ZXMgYW4gZW1wdHkgZmlsZSBmb3IgdXM6IFNlZSAjMTA4XG4gICAgLy8gZG9uJ3QgY2FyZSBhYm91dCBlcnJvciBoZXJlXG4gICAgZnMudW5saW5rKGRlc3QsICgpID0+IHtcbiAgICAgIC8vIG5vdGU6IGBlcnJgIGhlcmUgaXMgZnJvbSB0aGUgaW5wdXQgc3RyZWFtIGVycnJvclxuICAgICAgaWYgKGVyci5jb2RlID09PSAnRUlTRElSJyB8fCBlcnIuY29kZSA9PT0gJ0VQRVJNJykge1xuICAgICAgICBtb3ZlRGlyQWNyb3NzRGV2aWNlKHNyYywgZGVzdCwgb3ZlcndyaXRlLCBjYWxsYmFjaylcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNhbGxiYWNrKGVycilcbiAgICAgIH1cbiAgICB9KVxuICB9KVxuXG4gIG91dHMub24oJ2Vycm9yJywgZXJyID0+IHtcbiAgICBpbnMuZGVzdHJveSgpXG4gICAgb3V0cy5kZXN0cm95KClcbiAgICBvdXRzLnJlbW92ZUxpc3RlbmVyKCdjbG9zZScsIG9uQ2xvc2UpXG4gICAgY2FsbGJhY2soZXJyKVxuICB9KVxuXG4gIG91dHMub25jZSgnY2xvc2UnLCBvbkNsb3NlKVxuICBpbnMucGlwZShvdXRzKVxuXG4gIGZ1bmN0aW9uIG9uQ2xvc2UgKCkge1xuICAgIGZzLnVubGluayhzcmMsIGNhbGxiYWNrKVxuICB9XG59XG5cbmZ1bmN0aW9uIG1vdmVEaXJBY3Jvc3NEZXZpY2UgKHNyYywgZGVzdCwgb3ZlcndyaXRlLCBjYWxsYmFjaykge1xuICBjb25zdCBvcHRpb25zID0ge1xuICAgIG92ZXJ3cml0ZTogZmFsc2VcbiAgfVxuXG4gIGlmIChvdmVyd3JpdGUpIHtcbiAgICByZW1vdmUoZGVzdCwgZXJyID0+IHtcbiAgICAgIGlmIChlcnIpIHJldHVybiBjYWxsYmFjayhlcnIpXG4gICAgICBzdGFydENvcHkoKVxuICAgIH0pXG4gIH0gZWxzZSB7XG4gICAgc3RhcnRDb3B5KClcbiAgfVxuXG4gIGZ1bmN0aW9uIHN0YXJ0Q29weSAoKSB7XG4gICAgY29weShzcmMsIGRlc3QsIG9wdGlvbnMsIGVyciA9PiB7XG4gICAgICBpZiAoZXJyKSByZXR1cm4gY2FsbGJhY2soZXJyKVxuICAgICAgcmVtb3ZlKHNyYywgY2FsbGJhY2spXG4gICAgfSlcbiAgfVxufVxuXG4vLyByZXR1cm4gdHJ1ZSBpZiBkZXN0IGlzIGEgc3ViZGlyIG9mIHNyYywgb3RoZXJ3aXNlIGZhbHNlLlxuLy8gZXh0cmFjdCBkZXN0IGJhc2UgZGlyIGFuZCBjaGVjayBpZiB0aGF0IGlzIHRoZSBzYW1lIGFzIHNyYyBiYXNlbmFtZVxuZnVuY3Rpb24gaXNTcmNTdWJkaXIgKHNyYywgZGVzdCwgY2IpIHtcbiAgZnMuc3RhdChzcmMsIChlcnIsIHN0KSA9PiB7XG4gICAgaWYgKGVycikgcmV0dXJuIGNiKGVycilcbiAgICBpZiAoc3QuaXNEaXJlY3RvcnkoKSkge1xuICAgICAgY29uc3QgYmFzZURpciA9IGRlc3Quc3BsaXQocGF0aC5kaXJuYW1lKHNyYykgKyBwYXRoLnNlcClbMV1cbiAgICAgIGlmIChiYXNlRGlyKSB7XG4gICAgICAgIGNvbnN0IGRlc3RCYXNlbmFtZSA9IGJhc2VEaXIuc3BsaXQocGF0aC5zZXApWzBdXG4gICAgICAgIGlmIChkZXN0QmFzZW5hbWUpIHJldHVybiBjYihudWxsLCBzcmMgIT09IGRlc3QgJiYgZGVzdC5pbmRleE9mKHNyYykgPiAtMSAmJiBkZXN0QmFzZW5hbWUgPT09IHBhdGguYmFzZW5hbWUoc3JjKSlcbiAgICAgICAgcmV0dXJuIGNiKG51bGwsIGZhbHNlKVxuICAgICAgfVxuICAgICAgcmV0dXJuIGNiKG51bGwsIGZhbHNlKVxuICAgIH1cbiAgICByZXR1cm4gY2IobnVsbCwgZmFsc2UpXG4gIH0pXG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBtb3ZlOiB1KG1vdmUpXG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvZWxlY3Ryb24tdXBkYXRlci9ub2RlX21vZHVsZXMvZnMtZXh0cmEvbGliL21vdmUvaW5kZXguanMiLCIndXNlIHN0cmljdCdcblxuY29uc3QgZnMgPSByZXF1aXJlKCdncmFjZWZ1bC1mcycpXG5jb25zdCBwYXRoID0gcmVxdWlyZSgncGF0aCcpXG5jb25zdCBjb3B5U3luYyA9IHJlcXVpcmUoJy4uL2NvcHktc3luYycpLmNvcHlTeW5jXG5jb25zdCByZW1vdmVTeW5jID0gcmVxdWlyZSgnLi4vcmVtb3ZlJykucmVtb3ZlU3luY1xuY29uc3QgbWtkaXJwU3luYyA9IHJlcXVpcmUoJy4uL21rZGlycycpLm1rZGlyc1N5bmNcbmNvbnN0IGJ1ZmZlciA9IHJlcXVpcmUoJy4uL3V0aWwvYnVmZmVyJylcblxuZnVuY3Rpb24gbW92ZVN5bmMgKHNyYywgZGVzdCwgb3B0aW9ucykge1xuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fVxuICBjb25zdCBvdmVyd3JpdGUgPSBvcHRpb25zLm92ZXJ3cml0ZSB8fCBvcHRpb25zLmNsb2JiZXIgfHwgZmFsc2VcblxuICBzcmMgPSBwYXRoLnJlc29sdmUoc3JjKVxuICBkZXN0ID0gcGF0aC5yZXNvbHZlKGRlc3QpXG5cbiAgaWYgKHNyYyA9PT0gZGVzdCkgcmV0dXJuIGZzLmFjY2Vzc1N5bmMoc3JjKVxuXG4gIGlmIChpc1NyY1N1YmRpcihzcmMsIGRlc3QpKSB0aHJvdyBuZXcgRXJyb3IoYENhbm5vdCBtb3ZlICcke3NyY30nIGludG8gaXRzZWxmICcke2Rlc3R9Jy5gKVxuXG4gIG1rZGlycFN5bmMocGF0aC5kaXJuYW1lKGRlc3QpKVxuICB0cnlSZW5hbWVTeW5jKClcblxuICBmdW5jdGlvbiB0cnlSZW5hbWVTeW5jICgpIHtcbiAgICBpZiAob3ZlcndyaXRlKSB7XG4gICAgICB0cnkge1xuICAgICAgICByZXR1cm4gZnMucmVuYW1lU3luYyhzcmMsIGRlc3QpXG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgaWYgKGVyci5jb2RlID09PSAnRU5PVEVNUFRZJyB8fCBlcnIuY29kZSA9PT0gJ0VFWElTVCcgfHwgZXJyLmNvZGUgPT09ICdFUEVSTScpIHtcbiAgICAgICAgICByZW1vdmVTeW5jKGRlc3QpXG4gICAgICAgICAgb3B0aW9ucy5vdmVyd3JpdGUgPSBmYWxzZSAvLyBqdXN0IG92ZXJ3cml0ZWVkIGl0LCBubyBuZWVkIHRvIGRvIGl0IGFnYWluXG4gICAgICAgICAgcmV0dXJuIG1vdmVTeW5jKHNyYywgZGVzdCwgb3B0aW9ucylcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChlcnIuY29kZSAhPT0gJ0VYREVWJykgdGhyb3cgZXJyXG4gICAgICAgIHJldHVybiBtb3ZlU3luY0Fjcm9zc0RldmljZShzcmMsIGRlc3QsIG92ZXJ3cml0ZSlcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdHJ5IHtcbiAgICAgICAgZnMubGlua1N5bmMoc3JjLCBkZXN0KVxuICAgICAgICByZXR1cm4gZnMudW5saW5rU3luYyhzcmMpXG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgaWYgKGVyci5jb2RlID09PSAnRVhERVYnIHx8IGVyci5jb2RlID09PSAnRUlTRElSJyB8fCBlcnIuY29kZSA9PT0gJ0VQRVJNJyB8fCBlcnIuY29kZSA9PT0gJ0VOT1RTVVAnKSB7XG4gICAgICAgICAgcmV0dXJuIG1vdmVTeW5jQWNyb3NzRGV2aWNlKHNyYywgZGVzdCwgb3ZlcndyaXRlKVxuICAgICAgICB9XG4gICAgICAgIHRocm93IGVyclxuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBtb3ZlU3luY0Fjcm9zc0RldmljZSAoc3JjLCBkZXN0LCBvdmVyd3JpdGUpIHtcbiAgY29uc3Qgc3RhdCA9IGZzLnN0YXRTeW5jKHNyYylcblxuICBpZiAoc3RhdC5pc0RpcmVjdG9yeSgpKSB7XG4gICAgcmV0dXJuIG1vdmVEaXJTeW5jQWNyb3NzRGV2aWNlKHNyYywgZGVzdCwgb3ZlcndyaXRlKVxuICB9IGVsc2Uge1xuICAgIHJldHVybiBtb3ZlRmlsZVN5bmNBY3Jvc3NEZXZpY2Uoc3JjLCBkZXN0LCBvdmVyd3JpdGUpXG4gIH1cbn1cblxuZnVuY3Rpb24gbW92ZUZpbGVTeW5jQWNyb3NzRGV2aWNlIChzcmMsIGRlc3QsIG92ZXJ3cml0ZSkge1xuICBjb25zdCBCVUZfTEVOR1RIID0gNjQgKiAxMDI0XG4gIGNvbnN0IF9idWZmID0gYnVmZmVyKEJVRl9MRU5HVEgpXG5cbiAgY29uc3QgZmxhZ3MgPSBvdmVyd3JpdGUgPyAndycgOiAnd3gnXG5cbiAgY29uc3QgZmRyID0gZnMub3BlblN5bmMoc3JjLCAncicpXG4gIGNvbnN0IHN0YXQgPSBmcy5mc3RhdFN5bmMoZmRyKVxuICBjb25zdCBmZHcgPSBmcy5vcGVuU3luYyhkZXN0LCBmbGFncywgc3RhdC5tb2RlKVxuICBsZXQgYnl0ZXNSZWFkID0gMVxuICBsZXQgcG9zID0gMFxuXG4gIHdoaWxlIChieXRlc1JlYWQgPiAwKSB7XG4gICAgYnl0ZXNSZWFkID0gZnMucmVhZFN5bmMoZmRyLCBfYnVmZiwgMCwgQlVGX0xFTkdUSCwgcG9zKVxuICAgIGZzLndyaXRlU3luYyhmZHcsIF9idWZmLCAwLCBieXRlc1JlYWQpXG4gICAgcG9zICs9IGJ5dGVzUmVhZFxuICB9XG5cbiAgZnMuY2xvc2VTeW5jKGZkcilcbiAgZnMuY2xvc2VTeW5jKGZkdylcbiAgcmV0dXJuIGZzLnVubGlua1N5bmMoc3JjKVxufVxuXG5mdW5jdGlvbiBtb3ZlRGlyU3luY0Fjcm9zc0RldmljZSAoc3JjLCBkZXN0LCBvdmVyd3JpdGUpIHtcbiAgY29uc3Qgb3B0aW9ucyA9IHtcbiAgICBvdmVyd3JpdGU6IGZhbHNlXG4gIH1cblxuICBpZiAob3ZlcndyaXRlKSB7XG4gICAgcmVtb3ZlU3luYyhkZXN0KVxuICAgIHRyeUNvcHlTeW5jKClcbiAgfSBlbHNlIHtcbiAgICB0cnlDb3B5U3luYygpXG4gIH1cblxuICBmdW5jdGlvbiB0cnlDb3B5U3luYyAoKSB7XG4gICAgY29weVN5bmMoc3JjLCBkZXN0LCBvcHRpb25zKVxuICAgIHJldHVybiByZW1vdmVTeW5jKHNyYylcbiAgfVxufVxuXG4vLyByZXR1cm4gdHJ1ZSBpZiBkZXN0IGlzIGEgc3ViZGlyIG9mIHNyYywgb3RoZXJ3aXNlIGZhbHNlLlxuLy8gZXh0cmFjdCBkZXN0IGJhc2UgZGlyIGFuZCBjaGVjayBpZiB0aGF0IGlzIHRoZSBzYW1lIGFzIHNyYyBiYXNlbmFtZVxuZnVuY3Rpb24gaXNTcmNTdWJkaXIgKHNyYywgZGVzdCkge1xuICB0cnkge1xuICAgIHJldHVybiBmcy5zdGF0U3luYyhzcmMpLmlzRGlyZWN0b3J5KCkgJiZcbiAgICAgICAgICAgc3JjICE9PSBkZXN0ICYmXG4gICAgICAgICAgIGRlc3QuaW5kZXhPZihzcmMpID4gLTEgJiZcbiAgICAgICAgICAgZGVzdC5zcGxpdChwYXRoLmRpcm5hbWUoc3JjKSArIHBhdGguc2VwKVsxXS5zcGxpdChwYXRoLnNlcClbMF0gPT09IHBhdGguYmFzZW5hbWUoc3JjKVxuICB9IGNhdGNoIChlKSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIG1vdmVTeW5jXG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvZWxlY3Ryb24tdXBkYXRlci9ub2RlX21vZHVsZXMvZnMtZXh0cmEvbGliL21vdmUtc3luYy9pbmRleC5qcyIsIid1c2Ugc3RyaWN0J1xuXG5jb25zdCB1ID0gcmVxdWlyZSgndW5pdmVyc2FsaWZ5JykuZnJvbUNhbGxiYWNrXG5jb25zdCBmcyA9IHJlcXVpcmUoJ2ZzJylcbmNvbnN0IHBhdGggPSByZXF1aXJlKCdwYXRoJylcbmNvbnN0IG1rZGlyID0gcmVxdWlyZSgnLi4vbWtkaXJzJylcbmNvbnN0IHJlbW92ZSA9IHJlcXVpcmUoJy4uL3JlbW92ZScpXG5cbmNvbnN0IGVtcHR5RGlyID0gdShmdW5jdGlvbiBlbXB0eURpciAoZGlyLCBjYWxsYmFjaykge1xuICBjYWxsYmFjayA9IGNhbGxiYWNrIHx8IGZ1bmN0aW9uICgpIHt9XG4gIGZzLnJlYWRkaXIoZGlyLCAoZXJyLCBpdGVtcykgPT4ge1xuICAgIGlmIChlcnIpIHJldHVybiBta2Rpci5ta2RpcnMoZGlyLCBjYWxsYmFjaylcblxuICAgIGl0ZW1zID0gaXRlbXMubWFwKGl0ZW0gPT4gcGF0aC5qb2luKGRpciwgaXRlbSkpXG5cbiAgICBkZWxldGVJdGVtKClcblxuICAgIGZ1bmN0aW9uIGRlbGV0ZUl0ZW0gKCkge1xuICAgICAgY29uc3QgaXRlbSA9IGl0ZW1zLnBvcCgpXG4gICAgICBpZiAoIWl0ZW0pIHJldHVybiBjYWxsYmFjaygpXG4gICAgICByZW1vdmUucmVtb3ZlKGl0ZW0sIGVyciA9PiB7XG4gICAgICAgIGlmIChlcnIpIHJldHVybiBjYWxsYmFjayhlcnIpXG4gICAgICAgIGRlbGV0ZUl0ZW0oKVxuICAgICAgfSlcbiAgICB9XG4gIH0pXG59KVxuXG5mdW5jdGlvbiBlbXB0eURpclN5bmMgKGRpcikge1xuICBsZXQgaXRlbXNcbiAgdHJ5IHtcbiAgICBpdGVtcyA9IGZzLnJlYWRkaXJTeW5jKGRpcilcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgcmV0dXJuIG1rZGlyLm1rZGlyc1N5bmMoZGlyKVxuICB9XG5cbiAgaXRlbXMuZm9yRWFjaChpdGVtID0+IHtcbiAgICBpdGVtID0gcGF0aC5qb2luKGRpciwgaXRlbSlcbiAgICByZW1vdmUucmVtb3ZlU3luYyhpdGVtKVxuICB9KVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgZW1wdHlEaXJTeW5jLFxuICBlbXB0eWRpclN5bmM6IGVtcHR5RGlyU3luYyxcbiAgZW1wdHlEaXIsXG4gIGVtcHR5ZGlyOiBlbXB0eURpclxufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2VsZWN0cm9uLXVwZGF0ZXIvbm9kZV9tb2R1bGVzL2ZzLWV4dHJhL2xpYi9lbXB0eS9pbmRleC5qcyIsIid1c2Ugc3RyaWN0J1xuXG5jb25zdCBmaWxlID0gcmVxdWlyZSgnLi9maWxlJylcbmNvbnN0IGxpbmsgPSByZXF1aXJlKCcuL2xpbmsnKVxuY29uc3Qgc3ltbGluayA9IHJlcXVpcmUoJy4vc3ltbGluaycpXG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICAvLyBmaWxlXG4gIGNyZWF0ZUZpbGU6IGZpbGUuY3JlYXRlRmlsZSxcbiAgY3JlYXRlRmlsZVN5bmM6IGZpbGUuY3JlYXRlRmlsZVN5bmMsXG4gIGVuc3VyZUZpbGU6IGZpbGUuY3JlYXRlRmlsZSxcbiAgZW5zdXJlRmlsZVN5bmM6IGZpbGUuY3JlYXRlRmlsZVN5bmMsXG4gIC8vIGxpbmtcbiAgY3JlYXRlTGluazogbGluay5jcmVhdGVMaW5rLFxuICBjcmVhdGVMaW5rU3luYzogbGluay5jcmVhdGVMaW5rU3luYyxcbiAgZW5zdXJlTGluazogbGluay5jcmVhdGVMaW5rLFxuICBlbnN1cmVMaW5rU3luYzogbGluay5jcmVhdGVMaW5rU3luYyxcbiAgLy8gc3ltbGlua1xuICBjcmVhdGVTeW1saW5rOiBzeW1saW5rLmNyZWF0ZVN5bWxpbmssXG4gIGNyZWF0ZVN5bWxpbmtTeW5jOiBzeW1saW5rLmNyZWF0ZVN5bWxpbmtTeW5jLFxuICBlbnN1cmVTeW1saW5rOiBzeW1saW5rLmNyZWF0ZVN5bWxpbmssXG4gIGVuc3VyZVN5bWxpbmtTeW5jOiBzeW1saW5rLmNyZWF0ZVN5bWxpbmtTeW5jXG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvZWxlY3Ryb24tdXBkYXRlci9ub2RlX21vZHVsZXMvZnMtZXh0cmEvbGliL2Vuc3VyZS9pbmRleC5qcyIsIid1c2Ugc3RyaWN0J1xuXG5jb25zdCB1ID0gcmVxdWlyZSgndW5pdmVyc2FsaWZ5JykuZnJvbUNhbGxiYWNrXG5jb25zdCBwYXRoID0gcmVxdWlyZSgncGF0aCcpXG5jb25zdCBmcyA9IHJlcXVpcmUoJ2dyYWNlZnVsLWZzJylcbmNvbnN0IG1rZGlyID0gcmVxdWlyZSgnLi4vbWtkaXJzJylcbmNvbnN0IHBhdGhFeGlzdHMgPSByZXF1aXJlKCcuLi9wYXRoLWV4aXN0cycpLnBhdGhFeGlzdHNcblxuZnVuY3Rpb24gY3JlYXRlRmlsZSAoZmlsZSwgY2FsbGJhY2spIHtcbiAgZnVuY3Rpb24gbWFrZUZpbGUgKCkge1xuICAgIGZzLndyaXRlRmlsZShmaWxlLCAnJywgZXJyID0+IHtcbiAgICAgIGlmIChlcnIpIHJldHVybiBjYWxsYmFjayhlcnIpXG4gICAgICBjYWxsYmFjaygpXG4gICAgfSlcbiAgfVxuXG4gIGZzLnN0YXQoZmlsZSwgKGVyciwgc3RhdHMpID0+IHsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBoYW5kbGUtY2FsbGJhY2stZXJyXG4gICAgaWYgKCFlcnIgJiYgc3RhdHMuaXNGaWxlKCkpIHJldHVybiBjYWxsYmFjaygpXG4gICAgY29uc3QgZGlyID0gcGF0aC5kaXJuYW1lKGZpbGUpXG4gICAgcGF0aEV4aXN0cyhkaXIsIChlcnIsIGRpckV4aXN0cykgPT4ge1xuICAgICAgaWYgKGVycikgcmV0dXJuIGNhbGxiYWNrKGVycilcbiAgICAgIGlmIChkaXJFeGlzdHMpIHJldHVybiBtYWtlRmlsZSgpXG4gICAgICBta2Rpci5ta2RpcnMoZGlyLCBlcnIgPT4ge1xuICAgICAgICBpZiAoZXJyKSByZXR1cm4gY2FsbGJhY2soZXJyKVxuICAgICAgICBtYWtlRmlsZSgpXG4gICAgICB9KVxuICAgIH0pXG4gIH0pXG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUZpbGVTeW5jIChmaWxlKSB7XG4gIGxldCBzdGF0c1xuICB0cnkge1xuICAgIHN0YXRzID0gZnMuc3RhdFN5bmMoZmlsZSlcbiAgfSBjYXRjaCAoZSkge31cbiAgaWYgKHN0YXRzICYmIHN0YXRzLmlzRmlsZSgpKSByZXR1cm5cblxuICBjb25zdCBkaXIgPSBwYXRoLmRpcm5hbWUoZmlsZSlcbiAgaWYgKCFmcy5leGlzdHNTeW5jKGRpcikpIHtcbiAgICBta2Rpci5ta2RpcnNTeW5jKGRpcilcbiAgfVxuXG4gIGZzLndyaXRlRmlsZVN5bmMoZmlsZSwgJycpXG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBjcmVhdGVGaWxlOiB1KGNyZWF0ZUZpbGUpLFxuICBjcmVhdGVGaWxlU3luY1xufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2VsZWN0cm9uLXVwZGF0ZXIvbm9kZV9tb2R1bGVzL2ZzLWV4dHJhL2xpYi9lbnN1cmUvZmlsZS5qcyIsIid1c2Ugc3RyaWN0J1xuXG5jb25zdCB1ID0gcmVxdWlyZSgndW5pdmVyc2FsaWZ5JykuZnJvbUNhbGxiYWNrXG5jb25zdCBwYXRoID0gcmVxdWlyZSgncGF0aCcpXG5jb25zdCBmcyA9IHJlcXVpcmUoJ2dyYWNlZnVsLWZzJylcbmNvbnN0IG1rZGlyID0gcmVxdWlyZSgnLi4vbWtkaXJzJylcbmNvbnN0IHBhdGhFeGlzdHMgPSByZXF1aXJlKCcuLi9wYXRoLWV4aXN0cycpLnBhdGhFeGlzdHNcblxuZnVuY3Rpb24gY3JlYXRlTGluayAoc3JjcGF0aCwgZHN0cGF0aCwgY2FsbGJhY2spIHtcbiAgZnVuY3Rpb24gbWFrZUxpbmsgKHNyY3BhdGgsIGRzdHBhdGgpIHtcbiAgICBmcy5saW5rKHNyY3BhdGgsIGRzdHBhdGgsIGVyciA9PiB7XG4gICAgICBpZiAoZXJyKSByZXR1cm4gY2FsbGJhY2soZXJyKVxuICAgICAgY2FsbGJhY2sobnVsbClcbiAgICB9KVxuICB9XG5cbiAgcGF0aEV4aXN0cyhkc3RwYXRoLCAoZXJyLCBkZXN0aW5hdGlvbkV4aXN0cykgPT4ge1xuICAgIGlmIChlcnIpIHJldHVybiBjYWxsYmFjayhlcnIpXG4gICAgaWYgKGRlc3RpbmF0aW9uRXhpc3RzKSByZXR1cm4gY2FsbGJhY2sobnVsbClcbiAgICBmcy5sc3RhdChzcmNwYXRoLCAoZXJyLCBzdGF0KSA9PiB7XG4gICAgICBpZiAoZXJyKSB7XG4gICAgICAgIGVyci5tZXNzYWdlID0gZXJyLm1lc3NhZ2UucmVwbGFjZSgnbHN0YXQnLCAnZW5zdXJlTGluaycpXG4gICAgICAgIHJldHVybiBjYWxsYmFjayhlcnIpXG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGRpciA9IHBhdGguZGlybmFtZShkc3RwYXRoKVxuICAgICAgcGF0aEV4aXN0cyhkaXIsIChlcnIsIGRpckV4aXN0cykgPT4ge1xuICAgICAgICBpZiAoZXJyKSByZXR1cm4gY2FsbGJhY2soZXJyKVxuICAgICAgICBpZiAoZGlyRXhpc3RzKSByZXR1cm4gbWFrZUxpbmsoc3JjcGF0aCwgZHN0cGF0aClcbiAgICAgICAgbWtkaXIubWtkaXJzKGRpciwgZXJyID0+IHtcbiAgICAgICAgICBpZiAoZXJyKSByZXR1cm4gY2FsbGJhY2soZXJyKVxuICAgICAgICAgIG1ha2VMaW5rKHNyY3BhdGgsIGRzdHBhdGgpXG4gICAgICAgIH0pXG4gICAgICB9KVxuICAgIH0pXG4gIH0pXG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUxpbmtTeW5jIChzcmNwYXRoLCBkc3RwYXRoLCBjYWxsYmFjaykge1xuICBjb25zdCBkZXN0aW5hdGlvbkV4aXN0cyA9IGZzLmV4aXN0c1N5bmMoZHN0cGF0aClcbiAgaWYgKGRlc3RpbmF0aW9uRXhpc3RzKSByZXR1cm4gdW5kZWZpbmVkXG5cbiAgdHJ5IHtcbiAgICBmcy5sc3RhdFN5bmMoc3JjcGF0aClcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgZXJyLm1lc3NhZ2UgPSBlcnIubWVzc2FnZS5yZXBsYWNlKCdsc3RhdCcsICdlbnN1cmVMaW5rJylcbiAgICB0aHJvdyBlcnJcbiAgfVxuXG4gIGNvbnN0IGRpciA9IHBhdGguZGlybmFtZShkc3RwYXRoKVxuICBjb25zdCBkaXJFeGlzdHMgPSBmcy5leGlzdHNTeW5jKGRpcilcbiAgaWYgKGRpckV4aXN0cykgcmV0dXJuIGZzLmxpbmtTeW5jKHNyY3BhdGgsIGRzdHBhdGgpXG4gIG1rZGlyLm1rZGlyc1N5bmMoZGlyKVxuXG4gIHJldHVybiBmcy5saW5rU3luYyhzcmNwYXRoLCBkc3RwYXRoKVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgY3JlYXRlTGluazogdShjcmVhdGVMaW5rKSxcbiAgY3JlYXRlTGlua1N5bmNcbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9lbGVjdHJvbi11cGRhdGVyL25vZGVfbW9kdWxlcy9mcy1leHRyYS9saWIvZW5zdXJlL2xpbmsuanMiLCIndXNlIHN0cmljdCdcblxuY29uc3QgdSA9IHJlcXVpcmUoJ3VuaXZlcnNhbGlmeScpLmZyb21DYWxsYmFja1xuY29uc3QgcGF0aCA9IHJlcXVpcmUoJ3BhdGgnKVxuY29uc3QgZnMgPSByZXF1aXJlKCdncmFjZWZ1bC1mcycpXG5jb25zdCBfbWtkaXJzID0gcmVxdWlyZSgnLi4vbWtkaXJzJylcbmNvbnN0IG1rZGlycyA9IF9ta2RpcnMubWtkaXJzXG5jb25zdCBta2RpcnNTeW5jID0gX21rZGlycy5ta2RpcnNTeW5jXG5cbmNvbnN0IF9zeW1saW5rUGF0aHMgPSByZXF1aXJlKCcuL3N5bWxpbmstcGF0aHMnKVxuY29uc3Qgc3ltbGlua1BhdGhzID0gX3N5bWxpbmtQYXRocy5zeW1saW5rUGF0aHNcbmNvbnN0IHN5bWxpbmtQYXRoc1N5bmMgPSBfc3ltbGlua1BhdGhzLnN5bWxpbmtQYXRoc1N5bmNcblxuY29uc3QgX3N5bWxpbmtUeXBlID0gcmVxdWlyZSgnLi9zeW1saW5rLXR5cGUnKVxuY29uc3Qgc3ltbGlua1R5cGUgPSBfc3ltbGlua1R5cGUuc3ltbGlua1R5cGVcbmNvbnN0IHN5bWxpbmtUeXBlU3luYyA9IF9zeW1saW5rVHlwZS5zeW1saW5rVHlwZVN5bmNcblxuY29uc3QgcGF0aEV4aXN0cyA9IHJlcXVpcmUoJy4uL3BhdGgtZXhpc3RzJykucGF0aEV4aXN0c1xuXG5mdW5jdGlvbiBjcmVhdGVTeW1saW5rIChzcmNwYXRoLCBkc3RwYXRoLCB0eXBlLCBjYWxsYmFjaykge1xuICBjYWxsYmFjayA9ICh0eXBlb2YgdHlwZSA9PT0gJ2Z1bmN0aW9uJykgPyB0eXBlIDogY2FsbGJhY2tcbiAgdHlwZSA9ICh0eXBlb2YgdHlwZSA9PT0gJ2Z1bmN0aW9uJykgPyBmYWxzZSA6IHR5cGVcblxuICBwYXRoRXhpc3RzKGRzdHBhdGgsIChlcnIsIGRlc3RpbmF0aW9uRXhpc3RzKSA9PiB7XG4gICAgaWYgKGVycikgcmV0dXJuIGNhbGxiYWNrKGVycilcbiAgICBpZiAoZGVzdGluYXRpb25FeGlzdHMpIHJldHVybiBjYWxsYmFjayhudWxsKVxuICAgIHN5bWxpbmtQYXRocyhzcmNwYXRoLCBkc3RwYXRoLCAoZXJyLCByZWxhdGl2ZSkgPT4ge1xuICAgICAgaWYgKGVycikgcmV0dXJuIGNhbGxiYWNrKGVycilcbiAgICAgIHNyY3BhdGggPSByZWxhdGl2ZS50b0RzdFxuICAgICAgc3ltbGlua1R5cGUocmVsYXRpdmUudG9Dd2QsIHR5cGUsIChlcnIsIHR5cGUpID0+IHtcbiAgICAgICAgaWYgKGVycikgcmV0dXJuIGNhbGxiYWNrKGVycilcbiAgICAgICAgY29uc3QgZGlyID0gcGF0aC5kaXJuYW1lKGRzdHBhdGgpXG4gICAgICAgIHBhdGhFeGlzdHMoZGlyLCAoZXJyLCBkaXJFeGlzdHMpID0+IHtcbiAgICAgICAgICBpZiAoZXJyKSByZXR1cm4gY2FsbGJhY2soZXJyKVxuICAgICAgICAgIGlmIChkaXJFeGlzdHMpIHJldHVybiBmcy5zeW1saW5rKHNyY3BhdGgsIGRzdHBhdGgsIHR5cGUsIGNhbGxiYWNrKVxuICAgICAgICAgIG1rZGlycyhkaXIsIGVyciA9PiB7XG4gICAgICAgICAgICBpZiAoZXJyKSByZXR1cm4gY2FsbGJhY2soZXJyKVxuICAgICAgICAgICAgZnMuc3ltbGluayhzcmNwYXRoLCBkc3RwYXRoLCB0eXBlLCBjYWxsYmFjaylcbiAgICAgICAgICB9KVxuICAgICAgICB9KVxuICAgICAgfSlcbiAgICB9KVxuICB9KVxufVxuXG5mdW5jdGlvbiBjcmVhdGVTeW1saW5rU3luYyAoc3JjcGF0aCwgZHN0cGF0aCwgdHlwZSwgY2FsbGJhY2spIHtcbiAgY2FsbGJhY2sgPSAodHlwZW9mIHR5cGUgPT09ICdmdW5jdGlvbicpID8gdHlwZSA6IGNhbGxiYWNrXG4gIHR5cGUgPSAodHlwZW9mIHR5cGUgPT09ICdmdW5jdGlvbicpID8gZmFsc2UgOiB0eXBlXG5cbiAgY29uc3QgZGVzdGluYXRpb25FeGlzdHMgPSBmcy5leGlzdHNTeW5jKGRzdHBhdGgpXG4gIGlmIChkZXN0aW5hdGlvbkV4aXN0cykgcmV0dXJuIHVuZGVmaW5lZFxuXG4gIGNvbnN0IHJlbGF0aXZlID0gc3ltbGlua1BhdGhzU3luYyhzcmNwYXRoLCBkc3RwYXRoKVxuICBzcmNwYXRoID0gcmVsYXRpdmUudG9Ec3RcbiAgdHlwZSA9IHN5bWxpbmtUeXBlU3luYyhyZWxhdGl2ZS50b0N3ZCwgdHlwZSlcbiAgY29uc3QgZGlyID0gcGF0aC5kaXJuYW1lKGRzdHBhdGgpXG4gIGNvbnN0IGV4aXN0cyA9IGZzLmV4aXN0c1N5bmMoZGlyKVxuICBpZiAoZXhpc3RzKSByZXR1cm4gZnMuc3ltbGlua1N5bmMoc3JjcGF0aCwgZHN0cGF0aCwgdHlwZSlcbiAgbWtkaXJzU3luYyhkaXIpXG4gIHJldHVybiBmcy5zeW1saW5rU3luYyhzcmNwYXRoLCBkc3RwYXRoLCB0eXBlKVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgY3JlYXRlU3ltbGluazogdShjcmVhdGVTeW1saW5rKSxcbiAgY3JlYXRlU3ltbGlua1N5bmNcbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9lbGVjdHJvbi11cGRhdGVyL25vZGVfbW9kdWxlcy9mcy1leHRyYS9saWIvZW5zdXJlL3N5bWxpbmsuanMiLCIndXNlIHN0cmljdCdcblxuY29uc3QgcGF0aCA9IHJlcXVpcmUoJ3BhdGgnKVxuY29uc3QgZnMgPSByZXF1aXJlKCdncmFjZWZ1bC1mcycpXG5jb25zdCBwYXRoRXhpc3RzID0gcmVxdWlyZSgnLi4vcGF0aC1leGlzdHMnKS5wYXRoRXhpc3RzXG5cbi8qKlxuICogRnVuY3Rpb24gdGhhdCByZXR1cm5zIHR3byB0eXBlcyBvZiBwYXRocywgb25lIHJlbGF0aXZlIHRvIHN5bWxpbmssIGFuZCBvbmVcbiAqIHJlbGF0aXZlIHRvIHRoZSBjdXJyZW50IHdvcmtpbmcgZGlyZWN0b3J5LiBDaGVja3MgaWYgcGF0aCBpcyBhYnNvbHV0ZSBvclxuICogcmVsYXRpdmUuIElmIHRoZSBwYXRoIGlzIHJlbGF0aXZlLCB0aGlzIGZ1bmN0aW9uIGNoZWNrcyBpZiB0aGUgcGF0aCBpc1xuICogcmVsYXRpdmUgdG8gc3ltbGluayBvciByZWxhdGl2ZSB0byBjdXJyZW50IHdvcmtpbmcgZGlyZWN0b3J5LiBUaGlzIGlzIGFuXG4gKiBpbml0aWF0aXZlIHRvIGZpbmQgYSBzbWFydGVyIGBzcmNwYXRoYCB0byBzdXBwbHkgd2hlbiBidWlsZGluZyBzeW1saW5rcy5cbiAqIFRoaXMgYWxsb3dzIHlvdSB0byBkZXRlcm1pbmUgd2hpY2ggcGF0aCB0byB1c2Ugb3V0IG9mIG9uZSBvZiB0aHJlZSBwb3NzaWJsZVxuICogdHlwZXMgb2Ygc291cmNlIHBhdGhzLiBUaGUgZmlyc3QgaXMgYW4gYWJzb2x1dGUgcGF0aC4gVGhpcyBpcyBkZXRlY3RlZCBieVxuICogYHBhdGguaXNBYnNvbHV0ZSgpYC4gV2hlbiBhbiBhYnNvbHV0ZSBwYXRoIGlzIHByb3ZpZGVkLCBpdCBpcyBjaGVja2VkIHRvXG4gKiBzZWUgaWYgaXQgZXhpc3RzLiBJZiBpdCBkb2VzIGl0J3MgdXNlZCwgaWYgbm90IGFuIGVycm9yIGlzIHJldHVybmVkXG4gKiAoY2FsbGJhY2spLyB0aHJvd24gKHN5bmMpLiBUaGUgb3RoZXIgdHdvIG9wdGlvbnMgZm9yIGBzcmNwYXRoYCBhcmUgYVxuICogcmVsYXRpdmUgdXJsLiBCeSBkZWZhdWx0IE5vZGUncyBgZnMuc3ltbGlua2Agd29ya3MgYnkgY3JlYXRpbmcgYSBzeW1saW5rXG4gKiB1c2luZyBgZHN0cGF0aGAgYW5kIGV4cGVjdHMgdGhlIGBzcmNwYXRoYCB0byBiZSByZWxhdGl2ZSB0byB0aGUgbmV3bHlcbiAqIGNyZWF0ZWQgc3ltbGluay4gSWYgeW91IHByb3ZpZGUgYSBgc3JjcGF0aGAgdGhhdCBkb2VzIG5vdCBleGlzdCBvbiB0aGUgZmlsZVxuICogc3lzdGVtIGl0IHJlc3VsdHMgaW4gYSBicm9rZW4gc3ltbGluay4gVG8gbWluaW1pemUgdGhpcywgdGhlIGZ1bmN0aW9uXG4gKiBjaGVja3MgdG8gc2VlIGlmIHRoZSAncmVsYXRpdmUgdG8gc3ltbGluaycgc291cmNlIGZpbGUgZXhpc3RzLCBhbmQgaWYgaXRcbiAqIGRvZXMgaXQgd2lsbCB1c2UgaXQuIElmIGl0IGRvZXMgbm90LCBpdCBjaGVja3MgaWYgdGhlcmUncyBhIGZpbGUgdGhhdFxuICogZXhpc3RzIHRoYXQgaXMgcmVsYXRpdmUgdG8gdGhlIGN1cnJlbnQgd29ya2luZyBkaXJlY3RvcnksIGlmIGRvZXMgaXRzIHVzZWQuXG4gKiBUaGlzIHByZXNlcnZlcyB0aGUgZXhwZWN0YXRpb25zIG9mIHRoZSBvcmlnaW5hbCBmcy5zeW1saW5rIHNwZWMgYW5kIGFkZHNcbiAqIHRoZSBhYmlsaXR5IHRvIHBhc3MgaW4gYHJlbGF0aXZlIHRvIGN1cnJlbnQgd29ya2luZyBkaXJlY290cnlgIHBhdGhzLlxuICovXG5cbmZ1bmN0aW9uIHN5bWxpbmtQYXRocyAoc3JjcGF0aCwgZHN0cGF0aCwgY2FsbGJhY2spIHtcbiAgaWYgKHBhdGguaXNBYnNvbHV0ZShzcmNwYXRoKSkge1xuICAgIHJldHVybiBmcy5sc3RhdChzcmNwYXRoLCAoZXJyLCBzdGF0KSA9PiB7XG4gICAgICBpZiAoZXJyKSB7XG4gICAgICAgIGVyci5tZXNzYWdlID0gZXJyLm1lc3NhZ2UucmVwbGFjZSgnbHN0YXQnLCAnZW5zdXJlU3ltbGluaycpXG4gICAgICAgIHJldHVybiBjYWxsYmFjayhlcnIpXG4gICAgICB9XG4gICAgICByZXR1cm4gY2FsbGJhY2sobnVsbCwge1xuICAgICAgICAndG9Dd2QnOiBzcmNwYXRoLFxuICAgICAgICAndG9Ec3QnOiBzcmNwYXRoXG4gICAgICB9KVxuICAgIH0pXG4gIH0gZWxzZSB7XG4gICAgY29uc3QgZHN0ZGlyID0gcGF0aC5kaXJuYW1lKGRzdHBhdGgpXG4gICAgY29uc3QgcmVsYXRpdmVUb0RzdCA9IHBhdGguam9pbihkc3RkaXIsIHNyY3BhdGgpXG4gICAgcmV0dXJuIHBhdGhFeGlzdHMocmVsYXRpdmVUb0RzdCwgKGVyciwgZXhpc3RzKSA9PiB7XG4gICAgICBpZiAoZXJyKSByZXR1cm4gY2FsbGJhY2soZXJyKVxuICAgICAgaWYgKGV4aXN0cykge1xuICAgICAgICByZXR1cm4gY2FsbGJhY2sobnVsbCwge1xuICAgICAgICAgICd0b0N3ZCc6IHJlbGF0aXZlVG9Ec3QsXG4gICAgICAgICAgJ3RvRHN0Jzogc3JjcGF0aFxuICAgICAgICB9KVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGZzLmxzdGF0KHNyY3BhdGgsIChlcnIsIHN0YXQpID0+IHtcbiAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICBlcnIubWVzc2FnZSA9IGVyci5tZXNzYWdlLnJlcGxhY2UoJ2xzdGF0JywgJ2Vuc3VyZVN5bWxpbmsnKVxuICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGVycilcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKG51bGwsIHtcbiAgICAgICAgICAgICd0b0N3ZCc6IHNyY3BhdGgsXG4gICAgICAgICAgICAndG9Ec3QnOiBwYXRoLnJlbGF0aXZlKGRzdGRpciwgc3JjcGF0aClcbiAgICAgICAgICB9KVxuICAgICAgICB9KVxuICAgICAgfVxuICAgIH0pXG4gIH1cbn1cblxuZnVuY3Rpb24gc3ltbGlua1BhdGhzU3luYyAoc3JjcGF0aCwgZHN0cGF0aCkge1xuICBsZXQgZXhpc3RzXG4gIGlmIChwYXRoLmlzQWJzb2x1dGUoc3JjcGF0aCkpIHtcbiAgICBleGlzdHMgPSBmcy5leGlzdHNTeW5jKHNyY3BhdGgpXG4gICAgaWYgKCFleGlzdHMpIHRocm93IG5ldyBFcnJvcignYWJzb2x1dGUgc3JjcGF0aCBkb2VzIG5vdCBleGlzdCcpXG4gICAgcmV0dXJuIHtcbiAgICAgICd0b0N3ZCc6IHNyY3BhdGgsXG4gICAgICAndG9Ec3QnOiBzcmNwYXRoXG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGNvbnN0IGRzdGRpciA9IHBhdGguZGlybmFtZShkc3RwYXRoKVxuICAgIGNvbnN0IHJlbGF0aXZlVG9Ec3QgPSBwYXRoLmpvaW4oZHN0ZGlyLCBzcmNwYXRoKVxuICAgIGV4aXN0cyA9IGZzLmV4aXN0c1N5bmMocmVsYXRpdmVUb0RzdClcbiAgICBpZiAoZXhpc3RzKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICAndG9Dd2QnOiByZWxhdGl2ZVRvRHN0LFxuICAgICAgICAndG9Ec3QnOiBzcmNwYXRoXG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGV4aXN0cyA9IGZzLmV4aXN0c1N5bmMoc3JjcGF0aClcbiAgICAgIGlmICghZXhpc3RzKSB0aHJvdyBuZXcgRXJyb3IoJ3JlbGF0aXZlIHNyY3BhdGggZG9lcyBub3QgZXhpc3QnKVxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgJ3RvQ3dkJzogc3JjcGF0aCxcbiAgICAgICAgJ3RvRHN0JzogcGF0aC5yZWxhdGl2ZShkc3RkaXIsIHNyY3BhdGgpXG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBzeW1saW5rUGF0aHMsXG4gIHN5bWxpbmtQYXRoc1N5bmNcbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9lbGVjdHJvbi11cGRhdGVyL25vZGVfbW9kdWxlcy9mcy1leHRyYS9saWIvZW5zdXJlL3N5bWxpbmstcGF0aHMuanMiLCIndXNlIHN0cmljdCdcblxuY29uc3QgZnMgPSByZXF1aXJlKCdncmFjZWZ1bC1mcycpXG5cbmZ1bmN0aW9uIHN5bWxpbmtUeXBlIChzcmNwYXRoLCB0eXBlLCBjYWxsYmFjaykge1xuICBjYWxsYmFjayA9ICh0eXBlb2YgdHlwZSA9PT0gJ2Z1bmN0aW9uJykgPyB0eXBlIDogY2FsbGJhY2tcbiAgdHlwZSA9ICh0eXBlb2YgdHlwZSA9PT0gJ2Z1bmN0aW9uJykgPyBmYWxzZSA6IHR5cGVcbiAgaWYgKHR5cGUpIHJldHVybiBjYWxsYmFjayhudWxsLCB0eXBlKVxuICBmcy5sc3RhdChzcmNwYXRoLCAoZXJyLCBzdGF0cykgPT4ge1xuICAgIGlmIChlcnIpIHJldHVybiBjYWxsYmFjayhudWxsLCAnZmlsZScpXG4gICAgdHlwZSA9IChzdGF0cyAmJiBzdGF0cy5pc0RpcmVjdG9yeSgpKSA/ICdkaXInIDogJ2ZpbGUnXG4gICAgY2FsbGJhY2sobnVsbCwgdHlwZSlcbiAgfSlcbn1cblxuZnVuY3Rpb24gc3ltbGlua1R5cGVTeW5jIChzcmNwYXRoLCB0eXBlKSB7XG4gIGxldCBzdGF0c1xuXG4gIGlmICh0eXBlKSByZXR1cm4gdHlwZVxuICB0cnkge1xuICAgIHN0YXRzID0gZnMubHN0YXRTeW5jKHNyY3BhdGgpXG4gIH0gY2F0Y2ggKGUpIHtcbiAgICByZXR1cm4gJ2ZpbGUnXG4gIH1cbiAgcmV0dXJuIChzdGF0cyAmJiBzdGF0cy5pc0RpcmVjdG9yeSgpKSA/ICdkaXInIDogJ2ZpbGUnXG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBzeW1saW5rVHlwZSxcbiAgc3ltbGlua1R5cGVTeW5jXG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvZWxlY3Ryb24tdXBkYXRlci9ub2RlX21vZHVsZXMvZnMtZXh0cmEvbGliL2Vuc3VyZS9zeW1saW5rLXR5cGUuanMiLCIndXNlIHN0cmljdCdcblxuY29uc3QgdSA9IHJlcXVpcmUoJ3VuaXZlcnNhbGlmeScpLmZyb21DYWxsYmFja1xuY29uc3QgZnMgPSByZXF1aXJlKCdncmFjZWZ1bC1mcycpXG5jb25zdCBwYXRoID0gcmVxdWlyZSgncGF0aCcpXG5jb25zdCBta2RpciA9IHJlcXVpcmUoJy4uL21rZGlycycpXG5jb25zdCBwYXRoRXhpc3RzID0gcmVxdWlyZSgnLi4vcGF0aC1leGlzdHMnKS5wYXRoRXhpc3RzXG5cbmZ1bmN0aW9uIG91dHB1dEZpbGUgKGZpbGUsIGRhdGEsIGVuY29kaW5nLCBjYWxsYmFjaykge1xuICBpZiAodHlwZW9mIGVuY29kaW5nID09PSAnZnVuY3Rpb24nKSB7XG4gICAgY2FsbGJhY2sgPSBlbmNvZGluZ1xuICAgIGVuY29kaW5nID0gJ3V0ZjgnXG4gIH1cblxuICBjb25zdCBkaXIgPSBwYXRoLmRpcm5hbWUoZmlsZSlcbiAgcGF0aEV4aXN0cyhkaXIsIChlcnIsIGl0RG9lcykgPT4ge1xuICAgIGlmIChlcnIpIHJldHVybiBjYWxsYmFjayhlcnIpXG4gICAgaWYgKGl0RG9lcykgcmV0dXJuIGZzLndyaXRlRmlsZShmaWxlLCBkYXRhLCBlbmNvZGluZywgY2FsbGJhY2spXG5cbiAgICBta2Rpci5ta2RpcnMoZGlyLCBlcnIgPT4ge1xuICAgICAgaWYgKGVycikgcmV0dXJuIGNhbGxiYWNrKGVycilcblxuICAgICAgZnMud3JpdGVGaWxlKGZpbGUsIGRhdGEsIGVuY29kaW5nLCBjYWxsYmFjaylcbiAgICB9KVxuICB9KVxufVxuXG5mdW5jdGlvbiBvdXRwdXRGaWxlU3luYyAoZmlsZSwgZGF0YSwgZW5jb2RpbmcpIHtcbiAgY29uc3QgZGlyID0gcGF0aC5kaXJuYW1lKGZpbGUpXG4gIGlmIChmcy5leGlzdHNTeW5jKGRpcikpIHtcbiAgICByZXR1cm4gZnMud3JpdGVGaWxlU3luYy5hcHBseShmcywgYXJndW1lbnRzKVxuICB9XG4gIG1rZGlyLm1rZGlyc1N5bmMoZGlyKVxuICBmcy53cml0ZUZpbGVTeW5jLmFwcGx5KGZzLCBhcmd1bWVudHMpXG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBvdXRwdXRGaWxlOiB1KG91dHB1dEZpbGUpLFxuICBvdXRwdXRGaWxlU3luY1xufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2VsZWN0cm9uLXVwZGF0ZXIvbm9kZV9tb2R1bGVzL2ZzLWV4dHJhL2xpYi9vdXRwdXQvaW5kZXguanMiLCJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5naXRodWJVcmwgPSBnaXRodWJVcmw7XG5leHBvcnRzLmdldFMzTGlrZVByb3ZpZGVyQmFzZVVybCA9IGdldFMzTGlrZVByb3ZpZGVyQmFzZVVybDtcbi8qKiBAcHJpdmF0ZSAqL1xuZnVuY3Rpb24gZ2l0aHViVXJsKG9wdGlvbnMsIGRlZmF1bHRIb3N0ID0gXCJnaXRodWIuY29tXCIpIHtcbiAgICByZXR1cm4gYCR7b3B0aW9ucy5wcm90b2NvbCB8fCBcImh0dHBzXCJ9Oi8vJHtvcHRpb25zLmhvc3QgfHwgZGVmYXVsdEhvc3R9YDtcbn1cbmZ1bmN0aW9uIGdldFMzTGlrZVByb3ZpZGVyQmFzZVVybChjb25maWd1cmF0aW9uKSB7XG4gICAgY29uc3QgcHJvdmlkZXIgPSBjb25maWd1cmF0aW9uLnByb3ZpZGVyO1xuICAgIGlmIChwcm92aWRlciA9PT0gXCJzM1wiKSB7XG4gICAgICAgIHJldHVybiBzM1VybChjb25maWd1cmF0aW9uKTtcbiAgICB9XG4gICAgaWYgKHByb3ZpZGVyID09PSBcInNwYWNlc1wiKSB7XG4gICAgICAgIHJldHVybiBzcGFjZXNVcmwoY29uZmlndXJhdGlvbik7XG4gICAgfVxuICAgIHRocm93IG5ldyBFcnJvcihgTm90IHN1cHBvcnRlZCBwcm92aWRlcjogJHtwcm92aWRlcn1gKTtcbn1cbmZ1bmN0aW9uIHMzVXJsKG9wdGlvbnMpIHtcbiAgICBsZXQgdXJsO1xuICAgIGlmIChvcHRpb25zLmVuZHBvaW50ICE9IG51bGwpIHtcbiAgICAgICAgdXJsID0gYCR7b3B0aW9ucy5lbmRwb2ludH0vJHtvcHRpb25zLmJ1Y2tldH1gO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGlmICghb3B0aW9ucy5idWNrZXQuaW5jbHVkZXMoXCIuXCIpKSB7XG4gICAgICAgICAgICBpZiAob3B0aW9ucy5yZWdpb24gPT09IFwiY24tbm9ydGgtMVwiKSB7XG4gICAgICAgICAgICAgICAgdXJsID0gYGh0dHBzOi8vJHtvcHRpb25zLmJ1Y2tldH0uczMuJHtvcHRpb25zLnJlZ2lvbn0uYW1hem9uYXdzLmNvbS5jbmA7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHVybCA9IGBodHRwczovLyR7b3B0aW9ucy5idWNrZXR9LnMzLmFtYXpvbmF3cy5jb21gO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKG9wdGlvbnMucmVnaW9uID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEJ1Y2tldCBuYW1lIFwiJHtvcHRpb25zLmJ1Y2tldH1cIiBpbmNsdWRlcyBhIGRvdCwgYnV0IFMzIHJlZ2lvbiBpcyBtaXNzaW5nYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBzcGVjaWFsIGNhc2UsIHNlZSBodHRwOi8vZG9jcy5hd3MuYW1hem9uLmNvbS9BbWF6b25TMy9sYXRlc3QvZGV2L1VzaW5nQnVja2V0Lmh0bWwjYWNjZXNzLWJ1Y2tldC1pbnRyb1xuICAgICAgICAgICAgdXJsID0gb3B0aW9ucy5yZWdpb24gPT09IFwidXMtZWFzdC0xXCIgPyBgaHR0cHM6Ly9zMy5hbWF6b25hd3MuY29tLyR7b3B0aW9ucy5idWNrZXR9YCA6IGBodHRwczovL3MzLSR7b3B0aW9ucy5yZWdpb259LmFtYXpvbmF3cy5jb20vJHtvcHRpb25zLmJ1Y2tldH1gO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChvcHRpb25zLnBhdGggIT0gbnVsbCkge1xuICAgICAgICB1cmwgKz0gYC8ke29wdGlvbnMucGF0aH1gO1xuICAgIH1cbiAgICByZXR1cm4gdXJsO1xufVxuZnVuY3Rpb24gc3BhY2VzVXJsKG9wdGlvbnMpIHtcbiAgICBpZiAob3B0aW9ucy5uYW1lID09IG51bGwpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBuYW1lIGlzIG1pc3NpbmdgKTtcbiAgICB9XG4gICAgaWYgKG9wdGlvbnMucmVnaW9uID09IG51bGwpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGByZWdpb24gaXMgbWlzc2luZ2ApO1xuICAgIH1cbiAgICBsZXQgdXJsID0gYGh0dHBzOi8vJHtvcHRpb25zLm5hbWV9LiR7b3B0aW9ucy5yZWdpb259LmRpZ2l0YWxvY2VhbnNwYWNlcy5jb21gO1xuICAgIGlmIChvcHRpb25zLnBhdGggIT0gbnVsbCkge1xuICAgICAgICB1cmwgKz0gYC8ke29wdGlvbnMucGF0aH1gO1xuICAgIH1cbiAgICByZXR1cm4gdXJsO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cHVibGlzaE9wdGlvbnMuanMubWFwXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2VsZWN0cm9uLXVwZGF0ZXIvbm9kZV9tb2R1bGVzL2J1aWxkZXItdXRpbC1ydW50aW1lL291dC9wdWJsaXNoT3B0aW9ucy5qcyIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5wYXJzZURuID0gcGFyc2VEbjtcbmZ1bmN0aW9uIHBhcnNlRG4oc2VxKSB7XG4gICAgbGV0IHF1b3RlZCA9IGZhbHNlO1xuICAgIGxldCBrZXkgPSBudWxsO1xuICAgIGxldCB0b2tlbiA9IFwiXCI7XG4gICAgbGV0IG5leHROb25TcGFjZSA9IDA7XG4gICAgc2VxID0gc2VxLnRyaW0oKTtcbiAgICBjb25zdCByZXN1bHQgPSBuZXcgTWFwKCk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPD0gc2VxLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmIChpID09PSBzZXEubGVuZ3RoKSB7XG4gICAgICAgICAgICBpZiAoa2V5ICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnNldChrZXksIHRva2VuKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGNoID0gc2VxW2ldO1xuICAgICAgICBpZiAocXVvdGVkKSB7XG4gICAgICAgICAgICBpZiAoY2ggPT09ICdcIicpIHtcbiAgICAgICAgICAgICAgICBxdW90ZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmIChjaCA9PT0gJ1wiJykge1xuICAgICAgICAgICAgICAgIHF1b3RlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY2ggPT09IFwiXFxcXFwiKSB7XG4gICAgICAgICAgICAgICAgaSsrO1xuICAgICAgICAgICAgICAgIGNvbnN0IG9yZCA9IHBhcnNlSW50KHNlcS5zbGljZShpLCBpICsgMiksIDE2KTtcbiAgICAgICAgICAgICAgICBpZiAoTnVtYmVyLmlzTmFOKG9yZCkpIHtcbiAgICAgICAgICAgICAgICAgICAgdG9rZW4gKz0gc2VxW2ldO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGkrKztcbiAgICAgICAgICAgICAgICAgICAgdG9rZW4gKz0gU3RyaW5nLmZyb21DaGFyQ29kZShvcmQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChrZXkgPT09IG51bGwgJiYgY2ggPT09IFwiPVwiKSB7XG4gICAgICAgICAgICAgICAga2V5ID0gdG9rZW47XG4gICAgICAgICAgICAgICAgdG9rZW4gPSBcIlwiO1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGNoID09PSBcIixcIiB8fCBjaCA9PT0gXCI7XCIgfHwgY2ggPT09IFwiK1wiKSB7XG4gICAgICAgICAgICAgICAgaWYgKGtleSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQuc2V0KGtleSwgdG9rZW4pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBrZXkgPSBudWxsO1xuICAgICAgICAgICAgICAgIHRva2VuID0gXCJcIjtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoY2ggPT09IFwiIFwiICYmICFxdW90ZWQpIHtcbiAgICAgICAgICAgIGlmICh0b2tlbi5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpID4gbmV4dE5vblNwYWNlKSB7XG4gICAgICAgICAgICAgICAgbGV0IGogPSBpO1xuICAgICAgICAgICAgICAgIHdoaWxlIChzZXFbal0gPT09IFwiIFwiKSB7XG4gICAgICAgICAgICAgICAgICAgIGorKztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbmV4dE5vblNwYWNlID0gajtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChuZXh0Tm9uU3BhY2UgPj0gc2VxLmxlbmd0aCB8fCBzZXFbbmV4dE5vblNwYWNlXSA9PT0gXCIsXCIgfHwgc2VxW25leHROb25TcGFjZV0gPT09IFwiO1wiIHx8IGtleSA9PT0gbnVsbCAmJiBzZXFbbmV4dE5vblNwYWNlXSA9PT0gXCI9XCIgfHwga2V5ICE9PSBudWxsICYmIHNlcVtuZXh0Tm9uU3BhY2VdID09PSBcIitcIikge1xuICAgICAgICAgICAgICAgIGkgPSBuZXh0Tm9uU3BhY2UgLSAxO1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRva2VuICs9IGNoO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cmZjMjI1M1BhcnNlci5qcy5tYXBcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvZWxlY3Ryb24tdXBkYXRlci9ub2RlX21vZHVsZXMvYnVpbGRlci11dGlsLXJ1bnRpbWUvb3V0L3JmYzIyNTNQYXJzZXIuanMiLCJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5uaWwgPSBleHBvcnRzLlVVSUQgPSB1bmRlZmluZWQ7XG5cbnZhciBfY3J5cHRvO1xuXG5mdW5jdGlvbiBfbG9hZF9jcnlwdG8oKSB7XG4gICAgcmV0dXJuIF9jcnlwdG8gPSByZXF1aXJlKFwiY3J5cHRvXCIpO1xufVxuXG52YXIgX2luZGV4O1xuXG5mdW5jdGlvbiBfbG9hZF9pbmRleCgpIHtcbiAgICByZXR1cm4gX2luZGV4ID0gcmVxdWlyZShcIi4vaW5kZXhcIik7XG59XG5cbmNvbnN0IGludmFsaWROYW1lID0gXCJvcHRpb25zLm5hbWUgbXVzdCBiZSBlaXRoZXIgYSBzdHJpbmcgb3IgYSBCdWZmZXJcIjtcbmNvbnN0IG1vcmVUaGFuMTAwMDAgPSBcImNhbiBub3QgZ2VuZXJhdGUgbW9yZSB0aGFuIDEwMDAwIFVVSURzIHBlciBzZWNvbmRcIjtcbi8vIE5vZGUgSUQgYWNjb3JkaW5nIHRvIHJmYzQxMjIjc2VjdGlvbi00LjVcbmNvbnN0IHJhbmRvbUhvc3QgPSAoMCwgKF9jcnlwdG8gfHwgX2xvYWRfY3J5cHRvKCkpLnJhbmRvbUJ5dGVzKSgxNik7XG5yYW5kb21Ib3N0WzBdID0gcmFuZG9tSG9zdFswXSB8IDB4MDE7XG4vLyByYW5kb21pemUgY2xvY2tTZXEgaW5pdGlhbGx5LCBhcyBwZXIgcmZjNDEyMiNzZWN0aW9uLTQuMS41XG5jb25zdCBzZWVkID0gKDAsIChfY3J5cHRvIHx8IF9sb2FkX2NyeXB0bygpKS5yYW5kb21CeXRlcykoMik7XG5sZXQgY2xvY2tTZXEgPSAoc2VlZFswXSB8IHNlZWRbMV0gPDwgOCkgJiAweDNmZmY7XG4vLyBjbG9jayB2YWx1ZXNcbmxldCBsYXN0TVRpbWUgPSAwO1xubGV0IGxhc3ROVGltZSA9IDA7XG4vLyBsb29rdXAgdGFibGUgaGV4IHRvIGJ5dGVcbmNvbnN0IGhleDJieXRlID0ge307XG4vLyBsb29rdXAgdGFibGUgYnl0ZSB0byBoZXhcbmNvbnN0IGJ5dGUyaGV4ID0gW107XG4vLyBwb3B1bGF0ZSBsb29rdXAgdGFibGVzXG5mb3IgKGxldCBpID0gMDsgaSA8IDI1NjsgaSsrKSB7XG4gICAgY29uc3QgaGV4ID0gKGkgKyAweDEwMCkudG9TdHJpbmcoMTYpLnN1YnN0cigxKTtcbiAgICBoZXgyYnl0ZVtoZXhdID0gaTtcbiAgICBieXRlMmhleFtpXSA9IGhleDtcbn1cbi8vIFVVSUQgY2xhc3NcbmNsYXNzIFVVSUQge1xuICAgIGNvbnN0cnVjdG9yKHV1aWQpIHtcbiAgICAgICAgY29uc3QgY2hlY2sgPSBVVUlELmNoZWNrKHV1aWQpO1xuICAgICAgICBpZiAoIWNoZWNrKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJub3QgYSBVVUlEXCIpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudmVyc2lvbiA9IGNoZWNrLnZlcnNpb247XG4gICAgICAgIGlmIChjaGVjay5mb3JtYXQgPT09IFwiYXNjaWlcIikge1xuICAgICAgICAgICAgdGhpcy5hc2NpaSA9IHV1aWQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmJpbmFyeSA9IHV1aWQ7XG4gICAgICAgIH1cbiAgICB9XG4gICAgc3RhdGljIHYxKCkge1xuICAgICAgICByZXR1cm4gdXVpZFRpbWVCYXNlZChyYW5kb21Ib3N0KTtcbiAgICB9XG4gICAgc3RhdGljIHY1KG5hbWUsIG5hbWVzcGFjZSkge1xuICAgICAgICByZXR1cm4gdXVpZE5hbWVkKG5hbWUsIFwic2hhMVwiLCAweDUwLCBuYW1lc3BhY2UpO1xuICAgIH1cbiAgICB0b1N0cmluZygpIHtcbiAgICAgICAgaWYgKHRoaXMuYXNjaWkgPT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5hc2NpaSA9IHN0cmluZ2lmeSh0aGlzLmJpbmFyeSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuYXNjaWk7XG4gICAgfVxuICAgIHRvQnVmZmVyKCkge1xuICAgICAgICBpZiAodGhpcy5iaW5hcnkgPT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5iaW5hcnkgPSBVVUlELnBhcnNlKHRoaXMuYXNjaWkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBCdWZmZXIuZnJvbSh0aGlzLmJpbmFyeSk7XG4gICAgfVxuICAgIGluc3BlY3QoKSB7XG4gICAgICAgIHJldHVybiBgVVVJRCB2JHt0aGlzLnZlcnNpb259ICR7dGhpcy50b1N0cmluZygpfWA7XG4gICAgfVxuICAgIHN0YXRpYyBjaGVjayh1dWlkLCBvZmZzZXQgPSAwKSB7XG4gICAgICAgIGlmICh0eXBlb2YgdXVpZCA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgdXVpZCA9IHV1aWQudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICAgIGlmICghL15bYS1mMC05XXs4fShcXC1bYS1mMC05XXs0fSl7M31cXC0oW2EtZjAtOV17MTJ9KSQvLnRlc3QodXVpZCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodXVpZCA9PT0gXCIwMDAwMDAwMC0wMDAwLTAwMDAtMDAwMC0wMDAwMDAwMDAwMDBcIikge1xuICAgICAgICAgICAgICAgIHJldHVybiB7IHZlcnNpb246IHVuZGVmaW5lZCwgdmFyaWFudDogXCJuaWxcIiwgZm9ybWF0OiBcImFzY2lpXCIgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdmVyc2lvbjogKGhleDJieXRlW3V1aWRbMTRdICsgdXVpZFsxNV1dICYgMHhmMCkgPj4gNCxcbiAgICAgICAgICAgICAgICB2YXJpYW50OiBnZXRWYXJpYW50KChoZXgyYnl0ZVt1dWlkWzE5XSArIHV1aWRbMjBdXSAmIDB4ZTApID4+IDUpLFxuICAgICAgICAgICAgICAgIGZvcm1hdDogXCJhc2NpaVwiXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGlmIChCdWZmZXIuaXNCdWZmZXIodXVpZCkpIHtcbiAgICAgICAgICAgIGlmICh1dWlkLmxlbmd0aCA8IG9mZnNldCArIDE2KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IGkgPSAwO1xuICAgICAgICAgICAgZm9yICg7IGkgPCAxNjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKHV1aWRbb2Zmc2V0ICsgaV0gIT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGkgPT09IDE2KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgdmVyc2lvbjogdW5kZWZpbmVkLCB2YXJpYW50OiBcIm5pbFwiLCBmb3JtYXQ6IFwiYmluYXJ5XCIgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdmVyc2lvbjogKHV1aWRbb2Zmc2V0ICsgNl0gJiAweGYwKSA+PiA0LFxuICAgICAgICAgICAgICAgIHZhcmlhbnQ6IGdldFZhcmlhbnQoKHV1aWRbb2Zmc2V0ICsgOF0gJiAweGUwKSA+PiA1KSxcbiAgICAgICAgICAgICAgICBmb3JtYXQ6IFwiYmluYXJ5XCJcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgKDAsIChfaW5kZXggfHwgX2xvYWRfaW5kZXgoKSkubmV3RXJyb3IpKFwiVW5rbm93biB0eXBlIG9mIHV1aWRcIiwgXCJFUlJfVU5LTk9XTl9VVUlEX1RZUEVcIik7XG4gICAgfVxuICAgIC8vIHJlYWQgc3RyaW5naWZpZWQgdXVpZCBpbnRvIGEgQnVmZmVyXG4gICAgc3RhdGljIHBhcnNlKGlucHV0KSB7XG4gICAgICAgIGNvbnN0IGJ1ZmZlciA9IEJ1ZmZlci5hbGxvY1Vuc2FmZSgxNik7XG4gICAgICAgIGxldCBqID0gMDtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCAxNjsgaSsrKSB7XG4gICAgICAgICAgICBidWZmZXJbaV0gPSBoZXgyYnl0ZVtpbnB1dFtqKytdICsgaW5wdXRbaisrXV07XG4gICAgICAgICAgICBpZiAoaSA9PT0gMyB8fCBpID09PSA1IHx8IGkgPT09IDcgfHwgaSA9PT0gOSkge1xuICAgICAgICAgICAgICAgIGogKz0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYnVmZmVyO1xuICAgIH1cbn1cbmV4cG9ydHMuVVVJRCA9IFVVSUQ7IC8vIGZyb20gcmZjNDEyMiNhcHBlbmRpeC1DXG5cblVVSUQuVVJMID0gbmV3IFVVSUQoXCI2YmE3YjgxMS05ZGFkLTExZDEtODBiNC0wMGMwNGZkNDMwYzhcIik7XG5VVUlELk9JRCA9IFVVSUQucGFyc2UoXCI2YmE3YjgxMi05ZGFkLTExZDEtODBiNC0wMGMwNGZkNDMwYzhcIik7XG4vLyBhY2NvcmRpbmcgdG8gcmZjNDEyMiNzZWN0aW9uLTQuMS4xXG5mdW5jdGlvbiBnZXRWYXJpYW50KGJpdHMpIHtcbiAgICBzd2l0Y2ggKGJpdHMpIHtcbiAgICAgICAgY2FzZSAwOlxuICAgICAgICBjYXNlIDE6XG4gICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgIHJldHVybiBcIm5jc1wiO1xuICAgICAgICBjYXNlIDQ6XG4gICAgICAgIGNhc2UgNTpcbiAgICAgICAgICAgIHJldHVybiBcInJmYzQxMjJcIjtcbiAgICAgICAgY2FzZSA2OlxuICAgICAgICAgICAgcmV0dXJuIFwibWljcm9zb2Z0XCI7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICByZXR1cm4gXCJmdXR1cmVcIjtcbiAgICB9XG59XG52YXIgVXVpZEVuY29kaW5nO1xuKGZ1bmN0aW9uIChVdWlkRW5jb2RpbmcpIHtcbiAgICBVdWlkRW5jb2RpbmdbVXVpZEVuY29kaW5nW1wiQVNDSUlcIl0gPSAwXSA9IFwiQVNDSUlcIjtcbiAgICBVdWlkRW5jb2RpbmdbVXVpZEVuY29kaW5nW1wiQklOQVJZXCJdID0gMV0gPSBcIkJJTkFSWVwiO1xuICAgIFV1aWRFbmNvZGluZ1tVdWlkRW5jb2RpbmdbXCJPQkpFQ1RcIl0gPSAyXSA9IFwiT0JKRUNUXCI7XG59KShVdWlkRW5jb2RpbmcgfHwgKFV1aWRFbmNvZGluZyA9IHt9KSk7XG4vLyB2MVxuZnVuY3Rpb24gdXVpZFRpbWVCYXNlZChub2RlSWQsIGVuY29kaW5nID0gVXVpZEVuY29kaW5nLkFTQ0lJKSB7XG4gICAgbGV0IG1UaW1lID0gRGF0ZS5ub3coKTtcbiAgICBsZXQgblRpbWUgPSBsYXN0TlRpbWUgKyAxO1xuICAgIGNvbnN0IGRlbHRhID0gbVRpbWUgLSBsYXN0TVRpbWUgKyAoblRpbWUgLSBsYXN0TlRpbWUpIC8gMTAwMDA7XG4gICAgaWYgKGRlbHRhIDwgMCkge1xuICAgICAgICBjbG9ja1NlcSA9IGNsb2NrU2VxICsgMSAmIDB4M2ZmZjtcbiAgICAgICAgblRpbWUgPSAwO1xuICAgIH0gZWxzZSBpZiAobVRpbWUgPiBsYXN0TVRpbWUpIHtcbiAgICAgICAgblRpbWUgPSAwO1xuICAgIH0gZWxzZSBpZiAoblRpbWUgPj0gMTAwMDApIHtcbiAgICAgICAgcmV0dXJuIG1vcmVUaGFuMTAwMDA7XG4gICAgfVxuICAgIGxhc3RNVGltZSA9IG1UaW1lO1xuICAgIGxhc3ROVGltZSA9IG5UaW1lO1xuICAgIC8vIHVuaXggdGltZXN0YW1wIHRvIGdyZWdvcmlhbiBlcG9jaCBhcyBwZXIgcmZjNDEyMiNzZWN0aW9uLTQuNVxuICAgIG1UaW1lICs9IDEyMjE5MjkyODAwMDAwO1xuICAgIGNvbnN0IGJ1ZmZlciA9IEJ1ZmZlci5hbGxvY1Vuc2FmZSgxNik7XG4gICAgY29uc3QgbXlDbG9ja1NlcSA9IGNsb2NrU2VxO1xuICAgIGNvbnN0IHRpbWVMb3cgPSAoKG1UaW1lICYgMHhmZmZmZmZmKSAqIDEwMDAwICsgblRpbWUpICUgMHgxMDAwMDAwMDA7XG4gICAgY29uc3QgdGltZUhpZ2ggPSBtVGltZSAvIDB4MTAwMDAwMDAwICogMTAwMDAgJiAweGZmZmZmZmY7XG4gICAgYnVmZmVyWzBdID0gdGltZUxvdyA+Pj4gMjQgJiAweGZmO1xuICAgIGJ1ZmZlclsxXSA9IHRpbWVMb3cgPj4+IDE2ICYgMHhmZjtcbiAgICBidWZmZXJbMl0gPSB0aW1lTG93ID4+PiA4ICYgMHhmZjtcbiAgICBidWZmZXJbM10gPSB0aW1lTG93ICYgMHhmZjtcbiAgICBidWZmZXJbNF0gPSB0aW1lSGlnaCA+Pj4gOCAmIDB4ZmY7XG4gICAgYnVmZmVyWzVdID0gdGltZUhpZ2ggJiAweGZmO1xuICAgIGJ1ZmZlcls2XSA9IHRpbWVIaWdoID4+PiAyNCAmIDB4MGYgfCAweDEwO1xuICAgIGJ1ZmZlcls3XSA9IHRpbWVIaWdoID4+PiAxNiAmIDB4M2YgfCAweDgwO1xuICAgIGJ1ZmZlcls4XSA9IG15Q2xvY2tTZXEgPj4+IDg7XG4gICAgYnVmZmVyWzldID0gbXlDbG9ja1NlcSAmIDB4ZmY7XG4gICAgbGV0IHJlc3VsdDtcbiAgICBzd2l0Y2ggKGVuY29kaW5nKSB7XG4gICAgICAgIGNhc2UgVXVpZEVuY29kaW5nLkJJTkFSWTpcbiAgICAgICAgICAgIGJ1ZmZlclsxMF0gPSBub2RlSWRbMF07XG4gICAgICAgICAgICBidWZmZXJbMTFdID0gbm9kZUlkWzFdO1xuICAgICAgICAgICAgYnVmZmVyWzEyXSA9IG5vZGVJZFsyXTtcbiAgICAgICAgICAgIGJ1ZmZlclsxM10gPSBub2RlSWRbM107XG4gICAgICAgICAgICBidWZmZXJbMTRdID0gbm9kZUlkWzRdO1xuICAgICAgICAgICAgYnVmZmVyWzE1XSA9IG5vZGVJZFs1XTtcbiAgICAgICAgICAgIHJlc3VsdCA9IGJ1ZmZlcjtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFV1aWRFbmNvZGluZy5PQkpFQ1Q6XG4gICAgICAgICAgICBidWZmZXJbMTBdID0gbm9kZUlkWzBdO1xuICAgICAgICAgICAgYnVmZmVyWzExXSA9IG5vZGVJZFsxXTtcbiAgICAgICAgICAgIGJ1ZmZlclsxMl0gPSBub2RlSWRbMl07XG4gICAgICAgICAgICBidWZmZXJbMTNdID0gbm9kZUlkWzNdO1xuICAgICAgICAgICAgYnVmZmVyWzE0XSA9IG5vZGVJZFs0XTtcbiAgICAgICAgICAgIGJ1ZmZlclsxNV0gPSBub2RlSWRbNV07XG4gICAgICAgICAgICByZXN1bHQgPSBuZXcgVVVJRChidWZmZXIpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICByZXN1bHQgPSBieXRlMmhleFtidWZmZXJbMF1dICsgYnl0ZTJoZXhbYnVmZmVyWzFdXSArIGJ5dGUyaGV4W2J1ZmZlclsyXV0gKyBieXRlMmhleFtidWZmZXJbM11dICsgXCItXCIgKyBieXRlMmhleFtidWZmZXJbNF1dICsgYnl0ZTJoZXhbYnVmZmVyWzVdXSArIFwiLVwiICsgYnl0ZTJoZXhbYnVmZmVyWzZdXSArIGJ5dGUyaGV4W2J1ZmZlcls3XV0gKyBcIi1cIiArIGJ5dGUyaGV4W2J1ZmZlcls4XV0gKyBieXRlMmhleFtidWZmZXJbOV1dICsgXCItXCIgKyBieXRlMmhleFtub2RlSWRbMF1dICsgYnl0ZTJoZXhbbm9kZUlkWzFdXSArIGJ5dGUyaGV4W25vZGVJZFsyXV0gKyBieXRlMmhleFtub2RlSWRbM11dICsgYnl0ZTJoZXhbbm9kZUlkWzRdXSArIGJ5dGUyaGV4W25vZGVJZFs1XV07XG4gICAgICAgICAgICBicmVhaztcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbi8vIHYzICsgdjVcbmZ1bmN0aW9uIHV1aWROYW1lZChuYW1lLCBoYXNoTWV0aG9kLCB2ZXJzaW9uLCBuYW1lc3BhY2UsIGVuY29kaW5nID0gVXVpZEVuY29kaW5nLkFTQ0lJKSB7XG4gICAgY29uc3QgaGFzaCA9ICgwLCAoX2NyeXB0byB8fCBfbG9hZF9jcnlwdG8oKSkuY3JlYXRlSGFzaCkoaGFzaE1ldGhvZCk7XG4gICAgY29uc3QgbmFtZUlzTm90QVN0cmluZyA9IHR5cGVvZiBuYW1lICE9PSBcInN0cmluZ1wiO1xuICAgIGlmIChuYW1lSXNOb3RBU3RyaW5nICYmICFCdWZmZXIuaXNCdWZmZXIobmFtZSkpIHtcbiAgICAgICAgdGhyb3cgKDAsIChfaW5kZXggfHwgX2xvYWRfaW5kZXgoKSkubmV3RXJyb3IpKGludmFsaWROYW1lLCBcIkVSUl9JTlZBTElEX1VVSURfTkFNRVwiKTtcbiAgICB9XG4gICAgaGFzaC51cGRhdGUobmFtZXNwYWNlKTtcbiAgICBoYXNoLnVwZGF0ZShuYW1lLCBuYW1lSXNOb3RBU3RyaW5nID8gXCJsYXRpbjFcIiA6IFwidXRmOFwiKTtcbiAgICBjb25zdCBidWZmZXIgPSBoYXNoLmRpZ2VzdCgpO1xuICAgIGxldCByZXN1bHQ7XG4gICAgc3dpdGNoIChlbmNvZGluZykge1xuICAgICAgICBjYXNlIFV1aWRFbmNvZGluZy5CSU5BUlk6XG4gICAgICAgICAgICBidWZmZXJbNl0gPSBidWZmZXJbNl0gJiAweDBmIHwgdmVyc2lvbjtcbiAgICAgICAgICAgIGJ1ZmZlcls4XSA9IGJ1ZmZlcls4XSAmIDB4M2YgfCAweDgwO1xuICAgICAgICAgICAgcmVzdWx0ID0gYnVmZmVyO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgVXVpZEVuY29kaW5nLk9CSkVDVDpcbiAgICAgICAgICAgIGJ1ZmZlcls2XSA9IGJ1ZmZlcls2XSAmIDB4MGYgfCB2ZXJzaW9uO1xuICAgICAgICAgICAgYnVmZmVyWzhdID0gYnVmZmVyWzhdICYgMHgzZiB8IDB4ODA7XG4gICAgICAgICAgICByZXN1bHQgPSBuZXcgVVVJRChidWZmZXIpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICByZXN1bHQgPSBieXRlMmhleFtidWZmZXJbMF1dICsgYnl0ZTJoZXhbYnVmZmVyWzFdXSArIGJ5dGUyaGV4W2J1ZmZlclsyXV0gKyBieXRlMmhleFtidWZmZXJbM11dICsgXCItXCIgKyBieXRlMmhleFtidWZmZXJbNF1dICsgYnl0ZTJoZXhbYnVmZmVyWzVdXSArIFwiLVwiICsgYnl0ZTJoZXhbYnVmZmVyWzZdICYgMHgwZiB8IHZlcnNpb25dICsgYnl0ZTJoZXhbYnVmZmVyWzddXSArIFwiLVwiICsgYnl0ZTJoZXhbYnVmZmVyWzhdICYgMHgzZiB8IDB4ODBdICsgYnl0ZTJoZXhbYnVmZmVyWzldXSArIFwiLVwiICsgYnl0ZTJoZXhbYnVmZmVyWzEwXV0gKyBieXRlMmhleFtidWZmZXJbMTFdXSArIGJ5dGUyaGV4W2J1ZmZlclsxMl1dICsgYnl0ZTJoZXhbYnVmZmVyWzEzXV0gKyBieXRlMmhleFtidWZmZXJbMTRdXSArIGJ5dGUyaGV4W2J1ZmZlclsxNV1dO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiBzdHJpbmdpZnkoYnVmZmVyKSB7XG4gICAgcmV0dXJuIGJ5dGUyaGV4W2J1ZmZlclswXV0gKyBieXRlMmhleFtidWZmZXJbMV1dICsgYnl0ZTJoZXhbYnVmZmVyWzJdXSArIGJ5dGUyaGV4W2J1ZmZlclszXV0gKyBcIi1cIiArIGJ5dGUyaGV4W2J1ZmZlcls0XV0gKyBieXRlMmhleFtidWZmZXJbNV1dICsgXCItXCIgKyBieXRlMmhleFtidWZmZXJbNl1dICsgYnl0ZTJoZXhbYnVmZmVyWzddXSArIFwiLVwiICsgYnl0ZTJoZXhbYnVmZmVyWzhdXSArIGJ5dGUyaGV4W2J1ZmZlcls5XV0gKyBcIi1cIiArIGJ5dGUyaGV4W2J1ZmZlclsxMF1dICsgYnl0ZTJoZXhbYnVmZmVyWzExXV0gKyBieXRlMmhleFtidWZmZXJbMTJdXSArIGJ5dGUyaGV4W2J1ZmZlclsxM11dICsgYnl0ZTJoZXhbYnVmZmVyWzE0XV0gKyBieXRlMmhleFtidWZmZXJbMTVdXTtcbn1cbi8vIGFjY29yZGluZyB0byByZmM0MTIyI3NlY3Rpb24tNC4xLjdcbmNvbnN0IG5pbCA9IGV4cG9ydHMubmlsID0gbmV3IFVVSUQoXCIwMDAwMDAwMC0wMDAwLTAwMDAtMDAwMC0wMDAwMDAwMDAwMDBcIik7XG4vLyBVVUlELnY0ID0gdXVpZFJhbmRvbVxuLy8gVVVJRC52NGZhc3QgPSB1dWlkUmFuZG9tRmFzdFxuLy8gVVVJRC52MyA9IGZ1bmN0aW9uKG9wdGlvbnMsIGNhbGxiYWNrKSB7XG4vLyAgICAgcmV0dXJuIHV1aWROYW1lZChcIm1kNVwiLCAweDMwLCBvcHRpb25zLCBjYWxsYmFjaylcbi8vIH0gXG4vLyMgc291cmNlTWFwcGluZ1VSTD11dWlkLmpzLm1hcFxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9lbGVjdHJvbi11cGRhdGVyL25vZGVfbW9kdWxlcy9idWlsZGVyLXV0aWwtcnVudGltZS9vdXQvdXVpZC5qcyIsIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLlhFbGVtZW50ID0gdW5kZWZpbmVkO1xuZXhwb3J0cy5wYXJzZVhtbCA9IHBhcnNlWG1sO1xuXG52YXIgX3NheDtcblxuZnVuY3Rpb24gX2xvYWRfc2F4KCkge1xuICAgIHJldHVybiBfc2F4ID0gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQocmVxdWlyZShcInNheFwiKSk7XG59XG5cbnZhciBfaW5kZXg7XG5cbmZ1bmN0aW9uIF9sb2FkX2luZGV4KCkge1xuICAgIHJldHVybiBfaW5kZXggPSByZXF1aXJlKFwiLi9pbmRleFwiKTtcbn1cblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQob2JqKSB7IGlmIChvYmogJiYgb2JqLl9fZXNNb2R1bGUpIHsgcmV0dXJuIG9iajsgfSBlbHNlIHsgdmFyIG5ld09iaiA9IHt9OyBpZiAob2JqICE9IG51bGwpIHsgZm9yICh2YXIga2V5IGluIG9iaikgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwga2V5KSkgbmV3T2JqW2tleV0gPSBvYmpba2V5XTsgfSB9IG5ld09iai5kZWZhdWx0ID0gb2JqOyByZXR1cm4gbmV3T2JqOyB9IH1cblxuY2xhc3MgWEVsZW1lbnQge1xuICAgIGNvbnN0cnVjdG9yKG5hbWUpIHtcbiAgICAgICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICAgICAgdGhpcy52YWx1ZSA9IFwiXCI7XG4gICAgICAgIHRoaXMuYXR0cmlidXRlcyA9IG51bGw7XG4gICAgICAgIHRoaXMuaXNDRGF0YSA9IGZhbHNlO1xuICAgICAgICB0aGlzLmVsZW1lbnRzID0gbnVsbDtcbiAgICAgICAgaWYgKCFuYW1lKSB7XG4gICAgICAgICAgICB0aHJvdyAoMCwgKF9pbmRleCB8fCBfbG9hZF9pbmRleCgpKS5uZXdFcnJvcikoXCJFbGVtZW50IG5hbWUgY2Fubm90IGJlIGVtcHR5XCIsIFwiRVJSX1hNTF9FTEVNRU5UX05BTUVfRU1QVFlcIik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFpc1ZhbGlkTmFtZShuYW1lKSkge1xuICAgICAgICAgICAgdGhyb3cgKDAsIChfaW5kZXggfHwgX2xvYWRfaW5kZXgoKSkubmV3RXJyb3IpKGBJbnZhbGlkIGVsZW1lbnQgbmFtZTogJHtuYW1lfWAsIFwiRVJSX1hNTF9FTEVNRU5UX0lOVkFMSURfTkFNRVwiKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhdHRyaWJ1dGUobmFtZSkge1xuICAgICAgICBjb25zdCByZXN1bHQgPSB0aGlzLmF0dHJpYnV0ZXMgPT09IG51bGwgPyBudWxsIDogdGhpcy5hdHRyaWJ1dGVzW25hbWVdO1xuICAgICAgICBpZiAocmVzdWx0ID09IG51bGwpIHtcbiAgICAgICAgICAgIHRocm93ICgwLCAoX2luZGV4IHx8IF9sb2FkX2luZGV4KCkpLm5ld0Vycm9yKShgTm8gYXR0cmlidXRlIFwiJHtuYW1lfVwiYCwgXCJFUlJfWE1MX01JU1NFRF9BVFRSSUJVVEVcIik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgcmVtb3ZlQXR0cmlidXRlKG5hbWUpIHtcbiAgICAgICAgaWYgKHRoaXMuYXR0cmlidXRlcyAhPT0gbnVsbCkge1xuICAgICAgICAgICAgZGVsZXRlIHRoaXMuYXR0cmlidXRlc1tuYW1lXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbGVtZW50KG5hbWUsIGlnbm9yZUNhc2UgPSBmYWxzZSwgZXJyb3JJZk1pc3NlZCA9IG51bGwpIHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gdGhpcy5lbGVtZW50T3JOdWxsKG5hbWUsIGlnbm9yZUNhc2UpO1xuICAgICAgICBpZiAocmVzdWx0ID09PSBudWxsKSB7XG4gICAgICAgICAgICB0aHJvdyAoMCwgKF9pbmRleCB8fCBfbG9hZF9pbmRleCgpKS5uZXdFcnJvcikoZXJyb3JJZk1pc3NlZCB8fCBgTm8gZWxlbWVudCBcIiR7bmFtZX1cImAsIFwiRVJSX1hNTF9NSVNTRURfRUxFTUVOVFwiKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICBlbGVtZW50T3JOdWxsKG5hbWUsIGlnbm9yZUNhc2UgPSBmYWxzZSkge1xuICAgICAgICBpZiAodGhpcy5lbGVtZW50cyA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChjb25zdCBlbGVtZW50IG9mIHRoaXMuZWxlbWVudHMpIHtcbiAgICAgICAgICAgIGlmIChpc05hbWVFcXVhbHMoZWxlbWVudCwgbmFtZSwgaWdub3JlQ2FzZSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZWxlbWVudDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgZ2V0RWxlbWVudHMobmFtZSwgaWdub3JlQ2FzZSA9IGZhbHNlKSB7XG4gICAgICAgIGlmICh0aGlzLmVsZW1lbnRzID09PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuZWxlbWVudHMuZmlsdGVyKGl0ID0+IGlzTmFtZUVxdWFscyhpdCwgbmFtZSwgaWdub3JlQ2FzZSkpO1xuICAgIH1cbiAgICBlbGVtZW50VmFsdWVPckVtcHR5KG5hbWUsIGlnbm9yZUNhc2UgPSBmYWxzZSkge1xuICAgICAgICBjb25zdCBlbGVtZW50ID0gdGhpcy5lbGVtZW50T3JOdWxsKG5hbWUsIGlnbm9yZUNhc2UpO1xuICAgICAgICByZXR1cm4gZWxlbWVudCA9PT0gbnVsbCA/IFwiXCIgOiBlbGVtZW50LnZhbHVlO1xuICAgIH1cbn1cbmV4cG9ydHMuWEVsZW1lbnQgPSBYRWxlbWVudDtcbmNvbnN0IE5BTUVfUkVHX0VYUCA9IG5ldyBSZWdFeHAoL15bQS1aYS16X11bOkEtWmEtejAtOV8tXSokL2kpO1xuZnVuY3Rpb24gaXNWYWxpZE5hbWUobmFtZSkge1xuICAgIHJldHVybiBOQU1FX1JFR19FWFAudGVzdChuYW1lKTtcbn1cbmZ1bmN0aW9uIGlzTmFtZUVxdWFscyhlbGVtZW50LCBuYW1lLCBpZ25vcmVDYXNlKSB7XG4gICAgY29uc3QgZWxlbWVudE5hbWUgPSBlbGVtZW50Lm5hbWU7XG4gICAgcmV0dXJuIGVsZW1lbnROYW1lID09PSBuYW1lIHx8IGlnbm9yZUNhc2UgPT09IHRydWUgJiYgZWxlbWVudE5hbWUubGVuZ3RoID09PSBuYW1lLmxlbmd0aCAmJiBlbGVtZW50TmFtZS50b0xvd2VyQ2FzZSgpID09PSBuYW1lLnRvTG93ZXJDYXNlKCk7XG59XG5mdW5jdGlvbiBwYXJzZVhtbChkYXRhKSB7XG4gICAgbGV0IHJvb3RFbGVtZW50ID0gbnVsbDtcbiAgICBjb25zdCBwYXJzZXIgPSAoX3NheCB8fCBfbG9hZF9zYXgoKSkucGFyc2VyKHRydWUsIHt9KTtcbiAgICBjb25zdCBlbGVtZW50cyA9IFtdO1xuICAgIHBhcnNlci5vbm9wZW50YWcgPSBzYXhFbGVtZW50ID0+IHtcbiAgICAgICAgY29uc3QgZWxlbWVudCA9IG5ldyBYRWxlbWVudChzYXhFbGVtZW50Lm5hbWUpO1xuICAgICAgICBlbGVtZW50LmF0dHJpYnV0ZXMgPSBzYXhFbGVtZW50LmF0dHJpYnV0ZXM7XG4gICAgICAgIGlmIChyb290RWxlbWVudCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcm9vdEVsZW1lbnQgPSBlbGVtZW50O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgcGFyZW50ID0gZWxlbWVudHNbZWxlbWVudHMubGVuZ3RoIC0gMV07XG4gICAgICAgICAgICBpZiAocGFyZW50LmVsZW1lbnRzID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBwYXJlbnQuZWxlbWVudHMgPSBbXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHBhcmVudC5lbGVtZW50cy5wdXNoKGVsZW1lbnQpO1xuICAgICAgICB9XG4gICAgICAgIGVsZW1lbnRzLnB1c2goZWxlbWVudCk7XG4gICAgfTtcbiAgICBwYXJzZXIub25jbG9zZXRhZyA9ICgpID0+IHtcbiAgICAgICAgZWxlbWVudHMucG9wKCk7XG4gICAgfTtcbiAgICBwYXJzZXIub250ZXh0ID0gdGV4dCA9PiB7XG4gICAgICAgIGlmIChlbGVtZW50cy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBlbGVtZW50c1tlbGVtZW50cy5sZW5ndGggLSAxXS52YWx1ZSA9IHRleHQ7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHBhcnNlci5vbmNkYXRhID0gY2RhdGEgPT4ge1xuICAgICAgICBjb25zdCBlbGVtZW50ID0gZWxlbWVudHNbZWxlbWVudHMubGVuZ3RoIC0gMV07XG4gICAgICAgIGVsZW1lbnQudmFsdWUgPSBjZGF0YTtcbiAgICAgICAgZWxlbWVudC5pc0NEYXRhID0gdHJ1ZTtcbiAgICB9O1xuICAgIHBhcnNlci5vbmVycm9yID0gZXJyID0+IHtcbiAgICAgICAgdGhyb3cgZXJyO1xuICAgIH07XG4gICAgcGFyc2VyLndyaXRlKGRhdGEpO1xuICAgIHJldHVybiByb290RWxlbWVudDtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXhtbC5qcy5tYXBcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvZWxlY3Ryb24tdXBkYXRlci9ub2RlX21vZHVsZXMvYnVpbGRlci11dGlsLXJ1bnRpbWUvb3V0L3htbC5qcyIsIjsoZnVuY3Rpb24gKHNheCkgeyAvLyB3cmFwcGVyIGZvciBub24tbm9kZSBlbnZzXG4gIHNheC5wYXJzZXIgPSBmdW5jdGlvbiAoc3RyaWN0LCBvcHQpIHsgcmV0dXJuIG5ldyBTQVhQYXJzZXIoc3RyaWN0LCBvcHQpIH1cbiAgc2F4LlNBWFBhcnNlciA9IFNBWFBhcnNlclxuICBzYXguU0FYU3RyZWFtID0gU0FYU3RyZWFtXG4gIHNheC5jcmVhdGVTdHJlYW0gPSBjcmVhdGVTdHJlYW1cblxuICAvLyBXaGVuIHdlIHBhc3MgdGhlIE1BWF9CVUZGRVJfTEVOR1RIIHBvc2l0aW9uLCBzdGFydCBjaGVja2luZyBmb3IgYnVmZmVyIG92ZXJydW5zLlxuICAvLyBXaGVuIHdlIGNoZWNrLCBzY2hlZHVsZSB0aGUgbmV4dCBjaGVjayBmb3IgTUFYX0JVRkZFUl9MRU5HVEggLSAobWF4KGJ1ZmZlciBsZW5ndGhzKSksXG4gIC8vIHNpbmNlIHRoYXQncyB0aGUgZWFybGllc3QgdGhhdCBhIGJ1ZmZlciBvdmVycnVuIGNvdWxkIG9jY3VyLiAgVGhpcyB3YXksIGNoZWNrcyBhcmVcbiAgLy8gYXMgcmFyZSBhcyByZXF1aXJlZCwgYnV0IGFzIG9mdGVuIGFzIG5lY2Vzc2FyeSB0byBlbnN1cmUgbmV2ZXIgY3Jvc3NpbmcgdGhpcyBib3VuZC5cbiAgLy8gRnVydGhlcm1vcmUsIGJ1ZmZlcnMgYXJlIG9ubHkgdGVzdGVkIGF0IG1vc3Qgb25jZSBwZXIgd3JpdGUoKSwgc28gcGFzc2luZyBhIHZlcnlcbiAgLy8gbGFyZ2Ugc3RyaW5nIGludG8gd3JpdGUoKSBtaWdodCBoYXZlIHVuZGVzaXJhYmxlIGVmZmVjdHMsIGJ1dCB0aGlzIGlzIG1hbmFnZWFibGUgYnlcbiAgLy8gdGhlIGNhbGxlciwgc28gaXQgaXMgYXNzdW1lZCB0byBiZSBzYWZlLiAgVGh1cywgYSBjYWxsIHRvIHdyaXRlKCkgbWF5LCBpbiB0aGUgZXh0cmVtZVxuICAvLyBlZGdlIGNhc2UsIHJlc3VsdCBpbiBjcmVhdGluZyBhdCBtb3N0IG9uZSBjb21wbGV0ZSBjb3B5IG9mIHRoZSBzdHJpbmcgcGFzc2VkIGluLlxuICAvLyBTZXQgdG8gSW5maW5pdHkgdG8gaGF2ZSB1bmxpbWl0ZWQgYnVmZmVycy5cbiAgc2F4Lk1BWF9CVUZGRVJfTEVOR1RIID0gNjQgKiAxMDI0XG5cbiAgdmFyIGJ1ZmZlcnMgPSBbXG4gICAgJ2NvbW1lbnQnLCAnc2dtbERlY2wnLCAndGV4dE5vZGUnLCAndGFnTmFtZScsICdkb2N0eXBlJyxcbiAgICAncHJvY0luc3ROYW1lJywgJ3Byb2NJbnN0Qm9keScsICdlbnRpdHknLCAnYXR0cmliTmFtZScsXG4gICAgJ2F0dHJpYlZhbHVlJywgJ2NkYXRhJywgJ3NjcmlwdCdcbiAgXVxuXG4gIHNheC5FVkVOVFMgPSBbXG4gICAgJ3RleHQnLFxuICAgICdwcm9jZXNzaW5naW5zdHJ1Y3Rpb24nLFxuICAgICdzZ21sZGVjbGFyYXRpb24nLFxuICAgICdkb2N0eXBlJyxcbiAgICAnY29tbWVudCcsXG4gICAgJ29wZW50YWdzdGFydCcsXG4gICAgJ2F0dHJpYnV0ZScsXG4gICAgJ29wZW50YWcnLFxuICAgICdjbG9zZXRhZycsXG4gICAgJ29wZW5jZGF0YScsXG4gICAgJ2NkYXRhJyxcbiAgICAnY2xvc2VjZGF0YScsXG4gICAgJ2Vycm9yJyxcbiAgICAnZW5kJyxcbiAgICAncmVhZHknLFxuICAgICdzY3JpcHQnLFxuICAgICdvcGVubmFtZXNwYWNlJyxcbiAgICAnY2xvc2VuYW1lc3BhY2UnXG4gIF1cblxuICBmdW5jdGlvbiBTQVhQYXJzZXIgKHN0cmljdCwgb3B0KSB7XG4gICAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIFNBWFBhcnNlcikpIHtcbiAgICAgIHJldHVybiBuZXcgU0FYUGFyc2VyKHN0cmljdCwgb3B0KVxuICAgIH1cblxuICAgIHZhciBwYXJzZXIgPSB0aGlzXG4gICAgY2xlYXJCdWZmZXJzKHBhcnNlcilcbiAgICBwYXJzZXIucSA9IHBhcnNlci5jID0gJydcbiAgICBwYXJzZXIuYnVmZmVyQ2hlY2tQb3NpdGlvbiA9IHNheC5NQVhfQlVGRkVSX0xFTkdUSFxuICAgIHBhcnNlci5vcHQgPSBvcHQgfHwge31cbiAgICBwYXJzZXIub3B0Lmxvd2VyY2FzZSA9IHBhcnNlci5vcHQubG93ZXJjYXNlIHx8IHBhcnNlci5vcHQubG93ZXJjYXNldGFnc1xuICAgIHBhcnNlci5sb29zZUNhc2UgPSBwYXJzZXIub3B0Lmxvd2VyY2FzZSA/ICd0b0xvd2VyQ2FzZScgOiAndG9VcHBlckNhc2UnXG4gICAgcGFyc2VyLnRhZ3MgPSBbXVxuICAgIHBhcnNlci5jbG9zZWQgPSBwYXJzZXIuY2xvc2VkUm9vdCA9IHBhcnNlci5zYXdSb290ID0gZmFsc2VcbiAgICBwYXJzZXIudGFnID0gcGFyc2VyLmVycm9yID0gbnVsbFxuICAgIHBhcnNlci5zdHJpY3QgPSAhIXN0cmljdFxuICAgIHBhcnNlci5ub3NjcmlwdCA9ICEhKHN0cmljdCB8fCBwYXJzZXIub3B0Lm5vc2NyaXB0KVxuICAgIHBhcnNlci5zdGF0ZSA9IFMuQkVHSU5cbiAgICBwYXJzZXIuc3RyaWN0RW50aXRpZXMgPSBwYXJzZXIub3B0LnN0cmljdEVudGl0aWVzXG4gICAgcGFyc2VyLkVOVElUSUVTID0gcGFyc2VyLnN0cmljdEVudGl0aWVzID8gT2JqZWN0LmNyZWF0ZShzYXguWE1MX0VOVElUSUVTKSA6IE9iamVjdC5jcmVhdGUoc2F4LkVOVElUSUVTKVxuICAgIHBhcnNlci5hdHRyaWJMaXN0ID0gW11cblxuICAgIC8vIG5hbWVzcGFjZXMgZm9ybSBhIHByb3RvdHlwZSBjaGFpbi5cbiAgICAvLyBpdCBhbHdheXMgcG9pbnRzIGF0IHRoZSBjdXJyZW50IHRhZyxcbiAgICAvLyB3aGljaCBwcm90b3MgdG8gaXRzIHBhcmVudCB0YWcuXG4gICAgaWYgKHBhcnNlci5vcHQueG1sbnMpIHtcbiAgICAgIHBhcnNlci5ucyA9IE9iamVjdC5jcmVhdGUocm9vdE5TKVxuICAgIH1cblxuICAgIC8vIG1vc3RseSBqdXN0IGZvciBlcnJvciByZXBvcnRpbmdcbiAgICBwYXJzZXIudHJhY2tQb3NpdGlvbiA9IHBhcnNlci5vcHQucG9zaXRpb24gIT09IGZhbHNlXG4gICAgaWYgKHBhcnNlci50cmFja1Bvc2l0aW9uKSB7XG4gICAgICBwYXJzZXIucG9zaXRpb24gPSBwYXJzZXIubGluZSA9IHBhcnNlci5jb2x1bW4gPSAwXG4gICAgfVxuICAgIGVtaXQocGFyc2VyLCAnb25yZWFkeScpXG4gIH1cblxuICBpZiAoIU9iamVjdC5jcmVhdGUpIHtcbiAgICBPYmplY3QuY3JlYXRlID0gZnVuY3Rpb24gKG8pIHtcbiAgICAgIGZ1bmN0aW9uIEYgKCkge31cbiAgICAgIEYucHJvdG90eXBlID0gb1xuICAgICAgdmFyIG5ld2YgPSBuZXcgRigpXG4gICAgICByZXR1cm4gbmV3ZlxuICAgIH1cbiAgfVxuXG4gIGlmICghT2JqZWN0LmtleXMpIHtcbiAgICBPYmplY3Qua2V5cyA9IGZ1bmN0aW9uIChvKSB7XG4gICAgICB2YXIgYSA9IFtdXG4gICAgICBmb3IgKHZhciBpIGluIG8pIGlmIChvLmhhc093blByb3BlcnR5KGkpKSBhLnB1c2goaSlcbiAgICAgIHJldHVybiBhXG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gY2hlY2tCdWZmZXJMZW5ndGggKHBhcnNlcikge1xuICAgIHZhciBtYXhBbGxvd2VkID0gTWF0aC5tYXgoc2F4Lk1BWF9CVUZGRVJfTEVOR1RILCAxMClcbiAgICB2YXIgbWF4QWN0dWFsID0gMFxuICAgIGZvciAodmFyIGkgPSAwLCBsID0gYnVmZmVycy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIHZhciBsZW4gPSBwYXJzZXJbYnVmZmVyc1tpXV0ubGVuZ3RoXG4gICAgICBpZiAobGVuID4gbWF4QWxsb3dlZCkge1xuICAgICAgICAvLyBUZXh0L2NkYXRhIG5vZGVzIGNhbiBnZXQgYmlnLCBhbmQgc2luY2UgdGhleSdyZSBidWZmZXJlZCxcbiAgICAgICAgLy8gd2UgY2FuIGdldCBoZXJlIHVuZGVyIG5vcm1hbCBjb25kaXRpb25zLlxuICAgICAgICAvLyBBdm9pZCBpc3N1ZXMgYnkgZW1pdHRpbmcgdGhlIHRleHQgbm9kZSBub3csXG4gICAgICAgIC8vIHNvIGF0IGxlYXN0IGl0IHdvbid0IGdldCBhbnkgYmlnZ2VyLlxuICAgICAgICBzd2l0Y2ggKGJ1ZmZlcnNbaV0pIHtcbiAgICAgICAgICBjYXNlICd0ZXh0Tm9kZSc6XG4gICAgICAgICAgICBjbG9zZVRleHQocGFyc2VyKVxuICAgICAgICAgICAgYnJlYWtcblxuICAgICAgICAgIGNhc2UgJ2NkYXRhJzpcbiAgICAgICAgICAgIGVtaXROb2RlKHBhcnNlciwgJ29uY2RhdGEnLCBwYXJzZXIuY2RhdGEpXG4gICAgICAgICAgICBwYXJzZXIuY2RhdGEgPSAnJ1xuICAgICAgICAgICAgYnJlYWtcblxuICAgICAgICAgIGNhc2UgJ3NjcmlwdCc6XG4gICAgICAgICAgICBlbWl0Tm9kZShwYXJzZXIsICdvbnNjcmlwdCcsIHBhcnNlci5zY3JpcHQpXG4gICAgICAgICAgICBwYXJzZXIuc2NyaXB0ID0gJydcbiAgICAgICAgICAgIGJyZWFrXG5cbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgZXJyb3IocGFyc2VyLCAnTWF4IGJ1ZmZlciBsZW5ndGggZXhjZWVkZWQ6ICcgKyBidWZmZXJzW2ldKVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBtYXhBY3R1YWwgPSBNYXRoLm1heChtYXhBY3R1YWwsIGxlbilcbiAgICB9XG4gICAgLy8gc2NoZWR1bGUgdGhlIG5leHQgY2hlY2sgZm9yIHRoZSBlYXJsaWVzdCBwb3NzaWJsZSBidWZmZXIgb3ZlcnJ1bi5cbiAgICB2YXIgbSA9IHNheC5NQVhfQlVGRkVSX0xFTkdUSCAtIG1heEFjdHVhbFxuICAgIHBhcnNlci5idWZmZXJDaGVja1Bvc2l0aW9uID0gbSArIHBhcnNlci5wb3NpdGlvblxuICB9XG5cbiAgZnVuY3Rpb24gY2xlYXJCdWZmZXJzIChwYXJzZXIpIHtcbiAgICBmb3IgKHZhciBpID0gMCwgbCA9IGJ1ZmZlcnMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICBwYXJzZXJbYnVmZmVyc1tpXV0gPSAnJ1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGZsdXNoQnVmZmVycyAocGFyc2VyKSB7XG4gICAgY2xvc2VUZXh0KHBhcnNlcilcbiAgICBpZiAocGFyc2VyLmNkYXRhICE9PSAnJykge1xuICAgICAgZW1pdE5vZGUocGFyc2VyLCAnb25jZGF0YScsIHBhcnNlci5jZGF0YSlcbiAgICAgIHBhcnNlci5jZGF0YSA9ICcnXG4gICAgfVxuICAgIGlmIChwYXJzZXIuc2NyaXB0ICE9PSAnJykge1xuICAgICAgZW1pdE5vZGUocGFyc2VyLCAnb25zY3JpcHQnLCBwYXJzZXIuc2NyaXB0KVxuICAgICAgcGFyc2VyLnNjcmlwdCA9ICcnXG4gICAgfVxuICB9XG5cbiAgU0FYUGFyc2VyLnByb3RvdHlwZSA9IHtcbiAgICBlbmQ6IGZ1bmN0aW9uICgpIHsgZW5kKHRoaXMpIH0sXG4gICAgd3JpdGU6IHdyaXRlLFxuICAgIHJlc3VtZTogZnVuY3Rpb24gKCkgeyB0aGlzLmVycm9yID0gbnVsbDsgcmV0dXJuIHRoaXMgfSxcbiAgICBjbG9zZTogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy53cml0ZShudWxsKSB9LFxuICAgIGZsdXNoOiBmdW5jdGlvbiAoKSB7IGZsdXNoQnVmZmVycyh0aGlzKSB9XG4gIH1cblxuICB2YXIgU3RyZWFtXG4gIHRyeSB7XG4gICAgU3RyZWFtID0gcmVxdWlyZSgnc3RyZWFtJykuU3RyZWFtXG4gIH0gY2F0Y2ggKGV4KSB7XG4gICAgU3RyZWFtID0gZnVuY3Rpb24gKCkge31cbiAgfVxuXG4gIHZhciBzdHJlYW1XcmFwcyA9IHNheC5FVkVOVFMuZmlsdGVyKGZ1bmN0aW9uIChldikge1xuICAgIHJldHVybiBldiAhPT0gJ2Vycm9yJyAmJiBldiAhPT0gJ2VuZCdcbiAgfSlcblxuICBmdW5jdGlvbiBjcmVhdGVTdHJlYW0gKHN0cmljdCwgb3B0KSB7XG4gICAgcmV0dXJuIG5ldyBTQVhTdHJlYW0oc3RyaWN0LCBvcHQpXG4gIH1cblxuICBmdW5jdGlvbiBTQVhTdHJlYW0gKHN0cmljdCwgb3B0KSB7XG4gICAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIFNBWFN0cmVhbSkpIHtcbiAgICAgIHJldHVybiBuZXcgU0FYU3RyZWFtKHN0cmljdCwgb3B0KVxuICAgIH1cblxuICAgIFN0cmVhbS5hcHBseSh0aGlzKVxuXG4gICAgdGhpcy5fcGFyc2VyID0gbmV3IFNBWFBhcnNlcihzdHJpY3QsIG9wdClcbiAgICB0aGlzLndyaXRhYmxlID0gdHJ1ZVxuICAgIHRoaXMucmVhZGFibGUgPSB0cnVlXG5cbiAgICB2YXIgbWUgPSB0aGlzXG5cbiAgICB0aGlzLl9wYXJzZXIub25lbmQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBtZS5lbWl0KCdlbmQnKVxuICAgIH1cblxuICAgIHRoaXMuX3BhcnNlci5vbmVycm9yID0gZnVuY3Rpb24gKGVyKSB7XG4gICAgICBtZS5lbWl0KCdlcnJvcicsIGVyKVxuXG4gICAgICAvLyBpZiBkaWRuJ3QgdGhyb3csIHRoZW4gbWVhbnMgZXJyb3Igd2FzIGhhbmRsZWQuXG4gICAgICAvLyBnbyBhaGVhZCBhbmQgY2xlYXIgZXJyb3IsIHNvIHdlIGNhbiB3cml0ZSBhZ2Fpbi5cbiAgICAgIG1lLl9wYXJzZXIuZXJyb3IgPSBudWxsXG4gICAgfVxuXG4gICAgdGhpcy5fZGVjb2RlciA9IG51bGxcblxuICAgIHN0cmVhbVdyYXBzLmZvckVhY2goZnVuY3Rpb24gKGV2KSB7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobWUsICdvbicgKyBldiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICByZXR1cm4gbWUuX3BhcnNlclsnb24nICsgZXZdXG4gICAgICAgIH0sXG4gICAgICAgIHNldDogZnVuY3Rpb24gKGgpIHtcbiAgICAgICAgICBpZiAoIWgpIHtcbiAgICAgICAgICAgIG1lLnJlbW92ZUFsbExpc3RlbmVycyhldilcbiAgICAgICAgICAgIG1lLl9wYXJzZXJbJ29uJyArIGV2XSA9IGhcbiAgICAgICAgICAgIHJldHVybiBoXG4gICAgICAgICAgfVxuICAgICAgICAgIG1lLm9uKGV2LCBoKVxuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IGZhbHNlXG4gICAgICB9KVxuICAgIH0pXG4gIH1cblxuICBTQVhTdHJlYW0ucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShTdHJlYW0ucHJvdG90eXBlLCB7XG4gICAgY29uc3RydWN0b3I6IHtcbiAgICAgIHZhbHVlOiBTQVhTdHJlYW1cbiAgICB9XG4gIH0pXG5cbiAgU0FYU3RyZWFtLnByb3RvdHlwZS53cml0ZSA9IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgaWYgKHR5cGVvZiBCdWZmZXIgPT09ICdmdW5jdGlvbicgJiZcbiAgICAgIHR5cGVvZiBCdWZmZXIuaXNCdWZmZXIgPT09ICdmdW5jdGlvbicgJiZcbiAgICAgIEJ1ZmZlci5pc0J1ZmZlcihkYXRhKSkge1xuICAgICAgaWYgKCF0aGlzLl9kZWNvZGVyKSB7XG4gICAgICAgIHZhciBTRCA9IHJlcXVpcmUoJ3N0cmluZ19kZWNvZGVyJykuU3RyaW5nRGVjb2RlclxuICAgICAgICB0aGlzLl9kZWNvZGVyID0gbmV3IFNEKCd1dGY4JylcbiAgICAgIH1cbiAgICAgIGRhdGEgPSB0aGlzLl9kZWNvZGVyLndyaXRlKGRhdGEpXG4gICAgfVxuXG4gICAgdGhpcy5fcGFyc2VyLndyaXRlKGRhdGEudG9TdHJpbmcoKSlcbiAgICB0aGlzLmVtaXQoJ2RhdGEnLCBkYXRhKVxuICAgIHJldHVybiB0cnVlXG4gIH1cblxuICBTQVhTdHJlYW0ucHJvdG90eXBlLmVuZCA9IGZ1bmN0aW9uIChjaHVuaykge1xuICAgIGlmIChjaHVuayAmJiBjaHVuay5sZW5ndGgpIHtcbiAgICAgIHRoaXMud3JpdGUoY2h1bmspXG4gICAgfVxuICAgIHRoaXMuX3BhcnNlci5lbmQoKVxuICAgIHJldHVybiB0cnVlXG4gIH1cblxuICBTQVhTdHJlYW0ucHJvdG90eXBlLm9uID0gZnVuY3Rpb24gKGV2LCBoYW5kbGVyKSB7XG4gICAgdmFyIG1lID0gdGhpc1xuICAgIGlmICghbWUuX3BhcnNlclsnb24nICsgZXZdICYmIHN0cmVhbVdyYXBzLmluZGV4T2YoZXYpICE9PSAtMSkge1xuICAgICAgbWUuX3BhcnNlclsnb24nICsgZXZdID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgYXJncyA9IGFyZ3VtZW50cy5sZW5ndGggPT09IDEgPyBbYXJndW1lbnRzWzBdXSA6IEFycmF5LmFwcGx5KG51bGwsIGFyZ3VtZW50cylcbiAgICAgICAgYXJncy5zcGxpY2UoMCwgMCwgZXYpXG4gICAgICAgIG1lLmVtaXQuYXBwbHkobWUsIGFyZ3MpXG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIFN0cmVhbS5wcm90b3R5cGUub24uY2FsbChtZSwgZXYsIGhhbmRsZXIpXG4gIH1cblxuICAvLyB0aGlzIHJlYWxseSBuZWVkcyB0byBiZSByZXBsYWNlZCB3aXRoIGNoYXJhY3RlciBjbGFzc2VzLlxuICAvLyBYTUwgYWxsb3dzIGFsbCBtYW5uZXIgb2YgcmlkaWN1bG91cyBudW1iZXJzIGFuZCBkaWdpdHMuXG4gIHZhciBDREFUQSA9ICdbQ0RBVEFbJ1xuICB2YXIgRE9DVFlQRSA9ICdET0NUWVBFJ1xuICB2YXIgWE1MX05BTUVTUEFDRSA9ICdodHRwOi8vd3d3LnczLm9yZy9YTUwvMTk5OC9uYW1lc3BhY2UnXG4gIHZhciBYTUxOU19OQU1FU1BBQ0UgPSAnaHR0cDovL3d3dy53My5vcmcvMjAwMC94bWxucy8nXG4gIHZhciByb290TlMgPSB7IHhtbDogWE1MX05BTUVTUEFDRSwgeG1sbnM6IFhNTE5TX05BTUVTUEFDRSB9XG5cbiAgLy8gaHR0cDovL3d3dy53My5vcmcvVFIvUkVDLXhtbC8jTlQtTmFtZVN0YXJ0Q2hhclxuICAvLyBUaGlzIGltcGxlbWVudGF0aW9uIHdvcmtzIG9uIHN0cmluZ3MsIGEgc2luZ2xlIGNoYXJhY3RlciBhdCBhIHRpbWVcbiAgLy8gYXMgc3VjaCwgaXQgY2Fubm90IGV2ZXIgc3VwcG9ydCBhc3RyYWwtcGxhbmUgY2hhcmFjdGVycyAoMTAwMDAtRUZGRkYpXG4gIC8vIHdpdGhvdXQgYSBzaWduaWZpY2FudCBicmVha2luZyBjaGFuZ2UgdG8gZWl0aGVyIHRoaXMgIHBhcnNlciwgb3IgdGhlXG4gIC8vIEphdmFTY3JpcHQgbGFuZ3VhZ2UuICBJbXBsZW1lbnRhdGlvbiBvZiBhbiBlbW9qaS1jYXBhYmxlIHhtbCBwYXJzZXJcbiAgLy8gaXMgbGVmdCBhcyBhbiBleGVyY2lzZSBmb3IgdGhlIHJlYWRlci5cbiAgdmFyIG5hbWVTdGFydCA9IC9bOl9BLVphLXpcXHUwMEMwLVxcdTAwRDZcXHUwMEQ4LVxcdTAwRjZcXHUwMEY4LVxcdTAyRkZcXHUwMzcwLVxcdTAzN0RcXHUwMzdGLVxcdTFGRkZcXHUyMDBDLVxcdTIwMERcXHUyMDcwLVxcdTIxOEZcXHUyQzAwLVxcdTJGRUZcXHUzMDAxLVxcdUQ3RkZcXHVGOTAwLVxcdUZEQ0ZcXHVGREYwLVxcdUZGRkRdL1xuXG4gIHZhciBuYW1lQm9keSA9IC9bOl9BLVphLXpcXHUwMEMwLVxcdTAwRDZcXHUwMEQ4LVxcdTAwRjZcXHUwMEY4LVxcdTAyRkZcXHUwMzcwLVxcdTAzN0RcXHUwMzdGLVxcdTFGRkZcXHUyMDBDLVxcdTIwMERcXHUyMDcwLVxcdTIxOEZcXHUyQzAwLVxcdTJGRUZcXHUzMDAxLVxcdUQ3RkZcXHVGOTAwLVxcdUZEQ0ZcXHVGREYwLVxcdUZGRkRcXHUwMEI3XFx1MDMwMC1cXHUwMzZGXFx1MjAzRi1cXHUyMDQwLlxcZC1dL1xuXG4gIHZhciBlbnRpdHlTdGFydCA9IC9bIzpfQS1aYS16XFx1MDBDMC1cXHUwMEQ2XFx1MDBEOC1cXHUwMEY2XFx1MDBGOC1cXHUwMkZGXFx1MDM3MC1cXHUwMzdEXFx1MDM3Ri1cXHUxRkZGXFx1MjAwQy1cXHUyMDBEXFx1MjA3MC1cXHUyMThGXFx1MkMwMC1cXHUyRkVGXFx1MzAwMS1cXHVEN0ZGXFx1RjkwMC1cXHVGRENGXFx1RkRGMC1cXHVGRkZEXS9cbiAgdmFyIGVudGl0eUJvZHkgPSAvWyM6X0EtWmEtelxcdTAwQzAtXFx1MDBENlxcdTAwRDgtXFx1MDBGNlxcdTAwRjgtXFx1MDJGRlxcdTAzNzAtXFx1MDM3RFxcdTAzN0YtXFx1MUZGRlxcdTIwMEMtXFx1MjAwRFxcdTIwNzAtXFx1MjE4RlxcdTJDMDAtXFx1MkZFRlxcdTMwMDEtXFx1RDdGRlxcdUY5MDAtXFx1RkRDRlxcdUZERjAtXFx1RkZGRFxcdTAwQjdcXHUwMzAwLVxcdTAzNkZcXHUyMDNGLVxcdTIwNDAuXFxkLV0vXG5cbiAgZnVuY3Rpb24gaXNXaGl0ZXNwYWNlIChjKSB7XG4gICAgcmV0dXJuIGMgPT09ICcgJyB8fCBjID09PSAnXFxuJyB8fCBjID09PSAnXFxyJyB8fCBjID09PSAnXFx0J1xuICB9XG5cbiAgZnVuY3Rpb24gaXNRdW90ZSAoYykge1xuICAgIHJldHVybiBjID09PSAnXCInIHx8IGMgPT09ICdcXCcnXG4gIH1cblxuICBmdW5jdGlvbiBpc0F0dHJpYkVuZCAoYykge1xuICAgIHJldHVybiBjID09PSAnPicgfHwgaXNXaGl0ZXNwYWNlKGMpXG4gIH1cblxuICBmdW5jdGlvbiBpc01hdGNoIChyZWdleCwgYykge1xuICAgIHJldHVybiByZWdleC50ZXN0KGMpXG4gIH1cblxuICBmdW5jdGlvbiBub3RNYXRjaCAocmVnZXgsIGMpIHtcbiAgICByZXR1cm4gIWlzTWF0Y2gocmVnZXgsIGMpXG4gIH1cblxuICB2YXIgUyA9IDBcbiAgc2F4LlNUQVRFID0ge1xuICAgIEJFR0lOOiBTKyssIC8vIGxlYWRpbmcgYnl0ZSBvcmRlciBtYXJrIG9yIHdoaXRlc3BhY2VcbiAgICBCRUdJTl9XSElURVNQQUNFOiBTKyssIC8vIGxlYWRpbmcgd2hpdGVzcGFjZVxuICAgIFRFWFQ6IFMrKywgLy8gZ2VuZXJhbCBzdHVmZlxuICAgIFRFWFRfRU5USVRZOiBTKyssIC8vICZhbXAgYW5kIHN1Y2guXG4gICAgT1BFTl9XQUtBOiBTKyssIC8vIDxcbiAgICBTR01MX0RFQ0w6IFMrKywgLy8gPCFCTEFSR1xuICAgIFNHTUxfREVDTF9RVU9URUQ6IFMrKywgLy8gPCFCTEFSRyBmb28gXCJiYXJcbiAgICBET0NUWVBFOiBTKyssIC8vIDwhRE9DVFlQRVxuICAgIERPQ1RZUEVfUVVPVEVEOiBTKyssIC8vIDwhRE9DVFlQRSBcIi8vYmxhaFxuICAgIERPQ1RZUEVfRFREOiBTKyssIC8vIDwhRE9DVFlQRSBcIi8vYmxhaFwiIFsgLi4uXG4gICAgRE9DVFlQRV9EVERfUVVPVEVEOiBTKyssIC8vIDwhRE9DVFlQRSBcIi8vYmxhaFwiIFsgXCJmb29cbiAgICBDT01NRU5UX1NUQVJUSU5HOiBTKyssIC8vIDwhLVxuICAgIENPTU1FTlQ6IFMrKywgLy8gPCEtLVxuICAgIENPTU1FTlRfRU5ESU5HOiBTKyssIC8vIDwhLS0gYmxhaCAtXG4gICAgQ09NTUVOVF9FTkRFRDogUysrLCAvLyA8IS0tIGJsYWggLS1cbiAgICBDREFUQTogUysrLCAvLyA8IVtDREFUQVsgc29tZXRoaW5nXG4gICAgQ0RBVEFfRU5ESU5HOiBTKyssIC8vIF1cbiAgICBDREFUQV9FTkRJTkdfMjogUysrLCAvLyBdXVxuICAgIFBST0NfSU5TVDogUysrLCAvLyA8P2hpXG4gICAgUFJPQ19JTlNUX0JPRFk6IFMrKywgLy8gPD9oaSB0aGVyZVxuICAgIFBST0NfSU5TVF9FTkRJTkc6IFMrKywgLy8gPD9oaSBcInRoZXJlXCIgP1xuICAgIE9QRU5fVEFHOiBTKyssIC8vIDxzdHJvbmdcbiAgICBPUEVOX1RBR19TTEFTSDogUysrLCAvLyA8c3Ryb25nIC9cbiAgICBBVFRSSUI6IFMrKywgLy8gPGFcbiAgICBBVFRSSUJfTkFNRTogUysrLCAvLyA8YSBmb29cbiAgICBBVFRSSUJfTkFNRV9TQVdfV0hJVEU6IFMrKywgLy8gPGEgZm9vIF9cbiAgICBBVFRSSUJfVkFMVUU6IFMrKywgLy8gPGEgZm9vPVxuICAgIEFUVFJJQl9WQUxVRV9RVU9URUQ6IFMrKywgLy8gPGEgZm9vPVwiYmFyXG4gICAgQVRUUklCX1ZBTFVFX0NMT1NFRDogUysrLCAvLyA8YSBmb289XCJiYXJcIlxuICAgIEFUVFJJQl9WQUxVRV9VTlFVT1RFRDogUysrLCAvLyA8YSBmb289YmFyXG4gICAgQVRUUklCX1ZBTFVFX0VOVElUWV9ROiBTKyssIC8vIDxmb28gYmFyPVwiJnF1b3Q7XCJcbiAgICBBVFRSSUJfVkFMVUVfRU5USVRZX1U6IFMrKywgLy8gPGZvbyBiYXI9JnF1b3RcbiAgICBDTE9TRV9UQUc6IFMrKywgLy8gPC9hXG4gICAgQ0xPU0VfVEFHX1NBV19XSElURTogUysrLCAvLyA8L2EgICA+XG4gICAgU0NSSVBUOiBTKyssIC8vIDxzY3JpcHQ+IC4uLlxuICAgIFNDUklQVF9FTkRJTkc6IFMrKyAvLyA8c2NyaXB0PiAuLi4gPFxuICB9XG5cbiAgc2F4LlhNTF9FTlRJVElFUyA9IHtcbiAgICAnYW1wJzogJyYnLFxuICAgICdndCc6ICc+JyxcbiAgICAnbHQnOiAnPCcsXG4gICAgJ3F1b3QnOiAnXCInLFxuICAgICdhcG9zJzogXCInXCJcbiAgfVxuXG4gIHNheC5FTlRJVElFUyA9IHtcbiAgICAnYW1wJzogJyYnLFxuICAgICdndCc6ICc+JyxcbiAgICAnbHQnOiAnPCcsXG4gICAgJ3F1b3QnOiAnXCInLFxuICAgICdhcG9zJzogXCInXCIsXG4gICAgJ0FFbGlnJzogMTk4LFxuICAgICdBYWN1dGUnOiAxOTMsXG4gICAgJ0FjaXJjJzogMTk0LFxuICAgICdBZ3JhdmUnOiAxOTIsXG4gICAgJ0FyaW5nJzogMTk3LFxuICAgICdBdGlsZGUnOiAxOTUsXG4gICAgJ0F1bWwnOiAxOTYsXG4gICAgJ0NjZWRpbCc6IDE5OSxcbiAgICAnRVRIJzogMjA4LFxuICAgICdFYWN1dGUnOiAyMDEsXG4gICAgJ0VjaXJjJzogMjAyLFxuICAgICdFZ3JhdmUnOiAyMDAsXG4gICAgJ0V1bWwnOiAyMDMsXG4gICAgJ0lhY3V0ZSc6IDIwNSxcbiAgICAnSWNpcmMnOiAyMDYsXG4gICAgJ0lncmF2ZSc6IDIwNCxcbiAgICAnSXVtbCc6IDIwNyxcbiAgICAnTnRpbGRlJzogMjA5LFxuICAgICdPYWN1dGUnOiAyMTEsXG4gICAgJ09jaXJjJzogMjEyLFxuICAgICdPZ3JhdmUnOiAyMTAsXG4gICAgJ09zbGFzaCc6IDIxNixcbiAgICAnT3RpbGRlJzogMjEzLFxuICAgICdPdW1sJzogMjE0LFxuICAgICdUSE9STic6IDIyMixcbiAgICAnVWFjdXRlJzogMjE4LFxuICAgICdVY2lyYyc6IDIxOSxcbiAgICAnVWdyYXZlJzogMjE3LFxuICAgICdVdW1sJzogMjIwLFxuICAgICdZYWN1dGUnOiAyMjEsXG4gICAgJ2FhY3V0ZSc6IDIyNSxcbiAgICAnYWNpcmMnOiAyMjYsXG4gICAgJ2FlbGlnJzogMjMwLFxuICAgICdhZ3JhdmUnOiAyMjQsXG4gICAgJ2FyaW5nJzogMjI5LFxuICAgICdhdGlsZGUnOiAyMjcsXG4gICAgJ2F1bWwnOiAyMjgsXG4gICAgJ2NjZWRpbCc6IDIzMSxcbiAgICAnZWFjdXRlJzogMjMzLFxuICAgICdlY2lyYyc6IDIzNCxcbiAgICAnZWdyYXZlJzogMjMyLFxuICAgICdldGgnOiAyNDAsXG4gICAgJ2V1bWwnOiAyMzUsXG4gICAgJ2lhY3V0ZSc6IDIzNyxcbiAgICAnaWNpcmMnOiAyMzgsXG4gICAgJ2lncmF2ZSc6IDIzNixcbiAgICAnaXVtbCc6IDIzOSxcbiAgICAnbnRpbGRlJzogMjQxLFxuICAgICdvYWN1dGUnOiAyNDMsXG4gICAgJ29jaXJjJzogMjQ0LFxuICAgICdvZ3JhdmUnOiAyNDIsXG4gICAgJ29zbGFzaCc6IDI0OCxcbiAgICAnb3RpbGRlJzogMjQ1LFxuICAgICdvdW1sJzogMjQ2LFxuICAgICdzemxpZyc6IDIyMyxcbiAgICAndGhvcm4nOiAyNTQsXG4gICAgJ3VhY3V0ZSc6IDI1MCxcbiAgICAndWNpcmMnOiAyNTEsXG4gICAgJ3VncmF2ZSc6IDI0OSxcbiAgICAndXVtbCc6IDI1MixcbiAgICAneWFjdXRlJzogMjUzLFxuICAgICd5dW1sJzogMjU1LFxuICAgICdjb3B5JzogMTY5LFxuICAgICdyZWcnOiAxNzQsXG4gICAgJ25ic3AnOiAxNjAsXG4gICAgJ2lleGNsJzogMTYxLFxuICAgICdjZW50JzogMTYyLFxuICAgICdwb3VuZCc6IDE2MyxcbiAgICAnY3VycmVuJzogMTY0LFxuICAgICd5ZW4nOiAxNjUsXG4gICAgJ2JydmJhcic6IDE2NixcbiAgICAnc2VjdCc6IDE2NyxcbiAgICAndW1sJzogMTY4LFxuICAgICdvcmRmJzogMTcwLFxuICAgICdsYXF1byc6IDE3MSxcbiAgICAnbm90JzogMTcyLFxuICAgICdzaHknOiAxNzMsXG4gICAgJ21hY3InOiAxNzUsXG4gICAgJ2RlZyc6IDE3NixcbiAgICAncGx1c21uJzogMTc3LFxuICAgICdzdXAxJzogMTg1LFxuICAgICdzdXAyJzogMTc4LFxuICAgICdzdXAzJzogMTc5LFxuICAgICdhY3V0ZSc6IDE4MCxcbiAgICAnbWljcm8nOiAxODEsXG4gICAgJ3BhcmEnOiAxODIsXG4gICAgJ21pZGRvdCc6IDE4MyxcbiAgICAnY2VkaWwnOiAxODQsXG4gICAgJ29yZG0nOiAxODYsXG4gICAgJ3JhcXVvJzogMTg3LFxuICAgICdmcmFjMTQnOiAxODgsXG4gICAgJ2ZyYWMxMic6IDE4OSxcbiAgICAnZnJhYzM0JzogMTkwLFxuICAgICdpcXVlc3QnOiAxOTEsXG4gICAgJ3RpbWVzJzogMjE1LFxuICAgICdkaXZpZGUnOiAyNDcsXG4gICAgJ09FbGlnJzogMzM4LFxuICAgICdvZWxpZyc6IDMzOSxcbiAgICAnU2Nhcm9uJzogMzUyLFxuICAgICdzY2Fyb24nOiAzNTMsXG4gICAgJ1l1bWwnOiAzNzYsXG4gICAgJ2Zub2YnOiA0MDIsXG4gICAgJ2NpcmMnOiA3MTAsXG4gICAgJ3RpbGRlJzogNzMyLFxuICAgICdBbHBoYSc6IDkxMyxcbiAgICAnQmV0YSc6IDkxNCxcbiAgICAnR2FtbWEnOiA5MTUsXG4gICAgJ0RlbHRhJzogOTE2LFxuICAgICdFcHNpbG9uJzogOTE3LFxuICAgICdaZXRhJzogOTE4LFxuICAgICdFdGEnOiA5MTksXG4gICAgJ1RoZXRhJzogOTIwLFxuICAgICdJb3RhJzogOTIxLFxuICAgICdLYXBwYSc6IDkyMixcbiAgICAnTGFtYmRhJzogOTIzLFxuICAgICdNdSc6IDkyNCxcbiAgICAnTnUnOiA5MjUsXG4gICAgJ1hpJzogOTI2LFxuICAgICdPbWljcm9uJzogOTI3LFxuICAgICdQaSc6IDkyOCxcbiAgICAnUmhvJzogOTI5LFxuICAgICdTaWdtYSc6IDkzMSxcbiAgICAnVGF1JzogOTMyLFxuICAgICdVcHNpbG9uJzogOTMzLFxuICAgICdQaGknOiA5MzQsXG4gICAgJ0NoaSc6IDkzNSxcbiAgICAnUHNpJzogOTM2LFxuICAgICdPbWVnYSc6IDkzNyxcbiAgICAnYWxwaGEnOiA5NDUsXG4gICAgJ2JldGEnOiA5NDYsXG4gICAgJ2dhbW1hJzogOTQ3LFxuICAgICdkZWx0YSc6IDk0OCxcbiAgICAnZXBzaWxvbic6IDk0OSxcbiAgICAnemV0YSc6IDk1MCxcbiAgICAnZXRhJzogOTUxLFxuICAgICd0aGV0YSc6IDk1MixcbiAgICAnaW90YSc6IDk1MyxcbiAgICAna2FwcGEnOiA5NTQsXG4gICAgJ2xhbWJkYSc6IDk1NSxcbiAgICAnbXUnOiA5NTYsXG4gICAgJ251JzogOTU3LFxuICAgICd4aSc6IDk1OCxcbiAgICAnb21pY3Jvbic6IDk1OSxcbiAgICAncGknOiA5NjAsXG4gICAgJ3Jobyc6IDk2MSxcbiAgICAnc2lnbWFmJzogOTYyLFxuICAgICdzaWdtYSc6IDk2MyxcbiAgICAndGF1JzogOTY0LFxuICAgICd1cHNpbG9uJzogOTY1LFxuICAgICdwaGknOiA5NjYsXG4gICAgJ2NoaSc6IDk2NyxcbiAgICAncHNpJzogOTY4LFxuICAgICdvbWVnYSc6IDk2OSxcbiAgICAndGhldGFzeW0nOiA5NzcsXG4gICAgJ3Vwc2loJzogOTc4LFxuICAgICdwaXYnOiA5ODIsXG4gICAgJ2Vuc3AnOiA4MTk0LFxuICAgICdlbXNwJzogODE5NSxcbiAgICAndGhpbnNwJzogODIwMSxcbiAgICAnenduaic6IDgyMDQsXG4gICAgJ3p3aic6IDgyMDUsXG4gICAgJ2xybSc6IDgyMDYsXG4gICAgJ3JsbSc6IDgyMDcsXG4gICAgJ25kYXNoJzogODIxMSxcbiAgICAnbWRhc2gnOiA4MjEyLFxuICAgICdsc3F1byc6IDgyMTYsXG4gICAgJ3JzcXVvJzogODIxNyxcbiAgICAnc2JxdW8nOiA4MjE4LFxuICAgICdsZHF1byc6IDgyMjAsXG4gICAgJ3JkcXVvJzogODIyMSxcbiAgICAnYmRxdW8nOiA4MjIyLFxuICAgICdkYWdnZXInOiA4MjI0LFxuICAgICdEYWdnZXInOiA4MjI1LFxuICAgICdidWxsJzogODIyNixcbiAgICAnaGVsbGlwJzogODIzMCxcbiAgICAncGVybWlsJzogODI0MCxcbiAgICAncHJpbWUnOiA4MjQyLFxuICAgICdQcmltZSc6IDgyNDMsXG4gICAgJ2xzYXF1byc6IDgyNDksXG4gICAgJ3JzYXF1byc6IDgyNTAsXG4gICAgJ29saW5lJzogODI1NCxcbiAgICAnZnJhc2wnOiA4MjYwLFxuICAgICdldXJvJzogODM2NCxcbiAgICAnaW1hZ2UnOiA4NDY1LFxuICAgICd3ZWllcnAnOiA4NDcyLFxuICAgICdyZWFsJzogODQ3NixcbiAgICAndHJhZGUnOiA4NDgyLFxuICAgICdhbGVmc3ltJzogODUwMSxcbiAgICAnbGFycic6IDg1OTIsXG4gICAgJ3VhcnInOiA4NTkzLFxuICAgICdyYXJyJzogODU5NCxcbiAgICAnZGFycic6IDg1OTUsXG4gICAgJ2hhcnInOiA4NTk2LFxuICAgICdjcmFycic6IDg2MjksXG4gICAgJ2xBcnInOiA4NjU2LFxuICAgICd1QXJyJzogODY1NyxcbiAgICAnckFycic6IDg2NTgsXG4gICAgJ2RBcnInOiA4NjU5LFxuICAgICdoQXJyJzogODY2MCxcbiAgICAnZm9yYWxsJzogODcwNCxcbiAgICAncGFydCc6IDg3MDYsXG4gICAgJ2V4aXN0JzogODcwNyxcbiAgICAnZW1wdHknOiA4NzA5LFxuICAgICduYWJsYSc6IDg3MTEsXG4gICAgJ2lzaW4nOiA4NzEyLFxuICAgICdub3Rpbic6IDg3MTMsXG4gICAgJ25pJzogODcxNSxcbiAgICAncHJvZCc6IDg3MTksXG4gICAgJ3N1bSc6IDg3MjEsXG4gICAgJ21pbnVzJzogODcyMixcbiAgICAnbG93YXN0JzogODcyNyxcbiAgICAncmFkaWMnOiA4NzMwLFxuICAgICdwcm9wJzogODczMyxcbiAgICAnaW5maW4nOiA4NzM0LFxuICAgICdhbmcnOiA4NzM2LFxuICAgICdhbmQnOiA4NzQzLFxuICAgICdvcic6IDg3NDQsXG4gICAgJ2NhcCc6IDg3NDUsXG4gICAgJ2N1cCc6IDg3NDYsXG4gICAgJ2ludCc6IDg3NDcsXG4gICAgJ3RoZXJlNCc6IDg3NTYsXG4gICAgJ3NpbSc6IDg3NjQsXG4gICAgJ2NvbmcnOiA4NzczLFxuICAgICdhc3ltcCc6IDg3NzYsXG4gICAgJ25lJzogODgwMCxcbiAgICAnZXF1aXYnOiA4ODAxLFxuICAgICdsZSc6IDg4MDQsXG4gICAgJ2dlJzogODgwNSxcbiAgICAnc3ViJzogODgzNCxcbiAgICAnc3VwJzogODgzNSxcbiAgICAnbnN1Yic6IDg4MzYsXG4gICAgJ3N1YmUnOiA4ODM4LFxuICAgICdzdXBlJzogODgzOSxcbiAgICAnb3BsdXMnOiA4ODUzLFxuICAgICdvdGltZXMnOiA4ODU1LFxuICAgICdwZXJwJzogODg2OSxcbiAgICAnc2RvdCc6IDg5MDEsXG4gICAgJ2xjZWlsJzogODk2OCxcbiAgICAncmNlaWwnOiA4OTY5LFxuICAgICdsZmxvb3InOiA4OTcwLFxuICAgICdyZmxvb3InOiA4OTcxLFxuICAgICdsYW5nJzogOTAwMSxcbiAgICAncmFuZyc6IDkwMDIsXG4gICAgJ2xveic6IDk2NzQsXG4gICAgJ3NwYWRlcyc6IDk4MjQsXG4gICAgJ2NsdWJzJzogOTgyNyxcbiAgICAnaGVhcnRzJzogOTgyOSxcbiAgICAnZGlhbXMnOiA5ODMwXG4gIH1cblxuICBPYmplY3Qua2V5cyhzYXguRU5USVRJRVMpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgIHZhciBlID0gc2F4LkVOVElUSUVTW2tleV1cbiAgICB2YXIgcyA9IHR5cGVvZiBlID09PSAnbnVtYmVyJyA/IFN0cmluZy5mcm9tQ2hhckNvZGUoZSkgOiBlXG4gICAgc2F4LkVOVElUSUVTW2tleV0gPSBzXG4gIH0pXG5cbiAgZm9yICh2YXIgcyBpbiBzYXguU1RBVEUpIHtcbiAgICBzYXguU1RBVEVbc2F4LlNUQVRFW3NdXSA9IHNcbiAgfVxuXG4gIC8vIHNob3J0aGFuZFxuICBTID0gc2F4LlNUQVRFXG5cbiAgZnVuY3Rpb24gZW1pdCAocGFyc2VyLCBldmVudCwgZGF0YSkge1xuICAgIHBhcnNlcltldmVudF0gJiYgcGFyc2VyW2V2ZW50XShkYXRhKVxuICB9XG5cbiAgZnVuY3Rpb24gZW1pdE5vZGUgKHBhcnNlciwgbm9kZVR5cGUsIGRhdGEpIHtcbiAgICBpZiAocGFyc2VyLnRleHROb2RlKSBjbG9zZVRleHQocGFyc2VyKVxuICAgIGVtaXQocGFyc2VyLCBub2RlVHlwZSwgZGF0YSlcbiAgfVxuXG4gIGZ1bmN0aW9uIGNsb3NlVGV4dCAocGFyc2VyKSB7XG4gICAgcGFyc2VyLnRleHROb2RlID0gdGV4dG9wdHMocGFyc2VyLm9wdCwgcGFyc2VyLnRleHROb2RlKVxuICAgIGlmIChwYXJzZXIudGV4dE5vZGUpIGVtaXQocGFyc2VyLCAnb250ZXh0JywgcGFyc2VyLnRleHROb2RlKVxuICAgIHBhcnNlci50ZXh0Tm9kZSA9ICcnXG4gIH1cblxuICBmdW5jdGlvbiB0ZXh0b3B0cyAob3B0LCB0ZXh0KSB7XG4gICAgaWYgKG9wdC50cmltKSB0ZXh0ID0gdGV4dC50cmltKClcbiAgICBpZiAob3B0Lm5vcm1hbGl6ZSkgdGV4dCA9IHRleHQucmVwbGFjZSgvXFxzKy9nLCAnICcpXG4gICAgcmV0dXJuIHRleHRcbiAgfVxuXG4gIGZ1bmN0aW9uIGVycm9yIChwYXJzZXIsIGVyKSB7XG4gICAgY2xvc2VUZXh0KHBhcnNlcilcbiAgICBpZiAocGFyc2VyLnRyYWNrUG9zaXRpb24pIHtcbiAgICAgIGVyICs9ICdcXG5MaW5lOiAnICsgcGFyc2VyLmxpbmUgK1xuICAgICAgICAnXFxuQ29sdW1uOiAnICsgcGFyc2VyLmNvbHVtbiArXG4gICAgICAgICdcXG5DaGFyOiAnICsgcGFyc2VyLmNcbiAgICB9XG4gICAgZXIgPSBuZXcgRXJyb3IoZXIpXG4gICAgcGFyc2VyLmVycm9yID0gZXJcbiAgICBlbWl0KHBhcnNlciwgJ29uZXJyb3InLCBlcilcbiAgICByZXR1cm4gcGFyc2VyXG4gIH1cblxuICBmdW5jdGlvbiBlbmQgKHBhcnNlcikge1xuICAgIGlmIChwYXJzZXIuc2F3Um9vdCAmJiAhcGFyc2VyLmNsb3NlZFJvb3QpIHN0cmljdEZhaWwocGFyc2VyLCAnVW5jbG9zZWQgcm9vdCB0YWcnKVxuICAgIGlmICgocGFyc2VyLnN0YXRlICE9PSBTLkJFR0lOKSAmJlxuICAgICAgKHBhcnNlci5zdGF0ZSAhPT0gUy5CRUdJTl9XSElURVNQQUNFKSAmJlxuICAgICAgKHBhcnNlci5zdGF0ZSAhPT0gUy5URVhUKSkge1xuICAgICAgZXJyb3IocGFyc2VyLCAnVW5leHBlY3RlZCBlbmQnKVxuICAgIH1cbiAgICBjbG9zZVRleHQocGFyc2VyKVxuICAgIHBhcnNlci5jID0gJydcbiAgICBwYXJzZXIuY2xvc2VkID0gdHJ1ZVxuICAgIGVtaXQocGFyc2VyLCAnb25lbmQnKVxuICAgIFNBWFBhcnNlci5jYWxsKHBhcnNlciwgcGFyc2VyLnN0cmljdCwgcGFyc2VyLm9wdClcbiAgICByZXR1cm4gcGFyc2VyXG4gIH1cblxuICBmdW5jdGlvbiBzdHJpY3RGYWlsIChwYXJzZXIsIG1lc3NhZ2UpIHtcbiAgICBpZiAodHlwZW9mIHBhcnNlciAhPT0gJ29iamVjdCcgfHwgIShwYXJzZXIgaW5zdGFuY2VvZiBTQVhQYXJzZXIpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2JhZCBjYWxsIHRvIHN0cmljdEZhaWwnKVxuICAgIH1cbiAgICBpZiAocGFyc2VyLnN0cmljdCkge1xuICAgICAgZXJyb3IocGFyc2VyLCBtZXNzYWdlKVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIG5ld1RhZyAocGFyc2VyKSB7XG4gICAgaWYgKCFwYXJzZXIuc3RyaWN0KSBwYXJzZXIudGFnTmFtZSA9IHBhcnNlci50YWdOYW1lW3BhcnNlci5sb29zZUNhc2VdKClcbiAgICB2YXIgcGFyZW50ID0gcGFyc2VyLnRhZ3NbcGFyc2VyLnRhZ3MubGVuZ3RoIC0gMV0gfHwgcGFyc2VyXG4gICAgdmFyIHRhZyA9IHBhcnNlci50YWcgPSB7IG5hbWU6IHBhcnNlci50YWdOYW1lLCBhdHRyaWJ1dGVzOiB7fSB9XG5cbiAgICAvLyB3aWxsIGJlIG92ZXJyaWRkZW4gaWYgdGFnIGNvbnRhaWxzIGFuIHhtbG5zPVwiZm9vXCIgb3IgeG1sbnM6Zm9vPVwiYmFyXCJcbiAgICBpZiAocGFyc2VyLm9wdC54bWxucykge1xuICAgICAgdGFnLm5zID0gcGFyZW50Lm5zXG4gICAgfVxuICAgIHBhcnNlci5hdHRyaWJMaXN0Lmxlbmd0aCA9IDBcbiAgICBlbWl0Tm9kZShwYXJzZXIsICdvbm9wZW50YWdzdGFydCcsIHRhZylcbiAgfVxuXG4gIGZ1bmN0aW9uIHFuYW1lIChuYW1lLCBhdHRyaWJ1dGUpIHtcbiAgICB2YXIgaSA9IG5hbWUuaW5kZXhPZignOicpXG4gICAgdmFyIHF1YWxOYW1lID0gaSA8IDAgPyBbICcnLCBuYW1lIF0gOiBuYW1lLnNwbGl0KCc6JylcbiAgICB2YXIgcHJlZml4ID0gcXVhbE5hbWVbMF1cbiAgICB2YXIgbG9jYWwgPSBxdWFsTmFtZVsxXVxuXG4gICAgLy8gPHggXCJ4bWxuc1wiPVwiaHR0cDovL2Zvb1wiPlxuICAgIGlmIChhdHRyaWJ1dGUgJiYgbmFtZSA9PT0gJ3htbG5zJykge1xuICAgICAgcHJlZml4ID0gJ3htbG5zJ1xuICAgICAgbG9jYWwgPSAnJ1xuICAgIH1cblxuICAgIHJldHVybiB7IHByZWZpeDogcHJlZml4LCBsb2NhbDogbG9jYWwgfVxuICB9XG5cbiAgZnVuY3Rpb24gYXR0cmliIChwYXJzZXIpIHtcbiAgICBpZiAoIXBhcnNlci5zdHJpY3QpIHtcbiAgICAgIHBhcnNlci5hdHRyaWJOYW1lID0gcGFyc2VyLmF0dHJpYk5hbWVbcGFyc2VyLmxvb3NlQ2FzZV0oKVxuICAgIH1cblxuICAgIGlmIChwYXJzZXIuYXR0cmliTGlzdC5pbmRleE9mKHBhcnNlci5hdHRyaWJOYW1lKSAhPT0gLTEgfHxcbiAgICAgIHBhcnNlci50YWcuYXR0cmlidXRlcy5oYXNPd25Qcm9wZXJ0eShwYXJzZXIuYXR0cmliTmFtZSkpIHtcbiAgICAgIHBhcnNlci5hdHRyaWJOYW1lID0gcGFyc2VyLmF0dHJpYlZhbHVlID0gJydcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIGlmIChwYXJzZXIub3B0LnhtbG5zKSB7XG4gICAgICB2YXIgcW4gPSBxbmFtZShwYXJzZXIuYXR0cmliTmFtZSwgdHJ1ZSlcbiAgICAgIHZhciBwcmVmaXggPSBxbi5wcmVmaXhcbiAgICAgIHZhciBsb2NhbCA9IHFuLmxvY2FsXG5cbiAgICAgIGlmIChwcmVmaXggPT09ICd4bWxucycpIHtcbiAgICAgICAgLy8gbmFtZXNwYWNlIGJpbmRpbmcgYXR0cmlidXRlLiBwdXNoIHRoZSBiaW5kaW5nIGludG8gc2NvcGVcbiAgICAgICAgaWYgKGxvY2FsID09PSAneG1sJyAmJiBwYXJzZXIuYXR0cmliVmFsdWUgIT09IFhNTF9OQU1FU1BBQ0UpIHtcbiAgICAgICAgICBzdHJpY3RGYWlsKHBhcnNlcixcbiAgICAgICAgICAgICd4bWw6IHByZWZpeCBtdXN0IGJlIGJvdW5kIHRvICcgKyBYTUxfTkFNRVNQQUNFICsgJ1xcbicgK1xuICAgICAgICAgICAgJ0FjdHVhbDogJyArIHBhcnNlci5hdHRyaWJWYWx1ZSlcbiAgICAgICAgfSBlbHNlIGlmIChsb2NhbCA9PT0gJ3htbG5zJyAmJiBwYXJzZXIuYXR0cmliVmFsdWUgIT09IFhNTE5TX05BTUVTUEFDRSkge1xuICAgICAgICAgIHN0cmljdEZhaWwocGFyc2VyLFxuICAgICAgICAgICAgJ3htbG5zOiBwcmVmaXggbXVzdCBiZSBib3VuZCB0byAnICsgWE1MTlNfTkFNRVNQQUNFICsgJ1xcbicgK1xuICAgICAgICAgICAgJ0FjdHVhbDogJyArIHBhcnNlci5hdHRyaWJWYWx1ZSlcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YXIgdGFnID0gcGFyc2VyLnRhZ1xuICAgICAgICAgIHZhciBwYXJlbnQgPSBwYXJzZXIudGFnc1twYXJzZXIudGFncy5sZW5ndGggLSAxXSB8fCBwYXJzZXJcbiAgICAgICAgICBpZiAodGFnLm5zID09PSBwYXJlbnQubnMpIHtcbiAgICAgICAgICAgIHRhZy5ucyA9IE9iamVjdC5jcmVhdGUocGFyZW50Lm5zKVxuICAgICAgICAgIH1cbiAgICAgICAgICB0YWcubnNbbG9jYWxdID0gcGFyc2VyLmF0dHJpYlZhbHVlXG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gZGVmZXIgb25hdHRyaWJ1dGUgZXZlbnRzIHVudGlsIGFsbCBhdHRyaWJ1dGVzIGhhdmUgYmVlbiBzZWVuXG4gICAgICAvLyBzbyBhbnkgbmV3IGJpbmRpbmdzIGNhbiB0YWtlIGVmZmVjdC4gcHJlc2VydmUgYXR0cmlidXRlIG9yZGVyXG4gICAgICAvLyBzbyBkZWZlcnJlZCBldmVudHMgY2FuIGJlIGVtaXR0ZWQgaW4gZG9jdW1lbnQgb3JkZXJcbiAgICAgIHBhcnNlci5hdHRyaWJMaXN0LnB1c2goW3BhcnNlci5hdHRyaWJOYW1lLCBwYXJzZXIuYXR0cmliVmFsdWVdKVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBpbiBub24teG1sbnMgbW9kZSwgd2UgY2FuIGVtaXQgdGhlIGV2ZW50IHJpZ2h0IGF3YXlcbiAgICAgIHBhcnNlci50YWcuYXR0cmlidXRlc1twYXJzZXIuYXR0cmliTmFtZV0gPSBwYXJzZXIuYXR0cmliVmFsdWVcbiAgICAgIGVtaXROb2RlKHBhcnNlciwgJ29uYXR0cmlidXRlJywge1xuICAgICAgICBuYW1lOiBwYXJzZXIuYXR0cmliTmFtZSxcbiAgICAgICAgdmFsdWU6IHBhcnNlci5hdHRyaWJWYWx1ZVxuICAgICAgfSlcbiAgICB9XG5cbiAgICBwYXJzZXIuYXR0cmliTmFtZSA9IHBhcnNlci5hdHRyaWJWYWx1ZSA9ICcnXG4gIH1cblxuICBmdW5jdGlvbiBvcGVuVGFnIChwYXJzZXIsIHNlbGZDbG9zaW5nKSB7XG4gICAgaWYgKHBhcnNlci5vcHQueG1sbnMpIHtcbiAgICAgIC8vIGVtaXQgbmFtZXNwYWNlIGJpbmRpbmcgZXZlbnRzXG4gICAgICB2YXIgdGFnID0gcGFyc2VyLnRhZ1xuXG4gICAgICAvLyBhZGQgbmFtZXNwYWNlIGluZm8gdG8gdGFnXG4gICAgICB2YXIgcW4gPSBxbmFtZShwYXJzZXIudGFnTmFtZSlcbiAgICAgIHRhZy5wcmVmaXggPSBxbi5wcmVmaXhcbiAgICAgIHRhZy5sb2NhbCA9IHFuLmxvY2FsXG4gICAgICB0YWcudXJpID0gdGFnLm5zW3FuLnByZWZpeF0gfHwgJydcblxuICAgICAgaWYgKHRhZy5wcmVmaXggJiYgIXRhZy51cmkpIHtcbiAgICAgICAgc3RyaWN0RmFpbChwYXJzZXIsICdVbmJvdW5kIG5hbWVzcGFjZSBwcmVmaXg6ICcgK1xuICAgICAgICAgIEpTT04uc3RyaW5naWZ5KHBhcnNlci50YWdOYW1lKSlcbiAgICAgICAgdGFnLnVyaSA9IHFuLnByZWZpeFxuICAgICAgfVxuXG4gICAgICB2YXIgcGFyZW50ID0gcGFyc2VyLnRhZ3NbcGFyc2VyLnRhZ3MubGVuZ3RoIC0gMV0gfHwgcGFyc2VyXG4gICAgICBpZiAodGFnLm5zICYmIHBhcmVudC5ucyAhPT0gdGFnLm5zKSB7XG4gICAgICAgIE9iamVjdC5rZXlzKHRhZy5ucykuZm9yRWFjaChmdW5jdGlvbiAocCkge1xuICAgICAgICAgIGVtaXROb2RlKHBhcnNlciwgJ29ub3Blbm5hbWVzcGFjZScsIHtcbiAgICAgICAgICAgIHByZWZpeDogcCxcbiAgICAgICAgICAgIHVyaTogdGFnLm5zW3BdXG4gICAgICAgICAgfSlcbiAgICAgICAgfSlcbiAgICAgIH1cblxuICAgICAgLy8gaGFuZGxlIGRlZmVycmVkIG9uYXR0cmlidXRlIGV2ZW50c1xuICAgICAgLy8gTm90ZTogZG8gbm90IGFwcGx5IGRlZmF1bHQgbnMgdG8gYXR0cmlidXRlczpcbiAgICAgIC8vICAgaHR0cDovL3d3dy53My5vcmcvVFIvUkVDLXhtbC1uYW1lcy8jZGVmYXVsdGluZ1xuICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBwYXJzZXIuYXR0cmliTGlzdC5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgdmFyIG52ID0gcGFyc2VyLmF0dHJpYkxpc3RbaV1cbiAgICAgICAgdmFyIG5hbWUgPSBudlswXVxuICAgICAgICB2YXIgdmFsdWUgPSBudlsxXVxuICAgICAgICB2YXIgcXVhbE5hbWUgPSBxbmFtZShuYW1lLCB0cnVlKVxuICAgICAgICB2YXIgcHJlZml4ID0gcXVhbE5hbWUucHJlZml4XG4gICAgICAgIHZhciBsb2NhbCA9IHF1YWxOYW1lLmxvY2FsXG4gICAgICAgIHZhciB1cmkgPSBwcmVmaXggPT09ICcnID8gJycgOiAodGFnLm5zW3ByZWZpeF0gfHwgJycpXG4gICAgICAgIHZhciBhID0ge1xuICAgICAgICAgIG5hbWU6IG5hbWUsXG4gICAgICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgICAgIHByZWZpeDogcHJlZml4LFxuICAgICAgICAgIGxvY2FsOiBsb2NhbCxcbiAgICAgICAgICB1cmk6IHVyaVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gaWYgdGhlcmUncyBhbnkgYXR0cmlidXRlcyB3aXRoIGFuIHVuZGVmaW5lZCBuYW1lc3BhY2UsXG4gICAgICAgIC8vIHRoZW4gZmFpbCBvbiB0aGVtIG5vdy5cbiAgICAgICAgaWYgKHByZWZpeCAmJiBwcmVmaXggIT09ICd4bWxucycgJiYgIXVyaSkge1xuICAgICAgICAgIHN0cmljdEZhaWwocGFyc2VyLCAnVW5ib3VuZCBuYW1lc3BhY2UgcHJlZml4OiAnICtcbiAgICAgICAgICAgIEpTT04uc3RyaW5naWZ5KHByZWZpeCkpXG4gICAgICAgICAgYS51cmkgPSBwcmVmaXhcbiAgICAgICAgfVxuICAgICAgICBwYXJzZXIudGFnLmF0dHJpYnV0ZXNbbmFtZV0gPSBhXG4gICAgICAgIGVtaXROb2RlKHBhcnNlciwgJ29uYXR0cmlidXRlJywgYSlcbiAgICAgIH1cbiAgICAgIHBhcnNlci5hdHRyaWJMaXN0Lmxlbmd0aCA9IDBcbiAgICB9XG5cbiAgICBwYXJzZXIudGFnLmlzU2VsZkNsb3NpbmcgPSAhIXNlbGZDbG9zaW5nXG5cbiAgICAvLyBwcm9jZXNzIHRoZSB0YWdcbiAgICBwYXJzZXIuc2F3Um9vdCA9IHRydWVcbiAgICBwYXJzZXIudGFncy5wdXNoKHBhcnNlci50YWcpXG4gICAgZW1pdE5vZGUocGFyc2VyLCAnb25vcGVudGFnJywgcGFyc2VyLnRhZylcbiAgICBpZiAoIXNlbGZDbG9zaW5nKSB7XG4gICAgICAvLyBzcGVjaWFsIGNhc2UgZm9yIDxzY3JpcHQ+IGluIG5vbi1zdHJpY3QgbW9kZS5cbiAgICAgIGlmICghcGFyc2VyLm5vc2NyaXB0ICYmIHBhcnNlci50YWdOYW1lLnRvTG93ZXJDYXNlKCkgPT09ICdzY3JpcHQnKSB7XG4gICAgICAgIHBhcnNlci5zdGF0ZSA9IFMuU0NSSVBUXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwYXJzZXIuc3RhdGUgPSBTLlRFWFRcbiAgICAgIH1cbiAgICAgIHBhcnNlci50YWcgPSBudWxsXG4gICAgICBwYXJzZXIudGFnTmFtZSA9ICcnXG4gICAgfVxuICAgIHBhcnNlci5hdHRyaWJOYW1lID0gcGFyc2VyLmF0dHJpYlZhbHVlID0gJydcbiAgICBwYXJzZXIuYXR0cmliTGlzdC5sZW5ndGggPSAwXG4gIH1cblxuICBmdW5jdGlvbiBjbG9zZVRhZyAocGFyc2VyKSB7XG4gICAgaWYgKCFwYXJzZXIudGFnTmFtZSkge1xuICAgICAgc3RyaWN0RmFpbChwYXJzZXIsICdXZWlyZCBlbXB0eSBjbG9zZSB0YWcuJylcbiAgICAgIHBhcnNlci50ZXh0Tm9kZSArPSAnPC8+J1xuICAgICAgcGFyc2VyLnN0YXRlID0gUy5URVhUXG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICBpZiAocGFyc2VyLnNjcmlwdCkge1xuICAgICAgaWYgKHBhcnNlci50YWdOYW1lICE9PSAnc2NyaXB0Jykge1xuICAgICAgICBwYXJzZXIuc2NyaXB0ICs9ICc8LycgKyBwYXJzZXIudGFnTmFtZSArICc+J1xuICAgICAgICBwYXJzZXIudGFnTmFtZSA9ICcnXG4gICAgICAgIHBhcnNlci5zdGF0ZSA9IFMuU0NSSVBUXG4gICAgICAgIHJldHVyblxuICAgICAgfVxuICAgICAgZW1pdE5vZGUocGFyc2VyLCAnb25zY3JpcHQnLCBwYXJzZXIuc2NyaXB0KVxuICAgICAgcGFyc2VyLnNjcmlwdCA9ICcnXG4gICAgfVxuXG4gICAgLy8gZmlyc3QgbWFrZSBzdXJlIHRoYXQgdGhlIGNsb3NpbmcgdGFnIGFjdHVhbGx5IGV4aXN0cy5cbiAgICAvLyA8YT48Yj48L2M+PC9iPjwvYT4gd2lsbCBjbG9zZSBldmVyeXRoaW5nLCBvdGhlcndpc2UuXG4gICAgdmFyIHQgPSBwYXJzZXIudGFncy5sZW5ndGhcbiAgICB2YXIgdGFnTmFtZSA9IHBhcnNlci50YWdOYW1lXG4gICAgaWYgKCFwYXJzZXIuc3RyaWN0KSB7XG4gICAgICB0YWdOYW1lID0gdGFnTmFtZVtwYXJzZXIubG9vc2VDYXNlXSgpXG4gICAgfVxuICAgIHZhciBjbG9zZVRvID0gdGFnTmFtZVxuICAgIHdoaWxlICh0LS0pIHtcbiAgICAgIHZhciBjbG9zZSA9IHBhcnNlci50YWdzW3RdXG4gICAgICBpZiAoY2xvc2UubmFtZSAhPT0gY2xvc2VUbykge1xuICAgICAgICAvLyBmYWlsIHRoZSBmaXJzdCB0aW1lIGluIHN0cmljdCBtb2RlXG4gICAgICAgIHN0cmljdEZhaWwocGFyc2VyLCAnVW5leHBlY3RlZCBjbG9zZSB0YWcnKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYnJlYWtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBkaWRuJ3QgZmluZCBpdC4gIHdlIGFscmVhZHkgZmFpbGVkIGZvciBzdHJpY3QsIHNvIGp1c3QgYWJvcnQuXG4gICAgaWYgKHQgPCAwKSB7XG4gICAgICBzdHJpY3RGYWlsKHBhcnNlciwgJ1VubWF0Y2hlZCBjbG9zaW5nIHRhZzogJyArIHBhcnNlci50YWdOYW1lKVxuICAgICAgcGFyc2VyLnRleHROb2RlICs9ICc8LycgKyBwYXJzZXIudGFnTmFtZSArICc+J1xuICAgICAgcGFyc2VyLnN0YXRlID0gUy5URVhUXG4gICAgICByZXR1cm5cbiAgICB9XG4gICAgcGFyc2VyLnRhZ05hbWUgPSB0YWdOYW1lXG4gICAgdmFyIHMgPSBwYXJzZXIudGFncy5sZW5ndGhcbiAgICB3aGlsZSAocy0tID4gdCkge1xuICAgICAgdmFyIHRhZyA9IHBhcnNlci50YWcgPSBwYXJzZXIudGFncy5wb3AoKVxuICAgICAgcGFyc2VyLnRhZ05hbWUgPSBwYXJzZXIudGFnLm5hbWVcbiAgICAgIGVtaXROb2RlKHBhcnNlciwgJ29uY2xvc2V0YWcnLCBwYXJzZXIudGFnTmFtZSlcblxuICAgICAgdmFyIHggPSB7fVxuICAgICAgZm9yICh2YXIgaSBpbiB0YWcubnMpIHtcbiAgICAgICAgeFtpXSA9IHRhZy5uc1tpXVxuICAgICAgfVxuXG4gICAgICB2YXIgcGFyZW50ID0gcGFyc2VyLnRhZ3NbcGFyc2VyLnRhZ3MubGVuZ3RoIC0gMV0gfHwgcGFyc2VyXG4gICAgICBpZiAocGFyc2VyLm9wdC54bWxucyAmJiB0YWcubnMgIT09IHBhcmVudC5ucykge1xuICAgICAgICAvLyByZW1vdmUgbmFtZXNwYWNlIGJpbmRpbmdzIGludHJvZHVjZWQgYnkgdGFnXG4gICAgICAgIE9iamVjdC5rZXlzKHRhZy5ucykuZm9yRWFjaChmdW5jdGlvbiAocCkge1xuICAgICAgICAgIHZhciBuID0gdGFnLm5zW3BdXG4gICAgICAgICAgZW1pdE5vZGUocGFyc2VyLCAnb25jbG9zZW5hbWVzcGFjZScsIHsgcHJlZml4OiBwLCB1cmk6IG4gfSlcbiAgICAgICAgfSlcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHQgPT09IDApIHBhcnNlci5jbG9zZWRSb290ID0gdHJ1ZVxuICAgIHBhcnNlci50YWdOYW1lID0gcGFyc2VyLmF0dHJpYlZhbHVlID0gcGFyc2VyLmF0dHJpYk5hbWUgPSAnJ1xuICAgIHBhcnNlci5hdHRyaWJMaXN0Lmxlbmd0aCA9IDBcbiAgICBwYXJzZXIuc3RhdGUgPSBTLlRFWFRcbiAgfVxuXG4gIGZ1bmN0aW9uIHBhcnNlRW50aXR5IChwYXJzZXIpIHtcbiAgICB2YXIgZW50aXR5ID0gcGFyc2VyLmVudGl0eVxuICAgIHZhciBlbnRpdHlMQyA9IGVudGl0eS50b0xvd2VyQ2FzZSgpXG4gICAgdmFyIG51bVxuICAgIHZhciBudW1TdHIgPSAnJ1xuXG4gICAgaWYgKHBhcnNlci5FTlRJVElFU1tlbnRpdHldKSB7XG4gICAgICByZXR1cm4gcGFyc2VyLkVOVElUSUVTW2VudGl0eV1cbiAgICB9XG4gICAgaWYgKHBhcnNlci5FTlRJVElFU1tlbnRpdHlMQ10pIHtcbiAgICAgIHJldHVybiBwYXJzZXIuRU5USVRJRVNbZW50aXR5TENdXG4gICAgfVxuICAgIGVudGl0eSA9IGVudGl0eUxDXG4gICAgaWYgKGVudGl0eS5jaGFyQXQoMCkgPT09ICcjJykge1xuICAgICAgaWYgKGVudGl0eS5jaGFyQXQoMSkgPT09ICd4Jykge1xuICAgICAgICBlbnRpdHkgPSBlbnRpdHkuc2xpY2UoMilcbiAgICAgICAgbnVtID0gcGFyc2VJbnQoZW50aXR5LCAxNilcbiAgICAgICAgbnVtU3RyID0gbnVtLnRvU3RyaW5nKDE2KVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZW50aXR5ID0gZW50aXR5LnNsaWNlKDEpXG4gICAgICAgIG51bSA9IHBhcnNlSW50KGVudGl0eSwgMTApXG4gICAgICAgIG51bVN0ciA9IG51bS50b1N0cmluZygxMClcbiAgICAgIH1cbiAgICB9XG4gICAgZW50aXR5ID0gZW50aXR5LnJlcGxhY2UoL14wKy8sICcnKVxuICAgIGlmIChpc05hTihudW0pIHx8IG51bVN0ci50b0xvd2VyQ2FzZSgpICE9PSBlbnRpdHkpIHtcbiAgICAgIHN0cmljdEZhaWwocGFyc2VyLCAnSW52YWxpZCBjaGFyYWN0ZXIgZW50aXR5JylcbiAgICAgIHJldHVybiAnJicgKyBwYXJzZXIuZW50aXR5ICsgJzsnXG4gICAgfVxuXG4gICAgcmV0dXJuIFN0cmluZy5mcm9tQ29kZVBvaW50KG51bSlcbiAgfVxuXG4gIGZ1bmN0aW9uIGJlZ2luV2hpdGVTcGFjZSAocGFyc2VyLCBjKSB7XG4gICAgaWYgKGMgPT09ICc8Jykge1xuICAgICAgcGFyc2VyLnN0YXRlID0gUy5PUEVOX1dBS0FcbiAgICAgIHBhcnNlci5zdGFydFRhZ1Bvc2l0aW9uID0gcGFyc2VyLnBvc2l0aW9uXG4gICAgfSBlbHNlIGlmICghaXNXaGl0ZXNwYWNlKGMpKSB7XG4gICAgICAvLyBoYXZlIHRvIHByb2Nlc3MgdGhpcyBhcyBhIHRleHQgbm9kZS5cbiAgICAgIC8vIHdlaXJkLCBidXQgaGFwcGVucy5cbiAgICAgIHN0cmljdEZhaWwocGFyc2VyLCAnTm9uLXdoaXRlc3BhY2UgYmVmb3JlIGZpcnN0IHRhZy4nKVxuICAgICAgcGFyc2VyLnRleHROb2RlID0gY1xuICAgICAgcGFyc2VyLnN0YXRlID0gUy5URVhUXG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gY2hhckF0IChjaHVuaywgaSkge1xuICAgIHZhciByZXN1bHQgPSAnJ1xuICAgIGlmIChpIDwgY2h1bmsubGVuZ3RoKSB7XG4gICAgICByZXN1bHQgPSBjaHVuay5jaGFyQXQoaSlcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdFxuICB9XG5cbiAgZnVuY3Rpb24gd3JpdGUgKGNodW5rKSB7XG4gICAgdmFyIHBhcnNlciA9IHRoaXNcbiAgICBpZiAodGhpcy5lcnJvcikge1xuICAgICAgdGhyb3cgdGhpcy5lcnJvclxuICAgIH1cbiAgICBpZiAocGFyc2VyLmNsb3NlZCkge1xuICAgICAgcmV0dXJuIGVycm9yKHBhcnNlcixcbiAgICAgICAgJ0Nhbm5vdCB3cml0ZSBhZnRlciBjbG9zZS4gQXNzaWduIGFuIG9ucmVhZHkgaGFuZGxlci4nKVxuICAgIH1cbiAgICBpZiAoY2h1bmsgPT09IG51bGwpIHtcbiAgICAgIHJldHVybiBlbmQocGFyc2VyKVxuICAgIH1cbiAgICBpZiAodHlwZW9mIGNodW5rID09PSAnb2JqZWN0Jykge1xuICAgICAgY2h1bmsgPSBjaHVuay50b1N0cmluZygpXG4gICAgfVxuICAgIHZhciBpID0gMFxuICAgIHZhciBjID0gJydcbiAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgYyA9IGNoYXJBdChjaHVuaywgaSsrKVxuICAgICAgcGFyc2VyLmMgPSBjXG5cbiAgICAgIGlmICghYykge1xuICAgICAgICBicmVha1xuICAgICAgfVxuXG4gICAgICBpZiAocGFyc2VyLnRyYWNrUG9zaXRpb24pIHtcbiAgICAgICAgcGFyc2VyLnBvc2l0aW9uKytcbiAgICAgICAgaWYgKGMgPT09ICdcXG4nKSB7XG4gICAgICAgICAgcGFyc2VyLmxpbmUrK1xuICAgICAgICAgIHBhcnNlci5jb2x1bW4gPSAwXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcGFyc2VyLmNvbHVtbisrXG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgc3dpdGNoIChwYXJzZXIuc3RhdGUpIHtcbiAgICAgICAgY2FzZSBTLkJFR0lOOlxuICAgICAgICAgIHBhcnNlci5zdGF0ZSA9IFMuQkVHSU5fV0hJVEVTUEFDRVxuICAgICAgICAgIGlmIChjID09PSAnXFx1RkVGRicpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgICAgfVxuICAgICAgICAgIGJlZ2luV2hpdGVTcGFjZShwYXJzZXIsIGMpXG4gICAgICAgICAgY29udGludWVcblxuICAgICAgICBjYXNlIFMuQkVHSU5fV0hJVEVTUEFDRTpcbiAgICAgICAgICBiZWdpbldoaXRlU3BhY2UocGFyc2VyLCBjKVxuICAgICAgICAgIGNvbnRpbnVlXG5cbiAgICAgICAgY2FzZSBTLlRFWFQ6XG4gICAgICAgICAgaWYgKHBhcnNlci5zYXdSb290ICYmICFwYXJzZXIuY2xvc2VkUm9vdCkge1xuICAgICAgICAgICAgdmFyIHN0YXJ0aSA9IGkgLSAxXG4gICAgICAgICAgICB3aGlsZSAoYyAmJiBjICE9PSAnPCcgJiYgYyAhPT0gJyYnKSB7XG4gICAgICAgICAgICAgIGMgPSBjaGFyQXQoY2h1bmssIGkrKylcbiAgICAgICAgICAgICAgaWYgKGMgJiYgcGFyc2VyLnRyYWNrUG9zaXRpb24pIHtcbiAgICAgICAgICAgICAgICBwYXJzZXIucG9zaXRpb24rK1xuICAgICAgICAgICAgICAgIGlmIChjID09PSAnXFxuJykge1xuICAgICAgICAgICAgICAgICAgcGFyc2VyLmxpbmUrK1xuICAgICAgICAgICAgICAgICAgcGFyc2VyLmNvbHVtbiA9IDBcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgcGFyc2VyLmNvbHVtbisrXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwYXJzZXIudGV4dE5vZGUgKz0gY2h1bmsuc3Vic3RyaW5nKHN0YXJ0aSwgaSAtIDEpXG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChjID09PSAnPCcgJiYgIShwYXJzZXIuc2F3Um9vdCAmJiBwYXJzZXIuY2xvc2VkUm9vdCAmJiAhcGFyc2VyLnN0cmljdCkpIHtcbiAgICAgICAgICAgIHBhcnNlci5zdGF0ZSA9IFMuT1BFTl9XQUtBXG4gICAgICAgICAgICBwYXJzZXIuc3RhcnRUYWdQb3NpdGlvbiA9IHBhcnNlci5wb3NpdGlvblxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAoIWlzV2hpdGVzcGFjZShjKSAmJiAoIXBhcnNlci5zYXdSb290IHx8IHBhcnNlci5jbG9zZWRSb290KSkge1xuICAgICAgICAgICAgICBzdHJpY3RGYWlsKHBhcnNlciwgJ1RleHQgZGF0YSBvdXRzaWRlIG9mIHJvb3Qgbm9kZS4nKVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGMgPT09ICcmJykge1xuICAgICAgICAgICAgICBwYXJzZXIuc3RhdGUgPSBTLlRFWFRfRU5USVRZXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBwYXJzZXIudGV4dE5vZGUgKz0gY1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBjb250aW51ZVxuXG4gICAgICAgIGNhc2UgUy5TQ1JJUFQ6XG4gICAgICAgICAgLy8gb25seSBub24tc3RyaWN0XG4gICAgICAgICAgaWYgKGMgPT09ICc8Jykge1xuICAgICAgICAgICAgcGFyc2VyLnN0YXRlID0gUy5TQ1JJUFRfRU5ESU5HXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHBhcnNlci5zY3JpcHQgKz0gY1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb250aW51ZVxuXG4gICAgICAgIGNhc2UgUy5TQ1JJUFRfRU5ESU5HOlxuICAgICAgICAgIGlmIChjID09PSAnLycpIHtcbiAgICAgICAgICAgIHBhcnNlci5zdGF0ZSA9IFMuQ0xPU0VfVEFHXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHBhcnNlci5zY3JpcHQgKz0gJzwnICsgY1xuICAgICAgICAgICAgcGFyc2VyLnN0YXRlID0gUy5TQ1JJUFRcbiAgICAgICAgICB9XG4gICAgICAgICAgY29udGludWVcblxuICAgICAgICBjYXNlIFMuT1BFTl9XQUtBOlxuICAgICAgICAgIC8vIGVpdGhlciBhIC8sID8sICEsIG9yIHRleHQgaXMgY29taW5nIG5leHQuXG4gICAgICAgICAgaWYgKGMgPT09ICchJykge1xuICAgICAgICAgICAgcGFyc2VyLnN0YXRlID0gUy5TR01MX0RFQ0xcbiAgICAgICAgICAgIHBhcnNlci5zZ21sRGVjbCA9ICcnXG4gICAgICAgICAgfSBlbHNlIGlmIChpc1doaXRlc3BhY2UoYykpIHtcbiAgICAgICAgICAgIC8vIHdhaXQgZm9yIGl0Li4uXG4gICAgICAgICAgfSBlbHNlIGlmIChpc01hdGNoKG5hbWVTdGFydCwgYykpIHtcbiAgICAgICAgICAgIHBhcnNlci5zdGF0ZSA9IFMuT1BFTl9UQUdcbiAgICAgICAgICAgIHBhcnNlci50YWdOYW1lID0gY1xuICAgICAgICAgIH0gZWxzZSBpZiAoYyA9PT0gJy8nKSB7XG4gICAgICAgICAgICBwYXJzZXIuc3RhdGUgPSBTLkNMT1NFX1RBR1xuICAgICAgICAgICAgcGFyc2VyLnRhZ05hbWUgPSAnJ1xuICAgICAgICAgIH0gZWxzZSBpZiAoYyA9PT0gJz8nKSB7XG4gICAgICAgICAgICBwYXJzZXIuc3RhdGUgPSBTLlBST0NfSU5TVFxuICAgICAgICAgICAgcGFyc2VyLnByb2NJbnN0TmFtZSA9IHBhcnNlci5wcm9jSW5zdEJvZHkgPSAnJ1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzdHJpY3RGYWlsKHBhcnNlciwgJ1VuZW5jb2RlZCA8JylcbiAgICAgICAgICAgIC8vIGlmIHRoZXJlIHdhcyBzb21lIHdoaXRlc3BhY2UsIHRoZW4gYWRkIHRoYXQgaW4uXG4gICAgICAgICAgICBpZiAocGFyc2VyLnN0YXJ0VGFnUG9zaXRpb24gKyAxIDwgcGFyc2VyLnBvc2l0aW9uKSB7XG4gICAgICAgICAgICAgIHZhciBwYWQgPSBwYXJzZXIucG9zaXRpb24gLSBwYXJzZXIuc3RhcnRUYWdQb3NpdGlvblxuICAgICAgICAgICAgICBjID0gbmV3IEFycmF5KHBhZCkuam9pbignICcpICsgY1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcGFyc2VyLnRleHROb2RlICs9ICc8JyArIGNcbiAgICAgICAgICAgIHBhcnNlci5zdGF0ZSA9IFMuVEVYVFxuICAgICAgICAgIH1cbiAgICAgICAgICBjb250aW51ZVxuXG4gICAgICAgIGNhc2UgUy5TR01MX0RFQ0w6XG4gICAgICAgICAgaWYgKChwYXJzZXIuc2dtbERlY2wgKyBjKS50b1VwcGVyQ2FzZSgpID09PSBDREFUQSkge1xuICAgICAgICAgICAgZW1pdE5vZGUocGFyc2VyLCAnb25vcGVuY2RhdGEnKVxuICAgICAgICAgICAgcGFyc2VyLnN0YXRlID0gUy5DREFUQVxuICAgICAgICAgICAgcGFyc2VyLnNnbWxEZWNsID0gJydcbiAgICAgICAgICAgIHBhcnNlci5jZGF0YSA9ICcnXG4gICAgICAgICAgfSBlbHNlIGlmIChwYXJzZXIuc2dtbERlY2wgKyBjID09PSAnLS0nKSB7XG4gICAgICAgICAgICBwYXJzZXIuc3RhdGUgPSBTLkNPTU1FTlRcbiAgICAgICAgICAgIHBhcnNlci5jb21tZW50ID0gJydcbiAgICAgICAgICAgIHBhcnNlci5zZ21sRGVjbCA9ICcnXG4gICAgICAgICAgfSBlbHNlIGlmICgocGFyc2VyLnNnbWxEZWNsICsgYykudG9VcHBlckNhc2UoKSA9PT0gRE9DVFlQRSkge1xuICAgICAgICAgICAgcGFyc2VyLnN0YXRlID0gUy5ET0NUWVBFXG4gICAgICAgICAgICBpZiAocGFyc2VyLmRvY3R5cGUgfHwgcGFyc2VyLnNhd1Jvb3QpIHtcbiAgICAgICAgICAgICAgc3RyaWN0RmFpbChwYXJzZXIsXG4gICAgICAgICAgICAgICAgJ0luYXBwcm9wcmlhdGVseSBsb2NhdGVkIGRvY3R5cGUgZGVjbGFyYXRpb24nKVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcGFyc2VyLmRvY3R5cGUgPSAnJ1xuICAgICAgICAgICAgcGFyc2VyLnNnbWxEZWNsID0gJydcbiAgICAgICAgICB9IGVsc2UgaWYgKGMgPT09ICc+Jykge1xuICAgICAgICAgICAgZW1pdE5vZGUocGFyc2VyLCAnb25zZ21sZGVjbGFyYXRpb24nLCBwYXJzZXIuc2dtbERlY2wpXG4gICAgICAgICAgICBwYXJzZXIuc2dtbERlY2wgPSAnJ1xuICAgICAgICAgICAgcGFyc2VyLnN0YXRlID0gUy5URVhUXG4gICAgICAgICAgfSBlbHNlIGlmIChpc1F1b3RlKGMpKSB7XG4gICAgICAgICAgICBwYXJzZXIuc3RhdGUgPSBTLlNHTUxfREVDTF9RVU9URURcbiAgICAgICAgICAgIHBhcnNlci5zZ21sRGVjbCArPSBjXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHBhcnNlci5zZ21sRGVjbCArPSBjXG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnRpbnVlXG5cbiAgICAgICAgY2FzZSBTLlNHTUxfREVDTF9RVU9URUQ6XG4gICAgICAgICAgaWYgKGMgPT09IHBhcnNlci5xKSB7XG4gICAgICAgICAgICBwYXJzZXIuc3RhdGUgPSBTLlNHTUxfREVDTFxuICAgICAgICAgICAgcGFyc2VyLnEgPSAnJ1xuICAgICAgICAgIH1cbiAgICAgICAgICBwYXJzZXIuc2dtbERlY2wgKz0gY1xuICAgICAgICAgIGNvbnRpbnVlXG5cbiAgICAgICAgY2FzZSBTLkRPQ1RZUEU6XG4gICAgICAgICAgaWYgKGMgPT09ICc+Jykge1xuICAgICAgICAgICAgcGFyc2VyLnN0YXRlID0gUy5URVhUXG4gICAgICAgICAgICBlbWl0Tm9kZShwYXJzZXIsICdvbmRvY3R5cGUnLCBwYXJzZXIuZG9jdHlwZSlcbiAgICAgICAgICAgIHBhcnNlci5kb2N0eXBlID0gdHJ1ZSAvLyBqdXN0IHJlbWVtYmVyIHRoYXQgd2Ugc2F3IGl0LlxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBwYXJzZXIuZG9jdHlwZSArPSBjXG4gICAgICAgICAgICBpZiAoYyA9PT0gJ1snKSB7XG4gICAgICAgICAgICAgIHBhcnNlci5zdGF0ZSA9IFMuRE9DVFlQRV9EVERcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoaXNRdW90ZShjKSkge1xuICAgICAgICAgICAgICBwYXJzZXIuc3RhdGUgPSBTLkRPQ1RZUEVfUVVPVEVEXG4gICAgICAgICAgICAgIHBhcnNlci5xID0gY1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBjb250aW51ZVxuXG4gICAgICAgIGNhc2UgUy5ET0NUWVBFX1FVT1RFRDpcbiAgICAgICAgICBwYXJzZXIuZG9jdHlwZSArPSBjXG4gICAgICAgICAgaWYgKGMgPT09IHBhcnNlci5xKSB7XG4gICAgICAgICAgICBwYXJzZXIucSA9ICcnXG4gICAgICAgICAgICBwYXJzZXIuc3RhdGUgPSBTLkRPQ1RZUEVcbiAgICAgICAgICB9XG4gICAgICAgICAgY29udGludWVcblxuICAgICAgICBjYXNlIFMuRE9DVFlQRV9EVEQ6XG4gICAgICAgICAgcGFyc2VyLmRvY3R5cGUgKz0gY1xuICAgICAgICAgIGlmIChjID09PSAnXScpIHtcbiAgICAgICAgICAgIHBhcnNlci5zdGF0ZSA9IFMuRE9DVFlQRVxuICAgICAgICAgIH0gZWxzZSBpZiAoaXNRdW90ZShjKSkge1xuICAgICAgICAgICAgcGFyc2VyLnN0YXRlID0gUy5ET0NUWVBFX0RURF9RVU9URURcbiAgICAgICAgICAgIHBhcnNlci5xID0gY1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb250aW51ZVxuXG4gICAgICAgIGNhc2UgUy5ET0NUWVBFX0RURF9RVU9URUQ6XG4gICAgICAgICAgcGFyc2VyLmRvY3R5cGUgKz0gY1xuICAgICAgICAgIGlmIChjID09PSBwYXJzZXIucSkge1xuICAgICAgICAgICAgcGFyc2VyLnN0YXRlID0gUy5ET0NUWVBFX0RURFxuICAgICAgICAgICAgcGFyc2VyLnEgPSAnJ1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb250aW51ZVxuXG4gICAgICAgIGNhc2UgUy5DT01NRU5UOlxuICAgICAgICAgIGlmIChjID09PSAnLScpIHtcbiAgICAgICAgICAgIHBhcnNlci5zdGF0ZSA9IFMuQ09NTUVOVF9FTkRJTkdcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcGFyc2VyLmNvbW1lbnQgKz0gY1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb250aW51ZVxuXG4gICAgICAgIGNhc2UgUy5DT01NRU5UX0VORElORzpcbiAgICAgICAgICBpZiAoYyA9PT0gJy0nKSB7XG4gICAgICAgICAgICBwYXJzZXIuc3RhdGUgPSBTLkNPTU1FTlRfRU5ERURcbiAgICAgICAgICAgIHBhcnNlci5jb21tZW50ID0gdGV4dG9wdHMocGFyc2VyLm9wdCwgcGFyc2VyLmNvbW1lbnQpXG4gICAgICAgICAgICBpZiAocGFyc2VyLmNvbW1lbnQpIHtcbiAgICAgICAgICAgICAgZW1pdE5vZGUocGFyc2VyLCAnb25jb21tZW50JywgcGFyc2VyLmNvbW1lbnQpXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwYXJzZXIuY29tbWVudCA9ICcnXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHBhcnNlci5jb21tZW50ICs9ICctJyArIGNcbiAgICAgICAgICAgIHBhcnNlci5zdGF0ZSA9IFMuQ09NTUVOVFxuICAgICAgICAgIH1cbiAgICAgICAgICBjb250aW51ZVxuXG4gICAgICAgIGNhc2UgUy5DT01NRU5UX0VOREVEOlxuICAgICAgICAgIGlmIChjICE9PSAnPicpIHtcbiAgICAgICAgICAgIHN0cmljdEZhaWwocGFyc2VyLCAnTWFsZm9ybWVkIGNvbW1lbnQnKVxuICAgICAgICAgICAgLy8gYWxsb3cgPCEtLSBibGFoIC0tIGJsb28gLS0+IGluIG5vbi1zdHJpY3QgbW9kZSxcbiAgICAgICAgICAgIC8vIHdoaWNoIGlzIGEgY29tbWVudCBvZiBcIiBibGFoIC0tIGJsb28gXCJcbiAgICAgICAgICAgIHBhcnNlci5jb21tZW50ICs9ICctLScgKyBjXG4gICAgICAgICAgICBwYXJzZXIuc3RhdGUgPSBTLkNPTU1FTlRcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcGFyc2VyLnN0YXRlID0gUy5URVhUXG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnRpbnVlXG5cbiAgICAgICAgY2FzZSBTLkNEQVRBOlxuICAgICAgICAgIGlmIChjID09PSAnXScpIHtcbiAgICAgICAgICAgIHBhcnNlci5zdGF0ZSA9IFMuQ0RBVEFfRU5ESU5HXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHBhcnNlci5jZGF0YSArPSBjXG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnRpbnVlXG5cbiAgICAgICAgY2FzZSBTLkNEQVRBX0VORElORzpcbiAgICAgICAgICBpZiAoYyA9PT0gJ10nKSB7XG4gICAgICAgICAgICBwYXJzZXIuc3RhdGUgPSBTLkNEQVRBX0VORElOR18yXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHBhcnNlci5jZGF0YSArPSAnXScgKyBjXG4gICAgICAgICAgICBwYXJzZXIuc3RhdGUgPSBTLkNEQVRBXG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnRpbnVlXG5cbiAgICAgICAgY2FzZSBTLkNEQVRBX0VORElOR18yOlxuICAgICAgICAgIGlmIChjID09PSAnPicpIHtcbiAgICAgICAgICAgIGlmIChwYXJzZXIuY2RhdGEpIHtcbiAgICAgICAgICAgICAgZW1pdE5vZGUocGFyc2VyLCAnb25jZGF0YScsIHBhcnNlci5jZGF0YSlcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVtaXROb2RlKHBhcnNlciwgJ29uY2xvc2VjZGF0YScpXG4gICAgICAgICAgICBwYXJzZXIuY2RhdGEgPSAnJ1xuICAgICAgICAgICAgcGFyc2VyLnN0YXRlID0gUy5URVhUXG4gICAgICAgICAgfSBlbHNlIGlmIChjID09PSAnXScpIHtcbiAgICAgICAgICAgIHBhcnNlci5jZGF0YSArPSAnXSdcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcGFyc2VyLmNkYXRhICs9ICddXScgKyBjXG4gICAgICAgICAgICBwYXJzZXIuc3RhdGUgPSBTLkNEQVRBXG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnRpbnVlXG5cbiAgICAgICAgY2FzZSBTLlBST0NfSU5TVDpcbiAgICAgICAgICBpZiAoYyA9PT0gJz8nKSB7XG4gICAgICAgICAgICBwYXJzZXIuc3RhdGUgPSBTLlBST0NfSU5TVF9FTkRJTkdcbiAgICAgICAgICB9IGVsc2UgaWYgKGlzV2hpdGVzcGFjZShjKSkge1xuICAgICAgICAgICAgcGFyc2VyLnN0YXRlID0gUy5QUk9DX0lOU1RfQk9EWVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBwYXJzZXIucHJvY0luc3ROYW1lICs9IGNcbiAgICAgICAgICB9XG4gICAgICAgICAgY29udGludWVcblxuICAgICAgICBjYXNlIFMuUFJPQ19JTlNUX0JPRFk6XG4gICAgICAgICAgaWYgKCFwYXJzZXIucHJvY0luc3RCb2R5ICYmIGlzV2hpdGVzcGFjZShjKSkge1xuICAgICAgICAgICAgY29udGludWVcbiAgICAgICAgICB9IGVsc2UgaWYgKGMgPT09ICc/Jykge1xuICAgICAgICAgICAgcGFyc2VyLnN0YXRlID0gUy5QUk9DX0lOU1RfRU5ESU5HXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHBhcnNlci5wcm9jSW5zdEJvZHkgKz0gY1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb250aW51ZVxuXG4gICAgICAgIGNhc2UgUy5QUk9DX0lOU1RfRU5ESU5HOlxuICAgICAgICAgIGlmIChjID09PSAnPicpIHtcbiAgICAgICAgICAgIGVtaXROb2RlKHBhcnNlciwgJ29ucHJvY2Vzc2luZ2luc3RydWN0aW9uJywge1xuICAgICAgICAgICAgICBuYW1lOiBwYXJzZXIucHJvY0luc3ROYW1lLFxuICAgICAgICAgICAgICBib2R5OiBwYXJzZXIucHJvY0luc3RCb2R5XG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgcGFyc2VyLnByb2NJbnN0TmFtZSA9IHBhcnNlci5wcm9jSW5zdEJvZHkgPSAnJ1xuICAgICAgICAgICAgcGFyc2VyLnN0YXRlID0gUy5URVhUXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHBhcnNlci5wcm9jSW5zdEJvZHkgKz0gJz8nICsgY1xuICAgICAgICAgICAgcGFyc2VyLnN0YXRlID0gUy5QUk9DX0lOU1RfQk9EWVxuICAgICAgICAgIH1cbiAgICAgICAgICBjb250aW51ZVxuXG4gICAgICAgIGNhc2UgUy5PUEVOX1RBRzpcbiAgICAgICAgICBpZiAoaXNNYXRjaChuYW1lQm9keSwgYykpIHtcbiAgICAgICAgICAgIHBhcnNlci50YWdOYW1lICs9IGNcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbmV3VGFnKHBhcnNlcilcbiAgICAgICAgICAgIGlmIChjID09PSAnPicpIHtcbiAgICAgICAgICAgICAgb3BlblRhZyhwYXJzZXIpXG4gICAgICAgICAgICB9IGVsc2UgaWYgKGMgPT09ICcvJykge1xuICAgICAgICAgICAgICBwYXJzZXIuc3RhdGUgPSBTLk9QRU5fVEFHX1NMQVNIXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBpZiAoIWlzV2hpdGVzcGFjZShjKSkge1xuICAgICAgICAgICAgICAgIHN0cmljdEZhaWwocGFyc2VyLCAnSW52YWxpZCBjaGFyYWN0ZXIgaW4gdGFnIG5hbWUnKVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHBhcnNlci5zdGF0ZSA9IFMuQVRUUklCXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnRpbnVlXG5cbiAgICAgICAgY2FzZSBTLk9QRU5fVEFHX1NMQVNIOlxuICAgICAgICAgIGlmIChjID09PSAnPicpIHtcbiAgICAgICAgICAgIG9wZW5UYWcocGFyc2VyLCB0cnVlKVxuICAgICAgICAgICAgY2xvc2VUYWcocGFyc2VyKVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzdHJpY3RGYWlsKHBhcnNlciwgJ0ZvcndhcmQtc2xhc2ggaW4gb3BlbmluZyB0YWcgbm90IGZvbGxvd2VkIGJ5ID4nKVxuICAgICAgICAgICAgcGFyc2VyLnN0YXRlID0gUy5BVFRSSUJcbiAgICAgICAgICB9XG4gICAgICAgICAgY29udGludWVcblxuICAgICAgICBjYXNlIFMuQVRUUklCOlxuICAgICAgICAgIC8vIGhhdmVuJ3QgcmVhZCB0aGUgYXR0cmlidXRlIG5hbWUgeWV0LlxuICAgICAgICAgIGlmIChpc1doaXRlc3BhY2UoYykpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgICAgfSBlbHNlIGlmIChjID09PSAnPicpIHtcbiAgICAgICAgICAgIG9wZW5UYWcocGFyc2VyKVxuICAgICAgICAgIH0gZWxzZSBpZiAoYyA9PT0gJy8nKSB7XG4gICAgICAgICAgICBwYXJzZXIuc3RhdGUgPSBTLk9QRU5fVEFHX1NMQVNIXG4gICAgICAgICAgfSBlbHNlIGlmIChpc01hdGNoKG5hbWVTdGFydCwgYykpIHtcbiAgICAgICAgICAgIHBhcnNlci5hdHRyaWJOYW1lID0gY1xuICAgICAgICAgICAgcGFyc2VyLmF0dHJpYlZhbHVlID0gJydcbiAgICAgICAgICAgIHBhcnNlci5zdGF0ZSA9IFMuQVRUUklCX05BTUVcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc3RyaWN0RmFpbChwYXJzZXIsICdJbnZhbGlkIGF0dHJpYnV0ZSBuYW1lJylcbiAgICAgICAgICB9XG4gICAgICAgICAgY29udGludWVcblxuICAgICAgICBjYXNlIFMuQVRUUklCX05BTUU6XG4gICAgICAgICAgaWYgKGMgPT09ICc9Jykge1xuICAgICAgICAgICAgcGFyc2VyLnN0YXRlID0gUy5BVFRSSUJfVkFMVUVcbiAgICAgICAgICB9IGVsc2UgaWYgKGMgPT09ICc+Jykge1xuICAgICAgICAgICAgc3RyaWN0RmFpbChwYXJzZXIsICdBdHRyaWJ1dGUgd2l0aG91dCB2YWx1ZScpXG4gICAgICAgICAgICBwYXJzZXIuYXR0cmliVmFsdWUgPSBwYXJzZXIuYXR0cmliTmFtZVxuICAgICAgICAgICAgYXR0cmliKHBhcnNlcilcbiAgICAgICAgICAgIG9wZW5UYWcocGFyc2VyKVxuICAgICAgICAgIH0gZWxzZSBpZiAoaXNXaGl0ZXNwYWNlKGMpKSB7XG4gICAgICAgICAgICBwYXJzZXIuc3RhdGUgPSBTLkFUVFJJQl9OQU1FX1NBV19XSElURVxuICAgICAgICAgIH0gZWxzZSBpZiAoaXNNYXRjaChuYW1lQm9keSwgYykpIHtcbiAgICAgICAgICAgIHBhcnNlci5hdHRyaWJOYW1lICs9IGNcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc3RyaWN0RmFpbChwYXJzZXIsICdJbnZhbGlkIGF0dHJpYnV0ZSBuYW1lJylcbiAgICAgICAgICB9XG4gICAgICAgICAgY29udGludWVcblxuICAgICAgICBjYXNlIFMuQVRUUklCX05BTUVfU0FXX1dISVRFOlxuICAgICAgICAgIGlmIChjID09PSAnPScpIHtcbiAgICAgICAgICAgIHBhcnNlci5zdGF0ZSA9IFMuQVRUUklCX1ZBTFVFXG4gICAgICAgICAgfSBlbHNlIGlmIChpc1doaXRlc3BhY2UoYykpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHN0cmljdEZhaWwocGFyc2VyLCAnQXR0cmlidXRlIHdpdGhvdXQgdmFsdWUnKVxuICAgICAgICAgICAgcGFyc2VyLnRhZy5hdHRyaWJ1dGVzW3BhcnNlci5hdHRyaWJOYW1lXSA9ICcnXG4gICAgICAgICAgICBwYXJzZXIuYXR0cmliVmFsdWUgPSAnJ1xuICAgICAgICAgICAgZW1pdE5vZGUocGFyc2VyLCAnb25hdHRyaWJ1dGUnLCB7XG4gICAgICAgICAgICAgIG5hbWU6IHBhcnNlci5hdHRyaWJOYW1lLFxuICAgICAgICAgICAgICB2YWx1ZTogJydcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICBwYXJzZXIuYXR0cmliTmFtZSA9ICcnXG4gICAgICAgICAgICBpZiAoYyA9PT0gJz4nKSB7XG4gICAgICAgICAgICAgIG9wZW5UYWcocGFyc2VyKVxuICAgICAgICAgICAgfSBlbHNlIGlmIChpc01hdGNoKG5hbWVTdGFydCwgYykpIHtcbiAgICAgICAgICAgICAgcGFyc2VyLmF0dHJpYk5hbWUgPSBjXG4gICAgICAgICAgICAgIHBhcnNlci5zdGF0ZSA9IFMuQVRUUklCX05BTUVcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHN0cmljdEZhaWwocGFyc2VyLCAnSW52YWxpZCBhdHRyaWJ1dGUgbmFtZScpXG4gICAgICAgICAgICAgIHBhcnNlci5zdGF0ZSA9IFMuQVRUUklCXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnRpbnVlXG5cbiAgICAgICAgY2FzZSBTLkFUVFJJQl9WQUxVRTpcbiAgICAgICAgICBpZiAoaXNXaGl0ZXNwYWNlKGMpKSB7XG4gICAgICAgICAgICBjb250aW51ZVxuICAgICAgICAgIH0gZWxzZSBpZiAoaXNRdW90ZShjKSkge1xuICAgICAgICAgICAgcGFyc2VyLnEgPSBjXG4gICAgICAgICAgICBwYXJzZXIuc3RhdGUgPSBTLkFUVFJJQl9WQUxVRV9RVU9URURcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc3RyaWN0RmFpbChwYXJzZXIsICdVbnF1b3RlZCBhdHRyaWJ1dGUgdmFsdWUnKVxuICAgICAgICAgICAgcGFyc2VyLnN0YXRlID0gUy5BVFRSSUJfVkFMVUVfVU5RVU9URURcbiAgICAgICAgICAgIHBhcnNlci5hdHRyaWJWYWx1ZSA9IGNcbiAgICAgICAgICB9XG4gICAgICAgICAgY29udGludWVcblxuICAgICAgICBjYXNlIFMuQVRUUklCX1ZBTFVFX1FVT1RFRDpcbiAgICAgICAgICBpZiAoYyAhPT0gcGFyc2VyLnEpIHtcbiAgICAgICAgICAgIGlmIChjID09PSAnJicpIHtcbiAgICAgICAgICAgICAgcGFyc2VyLnN0YXRlID0gUy5BVFRSSUJfVkFMVUVfRU5USVRZX1FcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHBhcnNlci5hdHRyaWJWYWx1ZSArPSBjXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb250aW51ZVxuICAgICAgICAgIH1cbiAgICAgICAgICBhdHRyaWIocGFyc2VyKVxuICAgICAgICAgIHBhcnNlci5xID0gJydcbiAgICAgICAgICBwYXJzZXIuc3RhdGUgPSBTLkFUVFJJQl9WQUxVRV9DTE9TRURcbiAgICAgICAgICBjb250aW51ZVxuXG4gICAgICAgIGNhc2UgUy5BVFRSSUJfVkFMVUVfQ0xPU0VEOlxuICAgICAgICAgIGlmIChpc1doaXRlc3BhY2UoYykpIHtcbiAgICAgICAgICAgIHBhcnNlci5zdGF0ZSA9IFMuQVRUUklCXG4gICAgICAgICAgfSBlbHNlIGlmIChjID09PSAnPicpIHtcbiAgICAgICAgICAgIG9wZW5UYWcocGFyc2VyKVxuICAgICAgICAgIH0gZWxzZSBpZiAoYyA9PT0gJy8nKSB7XG4gICAgICAgICAgICBwYXJzZXIuc3RhdGUgPSBTLk9QRU5fVEFHX1NMQVNIXG4gICAgICAgICAgfSBlbHNlIGlmIChpc01hdGNoKG5hbWVTdGFydCwgYykpIHtcbiAgICAgICAgICAgIHN0cmljdEZhaWwocGFyc2VyLCAnTm8gd2hpdGVzcGFjZSBiZXR3ZWVuIGF0dHJpYnV0ZXMnKVxuICAgICAgICAgICAgcGFyc2VyLmF0dHJpYk5hbWUgPSBjXG4gICAgICAgICAgICBwYXJzZXIuYXR0cmliVmFsdWUgPSAnJ1xuICAgICAgICAgICAgcGFyc2VyLnN0YXRlID0gUy5BVFRSSUJfTkFNRVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzdHJpY3RGYWlsKHBhcnNlciwgJ0ludmFsaWQgYXR0cmlidXRlIG5hbWUnKVxuICAgICAgICAgIH1cbiAgICAgICAgICBjb250aW51ZVxuXG4gICAgICAgIGNhc2UgUy5BVFRSSUJfVkFMVUVfVU5RVU9URUQ6XG4gICAgICAgICAgaWYgKCFpc0F0dHJpYkVuZChjKSkge1xuICAgICAgICAgICAgaWYgKGMgPT09ICcmJykge1xuICAgICAgICAgICAgICBwYXJzZXIuc3RhdGUgPSBTLkFUVFJJQl9WQUxVRV9FTlRJVFlfVVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgcGFyc2VyLmF0dHJpYlZhbHVlICs9IGNcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgICAgfVxuICAgICAgICAgIGF0dHJpYihwYXJzZXIpXG4gICAgICAgICAgaWYgKGMgPT09ICc+Jykge1xuICAgICAgICAgICAgb3BlblRhZyhwYXJzZXIpXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHBhcnNlci5zdGF0ZSA9IFMuQVRUUklCXG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnRpbnVlXG5cbiAgICAgICAgY2FzZSBTLkNMT1NFX1RBRzpcbiAgICAgICAgICBpZiAoIXBhcnNlci50YWdOYW1lKSB7XG4gICAgICAgICAgICBpZiAoaXNXaGl0ZXNwYWNlKGMpKSB7XG4gICAgICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgICAgICB9IGVsc2UgaWYgKG5vdE1hdGNoKG5hbWVTdGFydCwgYykpIHtcbiAgICAgICAgICAgICAgaWYgKHBhcnNlci5zY3JpcHQpIHtcbiAgICAgICAgICAgICAgICBwYXJzZXIuc2NyaXB0ICs9ICc8LycgKyBjXG4gICAgICAgICAgICAgICAgcGFyc2VyLnN0YXRlID0gUy5TQ1JJUFRcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBzdHJpY3RGYWlsKHBhcnNlciwgJ0ludmFsaWQgdGFnbmFtZSBpbiBjbG9zaW5nIHRhZy4nKVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBwYXJzZXIudGFnTmFtZSA9IGNcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2UgaWYgKGMgPT09ICc+Jykge1xuICAgICAgICAgICAgY2xvc2VUYWcocGFyc2VyKVxuICAgICAgICAgIH0gZWxzZSBpZiAoaXNNYXRjaChuYW1lQm9keSwgYykpIHtcbiAgICAgICAgICAgIHBhcnNlci50YWdOYW1lICs9IGNcbiAgICAgICAgICB9IGVsc2UgaWYgKHBhcnNlci5zY3JpcHQpIHtcbiAgICAgICAgICAgIHBhcnNlci5zY3JpcHQgKz0gJzwvJyArIHBhcnNlci50YWdOYW1lXG4gICAgICAgICAgICBwYXJzZXIudGFnTmFtZSA9ICcnXG4gICAgICAgICAgICBwYXJzZXIuc3RhdGUgPSBTLlNDUklQVFxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAoIWlzV2hpdGVzcGFjZShjKSkge1xuICAgICAgICAgICAgICBzdHJpY3RGYWlsKHBhcnNlciwgJ0ludmFsaWQgdGFnbmFtZSBpbiBjbG9zaW5nIHRhZycpXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwYXJzZXIuc3RhdGUgPSBTLkNMT1NFX1RBR19TQVdfV0hJVEVcbiAgICAgICAgICB9XG4gICAgICAgICAgY29udGludWVcblxuICAgICAgICBjYXNlIFMuQ0xPU0VfVEFHX1NBV19XSElURTpcbiAgICAgICAgICBpZiAoaXNXaGl0ZXNwYWNlKGMpKSB7XG4gICAgICAgICAgICBjb250aW51ZVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoYyA9PT0gJz4nKSB7XG4gICAgICAgICAgICBjbG9zZVRhZyhwYXJzZXIpXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHN0cmljdEZhaWwocGFyc2VyLCAnSW52YWxpZCBjaGFyYWN0ZXJzIGluIGNsb3NpbmcgdGFnJylcbiAgICAgICAgICB9XG4gICAgICAgICAgY29udGludWVcblxuICAgICAgICBjYXNlIFMuVEVYVF9FTlRJVFk6XG4gICAgICAgIGNhc2UgUy5BVFRSSUJfVkFMVUVfRU5USVRZX1E6XG4gICAgICAgIGNhc2UgUy5BVFRSSUJfVkFMVUVfRU5USVRZX1U6XG4gICAgICAgICAgdmFyIHJldHVyblN0YXRlXG4gICAgICAgICAgdmFyIGJ1ZmZlclxuICAgICAgICAgIHN3aXRjaCAocGFyc2VyLnN0YXRlKSB7XG4gICAgICAgICAgICBjYXNlIFMuVEVYVF9FTlRJVFk6XG4gICAgICAgICAgICAgIHJldHVyblN0YXRlID0gUy5URVhUXG4gICAgICAgICAgICAgIGJ1ZmZlciA9ICd0ZXh0Tm9kZSdcbiAgICAgICAgICAgICAgYnJlYWtcblxuICAgICAgICAgICAgY2FzZSBTLkFUVFJJQl9WQUxVRV9FTlRJVFlfUTpcbiAgICAgICAgICAgICAgcmV0dXJuU3RhdGUgPSBTLkFUVFJJQl9WQUxVRV9RVU9URURcbiAgICAgICAgICAgICAgYnVmZmVyID0gJ2F0dHJpYlZhbHVlJ1xuICAgICAgICAgICAgICBicmVha1xuXG4gICAgICAgICAgICBjYXNlIFMuQVRUUklCX1ZBTFVFX0VOVElUWV9VOlxuICAgICAgICAgICAgICByZXR1cm5TdGF0ZSA9IFMuQVRUUklCX1ZBTFVFX1VOUVVPVEVEXG4gICAgICAgICAgICAgIGJ1ZmZlciA9ICdhdHRyaWJWYWx1ZSdcbiAgICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoYyA9PT0gJzsnKSB7XG4gICAgICAgICAgICBwYXJzZXJbYnVmZmVyXSArPSBwYXJzZUVudGl0eShwYXJzZXIpXG4gICAgICAgICAgICBwYXJzZXIuZW50aXR5ID0gJydcbiAgICAgICAgICAgIHBhcnNlci5zdGF0ZSA9IHJldHVyblN0YXRlXG4gICAgICAgICAgfSBlbHNlIGlmIChpc01hdGNoKHBhcnNlci5lbnRpdHkubGVuZ3RoID8gZW50aXR5Qm9keSA6IGVudGl0eVN0YXJ0LCBjKSkge1xuICAgICAgICAgICAgcGFyc2VyLmVudGl0eSArPSBjXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHN0cmljdEZhaWwocGFyc2VyLCAnSW52YWxpZCBjaGFyYWN0ZXIgaW4gZW50aXR5IG5hbWUnKVxuICAgICAgICAgICAgcGFyc2VyW2J1ZmZlcl0gKz0gJyYnICsgcGFyc2VyLmVudGl0eSArIGNcbiAgICAgICAgICAgIHBhcnNlci5lbnRpdHkgPSAnJ1xuICAgICAgICAgICAgcGFyc2VyLnN0YXRlID0gcmV0dXJuU3RhdGVcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjb250aW51ZVxuXG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKHBhcnNlciwgJ1Vua25vd24gc3RhdGU6ICcgKyBwYXJzZXIuc3RhdGUpXG4gICAgICB9XG4gICAgfSAvLyB3aGlsZVxuXG4gICAgaWYgKHBhcnNlci5wb3NpdGlvbiA+PSBwYXJzZXIuYnVmZmVyQ2hlY2tQb3NpdGlvbikge1xuICAgICAgY2hlY2tCdWZmZXJMZW5ndGgocGFyc2VyKVxuICAgIH1cbiAgICByZXR1cm4gcGFyc2VyXG4gIH1cblxuICAvKiEgaHR0cDovL210aHMuYmUvZnJvbWNvZGVwb2ludCB2MC4xLjAgYnkgQG1hdGhpYXMgKi9cbiAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgaWYgKCFTdHJpbmcuZnJvbUNvZGVQb2ludCkge1xuICAgIChmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgc3RyaW5nRnJvbUNoYXJDb2RlID0gU3RyaW5nLmZyb21DaGFyQ29kZVxuICAgICAgdmFyIGZsb29yID0gTWF0aC5mbG9vclxuICAgICAgdmFyIGZyb21Db2RlUG9pbnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBNQVhfU0laRSA9IDB4NDAwMFxuICAgICAgICB2YXIgY29kZVVuaXRzID0gW11cbiAgICAgICAgdmFyIGhpZ2hTdXJyb2dhdGVcbiAgICAgICAgdmFyIGxvd1N1cnJvZ2F0ZVxuICAgICAgICB2YXIgaW5kZXggPSAtMVxuICAgICAgICB2YXIgbGVuZ3RoID0gYXJndW1lbnRzLmxlbmd0aFxuICAgICAgICBpZiAoIWxlbmd0aCkge1xuICAgICAgICAgIHJldHVybiAnJ1xuICAgICAgICB9XG4gICAgICAgIHZhciByZXN1bHQgPSAnJ1xuICAgICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICAgIHZhciBjb2RlUG9pbnQgPSBOdW1iZXIoYXJndW1lbnRzW2luZGV4XSlcbiAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAhaXNGaW5pdGUoY29kZVBvaW50KSB8fCAvLyBgTmFOYCwgYCtJbmZpbml0eWAsIG9yIGAtSW5maW5pdHlgXG4gICAgICAgICAgICBjb2RlUG9pbnQgPCAwIHx8IC8vIG5vdCBhIHZhbGlkIFVuaWNvZGUgY29kZSBwb2ludFxuICAgICAgICAgICAgY29kZVBvaW50ID4gMHgxMEZGRkYgfHwgLy8gbm90IGEgdmFsaWQgVW5pY29kZSBjb2RlIHBvaW50XG4gICAgICAgICAgICBmbG9vcihjb2RlUG9pbnQpICE9PSBjb2RlUG9pbnQgLy8gbm90IGFuIGludGVnZXJcbiAgICAgICAgICApIHtcbiAgICAgICAgICAgIHRocm93IFJhbmdlRXJyb3IoJ0ludmFsaWQgY29kZSBwb2ludDogJyArIGNvZGVQb2ludClcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGNvZGVQb2ludCA8PSAweEZGRkYpIHsgLy8gQk1QIGNvZGUgcG9pbnRcbiAgICAgICAgICAgIGNvZGVVbml0cy5wdXNoKGNvZGVQb2ludClcbiAgICAgICAgICB9IGVsc2UgeyAvLyBBc3RyYWwgY29kZSBwb2ludDsgc3BsaXQgaW4gc3Vycm9nYXRlIGhhbHZlc1xuICAgICAgICAgICAgLy8gaHR0cDovL21hdGhpYXNieW5lbnMuYmUvbm90ZXMvamF2YXNjcmlwdC1lbmNvZGluZyNzdXJyb2dhdGUtZm9ybXVsYWVcbiAgICAgICAgICAgIGNvZGVQb2ludCAtPSAweDEwMDAwXG4gICAgICAgICAgICBoaWdoU3Vycm9nYXRlID0gKGNvZGVQb2ludCA+PiAxMCkgKyAweEQ4MDBcbiAgICAgICAgICAgIGxvd1N1cnJvZ2F0ZSA9IChjb2RlUG9pbnQgJSAweDQwMCkgKyAweERDMDBcbiAgICAgICAgICAgIGNvZGVVbml0cy5wdXNoKGhpZ2hTdXJyb2dhdGUsIGxvd1N1cnJvZ2F0ZSlcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGluZGV4ICsgMSA9PT0gbGVuZ3RoIHx8IGNvZGVVbml0cy5sZW5ndGggPiBNQVhfU0laRSkge1xuICAgICAgICAgICAgcmVzdWx0ICs9IHN0cmluZ0Zyb21DaGFyQ29kZS5hcHBseShudWxsLCBjb2RlVW5pdHMpXG4gICAgICAgICAgICBjb2RlVW5pdHMubGVuZ3RoID0gMFxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0XG4gICAgICB9XG4gICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgICAgaWYgKE9iamVjdC5kZWZpbmVQcm9wZXJ0eSkge1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoU3RyaW5nLCAnZnJvbUNvZGVQb2ludCcsIHtcbiAgICAgICAgICB2YWx1ZTogZnJvbUNvZGVQb2ludCxcbiAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgd3JpdGFibGU6IHRydWVcbiAgICAgICAgfSlcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIFN0cmluZy5mcm9tQ29kZVBvaW50ID0gZnJvbUNvZGVQb2ludFxuICAgICAgfVxuICAgIH0oKSlcbiAgfVxufSkodHlwZW9mIGV4cG9ydHMgPT09ICd1bmRlZmluZWQnID8gdGhpcy5zYXggPSB7fSA6IGV4cG9ydHMpXG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvc2F4L2xpYi9zYXguanMiLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCJzdHJpbmdfZGVjb2RlclwiKTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyBleHRlcm5hbCBcInN0cmluZ19kZWNvZGVyXCJcbi8vIG1vZHVsZSBpZCA9IDEzNlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIndXNlIHN0cmljdCc7XG5cblxudmFyIGxvYWRlciA9IHJlcXVpcmUoJy4vanMteWFtbC9sb2FkZXInKTtcbnZhciBkdW1wZXIgPSByZXF1aXJlKCcuL2pzLXlhbWwvZHVtcGVyJyk7XG5cblxuZnVuY3Rpb24gZGVwcmVjYXRlZChuYW1lKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdGdW5jdGlvbiAnICsgbmFtZSArICcgaXMgZGVwcmVjYXRlZCBhbmQgY2Fubm90IGJlIHVzZWQuJyk7XG4gIH07XG59XG5cblxubW9kdWxlLmV4cG9ydHMuVHlwZSAgICAgICAgICAgICAgICA9IHJlcXVpcmUoJy4vanMteWFtbC90eXBlJyk7XG5tb2R1bGUuZXhwb3J0cy5TY2hlbWEgICAgICAgICAgICAgID0gcmVxdWlyZSgnLi9qcy15YW1sL3NjaGVtYScpO1xubW9kdWxlLmV4cG9ydHMuRkFJTFNBRkVfU0NIRU1BICAgICA9IHJlcXVpcmUoJy4vanMteWFtbC9zY2hlbWEvZmFpbHNhZmUnKTtcbm1vZHVsZS5leHBvcnRzLkpTT05fU0NIRU1BICAgICAgICAgPSByZXF1aXJlKCcuL2pzLXlhbWwvc2NoZW1hL2pzb24nKTtcbm1vZHVsZS5leHBvcnRzLkNPUkVfU0NIRU1BICAgICAgICAgPSByZXF1aXJlKCcuL2pzLXlhbWwvc2NoZW1hL2NvcmUnKTtcbm1vZHVsZS5leHBvcnRzLkRFRkFVTFRfU0FGRV9TQ0hFTUEgPSByZXF1aXJlKCcuL2pzLXlhbWwvc2NoZW1hL2RlZmF1bHRfc2FmZScpO1xubW9kdWxlLmV4cG9ydHMuREVGQVVMVF9GVUxMX1NDSEVNQSA9IHJlcXVpcmUoJy4vanMteWFtbC9zY2hlbWEvZGVmYXVsdF9mdWxsJyk7XG5tb2R1bGUuZXhwb3J0cy5sb2FkICAgICAgICAgICAgICAgID0gbG9hZGVyLmxvYWQ7XG5tb2R1bGUuZXhwb3J0cy5sb2FkQWxsICAgICAgICAgICAgID0gbG9hZGVyLmxvYWRBbGw7XG5tb2R1bGUuZXhwb3J0cy5zYWZlTG9hZCAgICAgICAgICAgID0gbG9hZGVyLnNhZmVMb2FkO1xubW9kdWxlLmV4cG9ydHMuc2FmZUxvYWRBbGwgICAgICAgICA9IGxvYWRlci5zYWZlTG9hZEFsbDtcbm1vZHVsZS5leHBvcnRzLmR1bXAgICAgICAgICAgICAgICAgPSBkdW1wZXIuZHVtcDtcbm1vZHVsZS5leHBvcnRzLnNhZmVEdW1wICAgICAgICAgICAgPSBkdW1wZXIuc2FmZUR1bXA7XG5tb2R1bGUuZXhwb3J0cy5ZQU1MRXhjZXB0aW9uICAgICAgID0gcmVxdWlyZSgnLi9qcy15YW1sL2V4Y2VwdGlvbicpO1xuXG4vLyBEZXByZWNhdGVkIHNjaGVtYSBuYW1lcyBmcm9tIEpTLVlBTUwgMi4wLnhcbm1vZHVsZS5leHBvcnRzLk1JTklNQUxfU0NIRU1BID0gcmVxdWlyZSgnLi9qcy15YW1sL3NjaGVtYS9mYWlsc2FmZScpO1xubW9kdWxlLmV4cG9ydHMuU0FGRV9TQ0hFTUEgICAgPSByZXF1aXJlKCcuL2pzLXlhbWwvc2NoZW1hL2RlZmF1bHRfc2FmZScpO1xubW9kdWxlLmV4cG9ydHMuREVGQVVMVF9TQ0hFTUEgPSByZXF1aXJlKCcuL2pzLXlhbWwvc2NoZW1hL2RlZmF1bHRfZnVsbCcpO1xuXG4vLyBEZXByZWNhdGVkIGZ1bmN0aW9ucyBmcm9tIEpTLVlBTUwgMS54Lnhcbm1vZHVsZS5leHBvcnRzLnNjYW4gICAgICAgICAgID0gZGVwcmVjYXRlZCgnc2NhbicpO1xubW9kdWxlLmV4cG9ydHMucGFyc2UgICAgICAgICAgPSBkZXByZWNhdGVkKCdwYXJzZScpO1xubW9kdWxlLmV4cG9ydHMuY29tcG9zZSAgICAgICAgPSBkZXByZWNhdGVkKCdjb21wb3NlJyk7XG5tb2R1bGUuZXhwb3J0cy5hZGRDb25zdHJ1Y3RvciA9IGRlcHJlY2F0ZWQoJ2FkZENvbnN0cnVjdG9yJyk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvanMteWFtbC9saWIvanMteWFtbC5qcyIsIid1c2Ugc3RyaWN0JztcblxuLyplc2xpbnQtZGlzYWJsZSBtYXgtbGVuLG5vLXVzZS1iZWZvcmUtZGVmaW5lKi9cblxudmFyIGNvbW1vbiAgICAgICAgICAgICAgPSByZXF1aXJlKCcuL2NvbW1vbicpO1xudmFyIFlBTUxFeGNlcHRpb24gICAgICAgPSByZXF1aXJlKCcuL2V4Y2VwdGlvbicpO1xudmFyIE1hcmsgICAgICAgICAgICAgICAgPSByZXF1aXJlKCcuL21hcmsnKTtcbnZhciBERUZBVUxUX1NBRkVfU0NIRU1BID0gcmVxdWlyZSgnLi9zY2hlbWEvZGVmYXVsdF9zYWZlJyk7XG52YXIgREVGQVVMVF9GVUxMX1NDSEVNQSA9IHJlcXVpcmUoJy4vc2NoZW1hL2RlZmF1bHRfZnVsbCcpO1xuXG5cbnZhciBfaGFzT3duUHJvcGVydHkgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xuXG5cbnZhciBDT05URVhUX0ZMT1dfSU4gICA9IDE7XG52YXIgQ09OVEVYVF9GTE9XX09VVCAgPSAyO1xudmFyIENPTlRFWFRfQkxPQ0tfSU4gID0gMztcbnZhciBDT05URVhUX0JMT0NLX09VVCA9IDQ7XG5cblxudmFyIENIT01QSU5HX0NMSVAgID0gMTtcbnZhciBDSE9NUElOR19TVFJJUCA9IDI7XG52YXIgQ0hPTVBJTkdfS0VFUCAgPSAzO1xuXG5cbnZhciBQQVRURVJOX05PTl9QUklOVEFCTEUgICAgICAgICA9IC9bXFx4MDAtXFx4MDhcXHgwQlxceDBDXFx4MEUtXFx4MUZcXHg3Ri1cXHg4NFxceDg2LVxceDlGXFx1RkZGRVxcdUZGRkZdfFtcXHVEODAwLVxcdURCRkZdKD8hW1xcdURDMDAtXFx1REZGRl0pfCg/OlteXFx1RDgwMC1cXHVEQkZGXXxeKVtcXHVEQzAwLVxcdURGRkZdLztcbnZhciBQQVRURVJOX05PTl9BU0NJSV9MSU5FX0JSRUFLUyA9IC9bXFx4ODVcXHUyMDI4XFx1MjAyOV0vO1xudmFyIFBBVFRFUk5fRkxPV19JTkRJQ0FUT1JTICAgICAgID0gL1ssXFxbXFxdXFx7XFx9XS87XG52YXIgUEFUVEVSTl9UQUdfSEFORExFICAgICAgICAgICAgPSAvXig/OiF8ISF8IVthLXpcXC1dKyEpJC9pO1xudmFyIFBBVFRFUk5fVEFHX1VSSSAgICAgICAgICAgICAgID0gL14oPzohfFteLFxcW1xcXVxce1xcfV0pKD86JVswLTlhLWZdezJ9fFswLTlhLXpcXC0jO1xcL1xcPzpAJj1cXCtcXCQsX1xcLiF+XFwqJ1xcKFxcKVxcW1xcXV0pKiQvaTtcblxuXG5mdW5jdGlvbiBpc19FT0woYykge1xuICByZXR1cm4gKGMgPT09IDB4MEEvKiBMRiAqLykgfHwgKGMgPT09IDB4MEQvKiBDUiAqLyk7XG59XG5cbmZ1bmN0aW9uIGlzX1dISVRFX1NQQUNFKGMpIHtcbiAgcmV0dXJuIChjID09PSAweDA5LyogVGFiICovKSB8fCAoYyA9PT0gMHgyMC8qIFNwYWNlICovKTtcbn1cblxuZnVuY3Rpb24gaXNfV1NfT1JfRU9MKGMpIHtcbiAgcmV0dXJuIChjID09PSAweDA5LyogVGFiICovKSB8fFxuICAgICAgICAgKGMgPT09IDB4MjAvKiBTcGFjZSAqLykgfHxcbiAgICAgICAgIChjID09PSAweDBBLyogTEYgKi8pIHx8XG4gICAgICAgICAoYyA9PT0gMHgwRC8qIENSICovKTtcbn1cblxuZnVuY3Rpb24gaXNfRkxPV19JTkRJQ0FUT1IoYykge1xuICByZXR1cm4gYyA9PT0gMHgyQy8qICwgKi8gfHxcbiAgICAgICAgIGMgPT09IDB4NUIvKiBbICovIHx8XG4gICAgICAgICBjID09PSAweDVELyogXSAqLyB8fFxuICAgICAgICAgYyA9PT0gMHg3Qi8qIHsgKi8gfHxcbiAgICAgICAgIGMgPT09IDB4N0QvKiB9ICovO1xufVxuXG5mdW5jdGlvbiBmcm9tSGV4Q29kZShjKSB7XG4gIHZhciBsYztcblxuICBpZiAoKDB4MzAvKiAwICovIDw9IGMpICYmIChjIDw9IDB4MzkvKiA5ICovKSkge1xuICAgIHJldHVybiBjIC0gMHgzMDtcbiAgfVxuXG4gIC8qZXNsaW50LWRpc2FibGUgbm8tYml0d2lzZSovXG4gIGxjID0gYyB8IDB4MjA7XG5cbiAgaWYgKCgweDYxLyogYSAqLyA8PSBsYykgJiYgKGxjIDw9IDB4NjYvKiBmICovKSkge1xuICAgIHJldHVybiBsYyAtIDB4NjEgKyAxMDtcbiAgfVxuXG4gIHJldHVybiAtMTtcbn1cblxuZnVuY3Rpb24gZXNjYXBlZEhleExlbihjKSB7XG4gIGlmIChjID09PSAweDc4LyogeCAqLykgeyByZXR1cm4gMjsgfVxuICBpZiAoYyA9PT0gMHg3NS8qIHUgKi8pIHsgcmV0dXJuIDQ7IH1cbiAgaWYgKGMgPT09IDB4NTUvKiBVICovKSB7IHJldHVybiA4OyB9XG4gIHJldHVybiAwO1xufVxuXG5mdW5jdGlvbiBmcm9tRGVjaW1hbENvZGUoYykge1xuICBpZiAoKDB4MzAvKiAwICovIDw9IGMpICYmIChjIDw9IDB4MzkvKiA5ICovKSkge1xuICAgIHJldHVybiBjIC0gMHgzMDtcbiAgfVxuXG4gIHJldHVybiAtMTtcbn1cblxuZnVuY3Rpb24gc2ltcGxlRXNjYXBlU2VxdWVuY2UoYykge1xuICAvKiBlc2xpbnQtZGlzYWJsZSBpbmRlbnQgKi9cbiAgcmV0dXJuIChjID09PSAweDMwLyogMCAqLykgPyAnXFx4MDAnIDpcbiAgICAgICAgKGMgPT09IDB4NjEvKiBhICovKSA/ICdcXHgwNycgOlxuICAgICAgICAoYyA9PT0gMHg2Mi8qIGIgKi8pID8gJ1xceDA4JyA6XG4gICAgICAgIChjID09PSAweDc0LyogdCAqLykgPyAnXFx4MDknIDpcbiAgICAgICAgKGMgPT09IDB4MDkvKiBUYWIgKi8pID8gJ1xceDA5JyA6XG4gICAgICAgIChjID09PSAweDZFLyogbiAqLykgPyAnXFx4MEEnIDpcbiAgICAgICAgKGMgPT09IDB4NzYvKiB2ICovKSA/ICdcXHgwQicgOlxuICAgICAgICAoYyA9PT0gMHg2Ni8qIGYgKi8pID8gJ1xceDBDJyA6XG4gICAgICAgIChjID09PSAweDcyLyogciAqLykgPyAnXFx4MEQnIDpcbiAgICAgICAgKGMgPT09IDB4NjUvKiBlICovKSA/ICdcXHgxQicgOlxuICAgICAgICAoYyA9PT0gMHgyMC8qIFNwYWNlICovKSA/ICcgJyA6XG4gICAgICAgIChjID09PSAweDIyLyogXCIgKi8pID8gJ1xceDIyJyA6XG4gICAgICAgIChjID09PSAweDJGLyogLyAqLykgPyAnLycgOlxuICAgICAgICAoYyA9PT0gMHg1Qy8qIFxcICovKSA/ICdcXHg1QycgOlxuICAgICAgICAoYyA9PT0gMHg0RS8qIE4gKi8pID8gJ1xceDg1JyA6XG4gICAgICAgIChjID09PSAweDVGLyogXyAqLykgPyAnXFx4QTAnIDpcbiAgICAgICAgKGMgPT09IDB4NEMvKiBMICovKSA/ICdcXHUyMDI4JyA6XG4gICAgICAgIChjID09PSAweDUwLyogUCAqLykgPyAnXFx1MjAyOScgOiAnJztcbn1cblxuZnVuY3Rpb24gY2hhckZyb21Db2RlcG9pbnQoYykge1xuICBpZiAoYyA8PSAweEZGRkYpIHtcbiAgICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZShjKTtcbiAgfVxuICAvLyBFbmNvZGUgVVRGLTE2IHN1cnJvZ2F0ZSBwYWlyXG4gIC8vIGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL1VURi0xNiNDb2RlX3BvaW50c19VLjJCMDEwMDAwX3RvX1UuMkIxMEZGRkZcbiAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUoXG4gICAgKChjIC0gMHgwMTAwMDApID4+IDEwKSArIDB4RDgwMCxcbiAgICAoKGMgLSAweDAxMDAwMCkgJiAweDAzRkYpICsgMHhEQzAwXG4gICk7XG59XG5cbnZhciBzaW1wbGVFc2NhcGVDaGVjayA9IG5ldyBBcnJheSgyNTYpOyAvLyBpbnRlZ2VyLCBmb3IgZmFzdCBhY2Nlc3NcbnZhciBzaW1wbGVFc2NhcGVNYXAgPSBuZXcgQXJyYXkoMjU2KTtcbmZvciAodmFyIGkgPSAwOyBpIDwgMjU2OyBpKyspIHtcbiAgc2ltcGxlRXNjYXBlQ2hlY2tbaV0gPSBzaW1wbGVFc2NhcGVTZXF1ZW5jZShpKSA/IDEgOiAwO1xuICBzaW1wbGVFc2NhcGVNYXBbaV0gPSBzaW1wbGVFc2NhcGVTZXF1ZW5jZShpKTtcbn1cblxuXG5mdW5jdGlvbiBTdGF0ZShpbnB1dCwgb3B0aW9ucykge1xuICB0aGlzLmlucHV0ID0gaW5wdXQ7XG5cbiAgdGhpcy5maWxlbmFtZSAgPSBvcHRpb25zWydmaWxlbmFtZSddICB8fCBudWxsO1xuICB0aGlzLnNjaGVtYSAgICA9IG9wdGlvbnNbJ3NjaGVtYSddICAgIHx8IERFRkFVTFRfRlVMTF9TQ0hFTUE7XG4gIHRoaXMub25XYXJuaW5nID0gb3B0aW9uc1snb25XYXJuaW5nJ10gfHwgbnVsbDtcbiAgdGhpcy5sZWdhY3kgICAgPSBvcHRpb25zWydsZWdhY3knXSAgICB8fCBmYWxzZTtcbiAgdGhpcy5qc29uICAgICAgPSBvcHRpb25zWydqc29uJ10gICAgICB8fCBmYWxzZTtcbiAgdGhpcy5saXN0ZW5lciAgPSBvcHRpb25zWydsaXN0ZW5lciddICB8fCBudWxsO1xuXG4gIHRoaXMuaW1wbGljaXRUeXBlcyA9IHRoaXMuc2NoZW1hLmNvbXBpbGVkSW1wbGljaXQ7XG4gIHRoaXMudHlwZU1hcCAgICAgICA9IHRoaXMuc2NoZW1hLmNvbXBpbGVkVHlwZU1hcDtcblxuICB0aGlzLmxlbmd0aCAgICAgPSBpbnB1dC5sZW5ndGg7XG4gIHRoaXMucG9zaXRpb24gICA9IDA7XG4gIHRoaXMubGluZSAgICAgICA9IDA7XG4gIHRoaXMubGluZVN0YXJ0ICA9IDA7XG4gIHRoaXMubGluZUluZGVudCA9IDA7XG5cbiAgdGhpcy5kb2N1bWVudHMgPSBbXTtcblxuICAvKlxuICB0aGlzLnZlcnNpb247XG4gIHRoaXMuY2hlY2tMaW5lQnJlYWtzO1xuICB0aGlzLnRhZ01hcDtcbiAgdGhpcy5hbmNob3JNYXA7XG4gIHRoaXMudGFnO1xuICB0aGlzLmFuY2hvcjtcbiAgdGhpcy5raW5kO1xuICB0aGlzLnJlc3VsdDsqL1xuXG59XG5cblxuZnVuY3Rpb24gZ2VuZXJhdGVFcnJvcihzdGF0ZSwgbWVzc2FnZSkge1xuICByZXR1cm4gbmV3IFlBTUxFeGNlcHRpb24oXG4gICAgbWVzc2FnZSxcbiAgICBuZXcgTWFyayhzdGF0ZS5maWxlbmFtZSwgc3RhdGUuaW5wdXQsIHN0YXRlLnBvc2l0aW9uLCBzdGF0ZS5saW5lLCAoc3RhdGUucG9zaXRpb24gLSBzdGF0ZS5saW5lU3RhcnQpKSk7XG59XG5cbmZ1bmN0aW9uIHRocm93RXJyb3Ioc3RhdGUsIG1lc3NhZ2UpIHtcbiAgdGhyb3cgZ2VuZXJhdGVFcnJvcihzdGF0ZSwgbWVzc2FnZSk7XG59XG5cbmZ1bmN0aW9uIHRocm93V2FybmluZyhzdGF0ZSwgbWVzc2FnZSkge1xuICBpZiAoc3RhdGUub25XYXJuaW5nKSB7XG4gICAgc3RhdGUub25XYXJuaW5nLmNhbGwobnVsbCwgZ2VuZXJhdGVFcnJvcihzdGF0ZSwgbWVzc2FnZSkpO1xuICB9XG59XG5cblxudmFyIGRpcmVjdGl2ZUhhbmRsZXJzID0ge1xuXG4gIFlBTUw6IGZ1bmN0aW9uIGhhbmRsZVlhbWxEaXJlY3RpdmUoc3RhdGUsIG5hbWUsIGFyZ3MpIHtcblxuICAgIHZhciBtYXRjaCwgbWFqb3IsIG1pbm9yO1xuXG4gICAgaWYgKHN0YXRlLnZlcnNpb24gIT09IG51bGwpIHtcbiAgICAgIHRocm93RXJyb3Ioc3RhdGUsICdkdXBsaWNhdGlvbiBvZiAlWUFNTCBkaXJlY3RpdmUnKTtcbiAgICB9XG5cbiAgICBpZiAoYXJncy5sZW5ndGggIT09IDEpIHtcbiAgICAgIHRocm93RXJyb3Ioc3RhdGUsICdZQU1MIGRpcmVjdGl2ZSBhY2NlcHRzIGV4YWN0bHkgb25lIGFyZ3VtZW50Jyk7XG4gICAgfVxuXG4gICAgbWF0Y2ggPSAvXihbMC05XSspXFwuKFswLTldKykkLy5leGVjKGFyZ3NbMF0pO1xuXG4gICAgaWYgKG1hdGNoID09PSBudWxsKSB7XG4gICAgICB0aHJvd0Vycm9yKHN0YXRlLCAnaWxsLWZvcm1lZCBhcmd1bWVudCBvZiB0aGUgWUFNTCBkaXJlY3RpdmUnKTtcbiAgICB9XG5cbiAgICBtYWpvciA9IHBhcnNlSW50KG1hdGNoWzFdLCAxMCk7XG4gICAgbWlub3IgPSBwYXJzZUludChtYXRjaFsyXSwgMTApO1xuXG4gICAgaWYgKG1ham9yICE9PSAxKSB7XG4gICAgICB0aHJvd0Vycm9yKHN0YXRlLCAndW5hY2NlcHRhYmxlIFlBTUwgdmVyc2lvbiBvZiB0aGUgZG9jdW1lbnQnKTtcbiAgICB9XG5cbiAgICBzdGF0ZS52ZXJzaW9uID0gYXJnc1swXTtcbiAgICBzdGF0ZS5jaGVja0xpbmVCcmVha3MgPSAobWlub3IgPCAyKTtcblxuICAgIGlmIChtaW5vciAhPT0gMSAmJiBtaW5vciAhPT0gMikge1xuICAgICAgdGhyb3dXYXJuaW5nKHN0YXRlLCAndW5zdXBwb3J0ZWQgWUFNTCB2ZXJzaW9uIG9mIHRoZSBkb2N1bWVudCcpO1xuICAgIH1cbiAgfSxcblxuICBUQUc6IGZ1bmN0aW9uIGhhbmRsZVRhZ0RpcmVjdGl2ZShzdGF0ZSwgbmFtZSwgYXJncykge1xuXG4gICAgdmFyIGhhbmRsZSwgcHJlZml4O1xuXG4gICAgaWYgKGFyZ3MubGVuZ3RoICE9PSAyKSB7XG4gICAgICB0aHJvd0Vycm9yKHN0YXRlLCAnVEFHIGRpcmVjdGl2ZSBhY2NlcHRzIGV4YWN0bHkgdHdvIGFyZ3VtZW50cycpO1xuICAgIH1cblxuICAgIGhhbmRsZSA9IGFyZ3NbMF07XG4gICAgcHJlZml4ID0gYXJnc1sxXTtcblxuICAgIGlmICghUEFUVEVSTl9UQUdfSEFORExFLnRlc3QoaGFuZGxlKSkge1xuICAgICAgdGhyb3dFcnJvcihzdGF0ZSwgJ2lsbC1mb3JtZWQgdGFnIGhhbmRsZSAoZmlyc3QgYXJndW1lbnQpIG9mIHRoZSBUQUcgZGlyZWN0aXZlJyk7XG4gICAgfVxuXG4gICAgaWYgKF9oYXNPd25Qcm9wZXJ0eS5jYWxsKHN0YXRlLnRhZ01hcCwgaGFuZGxlKSkge1xuICAgICAgdGhyb3dFcnJvcihzdGF0ZSwgJ3RoZXJlIGlzIGEgcHJldmlvdXNseSBkZWNsYXJlZCBzdWZmaXggZm9yIFwiJyArIGhhbmRsZSArICdcIiB0YWcgaGFuZGxlJyk7XG4gICAgfVxuXG4gICAgaWYgKCFQQVRURVJOX1RBR19VUkkudGVzdChwcmVmaXgpKSB7XG4gICAgICB0aHJvd0Vycm9yKHN0YXRlLCAnaWxsLWZvcm1lZCB0YWcgcHJlZml4IChzZWNvbmQgYXJndW1lbnQpIG9mIHRoZSBUQUcgZGlyZWN0aXZlJyk7XG4gICAgfVxuXG4gICAgc3RhdGUudGFnTWFwW2hhbmRsZV0gPSBwcmVmaXg7XG4gIH1cbn07XG5cblxuZnVuY3Rpb24gY2FwdHVyZVNlZ21lbnQoc3RhdGUsIHN0YXJ0LCBlbmQsIGNoZWNrSnNvbikge1xuICB2YXIgX3Bvc2l0aW9uLCBfbGVuZ3RoLCBfY2hhcmFjdGVyLCBfcmVzdWx0O1xuXG4gIGlmIChzdGFydCA8IGVuZCkge1xuICAgIF9yZXN1bHQgPSBzdGF0ZS5pbnB1dC5zbGljZShzdGFydCwgZW5kKTtcblxuICAgIGlmIChjaGVja0pzb24pIHtcbiAgICAgIGZvciAoX3Bvc2l0aW9uID0gMCwgX2xlbmd0aCA9IF9yZXN1bHQubGVuZ3RoOyBfcG9zaXRpb24gPCBfbGVuZ3RoOyBfcG9zaXRpb24gKz0gMSkge1xuICAgICAgICBfY2hhcmFjdGVyID0gX3Jlc3VsdC5jaGFyQ29kZUF0KF9wb3NpdGlvbik7XG4gICAgICAgIGlmICghKF9jaGFyYWN0ZXIgPT09IDB4MDkgfHxcbiAgICAgICAgICAgICAgKDB4MjAgPD0gX2NoYXJhY3RlciAmJiBfY2hhcmFjdGVyIDw9IDB4MTBGRkZGKSkpIHtcbiAgICAgICAgICB0aHJvd0Vycm9yKHN0YXRlLCAnZXhwZWN0ZWQgdmFsaWQgSlNPTiBjaGFyYWN0ZXInKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoUEFUVEVSTl9OT05fUFJJTlRBQkxFLnRlc3QoX3Jlc3VsdCkpIHtcbiAgICAgIHRocm93RXJyb3Ioc3RhdGUsICd0aGUgc3RyZWFtIGNvbnRhaW5zIG5vbi1wcmludGFibGUgY2hhcmFjdGVycycpO1xuICAgIH1cblxuICAgIHN0YXRlLnJlc3VsdCArPSBfcmVzdWx0O1xuICB9XG59XG5cbmZ1bmN0aW9uIG1lcmdlTWFwcGluZ3Moc3RhdGUsIGRlc3RpbmF0aW9uLCBzb3VyY2UsIG92ZXJyaWRhYmxlS2V5cykge1xuICB2YXIgc291cmNlS2V5cywga2V5LCBpbmRleCwgcXVhbnRpdHk7XG5cbiAgaWYgKCFjb21tb24uaXNPYmplY3Qoc291cmNlKSkge1xuICAgIHRocm93RXJyb3Ioc3RhdGUsICdjYW5ub3QgbWVyZ2UgbWFwcGluZ3M7IHRoZSBwcm92aWRlZCBzb3VyY2Ugb2JqZWN0IGlzIHVuYWNjZXB0YWJsZScpO1xuICB9XG5cbiAgc291cmNlS2V5cyA9IE9iamVjdC5rZXlzKHNvdXJjZSk7XG5cbiAgZm9yIChpbmRleCA9IDAsIHF1YW50aXR5ID0gc291cmNlS2V5cy5sZW5ndGg7IGluZGV4IDwgcXVhbnRpdHk7IGluZGV4ICs9IDEpIHtcbiAgICBrZXkgPSBzb3VyY2VLZXlzW2luZGV4XTtcblxuICAgIGlmICghX2hhc093blByb3BlcnR5LmNhbGwoZGVzdGluYXRpb24sIGtleSkpIHtcbiAgICAgIGRlc3RpbmF0aW9uW2tleV0gPSBzb3VyY2Vba2V5XTtcbiAgICAgIG92ZXJyaWRhYmxlS2V5c1trZXldID0gdHJ1ZTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gc3RvcmVNYXBwaW5nUGFpcihzdGF0ZSwgX3Jlc3VsdCwgb3ZlcnJpZGFibGVLZXlzLCBrZXlUYWcsIGtleU5vZGUsIHZhbHVlTm9kZSwgc3RhcnRMaW5lLCBzdGFydFBvcykge1xuICB2YXIgaW5kZXgsIHF1YW50aXR5O1xuXG4gIGtleU5vZGUgPSBTdHJpbmcoa2V5Tm9kZSk7XG5cbiAgaWYgKF9yZXN1bHQgPT09IG51bGwpIHtcbiAgICBfcmVzdWx0ID0ge307XG4gIH1cblxuICBpZiAoa2V5VGFnID09PSAndGFnOnlhbWwub3JnLDIwMDI6bWVyZ2UnKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWVOb2RlKSkge1xuICAgICAgZm9yIChpbmRleCA9IDAsIHF1YW50aXR5ID0gdmFsdWVOb2RlLmxlbmd0aDsgaW5kZXggPCBxdWFudGl0eTsgaW5kZXggKz0gMSkge1xuICAgICAgICBtZXJnZU1hcHBpbmdzKHN0YXRlLCBfcmVzdWx0LCB2YWx1ZU5vZGVbaW5kZXhdLCBvdmVycmlkYWJsZUtleXMpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBtZXJnZU1hcHBpbmdzKHN0YXRlLCBfcmVzdWx0LCB2YWx1ZU5vZGUsIG92ZXJyaWRhYmxlS2V5cyk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGlmICghc3RhdGUuanNvbiAmJlxuICAgICAgICAhX2hhc093blByb3BlcnR5LmNhbGwob3ZlcnJpZGFibGVLZXlzLCBrZXlOb2RlKSAmJlxuICAgICAgICBfaGFzT3duUHJvcGVydHkuY2FsbChfcmVzdWx0LCBrZXlOb2RlKSkge1xuICAgICAgc3RhdGUubGluZSA9IHN0YXJ0TGluZSB8fCBzdGF0ZS5saW5lO1xuICAgICAgc3RhdGUucG9zaXRpb24gPSBzdGFydFBvcyB8fCBzdGF0ZS5wb3NpdGlvbjtcbiAgICAgIHRocm93RXJyb3Ioc3RhdGUsICdkdXBsaWNhdGVkIG1hcHBpbmcga2V5Jyk7XG4gICAgfVxuICAgIF9yZXN1bHRba2V5Tm9kZV0gPSB2YWx1ZU5vZGU7XG4gICAgZGVsZXRlIG92ZXJyaWRhYmxlS2V5c1trZXlOb2RlXTtcbiAgfVxuXG4gIHJldHVybiBfcmVzdWx0O1xufVxuXG5mdW5jdGlvbiByZWFkTGluZUJyZWFrKHN0YXRlKSB7XG4gIHZhciBjaDtcblxuICBjaCA9IHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoc3RhdGUucG9zaXRpb24pO1xuXG4gIGlmIChjaCA9PT0gMHgwQS8qIExGICovKSB7XG4gICAgc3RhdGUucG9zaXRpb24rKztcbiAgfSBlbHNlIGlmIChjaCA9PT0gMHgwRC8qIENSICovKSB7XG4gICAgc3RhdGUucG9zaXRpb24rKztcbiAgICBpZiAoc3RhdGUuaW5wdXQuY2hhckNvZGVBdChzdGF0ZS5wb3NpdGlvbikgPT09IDB4MEEvKiBMRiAqLykge1xuICAgICAgc3RhdGUucG9zaXRpb24rKztcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdGhyb3dFcnJvcihzdGF0ZSwgJ2EgbGluZSBicmVhayBpcyBleHBlY3RlZCcpO1xuICB9XG5cbiAgc3RhdGUubGluZSArPSAxO1xuICBzdGF0ZS5saW5lU3RhcnQgPSBzdGF0ZS5wb3NpdGlvbjtcbn1cblxuZnVuY3Rpb24gc2tpcFNlcGFyYXRpb25TcGFjZShzdGF0ZSwgYWxsb3dDb21tZW50cywgY2hlY2tJbmRlbnQpIHtcbiAgdmFyIGxpbmVCcmVha3MgPSAwLFxuICAgICAgY2ggPSBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KHN0YXRlLnBvc2l0aW9uKTtcblxuICB3aGlsZSAoY2ggIT09IDApIHtcbiAgICB3aGlsZSAoaXNfV0hJVEVfU1BBQ0UoY2gpKSB7XG4gICAgICBjaCA9IHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoKytzdGF0ZS5wb3NpdGlvbik7XG4gICAgfVxuXG4gICAgaWYgKGFsbG93Q29tbWVudHMgJiYgY2ggPT09IDB4MjMvKiAjICovKSB7XG4gICAgICBkbyB7XG4gICAgICAgIGNoID0gc3RhdGUuaW5wdXQuY2hhckNvZGVBdCgrK3N0YXRlLnBvc2l0aW9uKTtcbiAgICAgIH0gd2hpbGUgKGNoICE9PSAweDBBLyogTEYgKi8gJiYgY2ggIT09IDB4MEQvKiBDUiAqLyAmJiBjaCAhPT0gMCk7XG4gICAgfVxuXG4gICAgaWYgKGlzX0VPTChjaCkpIHtcbiAgICAgIHJlYWRMaW5lQnJlYWsoc3RhdGUpO1xuXG4gICAgICBjaCA9IHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoc3RhdGUucG9zaXRpb24pO1xuICAgICAgbGluZUJyZWFrcysrO1xuICAgICAgc3RhdGUubGluZUluZGVudCA9IDA7XG5cbiAgICAgIHdoaWxlIChjaCA9PT0gMHgyMC8qIFNwYWNlICovKSB7XG4gICAgICAgIHN0YXRlLmxpbmVJbmRlbnQrKztcbiAgICAgICAgY2ggPSBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KCsrc3RhdGUucG9zaXRpb24pO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cblxuICBpZiAoY2hlY2tJbmRlbnQgIT09IC0xICYmIGxpbmVCcmVha3MgIT09IDAgJiYgc3RhdGUubGluZUluZGVudCA8IGNoZWNrSW5kZW50KSB7XG4gICAgdGhyb3dXYXJuaW5nKHN0YXRlLCAnZGVmaWNpZW50IGluZGVudGF0aW9uJyk7XG4gIH1cblxuICByZXR1cm4gbGluZUJyZWFrcztcbn1cblxuZnVuY3Rpb24gdGVzdERvY3VtZW50U2VwYXJhdG9yKHN0YXRlKSB7XG4gIHZhciBfcG9zaXRpb24gPSBzdGF0ZS5wb3NpdGlvbixcbiAgICAgIGNoO1xuXG4gIGNoID0gc3RhdGUuaW5wdXQuY2hhckNvZGVBdChfcG9zaXRpb24pO1xuXG4gIC8vIENvbmRpdGlvbiBzdGF0ZS5wb3NpdGlvbiA9PT0gc3RhdGUubGluZVN0YXJ0IGlzIHRlc3RlZFxuICAvLyBpbiBwYXJlbnQgb24gZWFjaCBjYWxsLCBmb3IgZWZmaWNpZW5jeS4gTm8gbmVlZHMgdG8gdGVzdCBoZXJlIGFnYWluLlxuICBpZiAoKGNoID09PSAweDJELyogLSAqLyB8fCBjaCA9PT0gMHgyRS8qIC4gKi8pICYmXG4gICAgICBjaCA9PT0gc3RhdGUuaW5wdXQuY2hhckNvZGVBdChfcG9zaXRpb24gKyAxKSAmJlxuICAgICAgY2ggPT09IHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoX3Bvc2l0aW9uICsgMikpIHtcblxuICAgIF9wb3NpdGlvbiArPSAzO1xuXG4gICAgY2ggPSBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KF9wb3NpdGlvbik7XG5cbiAgICBpZiAoY2ggPT09IDAgfHwgaXNfV1NfT1JfRU9MKGNoKSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiB3cml0ZUZvbGRlZExpbmVzKHN0YXRlLCBjb3VudCkge1xuICBpZiAoY291bnQgPT09IDEpIHtcbiAgICBzdGF0ZS5yZXN1bHQgKz0gJyAnO1xuICB9IGVsc2UgaWYgKGNvdW50ID4gMSkge1xuICAgIHN0YXRlLnJlc3VsdCArPSBjb21tb24ucmVwZWF0KCdcXG4nLCBjb3VudCAtIDEpO1xuICB9XG59XG5cblxuZnVuY3Rpb24gcmVhZFBsYWluU2NhbGFyKHN0YXRlLCBub2RlSW5kZW50LCB3aXRoaW5GbG93Q29sbGVjdGlvbikge1xuICB2YXIgcHJlY2VkaW5nLFxuICAgICAgZm9sbG93aW5nLFxuICAgICAgY2FwdHVyZVN0YXJ0LFxuICAgICAgY2FwdHVyZUVuZCxcbiAgICAgIGhhc1BlbmRpbmdDb250ZW50LFxuICAgICAgX2xpbmUsXG4gICAgICBfbGluZVN0YXJ0LFxuICAgICAgX2xpbmVJbmRlbnQsXG4gICAgICBfa2luZCA9IHN0YXRlLmtpbmQsXG4gICAgICBfcmVzdWx0ID0gc3RhdGUucmVzdWx0LFxuICAgICAgY2g7XG5cbiAgY2ggPSBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KHN0YXRlLnBvc2l0aW9uKTtcblxuICBpZiAoaXNfV1NfT1JfRU9MKGNoKSAgICAgIHx8XG4gICAgICBpc19GTE9XX0lORElDQVRPUihjaCkgfHxcbiAgICAgIGNoID09PSAweDIzLyogIyAqLyAgICB8fFxuICAgICAgY2ggPT09IDB4MjYvKiAmICovICAgIHx8XG4gICAgICBjaCA9PT0gMHgyQS8qICogKi8gICAgfHxcbiAgICAgIGNoID09PSAweDIxLyogISAqLyAgICB8fFxuICAgICAgY2ggPT09IDB4N0MvKiB8ICovICAgIHx8XG4gICAgICBjaCA9PT0gMHgzRS8qID4gKi8gICAgfHxcbiAgICAgIGNoID09PSAweDI3LyogJyAqLyAgICB8fFxuICAgICAgY2ggPT09IDB4MjIvKiBcIiAqLyAgICB8fFxuICAgICAgY2ggPT09IDB4MjUvKiAlICovICAgIHx8XG4gICAgICBjaCA9PT0gMHg0MC8qIEAgKi8gICAgfHxcbiAgICAgIGNoID09PSAweDYwLyogYCAqLykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGlmIChjaCA9PT0gMHgzRi8qID8gKi8gfHwgY2ggPT09IDB4MkQvKiAtICovKSB7XG4gICAgZm9sbG93aW5nID0gc3RhdGUuaW5wdXQuY2hhckNvZGVBdChzdGF0ZS5wb3NpdGlvbiArIDEpO1xuXG4gICAgaWYgKGlzX1dTX09SX0VPTChmb2xsb3dpbmcpIHx8XG4gICAgICAgIHdpdGhpbkZsb3dDb2xsZWN0aW9uICYmIGlzX0ZMT1dfSU5ESUNBVE9SKGZvbGxvd2luZykpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cblxuICBzdGF0ZS5raW5kID0gJ3NjYWxhcic7XG4gIHN0YXRlLnJlc3VsdCA9ICcnO1xuICBjYXB0dXJlU3RhcnQgPSBjYXB0dXJlRW5kID0gc3RhdGUucG9zaXRpb247XG4gIGhhc1BlbmRpbmdDb250ZW50ID0gZmFsc2U7XG5cbiAgd2hpbGUgKGNoICE9PSAwKSB7XG4gICAgaWYgKGNoID09PSAweDNBLyogOiAqLykge1xuICAgICAgZm9sbG93aW5nID0gc3RhdGUuaW5wdXQuY2hhckNvZGVBdChzdGF0ZS5wb3NpdGlvbiArIDEpO1xuXG4gICAgICBpZiAoaXNfV1NfT1JfRU9MKGZvbGxvd2luZykgfHxcbiAgICAgICAgICB3aXRoaW5GbG93Q29sbGVjdGlvbiAmJiBpc19GTE9XX0lORElDQVRPUihmb2xsb3dpbmcpKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgfSBlbHNlIGlmIChjaCA9PT0gMHgyMy8qICMgKi8pIHtcbiAgICAgIHByZWNlZGluZyA9IHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoc3RhdGUucG9zaXRpb24gLSAxKTtcblxuICAgICAgaWYgKGlzX1dTX09SX0VPTChwcmVjZWRpbmcpKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgfSBlbHNlIGlmICgoc3RhdGUucG9zaXRpb24gPT09IHN0YXRlLmxpbmVTdGFydCAmJiB0ZXN0RG9jdW1lbnRTZXBhcmF0b3Ioc3RhdGUpKSB8fFxuICAgICAgICAgICAgICAgd2l0aGluRmxvd0NvbGxlY3Rpb24gJiYgaXNfRkxPV19JTkRJQ0FUT1IoY2gpKSB7XG4gICAgICBicmVhaztcblxuICAgIH0gZWxzZSBpZiAoaXNfRU9MKGNoKSkge1xuICAgICAgX2xpbmUgPSBzdGF0ZS5saW5lO1xuICAgICAgX2xpbmVTdGFydCA9IHN0YXRlLmxpbmVTdGFydDtcbiAgICAgIF9saW5lSW5kZW50ID0gc3RhdGUubGluZUluZGVudDtcbiAgICAgIHNraXBTZXBhcmF0aW9uU3BhY2Uoc3RhdGUsIGZhbHNlLCAtMSk7XG5cbiAgICAgIGlmIChzdGF0ZS5saW5lSW5kZW50ID49IG5vZGVJbmRlbnQpIHtcbiAgICAgICAgaGFzUGVuZGluZ0NvbnRlbnQgPSB0cnVlO1xuICAgICAgICBjaCA9IHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoc3RhdGUucG9zaXRpb24pO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN0YXRlLnBvc2l0aW9uID0gY2FwdHVyZUVuZDtcbiAgICAgICAgc3RhdGUubGluZSA9IF9saW5lO1xuICAgICAgICBzdGF0ZS5saW5lU3RhcnQgPSBfbGluZVN0YXJ0O1xuICAgICAgICBzdGF0ZS5saW5lSW5kZW50ID0gX2xpbmVJbmRlbnQ7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChoYXNQZW5kaW5nQ29udGVudCkge1xuICAgICAgY2FwdHVyZVNlZ21lbnQoc3RhdGUsIGNhcHR1cmVTdGFydCwgY2FwdHVyZUVuZCwgZmFsc2UpO1xuICAgICAgd3JpdGVGb2xkZWRMaW5lcyhzdGF0ZSwgc3RhdGUubGluZSAtIF9saW5lKTtcbiAgICAgIGNhcHR1cmVTdGFydCA9IGNhcHR1cmVFbmQgPSBzdGF0ZS5wb3NpdGlvbjtcbiAgICAgIGhhc1BlbmRpbmdDb250ZW50ID0gZmFsc2U7XG4gICAgfVxuXG4gICAgaWYgKCFpc19XSElURV9TUEFDRShjaCkpIHtcbiAgICAgIGNhcHR1cmVFbmQgPSBzdGF0ZS5wb3NpdGlvbiArIDE7XG4gICAgfVxuXG4gICAgY2ggPSBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KCsrc3RhdGUucG9zaXRpb24pO1xuICB9XG5cbiAgY2FwdHVyZVNlZ21lbnQoc3RhdGUsIGNhcHR1cmVTdGFydCwgY2FwdHVyZUVuZCwgZmFsc2UpO1xuXG4gIGlmIChzdGF0ZS5yZXN1bHQpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIHN0YXRlLmtpbmQgPSBfa2luZDtcbiAgc3RhdGUucmVzdWx0ID0gX3Jlc3VsdDtcbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiByZWFkU2luZ2xlUXVvdGVkU2NhbGFyKHN0YXRlLCBub2RlSW5kZW50KSB7XG4gIHZhciBjaCxcbiAgICAgIGNhcHR1cmVTdGFydCwgY2FwdHVyZUVuZDtcblxuICBjaCA9IHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoc3RhdGUucG9zaXRpb24pO1xuXG4gIGlmIChjaCAhPT0gMHgyNy8qICcgKi8pIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBzdGF0ZS5raW5kID0gJ3NjYWxhcic7XG4gIHN0YXRlLnJlc3VsdCA9ICcnO1xuICBzdGF0ZS5wb3NpdGlvbisrO1xuICBjYXB0dXJlU3RhcnQgPSBjYXB0dXJlRW5kID0gc3RhdGUucG9zaXRpb247XG5cbiAgd2hpbGUgKChjaCA9IHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoc3RhdGUucG9zaXRpb24pKSAhPT0gMCkge1xuICAgIGlmIChjaCA9PT0gMHgyNy8qICcgKi8pIHtcbiAgICAgIGNhcHR1cmVTZWdtZW50KHN0YXRlLCBjYXB0dXJlU3RhcnQsIHN0YXRlLnBvc2l0aW9uLCB0cnVlKTtcbiAgICAgIGNoID0gc3RhdGUuaW5wdXQuY2hhckNvZGVBdCgrK3N0YXRlLnBvc2l0aW9uKTtcblxuICAgICAgaWYgKGNoID09PSAweDI3LyogJyAqLykge1xuICAgICAgICBjYXB0dXJlU3RhcnQgPSBzdGF0ZS5wb3NpdGlvbjtcbiAgICAgICAgc3RhdGUucG9zaXRpb24rKztcbiAgICAgICAgY2FwdHVyZUVuZCA9IHN0YXRlLnBvc2l0aW9uO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG5cbiAgICB9IGVsc2UgaWYgKGlzX0VPTChjaCkpIHtcbiAgICAgIGNhcHR1cmVTZWdtZW50KHN0YXRlLCBjYXB0dXJlU3RhcnQsIGNhcHR1cmVFbmQsIHRydWUpO1xuICAgICAgd3JpdGVGb2xkZWRMaW5lcyhzdGF0ZSwgc2tpcFNlcGFyYXRpb25TcGFjZShzdGF0ZSwgZmFsc2UsIG5vZGVJbmRlbnQpKTtcbiAgICAgIGNhcHR1cmVTdGFydCA9IGNhcHR1cmVFbmQgPSBzdGF0ZS5wb3NpdGlvbjtcblxuICAgIH0gZWxzZSBpZiAoc3RhdGUucG9zaXRpb24gPT09IHN0YXRlLmxpbmVTdGFydCAmJiB0ZXN0RG9jdW1lbnRTZXBhcmF0b3Ioc3RhdGUpKSB7XG4gICAgICB0aHJvd0Vycm9yKHN0YXRlLCAndW5leHBlY3RlZCBlbmQgb2YgdGhlIGRvY3VtZW50IHdpdGhpbiBhIHNpbmdsZSBxdW90ZWQgc2NhbGFyJyk7XG5cbiAgICB9IGVsc2Uge1xuICAgICAgc3RhdGUucG9zaXRpb24rKztcbiAgICAgIGNhcHR1cmVFbmQgPSBzdGF0ZS5wb3NpdGlvbjtcbiAgICB9XG4gIH1cblxuICB0aHJvd0Vycm9yKHN0YXRlLCAndW5leHBlY3RlZCBlbmQgb2YgdGhlIHN0cmVhbSB3aXRoaW4gYSBzaW5nbGUgcXVvdGVkIHNjYWxhcicpO1xufVxuXG5mdW5jdGlvbiByZWFkRG91YmxlUXVvdGVkU2NhbGFyKHN0YXRlLCBub2RlSW5kZW50KSB7XG4gIHZhciBjYXB0dXJlU3RhcnQsXG4gICAgICBjYXB0dXJlRW5kLFxuICAgICAgaGV4TGVuZ3RoLFxuICAgICAgaGV4UmVzdWx0LFxuICAgICAgdG1wLFxuICAgICAgY2g7XG5cbiAgY2ggPSBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KHN0YXRlLnBvc2l0aW9uKTtcblxuICBpZiAoY2ggIT09IDB4MjIvKiBcIiAqLykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHN0YXRlLmtpbmQgPSAnc2NhbGFyJztcbiAgc3RhdGUucmVzdWx0ID0gJyc7XG4gIHN0YXRlLnBvc2l0aW9uKys7XG4gIGNhcHR1cmVTdGFydCA9IGNhcHR1cmVFbmQgPSBzdGF0ZS5wb3NpdGlvbjtcblxuICB3aGlsZSAoKGNoID0gc3RhdGUuaW5wdXQuY2hhckNvZGVBdChzdGF0ZS5wb3NpdGlvbikpICE9PSAwKSB7XG4gICAgaWYgKGNoID09PSAweDIyLyogXCIgKi8pIHtcbiAgICAgIGNhcHR1cmVTZWdtZW50KHN0YXRlLCBjYXB0dXJlU3RhcnQsIHN0YXRlLnBvc2l0aW9uLCB0cnVlKTtcbiAgICAgIHN0YXRlLnBvc2l0aW9uKys7XG4gICAgICByZXR1cm4gdHJ1ZTtcblxuICAgIH0gZWxzZSBpZiAoY2ggPT09IDB4NUMvKiBcXCAqLykge1xuICAgICAgY2FwdHVyZVNlZ21lbnQoc3RhdGUsIGNhcHR1cmVTdGFydCwgc3RhdGUucG9zaXRpb24sIHRydWUpO1xuICAgICAgY2ggPSBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KCsrc3RhdGUucG9zaXRpb24pO1xuXG4gICAgICBpZiAoaXNfRU9MKGNoKSkge1xuICAgICAgICBza2lwU2VwYXJhdGlvblNwYWNlKHN0YXRlLCBmYWxzZSwgbm9kZUluZGVudCk7XG5cbiAgICAgICAgLy8gVE9ETzogcmV3b3JrIHRvIGlubGluZSBmbiB3aXRoIG5vIHR5cGUgY2FzdD9cbiAgICAgIH0gZWxzZSBpZiAoY2ggPCAyNTYgJiYgc2ltcGxlRXNjYXBlQ2hlY2tbY2hdKSB7XG4gICAgICAgIHN0YXRlLnJlc3VsdCArPSBzaW1wbGVFc2NhcGVNYXBbY2hdO1xuICAgICAgICBzdGF0ZS5wb3NpdGlvbisrO1xuXG4gICAgICB9IGVsc2UgaWYgKCh0bXAgPSBlc2NhcGVkSGV4TGVuKGNoKSkgPiAwKSB7XG4gICAgICAgIGhleExlbmd0aCA9IHRtcDtcbiAgICAgICAgaGV4UmVzdWx0ID0gMDtcblxuICAgICAgICBmb3IgKDsgaGV4TGVuZ3RoID4gMDsgaGV4TGVuZ3RoLS0pIHtcbiAgICAgICAgICBjaCA9IHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoKytzdGF0ZS5wb3NpdGlvbik7XG5cbiAgICAgICAgICBpZiAoKHRtcCA9IGZyb21IZXhDb2RlKGNoKSkgPj0gMCkge1xuICAgICAgICAgICAgaGV4UmVzdWx0ID0gKGhleFJlc3VsdCA8PCA0KSArIHRtcDtcblxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aHJvd0Vycm9yKHN0YXRlLCAnZXhwZWN0ZWQgaGV4YWRlY2ltYWwgY2hhcmFjdGVyJyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgc3RhdGUucmVzdWx0ICs9IGNoYXJGcm9tQ29kZXBvaW50KGhleFJlc3VsdCk7XG5cbiAgICAgICAgc3RhdGUucG9zaXRpb24rKztcblxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3dFcnJvcihzdGF0ZSwgJ3Vua25vd24gZXNjYXBlIHNlcXVlbmNlJyk7XG4gICAgICB9XG5cbiAgICAgIGNhcHR1cmVTdGFydCA9IGNhcHR1cmVFbmQgPSBzdGF0ZS5wb3NpdGlvbjtcblxuICAgIH0gZWxzZSBpZiAoaXNfRU9MKGNoKSkge1xuICAgICAgY2FwdHVyZVNlZ21lbnQoc3RhdGUsIGNhcHR1cmVTdGFydCwgY2FwdHVyZUVuZCwgdHJ1ZSk7XG4gICAgICB3cml0ZUZvbGRlZExpbmVzKHN0YXRlLCBza2lwU2VwYXJhdGlvblNwYWNlKHN0YXRlLCBmYWxzZSwgbm9kZUluZGVudCkpO1xuICAgICAgY2FwdHVyZVN0YXJ0ID0gY2FwdHVyZUVuZCA9IHN0YXRlLnBvc2l0aW9uO1xuXG4gICAgfSBlbHNlIGlmIChzdGF0ZS5wb3NpdGlvbiA9PT0gc3RhdGUubGluZVN0YXJ0ICYmIHRlc3REb2N1bWVudFNlcGFyYXRvcihzdGF0ZSkpIHtcbiAgICAgIHRocm93RXJyb3Ioc3RhdGUsICd1bmV4cGVjdGVkIGVuZCBvZiB0aGUgZG9jdW1lbnQgd2l0aGluIGEgZG91YmxlIHF1b3RlZCBzY2FsYXInKTtcblxuICAgIH0gZWxzZSB7XG4gICAgICBzdGF0ZS5wb3NpdGlvbisrO1xuICAgICAgY2FwdHVyZUVuZCA9IHN0YXRlLnBvc2l0aW9uO1xuICAgIH1cbiAgfVxuXG4gIHRocm93RXJyb3Ioc3RhdGUsICd1bmV4cGVjdGVkIGVuZCBvZiB0aGUgc3RyZWFtIHdpdGhpbiBhIGRvdWJsZSBxdW90ZWQgc2NhbGFyJyk7XG59XG5cbmZ1bmN0aW9uIHJlYWRGbG93Q29sbGVjdGlvbihzdGF0ZSwgbm9kZUluZGVudCkge1xuICB2YXIgcmVhZE5leHQgPSB0cnVlLFxuICAgICAgX2xpbmUsXG4gICAgICBfdGFnICAgICA9IHN0YXRlLnRhZyxcbiAgICAgIF9yZXN1bHQsXG4gICAgICBfYW5jaG9yICA9IHN0YXRlLmFuY2hvcixcbiAgICAgIGZvbGxvd2luZyxcbiAgICAgIHRlcm1pbmF0b3IsXG4gICAgICBpc1BhaXIsXG4gICAgICBpc0V4cGxpY2l0UGFpcixcbiAgICAgIGlzTWFwcGluZyxcbiAgICAgIG92ZXJyaWRhYmxlS2V5cyA9IHt9LFxuICAgICAga2V5Tm9kZSxcbiAgICAgIGtleVRhZyxcbiAgICAgIHZhbHVlTm9kZSxcbiAgICAgIGNoO1xuXG4gIGNoID0gc3RhdGUuaW5wdXQuY2hhckNvZGVBdChzdGF0ZS5wb3NpdGlvbik7XG5cbiAgaWYgKGNoID09PSAweDVCLyogWyAqLykge1xuICAgIHRlcm1pbmF0b3IgPSAweDVEOy8qIF0gKi9cbiAgICBpc01hcHBpbmcgPSBmYWxzZTtcbiAgICBfcmVzdWx0ID0gW107XG4gIH0gZWxzZSBpZiAoY2ggPT09IDB4N0IvKiB7ICovKSB7XG4gICAgdGVybWluYXRvciA9IDB4N0Q7LyogfSAqL1xuICAgIGlzTWFwcGluZyA9IHRydWU7XG4gICAgX3Jlc3VsdCA9IHt9O1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGlmIChzdGF0ZS5hbmNob3IgIT09IG51bGwpIHtcbiAgICBzdGF0ZS5hbmNob3JNYXBbc3RhdGUuYW5jaG9yXSA9IF9yZXN1bHQ7XG4gIH1cblxuICBjaCA9IHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoKytzdGF0ZS5wb3NpdGlvbik7XG5cbiAgd2hpbGUgKGNoICE9PSAwKSB7XG4gICAgc2tpcFNlcGFyYXRpb25TcGFjZShzdGF0ZSwgdHJ1ZSwgbm9kZUluZGVudCk7XG5cbiAgICBjaCA9IHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoc3RhdGUucG9zaXRpb24pO1xuXG4gICAgaWYgKGNoID09PSB0ZXJtaW5hdG9yKSB7XG4gICAgICBzdGF0ZS5wb3NpdGlvbisrO1xuICAgICAgc3RhdGUudGFnID0gX3RhZztcbiAgICAgIHN0YXRlLmFuY2hvciA9IF9hbmNob3I7XG4gICAgICBzdGF0ZS5raW5kID0gaXNNYXBwaW5nID8gJ21hcHBpbmcnIDogJ3NlcXVlbmNlJztcbiAgICAgIHN0YXRlLnJlc3VsdCA9IF9yZXN1bHQ7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2UgaWYgKCFyZWFkTmV4dCkge1xuICAgICAgdGhyb3dFcnJvcihzdGF0ZSwgJ21pc3NlZCBjb21tYSBiZXR3ZWVuIGZsb3cgY29sbGVjdGlvbiBlbnRyaWVzJyk7XG4gICAgfVxuXG4gICAga2V5VGFnID0ga2V5Tm9kZSA9IHZhbHVlTm9kZSA9IG51bGw7XG4gICAgaXNQYWlyID0gaXNFeHBsaWNpdFBhaXIgPSBmYWxzZTtcblxuICAgIGlmIChjaCA9PT0gMHgzRi8qID8gKi8pIHtcbiAgICAgIGZvbGxvd2luZyA9IHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoc3RhdGUucG9zaXRpb24gKyAxKTtcblxuICAgICAgaWYgKGlzX1dTX09SX0VPTChmb2xsb3dpbmcpKSB7XG4gICAgICAgIGlzUGFpciA9IGlzRXhwbGljaXRQYWlyID0gdHJ1ZTtcbiAgICAgICAgc3RhdGUucG9zaXRpb24rKztcbiAgICAgICAgc2tpcFNlcGFyYXRpb25TcGFjZShzdGF0ZSwgdHJ1ZSwgbm9kZUluZGVudCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgX2xpbmUgPSBzdGF0ZS5saW5lO1xuICAgIGNvbXBvc2VOb2RlKHN0YXRlLCBub2RlSW5kZW50LCBDT05URVhUX0ZMT1dfSU4sIGZhbHNlLCB0cnVlKTtcbiAgICBrZXlUYWcgPSBzdGF0ZS50YWc7XG4gICAga2V5Tm9kZSA9IHN0YXRlLnJlc3VsdDtcbiAgICBza2lwU2VwYXJhdGlvblNwYWNlKHN0YXRlLCB0cnVlLCBub2RlSW5kZW50KTtcblxuICAgIGNoID0gc3RhdGUuaW5wdXQuY2hhckNvZGVBdChzdGF0ZS5wb3NpdGlvbik7XG5cbiAgICBpZiAoKGlzRXhwbGljaXRQYWlyIHx8IHN0YXRlLmxpbmUgPT09IF9saW5lKSAmJiBjaCA9PT0gMHgzQS8qIDogKi8pIHtcbiAgICAgIGlzUGFpciA9IHRydWU7XG4gICAgICBjaCA9IHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoKytzdGF0ZS5wb3NpdGlvbik7XG4gICAgICBza2lwU2VwYXJhdGlvblNwYWNlKHN0YXRlLCB0cnVlLCBub2RlSW5kZW50KTtcbiAgICAgIGNvbXBvc2VOb2RlKHN0YXRlLCBub2RlSW5kZW50LCBDT05URVhUX0ZMT1dfSU4sIGZhbHNlLCB0cnVlKTtcbiAgICAgIHZhbHVlTm9kZSA9IHN0YXRlLnJlc3VsdDtcbiAgICB9XG5cbiAgICBpZiAoaXNNYXBwaW5nKSB7XG4gICAgICBzdG9yZU1hcHBpbmdQYWlyKHN0YXRlLCBfcmVzdWx0LCBvdmVycmlkYWJsZUtleXMsIGtleVRhZywga2V5Tm9kZSwgdmFsdWVOb2RlKTtcbiAgICB9IGVsc2UgaWYgKGlzUGFpcikge1xuICAgICAgX3Jlc3VsdC5wdXNoKHN0b3JlTWFwcGluZ1BhaXIoc3RhdGUsIG51bGwsIG92ZXJyaWRhYmxlS2V5cywga2V5VGFnLCBrZXlOb2RlLCB2YWx1ZU5vZGUpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgX3Jlc3VsdC5wdXNoKGtleU5vZGUpO1xuICAgIH1cblxuICAgIHNraXBTZXBhcmF0aW9uU3BhY2Uoc3RhdGUsIHRydWUsIG5vZGVJbmRlbnQpO1xuXG4gICAgY2ggPSBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KHN0YXRlLnBvc2l0aW9uKTtcblxuICAgIGlmIChjaCA9PT0gMHgyQy8qICwgKi8pIHtcbiAgICAgIHJlYWROZXh0ID0gdHJ1ZTtcbiAgICAgIGNoID0gc3RhdGUuaW5wdXQuY2hhckNvZGVBdCgrK3N0YXRlLnBvc2l0aW9uKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVhZE5leHQgPSBmYWxzZTtcbiAgICB9XG4gIH1cblxuICB0aHJvd0Vycm9yKHN0YXRlLCAndW5leHBlY3RlZCBlbmQgb2YgdGhlIHN0cmVhbSB3aXRoaW4gYSBmbG93IGNvbGxlY3Rpb24nKTtcbn1cblxuZnVuY3Rpb24gcmVhZEJsb2NrU2NhbGFyKHN0YXRlLCBub2RlSW5kZW50KSB7XG4gIHZhciBjYXB0dXJlU3RhcnQsXG4gICAgICBmb2xkaW5nLFxuICAgICAgY2hvbXBpbmcgICAgICAgPSBDSE9NUElOR19DTElQLFxuICAgICAgZGlkUmVhZENvbnRlbnQgPSBmYWxzZSxcbiAgICAgIGRldGVjdGVkSW5kZW50ID0gZmFsc2UsXG4gICAgICB0ZXh0SW5kZW50ICAgICA9IG5vZGVJbmRlbnQsXG4gICAgICBlbXB0eUxpbmVzICAgICA9IDAsXG4gICAgICBhdE1vcmVJbmRlbnRlZCA9IGZhbHNlLFxuICAgICAgdG1wLFxuICAgICAgY2g7XG5cbiAgY2ggPSBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KHN0YXRlLnBvc2l0aW9uKTtcblxuICBpZiAoY2ggPT09IDB4N0MvKiB8ICovKSB7XG4gICAgZm9sZGluZyA9IGZhbHNlO1xuICB9IGVsc2UgaWYgKGNoID09PSAweDNFLyogPiAqLykge1xuICAgIGZvbGRpbmcgPSB0cnVlO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHN0YXRlLmtpbmQgPSAnc2NhbGFyJztcbiAgc3RhdGUucmVzdWx0ID0gJyc7XG5cbiAgd2hpbGUgKGNoICE9PSAwKSB7XG4gICAgY2ggPSBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KCsrc3RhdGUucG9zaXRpb24pO1xuXG4gICAgaWYgKGNoID09PSAweDJCLyogKyAqLyB8fCBjaCA9PT0gMHgyRC8qIC0gKi8pIHtcbiAgICAgIGlmIChDSE9NUElOR19DTElQID09PSBjaG9tcGluZykge1xuICAgICAgICBjaG9tcGluZyA9IChjaCA9PT0gMHgyQi8qICsgKi8pID8gQ0hPTVBJTkdfS0VFUCA6IENIT01QSU5HX1NUUklQO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3dFcnJvcihzdGF0ZSwgJ3JlcGVhdCBvZiBhIGNob21waW5nIG1vZGUgaWRlbnRpZmllcicpO1xuICAgICAgfVxuXG4gICAgfSBlbHNlIGlmICgodG1wID0gZnJvbURlY2ltYWxDb2RlKGNoKSkgPj0gMCkge1xuICAgICAgaWYgKHRtcCA9PT0gMCkge1xuICAgICAgICB0aHJvd0Vycm9yKHN0YXRlLCAnYmFkIGV4cGxpY2l0IGluZGVudGF0aW9uIHdpZHRoIG9mIGEgYmxvY2sgc2NhbGFyOyBpdCBjYW5ub3QgYmUgbGVzcyB0aGFuIG9uZScpO1xuICAgICAgfSBlbHNlIGlmICghZGV0ZWN0ZWRJbmRlbnQpIHtcbiAgICAgICAgdGV4dEluZGVudCA9IG5vZGVJbmRlbnQgKyB0bXAgLSAxO1xuICAgICAgICBkZXRlY3RlZEluZGVudCA9IHRydWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvd0Vycm9yKHN0YXRlLCAncmVwZWF0IG9mIGFuIGluZGVudGF0aW9uIHdpZHRoIGlkZW50aWZpZXInKTtcbiAgICAgIH1cblxuICAgIH0gZWxzZSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cblxuICBpZiAoaXNfV0hJVEVfU1BBQ0UoY2gpKSB7XG4gICAgZG8geyBjaCA9IHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoKytzdGF0ZS5wb3NpdGlvbik7IH1cbiAgICB3aGlsZSAoaXNfV0hJVEVfU1BBQ0UoY2gpKTtcblxuICAgIGlmIChjaCA9PT0gMHgyMy8qICMgKi8pIHtcbiAgICAgIGRvIHsgY2ggPSBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KCsrc3RhdGUucG9zaXRpb24pOyB9XG4gICAgICB3aGlsZSAoIWlzX0VPTChjaCkgJiYgKGNoICE9PSAwKSk7XG4gICAgfVxuICB9XG5cbiAgd2hpbGUgKGNoICE9PSAwKSB7XG4gICAgcmVhZExpbmVCcmVhayhzdGF0ZSk7XG4gICAgc3RhdGUubGluZUluZGVudCA9IDA7XG5cbiAgICBjaCA9IHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoc3RhdGUucG9zaXRpb24pO1xuXG4gICAgd2hpbGUgKCghZGV0ZWN0ZWRJbmRlbnQgfHwgc3RhdGUubGluZUluZGVudCA8IHRleHRJbmRlbnQpICYmXG4gICAgICAgICAgIChjaCA9PT0gMHgyMC8qIFNwYWNlICovKSkge1xuICAgICAgc3RhdGUubGluZUluZGVudCsrO1xuICAgICAgY2ggPSBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KCsrc3RhdGUucG9zaXRpb24pO1xuICAgIH1cblxuICAgIGlmICghZGV0ZWN0ZWRJbmRlbnQgJiYgc3RhdGUubGluZUluZGVudCA+IHRleHRJbmRlbnQpIHtcbiAgICAgIHRleHRJbmRlbnQgPSBzdGF0ZS5saW5lSW5kZW50O1xuICAgIH1cblxuICAgIGlmIChpc19FT0woY2gpKSB7XG4gICAgICBlbXB0eUxpbmVzKys7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICAvLyBFbmQgb2YgdGhlIHNjYWxhci5cbiAgICBpZiAoc3RhdGUubGluZUluZGVudCA8IHRleHRJbmRlbnQpIHtcblxuICAgICAgLy8gUGVyZm9ybSB0aGUgY2hvbXBpbmcuXG4gICAgICBpZiAoY2hvbXBpbmcgPT09IENIT01QSU5HX0tFRVApIHtcbiAgICAgICAgc3RhdGUucmVzdWx0ICs9IGNvbW1vbi5yZXBlYXQoJ1xcbicsIGRpZFJlYWRDb250ZW50ID8gMSArIGVtcHR5TGluZXMgOiBlbXB0eUxpbmVzKTtcbiAgICAgIH0gZWxzZSBpZiAoY2hvbXBpbmcgPT09IENIT01QSU5HX0NMSVApIHtcbiAgICAgICAgaWYgKGRpZFJlYWRDb250ZW50KSB7IC8vIGkuZS4gb25seSBpZiB0aGUgc2NhbGFyIGlzIG5vdCBlbXB0eS5cbiAgICAgICAgICBzdGF0ZS5yZXN1bHQgKz0gJ1xcbic7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gQnJlYWsgdGhpcyBgd2hpbGVgIGN5Y2xlIGFuZCBnbyB0byB0aGUgZnVuY2l0b24ncyBlcGlsb2d1ZS5cbiAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIC8vIEZvbGRlZCBzdHlsZTogdXNlIGZhbmN5IHJ1bGVzIHRvIGhhbmRsZSBsaW5lIGJyZWFrcy5cbiAgICBpZiAoZm9sZGluZykge1xuXG4gICAgICAvLyBMaW5lcyBzdGFydGluZyB3aXRoIHdoaXRlIHNwYWNlIGNoYXJhY3RlcnMgKG1vcmUtaW5kZW50ZWQgbGluZXMpIGFyZSBub3QgZm9sZGVkLlxuICAgICAgaWYgKGlzX1dISVRFX1NQQUNFKGNoKSkge1xuICAgICAgICBhdE1vcmVJbmRlbnRlZCA9IHRydWU7XG4gICAgICAgIC8vIGV4Y2VwdCBmb3IgdGhlIGZpcnN0IGNvbnRlbnQgbGluZSAoY2YuIEV4YW1wbGUgOC4xKVxuICAgICAgICBzdGF0ZS5yZXN1bHQgKz0gY29tbW9uLnJlcGVhdCgnXFxuJywgZGlkUmVhZENvbnRlbnQgPyAxICsgZW1wdHlMaW5lcyA6IGVtcHR5TGluZXMpO1xuXG4gICAgICAvLyBFbmQgb2YgbW9yZS1pbmRlbnRlZCBibG9jay5cbiAgICAgIH0gZWxzZSBpZiAoYXRNb3JlSW5kZW50ZWQpIHtcbiAgICAgICAgYXRNb3JlSW5kZW50ZWQgPSBmYWxzZTtcbiAgICAgICAgc3RhdGUucmVzdWx0ICs9IGNvbW1vbi5yZXBlYXQoJ1xcbicsIGVtcHR5TGluZXMgKyAxKTtcblxuICAgICAgLy8gSnVzdCBvbmUgbGluZSBicmVhayAtIHBlcmNlaXZlIGFzIHRoZSBzYW1lIGxpbmUuXG4gICAgICB9IGVsc2UgaWYgKGVtcHR5TGluZXMgPT09IDApIHtcbiAgICAgICAgaWYgKGRpZFJlYWRDb250ZW50KSB7IC8vIGkuZS4gb25seSBpZiB3ZSBoYXZlIGFscmVhZHkgcmVhZCBzb21lIHNjYWxhciBjb250ZW50LlxuICAgICAgICAgIHN0YXRlLnJlc3VsdCArPSAnICc7XG4gICAgICAgIH1cblxuICAgICAgLy8gU2V2ZXJhbCBsaW5lIGJyZWFrcyAtIHBlcmNlaXZlIGFzIGRpZmZlcmVudCBsaW5lcy5cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN0YXRlLnJlc3VsdCArPSBjb21tb24ucmVwZWF0KCdcXG4nLCBlbXB0eUxpbmVzKTtcbiAgICAgIH1cblxuICAgIC8vIExpdGVyYWwgc3R5bGU6IGp1c3QgYWRkIGV4YWN0IG51bWJlciBvZiBsaW5lIGJyZWFrcyBiZXR3ZWVuIGNvbnRlbnQgbGluZXMuXG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIEtlZXAgYWxsIGxpbmUgYnJlYWtzIGV4Y2VwdCB0aGUgaGVhZGVyIGxpbmUgYnJlYWsuXG4gICAgICBzdGF0ZS5yZXN1bHQgKz0gY29tbW9uLnJlcGVhdCgnXFxuJywgZGlkUmVhZENvbnRlbnQgPyAxICsgZW1wdHlMaW5lcyA6IGVtcHR5TGluZXMpO1xuICAgIH1cblxuICAgIGRpZFJlYWRDb250ZW50ID0gdHJ1ZTtcbiAgICBkZXRlY3RlZEluZGVudCA9IHRydWU7XG4gICAgZW1wdHlMaW5lcyA9IDA7XG4gICAgY2FwdHVyZVN0YXJ0ID0gc3RhdGUucG9zaXRpb247XG5cbiAgICB3aGlsZSAoIWlzX0VPTChjaCkgJiYgKGNoICE9PSAwKSkge1xuICAgICAgY2ggPSBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KCsrc3RhdGUucG9zaXRpb24pO1xuICAgIH1cblxuICAgIGNhcHR1cmVTZWdtZW50KHN0YXRlLCBjYXB0dXJlU3RhcnQsIHN0YXRlLnBvc2l0aW9uLCBmYWxzZSk7XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gcmVhZEJsb2NrU2VxdWVuY2Uoc3RhdGUsIG5vZGVJbmRlbnQpIHtcbiAgdmFyIF9saW5lLFxuICAgICAgX3RhZyAgICAgID0gc3RhdGUudGFnLFxuICAgICAgX2FuY2hvciAgID0gc3RhdGUuYW5jaG9yLFxuICAgICAgX3Jlc3VsdCAgID0gW10sXG4gICAgICBmb2xsb3dpbmcsXG4gICAgICBkZXRlY3RlZCAgPSBmYWxzZSxcbiAgICAgIGNoO1xuXG4gIGlmIChzdGF0ZS5hbmNob3IgIT09IG51bGwpIHtcbiAgICBzdGF0ZS5hbmNob3JNYXBbc3RhdGUuYW5jaG9yXSA9IF9yZXN1bHQ7XG4gIH1cblxuICBjaCA9IHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoc3RhdGUucG9zaXRpb24pO1xuXG4gIHdoaWxlIChjaCAhPT0gMCkge1xuXG4gICAgaWYgKGNoICE9PSAweDJELyogLSAqLykge1xuICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgZm9sbG93aW5nID0gc3RhdGUuaW5wdXQuY2hhckNvZGVBdChzdGF0ZS5wb3NpdGlvbiArIDEpO1xuXG4gICAgaWYgKCFpc19XU19PUl9FT0woZm9sbG93aW5nKSkge1xuICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgZGV0ZWN0ZWQgPSB0cnVlO1xuICAgIHN0YXRlLnBvc2l0aW9uKys7XG5cbiAgICBpZiAoc2tpcFNlcGFyYXRpb25TcGFjZShzdGF0ZSwgdHJ1ZSwgLTEpKSB7XG4gICAgICBpZiAoc3RhdGUubGluZUluZGVudCA8PSBub2RlSW5kZW50KSB7XG4gICAgICAgIF9yZXN1bHQucHVzaChudWxsKTtcbiAgICAgICAgY2ggPSBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KHN0YXRlLnBvc2l0aW9uKTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgX2xpbmUgPSBzdGF0ZS5saW5lO1xuICAgIGNvbXBvc2VOb2RlKHN0YXRlLCBub2RlSW5kZW50LCBDT05URVhUX0JMT0NLX0lOLCBmYWxzZSwgdHJ1ZSk7XG4gICAgX3Jlc3VsdC5wdXNoKHN0YXRlLnJlc3VsdCk7XG4gICAgc2tpcFNlcGFyYXRpb25TcGFjZShzdGF0ZSwgdHJ1ZSwgLTEpO1xuXG4gICAgY2ggPSBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KHN0YXRlLnBvc2l0aW9uKTtcblxuICAgIGlmICgoc3RhdGUubGluZSA9PT0gX2xpbmUgfHwgc3RhdGUubGluZUluZGVudCA+IG5vZGVJbmRlbnQpICYmIChjaCAhPT0gMCkpIHtcbiAgICAgIHRocm93RXJyb3Ioc3RhdGUsICdiYWQgaW5kZW50YXRpb24gb2YgYSBzZXF1ZW5jZSBlbnRyeScpO1xuICAgIH0gZWxzZSBpZiAoc3RhdGUubGluZUluZGVudCA8IG5vZGVJbmRlbnQpIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuXG4gIGlmIChkZXRlY3RlZCkge1xuICAgIHN0YXRlLnRhZyA9IF90YWc7XG4gICAgc3RhdGUuYW5jaG9yID0gX2FuY2hvcjtcbiAgICBzdGF0ZS5raW5kID0gJ3NlcXVlbmNlJztcbiAgICBzdGF0ZS5yZXN1bHQgPSBfcmVzdWx0O1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gcmVhZEJsb2NrTWFwcGluZyhzdGF0ZSwgbm9kZUluZGVudCwgZmxvd0luZGVudCkge1xuICB2YXIgZm9sbG93aW5nLFxuICAgICAgYWxsb3dDb21wYWN0LFxuICAgICAgX2xpbmUsXG4gICAgICBfcG9zLFxuICAgICAgX3RhZyAgICAgICAgICA9IHN0YXRlLnRhZyxcbiAgICAgIF9hbmNob3IgICAgICAgPSBzdGF0ZS5hbmNob3IsXG4gICAgICBfcmVzdWx0ICAgICAgID0ge30sXG4gICAgICBvdmVycmlkYWJsZUtleXMgPSB7fSxcbiAgICAgIGtleVRhZyAgICAgICAgPSBudWxsLFxuICAgICAga2V5Tm9kZSAgICAgICA9IG51bGwsXG4gICAgICB2YWx1ZU5vZGUgICAgID0gbnVsbCxcbiAgICAgIGF0RXhwbGljaXRLZXkgPSBmYWxzZSxcbiAgICAgIGRldGVjdGVkICAgICAgPSBmYWxzZSxcbiAgICAgIGNoO1xuXG4gIGlmIChzdGF0ZS5hbmNob3IgIT09IG51bGwpIHtcbiAgICBzdGF0ZS5hbmNob3JNYXBbc3RhdGUuYW5jaG9yXSA9IF9yZXN1bHQ7XG4gIH1cblxuICBjaCA9IHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoc3RhdGUucG9zaXRpb24pO1xuXG4gIHdoaWxlIChjaCAhPT0gMCkge1xuICAgIGZvbGxvd2luZyA9IHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoc3RhdGUucG9zaXRpb24gKyAxKTtcbiAgICBfbGluZSA9IHN0YXRlLmxpbmU7IC8vIFNhdmUgdGhlIGN1cnJlbnQgbGluZS5cbiAgICBfcG9zID0gc3RhdGUucG9zaXRpb247XG5cbiAgICAvL1xuICAgIC8vIEV4cGxpY2l0IG5vdGF0aW9uIGNhc2UuIFRoZXJlIGFyZSB0d28gc2VwYXJhdGUgYmxvY2tzOlxuICAgIC8vIGZpcnN0IGZvciB0aGUga2V5IChkZW5vdGVkIGJ5IFwiP1wiKSBhbmQgc2Vjb25kIGZvciB0aGUgdmFsdWUgKGRlbm90ZWQgYnkgXCI6XCIpXG4gICAgLy9cbiAgICBpZiAoKGNoID09PSAweDNGLyogPyAqLyB8fCBjaCA9PT0gMHgzQS8qIDogKi8pICYmIGlzX1dTX09SX0VPTChmb2xsb3dpbmcpKSB7XG5cbiAgICAgIGlmIChjaCA9PT0gMHgzRi8qID8gKi8pIHtcbiAgICAgICAgaWYgKGF0RXhwbGljaXRLZXkpIHtcbiAgICAgICAgICBzdG9yZU1hcHBpbmdQYWlyKHN0YXRlLCBfcmVzdWx0LCBvdmVycmlkYWJsZUtleXMsIGtleVRhZywga2V5Tm9kZSwgbnVsbCk7XG4gICAgICAgICAga2V5VGFnID0ga2V5Tm9kZSA9IHZhbHVlTm9kZSA9IG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICBkZXRlY3RlZCA9IHRydWU7XG4gICAgICAgIGF0RXhwbGljaXRLZXkgPSB0cnVlO1xuICAgICAgICBhbGxvd0NvbXBhY3QgPSB0cnVlO1xuXG4gICAgICB9IGVsc2UgaWYgKGF0RXhwbGljaXRLZXkpIHtcbiAgICAgICAgLy8gaS5lLiAweDNBLyogOiAqLyA9PT0gY2hhcmFjdGVyIGFmdGVyIHRoZSBleHBsaWNpdCBrZXkuXG4gICAgICAgIGF0RXhwbGljaXRLZXkgPSBmYWxzZTtcbiAgICAgICAgYWxsb3dDb21wYWN0ID0gdHJ1ZTtcblxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3dFcnJvcihzdGF0ZSwgJ2luY29tcGxldGUgZXhwbGljaXQgbWFwcGluZyBwYWlyOyBhIGtleSBub2RlIGlzIG1pc3NlZDsgb3IgZm9sbG93ZWQgYnkgYSBub24tdGFidWxhdGVkIGVtcHR5IGxpbmUnKTtcbiAgICAgIH1cblxuICAgICAgc3RhdGUucG9zaXRpb24gKz0gMTtcbiAgICAgIGNoID0gZm9sbG93aW5nO1xuXG4gICAgLy9cbiAgICAvLyBJbXBsaWNpdCBub3RhdGlvbiBjYXNlLiBGbG93LXN0eWxlIG5vZGUgYXMgdGhlIGtleSBmaXJzdCwgdGhlbiBcIjpcIiwgYW5kIHRoZSB2YWx1ZS5cbiAgICAvL1xuICAgIH0gZWxzZSBpZiAoY29tcG9zZU5vZGUoc3RhdGUsIGZsb3dJbmRlbnQsIENPTlRFWFRfRkxPV19PVVQsIGZhbHNlLCB0cnVlKSkge1xuXG4gICAgICBpZiAoc3RhdGUubGluZSA9PT0gX2xpbmUpIHtcbiAgICAgICAgY2ggPSBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KHN0YXRlLnBvc2l0aW9uKTtcblxuICAgICAgICB3aGlsZSAoaXNfV0hJVEVfU1BBQ0UoY2gpKSB7XG4gICAgICAgICAgY2ggPSBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KCsrc3RhdGUucG9zaXRpb24pO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGNoID09PSAweDNBLyogOiAqLykge1xuICAgICAgICAgIGNoID0gc3RhdGUuaW5wdXQuY2hhckNvZGVBdCgrK3N0YXRlLnBvc2l0aW9uKTtcblxuICAgICAgICAgIGlmICghaXNfV1NfT1JfRU9MKGNoKSkge1xuICAgICAgICAgICAgdGhyb3dFcnJvcihzdGF0ZSwgJ2Egd2hpdGVzcGFjZSBjaGFyYWN0ZXIgaXMgZXhwZWN0ZWQgYWZ0ZXIgdGhlIGtleS12YWx1ZSBzZXBhcmF0b3Igd2l0aGluIGEgYmxvY2sgbWFwcGluZycpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChhdEV4cGxpY2l0S2V5KSB7XG4gICAgICAgICAgICBzdG9yZU1hcHBpbmdQYWlyKHN0YXRlLCBfcmVzdWx0LCBvdmVycmlkYWJsZUtleXMsIGtleVRhZywga2V5Tm9kZSwgbnVsbCk7XG4gICAgICAgICAgICBrZXlUYWcgPSBrZXlOb2RlID0gdmFsdWVOb2RlID0gbnVsbDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBkZXRlY3RlZCA9IHRydWU7XG4gICAgICAgICAgYXRFeHBsaWNpdEtleSA9IGZhbHNlO1xuICAgICAgICAgIGFsbG93Q29tcGFjdCA9IGZhbHNlO1xuICAgICAgICAgIGtleVRhZyA9IHN0YXRlLnRhZztcbiAgICAgICAgICBrZXlOb2RlID0gc3RhdGUucmVzdWx0O1xuXG4gICAgICAgIH0gZWxzZSBpZiAoZGV0ZWN0ZWQpIHtcbiAgICAgICAgICB0aHJvd0Vycm9yKHN0YXRlLCAnY2FuIG5vdCByZWFkIGFuIGltcGxpY2l0IG1hcHBpbmcgcGFpcjsgYSBjb2xvbiBpcyBtaXNzZWQnKTtcblxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHN0YXRlLnRhZyA9IF90YWc7XG4gICAgICAgICAgc3RhdGUuYW5jaG9yID0gX2FuY2hvcjtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTsgLy8gS2VlcCB0aGUgcmVzdWx0IG9mIGBjb21wb3NlTm9kZWAuXG4gICAgICAgIH1cblxuICAgICAgfSBlbHNlIGlmIChkZXRlY3RlZCkge1xuICAgICAgICB0aHJvd0Vycm9yKHN0YXRlLCAnY2FuIG5vdCByZWFkIGEgYmxvY2sgbWFwcGluZyBlbnRyeTsgYSBtdWx0aWxpbmUga2V5IG1heSBub3QgYmUgYW4gaW1wbGljaXQga2V5Jyk7XG5cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN0YXRlLnRhZyA9IF90YWc7XG4gICAgICAgIHN0YXRlLmFuY2hvciA9IF9hbmNob3I7XG4gICAgICAgIHJldHVybiB0cnVlOyAvLyBLZWVwIHRoZSByZXN1bHQgb2YgYGNvbXBvc2VOb2RlYC5cbiAgICAgIH1cblxuICAgIH0gZWxzZSB7XG4gICAgICBicmVhazsgLy8gUmVhZGluZyBpcyBkb25lLiBHbyB0byB0aGUgZXBpbG9ndWUuXG4gICAgfVxuXG4gICAgLy9cbiAgICAvLyBDb21tb24gcmVhZGluZyBjb2RlIGZvciBib3RoIGV4cGxpY2l0IGFuZCBpbXBsaWNpdCBub3RhdGlvbnMuXG4gICAgLy9cbiAgICBpZiAoc3RhdGUubGluZSA9PT0gX2xpbmUgfHwgc3RhdGUubGluZUluZGVudCA+IG5vZGVJbmRlbnQpIHtcbiAgICAgIGlmIChjb21wb3NlTm9kZShzdGF0ZSwgbm9kZUluZGVudCwgQ09OVEVYVF9CTE9DS19PVVQsIHRydWUsIGFsbG93Q29tcGFjdCkpIHtcbiAgICAgICAgaWYgKGF0RXhwbGljaXRLZXkpIHtcbiAgICAgICAgICBrZXlOb2RlID0gc3RhdGUucmVzdWx0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhbHVlTm9kZSA9IHN0YXRlLnJlc3VsdDtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoIWF0RXhwbGljaXRLZXkpIHtcbiAgICAgICAgc3RvcmVNYXBwaW5nUGFpcihzdGF0ZSwgX3Jlc3VsdCwgb3ZlcnJpZGFibGVLZXlzLCBrZXlUYWcsIGtleU5vZGUsIHZhbHVlTm9kZSwgX2xpbmUsIF9wb3MpO1xuICAgICAgICBrZXlUYWcgPSBrZXlOb2RlID0gdmFsdWVOb2RlID0gbnVsbDtcbiAgICAgIH1cblxuICAgICAgc2tpcFNlcGFyYXRpb25TcGFjZShzdGF0ZSwgdHJ1ZSwgLTEpO1xuICAgICAgY2ggPSBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KHN0YXRlLnBvc2l0aW9uKTtcbiAgICB9XG5cbiAgICBpZiAoc3RhdGUubGluZUluZGVudCA+IG5vZGVJbmRlbnQgJiYgKGNoICE9PSAwKSkge1xuICAgICAgdGhyb3dFcnJvcihzdGF0ZSwgJ2JhZCBpbmRlbnRhdGlvbiBvZiBhIG1hcHBpbmcgZW50cnknKTtcbiAgICB9IGVsc2UgaWYgKHN0YXRlLmxpbmVJbmRlbnQgPCBub2RlSW5kZW50KSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cblxuICAvL1xuICAvLyBFcGlsb2d1ZS5cbiAgLy9cblxuICAvLyBTcGVjaWFsIGNhc2U6IGxhc3QgbWFwcGluZydzIG5vZGUgY29udGFpbnMgb25seSB0aGUga2V5IGluIGV4cGxpY2l0IG5vdGF0aW9uLlxuICBpZiAoYXRFeHBsaWNpdEtleSkge1xuICAgIHN0b3JlTWFwcGluZ1BhaXIoc3RhdGUsIF9yZXN1bHQsIG92ZXJyaWRhYmxlS2V5cywga2V5VGFnLCBrZXlOb2RlLCBudWxsKTtcbiAgfVxuXG4gIC8vIEV4cG9zZSB0aGUgcmVzdWx0aW5nIG1hcHBpbmcuXG4gIGlmIChkZXRlY3RlZCkge1xuICAgIHN0YXRlLnRhZyA9IF90YWc7XG4gICAgc3RhdGUuYW5jaG9yID0gX2FuY2hvcjtcbiAgICBzdGF0ZS5raW5kID0gJ21hcHBpbmcnO1xuICAgIHN0YXRlLnJlc3VsdCA9IF9yZXN1bHQ7XG4gIH1cblxuICByZXR1cm4gZGV0ZWN0ZWQ7XG59XG5cbmZ1bmN0aW9uIHJlYWRUYWdQcm9wZXJ0eShzdGF0ZSkge1xuICB2YXIgX3Bvc2l0aW9uLFxuICAgICAgaXNWZXJiYXRpbSA9IGZhbHNlLFxuICAgICAgaXNOYW1lZCAgICA9IGZhbHNlLFxuICAgICAgdGFnSGFuZGxlLFxuICAgICAgdGFnTmFtZSxcbiAgICAgIGNoO1xuXG4gIGNoID0gc3RhdGUuaW5wdXQuY2hhckNvZGVBdChzdGF0ZS5wb3NpdGlvbik7XG5cbiAgaWYgKGNoICE9PSAweDIxLyogISAqLykgcmV0dXJuIGZhbHNlO1xuXG4gIGlmIChzdGF0ZS50YWcgIT09IG51bGwpIHtcbiAgICB0aHJvd0Vycm9yKHN0YXRlLCAnZHVwbGljYXRpb24gb2YgYSB0YWcgcHJvcGVydHknKTtcbiAgfVxuXG4gIGNoID0gc3RhdGUuaW5wdXQuY2hhckNvZGVBdCgrK3N0YXRlLnBvc2l0aW9uKTtcblxuICBpZiAoY2ggPT09IDB4M0MvKiA8ICovKSB7XG4gICAgaXNWZXJiYXRpbSA9IHRydWU7XG4gICAgY2ggPSBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KCsrc3RhdGUucG9zaXRpb24pO1xuXG4gIH0gZWxzZSBpZiAoY2ggPT09IDB4MjEvKiAhICovKSB7XG4gICAgaXNOYW1lZCA9IHRydWU7XG4gICAgdGFnSGFuZGxlID0gJyEhJztcbiAgICBjaCA9IHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoKytzdGF0ZS5wb3NpdGlvbik7XG5cbiAgfSBlbHNlIHtcbiAgICB0YWdIYW5kbGUgPSAnISc7XG4gIH1cblxuICBfcG9zaXRpb24gPSBzdGF0ZS5wb3NpdGlvbjtcblxuICBpZiAoaXNWZXJiYXRpbSkge1xuICAgIGRvIHsgY2ggPSBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KCsrc3RhdGUucG9zaXRpb24pOyB9XG4gICAgd2hpbGUgKGNoICE9PSAwICYmIGNoICE9PSAweDNFLyogPiAqLyk7XG5cbiAgICBpZiAoc3RhdGUucG9zaXRpb24gPCBzdGF0ZS5sZW5ndGgpIHtcbiAgICAgIHRhZ05hbWUgPSBzdGF0ZS5pbnB1dC5zbGljZShfcG9zaXRpb24sIHN0YXRlLnBvc2l0aW9uKTtcbiAgICAgIGNoID0gc3RhdGUuaW5wdXQuY2hhckNvZGVBdCgrK3N0YXRlLnBvc2l0aW9uKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3dFcnJvcihzdGF0ZSwgJ3VuZXhwZWN0ZWQgZW5kIG9mIHRoZSBzdHJlYW0gd2l0aGluIGEgdmVyYmF0aW0gdGFnJyk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHdoaWxlIChjaCAhPT0gMCAmJiAhaXNfV1NfT1JfRU9MKGNoKSkge1xuXG4gICAgICBpZiAoY2ggPT09IDB4MjEvKiAhICovKSB7XG4gICAgICAgIGlmICghaXNOYW1lZCkge1xuICAgICAgICAgIHRhZ0hhbmRsZSA9IHN0YXRlLmlucHV0LnNsaWNlKF9wb3NpdGlvbiAtIDEsIHN0YXRlLnBvc2l0aW9uICsgMSk7XG5cbiAgICAgICAgICBpZiAoIVBBVFRFUk5fVEFHX0hBTkRMRS50ZXN0KHRhZ0hhbmRsZSkpIHtcbiAgICAgICAgICAgIHRocm93RXJyb3Ioc3RhdGUsICduYW1lZCB0YWcgaGFuZGxlIGNhbm5vdCBjb250YWluIHN1Y2ggY2hhcmFjdGVycycpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlzTmFtZWQgPSB0cnVlO1xuICAgICAgICAgIF9wb3NpdGlvbiA9IHN0YXRlLnBvc2l0aW9uICsgMTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aHJvd0Vycm9yKHN0YXRlLCAndGFnIHN1ZmZpeCBjYW5ub3QgY29udGFpbiBleGNsYW1hdGlvbiBtYXJrcycpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGNoID0gc3RhdGUuaW5wdXQuY2hhckNvZGVBdCgrK3N0YXRlLnBvc2l0aW9uKTtcbiAgICB9XG5cbiAgICB0YWdOYW1lID0gc3RhdGUuaW5wdXQuc2xpY2UoX3Bvc2l0aW9uLCBzdGF0ZS5wb3NpdGlvbik7XG5cbiAgICBpZiAoUEFUVEVSTl9GTE9XX0lORElDQVRPUlMudGVzdCh0YWdOYW1lKSkge1xuICAgICAgdGhyb3dFcnJvcihzdGF0ZSwgJ3RhZyBzdWZmaXggY2Fubm90IGNvbnRhaW4gZmxvdyBpbmRpY2F0b3IgY2hhcmFjdGVycycpO1xuICAgIH1cbiAgfVxuXG4gIGlmICh0YWdOYW1lICYmICFQQVRURVJOX1RBR19VUkkudGVzdCh0YWdOYW1lKSkge1xuICAgIHRocm93RXJyb3Ioc3RhdGUsICd0YWcgbmFtZSBjYW5ub3QgY29udGFpbiBzdWNoIGNoYXJhY3RlcnM6ICcgKyB0YWdOYW1lKTtcbiAgfVxuXG4gIGlmIChpc1ZlcmJhdGltKSB7XG4gICAgc3RhdGUudGFnID0gdGFnTmFtZTtcblxuICB9IGVsc2UgaWYgKF9oYXNPd25Qcm9wZXJ0eS5jYWxsKHN0YXRlLnRhZ01hcCwgdGFnSGFuZGxlKSkge1xuICAgIHN0YXRlLnRhZyA9IHN0YXRlLnRhZ01hcFt0YWdIYW5kbGVdICsgdGFnTmFtZTtcblxuICB9IGVsc2UgaWYgKHRhZ0hhbmRsZSA9PT0gJyEnKSB7XG4gICAgc3RhdGUudGFnID0gJyEnICsgdGFnTmFtZTtcblxuICB9IGVsc2UgaWYgKHRhZ0hhbmRsZSA9PT0gJyEhJykge1xuICAgIHN0YXRlLnRhZyA9ICd0YWc6eWFtbC5vcmcsMjAwMjonICsgdGFnTmFtZTtcblxuICB9IGVsc2Uge1xuICAgIHRocm93RXJyb3Ioc3RhdGUsICd1bmRlY2xhcmVkIHRhZyBoYW5kbGUgXCInICsgdGFnSGFuZGxlICsgJ1wiJyk7XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gcmVhZEFuY2hvclByb3BlcnR5KHN0YXRlKSB7XG4gIHZhciBfcG9zaXRpb24sXG4gICAgICBjaDtcblxuICBjaCA9IHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoc3RhdGUucG9zaXRpb24pO1xuXG4gIGlmIChjaCAhPT0gMHgyNi8qICYgKi8pIHJldHVybiBmYWxzZTtcblxuICBpZiAoc3RhdGUuYW5jaG9yICE9PSBudWxsKSB7XG4gICAgdGhyb3dFcnJvcihzdGF0ZSwgJ2R1cGxpY2F0aW9uIG9mIGFuIGFuY2hvciBwcm9wZXJ0eScpO1xuICB9XG5cbiAgY2ggPSBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KCsrc3RhdGUucG9zaXRpb24pO1xuICBfcG9zaXRpb24gPSBzdGF0ZS5wb3NpdGlvbjtcblxuICB3aGlsZSAoY2ggIT09IDAgJiYgIWlzX1dTX09SX0VPTChjaCkgJiYgIWlzX0ZMT1dfSU5ESUNBVE9SKGNoKSkge1xuICAgIGNoID0gc3RhdGUuaW5wdXQuY2hhckNvZGVBdCgrK3N0YXRlLnBvc2l0aW9uKTtcbiAgfVxuXG4gIGlmIChzdGF0ZS5wb3NpdGlvbiA9PT0gX3Bvc2l0aW9uKSB7XG4gICAgdGhyb3dFcnJvcihzdGF0ZSwgJ25hbWUgb2YgYW4gYW5jaG9yIG5vZGUgbXVzdCBjb250YWluIGF0IGxlYXN0IG9uZSBjaGFyYWN0ZXInKTtcbiAgfVxuXG4gIHN0YXRlLmFuY2hvciA9IHN0YXRlLmlucHV0LnNsaWNlKF9wb3NpdGlvbiwgc3RhdGUucG9zaXRpb24pO1xuICByZXR1cm4gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gcmVhZEFsaWFzKHN0YXRlKSB7XG4gIHZhciBfcG9zaXRpb24sIGFsaWFzLFxuICAgICAgY2g7XG5cbiAgY2ggPSBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KHN0YXRlLnBvc2l0aW9uKTtcblxuICBpZiAoY2ggIT09IDB4MkEvKiAqICovKSByZXR1cm4gZmFsc2U7XG5cbiAgY2ggPSBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KCsrc3RhdGUucG9zaXRpb24pO1xuICBfcG9zaXRpb24gPSBzdGF0ZS5wb3NpdGlvbjtcblxuICB3aGlsZSAoY2ggIT09IDAgJiYgIWlzX1dTX09SX0VPTChjaCkgJiYgIWlzX0ZMT1dfSU5ESUNBVE9SKGNoKSkge1xuICAgIGNoID0gc3RhdGUuaW5wdXQuY2hhckNvZGVBdCgrK3N0YXRlLnBvc2l0aW9uKTtcbiAgfVxuXG4gIGlmIChzdGF0ZS5wb3NpdGlvbiA9PT0gX3Bvc2l0aW9uKSB7XG4gICAgdGhyb3dFcnJvcihzdGF0ZSwgJ25hbWUgb2YgYW4gYWxpYXMgbm9kZSBtdXN0IGNvbnRhaW4gYXQgbGVhc3Qgb25lIGNoYXJhY3RlcicpO1xuICB9XG5cbiAgYWxpYXMgPSBzdGF0ZS5pbnB1dC5zbGljZShfcG9zaXRpb24sIHN0YXRlLnBvc2l0aW9uKTtcblxuICBpZiAoIXN0YXRlLmFuY2hvck1hcC5oYXNPd25Qcm9wZXJ0eShhbGlhcykpIHtcbiAgICB0aHJvd0Vycm9yKHN0YXRlLCAndW5pZGVudGlmaWVkIGFsaWFzIFwiJyArIGFsaWFzICsgJ1wiJyk7XG4gIH1cblxuICBzdGF0ZS5yZXN1bHQgPSBzdGF0ZS5hbmNob3JNYXBbYWxpYXNdO1xuICBza2lwU2VwYXJhdGlvblNwYWNlKHN0YXRlLCB0cnVlLCAtMSk7XG4gIHJldHVybiB0cnVlO1xufVxuXG5mdW5jdGlvbiBjb21wb3NlTm9kZShzdGF0ZSwgcGFyZW50SW5kZW50LCBub2RlQ29udGV4dCwgYWxsb3dUb1NlZWssIGFsbG93Q29tcGFjdCkge1xuICB2YXIgYWxsb3dCbG9ja1N0eWxlcyxcbiAgICAgIGFsbG93QmxvY2tTY2FsYXJzLFxuICAgICAgYWxsb3dCbG9ja0NvbGxlY3Rpb25zLFxuICAgICAgaW5kZW50U3RhdHVzID0gMSwgLy8gMTogdGhpcz5wYXJlbnQsIDA6IHRoaXM9cGFyZW50LCAtMTogdGhpczxwYXJlbnRcbiAgICAgIGF0TmV3TGluZSAgPSBmYWxzZSxcbiAgICAgIGhhc0NvbnRlbnQgPSBmYWxzZSxcbiAgICAgIHR5cGVJbmRleCxcbiAgICAgIHR5cGVRdWFudGl0eSxcbiAgICAgIHR5cGUsXG4gICAgICBmbG93SW5kZW50LFxuICAgICAgYmxvY2tJbmRlbnQ7XG5cbiAgaWYgKHN0YXRlLmxpc3RlbmVyICE9PSBudWxsKSB7XG4gICAgc3RhdGUubGlzdGVuZXIoJ29wZW4nLCBzdGF0ZSk7XG4gIH1cblxuICBzdGF0ZS50YWcgICAgPSBudWxsO1xuICBzdGF0ZS5hbmNob3IgPSBudWxsO1xuICBzdGF0ZS5raW5kICAgPSBudWxsO1xuICBzdGF0ZS5yZXN1bHQgPSBudWxsO1xuXG4gIGFsbG93QmxvY2tTdHlsZXMgPSBhbGxvd0Jsb2NrU2NhbGFycyA9IGFsbG93QmxvY2tDb2xsZWN0aW9ucyA9XG4gICAgQ09OVEVYVF9CTE9DS19PVVQgPT09IG5vZGVDb250ZXh0IHx8XG4gICAgQ09OVEVYVF9CTE9DS19JTiAgPT09IG5vZGVDb250ZXh0O1xuXG4gIGlmIChhbGxvd1RvU2Vlaykge1xuICAgIGlmIChza2lwU2VwYXJhdGlvblNwYWNlKHN0YXRlLCB0cnVlLCAtMSkpIHtcbiAgICAgIGF0TmV3TGluZSA9IHRydWU7XG5cbiAgICAgIGlmIChzdGF0ZS5saW5lSW5kZW50ID4gcGFyZW50SW5kZW50KSB7XG4gICAgICAgIGluZGVudFN0YXR1cyA9IDE7XG4gICAgICB9IGVsc2UgaWYgKHN0YXRlLmxpbmVJbmRlbnQgPT09IHBhcmVudEluZGVudCkge1xuICAgICAgICBpbmRlbnRTdGF0dXMgPSAwO1xuICAgICAgfSBlbHNlIGlmIChzdGF0ZS5saW5lSW5kZW50IDwgcGFyZW50SW5kZW50KSB7XG4gICAgICAgIGluZGVudFN0YXR1cyA9IC0xO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGlmIChpbmRlbnRTdGF0dXMgPT09IDEpIHtcbiAgICB3aGlsZSAocmVhZFRhZ1Byb3BlcnR5KHN0YXRlKSB8fCByZWFkQW5jaG9yUHJvcGVydHkoc3RhdGUpKSB7XG4gICAgICBpZiAoc2tpcFNlcGFyYXRpb25TcGFjZShzdGF0ZSwgdHJ1ZSwgLTEpKSB7XG4gICAgICAgIGF0TmV3TGluZSA9IHRydWU7XG4gICAgICAgIGFsbG93QmxvY2tDb2xsZWN0aW9ucyA9IGFsbG93QmxvY2tTdHlsZXM7XG5cbiAgICAgICAgaWYgKHN0YXRlLmxpbmVJbmRlbnQgPiBwYXJlbnRJbmRlbnQpIHtcbiAgICAgICAgICBpbmRlbnRTdGF0dXMgPSAxO1xuICAgICAgICB9IGVsc2UgaWYgKHN0YXRlLmxpbmVJbmRlbnQgPT09IHBhcmVudEluZGVudCkge1xuICAgICAgICAgIGluZGVudFN0YXR1cyA9IDA7XG4gICAgICAgIH0gZWxzZSBpZiAoc3RhdGUubGluZUluZGVudCA8IHBhcmVudEluZGVudCkge1xuICAgICAgICAgIGluZGVudFN0YXR1cyA9IC0xO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBhbGxvd0Jsb2NrQ29sbGVjdGlvbnMgPSBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBpZiAoYWxsb3dCbG9ja0NvbGxlY3Rpb25zKSB7XG4gICAgYWxsb3dCbG9ja0NvbGxlY3Rpb25zID0gYXROZXdMaW5lIHx8IGFsbG93Q29tcGFjdDtcbiAgfVxuXG4gIGlmIChpbmRlbnRTdGF0dXMgPT09IDEgfHwgQ09OVEVYVF9CTE9DS19PVVQgPT09IG5vZGVDb250ZXh0KSB7XG4gICAgaWYgKENPTlRFWFRfRkxPV19JTiA9PT0gbm9kZUNvbnRleHQgfHwgQ09OVEVYVF9GTE9XX09VVCA9PT0gbm9kZUNvbnRleHQpIHtcbiAgICAgIGZsb3dJbmRlbnQgPSBwYXJlbnRJbmRlbnQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIGZsb3dJbmRlbnQgPSBwYXJlbnRJbmRlbnQgKyAxO1xuICAgIH1cblxuICAgIGJsb2NrSW5kZW50ID0gc3RhdGUucG9zaXRpb24gLSBzdGF0ZS5saW5lU3RhcnQ7XG5cbiAgICBpZiAoaW5kZW50U3RhdHVzID09PSAxKSB7XG4gICAgICBpZiAoYWxsb3dCbG9ja0NvbGxlY3Rpb25zICYmXG4gICAgICAgICAgKHJlYWRCbG9ja1NlcXVlbmNlKHN0YXRlLCBibG9ja0luZGVudCkgfHxcbiAgICAgICAgICAgcmVhZEJsb2NrTWFwcGluZyhzdGF0ZSwgYmxvY2tJbmRlbnQsIGZsb3dJbmRlbnQpKSB8fFxuICAgICAgICAgIHJlYWRGbG93Q29sbGVjdGlvbihzdGF0ZSwgZmxvd0luZGVudCkpIHtcbiAgICAgICAgaGFzQ29udGVudCA9IHRydWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoKGFsbG93QmxvY2tTY2FsYXJzICYmIHJlYWRCbG9ja1NjYWxhcihzdGF0ZSwgZmxvd0luZGVudCkpIHx8XG4gICAgICAgICAgICByZWFkU2luZ2xlUXVvdGVkU2NhbGFyKHN0YXRlLCBmbG93SW5kZW50KSB8fFxuICAgICAgICAgICAgcmVhZERvdWJsZVF1b3RlZFNjYWxhcihzdGF0ZSwgZmxvd0luZGVudCkpIHtcbiAgICAgICAgICBoYXNDb250ZW50ID0gdHJ1ZTtcblxuICAgICAgICB9IGVsc2UgaWYgKHJlYWRBbGlhcyhzdGF0ZSkpIHtcbiAgICAgICAgICBoYXNDb250ZW50ID0gdHJ1ZTtcblxuICAgICAgICAgIGlmIChzdGF0ZS50YWcgIT09IG51bGwgfHwgc3RhdGUuYW5jaG9yICE9PSBudWxsKSB7XG4gICAgICAgICAgICB0aHJvd0Vycm9yKHN0YXRlLCAnYWxpYXMgbm9kZSBzaG91bGQgbm90IGhhdmUgYW55IHByb3BlcnRpZXMnKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgfSBlbHNlIGlmIChyZWFkUGxhaW5TY2FsYXIoc3RhdGUsIGZsb3dJbmRlbnQsIENPTlRFWFRfRkxPV19JTiA9PT0gbm9kZUNvbnRleHQpKSB7XG4gICAgICAgICAgaGFzQ29udGVudCA9IHRydWU7XG5cbiAgICAgICAgICBpZiAoc3RhdGUudGFnID09PSBudWxsKSB7XG4gICAgICAgICAgICBzdGF0ZS50YWcgPSAnPyc7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHN0YXRlLmFuY2hvciAhPT0gbnVsbCkge1xuICAgICAgICAgIHN0YXRlLmFuY2hvck1hcFtzdGF0ZS5hbmNob3JdID0gc3RhdGUucmVzdWx0O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChpbmRlbnRTdGF0dXMgPT09IDApIHtcbiAgICAgIC8vIFNwZWNpYWwgY2FzZTogYmxvY2sgc2VxdWVuY2VzIGFyZSBhbGxvd2VkIHRvIGhhdmUgc2FtZSBpbmRlbnRhdGlvbiBsZXZlbCBhcyB0aGUgcGFyZW50LlxuICAgICAgLy8gaHR0cDovL3d3dy55YW1sLm9yZy9zcGVjLzEuMi9zcGVjLmh0bWwjaWQyNzk5Nzg0XG4gICAgICBoYXNDb250ZW50ID0gYWxsb3dCbG9ja0NvbGxlY3Rpb25zICYmIHJlYWRCbG9ja1NlcXVlbmNlKHN0YXRlLCBibG9ja0luZGVudCk7XG4gICAgfVxuICB9XG5cbiAgaWYgKHN0YXRlLnRhZyAhPT0gbnVsbCAmJiBzdGF0ZS50YWcgIT09ICchJykge1xuICAgIGlmIChzdGF0ZS50YWcgPT09ICc/Jykge1xuICAgICAgZm9yICh0eXBlSW5kZXggPSAwLCB0eXBlUXVhbnRpdHkgPSBzdGF0ZS5pbXBsaWNpdFR5cGVzLmxlbmd0aDsgdHlwZUluZGV4IDwgdHlwZVF1YW50aXR5OyB0eXBlSW5kZXggKz0gMSkge1xuICAgICAgICB0eXBlID0gc3RhdGUuaW1wbGljaXRUeXBlc1t0eXBlSW5kZXhdO1xuXG4gICAgICAgIC8vIEltcGxpY2l0IHJlc29sdmluZyBpcyBub3QgYWxsb3dlZCBmb3Igbm9uLXNjYWxhciB0eXBlcywgYW5kICc/J1xuICAgICAgICAvLyBub24tc3BlY2lmaWMgdGFnIGlzIG9ubHkgYXNzaWduZWQgdG8gcGxhaW4gc2NhbGFycy4gU28sIGl0IGlzbid0XG4gICAgICAgIC8vIG5lZWRlZCB0byBjaGVjayBmb3IgJ2tpbmQnIGNvbmZvcm1pdHkuXG5cbiAgICAgICAgaWYgKHR5cGUucmVzb2x2ZShzdGF0ZS5yZXN1bHQpKSB7IC8vIGBzdGF0ZS5yZXN1bHRgIHVwZGF0ZWQgaW4gcmVzb2x2ZXIgaWYgbWF0Y2hlZFxuICAgICAgICAgIHN0YXRlLnJlc3VsdCA9IHR5cGUuY29uc3RydWN0KHN0YXRlLnJlc3VsdCk7XG4gICAgICAgICAgc3RhdGUudGFnID0gdHlwZS50YWc7XG4gICAgICAgICAgaWYgKHN0YXRlLmFuY2hvciAhPT0gbnVsbCkge1xuICAgICAgICAgICAgc3RhdGUuYW5jaG9yTWFwW3N0YXRlLmFuY2hvcl0gPSBzdGF0ZS5yZXN1bHQ7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChfaGFzT3duUHJvcGVydHkuY2FsbChzdGF0ZS50eXBlTWFwW3N0YXRlLmtpbmQgfHwgJ2ZhbGxiYWNrJ10sIHN0YXRlLnRhZykpIHtcbiAgICAgIHR5cGUgPSBzdGF0ZS50eXBlTWFwW3N0YXRlLmtpbmQgfHwgJ2ZhbGxiYWNrJ11bc3RhdGUudGFnXTtcblxuICAgICAgaWYgKHN0YXRlLnJlc3VsdCAhPT0gbnVsbCAmJiB0eXBlLmtpbmQgIT09IHN0YXRlLmtpbmQpIHtcbiAgICAgICAgdGhyb3dFcnJvcihzdGF0ZSwgJ3VuYWNjZXB0YWJsZSBub2RlIGtpbmQgZm9yICE8JyArIHN0YXRlLnRhZyArICc+IHRhZzsgaXQgc2hvdWxkIGJlIFwiJyArIHR5cGUua2luZCArICdcIiwgbm90IFwiJyArIHN0YXRlLmtpbmQgKyAnXCInKTtcbiAgICAgIH1cblxuICAgICAgaWYgKCF0eXBlLnJlc29sdmUoc3RhdGUucmVzdWx0KSkgeyAvLyBgc3RhdGUucmVzdWx0YCB1cGRhdGVkIGluIHJlc29sdmVyIGlmIG1hdGNoZWRcbiAgICAgICAgdGhyb3dFcnJvcihzdGF0ZSwgJ2Nhbm5vdCByZXNvbHZlIGEgbm9kZSB3aXRoICE8JyArIHN0YXRlLnRhZyArICc+IGV4cGxpY2l0IHRhZycpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3RhdGUucmVzdWx0ID0gdHlwZS5jb25zdHJ1Y3Qoc3RhdGUucmVzdWx0KTtcbiAgICAgICAgaWYgKHN0YXRlLmFuY2hvciAhPT0gbnVsbCkge1xuICAgICAgICAgIHN0YXRlLmFuY2hvck1hcFtzdGF0ZS5hbmNob3JdID0gc3RhdGUucmVzdWx0O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93RXJyb3Ioc3RhdGUsICd1bmtub3duIHRhZyAhPCcgKyBzdGF0ZS50YWcgKyAnPicpO1xuICAgIH1cbiAgfVxuXG4gIGlmIChzdGF0ZS5saXN0ZW5lciAhPT0gbnVsbCkge1xuICAgIHN0YXRlLmxpc3RlbmVyKCdjbG9zZScsIHN0YXRlKTtcbiAgfVxuICByZXR1cm4gc3RhdGUudGFnICE9PSBudWxsIHx8ICBzdGF0ZS5hbmNob3IgIT09IG51bGwgfHwgaGFzQ29udGVudDtcbn1cblxuZnVuY3Rpb24gcmVhZERvY3VtZW50KHN0YXRlKSB7XG4gIHZhciBkb2N1bWVudFN0YXJ0ID0gc3RhdGUucG9zaXRpb24sXG4gICAgICBfcG9zaXRpb24sXG4gICAgICBkaXJlY3RpdmVOYW1lLFxuICAgICAgZGlyZWN0aXZlQXJncyxcbiAgICAgIGhhc0RpcmVjdGl2ZXMgPSBmYWxzZSxcbiAgICAgIGNoO1xuXG4gIHN0YXRlLnZlcnNpb24gPSBudWxsO1xuICBzdGF0ZS5jaGVja0xpbmVCcmVha3MgPSBzdGF0ZS5sZWdhY3k7XG4gIHN0YXRlLnRhZ01hcCA9IHt9O1xuICBzdGF0ZS5hbmNob3JNYXAgPSB7fTtcblxuICB3aGlsZSAoKGNoID0gc3RhdGUuaW5wdXQuY2hhckNvZGVBdChzdGF0ZS5wb3NpdGlvbikpICE9PSAwKSB7XG4gICAgc2tpcFNlcGFyYXRpb25TcGFjZShzdGF0ZSwgdHJ1ZSwgLTEpO1xuXG4gICAgY2ggPSBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KHN0YXRlLnBvc2l0aW9uKTtcblxuICAgIGlmIChzdGF0ZS5saW5lSW5kZW50ID4gMCB8fCBjaCAhPT0gMHgyNS8qICUgKi8pIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIGhhc0RpcmVjdGl2ZXMgPSB0cnVlO1xuICAgIGNoID0gc3RhdGUuaW5wdXQuY2hhckNvZGVBdCgrK3N0YXRlLnBvc2l0aW9uKTtcbiAgICBfcG9zaXRpb24gPSBzdGF0ZS5wb3NpdGlvbjtcblxuICAgIHdoaWxlIChjaCAhPT0gMCAmJiAhaXNfV1NfT1JfRU9MKGNoKSkge1xuICAgICAgY2ggPSBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KCsrc3RhdGUucG9zaXRpb24pO1xuICAgIH1cblxuICAgIGRpcmVjdGl2ZU5hbWUgPSBzdGF0ZS5pbnB1dC5zbGljZShfcG9zaXRpb24sIHN0YXRlLnBvc2l0aW9uKTtcbiAgICBkaXJlY3RpdmVBcmdzID0gW107XG5cbiAgICBpZiAoZGlyZWN0aXZlTmFtZS5sZW5ndGggPCAxKSB7XG4gICAgICB0aHJvd0Vycm9yKHN0YXRlLCAnZGlyZWN0aXZlIG5hbWUgbXVzdCBub3QgYmUgbGVzcyB0aGFuIG9uZSBjaGFyYWN0ZXIgaW4gbGVuZ3RoJyk7XG4gICAgfVxuXG4gICAgd2hpbGUgKGNoICE9PSAwKSB7XG4gICAgICB3aGlsZSAoaXNfV0hJVEVfU1BBQ0UoY2gpKSB7XG4gICAgICAgIGNoID0gc3RhdGUuaW5wdXQuY2hhckNvZGVBdCgrK3N0YXRlLnBvc2l0aW9uKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGNoID09PSAweDIzLyogIyAqLykge1xuICAgICAgICBkbyB7IGNoID0gc3RhdGUuaW5wdXQuY2hhckNvZGVBdCgrK3N0YXRlLnBvc2l0aW9uKTsgfVxuICAgICAgICB3aGlsZSAoY2ggIT09IDAgJiYgIWlzX0VPTChjaCkpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgICAgaWYgKGlzX0VPTChjaCkpIGJyZWFrO1xuXG4gICAgICBfcG9zaXRpb24gPSBzdGF0ZS5wb3NpdGlvbjtcblxuICAgICAgd2hpbGUgKGNoICE9PSAwICYmICFpc19XU19PUl9FT0woY2gpKSB7XG4gICAgICAgIGNoID0gc3RhdGUuaW5wdXQuY2hhckNvZGVBdCgrK3N0YXRlLnBvc2l0aW9uKTtcbiAgICAgIH1cblxuICAgICAgZGlyZWN0aXZlQXJncy5wdXNoKHN0YXRlLmlucHV0LnNsaWNlKF9wb3NpdGlvbiwgc3RhdGUucG9zaXRpb24pKTtcbiAgICB9XG5cbiAgICBpZiAoY2ggIT09IDApIHJlYWRMaW5lQnJlYWsoc3RhdGUpO1xuXG4gICAgaWYgKF9oYXNPd25Qcm9wZXJ0eS5jYWxsKGRpcmVjdGl2ZUhhbmRsZXJzLCBkaXJlY3RpdmVOYW1lKSkge1xuICAgICAgZGlyZWN0aXZlSGFuZGxlcnNbZGlyZWN0aXZlTmFtZV0oc3RhdGUsIGRpcmVjdGl2ZU5hbWUsIGRpcmVjdGl2ZUFyZ3MpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvd1dhcm5pbmcoc3RhdGUsICd1bmtub3duIGRvY3VtZW50IGRpcmVjdGl2ZSBcIicgKyBkaXJlY3RpdmVOYW1lICsgJ1wiJyk7XG4gICAgfVxuICB9XG5cbiAgc2tpcFNlcGFyYXRpb25TcGFjZShzdGF0ZSwgdHJ1ZSwgLTEpO1xuXG4gIGlmIChzdGF0ZS5saW5lSW5kZW50ID09PSAwICYmXG4gICAgICBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KHN0YXRlLnBvc2l0aW9uKSAgICAgPT09IDB4MkQvKiAtICovICYmXG4gICAgICBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KHN0YXRlLnBvc2l0aW9uICsgMSkgPT09IDB4MkQvKiAtICovICYmXG4gICAgICBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KHN0YXRlLnBvc2l0aW9uICsgMikgPT09IDB4MkQvKiAtICovKSB7XG4gICAgc3RhdGUucG9zaXRpb24gKz0gMztcbiAgICBza2lwU2VwYXJhdGlvblNwYWNlKHN0YXRlLCB0cnVlLCAtMSk7XG5cbiAgfSBlbHNlIGlmIChoYXNEaXJlY3RpdmVzKSB7XG4gICAgdGhyb3dFcnJvcihzdGF0ZSwgJ2RpcmVjdGl2ZXMgZW5kIG1hcmsgaXMgZXhwZWN0ZWQnKTtcbiAgfVxuXG4gIGNvbXBvc2VOb2RlKHN0YXRlLCBzdGF0ZS5saW5lSW5kZW50IC0gMSwgQ09OVEVYVF9CTE9DS19PVVQsIGZhbHNlLCB0cnVlKTtcbiAgc2tpcFNlcGFyYXRpb25TcGFjZShzdGF0ZSwgdHJ1ZSwgLTEpO1xuXG4gIGlmIChzdGF0ZS5jaGVja0xpbmVCcmVha3MgJiZcbiAgICAgIFBBVFRFUk5fTk9OX0FTQ0lJX0xJTkVfQlJFQUtTLnRlc3Qoc3RhdGUuaW5wdXQuc2xpY2UoZG9jdW1lbnRTdGFydCwgc3RhdGUucG9zaXRpb24pKSkge1xuICAgIHRocm93V2FybmluZyhzdGF0ZSwgJ25vbi1BU0NJSSBsaW5lIGJyZWFrcyBhcmUgaW50ZXJwcmV0ZWQgYXMgY29udGVudCcpO1xuICB9XG5cbiAgc3RhdGUuZG9jdW1lbnRzLnB1c2goc3RhdGUucmVzdWx0KTtcblxuICBpZiAoc3RhdGUucG9zaXRpb24gPT09IHN0YXRlLmxpbmVTdGFydCAmJiB0ZXN0RG9jdW1lbnRTZXBhcmF0b3Ioc3RhdGUpKSB7XG5cbiAgICBpZiAoc3RhdGUuaW5wdXQuY2hhckNvZGVBdChzdGF0ZS5wb3NpdGlvbikgPT09IDB4MkUvKiAuICovKSB7XG4gICAgICBzdGF0ZS5wb3NpdGlvbiArPSAzO1xuICAgICAgc2tpcFNlcGFyYXRpb25TcGFjZShzdGF0ZSwgdHJ1ZSwgLTEpO1xuICAgIH1cbiAgICByZXR1cm47XG4gIH1cblxuICBpZiAoc3RhdGUucG9zaXRpb24gPCAoc3RhdGUubGVuZ3RoIC0gMSkpIHtcbiAgICB0aHJvd0Vycm9yKHN0YXRlLCAnZW5kIG9mIHRoZSBzdHJlYW0gb3IgYSBkb2N1bWVudCBzZXBhcmF0b3IgaXMgZXhwZWN0ZWQnKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm47XG4gIH1cbn1cblxuXG5mdW5jdGlvbiBsb2FkRG9jdW1lbnRzKGlucHV0LCBvcHRpb25zKSB7XG4gIGlucHV0ID0gU3RyaW5nKGlucHV0KTtcbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgaWYgKGlucHV0Lmxlbmd0aCAhPT0gMCkge1xuXG4gICAgLy8gQWRkIHRhaWxpbmcgYFxcbmAgaWYgbm90IGV4aXN0c1xuICAgIGlmIChpbnB1dC5jaGFyQ29kZUF0KGlucHV0Lmxlbmd0aCAtIDEpICE9PSAweDBBLyogTEYgKi8gJiZcbiAgICAgICAgaW5wdXQuY2hhckNvZGVBdChpbnB1dC5sZW5ndGggLSAxKSAhPT0gMHgwRC8qIENSICovKSB7XG4gICAgICBpbnB1dCArPSAnXFxuJztcbiAgICB9XG5cbiAgICAvLyBTdHJpcCBCT01cbiAgICBpZiAoaW5wdXQuY2hhckNvZGVBdCgwKSA9PT0gMHhGRUZGKSB7XG4gICAgICBpbnB1dCA9IGlucHV0LnNsaWNlKDEpO1xuICAgIH1cbiAgfVxuXG4gIHZhciBzdGF0ZSA9IG5ldyBTdGF0ZShpbnB1dCwgb3B0aW9ucyk7XG5cbiAgLy8gVXNlIDAgYXMgc3RyaW5nIHRlcm1pbmF0b3IuIFRoYXQgc2lnbmlmaWNhbnRseSBzaW1wbGlmaWVzIGJvdW5kcyBjaGVjay5cbiAgc3RhdGUuaW5wdXQgKz0gJ1xcMCc7XG5cbiAgd2hpbGUgKHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoc3RhdGUucG9zaXRpb24pID09PSAweDIwLyogU3BhY2UgKi8pIHtcbiAgICBzdGF0ZS5saW5lSW5kZW50ICs9IDE7XG4gICAgc3RhdGUucG9zaXRpb24gKz0gMTtcbiAgfVxuXG4gIHdoaWxlIChzdGF0ZS5wb3NpdGlvbiA8IChzdGF0ZS5sZW5ndGggLSAxKSkge1xuICAgIHJlYWREb2N1bWVudChzdGF0ZSk7XG4gIH1cblxuICByZXR1cm4gc3RhdGUuZG9jdW1lbnRzO1xufVxuXG5cbmZ1bmN0aW9uIGxvYWRBbGwoaW5wdXQsIGl0ZXJhdG9yLCBvcHRpb25zKSB7XG4gIHZhciBkb2N1bWVudHMgPSBsb2FkRG9jdW1lbnRzKGlucHV0LCBvcHRpb25zKSwgaW5kZXgsIGxlbmd0aDtcblxuICBpZiAodHlwZW9mIGl0ZXJhdG9yICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIGRvY3VtZW50cztcbiAgfVxuXG4gIGZvciAoaW5kZXggPSAwLCBsZW5ndGggPSBkb2N1bWVudHMubGVuZ3RoOyBpbmRleCA8IGxlbmd0aDsgaW5kZXggKz0gMSkge1xuICAgIGl0ZXJhdG9yKGRvY3VtZW50c1tpbmRleF0pO1xuICB9XG59XG5cblxuZnVuY3Rpb24gbG9hZChpbnB1dCwgb3B0aW9ucykge1xuICB2YXIgZG9jdW1lbnRzID0gbG9hZERvY3VtZW50cyhpbnB1dCwgb3B0aW9ucyk7XG5cbiAgaWYgKGRvY3VtZW50cy5sZW5ndGggPT09IDApIHtcbiAgICAvKmVzbGludC1kaXNhYmxlIG5vLXVuZGVmaW5lZCovXG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfSBlbHNlIGlmIChkb2N1bWVudHMubGVuZ3RoID09PSAxKSB7XG4gICAgcmV0dXJuIGRvY3VtZW50c1swXTtcbiAgfVxuICB0aHJvdyBuZXcgWUFNTEV4Y2VwdGlvbignZXhwZWN0ZWQgYSBzaW5nbGUgZG9jdW1lbnQgaW4gdGhlIHN0cmVhbSwgYnV0IGZvdW5kIG1vcmUnKTtcbn1cblxuXG5mdW5jdGlvbiBzYWZlTG9hZEFsbChpbnB1dCwgb3V0cHV0LCBvcHRpb25zKSB7XG4gIGlmICh0eXBlb2Ygb3V0cHV0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgbG9hZEFsbChpbnB1dCwgb3V0cHV0LCBjb21tb24uZXh0ZW5kKHsgc2NoZW1hOiBERUZBVUxUX1NBRkVfU0NIRU1BIH0sIG9wdGlvbnMpKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gbG9hZEFsbChpbnB1dCwgY29tbW9uLmV4dGVuZCh7IHNjaGVtYTogREVGQVVMVF9TQUZFX1NDSEVNQSB9LCBvcHRpb25zKSk7XG4gIH1cbn1cblxuXG5mdW5jdGlvbiBzYWZlTG9hZChpbnB1dCwgb3B0aW9ucykge1xuICByZXR1cm4gbG9hZChpbnB1dCwgY29tbW9uLmV4dGVuZCh7IHNjaGVtYTogREVGQVVMVF9TQUZFX1NDSEVNQSB9LCBvcHRpb25zKSk7XG59XG5cblxubW9kdWxlLmV4cG9ydHMubG9hZEFsbCAgICAgPSBsb2FkQWxsO1xubW9kdWxlLmV4cG9ydHMubG9hZCAgICAgICAgPSBsb2FkO1xubW9kdWxlLmV4cG9ydHMuc2FmZUxvYWRBbGwgPSBzYWZlTG9hZEFsbDtcbm1vZHVsZS5leHBvcnRzLnNhZmVMb2FkICAgID0gc2FmZUxvYWQ7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvanMteWFtbC9saWIvanMteWFtbC9sb2FkZXIuanMiLCIndXNlIHN0cmljdCc7XG5cblxudmFyIGNvbW1vbiA9IHJlcXVpcmUoJy4vY29tbW9uJyk7XG5cblxuZnVuY3Rpb24gTWFyayhuYW1lLCBidWZmZXIsIHBvc2l0aW9uLCBsaW5lLCBjb2x1bW4pIHtcbiAgdGhpcy5uYW1lICAgICA9IG5hbWU7XG4gIHRoaXMuYnVmZmVyICAgPSBidWZmZXI7XG4gIHRoaXMucG9zaXRpb24gPSBwb3NpdGlvbjtcbiAgdGhpcy5saW5lICAgICA9IGxpbmU7XG4gIHRoaXMuY29sdW1uICAgPSBjb2x1bW47XG59XG5cblxuTWFyay5wcm90b3R5cGUuZ2V0U25pcHBldCA9IGZ1bmN0aW9uIGdldFNuaXBwZXQoaW5kZW50LCBtYXhMZW5ndGgpIHtcbiAgdmFyIGhlYWQsIHN0YXJ0LCB0YWlsLCBlbmQsIHNuaXBwZXQ7XG5cbiAgaWYgKCF0aGlzLmJ1ZmZlcikgcmV0dXJuIG51bGw7XG5cbiAgaW5kZW50ID0gaW5kZW50IHx8IDQ7XG4gIG1heExlbmd0aCA9IG1heExlbmd0aCB8fCA3NTtcblxuICBoZWFkID0gJyc7XG4gIHN0YXJ0ID0gdGhpcy5wb3NpdGlvbjtcblxuICB3aGlsZSAoc3RhcnQgPiAwICYmICdcXHgwMFxcclxcblxceDg1XFx1MjAyOFxcdTIwMjknLmluZGV4T2YodGhpcy5idWZmZXIuY2hhckF0KHN0YXJ0IC0gMSkpID09PSAtMSkge1xuICAgIHN0YXJ0IC09IDE7XG4gICAgaWYgKHRoaXMucG9zaXRpb24gLSBzdGFydCA+IChtYXhMZW5ndGggLyAyIC0gMSkpIHtcbiAgICAgIGhlYWQgPSAnIC4uLiAnO1xuICAgICAgc3RhcnQgKz0gNTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuXG4gIHRhaWwgPSAnJztcbiAgZW5kID0gdGhpcy5wb3NpdGlvbjtcblxuICB3aGlsZSAoZW5kIDwgdGhpcy5idWZmZXIubGVuZ3RoICYmICdcXHgwMFxcclxcblxceDg1XFx1MjAyOFxcdTIwMjknLmluZGV4T2YodGhpcy5idWZmZXIuY2hhckF0KGVuZCkpID09PSAtMSkge1xuICAgIGVuZCArPSAxO1xuICAgIGlmIChlbmQgLSB0aGlzLnBvc2l0aW9uID4gKG1heExlbmd0aCAvIDIgLSAxKSkge1xuICAgICAgdGFpbCA9ICcgLi4uICc7XG4gICAgICBlbmQgLT0gNTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuXG4gIHNuaXBwZXQgPSB0aGlzLmJ1ZmZlci5zbGljZShzdGFydCwgZW5kKTtcblxuICByZXR1cm4gY29tbW9uLnJlcGVhdCgnICcsIGluZGVudCkgKyBoZWFkICsgc25pcHBldCArIHRhaWwgKyAnXFxuJyArXG4gICAgICAgICBjb21tb24ucmVwZWF0KCcgJywgaW5kZW50ICsgdGhpcy5wb3NpdGlvbiAtIHN0YXJ0ICsgaGVhZC5sZW5ndGgpICsgJ14nO1xufTtcblxuXG5NYXJrLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nKGNvbXBhY3QpIHtcbiAgdmFyIHNuaXBwZXQsIHdoZXJlID0gJyc7XG5cbiAgaWYgKHRoaXMubmFtZSkge1xuICAgIHdoZXJlICs9ICdpbiBcIicgKyB0aGlzLm5hbWUgKyAnXCIgJztcbiAgfVxuXG4gIHdoZXJlICs9ICdhdCBsaW5lICcgKyAodGhpcy5saW5lICsgMSkgKyAnLCBjb2x1bW4gJyArICh0aGlzLmNvbHVtbiArIDEpO1xuXG4gIGlmICghY29tcGFjdCkge1xuICAgIHNuaXBwZXQgPSB0aGlzLmdldFNuaXBwZXQoKTtcblxuICAgIGlmIChzbmlwcGV0KSB7XG4gICAgICB3aGVyZSArPSAnOlxcbicgKyBzbmlwcGV0O1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB3aGVyZTtcbn07XG5cblxubW9kdWxlLmV4cG9ydHMgPSBNYXJrO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2pzLXlhbWwvbGliL2pzLXlhbWwvbWFyay5qcyIsIid1c2Ugc3RyaWN0JztcblxudmFyIFR5cGUgPSByZXF1aXJlKCcuLi90eXBlJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gbmV3IFR5cGUoJ3RhZzp5YW1sLm9yZywyMDAyOnN0cicsIHtcbiAga2luZDogJ3NjYWxhcicsXG4gIGNvbnN0cnVjdDogZnVuY3Rpb24gKGRhdGEpIHsgcmV0dXJuIGRhdGEgIT09IG51bGwgPyBkYXRhIDogJyc7IH1cbn0pO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2pzLXlhbWwvbGliL2pzLXlhbWwvdHlwZS9zdHIuanMiLCIndXNlIHN0cmljdCc7XG5cbnZhciBUeXBlID0gcmVxdWlyZSgnLi4vdHlwZScpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IG5ldyBUeXBlKCd0YWc6eWFtbC5vcmcsMjAwMjpzZXEnLCB7XG4gIGtpbmQ6ICdzZXF1ZW5jZScsXG4gIGNvbnN0cnVjdDogZnVuY3Rpb24gKGRhdGEpIHsgcmV0dXJuIGRhdGEgIT09IG51bGwgPyBkYXRhIDogW107IH1cbn0pO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2pzLXlhbWwvbGliL2pzLXlhbWwvdHlwZS9zZXEuanMiLCIndXNlIHN0cmljdCc7XG5cbnZhciBUeXBlID0gcmVxdWlyZSgnLi4vdHlwZScpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IG5ldyBUeXBlKCd0YWc6eWFtbC5vcmcsMjAwMjptYXAnLCB7XG4gIGtpbmQ6ICdtYXBwaW5nJyxcbiAgY29uc3RydWN0OiBmdW5jdGlvbiAoZGF0YSkgeyByZXR1cm4gZGF0YSAhPT0gbnVsbCA/IGRhdGEgOiB7fTsgfVxufSk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvanMteWFtbC9saWIvanMteWFtbC90eXBlL21hcC5qcyIsIid1c2Ugc3RyaWN0JztcblxudmFyIFR5cGUgPSByZXF1aXJlKCcuLi90eXBlJyk7XG5cbmZ1bmN0aW9uIHJlc29sdmVZYW1sTnVsbChkYXRhKSB7XG4gIGlmIChkYXRhID09PSBudWxsKSByZXR1cm4gdHJ1ZTtcblxuICB2YXIgbWF4ID0gZGF0YS5sZW5ndGg7XG5cbiAgcmV0dXJuIChtYXggPT09IDEgJiYgZGF0YSA9PT0gJ34nKSB8fFxuICAgICAgICAgKG1heCA9PT0gNCAmJiAoZGF0YSA9PT0gJ251bGwnIHx8IGRhdGEgPT09ICdOdWxsJyB8fCBkYXRhID09PSAnTlVMTCcpKTtcbn1cblxuZnVuY3Rpb24gY29uc3RydWN0WWFtbE51bGwoKSB7XG4gIHJldHVybiBudWxsO1xufVxuXG5mdW5jdGlvbiBpc051bGwob2JqZWN0KSB7XG4gIHJldHVybiBvYmplY3QgPT09IG51bGw7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gbmV3IFR5cGUoJ3RhZzp5YW1sLm9yZywyMDAyOm51bGwnLCB7XG4gIGtpbmQ6ICdzY2FsYXInLFxuICByZXNvbHZlOiByZXNvbHZlWWFtbE51bGwsXG4gIGNvbnN0cnVjdDogY29uc3RydWN0WWFtbE51bGwsXG4gIHByZWRpY2F0ZTogaXNOdWxsLFxuICByZXByZXNlbnQ6IHtcbiAgICBjYW5vbmljYWw6IGZ1bmN0aW9uICgpIHsgcmV0dXJuICd+JzsgICAgfSxcbiAgICBsb3dlcmNhc2U6IGZ1bmN0aW9uICgpIHsgcmV0dXJuICdudWxsJzsgfSxcbiAgICB1cHBlcmNhc2U6IGZ1bmN0aW9uICgpIHsgcmV0dXJuICdOVUxMJzsgfSxcbiAgICBjYW1lbGNhc2U6IGZ1bmN0aW9uICgpIHsgcmV0dXJuICdOdWxsJzsgfVxuICB9LFxuICBkZWZhdWx0U3R5bGU6ICdsb3dlcmNhc2UnXG59KTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9qcy15YW1sL2xpYi9qcy15YW1sL3R5cGUvbnVsbC5qcyIsIid1c2Ugc3RyaWN0JztcblxudmFyIFR5cGUgPSByZXF1aXJlKCcuLi90eXBlJyk7XG5cbmZ1bmN0aW9uIHJlc29sdmVZYW1sQm9vbGVhbihkYXRhKSB7XG4gIGlmIChkYXRhID09PSBudWxsKSByZXR1cm4gZmFsc2U7XG5cbiAgdmFyIG1heCA9IGRhdGEubGVuZ3RoO1xuXG4gIHJldHVybiAobWF4ID09PSA0ICYmIChkYXRhID09PSAndHJ1ZScgfHwgZGF0YSA9PT0gJ1RydWUnIHx8IGRhdGEgPT09ICdUUlVFJykpIHx8XG4gICAgICAgICAobWF4ID09PSA1ICYmIChkYXRhID09PSAnZmFsc2UnIHx8IGRhdGEgPT09ICdGYWxzZScgfHwgZGF0YSA9PT0gJ0ZBTFNFJykpO1xufVxuXG5mdW5jdGlvbiBjb25zdHJ1Y3RZYW1sQm9vbGVhbihkYXRhKSB7XG4gIHJldHVybiBkYXRhID09PSAndHJ1ZScgfHxcbiAgICAgICAgIGRhdGEgPT09ICdUcnVlJyB8fFxuICAgICAgICAgZGF0YSA9PT0gJ1RSVUUnO1xufVxuXG5mdW5jdGlvbiBpc0Jvb2xlYW4ob2JqZWN0KSB7XG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwob2JqZWN0KSA9PT0gJ1tvYmplY3QgQm9vbGVhbl0nO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IG5ldyBUeXBlKCd0YWc6eWFtbC5vcmcsMjAwMjpib29sJywge1xuICBraW5kOiAnc2NhbGFyJyxcbiAgcmVzb2x2ZTogcmVzb2x2ZVlhbWxCb29sZWFuLFxuICBjb25zdHJ1Y3Q6IGNvbnN0cnVjdFlhbWxCb29sZWFuLFxuICBwcmVkaWNhdGU6IGlzQm9vbGVhbixcbiAgcmVwcmVzZW50OiB7XG4gICAgbG93ZXJjYXNlOiBmdW5jdGlvbiAob2JqZWN0KSB7IHJldHVybiBvYmplY3QgPyAndHJ1ZScgOiAnZmFsc2UnOyB9LFxuICAgIHVwcGVyY2FzZTogZnVuY3Rpb24gKG9iamVjdCkgeyByZXR1cm4gb2JqZWN0ID8gJ1RSVUUnIDogJ0ZBTFNFJzsgfSxcbiAgICBjYW1lbGNhc2U6IGZ1bmN0aW9uIChvYmplY3QpIHsgcmV0dXJuIG9iamVjdCA/ICdUcnVlJyA6ICdGYWxzZSc7IH1cbiAgfSxcbiAgZGVmYXVsdFN0eWxlOiAnbG93ZXJjYXNlJ1xufSk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvanMteWFtbC9saWIvanMteWFtbC90eXBlL2Jvb2wuanMiLCIndXNlIHN0cmljdCc7XG5cbnZhciBjb21tb24gPSByZXF1aXJlKCcuLi9jb21tb24nKTtcbnZhciBUeXBlICAgPSByZXF1aXJlKCcuLi90eXBlJyk7XG5cbmZ1bmN0aW9uIGlzSGV4Q29kZShjKSB7XG4gIHJldHVybiAoKDB4MzAvKiAwICovIDw9IGMpICYmIChjIDw9IDB4MzkvKiA5ICovKSkgfHxcbiAgICAgICAgICgoMHg0MS8qIEEgKi8gPD0gYykgJiYgKGMgPD0gMHg0Ni8qIEYgKi8pKSB8fFxuICAgICAgICAgKCgweDYxLyogYSAqLyA8PSBjKSAmJiAoYyA8PSAweDY2LyogZiAqLykpO1xufVxuXG5mdW5jdGlvbiBpc09jdENvZGUoYykge1xuICByZXR1cm4gKCgweDMwLyogMCAqLyA8PSBjKSAmJiAoYyA8PSAweDM3LyogNyAqLykpO1xufVxuXG5mdW5jdGlvbiBpc0RlY0NvZGUoYykge1xuICByZXR1cm4gKCgweDMwLyogMCAqLyA8PSBjKSAmJiAoYyA8PSAweDM5LyogOSAqLykpO1xufVxuXG5mdW5jdGlvbiByZXNvbHZlWWFtbEludGVnZXIoZGF0YSkge1xuICBpZiAoZGF0YSA9PT0gbnVsbCkgcmV0dXJuIGZhbHNlO1xuXG4gIHZhciBtYXggPSBkYXRhLmxlbmd0aCxcbiAgICAgIGluZGV4ID0gMCxcbiAgICAgIGhhc0RpZ2l0cyA9IGZhbHNlLFxuICAgICAgY2g7XG5cbiAgaWYgKCFtYXgpIHJldHVybiBmYWxzZTtcblxuICBjaCA9IGRhdGFbaW5kZXhdO1xuXG4gIC8vIHNpZ25cbiAgaWYgKGNoID09PSAnLScgfHwgY2ggPT09ICcrJykge1xuICAgIGNoID0gZGF0YVsrK2luZGV4XTtcbiAgfVxuXG4gIGlmIChjaCA9PT0gJzAnKSB7XG4gICAgLy8gMFxuICAgIGlmIChpbmRleCArIDEgPT09IG1heCkgcmV0dXJuIHRydWU7XG4gICAgY2ggPSBkYXRhWysraW5kZXhdO1xuXG4gICAgLy8gYmFzZSAyLCBiYXNlIDgsIGJhc2UgMTZcblxuICAgIGlmIChjaCA9PT0gJ2InKSB7XG4gICAgICAvLyBiYXNlIDJcbiAgICAgIGluZGV4Kys7XG5cbiAgICAgIGZvciAoOyBpbmRleCA8IG1heDsgaW5kZXgrKykge1xuICAgICAgICBjaCA9IGRhdGFbaW5kZXhdO1xuICAgICAgICBpZiAoY2ggPT09ICdfJykgY29udGludWU7XG4gICAgICAgIGlmIChjaCAhPT0gJzAnICYmIGNoICE9PSAnMScpIHJldHVybiBmYWxzZTtcbiAgICAgICAgaGFzRGlnaXRzID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBoYXNEaWdpdHMgJiYgY2ggIT09ICdfJztcbiAgICB9XG5cblxuICAgIGlmIChjaCA9PT0gJ3gnKSB7XG4gICAgICAvLyBiYXNlIDE2XG4gICAgICBpbmRleCsrO1xuXG4gICAgICBmb3IgKDsgaW5kZXggPCBtYXg7IGluZGV4KyspIHtcbiAgICAgICAgY2ggPSBkYXRhW2luZGV4XTtcbiAgICAgICAgaWYgKGNoID09PSAnXycpIGNvbnRpbnVlO1xuICAgICAgICBpZiAoIWlzSGV4Q29kZShkYXRhLmNoYXJDb2RlQXQoaW5kZXgpKSkgcmV0dXJuIGZhbHNlO1xuICAgICAgICBoYXNEaWdpdHMgPSB0cnVlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGhhc0RpZ2l0cyAmJiBjaCAhPT0gJ18nO1xuICAgIH1cblxuICAgIC8vIGJhc2UgOFxuICAgIGZvciAoOyBpbmRleCA8IG1heDsgaW5kZXgrKykge1xuICAgICAgY2ggPSBkYXRhW2luZGV4XTtcbiAgICAgIGlmIChjaCA9PT0gJ18nKSBjb250aW51ZTtcbiAgICAgIGlmICghaXNPY3RDb2RlKGRhdGEuY2hhckNvZGVBdChpbmRleCkpKSByZXR1cm4gZmFsc2U7XG4gICAgICBoYXNEaWdpdHMgPSB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gaGFzRGlnaXRzICYmIGNoICE9PSAnXyc7XG4gIH1cblxuICAvLyBiYXNlIDEwIChleGNlcHQgMCkgb3IgYmFzZSA2MFxuXG4gIC8vIHZhbHVlIHNob3VsZCBub3Qgc3RhcnQgd2l0aCBgX2A7XG4gIGlmIChjaCA9PT0gJ18nKSByZXR1cm4gZmFsc2U7XG5cbiAgZm9yICg7IGluZGV4IDwgbWF4OyBpbmRleCsrKSB7XG4gICAgY2ggPSBkYXRhW2luZGV4XTtcbiAgICBpZiAoY2ggPT09ICdfJykgY29udGludWU7XG4gICAgaWYgKGNoID09PSAnOicpIGJyZWFrO1xuICAgIGlmICghaXNEZWNDb2RlKGRhdGEuY2hhckNvZGVBdChpbmRleCkpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGhhc0RpZ2l0cyA9IHRydWU7XG4gIH1cblxuICAvLyBTaG91bGQgaGF2ZSBkaWdpdHMgYW5kIHNob3VsZCBub3QgZW5kIHdpdGggYF9gXG4gIGlmICghaGFzRGlnaXRzIHx8IGNoID09PSAnXycpIHJldHVybiBmYWxzZTtcblxuICAvLyBpZiAhYmFzZTYwIC0gZG9uZTtcbiAgaWYgKGNoICE9PSAnOicpIHJldHVybiB0cnVlO1xuXG4gIC8vIGJhc2U2MCBhbG1vc3Qgbm90IHVzZWQsIG5vIG5lZWRzIHRvIG9wdGltaXplXG4gIHJldHVybiAvXig6WzAtNV0/WzAtOV0pKyQvLnRlc3QoZGF0YS5zbGljZShpbmRleCkpO1xufVxuXG5mdW5jdGlvbiBjb25zdHJ1Y3RZYW1sSW50ZWdlcihkYXRhKSB7XG4gIHZhciB2YWx1ZSA9IGRhdGEsIHNpZ24gPSAxLCBjaCwgYmFzZSwgZGlnaXRzID0gW107XG5cbiAgaWYgKHZhbHVlLmluZGV4T2YoJ18nKSAhPT0gLTEpIHtcbiAgICB2YWx1ZSA9IHZhbHVlLnJlcGxhY2UoL18vZywgJycpO1xuICB9XG5cbiAgY2ggPSB2YWx1ZVswXTtcblxuICBpZiAoY2ggPT09ICctJyB8fCBjaCA9PT0gJysnKSB7XG4gICAgaWYgKGNoID09PSAnLScpIHNpZ24gPSAtMTtcbiAgICB2YWx1ZSA9IHZhbHVlLnNsaWNlKDEpO1xuICAgIGNoID0gdmFsdWVbMF07XG4gIH1cblxuICBpZiAodmFsdWUgPT09ICcwJykgcmV0dXJuIDA7XG5cbiAgaWYgKGNoID09PSAnMCcpIHtcbiAgICBpZiAodmFsdWVbMV0gPT09ICdiJykgcmV0dXJuIHNpZ24gKiBwYXJzZUludCh2YWx1ZS5zbGljZSgyKSwgMik7XG4gICAgaWYgKHZhbHVlWzFdID09PSAneCcpIHJldHVybiBzaWduICogcGFyc2VJbnQodmFsdWUsIDE2KTtcbiAgICByZXR1cm4gc2lnbiAqIHBhcnNlSW50KHZhbHVlLCA4KTtcbiAgfVxuXG4gIGlmICh2YWx1ZS5pbmRleE9mKCc6JykgIT09IC0xKSB7XG4gICAgdmFsdWUuc3BsaXQoJzonKS5mb3JFYWNoKGZ1bmN0aW9uICh2KSB7XG4gICAgICBkaWdpdHMudW5zaGlmdChwYXJzZUludCh2LCAxMCkpO1xuICAgIH0pO1xuXG4gICAgdmFsdWUgPSAwO1xuICAgIGJhc2UgPSAxO1xuXG4gICAgZGlnaXRzLmZvckVhY2goZnVuY3Rpb24gKGQpIHtcbiAgICAgIHZhbHVlICs9IChkICogYmFzZSk7XG4gICAgICBiYXNlICo9IDYwO1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIHNpZ24gKiB2YWx1ZTtcblxuICB9XG5cbiAgcmV0dXJuIHNpZ24gKiBwYXJzZUludCh2YWx1ZSwgMTApO1xufVxuXG5mdW5jdGlvbiBpc0ludGVnZXIob2JqZWN0KSB7XG4gIHJldHVybiAoT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG9iamVjdCkpID09PSAnW29iamVjdCBOdW1iZXJdJyAmJlxuICAgICAgICAgKG9iamVjdCAlIDEgPT09IDAgJiYgIWNvbW1vbi5pc05lZ2F0aXZlWmVybyhvYmplY3QpKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBuZXcgVHlwZSgndGFnOnlhbWwub3JnLDIwMDI6aW50Jywge1xuICBraW5kOiAnc2NhbGFyJyxcbiAgcmVzb2x2ZTogcmVzb2x2ZVlhbWxJbnRlZ2VyLFxuICBjb25zdHJ1Y3Q6IGNvbnN0cnVjdFlhbWxJbnRlZ2VyLFxuICBwcmVkaWNhdGU6IGlzSW50ZWdlcixcbiAgcmVwcmVzZW50OiB7XG4gICAgYmluYXJ5OiAgICAgIGZ1bmN0aW9uIChvYmplY3QpIHsgcmV0dXJuICcwYicgKyBvYmplY3QudG9TdHJpbmcoMik7IH0sXG4gICAgb2N0YWw6ICAgICAgIGZ1bmN0aW9uIChvYmplY3QpIHsgcmV0dXJuICcwJyAgKyBvYmplY3QudG9TdHJpbmcoOCk7IH0sXG4gICAgZGVjaW1hbDogICAgIGZ1bmN0aW9uIChvYmplY3QpIHsgcmV0dXJuICAgICAgICBvYmplY3QudG9TdHJpbmcoMTApOyB9LFxuICAgIGhleGFkZWNpbWFsOiBmdW5jdGlvbiAob2JqZWN0KSB7IHJldHVybiAnMHgnICsgb2JqZWN0LnRvU3RyaW5nKDE2KS50b1VwcGVyQ2FzZSgpOyB9XG4gIH0sXG4gIGRlZmF1bHRTdHlsZTogJ2RlY2ltYWwnLFxuICBzdHlsZUFsaWFzZXM6IHtcbiAgICBiaW5hcnk6ICAgICAgWyAyLCAgJ2JpbicgXSxcbiAgICBvY3RhbDogICAgICAgWyA4LCAgJ29jdCcgXSxcbiAgICBkZWNpbWFsOiAgICAgWyAxMCwgJ2RlYycgXSxcbiAgICBoZXhhZGVjaW1hbDogWyAxNiwgJ2hleCcgXVxuICB9XG59KTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9qcy15YW1sL2xpYi9qcy15YW1sL3R5cGUvaW50LmpzIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgY29tbW9uID0gcmVxdWlyZSgnLi4vY29tbW9uJyk7XG52YXIgVHlwZSAgID0gcmVxdWlyZSgnLi4vdHlwZScpO1xuXG52YXIgWUFNTF9GTE9BVF9QQVRURVJOID0gbmV3IFJlZ0V4cChcbiAgLy8gMi41ZTQsIDIuNSBhbmQgaW50ZWdlcnNcbiAgJ14oPzpbLStdPyg/OjB8WzEtOV1bMC05X10qKSg/OlxcXFwuWzAtOV9dKik/KD86W2VFXVstK10/WzAtOV0rKT8nICtcbiAgLy8gLjJlNCwgLjJcbiAgLy8gc3BlY2lhbCBjYXNlLCBzZWVtcyBub3QgZnJvbSBzcGVjXG4gICd8XFxcXC5bMC05X10rKD86W2VFXVstK10/WzAtOV0rKT8nICtcbiAgLy8gMjA6NTlcbiAgJ3xbLStdP1swLTldWzAtOV9dKig/OjpbMC01XT9bMC05XSkrXFxcXC5bMC05X10qJyArXG4gIC8vIC5pbmZcbiAgJ3xbLStdP1xcXFwuKD86aW5mfEluZnxJTkYpJyArXG4gIC8vIC5uYW5cbiAgJ3xcXFxcLig/Om5hbnxOYU58TkFOKSkkJyk7XG5cbmZ1bmN0aW9uIHJlc29sdmVZYW1sRmxvYXQoZGF0YSkge1xuICBpZiAoZGF0YSA9PT0gbnVsbCkgcmV0dXJuIGZhbHNlO1xuXG4gIGlmICghWUFNTF9GTE9BVF9QQVRURVJOLnRlc3QoZGF0YSkgfHxcbiAgICAgIC8vIFF1aWNrIGhhY2sgdG8gbm90IGFsbG93IGludGVnZXJzIGVuZCB3aXRoIGBfYFxuICAgICAgLy8gUHJvYmFibHkgc2hvdWxkIHVwZGF0ZSByZWdleHAgJiBjaGVjayBzcGVlZFxuICAgICAgZGF0YVtkYXRhLmxlbmd0aCAtIDFdID09PSAnXycpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gY29uc3RydWN0WWFtbEZsb2F0KGRhdGEpIHtcbiAgdmFyIHZhbHVlLCBzaWduLCBiYXNlLCBkaWdpdHM7XG5cbiAgdmFsdWUgID0gZGF0YS5yZXBsYWNlKC9fL2csICcnKS50b0xvd2VyQ2FzZSgpO1xuICBzaWduICAgPSB2YWx1ZVswXSA9PT0gJy0nID8gLTEgOiAxO1xuICBkaWdpdHMgPSBbXTtcblxuICBpZiAoJystJy5pbmRleE9mKHZhbHVlWzBdKSA+PSAwKSB7XG4gICAgdmFsdWUgPSB2YWx1ZS5zbGljZSgxKTtcbiAgfVxuXG4gIGlmICh2YWx1ZSA9PT0gJy5pbmYnKSB7XG4gICAgcmV0dXJuIChzaWduID09PSAxKSA/IE51bWJlci5QT1NJVElWRV9JTkZJTklUWSA6IE51bWJlci5ORUdBVElWRV9JTkZJTklUWTtcblxuICB9IGVsc2UgaWYgKHZhbHVlID09PSAnLm5hbicpIHtcbiAgICByZXR1cm4gTmFOO1xuXG4gIH0gZWxzZSBpZiAodmFsdWUuaW5kZXhPZignOicpID49IDApIHtcbiAgICB2YWx1ZS5zcGxpdCgnOicpLmZvckVhY2goZnVuY3Rpb24gKHYpIHtcbiAgICAgIGRpZ2l0cy51bnNoaWZ0KHBhcnNlRmxvYXQodiwgMTApKTtcbiAgICB9KTtcblxuICAgIHZhbHVlID0gMC4wO1xuICAgIGJhc2UgPSAxO1xuXG4gICAgZGlnaXRzLmZvckVhY2goZnVuY3Rpb24gKGQpIHtcbiAgICAgIHZhbHVlICs9IGQgKiBiYXNlO1xuICAgICAgYmFzZSAqPSA2MDtcbiAgICB9KTtcblxuICAgIHJldHVybiBzaWduICogdmFsdWU7XG5cbiAgfVxuICByZXR1cm4gc2lnbiAqIHBhcnNlRmxvYXQodmFsdWUsIDEwKTtcbn1cblxuXG52YXIgU0NJRU5USUZJQ19XSVRIT1VUX0RPVCA9IC9eWy0rXT9bMC05XStlLztcblxuZnVuY3Rpb24gcmVwcmVzZW50WWFtbEZsb2F0KG9iamVjdCwgc3R5bGUpIHtcbiAgdmFyIHJlcztcblxuICBpZiAoaXNOYU4ob2JqZWN0KSkge1xuICAgIHN3aXRjaCAoc3R5bGUpIHtcbiAgICAgIGNhc2UgJ2xvd2VyY2FzZSc6IHJldHVybiAnLm5hbic7XG4gICAgICBjYXNlICd1cHBlcmNhc2UnOiByZXR1cm4gJy5OQU4nO1xuICAgICAgY2FzZSAnY2FtZWxjYXNlJzogcmV0dXJuICcuTmFOJztcbiAgICB9XG4gIH0gZWxzZSBpZiAoTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZID09PSBvYmplY3QpIHtcbiAgICBzd2l0Y2ggKHN0eWxlKSB7XG4gICAgICBjYXNlICdsb3dlcmNhc2UnOiByZXR1cm4gJy5pbmYnO1xuICAgICAgY2FzZSAndXBwZXJjYXNlJzogcmV0dXJuICcuSU5GJztcbiAgICAgIGNhc2UgJ2NhbWVsY2FzZSc6IHJldHVybiAnLkluZic7XG4gICAgfVxuICB9IGVsc2UgaWYgKE51bWJlci5ORUdBVElWRV9JTkZJTklUWSA9PT0gb2JqZWN0KSB7XG4gICAgc3dpdGNoIChzdHlsZSkge1xuICAgICAgY2FzZSAnbG93ZXJjYXNlJzogcmV0dXJuICctLmluZic7XG4gICAgICBjYXNlICd1cHBlcmNhc2UnOiByZXR1cm4gJy0uSU5GJztcbiAgICAgIGNhc2UgJ2NhbWVsY2FzZSc6IHJldHVybiAnLS5JbmYnO1xuICAgIH1cbiAgfSBlbHNlIGlmIChjb21tb24uaXNOZWdhdGl2ZVplcm8ob2JqZWN0KSkge1xuICAgIHJldHVybiAnLTAuMCc7XG4gIH1cblxuICByZXMgPSBvYmplY3QudG9TdHJpbmcoMTApO1xuXG4gIC8vIEpTIHN0cmluZ2lmaWVyIGNhbiBidWlsZCBzY2llbnRpZmljIGZvcm1hdCB3aXRob3V0IGRvdHM6IDVlLTEwMCxcbiAgLy8gd2hpbGUgWUFNTCByZXF1cmVzIGRvdDogNS5lLTEwMC4gRml4IGl0IHdpdGggc2ltcGxlIGhhY2tcblxuICByZXR1cm4gU0NJRU5USUZJQ19XSVRIT1VUX0RPVC50ZXN0KHJlcykgPyByZXMucmVwbGFjZSgnZScsICcuZScpIDogcmVzO1xufVxuXG5mdW5jdGlvbiBpc0Zsb2F0KG9iamVjdCkge1xuICByZXR1cm4gKE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvYmplY3QpID09PSAnW29iamVjdCBOdW1iZXJdJykgJiZcbiAgICAgICAgIChvYmplY3QgJSAxICE9PSAwIHx8IGNvbW1vbi5pc05lZ2F0aXZlWmVybyhvYmplY3QpKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBuZXcgVHlwZSgndGFnOnlhbWwub3JnLDIwMDI6ZmxvYXQnLCB7XG4gIGtpbmQ6ICdzY2FsYXInLFxuICByZXNvbHZlOiByZXNvbHZlWWFtbEZsb2F0LFxuICBjb25zdHJ1Y3Q6IGNvbnN0cnVjdFlhbWxGbG9hdCxcbiAgcHJlZGljYXRlOiBpc0Zsb2F0LFxuICByZXByZXNlbnQ6IHJlcHJlc2VudFlhbWxGbG9hdCxcbiAgZGVmYXVsdFN0eWxlOiAnbG93ZXJjYXNlJ1xufSk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvanMteWFtbC9saWIvanMteWFtbC90eXBlL2Zsb2F0LmpzIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgVHlwZSA9IHJlcXVpcmUoJy4uL3R5cGUnKTtcblxudmFyIFlBTUxfREFURV9SRUdFWFAgPSBuZXcgUmVnRXhwKFxuICAnXihbMC05XVswLTldWzAtOV1bMC05XSknICAgICAgICAgICsgLy8gWzFdIHllYXJcbiAgJy0oWzAtOV1bMC05XSknICAgICAgICAgICAgICAgICAgICArIC8vIFsyXSBtb250aFxuICAnLShbMC05XVswLTldKSQnKTsgICAgICAgICAgICAgICAgICAgLy8gWzNdIGRheVxuXG52YXIgWUFNTF9USU1FU1RBTVBfUkVHRVhQID0gbmV3IFJlZ0V4cChcbiAgJ14oWzAtOV1bMC05XVswLTldWzAtOV0pJyAgICAgICAgICArIC8vIFsxXSB5ZWFyXG4gICctKFswLTldWzAtOV0/KScgICAgICAgICAgICAgICAgICAgKyAvLyBbMl0gbW9udGhcbiAgJy0oWzAtOV1bMC05XT8pJyAgICAgICAgICAgICAgICAgICArIC8vIFszXSBkYXlcbiAgJyg/OltUdF18WyBcXFxcdF0rKScgICAgICAgICAgICAgICAgICsgLy8gLi4uXG4gICcoWzAtOV1bMC05XT8pJyAgICAgICAgICAgICAgICAgICAgKyAvLyBbNF0gaG91clxuICAnOihbMC05XVswLTldKScgICAgICAgICAgICAgICAgICAgICsgLy8gWzVdIG1pbnV0ZVxuICAnOihbMC05XVswLTldKScgICAgICAgICAgICAgICAgICAgICsgLy8gWzZdIHNlY29uZFxuICAnKD86XFxcXC4oWzAtOV0qKSk/JyAgICAgICAgICAgICAgICAgKyAvLyBbN10gZnJhY3Rpb25cbiAgJyg/OlsgXFxcXHRdKihafChbLStdKShbMC05XVswLTldPyknICsgLy8gWzhdIHR6IFs5XSB0el9zaWduIFsxMF0gdHpfaG91clxuICAnKD86OihbMC05XVswLTldKSk/KSk/JCcpOyAgICAgICAgICAgLy8gWzExXSB0el9taW51dGVcblxuZnVuY3Rpb24gcmVzb2x2ZVlhbWxUaW1lc3RhbXAoZGF0YSkge1xuICBpZiAoZGF0YSA9PT0gbnVsbCkgcmV0dXJuIGZhbHNlO1xuICBpZiAoWUFNTF9EQVRFX1JFR0VYUC5leGVjKGRhdGEpICE9PSBudWxsKSByZXR1cm4gdHJ1ZTtcbiAgaWYgKFlBTUxfVElNRVNUQU1QX1JFR0VYUC5leGVjKGRhdGEpICE9PSBudWxsKSByZXR1cm4gdHJ1ZTtcbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBjb25zdHJ1Y3RZYW1sVGltZXN0YW1wKGRhdGEpIHtcbiAgdmFyIG1hdGNoLCB5ZWFyLCBtb250aCwgZGF5LCBob3VyLCBtaW51dGUsIHNlY29uZCwgZnJhY3Rpb24gPSAwLFxuICAgICAgZGVsdGEgPSBudWxsLCB0el9ob3VyLCB0el9taW51dGUsIGRhdGU7XG5cbiAgbWF0Y2ggPSBZQU1MX0RBVEVfUkVHRVhQLmV4ZWMoZGF0YSk7XG4gIGlmIChtYXRjaCA9PT0gbnVsbCkgbWF0Y2ggPSBZQU1MX1RJTUVTVEFNUF9SRUdFWFAuZXhlYyhkYXRhKTtcblxuICBpZiAobWF0Y2ggPT09IG51bGwpIHRocm93IG5ldyBFcnJvcignRGF0ZSByZXNvbHZlIGVycm9yJyk7XG5cbiAgLy8gbWF0Y2g6IFsxXSB5ZWFyIFsyXSBtb250aCBbM10gZGF5XG5cbiAgeWVhciA9ICsobWF0Y2hbMV0pO1xuICBtb250aCA9ICsobWF0Y2hbMl0pIC0gMTsgLy8gSlMgbW9udGggc3RhcnRzIHdpdGggMFxuICBkYXkgPSArKG1hdGNoWzNdKTtcblxuICBpZiAoIW1hdGNoWzRdKSB7IC8vIG5vIGhvdXJcbiAgICByZXR1cm4gbmV3IERhdGUoRGF0ZS5VVEMoeWVhciwgbW9udGgsIGRheSkpO1xuICB9XG5cbiAgLy8gbWF0Y2g6IFs0XSBob3VyIFs1XSBtaW51dGUgWzZdIHNlY29uZCBbN10gZnJhY3Rpb25cblxuICBob3VyID0gKyhtYXRjaFs0XSk7XG4gIG1pbnV0ZSA9ICsobWF0Y2hbNV0pO1xuICBzZWNvbmQgPSArKG1hdGNoWzZdKTtcblxuICBpZiAobWF0Y2hbN10pIHtcbiAgICBmcmFjdGlvbiA9IG1hdGNoWzddLnNsaWNlKDAsIDMpO1xuICAgIHdoaWxlIChmcmFjdGlvbi5sZW5ndGggPCAzKSB7IC8vIG1pbGxpLXNlY29uZHNcbiAgICAgIGZyYWN0aW9uICs9ICcwJztcbiAgICB9XG4gICAgZnJhY3Rpb24gPSArZnJhY3Rpb247XG4gIH1cblxuICAvLyBtYXRjaDogWzhdIHR6IFs5XSB0el9zaWduIFsxMF0gdHpfaG91ciBbMTFdIHR6X21pbnV0ZVxuXG4gIGlmIChtYXRjaFs5XSkge1xuICAgIHR6X2hvdXIgPSArKG1hdGNoWzEwXSk7XG4gICAgdHpfbWludXRlID0gKyhtYXRjaFsxMV0gfHwgMCk7XG4gICAgZGVsdGEgPSAodHpfaG91ciAqIDYwICsgdHpfbWludXRlKSAqIDYwMDAwOyAvLyBkZWx0YSBpbiBtaWxpLXNlY29uZHNcbiAgICBpZiAobWF0Y2hbOV0gPT09ICctJykgZGVsdGEgPSAtZGVsdGE7XG4gIH1cblxuICBkYXRlID0gbmV3IERhdGUoRGF0ZS5VVEMoeWVhciwgbW9udGgsIGRheSwgaG91ciwgbWludXRlLCBzZWNvbmQsIGZyYWN0aW9uKSk7XG5cbiAgaWYgKGRlbHRhKSBkYXRlLnNldFRpbWUoZGF0ZS5nZXRUaW1lKCkgLSBkZWx0YSk7XG5cbiAgcmV0dXJuIGRhdGU7XG59XG5cbmZ1bmN0aW9uIHJlcHJlc2VudFlhbWxUaW1lc3RhbXAob2JqZWN0IC8qLCBzdHlsZSovKSB7XG4gIHJldHVybiBvYmplY3QudG9JU09TdHJpbmcoKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBuZXcgVHlwZSgndGFnOnlhbWwub3JnLDIwMDI6dGltZXN0YW1wJywge1xuICBraW5kOiAnc2NhbGFyJyxcbiAgcmVzb2x2ZTogcmVzb2x2ZVlhbWxUaW1lc3RhbXAsXG4gIGNvbnN0cnVjdDogY29uc3RydWN0WWFtbFRpbWVzdGFtcCxcbiAgaW5zdGFuY2VPZjogRGF0ZSxcbiAgcmVwcmVzZW50OiByZXByZXNlbnRZYW1sVGltZXN0YW1wXG59KTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9qcy15YW1sL2xpYi9qcy15YW1sL3R5cGUvdGltZXN0YW1wLmpzIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgVHlwZSA9IHJlcXVpcmUoJy4uL3R5cGUnKTtcblxuZnVuY3Rpb24gcmVzb2x2ZVlhbWxNZXJnZShkYXRhKSB7XG4gIHJldHVybiBkYXRhID09PSAnPDwnIHx8IGRhdGEgPT09IG51bGw7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gbmV3IFR5cGUoJ3RhZzp5YW1sLm9yZywyMDAyOm1lcmdlJywge1xuICBraW5kOiAnc2NhbGFyJyxcbiAgcmVzb2x2ZTogcmVzb2x2ZVlhbWxNZXJnZVxufSk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvanMteWFtbC9saWIvanMteWFtbC90eXBlL21lcmdlLmpzIiwiJ3VzZSBzdHJpY3QnO1xuXG4vKmVzbGludC1kaXNhYmxlIG5vLWJpdHdpc2UqL1xuXG52YXIgTm9kZUJ1ZmZlcjtcblxudHJ5IHtcbiAgLy8gQSB0cmljayBmb3IgYnJvd3NlcmlmaWVkIHZlcnNpb24sIHRvIG5vdCBpbmNsdWRlIGBCdWZmZXJgIHNoaW1cbiAgdmFyIF9yZXF1aXJlID0gcmVxdWlyZTtcbiAgTm9kZUJ1ZmZlciA9IF9yZXF1aXJlKCdidWZmZXInKS5CdWZmZXI7XG59IGNhdGNoIChfXykge31cblxudmFyIFR5cGUgICAgICAgPSByZXF1aXJlKCcuLi90eXBlJyk7XG5cblxuLy8gWyA2NCwgNjUsIDY2IF0gLT4gWyBwYWRkaW5nLCBDUiwgTEYgXVxudmFyIEJBU0U2NF9NQVAgPSAnQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejAxMjM0NTY3ODkrLz1cXG5cXHInO1xuXG5cbmZ1bmN0aW9uIHJlc29sdmVZYW1sQmluYXJ5KGRhdGEpIHtcbiAgaWYgKGRhdGEgPT09IG51bGwpIHJldHVybiBmYWxzZTtcblxuICB2YXIgY29kZSwgaWR4LCBiaXRsZW4gPSAwLCBtYXggPSBkYXRhLmxlbmd0aCwgbWFwID0gQkFTRTY0X01BUDtcblxuICAvLyBDb252ZXJ0IG9uZSBieSBvbmUuXG4gIGZvciAoaWR4ID0gMDsgaWR4IDwgbWF4OyBpZHgrKykge1xuICAgIGNvZGUgPSBtYXAuaW5kZXhPZihkYXRhLmNoYXJBdChpZHgpKTtcblxuICAgIC8vIFNraXAgQ1IvTEZcbiAgICBpZiAoY29kZSA+IDY0KSBjb250aW51ZTtcblxuICAgIC8vIEZhaWwgb24gaWxsZWdhbCBjaGFyYWN0ZXJzXG4gICAgaWYgKGNvZGUgPCAwKSByZXR1cm4gZmFsc2U7XG5cbiAgICBiaXRsZW4gKz0gNjtcbiAgfVxuXG4gIC8vIElmIHRoZXJlIGFyZSBhbnkgYml0cyBsZWZ0LCBzb3VyY2Ugd2FzIGNvcnJ1cHRlZFxuICByZXR1cm4gKGJpdGxlbiAlIDgpID09PSAwO1xufVxuXG5mdW5jdGlvbiBjb25zdHJ1Y3RZYW1sQmluYXJ5KGRhdGEpIHtcbiAgdmFyIGlkeCwgdGFpbGJpdHMsXG4gICAgICBpbnB1dCA9IGRhdGEucmVwbGFjZSgvW1xcclxcbj1dL2csICcnKSwgLy8gcmVtb3ZlIENSL0xGICYgcGFkZGluZyB0byBzaW1wbGlmeSBzY2FuXG4gICAgICBtYXggPSBpbnB1dC5sZW5ndGgsXG4gICAgICBtYXAgPSBCQVNFNjRfTUFQLFxuICAgICAgYml0cyA9IDAsXG4gICAgICByZXN1bHQgPSBbXTtcblxuICAvLyBDb2xsZWN0IGJ5IDYqNCBiaXRzICgzIGJ5dGVzKVxuXG4gIGZvciAoaWR4ID0gMDsgaWR4IDwgbWF4OyBpZHgrKykge1xuICAgIGlmICgoaWR4ICUgNCA9PT0gMCkgJiYgaWR4KSB7XG4gICAgICByZXN1bHQucHVzaCgoYml0cyA+PiAxNikgJiAweEZGKTtcbiAgICAgIHJlc3VsdC5wdXNoKChiaXRzID4+IDgpICYgMHhGRik7XG4gICAgICByZXN1bHQucHVzaChiaXRzICYgMHhGRik7XG4gICAgfVxuXG4gICAgYml0cyA9IChiaXRzIDw8IDYpIHwgbWFwLmluZGV4T2YoaW5wdXQuY2hhckF0KGlkeCkpO1xuICB9XG5cbiAgLy8gRHVtcCB0YWlsXG5cbiAgdGFpbGJpdHMgPSAobWF4ICUgNCkgKiA2O1xuXG4gIGlmICh0YWlsYml0cyA9PT0gMCkge1xuICAgIHJlc3VsdC5wdXNoKChiaXRzID4+IDE2KSAmIDB4RkYpO1xuICAgIHJlc3VsdC5wdXNoKChiaXRzID4+IDgpICYgMHhGRik7XG4gICAgcmVzdWx0LnB1c2goYml0cyAmIDB4RkYpO1xuICB9IGVsc2UgaWYgKHRhaWxiaXRzID09PSAxOCkge1xuICAgIHJlc3VsdC5wdXNoKChiaXRzID4+IDEwKSAmIDB4RkYpO1xuICAgIHJlc3VsdC5wdXNoKChiaXRzID4+IDIpICYgMHhGRik7XG4gIH0gZWxzZSBpZiAodGFpbGJpdHMgPT09IDEyKSB7XG4gICAgcmVzdWx0LnB1c2goKGJpdHMgPj4gNCkgJiAweEZGKTtcbiAgfVxuXG4gIC8vIFdyYXAgaW50byBCdWZmZXIgZm9yIE5vZGVKUyBhbmQgbGVhdmUgQXJyYXkgZm9yIGJyb3dzZXJcbiAgaWYgKE5vZGVCdWZmZXIpIHtcbiAgICAvLyBTdXBwb3J0IG5vZGUgNi4rIEJ1ZmZlciBBUEkgd2hlbiBhdmFpbGFibGVcbiAgICByZXR1cm4gTm9kZUJ1ZmZlci5mcm9tID8gTm9kZUJ1ZmZlci5mcm9tKHJlc3VsdCkgOiBuZXcgTm9kZUJ1ZmZlcihyZXN1bHQpO1xuICB9XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuZnVuY3Rpb24gcmVwcmVzZW50WWFtbEJpbmFyeShvYmplY3QgLyosIHN0eWxlKi8pIHtcbiAgdmFyIHJlc3VsdCA9ICcnLCBiaXRzID0gMCwgaWR4LCB0YWlsLFxuICAgICAgbWF4ID0gb2JqZWN0Lmxlbmd0aCxcbiAgICAgIG1hcCA9IEJBU0U2NF9NQVA7XG5cbiAgLy8gQ29udmVydCBldmVyeSB0aHJlZSBieXRlcyB0byA0IEFTQ0lJIGNoYXJhY3RlcnMuXG5cbiAgZm9yIChpZHggPSAwOyBpZHggPCBtYXg7IGlkeCsrKSB7XG4gICAgaWYgKChpZHggJSAzID09PSAwKSAmJiBpZHgpIHtcbiAgICAgIHJlc3VsdCArPSBtYXBbKGJpdHMgPj4gMTgpICYgMHgzRl07XG4gICAgICByZXN1bHQgKz0gbWFwWyhiaXRzID4+IDEyKSAmIDB4M0ZdO1xuICAgICAgcmVzdWx0ICs9IG1hcFsoYml0cyA+PiA2KSAmIDB4M0ZdO1xuICAgICAgcmVzdWx0ICs9IG1hcFtiaXRzICYgMHgzRl07XG4gICAgfVxuXG4gICAgYml0cyA9IChiaXRzIDw8IDgpICsgb2JqZWN0W2lkeF07XG4gIH1cblxuICAvLyBEdW1wIHRhaWxcblxuICB0YWlsID0gbWF4ICUgMztcblxuICBpZiAodGFpbCA9PT0gMCkge1xuICAgIHJlc3VsdCArPSBtYXBbKGJpdHMgPj4gMTgpICYgMHgzRl07XG4gICAgcmVzdWx0ICs9IG1hcFsoYml0cyA+PiAxMikgJiAweDNGXTtcbiAgICByZXN1bHQgKz0gbWFwWyhiaXRzID4+IDYpICYgMHgzRl07XG4gICAgcmVzdWx0ICs9IG1hcFtiaXRzICYgMHgzRl07XG4gIH0gZWxzZSBpZiAodGFpbCA9PT0gMikge1xuICAgIHJlc3VsdCArPSBtYXBbKGJpdHMgPj4gMTApICYgMHgzRl07XG4gICAgcmVzdWx0ICs9IG1hcFsoYml0cyA+PiA0KSAmIDB4M0ZdO1xuICAgIHJlc3VsdCArPSBtYXBbKGJpdHMgPDwgMikgJiAweDNGXTtcbiAgICByZXN1bHQgKz0gbWFwWzY0XTtcbiAgfSBlbHNlIGlmICh0YWlsID09PSAxKSB7XG4gICAgcmVzdWx0ICs9IG1hcFsoYml0cyA+PiAyKSAmIDB4M0ZdO1xuICAgIHJlc3VsdCArPSBtYXBbKGJpdHMgPDwgNCkgJiAweDNGXTtcbiAgICByZXN1bHQgKz0gbWFwWzY0XTtcbiAgICByZXN1bHQgKz0gbWFwWzY0XTtcbiAgfVxuXG4gIHJldHVybiByZXN1bHQ7XG59XG5cbmZ1bmN0aW9uIGlzQmluYXJ5KG9iamVjdCkge1xuICByZXR1cm4gTm9kZUJ1ZmZlciAmJiBOb2RlQnVmZmVyLmlzQnVmZmVyKG9iamVjdCk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gbmV3IFR5cGUoJ3RhZzp5YW1sLm9yZywyMDAyOmJpbmFyeScsIHtcbiAga2luZDogJ3NjYWxhcicsXG4gIHJlc29sdmU6IHJlc29sdmVZYW1sQmluYXJ5LFxuICBjb25zdHJ1Y3Q6IGNvbnN0cnVjdFlhbWxCaW5hcnksXG4gIHByZWRpY2F0ZTogaXNCaW5hcnksXG4gIHJlcHJlc2VudDogcmVwcmVzZW50WWFtbEJpbmFyeVxufSk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvanMteWFtbC9saWIvanMteWFtbC90eXBlL2JpbmFyeS5qcyIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcImJ1ZmZlclwiKTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyBleHRlcm5hbCBcImJ1ZmZlclwiXG4vLyBtb2R1bGUgaWQgPSAxNTBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgVHlwZSA9IHJlcXVpcmUoJy4uL3R5cGUnKTtcblxudmFyIF9oYXNPd25Qcm9wZXJ0eSA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG52YXIgX3RvU3RyaW5nICAgICAgID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZztcblxuZnVuY3Rpb24gcmVzb2x2ZVlhbWxPbWFwKGRhdGEpIHtcbiAgaWYgKGRhdGEgPT09IG51bGwpIHJldHVybiB0cnVlO1xuXG4gIHZhciBvYmplY3RLZXlzID0gW10sIGluZGV4LCBsZW5ndGgsIHBhaXIsIHBhaXJLZXksIHBhaXJIYXNLZXksXG4gICAgICBvYmplY3QgPSBkYXRhO1xuXG4gIGZvciAoaW5kZXggPSAwLCBsZW5ndGggPSBvYmplY3QubGVuZ3RoOyBpbmRleCA8IGxlbmd0aDsgaW5kZXggKz0gMSkge1xuICAgIHBhaXIgPSBvYmplY3RbaW5kZXhdO1xuICAgIHBhaXJIYXNLZXkgPSBmYWxzZTtcblxuICAgIGlmIChfdG9TdHJpbmcuY2FsbChwYWlyKSAhPT0gJ1tvYmplY3QgT2JqZWN0XScpIHJldHVybiBmYWxzZTtcblxuICAgIGZvciAocGFpcktleSBpbiBwYWlyKSB7XG4gICAgICBpZiAoX2hhc093blByb3BlcnR5LmNhbGwocGFpciwgcGFpcktleSkpIHtcbiAgICAgICAgaWYgKCFwYWlySGFzS2V5KSBwYWlySGFzS2V5ID0gdHJ1ZTtcbiAgICAgICAgZWxzZSByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKCFwYWlySGFzS2V5KSByZXR1cm4gZmFsc2U7XG5cbiAgICBpZiAob2JqZWN0S2V5cy5pbmRleE9mKHBhaXJLZXkpID09PSAtMSkgb2JqZWN0S2V5cy5wdXNoKHBhaXJLZXkpO1xuICAgIGVsc2UgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59XG5cbmZ1bmN0aW9uIGNvbnN0cnVjdFlhbWxPbWFwKGRhdGEpIHtcbiAgcmV0dXJuIGRhdGEgIT09IG51bGwgPyBkYXRhIDogW107XG59XG5cbm1vZHVsZS5leHBvcnRzID0gbmV3IFR5cGUoJ3RhZzp5YW1sLm9yZywyMDAyOm9tYXAnLCB7XG4gIGtpbmQ6ICdzZXF1ZW5jZScsXG4gIHJlc29sdmU6IHJlc29sdmVZYW1sT21hcCxcbiAgY29uc3RydWN0OiBjb25zdHJ1Y3RZYW1sT21hcFxufSk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvanMteWFtbC9saWIvanMteWFtbC90eXBlL29tYXAuanMiLCIndXNlIHN0cmljdCc7XG5cbnZhciBUeXBlID0gcmVxdWlyZSgnLi4vdHlwZScpO1xuXG52YXIgX3RvU3RyaW5nID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZztcblxuZnVuY3Rpb24gcmVzb2x2ZVlhbWxQYWlycyhkYXRhKSB7XG4gIGlmIChkYXRhID09PSBudWxsKSByZXR1cm4gdHJ1ZTtcblxuICB2YXIgaW5kZXgsIGxlbmd0aCwgcGFpciwga2V5cywgcmVzdWx0LFxuICAgICAgb2JqZWN0ID0gZGF0YTtcblxuICByZXN1bHQgPSBuZXcgQXJyYXkob2JqZWN0Lmxlbmd0aCk7XG5cbiAgZm9yIChpbmRleCA9IDAsIGxlbmd0aCA9IG9iamVjdC5sZW5ndGg7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCArPSAxKSB7XG4gICAgcGFpciA9IG9iamVjdFtpbmRleF07XG5cbiAgICBpZiAoX3RvU3RyaW5nLmNhbGwocGFpcikgIT09ICdbb2JqZWN0IE9iamVjdF0nKSByZXR1cm4gZmFsc2U7XG5cbiAgICBrZXlzID0gT2JqZWN0LmtleXMocGFpcik7XG5cbiAgICBpZiAoa2V5cy5sZW5ndGggIT09IDEpIHJldHVybiBmYWxzZTtcblxuICAgIHJlc3VsdFtpbmRleF0gPSBbIGtleXNbMF0sIHBhaXJba2V5c1swXV0gXTtcbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufVxuXG5mdW5jdGlvbiBjb25zdHJ1Y3RZYW1sUGFpcnMoZGF0YSkge1xuICBpZiAoZGF0YSA9PT0gbnVsbCkgcmV0dXJuIFtdO1xuXG4gIHZhciBpbmRleCwgbGVuZ3RoLCBwYWlyLCBrZXlzLCByZXN1bHQsXG4gICAgICBvYmplY3QgPSBkYXRhO1xuXG4gIHJlc3VsdCA9IG5ldyBBcnJheShvYmplY3QubGVuZ3RoKTtcblxuICBmb3IgKGluZGV4ID0gMCwgbGVuZ3RoID0gb2JqZWN0Lmxlbmd0aDsgaW5kZXggPCBsZW5ndGg7IGluZGV4ICs9IDEpIHtcbiAgICBwYWlyID0gb2JqZWN0W2luZGV4XTtcblxuICAgIGtleXMgPSBPYmplY3Qua2V5cyhwYWlyKTtcblxuICAgIHJlc3VsdFtpbmRleF0gPSBbIGtleXNbMF0sIHBhaXJba2V5c1swXV0gXTtcbiAgfVxuXG4gIHJldHVybiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gbmV3IFR5cGUoJ3RhZzp5YW1sLm9yZywyMDAyOnBhaXJzJywge1xuICBraW5kOiAnc2VxdWVuY2UnLFxuICByZXNvbHZlOiByZXNvbHZlWWFtbFBhaXJzLFxuICBjb25zdHJ1Y3Q6IGNvbnN0cnVjdFlhbWxQYWlyc1xufSk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvanMteWFtbC9saWIvanMteWFtbC90eXBlL3BhaXJzLmpzIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgVHlwZSA9IHJlcXVpcmUoJy4uL3R5cGUnKTtcblxudmFyIF9oYXNPd25Qcm9wZXJ0eSA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG5cbmZ1bmN0aW9uIHJlc29sdmVZYW1sU2V0KGRhdGEpIHtcbiAgaWYgKGRhdGEgPT09IG51bGwpIHJldHVybiB0cnVlO1xuXG4gIHZhciBrZXksIG9iamVjdCA9IGRhdGE7XG5cbiAgZm9yIChrZXkgaW4gb2JqZWN0KSB7XG4gICAgaWYgKF9oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwga2V5KSkge1xuICAgICAgaWYgKG9iamVjdFtrZXldICE9PSBudWxsKSByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59XG5cbmZ1bmN0aW9uIGNvbnN0cnVjdFlhbWxTZXQoZGF0YSkge1xuICByZXR1cm4gZGF0YSAhPT0gbnVsbCA/IGRhdGEgOiB7fTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBuZXcgVHlwZSgndGFnOnlhbWwub3JnLDIwMDI6c2V0Jywge1xuICBraW5kOiAnbWFwcGluZycsXG4gIHJlc29sdmU6IHJlc29sdmVZYW1sU2V0LFxuICBjb25zdHJ1Y3Q6IGNvbnN0cnVjdFlhbWxTZXRcbn0pO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2pzLXlhbWwvbGliL2pzLXlhbWwvdHlwZS9zZXQuanMiLCIndXNlIHN0cmljdCc7XG5cbnZhciBUeXBlID0gcmVxdWlyZSgnLi4vLi4vdHlwZScpO1xuXG5mdW5jdGlvbiByZXNvbHZlSmF2YXNjcmlwdFVuZGVmaW5lZCgpIHtcbiAgcmV0dXJuIHRydWU7XG59XG5cbmZ1bmN0aW9uIGNvbnN0cnVjdEphdmFzY3JpcHRVbmRlZmluZWQoKSB7XG4gIC8qZXNsaW50LWRpc2FibGUgbm8tdW5kZWZpbmVkKi9cbiAgcmV0dXJuIHVuZGVmaW5lZDtcbn1cblxuZnVuY3Rpb24gcmVwcmVzZW50SmF2YXNjcmlwdFVuZGVmaW5lZCgpIHtcbiAgcmV0dXJuICcnO1xufVxuXG5mdW5jdGlvbiBpc1VuZGVmaW5lZChvYmplY3QpIHtcbiAgcmV0dXJuIHR5cGVvZiBvYmplY3QgPT09ICd1bmRlZmluZWQnO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IG5ldyBUeXBlKCd0YWc6eWFtbC5vcmcsMjAwMjpqcy91bmRlZmluZWQnLCB7XG4gIGtpbmQ6ICdzY2FsYXInLFxuICByZXNvbHZlOiByZXNvbHZlSmF2YXNjcmlwdFVuZGVmaW5lZCxcbiAgY29uc3RydWN0OiBjb25zdHJ1Y3RKYXZhc2NyaXB0VW5kZWZpbmVkLFxuICBwcmVkaWNhdGU6IGlzVW5kZWZpbmVkLFxuICByZXByZXNlbnQ6IHJlcHJlc2VudEphdmFzY3JpcHRVbmRlZmluZWRcbn0pO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2pzLXlhbWwvbGliL2pzLXlhbWwvdHlwZS9qcy91bmRlZmluZWQuanMiLCIndXNlIHN0cmljdCc7XG5cbnZhciBUeXBlID0gcmVxdWlyZSgnLi4vLi4vdHlwZScpO1xuXG5mdW5jdGlvbiByZXNvbHZlSmF2YXNjcmlwdFJlZ0V4cChkYXRhKSB7XG4gIGlmIChkYXRhID09PSBudWxsKSByZXR1cm4gZmFsc2U7XG4gIGlmIChkYXRhLmxlbmd0aCA9PT0gMCkgcmV0dXJuIGZhbHNlO1xuXG4gIHZhciByZWdleHAgPSBkYXRhLFxuICAgICAgdGFpbCAgID0gL1xcLyhbZ2ltXSopJC8uZXhlYyhkYXRhKSxcbiAgICAgIG1vZGlmaWVycyA9ICcnO1xuXG4gIC8vIGlmIHJlZ2V4cCBzdGFydHMgd2l0aCAnLycgaXQgY2FuIGhhdmUgbW9kaWZpZXJzIGFuZCBtdXN0IGJlIHByb3Blcmx5IGNsb3NlZFxuICAvLyBgL2Zvby9naW1gIC0gbW9kaWZpZXJzIHRhaWwgY2FuIGJlIG1heGltdW0gMyBjaGFyc1xuICBpZiAocmVnZXhwWzBdID09PSAnLycpIHtcbiAgICBpZiAodGFpbCkgbW9kaWZpZXJzID0gdGFpbFsxXTtcblxuICAgIGlmIChtb2RpZmllcnMubGVuZ3RoID4gMykgcmV0dXJuIGZhbHNlO1xuICAgIC8vIGlmIGV4cHJlc3Npb24gc3RhcnRzIHdpdGggLywgaXMgc2hvdWxkIGJlIHByb3Blcmx5IHRlcm1pbmF0ZWRcbiAgICBpZiAocmVnZXhwW3JlZ2V4cC5sZW5ndGggLSBtb2RpZmllcnMubGVuZ3RoIC0gMV0gIT09ICcvJykgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59XG5cbmZ1bmN0aW9uIGNvbnN0cnVjdEphdmFzY3JpcHRSZWdFeHAoZGF0YSkge1xuICB2YXIgcmVnZXhwID0gZGF0YSxcbiAgICAgIHRhaWwgICA9IC9cXC8oW2dpbV0qKSQvLmV4ZWMoZGF0YSksXG4gICAgICBtb2RpZmllcnMgPSAnJztcblxuICAvLyBgL2Zvby9naW1gIC0gdGFpbCBjYW4gYmUgbWF4aW11bSA0IGNoYXJzXG4gIGlmIChyZWdleHBbMF0gPT09ICcvJykge1xuICAgIGlmICh0YWlsKSBtb2RpZmllcnMgPSB0YWlsWzFdO1xuICAgIHJlZ2V4cCA9IHJlZ2V4cC5zbGljZSgxLCByZWdleHAubGVuZ3RoIC0gbW9kaWZpZXJzLmxlbmd0aCAtIDEpO1xuICB9XG5cbiAgcmV0dXJuIG5ldyBSZWdFeHAocmVnZXhwLCBtb2RpZmllcnMpO1xufVxuXG5mdW5jdGlvbiByZXByZXNlbnRKYXZhc2NyaXB0UmVnRXhwKG9iamVjdCAvKiwgc3R5bGUqLykge1xuICB2YXIgcmVzdWx0ID0gJy8nICsgb2JqZWN0LnNvdXJjZSArICcvJztcblxuICBpZiAob2JqZWN0Lmdsb2JhbCkgcmVzdWx0ICs9ICdnJztcbiAgaWYgKG9iamVjdC5tdWx0aWxpbmUpIHJlc3VsdCArPSAnbSc7XG4gIGlmIChvYmplY3QuaWdub3JlQ2FzZSkgcmVzdWx0ICs9ICdpJztcblxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5mdW5jdGlvbiBpc1JlZ0V4cChvYmplY3QpIHtcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvYmplY3QpID09PSAnW29iamVjdCBSZWdFeHBdJztcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBuZXcgVHlwZSgndGFnOnlhbWwub3JnLDIwMDI6anMvcmVnZXhwJywge1xuICBraW5kOiAnc2NhbGFyJyxcbiAgcmVzb2x2ZTogcmVzb2x2ZUphdmFzY3JpcHRSZWdFeHAsXG4gIGNvbnN0cnVjdDogY29uc3RydWN0SmF2YXNjcmlwdFJlZ0V4cCxcbiAgcHJlZGljYXRlOiBpc1JlZ0V4cCxcbiAgcmVwcmVzZW50OiByZXByZXNlbnRKYXZhc2NyaXB0UmVnRXhwXG59KTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9qcy15YW1sL2xpYi9qcy15YW1sL3R5cGUvanMvcmVnZXhwLmpzIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgZXNwcmltYTtcblxuLy8gQnJvd3NlcmlmaWVkIHZlcnNpb24gZG9lcyBub3QgaGF2ZSBlc3ByaW1hXG4vL1xuLy8gMS4gRm9yIG5vZGUuanMganVzdCByZXF1aXJlIG1vZHVsZSBhcyBkZXBzXG4vLyAyLiBGb3IgYnJvd3NlciB0cnkgdG8gcmVxdWlyZSBtdWR1bGUgdmlhIGV4dGVybmFsIEFNRCBzeXN0ZW0uXG4vLyAgICBJZiBub3QgZm91bmQgLSB0cnkgdG8gZmFsbGJhY2sgdG8gd2luZG93LmVzcHJpbWEuIElmIG5vdFxuLy8gICAgZm91bmQgdG9vIC0gdGhlbiBmYWlsIHRvIHBhcnNlLlxuLy9cbnRyeSB7XG4gIC8vIHdvcmthcm91bmQgdG8gZXhjbHVkZSBwYWNrYWdlIGZyb20gYnJvd3NlcmlmeSBsaXN0LlxuICB2YXIgX3JlcXVpcmUgPSByZXF1aXJlO1xuICBlc3ByaW1hID0gX3JlcXVpcmUoJ2VzcHJpbWEnKTtcbn0gY2F0Y2ggKF8pIHtcbiAgLypnbG9iYWwgd2luZG93ICovXG4gIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJykgZXNwcmltYSA9IHdpbmRvdy5lc3ByaW1hO1xufVxuXG52YXIgVHlwZSA9IHJlcXVpcmUoJy4uLy4uL3R5cGUnKTtcblxuZnVuY3Rpb24gcmVzb2x2ZUphdmFzY3JpcHRGdW5jdGlvbihkYXRhKSB7XG4gIGlmIChkYXRhID09PSBudWxsKSByZXR1cm4gZmFsc2U7XG5cbiAgdHJ5IHtcbiAgICB2YXIgc291cmNlID0gJygnICsgZGF0YSArICcpJyxcbiAgICAgICAgYXN0ICAgID0gZXNwcmltYS5wYXJzZShzb3VyY2UsIHsgcmFuZ2U6IHRydWUgfSk7XG5cbiAgICBpZiAoYXN0LnR5cGUgICAgICAgICAgICAgICAgICAgICE9PSAnUHJvZ3JhbScgICAgICAgICAgICAgfHxcbiAgICAgICAgYXN0LmJvZHkubGVuZ3RoICAgICAgICAgICAgICE9PSAxICAgICAgICAgICAgICAgICAgICAgfHxcbiAgICAgICAgYXN0LmJvZHlbMF0udHlwZSAgICAgICAgICAgICE9PSAnRXhwcmVzc2lvblN0YXRlbWVudCcgfHxcbiAgICAgICAgYXN0LmJvZHlbMF0uZXhwcmVzc2lvbi50eXBlICE9PSAnRnVuY3Rpb25FeHByZXNzaW9uJykge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHJldHVybiB0cnVlO1xuICB9IGNhdGNoIChlcnIpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn1cblxuZnVuY3Rpb24gY29uc3RydWN0SmF2YXNjcmlwdEZ1bmN0aW9uKGRhdGEpIHtcbiAgLypqc2xpbnQgZXZpbDp0cnVlKi9cblxuICB2YXIgc291cmNlID0gJygnICsgZGF0YSArICcpJyxcbiAgICAgIGFzdCAgICA9IGVzcHJpbWEucGFyc2Uoc291cmNlLCB7IHJhbmdlOiB0cnVlIH0pLFxuICAgICAgcGFyYW1zID0gW10sXG4gICAgICBib2R5O1xuXG4gIGlmIChhc3QudHlwZSAgICAgICAgICAgICAgICAgICAgIT09ICdQcm9ncmFtJyAgICAgICAgICAgICB8fFxuICAgICAgYXN0LmJvZHkubGVuZ3RoICAgICAgICAgICAgICE9PSAxICAgICAgICAgICAgICAgICAgICAgfHxcbiAgICAgIGFzdC5ib2R5WzBdLnR5cGUgICAgICAgICAgICAhPT0gJ0V4cHJlc3Npb25TdGF0ZW1lbnQnIHx8XG4gICAgICBhc3QuYm9keVswXS5leHByZXNzaW9uLnR5cGUgIT09ICdGdW5jdGlvbkV4cHJlc3Npb24nKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdGYWlsZWQgdG8gcmVzb2x2ZSBmdW5jdGlvbicpO1xuICB9XG5cbiAgYXN0LmJvZHlbMF0uZXhwcmVzc2lvbi5wYXJhbXMuZm9yRWFjaChmdW5jdGlvbiAocGFyYW0pIHtcbiAgICBwYXJhbXMucHVzaChwYXJhbS5uYW1lKTtcbiAgfSk7XG5cbiAgYm9keSA9IGFzdC5ib2R5WzBdLmV4cHJlc3Npb24uYm9keS5yYW5nZTtcblxuICAvLyBFc3ByaW1hJ3MgcmFuZ2VzIGluY2x1ZGUgdGhlIGZpcnN0ICd7JyBhbmQgdGhlIGxhc3QgJ30nIGNoYXJhY3RlcnMgb25cbiAgLy8gZnVuY3Rpb24gZXhwcmVzc2lvbnMuIFNvIGN1dCB0aGVtIG91dC5cbiAgLyplc2xpbnQtZGlzYWJsZSBuby1uZXctZnVuYyovXG4gIHJldHVybiBuZXcgRnVuY3Rpb24ocGFyYW1zLCBzb3VyY2Uuc2xpY2UoYm9keVswXSArIDEsIGJvZHlbMV0gLSAxKSk7XG59XG5cbmZ1bmN0aW9uIHJlcHJlc2VudEphdmFzY3JpcHRGdW5jdGlvbihvYmplY3QgLyosIHN0eWxlKi8pIHtcbiAgcmV0dXJuIG9iamVjdC50b1N0cmluZygpO1xufVxuXG5mdW5jdGlvbiBpc0Z1bmN0aW9uKG9iamVjdCkge1xuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG9iamVjdCkgPT09ICdbb2JqZWN0IEZ1bmN0aW9uXSc7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gbmV3IFR5cGUoJ3RhZzp5YW1sLm9yZywyMDAyOmpzL2Z1bmN0aW9uJywge1xuICBraW5kOiAnc2NhbGFyJyxcbiAgcmVzb2x2ZTogcmVzb2x2ZUphdmFzY3JpcHRGdW5jdGlvbixcbiAgY29uc3RydWN0OiBjb25zdHJ1Y3RKYXZhc2NyaXB0RnVuY3Rpb24sXG4gIHByZWRpY2F0ZTogaXNGdW5jdGlvbixcbiAgcmVwcmVzZW50OiByZXByZXNlbnRKYXZhc2NyaXB0RnVuY3Rpb25cbn0pO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2pzLXlhbWwvbGliL2pzLXlhbWwvdHlwZS9qcy9mdW5jdGlvbi5qcyIsIihmdW5jdGlvbiB3ZWJwYWNrVW5pdmVyc2FsTW9kdWxlRGVmaW5pdGlvbihyb290LCBmYWN0b3J5KSB7XG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuXHRpZih0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSA9PT0gJ29iamVjdCcpXG5cdFx0bW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KCk7XG5cdGVsc2UgaWYodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKVxuXHRcdGRlZmluZShbXSwgZmFjdG9yeSk7XG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuXHRlbHNlIGlmKHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0Jylcblx0XHRleHBvcnRzW1wiZXNwcmltYVwiXSA9IGZhY3RvcnkoKTtcblx0ZWxzZVxuXHRcdHJvb3RbXCJlc3ByaW1hXCJdID0gZmFjdG9yeSgpO1xufSkodGhpcywgZnVuY3Rpb24oKSB7XG5yZXR1cm4gLyoqKioqKi8gKGZ1bmN0aW9uKG1vZHVsZXMpIHsgLy8gd2VicGFja0Jvb3RzdHJhcFxuLyoqKioqKi8gXHQvLyBUaGUgbW9kdWxlIGNhY2hlXG4vKioqKioqLyBcdHZhciBpbnN0YWxsZWRNb2R1bGVzID0ge307XG5cbi8qKioqKiovIFx0Ly8gVGhlIHJlcXVpcmUgZnVuY3Rpb25cbi8qKioqKiovIFx0ZnVuY3Rpb24gX193ZWJwYWNrX3JlcXVpcmVfXyhtb2R1bGVJZCkge1xuXG4vKioqKioqLyBcdFx0Ly8gQ2hlY2sgaWYgbW9kdWxlIGlzIGluIGNhY2hlXG4vKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbi8qKioqKiovIFx0XHRpZihpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSlcbi8qKioqKiovIFx0XHRcdHJldHVybiBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXS5leHBvcnRzO1xuXG4vKioqKioqLyBcdFx0Ly8gQ3JlYXRlIGEgbmV3IG1vZHVsZSAoYW5kIHB1dCBpdCBpbnRvIHRoZSBjYWNoZSlcbi8qKioqKiovIFx0XHR2YXIgbW9kdWxlID0gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0gPSB7XG4vKioqKioqLyBcdFx0XHRleHBvcnRzOiB7fSxcbi8qKioqKiovIFx0XHRcdGlkOiBtb2R1bGVJZCxcbi8qKioqKiovIFx0XHRcdGxvYWRlZDogZmFsc2Vcbi8qKioqKiovIFx0XHR9O1xuXG4vKioqKioqLyBcdFx0Ly8gRXhlY3V0ZSB0aGUgbW9kdWxlIGZ1bmN0aW9uXG4vKioqKioqLyBcdFx0bW9kdWxlc1ttb2R1bGVJZF0uY2FsbChtb2R1bGUuZXhwb3J0cywgbW9kdWxlLCBtb2R1bGUuZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXyk7XG5cbi8qKioqKiovIFx0XHQvLyBGbGFnIHRoZSBtb2R1bGUgYXMgbG9hZGVkXG4vKioqKioqLyBcdFx0bW9kdWxlLmxvYWRlZCA9IHRydWU7XG5cbi8qKioqKiovIFx0XHQvLyBSZXR1cm4gdGhlIGV4cG9ydHMgb2YgdGhlIG1vZHVsZVxuLyoqKioqKi8gXHRcdHJldHVybiBtb2R1bGUuZXhwb3J0cztcbi8qKioqKiovIFx0fVxuXG5cbi8qKioqKiovIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGVzIG9iamVjdCAoX193ZWJwYWNrX21vZHVsZXNfXylcbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5tID0gbW9kdWxlcztcblxuLyoqKioqKi8gXHQvLyBleHBvc2UgdGhlIG1vZHVsZSBjYWNoZVxuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmMgPSBpbnN0YWxsZWRNb2R1bGVzO1xuXG4vKioqKioqLyBcdC8vIF9fd2VicGFja19wdWJsaWNfcGF0aF9fXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18ucCA9IFwiXCI7XG5cbi8qKioqKiovIFx0Ly8gTG9hZCBlbnRyeSBtb2R1bGUgYW5kIHJldHVybiBleHBvcnRzXG4vKioqKioqLyBcdHJldHVybiBfX3dlYnBhY2tfcmVxdWlyZV9fKDApO1xuLyoqKioqKi8gfSlcbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqKioqLyAoW1xuLyogMCAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblx0XCJ1c2Ugc3RyaWN0XCI7XHJcblx0LypcclxuXHQgIENvcHlyaWdodCBKUyBGb3VuZGF0aW9uIGFuZCBvdGhlciBjb250cmlidXRvcnMsIGh0dHBzOi8vanMuZm91bmRhdGlvbi9cclxuXHJcblx0ICBSZWRpc3RyaWJ1dGlvbiBhbmQgdXNlIGluIHNvdXJjZSBhbmQgYmluYXJ5IGZvcm1zLCB3aXRoIG9yIHdpdGhvdXRcclxuXHQgIG1vZGlmaWNhdGlvbiwgYXJlIHBlcm1pdHRlZCBwcm92aWRlZCB0aGF0IHRoZSBmb2xsb3dpbmcgY29uZGl0aW9ucyBhcmUgbWV0OlxyXG5cclxuXHQgICAgKiBSZWRpc3RyaWJ1dGlvbnMgb2Ygc291cmNlIGNvZGUgbXVzdCByZXRhaW4gdGhlIGFib3ZlIGNvcHlyaWdodFxyXG5cdCAgICAgIG5vdGljZSwgdGhpcyBsaXN0IG9mIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmcgZGlzY2xhaW1lci5cclxuXHQgICAgKiBSZWRpc3RyaWJ1dGlvbnMgaW4gYmluYXJ5IGZvcm0gbXVzdCByZXByb2R1Y2UgdGhlIGFib3ZlIGNvcHlyaWdodFxyXG5cdCAgICAgIG5vdGljZSwgdGhpcyBsaXN0IG9mIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmcgZGlzY2xhaW1lciBpbiB0aGVcclxuXHQgICAgICBkb2N1bWVudGF0aW9uIGFuZC9vciBvdGhlciBtYXRlcmlhbHMgcHJvdmlkZWQgd2l0aCB0aGUgZGlzdHJpYnV0aW9uLlxyXG5cclxuXHQgIFRISVMgU09GVFdBUkUgSVMgUFJPVklERUQgQlkgVEhFIENPUFlSSUdIVCBIT0xERVJTIEFORCBDT05UUklCVVRPUlMgXCJBUyBJU1wiXHJcblx0ICBBTkQgQU5ZIEVYUFJFU1MgT1IgSU1QTElFRCBXQVJSQU5USUVTLCBJTkNMVURJTkcsIEJVVCBOT1QgTElNSVRFRCBUTywgVEhFXHJcblx0ICBJTVBMSUVEIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZIEFORCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRVxyXG5cdCAgQVJFIERJU0NMQUlNRUQuIElOIE5PIEVWRU5UIFNIQUxMIDxDT1BZUklHSFQgSE9MREVSPiBCRSBMSUFCTEUgRk9SIEFOWVxyXG5cdCAgRElSRUNULCBJTkRJUkVDVCwgSU5DSURFTlRBTCwgU1BFQ0lBTCwgRVhFTVBMQVJZLCBPUiBDT05TRVFVRU5USUFMIERBTUFHRVNcclxuXHQgIChJTkNMVURJTkcsIEJVVCBOT1QgTElNSVRFRCBUTywgUFJPQ1VSRU1FTlQgT0YgU1VCU1RJVFVURSBHT09EUyBPUiBTRVJWSUNFUztcclxuXHQgIExPU1MgT0YgVVNFLCBEQVRBLCBPUiBQUk9GSVRTOyBPUiBCVVNJTkVTUyBJTlRFUlJVUFRJT04pIEhPV0VWRVIgQ0FVU0VEIEFORFxyXG5cdCAgT04gQU5ZIFRIRU9SWSBPRiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQ09OVFJBQ1QsIFNUUklDVCBMSUFCSUxJVFksIE9SIFRPUlRcclxuXHQgIChJTkNMVURJTkcgTkVHTElHRU5DRSBPUiBPVEhFUldJU0UpIEFSSVNJTkcgSU4gQU5ZIFdBWSBPVVQgT0YgVEhFIFVTRSBPRlxyXG5cdCAgVEhJUyBTT0ZUV0FSRSwgRVZFTiBJRiBBRFZJU0VEIE9GIFRIRSBQT1NTSUJJTElUWSBPRiBTVUNIIERBTUFHRS5cclxuXHQqL1xyXG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuXHR2YXIgY29tbWVudF9oYW5kbGVyXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEpO1xyXG5cdHZhciBqc3hfcGFyc2VyXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMpO1xyXG5cdHZhciBwYXJzZXJfMSA9IF9fd2VicGFja19yZXF1aXJlX18oOCk7XHJcblx0dmFyIHRva2VuaXplcl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygxNSk7XHJcblx0ZnVuY3Rpb24gcGFyc2UoY29kZSwgb3B0aW9ucywgZGVsZWdhdGUpIHtcclxuXHQgICAgdmFyIGNvbW1lbnRIYW5kbGVyID0gbnVsbDtcclxuXHQgICAgdmFyIHByb3h5RGVsZWdhdGUgPSBmdW5jdGlvbiAobm9kZSwgbWV0YWRhdGEpIHtcclxuXHQgICAgICAgIGlmIChkZWxlZ2F0ZSkge1xyXG5cdCAgICAgICAgICAgIGRlbGVnYXRlKG5vZGUsIG1ldGFkYXRhKTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIGlmIChjb21tZW50SGFuZGxlcikge1xyXG5cdCAgICAgICAgICAgIGNvbW1lbnRIYW5kbGVyLnZpc2l0KG5vZGUsIG1ldGFkYXRhKTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgfTtcclxuXHQgICAgdmFyIHBhcnNlckRlbGVnYXRlID0gKHR5cGVvZiBkZWxlZ2F0ZSA9PT0gJ2Z1bmN0aW9uJykgPyBwcm94eURlbGVnYXRlIDogbnVsbDtcclxuXHQgICAgdmFyIGNvbGxlY3RDb21tZW50ID0gZmFsc2U7XHJcblx0ICAgIGlmIChvcHRpb25zKSB7XHJcblx0ICAgICAgICBjb2xsZWN0Q29tbWVudCA9ICh0eXBlb2Ygb3B0aW9ucy5jb21tZW50ID09PSAnYm9vbGVhbicgJiYgb3B0aW9ucy5jb21tZW50KTtcclxuXHQgICAgICAgIHZhciBhdHRhY2hDb21tZW50ID0gKHR5cGVvZiBvcHRpb25zLmF0dGFjaENvbW1lbnQgPT09ICdib29sZWFuJyAmJiBvcHRpb25zLmF0dGFjaENvbW1lbnQpO1xyXG5cdCAgICAgICAgaWYgKGNvbGxlY3RDb21tZW50IHx8IGF0dGFjaENvbW1lbnQpIHtcclxuXHQgICAgICAgICAgICBjb21tZW50SGFuZGxlciA9IG5ldyBjb21tZW50X2hhbmRsZXJfMS5Db21tZW50SGFuZGxlcigpO1xyXG5cdCAgICAgICAgICAgIGNvbW1lbnRIYW5kbGVyLmF0dGFjaCA9IGF0dGFjaENvbW1lbnQ7XHJcblx0ICAgICAgICAgICAgb3B0aW9ucy5jb21tZW50ID0gdHJ1ZTtcclxuXHQgICAgICAgICAgICBwYXJzZXJEZWxlZ2F0ZSA9IHByb3h5RGVsZWdhdGU7XHJcblx0ICAgICAgICB9XHJcblx0ICAgIH1cclxuXHQgICAgdmFyIGlzTW9kdWxlID0gZmFsc2U7XHJcblx0ICAgIGlmIChvcHRpb25zICYmIHR5cGVvZiBvcHRpb25zLnNvdXJjZVR5cGUgPT09ICdzdHJpbmcnKSB7XHJcblx0ICAgICAgICBpc01vZHVsZSA9IChvcHRpb25zLnNvdXJjZVR5cGUgPT09ICdtb2R1bGUnKTtcclxuXHQgICAgfVxyXG5cdCAgICB2YXIgcGFyc2VyO1xyXG5cdCAgICBpZiAob3B0aW9ucyAmJiB0eXBlb2Ygb3B0aW9ucy5qc3ggPT09ICdib29sZWFuJyAmJiBvcHRpb25zLmpzeCkge1xyXG5cdCAgICAgICAgcGFyc2VyID0gbmV3IGpzeF9wYXJzZXJfMS5KU1hQYXJzZXIoY29kZSwgb3B0aW9ucywgcGFyc2VyRGVsZWdhdGUpO1xyXG5cdCAgICB9XHJcblx0ICAgIGVsc2Uge1xyXG5cdCAgICAgICAgcGFyc2VyID0gbmV3IHBhcnNlcl8xLlBhcnNlcihjb2RlLCBvcHRpb25zLCBwYXJzZXJEZWxlZ2F0ZSk7XHJcblx0ICAgIH1cclxuXHQgICAgdmFyIHByb2dyYW0gPSBpc01vZHVsZSA/IHBhcnNlci5wYXJzZU1vZHVsZSgpIDogcGFyc2VyLnBhcnNlU2NyaXB0KCk7XHJcblx0ICAgIHZhciBhc3QgPSBwcm9ncmFtO1xyXG5cdCAgICBpZiAoY29sbGVjdENvbW1lbnQgJiYgY29tbWVudEhhbmRsZXIpIHtcclxuXHQgICAgICAgIGFzdC5jb21tZW50cyA9IGNvbW1lbnRIYW5kbGVyLmNvbW1lbnRzO1xyXG5cdCAgICB9XHJcblx0ICAgIGlmIChwYXJzZXIuY29uZmlnLnRva2Vucykge1xyXG5cdCAgICAgICAgYXN0LnRva2VucyA9IHBhcnNlci50b2tlbnM7XHJcblx0ICAgIH1cclxuXHQgICAgaWYgKHBhcnNlci5jb25maWcudG9sZXJhbnQpIHtcclxuXHQgICAgICAgIGFzdC5lcnJvcnMgPSBwYXJzZXIuZXJyb3JIYW5kbGVyLmVycm9ycztcclxuXHQgICAgfVxyXG5cdCAgICByZXR1cm4gYXN0O1xyXG5cdH1cclxuXHRleHBvcnRzLnBhcnNlID0gcGFyc2U7XHJcblx0ZnVuY3Rpb24gcGFyc2VNb2R1bGUoY29kZSwgb3B0aW9ucywgZGVsZWdhdGUpIHtcclxuXHQgICAgdmFyIHBhcnNpbmdPcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcclxuXHQgICAgcGFyc2luZ09wdGlvbnMuc291cmNlVHlwZSA9ICdtb2R1bGUnO1xyXG5cdCAgICByZXR1cm4gcGFyc2UoY29kZSwgcGFyc2luZ09wdGlvbnMsIGRlbGVnYXRlKTtcclxuXHR9XHJcblx0ZXhwb3J0cy5wYXJzZU1vZHVsZSA9IHBhcnNlTW9kdWxlO1xyXG5cdGZ1bmN0aW9uIHBhcnNlU2NyaXB0KGNvZGUsIG9wdGlvbnMsIGRlbGVnYXRlKSB7XHJcblx0ICAgIHZhciBwYXJzaW5nT3B0aW9ucyA9IG9wdGlvbnMgfHwge307XHJcblx0ICAgIHBhcnNpbmdPcHRpb25zLnNvdXJjZVR5cGUgPSAnc2NyaXB0JztcclxuXHQgICAgcmV0dXJuIHBhcnNlKGNvZGUsIHBhcnNpbmdPcHRpb25zLCBkZWxlZ2F0ZSk7XHJcblx0fVxyXG5cdGV4cG9ydHMucGFyc2VTY3JpcHQgPSBwYXJzZVNjcmlwdDtcclxuXHRmdW5jdGlvbiB0b2tlbml6ZShjb2RlLCBvcHRpb25zLCBkZWxlZ2F0ZSkge1xyXG5cdCAgICB2YXIgdG9rZW5pemVyID0gbmV3IHRva2VuaXplcl8xLlRva2VuaXplcihjb2RlLCBvcHRpb25zKTtcclxuXHQgICAgdmFyIHRva2VucztcclxuXHQgICAgdG9rZW5zID0gW107XHJcblx0ICAgIHRyeSB7XHJcblx0ICAgICAgICB3aGlsZSAodHJ1ZSkge1xyXG5cdCAgICAgICAgICAgIHZhciB0b2tlbiA9IHRva2VuaXplci5nZXROZXh0VG9rZW4oKTtcclxuXHQgICAgICAgICAgICBpZiAoIXRva2VuKSB7XHJcblx0ICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICBpZiAoZGVsZWdhdGUpIHtcclxuXHQgICAgICAgICAgICAgICAgdG9rZW4gPSBkZWxlZ2F0ZSh0b2tlbik7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgIHRva2Vucy5wdXNoKHRva2VuKTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgfVxyXG5cdCAgICBjYXRjaCAoZSkge1xyXG5cdCAgICAgICAgdG9rZW5pemVyLmVycm9ySGFuZGxlci50b2xlcmF0ZShlKTtcclxuXHQgICAgfVxyXG5cdCAgICBpZiAodG9rZW5pemVyLmVycm9ySGFuZGxlci50b2xlcmFudCkge1xyXG5cdCAgICAgICAgdG9rZW5zLmVycm9ycyA9IHRva2VuaXplci5lcnJvcnMoKTtcclxuXHQgICAgfVxyXG5cdCAgICByZXR1cm4gdG9rZW5zO1xyXG5cdH1cclxuXHRleHBvcnRzLnRva2VuaXplID0gdG9rZW5pemU7XHJcblx0dmFyIHN5bnRheF8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygyKTtcclxuXHRleHBvcnRzLlN5bnRheCA9IHN5bnRheF8xLlN5bnRheDtcclxuXHQvLyBTeW5jIHdpdGggKi5qc29uIG1hbmlmZXN0cy5cclxuXHRleHBvcnRzLnZlcnNpb24gPSAnNC4wLjAnO1xyXG5cblxuLyoqKi8gfSxcbi8qIDEgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cdFwidXNlIHN0cmljdFwiO1xyXG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuXHR2YXIgc3ludGF4XzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIpO1xyXG5cdHZhciBDb21tZW50SGFuZGxlciA9IChmdW5jdGlvbiAoKSB7XHJcblx0ICAgIGZ1bmN0aW9uIENvbW1lbnRIYW5kbGVyKCkge1xyXG5cdCAgICAgICAgdGhpcy5hdHRhY2ggPSBmYWxzZTtcclxuXHQgICAgICAgIHRoaXMuY29tbWVudHMgPSBbXTtcclxuXHQgICAgICAgIHRoaXMuc3RhY2sgPSBbXTtcclxuXHQgICAgICAgIHRoaXMubGVhZGluZyA9IFtdO1xyXG5cdCAgICAgICAgdGhpcy50cmFpbGluZyA9IFtdO1xyXG5cdCAgICB9XHJcblx0ICAgIENvbW1lbnRIYW5kbGVyLnByb3RvdHlwZS5pbnNlcnRJbm5lckNvbW1lbnRzID0gZnVuY3Rpb24gKG5vZGUsIG1ldGFkYXRhKSB7XHJcblx0ICAgICAgICAvLyAgaW5ubmVyQ29tbWVudHMgZm9yIHByb3BlcnRpZXMgZW1wdHkgYmxvY2tcclxuXHQgICAgICAgIC8vICBgZnVuY3Rpb24gYSgpIHsvKiogY29tbWVudHMgKipcXC99YFxyXG5cdCAgICAgICAgaWYgKG5vZGUudHlwZSA9PT0gc3ludGF4XzEuU3ludGF4LkJsb2NrU3RhdGVtZW50ICYmIG5vZGUuYm9keS5sZW5ndGggPT09IDApIHtcclxuXHQgICAgICAgICAgICB2YXIgaW5uZXJDb21tZW50cyA9IFtdO1xyXG5cdCAgICAgICAgICAgIGZvciAodmFyIGkgPSB0aGlzLmxlYWRpbmcubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcclxuXHQgICAgICAgICAgICAgICAgdmFyIGVudHJ5ID0gdGhpcy5sZWFkaW5nW2ldO1xyXG5cdCAgICAgICAgICAgICAgICBpZiAobWV0YWRhdGEuZW5kLm9mZnNldCA+PSBlbnRyeS5zdGFydCkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgaW5uZXJDb21tZW50cy51bnNoaWZ0KGVudHJ5LmNvbW1lbnQpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgdGhpcy5sZWFkaW5nLnNwbGljZShpLCAxKTtcclxuXHQgICAgICAgICAgICAgICAgICAgIHRoaXMudHJhaWxpbmcuc3BsaWNlKGksIDEpO1xyXG5cdCAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgIGlmIChpbm5lckNvbW1lbnRzLmxlbmd0aCkge1xyXG5cdCAgICAgICAgICAgICAgICBub2RlLmlubmVyQ29tbWVudHMgPSBpbm5lckNvbW1lbnRzO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgIH1cclxuXHQgICAgfTtcclxuXHQgICAgQ29tbWVudEhhbmRsZXIucHJvdG90eXBlLmZpbmRUcmFpbGluZ0NvbW1lbnRzID0gZnVuY3Rpb24gKG1ldGFkYXRhKSB7XHJcblx0ICAgICAgICB2YXIgdHJhaWxpbmdDb21tZW50cyA9IFtdO1xyXG5cdCAgICAgICAgaWYgKHRoaXMudHJhaWxpbmcubGVuZ3RoID4gMCkge1xyXG5cdCAgICAgICAgICAgIGZvciAodmFyIGkgPSB0aGlzLnRyYWlsaW5nLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XHJcblx0ICAgICAgICAgICAgICAgIHZhciBlbnRyeV8xID0gdGhpcy50cmFpbGluZ1tpXTtcclxuXHQgICAgICAgICAgICAgICAgaWYgKGVudHJ5XzEuc3RhcnQgPj0gbWV0YWRhdGEuZW5kLm9mZnNldCkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgdHJhaWxpbmdDb21tZW50cy51bnNoaWZ0KGVudHJ5XzEuY29tbWVudCk7XHJcblx0ICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgdGhpcy50cmFpbGluZy5sZW5ndGggPSAwO1xyXG5cdCAgICAgICAgICAgIHJldHVybiB0cmFpbGluZ0NvbW1lbnRzO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgdmFyIGVudHJ5ID0gdGhpcy5zdGFja1t0aGlzLnN0YWNrLmxlbmd0aCAtIDFdO1xyXG5cdCAgICAgICAgaWYgKGVudHJ5ICYmIGVudHJ5Lm5vZGUudHJhaWxpbmdDb21tZW50cykge1xyXG5cdCAgICAgICAgICAgIHZhciBmaXJzdENvbW1lbnQgPSBlbnRyeS5ub2RlLnRyYWlsaW5nQ29tbWVudHNbMF07XHJcblx0ICAgICAgICAgICAgaWYgKGZpcnN0Q29tbWVudCAmJiBmaXJzdENvbW1lbnQucmFuZ2VbMF0gPj0gbWV0YWRhdGEuZW5kLm9mZnNldCkge1xyXG5cdCAgICAgICAgICAgICAgICB0cmFpbGluZ0NvbW1lbnRzID0gZW50cnkubm9kZS50cmFpbGluZ0NvbW1lbnRzO1xyXG5cdCAgICAgICAgICAgICAgICBkZWxldGUgZW50cnkubm9kZS50cmFpbGluZ0NvbW1lbnRzO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIHJldHVybiB0cmFpbGluZ0NvbW1lbnRzO1xyXG5cdCAgICB9O1xyXG5cdCAgICBDb21tZW50SGFuZGxlci5wcm90b3R5cGUuZmluZExlYWRpbmdDb21tZW50cyA9IGZ1bmN0aW9uIChtZXRhZGF0YSkge1xyXG5cdCAgICAgICAgdmFyIGxlYWRpbmdDb21tZW50cyA9IFtdO1xyXG5cdCAgICAgICAgdmFyIHRhcmdldDtcclxuXHQgICAgICAgIHdoaWxlICh0aGlzLnN0YWNrLmxlbmd0aCA+IDApIHtcclxuXHQgICAgICAgICAgICB2YXIgZW50cnkgPSB0aGlzLnN0YWNrW3RoaXMuc3RhY2subGVuZ3RoIC0gMV07XHJcblx0ICAgICAgICAgICAgaWYgKGVudHJ5ICYmIGVudHJ5LnN0YXJ0ID49IG1ldGFkYXRhLnN0YXJ0Lm9mZnNldCkge1xyXG5cdCAgICAgICAgICAgICAgICB0YXJnZXQgPSBlbnRyeS5ub2RlO1xyXG5cdCAgICAgICAgICAgICAgICB0aGlzLnN0YWNrLnBvcCgpO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICBlbHNlIHtcclxuXHQgICAgICAgICAgICAgICAgYnJlYWs7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgaWYgKHRhcmdldCkge1xyXG5cdCAgICAgICAgICAgIHZhciBjb3VudCA9IHRhcmdldC5sZWFkaW5nQ29tbWVudHMgPyB0YXJnZXQubGVhZGluZ0NvbW1lbnRzLmxlbmd0aCA6IDA7XHJcblx0ICAgICAgICAgICAgZm9yICh2YXIgaSA9IGNvdW50IC0gMTsgaSA+PSAwOyAtLWkpIHtcclxuXHQgICAgICAgICAgICAgICAgdmFyIGNvbW1lbnQgPSB0YXJnZXQubGVhZGluZ0NvbW1lbnRzW2ldO1xyXG5cdCAgICAgICAgICAgICAgICBpZiAoY29tbWVudC5yYW5nZVsxXSA8PSBtZXRhZGF0YS5zdGFydC5vZmZzZXQpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgIGxlYWRpbmdDb21tZW50cy51bnNoaWZ0KGNvbW1lbnQpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgdGFyZ2V0LmxlYWRpbmdDb21tZW50cy5zcGxpY2UoaSwgMSk7XHJcblx0ICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgaWYgKHRhcmdldC5sZWFkaW5nQ29tbWVudHMgJiYgdGFyZ2V0LmxlYWRpbmdDb21tZW50cy5sZW5ndGggPT09IDApIHtcclxuXHQgICAgICAgICAgICAgICAgZGVsZXRlIHRhcmdldC5sZWFkaW5nQ29tbWVudHM7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgIHJldHVybiBsZWFkaW5nQ29tbWVudHM7XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICBmb3IgKHZhciBpID0gdGhpcy5sZWFkaW5nLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XHJcblx0ICAgICAgICAgICAgdmFyIGVudHJ5ID0gdGhpcy5sZWFkaW5nW2ldO1xyXG5cdCAgICAgICAgICAgIGlmIChlbnRyeS5zdGFydCA8PSBtZXRhZGF0YS5zdGFydC5vZmZzZXQpIHtcclxuXHQgICAgICAgICAgICAgICAgbGVhZGluZ0NvbW1lbnRzLnVuc2hpZnQoZW50cnkuY29tbWVudCk7XHJcblx0ICAgICAgICAgICAgICAgIHRoaXMubGVhZGluZy5zcGxpY2UoaSwgMSk7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgcmV0dXJuIGxlYWRpbmdDb21tZW50cztcclxuXHQgICAgfTtcclxuXHQgICAgQ29tbWVudEhhbmRsZXIucHJvdG90eXBlLnZpc2l0Tm9kZSA9IGZ1bmN0aW9uIChub2RlLCBtZXRhZGF0YSkge1xyXG5cdCAgICAgICAgaWYgKG5vZGUudHlwZSA9PT0gc3ludGF4XzEuU3ludGF4LlByb2dyYW0gJiYgbm9kZS5ib2R5Lmxlbmd0aCA+IDApIHtcclxuXHQgICAgICAgICAgICByZXR1cm47XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICB0aGlzLmluc2VydElubmVyQ29tbWVudHMobm9kZSwgbWV0YWRhdGEpO1xyXG5cdCAgICAgICAgdmFyIHRyYWlsaW5nQ29tbWVudHMgPSB0aGlzLmZpbmRUcmFpbGluZ0NvbW1lbnRzKG1ldGFkYXRhKTtcclxuXHQgICAgICAgIHZhciBsZWFkaW5nQ29tbWVudHMgPSB0aGlzLmZpbmRMZWFkaW5nQ29tbWVudHMobWV0YWRhdGEpO1xyXG5cdCAgICAgICAgaWYgKGxlYWRpbmdDb21tZW50cy5sZW5ndGggPiAwKSB7XHJcblx0ICAgICAgICAgICAgbm9kZS5sZWFkaW5nQ29tbWVudHMgPSBsZWFkaW5nQ29tbWVudHM7XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICBpZiAodHJhaWxpbmdDb21tZW50cy5sZW5ndGggPiAwKSB7XHJcblx0ICAgICAgICAgICAgbm9kZS50cmFpbGluZ0NvbW1lbnRzID0gdHJhaWxpbmdDb21tZW50cztcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIHRoaXMuc3RhY2sucHVzaCh7XHJcblx0ICAgICAgICAgICAgbm9kZTogbm9kZSxcclxuXHQgICAgICAgICAgICBzdGFydDogbWV0YWRhdGEuc3RhcnQub2Zmc2V0XHJcblx0ICAgICAgICB9KTtcclxuXHQgICAgfTtcclxuXHQgICAgQ29tbWVudEhhbmRsZXIucHJvdG90eXBlLnZpc2l0Q29tbWVudCA9IGZ1bmN0aW9uIChub2RlLCBtZXRhZGF0YSkge1xyXG5cdCAgICAgICAgdmFyIHR5cGUgPSAobm9kZS50eXBlWzBdID09PSAnTCcpID8gJ0xpbmUnIDogJ0Jsb2NrJztcclxuXHQgICAgICAgIHZhciBjb21tZW50ID0ge1xyXG5cdCAgICAgICAgICAgIHR5cGU6IHR5cGUsXHJcblx0ICAgICAgICAgICAgdmFsdWU6IG5vZGUudmFsdWVcclxuXHQgICAgICAgIH07XHJcblx0ICAgICAgICBpZiAobm9kZS5yYW5nZSkge1xyXG5cdCAgICAgICAgICAgIGNvbW1lbnQucmFuZ2UgPSBub2RlLnJhbmdlO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgaWYgKG5vZGUubG9jKSB7XHJcblx0ICAgICAgICAgICAgY29tbWVudC5sb2MgPSBub2RlLmxvYztcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIHRoaXMuY29tbWVudHMucHVzaChjb21tZW50KTtcclxuXHQgICAgICAgIGlmICh0aGlzLmF0dGFjaCkge1xyXG5cdCAgICAgICAgICAgIHZhciBlbnRyeSA9IHtcclxuXHQgICAgICAgICAgICAgICAgY29tbWVudDoge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgdHlwZTogdHlwZSxcclxuXHQgICAgICAgICAgICAgICAgICAgIHZhbHVlOiBub2RlLnZhbHVlLFxyXG5cdCAgICAgICAgICAgICAgICAgICAgcmFuZ2U6IFttZXRhZGF0YS5zdGFydC5vZmZzZXQsIG1ldGFkYXRhLmVuZC5vZmZzZXRdXHJcblx0ICAgICAgICAgICAgICAgIH0sXHJcblx0ICAgICAgICAgICAgICAgIHN0YXJ0OiBtZXRhZGF0YS5zdGFydC5vZmZzZXRcclxuXHQgICAgICAgICAgICB9O1xyXG5cdCAgICAgICAgICAgIGlmIChub2RlLmxvYykge1xyXG5cdCAgICAgICAgICAgICAgICBlbnRyeS5jb21tZW50LmxvYyA9IG5vZGUubG9jO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICBub2RlLnR5cGUgPSB0eXBlO1xyXG5cdCAgICAgICAgICAgIHRoaXMubGVhZGluZy5wdXNoKGVudHJ5KTtcclxuXHQgICAgICAgICAgICB0aGlzLnRyYWlsaW5nLnB1c2goZW50cnkpO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICB9O1xyXG5cdCAgICBDb21tZW50SGFuZGxlci5wcm90b3R5cGUudmlzaXQgPSBmdW5jdGlvbiAobm9kZSwgbWV0YWRhdGEpIHtcclxuXHQgICAgICAgIGlmIChub2RlLnR5cGUgPT09ICdMaW5lQ29tbWVudCcpIHtcclxuXHQgICAgICAgICAgICB0aGlzLnZpc2l0Q29tbWVudChub2RlLCBtZXRhZGF0YSk7XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICBlbHNlIGlmIChub2RlLnR5cGUgPT09ICdCbG9ja0NvbW1lbnQnKSB7XHJcblx0ICAgICAgICAgICAgdGhpcy52aXNpdENvbW1lbnQobm9kZSwgbWV0YWRhdGEpO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgZWxzZSBpZiAodGhpcy5hdHRhY2gpIHtcclxuXHQgICAgICAgICAgICB0aGlzLnZpc2l0Tm9kZShub2RlLCBtZXRhZGF0YSk7XHJcblx0ICAgICAgICB9XHJcblx0ICAgIH07XHJcblx0ICAgIHJldHVybiBDb21tZW50SGFuZGxlcjtcclxuXHR9KCkpO1xyXG5cdGV4cG9ydHMuQ29tbWVudEhhbmRsZXIgPSBDb21tZW50SGFuZGxlcjtcclxuXG5cbi8qKiovIH0sXG4vKiAyICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxuXHRcInVzZSBzdHJpY3RcIjtcclxuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcblx0ZXhwb3J0cy5TeW50YXggPSB7XHJcblx0ICAgIEFzc2lnbm1lbnRFeHByZXNzaW9uOiAnQXNzaWdubWVudEV4cHJlc3Npb24nLFxyXG5cdCAgICBBc3NpZ25tZW50UGF0dGVybjogJ0Fzc2lnbm1lbnRQYXR0ZXJuJyxcclxuXHQgICAgQXJyYXlFeHByZXNzaW9uOiAnQXJyYXlFeHByZXNzaW9uJyxcclxuXHQgICAgQXJyYXlQYXR0ZXJuOiAnQXJyYXlQYXR0ZXJuJyxcclxuXHQgICAgQXJyb3dGdW5jdGlvbkV4cHJlc3Npb246ICdBcnJvd0Z1bmN0aW9uRXhwcmVzc2lvbicsXHJcblx0ICAgIEF3YWl0RXhwcmVzc2lvbjogJ0F3YWl0RXhwcmVzc2lvbicsXHJcblx0ICAgIEJsb2NrU3RhdGVtZW50OiAnQmxvY2tTdGF0ZW1lbnQnLFxyXG5cdCAgICBCaW5hcnlFeHByZXNzaW9uOiAnQmluYXJ5RXhwcmVzc2lvbicsXHJcblx0ICAgIEJyZWFrU3RhdGVtZW50OiAnQnJlYWtTdGF0ZW1lbnQnLFxyXG5cdCAgICBDYWxsRXhwcmVzc2lvbjogJ0NhbGxFeHByZXNzaW9uJyxcclxuXHQgICAgQ2F0Y2hDbGF1c2U6ICdDYXRjaENsYXVzZScsXHJcblx0ICAgIENsYXNzQm9keTogJ0NsYXNzQm9keScsXHJcblx0ICAgIENsYXNzRGVjbGFyYXRpb246ICdDbGFzc0RlY2xhcmF0aW9uJyxcclxuXHQgICAgQ2xhc3NFeHByZXNzaW9uOiAnQ2xhc3NFeHByZXNzaW9uJyxcclxuXHQgICAgQ29uZGl0aW9uYWxFeHByZXNzaW9uOiAnQ29uZGl0aW9uYWxFeHByZXNzaW9uJyxcclxuXHQgICAgQ29udGludWVTdGF0ZW1lbnQ6ICdDb250aW51ZVN0YXRlbWVudCcsXHJcblx0ICAgIERvV2hpbGVTdGF0ZW1lbnQ6ICdEb1doaWxlU3RhdGVtZW50JyxcclxuXHQgICAgRGVidWdnZXJTdGF0ZW1lbnQ6ICdEZWJ1Z2dlclN0YXRlbWVudCcsXHJcblx0ICAgIEVtcHR5U3RhdGVtZW50OiAnRW1wdHlTdGF0ZW1lbnQnLFxyXG5cdCAgICBFeHBvcnRBbGxEZWNsYXJhdGlvbjogJ0V4cG9ydEFsbERlY2xhcmF0aW9uJyxcclxuXHQgICAgRXhwb3J0RGVmYXVsdERlY2xhcmF0aW9uOiAnRXhwb3J0RGVmYXVsdERlY2xhcmF0aW9uJyxcclxuXHQgICAgRXhwb3J0TmFtZWREZWNsYXJhdGlvbjogJ0V4cG9ydE5hbWVkRGVjbGFyYXRpb24nLFxyXG5cdCAgICBFeHBvcnRTcGVjaWZpZXI6ICdFeHBvcnRTcGVjaWZpZXInLFxyXG5cdCAgICBFeHByZXNzaW9uU3RhdGVtZW50OiAnRXhwcmVzc2lvblN0YXRlbWVudCcsXHJcblx0ICAgIEZvclN0YXRlbWVudDogJ0ZvclN0YXRlbWVudCcsXHJcblx0ICAgIEZvck9mU3RhdGVtZW50OiAnRm9yT2ZTdGF0ZW1lbnQnLFxyXG5cdCAgICBGb3JJblN0YXRlbWVudDogJ0ZvckluU3RhdGVtZW50JyxcclxuXHQgICAgRnVuY3Rpb25EZWNsYXJhdGlvbjogJ0Z1bmN0aW9uRGVjbGFyYXRpb24nLFxyXG5cdCAgICBGdW5jdGlvbkV4cHJlc3Npb246ICdGdW5jdGlvbkV4cHJlc3Npb24nLFxyXG5cdCAgICBJZGVudGlmaWVyOiAnSWRlbnRpZmllcicsXHJcblx0ICAgIElmU3RhdGVtZW50OiAnSWZTdGF0ZW1lbnQnLFxyXG5cdCAgICBJbXBvcnREZWNsYXJhdGlvbjogJ0ltcG9ydERlY2xhcmF0aW9uJyxcclxuXHQgICAgSW1wb3J0RGVmYXVsdFNwZWNpZmllcjogJ0ltcG9ydERlZmF1bHRTcGVjaWZpZXInLFxyXG5cdCAgICBJbXBvcnROYW1lc3BhY2VTcGVjaWZpZXI6ICdJbXBvcnROYW1lc3BhY2VTcGVjaWZpZXInLFxyXG5cdCAgICBJbXBvcnRTcGVjaWZpZXI6ICdJbXBvcnRTcGVjaWZpZXInLFxyXG5cdCAgICBMaXRlcmFsOiAnTGl0ZXJhbCcsXHJcblx0ICAgIExhYmVsZWRTdGF0ZW1lbnQ6ICdMYWJlbGVkU3RhdGVtZW50JyxcclxuXHQgICAgTG9naWNhbEV4cHJlc3Npb246ICdMb2dpY2FsRXhwcmVzc2lvbicsXHJcblx0ICAgIE1lbWJlckV4cHJlc3Npb246ICdNZW1iZXJFeHByZXNzaW9uJyxcclxuXHQgICAgTWV0YVByb3BlcnR5OiAnTWV0YVByb3BlcnR5JyxcclxuXHQgICAgTWV0aG9kRGVmaW5pdGlvbjogJ01ldGhvZERlZmluaXRpb24nLFxyXG5cdCAgICBOZXdFeHByZXNzaW9uOiAnTmV3RXhwcmVzc2lvbicsXHJcblx0ICAgIE9iamVjdEV4cHJlc3Npb246ICdPYmplY3RFeHByZXNzaW9uJyxcclxuXHQgICAgT2JqZWN0UGF0dGVybjogJ09iamVjdFBhdHRlcm4nLFxyXG5cdCAgICBQcm9ncmFtOiAnUHJvZ3JhbScsXHJcblx0ICAgIFByb3BlcnR5OiAnUHJvcGVydHknLFxyXG5cdCAgICBSZXN0RWxlbWVudDogJ1Jlc3RFbGVtZW50JyxcclxuXHQgICAgUmV0dXJuU3RhdGVtZW50OiAnUmV0dXJuU3RhdGVtZW50JyxcclxuXHQgICAgU2VxdWVuY2VFeHByZXNzaW9uOiAnU2VxdWVuY2VFeHByZXNzaW9uJyxcclxuXHQgICAgU3ByZWFkRWxlbWVudDogJ1NwcmVhZEVsZW1lbnQnLFxyXG5cdCAgICBTdXBlcjogJ1N1cGVyJyxcclxuXHQgICAgU3dpdGNoQ2FzZTogJ1N3aXRjaENhc2UnLFxyXG5cdCAgICBTd2l0Y2hTdGF0ZW1lbnQ6ICdTd2l0Y2hTdGF0ZW1lbnQnLFxyXG5cdCAgICBUYWdnZWRUZW1wbGF0ZUV4cHJlc3Npb246ICdUYWdnZWRUZW1wbGF0ZUV4cHJlc3Npb24nLFxyXG5cdCAgICBUZW1wbGF0ZUVsZW1lbnQ6ICdUZW1wbGF0ZUVsZW1lbnQnLFxyXG5cdCAgICBUZW1wbGF0ZUxpdGVyYWw6ICdUZW1wbGF0ZUxpdGVyYWwnLFxyXG5cdCAgICBUaGlzRXhwcmVzc2lvbjogJ1RoaXNFeHByZXNzaW9uJyxcclxuXHQgICAgVGhyb3dTdGF0ZW1lbnQ6ICdUaHJvd1N0YXRlbWVudCcsXHJcblx0ICAgIFRyeVN0YXRlbWVudDogJ1RyeVN0YXRlbWVudCcsXHJcblx0ICAgIFVuYXJ5RXhwcmVzc2lvbjogJ1VuYXJ5RXhwcmVzc2lvbicsXHJcblx0ICAgIFVwZGF0ZUV4cHJlc3Npb246ICdVcGRhdGVFeHByZXNzaW9uJyxcclxuXHQgICAgVmFyaWFibGVEZWNsYXJhdGlvbjogJ1ZhcmlhYmxlRGVjbGFyYXRpb24nLFxyXG5cdCAgICBWYXJpYWJsZURlY2xhcmF0b3I6ICdWYXJpYWJsZURlY2xhcmF0b3InLFxyXG5cdCAgICBXaGlsZVN0YXRlbWVudDogJ1doaWxlU3RhdGVtZW50JyxcclxuXHQgICAgV2l0aFN0YXRlbWVudDogJ1dpdGhTdGF0ZW1lbnQnLFxyXG5cdCAgICBZaWVsZEV4cHJlc3Npb246ICdZaWVsZEV4cHJlc3Npb24nXHJcblx0fTtcclxuXG5cbi8qKiovIH0sXG4vKiAzICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXHRcInVzZSBzdHJpY3RcIjtcclxuLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cblx0dmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xyXG5cdCAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxyXG5cdCAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxyXG5cdCAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07XHJcblx0ICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xyXG5cdCAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcclxuXHQgICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxyXG5cdCAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xyXG5cdCAgICB9O1xyXG5cdH0pKCk7XHJcblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG5cdHZhciBjaGFyYWN0ZXJfMSA9IF9fd2VicGFja19yZXF1aXJlX18oNCk7XHJcblx0dmFyIEpTWE5vZGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDUpO1xyXG5cdHZhciBqc3hfc3ludGF4XzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDYpO1xyXG5cdHZhciBOb2RlID0gX193ZWJwYWNrX3JlcXVpcmVfXyg3KTtcclxuXHR2YXIgcGFyc2VyXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDgpO1xyXG5cdHZhciB0b2tlbl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMyk7XHJcblx0dmFyIHhodG1sX2VudGl0aWVzXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE0KTtcclxuXHR0b2tlbl8xLlRva2VuTmFtZVsxMDAgLyogSWRlbnRpZmllciAqL10gPSAnSlNYSWRlbnRpZmllcic7XHJcblx0dG9rZW5fMS5Ub2tlbk5hbWVbMTAxIC8qIFRleHQgKi9dID0gJ0pTWFRleHQnO1xyXG5cdC8vIEZ1bGx5IHF1YWxpZmllZCBlbGVtZW50IG5hbWUsIGUuZy4gPHN2ZzpwYXRoPiByZXR1cm5zIFwic3ZnOnBhdGhcIlxyXG5cdGZ1bmN0aW9uIGdldFF1YWxpZmllZEVsZW1lbnROYW1lKGVsZW1lbnROYW1lKSB7XHJcblx0ICAgIHZhciBxdWFsaWZpZWROYW1lO1xyXG5cdCAgICBzd2l0Y2ggKGVsZW1lbnROYW1lLnR5cGUpIHtcclxuXHQgICAgICAgIGNhc2UganN4X3N5bnRheF8xLkpTWFN5bnRheC5KU1hJZGVudGlmaWVyOlxyXG5cdCAgICAgICAgICAgIHZhciBpZCA9IGVsZW1lbnROYW1lO1xyXG5cdCAgICAgICAgICAgIHF1YWxpZmllZE5hbWUgPSBpZC5uYW1lO1xyXG5cdCAgICAgICAgICAgIGJyZWFrO1xyXG5cdCAgICAgICAgY2FzZSBqc3hfc3ludGF4XzEuSlNYU3ludGF4LkpTWE5hbWVzcGFjZWROYW1lOlxyXG5cdCAgICAgICAgICAgIHZhciBucyA9IGVsZW1lbnROYW1lO1xyXG5cdCAgICAgICAgICAgIHF1YWxpZmllZE5hbWUgPSBnZXRRdWFsaWZpZWRFbGVtZW50TmFtZShucy5uYW1lc3BhY2UpICsgJzonICtcclxuXHQgICAgICAgICAgICAgICAgZ2V0UXVhbGlmaWVkRWxlbWVudE5hbWUobnMubmFtZSk7XHJcblx0ICAgICAgICAgICAgYnJlYWs7XHJcblx0ICAgICAgICBjYXNlIGpzeF9zeW50YXhfMS5KU1hTeW50YXguSlNYTWVtYmVyRXhwcmVzc2lvbjpcclxuXHQgICAgICAgICAgICB2YXIgZXhwciA9IGVsZW1lbnROYW1lO1xyXG5cdCAgICAgICAgICAgIHF1YWxpZmllZE5hbWUgPSBnZXRRdWFsaWZpZWRFbGVtZW50TmFtZShleHByLm9iamVjdCkgKyAnLicgK1xyXG5cdCAgICAgICAgICAgICAgICBnZXRRdWFsaWZpZWRFbGVtZW50TmFtZShleHByLnByb3BlcnR5KTtcclxuXHQgICAgICAgICAgICBicmVhaztcclxuXHQgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXHJcblx0ICAgICAgICBkZWZhdWx0OlxyXG5cdCAgICAgICAgICAgIGJyZWFrO1xyXG5cdCAgICB9XHJcblx0ICAgIHJldHVybiBxdWFsaWZpZWROYW1lO1xyXG5cdH1cclxuXHR2YXIgSlNYUGFyc2VyID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuXHQgICAgX19leHRlbmRzKEpTWFBhcnNlciwgX3N1cGVyKTtcclxuXHQgICAgZnVuY3Rpb24gSlNYUGFyc2VyKGNvZGUsIG9wdGlvbnMsIGRlbGVnYXRlKSB7XHJcblx0ICAgICAgICByZXR1cm4gX3N1cGVyLmNhbGwodGhpcywgY29kZSwgb3B0aW9ucywgZGVsZWdhdGUpIHx8IHRoaXM7XHJcblx0ICAgIH1cclxuXHQgICAgSlNYUGFyc2VyLnByb3RvdHlwZS5wYXJzZVByaW1hcnlFeHByZXNzaW9uID0gZnVuY3Rpb24gKCkge1xyXG5cdCAgICAgICAgcmV0dXJuIHRoaXMubWF0Y2goJzwnKSA/IHRoaXMucGFyc2VKU1hSb290KCkgOiBfc3VwZXIucHJvdG90eXBlLnBhcnNlUHJpbWFyeUV4cHJlc3Npb24uY2FsbCh0aGlzKTtcclxuXHQgICAgfTtcclxuXHQgICAgSlNYUGFyc2VyLnByb3RvdHlwZS5zdGFydEpTWCA9IGZ1bmN0aW9uICgpIHtcclxuXHQgICAgICAgIC8vIFVud2luZCB0aGUgc2Nhbm5lciBiZWZvcmUgdGhlIGxvb2thaGVhZCB0b2tlbi5cclxuXHQgICAgICAgIHRoaXMuc2Nhbm5lci5pbmRleCA9IHRoaXMuc3RhcnRNYXJrZXIuaW5kZXg7XHJcblx0ICAgICAgICB0aGlzLnNjYW5uZXIubGluZU51bWJlciA9IHRoaXMuc3RhcnRNYXJrZXIubGluZTtcclxuXHQgICAgICAgIHRoaXMuc2Nhbm5lci5saW5lU3RhcnQgPSB0aGlzLnN0YXJ0TWFya2VyLmluZGV4IC0gdGhpcy5zdGFydE1hcmtlci5jb2x1bW47XHJcblx0ICAgIH07XHJcblx0ICAgIEpTWFBhcnNlci5wcm90b3R5cGUuZmluaXNoSlNYID0gZnVuY3Rpb24gKCkge1xyXG5cdCAgICAgICAgLy8gUHJpbWUgdGhlIG5leHQgbG9va2FoZWFkLlxyXG5cdCAgICAgICAgdGhpcy5uZXh0VG9rZW4oKTtcclxuXHQgICAgfTtcclxuXHQgICAgSlNYUGFyc2VyLnByb3RvdHlwZS5yZWVudGVySlNYID0gZnVuY3Rpb24gKCkge1xyXG5cdCAgICAgICAgdGhpcy5zdGFydEpTWCgpO1xyXG5cdCAgICAgICAgdGhpcy5leHBlY3RKU1goJ30nKTtcclxuXHQgICAgICAgIC8vIFBvcCB0aGUgY2xvc2luZyAnfScgYWRkZWQgZnJvbSB0aGUgbG9va2FoZWFkLlxyXG5cdCAgICAgICAgaWYgKHRoaXMuY29uZmlnLnRva2Vucykge1xyXG5cdCAgICAgICAgICAgIHRoaXMudG9rZW5zLnBvcCgpO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICB9O1xyXG5cdCAgICBKU1hQYXJzZXIucHJvdG90eXBlLmNyZWF0ZUpTWE5vZGUgPSBmdW5jdGlvbiAoKSB7XHJcblx0ICAgICAgICB0aGlzLmNvbGxlY3RDb21tZW50cygpO1xyXG5cdCAgICAgICAgcmV0dXJuIHtcclxuXHQgICAgICAgICAgICBpbmRleDogdGhpcy5zY2FubmVyLmluZGV4LFxyXG5cdCAgICAgICAgICAgIGxpbmU6IHRoaXMuc2Nhbm5lci5saW5lTnVtYmVyLFxyXG5cdCAgICAgICAgICAgIGNvbHVtbjogdGhpcy5zY2FubmVyLmluZGV4IC0gdGhpcy5zY2FubmVyLmxpbmVTdGFydFxyXG5cdCAgICAgICAgfTtcclxuXHQgICAgfTtcclxuXHQgICAgSlNYUGFyc2VyLnByb3RvdHlwZS5jcmVhdGVKU1hDaGlsZE5vZGUgPSBmdW5jdGlvbiAoKSB7XHJcblx0ICAgICAgICByZXR1cm4ge1xyXG5cdCAgICAgICAgICAgIGluZGV4OiB0aGlzLnNjYW5uZXIuaW5kZXgsXHJcblx0ICAgICAgICAgICAgbGluZTogdGhpcy5zY2FubmVyLmxpbmVOdW1iZXIsXHJcblx0ICAgICAgICAgICAgY29sdW1uOiB0aGlzLnNjYW5uZXIuaW5kZXggLSB0aGlzLnNjYW5uZXIubGluZVN0YXJ0XHJcblx0ICAgICAgICB9O1xyXG5cdCAgICB9O1xyXG5cdCAgICBKU1hQYXJzZXIucHJvdG90eXBlLnNjYW5YSFRNTEVudGl0eSA9IGZ1bmN0aW9uIChxdW90ZSkge1xyXG5cdCAgICAgICAgdmFyIHJlc3VsdCA9ICcmJztcclxuXHQgICAgICAgIHZhciB2YWxpZCA9IHRydWU7XHJcblx0ICAgICAgICB2YXIgdGVybWluYXRlZCA9IGZhbHNlO1xyXG5cdCAgICAgICAgdmFyIG51bWVyaWMgPSBmYWxzZTtcclxuXHQgICAgICAgIHZhciBoZXggPSBmYWxzZTtcclxuXHQgICAgICAgIHdoaWxlICghdGhpcy5zY2FubmVyLmVvZigpICYmIHZhbGlkICYmICF0ZXJtaW5hdGVkKSB7XHJcblx0ICAgICAgICAgICAgdmFyIGNoID0gdGhpcy5zY2FubmVyLnNvdXJjZVt0aGlzLnNjYW5uZXIuaW5kZXhdO1xyXG5cdCAgICAgICAgICAgIGlmIChjaCA9PT0gcXVvdGUpIHtcclxuXHQgICAgICAgICAgICAgICAgYnJlYWs7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgIHRlcm1pbmF0ZWQgPSAoY2ggPT09ICc7Jyk7XHJcblx0ICAgICAgICAgICAgcmVzdWx0ICs9IGNoO1xyXG5cdCAgICAgICAgICAgICsrdGhpcy5zY2FubmVyLmluZGV4O1xyXG5cdCAgICAgICAgICAgIGlmICghdGVybWluYXRlZCkge1xyXG5cdCAgICAgICAgICAgICAgICBzd2l0Y2ggKHJlc3VsdC5sZW5ndGgpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgIGNhc2UgMjpcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAvLyBlLmcuICcmIzEyMzsnXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgbnVtZXJpYyA9IChjaCA9PT0gJyMnKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuXHQgICAgICAgICAgICAgICAgICAgIGNhc2UgMzpcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBpZiAobnVtZXJpYykge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBlLmcuICcmI3g0MTsnXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhleCA9IChjaCA9PT0gJ3gnKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsaWQgPSBoZXggfHwgY2hhcmFjdGVyXzEuQ2hhcmFjdGVyLmlzRGVjaW1hbERpZ2l0KGNoLmNoYXJDb2RlQXQoMCkpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBudW1lcmljID0gbnVtZXJpYyAmJiAhaGV4O1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuXHQgICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdmFsaWQgPSB2YWxpZCAmJiAhKG51bWVyaWMgJiYgIWNoYXJhY3Rlcl8xLkNoYXJhY3Rlci5pc0RlY2ltYWxEaWdpdChjaC5jaGFyQ29kZUF0KDApKSk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdmFsaWQgPSB2YWxpZCAmJiAhKGhleCAmJiAhY2hhcmFjdGVyXzEuQ2hhcmFjdGVyLmlzSGV4RGlnaXQoY2guY2hhckNvZGVBdCgwKSkpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cdCAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgaWYgKHZhbGlkICYmIHRlcm1pbmF0ZWQgJiYgcmVzdWx0Lmxlbmd0aCA+IDIpIHtcclxuXHQgICAgICAgICAgICAvLyBlLmcuICcmI3g0MTsnIGJlY29tZXMganVzdCAnI3g0MSdcclxuXHQgICAgICAgICAgICB2YXIgc3RyID0gcmVzdWx0LnN1YnN0cigxLCByZXN1bHQubGVuZ3RoIC0gMik7XHJcblx0ICAgICAgICAgICAgaWYgKG51bWVyaWMgJiYgc3RyLmxlbmd0aCA+IDEpIHtcclxuXHQgICAgICAgICAgICAgICAgcmVzdWx0ID0gU3RyaW5nLmZyb21DaGFyQ29kZShwYXJzZUludChzdHIuc3Vic3RyKDEpLCAxMCkpO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICBlbHNlIGlmIChoZXggJiYgc3RyLmxlbmd0aCA+IDIpIHtcclxuXHQgICAgICAgICAgICAgICAgcmVzdWx0ID0gU3RyaW5nLmZyb21DaGFyQ29kZShwYXJzZUludCgnMCcgKyBzdHIuc3Vic3RyKDEpLCAxNikpO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICBlbHNlIGlmICghbnVtZXJpYyAmJiAhaGV4ICYmIHhodG1sX2VudGl0aWVzXzEuWEhUTUxFbnRpdGllc1tzdHJdKSB7XHJcblx0ICAgICAgICAgICAgICAgIHJlc3VsdCA9IHhodG1sX2VudGl0aWVzXzEuWEhUTUxFbnRpdGllc1tzdHJdO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIHJldHVybiByZXN1bHQ7XHJcblx0ICAgIH07XHJcblx0ICAgIC8vIFNjYW4gdGhlIG5leHQgSlNYIHRva2VuLiBUaGlzIHJlcGxhY2VzIFNjYW5uZXIjbGV4IHdoZW4gaW4gSlNYIG1vZGUuXHJcblx0ICAgIEpTWFBhcnNlci5wcm90b3R5cGUubGV4SlNYID0gZnVuY3Rpb24gKCkge1xyXG5cdCAgICAgICAgdmFyIGNwID0gdGhpcy5zY2FubmVyLnNvdXJjZS5jaGFyQ29kZUF0KHRoaXMuc2Nhbm5lci5pbmRleCk7XHJcblx0ICAgICAgICAvLyA8ID4gLyA6ID0geyB9XHJcblx0ICAgICAgICBpZiAoY3AgPT09IDYwIHx8IGNwID09PSA2MiB8fCBjcCA9PT0gNDcgfHwgY3AgPT09IDU4IHx8IGNwID09PSA2MSB8fCBjcCA9PT0gMTIzIHx8IGNwID09PSAxMjUpIHtcclxuXHQgICAgICAgICAgICB2YXIgdmFsdWUgPSB0aGlzLnNjYW5uZXIuc291cmNlW3RoaXMuc2Nhbm5lci5pbmRleCsrXTtcclxuXHQgICAgICAgICAgICByZXR1cm4ge1xyXG5cdCAgICAgICAgICAgICAgICB0eXBlOiA3IC8qIFB1bmN0dWF0b3IgKi8sXHJcblx0ICAgICAgICAgICAgICAgIHZhbHVlOiB2YWx1ZSxcclxuXHQgICAgICAgICAgICAgICAgbGluZU51bWJlcjogdGhpcy5zY2FubmVyLmxpbmVOdW1iZXIsXHJcblx0ICAgICAgICAgICAgICAgIGxpbmVTdGFydDogdGhpcy5zY2FubmVyLmxpbmVTdGFydCxcclxuXHQgICAgICAgICAgICAgICAgc3RhcnQ6IHRoaXMuc2Nhbm5lci5pbmRleCAtIDEsXHJcblx0ICAgICAgICAgICAgICAgIGVuZDogdGhpcy5zY2FubmVyLmluZGV4XHJcblx0ICAgICAgICAgICAgfTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIC8vIFwiICdcclxuXHQgICAgICAgIGlmIChjcCA9PT0gMzQgfHwgY3AgPT09IDM5KSB7XHJcblx0ICAgICAgICAgICAgdmFyIHN0YXJ0ID0gdGhpcy5zY2FubmVyLmluZGV4O1xyXG5cdCAgICAgICAgICAgIHZhciBxdW90ZSA9IHRoaXMuc2Nhbm5lci5zb3VyY2VbdGhpcy5zY2FubmVyLmluZGV4KytdO1xyXG5cdCAgICAgICAgICAgIHZhciBzdHIgPSAnJztcclxuXHQgICAgICAgICAgICB3aGlsZSAoIXRoaXMuc2Nhbm5lci5lb2YoKSkge1xyXG5cdCAgICAgICAgICAgICAgICB2YXIgY2ggPSB0aGlzLnNjYW5uZXIuc291cmNlW3RoaXMuc2Nhbm5lci5pbmRleCsrXTtcclxuXHQgICAgICAgICAgICAgICAgaWYgKGNoID09PSBxdW90ZSkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcblx0ICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgZWxzZSBpZiAoY2ggPT09ICcmJykge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgc3RyICs9IHRoaXMuc2NhblhIVE1MRW50aXR5KHF1b3RlKTtcclxuXHQgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICBlbHNlIHtcclxuXHQgICAgICAgICAgICAgICAgICAgIHN0ciArPSBjaDtcclxuXHQgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICByZXR1cm4ge1xyXG5cdCAgICAgICAgICAgICAgICB0eXBlOiA4IC8qIFN0cmluZ0xpdGVyYWwgKi8sXHJcblx0ICAgICAgICAgICAgICAgIHZhbHVlOiBzdHIsXHJcblx0ICAgICAgICAgICAgICAgIGxpbmVOdW1iZXI6IHRoaXMuc2Nhbm5lci5saW5lTnVtYmVyLFxyXG5cdCAgICAgICAgICAgICAgICBsaW5lU3RhcnQ6IHRoaXMuc2Nhbm5lci5saW5lU3RhcnQsXHJcblx0ICAgICAgICAgICAgICAgIHN0YXJ0OiBzdGFydCxcclxuXHQgICAgICAgICAgICAgICAgZW5kOiB0aGlzLnNjYW5uZXIuaW5kZXhcclxuXHQgICAgICAgICAgICB9O1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgLy8gLi4uIG9yIC5cclxuXHQgICAgICAgIGlmIChjcCA9PT0gNDYpIHtcclxuXHQgICAgICAgICAgICB2YXIgbjEgPSB0aGlzLnNjYW5uZXIuc291cmNlLmNoYXJDb2RlQXQodGhpcy5zY2FubmVyLmluZGV4ICsgMSk7XHJcblx0ICAgICAgICAgICAgdmFyIG4yID0gdGhpcy5zY2FubmVyLnNvdXJjZS5jaGFyQ29kZUF0KHRoaXMuc2Nhbm5lci5pbmRleCArIDIpO1xyXG5cdCAgICAgICAgICAgIHZhciB2YWx1ZSA9IChuMSA9PT0gNDYgJiYgbjIgPT09IDQ2KSA/ICcuLi4nIDogJy4nO1xyXG5cdCAgICAgICAgICAgIHZhciBzdGFydCA9IHRoaXMuc2Nhbm5lci5pbmRleDtcclxuXHQgICAgICAgICAgICB0aGlzLnNjYW5uZXIuaW5kZXggKz0gdmFsdWUubGVuZ3RoO1xyXG5cdCAgICAgICAgICAgIHJldHVybiB7XHJcblx0ICAgICAgICAgICAgICAgIHR5cGU6IDcgLyogUHVuY3R1YXRvciAqLyxcclxuXHQgICAgICAgICAgICAgICAgdmFsdWU6IHZhbHVlLFxyXG5cdCAgICAgICAgICAgICAgICBsaW5lTnVtYmVyOiB0aGlzLnNjYW5uZXIubGluZU51bWJlcixcclxuXHQgICAgICAgICAgICAgICAgbGluZVN0YXJ0OiB0aGlzLnNjYW5uZXIubGluZVN0YXJ0LFxyXG5cdCAgICAgICAgICAgICAgICBzdGFydDogc3RhcnQsXHJcblx0ICAgICAgICAgICAgICAgIGVuZDogdGhpcy5zY2FubmVyLmluZGV4XHJcblx0ICAgICAgICAgICAgfTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIC8vIGBcclxuXHQgICAgICAgIGlmIChjcCA9PT0gOTYpIHtcclxuXHQgICAgICAgICAgICAvLyBPbmx5IHBsYWNlaG9sZGVyLCBzaW5jZSBpdCB3aWxsIGJlIHJlc2Nhbm5lZCBhcyBhIHJlYWwgYXNzaWdubWVudCBleHByZXNzaW9uLlxyXG5cdCAgICAgICAgICAgIHJldHVybiB7XHJcblx0ICAgICAgICAgICAgICAgIHR5cGU6IDEwIC8qIFRlbXBsYXRlICovLFxyXG5cdCAgICAgICAgICAgICAgICB2YWx1ZTogJycsXHJcblx0ICAgICAgICAgICAgICAgIGxpbmVOdW1iZXI6IHRoaXMuc2Nhbm5lci5saW5lTnVtYmVyLFxyXG5cdCAgICAgICAgICAgICAgICBsaW5lU3RhcnQ6IHRoaXMuc2Nhbm5lci5saW5lU3RhcnQsXHJcblx0ICAgICAgICAgICAgICAgIHN0YXJ0OiB0aGlzLnNjYW5uZXIuaW5kZXgsXHJcblx0ICAgICAgICAgICAgICAgIGVuZDogdGhpcy5zY2FubmVyLmluZGV4XHJcblx0ICAgICAgICAgICAgfTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIC8vIElkZW50aWZlciBjYW4gbm90IGNvbnRhaW4gYmFja3NsYXNoIChjaGFyIGNvZGUgOTIpLlxyXG5cdCAgICAgICAgaWYgKGNoYXJhY3Rlcl8xLkNoYXJhY3Rlci5pc0lkZW50aWZpZXJTdGFydChjcCkgJiYgKGNwICE9PSA5MikpIHtcclxuXHQgICAgICAgICAgICB2YXIgc3RhcnQgPSB0aGlzLnNjYW5uZXIuaW5kZXg7XHJcblx0ICAgICAgICAgICAgKyt0aGlzLnNjYW5uZXIuaW5kZXg7XHJcblx0ICAgICAgICAgICAgd2hpbGUgKCF0aGlzLnNjYW5uZXIuZW9mKCkpIHtcclxuXHQgICAgICAgICAgICAgICAgdmFyIGNoID0gdGhpcy5zY2FubmVyLnNvdXJjZS5jaGFyQ29kZUF0KHRoaXMuc2Nhbm5lci5pbmRleCk7XHJcblx0ICAgICAgICAgICAgICAgIGlmIChjaGFyYWN0ZXJfMS5DaGFyYWN0ZXIuaXNJZGVudGlmaWVyUGFydChjaCkgJiYgKGNoICE9PSA5MikpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICsrdGhpcy5zY2FubmVyLmluZGV4O1xyXG5cdCAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgIGVsc2UgaWYgKGNoID09PSA0NSkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgLy8gSHlwaGVuIChjaGFyIGNvZGUgNDUpIGNhbiBiZSBwYXJ0IG9mIGFuIGlkZW50aWZpZXIuXHJcblx0ICAgICAgICAgICAgICAgICAgICArK3RoaXMuc2Nhbm5lci5pbmRleDtcclxuXHQgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICBlbHNlIHtcclxuXHQgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cdCAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgIHZhciBpZCA9IHRoaXMuc2Nhbm5lci5zb3VyY2Uuc2xpY2Uoc3RhcnQsIHRoaXMuc2Nhbm5lci5pbmRleCk7XHJcblx0ICAgICAgICAgICAgcmV0dXJuIHtcclxuXHQgICAgICAgICAgICAgICAgdHlwZTogMTAwIC8qIElkZW50aWZpZXIgKi8sXHJcblx0ICAgICAgICAgICAgICAgIHZhbHVlOiBpZCxcclxuXHQgICAgICAgICAgICAgICAgbGluZU51bWJlcjogdGhpcy5zY2FubmVyLmxpbmVOdW1iZXIsXHJcblx0ICAgICAgICAgICAgICAgIGxpbmVTdGFydDogdGhpcy5zY2FubmVyLmxpbmVTdGFydCxcclxuXHQgICAgICAgICAgICAgICAgc3RhcnQ6IHN0YXJ0LFxyXG5cdCAgICAgICAgICAgICAgICBlbmQ6IHRoaXMuc2Nhbm5lci5pbmRleFxyXG5cdCAgICAgICAgICAgIH07XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICByZXR1cm4gdGhpcy5zY2FubmVyLmxleCgpO1xyXG5cdCAgICB9O1xyXG5cdCAgICBKU1hQYXJzZXIucHJvdG90eXBlLm5leHRKU1hUb2tlbiA9IGZ1bmN0aW9uICgpIHtcclxuXHQgICAgICAgIHRoaXMuY29sbGVjdENvbW1lbnRzKCk7XHJcblx0ICAgICAgICB0aGlzLnN0YXJ0TWFya2VyLmluZGV4ID0gdGhpcy5zY2FubmVyLmluZGV4O1xyXG5cdCAgICAgICAgdGhpcy5zdGFydE1hcmtlci5saW5lID0gdGhpcy5zY2FubmVyLmxpbmVOdW1iZXI7XHJcblx0ICAgICAgICB0aGlzLnN0YXJ0TWFya2VyLmNvbHVtbiA9IHRoaXMuc2Nhbm5lci5pbmRleCAtIHRoaXMuc2Nhbm5lci5saW5lU3RhcnQ7XHJcblx0ICAgICAgICB2YXIgdG9rZW4gPSB0aGlzLmxleEpTWCgpO1xyXG5cdCAgICAgICAgdGhpcy5sYXN0TWFya2VyLmluZGV4ID0gdGhpcy5zY2FubmVyLmluZGV4O1xyXG5cdCAgICAgICAgdGhpcy5sYXN0TWFya2VyLmxpbmUgPSB0aGlzLnNjYW5uZXIubGluZU51bWJlcjtcclxuXHQgICAgICAgIHRoaXMubGFzdE1hcmtlci5jb2x1bW4gPSB0aGlzLnNjYW5uZXIuaW5kZXggLSB0aGlzLnNjYW5uZXIubGluZVN0YXJ0O1xyXG5cdCAgICAgICAgaWYgKHRoaXMuY29uZmlnLnRva2Vucykge1xyXG5cdCAgICAgICAgICAgIHRoaXMudG9rZW5zLnB1c2godGhpcy5jb252ZXJ0VG9rZW4odG9rZW4pKTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIHJldHVybiB0b2tlbjtcclxuXHQgICAgfTtcclxuXHQgICAgSlNYUGFyc2VyLnByb3RvdHlwZS5uZXh0SlNYVGV4dCA9IGZ1bmN0aW9uICgpIHtcclxuXHQgICAgICAgIHRoaXMuc3RhcnRNYXJrZXIuaW5kZXggPSB0aGlzLnNjYW5uZXIuaW5kZXg7XHJcblx0ICAgICAgICB0aGlzLnN0YXJ0TWFya2VyLmxpbmUgPSB0aGlzLnNjYW5uZXIubGluZU51bWJlcjtcclxuXHQgICAgICAgIHRoaXMuc3RhcnRNYXJrZXIuY29sdW1uID0gdGhpcy5zY2FubmVyLmluZGV4IC0gdGhpcy5zY2FubmVyLmxpbmVTdGFydDtcclxuXHQgICAgICAgIHZhciBzdGFydCA9IHRoaXMuc2Nhbm5lci5pbmRleDtcclxuXHQgICAgICAgIHZhciB0ZXh0ID0gJyc7XHJcblx0ICAgICAgICB3aGlsZSAoIXRoaXMuc2Nhbm5lci5lb2YoKSkge1xyXG5cdCAgICAgICAgICAgIHZhciBjaCA9IHRoaXMuc2Nhbm5lci5zb3VyY2VbdGhpcy5zY2FubmVyLmluZGV4XTtcclxuXHQgICAgICAgICAgICBpZiAoY2ggPT09ICd7JyB8fCBjaCA9PT0gJzwnKSB7XHJcblx0ICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICArK3RoaXMuc2Nhbm5lci5pbmRleDtcclxuXHQgICAgICAgICAgICB0ZXh0ICs9IGNoO1xyXG5cdCAgICAgICAgICAgIGlmIChjaGFyYWN0ZXJfMS5DaGFyYWN0ZXIuaXNMaW5lVGVybWluYXRvcihjaC5jaGFyQ29kZUF0KDApKSkge1xyXG5cdCAgICAgICAgICAgICAgICArK3RoaXMuc2Nhbm5lci5saW5lTnVtYmVyO1xyXG5cdCAgICAgICAgICAgICAgICBpZiAoY2ggPT09ICdcXHInICYmIHRoaXMuc2Nhbm5lci5zb3VyY2VbdGhpcy5zY2FubmVyLmluZGV4XSA9PT0gJ1xcbicpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICsrdGhpcy5zY2FubmVyLmluZGV4O1xyXG5cdCAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgIHRoaXMuc2Nhbm5lci5saW5lU3RhcnQgPSB0aGlzLnNjYW5uZXIuaW5kZXg7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgdGhpcy5sYXN0TWFya2VyLmluZGV4ID0gdGhpcy5zY2FubmVyLmluZGV4O1xyXG5cdCAgICAgICAgdGhpcy5sYXN0TWFya2VyLmxpbmUgPSB0aGlzLnNjYW5uZXIubGluZU51bWJlcjtcclxuXHQgICAgICAgIHRoaXMubGFzdE1hcmtlci5jb2x1bW4gPSB0aGlzLnNjYW5uZXIuaW5kZXggLSB0aGlzLnNjYW5uZXIubGluZVN0YXJ0O1xyXG5cdCAgICAgICAgdmFyIHRva2VuID0ge1xyXG5cdCAgICAgICAgICAgIHR5cGU6IDEwMSAvKiBUZXh0ICovLFxyXG5cdCAgICAgICAgICAgIHZhbHVlOiB0ZXh0LFxyXG5cdCAgICAgICAgICAgIGxpbmVOdW1iZXI6IHRoaXMuc2Nhbm5lci5saW5lTnVtYmVyLFxyXG5cdCAgICAgICAgICAgIGxpbmVTdGFydDogdGhpcy5zY2FubmVyLmxpbmVTdGFydCxcclxuXHQgICAgICAgICAgICBzdGFydDogc3RhcnQsXHJcblx0ICAgICAgICAgICAgZW5kOiB0aGlzLnNjYW5uZXIuaW5kZXhcclxuXHQgICAgICAgIH07XHJcblx0ICAgICAgICBpZiAoKHRleHQubGVuZ3RoID4gMCkgJiYgdGhpcy5jb25maWcudG9rZW5zKSB7XHJcblx0ICAgICAgICAgICAgdGhpcy50b2tlbnMucHVzaCh0aGlzLmNvbnZlcnRUb2tlbih0b2tlbikpO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgcmV0dXJuIHRva2VuO1xyXG5cdCAgICB9O1xyXG5cdCAgICBKU1hQYXJzZXIucHJvdG90eXBlLnBlZWtKU1hUb2tlbiA9IGZ1bmN0aW9uICgpIHtcclxuXHQgICAgICAgIHZhciBzdGF0ZSA9IHRoaXMuc2Nhbm5lci5zYXZlU3RhdGUoKTtcclxuXHQgICAgICAgIHRoaXMuc2Nhbm5lci5zY2FuQ29tbWVudHMoKTtcclxuXHQgICAgICAgIHZhciBuZXh0ID0gdGhpcy5sZXhKU1goKTtcclxuXHQgICAgICAgIHRoaXMuc2Nhbm5lci5yZXN0b3JlU3RhdGUoc3RhdGUpO1xyXG5cdCAgICAgICAgcmV0dXJuIG5leHQ7XHJcblx0ICAgIH07XHJcblx0ICAgIC8vIEV4cGVjdCB0aGUgbmV4dCBKU1ggdG9rZW4gdG8gbWF0Y2ggdGhlIHNwZWNpZmllZCBwdW5jdHVhdG9yLlxyXG5cdCAgICAvLyBJZiBub3QsIGFuIGV4Y2VwdGlvbiB3aWxsIGJlIHRocm93bi5cclxuXHQgICAgSlNYUGFyc2VyLnByb3RvdHlwZS5leHBlY3RKU1ggPSBmdW5jdGlvbiAodmFsdWUpIHtcclxuXHQgICAgICAgIHZhciB0b2tlbiA9IHRoaXMubmV4dEpTWFRva2VuKCk7XHJcblx0ICAgICAgICBpZiAodG9rZW4udHlwZSAhPT0gNyAvKiBQdW5jdHVhdG9yICovIHx8IHRva2VuLnZhbHVlICE9PSB2YWx1ZSkge1xyXG5cdCAgICAgICAgICAgIHRoaXMudGhyb3dVbmV4cGVjdGVkVG9rZW4odG9rZW4pO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICB9O1xyXG5cdCAgICAvLyBSZXR1cm4gdHJ1ZSBpZiB0aGUgbmV4dCBKU1ggdG9rZW4gbWF0Y2hlcyB0aGUgc3BlY2lmaWVkIHB1bmN0dWF0b3IuXHJcblx0ICAgIEpTWFBhcnNlci5wcm90b3R5cGUubWF0Y2hKU1ggPSBmdW5jdGlvbiAodmFsdWUpIHtcclxuXHQgICAgICAgIHZhciBuZXh0ID0gdGhpcy5wZWVrSlNYVG9rZW4oKTtcclxuXHQgICAgICAgIHJldHVybiBuZXh0LnR5cGUgPT09IDcgLyogUHVuY3R1YXRvciAqLyAmJiBuZXh0LnZhbHVlID09PSB2YWx1ZTtcclxuXHQgICAgfTtcclxuXHQgICAgSlNYUGFyc2VyLnByb3RvdHlwZS5wYXJzZUpTWElkZW50aWZpZXIgPSBmdW5jdGlvbiAoKSB7XHJcblx0ICAgICAgICB2YXIgbm9kZSA9IHRoaXMuY3JlYXRlSlNYTm9kZSgpO1xyXG5cdCAgICAgICAgdmFyIHRva2VuID0gdGhpcy5uZXh0SlNYVG9rZW4oKTtcclxuXHQgICAgICAgIGlmICh0b2tlbi50eXBlICE9PSAxMDAgLyogSWRlbnRpZmllciAqLykge1xyXG5cdCAgICAgICAgICAgIHRoaXMudGhyb3dVbmV4cGVjdGVkVG9rZW4odG9rZW4pO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgcmV0dXJuIHRoaXMuZmluYWxpemUobm9kZSwgbmV3IEpTWE5vZGUuSlNYSWRlbnRpZmllcih0b2tlbi52YWx1ZSkpO1xyXG5cdCAgICB9O1xyXG5cdCAgICBKU1hQYXJzZXIucHJvdG90eXBlLnBhcnNlSlNYRWxlbWVudE5hbWUgPSBmdW5jdGlvbiAoKSB7XHJcblx0ICAgICAgICB2YXIgbm9kZSA9IHRoaXMuY3JlYXRlSlNYTm9kZSgpO1xyXG5cdCAgICAgICAgdmFyIGVsZW1lbnROYW1lID0gdGhpcy5wYXJzZUpTWElkZW50aWZpZXIoKTtcclxuXHQgICAgICAgIGlmICh0aGlzLm1hdGNoSlNYKCc6JykpIHtcclxuXHQgICAgICAgICAgICB2YXIgbmFtZXNwYWNlID0gZWxlbWVudE5hbWU7XHJcblx0ICAgICAgICAgICAgdGhpcy5leHBlY3RKU1goJzonKTtcclxuXHQgICAgICAgICAgICB2YXIgbmFtZV8xID0gdGhpcy5wYXJzZUpTWElkZW50aWZpZXIoKTtcclxuXHQgICAgICAgICAgICBlbGVtZW50TmFtZSA9IHRoaXMuZmluYWxpemUobm9kZSwgbmV3IEpTWE5vZGUuSlNYTmFtZXNwYWNlZE5hbWUobmFtZXNwYWNlLCBuYW1lXzEpKTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIGVsc2UgaWYgKHRoaXMubWF0Y2hKU1goJy4nKSkge1xyXG5cdCAgICAgICAgICAgIHdoaWxlICh0aGlzLm1hdGNoSlNYKCcuJykpIHtcclxuXHQgICAgICAgICAgICAgICAgdmFyIG9iamVjdCA9IGVsZW1lbnROYW1lO1xyXG5cdCAgICAgICAgICAgICAgICB0aGlzLmV4cGVjdEpTWCgnLicpO1xyXG5cdCAgICAgICAgICAgICAgICB2YXIgcHJvcGVydHkgPSB0aGlzLnBhcnNlSlNYSWRlbnRpZmllcigpO1xyXG5cdCAgICAgICAgICAgICAgICBlbGVtZW50TmFtZSA9IHRoaXMuZmluYWxpemUobm9kZSwgbmV3IEpTWE5vZGUuSlNYTWVtYmVyRXhwcmVzc2lvbihvYmplY3QsIHByb3BlcnR5KSk7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgcmV0dXJuIGVsZW1lbnROYW1lO1xyXG5cdCAgICB9O1xyXG5cdCAgICBKU1hQYXJzZXIucHJvdG90eXBlLnBhcnNlSlNYQXR0cmlidXRlTmFtZSA9IGZ1bmN0aW9uICgpIHtcclxuXHQgICAgICAgIHZhciBub2RlID0gdGhpcy5jcmVhdGVKU1hOb2RlKCk7XHJcblx0ICAgICAgICB2YXIgYXR0cmlidXRlTmFtZTtcclxuXHQgICAgICAgIHZhciBpZGVudGlmaWVyID0gdGhpcy5wYXJzZUpTWElkZW50aWZpZXIoKTtcclxuXHQgICAgICAgIGlmICh0aGlzLm1hdGNoSlNYKCc6JykpIHtcclxuXHQgICAgICAgICAgICB2YXIgbmFtZXNwYWNlID0gaWRlbnRpZmllcjtcclxuXHQgICAgICAgICAgICB0aGlzLmV4cGVjdEpTWCgnOicpO1xyXG5cdCAgICAgICAgICAgIHZhciBuYW1lXzIgPSB0aGlzLnBhcnNlSlNYSWRlbnRpZmllcigpO1xyXG5cdCAgICAgICAgICAgIGF0dHJpYnV0ZU5hbWUgPSB0aGlzLmZpbmFsaXplKG5vZGUsIG5ldyBKU1hOb2RlLkpTWE5hbWVzcGFjZWROYW1lKG5hbWVzcGFjZSwgbmFtZV8yKSk7XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICBlbHNlIHtcclxuXHQgICAgICAgICAgICBhdHRyaWJ1dGVOYW1lID0gaWRlbnRpZmllcjtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIHJldHVybiBhdHRyaWJ1dGVOYW1lO1xyXG5cdCAgICB9O1xyXG5cdCAgICBKU1hQYXJzZXIucHJvdG90eXBlLnBhcnNlSlNYU3RyaW5nTGl0ZXJhbEF0dHJpYnV0ZSA9IGZ1bmN0aW9uICgpIHtcclxuXHQgICAgICAgIHZhciBub2RlID0gdGhpcy5jcmVhdGVKU1hOb2RlKCk7XHJcblx0ICAgICAgICB2YXIgdG9rZW4gPSB0aGlzLm5leHRKU1hUb2tlbigpO1xyXG5cdCAgICAgICAgaWYgKHRva2VuLnR5cGUgIT09IDggLyogU3RyaW5nTGl0ZXJhbCAqLykge1xyXG5cdCAgICAgICAgICAgIHRoaXMudGhyb3dVbmV4cGVjdGVkVG9rZW4odG9rZW4pO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgdmFyIHJhdyA9IHRoaXMuZ2V0VG9rZW5SYXcodG9rZW4pO1xyXG5cdCAgICAgICAgcmV0dXJuIHRoaXMuZmluYWxpemUobm9kZSwgbmV3IE5vZGUuTGl0ZXJhbCh0b2tlbi52YWx1ZSwgcmF3KSk7XHJcblx0ICAgIH07XHJcblx0ICAgIEpTWFBhcnNlci5wcm90b3R5cGUucGFyc2VKU1hFeHByZXNzaW9uQXR0cmlidXRlID0gZnVuY3Rpb24gKCkge1xyXG5cdCAgICAgICAgdmFyIG5vZGUgPSB0aGlzLmNyZWF0ZUpTWE5vZGUoKTtcclxuXHQgICAgICAgIHRoaXMuZXhwZWN0SlNYKCd7Jyk7XHJcblx0ICAgICAgICB0aGlzLmZpbmlzaEpTWCgpO1xyXG5cdCAgICAgICAgaWYgKHRoaXMubWF0Y2goJ30nKSkge1xyXG5cdCAgICAgICAgICAgIHRoaXMudG9sZXJhdGVFcnJvcignSlNYIGF0dHJpYnV0ZXMgbXVzdCBvbmx5IGJlIGFzc2lnbmVkIGEgbm9uLWVtcHR5IGV4cHJlc3Npb24nKTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIHZhciBleHByZXNzaW9uID0gdGhpcy5wYXJzZUFzc2lnbm1lbnRFeHByZXNzaW9uKCk7XHJcblx0ICAgICAgICB0aGlzLnJlZW50ZXJKU1goKTtcclxuXHQgICAgICAgIHJldHVybiB0aGlzLmZpbmFsaXplKG5vZGUsIG5ldyBKU1hOb2RlLkpTWEV4cHJlc3Npb25Db250YWluZXIoZXhwcmVzc2lvbikpO1xyXG5cdCAgICB9O1xyXG5cdCAgICBKU1hQYXJzZXIucHJvdG90eXBlLnBhcnNlSlNYQXR0cmlidXRlVmFsdWUgPSBmdW5jdGlvbiAoKSB7XHJcblx0ICAgICAgICByZXR1cm4gdGhpcy5tYXRjaEpTWCgneycpID8gdGhpcy5wYXJzZUpTWEV4cHJlc3Npb25BdHRyaWJ1dGUoKSA6XHJcblx0ICAgICAgICAgICAgdGhpcy5tYXRjaEpTWCgnPCcpID8gdGhpcy5wYXJzZUpTWEVsZW1lbnQoKSA6IHRoaXMucGFyc2VKU1hTdHJpbmdMaXRlcmFsQXR0cmlidXRlKCk7XHJcblx0ICAgIH07XHJcblx0ICAgIEpTWFBhcnNlci5wcm90b3R5cGUucGFyc2VKU1hOYW1lVmFsdWVBdHRyaWJ1dGUgPSBmdW5jdGlvbiAoKSB7XHJcblx0ICAgICAgICB2YXIgbm9kZSA9IHRoaXMuY3JlYXRlSlNYTm9kZSgpO1xyXG5cdCAgICAgICAgdmFyIG5hbWUgPSB0aGlzLnBhcnNlSlNYQXR0cmlidXRlTmFtZSgpO1xyXG5cdCAgICAgICAgdmFyIHZhbHVlID0gbnVsbDtcclxuXHQgICAgICAgIGlmICh0aGlzLm1hdGNoSlNYKCc9JykpIHtcclxuXHQgICAgICAgICAgICB0aGlzLmV4cGVjdEpTWCgnPScpO1xyXG5cdCAgICAgICAgICAgIHZhbHVlID0gdGhpcy5wYXJzZUpTWEF0dHJpYnV0ZVZhbHVlKCk7XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICByZXR1cm4gdGhpcy5maW5hbGl6ZShub2RlLCBuZXcgSlNYTm9kZS5KU1hBdHRyaWJ1dGUobmFtZSwgdmFsdWUpKTtcclxuXHQgICAgfTtcclxuXHQgICAgSlNYUGFyc2VyLnByb3RvdHlwZS5wYXJzZUpTWFNwcmVhZEF0dHJpYnV0ZSA9IGZ1bmN0aW9uICgpIHtcclxuXHQgICAgICAgIHZhciBub2RlID0gdGhpcy5jcmVhdGVKU1hOb2RlKCk7XHJcblx0ICAgICAgICB0aGlzLmV4cGVjdEpTWCgneycpO1xyXG5cdCAgICAgICAgdGhpcy5leHBlY3RKU1goJy4uLicpO1xyXG5cdCAgICAgICAgdGhpcy5maW5pc2hKU1goKTtcclxuXHQgICAgICAgIHZhciBhcmd1bWVudCA9IHRoaXMucGFyc2VBc3NpZ25tZW50RXhwcmVzc2lvbigpO1xyXG5cdCAgICAgICAgdGhpcy5yZWVudGVySlNYKCk7XHJcblx0ICAgICAgICByZXR1cm4gdGhpcy5maW5hbGl6ZShub2RlLCBuZXcgSlNYTm9kZS5KU1hTcHJlYWRBdHRyaWJ1dGUoYXJndW1lbnQpKTtcclxuXHQgICAgfTtcclxuXHQgICAgSlNYUGFyc2VyLnByb3RvdHlwZS5wYXJzZUpTWEF0dHJpYnV0ZXMgPSBmdW5jdGlvbiAoKSB7XHJcblx0ICAgICAgICB2YXIgYXR0cmlidXRlcyA9IFtdO1xyXG5cdCAgICAgICAgd2hpbGUgKCF0aGlzLm1hdGNoSlNYKCcvJykgJiYgIXRoaXMubWF0Y2hKU1goJz4nKSkge1xyXG5cdCAgICAgICAgICAgIHZhciBhdHRyaWJ1dGUgPSB0aGlzLm1hdGNoSlNYKCd7JykgPyB0aGlzLnBhcnNlSlNYU3ByZWFkQXR0cmlidXRlKCkgOlxyXG5cdCAgICAgICAgICAgICAgICB0aGlzLnBhcnNlSlNYTmFtZVZhbHVlQXR0cmlidXRlKCk7XHJcblx0ICAgICAgICAgICAgYXR0cmlidXRlcy5wdXNoKGF0dHJpYnV0ZSk7XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICByZXR1cm4gYXR0cmlidXRlcztcclxuXHQgICAgfTtcclxuXHQgICAgSlNYUGFyc2VyLnByb3RvdHlwZS5wYXJzZUpTWE9wZW5pbmdFbGVtZW50ID0gZnVuY3Rpb24gKCkge1xyXG5cdCAgICAgICAgdmFyIG5vZGUgPSB0aGlzLmNyZWF0ZUpTWE5vZGUoKTtcclxuXHQgICAgICAgIHRoaXMuZXhwZWN0SlNYKCc8Jyk7XHJcblx0ICAgICAgICB2YXIgbmFtZSA9IHRoaXMucGFyc2VKU1hFbGVtZW50TmFtZSgpO1xyXG5cdCAgICAgICAgdmFyIGF0dHJpYnV0ZXMgPSB0aGlzLnBhcnNlSlNYQXR0cmlidXRlcygpO1xyXG5cdCAgICAgICAgdmFyIHNlbGZDbG9zaW5nID0gdGhpcy5tYXRjaEpTWCgnLycpO1xyXG5cdCAgICAgICAgaWYgKHNlbGZDbG9zaW5nKSB7XHJcblx0ICAgICAgICAgICAgdGhpcy5leHBlY3RKU1goJy8nKTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIHRoaXMuZXhwZWN0SlNYKCc+Jyk7XHJcblx0ICAgICAgICByZXR1cm4gdGhpcy5maW5hbGl6ZShub2RlLCBuZXcgSlNYTm9kZS5KU1hPcGVuaW5nRWxlbWVudChuYW1lLCBzZWxmQ2xvc2luZywgYXR0cmlidXRlcykpO1xyXG5cdCAgICB9O1xyXG5cdCAgICBKU1hQYXJzZXIucHJvdG90eXBlLnBhcnNlSlNYQm91bmRhcnlFbGVtZW50ID0gZnVuY3Rpb24gKCkge1xyXG5cdCAgICAgICAgdmFyIG5vZGUgPSB0aGlzLmNyZWF0ZUpTWE5vZGUoKTtcclxuXHQgICAgICAgIHRoaXMuZXhwZWN0SlNYKCc8Jyk7XHJcblx0ICAgICAgICBpZiAodGhpcy5tYXRjaEpTWCgnLycpKSB7XHJcblx0ICAgICAgICAgICAgdGhpcy5leHBlY3RKU1goJy8nKTtcclxuXHQgICAgICAgICAgICB2YXIgbmFtZV8zID0gdGhpcy5wYXJzZUpTWEVsZW1lbnROYW1lKCk7XHJcblx0ICAgICAgICAgICAgdGhpcy5leHBlY3RKU1goJz4nKTtcclxuXHQgICAgICAgICAgICByZXR1cm4gdGhpcy5maW5hbGl6ZShub2RlLCBuZXcgSlNYTm9kZS5KU1hDbG9zaW5nRWxlbWVudChuYW1lXzMpKTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIHZhciBuYW1lID0gdGhpcy5wYXJzZUpTWEVsZW1lbnROYW1lKCk7XHJcblx0ICAgICAgICB2YXIgYXR0cmlidXRlcyA9IHRoaXMucGFyc2VKU1hBdHRyaWJ1dGVzKCk7XHJcblx0ICAgICAgICB2YXIgc2VsZkNsb3NpbmcgPSB0aGlzLm1hdGNoSlNYKCcvJyk7XHJcblx0ICAgICAgICBpZiAoc2VsZkNsb3NpbmcpIHtcclxuXHQgICAgICAgICAgICB0aGlzLmV4cGVjdEpTWCgnLycpO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgdGhpcy5leHBlY3RKU1goJz4nKTtcclxuXHQgICAgICAgIHJldHVybiB0aGlzLmZpbmFsaXplKG5vZGUsIG5ldyBKU1hOb2RlLkpTWE9wZW5pbmdFbGVtZW50KG5hbWUsIHNlbGZDbG9zaW5nLCBhdHRyaWJ1dGVzKSk7XHJcblx0ICAgIH07XHJcblx0ICAgIEpTWFBhcnNlci5wcm90b3R5cGUucGFyc2VKU1hFbXB0eUV4cHJlc3Npb24gPSBmdW5jdGlvbiAoKSB7XHJcblx0ICAgICAgICB2YXIgbm9kZSA9IHRoaXMuY3JlYXRlSlNYQ2hpbGROb2RlKCk7XHJcblx0ICAgICAgICB0aGlzLmNvbGxlY3RDb21tZW50cygpO1xyXG5cdCAgICAgICAgdGhpcy5sYXN0TWFya2VyLmluZGV4ID0gdGhpcy5zY2FubmVyLmluZGV4O1xyXG5cdCAgICAgICAgdGhpcy5sYXN0TWFya2VyLmxpbmUgPSB0aGlzLnNjYW5uZXIubGluZU51bWJlcjtcclxuXHQgICAgICAgIHRoaXMubGFzdE1hcmtlci5jb2x1bW4gPSB0aGlzLnNjYW5uZXIuaW5kZXggLSB0aGlzLnNjYW5uZXIubGluZVN0YXJ0O1xyXG5cdCAgICAgICAgcmV0dXJuIHRoaXMuZmluYWxpemUobm9kZSwgbmV3IEpTWE5vZGUuSlNYRW1wdHlFeHByZXNzaW9uKCkpO1xyXG5cdCAgICB9O1xyXG5cdCAgICBKU1hQYXJzZXIucHJvdG90eXBlLnBhcnNlSlNYRXhwcmVzc2lvbkNvbnRhaW5lciA9IGZ1bmN0aW9uICgpIHtcclxuXHQgICAgICAgIHZhciBub2RlID0gdGhpcy5jcmVhdGVKU1hOb2RlKCk7XHJcblx0ICAgICAgICB0aGlzLmV4cGVjdEpTWCgneycpO1xyXG5cdCAgICAgICAgdmFyIGV4cHJlc3Npb247XHJcblx0ICAgICAgICBpZiAodGhpcy5tYXRjaEpTWCgnfScpKSB7XHJcblx0ICAgICAgICAgICAgZXhwcmVzc2lvbiA9IHRoaXMucGFyc2VKU1hFbXB0eUV4cHJlc3Npb24oKTtcclxuXHQgICAgICAgICAgICB0aGlzLmV4cGVjdEpTWCgnfScpO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgZWxzZSB7XHJcblx0ICAgICAgICAgICAgdGhpcy5maW5pc2hKU1goKTtcclxuXHQgICAgICAgICAgICBleHByZXNzaW9uID0gdGhpcy5wYXJzZUFzc2lnbm1lbnRFeHByZXNzaW9uKCk7XHJcblx0ICAgICAgICAgICAgdGhpcy5yZWVudGVySlNYKCk7XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICByZXR1cm4gdGhpcy5maW5hbGl6ZShub2RlLCBuZXcgSlNYTm9kZS5KU1hFeHByZXNzaW9uQ29udGFpbmVyKGV4cHJlc3Npb24pKTtcclxuXHQgICAgfTtcclxuXHQgICAgSlNYUGFyc2VyLnByb3RvdHlwZS5wYXJzZUpTWENoaWxkcmVuID0gZnVuY3Rpb24gKCkge1xyXG5cdCAgICAgICAgdmFyIGNoaWxkcmVuID0gW107XHJcblx0ICAgICAgICB3aGlsZSAoIXRoaXMuc2Nhbm5lci5lb2YoKSkge1xyXG5cdCAgICAgICAgICAgIHZhciBub2RlID0gdGhpcy5jcmVhdGVKU1hDaGlsZE5vZGUoKTtcclxuXHQgICAgICAgICAgICB2YXIgdG9rZW4gPSB0aGlzLm5leHRKU1hUZXh0KCk7XHJcblx0ICAgICAgICAgICAgaWYgKHRva2VuLnN0YXJ0IDwgdG9rZW4uZW5kKSB7XHJcblx0ICAgICAgICAgICAgICAgIHZhciByYXcgPSB0aGlzLmdldFRva2VuUmF3KHRva2VuKTtcclxuXHQgICAgICAgICAgICAgICAgdmFyIGNoaWxkID0gdGhpcy5maW5hbGl6ZShub2RlLCBuZXcgSlNYTm9kZS5KU1hUZXh0KHRva2VuLnZhbHVlLCByYXcpKTtcclxuXHQgICAgICAgICAgICAgICAgY2hpbGRyZW4ucHVzaChjaGlsZCk7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgIGlmICh0aGlzLnNjYW5uZXIuc291cmNlW3RoaXMuc2Nhbm5lci5pbmRleF0gPT09ICd7Jykge1xyXG5cdCAgICAgICAgICAgICAgICB2YXIgY29udGFpbmVyID0gdGhpcy5wYXJzZUpTWEV4cHJlc3Npb25Db250YWluZXIoKTtcclxuXHQgICAgICAgICAgICAgICAgY2hpbGRyZW4ucHVzaChjb250YWluZXIpO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICBlbHNlIHtcclxuXHQgICAgICAgICAgICAgICAgYnJlYWs7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgcmV0dXJuIGNoaWxkcmVuO1xyXG5cdCAgICB9O1xyXG5cdCAgICBKU1hQYXJzZXIucHJvdG90eXBlLnBhcnNlQ29tcGxleEpTWEVsZW1lbnQgPSBmdW5jdGlvbiAoZWwpIHtcclxuXHQgICAgICAgIHZhciBzdGFjayA9IFtdO1xyXG5cdCAgICAgICAgd2hpbGUgKCF0aGlzLnNjYW5uZXIuZW9mKCkpIHtcclxuXHQgICAgICAgICAgICBlbC5jaGlsZHJlbiA9IGVsLmNoaWxkcmVuLmNvbmNhdCh0aGlzLnBhcnNlSlNYQ2hpbGRyZW4oKSk7XHJcblx0ICAgICAgICAgICAgdmFyIG5vZGUgPSB0aGlzLmNyZWF0ZUpTWENoaWxkTm9kZSgpO1xyXG5cdCAgICAgICAgICAgIHZhciBlbGVtZW50ID0gdGhpcy5wYXJzZUpTWEJvdW5kYXJ5RWxlbWVudCgpO1xyXG5cdCAgICAgICAgICAgIGlmIChlbGVtZW50LnR5cGUgPT09IGpzeF9zeW50YXhfMS5KU1hTeW50YXguSlNYT3BlbmluZ0VsZW1lbnQpIHtcclxuXHQgICAgICAgICAgICAgICAgdmFyIG9wZW5pbmcgPSBlbGVtZW50O1xyXG5cdCAgICAgICAgICAgICAgICBpZiAob3BlbmluZy5zZWxmQ2xvc2luZykge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIGNoaWxkID0gdGhpcy5maW5hbGl6ZShub2RlLCBuZXcgSlNYTm9kZS5KU1hFbGVtZW50KG9wZW5pbmcsIFtdLCBudWxsKSk7XHJcblx0ICAgICAgICAgICAgICAgICAgICBlbC5jaGlsZHJlbi5wdXNoKGNoaWxkKTtcclxuXHQgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICBlbHNlIHtcclxuXHQgICAgICAgICAgICAgICAgICAgIHN0YWNrLnB1c2goZWwpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgZWwgPSB7IG5vZGU6IG5vZGUsIG9wZW5pbmc6IG9wZW5pbmcsIGNsb3Npbmc6IG51bGwsIGNoaWxkcmVuOiBbXSB9O1xyXG5cdCAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgIGlmIChlbGVtZW50LnR5cGUgPT09IGpzeF9zeW50YXhfMS5KU1hTeW50YXguSlNYQ2xvc2luZ0VsZW1lbnQpIHtcclxuXHQgICAgICAgICAgICAgICAgZWwuY2xvc2luZyA9IGVsZW1lbnQ7XHJcblx0ICAgICAgICAgICAgICAgIHZhciBvcGVuXzEgPSBnZXRRdWFsaWZpZWRFbGVtZW50TmFtZShlbC5vcGVuaW5nLm5hbWUpO1xyXG5cdCAgICAgICAgICAgICAgICB2YXIgY2xvc2VfMSA9IGdldFF1YWxpZmllZEVsZW1lbnROYW1lKGVsLmNsb3NpbmcubmFtZSk7XHJcblx0ICAgICAgICAgICAgICAgIGlmIChvcGVuXzEgIT09IGNsb3NlXzEpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgIHRoaXMudG9sZXJhdGVFcnJvcignRXhwZWN0ZWQgY29ycmVzcG9uZGluZyBKU1ggY2xvc2luZyB0YWcgZm9yICUwJywgb3Blbl8xKTtcclxuXHQgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICBpZiAoc3RhY2subGVuZ3RoID4gMCkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIGNoaWxkID0gdGhpcy5maW5hbGl6ZShlbC5ub2RlLCBuZXcgSlNYTm9kZS5KU1hFbGVtZW50KGVsLm9wZW5pbmcsIGVsLmNoaWxkcmVuLCBlbC5jbG9zaW5nKSk7XHJcblx0ICAgICAgICAgICAgICAgICAgICBlbCA9IHN0YWNrW3N0YWNrLmxlbmd0aCAtIDFdO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgZWwuY2hpbGRyZW4ucHVzaChjaGlsZCk7XHJcblx0ICAgICAgICAgICAgICAgICAgICBzdGFjay5wb3AoKTtcclxuXHQgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICBlbHNlIHtcclxuXHQgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cdCAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgcmV0dXJuIGVsO1xyXG5cdCAgICB9O1xyXG5cdCAgICBKU1hQYXJzZXIucHJvdG90eXBlLnBhcnNlSlNYRWxlbWVudCA9IGZ1bmN0aW9uICgpIHtcclxuXHQgICAgICAgIHZhciBub2RlID0gdGhpcy5jcmVhdGVKU1hOb2RlKCk7XHJcblx0ICAgICAgICB2YXIgb3BlbmluZyA9IHRoaXMucGFyc2VKU1hPcGVuaW5nRWxlbWVudCgpO1xyXG5cdCAgICAgICAgdmFyIGNoaWxkcmVuID0gW107XHJcblx0ICAgICAgICB2YXIgY2xvc2luZyA9IG51bGw7XHJcblx0ICAgICAgICBpZiAoIW9wZW5pbmcuc2VsZkNsb3NpbmcpIHtcclxuXHQgICAgICAgICAgICB2YXIgZWwgPSB0aGlzLnBhcnNlQ29tcGxleEpTWEVsZW1lbnQoeyBub2RlOiBub2RlLCBvcGVuaW5nOiBvcGVuaW5nLCBjbG9zaW5nOiBjbG9zaW5nLCBjaGlsZHJlbjogY2hpbGRyZW4gfSk7XHJcblx0ICAgICAgICAgICAgY2hpbGRyZW4gPSBlbC5jaGlsZHJlbjtcclxuXHQgICAgICAgICAgICBjbG9zaW5nID0gZWwuY2xvc2luZztcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIHJldHVybiB0aGlzLmZpbmFsaXplKG5vZGUsIG5ldyBKU1hOb2RlLkpTWEVsZW1lbnQob3BlbmluZywgY2hpbGRyZW4sIGNsb3NpbmcpKTtcclxuXHQgICAgfTtcclxuXHQgICAgSlNYUGFyc2VyLnByb3RvdHlwZS5wYXJzZUpTWFJvb3QgPSBmdW5jdGlvbiAoKSB7XHJcblx0ICAgICAgICAvLyBQb3AgdGhlIG9wZW5pbmcgJzwnIGFkZGVkIGZyb20gdGhlIGxvb2thaGVhZC5cclxuXHQgICAgICAgIGlmICh0aGlzLmNvbmZpZy50b2tlbnMpIHtcclxuXHQgICAgICAgICAgICB0aGlzLnRva2Vucy5wb3AoKTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIHRoaXMuc3RhcnRKU1goKTtcclxuXHQgICAgICAgIHZhciBlbGVtZW50ID0gdGhpcy5wYXJzZUpTWEVsZW1lbnQoKTtcclxuXHQgICAgICAgIHRoaXMuZmluaXNoSlNYKCk7XHJcblx0ICAgICAgICByZXR1cm4gZWxlbWVudDtcclxuXHQgICAgfTtcclxuXHQgICAgSlNYUGFyc2VyLnByb3RvdHlwZS5pc1N0YXJ0T2ZFeHByZXNzaW9uID0gZnVuY3Rpb24gKCkge1xyXG5cdCAgICAgICAgcmV0dXJuIF9zdXBlci5wcm90b3R5cGUuaXNTdGFydE9mRXhwcmVzc2lvbi5jYWxsKHRoaXMpIHx8IHRoaXMubWF0Y2goJzwnKTtcclxuXHQgICAgfTtcclxuXHQgICAgcmV0dXJuIEpTWFBhcnNlcjtcclxuXHR9KHBhcnNlcl8xLlBhcnNlcikpO1xyXG5cdGV4cG9ydHMuSlNYUGFyc2VyID0gSlNYUGFyc2VyO1xyXG5cblxuLyoqKi8gfSxcbi8qIDQgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG5cdFwidXNlIHN0cmljdFwiO1xyXG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuXHQvLyBTZWUgYWxzbyB0b29scy9nZW5lcmF0ZS11bmljb2RlLXJlZ2V4LmpzLlxyXG5cdHZhciBSZWdleCA9IHtcclxuXHQgICAgLy8gVW5pY29kZSB2OC4wLjAgTm9uQXNjaWlJZGVudGlmaWVyU3RhcnQ6XHJcblx0ICAgIE5vbkFzY2lpSWRlbnRpZmllclN0YXJ0OiAvW1xceEFBXFx4QjVcXHhCQVxceEMwLVxceEQ2XFx4RDgtXFx4RjZcXHhGOC1cXHUwMkMxXFx1MDJDNi1cXHUwMkQxXFx1MDJFMC1cXHUwMkU0XFx1MDJFQ1xcdTAyRUVcXHUwMzcwLVxcdTAzNzRcXHUwMzc2XFx1MDM3N1xcdTAzN0EtXFx1MDM3RFxcdTAzN0ZcXHUwMzg2XFx1MDM4OC1cXHUwMzhBXFx1MDM4Q1xcdTAzOEUtXFx1MDNBMVxcdTAzQTMtXFx1MDNGNVxcdTAzRjctXFx1MDQ4MVxcdTA0OEEtXFx1MDUyRlxcdTA1MzEtXFx1MDU1NlxcdTA1NTlcXHUwNTYxLVxcdTA1ODdcXHUwNUQwLVxcdTA1RUFcXHUwNUYwLVxcdTA1RjJcXHUwNjIwLVxcdTA2NEFcXHUwNjZFXFx1MDY2RlxcdTA2NzEtXFx1MDZEM1xcdTA2RDVcXHUwNkU1XFx1MDZFNlxcdTA2RUVcXHUwNkVGXFx1MDZGQS1cXHUwNkZDXFx1MDZGRlxcdTA3MTBcXHUwNzEyLVxcdTA3MkZcXHUwNzRELVxcdTA3QTVcXHUwN0IxXFx1MDdDQS1cXHUwN0VBXFx1MDdGNFxcdTA3RjVcXHUwN0ZBXFx1MDgwMC1cXHUwODE1XFx1MDgxQVxcdTA4MjRcXHUwODI4XFx1MDg0MC1cXHUwODU4XFx1MDhBMC1cXHUwOEI0XFx1MDkwNC1cXHUwOTM5XFx1MDkzRFxcdTA5NTBcXHUwOTU4LVxcdTA5NjFcXHUwOTcxLVxcdTA5ODBcXHUwOTg1LVxcdTA5OENcXHUwOThGXFx1MDk5MFxcdTA5OTMtXFx1MDlBOFxcdTA5QUEtXFx1MDlCMFxcdTA5QjJcXHUwOUI2LVxcdTA5QjlcXHUwOUJEXFx1MDlDRVxcdTA5RENcXHUwOUREXFx1MDlERi1cXHUwOUUxXFx1MDlGMFxcdTA5RjFcXHUwQTA1LVxcdTBBMEFcXHUwQTBGXFx1MEExMFxcdTBBMTMtXFx1MEEyOFxcdTBBMkEtXFx1MEEzMFxcdTBBMzJcXHUwQTMzXFx1MEEzNVxcdTBBMzZcXHUwQTM4XFx1MEEzOVxcdTBBNTktXFx1MEE1Q1xcdTBBNUVcXHUwQTcyLVxcdTBBNzRcXHUwQTg1LVxcdTBBOERcXHUwQThGLVxcdTBBOTFcXHUwQTkzLVxcdTBBQThcXHUwQUFBLVxcdTBBQjBcXHUwQUIyXFx1MEFCM1xcdTBBQjUtXFx1MEFCOVxcdTBBQkRcXHUwQUQwXFx1MEFFMFxcdTBBRTFcXHUwQUY5XFx1MEIwNS1cXHUwQjBDXFx1MEIwRlxcdTBCMTBcXHUwQjEzLVxcdTBCMjhcXHUwQjJBLVxcdTBCMzBcXHUwQjMyXFx1MEIzM1xcdTBCMzUtXFx1MEIzOVxcdTBCM0RcXHUwQjVDXFx1MEI1RFxcdTBCNUYtXFx1MEI2MVxcdTBCNzFcXHUwQjgzXFx1MEI4NS1cXHUwQjhBXFx1MEI4RS1cXHUwQjkwXFx1MEI5Mi1cXHUwQjk1XFx1MEI5OVxcdTBCOUFcXHUwQjlDXFx1MEI5RVxcdTBCOUZcXHUwQkEzXFx1MEJBNFxcdTBCQTgtXFx1MEJBQVxcdTBCQUUtXFx1MEJCOVxcdTBCRDBcXHUwQzA1LVxcdTBDMENcXHUwQzBFLVxcdTBDMTBcXHUwQzEyLVxcdTBDMjhcXHUwQzJBLVxcdTBDMzlcXHUwQzNEXFx1MEM1OC1cXHUwQzVBXFx1MEM2MFxcdTBDNjFcXHUwQzg1LVxcdTBDOENcXHUwQzhFLVxcdTBDOTBcXHUwQzkyLVxcdTBDQThcXHUwQ0FBLVxcdTBDQjNcXHUwQ0I1LVxcdTBDQjlcXHUwQ0JEXFx1MENERVxcdTBDRTBcXHUwQ0UxXFx1MENGMVxcdTBDRjJcXHUwRDA1LVxcdTBEMENcXHUwRDBFLVxcdTBEMTBcXHUwRDEyLVxcdTBEM0FcXHUwRDNEXFx1MEQ0RVxcdTBENUYtXFx1MEQ2MVxcdTBEN0EtXFx1MEQ3RlxcdTBEODUtXFx1MEQ5NlxcdTBEOUEtXFx1MERCMVxcdTBEQjMtXFx1MERCQlxcdTBEQkRcXHUwREMwLVxcdTBEQzZcXHUwRTAxLVxcdTBFMzBcXHUwRTMyXFx1MEUzM1xcdTBFNDAtXFx1MEU0NlxcdTBFODFcXHUwRTgyXFx1MEU4NFxcdTBFODdcXHUwRTg4XFx1MEU4QVxcdTBFOERcXHUwRTk0LVxcdTBFOTdcXHUwRTk5LVxcdTBFOUZcXHUwRUExLVxcdTBFQTNcXHUwRUE1XFx1MEVBN1xcdTBFQUFcXHUwRUFCXFx1MEVBRC1cXHUwRUIwXFx1MEVCMlxcdTBFQjNcXHUwRUJEXFx1MEVDMC1cXHUwRUM0XFx1MEVDNlxcdTBFREMtXFx1MEVERlxcdTBGMDBcXHUwRjQwLVxcdTBGNDdcXHUwRjQ5LVxcdTBGNkNcXHUwRjg4LVxcdTBGOENcXHUxMDAwLVxcdTEwMkFcXHUxMDNGXFx1MTA1MC1cXHUxMDU1XFx1MTA1QS1cXHUxMDVEXFx1MTA2MVxcdTEwNjVcXHUxMDY2XFx1MTA2RS1cXHUxMDcwXFx1MTA3NS1cXHUxMDgxXFx1MTA4RVxcdTEwQTAtXFx1MTBDNVxcdTEwQzdcXHUxMENEXFx1MTBEMC1cXHUxMEZBXFx1MTBGQy1cXHUxMjQ4XFx1MTI0QS1cXHUxMjREXFx1MTI1MC1cXHUxMjU2XFx1MTI1OFxcdTEyNUEtXFx1MTI1RFxcdTEyNjAtXFx1MTI4OFxcdTEyOEEtXFx1MTI4RFxcdTEyOTAtXFx1MTJCMFxcdTEyQjItXFx1MTJCNVxcdTEyQjgtXFx1MTJCRVxcdTEyQzBcXHUxMkMyLVxcdTEyQzVcXHUxMkM4LVxcdTEyRDZcXHUxMkQ4LVxcdTEzMTBcXHUxMzEyLVxcdTEzMTVcXHUxMzE4LVxcdTEzNUFcXHUxMzgwLVxcdTEzOEZcXHUxM0EwLVxcdTEzRjVcXHUxM0Y4LVxcdTEzRkRcXHUxNDAxLVxcdTE2NkNcXHUxNjZGLVxcdTE2N0ZcXHUxNjgxLVxcdTE2OUFcXHUxNkEwLVxcdTE2RUFcXHUxNkVFLVxcdTE2RjhcXHUxNzAwLVxcdTE3MENcXHUxNzBFLVxcdTE3MTFcXHUxNzIwLVxcdTE3MzFcXHUxNzQwLVxcdTE3NTFcXHUxNzYwLVxcdTE3NkNcXHUxNzZFLVxcdTE3NzBcXHUxNzgwLVxcdTE3QjNcXHUxN0Q3XFx1MTdEQ1xcdTE4MjAtXFx1MTg3N1xcdTE4ODAtXFx1MThBOFxcdTE4QUFcXHUxOEIwLVxcdTE4RjVcXHUxOTAwLVxcdTE5MUVcXHUxOTUwLVxcdTE5NkRcXHUxOTcwLVxcdTE5NzRcXHUxOTgwLVxcdTE5QUJcXHUxOUIwLVxcdTE5QzlcXHUxQTAwLVxcdTFBMTZcXHUxQTIwLVxcdTFBNTRcXHUxQUE3XFx1MUIwNS1cXHUxQjMzXFx1MUI0NS1cXHUxQjRCXFx1MUI4My1cXHUxQkEwXFx1MUJBRVxcdTFCQUZcXHUxQkJBLVxcdTFCRTVcXHUxQzAwLVxcdTFDMjNcXHUxQzRELVxcdTFDNEZcXHUxQzVBLVxcdTFDN0RcXHUxQ0U5LVxcdTFDRUNcXHUxQ0VFLVxcdTFDRjFcXHUxQ0Y1XFx1MUNGNlxcdTFEMDAtXFx1MURCRlxcdTFFMDAtXFx1MUYxNVxcdTFGMTgtXFx1MUYxRFxcdTFGMjAtXFx1MUY0NVxcdTFGNDgtXFx1MUY0RFxcdTFGNTAtXFx1MUY1N1xcdTFGNTlcXHUxRjVCXFx1MUY1RFxcdTFGNUYtXFx1MUY3RFxcdTFGODAtXFx1MUZCNFxcdTFGQjYtXFx1MUZCQ1xcdTFGQkVcXHUxRkMyLVxcdTFGQzRcXHUxRkM2LVxcdTFGQ0NcXHUxRkQwLVxcdTFGRDNcXHUxRkQ2LVxcdTFGREJcXHUxRkUwLVxcdTFGRUNcXHUxRkYyLVxcdTFGRjRcXHUxRkY2LVxcdTFGRkNcXHUyMDcxXFx1MjA3RlxcdTIwOTAtXFx1MjA5Q1xcdTIxMDJcXHUyMTA3XFx1MjEwQS1cXHUyMTEzXFx1MjExNVxcdTIxMTgtXFx1MjExRFxcdTIxMjRcXHUyMTI2XFx1MjEyOFxcdTIxMkEtXFx1MjEzOVxcdTIxM0MtXFx1MjEzRlxcdTIxNDUtXFx1MjE0OVxcdTIxNEVcXHUyMTYwLVxcdTIxODhcXHUyQzAwLVxcdTJDMkVcXHUyQzMwLVxcdTJDNUVcXHUyQzYwLVxcdTJDRTRcXHUyQ0VCLVxcdTJDRUVcXHUyQ0YyXFx1MkNGM1xcdTJEMDAtXFx1MkQyNVxcdTJEMjdcXHUyRDJEXFx1MkQzMC1cXHUyRDY3XFx1MkQ2RlxcdTJEODAtXFx1MkQ5NlxcdTJEQTAtXFx1MkRBNlxcdTJEQTgtXFx1MkRBRVxcdTJEQjAtXFx1MkRCNlxcdTJEQjgtXFx1MkRCRVxcdTJEQzAtXFx1MkRDNlxcdTJEQzgtXFx1MkRDRVxcdTJERDAtXFx1MkRENlxcdTJERDgtXFx1MkRERVxcdTMwMDUtXFx1MzAwN1xcdTMwMjEtXFx1MzAyOVxcdTMwMzEtXFx1MzAzNVxcdTMwMzgtXFx1MzAzQ1xcdTMwNDEtXFx1MzA5NlxcdTMwOUItXFx1MzA5RlxcdTMwQTEtXFx1MzBGQVxcdTMwRkMtXFx1MzBGRlxcdTMxMDUtXFx1MzEyRFxcdTMxMzEtXFx1MzE4RVxcdTMxQTAtXFx1MzFCQVxcdTMxRjAtXFx1MzFGRlxcdTM0MDAtXFx1NERCNVxcdTRFMDAtXFx1OUZENVxcdUEwMDAtXFx1QTQ4Q1xcdUE0RDAtXFx1QTRGRFxcdUE1MDAtXFx1QTYwQ1xcdUE2MTAtXFx1QTYxRlxcdUE2MkFcXHVBNjJCXFx1QTY0MC1cXHVBNjZFXFx1QTY3Ri1cXHVBNjlEXFx1QTZBMC1cXHVBNkVGXFx1QTcxNy1cXHVBNzFGXFx1QTcyMi1cXHVBNzg4XFx1QTc4Qi1cXHVBN0FEXFx1QTdCMC1cXHVBN0I3XFx1QTdGNy1cXHVBODAxXFx1QTgwMy1cXHVBODA1XFx1QTgwNy1cXHVBODBBXFx1QTgwQy1cXHVBODIyXFx1QTg0MC1cXHVBODczXFx1QTg4Mi1cXHVBOEIzXFx1QThGMi1cXHVBOEY3XFx1QThGQlxcdUE4RkRcXHVBOTBBLVxcdUE5MjVcXHVBOTMwLVxcdUE5NDZcXHVBOTYwLVxcdUE5N0NcXHVBOTg0LVxcdUE5QjJcXHVBOUNGXFx1QTlFMC1cXHVBOUU0XFx1QTlFNi1cXHVBOUVGXFx1QTlGQS1cXHVBOUZFXFx1QUEwMC1cXHVBQTI4XFx1QUE0MC1cXHVBQTQyXFx1QUE0NC1cXHVBQTRCXFx1QUE2MC1cXHVBQTc2XFx1QUE3QVxcdUFBN0UtXFx1QUFBRlxcdUFBQjFcXHVBQUI1XFx1QUFCNlxcdUFBQjktXFx1QUFCRFxcdUFBQzBcXHVBQUMyXFx1QUFEQi1cXHVBQUREXFx1QUFFMC1cXHVBQUVBXFx1QUFGMi1cXHVBQUY0XFx1QUIwMS1cXHVBQjA2XFx1QUIwOS1cXHVBQjBFXFx1QUIxMS1cXHVBQjE2XFx1QUIyMC1cXHVBQjI2XFx1QUIyOC1cXHVBQjJFXFx1QUIzMC1cXHVBQjVBXFx1QUI1Qy1cXHVBQjY1XFx1QUI3MC1cXHVBQkUyXFx1QUMwMC1cXHVEN0EzXFx1RDdCMC1cXHVEN0M2XFx1RDdDQi1cXHVEN0ZCXFx1RjkwMC1cXHVGQTZEXFx1RkE3MC1cXHVGQUQ5XFx1RkIwMC1cXHVGQjA2XFx1RkIxMy1cXHVGQjE3XFx1RkIxRFxcdUZCMUYtXFx1RkIyOFxcdUZCMkEtXFx1RkIzNlxcdUZCMzgtXFx1RkIzQ1xcdUZCM0VcXHVGQjQwXFx1RkI0MVxcdUZCNDNcXHVGQjQ0XFx1RkI0Ni1cXHVGQkIxXFx1RkJEMy1cXHVGRDNEXFx1RkQ1MC1cXHVGRDhGXFx1RkQ5Mi1cXHVGREM3XFx1RkRGMC1cXHVGREZCXFx1RkU3MC1cXHVGRTc0XFx1RkU3Ni1cXHVGRUZDXFx1RkYyMS1cXHVGRjNBXFx1RkY0MS1cXHVGRjVBXFx1RkY2Ni1cXHVGRkJFXFx1RkZDMi1cXHVGRkM3XFx1RkZDQS1cXHVGRkNGXFx1RkZEMi1cXHVGRkQ3XFx1RkZEQS1cXHVGRkRDXXxcXHVEODAwW1xcdURDMDAtXFx1REMwQlxcdURDMEQtXFx1REMyNlxcdURDMjgtXFx1REMzQVxcdURDM0NcXHVEQzNEXFx1REMzRi1cXHVEQzREXFx1REM1MC1cXHVEQzVEXFx1REM4MC1cXHVEQ0ZBXFx1REQ0MC1cXHVERDc0XFx1REU4MC1cXHVERTlDXFx1REVBMC1cXHVERUQwXFx1REYwMC1cXHVERjFGXFx1REYzMC1cXHVERjRBXFx1REY1MC1cXHVERjc1XFx1REY4MC1cXHVERjlEXFx1REZBMC1cXHVERkMzXFx1REZDOC1cXHVERkNGXFx1REZEMS1cXHVERkQ1XXxcXHVEODAxW1xcdURDMDAtXFx1REM5RFxcdUREMDAtXFx1REQyN1xcdUREMzAtXFx1REQ2M1xcdURFMDAtXFx1REYzNlxcdURGNDAtXFx1REY1NVxcdURGNjAtXFx1REY2N118XFx1RDgwMltcXHVEQzAwLVxcdURDMDVcXHVEQzA4XFx1REMwQS1cXHVEQzM1XFx1REMzN1xcdURDMzhcXHVEQzNDXFx1REMzRi1cXHVEQzU1XFx1REM2MC1cXHVEQzc2XFx1REM4MC1cXHVEQzlFXFx1RENFMC1cXHVEQ0YyXFx1RENGNFxcdURDRjVcXHVERDAwLVxcdUREMTVcXHVERDIwLVxcdUREMzlcXHVERDgwLVxcdUREQjdcXHVEREJFXFx1RERCRlxcdURFMDBcXHVERTEwLVxcdURFMTNcXHVERTE1LVxcdURFMTdcXHVERTE5LVxcdURFMzNcXHVERTYwLVxcdURFN0NcXHVERTgwLVxcdURFOUNcXHVERUMwLVxcdURFQzdcXHVERUM5LVxcdURFRTRcXHVERjAwLVxcdURGMzVcXHVERjQwLVxcdURGNTVcXHVERjYwLVxcdURGNzJcXHVERjgwLVxcdURGOTFdfFxcdUQ4MDNbXFx1REMwMC1cXHVEQzQ4XFx1REM4MC1cXHVEQ0IyXFx1RENDMC1cXHVEQ0YyXXxcXHVEODA0W1xcdURDMDMtXFx1REMzN1xcdURDODMtXFx1RENBRlxcdURDRDAtXFx1RENFOFxcdUREMDMtXFx1REQyNlxcdURENTAtXFx1REQ3MlxcdURENzZcXHVERDgzLVxcdUREQjJcXHVEREMxLVxcdUREQzRcXHVERERBXFx1REREQ1xcdURFMDAtXFx1REUxMVxcdURFMTMtXFx1REUyQlxcdURFODAtXFx1REU4NlxcdURFODhcXHVERThBLVxcdURFOERcXHVERThGLVxcdURFOURcXHVERTlGLVxcdURFQThcXHVERUIwLVxcdURFREVcXHVERjA1LVxcdURGMENcXHVERjBGXFx1REYxMFxcdURGMTMtXFx1REYyOFxcdURGMkEtXFx1REYzMFxcdURGMzJcXHVERjMzXFx1REYzNS1cXHVERjM5XFx1REYzRFxcdURGNTBcXHVERjVELVxcdURGNjFdfFxcdUQ4MDVbXFx1REM4MC1cXHVEQ0FGXFx1RENDNFxcdURDQzVcXHVEQ0M3XFx1REQ4MC1cXHVEREFFXFx1REREOC1cXHVERERCXFx1REUwMC1cXHVERTJGXFx1REU0NFxcdURFODAtXFx1REVBQVxcdURGMDAtXFx1REYxOV18XFx1RDgwNltcXHVEQ0EwLVxcdURDREZcXHVEQ0ZGXFx1REVDMC1cXHVERUY4XXxcXHVEODA4W1xcdURDMDAtXFx1REY5OV18XFx1RDgwOVtcXHVEQzAwLVxcdURDNkVcXHVEQzgwLVxcdURENDNdfFtcXHVEODBDXFx1RDg0MC1cXHVEODY4XFx1RDg2QS1cXHVEODZDXFx1RDg2Ri1cXHVEODcyXVtcXHVEQzAwLVxcdURGRkZdfFxcdUQ4MERbXFx1REMwMC1cXHVEQzJFXXxcXHVEODExW1xcdURDMDAtXFx1REU0Nl18XFx1RDgxQVtcXHVEQzAwLVxcdURFMzhcXHVERTQwLVxcdURFNUVcXHVERUQwLVxcdURFRURcXHVERjAwLVxcdURGMkZcXHVERjQwLVxcdURGNDNcXHVERjYzLVxcdURGNzdcXHVERjdELVxcdURGOEZdfFxcdUQ4MUJbXFx1REYwMC1cXHVERjQ0XFx1REY1MFxcdURGOTMtXFx1REY5Rl18XFx1RDgyQ1tcXHVEQzAwXFx1REMwMV18XFx1RDgyRltcXHVEQzAwLVxcdURDNkFcXHVEQzcwLVxcdURDN0NcXHVEQzgwLVxcdURDODhcXHVEQzkwLVxcdURDOTldfFxcdUQ4MzVbXFx1REMwMC1cXHVEQzU0XFx1REM1Ni1cXHVEQzlDXFx1REM5RVxcdURDOUZcXHVEQ0EyXFx1RENBNVxcdURDQTZcXHVEQ0E5LVxcdURDQUNcXHVEQ0FFLVxcdURDQjlcXHVEQ0JCXFx1RENCRC1cXHVEQ0MzXFx1RENDNS1cXHVERDA1XFx1REQwNy1cXHVERDBBXFx1REQwRC1cXHVERDE0XFx1REQxNi1cXHVERDFDXFx1REQxRS1cXHVERDM5XFx1REQzQi1cXHVERDNFXFx1REQ0MC1cXHVERDQ0XFx1REQ0NlxcdURENEEtXFx1REQ1MFxcdURENTItXFx1REVBNVxcdURFQTgtXFx1REVDMFxcdURFQzItXFx1REVEQVxcdURFREMtXFx1REVGQVxcdURFRkMtXFx1REYxNFxcdURGMTYtXFx1REYzNFxcdURGMzYtXFx1REY0RVxcdURGNTAtXFx1REY2RVxcdURGNzAtXFx1REY4OFxcdURGOEEtXFx1REZBOFxcdURGQUEtXFx1REZDMlxcdURGQzQtXFx1REZDQl18XFx1RDgzQVtcXHVEQzAwLVxcdURDQzRdfFxcdUQ4M0JbXFx1REUwMC1cXHVERTAzXFx1REUwNS1cXHVERTFGXFx1REUyMVxcdURFMjJcXHVERTI0XFx1REUyN1xcdURFMjktXFx1REUzMlxcdURFMzQtXFx1REUzN1xcdURFMzlcXHVERTNCXFx1REU0MlxcdURFNDdcXHVERTQ5XFx1REU0QlxcdURFNEQtXFx1REU0RlxcdURFNTFcXHVERTUyXFx1REU1NFxcdURFNTdcXHVERTU5XFx1REU1QlxcdURFNURcXHVERTVGXFx1REU2MVxcdURFNjJcXHVERTY0XFx1REU2Ny1cXHVERTZBXFx1REU2Qy1cXHVERTcyXFx1REU3NC1cXHVERTc3XFx1REU3OS1cXHVERTdDXFx1REU3RVxcdURFODAtXFx1REU4OVxcdURFOEItXFx1REU5QlxcdURFQTEtXFx1REVBM1xcdURFQTUtXFx1REVBOVxcdURFQUItXFx1REVCQl18XFx1RDg2OVtcXHVEQzAwLVxcdURFRDZcXHVERjAwLVxcdURGRkZdfFxcdUQ4NkRbXFx1REMwMC1cXHVERjM0XFx1REY0MC1cXHVERkZGXXxcXHVEODZFW1xcdURDMDAtXFx1REMxRFxcdURDMjAtXFx1REZGRl18XFx1RDg3M1tcXHVEQzAwLVxcdURFQTFdfFxcdUQ4N0VbXFx1REMwMC1cXHVERTFEXS8sXHJcblx0ICAgIC8vIFVuaWNvZGUgdjguMC4wIE5vbkFzY2lpSWRlbnRpZmllclBhcnQ6XHJcblx0ICAgIE5vbkFzY2lpSWRlbnRpZmllclBhcnQ6IC9bXFx4QUFcXHhCNVxceEI3XFx4QkFcXHhDMC1cXHhENlxceEQ4LVxceEY2XFx4RjgtXFx1MDJDMVxcdTAyQzYtXFx1MDJEMVxcdTAyRTAtXFx1MDJFNFxcdTAyRUNcXHUwMkVFXFx1MDMwMC1cXHUwMzc0XFx1MDM3NlxcdTAzNzdcXHUwMzdBLVxcdTAzN0RcXHUwMzdGXFx1MDM4Ni1cXHUwMzhBXFx1MDM4Q1xcdTAzOEUtXFx1MDNBMVxcdTAzQTMtXFx1MDNGNVxcdTAzRjctXFx1MDQ4MVxcdTA0ODMtXFx1MDQ4N1xcdTA0OEEtXFx1MDUyRlxcdTA1MzEtXFx1MDU1NlxcdTA1NTlcXHUwNTYxLVxcdTA1ODdcXHUwNTkxLVxcdTA1QkRcXHUwNUJGXFx1MDVDMVxcdTA1QzJcXHUwNUM0XFx1MDVDNVxcdTA1QzdcXHUwNUQwLVxcdTA1RUFcXHUwNUYwLVxcdTA1RjJcXHUwNjEwLVxcdTA2MUFcXHUwNjIwLVxcdTA2NjlcXHUwNjZFLVxcdTA2RDNcXHUwNkQ1LVxcdTA2RENcXHUwNkRGLVxcdTA2RThcXHUwNkVBLVxcdTA2RkNcXHUwNkZGXFx1MDcxMC1cXHUwNzRBXFx1MDc0RC1cXHUwN0IxXFx1MDdDMC1cXHUwN0Y1XFx1MDdGQVxcdTA4MDAtXFx1MDgyRFxcdTA4NDAtXFx1MDg1QlxcdTA4QTAtXFx1MDhCNFxcdTA4RTMtXFx1MDk2M1xcdTA5NjYtXFx1MDk2RlxcdTA5NzEtXFx1MDk4M1xcdTA5ODUtXFx1MDk4Q1xcdTA5OEZcXHUwOTkwXFx1MDk5My1cXHUwOUE4XFx1MDlBQS1cXHUwOUIwXFx1MDlCMlxcdTA5QjYtXFx1MDlCOVxcdTA5QkMtXFx1MDlDNFxcdTA5QzdcXHUwOUM4XFx1MDlDQi1cXHUwOUNFXFx1MDlEN1xcdTA5RENcXHUwOUREXFx1MDlERi1cXHUwOUUzXFx1MDlFNi1cXHUwOUYxXFx1MEEwMS1cXHUwQTAzXFx1MEEwNS1cXHUwQTBBXFx1MEEwRlxcdTBBMTBcXHUwQTEzLVxcdTBBMjhcXHUwQTJBLVxcdTBBMzBcXHUwQTMyXFx1MEEzM1xcdTBBMzVcXHUwQTM2XFx1MEEzOFxcdTBBMzlcXHUwQTNDXFx1MEEzRS1cXHUwQTQyXFx1MEE0N1xcdTBBNDhcXHUwQTRCLVxcdTBBNERcXHUwQTUxXFx1MEE1OS1cXHUwQTVDXFx1MEE1RVxcdTBBNjYtXFx1MEE3NVxcdTBBODEtXFx1MEE4M1xcdTBBODUtXFx1MEE4RFxcdTBBOEYtXFx1MEE5MVxcdTBBOTMtXFx1MEFBOFxcdTBBQUEtXFx1MEFCMFxcdTBBQjJcXHUwQUIzXFx1MEFCNS1cXHUwQUI5XFx1MEFCQy1cXHUwQUM1XFx1MEFDNy1cXHUwQUM5XFx1MEFDQi1cXHUwQUNEXFx1MEFEMFxcdTBBRTAtXFx1MEFFM1xcdTBBRTYtXFx1MEFFRlxcdTBBRjlcXHUwQjAxLVxcdTBCMDNcXHUwQjA1LVxcdTBCMENcXHUwQjBGXFx1MEIxMFxcdTBCMTMtXFx1MEIyOFxcdTBCMkEtXFx1MEIzMFxcdTBCMzJcXHUwQjMzXFx1MEIzNS1cXHUwQjM5XFx1MEIzQy1cXHUwQjQ0XFx1MEI0N1xcdTBCNDhcXHUwQjRCLVxcdTBCNERcXHUwQjU2XFx1MEI1N1xcdTBCNUNcXHUwQjVEXFx1MEI1Ri1cXHUwQjYzXFx1MEI2Ni1cXHUwQjZGXFx1MEI3MVxcdTBCODJcXHUwQjgzXFx1MEI4NS1cXHUwQjhBXFx1MEI4RS1cXHUwQjkwXFx1MEI5Mi1cXHUwQjk1XFx1MEI5OVxcdTBCOUFcXHUwQjlDXFx1MEI5RVxcdTBCOUZcXHUwQkEzXFx1MEJBNFxcdTBCQTgtXFx1MEJBQVxcdTBCQUUtXFx1MEJCOVxcdTBCQkUtXFx1MEJDMlxcdTBCQzYtXFx1MEJDOFxcdTBCQ0EtXFx1MEJDRFxcdTBCRDBcXHUwQkQ3XFx1MEJFNi1cXHUwQkVGXFx1MEMwMC1cXHUwQzAzXFx1MEMwNS1cXHUwQzBDXFx1MEMwRS1cXHUwQzEwXFx1MEMxMi1cXHUwQzI4XFx1MEMyQS1cXHUwQzM5XFx1MEMzRC1cXHUwQzQ0XFx1MEM0Ni1cXHUwQzQ4XFx1MEM0QS1cXHUwQzREXFx1MEM1NVxcdTBDNTZcXHUwQzU4LVxcdTBDNUFcXHUwQzYwLVxcdTBDNjNcXHUwQzY2LVxcdTBDNkZcXHUwQzgxLVxcdTBDODNcXHUwQzg1LVxcdTBDOENcXHUwQzhFLVxcdTBDOTBcXHUwQzkyLVxcdTBDQThcXHUwQ0FBLVxcdTBDQjNcXHUwQ0I1LVxcdTBDQjlcXHUwQ0JDLVxcdTBDQzRcXHUwQ0M2LVxcdTBDQzhcXHUwQ0NBLVxcdTBDQ0RcXHUwQ0Q1XFx1MENENlxcdTBDREVcXHUwQ0UwLVxcdTBDRTNcXHUwQ0U2LVxcdTBDRUZcXHUwQ0YxXFx1MENGMlxcdTBEMDEtXFx1MEQwM1xcdTBEMDUtXFx1MEQwQ1xcdTBEMEUtXFx1MEQxMFxcdTBEMTItXFx1MEQzQVxcdTBEM0QtXFx1MEQ0NFxcdTBENDYtXFx1MEQ0OFxcdTBENEEtXFx1MEQ0RVxcdTBENTdcXHUwRDVGLVxcdTBENjNcXHUwRDY2LVxcdTBENkZcXHUwRDdBLVxcdTBEN0ZcXHUwRDgyXFx1MEQ4M1xcdTBEODUtXFx1MEQ5NlxcdTBEOUEtXFx1MERCMVxcdTBEQjMtXFx1MERCQlxcdTBEQkRcXHUwREMwLVxcdTBEQzZcXHUwRENBXFx1MERDRi1cXHUwREQ0XFx1MERENlxcdTBERDgtXFx1MERERlxcdTBERTYtXFx1MERFRlxcdTBERjJcXHUwREYzXFx1MEUwMS1cXHUwRTNBXFx1MEU0MC1cXHUwRTRFXFx1MEU1MC1cXHUwRTU5XFx1MEU4MVxcdTBFODJcXHUwRTg0XFx1MEU4N1xcdTBFODhcXHUwRThBXFx1MEU4RFxcdTBFOTQtXFx1MEU5N1xcdTBFOTktXFx1MEU5RlxcdTBFQTEtXFx1MEVBM1xcdTBFQTVcXHUwRUE3XFx1MEVBQVxcdTBFQUJcXHUwRUFELVxcdTBFQjlcXHUwRUJCLVxcdTBFQkRcXHUwRUMwLVxcdTBFQzRcXHUwRUM2XFx1MEVDOC1cXHUwRUNEXFx1MEVEMC1cXHUwRUQ5XFx1MEVEQy1cXHUwRURGXFx1MEYwMFxcdTBGMThcXHUwRjE5XFx1MEYyMC1cXHUwRjI5XFx1MEYzNVxcdTBGMzdcXHUwRjM5XFx1MEYzRS1cXHUwRjQ3XFx1MEY0OS1cXHUwRjZDXFx1MEY3MS1cXHUwRjg0XFx1MEY4Ni1cXHUwRjk3XFx1MEY5OS1cXHUwRkJDXFx1MEZDNlxcdTEwMDAtXFx1MTA0OVxcdTEwNTAtXFx1MTA5RFxcdTEwQTAtXFx1MTBDNVxcdTEwQzdcXHUxMENEXFx1MTBEMC1cXHUxMEZBXFx1MTBGQy1cXHUxMjQ4XFx1MTI0QS1cXHUxMjREXFx1MTI1MC1cXHUxMjU2XFx1MTI1OFxcdTEyNUEtXFx1MTI1RFxcdTEyNjAtXFx1MTI4OFxcdTEyOEEtXFx1MTI4RFxcdTEyOTAtXFx1MTJCMFxcdTEyQjItXFx1MTJCNVxcdTEyQjgtXFx1MTJCRVxcdTEyQzBcXHUxMkMyLVxcdTEyQzVcXHUxMkM4LVxcdTEyRDZcXHUxMkQ4LVxcdTEzMTBcXHUxMzEyLVxcdTEzMTVcXHUxMzE4LVxcdTEzNUFcXHUxMzVELVxcdTEzNUZcXHUxMzY5LVxcdTEzNzFcXHUxMzgwLVxcdTEzOEZcXHUxM0EwLVxcdTEzRjVcXHUxM0Y4LVxcdTEzRkRcXHUxNDAxLVxcdTE2NkNcXHUxNjZGLVxcdTE2N0ZcXHUxNjgxLVxcdTE2OUFcXHUxNkEwLVxcdTE2RUFcXHUxNkVFLVxcdTE2RjhcXHUxNzAwLVxcdTE3MENcXHUxNzBFLVxcdTE3MTRcXHUxNzIwLVxcdTE3MzRcXHUxNzQwLVxcdTE3NTNcXHUxNzYwLVxcdTE3NkNcXHUxNzZFLVxcdTE3NzBcXHUxNzcyXFx1MTc3M1xcdTE3ODAtXFx1MTdEM1xcdTE3RDdcXHUxN0RDXFx1MTdERFxcdTE3RTAtXFx1MTdFOVxcdTE4MEItXFx1MTgwRFxcdTE4MTAtXFx1MTgxOVxcdTE4MjAtXFx1MTg3N1xcdTE4ODAtXFx1MThBQVxcdTE4QjAtXFx1MThGNVxcdTE5MDAtXFx1MTkxRVxcdTE5MjAtXFx1MTkyQlxcdTE5MzAtXFx1MTkzQlxcdTE5NDYtXFx1MTk2RFxcdTE5NzAtXFx1MTk3NFxcdTE5ODAtXFx1MTlBQlxcdTE5QjAtXFx1MTlDOVxcdTE5RDAtXFx1MTlEQVxcdTFBMDAtXFx1MUExQlxcdTFBMjAtXFx1MUE1RVxcdTFBNjAtXFx1MUE3Q1xcdTFBN0YtXFx1MUE4OVxcdTFBOTAtXFx1MUE5OVxcdTFBQTdcXHUxQUIwLVxcdTFBQkRcXHUxQjAwLVxcdTFCNEJcXHUxQjUwLVxcdTFCNTlcXHUxQjZCLVxcdTFCNzNcXHUxQjgwLVxcdTFCRjNcXHUxQzAwLVxcdTFDMzdcXHUxQzQwLVxcdTFDNDlcXHUxQzRELVxcdTFDN0RcXHUxQ0QwLVxcdTFDRDJcXHUxQ0Q0LVxcdTFDRjZcXHUxQ0Y4XFx1MUNGOVxcdTFEMDAtXFx1MURGNVxcdTFERkMtXFx1MUYxNVxcdTFGMTgtXFx1MUYxRFxcdTFGMjAtXFx1MUY0NVxcdTFGNDgtXFx1MUY0RFxcdTFGNTAtXFx1MUY1N1xcdTFGNTlcXHUxRjVCXFx1MUY1RFxcdTFGNUYtXFx1MUY3RFxcdTFGODAtXFx1MUZCNFxcdTFGQjYtXFx1MUZCQ1xcdTFGQkVcXHUxRkMyLVxcdTFGQzRcXHUxRkM2LVxcdTFGQ0NcXHUxRkQwLVxcdTFGRDNcXHUxRkQ2LVxcdTFGREJcXHUxRkUwLVxcdTFGRUNcXHUxRkYyLVxcdTFGRjRcXHUxRkY2LVxcdTFGRkNcXHUyMDBDXFx1MjAwRFxcdTIwM0ZcXHUyMDQwXFx1MjA1NFxcdTIwNzFcXHUyMDdGXFx1MjA5MC1cXHUyMDlDXFx1MjBEMC1cXHUyMERDXFx1MjBFMVxcdTIwRTUtXFx1MjBGMFxcdTIxMDJcXHUyMTA3XFx1MjEwQS1cXHUyMTEzXFx1MjExNVxcdTIxMTgtXFx1MjExRFxcdTIxMjRcXHUyMTI2XFx1MjEyOFxcdTIxMkEtXFx1MjEzOVxcdTIxM0MtXFx1MjEzRlxcdTIxNDUtXFx1MjE0OVxcdTIxNEVcXHUyMTYwLVxcdTIxODhcXHUyQzAwLVxcdTJDMkVcXHUyQzMwLVxcdTJDNUVcXHUyQzYwLVxcdTJDRTRcXHUyQ0VCLVxcdTJDRjNcXHUyRDAwLVxcdTJEMjVcXHUyRDI3XFx1MkQyRFxcdTJEMzAtXFx1MkQ2N1xcdTJENkZcXHUyRDdGLVxcdTJEOTZcXHUyREEwLVxcdTJEQTZcXHUyREE4LVxcdTJEQUVcXHUyREIwLVxcdTJEQjZcXHUyREI4LVxcdTJEQkVcXHUyREMwLVxcdTJEQzZcXHUyREM4LVxcdTJEQ0VcXHUyREQwLVxcdTJERDZcXHUyREQ4LVxcdTJEREVcXHUyREUwLVxcdTJERkZcXHUzMDA1LVxcdTMwMDdcXHUzMDIxLVxcdTMwMkZcXHUzMDMxLVxcdTMwMzVcXHUzMDM4LVxcdTMwM0NcXHUzMDQxLVxcdTMwOTZcXHUzMDk5LVxcdTMwOUZcXHUzMEExLVxcdTMwRkFcXHUzMEZDLVxcdTMwRkZcXHUzMTA1LVxcdTMxMkRcXHUzMTMxLVxcdTMxOEVcXHUzMUEwLVxcdTMxQkFcXHUzMUYwLVxcdTMxRkZcXHUzNDAwLVxcdTREQjVcXHU0RTAwLVxcdTlGRDVcXHVBMDAwLVxcdUE0OENcXHVBNEQwLVxcdUE0RkRcXHVBNTAwLVxcdUE2MENcXHVBNjEwLVxcdUE2MkJcXHVBNjQwLVxcdUE2NkZcXHVBNjc0LVxcdUE2N0RcXHVBNjdGLVxcdUE2RjFcXHVBNzE3LVxcdUE3MUZcXHVBNzIyLVxcdUE3ODhcXHVBNzhCLVxcdUE3QURcXHVBN0IwLVxcdUE3QjdcXHVBN0Y3LVxcdUE4MjdcXHVBODQwLVxcdUE4NzNcXHVBODgwLVxcdUE4QzRcXHVBOEQwLVxcdUE4RDlcXHVBOEUwLVxcdUE4RjdcXHVBOEZCXFx1QThGRFxcdUE5MDAtXFx1QTkyRFxcdUE5MzAtXFx1QTk1M1xcdUE5NjAtXFx1QTk3Q1xcdUE5ODAtXFx1QTlDMFxcdUE5Q0YtXFx1QTlEOVxcdUE5RTAtXFx1QTlGRVxcdUFBMDAtXFx1QUEzNlxcdUFBNDAtXFx1QUE0RFxcdUFBNTAtXFx1QUE1OVxcdUFBNjAtXFx1QUE3NlxcdUFBN0EtXFx1QUFDMlxcdUFBREItXFx1QUFERFxcdUFBRTAtXFx1QUFFRlxcdUFBRjItXFx1QUFGNlxcdUFCMDEtXFx1QUIwNlxcdUFCMDktXFx1QUIwRVxcdUFCMTEtXFx1QUIxNlxcdUFCMjAtXFx1QUIyNlxcdUFCMjgtXFx1QUIyRVxcdUFCMzAtXFx1QUI1QVxcdUFCNUMtXFx1QUI2NVxcdUFCNzAtXFx1QUJFQVxcdUFCRUNcXHVBQkVEXFx1QUJGMC1cXHVBQkY5XFx1QUMwMC1cXHVEN0EzXFx1RDdCMC1cXHVEN0M2XFx1RDdDQi1cXHVEN0ZCXFx1RjkwMC1cXHVGQTZEXFx1RkE3MC1cXHVGQUQ5XFx1RkIwMC1cXHVGQjA2XFx1RkIxMy1cXHVGQjE3XFx1RkIxRC1cXHVGQjI4XFx1RkIyQS1cXHVGQjM2XFx1RkIzOC1cXHVGQjNDXFx1RkIzRVxcdUZCNDBcXHVGQjQxXFx1RkI0M1xcdUZCNDRcXHVGQjQ2LVxcdUZCQjFcXHVGQkQzLVxcdUZEM0RcXHVGRDUwLVxcdUZEOEZcXHVGRDkyLVxcdUZEQzdcXHVGREYwLVxcdUZERkJcXHVGRTAwLVxcdUZFMEZcXHVGRTIwLVxcdUZFMkZcXHVGRTMzXFx1RkUzNFxcdUZFNEQtXFx1RkU0RlxcdUZFNzAtXFx1RkU3NFxcdUZFNzYtXFx1RkVGQ1xcdUZGMTAtXFx1RkYxOVxcdUZGMjEtXFx1RkYzQVxcdUZGM0ZcXHVGRjQxLVxcdUZGNUFcXHVGRjY2LVxcdUZGQkVcXHVGRkMyLVxcdUZGQzdcXHVGRkNBLVxcdUZGQ0ZcXHVGRkQyLVxcdUZGRDdcXHVGRkRBLVxcdUZGRENdfFxcdUQ4MDBbXFx1REMwMC1cXHVEQzBCXFx1REMwRC1cXHVEQzI2XFx1REMyOC1cXHVEQzNBXFx1REMzQ1xcdURDM0RcXHVEQzNGLVxcdURDNERcXHVEQzUwLVxcdURDNURcXHVEQzgwLVxcdURDRkFcXHVERDQwLVxcdURENzRcXHVEREZEXFx1REU4MC1cXHVERTlDXFx1REVBMC1cXHVERUQwXFx1REVFMFxcdURGMDAtXFx1REYxRlxcdURGMzAtXFx1REY0QVxcdURGNTAtXFx1REY3QVxcdURGODAtXFx1REY5RFxcdURGQTAtXFx1REZDM1xcdURGQzgtXFx1REZDRlxcdURGRDEtXFx1REZENV18XFx1RDgwMVtcXHVEQzAwLVxcdURDOURcXHVEQ0EwLVxcdURDQTlcXHVERDAwLVxcdUREMjdcXHVERDMwLVxcdURENjNcXHVERTAwLVxcdURGMzZcXHVERjQwLVxcdURGNTVcXHVERjYwLVxcdURGNjddfFxcdUQ4MDJbXFx1REMwMC1cXHVEQzA1XFx1REMwOFxcdURDMEEtXFx1REMzNVxcdURDMzdcXHVEQzM4XFx1REMzQ1xcdURDM0YtXFx1REM1NVxcdURDNjAtXFx1REM3NlxcdURDODAtXFx1REM5RVxcdURDRTAtXFx1RENGMlxcdURDRjRcXHVEQ0Y1XFx1REQwMC1cXHVERDE1XFx1REQyMC1cXHVERDM5XFx1REQ4MC1cXHVEREI3XFx1RERCRVxcdUREQkZcXHVERTAwLVxcdURFMDNcXHVERTA1XFx1REUwNlxcdURFMEMtXFx1REUxM1xcdURFMTUtXFx1REUxN1xcdURFMTktXFx1REUzM1xcdURFMzgtXFx1REUzQVxcdURFM0ZcXHVERTYwLVxcdURFN0NcXHVERTgwLVxcdURFOUNcXHVERUMwLVxcdURFQzdcXHVERUM5LVxcdURFRTZcXHVERjAwLVxcdURGMzVcXHVERjQwLVxcdURGNTVcXHVERjYwLVxcdURGNzJcXHVERjgwLVxcdURGOTFdfFxcdUQ4MDNbXFx1REMwMC1cXHVEQzQ4XFx1REM4MC1cXHVEQ0IyXFx1RENDMC1cXHVEQ0YyXXxcXHVEODA0W1xcdURDMDAtXFx1REM0NlxcdURDNjYtXFx1REM2RlxcdURDN0YtXFx1RENCQVxcdURDRDAtXFx1RENFOFxcdURDRjAtXFx1RENGOVxcdUREMDAtXFx1REQzNFxcdUREMzYtXFx1REQzRlxcdURENTAtXFx1REQ3M1xcdURENzZcXHVERDgwLVxcdUREQzRcXHVERENBLVxcdUREQ0NcXHVEREQwLVxcdUREREFcXHVERERDXFx1REUwMC1cXHVERTExXFx1REUxMy1cXHVERTM3XFx1REU4MC1cXHVERTg2XFx1REU4OFxcdURFOEEtXFx1REU4RFxcdURFOEYtXFx1REU5RFxcdURFOUYtXFx1REVBOFxcdURFQjAtXFx1REVFQVxcdURFRjAtXFx1REVGOVxcdURGMDAtXFx1REYwM1xcdURGMDUtXFx1REYwQ1xcdURGMEZcXHVERjEwXFx1REYxMy1cXHVERjI4XFx1REYyQS1cXHVERjMwXFx1REYzMlxcdURGMzNcXHVERjM1LVxcdURGMzlcXHVERjNDLVxcdURGNDRcXHVERjQ3XFx1REY0OFxcdURGNEItXFx1REY0RFxcdURGNTBcXHVERjU3XFx1REY1RC1cXHVERjYzXFx1REY2Ni1cXHVERjZDXFx1REY3MC1cXHVERjc0XXxcXHVEODA1W1xcdURDODAtXFx1RENDNVxcdURDQzdcXHVEQ0QwLVxcdURDRDlcXHVERDgwLVxcdUREQjVcXHVEREI4LVxcdUREQzBcXHVEREQ4LVxcdURERERcXHVERTAwLVxcdURFNDBcXHVERTQ0XFx1REU1MC1cXHVERTU5XFx1REU4MC1cXHVERUI3XFx1REVDMC1cXHVERUM5XFx1REYwMC1cXHVERjE5XFx1REYxRC1cXHVERjJCXFx1REYzMC1cXHVERjM5XXxcXHVEODA2W1xcdURDQTAtXFx1RENFOVxcdURDRkZcXHVERUMwLVxcdURFRjhdfFxcdUQ4MDhbXFx1REMwMC1cXHVERjk5XXxcXHVEODA5W1xcdURDMDAtXFx1REM2RVxcdURDODAtXFx1REQ0M118W1xcdUQ4MENcXHVEODQwLVxcdUQ4NjhcXHVEODZBLVxcdUQ4NkNcXHVEODZGLVxcdUQ4NzJdW1xcdURDMDAtXFx1REZGRl18XFx1RDgwRFtcXHVEQzAwLVxcdURDMkVdfFxcdUQ4MTFbXFx1REMwMC1cXHVERTQ2XXxcXHVEODFBW1xcdURDMDAtXFx1REUzOFxcdURFNDAtXFx1REU1RVxcdURFNjAtXFx1REU2OVxcdURFRDAtXFx1REVFRFxcdURFRjAtXFx1REVGNFxcdURGMDAtXFx1REYzNlxcdURGNDAtXFx1REY0M1xcdURGNTAtXFx1REY1OVxcdURGNjMtXFx1REY3N1xcdURGN0QtXFx1REY4Rl18XFx1RDgxQltcXHVERjAwLVxcdURGNDRcXHVERjUwLVxcdURGN0VcXHVERjhGLVxcdURGOUZdfFxcdUQ4MkNbXFx1REMwMFxcdURDMDFdfFxcdUQ4MkZbXFx1REMwMC1cXHVEQzZBXFx1REM3MC1cXHVEQzdDXFx1REM4MC1cXHVEQzg4XFx1REM5MC1cXHVEQzk5XFx1REM5RFxcdURDOUVdfFxcdUQ4MzRbXFx1REQ2NS1cXHVERDY5XFx1REQ2RC1cXHVERDcyXFx1REQ3Qi1cXHVERDgyXFx1REQ4NS1cXHVERDhCXFx1RERBQS1cXHVEREFEXFx1REU0Mi1cXHVERTQ0XXxcXHVEODM1W1xcdURDMDAtXFx1REM1NFxcdURDNTYtXFx1REM5Q1xcdURDOUVcXHVEQzlGXFx1RENBMlxcdURDQTVcXHVEQ0E2XFx1RENBOS1cXHVEQ0FDXFx1RENBRS1cXHVEQ0I5XFx1RENCQlxcdURDQkQtXFx1RENDM1xcdURDQzUtXFx1REQwNVxcdUREMDctXFx1REQwQVxcdUREMEQtXFx1REQxNFxcdUREMTYtXFx1REQxQ1xcdUREMUUtXFx1REQzOVxcdUREM0ItXFx1REQzRVxcdURENDAtXFx1REQ0NFxcdURENDZcXHVERDRBLVxcdURENTBcXHVERDUyLVxcdURFQTVcXHVERUE4LVxcdURFQzBcXHVERUMyLVxcdURFREFcXHVERURDLVxcdURFRkFcXHVERUZDLVxcdURGMTRcXHVERjE2LVxcdURGMzRcXHVERjM2LVxcdURGNEVcXHVERjUwLVxcdURGNkVcXHVERjcwLVxcdURGODhcXHVERjhBLVxcdURGQThcXHVERkFBLVxcdURGQzJcXHVERkM0LVxcdURGQ0JcXHVERkNFLVxcdURGRkZdfFxcdUQ4MzZbXFx1REUwMC1cXHVERTM2XFx1REUzQi1cXHVERTZDXFx1REU3NVxcdURFODRcXHVERTlCLVxcdURFOUZcXHVERUExLVxcdURFQUZdfFxcdUQ4M0FbXFx1REMwMC1cXHVEQ0M0XFx1RENEMC1cXHVEQ0Q2XXxcXHVEODNCW1xcdURFMDAtXFx1REUwM1xcdURFMDUtXFx1REUxRlxcdURFMjFcXHVERTIyXFx1REUyNFxcdURFMjdcXHVERTI5LVxcdURFMzJcXHVERTM0LVxcdURFMzdcXHVERTM5XFx1REUzQlxcdURFNDJcXHVERTQ3XFx1REU0OVxcdURFNEJcXHVERTRELVxcdURFNEZcXHVERTUxXFx1REU1MlxcdURFNTRcXHVERTU3XFx1REU1OVxcdURFNUJcXHVERTVEXFx1REU1RlxcdURFNjFcXHVERTYyXFx1REU2NFxcdURFNjctXFx1REU2QVxcdURFNkMtXFx1REU3MlxcdURFNzQtXFx1REU3N1xcdURFNzktXFx1REU3Q1xcdURFN0VcXHVERTgwLVxcdURFODlcXHVERThCLVxcdURFOUJcXHVERUExLVxcdURFQTNcXHVERUE1LVxcdURFQTlcXHVERUFCLVxcdURFQkJdfFxcdUQ4NjlbXFx1REMwMC1cXHVERUQ2XFx1REYwMC1cXHVERkZGXXxcXHVEODZEW1xcdURDMDAtXFx1REYzNFxcdURGNDAtXFx1REZGRl18XFx1RDg2RVtcXHVEQzAwLVxcdURDMURcXHVEQzIwLVxcdURGRkZdfFxcdUQ4NzNbXFx1REMwMC1cXHVERUExXXxcXHVEODdFW1xcdURDMDAtXFx1REUxRF18XFx1REI0MFtcXHVERDAwLVxcdURERUZdL1xyXG5cdH07XHJcblx0ZXhwb3J0cy5DaGFyYWN0ZXIgPSB7XHJcblx0ICAgIC8qIHRzbGludDpkaXNhYmxlOm5vLWJpdHdpc2UgKi9cclxuXHQgICAgZnJvbUNvZGVQb2ludDogZnVuY3Rpb24gKGNwKSB7XHJcblx0ICAgICAgICByZXR1cm4gKGNwIDwgMHgxMDAwMCkgPyBTdHJpbmcuZnJvbUNoYXJDb2RlKGNwKSA6XHJcblx0ICAgICAgICAgICAgU3RyaW5nLmZyb21DaGFyQ29kZSgweEQ4MDAgKyAoKGNwIC0gMHgxMDAwMCkgPj4gMTApKSArXHJcblx0ICAgICAgICAgICAgICAgIFN0cmluZy5mcm9tQ2hhckNvZGUoMHhEQzAwICsgKChjcCAtIDB4MTAwMDApICYgMTAyMykpO1xyXG5cdCAgICB9LFxyXG5cdCAgICAvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy13aGl0ZS1zcGFjZVxyXG5cdCAgICBpc1doaXRlU3BhY2U6IGZ1bmN0aW9uIChjcCkge1xyXG5cdCAgICAgICAgcmV0dXJuIChjcCA9PT0gMHgyMCkgfHwgKGNwID09PSAweDA5KSB8fCAoY3AgPT09IDB4MEIpIHx8IChjcCA9PT0gMHgwQykgfHwgKGNwID09PSAweEEwKSB8fFxyXG5cdCAgICAgICAgICAgIChjcCA+PSAweDE2ODAgJiYgWzB4MTY4MCwgMHgyMDAwLCAweDIwMDEsIDB4MjAwMiwgMHgyMDAzLCAweDIwMDQsIDB4MjAwNSwgMHgyMDA2LCAweDIwMDcsIDB4MjAwOCwgMHgyMDA5LCAweDIwMEEsIDB4MjAyRiwgMHgyMDVGLCAweDMwMDAsIDB4RkVGRl0uaW5kZXhPZihjcCkgPj0gMCk7XHJcblx0ICAgIH0sXHJcblx0ICAgIC8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLWxpbmUtdGVybWluYXRvcnNcclxuXHQgICAgaXNMaW5lVGVybWluYXRvcjogZnVuY3Rpb24gKGNwKSB7XHJcblx0ICAgICAgICByZXR1cm4gKGNwID09PSAweDBBKSB8fCAoY3AgPT09IDB4MEQpIHx8IChjcCA9PT0gMHgyMDI4KSB8fCAoY3AgPT09IDB4MjAyOSk7XHJcblx0ICAgIH0sXHJcblx0ICAgIC8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLW5hbWVzLWFuZC1rZXl3b3Jkc1xyXG5cdCAgICBpc0lkZW50aWZpZXJTdGFydDogZnVuY3Rpb24gKGNwKSB7XHJcblx0ICAgICAgICByZXR1cm4gKGNwID09PSAweDI0KSB8fCAoY3AgPT09IDB4NUYpIHx8XHJcblx0ICAgICAgICAgICAgKGNwID49IDB4NDEgJiYgY3AgPD0gMHg1QSkgfHxcclxuXHQgICAgICAgICAgICAoY3AgPj0gMHg2MSAmJiBjcCA8PSAweDdBKSB8fFxyXG5cdCAgICAgICAgICAgIChjcCA9PT0gMHg1QykgfHxcclxuXHQgICAgICAgICAgICAoKGNwID49IDB4ODApICYmIFJlZ2V4Lk5vbkFzY2lpSWRlbnRpZmllclN0YXJ0LnRlc3QoZXhwb3J0cy5DaGFyYWN0ZXIuZnJvbUNvZGVQb2ludChjcCkpKTtcclxuXHQgICAgfSxcclxuXHQgICAgaXNJZGVudGlmaWVyUGFydDogZnVuY3Rpb24gKGNwKSB7XHJcblx0ICAgICAgICByZXR1cm4gKGNwID09PSAweDI0KSB8fCAoY3AgPT09IDB4NUYpIHx8XHJcblx0ICAgICAgICAgICAgKGNwID49IDB4NDEgJiYgY3AgPD0gMHg1QSkgfHxcclxuXHQgICAgICAgICAgICAoY3AgPj0gMHg2MSAmJiBjcCA8PSAweDdBKSB8fFxyXG5cdCAgICAgICAgICAgIChjcCA+PSAweDMwICYmIGNwIDw9IDB4MzkpIHx8XHJcblx0ICAgICAgICAgICAgKGNwID09PSAweDVDKSB8fFxyXG5cdCAgICAgICAgICAgICgoY3AgPj0gMHg4MCkgJiYgUmVnZXguTm9uQXNjaWlJZGVudGlmaWVyUGFydC50ZXN0KGV4cG9ydHMuQ2hhcmFjdGVyLmZyb21Db2RlUG9pbnQoY3ApKSk7XHJcblx0ICAgIH0sXHJcblx0ICAgIC8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLWxpdGVyYWxzLW51bWVyaWMtbGl0ZXJhbHNcclxuXHQgICAgaXNEZWNpbWFsRGlnaXQ6IGZ1bmN0aW9uIChjcCkge1xyXG5cdCAgICAgICAgcmV0dXJuIChjcCA+PSAweDMwICYmIGNwIDw9IDB4MzkpOyAvLyAwLi45XHJcblx0ICAgIH0sXHJcblx0ICAgIGlzSGV4RGlnaXQ6IGZ1bmN0aW9uIChjcCkge1xyXG5cdCAgICAgICAgcmV0dXJuIChjcCA+PSAweDMwICYmIGNwIDw9IDB4MzkpIHx8XHJcblx0ICAgICAgICAgICAgKGNwID49IDB4NDEgJiYgY3AgPD0gMHg0NikgfHxcclxuXHQgICAgICAgICAgICAoY3AgPj0gMHg2MSAmJiBjcCA8PSAweDY2KTsgLy8gYS4uZlxyXG5cdCAgICB9LFxyXG5cdCAgICBpc09jdGFsRGlnaXQ6IGZ1bmN0aW9uIChjcCkge1xyXG5cdCAgICAgICAgcmV0dXJuIChjcCA+PSAweDMwICYmIGNwIDw9IDB4MzcpOyAvLyAwLi43XHJcblx0ICAgIH1cclxuXHR9O1xyXG5cblxuLyoqKi8gfSxcbi8qIDUgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cdFwidXNlIHN0cmljdFwiO1xyXG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuXHR2YXIganN4X3N5bnRheF8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2KTtcclxuXHQvKiB0c2xpbnQ6ZGlzYWJsZTptYXgtY2xhc3Nlcy1wZXItZmlsZSAqL1xyXG5cdHZhciBKU1hDbG9zaW5nRWxlbWVudCA9IChmdW5jdGlvbiAoKSB7XHJcblx0ICAgIGZ1bmN0aW9uIEpTWENsb3NpbmdFbGVtZW50KG5hbWUpIHtcclxuXHQgICAgICAgIHRoaXMudHlwZSA9IGpzeF9zeW50YXhfMS5KU1hTeW50YXguSlNYQ2xvc2luZ0VsZW1lbnQ7XHJcblx0ICAgICAgICB0aGlzLm5hbWUgPSBuYW1lO1xyXG5cdCAgICB9XHJcblx0ICAgIHJldHVybiBKU1hDbG9zaW5nRWxlbWVudDtcclxuXHR9KCkpO1xyXG5cdGV4cG9ydHMuSlNYQ2xvc2luZ0VsZW1lbnQgPSBKU1hDbG9zaW5nRWxlbWVudDtcclxuXHR2YXIgSlNYRWxlbWVudCA9IChmdW5jdGlvbiAoKSB7XHJcblx0ICAgIGZ1bmN0aW9uIEpTWEVsZW1lbnQob3BlbmluZ0VsZW1lbnQsIGNoaWxkcmVuLCBjbG9zaW5nRWxlbWVudCkge1xyXG5cdCAgICAgICAgdGhpcy50eXBlID0ganN4X3N5bnRheF8xLkpTWFN5bnRheC5KU1hFbGVtZW50O1xyXG5cdCAgICAgICAgdGhpcy5vcGVuaW5nRWxlbWVudCA9IG9wZW5pbmdFbGVtZW50O1xyXG5cdCAgICAgICAgdGhpcy5jaGlsZHJlbiA9IGNoaWxkcmVuO1xyXG5cdCAgICAgICAgdGhpcy5jbG9zaW5nRWxlbWVudCA9IGNsb3NpbmdFbGVtZW50O1xyXG5cdCAgICB9XHJcblx0ICAgIHJldHVybiBKU1hFbGVtZW50O1xyXG5cdH0oKSk7XHJcblx0ZXhwb3J0cy5KU1hFbGVtZW50ID0gSlNYRWxlbWVudDtcclxuXHR2YXIgSlNYRW1wdHlFeHByZXNzaW9uID0gKGZ1bmN0aW9uICgpIHtcclxuXHQgICAgZnVuY3Rpb24gSlNYRW1wdHlFeHByZXNzaW9uKCkge1xyXG5cdCAgICAgICAgdGhpcy50eXBlID0ganN4X3N5bnRheF8xLkpTWFN5bnRheC5KU1hFbXB0eUV4cHJlc3Npb247XHJcblx0ICAgIH1cclxuXHQgICAgcmV0dXJuIEpTWEVtcHR5RXhwcmVzc2lvbjtcclxuXHR9KCkpO1xyXG5cdGV4cG9ydHMuSlNYRW1wdHlFeHByZXNzaW9uID0gSlNYRW1wdHlFeHByZXNzaW9uO1xyXG5cdHZhciBKU1hFeHByZXNzaW9uQ29udGFpbmVyID0gKGZ1bmN0aW9uICgpIHtcclxuXHQgICAgZnVuY3Rpb24gSlNYRXhwcmVzc2lvbkNvbnRhaW5lcihleHByZXNzaW9uKSB7XHJcblx0ICAgICAgICB0aGlzLnR5cGUgPSBqc3hfc3ludGF4XzEuSlNYU3ludGF4LkpTWEV4cHJlc3Npb25Db250YWluZXI7XHJcblx0ICAgICAgICB0aGlzLmV4cHJlc3Npb24gPSBleHByZXNzaW9uO1xyXG5cdCAgICB9XHJcblx0ICAgIHJldHVybiBKU1hFeHByZXNzaW9uQ29udGFpbmVyO1xyXG5cdH0oKSk7XHJcblx0ZXhwb3J0cy5KU1hFeHByZXNzaW9uQ29udGFpbmVyID0gSlNYRXhwcmVzc2lvbkNvbnRhaW5lcjtcclxuXHR2YXIgSlNYSWRlbnRpZmllciA9IChmdW5jdGlvbiAoKSB7XHJcblx0ICAgIGZ1bmN0aW9uIEpTWElkZW50aWZpZXIobmFtZSkge1xyXG5cdCAgICAgICAgdGhpcy50eXBlID0ganN4X3N5bnRheF8xLkpTWFN5bnRheC5KU1hJZGVudGlmaWVyO1xyXG5cdCAgICAgICAgdGhpcy5uYW1lID0gbmFtZTtcclxuXHQgICAgfVxyXG5cdCAgICByZXR1cm4gSlNYSWRlbnRpZmllcjtcclxuXHR9KCkpO1xyXG5cdGV4cG9ydHMuSlNYSWRlbnRpZmllciA9IEpTWElkZW50aWZpZXI7XHJcblx0dmFyIEpTWE1lbWJlckV4cHJlc3Npb24gPSAoZnVuY3Rpb24gKCkge1xyXG5cdCAgICBmdW5jdGlvbiBKU1hNZW1iZXJFeHByZXNzaW9uKG9iamVjdCwgcHJvcGVydHkpIHtcclxuXHQgICAgICAgIHRoaXMudHlwZSA9IGpzeF9zeW50YXhfMS5KU1hTeW50YXguSlNYTWVtYmVyRXhwcmVzc2lvbjtcclxuXHQgICAgICAgIHRoaXMub2JqZWN0ID0gb2JqZWN0O1xyXG5cdCAgICAgICAgdGhpcy5wcm9wZXJ0eSA9IHByb3BlcnR5O1xyXG5cdCAgICB9XHJcblx0ICAgIHJldHVybiBKU1hNZW1iZXJFeHByZXNzaW9uO1xyXG5cdH0oKSk7XHJcblx0ZXhwb3J0cy5KU1hNZW1iZXJFeHByZXNzaW9uID0gSlNYTWVtYmVyRXhwcmVzc2lvbjtcclxuXHR2YXIgSlNYQXR0cmlidXRlID0gKGZ1bmN0aW9uICgpIHtcclxuXHQgICAgZnVuY3Rpb24gSlNYQXR0cmlidXRlKG5hbWUsIHZhbHVlKSB7XHJcblx0ICAgICAgICB0aGlzLnR5cGUgPSBqc3hfc3ludGF4XzEuSlNYU3ludGF4LkpTWEF0dHJpYnV0ZTtcclxuXHQgICAgICAgIHRoaXMubmFtZSA9IG5hbWU7XHJcblx0ICAgICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XHJcblx0ICAgIH1cclxuXHQgICAgcmV0dXJuIEpTWEF0dHJpYnV0ZTtcclxuXHR9KCkpO1xyXG5cdGV4cG9ydHMuSlNYQXR0cmlidXRlID0gSlNYQXR0cmlidXRlO1xyXG5cdHZhciBKU1hOYW1lc3BhY2VkTmFtZSA9IChmdW5jdGlvbiAoKSB7XHJcblx0ICAgIGZ1bmN0aW9uIEpTWE5hbWVzcGFjZWROYW1lKG5hbWVzcGFjZSwgbmFtZSkge1xyXG5cdCAgICAgICAgdGhpcy50eXBlID0ganN4X3N5bnRheF8xLkpTWFN5bnRheC5KU1hOYW1lc3BhY2VkTmFtZTtcclxuXHQgICAgICAgIHRoaXMubmFtZXNwYWNlID0gbmFtZXNwYWNlO1xyXG5cdCAgICAgICAgdGhpcy5uYW1lID0gbmFtZTtcclxuXHQgICAgfVxyXG5cdCAgICByZXR1cm4gSlNYTmFtZXNwYWNlZE5hbWU7XHJcblx0fSgpKTtcclxuXHRleHBvcnRzLkpTWE5hbWVzcGFjZWROYW1lID0gSlNYTmFtZXNwYWNlZE5hbWU7XHJcblx0dmFyIEpTWE9wZW5pbmdFbGVtZW50ID0gKGZ1bmN0aW9uICgpIHtcclxuXHQgICAgZnVuY3Rpb24gSlNYT3BlbmluZ0VsZW1lbnQobmFtZSwgc2VsZkNsb3NpbmcsIGF0dHJpYnV0ZXMpIHtcclxuXHQgICAgICAgIHRoaXMudHlwZSA9IGpzeF9zeW50YXhfMS5KU1hTeW50YXguSlNYT3BlbmluZ0VsZW1lbnQ7XHJcblx0ICAgICAgICB0aGlzLm5hbWUgPSBuYW1lO1xyXG5cdCAgICAgICAgdGhpcy5zZWxmQ2xvc2luZyA9IHNlbGZDbG9zaW5nO1xyXG5cdCAgICAgICAgdGhpcy5hdHRyaWJ1dGVzID0gYXR0cmlidXRlcztcclxuXHQgICAgfVxyXG5cdCAgICByZXR1cm4gSlNYT3BlbmluZ0VsZW1lbnQ7XHJcblx0fSgpKTtcclxuXHRleHBvcnRzLkpTWE9wZW5pbmdFbGVtZW50ID0gSlNYT3BlbmluZ0VsZW1lbnQ7XHJcblx0dmFyIEpTWFNwcmVhZEF0dHJpYnV0ZSA9IChmdW5jdGlvbiAoKSB7XHJcblx0ICAgIGZ1bmN0aW9uIEpTWFNwcmVhZEF0dHJpYnV0ZShhcmd1bWVudCkge1xyXG5cdCAgICAgICAgdGhpcy50eXBlID0ganN4X3N5bnRheF8xLkpTWFN5bnRheC5KU1hTcHJlYWRBdHRyaWJ1dGU7XHJcblx0ICAgICAgICB0aGlzLmFyZ3VtZW50ID0gYXJndW1lbnQ7XHJcblx0ICAgIH1cclxuXHQgICAgcmV0dXJuIEpTWFNwcmVhZEF0dHJpYnV0ZTtcclxuXHR9KCkpO1xyXG5cdGV4cG9ydHMuSlNYU3ByZWFkQXR0cmlidXRlID0gSlNYU3ByZWFkQXR0cmlidXRlO1xyXG5cdHZhciBKU1hUZXh0ID0gKGZ1bmN0aW9uICgpIHtcclxuXHQgICAgZnVuY3Rpb24gSlNYVGV4dCh2YWx1ZSwgcmF3KSB7XHJcblx0ICAgICAgICB0aGlzLnR5cGUgPSBqc3hfc3ludGF4XzEuSlNYU3ludGF4LkpTWFRleHQ7XHJcblx0ICAgICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XHJcblx0ICAgICAgICB0aGlzLnJhdyA9IHJhdztcclxuXHQgICAgfVxyXG5cdCAgICByZXR1cm4gSlNYVGV4dDtcclxuXHR9KCkpO1xyXG5cdGV4cG9ydHMuSlNYVGV4dCA9IEpTWFRleHQ7XHJcblxuXG4vKioqLyB9LFxuLyogNiAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cblx0XCJ1c2Ugc3RyaWN0XCI7XHJcblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG5cdGV4cG9ydHMuSlNYU3ludGF4ID0ge1xyXG5cdCAgICBKU1hBdHRyaWJ1dGU6ICdKU1hBdHRyaWJ1dGUnLFxyXG5cdCAgICBKU1hDbG9zaW5nRWxlbWVudDogJ0pTWENsb3NpbmdFbGVtZW50JyxcclxuXHQgICAgSlNYRWxlbWVudDogJ0pTWEVsZW1lbnQnLFxyXG5cdCAgICBKU1hFbXB0eUV4cHJlc3Npb246ICdKU1hFbXB0eUV4cHJlc3Npb24nLFxyXG5cdCAgICBKU1hFeHByZXNzaW9uQ29udGFpbmVyOiAnSlNYRXhwcmVzc2lvbkNvbnRhaW5lcicsXHJcblx0ICAgIEpTWElkZW50aWZpZXI6ICdKU1hJZGVudGlmaWVyJyxcclxuXHQgICAgSlNYTWVtYmVyRXhwcmVzc2lvbjogJ0pTWE1lbWJlckV4cHJlc3Npb24nLFxyXG5cdCAgICBKU1hOYW1lc3BhY2VkTmFtZTogJ0pTWE5hbWVzcGFjZWROYW1lJyxcclxuXHQgICAgSlNYT3BlbmluZ0VsZW1lbnQ6ICdKU1hPcGVuaW5nRWxlbWVudCcsXHJcblx0ICAgIEpTWFNwcmVhZEF0dHJpYnV0ZTogJ0pTWFNwcmVhZEF0dHJpYnV0ZScsXHJcblx0ICAgIEpTWFRleHQ6ICdKU1hUZXh0J1xyXG5cdH07XHJcblxuXG4vKioqLyB9LFxuLyogNyAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblx0XCJ1c2Ugc3RyaWN0XCI7XHJcblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG5cdHZhciBzeW50YXhfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMik7XHJcblx0LyogdHNsaW50OmRpc2FibGU6bWF4LWNsYXNzZXMtcGVyLWZpbGUgKi9cclxuXHR2YXIgQXJyYXlFeHByZXNzaW9uID0gKGZ1bmN0aW9uICgpIHtcclxuXHQgICAgZnVuY3Rpb24gQXJyYXlFeHByZXNzaW9uKGVsZW1lbnRzKSB7XHJcblx0ICAgICAgICB0aGlzLnR5cGUgPSBzeW50YXhfMS5TeW50YXguQXJyYXlFeHByZXNzaW9uO1xyXG5cdCAgICAgICAgdGhpcy5lbGVtZW50cyA9IGVsZW1lbnRzO1xyXG5cdCAgICB9XHJcblx0ICAgIHJldHVybiBBcnJheUV4cHJlc3Npb247XHJcblx0fSgpKTtcclxuXHRleHBvcnRzLkFycmF5RXhwcmVzc2lvbiA9IEFycmF5RXhwcmVzc2lvbjtcclxuXHR2YXIgQXJyYXlQYXR0ZXJuID0gKGZ1bmN0aW9uICgpIHtcclxuXHQgICAgZnVuY3Rpb24gQXJyYXlQYXR0ZXJuKGVsZW1lbnRzKSB7XHJcblx0ICAgICAgICB0aGlzLnR5cGUgPSBzeW50YXhfMS5TeW50YXguQXJyYXlQYXR0ZXJuO1xyXG5cdCAgICAgICAgdGhpcy5lbGVtZW50cyA9IGVsZW1lbnRzO1xyXG5cdCAgICB9XHJcblx0ICAgIHJldHVybiBBcnJheVBhdHRlcm47XHJcblx0fSgpKTtcclxuXHRleHBvcnRzLkFycmF5UGF0dGVybiA9IEFycmF5UGF0dGVybjtcclxuXHR2YXIgQXJyb3dGdW5jdGlvbkV4cHJlc3Npb24gPSAoZnVuY3Rpb24gKCkge1xyXG5cdCAgICBmdW5jdGlvbiBBcnJvd0Z1bmN0aW9uRXhwcmVzc2lvbihwYXJhbXMsIGJvZHksIGV4cHJlc3Npb24pIHtcclxuXHQgICAgICAgIHRoaXMudHlwZSA9IHN5bnRheF8xLlN5bnRheC5BcnJvd0Z1bmN0aW9uRXhwcmVzc2lvbjtcclxuXHQgICAgICAgIHRoaXMuaWQgPSBudWxsO1xyXG5cdCAgICAgICAgdGhpcy5wYXJhbXMgPSBwYXJhbXM7XHJcblx0ICAgICAgICB0aGlzLmJvZHkgPSBib2R5O1xyXG5cdCAgICAgICAgdGhpcy5nZW5lcmF0b3IgPSBmYWxzZTtcclxuXHQgICAgICAgIHRoaXMuZXhwcmVzc2lvbiA9IGV4cHJlc3Npb247XHJcblx0ICAgICAgICB0aGlzLmFzeW5jID0gZmFsc2U7XHJcblx0ICAgIH1cclxuXHQgICAgcmV0dXJuIEFycm93RnVuY3Rpb25FeHByZXNzaW9uO1xyXG5cdH0oKSk7XHJcblx0ZXhwb3J0cy5BcnJvd0Z1bmN0aW9uRXhwcmVzc2lvbiA9IEFycm93RnVuY3Rpb25FeHByZXNzaW9uO1xyXG5cdHZhciBBc3NpZ25tZW50RXhwcmVzc2lvbiA9IChmdW5jdGlvbiAoKSB7XHJcblx0ICAgIGZ1bmN0aW9uIEFzc2lnbm1lbnRFeHByZXNzaW9uKG9wZXJhdG9yLCBsZWZ0LCByaWdodCkge1xyXG5cdCAgICAgICAgdGhpcy50eXBlID0gc3ludGF4XzEuU3ludGF4LkFzc2lnbm1lbnRFeHByZXNzaW9uO1xyXG5cdCAgICAgICAgdGhpcy5vcGVyYXRvciA9IG9wZXJhdG9yO1xyXG5cdCAgICAgICAgdGhpcy5sZWZ0ID0gbGVmdDtcclxuXHQgICAgICAgIHRoaXMucmlnaHQgPSByaWdodDtcclxuXHQgICAgfVxyXG5cdCAgICByZXR1cm4gQXNzaWdubWVudEV4cHJlc3Npb247XHJcblx0fSgpKTtcclxuXHRleHBvcnRzLkFzc2lnbm1lbnRFeHByZXNzaW9uID0gQXNzaWdubWVudEV4cHJlc3Npb247XHJcblx0dmFyIEFzc2lnbm1lbnRQYXR0ZXJuID0gKGZ1bmN0aW9uICgpIHtcclxuXHQgICAgZnVuY3Rpb24gQXNzaWdubWVudFBhdHRlcm4obGVmdCwgcmlnaHQpIHtcclxuXHQgICAgICAgIHRoaXMudHlwZSA9IHN5bnRheF8xLlN5bnRheC5Bc3NpZ25tZW50UGF0dGVybjtcclxuXHQgICAgICAgIHRoaXMubGVmdCA9IGxlZnQ7XHJcblx0ICAgICAgICB0aGlzLnJpZ2h0ID0gcmlnaHQ7XHJcblx0ICAgIH1cclxuXHQgICAgcmV0dXJuIEFzc2lnbm1lbnRQYXR0ZXJuO1xyXG5cdH0oKSk7XHJcblx0ZXhwb3J0cy5Bc3NpZ25tZW50UGF0dGVybiA9IEFzc2lnbm1lbnRQYXR0ZXJuO1xyXG5cdHZhciBBc3luY0Fycm93RnVuY3Rpb25FeHByZXNzaW9uID0gKGZ1bmN0aW9uICgpIHtcclxuXHQgICAgZnVuY3Rpb24gQXN5bmNBcnJvd0Z1bmN0aW9uRXhwcmVzc2lvbihwYXJhbXMsIGJvZHksIGV4cHJlc3Npb24pIHtcclxuXHQgICAgICAgIHRoaXMudHlwZSA9IHN5bnRheF8xLlN5bnRheC5BcnJvd0Z1bmN0aW9uRXhwcmVzc2lvbjtcclxuXHQgICAgICAgIHRoaXMuaWQgPSBudWxsO1xyXG5cdCAgICAgICAgdGhpcy5wYXJhbXMgPSBwYXJhbXM7XHJcblx0ICAgICAgICB0aGlzLmJvZHkgPSBib2R5O1xyXG5cdCAgICAgICAgdGhpcy5nZW5lcmF0b3IgPSBmYWxzZTtcclxuXHQgICAgICAgIHRoaXMuZXhwcmVzc2lvbiA9IGV4cHJlc3Npb247XHJcblx0ICAgICAgICB0aGlzLmFzeW5jID0gdHJ1ZTtcclxuXHQgICAgfVxyXG5cdCAgICByZXR1cm4gQXN5bmNBcnJvd0Z1bmN0aW9uRXhwcmVzc2lvbjtcclxuXHR9KCkpO1xyXG5cdGV4cG9ydHMuQXN5bmNBcnJvd0Z1bmN0aW9uRXhwcmVzc2lvbiA9IEFzeW5jQXJyb3dGdW5jdGlvbkV4cHJlc3Npb247XHJcblx0dmFyIEFzeW5jRnVuY3Rpb25EZWNsYXJhdGlvbiA9IChmdW5jdGlvbiAoKSB7XHJcblx0ICAgIGZ1bmN0aW9uIEFzeW5jRnVuY3Rpb25EZWNsYXJhdGlvbihpZCwgcGFyYW1zLCBib2R5KSB7XHJcblx0ICAgICAgICB0aGlzLnR5cGUgPSBzeW50YXhfMS5TeW50YXguRnVuY3Rpb25EZWNsYXJhdGlvbjtcclxuXHQgICAgICAgIHRoaXMuaWQgPSBpZDtcclxuXHQgICAgICAgIHRoaXMucGFyYW1zID0gcGFyYW1zO1xyXG5cdCAgICAgICAgdGhpcy5ib2R5ID0gYm9keTtcclxuXHQgICAgICAgIHRoaXMuZ2VuZXJhdG9yID0gZmFsc2U7XHJcblx0ICAgICAgICB0aGlzLmV4cHJlc3Npb24gPSBmYWxzZTtcclxuXHQgICAgICAgIHRoaXMuYXN5bmMgPSB0cnVlO1xyXG5cdCAgICB9XHJcblx0ICAgIHJldHVybiBBc3luY0Z1bmN0aW9uRGVjbGFyYXRpb247XHJcblx0fSgpKTtcclxuXHRleHBvcnRzLkFzeW5jRnVuY3Rpb25EZWNsYXJhdGlvbiA9IEFzeW5jRnVuY3Rpb25EZWNsYXJhdGlvbjtcclxuXHR2YXIgQXN5bmNGdW5jdGlvbkV4cHJlc3Npb24gPSAoZnVuY3Rpb24gKCkge1xyXG5cdCAgICBmdW5jdGlvbiBBc3luY0Z1bmN0aW9uRXhwcmVzc2lvbihpZCwgcGFyYW1zLCBib2R5KSB7XHJcblx0ICAgICAgICB0aGlzLnR5cGUgPSBzeW50YXhfMS5TeW50YXguRnVuY3Rpb25FeHByZXNzaW9uO1xyXG5cdCAgICAgICAgdGhpcy5pZCA9IGlkO1xyXG5cdCAgICAgICAgdGhpcy5wYXJhbXMgPSBwYXJhbXM7XHJcblx0ICAgICAgICB0aGlzLmJvZHkgPSBib2R5O1xyXG5cdCAgICAgICAgdGhpcy5nZW5lcmF0b3IgPSBmYWxzZTtcclxuXHQgICAgICAgIHRoaXMuZXhwcmVzc2lvbiA9IGZhbHNlO1xyXG5cdCAgICAgICAgdGhpcy5hc3luYyA9IHRydWU7XHJcblx0ICAgIH1cclxuXHQgICAgcmV0dXJuIEFzeW5jRnVuY3Rpb25FeHByZXNzaW9uO1xyXG5cdH0oKSk7XHJcblx0ZXhwb3J0cy5Bc3luY0Z1bmN0aW9uRXhwcmVzc2lvbiA9IEFzeW5jRnVuY3Rpb25FeHByZXNzaW9uO1xyXG5cdHZhciBBd2FpdEV4cHJlc3Npb24gPSAoZnVuY3Rpb24gKCkge1xyXG5cdCAgICBmdW5jdGlvbiBBd2FpdEV4cHJlc3Npb24oYXJndW1lbnQpIHtcclxuXHQgICAgICAgIHRoaXMudHlwZSA9IHN5bnRheF8xLlN5bnRheC5Bd2FpdEV4cHJlc3Npb247XHJcblx0ICAgICAgICB0aGlzLmFyZ3VtZW50ID0gYXJndW1lbnQ7XHJcblx0ICAgIH1cclxuXHQgICAgcmV0dXJuIEF3YWl0RXhwcmVzc2lvbjtcclxuXHR9KCkpO1xyXG5cdGV4cG9ydHMuQXdhaXRFeHByZXNzaW9uID0gQXdhaXRFeHByZXNzaW9uO1xyXG5cdHZhciBCaW5hcnlFeHByZXNzaW9uID0gKGZ1bmN0aW9uICgpIHtcclxuXHQgICAgZnVuY3Rpb24gQmluYXJ5RXhwcmVzc2lvbihvcGVyYXRvciwgbGVmdCwgcmlnaHQpIHtcclxuXHQgICAgICAgIHZhciBsb2dpY2FsID0gKG9wZXJhdG9yID09PSAnfHwnIHx8IG9wZXJhdG9yID09PSAnJiYnKTtcclxuXHQgICAgICAgIHRoaXMudHlwZSA9IGxvZ2ljYWwgPyBzeW50YXhfMS5TeW50YXguTG9naWNhbEV4cHJlc3Npb24gOiBzeW50YXhfMS5TeW50YXguQmluYXJ5RXhwcmVzc2lvbjtcclxuXHQgICAgICAgIHRoaXMub3BlcmF0b3IgPSBvcGVyYXRvcjtcclxuXHQgICAgICAgIHRoaXMubGVmdCA9IGxlZnQ7XHJcblx0ICAgICAgICB0aGlzLnJpZ2h0ID0gcmlnaHQ7XHJcblx0ICAgIH1cclxuXHQgICAgcmV0dXJuIEJpbmFyeUV4cHJlc3Npb247XHJcblx0fSgpKTtcclxuXHRleHBvcnRzLkJpbmFyeUV4cHJlc3Npb24gPSBCaW5hcnlFeHByZXNzaW9uO1xyXG5cdHZhciBCbG9ja1N0YXRlbWVudCA9IChmdW5jdGlvbiAoKSB7XHJcblx0ICAgIGZ1bmN0aW9uIEJsb2NrU3RhdGVtZW50KGJvZHkpIHtcclxuXHQgICAgICAgIHRoaXMudHlwZSA9IHN5bnRheF8xLlN5bnRheC5CbG9ja1N0YXRlbWVudDtcclxuXHQgICAgICAgIHRoaXMuYm9keSA9IGJvZHk7XHJcblx0ICAgIH1cclxuXHQgICAgcmV0dXJuIEJsb2NrU3RhdGVtZW50O1xyXG5cdH0oKSk7XHJcblx0ZXhwb3J0cy5CbG9ja1N0YXRlbWVudCA9IEJsb2NrU3RhdGVtZW50O1xyXG5cdHZhciBCcmVha1N0YXRlbWVudCA9IChmdW5jdGlvbiAoKSB7XHJcblx0ICAgIGZ1bmN0aW9uIEJyZWFrU3RhdGVtZW50KGxhYmVsKSB7XHJcblx0ICAgICAgICB0aGlzLnR5cGUgPSBzeW50YXhfMS5TeW50YXguQnJlYWtTdGF0ZW1lbnQ7XHJcblx0ICAgICAgICB0aGlzLmxhYmVsID0gbGFiZWw7XHJcblx0ICAgIH1cclxuXHQgICAgcmV0dXJuIEJyZWFrU3RhdGVtZW50O1xyXG5cdH0oKSk7XHJcblx0ZXhwb3J0cy5CcmVha1N0YXRlbWVudCA9IEJyZWFrU3RhdGVtZW50O1xyXG5cdHZhciBDYWxsRXhwcmVzc2lvbiA9IChmdW5jdGlvbiAoKSB7XHJcblx0ICAgIGZ1bmN0aW9uIENhbGxFeHByZXNzaW9uKGNhbGxlZSwgYXJncykge1xyXG5cdCAgICAgICAgdGhpcy50eXBlID0gc3ludGF4XzEuU3ludGF4LkNhbGxFeHByZXNzaW9uO1xyXG5cdCAgICAgICAgdGhpcy5jYWxsZWUgPSBjYWxsZWU7XHJcblx0ICAgICAgICB0aGlzLmFyZ3VtZW50cyA9IGFyZ3M7XHJcblx0ICAgIH1cclxuXHQgICAgcmV0dXJuIENhbGxFeHByZXNzaW9uO1xyXG5cdH0oKSk7XHJcblx0ZXhwb3J0cy5DYWxsRXhwcmVzc2lvbiA9IENhbGxFeHByZXNzaW9uO1xyXG5cdHZhciBDYXRjaENsYXVzZSA9IChmdW5jdGlvbiAoKSB7XHJcblx0ICAgIGZ1bmN0aW9uIENhdGNoQ2xhdXNlKHBhcmFtLCBib2R5KSB7XHJcblx0ICAgICAgICB0aGlzLnR5cGUgPSBzeW50YXhfMS5TeW50YXguQ2F0Y2hDbGF1c2U7XHJcblx0ICAgICAgICB0aGlzLnBhcmFtID0gcGFyYW07XHJcblx0ICAgICAgICB0aGlzLmJvZHkgPSBib2R5O1xyXG5cdCAgICB9XHJcblx0ICAgIHJldHVybiBDYXRjaENsYXVzZTtcclxuXHR9KCkpO1xyXG5cdGV4cG9ydHMuQ2F0Y2hDbGF1c2UgPSBDYXRjaENsYXVzZTtcclxuXHR2YXIgQ2xhc3NCb2R5ID0gKGZ1bmN0aW9uICgpIHtcclxuXHQgICAgZnVuY3Rpb24gQ2xhc3NCb2R5KGJvZHkpIHtcclxuXHQgICAgICAgIHRoaXMudHlwZSA9IHN5bnRheF8xLlN5bnRheC5DbGFzc0JvZHk7XHJcblx0ICAgICAgICB0aGlzLmJvZHkgPSBib2R5O1xyXG5cdCAgICB9XHJcblx0ICAgIHJldHVybiBDbGFzc0JvZHk7XHJcblx0fSgpKTtcclxuXHRleHBvcnRzLkNsYXNzQm9keSA9IENsYXNzQm9keTtcclxuXHR2YXIgQ2xhc3NEZWNsYXJhdGlvbiA9IChmdW5jdGlvbiAoKSB7XHJcblx0ICAgIGZ1bmN0aW9uIENsYXNzRGVjbGFyYXRpb24oaWQsIHN1cGVyQ2xhc3MsIGJvZHkpIHtcclxuXHQgICAgICAgIHRoaXMudHlwZSA9IHN5bnRheF8xLlN5bnRheC5DbGFzc0RlY2xhcmF0aW9uO1xyXG5cdCAgICAgICAgdGhpcy5pZCA9IGlkO1xyXG5cdCAgICAgICAgdGhpcy5zdXBlckNsYXNzID0gc3VwZXJDbGFzcztcclxuXHQgICAgICAgIHRoaXMuYm9keSA9IGJvZHk7XHJcblx0ICAgIH1cclxuXHQgICAgcmV0dXJuIENsYXNzRGVjbGFyYXRpb247XHJcblx0fSgpKTtcclxuXHRleHBvcnRzLkNsYXNzRGVjbGFyYXRpb24gPSBDbGFzc0RlY2xhcmF0aW9uO1xyXG5cdHZhciBDbGFzc0V4cHJlc3Npb24gPSAoZnVuY3Rpb24gKCkge1xyXG5cdCAgICBmdW5jdGlvbiBDbGFzc0V4cHJlc3Npb24oaWQsIHN1cGVyQ2xhc3MsIGJvZHkpIHtcclxuXHQgICAgICAgIHRoaXMudHlwZSA9IHN5bnRheF8xLlN5bnRheC5DbGFzc0V4cHJlc3Npb247XHJcblx0ICAgICAgICB0aGlzLmlkID0gaWQ7XHJcblx0ICAgICAgICB0aGlzLnN1cGVyQ2xhc3MgPSBzdXBlckNsYXNzO1xyXG5cdCAgICAgICAgdGhpcy5ib2R5ID0gYm9keTtcclxuXHQgICAgfVxyXG5cdCAgICByZXR1cm4gQ2xhc3NFeHByZXNzaW9uO1xyXG5cdH0oKSk7XHJcblx0ZXhwb3J0cy5DbGFzc0V4cHJlc3Npb24gPSBDbGFzc0V4cHJlc3Npb247XHJcblx0dmFyIENvbXB1dGVkTWVtYmVyRXhwcmVzc2lvbiA9IChmdW5jdGlvbiAoKSB7XHJcblx0ICAgIGZ1bmN0aW9uIENvbXB1dGVkTWVtYmVyRXhwcmVzc2lvbihvYmplY3QsIHByb3BlcnR5KSB7XHJcblx0ICAgICAgICB0aGlzLnR5cGUgPSBzeW50YXhfMS5TeW50YXguTWVtYmVyRXhwcmVzc2lvbjtcclxuXHQgICAgICAgIHRoaXMuY29tcHV0ZWQgPSB0cnVlO1xyXG5cdCAgICAgICAgdGhpcy5vYmplY3QgPSBvYmplY3Q7XHJcblx0ICAgICAgICB0aGlzLnByb3BlcnR5ID0gcHJvcGVydHk7XHJcblx0ICAgIH1cclxuXHQgICAgcmV0dXJuIENvbXB1dGVkTWVtYmVyRXhwcmVzc2lvbjtcclxuXHR9KCkpO1xyXG5cdGV4cG9ydHMuQ29tcHV0ZWRNZW1iZXJFeHByZXNzaW9uID0gQ29tcHV0ZWRNZW1iZXJFeHByZXNzaW9uO1xyXG5cdHZhciBDb25kaXRpb25hbEV4cHJlc3Npb24gPSAoZnVuY3Rpb24gKCkge1xyXG5cdCAgICBmdW5jdGlvbiBDb25kaXRpb25hbEV4cHJlc3Npb24odGVzdCwgY29uc2VxdWVudCwgYWx0ZXJuYXRlKSB7XHJcblx0ICAgICAgICB0aGlzLnR5cGUgPSBzeW50YXhfMS5TeW50YXguQ29uZGl0aW9uYWxFeHByZXNzaW9uO1xyXG5cdCAgICAgICAgdGhpcy50ZXN0ID0gdGVzdDtcclxuXHQgICAgICAgIHRoaXMuY29uc2VxdWVudCA9IGNvbnNlcXVlbnQ7XHJcblx0ICAgICAgICB0aGlzLmFsdGVybmF0ZSA9IGFsdGVybmF0ZTtcclxuXHQgICAgfVxyXG5cdCAgICByZXR1cm4gQ29uZGl0aW9uYWxFeHByZXNzaW9uO1xyXG5cdH0oKSk7XHJcblx0ZXhwb3J0cy5Db25kaXRpb25hbEV4cHJlc3Npb24gPSBDb25kaXRpb25hbEV4cHJlc3Npb247XHJcblx0dmFyIENvbnRpbnVlU3RhdGVtZW50ID0gKGZ1bmN0aW9uICgpIHtcclxuXHQgICAgZnVuY3Rpb24gQ29udGludWVTdGF0ZW1lbnQobGFiZWwpIHtcclxuXHQgICAgICAgIHRoaXMudHlwZSA9IHN5bnRheF8xLlN5bnRheC5Db250aW51ZVN0YXRlbWVudDtcclxuXHQgICAgICAgIHRoaXMubGFiZWwgPSBsYWJlbDtcclxuXHQgICAgfVxyXG5cdCAgICByZXR1cm4gQ29udGludWVTdGF0ZW1lbnQ7XHJcblx0fSgpKTtcclxuXHRleHBvcnRzLkNvbnRpbnVlU3RhdGVtZW50ID0gQ29udGludWVTdGF0ZW1lbnQ7XHJcblx0dmFyIERlYnVnZ2VyU3RhdGVtZW50ID0gKGZ1bmN0aW9uICgpIHtcclxuXHQgICAgZnVuY3Rpb24gRGVidWdnZXJTdGF0ZW1lbnQoKSB7XHJcblx0ICAgICAgICB0aGlzLnR5cGUgPSBzeW50YXhfMS5TeW50YXguRGVidWdnZXJTdGF0ZW1lbnQ7XHJcblx0ICAgIH1cclxuXHQgICAgcmV0dXJuIERlYnVnZ2VyU3RhdGVtZW50O1xyXG5cdH0oKSk7XHJcblx0ZXhwb3J0cy5EZWJ1Z2dlclN0YXRlbWVudCA9IERlYnVnZ2VyU3RhdGVtZW50O1xyXG5cdHZhciBEaXJlY3RpdmUgPSAoZnVuY3Rpb24gKCkge1xyXG5cdCAgICBmdW5jdGlvbiBEaXJlY3RpdmUoZXhwcmVzc2lvbiwgZGlyZWN0aXZlKSB7XHJcblx0ICAgICAgICB0aGlzLnR5cGUgPSBzeW50YXhfMS5TeW50YXguRXhwcmVzc2lvblN0YXRlbWVudDtcclxuXHQgICAgICAgIHRoaXMuZXhwcmVzc2lvbiA9IGV4cHJlc3Npb247XHJcblx0ICAgICAgICB0aGlzLmRpcmVjdGl2ZSA9IGRpcmVjdGl2ZTtcclxuXHQgICAgfVxyXG5cdCAgICByZXR1cm4gRGlyZWN0aXZlO1xyXG5cdH0oKSk7XHJcblx0ZXhwb3J0cy5EaXJlY3RpdmUgPSBEaXJlY3RpdmU7XHJcblx0dmFyIERvV2hpbGVTdGF0ZW1lbnQgPSAoZnVuY3Rpb24gKCkge1xyXG5cdCAgICBmdW5jdGlvbiBEb1doaWxlU3RhdGVtZW50KGJvZHksIHRlc3QpIHtcclxuXHQgICAgICAgIHRoaXMudHlwZSA9IHN5bnRheF8xLlN5bnRheC5Eb1doaWxlU3RhdGVtZW50O1xyXG5cdCAgICAgICAgdGhpcy5ib2R5ID0gYm9keTtcclxuXHQgICAgICAgIHRoaXMudGVzdCA9IHRlc3Q7XHJcblx0ICAgIH1cclxuXHQgICAgcmV0dXJuIERvV2hpbGVTdGF0ZW1lbnQ7XHJcblx0fSgpKTtcclxuXHRleHBvcnRzLkRvV2hpbGVTdGF0ZW1lbnQgPSBEb1doaWxlU3RhdGVtZW50O1xyXG5cdHZhciBFbXB0eVN0YXRlbWVudCA9IChmdW5jdGlvbiAoKSB7XHJcblx0ICAgIGZ1bmN0aW9uIEVtcHR5U3RhdGVtZW50KCkge1xyXG5cdCAgICAgICAgdGhpcy50eXBlID0gc3ludGF4XzEuU3ludGF4LkVtcHR5U3RhdGVtZW50O1xyXG5cdCAgICB9XHJcblx0ICAgIHJldHVybiBFbXB0eVN0YXRlbWVudDtcclxuXHR9KCkpO1xyXG5cdGV4cG9ydHMuRW1wdHlTdGF0ZW1lbnQgPSBFbXB0eVN0YXRlbWVudDtcclxuXHR2YXIgRXhwb3J0QWxsRGVjbGFyYXRpb24gPSAoZnVuY3Rpb24gKCkge1xyXG5cdCAgICBmdW5jdGlvbiBFeHBvcnRBbGxEZWNsYXJhdGlvbihzb3VyY2UpIHtcclxuXHQgICAgICAgIHRoaXMudHlwZSA9IHN5bnRheF8xLlN5bnRheC5FeHBvcnRBbGxEZWNsYXJhdGlvbjtcclxuXHQgICAgICAgIHRoaXMuc291cmNlID0gc291cmNlO1xyXG5cdCAgICB9XHJcblx0ICAgIHJldHVybiBFeHBvcnRBbGxEZWNsYXJhdGlvbjtcclxuXHR9KCkpO1xyXG5cdGV4cG9ydHMuRXhwb3J0QWxsRGVjbGFyYXRpb24gPSBFeHBvcnRBbGxEZWNsYXJhdGlvbjtcclxuXHR2YXIgRXhwb3J0RGVmYXVsdERlY2xhcmF0aW9uID0gKGZ1bmN0aW9uICgpIHtcclxuXHQgICAgZnVuY3Rpb24gRXhwb3J0RGVmYXVsdERlY2xhcmF0aW9uKGRlY2xhcmF0aW9uKSB7XHJcblx0ICAgICAgICB0aGlzLnR5cGUgPSBzeW50YXhfMS5TeW50YXguRXhwb3J0RGVmYXVsdERlY2xhcmF0aW9uO1xyXG5cdCAgICAgICAgdGhpcy5kZWNsYXJhdGlvbiA9IGRlY2xhcmF0aW9uO1xyXG5cdCAgICB9XHJcblx0ICAgIHJldHVybiBFeHBvcnREZWZhdWx0RGVjbGFyYXRpb247XHJcblx0fSgpKTtcclxuXHRleHBvcnRzLkV4cG9ydERlZmF1bHREZWNsYXJhdGlvbiA9IEV4cG9ydERlZmF1bHREZWNsYXJhdGlvbjtcclxuXHR2YXIgRXhwb3J0TmFtZWREZWNsYXJhdGlvbiA9IChmdW5jdGlvbiAoKSB7XHJcblx0ICAgIGZ1bmN0aW9uIEV4cG9ydE5hbWVkRGVjbGFyYXRpb24oZGVjbGFyYXRpb24sIHNwZWNpZmllcnMsIHNvdXJjZSkge1xyXG5cdCAgICAgICAgdGhpcy50eXBlID0gc3ludGF4XzEuU3ludGF4LkV4cG9ydE5hbWVkRGVjbGFyYXRpb247XHJcblx0ICAgICAgICB0aGlzLmRlY2xhcmF0aW9uID0gZGVjbGFyYXRpb247XHJcblx0ICAgICAgICB0aGlzLnNwZWNpZmllcnMgPSBzcGVjaWZpZXJzO1xyXG5cdCAgICAgICAgdGhpcy5zb3VyY2UgPSBzb3VyY2U7XHJcblx0ICAgIH1cclxuXHQgICAgcmV0dXJuIEV4cG9ydE5hbWVkRGVjbGFyYXRpb247XHJcblx0fSgpKTtcclxuXHRleHBvcnRzLkV4cG9ydE5hbWVkRGVjbGFyYXRpb24gPSBFeHBvcnROYW1lZERlY2xhcmF0aW9uO1xyXG5cdHZhciBFeHBvcnRTcGVjaWZpZXIgPSAoZnVuY3Rpb24gKCkge1xyXG5cdCAgICBmdW5jdGlvbiBFeHBvcnRTcGVjaWZpZXIobG9jYWwsIGV4cG9ydGVkKSB7XHJcblx0ICAgICAgICB0aGlzLnR5cGUgPSBzeW50YXhfMS5TeW50YXguRXhwb3J0U3BlY2lmaWVyO1xyXG5cdCAgICAgICAgdGhpcy5leHBvcnRlZCA9IGV4cG9ydGVkO1xyXG5cdCAgICAgICAgdGhpcy5sb2NhbCA9IGxvY2FsO1xyXG5cdCAgICB9XHJcblx0ICAgIHJldHVybiBFeHBvcnRTcGVjaWZpZXI7XHJcblx0fSgpKTtcclxuXHRleHBvcnRzLkV4cG9ydFNwZWNpZmllciA9IEV4cG9ydFNwZWNpZmllcjtcclxuXHR2YXIgRXhwcmVzc2lvblN0YXRlbWVudCA9IChmdW5jdGlvbiAoKSB7XHJcblx0ICAgIGZ1bmN0aW9uIEV4cHJlc3Npb25TdGF0ZW1lbnQoZXhwcmVzc2lvbikge1xyXG5cdCAgICAgICAgdGhpcy50eXBlID0gc3ludGF4XzEuU3ludGF4LkV4cHJlc3Npb25TdGF0ZW1lbnQ7XHJcblx0ICAgICAgICB0aGlzLmV4cHJlc3Npb24gPSBleHByZXNzaW9uO1xyXG5cdCAgICB9XHJcblx0ICAgIHJldHVybiBFeHByZXNzaW9uU3RhdGVtZW50O1xyXG5cdH0oKSk7XHJcblx0ZXhwb3J0cy5FeHByZXNzaW9uU3RhdGVtZW50ID0gRXhwcmVzc2lvblN0YXRlbWVudDtcclxuXHR2YXIgRm9ySW5TdGF0ZW1lbnQgPSAoZnVuY3Rpb24gKCkge1xyXG5cdCAgICBmdW5jdGlvbiBGb3JJblN0YXRlbWVudChsZWZ0LCByaWdodCwgYm9keSkge1xyXG5cdCAgICAgICAgdGhpcy50eXBlID0gc3ludGF4XzEuU3ludGF4LkZvckluU3RhdGVtZW50O1xyXG5cdCAgICAgICAgdGhpcy5sZWZ0ID0gbGVmdDtcclxuXHQgICAgICAgIHRoaXMucmlnaHQgPSByaWdodDtcclxuXHQgICAgICAgIHRoaXMuYm9keSA9IGJvZHk7XHJcblx0ICAgICAgICB0aGlzLmVhY2ggPSBmYWxzZTtcclxuXHQgICAgfVxyXG5cdCAgICByZXR1cm4gRm9ySW5TdGF0ZW1lbnQ7XHJcblx0fSgpKTtcclxuXHRleHBvcnRzLkZvckluU3RhdGVtZW50ID0gRm9ySW5TdGF0ZW1lbnQ7XHJcblx0dmFyIEZvck9mU3RhdGVtZW50ID0gKGZ1bmN0aW9uICgpIHtcclxuXHQgICAgZnVuY3Rpb24gRm9yT2ZTdGF0ZW1lbnQobGVmdCwgcmlnaHQsIGJvZHkpIHtcclxuXHQgICAgICAgIHRoaXMudHlwZSA9IHN5bnRheF8xLlN5bnRheC5Gb3JPZlN0YXRlbWVudDtcclxuXHQgICAgICAgIHRoaXMubGVmdCA9IGxlZnQ7XHJcblx0ICAgICAgICB0aGlzLnJpZ2h0ID0gcmlnaHQ7XHJcblx0ICAgICAgICB0aGlzLmJvZHkgPSBib2R5O1xyXG5cdCAgICB9XHJcblx0ICAgIHJldHVybiBGb3JPZlN0YXRlbWVudDtcclxuXHR9KCkpO1xyXG5cdGV4cG9ydHMuRm9yT2ZTdGF0ZW1lbnQgPSBGb3JPZlN0YXRlbWVudDtcclxuXHR2YXIgRm9yU3RhdGVtZW50ID0gKGZ1bmN0aW9uICgpIHtcclxuXHQgICAgZnVuY3Rpb24gRm9yU3RhdGVtZW50KGluaXQsIHRlc3QsIHVwZGF0ZSwgYm9keSkge1xyXG5cdCAgICAgICAgdGhpcy50eXBlID0gc3ludGF4XzEuU3ludGF4LkZvclN0YXRlbWVudDtcclxuXHQgICAgICAgIHRoaXMuaW5pdCA9IGluaXQ7XHJcblx0ICAgICAgICB0aGlzLnRlc3QgPSB0ZXN0O1xyXG5cdCAgICAgICAgdGhpcy51cGRhdGUgPSB1cGRhdGU7XHJcblx0ICAgICAgICB0aGlzLmJvZHkgPSBib2R5O1xyXG5cdCAgICB9XHJcblx0ICAgIHJldHVybiBGb3JTdGF0ZW1lbnQ7XHJcblx0fSgpKTtcclxuXHRleHBvcnRzLkZvclN0YXRlbWVudCA9IEZvclN0YXRlbWVudDtcclxuXHR2YXIgRnVuY3Rpb25EZWNsYXJhdGlvbiA9IChmdW5jdGlvbiAoKSB7XHJcblx0ICAgIGZ1bmN0aW9uIEZ1bmN0aW9uRGVjbGFyYXRpb24oaWQsIHBhcmFtcywgYm9keSwgZ2VuZXJhdG9yKSB7XHJcblx0ICAgICAgICB0aGlzLnR5cGUgPSBzeW50YXhfMS5TeW50YXguRnVuY3Rpb25EZWNsYXJhdGlvbjtcclxuXHQgICAgICAgIHRoaXMuaWQgPSBpZDtcclxuXHQgICAgICAgIHRoaXMucGFyYW1zID0gcGFyYW1zO1xyXG5cdCAgICAgICAgdGhpcy5ib2R5ID0gYm9keTtcclxuXHQgICAgICAgIHRoaXMuZ2VuZXJhdG9yID0gZ2VuZXJhdG9yO1xyXG5cdCAgICAgICAgdGhpcy5leHByZXNzaW9uID0gZmFsc2U7XHJcblx0ICAgICAgICB0aGlzLmFzeW5jID0gZmFsc2U7XHJcblx0ICAgIH1cclxuXHQgICAgcmV0dXJuIEZ1bmN0aW9uRGVjbGFyYXRpb247XHJcblx0fSgpKTtcclxuXHRleHBvcnRzLkZ1bmN0aW9uRGVjbGFyYXRpb24gPSBGdW5jdGlvbkRlY2xhcmF0aW9uO1xyXG5cdHZhciBGdW5jdGlvbkV4cHJlc3Npb24gPSAoZnVuY3Rpb24gKCkge1xyXG5cdCAgICBmdW5jdGlvbiBGdW5jdGlvbkV4cHJlc3Npb24oaWQsIHBhcmFtcywgYm9keSwgZ2VuZXJhdG9yKSB7XHJcblx0ICAgICAgICB0aGlzLnR5cGUgPSBzeW50YXhfMS5TeW50YXguRnVuY3Rpb25FeHByZXNzaW9uO1xyXG5cdCAgICAgICAgdGhpcy5pZCA9IGlkO1xyXG5cdCAgICAgICAgdGhpcy5wYXJhbXMgPSBwYXJhbXM7XHJcblx0ICAgICAgICB0aGlzLmJvZHkgPSBib2R5O1xyXG5cdCAgICAgICAgdGhpcy5nZW5lcmF0b3IgPSBnZW5lcmF0b3I7XHJcblx0ICAgICAgICB0aGlzLmV4cHJlc3Npb24gPSBmYWxzZTtcclxuXHQgICAgICAgIHRoaXMuYXN5bmMgPSBmYWxzZTtcclxuXHQgICAgfVxyXG5cdCAgICByZXR1cm4gRnVuY3Rpb25FeHByZXNzaW9uO1xyXG5cdH0oKSk7XHJcblx0ZXhwb3J0cy5GdW5jdGlvbkV4cHJlc3Npb24gPSBGdW5jdGlvbkV4cHJlc3Npb247XHJcblx0dmFyIElkZW50aWZpZXIgPSAoZnVuY3Rpb24gKCkge1xyXG5cdCAgICBmdW5jdGlvbiBJZGVudGlmaWVyKG5hbWUpIHtcclxuXHQgICAgICAgIHRoaXMudHlwZSA9IHN5bnRheF8xLlN5bnRheC5JZGVudGlmaWVyO1xyXG5cdCAgICAgICAgdGhpcy5uYW1lID0gbmFtZTtcclxuXHQgICAgfVxyXG5cdCAgICByZXR1cm4gSWRlbnRpZmllcjtcclxuXHR9KCkpO1xyXG5cdGV4cG9ydHMuSWRlbnRpZmllciA9IElkZW50aWZpZXI7XHJcblx0dmFyIElmU3RhdGVtZW50ID0gKGZ1bmN0aW9uICgpIHtcclxuXHQgICAgZnVuY3Rpb24gSWZTdGF0ZW1lbnQodGVzdCwgY29uc2VxdWVudCwgYWx0ZXJuYXRlKSB7XHJcblx0ICAgICAgICB0aGlzLnR5cGUgPSBzeW50YXhfMS5TeW50YXguSWZTdGF0ZW1lbnQ7XHJcblx0ICAgICAgICB0aGlzLnRlc3QgPSB0ZXN0O1xyXG5cdCAgICAgICAgdGhpcy5jb25zZXF1ZW50ID0gY29uc2VxdWVudDtcclxuXHQgICAgICAgIHRoaXMuYWx0ZXJuYXRlID0gYWx0ZXJuYXRlO1xyXG5cdCAgICB9XHJcblx0ICAgIHJldHVybiBJZlN0YXRlbWVudDtcclxuXHR9KCkpO1xyXG5cdGV4cG9ydHMuSWZTdGF0ZW1lbnQgPSBJZlN0YXRlbWVudDtcclxuXHR2YXIgSW1wb3J0RGVjbGFyYXRpb24gPSAoZnVuY3Rpb24gKCkge1xyXG5cdCAgICBmdW5jdGlvbiBJbXBvcnREZWNsYXJhdGlvbihzcGVjaWZpZXJzLCBzb3VyY2UpIHtcclxuXHQgICAgICAgIHRoaXMudHlwZSA9IHN5bnRheF8xLlN5bnRheC5JbXBvcnREZWNsYXJhdGlvbjtcclxuXHQgICAgICAgIHRoaXMuc3BlY2lmaWVycyA9IHNwZWNpZmllcnM7XHJcblx0ICAgICAgICB0aGlzLnNvdXJjZSA9IHNvdXJjZTtcclxuXHQgICAgfVxyXG5cdCAgICByZXR1cm4gSW1wb3J0RGVjbGFyYXRpb247XHJcblx0fSgpKTtcclxuXHRleHBvcnRzLkltcG9ydERlY2xhcmF0aW9uID0gSW1wb3J0RGVjbGFyYXRpb247XHJcblx0dmFyIEltcG9ydERlZmF1bHRTcGVjaWZpZXIgPSAoZnVuY3Rpb24gKCkge1xyXG5cdCAgICBmdW5jdGlvbiBJbXBvcnREZWZhdWx0U3BlY2lmaWVyKGxvY2FsKSB7XHJcblx0ICAgICAgICB0aGlzLnR5cGUgPSBzeW50YXhfMS5TeW50YXguSW1wb3J0RGVmYXVsdFNwZWNpZmllcjtcclxuXHQgICAgICAgIHRoaXMubG9jYWwgPSBsb2NhbDtcclxuXHQgICAgfVxyXG5cdCAgICByZXR1cm4gSW1wb3J0RGVmYXVsdFNwZWNpZmllcjtcclxuXHR9KCkpO1xyXG5cdGV4cG9ydHMuSW1wb3J0RGVmYXVsdFNwZWNpZmllciA9IEltcG9ydERlZmF1bHRTcGVjaWZpZXI7XHJcblx0dmFyIEltcG9ydE5hbWVzcGFjZVNwZWNpZmllciA9IChmdW5jdGlvbiAoKSB7XHJcblx0ICAgIGZ1bmN0aW9uIEltcG9ydE5hbWVzcGFjZVNwZWNpZmllcihsb2NhbCkge1xyXG5cdCAgICAgICAgdGhpcy50eXBlID0gc3ludGF4XzEuU3ludGF4LkltcG9ydE5hbWVzcGFjZVNwZWNpZmllcjtcclxuXHQgICAgICAgIHRoaXMubG9jYWwgPSBsb2NhbDtcclxuXHQgICAgfVxyXG5cdCAgICByZXR1cm4gSW1wb3J0TmFtZXNwYWNlU3BlY2lmaWVyO1xyXG5cdH0oKSk7XHJcblx0ZXhwb3J0cy5JbXBvcnROYW1lc3BhY2VTcGVjaWZpZXIgPSBJbXBvcnROYW1lc3BhY2VTcGVjaWZpZXI7XHJcblx0dmFyIEltcG9ydFNwZWNpZmllciA9IChmdW5jdGlvbiAoKSB7XHJcblx0ICAgIGZ1bmN0aW9uIEltcG9ydFNwZWNpZmllcihsb2NhbCwgaW1wb3J0ZWQpIHtcclxuXHQgICAgICAgIHRoaXMudHlwZSA9IHN5bnRheF8xLlN5bnRheC5JbXBvcnRTcGVjaWZpZXI7XHJcblx0ICAgICAgICB0aGlzLmxvY2FsID0gbG9jYWw7XHJcblx0ICAgICAgICB0aGlzLmltcG9ydGVkID0gaW1wb3J0ZWQ7XHJcblx0ICAgIH1cclxuXHQgICAgcmV0dXJuIEltcG9ydFNwZWNpZmllcjtcclxuXHR9KCkpO1xyXG5cdGV4cG9ydHMuSW1wb3J0U3BlY2lmaWVyID0gSW1wb3J0U3BlY2lmaWVyO1xyXG5cdHZhciBMYWJlbGVkU3RhdGVtZW50ID0gKGZ1bmN0aW9uICgpIHtcclxuXHQgICAgZnVuY3Rpb24gTGFiZWxlZFN0YXRlbWVudChsYWJlbCwgYm9keSkge1xyXG5cdCAgICAgICAgdGhpcy50eXBlID0gc3ludGF4XzEuU3ludGF4LkxhYmVsZWRTdGF0ZW1lbnQ7XHJcblx0ICAgICAgICB0aGlzLmxhYmVsID0gbGFiZWw7XHJcblx0ICAgICAgICB0aGlzLmJvZHkgPSBib2R5O1xyXG5cdCAgICB9XHJcblx0ICAgIHJldHVybiBMYWJlbGVkU3RhdGVtZW50O1xyXG5cdH0oKSk7XHJcblx0ZXhwb3J0cy5MYWJlbGVkU3RhdGVtZW50ID0gTGFiZWxlZFN0YXRlbWVudDtcclxuXHR2YXIgTGl0ZXJhbCA9IChmdW5jdGlvbiAoKSB7XHJcblx0ICAgIGZ1bmN0aW9uIExpdGVyYWwodmFsdWUsIHJhdykge1xyXG5cdCAgICAgICAgdGhpcy50eXBlID0gc3ludGF4XzEuU3ludGF4LkxpdGVyYWw7XHJcblx0ICAgICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XHJcblx0ICAgICAgICB0aGlzLnJhdyA9IHJhdztcclxuXHQgICAgfVxyXG5cdCAgICByZXR1cm4gTGl0ZXJhbDtcclxuXHR9KCkpO1xyXG5cdGV4cG9ydHMuTGl0ZXJhbCA9IExpdGVyYWw7XHJcblx0dmFyIE1ldGFQcm9wZXJ0eSA9IChmdW5jdGlvbiAoKSB7XHJcblx0ICAgIGZ1bmN0aW9uIE1ldGFQcm9wZXJ0eShtZXRhLCBwcm9wZXJ0eSkge1xyXG5cdCAgICAgICAgdGhpcy50eXBlID0gc3ludGF4XzEuU3ludGF4Lk1ldGFQcm9wZXJ0eTtcclxuXHQgICAgICAgIHRoaXMubWV0YSA9IG1ldGE7XHJcblx0ICAgICAgICB0aGlzLnByb3BlcnR5ID0gcHJvcGVydHk7XHJcblx0ICAgIH1cclxuXHQgICAgcmV0dXJuIE1ldGFQcm9wZXJ0eTtcclxuXHR9KCkpO1xyXG5cdGV4cG9ydHMuTWV0YVByb3BlcnR5ID0gTWV0YVByb3BlcnR5O1xyXG5cdHZhciBNZXRob2REZWZpbml0aW9uID0gKGZ1bmN0aW9uICgpIHtcclxuXHQgICAgZnVuY3Rpb24gTWV0aG9kRGVmaW5pdGlvbihrZXksIGNvbXB1dGVkLCB2YWx1ZSwga2luZCwgaXNTdGF0aWMpIHtcclxuXHQgICAgICAgIHRoaXMudHlwZSA9IHN5bnRheF8xLlN5bnRheC5NZXRob2REZWZpbml0aW9uO1xyXG5cdCAgICAgICAgdGhpcy5rZXkgPSBrZXk7XHJcblx0ICAgICAgICB0aGlzLmNvbXB1dGVkID0gY29tcHV0ZWQ7XHJcblx0ICAgICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XHJcblx0ICAgICAgICB0aGlzLmtpbmQgPSBraW5kO1xyXG5cdCAgICAgICAgdGhpcy5zdGF0aWMgPSBpc1N0YXRpYztcclxuXHQgICAgfVxyXG5cdCAgICByZXR1cm4gTWV0aG9kRGVmaW5pdGlvbjtcclxuXHR9KCkpO1xyXG5cdGV4cG9ydHMuTWV0aG9kRGVmaW5pdGlvbiA9IE1ldGhvZERlZmluaXRpb247XHJcblx0dmFyIE1vZHVsZSA9IChmdW5jdGlvbiAoKSB7XHJcblx0ICAgIGZ1bmN0aW9uIE1vZHVsZShib2R5KSB7XHJcblx0ICAgICAgICB0aGlzLnR5cGUgPSBzeW50YXhfMS5TeW50YXguUHJvZ3JhbTtcclxuXHQgICAgICAgIHRoaXMuYm9keSA9IGJvZHk7XHJcblx0ICAgICAgICB0aGlzLnNvdXJjZVR5cGUgPSAnbW9kdWxlJztcclxuXHQgICAgfVxyXG5cdCAgICByZXR1cm4gTW9kdWxlO1xyXG5cdH0oKSk7XHJcblx0ZXhwb3J0cy5Nb2R1bGUgPSBNb2R1bGU7XHJcblx0dmFyIE5ld0V4cHJlc3Npb24gPSAoZnVuY3Rpb24gKCkge1xyXG5cdCAgICBmdW5jdGlvbiBOZXdFeHByZXNzaW9uKGNhbGxlZSwgYXJncykge1xyXG5cdCAgICAgICAgdGhpcy50eXBlID0gc3ludGF4XzEuU3ludGF4Lk5ld0V4cHJlc3Npb247XHJcblx0ICAgICAgICB0aGlzLmNhbGxlZSA9IGNhbGxlZTtcclxuXHQgICAgICAgIHRoaXMuYXJndW1lbnRzID0gYXJncztcclxuXHQgICAgfVxyXG5cdCAgICByZXR1cm4gTmV3RXhwcmVzc2lvbjtcclxuXHR9KCkpO1xyXG5cdGV4cG9ydHMuTmV3RXhwcmVzc2lvbiA9IE5ld0V4cHJlc3Npb247XHJcblx0dmFyIE9iamVjdEV4cHJlc3Npb24gPSAoZnVuY3Rpb24gKCkge1xyXG5cdCAgICBmdW5jdGlvbiBPYmplY3RFeHByZXNzaW9uKHByb3BlcnRpZXMpIHtcclxuXHQgICAgICAgIHRoaXMudHlwZSA9IHN5bnRheF8xLlN5bnRheC5PYmplY3RFeHByZXNzaW9uO1xyXG5cdCAgICAgICAgdGhpcy5wcm9wZXJ0aWVzID0gcHJvcGVydGllcztcclxuXHQgICAgfVxyXG5cdCAgICByZXR1cm4gT2JqZWN0RXhwcmVzc2lvbjtcclxuXHR9KCkpO1xyXG5cdGV4cG9ydHMuT2JqZWN0RXhwcmVzc2lvbiA9IE9iamVjdEV4cHJlc3Npb247XHJcblx0dmFyIE9iamVjdFBhdHRlcm4gPSAoZnVuY3Rpb24gKCkge1xyXG5cdCAgICBmdW5jdGlvbiBPYmplY3RQYXR0ZXJuKHByb3BlcnRpZXMpIHtcclxuXHQgICAgICAgIHRoaXMudHlwZSA9IHN5bnRheF8xLlN5bnRheC5PYmplY3RQYXR0ZXJuO1xyXG5cdCAgICAgICAgdGhpcy5wcm9wZXJ0aWVzID0gcHJvcGVydGllcztcclxuXHQgICAgfVxyXG5cdCAgICByZXR1cm4gT2JqZWN0UGF0dGVybjtcclxuXHR9KCkpO1xyXG5cdGV4cG9ydHMuT2JqZWN0UGF0dGVybiA9IE9iamVjdFBhdHRlcm47XHJcblx0dmFyIFByb3BlcnR5ID0gKGZ1bmN0aW9uICgpIHtcclxuXHQgICAgZnVuY3Rpb24gUHJvcGVydHkoa2luZCwga2V5LCBjb21wdXRlZCwgdmFsdWUsIG1ldGhvZCwgc2hvcnRoYW5kKSB7XHJcblx0ICAgICAgICB0aGlzLnR5cGUgPSBzeW50YXhfMS5TeW50YXguUHJvcGVydHk7XHJcblx0ICAgICAgICB0aGlzLmtleSA9IGtleTtcclxuXHQgICAgICAgIHRoaXMuY29tcHV0ZWQgPSBjb21wdXRlZDtcclxuXHQgICAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcclxuXHQgICAgICAgIHRoaXMua2luZCA9IGtpbmQ7XHJcblx0ICAgICAgICB0aGlzLm1ldGhvZCA9IG1ldGhvZDtcclxuXHQgICAgICAgIHRoaXMuc2hvcnRoYW5kID0gc2hvcnRoYW5kO1xyXG5cdCAgICB9XHJcblx0ICAgIHJldHVybiBQcm9wZXJ0eTtcclxuXHR9KCkpO1xyXG5cdGV4cG9ydHMuUHJvcGVydHkgPSBQcm9wZXJ0eTtcclxuXHR2YXIgUmVnZXhMaXRlcmFsID0gKGZ1bmN0aW9uICgpIHtcclxuXHQgICAgZnVuY3Rpb24gUmVnZXhMaXRlcmFsKHZhbHVlLCByYXcsIHBhdHRlcm4sIGZsYWdzKSB7XHJcblx0ICAgICAgICB0aGlzLnR5cGUgPSBzeW50YXhfMS5TeW50YXguTGl0ZXJhbDtcclxuXHQgICAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcclxuXHQgICAgICAgIHRoaXMucmF3ID0gcmF3O1xyXG5cdCAgICAgICAgdGhpcy5yZWdleCA9IHsgcGF0dGVybjogcGF0dGVybiwgZmxhZ3M6IGZsYWdzIH07XHJcblx0ICAgIH1cclxuXHQgICAgcmV0dXJuIFJlZ2V4TGl0ZXJhbDtcclxuXHR9KCkpO1xyXG5cdGV4cG9ydHMuUmVnZXhMaXRlcmFsID0gUmVnZXhMaXRlcmFsO1xyXG5cdHZhciBSZXN0RWxlbWVudCA9IChmdW5jdGlvbiAoKSB7XHJcblx0ICAgIGZ1bmN0aW9uIFJlc3RFbGVtZW50KGFyZ3VtZW50KSB7XHJcblx0ICAgICAgICB0aGlzLnR5cGUgPSBzeW50YXhfMS5TeW50YXguUmVzdEVsZW1lbnQ7XHJcblx0ICAgICAgICB0aGlzLmFyZ3VtZW50ID0gYXJndW1lbnQ7XHJcblx0ICAgIH1cclxuXHQgICAgcmV0dXJuIFJlc3RFbGVtZW50O1xyXG5cdH0oKSk7XHJcblx0ZXhwb3J0cy5SZXN0RWxlbWVudCA9IFJlc3RFbGVtZW50O1xyXG5cdHZhciBSZXR1cm5TdGF0ZW1lbnQgPSAoZnVuY3Rpb24gKCkge1xyXG5cdCAgICBmdW5jdGlvbiBSZXR1cm5TdGF0ZW1lbnQoYXJndW1lbnQpIHtcclxuXHQgICAgICAgIHRoaXMudHlwZSA9IHN5bnRheF8xLlN5bnRheC5SZXR1cm5TdGF0ZW1lbnQ7XHJcblx0ICAgICAgICB0aGlzLmFyZ3VtZW50ID0gYXJndW1lbnQ7XHJcblx0ICAgIH1cclxuXHQgICAgcmV0dXJuIFJldHVyblN0YXRlbWVudDtcclxuXHR9KCkpO1xyXG5cdGV4cG9ydHMuUmV0dXJuU3RhdGVtZW50ID0gUmV0dXJuU3RhdGVtZW50O1xyXG5cdHZhciBTY3JpcHQgPSAoZnVuY3Rpb24gKCkge1xyXG5cdCAgICBmdW5jdGlvbiBTY3JpcHQoYm9keSkge1xyXG5cdCAgICAgICAgdGhpcy50eXBlID0gc3ludGF4XzEuU3ludGF4LlByb2dyYW07XHJcblx0ICAgICAgICB0aGlzLmJvZHkgPSBib2R5O1xyXG5cdCAgICAgICAgdGhpcy5zb3VyY2VUeXBlID0gJ3NjcmlwdCc7XHJcblx0ICAgIH1cclxuXHQgICAgcmV0dXJuIFNjcmlwdDtcclxuXHR9KCkpO1xyXG5cdGV4cG9ydHMuU2NyaXB0ID0gU2NyaXB0O1xyXG5cdHZhciBTZXF1ZW5jZUV4cHJlc3Npb24gPSAoZnVuY3Rpb24gKCkge1xyXG5cdCAgICBmdW5jdGlvbiBTZXF1ZW5jZUV4cHJlc3Npb24oZXhwcmVzc2lvbnMpIHtcclxuXHQgICAgICAgIHRoaXMudHlwZSA9IHN5bnRheF8xLlN5bnRheC5TZXF1ZW5jZUV4cHJlc3Npb247XHJcblx0ICAgICAgICB0aGlzLmV4cHJlc3Npb25zID0gZXhwcmVzc2lvbnM7XHJcblx0ICAgIH1cclxuXHQgICAgcmV0dXJuIFNlcXVlbmNlRXhwcmVzc2lvbjtcclxuXHR9KCkpO1xyXG5cdGV4cG9ydHMuU2VxdWVuY2VFeHByZXNzaW9uID0gU2VxdWVuY2VFeHByZXNzaW9uO1xyXG5cdHZhciBTcHJlYWRFbGVtZW50ID0gKGZ1bmN0aW9uICgpIHtcclxuXHQgICAgZnVuY3Rpb24gU3ByZWFkRWxlbWVudChhcmd1bWVudCkge1xyXG5cdCAgICAgICAgdGhpcy50eXBlID0gc3ludGF4XzEuU3ludGF4LlNwcmVhZEVsZW1lbnQ7XHJcblx0ICAgICAgICB0aGlzLmFyZ3VtZW50ID0gYXJndW1lbnQ7XHJcblx0ICAgIH1cclxuXHQgICAgcmV0dXJuIFNwcmVhZEVsZW1lbnQ7XHJcblx0fSgpKTtcclxuXHRleHBvcnRzLlNwcmVhZEVsZW1lbnQgPSBTcHJlYWRFbGVtZW50O1xyXG5cdHZhciBTdGF0aWNNZW1iZXJFeHByZXNzaW9uID0gKGZ1bmN0aW9uICgpIHtcclxuXHQgICAgZnVuY3Rpb24gU3RhdGljTWVtYmVyRXhwcmVzc2lvbihvYmplY3QsIHByb3BlcnR5KSB7XHJcblx0ICAgICAgICB0aGlzLnR5cGUgPSBzeW50YXhfMS5TeW50YXguTWVtYmVyRXhwcmVzc2lvbjtcclxuXHQgICAgICAgIHRoaXMuY29tcHV0ZWQgPSBmYWxzZTtcclxuXHQgICAgICAgIHRoaXMub2JqZWN0ID0gb2JqZWN0O1xyXG5cdCAgICAgICAgdGhpcy5wcm9wZXJ0eSA9IHByb3BlcnR5O1xyXG5cdCAgICB9XHJcblx0ICAgIHJldHVybiBTdGF0aWNNZW1iZXJFeHByZXNzaW9uO1xyXG5cdH0oKSk7XHJcblx0ZXhwb3J0cy5TdGF0aWNNZW1iZXJFeHByZXNzaW9uID0gU3RhdGljTWVtYmVyRXhwcmVzc2lvbjtcclxuXHR2YXIgU3VwZXIgPSAoZnVuY3Rpb24gKCkge1xyXG5cdCAgICBmdW5jdGlvbiBTdXBlcigpIHtcclxuXHQgICAgICAgIHRoaXMudHlwZSA9IHN5bnRheF8xLlN5bnRheC5TdXBlcjtcclxuXHQgICAgfVxyXG5cdCAgICByZXR1cm4gU3VwZXI7XHJcblx0fSgpKTtcclxuXHRleHBvcnRzLlN1cGVyID0gU3VwZXI7XHJcblx0dmFyIFN3aXRjaENhc2UgPSAoZnVuY3Rpb24gKCkge1xyXG5cdCAgICBmdW5jdGlvbiBTd2l0Y2hDYXNlKHRlc3QsIGNvbnNlcXVlbnQpIHtcclxuXHQgICAgICAgIHRoaXMudHlwZSA9IHN5bnRheF8xLlN5bnRheC5Td2l0Y2hDYXNlO1xyXG5cdCAgICAgICAgdGhpcy50ZXN0ID0gdGVzdDtcclxuXHQgICAgICAgIHRoaXMuY29uc2VxdWVudCA9IGNvbnNlcXVlbnQ7XHJcblx0ICAgIH1cclxuXHQgICAgcmV0dXJuIFN3aXRjaENhc2U7XHJcblx0fSgpKTtcclxuXHRleHBvcnRzLlN3aXRjaENhc2UgPSBTd2l0Y2hDYXNlO1xyXG5cdHZhciBTd2l0Y2hTdGF0ZW1lbnQgPSAoZnVuY3Rpb24gKCkge1xyXG5cdCAgICBmdW5jdGlvbiBTd2l0Y2hTdGF0ZW1lbnQoZGlzY3JpbWluYW50LCBjYXNlcykge1xyXG5cdCAgICAgICAgdGhpcy50eXBlID0gc3ludGF4XzEuU3ludGF4LlN3aXRjaFN0YXRlbWVudDtcclxuXHQgICAgICAgIHRoaXMuZGlzY3JpbWluYW50ID0gZGlzY3JpbWluYW50O1xyXG5cdCAgICAgICAgdGhpcy5jYXNlcyA9IGNhc2VzO1xyXG5cdCAgICB9XHJcblx0ICAgIHJldHVybiBTd2l0Y2hTdGF0ZW1lbnQ7XHJcblx0fSgpKTtcclxuXHRleHBvcnRzLlN3aXRjaFN0YXRlbWVudCA9IFN3aXRjaFN0YXRlbWVudDtcclxuXHR2YXIgVGFnZ2VkVGVtcGxhdGVFeHByZXNzaW9uID0gKGZ1bmN0aW9uICgpIHtcclxuXHQgICAgZnVuY3Rpb24gVGFnZ2VkVGVtcGxhdGVFeHByZXNzaW9uKHRhZywgcXVhc2kpIHtcclxuXHQgICAgICAgIHRoaXMudHlwZSA9IHN5bnRheF8xLlN5bnRheC5UYWdnZWRUZW1wbGF0ZUV4cHJlc3Npb247XHJcblx0ICAgICAgICB0aGlzLnRhZyA9IHRhZztcclxuXHQgICAgICAgIHRoaXMucXVhc2kgPSBxdWFzaTtcclxuXHQgICAgfVxyXG5cdCAgICByZXR1cm4gVGFnZ2VkVGVtcGxhdGVFeHByZXNzaW9uO1xyXG5cdH0oKSk7XHJcblx0ZXhwb3J0cy5UYWdnZWRUZW1wbGF0ZUV4cHJlc3Npb24gPSBUYWdnZWRUZW1wbGF0ZUV4cHJlc3Npb247XHJcblx0dmFyIFRlbXBsYXRlRWxlbWVudCA9IChmdW5jdGlvbiAoKSB7XHJcblx0ICAgIGZ1bmN0aW9uIFRlbXBsYXRlRWxlbWVudCh2YWx1ZSwgdGFpbCkge1xyXG5cdCAgICAgICAgdGhpcy50eXBlID0gc3ludGF4XzEuU3ludGF4LlRlbXBsYXRlRWxlbWVudDtcclxuXHQgICAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcclxuXHQgICAgICAgIHRoaXMudGFpbCA9IHRhaWw7XHJcblx0ICAgIH1cclxuXHQgICAgcmV0dXJuIFRlbXBsYXRlRWxlbWVudDtcclxuXHR9KCkpO1xyXG5cdGV4cG9ydHMuVGVtcGxhdGVFbGVtZW50ID0gVGVtcGxhdGVFbGVtZW50O1xyXG5cdHZhciBUZW1wbGF0ZUxpdGVyYWwgPSAoZnVuY3Rpb24gKCkge1xyXG5cdCAgICBmdW5jdGlvbiBUZW1wbGF0ZUxpdGVyYWwocXVhc2lzLCBleHByZXNzaW9ucykge1xyXG5cdCAgICAgICAgdGhpcy50eXBlID0gc3ludGF4XzEuU3ludGF4LlRlbXBsYXRlTGl0ZXJhbDtcclxuXHQgICAgICAgIHRoaXMucXVhc2lzID0gcXVhc2lzO1xyXG5cdCAgICAgICAgdGhpcy5leHByZXNzaW9ucyA9IGV4cHJlc3Npb25zO1xyXG5cdCAgICB9XHJcblx0ICAgIHJldHVybiBUZW1wbGF0ZUxpdGVyYWw7XHJcblx0fSgpKTtcclxuXHRleHBvcnRzLlRlbXBsYXRlTGl0ZXJhbCA9IFRlbXBsYXRlTGl0ZXJhbDtcclxuXHR2YXIgVGhpc0V4cHJlc3Npb24gPSAoZnVuY3Rpb24gKCkge1xyXG5cdCAgICBmdW5jdGlvbiBUaGlzRXhwcmVzc2lvbigpIHtcclxuXHQgICAgICAgIHRoaXMudHlwZSA9IHN5bnRheF8xLlN5bnRheC5UaGlzRXhwcmVzc2lvbjtcclxuXHQgICAgfVxyXG5cdCAgICByZXR1cm4gVGhpc0V4cHJlc3Npb247XHJcblx0fSgpKTtcclxuXHRleHBvcnRzLlRoaXNFeHByZXNzaW9uID0gVGhpc0V4cHJlc3Npb247XHJcblx0dmFyIFRocm93U3RhdGVtZW50ID0gKGZ1bmN0aW9uICgpIHtcclxuXHQgICAgZnVuY3Rpb24gVGhyb3dTdGF0ZW1lbnQoYXJndW1lbnQpIHtcclxuXHQgICAgICAgIHRoaXMudHlwZSA9IHN5bnRheF8xLlN5bnRheC5UaHJvd1N0YXRlbWVudDtcclxuXHQgICAgICAgIHRoaXMuYXJndW1lbnQgPSBhcmd1bWVudDtcclxuXHQgICAgfVxyXG5cdCAgICByZXR1cm4gVGhyb3dTdGF0ZW1lbnQ7XHJcblx0fSgpKTtcclxuXHRleHBvcnRzLlRocm93U3RhdGVtZW50ID0gVGhyb3dTdGF0ZW1lbnQ7XHJcblx0dmFyIFRyeVN0YXRlbWVudCA9IChmdW5jdGlvbiAoKSB7XHJcblx0ICAgIGZ1bmN0aW9uIFRyeVN0YXRlbWVudChibG9jaywgaGFuZGxlciwgZmluYWxpemVyKSB7XHJcblx0ICAgICAgICB0aGlzLnR5cGUgPSBzeW50YXhfMS5TeW50YXguVHJ5U3RhdGVtZW50O1xyXG5cdCAgICAgICAgdGhpcy5ibG9jayA9IGJsb2NrO1xyXG5cdCAgICAgICAgdGhpcy5oYW5kbGVyID0gaGFuZGxlcjtcclxuXHQgICAgICAgIHRoaXMuZmluYWxpemVyID0gZmluYWxpemVyO1xyXG5cdCAgICB9XHJcblx0ICAgIHJldHVybiBUcnlTdGF0ZW1lbnQ7XHJcblx0fSgpKTtcclxuXHRleHBvcnRzLlRyeVN0YXRlbWVudCA9IFRyeVN0YXRlbWVudDtcclxuXHR2YXIgVW5hcnlFeHByZXNzaW9uID0gKGZ1bmN0aW9uICgpIHtcclxuXHQgICAgZnVuY3Rpb24gVW5hcnlFeHByZXNzaW9uKG9wZXJhdG9yLCBhcmd1bWVudCkge1xyXG5cdCAgICAgICAgdGhpcy50eXBlID0gc3ludGF4XzEuU3ludGF4LlVuYXJ5RXhwcmVzc2lvbjtcclxuXHQgICAgICAgIHRoaXMub3BlcmF0b3IgPSBvcGVyYXRvcjtcclxuXHQgICAgICAgIHRoaXMuYXJndW1lbnQgPSBhcmd1bWVudDtcclxuXHQgICAgICAgIHRoaXMucHJlZml4ID0gdHJ1ZTtcclxuXHQgICAgfVxyXG5cdCAgICByZXR1cm4gVW5hcnlFeHByZXNzaW9uO1xyXG5cdH0oKSk7XHJcblx0ZXhwb3J0cy5VbmFyeUV4cHJlc3Npb24gPSBVbmFyeUV4cHJlc3Npb247XHJcblx0dmFyIFVwZGF0ZUV4cHJlc3Npb24gPSAoZnVuY3Rpb24gKCkge1xyXG5cdCAgICBmdW5jdGlvbiBVcGRhdGVFeHByZXNzaW9uKG9wZXJhdG9yLCBhcmd1bWVudCwgcHJlZml4KSB7XHJcblx0ICAgICAgICB0aGlzLnR5cGUgPSBzeW50YXhfMS5TeW50YXguVXBkYXRlRXhwcmVzc2lvbjtcclxuXHQgICAgICAgIHRoaXMub3BlcmF0b3IgPSBvcGVyYXRvcjtcclxuXHQgICAgICAgIHRoaXMuYXJndW1lbnQgPSBhcmd1bWVudDtcclxuXHQgICAgICAgIHRoaXMucHJlZml4ID0gcHJlZml4O1xyXG5cdCAgICB9XHJcblx0ICAgIHJldHVybiBVcGRhdGVFeHByZXNzaW9uO1xyXG5cdH0oKSk7XHJcblx0ZXhwb3J0cy5VcGRhdGVFeHByZXNzaW9uID0gVXBkYXRlRXhwcmVzc2lvbjtcclxuXHR2YXIgVmFyaWFibGVEZWNsYXJhdGlvbiA9IChmdW5jdGlvbiAoKSB7XHJcblx0ICAgIGZ1bmN0aW9uIFZhcmlhYmxlRGVjbGFyYXRpb24oZGVjbGFyYXRpb25zLCBraW5kKSB7XHJcblx0ICAgICAgICB0aGlzLnR5cGUgPSBzeW50YXhfMS5TeW50YXguVmFyaWFibGVEZWNsYXJhdGlvbjtcclxuXHQgICAgICAgIHRoaXMuZGVjbGFyYXRpb25zID0gZGVjbGFyYXRpb25zO1xyXG5cdCAgICAgICAgdGhpcy5raW5kID0ga2luZDtcclxuXHQgICAgfVxyXG5cdCAgICByZXR1cm4gVmFyaWFibGVEZWNsYXJhdGlvbjtcclxuXHR9KCkpO1xyXG5cdGV4cG9ydHMuVmFyaWFibGVEZWNsYXJhdGlvbiA9IFZhcmlhYmxlRGVjbGFyYXRpb247XHJcblx0dmFyIFZhcmlhYmxlRGVjbGFyYXRvciA9IChmdW5jdGlvbiAoKSB7XHJcblx0ICAgIGZ1bmN0aW9uIFZhcmlhYmxlRGVjbGFyYXRvcihpZCwgaW5pdCkge1xyXG5cdCAgICAgICAgdGhpcy50eXBlID0gc3ludGF4XzEuU3ludGF4LlZhcmlhYmxlRGVjbGFyYXRvcjtcclxuXHQgICAgICAgIHRoaXMuaWQgPSBpZDtcclxuXHQgICAgICAgIHRoaXMuaW5pdCA9IGluaXQ7XHJcblx0ICAgIH1cclxuXHQgICAgcmV0dXJuIFZhcmlhYmxlRGVjbGFyYXRvcjtcclxuXHR9KCkpO1xyXG5cdGV4cG9ydHMuVmFyaWFibGVEZWNsYXJhdG9yID0gVmFyaWFibGVEZWNsYXJhdG9yO1xyXG5cdHZhciBXaGlsZVN0YXRlbWVudCA9IChmdW5jdGlvbiAoKSB7XHJcblx0ICAgIGZ1bmN0aW9uIFdoaWxlU3RhdGVtZW50KHRlc3QsIGJvZHkpIHtcclxuXHQgICAgICAgIHRoaXMudHlwZSA9IHN5bnRheF8xLlN5bnRheC5XaGlsZVN0YXRlbWVudDtcclxuXHQgICAgICAgIHRoaXMudGVzdCA9IHRlc3Q7XHJcblx0ICAgICAgICB0aGlzLmJvZHkgPSBib2R5O1xyXG5cdCAgICB9XHJcblx0ICAgIHJldHVybiBXaGlsZVN0YXRlbWVudDtcclxuXHR9KCkpO1xyXG5cdGV4cG9ydHMuV2hpbGVTdGF0ZW1lbnQgPSBXaGlsZVN0YXRlbWVudDtcclxuXHR2YXIgV2l0aFN0YXRlbWVudCA9IChmdW5jdGlvbiAoKSB7XHJcblx0ICAgIGZ1bmN0aW9uIFdpdGhTdGF0ZW1lbnQob2JqZWN0LCBib2R5KSB7XHJcblx0ICAgICAgICB0aGlzLnR5cGUgPSBzeW50YXhfMS5TeW50YXguV2l0aFN0YXRlbWVudDtcclxuXHQgICAgICAgIHRoaXMub2JqZWN0ID0gb2JqZWN0O1xyXG5cdCAgICAgICAgdGhpcy5ib2R5ID0gYm9keTtcclxuXHQgICAgfVxyXG5cdCAgICByZXR1cm4gV2l0aFN0YXRlbWVudDtcclxuXHR9KCkpO1xyXG5cdGV4cG9ydHMuV2l0aFN0YXRlbWVudCA9IFdpdGhTdGF0ZW1lbnQ7XHJcblx0dmFyIFlpZWxkRXhwcmVzc2lvbiA9IChmdW5jdGlvbiAoKSB7XHJcblx0ICAgIGZ1bmN0aW9uIFlpZWxkRXhwcmVzc2lvbihhcmd1bWVudCwgZGVsZWdhdGUpIHtcclxuXHQgICAgICAgIHRoaXMudHlwZSA9IHN5bnRheF8xLlN5bnRheC5ZaWVsZEV4cHJlc3Npb247XHJcblx0ICAgICAgICB0aGlzLmFyZ3VtZW50ID0gYXJndW1lbnQ7XHJcblx0ICAgICAgICB0aGlzLmRlbGVnYXRlID0gZGVsZWdhdGU7XHJcblx0ICAgIH1cclxuXHQgICAgcmV0dXJuIFlpZWxkRXhwcmVzc2lvbjtcclxuXHR9KCkpO1xyXG5cdGV4cG9ydHMuWWllbGRFeHByZXNzaW9uID0gWWllbGRFeHByZXNzaW9uO1xyXG5cblxuLyoqKi8gfSxcbi8qIDggKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cdFwidXNlIHN0cmljdFwiO1xyXG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuXHR2YXIgYXNzZXJ0XzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDkpO1xyXG5cdHZhciBlcnJvcl9oYW5kbGVyXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEwKTtcclxuXHR2YXIgbWVzc2FnZXNfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMTEpO1xyXG5cdHZhciBOb2RlID0gX193ZWJwYWNrX3JlcXVpcmVfXyg3KTtcclxuXHR2YXIgc2Nhbm5lcl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMik7XHJcblx0dmFyIHN5bnRheF8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygyKTtcclxuXHR2YXIgdG9rZW5fMSA9IF9fd2VicGFja19yZXF1aXJlX18oMTMpO1xyXG5cdHZhciBBcnJvd1BhcmFtZXRlclBsYWNlSG9sZGVyID0gJ0Fycm93UGFyYW1ldGVyUGxhY2VIb2xkZXInO1xyXG5cdHZhciBQYXJzZXIgPSAoZnVuY3Rpb24gKCkge1xyXG5cdCAgICBmdW5jdGlvbiBQYXJzZXIoY29kZSwgb3B0aW9ucywgZGVsZWdhdGUpIHtcclxuXHQgICAgICAgIGlmIChvcHRpb25zID09PSB2b2lkIDApIHsgb3B0aW9ucyA9IHt9OyB9XHJcblx0ICAgICAgICB0aGlzLmNvbmZpZyA9IHtcclxuXHQgICAgICAgICAgICByYW5nZTogKHR5cGVvZiBvcHRpb25zLnJhbmdlID09PSAnYm9vbGVhbicpICYmIG9wdGlvbnMucmFuZ2UsXHJcblx0ICAgICAgICAgICAgbG9jOiAodHlwZW9mIG9wdGlvbnMubG9jID09PSAnYm9vbGVhbicpICYmIG9wdGlvbnMubG9jLFxyXG5cdCAgICAgICAgICAgIHNvdXJjZTogbnVsbCxcclxuXHQgICAgICAgICAgICB0b2tlbnM6ICh0eXBlb2Ygb3B0aW9ucy50b2tlbnMgPT09ICdib29sZWFuJykgJiYgb3B0aW9ucy50b2tlbnMsXHJcblx0ICAgICAgICAgICAgY29tbWVudDogKHR5cGVvZiBvcHRpb25zLmNvbW1lbnQgPT09ICdib29sZWFuJykgJiYgb3B0aW9ucy5jb21tZW50LFxyXG5cdCAgICAgICAgICAgIHRvbGVyYW50OiAodHlwZW9mIG9wdGlvbnMudG9sZXJhbnQgPT09ICdib29sZWFuJykgJiYgb3B0aW9ucy50b2xlcmFudFxyXG5cdCAgICAgICAgfTtcclxuXHQgICAgICAgIGlmICh0aGlzLmNvbmZpZy5sb2MgJiYgb3B0aW9ucy5zb3VyY2UgJiYgb3B0aW9ucy5zb3VyY2UgIT09IG51bGwpIHtcclxuXHQgICAgICAgICAgICB0aGlzLmNvbmZpZy5zb3VyY2UgPSBTdHJpbmcob3B0aW9ucy5zb3VyY2UpO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgdGhpcy5kZWxlZ2F0ZSA9IGRlbGVnYXRlO1xyXG5cdCAgICAgICAgdGhpcy5lcnJvckhhbmRsZXIgPSBuZXcgZXJyb3JfaGFuZGxlcl8xLkVycm9ySGFuZGxlcigpO1xyXG5cdCAgICAgICAgdGhpcy5lcnJvckhhbmRsZXIudG9sZXJhbnQgPSB0aGlzLmNvbmZpZy50b2xlcmFudDtcclxuXHQgICAgICAgIHRoaXMuc2Nhbm5lciA9IG5ldyBzY2FubmVyXzEuU2Nhbm5lcihjb2RlLCB0aGlzLmVycm9ySGFuZGxlcik7XHJcblx0ICAgICAgICB0aGlzLnNjYW5uZXIudHJhY2tDb21tZW50ID0gdGhpcy5jb25maWcuY29tbWVudDtcclxuXHQgICAgICAgIHRoaXMub3BlcmF0b3JQcmVjZWRlbmNlID0ge1xyXG5cdCAgICAgICAgICAgICcpJzogMCxcclxuXHQgICAgICAgICAgICAnOyc6IDAsXHJcblx0ICAgICAgICAgICAgJywnOiAwLFxyXG5cdCAgICAgICAgICAgICc9JzogMCxcclxuXHQgICAgICAgICAgICAnXSc6IDAsXHJcblx0ICAgICAgICAgICAgJ3x8JzogMSxcclxuXHQgICAgICAgICAgICAnJiYnOiAyLFxyXG5cdCAgICAgICAgICAgICd8JzogMyxcclxuXHQgICAgICAgICAgICAnXic6IDQsXHJcblx0ICAgICAgICAgICAgJyYnOiA1LFxyXG5cdCAgICAgICAgICAgICc9PSc6IDYsXHJcblx0ICAgICAgICAgICAgJyE9JzogNixcclxuXHQgICAgICAgICAgICAnPT09JzogNixcclxuXHQgICAgICAgICAgICAnIT09JzogNixcclxuXHQgICAgICAgICAgICAnPCc6IDcsXHJcblx0ICAgICAgICAgICAgJz4nOiA3LFxyXG5cdCAgICAgICAgICAgICc8PSc6IDcsXHJcblx0ICAgICAgICAgICAgJz49JzogNyxcclxuXHQgICAgICAgICAgICAnPDwnOiA4LFxyXG5cdCAgICAgICAgICAgICc+Pic6IDgsXHJcblx0ICAgICAgICAgICAgJz4+Pic6IDgsXHJcblx0ICAgICAgICAgICAgJysnOiA5LFxyXG5cdCAgICAgICAgICAgICctJzogOSxcclxuXHQgICAgICAgICAgICAnKic6IDExLFxyXG5cdCAgICAgICAgICAgICcvJzogMTEsXHJcblx0ICAgICAgICAgICAgJyUnOiAxMVxyXG5cdCAgICAgICAgfTtcclxuXHQgICAgICAgIHRoaXMubG9va2FoZWFkID0ge1xyXG5cdCAgICAgICAgICAgIHR5cGU6IDIgLyogRU9GICovLFxyXG5cdCAgICAgICAgICAgIHZhbHVlOiAnJyxcclxuXHQgICAgICAgICAgICBsaW5lTnVtYmVyOiB0aGlzLnNjYW5uZXIubGluZU51bWJlcixcclxuXHQgICAgICAgICAgICBsaW5lU3RhcnQ6IDAsXHJcblx0ICAgICAgICAgICAgc3RhcnQ6IDAsXHJcblx0ICAgICAgICAgICAgZW5kOiAwXHJcblx0ICAgICAgICB9O1xyXG5cdCAgICAgICAgdGhpcy5oYXNMaW5lVGVybWluYXRvciA9IGZhbHNlO1xyXG5cdCAgICAgICAgdGhpcy5jb250ZXh0ID0ge1xyXG5cdCAgICAgICAgICAgIGlzTW9kdWxlOiBmYWxzZSxcclxuXHQgICAgICAgICAgICBhd2FpdDogZmFsc2UsXHJcblx0ICAgICAgICAgICAgYWxsb3dJbjogdHJ1ZSxcclxuXHQgICAgICAgICAgICBhbGxvd1N0cmljdERpcmVjdGl2ZTogdHJ1ZSxcclxuXHQgICAgICAgICAgICBhbGxvd1lpZWxkOiB0cnVlLFxyXG5cdCAgICAgICAgICAgIGZpcnN0Q292ZXJJbml0aWFsaXplZE5hbWVFcnJvcjogbnVsbCxcclxuXHQgICAgICAgICAgICBpc0Fzc2lnbm1lbnRUYXJnZXQ6IGZhbHNlLFxyXG5cdCAgICAgICAgICAgIGlzQmluZGluZ0VsZW1lbnQ6IGZhbHNlLFxyXG5cdCAgICAgICAgICAgIGluRnVuY3Rpb25Cb2R5OiBmYWxzZSxcclxuXHQgICAgICAgICAgICBpbkl0ZXJhdGlvbjogZmFsc2UsXHJcblx0ICAgICAgICAgICAgaW5Td2l0Y2g6IGZhbHNlLFxyXG5cdCAgICAgICAgICAgIGxhYmVsU2V0OiB7fSxcclxuXHQgICAgICAgICAgICBzdHJpY3Q6IGZhbHNlXHJcblx0ICAgICAgICB9O1xyXG5cdCAgICAgICAgdGhpcy50b2tlbnMgPSBbXTtcclxuXHQgICAgICAgIHRoaXMuc3RhcnRNYXJrZXIgPSB7XHJcblx0ICAgICAgICAgICAgaW5kZXg6IDAsXHJcblx0ICAgICAgICAgICAgbGluZTogdGhpcy5zY2FubmVyLmxpbmVOdW1iZXIsXHJcblx0ICAgICAgICAgICAgY29sdW1uOiAwXHJcblx0ICAgICAgICB9O1xyXG5cdCAgICAgICAgdGhpcy5sYXN0TWFya2VyID0ge1xyXG5cdCAgICAgICAgICAgIGluZGV4OiAwLFxyXG5cdCAgICAgICAgICAgIGxpbmU6IHRoaXMuc2Nhbm5lci5saW5lTnVtYmVyLFxyXG5cdCAgICAgICAgICAgIGNvbHVtbjogMFxyXG5cdCAgICAgICAgfTtcclxuXHQgICAgICAgIHRoaXMubmV4dFRva2VuKCk7XHJcblx0ICAgICAgICB0aGlzLmxhc3RNYXJrZXIgPSB7XHJcblx0ICAgICAgICAgICAgaW5kZXg6IHRoaXMuc2Nhbm5lci5pbmRleCxcclxuXHQgICAgICAgICAgICBsaW5lOiB0aGlzLnNjYW5uZXIubGluZU51bWJlcixcclxuXHQgICAgICAgICAgICBjb2x1bW46IHRoaXMuc2Nhbm5lci5pbmRleCAtIHRoaXMuc2Nhbm5lci5saW5lU3RhcnRcclxuXHQgICAgICAgIH07XHJcblx0ICAgIH1cclxuXHQgICAgUGFyc2VyLnByb3RvdHlwZS50aHJvd0Vycm9yID0gZnVuY3Rpb24gKG1lc3NhZ2VGb3JtYXQpIHtcclxuXHQgICAgICAgIHZhciB2YWx1ZXMgPSBbXTtcclxuXHQgICAgICAgIGZvciAodmFyIF9pID0gMTsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XHJcblx0ICAgICAgICAgICAgdmFsdWVzW19pIC0gMV0gPSBhcmd1bWVudHNbX2ldO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgdmFyIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpO1xyXG5cdCAgICAgICAgdmFyIG1zZyA9IG1lc3NhZ2VGb3JtYXQucmVwbGFjZSgvJShcXGQpL2csIGZ1bmN0aW9uICh3aG9sZSwgaWR4KSB7XHJcblx0ICAgICAgICAgICAgYXNzZXJ0XzEuYXNzZXJ0KGlkeCA8IGFyZ3MubGVuZ3RoLCAnTWVzc2FnZSByZWZlcmVuY2UgbXVzdCBiZSBpbiByYW5nZScpO1xyXG5cdCAgICAgICAgICAgIHJldHVybiBhcmdzW2lkeF07XHJcblx0ICAgICAgICB9KTtcclxuXHQgICAgICAgIHZhciBpbmRleCA9IHRoaXMubGFzdE1hcmtlci5pbmRleDtcclxuXHQgICAgICAgIHZhciBsaW5lID0gdGhpcy5sYXN0TWFya2VyLmxpbmU7XHJcblx0ICAgICAgICB2YXIgY29sdW1uID0gdGhpcy5sYXN0TWFya2VyLmNvbHVtbiArIDE7XHJcblx0ICAgICAgICB0aHJvdyB0aGlzLmVycm9ySGFuZGxlci5jcmVhdGVFcnJvcihpbmRleCwgbGluZSwgY29sdW1uLCBtc2cpO1xyXG5cdCAgICB9O1xyXG5cdCAgICBQYXJzZXIucHJvdG90eXBlLnRvbGVyYXRlRXJyb3IgPSBmdW5jdGlvbiAobWVzc2FnZUZvcm1hdCkge1xyXG5cdCAgICAgICAgdmFyIHZhbHVlcyA9IFtdO1xyXG5cdCAgICAgICAgZm9yICh2YXIgX2kgPSAxOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcclxuXHQgICAgICAgICAgICB2YWx1ZXNbX2kgLSAxXSA9IGFyZ3VtZW50c1tfaV07XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICB2YXIgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSk7XHJcblx0ICAgICAgICB2YXIgbXNnID0gbWVzc2FnZUZvcm1hdC5yZXBsYWNlKC8lKFxcZCkvZywgZnVuY3Rpb24gKHdob2xlLCBpZHgpIHtcclxuXHQgICAgICAgICAgICBhc3NlcnRfMS5hc3NlcnQoaWR4IDwgYXJncy5sZW5ndGgsICdNZXNzYWdlIHJlZmVyZW5jZSBtdXN0IGJlIGluIHJhbmdlJyk7XHJcblx0ICAgICAgICAgICAgcmV0dXJuIGFyZ3NbaWR4XTtcclxuXHQgICAgICAgIH0pO1xyXG5cdCAgICAgICAgdmFyIGluZGV4ID0gdGhpcy5sYXN0TWFya2VyLmluZGV4O1xyXG5cdCAgICAgICAgdmFyIGxpbmUgPSB0aGlzLnNjYW5uZXIubGluZU51bWJlcjtcclxuXHQgICAgICAgIHZhciBjb2x1bW4gPSB0aGlzLmxhc3RNYXJrZXIuY29sdW1uICsgMTtcclxuXHQgICAgICAgIHRoaXMuZXJyb3JIYW5kbGVyLnRvbGVyYXRlRXJyb3IoaW5kZXgsIGxpbmUsIGNvbHVtbiwgbXNnKTtcclxuXHQgICAgfTtcclxuXHQgICAgLy8gVGhyb3cgYW4gZXhjZXB0aW9uIGJlY2F1c2Ugb2YgdGhlIHRva2VuLlxyXG5cdCAgICBQYXJzZXIucHJvdG90eXBlLnVuZXhwZWN0ZWRUb2tlbkVycm9yID0gZnVuY3Rpb24gKHRva2VuLCBtZXNzYWdlKSB7XHJcblx0ICAgICAgICB2YXIgbXNnID0gbWVzc2FnZSB8fCBtZXNzYWdlc18xLk1lc3NhZ2VzLlVuZXhwZWN0ZWRUb2tlbjtcclxuXHQgICAgICAgIHZhciB2YWx1ZTtcclxuXHQgICAgICAgIGlmICh0b2tlbikge1xyXG5cdCAgICAgICAgICAgIGlmICghbWVzc2FnZSkge1xyXG5cdCAgICAgICAgICAgICAgICBtc2cgPSAodG9rZW4udHlwZSA9PT0gMiAvKiBFT0YgKi8pID8gbWVzc2FnZXNfMS5NZXNzYWdlcy5VbmV4cGVjdGVkRU9TIDpcclxuXHQgICAgICAgICAgICAgICAgICAgICh0b2tlbi50eXBlID09PSAzIC8qIElkZW50aWZpZXIgKi8pID8gbWVzc2FnZXNfMS5NZXNzYWdlcy5VbmV4cGVjdGVkSWRlbnRpZmllciA6XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgKHRva2VuLnR5cGUgPT09IDYgLyogTnVtZXJpY0xpdGVyYWwgKi8pID8gbWVzc2FnZXNfMS5NZXNzYWdlcy5VbmV4cGVjdGVkTnVtYmVyIDpcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgKHRva2VuLnR5cGUgPT09IDggLyogU3RyaW5nTGl0ZXJhbCAqLykgPyBtZXNzYWdlc18xLk1lc3NhZ2VzLlVuZXhwZWN0ZWRTdHJpbmcgOlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKHRva2VuLnR5cGUgPT09IDEwIC8qIFRlbXBsYXRlICovKSA/IG1lc3NhZ2VzXzEuTWVzc2FnZXMuVW5leHBlY3RlZFRlbXBsYXRlIDpcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlc18xLk1lc3NhZ2VzLlVuZXhwZWN0ZWRUb2tlbjtcclxuXHQgICAgICAgICAgICAgICAgaWYgKHRva2VuLnR5cGUgPT09IDQgLyogS2V5d29yZCAqLykge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuc2Nhbm5lci5pc0Z1dHVyZVJlc2VydmVkV29yZCh0b2tlbi52YWx1ZSkpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBtc2cgPSBtZXNzYWdlc18xLk1lc3NhZ2VzLlVuZXhwZWN0ZWRSZXNlcnZlZDtcclxuXHQgICAgICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMuY29udGV4dC5zdHJpY3QgJiYgdGhpcy5zY2FubmVyLmlzU3RyaWN0TW9kZVJlc2VydmVkV29yZCh0b2tlbi52YWx1ZSkpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBtc2cgPSBtZXNzYWdlc18xLk1lc3NhZ2VzLlN0cmljdFJlc2VydmVkV29yZDtcclxuXHQgICAgICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICB2YWx1ZSA9IHRva2VuLnZhbHVlO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgZWxzZSB7XHJcblx0ICAgICAgICAgICAgdmFsdWUgPSAnSUxMRUdBTCc7XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICBtc2cgPSBtc2cucmVwbGFjZSgnJTAnLCB2YWx1ZSk7XHJcblx0ICAgICAgICBpZiAodG9rZW4gJiYgdHlwZW9mIHRva2VuLmxpbmVOdW1iZXIgPT09ICdudW1iZXInKSB7XHJcblx0ICAgICAgICAgICAgdmFyIGluZGV4ID0gdG9rZW4uc3RhcnQ7XHJcblx0ICAgICAgICAgICAgdmFyIGxpbmUgPSB0b2tlbi5saW5lTnVtYmVyO1xyXG5cdCAgICAgICAgICAgIHZhciBsYXN0TWFya2VyTGluZVN0YXJ0ID0gdGhpcy5sYXN0TWFya2VyLmluZGV4IC0gdGhpcy5sYXN0TWFya2VyLmNvbHVtbjtcclxuXHQgICAgICAgICAgICB2YXIgY29sdW1uID0gdG9rZW4uc3RhcnQgLSBsYXN0TWFya2VyTGluZVN0YXJ0ICsgMTtcclxuXHQgICAgICAgICAgICByZXR1cm4gdGhpcy5lcnJvckhhbmRsZXIuY3JlYXRlRXJyb3IoaW5kZXgsIGxpbmUsIGNvbHVtbiwgbXNnKTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIGVsc2Uge1xyXG5cdCAgICAgICAgICAgIHZhciBpbmRleCA9IHRoaXMubGFzdE1hcmtlci5pbmRleDtcclxuXHQgICAgICAgICAgICB2YXIgbGluZSA9IHRoaXMubGFzdE1hcmtlci5saW5lO1xyXG5cdCAgICAgICAgICAgIHZhciBjb2x1bW4gPSB0aGlzLmxhc3RNYXJrZXIuY29sdW1uICsgMTtcclxuXHQgICAgICAgICAgICByZXR1cm4gdGhpcy5lcnJvckhhbmRsZXIuY3JlYXRlRXJyb3IoaW5kZXgsIGxpbmUsIGNvbHVtbiwgbXNnKTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgfTtcclxuXHQgICAgUGFyc2VyLnByb3RvdHlwZS50aHJvd1VuZXhwZWN0ZWRUb2tlbiA9IGZ1bmN0aW9uICh0b2tlbiwgbWVzc2FnZSkge1xyXG5cdCAgICAgICAgdGhyb3cgdGhpcy51bmV4cGVjdGVkVG9rZW5FcnJvcih0b2tlbiwgbWVzc2FnZSk7XHJcblx0ICAgIH07XHJcblx0ICAgIFBhcnNlci5wcm90b3R5cGUudG9sZXJhdGVVbmV4cGVjdGVkVG9rZW4gPSBmdW5jdGlvbiAodG9rZW4sIG1lc3NhZ2UpIHtcclxuXHQgICAgICAgIHRoaXMuZXJyb3JIYW5kbGVyLnRvbGVyYXRlKHRoaXMudW5leHBlY3RlZFRva2VuRXJyb3IodG9rZW4sIG1lc3NhZ2UpKTtcclxuXHQgICAgfTtcclxuXHQgICAgUGFyc2VyLnByb3RvdHlwZS5jb2xsZWN0Q29tbWVudHMgPSBmdW5jdGlvbiAoKSB7XHJcblx0ICAgICAgICBpZiAoIXRoaXMuY29uZmlnLmNvbW1lbnQpIHtcclxuXHQgICAgICAgICAgICB0aGlzLnNjYW5uZXIuc2NhbkNvbW1lbnRzKCk7XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICBlbHNlIHtcclxuXHQgICAgICAgICAgICB2YXIgY29tbWVudHMgPSB0aGlzLnNjYW5uZXIuc2NhbkNvbW1lbnRzKCk7XHJcblx0ICAgICAgICAgICAgaWYgKGNvbW1lbnRzLmxlbmd0aCA+IDAgJiYgdGhpcy5kZWxlZ2F0ZSkge1xyXG5cdCAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNvbW1lbnRzLmxlbmd0aDsgKytpKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgZSA9IGNvbW1lbnRzW2ldO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIG5vZGUgPSB2b2lkIDA7XHJcblx0ICAgICAgICAgICAgICAgICAgICBub2RlID0ge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IGUubXVsdGlMaW5lID8gJ0Jsb2NrQ29tbWVudCcgOiAnTGluZUNvbW1lbnQnLFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiB0aGlzLnNjYW5uZXIuc291cmNlLnNsaWNlKGUuc2xpY2VbMF0sIGUuc2xpY2VbMV0pXHJcblx0ICAgICAgICAgICAgICAgICAgICB9O1xyXG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlnLnJhbmdlKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgbm9kZS5yYW5nZSA9IGUucmFuZ2U7XHJcblx0ICAgICAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5jb25maWcubG9jKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgbm9kZS5sb2MgPSBlLmxvYztcclxuXHQgICAgICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgICAgIHZhciBtZXRhZGF0YSA9IHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBzdGFydDoge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBsaW5lOiBlLmxvYy5zdGFydC5saW5lLFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2x1bW46IGUubG9jLnN0YXJ0LmNvbHVtbixcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgb2Zmc2V0OiBlLnJhbmdlWzBdXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfSxcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBlbmQ6IHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGluZTogZS5sb2MuZW5kLmxpbmUsXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbHVtbjogZS5sb2MuZW5kLmNvbHVtbixcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgb2Zmc2V0OiBlLnJhbmdlWzFdXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICAgICAgfTtcclxuXHQgICAgICAgICAgICAgICAgICAgIHRoaXMuZGVsZWdhdGUobm9kZSwgbWV0YWRhdGEpO1xyXG5cdCAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgfVxyXG5cdCAgICB9O1xyXG5cdCAgICAvLyBGcm9tIGludGVybmFsIHJlcHJlc2VudGF0aW9uIHRvIGFuIGV4dGVybmFsIHN0cnVjdHVyZVxyXG5cdCAgICBQYXJzZXIucHJvdG90eXBlLmdldFRva2VuUmF3ID0gZnVuY3Rpb24gKHRva2VuKSB7XHJcblx0ICAgICAgICByZXR1cm4gdGhpcy5zY2FubmVyLnNvdXJjZS5zbGljZSh0b2tlbi5zdGFydCwgdG9rZW4uZW5kKTtcclxuXHQgICAgfTtcclxuXHQgICAgUGFyc2VyLnByb3RvdHlwZS5jb252ZXJ0VG9rZW4gPSBmdW5jdGlvbiAodG9rZW4pIHtcclxuXHQgICAgICAgIHZhciB0ID0ge1xyXG5cdCAgICAgICAgICAgIHR5cGU6IHRva2VuXzEuVG9rZW5OYW1lW3Rva2VuLnR5cGVdLFxyXG5cdCAgICAgICAgICAgIHZhbHVlOiB0aGlzLmdldFRva2VuUmF3KHRva2VuKVxyXG5cdCAgICAgICAgfTtcclxuXHQgICAgICAgIGlmICh0aGlzLmNvbmZpZy5yYW5nZSkge1xyXG5cdCAgICAgICAgICAgIHQucmFuZ2UgPSBbdG9rZW4uc3RhcnQsIHRva2VuLmVuZF07XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICBpZiAodGhpcy5jb25maWcubG9jKSB7XHJcblx0ICAgICAgICAgICAgdC5sb2MgPSB7XHJcblx0ICAgICAgICAgICAgICAgIHN0YXJ0OiB7XHJcblx0ICAgICAgICAgICAgICAgICAgICBsaW5lOiB0aGlzLnN0YXJ0TWFya2VyLmxpbmUsXHJcblx0ICAgICAgICAgICAgICAgICAgICBjb2x1bW46IHRoaXMuc3RhcnRNYXJrZXIuY29sdW1uXHJcblx0ICAgICAgICAgICAgICAgIH0sXHJcblx0ICAgICAgICAgICAgICAgIGVuZDoge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgbGluZTogdGhpcy5zY2FubmVyLmxpbmVOdW1iZXIsXHJcblx0ICAgICAgICAgICAgICAgICAgICBjb2x1bW46IHRoaXMuc2Nhbm5lci5pbmRleCAtIHRoaXMuc2Nhbm5lci5saW5lU3RhcnRcclxuXHQgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgIH07XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICBpZiAodG9rZW4udHlwZSA9PT0gOSAvKiBSZWd1bGFyRXhwcmVzc2lvbiAqLykge1xyXG5cdCAgICAgICAgICAgIHZhciBwYXR0ZXJuID0gdG9rZW4ucGF0dGVybjtcclxuXHQgICAgICAgICAgICB2YXIgZmxhZ3MgPSB0b2tlbi5mbGFncztcclxuXHQgICAgICAgICAgICB0LnJlZ2V4ID0geyBwYXR0ZXJuOiBwYXR0ZXJuLCBmbGFnczogZmxhZ3MgfTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIHJldHVybiB0O1xyXG5cdCAgICB9O1xyXG5cdCAgICBQYXJzZXIucHJvdG90eXBlLm5leHRUb2tlbiA9IGZ1bmN0aW9uICgpIHtcclxuXHQgICAgICAgIHZhciB0b2tlbiA9IHRoaXMubG9va2FoZWFkO1xyXG5cdCAgICAgICAgdGhpcy5sYXN0TWFya2VyLmluZGV4ID0gdGhpcy5zY2FubmVyLmluZGV4O1xyXG5cdCAgICAgICAgdGhpcy5sYXN0TWFya2VyLmxpbmUgPSB0aGlzLnNjYW5uZXIubGluZU51bWJlcjtcclxuXHQgICAgICAgIHRoaXMubGFzdE1hcmtlci5jb2x1bW4gPSB0aGlzLnNjYW5uZXIuaW5kZXggLSB0aGlzLnNjYW5uZXIubGluZVN0YXJ0O1xyXG5cdCAgICAgICAgdGhpcy5jb2xsZWN0Q29tbWVudHMoKTtcclxuXHQgICAgICAgIGlmICh0aGlzLnNjYW5uZXIuaW5kZXggIT09IHRoaXMuc3RhcnRNYXJrZXIuaW5kZXgpIHtcclxuXHQgICAgICAgICAgICB0aGlzLnN0YXJ0TWFya2VyLmluZGV4ID0gdGhpcy5zY2FubmVyLmluZGV4O1xyXG5cdCAgICAgICAgICAgIHRoaXMuc3RhcnRNYXJrZXIubGluZSA9IHRoaXMuc2Nhbm5lci5saW5lTnVtYmVyO1xyXG5cdCAgICAgICAgICAgIHRoaXMuc3RhcnRNYXJrZXIuY29sdW1uID0gdGhpcy5zY2FubmVyLmluZGV4IC0gdGhpcy5zY2FubmVyLmxpbmVTdGFydDtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIHZhciBuZXh0ID0gdGhpcy5zY2FubmVyLmxleCgpO1xyXG5cdCAgICAgICAgdGhpcy5oYXNMaW5lVGVybWluYXRvciA9ICh0b2tlbi5saW5lTnVtYmVyICE9PSBuZXh0LmxpbmVOdW1iZXIpO1xyXG5cdCAgICAgICAgaWYgKG5leHQgJiYgdGhpcy5jb250ZXh0LnN0cmljdCAmJiBuZXh0LnR5cGUgPT09IDMgLyogSWRlbnRpZmllciAqLykge1xyXG5cdCAgICAgICAgICAgIGlmICh0aGlzLnNjYW5uZXIuaXNTdHJpY3RNb2RlUmVzZXJ2ZWRXb3JkKG5leHQudmFsdWUpKSB7XHJcblx0ICAgICAgICAgICAgICAgIG5leHQudHlwZSA9IDQgLyogS2V5d29yZCAqLztcclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICB0aGlzLmxvb2thaGVhZCA9IG5leHQ7XHJcblx0ICAgICAgICBpZiAodGhpcy5jb25maWcudG9rZW5zICYmIG5leHQudHlwZSAhPT0gMiAvKiBFT0YgKi8pIHtcclxuXHQgICAgICAgICAgICB0aGlzLnRva2Vucy5wdXNoKHRoaXMuY29udmVydFRva2VuKG5leHQpKTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIHJldHVybiB0b2tlbjtcclxuXHQgICAgfTtcclxuXHQgICAgUGFyc2VyLnByb3RvdHlwZS5uZXh0UmVnZXhUb2tlbiA9IGZ1bmN0aW9uICgpIHtcclxuXHQgICAgICAgIHRoaXMuY29sbGVjdENvbW1lbnRzKCk7XHJcblx0ICAgICAgICB2YXIgdG9rZW4gPSB0aGlzLnNjYW5uZXIuc2NhblJlZ0V4cCgpO1xyXG5cdCAgICAgICAgaWYgKHRoaXMuY29uZmlnLnRva2Vucykge1xyXG5cdCAgICAgICAgICAgIC8vIFBvcCB0aGUgcHJldmlvdXMgdG9rZW4sICcvJyBvciAnLz0nXHJcblx0ICAgICAgICAgICAgLy8gVGhpcyBpcyBhZGRlZCBmcm9tIHRoZSBsb29rYWhlYWQgdG9rZW4uXHJcblx0ICAgICAgICAgICAgdGhpcy50b2tlbnMucG9wKCk7XHJcblx0ICAgICAgICAgICAgdGhpcy50b2tlbnMucHVzaCh0aGlzLmNvbnZlcnRUb2tlbih0b2tlbikpO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgLy8gUHJpbWUgdGhlIG5leHQgbG9va2FoZWFkLlxyXG5cdCAgICAgICAgdGhpcy5sb29rYWhlYWQgPSB0b2tlbjtcclxuXHQgICAgICAgIHRoaXMubmV4dFRva2VuKCk7XHJcblx0ICAgICAgICByZXR1cm4gdG9rZW47XHJcblx0ICAgIH07XHJcblx0ICAgIFBhcnNlci5wcm90b3R5cGUuY3JlYXRlTm9kZSA9IGZ1bmN0aW9uICgpIHtcclxuXHQgICAgICAgIHJldHVybiB7XHJcblx0ICAgICAgICAgICAgaW5kZXg6IHRoaXMuc3RhcnRNYXJrZXIuaW5kZXgsXHJcblx0ICAgICAgICAgICAgbGluZTogdGhpcy5zdGFydE1hcmtlci5saW5lLFxyXG5cdCAgICAgICAgICAgIGNvbHVtbjogdGhpcy5zdGFydE1hcmtlci5jb2x1bW5cclxuXHQgICAgICAgIH07XHJcblx0ICAgIH07XHJcblx0ICAgIFBhcnNlci5wcm90b3R5cGUuc3RhcnROb2RlID0gZnVuY3Rpb24gKHRva2VuKSB7XHJcblx0ICAgICAgICByZXR1cm4ge1xyXG5cdCAgICAgICAgICAgIGluZGV4OiB0b2tlbi5zdGFydCxcclxuXHQgICAgICAgICAgICBsaW5lOiB0b2tlbi5saW5lTnVtYmVyLFxyXG5cdCAgICAgICAgICAgIGNvbHVtbjogdG9rZW4uc3RhcnQgLSB0b2tlbi5saW5lU3RhcnRcclxuXHQgICAgICAgIH07XHJcblx0ICAgIH07XHJcblx0ICAgIFBhcnNlci5wcm90b3R5cGUuZmluYWxpemUgPSBmdW5jdGlvbiAobWFya2VyLCBub2RlKSB7XHJcblx0ICAgICAgICBpZiAodGhpcy5jb25maWcucmFuZ2UpIHtcclxuXHQgICAgICAgICAgICBub2RlLnJhbmdlID0gW21hcmtlci5pbmRleCwgdGhpcy5sYXN0TWFya2VyLmluZGV4XTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIGlmICh0aGlzLmNvbmZpZy5sb2MpIHtcclxuXHQgICAgICAgICAgICBub2RlLmxvYyA9IHtcclxuXHQgICAgICAgICAgICAgICAgc3RhcnQ6IHtcclxuXHQgICAgICAgICAgICAgICAgICAgIGxpbmU6IG1hcmtlci5saW5lLFxyXG5cdCAgICAgICAgICAgICAgICAgICAgY29sdW1uOiBtYXJrZXIuY29sdW1uLFxyXG5cdCAgICAgICAgICAgICAgICB9LFxyXG5cdCAgICAgICAgICAgICAgICBlbmQ6IHtcclxuXHQgICAgICAgICAgICAgICAgICAgIGxpbmU6IHRoaXMubGFzdE1hcmtlci5saW5lLFxyXG5cdCAgICAgICAgICAgICAgICAgICAgY29sdW1uOiB0aGlzLmxhc3RNYXJrZXIuY29sdW1uXHJcblx0ICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICB9O1xyXG5cdCAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZy5zb3VyY2UpIHtcclxuXHQgICAgICAgICAgICAgICAgbm9kZS5sb2Muc291cmNlID0gdGhpcy5jb25maWcuc291cmNlO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIGlmICh0aGlzLmRlbGVnYXRlKSB7XHJcblx0ICAgICAgICAgICAgdmFyIG1ldGFkYXRhID0ge1xyXG5cdCAgICAgICAgICAgICAgICBzdGFydDoge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgbGluZTogbWFya2VyLmxpbmUsXHJcblx0ICAgICAgICAgICAgICAgICAgICBjb2x1bW46IG1hcmtlci5jb2x1bW4sXHJcblx0ICAgICAgICAgICAgICAgICAgICBvZmZzZXQ6IG1hcmtlci5pbmRleFxyXG5cdCAgICAgICAgICAgICAgICB9LFxyXG5cdCAgICAgICAgICAgICAgICBlbmQ6IHtcclxuXHQgICAgICAgICAgICAgICAgICAgIGxpbmU6IHRoaXMubGFzdE1hcmtlci5saW5lLFxyXG5cdCAgICAgICAgICAgICAgICAgICAgY29sdW1uOiB0aGlzLmxhc3RNYXJrZXIuY29sdW1uLFxyXG5cdCAgICAgICAgICAgICAgICAgICAgb2Zmc2V0OiB0aGlzLmxhc3RNYXJrZXIuaW5kZXhcclxuXHQgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgIH07XHJcblx0ICAgICAgICAgICAgdGhpcy5kZWxlZ2F0ZShub2RlLCBtZXRhZGF0YSk7XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICByZXR1cm4gbm9kZTtcclxuXHQgICAgfTtcclxuXHQgICAgLy8gRXhwZWN0IHRoZSBuZXh0IHRva2VuIHRvIG1hdGNoIHRoZSBzcGVjaWZpZWQgcHVuY3R1YXRvci5cclxuXHQgICAgLy8gSWYgbm90LCBhbiBleGNlcHRpb24gd2lsbCBiZSB0aHJvd24uXHJcblx0ICAgIFBhcnNlci5wcm90b3R5cGUuZXhwZWN0ID0gZnVuY3Rpb24gKHZhbHVlKSB7XHJcblx0ICAgICAgICB2YXIgdG9rZW4gPSB0aGlzLm5leHRUb2tlbigpO1xyXG5cdCAgICAgICAgaWYgKHRva2VuLnR5cGUgIT09IDcgLyogUHVuY3R1YXRvciAqLyB8fCB0b2tlbi52YWx1ZSAhPT0gdmFsdWUpIHtcclxuXHQgICAgICAgICAgICB0aGlzLnRocm93VW5leHBlY3RlZFRva2VuKHRva2VuKTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgfTtcclxuXHQgICAgLy8gUXVpZXRseSBleHBlY3QgYSBjb21tYSB3aGVuIGluIHRvbGVyYW50IG1vZGUsIG90aGVyd2lzZSBkZWxlZ2F0ZXMgdG8gZXhwZWN0KCkuXHJcblx0ICAgIFBhcnNlci5wcm90b3R5cGUuZXhwZWN0Q29tbWFTZXBhcmF0b3IgPSBmdW5jdGlvbiAoKSB7XHJcblx0ICAgICAgICBpZiAodGhpcy5jb25maWcudG9sZXJhbnQpIHtcclxuXHQgICAgICAgICAgICB2YXIgdG9rZW4gPSB0aGlzLmxvb2thaGVhZDtcclxuXHQgICAgICAgICAgICBpZiAodG9rZW4udHlwZSA9PT0gNyAvKiBQdW5jdHVhdG9yICovICYmIHRva2VuLnZhbHVlID09PSAnLCcpIHtcclxuXHQgICAgICAgICAgICAgICAgdGhpcy5uZXh0VG9rZW4oKTtcclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgZWxzZSBpZiAodG9rZW4udHlwZSA9PT0gNyAvKiBQdW5jdHVhdG9yICovICYmIHRva2VuLnZhbHVlID09PSAnOycpIHtcclxuXHQgICAgICAgICAgICAgICAgdGhpcy5uZXh0VG9rZW4oKTtcclxuXHQgICAgICAgICAgICAgICAgdGhpcy50b2xlcmF0ZVVuZXhwZWN0ZWRUb2tlbih0b2tlbik7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgIGVsc2Uge1xyXG5cdCAgICAgICAgICAgICAgICB0aGlzLnRvbGVyYXRlVW5leHBlY3RlZFRva2VuKHRva2VuLCBtZXNzYWdlc18xLk1lc3NhZ2VzLlVuZXhwZWN0ZWRUb2tlbik7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgZWxzZSB7XHJcblx0ICAgICAgICAgICAgdGhpcy5leHBlY3QoJywnKTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgfTtcclxuXHQgICAgLy8gRXhwZWN0IHRoZSBuZXh0IHRva2VuIHRvIG1hdGNoIHRoZSBzcGVjaWZpZWQga2V5d29yZC5cclxuXHQgICAgLy8gSWYgbm90LCBhbiBleGNlcHRpb24gd2lsbCBiZSB0aHJvd24uXHJcblx0ICAgIFBhcnNlci5wcm90b3R5cGUuZXhwZWN0S2V5d29yZCA9IGZ1bmN0aW9uIChrZXl3b3JkKSB7XHJcblx0ICAgICAgICB2YXIgdG9rZW4gPSB0aGlzLm5leHRUb2tlbigpO1xyXG5cdCAgICAgICAgaWYgKHRva2VuLnR5cGUgIT09IDQgLyogS2V5d29yZCAqLyB8fCB0b2tlbi52YWx1ZSAhPT0ga2V5d29yZCkge1xyXG5cdCAgICAgICAgICAgIHRoaXMudGhyb3dVbmV4cGVjdGVkVG9rZW4odG9rZW4pO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICB9O1xyXG5cdCAgICAvLyBSZXR1cm4gdHJ1ZSBpZiB0aGUgbmV4dCB0b2tlbiBtYXRjaGVzIHRoZSBzcGVjaWZpZWQgcHVuY3R1YXRvci5cclxuXHQgICAgUGFyc2VyLnByb3RvdHlwZS5tYXRjaCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xyXG5cdCAgICAgICAgcmV0dXJuIHRoaXMubG9va2FoZWFkLnR5cGUgPT09IDcgLyogUHVuY3R1YXRvciAqLyAmJiB0aGlzLmxvb2thaGVhZC52YWx1ZSA9PT0gdmFsdWU7XHJcblx0ICAgIH07XHJcblx0ICAgIC8vIFJldHVybiB0cnVlIGlmIHRoZSBuZXh0IHRva2VuIG1hdGNoZXMgdGhlIHNwZWNpZmllZCBrZXl3b3JkXHJcblx0ICAgIFBhcnNlci5wcm90b3R5cGUubWF0Y2hLZXl3b3JkID0gZnVuY3Rpb24gKGtleXdvcmQpIHtcclxuXHQgICAgICAgIHJldHVybiB0aGlzLmxvb2thaGVhZC50eXBlID09PSA0IC8qIEtleXdvcmQgKi8gJiYgdGhpcy5sb29rYWhlYWQudmFsdWUgPT09IGtleXdvcmQ7XHJcblx0ICAgIH07XHJcblx0ICAgIC8vIFJldHVybiB0cnVlIGlmIHRoZSBuZXh0IHRva2VuIG1hdGNoZXMgdGhlIHNwZWNpZmllZCBjb250ZXh0dWFsIGtleXdvcmRcclxuXHQgICAgLy8gKHdoZXJlIGFuIGlkZW50aWZpZXIgaXMgc29tZXRpbWVzIGEga2V5d29yZCBkZXBlbmRpbmcgb24gdGhlIGNvbnRleHQpXHJcblx0ICAgIFBhcnNlci5wcm90b3R5cGUubWF0Y2hDb250ZXh0dWFsS2V5d29yZCA9IGZ1bmN0aW9uIChrZXl3b3JkKSB7XHJcblx0ICAgICAgICByZXR1cm4gdGhpcy5sb29rYWhlYWQudHlwZSA9PT0gMyAvKiBJZGVudGlmaWVyICovICYmIHRoaXMubG9va2FoZWFkLnZhbHVlID09PSBrZXl3b3JkO1xyXG5cdCAgICB9O1xyXG5cdCAgICAvLyBSZXR1cm4gdHJ1ZSBpZiB0aGUgbmV4dCB0b2tlbiBpcyBhbiBhc3NpZ25tZW50IG9wZXJhdG9yXHJcblx0ICAgIFBhcnNlci5wcm90b3R5cGUubWF0Y2hBc3NpZ24gPSBmdW5jdGlvbiAoKSB7XHJcblx0ICAgICAgICBpZiAodGhpcy5sb29rYWhlYWQudHlwZSAhPT0gNyAvKiBQdW5jdHVhdG9yICovKSB7XHJcblx0ICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgdmFyIG9wID0gdGhpcy5sb29rYWhlYWQudmFsdWU7XHJcblx0ICAgICAgICByZXR1cm4gb3AgPT09ICc9JyB8fFxyXG5cdCAgICAgICAgICAgIG9wID09PSAnKj0nIHx8XHJcblx0ICAgICAgICAgICAgb3AgPT09ICcqKj0nIHx8XHJcblx0ICAgICAgICAgICAgb3AgPT09ICcvPScgfHxcclxuXHQgICAgICAgICAgICBvcCA9PT0gJyU9JyB8fFxyXG5cdCAgICAgICAgICAgIG9wID09PSAnKz0nIHx8XHJcblx0ICAgICAgICAgICAgb3AgPT09ICctPScgfHxcclxuXHQgICAgICAgICAgICBvcCA9PT0gJzw8PScgfHxcclxuXHQgICAgICAgICAgICBvcCA9PT0gJz4+PScgfHxcclxuXHQgICAgICAgICAgICBvcCA9PT0gJz4+Pj0nIHx8XHJcblx0ICAgICAgICAgICAgb3AgPT09ICcmPScgfHxcclxuXHQgICAgICAgICAgICBvcCA9PT0gJ149JyB8fFxyXG5cdCAgICAgICAgICAgIG9wID09PSAnfD0nO1xyXG5cdCAgICB9O1xyXG5cdCAgICAvLyBDb3ZlciBncmFtbWFyIHN1cHBvcnQuXHJcblx0ICAgIC8vXHJcblx0ICAgIC8vIFdoZW4gYW4gYXNzaWdubWVudCBleHByZXNzaW9uIHBvc2l0aW9uIHN0YXJ0cyB3aXRoIGFuIGxlZnQgcGFyZW50aGVzaXMsIHRoZSBkZXRlcm1pbmF0aW9uIG9mIHRoZSB0eXBlXHJcblx0ICAgIC8vIG9mIHRoZSBzeW50YXggaXMgdG8gYmUgZGVmZXJyZWQgYXJiaXRyYXJpbHkgbG9uZyB1bnRpbCB0aGUgZW5kIG9mIHRoZSBwYXJlbnRoZXNlcyBwYWlyIChwbHVzIGEgbG9va2FoZWFkKVxyXG5cdCAgICAvLyBvciB0aGUgZmlyc3QgY29tbWEuIFRoaXMgc2l0dWF0aW9uIGFsc28gZGVmZXJzIHRoZSBkZXRlcm1pbmF0aW9uIG9mIGFsbCB0aGUgZXhwcmVzc2lvbnMgbmVzdGVkIGluIHRoZSBwYWlyLlxyXG5cdCAgICAvL1xyXG5cdCAgICAvLyBUaGVyZSBhcmUgdGhyZWUgcHJvZHVjdGlvbnMgdGhhdCBjYW4gYmUgcGFyc2VkIGluIGEgcGFyZW50aGVzZXMgcGFpciB0aGF0IG5lZWRzIHRvIGJlIGRldGVybWluZWRcclxuXHQgICAgLy8gYWZ0ZXIgdGhlIG91dGVybW9zdCBwYWlyIGlzIGNsb3NlZC4gVGhleSBhcmU6XHJcblx0ICAgIC8vXHJcblx0ICAgIC8vICAgMS4gQXNzaWdubWVudEV4cHJlc3Npb25cclxuXHQgICAgLy8gICAyLiBCaW5kaW5nRWxlbWVudHNcclxuXHQgICAgLy8gICAzLiBBc3NpZ25tZW50VGFyZ2V0c1xyXG5cdCAgICAvL1xyXG5cdCAgICAvLyBJbiBvcmRlciB0byBhdm9pZCBleHBvbmVudGlhbCBiYWNrdHJhY2tpbmcsIHdlIHVzZSB0d28gZmxhZ3MgdG8gZGVub3RlIGlmIHRoZSBwcm9kdWN0aW9uIGNhbiBiZVxyXG5cdCAgICAvLyBiaW5kaW5nIGVsZW1lbnQgb3IgYXNzaWdubWVudCB0YXJnZXQuXHJcblx0ICAgIC8vXHJcblx0ICAgIC8vIFRoZSB0aHJlZSBwcm9kdWN0aW9ucyBoYXZlIHRoZSByZWxhdGlvbnNoaXA6XHJcblx0ICAgIC8vXHJcblx0ICAgIC8vICAgQmluZGluZ0VsZW1lbnRzIOKKhiBBc3NpZ25tZW50VGFyZ2V0cyDiioYgQXNzaWdubWVudEV4cHJlc3Npb25cclxuXHQgICAgLy9cclxuXHQgICAgLy8gd2l0aCBhIHNpbmdsZSBleGNlcHRpb24gdGhhdCBDb3ZlckluaXRpYWxpemVkTmFtZSB3aGVuIHVzZWQgZGlyZWN0bHkgaW4gYW4gRXhwcmVzc2lvbiwgZ2VuZXJhdGVzXHJcblx0ICAgIC8vIGFuIGVhcmx5IGVycm9yLiBUaGVyZWZvcmUsIHdlIG5lZWQgdGhlIHRoaXJkIHN0YXRlLCBmaXJzdENvdmVySW5pdGlhbGl6ZWROYW1lRXJyb3IsIHRvIHRyYWNrIHRoZVxyXG5cdCAgICAvLyBmaXJzdCB1c2FnZSBvZiBDb3ZlckluaXRpYWxpemVkTmFtZSBhbmQgcmVwb3J0IGl0IHdoZW4gd2UgcmVhY2hlZCB0aGUgZW5kIG9mIHRoZSBwYXJlbnRoZXNlcyBwYWlyLlxyXG5cdCAgICAvL1xyXG5cdCAgICAvLyBpc29sYXRlQ292ZXJHcmFtbWFyIGZ1bmN0aW9uIHJ1bnMgdGhlIGdpdmVuIHBhcnNlciBmdW5jdGlvbiB3aXRoIGEgbmV3IGNvdmVyIGdyYW1tYXIgY29udGV4dCwgYW5kIGl0IGRvZXMgbm90XHJcblx0ICAgIC8vIGVmZmVjdCB0aGUgY3VycmVudCBmbGFncy4gVGhpcyBtZWFucyB0aGUgcHJvZHVjdGlvbiB0aGUgcGFyc2VyIHBhcnNlcyBpcyBvbmx5IHVzZWQgYXMgYW4gZXhwcmVzc2lvbi4gVGhlcmVmb3JlXHJcblx0ICAgIC8vIHRoZSBDb3ZlckluaXRpYWxpemVkTmFtZSBjaGVjayBpcyBjb25kdWN0ZWQuXHJcblx0ICAgIC8vXHJcblx0ICAgIC8vIGluaGVyaXRDb3ZlckdyYW1tYXIgZnVuY3Rpb24gcnVucyB0aGUgZ2l2ZW4gcGFyc2UgZnVuY3Rpb24gd2l0aCBhIG5ldyBjb3ZlciBncmFtbWFyIGNvbnRleHQsIGFuZCBpdCBwcm9wYWdhdGVzXHJcblx0ICAgIC8vIHRoZSBmbGFncyBvdXRzaWRlIG9mIHRoZSBwYXJzZXIuIFRoaXMgbWVhbnMgdGhlIHByb2R1Y3Rpb24gdGhlIHBhcnNlciBwYXJzZXMgaXMgdXNlZCBhcyBhIHBhcnQgb2YgYSBwb3RlbnRpYWxcclxuXHQgICAgLy8gcGF0dGVybi4gVGhlIENvdmVySW5pdGlhbGl6ZWROYW1lIGNoZWNrIGlzIGRlZmVycmVkLlxyXG5cdCAgICBQYXJzZXIucHJvdG90eXBlLmlzb2xhdGVDb3ZlckdyYW1tYXIgPSBmdW5jdGlvbiAocGFyc2VGdW5jdGlvbikge1xyXG5cdCAgICAgICAgdmFyIHByZXZpb3VzSXNCaW5kaW5nRWxlbWVudCA9IHRoaXMuY29udGV4dC5pc0JpbmRpbmdFbGVtZW50O1xyXG5cdCAgICAgICAgdmFyIHByZXZpb3VzSXNBc3NpZ25tZW50VGFyZ2V0ID0gdGhpcy5jb250ZXh0LmlzQXNzaWdubWVudFRhcmdldDtcclxuXHQgICAgICAgIHZhciBwcmV2aW91c0ZpcnN0Q292ZXJJbml0aWFsaXplZE5hbWVFcnJvciA9IHRoaXMuY29udGV4dC5maXJzdENvdmVySW5pdGlhbGl6ZWROYW1lRXJyb3I7XHJcblx0ICAgICAgICB0aGlzLmNvbnRleHQuaXNCaW5kaW5nRWxlbWVudCA9IHRydWU7XHJcblx0ICAgICAgICB0aGlzLmNvbnRleHQuaXNBc3NpZ25tZW50VGFyZ2V0ID0gdHJ1ZTtcclxuXHQgICAgICAgIHRoaXMuY29udGV4dC5maXJzdENvdmVySW5pdGlhbGl6ZWROYW1lRXJyb3IgPSBudWxsO1xyXG5cdCAgICAgICAgdmFyIHJlc3VsdCA9IHBhcnNlRnVuY3Rpb24uY2FsbCh0aGlzKTtcclxuXHQgICAgICAgIGlmICh0aGlzLmNvbnRleHQuZmlyc3RDb3ZlckluaXRpYWxpemVkTmFtZUVycm9yICE9PSBudWxsKSB7XHJcblx0ICAgICAgICAgICAgdGhpcy50aHJvd1VuZXhwZWN0ZWRUb2tlbih0aGlzLmNvbnRleHQuZmlyc3RDb3ZlckluaXRpYWxpemVkTmFtZUVycm9yKTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIHRoaXMuY29udGV4dC5pc0JpbmRpbmdFbGVtZW50ID0gcHJldmlvdXNJc0JpbmRpbmdFbGVtZW50O1xyXG5cdCAgICAgICAgdGhpcy5jb250ZXh0LmlzQXNzaWdubWVudFRhcmdldCA9IHByZXZpb3VzSXNBc3NpZ25tZW50VGFyZ2V0O1xyXG5cdCAgICAgICAgdGhpcy5jb250ZXh0LmZpcnN0Q292ZXJJbml0aWFsaXplZE5hbWVFcnJvciA9IHByZXZpb3VzRmlyc3RDb3ZlckluaXRpYWxpemVkTmFtZUVycm9yO1xyXG5cdCAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuXHQgICAgfTtcclxuXHQgICAgUGFyc2VyLnByb3RvdHlwZS5pbmhlcml0Q292ZXJHcmFtbWFyID0gZnVuY3Rpb24gKHBhcnNlRnVuY3Rpb24pIHtcclxuXHQgICAgICAgIHZhciBwcmV2aW91c0lzQmluZGluZ0VsZW1lbnQgPSB0aGlzLmNvbnRleHQuaXNCaW5kaW5nRWxlbWVudDtcclxuXHQgICAgICAgIHZhciBwcmV2aW91c0lzQXNzaWdubWVudFRhcmdldCA9IHRoaXMuY29udGV4dC5pc0Fzc2lnbm1lbnRUYXJnZXQ7XHJcblx0ICAgICAgICB2YXIgcHJldmlvdXNGaXJzdENvdmVySW5pdGlhbGl6ZWROYW1lRXJyb3IgPSB0aGlzLmNvbnRleHQuZmlyc3RDb3ZlckluaXRpYWxpemVkTmFtZUVycm9yO1xyXG5cdCAgICAgICAgdGhpcy5jb250ZXh0LmlzQmluZGluZ0VsZW1lbnQgPSB0cnVlO1xyXG5cdCAgICAgICAgdGhpcy5jb250ZXh0LmlzQXNzaWdubWVudFRhcmdldCA9IHRydWU7XHJcblx0ICAgICAgICB0aGlzLmNvbnRleHQuZmlyc3RDb3ZlckluaXRpYWxpemVkTmFtZUVycm9yID0gbnVsbDtcclxuXHQgICAgICAgIHZhciByZXN1bHQgPSBwYXJzZUZ1bmN0aW9uLmNhbGwodGhpcyk7XHJcblx0ICAgICAgICB0aGlzLmNvbnRleHQuaXNCaW5kaW5nRWxlbWVudCA9IHRoaXMuY29udGV4dC5pc0JpbmRpbmdFbGVtZW50ICYmIHByZXZpb3VzSXNCaW5kaW5nRWxlbWVudDtcclxuXHQgICAgICAgIHRoaXMuY29udGV4dC5pc0Fzc2lnbm1lbnRUYXJnZXQgPSB0aGlzLmNvbnRleHQuaXNBc3NpZ25tZW50VGFyZ2V0ICYmIHByZXZpb3VzSXNBc3NpZ25tZW50VGFyZ2V0O1xyXG5cdCAgICAgICAgdGhpcy5jb250ZXh0LmZpcnN0Q292ZXJJbml0aWFsaXplZE5hbWVFcnJvciA9IHByZXZpb3VzRmlyc3RDb3ZlckluaXRpYWxpemVkTmFtZUVycm9yIHx8IHRoaXMuY29udGV4dC5maXJzdENvdmVySW5pdGlhbGl6ZWROYW1lRXJyb3I7XHJcblx0ICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG5cdCAgICB9O1xyXG5cdCAgICBQYXJzZXIucHJvdG90eXBlLmNvbnN1bWVTZW1pY29sb24gPSBmdW5jdGlvbiAoKSB7XHJcblx0ICAgICAgICBpZiAodGhpcy5tYXRjaCgnOycpKSB7XHJcblx0ICAgICAgICAgICAgdGhpcy5uZXh0VG9rZW4oKTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIGVsc2UgaWYgKCF0aGlzLmhhc0xpbmVUZXJtaW5hdG9yKSB7XHJcblx0ICAgICAgICAgICAgaWYgKHRoaXMubG9va2FoZWFkLnR5cGUgIT09IDIgLyogRU9GICovICYmICF0aGlzLm1hdGNoKCd9JykpIHtcclxuXHQgICAgICAgICAgICAgICAgdGhpcy50aHJvd1VuZXhwZWN0ZWRUb2tlbih0aGlzLmxvb2thaGVhZCk7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgIHRoaXMubGFzdE1hcmtlci5pbmRleCA9IHRoaXMuc3RhcnRNYXJrZXIuaW5kZXg7XHJcblx0ICAgICAgICAgICAgdGhpcy5sYXN0TWFya2VyLmxpbmUgPSB0aGlzLnN0YXJ0TWFya2VyLmxpbmU7XHJcblx0ICAgICAgICAgICAgdGhpcy5sYXN0TWFya2VyLmNvbHVtbiA9IHRoaXMuc3RhcnRNYXJrZXIuY29sdW1uO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICB9O1xyXG5cdCAgICAvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1wcmltYXJ5LWV4cHJlc3Npb25cclxuXHQgICAgUGFyc2VyLnByb3RvdHlwZS5wYXJzZVByaW1hcnlFeHByZXNzaW9uID0gZnVuY3Rpb24gKCkge1xyXG5cdCAgICAgICAgdmFyIG5vZGUgPSB0aGlzLmNyZWF0ZU5vZGUoKTtcclxuXHQgICAgICAgIHZhciBleHByO1xyXG5cdCAgICAgICAgdmFyIHRva2VuLCByYXc7XHJcblx0ICAgICAgICBzd2l0Y2ggKHRoaXMubG9va2FoZWFkLnR5cGUpIHtcclxuXHQgICAgICAgICAgICBjYXNlIDMgLyogSWRlbnRpZmllciAqLzpcclxuXHQgICAgICAgICAgICAgICAgaWYgKCh0aGlzLmNvbnRleHQuaXNNb2R1bGUgfHwgdGhpcy5jb250ZXh0LmF3YWl0KSAmJiB0aGlzLmxvb2thaGVhZC52YWx1ZSA9PT0gJ2F3YWl0Jykge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgdGhpcy50b2xlcmF0ZVVuZXhwZWN0ZWRUb2tlbih0aGlzLmxvb2thaGVhZCk7XHJcblx0ICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgZXhwciA9IHRoaXMubWF0Y2hBc3luY0Z1bmN0aW9uKCkgPyB0aGlzLnBhcnNlRnVuY3Rpb25FeHByZXNzaW9uKCkgOiB0aGlzLmZpbmFsaXplKG5vZGUsIG5ldyBOb2RlLklkZW50aWZpZXIodGhpcy5uZXh0VG9rZW4oKS52YWx1ZSkpO1xyXG5cdCAgICAgICAgICAgICAgICBicmVhaztcclxuXHQgICAgICAgICAgICBjYXNlIDYgLyogTnVtZXJpY0xpdGVyYWwgKi86XHJcblx0ICAgICAgICAgICAgY2FzZSA4IC8qIFN0cmluZ0xpdGVyYWwgKi86XHJcblx0ICAgICAgICAgICAgICAgIGlmICh0aGlzLmNvbnRleHQuc3RyaWN0ICYmIHRoaXMubG9va2FoZWFkLm9jdGFsKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICB0aGlzLnRvbGVyYXRlVW5leHBlY3RlZFRva2VuKHRoaXMubG9va2FoZWFkLCBtZXNzYWdlc18xLk1lc3NhZ2VzLlN0cmljdE9jdGFsTGl0ZXJhbCk7XHJcblx0ICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgdGhpcy5jb250ZXh0LmlzQXNzaWdubWVudFRhcmdldCA9IGZhbHNlO1xyXG5cdCAgICAgICAgICAgICAgICB0aGlzLmNvbnRleHQuaXNCaW5kaW5nRWxlbWVudCA9IGZhbHNlO1xyXG5cdCAgICAgICAgICAgICAgICB0b2tlbiA9IHRoaXMubmV4dFRva2VuKCk7XHJcblx0ICAgICAgICAgICAgICAgIHJhdyA9IHRoaXMuZ2V0VG9rZW5SYXcodG9rZW4pO1xyXG5cdCAgICAgICAgICAgICAgICBleHByID0gdGhpcy5maW5hbGl6ZShub2RlLCBuZXcgTm9kZS5MaXRlcmFsKHRva2VuLnZhbHVlLCByYXcpKTtcclxuXHQgICAgICAgICAgICAgICAgYnJlYWs7XHJcblx0ICAgICAgICAgICAgY2FzZSAxIC8qIEJvb2xlYW5MaXRlcmFsICovOlxyXG5cdCAgICAgICAgICAgICAgICB0aGlzLmNvbnRleHQuaXNBc3NpZ25tZW50VGFyZ2V0ID0gZmFsc2U7XHJcblx0ICAgICAgICAgICAgICAgIHRoaXMuY29udGV4dC5pc0JpbmRpbmdFbGVtZW50ID0gZmFsc2U7XHJcblx0ICAgICAgICAgICAgICAgIHRva2VuID0gdGhpcy5uZXh0VG9rZW4oKTtcclxuXHQgICAgICAgICAgICAgICAgcmF3ID0gdGhpcy5nZXRUb2tlblJhdyh0b2tlbik7XHJcblx0ICAgICAgICAgICAgICAgIGV4cHIgPSB0aGlzLmZpbmFsaXplKG5vZGUsIG5ldyBOb2RlLkxpdGVyYWwodG9rZW4udmFsdWUgPT09ICd0cnVlJywgcmF3KSk7XHJcblx0ICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cdCAgICAgICAgICAgIGNhc2UgNSAvKiBOdWxsTGl0ZXJhbCAqLzpcclxuXHQgICAgICAgICAgICAgICAgdGhpcy5jb250ZXh0LmlzQXNzaWdubWVudFRhcmdldCA9IGZhbHNlO1xyXG5cdCAgICAgICAgICAgICAgICB0aGlzLmNvbnRleHQuaXNCaW5kaW5nRWxlbWVudCA9IGZhbHNlO1xyXG5cdCAgICAgICAgICAgICAgICB0b2tlbiA9IHRoaXMubmV4dFRva2VuKCk7XHJcblx0ICAgICAgICAgICAgICAgIHJhdyA9IHRoaXMuZ2V0VG9rZW5SYXcodG9rZW4pO1xyXG5cdCAgICAgICAgICAgICAgICBleHByID0gdGhpcy5maW5hbGl6ZShub2RlLCBuZXcgTm9kZS5MaXRlcmFsKG51bGwsIHJhdykpO1xyXG5cdCAgICAgICAgICAgICAgICBicmVhaztcclxuXHQgICAgICAgICAgICBjYXNlIDEwIC8qIFRlbXBsYXRlICovOlxyXG5cdCAgICAgICAgICAgICAgICBleHByID0gdGhpcy5wYXJzZVRlbXBsYXRlTGl0ZXJhbCgpO1xyXG5cdCAgICAgICAgICAgICAgICBicmVhaztcclxuXHQgICAgICAgICAgICBjYXNlIDcgLyogUHVuY3R1YXRvciAqLzpcclxuXHQgICAgICAgICAgICAgICAgc3dpdGNoICh0aGlzLmxvb2thaGVhZC52YWx1ZSkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgY2FzZSAnKCc6XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jb250ZXh0LmlzQmluZGluZ0VsZW1lbnQgPSBmYWxzZTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBleHByID0gdGhpcy5pbmhlcml0Q292ZXJHcmFtbWFyKHRoaXMucGFyc2VHcm91cEV4cHJlc3Npb24pO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgY2FzZSAnWyc6XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgZXhwciA9IHRoaXMuaW5oZXJpdENvdmVyR3JhbW1hcih0aGlzLnBhcnNlQXJyYXlJbml0aWFsaXplcik7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcblx0ICAgICAgICAgICAgICAgICAgICBjYXNlICd7JzpcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBleHByID0gdGhpcy5pbmhlcml0Q292ZXJHcmFtbWFyKHRoaXMucGFyc2VPYmplY3RJbml0aWFsaXplcik7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcblx0ICAgICAgICAgICAgICAgICAgICBjYXNlICcvJzpcclxuXHQgICAgICAgICAgICAgICAgICAgIGNhc2UgJy89JzpcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbnRleHQuaXNBc3NpZ25tZW50VGFyZ2V0ID0gZmFsc2U7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jb250ZXh0LmlzQmluZGluZ0VsZW1lbnQgPSBmYWxzZTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnNjYW5uZXIuaW5kZXggPSB0aGlzLnN0YXJ0TWFya2VyLmluZGV4O1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHRva2VuID0gdGhpcy5uZXh0UmVnZXhUb2tlbigpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJhdyA9IHRoaXMuZ2V0VG9rZW5SYXcodG9rZW4pO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGV4cHIgPSB0aGlzLmZpbmFsaXplKG5vZGUsIG5ldyBOb2RlLlJlZ2V4TGl0ZXJhbCh0b2tlbi5yZWdleCwgcmF3LCB0b2tlbi5wYXR0ZXJuLCB0b2tlbi5mbGFncykpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBleHByID0gdGhpcy50aHJvd1VuZXhwZWN0ZWRUb2tlbih0aGlzLm5leHRUb2tlbigpKTtcclxuXHQgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICBicmVhaztcclxuXHQgICAgICAgICAgICBjYXNlIDQgLyogS2V5d29yZCAqLzpcclxuXHQgICAgICAgICAgICAgICAgaWYgKCF0aGlzLmNvbnRleHQuc3RyaWN0ICYmIHRoaXMuY29udGV4dC5hbGxvd1lpZWxkICYmIHRoaXMubWF0Y2hLZXl3b3JkKCd5aWVsZCcpKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICBleHByID0gdGhpcy5wYXJzZUlkZW50aWZpZXJOYW1lKCk7XHJcblx0ICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgZWxzZSBpZiAoIXRoaXMuY29udGV4dC5zdHJpY3QgJiYgdGhpcy5tYXRjaEtleXdvcmQoJ2xldCcpKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICBleHByID0gdGhpcy5maW5hbGl6ZShub2RlLCBuZXcgTm9kZS5JZGVudGlmaWVyKHRoaXMubmV4dFRva2VuKCkudmFsdWUpKTtcclxuXHQgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICBlbHNlIHtcclxuXHQgICAgICAgICAgICAgICAgICAgIHRoaXMuY29udGV4dC5pc0Fzc2lnbm1lbnRUYXJnZXQgPSBmYWxzZTtcclxuXHQgICAgICAgICAgICAgICAgICAgIHRoaXMuY29udGV4dC5pc0JpbmRpbmdFbGVtZW50ID0gZmFsc2U7XHJcblx0ICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5tYXRjaEtleXdvcmQoJ2Z1bmN0aW9uJykpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBleHByID0gdGhpcy5wYXJzZUZ1bmN0aW9uRXhwcmVzc2lvbigpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5tYXRjaEtleXdvcmQoJ3RoaXMnKSkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubmV4dFRva2VuKCk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgZXhwciA9IHRoaXMuZmluYWxpemUobm9kZSwgbmV3IE5vZGUuVGhpc0V4cHJlc3Npb24oKSk7XHJcblx0ICAgICAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICh0aGlzLm1hdGNoS2V5d29yZCgnY2xhc3MnKSkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGV4cHIgPSB0aGlzLnBhcnNlQ2xhc3NFeHByZXNzaW9uKCk7XHJcblx0ICAgICAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBleHByID0gdGhpcy50aHJvd1VuZXhwZWN0ZWRUb2tlbih0aGlzLm5leHRUb2tlbigpKTtcclxuXHQgICAgICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICBicmVhaztcclxuXHQgICAgICAgICAgICBkZWZhdWx0OlxyXG5cdCAgICAgICAgICAgICAgICBleHByID0gdGhpcy50aHJvd1VuZXhwZWN0ZWRUb2tlbih0aGlzLm5leHRUb2tlbigpKTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIHJldHVybiBleHByO1xyXG5cdCAgICB9O1xyXG5cdCAgICAvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1hcnJheS1pbml0aWFsaXplclxyXG5cdCAgICBQYXJzZXIucHJvdG90eXBlLnBhcnNlU3ByZWFkRWxlbWVudCA9IGZ1bmN0aW9uICgpIHtcclxuXHQgICAgICAgIHZhciBub2RlID0gdGhpcy5jcmVhdGVOb2RlKCk7XHJcblx0ICAgICAgICB0aGlzLmV4cGVjdCgnLi4uJyk7XHJcblx0ICAgICAgICB2YXIgYXJnID0gdGhpcy5pbmhlcml0Q292ZXJHcmFtbWFyKHRoaXMucGFyc2VBc3NpZ25tZW50RXhwcmVzc2lvbik7XHJcblx0ICAgICAgICByZXR1cm4gdGhpcy5maW5hbGl6ZShub2RlLCBuZXcgTm9kZS5TcHJlYWRFbGVtZW50KGFyZykpO1xyXG5cdCAgICB9O1xyXG5cdCAgICBQYXJzZXIucHJvdG90eXBlLnBhcnNlQXJyYXlJbml0aWFsaXplciA9IGZ1bmN0aW9uICgpIHtcclxuXHQgICAgICAgIHZhciBub2RlID0gdGhpcy5jcmVhdGVOb2RlKCk7XHJcblx0ICAgICAgICB2YXIgZWxlbWVudHMgPSBbXTtcclxuXHQgICAgICAgIHRoaXMuZXhwZWN0KCdbJyk7XHJcblx0ICAgICAgICB3aGlsZSAoIXRoaXMubWF0Y2goJ10nKSkge1xyXG5cdCAgICAgICAgICAgIGlmICh0aGlzLm1hdGNoKCcsJykpIHtcclxuXHQgICAgICAgICAgICAgICAgdGhpcy5uZXh0VG9rZW4oKTtcclxuXHQgICAgICAgICAgICAgICAgZWxlbWVudHMucHVzaChudWxsKTtcclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5tYXRjaCgnLi4uJykpIHtcclxuXHQgICAgICAgICAgICAgICAgdmFyIGVsZW1lbnQgPSB0aGlzLnBhcnNlU3ByZWFkRWxlbWVudCgpO1xyXG5cdCAgICAgICAgICAgICAgICBpZiAoIXRoaXMubWF0Y2goJ10nKSkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgdGhpcy5jb250ZXh0LmlzQXNzaWdubWVudFRhcmdldCA9IGZhbHNlO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgdGhpcy5jb250ZXh0LmlzQmluZGluZ0VsZW1lbnQgPSBmYWxzZTtcclxuXHQgICAgICAgICAgICAgICAgICAgIHRoaXMuZXhwZWN0KCcsJyk7XHJcblx0ICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgZWxlbWVudHMucHVzaChlbGVtZW50KTtcclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgZWxzZSB7XHJcblx0ICAgICAgICAgICAgICAgIGVsZW1lbnRzLnB1c2godGhpcy5pbmhlcml0Q292ZXJHcmFtbWFyKHRoaXMucGFyc2VBc3NpZ25tZW50RXhwcmVzc2lvbikpO1xyXG5cdCAgICAgICAgICAgICAgICBpZiAoIXRoaXMubWF0Y2goJ10nKSkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgdGhpcy5leHBlY3QoJywnKTtcclxuXHQgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIHRoaXMuZXhwZWN0KCddJyk7XHJcblx0ICAgICAgICByZXR1cm4gdGhpcy5maW5hbGl6ZShub2RlLCBuZXcgTm9kZS5BcnJheUV4cHJlc3Npb24oZWxlbWVudHMpKTtcclxuXHQgICAgfTtcclxuXHQgICAgLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtb2JqZWN0LWluaXRpYWxpemVyXHJcblx0ICAgIFBhcnNlci5wcm90b3R5cGUucGFyc2VQcm9wZXJ0eU1ldGhvZCA9IGZ1bmN0aW9uIChwYXJhbXMpIHtcclxuXHQgICAgICAgIHRoaXMuY29udGV4dC5pc0Fzc2lnbm1lbnRUYXJnZXQgPSBmYWxzZTtcclxuXHQgICAgICAgIHRoaXMuY29udGV4dC5pc0JpbmRpbmdFbGVtZW50ID0gZmFsc2U7XHJcblx0ICAgICAgICB2YXIgcHJldmlvdXNTdHJpY3QgPSB0aGlzLmNvbnRleHQuc3RyaWN0O1xyXG5cdCAgICAgICAgdmFyIHByZXZpb3VzQWxsb3dTdHJpY3REaXJlY3RpdmUgPSB0aGlzLmNvbnRleHQuYWxsb3dTdHJpY3REaXJlY3RpdmU7XHJcblx0ICAgICAgICB0aGlzLmNvbnRleHQuYWxsb3dTdHJpY3REaXJlY3RpdmUgPSBwYXJhbXMuc2ltcGxlO1xyXG5cdCAgICAgICAgdmFyIGJvZHkgPSB0aGlzLmlzb2xhdGVDb3ZlckdyYW1tYXIodGhpcy5wYXJzZUZ1bmN0aW9uU291cmNlRWxlbWVudHMpO1xyXG5cdCAgICAgICAgaWYgKHRoaXMuY29udGV4dC5zdHJpY3QgJiYgcGFyYW1zLmZpcnN0UmVzdHJpY3RlZCkge1xyXG5cdCAgICAgICAgICAgIHRoaXMudG9sZXJhdGVVbmV4cGVjdGVkVG9rZW4ocGFyYW1zLmZpcnN0UmVzdHJpY3RlZCwgcGFyYW1zLm1lc3NhZ2UpO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgaWYgKHRoaXMuY29udGV4dC5zdHJpY3QgJiYgcGFyYW1zLnN0cmljdGVkKSB7XHJcblx0ICAgICAgICAgICAgdGhpcy50b2xlcmF0ZVVuZXhwZWN0ZWRUb2tlbihwYXJhbXMuc3RyaWN0ZWQsIHBhcmFtcy5tZXNzYWdlKTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIHRoaXMuY29udGV4dC5zdHJpY3QgPSBwcmV2aW91c1N0cmljdDtcclxuXHQgICAgICAgIHRoaXMuY29udGV4dC5hbGxvd1N0cmljdERpcmVjdGl2ZSA9IHByZXZpb3VzQWxsb3dTdHJpY3REaXJlY3RpdmU7XHJcblx0ICAgICAgICByZXR1cm4gYm9keTtcclxuXHQgICAgfTtcclxuXHQgICAgUGFyc2VyLnByb3RvdHlwZS5wYXJzZVByb3BlcnR5TWV0aG9kRnVuY3Rpb24gPSBmdW5jdGlvbiAoKSB7XHJcblx0ICAgICAgICB2YXIgaXNHZW5lcmF0b3IgPSBmYWxzZTtcclxuXHQgICAgICAgIHZhciBub2RlID0gdGhpcy5jcmVhdGVOb2RlKCk7XHJcblx0ICAgICAgICB2YXIgcHJldmlvdXNBbGxvd1lpZWxkID0gdGhpcy5jb250ZXh0LmFsbG93WWllbGQ7XHJcblx0ICAgICAgICB0aGlzLmNvbnRleHQuYWxsb3dZaWVsZCA9IGZhbHNlO1xyXG5cdCAgICAgICAgdmFyIHBhcmFtcyA9IHRoaXMucGFyc2VGb3JtYWxQYXJhbWV0ZXJzKCk7XHJcblx0ICAgICAgICB2YXIgbWV0aG9kID0gdGhpcy5wYXJzZVByb3BlcnR5TWV0aG9kKHBhcmFtcyk7XHJcblx0ICAgICAgICB0aGlzLmNvbnRleHQuYWxsb3dZaWVsZCA9IHByZXZpb3VzQWxsb3dZaWVsZDtcclxuXHQgICAgICAgIHJldHVybiB0aGlzLmZpbmFsaXplKG5vZGUsIG5ldyBOb2RlLkZ1bmN0aW9uRXhwcmVzc2lvbihudWxsLCBwYXJhbXMucGFyYW1zLCBtZXRob2QsIGlzR2VuZXJhdG9yKSk7XHJcblx0ICAgIH07XHJcblx0ICAgIFBhcnNlci5wcm90b3R5cGUucGFyc2VQcm9wZXJ0eU1ldGhvZEFzeW5jRnVuY3Rpb24gPSBmdW5jdGlvbiAoKSB7XHJcblx0ICAgICAgICB2YXIgbm9kZSA9IHRoaXMuY3JlYXRlTm9kZSgpO1xyXG5cdCAgICAgICAgdmFyIHByZXZpb3VzQWxsb3dZaWVsZCA9IHRoaXMuY29udGV4dC5hbGxvd1lpZWxkO1xyXG5cdCAgICAgICAgdmFyIHByZXZpb3VzQXdhaXQgPSB0aGlzLmNvbnRleHQuYXdhaXQ7XHJcblx0ICAgICAgICB0aGlzLmNvbnRleHQuYWxsb3dZaWVsZCA9IGZhbHNlO1xyXG5cdCAgICAgICAgdGhpcy5jb250ZXh0LmF3YWl0ID0gdHJ1ZTtcclxuXHQgICAgICAgIHZhciBwYXJhbXMgPSB0aGlzLnBhcnNlRm9ybWFsUGFyYW1ldGVycygpO1xyXG5cdCAgICAgICAgdmFyIG1ldGhvZCA9IHRoaXMucGFyc2VQcm9wZXJ0eU1ldGhvZChwYXJhbXMpO1xyXG5cdCAgICAgICAgdGhpcy5jb250ZXh0LmFsbG93WWllbGQgPSBwcmV2aW91c0FsbG93WWllbGQ7XHJcblx0ICAgICAgICB0aGlzLmNvbnRleHQuYXdhaXQgPSBwcmV2aW91c0F3YWl0O1xyXG5cdCAgICAgICAgcmV0dXJuIHRoaXMuZmluYWxpemUobm9kZSwgbmV3IE5vZGUuQXN5bmNGdW5jdGlvbkV4cHJlc3Npb24obnVsbCwgcGFyYW1zLnBhcmFtcywgbWV0aG9kKSk7XHJcblx0ICAgIH07XHJcblx0ICAgIFBhcnNlci5wcm90b3R5cGUucGFyc2VPYmplY3RQcm9wZXJ0eUtleSA9IGZ1bmN0aW9uICgpIHtcclxuXHQgICAgICAgIHZhciBub2RlID0gdGhpcy5jcmVhdGVOb2RlKCk7XHJcblx0ICAgICAgICB2YXIgdG9rZW4gPSB0aGlzLm5leHRUb2tlbigpO1xyXG5cdCAgICAgICAgdmFyIGtleTtcclxuXHQgICAgICAgIHN3aXRjaCAodG9rZW4udHlwZSkge1xyXG5cdCAgICAgICAgICAgIGNhc2UgOCAvKiBTdHJpbmdMaXRlcmFsICovOlxyXG5cdCAgICAgICAgICAgIGNhc2UgNiAvKiBOdW1lcmljTGl0ZXJhbCAqLzpcclxuXHQgICAgICAgICAgICAgICAgaWYgKHRoaXMuY29udGV4dC5zdHJpY3QgJiYgdG9rZW4ub2N0YWwpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgIHRoaXMudG9sZXJhdGVVbmV4cGVjdGVkVG9rZW4odG9rZW4sIG1lc3NhZ2VzXzEuTWVzc2FnZXMuU3RyaWN0T2N0YWxMaXRlcmFsKTtcclxuXHQgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICB2YXIgcmF3ID0gdGhpcy5nZXRUb2tlblJhdyh0b2tlbik7XHJcblx0ICAgICAgICAgICAgICAgIGtleSA9IHRoaXMuZmluYWxpemUobm9kZSwgbmV3IE5vZGUuTGl0ZXJhbCh0b2tlbi52YWx1ZSwgcmF3KSk7XHJcblx0ICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cdCAgICAgICAgICAgIGNhc2UgMyAvKiBJZGVudGlmaWVyICovOlxyXG5cdCAgICAgICAgICAgIGNhc2UgMSAvKiBCb29sZWFuTGl0ZXJhbCAqLzpcclxuXHQgICAgICAgICAgICBjYXNlIDUgLyogTnVsbExpdGVyYWwgKi86XHJcblx0ICAgICAgICAgICAgY2FzZSA0IC8qIEtleXdvcmQgKi86XHJcblx0ICAgICAgICAgICAgICAgIGtleSA9IHRoaXMuZmluYWxpemUobm9kZSwgbmV3IE5vZGUuSWRlbnRpZmllcih0b2tlbi52YWx1ZSkpO1xyXG5cdCAgICAgICAgICAgICAgICBicmVhaztcclxuXHQgICAgICAgICAgICBjYXNlIDcgLyogUHVuY3R1YXRvciAqLzpcclxuXHQgICAgICAgICAgICAgICAgaWYgKHRva2VuLnZhbHVlID09PSAnWycpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgIGtleSA9IHRoaXMuaXNvbGF0ZUNvdmVyR3JhbW1hcih0aGlzLnBhcnNlQXNzaWdubWVudEV4cHJlc3Npb24pO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgdGhpcy5leHBlY3QoJ10nKTtcclxuXHQgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICBlbHNlIHtcclxuXHQgICAgICAgICAgICAgICAgICAgIGtleSA9IHRoaXMudGhyb3dVbmV4cGVjdGVkVG9rZW4odG9rZW4pO1xyXG5cdCAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cdCAgICAgICAgICAgIGRlZmF1bHQ6XHJcblx0ICAgICAgICAgICAgICAgIGtleSA9IHRoaXMudGhyb3dVbmV4cGVjdGVkVG9rZW4odG9rZW4pO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgcmV0dXJuIGtleTtcclxuXHQgICAgfTtcclxuXHQgICAgUGFyc2VyLnByb3RvdHlwZS5pc1Byb3BlcnR5S2V5ID0gZnVuY3Rpb24gKGtleSwgdmFsdWUpIHtcclxuXHQgICAgICAgIHJldHVybiAoa2V5LnR5cGUgPT09IHN5bnRheF8xLlN5bnRheC5JZGVudGlmaWVyICYmIGtleS5uYW1lID09PSB2YWx1ZSkgfHxcclxuXHQgICAgICAgICAgICAoa2V5LnR5cGUgPT09IHN5bnRheF8xLlN5bnRheC5MaXRlcmFsICYmIGtleS52YWx1ZSA9PT0gdmFsdWUpO1xyXG5cdCAgICB9O1xyXG5cdCAgICBQYXJzZXIucHJvdG90eXBlLnBhcnNlT2JqZWN0UHJvcGVydHkgPSBmdW5jdGlvbiAoaGFzUHJvdG8pIHtcclxuXHQgICAgICAgIHZhciBub2RlID0gdGhpcy5jcmVhdGVOb2RlKCk7XHJcblx0ICAgICAgICB2YXIgdG9rZW4gPSB0aGlzLmxvb2thaGVhZDtcclxuXHQgICAgICAgIHZhciBraW5kO1xyXG5cdCAgICAgICAgdmFyIGtleSA9IG51bGw7XHJcblx0ICAgICAgICB2YXIgdmFsdWUgPSBudWxsO1xyXG5cdCAgICAgICAgdmFyIGNvbXB1dGVkID0gZmFsc2U7XHJcblx0ICAgICAgICB2YXIgbWV0aG9kID0gZmFsc2U7XHJcblx0ICAgICAgICB2YXIgc2hvcnRoYW5kID0gZmFsc2U7XHJcblx0ICAgICAgICB2YXIgaXNBc3luYyA9IGZhbHNlO1xyXG5cdCAgICAgICAgaWYgKHRva2VuLnR5cGUgPT09IDMgLyogSWRlbnRpZmllciAqLykge1xyXG5cdCAgICAgICAgICAgIHZhciBpZCA9IHRva2VuLnZhbHVlO1xyXG5cdCAgICAgICAgICAgIHRoaXMubmV4dFRva2VuKCk7XHJcblx0ICAgICAgICAgICAgY29tcHV0ZWQgPSB0aGlzLm1hdGNoKCdbJyk7XHJcblx0ICAgICAgICAgICAgaXNBc3luYyA9ICF0aGlzLmhhc0xpbmVUZXJtaW5hdG9yICYmIChpZCA9PT0gJ2FzeW5jJykgJiZcclxuXHQgICAgICAgICAgICAgICAgIXRoaXMubWF0Y2goJzonKSAmJiAhdGhpcy5tYXRjaCgnKCcpICYmICF0aGlzLm1hdGNoKCcqJyk7XHJcblx0ICAgICAgICAgICAga2V5ID0gaXNBc3luYyA/IHRoaXMucGFyc2VPYmplY3RQcm9wZXJ0eUtleSgpIDogdGhpcy5maW5hbGl6ZShub2RlLCBuZXcgTm9kZS5JZGVudGlmaWVyKGlkKSk7XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICBlbHNlIGlmICh0aGlzLm1hdGNoKCcqJykpIHtcclxuXHQgICAgICAgICAgICB0aGlzLm5leHRUb2tlbigpO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgZWxzZSB7XHJcblx0ICAgICAgICAgICAgY29tcHV0ZWQgPSB0aGlzLm1hdGNoKCdbJyk7XHJcblx0ICAgICAgICAgICAga2V5ID0gdGhpcy5wYXJzZU9iamVjdFByb3BlcnR5S2V5KCk7XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICB2YXIgbG9va2FoZWFkUHJvcGVydHlLZXkgPSB0aGlzLnF1YWxpZmllZFByb3BlcnR5TmFtZSh0aGlzLmxvb2thaGVhZCk7XHJcblx0ICAgICAgICBpZiAodG9rZW4udHlwZSA9PT0gMyAvKiBJZGVudGlmaWVyICovICYmICFpc0FzeW5jICYmIHRva2VuLnZhbHVlID09PSAnZ2V0JyAmJiBsb29rYWhlYWRQcm9wZXJ0eUtleSkge1xyXG5cdCAgICAgICAgICAgIGtpbmQgPSAnZ2V0JztcclxuXHQgICAgICAgICAgICBjb21wdXRlZCA9IHRoaXMubWF0Y2goJ1snKTtcclxuXHQgICAgICAgICAgICBrZXkgPSB0aGlzLnBhcnNlT2JqZWN0UHJvcGVydHlLZXkoKTtcclxuXHQgICAgICAgICAgICB0aGlzLmNvbnRleHQuYWxsb3dZaWVsZCA9IGZhbHNlO1xyXG5cdCAgICAgICAgICAgIHZhbHVlID0gdGhpcy5wYXJzZUdldHRlck1ldGhvZCgpO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgZWxzZSBpZiAodG9rZW4udHlwZSA9PT0gMyAvKiBJZGVudGlmaWVyICovICYmICFpc0FzeW5jICYmIHRva2VuLnZhbHVlID09PSAnc2V0JyAmJiBsb29rYWhlYWRQcm9wZXJ0eUtleSkge1xyXG5cdCAgICAgICAgICAgIGtpbmQgPSAnc2V0JztcclxuXHQgICAgICAgICAgICBjb21wdXRlZCA9IHRoaXMubWF0Y2goJ1snKTtcclxuXHQgICAgICAgICAgICBrZXkgPSB0aGlzLnBhcnNlT2JqZWN0UHJvcGVydHlLZXkoKTtcclxuXHQgICAgICAgICAgICB2YWx1ZSA9IHRoaXMucGFyc2VTZXR0ZXJNZXRob2QoKTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIGVsc2UgaWYgKHRva2VuLnR5cGUgPT09IDcgLyogUHVuY3R1YXRvciAqLyAmJiB0b2tlbi52YWx1ZSA9PT0gJyonICYmIGxvb2thaGVhZFByb3BlcnR5S2V5KSB7XHJcblx0ICAgICAgICAgICAga2luZCA9ICdpbml0JztcclxuXHQgICAgICAgICAgICBjb21wdXRlZCA9IHRoaXMubWF0Y2goJ1snKTtcclxuXHQgICAgICAgICAgICBrZXkgPSB0aGlzLnBhcnNlT2JqZWN0UHJvcGVydHlLZXkoKTtcclxuXHQgICAgICAgICAgICB2YWx1ZSA9IHRoaXMucGFyc2VHZW5lcmF0b3JNZXRob2QoKTtcclxuXHQgICAgICAgICAgICBtZXRob2QgPSB0cnVlO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgZWxzZSB7XHJcblx0ICAgICAgICAgICAgaWYgKCFrZXkpIHtcclxuXHQgICAgICAgICAgICAgICAgdGhpcy50aHJvd1VuZXhwZWN0ZWRUb2tlbih0aGlzLmxvb2thaGVhZCk7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgIGtpbmQgPSAnaW5pdCc7XHJcblx0ICAgICAgICAgICAgaWYgKHRoaXMubWF0Y2goJzonKSAmJiAhaXNBc3luYykge1xyXG5cdCAgICAgICAgICAgICAgICBpZiAoIWNvbXB1dGVkICYmIHRoaXMuaXNQcm9wZXJ0eUtleShrZXksICdfX3Byb3RvX18nKSkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKGhhc1Byb3RvLnZhbHVlKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy50b2xlcmF0ZUVycm9yKG1lc3NhZ2VzXzEuTWVzc2FnZXMuRHVwbGljYXRlUHJvdG9Qcm9wZXJ0eSk7XHJcblx0ICAgICAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgICAgICBoYXNQcm90by52YWx1ZSA9IHRydWU7XHJcblx0ICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgdGhpcy5uZXh0VG9rZW4oKTtcclxuXHQgICAgICAgICAgICAgICAgdmFsdWUgPSB0aGlzLmluaGVyaXRDb3ZlckdyYW1tYXIodGhpcy5wYXJzZUFzc2lnbm1lbnRFeHByZXNzaW9uKTtcclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5tYXRjaCgnKCcpKSB7XHJcblx0ICAgICAgICAgICAgICAgIHZhbHVlID0gaXNBc3luYyA/IHRoaXMucGFyc2VQcm9wZXJ0eU1ldGhvZEFzeW5jRnVuY3Rpb24oKSA6IHRoaXMucGFyc2VQcm9wZXJ0eU1ldGhvZEZ1bmN0aW9uKCk7XHJcblx0ICAgICAgICAgICAgICAgIG1ldGhvZCA9IHRydWU7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgIGVsc2UgaWYgKHRva2VuLnR5cGUgPT09IDMgLyogSWRlbnRpZmllciAqLykge1xyXG5cdCAgICAgICAgICAgICAgICB2YXIgaWQgPSB0aGlzLmZpbmFsaXplKG5vZGUsIG5ldyBOb2RlLklkZW50aWZpZXIodG9rZW4udmFsdWUpKTtcclxuXHQgICAgICAgICAgICAgICAgaWYgKHRoaXMubWF0Y2goJz0nKSkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgdGhpcy5jb250ZXh0LmZpcnN0Q292ZXJJbml0aWFsaXplZE5hbWVFcnJvciA9IHRoaXMubG9va2FoZWFkO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgdGhpcy5uZXh0VG9rZW4oKTtcclxuXHQgICAgICAgICAgICAgICAgICAgIHNob3J0aGFuZCA9IHRydWU7XHJcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgaW5pdCA9IHRoaXMuaXNvbGF0ZUNvdmVyR3JhbW1hcih0aGlzLnBhcnNlQXNzaWdubWVudEV4cHJlc3Npb24pO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSB0aGlzLmZpbmFsaXplKG5vZGUsIG5ldyBOb2RlLkFzc2lnbm1lbnRQYXR0ZXJuKGlkLCBpbml0KSk7XHJcblx0ICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgZWxzZSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICBzaG9ydGhhbmQgPSB0cnVlO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBpZDtcclxuXHQgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICBlbHNlIHtcclxuXHQgICAgICAgICAgICAgICAgdGhpcy50aHJvd1VuZXhwZWN0ZWRUb2tlbih0aGlzLm5leHRUb2tlbigpKTtcclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICByZXR1cm4gdGhpcy5maW5hbGl6ZShub2RlLCBuZXcgTm9kZS5Qcm9wZXJ0eShraW5kLCBrZXksIGNvbXB1dGVkLCB2YWx1ZSwgbWV0aG9kLCBzaG9ydGhhbmQpKTtcclxuXHQgICAgfTtcclxuXHQgICAgUGFyc2VyLnByb3RvdHlwZS5wYXJzZU9iamVjdEluaXRpYWxpemVyID0gZnVuY3Rpb24gKCkge1xyXG5cdCAgICAgICAgdmFyIG5vZGUgPSB0aGlzLmNyZWF0ZU5vZGUoKTtcclxuXHQgICAgICAgIHRoaXMuZXhwZWN0KCd7Jyk7XHJcblx0ICAgICAgICB2YXIgcHJvcGVydGllcyA9IFtdO1xyXG5cdCAgICAgICAgdmFyIGhhc1Byb3RvID0geyB2YWx1ZTogZmFsc2UgfTtcclxuXHQgICAgICAgIHdoaWxlICghdGhpcy5tYXRjaCgnfScpKSB7XHJcblx0ICAgICAgICAgICAgcHJvcGVydGllcy5wdXNoKHRoaXMucGFyc2VPYmplY3RQcm9wZXJ0eShoYXNQcm90bykpO1xyXG5cdCAgICAgICAgICAgIGlmICghdGhpcy5tYXRjaCgnfScpKSB7XHJcblx0ICAgICAgICAgICAgICAgIHRoaXMuZXhwZWN0Q29tbWFTZXBhcmF0b3IoKTtcclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICB0aGlzLmV4cGVjdCgnfScpO1xyXG5cdCAgICAgICAgcmV0dXJuIHRoaXMuZmluYWxpemUobm9kZSwgbmV3IE5vZGUuT2JqZWN0RXhwcmVzc2lvbihwcm9wZXJ0aWVzKSk7XHJcblx0ICAgIH07XHJcblx0ICAgIC8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLXRlbXBsYXRlLWxpdGVyYWxzXHJcblx0ICAgIFBhcnNlci5wcm90b3R5cGUucGFyc2VUZW1wbGF0ZUhlYWQgPSBmdW5jdGlvbiAoKSB7XHJcblx0ICAgICAgICBhc3NlcnRfMS5hc3NlcnQodGhpcy5sb29rYWhlYWQuaGVhZCwgJ1RlbXBsYXRlIGxpdGVyYWwgbXVzdCBzdGFydCB3aXRoIGEgdGVtcGxhdGUgaGVhZCcpO1xyXG5cdCAgICAgICAgdmFyIG5vZGUgPSB0aGlzLmNyZWF0ZU5vZGUoKTtcclxuXHQgICAgICAgIHZhciB0b2tlbiA9IHRoaXMubmV4dFRva2VuKCk7XHJcblx0ICAgICAgICB2YXIgcmF3ID0gdG9rZW4udmFsdWU7XHJcblx0ICAgICAgICB2YXIgY29va2VkID0gdG9rZW4uY29va2VkO1xyXG5cdCAgICAgICAgcmV0dXJuIHRoaXMuZmluYWxpemUobm9kZSwgbmV3IE5vZGUuVGVtcGxhdGVFbGVtZW50KHsgcmF3OiByYXcsIGNvb2tlZDogY29va2VkIH0sIHRva2VuLnRhaWwpKTtcclxuXHQgICAgfTtcclxuXHQgICAgUGFyc2VyLnByb3RvdHlwZS5wYXJzZVRlbXBsYXRlRWxlbWVudCA9IGZ1bmN0aW9uICgpIHtcclxuXHQgICAgICAgIGlmICh0aGlzLmxvb2thaGVhZC50eXBlICE9PSAxMCAvKiBUZW1wbGF0ZSAqLykge1xyXG5cdCAgICAgICAgICAgIHRoaXMudGhyb3dVbmV4cGVjdGVkVG9rZW4oKTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIHZhciBub2RlID0gdGhpcy5jcmVhdGVOb2RlKCk7XHJcblx0ICAgICAgICB2YXIgdG9rZW4gPSB0aGlzLm5leHRUb2tlbigpO1xyXG5cdCAgICAgICAgdmFyIHJhdyA9IHRva2VuLnZhbHVlO1xyXG5cdCAgICAgICAgdmFyIGNvb2tlZCA9IHRva2VuLmNvb2tlZDtcclxuXHQgICAgICAgIHJldHVybiB0aGlzLmZpbmFsaXplKG5vZGUsIG5ldyBOb2RlLlRlbXBsYXRlRWxlbWVudCh7IHJhdzogcmF3LCBjb29rZWQ6IGNvb2tlZCB9LCB0b2tlbi50YWlsKSk7XHJcblx0ICAgIH07XHJcblx0ICAgIFBhcnNlci5wcm90b3R5cGUucGFyc2VUZW1wbGF0ZUxpdGVyYWwgPSBmdW5jdGlvbiAoKSB7XHJcblx0ICAgICAgICB2YXIgbm9kZSA9IHRoaXMuY3JlYXRlTm9kZSgpO1xyXG5cdCAgICAgICAgdmFyIGV4cHJlc3Npb25zID0gW107XHJcblx0ICAgICAgICB2YXIgcXVhc2lzID0gW107XHJcblx0ICAgICAgICB2YXIgcXVhc2kgPSB0aGlzLnBhcnNlVGVtcGxhdGVIZWFkKCk7XHJcblx0ICAgICAgICBxdWFzaXMucHVzaChxdWFzaSk7XHJcblx0ICAgICAgICB3aGlsZSAoIXF1YXNpLnRhaWwpIHtcclxuXHQgICAgICAgICAgICBleHByZXNzaW9ucy5wdXNoKHRoaXMucGFyc2VFeHByZXNzaW9uKCkpO1xyXG5cdCAgICAgICAgICAgIHF1YXNpID0gdGhpcy5wYXJzZVRlbXBsYXRlRWxlbWVudCgpO1xyXG5cdCAgICAgICAgICAgIHF1YXNpcy5wdXNoKHF1YXNpKTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIHJldHVybiB0aGlzLmZpbmFsaXplKG5vZGUsIG5ldyBOb2RlLlRlbXBsYXRlTGl0ZXJhbChxdWFzaXMsIGV4cHJlc3Npb25zKSk7XHJcblx0ICAgIH07XHJcblx0ICAgIC8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLWdyb3VwaW5nLW9wZXJhdG9yXHJcblx0ICAgIFBhcnNlci5wcm90b3R5cGUucmVpbnRlcnByZXRFeHByZXNzaW9uQXNQYXR0ZXJuID0gZnVuY3Rpb24gKGV4cHIpIHtcclxuXHQgICAgICAgIHN3aXRjaCAoZXhwci50eXBlKSB7XHJcblx0ICAgICAgICAgICAgY2FzZSBzeW50YXhfMS5TeW50YXguSWRlbnRpZmllcjpcclxuXHQgICAgICAgICAgICBjYXNlIHN5bnRheF8xLlN5bnRheC5NZW1iZXJFeHByZXNzaW9uOlxyXG5cdCAgICAgICAgICAgIGNhc2Ugc3ludGF4XzEuU3ludGF4LlJlc3RFbGVtZW50OlxyXG5cdCAgICAgICAgICAgIGNhc2Ugc3ludGF4XzEuU3ludGF4LkFzc2lnbm1lbnRQYXR0ZXJuOlxyXG5cdCAgICAgICAgICAgICAgICBicmVhaztcclxuXHQgICAgICAgICAgICBjYXNlIHN5bnRheF8xLlN5bnRheC5TcHJlYWRFbGVtZW50OlxyXG5cdCAgICAgICAgICAgICAgICBleHByLnR5cGUgPSBzeW50YXhfMS5TeW50YXguUmVzdEVsZW1lbnQ7XHJcblx0ICAgICAgICAgICAgICAgIHRoaXMucmVpbnRlcnByZXRFeHByZXNzaW9uQXNQYXR0ZXJuKGV4cHIuYXJndW1lbnQpO1xyXG5cdCAgICAgICAgICAgICAgICBicmVhaztcclxuXHQgICAgICAgICAgICBjYXNlIHN5bnRheF8xLlN5bnRheC5BcnJheUV4cHJlc3Npb246XHJcblx0ICAgICAgICAgICAgICAgIGV4cHIudHlwZSA9IHN5bnRheF8xLlN5bnRheC5BcnJheVBhdHRlcm47XHJcblx0ICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZXhwci5lbGVtZW50cy5sZW5ndGg7IGkrKykge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKGV4cHIuZWxlbWVudHNbaV0gIT09IG51bGwpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnJlaW50ZXJwcmV0RXhwcmVzc2lvbkFzUGF0dGVybihleHByLmVsZW1lbnRzW2ldKTtcclxuXHQgICAgICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICBicmVhaztcclxuXHQgICAgICAgICAgICBjYXNlIHN5bnRheF8xLlN5bnRheC5PYmplY3RFeHByZXNzaW9uOlxyXG5cdCAgICAgICAgICAgICAgICBleHByLnR5cGUgPSBzeW50YXhfMS5TeW50YXguT2JqZWN0UGF0dGVybjtcclxuXHQgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBleHByLnByb3BlcnRpZXMubGVuZ3RoOyBpKyspIHtcclxuXHQgICAgICAgICAgICAgICAgICAgIHRoaXMucmVpbnRlcnByZXRFeHByZXNzaW9uQXNQYXR0ZXJuKGV4cHIucHJvcGVydGllc1tpXS52YWx1ZSk7XHJcblx0ICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgYnJlYWs7XHJcblx0ICAgICAgICAgICAgY2FzZSBzeW50YXhfMS5TeW50YXguQXNzaWdubWVudEV4cHJlc3Npb246XHJcblx0ICAgICAgICAgICAgICAgIGV4cHIudHlwZSA9IHN5bnRheF8xLlN5bnRheC5Bc3NpZ25tZW50UGF0dGVybjtcclxuXHQgICAgICAgICAgICAgICAgZGVsZXRlIGV4cHIub3BlcmF0b3I7XHJcblx0ICAgICAgICAgICAgICAgIHRoaXMucmVpbnRlcnByZXRFeHByZXNzaW9uQXNQYXR0ZXJuKGV4cHIubGVmdCk7XHJcblx0ICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cdCAgICAgICAgICAgIGRlZmF1bHQ6XHJcblx0ICAgICAgICAgICAgICAgIC8vIEFsbG93IG90aGVyIG5vZGUgdHlwZSBmb3IgdG9sZXJhbnQgcGFyc2luZy5cclxuXHQgICAgICAgICAgICAgICAgYnJlYWs7XHJcblx0ICAgICAgICB9XHJcblx0ICAgIH07XHJcblx0ICAgIFBhcnNlci5wcm90b3R5cGUucGFyc2VHcm91cEV4cHJlc3Npb24gPSBmdW5jdGlvbiAoKSB7XHJcblx0ICAgICAgICB2YXIgZXhwcjtcclxuXHQgICAgICAgIHRoaXMuZXhwZWN0KCcoJyk7XHJcblx0ICAgICAgICBpZiAodGhpcy5tYXRjaCgnKScpKSB7XHJcblx0ICAgICAgICAgICAgdGhpcy5uZXh0VG9rZW4oKTtcclxuXHQgICAgICAgICAgICBpZiAoIXRoaXMubWF0Y2goJz0+JykpIHtcclxuXHQgICAgICAgICAgICAgICAgdGhpcy5leHBlY3QoJz0+Jyk7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgIGV4cHIgPSB7XHJcblx0ICAgICAgICAgICAgICAgIHR5cGU6IEFycm93UGFyYW1ldGVyUGxhY2VIb2xkZXIsXHJcblx0ICAgICAgICAgICAgICAgIHBhcmFtczogW10sXHJcblx0ICAgICAgICAgICAgICAgIGFzeW5jOiBmYWxzZVxyXG5cdCAgICAgICAgICAgIH07XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICBlbHNlIHtcclxuXHQgICAgICAgICAgICB2YXIgc3RhcnRUb2tlbiA9IHRoaXMubG9va2FoZWFkO1xyXG5cdCAgICAgICAgICAgIHZhciBwYXJhbXMgPSBbXTtcclxuXHQgICAgICAgICAgICBpZiAodGhpcy5tYXRjaCgnLi4uJykpIHtcclxuXHQgICAgICAgICAgICAgICAgZXhwciA9IHRoaXMucGFyc2VSZXN0RWxlbWVudChwYXJhbXMpO1xyXG5cdCAgICAgICAgICAgICAgICB0aGlzLmV4cGVjdCgnKScpO1xyXG5cdCAgICAgICAgICAgICAgICBpZiAoIXRoaXMubWF0Y2goJz0+JykpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgIHRoaXMuZXhwZWN0KCc9PicpO1xyXG5cdCAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgIGV4cHIgPSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICB0eXBlOiBBcnJvd1BhcmFtZXRlclBsYWNlSG9sZGVyLFxyXG5cdCAgICAgICAgICAgICAgICAgICAgcGFyYW1zOiBbZXhwcl0sXHJcblx0ICAgICAgICAgICAgICAgICAgICBhc3luYzogZmFsc2VcclxuXHQgICAgICAgICAgICAgICAgfTtcclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgZWxzZSB7XHJcblx0ICAgICAgICAgICAgICAgIHZhciBhcnJvdyA9IGZhbHNlO1xyXG5cdCAgICAgICAgICAgICAgICB0aGlzLmNvbnRleHQuaXNCaW5kaW5nRWxlbWVudCA9IHRydWU7XHJcblx0ICAgICAgICAgICAgICAgIGV4cHIgPSB0aGlzLmluaGVyaXRDb3ZlckdyYW1tYXIodGhpcy5wYXJzZUFzc2lnbm1lbnRFeHByZXNzaW9uKTtcclxuXHQgICAgICAgICAgICAgICAgaWYgKHRoaXMubWF0Y2goJywnKSkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIGV4cHJlc3Npb25zID0gW107XHJcblx0ICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbnRleHQuaXNBc3NpZ25tZW50VGFyZ2V0ID0gZmFsc2U7XHJcblx0ICAgICAgICAgICAgICAgICAgICBleHByZXNzaW9ucy5wdXNoKGV4cHIpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgd2hpbGUgKHRoaXMubG9va2FoZWFkLnR5cGUgIT09IDIgLyogRU9GICovKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCF0aGlzLm1hdGNoKCcsJykpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubmV4dFRva2VuKCk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMubWF0Y2goJyknKSkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm5leHRUb2tlbigpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGV4cHJlc3Npb25zLmxlbmd0aDsgaSsrKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnJlaW50ZXJwcmV0RXhwcmVzc2lvbkFzUGF0dGVybihleHByZXNzaW9uc1tpXSk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXJyb3cgPSB0cnVlO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBleHByID0ge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogQXJyb3dQYXJhbWV0ZXJQbGFjZUhvbGRlcixcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcmFtczogZXhwcmVzc2lvbnMsXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhc3luYzogZmFsc2VcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgfTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5tYXRjaCgnLi4uJykpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCF0aGlzLmNvbnRleHQuaXNCaW5kaW5nRWxlbWVudCkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy50aHJvd1VuZXhwZWN0ZWRUb2tlbih0aGlzLmxvb2thaGVhZCk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXhwcmVzc2lvbnMucHVzaCh0aGlzLnBhcnNlUmVzdEVsZW1lbnQocGFyYW1zKSk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZXhwZWN0KCcpJyk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghdGhpcy5tYXRjaCgnPT4nKSkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5leHBlY3QoJz0+Jyk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jb250ZXh0LmlzQmluZGluZ0VsZW1lbnQgPSBmYWxzZTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBleHByZXNzaW9ucy5sZW5ndGg7IGkrKykge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5yZWludGVycHJldEV4cHJlc3Npb25Bc1BhdHRlcm4oZXhwcmVzc2lvbnNbaV0pO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFycm93ID0gdHJ1ZTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXhwciA9IHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IEFycm93UGFyYW1ldGVyUGxhY2VIb2xkZXIsXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXJhbXM6IGV4cHJlc3Npb25zLFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXN5bmM6IGZhbHNlXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIH07XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBleHByZXNzaW9ucy5wdXNoKHRoaXMuaW5oZXJpdENvdmVyR3JhbW1hcih0aGlzLnBhcnNlQXNzaWdubWVudEV4cHJlc3Npb24pKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGFycm93KSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgICAgIGlmICghYXJyb3cpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBleHByID0gdGhpcy5maW5hbGl6ZSh0aGlzLnN0YXJ0Tm9kZShzdGFydFRva2VuKSwgbmV3IE5vZGUuU2VxdWVuY2VFeHByZXNzaW9uKGV4cHJlc3Npb25zKSk7XHJcblx0ICAgICAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgaWYgKCFhcnJvdykge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgdGhpcy5leHBlY3QoJyknKTtcclxuXHQgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLm1hdGNoKCc9PicpKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGV4cHIudHlwZSA9PT0gc3ludGF4XzEuU3ludGF4LklkZW50aWZpZXIgJiYgZXhwci5uYW1lID09PSAneWllbGQnKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFycm93ID0gdHJ1ZTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXhwciA9IHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IEFycm93UGFyYW1ldGVyUGxhY2VIb2xkZXIsXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXJhbXM6IFtleHByXSxcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFzeW5jOiBmYWxzZVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWFycm93KSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghdGhpcy5jb250ZXh0LmlzQmluZGluZ0VsZW1lbnQpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMudGhyb3dVbmV4cGVjdGVkVG9rZW4odGhpcy5sb29rYWhlYWQpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChleHByLnR5cGUgPT09IHN5bnRheF8xLlN5bnRheC5TZXF1ZW5jZUV4cHJlc3Npb24pIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZXhwci5leHByZXNzaW9ucy5sZW5ndGg7IGkrKykge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucmVpbnRlcnByZXRFeHByZXNzaW9uQXNQYXR0ZXJuKGV4cHIuZXhwcmVzc2lvbnNbaV0pO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5yZWludGVycHJldEV4cHJlc3Npb25Bc1BhdHRlcm4oZXhwcik7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHBhcmFtZXRlcnMgPSAoZXhwci50eXBlID09PSBzeW50YXhfMS5TeW50YXguU2VxdWVuY2VFeHByZXNzaW9uID8gZXhwci5leHByZXNzaW9ucyA6IFtleHByXSk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV4cHIgPSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBBcnJvd1BhcmFtZXRlclBsYWNlSG9sZGVyLFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFyYW1zOiBwYXJhbWV0ZXJzLFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXN5bmM6IGZhbHNlXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIH07XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICAgICAgdGhpcy5jb250ZXh0LmlzQmluZGluZ0VsZW1lbnQgPSBmYWxzZTtcclxuXHQgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIHJldHVybiBleHByO1xyXG5cdCAgICB9O1xyXG5cdCAgICAvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1sZWZ0LWhhbmQtc2lkZS1leHByZXNzaW9uc1xyXG5cdCAgICBQYXJzZXIucHJvdG90eXBlLnBhcnNlQXJndW1lbnRzID0gZnVuY3Rpb24gKCkge1xyXG5cdCAgICAgICAgdGhpcy5leHBlY3QoJygnKTtcclxuXHQgICAgICAgIHZhciBhcmdzID0gW107XHJcblx0ICAgICAgICBpZiAoIXRoaXMubWF0Y2goJyknKSkge1xyXG5cdCAgICAgICAgICAgIHdoaWxlICh0cnVlKSB7XHJcblx0ICAgICAgICAgICAgICAgIHZhciBleHByID0gdGhpcy5tYXRjaCgnLi4uJykgPyB0aGlzLnBhcnNlU3ByZWFkRWxlbWVudCgpIDpcclxuXHQgICAgICAgICAgICAgICAgICAgIHRoaXMuaXNvbGF0ZUNvdmVyR3JhbW1hcih0aGlzLnBhcnNlQXNzaWdubWVudEV4cHJlc3Npb24pO1xyXG5cdCAgICAgICAgICAgICAgICBhcmdzLnB1c2goZXhwcik7XHJcblx0ICAgICAgICAgICAgICAgIGlmICh0aGlzLm1hdGNoKCcpJykpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cdCAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgIHRoaXMuZXhwZWN0Q29tbWFTZXBhcmF0b3IoKTtcclxuXHQgICAgICAgICAgICAgICAgaWYgKHRoaXMubWF0Y2goJyknKSkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcblx0ICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICB0aGlzLmV4cGVjdCgnKScpO1xyXG5cdCAgICAgICAgcmV0dXJuIGFyZ3M7XHJcblx0ICAgIH07XHJcblx0ICAgIFBhcnNlci5wcm90b3R5cGUuaXNJZGVudGlmaWVyTmFtZSA9IGZ1bmN0aW9uICh0b2tlbikge1xyXG5cdCAgICAgICAgcmV0dXJuIHRva2VuLnR5cGUgPT09IDMgLyogSWRlbnRpZmllciAqLyB8fFxyXG5cdCAgICAgICAgICAgIHRva2VuLnR5cGUgPT09IDQgLyogS2V5d29yZCAqLyB8fFxyXG5cdCAgICAgICAgICAgIHRva2VuLnR5cGUgPT09IDEgLyogQm9vbGVhbkxpdGVyYWwgKi8gfHxcclxuXHQgICAgICAgICAgICB0b2tlbi50eXBlID09PSA1IC8qIE51bGxMaXRlcmFsICovO1xyXG5cdCAgICB9O1xyXG5cdCAgICBQYXJzZXIucHJvdG90eXBlLnBhcnNlSWRlbnRpZmllck5hbWUgPSBmdW5jdGlvbiAoKSB7XHJcblx0ICAgICAgICB2YXIgbm9kZSA9IHRoaXMuY3JlYXRlTm9kZSgpO1xyXG5cdCAgICAgICAgdmFyIHRva2VuID0gdGhpcy5uZXh0VG9rZW4oKTtcclxuXHQgICAgICAgIGlmICghdGhpcy5pc0lkZW50aWZpZXJOYW1lKHRva2VuKSkge1xyXG5cdCAgICAgICAgICAgIHRoaXMudGhyb3dVbmV4cGVjdGVkVG9rZW4odG9rZW4pO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgcmV0dXJuIHRoaXMuZmluYWxpemUobm9kZSwgbmV3IE5vZGUuSWRlbnRpZmllcih0b2tlbi52YWx1ZSkpO1xyXG5cdCAgICB9O1xyXG5cdCAgICBQYXJzZXIucHJvdG90eXBlLnBhcnNlTmV3RXhwcmVzc2lvbiA9IGZ1bmN0aW9uICgpIHtcclxuXHQgICAgICAgIHZhciBub2RlID0gdGhpcy5jcmVhdGVOb2RlKCk7XHJcblx0ICAgICAgICB2YXIgaWQgPSB0aGlzLnBhcnNlSWRlbnRpZmllck5hbWUoKTtcclxuXHQgICAgICAgIGFzc2VydF8xLmFzc2VydChpZC5uYW1lID09PSAnbmV3JywgJ05ldyBleHByZXNzaW9uIG11c3Qgc3RhcnQgd2l0aCBgbmV3YCcpO1xyXG5cdCAgICAgICAgdmFyIGV4cHI7XHJcblx0ICAgICAgICBpZiAodGhpcy5tYXRjaCgnLicpKSB7XHJcblx0ICAgICAgICAgICAgdGhpcy5uZXh0VG9rZW4oKTtcclxuXHQgICAgICAgICAgICBpZiAodGhpcy5sb29rYWhlYWQudHlwZSA9PT0gMyAvKiBJZGVudGlmaWVyICovICYmIHRoaXMuY29udGV4dC5pbkZ1bmN0aW9uQm9keSAmJiB0aGlzLmxvb2thaGVhZC52YWx1ZSA9PT0gJ3RhcmdldCcpIHtcclxuXHQgICAgICAgICAgICAgICAgdmFyIHByb3BlcnR5ID0gdGhpcy5wYXJzZUlkZW50aWZpZXJOYW1lKCk7XHJcblx0ICAgICAgICAgICAgICAgIGV4cHIgPSBuZXcgTm9kZS5NZXRhUHJvcGVydHkoaWQsIHByb3BlcnR5KTtcclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgZWxzZSB7XHJcblx0ICAgICAgICAgICAgICAgIHRoaXMudGhyb3dVbmV4cGVjdGVkVG9rZW4odGhpcy5sb29rYWhlYWQpO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIGVsc2Uge1xyXG5cdCAgICAgICAgICAgIHZhciBjYWxsZWUgPSB0aGlzLmlzb2xhdGVDb3ZlckdyYW1tYXIodGhpcy5wYXJzZUxlZnRIYW5kU2lkZUV4cHJlc3Npb24pO1xyXG5cdCAgICAgICAgICAgIHZhciBhcmdzID0gdGhpcy5tYXRjaCgnKCcpID8gdGhpcy5wYXJzZUFyZ3VtZW50cygpIDogW107XHJcblx0ICAgICAgICAgICAgZXhwciA9IG5ldyBOb2RlLk5ld0V4cHJlc3Npb24oY2FsbGVlLCBhcmdzKTtcclxuXHQgICAgICAgICAgICB0aGlzLmNvbnRleHQuaXNBc3NpZ25tZW50VGFyZ2V0ID0gZmFsc2U7XHJcblx0ICAgICAgICAgICAgdGhpcy5jb250ZXh0LmlzQmluZGluZ0VsZW1lbnQgPSBmYWxzZTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIHJldHVybiB0aGlzLmZpbmFsaXplKG5vZGUsIGV4cHIpO1xyXG5cdCAgICB9O1xyXG5cdCAgICBQYXJzZXIucHJvdG90eXBlLnBhcnNlQXN5bmNBcmd1bWVudCA9IGZ1bmN0aW9uICgpIHtcclxuXHQgICAgICAgIHZhciBhcmcgPSB0aGlzLnBhcnNlQXNzaWdubWVudEV4cHJlc3Npb24oKTtcclxuXHQgICAgICAgIHRoaXMuY29udGV4dC5maXJzdENvdmVySW5pdGlhbGl6ZWROYW1lRXJyb3IgPSBudWxsO1xyXG5cdCAgICAgICAgcmV0dXJuIGFyZztcclxuXHQgICAgfTtcclxuXHQgICAgUGFyc2VyLnByb3RvdHlwZS5wYXJzZUFzeW5jQXJndW1lbnRzID0gZnVuY3Rpb24gKCkge1xyXG5cdCAgICAgICAgdGhpcy5leHBlY3QoJygnKTtcclxuXHQgICAgICAgIHZhciBhcmdzID0gW107XHJcblx0ICAgICAgICBpZiAoIXRoaXMubWF0Y2goJyknKSkge1xyXG5cdCAgICAgICAgICAgIHdoaWxlICh0cnVlKSB7XHJcblx0ICAgICAgICAgICAgICAgIHZhciBleHByID0gdGhpcy5tYXRjaCgnLi4uJykgPyB0aGlzLnBhcnNlU3ByZWFkRWxlbWVudCgpIDpcclxuXHQgICAgICAgICAgICAgICAgICAgIHRoaXMuaXNvbGF0ZUNvdmVyR3JhbW1hcih0aGlzLnBhcnNlQXN5bmNBcmd1bWVudCk7XHJcblx0ICAgICAgICAgICAgICAgIGFyZ3MucHVzaChleHByKTtcclxuXHQgICAgICAgICAgICAgICAgaWYgKHRoaXMubWF0Y2goJyknKSkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcblx0ICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgdGhpcy5leHBlY3RDb21tYVNlcGFyYXRvcigpO1xyXG5cdCAgICAgICAgICAgICAgICBpZiAodGhpcy5tYXRjaCgnKScpKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuXHQgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIHRoaXMuZXhwZWN0KCcpJyk7XHJcblx0ICAgICAgICByZXR1cm4gYXJncztcclxuXHQgICAgfTtcclxuXHQgICAgUGFyc2VyLnByb3RvdHlwZS5wYXJzZUxlZnRIYW5kU2lkZUV4cHJlc3Npb25BbGxvd0NhbGwgPSBmdW5jdGlvbiAoKSB7XHJcblx0ICAgICAgICB2YXIgc3RhcnRUb2tlbiA9IHRoaXMubG9va2FoZWFkO1xyXG5cdCAgICAgICAgdmFyIG1heWJlQXN5bmMgPSB0aGlzLm1hdGNoQ29udGV4dHVhbEtleXdvcmQoJ2FzeW5jJyk7XHJcblx0ICAgICAgICB2YXIgcHJldmlvdXNBbGxvd0luID0gdGhpcy5jb250ZXh0LmFsbG93SW47XHJcblx0ICAgICAgICB0aGlzLmNvbnRleHQuYWxsb3dJbiA9IHRydWU7XHJcblx0ICAgICAgICB2YXIgZXhwcjtcclxuXHQgICAgICAgIGlmICh0aGlzLm1hdGNoS2V5d29yZCgnc3VwZXInKSAmJiB0aGlzLmNvbnRleHQuaW5GdW5jdGlvbkJvZHkpIHtcclxuXHQgICAgICAgICAgICBleHByID0gdGhpcy5jcmVhdGVOb2RlKCk7XHJcblx0ICAgICAgICAgICAgdGhpcy5uZXh0VG9rZW4oKTtcclxuXHQgICAgICAgICAgICBleHByID0gdGhpcy5maW5hbGl6ZShleHByLCBuZXcgTm9kZS5TdXBlcigpKTtcclxuXHQgICAgICAgICAgICBpZiAoIXRoaXMubWF0Y2goJygnKSAmJiAhdGhpcy5tYXRjaCgnLicpICYmICF0aGlzLm1hdGNoKCdbJykpIHtcclxuXHQgICAgICAgICAgICAgICAgdGhpcy50aHJvd1VuZXhwZWN0ZWRUb2tlbih0aGlzLmxvb2thaGVhZCk7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgZWxzZSB7XHJcblx0ICAgICAgICAgICAgZXhwciA9IHRoaXMuaW5oZXJpdENvdmVyR3JhbW1hcih0aGlzLm1hdGNoS2V5d29yZCgnbmV3JykgPyB0aGlzLnBhcnNlTmV3RXhwcmVzc2lvbiA6IHRoaXMucGFyc2VQcmltYXJ5RXhwcmVzc2lvbik7XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICB3aGlsZSAodHJ1ZSkge1xyXG5cdCAgICAgICAgICAgIGlmICh0aGlzLm1hdGNoKCcuJykpIHtcclxuXHQgICAgICAgICAgICAgICAgdGhpcy5jb250ZXh0LmlzQmluZGluZ0VsZW1lbnQgPSBmYWxzZTtcclxuXHQgICAgICAgICAgICAgICAgdGhpcy5jb250ZXh0LmlzQXNzaWdubWVudFRhcmdldCA9IHRydWU7XHJcblx0ICAgICAgICAgICAgICAgIHRoaXMuZXhwZWN0KCcuJyk7XHJcblx0ICAgICAgICAgICAgICAgIHZhciBwcm9wZXJ0eSA9IHRoaXMucGFyc2VJZGVudGlmaWVyTmFtZSgpO1xyXG5cdCAgICAgICAgICAgICAgICBleHByID0gdGhpcy5maW5hbGl6ZSh0aGlzLnN0YXJ0Tm9kZShzdGFydFRva2VuKSwgbmV3IE5vZGUuU3RhdGljTWVtYmVyRXhwcmVzc2lvbihleHByLCBwcm9wZXJ0eSkpO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICBlbHNlIGlmICh0aGlzLm1hdGNoKCcoJykpIHtcclxuXHQgICAgICAgICAgICAgICAgdmFyIGFzeW5jQXJyb3cgPSBtYXliZUFzeW5jICYmIChzdGFydFRva2VuLmxpbmVOdW1iZXIgPT09IHRoaXMubG9va2FoZWFkLmxpbmVOdW1iZXIpO1xyXG5cdCAgICAgICAgICAgICAgICB0aGlzLmNvbnRleHQuaXNCaW5kaW5nRWxlbWVudCA9IGZhbHNlO1xyXG5cdCAgICAgICAgICAgICAgICB0aGlzLmNvbnRleHQuaXNBc3NpZ25tZW50VGFyZ2V0ID0gZmFsc2U7XHJcblx0ICAgICAgICAgICAgICAgIHZhciBhcmdzID0gYXN5bmNBcnJvdyA/IHRoaXMucGFyc2VBc3luY0FyZ3VtZW50cygpIDogdGhpcy5wYXJzZUFyZ3VtZW50cygpO1xyXG5cdCAgICAgICAgICAgICAgICBleHByID0gdGhpcy5maW5hbGl6ZSh0aGlzLnN0YXJ0Tm9kZShzdGFydFRva2VuKSwgbmV3IE5vZGUuQ2FsbEV4cHJlc3Npb24oZXhwciwgYXJncykpO1xyXG5cdCAgICAgICAgICAgICAgICBpZiAoYXN5bmNBcnJvdyAmJiB0aGlzLm1hdGNoKCc9PicpKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFyZ3MubGVuZ3RoOyArK2kpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnJlaW50ZXJwcmV0RXhwcmVzc2lvbkFzUGF0dGVybihhcmdzW2ldKTtcclxuXHQgICAgICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgICAgIGV4cHIgPSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogQXJyb3dQYXJhbWV0ZXJQbGFjZUhvbGRlcixcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBwYXJhbXM6IGFyZ3MsXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgYXN5bmM6IHRydWVcclxuXHQgICAgICAgICAgICAgICAgICAgIH07XHJcblx0ICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5tYXRjaCgnWycpKSB7XHJcblx0ICAgICAgICAgICAgICAgIHRoaXMuY29udGV4dC5pc0JpbmRpbmdFbGVtZW50ID0gZmFsc2U7XHJcblx0ICAgICAgICAgICAgICAgIHRoaXMuY29udGV4dC5pc0Fzc2lnbm1lbnRUYXJnZXQgPSB0cnVlO1xyXG5cdCAgICAgICAgICAgICAgICB0aGlzLmV4cGVjdCgnWycpO1xyXG5cdCAgICAgICAgICAgICAgICB2YXIgcHJvcGVydHkgPSB0aGlzLmlzb2xhdGVDb3ZlckdyYW1tYXIodGhpcy5wYXJzZUV4cHJlc3Npb24pO1xyXG5cdCAgICAgICAgICAgICAgICB0aGlzLmV4cGVjdCgnXScpO1xyXG5cdCAgICAgICAgICAgICAgICBleHByID0gdGhpcy5maW5hbGl6ZSh0aGlzLnN0YXJ0Tm9kZShzdGFydFRva2VuKSwgbmV3IE5vZGUuQ29tcHV0ZWRNZW1iZXJFeHByZXNzaW9uKGV4cHIsIHByb3BlcnR5KSk7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMubG9va2FoZWFkLnR5cGUgPT09IDEwIC8qIFRlbXBsYXRlICovICYmIHRoaXMubG9va2FoZWFkLmhlYWQpIHtcclxuXHQgICAgICAgICAgICAgICAgdmFyIHF1YXNpID0gdGhpcy5wYXJzZVRlbXBsYXRlTGl0ZXJhbCgpO1xyXG5cdCAgICAgICAgICAgICAgICBleHByID0gdGhpcy5maW5hbGl6ZSh0aGlzLnN0YXJ0Tm9kZShzdGFydFRva2VuKSwgbmV3IE5vZGUuVGFnZ2VkVGVtcGxhdGVFeHByZXNzaW9uKGV4cHIsIHF1YXNpKSk7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgIGVsc2Uge1xyXG5cdCAgICAgICAgICAgICAgICBicmVhaztcclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICB0aGlzLmNvbnRleHQuYWxsb3dJbiA9IHByZXZpb3VzQWxsb3dJbjtcclxuXHQgICAgICAgIHJldHVybiBleHByO1xyXG5cdCAgICB9O1xyXG5cdCAgICBQYXJzZXIucHJvdG90eXBlLnBhcnNlU3VwZXIgPSBmdW5jdGlvbiAoKSB7XHJcblx0ICAgICAgICB2YXIgbm9kZSA9IHRoaXMuY3JlYXRlTm9kZSgpO1xyXG5cdCAgICAgICAgdGhpcy5leHBlY3RLZXl3b3JkKCdzdXBlcicpO1xyXG5cdCAgICAgICAgaWYgKCF0aGlzLm1hdGNoKCdbJykgJiYgIXRoaXMubWF0Y2goJy4nKSkge1xyXG5cdCAgICAgICAgICAgIHRoaXMudGhyb3dVbmV4cGVjdGVkVG9rZW4odGhpcy5sb29rYWhlYWQpO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgcmV0dXJuIHRoaXMuZmluYWxpemUobm9kZSwgbmV3IE5vZGUuU3VwZXIoKSk7XHJcblx0ICAgIH07XHJcblx0ICAgIFBhcnNlci5wcm90b3R5cGUucGFyc2VMZWZ0SGFuZFNpZGVFeHByZXNzaW9uID0gZnVuY3Rpb24gKCkge1xyXG5cdCAgICAgICAgYXNzZXJ0XzEuYXNzZXJ0KHRoaXMuY29udGV4dC5hbGxvd0luLCAnY2FsbGVlIG9mIG5ldyBleHByZXNzaW9uIGFsd2F5cyBhbGxvdyBpbiBrZXl3b3JkLicpO1xyXG5cdCAgICAgICAgdmFyIG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZSh0aGlzLmxvb2thaGVhZCk7XHJcblx0ICAgICAgICB2YXIgZXhwciA9ICh0aGlzLm1hdGNoS2V5d29yZCgnc3VwZXInKSAmJiB0aGlzLmNvbnRleHQuaW5GdW5jdGlvbkJvZHkpID8gdGhpcy5wYXJzZVN1cGVyKCkgOlxyXG5cdCAgICAgICAgICAgIHRoaXMuaW5oZXJpdENvdmVyR3JhbW1hcih0aGlzLm1hdGNoS2V5d29yZCgnbmV3JykgPyB0aGlzLnBhcnNlTmV3RXhwcmVzc2lvbiA6IHRoaXMucGFyc2VQcmltYXJ5RXhwcmVzc2lvbik7XHJcblx0ICAgICAgICB3aGlsZSAodHJ1ZSkge1xyXG5cdCAgICAgICAgICAgIGlmICh0aGlzLm1hdGNoKCdbJykpIHtcclxuXHQgICAgICAgICAgICAgICAgdGhpcy5jb250ZXh0LmlzQmluZGluZ0VsZW1lbnQgPSBmYWxzZTtcclxuXHQgICAgICAgICAgICAgICAgdGhpcy5jb250ZXh0LmlzQXNzaWdubWVudFRhcmdldCA9IHRydWU7XHJcblx0ICAgICAgICAgICAgICAgIHRoaXMuZXhwZWN0KCdbJyk7XHJcblx0ICAgICAgICAgICAgICAgIHZhciBwcm9wZXJ0eSA9IHRoaXMuaXNvbGF0ZUNvdmVyR3JhbW1hcih0aGlzLnBhcnNlRXhwcmVzc2lvbik7XHJcblx0ICAgICAgICAgICAgICAgIHRoaXMuZXhwZWN0KCddJyk7XHJcblx0ICAgICAgICAgICAgICAgIGV4cHIgPSB0aGlzLmZpbmFsaXplKG5vZGUsIG5ldyBOb2RlLkNvbXB1dGVkTWVtYmVyRXhwcmVzc2lvbihleHByLCBwcm9wZXJ0eSkpO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICBlbHNlIGlmICh0aGlzLm1hdGNoKCcuJykpIHtcclxuXHQgICAgICAgICAgICAgICAgdGhpcy5jb250ZXh0LmlzQmluZGluZ0VsZW1lbnQgPSBmYWxzZTtcclxuXHQgICAgICAgICAgICAgICAgdGhpcy5jb250ZXh0LmlzQXNzaWdubWVudFRhcmdldCA9IHRydWU7XHJcblx0ICAgICAgICAgICAgICAgIHRoaXMuZXhwZWN0KCcuJyk7XHJcblx0ICAgICAgICAgICAgICAgIHZhciBwcm9wZXJ0eSA9IHRoaXMucGFyc2VJZGVudGlmaWVyTmFtZSgpO1xyXG5cdCAgICAgICAgICAgICAgICBleHByID0gdGhpcy5maW5hbGl6ZShub2RlLCBuZXcgTm9kZS5TdGF0aWNNZW1iZXJFeHByZXNzaW9uKGV4cHIsIHByb3BlcnR5KSk7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMubG9va2FoZWFkLnR5cGUgPT09IDEwIC8qIFRlbXBsYXRlICovICYmIHRoaXMubG9va2FoZWFkLmhlYWQpIHtcclxuXHQgICAgICAgICAgICAgICAgdmFyIHF1YXNpID0gdGhpcy5wYXJzZVRlbXBsYXRlTGl0ZXJhbCgpO1xyXG5cdCAgICAgICAgICAgICAgICBleHByID0gdGhpcy5maW5hbGl6ZShub2RlLCBuZXcgTm9kZS5UYWdnZWRUZW1wbGF0ZUV4cHJlc3Npb24oZXhwciwgcXVhc2kpKTtcclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgZWxzZSB7XHJcblx0ICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIHJldHVybiBleHByO1xyXG5cdCAgICB9O1xyXG5cdCAgICAvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy11cGRhdGUtZXhwcmVzc2lvbnNcclxuXHQgICAgUGFyc2VyLnByb3RvdHlwZS5wYXJzZVVwZGF0ZUV4cHJlc3Npb24gPSBmdW5jdGlvbiAoKSB7XHJcblx0ICAgICAgICB2YXIgZXhwcjtcclxuXHQgICAgICAgIHZhciBzdGFydFRva2VuID0gdGhpcy5sb29rYWhlYWQ7XHJcblx0ICAgICAgICBpZiAodGhpcy5tYXRjaCgnKysnKSB8fCB0aGlzLm1hdGNoKCctLScpKSB7XHJcblx0ICAgICAgICAgICAgdmFyIG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZShzdGFydFRva2VuKTtcclxuXHQgICAgICAgICAgICB2YXIgdG9rZW4gPSB0aGlzLm5leHRUb2tlbigpO1xyXG5cdCAgICAgICAgICAgIGV4cHIgPSB0aGlzLmluaGVyaXRDb3ZlckdyYW1tYXIodGhpcy5wYXJzZVVuYXJ5RXhwcmVzc2lvbik7XHJcblx0ICAgICAgICAgICAgaWYgKHRoaXMuY29udGV4dC5zdHJpY3QgJiYgZXhwci50eXBlID09PSBzeW50YXhfMS5TeW50YXguSWRlbnRpZmllciAmJiB0aGlzLnNjYW5uZXIuaXNSZXN0cmljdGVkV29yZChleHByLm5hbWUpKSB7XHJcblx0ICAgICAgICAgICAgICAgIHRoaXMudG9sZXJhdGVFcnJvcihtZXNzYWdlc18xLk1lc3NhZ2VzLlN0cmljdExIU1ByZWZpeCk7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgIGlmICghdGhpcy5jb250ZXh0LmlzQXNzaWdubWVudFRhcmdldCkge1xyXG5cdCAgICAgICAgICAgICAgICB0aGlzLnRvbGVyYXRlRXJyb3IobWVzc2FnZXNfMS5NZXNzYWdlcy5JbnZhbGlkTEhTSW5Bc3NpZ25tZW50KTtcclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgdmFyIHByZWZpeCA9IHRydWU7XHJcblx0ICAgICAgICAgICAgZXhwciA9IHRoaXMuZmluYWxpemUobm9kZSwgbmV3IE5vZGUuVXBkYXRlRXhwcmVzc2lvbih0b2tlbi52YWx1ZSwgZXhwciwgcHJlZml4KSk7XHJcblx0ICAgICAgICAgICAgdGhpcy5jb250ZXh0LmlzQXNzaWdubWVudFRhcmdldCA9IGZhbHNlO1xyXG5cdCAgICAgICAgICAgIHRoaXMuY29udGV4dC5pc0JpbmRpbmdFbGVtZW50ID0gZmFsc2U7XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICBlbHNlIHtcclxuXHQgICAgICAgICAgICBleHByID0gdGhpcy5pbmhlcml0Q292ZXJHcmFtbWFyKHRoaXMucGFyc2VMZWZ0SGFuZFNpZGVFeHByZXNzaW9uQWxsb3dDYWxsKTtcclxuXHQgICAgICAgICAgICBpZiAoIXRoaXMuaGFzTGluZVRlcm1pbmF0b3IgJiYgdGhpcy5sb29rYWhlYWQudHlwZSA9PT0gNyAvKiBQdW5jdHVhdG9yICovKSB7XHJcblx0ICAgICAgICAgICAgICAgIGlmICh0aGlzLm1hdGNoKCcrKycpIHx8IHRoaXMubWF0Y2goJy0tJykpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmNvbnRleHQuc3RyaWN0ICYmIGV4cHIudHlwZSA9PT0gc3ludGF4XzEuU3ludGF4LklkZW50aWZpZXIgJiYgdGhpcy5zY2FubmVyLmlzUmVzdHJpY3RlZFdvcmQoZXhwci5uYW1lKSkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMudG9sZXJhdGVFcnJvcihtZXNzYWdlc18xLk1lc3NhZ2VzLlN0cmljdExIU1Bvc3RmaXgpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKCF0aGlzLmNvbnRleHQuaXNBc3NpZ25tZW50VGFyZ2V0KSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy50b2xlcmF0ZUVycm9yKG1lc3NhZ2VzXzEuTWVzc2FnZXMuSW52YWxpZExIU0luQXNzaWdubWVudCk7XHJcblx0ICAgICAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbnRleHQuaXNBc3NpZ25tZW50VGFyZ2V0ID0gZmFsc2U7XHJcblx0ICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbnRleHQuaXNCaW5kaW5nRWxlbWVudCA9IGZhbHNlO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIG9wZXJhdG9yID0gdGhpcy5uZXh0VG9rZW4oKS52YWx1ZTtcclxuXHQgICAgICAgICAgICAgICAgICAgIHZhciBwcmVmaXggPSBmYWxzZTtcclxuXHQgICAgICAgICAgICAgICAgICAgIGV4cHIgPSB0aGlzLmZpbmFsaXplKHRoaXMuc3RhcnROb2RlKHN0YXJ0VG9rZW4pLCBuZXcgTm9kZS5VcGRhdGVFeHByZXNzaW9uKG9wZXJhdG9yLCBleHByLCBwcmVmaXgpKTtcclxuXHQgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIHJldHVybiBleHByO1xyXG5cdCAgICB9O1xyXG5cdCAgICAvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy11bmFyeS1vcGVyYXRvcnNcclxuXHQgICAgUGFyc2VyLnByb3RvdHlwZS5wYXJzZUF3YWl0RXhwcmVzc2lvbiA9IGZ1bmN0aW9uICgpIHtcclxuXHQgICAgICAgIHZhciBub2RlID0gdGhpcy5jcmVhdGVOb2RlKCk7XHJcblx0ICAgICAgICB0aGlzLm5leHRUb2tlbigpO1xyXG5cdCAgICAgICAgdmFyIGFyZ3VtZW50ID0gdGhpcy5wYXJzZVVuYXJ5RXhwcmVzc2lvbigpO1xyXG5cdCAgICAgICAgcmV0dXJuIHRoaXMuZmluYWxpemUobm9kZSwgbmV3IE5vZGUuQXdhaXRFeHByZXNzaW9uKGFyZ3VtZW50KSk7XHJcblx0ICAgIH07XHJcblx0ICAgIFBhcnNlci5wcm90b3R5cGUucGFyc2VVbmFyeUV4cHJlc3Npb24gPSBmdW5jdGlvbiAoKSB7XHJcblx0ICAgICAgICB2YXIgZXhwcjtcclxuXHQgICAgICAgIGlmICh0aGlzLm1hdGNoKCcrJykgfHwgdGhpcy5tYXRjaCgnLScpIHx8IHRoaXMubWF0Y2goJ34nKSB8fCB0aGlzLm1hdGNoKCchJykgfHxcclxuXHQgICAgICAgICAgICB0aGlzLm1hdGNoS2V5d29yZCgnZGVsZXRlJykgfHwgdGhpcy5tYXRjaEtleXdvcmQoJ3ZvaWQnKSB8fCB0aGlzLm1hdGNoS2V5d29yZCgndHlwZW9mJykpIHtcclxuXHQgICAgICAgICAgICB2YXIgbm9kZSA9IHRoaXMuc3RhcnROb2RlKHRoaXMubG9va2FoZWFkKTtcclxuXHQgICAgICAgICAgICB2YXIgdG9rZW4gPSB0aGlzLm5leHRUb2tlbigpO1xyXG5cdCAgICAgICAgICAgIGV4cHIgPSB0aGlzLmluaGVyaXRDb3ZlckdyYW1tYXIodGhpcy5wYXJzZVVuYXJ5RXhwcmVzc2lvbik7XHJcblx0ICAgICAgICAgICAgZXhwciA9IHRoaXMuZmluYWxpemUobm9kZSwgbmV3IE5vZGUuVW5hcnlFeHByZXNzaW9uKHRva2VuLnZhbHVlLCBleHByKSk7XHJcblx0ICAgICAgICAgICAgaWYgKHRoaXMuY29udGV4dC5zdHJpY3QgJiYgZXhwci5vcGVyYXRvciA9PT0gJ2RlbGV0ZScgJiYgZXhwci5hcmd1bWVudC50eXBlID09PSBzeW50YXhfMS5TeW50YXguSWRlbnRpZmllcikge1xyXG5cdCAgICAgICAgICAgICAgICB0aGlzLnRvbGVyYXRlRXJyb3IobWVzc2FnZXNfMS5NZXNzYWdlcy5TdHJpY3REZWxldGUpO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICB0aGlzLmNvbnRleHQuaXNBc3NpZ25tZW50VGFyZ2V0ID0gZmFsc2U7XHJcblx0ICAgICAgICAgICAgdGhpcy5jb250ZXh0LmlzQmluZGluZ0VsZW1lbnQgPSBmYWxzZTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIGVsc2UgaWYgKHRoaXMuY29udGV4dC5hd2FpdCAmJiB0aGlzLm1hdGNoQ29udGV4dHVhbEtleXdvcmQoJ2F3YWl0JykpIHtcclxuXHQgICAgICAgICAgICBleHByID0gdGhpcy5wYXJzZUF3YWl0RXhwcmVzc2lvbigpO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgZWxzZSB7XHJcblx0ICAgICAgICAgICAgZXhwciA9IHRoaXMucGFyc2VVcGRhdGVFeHByZXNzaW9uKCk7XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICByZXR1cm4gZXhwcjtcclxuXHQgICAgfTtcclxuXHQgICAgUGFyc2VyLnByb3RvdHlwZS5wYXJzZUV4cG9uZW50aWF0aW9uRXhwcmVzc2lvbiA9IGZ1bmN0aW9uICgpIHtcclxuXHQgICAgICAgIHZhciBzdGFydFRva2VuID0gdGhpcy5sb29rYWhlYWQ7XHJcblx0ICAgICAgICB2YXIgZXhwciA9IHRoaXMuaW5oZXJpdENvdmVyR3JhbW1hcih0aGlzLnBhcnNlVW5hcnlFeHByZXNzaW9uKTtcclxuXHQgICAgICAgIGlmIChleHByLnR5cGUgIT09IHN5bnRheF8xLlN5bnRheC5VbmFyeUV4cHJlc3Npb24gJiYgdGhpcy5tYXRjaCgnKionKSkge1xyXG5cdCAgICAgICAgICAgIHRoaXMubmV4dFRva2VuKCk7XHJcblx0ICAgICAgICAgICAgdGhpcy5jb250ZXh0LmlzQXNzaWdubWVudFRhcmdldCA9IGZhbHNlO1xyXG5cdCAgICAgICAgICAgIHRoaXMuY29udGV4dC5pc0JpbmRpbmdFbGVtZW50ID0gZmFsc2U7XHJcblx0ICAgICAgICAgICAgdmFyIGxlZnQgPSBleHByO1xyXG5cdCAgICAgICAgICAgIHZhciByaWdodCA9IHRoaXMuaXNvbGF0ZUNvdmVyR3JhbW1hcih0aGlzLnBhcnNlRXhwb25lbnRpYXRpb25FeHByZXNzaW9uKTtcclxuXHQgICAgICAgICAgICBleHByID0gdGhpcy5maW5hbGl6ZSh0aGlzLnN0YXJ0Tm9kZShzdGFydFRva2VuKSwgbmV3IE5vZGUuQmluYXJ5RXhwcmVzc2lvbignKionLCBsZWZ0LCByaWdodCkpO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgcmV0dXJuIGV4cHI7XHJcblx0ICAgIH07XHJcblx0ICAgIC8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLWV4cC1vcGVyYXRvclxyXG5cdCAgICAvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1tdWx0aXBsaWNhdGl2ZS1vcGVyYXRvcnNcclxuXHQgICAgLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtYWRkaXRpdmUtb3BlcmF0b3JzXHJcblx0ICAgIC8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLWJpdHdpc2Utc2hpZnQtb3BlcmF0b3JzXHJcblx0ICAgIC8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLXJlbGF0aW9uYWwtb3BlcmF0b3JzXHJcblx0ICAgIC8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLWVxdWFsaXR5LW9wZXJhdG9yc1xyXG5cdCAgICAvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1iaW5hcnktYml0d2lzZS1vcGVyYXRvcnNcclxuXHQgICAgLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtYmluYXJ5LWxvZ2ljYWwtb3BlcmF0b3JzXHJcblx0ICAgIFBhcnNlci5wcm90b3R5cGUuYmluYXJ5UHJlY2VkZW5jZSA9IGZ1bmN0aW9uICh0b2tlbikge1xyXG5cdCAgICAgICAgdmFyIG9wID0gdG9rZW4udmFsdWU7XHJcblx0ICAgICAgICB2YXIgcHJlY2VkZW5jZTtcclxuXHQgICAgICAgIGlmICh0b2tlbi50eXBlID09PSA3IC8qIFB1bmN0dWF0b3IgKi8pIHtcclxuXHQgICAgICAgICAgICBwcmVjZWRlbmNlID0gdGhpcy5vcGVyYXRvclByZWNlZGVuY2Vbb3BdIHx8IDA7XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICBlbHNlIGlmICh0b2tlbi50eXBlID09PSA0IC8qIEtleXdvcmQgKi8pIHtcclxuXHQgICAgICAgICAgICBwcmVjZWRlbmNlID0gKG9wID09PSAnaW5zdGFuY2VvZicgfHwgKHRoaXMuY29udGV4dC5hbGxvd0luICYmIG9wID09PSAnaW4nKSkgPyA3IDogMDtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIGVsc2Uge1xyXG5cdCAgICAgICAgICAgIHByZWNlZGVuY2UgPSAwO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgcmV0dXJuIHByZWNlZGVuY2U7XHJcblx0ICAgIH07XHJcblx0ICAgIFBhcnNlci5wcm90b3R5cGUucGFyc2VCaW5hcnlFeHByZXNzaW9uID0gZnVuY3Rpb24gKCkge1xyXG5cdCAgICAgICAgdmFyIHN0YXJ0VG9rZW4gPSB0aGlzLmxvb2thaGVhZDtcclxuXHQgICAgICAgIHZhciBleHByID0gdGhpcy5pbmhlcml0Q292ZXJHcmFtbWFyKHRoaXMucGFyc2VFeHBvbmVudGlhdGlvbkV4cHJlc3Npb24pO1xyXG5cdCAgICAgICAgdmFyIHRva2VuID0gdGhpcy5sb29rYWhlYWQ7XHJcblx0ICAgICAgICB2YXIgcHJlYyA9IHRoaXMuYmluYXJ5UHJlY2VkZW5jZSh0b2tlbik7XHJcblx0ICAgICAgICBpZiAocHJlYyA+IDApIHtcclxuXHQgICAgICAgICAgICB0aGlzLm5leHRUb2tlbigpO1xyXG5cdCAgICAgICAgICAgIHRoaXMuY29udGV4dC5pc0Fzc2lnbm1lbnRUYXJnZXQgPSBmYWxzZTtcclxuXHQgICAgICAgICAgICB0aGlzLmNvbnRleHQuaXNCaW5kaW5nRWxlbWVudCA9IGZhbHNlO1xyXG5cdCAgICAgICAgICAgIHZhciBtYXJrZXJzID0gW3N0YXJ0VG9rZW4sIHRoaXMubG9va2FoZWFkXTtcclxuXHQgICAgICAgICAgICB2YXIgbGVmdCA9IGV4cHI7XHJcblx0ICAgICAgICAgICAgdmFyIHJpZ2h0ID0gdGhpcy5pc29sYXRlQ292ZXJHcmFtbWFyKHRoaXMucGFyc2VFeHBvbmVudGlhdGlvbkV4cHJlc3Npb24pO1xyXG5cdCAgICAgICAgICAgIHZhciBzdGFjayA9IFtsZWZ0LCB0b2tlbi52YWx1ZSwgcmlnaHRdO1xyXG5cdCAgICAgICAgICAgIHZhciBwcmVjZWRlbmNlcyA9IFtwcmVjXTtcclxuXHQgICAgICAgICAgICB3aGlsZSAodHJ1ZSkge1xyXG5cdCAgICAgICAgICAgICAgICBwcmVjID0gdGhpcy5iaW5hcnlQcmVjZWRlbmNlKHRoaXMubG9va2FoZWFkKTtcclxuXHQgICAgICAgICAgICAgICAgaWYgKHByZWMgPD0gMCkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcblx0ICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgLy8gUmVkdWNlOiBtYWtlIGEgYmluYXJ5IGV4cHJlc3Npb24gZnJvbSB0aGUgdGhyZWUgdG9wbW9zdCBlbnRyaWVzLlxyXG5cdCAgICAgICAgICAgICAgICB3aGlsZSAoKHN0YWNrLmxlbmd0aCA+IDIpICYmIChwcmVjIDw9IHByZWNlZGVuY2VzW3ByZWNlZGVuY2VzLmxlbmd0aCAtIDFdKSkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgcmlnaHQgPSBzdGFjay5wb3AoKTtcclxuXHQgICAgICAgICAgICAgICAgICAgIHZhciBvcGVyYXRvciA9IHN0YWNrLnBvcCgpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgcHJlY2VkZW5jZXMucG9wKCk7XHJcblx0ICAgICAgICAgICAgICAgICAgICBsZWZ0ID0gc3RhY2sucG9wKCk7XHJcblx0ICAgICAgICAgICAgICAgICAgICBtYXJrZXJzLnBvcCgpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZShtYXJrZXJzW21hcmtlcnMubGVuZ3RoIC0gMV0pO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgc3RhY2sucHVzaCh0aGlzLmZpbmFsaXplKG5vZGUsIG5ldyBOb2RlLkJpbmFyeUV4cHJlc3Npb24ob3BlcmF0b3IsIGxlZnQsIHJpZ2h0KSkpO1xyXG5cdCAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgIC8vIFNoaWZ0LlxyXG5cdCAgICAgICAgICAgICAgICBzdGFjay5wdXNoKHRoaXMubmV4dFRva2VuKCkudmFsdWUpO1xyXG5cdCAgICAgICAgICAgICAgICBwcmVjZWRlbmNlcy5wdXNoKHByZWMpO1xyXG5cdCAgICAgICAgICAgICAgICBtYXJrZXJzLnB1c2godGhpcy5sb29rYWhlYWQpO1xyXG5cdCAgICAgICAgICAgICAgICBzdGFjay5wdXNoKHRoaXMuaXNvbGF0ZUNvdmVyR3JhbW1hcih0aGlzLnBhcnNlRXhwb25lbnRpYXRpb25FeHByZXNzaW9uKSk7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgIC8vIEZpbmFsIHJlZHVjZSB0byBjbGVhbi11cCB0aGUgc3RhY2suXHJcblx0ICAgICAgICAgICAgdmFyIGkgPSBzdGFjay5sZW5ndGggLSAxO1xyXG5cdCAgICAgICAgICAgIGV4cHIgPSBzdGFja1tpXTtcclxuXHQgICAgICAgICAgICBtYXJrZXJzLnBvcCgpO1xyXG5cdCAgICAgICAgICAgIHdoaWxlIChpID4gMSkge1xyXG5cdCAgICAgICAgICAgICAgICB2YXIgbm9kZSA9IHRoaXMuc3RhcnROb2RlKG1hcmtlcnMucG9wKCkpO1xyXG5cdCAgICAgICAgICAgICAgICB2YXIgb3BlcmF0b3IgPSBzdGFja1tpIC0gMV07XHJcblx0ICAgICAgICAgICAgICAgIGV4cHIgPSB0aGlzLmZpbmFsaXplKG5vZGUsIG5ldyBOb2RlLkJpbmFyeUV4cHJlc3Npb24ob3BlcmF0b3IsIHN0YWNrW2kgLSAyXSwgZXhwcikpO1xyXG5cdCAgICAgICAgICAgICAgICBpIC09IDI7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgcmV0dXJuIGV4cHI7XHJcblx0ICAgIH07XHJcblx0ICAgIC8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLWNvbmRpdGlvbmFsLW9wZXJhdG9yXHJcblx0ICAgIFBhcnNlci5wcm90b3R5cGUucGFyc2VDb25kaXRpb25hbEV4cHJlc3Npb24gPSBmdW5jdGlvbiAoKSB7XHJcblx0ICAgICAgICB2YXIgc3RhcnRUb2tlbiA9IHRoaXMubG9va2FoZWFkO1xyXG5cdCAgICAgICAgdmFyIGV4cHIgPSB0aGlzLmluaGVyaXRDb3ZlckdyYW1tYXIodGhpcy5wYXJzZUJpbmFyeUV4cHJlc3Npb24pO1xyXG5cdCAgICAgICAgaWYgKHRoaXMubWF0Y2goJz8nKSkge1xyXG5cdCAgICAgICAgICAgIHRoaXMubmV4dFRva2VuKCk7XHJcblx0ICAgICAgICAgICAgdmFyIHByZXZpb3VzQWxsb3dJbiA9IHRoaXMuY29udGV4dC5hbGxvd0luO1xyXG5cdCAgICAgICAgICAgIHRoaXMuY29udGV4dC5hbGxvd0luID0gdHJ1ZTtcclxuXHQgICAgICAgICAgICB2YXIgY29uc2VxdWVudCA9IHRoaXMuaXNvbGF0ZUNvdmVyR3JhbW1hcih0aGlzLnBhcnNlQXNzaWdubWVudEV4cHJlc3Npb24pO1xyXG5cdCAgICAgICAgICAgIHRoaXMuY29udGV4dC5hbGxvd0luID0gcHJldmlvdXNBbGxvd0luO1xyXG5cdCAgICAgICAgICAgIHRoaXMuZXhwZWN0KCc6Jyk7XHJcblx0ICAgICAgICAgICAgdmFyIGFsdGVybmF0ZSA9IHRoaXMuaXNvbGF0ZUNvdmVyR3JhbW1hcih0aGlzLnBhcnNlQXNzaWdubWVudEV4cHJlc3Npb24pO1xyXG5cdCAgICAgICAgICAgIGV4cHIgPSB0aGlzLmZpbmFsaXplKHRoaXMuc3RhcnROb2RlKHN0YXJ0VG9rZW4pLCBuZXcgTm9kZS5Db25kaXRpb25hbEV4cHJlc3Npb24oZXhwciwgY29uc2VxdWVudCwgYWx0ZXJuYXRlKSk7XHJcblx0ICAgICAgICAgICAgdGhpcy5jb250ZXh0LmlzQXNzaWdubWVudFRhcmdldCA9IGZhbHNlO1xyXG5cdCAgICAgICAgICAgIHRoaXMuY29udGV4dC5pc0JpbmRpbmdFbGVtZW50ID0gZmFsc2U7XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICByZXR1cm4gZXhwcjtcclxuXHQgICAgfTtcclxuXHQgICAgLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtYXNzaWdubWVudC1vcGVyYXRvcnNcclxuXHQgICAgUGFyc2VyLnByb3RvdHlwZS5jaGVja1BhdHRlcm5QYXJhbSA9IGZ1bmN0aW9uIChvcHRpb25zLCBwYXJhbSkge1xyXG5cdCAgICAgICAgc3dpdGNoIChwYXJhbS50eXBlKSB7XHJcblx0ICAgICAgICAgICAgY2FzZSBzeW50YXhfMS5TeW50YXguSWRlbnRpZmllcjpcclxuXHQgICAgICAgICAgICAgICAgdGhpcy52YWxpZGF0ZVBhcmFtKG9wdGlvbnMsIHBhcmFtLCBwYXJhbS5uYW1lKTtcclxuXHQgICAgICAgICAgICAgICAgYnJlYWs7XHJcblx0ICAgICAgICAgICAgY2FzZSBzeW50YXhfMS5TeW50YXguUmVzdEVsZW1lbnQ6XHJcblx0ICAgICAgICAgICAgICAgIHRoaXMuY2hlY2tQYXR0ZXJuUGFyYW0ob3B0aW9ucywgcGFyYW0uYXJndW1lbnQpO1xyXG5cdCAgICAgICAgICAgICAgICBicmVhaztcclxuXHQgICAgICAgICAgICBjYXNlIHN5bnRheF8xLlN5bnRheC5Bc3NpZ25tZW50UGF0dGVybjpcclxuXHQgICAgICAgICAgICAgICAgdGhpcy5jaGVja1BhdHRlcm5QYXJhbShvcHRpb25zLCBwYXJhbS5sZWZ0KTtcclxuXHQgICAgICAgICAgICAgICAgYnJlYWs7XHJcblx0ICAgICAgICAgICAgY2FzZSBzeW50YXhfMS5TeW50YXguQXJyYXlQYXR0ZXJuOlxyXG5cdCAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBhcmFtLmVsZW1lbnRzLmxlbmd0aDsgaSsrKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICBpZiAocGFyYW0uZWxlbWVudHNbaV0gIT09IG51bGwpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmNoZWNrUGF0dGVyblBhcmFtKG9wdGlvbnMsIHBhcmFtLmVsZW1lbnRzW2ldKTtcclxuXHQgICAgICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICBicmVhaztcclxuXHQgICAgICAgICAgICBjYXNlIHN5bnRheF8xLlN5bnRheC5PYmplY3RQYXR0ZXJuOlxyXG5cdCAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBhcmFtLnByb3BlcnRpZXMubGVuZ3RoOyBpKyspIHtcclxuXHQgICAgICAgICAgICAgICAgICAgIHRoaXMuY2hlY2tQYXR0ZXJuUGFyYW0ob3B0aW9ucywgcGFyYW0ucHJvcGVydGllc1tpXS52YWx1ZSk7XHJcblx0ICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgYnJlYWs7XHJcblx0ICAgICAgICAgICAgZGVmYXVsdDpcclxuXHQgICAgICAgICAgICAgICAgYnJlYWs7XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICBvcHRpb25zLnNpbXBsZSA9IG9wdGlvbnMuc2ltcGxlICYmIChwYXJhbSBpbnN0YW5jZW9mIE5vZGUuSWRlbnRpZmllcik7XHJcblx0ICAgIH07XHJcblx0ICAgIFBhcnNlci5wcm90b3R5cGUucmVpbnRlcnByZXRBc0NvdmVyRm9ybWFsc0xpc3QgPSBmdW5jdGlvbiAoZXhwcikge1xyXG5cdCAgICAgICAgdmFyIHBhcmFtcyA9IFtleHByXTtcclxuXHQgICAgICAgIHZhciBvcHRpb25zO1xyXG5cdCAgICAgICAgdmFyIGFzeW5jQXJyb3cgPSBmYWxzZTtcclxuXHQgICAgICAgIHN3aXRjaCAoZXhwci50eXBlKSB7XHJcblx0ICAgICAgICAgICAgY2FzZSBzeW50YXhfMS5TeW50YXguSWRlbnRpZmllcjpcclxuXHQgICAgICAgICAgICAgICAgYnJlYWs7XHJcblx0ICAgICAgICAgICAgY2FzZSBBcnJvd1BhcmFtZXRlclBsYWNlSG9sZGVyOlxyXG5cdCAgICAgICAgICAgICAgICBwYXJhbXMgPSBleHByLnBhcmFtcztcclxuXHQgICAgICAgICAgICAgICAgYXN5bmNBcnJvdyA9IGV4cHIuYXN5bmM7XHJcblx0ICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cdCAgICAgICAgICAgIGRlZmF1bHQ6XHJcblx0ICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgb3B0aW9ucyA9IHtcclxuXHQgICAgICAgICAgICBzaW1wbGU6IHRydWUsXHJcblx0ICAgICAgICAgICAgcGFyYW1TZXQ6IHt9XHJcblx0ICAgICAgICB9O1xyXG5cdCAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwYXJhbXMubGVuZ3RoOyArK2kpIHtcclxuXHQgICAgICAgICAgICB2YXIgcGFyYW0gPSBwYXJhbXNbaV07XHJcblx0ICAgICAgICAgICAgaWYgKHBhcmFtLnR5cGUgPT09IHN5bnRheF8xLlN5bnRheC5Bc3NpZ25tZW50UGF0dGVybikge1xyXG5cdCAgICAgICAgICAgICAgICBpZiAocGFyYW0ucmlnaHQudHlwZSA9PT0gc3ludGF4XzEuU3ludGF4LllpZWxkRXhwcmVzc2lvbikge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKHBhcmFtLnJpZ2h0LmFyZ3VtZW50KSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy50aHJvd1VuZXhwZWN0ZWRUb2tlbih0aGlzLmxvb2thaGVhZCk7XHJcblx0ICAgICAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgICAgICBwYXJhbS5yaWdodC50eXBlID0gc3ludGF4XzEuU3ludGF4LklkZW50aWZpZXI7XHJcblx0ICAgICAgICAgICAgICAgICAgICBwYXJhbS5yaWdodC5uYW1lID0gJ3lpZWxkJztcclxuXHQgICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBwYXJhbS5yaWdodC5hcmd1bWVudDtcclxuXHQgICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBwYXJhbS5yaWdodC5kZWxlZ2F0ZTtcclxuXHQgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICBlbHNlIGlmIChhc3luY0Fycm93ICYmIHBhcmFtLnR5cGUgPT09IHN5bnRheF8xLlN5bnRheC5JZGVudGlmaWVyICYmIHBhcmFtLm5hbWUgPT09ICdhd2FpdCcpIHtcclxuXHQgICAgICAgICAgICAgICAgdGhpcy50aHJvd1VuZXhwZWN0ZWRUb2tlbih0aGlzLmxvb2thaGVhZCk7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgIHRoaXMuY2hlY2tQYXR0ZXJuUGFyYW0ob3B0aW9ucywgcGFyYW0pO1xyXG5cdCAgICAgICAgICAgIHBhcmFtc1tpXSA9IHBhcmFtO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgaWYgKHRoaXMuY29udGV4dC5zdHJpY3QgfHwgIXRoaXMuY29udGV4dC5hbGxvd1lpZWxkKSB7XHJcblx0ICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwYXJhbXMubGVuZ3RoOyArK2kpIHtcclxuXHQgICAgICAgICAgICAgICAgdmFyIHBhcmFtID0gcGFyYW1zW2ldO1xyXG5cdCAgICAgICAgICAgICAgICBpZiAocGFyYW0udHlwZSA9PT0gc3ludGF4XzEuU3ludGF4LllpZWxkRXhwcmVzc2lvbikge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgdGhpcy50aHJvd1VuZXhwZWN0ZWRUb2tlbih0aGlzLmxvb2thaGVhZCk7XHJcblx0ICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICBpZiAob3B0aW9ucy5tZXNzYWdlID09PSBtZXNzYWdlc18xLk1lc3NhZ2VzLlN0cmljdFBhcmFtRHVwZSkge1xyXG5cdCAgICAgICAgICAgIHZhciB0b2tlbiA9IHRoaXMuY29udGV4dC5zdHJpY3QgPyBvcHRpb25zLnN0cmljdGVkIDogb3B0aW9ucy5maXJzdFJlc3RyaWN0ZWQ7XHJcblx0ICAgICAgICAgICAgdGhpcy50aHJvd1VuZXhwZWN0ZWRUb2tlbih0b2tlbiwgb3B0aW9ucy5tZXNzYWdlKTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIHJldHVybiB7XHJcblx0ICAgICAgICAgICAgc2ltcGxlOiBvcHRpb25zLnNpbXBsZSxcclxuXHQgICAgICAgICAgICBwYXJhbXM6IHBhcmFtcyxcclxuXHQgICAgICAgICAgICBzdHJpY3RlZDogb3B0aW9ucy5zdHJpY3RlZCxcclxuXHQgICAgICAgICAgICBmaXJzdFJlc3RyaWN0ZWQ6IG9wdGlvbnMuZmlyc3RSZXN0cmljdGVkLFxyXG5cdCAgICAgICAgICAgIG1lc3NhZ2U6IG9wdGlvbnMubWVzc2FnZVxyXG5cdCAgICAgICAgfTtcclxuXHQgICAgfTtcclxuXHQgICAgUGFyc2VyLnByb3RvdHlwZS5wYXJzZUFzc2lnbm1lbnRFeHByZXNzaW9uID0gZnVuY3Rpb24gKCkge1xyXG5cdCAgICAgICAgdmFyIGV4cHI7XHJcblx0ICAgICAgICBpZiAoIXRoaXMuY29udGV4dC5hbGxvd1lpZWxkICYmIHRoaXMubWF0Y2hLZXl3b3JkKCd5aWVsZCcpKSB7XHJcblx0ICAgICAgICAgICAgZXhwciA9IHRoaXMucGFyc2VZaWVsZEV4cHJlc3Npb24oKTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIGVsc2Uge1xyXG5cdCAgICAgICAgICAgIHZhciBzdGFydFRva2VuID0gdGhpcy5sb29rYWhlYWQ7XHJcblx0ICAgICAgICAgICAgdmFyIHRva2VuID0gc3RhcnRUb2tlbjtcclxuXHQgICAgICAgICAgICBleHByID0gdGhpcy5wYXJzZUNvbmRpdGlvbmFsRXhwcmVzc2lvbigpO1xyXG5cdCAgICAgICAgICAgIGlmICh0b2tlbi50eXBlID09PSAzIC8qIElkZW50aWZpZXIgKi8gJiYgKHRva2VuLmxpbmVOdW1iZXIgPT09IHRoaXMubG9va2FoZWFkLmxpbmVOdW1iZXIpICYmIHRva2VuLnZhbHVlID09PSAnYXN5bmMnKSB7XHJcblx0ICAgICAgICAgICAgICAgIGlmICh0aGlzLmxvb2thaGVhZC50eXBlID09PSAzIC8qIElkZW50aWZpZXIgKi8gfHwgdGhpcy5tYXRjaEtleXdvcmQoJ3lpZWxkJykpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgIHZhciBhcmcgPSB0aGlzLnBhcnNlUHJpbWFyeUV4cHJlc3Npb24oKTtcclxuXHQgICAgICAgICAgICAgICAgICAgIHRoaXMucmVpbnRlcnByZXRFeHByZXNzaW9uQXNQYXR0ZXJuKGFyZyk7XHJcblx0ICAgICAgICAgICAgICAgICAgICBleHByID0ge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IEFycm93UGFyYW1ldGVyUGxhY2VIb2xkZXIsXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcGFyYW1zOiBbYXJnXSxcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBhc3luYzogdHJ1ZVxyXG5cdCAgICAgICAgICAgICAgICAgICAgfTtcclxuXHQgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICBpZiAoZXhwci50eXBlID09PSBBcnJvd1BhcmFtZXRlclBsYWNlSG9sZGVyIHx8IHRoaXMubWF0Y2goJz0+JykpIHtcclxuXHQgICAgICAgICAgICAgICAgLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtYXJyb3ctZnVuY3Rpb24tZGVmaW5pdGlvbnNcclxuXHQgICAgICAgICAgICAgICAgdGhpcy5jb250ZXh0LmlzQXNzaWdubWVudFRhcmdldCA9IGZhbHNlO1xyXG5cdCAgICAgICAgICAgICAgICB0aGlzLmNvbnRleHQuaXNCaW5kaW5nRWxlbWVudCA9IGZhbHNlO1xyXG5cdCAgICAgICAgICAgICAgICB2YXIgaXNBc3luYyA9IGV4cHIuYXN5bmM7XHJcblx0ICAgICAgICAgICAgICAgIHZhciBsaXN0ID0gdGhpcy5yZWludGVycHJldEFzQ292ZXJGb3JtYWxzTGlzdChleHByKTtcclxuXHQgICAgICAgICAgICAgICAgaWYgKGxpc3QpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmhhc0xpbmVUZXJtaW5hdG9yKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy50b2xlcmF0ZVVuZXhwZWN0ZWRUb2tlbih0aGlzLmxvb2thaGVhZCk7XHJcblx0ICAgICAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbnRleHQuZmlyc3RDb3ZlckluaXRpYWxpemVkTmFtZUVycm9yID0gbnVsbDtcclxuXHQgICAgICAgICAgICAgICAgICAgIHZhciBwcmV2aW91c1N0cmljdCA9IHRoaXMuY29udGV4dC5zdHJpY3Q7XHJcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgcHJldmlvdXNBbGxvd1N0cmljdERpcmVjdGl2ZSA9IHRoaXMuY29udGV4dC5hbGxvd1N0cmljdERpcmVjdGl2ZTtcclxuXHQgICAgICAgICAgICAgICAgICAgIHRoaXMuY29udGV4dC5hbGxvd1N0cmljdERpcmVjdGl2ZSA9IGxpc3Quc2ltcGxlO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIHByZXZpb3VzQWxsb3dZaWVsZCA9IHRoaXMuY29udGV4dC5hbGxvd1lpZWxkO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIHByZXZpb3VzQXdhaXQgPSB0aGlzLmNvbnRleHQuYXdhaXQ7XHJcblx0ICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbnRleHQuYWxsb3dZaWVsZCA9IHRydWU7XHJcblx0ICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbnRleHQuYXdhaXQgPSBpc0FzeW5jO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZShzdGFydFRva2VuKTtcclxuXHQgICAgICAgICAgICAgICAgICAgIHRoaXMuZXhwZWN0KCc9PicpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIGJvZHkgPSB2b2lkIDA7XHJcblx0ICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5tYXRjaCgneycpKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHByZXZpb3VzQWxsb3dJbiA9IHRoaXMuY29udGV4dC5hbGxvd0luO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY29udGV4dC5hbGxvd0luID0gdHJ1ZTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBib2R5ID0gdGhpcy5wYXJzZUZ1bmN0aW9uU291cmNlRWxlbWVudHMoKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbnRleHQuYWxsb3dJbiA9IHByZXZpb3VzQWxsb3dJbjtcclxuXHQgICAgICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGJvZHkgPSB0aGlzLmlzb2xhdGVDb3ZlckdyYW1tYXIodGhpcy5wYXJzZUFzc2lnbm1lbnRFeHByZXNzaW9uKTtcclxuXHQgICAgICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgICAgIHZhciBleHByZXNzaW9uID0gYm9keS50eXBlICE9PSBzeW50YXhfMS5TeW50YXguQmxvY2tTdGF0ZW1lbnQ7XHJcblx0ICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5jb250ZXh0LnN0cmljdCAmJiBsaXN0LmZpcnN0UmVzdHJpY3RlZCkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMudGhyb3dVbmV4cGVjdGVkVG9rZW4obGlzdC5maXJzdFJlc3RyaWN0ZWQsIGxpc3QubWVzc2FnZSk7XHJcblx0ICAgICAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5jb250ZXh0LnN0cmljdCAmJiBsaXN0LnN0cmljdGVkKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy50b2xlcmF0ZVVuZXhwZWN0ZWRUb2tlbihsaXN0LnN0cmljdGVkLCBsaXN0Lm1lc3NhZ2UpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICAgICAgZXhwciA9IGlzQXN5bmMgPyB0aGlzLmZpbmFsaXplKG5vZGUsIG5ldyBOb2RlLkFzeW5jQXJyb3dGdW5jdGlvbkV4cHJlc3Npb24obGlzdC5wYXJhbXMsIGJvZHksIGV4cHJlc3Npb24pKSA6XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5maW5hbGl6ZShub2RlLCBuZXcgTm9kZS5BcnJvd0Z1bmN0aW9uRXhwcmVzc2lvbihsaXN0LnBhcmFtcywgYm9keSwgZXhwcmVzc2lvbikpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgdGhpcy5jb250ZXh0LnN0cmljdCA9IHByZXZpb3VzU3RyaWN0O1xyXG5cdCAgICAgICAgICAgICAgICAgICAgdGhpcy5jb250ZXh0LmFsbG93U3RyaWN0RGlyZWN0aXZlID0gcHJldmlvdXNBbGxvd1N0cmljdERpcmVjdGl2ZTtcclxuXHQgICAgICAgICAgICAgICAgICAgIHRoaXMuY29udGV4dC5hbGxvd1lpZWxkID0gcHJldmlvdXNBbGxvd1lpZWxkO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgdGhpcy5jb250ZXh0LmF3YWl0ID0gcHJldmlvdXNBd2FpdDtcclxuXHQgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICBlbHNlIHtcclxuXHQgICAgICAgICAgICAgICAgaWYgKHRoaXMubWF0Y2hBc3NpZ24oKSkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKCF0aGlzLmNvbnRleHQuaXNBc3NpZ25tZW50VGFyZ2V0KSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy50b2xlcmF0ZUVycm9yKG1lc3NhZ2VzXzEuTWVzc2FnZXMuSW52YWxpZExIU0luQXNzaWdubWVudCk7XHJcblx0ICAgICAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5jb250ZXh0LnN0cmljdCAmJiBleHByLnR5cGUgPT09IHN5bnRheF8xLlN5bnRheC5JZGVudGlmaWVyKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGlkID0gZXhwcjtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5zY2FubmVyLmlzUmVzdHJpY3RlZFdvcmQoaWQubmFtZSkpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy50b2xlcmF0ZVVuZXhwZWN0ZWRUb2tlbih0b2tlbiwgbWVzc2FnZXNfMS5NZXNzYWdlcy5TdHJpY3RMSFNBc3NpZ25tZW50KTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuc2Nhbm5lci5pc1N0cmljdE1vZGVSZXNlcnZlZFdvcmQoaWQubmFtZSkpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy50b2xlcmF0ZVVuZXhwZWN0ZWRUb2tlbih0b2tlbiwgbWVzc2FnZXNfMS5NZXNzYWdlcy5TdHJpY3RSZXNlcnZlZFdvcmQpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgICAgIGlmICghdGhpcy5tYXRjaCgnPScpKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jb250ZXh0LmlzQXNzaWdubWVudFRhcmdldCA9IGZhbHNlO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY29udGV4dC5pc0JpbmRpbmdFbGVtZW50ID0gZmFsc2U7XHJcblx0ICAgICAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnJlaW50ZXJwcmV0RXhwcmVzc2lvbkFzUGF0dGVybihleHByKTtcclxuXHQgICAgICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgICAgIHRva2VuID0gdGhpcy5uZXh0VG9rZW4oKTtcclxuXHQgICAgICAgICAgICAgICAgICAgIHZhciBvcGVyYXRvciA9IHRva2VuLnZhbHVlO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIHJpZ2h0ID0gdGhpcy5pc29sYXRlQ292ZXJHcmFtbWFyKHRoaXMucGFyc2VBc3NpZ25tZW50RXhwcmVzc2lvbik7XHJcblx0ICAgICAgICAgICAgICAgICAgICBleHByID0gdGhpcy5maW5hbGl6ZSh0aGlzLnN0YXJ0Tm9kZShzdGFydFRva2VuKSwgbmV3IE5vZGUuQXNzaWdubWVudEV4cHJlc3Npb24ob3BlcmF0b3IsIGV4cHIsIHJpZ2h0KSk7XHJcblx0ICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbnRleHQuZmlyc3RDb3ZlckluaXRpYWxpemVkTmFtZUVycm9yID0gbnVsbDtcclxuXHQgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIHJldHVybiBleHByO1xyXG5cdCAgICB9O1xyXG5cdCAgICAvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1jb21tYS1vcGVyYXRvclxyXG5cdCAgICBQYXJzZXIucHJvdG90eXBlLnBhcnNlRXhwcmVzc2lvbiA9IGZ1bmN0aW9uICgpIHtcclxuXHQgICAgICAgIHZhciBzdGFydFRva2VuID0gdGhpcy5sb29rYWhlYWQ7XHJcblx0ICAgICAgICB2YXIgZXhwciA9IHRoaXMuaXNvbGF0ZUNvdmVyR3JhbW1hcih0aGlzLnBhcnNlQXNzaWdubWVudEV4cHJlc3Npb24pO1xyXG5cdCAgICAgICAgaWYgKHRoaXMubWF0Y2goJywnKSkge1xyXG5cdCAgICAgICAgICAgIHZhciBleHByZXNzaW9ucyA9IFtdO1xyXG5cdCAgICAgICAgICAgIGV4cHJlc3Npb25zLnB1c2goZXhwcik7XHJcblx0ICAgICAgICAgICAgd2hpbGUgKHRoaXMubG9va2FoZWFkLnR5cGUgIT09IDIgLyogRU9GICovKSB7XHJcblx0ICAgICAgICAgICAgICAgIGlmICghdGhpcy5tYXRjaCgnLCcpKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuXHQgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICB0aGlzLm5leHRUb2tlbigpO1xyXG5cdCAgICAgICAgICAgICAgICBleHByZXNzaW9ucy5wdXNoKHRoaXMuaXNvbGF0ZUNvdmVyR3JhbW1hcih0aGlzLnBhcnNlQXNzaWdubWVudEV4cHJlc3Npb24pKTtcclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgZXhwciA9IHRoaXMuZmluYWxpemUodGhpcy5zdGFydE5vZGUoc3RhcnRUb2tlbiksIG5ldyBOb2RlLlNlcXVlbmNlRXhwcmVzc2lvbihleHByZXNzaW9ucykpO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgcmV0dXJuIGV4cHI7XHJcblx0ICAgIH07XHJcblx0ICAgIC8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLWJsb2NrXHJcblx0ICAgIFBhcnNlci5wcm90b3R5cGUucGFyc2VTdGF0ZW1lbnRMaXN0SXRlbSA9IGZ1bmN0aW9uICgpIHtcclxuXHQgICAgICAgIHZhciBzdGF0ZW1lbnQ7XHJcblx0ICAgICAgICB0aGlzLmNvbnRleHQuaXNBc3NpZ25tZW50VGFyZ2V0ID0gdHJ1ZTtcclxuXHQgICAgICAgIHRoaXMuY29udGV4dC5pc0JpbmRpbmdFbGVtZW50ID0gdHJ1ZTtcclxuXHQgICAgICAgIGlmICh0aGlzLmxvb2thaGVhZC50eXBlID09PSA0IC8qIEtleXdvcmQgKi8pIHtcclxuXHQgICAgICAgICAgICBzd2l0Y2ggKHRoaXMubG9va2FoZWFkLnZhbHVlKSB7XHJcblx0ICAgICAgICAgICAgICAgIGNhc2UgJ2V4cG9ydCc6XHJcblx0ICAgICAgICAgICAgICAgICAgICBpZiAoIXRoaXMuY29udGV4dC5pc01vZHVsZSkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMudG9sZXJhdGVVbmV4cGVjdGVkVG9rZW4odGhpcy5sb29rYWhlYWQsIG1lc3NhZ2VzXzEuTWVzc2FnZXMuSWxsZWdhbEV4cG9ydERlY2xhcmF0aW9uKTtcclxuXHQgICAgICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgICAgIHN0YXRlbWVudCA9IHRoaXMucGFyc2VFeHBvcnREZWNsYXJhdGlvbigpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcblx0ICAgICAgICAgICAgICAgIGNhc2UgJ2ltcG9ydCc6XHJcblx0ICAgICAgICAgICAgICAgICAgICBpZiAoIXRoaXMuY29udGV4dC5pc01vZHVsZSkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMudG9sZXJhdGVVbmV4cGVjdGVkVG9rZW4odGhpcy5sb29rYWhlYWQsIG1lc3NhZ2VzXzEuTWVzc2FnZXMuSWxsZWdhbEltcG9ydERlY2xhcmF0aW9uKTtcclxuXHQgICAgICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgICAgIHN0YXRlbWVudCA9IHRoaXMucGFyc2VJbXBvcnREZWNsYXJhdGlvbigpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcblx0ICAgICAgICAgICAgICAgIGNhc2UgJ2NvbnN0JzpcclxuXHQgICAgICAgICAgICAgICAgICAgIHN0YXRlbWVudCA9IHRoaXMucGFyc2VMZXhpY2FsRGVjbGFyYXRpb24oeyBpbkZvcjogZmFsc2UgfSk7XHJcblx0ICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuXHQgICAgICAgICAgICAgICAgY2FzZSAnZnVuY3Rpb24nOlxyXG5cdCAgICAgICAgICAgICAgICAgICAgc3RhdGVtZW50ID0gdGhpcy5wYXJzZUZ1bmN0aW9uRGVjbGFyYXRpb24oKTtcclxuXHQgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cdCAgICAgICAgICAgICAgICBjYXNlICdjbGFzcyc6XHJcblx0ICAgICAgICAgICAgICAgICAgICBzdGF0ZW1lbnQgPSB0aGlzLnBhcnNlQ2xhc3NEZWNsYXJhdGlvbigpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcblx0ICAgICAgICAgICAgICAgIGNhc2UgJ2xldCc6XHJcblx0ICAgICAgICAgICAgICAgICAgICBzdGF0ZW1lbnQgPSB0aGlzLmlzTGV4aWNhbERlY2xhcmF0aW9uKCkgPyB0aGlzLnBhcnNlTGV4aWNhbERlY2xhcmF0aW9uKHsgaW5Gb3I6IGZhbHNlIH0pIDogdGhpcy5wYXJzZVN0YXRlbWVudCgpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcblx0ICAgICAgICAgICAgICAgIGRlZmF1bHQ6XHJcblx0ICAgICAgICAgICAgICAgICAgICBzdGF0ZW1lbnQgPSB0aGlzLnBhcnNlU3RhdGVtZW50KCk7XHJcblx0ICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICBlbHNlIHtcclxuXHQgICAgICAgICAgICBzdGF0ZW1lbnQgPSB0aGlzLnBhcnNlU3RhdGVtZW50KCk7XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICByZXR1cm4gc3RhdGVtZW50O1xyXG5cdCAgICB9O1xyXG5cdCAgICBQYXJzZXIucHJvdG90eXBlLnBhcnNlQmxvY2sgPSBmdW5jdGlvbiAoKSB7XHJcblx0ICAgICAgICB2YXIgbm9kZSA9IHRoaXMuY3JlYXRlTm9kZSgpO1xyXG5cdCAgICAgICAgdGhpcy5leHBlY3QoJ3snKTtcclxuXHQgICAgICAgIHZhciBibG9jayA9IFtdO1xyXG5cdCAgICAgICAgd2hpbGUgKHRydWUpIHtcclxuXHQgICAgICAgICAgICBpZiAodGhpcy5tYXRjaCgnfScpKSB7XHJcblx0ICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICBibG9jay5wdXNoKHRoaXMucGFyc2VTdGF0ZW1lbnRMaXN0SXRlbSgpKTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIHRoaXMuZXhwZWN0KCd9Jyk7XHJcblx0ICAgICAgICByZXR1cm4gdGhpcy5maW5hbGl6ZShub2RlLCBuZXcgTm9kZS5CbG9ja1N0YXRlbWVudChibG9jaykpO1xyXG5cdCAgICB9O1xyXG5cdCAgICAvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1sZXQtYW5kLWNvbnN0LWRlY2xhcmF0aW9uc1xyXG5cdCAgICBQYXJzZXIucHJvdG90eXBlLnBhcnNlTGV4aWNhbEJpbmRpbmcgPSBmdW5jdGlvbiAoa2luZCwgb3B0aW9ucykge1xyXG5cdCAgICAgICAgdmFyIG5vZGUgPSB0aGlzLmNyZWF0ZU5vZGUoKTtcclxuXHQgICAgICAgIHZhciBwYXJhbXMgPSBbXTtcclxuXHQgICAgICAgIHZhciBpZCA9IHRoaXMucGFyc2VQYXR0ZXJuKHBhcmFtcywga2luZCk7XHJcblx0ICAgICAgICBpZiAodGhpcy5jb250ZXh0LnN0cmljdCAmJiBpZC50eXBlID09PSBzeW50YXhfMS5TeW50YXguSWRlbnRpZmllcikge1xyXG5cdCAgICAgICAgICAgIGlmICh0aGlzLnNjYW5uZXIuaXNSZXN0cmljdGVkV29yZChpZC5uYW1lKSkge1xyXG5cdCAgICAgICAgICAgICAgICB0aGlzLnRvbGVyYXRlRXJyb3IobWVzc2FnZXNfMS5NZXNzYWdlcy5TdHJpY3RWYXJOYW1lKTtcclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICB2YXIgaW5pdCA9IG51bGw7XHJcblx0ICAgICAgICBpZiAoa2luZCA9PT0gJ2NvbnN0Jykge1xyXG5cdCAgICAgICAgICAgIGlmICghdGhpcy5tYXRjaEtleXdvcmQoJ2luJykgJiYgIXRoaXMubWF0Y2hDb250ZXh0dWFsS2V5d29yZCgnb2YnKSkge1xyXG5cdCAgICAgICAgICAgICAgICBpZiAodGhpcy5tYXRjaCgnPScpKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICB0aGlzLm5leHRUb2tlbigpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgaW5pdCA9IHRoaXMuaXNvbGF0ZUNvdmVyR3JhbW1hcih0aGlzLnBhcnNlQXNzaWdubWVudEV4cHJlc3Npb24pO1xyXG5cdCAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgIGVsc2Uge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgdGhpcy50aHJvd0Vycm9yKG1lc3NhZ2VzXzEuTWVzc2FnZXMuRGVjbGFyYXRpb25NaXNzaW5nSW5pdGlhbGl6ZXIsICdjb25zdCcpO1xyXG5cdCAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgZWxzZSBpZiAoKCFvcHRpb25zLmluRm9yICYmIGlkLnR5cGUgIT09IHN5bnRheF8xLlN5bnRheC5JZGVudGlmaWVyKSB8fCB0aGlzLm1hdGNoKCc9JykpIHtcclxuXHQgICAgICAgICAgICB0aGlzLmV4cGVjdCgnPScpO1xyXG5cdCAgICAgICAgICAgIGluaXQgPSB0aGlzLmlzb2xhdGVDb3ZlckdyYW1tYXIodGhpcy5wYXJzZUFzc2lnbm1lbnRFeHByZXNzaW9uKTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIHJldHVybiB0aGlzLmZpbmFsaXplKG5vZGUsIG5ldyBOb2RlLlZhcmlhYmxlRGVjbGFyYXRvcihpZCwgaW5pdCkpO1xyXG5cdCAgICB9O1xyXG5cdCAgICBQYXJzZXIucHJvdG90eXBlLnBhcnNlQmluZGluZ0xpc3QgPSBmdW5jdGlvbiAoa2luZCwgb3B0aW9ucykge1xyXG5cdCAgICAgICAgdmFyIGxpc3QgPSBbdGhpcy5wYXJzZUxleGljYWxCaW5kaW5nKGtpbmQsIG9wdGlvbnMpXTtcclxuXHQgICAgICAgIHdoaWxlICh0aGlzLm1hdGNoKCcsJykpIHtcclxuXHQgICAgICAgICAgICB0aGlzLm5leHRUb2tlbigpO1xyXG5cdCAgICAgICAgICAgIGxpc3QucHVzaCh0aGlzLnBhcnNlTGV4aWNhbEJpbmRpbmcoa2luZCwgb3B0aW9ucykpO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgcmV0dXJuIGxpc3Q7XHJcblx0ICAgIH07XHJcblx0ICAgIFBhcnNlci5wcm90b3R5cGUuaXNMZXhpY2FsRGVjbGFyYXRpb24gPSBmdW5jdGlvbiAoKSB7XHJcblx0ICAgICAgICB2YXIgc3RhdGUgPSB0aGlzLnNjYW5uZXIuc2F2ZVN0YXRlKCk7XHJcblx0ICAgICAgICB0aGlzLnNjYW5uZXIuc2NhbkNvbW1lbnRzKCk7XHJcblx0ICAgICAgICB2YXIgbmV4dCA9IHRoaXMuc2Nhbm5lci5sZXgoKTtcclxuXHQgICAgICAgIHRoaXMuc2Nhbm5lci5yZXN0b3JlU3RhdGUoc3RhdGUpO1xyXG5cdCAgICAgICAgcmV0dXJuIChuZXh0LnR5cGUgPT09IDMgLyogSWRlbnRpZmllciAqLykgfHxcclxuXHQgICAgICAgICAgICAobmV4dC50eXBlID09PSA3IC8qIFB1bmN0dWF0b3IgKi8gJiYgbmV4dC52YWx1ZSA9PT0gJ1snKSB8fFxyXG5cdCAgICAgICAgICAgIChuZXh0LnR5cGUgPT09IDcgLyogUHVuY3R1YXRvciAqLyAmJiBuZXh0LnZhbHVlID09PSAneycpIHx8XHJcblx0ICAgICAgICAgICAgKG5leHQudHlwZSA9PT0gNCAvKiBLZXl3b3JkICovICYmIG5leHQudmFsdWUgPT09ICdsZXQnKSB8fFxyXG5cdCAgICAgICAgICAgIChuZXh0LnR5cGUgPT09IDQgLyogS2V5d29yZCAqLyAmJiBuZXh0LnZhbHVlID09PSAneWllbGQnKTtcclxuXHQgICAgfTtcclxuXHQgICAgUGFyc2VyLnByb3RvdHlwZS5wYXJzZUxleGljYWxEZWNsYXJhdGlvbiA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XHJcblx0ICAgICAgICB2YXIgbm9kZSA9IHRoaXMuY3JlYXRlTm9kZSgpO1xyXG5cdCAgICAgICAgdmFyIGtpbmQgPSB0aGlzLm5leHRUb2tlbigpLnZhbHVlO1xyXG5cdCAgICAgICAgYXNzZXJ0XzEuYXNzZXJ0KGtpbmQgPT09ICdsZXQnIHx8IGtpbmQgPT09ICdjb25zdCcsICdMZXhpY2FsIGRlY2xhcmF0aW9uIG11c3QgYmUgZWl0aGVyIGxldCBvciBjb25zdCcpO1xyXG5cdCAgICAgICAgdmFyIGRlY2xhcmF0aW9ucyA9IHRoaXMucGFyc2VCaW5kaW5nTGlzdChraW5kLCBvcHRpb25zKTtcclxuXHQgICAgICAgIHRoaXMuY29uc3VtZVNlbWljb2xvbigpO1xyXG5cdCAgICAgICAgcmV0dXJuIHRoaXMuZmluYWxpemUobm9kZSwgbmV3IE5vZGUuVmFyaWFibGVEZWNsYXJhdGlvbihkZWNsYXJhdGlvbnMsIGtpbmQpKTtcclxuXHQgICAgfTtcclxuXHQgICAgLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtZGVzdHJ1Y3R1cmluZy1iaW5kaW5nLXBhdHRlcm5zXHJcblx0ICAgIFBhcnNlci5wcm90b3R5cGUucGFyc2VCaW5kaW5nUmVzdEVsZW1lbnQgPSBmdW5jdGlvbiAocGFyYW1zLCBraW5kKSB7XHJcblx0ICAgICAgICB2YXIgbm9kZSA9IHRoaXMuY3JlYXRlTm9kZSgpO1xyXG5cdCAgICAgICAgdGhpcy5leHBlY3QoJy4uLicpO1xyXG5cdCAgICAgICAgdmFyIGFyZyA9IHRoaXMucGFyc2VQYXR0ZXJuKHBhcmFtcywga2luZCk7XHJcblx0ICAgICAgICByZXR1cm4gdGhpcy5maW5hbGl6ZShub2RlLCBuZXcgTm9kZS5SZXN0RWxlbWVudChhcmcpKTtcclxuXHQgICAgfTtcclxuXHQgICAgUGFyc2VyLnByb3RvdHlwZS5wYXJzZUFycmF5UGF0dGVybiA9IGZ1bmN0aW9uIChwYXJhbXMsIGtpbmQpIHtcclxuXHQgICAgICAgIHZhciBub2RlID0gdGhpcy5jcmVhdGVOb2RlKCk7XHJcblx0ICAgICAgICB0aGlzLmV4cGVjdCgnWycpO1xyXG5cdCAgICAgICAgdmFyIGVsZW1lbnRzID0gW107XHJcblx0ICAgICAgICB3aGlsZSAoIXRoaXMubWF0Y2goJ10nKSkge1xyXG5cdCAgICAgICAgICAgIGlmICh0aGlzLm1hdGNoKCcsJykpIHtcclxuXHQgICAgICAgICAgICAgICAgdGhpcy5uZXh0VG9rZW4oKTtcclxuXHQgICAgICAgICAgICAgICAgZWxlbWVudHMucHVzaChudWxsKTtcclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgZWxzZSB7XHJcblx0ICAgICAgICAgICAgICAgIGlmICh0aGlzLm1hdGNoKCcuLi4nKSkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgZWxlbWVudHMucHVzaCh0aGlzLnBhcnNlQmluZGluZ1Jlc3RFbGVtZW50KHBhcmFtcywga2luZCkpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcblx0ICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgZWxzZSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICBlbGVtZW50cy5wdXNoKHRoaXMucGFyc2VQYXR0ZXJuV2l0aERlZmF1bHQocGFyYW1zLCBraW5kKSk7XHJcblx0ICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgaWYgKCF0aGlzLm1hdGNoKCddJykpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgIHRoaXMuZXhwZWN0KCcsJyk7XHJcblx0ICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICB0aGlzLmV4cGVjdCgnXScpO1xyXG5cdCAgICAgICAgcmV0dXJuIHRoaXMuZmluYWxpemUobm9kZSwgbmV3IE5vZGUuQXJyYXlQYXR0ZXJuKGVsZW1lbnRzKSk7XHJcblx0ICAgIH07XHJcblx0ICAgIFBhcnNlci5wcm90b3R5cGUucGFyc2VQcm9wZXJ0eVBhdHRlcm4gPSBmdW5jdGlvbiAocGFyYW1zLCBraW5kKSB7XHJcblx0ICAgICAgICB2YXIgbm9kZSA9IHRoaXMuY3JlYXRlTm9kZSgpO1xyXG5cdCAgICAgICAgdmFyIGNvbXB1dGVkID0gZmFsc2U7XHJcblx0ICAgICAgICB2YXIgc2hvcnRoYW5kID0gZmFsc2U7XHJcblx0ICAgICAgICB2YXIgbWV0aG9kID0gZmFsc2U7XHJcblx0ICAgICAgICB2YXIga2V5O1xyXG5cdCAgICAgICAgdmFyIHZhbHVlO1xyXG5cdCAgICAgICAgaWYgKHRoaXMubG9va2FoZWFkLnR5cGUgPT09IDMgLyogSWRlbnRpZmllciAqLykge1xyXG5cdCAgICAgICAgICAgIHZhciBrZXlUb2tlbiA9IHRoaXMubG9va2FoZWFkO1xyXG5cdCAgICAgICAgICAgIGtleSA9IHRoaXMucGFyc2VWYXJpYWJsZUlkZW50aWZpZXIoKTtcclxuXHQgICAgICAgICAgICB2YXIgaW5pdCA9IHRoaXMuZmluYWxpemUobm9kZSwgbmV3IE5vZGUuSWRlbnRpZmllcihrZXlUb2tlbi52YWx1ZSkpO1xyXG5cdCAgICAgICAgICAgIGlmICh0aGlzLm1hdGNoKCc9JykpIHtcclxuXHQgICAgICAgICAgICAgICAgcGFyYW1zLnB1c2goa2V5VG9rZW4pO1xyXG5cdCAgICAgICAgICAgICAgICBzaG9ydGhhbmQgPSB0cnVlO1xyXG5cdCAgICAgICAgICAgICAgICB0aGlzLm5leHRUb2tlbigpO1xyXG5cdCAgICAgICAgICAgICAgICB2YXIgZXhwciA9IHRoaXMucGFyc2VBc3NpZ25tZW50RXhwcmVzc2lvbigpO1xyXG5cdCAgICAgICAgICAgICAgICB2YWx1ZSA9IHRoaXMuZmluYWxpemUodGhpcy5zdGFydE5vZGUoa2V5VG9rZW4pLCBuZXcgTm9kZS5Bc3NpZ25tZW50UGF0dGVybihpbml0LCBleHByKSk7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgIGVsc2UgaWYgKCF0aGlzLm1hdGNoKCc6JykpIHtcclxuXHQgICAgICAgICAgICAgICAgcGFyYW1zLnB1c2goa2V5VG9rZW4pO1xyXG5cdCAgICAgICAgICAgICAgICBzaG9ydGhhbmQgPSB0cnVlO1xyXG5cdCAgICAgICAgICAgICAgICB2YWx1ZSA9IGluaXQ7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgIGVsc2Uge1xyXG5cdCAgICAgICAgICAgICAgICB0aGlzLmV4cGVjdCgnOicpO1xyXG5cdCAgICAgICAgICAgICAgICB2YWx1ZSA9IHRoaXMucGFyc2VQYXR0ZXJuV2l0aERlZmF1bHQocGFyYW1zLCBraW5kKTtcclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICBlbHNlIHtcclxuXHQgICAgICAgICAgICBjb21wdXRlZCA9IHRoaXMubWF0Y2goJ1snKTtcclxuXHQgICAgICAgICAgICBrZXkgPSB0aGlzLnBhcnNlT2JqZWN0UHJvcGVydHlLZXkoKTtcclxuXHQgICAgICAgICAgICB0aGlzLmV4cGVjdCgnOicpO1xyXG5cdCAgICAgICAgICAgIHZhbHVlID0gdGhpcy5wYXJzZVBhdHRlcm5XaXRoRGVmYXVsdChwYXJhbXMsIGtpbmQpO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgcmV0dXJuIHRoaXMuZmluYWxpemUobm9kZSwgbmV3IE5vZGUuUHJvcGVydHkoJ2luaXQnLCBrZXksIGNvbXB1dGVkLCB2YWx1ZSwgbWV0aG9kLCBzaG9ydGhhbmQpKTtcclxuXHQgICAgfTtcclxuXHQgICAgUGFyc2VyLnByb3RvdHlwZS5wYXJzZU9iamVjdFBhdHRlcm4gPSBmdW5jdGlvbiAocGFyYW1zLCBraW5kKSB7XHJcblx0ICAgICAgICB2YXIgbm9kZSA9IHRoaXMuY3JlYXRlTm9kZSgpO1xyXG5cdCAgICAgICAgdmFyIHByb3BlcnRpZXMgPSBbXTtcclxuXHQgICAgICAgIHRoaXMuZXhwZWN0KCd7Jyk7XHJcblx0ICAgICAgICB3aGlsZSAoIXRoaXMubWF0Y2goJ30nKSkge1xyXG5cdCAgICAgICAgICAgIHByb3BlcnRpZXMucHVzaCh0aGlzLnBhcnNlUHJvcGVydHlQYXR0ZXJuKHBhcmFtcywga2luZCkpO1xyXG5cdCAgICAgICAgICAgIGlmICghdGhpcy5tYXRjaCgnfScpKSB7XHJcblx0ICAgICAgICAgICAgICAgIHRoaXMuZXhwZWN0KCcsJyk7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgdGhpcy5leHBlY3QoJ30nKTtcclxuXHQgICAgICAgIHJldHVybiB0aGlzLmZpbmFsaXplKG5vZGUsIG5ldyBOb2RlLk9iamVjdFBhdHRlcm4ocHJvcGVydGllcykpO1xyXG5cdCAgICB9O1xyXG5cdCAgICBQYXJzZXIucHJvdG90eXBlLnBhcnNlUGF0dGVybiA9IGZ1bmN0aW9uIChwYXJhbXMsIGtpbmQpIHtcclxuXHQgICAgICAgIHZhciBwYXR0ZXJuO1xyXG5cdCAgICAgICAgaWYgKHRoaXMubWF0Y2goJ1snKSkge1xyXG5cdCAgICAgICAgICAgIHBhdHRlcm4gPSB0aGlzLnBhcnNlQXJyYXlQYXR0ZXJuKHBhcmFtcywga2luZCk7XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICBlbHNlIGlmICh0aGlzLm1hdGNoKCd7JykpIHtcclxuXHQgICAgICAgICAgICBwYXR0ZXJuID0gdGhpcy5wYXJzZU9iamVjdFBhdHRlcm4ocGFyYW1zLCBraW5kKTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIGVsc2Uge1xyXG5cdCAgICAgICAgICAgIGlmICh0aGlzLm1hdGNoS2V5d29yZCgnbGV0JykgJiYgKGtpbmQgPT09ICdjb25zdCcgfHwga2luZCA9PT0gJ2xldCcpKSB7XHJcblx0ICAgICAgICAgICAgICAgIHRoaXMudG9sZXJhdGVVbmV4cGVjdGVkVG9rZW4odGhpcy5sb29rYWhlYWQsIG1lc3NhZ2VzXzEuTWVzc2FnZXMuTGV0SW5MZXhpY2FsQmluZGluZyk7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgIHBhcmFtcy5wdXNoKHRoaXMubG9va2FoZWFkKTtcclxuXHQgICAgICAgICAgICBwYXR0ZXJuID0gdGhpcy5wYXJzZVZhcmlhYmxlSWRlbnRpZmllcihraW5kKTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIHJldHVybiBwYXR0ZXJuO1xyXG5cdCAgICB9O1xyXG5cdCAgICBQYXJzZXIucHJvdG90eXBlLnBhcnNlUGF0dGVybldpdGhEZWZhdWx0ID0gZnVuY3Rpb24gKHBhcmFtcywga2luZCkge1xyXG5cdCAgICAgICAgdmFyIHN0YXJ0VG9rZW4gPSB0aGlzLmxvb2thaGVhZDtcclxuXHQgICAgICAgIHZhciBwYXR0ZXJuID0gdGhpcy5wYXJzZVBhdHRlcm4ocGFyYW1zLCBraW5kKTtcclxuXHQgICAgICAgIGlmICh0aGlzLm1hdGNoKCc9JykpIHtcclxuXHQgICAgICAgICAgICB0aGlzLm5leHRUb2tlbigpO1xyXG5cdCAgICAgICAgICAgIHZhciBwcmV2aW91c0FsbG93WWllbGQgPSB0aGlzLmNvbnRleHQuYWxsb3dZaWVsZDtcclxuXHQgICAgICAgICAgICB0aGlzLmNvbnRleHQuYWxsb3dZaWVsZCA9IHRydWU7XHJcblx0ICAgICAgICAgICAgdmFyIHJpZ2h0ID0gdGhpcy5pc29sYXRlQ292ZXJHcmFtbWFyKHRoaXMucGFyc2VBc3NpZ25tZW50RXhwcmVzc2lvbik7XHJcblx0ICAgICAgICAgICAgdGhpcy5jb250ZXh0LmFsbG93WWllbGQgPSBwcmV2aW91c0FsbG93WWllbGQ7XHJcblx0ICAgICAgICAgICAgcGF0dGVybiA9IHRoaXMuZmluYWxpemUodGhpcy5zdGFydE5vZGUoc3RhcnRUb2tlbiksIG5ldyBOb2RlLkFzc2lnbm1lbnRQYXR0ZXJuKHBhdHRlcm4sIHJpZ2h0KSk7XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICByZXR1cm4gcGF0dGVybjtcclxuXHQgICAgfTtcclxuXHQgICAgLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtdmFyaWFibGUtc3RhdGVtZW50XHJcblx0ICAgIFBhcnNlci5wcm90b3R5cGUucGFyc2VWYXJpYWJsZUlkZW50aWZpZXIgPSBmdW5jdGlvbiAoa2luZCkge1xyXG5cdCAgICAgICAgdmFyIG5vZGUgPSB0aGlzLmNyZWF0ZU5vZGUoKTtcclxuXHQgICAgICAgIHZhciB0b2tlbiA9IHRoaXMubmV4dFRva2VuKCk7XHJcblx0ICAgICAgICBpZiAodG9rZW4udHlwZSA9PT0gNCAvKiBLZXl3b3JkICovICYmIHRva2VuLnZhbHVlID09PSAneWllbGQnKSB7XHJcblx0ICAgICAgICAgICAgaWYgKHRoaXMuY29udGV4dC5zdHJpY3QpIHtcclxuXHQgICAgICAgICAgICAgICAgdGhpcy50b2xlcmF0ZVVuZXhwZWN0ZWRUb2tlbih0b2tlbiwgbWVzc2FnZXNfMS5NZXNzYWdlcy5TdHJpY3RSZXNlcnZlZFdvcmQpO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICBlbHNlIGlmICghdGhpcy5jb250ZXh0LmFsbG93WWllbGQpIHtcclxuXHQgICAgICAgICAgICAgICAgdGhpcy50aHJvd1VuZXhwZWN0ZWRUb2tlbih0b2tlbik7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgZWxzZSBpZiAodG9rZW4udHlwZSAhPT0gMyAvKiBJZGVudGlmaWVyICovKSB7XHJcblx0ICAgICAgICAgICAgaWYgKHRoaXMuY29udGV4dC5zdHJpY3QgJiYgdG9rZW4udHlwZSA9PT0gNCAvKiBLZXl3b3JkICovICYmIHRoaXMuc2Nhbm5lci5pc1N0cmljdE1vZGVSZXNlcnZlZFdvcmQodG9rZW4udmFsdWUpKSB7XHJcblx0ICAgICAgICAgICAgICAgIHRoaXMudG9sZXJhdGVVbmV4cGVjdGVkVG9rZW4odG9rZW4sIG1lc3NhZ2VzXzEuTWVzc2FnZXMuU3RyaWN0UmVzZXJ2ZWRXb3JkKTtcclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgZWxzZSB7XHJcblx0ICAgICAgICAgICAgICAgIGlmICh0aGlzLmNvbnRleHQuc3RyaWN0IHx8IHRva2VuLnZhbHVlICE9PSAnbGV0JyB8fCBraW5kICE9PSAndmFyJykge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgdGhpcy50aHJvd1VuZXhwZWN0ZWRUb2tlbih0b2tlbik7XHJcblx0ICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICBlbHNlIGlmICgodGhpcy5jb250ZXh0LmlzTW9kdWxlIHx8IHRoaXMuY29udGV4dC5hd2FpdCkgJiYgdG9rZW4udHlwZSA9PT0gMyAvKiBJZGVudGlmaWVyICovICYmIHRva2VuLnZhbHVlID09PSAnYXdhaXQnKSB7XHJcblx0ICAgICAgICAgICAgdGhpcy50b2xlcmF0ZVVuZXhwZWN0ZWRUb2tlbih0b2tlbik7XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICByZXR1cm4gdGhpcy5maW5hbGl6ZShub2RlLCBuZXcgTm9kZS5JZGVudGlmaWVyKHRva2VuLnZhbHVlKSk7XHJcblx0ICAgIH07XHJcblx0ICAgIFBhcnNlci5wcm90b3R5cGUucGFyc2VWYXJpYWJsZURlY2xhcmF0aW9uID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcclxuXHQgICAgICAgIHZhciBub2RlID0gdGhpcy5jcmVhdGVOb2RlKCk7XHJcblx0ICAgICAgICB2YXIgcGFyYW1zID0gW107XHJcblx0ICAgICAgICB2YXIgaWQgPSB0aGlzLnBhcnNlUGF0dGVybihwYXJhbXMsICd2YXInKTtcclxuXHQgICAgICAgIGlmICh0aGlzLmNvbnRleHQuc3RyaWN0ICYmIGlkLnR5cGUgPT09IHN5bnRheF8xLlN5bnRheC5JZGVudGlmaWVyKSB7XHJcblx0ICAgICAgICAgICAgaWYgKHRoaXMuc2Nhbm5lci5pc1Jlc3RyaWN0ZWRXb3JkKGlkLm5hbWUpKSB7XHJcblx0ICAgICAgICAgICAgICAgIHRoaXMudG9sZXJhdGVFcnJvcihtZXNzYWdlc18xLk1lc3NhZ2VzLlN0cmljdFZhck5hbWUpO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIHZhciBpbml0ID0gbnVsbDtcclxuXHQgICAgICAgIGlmICh0aGlzLm1hdGNoKCc9JykpIHtcclxuXHQgICAgICAgICAgICB0aGlzLm5leHRUb2tlbigpO1xyXG5cdCAgICAgICAgICAgIGluaXQgPSB0aGlzLmlzb2xhdGVDb3ZlckdyYW1tYXIodGhpcy5wYXJzZUFzc2lnbm1lbnRFeHByZXNzaW9uKTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIGVsc2UgaWYgKGlkLnR5cGUgIT09IHN5bnRheF8xLlN5bnRheC5JZGVudGlmaWVyICYmICFvcHRpb25zLmluRm9yKSB7XHJcblx0ICAgICAgICAgICAgdGhpcy5leHBlY3QoJz0nKTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIHJldHVybiB0aGlzLmZpbmFsaXplKG5vZGUsIG5ldyBOb2RlLlZhcmlhYmxlRGVjbGFyYXRvcihpZCwgaW5pdCkpO1xyXG5cdCAgICB9O1xyXG5cdCAgICBQYXJzZXIucHJvdG90eXBlLnBhcnNlVmFyaWFibGVEZWNsYXJhdGlvbkxpc3QgPSBmdW5jdGlvbiAob3B0aW9ucykge1xyXG5cdCAgICAgICAgdmFyIG9wdCA9IHsgaW5Gb3I6IG9wdGlvbnMuaW5Gb3IgfTtcclxuXHQgICAgICAgIHZhciBsaXN0ID0gW107XHJcblx0ICAgICAgICBsaXN0LnB1c2godGhpcy5wYXJzZVZhcmlhYmxlRGVjbGFyYXRpb24ob3B0KSk7XHJcblx0ICAgICAgICB3aGlsZSAodGhpcy5tYXRjaCgnLCcpKSB7XHJcblx0ICAgICAgICAgICAgdGhpcy5uZXh0VG9rZW4oKTtcclxuXHQgICAgICAgICAgICBsaXN0LnB1c2godGhpcy5wYXJzZVZhcmlhYmxlRGVjbGFyYXRpb24ob3B0KSk7XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICByZXR1cm4gbGlzdDtcclxuXHQgICAgfTtcclxuXHQgICAgUGFyc2VyLnByb3RvdHlwZS5wYXJzZVZhcmlhYmxlU3RhdGVtZW50ID0gZnVuY3Rpb24gKCkge1xyXG5cdCAgICAgICAgdmFyIG5vZGUgPSB0aGlzLmNyZWF0ZU5vZGUoKTtcclxuXHQgICAgICAgIHRoaXMuZXhwZWN0S2V5d29yZCgndmFyJyk7XHJcblx0ICAgICAgICB2YXIgZGVjbGFyYXRpb25zID0gdGhpcy5wYXJzZVZhcmlhYmxlRGVjbGFyYXRpb25MaXN0KHsgaW5Gb3I6IGZhbHNlIH0pO1xyXG5cdCAgICAgICAgdGhpcy5jb25zdW1lU2VtaWNvbG9uKCk7XHJcblx0ICAgICAgICByZXR1cm4gdGhpcy5maW5hbGl6ZShub2RlLCBuZXcgTm9kZS5WYXJpYWJsZURlY2xhcmF0aW9uKGRlY2xhcmF0aW9ucywgJ3ZhcicpKTtcclxuXHQgICAgfTtcclxuXHQgICAgLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtZW1wdHktc3RhdGVtZW50XHJcblx0ICAgIFBhcnNlci5wcm90b3R5cGUucGFyc2VFbXB0eVN0YXRlbWVudCA9IGZ1bmN0aW9uICgpIHtcclxuXHQgICAgICAgIHZhciBub2RlID0gdGhpcy5jcmVhdGVOb2RlKCk7XHJcblx0ICAgICAgICB0aGlzLmV4cGVjdCgnOycpO1xyXG5cdCAgICAgICAgcmV0dXJuIHRoaXMuZmluYWxpemUobm9kZSwgbmV3IE5vZGUuRW1wdHlTdGF0ZW1lbnQoKSk7XHJcblx0ICAgIH07XHJcblx0ICAgIC8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLWV4cHJlc3Npb24tc3RhdGVtZW50XHJcblx0ICAgIFBhcnNlci5wcm90b3R5cGUucGFyc2VFeHByZXNzaW9uU3RhdGVtZW50ID0gZnVuY3Rpb24gKCkge1xyXG5cdCAgICAgICAgdmFyIG5vZGUgPSB0aGlzLmNyZWF0ZU5vZGUoKTtcclxuXHQgICAgICAgIHZhciBleHByID0gdGhpcy5wYXJzZUV4cHJlc3Npb24oKTtcclxuXHQgICAgICAgIHRoaXMuY29uc3VtZVNlbWljb2xvbigpO1xyXG5cdCAgICAgICAgcmV0dXJuIHRoaXMuZmluYWxpemUobm9kZSwgbmV3IE5vZGUuRXhwcmVzc2lvblN0YXRlbWVudChleHByKSk7XHJcblx0ICAgIH07XHJcblx0ICAgIC8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLWlmLXN0YXRlbWVudFxyXG5cdCAgICBQYXJzZXIucHJvdG90eXBlLnBhcnNlSWZDbGF1c2UgPSBmdW5jdGlvbiAoKSB7XHJcblx0ICAgICAgICBpZiAodGhpcy5jb250ZXh0LnN0cmljdCAmJiB0aGlzLm1hdGNoS2V5d29yZCgnZnVuY3Rpb24nKSkge1xyXG5cdCAgICAgICAgICAgIHRoaXMudG9sZXJhdGVFcnJvcihtZXNzYWdlc18xLk1lc3NhZ2VzLlN0cmljdEZ1bmN0aW9uKTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIHJldHVybiB0aGlzLnBhcnNlU3RhdGVtZW50KCk7XHJcblx0ICAgIH07XHJcblx0ICAgIFBhcnNlci5wcm90b3R5cGUucGFyc2VJZlN0YXRlbWVudCA9IGZ1bmN0aW9uICgpIHtcclxuXHQgICAgICAgIHZhciBub2RlID0gdGhpcy5jcmVhdGVOb2RlKCk7XHJcblx0ICAgICAgICB2YXIgY29uc2VxdWVudDtcclxuXHQgICAgICAgIHZhciBhbHRlcm5hdGUgPSBudWxsO1xyXG5cdCAgICAgICAgdGhpcy5leHBlY3RLZXl3b3JkKCdpZicpO1xyXG5cdCAgICAgICAgdGhpcy5leHBlY3QoJygnKTtcclxuXHQgICAgICAgIHZhciB0ZXN0ID0gdGhpcy5wYXJzZUV4cHJlc3Npb24oKTtcclxuXHQgICAgICAgIGlmICghdGhpcy5tYXRjaCgnKScpICYmIHRoaXMuY29uZmlnLnRvbGVyYW50KSB7XHJcblx0ICAgICAgICAgICAgdGhpcy50b2xlcmF0ZVVuZXhwZWN0ZWRUb2tlbih0aGlzLm5leHRUb2tlbigpKTtcclxuXHQgICAgICAgICAgICBjb25zZXF1ZW50ID0gdGhpcy5maW5hbGl6ZSh0aGlzLmNyZWF0ZU5vZGUoKSwgbmV3IE5vZGUuRW1wdHlTdGF0ZW1lbnQoKSk7XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICBlbHNlIHtcclxuXHQgICAgICAgICAgICB0aGlzLmV4cGVjdCgnKScpO1xyXG5cdCAgICAgICAgICAgIGNvbnNlcXVlbnQgPSB0aGlzLnBhcnNlSWZDbGF1c2UoKTtcclxuXHQgICAgICAgICAgICBpZiAodGhpcy5tYXRjaEtleXdvcmQoJ2Vsc2UnKSkge1xyXG5cdCAgICAgICAgICAgICAgICB0aGlzLm5leHRUb2tlbigpO1xyXG5cdCAgICAgICAgICAgICAgICBhbHRlcm5hdGUgPSB0aGlzLnBhcnNlSWZDbGF1c2UoKTtcclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICByZXR1cm4gdGhpcy5maW5hbGl6ZShub2RlLCBuZXcgTm9kZS5JZlN0YXRlbWVudCh0ZXN0LCBjb25zZXF1ZW50LCBhbHRlcm5hdGUpKTtcclxuXHQgICAgfTtcclxuXHQgICAgLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtZG8td2hpbGUtc3RhdGVtZW50XHJcblx0ICAgIFBhcnNlci5wcm90b3R5cGUucGFyc2VEb1doaWxlU3RhdGVtZW50ID0gZnVuY3Rpb24gKCkge1xyXG5cdCAgICAgICAgdmFyIG5vZGUgPSB0aGlzLmNyZWF0ZU5vZGUoKTtcclxuXHQgICAgICAgIHRoaXMuZXhwZWN0S2V5d29yZCgnZG8nKTtcclxuXHQgICAgICAgIHZhciBwcmV2aW91c0luSXRlcmF0aW9uID0gdGhpcy5jb250ZXh0LmluSXRlcmF0aW9uO1xyXG5cdCAgICAgICAgdGhpcy5jb250ZXh0LmluSXRlcmF0aW9uID0gdHJ1ZTtcclxuXHQgICAgICAgIHZhciBib2R5ID0gdGhpcy5wYXJzZVN0YXRlbWVudCgpO1xyXG5cdCAgICAgICAgdGhpcy5jb250ZXh0LmluSXRlcmF0aW9uID0gcHJldmlvdXNJbkl0ZXJhdGlvbjtcclxuXHQgICAgICAgIHRoaXMuZXhwZWN0S2V5d29yZCgnd2hpbGUnKTtcclxuXHQgICAgICAgIHRoaXMuZXhwZWN0KCcoJyk7XHJcblx0ICAgICAgICB2YXIgdGVzdCA9IHRoaXMucGFyc2VFeHByZXNzaW9uKCk7XHJcblx0ICAgICAgICBpZiAoIXRoaXMubWF0Y2goJyknKSAmJiB0aGlzLmNvbmZpZy50b2xlcmFudCkge1xyXG5cdCAgICAgICAgICAgIHRoaXMudG9sZXJhdGVVbmV4cGVjdGVkVG9rZW4odGhpcy5uZXh0VG9rZW4oKSk7XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICBlbHNlIHtcclxuXHQgICAgICAgICAgICB0aGlzLmV4cGVjdCgnKScpO1xyXG5cdCAgICAgICAgICAgIGlmICh0aGlzLm1hdGNoKCc7JykpIHtcclxuXHQgICAgICAgICAgICAgICAgdGhpcy5uZXh0VG9rZW4oKTtcclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICByZXR1cm4gdGhpcy5maW5hbGl6ZShub2RlLCBuZXcgTm9kZS5Eb1doaWxlU3RhdGVtZW50KGJvZHksIHRlc3QpKTtcclxuXHQgICAgfTtcclxuXHQgICAgLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtd2hpbGUtc3RhdGVtZW50XHJcblx0ICAgIFBhcnNlci5wcm90b3R5cGUucGFyc2VXaGlsZVN0YXRlbWVudCA9IGZ1bmN0aW9uICgpIHtcclxuXHQgICAgICAgIHZhciBub2RlID0gdGhpcy5jcmVhdGVOb2RlKCk7XHJcblx0ICAgICAgICB2YXIgYm9keTtcclxuXHQgICAgICAgIHRoaXMuZXhwZWN0S2V5d29yZCgnd2hpbGUnKTtcclxuXHQgICAgICAgIHRoaXMuZXhwZWN0KCcoJyk7XHJcblx0ICAgICAgICB2YXIgdGVzdCA9IHRoaXMucGFyc2VFeHByZXNzaW9uKCk7XHJcblx0ICAgICAgICBpZiAoIXRoaXMubWF0Y2goJyknKSAmJiB0aGlzLmNvbmZpZy50b2xlcmFudCkge1xyXG5cdCAgICAgICAgICAgIHRoaXMudG9sZXJhdGVVbmV4cGVjdGVkVG9rZW4odGhpcy5uZXh0VG9rZW4oKSk7XHJcblx0ICAgICAgICAgICAgYm9keSA9IHRoaXMuZmluYWxpemUodGhpcy5jcmVhdGVOb2RlKCksIG5ldyBOb2RlLkVtcHR5U3RhdGVtZW50KCkpO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgZWxzZSB7XHJcblx0ICAgICAgICAgICAgdGhpcy5leHBlY3QoJyknKTtcclxuXHQgICAgICAgICAgICB2YXIgcHJldmlvdXNJbkl0ZXJhdGlvbiA9IHRoaXMuY29udGV4dC5pbkl0ZXJhdGlvbjtcclxuXHQgICAgICAgICAgICB0aGlzLmNvbnRleHQuaW5JdGVyYXRpb24gPSB0cnVlO1xyXG5cdCAgICAgICAgICAgIGJvZHkgPSB0aGlzLnBhcnNlU3RhdGVtZW50KCk7XHJcblx0ICAgICAgICAgICAgdGhpcy5jb250ZXh0LmluSXRlcmF0aW9uID0gcHJldmlvdXNJbkl0ZXJhdGlvbjtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIHJldHVybiB0aGlzLmZpbmFsaXplKG5vZGUsIG5ldyBOb2RlLldoaWxlU3RhdGVtZW50KHRlc3QsIGJvZHkpKTtcclxuXHQgICAgfTtcclxuXHQgICAgLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtZm9yLXN0YXRlbWVudFxyXG5cdCAgICAvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1mb3ItaW4tYW5kLWZvci1vZi1zdGF0ZW1lbnRzXHJcblx0ICAgIFBhcnNlci5wcm90b3R5cGUucGFyc2VGb3JTdGF0ZW1lbnQgPSBmdW5jdGlvbiAoKSB7XHJcblx0ICAgICAgICB2YXIgaW5pdCA9IG51bGw7XHJcblx0ICAgICAgICB2YXIgdGVzdCA9IG51bGw7XHJcblx0ICAgICAgICB2YXIgdXBkYXRlID0gbnVsbDtcclxuXHQgICAgICAgIHZhciBmb3JJbiA9IHRydWU7XHJcblx0ICAgICAgICB2YXIgbGVmdCwgcmlnaHQ7XHJcblx0ICAgICAgICB2YXIgbm9kZSA9IHRoaXMuY3JlYXRlTm9kZSgpO1xyXG5cdCAgICAgICAgdGhpcy5leHBlY3RLZXl3b3JkKCdmb3InKTtcclxuXHQgICAgICAgIHRoaXMuZXhwZWN0KCcoJyk7XHJcblx0ICAgICAgICBpZiAodGhpcy5tYXRjaCgnOycpKSB7XHJcblx0ICAgICAgICAgICAgdGhpcy5uZXh0VG9rZW4oKTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIGVsc2Uge1xyXG5cdCAgICAgICAgICAgIGlmICh0aGlzLm1hdGNoS2V5d29yZCgndmFyJykpIHtcclxuXHQgICAgICAgICAgICAgICAgaW5pdCA9IHRoaXMuY3JlYXRlTm9kZSgpO1xyXG5cdCAgICAgICAgICAgICAgICB0aGlzLm5leHRUb2tlbigpO1xyXG5cdCAgICAgICAgICAgICAgICB2YXIgcHJldmlvdXNBbGxvd0luID0gdGhpcy5jb250ZXh0LmFsbG93SW47XHJcblx0ICAgICAgICAgICAgICAgIHRoaXMuY29udGV4dC5hbGxvd0luID0gZmFsc2U7XHJcblx0ICAgICAgICAgICAgICAgIHZhciBkZWNsYXJhdGlvbnMgPSB0aGlzLnBhcnNlVmFyaWFibGVEZWNsYXJhdGlvbkxpc3QoeyBpbkZvcjogdHJ1ZSB9KTtcclxuXHQgICAgICAgICAgICAgICAgdGhpcy5jb250ZXh0LmFsbG93SW4gPSBwcmV2aW91c0FsbG93SW47XHJcblx0ICAgICAgICAgICAgICAgIGlmIChkZWNsYXJhdGlvbnMubGVuZ3RoID09PSAxICYmIHRoaXMubWF0Y2hLZXl3b3JkKCdpbicpKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgZGVjbCA9IGRlY2xhcmF0aW9uc1swXTtcclxuXHQgICAgICAgICAgICAgICAgICAgIGlmIChkZWNsLmluaXQgJiYgKGRlY2wuaWQudHlwZSA9PT0gc3ludGF4XzEuU3ludGF4LkFycmF5UGF0dGVybiB8fCBkZWNsLmlkLnR5cGUgPT09IHN5bnRheF8xLlN5bnRheC5PYmplY3RQYXR0ZXJuIHx8IHRoaXMuY29udGV4dC5zdHJpY3QpKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy50b2xlcmF0ZUVycm9yKG1lc3NhZ2VzXzEuTWVzc2FnZXMuRm9ySW5PZkxvb3BJbml0aWFsaXplciwgJ2Zvci1pbicpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICAgICAgaW5pdCA9IHRoaXMuZmluYWxpemUoaW5pdCwgbmV3IE5vZGUuVmFyaWFibGVEZWNsYXJhdGlvbihkZWNsYXJhdGlvbnMsICd2YXInKSk7XHJcblx0ICAgICAgICAgICAgICAgICAgICB0aGlzLm5leHRUb2tlbigpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgbGVmdCA9IGluaXQ7XHJcblx0ICAgICAgICAgICAgICAgICAgICByaWdodCA9IHRoaXMucGFyc2VFeHByZXNzaW9uKCk7XHJcblx0ICAgICAgICAgICAgICAgICAgICBpbml0ID0gbnVsbDtcclxuXHQgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICBlbHNlIGlmIChkZWNsYXJhdGlvbnMubGVuZ3RoID09PSAxICYmIGRlY2xhcmF0aW9uc1swXS5pbml0ID09PSBudWxsICYmIHRoaXMubWF0Y2hDb250ZXh0dWFsS2V5d29yZCgnb2YnKSkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgaW5pdCA9IHRoaXMuZmluYWxpemUoaW5pdCwgbmV3IE5vZGUuVmFyaWFibGVEZWNsYXJhdGlvbihkZWNsYXJhdGlvbnMsICd2YXInKSk7XHJcblx0ICAgICAgICAgICAgICAgICAgICB0aGlzLm5leHRUb2tlbigpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgbGVmdCA9IGluaXQ7XHJcblx0ICAgICAgICAgICAgICAgICAgICByaWdodCA9IHRoaXMucGFyc2VBc3NpZ25tZW50RXhwcmVzc2lvbigpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgaW5pdCA9IG51bGw7XHJcblx0ICAgICAgICAgICAgICAgICAgICBmb3JJbiA9IGZhbHNlO1xyXG5cdCAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgIGVsc2Uge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgaW5pdCA9IHRoaXMuZmluYWxpemUoaW5pdCwgbmV3IE5vZGUuVmFyaWFibGVEZWNsYXJhdGlvbihkZWNsYXJhdGlvbnMsICd2YXInKSk7XHJcblx0ICAgICAgICAgICAgICAgICAgICB0aGlzLmV4cGVjdCgnOycpO1xyXG5cdCAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMubWF0Y2hLZXl3b3JkKCdjb25zdCcpIHx8IHRoaXMubWF0Y2hLZXl3b3JkKCdsZXQnKSkge1xyXG5cdCAgICAgICAgICAgICAgICBpbml0ID0gdGhpcy5jcmVhdGVOb2RlKCk7XHJcblx0ICAgICAgICAgICAgICAgIHZhciBraW5kID0gdGhpcy5uZXh0VG9rZW4oKS52YWx1ZTtcclxuXHQgICAgICAgICAgICAgICAgaWYgKCF0aGlzLmNvbnRleHQuc3RyaWN0ICYmIHRoaXMubG9va2FoZWFkLnZhbHVlID09PSAnaW4nKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICBpbml0ID0gdGhpcy5maW5hbGl6ZShpbml0LCBuZXcgTm9kZS5JZGVudGlmaWVyKGtpbmQpKTtcclxuXHQgICAgICAgICAgICAgICAgICAgIHRoaXMubmV4dFRva2VuKCk7XHJcblx0ICAgICAgICAgICAgICAgICAgICBsZWZ0ID0gaW5pdDtcclxuXHQgICAgICAgICAgICAgICAgICAgIHJpZ2h0ID0gdGhpcy5wYXJzZUV4cHJlc3Npb24oKTtcclxuXHQgICAgICAgICAgICAgICAgICAgIGluaXQgPSBudWxsO1xyXG5cdCAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgIGVsc2Uge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIHByZXZpb3VzQWxsb3dJbiA9IHRoaXMuY29udGV4dC5hbGxvd0luO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgdGhpcy5jb250ZXh0LmFsbG93SW4gPSBmYWxzZTtcclxuXHQgICAgICAgICAgICAgICAgICAgIHZhciBkZWNsYXJhdGlvbnMgPSB0aGlzLnBhcnNlQmluZGluZ0xpc3Qoa2luZCwgeyBpbkZvcjogdHJ1ZSB9KTtcclxuXHQgICAgICAgICAgICAgICAgICAgIHRoaXMuY29udGV4dC5hbGxvd0luID0gcHJldmlvdXNBbGxvd0luO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKGRlY2xhcmF0aW9ucy5sZW5ndGggPT09IDEgJiYgZGVjbGFyYXRpb25zWzBdLmluaXQgPT09IG51bGwgJiYgdGhpcy5tYXRjaEtleXdvcmQoJ2luJykpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBpbml0ID0gdGhpcy5maW5hbGl6ZShpbml0LCBuZXcgTm9kZS5WYXJpYWJsZURlY2xhcmF0aW9uKGRlY2xhcmF0aW9ucywga2luZCkpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubmV4dFRva2VuKCk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgbGVmdCA9IGluaXQ7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcmlnaHQgPSB0aGlzLnBhcnNlRXhwcmVzc2lvbigpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGluaXQgPSBudWxsO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoZGVjbGFyYXRpb25zLmxlbmd0aCA9PT0gMSAmJiBkZWNsYXJhdGlvbnNbMF0uaW5pdCA9PT0gbnVsbCAmJiB0aGlzLm1hdGNoQ29udGV4dHVhbEtleXdvcmQoJ29mJykpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBpbml0ID0gdGhpcy5maW5hbGl6ZShpbml0LCBuZXcgTm9kZS5WYXJpYWJsZURlY2xhcmF0aW9uKGRlY2xhcmF0aW9ucywga2luZCkpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubmV4dFRva2VuKCk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgbGVmdCA9IGluaXQ7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcmlnaHQgPSB0aGlzLnBhcnNlQXNzaWdubWVudEV4cHJlc3Npb24oKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBpbml0ID0gbnVsbDtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBmb3JJbiA9IGZhbHNlO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jb25zdW1lU2VtaWNvbG9uKCk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgaW5pdCA9IHRoaXMuZmluYWxpemUoaW5pdCwgbmV3IE5vZGUuVmFyaWFibGVEZWNsYXJhdGlvbihkZWNsYXJhdGlvbnMsIGtpbmQpKTtcclxuXHQgICAgICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICBlbHNlIHtcclxuXHQgICAgICAgICAgICAgICAgdmFyIGluaXRTdGFydFRva2VuID0gdGhpcy5sb29rYWhlYWQ7XHJcblx0ICAgICAgICAgICAgICAgIHZhciBwcmV2aW91c0FsbG93SW4gPSB0aGlzLmNvbnRleHQuYWxsb3dJbjtcclxuXHQgICAgICAgICAgICAgICAgdGhpcy5jb250ZXh0LmFsbG93SW4gPSBmYWxzZTtcclxuXHQgICAgICAgICAgICAgICAgaW5pdCA9IHRoaXMuaW5oZXJpdENvdmVyR3JhbW1hcih0aGlzLnBhcnNlQXNzaWdubWVudEV4cHJlc3Npb24pO1xyXG5cdCAgICAgICAgICAgICAgICB0aGlzLmNvbnRleHQuYWxsb3dJbiA9IHByZXZpb3VzQWxsb3dJbjtcclxuXHQgICAgICAgICAgICAgICAgaWYgKHRoaXMubWF0Y2hLZXl3b3JkKCdpbicpKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICBpZiAoIXRoaXMuY29udGV4dC5pc0Fzc2lnbm1lbnRUYXJnZXQgfHwgaW5pdC50eXBlID09PSBzeW50YXhfMS5TeW50YXguQXNzaWdubWVudEV4cHJlc3Npb24pIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnRvbGVyYXRlRXJyb3IobWVzc2FnZXNfMS5NZXNzYWdlcy5JbnZhbGlkTEhTSW5Gb3JJbik7XHJcblx0ICAgICAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgICAgICB0aGlzLm5leHRUb2tlbigpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgdGhpcy5yZWludGVycHJldEV4cHJlc3Npb25Bc1BhdHRlcm4oaW5pdCk7XHJcblx0ICAgICAgICAgICAgICAgICAgICBsZWZ0ID0gaW5pdDtcclxuXHQgICAgICAgICAgICAgICAgICAgIHJpZ2h0ID0gdGhpcy5wYXJzZUV4cHJlc3Npb24oKTtcclxuXHQgICAgICAgICAgICAgICAgICAgIGluaXQgPSBudWxsO1xyXG5cdCAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMubWF0Y2hDb250ZXh0dWFsS2V5d29yZCgnb2YnKSkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKCF0aGlzLmNvbnRleHQuaXNBc3NpZ25tZW50VGFyZ2V0IHx8IGluaXQudHlwZSA9PT0gc3ludGF4XzEuU3ludGF4LkFzc2lnbm1lbnRFeHByZXNzaW9uKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy50b2xlcmF0ZUVycm9yKG1lc3NhZ2VzXzEuTWVzc2FnZXMuSW52YWxpZExIU0luRm9yTG9vcCk7XHJcblx0ICAgICAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgICAgICB0aGlzLm5leHRUb2tlbigpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgdGhpcy5yZWludGVycHJldEV4cHJlc3Npb25Bc1BhdHRlcm4oaW5pdCk7XHJcblx0ICAgICAgICAgICAgICAgICAgICBsZWZ0ID0gaW5pdDtcclxuXHQgICAgICAgICAgICAgICAgICAgIHJpZ2h0ID0gdGhpcy5wYXJzZUFzc2lnbm1lbnRFeHByZXNzaW9uKCk7XHJcblx0ICAgICAgICAgICAgICAgICAgICBpbml0ID0gbnVsbDtcclxuXHQgICAgICAgICAgICAgICAgICAgIGZvckluID0gZmFsc2U7XHJcblx0ICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgZWxzZSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5tYXRjaCgnLCcpKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGluaXRTZXEgPSBbaW5pdF07XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgd2hpbGUgKHRoaXMubWF0Y2goJywnKSkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm5leHRUb2tlbigpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbml0U2VxLnB1c2godGhpcy5pc29sYXRlQ292ZXJHcmFtbWFyKHRoaXMucGFyc2VBc3NpZ25tZW50RXhwcmVzc2lvbikpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBpbml0ID0gdGhpcy5maW5hbGl6ZSh0aGlzLnN0YXJ0Tm9kZShpbml0U3RhcnRUb2tlbiksIG5ldyBOb2RlLlNlcXVlbmNlRXhwcmVzc2lvbihpbml0U2VxKSk7XHJcblx0ICAgICAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgICAgICB0aGlzLmV4cGVjdCgnOycpO1xyXG5cdCAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgaWYgKHR5cGVvZiBsZWZ0ID09PSAndW5kZWZpbmVkJykge1xyXG5cdCAgICAgICAgICAgIGlmICghdGhpcy5tYXRjaCgnOycpKSB7XHJcblx0ICAgICAgICAgICAgICAgIHRlc3QgPSB0aGlzLnBhcnNlRXhwcmVzc2lvbigpO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICB0aGlzLmV4cGVjdCgnOycpO1xyXG5cdCAgICAgICAgICAgIGlmICghdGhpcy5tYXRjaCgnKScpKSB7XHJcblx0ICAgICAgICAgICAgICAgIHVwZGF0ZSA9IHRoaXMucGFyc2VFeHByZXNzaW9uKCk7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgdmFyIGJvZHk7XHJcblx0ICAgICAgICBpZiAoIXRoaXMubWF0Y2goJyknKSAmJiB0aGlzLmNvbmZpZy50b2xlcmFudCkge1xyXG5cdCAgICAgICAgICAgIHRoaXMudG9sZXJhdGVVbmV4cGVjdGVkVG9rZW4odGhpcy5uZXh0VG9rZW4oKSk7XHJcblx0ICAgICAgICAgICAgYm9keSA9IHRoaXMuZmluYWxpemUodGhpcy5jcmVhdGVOb2RlKCksIG5ldyBOb2RlLkVtcHR5U3RhdGVtZW50KCkpO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgZWxzZSB7XHJcblx0ICAgICAgICAgICAgdGhpcy5leHBlY3QoJyknKTtcclxuXHQgICAgICAgICAgICB2YXIgcHJldmlvdXNJbkl0ZXJhdGlvbiA9IHRoaXMuY29udGV4dC5pbkl0ZXJhdGlvbjtcclxuXHQgICAgICAgICAgICB0aGlzLmNvbnRleHQuaW5JdGVyYXRpb24gPSB0cnVlO1xyXG5cdCAgICAgICAgICAgIGJvZHkgPSB0aGlzLmlzb2xhdGVDb3ZlckdyYW1tYXIodGhpcy5wYXJzZVN0YXRlbWVudCk7XHJcblx0ICAgICAgICAgICAgdGhpcy5jb250ZXh0LmluSXRlcmF0aW9uID0gcHJldmlvdXNJbkl0ZXJhdGlvbjtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIHJldHVybiAodHlwZW9mIGxlZnQgPT09ICd1bmRlZmluZWQnKSA/XHJcblx0ICAgICAgICAgICAgdGhpcy5maW5hbGl6ZShub2RlLCBuZXcgTm9kZS5Gb3JTdGF0ZW1lbnQoaW5pdCwgdGVzdCwgdXBkYXRlLCBib2R5KSkgOlxyXG5cdCAgICAgICAgICAgIGZvckluID8gdGhpcy5maW5hbGl6ZShub2RlLCBuZXcgTm9kZS5Gb3JJblN0YXRlbWVudChsZWZ0LCByaWdodCwgYm9keSkpIDpcclxuXHQgICAgICAgICAgICAgICAgdGhpcy5maW5hbGl6ZShub2RlLCBuZXcgTm9kZS5Gb3JPZlN0YXRlbWVudChsZWZ0LCByaWdodCwgYm9keSkpO1xyXG5cdCAgICB9O1xyXG5cdCAgICAvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1jb250aW51ZS1zdGF0ZW1lbnRcclxuXHQgICAgUGFyc2VyLnByb3RvdHlwZS5wYXJzZUNvbnRpbnVlU3RhdGVtZW50ID0gZnVuY3Rpb24gKCkge1xyXG5cdCAgICAgICAgdmFyIG5vZGUgPSB0aGlzLmNyZWF0ZU5vZGUoKTtcclxuXHQgICAgICAgIHRoaXMuZXhwZWN0S2V5d29yZCgnY29udGludWUnKTtcclxuXHQgICAgICAgIHZhciBsYWJlbCA9IG51bGw7XHJcblx0ICAgICAgICBpZiAodGhpcy5sb29rYWhlYWQudHlwZSA9PT0gMyAvKiBJZGVudGlmaWVyICovICYmICF0aGlzLmhhc0xpbmVUZXJtaW5hdG9yKSB7XHJcblx0ICAgICAgICAgICAgdmFyIGlkID0gdGhpcy5wYXJzZVZhcmlhYmxlSWRlbnRpZmllcigpO1xyXG5cdCAgICAgICAgICAgIGxhYmVsID0gaWQ7XHJcblx0ICAgICAgICAgICAgdmFyIGtleSA9ICckJyArIGlkLm5hbWU7XHJcblx0ICAgICAgICAgICAgaWYgKCFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodGhpcy5jb250ZXh0LmxhYmVsU2V0LCBrZXkpKSB7XHJcblx0ICAgICAgICAgICAgICAgIHRoaXMudGhyb3dFcnJvcihtZXNzYWdlc18xLk1lc3NhZ2VzLlVua25vd25MYWJlbCwgaWQubmFtZSk7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgdGhpcy5jb25zdW1lU2VtaWNvbG9uKCk7XHJcblx0ICAgICAgICBpZiAobGFiZWwgPT09IG51bGwgJiYgIXRoaXMuY29udGV4dC5pbkl0ZXJhdGlvbikge1xyXG5cdCAgICAgICAgICAgIHRoaXMudGhyb3dFcnJvcihtZXNzYWdlc18xLk1lc3NhZ2VzLklsbGVnYWxDb250aW51ZSk7XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICByZXR1cm4gdGhpcy5maW5hbGl6ZShub2RlLCBuZXcgTm9kZS5Db250aW51ZVN0YXRlbWVudChsYWJlbCkpO1xyXG5cdCAgICB9O1xyXG5cdCAgICAvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1icmVhay1zdGF0ZW1lbnRcclxuXHQgICAgUGFyc2VyLnByb3RvdHlwZS5wYXJzZUJyZWFrU3RhdGVtZW50ID0gZnVuY3Rpb24gKCkge1xyXG5cdCAgICAgICAgdmFyIG5vZGUgPSB0aGlzLmNyZWF0ZU5vZGUoKTtcclxuXHQgICAgICAgIHRoaXMuZXhwZWN0S2V5d29yZCgnYnJlYWsnKTtcclxuXHQgICAgICAgIHZhciBsYWJlbCA9IG51bGw7XHJcblx0ICAgICAgICBpZiAodGhpcy5sb29rYWhlYWQudHlwZSA9PT0gMyAvKiBJZGVudGlmaWVyICovICYmICF0aGlzLmhhc0xpbmVUZXJtaW5hdG9yKSB7XHJcblx0ICAgICAgICAgICAgdmFyIGlkID0gdGhpcy5wYXJzZVZhcmlhYmxlSWRlbnRpZmllcigpO1xyXG5cdCAgICAgICAgICAgIHZhciBrZXkgPSAnJCcgKyBpZC5uYW1lO1xyXG5cdCAgICAgICAgICAgIGlmICghT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHRoaXMuY29udGV4dC5sYWJlbFNldCwga2V5KSkge1xyXG5cdCAgICAgICAgICAgICAgICB0aGlzLnRocm93RXJyb3IobWVzc2FnZXNfMS5NZXNzYWdlcy5Vbmtub3duTGFiZWwsIGlkLm5hbWUpO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICBsYWJlbCA9IGlkO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgdGhpcy5jb25zdW1lU2VtaWNvbG9uKCk7XHJcblx0ICAgICAgICBpZiAobGFiZWwgPT09IG51bGwgJiYgIXRoaXMuY29udGV4dC5pbkl0ZXJhdGlvbiAmJiAhdGhpcy5jb250ZXh0LmluU3dpdGNoKSB7XHJcblx0ICAgICAgICAgICAgdGhpcy50aHJvd0Vycm9yKG1lc3NhZ2VzXzEuTWVzc2FnZXMuSWxsZWdhbEJyZWFrKTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIHJldHVybiB0aGlzLmZpbmFsaXplKG5vZGUsIG5ldyBOb2RlLkJyZWFrU3RhdGVtZW50KGxhYmVsKSk7XHJcblx0ICAgIH07XHJcblx0ICAgIC8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLXJldHVybi1zdGF0ZW1lbnRcclxuXHQgICAgUGFyc2VyLnByb3RvdHlwZS5wYXJzZVJldHVyblN0YXRlbWVudCA9IGZ1bmN0aW9uICgpIHtcclxuXHQgICAgICAgIGlmICghdGhpcy5jb250ZXh0LmluRnVuY3Rpb25Cb2R5KSB7XHJcblx0ICAgICAgICAgICAgdGhpcy50b2xlcmF0ZUVycm9yKG1lc3NhZ2VzXzEuTWVzc2FnZXMuSWxsZWdhbFJldHVybik7XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICB2YXIgbm9kZSA9IHRoaXMuY3JlYXRlTm9kZSgpO1xyXG5cdCAgICAgICAgdGhpcy5leHBlY3RLZXl3b3JkKCdyZXR1cm4nKTtcclxuXHQgICAgICAgIHZhciBoYXNBcmd1bWVudCA9ICF0aGlzLm1hdGNoKCc7JykgJiYgIXRoaXMubWF0Y2goJ30nKSAmJlxyXG5cdCAgICAgICAgICAgICF0aGlzLmhhc0xpbmVUZXJtaW5hdG9yICYmIHRoaXMubG9va2FoZWFkLnR5cGUgIT09IDIgLyogRU9GICovO1xyXG5cdCAgICAgICAgdmFyIGFyZ3VtZW50ID0gaGFzQXJndW1lbnQgPyB0aGlzLnBhcnNlRXhwcmVzc2lvbigpIDogbnVsbDtcclxuXHQgICAgICAgIHRoaXMuY29uc3VtZVNlbWljb2xvbigpO1xyXG5cdCAgICAgICAgcmV0dXJuIHRoaXMuZmluYWxpemUobm9kZSwgbmV3IE5vZGUuUmV0dXJuU3RhdGVtZW50KGFyZ3VtZW50KSk7XHJcblx0ICAgIH07XHJcblx0ICAgIC8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLXdpdGgtc3RhdGVtZW50XHJcblx0ICAgIFBhcnNlci5wcm90b3R5cGUucGFyc2VXaXRoU3RhdGVtZW50ID0gZnVuY3Rpb24gKCkge1xyXG5cdCAgICAgICAgaWYgKHRoaXMuY29udGV4dC5zdHJpY3QpIHtcclxuXHQgICAgICAgICAgICB0aGlzLnRvbGVyYXRlRXJyb3IobWVzc2FnZXNfMS5NZXNzYWdlcy5TdHJpY3RNb2RlV2l0aCk7XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICB2YXIgbm9kZSA9IHRoaXMuY3JlYXRlTm9kZSgpO1xyXG5cdCAgICAgICAgdmFyIGJvZHk7XHJcblx0ICAgICAgICB0aGlzLmV4cGVjdEtleXdvcmQoJ3dpdGgnKTtcclxuXHQgICAgICAgIHRoaXMuZXhwZWN0KCcoJyk7XHJcblx0ICAgICAgICB2YXIgb2JqZWN0ID0gdGhpcy5wYXJzZUV4cHJlc3Npb24oKTtcclxuXHQgICAgICAgIGlmICghdGhpcy5tYXRjaCgnKScpICYmIHRoaXMuY29uZmlnLnRvbGVyYW50KSB7XHJcblx0ICAgICAgICAgICAgdGhpcy50b2xlcmF0ZVVuZXhwZWN0ZWRUb2tlbih0aGlzLm5leHRUb2tlbigpKTtcclxuXHQgICAgICAgICAgICBib2R5ID0gdGhpcy5maW5hbGl6ZSh0aGlzLmNyZWF0ZU5vZGUoKSwgbmV3IE5vZGUuRW1wdHlTdGF0ZW1lbnQoKSk7XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICBlbHNlIHtcclxuXHQgICAgICAgICAgICB0aGlzLmV4cGVjdCgnKScpO1xyXG5cdCAgICAgICAgICAgIGJvZHkgPSB0aGlzLnBhcnNlU3RhdGVtZW50KCk7XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICByZXR1cm4gdGhpcy5maW5hbGl6ZShub2RlLCBuZXcgTm9kZS5XaXRoU3RhdGVtZW50KG9iamVjdCwgYm9keSkpO1xyXG5cdCAgICB9O1xyXG5cdCAgICAvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1zd2l0Y2gtc3RhdGVtZW50XHJcblx0ICAgIFBhcnNlci5wcm90b3R5cGUucGFyc2VTd2l0Y2hDYXNlID0gZnVuY3Rpb24gKCkge1xyXG5cdCAgICAgICAgdmFyIG5vZGUgPSB0aGlzLmNyZWF0ZU5vZGUoKTtcclxuXHQgICAgICAgIHZhciB0ZXN0O1xyXG5cdCAgICAgICAgaWYgKHRoaXMubWF0Y2hLZXl3b3JkKCdkZWZhdWx0JykpIHtcclxuXHQgICAgICAgICAgICB0aGlzLm5leHRUb2tlbigpO1xyXG5cdCAgICAgICAgICAgIHRlc3QgPSBudWxsO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgZWxzZSB7XHJcblx0ICAgICAgICAgICAgdGhpcy5leHBlY3RLZXl3b3JkKCdjYXNlJyk7XHJcblx0ICAgICAgICAgICAgdGVzdCA9IHRoaXMucGFyc2VFeHByZXNzaW9uKCk7XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICB0aGlzLmV4cGVjdCgnOicpO1xyXG5cdCAgICAgICAgdmFyIGNvbnNlcXVlbnQgPSBbXTtcclxuXHQgICAgICAgIHdoaWxlICh0cnVlKSB7XHJcblx0ICAgICAgICAgICAgaWYgKHRoaXMubWF0Y2goJ30nKSB8fCB0aGlzLm1hdGNoS2V5d29yZCgnZGVmYXVsdCcpIHx8IHRoaXMubWF0Y2hLZXl3b3JkKCdjYXNlJykpIHtcclxuXHQgICAgICAgICAgICAgICAgYnJlYWs7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgIGNvbnNlcXVlbnQucHVzaCh0aGlzLnBhcnNlU3RhdGVtZW50TGlzdEl0ZW0oKSk7XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICByZXR1cm4gdGhpcy5maW5hbGl6ZShub2RlLCBuZXcgTm9kZS5Td2l0Y2hDYXNlKHRlc3QsIGNvbnNlcXVlbnQpKTtcclxuXHQgICAgfTtcclxuXHQgICAgUGFyc2VyLnByb3RvdHlwZS5wYXJzZVN3aXRjaFN0YXRlbWVudCA9IGZ1bmN0aW9uICgpIHtcclxuXHQgICAgICAgIHZhciBub2RlID0gdGhpcy5jcmVhdGVOb2RlKCk7XHJcblx0ICAgICAgICB0aGlzLmV4cGVjdEtleXdvcmQoJ3N3aXRjaCcpO1xyXG5cdCAgICAgICAgdGhpcy5leHBlY3QoJygnKTtcclxuXHQgICAgICAgIHZhciBkaXNjcmltaW5hbnQgPSB0aGlzLnBhcnNlRXhwcmVzc2lvbigpO1xyXG5cdCAgICAgICAgdGhpcy5leHBlY3QoJyknKTtcclxuXHQgICAgICAgIHZhciBwcmV2aW91c0luU3dpdGNoID0gdGhpcy5jb250ZXh0LmluU3dpdGNoO1xyXG5cdCAgICAgICAgdGhpcy5jb250ZXh0LmluU3dpdGNoID0gdHJ1ZTtcclxuXHQgICAgICAgIHZhciBjYXNlcyA9IFtdO1xyXG5cdCAgICAgICAgdmFyIGRlZmF1bHRGb3VuZCA9IGZhbHNlO1xyXG5cdCAgICAgICAgdGhpcy5leHBlY3QoJ3snKTtcclxuXHQgICAgICAgIHdoaWxlICh0cnVlKSB7XHJcblx0ICAgICAgICAgICAgaWYgKHRoaXMubWF0Y2goJ30nKSkge1xyXG5cdCAgICAgICAgICAgICAgICBicmVhaztcclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgdmFyIGNsYXVzZSA9IHRoaXMucGFyc2VTd2l0Y2hDYXNlKCk7XHJcblx0ICAgICAgICAgICAgaWYgKGNsYXVzZS50ZXN0ID09PSBudWxsKSB7XHJcblx0ICAgICAgICAgICAgICAgIGlmIChkZWZhdWx0Rm91bmQpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgIHRoaXMudGhyb3dFcnJvcihtZXNzYWdlc18xLk1lc3NhZ2VzLk11bHRpcGxlRGVmYXVsdHNJblN3aXRjaCk7XHJcblx0ICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgZGVmYXVsdEZvdW5kID0gdHJ1ZTtcclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgY2FzZXMucHVzaChjbGF1c2UpO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgdGhpcy5leHBlY3QoJ30nKTtcclxuXHQgICAgICAgIHRoaXMuY29udGV4dC5pblN3aXRjaCA9IHByZXZpb3VzSW5Td2l0Y2g7XHJcblx0ICAgICAgICByZXR1cm4gdGhpcy5maW5hbGl6ZShub2RlLCBuZXcgTm9kZS5Td2l0Y2hTdGF0ZW1lbnQoZGlzY3JpbWluYW50LCBjYXNlcykpO1xyXG5cdCAgICB9O1xyXG5cdCAgICAvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1sYWJlbGxlZC1zdGF0ZW1lbnRzXHJcblx0ICAgIFBhcnNlci5wcm90b3R5cGUucGFyc2VMYWJlbGxlZFN0YXRlbWVudCA9IGZ1bmN0aW9uICgpIHtcclxuXHQgICAgICAgIHZhciBub2RlID0gdGhpcy5jcmVhdGVOb2RlKCk7XHJcblx0ICAgICAgICB2YXIgZXhwciA9IHRoaXMucGFyc2VFeHByZXNzaW9uKCk7XHJcblx0ICAgICAgICB2YXIgc3RhdGVtZW50O1xyXG5cdCAgICAgICAgaWYgKChleHByLnR5cGUgPT09IHN5bnRheF8xLlN5bnRheC5JZGVudGlmaWVyKSAmJiB0aGlzLm1hdGNoKCc6JykpIHtcclxuXHQgICAgICAgICAgICB0aGlzLm5leHRUb2tlbigpO1xyXG5cdCAgICAgICAgICAgIHZhciBpZCA9IGV4cHI7XHJcblx0ICAgICAgICAgICAgdmFyIGtleSA9ICckJyArIGlkLm5hbWU7XHJcblx0ICAgICAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh0aGlzLmNvbnRleHQubGFiZWxTZXQsIGtleSkpIHtcclxuXHQgICAgICAgICAgICAgICAgdGhpcy50aHJvd0Vycm9yKG1lc3NhZ2VzXzEuTWVzc2FnZXMuUmVkZWNsYXJhdGlvbiwgJ0xhYmVsJywgaWQubmFtZSk7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgIHRoaXMuY29udGV4dC5sYWJlbFNldFtrZXldID0gdHJ1ZTtcclxuXHQgICAgICAgICAgICB2YXIgYm9keSA9IHZvaWQgMDtcclxuXHQgICAgICAgICAgICBpZiAodGhpcy5tYXRjaEtleXdvcmQoJ2NsYXNzJykpIHtcclxuXHQgICAgICAgICAgICAgICAgdGhpcy50b2xlcmF0ZVVuZXhwZWN0ZWRUb2tlbih0aGlzLmxvb2thaGVhZCk7XHJcblx0ICAgICAgICAgICAgICAgIGJvZHkgPSB0aGlzLnBhcnNlQ2xhc3NEZWNsYXJhdGlvbigpO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICBlbHNlIGlmICh0aGlzLm1hdGNoS2V5d29yZCgnZnVuY3Rpb24nKSkge1xyXG5cdCAgICAgICAgICAgICAgICB2YXIgdG9rZW4gPSB0aGlzLmxvb2thaGVhZDtcclxuXHQgICAgICAgICAgICAgICAgdmFyIGRlY2xhcmF0aW9uID0gdGhpcy5wYXJzZUZ1bmN0aW9uRGVjbGFyYXRpb24oKTtcclxuXHQgICAgICAgICAgICAgICAgaWYgKHRoaXMuY29udGV4dC5zdHJpY3QpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgIHRoaXMudG9sZXJhdGVVbmV4cGVjdGVkVG9rZW4odG9rZW4sIG1lc3NhZ2VzXzEuTWVzc2FnZXMuU3RyaWN0RnVuY3Rpb24pO1xyXG5cdCAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgIGVsc2UgaWYgKGRlY2xhcmF0aW9uLmdlbmVyYXRvcikge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgdGhpcy50b2xlcmF0ZVVuZXhwZWN0ZWRUb2tlbih0b2tlbiwgbWVzc2FnZXNfMS5NZXNzYWdlcy5HZW5lcmF0b3JJbkxlZ2FjeUNvbnRleHQpO1xyXG5cdCAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgIGJvZHkgPSBkZWNsYXJhdGlvbjtcclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgZWxzZSB7XHJcblx0ICAgICAgICAgICAgICAgIGJvZHkgPSB0aGlzLnBhcnNlU3RhdGVtZW50KCk7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgIGRlbGV0ZSB0aGlzLmNvbnRleHQubGFiZWxTZXRba2V5XTtcclxuXHQgICAgICAgICAgICBzdGF0ZW1lbnQgPSBuZXcgTm9kZS5MYWJlbGVkU3RhdGVtZW50KGlkLCBib2R5KTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIGVsc2Uge1xyXG5cdCAgICAgICAgICAgIHRoaXMuY29uc3VtZVNlbWljb2xvbigpO1xyXG5cdCAgICAgICAgICAgIHN0YXRlbWVudCA9IG5ldyBOb2RlLkV4cHJlc3Npb25TdGF0ZW1lbnQoZXhwcik7XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICByZXR1cm4gdGhpcy5maW5hbGl6ZShub2RlLCBzdGF0ZW1lbnQpO1xyXG5cdCAgICB9O1xyXG5cdCAgICAvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy10aHJvdy1zdGF0ZW1lbnRcclxuXHQgICAgUGFyc2VyLnByb3RvdHlwZS5wYXJzZVRocm93U3RhdGVtZW50ID0gZnVuY3Rpb24gKCkge1xyXG5cdCAgICAgICAgdmFyIG5vZGUgPSB0aGlzLmNyZWF0ZU5vZGUoKTtcclxuXHQgICAgICAgIHRoaXMuZXhwZWN0S2V5d29yZCgndGhyb3cnKTtcclxuXHQgICAgICAgIGlmICh0aGlzLmhhc0xpbmVUZXJtaW5hdG9yKSB7XHJcblx0ICAgICAgICAgICAgdGhpcy50aHJvd0Vycm9yKG1lc3NhZ2VzXzEuTWVzc2FnZXMuTmV3bGluZUFmdGVyVGhyb3cpO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgdmFyIGFyZ3VtZW50ID0gdGhpcy5wYXJzZUV4cHJlc3Npb24oKTtcclxuXHQgICAgICAgIHRoaXMuY29uc3VtZVNlbWljb2xvbigpO1xyXG5cdCAgICAgICAgcmV0dXJuIHRoaXMuZmluYWxpemUobm9kZSwgbmV3IE5vZGUuVGhyb3dTdGF0ZW1lbnQoYXJndW1lbnQpKTtcclxuXHQgICAgfTtcclxuXHQgICAgLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtdHJ5LXN0YXRlbWVudFxyXG5cdCAgICBQYXJzZXIucHJvdG90eXBlLnBhcnNlQ2F0Y2hDbGF1c2UgPSBmdW5jdGlvbiAoKSB7XHJcblx0ICAgICAgICB2YXIgbm9kZSA9IHRoaXMuY3JlYXRlTm9kZSgpO1xyXG5cdCAgICAgICAgdGhpcy5leHBlY3RLZXl3b3JkKCdjYXRjaCcpO1xyXG5cdCAgICAgICAgdGhpcy5leHBlY3QoJygnKTtcclxuXHQgICAgICAgIGlmICh0aGlzLm1hdGNoKCcpJykpIHtcclxuXHQgICAgICAgICAgICB0aGlzLnRocm93VW5leHBlY3RlZFRva2VuKHRoaXMubG9va2FoZWFkKTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIHZhciBwYXJhbXMgPSBbXTtcclxuXHQgICAgICAgIHZhciBwYXJhbSA9IHRoaXMucGFyc2VQYXR0ZXJuKHBhcmFtcyk7XHJcblx0ICAgICAgICB2YXIgcGFyYW1NYXAgPSB7fTtcclxuXHQgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcGFyYW1zLmxlbmd0aDsgaSsrKSB7XHJcblx0ICAgICAgICAgICAgdmFyIGtleSA9ICckJyArIHBhcmFtc1tpXS52YWx1ZTtcclxuXHQgICAgICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHBhcmFtTWFwLCBrZXkpKSB7XHJcblx0ICAgICAgICAgICAgICAgIHRoaXMudG9sZXJhdGVFcnJvcihtZXNzYWdlc18xLk1lc3NhZ2VzLkR1cGxpY2F0ZUJpbmRpbmcsIHBhcmFtc1tpXS52YWx1ZSk7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgIHBhcmFtTWFwW2tleV0gPSB0cnVlO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgaWYgKHRoaXMuY29udGV4dC5zdHJpY3QgJiYgcGFyYW0udHlwZSA9PT0gc3ludGF4XzEuU3ludGF4LklkZW50aWZpZXIpIHtcclxuXHQgICAgICAgICAgICBpZiAodGhpcy5zY2FubmVyLmlzUmVzdHJpY3RlZFdvcmQocGFyYW0ubmFtZSkpIHtcclxuXHQgICAgICAgICAgICAgICAgdGhpcy50b2xlcmF0ZUVycm9yKG1lc3NhZ2VzXzEuTWVzc2FnZXMuU3RyaWN0Q2F0Y2hWYXJpYWJsZSk7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgdGhpcy5leHBlY3QoJyknKTtcclxuXHQgICAgICAgIHZhciBib2R5ID0gdGhpcy5wYXJzZUJsb2NrKCk7XHJcblx0ICAgICAgICByZXR1cm4gdGhpcy5maW5hbGl6ZShub2RlLCBuZXcgTm9kZS5DYXRjaENsYXVzZShwYXJhbSwgYm9keSkpO1xyXG5cdCAgICB9O1xyXG5cdCAgICBQYXJzZXIucHJvdG90eXBlLnBhcnNlRmluYWxseUNsYXVzZSA9IGZ1bmN0aW9uICgpIHtcclxuXHQgICAgICAgIHRoaXMuZXhwZWN0S2V5d29yZCgnZmluYWxseScpO1xyXG5cdCAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VCbG9jaygpO1xyXG5cdCAgICB9O1xyXG5cdCAgICBQYXJzZXIucHJvdG90eXBlLnBhcnNlVHJ5U3RhdGVtZW50ID0gZnVuY3Rpb24gKCkge1xyXG5cdCAgICAgICAgdmFyIG5vZGUgPSB0aGlzLmNyZWF0ZU5vZGUoKTtcclxuXHQgICAgICAgIHRoaXMuZXhwZWN0S2V5d29yZCgndHJ5Jyk7XHJcblx0ICAgICAgICB2YXIgYmxvY2sgPSB0aGlzLnBhcnNlQmxvY2soKTtcclxuXHQgICAgICAgIHZhciBoYW5kbGVyID0gdGhpcy5tYXRjaEtleXdvcmQoJ2NhdGNoJykgPyB0aGlzLnBhcnNlQ2F0Y2hDbGF1c2UoKSA6IG51bGw7XHJcblx0ICAgICAgICB2YXIgZmluYWxpemVyID0gdGhpcy5tYXRjaEtleXdvcmQoJ2ZpbmFsbHknKSA/IHRoaXMucGFyc2VGaW5hbGx5Q2xhdXNlKCkgOiBudWxsO1xyXG5cdCAgICAgICAgaWYgKCFoYW5kbGVyICYmICFmaW5hbGl6ZXIpIHtcclxuXHQgICAgICAgICAgICB0aGlzLnRocm93RXJyb3IobWVzc2FnZXNfMS5NZXNzYWdlcy5Ob0NhdGNoT3JGaW5hbGx5KTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIHJldHVybiB0aGlzLmZpbmFsaXplKG5vZGUsIG5ldyBOb2RlLlRyeVN0YXRlbWVudChibG9jaywgaGFuZGxlciwgZmluYWxpemVyKSk7XHJcblx0ICAgIH07XHJcblx0ICAgIC8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLWRlYnVnZ2VyLXN0YXRlbWVudFxyXG5cdCAgICBQYXJzZXIucHJvdG90eXBlLnBhcnNlRGVidWdnZXJTdGF0ZW1lbnQgPSBmdW5jdGlvbiAoKSB7XHJcblx0ICAgICAgICB2YXIgbm9kZSA9IHRoaXMuY3JlYXRlTm9kZSgpO1xyXG5cdCAgICAgICAgdGhpcy5leHBlY3RLZXl3b3JkKCdkZWJ1Z2dlcicpO1xyXG5cdCAgICAgICAgdGhpcy5jb25zdW1lU2VtaWNvbG9uKCk7XHJcblx0ICAgICAgICByZXR1cm4gdGhpcy5maW5hbGl6ZShub2RlLCBuZXcgTm9kZS5EZWJ1Z2dlclN0YXRlbWVudCgpKTtcclxuXHQgICAgfTtcclxuXHQgICAgLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtZWNtYXNjcmlwdC1sYW5ndWFnZS1zdGF0ZW1lbnRzLWFuZC1kZWNsYXJhdGlvbnNcclxuXHQgICAgUGFyc2VyLnByb3RvdHlwZS5wYXJzZVN0YXRlbWVudCA9IGZ1bmN0aW9uICgpIHtcclxuXHQgICAgICAgIHZhciBzdGF0ZW1lbnQ7XHJcblx0ICAgICAgICBzd2l0Y2ggKHRoaXMubG9va2FoZWFkLnR5cGUpIHtcclxuXHQgICAgICAgICAgICBjYXNlIDEgLyogQm9vbGVhbkxpdGVyYWwgKi86XHJcblx0ICAgICAgICAgICAgY2FzZSA1IC8qIE51bGxMaXRlcmFsICovOlxyXG5cdCAgICAgICAgICAgIGNhc2UgNiAvKiBOdW1lcmljTGl0ZXJhbCAqLzpcclxuXHQgICAgICAgICAgICBjYXNlIDggLyogU3RyaW5nTGl0ZXJhbCAqLzpcclxuXHQgICAgICAgICAgICBjYXNlIDEwIC8qIFRlbXBsYXRlICovOlxyXG5cdCAgICAgICAgICAgIGNhc2UgOSAvKiBSZWd1bGFyRXhwcmVzc2lvbiAqLzpcclxuXHQgICAgICAgICAgICAgICAgc3RhdGVtZW50ID0gdGhpcy5wYXJzZUV4cHJlc3Npb25TdGF0ZW1lbnQoKTtcclxuXHQgICAgICAgICAgICAgICAgYnJlYWs7XHJcblx0ICAgICAgICAgICAgY2FzZSA3IC8qIFB1bmN0dWF0b3IgKi86XHJcblx0ICAgICAgICAgICAgICAgIHZhciB2YWx1ZSA9IHRoaXMubG9va2FoZWFkLnZhbHVlO1xyXG5cdCAgICAgICAgICAgICAgICBpZiAodmFsdWUgPT09ICd7Jykge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgc3RhdGVtZW50ID0gdGhpcy5wYXJzZUJsb2NrKCk7XHJcblx0ICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgZWxzZSBpZiAodmFsdWUgPT09ICcoJykge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgc3RhdGVtZW50ID0gdGhpcy5wYXJzZUV4cHJlc3Npb25TdGF0ZW1lbnQoKTtcclxuXHQgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICBlbHNlIGlmICh2YWx1ZSA9PT0gJzsnKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICBzdGF0ZW1lbnQgPSB0aGlzLnBhcnNlRW1wdHlTdGF0ZW1lbnQoKTtcclxuXHQgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICBlbHNlIHtcclxuXHQgICAgICAgICAgICAgICAgICAgIHN0YXRlbWVudCA9IHRoaXMucGFyc2VFeHByZXNzaW9uU3RhdGVtZW50KCk7XHJcblx0ICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgYnJlYWs7XHJcblx0ICAgICAgICAgICAgY2FzZSAzIC8qIElkZW50aWZpZXIgKi86XHJcblx0ICAgICAgICAgICAgICAgIHN0YXRlbWVudCA9IHRoaXMubWF0Y2hBc3luY0Z1bmN0aW9uKCkgPyB0aGlzLnBhcnNlRnVuY3Rpb25EZWNsYXJhdGlvbigpIDogdGhpcy5wYXJzZUxhYmVsbGVkU3RhdGVtZW50KCk7XHJcblx0ICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cdCAgICAgICAgICAgIGNhc2UgNCAvKiBLZXl3b3JkICovOlxyXG5cdCAgICAgICAgICAgICAgICBzd2l0Y2ggKHRoaXMubG9va2FoZWFkLnZhbHVlKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICBjYXNlICdicmVhayc6XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGVtZW50ID0gdGhpcy5wYXJzZUJyZWFrU3RhdGVtZW50KCk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcblx0ICAgICAgICAgICAgICAgICAgICBjYXNlICdjb250aW51ZSc6XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGVtZW50ID0gdGhpcy5wYXJzZUNvbnRpbnVlU3RhdGVtZW50KCk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcblx0ICAgICAgICAgICAgICAgICAgICBjYXNlICdkZWJ1Z2dlcic6XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGVtZW50ID0gdGhpcy5wYXJzZURlYnVnZ2VyU3RhdGVtZW50KCk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcblx0ICAgICAgICAgICAgICAgICAgICBjYXNlICdkbyc6XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGVtZW50ID0gdGhpcy5wYXJzZURvV2hpbGVTdGF0ZW1lbnQoKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuXHQgICAgICAgICAgICAgICAgICAgIGNhc2UgJ2Zvcic6XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGVtZW50ID0gdGhpcy5wYXJzZUZvclN0YXRlbWVudCgpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgY2FzZSAnZnVuY3Rpb24nOlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRlbWVudCA9IHRoaXMucGFyc2VGdW5jdGlvbkRlY2xhcmF0aW9uKCk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcblx0ICAgICAgICAgICAgICAgICAgICBjYXNlICdpZic6XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGVtZW50ID0gdGhpcy5wYXJzZUlmU3RhdGVtZW50KCk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcblx0ICAgICAgICAgICAgICAgICAgICBjYXNlICdyZXR1cm4nOlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRlbWVudCA9IHRoaXMucGFyc2VSZXR1cm5TdGF0ZW1lbnQoKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuXHQgICAgICAgICAgICAgICAgICAgIGNhc2UgJ3N3aXRjaCc6XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGVtZW50ID0gdGhpcy5wYXJzZVN3aXRjaFN0YXRlbWVudCgpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgY2FzZSAndGhyb3cnOlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRlbWVudCA9IHRoaXMucGFyc2VUaHJvd1N0YXRlbWVudCgpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgY2FzZSAndHJ5JzpcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBzdGF0ZW1lbnQgPSB0aGlzLnBhcnNlVHJ5U3RhdGVtZW50KCk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcblx0ICAgICAgICAgICAgICAgICAgICBjYXNlICd2YXInOlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRlbWVudCA9IHRoaXMucGFyc2VWYXJpYWJsZVN0YXRlbWVudCgpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgY2FzZSAnd2hpbGUnOlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRlbWVudCA9IHRoaXMucGFyc2VXaGlsZVN0YXRlbWVudCgpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgY2FzZSAnd2l0aCc6XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGVtZW50ID0gdGhpcy5wYXJzZVdpdGhTdGF0ZW1lbnQoKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuXHQgICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGVtZW50ID0gdGhpcy5wYXJzZUV4cHJlc3Npb25TdGF0ZW1lbnQoKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuXHQgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICBicmVhaztcclxuXHQgICAgICAgICAgICBkZWZhdWx0OlxyXG5cdCAgICAgICAgICAgICAgICBzdGF0ZW1lbnQgPSB0aGlzLnRocm93VW5leHBlY3RlZFRva2VuKHRoaXMubG9va2FoZWFkKTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIHJldHVybiBzdGF0ZW1lbnQ7XHJcblx0ICAgIH07XHJcblx0ICAgIC8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLWZ1bmN0aW9uLWRlZmluaXRpb25zXHJcblx0ICAgIFBhcnNlci5wcm90b3R5cGUucGFyc2VGdW5jdGlvblNvdXJjZUVsZW1lbnRzID0gZnVuY3Rpb24gKCkge1xyXG5cdCAgICAgICAgdmFyIG5vZGUgPSB0aGlzLmNyZWF0ZU5vZGUoKTtcclxuXHQgICAgICAgIHRoaXMuZXhwZWN0KCd7Jyk7XHJcblx0ICAgICAgICB2YXIgYm9keSA9IHRoaXMucGFyc2VEaXJlY3RpdmVQcm9sb2d1ZXMoKTtcclxuXHQgICAgICAgIHZhciBwcmV2aW91c0xhYmVsU2V0ID0gdGhpcy5jb250ZXh0LmxhYmVsU2V0O1xyXG5cdCAgICAgICAgdmFyIHByZXZpb3VzSW5JdGVyYXRpb24gPSB0aGlzLmNvbnRleHQuaW5JdGVyYXRpb247XHJcblx0ICAgICAgICB2YXIgcHJldmlvdXNJblN3aXRjaCA9IHRoaXMuY29udGV4dC5pblN3aXRjaDtcclxuXHQgICAgICAgIHZhciBwcmV2aW91c0luRnVuY3Rpb25Cb2R5ID0gdGhpcy5jb250ZXh0LmluRnVuY3Rpb25Cb2R5O1xyXG5cdCAgICAgICAgdGhpcy5jb250ZXh0LmxhYmVsU2V0ID0ge307XHJcblx0ICAgICAgICB0aGlzLmNvbnRleHQuaW5JdGVyYXRpb24gPSBmYWxzZTtcclxuXHQgICAgICAgIHRoaXMuY29udGV4dC5pblN3aXRjaCA9IGZhbHNlO1xyXG5cdCAgICAgICAgdGhpcy5jb250ZXh0LmluRnVuY3Rpb25Cb2R5ID0gdHJ1ZTtcclxuXHQgICAgICAgIHdoaWxlICh0aGlzLmxvb2thaGVhZC50eXBlICE9PSAyIC8qIEVPRiAqLykge1xyXG5cdCAgICAgICAgICAgIGlmICh0aGlzLm1hdGNoKCd9JykpIHtcclxuXHQgICAgICAgICAgICAgICAgYnJlYWs7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgIGJvZHkucHVzaCh0aGlzLnBhcnNlU3RhdGVtZW50TGlzdEl0ZW0oKSk7XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICB0aGlzLmV4cGVjdCgnfScpO1xyXG5cdCAgICAgICAgdGhpcy5jb250ZXh0LmxhYmVsU2V0ID0gcHJldmlvdXNMYWJlbFNldDtcclxuXHQgICAgICAgIHRoaXMuY29udGV4dC5pbkl0ZXJhdGlvbiA9IHByZXZpb3VzSW5JdGVyYXRpb247XHJcblx0ICAgICAgICB0aGlzLmNvbnRleHQuaW5Td2l0Y2ggPSBwcmV2aW91c0luU3dpdGNoO1xyXG5cdCAgICAgICAgdGhpcy5jb250ZXh0LmluRnVuY3Rpb25Cb2R5ID0gcHJldmlvdXNJbkZ1bmN0aW9uQm9keTtcclxuXHQgICAgICAgIHJldHVybiB0aGlzLmZpbmFsaXplKG5vZGUsIG5ldyBOb2RlLkJsb2NrU3RhdGVtZW50KGJvZHkpKTtcclxuXHQgICAgfTtcclxuXHQgICAgUGFyc2VyLnByb3RvdHlwZS52YWxpZGF0ZVBhcmFtID0gZnVuY3Rpb24gKG9wdGlvbnMsIHBhcmFtLCBuYW1lKSB7XHJcblx0ICAgICAgICB2YXIga2V5ID0gJyQnICsgbmFtZTtcclxuXHQgICAgICAgIGlmICh0aGlzLmNvbnRleHQuc3RyaWN0KSB7XHJcblx0ICAgICAgICAgICAgaWYgKHRoaXMuc2Nhbm5lci5pc1Jlc3RyaWN0ZWRXb3JkKG5hbWUpKSB7XHJcblx0ICAgICAgICAgICAgICAgIG9wdGlvbnMuc3RyaWN0ZWQgPSBwYXJhbTtcclxuXHQgICAgICAgICAgICAgICAgb3B0aW9ucy5tZXNzYWdlID0gbWVzc2FnZXNfMS5NZXNzYWdlcy5TdHJpY3RQYXJhbU5hbWU7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob3B0aW9ucy5wYXJhbVNldCwga2V5KSkge1xyXG5cdCAgICAgICAgICAgICAgICBvcHRpb25zLnN0cmljdGVkID0gcGFyYW07XHJcblx0ICAgICAgICAgICAgICAgIG9wdGlvbnMubWVzc2FnZSA9IG1lc3NhZ2VzXzEuTWVzc2FnZXMuU3RyaWN0UGFyYW1EdXBlO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIGVsc2UgaWYgKCFvcHRpb25zLmZpcnN0UmVzdHJpY3RlZCkge1xyXG5cdCAgICAgICAgICAgIGlmICh0aGlzLnNjYW5uZXIuaXNSZXN0cmljdGVkV29yZChuYW1lKSkge1xyXG5cdCAgICAgICAgICAgICAgICBvcHRpb25zLmZpcnN0UmVzdHJpY3RlZCA9IHBhcmFtO1xyXG5cdCAgICAgICAgICAgICAgICBvcHRpb25zLm1lc3NhZ2UgPSBtZXNzYWdlc18xLk1lc3NhZ2VzLlN0cmljdFBhcmFtTmFtZTtcclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5zY2FubmVyLmlzU3RyaWN0TW9kZVJlc2VydmVkV29yZChuYW1lKSkge1xyXG5cdCAgICAgICAgICAgICAgICBvcHRpb25zLmZpcnN0UmVzdHJpY3RlZCA9IHBhcmFtO1xyXG5cdCAgICAgICAgICAgICAgICBvcHRpb25zLm1lc3NhZ2UgPSBtZXNzYWdlc18xLk1lc3NhZ2VzLlN0cmljdFJlc2VydmVkV29yZDtcclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgZWxzZSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9wdGlvbnMucGFyYW1TZXQsIGtleSkpIHtcclxuXHQgICAgICAgICAgICAgICAgb3B0aW9ucy5zdHJpY3RlZCA9IHBhcmFtO1xyXG5cdCAgICAgICAgICAgICAgICBvcHRpb25zLm1lc3NhZ2UgPSBtZXNzYWdlc18xLk1lc3NhZ2VzLlN0cmljdFBhcmFtRHVwZTtcclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xyXG5cdCAgICAgICAgaWYgKHR5cGVvZiBPYmplY3QuZGVmaW5lUHJvcGVydHkgPT09ICdmdW5jdGlvbicpIHtcclxuXHQgICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkob3B0aW9ucy5wYXJhbVNldCwga2V5LCB7IHZhbHVlOiB0cnVlLCBlbnVtZXJhYmxlOiB0cnVlLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0pO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgZWxzZSB7XHJcblx0ICAgICAgICAgICAgb3B0aW9ucy5wYXJhbVNldFtrZXldID0gdHJ1ZTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgfTtcclxuXHQgICAgUGFyc2VyLnByb3RvdHlwZS5wYXJzZVJlc3RFbGVtZW50ID0gZnVuY3Rpb24gKHBhcmFtcykge1xyXG5cdCAgICAgICAgdmFyIG5vZGUgPSB0aGlzLmNyZWF0ZU5vZGUoKTtcclxuXHQgICAgICAgIHRoaXMuZXhwZWN0KCcuLi4nKTtcclxuXHQgICAgICAgIHZhciBhcmcgPSB0aGlzLnBhcnNlUGF0dGVybihwYXJhbXMpO1xyXG5cdCAgICAgICAgaWYgKHRoaXMubWF0Y2goJz0nKSkge1xyXG5cdCAgICAgICAgICAgIHRoaXMudGhyb3dFcnJvcihtZXNzYWdlc18xLk1lc3NhZ2VzLkRlZmF1bHRSZXN0UGFyYW1ldGVyKTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIGlmICghdGhpcy5tYXRjaCgnKScpKSB7XHJcblx0ICAgICAgICAgICAgdGhpcy50aHJvd0Vycm9yKG1lc3NhZ2VzXzEuTWVzc2FnZXMuUGFyYW1ldGVyQWZ0ZXJSZXN0UGFyYW1ldGVyKTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIHJldHVybiB0aGlzLmZpbmFsaXplKG5vZGUsIG5ldyBOb2RlLlJlc3RFbGVtZW50KGFyZykpO1xyXG5cdCAgICB9O1xyXG5cdCAgICBQYXJzZXIucHJvdG90eXBlLnBhcnNlRm9ybWFsUGFyYW1ldGVyID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcclxuXHQgICAgICAgIHZhciBwYXJhbXMgPSBbXTtcclxuXHQgICAgICAgIHZhciBwYXJhbSA9IHRoaXMubWF0Y2goJy4uLicpID8gdGhpcy5wYXJzZVJlc3RFbGVtZW50KHBhcmFtcykgOiB0aGlzLnBhcnNlUGF0dGVybldpdGhEZWZhdWx0KHBhcmFtcyk7XHJcblx0ICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBhcmFtcy5sZW5ndGg7IGkrKykge1xyXG5cdCAgICAgICAgICAgIHRoaXMudmFsaWRhdGVQYXJhbShvcHRpb25zLCBwYXJhbXNbaV0sIHBhcmFtc1tpXS52YWx1ZSk7XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICBvcHRpb25zLnNpbXBsZSA9IG9wdGlvbnMuc2ltcGxlICYmIChwYXJhbSBpbnN0YW5jZW9mIE5vZGUuSWRlbnRpZmllcik7XHJcblx0ICAgICAgICBvcHRpb25zLnBhcmFtcy5wdXNoKHBhcmFtKTtcclxuXHQgICAgfTtcclxuXHQgICAgUGFyc2VyLnByb3RvdHlwZS5wYXJzZUZvcm1hbFBhcmFtZXRlcnMgPSBmdW5jdGlvbiAoZmlyc3RSZXN0cmljdGVkKSB7XHJcblx0ICAgICAgICB2YXIgb3B0aW9ucztcclxuXHQgICAgICAgIG9wdGlvbnMgPSB7XHJcblx0ICAgICAgICAgICAgc2ltcGxlOiB0cnVlLFxyXG5cdCAgICAgICAgICAgIHBhcmFtczogW10sXHJcblx0ICAgICAgICAgICAgZmlyc3RSZXN0cmljdGVkOiBmaXJzdFJlc3RyaWN0ZWRcclxuXHQgICAgICAgIH07XHJcblx0ICAgICAgICB0aGlzLmV4cGVjdCgnKCcpO1xyXG5cdCAgICAgICAgaWYgKCF0aGlzLm1hdGNoKCcpJykpIHtcclxuXHQgICAgICAgICAgICBvcHRpb25zLnBhcmFtU2V0ID0ge307XHJcblx0ICAgICAgICAgICAgd2hpbGUgKHRoaXMubG9va2FoZWFkLnR5cGUgIT09IDIgLyogRU9GICovKSB7XHJcblx0ICAgICAgICAgICAgICAgIHRoaXMucGFyc2VGb3JtYWxQYXJhbWV0ZXIob3B0aW9ucyk7XHJcblx0ICAgICAgICAgICAgICAgIGlmICh0aGlzLm1hdGNoKCcpJykpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cdCAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgIHRoaXMuZXhwZWN0KCcsJyk7XHJcblx0ICAgICAgICAgICAgICAgIGlmICh0aGlzLm1hdGNoKCcpJykpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cdCAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgdGhpcy5leHBlY3QoJyknKTtcclxuXHQgICAgICAgIHJldHVybiB7XHJcblx0ICAgICAgICAgICAgc2ltcGxlOiBvcHRpb25zLnNpbXBsZSxcclxuXHQgICAgICAgICAgICBwYXJhbXM6IG9wdGlvbnMucGFyYW1zLFxyXG5cdCAgICAgICAgICAgIHN0cmljdGVkOiBvcHRpb25zLnN0cmljdGVkLFxyXG5cdCAgICAgICAgICAgIGZpcnN0UmVzdHJpY3RlZDogb3B0aW9ucy5maXJzdFJlc3RyaWN0ZWQsXHJcblx0ICAgICAgICAgICAgbWVzc2FnZTogb3B0aW9ucy5tZXNzYWdlXHJcblx0ICAgICAgICB9O1xyXG5cdCAgICB9O1xyXG5cdCAgICBQYXJzZXIucHJvdG90eXBlLm1hdGNoQXN5bmNGdW5jdGlvbiA9IGZ1bmN0aW9uICgpIHtcclxuXHQgICAgICAgIHZhciBtYXRjaCA9IHRoaXMubWF0Y2hDb250ZXh0dWFsS2V5d29yZCgnYXN5bmMnKTtcclxuXHQgICAgICAgIGlmIChtYXRjaCkge1xyXG5cdCAgICAgICAgICAgIHZhciBzdGF0ZSA9IHRoaXMuc2Nhbm5lci5zYXZlU3RhdGUoKTtcclxuXHQgICAgICAgICAgICB0aGlzLnNjYW5uZXIuc2NhbkNvbW1lbnRzKCk7XHJcblx0ICAgICAgICAgICAgdmFyIG5leHQgPSB0aGlzLnNjYW5uZXIubGV4KCk7XHJcblx0ICAgICAgICAgICAgdGhpcy5zY2FubmVyLnJlc3RvcmVTdGF0ZShzdGF0ZSk7XHJcblx0ICAgICAgICAgICAgbWF0Y2ggPSAoc3RhdGUubGluZU51bWJlciA9PT0gbmV4dC5saW5lTnVtYmVyKSAmJiAobmV4dC50eXBlID09PSA0IC8qIEtleXdvcmQgKi8pICYmIChuZXh0LnZhbHVlID09PSAnZnVuY3Rpb24nKTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIHJldHVybiBtYXRjaDtcclxuXHQgICAgfTtcclxuXHQgICAgUGFyc2VyLnByb3RvdHlwZS5wYXJzZUZ1bmN0aW9uRGVjbGFyYXRpb24gPSBmdW5jdGlvbiAoaWRlbnRpZmllcklzT3B0aW9uYWwpIHtcclxuXHQgICAgICAgIHZhciBub2RlID0gdGhpcy5jcmVhdGVOb2RlKCk7XHJcblx0ICAgICAgICB2YXIgaXNBc3luYyA9IHRoaXMubWF0Y2hDb250ZXh0dWFsS2V5d29yZCgnYXN5bmMnKTtcclxuXHQgICAgICAgIGlmIChpc0FzeW5jKSB7XHJcblx0ICAgICAgICAgICAgdGhpcy5uZXh0VG9rZW4oKTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIHRoaXMuZXhwZWN0S2V5d29yZCgnZnVuY3Rpb24nKTtcclxuXHQgICAgICAgIHZhciBpc0dlbmVyYXRvciA9IGlzQXN5bmMgPyBmYWxzZSA6IHRoaXMubWF0Y2goJyonKTtcclxuXHQgICAgICAgIGlmIChpc0dlbmVyYXRvcikge1xyXG5cdCAgICAgICAgICAgIHRoaXMubmV4dFRva2VuKCk7XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICB2YXIgbWVzc2FnZTtcclxuXHQgICAgICAgIHZhciBpZCA9IG51bGw7XHJcblx0ICAgICAgICB2YXIgZmlyc3RSZXN0cmljdGVkID0gbnVsbDtcclxuXHQgICAgICAgIGlmICghaWRlbnRpZmllcklzT3B0aW9uYWwgfHwgIXRoaXMubWF0Y2goJygnKSkge1xyXG5cdCAgICAgICAgICAgIHZhciB0b2tlbiA9IHRoaXMubG9va2FoZWFkO1xyXG5cdCAgICAgICAgICAgIGlkID0gdGhpcy5wYXJzZVZhcmlhYmxlSWRlbnRpZmllcigpO1xyXG5cdCAgICAgICAgICAgIGlmICh0aGlzLmNvbnRleHQuc3RyaWN0KSB7XHJcblx0ICAgICAgICAgICAgICAgIGlmICh0aGlzLnNjYW5uZXIuaXNSZXN0cmljdGVkV29yZCh0b2tlbi52YWx1ZSkpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgIHRoaXMudG9sZXJhdGVVbmV4cGVjdGVkVG9rZW4odG9rZW4sIG1lc3NhZ2VzXzEuTWVzc2FnZXMuU3RyaWN0RnVuY3Rpb25OYW1lKTtcclxuXHQgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICBlbHNlIHtcclxuXHQgICAgICAgICAgICAgICAgaWYgKHRoaXMuc2Nhbm5lci5pc1Jlc3RyaWN0ZWRXb3JkKHRva2VuLnZhbHVlKSkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgZmlyc3RSZXN0cmljdGVkID0gdG9rZW47XHJcblx0ICAgICAgICAgICAgICAgICAgICBtZXNzYWdlID0gbWVzc2FnZXNfMS5NZXNzYWdlcy5TdHJpY3RGdW5jdGlvbk5hbWU7XHJcblx0ICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5zY2FubmVyLmlzU3RyaWN0TW9kZVJlc2VydmVkV29yZCh0b2tlbi52YWx1ZSkpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgIGZpcnN0UmVzdHJpY3RlZCA9IHRva2VuO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgbWVzc2FnZSA9IG1lc3NhZ2VzXzEuTWVzc2FnZXMuU3RyaWN0UmVzZXJ2ZWRXb3JkO1xyXG5cdCAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgdmFyIHByZXZpb3VzQWxsb3dBd2FpdCA9IHRoaXMuY29udGV4dC5hd2FpdDtcclxuXHQgICAgICAgIHZhciBwcmV2aW91c0FsbG93WWllbGQgPSB0aGlzLmNvbnRleHQuYWxsb3dZaWVsZDtcclxuXHQgICAgICAgIHRoaXMuY29udGV4dC5hd2FpdCA9IGlzQXN5bmM7XHJcblx0ICAgICAgICB0aGlzLmNvbnRleHQuYWxsb3dZaWVsZCA9ICFpc0dlbmVyYXRvcjtcclxuXHQgICAgICAgIHZhciBmb3JtYWxQYXJhbWV0ZXJzID0gdGhpcy5wYXJzZUZvcm1hbFBhcmFtZXRlcnMoZmlyc3RSZXN0cmljdGVkKTtcclxuXHQgICAgICAgIHZhciBwYXJhbXMgPSBmb3JtYWxQYXJhbWV0ZXJzLnBhcmFtcztcclxuXHQgICAgICAgIHZhciBzdHJpY3RlZCA9IGZvcm1hbFBhcmFtZXRlcnMuc3RyaWN0ZWQ7XHJcblx0ICAgICAgICBmaXJzdFJlc3RyaWN0ZWQgPSBmb3JtYWxQYXJhbWV0ZXJzLmZpcnN0UmVzdHJpY3RlZDtcclxuXHQgICAgICAgIGlmIChmb3JtYWxQYXJhbWV0ZXJzLm1lc3NhZ2UpIHtcclxuXHQgICAgICAgICAgICBtZXNzYWdlID0gZm9ybWFsUGFyYW1ldGVycy5tZXNzYWdlO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgdmFyIHByZXZpb3VzU3RyaWN0ID0gdGhpcy5jb250ZXh0LnN0cmljdDtcclxuXHQgICAgICAgIHZhciBwcmV2aW91c0FsbG93U3RyaWN0RGlyZWN0aXZlID0gdGhpcy5jb250ZXh0LmFsbG93U3RyaWN0RGlyZWN0aXZlO1xyXG5cdCAgICAgICAgdGhpcy5jb250ZXh0LmFsbG93U3RyaWN0RGlyZWN0aXZlID0gZm9ybWFsUGFyYW1ldGVycy5zaW1wbGU7XHJcblx0ICAgICAgICB2YXIgYm9keSA9IHRoaXMucGFyc2VGdW5jdGlvblNvdXJjZUVsZW1lbnRzKCk7XHJcblx0ICAgICAgICBpZiAodGhpcy5jb250ZXh0LnN0cmljdCAmJiBmaXJzdFJlc3RyaWN0ZWQpIHtcclxuXHQgICAgICAgICAgICB0aGlzLnRocm93VW5leHBlY3RlZFRva2VuKGZpcnN0UmVzdHJpY3RlZCwgbWVzc2FnZSk7XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICBpZiAodGhpcy5jb250ZXh0LnN0cmljdCAmJiBzdHJpY3RlZCkge1xyXG5cdCAgICAgICAgICAgIHRoaXMudG9sZXJhdGVVbmV4cGVjdGVkVG9rZW4oc3RyaWN0ZWQsIG1lc3NhZ2UpO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgdGhpcy5jb250ZXh0LnN0cmljdCA9IHByZXZpb3VzU3RyaWN0O1xyXG5cdCAgICAgICAgdGhpcy5jb250ZXh0LmFsbG93U3RyaWN0RGlyZWN0aXZlID0gcHJldmlvdXNBbGxvd1N0cmljdERpcmVjdGl2ZTtcclxuXHQgICAgICAgIHRoaXMuY29udGV4dC5hd2FpdCA9IHByZXZpb3VzQWxsb3dBd2FpdDtcclxuXHQgICAgICAgIHRoaXMuY29udGV4dC5hbGxvd1lpZWxkID0gcHJldmlvdXNBbGxvd1lpZWxkO1xyXG5cdCAgICAgICAgcmV0dXJuIGlzQXN5bmMgPyB0aGlzLmZpbmFsaXplKG5vZGUsIG5ldyBOb2RlLkFzeW5jRnVuY3Rpb25EZWNsYXJhdGlvbihpZCwgcGFyYW1zLCBib2R5KSkgOlxyXG5cdCAgICAgICAgICAgIHRoaXMuZmluYWxpemUobm9kZSwgbmV3IE5vZGUuRnVuY3Rpb25EZWNsYXJhdGlvbihpZCwgcGFyYW1zLCBib2R5LCBpc0dlbmVyYXRvcikpO1xyXG5cdCAgICB9O1xyXG5cdCAgICBQYXJzZXIucHJvdG90eXBlLnBhcnNlRnVuY3Rpb25FeHByZXNzaW9uID0gZnVuY3Rpb24gKCkge1xyXG5cdCAgICAgICAgdmFyIG5vZGUgPSB0aGlzLmNyZWF0ZU5vZGUoKTtcclxuXHQgICAgICAgIHZhciBpc0FzeW5jID0gdGhpcy5tYXRjaENvbnRleHR1YWxLZXl3b3JkKCdhc3luYycpO1xyXG5cdCAgICAgICAgaWYgKGlzQXN5bmMpIHtcclxuXHQgICAgICAgICAgICB0aGlzLm5leHRUb2tlbigpO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgdGhpcy5leHBlY3RLZXl3b3JkKCdmdW5jdGlvbicpO1xyXG5cdCAgICAgICAgdmFyIGlzR2VuZXJhdG9yID0gaXNBc3luYyA/IGZhbHNlIDogdGhpcy5tYXRjaCgnKicpO1xyXG5cdCAgICAgICAgaWYgKGlzR2VuZXJhdG9yKSB7XHJcblx0ICAgICAgICAgICAgdGhpcy5uZXh0VG9rZW4oKTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIHZhciBtZXNzYWdlO1xyXG5cdCAgICAgICAgdmFyIGlkID0gbnVsbDtcclxuXHQgICAgICAgIHZhciBmaXJzdFJlc3RyaWN0ZWQ7XHJcblx0ICAgICAgICB2YXIgcHJldmlvdXNBbGxvd0F3YWl0ID0gdGhpcy5jb250ZXh0LmF3YWl0O1xyXG5cdCAgICAgICAgdmFyIHByZXZpb3VzQWxsb3dZaWVsZCA9IHRoaXMuY29udGV4dC5hbGxvd1lpZWxkO1xyXG5cdCAgICAgICAgdGhpcy5jb250ZXh0LmF3YWl0ID0gaXNBc3luYztcclxuXHQgICAgICAgIHRoaXMuY29udGV4dC5hbGxvd1lpZWxkID0gIWlzR2VuZXJhdG9yO1xyXG5cdCAgICAgICAgaWYgKCF0aGlzLm1hdGNoKCcoJykpIHtcclxuXHQgICAgICAgICAgICB2YXIgdG9rZW4gPSB0aGlzLmxvb2thaGVhZDtcclxuXHQgICAgICAgICAgICBpZCA9ICghdGhpcy5jb250ZXh0LnN0cmljdCAmJiAhaXNHZW5lcmF0b3IgJiYgdGhpcy5tYXRjaEtleXdvcmQoJ3lpZWxkJykpID8gdGhpcy5wYXJzZUlkZW50aWZpZXJOYW1lKCkgOiB0aGlzLnBhcnNlVmFyaWFibGVJZGVudGlmaWVyKCk7XHJcblx0ICAgICAgICAgICAgaWYgKHRoaXMuY29udGV4dC5zdHJpY3QpIHtcclxuXHQgICAgICAgICAgICAgICAgaWYgKHRoaXMuc2Nhbm5lci5pc1Jlc3RyaWN0ZWRXb3JkKHRva2VuLnZhbHVlKSkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgdGhpcy50b2xlcmF0ZVVuZXhwZWN0ZWRUb2tlbih0b2tlbiwgbWVzc2FnZXNfMS5NZXNzYWdlcy5TdHJpY3RGdW5jdGlvbk5hbWUpO1xyXG5cdCAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgIGVsc2Uge1xyXG5cdCAgICAgICAgICAgICAgICBpZiAodGhpcy5zY2FubmVyLmlzUmVzdHJpY3RlZFdvcmQodG9rZW4udmFsdWUpKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICBmaXJzdFJlc3RyaWN0ZWQgPSB0b2tlbjtcclxuXHQgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UgPSBtZXNzYWdlc18xLk1lc3NhZ2VzLlN0cmljdEZ1bmN0aW9uTmFtZTtcclxuXHQgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICBlbHNlIGlmICh0aGlzLnNjYW5uZXIuaXNTdHJpY3RNb2RlUmVzZXJ2ZWRXb3JkKHRva2VuLnZhbHVlKSkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgZmlyc3RSZXN0cmljdGVkID0gdG9rZW47XHJcblx0ICAgICAgICAgICAgICAgICAgICBtZXNzYWdlID0gbWVzc2FnZXNfMS5NZXNzYWdlcy5TdHJpY3RSZXNlcnZlZFdvcmQ7XHJcblx0ICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICB2YXIgZm9ybWFsUGFyYW1ldGVycyA9IHRoaXMucGFyc2VGb3JtYWxQYXJhbWV0ZXJzKGZpcnN0UmVzdHJpY3RlZCk7XHJcblx0ICAgICAgICB2YXIgcGFyYW1zID0gZm9ybWFsUGFyYW1ldGVycy5wYXJhbXM7XHJcblx0ICAgICAgICB2YXIgc3RyaWN0ZWQgPSBmb3JtYWxQYXJhbWV0ZXJzLnN0cmljdGVkO1xyXG5cdCAgICAgICAgZmlyc3RSZXN0cmljdGVkID0gZm9ybWFsUGFyYW1ldGVycy5maXJzdFJlc3RyaWN0ZWQ7XHJcblx0ICAgICAgICBpZiAoZm9ybWFsUGFyYW1ldGVycy5tZXNzYWdlKSB7XHJcblx0ICAgICAgICAgICAgbWVzc2FnZSA9IGZvcm1hbFBhcmFtZXRlcnMubWVzc2FnZTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIHZhciBwcmV2aW91c1N0cmljdCA9IHRoaXMuY29udGV4dC5zdHJpY3Q7XHJcblx0ICAgICAgICB2YXIgcHJldmlvdXNBbGxvd1N0cmljdERpcmVjdGl2ZSA9IHRoaXMuY29udGV4dC5hbGxvd1N0cmljdERpcmVjdGl2ZTtcclxuXHQgICAgICAgIHRoaXMuY29udGV4dC5hbGxvd1N0cmljdERpcmVjdGl2ZSA9IGZvcm1hbFBhcmFtZXRlcnMuc2ltcGxlO1xyXG5cdCAgICAgICAgdmFyIGJvZHkgPSB0aGlzLnBhcnNlRnVuY3Rpb25Tb3VyY2VFbGVtZW50cygpO1xyXG5cdCAgICAgICAgaWYgKHRoaXMuY29udGV4dC5zdHJpY3QgJiYgZmlyc3RSZXN0cmljdGVkKSB7XHJcblx0ICAgICAgICAgICAgdGhpcy50aHJvd1VuZXhwZWN0ZWRUb2tlbihmaXJzdFJlc3RyaWN0ZWQsIG1lc3NhZ2UpO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgaWYgKHRoaXMuY29udGV4dC5zdHJpY3QgJiYgc3RyaWN0ZWQpIHtcclxuXHQgICAgICAgICAgICB0aGlzLnRvbGVyYXRlVW5leHBlY3RlZFRva2VuKHN0cmljdGVkLCBtZXNzYWdlKTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIHRoaXMuY29udGV4dC5zdHJpY3QgPSBwcmV2aW91c1N0cmljdDtcclxuXHQgICAgICAgIHRoaXMuY29udGV4dC5hbGxvd1N0cmljdERpcmVjdGl2ZSA9IHByZXZpb3VzQWxsb3dTdHJpY3REaXJlY3RpdmU7XHJcblx0ICAgICAgICB0aGlzLmNvbnRleHQuYXdhaXQgPSBwcmV2aW91c0FsbG93QXdhaXQ7XHJcblx0ICAgICAgICB0aGlzLmNvbnRleHQuYWxsb3dZaWVsZCA9IHByZXZpb3VzQWxsb3dZaWVsZDtcclxuXHQgICAgICAgIHJldHVybiBpc0FzeW5jID8gdGhpcy5maW5hbGl6ZShub2RlLCBuZXcgTm9kZS5Bc3luY0Z1bmN0aW9uRXhwcmVzc2lvbihpZCwgcGFyYW1zLCBib2R5KSkgOlxyXG5cdCAgICAgICAgICAgIHRoaXMuZmluYWxpemUobm9kZSwgbmV3IE5vZGUuRnVuY3Rpb25FeHByZXNzaW9uKGlkLCBwYXJhbXMsIGJvZHksIGlzR2VuZXJhdG9yKSk7XHJcblx0ICAgIH07XHJcblx0ICAgIC8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLWRpcmVjdGl2ZS1wcm9sb2d1ZXMtYW5kLXRoZS11c2Utc3RyaWN0LWRpcmVjdGl2ZVxyXG5cdCAgICBQYXJzZXIucHJvdG90eXBlLnBhcnNlRGlyZWN0aXZlID0gZnVuY3Rpb24gKCkge1xyXG5cdCAgICAgICAgdmFyIHRva2VuID0gdGhpcy5sb29rYWhlYWQ7XHJcblx0ICAgICAgICB2YXIgbm9kZSA9IHRoaXMuY3JlYXRlTm9kZSgpO1xyXG5cdCAgICAgICAgdmFyIGV4cHIgPSB0aGlzLnBhcnNlRXhwcmVzc2lvbigpO1xyXG5cdCAgICAgICAgdmFyIGRpcmVjdGl2ZSA9IChleHByLnR5cGUgPT09IHN5bnRheF8xLlN5bnRheC5MaXRlcmFsKSA/IHRoaXMuZ2V0VG9rZW5SYXcodG9rZW4pLnNsaWNlKDEsIC0xKSA6IG51bGw7XHJcblx0ICAgICAgICB0aGlzLmNvbnN1bWVTZW1pY29sb24oKTtcclxuXHQgICAgICAgIHJldHVybiB0aGlzLmZpbmFsaXplKG5vZGUsIGRpcmVjdGl2ZSA/IG5ldyBOb2RlLkRpcmVjdGl2ZShleHByLCBkaXJlY3RpdmUpIDogbmV3IE5vZGUuRXhwcmVzc2lvblN0YXRlbWVudChleHByKSk7XHJcblx0ICAgIH07XHJcblx0ICAgIFBhcnNlci5wcm90b3R5cGUucGFyc2VEaXJlY3RpdmVQcm9sb2d1ZXMgPSBmdW5jdGlvbiAoKSB7XHJcblx0ICAgICAgICB2YXIgZmlyc3RSZXN0cmljdGVkID0gbnVsbDtcclxuXHQgICAgICAgIHZhciBib2R5ID0gW107XHJcblx0ICAgICAgICB3aGlsZSAodHJ1ZSkge1xyXG5cdCAgICAgICAgICAgIHZhciB0b2tlbiA9IHRoaXMubG9va2FoZWFkO1xyXG5cdCAgICAgICAgICAgIGlmICh0b2tlbi50eXBlICE9PSA4IC8qIFN0cmluZ0xpdGVyYWwgKi8pIHtcclxuXHQgICAgICAgICAgICAgICAgYnJlYWs7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgIHZhciBzdGF0ZW1lbnQgPSB0aGlzLnBhcnNlRGlyZWN0aXZlKCk7XHJcblx0ICAgICAgICAgICAgYm9keS5wdXNoKHN0YXRlbWVudCk7XHJcblx0ICAgICAgICAgICAgdmFyIGRpcmVjdGl2ZSA9IHN0YXRlbWVudC5kaXJlY3RpdmU7XHJcblx0ICAgICAgICAgICAgaWYgKHR5cGVvZiBkaXJlY3RpdmUgIT09ICdzdHJpbmcnKSB7XHJcblx0ICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICBpZiAoZGlyZWN0aXZlID09PSAndXNlIHN0cmljdCcpIHtcclxuXHQgICAgICAgICAgICAgICAgdGhpcy5jb250ZXh0LnN0cmljdCA9IHRydWU7XHJcblx0ICAgICAgICAgICAgICAgIGlmIChmaXJzdFJlc3RyaWN0ZWQpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgIHRoaXMudG9sZXJhdGVVbmV4cGVjdGVkVG9rZW4oZmlyc3RSZXN0cmljdGVkLCBtZXNzYWdlc18xLk1lc3NhZ2VzLlN0cmljdE9jdGFsTGl0ZXJhbCk7XHJcblx0ICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgaWYgKCF0aGlzLmNvbnRleHQuYWxsb3dTdHJpY3REaXJlY3RpdmUpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgIHRoaXMudG9sZXJhdGVVbmV4cGVjdGVkVG9rZW4odG9rZW4sIG1lc3NhZ2VzXzEuTWVzc2FnZXMuSWxsZWdhbExhbmd1YWdlTW9kZURpcmVjdGl2ZSk7XHJcblx0ICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgZWxzZSB7XHJcblx0ICAgICAgICAgICAgICAgIGlmICghZmlyc3RSZXN0cmljdGVkICYmIHRva2VuLm9jdGFsKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICBmaXJzdFJlc3RyaWN0ZWQgPSB0b2tlbjtcclxuXHQgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIHJldHVybiBib2R5O1xyXG5cdCAgICB9O1xyXG5cdCAgICAvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1tZXRob2QtZGVmaW5pdGlvbnNcclxuXHQgICAgUGFyc2VyLnByb3RvdHlwZS5xdWFsaWZpZWRQcm9wZXJ0eU5hbWUgPSBmdW5jdGlvbiAodG9rZW4pIHtcclxuXHQgICAgICAgIHN3aXRjaCAodG9rZW4udHlwZSkge1xyXG5cdCAgICAgICAgICAgIGNhc2UgMyAvKiBJZGVudGlmaWVyICovOlxyXG5cdCAgICAgICAgICAgIGNhc2UgOCAvKiBTdHJpbmdMaXRlcmFsICovOlxyXG5cdCAgICAgICAgICAgIGNhc2UgMSAvKiBCb29sZWFuTGl0ZXJhbCAqLzpcclxuXHQgICAgICAgICAgICBjYXNlIDUgLyogTnVsbExpdGVyYWwgKi86XHJcblx0ICAgICAgICAgICAgY2FzZSA2IC8qIE51bWVyaWNMaXRlcmFsICovOlxyXG5cdCAgICAgICAgICAgIGNhc2UgNCAvKiBLZXl3b3JkICovOlxyXG5cdCAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuXHQgICAgICAgICAgICBjYXNlIDcgLyogUHVuY3R1YXRvciAqLzpcclxuXHQgICAgICAgICAgICAgICAgcmV0dXJuIHRva2VuLnZhbHVlID09PSAnWyc7XHJcblx0ICAgICAgICAgICAgZGVmYXVsdDpcclxuXHQgICAgICAgICAgICAgICAgYnJlYWs7XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICByZXR1cm4gZmFsc2U7XHJcblx0ICAgIH07XHJcblx0ICAgIFBhcnNlci5wcm90b3R5cGUucGFyc2VHZXR0ZXJNZXRob2QgPSBmdW5jdGlvbiAoKSB7XHJcblx0ICAgICAgICB2YXIgbm9kZSA9IHRoaXMuY3JlYXRlTm9kZSgpO1xyXG5cdCAgICAgICAgdmFyIGlzR2VuZXJhdG9yID0gZmFsc2U7XHJcblx0ICAgICAgICB2YXIgcHJldmlvdXNBbGxvd1lpZWxkID0gdGhpcy5jb250ZXh0LmFsbG93WWllbGQ7XHJcblx0ICAgICAgICB0aGlzLmNvbnRleHQuYWxsb3dZaWVsZCA9IGZhbHNlO1xyXG5cdCAgICAgICAgdmFyIGZvcm1hbFBhcmFtZXRlcnMgPSB0aGlzLnBhcnNlRm9ybWFsUGFyYW1ldGVycygpO1xyXG5cdCAgICAgICAgaWYgKGZvcm1hbFBhcmFtZXRlcnMucGFyYW1zLmxlbmd0aCA+IDApIHtcclxuXHQgICAgICAgICAgICB0aGlzLnRvbGVyYXRlRXJyb3IobWVzc2FnZXNfMS5NZXNzYWdlcy5CYWRHZXR0ZXJBcml0eSk7XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICB2YXIgbWV0aG9kID0gdGhpcy5wYXJzZVByb3BlcnR5TWV0aG9kKGZvcm1hbFBhcmFtZXRlcnMpO1xyXG5cdCAgICAgICAgdGhpcy5jb250ZXh0LmFsbG93WWllbGQgPSBwcmV2aW91c0FsbG93WWllbGQ7XHJcblx0ICAgICAgICByZXR1cm4gdGhpcy5maW5hbGl6ZShub2RlLCBuZXcgTm9kZS5GdW5jdGlvbkV4cHJlc3Npb24obnVsbCwgZm9ybWFsUGFyYW1ldGVycy5wYXJhbXMsIG1ldGhvZCwgaXNHZW5lcmF0b3IpKTtcclxuXHQgICAgfTtcclxuXHQgICAgUGFyc2VyLnByb3RvdHlwZS5wYXJzZVNldHRlck1ldGhvZCA9IGZ1bmN0aW9uICgpIHtcclxuXHQgICAgICAgIHZhciBub2RlID0gdGhpcy5jcmVhdGVOb2RlKCk7XHJcblx0ICAgICAgICB2YXIgaXNHZW5lcmF0b3IgPSBmYWxzZTtcclxuXHQgICAgICAgIHZhciBwcmV2aW91c0FsbG93WWllbGQgPSB0aGlzLmNvbnRleHQuYWxsb3dZaWVsZDtcclxuXHQgICAgICAgIHRoaXMuY29udGV4dC5hbGxvd1lpZWxkID0gZmFsc2U7XHJcblx0ICAgICAgICB2YXIgZm9ybWFsUGFyYW1ldGVycyA9IHRoaXMucGFyc2VGb3JtYWxQYXJhbWV0ZXJzKCk7XHJcblx0ICAgICAgICBpZiAoZm9ybWFsUGFyYW1ldGVycy5wYXJhbXMubGVuZ3RoICE9PSAxKSB7XHJcblx0ICAgICAgICAgICAgdGhpcy50b2xlcmF0ZUVycm9yKG1lc3NhZ2VzXzEuTWVzc2FnZXMuQmFkU2V0dGVyQXJpdHkpO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgZWxzZSBpZiAoZm9ybWFsUGFyYW1ldGVycy5wYXJhbXNbMF0gaW5zdGFuY2VvZiBOb2RlLlJlc3RFbGVtZW50KSB7XHJcblx0ICAgICAgICAgICAgdGhpcy50b2xlcmF0ZUVycm9yKG1lc3NhZ2VzXzEuTWVzc2FnZXMuQmFkU2V0dGVyUmVzdFBhcmFtZXRlcik7XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICB2YXIgbWV0aG9kID0gdGhpcy5wYXJzZVByb3BlcnR5TWV0aG9kKGZvcm1hbFBhcmFtZXRlcnMpO1xyXG5cdCAgICAgICAgdGhpcy5jb250ZXh0LmFsbG93WWllbGQgPSBwcmV2aW91c0FsbG93WWllbGQ7XHJcblx0ICAgICAgICByZXR1cm4gdGhpcy5maW5hbGl6ZShub2RlLCBuZXcgTm9kZS5GdW5jdGlvbkV4cHJlc3Npb24obnVsbCwgZm9ybWFsUGFyYW1ldGVycy5wYXJhbXMsIG1ldGhvZCwgaXNHZW5lcmF0b3IpKTtcclxuXHQgICAgfTtcclxuXHQgICAgUGFyc2VyLnByb3RvdHlwZS5wYXJzZUdlbmVyYXRvck1ldGhvZCA9IGZ1bmN0aW9uICgpIHtcclxuXHQgICAgICAgIHZhciBub2RlID0gdGhpcy5jcmVhdGVOb2RlKCk7XHJcblx0ICAgICAgICB2YXIgaXNHZW5lcmF0b3IgPSB0cnVlO1xyXG5cdCAgICAgICAgdmFyIHByZXZpb3VzQWxsb3dZaWVsZCA9IHRoaXMuY29udGV4dC5hbGxvd1lpZWxkO1xyXG5cdCAgICAgICAgdGhpcy5jb250ZXh0LmFsbG93WWllbGQgPSB0cnVlO1xyXG5cdCAgICAgICAgdmFyIHBhcmFtcyA9IHRoaXMucGFyc2VGb3JtYWxQYXJhbWV0ZXJzKCk7XHJcblx0ICAgICAgICB0aGlzLmNvbnRleHQuYWxsb3dZaWVsZCA9IGZhbHNlO1xyXG5cdCAgICAgICAgdmFyIG1ldGhvZCA9IHRoaXMucGFyc2VQcm9wZXJ0eU1ldGhvZChwYXJhbXMpO1xyXG5cdCAgICAgICAgdGhpcy5jb250ZXh0LmFsbG93WWllbGQgPSBwcmV2aW91c0FsbG93WWllbGQ7XHJcblx0ICAgICAgICByZXR1cm4gdGhpcy5maW5hbGl6ZShub2RlLCBuZXcgTm9kZS5GdW5jdGlvbkV4cHJlc3Npb24obnVsbCwgcGFyYW1zLnBhcmFtcywgbWV0aG9kLCBpc0dlbmVyYXRvcikpO1xyXG5cdCAgICB9O1xyXG5cdCAgICAvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1nZW5lcmF0b3ItZnVuY3Rpb24tZGVmaW5pdGlvbnNcclxuXHQgICAgUGFyc2VyLnByb3RvdHlwZS5pc1N0YXJ0T2ZFeHByZXNzaW9uID0gZnVuY3Rpb24gKCkge1xyXG5cdCAgICAgICAgdmFyIHN0YXJ0ID0gdHJ1ZTtcclxuXHQgICAgICAgIHZhciB2YWx1ZSA9IHRoaXMubG9va2FoZWFkLnZhbHVlO1xyXG5cdCAgICAgICAgc3dpdGNoICh0aGlzLmxvb2thaGVhZC50eXBlKSB7XHJcblx0ICAgICAgICAgICAgY2FzZSA3IC8qIFB1bmN0dWF0b3IgKi86XHJcblx0ICAgICAgICAgICAgICAgIHN0YXJ0ID0gKHZhbHVlID09PSAnWycpIHx8ICh2YWx1ZSA9PT0gJygnKSB8fCAodmFsdWUgPT09ICd7JykgfHxcclxuXHQgICAgICAgICAgICAgICAgICAgICh2YWx1ZSA9PT0gJysnKSB8fCAodmFsdWUgPT09ICctJykgfHxcclxuXHQgICAgICAgICAgICAgICAgICAgICh2YWx1ZSA9PT0gJyEnKSB8fCAodmFsdWUgPT09ICd+JykgfHxcclxuXHQgICAgICAgICAgICAgICAgICAgICh2YWx1ZSA9PT0gJysrJykgfHwgKHZhbHVlID09PSAnLS0nKSB8fFxyXG5cdCAgICAgICAgICAgICAgICAgICAgKHZhbHVlID09PSAnLycpIHx8ICh2YWx1ZSA9PT0gJy89Jyk7IC8vIHJlZ3VsYXIgZXhwcmVzc2lvbiBsaXRlcmFsXHJcblx0ICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cdCAgICAgICAgICAgIGNhc2UgNCAvKiBLZXl3b3JkICovOlxyXG5cdCAgICAgICAgICAgICAgICBzdGFydCA9ICh2YWx1ZSA9PT0gJ2NsYXNzJykgfHwgKHZhbHVlID09PSAnZGVsZXRlJykgfHxcclxuXHQgICAgICAgICAgICAgICAgICAgICh2YWx1ZSA9PT0gJ2Z1bmN0aW9uJykgfHwgKHZhbHVlID09PSAnbGV0JykgfHwgKHZhbHVlID09PSAnbmV3JykgfHxcclxuXHQgICAgICAgICAgICAgICAgICAgICh2YWx1ZSA9PT0gJ3N1cGVyJykgfHwgKHZhbHVlID09PSAndGhpcycpIHx8ICh2YWx1ZSA9PT0gJ3R5cGVvZicpIHx8XHJcblx0ICAgICAgICAgICAgICAgICAgICAodmFsdWUgPT09ICd2b2lkJykgfHwgKHZhbHVlID09PSAneWllbGQnKTtcclxuXHQgICAgICAgICAgICAgICAgYnJlYWs7XHJcblx0ICAgICAgICAgICAgZGVmYXVsdDpcclxuXHQgICAgICAgICAgICAgICAgYnJlYWs7XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICByZXR1cm4gc3RhcnQ7XHJcblx0ICAgIH07XHJcblx0ICAgIFBhcnNlci5wcm90b3R5cGUucGFyc2VZaWVsZEV4cHJlc3Npb24gPSBmdW5jdGlvbiAoKSB7XHJcblx0ICAgICAgICB2YXIgbm9kZSA9IHRoaXMuY3JlYXRlTm9kZSgpO1xyXG5cdCAgICAgICAgdGhpcy5leHBlY3RLZXl3b3JkKCd5aWVsZCcpO1xyXG5cdCAgICAgICAgdmFyIGFyZ3VtZW50ID0gbnVsbDtcclxuXHQgICAgICAgIHZhciBkZWxlZ2F0ZSA9IGZhbHNlO1xyXG5cdCAgICAgICAgaWYgKCF0aGlzLmhhc0xpbmVUZXJtaW5hdG9yKSB7XHJcblx0ICAgICAgICAgICAgdmFyIHByZXZpb3VzQWxsb3dZaWVsZCA9IHRoaXMuY29udGV4dC5hbGxvd1lpZWxkO1xyXG5cdCAgICAgICAgICAgIHRoaXMuY29udGV4dC5hbGxvd1lpZWxkID0gZmFsc2U7XHJcblx0ICAgICAgICAgICAgZGVsZWdhdGUgPSB0aGlzLm1hdGNoKCcqJyk7XHJcblx0ICAgICAgICAgICAgaWYgKGRlbGVnYXRlKSB7XHJcblx0ICAgICAgICAgICAgICAgIHRoaXMubmV4dFRva2VuKCk7XHJcblx0ICAgICAgICAgICAgICAgIGFyZ3VtZW50ID0gdGhpcy5wYXJzZUFzc2lnbm1lbnRFeHByZXNzaW9uKCk7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMuaXNTdGFydE9mRXhwcmVzc2lvbigpKSB7XHJcblx0ICAgICAgICAgICAgICAgIGFyZ3VtZW50ID0gdGhpcy5wYXJzZUFzc2lnbm1lbnRFeHByZXNzaW9uKCk7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgIHRoaXMuY29udGV4dC5hbGxvd1lpZWxkID0gcHJldmlvdXNBbGxvd1lpZWxkO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgcmV0dXJuIHRoaXMuZmluYWxpemUobm9kZSwgbmV3IE5vZGUuWWllbGRFeHByZXNzaW9uKGFyZ3VtZW50LCBkZWxlZ2F0ZSkpO1xyXG5cdCAgICB9O1xyXG5cdCAgICAvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1jbGFzcy1kZWZpbml0aW9uc1xyXG5cdCAgICBQYXJzZXIucHJvdG90eXBlLnBhcnNlQ2xhc3NFbGVtZW50ID0gZnVuY3Rpb24gKGhhc0NvbnN0cnVjdG9yKSB7XHJcblx0ICAgICAgICB2YXIgdG9rZW4gPSB0aGlzLmxvb2thaGVhZDtcclxuXHQgICAgICAgIHZhciBub2RlID0gdGhpcy5jcmVhdGVOb2RlKCk7XHJcblx0ICAgICAgICB2YXIga2luZCA9ICcnO1xyXG5cdCAgICAgICAgdmFyIGtleSA9IG51bGw7XHJcblx0ICAgICAgICB2YXIgdmFsdWUgPSBudWxsO1xyXG5cdCAgICAgICAgdmFyIGNvbXB1dGVkID0gZmFsc2U7XHJcblx0ICAgICAgICB2YXIgbWV0aG9kID0gZmFsc2U7XHJcblx0ICAgICAgICB2YXIgaXNTdGF0aWMgPSBmYWxzZTtcclxuXHQgICAgICAgIHZhciBpc0FzeW5jID0gZmFsc2U7XHJcblx0ICAgICAgICBpZiAodGhpcy5tYXRjaCgnKicpKSB7XHJcblx0ICAgICAgICAgICAgdGhpcy5uZXh0VG9rZW4oKTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIGVsc2Uge1xyXG5cdCAgICAgICAgICAgIGNvbXB1dGVkID0gdGhpcy5tYXRjaCgnWycpO1xyXG5cdCAgICAgICAgICAgIGtleSA9IHRoaXMucGFyc2VPYmplY3RQcm9wZXJ0eUtleSgpO1xyXG5cdCAgICAgICAgICAgIHZhciBpZCA9IGtleTtcclxuXHQgICAgICAgICAgICBpZiAoaWQubmFtZSA9PT0gJ3N0YXRpYycgJiYgKHRoaXMucXVhbGlmaWVkUHJvcGVydHlOYW1lKHRoaXMubG9va2FoZWFkKSB8fCB0aGlzLm1hdGNoKCcqJykpKSB7XHJcblx0ICAgICAgICAgICAgICAgIHRva2VuID0gdGhpcy5sb29rYWhlYWQ7XHJcblx0ICAgICAgICAgICAgICAgIGlzU3RhdGljID0gdHJ1ZTtcclxuXHQgICAgICAgICAgICAgICAgY29tcHV0ZWQgPSB0aGlzLm1hdGNoKCdbJyk7XHJcblx0ICAgICAgICAgICAgICAgIGlmICh0aGlzLm1hdGNoKCcqJykpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgIHRoaXMubmV4dFRva2VuKCk7XHJcblx0ICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgZWxzZSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICBrZXkgPSB0aGlzLnBhcnNlT2JqZWN0UHJvcGVydHlLZXkoKTtcclxuXHQgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICBpZiAoKHRva2VuLnR5cGUgPT09IDMgLyogSWRlbnRpZmllciAqLykgJiYgIXRoaXMuaGFzTGluZVRlcm1pbmF0b3IgJiYgKHRva2VuLnZhbHVlID09PSAnYXN5bmMnKSkge1xyXG5cdCAgICAgICAgICAgICAgICB2YXIgcHVuY3R1YXRvciA9IHRoaXMubG9va2FoZWFkLnZhbHVlO1xyXG5cdCAgICAgICAgICAgICAgICBpZiAocHVuY3R1YXRvciAhPT0gJzonICYmIHB1bmN0dWF0b3IgIT09ICcoJyAmJiBwdW5jdHVhdG9yICE9PSAnKicpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgIGlzQXN5bmMgPSB0cnVlO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgdG9rZW4gPSB0aGlzLmxvb2thaGVhZDtcclxuXHQgICAgICAgICAgICAgICAgICAgIGtleSA9IHRoaXMucGFyc2VPYmplY3RQcm9wZXJ0eUtleSgpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKHRva2VuLnR5cGUgPT09IDMgLyogSWRlbnRpZmllciAqLykge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0b2tlbi52YWx1ZSA9PT0gJ2dldCcgfHwgdG9rZW4udmFsdWUgPT09ICdzZXQnKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMudG9sZXJhdGVVbmV4cGVjdGVkVG9rZW4odG9rZW4pO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICh0b2tlbi52YWx1ZSA9PT0gJ2NvbnN0cnVjdG9yJykge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnRvbGVyYXRlVW5leHBlY3RlZFRva2VuKHRva2VuLCBtZXNzYWdlc18xLk1lc3NhZ2VzLkNvbnN0cnVjdG9ySXNBc3luYyk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgdmFyIGxvb2thaGVhZFByb3BlcnR5S2V5ID0gdGhpcy5xdWFsaWZpZWRQcm9wZXJ0eU5hbWUodGhpcy5sb29rYWhlYWQpO1xyXG5cdCAgICAgICAgaWYgKHRva2VuLnR5cGUgPT09IDMgLyogSWRlbnRpZmllciAqLykge1xyXG5cdCAgICAgICAgICAgIGlmICh0b2tlbi52YWx1ZSA9PT0gJ2dldCcgJiYgbG9va2FoZWFkUHJvcGVydHlLZXkpIHtcclxuXHQgICAgICAgICAgICAgICAga2luZCA9ICdnZXQnO1xyXG5cdCAgICAgICAgICAgICAgICBjb21wdXRlZCA9IHRoaXMubWF0Y2goJ1snKTtcclxuXHQgICAgICAgICAgICAgICAga2V5ID0gdGhpcy5wYXJzZU9iamVjdFByb3BlcnR5S2V5KCk7XHJcblx0ICAgICAgICAgICAgICAgIHRoaXMuY29udGV4dC5hbGxvd1lpZWxkID0gZmFsc2U7XHJcblx0ICAgICAgICAgICAgICAgIHZhbHVlID0gdGhpcy5wYXJzZUdldHRlck1ldGhvZCgpO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICBlbHNlIGlmICh0b2tlbi52YWx1ZSA9PT0gJ3NldCcgJiYgbG9va2FoZWFkUHJvcGVydHlLZXkpIHtcclxuXHQgICAgICAgICAgICAgICAga2luZCA9ICdzZXQnO1xyXG5cdCAgICAgICAgICAgICAgICBjb21wdXRlZCA9IHRoaXMubWF0Y2goJ1snKTtcclxuXHQgICAgICAgICAgICAgICAga2V5ID0gdGhpcy5wYXJzZU9iamVjdFByb3BlcnR5S2V5KCk7XHJcblx0ICAgICAgICAgICAgICAgIHZhbHVlID0gdGhpcy5wYXJzZVNldHRlck1ldGhvZCgpO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIGVsc2UgaWYgKHRva2VuLnR5cGUgPT09IDcgLyogUHVuY3R1YXRvciAqLyAmJiB0b2tlbi52YWx1ZSA9PT0gJyonICYmIGxvb2thaGVhZFByb3BlcnR5S2V5KSB7XHJcblx0ICAgICAgICAgICAga2luZCA9ICdpbml0JztcclxuXHQgICAgICAgICAgICBjb21wdXRlZCA9IHRoaXMubWF0Y2goJ1snKTtcclxuXHQgICAgICAgICAgICBrZXkgPSB0aGlzLnBhcnNlT2JqZWN0UHJvcGVydHlLZXkoKTtcclxuXHQgICAgICAgICAgICB2YWx1ZSA9IHRoaXMucGFyc2VHZW5lcmF0b3JNZXRob2QoKTtcclxuXHQgICAgICAgICAgICBtZXRob2QgPSB0cnVlO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgaWYgKCFraW5kICYmIGtleSAmJiB0aGlzLm1hdGNoKCcoJykpIHtcclxuXHQgICAgICAgICAgICBraW5kID0gJ2luaXQnO1xyXG5cdCAgICAgICAgICAgIHZhbHVlID0gaXNBc3luYyA/IHRoaXMucGFyc2VQcm9wZXJ0eU1ldGhvZEFzeW5jRnVuY3Rpb24oKSA6IHRoaXMucGFyc2VQcm9wZXJ0eU1ldGhvZEZ1bmN0aW9uKCk7XHJcblx0ICAgICAgICAgICAgbWV0aG9kID0gdHJ1ZTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIGlmICgha2luZCkge1xyXG5cdCAgICAgICAgICAgIHRoaXMudGhyb3dVbmV4cGVjdGVkVG9rZW4odGhpcy5sb29rYWhlYWQpO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgaWYgKGtpbmQgPT09ICdpbml0Jykge1xyXG5cdCAgICAgICAgICAgIGtpbmQgPSAnbWV0aG9kJztcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIGlmICghY29tcHV0ZWQpIHtcclxuXHQgICAgICAgICAgICBpZiAoaXNTdGF0aWMgJiYgdGhpcy5pc1Byb3BlcnR5S2V5KGtleSwgJ3Byb3RvdHlwZScpKSB7XHJcblx0ICAgICAgICAgICAgICAgIHRoaXMudGhyb3dVbmV4cGVjdGVkVG9rZW4odG9rZW4sIG1lc3NhZ2VzXzEuTWVzc2FnZXMuU3RhdGljUHJvdG90eXBlKTtcclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgaWYgKCFpc1N0YXRpYyAmJiB0aGlzLmlzUHJvcGVydHlLZXkoa2V5LCAnY29uc3RydWN0b3InKSkge1xyXG5cdCAgICAgICAgICAgICAgICBpZiAoa2luZCAhPT0gJ21ldGhvZCcgfHwgIW1ldGhvZCB8fCAodmFsdWUgJiYgdmFsdWUuZ2VuZXJhdG9yKSkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgdGhpcy50aHJvd1VuZXhwZWN0ZWRUb2tlbih0b2tlbiwgbWVzc2FnZXNfMS5NZXNzYWdlcy5Db25zdHJ1Y3RvclNwZWNpYWxNZXRob2QpO1xyXG5cdCAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgIGlmIChoYXNDb25zdHJ1Y3Rvci52YWx1ZSkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgdGhpcy50aHJvd1VuZXhwZWN0ZWRUb2tlbih0b2tlbiwgbWVzc2FnZXNfMS5NZXNzYWdlcy5EdXBsaWNhdGVDb25zdHJ1Y3Rvcik7XHJcblx0ICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgZWxzZSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICBoYXNDb25zdHJ1Y3Rvci52YWx1ZSA9IHRydWU7XHJcblx0ICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAga2luZCA9ICdjb25zdHJ1Y3Rvcic7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgcmV0dXJuIHRoaXMuZmluYWxpemUobm9kZSwgbmV3IE5vZGUuTWV0aG9kRGVmaW5pdGlvbihrZXksIGNvbXB1dGVkLCB2YWx1ZSwga2luZCwgaXNTdGF0aWMpKTtcclxuXHQgICAgfTtcclxuXHQgICAgUGFyc2VyLnByb3RvdHlwZS5wYXJzZUNsYXNzRWxlbWVudExpc3QgPSBmdW5jdGlvbiAoKSB7XHJcblx0ICAgICAgICB2YXIgYm9keSA9IFtdO1xyXG5cdCAgICAgICAgdmFyIGhhc0NvbnN0cnVjdG9yID0geyB2YWx1ZTogZmFsc2UgfTtcclxuXHQgICAgICAgIHRoaXMuZXhwZWN0KCd7Jyk7XHJcblx0ICAgICAgICB3aGlsZSAoIXRoaXMubWF0Y2goJ30nKSkge1xyXG5cdCAgICAgICAgICAgIGlmICh0aGlzLm1hdGNoKCc7JykpIHtcclxuXHQgICAgICAgICAgICAgICAgdGhpcy5uZXh0VG9rZW4oKTtcclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgZWxzZSB7XHJcblx0ICAgICAgICAgICAgICAgIGJvZHkucHVzaCh0aGlzLnBhcnNlQ2xhc3NFbGVtZW50KGhhc0NvbnN0cnVjdG9yKSk7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgdGhpcy5leHBlY3QoJ30nKTtcclxuXHQgICAgICAgIHJldHVybiBib2R5O1xyXG5cdCAgICB9O1xyXG5cdCAgICBQYXJzZXIucHJvdG90eXBlLnBhcnNlQ2xhc3NCb2R5ID0gZnVuY3Rpb24gKCkge1xyXG5cdCAgICAgICAgdmFyIG5vZGUgPSB0aGlzLmNyZWF0ZU5vZGUoKTtcclxuXHQgICAgICAgIHZhciBlbGVtZW50TGlzdCA9IHRoaXMucGFyc2VDbGFzc0VsZW1lbnRMaXN0KCk7XHJcblx0ICAgICAgICByZXR1cm4gdGhpcy5maW5hbGl6ZShub2RlLCBuZXcgTm9kZS5DbGFzc0JvZHkoZWxlbWVudExpc3QpKTtcclxuXHQgICAgfTtcclxuXHQgICAgUGFyc2VyLnByb3RvdHlwZS5wYXJzZUNsYXNzRGVjbGFyYXRpb24gPSBmdW5jdGlvbiAoaWRlbnRpZmllcklzT3B0aW9uYWwpIHtcclxuXHQgICAgICAgIHZhciBub2RlID0gdGhpcy5jcmVhdGVOb2RlKCk7XHJcblx0ICAgICAgICB2YXIgcHJldmlvdXNTdHJpY3QgPSB0aGlzLmNvbnRleHQuc3RyaWN0O1xyXG5cdCAgICAgICAgdGhpcy5jb250ZXh0LnN0cmljdCA9IHRydWU7XHJcblx0ICAgICAgICB0aGlzLmV4cGVjdEtleXdvcmQoJ2NsYXNzJyk7XHJcblx0ICAgICAgICB2YXIgaWQgPSAoaWRlbnRpZmllcklzT3B0aW9uYWwgJiYgKHRoaXMubG9va2FoZWFkLnR5cGUgIT09IDMgLyogSWRlbnRpZmllciAqLykpID8gbnVsbCA6IHRoaXMucGFyc2VWYXJpYWJsZUlkZW50aWZpZXIoKTtcclxuXHQgICAgICAgIHZhciBzdXBlckNsYXNzID0gbnVsbDtcclxuXHQgICAgICAgIGlmICh0aGlzLm1hdGNoS2V5d29yZCgnZXh0ZW5kcycpKSB7XHJcblx0ICAgICAgICAgICAgdGhpcy5uZXh0VG9rZW4oKTtcclxuXHQgICAgICAgICAgICBzdXBlckNsYXNzID0gdGhpcy5pc29sYXRlQ292ZXJHcmFtbWFyKHRoaXMucGFyc2VMZWZ0SGFuZFNpZGVFeHByZXNzaW9uQWxsb3dDYWxsKTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIHZhciBjbGFzc0JvZHkgPSB0aGlzLnBhcnNlQ2xhc3NCb2R5KCk7XHJcblx0ICAgICAgICB0aGlzLmNvbnRleHQuc3RyaWN0ID0gcHJldmlvdXNTdHJpY3Q7XHJcblx0ICAgICAgICByZXR1cm4gdGhpcy5maW5hbGl6ZShub2RlLCBuZXcgTm9kZS5DbGFzc0RlY2xhcmF0aW9uKGlkLCBzdXBlckNsYXNzLCBjbGFzc0JvZHkpKTtcclxuXHQgICAgfTtcclxuXHQgICAgUGFyc2VyLnByb3RvdHlwZS5wYXJzZUNsYXNzRXhwcmVzc2lvbiA9IGZ1bmN0aW9uICgpIHtcclxuXHQgICAgICAgIHZhciBub2RlID0gdGhpcy5jcmVhdGVOb2RlKCk7XHJcblx0ICAgICAgICB2YXIgcHJldmlvdXNTdHJpY3QgPSB0aGlzLmNvbnRleHQuc3RyaWN0O1xyXG5cdCAgICAgICAgdGhpcy5jb250ZXh0LnN0cmljdCA9IHRydWU7XHJcblx0ICAgICAgICB0aGlzLmV4cGVjdEtleXdvcmQoJ2NsYXNzJyk7XHJcblx0ICAgICAgICB2YXIgaWQgPSAodGhpcy5sb29rYWhlYWQudHlwZSA9PT0gMyAvKiBJZGVudGlmaWVyICovKSA/IHRoaXMucGFyc2VWYXJpYWJsZUlkZW50aWZpZXIoKSA6IG51bGw7XHJcblx0ICAgICAgICB2YXIgc3VwZXJDbGFzcyA9IG51bGw7XHJcblx0ICAgICAgICBpZiAodGhpcy5tYXRjaEtleXdvcmQoJ2V4dGVuZHMnKSkge1xyXG5cdCAgICAgICAgICAgIHRoaXMubmV4dFRva2VuKCk7XHJcblx0ICAgICAgICAgICAgc3VwZXJDbGFzcyA9IHRoaXMuaXNvbGF0ZUNvdmVyR3JhbW1hcih0aGlzLnBhcnNlTGVmdEhhbmRTaWRlRXhwcmVzc2lvbkFsbG93Q2FsbCk7XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICB2YXIgY2xhc3NCb2R5ID0gdGhpcy5wYXJzZUNsYXNzQm9keSgpO1xyXG5cdCAgICAgICAgdGhpcy5jb250ZXh0LnN0cmljdCA9IHByZXZpb3VzU3RyaWN0O1xyXG5cdCAgICAgICAgcmV0dXJuIHRoaXMuZmluYWxpemUobm9kZSwgbmV3IE5vZGUuQ2xhc3NFeHByZXNzaW9uKGlkLCBzdXBlckNsYXNzLCBjbGFzc0JvZHkpKTtcclxuXHQgICAgfTtcclxuXHQgICAgLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtc2NyaXB0c1xyXG5cdCAgICAvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1tb2R1bGVzXHJcblx0ICAgIFBhcnNlci5wcm90b3R5cGUucGFyc2VNb2R1bGUgPSBmdW5jdGlvbiAoKSB7XHJcblx0ICAgICAgICB0aGlzLmNvbnRleHQuc3RyaWN0ID0gdHJ1ZTtcclxuXHQgICAgICAgIHRoaXMuY29udGV4dC5pc01vZHVsZSA9IHRydWU7XHJcblx0ICAgICAgICB2YXIgbm9kZSA9IHRoaXMuY3JlYXRlTm9kZSgpO1xyXG5cdCAgICAgICAgdmFyIGJvZHkgPSB0aGlzLnBhcnNlRGlyZWN0aXZlUHJvbG9ndWVzKCk7XHJcblx0ICAgICAgICB3aGlsZSAodGhpcy5sb29rYWhlYWQudHlwZSAhPT0gMiAvKiBFT0YgKi8pIHtcclxuXHQgICAgICAgICAgICBib2R5LnB1c2godGhpcy5wYXJzZVN0YXRlbWVudExpc3RJdGVtKCkpO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgcmV0dXJuIHRoaXMuZmluYWxpemUobm9kZSwgbmV3IE5vZGUuTW9kdWxlKGJvZHkpKTtcclxuXHQgICAgfTtcclxuXHQgICAgUGFyc2VyLnByb3RvdHlwZS5wYXJzZVNjcmlwdCA9IGZ1bmN0aW9uICgpIHtcclxuXHQgICAgICAgIHZhciBub2RlID0gdGhpcy5jcmVhdGVOb2RlKCk7XHJcblx0ICAgICAgICB2YXIgYm9keSA9IHRoaXMucGFyc2VEaXJlY3RpdmVQcm9sb2d1ZXMoKTtcclxuXHQgICAgICAgIHdoaWxlICh0aGlzLmxvb2thaGVhZC50eXBlICE9PSAyIC8qIEVPRiAqLykge1xyXG5cdCAgICAgICAgICAgIGJvZHkucHVzaCh0aGlzLnBhcnNlU3RhdGVtZW50TGlzdEl0ZW0oKSk7XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICByZXR1cm4gdGhpcy5maW5hbGl6ZShub2RlLCBuZXcgTm9kZS5TY3JpcHQoYm9keSkpO1xyXG5cdCAgICB9O1xyXG5cdCAgICAvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1pbXBvcnRzXHJcblx0ICAgIFBhcnNlci5wcm90b3R5cGUucGFyc2VNb2R1bGVTcGVjaWZpZXIgPSBmdW5jdGlvbiAoKSB7XHJcblx0ICAgICAgICB2YXIgbm9kZSA9IHRoaXMuY3JlYXRlTm9kZSgpO1xyXG5cdCAgICAgICAgaWYgKHRoaXMubG9va2FoZWFkLnR5cGUgIT09IDggLyogU3RyaW5nTGl0ZXJhbCAqLykge1xyXG5cdCAgICAgICAgICAgIHRoaXMudGhyb3dFcnJvcihtZXNzYWdlc18xLk1lc3NhZ2VzLkludmFsaWRNb2R1bGVTcGVjaWZpZXIpO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgdmFyIHRva2VuID0gdGhpcy5uZXh0VG9rZW4oKTtcclxuXHQgICAgICAgIHZhciByYXcgPSB0aGlzLmdldFRva2VuUmF3KHRva2VuKTtcclxuXHQgICAgICAgIHJldHVybiB0aGlzLmZpbmFsaXplKG5vZGUsIG5ldyBOb2RlLkxpdGVyYWwodG9rZW4udmFsdWUsIHJhdykpO1xyXG5cdCAgICB9O1xyXG5cdCAgICAvLyBpbXBvcnQgezxmb28gYXMgYmFyPn0gLi4uO1xyXG5cdCAgICBQYXJzZXIucHJvdG90eXBlLnBhcnNlSW1wb3J0U3BlY2lmaWVyID0gZnVuY3Rpb24gKCkge1xyXG5cdCAgICAgICAgdmFyIG5vZGUgPSB0aGlzLmNyZWF0ZU5vZGUoKTtcclxuXHQgICAgICAgIHZhciBpbXBvcnRlZDtcclxuXHQgICAgICAgIHZhciBsb2NhbDtcclxuXHQgICAgICAgIGlmICh0aGlzLmxvb2thaGVhZC50eXBlID09PSAzIC8qIElkZW50aWZpZXIgKi8pIHtcclxuXHQgICAgICAgICAgICBpbXBvcnRlZCA9IHRoaXMucGFyc2VWYXJpYWJsZUlkZW50aWZpZXIoKTtcclxuXHQgICAgICAgICAgICBsb2NhbCA9IGltcG9ydGVkO1xyXG5cdCAgICAgICAgICAgIGlmICh0aGlzLm1hdGNoQ29udGV4dHVhbEtleXdvcmQoJ2FzJykpIHtcclxuXHQgICAgICAgICAgICAgICAgdGhpcy5uZXh0VG9rZW4oKTtcclxuXHQgICAgICAgICAgICAgICAgbG9jYWwgPSB0aGlzLnBhcnNlVmFyaWFibGVJZGVudGlmaWVyKCk7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgZWxzZSB7XHJcblx0ICAgICAgICAgICAgaW1wb3J0ZWQgPSB0aGlzLnBhcnNlSWRlbnRpZmllck5hbWUoKTtcclxuXHQgICAgICAgICAgICBsb2NhbCA9IGltcG9ydGVkO1xyXG5cdCAgICAgICAgICAgIGlmICh0aGlzLm1hdGNoQ29udGV4dHVhbEtleXdvcmQoJ2FzJykpIHtcclxuXHQgICAgICAgICAgICAgICAgdGhpcy5uZXh0VG9rZW4oKTtcclxuXHQgICAgICAgICAgICAgICAgbG9jYWwgPSB0aGlzLnBhcnNlVmFyaWFibGVJZGVudGlmaWVyKCk7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgIGVsc2Uge1xyXG5cdCAgICAgICAgICAgICAgICB0aGlzLnRocm93VW5leHBlY3RlZFRva2VuKHRoaXMubmV4dFRva2VuKCkpO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIHJldHVybiB0aGlzLmZpbmFsaXplKG5vZGUsIG5ldyBOb2RlLkltcG9ydFNwZWNpZmllcihsb2NhbCwgaW1wb3J0ZWQpKTtcclxuXHQgICAgfTtcclxuXHQgICAgLy8ge2ZvbywgYmFyIGFzIGJhc31cclxuXHQgICAgUGFyc2VyLnByb3RvdHlwZS5wYXJzZU5hbWVkSW1wb3J0cyA9IGZ1bmN0aW9uICgpIHtcclxuXHQgICAgICAgIHRoaXMuZXhwZWN0KCd7Jyk7XHJcblx0ICAgICAgICB2YXIgc3BlY2lmaWVycyA9IFtdO1xyXG5cdCAgICAgICAgd2hpbGUgKCF0aGlzLm1hdGNoKCd9JykpIHtcclxuXHQgICAgICAgICAgICBzcGVjaWZpZXJzLnB1c2godGhpcy5wYXJzZUltcG9ydFNwZWNpZmllcigpKTtcclxuXHQgICAgICAgICAgICBpZiAoIXRoaXMubWF0Y2goJ30nKSkge1xyXG5cdCAgICAgICAgICAgICAgICB0aGlzLmV4cGVjdCgnLCcpO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIHRoaXMuZXhwZWN0KCd9Jyk7XHJcblx0ICAgICAgICByZXR1cm4gc3BlY2lmaWVycztcclxuXHQgICAgfTtcclxuXHQgICAgLy8gaW1wb3J0IDxmb28+IC4uLjtcclxuXHQgICAgUGFyc2VyLnByb3RvdHlwZS5wYXJzZUltcG9ydERlZmF1bHRTcGVjaWZpZXIgPSBmdW5jdGlvbiAoKSB7XHJcblx0ICAgICAgICB2YXIgbm9kZSA9IHRoaXMuY3JlYXRlTm9kZSgpO1xyXG5cdCAgICAgICAgdmFyIGxvY2FsID0gdGhpcy5wYXJzZUlkZW50aWZpZXJOYW1lKCk7XHJcblx0ICAgICAgICByZXR1cm4gdGhpcy5maW5hbGl6ZShub2RlLCBuZXcgTm9kZS5JbXBvcnREZWZhdWx0U3BlY2lmaWVyKGxvY2FsKSk7XHJcblx0ICAgIH07XHJcblx0ICAgIC8vIGltcG9ydCA8KiBhcyBmb28+IC4uLjtcclxuXHQgICAgUGFyc2VyLnByb3RvdHlwZS5wYXJzZUltcG9ydE5hbWVzcGFjZVNwZWNpZmllciA9IGZ1bmN0aW9uICgpIHtcclxuXHQgICAgICAgIHZhciBub2RlID0gdGhpcy5jcmVhdGVOb2RlKCk7XHJcblx0ICAgICAgICB0aGlzLmV4cGVjdCgnKicpO1xyXG5cdCAgICAgICAgaWYgKCF0aGlzLm1hdGNoQ29udGV4dHVhbEtleXdvcmQoJ2FzJykpIHtcclxuXHQgICAgICAgICAgICB0aGlzLnRocm93RXJyb3IobWVzc2FnZXNfMS5NZXNzYWdlcy5Ob0FzQWZ0ZXJJbXBvcnROYW1lc3BhY2UpO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgdGhpcy5uZXh0VG9rZW4oKTtcclxuXHQgICAgICAgIHZhciBsb2NhbCA9IHRoaXMucGFyc2VJZGVudGlmaWVyTmFtZSgpO1xyXG5cdCAgICAgICAgcmV0dXJuIHRoaXMuZmluYWxpemUobm9kZSwgbmV3IE5vZGUuSW1wb3J0TmFtZXNwYWNlU3BlY2lmaWVyKGxvY2FsKSk7XHJcblx0ICAgIH07XHJcblx0ICAgIFBhcnNlci5wcm90b3R5cGUucGFyc2VJbXBvcnREZWNsYXJhdGlvbiA9IGZ1bmN0aW9uICgpIHtcclxuXHQgICAgICAgIGlmICh0aGlzLmNvbnRleHQuaW5GdW5jdGlvbkJvZHkpIHtcclxuXHQgICAgICAgICAgICB0aGlzLnRocm93RXJyb3IobWVzc2FnZXNfMS5NZXNzYWdlcy5JbGxlZ2FsSW1wb3J0RGVjbGFyYXRpb24pO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgdmFyIG5vZGUgPSB0aGlzLmNyZWF0ZU5vZGUoKTtcclxuXHQgICAgICAgIHRoaXMuZXhwZWN0S2V5d29yZCgnaW1wb3J0Jyk7XHJcblx0ICAgICAgICB2YXIgc3JjO1xyXG5cdCAgICAgICAgdmFyIHNwZWNpZmllcnMgPSBbXTtcclxuXHQgICAgICAgIGlmICh0aGlzLmxvb2thaGVhZC50eXBlID09PSA4IC8qIFN0cmluZ0xpdGVyYWwgKi8pIHtcclxuXHQgICAgICAgICAgICAvLyBpbXBvcnQgJ2Zvbyc7XHJcblx0ICAgICAgICAgICAgc3JjID0gdGhpcy5wYXJzZU1vZHVsZVNwZWNpZmllcigpO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgZWxzZSB7XHJcblx0ICAgICAgICAgICAgaWYgKHRoaXMubWF0Y2goJ3snKSkge1xyXG5cdCAgICAgICAgICAgICAgICAvLyBpbXBvcnQge2Jhcn1cclxuXHQgICAgICAgICAgICAgICAgc3BlY2lmaWVycyA9IHNwZWNpZmllcnMuY29uY2F0KHRoaXMucGFyc2VOYW1lZEltcG9ydHMoKSk7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMubWF0Y2goJyonKSkge1xyXG5cdCAgICAgICAgICAgICAgICAvLyBpbXBvcnQgKiBhcyBmb29cclxuXHQgICAgICAgICAgICAgICAgc3BlY2lmaWVycy5wdXNoKHRoaXMucGFyc2VJbXBvcnROYW1lc3BhY2VTcGVjaWZpZXIoKSk7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMuaXNJZGVudGlmaWVyTmFtZSh0aGlzLmxvb2thaGVhZCkgJiYgIXRoaXMubWF0Y2hLZXl3b3JkKCdkZWZhdWx0JykpIHtcclxuXHQgICAgICAgICAgICAgICAgLy8gaW1wb3J0IGZvb1xyXG5cdCAgICAgICAgICAgICAgICBzcGVjaWZpZXJzLnB1c2godGhpcy5wYXJzZUltcG9ydERlZmF1bHRTcGVjaWZpZXIoKSk7XHJcblx0ICAgICAgICAgICAgICAgIGlmICh0aGlzLm1hdGNoKCcsJykpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgIHRoaXMubmV4dFRva2VuKCk7XHJcblx0ICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5tYXRjaCgnKicpKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgLy8gaW1wb3J0IGZvbywgKiBhcyBmb29cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBzcGVjaWZpZXJzLnB1c2godGhpcy5wYXJzZUltcG9ydE5hbWVzcGFjZVNwZWNpZmllcigpKTtcclxuXHQgICAgICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMubWF0Y2goJ3snKSkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIC8vIGltcG9ydCBmb28sIHtiYXJ9XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgc3BlY2lmaWVycyA9IHNwZWNpZmllcnMuY29uY2F0KHRoaXMucGFyc2VOYW1lZEltcG9ydHMoKSk7XHJcblx0ICAgICAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnRocm93VW5leHBlY3RlZFRva2VuKHRoaXMubG9va2FoZWFkKTtcclxuXHQgICAgICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICBlbHNlIHtcclxuXHQgICAgICAgICAgICAgICAgdGhpcy50aHJvd1VuZXhwZWN0ZWRUb2tlbih0aGlzLm5leHRUb2tlbigpKTtcclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgaWYgKCF0aGlzLm1hdGNoQ29udGV4dHVhbEtleXdvcmQoJ2Zyb20nKSkge1xyXG5cdCAgICAgICAgICAgICAgICB2YXIgbWVzc2FnZSA9IHRoaXMubG9va2FoZWFkLnZhbHVlID8gbWVzc2FnZXNfMS5NZXNzYWdlcy5VbmV4cGVjdGVkVG9rZW4gOiBtZXNzYWdlc18xLk1lc3NhZ2VzLk1pc3NpbmdGcm9tQ2xhdXNlO1xyXG5cdCAgICAgICAgICAgICAgICB0aGlzLnRocm93RXJyb3IobWVzc2FnZSwgdGhpcy5sb29rYWhlYWQudmFsdWUpO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICB0aGlzLm5leHRUb2tlbigpO1xyXG5cdCAgICAgICAgICAgIHNyYyA9IHRoaXMucGFyc2VNb2R1bGVTcGVjaWZpZXIoKTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIHRoaXMuY29uc3VtZVNlbWljb2xvbigpO1xyXG5cdCAgICAgICAgcmV0dXJuIHRoaXMuZmluYWxpemUobm9kZSwgbmV3IE5vZGUuSW1wb3J0RGVjbGFyYXRpb24oc3BlY2lmaWVycywgc3JjKSk7XHJcblx0ICAgIH07XHJcblx0ICAgIC8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLWV4cG9ydHNcclxuXHQgICAgUGFyc2VyLnByb3RvdHlwZS5wYXJzZUV4cG9ydFNwZWNpZmllciA9IGZ1bmN0aW9uICgpIHtcclxuXHQgICAgICAgIHZhciBub2RlID0gdGhpcy5jcmVhdGVOb2RlKCk7XHJcblx0ICAgICAgICB2YXIgbG9jYWwgPSB0aGlzLnBhcnNlSWRlbnRpZmllck5hbWUoKTtcclxuXHQgICAgICAgIHZhciBleHBvcnRlZCA9IGxvY2FsO1xyXG5cdCAgICAgICAgaWYgKHRoaXMubWF0Y2hDb250ZXh0dWFsS2V5d29yZCgnYXMnKSkge1xyXG5cdCAgICAgICAgICAgIHRoaXMubmV4dFRva2VuKCk7XHJcblx0ICAgICAgICAgICAgZXhwb3J0ZWQgPSB0aGlzLnBhcnNlSWRlbnRpZmllck5hbWUoKTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIHJldHVybiB0aGlzLmZpbmFsaXplKG5vZGUsIG5ldyBOb2RlLkV4cG9ydFNwZWNpZmllcihsb2NhbCwgZXhwb3J0ZWQpKTtcclxuXHQgICAgfTtcclxuXHQgICAgUGFyc2VyLnByb3RvdHlwZS5wYXJzZUV4cG9ydERlY2xhcmF0aW9uID0gZnVuY3Rpb24gKCkge1xyXG5cdCAgICAgICAgaWYgKHRoaXMuY29udGV4dC5pbkZ1bmN0aW9uQm9keSkge1xyXG5cdCAgICAgICAgICAgIHRoaXMudGhyb3dFcnJvcihtZXNzYWdlc18xLk1lc3NhZ2VzLklsbGVnYWxFeHBvcnREZWNsYXJhdGlvbik7XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICB2YXIgbm9kZSA9IHRoaXMuY3JlYXRlTm9kZSgpO1xyXG5cdCAgICAgICAgdGhpcy5leHBlY3RLZXl3b3JkKCdleHBvcnQnKTtcclxuXHQgICAgICAgIHZhciBleHBvcnREZWNsYXJhdGlvbjtcclxuXHQgICAgICAgIGlmICh0aGlzLm1hdGNoS2V5d29yZCgnZGVmYXVsdCcpKSB7XHJcblx0ICAgICAgICAgICAgLy8gZXhwb3J0IGRlZmF1bHQgLi4uXHJcblx0ICAgICAgICAgICAgdGhpcy5uZXh0VG9rZW4oKTtcclxuXHQgICAgICAgICAgICBpZiAodGhpcy5tYXRjaEtleXdvcmQoJ2Z1bmN0aW9uJykpIHtcclxuXHQgICAgICAgICAgICAgICAgLy8gZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZm9vICgpIHt9XHJcblx0ICAgICAgICAgICAgICAgIC8vIGV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uICgpIHt9XHJcblx0ICAgICAgICAgICAgICAgIHZhciBkZWNsYXJhdGlvbiA9IHRoaXMucGFyc2VGdW5jdGlvbkRlY2xhcmF0aW9uKHRydWUpO1xyXG5cdCAgICAgICAgICAgICAgICBleHBvcnREZWNsYXJhdGlvbiA9IHRoaXMuZmluYWxpemUobm9kZSwgbmV3IE5vZGUuRXhwb3J0RGVmYXVsdERlY2xhcmF0aW9uKGRlY2xhcmF0aW9uKSk7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMubWF0Y2hLZXl3b3JkKCdjbGFzcycpKSB7XHJcblx0ICAgICAgICAgICAgICAgIC8vIGV4cG9ydCBkZWZhdWx0IGNsYXNzIGZvbyB7fVxyXG5cdCAgICAgICAgICAgICAgICB2YXIgZGVjbGFyYXRpb24gPSB0aGlzLnBhcnNlQ2xhc3NEZWNsYXJhdGlvbih0cnVlKTtcclxuXHQgICAgICAgICAgICAgICAgZXhwb3J0RGVjbGFyYXRpb24gPSB0aGlzLmZpbmFsaXplKG5vZGUsIG5ldyBOb2RlLkV4cG9ydERlZmF1bHREZWNsYXJhdGlvbihkZWNsYXJhdGlvbikpO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICBlbHNlIGlmICh0aGlzLm1hdGNoQ29udGV4dHVhbEtleXdvcmQoJ2FzeW5jJykpIHtcclxuXHQgICAgICAgICAgICAgICAgLy8gZXhwb3J0IGRlZmF1bHQgYXN5bmMgZnVuY3Rpb24gZiAoKSB7fVxyXG5cdCAgICAgICAgICAgICAgICAvLyBleHBvcnQgZGVmYXVsdCBhc3luYyBmdW5jdGlvbiAoKSB7fVxyXG5cdCAgICAgICAgICAgICAgICAvLyBleHBvcnQgZGVmYXVsdCBhc3luYyB4ID0+IHhcclxuXHQgICAgICAgICAgICAgICAgdmFyIGRlY2xhcmF0aW9uID0gdGhpcy5tYXRjaEFzeW5jRnVuY3Rpb24oKSA/IHRoaXMucGFyc2VGdW5jdGlvbkRlY2xhcmF0aW9uKHRydWUpIDogdGhpcy5wYXJzZUFzc2lnbm1lbnRFeHByZXNzaW9uKCk7XHJcblx0ICAgICAgICAgICAgICAgIGV4cG9ydERlY2xhcmF0aW9uID0gdGhpcy5maW5hbGl6ZShub2RlLCBuZXcgTm9kZS5FeHBvcnREZWZhdWx0RGVjbGFyYXRpb24oZGVjbGFyYXRpb24pKTtcclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgZWxzZSB7XHJcblx0ICAgICAgICAgICAgICAgIGlmICh0aGlzLm1hdGNoQ29udGV4dHVhbEtleXdvcmQoJ2Zyb20nKSkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgdGhpcy50aHJvd0Vycm9yKG1lc3NhZ2VzXzEuTWVzc2FnZXMuVW5leHBlY3RlZFRva2VuLCB0aGlzLmxvb2thaGVhZC52YWx1ZSk7XHJcblx0ICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgLy8gZXhwb3J0IGRlZmF1bHQge307XHJcblx0ICAgICAgICAgICAgICAgIC8vIGV4cG9ydCBkZWZhdWx0IFtdO1xyXG5cdCAgICAgICAgICAgICAgICAvLyBleHBvcnQgZGVmYXVsdCAoMSArIDIpO1xyXG5cdCAgICAgICAgICAgICAgICB2YXIgZGVjbGFyYXRpb24gPSB0aGlzLm1hdGNoKCd7JykgPyB0aGlzLnBhcnNlT2JqZWN0SW5pdGlhbGl6ZXIoKSA6XHJcblx0ICAgICAgICAgICAgICAgICAgICB0aGlzLm1hdGNoKCdbJykgPyB0aGlzLnBhcnNlQXJyYXlJbml0aWFsaXplcigpIDogdGhpcy5wYXJzZUFzc2lnbm1lbnRFeHByZXNzaW9uKCk7XHJcblx0ICAgICAgICAgICAgICAgIHRoaXMuY29uc3VtZVNlbWljb2xvbigpO1xyXG5cdCAgICAgICAgICAgICAgICBleHBvcnREZWNsYXJhdGlvbiA9IHRoaXMuZmluYWxpemUobm9kZSwgbmV3IE5vZGUuRXhwb3J0RGVmYXVsdERlY2xhcmF0aW9uKGRlY2xhcmF0aW9uKSk7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgZWxzZSBpZiAodGhpcy5tYXRjaCgnKicpKSB7XHJcblx0ICAgICAgICAgICAgLy8gZXhwb3J0ICogZnJvbSAnZm9vJztcclxuXHQgICAgICAgICAgICB0aGlzLm5leHRUb2tlbigpO1xyXG5cdCAgICAgICAgICAgIGlmICghdGhpcy5tYXRjaENvbnRleHR1YWxLZXl3b3JkKCdmcm9tJykpIHtcclxuXHQgICAgICAgICAgICAgICAgdmFyIG1lc3NhZ2UgPSB0aGlzLmxvb2thaGVhZC52YWx1ZSA/IG1lc3NhZ2VzXzEuTWVzc2FnZXMuVW5leHBlY3RlZFRva2VuIDogbWVzc2FnZXNfMS5NZXNzYWdlcy5NaXNzaW5nRnJvbUNsYXVzZTtcclxuXHQgICAgICAgICAgICAgICAgdGhpcy50aHJvd0Vycm9yKG1lc3NhZ2UsIHRoaXMubG9va2FoZWFkLnZhbHVlKTtcclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgdGhpcy5uZXh0VG9rZW4oKTtcclxuXHQgICAgICAgICAgICB2YXIgc3JjID0gdGhpcy5wYXJzZU1vZHVsZVNwZWNpZmllcigpO1xyXG5cdCAgICAgICAgICAgIHRoaXMuY29uc3VtZVNlbWljb2xvbigpO1xyXG5cdCAgICAgICAgICAgIGV4cG9ydERlY2xhcmF0aW9uID0gdGhpcy5maW5hbGl6ZShub2RlLCBuZXcgTm9kZS5FeHBvcnRBbGxEZWNsYXJhdGlvbihzcmMpKTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIGVsc2UgaWYgKHRoaXMubG9va2FoZWFkLnR5cGUgPT09IDQgLyogS2V5d29yZCAqLykge1xyXG5cdCAgICAgICAgICAgIC8vIGV4cG9ydCB2YXIgZiA9IDE7XHJcblx0ICAgICAgICAgICAgdmFyIGRlY2xhcmF0aW9uID0gdm9pZCAwO1xyXG5cdCAgICAgICAgICAgIHN3aXRjaCAodGhpcy5sb29rYWhlYWQudmFsdWUpIHtcclxuXHQgICAgICAgICAgICAgICAgY2FzZSAnbGV0JzpcclxuXHQgICAgICAgICAgICAgICAgY2FzZSAnY29uc3QnOlxyXG5cdCAgICAgICAgICAgICAgICAgICAgZGVjbGFyYXRpb24gPSB0aGlzLnBhcnNlTGV4aWNhbERlY2xhcmF0aW9uKHsgaW5Gb3I6IGZhbHNlIH0pO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcblx0ICAgICAgICAgICAgICAgIGNhc2UgJ3Zhcic6XHJcblx0ICAgICAgICAgICAgICAgIGNhc2UgJ2NsYXNzJzpcclxuXHQgICAgICAgICAgICAgICAgY2FzZSAnZnVuY3Rpb24nOlxyXG5cdCAgICAgICAgICAgICAgICAgICAgZGVjbGFyYXRpb24gPSB0aGlzLnBhcnNlU3RhdGVtZW50TGlzdEl0ZW0oKTtcclxuXHQgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cdCAgICAgICAgICAgICAgICBkZWZhdWx0OlxyXG5cdCAgICAgICAgICAgICAgICAgICAgdGhpcy50aHJvd1VuZXhwZWN0ZWRUb2tlbih0aGlzLmxvb2thaGVhZCk7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgIGV4cG9ydERlY2xhcmF0aW9uID0gdGhpcy5maW5hbGl6ZShub2RlLCBuZXcgTm9kZS5FeHBvcnROYW1lZERlY2xhcmF0aW9uKGRlY2xhcmF0aW9uLCBbXSwgbnVsbCkpO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgZWxzZSBpZiAodGhpcy5tYXRjaEFzeW5jRnVuY3Rpb24oKSkge1xyXG5cdCAgICAgICAgICAgIHZhciBkZWNsYXJhdGlvbiA9IHRoaXMucGFyc2VGdW5jdGlvbkRlY2xhcmF0aW9uKCk7XHJcblx0ICAgICAgICAgICAgZXhwb3J0RGVjbGFyYXRpb24gPSB0aGlzLmZpbmFsaXplKG5vZGUsIG5ldyBOb2RlLkV4cG9ydE5hbWVkRGVjbGFyYXRpb24oZGVjbGFyYXRpb24sIFtdLCBudWxsKSk7XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICBlbHNlIHtcclxuXHQgICAgICAgICAgICB2YXIgc3BlY2lmaWVycyA9IFtdO1xyXG5cdCAgICAgICAgICAgIHZhciBzb3VyY2UgPSBudWxsO1xyXG5cdCAgICAgICAgICAgIHZhciBpc0V4cG9ydEZyb21JZGVudGlmaWVyID0gZmFsc2U7XHJcblx0ICAgICAgICAgICAgdGhpcy5leHBlY3QoJ3snKTtcclxuXHQgICAgICAgICAgICB3aGlsZSAoIXRoaXMubWF0Y2goJ30nKSkge1xyXG5cdCAgICAgICAgICAgICAgICBpc0V4cG9ydEZyb21JZGVudGlmaWVyID0gaXNFeHBvcnRGcm9tSWRlbnRpZmllciB8fCB0aGlzLm1hdGNoS2V5d29yZCgnZGVmYXVsdCcpO1xyXG5cdCAgICAgICAgICAgICAgICBzcGVjaWZpZXJzLnB1c2godGhpcy5wYXJzZUV4cG9ydFNwZWNpZmllcigpKTtcclxuXHQgICAgICAgICAgICAgICAgaWYgKCF0aGlzLm1hdGNoKCd9JykpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgIHRoaXMuZXhwZWN0KCcsJyk7XHJcblx0ICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgdGhpcy5leHBlY3QoJ30nKTtcclxuXHQgICAgICAgICAgICBpZiAodGhpcy5tYXRjaENvbnRleHR1YWxLZXl3b3JkKCdmcm9tJykpIHtcclxuXHQgICAgICAgICAgICAgICAgLy8gZXhwb3J0IHtkZWZhdWx0fSBmcm9tICdmb28nO1xyXG5cdCAgICAgICAgICAgICAgICAvLyBleHBvcnQge2Zvb30gZnJvbSAnZm9vJztcclxuXHQgICAgICAgICAgICAgICAgdGhpcy5uZXh0VG9rZW4oKTtcclxuXHQgICAgICAgICAgICAgICAgc291cmNlID0gdGhpcy5wYXJzZU1vZHVsZVNwZWNpZmllcigpO1xyXG5cdCAgICAgICAgICAgICAgICB0aGlzLmNvbnN1bWVTZW1pY29sb24oKTtcclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgZWxzZSBpZiAoaXNFeHBvcnRGcm9tSWRlbnRpZmllcikge1xyXG5cdCAgICAgICAgICAgICAgICAvLyBleHBvcnQge2RlZmF1bHR9OyAvLyBtaXNzaW5nIGZyb21DbGF1c2VcclxuXHQgICAgICAgICAgICAgICAgdmFyIG1lc3NhZ2UgPSB0aGlzLmxvb2thaGVhZC52YWx1ZSA/IG1lc3NhZ2VzXzEuTWVzc2FnZXMuVW5leHBlY3RlZFRva2VuIDogbWVzc2FnZXNfMS5NZXNzYWdlcy5NaXNzaW5nRnJvbUNsYXVzZTtcclxuXHQgICAgICAgICAgICAgICAgdGhpcy50aHJvd0Vycm9yKG1lc3NhZ2UsIHRoaXMubG9va2FoZWFkLnZhbHVlKTtcclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgZWxzZSB7XHJcblx0ICAgICAgICAgICAgICAgIC8vIGV4cG9ydCB7Zm9vfTtcclxuXHQgICAgICAgICAgICAgICAgdGhpcy5jb25zdW1lU2VtaWNvbG9uKCk7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgIGV4cG9ydERlY2xhcmF0aW9uID0gdGhpcy5maW5hbGl6ZShub2RlLCBuZXcgTm9kZS5FeHBvcnROYW1lZERlY2xhcmF0aW9uKG51bGwsIHNwZWNpZmllcnMsIHNvdXJjZSkpO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgcmV0dXJuIGV4cG9ydERlY2xhcmF0aW9uO1xyXG5cdCAgICB9O1xyXG5cdCAgICByZXR1cm4gUGFyc2VyO1xyXG5cdH0oKSk7XHJcblx0ZXhwb3J0cy5QYXJzZXIgPSBQYXJzZXI7XHJcblxuXG4vKioqLyB9LFxuLyogOSAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cblx0XCJ1c2Ugc3RyaWN0XCI7XHJcblx0Ly8gRW5zdXJlIHRoZSBjb25kaXRpb24gaXMgdHJ1ZSwgb3RoZXJ3aXNlIHRocm93IGFuIGVycm9yLlxyXG5cdC8vIFRoaXMgaXMgb25seSB0byBoYXZlIGEgYmV0dGVyIGNvbnRyYWN0IHNlbWFudGljLCBpLmUuIGFub3RoZXIgc2FmZXR5IG5ldFxyXG5cdC8vIHRvIGNhdGNoIGEgbG9naWMgZXJyb3IuIFRoZSBjb25kaXRpb24gc2hhbGwgYmUgZnVsZmlsbGVkIGluIG5vcm1hbCBjYXNlLlxyXG5cdC8vIERvIE5PVCB1c2UgdGhpcyB0byBlbmZvcmNlIGEgY2VydGFpbiBjb25kaXRpb24gb24gYW55IHVzZXIgaW5wdXQuXHJcblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG5cdGZ1bmN0aW9uIGFzc2VydChjb25kaXRpb24sIG1lc3NhZ2UpIHtcclxuXHQgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXHJcblx0ICAgIGlmICghY29uZGl0aW9uKSB7XHJcblx0ICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0FTU0VSVDogJyArIG1lc3NhZ2UpO1xyXG5cdCAgICB9XHJcblx0fVxyXG5cdGV4cG9ydHMuYXNzZXJ0ID0gYXNzZXJ0O1xyXG5cblxuLyoqKi8gfSxcbi8qIDEwICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxuXHRcInVzZSBzdHJpY3RcIjtcclxuXHQvKiB0c2xpbnQ6ZGlzYWJsZTptYXgtY2xhc3Nlcy1wZXItZmlsZSAqL1xyXG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuXHR2YXIgRXJyb3JIYW5kbGVyID0gKGZ1bmN0aW9uICgpIHtcclxuXHQgICAgZnVuY3Rpb24gRXJyb3JIYW5kbGVyKCkge1xyXG5cdCAgICAgICAgdGhpcy5lcnJvcnMgPSBbXTtcclxuXHQgICAgICAgIHRoaXMudG9sZXJhbnQgPSBmYWxzZTtcclxuXHQgICAgfVxyXG5cdCAgICBFcnJvckhhbmRsZXIucHJvdG90eXBlLnJlY29yZEVycm9yID0gZnVuY3Rpb24gKGVycm9yKSB7XHJcblx0ICAgICAgICB0aGlzLmVycm9ycy5wdXNoKGVycm9yKTtcclxuXHQgICAgfTtcclxuXHQgICAgRXJyb3JIYW5kbGVyLnByb3RvdHlwZS50b2xlcmF0ZSA9IGZ1bmN0aW9uIChlcnJvcikge1xyXG5cdCAgICAgICAgaWYgKHRoaXMudG9sZXJhbnQpIHtcclxuXHQgICAgICAgICAgICB0aGlzLnJlY29yZEVycm9yKGVycm9yKTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIGVsc2Uge1xyXG5cdCAgICAgICAgICAgIHRocm93IGVycm9yO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICB9O1xyXG5cdCAgICBFcnJvckhhbmRsZXIucHJvdG90eXBlLmNvbnN0cnVjdEVycm9yID0gZnVuY3Rpb24gKG1zZywgY29sdW1uKSB7XHJcblx0ICAgICAgICB2YXIgZXJyb3IgPSBuZXcgRXJyb3IobXNnKTtcclxuXHQgICAgICAgIHRyeSB7XHJcblx0ICAgICAgICAgICAgdGhyb3cgZXJyb3I7XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICBjYXRjaCAoYmFzZSkge1xyXG5cdCAgICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXHJcblx0ICAgICAgICAgICAgaWYgKE9iamVjdC5jcmVhdGUgJiYgT2JqZWN0LmRlZmluZVByb3BlcnR5KSB7XHJcblx0ICAgICAgICAgICAgICAgIGVycm9yID0gT2JqZWN0LmNyZWF0ZShiYXNlKTtcclxuXHQgICAgICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGVycm9yLCAnY29sdW1uJywgeyB2YWx1ZTogY29sdW1uIH0pO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXHJcblx0ICAgICAgICByZXR1cm4gZXJyb3I7XHJcblx0ICAgIH07XHJcblx0ICAgIEVycm9ySGFuZGxlci5wcm90b3R5cGUuY3JlYXRlRXJyb3IgPSBmdW5jdGlvbiAoaW5kZXgsIGxpbmUsIGNvbCwgZGVzY3JpcHRpb24pIHtcclxuXHQgICAgICAgIHZhciBtc2cgPSAnTGluZSAnICsgbGluZSArICc6ICcgKyBkZXNjcmlwdGlvbjtcclxuXHQgICAgICAgIHZhciBlcnJvciA9IHRoaXMuY29uc3RydWN0RXJyb3IobXNnLCBjb2wpO1xyXG5cdCAgICAgICAgZXJyb3IuaW5kZXggPSBpbmRleDtcclxuXHQgICAgICAgIGVycm9yLmxpbmVOdW1iZXIgPSBsaW5lO1xyXG5cdCAgICAgICAgZXJyb3IuZGVzY3JpcHRpb24gPSBkZXNjcmlwdGlvbjtcclxuXHQgICAgICAgIHJldHVybiBlcnJvcjtcclxuXHQgICAgfTtcclxuXHQgICAgRXJyb3JIYW5kbGVyLnByb3RvdHlwZS50aHJvd0Vycm9yID0gZnVuY3Rpb24gKGluZGV4LCBsaW5lLCBjb2wsIGRlc2NyaXB0aW9uKSB7XHJcblx0ICAgICAgICB0aHJvdyB0aGlzLmNyZWF0ZUVycm9yKGluZGV4LCBsaW5lLCBjb2wsIGRlc2NyaXB0aW9uKTtcclxuXHQgICAgfTtcclxuXHQgICAgRXJyb3JIYW5kbGVyLnByb3RvdHlwZS50b2xlcmF0ZUVycm9yID0gZnVuY3Rpb24gKGluZGV4LCBsaW5lLCBjb2wsIGRlc2NyaXB0aW9uKSB7XHJcblx0ICAgICAgICB2YXIgZXJyb3IgPSB0aGlzLmNyZWF0ZUVycm9yKGluZGV4LCBsaW5lLCBjb2wsIGRlc2NyaXB0aW9uKTtcclxuXHQgICAgICAgIGlmICh0aGlzLnRvbGVyYW50KSB7XHJcblx0ICAgICAgICAgICAgdGhpcy5yZWNvcmRFcnJvcihlcnJvcik7XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICBlbHNlIHtcclxuXHQgICAgICAgICAgICB0aHJvdyBlcnJvcjtcclxuXHQgICAgICAgIH1cclxuXHQgICAgfTtcclxuXHQgICAgcmV0dXJuIEVycm9ySGFuZGxlcjtcclxuXHR9KCkpO1xyXG5cdGV4cG9ydHMuRXJyb3JIYW5kbGVyID0gRXJyb3JIYW5kbGVyO1xyXG5cblxuLyoqKi8gfSxcbi8qIDExICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxuXHRcInVzZSBzdHJpY3RcIjtcclxuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcblx0Ly8gRXJyb3IgbWVzc2FnZXMgc2hvdWxkIGJlIGlkZW50aWNhbCB0byBWOC5cclxuXHRleHBvcnRzLk1lc3NhZ2VzID0ge1xyXG5cdCAgICBCYWRHZXR0ZXJBcml0eTogJ0dldHRlciBtdXN0IG5vdCBoYXZlIGFueSBmb3JtYWwgcGFyYW1ldGVycycsXHJcblx0ICAgIEJhZFNldHRlckFyaXR5OiAnU2V0dGVyIG11c3QgaGF2ZSBleGFjdGx5IG9uZSBmb3JtYWwgcGFyYW1ldGVyJyxcclxuXHQgICAgQmFkU2V0dGVyUmVzdFBhcmFtZXRlcjogJ1NldHRlciBmdW5jdGlvbiBhcmd1bWVudCBtdXN0IG5vdCBiZSBhIHJlc3QgcGFyYW1ldGVyJyxcclxuXHQgICAgQ29uc3RydWN0b3JJc0FzeW5jOiAnQ2xhc3MgY29uc3RydWN0b3IgbWF5IG5vdCBiZSBhbiBhc3luYyBtZXRob2QnLFxyXG5cdCAgICBDb25zdHJ1Y3RvclNwZWNpYWxNZXRob2Q6ICdDbGFzcyBjb25zdHJ1Y3RvciBtYXkgbm90IGJlIGFuIGFjY2Vzc29yJyxcclxuXHQgICAgRGVjbGFyYXRpb25NaXNzaW5nSW5pdGlhbGl6ZXI6ICdNaXNzaW5nIGluaXRpYWxpemVyIGluICUwIGRlY2xhcmF0aW9uJyxcclxuXHQgICAgRGVmYXVsdFJlc3RQYXJhbWV0ZXI6ICdVbmV4cGVjdGVkIHRva2VuID0nLFxyXG5cdCAgICBEdXBsaWNhdGVCaW5kaW5nOiAnRHVwbGljYXRlIGJpbmRpbmcgJTAnLFxyXG5cdCAgICBEdXBsaWNhdGVDb25zdHJ1Y3RvcjogJ0EgY2xhc3MgbWF5IG9ubHkgaGF2ZSBvbmUgY29uc3RydWN0b3InLFxyXG5cdCAgICBEdXBsaWNhdGVQcm90b1Byb3BlcnR5OiAnRHVwbGljYXRlIF9fcHJvdG9fXyBmaWVsZHMgYXJlIG5vdCBhbGxvd2VkIGluIG9iamVjdCBsaXRlcmFscycsXHJcblx0ICAgIEZvckluT2ZMb29wSW5pdGlhbGl6ZXI6ICclMCBsb29wIHZhcmlhYmxlIGRlY2xhcmF0aW9uIG1heSBub3QgaGF2ZSBhbiBpbml0aWFsaXplcicsXHJcblx0ICAgIEdlbmVyYXRvckluTGVnYWN5Q29udGV4dDogJ0dlbmVyYXRvciBkZWNsYXJhdGlvbnMgYXJlIG5vdCBhbGxvd2VkIGluIGxlZ2FjeSBjb250ZXh0cycsXHJcblx0ICAgIElsbGVnYWxCcmVhazogJ0lsbGVnYWwgYnJlYWsgc3RhdGVtZW50JyxcclxuXHQgICAgSWxsZWdhbENvbnRpbnVlOiAnSWxsZWdhbCBjb250aW51ZSBzdGF0ZW1lbnQnLFxyXG5cdCAgICBJbGxlZ2FsRXhwb3J0RGVjbGFyYXRpb246ICdVbmV4cGVjdGVkIHRva2VuJyxcclxuXHQgICAgSWxsZWdhbEltcG9ydERlY2xhcmF0aW9uOiAnVW5leHBlY3RlZCB0b2tlbicsXHJcblx0ICAgIElsbGVnYWxMYW5ndWFnZU1vZGVEaXJlY3RpdmU6ICdJbGxlZ2FsIFxcJ3VzZSBzdHJpY3RcXCcgZGlyZWN0aXZlIGluIGZ1bmN0aW9uIHdpdGggbm9uLXNpbXBsZSBwYXJhbWV0ZXIgbGlzdCcsXHJcblx0ICAgIElsbGVnYWxSZXR1cm46ICdJbGxlZ2FsIHJldHVybiBzdGF0ZW1lbnQnLFxyXG5cdCAgICBJbnZhbGlkRXNjYXBlZFJlc2VydmVkV29yZDogJ0tleXdvcmQgbXVzdCBub3QgY29udGFpbiBlc2NhcGVkIGNoYXJhY3RlcnMnLFxyXG5cdCAgICBJbnZhbGlkSGV4RXNjYXBlU2VxdWVuY2U6ICdJbnZhbGlkIGhleGFkZWNpbWFsIGVzY2FwZSBzZXF1ZW5jZScsXHJcblx0ICAgIEludmFsaWRMSFNJbkFzc2lnbm1lbnQ6ICdJbnZhbGlkIGxlZnQtaGFuZCBzaWRlIGluIGFzc2lnbm1lbnQnLFxyXG5cdCAgICBJbnZhbGlkTEhTSW5Gb3JJbjogJ0ludmFsaWQgbGVmdC1oYW5kIHNpZGUgaW4gZm9yLWluJyxcclxuXHQgICAgSW52YWxpZExIU0luRm9yTG9vcDogJ0ludmFsaWQgbGVmdC1oYW5kIHNpZGUgaW4gZm9yLWxvb3AnLFxyXG5cdCAgICBJbnZhbGlkTW9kdWxlU3BlY2lmaWVyOiAnVW5leHBlY3RlZCB0b2tlbicsXHJcblx0ICAgIEludmFsaWRSZWdFeHA6ICdJbnZhbGlkIHJlZ3VsYXIgZXhwcmVzc2lvbicsXHJcblx0ICAgIExldEluTGV4aWNhbEJpbmRpbmc6ICdsZXQgaXMgZGlzYWxsb3dlZCBhcyBhIGxleGljYWxseSBib3VuZCBuYW1lJyxcclxuXHQgICAgTWlzc2luZ0Zyb21DbGF1c2U6ICdVbmV4cGVjdGVkIHRva2VuJyxcclxuXHQgICAgTXVsdGlwbGVEZWZhdWx0c0luU3dpdGNoOiAnTW9yZSB0aGFuIG9uZSBkZWZhdWx0IGNsYXVzZSBpbiBzd2l0Y2ggc3RhdGVtZW50JyxcclxuXHQgICAgTmV3bGluZUFmdGVyVGhyb3c6ICdJbGxlZ2FsIG5ld2xpbmUgYWZ0ZXIgdGhyb3cnLFxyXG5cdCAgICBOb0FzQWZ0ZXJJbXBvcnROYW1lc3BhY2U6ICdVbmV4cGVjdGVkIHRva2VuJyxcclxuXHQgICAgTm9DYXRjaE9yRmluYWxseTogJ01pc3NpbmcgY2F0Y2ggb3IgZmluYWxseSBhZnRlciB0cnknLFxyXG5cdCAgICBQYXJhbWV0ZXJBZnRlclJlc3RQYXJhbWV0ZXI6ICdSZXN0IHBhcmFtZXRlciBtdXN0IGJlIGxhc3QgZm9ybWFsIHBhcmFtZXRlcicsXHJcblx0ICAgIFJlZGVjbGFyYXRpb246ICclMCBcXCclMVxcJyBoYXMgYWxyZWFkeSBiZWVuIGRlY2xhcmVkJyxcclxuXHQgICAgU3RhdGljUHJvdG90eXBlOiAnQ2xhc3NlcyBtYXkgbm90IGhhdmUgc3RhdGljIHByb3BlcnR5IG5hbWVkIHByb3RvdHlwZScsXHJcblx0ICAgIFN0cmljdENhdGNoVmFyaWFibGU6ICdDYXRjaCB2YXJpYWJsZSBtYXkgbm90IGJlIGV2YWwgb3IgYXJndW1lbnRzIGluIHN0cmljdCBtb2RlJyxcclxuXHQgICAgU3RyaWN0RGVsZXRlOiAnRGVsZXRlIG9mIGFuIHVucXVhbGlmaWVkIGlkZW50aWZpZXIgaW4gc3RyaWN0IG1vZGUuJyxcclxuXHQgICAgU3RyaWN0RnVuY3Rpb246ICdJbiBzdHJpY3QgbW9kZSBjb2RlLCBmdW5jdGlvbnMgY2FuIG9ubHkgYmUgZGVjbGFyZWQgYXQgdG9wIGxldmVsIG9yIGluc2lkZSBhIGJsb2NrJyxcclxuXHQgICAgU3RyaWN0RnVuY3Rpb25OYW1lOiAnRnVuY3Rpb24gbmFtZSBtYXkgbm90IGJlIGV2YWwgb3IgYXJndW1lbnRzIGluIHN0cmljdCBtb2RlJyxcclxuXHQgICAgU3RyaWN0TEhTQXNzaWdubWVudDogJ0Fzc2lnbm1lbnQgdG8gZXZhbCBvciBhcmd1bWVudHMgaXMgbm90IGFsbG93ZWQgaW4gc3RyaWN0IG1vZGUnLFxyXG5cdCAgICBTdHJpY3RMSFNQb3N0Zml4OiAnUG9zdGZpeCBpbmNyZW1lbnQvZGVjcmVtZW50IG1heSBub3QgaGF2ZSBldmFsIG9yIGFyZ3VtZW50cyBvcGVyYW5kIGluIHN0cmljdCBtb2RlJyxcclxuXHQgICAgU3RyaWN0TEhTUHJlZml4OiAnUHJlZml4IGluY3JlbWVudC9kZWNyZW1lbnQgbWF5IG5vdCBoYXZlIGV2YWwgb3IgYXJndW1lbnRzIG9wZXJhbmQgaW4gc3RyaWN0IG1vZGUnLFxyXG5cdCAgICBTdHJpY3RNb2RlV2l0aDogJ1N0cmljdCBtb2RlIGNvZGUgbWF5IG5vdCBpbmNsdWRlIGEgd2l0aCBzdGF0ZW1lbnQnLFxyXG5cdCAgICBTdHJpY3RPY3RhbExpdGVyYWw6ICdPY3RhbCBsaXRlcmFscyBhcmUgbm90IGFsbG93ZWQgaW4gc3RyaWN0IG1vZGUuJyxcclxuXHQgICAgU3RyaWN0UGFyYW1EdXBlOiAnU3RyaWN0IG1vZGUgZnVuY3Rpb24gbWF5IG5vdCBoYXZlIGR1cGxpY2F0ZSBwYXJhbWV0ZXIgbmFtZXMnLFxyXG5cdCAgICBTdHJpY3RQYXJhbU5hbWU6ICdQYXJhbWV0ZXIgbmFtZSBldmFsIG9yIGFyZ3VtZW50cyBpcyBub3QgYWxsb3dlZCBpbiBzdHJpY3QgbW9kZScsXHJcblx0ICAgIFN0cmljdFJlc2VydmVkV29yZDogJ1VzZSBvZiBmdXR1cmUgcmVzZXJ2ZWQgd29yZCBpbiBzdHJpY3QgbW9kZScsXHJcblx0ICAgIFN0cmljdFZhck5hbWU6ICdWYXJpYWJsZSBuYW1lIG1heSBub3QgYmUgZXZhbCBvciBhcmd1bWVudHMgaW4gc3RyaWN0IG1vZGUnLFxyXG5cdCAgICBUZW1wbGF0ZU9jdGFsTGl0ZXJhbDogJ09jdGFsIGxpdGVyYWxzIGFyZSBub3QgYWxsb3dlZCBpbiB0ZW1wbGF0ZSBzdHJpbmdzLicsXHJcblx0ICAgIFVuZXhwZWN0ZWRFT1M6ICdVbmV4cGVjdGVkIGVuZCBvZiBpbnB1dCcsXHJcblx0ICAgIFVuZXhwZWN0ZWRJZGVudGlmaWVyOiAnVW5leHBlY3RlZCBpZGVudGlmaWVyJyxcclxuXHQgICAgVW5leHBlY3RlZE51bWJlcjogJ1VuZXhwZWN0ZWQgbnVtYmVyJyxcclxuXHQgICAgVW5leHBlY3RlZFJlc2VydmVkOiAnVW5leHBlY3RlZCByZXNlcnZlZCB3b3JkJyxcclxuXHQgICAgVW5leHBlY3RlZFN0cmluZzogJ1VuZXhwZWN0ZWQgc3RyaW5nJyxcclxuXHQgICAgVW5leHBlY3RlZFRlbXBsYXRlOiAnVW5leHBlY3RlZCBxdWFzaSAlMCcsXHJcblx0ICAgIFVuZXhwZWN0ZWRUb2tlbjogJ1VuZXhwZWN0ZWQgdG9rZW4gJTAnLFxyXG5cdCAgICBVbmV4cGVjdGVkVG9rZW5JbGxlZ2FsOiAnVW5leHBlY3RlZCB0b2tlbiBJTExFR0FMJyxcclxuXHQgICAgVW5rbm93bkxhYmVsOiAnVW5kZWZpbmVkIGxhYmVsIFxcJyUwXFwnJyxcclxuXHQgICAgVW50ZXJtaW5hdGVkUmVnRXhwOiAnSW52YWxpZCByZWd1bGFyIGV4cHJlc3Npb246IG1pc3NpbmcgLydcclxuXHR9O1xyXG5cblxuLyoqKi8gfSxcbi8qIDEyICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXHRcInVzZSBzdHJpY3RcIjtcclxuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcblx0dmFyIGFzc2VydF8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg5KTtcclxuXHR2YXIgY2hhcmFjdGVyXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQpO1xyXG5cdHZhciBtZXNzYWdlc18xID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMSk7XHJcblx0ZnVuY3Rpb24gaGV4VmFsdWUoY2gpIHtcclxuXHQgICAgcmV0dXJuICcwMTIzNDU2Nzg5YWJjZGVmJy5pbmRleE9mKGNoLnRvTG93ZXJDYXNlKCkpO1xyXG5cdH1cclxuXHRmdW5jdGlvbiBvY3RhbFZhbHVlKGNoKSB7XHJcblx0ICAgIHJldHVybiAnMDEyMzQ1NjcnLmluZGV4T2YoY2gpO1xyXG5cdH1cclxuXHR2YXIgU2Nhbm5lciA9IChmdW5jdGlvbiAoKSB7XHJcblx0ICAgIGZ1bmN0aW9uIFNjYW5uZXIoY29kZSwgaGFuZGxlcikge1xyXG5cdCAgICAgICAgdGhpcy5zb3VyY2UgPSBjb2RlO1xyXG5cdCAgICAgICAgdGhpcy5lcnJvckhhbmRsZXIgPSBoYW5kbGVyO1xyXG5cdCAgICAgICAgdGhpcy50cmFja0NvbW1lbnQgPSBmYWxzZTtcclxuXHQgICAgICAgIHRoaXMubGVuZ3RoID0gY29kZS5sZW5ndGg7XHJcblx0ICAgICAgICB0aGlzLmluZGV4ID0gMDtcclxuXHQgICAgICAgIHRoaXMubGluZU51bWJlciA9IChjb2RlLmxlbmd0aCA+IDApID8gMSA6IDA7XHJcblx0ICAgICAgICB0aGlzLmxpbmVTdGFydCA9IDA7XHJcblx0ICAgICAgICB0aGlzLmN1cmx5U3RhY2sgPSBbXTtcclxuXHQgICAgfVxyXG5cdCAgICBTY2FubmVyLnByb3RvdHlwZS5zYXZlU3RhdGUgPSBmdW5jdGlvbiAoKSB7XHJcblx0ICAgICAgICByZXR1cm4ge1xyXG5cdCAgICAgICAgICAgIGluZGV4OiB0aGlzLmluZGV4LFxyXG5cdCAgICAgICAgICAgIGxpbmVOdW1iZXI6IHRoaXMubGluZU51bWJlcixcclxuXHQgICAgICAgICAgICBsaW5lU3RhcnQ6IHRoaXMubGluZVN0YXJ0XHJcblx0ICAgICAgICB9O1xyXG5cdCAgICB9O1xyXG5cdCAgICBTY2FubmVyLnByb3RvdHlwZS5yZXN0b3JlU3RhdGUgPSBmdW5jdGlvbiAoc3RhdGUpIHtcclxuXHQgICAgICAgIHRoaXMuaW5kZXggPSBzdGF0ZS5pbmRleDtcclxuXHQgICAgICAgIHRoaXMubGluZU51bWJlciA9IHN0YXRlLmxpbmVOdW1iZXI7XHJcblx0ICAgICAgICB0aGlzLmxpbmVTdGFydCA9IHN0YXRlLmxpbmVTdGFydDtcclxuXHQgICAgfTtcclxuXHQgICAgU2Nhbm5lci5wcm90b3R5cGUuZW9mID0gZnVuY3Rpb24gKCkge1xyXG5cdCAgICAgICAgcmV0dXJuIHRoaXMuaW5kZXggPj0gdGhpcy5sZW5ndGg7XHJcblx0ICAgIH07XHJcblx0ICAgIFNjYW5uZXIucHJvdG90eXBlLnRocm93VW5leHBlY3RlZFRva2VuID0gZnVuY3Rpb24gKG1lc3NhZ2UpIHtcclxuXHQgICAgICAgIGlmIChtZXNzYWdlID09PSB2b2lkIDApIHsgbWVzc2FnZSA9IG1lc3NhZ2VzXzEuTWVzc2FnZXMuVW5leHBlY3RlZFRva2VuSWxsZWdhbDsgfVxyXG5cdCAgICAgICAgcmV0dXJuIHRoaXMuZXJyb3JIYW5kbGVyLnRocm93RXJyb3IodGhpcy5pbmRleCwgdGhpcy5saW5lTnVtYmVyLCB0aGlzLmluZGV4IC0gdGhpcy5saW5lU3RhcnQgKyAxLCBtZXNzYWdlKTtcclxuXHQgICAgfTtcclxuXHQgICAgU2Nhbm5lci5wcm90b3R5cGUudG9sZXJhdGVVbmV4cGVjdGVkVG9rZW4gPSBmdW5jdGlvbiAobWVzc2FnZSkge1xyXG5cdCAgICAgICAgaWYgKG1lc3NhZ2UgPT09IHZvaWQgMCkgeyBtZXNzYWdlID0gbWVzc2FnZXNfMS5NZXNzYWdlcy5VbmV4cGVjdGVkVG9rZW5JbGxlZ2FsOyB9XHJcblx0ICAgICAgICB0aGlzLmVycm9ySGFuZGxlci50b2xlcmF0ZUVycm9yKHRoaXMuaW5kZXgsIHRoaXMubGluZU51bWJlciwgdGhpcy5pbmRleCAtIHRoaXMubGluZVN0YXJ0ICsgMSwgbWVzc2FnZSk7XHJcblx0ICAgIH07XHJcblx0ICAgIC8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLWNvbW1lbnRzXHJcblx0ICAgIFNjYW5uZXIucHJvdG90eXBlLnNraXBTaW5nbGVMaW5lQ29tbWVudCA9IGZ1bmN0aW9uIChvZmZzZXQpIHtcclxuXHQgICAgICAgIHZhciBjb21tZW50cyA9IFtdO1xyXG5cdCAgICAgICAgdmFyIHN0YXJ0LCBsb2M7XHJcblx0ICAgICAgICBpZiAodGhpcy50cmFja0NvbW1lbnQpIHtcclxuXHQgICAgICAgICAgICBjb21tZW50cyA9IFtdO1xyXG5cdCAgICAgICAgICAgIHN0YXJ0ID0gdGhpcy5pbmRleCAtIG9mZnNldDtcclxuXHQgICAgICAgICAgICBsb2MgPSB7XHJcblx0ICAgICAgICAgICAgICAgIHN0YXJ0OiB7XHJcblx0ICAgICAgICAgICAgICAgICAgICBsaW5lOiB0aGlzLmxpbmVOdW1iZXIsXHJcblx0ICAgICAgICAgICAgICAgICAgICBjb2x1bW46IHRoaXMuaW5kZXggLSB0aGlzLmxpbmVTdGFydCAtIG9mZnNldFxyXG5cdCAgICAgICAgICAgICAgICB9LFxyXG5cdCAgICAgICAgICAgICAgICBlbmQ6IHt9XHJcblx0ICAgICAgICAgICAgfTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIHdoaWxlICghdGhpcy5lb2YoKSkge1xyXG5cdCAgICAgICAgICAgIHZhciBjaCA9IHRoaXMuc291cmNlLmNoYXJDb2RlQXQodGhpcy5pbmRleCk7XHJcblx0ICAgICAgICAgICAgKyt0aGlzLmluZGV4O1xyXG5cdCAgICAgICAgICAgIGlmIChjaGFyYWN0ZXJfMS5DaGFyYWN0ZXIuaXNMaW5lVGVybWluYXRvcihjaCkpIHtcclxuXHQgICAgICAgICAgICAgICAgaWYgKHRoaXMudHJhY2tDb21tZW50KSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICBsb2MuZW5kID0ge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGxpbmU6IHRoaXMubGluZU51bWJlcixcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBjb2x1bW46IHRoaXMuaW5kZXggLSB0aGlzLmxpbmVTdGFydCAtIDFcclxuXHQgICAgICAgICAgICAgICAgICAgIH07XHJcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgZW50cnkgPSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgbXVsdGlMaW5lOiBmYWxzZSxcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBzbGljZTogW3N0YXJ0ICsgb2Zmc2V0LCB0aGlzLmluZGV4IC0gMV0sXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcmFuZ2U6IFtzdGFydCwgdGhpcy5pbmRleCAtIDFdLFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGxvYzogbG9jXHJcblx0ICAgICAgICAgICAgICAgICAgICB9O1xyXG5cdCAgICAgICAgICAgICAgICAgICAgY29tbWVudHMucHVzaChlbnRyeSk7XHJcblx0ICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgaWYgKGNoID09PSAxMyAmJiB0aGlzLnNvdXJjZS5jaGFyQ29kZUF0KHRoaXMuaW5kZXgpID09PSAxMCkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgKyt0aGlzLmluZGV4O1xyXG5cdCAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgICsrdGhpcy5saW5lTnVtYmVyO1xyXG5cdCAgICAgICAgICAgICAgICB0aGlzLmxpbmVTdGFydCA9IHRoaXMuaW5kZXg7XHJcblx0ICAgICAgICAgICAgICAgIHJldHVybiBjb21tZW50cztcclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICBpZiAodGhpcy50cmFja0NvbW1lbnQpIHtcclxuXHQgICAgICAgICAgICBsb2MuZW5kID0ge1xyXG5cdCAgICAgICAgICAgICAgICBsaW5lOiB0aGlzLmxpbmVOdW1iZXIsXHJcblx0ICAgICAgICAgICAgICAgIGNvbHVtbjogdGhpcy5pbmRleCAtIHRoaXMubGluZVN0YXJ0XHJcblx0ICAgICAgICAgICAgfTtcclxuXHQgICAgICAgICAgICB2YXIgZW50cnkgPSB7XHJcblx0ICAgICAgICAgICAgICAgIG11bHRpTGluZTogZmFsc2UsXHJcblx0ICAgICAgICAgICAgICAgIHNsaWNlOiBbc3RhcnQgKyBvZmZzZXQsIHRoaXMuaW5kZXhdLFxyXG5cdCAgICAgICAgICAgICAgICByYW5nZTogW3N0YXJ0LCB0aGlzLmluZGV4XSxcclxuXHQgICAgICAgICAgICAgICAgbG9jOiBsb2NcclxuXHQgICAgICAgICAgICB9O1xyXG5cdCAgICAgICAgICAgIGNvbW1lbnRzLnB1c2goZW50cnkpO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgcmV0dXJuIGNvbW1lbnRzO1xyXG5cdCAgICB9O1xyXG5cdCAgICBTY2FubmVyLnByb3RvdHlwZS5za2lwTXVsdGlMaW5lQ29tbWVudCA9IGZ1bmN0aW9uICgpIHtcclxuXHQgICAgICAgIHZhciBjb21tZW50cyA9IFtdO1xyXG5cdCAgICAgICAgdmFyIHN0YXJ0LCBsb2M7XHJcblx0ICAgICAgICBpZiAodGhpcy50cmFja0NvbW1lbnQpIHtcclxuXHQgICAgICAgICAgICBjb21tZW50cyA9IFtdO1xyXG5cdCAgICAgICAgICAgIHN0YXJ0ID0gdGhpcy5pbmRleCAtIDI7XHJcblx0ICAgICAgICAgICAgbG9jID0ge1xyXG5cdCAgICAgICAgICAgICAgICBzdGFydDoge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgbGluZTogdGhpcy5saW5lTnVtYmVyLFxyXG5cdCAgICAgICAgICAgICAgICAgICAgY29sdW1uOiB0aGlzLmluZGV4IC0gdGhpcy5saW5lU3RhcnQgLSAyXHJcblx0ICAgICAgICAgICAgICAgIH0sXHJcblx0ICAgICAgICAgICAgICAgIGVuZDoge31cclxuXHQgICAgICAgICAgICB9O1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgd2hpbGUgKCF0aGlzLmVvZigpKSB7XHJcblx0ICAgICAgICAgICAgdmFyIGNoID0gdGhpcy5zb3VyY2UuY2hhckNvZGVBdCh0aGlzLmluZGV4KTtcclxuXHQgICAgICAgICAgICBpZiAoY2hhcmFjdGVyXzEuQ2hhcmFjdGVyLmlzTGluZVRlcm1pbmF0b3IoY2gpKSB7XHJcblx0ICAgICAgICAgICAgICAgIGlmIChjaCA9PT0gMHgwRCAmJiB0aGlzLnNvdXJjZS5jaGFyQ29kZUF0KHRoaXMuaW5kZXggKyAxKSA9PT0gMHgwQSkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgKyt0aGlzLmluZGV4O1xyXG5cdCAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgICsrdGhpcy5saW5lTnVtYmVyO1xyXG5cdCAgICAgICAgICAgICAgICArK3RoaXMuaW5kZXg7XHJcblx0ICAgICAgICAgICAgICAgIHRoaXMubGluZVN0YXJ0ID0gdGhpcy5pbmRleDtcclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgZWxzZSBpZiAoY2ggPT09IDB4MkEpIHtcclxuXHQgICAgICAgICAgICAgICAgLy8gQmxvY2sgY29tbWVudCBlbmRzIHdpdGggJyovJy5cclxuXHQgICAgICAgICAgICAgICAgaWYgKHRoaXMuc291cmNlLmNoYXJDb2RlQXQodGhpcy5pbmRleCArIDEpID09PSAweDJGKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICB0aGlzLmluZGV4ICs9IDI7XHJcblx0ICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy50cmFja0NvbW1lbnQpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBsb2MuZW5kID0ge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBsaW5lOiB0aGlzLmxpbmVOdW1iZXIsXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbHVtbjogdGhpcy5pbmRleCAtIHRoaXMubGluZVN0YXJ0XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZW50cnkgPSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIG11bHRpTGluZTogdHJ1ZSxcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2xpY2U6IFtzdGFydCArIDIsIHRoaXMuaW5kZXggLSAyXSxcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmFuZ2U6IFtzdGFydCwgdGhpcy5pbmRleF0sXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxvYzogbG9jXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBjb21tZW50cy5wdXNoKGVudHJ5KTtcclxuXHQgICAgICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgICAgIHJldHVybiBjb21tZW50cztcclxuXHQgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICArK3RoaXMuaW5kZXg7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgIGVsc2Uge1xyXG5cdCAgICAgICAgICAgICAgICArK3RoaXMuaW5kZXg7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgLy8gUmFuIG9mZiB0aGUgZW5kIG9mIHRoZSBmaWxlIC0gdGhlIHdob2xlIHRoaW5nIGlzIGEgY29tbWVudFxyXG5cdCAgICAgICAgaWYgKHRoaXMudHJhY2tDb21tZW50KSB7XHJcblx0ICAgICAgICAgICAgbG9jLmVuZCA9IHtcclxuXHQgICAgICAgICAgICAgICAgbGluZTogdGhpcy5saW5lTnVtYmVyLFxyXG5cdCAgICAgICAgICAgICAgICBjb2x1bW46IHRoaXMuaW5kZXggLSB0aGlzLmxpbmVTdGFydFxyXG5cdCAgICAgICAgICAgIH07XHJcblx0ICAgICAgICAgICAgdmFyIGVudHJ5ID0ge1xyXG5cdCAgICAgICAgICAgICAgICBtdWx0aUxpbmU6IHRydWUsXHJcblx0ICAgICAgICAgICAgICAgIHNsaWNlOiBbc3RhcnQgKyAyLCB0aGlzLmluZGV4XSxcclxuXHQgICAgICAgICAgICAgICAgcmFuZ2U6IFtzdGFydCwgdGhpcy5pbmRleF0sXHJcblx0ICAgICAgICAgICAgICAgIGxvYzogbG9jXHJcblx0ICAgICAgICAgICAgfTtcclxuXHQgICAgICAgICAgICBjb21tZW50cy5wdXNoKGVudHJ5KTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIHRoaXMudG9sZXJhdGVVbmV4cGVjdGVkVG9rZW4oKTtcclxuXHQgICAgICAgIHJldHVybiBjb21tZW50cztcclxuXHQgICAgfTtcclxuXHQgICAgU2Nhbm5lci5wcm90b3R5cGUuc2NhbkNvbW1lbnRzID0gZnVuY3Rpb24gKCkge1xyXG5cdCAgICAgICAgdmFyIGNvbW1lbnRzO1xyXG5cdCAgICAgICAgaWYgKHRoaXMudHJhY2tDb21tZW50KSB7XHJcblx0ICAgICAgICAgICAgY29tbWVudHMgPSBbXTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIHZhciBzdGFydCA9ICh0aGlzLmluZGV4ID09PSAwKTtcclxuXHQgICAgICAgIHdoaWxlICghdGhpcy5lb2YoKSkge1xyXG5cdCAgICAgICAgICAgIHZhciBjaCA9IHRoaXMuc291cmNlLmNoYXJDb2RlQXQodGhpcy5pbmRleCk7XHJcblx0ICAgICAgICAgICAgaWYgKGNoYXJhY3Rlcl8xLkNoYXJhY3Rlci5pc1doaXRlU3BhY2UoY2gpKSB7XHJcblx0ICAgICAgICAgICAgICAgICsrdGhpcy5pbmRleDtcclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgZWxzZSBpZiAoY2hhcmFjdGVyXzEuQ2hhcmFjdGVyLmlzTGluZVRlcm1pbmF0b3IoY2gpKSB7XHJcblx0ICAgICAgICAgICAgICAgICsrdGhpcy5pbmRleDtcclxuXHQgICAgICAgICAgICAgICAgaWYgKGNoID09PSAweDBEICYmIHRoaXMuc291cmNlLmNoYXJDb2RlQXQodGhpcy5pbmRleCkgPT09IDB4MEEpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICsrdGhpcy5pbmRleDtcclxuXHQgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICArK3RoaXMubGluZU51bWJlcjtcclxuXHQgICAgICAgICAgICAgICAgdGhpcy5saW5lU3RhcnQgPSB0aGlzLmluZGV4O1xyXG5cdCAgICAgICAgICAgICAgICBzdGFydCA9IHRydWU7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgIGVsc2UgaWYgKGNoID09PSAweDJGKSB7XHJcblx0ICAgICAgICAgICAgICAgIGNoID0gdGhpcy5zb3VyY2UuY2hhckNvZGVBdCh0aGlzLmluZGV4ICsgMSk7XHJcblx0ICAgICAgICAgICAgICAgIGlmIChjaCA9PT0gMHgyRikge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgdGhpcy5pbmRleCArPSAyO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIGNvbW1lbnQgPSB0aGlzLnNraXBTaW5nbGVMaW5lQ29tbWVudCgyKTtcclxuXHQgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLnRyYWNrQ29tbWVudCkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGNvbW1lbnRzID0gY29tbWVudHMuY29uY2F0KGNvbW1lbnQpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICAgICAgc3RhcnQgPSB0cnVlO1xyXG5cdCAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgIGVsc2UgaWYgKGNoID09PSAweDJBKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICB0aGlzLmluZGV4ICs9IDI7XHJcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgY29tbWVudCA9IHRoaXMuc2tpcE11bHRpTGluZUNvbW1lbnQoKTtcclxuXHQgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLnRyYWNrQ29tbWVudCkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGNvbW1lbnRzID0gY29tbWVudHMuY29uY2F0KGNvbW1lbnQpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgIGVsc2Uge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcblx0ICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgZWxzZSBpZiAoc3RhcnQgJiYgY2ggPT09IDB4MkQpIHtcclxuXHQgICAgICAgICAgICAgICAgLy8gVSswMDNFIGlzICc+J1xyXG5cdCAgICAgICAgICAgICAgICBpZiAoKHRoaXMuc291cmNlLmNoYXJDb2RlQXQodGhpcy5pbmRleCArIDEpID09PSAweDJEKSAmJiAodGhpcy5zb3VyY2UuY2hhckNvZGVBdCh0aGlzLmluZGV4ICsgMikgPT09IDB4M0UpKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAvLyAnLS0+JyBpcyBhIHNpbmdsZS1saW5lIGNvbW1lbnRcclxuXHQgICAgICAgICAgICAgICAgICAgIHRoaXMuaW5kZXggKz0gMztcclxuXHQgICAgICAgICAgICAgICAgICAgIHZhciBjb21tZW50ID0gdGhpcy5za2lwU2luZ2xlTGluZUNvbW1lbnQoMyk7XHJcblx0ICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy50cmFja0NvbW1lbnQpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBjb21tZW50cyA9IGNvbW1lbnRzLmNvbmNhdChjb21tZW50KTtcclxuXHQgICAgICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICBlbHNlIHtcclxuXHQgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cdCAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgIGVsc2UgaWYgKGNoID09PSAweDNDKSB7XHJcblx0ICAgICAgICAgICAgICAgIGlmICh0aGlzLnNvdXJjZS5zbGljZSh0aGlzLmluZGV4ICsgMSwgdGhpcy5pbmRleCArIDQpID09PSAnIS0tJykge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgdGhpcy5pbmRleCArPSA0OyAvLyBgPCEtLWBcclxuXHQgICAgICAgICAgICAgICAgICAgIHZhciBjb21tZW50ID0gdGhpcy5za2lwU2luZ2xlTGluZUNvbW1lbnQoNCk7XHJcblx0ICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy50cmFja0NvbW1lbnQpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBjb21tZW50cyA9IGNvbW1lbnRzLmNvbmNhdChjb21tZW50KTtcclxuXHQgICAgICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICBlbHNlIHtcclxuXHQgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cdCAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgIGVsc2Uge1xyXG5cdCAgICAgICAgICAgICAgICBicmVhaztcclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICByZXR1cm4gY29tbWVudHM7XHJcblx0ICAgIH07XHJcblx0ICAgIC8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLWZ1dHVyZS1yZXNlcnZlZC13b3Jkc1xyXG5cdCAgICBTY2FubmVyLnByb3RvdHlwZS5pc0Z1dHVyZVJlc2VydmVkV29yZCA9IGZ1bmN0aW9uIChpZCkge1xyXG5cdCAgICAgICAgc3dpdGNoIChpZCkge1xyXG5cdCAgICAgICAgICAgIGNhc2UgJ2VudW0nOlxyXG5cdCAgICAgICAgICAgIGNhc2UgJ2V4cG9ydCc6XHJcblx0ICAgICAgICAgICAgY2FzZSAnaW1wb3J0JzpcclxuXHQgICAgICAgICAgICBjYXNlICdzdXBlcic6XHJcblx0ICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG5cdCAgICAgICAgICAgIGRlZmF1bHQ6XHJcblx0ICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgfTtcclxuXHQgICAgU2Nhbm5lci5wcm90b3R5cGUuaXNTdHJpY3RNb2RlUmVzZXJ2ZWRXb3JkID0gZnVuY3Rpb24gKGlkKSB7XHJcblx0ICAgICAgICBzd2l0Y2ggKGlkKSB7XHJcblx0ICAgICAgICAgICAgY2FzZSAnaW1wbGVtZW50cyc6XHJcblx0ICAgICAgICAgICAgY2FzZSAnaW50ZXJmYWNlJzpcclxuXHQgICAgICAgICAgICBjYXNlICdwYWNrYWdlJzpcclxuXHQgICAgICAgICAgICBjYXNlICdwcml2YXRlJzpcclxuXHQgICAgICAgICAgICBjYXNlICdwcm90ZWN0ZWQnOlxyXG5cdCAgICAgICAgICAgIGNhc2UgJ3B1YmxpYyc6XHJcblx0ICAgICAgICAgICAgY2FzZSAnc3RhdGljJzpcclxuXHQgICAgICAgICAgICBjYXNlICd5aWVsZCc6XHJcblx0ICAgICAgICAgICAgY2FzZSAnbGV0JzpcclxuXHQgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcblx0ICAgICAgICAgICAgZGVmYXVsdDpcclxuXHQgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICB9O1xyXG5cdCAgICBTY2FubmVyLnByb3RvdHlwZS5pc1Jlc3RyaWN0ZWRXb3JkID0gZnVuY3Rpb24gKGlkKSB7XHJcblx0ICAgICAgICByZXR1cm4gaWQgPT09ICdldmFsJyB8fCBpZCA9PT0gJ2FyZ3VtZW50cyc7XHJcblx0ICAgIH07XHJcblx0ICAgIC8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLWtleXdvcmRzXHJcblx0ICAgIFNjYW5uZXIucHJvdG90eXBlLmlzS2V5d29yZCA9IGZ1bmN0aW9uIChpZCkge1xyXG5cdCAgICAgICAgc3dpdGNoIChpZC5sZW5ndGgpIHtcclxuXHQgICAgICAgICAgICBjYXNlIDI6XHJcblx0ICAgICAgICAgICAgICAgIHJldHVybiAoaWQgPT09ICdpZicpIHx8IChpZCA9PT0gJ2luJykgfHwgKGlkID09PSAnZG8nKTtcclxuXHQgICAgICAgICAgICBjYXNlIDM6XHJcblx0ICAgICAgICAgICAgICAgIHJldHVybiAoaWQgPT09ICd2YXInKSB8fCAoaWQgPT09ICdmb3InKSB8fCAoaWQgPT09ICduZXcnKSB8fFxyXG5cdCAgICAgICAgICAgICAgICAgICAgKGlkID09PSAndHJ5JykgfHwgKGlkID09PSAnbGV0Jyk7XHJcblx0ICAgICAgICAgICAgY2FzZSA0OlxyXG5cdCAgICAgICAgICAgICAgICByZXR1cm4gKGlkID09PSAndGhpcycpIHx8IChpZCA9PT0gJ2Vsc2UnKSB8fCAoaWQgPT09ICdjYXNlJykgfHxcclxuXHQgICAgICAgICAgICAgICAgICAgIChpZCA9PT0gJ3ZvaWQnKSB8fCAoaWQgPT09ICd3aXRoJykgfHwgKGlkID09PSAnZW51bScpO1xyXG5cdCAgICAgICAgICAgIGNhc2UgNTpcclxuXHQgICAgICAgICAgICAgICAgcmV0dXJuIChpZCA9PT0gJ3doaWxlJykgfHwgKGlkID09PSAnYnJlYWsnKSB8fCAoaWQgPT09ICdjYXRjaCcpIHx8XHJcblx0ICAgICAgICAgICAgICAgICAgICAoaWQgPT09ICd0aHJvdycpIHx8IChpZCA9PT0gJ2NvbnN0JykgfHwgKGlkID09PSAneWllbGQnKSB8fFxyXG5cdCAgICAgICAgICAgICAgICAgICAgKGlkID09PSAnY2xhc3MnKSB8fCAoaWQgPT09ICdzdXBlcicpO1xyXG5cdCAgICAgICAgICAgIGNhc2UgNjpcclxuXHQgICAgICAgICAgICAgICAgcmV0dXJuIChpZCA9PT0gJ3JldHVybicpIHx8IChpZCA9PT0gJ3R5cGVvZicpIHx8IChpZCA9PT0gJ2RlbGV0ZScpIHx8XHJcblx0ICAgICAgICAgICAgICAgICAgICAoaWQgPT09ICdzd2l0Y2gnKSB8fCAoaWQgPT09ICdleHBvcnQnKSB8fCAoaWQgPT09ICdpbXBvcnQnKTtcclxuXHQgICAgICAgICAgICBjYXNlIDc6XHJcblx0ICAgICAgICAgICAgICAgIHJldHVybiAoaWQgPT09ICdkZWZhdWx0JykgfHwgKGlkID09PSAnZmluYWxseScpIHx8IChpZCA9PT0gJ2V4dGVuZHMnKTtcclxuXHQgICAgICAgICAgICBjYXNlIDg6XHJcblx0ICAgICAgICAgICAgICAgIHJldHVybiAoaWQgPT09ICdmdW5jdGlvbicpIHx8IChpZCA9PT0gJ2NvbnRpbnVlJykgfHwgKGlkID09PSAnZGVidWdnZXInKTtcclxuXHQgICAgICAgICAgICBjYXNlIDEwOlxyXG5cdCAgICAgICAgICAgICAgICByZXR1cm4gKGlkID09PSAnaW5zdGFuY2VvZicpO1xyXG5cdCAgICAgICAgICAgIGRlZmF1bHQ6XHJcblx0ICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgfTtcclxuXHQgICAgU2Nhbm5lci5wcm90b3R5cGUuY29kZVBvaW50QXQgPSBmdW5jdGlvbiAoaSkge1xyXG5cdCAgICAgICAgdmFyIGNwID0gdGhpcy5zb3VyY2UuY2hhckNvZGVBdChpKTtcclxuXHQgICAgICAgIGlmIChjcCA+PSAweEQ4MDAgJiYgY3AgPD0gMHhEQkZGKSB7XHJcblx0ICAgICAgICAgICAgdmFyIHNlY29uZCA9IHRoaXMuc291cmNlLmNoYXJDb2RlQXQoaSArIDEpO1xyXG5cdCAgICAgICAgICAgIGlmIChzZWNvbmQgPj0gMHhEQzAwICYmIHNlY29uZCA8PSAweERGRkYpIHtcclxuXHQgICAgICAgICAgICAgICAgdmFyIGZpcnN0ID0gY3A7XHJcblx0ICAgICAgICAgICAgICAgIGNwID0gKGZpcnN0IC0gMHhEODAwKSAqIDB4NDAwICsgc2Vjb25kIC0gMHhEQzAwICsgMHgxMDAwMDtcclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICByZXR1cm4gY3A7XHJcblx0ICAgIH07XHJcblx0ICAgIFNjYW5uZXIucHJvdG90eXBlLnNjYW5IZXhFc2NhcGUgPSBmdW5jdGlvbiAocHJlZml4KSB7XHJcblx0ICAgICAgICB2YXIgbGVuID0gKHByZWZpeCA9PT0gJ3UnKSA/IDQgOiAyO1xyXG5cdCAgICAgICAgdmFyIGNvZGUgPSAwO1xyXG5cdCAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47ICsraSkge1xyXG5cdCAgICAgICAgICAgIGlmICghdGhpcy5lb2YoKSAmJiBjaGFyYWN0ZXJfMS5DaGFyYWN0ZXIuaXNIZXhEaWdpdCh0aGlzLnNvdXJjZS5jaGFyQ29kZUF0KHRoaXMuaW5kZXgpKSkge1xyXG5cdCAgICAgICAgICAgICAgICBjb2RlID0gY29kZSAqIDE2ICsgaGV4VmFsdWUodGhpcy5zb3VyY2VbdGhpcy5pbmRleCsrXSk7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgIGVsc2Uge1xyXG5cdCAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZShjb2RlKTtcclxuXHQgICAgfTtcclxuXHQgICAgU2Nhbm5lci5wcm90b3R5cGUuc2NhblVuaWNvZGVDb2RlUG9pbnRFc2NhcGUgPSBmdW5jdGlvbiAoKSB7XHJcblx0ICAgICAgICB2YXIgY2ggPSB0aGlzLnNvdXJjZVt0aGlzLmluZGV4XTtcclxuXHQgICAgICAgIHZhciBjb2RlID0gMDtcclxuXHQgICAgICAgIC8vIEF0IGxlYXN0LCBvbmUgaGV4IGRpZ2l0IGlzIHJlcXVpcmVkLlxyXG5cdCAgICAgICAgaWYgKGNoID09PSAnfScpIHtcclxuXHQgICAgICAgICAgICB0aGlzLnRocm93VW5leHBlY3RlZFRva2VuKCk7XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICB3aGlsZSAoIXRoaXMuZW9mKCkpIHtcclxuXHQgICAgICAgICAgICBjaCA9IHRoaXMuc291cmNlW3RoaXMuaW5kZXgrK107XHJcblx0ICAgICAgICAgICAgaWYgKCFjaGFyYWN0ZXJfMS5DaGFyYWN0ZXIuaXNIZXhEaWdpdChjaC5jaGFyQ29kZUF0KDApKSkge1xyXG5cdCAgICAgICAgICAgICAgICBicmVhaztcclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgY29kZSA9IGNvZGUgKiAxNiArIGhleFZhbHVlKGNoKTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIGlmIChjb2RlID4gMHgxMEZGRkYgfHwgY2ggIT09ICd9Jykge1xyXG5cdCAgICAgICAgICAgIHRoaXMudGhyb3dVbmV4cGVjdGVkVG9rZW4oKTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIHJldHVybiBjaGFyYWN0ZXJfMS5DaGFyYWN0ZXIuZnJvbUNvZGVQb2ludChjb2RlKTtcclxuXHQgICAgfTtcclxuXHQgICAgU2Nhbm5lci5wcm90b3R5cGUuZ2V0SWRlbnRpZmllciA9IGZ1bmN0aW9uICgpIHtcclxuXHQgICAgICAgIHZhciBzdGFydCA9IHRoaXMuaW5kZXgrKztcclxuXHQgICAgICAgIHdoaWxlICghdGhpcy5lb2YoKSkge1xyXG5cdCAgICAgICAgICAgIHZhciBjaCA9IHRoaXMuc291cmNlLmNoYXJDb2RlQXQodGhpcy5pbmRleCk7XHJcblx0ICAgICAgICAgICAgaWYgKGNoID09PSAweDVDKSB7XHJcblx0ICAgICAgICAgICAgICAgIC8vIEJsYWNrc2xhc2ggKFUrMDA1QykgbWFya3MgVW5pY29kZSBlc2NhcGUgc2VxdWVuY2UuXHJcblx0ICAgICAgICAgICAgICAgIHRoaXMuaW5kZXggPSBzdGFydDtcclxuXHQgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0Q29tcGxleElkZW50aWZpZXIoKTtcclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgZWxzZSBpZiAoY2ggPj0gMHhEODAwICYmIGNoIDwgMHhERkZGKSB7XHJcblx0ICAgICAgICAgICAgICAgIC8vIE5lZWQgdG8gaGFuZGxlIHN1cnJvZ2F0ZSBwYWlycy5cclxuXHQgICAgICAgICAgICAgICAgdGhpcy5pbmRleCA9IHN0YXJ0O1xyXG5cdCAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5nZXRDb21wbGV4SWRlbnRpZmllcigpO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICBpZiAoY2hhcmFjdGVyXzEuQ2hhcmFjdGVyLmlzSWRlbnRpZmllclBhcnQoY2gpKSB7XHJcblx0ICAgICAgICAgICAgICAgICsrdGhpcy5pbmRleDtcclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgZWxzZSB7XHJcblx0ICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIHJldHVybiB0aGlzLnNvdXJjZS5zbGljZShzdGFydCwgdGhpcy5pbmRleCk7XHJcblx0ICAgIH07XHJcblx0ICAgIFNjYW5uZXIucHJvdG90eXBlLmdldENvbXBsZXhJZGVudGlmaWVyID0gZnVuY3Rpb24gKCkge1xyXG5cdCAgICAgICAgdmFyIGNwID0gdGhpcy5jb2RlUG9pbnRBdCh0aGlzLmluZGV4KTtcclxuXHQgICAgICAgIHZhciBpZCA9IGNoYXJhY3Rlcl8xLkNoYXJhY3Rlci5mcm9tQ29kZVBvaW50KGNwKTtcclxuXHQgICAgICAgIHRoaXMuaW5kZXggKz0gaWQubGVuZ3RoO1xyXG5cdCAgICAgICAgLy8gJ1xcdScgKFUrMDA1QywgVSswMDc1KSBkZW5vdGVzIGFuIGVzY2FwZWQgY2hhcmFjdGVyLlxyXG5cdCAgICAgICAgdmFyIGNoO1xyXG5cdCAgICAgICAgaWYgKGNwID09PSAweDVDKSB7XHJcblx0ICAgICAgICAgICAgaWYgKHRoaXMuc291cmNlLmNoYXJDb2RlQXQodGhpcy5pbmRleCkgIT09IDB4NzUpIHtcclxuXHQgICAgICAgICAgICAgICAgdGhpcy50aHJvd1VuZXhwZWN0ZWRUb2tlbigpO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICArK3RoaXMuaW5kZXg7XHJcblx0ICAgICAgICAgICAgaWYgKHRoaXMuc291cmNlW3RoaXMuaW5kZXhdID09PSAneycpIHtcclxuXHQgICAgICAgICAgICAgICAgKyt0aGlzLmluZGV4O1xyXG5cdCAgICAgICAgICAgICAgICBjaCA9IHRoaXMuc2NhblVuaWNvZGVDb2RlUG9pbnRFc2NhcGUoKTtcclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgZWxzZSB7XHJcblx0ICAgICAgICAgICAgICAgIGNoID0gdGhpcy5zY2FuSGV4RXNjYXBlKCd1Jyk7XHJcblx0ICAgICAgICAgICAgICAgIGlmIChjaCA9PT0gbnVsbCB8fCBjaCA9PT0gJ1xcXFwnIHx8ICFjaGFyYWN0ZXJfMS5DaGFyYWN0ZXIuaXNJZGVudGlmaWVyU3RhcnQoY2guY2hhckNvZGVBdCgwKSkpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgIHRoaXMudGhyb3dVbmV4cGVjdGVkVG9rZW4oKTtcclxuXHQgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICBpZCA9IGNoO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgd2hpbGUgKCF0aGlzLmVvZigpKSB7XHJcblx0ICAgICAgICAgICAgY3AgPSB0aGlzLmNvZGVQb2ludEF0KHRoaXMuaW5kZXgpO1xyXG5cdCAgICAgICAgICAgIGlmICghY2hhcmFjdGVyXzEuQ2hhcmFjdGVyLmlzSWRlbnRpZmllclBhcnQoY3ApKSB7XHJcblx0ICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICBjaCA9IGNoYXJhY3Rlcl8xLkNoYXJhY3Rlci5mcm9tQ29kZVBvaW50KGNwKTtcclxuXHQgICAgICAgICAgICBpZCArPSBjaDtcclxuXHQgICAgICAgICAgICB0aGlzLmluZGV4ICs9IGNoLmxlbmd0aDtcclxuXHQgICAgICAgICAgICAvLyAnXFx1JyAoVSswMDVDLCBVKzAwNzUpIGRlbm90ZXMgYW4gZXNjYXBlZCBjaGFyYWN0ZXIuXHJcblx0ICAgICAgICAgICAgaWYgKGNwID09PSAweDVDKSB7XHJcblx0ICAgICAgICAgICAgICAgIGlkID0gaWQuc3Vic3RyKDAsIGlkLmxlbmd0aCAtIDEpO1xyXG5cdCAgICAgICAgICAgICAgICBpZiAodGhpcy5zb3VyY2UuY2hhckNvZGVBdCh0aGlzLmluZGV4KSAhPT0gMHg3NSkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgdGhpcy50aHJvd1VuZXhwZWN0ZWRUb2tlbigpO1xyXG5cdCAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgICsrdGhpcy5pbmRleDtcclxuXHQgICAgICAgICAgICAgICAgaWYgKHRoaXMuc291cmNlW3RoaXMuaW5kZXhdID09PSAneycpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICsrdGhpcy5pbmRleDtcclxuXHQgICAgICAgICAgICAgICAgICAgIGNoID0gdGhpcy5zY2FuVW5pY29kZUNvZGVQb2ludEVzY2FwZSgpO1xyXG5cdCAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgIGVsc2Uge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgY2ggPSB0aGlzLnNjYW5IZXhFc2NhcGUoJ3UnKTtcclxuXHQgICAgICAgICAgICAgICAgICAgIGlmIChjaCA9PT0gbnVsbCB8fCBjaCA9PT0gJ1xcXFwnIHx8ICFjaGFyYWN0ZXJfMS5DaGFyYWN0ZXIuaXNJZGVudGlmaWVyUGFydChjaC5jaGFyQ29kZUF0KDApKSkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMudGhyb3dVbmV4cGVjdGVkVG9rZW4oKTtcclxuXHQgICAgICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICBpZCArPSBjaDtcclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICByZXR1cm4gaWQ7XHJcblx0ICAgIH07XHJcblx0ICAgIFNjYW5uZXIucHJvdG90eXBlLm9jdGFsVG9EZWNpbWFsID0gZnVuY3Rpb24gKGNoKSB7XHJcblx0ICAgICAgICAvLyBcXDAgaXMgbm90IG9jdGFsIGVzY2FwZSBzZXF1ZW5jZVxyXG5cdCAgICAgICAgdmFyIG9jdGFsID0gKGNoICE9PSAnMCcpO1xyXG5cdCAgICAgICAgdmFyIGNvZGUgPSBvY3RhbFZhbHVlKGNoKTtcclxuXHQgICAgICAgIGlmICghdGhpcy5lb2YoKSAmJiBjaGFyYWN0ZXJfMS5DaGFyYWN0ZXIuaXNPY3RhbERpZ2l0KHRoaXMuc291cmNlLmNoYXJDb2RlQXQodGhpcy5pbmRleCkpKSB7XHJcblx0ICAgICAgICAgICAgb2N0YWwgPSB0cnVlO1xyXG5cdCAgICAgICAgICAgIGNvZGUgPSBjb2RlICogOCArIG9jdGFsVmFsdWUodGhpcy5zb3VyY2VbdGhpcy5pbmRleCsrXSk7XHJcblx0ICAgICAgICAgICAgLy8gMyBkaWdpdHMgYXJlIG9ubHkgYWxsb3dlZCB3aGVuIHN0cmluZyBzdGFydHNcclxuXHQgICAgICAgICAgICAvLyB3aXRoIDAsIDEsIDIsIDNcclxuXHQgICAgICAgICAgICBpZiAoJzAxMjMnLmluZGV4T2YoY2gpID49IDAgJiYgIXRoaXMuZW9mKCkgJiYgY2hhcmFjdGVyXzEuQ2hhcmFjdGVyLmlzT2N0YWxEaWdpdCh0aGlzLnNvdXJjZS5jaGFyQ29kZUF0KHRoaXMuaW5kZXgpKSkge1xyXG5cdCAgICAgICAgICAgICAgICBjb2RlID0gY29kZSAqIDggKyBvY3RhbFZhbHVlKHRoaXMuc291cmNlW3RoaXMuaW5kZXgrK10pO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIHJldHVybiB7XHJcblx0ICAgICAgICAgICAgY29kZTogY29kZSxcclxuXHQgICAgICAgICAgICBvY3RhbDogb2N0YWxcclxuXHQgICAgICAgIH07XHJcblx0ICAgIH07XHJcblx0ICAgIC8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLW5hbWVzLWFuZC1rZXl3b3Jkc1xyXG5cdCAgICBTY2FubmVyLnByb3RvdHlwZS5zY2FuSWRlbnRpZmllciA9IGZ1bmN0aW9uICgpIHtcclxuXHQgICAgICAgIHZhciB0eXBlO1xyXG5cdCAgICAgICAgdmFyIHN0YXJ0ID0gdGhpcy5pbmRleDtcclxuXHQgICAgICAgIC8vIEJhY2tzbGFzaCAoVSswMDVDKSBzdGFydHMgYW4gZXNjYXBlZCBjaGFyYWN0ZXIuXHJcblx0ICAgICAgICB2YXIgaWQgPSAodGhpcy5zb3VyY2UuY2hhckNvZGVBdChzdGFydCkgPT09IDB4NUMpID8gdGhpcy5nZXRDb21wbGV4SWRlbnRpZmllcigpIDogdGhpcy5nZXRJZGVudGlmaWVyKCk7XHJcblx0ICAgICAgICAvLyBUaGVyZSBpcyBubyBrZXl3b3JkIG9yIGxpdGVyYWwgd2l0aCBvbmx5IG9uZSBjaGFyYWN0ZXIuXHJcblx0ICAgICAgICAvLyBUaHVzLCBpdCBtdXN0IGJlIGFuIGlkZW50aWZpZXIuXHJcblx0ICAgICAgICBpZiAoaWQubGVuZ3RoID09PSAxKSB7XHJcblx0ICAgICAgICAgICAgdHlwZSA9IDMgLyogSWRlbnRpZmllciAqLztcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIGVsc2UgaWYgKHRoaXMuaXNLZXl3b3JkKGlkKSkge1xyXG5cdCAgICAgICAgICAgIHR5cGUgPSA0IC8qIEtleXdvcmQgKi87XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICBlbHNlIGlmIChpZCA9PT0gJ251bGwnKSB7XHJcblx0ICAgICAgICAgICAgdHlwZSA9IDUgLyogTnVsbExpdGVyYWwgKi87XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICBlbHNlIGlmIChpZCA9PT0gJ3RydWUnIHx8IGlkID09PSAnZmFsc2UnKSB7XHJcblx0ICAgICAgICAgICAgdHlwZSA9IDEgLyogQm9vbGVhbkxpdGVyYWwgKi87XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICBlbHNlIHtcclxuXHQgICAgICAgICAgICB0eXBlID0gMyAvKiBJZGVudGlmaWVyICovO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgaWYgKHR5cGUgIT09IDMgLyogSWRlbnRpZmllciAqLyAmJiAoc3RhcnQgKyBpZC5sZW5ndGggIT09IHRoaXMuaW5kZXgpKSB7XHJcblx0ICAgICAgICAgICAgdmFyIHJlc3RvcmUgPSB0aGlzLmluZGV4O1xyXG5cdCAgICAgICAgICAgIHRoaXMuaW5kZXggPSBzdGFydDtcclxuXHQgICAgICAgICAgICB0aGlzLnRvbGVyYXRlVW5leHBlY3RlZFRva2VuKG1lc3NhZ2VzXzEuTWVzc2FnZXMuSW52YWxpZEVzY2FwZWRSZXNlcnZlZFdvcmQpO1xyXG5cdCAgICAgICAgICAgIHRoaXMuaW5kZXggPSByZXN0b3JlO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgcmV0dXJuIHtcclxuXHQgICAgICAgICAgICB0eXBlOiB0eXBlLFxyXG5cdCAgICAgICAgICAgIHZhbHVlOiBpZCxcclxuXHQgICAgICAgICAgICBsaW5lTnVtYmVyOiB0aGlzLmxpbmVOdW1iZXIsXHJcblx0ICAgICAgICAgICAgbGluZVN0YXJ0OiB0aGlzLmxpbmVTdGFydCxcclxuXHQgICAgICAgICAgICBzdGFydDogc3RhcnQsXHJcblx0ICAgICAgICAgICAgZW5kOiB0aGlzLmluZGV4XHJcblx0ICAgICAgICB9O1xyXG5cdCAgICB9O1xyXG5cdCAgICAvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1wdW5jdHVhdG9yc1xyXG5cdCAgICBTY2FubmVyLnByb3RvdHlwZS5zY2FuUHVuY3R1YXRvciA9IGZ1bmN0aW9uICgpIHtcclxuXHQgICAgICAgIHZhciBzdGFydCA9IHRoaXMuaW5kZXg7XHJcblx0ICAgICAgICAvLyBDaGVjayBmb3IgbW9zdCBjb21tb24gc2luZ2xlLWNoYXJhY3RlciBwdW5jdHVhdG9ycy5cclxuXHQgICAgICAgIHZhciBzdHIgPSB0aGlzLnNvdXJjZVt0aGlzLmluZGV4XTtcclxuXHQgICAgICAgIHN3aXRjaCAoc3RyKSB7XHJcblx0ICAgICAgICAgICAgY2FzZSAnKCc6XHJcblx0ICAgICAgICAgICAgY2FzZSAneyc6XHJcblx0ICAgICAgICAgICAgICAgIGlmIChzdHIgPT09ICd7Jykge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgdGhpcy5jdXJseVN0YWNrLnB1c2goJ3snKTtcclxuXHQgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICArK3RoaXMuaW5kZXg7XHJcblx0ICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cdCAgICAgICAgICAgIGNhc2UgJy4nOlxyXG5cdCAgICAgICAgICAgICAgICArK3RoaXMuaW5kZXg7XHJcblx0ICAgICAgICAgICAgICAgIGlmICh0aGlzLnNvdXJjZVt0aGlzLmluZGV4XSA9PT0gJy4nICYmIHRoaXMuc291cmNlW3RoaXMuaW5kZXggKyAxXSA9PT0gJy4nKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAvLyBTcHJlYWQgb3BlcmF0b3I6IC4uLlxyXG5cdCAgICAgICAgICAgICAgICAgICAgdGhpcy5pbmRleCArPSAyO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgc3RyID0gJy4uLic7XHJcblx0ICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgYnJlYWs7XHJcblx0ICAgICAgICAgICAgY2FzZSAnfSc6XHJcblx0ICAgICAgICAgICAgICAgICsrdGhpcy5pbmRleDtcclxuXHQgICAgICAgICAgICAgICAgdGhpcy5jdXJseVN0YWNrLnBvcCgpO1xyXG5cdCAgICAgICAgICAgICAgICBicmVhaztcclxuXHQgICAgICAgICAgICBjYXNlICcpJzpcclxuXHQgICAgICAgICAgICBjYXNlICc7JzpcclxuXHQgICAgICAgICAgICBjYXNlICcsJzpcclxuXHQgICAgICAgICAgICBjYXNlICdbJzpcclxuXHQgICAgICAgICAgICBjYXNlICddJzpcclxuXHQgICAgICAgICAgICBjYXNlICc6JzpcclxuXHQgICAgICAgICAgICBjYXNlICc/JzpcclxuXHQgICAgICAgICAgICBjYXNlICd+JzpcclxuXHQgICAgICAgICAgICAgICAgKyt0aGlzLmluZGV4O1xyXG5cdCAgICAgICAgICAgICAgICBicmVhaztcclxuXHQgICAgICAgICAgICBkZWZhdWx0OlxyXG5cdCAgICAgICAgICAgICAgICAvLyA0LWNoYXJhY3RlciBwdW5jdHVhdG9yLlxyXG5cdCAgICAgICAgICAgICAgICBzdHIgPSB0aGlzLnNvdXJjZS5zdWJzdHIodGhpcy5pbmRleCwgNCk7XHJcblx0ICAgICAgICAgICAgICAgIGlmIChzdHIgPT09ICc+Pj49Jykge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgdGhpcy5pbmRleCArPSA0O1xyXG5cdCAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgIGVsc2Uge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgLy8gMy1jaGFyYWN0ZXIgcHVuY3R1YXRvcnMuXHJcblx0ICAgICAgICAgICAgICAgICAgICBzdHIgPSBzdHIuc3Vic3RyKDAsIDMpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKHN0ciA9PT0gJz09PScgfHwgc3RyID09PSAnIT09JyB8fCBzdHIgPT09ICc+Pj4nIHx8XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgc3RyID09PSAnPDw9JyB8fCBzdHIgPT09ICc+Pj0nIHx8IHN0ciA9PT0gJyoqPScpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmluZGV4ICs9IDM7XHJcblx0ICAgICAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAvLyAyLWNoYXJhY3RlciBwdW5jdHVhdG9ycy5cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBzdHIgPSBzdHIuc3Vic3RyKDAsIDIpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzdHIgPT09ICcmJicgfHwgc3RyID09PSAnfHwnIHx8IHN0ciA9PT0gJz09JyB8fCBzdHIgPT09ICchPScgfHxcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RyID09PSAnKz0nIHx8IHN0ciA9PT0gJy09JyB8fCBzdHIgPT09ICcqPScgfHwgc3RyID09PSAnLz0nIHx8XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0ciA9PT0gJysrJyB8fCBzdHIgPT09ICctLScgfHwgc3RyID09PSAnPDwnIHx8IHN0ciA9PT0gJz4+JyB8fFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHIgPT09ICcmPScgfHwgc3RyID09PSAnfD0nIHx8IHN0ciA9PT0gJ149JyB8fCBzdHIgPT09ICclPScgfHxcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RyID09PSAnPD0nIHx8IHN0ciA9PT0gJz49JyB8fCBzdHIgPT09ICc9PicgfHwgc3RyID09PSAnKionKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuaW5kZXggKz0gMjtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIDEtY2hhcmFjdGVyIHB1bmN0dWF0b3JzLlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHIgPSB0aGlzLnNvdXJjZVt0aGlzLmluZGV4XTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCc8Pj0hKy0qJSZ8Xi8nLmluZGV4T2Yoc3RyKSA+PSAwKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICArK3RoaXMuaW5kZXg7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIGlmICh0aGlzLmluZGV4ID09PSBzdGFydCkge1xyXG5cdCAgICAgICAgICAgIHRoaXMudGhyb3dVbmV4cGVjdGVkVG9rZW4oKTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIHJldHVybiB7XHJcblx0ICAgICAgICAgICAgdHlwZTogNyAvKiBQdW5jdHVhdG9yICovLFxyXG5cdCAgICAgICAgICAgIHZhbHVlOiBzdHIsXHJcblx0ICAgICAgICAgICAgbGluZU51bWJlcjogdGhpcy5saW5lTnVtYmVyLFxyXG5cdCAgICAgICAgICAgIGxpbmVTdGFydDogdGhpcy5saW5lU3RhcnQsXHJcblx0ICAgICAgICAgICAgc3RhcnQ6IHN0YXJ0LFxyXG5cdCAgICAgICAgICAgIGVuZDogdGhpcy5pbmRleFxyXG5cdCAgICAgICAgfTtcclxuXHQgICAgfTtcclxuXHQgICAgLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtbGl0ZXJhbHMtbnVtZXJpYy1saXRlcmFsc1xyXG5cdCAgICBTY2FubmVyLnByb3RvdHlwZS5zY2FuSGV4TGl0ZXJhbCA9IGZ1bmN0aW9uIChzdGFydCkge1xyXG5cdCAgICAgICAgdmFyIG51bSA9ICcnO1xyXG5cdCAgICAgICAgd2hpbGUgKCF0aGlzLmVvZigpKSB7XHJcblx0ICAgICAgICAgICAgaWYgKCFjaGFyYWN0ZXJfMS5DaGFyYWN0ZXIuaXNIZXhEaWdpdCh0aGlzLnNvdXJjZS5jaGFyQ29kZUF0KHRoaXMuaW5kZXgpKSkge1xyXG5cdCAgICAgICAgICAgICAgICBicmVhaztcclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgbnVtICs9IHRoaXMuc291cmNlW3RoaXMuaW5kZXgrK107XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICBpZiAobnVtLmxlbmd0aCA9PT0gMCkge1xyXG5cdCAgICAgICAgICAgIHRoaXMudGhyb3dVbmV4cGVjdGVkVG9rZW4oKTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIGlmIChjaGFyYWN0ZXJfMS5DaGFyYWN0ZXIuaXNJZGVudGlmaWVyU3RhcnQodGhpcy5zb3VyY2UuY2hhckNvZGVBdCh0aGlzLmluZGV4KSkpIHtcclxuXHQgICAgICAgICAgICB0aGlzLnRocm93VW5leHBlY3RlZFRva2VuKCk7XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICByZXR1cm4ge1xyXG5cdCAgICAgICAgICAgIHR5cGU6IDYgLyogTnVtZXJpY0xpdGVyYWwgKi8sXHJcblx0ICAgICAgICAgICAgdmFsdWU6IHBhcnNlSW50KCcweCcgKyBudW0sIDE2KSxcclxuXHQgICAgICAgICAgICBsaW5lTnVtYmVyOiB0aGlzLmxpbmVOdW1iZXIsXHJcblx0ICAgICAgICAgICAgbGluZVN0YXJ0OiB0aGlzLmxpbmVTdGFydCxcclxuXHQgICAgICAgICAgICBzdGFydDogc3RhcnQsXHJcblx0ICAgICAgICAgICAgZW5kOiB0aGlzLmluZGV4XHJcblx0ICAgICAgICB9O1xyXG5cdCAgICB9O1xyXG5cdCAgICBTY2FubmVyLnByb3RvdHlwZS5zY2FuQmluYXJ5TGl0ZXJhbCA9IGZ1bmN0aW9uIChzdGFydCkge1xyXG5cdCAgICAgICAgdmFyIG51bSA9ICcnO1xyXG5cdCAgICAgICAgdmFyIGNoO1xyXG5cdCAgICAgICAgd2hpbGUgKCF0aGlzLmVvZigpKSB7XHJcblx0ICAgICAgICAgICAgY2ggPSB0aGlzLnNvdXJjZVt0aGlzLmluZGV4XTtcclxuXHQgICAgICAgICAgICBpZiAoY2ggIT09ICcwJyAmJiBjaCAhPT0gJzEnKSB7XHJcblx0ICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICBudW0gKz0gdGhpcy5zb3VyY2VbdGhpcy5pbmRleCsrXTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIGlmIChudW0ubGVuZ3RoID09PSAwKSB7XHJcblx0ICAgICAgICAgICAgLy8gb25seSAwYiBvciAwQlxyXG5cdCAgICAgICAgICAgIHRoaXMudGhyb3dVbmV4cGVjdGVkVG9rZW4oKTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIGlmICghdGhpcy5lb2YoKSkge1xyXG5cdCAgICAgICAgICAgIGNoID0gdGhpcy5zb3VyY2UuY2hhckNvZGVBdCh0aGlzLmluZGV4KTtcclxuXHQgICAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xyXG5cdCAgICAgICAgICAgIGlmIChjaGFyYWN0ZXJfMS5DaGFyYWN0ZXIuaXNJZGVudGlmaWVyU3RhcnQoY2gpIHx8IGNoYXJhY3Rlcl8xLkNoYXJhY3Rlci5pc0RlY2ltYWxEaWdpdChjaCkpIHtcclxuXHQgICAgICAgICAgICAgICAgdGhpcy50aHJvd1VuZXhwZWN0ZWRUb2tlbigpO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIHJldHVybiB7XHJcblx0ICAgICAgICAgICAgdHlwZTogNiAvKiBOdW1lcmljTGl0ZXJhbCAqLyxcclxuXHQgICAgICAgICAgICB2YWx1ZTogcGFyc2VJbnQobnVtLCAyKSxcclxuXHQgICAgICAgICAgICBsaW5lTnVtYmVyOiB0aGlzLmxpbmVOdW1iZXIsXHJcblx0ICAgICAgICAgICAgbGluZVN0YXJ0OiB0aGlzLmxpbmVTdGFydCxcclxuXHQgICAgICAgICAgICBzdGFydDogc3RhcnQsXHJcblx0ICAgICAgICAgICAgZW5kOiB0aGlzLmluZGV4XHJcblx0ICAgICAgICB9O1xyXG5cdCAgICB9O1xyXG5cdCAgICBTY2FubmVyLnByb3RvdHlwZS5zY2FuT2N0YWxMaXRlcmFsID0gZnVuY3Rpb24gKHByZWZpeCwgc3RhcnQpIHtcclxuXHQgICAgICAgIHZhciBudW0gPSAnJztcclxuXHQgICAgICAgIHZhciBvY3RhbCA9IGZhbHNlO1xyXG5cdCAgICAgICAgaWYgKGNoYXJhY3Rlcl8xLkNoYXJhY3Rlci5pc09jdGFsRGlnaXQocHJlZml4LmNoYXJDb2RlQXQoMCkpKSB7XHJcblx0ICAgICAgICAgICAgb2N0YWwgPSB0cnVlO1xyXG5cdCAgICAgICAgICAgIG51bSA9ICcwJyArIHRoaXMuc291cmNlW3RoaXMuaW5kZXgrK107XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICBlbHNlIHtcclxuXHQgICAgICAgICAgICArK3RoaXMuaW5kZXg7XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICB3aGlsZSAoIXRoaXMuZW9mKCkpIHtcclxuXHQgICAgICAgICAgICBpZiAoIWNoYXJhY3Rlcl8xLkNoYXJhY3Rlci5pc09jdGFsRGlnaXQodGhpcy5zb3VyY2UuY2hhckNvZGVBdCh0aGlzLmluZGV4KSkpIHtcclxuXHQgICAgICAgICAgICAgICAgYnJlYWs7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgIG51bSArPSB0aGlzLnNvdXJjZVt0aGlzLmluZGV4KytdO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgaWYgKCFvY3RhbCAmJiBudW0ubGVuZ3RoID09PSAwKSB7XHJcblx0ICAgICAgICAgICAgLy8gb25seSAwbyBvciAwT1xyXG5cdCAgICAgICAgICAgIHRoaXMudGhyb3dVbmV4cGVjdGVkVG9rZW4oKTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIGlmIChjaGFyYWN0ZXJfMS5DaGFyYWN0ZXIuaXNJZGVudGlmaWVyU3RhcnQodGhpcy5zb3VyY2UuY2hhckNvZGVBdCh0aGlzLmluZGV4KSkgfHwgY2hhcmFjdGVyXzEuQ2hhcmFjdGVyLmlzRGVjaW1hbERpZ2l0KHRoaXMuc291cmNlLmNoYXJDb2RlQXQodGhpcy5pbmRleCkpKSB7XHJcblx0ICAgICAgICAgICAgdGhpcy50aHJvd1VuZXhwZWN0ZWRUb2tlbigpO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgcmV0dXJuIHtcclxuXHQgICAgICAgICAgICB0eXBlOiA2IC8qIE51bWVyaWNMaXRlcmFsICovLFxyXG5cdCAgICAgICAgICAgIHZhbHVlOiBwYXJzZUludChudW0sIDgpLFxyXG5cdCAgICAgICAgICAgIG9jdGFsOiBvY3RhbCxcclxuXHQgICAgICAgICAgICBsaW5lTnVtYmVyOiB0aGlzLmxpbmVOdW1iZXIsXHJcblx0ICAgICAgICAgICAgbGluZVN0YXJ0OiB0aGlzLmxpbmVTdGFydCxcclxuXHQgICAgICAgICAgICBzdGFydDogc3RhcnQsXHJcblx0ICAgICAgICAgICAgZW5kOiB0aGlzLmluZGV4XHJcblx0ICAgICAgICB9O1xyXG5cdCAgICB9O1xyXG5cdCAgICBTY2FubmVyLnByb3RvdHlwZS5pc0ltcGxpY2l0T2N0YWxMaXRlcmFsID0gZnVuY3Rpb24gKCkge1xyXG5cdCAgICAgICAgLy8gSW1wbGljaXQgb2N0YWwsIHVubGVzcyB0aGVyZSBpcyBhIG5vbi1vY3RhbCBkaWdpdC5cclxuXHQgICAgICAgIC8vIChBbm5leCBCLjEuMSBvbiBOdW1lcmljIExpdGVyYWxzKVxyXG5cdCAgICAgICAgZm9yICh2YXIgaSA9IHRoaXMuaW5kZXggKyAxOyBpIDwgdGhpcy5sZW5ndGg7ICsraSkge1xyXG5cdCAgICAgICAgICAgIHZhciBjaCA9IHRoaXMuc291cmNlW2ldO1xyXG5cdCAgICAgICAgICAgIGlmIChjaCA9PT0gJzgnIHx8IGNoID09PSAnOScpIHtcclxuXHQgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICBpZiAoIWNoYXJhY3Rlcl8xLkNoYXJhY3Rlci5pc09jdGFsRGlnaXQoY2guY2hhckNvZGVBdCgwKSkpIHtcclxuXHQgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgcmV0dXJuIHRydWU7XHJcblx0ICAgIH07XHJcblx0ICAgIFNjYW5uZXIucHJvdG90eXBlLnNjYW5OdW1lcmljTGl0ZXJhbCA9IGZ1bmN0aW9uICgpIHtcclxuXHQgICAgICAgIHZhciBzdGFydCA9IHRoaXMuaW5kZXg7XHJcblx0ICAgICAgICB2YXIgY2ggPSB0aGlzLnNvdXJjZVtzdGFydF07XHJcblx0ICAgICAgICBhc3NlcnRfMS5hc3NlcnQoY2hhcmFjdGVyXzEuQ2hhcmFjdGVyLmlzRGVjaW1hbERpZ2l0KGNoLmNoYXJDb2RlQXQoMCkpIHx8IChjaCA9PT0gJy4nKSwgJ051bWVyaWMgbGl0ZXJhbCBtdXN0IHN0YXJ0IHdpdGggYSBkZWNpbWFsIGRpZ2l0IG9yIGEgZGVjaW1hbCBwb2ludCcpO1xyXG5cdCAgICAgICAgdmFyIG51bSA9ICcnO1xyXG5cdCAgICAgICAgaWYgKGNoICE9PSAnLicpIHtcclxuXHQgICAgICAgICAgICBudW0gPSB0aGlzLnNvdXJjZVt0aGlzLmluZGV4KytdO1xyXG5cdCAgICAgICAgICAgIGNoID0gdGhpcy5zb3VyY2VbdGhpcy5pbmRleF07XHJcblx0ICAgICAgICAgICAgLy8gSGV4IG51bWJlciBzdGFydHMgd2l0aCAnMHgnLlxyXG5cdCAgICAgICAgICAgIC8vIE9jdGFsIG51bWJlciBzdGFydHMgd2l0aCAnMCcuXHJcblx0ICAgICAgICAgICAgLy8gT2N0YWwgbnVtYmVyIGluIEVTNiBzdGFydHMgd2l0aCAnMG8nLlxyXG5cdCAgICAgICAgICAgIC8vIEJpbmFyeSBudW1iZXIgaW4gRVM2IHN0YXJ0cyB3aXRoICcwYicuXHJcblx0ICAgICAgICAgICAgaWYgKG51bSA9PT0gJzAnKSB7XHJcblx0ICAgICAgICAgICAgICAgIGlmIChjaCA9PT0gJ3gnIHx8IGNoID09PSAnWCcpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICsrdGhpcy5pbmRleDtcclxuXHQgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnNjYW5IZXhMaXRlcmFsKHN0YXJ0KTtcclxuXHQgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICBpZiAoY2ggPT09ICdiJyB8fCBjaCA9PT0gJ0InKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICArK3RoaXMuaW5kZXg7XHJcblx0ICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5zY2FuQmluYXJ5TGl0ZXJhbChzdGFydCk7XHJcblx0ICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgaWYgKGNoID09PSAnbycgfHwgY2ggPT09ICdPJykge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2Nhbk9jdGFsTGl0ZXJhbChjaCwgc3RhcnQpO1xyXG5cdCAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgIGlmIChjaCAmJiBjaGFyYWN0ZXJfMS5DaGFyYWN0ZXIuaXNPY3RhbERpZ2l0KGNoLmNoYXJDb2RlQXQoMCkpKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5pc0ltcGxpY2l0T2N0YWxMaXRlcmFsKCkpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5zY2FuT2N0YWxMaXRlcmFsKGNoLCBzdGFydCk7XHJcblx0ICAgICAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgd2hpbGUgKGNoYXJhY3Rlcl8xLkNoYXJhY3Rlci5pc0RlY2ltYWxEaWdpdCh0aGlzLnNvdXJjZS5jaGFyQ29kZUF0KHRoaXMuaW5kZXgpKSkge1xyXG5cdCAgICAgICAgICAgICAgICBudW0gKz0gdGhpcy5zb3VyY2VbdGhpcy5pbmRleCsrXTtcclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgY2ggPSB0aGlzLnNvdXJjZVt0aGlzLmluZGV4XTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIGlmIChjaCA9PT0gJy4nKSB7XHJcblx0ICAgICAgICAgICAgbnVtICs9IHRoaXMuc291cmNlW3RoaXMuaW5kZXgrK107XHJcblx0ICAgICAgICAgICAgd2hpbGUgKGNoYXJhY3Rlcl8xLkNoYXJhY3Rlci5pc0RlY2ltYWxEaWdpdCh0aGlzLnNvdXJjZS5jaGFyQ29kZUF0KHRoaXMuaW5kZXgpKSkge1xyXG5cdCAgICAgICAgICAgICAgICBudW0gKz0gdGhpcy5zb3VyY2VbdGhpcy5pbmRleCsrXTtcclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgY2ggPSB0aGlzLnNvdXJjZVt0aGlzLmluZGV4XTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIGlmIChjaCA9PT0gJ2UnIHx8IGNoID09PSAnRScpIHtcclxuXHQgICAgICAgICAgICBudW0gKz0gdGhpcy5zb3VyY2VbdGhpcy5pbmRleCsrXTtcclxuXHQgICAgICAgICAgICBjaCA9IHRoaXMuc291cmNlW3RoaXMuaW5kZXhdO1xyXG5cdCAgICAgICAgICAgIGlmIChjaCA9PT0gJysnIHx8IGNoID09PSAnLScpIHtcclxuXHQgICAgICAgICAgICAgICAgbnVtICs9IHRoaXMuc291cmNlW3RoaXMuaW5kZXgrK107XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgIGlmIChjaGFyYWN0ZXJfMS5DaGFyYWN0ZXIuaXNEZWNpbWFsRGlnaXQodGhpcy5zb3VyY2UuY2hhckNvZGVBdCh0aGlzLmluZGV4KSkpIHtcclxuXHQgICAgICAgICAgICAgICAgd2hpbGUgKGNoYXJhY3Rlcl8xLkNoYXJhY3Rlci5pc0RlY2ltYWxEaWdpdCh0aGlzLnNvdXJjZS5jaGFyQ29kZUF0KHRoaXMuaW5kZXgpKSkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgbnVtICs9IHRoaXMuc291cmNlW3RoaXMuaW5kZXgrK107XHJcblx0ICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgZWxzZSB7XHJcblx0ICAgICAgICAgICAgICAgIHRoaXMudGhyb3dVbmV4cGVjdGVkVG9rZW4oKTtcclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICBpZiAoY2hhcmFjdGVyXzEuQ2hhcmFjdGVyLmlzSWRlbnRpZmllclN0YXJ0KHRoaXMuc291cmNlLmNoYXJDb2RlQXQodGhpcy5pbmRleCkpKSB7XHJcblx0ICAgICAgICAgICAgdGhpcy50aHJvd1VuZXhwZWN0ZWRUb2tlbigpO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgcmV0dXJuIHtcclxuXHQgICAgICAgICAgICB0eXBlOiA2IC8qIE51bWVyaWNMaXRlcmFsICovLFxyXG5cdCAgICAgICAgICAgIHZhbHVlOiBwYXJzZUZsb2F0KG51bSksXHJcblx0ICAgICAgICAgICAgbGluZU51bWJlcjogdGhpcy5saW5lTnVtYmVyLFxyXG5cdCAgICAgICAgICAgIGxpbmVTdGFydDogdGhpcy5saW5lU3RhcnQsXHJcblx0ICAgICAgICAgICAgc3RhcnQ6IHN0YXJ0LFxyXG5cdCAgICAgICAgICAgIGVuZDogdGhpcy5pbmRleFxyXG5cdCAgICAgICAgfTtcclxuXHQgICAgfTtcclxuXHQgICAgLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtbGl0ZXJhbHMtc3RyaW5nLWxpdGVyYWxzXHJcblx0ICAgIFNjYW5uZXIucHJvdG90eXBlLnNjYW5TdHJpbmdMaXRlcmFsID0gZnVuY3Rpb24gKCkge1xyXG5cdCAgICAgICAgdmFyIHN0YXJ0ID0gdGhpcy5pbmRleDtcclxuXHQgICAgICAgIHZhciBxdW90ZSA9IHRoaXMuc291cmNlW3N0YXJ0XTtcclxuXHQgICAgICAgIGFzc2VydF8xLmFzc2VydCgocXVvdGUgPT09ICdcXCcnIHx8IHF1b3RlID09PSAnXCInKSwgJ1N0cmluZyBsaXRlcmFsIG11c3Qgc3RhcnRzIHdpdGggYSBxdW90ZScpO1xyXG5cdCAgICAgICAgKyt0aGlzLmluZGV4O1xyXG5cdCAgICAgICAgdmFyIG9jdGFsID0gZmFsc2U7XHJcblx0ICAgICAgICB2YXIgc3RyID0gJyc7XHJcblx0ICAgICAgICB3aGlsZSAoIXRoaXMuZW9mKCkpIHtcclxuXHQgICAgICAgICAgICB2YXIgY2ggPSB0aGlzLnNvdXJjZVt0aGlzLmluZGV4KytdO1xyXG5cdCAgICAgICAgICAgIGlmIChjaCA9PT0gcXVvdGUpIHtcclxuXHQgICAgICAgICAgICAgICAgcXVvdGUgPSAnJztcclxuXHQgICAgICAgICAgICAgICAgYnJlYWs7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgIGVsc2UgaWYgKGNoID09PSAnXFxcXCcpIHtcclxuXHQgICAgICAgICAgICAgICAgY2ggPSB0aGlzLnNvdXJjZVt0aGlzLmluZGV4KytdO1xyXG5cdCAgICAgICAgICAgICAgICBpZiAoIWNoIHx8ICFjaGFyYWN0ZXJfMS5DaGFyYWN0ZXIuaXNMaW5lVGVybWluYXRvcihjaC5jaGFyQ29kZUF0KDApKSkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChjaCkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ3UnOlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5zb3VyY2VbdGhpcy5pbmRleF0gPT09ICd7Jykge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKyt0aGlzLmluZGV4O1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RyICs9IHRoaXMuc2NhblVuaWNvZGVDb2RlUG9pbnRFc2NhcGUoKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB1bmVzY2FwZWRfMSA9IHRoaXMuc2NhbkhleEVzY2FwZShjaCk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodW5lc2NhcGVkXzEgPT09IG51bGwpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnRocm93VW5leHBlY3RlZFRva2VuKCk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHIgKz0gdW5lc2NhcGVkXzE7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAneCc6XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB1bmVzY2FwZWQgPSB0aGlzLnNjYW5IZXhFc2NhcGUoY2gpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodW5lc2NhcGVkID09PSBudWxsKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnRocm93VW5leHBlY3RlZFRva2VuKG1lc3NhZ2VzXzEuTWVzc2FnZXMuSW52YWxpZEhleEVzY2FwZVNlcXVlbmNlKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHIgKz0gdW5lc2NhcGVkO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBjYXNlICduJzpcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RyICs9ICdcXG4nO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBjYXNlICdyJzpcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RyICs9ICdcXHInO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBjYXNlICd0JzpcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RyICs9ICdcXHQnO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBjYXNlICdiJzpcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RyICs9ICdcXGInO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBjYXNlICdmJzpcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RyICs9ICdcXGYnO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBjYXNlICd2JzpcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RyICs9ICdcXHgwQic7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJzgnOlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJzknOlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHIgKz0gY2g7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMudG9sZXJhdGVVbmV4cGVjdGVkVG9rZW4oKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNoICYmIGNoYXJhY3Rlcl8xLkNoYXJhY3Rlci5pc09jdGFsRGlnaXQoY2guY2hhckNvZGVBdCgwKSkpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBvY3RUb0RlYyA9IHRoaXMub2N0YWxUb0RlY2ltYWwoY2gpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb2N0YWwgPSBvY3RUb0RlYy5vY3RhbCB8fCBvY3RhbDtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0ciArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKG9jdFRvRGVjLmNvZGUpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RyICs9IGNoO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgIGVsc2Uge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgKyt0aGlzLmxpbmVOdW1iZXI7XHJcblx0ICAgICAgICAgICAgICAgICAgICBpZiAoY2ggPT09ICdcXHInICYmIHRoaXMuc291cmNlW3RoaXMuaW5kZXhdID09PSAnXFxuJykge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICsrdGhpcy5pbmRleDtcclxuXHQgICAgICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgICAgIHRoaXMubGluZVN0YXJ0ID0gdGhpcy5pbmRleDtcclxuXHQgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICBlbHNlIGlmIChjaGFyYWN0ZXJfMS5DaGFyYWN0ZXIuaXNMaW5lVGVybWluYXRvcihjaC5jaGFyQ29kZUF0KDApKSkge1xyXG5cdCAgICAgICAgICAgICAgICBicmVhaztcclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgZWxzZSB7XHJcblx0ICAgICAgICAgICAgICAgIHN0ciArPSBjaDtcclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICBpZiAocXVvdGUgIT09ICcnKSB7XHJcblx0ICAgICAgICAgICAgdGhpcy5pbmRleCA9IHN0YXJ0O1xyXG5cdCAgICAgICAgICAgIHRoaXMudGhyb3dVbmV4cGVjdGVkVG9rZW4oKTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIHJldHVybiB7XHJcblx0ICAgICAgICAgICAgdHlwZTogOCAvKiBTdHJpbmdMaXRlcmFsICovLFxyXG5cdCAgICAgICAgICAgIHZhbHVlOiBzdHIsXHJcblx0ICAgICAgICAgICAgb2N0YWw6IG9jdGFsLFxyXG5cdCAgICAgICAgICAgIGxpbmVOdW1iZXI6IHRoaXMubGluZU51bWJlcixcclxuXHQgICAgICAgICAgICBsaW5lU3RhcnQ6IHRoaXMubGluZVN0YXJ0LFxyXG5cdCAgICAgICAgICAgIHN0YXJ0OiBzdGFydCxcclxuXHQgICAgICAgICAgICBlbmQ6IHRoaXMuaW5kZXhcclxuXHQgICAgICAgIH07XHJcblx0ICAgIH07XHJcblx0ICAgIC8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLXRlbXBsYXRlLWxpdGVyYWwtbGV4aWNhbC1jb21wb25lbnRzXHJcblx0ICAgIFNjYW5uZXIucHJvdG90eXBlLnNjYW5UZW1wbGF0ZSA9IGZ1bmN0aW9uICgpIHtcclxuXHQgICAgICAgIHZhciBjb29rZWQgPSAnJztcclxuXHQgICAgICAgIHZhciB0ZXJtaW5hdGVkID0gZmFsc2U7XHJcblx0ICAgICAgICB2YXIgc3RhcnQgPSB0aGlzLmluZGV4O1xyXG5cdCAgICAgICAgdmFyIGhlYWQgPSAodGhpcy5zb3VyY2Vbc3RhcnRdID09PSAnYCcpO1xyXG5cdCAgICAgICAgdmFyIHRhaWwgPSBmYWxzZTtcclxuXHQgICAgICAgIHZhciByYXdPZmZzZXQgPSAyO1xyXG5cdCAgICAgICAgKyt0aGlzLmluZGV4O1xyXG5cdCAgICAgICAgd2hpbGUgKCF0aGlzLmVvZigpKSB7XHJcblx0ICAgICAgICAgICAgdmFyIGNoID0gdGhpcy5zb3VyY2VbdGhpcy5pbmRleCsrXTtcclxuXHQgICAgICAgICAgICBpZiAoY2ggPT09ICdgJykge1xyXG5cdCAgICAgICAgICAgICAgICByYXdPZmZzZXQgPSAxO1xyXG5cdCAgICAgICAgICAgICAgICB0YWlsID0gdHJ1ZTtcclxuXHQgICAgICAgICAgICAgICAgdGVybWluYXRlZCA9IHRydWU7XHJcblx0ICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICBlbHNlIGlmIChjaCA9PT0gJyQnKSB7XHJcblx0ICAgICAgICAgICAgICAgIGlmICh0aGlzLnNvdXJjZVt0aGlzLmluZGV4XSA9PT0gJ3snKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICB0aGlzLmN1cmx5U3RhY2sucHVzaCgnJHsnKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICsrdGhpcy5pbmRleDtcclxuXHQgICAgICAgICAgICAgICAgICAgIHRlcm1pbmF0ZWQgPSB0cnVlO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcblx0ICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgY29va2VkICs9IGNoO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICBlbHNlIGlmIChjaCA9PT0gJ1xcXFwnKSB7XHJcblx0ICAgICAgICAgICAgICAgIGNoID0gdGhpcy5zb3VyY2VbdGhpcy5pbmRleCsrXTtcclxuXHQgICAgICAgICAgICAgICAgaWYgKCFjaGFyYWN0ZXJfMS5DaGFyYWN0ZXIuaXNMaW5lVGVybWluYXRvcihjaC5jaGFyQ29kZUF0KDApKSkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChjaCkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ24nOlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb29rZWQgKz0gJ1xcbic7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ3InOlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb29rZWQgKz0gJ1xccic7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ3QnOlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb29rZWQgKz0gJ1xcdCc7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ3UnOlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5zb3VyY2VbdGhpcy5pbmRleF0gPT09ICd7Jykge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKyt0aGlzLmluZGV4O1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29va2VkICs9IHRoaXMuc2NhblVuaWNvZGVDb2RlUG9pbnRFc2NhcGUoKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciByZXN0b3JlID0gdGhpcy5pbmRleDtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB1bmVzY2FwZWRfMiA9IHRoaXMuc2NhbkhleEVzY2FwZShjaCk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodW5lc2NhcGVkXzIgIT09IG51bGwpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb29rZWQgKz0gdW5lc2NhcGVkXzI7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmluZGV4ID0gcmVzdG9yZTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb29rZWQgKz0gY2g7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAneCc6XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB1bmVzY2FwZWQgPSB0aGlzLnNjYW5IZXhFc2NhcGUoY2gpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodW5lc2NhcGVkID09PSBudWxsKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnRocm93VW5leHBlY3RlZFRva2VuKG1lc3NhZ2VzXzEuTWVzc2FnZXMuSW52YWxpZEhleEVzY2FwZVNlcXVlbmNlKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb29rZWQgKz0gdW5lc2NhcGVkO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBjYXNlICdiJzpcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29va2VkICs9ICdcXGInO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBjYXNlICdmJzpcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29va2VkICs9ICdcXGYnO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBjYXNlICd2JzpcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29va2VkICs9ICdcXHYnO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoY2ggPT09ICcwJykge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNoYXJhY3Rlcl8xLkNoYXJhY3Rlci5pc0RlY2ltYWxEaWdpdCh0aGlzLnNvdXJjZS5jaGFyQ29kZUF0KHRoaXMuaW5kZXgpKSkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIElsbGVnYWw6IFxcMDEgXFwwMiBhbmQgc28gb25cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnRocm93VW5leHBlY3RlZFRva2VuKG1lc3NhZ2VzXzEuTWVzc2FnZXMuVGVtcGxhdGVPY3RhbExpdGVyYWwpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29va2VkICs9ICdcXDAnO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGNoYXJhY3Rlcl8xLkNoYXJhY3Rlci5pc09jdGFsRGlnaXQoY2guY2hhckNvZGVBdCgwKSkpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIElsbGVnYWw6IFxcMSBcXDJcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMudGhyb3dVbmV4cGVjdGVkVG9rZW4obWVzc2FnZXNfMS5NZXNzYWdlcy5UZW1wbGF0ZU9jdGFsTGl0ZXJhbCk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb29rZWQgKz0gY2g7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcblx0ICAgICAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgZWxzZSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICArK3RoaXMubGluZU51bWJlcjtcclxuXHQgICAgICAgICAgICAgICAgICAgIGlmIChjaCA9PT0gJ1xccicgJiYgdGhpcy5zb3VyY2VbdGhpcy5pbmRleF0gPT09ICdcXG4nKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgKyt0aGlzLmluZGV4O1xyXG5cdCAgICAgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICAgICAgdGhpcy5saW5lU3RhcnQgPSB0aGlzLmluZGV4O1xyXG5cdCAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgIGVsc2UgaWYgKGNoYXJhY3Rlcl8xLkNoYXJhY3Rlci5pc0xpbmVUZXJtaW5hdG9yKGNoLmNoYXJDb2RlQXQoMCkpKSB7XHJcblx0ICAgICAgICAgICAgICAgICsrdGhpcy5saW5lTnVtYmVyO1xyXG5cdCAgICAgICAgICAgICAgICBpZiAoY2ggPT09ICdcXHInICYmIHRoaXMuc291cmNlW3RoaXMuaW5kZXhdID09PSAnXFxuJykge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgKyt0aGlzLmluZGV4O1xyXG5cdCAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgIHRoaXMubGluZVN0YXJ0ID0gdGhpcy5pbmRleDtcclxuXHQgICAgICAgICAgICAgICAgY29va2VkICs9ICdcXG4nO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICBlbHNlIHtcclxuXHQgICAgICAgICAgICAgICAgY29va2VkICs9IGNoO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIGlmICghdGVybWluYXRlZCkge1xyXG5cdCAgICAgICAgICAgIHRoaXMudGhyb3dVbmV4cGVjdGVkVG9rZW4oKTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIGlmICghaGVhZCkge1xyXG5cdCAgICAgICAgICAgIHRoaXMuY3VybHlTdGFjay5wb3AoKTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIHJldHVybiB7XHJcblx0ICAgICAgICAgICAgdHlwZTogMTAgLyogVGVtcGxhdGUgKi8sXHJcblx0ICAgICAgICAgICAgdmFsdWU6IHRoaXMuc291cmNlLnNsaWNlKHN0YXJ0ICsgMSwgdGhpcy5pbmRleCAtIHJhd09mZnNldCksXHJcblx0ICAgICAgICAgICAgY29va2VkOiBjb29rZWQsXHJcblx0ICAgICAgICAgICAgaGVhZDogaGVhZCxcclxuXHQgICAgICAgICAgICB0YWlsOiB0YWlsLFxyXG5cdCAgICAgICAgICAgIGxpbmVOdW1iZXI6IHRoaXMubGluZU51bWJlcixcclxuXHQgICAgICAgICAgICBsaW5lU3RhcnQ6IHRoaXMubGluZVN0YXJ0LFxyXG5cdCAgICAgICAgICAgIHN0YXJ0OiBzdGFydCxcclxuXHQgICAgICAgICAgICBlbmQ6IHRoaXMuaW5kZXhcclxuXHQgICAgICAgIH07XHJcblx0ICAgIH07XHJcblx0ICAgIC8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLWxpdGVyYWxzLXJlZ3VsYXItZXhwcmVzc2lvbi1saXRlcmFsc1xyXG5cdCAgICBTY2FubmVyLnByb3RvdHlwZS50ZXN0UmVnRXhwID0gZnVuY3Rpb24gKHBhdHRlcm4sIGZsYWdzKSB7XHJcblx0ICAgICAgICAvLyBUaGUgQk1QIGNoYXJhY3RlciB0byB1c2UgYXMgYSByZXBsYWNlbWVudCBmb3IgYXN0cmFsIHN5bWJvbHMgd2hlblxyXG5cdCAgICAgICAgLy8gdHJhbnNsYXRpbmcgYW4gRVM2IFwidVwiLWZsYWdnZWQgcGF0dGVybiB0byBhbiBFUzUtY29tcGF0aWJsZVxyXG5cdCAgICAgICAgLy8gYXBwcm94aW1hdGlvbi5cclxuXHQgICAgICAgIC8vIE5vdGU6IHJlcGxhY2luZyB3aXRoICdcXHVGRkZGJyBlbmFibGVzIGZhbHNlIHBvc2l0aXZlcyBpbiB1bmxpa2VseVxyXG5cdCAgICAgICAgLy8gc2NlbmFyaW9zLiBGb3IgZXhhbXBsZSwgYFtcXHV7MTA0NGZ9LVxcdXsxMDQ0MH1dYCBpcyBhbiBpbnZhbGlkXHJcblx0ICAgICAgICAvLyBwYXR0ZXJuIHRoYXQgd291bGQgbm90IGJlIGRldGVjdGVkIGJ5IHRoaXMgc3Vic3RpdHV0aW9uLlxyXG5cdCAgICAgICAgdmFyIGFzdHJhbFN1YnN0aXR1dGUgPSAnXFx1RkZGRic7XHJcblx0ICAgICAgICB2YXIgdG1wID0gcGF0dGVybjtcclxuXHQgICAgICAgIHZhciBzZWxmID0gdGhpcztcclxuXHQgICAgICAgIGlmIChmbGFncy5pbmRleE9mKCd1JykgPj0gMCkge1xyXG5cdCAgICAgICAgICAgIHRtcCA9IHRtcFxyXG5cdCAgICAgICAgICAgICAgICAucmVwbGFjZSgvXFxcXHVcXHsoWzAtOWEtZkEtRl0rKVxcfXxcXFxcdShbYS1mQS1GMC05XXs0fSkvZywgZnVuY3Rpb24gKCQwLCAkMSwgJDIpIHtcclxuXHQgICAgICAgICAgICAgICAgdmFyIGNvZGVQb2ludCA9IHBhcnNlSW50KCQxIHx8ICQyLCAxNik7XHJcblx0ICAgICAgICAgICAgICAgIGlmIChjb2RlUG9pbnQgPiAweDEwRkZGRikge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgc2VsZi50aHJvd1VuZXhwZWN0ZWRUb2tlbihtZXNzYWdlc18xLk1lc3NhZ2VzLkludmFsaWRSZWdFeHApO1xyXG5cdCAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgIGlmIChjb2RlUG9pbnQgPD0gMHhGRkZGKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZShjb2RlUG9pbnQpO1xyXG5cdCAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgIHJldHVybiBhc3RyYWxTdWJzdGl0dXRlO1xyXG5cdCAgICAgICAgICAgIH0pXHJcblx0ICAgICAgICAgICAgICAgIC5yZXBsYWNlKC9bXFx1RDgwMC1cXHVEQkZGXVtcXHVEQzAwLVxcdURGRkZdL2csIGFzdHJhbFN1YnN0aXR1dGUpO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgLy8gRmlyc3QsIGRldGVjdCBpbnZhbGlkIHJlZ3VsYXIgZXhwcmVzc2lvbnMuXHJcblx0ICAgICAgICB0cnkge1xyXG5cdCAgICAgICAgICAgIFJlZ0V4cCh0bXApO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgY2F0Y2ggKGUpIHtcclxuXHQgICAgICAgICAgICB0aGlzLnRocm93VW5leHBlY3RlZFRva2VuKG1lc3NhZ2VzXzEuTWVzc2FnZXMuSW52YWxpZFJlZ0V4cCk7XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICAvLyBSZXR1cm4gYSByZWd1bGFyIGV4cHJlc3Npb24gb2JqZWN0IGZvciB0aGlzIHBhdHRlcm4tZmxhZyBwYWlyLCBvclxyXG5cdCAgICAgICAgLy8gYG51bGxgIGluIGNhc2UgdGhlIGN1cnJlbnQgZW52aXJvbm1lbnQgZG9lc24ndCBzdXBwb3J0IHRoZSBmbGFncyBpdFxyXG5cdCAgICAgICAgLy8gdXNlcy5cclxuXHQgICAgICAgIHRyeSB7XHJcblx0ICAgICAgICAgICAgcmV0dXJuIG5ldyBSZWdFeHAocGF0dGVybiwgZmxhZ3MpO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgY2F0Y2ggKGV4Y2VwdGlvbikge1xyXG5cdCAgICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXHJcblx0ICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcblx0ICAgICAgICB9XHJcblx0ICAgIH07XHJcblx0ICAgIFNjYW5uZXIucHJvdG90eXBlLnNjYW5SZWdFeHBCb2R5ID0gZnVuY3Rpb24gKCkge1xyXG5cdCAgICAgICAgdmFyIGNoID0gdGhpcy5zb3VyY2VbdGhpcy5pbmRleF07XHJcblx0ICAgICAgICBhc3NlcnRfMS5hc3NlcnQoY2ggPT09ICcvJywgJ1JlZ3VsYXIgZXhwcmVzc2lvbiBsaXRlcmFsIG11c3Qgc3RhcnQgd2l0aCBhIHNsYXNoJyk7XHJcblx0ICAgICAgICB2YXIgc3RyID0gdGhpcy5zb3VyY2VbdGhpcy5pbmRleCsrXTtcclxuXHQgICAgICAgIHZhciBjbGFzc01hcmtlciA9IGZhbHNlO1xyXG5cdCAgICAgICAgdmFyIHRlcm1pbmF0ZWQgPSBmYWxzZTtcclxuXHQgICAgICAgIHdoaWxlICghdGhpcy5lb2YoKSkge1xyXG5cdCAgICAgICAgICAgIGNoID0gdGhpcy5zb3VyY2VbdGhpcy5pbmRleCsrXTtcclxuXHQgICAgICAgICAgICBzdHIgKz0gY2g7XHJcblx0ICAgICAgICAgICAgaWYgKGNoID09PSAnXFxcXCcpIHtcclxuXHQgICAgICAgICAgICAgICAgY2ggPSB0aGlzLnNvdXJjZVt0aGlzLmluZGV4KytdO1xyXG5cdCAgICAgICAgICAgICAgICAvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1saXRlcmFscy1yZWd1bGFyLWV4cHJlc3Npb24tbGl0ZXJhbHNcclxuXHQgICAgICAgICAgICAgICAgaWYgKGNoYXJhY3Rlcl8xLkNoYXJhY3Rlci5pc0xpbmVUZXJtaW5hdG9yKGNoLmNoYXJDb2RlQXQoMCkpKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICB0aGlzLnRocm93VW5leHBlY3RlZFRva2VuKG1lc3NhZ2VzXzEuTWVzc2FnZXMuVW50ZXJtaW5hdGVkUmVnRXhwKTtcclxuXHQgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICBzdHIgKz0gY2g7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgIGVsc2UgaWYgKGNoYXJhY3Rlcl8xLkNoYXJhY3Rlci5pc0xpbmVUZXJtaW5hdG9yKGNoLmNoYXJDb2RlQXQoMCkpKSB7XHJcblx0ICAgICAgICAgICAgICAgIHRoaXMudGhyb3dVbmV4cGVjdGVkVG9rZW4obWVzc2FnZXNfMS5NZXNzYWdlcy5VbnRlcm1pbmF0ZWRSZWdFeHApO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICBlbHNlIGlmIChjbGFzc01hcmtlcikge1xyXG5cdCAgICAgICAgICAgICAgICBpZiAoY2ggPT09ICddJykge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgY2xhc3NNYXJrZXIgPSBmYWxzZTtcclxuXHQgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICBlbHNlIHtcclxuXHQgICAgICAgICAgICAgICAgaWYgKGNoID09PSAnLycpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgIHRlcm1pbmF0ZWQgPSB0cnVlO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcblx0ICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgZWxzZSBpZiAoY2ggPT09ICdbJykge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgY2xhc3NNYXJrZXIgPSB0cnVlO1xyXG5cdCAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgaWYgKCF0ZXJtaW5hdGVkKSB7XHJcblx0ICAgICAgICAgICAgdGhpcy50aHJvd1VuZXhwZWN0ZWRUb2tlbihtZXNzYWdlc18xLk1lc3NhZ2VzLlVudGVybWluYXRlZFJlZ0V4cCk7XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICAvLyBFeGNsdWRlIGxlYWRpbmcgYW5kIHRyYWlsaW5nIHNsYXNoLlxyXG5cdCAgICAgICAgcmV0dXJuIHN0ci5zdWJzdHIoMSwgc3RyLmxlbmd0aCAtIDIpO1xyXG5cdCAgICB9O1xyXG5cdCAgICBTY2FubmVyLnByb3RvdHlwZS5zY2FuUmVnRXhwRmxhZ3MgPSBmdW5jdGlvbiAoKSB7XHJcblx0ICAgICAgICB2YXIgc3RyID0gJyc7XHJcblx0ICAgICAgICB2YXIgZmxhZ3MgPSAnJztcclxuXHQgICAgICAgIHdoaWxlICghdGhpcy5lb2YoKSkge1xyXG5cdCAgICAgICAgICAgIHZhciBjaCA9IHRoaXMuc291cmNlW3RoaXMuaW5kZXhdO1xyXG5cdCAgICAgICAgICAgIGlmICghY2hhcmFjdGVyXzEuQ2hhcmFjdGVyLmlzSWRlbnRpZmllclBhcnQoY2guY2hhckNvZGVBdCgwKSkpIHtcclxuXHQgICAgICAgICAgICAgICAgYnJlYWs7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICsrdGhpcy5pbmRleDtcclxuXHQgICAgICAgICAgICBpZiAoY2ggPT09ICdcXFxcJyAmJiAhdGhpcy5lb2YoKSkge1xyXG5cdCAgICAgICAgICAgICAgICBjaCA9IHRoaXMuc291cmNlW3RoaXMuaW5kZXhdO1xyXG5cdCAgICAgICAgICAgICAgICBpZiAoY2ggPT09ICd1Jykge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgKyt0aGlzLmluZGV4O1xyXG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIHJlc3RvcmUgPSB0aGlzLmluZGV4O1xyXG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIGNoYXIgPSB0aGlzLnNjYW5IZXhFc2NhcGUoJ3UnKTtcclxuXHQgICAgICAgICAgICAgICAgICAgIGlmIChjaGFyICE9PSBudWxsKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgZmxhZ3MgKz0gY2hhcjtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHN0ciArPSAnXFxcXHUnOyByZXN0b3JlIDwgdGhpcy5pbmRleDsgKytyZXN0b3JlKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0ciArPSB0aGlzLnNvdXJjZVtyZXN0b3JlXTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmluZGV4ID0gcmVzdG9yZTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBmbGFncyArPSAndSc7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgc3RyICs9ICdcXFxcdSc7XHJcblx0ICAgICAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgICAgICB0aGlzLnRvbGVyYXRlVW5leHBlY3RlZFRva2VuKCk7XHJcblx0ICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgZWxzZSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICBzdHIgKz0gJ1xcXFwnO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgdGhpcy50b2xlcmF0ZVVuZXhwZWN0ZWRUb2tlbigpO1xyXG5cdCAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgIGVsc2Uge1xyXG5cdCAgICAgICAgICAgICAgICBmbGFncyArPSBjaDtcclxuXHQgICAgICAgICAgICAgICAgc3RyICs9IGNoO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIHJldHVybiBmbGFncztcclxuXHQgICAgfTtcclxuXHQgICAgU2Nhbm5lci5wcm90b3R5cGUuc2NhblJlZ0V4cCA9IGZ1bmN0aW9uICgpIHtcclxuXHQgICAgICAgIHZhciBzdGFydCA9IHRoaXMuaW5kZXg7XHJcblx0ICAgICAgICB2YXIgcGF0dGVybiA9IHRoaXMuc2NhblJlZ0V4cEJvZHkoKTtcclxuXHQgICAgICAgIHZhciBmbGFncyA9IHRoaXMuc2NhblJlZ0V4cEZsYWdzKCk7XHJcblx0ICAgICAgICB2YXIgdmFsdWUgPSB0aGlzLnRlc3RSZWdFeHAocGF0dGVybiwgZmxhZ3MpO1xyXG5cdCAgICAgICAgcmV0dXJuIHtcclxuXHQgICAgICAgICAgICB0eXBlOiA5IC8qIFJlZ3VsYXJFeHByZXNzaW9uICovLFxyXG5cdCAgICAgICAgICAgIHZhbHVlOiAnJyxcclxuXHQgICAgICAgICAgICBwYXR0ZXJuOiBwYXR0ZXJuLFxyXG5cdCAgICAgICAgICAgIGZsYWdzOiBmbGFncyxcclxuXHQgICAgICAgICAgICByZWdleDogdmFsdWUsXHJcblx0ICAgICAgICAgICAgbGluZU51bWJlcjogdGhpcy5saW5lTnVtYmVyLFxyXG5cdCAgICAgICAgICAgIGxpbmVTdGFydDogdGhpcy5saW5lU3RhcnQsXHJcblx0ICAgICAgICAgICAgc3RhcnQ6IHN0YXJ0LFxyXG5cdCAgICAgICAgICAgIGVuZDogdGhpcy5pbmRleFxyXG5cdCAgICAgICAgfTtcclxuXHQgICAgfTtcclxuXHQgICAgU2Nhbm5lci5wcm90b3R5cGUubGV4ID0gZnVuY3Rpb24gKCkge1xyXG5cdCAgICAgICAgaWYgKHRoaXMuZW9mKCkpIHtcclxuXHQgICAgICAgICAgICByZXR1cm4ge1xyXG5cdCAgICAgICAgICAgICAgICB0eXBlOiAyIC8qIEVPRiAqLyxcclxuXHQgICAgICAgICAgICAgICAgdmFsdWU6ICcnLFxyXG5cdCAgICAgICAgICAgICAgICBsaW5lTnVtYmVyOiB0aGlzLmxpbmVOdW1iZXIsXHJcblx0ICAgICAgICAgICAgICAgIGxpbmVTdGFydDogdGhpcy5saW5lU3RhcnQsXHJcblx0ICAgICAgICAgICAgICAgIHN0YXJ0OiB0aGlzLmluZGV4LFxyXG5cdCAgICAgICAgICAgICAgICBlbmQ6IHRoaXMuaW5kZXhcclxuXHQgICAgICAgICAgICB9O1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgdmFyIGNwID0gdGhpcy5zb3VyY2UuY2hhckNvZGVBdCh0aGlzLmluZGV4KTtcclxuXHQgICAgICAgIGlmIChjaGFyYWN0ZXJfMS5DaGFyYWN0ZXIuaXNJZGVudGlmaWVyU3RhcnQoY3ApKSB7XHJcblx0ICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2NhbklkZW50aWZpZXIoKTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIC8vIFZlcnkgY29tbW9uOiAoIGFuZCApIGFuZCA7XHJcblx0ICAgICAgICBpZiAoY3AgPT09IDB4MjggfHwgY3AgPT09IDB4MjkgfHwgY3AgPT09IDB4M0IpIHtcclxuXHQgICAgICAgICAgICByZXR1cm4gdGhpcy5zY2FuUHVuY3R1YXRvcigpO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgLy8gU3RyaW5nIGxpdGVyYWwgc3RhcnRzIHdpdGggc2luZ2xlIHF1b3RlIChVKzAwMjcpIG9yIGRvdWJsZSBxdW90ZSAoVSswMDIyKS5cclxuXHQgICAgICAgIGlmIChjcCA9PT0gMHgyNyB8fCBjcCA9PT0gMHgyMikge1xyXG5cdCAgICAgICAgICAgIHJldHVybiB0aGlzLnNjYW5TdHJpbmdMaXRlcmFsKCk7XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICAvLyBEb3QgKC4pIFUrMDAyRSBjYW4gYWxzbyBzdGFydCBhIGZsb2F0aW5nLXBvaW50IG51bWJlciwgaGVuY2UgdGhlIG5lZWRcclxuXHQgICAgICAgIC8vIHRvIGNoZWNrIHRoZSBuZXh0IGNoYXJhY3Rlci5cclxuXHQgICAgICAgIGlmIChjcCA9PT0gMHgyRSkge1xyXG5cdCAgICAgICAgICAgIGlmIChjaGFyYWN0ZXJfMS5DaGFyYWN0ZXIuaXNEZWNpbWFsRGlnaXQodGhpcy5zb3VyY2UuY2hhckNvZGVBdCh0aGlzLmluZGV4ICsgMSkpKSB7XHJcblx0ICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnNjYW5OdW1lcmljTGl0ZXJhbCgpO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICByZXR1cm4gdGhpcy5zY2FuUHVuY3R1YXRvcigpO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgaWYgKGNoYXJhY3Rlcl8xLkNoYXJhY3Rlci5pc0RlY2ltYWxEaWdpdChjcCkpIHtcclxuXHQgICAgICAgICAgICByZXR1cm4gdGhpcy5zY2FuTnVtZXJpY0xpdGVyYWwoKTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIC8vIFRlbXBsYXRlIGxpdGVyYWxzIHN0YXJ0IHdpdGggYCAoVSswMDYwKSBmb3IgdGVtcGxhdGUgaGVhZFxyXG5cdCAgICAgICAgLy8gb3IgfSAoVSswMDdEKSBmb3IgdGVtcGxhdGUgbWlkZGxlIG9yIHRlbXBsYXRlIHRhaWwuXHJcblx0ICAgICAgICBpZiAoY3AgPT09IDB4NjAgfHwgKGNwID09PSAweDdEICYmIHRoaXMuY3VybHlTdGFja1t0aGlzLmN1cmx5U3RhY2subGVuZ3RoIC0gMV0gPT09ICckeycpKSB7XHJcblx0ICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2NhblRlbXBsYXRlKCk7XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICAvLyBQb3NzaWJsZSBpZGVudGlmaWVyIHN0YXJ0IGluIGEgc3Vycm9nYXRlIHBhaXIuXHJcblx0ICAgICAgICBpZiAoY3AgPj0gMHhEODAwICYmIGNwIDwgMHhERkZGKSB7XHJcblx0ICAgICAgICAgICAgaWYgKGNoYXJhY3Rlcl8xLkNoYXJhY3Rlci5pc0lkZW50aWZpZXJTdGFydCh0aGlzLmNvZGVQb2ludEF0KHRoaXMuaW5kZXgpKSkge1xyXG5cdCAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5zY2FuSWRlbnRpZmllcigpO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIHJldHVybiB0aGlzLnNjYW5QdW5jdHVhdG9yKCk7XHJcblx0ICAgIH07XHJcblx0ICAgIHJldHVybiBTY2FubmVyO1xyXG5cdH0oKSk7XHJcblx0ZXhwb3J0cy5TY2FubmVyID0gU2Nhbm5lcjtcclxuXG5cbi8qKiovIH0sXG4vKiAxMyAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cblx0XCJ1c2Ugc3RyaWN0XCI7XHJcblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG5cdGV4cG9ydHMuVG9rZW5OYW1lID0ge307XHJcblx0ZXhwb3J0cy5Ub2tlbk5hbWVbMSAvKiBCb29sZWFuTGl0ZXJhbCAqL10gPSAnQm9vbGVhbic7XHJcblx0ZXhwb3J0cy5Ub2tlbk5hbWVbMiAvKiBFT0YgKi9dID0gJzxlbmQ+JztcclxuXHRleHBvcnRzLlRva2VuTmFtZVszIC8qIElkZW50aWZpZXIgKi9dID0gJ0lkZW50aWZpZXInO1xyXG5cdGV4cG9ydHMuVG9rZW5OYW1lWzQgLyogS2V5d29yZCAqL10gPSAnS2V5d29yZCc7XHJcblx0ZXhwb3J0cy5Ub2tlbk5hbWVbNSAvKiBOdWxsTGl0ZXJhbCAqL10gPSAnTnVsbCc7XHJcblx0ZXhwb3J0cy5Ub2tlbk5hbWVbNiAvKiBOdW1lcmljTGl0ZXJhbCAqL10gPSAnTnVtZXJpYyc7XHJcblx0ZXhwb3J0cy5Ub2tlbk5hbWVbNyAvKiBQdW5jdHVhdG9yICovXSA9ICdQdW5jdHVhdG9yJztcclxuXHRleHBvcnRzLlRva2VuTmFtZVs4IC8qIFN0cmluZ0xpdGVyYWwgKi9dID0gJ1N0cmluZyc7XHJcblx0ZXhwb3J0cy5Ub2tlbk5hbWVbOSAvKiBSZWd1bGFyRXhwcmVzc2lvbiAqL10gPSAnUmVndWxhckV4cHJlc3Npb24nO1xyXG5cdGV4cG9ydHMuVG9rZW5OYW1lWzEwIC8qIFRlbXBsYXRlICovXSA9ICdUZW1wbGF0ZSc7XHJcblxuXG4vKioqLyB9LFxuLyogMTQgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG5cdFwidXNlIHN0cmljdFwiO1xyXG5cdC8vIEdlbmVyYXRlZCBieSBnZW5lcmF0ZS14aHRtbC1lbnRpdGllcy5qcy4gRE8gTk9UIE1PRElGWSFcclxuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcblx0ZXhwb3J0cy5YSFRNTEVudGl0aWVzID0ge1xyXG5cdCAgICBxdW90OiAnXFx1MDAyMicsXHJcblx0ICAgIGFtcDogJ1xcdTAwMjYnLFxyXG5cdCAgICBhcG9zOiAnXFx1MDAyNycsXHJcblx0ICAgIGd0OiAnXFx1MDAzRScsXHJcblx0ICAgIG5ic3A6ICdcXHUwMEEwJyxcclxuXHQgICAgaWV4Y2w6ICdcXHUwMEExJyxcclxuXHQgICAgY2VudDogJ1xcdTAwQTInLFxyXG5cdCAgICBwb3VuZDogJ1xcdTAwQTMnLFxyXG5cdCAgICBjdXJyZW46ICdcXHUwMEE0JyxcclxuXHQgICAgeWVuOiAnXFx1MDBBNScsXHJcblx0ICAgIGJydmJhcjogJ1xcdTAwQTYnLFxyXG5cdCAgICBzZWN0OiAnXFx1MDBBNycsXHJcblx0ICAgIHVtbDogJ1xcdTAwQTgnLFxyXG5cdCAgICBjb3B5OiAnXFx1MDBBOScsXHJcblx0ICAgIG9yZGY6ICdcXHUwMEFBJyxcclxuXHQgICAgbGFxdW86ICdcXHUwMEFCJyxcclxuXHQgICAgbm90OiAnXFx1MDBBQycsXHJcblx0ICAgIHNoeTogJ1xcdTAwQUQnLFxyXG5cdCAgICByZWc6ICdcXHUwMEFFJyxcclxuXHQgICAgbWFjcjogJ1xcdTAwQUYnLFxyXG5cdCAgICBkZWc6ICdcXHUwMEIwJyxcclxuXHQgICAgcGx1c21uOiAnXFx1MDBCMScsXHJcblx0ICAgIHN1cDI6ICdcXHUwMEIyJyxcclxuXHQgICAgc3VwMzogJ1xcdTAwQjMnLFxyXG5cdCAgICBhY3V0ZTogJ1xcdTAwQjQnLFxyXG5cdCAgICBtaWNybzogJ1xcdTAwQjUnLFxyXG5cdCAgICBwYXJhOiAnXFx1MDBCNicsXHJcblx0ICAgIG1pZGRvdDogJ1xcdTAwQjcnLFxyXG5cdCAgICBjZWRpbDogJ1xcdTAwQjgnLFxyXG5cdCAgICBzdXAxOiAnXFx1MDBCOScsXHJcblx0ICAgIG9yZG06ICdcXHUwMEJBJyxcclxuXHQgICAgcmFxdW86ICdcXHUwMEJCJyxcclxuXHQgICAgZnJhYzE0OiAnXFx1MDBCQycsXHJcblx0ICAgIGZyYWMxMjogJ1xcdTAwQkQnLFxyXG5cdCAgICBmcmFjMzQ6ICdcXHUwMEJFJyxcclxuXHQgICAgaXF1ZXN0OiAnXFx1MDBCRicsXHJcblx0ICAgIEFncmF2ZTogJ1xcdTAwQzAnLFxyXG5cdCAgICBBYWN1dGU6ICdcXHUwMEMxJyxcclxuXHQgICAgQWNpcmM6ICdcXHUwMEMyJyxcclxuXHQgICAgQXRpbGRlOiAnXFx1MDBDMycsXHJcblx0ICAgIEF1bWw6ICdcXHUwMEM0JyxcclxuXHQgICAgQXJpbmc6ICdcXHUwMEM1JyxcclxuXHQgICAgQUVsaWc6ICdcXHUwMEM2JyxcclxuXHQgICAgQ2NlZGlsOiAnXFx1MDBDNycsXHJcblx0ICAgIEVncmF2ZTogJ1xcdTAwQzgnLFxyXG5cdCAgICBFYWN1dGU6ICdcXHUwMEM5JyxcclxuXHQgICAgRWNpcmM6ICdcXHUwMENBJyxcclxuXHQgICAgRXVtbDogJ1xcdTAwQ0InLFxyXG5cdCAgICBJZ3JhdmU6ICdcXHUwMENDJyxcclxuXHQgICAgSWFjdXRlOiAnXFx1MDBDRCcsXHJcblx0ICAgIEljaXJjOiAnXFx1MDBDRScsXHJcblx0ICAgIEl1bWw6ICdcXHUwMENGJyxcclxuXHQgICAgRVRIOiAnXFx1MDBEMCcsXHJcblx0ICAgIE50aWxkZTogJ1xcdTAwRDEnLFxyXG5cdCAgICBPZ3JhdmU6ICdcXHUwMEQyJyxcclxuXHQgICAgT2FjdXRlOiAnXFx1MDBEMycsXHJcblx0ICAgIE9jaXJjOiAnXFx1MDBENCcsXHJcblx0ICAgIE90aWxkZTogJ1xcdTAwRDUnLFxyXG5cdCAgICBPdW1sOiAnXFx1MDBENicsXHJcblx0ICAgIHRpbWVzOiAnXFx1MDBENycsXHJcblx0ICAgIE9zbGFzaDogJ1xcdTAwRDgnLFxyXG5cdCAgICBVZ3JhdmU6ICdcXHUwMEQ5JyxcclxuXHQgICAgVWFjdXRlOiAnXFx1MDBEQScsXHJcblx0ICAgIFVjaXJjOiAnXFx1MDBEQicsXHJcblx0ICAgIFV1bWw6ICdcXHUwMERDJyxcclxuXHQgICAgWWFjdXRlOiAnXFx1MDBERCcsXHJcblx0ICAgIFRIT1JOOiAnXFx1MDBERScsXHJcblx0ICAgIHN6bGlnOiAnXFx1MDBERicsXHJcblx0ICAgIGFncmF2ZTogJ1xcdTAwRTAnLFxyXG5cdCAgICBhYWN1dGU6ICdcXHUwMEUxJyxcclxuXHQgICAgYWNpcmM6ICdcXHUwMEUyJyxcclxuXHQgICAgYXRpbGRlOiAnXFx1MDBFMycsXHJcblx0ICAgIGF1bWw6ICdcXHUwMEU0JyxcclxuXHQgICAgYXJpbmc6ICdcXHUwMEU1JyxcclxuXHQgICAgYWVsaWc6ICdcXHUwMEU2JyxcclxuXHQgICAgY2NlZGlsOiAnXFx1MDBFNycsXHJcblx0ICAgIGVncmF2ZTogJ1xcdTAwRTgnLFxyXG5cdCAgICBlYWN1dGU6ICdcXHUwMEU5JyxcclxuXHQgICAgZWNpcmM6ICdcXHUwMEVBJyxcclxuXHQgICAgZXVtbDogJ1xcdTAwRUInLFxyXG5cdCAgICBpZ3JhdmU6ICdcXHUwMEVDJyxcclxuXHQgICAgaWFjdXRlOiAnXFx1MDBFRCcsXHJcblx0ICAgIGljaXJjOiAnXFx1MDBFRScsXHJcblx0ICAgIGl1bWw6ICdcXHUwMEVGJyxcclxuXHQgICAgZXRoOiAnXFx1MDBGMCcsXHJcblx0ICAgIG50aWxkZTogJ1xcdTAwRjEnLFxyXG5cdCAgICBvZ3JhdmU6ICdcXHUwMEYyJyxcclxuXHQgICAgb2FjdXRlOiAnXFx1MDBGMycsXHJcblx0ICAgIG9jaXJjOiAnXFx1MDBGNCcsXHJcblx0ICAgIG90aWxkZTogJ1xcdTAwRjUnLFxyXG5cdCAgICBvdW1sOiAnXFx1MDBGNicsXHJcblx0ICAgIGRpdmlkZTogJ1xcdTAwRjcnLFxyXG5cdCAgICBvc2xhc2g6ICdcXHUwMEY4JyxcclxuXHQgICAgdWdyYXZlOiAnXFx1MDBGOScsXHJcblx0ICAgIHVhY3V0ZTogJ1xcdTAwRkEnLFxyXG5cdCAgICB1Y2lyYzogJ1xcdTAwRkInLFxyXG5cdCAgICB1dW1sOiAnXFx1MDBGQycsXHJcblx0ICAgIHlhY3V0ZTogJ1xcdTAwRkQnLFxyXG5cdCAgICB0aG9ybjogJ1xcdTAwRkUnLFxyXG5cdCAgICB5dW1sOiAnXFx1MDBGRicsXHJcblx0ICAgIE9FbGlnOiAnXFx1MDE1MicsXHJcblx0ICAgIG9lbGlnOiAnXFx1MDE1MycsXHJcblx0ICAgIFNjYXJvbjogJ1xcdTAxNjAnLFxyXG5cdCAgICBzY2Fyb246ICdcXHUwMTYxJyxcclxuXHQgICAgWXVtbDogJ1xcdTAxNzgnLFxyXG5cdCAgICBmbm9mOiAnXFx1MDE5MicsXHJcblx0ICAgIGNpcmM6ICdcXHUwMkM2JyxcclxuXHQgICAgdGlsZGU6ICdcXHUwMkRDJyxcclxuXHQgICAgQWxwaGE6ICdcXHUwMzkxJyxcclxuXHQgICAgQmV0YTogJ1xcdTAzOTInLFxyXG5cdCAgICBHYW1tYTogJ1xcdTAzOTMnLFxyXG5cdCAgICBEZWx0YTogJ1xcdTAzOTQnLFxyXG5cdCAgICBFcHNpbG9uOiAnXFx1MDM5NScsXHJcblx0ICAgIFpldGE6ICdcXHUwMzk2JyxcclxuXHQgICAgRXRhOiAnXFx1MDM5NycsXHJcblx0ICAgIFRoZXRhOiAnXFx1MDM5OCcsXHJcblx0ICAgIElvdGE6ICdcXHUwMzk5JyxcclxuXHQgICAgS2FwcGE6ICdcXHUwMzlBJyxcclxuXHQgICAgTGFtYmRhOiAnXFx1MDM5QicsXHJcblx0ICAgIE11OiAnXFx1MDM5QycsXHJcblx0ICAgIE51OiAnXFx1MDM5RCcsXHJcblx0ICAgIFhpOiAnXFx1MDM5RScsXHJcblx0ICAgIE9taWNyb246ICdcXHUwMzlGJyxcclxuXHQgICAgUGk6ICdcXHUwM0EwJyxcclxuXHQgICAgUmhvOiAnXFx1MDNBMScsXHJcblx0ICAgIFNpZ21hOiAnXFx1MDNBMycsXHJcblx0ICAgIFRhdTogJ1xcdTAzQTQnLFxyXG5cdCAgICBVcHNpbG9uOiAnXFx1MDNBNScsXHJcblx0ICAgIFBoaTogJ1xcdTAzQTYnLFxyXG5cdCAgICBDaGk6ICdcXHUwM0E3JyxcclxuXHQgICAgUHNpOiAnXFx1MDNBOCcsXHJcblx0ICAgIE9tZWdhOiAnXFx1MDNBOScsXHJcblx0ICAgIGFscGhhOiAnXFx1MDNCMScsXHJcblx0ICAgIGJldGE6ICdcXHUwM0IyJyxcclxuXHQgICAgZ2FtbWE6ICdcXHUwM0IzJyxcclxuXHQgICAgZGVsdGE6ICdcXHUwM0I0JyxcclxuXHQgICAgZXBzaWxvbjogJ1xcdTAzQjUnLFxyXG5cdCAgICB6ZXRhOiAnXFx1MDNCNicsXHJcblx0ICAgIGV0YTogJ1xcdTAzQjcnLFxyXG5cdCAgICB0aGV0YTogJ1xcdTAzQjgnLFxyXG5cdCAgICBpb3RhOiAnXFx1MDNCOScsXHJcblx0ICAgIGthcHBhOiAnXFx1MDNCQScsXHJcblx0ICAgIGxhbWJkYTogJ1xcdTAzQkInLFxyXG5cdCAgICBtdTogJ1xcdTAzQkMnLFxyXG5cdCAgICBudTogJ1xcdTAzQkQnLFxyXG5cdCAgICB4aTogJ1xcdTAzQkUnLFxyXG5cdCAgICBvbWljcm9uOiAnXFx1MDNCRicsXHJcblx0ICAgIHBpOiAnXFx1MDNDMCcsXHJcblx0ICAgIHJobzogJ1xcdTAzQzEnLFxyXG5cdCAgICBzaWdtYWY6ICdcXHUwM0MyJyxcclxuXHQgICAgc2lnbWE6ICdcXHUwM0MzJyxcclxuXHQgICAgdGF1OiAnXFx1MDNDNCcsXHJcblx0ICAgIHVwc2lsb246ICdcXHUwM0M1JyxcclxuXHQgICAgcGhpOiAnXFx1MDNDNicsXHJcblx0ICAgIGNoaTogJ1xcdTAzQzcnLFxyXG5cdCAgICBwc2k6ICdcXHUwM0M4JyxcclxuXHQgICAgb21lZ2E6ICdcXHUwM0M5JyxcclxuXHQgICAgdGhldGFzeW06ICdcXHUwM0QxJyxcclxuXHQgICAgdXBzaWg6ICdcXHUwM0QyJyxcclxuXHQgICAgcGl2OiAnXFx1MDNENicsXHJcblx0ICAgIGVuc3A6ICdcXHUyMDAyJyxcclxuXHQgICAgZW1zcDogJ1xcdTIwMDMnLFxyXG5cdCAgICB0aGluc3A6ICdcXHUyMDA5JyxcclxuXHQgICAgenduajogJ1xcdTIwMEMnLFxyXG5cdCAgICB6d2o6ICdcXHUyMDBEJyxcclxuXHQgICAgbHJtOiAnXFx1MjAwRScsXHJcblx0ICAgIHJsbTogJ1xcdTIwMEYnLFxyXG5cdCAgICBuZGFzaDogJ1xcdTIwMTMnLFxyXG5cdCAgICBtZGFzaDogJ1xcdTIwMTQnLFxyXG5cdCAgICBsc3F1bzogJ1xcdTIwMTgnLFxyXG5cdCAgICByc3F1bzogJ1xcdTIwMTknLFxyXG5cdCAgICBzYnF1bzogJ1xcdTIwMUEnLFxyXG5cdCAgICBsZHF1bzogJ1xcdTIwMUMnLFxyXG5cdCAgICByZHF1bzogJ1xcdTIwMUQnLFxyXG5cdCAgICBiZHF1bzogJ1xcdTIwMUUnLFxyXG5cdCAgICBkYWdnZXI6ICdcXHUyMDIwJyxcclxuXHQgICAgRGFnZ2VyOiAnXFx1MjAyMScsXHJcblx0ICAgIGJ1bGw6ICdcXHUyMDIyJyxcclxuXHQgICAgaGVsbGlwOiAnXFx1MjAyNicsXHJcblx0ICAgIHBlcm1pbDogJ1xcdTIwMzAnLFxyXG5cdCAgICBwcmltZTogJ1xcdTIwMzInLFxyXG5cdCAgICBQcmltZTogJ1xcdTIwMzMnLFxyXG5cdCAgICBsc2FxdW86ICdcXHUyMDM5JyxcclxuXHQgICAgcnNhcXVvOiAnXFx1MjAzQScsXHJcblx0ICAgIG9saW5lOiAnXFx1MjAzRScsXHJcblx0ICAgIGZyYXNsOiAnXFx1MjA0NCcsXHJcblx0ICAgIGV1cm86ICdcXHUyMEFDJyxcclxuXHQgICAgaW1hZ2U6ICdcXHUyMTExJyxcclxuXHQgICAgd2VpZXJwOiAnXFx1MjExOCcsXHJcblx0ICAgIHJlYWw6ICdcXHUyMTFDJyxcclxuXHQgICAgdHJhZGU6ICdcXHUyMTIyJyxcclxuXHQgICAgYWxlZnN5bTogJ1xcdTIxMzUnLFxyXG5cdCAgICBsYXJyOiAnXFx1MjE5MCcsXHJcblx0ICAgIHVhcnI6ICdcXHUyMTkxJyxcclxuXHQgICAgcmFycjogJ1xcdTIxOTInLFxyXG5cdCAgICBkYXJyOiAnXFx1MjE5MycsXHJcblx0ICAgIGhhcnI6ICdcXHUyMTk0JyxcclxuXHQgICAgY3JhcnI6ICdcXHUyMUI1JyxcclxuXHQgICAgbEFycjogJ1xcdTIxRDAnLFxyXG5cdCAgICB1QXJyOiAnXFx1MjFEMScsXHJcblx0ICAgIHJBcnI6ICdcXHUyMUQyJyxcclxuXHQgICAgZEFycjogJ1xcdTIxRDMnLFxyXG5cdCAgICBoQXJyOiAnXFx1MjFENCcsXHJcblx0ICAgIGZvcmFsbDogJ1xcdTIyMDAnLFxyXG5cdCAgICBwYXJ0OiAnXFx1MjIwMicsXHJcblx0ICAgIGV4aXN0OiAnXFx1MjIwMycsXHJcblx0ICAgIGVtcHR5OiAnXFx1MjIwNScsXHJcblx0ICAgIG5hYmxhOiAnXFx1MjIwNycsXHJcblx0ICAgIGlzaW46ICdcXHUyMjA4JyxcclxuXHQgICAgbm90aW46ICdcXHUyMjA5JyxcclxuXHQgICAgbmk6ICdcXHUyMjBCJyxcclxuXHQgICAgcHJvZDogJ1xcdTIyMEYnLFxyXG5cdCAgICBzdW06ICdcXHUyMjExJyxcclxuXHQgICAgbWludXM6ICdcXHUyMjEyJyxcclxuXHQgICAgbG93YXN0OiAnXFx1MjIxNycsXHJcblx0ICAgIHJhZGljOiAnXFx1MjIxQScsXHJcblx0ICAgIHByb3A6ICdcXHUyMjFEJyxcclxuXHQgICAgaW5maW46ICdcXHUyMjFFJyxcclxuXHQgICAgYW5nOiAnXFx1MjIyMCcsXHJcblx0ICAgIGFuZDogJ1xcdTIyMjcnLFxyXG5cdCAgICBvcjogJ1xcdTIyMjgnLFxyXG5cdCAgICBjYXA6ICdcXHUyMjI5JyxcclxuXHQgICAgY3VwOiAnXFx1MjIyQScsXHJcblx0ICAgIGludDogJ1xcdTIyMkInLFxyXG5cdCAgICB0aGVyZTQ6ICdcXHUyMjM0JyxcclxuXHQgICAgc2ltOiAnXFx1MjIzQycsXHJcblx0ICAgIGNvbmc6ICdcXHUyMjQ1JyxcclxuXHQgICAgYXN5bXA6ICdcXHUyMjQ4JyxcclxuXHQgICAgbmU6ICdcXHUyMjYwJyxcclxuXHQgICAgZXF1aXY6ICdcXHUyMjYxJyxcclxuXHQgICAgbGU6ICdcXHUyMjY0JyxcclxuXHQgICAgZ2U6ICdcXHUyMjY1JyxcclxuXHQgICAgc3ViOiAnXFx1MjI4MicsXHJcblx0ICAgIHN1cDogJ1xcdTIyODMnLFxyXG5cdCAgICBuc3ViOiAnXFx1MjI4NCcsXHJcblx0ICAgIHN1YmU6ICdcXHUyMjg2JyxcclxuXHQgICAgc3VwZTogJ1xcdTIyODcnLFxyXG5cdCAgICBvcGx1czogJ1xcdTIyOTUnLFxyXG5cdCAgICBvdGltZXM6ICdcXHUyMjk3JyxcclxuXHQgICAgcGVycDogJ1xcdTIyQTUnLFxyXG5cdCAgICBzZG90OiAnXFx1MjJDNScsXHJcblx0ICAgIGxjZWlsOiAnXFx1MjMwOCcsXHJcblx0ICAgIHJjZWlsOiAnXFx1MjMwOScsXHJcblx0ICAgIGxmbG9vcjogJ1xcdTIzMEEnLFxyXG5cdCAgICByZmxvb3I6ICdcXHUyMzBCJyxcclxuXHQgICAgbG96OiAnXFx1MjVDQScsXHJcblx0ICAgIHNwYWRlczogJ1xcdTI2NjAnLFxyXG5cdCAgICBjbHViczogJ1xcdTI2NjMnLFxyXG5cdCAgICBoZWFydHM6ICdcXHUyNjY1JyxcclxuXHQgICAgZGlhbXM6ICdcXHUyNjY2JyxcclxuXHQgICAgbGFuZzogJ1xcdTI3RTgnLFxyXG5cdCAgICByYW5nOiAnXFx1MjdFOSdcclxuXHR9O1xyXG5cblxuLyoqKi8gfSxcbi8qIDE1ICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXHRcInVzZSBzdHJpY3RcIjtcclxuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcblx0dmFyIGVycm9yX2hhbmRsZXJfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMTApO1xyXG5cdHZhciBzY2FubmVyXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEyKTtcclxuXHR2YXIgdG9rZW5fMSA9IF9fd2VicGFja19yZXF1aXJlX18oMTMpO1xyXG5cdHZhciBSZWFkZXIgPSAoZnVuY3Rpb24gKCkge1xyXG5cdCAgICBmdW5jdGlvbiBSZWFkZXIoKSB7XHJcblx0ICAgICAgICB0aGlzLnZhbHVlcyA9IFtdO1xyXG5cdCAgICAgICAgdGhpcy5jdXJseSA9IHRoaXMucGFyZW4gPSAtMTtcclxuXHQgICAgfVxyXG5cdCAgICAvLyBBIGZ1bmN0aW9uIGZvbGxvd2luZyBvbmUgb2YgdGhvc2UgdG9rZW5zIGlzIGFuIGV4cHJlc3Npb24uXHJcblx0ICAgIFJlYWRlci5wcm90b3R5cGUuYmVmb3JlRnVuY3Rpb25FeHByZXNzaW9uID0gZnVuY3Rpb24gKHQpIHtcclxuXHQgICAgICAgIHJldHVybiBbJygnLCAneycsICdbJywgJ2luJywgJ3R5cGVvZicsICdpbnN0YW5jZW9mJywgJ25ldycsXHJcblx0ICAgICAgICAgICAgJ3JldHVybicsICdjYXNlJywgJ2RlbGV0ZScsICd0aHJvdycsICd2b2lkJyxcclxuXHQgICAgICAgICAgICAvLyBhc3NpZ25tZW50IG9wZXJhdG9yc1xyXG5cdCAgICAgICAgICAgICc9JywgJys9JywgJy09JywgJyo9JywgJyoqPScsICcvPScsICclPScsICc8PD0nLCAnPj49JywgJz4+Pj0nLFxyXG5cdCAgICAgICAgICAgICcmPScsICd8PScsICdePScsICcsJyxcclxuXHQgICAgICAgICAgICAvLyBiaW5hcnkvdW5hcnkgb3BlcmF0b3JzXHJcblx0ICAgICAgICAgICAgJysnLCAnLScsICcqJywgJyoqJywgJy8nLCAnJScsICcrKycsICctLScsICc8PCcsICc+PicsICc+Pj4nLCAnJicsXHJcblx0ICAgICAgICAgICAgJ3wnLCAnXicsICchJywgJ34nLCAnJiYnLCAnfHwnLCAnPycsICc6JywgJz09PScsICc9PScsICc+PScsXHJcblx0ICAgICAgICAgICAgJzw9JywgJzwnLCAnPicsICchPScsICchPT0nXS5pbmRleE9mKHQpID49IDA7XHJcblx0ICAgIH07XHJcblx0ICAgIC8vIERldGVybWluZSBpZiBmb3J3YXJkIHNsYXNoICgvKSBpcyBhbiBvcGVyYXRvciBvciBwYXJ0IG9mIGEgcmVndWxhciBleHByZXNzaW9uXHJcblx0ICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9tb3ppbGxhL3N3ZWV0LmpzL3dpa2kvZGVzaWduXHJcblx0ICAgIFJlYWRlci5wcm90b3R5cGUuaXNSZWdleFN0YXJ0ID0gZnVuY3Rpb24gKCkge1xyXG5cdCAgICAgICAgdmFyIHByZXZpb3VzID0gdGhpcy52YWx1ZXNbdGhpcy52YWx1ZXMubGVuZ3RoIC0gMV07XHJcblx0ICAgICAgICB2YXIgcmVnZXggPSAocHJldmlvdXMgIT09IG51bGwpO1xyXG5cdCAgICAgICAgc3dpdGNoIChwcmV2aW91cykge1xyXG5cdCAgICAgICAgICAgIGNhc2UgJ3RoaXMnOlxyXG5cdCAgICAgICAgICAgIGNhc2UgJ10nOlxyXG5cdCAgICAgICAgICAgICAgICByZWdleCA9IGZhbHNlO1xyXG5cdCAgICAgICAgICAgICAgICBicmVhaztcclxuXHQgICAgICAgICAgICBjYXNlICcpJzpcclxuXHQgICAgICAgICAgICAgICAgdmFyIGtleXdvcmQgPSB0aGlzLnZhbHVlc1t0aGlzLnBhcmVuIC0gMV07XHJcblx0ICAgICAgICAgICAgICAgIHJlZ2V4ID0gKGtleXdvcmQgPT09ICdpZicgfHwga2V5d29yZCA9PT0gJ3doaWxlJyB8fCBrZXl3b3JkID09PSAnZm9yJyB8fCBrZXl3b3JkID09PSAnd2l0aCcpO1xyXG5cdCAgICAgICAgICAgICAgICBicmVhaztcclxuXHQgICAgICAgICAgICBjYXNlICd9JzpcclxuXHQgICAgICAgICAgICAgICAgLy8gRGl2aWRpbmcgYSBmdW5jdGlvbiBieSBhbnl0aGluZyBtYWtlcyBsaXR0bGUgc2Vuc2UsXHJcblx0ICAgICAgICAgICAgICAgIC8vIGJ1dCB3ZSBoYXZlIHRvIGNoZWNrIGZvciB0aGF0LlxyXG5cdCAgICAgICAgICAgICAgICByZWdleCA9IGZhbHNlO1xyXG5cdCAgICAgICAgICAgICAgICBpZiAodGhpcy52YWx1ZXNbdGhpcy5jdXJseSAtIDNdID09PSAnZnVuY3Rpb24nKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAvLyBBbm9ueW1vdXMgZnVuY3Rpb24sIGUuZy4gZnVuY3Rpb24oKXt9IC80MlxyXG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIGNoZWNrID0gdGhpcy52YWx1ZXNbdGhpcy5jdXJseSAtIDRdO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgcmVnZXggPSBjaGVjayA/ICF0aGlzLmJlZm9yZUZ1bmN0aW9uRXhwcmVzc2lvbihjaGVjaykgOiBmYWxzZTtcclxuXHQgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICBlbHNlIGlmICh0aGlzLnZhbHVlc1t0aGlzLmN1cmx5IC0gNF0gPT09ICdmdW5jdGlvbicpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgIC8vIE5hbWVkIGZ1bmN0aW9uLCBlLmcuIGZ1bmN0aW9uIGYoKXt9IC80Mi9cclxuXHQgICAgICAgICAgICAgICAgICAgIHZhciBjaGVjayA9IHRoaXMudmFsdWVzW3RoaXMuY3VybHkgLSA1XTtcclxuXHQgICAgICAgICAgICAgICAgICAgIHJlZ2V4ID0gY2hlY2sgPyAhdGhpcy5iZWZvcmVGdW5jdGlvbkV4cHJlc3Npb24oY2hlY2spIDogdHJ1ZTtcclxuXHQgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICBicmVhaztcclxuXHQgICAgICAgICAgICBkZWZhdWx0OlxyXG5cdCAgICAgICAgICAgICAgICBicmVhaztcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIHJldHVybiByZWdleDtcclxuXHQgICAgfTtcclxuXHQgICAgUmVhZGVyLnByb3RvdHlwZS5wdXNoID0gZnVuY3Rpb24gKHRva2VuKSB7XHJcblx0ICAgICAgICBpZiAodG9rZW4udHlwZSA9PT0gNyAvKiBQdW5jdHVhdG9yICovIHx8IHRva2VuLnR5cGUgPT09IDQgLyogS2V5d29yZCAqLykge1xyXG5cdCAgICAgICAgICAgIGlmICh0b2tlbi52YWx1ZSA9PT0gJ3snKSB7XHJcblx0ICAgICAgICAgICAgICAgIHRoaXMuY3VybHkgPSB0aGlzLnZhbHVlcy5sZW5ndGg7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgIGVsc2UgaWYgKHRva2VuLnZhbHVlID09PSAnKCcpIHtcclxuXHQgICAgICAgICAgICAgICAgdGhpcy5wYXJlbiA9IHRoaXMudmFsdWVzLmxlbmd0aDtcclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgdGhpcy52YWx1ZXMucHVzaCh0b2tlbi52YWx1ZSk7XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICBlbHNlIHtcclxuXHQgICAgICAgICAgICB0aGlzLnZhbHVlcy5wdXNoKG51bGwpO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICB9O1xyXG5cdCAgICByZXR1cm4gUmVhZGVyO1xyXG5cdH0oKSk7XHJcblx0dmFyIFRva2VuaXplciA9IChmdW5jdGlvbiAoKSB7XHJcblx0ICAgIGZ1bmN0aW9uIFRva2VuaXplcihjb2RlLCBjb25maWcpIHtcclxuXHQgICAgICAgIHRoaXMuZXJyb3JIYW5kbGVyID0gbmV3IGVycm9yX2hhbmRsZXJfMS5FcnJvckhhbmRsZXIoKTtcclxuXHQgICAgICAgIHRoaXMuZXJyb3JIYW5kbGVyLnRvbGVyYW50ID0gY29uZmlnID8gKHR5cGVvZiBjb25maWcudG9sZXJhbnQgPT09ICdib29sZWFuJyAmJiBjb25maWcudG9sZXJhbnQpIDogZmFsc2U7XHJcblx0ICAgICAgICB0aGlzLnNjYW5uZXIgPSBuZXcgc2Nhbm5lcl8xLlNjYW5uZXIoY29kZSwgdGhpcy5lcnJvckhhbmRsZXIpO1xyXG5cdCAgICAgICAgdGhpcy5zY2FubmVyLnRyYWNrQ29tbWVudCA9IGNvbmZpZyA/ICh0eXBlb2YgY29uZmlnLmNvbW1lbnQgPT09ICdib29sZWFuJyAmJiBjb25maWcuY29tbWVudCkgOiBmYWxzZTtcclxuXHQgICAgICAgIHRoaXMudHJhY2tSYW5nZSA9IGNvbmZpZyA/ICh0eXBlb2YgY29uZmlnLnJhbmdlID09PSAnYm9vbGVhbicgJiYgY29uZmlnLnJhbmdlKSA6IGZhbHNlO1xyXG5cdCAgICAgICAgdGhpcy50cmFja0xvYyA9IGNvbmZpZyA/ICh0eXBlb2YgY29uZmlnLmxvYyA9PT0gJ2Jvb2xlYW4nICYmIGNvbmZpZy5sb2MpIDogZmFsc2U7XHJcblx0ICAgICAgICB0aGlzLmJ1ZmZlciA9IFtdO1xyXG5cdCAgICAgICAgdGhpcy5yZWFkZXIgPSBuZXcgUmVhZGVyKCk7XHJcblx0ICAgIH1cclxuXHQgICAgVG9rZW5pemVyLnByb3RvdHlwZS5lcnJvcnMgPSBmdW5jdGlvbiAoKSB7XHJcblx0ICAgICAgICByZXR1cm4gdGhpcy5lcnJvckhhbmRsZXIuZXJyb3JzO1xyXG5cdCAgICB9O1xyXG5cdCAgICBUb2tlbml6ZXIucHJvdG90eXBlLmdldE5leHRUb2tlbiA9IGZ1bmN0aW9uICgpIHtcclxuXHQgICAgICAgIGlmICh0aGlzLmJ1ZmZlci5sZW5ndGggPT09IDApIHtcclxuXHQgICAgICAgICAgICB2YXIgY29tbWVudHMgPSB0aGlzLnNjYW5uZXIuc2NhbkNvbW1lbnRzKCk7XHJcblx0ICAgICAgICAgICAgaWYgKHRoaXMuc2Nhbm5lci50cmFja0NvbW1lbnQpIHtcclxuXHQgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb21tZW50cy5sZW5ndGg7ICsraSkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIGUgPSBjb21tZW50c1tpXTtcclxuXHQgICAgICAgICAgICAgICAgICAgIHZhciB2YWx1ZSA9IHRoaXMuc2Nhbm5lci5zb3VyY2Uuc2xpY2UoZS5zbGljZVswXSwgZS5zbGljZVsxXSk7XHJcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgY29tbWVudCA9IHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBlLm11bHRpTGluZSA/ICdCbG9ja0NvbW1lbnQnIDogJ0xpbmVDb21tZW50JyxcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogdmFsdWVcclxuXHQgICAgICAgICAgICAgICAgICAgIH07XHJcblx0ICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy50cmFja1JhbmdlKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgY29tbWVudC5yYW5nZSA9IGUucmFuZ2U7XHJcblx0ICAgICAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy50cmFja0xvYykge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGNvbW1lbnQubG9jID0gZS5sb2M7XHJcblx0ICAgICAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgICAgICB0aGlzLmJ1ZmZlci5wdXNoKGNvbW1lbnQpO1xyXG5cdCAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgIGlmICghdGhpcy5zY2FubmVyLmVvZigpKSB7XHJcblx0ICAgICAgICAgICAgICAgIHZhciBsb2MgPSB2b2lkIDA7XHJcblx0ICAgICAgICAgICAgICAgIGlmICh0aGlzLnRyYWNrTG9jKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICBsb2MgPSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgc3RhcnQ6IHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGluZTogdGhpcy5zY2FubmVyLmxpbmVOdW1iZXIsXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbHVtbjogdGhpcy5zY2FubmVyLmluZGV4IC0gdGhpcy5zY2FubmVyLmxpbmVTdGFydFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH0sXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgZW5kOiB7fVxyXG5cdCAgICAgICAgICAgICAgICAgICAgfTtcclxuXHQgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICB2YXIgc3RhcnRSZWdleCA9ICh0aGlzLnNjYW5uZXIuc291cmNlW3RoaXMuc2Nhbm5lci5pbmRleF0gPT09ICcvJykgJiYgdGhpcy5yZWFkZXIuaXNSZWdleFN0YXJ0KCk7XHJcblx0ICAgICAgICAgICAgICAgIHZhciB0b2tlbiA9IHN0YXJ0UmVnZXggPyB0aGlzLnNjYW5uZXIuc2NhblJlZ0V4cCgpIDogdGhpcy5zY2FubmVyLmxleCgpO1xyXG5cdCAgICAgICAgICAgICAgICB0aGlzLnJlYWRlci5wdXNoKHRva2VuKTtcclxuXHQgICAgICAgICAgICAgICAgdmFyIGVudHJ5ID0ge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgdHlwZTogdG9rZW5fMS5Ub2tlbk5hbWVbdG9rZW4udHlwZV0sXHJcblx0ICAgICAgICAgICAgICAgICAgICB2YWx1ZTogdGhpcy5zY2FubmVyLnNvdXJjZS5zbGljZSh0b2tlbi5zdGFydCwgdG9rZW4uZW5kKVxyXG5cdCAgICAgICAgICAgICAgICB9O1xyXG5cdCAgICAgICAgICAgICAgICBpZiAodGhpcy50cmFja1JhbmdlKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICBlbnRyeS5yYW5nZSA9IFt0b2tlbi5zdGFydCwgdG9rZW4uZW5kXTtcclxuXHQgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICBpZiAodGhpcy50cmFja0xvYykge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgbG9jLmVuZCA9IHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBsaW5lOiB0aGlzLnNjYW5uZXIubGluZU51bWJlcixcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBjb2x1bW46IHRoaXMuc2Nhbm5lci5pbmRleCAtIHRoaXMuc2Nhbm5lci5saW5lU3RhcnRcclxuXHQgICAgICAgICAgICAgICAgICAgIH07XHJcblx0ICAgICAgICAgICAgICAgICAgICBlbnRyeS5sb2MgPSBsb2M7XHJcblx0ICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgaWYgKHRva2VuLnR5cGUgPT09IDkgLyogUmVndWxhckV4cHJlc3Npb24gKi8pIHtcclxuXHQgICAgICAgICAgICAgICAgICAgIHZhciBwYXR0ZXJuID0gdG9rZW4ucGF0dGVybjtcclxuXHQgICAgICAgICAgICAgICAgICAgIHZhciBmbGFncyA9IHRva2VuLmZsYWdzO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgZW50cnkucmVnZXggPSB7IHBhdHRlcm46IHBhdHRlcm4sIGZsYWdzOiBmbGFncyB9O1xyXG5cdCAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgIHRoaXMuYnVmZmVyLnB1c2goZW50cnkpO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIHJldHVybiB0aGlzLmJ1ZmZlci5zaGlmdCgpO1xyXG5cdCAgICB9O1xyXG5cdCAgICByZXR1cm4gVG9rZW5pemVyO1xyXG5cdH0oKSk7XHJcblx0ZXhwb3J0cy5Ub2tlbml6ZXIgPSBUb2tlbml6ZXI7XHJcblxuXG4vKioqLyB9XG4vKioqKioqLyBdKVxufSk7XG47XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2VzcHJpbWEvZGlzdC9lc3ByaW1hLmpzIiwiJ3VzZSBzdHJpY3QnO1xuXG4vKmVzbGludC1kaXNhYmxlIG5vLXVzZS1iZWZvcmUtZGVmaW5lKi9cblxudmFyIGNvbW1vbiAgICAgICAgICAgICAgPSByZXF1aXJlKCcuL2NvbW1vbicpO1xudmFyIFlBTUxFeGNlcHRpb24gICAgICAgPSByZXF1aXJlKCcuL2V4Y2VwdGlvbicpO1xudmFyIERFRkFVTFRfRlVMTF9TQ0hFTUEgPSByZXF1aXJlKCcuL3NjaGVtYS9kZWZhdWx0X2Z1bGwnKTtcbnZhciBERUZBVUxUX1NBRkVfU0NIRU1BID0gcmVxdWlyZSgnLi9zY2hlbWEvZGVmYXVsdF9zYWZlJyk7XG5cbnZhciBfdG9TdHJpbmcgICAgICAgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nO1xudmFyIF9oYXNPd25Qcm9wZXJ0eSA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG5cbnZhciBDSEFSX1RBQiAgICAgICAgICAgICAgICAgID0gMHgwOTsgLyogVGFiICovXG52YXIgQ0hBUl9MSU5FX0ZFRUQgICAgICAgICAgICA9IDB4MEE7IC8qIExGICovXG52YXIgQ0hBUl9TUEFDRSAgICAgICAgICAgICAgICA9IDB4MjA7IC8qIFNwYWNlICovXG52YXIgQ0hBUl9FWENMQU1BVElPTiAgICAgICAgICA9IDB4MjE7IC8qICEgKi9cbnZhciBDSEFSX0RPVUJMRV9RVU9URSAgICAgICAgID0gMHgyMjsgLyogXCIgKi9cbnZhciBDSEFSX1NIQVJQICAgICAgICAgICAgICAgID0gMHgyMzsgLyogIyAqL1xudmFyIENIQVJfUEVSQ0VOVCAgICAgICAgICAgICAgPSAweDI1OyAvKiAlICovXG52YXIgQ0hBUl9BTVBFUlNBTkQgICAgICAgICAgICA9IDB4MjY7IC8qICYgKi9cbnZhciBDSEFSX1NJTkdMRV9RVU9URSAgICAgICAgID0gMHgyNzsgLyogJyAqL1xudmFyIENIQVJfQVNURVJJU0sgICAgICAgICAgICAgPSAweDJBOyAvKiAqICovXG52YXIgQ0hBUl9DT01NQSAgICAgICAgICAgICAgICA9IDB4MkM7IC8qICwgKi9cbnZhciBDSEFSX01JTlVTICAgICAgICAgICAgICAgID0gMHgyRDsgLyogLSAqL1xudmFyIENIQVJfQ09MT04gICAgICAgICAgICAgICAgPSAweDNBOyAvKiA6ICovXG52YXIgQ0hBUl9HUkVBVEVSX1RIQU4gICAgICAgICA9IDB4M0U7IC8qID4gKi9cbnZhciBDSEFSX1FVRVNUSU9OICAgICAgICAgICAgID0gMHgzRjsgLyogPyAqL1xudmFyIENIQVJfQ09NTUVSQ0lBTF9BVCAgICAgICAgPSAweDQwOyAvKiBAICovXG52YXIgQ0hBUl9MRUZUX1NRVUFSRV9CUkFDS0VUICA9IDB4NUI7IC8qIFsgKi9cbnZhciBDSEFSX1JJR0hUX1NRVUFSRV9CUkFDS0VUID0gMHg1RDsgLyogXSAqL1xudmFyIENIQVJfR1JBVkVfQUNDRU5UICAgICAgICAgPSAweDYwOyAvKiBgICovXG52YXIgQ0hBUl9MRUZUX0NVUkxZX0JSQUNLRVQgICA9IDB4N0I7IC8qIHsgKi9cbnZhciBDSEFSX1ZFUlRJQ0FMX0xJTkUgICAgICAgID0gMHg3QzsgLyogfCAqL1xudmFyIENIQVJfUklHSFRfQ1VSTFlfQlJBQ0tFVCAgPSAweDdEOyAvKiB9ICovXG5cbnZhciBFU0NBUEVfU0VRVUVOQ0VTID0ge307XG5cbkVTQ0FQRV9TRVFVRU5DRVNbMHgwMF0gICA9ICdcXFxcMCc7XG5FU0NBUEVfU0VRVUVOQ0VTWzB4MDddICAgPSAnXFxcXGEnO1xuRVNDQVBFX1NFUVVFTkNFU1sweDA4XSAgID0gJ1xcXFxiJztcbkVTQ0FQRV9TRVFVRU5DRVNbMHgwOV0gICA9ICdcXFxcdCc7XG5FU0NBUEVfU0VRVUVOQ0VTWzB4MEFdICAgPSAnXFxcXG4nO1xuRVNDQVBFX1NFUVVFTkNFU1sweDBCXSAgID0gJ1xcXFx2JztcbkVTQ0FQRV9TRVFVRU5DRVNbMHgwQ10gICA9ICdcXFxcZic7XG5FU0NBUEVfU0VRVUVOQ0VTWzB4MERdICAgPSAnXFxcXHInO1xuRVNDQVBFX1NFUVVFTkNFU1sweDFCXSAgID0gJ1xcXFxlJztcbkVTQ0FQRV9TRVFVRU5DRVNbMHgyMl0gICA9ICdcXFxcXCInO1xuRVNDQVBFX1NFUVVFTkNFU1sweDVDXSAgID0gJ1xcXFxcXFxcJztcbkVTQ0FQRV9TRVFVRU5DRVNbMHg4NV0gICA9ICdcXFxcTic7XG5FU0NBUEVfU0VRVUVOQ0VTWzB4QTBdICAgPSAnXFxcXF8nO1xuRVNDQVBFX1NFUVVFTkNFU1sweDIwMjhdID0gJ1xcXFxMJztcbkVTQ0FQRV9TRVFVRU5DRVNbMHgyMDI5XSA9ICdcXFxcUCc7XG5cbnZhciBERVBSRUNBVEVEX0JPT0xFQU5TX1NZTlRBWCA9IFtcbiAgJ3knLCAnWScsICd5ZXMnLCAnWWVzJywgJ1lFUycsICdvbicsICdPbicsICdPTicsXG4gICduJywgJ04nLCAnbm8nLCAnTm8nLCAnTk8nLCAnb2ZmJywgJ09mZicsICdPRkYnXG5dO1xuXG5mdW5jdGlvbiBjb21waWxlU3R5bGVNYXAoc2NoZW1hLCBtYXApIHtcbiAgdmFyIHJlc3VsdCwga2V5cywgaW5kZXgsIGxlbmd0aCwgdGFnLCBzdHlsZSwgdHlwZTtcblxuICBpZiAobWFwID09PSBudWxsKSByZXR1cm4ge307XG5cbiAgcmVzdWx0ID0ge307XG4gIGtleXMgPSBPYmplY3Qua2V5cyhtYXApO1xuXG4gIGZvciAoaW5kZXggPSAwLCBsZW5ndGggPSBrZXlzLmxlbmd0aDsgaW5kZXggPCBsZW5ndGg7IGluZGV4ICs9IDEpIHtcbiAgICB0YWcgPSBrZXlzW2luZGV4XTtcbiAgICBzdHlsZSA9IFN0cmluZyhtYXBbdGFnXSk7XG5cbiAgICBpZiAodGFnLnNsaWNlKDAsIDIpID09PSAnISEnKSB7XG4gICAgICB0YWcgPSAndGFnOnlhbWwub3JnLDIwMDI6JyArIHRhZy5zbGljZSgyKTtcbiAgICB9XG4gICAgdHlwZSA9IHNjaGVtYS5jb21waWxlZFR5cGVNYXBbJ2ZhbGxiYWNrJ11bdGFnXTtcblxuICAgIGlmICh0eXBlICYmIF9oYXNPd25Qcm9wZXJ0eS5jYWxsKHR5cGUuc3R5bGVBbGlhc2VzLCBzdHlsZSkpIHtcbiAgICAgIHN0eWxlID0gdHlwZS5zdHlsZUFsaWFzZXNbc3R5bGVdO1xuICAgIH1cblxuICAgIHJlc3VsdFt0YWddID0gc3R5bGU7XG4gIH1cblxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5mdW5jdGlvbiBlbmNvZGVIZXgoY2hhcmFjdGVyKSB7XG4gIHZhciBzdHJpbmcsIGhhbmRsZSwgbGVuZ3RoO1xuXG4gIHN0cmluZyA9IGNoYXJhY3Rlci50b1N0cmluZygxNikudG9VcHBlckNhc2UoKTtcblxuICBpZiAoY2hhcmFjdGVyIDw9IDB4RkYpIHtcbiAgICBoYW5kbGUgPSAneCc7XG4gICAgbGVuZ3RoID0gMjtcbiAgfSBlbHNlIGlmIChjaGFyYWN0ZXIgPD0gMHhGRkZGKSB7XG4gICAgaGFuZGxlID0gJ3UnO1xuICAgIGxlbmd0aCA9IDQ7XG4gIH0gZWxzZSBpZiAoY2hhcmFjdGVyIDw9IDB4RkZGRkZGRkYpIHtcbiAgICBoYW5kbGUgPSAnVSc7XG4gICAgbGVuZ3RoID0gODtcbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBuZXcgWUFNTEV4Y2VwdGlvbignY29kZSBwb2ludCB3aXRoaW4gYSBzdHJpbmcgbWF5IG5vdCBiZSBncmVhdGVyIHRoYW4gMHhGRkZGRkZGRicpO1xuICB9XG5cbiAgcmV0dXJuICdcXFxcJyArIGhhbmRsZSArIGNvbW1vbi5yZXBlYXQoJzAnLCBsZW5ndGggLSBzdHJpbmcubGVuZ3RoKSArIHN0cmluZztcbn1cblxuZnVuY3Rpb24gU3RhdGUob3B0aW9ucykge1xuICB0aGlzLnNjaGVtYSAgICAgICA9IG9wdGlvbnNbJ3NjaGVtYSddIHx8IERFRkFVTFRfRlVMTF9TQ0hFTUE7XG4gIHRoaXMuaW5kZW50ICAgICAgID0gTWF0aC5tYXgoMSwgKG9wdGlvbnNbJ2luZGVudCddIHx8IDIpKTtcbiAgdGhpcy5za2lwSW52YWxpZCAgPSBvcHRpb25zWydza2lwSW52YWxpZCddIHx8IGZhbHNlO1xuICB0aGlzLmZsb3dMZXZlbCAgICA9IChjb21tb24uaXNOb3RoaW5nKG9wdGlvbnNbJ2Zsb3dMZXZlbCddKSA/IC0xIDogb3B0aW9uc1snZmxvd0xldmVsJ10pO1xuICB0aGlzLnN0eWxlTWFwICAgICA9IGNvbXBpbGVTdHlsZU1hcCh0aGlzLnNjaGVtYSwgb3B0aW9uc1snc3R5bGVzJ10gfHwgbnVsbCk7XG4gIHRoaXMuc29ydEtleXMgICAgID0gb3B0aW9uc1snc29ydEtleXMnXSB8fCBmYWxzZTtcbiAgdGhpcy5saW5lV2lkdGggICAgPSBvcHRpb25zWydsaW5lV2lkdGgnXSB8fCA4MDtcbiAgdGhpcy5ub1JlZnMgICAgICAgPSBvcHRpb25zWydub1JlZnMnXSB8fCBmYWxzZTtcbiAgdGhpcy5ub0NvbXBhdE1vZGUgPSBvcHRpb25zWydub0NvbXBhdE1vZGUnXSB8fCBmYWxzZTtcbiAgdGhpcy5jb25kZW5zZUZsb3cgPSBvcHRpb25zWydjb25kZW5zZUZsb3cnXSB8fCBmYWxzZTtcblxuICB0aGlzLmltcGxpY2l0VHlwZXMgPSB0aGlzLnNjaGVtYS5jb21waWxlZEltcGxpY2l0O1xuICB0aGlzLmV4cGxpY2l0VHlwZXMgPSB0aGlzLnNjaGVtYS5jb21waWxlZEV4cGxpY2l0O1xuXG4gIHRoaXMudGFnID0gbnVsbDtcbiAgdGhpcy5yZXN1bHQgPSAnJztcblxuICB0aGlzLmR1cGxpY2F0ZXMgPSBbXTtcbiAgdGhpcy51c2VkRHVwbGljYXRlcyA9IG51bGw7XG59XG5cbi8vIEluZGVudHMgZXZlcnkgbGluZSBpbiBhIHN0cmluZy4gRW1wdHkgbGluZXMgKFxcbiBvbmx5KSBhcmUgbm90IGluZGVudGVkLlxuZnVuY3Rpb24gaW5kZW50U3RyaW5nKHN0cmluZywgc3BhY2VzKSB7XG4gIHZhciBpbmQgPSBjb21tb24ucmVwZWF0KCcgJywgc3BhY2VzKSxcbiAgICAgIHBvc2l0aW9uID0gMCxcbiAgICAgIG5leHQgPSAtMSxcbiAgICAgIHJlc3VsdCA9ICcnLFxuICAgICAgbGluZSxcbiAgICAgIGxlbmd0aCA9IHN0cmluZy5sZW5ndGg7XG5cbiAgd2hpbGUgKHBvc2l0aW9uIDwgbGVuZ3RoKSB7XG4gICAgbmV4dCA9IHN0cmluZy5pbmRleE9mKCdcXG4nLCBwb3NpdGlvbik7XG4gICAgaWYgKG5leHQgPT09IC0xKSB7XG4gICAgICBsaW5lID0gc3RyaW5nLnNsaWNlKHBvc2l0aW9uKTtcbiAgICAgIHBvc2l0aW9uID0gbGVuZ3RoO1xuICAgIH0gZWxzZSB7XG4gICAgICBsaW5lID0gc3RyaW5nLnNsaWNlKHBvc2l0aW9uLCBuZXh0ICsgMSk7XG4gICAgICBwb3NpdGlvbiA9IG5leHQgKyAxO1xuICAgIH1cblxuICAgIGlmIChsaW5lLmxlbmd0aCAmJiBsaW5lICE9PSAnXFxuJykgcmVzdWx0ICs9IGluZDtcblxuICAgIHJlc3VsdCArPSBsaW5lO1xuICB9XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuZnVuY3Rpb24gZ2VuZXJhdGVOZXh0TGluZShzdGF0ZSwgbGV2ZWwpIHtcbiAgcmV0dXJuICdcXG4nICsgY29tbW9uLnJlcGVhdCgnICcsIHN0YXRlLmluZGVudCAqIGxldmVsKTtcbn1cblxuZnVuY3Rpb24gdGVzdEltcGxpY2l0UmVzb2x2aW5nKHN0YXRlLCBzdHIpIHtcbiAgdmFyIGluZGV4LCBsZW5ndGgsIHR5cGU7XG5cbiAgZm9yIChpbmRleCA9IDAsIGxlbmd0aCA9IHN0YXRlLmltcGxpY2l0VHlwZXMubGVuZ3RoOyBpbmRleCA8IGxlbmd0aDsgaW5kZXggKz0gMSkge1xuICAgIHR5cGUgPSBzdGF0ZS5pbXBsaWNpdFR5cGVzW2luZGV4XTtcblxuICAgIGlmICh0eXBlLnJlc29sdmUoc3RyKSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG4vLyBbMzNdIHMtd2hpdGUgOjo9IHMtc3BhY2UgfCBzLXRhYlxuZnVuY3Rpb24gaXNXaGl0ZXNwYWNlKGMpIHtcbiAgcmV0dXJuIGMgPT09IENIQVJfU1BBQ0UgfHwgYyA9PT0gQ0hBUl9UQUI7XG59XG5cbi8vIFJldHVybnMgdHJ1ZSBpZiB0aGUgY2hhcmFjdGVyIGNhbiBiZSBwcmludGVkIHdpdGhvdXQgZXNjYXBpbmcuXG4vLyBGcm9tIFlBTUwgMS4yOiBcImFueSBhbGxvd2VkIGNoYXJhY3RlcnMga25vd24gdG8gYmUgbm9uLXByaW50YWJsZVxuLy8gc2hvdWxkIGFsc28gYmUgZXNjYXBlZC4gW0hvd2V2ZXIsXSBUaGlzIGlzbuKAmXQgbWFuZGF0b3J5XCJcbi8vIERlcml2ZWQgZnJvbSBuYi1jaGFyIC0gXFx0IC0gI3g4NSAtICN4QTAgLSAjeDIwMjggLSAjeDIwMjkuXG5mdW5jdGlvbiBpc1ByaW50YWJsZShjKSB7XG4gIHJldHVybiAgKDB4MDAwMjAgPD0gYyAmJiBjIDw9IDB4MDAwMDdFKVxuICAgICAgfHwgKCgweDAwMEExIDw9IGMgJiYgYyA8PSAweDAwRDdGRikgJiYgYyAhPT0gMHgyMDI4ICYmIGMgIT09IDB4MjAyOSlcbiAgICAgIHx8ICgoMHgwRTAwMCA8PSBjICYmIGMgPD0gMHgwMEZGRkQpICYmIGMgIT09IDB4RkVGRiAvKiBCT00gKi8pXG4gICAgICB8fCAgKDB4MTAwMDAgPD0gYyAmJiBjIDw9IDB4MTBGRkZGKTtcbn1cblxuLy8gU2ltcGxpZmllZCB0ZXN0IGZvciB2YWx1ZXMgYWxsb3dlZCBhZnRlciB0aGUgZmlyc3QgY2hhcmFjdGVyIGluIHBsYWluIHN0eWxlLlxuZnVuY3Rpb24gaXNQbGFpblNhZmUoYykge1xuICAvLyBVc2VzIGEgc3Vic2V0IG9mIG5iLWNoYXIgLSBjLWZsb3ctaW5kaWNhdG9yIC0gXCI6XCIgLSBcIiNcIlxuICAvLyB3aGVyZSBuYi1jaGFyIDo6PSBjLXByaW50YWJsZSAtIGItY2hhciAtIGMtYnl0ZS1vcmRlci1tYXJrLlxuICByZXR1cm4gaXNQcmludGFibGUoYykgJiYgYyAhPT0gMHhGRUZGXG4gICAgLy8gLSBjLWZsb3ctaW5kaWNhdG9yXG4gICAgJiYgYyAhPT0gQ0hBUl9DT01NQVxuICAgICYmIGMgIT09IENIQVJfTEVGVF9TUVVBUkVfQlJBQ0tFVFxuICAgICYmIGMgIT09IENIQVJfUklHSFRfU1FVQVJFX0JSQUNLRVRcbiAgICAmJiBjICE9PSBDSEFSX0xFRlRfQ1VSTFlfQlJBQ0tFVFxuICAgICYmIGMgIT09IENIQVJfUklHSFRfQ1VSTFlfQlJBQ0tFVFxuICAgIC8vIC0gXCI6XCIgLSBcIiNcIlxuICAgICYmIGMgIT09IENIQVJfQ09MT05cbiAgICAmJiBjICE9PSBDSEFSX1NIQVJQO1xufVxuXG4vLyBTaW1wbGlmaWVkIHRlc3QgZm9yIHZhbHVlcyBhbGxvd2VkIGFzIHRoZSBmaXJzdCBjaGFyYWN0ZXIgaW4gcGxhaW4gc3R5bGUuXG5mdW5jdGlvbiBpc1BsYWluU2FmZUZpcnN0KGMpIHtcbiAgLy8gVXNlcyBhIHN1YnNldCBvZiBucy1jaGFyIC0gYy1pbmRpY2F0b3JcbiAgLy8gd2hlcmUgbnMtY2hhciA9IG5iLWNoYXIgLSBzLXdoaXRlLlxuICByZXR1cm4gaXNQcmludGFibGUoYykgJiYgYyAhPT0gMHhGRUZGXG4gICAgJiYgIWlzV2hpdGVzcGFjZShjKSAvLyAtIHMtd2hpdGVcbiAgICAvLyAtIChjLWluZGljYXRvciA6Oj1cbiAgICAvLyDigJwt4oCdIHwg4oCcP+KAnSB8IOKAnDrigJ0gfCDigJws4oCdIHwg4oCcW+KAnSB8IOKAnF3igJ0gfCDigJx74oCdIHwg4oCcfeKAnVxuICAgICYmIGMgIT09IENIQVJfTUlOVVNcbiAgICAmJiBjICE9PSBDSEFSX1FVRVNUSU9OXG4gICAgJiYgYyAhPT0gQ0hBUl9DT0xPTlxuICAgICYmIGMgIT09IENIQVJfQ09NTUFcbiAgICAmJiBjICE9PSBDSEFSX0xFRlRfU1FVQVJFX0JSQUNLRVRcbiAgICAmJiBjICE9PSBDSEFSX1JJR0hUX1NRVUFSRV9CUkFDS0VUXG4gICAgJiYgYyAhPT0gQ0hBUl9MRUZUX0NVUkxZX0JSQUNLRVRcbiAgICAmJiBjICE9PSBDSEFSX1JJR0hUX0NVUkxZX0JSQUNLRVRcbiAgICAvLyB8IOKAnCPigJ0gfCDigJwm4oCdIHwg4oCcKuKAnSB8IOKAnCHigJ0gfCDigJx84oCdIHwg4oCcPuKAnSB8IOKAnCfigJ0gfCDigJxcIuKAnVxuICAgICYmIGMgIT09IENIQVJfU0hBUlBcbiAgICAmJiBjICE9PSBDSEFSX0FNUEVSU0FORFxuICAgICYmIGMgIT09IENIQVJfQVNURVJJU0tcbiAgICAmJiBjICE9PSBDSEFSX0VYQ0xBTUFUSU9OXG4gICAgJiYgYyAhPT0gQ0hBUl9WRVJUSUNBTF9MSU5FXG4gICAgJiYgYyAhPT0gQ0hBUl9HUkVBVEVSX1RIQU5cbiAgICAmJiBjICE9PSBDSEFSX1NJTkdMRV9RVU9URVxuICAgICYmIGMgIT09IENIQVJfRE9VQkxFX1FVT1RFXG4gICAgLy8gfCDigJwl4oCdIHwg4oCcQOKAnSB8IOKAnGDigJ0pXG4gICAgJiYgYyAhPT0gQ0hBUl9QRVJDRU5UXG4gICAgJiYgYyAhPT0gQ0hBUl9DT01NRVJDSUFMX0FUXG4gICAgJiYgYyAhPT0gQ0hBUl9HUkFWRV9BQ0NFTlQ7XG59XG5cbnZhciBTVFlMRV9QTEFJTiAgID0gMSxcbiAgICBTVFlMRV9TSU5HTEUgID0gMixcbiAgICBTVFlMRV9MSVRFUkFMID0gMyxcbiAgICBTVFlMRV9GT0xERUQgID0gNCxcbiAgICBTVFlMRV9ET1VCTEUgID0gNTtcblxuLy8gRGV0ZXJtaW5lcyB3aGljaCBzY2FsYXIgc3R5bGVzIGFyZSBwb3NzaWJsZSBhbmQgcmV0dXJucyB0aGUgcHJlZmVycmVkIHN0eWxlLlxuLy8gbGluZVdpZHRoID0gLTEgPT4gbm8gbGltaXQuXG4vLyBQcmUtY29uZGl0aW9uczogc3RyLmxlbmd0aCA+IDAuXG4vLyBQb3N0LWNvbmRpdGlvbnM6XG4vLyAgICBTVFlMRV9QTEFJTiBvciBTVFlMRV9TSU5HTEUgPT4gbm8gXFxuIGFyZSBpbiB0aGUgc3RyaW5nLlxuLy8gICAgU1RZTEVfTElURVJBTCA9PiBubyBsaW5lcyBhcmUgc3VpdGFibGUgZm9yIGZvbGRpbmcgKG9yIGxpbmVXaWR0aCBpcyAtMSkuXG4vLyAgICBTVFlMRV9GT0xERUQgPT4gYSBsaW5lID4gbGluZVdpZHRoIGFuZCBjYW4gYmUgZm9sZGVkIChhbmQgbGluZVdpZHRoICE9IC0xKS5cbmZ1bmN0aW9uIGNob29zZVNjYWxhclN0eWxlKHN0cmluZywgc2luZ2xlTGluZU9ubHksIGluZGVudFBlckxldmVsLCBsaW5lV2lkdGgsIHRlc3RBbWJpZ3VvdXNUeXBlKSB7XG4gIHZhciBpO1xuICB2YXIgY2hhcjtcbiAgdmFyIGhhc0xpbmVCcmVhayA9IGZhbHNlO1xuICB2YXIgaGFzRm9sZGFibGVMaW5lID0gZmFsc2U7IC8vIG9ubHkgY2hlY2tlZCBpZiBzaG91bGRUcmFja1dpZHRoXG4gIHZhciBzaG91bGRUcmFja1dpZHRoID0gbGluZVdpZHRoICE9PSAtMTtcbiAgdmFyIHByZXZpb3VzTGluZUJyZWFrID0gLTE7IC8vIGNvdW50IHRoZSBmaXJzdCBsaW5lIGNvcnJlY3RseVxuICB2YXIgcGxhaW4gPSBpc1BsYWluU2FmZUZpcnN0KHN0cmluZy5jaGFyQ29kZUF0KDApKVxuICAgICAgICAgICYmICFpc1doaXRlc3BhY2Uoc3RyaW5nLmNoYXJDb2RlQXQoc3RyaW5nLmxlbmd0aCAtIDEpKTtcblxuICBpZiAoc2luZ2xlTGluZU9ubHkpIHtcbiAgICAvLyBDYXNlOiBubyBibG9jayBzdHlsZXMuXG4gICAgLy8gQ2hlY2sgZm9yIGRpc2FsbG93ZWQgY2hhcmFjdGVycyB0byBydWxlIG91dCBwbGFpbiBhbmQgc2luZ2xlLlxuICAgIGZvciAoaSA9IDA7IGkgPCBzdHJpbmcubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNoYXIgPSBzdHJpbmcuY2hhckNvZGVBdChpKTtcbiAgICAgIGlmICghaXNQcmludGFibGUoY2hhcikpIHtcbiAgICAgICAgcmV0dXJuIFNUWUxFX0RPVUJMRTtcbiAgICAgIH1cbiAgICAgIHBsYWluID0gcGxhaW4gJiYgaXNQbGFpblNhZmUoY2hhcik7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIC8vIENhc2U6IGJsb2NrIHN0eWxlcyBwZXJtaXR0ZWQuXG4gICAgZm9yIChpID0gMDsgaSA8IHN0cmluZy5sZW5ndGg7IGkrKykge1xuICAgICAgY2hhciA9IHN0cmluZy5jaGFyQ29kZUF0KGkpO1xuICAgICAgaWYgKGNoYXIgPT09IENIQVJfTElORV9GRUVEKSB7XG4gICAgICAgIGhhc0xpbmVCcmVhayA9IHRydWU7XG4gICAgICAgIC8vIENoZWNrIGlmIGFueSBsaW5lIGNhbiBiZSBmb2xkZWQuXG4gICAgICAgIGlmIChzaG91bGRUcmFja1dpZHRoKSB7XG4gICAgICAgICAgaGFzRm9sZGFibGVMaW5lID0gaGFzRm9sZGFibGVMaW5lIHx8XG4gICAgICAgICAgICAvLyBGb2xkYWJsZSBsaW5lID0gdG9vIGxvbmcsIGFuZCBub3QgbW9yZS1pbmRlbnRlZC5cbiAgICAgICAgICAgIChpIC0gcHJldmlvdXNMaW5lQnJlYWsgLSAxID4gbGluZVdpZHRoICYmXG4gICAgICAgICAgICAgc3RyaW5nW3ByZXZpb3VzTGluZUJyZWFrICsgMV0gIT09ICcgJyk7XG4gICAgICAgICAgcHJldmlvdXNMaW5lQnJlYWsgPSBpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKCFpc1ByaW50YWJsZShjaGFyKSkge1xuICAgICAgICByZXR1cm4gU1RZTEVfRE9VQkxFO1xuICAgICAgfVxuICAgICAgcGxhaW4gPSBwbGFpbiAmJiBpc1BsYWluU2FmZShjaGFyKTtcbiAgICB9XG4gICAgLy8gaW4gY2FzZSB0aGUgZW5kIGlzIG1pc3NpbmcgYSBcXG5cbiAgICBoYXNGb2xkYWJsZUxpbmUgPSBoYXNGb2xkYWJsZUxpbmUgfHwgKHNob3VsZFRyYWNrV2lkdGggJiZcbiAgICAgIChpIC0gcHJldmlvdXNMaW5lQnJlYWsgLSAxID4gbGluZVdpZHRoICYmXG4gICAgICAgc3RyaW5nW3ByZXZpb3VzTGluZUJyZWFrICsgMV0gIT09ICcgJykpO1xuICB9XG4gIC8vIEFsdGhvdWdoIGV2ZXJ5IHN0eWxlIGNhbiByZXByZXNlbnQgXFxuIHdpdGhvdXQgZXNjYXBpbmcsIHByZWZlciBibG9jayBzdHlsZXNcbiAgLy8gZm9yIG11bHRpbGluZSwgc2luY2UgdGhleSdyZSBtb3JlIHJlYWRhYmxlIGFuZCB0aGV5IGRvbid0IGFkZCBlbXB0eSBsaW5lcy5cbiAgLy8gQWxzbyBwcmVmZXIgZm9sZGluZyBhIHN1cGVyLWxvbmcgbGluZS5cbiAgaWYgKCFoYXNMaW5lQnJlYWsgJiYgIWhhc0ZvbGRhYmxlTGluZSkge1xuICAgIC8vIFN0cmluZ3MgaW50ZXJwcmV0YWJsZSBhcyBhbm90aGVyIHR5cGUgaGF2ZSB0byBiZSBxdW90ZWQ7XG4gICAgLy8gZS5nLiB0aGUgc3RyaW5nICd0cnVlJyB2cy4gdGhlIGJvb2xlYW4gdHJ1ZS5cbiAgICByZXR1cm4gcGxhaW4gJiYgIXRlc3RBbWJpZ3VvdXNUeXBlKHN0cmluZylcbiAgICAgID8gU1RZTEVfUExBSU4gOiBTVFlMRV9TSU5HTEU7XG4gIH1cbiAgLy8gRWRnZSBjYXNlOiBibG9jayBpbmRlbnRhdGlvbiBpbmRpY2F0b3IgY2FuIG9ubHkgaGF2ZSBvbmUgZGlnaXQuXG4gIGlmIChzdHJpbmdbMF0gPT09ICcgJyAmJiBpbmRlbnRQZXJMZXZlbCA+IDkpIHtcbiAgICByZXR1cm4gU1RZTEVfRE9VQkxFO1xuICB9XG4gIC8vIEF0IHRoaXMgcG9pbnQgd2Uga25vdyBibG9jayBzdHlsZXMgYXJlIHZhbGlkLlxuICAvLyBQcmVmZXIgbGl0ZXJhbCBzdHlsZSB1bmxlc3Mgd2Ugd2FudCB0byBmb2xkLlxuICByZXR1cm4gaGFzRm9sZGFibGVMaW5lID8gU1RZTEVfRk9MREVEIDogU1RZTEVfTElURVJBTDtcbn1cblxuLy8gTm90ZTogbGluZSBicmVha2luZy9mb2xkaW5nIGlzIGltcGxlbWVudGVkIGZvciBvbmx5IHRoZSBmb2xkZWQgc3R5bGUuXG4vLyBOQi4gV2UgZHJvcCB0aGUgbGFzdCB0cmFpbGluZyBuZXdsaW5lIChpZiBhbnkpIG9mIGEgcmV0dXJuZWQgYmxvY2sgc2NhbGFyXG4vLyAgc2luY2UgdGhlIGR1bXBlciBhZGRzIGl0cyBvd24gbmV3bGluZS4gVGhpcyBhbHdheXMgd29ya3M6XG4vLyAgICDigKIgTm8gZW5kaW5nIG5ld2xpbmUgPT4gdW5hZmZlY3RlZDsgYWxyZWFkeSB1c2luZyBzdHJpcCBcIi1cIiBjaG9tcGluZy5cbi8vICAgIOKAoiBFbmRpbmcgbmV3bGluZSAgICA9PiByZW1vdmVkIHRoZW4gcmVzdG9yZWQuXG4vLyAgSW1wb3J0YW50bHksIHRoaXMga2VlcHMgdGhlIFwiK1wiIGNob21wIGluZGljYXRvciBmcm9tIGdhaW5pbmcgYW4gZXh0cmEgbGluZS5cbmZ1bmN0aW9uIHdyaXRlU2NhbGFyKHN0YXRlLCBzdHJpbmcsIGxldmVsLCBpc2tleSkge1xuICBzdGF0ZS5kdW1wID0gKGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoc3RyaW5nLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuIFwiJydcIjtcbiAgICB9XG4gICAgaWYgKCFzdGF0ZS5ub0NvbXBhdE1vZGUgJiZcbiAgICAgICAgREVQUkVDQVRFRF9CT09MRUFOU19TWU5UQVguaW5kZXhPZihzdHJpbmcpICE9PSAtMSkge1xuICAgICAgcmV0dXJuIFwiJ1wiICsgc3RyaW5nICsgXCInXCI7XG4gICAgfVxuXG4gICAgdmFyIGluZGVudCA9IHN0YXRlLmluZGVudCAqIE1hdGgubWF4KDEsIGxldmVsKTsgLy8gbm8gMC1pbmRlbnQgc2NhbGFyc1xuICAgIC8vIEFzIGluZGVudGF0aW9uIGdldHMgZGVlcGVyLCBsZXQgdGhlIHdpZHRoIGRlY3JlYXNlIG1vbm90b25pY2FsbHlcbiAgICAvLyB0byB0aGUgbG93ZXIgYm91bmQgbWluKHN0YXRlLmxpbmVXaWR0aCwgNDApLlxuICAgIC8vIE5vdGUgdGhhdCB0aGlzIGltcGxpZXNcbiAgICAvLyAgc3RhdGUubGluZVdpZHRoIOKJpCA0MCArIHN0YXRlLmluZGVudDogd2lkdGggaXMgZml4ZWQgYXQgdGhlIGxvd2VyIGJvdW5kLlxuICAgIC8vICBzdGF0ZS5saW5lV2lkdGggPiA0MCArIHN0YXRlLmluZGVudDogd2lkdGggZGVjcmVhc2VzIHVudGlsIHRoZSBsb3dlciBib3VuZC5cbiAgICAvLyBUaGlzIGJlaGF2ZXMgYmV0dGVyIHRoYW4gYSBjb25zdGFudCBtaW5pbXVtIHdpZHRoIHdoaWNoIGRpc2FsbG93cyBuYXJyb3dlciBvcHRpb25zLFxuICAgIC8vIG9yIGFuIGluZGVudCB0aHJlc2hvbGQgd2hpY2ggY2F1c2VzIHRoZSB3aWR0aCB0byBzdWRkZW5seSBpbmNyZWFzZS5cbiAgICB2YXIgbGluZVdpZHRoID0gc3RhdGUubGluZVdpZHRoID09PSAtMVxuICAgICAgPyAtMSA6IE1hdGgubWF4KE1hdGgubWluKHN0YXRlLmxpbmVXaWR0aCwgNDApLCBzdGF0ZS5saW5lV2lkdGggLSBpbmRlbnQpO1xuXG4gICAgLy8gV2l0aG91dCBrbm93aW5nIGlmIGtleXMgYXJlIGltcGxpY2l0L2V4cGxpY2l0LCBhc3N1bWUgaW1wbGljaXQgZm9yIHNhZmV0eS5cbiAgICB2YXIgc2luZ2xlTGluZU9ubHkgPSBpc2tleVxuICAgICAgLy8gTm8gYmxvY2sgc3R5bGVzIGluIGZsb3cgbW9kZS5cbiAgICAgIHx8IChzdGF0ZS5mbG93TGV2ZWwgPiAtMSAmJiBsZXZlbCA+PSBzdGF0ZS5mbG93TGV2ZWwpO1xuICAgIGZ1bmN0aW9uIHRlc3RBbWJpZ3VpdHkoc3RyaW5nKSB7XG4gICAgICByZXR1cm4gdGVzdEltcGxpY2l0UmVzb2x2aW5nKHN0YXRlLCBzdHJpbmcpO1xuICAgIH1cblxuICAgIHN3aXRjaCAoY2hvb3NlU2NhbGFyU3R5bGUoc3RyaW5nLCBzaW5nbGVMaW5lT25seSwgc3RhdGUuaW5kZW50LCBsaW5lV2lkdGgsIHRlc3RBbWJpZ3VpdHkpKSB7XG4gICAgICBjYXNlIFNUWUxFX1BMQUlOOlxuICAgICAgICByZXR1cm4gc3RyaW5nO1xuICAgICAgY2FzZSBTVFlMRV9TSU5HTEU6XG4gICAgICAgIHJldHVybiBcIidcIiArIHN0cmluZy5yZXBsYWNlKC8nL2csIFwiJydcIikgKyBcIidcIjtcbiAgICAgIGNhc2UgU1RZTEVfTElURVJBTDpcbiAgICAgICAgcmV0dXJuICd8JyArIGJsb2NrSGVhZGVyKHN0cmluZywgc3RhdGUuaW5kZW50KVxuICAgICAgICAgICsgZHJvcEVuZGluZ05ld2xpbmUoaW5kZW50U3RyaW5nKHN0cmluZywgaW5kZW50KSk7XG4gICAgICBjYXNlIFNUWUxFX0ZPTERFRDpcbiAgICAgICAgcmV0dXJuICc+JyArIGJsb2NrSGVhZGVyKHN0cmluZywgc3RhdGUuaW5kZW50KVxuICAgICAgICAgICsgZHJvcEVuZGluZ05ld2xpbmUoaW5kZW50U3RyaW5nKGZvbGRTdHJpbmcoc3RyaW5nLCBsaW5lV2lkdGgpLCBpbmRlbnQpKTtcbiAgICAgIGNhc2UgU1RZTEVfRE9VQkxFOlxuICAgICAgICByZXR1cm4gJ1wiJyArIGVzY2FwZVN0cmluZyhzdHJpbmcsIGxpbmVXaWR0aCkgKyAnXCInO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhyb3cgbmV3IFlBTUxFeGNlcHRpb24oJ2ltcG9zc2libGUgZXJyb3I6IGludmFsaWQgc2NhbGFyIHN0eWxlJyk7XG4gICAgfVxuICB9KCkpO1xufVxuXG4vLyBQcmUtY29uZGl0aW9uczogc3RyaW5nIGlzIHZhbGlkIGZvciBhIGJsb2NrIHNjYWxhciwgMSA8PSBpbmRlbnRQZXJMZXZlbCA8PSA5LlxuZnVuY3Rpb24gYmxvY2tIZWFkZXIoc3RyaW5nLCBpbmRlbnRQZXJMZXZlbCkge1xuICB2YXIgaW5kZW50SW5kaWNhdG9yID0gKHN0cmluZ1swXSA9PT0gJyAnKSA/IFN0cmluZyhpbmRlbnRQZXJMZXZlbCkgOiAnJztcblxuICAvLyBub3RlIHRoZSBzcGVjaWFsIGNhc2U6IHRoZSBzdHJpbmcgJ1xcbicgY291bnRzIGFzIGEgXCJ0cmFpbGluZ1wiIGVtcHR5IGxpbmUuXG4gIHZhciBjbGlwID0gICAgICAgICAgc3RyaW5nW3N0cmluZy5sZW5ndGggLSAxXSA9PT0gJ1xcbic7XG4gIHZhciBrZWVwID0gY2xpcCAmJiAoc3RyaW5nW3N0cmluZy5sZW5ndGggLSAyXSA9PT0gJ1xcbicgfHwgc3RyaW5nID09PSAnXFxuJyk7XG4gIHZhciBjaG9tcCA9IGtlZXAgPyAnKycgOiAoY2xpcCA/ICcnIDogJy0nKTtcblxuICByZXR1cm4gaW5kZW50SW5kaWNhdG9yICsgY2hvbXAgKyAnXFxuJztcbn1cblxuLy8gKFNlZSB0aGUgbm90ZSBmb3Igd3JpdGVTY2FsYXIuKVxuZnVuY3Rpb24gZHJvcEVuZGluZ05ld2xpbmUoc3RyaW5nKSB7XG4gIHJldHVybiBzdHJpbmdbc3RyaW5nLmxlbmd0aCAtIDFdID09PSAnXFxuJyA/IHN0cmluZy5zbGljZSgwLCAtMSkgOiBzdHJpbmc7XG59XG5cbi8vIE5vdGU6IGEgbG9uZyBsaW5lIHdpdGhvdXQgYSBzdWl0YWJsZSBicmVhayBwb2ludCB3aWxsIGV4Y2VlZCB0aGUgd2lkdGggbGltaXQuXG4vLyBQcmUtY29uZGl0aW9uczogZXZlcnkgY2hhciBpbiBzdHIgaXNQcmludGFibGUsIHN0ci5sZW5ndGggPiAwLCB3aWR0aCA+IDAuXG5mdW5jdGlvbiBmb2xkU3RyaW5nKHN0cmluZywgd2lkdGgpIHtcbiAgLy8gSW4gZm9sZGVkIHN0eWxlLCAkayQgY29uc2VjdXRpdmUgbmV3bGluZXMgb3V0cHV0IGFzICRrKzEkIG5ld2xpbmVz4oCUXG4gIC8vIHVubGVzcyB0aGV5J3JlIGJlZm9yZSBvciBhZnRlciBhIG1vcmUtaW5kZW50ZWQgbGluZSwgb3IgYXQgdGhlIHZlcnlcbiAgLy8gYmVnaW5uaW5nIG9yIGVuZCwgaW4gd2hpY2ggY2FzZSAkayQgbWFwcyB0byAkayQuXG4gIC8vIFRoZXJlZm9yZSwgcGFyc2UgZWFjaCBjaHVuayBhcyBuZXdsaW5lKHMpIGZvbGxvd2VkIGJ5IGEgY29udGVudCBsaW5lLlxuICB2YXIgbGluZVJlID0gLyhcXG4rKShbXlxcbl0qKS9nO1xuXG4gIC8vIGZpcnN0IGxpbmUgKHBvc3NpYmx5IGFuIGVtcHR5IGxpbmUpXG4gIHZhciByZXN1bHQgPSAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBuZXh0TEYgPSBzdHJpbmcuaW5kZXhPZignXFxuJyk7XG4gICAgbmV4dExGID0gbmV4dExGICE9PSAtMSA/IG5leHRMRiA6IHN0cmluZy5sZW5ndGg7XG4gICAgbGluZVJlLmxhc3RJbmRleCA9IG5leHRMRjtcbiAgICByZXR1cm4gZm9sZExpbmUoc3RyaW5nLnNsaWNlKDAsIG5leHRMRiksIHdpZHRoKTtcbiAgfSgpKTtcbiAgLy8gSWYgd2UgaGF2ZW4ndCByZWFjaGVkIHRoZSBmaXJzdCBjb250ZW50IGxpbmUgeWV0LCBkb24ndCBhZGQgYW4gZXh0cmEgXFxuLlxuICB2YXIgcHJldk1vcmVJbmRlbnRlZCA9IHN0cmluZ1swXSA9PT0gJ1xcbicgfHwgc3RyaW5nWzBdID09PSAnICc7XG4gIHZhciBtb3JlSW5kZW50ZWQ7XG5cbiAgLy8gcmVzdCBvZiB0aGUgbGluZXNcbiAgdmFyIG1hdGNoO1xuICB3aGlsZSAoKG1hdGNoID0gbGluZVJlLmV4ZWMoc3RyaW5nKSkpIHtcbiAgICB2YXIgcHJlZml4ID0gbWF0Y2hbMV0sIGxpbmUgPSBtYXRjaFsyXTtcbiAgICBtb3JlSW5kZW50ZWQgPSAobGluZVswXSA9PT0gJyAnKTtcbiAgICByZXN1bHQgKz0gcHJlZml4XG4gICAgICArICghcHJldk1vcmVJbmRlbnRlZCAmJiAhbW9yZUluZGVudGVkICYmIGxpbmUgIT09ICcnXG4gICAgICAgID8gJ1xcbicgOiAnJylcbiAgICAgICsgZm9sZExpbmUobGluZSwgd2lkdGgpO1xuICAgIHByZXZNb3JlSW5kZW50ZWQgPSBtb3JlSW5kZW50ZWQ7XG4gIH1cblxuICByZXR1cm4gcmVzdWx0O1xufVxuXG4vLyBHcmVlZHkgbGluZSBicmVha2luZy5cbi8vIFBpY2tzIHRoZSBsb25nZXN0IGxpbmUgdW5kZXIgdGhlIGxpbWl0IGVhY2ggdGltZSxcbi8vIG90aGVyd2lzZSBzZXR0bGVzIGZvciB0aGUgc2hvcnRlc3QgbGluZSBvdmVyIHRoZSBsaW1pdC5cbi8vIE5CLiBNb3JlLWluZGVudGVkIGxpbmVzICpjYW5ub3QqIGJlIGZvbGRlZCwgYXMgdGhhdCB3b3VsZCBhZGQgYW4gZXh0cmEgXFxuLlxuZnVuY3Rpb24gZm9sZExpbmUobGluZSwgd2lkdGgpIHtcbiAgaWYgKGxpbmUgPT09ICcnIHx8IGxpbmVbMF0gPT09ICcgJykgcmV0dXJuIGxpbmU7XG5cbiAgLy8gU2luY2UgYSBtb3JlLWluZGVudGVkIGxpbmUgYWRkcyBhIFxcbiwgYnJlYWtzIGNhbid0IGJlIGZvbGxvd2VkIGJ5IGEgc3BhY2UuXG4gIHZhciBicmVha1JlID0gLyBbXiBdL2c7IC8vIG5vdGU6IHRoZSBtYXRjaCBpbmRleCB3aWxsIGFsd2F5cyBiZSA8PSBsZW5ndGgtMi5cbiAgdmFyIG1hdGNoO1xuICAvLyBzdGFydCBpcyBhbiBpbmNsdXNpdmUgaW5kZXguIGVuZCwgY3VyciwgYW5kIG5leHQgYXJlIGV4Y2x1c2l2ZS5cbiAgdmFyIHN0YXJ0ID0gMCwgZW5kLCBjdXJyID0gMCwgbmV4dCA9IDA7XG4gIHZhciByZXN1bHQgPSAnJztcblxuICAvLyBJbnZhcmlhbnRzOiAwIDw9IHN0YXJ0IDw9IGxlbmd0aC0xLlxuICAvLyAgIDAgPD0gY3VyciA8PSBuZXh0IDw9IG1heCgwLCBsZW5ndGgtMikuIGN1cnIgLSBzdGFydCA8PSB3aWR0aC5cbiAgLy8gSW5zaWRlIHRoZSBsb29wOlxuICAvLyAgIEEgbWF0Y2ggaW1wbGllcyBsZW5ndGggPj0gMiwgc28gY3VyciBhbmQgbmV4dCBhcmUgPD0gbGVuZ3RoLTIuXG4gIHdoaWxlICgobWF0Y2ggPSBicmVha1JlLmV4ZWMobGluZSkpKSB7XG4gICAgbmV4dCA9IG1hdGNoLmluZGV4O1xuICAgIC8vIG1haW50YWluIGludmFyaWFudDogY3VyciAtIHN0YXJ0IDw9IHdpZHRoXG4gICAgaWYgKG5leHQgLSBzdGFydCA+IHdpZHRoKSB7XG4gICAgICBlbmQgPSAoY3VyciA+IHN0YXJ0KSA/IGN1cnIgOiBuZXh0OyAvLyBkZXJpdmUgZW5kIDw9IGxlbmd0aC0yXG4gICAgICByZXN1bHQgKz0gJ1xcbicgKyBsaW5lLnNsaWNlKHN0YXJ0LCBlbmQpO1xuICAgICAgLy8gc2tpcCB0aGUgc3BhY2UgdGhhdCB3YXMgb3V0cHV0IGFzIFxcblxuICAgICAgc3RhcnQgPSBlbmQgKyAxOyAgICAgICAgICAgICAgICAgICAgLy8gZGVyaXZlIHN0YXJ0IDw9IGxlbmd0aC0xXG4gICAgfVxuICAgIGN1cnIgPSBuZXh0O1xuICB9XG5cbiAgLy8gQnkgdGhlIGludmFyaWFudHMsIHN0YXJ0IDw9IGxlbmd0aC0xLCBzbyB0aGVyZSBpcyBzb21ldGhpbmcgbGVmdCBvdmVyLlxuICAvLyBJdCBpcyBlaXRoZXIgdGhlIHdob2xlIHN0cmluZyBvciBhIHBhcnQgc3RhcnRpbmcgZnJvbSBub24td2hpdGVzcGFjZS5cbiAgcmVzdWx0ICs9ICdcXG4nO1xuICAvLyBJbnNlcnQgYSBicmVhayBpZiB0aGUgcmVtYWluZGVyIGlzIHRvbyBsb25nIGFuZCB0aGVyZSBpcyBhIGJyZWFrIGF2YWlsYWJsZS5cbiAgaWYgKGxpbmUubGVuZ3RoIC0gc3RhcnQgPiB3aWR0aCAmJiBjdXJyID4gc3RhcnQpIHtcbiAgICByZXN1bHQgKz0gbGluZS5zbGljZShzdGFydCwgY3VycikgKyAnXFxuJyArIGxpbmUuc2xpY2UoY3VyciArIDEpO1xuICB9IGVsc2Uge1xuICAgIHJlc3VsdCArPSBsaW5lLnNsaWNlKHN0YXJ0KTtcbiAgfVxuXG4gIHJldHVybiByZXN1bHQuc2xpY2UoMSk7IC8vIGRyb3AgZXh0cmEgXFxuIGpvaW5lclxufVxuXG4vLyBFc2NhcGVzIGEgZG91YmxlLXF1b3RlZCBzdHJpbmcuXG5mdW5jdGlvbiBlc2NhcGVTdHJpbmcoc3RyaW5nKSB7XG4gIHZhciByZXN1bHQgPSAnJztcbiAgdmFyIGNoYXIsIG5leHRDaGFyO1xuICB2YXIgZXNjYXBlU2VxO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgc3RyaW5nLmxlbmd0aDsgaSsrKSB7XG4gICAgY2hhciA9IHN0cmluZy5jaGFyQ29kZUF0KGkpO1xuICAgIC8vIENoZWNrIGZvciBzdXJyb2dhdGUgcGFpcnMgKHJlZmVyZW5jZSBVbmljb2RlIDMuMCBzZWN0aW9uIFwiMy43IFN1cnJvZ2F0ZXNcIikuXG4gICAgaWYgKGNoYXIgPj0gMHhEODAwICYmIGNoYXIgPD0gMHhEQkZGLyogaGlnaCBzdXJyb2dhdGUgKi8pIHtcbiAgICAgIG5leHRDaGFyID0gc3RyaW5nLmNoYXJDb2RlQXQoaSArIDEpO1xuICAgICAgaWYgKG5leHRDaGFyID49IDB4REMwMCAmJiBuZXh0Q2hhciA8PSAweERGRkYvKiBsb3cgc3Vycm9nYXRlICovKSB7XG4gICAgICAgIC8vIENvbWJpbmUgdGhlIHN1cnJvZ2F0ZSBwYWlyIGFuZCBzdG9yZSBpdCBlc2NhcGVkLlxuICAgICAgICByZXN1bHQgKz0gZW5jb2RlSGV4KChjaGFyIC0gMHhEODAwKSAqIDB4NDAwICsgbmV4dENoYXIgLSAweERDMDAgKyAweDEwMDAwKTtcbiAgICAgICAgLy8gQWR2YW5jZSBpbmRleCBvbmUgZXh0cmEgc2luY2Ugd2UgYWxyZWFkeSB1c2VkIHRoYXQgY2hhciBoZXJlLlxuICAgICAgICBpKys7IGNvbnRpbnVlO1xuICAgICAgfVxuICAgIH1cbiAgICBlc2NhcGVTZXEgPSBFU0NBUEVfU0VRVUVOQ0VTW2NoYXJdO1xuICAgIHJlc3VsdCArPSAhZXNjYXBlU2VxICYmIGlzUHJpbnRhYmxlKGNoYXIpXG4gICAgICA/IHN0cmluZ1tpXVxuICAgICAgOiBlc2NhcGVTZXEgfHwgZW5jb2RlSGV4KGNoYXIpO1xuICB9XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuZnVuY3Rpb24gd3JpdGVGbG93U2VxdWVuY2Uoc3RhdGUsIGxldmVsLCBvYmplY3QpIHtcbiAgdmFyIF9yZXN1bHQgPSAnJyxcbiAgICAgIF90YWcgICAgPSBzdGF0ZS50YWcsXG4gICAgICBpbmRleCxcbiAgICAgIGxlbmd0aDtcblxuICBmb3IgKGluZGV4ID0gMCwgbGVuZ3RoID0gb2JqZWN0Lmxlbmd0aDsgaW5kZXggPCBsZW5ndGg7IGluZGV4ICs9IDEpIHtcbiAgICAvLyBXcml0ZSBvbmx5IHZhbGlkIGVsZW1lbnRzLlxuICAgIGlmICh3cml0ZU5vZGUoc3RhdGUsIGxldmVsLCBvYmplY3RbaW5kZXhdLCBmYWxzZSwgZmFsc2UpKSB7XG4gICAgICBpZiAoaW5kZXggIT09IDApIF9yZXN1bHQgKz0gJywnICsgKCFzdGF0ZS5jb25kZW5zZUZsb3cgPyAnICcgOiAnJyk7XG4gICAgICBfcmVzdWx0ICs9IHN0YXRlLmR1bXA7XG4gICAgfVxuICB9XG5cbiAgc3RhdGUudGFnID0gX3RhZztcbiAgc3RhdGUuZHVtcCA9ICdbJyArIF9yZXN1bHQgKyAnXSc7XG59XG5cbmZ1bmN0aW9uIHdyaXRlQmxvY2tTZXF1ZW5jZShzdGF0ZSwgbGV2ZWwsIG9iamVjdCwgY29tcGFjdCkge1xuICB2YXIgX3Jlc3VsdCA9ICcnLFxuICAgICAgX3RhZyAgICA9IHN0YXRlLnRhZyxcbiAgICAgIGluZGV4LFxuICAgICAgbGVuZ3RoO1xuXG4gIGZvciAoaW5kZXggPSAwLCBsZW5ndGggPSBvYmplY3QubGVuZ3RoOyBpbmRleCA8IGxlbmd0aDsgaW5kZXggKz0gMSkge1xuICAgIC8vIFdyaXRlIG9ubHkgdmFsaWQgZWxlbWVudHMuXG4gICAgaWYgKHdyaXRlTm9kZShzdGF0ZSwgbGV2ZWwgKyAxLCBvYmplY3RbaW5kZXhdLCB0cnVlLCB0cnVlKSkge1xuICAgICAgaWYgKCFjb21wYWN0IHx8IGluZGV4ICE9PSAwKSB7XG4gICAgICAgIF9yZXN1bHQgKz0gZ2VuZXJhdGVOZXh0TGluZShzdGF0ZSwgbGV2ZWwpO1xuICAgICAgfVxuXG4gICAgICBpZiAoc3RhdGUuZHVtcCAmJiBDSEFSX0xJTkVfRkVFRCA9PT0gc3RhdGUuZHVtcC5jaGFyQ29kZUF0KDApKSB7XG4gICAgICAgIF9yZXN1bHQgKz0gJy0nO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgX3Jlc3VsdCArPSAnLSAnO1xuICAgICAgfVxuXG4gICAgICBfcmVzdWx0ICs9IHN0YXRlLmR1bXA7XG4gICAgfVxuICB9XG5cbiAgc3RhdGUudGFnID0gX3RhZztcbiAgc3RhdGUuZHVtcCA9IF9yZXN1bHQgfHwgJ1tdJzsgLy8gRW1wdHkgc2VxdWVuY2UgaWYgbm8gdmFsaWQgdmFsdWVzLlxufVxuXG5mdW5jdGlvbiB3cml0ZUZsb3dNYXBwaW5nKHN0YXRlLCBsZXZlbCwgb2JqZWN0KSB7XG4gIHZhciBfcmVzdWx0ICAgICAgID0gJycsXG4gICAgICBfdGFnICAgICAgICAgID0gc3RhdGUudGFnLFxuICAgICAgb2JqZWN0S2V5TGlzdCA9IE9iamVjdC5rZXlzKG9iamVjdCksXG4gICAgICBpbmRleCxcbiAgICAgIGxlbmd0aCxcbiAgICAgIG9iamVjdEtleSxcbiAgICAgIG9iamVjdFZhbHVlLFxuICAgICAgcGFpckJ1ZmZlcjtcblxuICBmb3IgKGluZGV4ID0gMCwgbGVuZ3RoID0gb2JqZWN0S2V5TGlzdC5sZW5ndGg7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCArPSAxKSB7XG4gICAgcGFpckJ1ZmZlciA9IHN0YXRlLmNvbmRlbnNlRmxvdyA/ICdcIicgOiAnJztcblxuICAgIGlmIChpbmRleCAhPT0gMCkgcGFpckJ1ZmZlciArPSAnLCAnO1xuXG4gICAgb2JqZWN0S2V5ID0gb2JqZWN0S2V5TGlzdFtpbmRleF07XG4gICAgb2JqZWN0VmFsdWUgPSBvYmplY3Rbb2JqZWN0S2V5XTtcblxuICAgIGlmICghd3JpdGVOb2RlKHN0YXRlLCBsZXZlbCwgb2JqZWN0S2V5LCBmYWxzZSwgZmFsc2UpKSB7XG4gICAgICBjb250aW51ZTsgLy8gU2tpcCB0aGlzIHBhaXIgYmVjYXVzZSBvZiBpbnZhbGlkIGtleTtcbiAgICB9XG5cbiAgICBpZiAoc3RhdGUuZHVtcC5sZW5ndGggPiAxMDI0KSBwYWlyQnVmZmVyICs9ICc/ICc7XG5cbiAgICBwYWlyQnVmZmVyICs9IHN0YXRlLmR1bXAgKyAoc3RhdGUuY29uZGVuc2VGbG93ID8gJ1wiJyA6ICcnKSArICc6JyArIChzdGF0ZS5jb25kZW5zZUZsb3cgPyAnJyA6ICcgJyk7XG5cbiAgICBpZiAoIXdyaXRlTm9kZShzdGF0ZSwgbGV2ZWwsIG9iamVjdFZhbHVlLCBmYWxzZSwgZmFsc2UpKSB7XG4gICAgICBjb250aW51ZTsgLy8gU2tpcCB0aGlzIHBhaXIgYmVjYXVzZSBvZiBpbnZhbGlkIHZhbHVlLlxuICAgIH1cblxuICAgIHBhaXJCdWZmZXIgKz0gc3RhdGUuZHVtcDtcblxuICAgIC8vIEJvdGgga2V5IGFuZCB2YWx1ZSBhcmUgdmFsaWQuXG4gICAgX3Jlc3VsdCArPSBwYWlyQnVmZmVyO1xuICB9XG5cbiAgc3RhdGUudGFnID0gX3RhZztcbiAgc3RhdGUuZHVtcCA9ICd7JyArIF9yZXN1bHQgKyAnfSc7XG59XG5cbmZ1bmN0aW9uIHdyaXRlQmxvY2tNYXBwaW5nKHN0YXRlLCBsZXZlbCwgb2JqZWN0LCBjb21wYWN0KSB7XG4gIHZhciBfcmVzdWx0ICAgICAgID0gJycsXG4gICAgICBfdGFnICAgICAgICAgID0gc3RhdGUudGFnLFxuICAgICAgb2JqZWN0S2V5TGlzdCA9IE9iamVjdC5rZXlzKG9iamVjdCksXG4gICAgICBpbmRleCxcbiAgICAgIGxlbmd0aCxcbiAgICAgIG9iamVjdEtleSxcbiAgICAgIG9iamVjdFZhbHVlLFxuICAgICAgZXhwbGljaXRQYWlyLFxuICAgICAgcGFpckJ1ZmZlcjtcblxuICAvLyBBbGxvdyBzb3J0aW5nIGtleXMgc28gdGhhdCB0aGUgb3V0cHV0IGZpbGUgaXMgZGV0ZXJtaW5pc3RpY1xuICBpZiAoc3RhdGUuc29ydEtleXMgPT09IHRydWUpIHtcbiAgICAvLyBEZWZhdWx0IHNvcnRpbmdcbiAgICBvYmplY3RLZXlMaXN0LnNvcnQoKTtcbiAgfSBlbHNlIGlmICh0eXBlb2Ygc3RhdGUuc29ydEtleXMgPT09ICdmdW5jdGlvbicpIHtcbiAgICAvLyBDdXN0b20gc29ydCBmdW5jdGlvblxuICAgIG9iamVjdEtleUxpc3Quc29ydChzdGF0ZS5zb3J0S2V5cyk7XG4gIH0gZWxzZSBpZiAoc3RhdGUuc29ydEtleXMpIHtcbiAgICAvLyBTb21ldGhpbmcgaXMgd3JvbmdcbiAgICB0aHJvdyBuZXcgWUFNTEV4Y2VwdGlvbignc29ydEtleXMgbXVzdCBiZSBhIGJvb2xlYW4gb3IgYSBmdW5jdGlvbicpO1xuICB9XG5cbiAgZm9yIChpbmRleCA9IDAsIGxlbmd0aCA9IG9iamVjdEtleUxpc3QubGVuZ3RoOyBpbmRleCA8IGxlbmd0aDsgaW5kZXggKz0gMSkge1xuICAgIHBhaXJCdWZmZXIgPSAnJztcblxuICAgIGlmICghY29tcGFjdCB8fCBpbmRleCAhPT0gMCkge1xuICAgICAgcGFpckJ1ZmZlciArPSBnZW5lcmF0ZU5leHRMaW5lKHN0YXRlLCBsZXZlbCk7XG4gICAgfVxuXG4gICAgb2JqZWN0S2V5ID0gb2JqZWN0S2V5TGlzdFtpbmRleF07XG4gICAgb2JqZWN0VmFsdWUgPSBvYmplY3Rbb2JqZWN0S2V5XTtcblxuICAgIGlmICghd3JpdGVOb2RlKHN0YXRlLCBsZXZlbCArIDEsIG9iamVjdEtleSwgdHJ1ZSwgdHJ1ZSwgdHJ1ZSkpIHtcbiAgICAgIGNvbnRpbnVlOyAvLyBTa2lwIHRoaXMgcGFpciBiZWNhdXNlIG9mIGludmFsaWQga2V5LlxuICAgIH1cblxuICAgIGV4cGxpY2l0UGFpciA9IChzdGF0ZS50YWcgIT09IG51bGwgJiYgc3RhdGUudGFnICE9PSAnPycpIHx8XG4gICAgICAgICAgICAgICAgICAgKHN0YXRlLmR1bXAgJiYgc3RhdGUuZHVtcC5sZW5ndGggPiAxMDI0KTtcblxuICAgIGlmIChleHBsaWNpdFBhaXIpIHtcbiAgICAgIGlmIChzdGF0ZS5kdW1wICYmIENIQVJfTElORV9GRUVEID09PSBzdGF0ZS5kdW1wLmNoYXJDb2RlQXQoMCkpIHtcbiAgICAgICAgcGFpckJ1ZmZlciArPSAnPyc7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwYWlyQnVmZmVyICs9ICc/ICc7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcGFpckJ1ZmZlciArPSBzdGF0ZS5kdW1wO1xuXG4gICAgaWYgKGV4cGxpY2l0UGFpcikge1xuICAgICAgcGFpckJ1ZmZlciArPSBnZW5lcmF0ZU5leHRMaW5lKHN0YXRlLCBsZXZlbCk7XG4gICAgfVxuXG4gICAgaWYgKCF3cml0ZU5vZGUoc3RhdGUsIGxldmVsICsgMSwgb2JqZWN0VmFsdWUsIHRydWUsIGV4cGxpY2l0UGFpcikpIHtcbiAgICAgIGNvbnRpbnVlOyAvLyBTa2lwIHRoaXMgcGFpciBiZWNhdXNlIG9mIGludmFsaWQgdmFsdWUuXG4gICAgfVxuXG4gICAgaWYgKHN0YXRlLmR1bXAgJiYgQ0hBUl9MSU5FX0ZFRUQgPT09IHN0YXRlLmR1bXAuY2hhckNvZGVBdCgwKSkge1xuICAgICAgcGFpckJ1ZmZlciArPSAnOic7XG4gICAgfSBlbHNlIHtcbiAgICAgIHBhaXJCdWZmZXIgKz0gJzogJztcbiAgICB9XG5cbiAgICBwYWlyQnVmZmVyICs9IHN0YXRlLmR1bXA7XG5cbiAgICAvLyBCb3RoIGtleSBhbmQgdmFsdWUgYXJlIHZhbGlkLlxuICAgIF9yZXN1bHQgKz0gcGFpckJ1ZmZlcjtcbiAgfVxuXG4gIHN0YXRlLnRhZyA9IF90YWc7XG4gIHN0YXRlLmR1bXAgPSBfcmVzdWx0IHx8ICd7fSc7IC8vIEVtcHR5IG1hcHBpbmcgaWYgbm8gdmFsaWQgcGFpcnMuXG59XG5cbmZ1bmN0aW9uIGRldGVjdFR5cGUoc3RhdGUsIG9iamVjdCwgZXhwbGljaXQpIHtcbiAgdmFyIF9yZXN1bHQsIHR5cGVMaXN0LCBpbmRleCwgbGVuZ3RoLCB0eXBlLCBzdHlsZTtcblxuICB0eXBlTGlzdCA9IGV4cGxpY2l0ID8gc3RhdGUuZXhwbGljaXRUeXBlcyA6IHN0YXRlLmltcGxpY2l0VHlwZXM7XG5cbiAgZm9yIChpbmRleCA9IDAsIGxlbmd0aCA9IHR5cGVMaXN0Lmxlbmd0aDsgaW5kZXggPCBsZW5ndGg7IGluZGV4ICs9IDEpIHtcbiAgICB0eXBlID0gdHlwZUxpc3RbaW5kZXhdO1xuXG4gICAgaWYgKCh0eXBlLmluc3RhbmNlT2YgIHx8IHR5cGUucHJlZGljYXRlKSAmJlxuICAgICAgICAoIXR5cGUuaW5zdGFuY2VPZiB8fCAoKHR5cGVvZiBvYmplY3QgPT09ICdvYmplY3QnKSAmJiAob2JqZWN0IGluc3RhbmNlb2YgdHlwZS5pbnN0YW5jZU9mKSkpICYmXG4gICAgICAgICghdHlwZS5wcmVkaWNhdGUgIHx8IHR5cGUucHJlZGljYXRlKG9iamVjdCkpKSB7XG5cbiAgICAgIHN0YXRlLnRhZyA9IGV4cGxpY2l0ID8gdHlwZS50YWcgOiAnPyc7XG5cbiAgICAgIGlmICh0eXBlLnJlcHJlc2VudCkge1xuICAgICAgICBzdHlsZSA9IHN0YXRlLnN0eWxlTWFwW3R5cGUudGFnXSB8fCB0eXBlLmRlZmF1bHRTdHlsZTtcblxuICAgICAgICBpZiAoX3RvU3RyaW5nLmNhbGwodHlwZS5yZXByZXNlbnQpID09PSAnW29iamVjdCBGdW5jdGlvbl0nKSB7XG4gICAgICAgICAgX3Jlc3VsdCA9IHR5cGUucmVwcmVzZW50KG9iamVjdCwgc3R5bGUpO1xuICAgICAgICB9IGVsc2UgaWYgKF9oYXNPd25Qcm9wZXJ0eS5jYWxsKHR5cGUucmVwcmVzZW50LCBzdHlsZSkpIHtcbiAgICAgICAgICBfcmVzdWx0ID0gdHlwZS5yZXByZXNlbnRbc3R5bGVdKG9iamVjdCwgc3R5bGUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRocm93IG5ldyBZQU1MRXhjZXB0aW9uKCchPCcgKyB0eXBlLnRhZyArICc+IHRhZyByZXNvbHZlciBhY2NlcHRzIG5vdCBcIicgKyBzdHlsZSArICdcIiBzdHlsZScpO1xuICAgICAgICB9XG5cbiAgICAgICAgc3RhdGUuZHVtcCA9IF9yZXN1bHQ7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxuLy8gU2VyaWFsaXplcyBgb2JqZWN0YCBhbmQgd3JpdGVzIGl0IHRvIGdsb2JhbCBgcmVzdWx0YC5cbi8vIFJldHVybnMgdHJ1ZSBvbiBzdWNjZXNzLCBvciBmYWxzZSBvbiBpbnZhbGlkIG9iamVjdC5cbi8vXG5mdW5jdGlvbiB3cml0ZU5vZGUoc3RhdGUsIGxldmVsLCBvYmplY3QsIGJsb2NrLCBjb21wYWN0LCBpc2tleSkge1xuICBzdGF0ZS50YWcgPSBudWxsO1xuICBzdGF0ZS5kdW1wID0gb2JqZWN0O1xuXG4gIGlmICghZGV0ZWN0VHlwZShzdGF0ZSwgb2JqZWN0LCBmYWxzZSkpIHtcbiAgICBkZXRlY3RUeXBlKHN0YXRlLCBvYmplY3QsIHRydWUpO1xuICB9XG5cbiAgdmFyIHR5cGUgPSBfdG9TdHJpbmcuY2FsbChzdGF0ZS5kdW1wKTtcblxuICBpZiAoYmxvY2spIHtcbiAgICBibG9jayA9IChzdGF0ZS5mbG93TGV2ZWwgPCAwIHx8IHN0YXRlLmZsb3dMZXZlbCA+IGxldmVsKTtcbiAgfVxuXG4gIHZhciBvYmplY3RPckFycmF5ID0gdHlwZSA9PT0gJ1tvYmplY3QgT2JqZWN0XScgfHwgdHlwZSA9PT0gJ1tvYmplY3QgQXJyYXldJyxcbiAgICAgIGR1cGxpY2F0ZUluZGV4LFxuICAgICAgZHVwbGljYXRlO1xuXG4gIGlmIChvYmplY3RPckFycmF5KSB7XG4gICAgZHVwbGljYXRlSW5kZXggPSBzdGF0ZS5kdXBsaWNhdGVzLmluZGV4T2Yob2JqZWN0KTtcbiAgICBkdXBsaWNhdGUgPSBkdXBsaWNhdGVJbmRleCAhPT0gLTE7XG4gIH1cblxuICBpZiAoKHN0YXRlLnRhZyAhPT0gbnVsbCAmJiBzdGF0ZS50YWcgIT09ICc/JykgfHwgZHVwbGljYXRlIHx8IChzdGF0ZS5pbmRlbnQgIT09IDIgJiYgbGV2ZWwgPiAwKSkge1xuICAgIGNvbXBhY3QgPSBmYWxzZTtcbiAgfVxuXG4gIGlmIChkdXBsaWNhdGUgJiYgc3RhdGUudXNlZER1cGxpY2F0ZXNbZHVwbGljYXRlSW5kZXhdKSB7XG4gICAgc3RhdGUuZHVtcCA9ICcqcmVmXycgKyBkdXBsaWNhdGVJbmRleDtcbiAgfSBlbHNlIHtcbiAgICBpZiAob2JqZWN0T3JBcnJheSAmJiBkdXBsaWNhdGUgJiYgIXN0YXRlLnVzZWREdXBsaWNhdGVzW2R1cGxpY2F0ZUluZGV4XSkge1xuICAgICAgc3RhdGUudXNlZER1cGxpY2F0ZXNbZHVwbGljYXRlSW5kZXhdID0gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKHR5cGUgPT09ICdbb2JqZWN0IE9iamVjdF0nKSB7XG4gICAgICBpZiAoYmxvY2sgJiYgKE9iamVjdC5rZXlzKHN0YXRlLmR1bXApLmxlbmd0aCAhPT0gMCkpIHtcbiAgICAgICAgd3JpdGVCbG9ja01hcHBpbmcoc3RhdGUsIGxldmVsLCBzdGF0ZS5kdW1wLCBjb21wYWN0KTtcbiAgICAgICAgaWYgKGR1cGxpY2F0ZSkge1xuICAgICAgICAgIHN0YXRlLmR1bXAgPSAnJnJlZl8nICsgZHVwbGljYXRlSW5kZXggKyBzdGF0ZS5kdW1wO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB3cml0ZUZsb3dNYXBwaW5nKHN0YXRlLCBsZXZlbCwgc3RhdGUuZHVtcCk7XG4gICAgICAgIGlmIChkdXBsaWNhdGUpIHtcbiAgICAgICAgICBzdGF0ZS5kdW1wID0gJyZyZWZfJyArIGR1cGxpY2F0ZUluZGV4ICsgJyAnICsgc3RhdGUuZHVtcDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gJ1tvYmplY3QgQXJyYXldJykge1xuICAgICAgaWYgKGJsb2NrICYmIChzdGF0ZS5kdW1wLmxlbmd0aCAhPT0gMCkpIHtcbiAgICAgICAgd3JpdGVCbG9ja1NlcXVlbmNlKHN0YXRlLCBsZXZlbCwgc3RhdGUuZHVtcCwgY29tcGFjdCk7XG4gICAgICAgIGlmIChkdXBsaWNhdGUpIHtcbiAgICAgICAgICBzdGF0ZS5kdW1wID0gJyZyZWZfJyArIGR1cGxpY2F0ZUluZGV4ICsgc3RhdGUuZHVtcDtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgd3JpdGVGbG93U2VxdWVuY2Uoc3RhdGUsIGxldmVsLCBzdGF0ZS5kdW1wKTtcbiAgICAgICAgaWYgKGR1cGxpY2F0ZSkge1xuICAgICAgICAgIHN0YXRlLmR1bXAgPSAnJnJlZl8nICsgZHVwbGljYXRlSW5kZXggKyAnICcgKyBzdGF0ZS5kdW1wO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICh0eXBlID09PSAnW29iamVjdCBTdHJpbmddJykge1xuICAgICAgaWYgKHN0YXRlLnRhZyAhPT0gJz8nKSB7XG4gICAgICAgIHdyaXRlU2NhbGFyKHN0YXRlLCBzdGF0ZS5kdW1wLCBsZXZlbCwgaXNrZXkpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoc3RhdGUuc2tpcEludmFsaWQpIHJldHVybiBmYWxzZTtcbiAgICAgIHRocm93IG5ldyBZQU1MRXhjZXB0aW9uKCd1bmFjY2VwdGFibGUga2luZCBvZiBhbiBvYmplY3QgdG8gZHVtcCAnICsgdHlwZSk7XG4gICAgfVxuXG4gICAgaWYgKHN0YXRlLnRhZyAhPT0gbnVsbCAmJiBzdGF0ZS50YWcgIT09ICc/Jykge1xuICAgICAgc3RhdGUuZHVtcCA9ICchPCcgKyBzdGF0ZS50YWcgKyAnPiAnICsgc3RhdGUuZHVtcDtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gZ2V0RHVwbGljYXRlUmVmZXJlbmNlcyhvYmplY3QsIHN0YXRlKSB7XG4gIHZhciBvYmplY3RzID0gW10sXG4gICAgICBkdXBsaWNhdGVzSW5kZXhlcyA9IFtdLFxuICAgICAgaW5kZXgsXG4gICAgICBsZW5ndGg7XG5cbiAgaW5zcGVjdE5vZGUob2JqZWN0LCBvYmplY3RzLCBkdXBsaWNhdGVzSW5kZXhlcyk7XG5cbiAgZm9yIChpbmRleCA9IDAsIGxlbmd0aCA9IGR1cGxpY2F0ZXNJbmRleGVzLmxlbmd0aDsgaW5kZXggPCBsZW5ndGg7IGluZGV4ICs9IDEpIHtcbiAgICBzdGF0ZS5kdXBsaWNhdGVzLnB1c2gob2JqZWN0c1tkdXBsaWNhdGVzSW5kZXhlc1tpbmRleF1dKTtcbiAgfVxuICBzdGF0ZS51c2VkRHVwbGljYXRlcyA9IG5ldyBBcnJheShsZW5ndGgpO1xufVxuXG5mdW5jdGlvbiBpbnNwZWN0Tm9kZShvYmplY3QsIG9iamVjdHMsIGR1cGxpY2F0ZXNJbmRleGVzKSB7XG4gIHZhciBvYmplY3RLZXlMaXN0LFxuICAgICAgaW5kZXgsXG4gICAgICBsZW5ndGg7XG5cbiAgaWYgKG9iamVjdCAhPT0gbnVsbCAmJiB0eXBlb2Ygb2JqZWN0ID09PSAnb2JqZWN0Jykge1xuICAgIGluZGV4ID0gb2JqZWN0cy5pbmRleE9mKG9iamVjdCk7XG4gICAgaWYgKGluZGV4ICE9PSAtMSkge1xuICAgICAgaWYgKGR1cGxpY2F0ZXNJbmRleGVzLmluZGV4T2YoaW5kZXgpID09PSAtMSkge1xuICAgICAgICBkdXBsaWNhdGVzSW5kZXhlcy5wdXNoKGluZGV4KTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgb2JqZWN0cy5wdXNoKG9iamVjdCk7XG5cbiAgICAgIGlmIChBcnJheS5pc0FycmF5KG9iamVjdCkpIHtcbiAgICAgICAgZm9yIChpbmRleCA9IDAsIGxlbmd0aCA9IG9iamVjdC5sZW5ndGg7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCArPSAxKSB7XG4gICAgICAgICAgaW5zcGVjdE5vZGUob2JqZWN0W2luZGV4XSwgb2JqZWN0cywgZHVwbGljYXRlc0luZGV4ZXMpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBvYmplY3RLZXlMaXN0ID0gT2JqZWN0LmtleXMob2JqZWN0KTtcblxuICAgICAgICBmb3IgKGluZGV4ID0gMCwgbGVuZ3RoID0gb2JqZWN0S2V5TGlzdC5sZW5ndGg7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCArPSAxKSB7XG4gICAgICAgICAgaW5zcGVjdE5vZGUob2JqZWN0W29iamVjdEtleUxpc3RbaW5kZXhdXSwgb2JqZWN0cywgZHVwbGljYXRlc0luZGV4ZXMpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGR1bXAoaW5wdXQsIG9wdGlvbnMpIHtcbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgdmFyIHN0YXRlID0gbmV3IFN0YXRlKG9wdGlvbnMpO1xuXG4gIGlmICghc3RhdGUubm9SZWZzKSBnZXREdXBsaWNhdGVSZWZlcmVuY2VzKGlucHV0LCBzdGF0ZSk7XG5cbiAgaWYgKHdyaXRlTm9kZShzdGF0ZSwgMCwgaW5wdXQsIHRydWUsIHRydWUpKSByZXR1cm4gc3RhdGUuZHVtcCArICdcXG4nO1xuXG4gIHJldHVybiAnJztcbn1cblxuZnVuY3Rpb24gc2FmZUR1bXAoaW5wdXQsIG9wdGlvbnMpIHtcbiAgcmV0dXJuIGR1bXAoaW5wdXQsIGNvbW1vbi5leHRlbmQoeyBzY2hlbWE6IERFRkFVTFRfU0FGRV9TQ0hFTUEgfSwgb3B0aW9ucykpO1xufVxuXG5tb2R1bGUuZXhwb3J0cy5kdW1wICAgICA9IGR1bXA7XG5tb2R1bGUuZXhwb3J0cy5zYWZlRHVtcCA9IHNhZmVEdW1wO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2pzLXlhbWwvbGliL2pzLXlhbWwvZHVtcGVyLmpzIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgIHZhbHVlOiB0cnVlXG59KTtcbmNsYXNzIExhenkge1xuICAgIGNvbnN0cnVjdG9yKGNyZWF0b3IpIHtcbiAgICAgICAgdGhpcy5jcmVhdG9yID0gY3JlYXRvcjtcbiAgICB9XG4gICAgZ2V0IGhhc1ZhbHVlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jcmVhdG9yID09IG51bGw7XG4gICAgfVxuICAgIGdldCB2YWx1ZSgpIHtcbiAgICAgICAgaWYgKHRoaXMuY3JlYXRvciA9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fdmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy52YWx1ZSA9IHRoaXMuY3JlYXRvcigpO1xuICAgICAgICByZXR1cm4gdGhpcy5fdmFsdWU7XG4gICAgfVxuICAgIHNldCB2YWx1ZSh2YWx1ZSkge1xuICAgICAgICB0aGlzLl92YWx1ZSA9IHZhbHVlO1xuICAgICAgICB0aGlzLmNyZWF0b3IgPSBudWxsO1xuICAgIH1cbn1cbmV4cG9ydHMuTGF6eSA9IExhenk7IC8vIyBzb3VyY2VNYXBwaW5nVVJMPW1haW4uanMubWFwXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2VsZWN0cm9uLXVwZGF0ZXIvbm9kZV9tb2R1bGVzL2xhenktdmFsL291dC9tYWluLmpzIiwidmFyIFNvdXJjZU1hcENvbnN1bWVyID0gcmVxdWlyZSgnc291cmNlLW1hcCcpLlNvdXJjZU1hcENvbnN1bWVyO1xudmFyIHBhdGggPSByZXF1aXJlKCdwYXRoJyk7XG5cbnZhciBmcztcbnRyeSB7XG4gIGZzID0gcmVxdWlyZSgnZnMnKTtcbiAgaWYgKCFmcy5leGlzdHNTeW5jIHx8ICFmcy5yZWFkRmlsZVN5bmMpIHtcbiAgICAvLyBmcyBkb2Vzbid0IGhhdmUgYWxsIG1ldGhvZHMgd2UgbmVlZFxuICAgIGZzID0gbnVsbDtcbiAgfVxufSBjYXRjaCAoZXJyKSB7XG4gIC8qIG5vcCAqL1xufVxuXG4vLyBPbmx5IGluc3RhbGwgb25jZSBpZiBjYWxsZWQgbXVsdGlwbGUgdGltZXNcbnZhciBlcnJvckZvcm1hdHRlckluc3RhbGxlZCA9IGZhbHNlO1xudmFyIHVuY2F1Z2h0U2hpbUluc3RhbGxlZCA9IGZhbHNlO1xuXG4vLyBJZiB0cnVlLCB0aGUgY2FjaGVzIGFyZSByZXNldCBiZWZvcmUgYSBzdGFjayB0cmFjZSBmb3JtYXR0aW5nIG9wZXJhdGlvblxudmFyIGVtcHR5Q2FjaGVCZXR3ZWVuT3BlcmF0aW9ucyA9IGZhbHNlO1xuXG4vLyBTdXBwb3J0cyB7YnJvd3Nlciwgbm9kZSwgYXV0b31cbnZhciBlbnZpcm9ubWVudCA9IFwiYXV0b1wiO1xuXG4vLyBNYXBzIGEgZmlsZSBwYXRoIHRvIGEgc3RyaW5nIGNvbnRhaW5pbmcgdGhlIGZpbGUgY29udGVudHNcbnZhciBmaWxlQ29udGVudHNDYWNoZSA9IHt9O1xuXG4vLyBNYXBzIGEgZmlsZSBwYXRoIHRvIGEgc291cmNlIG1hcCBmb3IgdGhhdCBmaWxlXG52YXIgc291cmNlTWFwQ2FjaGUgPSB7fTtcblxuLy8gUmVnZXggZm9yIGRldGVjdGluZyBzb3VyY2UgbWFwc1xudmFyIHJlU291cmNlTWFwID0gL15kYXRhOmFwcGxpY2F0aW9uXFwvanNvblteLF0rYmFzZTY0LC87XG5cbi8vIFByaW9yaXR5IGxpc3Qgb2YgcmV0cmlldmUgaGFuZGxlcnNcbnZhciByZXRyaWV2ZUZpbGVIYW5kbGVycyA9IFtdO1xudmFyIHJldHJpZXZlTWFwSGFuZGxlcnMgPSBbXTtcblxuZnVuY3Rpb24gaXNJbkJyb3dzZXIoKSB7XG4gIGlmIChlbnZpcm9ubWVudCA9PT0gXCJicm93c2VyXCIpXG4gICAgcmV0dXJuIHRydWU7XG4gIGlmIChlbnZpcm9ubWVudCA9PT0gXCJub2RlXCIpXG4gICAgcmV0dXJuIGZhbHNlO1xuICByZXR1cm4gKCh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJykgJiYgKHR5cGVvZiBYTUxIdHRwUmVxdWVzdCA9PT0gJ2Z1bmN0aW9uJykgJiYgISh3aW5kb3cucmVxdWlyZSAmJiB3aW5kb3cubW9kdWxlICYmIHdpbmRvdy5wcm9jZXNzICYmIHdpbmRvdy5wcm9jZXNzLnR5cGUgPT09IFwicmVuZGVyZXJcIikpO1xufVxuXG5mdW5jdGlvbiBoYXNHbG9iYWxQcm9jZXNzRXZlbnRFbWl0dGVyKCkge1xuICByZXR1cm4gKCh0eXBlb2YgcHJvY2VzcyA9PT0gJ29iamVjdCcpICYmIChwcm9jZXNzICE9PSBudWxsKSAmJiAodHlwZW9mIHByb2Nlc3Mub24gPT09ICdmdW5jdGlvbicpKTtcbn1cblxuZnVuY3Rpb24gaGFuZGxlckV4ZWMobGlzdCkge1xuICByZXR1cm4gZnVuY3Rpb24oYXJnKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgcmV0ID0gbGlzdFtpXShhcmcpO1xuICAgICAgaWYgKHJldCkge1xuICAgICAgICByZXR1cm4gcmV0O1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbiAgfTtcbn1cblxudmFyIHJldHJpZXZlRmlsZSA9IGhhbmRsZXJFeGVjKHJldHJpZXZlRmlsZUhhbmRsZXJzKTtcblxucmV0cmlldmVGaWxlSGFuZGxlcnMucHVzaChmdW5jdGlvbihwYXRoKSB7XG4gIC8vIFRyaW0gdGhlIHBhdGggdG8gbWFrZSBzdXJlIHRoZXJlIGlzIG5vIGV4dHJhIHdoaXRlc3BhY2UuXG4gIHBhdGggPSBwYXRoLnRyaW0oKTtcbiAgaWYgKHBhdGggaW4gZmlsZUNvbnRlbnRzQ2FjaGUpIHtcbiAgICByZXR1cm4gZmlsZUNvbnRlbnRzQ2FjaGVbcGF0aF07XG4gIH1cblxuICB2YXIgY29udGVudHMgPSBudWxsO1xuICBpZiAoIWZzKSB7XG4gICAgLy8gVXNlIFNKQVggaWYgd2UgYXJlIGluIHRoZSBicm93c2VyXG4gICAgdmFyIHhociA9IG5ldyBYTUxIdHRwUmVxdWVzdCgpO1xuICAgIHhoci5vcGVuKCdHRVQnLCBwYXRoLCBmYWxzZSk7XG4gICAgeGhyLnNlbmQobnVsbCk7XG4gICAgdmFyIGNvbnRlbnRzID0gbnVsbFxuICAgIGlmICh4aHIucmVhZHlTdGF0ZSA9PT0gNCAmJiB4aHIuc3RhdHVzID09PSAyMDApIHtcbiAgICAgIGNvbnRlbnRzID0geGhyLnJlc3BvbnNlVGV4dFxuICAgIH1cbiAgfSBlbHNlIGlmIChmcy5leGlzdHNTeW5jKHBhdGgpKSB7XG4gICAgLy8gT3RoZXJ3aXNlLCB1c2UgdGhlIGZpbGVzeXN0ZW1cbiAgICB0cnkge1xuICAgICAgY29udGVudHMgPSBmcy5yZWFkRmlsZVN5bmMocGF0aCwgJ3V0ZjgnKTtcbiAgICB9IGNhdGNoIChlcikge1xuICAgICAgY29udGVudHMgPSAnJztcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZmlsZUNvbnRlbnRzQ2FjaGVbcGF0aF0gPSBjb250ZW50cztcbn0pO1xuXG4vLyBTdXBwb3J0IFVSTHMgcmVsYXRpdmUgdG8gYSBkaXJlY3RvcnksIGJ1dCBiZSBjYXJlZnVsIGFib3V0IGEgcHJvdG9jb2wgcHJlZml4XG4vLyBpbiBjYXNlIHdlIGFyZSBpbiB0aGUgYnJvd3NlciAoaS5lLiBkaXJlY3RvcmllcyBtYXkgc3RhcnQgd2l0aCBcImh0dHA6Ly9cIilcbmZ1bmN0aW9uIHN1cHBvcnRSZWxhdGl2ZVVSTChmaWxlLCB1cmwpIHtcbiAgaWYgKCFmaWxlKSByZXR1cm4gdXJsO1xuICB2YXIgZGlyID0gcGF0aC5kaXJuYW1lKGZpbGUpO1xuICB2YXIgbWF0Y2ggPSAvXlxcdys6XFwvXFwvW15cXC9dKi8uZXhlYyhkaXIpO1xuICB2YXIgcHJvdG9jb2wgPSBtYXRjaCA/IG1hdGNoWzBdIDogJyc7XG4gIHJldHVybiBwcm90b2NvbCArIHBhdGgucmVzb2x2ZShkaXIuc2xpY2UocHJvdG9jb2wubGVuZ3RoKSwgdXJsKTtcbn1cblxuZnVuY3Rpb24gcmV0cmlldmVTb3VyY2VNYXBVUkwoc291cmNlKSB7XG4gIHZhciBmaWxlRGF0YTtcblxuICBpZiAoaXNJbkJyb3dzZXIoKSkge1xuICAgICB0cnkge1xuICAgICAgIHZhciB4aHIgPSBuZXcgWE1MSHR0cFJlcXVlc3QoKTtcbiAgICAgICB4aHIub3BlbignR0VUJywgc291cmNlLCBmYWxzZSk7XG4gICAgICAgeGhyLnNlbmQobnVsbCk7XG4gICAgICAgZmlsZURhdGEgPSB4aHIucmVhZHlTdGF0ZSA9PT0gNCA/IHhoci5yZXNwb25zZVRleHQgOiBudWxsO1xuXG4gICAgICAgLy8gU3VwcG9ydCBwcm92aWRpbmcgYSBzb3VyY2VNYXBwaW5nVVJMIHZpYSB0aGUgU291cmNlTWFwIGhlYWRlclxuICAgICAgIHZhciBzb3VyY2VNYXBIZWFkZXIgPSB4aHIuZ2V0UmVzcG9uc2VIZWFkZXIoXCJTb3VyY2VNYXBcIikgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeGhyLmdldFJlc3BvbnNlSGVhZGVyKFwiWC1Tb3VyY2VNYXBcIik7XG4gICAgICAgaWYgKHNvdXJjZU1hcEhlYWRlcikge1xuICAgICAgICAgcmV0dXJuIHNvdXJjZU1hcEhlYWRlcjtcbiAgICAgICB9XG4gICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgfVxuICB9XG5cbiAgLy8gR2V0IHRoZSBVUkwgb2YgdGhlIHNvdXJjZSBtYXBcbiAgZmlsZURhdGEgPSByZXRyaWV2ZUZpbGUoc291cmNlKTtcbiAgdmFyIHJlID0gLyg/OlxcL1xcL1tAI11bIFxcdF0rc291cmNlTWFwcGluZ1VSTD0oW15cXHMnXCJdKz8pWyBcXHRdKiQpfCg/OlxcL1xcKltAI11bIFxcdF0rc291cmNlTWFwcGluZ1VSTD0oW15cXCpdKz8pWyBcXHRdKig/OlxcKlxcLylbIFxcdF0qJCkvbWc7XG4gIC8vIEtlZXAgZXhlY3V0aW5nIHRoZSBzZWFyY2ggdG8gZmluZCB0aGUgKmxhc3QqIHNvdXJjZU1hcHBpbmdVUkwgdG8gYXZvaWRcbiAgLy8gcGlja2luZyB1cCBzb3VyY2VNYXBwaW5nVVJMcyBmcm9tIGNvbW1lbnRzLCBzdHJpbmdzLCBldGMuXG4gIHZhciBsYXN0TWF0Y2gsIG1hdGNoO1xuICB3aGlsZSAobWF0Y2ggPSByZS5leGVjKGZpbGVEYXRhKSkgbGFzdE1hdGNoID0gbWF0Y2g7XG4gIGlmICghbGFzdE1hdGNoKSByZXR1cm4gbnVsbDtcbiAgcmV0dXJuIGxhc3RNYXRjaFsxXTtcbn07XG5cbi8vIENhbiBiZSBvdmVycmlkZGVuIGJ5IHRoZSByZXRyaWV2ZVNvdXJjZU1hcCBvcHRpb24gdG8gaW5zdGFsbC4gVGFrZXMgYVxuLy8gZ2VuZXJhdGVkIHNvdXJjZSBmaWxlbmFtZTsgcmV0dXJucyBhIHttYXAsIG9wdGlvbmFsIHVybH0gb2JqZWN0LCBvciBudWxsIGlmXG4vLyB0aGVyZSBpcyBubyBzb3VyY2UgbWFwLiAgVGhlIG1hcCBmaWVsZCBtYXkgYmUgZWl0aGVyIGEgc3RyaW5nIG9yIHRoZSBwYXJzZWRcbi8vIEpTT04gb2JqZWN0IChpZSwgaXQgbXVzdCBiZSBhIHZhbGlkIGFyZ3VtZW50IHRvIHRoZSBTb3VyY2VNYXBDb25zdW1lclxuLy8gY29uc3RydWN0b3IpLlxudmFyIHJldHJpZXZlU291cmNlTWFwID0gaGFuZGxlckV4ZWMocmV0cmlldmVNYXBIYW5kbGVycyk7XG5yZXRyaWV2ZU1hcEhhbmRsZXJzLnB1c2goZnVuY3Rpb24oc291cmNlKSB7XG4gIHZhciBzb3VyY2VNYXBwaW5nVVJMID0gcmV0cmlldmVTb3VyY2VNYXBVUkwoc291cmNlKTtcbiAgaWYgKCFzb3VyY2VNYXBwaW5nVVJMKSByZXR1cm4gbnVsbDtcblxuICAvLyBSZWFkIHRoZSBjb250ZW50cyBvZiB0aGUgc291cmNlIG1hcFxuICB2YXIgc291cmNlTWFwRGF0YTtcbiAgaWYgKHJlU291cmNlTWFwLnRlc3Qoc291cmNlTWFwcGluZ1VSTCkpIHtcbiAgICAvLyBTdXBwb3J0IHNvdXJjZSBtYXAgVVJMIGFzIGEgZGF0YSB1cmxcbiAgICB2YXIgcmF3RGF0YSA9IHNvdXJjZU1hcHBpbmdVUkwuc2xpY2Uoc291cmNlTWFwcGluZ1VSTC5pbmRleE9mKCcsJykgKyAxKTtcbiAgICBzb3VyY2VNYXBEYXRhID0gbmV3IEJ1ZmZlcihyYXdEYXRhLCBcImJhc2U2NFwiKS50b1N0cmluZygpO1xuICAgIHNvdXJjZU1hcHBpbmdVUkwgPSBzb3VyY2U7XG4gIH0gZWxzZSB7XG4gICAgLy8gU3VwcG9ydCBzb3VyY2UgbWFwIFVSTHMgcmVsYXRpdmUgdG8gdGhlIHNvdXJjZSBVUkxcbiAgICBzb3VyY2VNYXBwaW5nVVJMID0gc3VwcG9ydFJlbGF0aXZlVVJMKHNvdXJjZSwgc291cmNlTWFwcGluZ1VSTCk7XG4gICAgc291cmNlTWFwRGF0YSA9IHJldHJpZXZlRmlsZShzb3VyY2VNYXBwaW5nVVJMKTtcbiAgfVxuXG4gIGlmICghc291cmNlTWFwRGF0YSkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICB1cmw6IHNvdXJjZU1hcHBpbmdVUkwsXG4gICAgbWFwOiBzb3VyY2VNYXBEYXRhXG4gIH07XG59KTtcblxuZnVuY3Rpb24gbWFwU291cmNlUG9zaXRpb24ocG9zaXRpb24pIHtcbiAgdmFyIHNvdXJjZU1hcCA9IHNvdXJjZU1hcENhY2hlW3Bvc2l0aW9uLnNvdXJjZV07XG4gIGlmICghc291cmNlTWFwKSB7XG4gICAgLy8gQ2FsbCB0aGUgKG92ZXJyaWRlYWJsZSkgcmV0cmlldmVTb3VyY2VNYXAgZnVuY3Rpb24gdG8gZ2V0IHRoZSBzb3VyY2UgbWFwLlxuICAgIHZhciB1cmxBbmRNYXAgPSByZXRyaWV2ZVNvdXJjZU1hcChwb3NpdGlvbi5zb3VyY2UpO1xuICAgIGlmICh1cmxBbmRNYXApIHtcbiAgICAgIHNvdXJjZU1hcCA9IHNvdXJjZU1hcENhY2hlW3Bvc2l0aW9uLnNvdXJjZV0gPSB7XG4gICAgICAgIHVybDogdXJsQW5kTWFwLnVybCxcbiAgICAgICAgbWFwOiBuZXcgU291cmNlTWFwQ29uc3VtZXIodXJsQW5kTWFwLm1hcClcbiAgICAgIH07XG5cbiAgICAgIC8vIExvYWQgYWxsIHNvdXJjZXMgc3RvcmVkIGlubGluZSB3aXRoIHRoZSBzb3VyY2UgbWFwIGludG8gdGhlIGZpbGUgY2FjaGVcbiAgICAgIC8vIHRvIHByZXRlbmQgbGlrZSB0aGV5IGFyZSBhbHJlYWR5IGxvYWRlZC4gVGhleSBtYXkgbm90IGV4aXN0IG9uIGRpc2suXG4gICAgICBpZiAoc291cmNlTWFwLm1hcC5zb3VyY2VzQ29udGVudCkge1xuICAgICAgICBzb3VyY2VNYXAubWFwLnNvdXJjZXMuZm9yRWFjaChmdW5jdGlvbihzb3VyY2UsIGkpIHtcbiAgICAgICAgICB2YXIgY29udGVudHMgPSBzb3VyY2VNYXAubWFwLnNvdXJjZXNDb250ZW50W2ldO1xuICAgICAgICAgIGlmIChjb250ZW50cykge1xuICAgICAgICAgICAgdmFyIHVybCA9IHN1cHBvcnRSZWxhdGl2ZVVSTChzb3VyY2VNYXAudXJsLCBzb3VyY2UpO1xuICAgICAgICAgICAgZmlsZUNvbnRlbnRzQ2FjaGVbdXJsXSA9IGNvbnRlbnRzO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHNvdXJjZU1hcCA9IHNvdXJjZU1hcENhY2hlW3Bvc2l0aW9uLnNvdXJjZV0gPSB7XG4gICAgICAgIHVybDogbnVsbCxcbiAgICAgICAgbWFwOiBudWxsXG4gICAgICB9O1xuICAgIH1cbiAgfVxuXG4gIC8vIFJlc29sdmUgdGhlIHNvdXJjZSBVUkwgcmVsYXRpdmUgdG8gdGhlIFVSTCBvZiB0aGUgc291cmNlIG1hcFxuICBpZiAoc291cmNlTWFwICYmIHNvdXJjZU1hcC5tYXApIHtcbiAgICB2YXIgb3JpZ2luYWxQb3NpdGlvbiA9IHNvdXJjZU1hcC5tYXAub3JpZ2luYWxQb3NpdGlvbkZvcihwb3NpdGlvbik7XG5cbiAgICAvLyBPbmx5IHJldHVybiB0aGUgb3JpZ2luYWwgcG9zaXRpb24gaWYgYSBtYXRjaGluZyBsaW5lIHdhcyBmb3VuZC4gSWYgbm9cbiAgICAvLyBtYXRjaGluZyBsaW5lIGlzIGZvdW5kIHRoZW4gd2UgcmV0dXJuIHBvc2l0aW9uIGluc3RlYWQsIHdoaWNoIHdpbGwgY2F1c2VcbiAgICAvLyB0aGUgc3RhY2sgdHJhY2UgdG8gcHJpbnQgdGhlIHBhdGggYW5kIGxpbmUgZm9yIHRoZSBjb21waWxlZCBmaWxlLiBJdCBpc1xuICAgIC8vIGJldHRlciB0byBnaXZlIGEgcHJlY2lzZSBsb2NhdGlvbiBpbiB0aGUgY29tcGlsZWQgZmlsZSB0aGFuIGEgdmFndWVcbiAgICAvLyBsb2NhdGlvbiBpbiB0aGUgb3JpZ2luYWwgZmlsZS5cbiAgICBpZiAob3JpZ2luYWxQb3NpdGlvbi5zb3VyY2UgIT09IG51bGwpIHtcbiAgICAgIG9yaWdpbmFsUG9zaXRpb24uc291cmNlID0gc3VwcG9ydFJlbGF0aXZlVVJMKFxuICAgICAgICBzb3VyY2VNYXAudXJsLCBvcmlnaW5hbFBvc2l0aW9uLnNvdXJjZSk7XG4gICAgICByZXR1cm4gb3JpZ2luYWxQb3NpdGlvbjtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gcG9zaXRpb247XG59XG5cbi8vIFBhcnNlcyBjb2RlIGdlbmVyYXRlZCBieSBGb3JtYXRFdmFsT3JpZ2luKCksIGEgZnVuY3Rpb24gaW5zaWRlIFY4OlxuLy8gaHR0cHM6Ly9jb2RlLmdvb2dsZS5jb20vcC92OC9zb3VyY2UvYnJvd3NlL3RydW5rL3NyYy9tZXNzYWdlcy5qc1xuZnVuY3Rpb24gbWFwRXZhbE9yaWdpbihvcmlnaW4pIHtcbiAgLy8gTW9zdCBldmFsKCkgY2FsbHMgYXJlIGluIHRoaXMgZm9ybWF0XG4gIHZhciBtYXRjaCA9IC9eZXZhbCBhdCAoW14oXSspIFxcKCguKyk6KFxcZCspOihcXGQrKVxcKSQvLmV4ZWMob3JpZ2luKTtcbiAgaWYgKG1hdGNoKSB7XG4gICAgdmFyIHBvc2l0aW9uID0gbWFwU291cmNlUG9zaXRpb24oe1xuICAgICAgc291cmNlOiBtYXRjaFsyXSxcbiAgICAgIGxpbmU6ICttYXRjaFszXSxcbiAgICAgIGNvbHVtbjogbWF0Y2hbNF0gLSAxXG4gICAgfSk7XG4gICAgcmV0dXJuICdldmFsIGF0ICcgKyBtYXRjaFsxXSArICcgKCcgKyBwb3NpdGlvbi5zb3VyY2UgKyAnOicgK1xuICAgICAgcG9zaXRpb24ubGluZSArICc6JyArIChwb3NpdGlvbi5jb2x1bW4gKyAxKSArICcpJztcbiAgfVxuXG4gIC8vIFBhcnNlIG5lc3RlZCBldmFsKCkgY2FsbHMgdXNpbmcgcmVjdXJzaW9uXG4gIG1hdGNoID0gL15ldmFsIGF0IChbXihdKykgXFwoKC4rKVxcKSQvLmV4ZWMob3JpZ2luKTtcbiAgaWYgKG1hdGNoKSB7XG4gICAgcmV0dXJuICdldmFsIGF0ICcgKyBtYXRjaFsxXSArICcgKCcgKyBtYXBFdmFsT3JpZ2luKG1hdGNoWzJdKSArICcpJztcbiAgfVxuXG4gIC8vIE1ha2Ugc3VyZSB3ZSBzdGlsbCByZXR1cm4gdXNlZnVsIGluZm9ybWF0aW9uIGlmIHdlIGRpZG4ndCBmaW5kIGFueXRoaW5nXG4gIHJldHVybiBvcmlnaW47XG59XG5cbi8vIFRoaXMgaXMgY29waWVkIGFsbW9zdCB2ZXJiYXRpbSBmcm9tIHRoZSBWOCBzb3VyY2UgY29kZSBhdFxuLy8gaHR0cHM6Ly9jb2RlLmdvb2dsZS5jb20vcC92OC9zb3VyY2UvYnJvd3NlL3RydW5rL3NyYy9tZXNzYWdlcy5qcy4gVGhlXG4vLyBpbXBsZW1lbnRhdGlvbiBvZiB3cmFwQ2FsbFNpdGUoKSB1c2VkIHRvIGp1c3QgZm9yd2FyZCB0byB0aGUgYWN0dWFsIHNvdXJjZVxuLy8gY29kZSBvZiBDYWxsU2l0ZS5wcm90b3R5cGUudG9TdHJpbmcgYnV0IHVuZm9ydHVuYXRlbHkgYSBuZXcgcmVsZWFzZSBvZiBWOFxuLy8gZGlkIHNvbWV0aGluZyB0byB0aGUgcHJvdG90eXBlIGNoYWluIGFuZCBicm9rZSB0aGUgc2hpbS4gVGhlIG9ubHkgZml4IElcbi8vIGNvdWxkIGZpbmQgd2FzIGNvcHkvcGFzdGUuXG5mdW5jdGlvbiBDYWxsU2l0ZVRvU3RyaW5nKCkge1xuICB2YXIgZmlsZU5hbWU7XG4gIHZhciBmaWxlTG9jYXRpb24gPSBcIlwiO1xuICBpZiAodGhpcy5pc05hdGl2ZSgpKSB7XG4gICAgZmlsZUxvY2F0aW9uID0gXCJuYXRpdmVcIjtcbiAgfSBlbHNlIHtcbiAgICBmaWxlTmFtZSA9IHRoaXMuZ2V0U2NyaXB0TmFtZU9yU291cmNlVVJMKCk7XG4gICAgaWYgKCFmaWxlTmFtZSAmJiB0aGlzLmlzRXZhbCgpKSB7XG4gICAgICBmaWxlTG9jYXRpb24gPSB0aGlzLmdldEV2YWxPcmlnaW4oKTtcbiAgICAgIGZpbGVMb2NhdGlvbiArPSBcIiwgXCI7ICAvLyBFeHBlY3Rpbmcgc291cmNlIHBvc2l0aW9uIHRvIGZvbGxvdy5cbiAgICB9XG5cbiAgICBpZiAoZmlsZU5hbWUpIHtcbiAgICAgIGZpbGVMb2NhdGlvbiArPSBmaWxlTmFtZTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gU291cmNlIGNvZGUgZG9lcyBub3Qgb3JpZ2luYXRlIGZyb20gYSBmaWxlIGFuZCBpcyBub3QgbmF0aXZlLCBidXQgd2VcbiAgICAgIC8vIGNhbiBzdGlsbCBnZXQgdGhlIHNvdXJjZSBwb3NpdGlvbiBpbnNpZGUgdGhlIHNvdXJjZSBzdHJpbmcsIGUuZy4gaW5cbiAgICAgIC8vIGFuIGV2YWwgc3RyaW5nLlxuICAgICAgZmlsZUxvY2F0aW9uICs9IFwiPGFub255bW91cz5cIjtcbiAgICB9XG4gICAgdmFyIGxpbmVOdW1iZXIgPSB0aGlzLmdldExpbmVOdW1iZXIoKTtcbiAgICBpZiAobGluZU51bWJlciAhPSBudWxsKSB7XG4gICAgICBmaWxlTG9jYXRpb24gKz0gXCI6XCIgKyBsaW5lTnVtYmVyO1xuICAgICAgdmFyIGNvbHVtbk51bWJlciA9IHRoaXMuZ2V0Q29sdW1uTnVtYmVyKCk7XG4gICAgICBpZiAoY29sdW1uTnVtYmVyKSB7XG4gICAgICAgIGZpbGVMb2NhdGlvbiArPSBcIjpcIiArIGNvbHVtbk51bWJlcjtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICB2YXIgbGluZSA9IFwiXCI7XG4gIHZhciBmdW5jdGlvbk5hbWUgPSB0aGlzLmdldEZ1bmN0aW9uTmFtZSgpO1xuICB2YXIgYWRkU3VmZml4ID0gdHJ1ZTtcbiAgdmFyIGlzQ29uc3RydWN0b3IgPSB0aGlzLmlzQ29uc3RydWN0b3IoKTtcbiAgdmFyIGlzTWV0aG9kQ2FsbCA9ICEodGhpcy5pc1RvcGxldmVsKCkgfHwgaXNDb25zdHJ1Y3Rvcik7XG4gIGlmIChpc01ldGhvZENhbGwpIHtcbiAgICB2YXIgdHlwZU5hbWUgPSB0aGlzLmdldFR5cGVOYW1lKCk7XG4gICAgLy8gRml4ZXMgc2hpbSB0byBiZSBiYWNrd2FyZCBjb21wYXRhYmxlIHdpdGggTm9kZSB2MCB0byB2NFxuICAgIGlmICh0eXBlTmFtZSA9PT0gXCJbb2JqZWN0IE9iamVjdF1cIikge1xuICAgICAgdHlwZU5hbWUgPSBcIm51bGxcIjtcbiAgICB9XG4gICAgdmFyIG1ldGhvZE5hbWUgPSB0aGlzLmdldE1ldGhvZE5hbWUoKTtcbiAgICBpZiAoZnVuY3Rpb25OYW1lKSB7XG4gICAgICBpZiAodHlwZU5hbWUgJiYgZnVuY3Rpb25OYW1lLmluZGV4T2YodHlwZU5hbWUpICE9IDApIHtcbiAgICAgICAgbGluZSArPSB0eXBlTmFtZSArIFwiLlwiO1xuICAgICAgfVxuICAgICAgbGluZSArPSBmdW5jdGlvbk5hbWU7XG4gICAgICBpZiAobWV0aG9kTmFtZSAmJiBmdW5jdGlvbk5hbWUuaW5kZXhPZihcIi5cIiArIG1ldGhvZE5hbWUpICE9IGZ1bmN0aW9uTmFtZS5sZW5ndGggLSBtZXRob2ROYW1lLmxlbmd0aCAtIDEpIHtcbiAgICAgICAgbGluZSArPSBcIiBbYXMgXCIgKyBtZXRob2ROYW1lICsgXCJdXCI7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGxpbmUgKz0gdHlwZU5hbWUgKyBcIi5cIiArIChtZXRob2ROYW1lIHx8IFwiPGFub255bW91cz5cIik7XG4gICAgfVxuICB9IGVsc2UgaWYgKGlzQ29uc3RydWN0b3IpIHtcbiAgICBsaW5lICs9IFwibmV3IFwiICsgKGZ1bmN0aW9uTmFtZSB8fCBcIjxhbm9ueW1vdXM+XCIpO1xuICB9IGVsc2UgaWYgKGZ1bmN0aW9uTmFtZSkge1xuICAgIGxpbmUgKz0gZnVuY3Rpb25OYW1lO1xuICB9IGVsc2Uge1xuICAgIGxpbmUgKz0gZmlsZUxvY2F0aW9uO1xuICAgIGFkZFN1ZmZpeCA9IGZhbHNlO1xuICB9XG4gIGlmIChhZGRTdWZmaXgpIHtcbiAgICBsaW5lICs9IFwiIChcIiArIGZpbGVMb2NhdGlvbiArIFwiKVwiO1xuICB9XG4gIHJldHVybiBsaW5lO1xufVxuXG5mdW5jdGlvbiBjbG9uZUNhbGxTaXRlKGZyYW1lKSB7XG4gIHZhciBvYmplY3QgPSB7fTtcbiAgT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoT2JqZWN0LmdldFByb3RvdHlwZU9mKGZyYW1lKSkuZm9yRWFjaChmdW5jdGlvbihuYW1lKSB7XG4gICAgb2JqZWN0W25hbWVdID0gL14oPzppc3xnZXQpLy50ZXN0KG5hbWUpID8gZnVuY3Rpb24oKSB7IHJldHVybiBmcmFtZVtuYW1lXS5jYWxsKGZyYW1lKTsgfSA6IGZyYW1lW25hbWVdO1xuICB9KTtcbiAgb2JqZWN0LnRvU3RyaW5nID0gQ2FsbFNpdGVUb1N0cmluZztcbiAgcmV0dXJuIG9iamVjdDtcbn1cblxuZnVuY3Rpb24gd3JhcENhbGxTaXRlKGZyYW1lKSB7XG4gIGlmKGZyYW1lLmlzTmF0aXZlKCkpIHtcbiAgICByZXR1cm4gZnJhbWU7XG4gIH1cblxuICAvLyBNb3N0IGNhbGwgc2l0ZXMgd2lsbCByZXR1cm4gdGhlIHNvdXJjZSBmaWxlIGZyb20gZ2V0RmlsZU5hbWUoKSwgYnV0IGNvZGVcbiAgLy8gcGFzc2VkIHRvIGV2YWwoKSBlbmRpbmcgaW4gXCIvLyMgc291cmNlVVJMPS4uLlwiIHdpbGwgcmV0dXJuIHRoZSBzb3VyY2UgZmlsZVxuICAvLyBmcm9tIGdldFNjcmlwdE5hbWVPclNvdXJjZVVSTCgpIGluc3RlYWRcbiAgdmFyIHNvdXJjZSA9IGZyYW1lLmdldEZpbGVOYW1lKCkgfHwgZnJhbWUuZ2V0U2NyaXB0TmFtZU9yU291cmNlVVJMKCk7XG4gIGlmIChzb3VyY2UpIHtcbiAgICB2YXIgbGluZSA9IGZyYW1lLmdldExpbmVOdW1iZXIoKTtcbiAgICB2YXIgY29sdW1uID0gZnJhbWUuZ2V0Q29sdW1uTnVtYmVyKCkgLSAxO1xuXG4gICAgLy8gRml4IHBvc2l0aW9uIGluIE5vZGUgd2hlcmUgc29tZSAoaW50ZXJuYWwpIGNvZGUgaXMgcHJlcGVuZGVkLlxuICAgIC8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vZXZhbncvbm9kZS1zb3VyY2UtbWFwLXN1cHBvcnQvaXNzdWVzLzM2XG4gICAgdmFyIGhlYWRlckxlbmd0aCA9IDYyO1xuICAgIGlmIChsaW5lID09PSAxICYmIGNvbHVtbiA+IGhlYWRlckxlbmd0aCAmJiAhaXNJbkJyb3dzZXIoKSAmJiAhZnJhbWUuaXNFdmFsKCkpIHtcbiAgICAgIGNvbHVtbiAtPSBoZWFkZXJMZW5ndGg7XG4gICAgfVxuXG4gICAgdmFyIHBvc2l0aW9uID0gbWFwU291cmNlUG9zaXRpb24oe1xuICAgICAgc291cmNlOiBzb3VyY2UsXG4gICAgICBsaW5lOiBsaW5lLFxuICAgICAgY29sdW1uOiBjb2x1bW5cbiAgICB9KTtcbiAgICBmcmFtZSA9IGNsb25lQ2FsbFNpdGUoZnJhbWUpO1xuICAgIGZyYW1lLmdldEZpbGVOYW1lID0gZnVuY3Rpb24oKSB7IHJldHVybiBwb3NpdGlvbi5zb3VyY2U7IH07XG4gICAgZnJhbWUuZ2V0TGluZU51bWJlciA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gcG9zaXRpb24ubGluZTsgfTtcbiAgICBmcmFtZS5nZXRDb2x1bW5OdW1iZXIgPSBmdW5jdGlvbigpIHsgcmV0dXJuIHBvc2l0aW9uLmNvbHVtbiArIDE7IH07XG4gICAgZnJhbWUuZ2V0U2NyaXB0TmFtZU9yU291cmNlVVJMID0gZnVuY3Rpb24oKSB7IHJldHVybiBwb3NpdGlvbi5zb3VyY2U7IH07XG4gICAgcmV0dXJuIGZyYW1lO1xuICB9XG5cbiAgLy8gQ29kZSBjYWxsZWQgdXNpbmcgZXZhbCgpIG5lZWRzIHNwZWNpYWwgaGFuZGxpbmdcbiAgdmFyIG9yaWdpbiA9IGZyYW1lLmlzRXZhbCgpICYmIGZyYW1lLmdldEV2YWxPcmlnaW4oKTtcbiAgaWYgKG9yaWdpbikge1xuICAgIG9yaWdpbiA9IG1hcEV2YWxPcmlnaW4ob3JpZ2luKTtcbiAgICBmcmFtZSA9IGNsb25lQ2FsbFNpdGUoZnJhbWUpO1xuICAgIGZyYW1lLmdldEV2YWxPcmlnaW4gPSBmdW5jdGlvbigpIHsgcmV0dXJuIG9yaWdpbjsgfTtcbiAgICByZXR1cm4gZnJhbWU7XG4gIH1cblxuICAvLyBJZiB3ZSBnZXQgaGVyZSB0aGVuIHdlIHdlcmUgdW5hYmxlIHRvIGNoYW5nZSB0aGUgc291cmNlIHBvc2l0aW9uXG4gIHJldHVybiBmcmFtZTtcbn1cblxuLy8gVGhpcyBmdW5jdGlvbiBpcyBwYXJ0IG9mIHRoZSBWOCBzdGFjayB0cmFjZSBBUEksIGZvciBtb3JlIGluZm8gc2VlOlxuLy8gaHR0cDovL2NvZGUuZ29vZ2xlLmNvbS9wL3Y4L3dpa2kvSmF2YVNjcmlwdFN0YWNrVHJhY2VBcGlcbmZ1bmN0aW9uIHByZXBhcmVTdGFja1RyYWNlKGVycm9yLCBzdGFjaykge1xuICBpZiAoZW1wdHlDYWNoZUJldHdlZW5PcGVyYXRpb25zKSB7XG4gICAgZmlsZUNvbnRlbnRzQ2FjaGUgPSB7fTtcbiAgICBzb3VyY2VNYXBDYWNoZSA9IHt9O1xuICB9XG5cbiAgcmV0dXJuIGVycm9yICsgc3RhY2subWFwKGZ1bmN0aW9uKGZyYW1lKSB7XG4gICAgcmV0dXJuICdcXG4gICAgYXQgJyArIHdyYXBDYWxsU2l0ZShmcmFtZSk7XG4gIH0pLmpvaW4oJycpO1xufVxuXG4vLyBHZW5lcmF0ZSBwb3NpdGlvbiBhbmQgc25pcHBldCBvZiBvcmlnaW5hbCBzb3VyY2Ugd2l0aCBwb2ludGVyXG5mdW5jdGlvbiBnZXRFcnJvclNvdXJjZShlcnJvcikge1xuICB2YXIgbWF0Y2ggPSAvXFxuICAgIGF0IFteKF0rIFxcKCguKik6KFxcZCspOihcXGQrKVxcKS8uZXhlYyhlcnJvci5zdGFjayk7XG4gIGlmIChtYXRjaCkge1xuICAgIHZhciBzb3VyY2UgPSBtYXRjaFsxXTtcbiAgICB2YXIgbGluZSA9ICttYXRjaFsyXTtcbiAgICB2YXIgY29sdW1uID0gK21hdGNoWzNdO1xuXG4gICAgLy8gU3VwcG9ydCB0aGUgaW5saW5lIHNvdXJjZUNvbnRlbnRzIGluc2lkZSB0aGUgc291cmNlIG1hcFxuICAgIHZhciBjb250ZW50cyA9IGZpbGVDb250ZW50c0NhY2hlW3NvdXJjZV07XG5cbiAgICAvLyBTdXBwb3J0IGZpbGVzIG9uIGRpc2tcbiAgICBpZiAoIWNvbnRlbnRzICYmIGZzICYmIGZzLmV4aXN0c1N5bmMoc291cmNlKSkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgY29udGVudHMgPSBmcy5yZWFkRmlsZVN5bmMoc291cmNlLCAndXRmOCcpO1xuICAgICAgfSBjYXRjaCAoZXIpIHtcbiAgICAgICAgY29udGVudHMgPSAnJztcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBGb3JtYXQgdGhlIGxpbmUgZnJvbSB0aGUgb3JpZ2luYWwgc291cmNlIGNvZGUgbGlrZSBub2RlIGRvZXNcbiAgICBpZiAoY29udGVudHMpIHtcbiAgICAgIHZhciBjb2RlID0gY29udGVudHMuc3BsaXQoLyg/OlxcclxcbnxcXHJ8XFxuKS8pW2xpbmUgLSAxXTtcbiAgICAgIGlmIChjb2RlKSB7XG4gICAgICAgIHJldHVybiBzb3VyY2UgKyAnOicgKyBsaW5lICsgJ1xcbicgKyBjb2RlICsgJ1xcbicgK1xuICAgICAgICAgIG5ldyBBcnJheShjb2x1bW4pLmpvaW4oJyAnKSArICdeJztcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59XG5cbmZ1bmN0aW9uIHByaW50RXJyb3JBbmRFeGl0IChlcnJvcikge1xuICB2YXIgc291cmNlID0gZ2V0RXJyb3JTb3VyY2UoZXJyb3IpO1xuXG4gIGlmIChzb3VyY2UpIHtcbiAgICBjb25zb2xlLmVycm9yKCk7XG4gICAgY29uc29sZS5lcnJvcihzb3VyY2UpO1xuICB9XG5cbiAgY29uc29sZS5lcnJvcihlcnJvci5zdGFjayk7XG4gIHByb2Nlc3MuZXhpdCgxKTtcbn1cblxuZnVuY3Rpb24gc2hpbUVtaXRVbmNhdWdodEV4Y2VwdGlvbiAoKSB7XG4gIHZhciBvcmlnRW1pdCA9IHByb2Nlc3MuZW1pdDtcblxuICBwcm9jZXNzLmVtaXQgPSBmdW5jdGlvbiAodHlwZSkge1xuICAgIGlmICh0eXBlID09PSAndW5jYXVnaHRFeGNlcHRpb24nKSB7XG4gICAgICB2YXIgaGFzU3RhY2sgPSAoYXJndW1lbnRzWzFdICYmIGFyZ3VtZW50c1sxXS5zdGFjayk7XG4gICAgICB2YXIgaGFzTGlzdGVuZXJzID0gKHRoaXMubGlzdGVuZXJzKHR5cGUpLmxlbmd0aCA+IDApO1xuXG4gICAgICBpZiAoaGFzU3RhY2sgJiYgIWhhc0xpc3RlbmVycykge1xuICAgICAgICByZXR1cm4gcHJpbnRFcnJvckFuZEV4aXQoYXJndW1lbnRzWzFdKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gb3JpZ0VtaXQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgfTtcbn1cblxuZXhwb3J0cy53cmFwQ2FsbFNpdGUgPSB3cmFwQ2FsbFNpdGU7XG5leHBvcnRzLmdldEVycm9yU291cmNlID0gZ2V0RXJyb3JTb3VyY2U7XG5leHBvcnRzLm1hcFNvdXJjZVBvc2l0aW9uID0gbWFwU291cmNlUG9zaXRpb247XG5leHBvcnRzLnJldHJpZXZlU291cmNlTWFwID0gcmV0cmlldmVTb3VyY2VNYXA7XG5cbmV4cG9ydHMuaW5zdGFsbCA9IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgaWYgKG9wdGlvbnMuZW52aXJvbm1lbnQpIHtcbiAgICBlbnZpcm9ubWVudCA9IG9wdGlvbnMuZW52aXJvbm1lbnQ7XG4gICAgaWYgKFtcIm5vZGVcIiwgXCJicm93c2VyXCIsIFwiYXV0b1wiXS5pbmRleE9mKGVudmlyb25tZW50KSA9PT0gLTEpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcImVudmlyb25tZW50IFwiICsgZW52aXJvbm1lbnQgKyBcIiB3YXMgdW5rbm93bi4gQXZhaWxhYmxlIG9wdGlvbnMgYXJlIHthdXRvLCBicm93c2VyLCBub2RlfVwiKVxuICAgIH1cbiAgfVxuXG4gIC8vIEFsbG93IHNvdXJjZXMgdG8gYmUgZm91bmQgYnkgbWV0aG9kcyBvdGhlciB0aGFuIHJlYWRpbmcgdGhlIGZpbGVzXG4gIC8vIGRpcmVjdGx5IGZyb20gZGlzay5cbiAgaWYgKG9wdGlvbnMucmV0cmlldmVGaWxlKSB7XG4gICAgaWYgKG9wdGlvbnMub3ZlcnJpZGVSZXRyaWV2ZUZpbGUpIHtcbiAgICAgIHJldHJpZXZlRmlsZUhhbmRsZXJzLmxlbmd0aCA9IDA7XG4gICAgfVxuXG4gICAgcmV0cmlldmVGaWxlSGFuZGxlcnMudW5zaGlmdChvcHRpb25zLnJldHJpZXZlRmlsZSk7XG4gIH1cblxuICAvLyBBbGxvdyBzb3VyY2UgbWFwcyB0byBiZSBmb3VuZCBieSBtZXRob2RzIG90aGVyIHRoYW4gcmVhZGluZyB0aGUgZmlsZXNcbiAgLy8gZGlyZWN0bHkgZnJvbSBkaXNrLlxuICBpZiAob3B0aW9ucy5yZXRyaWV2ZVNvdXJjZU1hcCkge1xuICAgIGlmIChvcHRpb25zLm92ZXJyaWRlUmV0cmlldmVTb3VyY2VNYXApIHtcbiAgICAgIHJldHJpZXZlTWFwSGFuZGxlcnMubGVuZ3RoID0gMDtcbiAgICB9XG5cbiAgICByZXRyaWV2ZU1hcEhhbmRsZXJzLnVuc2hpZnQob3B0aW9ucy5yZXRyaWV2ZVNvdXJjZU1hcCk7XG4gIH1cblxuICAvLyBTdXBwb3J0IHJ1bnRpbWUgdHJhbnNwaWxlcnMgdGhhdCBpbmNsdWRlIGlubGluZSBzb3VyY2UgbWFwc1xuICBpZiAob3B0aW9ucy5ob29rUmVxdWlyZSAmJiAhaXNJbkJyb3dzZXIoKSkge1xuICAgIHZhciBNb2R1bGU7XG4gICAgdHJ5IHtcbiAgICAgIE1vZHVsZSA9IHJlcXVpcmUoJ21vZHVsZScpO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgLy8gTk9QOiBMb2FkaW5nIGluIGNhdGNoIGJsb2NrIHRvIGNvbnZlcnQgd2VicGFjayBlcnJvciB0byB3YXJuaW5nLlxuICAgIH1cbiAgICB2YXIgJGNvbXBpbGUgPSBNb2R1bGUucHJvdG90eXBlLl9jb21waWxlO1xuXG4gICAgaWYgKCEkY29tcGlsZS5fX3NvdXJjZU1hcFN1cHBvcnQpIHtcbiAgICAgIE1vZHVsZS5wcm90b3R5cGUuX2NvbXBpbGUgPSBmdW5jdGlvbihjb250ZW50LCBmaWxlbmFtZSkge1xuICAgICAgICBmaWxlQ29udGVudHNDYWNoZVtmaWxlbmFtZV0gPSBjb250ZW50O1xuICAgICAgICBzb3VyY2VNYXBDYWNoZVtmaWxlbmFtZV0gPSB1bmRlZmluZWQ7XG4gICAgICAgIHJldHVybiAkY29tcGlsZS5jYWxsKHRoaXMsIGNvbnRlbnQsIGZpbGVuYW1lKTtcbiAgICAgIH07XG5cbiAgICAgIE1vZHVsZS5wcm90b3R5cGUuX2NvbXBpbGUuX19zb3VyY2VNYXBTdXBwb3J0ID0gdHJ1ZTtcbiAgICB9XG4gIH1cblxuICAvLyBDb25maWd1cmUgb3B0aW9uc1xuICBpZiAoIWVtcHR5Q2FjaGVCZXR3ZWVuT3BlcmF0aW9ucykge1xuICAgIGVtcHR5Q2FjaGVCZXR3ZWVuT3BlcmF0aW9ucyA9ICdlbXB0eUNhY2hlQmV0d2Vlbk9wZXJhdGlvbnMnIGluIG9wdGlvbnMgP1xuICAgICAgb3B0aW9ucy5lbXB0eUNhY2hlQmV0d2Vlbk9wZXJhdGlvbnMgOiBmYWxzZTtcbiAgfVxuXG4gIC8vIEluc3RhbGwgdGhlIGVycm9yIHJlZm9ybWF0dGVyXG4gIGlmICghZXJyb3JGb3JtYXR0ZXJJbnN0YWxsZWQpIHtcbiAgICBlcnJvckZvcm1hdHRlckluc3RhbGxlZCA9IHRydWU7XG4gICAgRXJyb3IucHJlcGFyZVN0YWNrVHJhY2UgPSBwcmVwYXJlU3RhY2tUcmFjZTtcbiAgfVxuXG4gIGlmICghdW5jYXVnaHRTaGltSW5zdGFsbGVkKSB7XG4gICAgdmFyIGluc3RhbGxIYW5kbGVyID0gJ2hhbmRsZVVuY2F1Z2h0RXhjZXB0aW9ucycgaW4gb3B0aW9ucyA/XG4gICAgICBvcHRpb25zLmhhbmRsZVVuY2F1Z2h0RXhjZXB0aW9ucyA6IHRydWU7XG5cbiAgICAvLyBQcm92aWRlIHRoZSBvcHRpb24gdG8gbm90IGluc3RhbGwgdGhlIHVuY2F1Z2h0IGV4Y2VwdGlvbiBoYW5kbGVyLiBUaGlzIGlzXG4gICAgLy8gdG8gc3VwcG9ydCBvdGhlciB1bmNhdWdodCBleGNlcHRpb24gaGFuZGxlcnMgKGluIHRlc3QgZnJhbWV3b3JrcywgZm9yXG4gICAgLy8gZXhhbXBsZSkuIElmIHRoaXMgaGFuZGxlciBpcyBub3QgaW5zdGFsbGVkIGFuZCB0aGVyZSBhcmUgbm8gb3RoZXIgdW5jYXVnaHRcbiAgICAvLyBleGNlcHRpb24gaGFuZGxlcnMsIHVuY2F1Z2h0IGV4Y2VwdGlvbnMgd2lsbCBiZSBjYXVnaHQgYnkgbm9kZSdzIGJ1aWx0LWluXG4gICAgLy8gZXhjZXB0aW9uIGhhbmRsZXIgYW5kIHRoZSBwcm9jZXNzIHdpbGwgc3RpbGwgYmUgdGVybWluYXRlZC4gSG93ZXZlciwgdGhlXG4gICAgLy8gZ2VuZXJhdGVkIEphdmFTY3JpcHQgY29kZSB3aWxsIGJlIHNob3duIGFib3ZlIHRoZSBzdGFjayB0cmFjZSBpbnN0ZWFkIG9mXG4gICAgLy8gdGhlIG9yaWdpbmFsIHNvdXJjZSBjb2RlLlxuICAgIGlmIChpbnN0YWxsSGFuZGxlciAmJiBoYXNHbG9iYWxQcm9jZXNzRXZlbnRFbWl0dGVyKCkpIHtcbiAgICAgIHVuY2F1Z2h0U2hpbUluc3RhbGxlZCA9IHRydWU7XG4gICAgICBzaGltRW1pdFVuY2F1Z2h0RXhjZXB0aW9uKCk7XG4gICAgfVxuICB9XG59O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2VsZWN0cm9uLXVwZGF0ZXIvbm9kZV9tb2R1bGVzL3NvdXJjZS1tYXAtc3VwcG9ydC9zb3VyY2UtbWFwLXN1cHBvcnQuanMiLCIvKlxuICogQ29weXJpZ2h0IDIwMDktMjAxMSBNb3ppbGxhIEZvdW5kYXRpb24gYW5kIGNvbnRyaWJ1dG9yc1xuICogTGljZW5zZWQgdW5kZXIgdGhlIE5ldyBCU0QgbGljZW5zZS4gU2VlIExJQ0VOU0UudHh0IG9yOlxuICogaHR0cDovL29wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL0JTRC0zLUNsYXVzZVxuICovXG5leHBvcnRzLlNvdXJjZU1hcEdlbmVyYXRvciA9IHJlcXVpcmUoJy4vbGliL3NvdXJjZS1tYXAtZ2VuZXJhdG9yJykuU291cmNlTWFwR2VuZXJhdG9yO1xuZXhwb3J0cy5Tb3VyY2VNYXBDb25zdW1lciA9IHJlcXVpcmUoJy4vbGliL3NvdXJjZS1tYXAtY29uc3VtZXInKS5Tb3VyY2VNYXBDb25zdW1lcjtcbmV4cG9ydHMuU291cmNlTm9kZSA9IHJlcXVpcmUoJy4vbGliL3NvdXJjZS1ub2RlJykuU291cmNlTm9kZTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9lbGVjdHJvbi11cGRhdGVyL25vZGVfbW9kdWxlcy9zb3VyY2UtbWFwL3NvdXJjZS1tYXAuanMiLCIvKiAtKi0gTW9kZToganM7IGpzLWluZGVudC1sZXZlbDogMjsgLSotICovXG4vKlxuICogQ29weXJpZ2h0IDIwMTEgTW96aWxsYSBGb3VuZGF0aW9uIGFuZCBjb250cmlidXRvcnNcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBOZXcgQlNEIGxpY2Vuc2UuIFNlZSBMSUNFTlNFIG9yOlxuICogaHR0cDovL29wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL0JTRC0zLUNsYXVzZVxuICovXG5cbnZhciBpbnRUb0NoYXJNYXAgPSAnQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejAxMjM0NTY3ODkrLycuc3BsaXQoJycpO1xuXG4vKipcbiAqIEVuY29kZSBhbiBpbnRlZ2VyIGluIHRoZSByYW5nZSBvZiAwIHRvIDYzIHRvIGEgc2luZ2xlIGJhc2UgNjQgZGlnaXQuXG4gKi9cbmV4cG9ydHMuZW5jb2RlID0gZnVuY3Rpb24gKG51bWJlcikge1xuICBpZiAoMCA8PSBudW1iZXIgJiYgbnVtYmVyIDwgaW50VG9DaGFyTWFwLmxlbmd0aCkge1xuICAgIHJldHVybiBpbnRUb0NoYXJNYXBbbnVtYmVyXTtcbiAgfVxuICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiTXVzdCBiZSBiZXR3ZWVuIDAgYW5kIDYzOiBcIiArIG51bWJlcik7XG59O1xuXG4vKipcbiAqIERlY29kZSBhIHNpbmdsZSBiYXNlIDY0IGNoYXJhY3RlciBjb2RlIGRpZ2l0IHRvIGFuIGludGVnZXIuIFJldHVybnMgLTEgb25cbiAqIGZhaWx1cmUuXG4gKi9cbmV4cG9ydHMuZGVjb2RlID0gZnVuY3Rpb24gKGNoYXJDb2RlKSB7XG4gIHZhciBiaWdBID0gNjU7ICAgICAvLyAnQSdcbiAgdmFyIGJpZ1ogPSA5MDsgICAgIC8vICdaJ1xuXG4gIHZhciBsaXR0bGVBID0gOTc7ICAvLyAnYSdcbiAgdmFyIGxpdHRsZVogPSAxMjI7IC8vICd6J1xuXG4gIHZhciB6ZXJvID0gNDg7ICAgICAvLyAnMCdcbiAgdmFyIG5pbmUgPSA1NzsgICAgIC8vICc5J1xuXG4gIHZhciBwbHVzID0gNDM7ICAgICAvLyAnKydcbiAgdmFyIHNsYXNoID0gNDc7ICAgIC8vICcvJ1xuXG4gIHZhciBsaXR0bGVPZmZzZXQgPSAyNjtcbiAgdmFyIG51bWJlck9mZnNldCA9IDUyO1xuXG4gIC8vIDAgLSAyNTogQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVpcbiAgaWYgKGJpZ0EgPD0gY2hhckNvZGUgJiYgY2hhckNvZGUgPD0gYmlnWikge1xuICAgIHJldHVybiAoY2hhckNvZGUgLSBiaWdBKTtcbiAgfVxuXG4gIC8vIDI2IC0gNTE6IGFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6XG4gIGlmIChsaXR0bGVBIDw9IGNoYXJDb2RlICYmIGNoYXJDb2RlIDw9IGxpdHRsZVopIHtcbiAgICByZXR1cm4gKGNoYXJDb2RlIC0gbGl0dGxlQSArIGxpdHRsZU9mZnNldCk7XG4gIH1cblxuICAvLyA1MiAtIDYxOiAwMTIzNDU2Nzg5XG4gIGlmICh6ZXJvIDw9IGNoYXJDb2RlICYmIGNoYXJDb2RlIDw9IG5pbmUpIHtcbiAgICByZXR1cm4gKGNoYXJDb2RlIC0gemVybyArIG51bWJlck9mZnNldCk7XG4gIH1cblxuICAvLyA2MjogK1xuICBpZiAoY2hhckNvZGUgPT0gcGx1cykge1xuICAgIHJldHVybiA2MjtcbiAgfVxuXG4gIC8vIDYzOiAvXG4gIGlmIChjaGFyQ29kZSA9PSBzbGFzaCkge1xuICAgIHJldHVybiA2MztcbiAgfVxuXG4gIC8vIEludmFsaWQgYmFzZTY0IGRpZ2l0LlxuICByZXR1cm4gLTE7XG59O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2VsZWN0cm9uLXVwZGF0ZXIvbm9kZV9tb2R1bGVzL3NvdXJjZS1tYXAvbGliL2Jhc2U2NC5qcyIsIi8qIC0qLSBNb2RlOiBqczsganMtaW5kZW50LWxldmVsOiAyOyAtKi0gKi9cbi8qXG4gKiBDb3B5cmlnaHQgMjAxNCBNb3ppbGxhIEZvdW5kYXRpb24gYW5kIGNvbnRyaWJ1dG9yc1xuICogTGljZW5zZWQgdW5kZXIgdGhlIE5ldyBCU0QgbGljZW5zZS4gU2VlIExJQ0VOU0Ugb3I6XG4gKiBodHRwOi8vb3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvQlNELTMtQ2xhdXNlXG4gKi9cblxudmFyIHV0aWwgPSByZXF1aXJlKCcuL3V0aWwnKTtcblxuLyoqXG4gKiBEZXRlcm1pbmUgd2hldGhlciBtYXBwaW5nQiBpcyBhZnRlciBtYXBwaW5nQSB3aXRoIHJlc3BlY3QgdG8gZ2VuZXJhdGVkXG4gKiBwb3NpdGlvbi5cbiAqL1xuZnVuY3Rpb24gZ2VuZXJhdGVkUG9zaXRpb25BZnRlcihtYXBwaW5nQSwgbWFwcGluZ0IpIHtcbiAgLy8gT3B0aW1pemVkIGZvciBtb3N0IGNvbW1vbiBjYXNlXG4gIHZhciBsaW5lQSA9IG1hcHBpbmdBLmdlbmVyYXRlZExpbmU7XG4gIHZhciBsaW5lQiA9IG1hcHBpbmdCLmdlbmVyYXRlZExpbmU7XG4gIHZhciBjb2x1bW5BID0gbWFwcGluZ0EuZ2VuZXJhdGVkQ29sdW1uO1xuICB2YXIgY29sdW1uQiA9IG1hcHBpbmdCLmdlbmVyYXRlZENvbHVtbjtcbiAgcmV0dXJuIGxpbmVCID4gbGluZUEgfHwgbGluZUIgPT0gbGluZUEgJiYgY29sdW1uQiA+PSBjb2x1bW5BIHx8XG4gICAgICAgICB1dGlsLmNvbXBhcmVCeUdlbmVyYXRlZFBvc2l0aW9uc0luZmxhdGVkKG1hcHBpbmdBLCBtYXBwaW5nQikgPD0gMDtcbn1cblxuLyoqXG4gKiBBIGRhdGEgc3RydWN0dXJlIHRvIHByb3ZpZGUgYSBzb3J0ZWQgdmlldyBvZiBhY2N1bXVsYXRlZCBtYXBwaW5ncyBpbiBhXG4gKiBwZXJmb3JtYW5jZSBjb25zY2lvdXMgbWFubmVyLiBJdCB0cmFkZXMgYSBuZWdsaWJhYmxlIG92ZXJoZWFkIGluIGdlbmVyYWxcbiAqIGNhc2UgZm9yIGEgbGFyZ2Ugc3BlZWR1cCBpbiBjYXNlIG9mIG1hcHBpbmdzIGJlaW5nIGFkZGVkIGluIG9yZGVyLlxuICovXG5mdW5jdGlvbiBNYXBwaW5nTGlzdCgpIHtcbiAgdGhpcy5fYXJyYXkgPSBbXTtcbiAgdGhpcy5fc29ydGVkID0gdHJ1ZTtcbiAgLy8gU2VydmVzIGFzIGluZmltdW1cbiAgdGhpcy5fbGFzdCA9IHtnZW5lcmF0ZWRMaW5lOiAtMSwgZ2VuZXJhdGVkQ29sdW1uOiAwfTtcbn1cblxuLyoqXG4gKiBJdGVyYXRlIHRocm91Z2ggaW50ZXJuYWwgaXRlbXMuIFRoaXMgbWV0aG9kIHRha2VzIHRoZSBzYW1lIGFyZ3VtZW50cyB0aGF0XG4gKiBgQXJyYXkucHJvdG90eXBlLmZvckVhY2hgIHRha2VzLlxuICpcbiAqIE5PVEU6IFRoZSBvcmRlciBvZiB0aGUgbWFwcGluZ3MgaXMgTk9UIGd1YXJhbnRlZWQuXG4gKi9cbk1hcHBpbmdMaXN0LnByb3RvdHlwZS51bnNvcnRlZEZvckVhY2ggPVxuICBmdW5jdGlvbiBNYXBwaW5nTGlzdF9mb3JFYWNoKGFDYWxsYmFjaywgYVRoaXNBcmcpIHtcbiAgICB0aGlzLl9hcnJheS5mb3JFYWNoKGFDYWxsYmFjaywgYVRoaXNBcmcpO1xuICB9O1xuXG4vKipcbiAqIEFkZCB0aGUgZ2l2ZW4gc291cmNlIG1hcHBpbmcuXG4gKlxuICogQHBhcmFtIE9iamVjdCBhTWFwcGluZ1xuICovXG5NYXBwaW5nTGlzdC5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24gTWFwcGluZ0xpc3RfYWRkKGFNYXBwaW5nKSB7XG4gIGlmIChnZW5lcmF0ZWRQb3NpdGlvbkFmdGVyKHRoaXMuX2xhc3QsIGFNYXBwaW5nKSkge1xuICAgIHRoaXMuX2xhc3QgPSBhTWFwcGluZztcbiAgICB0aGlzLl9hcnJheS5wdXNoKGFNYXBwaW5nKTtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLl9zb3J0ZWQgPSBmYWxzZTtcbiAgICB0aGlzLl9hcnJheS5wdXNoKGFNYXBwaW5nKTtcbiAgfVxufTtcblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBmbGF0LCBzb3J0ZWQgYXJyYXkgb2YgbWFwcGluZ3MuIFRoZSBtYXBwaW5ncyBhcmUgc29ydGVkIGJ5XG4gKiBnZW5lcmF0ZWQgcG9zaXRpb24uXG4gKlxuICogV0FSTklORzogVGhpcyBtZXRob2QgcmV0dXJucyBpbnRlcm5hbCBkYXRhIHdpdGhvdXQgY29weWluZywgZm9yXG4gKiBwZXJmb3JtYW5jZS4gVGhlIHJldHVybiB2YWx1ZSBtdXN0IE5PVCBiZSBtdXRhdGVkLCBhbmQgc2hvdWxkIGJlIHRyZWF0ZWQgYXNcbiAqIGFuIGltbXV0YWJsZSBib3Jyb3cuIElmIHlvdSB3YW50IHRvIHRha2Ugb3duZXJzaGlwLCB5b3UgbXVzdCBtYWtlIHlvdXIgb3duXG4gKiBjb3B5LlxuICovXG5NYXBwaW5nTGlzdC5wcm90b3R5cGUudG9BcnJheSA9IGZ1bmN0aW9uIE1hcHBpbmdMaXN0X3RvQXJyYXkoKSB7XG4gIGlmICghdGhpcy5fc29ydGVkKSB7XG4gICAgdGhpcy5fYXJyYXkuc29ydCh1dGlsLmNvbXBhcmVCeUdlbmVyYXRlZFBvc2l0aW9uc0luZmxhdGVkKTtcbiAgICB0aGlzLl9zb3J0ZWQgPSB0cnVlO1xuICB9XG4gIHJldHVybiB0aGlzLl9hcnJheTtcbn07XG5cbmV4cG9ydHMuTWFwcGluZ0xpc3QgPSBNYXBwaW5nTGlzdDtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9lbGVjdHJvbi11cGRhdGVyL25vZGVfbW9kdWxlcy9zb3VyY2UtbWFwL2xpYi9tYXBwaW5nLWxpc3QuanMiLCIvKiAtKi0gTW9kZToganM7IGpzLWluZGVudC1sZXZlbDogMjsgLSotICovXG4vKlxuICogQ29weXJpZ2h0IDIwMTEgTW96aWxsYSBGb3VuZGF0aW9uIGFuZCBjb250cmlidXRvcnNcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBOZXcgQlNEIGxpY2Vuc2UuIFNlZSBMSUNFTlNFIG9yOlxuICogaHR0cDovL29wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL0JTRC0zLUNsYXVzZVxuICovXG5cbnZhciB1dGlsID0gcmVxdWlyZSgnLi91dGlsJyk7XG52YXIgYmluYXJ5U2VhcmNoID0gcmVxdWlyZSgnLi9iaW5hcnktc2VhcmNoJyk7XG52YXIgQXJyYXlTZXQgPSByZXF1aXJlKCcuL2FycmF5LXNldCcpLkFycmF5U2V0O1xudmFyIGJhc2U2NFZMUSA9IHJlcXVpcmUoJy4vYmFzZTY0LXZscScpO1xudmFyIHF1aWNrU29ydCA9IHJlcXVpcmUoJy4vcXVpY2stc29ydCcpLnF1aWNrU29ydDtcblxuZnVuY3Rpb24gU291cmNlTWFwQ29uc3VtZXIoYVNvdXJjZU1hcCwgYVNvdXJjZU1hcFVSTCkge1xuICB2YXIgc291cmNlTWFwID0gYVNvdXJjZU1hcDtcbiAgaWYgKHR5cGVvZiBhU291cmNlTWFwID09PSAnc3RyaW5nJykge1xuICAgIHNvdXJjZU1hcCA9IHV0aWwucGFyc2VTb3VyY2VNYXBJbnB1dChhU291cmNlTWFwKTtcbiAgfVxuXG4gIHJldHVybiBzb3VyY2VNYXAuc2VjdGlvbnMgIT0gbnVsbFxuICAgID8gbmV3IEluZGV4ZWRTb3VyY2VNYXBDb25zdW1lcihzb3VyY2VNYXAsIGFTb3VyY2VNYXBVUkwpXG4gICAgOiBuZXcgQmFzaWNTb3VyY2VNYXBDb25zdW1lcihzb3VyY2VNYXAsIGFTb3VyY2VNYXBVUkwpO1xufVxuXG5Tb3VyY2VNYXBDb25zdW1lci5mcm9tU291cmNlTWFwID0gZnVuY3Rpb24oYVNvdXJjZU1hcCwgYVNvdXJjZU1hcFVSTCkge1xuICByZXR1cm4gQmFzaWNTb3VyY2VNYXBDb25zdW1lci5mcm9tU291cmNlTWFwKGFTb3VyY2VNYXAsIGFTb3VyY2VNYXBVUkwpO1xufVxuXG4vKipcbiAqIFRoZSB2ZXJzaW9uIG9mIHRoZSBzb3VyY2UgbWFwcGluZyBzcGVjIHRoYXQgd2UgYXJlIGNvbnN1bWluZy5cbiAqL1xuU291cmNlTWFwQ29uc3VtZXIucHJvdG90eXBlLl92ZXJzaW9uID0gMztcblxuLy8gYF9fZ2VuZXJhdGVkTWFwcGluZ3NgIGFuZCBgX19vcmlnaW5hbE1hcHBpbmdzYCBhcmUgYXJyYXlzIHRoYXQgaG9sZCB0aGVcbi8vIHBhcnNlZCBtYXBwaW5nIGNvb3JkaW5hdGVzIGZyb20gdGhlIHNvdXJjZSBtYXAncyBcIm1hcHBpbmdzXCIgYXR0cmlidXRlLiBUaGV5XG4vLyBhcmUgbGF6aWx5IGluc3RhbnRpYXRlZCwgYWNjZXNzZWQgdmlhIHRoZSBgX2dlbmVyYXRlZE1hcHBpbmdzYCBhbmRcbi8vIGBfb3JpZ2luYWxNYXBwaW5nc2AgZ2V0dGVycyByZXNwZWN0aXZlbHksIGFuZCB3ZSBvbmx5IHBhcnNlIHRoZSBtYXBwaW5nc1xuLy8gYW5kIGNyZWF0ZSB0aGVzZSBhcnJheXMgb25jZSBxdWVyaWVkIGZvciBhIHNvdXJjZSBsb2NhdGlvbi4gV2UganVtcCB0aHJvdWdoXG4vLyB0aGVzZSBob29wcyBiZWNhdXNlIHRoZXJlIGNhbiBiZSBtYW55IHRob3VzYW5kcyBvZiBtYXBwaW5ncywgYW5kIHBhcnNpbmdcbi8vIHRoZW0gaXMgZXhwZW5zaXZlLCBzbyB3ZSBvbmx5IHdhbnQgdG8gZG8gaXQgaWYgd2UgbXVzdC5cbi8vXG4vLyBFYWNoIG9iamVjdCBpbiB0aGUgYXJyYXlzIGlzIG9mIHRoZSBmb3JtOlxuLy9cbi8vICAgICB7XG4vLyAgICAgICBnZW5lcmF0ZWRMaW5lOiBUaGUgbGluZSBudW1iZXIgaW4gdGhlIGdlbmVyYXRlZCBjb2RlLFxuLy8gICAgICAgZ2VuZXJhdGVkQ29sdW1uOiBUaGUgY29sdW1uIG51bWJlciBpbiB0aGUgZ2VuZXJhdGVkIGNvZGUsXG4vLyAgICAgICBzb3VyY2U6IFRoZSBwYXRoIHRvIHRoZSBvcmlnaW5hbCBzb3VyY2UgZmlsZSB0aGF0IGdlbmVyYXRlZCB0aGlzXG4vLyAgICAgICAgICAgICAgIGNodW5rIG9mIGNvZGUsXG4vLyAgICAgICBvcmlnaW5hbExpbmU6IFRoZSBsaW5lIG51bWJlciBpbiB0aGUgb3JpZ2luYWwgc291cmNlIHRoYXRcbi8vICAgICAgICAgICAgICAgICAgICAgY29ycmVzcG9uZHMgdG8gdGhpcyBjaHVuayBvZiBnZW5lcmF0ZWQgY29kZSxcbi8vICAgICAgIG9yaWdpbmFsQ29sdW1uOiBUaGUgY29sdW1uIG51bWJlciBpbiB0aGUgb3JpZ2luYWwgc291cmNlIHRoYXRcbi8vICAgICAgICAgICAgICAgICAgICAgICBjb3JyZXNwb25kcyB0byB0aGlzIGNodW5rIG9mIGdlbmVyYXRlZCBjb2RlLFxuLy8gICAgICAgbmFtZTogVGhlIG5hbWUgb2YgdGhlIG9yaWdpbmFsIHN5bWJvbCB3aGljaCBnZW5lcmF0ZWQgdGhpcyBjaHVuayBvZlxuLy8gICAgICAgICAgICAgY29kZS5cbi8vICAgICB9XG4vL1xuLy8gQWxsIHByb3BlcnRpZXMgZXhjZXB0IGZvciBgZ2VuZXJhdGVkTGluZWAgYW5kIGBnZW5lcmF0ZWRDb2x1bW5gIGNhbiBiZVxuLy8gYG51bGxgLlxuLy9cbi8vIGBfZ2VuZXJhdGVkTWFwcGluZ3NgIGlzIG9yZGVyZWQgYnkgdGhlIGdlbmVyYXRlZCBwb3NpdGlvbnMuXG4vL1xuLy8gYF9vcmlnaW5hbE1hcHBpbmdzYCBpcyBvcmRlcmVkIGJ5IHRoZSBvcmlnaW5hbCBwb3NpdGlvbnMuXG5cblNvdXJjZU1hcENvbnN1bWVyLnByb3RvdHlwZS5fX2dlbmVyYXRlZE1hcHBpbmdzID0gbnVsbDtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShTb3VyY2VNYXBDb25zdW1lci5wcm90b3R5cGUsICdfZ2VuZXJhdGVkTWFwcGluZ3MnLCB7XG4gIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKCF0aGlzLl9fZ2VuZXJhdGVkTWFwcGluZ3MpIHtcbiAgICAgIHRoaXMuX3BhcnNlTWFwcGluZ3ModGhpcy5fbWFwcGluZ3MsIHRoaXMuc291cmNlUm9vdCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuX19nZW5lcmF0ZWRNYXBwaW5ncztcbiAgfVxufSk7XG5cblNvdXJjZU1hcENvbnN1bWVyLnByb3RvdHlwZS5fX29yaWdpbmFsTWFwcGluZ3MgPSBudWxsO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KFNvdXJjZU1hcENvbnN1bWVyLnByb3RvdHlwZSwgJ19vcmlnaW5hbE1hcHBpbmdzJywge1xuICBjb25maWd1cmFibGU6IHRydWUsXG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIGlmICghdGhpcy5fX29yaWdpbmFsTWFwcGluZ3MpIHtcbiAgICAgIHRoaXMuX3BhcnNlTWFwcGluZ3ModGhpcy5fbWFwcGluZ3MsIHRoaXMuc291cmNlUm9vdCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuX19vcmlnaW5hbE1hcHBpbmdzO1xuICB9XG59KTtcblxuU291cmNlTWFwQ29uc3VtZXIucHJvdG90eXBlLl9jaGFySXNNYXBwaW5nU2VwYXJhdG9yID1cbiAgZnVuY3Rpb24gU291cmNlTWFwQ29uc3VtZXJfY2hhcklzTWFwcGluZ1NlcGFyYXRvcihhU3RyLCBpbmRleCkge1xuICAgIHZhciBjID0gYVN0ci5jaGFyQXQoaW5kZXgpO1xuICAgIHJldHVybiBjID09PSBcIjtcIiB8fCBjID09PSBcIixcIjtcbiAgfTtcblxuLyoqXG4gKiBQYXJzZSB0aGUgbWFwcGluZ3MgaW4gYSBzdHJpbmcgaW4gdG8gYSBkYXRhIHN0cnVjdHVyZSB3aGljaCB3ZSBjYW4gZWFzaWx5XG4gKiBxdWVyeSAodGhlIG9yZGVyZWQgYXJyYXlzIGluIHRoZSBgdGhpcy5fX2dlbmVyYXRlZE1hcHBpbmdzYCBhbmRcbiAqIGB0aGlzLl9fb3JpZ2luYWxNYXBwaW5nc2AgcHJvcGVydGllcykuXG4gKi9cblNvdXJjZU1hcENvbnN1bWVyLnByb3RvdHlwZS5fcGFyc2VNYXBwaW5ncyA9XG4gIGZ1bmN0aW9uIFNvdXJjZU1hcENvbnN1bWVyX3BhcnNlTWFwcGluZ3MoYVN0ciwgYVNvdXJjZVJvb3QpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJTdWJjbGFzc2VzIG11c3QgaW1wbGVtZW50IF9wYXJzZU1hcHBpbmdzXCIpO1xuICB9O1xuXG5Tb3VyY2VNYXBDb25zdW1lci5HRU5FUkFURURfT1JERVIgPSAxO1xuU291cmNlTWFwQ29uc3VtZXIuT1JJR0lOQUxfT1JERVIgPSAyO1xuXG5Tb3VyY2VNYXBDb25zdW1lci5HUkVBVEVTVF9MT1dFUl9CT1VORCA9IDE7XG5Tb3VyY2VNYXBDb25zdW1lci5MRUFTVF9VUFBFUl9CT1VORCA9IDI7XG5cbi8qKlxuICogSXRlcmF0ZSBvdmVyIGVhY2ggbWFwcGluZyBiZXR3ZWVuIGFuIG9yaWdpbmFsIHNvdXJjZS9saW5lL2NvbHVtbiBhbmQgYVxuICogZ2VuZXJhdGVkIGxpbmUvY29sdW1uIGluIHRoaXMgc291cmNlIG1hcC5cbiAqXG4gKiBAcGFyYW0gRnVuY3Rpb24gYUNhbGxiYWNrXG4gKiAgICAgICAgVGhlIGZ1bmN0aW9uIHRoYXQgaXMgY2FsbGVkIHdpdGggZWFjaCBtYXBwaW5nLlxuICogQHBhcmFtIE9iamVjdCBhQ29udGV4dFxuICogICAgICAgIE9wdGlvbmFsLiBJZiBzcGVjaWZpZWQsIHRoaXMgb2JqZWN0IHdpbGwgYmUgdGhlIHZhbHVlIG9mIGB0aGlzYCBldmVyeVxuICogICAgICAgIHRpbWUgdGhhdCBgYUNhbGxiYWNrYCBpcyBjYWxsZWQuXG4gKiBAcGFyYW0gYU9yZGVyXG4gKiAgICAgICAgRWl0aGVyIGBTb3VyY2VNYXBDb25zdW1lci5HRU5FUkFURURfT1JERVJgIG9yXG4gKiAgICAgICAgYFNvdXJjZU1hcENvbnN1bWVyLk9SSUdJTkFMX09SREVSYC4gU3BlY2lmaWVzIHdoZXRoZXIgeW91IHdhbnQgdG9cbiAqICAgICAgICBpdGVyYXRlIG92ZXIgdGhlIG1hcHBpbmdzIHNvcnRlZCBieSB0aGUgZ2VuZXJhdGVkIGZpbGUncyBsaW5lL2NvbHVtblxuICogICAgICAgIG9yZGVyIG9yIHRoZSBvcmlnaW5hbCdzIHNvdXJjZS9saW5lL2NvbHVtbiBvcmRlciwgcmVzcGVjdGl2ZWx5LiBEZWZhdWx0cyB0b1xuICogICAgICAgIGBTb3VyY2VNYXBDb25zdW1lci5HRU5FUkFURURfT1JERVJgLlxuICovXG5Tb3VyY2VNYXBDb25zdW1lci5wcm90b3R5cGUuZWFjaE1hcHBpbmcgPVxuICBmdW5jdGlvbiBTb3VyY2VNYXBDb25zdW1lcl9lYWNoTWFwcGluZyhhQ2FsbGJhY2ssIGFDb250ZXh0LCBhT3JkZXIpIHtcbiAgICB2YXIgY29udGV4dCA9IGFDb250ZXh0IHx8IG51bGw7XG4gICAgdmFyIG9yZGVyID0gYU9yZGVyIHx8IFNvdXJjZU1hcENvbnN1bWVyLkdFTkVSQVRFRF9PUkRFUjtcblxuICAgIHZhciBtYXBwaW5ncztcbiAgICBzd2l0Y2ggKG9yZGVyKSB7XG4gICAgY2FzZSBTb3VyY2VNYXBDb25zdW1lci5HRU5FUkFURURfT1JERVI6XG4gICAgICBtYXBwaW5ncyA9IHRoaXMuX2dlbmVyYXRlZE1hcHBpbmdzO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBTb3VyY2VNYXBDb25zdW1lci5PUklHSU5BTF9PUkRFUjpcbiAgICAgIG1hcHBpbmdzID0gdGhpcy5fb3JpZ2luYWxNYXBwaW5ncztcbiAgICAgIGJyZWFrO1xuICAgIGRlZmF1bHQ6XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmtub3duIG9yZGVyIG9mIGl0ZXJhdGlvbi5cIik7XG4gICAgfVxuXG4gICAgdmFyIHNvdXJjZVJvb3QgPSB0aGlzLnNvdXJjZVJvb3Q7XG4gICAgbWFwcGluZ3MubWFwKGZ1bmN0aW9uIChtYXBwaW5nKSB7XG4gICAgICB2YXIgc291cmNlID0gbWFwcGluZy5zb3VyY2UgPT09IG51bGwgPyBudWxsIDogdGhpcy5fc291cmNlcy5hdChtYXBwaW5nLnNvdXJjZSk7XG4gICAgICBzb3VyY2UgPSB1dGlsLmNvbXB1dGVTb3VyY2VVUkwoc291cmNlUm9vdCwgc291cmNlLCB0aGlzLl9zb3VyY2VNYXBVUkwpO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgc291cmNlOiBzb3VyY2UsXG4gICAgICAgIGdlbmVyYXRlZExpbmU6IG1hcHBpbmcuZ2VuZXJhdGVkTGluZSxcbiAgICAgICAgZ2VuZXJhdGVkQ29sdW1uOiBtYXBwaW5nLmdlbmVyYXRlZENvbHVtbixcbiAgICAgICAgb3JpZ2luYWxMaW5lOiBtYXBwaW5nLm9yaWdpbmFsTGluZSxcbiAgICAgICAgb3JpZ2luYWxDb2x1bW46IG1hcHBpbmcub3JpZ2luYWxDb2x1bW4sXG4gICAgICAgIG5hbWU6IG1hcHBpbmcubmFtZSA9PT0gbnVsbCA/IG51bGwgOiB0aGlzLl9uYW1lcy5hdChtYXBwaW5nLm5hbWUpXG4gICAgICB9O1xuICAgIH0sIHRoaXMpLmZvckVhY2goYUNhbGxiYWNrLCBjb250ZXh0KTtcbiAgfTtcblxuLyoqXG4gKiBSZXR1cm5zIGFsbCBnZW5lcmF0ZWQgbGluZSBhbmQgY29sdW1uIGluZm9ybWF0aW9uIGZvciB0aGUgb3JpZ2luYWwgc291cmNlLFxuICogbGluZSwgYW5kIGNvbHVtbiBwcm92aWRlZC4gSWYgbm8gY29sdW1uIGlzIHByb3ZpZGVkLCByZXR1cm5zIGFsbCBtYXBwaW5nc1xuICogY29ycmVzcG9uZGluZyB0byBhIGVpdGhlciB0aGUgbGluZSB3ZSBhcmUgc2VhcmNoaW5nIGZvciBvciB0aGUgbmV4dFxuICogY2xvc2VzdCBsaW5lIHRoYXQgaGFzIGFueSBtYXBwaW5ncy4gT3RoZXJ3aXNlLCByZXR1cm5zIGFsbCBtYXBwaW5nc1xuICogY29ycmVzcG9uZGluZyB0byB0aGUgZ2l2ZW4gbGluZSBhbmQgZWl0aGVyIHRoZSBjb2x1bW4gd2UgYXJlIHNlYXJjaGluZyBmb3JcbiAqIG9yIHRoZSBuZXh0IGNsb3Nlc3QgY29sdW1uIHRoYXQgaGFzIGFueSBvZmZzZXRzLlxuICpcbiAqIFRoZSBvbmx5IGFyZ3VtZW50IGlzIGFuIG9iamVjdCB3aXRoIHRoZSBmb2xsb3dpbmcgcHJvcGVydGllczpcbiAqXG4gKiAgIC0gc291cmNlOiBUaGUgZmlsZW5hbWUgb2YgdGhlIG9yaWdpbmFsIHNvdXJjZS5cbiAqICAgLSBsaW5lOiBUaGUgbGluZSBudW1iZXIgaW4gdGhlIG9yaWdpbmFsIHNvdXJjZS4gIFRoZSBsaW5lIG51bWJlciBpcyAxLWJhc2VkLlxuICogICAtIGNvbHVtbjogT3B0aW9uYWwuIHRoZSBjb2x1bW4gbnVtYmVyIGluIHRoZSBvcmlnaW5hbCBzb3VyY2UuXG4gKiAgICBUaGUgY29sdW1uIG51bWJlciBpcyAwLWJhc2VkLlxuICpcbiAqIGFuZCBhbiBhcnJheSBvZiBvYmplY3RzIGlzIHJldHVybmVkLCBlYWNoIHdpdGggdGhlIGZvbGxvd2luZyBwcm9wZXJ0aWVzOlxuICpcbiAqICAgLSBsaW5lOiBUaGUgbGluZSBudW1iZXIgaW4gdGhlIGdlbmVyYXRlZCBzb3VyY2UsIG9yIG51bGwuICBUaGVcbiAqICAgIGxpbmUgbnVtYmVyIGlzIDEtYmFzZWQuXG4gKiAgIC0gY29sdW1uOiBUaGUgY29sdW1uIG51bWJlciBpbiB0aGUgZ2VuZXJhdGVkIHNvdXJjZSwgb3IgbnVsbC5cbiAqICAgIFRoZSBjb2x1bW4gbnVtYmVyIGlzIDAtYmFzZWQuXG4gKi9cblNvdXJjZU1hcENvbnN1bWVyLnByb3RvdHlwZS5hbGxHZW5lcmF0ZWRQb3NpdGlvbnNGb3IgPVxuICBmdW5jdGlvbiBTb3VyY2VNYXBDb25zdW1lcl9hbGxHZW5lcmF0ZWRQb3NpdGlvbnNGb3IoYUFyZ3MpIHtcbiAgICB2YXIgbGluZSA9IHV0aWwuZ2V0QXJnKGFBcmdzLCAnbGluZScpO1xuXG4gICAgLy8gV2hlbiB0aGVyZSBpcyBubyBleGFjdCBtYXRjaCwgQmFzaWNTb3VyY2VNYXBDb25zdW1lci5wcm90b3R5cGUuX2ZpbmRNYXBwaW5nXG4gICAgLy8gcmV0dXJucyB0aGUgaW5kZXggb2YgdGhlIGNsb3Nlc3QgbWFwcGluZyBsZXNzIHRoYW4gdGhlIG5lZWRsZS4gQnlcbiAgICAvLyBzZXR0aW5nIG5lZWRsZS5vcmlnaW5hbENvbHVtbiB0byAwLCB3ZSB0aHVzIGZpbmQgdGhlIGxhc3QgbWFwcGluZyBmb3JcbiAgICAvLyB0aGUgZ2l2ZW4gbGluZSwgcHJvdmlkZWQgc3VjaCBhIG1hcHBpbmcgZXhpc3RzLlxuICAgIHZhciBuZWVkbGUgPSB7XG4gICAgICBzb3VyY2U6IHV0aWwuZ2V0QXJnKGFBcmdzLCAnc291cmNlJyksXG4gICAgICBvcmlnaW5hbExpbmU6IGxpbmUsXG4gICAgICBvcmlnaW5hbENvbHVtbjogdXRpbC5nZXRBcmcoYUFyZ3MsICdjb2x1bW4nLCAwKVxuICAgIH07XG5cbiAgICBuZWVkbGUuc291cmNlID0gdGhpcy5fZmluZFNvdXJjZUluZGV4KG5lZWRsZS5zb3VyY2UpO1xuICAgIGlmIChuZWVkbGUuc291cmNlIDwgMCkge1xuICAgICAgcmV0dXJuIFtdO1xuICAgIH1cblxuICAgIHZhciBtYXBwaW5ncyA9IFtdO1xuXG4gICAgdmFyIGluZGV4ID0gdGhpcy5fZmluZE1hcHBpbmcobmVlZGxlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX29yaWdpbmFsTWFwcGluZ3MsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJvcmlnaW5hbExpbmVcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIm9yaWdpbmFsQ29sdW1uXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdXRpbC5jb21wYXJlQnlPcmlnaW5hbFBvc2l0aW9ucyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBiaW5hcnlTZWFyY2guTEVBU1RfVVBQRVJfQk9VTkQpO1xuICAgIGlmIChpbmRleCA+PSAwKSB7XG4gICAgICB2YXIgbWFwcGluZyA9IHRoaXMuX29yaWdpbmFsTWFwcGluZ3NbaW5kZXhdO1xuXG4gICAgICBpZiAoYUFyZ3MuY29sdW1uID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdmFyIG9yaWdpbmFsTGluZSA9IG1hcHBpbmcub3JpZ2luYWxMaW5lO1xuXG4gICAgICAgIC8vIEl0ZXJhdGUgdW50aWwgZWl0aGVyIHdlIHJ1biBvdXQgb2YgbWFwcGluZ3MsIG9yIHdlIHJ1biBpbnRvXG4gICAgICAgIC8vIGEgbWFwcGluZyBmb3IgYSBkaWZmZXJlbnQgbGluZSB0aGFuIHRoZSBvbmUgd2UgZm91bmQuIFNpbmNlXG4gICAgICAgIC8vIG1hcHBpbmdzIGFyZSBzb3J0ZWQsIHRoaXMgaXMgZ3VhcmFudGVlZCB0byBmaW5kIGFsbCBtYXBwaW5ncyBmb3JcbiAgICAgICAgLy8gdGhlIGxpbmUgd2UgZm91bmQuXG4gICAgICAgIHdoaWxlIChtYXBwaW5nICYmIG1hcHBpbmcub3JpZ2luYWxMaW5lID09PSBvcmlnaW5hbExpbmUpIHtcbiAgICAgICAgICBtYXBwaW5ncy5wdXNoKHtcbiAgICAgICAgICAgIGxpbmU6IHV0aWwuZ2V0QXJnKG1hcHBpbmcsICdnZW5lcmF0ZWRMaW5lJywgbnVsbCksXG4gICAgICAgICAgICBjb2x1bW46IHV0aWwuZ2V0QXJnKG1hcHBpbmcsICdnZW5lcmF0ZWRDb2x1bW4nLCBudWxsKSxcbiAgICAgICAgICAgIGxhc3RDb2x1bW46IHV0aWwuZ2V0QXJnKG1hcHBpbmcsICdsYXN0R2VuZXJhdGVkQ29sdW1uJywgbnVsbClcbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIG1hcHBpbmcgPSB0aGlzLl9vcmlnaW5hbE1hcHBpbmdzWysraW5kZXhdO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgb3JpZ2luYWxDb2x1bW4gPSBtYXBwaW5nLm9yaWdpbmFsQ29sdW1uO1xuXG4gICAgICAgIC8vIEl0ZXJhdGUgdW50aWwgZWl0aGVyIHdlIHJ1biBvdXQgb2YgbWFwcGluZ3MsIG9yIHdlIHJ1biBpbnRvXG4gICAgICAgIC8vIGEgbWFwcGluZyBmb3IgYSBkaWZmZXJlbnQgbGluZSB0aGFuIHRoZSBvbmUgd2Ugd2VyZSBzZWFyY2hpbmcgZm9yLlxuICAgICAgICAvLyBTaW5jZSBtYXBwaW5ncyBhcmUgc29ydGVkLCB0aGlzIGlzIGd1YXJhbnRlZWQgdG8gZmluZCBhbGwgbWFwcGluZ3MgZm9yXG4gICAgICAgIC8vIHRoZSBsaW5lIHdlIGFyZSBzZWFyY2hpbmcgZm9yLlxuICAgICAgICB3aGlsZSAobWFwcGluZyAmJlxuICAgICAgICAgICAgICAgbWFwcGluZy5vcmlnaW5hbExpbmUgPT09IGxpbmUgJiZcbiAgICAgICAgICAgICAgIG1hcHBpbmcub3JpZ2luYWxDb2x1bW4gPT0gb3JpZ2luYWxDb2x1bW4pIHtcbiAgICAgICAgICBtYXBwaW5ncy5wdXNoKHtcbiAgICAgICAgICAgIGxpbmU6IHV0aWwuZ2V0QXJnKG1hcHBpbmcsICdnZW5lcmF0ZWRMaW5lJywgbnVsbCksXG4gICAgICAgICAgICBjb2x1bW46IHV0aWwuZ2V0QXJnKG1hcHBpbmcsICdnZW5lcmF0ZWRDb2x1bW4nLCBudWxsKSxcbiAgICAgICAgICAgIGxhc3RDb2x1bW46IHV0aWwuZ2V0QXJnKG1hcHBpbmcsICdsYXN0R2VuZXJhdGVkQ29sdW1uJywgbnVsbClcbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIG1hcHBpbmcgPSB0aGlzLl9vcmlnaW5hbE1hcHBpbmdzWysraW5kZXhdO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIG1hcHBpbmdzO1xuICB9O1xuXG5leHBvcnRzLlNvdXJjZU1hcENvbnN1bWVyID0gU291cmNlTWFwQ29uc3VtZXI7XG5cbi8qKlxuICogQSBCYXNpY1NvdXJjZU1hcENvbnN1bWVyIGluc3RhbmNlIHJlcHJlc2VudHMgYSBwYXJzZWQgc291cmNlIG1hcCB3aGljaCB3ZSBjYW5cbiAqIHF1ZXJ5IGZvciBpbmZvcm1hdGlvbiBhYm91dCB0aGUgb3JpZ2luYWwgZmlsZSBwb3NpdGlvbnMgYnkgZ2l2aW5nIGl0IGEgZmlsZVxuICogcG9zaXRpb24gaW4gdGhlIGdlbmVyYXRlZCBzb3VyY2UuXG4gKlxuICogVGhlIGZpcnN0IHBhcmFtZXRlciBpcyB0aGUgcmF3IHNvdXJjZSBtYXAgKGVpdGhlciBhcyBhIEpTT04gc3RyaW5nLCBvclxuICogYWxyZWFkeSBwYXJzZWQgdG8gYW4gb2JqZWN0KS4gQWNjb3JkaW5nIHRvIHRoZSBzcGVjLCBzb3VyY2UgbWFwcyBoYXZlIHRoZVxuICogZm9sbG93aW5nIGF0dHJpYnV0ZXM6XG4gKlxuICogICAtIHZlcnNpb246IFdoaWNoIHZlcnNpb24gb2YgdGhlIHNvdXJjZSBtYXAgc3BlYyB0aGlzIG1hcCBpcyBmb2xsb3dpbmcuXG4gKiAgIC0gc291cmNlczogQW4gYXJyYXkgb2YgVVJMcyB0byB0aGUgb3JpZ2luYWwgc291cmNlIGZpbGVzLlxuICogICAtIG5hbWVzOiBBbiBhcnJheSBvZiBpZGVudGlmaWVycyB3aGljaCBjYW4gYmUgcmVmZXJyZW5jZWQgYnkgaW5kaXZpZHVhbCBtYXBwaW5ncy5cbiAqICAgLSBzb3VyY2VSb290OiBPcHRpb25hbC4gVGhlIFVSTCByb290IGZyb20gd2hpY2ggYWxsIHNvdXJjZXMgYXJlIHJlbGF0aXZlLlxuICogICAtIHNvdXJjZXNDb250ZW50OiBPcHRpb25hbC4gQW4gYXJyYXkgb2YgY29udGVudHMgb2YgdGhlIG9yaWdpbmFsIHNvdXJjZSBmaWxlcy5cbiAqICAgLSBtYXBwaW5nczogQSBzdHJpbmcgb2YgYmFzZTY0IFZMUXMgd2hpY2ggY29udGFpbiB0aGUgYWN0dWFsIG1hcHBpbmdzLlxuICogICAtIGZpbGU6IE9wdGlvbmFsLiBUaGUgZ2VuZXJhdGVkIGZpbGUgdGhpcyBzb3VyY2UgbWFwIGlzIGFzc29jaWF0ZWQgd2l0aC5cbiAqXG4gKiBIZXJlIGlzIGFuIGV4YW1wbGUgc291cmNlIG1hcCwgdGFrZW4gZnJvbSB0aGUgc291cmNlIG1hcCBzcGVjWzBdOlxuICpcbiAqICAgICB7XG4gKiAgICAgICB2ZXJzaW9uIDogMyxcbiAqICAgICAgIGZpbGU6IFwib3V0LmpzXCIsXG4gKiAgICAgICBzb3VyY2VSb290IDogXCJcIixcbiAqICAgICAgIHNvdXJjZXM6IFtcImZvby5qc1wiLCBcImJhci5qc1wiXSxcbiAqICAgICAgIG5hbWVzOiBbXCJzcmNcIiwgXCJtYXBzXCIsIFwiYXJlXCIsIFwiZnVuXCJdLFxuICogICAgICAgbWFwcGluZ3M6IFwiQUEsQUI7O0FCQ0RFO1wiXG4gKiAgICAgfVxuICpcbiAqIFRoZSBzZWNvbmQgcGFyYW1ldGVyLCBpZiBnaXZlbiwgaXMgYSBzdHJpbmcgd2hvc2UgdmFsdWUgaXMgdGhlIFVSTFxuICogYXQgd2hpY2ggdGhlIHNvdXJjZSBtYXAgd2FzIGZvdW5kLiAgVGhpcyBVUkwgaXMgdXNlZCB0byBjb21wdXRlIHRoZVxuICogc291cmNlcyBhcnJheS5cbiAqXG4gKiBbMF06IGh0dHBzOi8vZG9jcy5nb29nbGUuY29tL2RvY3VtZW50L2QvMVUxUkdBZWhRd1J5cFVUb3ZGMUtSbHBpT0Z6ZTBiLV8yZ2M2ZkFIMEtZMGsvZWRpdD9wbGk9MSNcbiAqL1xuZnVuY3Rpb24gQmFzaWNTb3VyY2VNYXBDb25zdW1lcihhU291cmNlTWFwLCBhU291cmNlTWFwVVJMKSB7XG4gIHZhciBzb3VyY2VNYXAgPSBhU291cmNlTWFwO1xuICBpZiAodHlwZW9mIGFTb3VyY2VNYXAgPT09ICdzdHJpbmcnKSB7XG4gICAgc291cmNlTWFwID0gdXRpbC5wYXJzZVNvdXJjZU1hcElucHV0KGFTb3VyY2VNYXApO1xuICB9XG5cbiAgdmFyIHZlcnNpb24gPSB1dGlsLmdldEFyZyhzb3VyY2VNYXAsICd2ZXJzaW9uJyk7XG4gIHZhciBzb3VyY2VzID0gdXRpbC5nZXRBcmcoc291cmNlTWFwLCAnc291cmNlcycpO1xuICAvLyBTYXNzIDMuMyBsZWF2ZXMgb3V0IHRoZSAnbmFtZXMnIGFycmF5LCBzbyB3ZSBkZXZpYXRlIGZyb20gdGhlIHNwZWMgKHdoaWNoXG4gIC8vIHJlcXVpcmVzIHRoZSBhcnJheSkgdG8gcGxheSBuaWNlIGhlcmUuXG4gIHZhciBuYW1lcyA9IHV0aWwuZ2V0QXJnKHNvdXJjZU1hcCwgJ25hbWVzJywgW10pO1xuICB2YXIgc291cmNlUm9vdCA9IHV0aWwuZ2V0QXJnKHNvdXJjZU1hcCwgJ3NvdXJjZVJvb3QnLCBudWxsKTtcbiAgdmFyIHNvdXJjZXNDb250ZW50ID0gdXRpbC5nZXRBcmcoc291cmNlTWFwLCAnc291cmNlc0NvbnRlbnQnLCBudWxsKTtcbiAgdmFyIG1hcHBpbmdzID0gdXRpbC5nZXRBcmcoc291cmNlTWFwLCAnbWFwcGluZ3MnKTtcbiAgdmFyIGZpbGUgPSB1dGlsLmdldEFyZyhzb3VyY2VNYXAsICdmaWxlJywgbnVsbCk7XG5cbiAgLy8gT25jZSBhZ2FpbiwgU2FzcyBkZXZpYXRlcyBmcm9tIHRoZSBzcGVjIGFuZCBzdXBwbGllcyB0aGUgdmVyc2lvbiBhcyBhXG4gIC8vIHN0cmluZyByYXRoZXIgdGhhbiBhIG51bWJlciwgc28gd2UgdXNlIGxvb3NlIGVxdWFsaXR5IGNoZWNraW5nIGhlcmUuXG4gIGlmICh2ZXJzaW9uICE9IHRoaXMuX3ZlcnNpb24pIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vuc3VwcG9ydGVkIHZlcnNpb246ICcgKyB2ZXJzaW9uKTtcbiAgfVxuXG4gIGlmIChzb3VyY2VSb290KSB7XG4gICAgc291cmNlUm9vdCA9IHV0aWwubm9ybWFsaXplKHNvdXJjZVJvb3QpO1xuICB9XG5cbiAgc291cmNlcyA9IHNvdXJjZXNcbiAgICAubWFwKFN0cmluZylcbiAgICAvLyBTb21lIHNvdXJjZSBtYXBzIHByb2R1Y2UgcmVsYXRpdmUgc291cmNlIHBhdGhzIGxpa2UgXCIuL2Zvby5qc1wiIGluc3RlYWQgb2ZcbiAgICAvLyBcImZvby5qc1wiLiAgTm9ybWFsaXplIHRoZXNlIGZpcnN0IHNvIHRoYXQgZnV0dXJlIGNvbXBhcmlzb25zIHdpbGwgc3VjY2VlZC5cbiAgICAvLyBTZWUgYnVnemlsLmxhLzEwOTA3NjguXG4gICAgLm1hcCh1dGlsLm5vcm1hbGl6ZSlcbiAgICAvLyBBbHdheXMgZW5zdXJlIHRoYXQgYWJzb2x1dGUgc291cmNlcyBhcmUgaW50ZXJuYWxseSBzdG9yZWQgcmVsYXRpdmUgdG9cbiAgICAvLyB0aGUgc291cmNlIHJvb3QsIGlmIHRoZSBzb3VyY2Ugcm9vdCBpcyBhYnNvbHV0ZS4gTm90IGRvaW5nIHRoaXMgd291bGRcbiAgICAvLyBiZSBwYXJ0aWN1bGFybHkgcHJvYmxlbWF0aWMgd2hlbiB0aGUgc291cmNlIHJvb3QgaXMgYSBwcmVmaXggb2YgdGhlXG4gICAgLy8gc291cmNlICh2YWxpZCwgYnV0IHdoeT8/KS4gU2VlIGdpdGh1YiBpc3N1ZSAjMTk5IGFuZCBidWd6aWwubGEvMTE4ODk4Mi5cbiAgICAubWFwKGZ1bmN0aW9uIChzb3VyY2UpIHtcbiAgICAgIHJldHVybiBzb3VyY2VSb290ICYmIHV0aWwuaXNBYnNvbHV0ZShzb3VyY2VSb290KSAmJiB1dGlsLmlzQWJzb2x1dGUoc291cmNlKVxuICAgICAgICA/IHV0aWwucmVsYXRpdmUoc291cmNlUm9vdCwgc291cmNlKVxuICAgICAgICA6IHNvdXJjZTtcbiAgICB9KTtcblxuICAvLyBQYXNzIGB0cnVlYCBiZWxvdyB0byBhbGxvdyBkdXBsaWNhdGUgbmFtZXMgYW5kIHNvdXJjZXMuIFdoaWxlIHNvdXJjZSBtYXBzXG4gIC8vIGFyZSBpbnRlbmRlZCB0byBiZSBjb21wcmVzc2VkIGFuZCBkZWR1cGxpY2F0ZWQsIHRoZSBUeXBlU2NyaXB0IGNvbXBpbGVyXG4gIC8vIHNvbWV0aW1lcyBnZW5lcmF0ZXMgc291cmNlIG1hcHMgd2l0aCBkdXBsaWNhdGVzIGluIHRoZW0uIFNlZSBHaXRodWIgaXNzdWVcbiAgLy8gIzcyIGFuZCBidWd6aWwubGEvODg5NDkyLlxuICB0aGlzLl9uYW1lcyA9IEFycmF5U2V0LmZyb21BcnJheShuYW1lcy5tYXAoU3RyaW5nKSwgdHJ1ZSk7XG4gIHRoaXMuX3NvdXJjZXMgPSBBcnJheVNldC5mcm9tQXJyYXkoc291cmNlcywgdHJ1ZSk7XG5cbiAgdGhpcy5fYWJzb2x1dGVTb3VyY2VzID0gdGhpcy5fc291cmNlcy50b0FycmF5KCkubWFwKGZ1bmN0aW9uIChzKSB7XG4gICAgcmV0dXJuIHV0aWwuY29tcHV0ZVNvdXJjZVVSTChzb3VyY2VSb290LCBzLCBhU291cmNlTWFwVVJMKTtcbiAgfSk7XG5cbiAgdGhpcy5zb3VyY2VSb290ID0gc291cmNlUm9vdDtcbiAgdGhpcy5zb3VyY2VzQ29udGVudCA9IHNvdXJjZXNDb250ZW50O1xuICB0aGlzLl9tYXBwaW5ncyA9IG1hcHBpbmdzO1xuICB0aGlzLl9zb3VyY2VNYXBVUkwgPSBhU291cmNlTWFwVVJMO1xuICB0aGlzLmZpbGUgPSBmaWxlO1xufVxuXG5CYXNpY1NvdXJjZU1hcENvbnN1bWVyLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoU291cmNlTWFwQ29uc3VtZXIucHJvdG90eXBlKTtcbkJhc2ljU291cmNlTWFwQ29uc3VtZXIucHJvdG90eXBlLmNvbnN1bWVyID0gU291cmNlTWFwQ29uc3VtZXI7XG5cbi8qKlxuICogVXRpbGl0eSBmdW5jdGlvbiB0byBmaW5kIHRoZSBpbmRleCBvZiBhIHNvdXJjZS4gIFJldHVybnMgLTEgaWYgbm90XG4gKiBmb3VuZC5cbiAqL1xuQmFzaWNTb3VyY2VNYXBDb25zdW1lci5wcm90b3R5cGUuX2ZpbmRTb3VyY2VJbmRleCA9IGZ1bmN0aW9uKGFTb3VyY2UpIHtcbiAgdmFyIHJlbGF0aXZlU291cmNlID0gYVNvdXJjZTtcbiAgaWYgKHRoaXMuc291cmNlUm9vdCAhPSBudWxsKSB7XG4gICAgcmVsYXRpdmVTb3VyY2UgPSB1dGlsLnJlbGF0aXZlKHRoaXMuc291cmNlUm9vdCwgcmVsYXRpdmVTb3VyY2UpO1xuICB9XG5cbiAgaWYgKHRoaXMuX3NvdXJjZXMuaGFzKHJlbGF0aXZlU291cmNlKSkge1xuICAgIHJldHVybiB0aGlzLl9zb3VyY2VzLmluZGV4T2YocmVsYXRpdmVTb3VyY2UpO1xuICB9XG5cbiAgLy8gTWF5YmUgYVNvdXJjZSBpcyBhbiBhYnNvbHV0ZSBVUkwgYXMgcmV0dXJuZWQgYnkgfHNvdXJjZXN8LiAgSW5cbiAgLy8gdGhpcyBjYXNlIHdlIGNhbid0IHNpbXBseSB1bmRvIHRoZSB0cmFuc2Zvcm0uXG4gIHZhciBpO1xuICBmb3IgKGkgPSAwOyBpIDwgdGhpcy5fYWJzb2x1dGVTb3VyY2VzLmxlbmd0aDsgKytpKSB7XG4gICAgaWYgKHRoaXMuX2Fic29sdXRlU291cmNlc1tpXSA9PSBhU291cmNlKSB7XG4gICAgICByZXR1cm4gaTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gLTE7XG59O1xuXG4vKipcbiAqIENyZWF0ZSBhIEJhc2ljU291cmNlTWFwQ29uc3VtZXIgZnJvbSBhIFNvdXJjZU1hcEdlbmVyYXRvci5cbiAqXG4gKiBAcGFyYW0gU291cmNlTWFwR2VuZXJhdG9yIGFTb3VyY2VNYXBcbiAqICAgICAgICBUaGUgc291cmNlIG1hcCB0aGF0IHdpbGwgYmUgY29uc3VtZWQuXG4gKiBAcGFyYW0gU3RyaW5nIGFTb3VyY2VNYXBVUkxcbiAqICAgICAgICBUaGUgVVJMIGF0IHdoaWNoIHRoZSBzb3VyY2UgbWFwIGNhbiBiZSBmb3VuZCAob3B0aW9uYWwpXG4gKiBAcmV0dXJucyBCYXNpY1NvdXJjZU1hcENvbnN1bWVyXG4gKi9cbkJhc2ljU291cmNlTWFwQ29uc3VtZXIuZnJvbVNvdXJjZU1hcCA9XG4gIGZ1bmN0aW9uIFNvdXJjZU1hcENvbnN1bWVyX2Zyb21Tb3VyY2VNYXAoYVNvdXJjZU1hcCwgYVNvdXJjZU1hcFVSTCkge1xuICAgIHZhciBzbWMgPSBPYmplY3QuY3JlYXRlKEJhc2ljU291cmNlTWFwQ29uc3VtZXIucHJvdG90eXBlKTtcblxuICAgIHZhciBuYW1lcyA9IHNtYy5fbmFtZXMgPSBBcnJheVNldC5mcm9tQXJyYXkoYVNvdXJjZU1hcC5fbmFtZXMudG9BcnJheSgpLCB0cnVlKTtcbiAgICB2YXIgc291cmNlcyA9IHNtYy5fc291cmNlcyA9IEFycmF5U2V0LmZyb21BcnJheShhU291cmNlTWFwLl9zb3VyY2VzLnRvQXJyYXkoKSwgdHJ1ZSk7XG4gICAgc21jLnNvdXJjZVJvb3QgPSBhU291cmNlTWFwLl9zb3VyY2VSb290O1xuICAgIHNtYy5zb3VyY2VzQ29udGVudCA9IGFTb3VyY2VNYXAuX2dlbmVyYXRlU291cmNlc0NvbnRlbnQoc21jLl9zb3VyY2VzLnRvQXJyYXkoKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNtYy5zb3VyY2VSb290KTtcbiAgICBzbWMuZmlsZSA9IGFTb3VyY2VNYXAuX2ZpbGU7XG4gICAgc21jLl9zb3VyY2VNYXBVUkwgPSBhU291cmNlTWFwVVJMO1xuICAgIHNtYy5fYWJzb2x1dGVTb3VyY2VzID0gc21jLl9zb3VyY2VzLnRvQXJyYXkoKS5tYXAoZnVuY3Rpb24gKHMpIHtcbiAgICAgIHJldHVybiB1dGlsLmNvbXB1dGVTb3VyY2VVUkwoc21jLnNvdXJjZVJvb3QsIHMsIGFTb3VyY2VNYXBVUkwpO1xuICAgIH0pO1xuXG4gICAgLy8gQmVjYXVzZSB3ZSBhcmUgbW9kaWZ5aW5nIHRoZSBlbnRyaWVzIChieSBjb252ZXJ0aW5nIHN0cmluZyBzb3VyY2VzIGFuZFxuICAgIC8vIG5hbWVzIHRvIGluZGljZXMgaW50byB0aGUgc291cmNlcyBhbmQgbmFtZXMgQXJyYXlTZXRzKSwgd2UgaGF2ZSB0byBtYWtlXG4gICAgLy8gYSBjb3B5IG9mIHRoZSBlbnRyeSBvciBlbHNlIGJhZCB0aGluZ3MgaGFwcGVuLiBTaGFyZWQgbXV0YWJsZSBzdGF0ZVxuICAgIC8vIHN0cmlrZXMgYWdhaW4hIFNlZSBnaXRodWIgaXNzdWUgIzE5MS5cblxuICAgIHZhciBnZW5lcmF0ZWRNYXBwaW5ncyA9IGFTb3VyY2VNYXAuX21hcHBpbmdzLnRvQXJyYXkoKS5zbGljZSgpO1xuICAgIHZhciBkZXN0R2VuZXJhdGVkTWFwcGluZ3MgPSBzbWMuX19nZW5lcmF0ZWRNYXBwaW5ncyA9IFtdO1xuICAgIHZhciBkZXN0T3JpZ2luYWxNYXBwaW5ncyA9IHNtYy5fX29yaWdpbmFsTWFwcGluZ3MgPSBbXTtcblxuICAgIGZvciAodmFyIGkgPSAwLCBsZW5ndGggPSBnZW5lcmF0ZWRNYXBwaW5ncy5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHNyY01hcHBpbmcgPSBnZW5lcmF0ZWRNYXBwaW5nc1tpXTtcbiAgICAgIHZhciBkZXN0TWFwcGluZyA9IG5ldyBNYXBwaW5nO1xuICAgICAgZGVzdE1hcHBpbmcuZ2VuZXJhdGVkTGluZSA9IHNyY01hcHBpbmcuZ2VuZXJhdGVkTGluZTtcbiAgICAgIGRlc3RNYXBwaW5nLmdlbmVyYXRlZENvbHVtbiA9IHNyY01hcHBpbmcuZ2VuZXJhdGVkQ29sdW1uO1xuXG4gICAgICBpZiAoc3JjTWFwcGluZy5zb3VyY2UpIHtcbiAgICAgICAgZGVzdE1hcHBpbmcuc291cmNlID0gc291cmNlcy5pbmRleE9mKHNyY01hcHBpbmcuc291cmNlKTtcbiAgICAgICAgZGVzdE1hcHBpbmcub3JpZ2luYWxMaW5lID0gc3JjTWFwcGluZy5vcmlnaW5hbExpbmU7XG4gICAgICAgIGRlc3RNYXBwaW5nLm9yaWdpbmFsQ29sdW1uID0gc3JjTWFwcGluZy5vcmlnaW5hbENvbHVtbjtcblxuICAgICAgICBpZiAoc3JjTWFwcGluZy5uYW1lKSB7XG4gICAgICAgICAgZGVzdE1hcHBpbmcubmFtZSA9IG5hbWVzLmluZGV4T2Yoc3JjTWFwcGluZy5uYW1lKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGRlc3RPcmlnaW5hbE1hcHBpbmdzLnB1c2goZGVzdE1hcHBpbmcpO1xuICAgICAgfVxuXG4gICAgICBkZXN0R2VuZXJhdGVkTWFwcGluZ3MucHVzaChkZXN0TWFwcGluZyk7XG4gICAgfVxuXG4gICAgcXVpY2tTb3J0KHNtYy5fX29yaWdpbmFsTWFwcGluZ3MsIHV0aWwuY29tcGFyZUJ5T3JpZ2luYWxQb3NpdGlvbnMpO1xuXG4gICAgcmV0dXJuIHNtYztcbiAgfTtcblxuLyoqXG4gKiBUaGUgdmVyc2lvbiBvZiB0aGUgc291cmNlIG1hcHBpbmcgc3BlYyB0aGF0IHdlIGFyZSBjb25zdW1pbmcuXG4gKi9cbkJhc2ljU291cmNlTWFwQ29uc3VtZXIucHJvdG90eXBlLl92ZXJzaW9uID0gMztcblxuLyoqXG4gKiBUaGUgbGlzdCBvZiBvcmlnaW5hbCBzb3VyY2VzLlxuICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoQmFzaWNTb3VyY2VNYXBDb25zdW1lci5wcm90b3R5cGUsICdzb3VyY2VzJywge1xuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5fYWJzb2x1dGVTb3VyY2VzLnNsaWNlKCk7XG4gIH1cbn0pO1xuXG4vKipcbiAqIFByb3ZpZGUgdGhlIEpJVCB3aXRoIGEgbmljZSBzaGFwZSAvIGhpZGRlbiBjbGFzcy5cbiAqL1xuZnVuY3Rpb24gTWFwcGluZygpIHtcbiAgdGhpcy5nZW5lcmF0ZWRMaW5lID0gMDtcbiAgdGhpcy5nZW5lcmF0ZWRDb2x1bW4gPSAwO1xuICB0aGlzLnNvdXJjZSA9IG51bGw7XG4gIHRoaXMub3JpZ2luYWxMaW5lID0gbnVsbDtcbiAgdGhpcy5vcmlnaW5hbENvbHVtbiA9IG51bGw7XG4gIHRoaXMubmFtZSA9IG51bGw7XG59XG5cbi8qKlxuICogUGFyc2UgdGhlIG1hcHBpbmdzIGluIGEgc3RyaW5nIGluIHRvIGEgZGF0YSBzdHJ1Y3R1cmUgd2hpY2ggd2UgY2FuIGVhc2lseVxuICogcXVlcnkgKHRoZSBvcmRlcmVkIGFycmF5cyBpbiB0aGUgYHRoaXMuX19nZW5lcmF0ZWRNYXBwaW5nc2AgYW5kXG4gKiBgdGhpcy5fX29yaWdpbmFsTWFwcGluZ3NgIHByb3BlcnRpZXMpLlxuICovXG5CYXNpY1NvdXJjZU1hcENvbnN1bWVyLnByb3RvdHlwZS5fcGFyc2VNYXBwaW5ncyA9XG4gIGZ1bmN0aW9uIFNvdXJjZU1hcENvbnN1bWVyX3BhcnNlTWFwcGluZ3MoYVN0ciwgYVNvdXJjZVJvb3QpIHtcbiAgICB2YXIgZ2VuZXJhdGVkTGluZSA9IDE7XG4gICAgdmFyIHByZXZpb3VzR2VuZXJhdGVkQ29sdW1uID0gMDtcbiAgICB2YXIgcHJldmlvdXNPcmlnaW5hbExpbmUgPSAwO1xuICAgIHZhciBwcmV2aW91c09yaWdpbmFsQ29sdW1uID0gMDtcbiAgICB2YXIgcHJldmlvdXNTb3VyY2UgPSAwO1xuICAgIHZhciBwcmV2aW91c05hbWUgPSAwO1xuICAgIHZhciBsZW5ndGggPSBhU3RyLmxlbmd0aDtcbiAgICB2YXIgaW5kZXggPSAwO1xuICAgIHZhciBjYWNoZWRTZWdtZW50cyA9IHt9O1xuICAgIHZhciB0ZW1wID0ge307XG4gICAgdmFyIG9yaWdpbmFsTWFwcGluZ3MgPSBbXTtcbiAgICB2YXIgZ2VuZXJhdGVkTWFwcGluZ3MgPSBbXTtcbiAgICB2YXIgbWFwcGluZywgc3RyLCBzZWdtZW50LCBlbmQsIHZhbHVlO1xuXG4gICAgd2hpbGUgKGluZGV4IDwgbGVuZ3RoKSB7XG4gICAgICBpZiAoYVN0ci5jaGFyQXQoaW5kZXgpID09PSAnOycpIHtcbiAgICAgICAgZ2VuZXJhdGVkTGluZSsrO1xuICAgICAgICBpbmRleCsrO1xuICAgICAgICBwcmV2aW91c0dlbmVyYXRlZENvbHVtbiA9IDA7XG4gICAgICB9XG4gICAgICBlbHNlIGlmIChhU3RyLmNoYXJBdChpbmRleCkgPT09ICcsJykge1xuICAgICAgICBpbmRleCsrO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIG1hcHBpbmcgPSBuZXcgTWFwcGluZygpO1xuICAgICAgICBtYXBwaW5nLmdlbmVyYXRlZExpbmUgPSBnZW5lcmF0ZWRMaW5lO1xuXG4gICAgICAgIC8vIEJlY2F1c2UgZWFjaCBvZmZzZXQgaXMgZW5jb2RlZCByZWxhdGl2ZSB0byB0aGUgcHJldmlvdXMgb25lLFxuICAgICAgICAvLyBtYW55IHNlZ21lbnRzIG9mdGVuIGhhdmUgdGhlIHNhbWUgZW5jb2RpbmcuIFdlIGNhbiBleHBsb2l0IHRoaXNcbiAgICAgICAgLy8gZmFjdCBieSBjYWNoaW5nIHRoZSBwYXJzZWQgdmFyaWFibGUgbGVuZ3RoIGZpZWxkcyBvZiBlYWNoIHNlZ21lbnQsXG4gICAgICAgIC8vIGFsbG93aW5nIHVzIHRvIGF2b2lkIGEgc2Vjb25kIHBhcnNlIGlmIHdlIGVuY291bnRlciB0aGUgc2FtZVxuICAgICAgICAvLyBzZWdtZW50IGFnYWluLlxuICAgICAgICBmb3IgKGVuZCA9IGluZGV4OyBlbmQgPCBsZW5ndGg7IGVuZCsrKSB7XG4gICAgICAgICAgaWYgKHRoaXMuX2NoYXJJc01hcHBpbmdTZXBhcmF0b3IoYVN0ciwgZW5kKSkge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHN0ciA9IGFTdHIuc2xpY2UoaW5kZXgsIGVuZCk7XG5cbiAgICAgICAgc2VnbWVudCA9IGNhY2hlZFNlZ21lbnRzW3N0cl07XG4gICAgICAgIGlmIChzZWdtZW50KSB7XG4gICAgICAgICAgaW5kZXggKz0gc3RyLmxlbmd0aDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzZWdtZW50ID0gW107XG4gICAgICAgICAgd2hpbGUgKGluZGV4IDwgZW5kKSB7XG4gICAgICAgICAgICBiYXNlNjRWTFEuZGVjb2RlKGFTdHIsIGluZGV4LCB0ZW1wKTtcbiAgICAgICAgICAgIHZhbHVlID0gdGVtcC52YWx1ZTtcbiAgICAgICAgICAgIGluZGV4ID0gdGVtcC5yZXN0O1xuICAgICAgICAgICAgc2VnbWVudC5wdXNoKHZhbHVlKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoc2VnbWVudC5sZW5ndGggPT09IDIpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRm91bmQgYSBzb3VyY2UsIGJ1dCBubyBsaW5lIGFuZCBjb2x1bW4nKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoc2VnbWVudC5sZW5ndGggPT09IDMpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRm91bmQgYSBzb3VyY2UgYW5kIGxpbmUsIGJ1dCBubyBjb2x1bW4nKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjYWNoZWRTZWdtZW50c1tzdHJdID0gc2VnbWVudDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEdlbmVyYXRlZCBjb2x1bW4uXG4gICAgICAgIG1hcHBpbmcuZ2VuZXJhdGVkQ29sdW1uID0gcHJldmlvdXNHZW5lcmF0ZWRDb2x1bW4gKyBzZWdtZW50WzBdO1xuICAgICAgICBwcmV2aW91c0dlbmVyYXRlZENvbHVtbiA9IG1hcHBpbmcuZ2VuZXJhdGVkQ29sdW1uO1xuXG4gICAgICAgIGlmIChzZWdtZW50Lmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAvLyBPcmlnaW5hbCBzb3VyY2UuXG4gICAgICAgICAgbWFwcGluZy5zb3VyY2UgPSBwcmV2aW91c1NvdXJjZSArIHNlZ21lbnRbMV07XG4gICAgICAgICAgcHJldmlvdXNTb3VyY2UgKz0gc2VnbWVudFsxXTtcblxuICAgICAgICAgIC8vIE9yaWdpbmFsIGxpbmUuXG4gICAgICAgICAgbWFwcGluZy5vcmlnaW5hbExpbmUgPSBwcmV2aW91c09yaWdpbmFsTGluZSArIHNlZ21lbnRbMl07XG4gICAgICAgICAgcHJldmlvdXNPcmlnaW5hbExpbmUgPSBtYXBwaW5nLm9yaWdpbmFsTGluZTtcbiAgICAgICAgICAvLyBMaW5lcyBhcmUgc3RvcmVkIDAtYmFzZWRcbiAgICAgICAgICBtYXBwaW5nLm9yaWdpbmFsTGluZSArPSAxO1xuXG4gICAgICAgICAgLy8gT3JpZ2luYWwgY29sdW1uLlxuICAgICAgICAgIG1hcHBpbmcub3JpZ2luYWxDb2x1bW4gPSBwcmV2aW91c09yaWdpbmFsQ29sdW1uICsgc2VnbWVudFszXTtcbiAgICAgICAgICBwcmV2aW91c09yaWdpbmFsQ29sdW1uID0gbWFwcGluZy5vcmlnaW5hbENvbHVtbjtcblxuICAgICAgICAgIGlmIChzZWdtZW50Lmxlbmd0aCA+IDQpIHtcbiAgICAgICAgICAgIC8vIE9yaWdpbmFsIG5hbWUuXG4gICAgICAgICAgICBtYXBwaW5nLm5hbWUgPSBwcmV2aW91c05hbWUgKyBzZWdtZW50WzRdO1xuICAgICAgICAgICAgcHJldmlvdXNOYW1lICs9IHNlZ21lbnRbNF07XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgZ2VuZXJhdGVkTWFwcGluZ3MucHVzaChtYXBwaW5nKTtcbiAgICAgICAgaWYgKHR5cGVvZiBtYXBwaW5nLm9yaWdpbmFsTGluZSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICBvcmlnaW5hbE1hcHBpbmdzLnB1c2gobWFwcGluZyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBxdWlja1NvcnQoZ2VuZXJhdGVkTWFwcGluZ3MsIHV0aWwuY29tcGFyZUJ5R2VuZXJhdGVkUG9zaXRpb25zRGVmbGF0ZWQpO1xuICAgIHRoaXMuX19nZW5lcmF0ZWRNYXBwaW5ncyA9IGdlbmVyYXRlZE1hcHBpbmdzO1xuXG4gICAgcXVpY2tTb3J0KG9yaWdpbmFsTWFwcGluZ3MsIHV0aWwuY29tcGFyZUJ5T3JpZ2luYWxQb3NpdGlvbnMpO1xuICAgIHRoaXMuX19vcmlnaW5hbE1hcHBpbmdzID0gb3JpZ2luYWxNYXBwaW5ncztcbiAgfTtcblxuLyoqXG4gKiBGaW5kIHRoZSBtYXBwaW5nIHRoYXQgYmVzdCBtYXRjaGVzIHRoZSBoeXBvdGhldGljYWwgXCJuZWVkbGVcIiBtYXBwaW5nIHRoYXRcbiAqIHdlIGFyZSBzZWFyY2hpbmcgZm9yIGluIHRoZSBnaXZlbiBcImhheXN0YWNrXCIgb2YgbWFwcGluZ3MuXG4gKi9cbkJhc2ljU291cmNlTWFwQ29uc3VtZXIucHJvdG90eXBlLl9maW5kTWFwcGluZyA9XG4gIGZ1bmN0aW9uIFNvdXJjZU1hcENvbnN1bWVyX2ZpbmRNYXBwaW5nKGFOZWVkbGUsIGFNYXBwaW5ncywgYUxpbmVOYW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhQ29sdW1uTmFtZSwgYUNvbXBhcmF0b3IsIGFCaWFzKSB7XG4gICAgLy8gVG8gcmV0dXJuIHRoZSBwb3NpdGlvbiB3ZSBhcmUgc2VhcmNoaW5nIGZvciwgd2UgbXVzdCBmaXJzdCBmaW5kIHRoZVxuICAgIC8vIG1hcHBpbmcgZm9yIHRoZSBnaXZlbiBwb3NpdGlvbiBhbmQgdGhlbiByZXR1cm4gdGhlIG9wcG9zaXRlIHBvc2l0aW9uIGl0XG4gICAgLy8gcG9pbnRzIHRvLiBCZWNhdXNlIHRoZSBtYXBwaW5ncyBhcmUgc29ydGVkLCB3ZSBjYW4gdXNlIGJpbmFyeSBzZWFyY2ggdG9cbiAgICAvLyBmaW5kIHRoZSBiZXN0IG1hcHBpbmcuXG5cbiAgICBpZiAoYU5lZWRsZVthTGluZU5hbWVdIDw9IDApIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0xpbmUgbXVzdCBiZSBncmVhdGVyIHRoYW4gb3IgZXF1YWwgdG8gMSwgZ290ICdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgKyBhTmVlZGxlW2FMaW5lTmFtZV0pO1xuICAgIH1cbiAgICBpZiAoYU5lZWRsZVthQ29sdW1uTmFtZV0gPCAwKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdDb2x1bW4gbXVzdCBiZSBncmVhdGVyIHRoYW4gb3IgZXF1YWwgdG8gMCwgZ290ICdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgKyBhTmVlZGxlW2FDb2x1bW5OYW1lXSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGJpbmFyeVNlYXJjaC5zZWFyY2goYU5lZWRsZSwgYU1hcHBpbmdzLCBhQ29tcGFyYXRvciwgYUJpYXMpO1xuICB9O1xuXG4vKipcbiAqIENvbXB1dGUgdGhlIGxhc3QgY29sdW1uIGZvciBlYWNoIGdlbmVyYXRlZCBtYXBwaW5nLiBUaGUgbGFzdCBjb2x1bW4gaXNcbiAqIGluY2x1c2l2ZS5cbiAqL1xuQmFzaWNTb3VyY2VNYXBDb25zdW1lci5wcm90b3R5cGUuY29tcHV0ZUNvbHVtblNwYW5zID1cbiAgZnVuY3Rpb24gU291cmNlTWFwQ29uc3VtZXJfY29tcHV0ZUNvbHVtblNwYW5zKCkge1xuICAgIGZvciAodmFyIGluZGV4ID0gMDsgaW5kZXggPCB0aGlzLl9nZW5lcmF0ZWRNYXBwaW5ncy5sZW5ndGg7ICsraW5kZXgpIHtcbiAgICAgIHZhciBtYXBwaW5nID0gdGhpcy5fZ2VuZXJhdGVkTWFwcGluZ3NbaW5kZXhdO1xuXG4gICAgICAvLyBNYXBwaW5ncyBkbyBub3QgY29udGFpbiBhIGZpZWxkIGZvciB0aGUgbGFzdCBnZW5lcmF0ZWQgY29sdW1udC4gV2VcbiAgICAgIC8vIGNhbiBjb21lIHVwIHdpdGggYW4gb3B0aW1pc3RpYyBlc3RpbWF0ZSwgaG93ZXZlciwgYnkgYXNzdW1pbmcgdGhhdFxuICAgICAgLy8gbWFwcGluZ3MgYXJlIGNvbnRpZ3VvdXMgKGkuZS4gZ2l2ZW4gdHdvIGNvbnNlY3V0aXZlIG1hcHBpbmdzLCB0aGVcbiAgICAgIC8vIGZpcnN0IG1hcHBpbmcgZW5kcyB3aGVyZSB0aGUgc2Vjb25kIG9uZSBzdGFydHMpLlxuICAgICAgaWYgKGluZGV4ICsgMSA8IHRoaXMuX2dlbmVyYXRlZE1hcHBpbmdzLmxlbmd0aCkge1xuICAgICAgICB2YXIgbmV4dE1hcHBpbmcgPSB0aGlzLl9nZW5lcmF0ZWRNYXBwaW5nc1tpbmRleCArIDFdO1xuXG4gICAgICAgIGlmIChtYXBwaW5nLmdlbmVyYXRlZExpbmUgPT09IG5leHRNYXBwaW5nLmdlbmVyYXRlZExpbmUpIHtcbiAgICAgICAgICBtYXBwaW5nLmxhc3RHZW5lcmF0ZWRDb2x1bW4gPSBuZXh0TWFwcGluZy5nZW5lcmF0ZWRDb2x1bW4gLSAxO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIFRoZSBsYXN0IG1hcHBpbmcgZm9yIGVhY2ggbGluZSBzcGFucyB0aGUgZW50aXJlIGxpbmUuXG4gICAgICBtYXBwaW5nLmxhc3RHZW5lcmF0ZWRDb2x1bW4gPSBJbmZpbml0eTtcbiAgICB9XG4gIH07XG5cbi8qKlxuICogUmV0dXJucyB0aGUgb3JpZ2luYWwgc291cmNlLCBsaW5lLCBhbmQgY29sdW1uIGluZm9ybWF0aW9uIGZvciB0aGUgZ2VuZXJhdGVkXG4gKiBzb3VyY2UncyBsaW5lIGFuZCBjb2x1bW4gcG9zaXRpb25zIHByb3ZpZGVkLiBUaGUgb25seSBhcmd1bWVudCBpcyBhbiBvYmplY3RcbiAqIHdpdGggdGhlIGZvbGxvd2luZyBwcm9wZXJ0aWVzOlxuICpcbiAqICAgLSBsaW5lOiBUaGUgbGluZSBudW1iZXIgaW4gdGhlIGdlbmVyYXRlZCBzb3VyY2UuICBUaGUgbGluZSBudW1iZXJcbiAqICAgICBpcyAxLWJhc2VkLlxuICogICAtIGNvbHVtbjogVGhlIGNvbHVtbiBudW1iZXIgaW4gdGhlIGdlbmVyYXRlZCBzb3VyY2UuICBUaGUgY29sdW1uXG4gKiAgICAgbnVtYmVyIGlzIDAtYmFzZWQuXG4gKiAgIC0gYmlhczogRWl0aGVyICdTb3VyY2VNYXBDb25zdW1lci5HUkVBVEVTVF9MT1dFUl9CT1VORCcgb3JcbiAqICAgICAnU291cmNlTWFwQ29uc3VtZXIuTEVBU1RfVVBQRVJfQk9VTkQnLiBTcGVjaWZpZXMgd2hldGhlciB0byByZXR1cm4gdGhlXG4gKiAgICAgY2xvc2VzdCBlbGVtZW50IHRoYXQgaXMgc21hbGxlciB0aGFuIG9yIGdyZWF0ZXIgdGhhbiB0aGUgb25lIHdlIGFyZVxuICogICAgIHNlYXJjaGluZyBmb3IsIHJlc3BlY3RpdmVseSwgaWYgdGhlIGV4YWN0IGVsZW1lbnQgY2Fubm90IGJlIGZvdW5kLlxuICogICAgIERlZmF1bHRzIHRvICdTb3VyY2VNYXBDb25zdW1lci5HUkVBVEVTVF9MT1dFUl9CT1VORCcuXG4gKlxuICogYW5kIGFuIG9iamVjdCBpcyByZXR1cm5lZCB3aXRoIHRoZSBmb2xsb3dpbmcgcHJvcGVydGllczpcbiAqXG4gKiAgIC0gc291cmNlOiBUaGUgb3JpZ2luYWwgc291cmNlIGZpbGUsIG9yIG51bGwuXG4gKiAgIC0gbGluZTogVGhlIGxpbmUgbnVtYmVyIGluIHRoZSBvcmlnaW5hbCBzb3VyY2UsIG9yIG51bGwuICBUaGVcbiAqICAgICBsaW5lIG51bWJlciBpcyAxLWJhc2VkLlxuICogICAtIGNvbHVtbjogVGhlIGNvbHVtbiBudW1iZXIgaW4gdGhlIG9yaWdpbmFsIHNvdXJjZSwgb3IgbnVsbC4gIFRoZVxuICogICAgIGNvbHVtbiBudW1iZXIgaXMgMC1iYXNlZC5cbiAqICAgLSBuYW1lOiBUaGUgb3JpZ2luYWwgaWRlbnRpZmllciwgb3IgbnVsbC5cbiAqL1xuQmFzaWNTb3VyY2VNYXBDb25zdW1lci5wcm90b3R5cGUub3JpZ2luYWxQb3NpdGlvbkZvciA9XG4gIGZ1bmN0aW9uIFNvdXJjZU1hcENvbnN1bWVyX29yaWdpbmFsUG9zaXRpb25Gb3IoYUFyZ3MpIHtcbiAgICB2YXIgbmVlZGxlID0ge1xuICAgICAgZ2VuZXJhdGVkTGluZTogdXRpbC5nZXRBcmcoYUFyZ3MsICdsaW5lJyksXG4gICAgICBnZW5lcmF0ZWRDb2x1bW46IHV0aWwuZ2V0QXJnKGFBcmdzLCAnY29sdW1uJylcbiAgICB9O1xuXG4gICAgdmFyIGluZGV4ID0gdGhpcy5fZmluZE1hcHBpbmcoXG4gICAgICBuZWVkbGUsXG4gICAgICB0aGlzLl9nZW5lcmF0ZWRNYXBwaW5ncyxcbiAgICAgIFwiZ2VuZXJhdGVkTGluZVwiLFxuICAgICAgXCJnZW5lcmF0ZWRDb2x1bW5cIixcbiAgICAgIHV0aWwuY29tcGFyZUJ5R2VuZXJhdGVkUG9zaXRpb25zRGVmbGF0ZWQsXG4gICAgICB1dGlsLmdldEFyZyhhQXJncywgJ2JpYXMnLCBTb3VyY2VNYXBDb25zdW1lci5HUkVBVEVTVF9MT1dFUl9CT1VORClcbiAgICApO1xuXG4gICAgaWYgKGluZGV4ID49IDApIHtcbiAgICAgIHZhciBtYXBwaW5nID0gdGhpcy5fZ2VuZXJhdGVkTWFwcGluZ3NbaW5kZXhdO1xuXG4gICAgICBpZiAobWFwcGluZy5nZW5lcmF0ZWRMaW5lID09PSBuZWVkbGUuZ2VuZXJhdGVkTGluZSkge1xuICAgICAgICB2YXIgc291cmNlID0gdXRpbC5nZXRBcmcobWFwcGluZywgJ3NvdXJjZScsIG51bGwpO1xuICAgICAgICBpZiAoc291cmNlICE9PSBudWxsKSB7XG4gICAgICAgICAgc291cmNlID0gdGhpcy5fc291cmNlcy5hdChzb3VyY2UpO1xuICAgICAgICAgIHNvdXJjZSA9IHV0aWwuY29tcHV0ZVNvdXJjZVVSTCh0aGlzLnNvdXJjZVJvb3QsIHNvdXJjZSwgdGhpcy5fc291cmNlTWFwVVJMKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgbmFtZSA9IHV0aWwuZ2V0QXJnKG1hcHBpbmcsICduYW1lJywgbnVsbCk7XG4gICAgICAgIGlmIChuYW1lICE9PSBudWxsKSB7XG4gICAgICAgICAgbmFtZSA9IHRoaXMuX25hbWVzLmF0KG5hbWUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgc291cmNlOiBzb3VyY2UsXG4gICAgICAgICAgbGluZTogdXRpbC5nZXRBcmcobWFwcGluZywgJ29yaWdpbmFsTGluZScsIG51bGwpLFxuICAgICAgICAgIGNvbHVtbjogdXRpbC5nZXRBcmcobWFwcGluZywgJ29yaWdpbmFsQ29sdW1uJywgbnVsbCksXG4gICAgICAgICAgbmFtZTogbmFtZVxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICBzb3VyY2U6IG51bGwsXG4gICAgICBsaW5lOiBudWxsLFxuICAgICAgY29sdW1uOiBudWxsLFxuICAgICAgbmFtZTogbnVsbFxuICAgIH07XG4gIH07XG5cbi8qKlxuICogUmV0dXJuIHRydWUgaWYgd2UgaGF2ZSB0aGUgc291cmNlIGNvbnRlbnQgZm9yIGV2ZXJ5IHNvdXJjZSBpbiB0aGUgc291cmNlXG4gKiBtYXAsIGZhbHNlIG90aGVyd2lzZS5cbiAqL1xuQmFzaWNTb3VyY2VNYXBDb25zdW1lci5wcm90b3R5cGUuaGFzQ29udGVudHNPZkFsbFNvdXJjZXMgPVxuICBmdW5jdGlvbiBCYXNpY1NvdXJjZU1hcENvbnN1bWVyX2hhc0NvbnRlbnRzT2ZBbGxTb3VyY2VzKCkge1xuICAgIGlmICghdGhpcy5zb3VyY2VzQ29udGVudCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5zb3VyY2VzQ29udGVudC5sZW5ndGggPj0gdGhpcy5fc291cmNlcy5zaXplKCkgJiZcbiAgICAgICF0aGlzLnNvdXJjZXNDb250ZW50LnNvbWUoZnVuY3Rpb24gKHNjKSB7IHJldHVybiBzYyA9PSBudWxsOyB9KTtcbiAgfTtcblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBvcmlnaW5hbCBzb3VyY2UgY29udGVudC4gVGhlIG9ubHkgYXJndW1lbnQgaXMgdGhlIHVybCBvZiB0aGVcbiAqIG9yaWdpbmFsIHNvdXJjZSBmaWxlLiBSZXR1cm5zIG51bGwgaWYgbm8gb3JpZ2luYWwgc291cmNlIGNvbnRlbnQgaXNcbiAqIGF2YWlsYWJsZS5cbiAqL1xuQmFzaWNTb3VyY2VNYXBDb25zdW1lci5wcm90b3R5cGUuc291cmNlQ29udGVudEZvciA9XG4gIGZ1bmN0aW9uIFNvdXJjZU1hcENvbnN1bWVyX3NvdXJjZUNvbnRlbnRGb3IoYVNvdXJjZSwgbnVsbE9uTWlzc2luZykge1xuICAgIGlmICghdGhpcy5zb3VyY2VzQ29udGVudCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgdmFyIGluZGV4ID0gdGhpcy5fZmluZFNvdXJjZUluZGV4KGFTb3VyY2UpO1xuICAgIGlmIChpbmRleCA+PSAwKSB7XG4gICAgICByZXR1cm4gdGhpcy5zb3VyY2VzQ29udGVudFtpbmRleF07XG4gICAgfVxuXG4gICAgdmFyIHJlbGF0aXZlU291cmNlID0gYVNvdXJjZTtcbiAgICBpZiAodGhpcy5zb3VyY2VSb290ICE9IG51bGwpIHtcbiAgICAgIHJlbGF0aXZlU291cmNlID0gdXRpbC5yZWxhdGl2ZSh0aGlzLnNvdXJjZVJvb3QsIHJlbGF0aXZlU291cmNlKTtcbiAgICB9XG5cbiAgICB2YXIgdXJsO1xuICAgIGlmICh0aGlzLnNvdXJjZVJvb3QgIT0gbnVsbFxuICAgICAgICAmJiAodXJsID0gdXRpbC51cmxQYXJzZSh0aGlzLnNvdXJjZVJvb3QpKSkge1xuICAgICAgLy8gWFhYOiBmaWxlOi8vIFVSSXMgYW5kIGFic29sdXRlIHBhdGhzIGxlYWQgdG8gdW5leHBlY3RlZCBiZWhhdmlvciBmb3JcbiAgICAgIC8vIG1hbnkgdXNlcnMuIFdlIGNhbiBoZWxwIHRoZW0gb3V0IHdoZW4gdGhleSBleHBlY3QgZmlsZTovLyBVUklzIHRvXG4gICAgICAvLyBiZWhhdmUgbGlrZSBpdCB3b3VsZCBpZiB0aGV5IHdlcmUgcnVubmluZyBhIGxvY2FsIEhUVFAgc2VydmVyLiBTZWVcbiAgICAgIC8vIGh0dHBzOi8vYnVnemlsbGEubW96aWxsYS5vcmcvc2hvd19idWcuY2dpP2lkPTg4NTU5Ny5cbiAgICAgIHZhciBmaWxlVXJpQWJzUGF0aCA9IHJlbGF0aXZlU291cmNlLnJlcGxhY2UoL15maWxlOlxcL1xcLy8sIFwiXCIpO1xuICAgICAgaWYgKHVybC5zY2hlbWUgPT0gXCJmaWxlXCJcbiAgICAgICAgICAmJiB0aGlzLl9zb3VyY2VzLmhhcyhmaWxlVXJpQWJzUGF0aCkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc291cmNlc0NvbnRlbnRbdGhpcy5fc291cmNlcy5pbmRleE9mKGZpbGVVcmlBYnNQYXRoKV1cbiAgICAgIH1cblxuICAgICAgaWYgKCghdXJsLnBhdGggfHwgdXJsLnBhdGggPT0gXCIvXCIpXG4gICAgICAgICAgJiYgdGhpcy5fc291cmNlcy5oYXMoXCIvXCIgKyByZWxhdGl2ZVNvdXJjZSkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc291cmNlc0NvbnRlbnRbdGhpcy5fc291cmNlcy5pbmRleE9mKFwiL1wiICsgcmVsYXRpdmVTb3VyY2UpXTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBUaGlzIGZ1bmN0aW9uIGlzIHVzZWQgcmVjdXJzaXZlbHkgZnJvbVxuICAgIC8vIEluZGV4ZWRTb3VyY2VNYXBDb25zdW1lci5wcm90b3R5cGUuc291cmNlQ29udGVudEZvci4gSW4gdGhhdCBjYXNlLCB3ZVxuICAgIC8vIGRvbid0IHdhbnQgdG8gdGhyb3cgaWYgd2UgY2FuJ3QgZmluZCB0aGUgc291cmNlIC0gd2UganVzdCB3YW50IHRvXG4gICAgLy8gcmV0dXJuIG51bGwsIHNvIHdlIHByb3ZpZGUgYSBmbGFnIHRvIGV4aXQgZ3JhY2VmdWxseS5cbiAgICBpZiAobnVsbE9uTWlzc2luZykge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdcIicgKyByZWxhdGl2ZVNvdXJjZSArICdcIiBpcyBub3QgaW4gdGhlIFNvdXJjZU1hcC4nKTtcbiAgICB9XG4gIH07XG5cbi8qKlxuICogUmV0dXJucyB0aGUgZ2VuZXJhdGVkIGxpbmUgYW5kIGNvbHVtbiBpbmZvcm1hdGlvbiBmb3IgdGhlIG9yaWdpbmFsIHNvdXJjZSxcbiAqIGxpbmUsIGFuZCBjb2x1bW4gcG9zaXRpb25zIHByb3ZpZGVkLiBUaGUgb25seSBhcmd1bWVudCBpcyBhbiBvYmplY3Qgd2l0aFxuICogdGhlIGZvbGxvd2luZyBwcm9wZXJ0aWVzOlxuICpcbiAqICAgLSBzb3VyY2U6IFRoZSBmaWxlbmFtZSBvZiB0aGUgb3JpZ2luYWwgc291cmNlLlxuICogICAtIGxpbmU6IFRoZSBsaW5lIG51bWJlciBpbiB0aGUgb3JpZ2luYWwgc291cmNlLiAgVGhlIGxpbmUgbnVtYmVyXG4gKiAgICAgaXMgMS1iYXNlZC5cbiAqICAgLSBjb2x1bW46IFRoZSBjb2x1bW4gbnVtYmVyIGluIHRoZSBvcmlnaW5hbCBzb3VyY2UuICBUaGUgY29sdW1uXG4gKiAgICAgbnVtYmVyIGlzIDAtYmFzZWQuXG4gKiAgIC0gYmlhczogRWl0aGVyICdTb3VyY2VNYXBDb25zdW1lci5HUkVBVEVTVF9MT1dFUl9CT1VORCcgb3JcbiAqICAgICAnU291cmNlTWFwQ29uc3VtZXIuTEVBU1RfVVBQRVJfQk9VTkQnLiBTcGVjaWZpZXMgd2hldGhlciB0byByZXR1cm4gdGhlXG4gKiAgICAgY2xvc2VzdCBlbGVtZW50IHRoYXQgaXMgc21hbGxlciB0aGFuIG9yIGdyZWF0ZXIgdGhhbiB0aGUgb25lIHdlIGFyZVxuICogICAgIHNlYXJjaGluZyBmb3IsIHJlc3BlY3RpdmVseSwgaWYgdGhlIGV4YWN0IGVsZW1lbnQgY2Fubm90IGJlIGZvdW5kLlxuICogICAgIERlZmF1bHRzIHRvICdTb3VyY2VNYXBDb25zdW1lci5HUkVBVEVTVF9MT1dFUl9CT1VORCcuXG4gKlxuICogYW5kIGFuIG9iamVjdCBpcyByZXR1cm5lZCB3aXRoIHRoZSBmb2xsb3dpbmcgcHJvcGVydGllczpcbiAqXG4gKiAgIC0gbGluZTogVGhlIGxpbmUgbnVtYmVyIGluIHRoZSBnZW5lcmF0ZWQgc291cmNlLCBvciBudWxsLiAgVGhlXG4gKiAgICAgbGluZSBudW1iZXIgaXMgMS1iYXNlZC5cbiAqICAgLSBjb2x1bW46IFRoZSBjb2x1bW4gbnVtYmVyIGluIHRoZSBnZW5lcmF0ZWQgc291cmNlLCBvciBudWxsLlxuICogICAgIFRoZSBjb2x1bW4gbnVtYmVyIGlzIDAtYmFzZWQuXG4gKi9cbkJhc2ljU291cmNlTWFwQ29uc3VtZXIucHJvdG90eXBlLmdlbmVyYXRlZFBvc2l0aW9uRm9yID1cbiAgZnVuY3Rpb24gU291cmNlTWFwQ29uc3VtZXJfZ2VuZXJhdGVkUG9zaXRpb25Gb3IoYUFyZ3MpIHtcbiAgICB2YXIgc291cmNlID0gdXRpbC5nZXRBcmcoYUFyZ3MsICdzb3VyY2UnKTtcbiAgICBzb3VyY2UgPSB0aGlzLl9maW5kU291cmNlSW5kZXgoc291cmNlKTtcbiAgICBpZiAoc291cmNlIDwgMCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgbGluZTogbnVsbCxcbiAgICAgICAgY29sdW1uOiBudWxsLFxuICAgICAgICBsYXN0Q29sdW1uOiBudWxsXG4gICAgICB9O1xuICAgIH1cblxuICAgIHZhciBuZWVkbGUgPSB7XG4gICAgICBzb3VyY2U6IHNvdXJjZSxcbiAgICAgIG9yaWdpbmFsTGluZTogdXRpbC5nZXRBcmcoYUFyZ3MsICdsaW5lJyksXG4gICAgICBvcmlnaW5hbENvbHVtbjogdXRpbC5nZXRBcmcoYUFyZ3MsICdjb2x1bW4nKVxuICAgIH07XG5cbiAgICB2YXIgaW5kZXggPSB0aGlzLl9maW5kTWFwcGluZyhcbiAgICAgIG5lZWRsZSxcbiAgICAgIHRoaXMuX29yaWdpbmFsTWFwcGluZ3MsXG4gICAgICBcIm9yaWdpbmFsTGluZVwiLFxuICAgICAgXCJvcmlnaW5hbENvbHVtblwiLFxuICAgICAgdXRpbC5jb21wYXJlQnlPcmlnaW5hbFBvc2l0aW9ucyxcbiAgICAgIHV0aWwuZ2V0QXJnKGFBcmdzLCAnYmlhcycsIFNvdXJjZU1hcENvbnN1bWVyLkdSRUFURVNUX0xPV0VSX0JPVU5EKVxuICAgICk7XG5cbiAgICBpZiAoaW5kZXggPj0gMCkge1xuICAgICAgdmFyIG1hcHBpbmcgPSB0aGlzLl9vcmlnaW5hbE1hcHBpbmdzW2luZGV4XTtcblxuICAgICAgaWYgKG1hcHBpbmcuc291cmNlID09PSBuZWVkbGUuc291cmNlKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgbGluZTogdXRpbC5nZXRBcmcobWFwcGluZywgJ2dlbmVyYXRlZExpbmUnLCBudWxsKSxcbiAgICAgICAgICBjb2x1bW46IHV0aWwuZ2V0QXJnKG1hcHBpbmcsICdnZW5lcmF0ZWRDb2x1bW4nLCBudWxsKSxcbiAgICAgICAgICBsYXN0Q29sdW1uOiB1dGlsLmdldEFyZyhtYXBwaW5nLCAnbGFzdEdlbmVyYXRlZENvbHVtbicsIG51bGwpXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIGxpbmU6IG51bGwsXG4gICAgICBjb2x1bW46IG51bGwsXG4gICAgICBsYXN0Q29sdW1uOiBudWxsXG4gICAgfTtcbiAgfTtcblxuZXhwb3J0cy5CYXNpY1NvdXJjZU1hcENvbnN1bWVyID0gQmFzaWNTb3VyY2VNYXBDb25zdW1lcjtcblxuLyoqXG4gKiBBbiBJbmRleGVkU291cmNlTWFwQ29uc3VtZXIgaW5zdGFuY2UgcmVwcmVzZW50cyBhIHBhcnNlZCBzb3VyY2UgbWFwIHdoaWNoXG4gKiB3ZSBjYW4gcXVlcnkgZm9yIGluZm9ybWF0aW9uLiBJdCBkaWZmZXJzIGZyb20gQmFzaWNTb3VyY2VNYXBDb25zdW1lciBpblxuICogdGhhdCBpdCB0YWtlcyBcImluZGV4ZWRcIiBzb3VyY2UgbWFwcyAoaS5lLiBvbmVzIHdpdGggYSBcInNlY3Rpb25zXCIgZmllbGQpIGFzXG4gKiBpbnB1dC5cbiAqXG4gKiBUaGUgZmlyc3QgcGFyYW1ldGVyIGlzIGEgcmF3IHNvdXJjZSBtYXAgKGVpdGhlciBhcyBhIEpTT04gc3RyaW5nLCBvciBhbHJlYWR5XG4gKiBwYXJzZWQgdG8gYW4gb2JqZWN0KS4gQWNjb3JkaW5nIHRvIHRoZSBzcGVjIGZvciBpbmRleGVkIHNvdXJjZSBtYXBzLCB0aGV5XG4gKiBoYXZlIHRoZSBmb2xsb3dpbmcgYXR0cmlidXRlczpcbiAqXG4gKiAgIC0gdmVyc2lvbjogV2hpY2ggdmVyc2lvbiBvZiB0aGUgc291cmNlIG1hcCBzcGVjIHRoaXMgbWFwIGlzIGZvbGxvd2luZy5cbiAqICAgLSBmaWxlOiBPcHRpb25hbC4gVGhlIGdlbmVyYXRlZCBmaWxlIHRoaXMgc291cmNlIG1hcCBpcyBhc3NvY2lhdGVkIHdpdGguXG4gKiAgIC0gc2VjdGlvbnM6IEEgbGlzdCBvZiBzZWN0aW9uIGRlZmluaXRpb25zLlxuICpcbiAqIEVhY2ggdmFsdWUgdW5kZXIgdGhlIFwic2VjdGlvbnNcIiBmaWVsZCBoYXMgdHdvIGZpZWxkczpcbiAqICAgLSBvZmZzZXQ6IFRoZSBvZmZzZXQgaW50byB0aGUgb3JpZ2luYWwgc3BlY2lmaWVkIGF0IHdoaWNoIHRoaXMgc2VjdGlvblxuICogICAgICAgYmVnaW5zIHRvIGFwcGx5LCBkZWZpbmVkIGFzIGFuIG9iamVjdCB3aXRoIGEgXCJsaW5lXCIgYW5kIFwiY29sdW1uXCJcbiAqICAgICAgIGZpZWxkLlxuICogICAtIG1hcDogQSBzb3VyY2UgbWFwIGRlZmluaXRpb24uIFRoaXMgc291cmNlIG1hcCBjb3VsZCBhbHNvIGJlIGluZGV4ZWQsXG4gKiAgICAgICBidXQgZG9lc24ndCBoYXZlIHRvIGJlLlxuICpcbiAqIEluc3RlYWQgb2YgdGhlIFwibWFwXCIgZmllbGQsIGl0J3MgYWxzbyBwb3NzaWJsZSB0byBoYXZlIGEgXCJ1cmxcIiBmaWVsZFxuICogc3BlY2lmeWluZyBhIFVSTCB0byByZXRyaWV2ZSBhIHNvdXJjZSBtYXAgZnJvbSwgYnV0IHRoYXQncyBjdXJyZW50bHlcbiAqIHVuc3VwcG9ydGVkLlxuICpcbiAqIEhlcmUncyBhbiBleGFtcGxlIHNvdXJjZSBtYXAsIHRha2VuIGZyb20gdGhlIHNvdXJjZSBtYXAgc3BlY1swXSwgYnV0XG4gKiBtb2RpZmllZCB0byBvbWl0IGEgc2VjdGlvbiB3aGljaCB1c2VzIHRoZSBcInVybFwiIGZpZWxkLlxuICpcbiAqICB7XG4gKiAgICB2ZXJzaW9uIDogMyxcbiAqICAgIGZpbGU6IFwiYXBwLmpzXCIsXG4gKiAgICBzZWN0aW9uczogW3tcbiAqICAgICAgb2Zmc2V0OiB7bGluZToxMDAsIGNvbHVtbjoxMH0sXG4gKiAgICAgIG1hcDoge1xuICogICAgICAgIHZlcnNpb24gOiAzLFxuICogICAgICAgIGZpbGU6IFwic2VjdGlvbi5qc1wiLFxuICogICAgICAgIHNvdXJjZXM6IFtcImZvby5qc1wiLCBcImJhci5qc1wiXSxcbiAqICAgICAgICBuYW1lczogW1wic3JjXCIsIFwibWFwc1wiLCBcImFyZVwiLCBcImZ1blwiXSxcbiAqICAgICAgICBtYXBwaW5nczogXCJBQUFBLEU7O0FCQ0RFO1wiXG4gKiAgICAgIH1cbiAqICAgIH1dLFxuICogIH1cbiAqXG4gKiBUaGUgc2Vjb25kIHBhcmFtZXRlciwgaWYgZ2l2ZW4sIGlzIGEgc3RyaW5nIHdob3NlIHZhbHVlIGlzIHRoZSBVUkxcbiAqIGF0IHdoaWNoIHRoZSBzb3VyY2UgbWFwIHdhcyBmb3VuZC4gIFRoaXMgVVJMIGlzIHVzZWQgdG8gY29tcHV0ZSB0aGVcbiAqIHNvdXJjZXMgYXJyYXkuXG4gKlxuICogWzBdOiBodHRwczovL2RvY3MuZ29vZ2xlLmNvbS9kb2N1bWVudC9kLzFVMVJHQWVoUXdSeXBVVG92RjFLUmxwaU9GemUwYi1fMmdjNmZBSDBLWTBrL2VkaXQjaGVhZGluZz1oLjUzNWVzM3hlcHJndFxuICovXG5mdW5jdGlvbiBJbmRleGVkU291cmNlTWFwQ29uc3VtZXIoYVNvdXJjZU1hcCwgYVNvdXJjZU1hcFVSTCkge1xuICB2YXIgc291cmNlTWFwID0gYVNvdXJjZU1hcDtcbiAgaWYgKHR5cGVvZiBhU291cmNlTWFwID09PSAnc3RyaW5nJykge1xuICAgIHNvdXJjZU1hcCA9IHV0aWwucGFyc2VTb3VyY2VNYXBJbnB1dChhU291cmNlTWFwKTtcbiAgfVxuXG4gIHZhciB2ZXJzaW9uID0gdXRpbC5nZXRBcmcoc291cmNlTWFwLCAndmVyc2lvbicpO1xuICB2YXIgc2VjdGlvbnMgPSB1dGlsLmdldEFyZyhzb3VyY2VNYXAsICdzZWN0aW9ucycpO1xuXG4gIGlmICh2ZXJzaW9uICE9IHRoaXMuX3ZlcnNpb24pIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vuc3VwcG9ydGVkIHZlcnNpb246ICcgKyB2ZXJzaW9uKTtcbiAgfVxuXG4gIHRoaXMuX3NvdXJjZXMgPSBuZXcgQXJyYXlTZXQoKTtcbiAgdGhpcy5fbmFtZXMgPSBuZXcgQXJyYXlTZXQoKTtcblxuICB2YXIgbGFzdE9mZnNldCA9IHtcbiAgICBsaW5lOiAtMSxcbiAgICBjb2x1bW46IDBcbiAgfTtcbiAgdGhpcy5fc2VjdGlvbnMgPSBzZWN0aW9ucy5tYXAoZnVuY3Rpb24gKHMpIHtcbiAgICBpZiAocy51cmwpIHtcbiAgICAgIC8vIFRoZSB1cmwgZmllbGQgd2lsbCByZXF1aXJlIHN1cHBvcnQgZm9yIGFzeW5jaHJvbmljaXR5LlxuICAgICAgLy8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9tb3ppbGxhL3NvdXJjZS1tYXAvaXNzdWVzLzE2XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1N1cHBvcnQgZm9yIHVybCBmaWVsZCBpbiBzZWN0aW9ucyBub3QgaW1wbGVtZW50ZWQuJyk7XG4gICAgfVxuICAgIHZhciBvZmZzZXQgPSB1dGlsLmdldEFyZyhzLCAnb2Zmc2V0Jyk7XG4gICAgdmFyIG9mZnNldExpbmUgPSB1dGlsLmdldEFyZyhvZmZzZXQsICdsaW5lJyk7XG4gICAgdmFyIG9mZnNldENvbHVtbiA9IHV0aWwuZ2V0QXJnKG9mZnNldCwgJ2NvbHVtbicpO1xuXG4gICAgaWYgKG9mZnNldExpbmUgPCBsYXN0T2Zmc2V0LmxpbmUgfHxcbiAgICAgICAgKG9mZnNldExpbmUgPT09IGxhc3RPZmZzZXQubGluZSAmJiBvZmZzZXRDb2x1bW4gPCBsYXN0T2Zmc2V0LmNvbHVtbikpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignU2VjdGlvbiBvZmZzZXRzIG11c3QgYmUgb3JkZXJlZCBhbmQgbm9uLW92ZXJsYXBwaW5nLicpO1xuICAgIH1cbiAgICBsYXN0T2Zmc2V0ID0gb2Zmc2V0O1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIGdlbmVyYXRlZE9mZnNldDoge1xuICAgICAgICAvLyBUaGUgb2Zmc2V0IGZpZWxkcyBhcmUgMC1iYXNlZCwgYnV0IHdlIHVzZSAxLWJhc2VkIGluZGljZXMgd2hlblxuICAgICAgICAvLyBlbmNvZGluZy9kZWNvZGluZyBmcm9tIFZMUS5cbiAgICAgICAgZ2VuZXJhdGVkTGluZTogb2Zmc2V0TGluZSArIDEsXG4gICAgICAgIGdlbmVyYXRlZENvbHVtbjogb2Zmc2V0Q29sdW1uICsgMVxuICAgICAgfSxcbiAgICAgIGNvbnN1bWVyOiBuZXcgU291cmNlTWFwQ29uc3VtZXIodXRpbC5nZXRBcmcocywgJ21hcCcpLCBhU291cmNlTWFwVVJMKVxuICAgIH1cbiAgfSk7XG59XG5cbkluZGV4ZWRTb3VyY2VNYXBDb25zdW1lci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKFNvdXJjZU1hcENvbnN1bWVyLnByb3RvdHlwZSk7XG5JbmRleGVkU291cmNlTWFwQ29uc3VtZXIucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gU291cmNlTWFwQ29uc3VtZXI7XG5cbi8qKlxuICogVGhlIHZlcnNpb24gb2YgdGhlIHNvdXJjZSBtYXBwaW5nIHNwZWMgdGhhdCB3ZSBhcmUgY29uc3VtaW5nLlxuICovXG5JbmRleGVkU291cmNlTWFwQ29uc3VtZXIucHJvdG90eXBlLl92ZXJzaW9uID0gMztcblxuLyoqXG4gKiBUaGUgbGlzdCBvZiBvcmlnaW5hbCBzb3VyY2VzLlxuICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoSW5kZXhlZFNvdXJjZU1hcENvbnN1bWVyLnByb3RvdHlwZSwgJ3NvdXJjZXMnLCB7XG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIHZhciBzb3VyY2VzID0gW107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLl9zZWN0aW9ucy5sZW5ndGg7IGkrKykge1xuICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCB0aGlzLl9zZWN0aW9uc1tpXS5jb25zdW1lci5zb3VyY2VzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgIHNvdXJjZXMucHVzaCh0aGlzLl9zZWN0aW9uc1tpXS5jb25zdW1lci5zb3VyY2VzW2pdKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHNvdXJjZXM7XG4gIH1cbn0pO1xuXG4vKipcbiAqIFJldHVybnMgdGhlIG9yaWdpbmFsIHNvdXJjZSwgbGluZSwgYW5kIGNvbHVtbiBpbmZvcm1hdGlvbiBmb3IgdGhlIGdlbmVyYXRlZFxuICogc291cmNlJ3MgbGluZSBhbmQgY29sdW1uIHBvc2l0aW9ucyBwcm92aWRlZC4gVGhlIG9ubHkgYXJndW1lbnQgaXMgYW4gb2JqZWN0XG4gKiB3aXRoIHRoZSBmb2xsb3dpbmcgcHJvcGVydGllczpcbiAqXG4gKiAgIC0gbGluZTogVGhlIGxpbmUgbnVtYmVyIGluIHRoZSBnZW5lcmF0ZWQgc291cmNlLiAgVGhlIGxpbmUgbnVtYmVyXG4gKiAgICAgaXMgMS1iYXNlZC5cbiAqICAgLSBjb2x1bW46IFRoZSBjb2x1bW4gbnVtYmVyIGluIHRoZSBnZW5lcmF0ZWQgc291cmNlLiAgVGhlIGNvbHVtblxuICogICAgIG51bWJlciBpcyAwLWJhc2VkLlxuICpcbiAqIGFuZCBhbiBvYmplY3QgaXMgcmV0dXJuZWQgd2l0aCB0aGUgZm9sbG93aW5nIHByb3BlcnRpZXM6XG4gKlxuICogICAtIHNvdXJjZTogVGhlIG9yaWdpbmFsIHNvdXJjZSBmaWxlLCBvciBudWxsLlxuICogICAtIGxpbmU6IFRoZSBsaW5lIG51bWJlciBpbiB0aGUgb3JpZ2luYWwgc291cmNlLCBvciBudWxsLiAgVGhlXG4gKiAgICAgbGluZSBudW1iZXIgaXMgMS1iYXNlZC5cbiAqICAgLSBjb2x1bW46IFRoZSBjb2x1bW4gbnVtYmVyIGluIHRoZSBvcmlnaW5hbCBzb3VyY2UsIG9yIG51bGwuICBUaGVcbiAqICAgICBjb2x1bW4gbnVtYmVyIGlzIDAtYmFzZWQuXG4gKiAgIC0gbmFtZTogVGhlIG9yaWdpbmFsIGlkZW50aWZpZXIsIG9yIG51bGwuXG4gKi9cbkluZGV4ZWRTb3VyY2VNYXBDb25zdW1lci5wcm90b3R5cGUub3JpZ2luYWxQb3NpdGlvbkZvciA9XG4gIGZ1bmN0aW9uIEluZGV4ZWRTb3VyY2VNYXBDb25zdW1lcl9vcmlnaW5hbFBvc2l0aW9uRm9yKGFBcmdzKSB7XG4gICAgdmFyIG5lZWRsZSA9IHtcbiAgICAgIGdlbmVyYXRlZExpbmU6IHV0aWwuZ2V0QXJnKGFBcmdzLCAnbGluZScpLFxuICAgICAgZ2VuZXJhdGVkQ29sdW1uOiB1dGlsLmdldEFyZyhhQXJncywgJ2NvbHVtbicpXG4gICAgfTtcblxuICAgIC8vIEZpbmQgdGhlIHNlY3Rpb24gY29udGFpbmluZyB0aGUgZ2VuZXJhdGVkIHBvc2l0aW9uIHdlJ3JlIHRyeWluZyB0byBtYXBcbiAgICAvLyB0byBhbiBvcmlnaW5hbCBwb3NpdGlvbi5cbiAgICB2YXIgc2VjdGlvbkluZGV4ID0gYmluYXJ5U2VhcmNoLnNlYXJjaChuZWVkbGUsIHRoaXMuX3NlY3Rpb25zLFxuICAgICAgZnVuY3Rpb24obmVlZGxlLCBzZWN0aW9uKSB7XG4gICAgICAgIHZhciBjbXAgPSBuZWVkbGUuZ2VuZXJhdGVkTGluZSAtIHNlY3Rpb24uZ2VuZXJhdGVkT2Zmc2V0LmdlbmVyYXRlZExpbmU7XG4gICAgICAgIGlmIChjbXApIHtcbiAgICAgICAgICByZXR1cm4gY21wO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIChuZWVkbGUuZ2VuZXJhdGVkQ29sdW1uIC1cbiAgICAgICAgICAgICAgICBzZWN0aW9uLmdlbmVyYXRlZE9mZnNldC5nZW5lcmF0ZWRDb2x1bW4pO1xuICAgICAgfSk7XG4gICAgdmFyIHNlY3Rpb24gPSB0aGlzLl9zZWN0aW9uc1tzZWN0aW9uSW5kZXhdO1xuXG4gICAgaWYgKCFzZWN0aW9uKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBzb3VyY2U6IG51bGwsXG4gICAgICAgIGxpbmU6IG51bGwsXG4gICAgICAgIGNvbHVtbjogbnVsbCxcbiAgICAgICAgbmFtZTogbnVsbFxuICAgICAgfTtcbiAgICB9XG5cbiAgICByZXR1cm4gc2VjdGlvbi5jb25zdW1lci5vcmlnaW5hbFBvc2l0aW9uRm9yKHtcbiAgICAgIGxpbmU6IG5lZWRsZS5nZW5lcmF0ZWRMaW5lIC1cbiAgICAgICAgKHNlY3Rpb24uZ2VuZXJhdGVkT2Zmc2V0LmdlbmVyYXRlZExpbmUgLSAxKSxcbiAgICAgIGNvbHVtbjogbmVlZGxlLmdlbmVyYXRlZENvbHVtbiAtXG4gICAgICAgIChzZWN0aW9uLmdlbmVyYXRlZE9mZnNldC5nZW5lcmF0ZWRMaW5lID09PSBuZWVkbGUuZ2VuZXJhdGVkTGluZVxuICAgICAgICAgPyBzZWN0aW9uLmdlbmVyYXRlZE9mZnNldC5nZW5lcmF0ZWRDb2x1bW4gLSAxXG4gICAgICAgICA6IDApLFxuICAgICAgYmlhczogYUFyZ3MuYmlhc1xuICAgIH0pO1xuICB9O1xuXG4vKipcbiAqIFJldHVybiB0cnVlIGlmIHdlIGhhdmUgdGhlIHNvdXJjZSBjb250ZW50IGZvciBldmVyeSBzb3VyY2UgaW4gdGhlIHNvdXJjZVxuICogbWFwLCBmYWxzZSBvdGhlcndpc2UuXG4gKi9cbkluZGV4ZWRTb3VyY2VNYXBDb25zdW1lci5wcm90b3R5cGUuaGFzQ29udGVudHNPZkFsbFNvdXJjZXMgPVxuICBmdW5jdGlvbiBJbmRleGVkU291cmNlTWFwQ29uc3VtZXJfaGFzQ29udGVudHNPZkFsbFNvdXJjZXMoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3NlY3Rpb25zLmV2ZXJ5KGZ1bmN0aW9uIChzKSB7XG4gICAgICByZXR1cm4gcy5jb25zdW1lci5oYXNDb250ZW50c09mQWxsU291cmNlcygpO1xuICAgIH0pO1xuICB9O1xuXG4vKipcbiAqIFJldHVybnMgdGhlIG9yaWdpbmFsIHNvdXJjZSBjb250ZW50LiBUaGUgb25seSBhcmd1bWVudCBpcyB0aGUgdXJsIG9mIHRoZVxuICogb3JpZ2luYWwgc291cmNlIGZpbGUuIFJldHVybnMgbnVsbCBpZiBubyBvcmlnaW5hbCBzb3VyY2UgY29udGVudCBpc1xuICogYXZhaWxhYmxlLlxuICovXG5JbmRleGVkU291cmNlTWFwQ29uc3VtZXIucHJvdG90eXBlLnNvdXJjZUNvbnRlbnRGb3IgPVxuICBmdW5jdGlvbiBJbmRleGVkU291cmNlTWFwQ29uc3VtZXJfc291cmNlQ29udGVudEZvcihhU291cmNlLCBudWxsT25NaXNzaW5nKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLl9zZWN0aW9ucy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHNlY3Rpb24gPSB0aGlzLl9zZWN0aW9uc1tpXTtcblxuICAgICAgdmFyIGNvbnRlbnQgPSBzZWN0aW9uLmNvbnN1bWVyLnNvdXJjZUNvbnRlbnRGb3IoYVNvdXJjZSwgdHJ1ZSk7XG4gICAgICBpZiAoY29udGVudCkge1xuICAgICAgICByZXR1cm4gY29udGVudDtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKG51bGxPbk1pc3NpbmcpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignXCInICsgYVNvdXJjZSArICdcIiBpcyBub3QgaW4gdGhlIFNvdXJjZU1hcC4nKTtcbiAgICB9XG4gIH07XG5cbi8qKlxuICogUmV0dXJucyB0aGUgZ2VuZXJhdGVkIGxpbmUgYW5kIGNvbHVtbiBpbmZvcm1hdGlvbiBmb3IgdGhlIG9yaWdpbmFsIHNvdXJjZSxcbiAqIGxpbmUsIGFuZCBjb2x1bW4gcG9zaXRpb25zIHByb3ZpZGVkLiBUaGUgb25seSBhcmd1bWVudCBpcyBhbiBvYmplY3Qgd2l0aFxuICogdGhlIGZvbGxvd2luZyBwcm9wZXJ0aWVzOlxuICpcbiAqICAgLSBzb3VyY2U6IFRoZSBmaWxlbmFtZSBvZiB0aGUgb3JpZ2luYWwgc291cmNlLlxuICogICAtIGxpbmU6IFRoZSBsaW5lIG51bWJlciBpbiB0aGUgb3JpZ2luYWwgc291cmNlLiAgVGhlIGxpbmUgbnVtYmVyXG4gKiAgICAgaXMgMS1iYXNlZC5cbiAqICAgLSBjb2x1bW46IFRoZSBjb2x1bW4gbnVtYmVyIGluIHRoZSBvcmlnaW5hbCBzb3VyY2UuICBUaGUgY29sdW1uXG4gKiAgICAgbnVtYmVyIGlzIDAtYmFzZWQuXG4gKlxuICogYW5kIGFuIG9iamVjdCBpcyByZXR1cm5lZCB3aXRoIHRoZSBmb2xsb3dpbmcgcHJvcGVydGllczpcbiAqXG4gKiAgIC0gbGluZTogVGhlIGxpbmUgbnVtYmVyIGluIHRoZSBnZW5lcmF0ZWQgc291cmNlLCBvciBudWxsLiAgVGhlXG4gKiAgICAgbGluZSBudW1iZXIgaXMgMS1iYXNlZC4gXG4gKiAgIC0gY29sdW1uOiBUaGUgY29sdW1uIG51bWJlciBpbiB0aGUgZ2VuZXJhdGVkIHNvdXJjZSwgb3IgbnVsbC5cbiAqICAgICBUaGUgY29sdW1uIG51bWJlciBpcyAwLWJhc2VkLlxuICovXG5JbmRleGVkU291cmNlTWFwQ29uc3VtZXIucHJvdG90eXBlLmdlbmVyYXRlZFBvc2l0aW9uRm9yID1cbiAgZnVuY3Rpb24gSW5kZXhlZFNvdXJjZU1hcENvbnN1bWVyX2dlbmVyYXRlZFBvc2l0aW9uRm9yKGFBcmdzKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLl9zZWN0aW9ucy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHNlY3Rpb24gPSB0aGlzLl9zZWN0aW9uc1tpXTtcblxuICAgICAgLy8gT25seSBjb25zaWRlciB0aGlzIHNlY3Rpb24gaWYgdGhlIHJlcXVlc3RlZCBzb3VyY2UgaXMgaW4gdGhlIGxpc3Qgb2ZcbiAgICAgIC8vIHNvdXJjZXMgb2YgdGhlIGNvbnN1bWVyLlxuICAgICAgaWYgKHNlY3Rpb24uY29uc3VtZXIuX2ZpbmRTb3VyY2VJbmRleCh1dGlsLmdldEFyZyhhQXJncywgJ3NvdXJjZScpKSA9PT0gLTEpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICB2YXIgZ2VuZXJhdGVkUG9zaXRpb24gPSBzZWN0aW9uLmNvbnN1bWVyLmdlbmVyYXRlZFBvc2l0aW9uRm9yKGFBcmdzKTtcbiAgICAgIGlmIChnZW5lcmF0ZWRQb3NpdGlvbikge1xuICAgICAgICB2YXIgcmV0ID0ge1xuICAgICAgICAgIGxpbmU6IGdlbmVyYXRlZFBvc2l0aW9uLmxpbmUgK1xuICAgICAgICAgICAgKHNlY3Rpb24uZ2VuZXJhdGVkT2Zmc2V0LmdlbmVyYXRlZExpbmUgLSAxKSxcbiAgICAgICAgICBjb2x1bW46IGdlbmVyYXRlZFBvc2l0aW9uLmNvbHVtbiArXG4gICAgICAgICAgICAoc2VjdGlvbi5nZW5lcmF0ZWRPZmZzZXQuZ2VuZXJhdGVkTGluZSA9PT0gZ2VuZXJhdGVkUG9zaXRpb24ubGluZVxuICAgICAgICAgICAgID8gc2VjdGlvbi5nZW5lcmF0ZWRPZmZzZXQuZ2VuZXJhdGVkQ29sdW1uIC0gMVxuICAgICAgICAgICAgIDogMClcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgbGluZTogbnVsbCxcbiAgICAgIGNvbHVtbjogbnVsbFxuICAgIH07XG4gIH07XG5cbi8qKlxuICogUGFyc2UgdGhlIG1hcHBpbmdzIGluIGEgc3RyaW5nIGluIHRvIGEgZGF0YSBzdHJ1Y3R1cmUgd2hpY2ggd2UgY2FuIGVhc2lseVxuICogcXVlcnkgKHRoZSBvcmRlcmVkIGFycmF5cyBpbiB0aGUgYHRoaXMuX19nZW5lcmF0ZWRNYXBwaW5nc2AgYW5kXG4gKiBgdGhpcy5fX29yaWdpbmFsTWFwcGluZ3NgIHByb3BlcnRpZXMpLlxuICovXG5JbmRleGVkU291cmNlTWFwQ29uc3VtZXIucHJvdG90eXBlLl9wYXJzZU1hcHBpbmdzID1cbiAgZnVuY3Rpb24gSW5kZXhlZFNvdXJjZU1hcENvbnN1bWVyX3BhcnNlTWFwcGluZ3MoYVN0ciwgYVNvdXJjZVJvb3QpIHtcbiAgICB0aGlzLl9fZ2VuZXJhdGVkTWFwcGluZ3MgPSBbXTtcbiAgICB0aGlzLl9fb3JpZ2luYWxNYXBwaW5ncyA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5fc2VjdGlvbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBzZWN0aW9uID0gdGhpcy5fc2VjdGlvbnNbaV07XG4gICAgICB2YXIgc2VjdGlvbk1hcHBpbmdzID0gc2VjdGlvbi5jb25zdW1lci5fZ2VuZXJhdGVkTWFwcGluZ3M7XG4gICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHNlY3Rpb25NYXBwaW5ncy5sZW5ndGg7IGorKykge1xuICAgICAgICB2YXIgbWFwcGluZyA9IHNlY3Rpb25NYXBwaW5nc1tqXTtcblxuICAgICAgICB2YXIgc291cmNlID0gc2VjdGlvbi5jb25zdW1lci5fc291cmNlcy5hdChtYXBwaW5nLnNvdXJjZSk7XG4gICAgICAgIHNvdXJjZSA9IHV0aWwuY29tcHV0ZVNvdXJjZVVSTChzZWN0aW9uLmNvbnN1bWVyLnNvdXJjZVJvb3QsIHNvdXJjZSwgdGhpcy5fc291cmNlTWFwVVJMKTtcbiAgICAgICAgdGhpcy5fc291cmNlcy5hZGQoc291cmNlKTtcbiAgICAgICAgc291cmNlID0gdGhpcy5fc291cmNlcy5pbmRleE9mKHNvdXJjZSk7XG5cbiAgICAgICAgdmFyIG5hbWUgPSBudWxsO1xuICAgICAgICBpZiAobWFwcGluZy5uYW1lKSB7XG4gICAgICAgICAgbmFtZSA9IHNlY3Rpb24uY29uc3VtZXIuX25hbWVzLmF0KG1hcHBpbmcubmFtZSk7XG4gICAgICAgICAgdGhpcy5fbmFtZXMuYWRkKG5hbWUpO1xuICAgICAgICAgIG5hbWUgPSB0aGlzLl9uYW1lcy5pbmRleE9mKG5hbWUpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gVGhlIG1hcHBpbmdzIGNvbWluZyBmcm9tIHRoZSBjb25zdW1lciBmb3IgdGhlIHNlY3Rpb24gaGF2ZVxuICAgICAgICAvLyBnZW5lcmF0ZWQgcG9zaXRpb25zIHJlbGF0aXZlIHRvIHRoZSBzdGFydCBvZiB0aGUgc2VjdGlvbiwgc28gd2VcbiAgICAgICAgLy8gbmVlZCB0byBvZmZzZXQgdGhlbSB0byBiZSByZWxhdGl2ZSB0byB0aGUgc3RhcnQgb2YgdGhlIGNvbmNhdGVuYXRlZFxuICAgICAgICAvLyBnZW5lcmF0ZWQgZmlsZS5cbiAgICAgICAgdmFyIGFkanVzdGVkTWFwcGluZyA9IHtcbiAgICAgICAgICBzb3VyY2U6IHNvdXJjZSxcbiAgICAgICAgICBnZW5lcmF0ZWRMaW5lOiBtYXBwaW5nLmdlbmVyYXRlZExpbmUgK1xuICAgICAgICAgICAgKHNlY3Rpb24uZ2VuZXJhdGVkT2Zmc2V0LmdlbmVyYXRlZExpbmUgLSAxKSxcbiAgICAgICAgICBnZW5lcmF0ZWRDb2x1bW46IG1hcHBpbmcuZ2VuZXJhdGVkQ29sdW1uICtcbiAgICAgICAgICAgIChzZWN0aW9uLmdlbmVyYXRlZE9mZnNldC5nZW5lcmF0ZWRMaW5lID09PSBtYXBwaW5nLmdlbmVyYXRlZExpbmVcbiAgICAgICAgICAgID8gc2VjdGlvbi5nZW5lcmF0ZWRPZmZzZXQuZ2VuZXJhdGVkQ29sdW1uIC0gMVxuICAgICAgICAgICAgOiAwKSxcbiAgICAgICAgICBvcmlnaW5hbExpbmU6IG1hcHBpbmcub3JpZ2luYWxMaW5lLFxuICAgICAgICAgIG9yaWdpbmFsQ29sdW1uOiBtYXBwaW5nLm9yaWdpbmFsQ29sdW1uLFxuICAgICAgICAgIG5hbWU6IG5hbWVcbiAgICAgICAgfTtcblxuICAgICAgICB0aGlzLl9fZ2VuZXJhdGVkTWFwcGluZ3MucHVzaChhZGp1c3RlZE1hcHBpbmcpO1xuICAgICAgICBpZiAodHlwZW9mIGFkanVzdGVkTWFwcGluZy5vcmlnaW5hbExpbmUgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgdGhpcy5fX29yaWdpbmFsTWFwcGluZ3MucHVzaChhZGp1c3RlZE1hcHBpbmcpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcXVpY2tTb3J0KHRoaXMuX19nZW5lcmF0ZWRNYXBwaW5ncywgdXRpbC5jb21wYXJlQnlHZW5lcmF0ZWRQb3NpdGlvbnNEZWZsYXRlZCk7XG4gICAgcXVpY2tTb3J0KHRoaXMuX19vcmlnaW5hbE1hcHBpbmdzLCB1dGlsLmNvbXBhcmVCeU9yaWdpbmFsUG9zaXRpb25zKTtcbiAgfTtcblxuZXhwb3J0cy5JbmRleGVkU291cmNlTWFwQ29uc3VtZXIgPSBJbmRleGVkU291cmNlTWFwQ29uc3VtZXI7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvZWxlY3Ryb24tdXBkYXRlci9ub2RlX21vZHVsZXMvc291cmNlLW1hcC9saWIvc291cmNlLW1hcC1jb25zdW1lci5qcyIsIi8qIC0qLSBNb2RlOiBqczsganMtaW5kZW50LWxldmVsOiAyOyAtKi0gKi9cbi8qXG4gKiBDb3B5cmlnaHQgMjAxMSBNb3ppbGxhIEZvdW5kYXRpb24gYW5kIGNvbnRyaWJ1dG9yc1xuICogTGljZW5zZWQgdW5kZXIgdGhlIE5ldyBCU0QgbGljZW5zZS4gU2VlIExJQ0VOU0Ugb3I6XG4gKiBodHRwOi8vb3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvQlNELTMtQ2xhdXNlXG4gKi9cblxuZXhwb3J0cy5HUkVBVEVTVF9MT1dFUl9CT1VORCA9IDE7XG5leHBvcnRzLkxFQVNUX1VQUEVSX0JPVU5EID0gMjtcblxuLyoqXG4gKiBSZWN1cnNpdmUgaW1wbGVtZW50YXRpb24gb2YgYmluYXJ5IHNlYXJjaC5cbiAqXG4gKiBAcGFyYW0gYUxvdyBJbmRpY2VzIGhlcmUgYW5kIGxvd2VyIGRvIG5vdCBjb250YWluIHRoZSBuZWVkbGUuXG4gKiBAcGFyYW0gYUhpZ2ggSW5kaWNlcyBoZXJlIGFuZCBoaWdoZXIgZG8gbm90IGNvbnRhaW4gdGhlIG5lZWRsZS5cbiAqIEBwYXJhbSBhTmVlZGxlIFRoZSBlbGVtZW50IGJlaW5nIHNlYXJjaGVkIGZvci5cbiAqIEBwYXJhbSBhSGF5c3RhY2sgVGhlIG5vbi1lbXB0eSBhcnJheSBiZWluZyBzZWFyY2hlZC5cbiAqIEBwYXJhbSBhQ29tcGFyZSBGdW5jdGlvbiB3aGljaCB0YWtlcyB0d28gZWxlbWVudHMgYW5kIHJldHVybnMgLTEsIDAsIG9yIDEuXG4gKiBAcGFyYW0gYUJpYXMgRWl0aGVyICdiaW5hcnlTZWFyY2guR1JFQVRFU1RfTE9XRVJfQk9VTkQnIG9yXG4gKiAgICAgJ2JpbmFyeVNlYXJjaC5MRUFTVF9VUFBFUl9CT1VORCcuIFNwZWNpZmllcyB3aGV0aGVyIHRvIHJldHVybiB0aGVcbiAqICAgICBjbG9zZXN0IGVsZW1lbnQgdGhhdCBpcyBzbWFsbGVyIHRoYW4gb3IgZ3JlYXRlciB0aGFuIHRoZSBvbmUgd2UgYXJlXG4gKiAgICAgc2VhcmNoaW5nIGZvciwgcmVzcGVjdGl2ZWx5LCBpZiB0aGUgZXhhY3QgZWxlbWVudCBjYW5ub3QgYmUgZm91bmQuXG4gKi9cbmZ1bmN0aW9uIHJlY3Vyc2l2ZVNlYXJjaChhTG93LCBhSGlnaCwgYU5lZWRsZSwgYUhheXN0YWNrLCBhQ29tcGFyZSwgYUJpYXMpIHtcbiAgLy8gVGhpcyBmdW5jdGlvbiB0ZXJtaW5hdGVzIHdoZW4gb25lIG9mIHRoZSBmb2xsb3dpbmcgaXMgdHJ1ZTpcbiAgLy9cbiAgLy8gICAxLiBXZSBmaW5kIHRoZSBleGFjdCBlbGVtZW50IHdlIGFyZSBsb29raW5nIGZvci5cbiAgLy9cbiAgLy8gICAyLiBXZSBkaWQgbm90IGZpbmQgdGhlIGV4YWN0IGVsZW1lbnQsIGJ1dCB3ZSBjYW4gcmV0dXJuIHRoZSBpbmRleCBvZlxuICAvLyAgICAgIHRoZSBuZXh0LWNsb3Nlc3QgZWxlbWVudC5cbiAgLy9cbiAgLy8gICAzLiBXZSBkaWQgbm90IGZpbmQgdGhlIGV4YWN0IGVsZW1lbnQsIGFuZCB0aGVyZSBpcyBubyBuZXh0LWNsb3Nlc3RcbiAgLy8gICAgICBlbGVtZW50IHRoYW4gdGhlIG9uZSB3ZSBhcmUgc2VhcmNoaW5nIGZvciwgc28gd2UgcmV0dXJuIC0xLlxuICB2YXIgbWlkID0gTWF0aC5mbG9vcigoYUhpZ2ggLSBhTG93KSAvIDIpICsgYUxvdztcbiAgdmFyIGNtcCA9IGFDb21wYXJlKGFOZWVkbGUsIGFIYXlzdGFja1ttaWRdLCB0cnVlKTtcbiAgaWYgKGNtcCA9PT0gMCkge1xuICAgIC8vIEZvdW5kIHRoZSBlbGVtZW50IHdlIGFyZSBsb29raW5nIGZvci5cbiAgICByZXR1cm4gbWlkO1xuICB9XG4gIGVsc2UgaWYgKGNtcCA+IDApIHtcbiAgICAvLyBPdXIgbmVlZGxlIGlzIGdyZWF0ZXIgdGhhbiBhSGF5c3RhY2tbbWlkXS5cbiAgICBpZiAoYUhpZ2ggLSBtaWQgPiAxKSB7XG4gICAgICAvLyBUaGUgZWxlbWVudCBpcyBpbiB0aGUgdXBwZXIgaGFsZi5cbiAgICAgIHJldHVybiByZWN1cnNpdmVTZWFyY2gobWlkLCBhSGlnaCwgYU5lZWRsZSwgYUhheXN0YWNrLCBhQ29tcGFyZSwgYUJpYXMpO1xuICAgIH1cblxuICAgIC8vIFRoZSBleGFjdCBuZWVkbGUgZWxlbWVudCB3YXMgbm90IGZvdW5kIGluIHRoaXMgaGF5c3RhY2suIERldGVybWluZSBpZlxuICAgIC8vIHdlIGFyZSBpbiB0ZXJtaW5hdGlvbiBjYXNlICgzKSBvciAoMikgYW5kIHJldHVybiB0aGUgYXBwcm9wcmlhdGUgdGhpbmcuXG4gICAgaWYgKGFCaWFzID09IGV4cG9ydHMuTEVBU1RfVVBQRVJfQk9VTkQpIHtcbiAgICAgIHJldHVybiBhSGlnaCA8IGFIYXlzdGFjay5sZW5ndGggPyBhSGlnaCA6IC0xO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gbWlkO1xuICAgIH1cbiAgfVxuICBlbHNlIHtcbiAgICAvLyBPdXIgbmVlZGxlIGlzIGxlc3MgdGhhbiBhSGF5c3RhY2tbbWlkXS5cbiAgICBpZiAobWlkIC0gYUxvdyA+IDEpIHtcbiAgICAgIC8vIFRoZSBlbGVtZW50IGlzIGluIHRoZSBsb3dlciBoYWxmLlxuICAgICAgcmV0dXJuIHJlY3Vyc2l2ZVNlYXJjaChhTG93LCBtaWQsIGFOZWVkbGUsIGFIYXlzdGFjaywgYUNvbXBhcmUsIGFCaWFzKTtcbiAgICB9XG5cbiAgICAvLyB3ZSBhcmUgaW4gdGVybWluYXRpb24gY2FzZSAoMykgb3IgKDIpIGFuZCByZXR1cm4gdGhlIGFwcHJvcHJpYXRlIHRoaW5nLlxuICAgIGlmIChhQmlhcyA9PSBleHBvcnRzLkxFQVNUX1VQUEVSX0JPVU5EKSB7XG4gICAgICByZXR1cm4gbWlkO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gYUxvdyA8IDAgPyAtMSA6IGFMb3c7XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogVGhpcyBpcyBhbiBpbXBsZW1lbnRhdGlvbiBvZiBiaW5hcnkgc2VhcmNoIHdoaWNoIHdpbGwgYWx3YXlzIHRyeSBhbmQgcmV0dXJuXG4gKiB0aGUgaW5kZXggb2YgdGhlIGNsb3Nlc3QgZWxlbWVudCBpZiB0aGVyZSBpcyBubyBleGFjdCBoaXQuIFRoaXMgaXMgYmVjYXVzZVxuICogbWFwcGluZ3MgYmV0d2VlbiBvcmlnaW5hbCBhbmQgZ2VuZXJhdGVkIGxpbmUvY29sIHBhaXJzIGFyZSBzaW5nbGUgcG9pbnRzLFxuICogYW5kIHRoZXJlIGlzIGFuIGltcGxpY2l0IHJlZ2lvbiBiZXR3ZWVuIGVhY2ggb2YgdGhlbSwgc28gYSBtaXNzIGp1c3QgbWVhbnNcbiAqIHRoYXQgeW91IGFyZW4ndCBvbiB0aGUgdmVyeSBzdGFydCBvZiBhIHJlZ2lvbi5cbiAqXG4gKiBAcGFyYW0gYU5lZWRsZSBUaGUgZWxlbWVudCB5b3UgYXJlIGxvb2tpbmcgZm9yLlxuICogQHBhcmFtIGFIYXlzdGFjayBUaGUgYXJyYXkgdGhhdCBpcyBiZWluZyBzZWFyY2hlZC5cbiAqIEBwYXJhbSBhQ29tcGFyZSBBIGZ1bmN0aW9uIHdoaWNoIHRha2VzIHRoZSBuZWVkbGUgYW5kIGFuIGVsZW1lbnQgaW4gdGhlXG4gKiAgICAgYXJyYXkgYW5kIHJldHVybnMgLTEsIDAsIG9yIDEgZGVwZW5kaW5nIG9uIHdoZXRoZXIgdGhlIG5lZWRsZSBpcyBsZXNzXG4gKiAgICAgdGhhbiwgZXF1YWwgdG8sIG9yIGdyZWF0ZXIgdGhhbiB0aGUgZWxlbWVudCwgcmVzcGVjdGl2ZWx5LlxuICogQHBhcmFtIGFCaWFzIEVpdGhlciAnYmluYXJ5U2VhcmNoLkdSRUFURVNUX0xPV0VSX0JPVU5EJyBvclxuICogICAgICdiaW5hcnlTZWFyY2guTEVBU1RfVVBQRVJfQk9VTkQnLiBTcGVjaWZpZXMgd2hldGhlciB0byByZXR1cm4gdGhlXG4gKiAgICAgY2xvc2VzdCBlbGVtZW50IHRoYXQgaXMgc21hbGxlciB0aGFuIG9yIGdyZWF0ZXIgdGhhbiB0aGUgb25lIHdlIGFyZVxuICogICAgIHNlYXJjaGluZyBmb3IsIHJlc3BlY3RpdmVseSwgaWYgdGhlIGV4YWN0IGVsZW1lbnQgY2Fubm90IGJlIGZvdW5kLlxuICogICAgIERlZmF1bHRzIHRvICdiaW5hcnlTZWFyY2guR1JFQVRFU1RfTE9XRVJfQk9VTkQnLlxuICovXG5leHBvcnRzLnNlYXJjaCA9IGZ1bmN0aW9uIHNlYXJjaChhTmVlZGxlLCBhSGF5c3RhY2ssIGFDb21wYXJlLCBhQmlhcykge1xuICBpZiAoYUhheXN0YWNrLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiAtMTtcbiAgfVxuXG4gIHZhciBpbmRleCA9IHJlY3Vyc2l2ZVNlYXJjaCgtMSwgYUhheXN0YWNrLmxlbmd0aCwgYU5lZWRsZSwgYUhheXN0YWNrLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYUNvbXBhcmUsIGFCaWFzIHx8IGV4cG9ydHMuR1JFQVRFU1RfTE9XRVJfQk9VTkQpO1xuICBpZiAoaW5kZXggPCAwKSB7XG4gICAgcmV0dXJuIC0xO1xuICB9XG5cbiAgLy8gV2UgaGF2ZSBmb3VuZCBlaXRoZXIgdGhlIGV4YWN0IGVsZW1lbnQsIG9yIHRoZSBuZXh0LWNsb3Nlc3QgZWxlbWVudCB0aGFuXG4gIC8vIHRoZSBvbmUgd2UgYXJlIHNlYXJjaGluZyBmb3IuIEhvd2V2ZXIsIHRoZXJlIG1heSBiZSBtb3JlIHRoYW4gb25lIHN1Y2hcbiAgLy8gZWxlbWVudC4gTWFrZSBzdXJlIHdlIGFsd2F5cyByZXR1cm4gdGhlIHNtYWxsZXN0IG9mIHRoZXNlLlxuICB3aGlsZSAoaW5kZXggLSAxID49IDApIHtcbiAgICBpZiAoYUNvbXBhcmUoYUhheXN0YWNrW2luZGV4XSwgYUhheXN0YWNrW2luZGV4IC0gMV0sIHRydWUpICE9PSAwKSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgLS1pbmRleDtcbiAgfVxuXG4gIHJldHVybiBpbmRleDtcbn07XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvZWxlY3Ryb24tdXBkYXRlci9ub2RlX21vZHVsZXMvc291cmNlLW1hcC9saWIvYmluYXJ5LXNlYXJjaC5qcyIsIi8qIC0qLSBNb2RlOiBqczsganMtaW5kZW50LWxldmVsOiAyOyAtKi0gKi9cbi8qXG4gKiBDb3B5cmlnaHQgMjAxMSBNb3ppbGxhIEZvdW5kYXRpb24gYW5kIGNvbnRyaWJ1dG9yc1xuICogTGljZW5zZWQgdW5kZXIgdGhlIE5ldyBCU0QgbGljZW5zZS4gU2VlIExJQ0VOU0Ugb3I6XG4gKiBodHRwOi8vb3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvQlNELTMtQ2xhdXNlXG4gKi9cblxuLy8gSXQgdHVybnMgb3V0IHRoYXQgc29tZSAobW9zdD8pIEphdmFTY3JpcHQgZW5naW5lcyBkb24ndCBzZWxmLWhvc3Rcbi8vIGBBcnJheS5wcm90b3R5cGUuc29ydGAuIFRoaXMgbWFrZXMgc2Vuc2UgYmVjYXVzZSBDKysgd2lsbCBsaWtlbHkgcmVtYWluXG4vLyBmYXN0ZXIgdGhhbiBKUyB3aGVuIGRvaW5nIHJhdyBDUFUtaW50ZW5zaXZlIHNvcnRpbmcuIEhvd2V2ZXIsIHdoZW4gdXNpbmcgYVxuLy8gY3VzdG9tIGNvbXBhcmF0b3IgZnVuY3Rpb24sIGNhbGxpbmcgYmFjayBhbmQgZm9ydGggYmV0d2VlbiB0aGUgVk0ncyBDKysgYW5kXG4vLyBKSVQnZCBKUyBpcyByYXRoZXIgc2xvdyAqYW5kKiBsb3NlcyBKSVQgdHlwZSBpbmZvcm1hdGlvbiwgcmVzdWx0aW5nIGluXG4vLyB3b3JzZSBnZW5lcmF0ZWQgY29kZSBmb3IgdGhlIGNvbXBhcmF0b3IgZnVuY3Rpb24gdGhhbiB3b3VsZCBiZSBvcHRpbWFsLiBJblxuLy8gZmFjdCwgd2hlbiBzb3J0aW5nIHdpdGggYSBjb21wYXJhdG9yLCB0aGVzZSBjb3N0cyBvdXR3ZWlnaCB0aGUgYmVuZWZpdHMgb2Zcbi8vIHNvcnRpbmcgaW4gQysrLiBCeSB1c2luZyBvdXIgb3duIEpTLWltcGxlbWVudGVkIFF1aWNrIFNvcnQgKGJlbG93KSwgd2UgZ2V0XG4vLyBhIH4zNTAwbXMgbWVhbiBzcGVlZC11cCBpbiBgYmVuY2gvYmVuY2guaHRtbGAuXG5cbi8qKlxuICogU3dhcCB0aGUgZWxlbWVudHMgaW5kZXhlZCBieSBgeGAgYW5kIGB5YCBpbiB0aGUgYXJyYXkgYGFyeWAuXG4gKlxuICogQHBhcmFtIHtBcnJheX0gYXJ5XG4gKiAgICAgICAgVGhlIGFycmF5LlxuICogQHBhcmFtIHtOdW1iZXJ9IHhcbiAqICAgICAgICBUaGUgaW5kZXggb2YgdGhlIGZpcnN0IGl0ZW0uXG4gKiBAcGFyYW0ge051bWJlcn0geVxuICogICAgICAgIFRoZSBpbmRleCBvZiB0aGUgc2Vjb25kIGl0ZW0uXG4gKi9cbmZ1bmN0aW9uIHN3YXAoYXJ5LCB4LCB5KSB7XG4gIHZhciB0ZW1wID0gYXJ5W3hdO1xuICBhcnlbeF0gPSBhcnlbeV07XG4gIGFyeVt5XSA9IHRlbXA7XG59XG5cbi8qKlxuICogUmV0dXJucyBhIHJhbmRvbSBpbnRlZ2VyIHdpdGhpbiB0aGUgcmFuZ2UgYGxvdyAuLiBoaWdoYCBpbmNsdXNpdmUuXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IGxvd1xuICogICAgICAgIFRoZSBsb3dlciBib3VuZCBvbiB0aGUgcmFuZ2UuXG4gKiBAcGFyYW0ge051bWJlcn0gaGlnaFxuICogICAgICAgIFRoZSB1cHBlciBib3VuZCBvbiB0aGUgcmFuZ2UuXG4gKi9cbmZ1bmN0aW9uIHJhbmRvbUludEluUmFuZ2UobG93LCBoaWdoKSB7XG4gIHJldHVybiBNYXRoLnJvdW5kKGxvdyArIChNYXRoLnJhbmRvbSgpICogKGhpZ2ggLSBsb3cpKSk7XG59XG5cbi8qKlxuICogVGhlIFF1aWNrIFNvcnQgYWxnb3JpdGhtLlxuICpcbiAqIEBwYXJhbSB7QXJyYXl9IGFyeVxuICogICAgICAgIEFuIGFycmF5IHRvIHNvcnQuXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBjb21wYXJhdG9yXG4gKiAgICAgICAgRnVuY3Rpb24gdG8gdXNlIHRvIGNvbXBhcmUgdHdvIGl0ZW1zLlxuICogQHBhcmFtIHtOdW1iZXJ9IHBcbiAqICAgICAgICBTdGFydCBpbmRleCBvZiB0aGUgYXJyYXlcbiAqIEBwYXJhbSB7TnVtYmVyfSByXG4gKiAgICAgICAgRW5kIGluZGV4IG9mIHRoZSBhcnJheVxuICovXG5mdW5jdGlvbiBkb1F1aWNrU29ydChhcnksIGNvbXBhcmF0b3IsIHAsIHIpIHtcbiAgLy8gSWYgb3VyIGxvd2VyIGJvdW5kIGlzIGxlc3MgdGhhbiBvdXIgdXBwZXIgYm91bmQsIHdlICgxKSBwYXJ0aXRpb24gdGhlXG4gIC8vIGFycmF5IGludG8gdHdvIHBpZWNlcyBhbmQgKDIpIHJlY3Vyc2Ugb24gZWFjaCBoYWxmLiBJZiBpdCBpcyBub3QsIHRoaXMgaXNcbiAgLy8gdGhlIGVtcHR5IGFycmF5IGFuZCBvdXIgYmFzZSBjYXNlLlxuXG4gIGlmIChwIDwgcikge1xuICAgIC8vICgxKSBQYXJ0aXRpb25pbmcuXG4gICAgLy9cbiAgICAvLyBUaGUgcGFydGl0aW9uaW5nIGNob29zZXMgYSBwaXZvdCBiZXR3ZWVuIGBwYCBhbmQgYHJgIGFuZCBtb3ZlcyBhbGxcbiAgICAvLyBlbGVtZW50cyB0aGF0IGFyZSBsZXNzIHRoYW4gb3IgZXF1YWwgdG8gdGhlIHBpdm90IHRvIHRoZSBiZWZvcmUgaXQsIGFuZFxuICAgIC8vIGFsbCB0aGUgZWxlbWVudHMgdGhhdCBhcmUgZ3JlYXRlciB0aGFuIGl0IGFmdGVyIGl0LiBUaGUgZWZmZWN0IGlzIHRoYXRcbiAgICAvLyBvbmNlIHBhcnRpdGlvbiBpcyBkb25lLCB0aGUgcGl2b3QgaXMgaW4gdGhlIGV4YWN0IHBsYWNlIGl0IHdpbGwgYmUgd2hlblxuICAgIC8vIHRoZSBhcnJheSBpcyBwdXQgaW4gc29ydGVkIG9yZGVyLCBhbmQgaXQgd2lsbCBub3QgbmVlZCB0byBiZSBtb3ZlZFxuICAgIC8vIGFnYWluLiBUaGlzIHJ1bnMgaW4gTyhuKSB0aW1lLlxuXG4gICAgLy8gQWx3YXlzIGNob29zZSBhIHJhbmRvbSBwaXZvdCBzbyB0aGF0IGFuIGlucHV0IGFycmF5IHdoaWNoIGlzIHJldmVyc2VcbiAgICAvLyBzb3J0ZWQgZG9lcyBub3QgY2F1c2UgTyhuXjIpIHJ1bm5pbmcgdGltZS5cbiAgICB2YXIgcGl2b3RJbmRleCA9IHJhbmRvbUludEluUmFuZ2UocCwgcik7XG4gICAgdmFyIGkgPSBwIC0gMTtcblxuICAgIHN3YXAoYXJ5LCBwaXZvdEluZGV4LCByKTtcbiAgICB2YXIgcGl2b3QgPSBhcnlbcl07XG5cbiAgICAvLyBJbW1lZGlhdGVseSBhZnRlciBgamAgaXMgaW5jcmVtZW50ZWQgaW4gdGhpcyBsb29wLCB0aGUgZm9sbG93aW5nIGhvbGRcbiAgICAvLyB0cnVlOlxuICAgIC8vXG4gICAgLy8gICAqIEV2ZXJ5IGVsZW1lbnQgaW4gYGFyeVtwIC4uIGldYCBpcyBsZXNzIHRoYW4gb3IgZXF1YWwgdG8gdGhlIHBpdm90LlxuICAgIC8vXG4gICAgLy8gICAqIEV2ZXJ5IGVsZW1lbnQgaW4gYGFyeVtpKzEgLi4gai0xXWAgaXMgZ3JlYXRlciB0aGFuIHRoZSBwaXZvdC5cbiAgICBmb3IgKHZhciBqID0gcDsgaiA8IHI7IGorKykge1xuICAgICAgaWYgKGNvbXBhcmF0b3IoYXJ5W2pdLCBwaXZvdCkgPD0gMCkge1xuICAgICAgICBpICs9IDE7XG4gICAgICAgIHN3YXAoYXJ5LCBpLCBqKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBzd2FwKGFyeSwgaSArIDEsIGopO1xuICAgIHZhciBxID0gaSArIDE7XG5cbiAgICAvLyAoMikgUmVjdXJzZSBvbiBlYWNoIGhhbGYuXG5cbiAgICBkb1F1aWNrU29ydChhcnksIGNvbXBhcmF0b3IsIHAsIHEgLSAxKTtcbiAgICBkb1F1aWNrU29ydChhcnksIGNvbXBhcmF0b3IsIHEgKyAxLCByKTtcbiAgfVxufVxuXG4vKipcbiAqIFNvcnQgdGhlIGdpdmVuIGFycmF5IGluLXBsYWNlIHdpdGggdGhlIGdpdmVuIGNvbXBhcmF0b3IgZnVuY3Rpb24uXG4gKlxuICogQHBhcmFtIHtBcnJheX0gYXJ5XG4gKiAgICAgICAgQW4gYXJyYXkgdG8gc29ydC5cbiAqIEBwYXJhbSB7ZnVuY3Rpb259IGNvbXBhcmF0b3JcbiAqICAgICAgICBGdW5jdGlvbiB0byB1c2UgdG8gY29tcGFyZSB0d28gaXRlbXMuXG4gKi9cbmV4cG9ydHMucXVpY2tTb3J0ID0gZnVuY3Rpb24gKGFyeSwgY29tcGFyYXRvcikge1xuICBkb1F1aWNrU29ydChhcnksIGNvbXBhcmF0b3IsIDAsIGFyeS5sZW5ndGggLSAxKTtcbn07XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvZWxlY3Ryb24tdXBkYXRlci9ub2RlX21vZHVsZXMvc291cmNlLW1hcC9saWIvcXVpY2stc29ydC5qcyIsIi8qIC0qLSBNb2RlOiBqczsganMtaW5kZW50LWxldmVsOiAyOyAtKi0gKi9cbi8qXG4gKiBDb3B5cmlnaHQgMjAxMSBNb3ppbGxhIEZvdW5kYXRpb24gYW5kIGNvbnRyaWJ1dG9yc1xuICogTGljZW5zZWQgdW5kZXIgdGhlIE5ldyBCU0QgbGljZW5zZS4gU2VlIExJQ0VOU0Ugb3I6XG4gKiBodHRwOi8vb3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvQlNELTMtQ2xhdXNlXG4gKi9cblxudmFyIFNvdXJjZU1hcEdlbmVyYXRvciA9IHJlcXVpcmUoJy4vc291cmNlLW1hcC1nZW5lcmF0b3InKS5Tb3VyY2VNYXBHZW5lcmF0b3I7XG52YXIgdXRpbCA9IHJlcXVpcmUoJy4vdXRpbCcpO1xuXG4vLyBNYXRjaGVzIGEgV2luZG93cy1zdHlsZSBgXFxyXFxuYCBuZXdsaW5lIG9yIGEgYFxcbmAgbmV3bGluZSB1c2VkIGJ5IGFsbCBvdGhlclxuLy8gb3BlcmF0aW5nIHN5c3RlbXMgdGhlc2UgZGF5cyAoY2FwdHVyaW5nIHRoZSByZXN1bHQpLlxudmFyIFJFR0VYX05FV0xJTkUgPSAvKFxccj9cXG4pLztcblxuLy8gTmV3bGluZSBjaGFyYWN0ZXIgY29kZSBmb3IgY2hhckNvZGVBdCgpIGNvbXBhcmlzb25zXG52YXIgTkVXTElORV9DT0RFID0gMTA7XG5cbi8vIFByaXZhdGUgc3ltYm9sIGZvciBpZGVudGlmeWluZyBgU291cmNlTm9kZWBzIHdoZW4gbXVsdGlwbGUgdmVyc2lvbnMgb2Zcbi8vIHRoZSBzb3VyY2UtbWFwIGxpYnJhcnkgYXJlIGxvYWRlZC4gVGhpcyBNVVNUIE5PVCBDSEFOR0UgYWNyb3NzXG4vLyB2ZXJzaW9ucyFcbnZhciBpc1NvdXJjZU5vZGUgPSBcIiQkJGlzU291cmNlTm9kZSQkJFwiO1xuXG4vKipcbiAqIFNvdXJjZU5vZGVzIHByb3ZpZGUgYSB3YXkgdG8gYWJzdHJhY3Qgb3ZlciBpbnRlcnBvbGF0aW5nL2NvbmNhdGVuYXRpbmdcbiAqIHNuaXBwZXRzIG9mIGdlbmVyYXRlZCBKYXZhU2NyaXB0IHNvdXJjZSBjb2RlIHdoaWxlIG1haW50YWluaW5nIHRoZSBsaW5lIGFuZFxuICogY29sdW1uIGluZm9ybWF0aW9uIGFzc29jaWF0ZWQgd2l0aCB0aGUgb3JpZ2luYWwgc291cmNlIGNvZGUuXG4gKlxuICogQHBhcmFtIGFMaW5lIFRoZSBvcmlnaW5hbCBsaW5lIG51bWJlci5cbiAqIEBwYXJhbSBhQ29sdW1uIFRoZSBvcmlnaW5hbCBjb2x1bW4gbnVtYmVyLlxuICogQHBhcmFtIGFTb3VyY2UgVGhlIG9yaWdpbmFsIHNvdXJjZSdzIGZpbGVuYW1lLlxuICogQHBhcmFtIGFDaHVua3MgT3B0aW9uYWwuIEFuIGFycmF5IG9mIHN0cmluZ3Mgd2hpY2ggYXJlIHNuaXBwZXRzIG9mXG4gKiAgICAgICAgZ2VuZXJhdGVkIEpTLCBvciBvdGhlciBTb3VyY2VOb2Rlcy5cbiAqIEBwYXJhbSBhTmFtZSBUaGUgb3JpZ2luYWwgaWRlbnRpZmllci5cbiAqL1xuZnVuY3Rpb24gU291cmNlTm9kZShhTGluZSwgYUNvbHVtbiwgYVNvdXJjZSwgYUNodW5rcywgYU5hbWUpIHtcbiAgdGhpcy5jaGlsZHJlbiA9IFtdO1xuICB0aGlzLnNvdXJjZUNvbnRlbnRzID0ge307XG4gIHRoaXMubGluZSA9IGFMaW5lID09IG51bGwgPyBudWxsIDogYUxpbmU7XG4gIHRoaXMuY29sdW1uID0gYUNvbHVtbiA9PSBudWxsID8gbnVsbCA6IGFDb2x1bW47XG4gIHRoaXMuc291cmNlID0gYVNvdXJjZSA9PSBudWxsID8gbnVsbCA6IGFTb3VyY2U7XG4gIHRoaXMubmFtZSA9IGFOYW1lID09IG51bGwgPyBudWxsIDogYU5hbWU7XG4gIHRoaXNbaXNTb3VyY2VOb2RlXSA9IHRydWU7XG4gIGlmIChhQ2h1bmtzICE9IG51bGwpIHRoaXMuYWRkKGFDaHVua3MpO1xufVxuXG4vKipcbiAqIENyZWF0ZXMgYSBTb3VyY2VOb2RlIGZyb20gZ2VuZXJhdGVkIGNvZGUgYW5kIGEgU291cmNlTWFwQ29uc3VtZXIuXG4gKlxuICogQHBhcmFtIGFHZW5lcmF0ZWRDb2RlIFRoZSBnZW5lcmF0ZWQgY29kZVxuICogQHBhcmFtIGFTb3VyY2VNYXBDb25zdW1lciBUaGUgU291cmNlTWFwIGZvciB0aGUgZ2VuZXJhdGVkIGNvZGVcbiAqIEBwYXJhbSBhUmVsYXRpdmVQYXRoIE9wdGlvbmFsLiBUaGUgcGF0aCB0aGF0IHJlbGF0aXZlIHNvdXJjZXMgaW4gdGhlXG4gKiAgICAgICAgU291cmNlTWFwQ29uc3VtZXIgc2hvdWxkIGJlIHJlbGF0aXZlIHRvLlxuICovXG5Tb3VyY2VOb2RlLmZyb21TdHJpbmdXaXRoU291cmNlTWFwID1cbiAgZnVuY3Rpb24gU291cmNlTm9kZV9mcm9tU3RyaW5nV2l0aFNvdXJjZU1hcChhR2VuZXJhdGVkQ29kZSwgYVNvdXJjZU1hcENvbnN1bWVyLCBhUmVsYXRpdmVQYXRoKSB7XG4gICAgLy8gVGhlIFNvdXJjZU5vZGUgd2Ugd2FudCB0byBmaWxsIHdpdGggdGhlIGdlbmVyYXRlZCBjb2RlXG4gICAgLy8gYW5kIHRoZSBTb3VyY2VNYXBcbiAgICB2YXIgbm9kZSA9IG5ldyBTb3VyY2VOb2RlKCk7XG5cbiAgICAvLyBBbGwgZXZlbiBpbmRpY2VzIG9mIHRoaXMgYXJyYXkgYXJlIG9uZSBsaW5lIG9mIHRoZSBnZW5lcmF0ZWQgY29kZSxcbiAgICAvLyB3aGlsZSBhbGwgb2RkIGluZGljZXMgYXJlIHRoZSBuZXdsaW5lcyBiZXR3ZWVuIHR3byBhZGphY2VudCBsaW5lc1xuICAgIC8vIChzaW5jZSBgUkVHRVhfTkVXTElORWAgY2FwdHVyZXMgaXRzIG1hdGNoKS5cbiAgICAvLyBQcm9jZXNzZWQgZnJhZ21lbnRzIGFyZSBhY2Nlc3NlZCBieSBjYWxsaW5nIGBzaGlmdE5leHRMaW5lYC5cbiAgICB2YXIgcmVtYWluaW5nTGluZXMgPSBhR2VuZXJhdGVkQ29kZS5zcGxpdChSRUdFWF9ORVdMSU5FKTtcbiAgICB2YXIgcmVtYWluaW5nTGluZXNJbmRleCA9IDA7XG4gICAgdmFyIHNoaWZ0TmV4dExpbmUgPSBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBsaW5lQ29udGVudHMgPSBnZXROZXh0TGluZSgpO1xuICAgICAgLy8gVGhlIGxhc3QgbGluZSBvZiBhIGZpbGUgbWlnaHQgbm90IGhhdmUgYSBuZXdsaW5lLlxuICAgICAgdmFyIG5ld0xpbmUgPSBnZXROZXh0TGluZSgpIHx8IFwiXCI7XG4gICAgICByZXR1cm4gbGluZUNvbnRlbnRzICsgbmV3TGluZTtcblxuICAgICAgZnVuY3Rpb24gZ2V0TmV4dExpbmUoKSB7XG4gICAgICAgIHJldHVybiByZW1haW5pbmdMaW5lc0luZGV4IDwgcmVtYWluaW5nTGluZXMubGVuZ3RoID9cbiAgICAgICAgICAgIHJlbWFpbmluZ0xpbmVzW3JlbWFpbmluZ0xpbmVzSW5kZXgrK10gOiB1bmRlZmluZWQ7XG4gICAgICB9XG4gICAgfTtcblxuICAgIC8vIFdlIG5lZWQgdG8gcmVtZW1iZXIgdGhlIHBvc2l0aW9uIG9mIFwicmVtYWluaW5nTGluZXNcIlxuICAgIHZhciBsYXN0R2VuZXJhdGVkTGluZSA9IDEsIGxhc3RHZW5lcmF0ZWRDb2x1bW4gPSAwO1xuXG4gICAgLy8gVGhlIGdlbmVyYXRlIFNvdXJjZU5vZGVzIHdlIG5lZWQgYSBjb2RlIHJhbmdlLlxuICAgIC8vIFRvIGV4dHJhY3QgaXQgY3VycmVudCBhbmQgbGFzdCBtYXBwaW5nIGlzIHVzZWQuXG4gICAgLy8gSGVyZSB3ZSBzdG9yZSB0aGUgbGFzdCBtYXBwaW5nLlxuICAgIHZhciBsYXN0TWFwcGluZyA9IG51bGw7XG5cbiAgICBhU291cmNlTWFwQ29uc3VtZXIuZWFjaE1hcHBpbmcoZnVuY3Rpb24gKG1hcHBpbmcpIHtcbiAgICAgIGlmIChsYXN0TWFwcGluZyAhPT0gbnVsbCkge1xuICAgICAgICAvLyBXZSBhZGQgdGhlIGNvZGUgZnJvbSBcImxhc3RNYXBwaW5nXCIgdG8gXCJtYXBwaW5nXCI6XG4gICAgICAgIC8vIEZpcnN0IGNoZWNrIGlmIHRoZXJlIGlzIGEgbmV3IGxpbmUgaW4gYmV0d2Vlbi5cbiAgICAgICAgaWYgKGxhc3RHZW5lcmF0ZWRMaW5lIDwgbWFwcGluZy5nZW5lcmF0ZWRMaW5lKSB7XG4gICAgICAgICAgLy8gQXNzb2NpYXRlIGZpcnN0IGxpbmUgd2l0aCBcImxhc3RNYXBwaW5nXCJcbiAgICAgICAgICBhZGRNYXBwaW5nV2l0aENvZGUobGFzdE1hcHBpbmcsIHNoaWZ0TmV4dExpbmUoKSk7XG4gICAgICAgICAgbGFzdEdlbmVyYXRlZExpbmUrKztcbiAgICAgICAgICBsYXN0R2VuZXJhdGVkQ29sdW1uID0gMDtcbiAgICAgICAgICAvLyBUaGUgcmVtYWluaW5nIGNvZGUgaXMgYWRkZWQgd2l0aG91dCBtYXBwaW5nXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gVGhlcmUgaXMgbm8gbmV3IGxpbmUgaW4gYmV0d2Vlbi5cbiAgICAgICAgICAvLyBBc3NvY2lhdGUgdGhlIGNvZGUgYmV0d2VlbiBcImxhc3RHZW5lcmF0ZWRDb2x1bW5cIiBhbmRcbiAgICAgICAgICAvLyBcIm1hcHBpbmcuZ2VuZXJhdGVkQ29sdW1uXCIgd2l0aCBcImxhc3RNYXBwaW5nXCJcbiAgICAgICAgICB2YXIgbmV4dExpbmUgPSByZW1haW5pbmdMaW5lc1tyZW1haW5pbmdMaW5lc0luZGV4XSB8fCAnJztcbiAgICAgICAgICB2YXIgY29kZSA9IG5leHRMaW5lLnN1YnN0cigwLCBtYXBwaW5nLmdlbmVyYXRlZENvbHVtbiAtXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGFzdEdlbmVyYXRlZENvbHVtbik7XG4gICAgICAgICAgcmVtYWluaW5nTGluZXNbcmVtYWluaW5nTGluZXNJbmRleF0gPSBuZXh0TGluZS5zdWJzdHIobWFwcGluZy5nZW5lcmF0ZWRDb2x1bW4gLVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxhc3RHZW5lcmF0ZWRDb2x1bW4pO1xuICAgICAgICAgIGxhc3RHZW5lcmF0ZWRDb2x1bW4gPSBtYXBwaW5nLmdlbmVyYXRlZENvbHVtbjtcbiAgICAgICAgICBhZGRNYXBwaW5nV2l0aENvZGUobGFzdE1hcHBpbmcsIGNvZGUpO1xuICAgICAgICAgIC8vIE5vIG1vcmUgcmVtYWluaW5nIGNvZGUsIGNvbnRpbnVlXG4gICAgICAgICAgbGFzdE1hcHBpbmcgPSBtYXBwaW5nO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgLy8gV2UgYWRkIHRoZSBnZW5lcmF0ZWQgY29kZSB1bnRpbCB0aGUgZmlyc3QgbWFwcGluZ1xuICAgICAgLy8gdG8gdGhlIFNvdXJjZU5vZGUgd2l0aG91dCBhbnkgbWFwcGluZy5cbiAgICAgIC8vIEVhY2ggbGluZSBpcyBhZGRlZCBhcyBzZXBhcmF0ZSBzdHJpbmcuXG4gICAgICB3aGlsZSAobGFzdEdlbmVyYXRlZExpbmUgPCBtYXBwaW5nLmdlbmVyYXRlZExpbmUpIHtcbiAgICAgICAgbm9kZS5hZGQoc2hpZnROZXh0TGluZSgpKTtcbiAgICAgICAgbGFzdEdlbmVyYXRlZExpbmUrKztcbiAgICAgIH1cbiAgICAgIGlmIChsYXN0R2VuZXJhdGVkQ29sdW1uIDwgbWFwcGluZy5nZW5lcmF0ZWRDb2x1bW4pIHtcbiAgICAgICAgdmFyIG5leHRMaW5lID0gcmVtYWluaW5nTGluZXNbcmVtYWluaW5nTGluZXNJbmRleF0gfHwgJyc7XG4gICAgICAgIG5vZGUuYWRkKG5leHRMaW5lLnN1YnN0cigwLCBtYXBwaW5nLmdlbmVyYXRlZENvbHVtbikpO1xuICAgICAgICByZW1haW5pbmdMaW5lc1tyZW1haW5pbmdMaW5lc0luZGV4XSA9IG5leHRMaW5lLnN1YnN0cihtYXBwaW5nLmdlbmVyYXRlZENvbHVtbik7XG4gICAgICAgIGxhc3RHZW5lcmF0ZWRDb2x1bW4gPSBtYXBwaW5nLmdlbmVyYXRlZENvbHVtbjtcbiAgICAgIH1cbiAgICAgIGxhc3RNYXBwaW5nID0gbWFwcGluZztcbiAgICB9LCB0aGlzKTtcbiAgICAvLyBXZSBoYXZlIHByb2Nlc3NlZCBhbGwgbWFwcGluZ3MuXG4gICAgaWYgKHJlbWFpbmluZ0xpbmVzSW5kZXggPCByZW1haW5pbmdMaW5lcy5sZW5ndGgpIHtcbiAgICAgIGlmIChsYXN0TWFwcGluZykge1xuICAgICAgICAvLyBBc3NvY2lhdGUgdGhlIHJlbWFpbmluZyBjb2RlIGluIHRoZSBjdXJyZW50IGxpbmUgd2l0aCBcImxhc3RNYXBwaW5nXCJcbiAgICAgICAgYWRkTWFwcGluZ1dpdGhDb2RlKGxhc3RNYXBwaW5nLCBzaGlmdE5leHRMaW5lKCkpO1xuICAgICAgfVxuICAgICAgLy8gYW5kIGFkZCB0aGUgcmVtYWluaW5nIGxpbmVzIHdpdGhvdXQgYW55IG1hcHBpbmdcbiAgICAgIG5vZGUuYWRkKHJlbWFpbmluZ0xpbmVzLnNwbGljZShyZW1haW5pbmdMaW5lc0luZGV4KS5qb2luKFwiXCIpKTtcbiAgICB9XG5cbiAgICAvLyBDb3B5IHNvdXJjZXNDb250ZW50IGludG8gU291cmNlTm9kZVxuICAgIGFTb3VyY2VNYXBDb25zdW1lci5zb3VyY2VzLmZvckVhY2goZnVuY3Rpb24gKHNvdXJjZUZpbGUpIHtcbiAgICAgIHZhciBjb250ZW50ID0gYVNvdXJjZU1hcENvbnN1bWVyLnNvdXJjZUNvbnRlbnRGb3Ioc291cmNlRmlsZSk7XG4gICAgICBpZiAoY29udGVudCAhPSBudWxsKSB7XG4gICAgICAgIGlmIChhUmVsYXRpdmVQYXRoICE9IG51bGwpIHtcbiAgICAgICAgICBzb3VyY2VGaWxlID0gdXRpbC5qb2luKGFSZWxhdGl2ZVBhdGgsIHNvdXJjZUZpbGUpO1xuICAgICAgICB9XG4gICAgICAgIG5vZGUuc2V0U291cmNlQ29udGVudChzb3VyY2VGaWxlLCBjb250ZW50KTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIHJldHVybiBub2RlO1xuXG4gICAgZnVuY3Rpb24gYWRkTWFwcGluZ1dpdGhDb2RlKG1hcHBpbmcsIGNvZGUpIHtcbiAgICAgIGlmIChtYXBwaW5nID09PSBudWxsIHx8IG1hcHBpbmcuc291cmNlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgbm9kZS5hZGQoY29kZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgc291cmNlID0gYVJlbGF0aXZlUGF0aFxuICAgICAgICAgID8gdXRpbC5qb2luKGFSZWxhdGl2ZVBhdGgsIG1hcHBpbmcuc291cmNlKVxuICAgICAgICAgIDogbWFwcGluZy5zb3VyY2U7XG4gICAgICAgIG5vZGUuYWRkKG5ldyBTb3VyY2VOb2RlKG1hcHBpbmcub3JpZ2luYWxMaW5lLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXBwaW5nLm9yaWdpbmFsQ29sdW1uLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzb3VyY2UsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvZGUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1hcHBpbmcubmFtZSkpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuLyoqXG4gKiBBZGQgYSBjaHVuayBvZiBnZW5lcmF0ZWQgSlMgdG8gdGhpcyBzb3VyY2Ugbm9kZS5cbiAqXG4gKiBAcGFyYW0gYUNodW5rIEEgc3RyaW5nIHNuaXBwZXQgb2YgZ2VuZXJhdGVkIEpTIGNvZGUsIGFub3RoZXIgaW5zdGFuY2Ugb2ZcbiAqICAgICAgICBTb3VyY2VOb2RlLCBvciBhbiBhcnJheSB3aGVyZSBlYWNoIG1lbWJlciBpcyBvbmUgb2YgdGhvc2UgdGhpbmdzLlxuICovXG5Tb3VyY2VOb2RlLnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbiBTb3VyY2VOb2RlX2FkZChhQ2h1bmspIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkoYUNodW5rKSkge1xuICAgIGFDaHVuay5mb3JFYWNoKGZ1bmN0aW9uIChjaHVuaykge1xuICAgICAgdGhpcy5hZGQoY2h1bmspO1xuICAgIH0sIHRoaXMpO1xuICB9XG4gIGVsc2UgaWYgKGFDaHVua1tpc1NvdXJjZU5vZGVdIHx8IHR5cGVvZiBhQ2h1bmsgPT09IFwic3RyaW5nXCIpIHtcbiAgICBpZiAoYUNodW5rKSB7XG4gICAgICB0aGlzLmNoaWxkcmVuLnB1c2goYUNodW5rKTtcbiAgICB9XG4gIH1cbiAgZWxzZSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgIFwiRXhwZWN0ZWQgYSBTb3VyY2VOb2RlLCBzdHJpbmcsIG9yIGFuIGFycmF5IG9mIFNvdXJjZU5vZGVzIGFuZCBzdHJpbmdzLiBHb3QgXCIgKyBhQ2h1bmtcbiAgICApO1xuICB9XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBBZGQgYSBjaHVuayBvZiBnZW5lcmF0ZWQgSlMgdG8gdGhlIGJlZ2lubmluZyBvZiB0aGlzIHNvdXJjZSBub2RlLlxuICpcbiAqIEBwYXJhbSBhQ2h1bmsgQSBzdHJpbmcgc25pcHBldCBvZiBnZW5lcmF0ZWQgSlMgY29kZSwgYW5vdGhlciBpbnN0YW5jZSBvZlxuICogICAgICAgIFNvdXJjZU5vZGUsIG9yIGFuIGFycmF5IHdoZXJlIGVhY2ggbWVtYmVyIGlzIG9uZSBvZiB0aG9zZSB0aGluZ3MuXG4gKi9cblNvdXJjZU5vZGUucHJvdG90eXBlLnByZXBlbmQgPSBmdW5jdGlvbiBTb3VyY2VOb2RlX3ByZXBlbmQoYUNodW5rKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KGFDaHVuaykpIHtcbiAgICBmb3IgKHZhciBpID0gYUNodW5rLmxlbmd0aC0xOyBpID49IDA7IGktLSkge1xuICAgICAgdGhpcy5wcmVwZW5kKGFDaHVua1tpXSk7XG4gICAgfVxuICB9XG4gIGVsc2UgaWYgKGFDaHVua1tpc1NvdXJjZU5vZGVdIHx8IHR5cGVvZiBhQ2h1bmsgPT09IFwic3RyaW5nXCIpIHtcbiAgICB0aGlzLmNoaWxkcmVuLnVuc2hpZnQoYUNodW5rKTtcbiAgfVxuICBlbHNlIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgXCJFeHBlY3RlZCBhIFNvdXJjZU5vZGUsIHN0cmluZywgb3IgYW4gYXJyYXkgb2YgU291cmNlTm9kZXMgYW5kIHN0cmluZ3MuIEdvdCBcIiArIGFDaHVua1xuICAgICk7XG4gIH1cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFdhbGsgb3ZlciB0aGUgdHJlZSBvZiBKUyBzbmlwcGV0cyBpbiB0aGlzIG5vZGUgYW5kIGl0cyBjaGlsZHJlbi4gVGhlXG4gKiB3YWxraW5nIGZ1bmN0aW9uIGlzIGNhbGxlZCBvbmNlIGZvciBlYWNoIHNuaXBwZXQgb2YgSlMgYW5kIGlzIHBhc3NlZCB0aGF0XG4gKiBzbmlwcGV0IGFuZCB0aGUgaXRzIG9yaWdpbmFsIGFzc29jaWF0ZWQgc291cmNlJ3MgbGluZS9jb2x1bW4gbG9jYXRpb24uXG4gKlxuICogQHBhcmFtIGFGbiBUaGUgdHJhdmVyc2FsIGZ1bmN0aW9uLlxuICovXG5Tb3VyY2VOb2RlLnByb3RvdHlwZS53YWxrID0gZnVuY3Rpb24gU291cmNlTm9kZV93YWxrKGFGbikge1xuICB2YXIgY2h1bms7XG4gIGZvciAodmFyIGkgPSAwLCBsZW4gPSB0aGlzLmNoaWxkcmVuLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgY2h1bmsgPSB0aGlzLmNoaWxkcmVuW2ldO1xuICAgIGlmIChjaHVua1tpc1NvdXJjZU5vZGVdKSB7XG4gICAgICBjaHVuay53YWxrKGFGbik7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgaWYgKGNodW5rICE9PSAnJykge1xuICAgICAgICBhRm4oY2h1bmssIHsgc291cmNlOiB0aGlzLnNvdXJjZSxcbiAgICAgICAgICAgICAgICAgICAgIGxpbmU6IHRoaXMubGluZSxcbiAgICAgICAgICAgICAgICAgICAgIGNvbHVtbjogdGhpcy5jb2x1bW4sXG4gICAgICAgICAgICAgICAgICAgICBuYW1lOiB0aGlzLm5hbWUgfSk7XG4gICAgICB9XG4gICAgfVxuICB9XG59O1xuXG4vKipcbiAqIExpa2UgYFN0cmluZy5wcm90b3R5cGUuam9pbmAgZXhjZXB0IGZvciBTb3VyY2VOb2Rlcy4gSW5zZXJ0cyBgYVN0cmAgYmV0d2VlblxuICogZWFjaCBvZiBgdGhpcy5jaGlsZHJlbmAuXG4gKlxuICogQHBhcmFtIGFTZXAgVGhlIHNlcGFyYXRvci5cbiAqL1xuU291cmNlTm9kZS5wcm90b3R5cGUuam9pbiA9IGZ1bmN0aW9uIFNvdXJjZU5vZGVfam9pbihhU2VwKSB7XG4gIHZhciBuZXdDaGlsZHJlbjtcbiAgdmFyIGk7XG4gIHZhciBsZW4gPSB0aGlzLmNoaWxkcmVuLmxlbmd0aDtcbiAgaWYgKGxlbiA+IDApIHtcbiAgICBuZXdDaGlsZHJlbiA9IFtdO1xuICAgIGZvciAoaSA9IDA7IGkgPCBsZW4tMTsgaSsrKSB7XG4gICAgICBuZXdDaGlsZHJlbi5wdXNoKHRoaXMuY2hpbGRyZW5baV0pO1xuICAgICAgbmV3Q2hpbGRyZW4ucHVzaChhU2VwKTtcbiAgICB9XG4gICAgbmV3Q2hpbGRyZW4ucHVzaCh0aGlzLmNoaWxkcmVuW2ldKTtcbiAgICB0aGlzLmNoaWxkcmVuID0gbmV3Q2hpbGRyZW47XG4gIH1cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIENhbGwgU3RyaW5nLnByb3RvdHlwZS5yZXBsYWNlIG9uIHRoZSB2ZXJ5IHJpZ2h0LW1vc3Qgc291cmNlIHNuaXBwZXQuIFVzZWZ1bFxuICogZm9yIHRyaW1taW5nIHdoaXRlc3BhY2UgZnJvbSB0aGUgZW5kIG9mIGEgc291cmNlIG5vZGUsIGV0Yy5cbiAqXG4gKiBAcGFyYW0gYVBhdHRlcm4gVGhlIHBhdHRlcm4gdG8gcmVwbGFjZS5cbiAqIEBwYXJhbSBhUmVwbGFjZW1lbnQgVGhlIHRoaW5nIHRvIHJlcGxhY2UgdGhlIHBhdHRlcm4gd2l0aC5cbiAqL1xuU291cmNlTm9kZS5wcm90b3R5cGUucmVwbGFjZVJpZ2h0ID0gZnVuY3Rpb24gU291cmNlTm9kZV9yZXBsYWNlUmlnaHQoYVBhdHRlcm4sIGFSZXBsYWNlbWVudCkge1xuICB2YXIgbGFzdENoaWxkID0gdGhpcy5jaGlsZHJlblt0aGlzLmNoaWxkcmVuLmxlbmd0aCAtIDFdO1xuICBpZiAobGFzdENoaWxkW2lzU291cmNlTm9kZV0pIHtcbiAgICBsYXN0Q2hpbGQucmVwbGFjZVJpZ2h0KGFQYXR0ZXJuLCBhUmVwbGFjZW1lbnQpO1xuICB9XG4gIGVsc2UgaWYgKHR5cGVvZiBsYXN0Q2hpbGQgPT09ICdzdHJpbmcnKSB7XG4gICAgdGhpcy5jaGlsZHJlblt0aGlzLmNoaWxkcmVuLmxlbmd0aCAtIDFdID0gbGFzdENoaWxkLnJlcGxhY2UoYVBhdHRlcm4sIGFSZXBsYWNlbWVudCk7XG4gIH1cbiAgZWxzZSB7XG4gICAgdGhpcy5jaGlsZHJlbi5wdXNoKCcnLnJlcGxhY2UoYVBhdHRlcm4sIGFSZXBsYWNlbWVudCkpO1xuICB9XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBTZXQgdGhlIHNvdXJjZSBjb250ZW50IGZvciBhIHNvdXJjZSBmaWxlLiBUaGlzIHdpbGwgYmUgYWRkZWQgdG8gdGhlIFNvdXJjZU1hcEdlbmVyYXRvclxuICogaW4gdGhlIHNvdXJjZXNDb250ZW50IGZpZWxkLlxuICpcbiAqIEBwYXJhbSBhU291cmNlRmlsZSBUaGUgZmlsZW5hbWUgb2YgdGhlIHNvdXJjZSBmaWxlXG4gKiBAcGFyYW0gYVNvdXJjZUNvbnRlbnQgVGhlIGNvbnRlbnQgb2YgdGhlIHNvdXJjZSBmaWxlXG4gKi9cblNvdXJjZU5vZGUucHJvdG90eXBlLnNldFNvdXJjZUNvbnRlbnQgPVxuICBmdW5jdGlvbiBTb3VyY2VOb2RlX3NldFNvdXJjZUNvbnRlbnQoYVNvdXJjZUZpbGUsIGFTb3VyY2VDb250ZW50KSB7XG4gICAgdGhpcy5zb3VyY2VDb250ZW50c1t1dGlsLnRvU2V0U3RyaW5nKGFTb3VyY2VGaWxlKV0gPSBhU291cmNlQ29udGVudDtcbiAgfTtcblxuLyoqXG4gKiBXYWxrIG92ZXIgdGhlIHRyZWUgb2YgU291cmNlTm9kZXMuIFRoZSB3YWxraW5nIGZ1bmN0aW9uIGlzIGNhbGxlZCBmb3IgZWFjaFxuICogc291cmNlIGZpbGUgY29udGVudCBhbmQgaXMgcGFzc2VkIHRoZSBmaWxlbmFtZSBhbmQgc291cmNlIGNvbnRlbnQuXG4gKlxuICogQHBhcmFtIGFGbiBUaGUgdHJhdmVyc2FsIGZ1bmN0aW9uLlxuICovXG5Tb3VyY2VOb2RlLnByb3RvdHlwZS53YWxrU291cmNlQ29udGVudHMgPVxuICBmdW5jdGlvbiBTb3VyY2VOb2RlX3dhbGtTb3VyY2VDb250ZW50cyhhRm4pIHtcbiAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gdGhpcy5jaGlsZHJlbi5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgaWYgKHRoaXMuY2hpbGRyZW5baV1baXNTb3VyY2VOb2RlXSkge1xuICAgICAgICB0aGlzLmNoaWxkcmVuW2ldLndhbGtTb3VyY2VDb250ZW50cyhhRm4pO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBzb3VyY2VzID0gT2JqZWN0LmtleXModGhpcy5zb3VyY2VDb250ZW50cyk7XG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHNvdXJjZXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIGFGbih1dGlsLmZyb21TZXRTdHJpbmcoc291cmNlc1tpXSksIHRoaXMuc291cmNlQ29udGVudHNbc291cmNlc1tpXV0pO1xuICAgIH1cbiAgfTtcblxuLyoqXG4gKiBSZXR1cm4gdGhlIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGlzIHNvdXJjZSBub2RlLiBXYWxrcyBvdmVyIHRoZSB0cmVlXG4gKiBhbmQgY29uY2F0ZW5hdGVzIGFsbCB0aGUgdmFyaW91cyBzbmlwcGV0cyB0b2dldGhlciB0byBvbmUgc3RyaW5nLlxuICovXG5Tb3VyY2VOb2RlLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uIFNvdXJjZU5vZGVfdG9TdHJpbmcoKSB7XG4gIHZhciBzdHIgPSBcIlwiO1xuICB0aGlzLndhbGsoZnVuY3Rpb24gKGNodW5rKSB7XG4gICAgc3RyICs9IGNodW5rO1xuICB9KTtcbiAgcmV0dXJuIHN0cjtcbn07XG5cbi8qKlxuICogUmV0dXJucyB0aGUgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoaXMgc291cmNlIG5vZGUgYWxvbmcgd2l0aCBhIHNvdXJjZVxuICogbWFwLlxuICovXG5Tb3VyY2VOb2RlLnByb3RvdHlwZS50b1N0cmluZ1dpdGhTb3VyY2VNYXAgPSBmdW5jdGlvbiBTb3VyY2VOb2RlX3RvU3RyaW5nV2l0aFNvdXJjZU1hcChhQXJncykge1xuICB2YXIgZ2VuZXJhdGVkID0ge1xuICAgIGNvZGU6IFwiXCIsXG4gICAgbGluZTogMSxcbiAgICBjb2x1bW46IDBcbiAgfTtcbiAgdmFyIG1hcCA9IG5ldyBTb3VyY2VNYXBHZW5lcmF0b3IoYUFyZ3MpO1xuICB2YXIgc291cmNlTWFwcGluZ0FjdGl2ZSA9IGZhbHNlO1xuICB2YXIgbGFzdE9yaWdpbmFsU291cmNlID0gbnVsbDtcbiAgdmFyIGxhc3RPcmlnaW5hbExpbmUgPSBudWxsO1xuICB2YXIgbGFzdE9yaWdpbmFsQ29sdW1uID0gbnVsbDtcbiAgdmFyIGxhc3RPcmlnaW5hbE5hbWUgPSBudWxsO1xuICB0aGlzLndhbGsoZnVuY3Rpb24gKGNodW5rLCBvcmlnaW5hbCkge1xuICAgIGdlbmVyYXRlZC5jb2RlICs9IGNodW5rO1xuICAgIGlmIChvcmlnaW5hbC5zb3VyY2UgIT09IG51bGxcbiAgICAgICAgJiYgb3JpZ2luYWwubGluZSAhPT0gbnVsbFxuICAgICAgICAmJiBvcmlnaW5hbC5jb2x1bW4gIT09IG51bGwpIHtcbiAgICAgIGlmKGxhc3RPcmlnaW5hbFNvdXJjZSAhPT0gb3JpZ2luYWwuc291cmNlXG4gICAgICAgICB8fCBsYXN0T3JpZ2luYWxMaW5lICE9PSBvcmlnaW5hbC5saW5lXG4gICAgICAgICB8fCBsYXN0T3JpZ2luYWxDb2x1bW4gIT09IG9yaWdpbmFsLmNvbHVtblxuICAgICAgICAgfHwgbGFzdE9yaWdpbmFsTmFtZSAhPT0gb3JpZ2luYWwubmFtZSkge1xuICAgICAgICBtYXAuYWRkTWFwcGluZyh7XG4gICAgICAgICAgc291cmNlOiBvcmlnaW5hbC5zb3VyY2UsXG4gICAgICAgICAgb3JpZ2luYWw6IHtcbiAgICAgICAgICAgIGxpbmU6IG9yaWdpbmFsLmxpbmUsXG4gICAgICAgICAgICBjb2x1bW46IG9yaWdpbmFsLmNvbHVtblxuICAgICAgICAgIH0sXG4gICAgICAgICAgZ2VuZXJhdGVkOiB7XG4gICAgICAgICAgICBsaW5lOiBnZW5lcmF0ZWQubGluZSxcbiAgICAgICAgICAgIGNvbHVtbjogZ2VuZXJhdGVkLmNvbHVtblxuICAgICAgICAgIH0sXG4gICAgICAgICAgbmFtZTogb3JpZ2luYWwubmFtZVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIGxhc3RPcmlnaW5hbFNvdXJjZSA9IG9yaWdpbmFsLnNvdXJjZTtcbiAgICAgIGxhc3RPcmlnaW5hbExpbmUgPSBvcmlnaW5hbC5saW5lO1xuICAgICAgbGFzdE9yaWdpbmFsQ29sdW1uID0gb3JpZ2luYWwuY29sdW1uO1xuICAgICAgbGFzdE9yaWdpbmFsTmFtZSA9IG9yaWdpbmFsLm5hbWU7XG4gICAgICBzb3VyY2VNYXBwaW5nQWN0aXZlID0gdHJ1ZTtcbiAgICB9IGVsc2UgaWYgKHNvdXJjZU1hcHBpbmdBY3RpdmUpIHtcbiAgICAgIG1hcC5hZGRNYXBwaW5nKHtcbiAgICAgICAgZ2VuZXJhdGVkOiB7XG4gICAgICAgICAgbGluZTogZ2VuZXJhdGVkLmxpbmUsXG4gICAgICAgICAgY29sdW1uOiBnZW5lcmF0ZWQuY29sdW1uXG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgbGFzdE9yaWdpbmFsU291cmNlID0gbnVsbDtcbiAgICAgIHNvdXJjZU1hcHBpbmdBY3RpdmUgPSBmYWxzZTtcbiAgICB9XG4gICAgZm9yICh2YXIgaWR4ID0gMCwgbGVuZ3RoID0gY2h1bmsubGVuZ3RoOyBpZHggPCBsZW5ndGg7IGlkeCsrKSB7XG4gICAgICBpZiAoY2h1bmsuY2hhckNvZGVBdChpZHgpID09PSBORVdMSU5FX0NPREUpIHtcbiAgICAgICAgZ2VuZXJhdGVkLmxpbmUrKztcbiAgICAgICAgZ2VuZXJhdGVkLmNvbHVtbiA9IDA7XG4gICAgICAgIC8vIE1hcHBpbmdzIGVuZCBhdCBlb2xcbiAgICAgICAgaWYgKGlkeCArIDEgPT09IGxlbmd0aCkge1xuICAgICAgICAgIGxhc3RPcmlnaW5hbFNvdXJjZSA9IG51bGw7XG4gICAgICAgICAgc291cmNlTWFwcGluZ0FjdGl2ZSA9IGZhbHNlO1xuICAgICAgICB9IGVsc2UgaWYgKHNvdXJjZU1hcHBpbmdBY3RpdmUpIHtcbiAgICAgICAgICBtYXAuYWRkTWFwcGluZyh7XG4gICAgICAgICAgICBzb3VyY2U6IG9yaWdpbmFsLnNvdXJjZSxcbiAgICAgICAgICAgIG9yaWdpbmFsOiB7XG4gICAgICAgICAgICAgIGxpbmU6IG9yaWdpbmFsLmxpbmUsXG4gICAgICAgICAgICAgIGNvbHVtbjogb3JpZ2luYWwuY29sdW1uXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZ2VuZXJhdGVkOiB7XG4gICAgICAgICAgICAgIGxpbmU6IGdlbmVyYXRlZC5saW5lLFxuICAgICAgICAgICAgICBjb2x1bW46IGdlbmVyYXRlZC5jb2x1bW5cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBuYW1lOiBvcmlnaW5hbC5uYW1lXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGdlbmVyYXRlZC5jb2x1bW4rKztcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xuICB0aGlzLndhbGtTb3VyY2VDb250ZW50cyhmdW5jdGlvbiAoc291cmNlRmlsZSwgc291cmNlQ29udGVudCkge1xuICAgIG1hcC5zZXRTb3VyY2VDb250ZW50KHNvdXJjZUZpbGUsIHNvdXJjZUNvbnRlbnQpO1xuICB9KTtcblxuICByZXR1cm4geyBjb2RlOiBnZW5lcmF0ZWQuY29kZSwgbWFwOiBtYXAgfTtcbn07XG5cbmV4cG9ydHMuU291cmNlTm9kZSA9IFNvdXJjZU5vZGU7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvZWxlY3Ryb24tdXBkYXRlci9ub2RlX21vZHVsZXMvc291cmNlLW1hcC9saWIvc291cmNlLW5vZGUuanMiLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCJtb2R1bGVcIik7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gZXh0ZXJuYWwgXCJtb2R1bGVcIlxuLy8gbW9kdWxlIGlkID0gMTY4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLkVsZWN0cm9uSHR0cEV4ZWN1dG9yID0gdW5kZWZpbmVkO1xuXG52YXIgX2JsdWViaXJkTHN0O1xuXG5mdW5jdGlvbiBfbG9hZF9ibHVlYmlyZExzdCgpIHtcbiAgICByZXR1cm4gX2JsdWViaXJkTHN0ID0gcmVxdWlyZShcImJsdWViaXJkLWxzdFwiKTtcbn1cblxudmFyIF9idWlsZGVyVXRpbFJ1bnRpbWU7XG5cbmZ1bmN0aW9uIF9sb2FkX2J1aWxkZXJVdGlsUnVudGltZSgpIHtcbiAgICByZXR1cm4gX2J1aWxkZXJVdGlsUnVudGltZSA9IHJlcXVpcmUoXCJidWlsZGVyLXV0aWwtcnVudGltZVwiKTtcbn1cblxudmFyIF9lbGVjdHJvbjtcblxuZnVuY3Rpb24gX2xvYWRfZWxlY3Ryb24oKSB7XG4gICAgcmV0dXJuIF9lbGVjdHJvbiA9IHJlcXVpcmUoXCJlbGVjdHJvblwiKTtcbn1cblxudmFyIF9mc0V4dHJhUDtcblxuZnVuY3Rpb24gX2xvYWRfZnNFeHRyYVAoKSB7XG4gICAgcmV0dXJuIF9mc0V4dHJhUCA9IHJlcXVpcmUoXCJmcy1leHRyYS1wXCIpO1xufVxuXG52YXIgX3BhdGggPSBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChyZXF1aXJlKFwicGF0aFwiKSk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKG9iaikgeyBpZiAob2JqICYmIG9iai5fX2VzTW9kdWxlKSB7IHJldHVybiBvYmo7IH0gZWxzZSB7IHZhciBuZXdPYmogPSB7fTsgaWYgKG9iaiAhPSBudWxsKSB7IGZvciAodmFyIGtleSBpbiBvYmopIHsgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGtleSkpIG5ld09ialtrZXldID0gb2JqW2tleV07IH0gfSBuZXdPYmouZGVmYXVsdCA9IG9iajsgcmV0dXJuIG5ld09iajsgfSB9XG5cbmNsYXNzIEVsZWN0cm9uSHR0cEV4ZWN1dG9yIGV4dGVuZHMgKF9idWlsZGVyVXRpbFJ1bnRpbWUgfHwgX2xvYWRfYnVpbGRlclV0aWxSdW50aW1lKCkpLkh0dHBFeGVjdXRvciB7XG4gICAgY29uc3RydWN0b3IocHJveHlMb2dpbkNhbGxiYWNrKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMucHJveHlMb2dpbkNhbGxiYWNrID0gcHJveHlMb2dpbkNhbGxiYWNrO1xuICAgIH1cbiAgICBkb3dubG9hZCh1cmwsIGRlc3RpbmF0aW9uLCBvcHRpb25zKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICAgICAgcmV0dXJuICgwLCAoX2JsdWViaXJkTHN0IHx8IF9sb2FkX2JsdWViaXJkTHN0KCkpLmNvcm91dGluZSkoZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGlmIChvcHRpb25zID09IG51bGwgfHwgIW9wdGlvbnMuc2tpcERpckNyZWF0aW9uKSB7XG4gICAgICAgICAgICAgICAgeWllbGQgKDAsIChfZnNFeHRyYVAgfHwgX2xvYWRfZnNFeHRyYVAoKSkuZW5zdXJlRGlyKShfcGF0aC5kaXJuYW1lKGRlc3RpbmF0aW9uKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4geWllbGQgb3B0aW9ucy5jYW5jZWxsYXRpb25Ub2tlbi5jcmVhdGVQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QsIG9uQ2FuY2VsKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMuZG9Eb3dubG9hZChPYmplY3QuYXNzaWduKHt9LCAoMCwgKF9idWlsZGVyVXRpbFJ1bnRpbWUgfHwgX2xvYWRfYnVpbGRlclV0aWxSdW50aW1lKCkpLmNvbmZpZ3VyZVJlcXVlc3RPcHRpb25zRnJvbVVybCkodXJsLCB7XG4gICAgICAgICAgICAgICAgICAgIGhlYWRlcnM6IG9wdGlvbnMuaGVhZGVycyB8fCB1bmRlZmluZWRcbiAgICAgICAgICAgICAgICB9KSwgeyByZWRpcmVjdDogXCJtYW51YWxcIiB9KSwgZGVzdGluYXRpb24sIDAsIG9wdGlvbnMsIGZ1bmN0aW9uIChlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZXJyb3IgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShkZXN0aW5hdGlvbik7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZWplY3QoZXJyb3IpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSwgb25DYW5jZWwpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pKCk7XG4gICAgfVxuICAgIGRvUmVxdWVzdChvcHRpb25zLCBjYWxsYmFjaykge1xuICAgICAgICBjb25zdCByZXF1ZXN0ID0gKF9lbGVjdHJvbiB8fCBfbG9hZF9lbGVjdHJvbigpKS5uZXQucmVxdWVzdChvcHRpb25zKTtcbiAgICAgICAgcmVxdWVzdC5vbihcInJlc3BvbnNlXCIsIGNhbGxiYWNrKTtcbiAgICAgICAgdGhpcy5hZGRQcm94eUxvZ2luSGFuZGxlcihyZXF1ZXN0KTtcbiAgICAgICAgcmV0dXJuIHJlcXVlc3Q7XG4gICAgfVxuICAgIGFkZFByb3h5TG9naW5IYW5kbGVyKHJlcXVlc3QpIHtcbiAgICAgICAgaWYgKHRoaXMucHJveHlMb2dpbkNhbGxiYWNrICE9IG51bGwpIHtcbiAgICAgICAgICAgIHJlcXVlc3Qub24oXCJsb2dpblwiLCB0aGlzLnByb3h5TG9naW5DYWxsYmFjayk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYWRkUmVkaXJlY3RIYW5kbGVycyhyZXF1ZXN0LCBvcHRpb25zLCByZWplY3QsIHJlZGlyZWN0Q291bnQsIGhhbmRsZXIpIHtcbiAgICAgICAgcmVxdWVzdC5vbihcInJlZGlyZWN0XCIsIChzdGF0dXNDb2RlLCBtZXRob2QsIHJlZGlyZWN0VXJsKSA9PiB7XG4gICAgICAgICAgICBpZiAocmVkaXJlY3RDb3VudCA+IDEwKSB7XG4gICAgICAgICAgICAgICAgcmVqZWN0KG5ldyBFcnJvcihcIlRvbyBtYW55IHJlZGlyZWN0cyAoPiAxMClcIikpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGhhbmRsZXIoKF9idWlsZGVyVXRpbFJ1bnRpbWUgfHwgX2xvYWRfYnVpbGRlclV0aWxSdW50aW1lKCkpLkh0dHBFeGVjdXRvci5wcmVwYXJlUmVkaXJlY3RVcmxPcHRpb25zKHJlZGlyZWN0VXJsLCBvcHRpb25zKSk7XG4gICAgICAgIH0pO1xuICAgIH1cbn1cbmV4cG9ydHMuRWxlY3Ryb25IdHRwRXhlY3V0b3IgPSBFbGVjdHJvbkh0dHBFeGVjdXRvcjsgLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZWxlY3Ryb25IdHRwRXhlY3V0b3IuanMubWFwXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2VsZWN0cm9uLXVwZGF0ZXIvb3V0L2VsZWN0cm9uSHR0cEV4ZWN1dG9yLmpzIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuY3JlYXRlQ2xpZW50ID0gY3JlYXRlQ2xpZW50O1xuXG52YXIgX2J1aWxkZXJVdGlsUnVudGltZTtcblxuZnVuY3Rpb24gX2xvYWRfYnVpbGRlclV0aWxSdW50aW1lKCkge1xuICAgIHJldHVybiBfYnVpbGRlclV0aWxSdW50aW1lID0gcmVxdWlyZShcImJ1aWxkZXItdXRpbC1ydW50aW1lXCIpO1xufVxuXG52YXIgX0JpbnRyYXlQcm92aWRlcjtcblxuZnVuY3Rpb24gX2xvYWRfQmludHJheVByb3ZpZGVyKCkge1xuICAgIHJldHVybiBfQmludHJheVByb3ZpZGVyID0gcmVxdWlyZShcIi4vQmludHJheVByb3ZpZGVyXCIpO1xufVxuXG52YXIgX0dlbmVyaWNQcm92aWRlcjtcblxuZnVuY3Rpb24gX2xvYWRfR2VuZXJpY1Byb3ZpZGVyKCkge1xuICAgIHJldHVybiBfR2VuZXJpY1Byb3ZpZGVyID0gcmVxdWlyZShcIi4vR2VuZXJpY1Byb3ZpZGVyXCIpO1xufVxuXG52YXIgX0dpdEh1YlByb3ZpZGVyO1xuXG5mdW5jdGlvbiBfbG9hZF9HaXRIdWJQcm92aWRlcigpIHtcbiAgICByZXR1cm4gX0dpdEh1YlByb3ZpZGVyID0gcmVxdWlyZShcIi4vR2l0SHViUHJvdmlkZXJcIik7XG59XG5cbnZhciBfUHJpdmF0ZUdpdEh1YlByb3ZpZGVyO1xuXG5mdW5jdGlvbiBfbG9hZF9Qcml2YXRlR2l0SHViUHJvdmlkZXIoKSB7XG4gICAgcmV0dXJuIF9Qcml2YXRlR2l0SHViUHJvdmlkZXIgPSByZXF1aXJlKFwiLi9Qcml2YXRlR2l0SHViUHJvdmlkZXJcIik7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUNsaWVudChkYXRhLCB1cGRhdGVyKSB7XG4gICAgaWYgKHR5cGVvZiBkYXRhID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIHRocm93ICgwLCAoX2J1aWxkZXJVdGlsUnVudGltZSB8fCBfbG9hZF9idWlsZGVyVXRpbFJ1bnRpbWUoKSkubmV3RXJyb3IpKFwiUGxlYXNlIHBhc3MgUHVibGlzaENvbmZpZ3VyYXRpb24gb2JqZWN0XCIsIFwiRVJSX1VQREFURVJfSU5WQUxJRF9QUk9WSURFUl9DT05GSUdVUkFUSU9OXCIpO1xuICAgIH1cbiAgICBjb25zdCBodHRwRXhlY3V0b3IgPSB1cGRhdGVyLmh0dHBFeGVjdXRvcjtcbiAgICBjb25zdCBwcm92aWRlciA9IGRhdGEucHJvdmlkZXI7XG4gICAgc3dpdGNoIChwcm92aWRlcikge1xuICAgICAgICBjYXNlIFwiZ2l0aHViXCI6XG4gICAgICAgICAgICBjb25zdCBnaXRodWJPcHRpb25zID0gZGF0YTtcbiAgICAgICAgICAgIGNvbnN0IHRva2VuID0gKGdpdGh1Yk9wdGlvbnMucHJpdmF0ZSA/IHByb2Nlc3MuZW52LkdIX1RPS0VOIDogbnVsbCkgfHwgZ2l0aHViT3B0aW9ucy50b2tlbjtcbiAgICAgICAgICAgIGlmICh0b2tlbiA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyAoX0dpdEh1YlByb3ZpZGVyIHx8IF9sb2FkX0dpdEh1YlByb3ZpZGVyKCkpLkdpdEh1YlByb3ZpZGVyKGdpdGh1Yk9wdGlvbnMsIHVwZGF0ZXIsIGh0dHBFeGVjdXRvcik7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgKF9Qcml2YXRlR2l0SHViUHJvdmlkZXIgfHwgX2xvYWRfUHJpdmF0ZUdpdEh1YlByb3ZpZGVyKCkpLlByaXZhdGVHaXRIdWJQcm92aWRlcihnaXRodWJPcHRpb25zLCB0b2tlbiwgaHR0cEV4ZWN1dG9yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgY2FzZSBcInMzXCI6XG4gICAgICAgIGNhc2UgXCJzcGFjZXNcIjpcbiAgICAgICAgICAgIHJldHVybiBuZXcgKF9HZW5lcmljUHJvdmlkZXIgfHwgX2xvYWRfR2VuZXJpY1Byb3ZpZGVyKCkpLkdlbmVyaWNQcm92aWRlcih7XG4gICAgICAgICAgICAgICAgcHJvdmlkZXI6IFwiZ2VuZXJpY1wiLFxuICAgICAgICAgICAgICAgIHVybDogKDAsIChfYnVpbGRlclV0aWxSdW50aW1lIHx8IF9sb2FkX2J1aWxkZXJVdGlsUnVudGltZSgpKS5nZXRTM0xpa2VQcm92aWRlckJhc2VVcmwpKGRhdGEpLFxuICAgICAgICAgICAgICAgIGNoYW5uZWw6IGRhdGEuY2hhbm5lbCB8fCBudWxsXG4gICAgICAgICAgICB9LCB1cGRhdGVyLCBwcm92aWRlciA9PT0gXCJzcGFjZXNcIiAvKiBodHRwczovL2dpdGh1Yi5jb20vbWluaW8vbWluaW8vaXNzdWVzLzUyODUjaXNzdWVjb21tZW50LTM1MDQyODk1NSAqLyk7XG4gICAgICAgIGNhc2UgXCJnZW5lcmljXCI6XG4gICAgICAgICAgICByZXR1cm4gbmV3IChfR2VuZXJpY1Byb3ZpZGVyIHx8IF9sb2FkX0dlbmVyaWNQcm92aWRlcigpKS5HZW5lcmljUHJvdmlkZXIoZGF0YSwgdXBkYXRlciwgdHJ1ZSk7XG4gICAgICAgIGNhc2UgXCJiaW50cmF5XCI6XG4gICAgICAgICAgICByZXR1cm4gbmV3IChfQmludHJheVByb3ZpZGVyIHx8IF9sb2FkX0JpbnRyYXlQcm92aWRlcigpKS5CaW50cmF5UHJvdmlkZXIoZGF0YSwgaHR0cEV4ZWN1dG9yKTtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHRocm93ICgwLCAoX2J1aWxkZXJVdGlsUnVudGltZSB8fCBfbG9hZF9idWlsZGVyVXRpbFJ1bnRpbWUoKSkubmV3RXJyb3IpKGBVbnN1cHBvcnRlZCBwcm92aWRlcjogJHtwcm92aWRlcn1gLCBcIkVSUl9VUERBVEVSX1VOU1VQUE9SVEVEX1BST1ZJREVSXCIpO1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXByb3ZpZGVyRmFjdG9yeS5qcy5tYXBcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvZWxlY3Ryb24tdXBkYXRlci9vdXQvcHJvdmlkZXJGYWN0b3J5LmpzIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuQmludHJheVByb3ZpZGVyID0gdW5kZWZpbmVkO1xuXG52YXIgX2JsdWViaXJkTHN0O1xuXG5mdW5jdGlvbiBfbG9hZF9ibHVlYmlyZExzdCgpIHtcbiAgICByZXR1cm4gX2JsdWViaXJkTHN0ID0gcmVxdWlyZShcImJsdWViaXJkLWxzdFwiKTtcbn1cblxudmFyIF9idWlsZGVyVXRpbFJ1bnRpbWU7XG5cbmZ1bmN0aW9uIF9sb2FkX2J1aWxkZXJVdGlsUnVudGltZSgpIHtcbiAgICByZXR1cm4gX2J1aWxkZXJVdGlsUnVudGltZSA9IHJlcXVpcmUoXCJidWlsZGVyLXV0aWwtcnVudGltZVwiKTtcbn1cblxudmFyIF9iaW50cmF5O1xuXG5mdW5jdGlvbiBfbG9hZF9iaW50cmF5KCkge1xuICAgIHJldHVybiBfYmludHJheSA9IHJlcXVpcmUoXCJidWlsZGVyLXV0aWwtcnVudGltZS9vdXQvYmludHJheVwiKTtcbn1cblxudmFyIF91cmw7XG5cbmZ1bmN0aW9uIF9sb2FkX3VybCgpIHtcbiAgICByZXR1cm4gX3VybCA9IHJlcXVpcmUoXCJ1cmxcIik7XG59XG5cbnZhciBfbWFpbjtcblxuZnVuY3Rpb24gX2xvYWRfbWFpbigpIHtcbiAgICByZXR1cm4gX21haW4gPSByZXF1aXJlKFwiLi9tYWluXCIpO1xufVxuXG52YXIgX1Byb3ZpZGVyO1xuXG5mdW5jdGlvbiBfbG9hZF9Qcm92aWRlcigpIHtcbiAgICByZXR1cm4gX1Byb3ZpZGVyID0gcmVxdWlyZShcIi4vUHJvdmlkZXJcIik7XG59XG5cbmNsYXNzIEJpbnRyYXlQcm92aWRlciBleHRlbmRzIChfbWFpbiB8fCBfbG9hZF9tYWluKCkpLlByb3ZpZGVyIHtcbiAgICBjb25zdHJ1Y3Rvcihjb25maWd1cmF0aW9uLCBodHRwRXhlY3V0b3IpIHtcbiAgICAgICAgc3VwZXIoaHR0cEV4ZWN1dG9yKTtcbiAgICAgICAgdGhpcy5jbGllbnQgPSBuZXcgKF9iaW50cmF5IHx8IF9sb2FkX2JpbnRyYXkoKSkuQmludHJheUNsaWVudChjb25maWd1cmF0aW9uLCBodHRwRXhlY3V0b3IsIG5ldyAoX2J1aWxkZXJVdGlsUnVudGltZSB8fCBfbG9hZF9idWlsZGVyVXRpbFJ1bnRpbWUoKSkuQ2FuY2VsbGF0aW9uVG9rZW4oKSk7XG4gICAgICAgIHRoaXMuYmFzZVVybCA9ICgwLCAoX21haW4gfHwgX2xvYWRfbWFpbigpKS5uZXdCYXNlVXJsKShgaHR0cHM6Ly9kbC5iaW50cmF5LmNvbS8ke3RoaXMuY2xpZW50Lm93bmVyfS8ke3RoaXMuY2xpZW50LnJlcG99YCk7XG4gICAgfVxuICAgIHNldFJlcXVlc3RIZWFkZXJzKHZhbHVlKSB7XG4gICAgICAgIHN1cGVyLnNldFJlcXVlc3RIZWFkZXJzKHZhbHVlKTtcbiAgICAgICAgdGhpcy5jbGllbnQuc2V0UmVxdWVzdEhlYWRlcnModmFsdWUpO1xuICAgIH1cbiAgICBnZXRMYXRlc3RWZXJzaW9uKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgICAgIHJldHVybiAoMCwgKF9ibHVlYmlyZExzdCB8fCBfbG9hZF9ibHVlYmlyZExzdCgpKS5jb3JvdXRpbmUpKGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGRhdGEgPSB5aWVsZCBfdGhpcy5jbGllbnQuZ2V0VmVyc2lvbihcIl9sYXRlc3RcIik7XG4gICAgICAgICAgICAgICAgY29uc3QgY2hhbm5lbEZpbGVuYW1lID0gKDAsIChfbWFpbiB8fCBfbG9hZF9tYWluKCkpLmdldENoYW5uZWxGaWxlbmFtZSkoKDAsIChfbWFpbiB8fCBfbG9hZF9tYWluKCkpLmdldERlZmF1bHRDaGFubmVsTmFtZSkoKSk7XG4gICAgICAgICAgICAgICAgY29uc3QgZmlsZXMgPSB5aWVsZCBfdGhpcy5jbGllbnQuZ2V0VmVyc2lvbkZpbGVzKGRhdGEubmFtZSk7XG4gICAgICAgICAgICAgICAgY29uc3QgY2hhbm5lbEZpbGUgPSBmaWxlcy5maW5kKGZ1bmN0aW9uIChpdCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaXQubmFtZS5lbmRzV2l0aChgXyR7Y2hhbm5lbEZpbGVuYW1lfWApIHx8IGl0Lm5hbWUuZW5kc1dpdGgoYC0ke2NoYW5uZWxGaWxlbmFtZX1gKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBpZiAoY2hhbm5lbEZpbGUgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBub2luc3BlY3Rpb24gRXhjZXB0aW9uQ2F1Z2h0TG9jYWxseUpTXG4gICAgICAgICAgICAgICAgICAgIHRocm93ICgwLCAoX2J1aWxkZXJVdGlsUnVudGltZSB8fCBfbG9hZF9idWlsZGVyVXRpbFJ1bnRpbWUoKSkubmV3RXJyb3IpKGBDYW5ub3QgZmluZCBjaGFubmVsIGZpbGUgXCIke2NoYW5uZWxGaWxlbmFtZX1cIiwgZXhpc3RpbmcgZmlsZXM6XFxuJHtmaWxlcy5tYXAoZnVuY3Rpb24gKGl0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkoaXQsIG51bGwsIDIpO1xuICAgICAgICAgICAgICAgICAgICB9KS5qb2luKFwiLFxcblwiKX1gLCBcIkVSUl9VUERBVEVSX0NIQU5ORUxfRklMRV9OT1RfRk9VTkRcIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IGNoYW5uZWxGaWxlVXJsID0gbmV3IChfdXJsIHx8IF9sb2FkX3VybCgpKS5VUkwoYGh0dHBzOi8vZGwuYmludHJheS5jb20vJHtfdGhpcy5jbGllbnQub3duZXJ9LyR7X3RoaXMuY2xpZW50LnJlcG99LyR7Y2hhbm5lbEZpbGUubmFtZX1gKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gKDAsIChfUHJvdmlkZXIgfHwgX2xvYWRfUHJvdmlkZXIoKSkucGFyc2VVcGRhdGVJbmZvKSgoeWllbGQgX3RoaXMuaHR0cFJlcXVlc3QoY2hhbm5lbEZpbGVVcmwpKSwgY2hhbm5lbEZpbGVuYW1lLCBjaGFubmVsRmlsZVVybCk7XG4gICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgaWYgKFwic3RhdHVzQ29kZVwiIGluIGUgJiYgZS5zdGF0dXNDb2RlID09PSA0MDQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgKDAsIChfYnVpbGRlclV0aWxSdW50aW1lIHx8IF9sb2FkX2J1aWxkZXJVdGlsUnVudGltZSgpKS5uZXdFcnJvcikoYE5vIGxhdGVzdCB2ZXJzaW9uLCBwbGVhc2UgZW5zdXJlIHRoYXQgdXNlciwgcGFja2FnZSBhbmQgcmVwb3NpdG9yeSBjb3JyZWN0bHkgY29uZmlndXJlZC4gT3IgYXQgbGVhc3Qgb25lIHZlcnNpb24gaXMgcHVibGlzaGVkLiAke2Uuc3RhY2sgfHwgZS5tZXNzYWdlfWAsIFwiRVJSX1VQREFURVJfTEFURVNUX1ZFUlNJT05fTk9UX0ZPVU5EXCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KSgpO1xuICAgIH1cbiAgICByZXNvbHZlRmlsZXModXBkYXRlSW5mbykge1xuICAgICAgICByZXR1cm4gKDAsIChfUHJvdmlkZXIgfHwgX2xvYWRfUHJvdmlkZXIoKSkucmVzb2x2ZUZpbGVzKSh1cGRhdGVJbmZvLCB0aGlzLmJhc2VVcmwpO1xuICAgIH1cbn1cbmV4cG9ydHMuQmludHJheVByb3ZpZGVyID0gQmludHJheVByb3ZpZGVyOyAvLyMgc291cmNlTWFwcGluZ1VSTD1CaW50cmF5UHJvdmlkZXIuanMubWFwXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2VsZWN0cm9uLXVwZGF0ZXIvb3V0L0JpbnRyYXlQcm92aWRlci5qcyIsIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLkJpbnRyYXlDbGllbnQgPSB1bmRlZmluZWQ7XG5cbnZhciBfaHR0cEV4ZWN1dG9yO1xuXG5mdW5jdGlvbiBfbG9hZF9odHRwRXhlY3V0b3IoKSB7XG4gICAgcmV0dXJuIF9odHRwRXhlY3V0b3IgPSByZXF1aXJlKFwiLi9odHRwRXhlY3V0b3JcIik7XG59XG5cbmNsYXNzIEJpbnRyYXlDbGllbnQge1xuICAgIGNvbnN0cnVjdG9yKG9wdGlvbnMsIGh0dHBFeGVjdXRvciwgY2FuY2VsbGF0aW9uVG9rZW4sIGFwaUtleSkge1xuICAgICAgICB0aGlzLmh0dHBFeGVjdXRvciA9IGh0dHBFeGVjdXRvcjtcbiAgICAgICAgdGhpcy5jYW5jZWxsYXRpb25Ub2tlbiA9IGNhbmNlbGxhdGlvblRva2VuO1xuICAgICAgICBpZiAob3B0aW9ucy5vd25lciA9PSBudWxsKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJvd25lciBpcyBub3Qgc3BlY2lmaWVkXCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvcHRpb25zLnBhY2thZ2UgPT0gbnVsbCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwicGFja2FnZSBpcyBub3Qgc3BlY2lmaWVkXCIpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucmVwbyA9IG9wdGlvbnMucmVwbyB8fCBcImdlbmVyaWNcIjtcbiAgICAgICAgdGhpcy5wYWNrYWdlTmFtZSA9IG9wdGlvbnMucGFja2FnZTtcbiAgICAgICAgdGhpcy5vd25lciA9IG9wdGlvbnMub3duZXI7XG4gICAgICAgIHRoaXMudXNlciA9IG9wdGlvbnMudXNlciB8fCBvcHRpb25zLm93bmVyO1xuICAgICAgICB0aGlzLmNvbXBvbmVudCA9IG9wdGlvbnMuY29tcG9uZW50IHx8IG51bGw7XG4gICAgICAgIHRoaXMuZGlzdHJpYnV0aW9uID0gb3B0aW9ucy5kaXN0cmlidXRpb24gfHwgXCJzdGFibGVcIjtcbiAgICAgICAgdGhpcy5hdXRoID0gYXBpS2V5ID09IG51bGwgPyBudWxsIDogYEJhc2ljICR7QnVmZmVyLmZyb20oYCR7dGhpcy51c2VyfToke2FwaUtleX1gKS50b1N0cmluZyhcImJhc2U2NFwiKX1gO1xuICAgICAgICB0aGlzLmJhc2VQYXRoID0gYC9wYWNrYWdlcy8ke3RoaXMub3duZXJ9LyR7dGhpcy5yZXBvfS8ke3RoaXMucGFja2FnZU5hbWV9YDtcbiAgICB9XG4gICAgc2V0UmVxdWVzdEhlYWRlcnModmFsdWUpIHtcbiAgICAgICAgdGhpcy5yZXF1ZXN0SGVhZGVycyA9IHZhbHVlO1xuICAgIH1cbiAgICBiaW50cmF5UmVxdWVzdChwYXRoLCBhdXRoLCBkYXRhID0gbnVsbCwgY2FuY2VsbGF0aW9uVG9rZW4sIG1ldGhvZCkge1xuICAgICAgICByZXR1cm4gKDAsIChfaHR0cEV4ZWN1dG9yIHx8IF9sb2FkX2h0dHBFeGVjdXRvcigpKS5wYXJzZUpzb24pKHRoaXMuaHR0cEV4ZWN1dG9yLnJlcXVlc3QoKDAsIChfaHR0cEV4ZWN1dG9yIHx8IF9sb2FkX2h0dHBFeGVjdXRvcigpKS5jb25maWd1cmVSZXF1ZXN0T3B0aW9ucykoeyBob3N0bmFtZTogXCJhcGkuYmludHJheS5jb21cIiwgcGF0aCwgaGVhZGVyczogdGhpcy5yZXF1ZXN0SGVhZGVycyB8fCB1bmRlZmluZWQgfSwgYXV0aCwgbWV0aG9kKSwgY2FuY2VsbGF0aW9uVG9rZW4sIGRhdGEpKTtcbiAgICB9XG4gICAgZ2V0VmVyc2lvbih2ZXJzaW9uKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmJpbnRyYXlSZXF1ZXN0KGAke3RoaXMuYmFzZVBhdGh9L3ZlcnNpb25zLyR7dmVyc2lvbn1gLCB0aGlzLmF1dGgsIG51bGwsIHRoaXMuY2FuY2VsbGF0aW9uVG9rZW4pO1xuICAgIH1cbiAgICBnZXRWZXJzaW9uRmlsZXModmVyc2lvbikge1xuICAgICAgICByZXR1cm4gdGhpcy5iaW50cmF5UmVxdWVzdChgJHt0aGlzLmJhc2VQYXRofS92ZXJzaW9ucy8ke3ZlcnNpb259L2ZpbGVzYCwgdGhpcy5hdXRoLCBudWxsLCB0aGlzLmNhbmNlbGxhdGlvblRva2VuKTtcbiAgICB9XG4gICAgY3JlYXRlVmVyc2lvbih2ZXJzaW9uKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmJpbnRyYXlSZXF1ZXN0KGAke3RoaXMuYmFzZVBhdGh9L3ZlcnNpb25zYCwgdGhpcy5hdXRoLCB7XG4gICAgICAgICAgICBuYW1lOiB2ZXJzaW9uXG4gICAgICAgIH0sIHRoaXMuY2FuY2VsbGF0aW9uVG9rZW4pO1xuICAgIH1cbiAgICBkZWxldGVWZXJzaW9uKHZlcnNpb24pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYmludHJheVJlcXVlc3QoYCR7dGhpcy5iYXNlUGF0aH0vdmVyc2lvbnMvJHt2ZXJzaW9ufWAsIHRoaXMuYXV0aCwgbnVsbCwgdGhpcy5jYW5jZWxsYXRpb25Ub2tlbiwgXCJERUxFVEVcIik7XG4gICAgfVxufVxuZXhwb3J0cy5CaW50cmF5Q2xpZW50ID0gQmludHJheUNsaWVudDsgLy8jIHNvdXJjZU1hcHBpbmdVUkw9YmludHJheS5qcy5tYXBcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvZWxlY3Ryb24tdXBkYXRlci9ub2RlX21vZHVsZXMvYnVpbGRlci11dGlsLXJ1bnRpbWUvb3V0L2JpbnRyYXkuanMiLCJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5Qcml2YXRlR2l0SHViUHJvdmlkZXIgPSB1bmRlZmluZWQ7XG5cbnZhciBfYmx1ZWJpcmRMc3Q7XG5cbmZ1bmN0aW9uIF9sb2FkX2JsdWViaXJkTHN0KCkge1xuICAgIHJldHVybiBfYmx1ZWJpcmRMc3QgPSByZXF1aXJlKFwiYmx1ZWJpcmQtbHN0XCIpO1xufVxuXG52YXIgX2J1aWxkZXJVdGlsUnVudGltZTtcblxuZnVuY3Rpb24gX2xvYWRfYnVpbGRlclV0aWxSdW50aW1lKCkge1xuICAgIHJldHVybiBfYnVpbGRlclV0aWxSdW50aW1lID0gcmVxdWlyZShcImJ1aWxkZXItdXRpbC1ydW50aW1lXCIpO1xufVxuXG52YXIgX2pzWWFtbDtcblxuZnVuY3Rpb24gX2xvYWRfanNZYW1sKCkge1xuICAgIHJldHVybiBfanNZYW1sID0gcmVxdWlyZShcImpzLXlhbWxcIik7XG59XG5cbnZhciBfcGF0aCA9IF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKHJlcXVpcmUoXCJwYXRoXCIpKTtcblxudmFyIF91cmw7XG5cbmZ1bmN0aW9uIF9sb2FkX3VybCgpIHtcbiAgICByZXR1cm4gX3VybCA9IHJlcXVpcmUoXCJ1cmxcIik7XG59XG5cbnZhciBfR2l0SHViUHJvdmlkZXI7XG5cbmZ1bmN0aW9uIF9sb2FkX0dpdEh1YlByb3ZpZGVyKCkge1xuICAgIHJldHVybiBfR2l0SHViUHJvdmlkZXIgPSByZXF1aXJlKFwiLi9HaXRIdWJQcm92aWRlclwiKTtcbn1cblxudmFyIF9tYWluO1xuXG5mdW5jdGlvbiBfbG9hZF9tYWluKCkge1xuICAgIHJldHVybiBfbWFpbiA9IHJlcXVpcmUoXCIuL21haW5cIik7XG59XG5cbnZhciBfUHJvdmlkZXI7XG5cbmZ1bmN0aW9uIF9sb2FkX1Byb3ZpZGVyKCkge1xuICAgIHJldHVybiBfUHJvdmlkZXIgPSByZXF1aXJlKFwiLi9Qcm92aWRlclwiKTtcbn1cblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQob2JqKSB7IGlmIChvYmogJiYgb2JqLl9fZXNNb2R1bGUpIHsgcmV0dXJuIG9iajsgfSBlbHNlIHsgdmFyIG5ld09iaiA9IHt9OyBpZiAob2JqICE9IG51bGwpIHsgZm9yICh2YXIga2V5IGluIG9iaikgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwga2V5KSkgbmV3T2JqW2tleV0gPSBvYmpba2V5XTsgfSB9IG5ld09iai5kZWZhdWx0ID0gb2JqOyByZXR1cm4gbmV3T2JqOyB9IH1cblxuY2xhc3MgUHJpdmF0ZUdpdEh1YlByb3ZpZGVyIGV4dGVuZHMgKF9HaXRIdWJQcm92aWRlciB8fCBfbG9hZF9HaXRIdWJQcm92aWRlcigpKS5CYXNlR2l0SHViUHJvdmlkZXIge1xuICAgIGNvbnN0cnVjdG9yKG9wdGlvbnMsIHRva2VuLCBleGVjdXRvcikge1xuICAgICAgICBzdXBlcihvcHRpb25zLCBcImFwaS5naXRodWIuY29tXCIsIGV4ZWN1dG9yKTtcbiAgICAgICAgdGhpcy50b2tlbiA9IHRva2VuO1xuICAgIH1cbiAgICBjcmVhdGVSZXF1ZXN0T3B0aW9ucyh1cmwsIGhlYWRlcnMpIHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gc3VwZXIuY3JlYXRlUmVxdWVzdE9wdGlvbnModXJsLCBoZWFkZXJzKTtcbiAgICAgICAgcmVzdWx0LnJlZGlyZWN0ID0gXCJtYW51YWxcIjtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgZ2V0TGF0ZXN0VmVyc2lvbigpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgICAgICByZXR1cm4gKDAsIChfYmx1ZWJpcmRMc3QgfHwgX2xvYWRfYmx1ZWJpcmRMc3QoKSkuY29yb3V0aW5lKShmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3QgYmFzZVBhdGggPSBfdGhpcy5iYXNlUGF0aDtcbiAgICAgICAgICAgIGNvbnN0IGNhbmNlbGxhdGlvblRva2VuID0gbmV3IChfYnVpbGRlclV0aWxSdW50aW1lIHx8IF9sb2FkX2J1aWxkZXJVdGlsUnVudGltZSgpKS5DYW5jZWxsYXRpb25Ub2tlbigpO1xuICAgICAgICAgICAgY29uc3QgY2hhbm5lbEZpbGUgPSAoMCwgKF9tYWluIHx8IF9sb2FkX21haW4oKSkuZ2V0Q2hhbm5lbEZpbGVuYW1lKSgoMCwgKF9tYWluIHx8IF9sb2FkX21haW4oKSkuZ2V0RGVmYXVsdENoYW5uZWxOYW1lKSgpKTtcbiAgICAgICAgICAgIGNvbnN0IHJlbGVhc2VJbmZvID0geWllbGQgX3RoaXMuZ2V0TGF0ZXN0VmVyc2lvbkluZm8oYmFzZVBhdGgsIGNhbmNlbGxhdGlvblRva2VuKTtcbiAgICAgICAgICAgIGNvbnN0IGFzc2V0ID0gcmVsZWFzZUluZm8uYXNzZXRzLmZpbmQoZnVuY3Rpb24gKGl0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGl0Lm5hbWUgPT09IGNoYW5uZWxGaWxlO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpZiAoYXNzZXQgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIC8vIGh0bWxfdXJsIG11c3QgYmUgYWx3YXlzLCBidXQganVzdCB0byBiZSBzdXJlXG4gICAgICAgICAgICAgICAgdGhyb3cgKDAsIChfYnVpbGRlclV0aWxSdW50aW1lIHx8IF9sb2FkX2J1aWxkZXJVdGlsUnVudGltZSgpKS5uZXdFcnJvcikoYENhbm5vdCBmaW5kICR7Y2hhbm5lbEZpbGV9IGluIHRoZSByZWxlYXNlICR7cmVsZWFzZUluZm8uaHRtbF91cmwgfHwgcmVsZWFzZUluZm8ubmFtZX1gLCBcIkVSUl9VUERBVEVSX0NIQU5ORUxfRklMRV9OT1RfRk9VTkRcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCB1cmwgPSBuZXcgKF91cmwgfHwgX2xvYWRfdXJsKCkpLlVSTChhc3NldC51cmwpO1xuICAgICAgICAgICAgbGV0IHJlc3VsdDtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gKDAsIChfanNZYW1sIHx8IF9sb2FkX2pzWWFtbCgpKS5zYWZlTG9hZCkoKHlpZWxkIF90aGlzLmh0dHBSZXF1ZXN0KHVybCwgX3RoaXMuY29uZmlndXJlSGVhZGVycyhcImFwcGxpY2F0aW9uL29jdGV0LXN0cmVhbVwiKSwgY2FuY2VsbGF0aW9uVG9rZW4pKSk7XG4gICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgaWYgKGUgaW5zdGFuY2VvZiAoX2J1aWxkZXJVdGlsUnVudGltZSB8fCBfbG9hZF9idWlsZGVyVXRpbFJ1bnRpbWUoKSkuSHR0cEVycm9yICYmIGUuc3RhdHVzQ29kZSA9PT0gNDA0KSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93ICgwLCAoX2J1aWxkZXJVdGlsUnVudGltZSB8fCBfbG9hZF9idWlsZGVyVXRpbFJ1bnRpbWUoKSkubmV3RXJyb3IpKGBDYW5ub3QgZmluZCAke2NoYW5uZWxGaWxlfSBpbiB0aGUgbGF0ZXN0IHJlbGVhc2UgYXJ0aWZhY3RzICgke3VybH0pOiAke2Uuc3RhY2sgfHwgZS5tZXNzYWdlfWAsIFwiRVJSX1VQREFURVJfQ0hBTk5FTF9GSUxFX05PVF9GT1VORFwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlc3VsdC5hc3NldHMgPSByZWxlYXNlSW5mby5hc3NldHM7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9KSgpO1xuICAgIH1cbiAgICBnZXQgZmlsZUV4dHJhRG93bmxvYWRIZWFkZXJzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jb25maWd1cmVIZWFkZXJzKFwiYXBwbGljYXRpb24vb2N0ZXQtc3RyZWFtXCIpO1xuICAgIH1cbiAgICBjb25maWd1cmVIZWFkZXJzKGFjY2VwdCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgQWNjZXB0OiBhY2NlcHQsXG4gICAgICAgICAgICBBdXRob3JpemF0aW9uOiBgdG9rZW4gJHt0aGlzLnRva2VufWBcbiAgICAgICAgfTtcbiAgICB9XG4gICAgZ2V0TGF0ZXN0VmVyc2lvbkluZm8oYmFzZVBhdGgsIGNhbmNlbGxhdGlvblRva2VuKSB7XG4gICAgICAgIHZhciBfdGhpczIgPSB0aGlzO1xuXG4gICAgICAgIHJldHVybiAoMCwgKF9ibHVlYmlyZExzdCB8fCBfbG9hZF9ibHVlYmlyZExzdCgpKS5jb3JvdXRpbmUpKGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCB1cmwgPSAoMCwgKF9tYWluIHx8IF9sb2FkX21haW4oKSkubmV3VXJsRnJvbUJhc2UpKGAke2Jhc2VQYXRofS9sYXRlc3RgLCBfdGhpczIuYmFzZVVybCk7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHJldHVybiBKU09OLnBhcnNlKCh5aWVsZCBfdGhpczIuaHR0cFJlcXVlc3QodXJsLCBfdGhpczIuY29uZmlndXJlSGVhZGVycyhcImFwcGxpY2F0aW9uL3ZuZC5naXRodWIudjMranNvblwiKSwgY2FuY2VsbGF0aW9uVG9rZW4pKSk7XG4gICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgKDAsIChfYnVpbGRlclV0aWxSdW50aW1lIHx8IF9sb2FkX2J1aWxkZXJVdGlsUnVudGltZSgpKS5uZXdFcnJvcikoYFVuYWJsZSB0byBmaW5kIGxhdGVzdCB2ZXJzaW9uIG9uIEdpdEh1YiAoJHt1cmx9KSwgcGxlYXNlIGVuc3VyZSBhIHByb2R1Y3Rpb24gcmVsZWFzZSBleGlzdHM6ICR7ZS5zdGFjayB8fCBlLm1lc3NhZ2V9YCwgXCJFUlJfVVBEQVRFUl9MQVRFU1RfVkVSU0lPTl9OT1RfRk9VTkRcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pKCk7XG4gICAgfVxuICAgIGdldCBiYXNlUGF0aCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29tcHV0ZUdpdGh1YkJhc2VQYXRoKGAvcmVwb3MvJHt0aGlzLm9wdGlvbnMub3duZXJ9LyR7dGhpcy5vcHRpb25zLnJlcG99L3JlbGVhc2VzYCk7XG4gICAgfVxuICAgIHJlc29sdmVGaWxlcyh1cGRhdGVJbmZvKSB7XG4gICAgICAgIHJldHVybiAoMCwgKF9Qcm92aWRlciB8fCBfbG9hZF9Qcm92aWRlcigpKS5nZXRGaWxlTGlzdCkodXBkYXRlSW5mbykubWFwKGl0ID0+IHtcbiAgICAgICAgICAgIGNvbnN0IG5hbWUgPSBfcGF0aC5wb3NpeC5iYXNlbmFtZShpdC51cmwpLnJlcGxhY2UoLyAvZywgXCItXCIpO1xuICAgICAgICAgICAgY29uc3QgYXNzZXQgPSB1cGRhdGVJbmZvLmFzc2V0cy5maW5kKGl0ID0+IGl0ICE9IG51bGwgJiYgaXQubmFtZSA9PT0gbmFtZSk7XG4gICAgICAgICAgICBpZiAoYXNzZXQgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRocm93ICgwLCAoX2J1aWxkZXJVdGlsUnVudGltZSB8fCBfbG9hZF9idWlsZGVyVXRpbFJ1bnRpbWUoKSkubmV3RXJyb3IpKGBDYW5ub3QgZmluZCBhc3NldCBcIiR7bmFtZX1cIiBpbjogJHtKU09OLnN0cmluZ2lmeSh1cGRhdGVJbmZvLmFzc2V0cywgbnVsbCwgMil9YCwgXCJFUlJfVVBEQVRFUl9BU1NFVF9OT1RfRk9VTkRcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHVybDogbmV3IChfdXJsIHx8IF9sb2FkX3VybCgpKS5VUkwoYXNzZXQudXJsKSxcbiAgICAgICAgICAgICAgICBpbmZvOiBpdFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSk7XG4gICAgfVxufVxuZXhwb3J0cy5Qcml2YXRlR2l0SHViUHJvdmlkZXIgPSBQcml2YXRlR2l0SHViUHJvdmlkZXI7IC8vIyBzb3VyY2VNYXBwaW5nVVJMPVByaXZhdGVHaXRIdWJQcm92aWRlci5qcy5tYXBcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvZWxlY3Ryb24tdXBkYXRlci9vdXQvUHJpdmF0ZUdpdEh1YlByb3ZpZGVyLmpzIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuTnNpc1VwZGF0ZXIgPSB1bmRlZmluZWQ7XG5cbnZhciBfYmx1ZWJpcmRMc3Q7XG5cbmZ1bmN0aW9uIF9sb2FkX2JsdWViaXJkTHN0KCkge1xuICAgIHJldHVybiBfYmx1ZWJpcmRMc3QgPSByZXF1aXJlKFwiYmx1ZWJpcmQtbHN0XCIpO1xufVxuXG52YXIgX2J1aWxkZXJVdGlsUnVudGltZTtcblxuZnVuY3Rpb24gX2xvYWRfYnVpbGRlclV0aWxSdW50aW1lKCkge1xuICAgIHJldHVybiBfYnVpbGRlclV0aWxSdW50aW1lID0gcmVxdWlyZShcImJ1aWxkZXItdXRpbC1ydW50aW1lXCIpO1xufVxuXG52YXIgX2NoaWxkX3Byb2Nlc3M7XG5cbmZ1bmN0aW9uIF9sb2FkX2NoaWxkX3Byb2Nlc3MoKSB7XG4gICAgcmV0dXJuIF9jaGlsZF9wcm9jZXNzID0gcmVxdWlyZShcImNoaWxkX3Byb2Nlc3NcIik7XG59XG5cbnZhciBfcGF0aCA9IF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKHJlcXVpcmUoXCJwYXRoXCIpKTtcblxucmVxdWlyZShcInNvdXJjZS1tYXAtc3VwcG9ydC9yZWdpc3RlclwiKTtcblxudmFyIF9CYXNlVXBkYXRlcjtcblxuZnVuY3Rpb24gX2xvYWRfQmFzZVVwZGF0ZXIoKSB7XG4gICAgcmV0dXJuIF9CYXNlVXBkYXRlciA9IHJlcXVpcmUoXCIuL0Jhc2VVcGRhdGVyXCIpO1xufVxuXG52YXIgX0ZpbGVXaXRoRW1iZWRkZWRCbG9ja01hcERpZmZlcmVudGlhbERvd25sb2FkZXI7XG5cbmZ1bmN0aW9uIF9sb2FkX0ZpbGVXaXRoRW1iZWRkZWRCbG9ja01hcERpZmZlcmVudGlhbERvd25sb2FkZXIoKSB7XG4gICAgcmV0dXJuIF9GaWxlV2l0aEVtYmVkZGVkQmxvY2tNYXBEaWZmZXJlbnRpYWxEb3dubG9hZGVyID0gcmVxdWlyZShcIi4vZGlmZmVyZW50aWFsRG93bmxvYWRlci9GaWxlV2l0aEVtYmVkZGVkQmxvY2tNYXBEaWZmZXJlbnRpYWxEb3dubG9hZGVyXCIpO1xufVxuXG52YXIgX0dlbmVyaWNEaWZmZXJlbnRpYWxEb3dubG9hZGVyO1xuXG5mdW5jdGlvbiBfbG9hZF9HZW5lcmljRGlmZmVyZW50aWFsRG93bmxvYWRlcigpIHtcbiAgICByZXR1cm4gX0dlbmVyaWNEaWZmZXJlbnRpYWxEb3dubG9hZGVyID0gcmVxdWlyZShcIi4vZGlmZmVyZW50aWFsRG93bmxvYWRlci9HZW5lcmljRGlmZmVyZW50aWFsRG93bmxvYWRlclwiKTtcbn1cblxudmFyIF9tYWluO1xuXG5mdW5jdGlvbiBfbG9hZF9tYWluKCkge1xuICAgIHJldHVybiBfbWFpbiA9IHJlcXVpcmUoXCIuL21haW5cIik7XG59XG5cbnZhciBfUHJvdmlkZXI7XG5cbmZ1bmN0aW9uIF9sb2FkX1Byb3ZpZGVyKCkge1xuICAgIHJldHVybiBfUHJvdmlkZXIgPSByZXF1aXJlKFwiLi9Qcm92aWRlclwiKTtcbn1cblxudmFyIF93aW5kb3dzRXhlY3V0YWJsZUNvZGVTaWduYXR1cmVWZXJpZmllcjtcblxuZnVuY3Rpb24gX2xvYWRfd2luZG93c0V4ZWN1dGFibGVDb2RlU2lnbmF0dXJlVmVyaWZpZXIoKSB7XG4gICAgcmV0dXJuIF93aW5kb3dzRXhlY3V0YWJsZUNvZGVTaWduYXR1cmVWZXJpZmllciA9IHJlcXVpcmUoXCIuL3dpbmRvd3NFeGVjdXRhYmxlQ29kZVNpZ25hdHVyZVZlcmlmaWVyXCIpO1xufVxuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChvYmopIHsgaWYgKG9iaiAmJiBvYmouX19lc01vZHVsZSkgeyByZXR1cm4gb2JqOyB9IGVsc2UgeyB2YXIgbmV3T2JqID0ge307IGlmIChvYmogIT0gbnVsbCkgeyBmb3IgKHZhciBrZXkgaW4gb2JqKSB7IGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBrZXkpKSBuZXdPYmpba2V5XSA9IG9ialtrZXldOyB9IH0gbmV3T2JqLmRlZmF1bHQgPSBvYmo7IHJldHVybiBuZXdPYmo7IH0gfVxuXG5jbGFzcyBOc2lzVXBkYXRlciBleHRlbmRzIChfQmFzZVVwZGF0ZXIgfHwgX2xvYWRfQmFzZVVwZGF0ZXIoKSkuQmFzZVVwZGF0ZXIge1xuICAgIGNvbnN0cnVjdG9yKG9wdGlvbnMsIGFwcCkge1xuICAgICAgICBzdXBlcihvcHRpb25zLCBhcHApO1xuICAgIH1cbiAgICAvKioqIEBwcml2YXRlICovXG4gICAgZG9Eb3dubG9hZFVwZGF0ZSh1cGRhdGVJbmZvLCBjYW5jZWxsYXRpb25Ub2tlbikge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgICAgIHJldHVybiAoMCwgKF9ibHVlYmlyZExzdCB8fCBfbG9hZF9ibHVlYmlyZExzdCgpKS5jb3JvdXRpbmUpKGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCBwcm92aWRlciA9IHlpZWxkIF90aGlzLnByb3ZpZGVyO1xuICAgICAgICAgICAgY29uc3QgZmlsZUluZm8gPSAoMCwgKF9Qcm92aWRlciB8fCBfbG9hZF9Qcm92aWRlcigpKS5maW5kRmlsZSkocHJvdmlkZXIucmVzb2x2ZUZpbGVzKHVwZGF0ZUluZm8pLCBcImV4ZVwiKTtcbiAgICAgICAgICAgIGNvbnN0IHJlcXVlc3RIZWFkZXJzID0geWllbGQgX3RoaXMuY29tcHV0ZVJlcXVlc3RIZWFkZXJzKCk7XG4gICAgICAgICAgICBjb25zdCBkb3dubG9hZE9wdGlvbnMgPSB7XG4gICAgICAgICAgICAgICAgc2tpcERpckNyZWF0aW9uOiB0cnVlLFxuICAgICAgICAgICAgICAgIGhlYWRlcnM6IHJlcXVlc3RIZWFkZXJzLFxuICAgICAgICAgICAgICAgIGNhbmNlbGxhdGlvblRva2VuLFxuICAgICAgICAgICAgICAgIHNoYTUxMjogZmlsZUluZm8uaW5mby5zaGE1MTJcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBsZXQgcGFja2FnZVBhdGggPSBfdGhpcy5kb3dubG9hZGVkVXBkYXRlSGVscGVyLnBhY2thZ2VQYXRoO1xuICAgICAgICAgICAgbGV0IGluc3RhbGxlclBhdGggPSBfdGhpcy5kb3dubG9hZGVkVXBkYXRlSGVscGVyLmdldERvd25sb2FkZWRGaWxlKHVwZGF0ZUluZm8sIGZpbGVJbmZvKTtcbiAgICAgICAgICAgIGlmIChpbnN0YWxsZXJQYXRoICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcGFja2FnZVBhdGggPT0gbnVsbCA/IFtpbnN0YWxsZXJQYXRoXSA6IFtpbnN0YWxsZXJQYXRoLCBwYWNrYWdlUGF0aF07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB5aWVsZCBfdGhpcy5leGVjdXRlRG93bmxvYWQoZG93bmxvYWRPcHRpb25zLCBmaWxlSW5mbywgKCgpID0+IHtcbiAgICAgICAgICAgICAgICB2YXIgX3JlZiA9ICgwLCAoX2JsdWViaXJkTHN0IHx8IF9sb2FkX2JsdWViaXJkTHN0KCkpLmNvcm91dGluZSkoZnVuY3Rpb24qICh0ZW1wRGlyLCBkZXN0aW5hdGlvbkZpbGUsIHJlbW92ZVRlbXBEaXJJZkFueSkge1xuICAgICAgICAgICAgICAgICAgICBpbnN0YWxsZXJQYXRoID0gZGVzdGluYXRpb25GaWxlO1xuICAgICAgICAgICAgICAgICAgICBpZiAoeWllbGQgX3RoaXMuZGlmZmVyZW50aWFsRG93bmxvYWRJbnN0YWxsZXIoZmlsZUluZm8sIFwiT0xEXCIsIGluc3RhbGxlclBhdGgsIHJlcXVlc3RIZWFkZXJzLCBwcm92aWRlcikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHlpZWxkIF90aGlzLmh0dHBFeGVjdXRvci5kb3dubG9hZChmaWxlSW5mby51cmwuaHJlZiwgaW5zdGFsbGVyUGF0aCwgZG93bmxvYWRPcHRpb25zKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjb25zdCBzaWduYXR1cmVWZXJpZmljYXRpb25TdGF0dXMgPSB5aWVsZCBfdGhpcy52ZXJpZnlTaWduYXR1cmUoaW5zdGFsbGVyUGF0aCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzaWduYXR1cmVWZXJpZmljYXRpb25TdGF0dXMgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgeWllbGQgcmVtb3ZlVGVtcERpcklmQW55KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBub2luc3BlY3Rpb24gVGhyb3dJbnNpZGVGaW5hbGx5QmxvY2tKU1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgKDAsIChfYnVpbGRlclV0aWxSdW50aW1lIHx8IF9sb2FkX2J1aWxkZXJVdGlsUnVudGltZSgpKS5uZXdFcnJvcikoYE5ldyB2ZXJzaW9uICR7X3RoaXMudXBkYXRlSW5mby52ZXJzaW9ufSBpcyBub3Qgc2lnbmVkIGJ5IHRoZSBhcHBsaWNhdGlvbiBvd25lcjogJHtzaWduYXR1cmVWZXJpZmljYXRpb25TdGF0dXN9YCwgXCJFUlJfVVBEQVRFUl9JTlZBTElEX1NJR05BVFVSRVwiKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjb25zdCBwYWNrYWdlSW5mbyA9IGZpbGVJbmZvLnBhY2thZ2VJbmZvO1xuICAgICAgICAgICAgICAgICAgICBpZiAocGFja2FnZUluZm8gIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcGFja2FnZVBhdGggPSBfcGF0aC5qb2luKHRlbXBEaXIsIGBwYWNrYWdlLSR7dXBkYXRlSW5mby52ZXJzaW9ufSR7X3BhdGguZXh0bmFtZShwYWNrYWdlSW5mby5wYXRoKSB8fCBcIi43elwifWApO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHlpZWxkIF90aGlzLmRpZmZlcmVudGlhbERvd25sb2FkV2ViUGFja2FnZShwYWNrYWdlSW5mbywgcGFja2FnZVBhdGgsIHByb3ZpZGVyKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHlpZWxkIF90aGlzLmh0dHBFeGVjdXRvci5kb3dubG9hZChwYWNrYWdlSW5mby5wYXRoLCBwYWNrYWdlUGF0aCwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBza2lwRGlyQ3JlYXRpb246IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhlYWRlcnM6IHJlcXVlc3RIZWFkZXJzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYW5jZWxsYXRpb25Ub2tlbixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2hhNTEyOiBwYWNrYWdlSW5mby5zaGE1MTJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChfeCwgX3gyLCBfeDMpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9yZWYuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSkoKSk7XG4gICAgICAgICAgICBfdGhpcy5kb3dubG9hZGVkVXBkYXRlSGVscGVyLnNldERvd25sb2FkZWRGaWxlKGluc3RhbGxlclBhdGgsIHBhY2thZ2VQYXRoLCB1cGRhdGVJbmZvLCBmaWxlSW5mbyk7XG4gICAgICAgICAgICBfdGhpcy5hZGRRdWl0SGFuZGxlcigpO1xuICAgICAgICAgICAgX3RoaXMuZW1pdCgoX21haW4gfHwgX2xvYWRfbWFpbigpKS5VUERBVEVfRE9XTkxPQURFRCwgX3RoaXMudXBkYXRlSW5mbyk7XG4gICAgICAgICAgICByZXR1cm4gcGFja2FnZVBhdGggPT0gbnVsbCA/IFtpbnN0YWxsZXJQYXRoXSA6IFtpbnN0YWxsZXJQYXRoLCBwYWNrYWdlUGF0aF07XG4gICAgICAgIH0pKCk7XG4gICAgfVxuICAgIC8vICRjZXJ0aWZpY2F0ZUluZm8gPSAoR2V0LUF1dGhlbnRpY29kZVNpZ25hdHVyZSAneHh4XFx5eXkuZXhlJ1xuICAgIC8vIHwgd2hlcmUgeyRfLlN0YXR1cy5FcXVhbHMoW1N5c3RlbS5NYW5hZ2VtZW50LkF1dG9tYXRpb24uU2lnbmF0dXJlU3RhdHVzXTo6VmFsaWQpIC1hbmQgJF8uU2lnbmVyQ2VydGlmaWNhdGUuU3ViamVjdC5Db250YWlucyhcIkNOPXNpZW1lbnMuY29tXCIpfSlcbiAgICAvLyB8IE91dC1TdHJpbmcgOyBpZiAoJGNlcnRpZmljYXRlSW5mbykgeyBleGl0IDAgfSBlbHNlIHsgZXhpdCAxIH1cbiAgICB2ZXJpZnlTaWduYXR1cmUodGVtcFVwZGF0ZUZpbGUpIHtcbiAgICAgICAgdmFyIF90aGlzMiA9IHRoaXM7XG5cbiAgICAgICAgcmV0dXJuICgwLCAoX2JsdWViaXJkTHN0IHx8IF9sb2FkX2JsdWViaXJkTHN0KCkpLmNvcm91dGluZSkoZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGxldCBwdWJsaXNoZXJOYW1lO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBwdWJsaXNoZXJOYW1lID0gKHlpZWxkIF90aGlzMi5jb25maWdPbkRpc2sudmFsdWUpLnB1Ymxpc2hlck5hbWU7XG4gICAgICAgICAgICAgICAgaWYgKHB1Ymxpc2hlck5hbWUgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgaWYgKGUuY29kZSA9PT0gXCJFTk9FTlRcIikge1xuICAgICAgICAgICAgICAgICAgICAvLyBubyBhcHAtdXBkYXRlLnltbFxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB5aWVsZCAoMCwgKF93aW5kb3dzRXhlY3V0YWJsZUNvZGVTaWduYXR1cmVWZXJpZmllciB8fCBfbG9hZF93aW5kb3dzRXhlY3V0YWJsZUNvZGVTaWduYXR1cmVWZXJpZmllcigpKS52ZXJpZnlTaWduYXR1cmUpKEFycmF5LmlzQXJyYXkocHVibGlzaGVyTmFtZSkgPyBwdWJsaXNoZXJOYW1lIDogW3B1Ymxpc2hlck5hbWVdLCB0ZW1wVXBkYXRlRmlsZSwgX3RoaXMyLl9sb2dnZXIpO1xuICAgICAgICB9KSgpO1xuICAgIH1cbiAgICBkb0luc3RhbGwoaW5zdGFsbGVyUGF0aCwgaXNTaWxlbnQsIGlzRm9yY2VSdW5BZnRlcikge1xuICAgICAgICBjb25zdCBhcmdzID0gW1wiLS11cGRhdGVkXCJdO1xuICAgICAgICBpZiAoaXNTaWxlbnQpIHtcbiAgICAgICAgICAgIGFyZ3MucHVzaChcIi9TXCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc0ZvcmNlUnVuQWZ0ZXIpIHtcbiAgICAgICAgICAgIGFyZ3MucHVzaChcIi0tZm9yY2UtcnVuXCIpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHBhY2thZ2VQYXRoID0gdGhpcy5kb3dubG9hZGVkVXBkYXRlSGVscGVyLnBhY2thZ2VQYXRoO1xuICAgICAgICBpZiAocGFja2FnZVBhdGggIT0gbnVsbCkge1xuICAgICAgICAgICAgLy8gb25seSA9IGZvcm0gaXMgc3VwcG9ydGVkXG4gICAgICAgICAgICBhcmdzLnB1c2goYC0tcGFja2FnZS1maWxlPSR7cGFja2FnZVBhdGh9YCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgc3Bhd25PcHRpb25zID0ge1xuICAgICAgICAgICAgZGV0YWNoZWQ6IHRydWUsXG4gICAgICAgICAgICBzdGRpbzogXCJpZ25vcmVcIlxuICAgICAgICB9O1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgKDAsIChfY2hpbGRfcHJvY2VzcyB8fCBfbG9hZF9jaGlsZF9wcm9jZXNzKCkpLnNwYXduKShpbnN0YWxsZXJQYXRoLCBhcmdzLCBzcGF3bk9wdGlvbnMpLnVucmVmKCk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIC8vIHllcywgc3VjaCBlcnJvcnMgZGlzcGF0Y2hlZCBub3QgYXMgZXJyb3IgZXZlbnRcbiAgICAgICAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9lbGVjdHJvbi11c2VybGFuZC9lbGVjdHJvbi1idWlsZGVyL2lzc3Vlcy8xMTI5XG4gICAgICAgICAgICBpZiAoZS5jb2RlID09PSBcIlVOS05PV05cIiB8fCBlLmNvZGUgPT09IFwiRUFDQ0VTXCIpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9sb2dnZXIuaW5mbyhcIkFjY2VzcyBkZW5pZWQgb3IgVU5LTk9XTiBlcnJvciBjb2RlIG9uIHNwYXduLCB3aWxsIGJlIGV4ZWN1dGVkIGFnYWluIHVzaW5nIGVsZXZhdGVcIik7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgKDAsIChfY2hpbGRfcHJvY2VzcyB8fCBfbG9hZF9jaGlsZF9wcm9jZXNzKCkpLnNwYXduKShfcGF0aC5qb2luKHByb2Nlc3MucmVzb3VyY2VzUGF0aCwgXCJlbGV2YXRlLmV4ZVwiKSwgW2luc3RhbGxlclBhdGhdLmNvbmNhdChhcmdzKSwgc3Bhd25PcHRpb25zKS51bnJlZigpO1xuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kaXNwYXRjaEVycm9yKGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5kaXNwYXRjaEVycm9yKGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBkaWZmZXJlbnRpYWxEb3dubG9hZEluc3RhbGxlcihmaWxlSW5mbywgb2xkRmlsZSwgaW5zdGFsbGVyUGF0aCwgcmVxdWVzdEhlYWRlcnMsIHByb3ZpZGVyKSB7XG4gICAgICAgIHZhciBfdGhpczMgPSB0aGlzO1xuXG4gICAgICAgIHJldHVybiAoMCwgKF9ibHVlYmlyZExzdCB8fCBfbG9hZF9ibHVlYmlyZExzdCgpKS5jb3JvdXRpbmUpKGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBpZiAocHJvY2Vzcy5lbnYuX19OU0lTX0RJRkZFUkVOVElBTF9VUERBVEVfXyA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGJsb2NrTWFwRGF0YSA9IEpTT04ucGFyc2UoKHlpZWxkIHByb3ZpZGVyLmh0dHBSZXF1ZXN0KCgwLCAoX21haW4gfHwgX2xvYWRfbWFpbigpKS5uZXdVcmxGcm9tQmFzZSkoYCR7ZmlsZUluZm8udXJsLnBhdGhuYW1lfS5ibG9ja01hcC5qc29uYCwgZmlsZUluZm8udXJsKSkpKTtcbiAgICAgICAgICAgICAgICB5aWVsZCBuZXcgKF9HZW5lcmljRGlmZmVyZW50aWFsRG93bmxvYWRlciB8fCBfbG9hZF9HZW5lcmljRGlmZmVyZW50aWFsRG93bmxvYWRlcigpKS5HZW5lcmljRGlmZmVyZW50aWFsRG93bmxvYWRlcihmaWxlSW5mby5pbmZvLCBfdGhpczMuaHR0cEV4ZWN1dG9yLCB7XG4gICAgICAgICAgICAgICAgICAgIG5ld1VybDogZmlsZUluZm8udXJsLmhyZWYsXG4gICAgICAgICAgICAgICAgICAgIG9sZEZpbGUsXG4gICAgICAgICAgICAgICAgICAgIGxvZ2dlcjogX3RoaXMzLl9sb2dnZXIsXG4gICAgICAgICAgICAgICAgICAgIG5ld0ZpbGU6IGluc3RhbGxlclBhdGgsXG4gICAgICAgICAgICAgICAgICAgIHVzZU11bHRpcGxlUmFuZ2VSZXF1ZXN0OiBwcm92aWRlci51c2VNdWx0aXBsZVJhbmdlUmVxdWVzdCxcbiAgICAgICAgICAgICAgICAgICAgcmVxdWVzdEhlYWRlcnNcbiAgICAgICAgICAgICAgICB9KS5kb3dubG9hZChibG9ja01hcERhdGEpO1xuICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIF90aGlzMy5fbG9nZ2VyLmVycm9yKGBDYW5ub3QgZG93bmxvYWQgZGlmZmVyZW50aWFsbHksIGZhbGxiYWNrIHRvIGZ1bGwgZG93bmxvYWQ6ICR7ZS5zdGFjayB8fCBlfWApO1xuICAgICAgICAgICAgICAgIC8vIGR1cmluZyB0ZXN0IChkZXZlbG9wZXIgbWFjaGluZSBtYWMpIHdlIG11c3QgdGhyb3cgZXJyb3JcbiAgICAgICAgICAgICAgICByZXR1cm4gcHJvY2Vzcy5wbGF0Zm9ybSA9PT0gXCJ3aW4zMlwiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9KSgpO1xuICAgIH1cbiAgICBkaWZmZXJlbnRpYWxEb3dubG9hZFdlYlBhY2thZ2UocGFja2FnZUluZm8sIHBhY2thZ2VQYXRoLCBwcm92aWRlcikge1xuICAgICAgICB2YXIgX3RoaXM0ID0gdGhpcztcblxuICAgICAgICByZXR1cm4gKDAsIChfYmx1ZWJpcmRMc3QgfHwgX2xvYWRfYmx1ZWJpcmRMc3QoKSkuY29yb3V0aW5lKShmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgaWYgKHBhY2thZ2VJbmZvLmJsb2NrTWFwU2l6ZSA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHlpZWxkIG5ldyAoX0ZpbGVXaXRoRW1iZWRkZWRCbG9ja01hcERpZmZlcmVudGlhbERvd25sb2FkZXIgfHwgX2xvYWRfRmlsZVdpdGhFbWJlZGRlZEJsb2NrTWFwRGlmZmVyZW50aWFsRG93bmxvYWRlcigpKS5GaWxlV2l0aEVtYmVkZGVkQmxvY2tNYXBEaWZmZXJlbnRpYWxEb3dubG9hZGVyKHBhY2thZ2VJbmZvLCBfdGhpczQuaHR0cEV4ZWN1dG9yLCB7XG4gICAgICAgICAgICAgICAgICAgIG5ld1VybDogcGFja2FnZUluZm8ucGF0aCxcbiAgICAgICAgICAgICAgICAgICAgb2xkRmlsZTogX3BhdGguam9pbihwcm9jZXNzLnJlc291cmNlc1BhdGgsIFwiLi5cIiwgXCJwYWNrYWdlLjd6XCIpLFxuICAgICAgICAgICAgICAgICAgICBsb2dnZXI6IF90aGlzNC5fbG9nZ2VyLFxuICAgICAgICAgICAgICAgICAgICBuZXdGaWxlOiBwYWNrYWdlUGF0aCxcbiAgICAgICAgICAgICAgICAgICAgcmVxdWVzdEhlYWRlcnM6IF90aGlzNC5yZXF1ZXN0SGVhZGVycyxcbiAgICAgICAgICAgICAgICAgICAgdXNlTXVsdGlwbGVSYW5nZVJlcXVlc3Q6IHByb3ZpZGVyLnVzZU11bHRpcGxlUmFuZ2VSZXF1ZXN0XG4gICAgICAgICAgICAgICAgfSkuZG93bmxvYWQoKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICBfdGhpczQuX2xvZ2dlci5lcnJvcihgQ2Fubm90IGRvd25sb2FkIGRpZmZlcmVudGlhbGx5LCBmYWxsYmFjayB0byBmdWxsIGRvd25sb2FkOiAke2Uuc3RhY2sgfHwgZX1gKTtcbiAgICAgICAgICAgICAgICAvLyBkdXJpbmcgdGVzdCAoZGV2ZWxvcGVyIG1hY2hpbmUgbWFjIG9yIGxpbnV4KSB3ZSBtdXN0IHRocm93IGVycm9yXG4gICAgICAgICAgICAgICAgcmV0dXJuIHByb2Nlc3MucGxhdGZvcm0gPT09IFwid2luMzJcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfSkoKTtcbiAgICB9XG59XG5leHBvcnRzLk5zaXNVcGRhdGVyID0gTnNpc1VwZGF0ZXI7IC8vIyBzb3VyY2VNYXBwaW5nVVJMPU5zaXNVcGRhdGVyLmpzLm1hcFxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9lbGVjdHJvbi11cGRhdGVyL291dC9Oc2lzVXBkYXRlci5qcyIsIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLkRvd25sb2FkZWRVcGRhdGVIZWxwZXIgPSB1bmRlZmluZWQ7XG5cbnZhciBfbG9kYXNoO1xuXG5mdW5jdGlvbiBfbG9hZF9sb2Rhc2goKSB7XG4gICAgcmV0dXJuIF9sb2Rhc2ggPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJsb2Rhc2guaXNlcXVhbFwiKSk7XG59XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbi8qKiBAcHJpdmF0ZSAqKi9cbmNsYXNzIERvd25sb2FkZWRVcGRhdGVIZWxwZXIge1xuICAgIGdldCBmaWxlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zZXR1cFBhdGg7XG4gICAgfVxuICAgIGdldCBwYWNrYWdlUGF0aCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3BhY2thZ2VQYXRoO1xuICAgIH1cbiAgICBnZXREb3dubG9hZGVkRmlsZSh2ZXJzaW9uSW5mbywgZmlsZUluZm8pIHtcbiAgICAgICAgaWYgKHRoaXMuc2V0dXBQYXRoID09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAoMCwgKF9sb2Rhc2ggfHwgX2xvYWRfbG9kYXNoKCkpLmRlZmF1bHQpKHRoaXMudmVyc2lvbkluZm8sIHZlcnNpb25JbmZvKSAmJiAoMCwgKF9sb2Rhc2ggfHwgX2xvYWRfbG9kYXNoKCkpLmRlZmF1bHQpKHRoaXMuZmlsZUluZm8sIGZpbGVJbmZvKSA/IHRoaXMuc2V0dXBQYXRoIDogbnVsbDtcbiAgICB9XG4gICAgc2V0RG93bmxvYWRlZEZpbGUoZmlsZSwgcGFja2FnZVBhdGgsIHZlcnNpb25JbmZvLCBmaWxlSW5mbykge1xuICAgICAgICB0aGlzLnNldHVwUGF0aCA9IGZpbGU7XG4gICAgICAgIHRoaXMuX3BhY2thZ2VQYXRoID0gcGFja2FnZVBhdGg7XG4gICAgICAgIHRoaXMudmVyc2lvbkluZm8gPSB2ZXJzaW9uSW5mbztcbiAgICAgICAgdGhpcy5maWxlSW5mbyA9IGZpbGVJbmZvO1xuICAgIH1cbiAgICBjbGVhcigpIHtcbiAgICAgICAgdGhpcy5zZXR1cFBhdGggPSBudWxsO1xuICAgICAgICB0aGlzLl9wYWNrYWdlUGF0aCA9IG51bGw7XG4gICAgICAgIHRoaXMudmVyc2lvbkluZm8gPSBudWxsO1xuICAgICAgICB0aGlzLmZpbGVJbmZvID0gbnVsbDtcbiAgICB9XG59XG5leHBvcnRzLkRvd25sb2FkZWRVcGRhdGVIZWxwZXIgPSBEb3dubG9hZGVkVXBkYXRlSGVscGVyOyAvLyMgc291cmNlTWFwcGluZ1VSTD1Eb3dubG9hZGVkVXBkYXRlSGVscGVyLmpzLm1hcFxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9lbGVjdHJvbi11cGRhdGVyL291dC9Eb3dubG9hZGVkVXBkYXRlSGVscGVyLmpzIiwiLyoqXG4gKiBMb2Rhc2ggKEN1c3RvbSBCdWlsZCkgPGh0dHBzOi8vbG9kYXNoLmNvbS8+XG4gKiBCdWlsZDogYGxvZGFzaCBtb2R1bGFyaXplIGV4cG9ydHM9XCJucG1cIiAtbyAuL2BcbiAqIENvcHlyaWdodCBKUyBGb3VuZGF0aW9uIGFuZCBvdGhlciBjb250cmlidXRvcnMgPGh0dHBzOi8vanMuZm91bmRhdGlvbi8+XG4gKiBSZWxlYXNlZCB1bmRlciBNSVQgbGljZW5zZSA8aHR0cHM6Ly9sb2Rhc2guY29tL2xpY2Vuc2U+XG4gKiBCYXNlZCBvbiBVbmRlcnNjb3JlLmpzIDEuOC4zIDxodHRwOi8vdW5kZXJzY29yZWpzLm9yZy9MSUNFTlNFPlxuICogQ29weXJpZ2h0IEplcmVteSBBc2hrZW5hcywgRG9jdW1lbnRDbG91ZCBhbmQgSW52ZXN0aWdhdGl2ZSBSZXBvcnRlcnMgJiBFZGl0b3JzXG4gKi9cblxuLyoqIFVzZWQgYXMgdGhlIHNpemUgdG8gZW5hYmxlIGxhcmdlIGFycmF5IG9wdGltaXphdGlvbnMuICovXG52YXIgTEFSR0VfQVJSQVlfU0laRSA9IDIwMDtcblxuLyoqIFVzZWQgdG8gc3RhbmQtaW4gZm9yIGB1bmRlZmluZWRgIGhhc2ggdmFsdWVzLiAqL1xudmFyIEhBU0hfVU5ERUZJTkVEID0gJ19fbG9kYXNoX2hhc2hfdW5kZWZpbmVkX18nO1xuXG4vKiogVXNlZCB0byBjb21wb3NlIGJpdG1hc2tzIGZvciB2YWx1ZSBjb21wYXJpc29ucy4gKi9cbnZhciBDT01QQVJFX1BBUlRJQUxfRkxBRyA9IDEsXG4gICAgQ09NUEFSRV9VTk9SREVSRURfRkxBRyA9IDI7XG5cbi8qKiBVc2VkIGFzIHJlZmVyZW5jZXMgZm9yIHZhcmlvdXMgYE51bWJlcmAgY29uc3RhbnRzLiAqL1xudmFyIE1BWF9TQUZFX0lOVEVHRVIgPSA5MDA3MTk5MjU0NzQwOTkxO1xuXG4vKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHJlZmVyZW5jZXMuICovXG52YXIgYXJnc1RhZyA9ICdbb2JqZWN0IEFyZ3VtZW50c10nLFxuICAgIGFycmF5VGFnID0gJ1tvYmplY3QgQXJyYXldJyxcbiAgICBhc3luY1RhZyA9ICdbb2JqZWN0IEFzeW5jRnVuY3Rpb25dJyxcbiAgICBib29sVGFnID0gJ1tvYmplY3QgQm9vbGVhbl0nLFxuICAgIGRhdGVUYWcgPSAnW29iamVjdCBEYXRlXScsXG4gICAgZXJyb3JUYWcgPSAnW29iamVjdCBFcnJvcl0nLFxuICAgIGZ1bmNUYWcgPSAnW29iamVjdCBGdW5jdGlvbl0nLFxuICAgIGdlblRhZyA9ICdbb2JqZWN0IEdlbmVyYXRvckZ1bmN0aW9uXScsXG4gICAgbWFwVGFnID0gJ1tvYmplY3QgTWFwXScsXG4gICAgbnVtYmVyVGFnID0gJ1tvYmplY3QgTnVtYmVyXScsXG4gICAgbnVsbFRhZyA9ICdbb2JqZWN0IE51bGxdJyxcbiAgICBvYmplY3RUYWcgPSAnW29iamVjdCBPYmplY3RdJyxcbiAgICBwcm9taXNlVGFnID0gJ1tvYmplY3QgUHJvbWlzZV0nLFxuICAgIHByb3h5VGFnID0gJ1tvYmplY3QgUHJveHldJyxcbiAgICByZWdleHBUYWcgPSAnW29iamVjdCBSZWdFeHBdJyxcbiAgICBzZXRUYWcgPSAnW29iamVjdCBTZXRdJyxcbiAgICBzdHJpbmdUYWcgPSAnW29iamVjdCBTdHJpbmddJyxcbiAgICBzeW1ib2xUYWcgPSAnW29iamVjdCBTeW1ib2xdJyxcbiAgICB1bmRlZmluZWRUYWcgPSAnW29iamVjdCBVbmRlZmluZWRdJyxcbiAgICB3ZWFrTWFwVGFnID0gJ1tvYmplY3QgV2Vha01hcF0nO1xuXG52YXIgYXJyYXlCdWZmZXJUYWcgPSAnW29iamVjdCBBcnJheUJ1ZmZlcl0nLFxuICAgIGRhdGFWaWV3VGFnID0gJ1tvYmplY3QgRGF0YVZpZXddJyxcbiAgICBmbG9hdDMyVGFnID0gJ1tvYmplY3QgRmxvYXQzMkFycmF5XScsXG4gICAgZmxvYXQ2NFRhZyA9ICdbb2JqZWN0IEZsb2F0NjRBcnJheV0nLFxuICAgIGludDhUYWcgPSAnW29iamVjdCBJbnQ4QXJyYXldJyxcbiAgICBpbnQxNlRhZyA9ICdbb2JqZWN0IEludDE2QXJyYXldJyxcbiAgICBpbnQzMlRhZyA9ICdbb2JqZWN0IEludDMyQXJyYXldJyxcbiAgICB1aW50OFRhZyA9ICdbb2JqZWN0IFVpbnQ4QXJyYXldJyxcbiAgICB1aW50OENsYW1wZWRUYWcgPSAnW29iamVjdCBVaW50OENsYW1wZWRBcnJheV0nLFxuICAgIHVpbnQxNlRhZyA9ICdbb2JqZWN0IFVpbnQxNkFycmF5XScsXG4gICAgdWludDMyVGFnID0gJ1tvYmplY3QgVWludDMyQXJyYXldJztcblxuLyoqXG4gKiBVc2VkIHRvIG1hdGNoIGBSZWdFeHBgXG4gKiBbc3ludGF4IGNoYXJhY3RlcnNdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLXBhdHRlcm5zKS5cbiAqL1xudmFyIHJlUmVnRXhwQ2hhciA9IC9bXFxcXF4kLiorPygpW1xcXXt9fF0vZztcblxuLyoqIFVzZWQgdG8gZGV0ZWN0IGhvc3QgY29uc3RydWN0b3JzIChTYWZhcmkpLiAqL1xudmFyIHJlSXNIb3N0Q3RvciA9IC9eXFxbb2JqZWN0IC4rP0NvbnN0cnVjdG9yXFxdJC87XG5cbi8qKiBVc2VkIHRvIGRldGVjdCB1bnNpZ25lZCBpbnRlZ2VyIHZhbHVlcy4gKi9cbnZhciByZUlzVWludCA9IC9eKD86MHxbMS05XVxcZCopJC87XG5cbi8qKiBVc2VkIHRvIGlkZW50aWZ5IGB0b1N0cmluZ1RhZ2AgdmFsdWVzIG9mIHR5cGVkIGFycmF5cy4gKi9cbnZhciB0eXBlZEFycmF5VGFncyA9IHt9O1xudHlwZWRBcnJheVRhZ3NbZmxvYXQzMlRhZ10gPSB0eXBlZEFycmF5VGFnc1tmbG9hdDY0VGFnXSA9XG50eXBlZEFycmF5VGFnc1tpbnQ4VGFnXSA9IHR5cGVkQXJyYXlUYWdzW2ludDE2VGFnXSA9XG50eXBlZEFycmF5VGFnc1tpbnQzMlRhZ10gPSB0eXBlZEFycmF5VGFnc1t1aW50OFRhZ10gPVxudHlwZWRBcnJheVRhZ3NbdWludDhDbGFtcGVkVGFnXSA9IHR5cGVkQXJyYXlUYWdzW3VpbnQxNlRhZ10gPVxudHlwZWRBcnJheVRhZ3NbdWludDMyVGFnXSA9IHRydWU7XG50eXBlZEFycmF5VGFnc1thcmdzVGFnXSA9IHR5cGVkQXJyYXlUYWdzW2FycmF5VGFnXSA9XG50eXBlZEFycmF5VGFnc1thcnJheUJ1ZmZlclRhZ10gPSB0eXBlZEFycmF5VGFnc1tib29sVGFnXSA9XG50eXBlZEFycmF5VGFnc1tkYXRhVmlld1RhZ10gPSB0eXBlZEFycmF5VGFnc1tkYXRlVGFnXSA9XG50eXBlZEFycmF5VGFnc1tlcnJvclRhZ10gPSB0eXBlZEFycmF5VGFnc1tmdW5jVGFnXSA9XG50eXBlZEFycmF5VGFnc1ttYXBUYWddID0gdHlwZWRBcnJheVRhZ3NbbnVtYmVyVGFnXSA9XG50eXBlZEFycmF5VGFnc1tvYmplY3RUYWddID0gdHlwZWRBcnJheVRhZ3NbcmVnZXhwVGFnXSA9XG50eXBlZEFycmF5VGFnc1tzZXRUYWddID0gdHlwZWRBcnJheVRhZ3Nbc3RyaW5nVGFnXSA9XG50eXBlZEFycmF5VGFnc1t3ZWFrTWFwVGFnXSA9IGZhbHNlO1xuXG4vKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYGdsb2JhbGAgZnJvbSBOb2RlLmpzLiAqL1xudmFyIGZyZWVHbG9iYWwgPSB0eXBlb2YgZ2xvYmFsID09ICdvYmplY3QnICYmIGdsb2JhbCAmJiBnbG9iYWwuT2JqZWN0ID09PSBPYmplY3QgJiYgZ2xvYmFsO1xuXG4vKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYHNlbGZgLiAqL1xudmFyIGZyZWVTZWxmID0gdHlwZW9mIHNlbGYgPT0gJ29iamVjdCcgJiYgc2VsZiAmJiBzZWxmLk9iamVjdCA9PT0gT2JqZWN0ICYmIHNlbGY7XG5cbi8qKiBVc2VkIGFzIGEgcmVmZXJlbmNlIHRvIHRoZSBnbG9iYWwgb2JqZWN0LiAqL1xudmFyIHJvb3QgPSBmcmVlR2xvYmFsIHx8IGZyZWVTZWxmIHx8IEZ1bmN0aW9uKCdyZXR1cm4gdGhpcycpKCk7XG5cbi8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgZXhwb3J0c2AuICovXG52YXIgZnJlZUV4cG9ydHMgPSB0eXBlb2YgZXhwb3J0cyA9PSAnb2JqZWN0JyAmJiBleHBvcnRzICYmICFleHBvcnRzLm5vZGVUeXBlICYmIGV4cG9ydHM7XG5cbi8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgbW9kdWxlYC4gKi9cbnZhciBmcmVlTW9kdWxlID0gZnJlZUV4cG9ydHMgJiYgdHlwZW9mIG1vZHVsZSA9PSAnb2JqZWN0JyAmJiBtb2R1bGUgJiYgIW1vZHVsZS5ub2RlVHlwZSAmJiBtb2R1bGU7XG5cbi8qKiBEZXRlY3QgdGhlIHBvcHVsYXIgQ29tbW9uSlMgZXh0ZW5zaW9uIGBtb2R1bGUuZXhwb3J0c2AuICovXG52YXIgbW9kdWxlRXhwb3J0cyA9IGZyZWVNb2R1bGUgJiYgZnJlZU1vZHVsZS5leHBvcnRzID09PSBmcmVlRXhwb3J0cztcblxuLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBwcm9jZXNzYCBmcm9tIE5vZGUuanMuICovXG52YXIgZnJlZVByb2Nlc3MgPSBtb2R1bGVFeHBvcnRzICYmIGZyZWVHbG9iYWwucHJvY2VzcztcblxuLyoqIFVzZWQgdG8gYWNjZXNzIGZhc3RlciBOb2RlLmpzIGhlbHBlcnMuICovXG52YXIgbm9kZVV0aWwgPSAoZnVuY3Rpb24oKSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIGZyZWVQcm9jZXNzICYmIGZyZWVQcm9jZXNzLmJpbmRpbmcgJiYgZnJlZVByb2Nlc3MuYmluZGluZygndXRpbCcpO1xuICB9IGNhdGNoIChlKSB7fVxufSgpKTtcblxuLyogTm9kZS5qcyBoZWxwZXIgcmVmZXJlbmNlcy4gKi9cbnZhciBub2RlSXNUeXBlZEFycmF5ID0gbm9kZVV0aWwgJiYgbm9kZVV0aWwuaXNUeXBlZEFycmF5O1xuXG4vKipcbiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgXy5maWx0ZXJgIGZvciBhcnJheXMgd2l0aG91dCBzdXBwb3J0IGZvclxuICogaXRlcmF0ZWUgc2hvcnRoYW5kcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gW2FycmF5XSBUaGUgYXJyYXkgdG8gaXRlcmF0ZSBvdmVyLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gcHJlZGljYXRlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBmaWx0ZXJlZCBhcnJheS5cbiAqL1xuZnVuY3Rpb24gYXJyYXlGaWx0ZXIoYXJyYXksIHByZWRpY2F0ZSkge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IGFycmF5ID09IG51bGwgPyAwIDogYXJyYXkubGVuZ3RoLFxuICAgICAgcmVzSW5kZXggPSAwLFxuICAgICAgcmVzdWx0ID0gW107XG5cbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICB2YXIgdmFsdWUgPSBhcnJheVtpbmRleF07XG4gICAgaWYgKHByZWRpY2F0ZSh2YWx1ZSwgaW5kZXgsIGFycmF5KSkge1xuICAgICAgcmVzdWx0W3Jlc0luZGV4KytdID0gdmFsdWU7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbi8qKlxuICogQXBwZW5kcyB0aGUgZWxlbWVudHMgb2YgYHZhbHVlc2AgdG8gYGFycmF5YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIG1vZGlmeS5cbiAqIEBwYXJhbSB7QXJyYXl9IHZhbHVlcyBUaGUgdmFsdWVzIHRvIGFwcGVuZC5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyBgYXJyYXlgLlxuICovXG5mdW5jdGlvbiBhcnJheVB1c2goYXJyYXksIHZhbHVlcykge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IHZhbHVlcy5sZW5ndGgsXG4gICAgICBvZmZzZXQgPSBhcnJheS5sZW5ndGg7XG5cbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICBhcnJheVtvZmZzZXQgKyBpbmRleF0gPSB2YWx1ZXNbaW5kZXhdO1xuICB9XG4gIHJldHVybiBhcnJheTtcbn1cblxuLyoqXG4gKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYF8uc29tZWAgZm9yIGFycmF5cyB3aXRob3V0IHN1cHBvcnQgZm9yIGl0ZXJhdGVlXG4gKiBzaG9ydGhhbmRzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fSBbYXJyYXldIFRoZSBhcnJheSB0byBpdGVyYXRlIG92ZXIuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBwcmVkaWNhdGUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBhbnkgZWxlbWVudCBwYXNzZXMgdGhlIHByZWRpY2F0ZSBjaGVjayxcbiAqICBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGFycmF5U29tZShhcnJheSwgcHJlZGljYXRlKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gYXJyYXkgPT0gbnVsbCA/IDAgOiBhcnJheS5sZW5ndGg7XG5cbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICBpZiAocHJlZGljYXRlKGFycmF5W2luZGV4XSwgaW5kZXgsIGFycmF5KSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy50aW1lc2Agd2l0aG91dCBzdXBwb3J0IGZvciBpdGVyYXRlZSBzaG9ydGhhbmRzXG4gKiBvciBtYXggYXJyYXkgbGVuZ3RoIGNoZWNrcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtudW1iZXJ9IG4gVGhlIG51bWJlciBvZiB0aW1lcyB0byBpbnZva2UgYGl0ZXJhdGVlYC5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdGVlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHJlc3VsdHMuXG4gKi9cbmZ1bmN0aW9uIGJhc2VUaW1lcyhuLCBpdGVyYXRlZSkge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIHJlc3VsdCA9IEFycmF5KG4pO1xuXG4gIHdoaWxlICgrK2luZGV4IDwgbikge1xuICAgIHJlc3VsdFtpbmRleF0gPSBpdGVyYXRlZShpbmRleCk7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy51bmFyeWAgd2l0aG91dCBzdXBwb3J0IGZvciBzdG9yaW5nIG1ldGFkYXRhLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBjYXAgYXJndW1lbnRzIGZvci5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGNhcHBlZCBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gYmFzZVVuYXJ5KGZ1bmMpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgcmV0dXJuIGZ1bmModmFsdWUpO1xuICB9O1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBhIGBjYWNoZWAgdmFsdWUgZm9yIGBrZXlgIGV4aXN0cy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IGNhY2hlIFRoZSBjYWNoZSB0byBxdWVyeS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgZW50cnkgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYW4gZW50cnkgZm9yIGBrZXlgIGV4aXN0cywgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBjYWNoZUhhcyhjYWNoZSwga2V5KSB7XG4gIHJldHVybiBjYWNoZS5oYXMoa2V5KTtcbn1cblxuLyoqXG4gKiBHZXRzIHRoZSB2YWx1ZSBhdCBga2V5YCBvZiBgb2JqZWN0YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IFtvYmplY3RdIFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHByb3BlcnR5IHRvIGdldC5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBwcm9wZXJ0eSB2YWx1ZS5cbiAqL1xuZnVuY3Rpb24gZ2V0VmFsdWUob2JqZWN0LCBrZXkpIHtcbiAgcmV0dXJuIG9iamVjdCA9PSBudWxsID8gdW5kZWZpbmVkIDogb2JqZWN0W2tleV07XG59XG5cbi8qKlxuICogQ29udmVydHMgYG1hcGAgdG8gaXRzIGtleS12YWx1ZSBwYWlycy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG1hcCBUaGUgbWFwIHRvIGNvbnZlcnQuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGtleS12YWx1ZSBwYWlycy5cbiAqL1xuZnVuY3Rpb24gbWFwVG9BcnJheShtYXApIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICByZXN1bHQgPSBBcnJheShtYXAuc2l6ZSk7XG5cbiAgbWFwLmZvckVhY2goZnVuY3Rpb24odmFsdWUsIGtleSkge1xuICAgIHJlc3VsdFsrK2luZGV4XSA9IFtrZXksIHZhbHVlXTtcbiAgfSk7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIHVuYXJ5IGZ1bmN0aW9uIHRoYXQgaW52b2tlcyBgZnVuY2Agd2l0aCBpdHMgYXJndW1lbnQgdHJhbnNmb3JtZWQuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIHdyYXAuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSB0cmFuc2Zvcm0gVGhlIGFyZ3VtZW50IHRyYW5zZm9ybS5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBvdmVyQXJnKGZ1bmMsIHRyYW5zZm9ybSkge1xuICByZXR1cm4gZnVuY3Rpb24oYXJnKSB7XG4gICAgcmV0dXJuIGZ1bmModHJhbnNmb3JtKGFyZykpO1xuICB9O1xufVxuXG4vKipcbiAqIENvbnZlcnRzIGBzZXRgIHRvIGFuIGFycmF5IG9mIGl0cyB2YWx1ZXMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBzZXQgVGhlIHNldCB0byBjb252ZXJ0LlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSB2YWx1ZXMuXG4gKi9cbmZ1bmN0aW9uIHNldFRvQXJyYXkoc2V0KSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgcmVzdWx0ID0gQXJyYXkoc2V0LnNpemUpO1xuXG4gIHNldC5mb3JFYWNoKGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgcmVzdWx0WysraW5kZXhdID0gdmFsdWU7XG4gIH0pO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG4vKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgYXJyYXlQcm90byA9IEFycmF5LnByb3RvdHlwZSxcbiAgICBmdW5jUHJvdG8gPSBGdW5jdGlvbi5wcm90b3R5cGUsXG4gICAgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKiogVXNlZCB0byBkZXRlY3Qgb3ZlcnJlYWNoaW5nIGNvcmUtanMgc2hpbXMuICovXG52YXIgY29yZUpzRGF0YSA9IHJvb3RbJ19fY29yZS1qc19zaGFyZWRfXyddO1xuXG4vKiogVXNlZCB0byByZXNvbHZlIHRoZSBkZWNvbXBpbGVkIHNvdXJjZSBvZiBmdW5jdGlvbnMuICovXG52YXIgZnVuY1RvU3RyaW5nID0gZnVuY1Byb3RvLnRvU3RyaW5nO1xuXG4vKiogVXNlZCB0byBjaGVjayBvYmplY3RzIGZvciBvd24gcHJvcGVydGllcy4gKi9cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IG9iamVjdFByb3RvLmhhc093blByb3BlcnR5O1xuXG4vKiogVXNlZCB0byBkZXRlY3QgbWV0aG9kcyBtYXNxdWVyYWRpbmcgYXMgbmF0aXZlLiAqL1xudmFyIG1hc2tTcmNLZXkgPSAoZnVuY3Rpb24oKSB7XG4gIHZhciB1aWQgPSAvW14uXSskLy5leGVjKGNvcmVKc0RhdGEgJiYgY29yZUpzRGF0YS5rZXlzICYmIGNvcmVKc0RhdGEua2V5cy5JRV9QUk9UTyB8fCAnJyk7XG4gIHJldHVybiB1aWQgPyAoJ1N5bWJvbChzcmMpXzEuJyArIHVpZCkgOiAnJztcbn0oKSk7XG5cbi8qKlxuICogVXNlZCB0byByZXNvbHZlIHRoZVxuICogW2B0b1N0cmluZ1RhZ2BdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLW9iamVjdC5wcm90b3R5cGUudG9zdHJpbmcpXG4gKiBvZiB2YWx1ZXMuXG4gKi9cbnZhciBuYXRpdmVPYmplY3RUb1N0cmluZyA9IG9iamVjdFByb3RvLnRvU3RyaW5nO1xuXG4vKiogVXNlZCB0byBkZXRlY3QgaWYgYSBtZXRob2QgaXMgbmF0aXZlLiAqL1xudmFyIHJlSXNOYXRpdmUgPSBSZWdFeHAoJ14nICtcbiAgZnVuY1RvU3RyaW5nLmNhbGwoaGFzT3duUHJvcGVydHkpLnJlcGxhY2UocmVSZWdFeHBDaGFyLCAnXFxcXCQmJylcbiAgLnJlcGxhY2UoL2hhc093blByb3BlcnR5fChmdW5jdGlvbikuKj8oPz1cXFxcXFwoKXwgZm9yIC4rPyg/PVxcXFxcXF0pL2csICckMS4qPycpICsgJyQnXG4pO1xuXG4vKiogQnVpbHQtaW4gdmFsdWUgcmVmZXJlbmNlcy4gKi9cbnZhciBCdWZmZXIgPSBtb2R1bGVFeHBvcnRzID8gcm9vdC5CdWZmZXIgOiB1bmRlZmluZWQsXG4gICAgU3ltYm9sID0gcm9vdC5TeW1ib2wsXG4gICAgVWludDhBcnJheSA9IHJvb3QuVWludDhBcnJheSxcbiAgICBwcm9wZXJ0eUlzRW51bWVyYWJsZSA9IG9iamVjdFByb3RvLnByb3BlcnR5SXNFbnVtZXJhYmxlLFxuICAgIHNwbGljZSA9IGFycmF5UHJvdG8uc3BsaWNlLFxuICAgIHN5bVRvU3RyaW5nVGFnID0gU3ltYm9sID8gU3ltYm9sLnRvU3RyaW5nVGFnIDogdW5kZWZpbmVkO1xuXG4vKiBCdWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcyBmb3IgdGhvc2Ugd2l0aCB0aGUgc2FtZSBuYW1lIGFzIG90aGVyIGBsb2Rhc2hgIG1ldGhvZHMuICovXG52YXIgbmF0aXZlR2V0U3ltYm9scyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMsXG4gICAgbmF0aXZlSXNCdWZmZXIgPSBCdWZmZXIgPyBCdWZmZXIuaXNCdWZmZXIgOiB1bmRlZmluZWQsXG4gICAgbmF0aXZlS2V5cyA9IG92ZXJBcmcoT2JqZWN0LmtleXMsIE9iamVjdCk7XG5cbi8qIEJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzIHRoYXQgYXJlIHZlcmlmaWVkIHRvIGJlIG5hdGl2ZS4gKi9cbnZhciBEYXRhVmlldyA9IGdldE5hdGl2ZShyb290LCAnRGF0YVZpZXcnKSxcbiAgICBNYXAgPSBnZXROYXRpdmUocm9vdCwgJ01hcCcpLFxuICAgIFByb21pc2UgPSBnZXROYXRpdmUocm9vdCwgJ1Byb21pc2UnKSxcbiAgICBTZXQgPSBnZXROYXRpdmUocm9vdCwgJ1NldCcpLFxuICAgIFdlYWtNYXAgPSBnZXROYXRpdmUocm9vdCwgJ1dlYWtNYXAnKSxcbiAgICBuYXRpdmVDcmVhdGUgPSBnZXROYXRpdmUoT2JqZWN0LCAnY3JlYXRlJyk7XG5cbi8qKiBVc2VkIHRvIGRldGVjdCBtYXBzLCBzZXRzLCBhbmQgd2Vha21hcHMuICovXG52YXIgZGF0YVZpZXdDdG9yU3RyaW5nID0gdG9Tb3VyY2UoRGF0YVZpZXcpLFxuICAgIG1hcEN0b3JTdHJpbmcgPSB0b1NvdXJjZShNYXApLFxuICAgIHByb21pc2VDdG9yU3RyaW5nID0gdG9Tb3VyY2UoUHJvbWlzZSksXG4gICAgc2V0Q3RvclN0cmluZyA9IHRvU291cmNlKFNldCksXG4gICAgd2Vha01hcEN0b3JTdHJpbmcgPSB0b1NvdXJjZShXZWFrTWFwKTtcblxuLyoqIFVzZWQgdG8gY29udmVydCBzeW1ib2xzIHRvIHByaW1pdGl2ZXMgYW5kIHN0cmluZ3MuICovXG52YXIgc3ltYm9sUHJvdG8gPSBTeW1ib2wgPyBTeW1ib2wucHJvdG90eXBlIDogdW5kZWZpbmVkLFxuICAgIHN5bWJvbFZhbHVlT2YgPSBzeW1ib2xQcm90byA/IHN5bWJvbFByb3RvLnZhbHVlT2YgOiB1bmRlZmluZWQ7XG5cbi8qKlxuICogQ3JlYXRlcyBhIGhhc2ggb2JqZWN0LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7QXJyYXl9IFtlbnRyaWVzXSBUaGUga2V5LXZhbHVlIHBhaXJzIHRvIGNhY2hlLlxuICovXG5mdW5jdGlvbiBIYXNoKGVudHJpZXMpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSBlbnRyaWVzID09IG51bGwgPyAwIDogZW50cmllcy5sZW5ndGg7XG5cbiAgdGhpcy5jbGVhcigpO1xuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIHZhciBlbnRyeSA9IGVudHJpZXNbaW5kZXhdO1xuICAgIHRoaXMuc2V0KGVudHJ5WzBdLCBlbnRyeVsxXSk7XG4gIH1cbn1cblxuLyoqXG4gKiBSZW1vdmVzIGFsbCBrZXktdmFsdWUgZW50cmllcyBmcm9tIHRoZSBoYXNoLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBjbGVhclxuICogQG1lbWJlck9mIEhhc2hcbiAqL1xuZnVuY3Rpb24gaGFzaENsZWFyKCkge1xuICB0aGlzLl9fZGF0YV9fID0gbmF0aXZlQ3JlYXRlID8gbmF0aXZlQ3JlYXRlKG51bGwpIDoge307XG4gIHRoaXMuc2l6ZSA9IDA7XG59XG5cbi8qKlxuICogUmVtb3ZlcyBga2V5YCBhbmQgaXRzIHZhbHVlIGZyb20gdGhlIGhhc2guXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGRlbGV0ZVxuICogQG1lbWJlck9mIEhhc2hcbiAqIEBwYXJhbSB7T2JqZWN0fSBoYXNoIFRoZSBoYXNoIHRvIG1vZGlmeS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gcmVtb3ZlLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBlbnRyeSB3YXMgcmVtb3ZlZCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBoYXNoRGVsZXRlKGtleSkge1xuICB2YXIgcmVzdWx0ID0gdGhpcy5oYXMoa2V5KSAmJiBkZWxldGUgdGhpcy5fX2RhdGFfX1trZXldO1xuICB0aGlzLnNpemUgLT0gcmVzdWx0ID8gMSA6IDA7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbi8qKlxuICogR2V0cyB0aGUgaGFzaCB2YWx1ZSBmb3IgYGtleWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGdldFxuICogQG1lbWJlck9mIEhhc2hcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gZ2V0LlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGVudHJ5IHZhbHVlLlxuICovXG5mdW5jdGlvbiBoYXNoR2V0KGtleSkge1xuICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX187XG4gIGlmIChuYXRpdmVDcmVhdGUpIHtcbiAgICB2YXIgcmVzdWx0ID0gZGF0YVtrZXldO1xuICAgIHJldHVybiByZXN1bHQgPT09IEhBU0hfVU5ERUZJTkVEID8gdW5kZWZpbmVkIDogcmVzdWx0O1xuICB9XG4gIHJldHVybiBoYXNPd25Qcm9wZXJ0eS5jYWxsKGRhdGEsIGtleSkgPyBkYXRhW2tleV0gOiB1bmRlZmluZWQ7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGEgaGFzaCB2YWx1ZSBmb3IgYGtleWAgZXhpc3RzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBoYXNcbiAqIEBtZW1iZXJPZiBIYXNoXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIGVudHJ5IHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGFuIGVudHJ5IGZvciBga2V5YCBleGlzdHMsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaGFzaEhhcyhrZXkpIHtcbiAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fO1xuICByZXR1cm4gbmF0aXZlQ3JlYXRlID8gKGRhdGFba2V5XSAhPT0gdW5kZWZpbmVkKSA6IGhhc093blByb3BlcnR5LmNhbGwoZGF0YSwga2V5KTtcbn1cblxuLyoqXG4gKiBTZXRzIHRoZSBoYXNoIGBrZXlgIHRvIGB2YWx1ZWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIHNldFxuICogQG1lbWJlck9mIEhhc2hcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gc2V0LlxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gc2V0LlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgaGFzaCBpbnN0YW5jZS5cbiAqL1xuZnVuY3Rpb24gaGFzaFNldChrZXksIHZhbHVlKSB7XG4gIHZhciBkYXRhID0gdGhpcy5fX2RhdGFfXztcbiAgdGhpcy5zaXplICs9IHRoaXMuaGFzKGtleSkgPyAwIDogMTtcbiAgZGF0YVtrZXldID0gKG5hdGl2ZUNyZWF0ZSAmJiB2YWx1ZSA9PT0gdW5kZWZpbmVkKSA/IEhBU0hfVU5ERUZJTkVEIDogdmFsdWU7XG4gIHJldHVybiB0aGlzO1xufVxuXG4vLyBBZGQgbWV0aG9kcyB0byBgSGFzaGAuXG5IYXNoLnByb3RvdHlwZS5jbGVhciA9IGhhc2hDbGVhcjtcbkhhc2gucHJvdG90eXBlWydkZWxldGUnXSA9IGhhc2hEZWxldGU7XG5IYXNoLnByb3RvdHlwZS5nZXQgPSBoYXNoR2V0O1xuSGFzaC5wcm90b3R5cGUuaGFzID0gaGFzaEhhcztcbkhhc2gucHJvdG90eXBlLnNldCA9IGhhc2hTZXQ7XG5cbi8qKlxuICogQ3JlYXRlcyBhbiBsaXN0IGNhY2hlIG9iamVjdC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge0FycmF5fSBbZW50cmllc10gVGhlIGtleS12YWx1ZSBwYWlycyB0byBjYWNoZS5cbiAqL1xuZnVuY3Rpb24gTGlzdENhY2hlKGVudHJpZXMpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSBlbnRyaWVzID09IG51bGwgPyAwIDogZW50cmllcy5sZW5ndGg7XG5cbiAgdGhpcy5jbGVhcigpO1xuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIHZhciBlbnRyeSA9IGVudHJpZXNbaW5kZXhdO1xuICAgIHRoaXMuc2V0KGVudHJ5WzBdLCBlbnRyeVsxXSk7XG4gIH1cbn1cblxuLyoqXG4gKiBSZW1vdmVzIGFsbCBrZXktdmFsdWUgZW50cmllcyBmcm9tIHRoZSBsaXN0IGNhY2hlLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBjbGVhclxuICogQG1lbWJlck9mIExpc3RDYWNoZVxuICovXG5mdW5jdGlvbiBsaXN0Q2FjaGVDbGVhcigpIHtcbiAgdGhpcy5fX2RhdGFfXyA9IFtdO1xuICB0aGlzLnNpemUgPSAwO1xufVxuXG4vKipcbiAqIFJlbW92ZXMgYGtleWAgYW5kIGl0cyB2YWx1ZSBmcm9tIHRoZSBsaXN0IGNhY2hlLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBkZWxldGVcbiAqIEBtZW1iZXJPZiBMaXN0Q2FjaGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gcmVtb3ZlLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBlbnRyeSB3YXMgcmVtb3ZlZCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBsaXN0Q2FjaGVEZWxldGUoa2V5KSB7XG4gIHZhciBkYXRhID0gdGhpcy5fX2RhdGFfXyxcbiAgICAgIGluZGV4ID0gYXNzb2NJbmRleE9mKGRhdGEsIGtleSk7XG5cbiAgaWYgKGluZGV4IDwgMCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICB2YXIgbGFzdEluZGV4ID0gZGF0YS5sZW5ndGggLSAxO1xuICBpZiAoaW5kZXggPT0gbGFzdEluZGV4KSB7XG4gICAgZGF0YS5wb3AoKTtcbiAgfSBlbHNlIHtcbiAgICBzcGxpY2UuY2FsbChkYXRhLCBpbmRleCwgMSk7XG4gIH1cbiAgLS10aGlzLnNpemU7XG4gIHJldHVybiB0cnVlO1xufVxuXG4vKipcbiAqIEdldHMgdGhlIGxpc3QgY2FjaGUgdmFsdWUgZm9yIGBrZXlgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBnZXRcbiAqIEBtZW1iZXJPZiBMaXN0Q2FjaGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gZ2V0LlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGVudHJ5IHZhbHVlLlxuICovXG5mdW5jdGlvbiBsaXN0Q2FjaGVHZXQoa2V5KSB7XG4gIHZhciBkYXRhID0gdGhpcy5fX2RhdGFfXyxcbiAgICAgIGluZGV4ID0gYXNzb2NJbmRleE9mKGRhdGEsIGtleSk7XG5cbiAgcmV0dXJuIGluZGV4IDwgMCA/IHVuZGVmaW5lZCA6IGRhdGFbaW5kZXhdWzFdO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBhIGxpc3QgY2FjaGUgdmFsdWUgZm9yIGBrZXlgIGV4aXN0cy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgaGFzXG4gKiBAbWVtYmVyT2YgTGlzdENhY2hlXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIGVudHJ5IHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGFuIGVudHJ5IGZvciBga2V5YCBleGlzdHMsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gbGlzdENhY2hlSGFzKGtleSkge1xuICByZXR1cm4gYXNzb2NJbmRleE9mKHRoaXMuX19kYXRhX18sIGtleSkgPiAtMTtcbn1cblxuLyoqXG4gKiBTZXRzIHRoZSBsaXN0IGNhY2hlIGBrZXlgIHRvIGB2YWx1ZWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIHNldFxuICogQG1lbWJlck9mIExpc3RDYWNoZVxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBzZXQuXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBzZXQuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBsaXN0IGNhY2hlIGluc3RhbmNlLlxuICovXG5mdW5jdGlvbiBsaXN0Q2FjaGVTZXQoa2V5LCB2YWx1ZSkge1xuICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX18sXG4gICAgICBpbmRleCA9IGFzc29jSW5kZXhPZihkYXRhLCBrZXkpO1xuXG4gIGlmIChpbmRleCA8IDApIHtcbiAgICArK3RoaXMuc2l6ZTtcbiAgICBkYXRhLnB1c2goW2tleSwgdmFsdWVdKTtcbiAgfSBlbHNlIHtcbiAgICBkYXRhW2luZGV4XVsxXSA9IHZhbHVlO1xuICB9XG4gIHJldHVybiB0aGlzO1xufVxuXG4vLyBBZGQgbWV0aG9kcyB0byBgTGlzdENhY2hlYC5cbkxpc3RDYWNoZS5wcm90b3R5cGUuY2xlYXIgPSBsaXN0Q2FjaGVDbGVhcjtcbkxpc3RDYWNoZS5wcm90b3R5cGVbJ2RlbGV0ZSddID0gbGlzdENhY2hlRGVsZXRlO1xuTGlzdENhY2hlLnByb3RvdHlwZS5nZXQgPSBsaXN0Q2FjaGVHZXQ7XG5MaXN0Q2FjaGUucHJvdG90eXBlLmhhcyA9IGxpc3RDYWNoZUhhcztcbkxpc3RDYWNoZS5wcm90b3R5cGUuc2V0ID0gbGlzdENhY2hlU2V0O1xuXG4vKipcbiAqIENyZWF0ZXMgYSBtYXAgY2FjaGUgb2JqZWN0IHRvIHN0b3JlIGtleS12YWx1ZSBwYWlycy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge0FycmF5fSBbZW50cmllc10gVGhlIGtleS12YWx1ZSBwYWlycyB0byBjYWNoZS5cbiAqL1xuZnVuY3Rpb24gTWFwQ2FjaGUoZW50cmllcykge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IGVudHJpZXMgPT0gbnVsbCA/IDAgOiBlbnRyaWVzLmxlbmd0aDtcblxuICB0aGlzLmNsZWFyKCk7XG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgdmFyIGVudHJ5ID0gZW50cmllc1tpbmRleF07XG4gICAgdGhpcy5zZXQoZW50cnlbMF0sIGVudHJ5WzFdKTtcbiAgfVxufVxuXG4vKipcbiAqIFJlbW92ZXMgYWxsIGtleS12YWx1ZSBlbnRyaWVzIGZyb20gdGhlIG1hcC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgY2xlYXJcbiAqIEBtZW1iZXJPZiBNYXBDYWNoZVxuICovXG5mdW5jdGlvbiBtYXBDYWNoZUNsZWFyKCkge1xuICB0aGlzLnNpemUgPSAwO1xuICB0aGlzLl9fZGF0YV9fID0ge1xuICAgICdoYXNoJzogbmV3IEhhc2gsXG4gICAgJ21hcCc6IG5ldyAoTWFwIHx8IExpc3RDYWNoZSksXG4gICAgJ3N0cmluZyc6IG5ldyBIYXNoXG4gIH07XG59XG5cbi8qKlxuICogUmVtb3ZlcyBga2V5YCBhbmQgaXRzIHZhbHVlIGZyb20gdGhlIG1hcC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgZGVsZXRlXG4gKiBAbWVtYmVyT2YgTWFwQ2FjaGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gcmVtb3ZlLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBlbnRyeSB3YXMgcmVtb3ZlZCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBtYXBDYWNoZURlbGV0ZShrZXkpIHtcbiAgdmFyIHJlc3VsdCA9IGdldE1hcERhdGEodGhpcywga2V5KVsnZGVsZXRlJ10oa2V5KTtcbiAgdGhpcy5zaXplIC09IHJlc3VsdCA/IDEgOiAwO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG4vKipcbiAqIEdldHMgdGhlIG1hcCB2YWx1ZSBmb3IgYGtleWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGdldFxuICogQG1lbWJlck9mIE1hcENhY2hlXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIGdldC5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBlbnRyeSB2YWx1ZS5cbiAqL1xuZnVuY3Rpb24gbWFwQ2FjaGVHZXQoa2V5KSB7XG4gIHJldHVybiBnZXRNYXBEYXRhKHRoaXMsIGtleSkuZ2V0KGtleSk7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGEgbWFwIHZhbHVlIGZvciBga2V5YCBleGlzdHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGhhc1xuICogQG1lbWJlck9mIE1hcENhY2hlXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIGVudHJ5IHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGFuIGVudHJ5IGZvciBga2V5YCBleGlzdHMsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gbWFwQ2FjaGVIYXMoa2V5KSB7XG4gIHJldHVybiBnZXRNYXBEYXRhKHRoaXMsIGtleSkuaGFzKGtleSk7XG59XG5cbi8qKlxuICogU2V0cyB0aGUgbWFwIGBrZXlgIHRvIGB2YWx1ZWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIHNldFxuICogQG1lbWJlck9mIE1hcENhY2hlXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIHNldC5cbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHNldC5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIG1hcCBjYWNoZSBpbnN0YW5jZS5cbiAqL1xuZnVuY3Rpb24gbWFwQ2FjaGVTZXQoa2V5LCB2YWx1ZSkge1xuICB2YXIgZGF0YSA9IGdldE1hcERhdGEodGhpcywga2V5KSxcbiAgICAgIHNpemUgPSBkYXRhLnNpemU7XG5cbiAgZGF0YS5zZXQoa2V5LCB2YWx1ZSk7XG4gIHRoaXMuc2l6ZSArPSBkYXRhLnNpemUgPT0gc2l6ZSA/IDAgOiAxO1xuICByZXR1cm4gdGhpcztcbn1cblxuLy8gQWRkIG1ldGhvZHMgdG8gYE1hcENhY2hlYC5cbk1hcENhY2hlLnByb3RvdHlwZS5jbGVhciA9IG1hcENhY2hlQ2xlYXI7XG5NYXBDYWNoZS5wcm90b3R5cGVbJ2RlbGV0ZSddID0gbWFwQ2FjaGVEZWxldGU7XG5NYXBDYWNoZS5wcm90b3R5cGUuZ2V0ID0gbWFwQ2FjaGVHZXQ7XG5NYXBDYWNoZS5wcm90b3R5cGUuaGFzID0gbWFwQ2FjaGVIYXM7XG5NYXBDYWNoZS5wcm90b3R5cGUuc2V0ID0gbWFwQ2FjaGVTZXQ7XG5cbi8qKlxuICpcbiAqIENyZWF0ZXMgYW4gYXJyYXkgY2FjaGUgb2JqZWN0IHRvIHN0b3JlIHVuaXF1ZSB2YWx1ZXMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtBcnJheX0gW3ZhbHVlc10gVGhlIHZhbHVlcyB0byBjYWNoZS5cbiAqL1xuZnVuY3Rpb24gU2V0Q2FjaGUodmFsdWVzKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gdmFsdWVzID09IG51bGwgPyAwIDogdmFsdWVzLmxlbmd0aDtcblxuICB0aGlzLl9fZGF0YV9fID0gbmV3IE1hcENhY2hlO1xuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIHRoaXMuYWRkKHZhbHVlc1tpbmRleF0pO1xuICB9XG59XG5cbi8qKlxuICogQWRkcyBgdmFsdWVgIHRvIHRoZSBhcnJheSBjYWNoZS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgYWRkXG4gKiBAbWVtYmVyT2YgU2V0Q2FjaGVcbiAqIEBhbGlhcyBwdXNoXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjYWNoZS5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGNhY2hlIGluc3RhbmNlLlxuICovXG5mdW5jdGlvbiBzZXRDYWNoZUFkZCh2YWx1ZSkge1xuICB0aGlzLl9fZGF0YV9fLnNldCh2YWx1ZSwgSEFTSF9VTkRFRklORUQpO1xuICByZXR1cm4gdGhpcztcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBpbiB0aGUgYXJyYXkgY2FjaGUuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGhhc1xuICogQG1lbWJlck9mIFNldENhY2hlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBzZWFyY2ggZm9yLlxuICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBmb3VuZCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBzZXRDYWNoZUhhcyh2YWx1ZSkge1xuICByZXR1cm4gdGhpcy5fX2RhdGFfXy5oYXModmFsdWUpO1xufVxuXG4vLyBBZGQgbWV0aG9kcyB0byBgU2V0Q2FjaGVgLlxuU2V0Q2FjaGUucHJvdG90eXBlLmFkZCA9IFNldENhY2hlLnByb3RvdHlwZS5wdXNoID0gc2V0Q2FjaGVBZGQ7XG5TZXRDYWNoZS5wcm90b3R5cGUuaGFzID0gc2V0Q2FjaGVIYXM7XG5cbi8qKlxuICogQ3JlYXRlcyBhIHN0YWNrIGNhY2hlIG9iamVjdCB0byBzdG9yZSBrZXktdmFsdWUgcGFpcnMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtBcnJheX0gW2VudHJpZXNdIFRoZSBrZXktdmFsdWUgcGFpcnMgdG8gY2FjaGUuXG4gKi9cbmZ1bmN0aW9uIFN0YWNrKGVudHJpZXMpIHtcbiAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fID0gbmV3IExpc3RDYWNoZShlbnRyaWVzKTtcbiAgdGhpcy5zaXplID0gZGF0YS5zaXplO1xufVxuXG4vKipcbiAqIFJlbW92ZXMgYWxsIGtleS12YWx1ZSBlbnRyaWVzIGZyb20gdGhlIHN0YWNrLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBjbGVhclxuICogQG1lbWJlck9mIFN0YWNrXG4gKi9cbmZ1bmN0aW9uIHN0YWNrQ2xlYXIoKSB7XG4gIHRoaXMuX19kYXRhX18gPSBuZXcgTGlzdENhY2hlO1xuICB0aGlzLnNpemUgPSAwO1xufVxuXG4vKipcbiAqIFJlbW92ZXMgYGtleWAgYW5kIGl0cyB2YWx1ZSBmcm9tIHRoZSBzdGFjay5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgZGVsZXRlXG4gKiBAbWVtYmVyT2YgU3RhY2tcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gcmVtb3ZlLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBlbnRyeSB3YXMgcmVtb3ZlZCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBzdGFja0RlbGV0ZShrZXkpIHtcbiAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fLFxuICAgICAgcmVzdWx0ID0gZGF0YVsnZGVsZXRlJ10oa2V5KTtcblxuICB0aGlzLnNpemUgPSBkYXRhLnNpemU7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbi8qKlxuICogR2V0cyB0aGUgc3RhY2sgdmFsdWUgZm9yIGBrZXlgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBnZXRcbiAqIEBtZW1iZXJPZiBTdGFja1xuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBnZXQuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgZW50cnkgdmFsdWUuXG4gKi9cbmZ1bmN0aW9uIHN0YWNrR2V0KGtleSkge1xuICByZXR1cm4gdGhpcy5fX2RhdGFfXy5nZXQoa2V5KTtcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYSBzdGFjayB2YWx1ZSBmb3IgYGtleWAgZXhpc3RzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBoYXNcbiAqIEBtZW1iZXJPZiBTdGFja1xuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBlbnRyeSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBhbiBlbnRyeSBmb3IgYGtleWAgZXhpc3RzLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIHN0YWNrSGFzKGtleSkge1xuICByZXR1cm4gdGhpcy5fX2RhdGFfXy5oYXMoa2V5KTtcbn1cblxuLyoqXG4gKiBTZXRzIHRoZSBzdGFjayBga2V5YCB0byBgdmFsdWVgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBzZXRcbiAqIEBtZW1iZXJPZiBTdGFja1xuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBzZXQuXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBzZXQuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBzdGFjayBjYWNoZSBpbnN0YW5jZS5cbiAqL1xuZnVuY3Rpb24gc3RhY2tTZXQoa2V5LCB2YWx1ZSkge1xuICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX187XG4gIGlmIChkYXRhIGluc3RhbmNlb2YgTGlzdENhY2hlKSB7XG4gICAgdmFyIHBhaXJzID0gZGF0YS5fX2RhdGFfXztcbiAgICBpZiAoIU1hcCB8fCAocGFpcnMubGVuZ3RoIDwgTEFSR0VfQVJSQVlfU0laRSAtIDEpKSB7XG4gICAgICBwYWlycy5wdXNoKFtrZXksIHZhbHVlXSk7XG4gICAgICB0aGlzLnNpemUgPSArK2RhdGEuc2l6ZTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBkYXRhID0gdGhpcy5fX2RhdGFfXyA9IG5ldyBNYXBDYWNoZShwYWlycyk7XG4gIH1cbiAgZGF0YS5zZXQoa2V5LCB2YWx1ZSk7XG4gIHRoaXMuc2l6ZSA9IGRhdGEuc2l6ZTtcbiAgcmV0dXJuIHRoaXM7XG59XG5cbi8vIEFkZCBtZXRob2RzIHRvIGBTdGFja2AuXG5TdGFjay5wcm90b3R5cGUuY2xlYXIgPSBzdGFja0NsZWFyO1xuU3RhY2sucHJvdG90eXBlWydkZWxldGUnXSA9IHN0YWNrRGVsZXRlO1xuU3RhY2sucHJvdG90eXBlLmdldCA9IHN0YWNrR2V0O1xuU3RhY2sucHJvdG90eXBlLmhhcyA9IHN0YWNrSGFzO1xuU3RhY2sucHJvdG90eXBlLnNldCA9IHN0YWNrU2V0O1xuXG4vKipcbiAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgdGhlIGVudW1lcmFibGUgcHJvcGVydHkgbmFtZXMgb2YgdGhlIGFycmF5LWxpa2UgYHZhbHVlYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcXVlcnkuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IGluaGVyaXRlZCBTcGVjaWZ5IHJldHVybmluZyBpbmhlcml0ZWQgcHJvcGVydHkgbmFtZXMuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHByb3BlcnR5IG5hbWVzLlxuICovXG5mdW5jdGlvbiBhcnJheUxpa2VLZXlzKHZhbHVlLCBpbmhlcml0ZWQpIHtcbiAgdmFyIGlzQXJyID0gaXNBcnJheSh2YWx1ZSksXG4gICAgICBpc0FyZyA9ICFpc0FyciAmJiBpc0FyZ3VtZW50cyh2YWx1ZSksXG4gICAgICBpc0J1ZmYgPSAhaXNBcnIgJiYgIWlzQXJnICYmIGlzQnVmZmVyKHZhbHVlKSxcbiAgICAgIGlzVHlwZSA9ICFpc0FyciAmJiAhaXNBcmcgJiYgIWlzQnVmZiAmJiBpc1R5cGVkQXJyYXkodmFsdWUpLFxuICAgICAgc2tpcEluZGV4ZXMgPSBpc0FyciB8fCBpc0FyZyB8fCBpc0J1ZmYgfHwgaXNUeXBlLFxuICAgICAgcmVzdWx0ID0gc2tpcEluZGV4ZXMgPyBiYXNlVGltZXModmFsdWUubGVuZ3RoLCBTdHJpbmcpIDogW10sXG4gICAgICBsZW5ndGggPSByZXN1bHQubGVuZ3RoO1xuXG4gIGZvciAodmFyIGtleSBpbiB2YWx1ZSkge1xuICAgIGlmICgoaW5oZXJpdGVkIHx8IGhhc093blByb3BlcnR5LmNhbGwodmFsdWUsIGtleSkpICYmXG4gICAgICAgICEoc2tpcEluZGV4ZXMgJiYgKFxuICAgICAgICAgICAvLyBTYWZhcmkgOSBoYXMgZW51bWVyYWJsZSBgYXJndW1lbnRzLmxlbmd0aGAgaW4gc3RyaWN0IG1vZGUuXG4gICAgICAgICAgIGtleSA9PSAnbGVuZ3RoJyB8fFxuICAgICAgICAgICAvLyBOb2RlLmpzIDAuMTAgaGFzIGVudW1lcmFibGUgbm9uLWluZGV4IHByb3BlcnRpZXMgb24gYnVmZmVycy5cbiAgICAgICAgICAgKGlzQnVmZiAmJiAoa2V5ID09ICdvZmZzZXQnIHx8IGtleSA9PSAncGFyZW50JykpIHx8XG4gICAgICAgICAgIC8vIFBoYW50b21KUyAyIGhhcyBlbnVtZXJhYmxlIG5vbi1pbmRleCBwcm9wZXJ0aWVzIG9uIHR5cGVkIGFycmF5cy5cbiAgICAgICAgICAgKGlzVHlwZSAmJiAoa2V5ID09ICdidWZmZXInIHx8IGtleSA9PSAnYnl0ZUxlbmd0aCcgfHwga2V5ID09ICdieXRlT2Zmc2V0JykpIHx8XG4gICAgICAgICAgIC8vIFNraXAgaW5kZXggcHJvcGVydGllcy5cbiAgICAgICAgICAgaXNJbmRleChrZXksIGxlbmd0aClcbiAgICAgICAgKSkpIHtcbiAgICAgIHJlc3VsdC5wdXNoKGtleSk7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbi8qKlxuICogR2V0cyB0aGUgaW5kZXggYXQgd2hpY2ggdGhlIGBrZXlgIGlzIGZvdW5kIGluIGBhcnJheWAgb2Yga2V5LXZhbHVlIHBhaXJzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaW5zcGVjdC5cbiAqIEBwYXJhbSB7Kn0ga2V5IFRoZSBrZXkgdG8gc2VhcmNoIGZvci5cbiAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIGluZGV4IG9mIHRoZSBtYXRjaGVkIHZhbHVlLCBlbHNlIGAtMWAuXG4gKi9cbmZ1bmN0aW9uIGFzc29jSW5kZXhPZihhcnJheSwga2V5KSB7XG4gIHZhciBsZW5ndGggPSBhcnJheS5sZW5ndGg7XG4gIHdoaWxlIChsZW5ndGgtLSkge1xuICAgIGlmIChlcShhcnJheVtsZW5ndGhdWzBdLCBrZXkpKSB7XG4gICAgICByZXR1cm4gbGVuZ3RoO1xuICAgIH1cbiAgfVxuICByZXR1cm4gLTE7XG59XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYGdldEFsbEtleXNgIGFuZCBgZ2V0QWxsS2V5c0luYCB3aGljaCB1c2VzXG4gKiBga2V5c0Z1bmNgIGFuZCBgc3ltYm9sc0Z1bmNgIHRvIGdldCB0aGUgZW51bWVyYWJsZSBwcm9wZXJ0eSBuYW1lcyBhbmRcbiAqIHN5bWJvbHMgb2YgYG9iamVjdGAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGtleXNGdW5jIFRoZSBmdW5jdGlvbiB0byBnZXQgdGhlIGtleXMgb2YgYG9iamVjdGAuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBzeW1ib2xzRnVuYyBUaGUgZnVuY3Rpb24gdG8gZ2V0IHRoZSBzeW1ib2xzIG9mIGBvYmplY3RgLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBwcm9wZXJ0eSBuYW1lcyBhbmQgc3ltYm9scy5cbiAqL1xuZnVuY3Rpb24gYmFzZUdldEFsbEtleXMob2JqZWN0LCBrZXlzRnVuYywgc3ltYm9sc0Z1bmMpIHtcbiAgdmFyIHJlc3VsdCA9IGtleXNGdW5jKG9iamVjdCk7XG4gIHJldHVybiBpc0FycmF5KG9iamVjdCkgPyByZXN1bHQgOiBhcnJheVB1c2gocmVzdWx0LCBzeW1ib2xzRnVuYyhvYmplY3QpKTtcbn1cblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgZ2V0VGFnYCB3aXRob3V0IGZhbGxiYWNrcyBmb3IgYnVnZ3kgZW52aXJvbm1lbnRzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIGB0b1N0cmluZ1RhZ2AuXG4gKi9cbmZ1bmN0aW9uIGJhc2VHZXRUYWcodmFsdWUpIHtcbiAgaWYgKHZhbHVlID09IG51bGwpIHtcbiAgICByZXR1cm4gdmFsdWUgPT09IHVuZGVmaW5lZCA/IHVuZGVmaW5lZFRhZyA6IG51bGxUYWc7XG4gIH1cbiAgcmV0dXJuIChzeW1Ub1N0cmluZ1RhZyAmJiBzeW1Ub1N0cmluZ1RhZyBpbiBPYmplY3QodmFsdWUpKVxuICAgID8gZ2V0UmF3VGFnKHZhbHVlKVxuICAgIDogb2JqZWN0VG9TdHJpbmcodmFsdWUpO1xufVxuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmlzQXJndW1lbnRzYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhbiBgYXJndW1lbnRzYCBvYmplY3QsXG4gKi9cbmZ1bmN0aW9uIGJhc2VJc0FyZ3VtZW50cyh2YWx1ZSkge1xuICByZXR1cm4gaXNPYmplY3RMaWtlKHZhbHVlKSAmJiBiYXNlR2V0VGFnKHZhbHVlKSA9PSBhcmdzVGFnO1xufVxuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmlzRXF1YWxgIHdoaWNoIHN1cHBvcnRzIHBhcnRpYWwgY29tcGFyaXNvbnNcbiAqIGFuZCB0cmFja3MgdHJhdmVyc2VkIG9iamVjdHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNvbXBhcmUuXG4gKiBAcGFyYW0geyp9IG90aGVyIFRoZSBvdGhlciB2YWx1ZSB0byBjb21wYXJlLlxuICogQHBhcmFtIHtib29sZWFufSBiaXRtYXNrIFRoZSBiaXRtYXNrIGZsYWdzLlxuICogIDEgLSBVbm9yZGVyZWQgY29tcGFyaXNvblxuICogIDIgLSBQYXJ0aWFsIGNvbXBhcmlzb25cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjdXN0b21pemVyXSBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIGNvbXBhcmlzb25zLlxuICogQHBhcmFtIHtPYmplY3R9IFtzdGFja10gVHJhY2tzIHRyYXZlcnNlZCBgdmFsdWVgIGFuZCBgb3RoZXJgIG9iamVjdHMuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIHZhbHVlcyBhcmUgZXF1aXZhbGVudCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBiYXNlSXNFcXVhbCh2YWx1ZSwgb3RoZXIsIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIHN0YWNrKSB7XG4gIGlmICh2YWx1ZSA9PT0gb3RoZXIpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBpZiAodmFsdWUgPT0gbnVsbCB8fCBvdGhlciA9PSBudWxsIHx8ICghaXNPYmplY3RMaWtlKHZhbHVlKSAmJiAhaXNPYmplY3RMaWtlKG90aGVyKSkpIHtcbiAgICByZXR1cm4gdmFsdWUgIT09IHZhbHVlICYmIG90aGVyICE9PSBvdGhlcjtcbiAgfVxuICByZXR1cm4gYmFzZUlzRXF1YWxEZWVwKHZhbHVlLCBvdGhlciwgYml0bWFzaywgY3VzdG9taXplciwgYmFzZUlzRXF1YWwsIHN0YWNrKTtcbn1cblxuLyoqXG4gKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYGJhc2VJc0VxdWFsYCBmb3IgYXJyYXlzIGFuZCBvYmplY3RzIHdoaWNoIHBlcmZvcm1zXG4gKiBkZWVwIGNvbXBhcmlzb25zIGFuZCB0cmFja3MgdHJhdmVyc2VkIG9iamVjdHMgZW5hYmxpbmcgb2JqZWN0cyB3aXRoIGNpcmN1bGFyXG4gKiByZWZlcmVuY2VzIHRvIGJlIGNvbXBhcmVkLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gY29tcGFyZS5cbiAqIEBwYXJhbSB7T2JqZWN0fSBvdGhlciBUaGUgb3RoZXIgb2JqZWN0IHRvIGNvbXBhcmUuXG4gKiBAcGFyYW0ge251bWJlcn0gYml0bWFzayBUaGUgYml0bWFzayBmbGFncy4gU2VlIGBiYXNlSXNFcXVhbGAgZm9yIG1vcmUgZGV0YWlscy5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGN1c3RvbWl6ZXIgVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBjb21wYXJpc29ucy5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGVxdWFsRnVuYyBUaGUgZnVuY3Rpb24gdG8gZGV0ZXJtaW5lIGVxdWl2YWxlbnRzIG9mIHZhbHVlcy5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbc3RhY2tdIFRyYWNrcyB0cmF2ZXJzZWQgYG9iamVjdGAgYW5kIGBvdGhlcmAgb2JqZWN0cy5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgb2JqZWN0cyBhcmUgZXF1aXZhbGVudCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBiYXNlSXNFcXVhbERlZXAob2JqZWN0LCBvdGhlciwgYml0bWFzaywgY3VzdG9taXplciwgZXF1YWxGdW5jLCBzdGFjaykge1xuICB2YXIgb2JqSXNBcnIgPSBpc0FycmF5KG9iamVjdCksXG4gICAgICBvdGhJc0FyciA9IGlzQXJyYXkob3RoZXIpLFxuICAgICAgb2JqVGFnID0gb2JqSXNBcnIgPyBhcnJheVRhZyA6IGdldFRhZyhvYmplY3QpLFxuICAgICAgb3RoVGFnID0gb3RoSXNBcnIgPyBhcnJheVRhZyA6IGdldFRhZyhvdGhlcik7XG5cbiAgb2JqVGFnID0gb2JqVGFnID09IGFyZ3NUYWcgPyBvYmplY3RUYWcgOiBvYmpUYWc7XG4gIG90aFRhZyA9IG90aFRhZyA9PSBhcmdzVGFnID8gb2JqZWN0VGFnIDogb3RoVGFnO1xuXG4gIHZhciBvYmpJc09iaiA9IG9ialRhZyA9PSBvYmplY3RUYWcsXG4gICAgICBvdGhJc09iaiA9IG90aFRhZyA9PSBvYmplY3RUYWcsXG4gICAgICBpc1NhbWVUYWcgPSBvYmpUYWcgPT0gb3RoVGFnO1xuXG4gIGlmIChpc1NhbWVUYWcgJiYgaXNCdWZmZXIob2JqZWN0KSkge1xuICAgIGlmICghaXNCdWZmZXIob3RoZXIpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIG9iaklzQXJyID0gdHJ1ZTtcbiAgICBvYmpJc09iaiA9IGZhbHNlO1xuICB9XG4gIGlmIChpc1NhbWVUYWcgJiYgIW9iaklzT2JqKSB7XG4gICAgc3RhY2sgfHwgKHN0YWNrID0gbmV3IFN0YWNrKTtcbiAgICByZXR1cm4gKG9iaklzQXJyIHx8IGlzVHlwZWRBcnJheShvYmplY3QpKVxuICAgICAgPyBlcXVhbEFycmF5cyhvYmplY3QsIG90aGVyLCBiaXRtYXNrLCBjdXN0b21pemVyLCBlcXVhbEZ1bmMsIHN0YWNrKVxuICAgICAgOiBlcXVhbEJ5VGFnKG9iamVjdCwgb3RoZXIsIG9ialRhZywgYml0bWFzaywgY3VzdG9taXplciwgZXF1YWxGdW5jLCBzdGFjayk7XG4gIH1cbiAgaWYgKCEoYml0bWFzayAmIENPTVBBUkVfUEFSVElBTF9GTEFHKSkge1xuICAgIHZhciBvYmpJc1dyYXBwZWQgPSBvYmpJc09iaiAmJiBoYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwgJ19fd3JhcHBlZF9fJyksXG4gICAgICAgIG90aElzV3JhcHBlZCA9IG90aElzT2JqICYmIGhhc093blByb3BlcnR5LmNhbGwob3RoZXIsICdfX3dyYXBwZWRfXycpO1xuXG4gICAgaWYgKG9iaklzV3JhcHBlZCB8fCBvdGhJc1dyYXBwZWQpIHtcbiAgICAgIHZhciBvYmpVbndyYXBwZWQgPSBvYmpJc1dyYXBwZWQgPyBvYmplY3QudmFsdWUoKSA6IG9iamVjdCxcbiAgICAgICAgICBvdGhVbndyYXBwZWQgPSBvdGhJc1dyYXBwZWQgPyBvdGhlci52YWx1ZSgpIDogb3RoZXI7XG5cbiAgICAgIHN0YWNrIHx8IChzdGFjayA9IG5ldyBTdGFjayk7XG4gICAgICByZXR1cm4gZXF1YWxGdW5jKG9ialVud3JhcHBlZCwgb3RoVW53cmFwcGVkLCBiaXRtYXNrLCBjdXN0b21pemVyLCBzdGFjayk7XG4gICAgfVxuICB9XG4gIGlmICghaXNTYW1lVGFnKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHN0YWNrIHx8IChzdGFjayA9IG5ldyBTdGFjayk7XG4gIHJldHVybiBlcXVhbE9iamVjdHMob2JqZWN0LCBvdGhlciwgYml0bWFzaywgY3VzdG9taXplciwgZXF1YWxGdW5jLCBzdGFjayk7XG59XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uaXNOYXRpdmVgIHdpdGhvdXQgYmFkIHNoaW0gY2hlY2tzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgbmF0aXZlIGZ1bmN0aW9uLFxuICogIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gYmFzZUlzTmF0aXZlKHZhbHVlKSB7XG4gIGlmICghaXNPYmplY3QodmFsdWUpIHx8IGlzTWFza2VkKHZhbHVlKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICB2YXIgcGF0dGVybiA9IGlzRnVuY3Rpb24odmFsdWUpID8gcmVJc05hdGl2ZSA6IHJlSXNIb3N0Q3RvcjtcbiAgcmV0dXJuIHBhdHRlcm4udGVzdCh0b1NvdXJjZSh2YWx1ZSkpO1xufVxuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmlzVHlwZWRBcnJheWAgd2l0aG91dCBOb2RlLmpzIG9wdGltaXphdGlvbnMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSB0eXBlZCBhcnJheSwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBiYXNlSXNUeXBlZEFycmF5KHZhbHVlKSB7XG4gIHJldHVybiBpc09iamVjdExpa2UodmFsdWUpICYmXG4gICAgaXNMZW5ndGgodmFsdWUubGVuZ3RoKSAmJiAhIXR5cGVkQXJyYXlUYWdzW2Jhc2VHZXRUYWcodmFsdWUpXTtcbn1cblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5rZXlzYCB3aGljaCBkb2Vzbid0IHRyZWF0IHNwYXJzZSBhcnJheXMgYXMgZGVuc2UuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgbmFtZXMuXG4gKi9cbmZ1bmN0aW9uIGJhc2VLZXlzKG9iamVjdCkge1xuICBpZiAoIWlzUHJvdG90eXBlKG9iamVjdCkpIHtcbiAgICByZXR1cm4gbmF0aXZlS2V5cyhvYmplY3QpO1xuICB9XG4gIHZhciByZXN1bHQgPSBbXTtcbiAgZm9yICh2YXIga2V5IGluIE9iamVjdChvYmplY3QpKSB7XG4gICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBrZXkpICYmIGtleSAhPSAnY29uc3RydWN0b3InKSB7XG4gICAgICByZXN1bHQucHVzaChrZXkpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG4vKipcbiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgYmFzZUlzRXF1YWxEZWVwYCBmb3IgYXJyYXlzIHdpdGggc3VwcG9ydCBmb3JcbiAqIHBhcnRpYWwgZGVlcCBjb21wYXJpc29ucy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGNvbXBhcmUuXG4gKiBAcGFyYW0ge0FycmF5fSBvdGhlciBUaGUgb3RoZXIgYXJyYXkgdG8gY29tcGFyZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBiaXRtYXNrIFRoZSBiaXRtYXNrIGZsYWdzLiBTZWUgYGJhc2VJc0VxdWFsYCBmb3IgbW9yZSBkZXRhaWxzLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gY3VzdG9taXplciBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIGNvbXBhcmlzb25zLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZXF1YWxGdW5jIFRoZSBmdW5jdGlvbiB0byBkZXRlcm1pbmUgZXF1aXZhbGVudHMgb2YgdmFsdWVzLlxuICogQHBhcmFtIHtPYmplY3R9IHN0YWNrIFRyYWNrcyB0cmF2ZXJzZWQgYGFycmF5YCBhbmQgYG90aGVyYCBvYmplY3RzLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBhcnJheXMgYXJlIGVxdWl2YWxlbnQsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gZXF1YWxBcnJheXMoYXJyYXksIG90aGVyLCBiaXRtYXNrLCBjdXN0b21pemVyLCBlcXVhbEZ1bmMsIHN0YWNrKSB7XG4gIHZhciBpc1BhcnRpYWwgPSBiaXRtYXNrICYgQ09NUEFSRV9QQVJUSUFMX0ZMQUcsXG4gICAgICBhcnJMZW5ndGggPSBhcnJheS5sZW5ndGgsXG4gICAgICBvdGhMZW5ndGggPSBvdGhlci5sZW5ndGg7XG5cbiAgaWYgKGFyckxlbmd0aCAhPSBvdGhMZW5ndGggJiYgIShpc1BhcnRpYWwgJiYgb3RoTGVuZ3RoID4gYXJyTGVuZ3RoKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICAvLyBBc3N1bWUgY3ljbGljIHZhbHVlcyBhcmUgZXF1YWwuXG4gIHZhciBzdGFja2VkID0gc3RhY2suZ2V0KGFycmF5KTtcbiAgaWYgKHN0YWNrZWQgJiYgc3RhY2suZ2V0KG90aGVyKSkge1xuICAgIHJldHVybiBzdGFja2VkID09IG90aGVyO1xuICB9XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgcmVzdWx0ID0gdHJ1ZSxcbiAgICAgIHNlZW4gPSAoYml0bWFzayAmIENPTVBBUkVfVU5PUkRFUkVEX0ZMQUcpID8gbmV3IFNldENhY2hlIDogdW5kZWZpbmVkO1xuXG4gIHN0YWNrLnNldChhcnJheSwgb3RoZXIpO1xuICBzdGFjay5zZXQob3RoZXIsIGFycmF5KTtcblxuICAvLyBJZ25vcmUgbm9uLWluZGV4IHByb3BlcnRpZXMuXG4gIHdoaWxlICgrK2luZGV4IDwgYXJyTGVuZ3RoKSB7XG4gICAgdmFyIGFyclZhbHVlID0gYXJyYXlbaW5kZXhdLFxuICAgICAgICBvdGhWYWx1ZSA9IG90aGVyW2luZGV4XTtcblxuICAgIGlmIChjdXN0b21pemVyKSB7XG4gICAgICB2YXIgY29tcGFyZWQgPSBpc1BhcnRpYWxcbiAgICAgICAgPyBjdXN0b21pemVyKG90aFZhbHVlLCBhcnJWYWx1ZSwgaW5kZXgsIG90aGVyLCBhcnJheSwgc3RhY2spXG4gICAgICAgIDogY3VzdG9taXplcihhcnJWYWx1ZSwgb3RoVmFsdWUsIGluZGV4LCBhcnJheSwgb3RoZXIsIHN0YWNrKTtcbiAgICB9XG4gICAgaWYgKGNvbXBhcmVkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGlmIChjb21wYXJlZCkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIHJlc3VsdCA9IGZhbHNlO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIC8vIFJlY3Vyc2l2ZWx5IGNvbXBhcmUgYXJyYXlzIChzdXNjZXB0aWJsZSB0byBjYWxsIHN0YWNrIGxpbWl0cykuXG4gICAgaWYgKHNlZW4pIHtcbiAgICAgIGlmICghYXJyYXlTb21lKG90aGVyLCBmdW5jdGlvbihvdGhWYWx1ZSwgb3RoSW5kZXgpIHtcbiAgICAgICAgICAgIGlmICghY2FjaGVIYXMoc2Vlbiwgb3RoSW5kZXgpICYmXG4gICAgICAgICAgICAgICAgKGFyclZhbHVlID09PSBvdGhWYWx1ZSB8fCBlcXVhbEZ1bmMoYXJyVmFsdWUsIG90aFZhbHVlLCBiaXRtYXNrLCBjdXN0b21pemVyLCBzdGFjaykpKSB7XG4gICAgICAgICAgICAgIHJldHVybiBzZWVuLnB1c2gob3RoSW5kZXgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pKSB7XG4gICAgICAgIHJlc3VsdCA9IGZhbHNlO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKCEoXG4gICAgICAgICAgYXJyVmFsdWUgPT09IG90aFZhbHVlIHx8XG4gICAgICAgICAgICBlcXVhbEZ1bmMoYXJyVmFsdWUsIG90aFZhbHVlLCBiaXRtYXNrLCBjdXN0b21pemVyLCBzdGFjaylcbiAgICAgICAgKSkge1xuICAgICAgcmVzdWx0ID0gZmFsc2U7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cbiAgc3RhY2tbJ2RlbGV0ZSddKGFycmF5KTtcbiAgc3RhY2tbJ2RlbGV0ZSddKG90aGVyKTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqXG4gKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYGJhc2VJc0VxdWFsRGVlcGAgZm9yIGNvbXBhcmluZyBvYmplY3RzIG9mXG4gKiB0aGUgc2FtZSBgdG9TdHJpbmdUYWdgLlxuICpcbiAqICoqTm90ZToqKiBUaGlzIGZ1bmN0aW9uIG9ubHkgc3VwcG9ydHMgY29tcGFyaW5nIHZhbHVlcyB3aXRoIHRhZ3Mgb2ZcbiAqIGBCb29sZWFuYCwgYERhdGVgLCBgRXJyb3JgLCBgTnVtYmVyYCwgYFJlZ0V4cGAsIG9yIGBTdHJpbmdgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gY29tcGFyZS5cbiAqIEBwYXJhbSB7T2JqZWN0fSBvdGhlciBUaGUgb3RoZXIgb2JqZWN0IHRvIGNvbXBhcmUuXG4gKiBAcGFyYW0ge3N0cmluZ30gdGFnIFRoZSBgdG9TdHJpbmdUYWdgIG9mIHRoZSBvYmplY3RzIHRvIGNvbXBhcmUuXG4gKiBAcGFyYW0ge251bWJlcn0gYml0bWFzayBUaGUgYml0bWFzayBmbGFncy4gU2VlIGBiYXNlSXNFcXVhbGAgZm9yIG1vcmUgZGV0YWlscy5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGN1c3RvbWl6ZXIgVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBjb21wYXJpc29ucy5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGVxdWFsRnVuYyBUaGUgZnVuY3Rpb24gdG8gZGV0ZXJtaW5lIGVxdWl2YWxlbnRzIG9mIHZhbHVlcy5cbiAqIEBwYXJhbSB7T2JqZWN0fSBzdGFjayBUcmFja3MgdHJhdmVyc2VkIGBvYmplY3RgIGFuZCBgb3RoZXJgIG9iamVjdHMuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIG9iamVjdHMgYXJlIGVxdWl2YWxlbnQsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gZXF1YWxCeVRhZyhvYmplY3QsIG90aGVyLCB0YWcsIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIGVxdWFsRnVuYywgc3RhY2spIHtcbiAgc3dpdGNoICh0YWcpIHtcbiAgICBjYXNlIGRhdGFWaWV3VGFnOlxuICAgICAgaWYgKChvYmplY3QuYnl0ZUxlbmd0aCAhPSBvdGhlci5ieXRlTGVuZ3RoKSB8fFxuICAgICAgICAgIChvYmplY3QuYnl0ZU9mZnNldCAhPSBvdGhlci5ieXRlT2Zmc2V0KSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICBvYmplY3QgPSBvYmplY3QuYnVmZmVyO1xuICAgICAgb3RoZXIgPSBvdGhlci5idWZmZXI7XG5cbiAgICBjYXNlIGFycmF5QnVmZmVyVGFnOlxuICAgICAgaWYgKChvYmplY3QuYnl0ZUxlbmd0aCAhPSBvdGhlci5ieXRlTGVuZ3RoKSB8fFxuICAgICAgICAgICFlcXVhbEZ1bmMobmV3IFVpbnQ4QXJyYXkob2JqZWN0KSwgbmV3IFVpbnQ4QXJyYXkob3RoZXIpKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICByZXR1cm4gdHJ1ZTtcblxuICAgIGNhc2UgYm9vbFRhZzpcbiAgICBjYXNlIGRhdGVUYWc6XG4gICAgY2FzZSBudW1iZXJUYWc6XG4gICAgICAvLyBDb2VyY2UgYm9vbGVhbnMgdG8gYDFgIG9yIGAwYCBhbmQgZGF0ZXMgdG8gbWlsbGlzZWNvbmRzLlxuICAgICAgLy8gSW52YWxpZCBkYXRlcyBhcmUgY29lcmNlZCB0byBgTmFOYC5cbiAgICAgIHJldHVybiBlcSgrb2JqZWN0LCArb3RoZXIpO1xuXG4gICAgY2FzZSBlcnJvclRhZzpcbiAgICAgIHJldHVybiBvYmplY3QubmFtZSA9PSBvdGhlci5uYW1lICYmIG9iamVjdC5tZXNzYWdlID09IG90aGVyLm1lc3NhZ2U7XG5cbiAgICBjYXNlIHJlZ2V4cFRhZzpcbiAgICBjYXNlIHN0cmluZ1RhZzpcbiAgICAgIC8vIENvZXJjZSByZWdleGVzIHRvIHN0cmluZ3MgYW5kIHRyZWF0IHN0cmluZ3MsIHByaW1pdGl2ZXMgYW5kIG9iamVjdHMsXG4gICAgICAvLyBhcyBlcXVhbC4gU2VlIGh0dHA6Ly93d3cuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1yZWdleHAucHJvdG90eXBlLnRvc3RyaW5nXG4gICAgICAvLyBmb3IgbW9yZSBkZXRhaWxzLlxuICAgICAgcmV0dXJuIG9iamVjdCA9PSAob3RoZXIgKyAnJyk7XG5cbiAgICBjYXNlIG1hcFRhZzpcbiAgICAgIHZhciBjb252ZXJ0ID0gbWFwVG9BcnJheTtcblxuICAgIGNhc2Ugc2V0VGFnOlxuICAgICAgdmFyIGlzUGFydGlhbCA9IGJpdG1hc2sgJiBDT01QQVJFX1BBUlRJQUxfRkxBRztcbiAgICAgIGNvbnZlcnQgfHwgKGNvbnZlcnQgPSBzZXRUb0FycmF5KTtcblxuICAgICAgaWYgKG9iamVjdC5zaXplICE9IG90aGVyLnNpemUgJiYgIWlzUGFydGlhbCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICAvLyBBc3N1bWUgY3ljbGljIHZhbHVlcyBhcmUgZXF1YWwuXG4gICAgICB2YXIgc3RhY2tlZCA9IHN0YWNrLmdldChvYmplY3QpO1xuICAgICAgaWYgKHN0YWNrZWQpIHtcbiAgICAgICAgcmV0dXJuIHN0YWNrZWQgPT0gb3RoZXI7XG4gICAgICB9XG4gICAgICBiaXRtYXNrIHw9IENPTVBBUkVfVU5PUkRFUkVEX0ZMQUc7XG5cbiAgICAgIC8vIFJlY3Vyc2l2ZWx5IGNvbXBhcmUgb2JqZWN0cyAoc3VzY2VwdGlibGUgdG8gY2FsbCBzdGFjayBsaW1pdHMpLlxuICAgICAgc3RhY2suc2V0KG9iamVjdCwgb3RoZXIpO1xuICAgICAgdmFyIHJlc3VsdCA9IGVxdWFsQXJyYXlzKGNvbnZlcnQob2JqZWN0KSwgY29udmVydChvdGhlciksIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIGVxdWFsRnVuYywgc3RhY2spO1xuICAgICAgc3RhY2tbJ2RlbGV0ZSddKG9iamVjdCk7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuXG4gICAgY2FzZSBzeW1ib2xUYWc6XG4gICAgICBpZiAoc3ltYm9sVmFsdWVPZikge1xuICAgICAgICByZXR1cm4gc3ltYm9sVmFsdWVPZi5jYWxsKG9iamVjdCkgPT0gc3ltYm9sVmFsdWVPZi5jYWxsKG90aGVyKTtcbiAgICAgIH1cbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5cbi8qKlxuICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBiYXNlSXNFcXVhbERlZXBgIGZvciBvYmplY3RzIHdpdGggc3VwcG9ydCBmb3JcbiAqIHBhcnRpYWwgZGVlcCBjb21wYXJpc29ucy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGNvbXBhcmUuXG4gKiBAcGFyYW0ge09iamVjdH0gb3RoZXIgVGhlIG90aGVyIG9iamVjdCB0byBjb21wYXJlLlxuICogQHBhcmFtIHtudW1iZXJ9IGJpdG1hc2sgVGhlIGJpdG1hc2sgZmxhZ3MuIFNlZSBgYmFzZUlzRXF1YWxgIGZvciBtb3JlIGRldGFpbHMuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjdXN0b21pemVyIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgY29tcGFyaXNvbnMuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBlcXVhbEZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGRldGVybWluZSBlcXVpdmFsZW50cyBvZiB2YWx1ZXMuXG4gKiBAcGFyYW0ge09iamVjdH0gc3RhY2sgVHJhY2tzIHRyYXZlcnNlZCBgb2JqZWN0YCBhbmQgYG90aGVyYCBvYmplY3RzLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBvYmplY3RzIGFyZSBlcXVpdmFsZW50LCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGVxdWFsT2JqZWN0cyhvYmplY3QsIG90aGVyLCBiaXRtYXNrLCBjdXN0b21pemVyLCBlcXVhbEZ1bmMsIHN0YWNrKSB7XG4gIHZhciBpc1BhcnRpYWwgPSBiaXRtYXNrICYgQ09NUEFSRV9QQVJUSUFMX0ZMQUcsXG4gICAgICBvYmpQcm9wcyA9IGdldEFsbEtleXMob2JqZWN0KSxcbiAgICAgIG9iakxlbmd0aCA9IG9ialByb3BzLmxlbmd0aCxcbiAgICAgIG90aFByb3BzID0gZ2V0QWxsS2V5cyhvdGhlciksXG4gICAgICBvdGhMZW5ndGggPSBvdGhQcm9wcy5sZW5ndGg7XG5cbiAgaWYgKG9iakxlbmd0aCAhPSBvdGhMZW5ndGggJiYgIWlzUGFydGlhbCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICB2YXIgaW5kZXggPSBvYmpMZW5ndGg7XG4gIHdoaWxlIChpbmRleC0tKSB7XG4gICAgdmFyIGtleSA9IG9ialByb3BzW2luZGV4XTtcbiAgICBpZiAoIShpc1BhcnRpYWwgPyBrZXkgaW4gb3RoZXIgOiBoYXNPd25Qcm9wZXJ0eS5jYWxsKG90aGVyLCBrZXkpKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuICAvLyBBc3N1bWUgY3ljbGljIHZhbHVlcyBhcmUgZXF1YWwuXG4gIHZhciBzdGFja2VkID0gc3RhY2suZ2V0KG9iamVjdCk7XG4gIGlmIChzdGFja2VkICYmIHN0YWNrLmdldChvdGhlcikpIHtcbiAgICByZXR1cm4gc3RhY2tlZCA9PSBvdGhlcjtcbiAgfVxuICB2YXIgcmVzdWx0ID0gdHJ1ZTtcbiAgc3RhY2suc2V0KG9iamVjdCwgb3RoZXIpO1xuICBzdGFjay5zZXQob3RoZXIsIG9iamVjdCk7XG5cbiAgdmFyIHNraXBDdG9yID0gaXNQYXJ0aWFsO1xuICB3aGlsZSAoKytpbmRleCA8IG9iakxlbmd0aCkge1xuICAgIGtleSA9IG9ialByb3BzW2luZGV4XTtcbiAgICB2YXIgb2JqVmFsdWUgPSBvYmplY3Rba2V5XSxcbiAgICAgICAgb3RoVmFsdWUgPSBvdGhlcltrZXldO1xuXG4gICAgaWYgKGN1c3RvbWl6ZXIpIHtcbiAgICAgIHZhciBjb21wYXJlZCA9IGlzUGFydGlhbFxuICAgICAgICA/IGN1c3RvbWl6ZXIob3RoVmFsdWUsIG9ialZhbHVlLCBrZXksIG90aGVyLCBvYmplY3QsIHN0YWNrKVxuICAgICAgICA6IGN1c3RvbWl6ZXIob2JqVmFsdWUsIG90aFZhbHVlLCBrZXksIG9iamVjdCwgb3RoZXIsIHN0YWNrKTtcbiAgICB9XG4gICAgLy8gUmVjdXJzaXZlbHkgY29tcGFyZSBvYmplY3RzIChzdXNjZXB0aWJsZSB0byBjYWxsIHN0YWNrIGxpbWl0cykuXG4gICAgaWYgKCEoY29tcGFyZWQgPT09IHVuZGVmaW5lZFxuICAgICAgICAgID8gKG9ialZhbHVlID09PSBvdGhWYWx1ZSB8fCBlcXVhbEZ1bmMob2JqVmFsdWUsIG90aFZhbHVlLCBiaXRtYXNrLCBjdXN0b21pemVyLCBzdGFjaykpXG4gICAgICAgICAgOiBjb21wYXJlZFxuICAgICAgICApKSB7XG4gICAgICByZXN1bHQgPSBmYWxzZTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBza2lwQ3RvciB8fCAoc2tpcEN0b3IgPSBrZXkgPT0gJ2NvbnN0cnVjdG9yJyk7XG4gIH1cbiAgaWYgKHJlc3VsdCAmJiAhc2tpcEN0b3IpIHtcbiAgICB2YXIgb2JqQ3RvciA9IG9iamVjdC5jb25zdHJ1Y3RvcixcbiAgICAgICAgb3RoQ3RvciA9IG90aGVyLmNvbnN0cnVjdG9yO1xuXG4gICAgLy8gTm9uIGBPYmplY3RgIG9iamVjdCBpbnN0YW5jZXMgd2l0aCBkaWZmZXJlbnQgY29uc3RydWN0b3JzIGFyZSBub3QgZXF1YWwuXG4gICAgaWYgKG9iakN0b3IgIT0gb3RoQ3RvciAmJlxuICAgICAgICAoJ2NvbnN0cnVjdG9yJyBpbiBvYmplY3QgJiYgJ2NvbnN0cnVjdG9yJyBpbiBvdGhlcikgJiZcbiAgICAgICAgISh0eXBlb2Ygb2JqQ3RvciA9PSAnZnVuY3Rpb24nICYmIG9iakN0b3IgaW5zdGFuY2VvZiBvYmpDdG9yICYmXG4gICAgICAgICAgdHlwZW9mIG90aEN0b3IgPT0gJ2Z1bmN0aW9uJyAmJiBvdGhDdG9yIGluc3RhbmNlb2Ygb3RoQ3RvcikpIHtcbiAgICAgIHJlc3VsdCA9IGZhbHNlO1xuICAgIH1cbiAgfVxuICBzdGFja1snZGVsZXRlJ10ob2JqZWN0KTtcbiAgc3RhY2tbJ2RlbGV0ZSddKG90aGVyKTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGFuIGFycmF5IG9mIG93biBlbnVtZXJhYmxlIHByb3BlcnR5IG5hbWVzIGFuZCBzeW1ib2xzIG9mIGBvYmplY3RgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHByb3BlcnR5IG5hbWVzIGFuZCBzeW1ib2xzLlxuICovXG5mdW5jdGlvbiBnZXRBbGxLZXlzKG9iamVjdCkge1xuICByZXR1cm4gYmFzZUdldEFsbEtleXMob2JqZWN0LCBrZXlzLCBnZXRTeW1ib2xzKTtcbn1cblxuLyoqXG4gKiBHZXRzIHRoZSBkYXRhIGZvciBgbWFwYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG1hcCBUaGUgbWFwIHRvIHF1ZXJ5LlxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUgcmVmZXJlbmNlIGtleS5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBtYXAgZGF0YS5cbiAqL1xuZnVuY3Rpb24gZ2V0TWFwRGF0YShtYXAsIGtleSkge1xuICB2YXIgZGF0YSA9IG1hcC5fX2RhdGFfXztcbiAgcmV0dXJuIGlzS2V5YWJsZShrZXkpXG4gICAgPyBkYXRhW3R5cGVvZiBrZXkgPT0gJ3N0cmluZycgPyAnc3RyaW5nJyA6ICdoYXNoJ11cbiAgICA6IGRhdGEubWFwO1xufVxuXG4vKipcbiAqIEdldHMgdGhlIG5hdGl2ZSBmdW5jdGlvbiBhdCBga2V5YCBvZiBgb2JqZWN0YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBtZXRob2QgdG8gZ2V0LlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGZ1bmN0aW9uIGlmIGl0J3MgbmF0aXZlLCBlbHNlIGB1bmRlZmluZWRgLlxuICovXG5mdW5jdGlvbiBnZXROYXRpdmUob2JqZWN0LCBrZXkpIHtcbiAgdmFyIHZhbHVlID0gZ2V0VmFsdWUob2JqZWN0LCBrZXkpO1xuICByZXR1cm4gYmFzZUlzTmF0aXZlKHZhbHVlKSA/IHZhbHVlIDogdW5kZWZpbmVkO1xufVxuXG4vKipcbiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgYmFzZUdldFRhZ2Agd2hpY2ggaWdub3JlcyBgU3ltYm9sLnRvU3RyaW5nVGFnYCB2YWx1ZXMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHF1ZXJ5LlxuICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgcmF3IGB0b1N0cmluZ1RhZ2AuXG4gKi9cbmZ1bmN0aW9uIGdldFJhd1RhZyh2YWx1ZSkge1xuICB2YXIgaXNPd24gPSBoYXNPd25Qcm9wZXJ0eS5jYWxsKHZhbHVlLCBzeW1Ub1N0cmluZ1RhZyksXG4gICAgICB0YWcgPSB2YWx1ZVtzeW1Ub1N0cmluZ1RhZ107XG5cbiAgdHJ5IHtcbiAgICB2YWx1ZVtzeW1Ub1N0cmluZ1RhZ10gPSB1bmRlZmluZWQ7XG4gICAgdmFyIHVubWFza2VkID0gdHJ1ZTtcbiAgfSBjYXRjaCAoZSkge31cblxuICB2YXIgcmVzdWx0ID0gbmF0aXZlT2JqZWN0VG9TdHJpbmcuY2FsbCh2YWx1ZSk7XG4gIGlmICh1bm1hc2tlZCkge1xuICAgIGlmIChpc093bikge1xuICAgICAgdmFsdWVbc3ltVG9TdHJpbmdUYWddID0gdGFnO1xuICAgIH0gZWxzZSB7XG4gICAgICBkZWxldGUgdmFsdWVbc3ltVG9TdHJpbmdUYWddO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG4vKipcbiAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgdGhlIG93biBlbnVtZXJhYmxlIHN5bWJvbHMgb2YgYG9iamVjdGAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2Ygc3ltYm9scy5cbiAqL1xudmFyIGdldFN5bWJvbHMgPSAhbmF0aXZlR2V0U3ltYm9scyA/IHN0dWJBcnJheSA6IGZ1bmN0aW9uKG9iamVjdCkge1xuICBpZiAob2JqZWN0ID09IG51bGwpIHtcbiAgICByZXR1cm4gW107XG4gIH1cbiAgb2JqZWN0ID0gT2JqZWN0KG9iamVjdCk7XG4gIHJldHVybiBhcnJheUZpbHRlcihuYXRpdmVHZXRTeW1ib2xzKG9iamVjdCksIGZ1bmN0aW9uKHN5bWJvbCkge1xuICAgIHJldHVybiBwcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKG9iamVjdCwgc3ltYm9sKTtcbiAgfSk7XG59O1xuXG4vKipcbiAqIEdldHMgdGhlIGB0b1N0cmluZ1RhZ2Agb2YgYHZhbHVlYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBgdG9TdHJpbmdUYWdgLlxuICovXG52YXIgZ2V0VGFnID0gYmFzZUdldFRhZztcblxuLy8gRmFsbGJhY2sgZm9yIGRhdGEgdmlld3MsIG1hcHMsIHNldHMsIGFuZCB3ZWFrIG1hcHMgaW4gSUUgMTEgYW5kIHByb21pc2VzIGluIE5vZGUuanMgPCA2LlxuaWYgKChEYXRhVmlldyAmJiBnZXRUYWcobmV3IERhdGFWaWV3KG5ldyBBcnJheUJ1ZmZlcigxKSkpICE9IGRhdGFWaWV3VGFnKSB8fFxuICAgIChNYXAgJiYgZ2V0VGFnKG5ldyBNYXApICE9IG1hcFRhZykgfHxcbiAgICAoUHJvbWlzZSAmJiBnZXRUYWcoUHJvbWlzZS5yZXNvbHZlKCkpICE9IHByb21pc2VUYWcpIHx8XG4gICAgKFNldCAmJiBnZXRUYWcobmV3IFNldCkgIT0gc2V0VGFnKSB8fFxuICAgIChXZWFrTWFwICYmIGdldFRhZyhuZXcgV2Vha01hcCkgIT0gd2Vha01hcFRhZykpIHtcbiAgZ2V0VGFnID0gZnVuY3Rpb24odmFsdWUpIHtcbiAgICB2YXIgcmVzdWx0ID0gYmFzZUdldFRhZyh2YWx1ZSksXG4gICAgICAgIEN0b3IgPSByZXN1bHQgPT0gb2JqZWN0VGFnID8gdmFsdWUuY29uc3RydWN0b3IgOiB1bmRlZmluZWQsXG4gICAgICAgIGN0b3JTdHJpbmcgPSBDdG9yID8gdG9Tb3VyY2UoQ3RvcikgOiAnJztcblxuICAgIGlmIChjdG9yU3RyaW5nKSB7XG4gICAgICBzd2l0Y2ggKGN0b3JTdHJpbmcpIHtcbiAgICAgICAgY2FzZSBkYXRhVmlld0N0b3JTdHJpbmc6IHJldHVybiBkYXRhVmlld1RhZztcbiAgICAgICAgY2FzZSBtYXBDdG9yU3RyaW5nOiByZXR1cm4gbWFwVGFnO1xuICAgICAgICBjYXNlIHByb21pc2VDdG9yU3RyaW5nOiByZXR1cm4gcHJvbWlzZVRhZztcbiAgICAgICAgY2FzZSBzZXRDdG9yU3RyaW5nOiByZXR1cm4gc2V0VGFnO1xuICAgICAgICBjYXNlIHdlYWtNYXBDdG9yU3RyaW5nOiByZXR1cm4gd2Vha01hcFRhZztcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhIHZhbGlkIGFycmF5LWxpa2UgaW5kZXguXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHBhcmFtIHtudW1iZXJ9IFtsZW5ndGg9TUFYX1NBRkVfSU5URUdFUl0gVGhlIHVwcGVyIGJvdW5kcyBvZiBhIHZhbGlkIGluZGV4LlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSB2YWxpZCBpbmRleCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBpc0luZGV4KHZhbHVlLCBsZW5ndGgpIHtcbiAgbGVuZ3RoID0gbGVuZ3RoID09IG51bGwgPyBNQVhfU0FGRV9JTlRFR0VSIDogbGVuZ3RoO1xuICByZXR1cm4gISFsZW5ndGggJiZcbiAgICAodHlwZW9mIHZhbHVlID09ICdudW1iZXInIHx8IHJlSXNVaW50LnRlc3QodmFsdWUpKSAmJlxuICAgICh2YWx1ZSA+IC0xICYmIHZhbHVlICUgMSA9PSAwICYmIHZhbHVlIDwgbGVuZ3RoKTtcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBzdWl0YWJsZSBmb3IgdXNlIGFzIHVuaXF1ZSBvYmplY3Qga2V5LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIHN1aXRhYmxlLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGlzS2V5YWJsZSh2YWx1ZSkge1xuICB2YXIgdHlwZSA9IHR5cGVvZiB2YWx1ZTtcbiAgcmV0dXJuICh0eXBlID09ICdzdHJpbmcnIHx8IHR5cGUgPT0gJ251bWJlcicgfHwgdHlwZSA9PSAnc3ltYm9sJyB8fCB0eXBlID09ICdib29sZWFuJylcbiAgICA/ICh2YWx1ZSAhPT0gJ19fcHJvdG9fXycpXG4gICAgOiAodmFsdWUgPT09IG51bGwpO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBgZnVuY2AgaGFzIGl0cyBzb3VyY2UgbWFza2VkLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgZnVuY2AgaXMgbWFza2VkLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGlzTWFza2VkKGZ1bmMpIHtcbiAgcmV0dXJuICEhbWFza1NyY0tleSAmJiAobWFza1NyY0tleSBpbiBmdW5jKTtcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBsaWtlbHkgYSBwcm90b3R5cGUgb2JqZWN0LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgcHJvdG90eXBlLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGlzUHJvdG90eXBlKHZhbHVlKSB7XG4gIHZhciBDdG9yID0gdmFsdWUgJiYgdmFsdWUuY29uc3RydWN0b3IsXG4gICAgICBwcm90byA9ICh0eXBlb2YgQ3RvciA9PSAnZnVuY3Rpb24nICYmIEN0b3IucHJvdG90eXBlKSB8fCBvYmplY3RQcm90bztcblxuICByZXR1cm4gdmFsdWUgPT09IHByb3RvO1xufVxuXG4vKipcbiAqIENvbnZlcnRzIGB2YWx1ZWAgdG8gYSBzdHJpbmcgdXNpbmcgYE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmdgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjb252ZXJ0LlxuICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgY29udmVydGVkIHN0cmluZy5cbiAqL1xuZnVuY3Rpb24gb2JqZWN0VG9TdHJpbmcodmFsdWUpIHtcbiAgcmV0dXJuIG5hdGl2ZU9iamVjdFRvU3RyaW5nLmNhbGwodmFsdWUpO1xufVxuXG4vKipcbiAqIENvbnZlcnRzIGBmdW5jYCB0byBpdHMgc291cmNlIGNvZGUuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGNvbnZlcnQuXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBzb3VyY2UgY29kZS5cbiAqL1xuZnVuY3Rpb24gdG9Tb3VyY2UoZnVuYykge1xuICBpZiAoZnVuYyAhPSBudWxsKSB7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBmdW5jVG9TdHJpbmcuY2FsbChmdW5jKTtcbiAgICB9IGNhdGNoIChlKSB7fVxuICAgIHRyeSB7XG4gICAgICByZXR1cm4gKGZ1bmMgKyAnJyk7XG4gICAgfSBjYXRjaCAoZSkge31cbiAgfVxuICByZXR1cm4gJyc7XG59XG5cbi8qKlxuICogUGVyZm9ybXMgYVxuICogW2BTYW1lVmFsdWVaZXJvYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtc2FtZXZhbHVlemVybylcbiAqIGNvbXBhcmlzb24gYmV0d2VlbiB0d28gdmFsdWVzIHRvIGRldGVybWluZSBpZiB0aGV5IGFyZSBlcXVpdmFsZW50LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjb21wYXJlLlxuICogQHBhcmFtIHsqfSBvdGhlciBUaGUgb3RoZXIgdmFsdWUgdG8gY29tcGFyZS5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgdmFsdWVzIGFyZSBlcXVpdmFsZW50LCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIHZhciBvYmplY3QgPSB7ICdhJzogMSB9O1xuICogdmFyIG90aGVyID0geyAnYSc6IDEgfTtcbiAqXG4gKiBfLmVxKG9iamVjdCwgb2JqZWN0KTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmVxKG9iamVjdCwgb3RoZXIpO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmVxKCdhJywgJ2EnKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmVxKCdhJywgT2JqZWN0KCdhJykpO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmVxKE5hTiwgTmFOKTtcbiAqIC8vID0+IHRydWVcbiAqL1xuZnVuY3Rpb24gZXEodmFsdWUsIG90aGVyKSB7XG4gIHJldHVybiB2YWx1ZSA9PT0gb3RoZXIgfHwgKHZhbHVlICE9PSB2YWx1ZSAmJiBvdGhlciAhPT0gb3RoZXIpO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGxpa2VseSBhbiBgYXJndW1lbnRzYCBvYmplY3QuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjEuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYW4gYGFyZ3VtZW50c2Agb2JqZWN0LFxuICogIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc0FyZ3VtZW50cyhmdW5jdGlvbigpIHsgcmV0dXJuIGFyZ3VtZW50czsgfSgpKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzQXJndW1lbnRzKFsxLCAyLCAzXSk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG52YXIgaXNBcmd1bWVudHMgPSBiYXNlSXNBcmd1bWVudHMoZnVuY3Rpb24oKSB7IHJldHVybiBhcmd1bWVudHM7IH0oKSkgPyBiYXNlSXNBcmd1bWVudHMgOiBmdW5jdGlvbih2YWx1ZSkge1xuICByZXR1cm4gaXNPYmplY3RMaWtlKHZhbHVlKSAmJiBoYXNPd25Qcm9wZXJ0eS5jYWxsKHZhbHVlLCAnY2FsbGVlJykgJiZcbiAgICAhcHJvcGVydHlJc0VudW1lcmFibGUuY2FsbCh2YWx1ZSwgJ2NhbGxlZScpO1xufTtcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBjbGFzc2lmaWVkIGFzIGFuIGBBcnJheWAgb2JqZWN0LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGFuIGFycmF5LCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNBcnJheShbMSwgMiwgM10pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNBcnJheShkb2N1bWVudC5ib2R5LmNoaWxkcmVuKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5pc0FycmF5KCdhYmMnKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5pc0FycmF5KF8ubm9vcCk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG52YXIgaXNBcnJheSA9IEFycmF5LmlzQXJyYXk7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYXJyYXktbGlrZS4gQSB2YWx1ZSBpcyBjb25zaWRlcmVkIGFycmF5LWxpa2UgaWYgaXQnc1xuICogbm90IGEgZnVuY3Rpb24gYW5kIGhhcyBhIGB2YWx1ZS5sZW5ndGhgIHRoYXQncyBhbiBpbnRlZ2VyIGdyZWF0ZXIgdGhhbiBvclxuICogZXF1YWwgdG8gYDBgIGFuZCBsZXNzIHRoYW4gb3IgZXF1YWwgdG8gYE51bWJlci5NQVhfU0FGRV9JTlRFR0VSYC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhcnJheS1saWtlLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNBcnJheUxpa2UoWzEsIDIsIDNdKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzQXJyYXlMaWtlKGRvY3VtZW50LmJvZHkuY2hpbGRyZW4pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNBcnJheUxpa2UoJ2FiYycpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNBcnJheUxpa2UoXy5ub29wKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzQXJyYXlMaWtlKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSAhPSBudWxsICYmIGlzTGVuZ3RoKHZhbHVlLmxlbmd0aCkgJiYgIWlzRnVuY3Rpb24odmFsdWUpO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGEgYnVmZmVyLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4zLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgYnVmZmVyLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNCdWZmZXIobmV3IEJ1ZmZlcigyKSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0J1ZmZlcihuZXcgVWludDhBcnJheSgyKSk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG52YXIgaXNCdWZmZXIgPSBuYXRpdmVJc0J1ZmZlciB8fCBzdHViRmFsc2U7XG5cbi8qKlxuICogUGVyZm9ybXMgYSBkZWVwIGNvbXBhcmlzb24gYmV0d2VlbiB0d28gdmFsdWVzIHRvIGRldGVybWluZSBpZiB0aGV5IGFyZVxuICogZXF1aXZhbGVudC5cbiAqXG4gKiAqKk5vdGU6KiogVGhpcyBtZXRob2Qgc3VwcG9ydHMgY29tcGFyaW5nIGFycmF5cywgYXJyYXkgYnVmZmVycywgYm9vbGVhbnMsXG4gKiBkYXRlIG9iamVjdHMsIGVycm9yIG9iamVjdHMsIG1hcHMsIG51bWJlcnMsIGBPYmplY3RgIG9iamVjdHMsIHJlZ2V4ZXMsXG4gKiBzZXRzLCBzdHJpbmdzLCBzeW1ib2xzLCBhbmQgdHlwZWQgYXJyYXlzLiBgT2JqZWN0YCBvYmplY3RzIGFyZSBjb21wYXJlZFxuICogYnkgdGhlaXIgb3duLCBub3QgaW5oZXJpdGVkLCBlbnVtZXJhYmxlIHByb3BlcnRpZXMuIEZ1bmN0aW9ucyBhbmQgRE9NXG4gKiBub2RlcyBhcmUgY29tcGFyZWQgYnkgc3RyaWN0IGVxdWFsaXR5LCBpLmUuIGA9PT1gLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjb21wYXJlLlxuICogQHBhcmFtIHsqfSBvdGhlciBUaGUgb3RoZXIgdmFsdWUgdG8gY29tcGFyZS5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgdmFsdWVzIGFyZSBlcXVpdmFsZW50LCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIHZhciBvYmplY3QgPSB7ICdhJzogMSB9O1xuICogdmFyIG90aGVyID0geyAnYSc6IDEgfTtcbiAqXG4gKiBfLmlzRXF1YWwob2JqZWN0LCBvdGhlcik7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogb2JqZWN0ID09PSBvdGhlcjtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzRXF1YWwodmFsdWUsIG90aGVyKSB7XG4gIHJldHVybiBiYXNlSXNFcXVhbCh2YWx1ZSwgb3RoZXIpO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGNsYXNzaWZpZWQgYXMgYSBgRnVuY3Rpb25gIG9iamVjdC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuMS4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIGZ1bmN0aW9uLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNGdW5jdGlvbihfKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzRnVuY3Rpb24oL2FiYy8pO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNGdW5jdGlvbih2YWx1ZSkge1xuICBpZiAoIWlzT2JqZWN0KHZhbHVlKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICAvLyBUaGUgdXNlIG9mIGBPYmplY3QjdG9TdHJpbmdgIGF2b2lkcyBpc3N1ZXMgd2l0aCB0aGUgYHR5cGVvZmAgb3BlcmF0b3JcbiAgLy8gaW4gU2FmYXJpIDkgd2hpY2ggcmV0dXJucyAnb2JqZWN0JyBmb3IgdHlwZWQgYXJyYXlzIGFuZCBvdGhlciBjb25zdHJ1Y3RvcnMuXG4gIHZhciB0YWcgPSBiYXNlR2V0VGFnKHZhbHVlKTtcbiAgcmV0dXJuIHRhZyA9PSBmdW5jVGFnIHx8IHRhZyA9PSBnZW5UYWcgfHwgdGFnID09IGFzeW5jVGFnIHx8IHRhZyA9PSBwcm94eVRhZztcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhIHZhbGlkIGFycmF5LWxpa2UgbGVuZ3RoLlxuICpcbiAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBpcyBsb29zZWx5IGJhc2VkIG9uXG4gKiBbYFRvTGVuZ3RoYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtdG9sZW5ndGgpLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgdmFsaWQgbGVuZ3RoLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNMZW5ndGgoMyk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0xlbmd0aChOdW1iZXIuTUlOX1ZBTFVFKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5pc0xlbmd0aChJbmZpbml0eSk7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uaXNMZW5ndGgoJzMnKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzTGVuZ3RoKHZhbHVlKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsdWUgPT0gJ251bWJlcicgJiZcbiAgICB2YWx1ZSA+IC0xICYmIHZhbHVlICUgMSA9PSAwICYmIHZhbHVlIDw9IE1BWF9TQUZFX0lOVEVHRVI7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgdGhlXG4gKiBbbGFuZ3VhZ2UgdHlwZV0oaHR0cDovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLWVjbWFzY3JpcHQtbGFuZ3VhZ2UtdHlwZXMpXG4gKiBvZiBgT2JqZWN0YC4gKGUuZy4gYXJyYXlzLCBmdW5jdGlvbnMsIG9iamVjdHMsIHJlZ2V4ZXMsIGBuZXcgTnVtYmVyKDApYCwgYW5kIGBuZXcgU3RyaW5nKCcnKWApXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjEuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYW4gb2JqZWN0LCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNPYmplY3Qoe30pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNPYmplY3QoWzEsIDIsIDNdKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzT2JqZWN0KF8ubm9vcCk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc09iamVjdChudWxsKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzT2JqZWN0KHZhbHVlKSB7XG4gIHZhciB0eXBlID0gdHlwZW9mIHZhbHVlO1xuICByZXR1cm4gdmFsdWUgIT0gbnVsbCAmJiAodHlwZSA9PSAnb2JqZWN0JyB8fCB0eXBlID09ICdmdW5jdGlvbicpO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIG9iamVjdC1saWtlLiBBIHZhbHVlIGlzIG9iamVjdC1saWtlIGlmIGl0J3Mgbm90IGBudWxsYFxuICogYW5kIGhhcyBhIGB0eXBlb2ZgIHJlc3VsdCBvZiBcIm9iamVjdFwiLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIG9iamVjdC1saWtlLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNPYmplY3RMaWtlKHt9KTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzT2JqZWN0TGlrZShbMSwgMiwgM10pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNPYmplY3RMaWtlKF8ubm9vcCk7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uaXNPYmplY3RMaWtlKG51bGwpO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNPYmplY3RMaWtlKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSAhPSBudWxsICYmIHR5cGVvZiB2YWx1ZSA9PSAnb2JqZWN0Jztcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBjbGFzc2lmaWVkIGFzIGEgdHlwZWQgYXJyYXkuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAzLjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSB0eXBlZCBhcnJheSwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzVHlwZWRBcnJheShuZXcgVWludDhBcnJheSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc1R5cGVkQXJyYXkoW10pO1xuICogLy8gPT4gZmFsc2VcbiAqL1xudmFyIGlzVHlwZWRBcnJheSA9IG5vZGVJc1R5cGVkQXJyYXkgPyBiYXNlVW5hcnkobm9kZUlzVHlwZWRBcnJheSkgOiBiYXNlSXNUeXBlZEFycmF5O1xuXG4vKipcbiAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgdGhlIG93biBlbnVtZXJhYmxlIHByb3BlcnR5IG5hbWVzIG9mIGBvYmplY3RgLlxuICpcbiAqICoqTm90ZToqKiBOb24tb2JqZWN0IHZhbHVlcyBhcmUgY29lcmNlZCB0byBvYmplY3RzLiBTZWUgdGhlXG4gKiBbRVMgc3BlY10oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtb2JqZWN0LmtleXMpXG4gKiBmb3IgbW9yZSBkZXRhaWxzLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBzaW5jZSAwLjEuMFxuICogQG1lbWJlck9mIF9cbiAqIEBjYXRlZ29yeSBPYmplY3RcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgbmFtZXMuXG4gKiBAZXhhbXBsZVxuICpcbiAqIGZ1bmN0aW9uIEZvbygpIHtcbiAqICAgdGhpcy5hID0gMTtcbiAqICAgdGhpcy5iID0gMjtcbiAqIH1cbiAqXG4gKiBGb28ucHJvdG90eXBlLmMgPSAzO1xuICpcbiAqIF8ua2V5cyhuZXcgRm9vKTtcbiAqIC8vID0+IFsnYScsICdiJ10gKGl0ZXJhdGlvbiBvcmRlciBpcyBub3QgZ3VhcmFudGVlZClcbiAqXG4gKiBfLmtleXMoJ2hpJyk7XG4gKiAvLyA9PiBbJzAnLCAnMSddXG4gKi9cbmZ1bmN0aW9uIGtleXMob2JqZWN0KSB7XG4gIHJldHVybiBpc0FycmF5TGlrZShvYmplY3QpID8gYXJyYXlMaWtlS2V5cyhvYmplY3QpIDogYmFzZUtleXMob2JqZWN0KTtcbn1cblxuLyoqXG4gKiBUaGlzIG1ldGhvZCByZXR1cm5zIGEgbmV3IGVtcHR5IGFycmF5LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4xMy4wXG4gKiBAY2F0ZWdvcnkgVXRpbFxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgZW1wdHkgYXJyYXkuXG4gKiBAZXhhbXBsZVxuICpcbiAqIHZhciBhcnJheXMgPSBfLnRpbWVzKDIsIF8uc3R1YkFycmF5KTtcbiAqXG4gKiBjb25zb2xlLmxvZyhhcnJheXMpO1xuICogLy8gPT4gW1tdLCBbXV1cbiAqXG4gKiBjb25zb2xlLmxvZyhhcnJheXNbMF0gPT09IGFycmF5c1sxXSk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBzdHViQXJyYXkoKSB7XG4gIHJldHVybiBbXTtcbn1cblxuLyoqXG4gKiBUaGlzIG1ldGhvZCByZXR1cm5zIGBmYWxzZWAuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjEzLjBcbiAqIEBjYXRlZ29yeSBVdGlsXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLnRpbWVzKDIsIF8uc3R1YkZhbHNlKTtcbiAqIC8vID0+IFtmYWxzZSwgZmFsc2VdXG4gKi9cbmZ1bmN0aW9uIHN0dWJGYWxzZSgpIHtcbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzRXF1YWw7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvbG9kYXNoLmlzZXF1YWwvaW5kZXguanMiLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKG1vZHVsZSkge1xyXG5cdGlmKCFtb2R1bGUud2VicGFja1BvbHlmaWxsKSB7XHJcblx0XHRtb2R1bGUuZGVwcmVjYXRlID0gZnVuY3Rpb24oKSB7fTtcclxuXHRcdG1vZHVsZS5wYXRocyA9IFtdO1xyXG5cdFx0Ly8gbW9kdWxlLnBhcmVudCA9IHVuZGVmaW5lZCBieSBkZWZhdWx0XHJcblx0XHRpZighbW9kdWxlLmNoaWxkcmVuKSBtb2R1bGUuY2hpbGRyZW4gPSBbXTtcclxuXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShtb2R1bGUsIFwibG9hZGVkXCIsIHtcclxuXHRcdFx0ZW51bWVyYWJsZTogdHJ1ZSxcclxuXHRcdFx0Z2V0OiBmdW5jdGlvbigpIHtcclxuXHRcdFx0XHRyZXR1cm4gbW9kdWxlLmw7XHJcblx0XHRcdH1cclxuXHRcdH0pO1xyXG5cdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KG1vZHVsZSwgXCJpZFwiLCB7XHJcblx0XHRcdGVudW1lcmFibGU6IHRydWUsXHJcblx0XHRcdGdldDogZnVuY3Rpb24oKSB7XHJcblx0XHRcdFx0cmV0dXJuIG1vZHVsZS5pO1xyXG5cdFx0XHR9XHJcblx0XHR9KTtcclxuXHRcdG1vZHVsZS53ZWJwYWNrUG9seWZpbGwgPSAxO1xyXG5cdH1cclxuXHRyZXR1cm4gbW9kdWxlO1xyXG59O1xyXG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gKHdlYnBhY2spL2J1aWxkaW4vbW9kdWxlLmpzIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZXhlY3V0ZVRhc2tzID0gZXhlY3V0ZVRhc2tzO1xuZXhwb3J0cy5fZXhlY3V0ZVRhc2tzID0gX2V4ZWN1dGVUYXNrcztcbmV4cG9ydHMuY2hlY2tJc1Jhbmdlc1N1cHBvcnRlZCA9IGNoZWNrSXNSYW5nZXNTdXBwb3J0ZWQ7XG5cbnZhciBfYnVpbGRlclV0aWxSdW50aW1lO1xuXG5mdW5jdGlvbiBfbG9hZF9idWlsZGVyVXRpbFJ1bnRpbWUoKSB7XG4gICAgcmV0dXJuIF9idWlsZGVyVXRpbFJ1bnRpbWUgPSByZXF1aXJlKFwiYnVpbGRlci11dGlsLXJ1bnRpbWVcIik7XG59XG5cbnZhciBfRGF0YVNwbGl0dGVyO1xuXG5mdW5jdGlvbiBfbG9hZF9EYXRhU3BsaXR0ZXIoKSB7XG4gICAgcmV0dXJuIF9EYXRhU3BsaXR0ZXIgPSByZXF1aXJlKFwiLi9EYXRhU3BsaXR0ZXJcIik7XG59XG5cbnZhciBfZG93bmxvYWRQbGFuQnVpbGRlcjtcblxuZnVuY3Rpb24gX2xvYWRfZG93bmxvYWRQbGFuQnVpbGRlcigpIHtcbiAgICByZXR1cm4gX2Rvd25sb2FkUGxhbkJ1aWxkZXIgPSByZXF1aXJlKFwiLi9kb3dubG9hZFBsYW5CdWlsZGVyXCIpO1xufVxuXG5mdW5jdGlvbiBleGVjdXRlVGFza3MoZGlmZmVyZW50aWFsRG93bmxvYWRlciwgdGFza3MsIG91dCwgb2xkRmlsZUZkLCByZWplY3QpIHtcbiAgICBjb25zdCB3ID0gdGFza09mZnNldCA9PiB7XG4gICAgICAgIGlmICh0YXNrT2Zmc2V0ID49IHRhc2tzLmxlbmd0aCkge1xuICAgICAgICAgICAgaWYgKGRpZmZlcmVudGlhbERvd25sb2FkZXIuZmlsZU1ldGFkYXRhQnVmZmVyICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBvdXQud3JpdGUoZGlmZmVyZW50aWFsRG93bmxvYWRlci5maWxlTWV0YWRhdGFCdWZmZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgb3V0LmVuZCgpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG5leHRPZmZzZXQgPSB0YXNrT2Zmc2V0ICsgKGRpZmZlcmVudGlhbERvd25sb2FkZXIub3B0aW9ucy51c2VNdWx0aXBsZVJhbmdlUmVxdWVzdCA9PT0gZmFsc2UgPyAxIDogMTAwMCk7XG4gICAgICAgIF9leGVjdXRlVGFza3MoZGlmZmVyZW50aWFsRG93bmxvYWRlciwge1xuICAgICAgICAgICAgdGFza3MsXG4gICAgICAgICAgICBzdGFydDogdGFza09mZnNldCxcbiAgICAgICAgICAgIGVuZDogTWF0aC5taW4odGFza3MubGVuZ3RoLCBuZXh0T2Zmc2V0KSxcbiAgICAgICAgICAgIG9sZEZpbGVGZFxuICAgICAgICB9LCBvdXQsICgpID0+IHcobmV4dE9mZnNldCksIHJlamVjdCk7XG4gICAgfTtcbiAgICByZXR1cm4gdztcbn1cbmZ1bmN0aW9uIF9leGVjdXRlVGFza3MoZGlmZmVyZW50aWFsRG93bmxvYWRlciwgb3B0aW9ucywgb3V0LCByZXNvbHZlLCByZWplY3QpIHtcbiAgICBsZXQgcmFuZ2VzID0gXCJieXRlcz1cIjtcbiAgICBsZXQgcGFydENvdW50ID0gMDtcbiAgICBjb25zdCBwYXJ0SW5kZXhUb1Rhc2tJbmRleCA9IG5ldyBNYXAoKTtcbiAgICBjb25zdCBwYXJ0SW5kZXhUb0xlbmd0aCA9IFtdO1xuICAgIGZvciAobGV0IGkgPSBvcHRpb25zLnN0YXJ0OyBpIDwgb3B0aW9ucy5lbmQ7IGkrKykge1xuICAgICAgICBjb25zdCB0YXNrID0gb3B0aW9ucy50YXNrc1tpXTtcbiAgICAgICAgaWYgKHRhc2sua2luZCA9PT0gKF9kb3dubG9hZFBsYW5CdWlsZGVyIHx8IF9sb2FkX2Rvd25sb2FkUGxhbkJ1aWxkZXIoKSkuT3BlcmF0aW9uS2luZC5ET1dOTE9BRCkge1xuICAgICAgICAgICAgcmFuZ2VzICs9IGAke3Rhc2suc3RhcnR9LSR7dGFzay5lbmQgLSAxfSwgYDtcbiAgICAgICAgICAgIHBhcnRJbmRleFRvVGFza0luZGV4LnNldChwYXJ0Q291bnQsIGkpO1xuICAgICAgICAgICAgcGFydENvdW50Kys7XG4gICAgICAgICAgICBwYXJ0SW5kZXhUb0xlbmd0aC5wdXNoKHRhc2suZW5kIC0gdGFzay5zdGFydCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKHBhcnRDb3VudCA8PSAxKSB7XG4gICAgICAgIC8vIHRoZSBvbmx5IHJlbW90ZSByYW5nZSAtIGNvcHlcbiAgICAgICAgY29uc3QgdyA9IGluZGV4ID0+IHtcbiAgICAgICAgICAgIGlmIChpbmRleCA+PSBvcHRpb25zLmVuZCkge1xuICAgICAgICAgICAgICAgIHJlc29sdmUoKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCB0YXNrID0gb3B0aW9ucy50YXNrc1tpbmRleCsrXTtcbiAgICAgICAgICAgIGlmICh0YXNrLmtpbmQgPT09IChfZG93bmxvYWRQbGFuQnVpbGRlciB8fCBfbG9hZF9kb3dubG9hZFBsYW5CdWlsZGVyKCkpLk9wZXJhdGlvbktpbmQuQ09QWSkge1xuICAgICAgICAgICAgICAgICgwLCAoX0RhdGFTcGxpdHRlciB8fCBfbG9hZF9EYXRhU3BsaXR0ZXIoKSkuY29weURhdGEpKHRhc2ssIG91dCwgb3B0aW9ucy5vbGRGaWxlRmQsIHJlamVjdCwgKCkgPT4gdyhpbmRleCkpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb25zdCByZXF1ZXN0T3B0aW9ucyA9IGRpZmZlcmVudGlhbERvd25sb2FkZXIuY3JlYXRlUmVxdWVzdE9wdGlvbnMoXCJnZXRcIik7XG4gICAgICAgICAgICAgICAgcmVxdWVzdE9wdGlvbnMuaGVhZGVycy5SYW5nZSA9IGBieXRlcz0ke3Rhc2suc3RhcnR9LSR7dGFzay5lbmQgLSAxfWA7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVxdWVzdCA9IGRpZmZlcmVudGlhbERvd25sb2FkZXIuaHR0cEV4ZWN1dG9yLmRvUmVxdWVzdChyZXF1ZXN0T3B0aW9ucywgcmVzcG9uc2UgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWNoZWNrSXNSYW5nZXNTdXBwb3J0ZWQocmVzcG9uc2UsIHJlamVjdCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXNwb25zZS5waXBlKG91dCwge1xuICAgICAgICAgICAgICAgICAgICAgICAgZW5kOiBmYWxzZVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2Uub25jZShcImVuZFwiLCAoKSA9PiB3KGluZGV4KSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgZGlmZmVyZW50aWFsRG93bmxvYWRlci5odHRwRXhlY3V0b3IuYWRkRXJyb3JBbmRUaW1lb3V0SGFuZGxlcnMocmVxdWVzdCwgcmVqZWN0KTtcbiAgICAgICAgICAgICAgICByZXF1ZXN0LmVuZCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICB3KG9wdGlvbnMuc3RhcnQpO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHJlcXVlc3RPcHRpb25zID0gZGlmZmVyZW50aWFsRG93bmxvYWRlci5jcmVhdGVSZXF1ZXN0T3B0aW9ucyhcImdldFwiKTtcbiAgICByZXF1ZXN0T3B0aW9ucy5oZWFkZXJzLlJhbmdlID0gcmFuZ2VzLnN1YnN0cmluZygwLCByYW5nZXMubGVuZ3RoIC0gMik7XG4gICAgY29uc3QgcmVxdWVzdCA9IGRpZmZlcmVudGlhbERvd25sb2FkZXIuaHR0cEV4ZWN1dG9yLmRvUmVxdWVzdChyZXF1ZXN0T3B0aW9ucywgcmVzcG9uc2UgPT4ge1xuICAgICAgICBpZiAoIWNoZWNrSXNSYW5nZXNTdXBwb3J0ZWQocmVzcG9uc2UsIHJlamVjdCkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBjb250ZW50VHlwZSA9ICgwLCAoX2J1aWxkZXJVdGlsUnVudGltZSB8fCBfbG9hZF9idWlsZGVyVXRpbFJ1bnRpbWUoKSkuc2FmZUdldEhlYWRlcikocmVzcG9uc2UsIFwiY29udGVudC10eXBlXCIpO1xuICAgICAgICBjb25zdCBtID0gL15tdWx0aXBhcnRcXC8uKz8oPzo7IGJvdW5kYXJ5PSg/Oig/OlwiKC4rKVwiKXwoPzooW15cXHNdKykpKSkkL2kuZXhlYyhjb250ZW50VHlwZSk7XG4gICAgICAgIGlmIChtID09IG51bGwpIHtcbiAgICAgICAgICAgIHJlamVjdChuZXcgRXJyb3IoYENvbnRlbnQtVHlwZSBcIm11bHRpcGFydC9ieXRlcmFuZ2VzXCIgaXMgZXhwZWN0ZWQsIGJ1dCBnb3QgXCIke2NvbnRlbnRUeXBlfVwiYCkpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGRpY2VyID0gbmV3IChfRGF0YVNwbGl0dGVyIHx8IF9sb2FkX0RhdGFTcGxpdHRlcigpKS5EYXRhU3BsaXR0ZXIob3V0LCBvcHRpb25zLCBwYXJ0SW5kZXhUb1Rhc2tJbmRleCwgbVsxXSB8fCBtWzJdLCBwYXJ0SW5kZXhUb0xlbmd0aCwgcmVzb2x2ZSk7XG4gICAgICAgIGRpY2VyLm9uKFwiZXJyb3JcIiwgcmVqZWN0KTtcbiAgICAgICAgcmVzcG9uc2UucGlwZShkaWNlcik7XG4gICAgfSk7XG4gICAgZGlmZmVyZW50aWFsRG93bmxvYWRlci5odHRwRXhlY3V0b3IuYWRkRXJyb3JBbmRUaW1lb3V0SGFuZGxlcnMocmVxdWVzdCwgcmVqZWN0KTtcbiAgICByZXF1ZXN0LmVuZCgpO1xufVxuZnVuY3Rpb24gY2hlY2tJc1Jhbmdlc1N1cHBvcnRlZChyZXNwb25zZSwgcmVqZWN0KSB7XG4gICAgLy8gRWxlY3Ryb24gbmV0IGhhbmRsZXMgcmVkaXJlY3RzIGF1dG9tYXRpY2FsbHksIG91ciBOb2RlSlMgdGVzdCBzZXJ2ZXIgZG9lc24ndCB1c2UgcmVkaXJlY3RzIC0gc28sIHdlIGRvbid0IGNoZWNrIDN4eCBjb2Rlcy5cbiAgICBpZiAocmVzcG9uc2Uuc3RhdHVzQ29kZSA+PSA0MDApIHtcbiAgICAgICAgcmVqZWN0KCgwLCAoX2J1aWxkZXJVdGlsUnVudGltZSB8fCBfbG9hZF9idWlsZGVyVXRpbFJ1bnRpbWUoKSkuY3JlYXRlSHR0cEVycm9yKShyZXNwb25zZSkpO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmIChyZXNwb25zZS5zdGF0dXNDb2RlICE9PSAyMDYpIHtcbiAgICAgICAgY29uc3QgYWNjZXB0UmFuZ2VzID0gKDAsIChfYnVpbGRlclV0aWxSdW50aW1lIHx8IF9sb2FkX2J1aWxkZXJVdGlsUnVudGltZSgpKS5zYWZlR2V0SGVhZGVyKShyZXNwb25zZSwgXCJhY2NlcHQtcmFuZ2VzXCIpO1xuICAgICAgICBpZiAoYWNjZXB0UmFuZ2VzID09IG51bGwgfHwgYWNjZXB0UmFuZ2VzID09PSBcIm5vbmVcIikge1xuICAgICAgICAgICAgcmVqZWN0KG5ldyBFcnJvcihcIlNlcnZlciBkb2Vzbid0IHN1cHBvcnQgQWNjZXB0LVJhbmdlc1wiKSk7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1tdWx0aXBsZVJhbmdlRG93bmxvYWRlci5qcy5tYXBcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvZWxlY3Ryb24tdXBkYXRlci9vdXQvZGlmZmVyZW50aWFsRG93bmxvYWRlci9tdWx0aXBsZVJhbmdlRG93bmxvYWRlci5qcyIsIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLkdlbmVyaWNEaWZmZXJlbnRpYWxEb3dubG9hZGVyID0gdW5kZWZpbmVkO1xuXG52YXIgX2JsdWViaXJkTHN0O1xuXG5mdW5jdGlvbiBfbG9hZF9ibHVlYmlyZExzdCgpIHtcbiAgICByZXR1cm4gX2JsdWViaXJkTHN0ID0gcmVxdWlyZShcImJsdWViaXJkLWxzdFwiKTtcbn1cblxudmFyIF9ibG9ja01hcEFwaTtcblxuZnVuY3Rpb24gX2xvYWRfYmxvY2tNYXBBcGkoKSB7XG4gICAgcmV0dXJuIF9ibG9ja01hcEFwaSA9IHJlcXVpcmUoXCJidWlsZGVyLXV0aWwtcnVudGltZS9vdXQvYmxvY2tNYXBBcGlcIik7XG59XG5cbnZhciBfZnNFeHRyYVA7XG5cbmZ1bmN0aW9uIF9sb2FkX2ZzRXh0cmFQKCkge1xuICAgIHJldHVybiBfZnNFeHRyYVAgPSByZXF1aXJlKFwiZnMtZXh0cmEtcFwiKTtcbn1cblxudmFyIF9wYXRoID0gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQocmVxdWlyZShcInBhdGhcIikpO1xuXG52YXIgX0RpZmZlcmVudGlhbERvd25sb2FkZXI7XG5cbmZ1bmN0aW9uIF9sb2FkX0RpZmZlcmVudGlhbERvd25sb2FkZXIoKSB7XG4gICAgcmV0dXJuIF9EaWZmZXJlbnRpYWxEb3dubG9hZGVyID0gcmVxdWlyZShcIi4vRGlmZmVyZW50aWFsRG93bmxvYWRlclwiKTtcbn1cblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQob2JqKSB7IGlmIChvYmogJiYgb2JqLl9fZXNNb2R1bGUpIHsgcmV0dXJuIG9iajsgfSBlbHNlIHsgdmFyIG5ld09iaiA9IHt9OyBpZiAob2JqICE9IG51bGwpIHsgZm9yICh2YXIga2V5IGluIG9iaikgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwga2V5KSkgbmV3T2JqW2tleV0gPSBvYmpba2V5XTsgfSB9IG5ld09iai5kZWZhdWx0ID0gb2JqOyByZXR1cm4gbmV3T2JqOyB9IH1cblxuY2xhc3MgR2VuZXJpY0RpZmZlcmVudGlhbERvd25sb2FkZXIgZXh0ZW5kcyAoX0RpZmZlcmVudGlhbERvd25sb2FkZXIgfHwgX2xvYWRfRGlmZmVyZW50aWFsRG93bmxvYWRlcigpKS5EaWZmZXJlbnRpYWxEb3dubG9hZGVyIHtcbiAgICBkb3dubG9hZChuZXdCbG9ja01hcCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgICAgIHJldHVybiAoMCwgKF9ibHVlYmlyZExzdCB8fCBfbG9hZF9ibHVlYmlyZExzdCgpKS5jb3JvdXRpbmUpKGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICB5aWVsZCBfdGhpcy5kb0Rvd25sb2FkKCh5aWVsZCAoMCwgKF9mc0V4dHJhUCB8fCBfbG9hZF9mc0V4dHJhUCgpKS5yZWFkSnNvbikoX3BhdGguam9pbihwcm9jZXNzLnJlc291cmNlc1BhdGgsIFwiLi5cIiwgKF9ibG9ja01hcEFwaSB8fCBfbG9hZF9ibG9ja01hcEFwaSgpKS5CTE9DS19NQVBfRklMRV9OQU1FKSkpLCBuZXdCbG9ja01hcCk7XG4gICAgICAgIH0pKCk7XG4gICAgfVxufVxuZXhwb3J0cy5HZW5lcmljRGlmZmVyZW50aWFsRG93bmxvYWRlciA9IEdlbmVyaWNEaWZmZXJlbnRpYWxEb3dubG9hZGVyOyAvLyMgc291cmNlTWFwcGluZ1VSTD1HZW5lcmljRGlmZmVyZW50aWFsRG93bmxvYWRlci5qcy5tYXBcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvZWxlY3Ryb24tdXBkYXRlci9vdXQvZGlmZmVyZW50aWFsRG93bmxvYWRlci9HZW5lcmljRGlmZmVyZW50aWFsRG93bmxvYWRlci5qcyIsIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLnZlcmlmeVNpZ25hdHVyZSA9IHZlcmlmeVNpZ25hdHVyZTtcblxudmFyIF9ibHVlYmlyZExzdDtcblxuZnVuY3Rpb24gX2xvYWRfYmx1ZWJpcmRMc3QoKSB7XG4gICAgcmV0dXJuIF9ibHVlYmlyZExzdCA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcImJsdWViaXJkLWxzdFwiKSk7XG59XG5cbnZhciBfYnVpbGRlclV0aWxSdW50aW1lO1xuXG5mdW5jdGlvbiBfbG9hZF9idWlsZGVyVXRpbFJ1bnRpbWUoKSB7XG4gICAgcmV0dXJuIF9idWlsZGVyVXRpbFJ1bnRpbWUgPSByZXF1aXJlKFwiYnVpbGRlci11dGlsLXJ1bnRpbWVcIik7XG59XG5cbnZhciBfY2hpbGRfcHJvY2VzcztcblxuZnVuY3Rpb24gX2xvYWRfY2hpbGRfcHJvY2VzcygpIHtcbiAgICByZXR1cm4gX2NoaWxkX3Byb2Nlc3MgPSByZXF1aXJlKFwiY2hpbGRfcHJvY2Vzc1wiKTtcbn1cblxudmFyIF9vcztcblxuZnVuY3Rpb24gX2xvYWRfb3MoKSB7XG4gICAgcmV0dXJuIF9vcyA9IF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKHJlcXVpcmUoXCJvc1wiKSk7XG59XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKG9iaikgeyBpZiAob2JqICYmIG9iai5fX2VzTW9kdWxlKSB7IHJldHVybiBvYmo7IH0gZWxzZSB7IHZhciBuZXdPYmogPSB7fTsgaWYgKG9iaiAhPSBudWxsKSB7IGZvciAodmFyIGtleSBpbiBvYmopIHsgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGtleSkpIG5ld09ialtrZXldID0gb2JqW2tleV07IH0gfSBuZXdPYmouZGVmYXVsdCA9IG9iajsgcmV0dXJuIG5ld09iajsgfSB9XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbi8vICRjZXJ0aWZpY2F0ZUluZm8gPSAoR2V0LUF1dGhlbnRpY29kZVNpZ25hdHVyZSAneHh4XFx5eXkuZXhlJ1xuLy8gfCB3aGVyZSB7JF8uU3RhdHVzLkVxdWFscyhbU3lzdGVtLk1hbmFnZW1lbnQuQXV0b21hdGlvbi5TaWduYXR1cmVTdGF0dXNdOjpWYWxpZCkgLWFuZCAkXy5TaWduZXJDZXJ0aWZpY2F0ZS5TdWJqZWN0LkNvbnRhaW5zKFwiQ049c2llbWVucy5jb21cIil9KVxuLy8gfCBPdXQtU3RyaW5nIDsgaWYgKCRjZXJ0aWZpY2F0ZUluZm8pIHsgZXhpdCAwIH0gZWxzZSB7IGV4aXQgMSB9XG5mdW5jdGlvbiB2ZXJpZnlTaWduYXR1cmUocHVibGlzaGVyTmFtZXMsIHRlbXBVcGRhdGVGaWxlLCBsb2dnZXIpIHtcbiAgICByZXR1cm4gbmV3IChfYmx1ZWJpcmRMc3QgfHwgX2xvYWRfYmx1ZWJpcmRMc3QoKSkuZGVmYXVsdCgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9lbGVjdHJvbi11c2VybGFuZC9lbGVjdHJvbi1idWlsZGVyL2lzc3Vlcy8yNDIxXG4gICAgICAgICgwLCAoX2NoaWxkX3Byb2Nlc3MgfHwgX2xvYWRfY2hpbGRfcHJvY2VzcygpKS5leGVjRmlsZSkoXCJwb3dlcnNoZWxsLmV4ZVwiLCBbYEdldC1BdXRoZW50aWNvZGVTaWduYXR1cmUgJyR7dGVtcFVwZGF0ZUZpbGV9JyB8IENvbnZlcnRUby1Kc29uIC1Db21wcmVzc2BdLCB7XG4gICAgICAgICAgICB0aW1lb3V0OiAzMCAqIDEwMDBcbiAgICAgICAgfSwgKGVycm9yLCBzdGRvdXQsIHN0ZGVycikgPT4ge1xuICAgICAgICAgICAgaWYgKGVycm9yICE9IG51bGwgfHwgc3RkZXJyKSB7XG4gICAgICAgICAgICAgICAgaWYgKGlzT2xkV2luNigpKSB7XG4gICAgICAgICAgICAgICAgICAgIGxvZ2dlci53YXJuKGBDYW5ub3QgZXhlY3V0ZSBHZXQtQXV0aGVudGljb2RlU2lnbmF0dXJlOiAke2Vycm9yIHx8IHN0ZGVycn0uIElnbm9yaW5nIHNpZ25hdHVyZSB2YWxpZGF0aW9uIGR1ZSB0byB1bnN1cHBvcnRlZCBwb3dlcnNoZWxsIHZlcnNpb24uIFBsZWFzZSB1cGdyYWRlIHRvIHBvd2Vyc2hlbGwgMyBvciBoaWdoZXIuYCk7XG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmUobnVsbCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgKDAsIChfY2hpbGRfcHJvY2VzcyB8fCBfbG9hZF9jaGlsZF9wcm9jZXNzKCkpLmV4ZWNGaWxlU3luYykoXCJwb3dlcnNoZWxsLmV4ZVwiLCBbXCJDb252ZXJ0VG8tSnNvbiB0ZXN0XCJdLCB7IHRpbWVvdXQ6IDEwICogMTAwMCB9KTtcbiAgICAgICAgICAgICAgICB9IGNhdGNoICh0ZXN0RXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgbG9nZ2VyLndhcm4oYENhbm5vdCBleGVjdXRlIENvbnZlcnRUby1Kc29uOiAke3Rlc3RFcnJvci5tZXNzYWdlfS4gSWdub3Jpbmcgc2lnbmF0dXJlIHZhbGlkYXRpb24gZHVlIHRvIHVuc3VwcG9ydGVkIHBvd2Vyc2hlbGwgdmVyc2lvbi4gUGxlYXNlIHVwZ3JhZGUgdG8gcG93ZXJzaGVsbCAzIG9yIGhpZ2hlci5gKTtcbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShudWxsKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoZXJyb3IgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICByZWplY3QoZXJyb3IpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChzdGRlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVqZWN0KG5ldyBFcnJvcihgQ2Fubm90IGV4ZWN1dGUgR2V0LUF1dGhlbnRpY29kZVNpZ25hdHVyZTogJHtzdGRlcnJ9YCkpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgZGF0YSA9IEpTT04ucGFyc2Uoc3Rkb3V0KTtcbiAgICAgICAgICAgIGRlbGV0ZSBkYXRhLlByaXZhdGVLZXk7XG4gICAgICAgICAgICBkZWxldGUgZGF0YS5Jc09TQmluYXJ5O1xuICAgICAgICAgICAgZGVsZXRlIGRhdGEuU2lnbmF0dXJlVHlwZTtcbiAgICAgICAgICAgIGNvbnN0IHNpZ25lckNlcnRpZmljYXRlID0gZGF0YS5TaWduZXJDZXJ0aWZpY2F0ZTtcbiAgICAgICAgICAgIGlmIChzaWduZXJDZXJ0aWZpY2F0ZSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgZGVsZXRlIHNpZ25lckNlcnRpZmljYXRlLkFyY2hpdmVkO1xuICAgICAgICAgICAgICAgIGRlbGV0ZSBzaWduZXJDZXJ0aWZpY2F0ZS5FeHRlbnNpb25zO1xuICAgICAgICAgICAgICAgIGRlbGV0ZSBzaWduZXJDZXJ0aWZpY2F0ZS5IYW5kbGU7XG4gICAgICAgICAgICAgICAgZGVsZXRlIHNpZ25lckNlcnRpZmljYXRlLkhhc1ByaXZhdGVLZXk7XG4gICAgICAgICAgICAgICAgLy8gZHVwbGljYXRlcyBkYXRhLlNpZ25lckNlcnRpZmljYXRlIChjb250YWlucyBSYXdEYXRhKVxuICAgICAgICAgICAgICAgIGRlbGV0ZSBzaWduZXJDZXJ0aWZpY2F0ZS5TdWJqZWN0TmFtZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRlbGV0ZSBkYXRhLlBhdGg7XG4gICAgICAgICAgICBpZiAoZGF0YS5TdGF0dXMgPT09IDApIHtcbiAgICAgICAgICAgICAgICBjb25zdCBuYW1lID0gKDAsIChfYnVpbGRlclV0aWxSdW50aW1lIHx8IF9sb2FkX2J1aWxkZXJVdGlsUnVudGltZSgpKS5wYXJzZURuKShkYXRhLlNpZ25lckNlcnRpZmljYXRlLlN1YmplY3QpLmdldChcIkNOXCIpO1xuICAgICAgICAgICAgICAgIGlmIChwdWJsaXNoZXJOYW1lcy5pbmNsdWRlcyhuYW1lKSkge1xuICAgICAgICAgICAgICAgICAgICByZXNvbHZlKG51bGwpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gYHB1Ymxpc2hlck5hbWVzOiAke3B1Ymxpc2hlck5hbWVzLmpvaW4oXCIgfCBcIil9LCByYXcgaW5mbzogYCArIEpTT04uc3RyaW5naWZ5KGRhdGEsIChuYW1lLCB2YWx1ZSkgPT4gbmFtZSA9PT0gXCJSYXdEYXRhXCIgPyB1bmRlZmluZWQgOiB2YWx1ZSwgMik7XG4gICAgICAgICAgICBsb2dnZXIuaW5mbyhgU2lnbiB2ZXJpZmljYXRpb24gZmFpbGVkLCBpbnN0YWxsZXIgc2lnbmVkIHdpdGggaW5jb3JyZWN0IGNlcnRpZmljYXRlOiAke3Jlc3VsdH1gKTtcbiAgICAgICAgICAgIHJlc29sdmUocmVzdWx0KTtcbiAgICAgICAgfSk7XG4gICAgfSk7XG59XG5mdW5jdGlvbiBpc09sZFdpbjYoKSB7XG4gICAgY29uc3Qgd2luVmVyc2lvbiA9IChfb3MgfHwgX2xvYWRfb3MoKSkucmVsZWFzZSgpO1xuICAgIHJldHVybiB3aW5WZXJzaW9uLnN0YXJ0c1dpdGgoXCI2LlwiKSAmJiAhd2luVmVyc2lvbi5zdGFydHNXaXRoKFwiNi4zXCIpO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9d2luZG93c0V4ZWN1dGFibGVDb2RlU2lnbmF0dXJlVmVyaWZpZXIuanMubWFwXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2VsZWN0cm9uLXVwZGF0ZXIvb3V0L3dpbmRvd3NFeGVjdXRhYmxlQ29kZVNpZ25hdHVyZVZlcmlmaWVyLmpzIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuTWFjVXBkYXRlciA9IHVuZGVmaW5lZDtcblxudmFyIF9ibHVlYmlyZExzdDtcblxuZnVuY3Rpb24gX2xvYWRfYmx1ZWJpcmRMc3QoKSB7XG4gICAgcmV0dXJuIF9ibHVlYmlyZExzdCA9IHJlcXVpcmUoXCJibHVlYmlyZC1sc3RcIik7XG59XG5cbnZhciBfYmx1ZWJpcmRMc3QyO1xuXG5mdW5jdGlvbiBfbG9hZF9ibHVlYmlyZExzdDIoKSB7XG4gICAgcmV0dXJuIF9ibHVlYmlyZExzdDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJibHVlYmlyZC1sc3RcIikpO1xufVxuXG52YXIgX2J1aWxkZXJVdGlsUnVudGltZTtcblxuZnVuY3Rpb24gX2xvYWRfYnVpbGRlclV0aWxSdW50aW1lKCkge1xuICAgIHJldHVybiBfYnVpbGRlclV0aWxSdW50aW1lID0gcmVxdWlyZShcImJ1aWxkZXItdXRpbC1ydW50aW1lXCIpO1xufVxuXG52YXIgX2h0dHA7XG5cbmZ1bmN0aW9uIF9sb2FkX2h0dHAoKSB7XG4gICAgcmV0dXJuIF9odHRwID0gcmVxdWlyZShcImh0dHBcIik7XG59XG5cbnZhciBfQXBwVXBkYXRlcjtcblxuZnVuY3Rpb24gX2xvYWRfQXBwVXBkYXRlcigpIHtcbiAgICByZXR1cm4gX0FwcFVwZGF0ZXIgPSByZXF1aXJlKFwiLi9BcHBVcGRhdGVyXCIpO1xufVxuXG52YXIgX21haW47XG5cbmZ1bmN0aW9uIF9sb2FkX21haW4oKSB7XG4gICAgcmV0dXJuIF9tYWluID0gcmVxdWlyZShcIi4vbWFpblwiKTtcbn1cblxudmFyIF9Qcm92aWRlcjtcblxuZnVuY3Rpb24gX2xvYWRfUHJvdmlkZXIoKSB7XG4gICAgcmV0dXJuIF9Qcm92aWRlciA9IHJlcXVpcmUoXCIuL1Byb3ZpZGVyXCIpO1xufVxuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5jbGFzcyBNYWNVcGRhdGVyIGV4dGVuZHMgKF9BcHBVcGRhdGVyIHx8IF9sb2FkX0FwcFVwZGF0ZXIoKSkuQXBwVXBkYXRlciB7XG4gICAgY29uc3RydWN0b3Iob3B0aW9ucykge1xuICAgICAgICBzdXBlcihvcHRpb25zKTtcbiAgICAgICAgdGhpcy5uYXRpdmVVcGRhdGVyID0gcmVxdWlyZShcImVsZWN0cm9uXCIpLmF1dG9VcGRhdGVyO1xuICAgICAgICB0aGlzLm5hdGl2ZVVwZGF0ZXIub24oXCJlcnJvclwiLCBpdCA9PiB7XG4gICAgICAgICAgICB0aGlzLl9sb2dnZXIud2FybihpdCk7XG4gICAgICAgICAgICB0aGlzLmVtaXQoXCJlcnJvclwiLCBpdCk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLm5hdGl2ZVVwZGF0ZXIub24oXCJ1cGRhdGUtZG93bmxvYWRlZFwiLCAoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLl9sb2dnZXIuaW5mbyhgTmV3IHZlcnNpb24gJHt0aGlzLnVwZGF0ZUluZm8udmVyc2lvbn0gaGFzIGJlZW4gZG93bmxvYWRlZGApO1xuICAgICAgICAgICAgdGhpcy5lbWl0KChfbWFpbiB8fCBfbG9hZF9tYWluKCkpLlVQREFURV9ET1dOTE9BREVELCB0aGlzLnVwZGF0ZUluZm8pO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgZG9Eb3dubG9hZFVwZGF0ZSh1cGRhdGVJbmZvLCBjYW5jZWxsYXRpb25Ub2tlbikge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgICAgIHJldHVybiAoMCwgKF9ibHVlYmlyZExzdCB8fCBfbG9hZF9ibHVlYmlyZExzdCgpKS5jb3JvdXRpbmUpKGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCBmaWxlcyA9ICh5aWVsZCBfdGhpcy5wcm92aWRlcikucmVzb2x2ZUZpbGVzKHVwZGF0ZUluZm8pO1xuICAgICAgICAgICAgY29uc3QgemlwRmlsZUluZm8gPSAoMCwgKF9Qcm92aWRlciB8fCBfbG9hZF9Qcm92aWRlcigpKS5maW5kRmlsZSkoZmlsZXMsIFwiemlwXCIsIFtcInBrZ1wiLCBcImRtZ1wiXSk7XG4gICAgICAgICAgICBpZiAoemlwRmlsZUluZm8gPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRocm93ICgwLCAoX2J1aWxkZXJVdGlsUnVudGltZSB8fCBfbG9hZF9idWlsZGVyVXRpbFJ1bnRpbWUoKSkubmV3RXJyb3IpKGBaSVAgZmlsZSBub3QgcHJvdmlkZWQ6ICR7KDAsIChfYnVpbGRlclV0aWxSdW50aW1lIHx8IF9sb2FkX2J1aWxkZXJVdGlsUnVudGltZSgpKS5zYWZlU3RyaW5naWZ5SnNvbikoZmlsZXMpfWAsIFwiRVJSX1VQREFURVJfWklQX0ZJTEVfTk9UX0ZPVU5EXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3Qgc2VydmVyID0gKDAsIChfaHR0cCB8fCBfbG9hZF9odHRwKCkpLmNyZWF0ZVNlcnZlcikoKTtcbiAgICAgICAgICAgIHNlcnZlci5vbihcImNsb3NlXCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5fbG9nZ2VyLmluZm8oYFByb3h5IHNlcnZlciBmb3IgbmF0aXZlIFNxdWlycmVsLk1hYyBpcyBjbG9zZWQgKHdhcyBzdGFydGVkIHRvIGRvd25sb2FkICR7emlwRmlsZUluZm8udXJsLmhyZWZ9KWApO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBmdW5jdGlvbiBnZXRTZXJ2ZXJVcmwoKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgYWRkcmVzcyA9IHNlcnZlci5hZGRyZXNzKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGBodHRwOi8vJHthZGRyZXNzLmFkZHJlc3N9OiR7YWRkcmVzcy5wb3J0fWA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCByZXF1ZXN0SGVhZGVycyA9IHlpZWxkIF90aGlzLmNvbXB1dGVSZXF1ZXN0SGVhZGVycygpO1xuICAgICAgICAgICAgcmV0dXJuIHlpZWxkIG5ldyAoX2JsdWViaXJkTHN0MiB8fCBfbG9hZF9ibHVlYmlyZExzdDIoKSkuZGVmYXVsdChmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgICAgICAgICAgc2VydmVyLm9uKFwicmVxdWVzdFwiLCBmdW5jdGlvbiAocmVxdWVzdCwgcmVzcG9uc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVxdWVzdFVybCA9IHJlcXVlc3QudXJsO1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5fbG9nZ2VyLmluZm8oYCR7cmVxdWVzdFVybH0gcmVxdWVzdGVkYCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChyZXF1ZXN0VXJsID09PSBcIi9cIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZGF0YSA9IEJ1ZmZlci5mcm9tKGB7IFwidXJsXCI6IFwiJHtnZXRTZXJ2ZXJVcmwoKX0vYXBwLnppcFwiIH1gKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlLndyaXRlSGVhZCgyMDAsIHsgXCJDb250ZW50LVR5cGVcIjogXCJhcHBsaWNhdGlvbi9qc29uXCIsIFwiQ29udGVudC1MZW5ndGhcIjogZGF0YS5sZW5ndGggfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXNwb25zZS5lbmQoZGF0YSk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAocmVxdWVzdFVybC5zdGFydHNXaXRoKFwiL2FwcC56aXBcIikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBlcnJvck9jY3VycmVkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXNwb25zZS5vbihcImZpbmlzaFwiLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2V0SW1tZWRpYXRlKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBzZXJ2ZXIuY2xvc2UoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFlcnJvck9jY3VycmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5uYXRpdmVVcGRhdGVyLnJlbW92ZUxpc3RlbmVyKFwiZXJyb3JcIiwgcmVqZWN0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmUoW10pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5kb1Byb3h5VXBkYXRlRmlsZShyZXNwb25zZSwgemlwRmlsZUluZm8udXJsLmhyZWYsIHJlcXVlc3RIZWFkZXJzLCB6aXBGaWxlSW5mby5pbmZvLnNoYTUxMiwgY2FuY2VsbGF0aW9uVG9rZW4sIGZ1bmN0aW9uIChlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yT2NjdXJyZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlLndyaXRlSGVhZCg1MDApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXNwb25zZS5lbmQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5uYXRpdmVVcGRhdGVyLnJlbW92ZUxpc3RlbmVyKFwiZXJyb3JcIiwgcmVqZWN0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVqZWN0KG5ldyBFcnJvcihgQ2Fubm90IGRvd25sb2FkIFwiJHt6aXBGaWxlSW5mby51cmx9XCI6ICR7ZXJyb3J9YCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuX2xvZ2dlci53YXJuKGAke3JlcXVlc3RVcmx9IHJlcXVlc3RlZCwgYnV0IG5vdCBzdXBwb3J0ZWRgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlLndyaXRlSGVhZCg0MDQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2UuZW5kKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBzZXJ2ZXIubGlzdGVuKDAsIFwiMTI3LjAuMC4xXCIsIDE2LCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLm5hdGl2ZVVwZGF0ZXIuc2V0RmVlZFVSTChgJHtnZXRTZXJ2ZXJVcmwoKX1gLCB7IFwiQ2FjaGUtQ29udHJvbFwiOiBcIm5vLWNhY2hlXCIgfSk7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLm5hdGl2ZVVwZGF0ZXIub25jZShcImVycm9yXCIsIHJlamVjdCk7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLm5hdGl2ZVVwZGF0ZXIuY2hlY2tGb3JVcGRhdGVzKCk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSkoKTtcbiAgICB9XG4gICAgZG9Qcm94eVVwZGF0ZUZpbGUobmF0aXZlUmVzcG9uc2UsIHVybCwgaGVhZGVycywgc2hhNTEyLCBjYW5jZWxsYXRpb25Ub2tlbiwgZXJyb3JIYW5kbGVyKSB7XG4gICAgICAgIGNvbnN0IGRvd25sb2FkUmVxdWVzdCA9IHRoaXMuaHR0cEV4ZWN1dG9yLmRvUmVxdWVzdCgoMCwgKF9idWlsZGVyVXRpbFJ1bnRpbWUgfHwgX2xvYWRfYnVpbGRlclV0aWxSdW50aW1lKCkpLmNvbmZpZ3VyZVJlcXVlc3RPcHRpb25zRnJvbVVybCkodXJsLCB7IGhlYWRlcnMgfSksIGRvd25sb2FkUmVzcG9uc2UgPT4ge1xuICAgICAgICAgICAgaWYgKGRvd25sb2FkUmVzcG9uc2Uuc3RhdHVzQ29kZSA+PSA0MDApIHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBuYXRpdmVSZXNwb25zZS53cml0ZUhlYWQoNDA0KTtcbiAgICAgICAgICAgICAgICAgICAgbmF0aXZlUmVzcG9uc2UuZW5kKCk7XG4gICAgICAgICAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgICAgICAgZXJyb3JIYW5kbGVyKG5ldyBFcnJvcihgQ2Fubm90IGRvd25sb2FkIFwiJHt1cmx9XCIsIHN0YXR1cyAke2Rvd25sb2FkUmVzcG9uc2Uuc3RhdHVzQ29kZX06ICR7ZG93bmxvYWRSZXNwb25zZS5zdGF0dXNNZXNzYWdlfWApKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gaW4gdGVzdHMgRWxlY3Ryb24gTkVUIEFwaSBpcyBub3QgdXNlZCwgc28sIHdlIGhhdmUgdG8gaGFuZGxlIHJlZGlyZWN0LlxuICAgICAgICAgICAgY29uc3QgcmVkaXJlY3RVcmwgPSAoMCwgKF9idWlsZGVyVXRpbFJ1bnRpbWUgfHwgX2xvYWRfYnVpbGRlclV0aWxSdW50aW1lKCkpLnNhZmVHZXRIZWFkZXIpKGRvd25sb2FkUmVzcG9uc2UsIFwibG9jYXRpb25cIik7XG4gICAgICAgICAgICBpZiAocmVkaXJlY3RVcmwgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRoaXMuZG9Qcm94eVVwZGF0ZUZpbGUobmF0aXZlUmVzcG9uc2UsIHJlZGlyZWN0VXJsLCBoZWFkZXJzLCBzaGE1MTIsIGNhbmNlbGxhdGlvblRva2VuLCBlcnJvckhhbmRsZXIpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IG5hdGl2ZUhlYWRlcnMgPSB7IFwiQ29udGVudC1UeXBlXCI6IFwiYXBwbGljYXRpb24vemlwXCIgfTtcbiAgICAgICAgICAgIGNvbnN0IHN0cmVhbXMgPSBbXTtcbiAgICAgICAgICAgIGNvbnN0IGRvd25sb2FkTGlzdGVuZXJDb3VudCA9IHRoaXMubGlzdGVuZXJDb3VudCgoX21haW4gfHwgX2xvYWRfbWFpbigpKS5ET1dOTE9BRF9QUk9HUkVTUyk7XG4gICAgICAgICAgICB0aGlzLl9sb2dnZXIuaW5mbyhgJHsoX21haW4gfHwgX2xvYWRfbWFpbigpKS5ET1dOTE9BRF9QUk9HUkVTU30gbGlzdGVuZXIgY291bnQ6ICR7ZG93bmxvYWRMaXN0ZW5lckNvdW50fWApO1xuICAgICAgICAgICAgaWYgKGRvd25sb2FkTGlzdGVuZXJDb3VudCA+IDApIHtcbiAgICAgICAgICAgICAgICBjb25zdCBjb250ZW50TGVuZ3RoID0gKDAsIChfYnVpbGRlclV0aWxSdW50aW1lIHx8IF9sb2FkX2J1aWxkZXJVdGlsUnVudGltZSgpKS5zYWZlR2V0SGVhZGVyKShkb3dubG9hZFJlc3BvbnNlLCBcImNvbnRlbnQtbGVuZ3RoXCIpO1xuICAgICAgICAgICAgICAgIHRoaXMuX2xvZ2dlci5pbmZvKGBjb250ZW50TGVuZ3RoOiAke2NvbnRlbnRMZW5ndGh9YCk7XG4gICAgICAgICAgICAgICAgaWYgKGNvbnRlbnRMZW5ndGggIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBuYXRpdmVIZWFkZXJzW1wiQ29udGVudC1MZW5ndGhcIl0gPSBjb250ZW50TGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICBzdHJlYW1zLnB1c2gobmV3IChfYnVpbGRlclV0aWxSdW50aW1lIHx8IF9sb2FkX2J1aWxkZXJVdGlsUnVudGltZSgpKS5Qcm9ncmVzc0NhbGxiYWNrVHJhbnNmb3JtKHBhcnNlSW50KGNvbnRlbnRMZW5ndGgsIDEwKSwgY2FuY2VsbGF0aW9uVG9rZW4sIGl0ID0+IHRoaXMuZW1pdCgoX21haW4gfHwgX2xvYWRfbWFpbigpKS5ET1dOTE9BRF9QUk9HUkVTUywgaXQpKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbmF0aXZlUmVzcG9uc2Uud3JpdGVIZWFkKDIwMCwgbmF0aXZlSGVhZGVycyk7XG4gICAgICAgICAgICAvLyBmb3IgbWFjIG9ubHkgc2hhNTEyIGlzIHByb2R1Y2VkIChzaGEyNTYgaXMgcHVibGlzaGVkIGZvciB3aW5kb3dzIG9ubHkgdG8gcHJlc2VydmUgYmFja3dhcmQgY29tcGF0aWJpbGl0eSlcbiAgICAgICAgICAgIGlmIChzaGE1MTIgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIC8vIFwiaGV4XCIgdG8gZWFzeSBtaWdyYXRlIHRvIG5ldyBiYXNlNjQgZW5jb2RlZCBoYXNoICh3ZSBhbHJlYWR5IHByb2R1Y2VzIGxhdGVzdC1tYWMueW1sIHdpdGggaGV4IGVuY29kZWQgaGFzaClcbiAgICAgICAgICAgICAgICBzdHJlYW1zLnB1c2gobmV3IChfYnVpbGRlclV0aWxSdW50aW1lIHx8IF9sb2FkX2J1aWxkZXJVdGlsUnVudGltZSgpKS5EaWdlc3RUcmFuc2Zvcm0oc2hhNTEyLCBcInNoYTUxMlwiLCBzaGE1MTIubGVuZ3RoID09PSAxMjggJiYgIXNoYTUxMi5pbmNsdWRlcyhcIitcIikgJiYgIXNoYTUxMi5pbmNsdWRlcyhcIlpcIikgJiYgIXNoYTUxMi5pbmNsdWRlcyhcIj1cIikgPyBcImhleFwiIDogXCJiYXNlNjRcIikpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc3RyZWFtcy5wdXNoKG5hdGl2ZVJlc3BvbnNlKTtcbiAgICAgICAgICAgIGxldCBsYXN0U3RyZWFtID0gZG93bmxvYWRSZXNwb25zZTtcbiAgICAgICAgICAgIGZvciAoY29uc3Qgc3RyZWFtIG9mIHN0cmVhbXMpIHtcbiAgICAgICAgICAgICAgICBzdHJlYW0ub24oXCJlcnJvclwiLCBlcnJvckhhbmRsZXIpO1xuICAgICAgICAgICAgICAgIGxhc3RTdHJlYW0gPSBsYXN0U3RyZWFtLnBpcGUoc3RyZWFtKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGRvd25sb2FkUmVxdWVzdC5vbihcInJlZGlyZWN0XCIsIChzdGF0dXNDb2RlLCBtZXRob2QsIHJlZGlyZWN0VXJsKSA9PiB7XG4gICAgICAgICAgICBpZiAoaGVhZGVycy5BdXRob3JpemF0aW9uICE9IG51bGwgJiYgaGVhZGVycy5BdXRob3JpemF0aW9uLnN0YXJ0c1dpdGgoXCJ0b2tlblwiKSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHBhcnNlZE5ld1VybCA9IG5ldyBVUkwocmVkaXJlY3RVcmwpO1xuICAgICAgICAgICAgICAgIGlmIChwYXJzZWROZXdVcmwuaG9zdG5hbWUuZW5kc1dpdGgoXCIuYW1hem9uYXdzLmNvbVwiKSkge1xuICAgICAgICAgICAgICAgICAgICBkZWxldGUgaGVhZGVycy5BdXRob3JpemF0aW9uO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuZG9Qcm94eVVwZGF0ZUZpbGUobmF0aXZlUmVzcG9uc2UsIHJlZGlyZWN0VXJsLCBoZWFkZXJzLCBzaGE1MTIsIGNhbmNlbGxhdGlvblRva2VuLCBlcnJvckhhbmRsZXIpO1xuICAgICAgICB9KTtcbiAgICAgICAgZG93bmxvYWRSZXF1ZXN0Lm9uKFwiZXJyb3JcIiwgZXJyb3JIYW5kbGVyKTtcbiAgICAgICAgZG93bmxvYWRSZXF1ZXN0LmVuZCgpO1xuICAgIH1cbiAgICBxdWl0QW5kSW5zdGFsbCgpIHtcbiAgICAgICAgdGhpcy5uYXRpdmVVcGRhdGVyLnF1aXRBbmRJbnN0YWxsKCk7XG4gICAgfVxufVxuZXhwb3J0cy5NYWNVcGRhdGVyID0gTWFjVXBkYXRlcjsgLy8jIHNvdXJjZU1hcHBpbmdVUkw9TWFjVXBkYXRlci5qcy5tYXBcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvZWxlY3Ryb24tdXBkYXRlci9vdXQvTWFjVXBkYXRlci5qcyIsIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLkFwcEltYWdlVXBkYXRlciA9IHVuZGVmaW5lZDtcblxudmFyIF9ibHVlYmlyZExzdDtcblxuZnVuY3Rpb24gX2xvYWRfYmx1ZWJpcmRMc3QoKSB7XG4gICAgcmV0dXJuIF9ibHVlYmlyZExzdCA9IHJlcXVpcmUoXCJibHVlYmlyZC1sc3RcIik7XG59XG5cbnZhciBfYmx1ZWJpcmRMc3QyO1xuXG5mdW5jdGlvbiBfbG9hZF9ibHVlYmlyZExzdDIoKSB7XG4gICAgcmV0dXJuIF9ibHVlYmlyZExzdDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJibHVlYmlyZC1sc3RcIikpO1xufVxuXG52YXIgX2J1aWxkZXJVdGlsUnVudGltZTtcblxuZnVuY3Rpb24gX2xvYWRfYnVpbGRlclV0aWxSdW50aW1lKCkge1xuICAgIHJldHVybiBfYnVpbGRlclV0aWxSdW50aW1lID0gcmVxdWlyZShcImJ1aWxkZXItdXRpbC1ydW50aW1lXCIpO1xufVxuXG52YXIgX2NoaWxkX3Byb2Nlc3M7XG5cbmZ1bmN0aW9uIF9sb2FkX2NoaWxkX3Byb2Nlc3MoKSB7XG4gICAgcmV0dXJuIF9jaGlsZF9wcm9jZXNzID0gcmVxdWlyZShcImNoaWxkX3Byb2Nlc3NcIik7XG59XG5cbnZhciBfZWxlY3Ryb25Jc0RldjtcblxuZnVuY3Rpb24gX2xvYWRfZWxlY3Ryb25Jc0RldigpIHtcbiAgICByZXR1cm4gX2VsZWN0cm9uSXNEZXYgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJlbGVjdHJvbi1pcy1kZXZcIikpO1xufVxuXG52YXIgX2ZzRXh0cmFQO1xuXG5mdW5jdGlvbiBfbG9hZF9mc0V4dHJhUCgpIHtcbiAgICByZXR1cm4gX2ZzRXh0cmFQID0gcmVxdWlyZShcImZzLWV4dHJhLXBcIik7XG59XG5cbnZhciBfcGF0aCA9IF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKHJlcXVpcmUoXCJwYXRoXCIpKTtcblxucmVxdWlyZShcInNvdXJjZS1tYXAtc3VwcG9ydC9yZWdpc3RlclwiKTtcblxudmFyIF9CYXNlVXBkYXRlcjtcblxuZnVuY3Rpb24gX2xvYWRfQmFzZVVwZGF0ZXIoKSB7XG4gICAgcmV0dXJuIF9CYXNlVXBkYXRlciA9IHJlcXVpcmUoXCIuL0Jhc2VVcGRhdGVyXCIpO1xufVxuXG52YXIgX0ZpbGVXaXRoRW1iZWRkZWRCbG9ja01hcERpZmZlcmVudGlhbERvd25sb2FkZXI7XG5cbmZ1bmN0aW9uIF9sb2FkX0ZpbGVXaXRoRW1iZWRkZWRCbG9ja01hcERpZmZlcmVudGlhbERvd25sb2FkZXIoKSB7XG4gICAgcmV0dXJuIF9GaWxlV2l0aEVtYmVkZGVkQmxvY2tNYXBEaWZmZXJlbnRpYWxEb3dubG9hZGVyID0gcmVxdWlyZShcIi4vZGlmZmVyZW50aWFsRG93bmxvYWRlci9GaWxlV2l0aEVtYmVkZGVkQmxvY2tNYXBEaWZmZXJlbnRpYWxEb3dubG9hZGVyXCIpO1xufVxuXG52YXIgX21haW47XG5cbmZ1bmN0aW9uIF9sb2FkX21haW4oKSB7XG4gICAgcmV0dXJuIF9tYWluID0gcmVxdWlyZShcIi4vbWFpblwiKTtcbn1cblxudmFyIF9Qcm92aWRlcjtcblxuZnVuY3Rpb24gX2xvYWRfUHJvdmlkZXIoKSB7XG4gICAgcmV0dXJuIF9Qcm92aWRlciA9IHJlcXVpcmUoXCIuL1Byb3ZpZGVyXCIpO1xufVxuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChvYmopIHsgaWYgKG9iaiAmJiBvYmouX19lc01vZHVsZSkgeyByZXR1cm4gb2JqOyB9IGVsc2UgeyB2YXIgbmV3T2JqID0ge307IGlmIChvYmogIT0gbnVsbCkgeyBmb3IgKHZhciBrZXkgaW4gb2JqKSB7IGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBrZXkpKSBuZXdPYmpba2V5XSA9IG9ialtrZXldOyB9IH0gbmV3T2JqLmRlZmF1bHQgPSBvYmo7IHJldHVybiBuZXdPYmo7IH0gfVxuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5jbGFzcyBBcHBJbWFnZVVwZGF0ZXIgZXh0ZW5kcyAoX0Jhc2VVcGRhdGVyIHx8IF9sb2FkX0Jhc2VVcGRhdGVyKCkpLkJhc2VVcGRhdGVyIHtcbiAgICBjb25zdHJ1Y3RvcihvcHRpb25zLCBhcHApIHtcbiAgICAgICAgc3VwZXIob3B0aW9ucywgYXBwKTtcbiAgICB9XG4gICAgY2hlY2tGb3JVcGRhdGVzQW5kTm90aWZ5KCkge1xuICAgICAgICBpZiAoKF9lbGVjdHJvbklzRGV2IHx8IF9sb2FkX2VsZWN0cm9uSXNEZXYoKSkuZGVmYXVsdCkge1xuICAgICAgICAgICAgcmV0dXJuIChfYmx1ZWJpcmRMc3QyIHx8IF9sb2FkX2JsdWViaXJkTHN0MigpKS5kZWZhdWx0LnJlc29sdmUobnVsbCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHByb2Nlc3MuZW52LkFQUElNQUdFID09IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuX2xvZ2dlci53YXJuKFwiQVBQSU1BR0UgZW52IGlzIG5vdCBkZWZpbmVkLCBjdXJyZW50IGFwcGxpY2F0aW9uIGlzIG5vdCBhbiBBcHBJbWFnZVwiKTtcbiAgICAgICAgICAgIHJldHVybiAoX2JsdWViaXJkTHN0MiB8fCBfbG9hZF9ibHVlYmlyZExzdDIoKSkuZGVmYXVsdC5yZXNvbHZlKG51bGwpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzdXBlci5jaGVja0ZvclVwZGF0ZXNBbmROb3RpZnkoKTtcbiAgICB9XG4gICAgLyoqKiBAcHJpdmF0ZSAqL1xuICAgIGRvRG93bmxvYWRVcGRhdGUodXBkYXRlSW5mbywgY2FuY2VsbGF0aW9uVG9rZW4pIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgICAgICByZXR1cm4gKDAsIChfYmx1ZWJpcmRMc3QgfHwgX2xvYWRfYmx1ZWJpcmRMc3QoKSkuY29yb3V0aW5lKShmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3QgcHJvdmlkZXIgPSB5aWVsZCBfdGhpcy5wcm92aWRlcjtcbiAgICAgICAgICAgIGNvbnN0IGZpbGVJbmZvID0gKDAsIChfUHJvdmlkZXIgfHwgX2xvYWRfUHJvdmlkZXIoKSkuZmluZEZpbGUpKHByb3ZpZGVyLnJlc29sdmVGaWxlcyh1cGRhdGVJbmZvKSwgXCJBcHBJbWFnZVwiKTtcbiAgICAgICAgICAgIGNvbnN0IHJlcXVlc3RIZWFkZXJzID0geWllbGQgX3RoaXMuY29tcHV0ZVJlcXVlc3RIZWFkZXJzKCk7XG4gICAgICAgICAgICBjb25zdCBkb3dubG9hZE9wdGlvbnMgPSB7XG4gICAgICAgICAgICAgICAgc2tpcERpckNyZWF0aW9uOiB0cnVlLFxuICAgICAgICAgICAgICAgIGhlYWRlcnM6IHJlcXVlc3RIZWFkZXJzLFxuICAgICAgICAgICAgICAgIGNhbmNlbGxhdGlvblRva2VuLFxuICAgICAgICAgICAgICAgIHNoYTUxMjogZmlsZUluZm8uaW5mby5zaGE1MTJcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBsZXQgaW5zdGFsbGVyUGF0aCA9IF90aGlzLmRvd25sb2FkZWRVcGRhdGVIZWxwZXIuZ2V0RG93bmxvYWRlZEZpbGUodXBkYXRlSW5mbywgZmlsZUluZm8pO1xuICAgICAgICAgICAgaWYgKGluc3RhbGxlclBhdGggIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBbaW5zdGFsbGVyUGF0aF07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB5aWVsZCBfdGhpcy5leGVjdXRlRG93bmxvYWQoZG93bmxvYWRPcHRpb25zLCBmaWxlSW5mbywgKCgpID0+IHtcbiAgICAgICAgICAgICAgICB2YXIgX3JlZiA9ICgwLCAoX2JsdWViaXJkTHN0IHx8IF9sb2FkX2JsdWViaXJkTHN0KCkpLmNvcm91dGluZSkoZnVuY3Rpb24qICh0ZW1wRGlyLCBkZXN0aW5hdGlvbkZpbGUpIHtcbiAgICAgICAgICAgICAgICAgICAgaW5zdGFsbGVyUGF0aCA9IGRlc3RpbmF0aW9uRmlsZTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgb2xkRmlsZSA9IHByb2Nlc3MuZW52LkFQUElNQUdFO1xuICAgICAgICAgICAgICAgICAgICBpZiAob2xkRmlsZSA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyAoMCwgKF9idWlsZGVyVXRpbFJ1bnRpbWUgfHwgX2xvYWRfYnVpbGRlclV0aWxSdW50aW1lKCkpLm5ld0Vycm9yKShcIkFQUElNQUdFIGVudiBpcyBub3QgZGVmaW5lZFwiLCBcIkVSUl9VUERBVEVSX09MRF9GSUxFX05PVF9GT1VORFwiKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBsZXQgaXNEb3dubG9hZEZ1bGwgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHlpZWxkIG5ldyAoX0ZpbGVXaXRoRW1iZWRkZWRCbG9ja01hcERpZmZlcmVudGlhbERvd25sb2FkZXIgfHwgX2xvYWRfRmlsZVdpdGhFbWJlZGRlZEJsb2NrTWFwRGlmZmVyZW50aWFsRG93bmxvYWRlcigpKS5GaWxlV2l0aEVtYmVkZGVkQmxvY2tNYXBEaWZmZXJlbnRpYWxEb3dubG9hZGVyKGZpbGVJbmZvLmluZm8sIF90aGlzLmh0dHBFeGVjdXRvciwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ld1VybDogZmlsZUluZm8udXJsLmhyZWYsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb2xkRmlsZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsb2dnZXI6IF90aGlzLl9sb2dnZXIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV3RmlsZTogaW5zdGFsbGVyUGF0aCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB1c2VNdWx0aXBsZVJhbmdlUmVxdWVzdDogcHJvdmlkZXIudXNlTXVsdGlwbGVSYW5nZVJlcXVlc3QsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVxdWVzdEhlYWRlcnNcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pLmRvd25sb2FkKCk7XG4gICAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLl9sb2dnZXIuZXJyb3IoYENhbm5vdCBkb3dubG9hZCBkaWZmZXJlbnRpYWxseSwgZmFsbGJhY2sgdG8gZnVsbCBkb3dubG9hZDogJHtlLnN0YWNrIHx8IGV9YCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBkdXJpbmcgdGVzdCAoZGV2ZWxvcGVyIG1hY2hpbmUgbWFjKSB3ZSBtdXN0IHRocm93IGVycm9yXG4gICAgICAgICAgICAgICAgICAgICAgICBpc0Rvd25sb2FkRnVsbCA9IHByb2Nlc3MucGxhdGZvcm0gPT09IFwibGludXhcIjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoaXNEb3dubG9hZEZ1bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHlpZWxkIF90aGlzLmh0dHBFeGVjdXRvci5kb3dubG9hZChmaWxlSW5mby51cmwuaHJlZiwgaW5zdGFsbGVyUGF0aCwgZG93bmxvYWRPcHRpb25zKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB5aWVsZCAoMCwgKF9mc0V4dHJhUCB8fCBfbG9hZF9mc0V4dHJhUCgpKS5jaG1vZCkoaW5zdGFsbGVyUGF0aCwgMG83NTUpO1xuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChfeCwgX3gyKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBfcmVmLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0pKCkpO1xuICAgICAgICAgICAgX3RoaXMuZG93bmxvYWRlZFVwZGF0ZUhlbHBlci5zZXREb3dubG9hZGVkRmlsZShpbnN0YWxsZXJQYXRoLCBudWxsLCB1cGRhdGVJbmZvLCBmaWxlSW5mbyk7XG4gICAgICAgICAgICBfdGhpcy5hZGRRdWl0SGFuZGxlcigpO1xuICAgICAgICAgICAgX3RoaXMuZW1pdCgoX21haW4gfHwgX2xvYWRfbWFpbigpKS5VUERBVEVfRE9XTkxPQURFRCwgX3RoaXMudXBkYXRlSW5mbyk7XG4gICAgICAgICAgICByZXR1cm4gW2luc3RhbGxlclBhdGhdO1xuICAgICAgICB9KSgpO1xuICAgIH1cbiAgICBkb0luc3RhbGwoaW5zdGFsbGVyUGF0aCwgaXNTaWxlbnQsIGlzUnVuQWZ0ZXIpIHtcbiAgICAgICAgY29uc3QgYXBwSW1hZ2VGaWxlID0gcHJvY2Vzcy5lbnYuQVBQSU1BR0U7XG4gICAgICAgIGlmIChhcHBJbWFnZUZpbGUgPT0gbnVsbCkge1xuICAgICAgICAgICAgdGhyb3cgKDAsIChfYnVpbGRlclV0aWxSdW50aW1lIHx8IF9sb2FkX2J1aWxkZXJVdGlsUnVudGltZSgpKS5uZXdFcnJvcikoXCJBUFBJTUFHRSBlbnYgaXMgbm90IGRlZmluZWRcIiwgXCJFUlJfVVBEQVRFUl9PTERfRklMRV9OT1RfRk9VTkRcIik7XG4gICAgICAgIH1cbiAgICAgICAgLy8gaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9hLzE3MTIwNTEvMTkxMDE5MVxuICAgICAgICAoMCwgKF9mc0V4dHJhUCB8fCBfbG9hZF9mc0V4dHJhUCgpKS51bmxpbmtTeW5jKShhcHBJbWFnZUZpbGUpO1xuICAgICAgICBsZXQgZGVzdGluYXRpb247XG4gICAgICAgIGlmIChfcGF0aC5iYXNlbmFtZShpbnN0YWxsZXJQYXRoKSA9PT0gX3BhdGguYmFzZW5hbWUoYXBwSW1hZ2VGaWxlKSkge1xuICAgICAgICAgICAgLy8gbm8gdmVyc2lvbiBpbiB0aGUgZmlsZSBuYW1lLCBvdmVyd3JpdGUgZXhpc3RpbmdcbiAgICAgICAgICAgIGRlc3RpbmF0aW9uID0gYXBwSW1hZ2VGaWxlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZGVzdGluYXRpb24gPSBfcGF0aC5qb2luKF9wYXRoLmRpcm5hbWUoYXBwSW1hZ2VGaWxlKSwgX3BhdGguYmFzZW5hbWUoaW5zdGFsbGVyUGF0aCkpO1xuICAgICAgICB9XG4gICAgICAgICgwLCAoX2NoaWxkX3Byb2Nlc3MgfHwgX2xvYWRfY2hpbGRfcHJvY2VzcygpKS5leGVjRmlsZVN5bmMpKFwibXZcIiwgW1wiLWZcIiwgaW5zdGFsbGVyUGF0aCwgZGVzdGluYXRpb25dKTtcbiAgICAgICAgY29uc3QgZW52ID0gT2JqZWN0LmFzc2lnbih7fSwgcHJvY2Vzcy5lbnYsIHsgQVBQSU1BR0VfU0lMRU5UX0lOU1RBTEw6IFwidHJ1ZVwiIH0pO1xuICAgICAgICBpZiAoaXNSdW5BZnRlcikge1xuICAgICAgICAgICAgKDAsIChfY2hpbGRfcHJvY2VzcyB8fCBfbG9hZF9jaGlsZF9wcm9jZXNzKCkpLnNwYXduKShkZXN0aW5hdGlvbiwgW10sIHtcbiAgICAgICAgICAgICAgICBkZXRhY2hlZDogdHJ1ZSxcbiAgICAgICAgICAgICAgICBzdGRpbzogXCJpZ25vcmVcIixcbiAgICAgICAgICAgICAgICBlbnZcbiAgICAgICAgICAgIH0pLnVucmVmKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBlbnYuQVBQSU1BR0VfRVhJVF9BRlRFUl9JTlNUQUxMID0gXCJ0cnVlXCI7XG4gICAgICAgICAgICAoMCwgKF9jaGlsZF9wcm9jZXNzIHx8IF9sb2FkX2NoaWxkX3Byb2Nlc3MoKSkuZXhlY0ZpbGVTeW5jKShkZXN0aW5hdGlvbiwgW10sIHsgZW52IH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbn1cbmV4cG9ydHMuQXBwSW1hZ2VVcGRhdGVyID0gQXBwSW1hZ2VVcGRhdGVyOyAvLyMgc291cmNlTWFwcGluZ1VSTD1BcHBJbWFnZVVwZGF0ZXIuanMubWFwXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2VsZWN0cm9uLXVwZGF0ZXIvb3V0L0FwcEltYWdlVXBkYXRlci5qcyIsIid1c2Ugc3RyaWN0JztcblxuaWYgKHByb2Nlc3MudHlwZSA9PT0gJ3JlbmRlcmVyJykge1xuICBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vcmVuZGVyZXInKTtcbn0gZWxzZSB7XG4gIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9tYWluJyk7XG59XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2VsZWN0cm9uLWxvZy9pbmRleC5qcyIsIid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSBudWxsO1xuXG52YXIgaXBjUmVuZGVyZXI7XG50cnkge1xuICBpcGNSZW5kZXJlciA9IHJlcXVpcmUoJ2VsZWN0cm9uJykuaXBjUmVuZGVyZXI7XG59IGNhdGNoIChlKSB7XG4gIGlwY1JlbmRlcmVyID0gbnVsbDtcbn1cblxudmFyIG9yaWdpbmFsQ29uc29sZSA9IHJlcXVpcmUoJy4vbGliL29yaWdpbmFsLWNvbnNvbGUnKTtcblxuaWYgKGlwY1JlbmRlcmVyKSB7XG4gIG1vZHVsZS5leHBvcnRzID0ge1xuICAgIGVycm9yOiAgIGxvZy5iaW5kKG51bGwsICdlcnJvcicpLFxuICAgIHdhcm46ICAgIGxvZy5iaW5kKG51bGwsICd3YXJuJyksXG4gICAgaW5mbzogICAgbG9nLmJpbmQobnVsbCwgJ2luZm8nKSxcbiAgICB2ZXJib3NlOiBsb2cuYmluZChudWxsLCAndmVyYm9zZScpLFxuICAgIGRlYnVnOiAgIGxvZy5iaW5kKG51bGwsICdkZWJ1ZycpLFxuICAgIHNpbGx5OiAgIGxvZy5iaW5kKG51bGwsICdzaWxseScpLFxuICAgIGxvZzogICAgIGxvZy5iaW5kKG51bGwsICdpbmZvJylcbiAgfTtcblxuICBtb2R1bGUuZXhwb3J0cy5kZWZhdWx0ID0gbW9kdWxlLmV4cG9ydHM7XG5cbiAgaXBjUmVuZGVyZXIub24oJ19fRUxFQ1RST05fTE9HX1JFTkRFUkVSX18nLCBmdW5jdGlvbihldmVudCwgbGV2ZWwsIHRleHQpIHtcbiAgICBpZiAobGV2ZWwgPT09ICd2ZXJib3NlJykge1xuICAgICAgbGV2ZWwgPSAnbG9nJztcbiAgICB9IGVsc2UgaWYgKGxldmVsID09PSAnc2lsbHknKSB7XG4gICAgICBsZXZlbCA9ICdkZWJ1Zyc7XG4gICAgfVxuXG4gICAgb3JpZ2luYWxDb25zb2xlW2xldmVsXS5jYWxsKG9yaWdpbmFsQ29uc29sZS5jb250ZXh0LCB0ZXh0KTtcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIGxvZygpIHtcbiAgdmFyIGRhdGEgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpO1xuXG4gIGRhdGEgPSBkYXRhLm1hcChmdW5jdGlvbihvYmopIHtcbiAgICBpZiAob2JqIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgIG9iaiA9IG9iai5zdGFjayB8fCBvYmo7XG4gICAgfVxuXG4gICAgcmV0dXJuIG9iajtcbiAgfSk7XG5cbiAgaXBjUmVuZGVyZXIuc2VuZCgnX19FTEVDVFJPTl9MT0dfXycsIGRhdGEpO1xufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2VsZWN0cm9uLWxvZy9yZW5kZXJlci5qcyIsIid1c2Ugc3RyaWN0JztcblxudmFyIGVsZWN0cm9uO1xudHJ5IHtcbiAgZWxlY3Ryb24gPSByZXF1aXJlKCdlbGVjdHJvbicpO1xufSBjYXRjaCAoZSkge1xuICBlbGVjdHJvbiA9IG51bGw7XG59XG5cbnZhciBsb2cgICAgICAgICAgICAgICAgICAgICAgPSByZXF1aXJlKCcuL2xpYi9sb2cnKTtcbnZhciB0cmFuc3BvcnRDb25zb2xlICAgICAgICAgPSByZXF1aXJlKCcuL2xpYi90cmFuc3BvcnRzL2NvbnNvbGUnKTtcbnZhciB0cmFuc3BvcnRGaWxlICAgICAgICAgICAgPSByZXF1aXJlKCcuL2xpYi90cmFuc3BvcnRzL2ZpbGUnKTtcbnZhciB0cmFuc3BvcnRMb2dTICAgICAgICAgICAgPSByZXF1aXJlKCcuL2xpYi90cmFuc3BvcnRzL2xvZy1zJyk7XG52YXIgdHJhbnNwb3J0UmVuZGVyZXJDb25zb2xlID0gcmVxdWlyZSgnLi9saWIvdHJhbnNwb3J0cy9yZW5kZXJlci1jb25zb2xlJyk7XG5cbnZhciB0cmFuc3BvcnRzID0ge1xuICBjb25zb2xlOiB0cmFuc3BvcnRDb25zb2xlLFxuICBmaWxlOiB0cmFuc3BvcnRGaWxlLFxuICBsb2dTOiB0cmFuc3BvcnRMb2dTLFxuICByZW5kZXJlckNvbnNvbGU6IHRyYW5zcG9ydFJlbmRlcmVyQ29uc29sZVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIHRyYW5zcG9ydHM6IHRyYW5zcG9ydHMsXG5cbiAgZXJyb3I6ICAgbG9nLmJpbmQobnVsbCwgdHJhbnNwb3J0cywgJ2Vycm9yJyksXG4gIHdhcm46ICAgIGxvZy5iaW5kKG51bGwsIHRyYW5zcG9ydHMsICd3YXJuJyksXG4gIGluZm86ICAgIGxvZy5iaW5kKG51bGwsIHRyYW5zcG9ydHMsICdpbmZvJyksXG4gIHZlcmJvc2U6IGxvZy5iaW5kKG51bGwsIHRyYW5zcG9ydHMsICd2ZXJib3NlJyksXG4gIGRlYnVnOiAgIGxvZy5iaW5kKG51bGwsIHRyYW5zcG9ydHMsICdkZWJ1ZycpLFxuICBzaWxseTogICBsb2cuYmluZChudWxsLCB0cmFuc3BvcnRzLCAnc2lsbHknKSxcbiAgbG9nOiAgICAgbG9nLmJpbmQobnVsbCwgdHJhbnNwb3J0cywgJ2luZm8nKVxufTtcblxubW9kdWxlLmV4cG9ydHMuZGVmYXVsdCA9IG1vZHVsZS5leHBvcnRzO1xuXG5pZiAoZWxlY3Ryb24gJiYgZWxlY3Ryb24uaXBjTWFpbikge1xuICBlbGVjdHJvbi5pcGNNYWluLm9uKCdfX0VMRUNUUk9OX0xPR19fJywgb25SZW5kZXJlckxvZyk7XG4gIHZhciBhcHBOYW1lID0gZWxlY3Ryb24uYXBwLmdldE5hbWUoKTtcbiAgaWYgKGFwcE5hbWUgIT09ICdFbGVjdHJvbicpIHtcbiAgICB0cmFuc3BvcnRGaWxlLmFwcE5hbWUgPSBhcHBOYW1lO1xuICB9XG59XG5cbmZ1bmN0aW9uIG9uUmVuZGVyZXJMb2coZXZlbnQsIGRhdGEpIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkoZGF0YSkpIHtcbiAgICBkYXRhLnVuc2hpZnQodHJhbnNwb3J0cyk7XG4gICAgbG9nLmFwcGx5KG51bGwsIGRhdGEpO1xuICB9XG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvZWxlY3Ryb24tbG9nL21haW4uanMiLCIvLyBqc2hpbnQgLVcwNDBcbid1c2Ugc3RyaWN0JztcblxudmFyIExFVkVMUyA9IFsnZXJyb3InLCAnd2FybicsICdpbmZvJywgJ3ZlcmJvc2UnLCAnZGVidWcnLCAnc2lsbHknXTtcblxubW9kdWxlLmV4cG9ydHMgPSBsb2c7XG5cbmZ1bmN0aW9uIGxvZyh0cmFuc3BvcnRzLCBsZXZlbCwgdGV4dCkge1xuICB2YXIgZGF0YSA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMik7XG5cbiAgdmFyIG1zZyA9IHtcbiAgICBkYXRhOiBkYXRhLFxuICAgIGRhdGU6IG5ldyBEYXRlKCksXG4gICAgbGV2ZWw6IGxldmVsXG4gIH07XG5cbiAgZm9yICh2YXIgaSBpbiB0cmFuc3BvcnRzKSB7XG4gICAgLy8ganNoaW50IC1XMDg5XG4gICAgaWYgKCF0cmFuc3BvcnRzLmhhc093blByb3BlcnR5KGkpIHx8IHR5cGVvZiB0cmFuc3BvcnRzW2ldICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICB2YXIgdHJhbnNwb3J0ID0gdHJhbnNwb3J0c1tpXTtcblxuICAgIGlmICh0cmFuc3BvcnQgPT09IGZhbHNlIHx8ICFjb21wYXJlTGV2ZWxzKHRyYW5zcG9ydC5sZXZlbCwgbGV2ZWwpKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICBpZiAodHJhbnNwb3J0LmxldmVsID09PSBmYWxzZSkgY29udGludWU7XG5cbiAgICB0cmFuc3BvcnQuY2FsbChudWxsLCBtc2cpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGNvbXBhcmVMZXZlbHMocGFzc0xldmVsLCBjaGVja0xldmVsKSB7XG4gIHZhciBwYXNzID0gTEVWRUxTLmluZGV4T2YocGFzc0xldmVsKTtcbiAgdmFyIGNoZWNrID0gTEVWRUxTLmluZGV4T2YoY2hlY2tMZXZlbCk7XG4gIGlmIChjaGVjayA9PT0gLTEgfHwgcGFzcyA9PT0gLTEpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICByZXR1cm4gY2hlY2sgPD0gcGFzcztcbn1cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvZWxlY3Ryb24tbG9nL2xpYi9sb2cuanMiLCIndXNlIHN0cmljdCc7XG5cbnZhciBmcyAgICAgICAgICAgICAgID0gcmVxdWlyZSgnZnMnKTtcbnZhciBFT0wgICAgICAgICAgICAgID0gcmVxdWlyZSgnb3MnKS5FT0w7XG52YXIgZm9ybWF0ICAgICAgICAgICA9IHJlcXVpcmUoJy4uLy4uL2Zvcm1hdCcpO1xudmFyIGNvbnNvbGVUcmFuc3BvcnQgPSByZXF1aXJlKCcuLi9jb25zb2xlJyk7XG52YXIgZmluZExvZ1BhdGggICAgICA9IHJlcXVpcmUoJy4vZmluZC1sb2ctcGF0aCcpO1xuXG50cmFuc3BvcnQuZmluZExvZ1BhdGggID0gZmluZExvZ1BhdGg7XG50cmFuc3BvcnQuZm9ybWF0ICAgICAgID0gJ1t7eX0te219LXtkfSB7aH06e2l9OntzfS57bXN9XSBbe2xldmVsfV0ge3RleHR9JztcbnRyYW5zcG9ydC5sZXZlbCAgICAgICAgPSAnd2Fybic7XG50cmFuc3BvcnQubWF4U2l6ZSAgICAgID0gMTAyNCAqIDEwMjQ7XG50cmFuc3BvcnQuc3RyZWFtQ29uZmlnID0gdW5kZWZpbmVkO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHRyYW5zcG9ydDtcblxuZnVuY3Rpb24gdHJhbnNwb3J0KG1zZykge1xuICB2YXIgdGV4dCA9IGZvcm1hdC5mb3JtYXQobXNnLCB0cmFuc3BvcnQuZm9ybWF0KSArIEVPTDtcblxuICBpZiAodHJhbnNwb3J0LnN0cmVhbSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgaW5pdFN0ZWFtQ29uZmlnKCk7XG4gICAgb3BlblN0cmVhbSgpO1xuICB9XG5cbiAgaWYgKHRyYW5zcG9ydC5sZXZlbCA9PT0gZmFsc2UpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgbmVlZExvZ1JvdGF0aW9uID0gdHJhbnNwb3J0Lm1heFNpemUgPiAwICYmXG4gICAgZ2V0U3RyZWFtU2l6ZSh0cmFuc3BvcnQuc3RyZWFtKSA+IHRyYW5zcG9ydC5tYXhTaXplO1xuXG4gIGlmIChuZWVkTG9nUm90YXRpb24pIHtcbiAgICBhcmNoaXZlTG9nKHRyYW5zcG9ydC5zdHJlYW0pO1xuICAgIG9wZW5TdHJlYW0oKTtcbiAgfVxuXG4gIHRyYW5zcG9ydC5zdHJlYW0ud3JpdGUodGV4dCk7XG59XG5cbmZ1bmN0aW9uIGluaXRTdGVhbUNvbmZpZygpIHtcbiAgdHJhbnNwb3J0LmZpbGUgPSB0cmFuc3BvcnQuZmlsZSB8fCBmaW5kTG9nUGF0aCh0cmFuc3BvcnQuYXBwTmFtZSk7XG5cbiAgaWYgKCF0cmFuc3BvcnQuZmlsZSkge1xuICAgIHRyYW5zcG9ydC5sZXZlbCA9IGZhbHNlO1xuICAgIGxvZ0NvbnNvbGUoJ0NvdWxkIG5vdCBzZXQgYSBsb2cgZmlsZScpO1xuICB9XG59XG5cbmZ1bmN0aW9uIG9wZW5TdHJlYW0oKSB7XG4gIGlmICh0cmFuc3BvcnQubGV2ZWwgPT09IGZhbHNlKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdHJhbnNwb3J0LnN0cmVhbSA9IGZzLmNyZWF0ZVdyaXRlU3RyZWFtKFxuICAgIHRyYW5zcG9ydC5maWxlLFxuICAgIHRyYW5zcG9ydC5zdHJlYW1Db25maWcgfHwgeyBmbGFnczogJ2EnIH1cbiAgKTtcbn1cblxuZnVuY3Rpb24gZ2V0U3RyZWFtU2l6ZShzdHJlYW0pIHtcbiAgaWYgKCFzdHJlYW0pIHtcbiAgICByZXR1cm4gMDtcbiAgfVxuXG4gIGlmIChzdHJlYW0ubG9nU2l6ZUF0U3RhcnQgPT09IHVuZGVmaW5lZCkge1xuICAgIHRyeSB7XG4gICAgICBzdHJlYW0ubG9nU2l6ZUF0U3RhcnQgPSBmcy5zdGF0U3luYyhzdHJlYW0ucGF0aCkuc2l6ZTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBzdHJlYW0ubG9nU2l6ZUF0U3RhcnQgPSAwO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBzdHJlYW0ubG9nU2l6ZUF0U3RhcnQgKyBzdHJlYW0uYnl0ZXNXcml0dGVuO1xufVxuXG5mdW5jdGlvbiBhcmNoaXZlTG9nKHN0cmVhbSkge1xuICBpZiAoc3RyZWFtLmVuZCkge1xuICAgIHN0cmVhbS5lbmQoKTtcbiAgfVxuXG4gIHRyeSB7XG4gICAgZnMucmVuYW1lU3luYyhzdHJlYW0ucGF0aCwgc3RyZWFtLnBhdGgucmVwbGFjZSgvbG9nJC8sICdvbGQubG9nJykpO1xuICB9IGNhdGNoIChlKSB7XG4gICAgbG9nQ29uc29sZSgnQ291bGQgbm90IHJvdGF0ZSBsb2cnLCBlKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBsb2dDb25zb2xlKG1lc3NhZ2UsIGVycm9yKSB7XG4gIHZhciBkYXRhID0gWydlbGVjdHJvbi1sb2cudHJhbnNwb3J0cy5maWxlOiAnICsgbWVzc2FnZV07XG5cbiAgaWYgKGVycm9yKSB7XG4gICAgZGF0YS5wdXNoKGVycm9yKTtcbiAgfVxuXG4gIGNvbnNvbGVUcmFuc3BvcnQoeyBkYXRhOiBkYXRhLCBkYXRlOiBuZXcgRGF0ZSgpLCBsZXZlbDogJ3dhcm4nIH0pO1xufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2VsZWN0cm9uLWxvZy9saWIvdHJhbnNwb3J0cy9maWxlL2luZGV4LmpzIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgZnMgICA9IHJlcXVpcmUoJ2ZzJyk7XG52YXIgcGF0aCA9IHJlcXVpcmUoJ3BhdGgnKTtcbnZhciBvcyAgID0gcmVxdWlyZSgnb3MnKTtcbnZhciBnZXRBcHBOYW1lID0gcmVxdWlyZSgnLi9nZXQtYXBwLW5hbWUnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmaW5kTG9nUGF0aDtcblxuLyoqXG4gKiBUcnkgdG8gZGV0ZXJtaW5lIGEgcGxhdGZvcm0tc3BlY2lmaWMgcGF0aCB3aGVyZSBjYW4gd3JpdGUgbG9nc1xuICogQHBhcmFtIHtzdHJpbmd9IFthcHBOYW1lXSBVc2VkIHRvIGRldGVybWluZSB0aGUgbGFzdCBwYXJ0IG9mIGEgbG9nIHBhdGhcbiAqIEByZXR1cm4ge3N0cmluZ3xib29sZWFufVxuICovXG5mdW5jdGlvbiBmaW5kTG9nUGF0aChhcHBOYW1lKSB7XG4gIGFwcE5hbWUgPSBhcHBOYW1lIHx8IGdldEFwcE5hbWUoKTtcbiAgaWYgKCFhcHBOYW1lKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgdmFyIGhvbWVEaXIgPSBvcy5ob21lZGlyID8gb3MuaG9tZWRpcigpIDogcHJvY2Vzcy5lbnZbJ0hPTUUnXTtcbiAgXG4gIHZhciBkaXI7XG4gIHN3aXRjaCAocHJvY2Vzcy5wbGF0Zm9ybSkge1xuICAgIGNhc2UgJ2xpbnV4Jzoge1xuICAgICAgZGlyID0gcHJlcGFyZURpcihwcm9jZXNzLmVudlsnWERHX0NPTkZJR19IT01FJ10sIGFwcE5hbWUpXG4gICAgICAgIC5vcihob21lRGlyLCAnLmNvbmZpZycsIGFwcE5hbWUpXG4gICAgICAgIC5vcihwcm9jZXNzLmVudlsnWERHX0RBVEFfSE9NRSddLCBhcHBOYW1lKVxuICAgICAgICAub3IoaG9tZURpciwgJy5sb2NhbCcsICdzaGFyZScsIGFwcE5hbWUpXG4gICAgICAgIC5yZXN1bHQ7XG4gICAgICBicmVhaztcbiAgICB9XG5cbiAgICBjYXNlICdkYXJ3aW4nOiB7XG4gICAgICBkaXIgPSBwcmVwYXJlRGlyKGhvbWVEaXIsICdMaWJyYXJ5JywgJ0xvZ3MnLCBhcHBOYW1lKVxuICAgICAgICAub3IoaG9tZURpciwgJ0xpYnJhcnknLCAnQXBwbGljYXRpb24gU3VwcG9ydCcsIGFwcE5hbWUpXG4gICAgICAgIC5yZXN1bHQ7XG4gICAgICBicmVhaztcbiAgICB9XG5cbiAgICBjYXNlICd3aW4zMic6IHtcbiAgICAgIGRpciA9IHByZXBhcmVEaXIocHJvY2Vzcy5lbnZbJ0FQUERBVEEnXSwgYXBwTmFtZSlcbiAgICAgICAgLm9yKGhvbWVEaXIsICdBcHBEYXRhJywgJ1JvYW1pbmcnLCBhcHBOYW1lKVxuICAgICAgICAucmVzdWx0O1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG5cbiAgaWYgKGRpcikge1xuICAgIHJldHVybiBwYXRoLmpvaW4oZGlyLCAnbG9nLmxvZycpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufVxuXG5cblxuZnVuY3Rpb24gcHJlcGFyZURpcihkaXJQYXRoKSB7XG4gIC8vIGpzaGludCAtVzA0MFxuICBpZiAoIXRoaXMgfHwgdGhpcy5vciAhPT0gcHJlcGFyZURpciB8fCAhdGhpcy5yZXN1bHQpIHtcbiAgICBpZiAoIWRpclBhdGgpIHtcbiAgICAgIHJldHVybiB7IG9yOiBwcmVwYXJlRGlyIH07XG4gICAgfVxuXG4gICAgLy9ub2luc3BlY3Rpb24gSlNDaGVja0Z1bmN0aW9uU2lnbmF0dXJlc1xuICAgIGRpclBhdGggPSBwYXRoLmpvaW4uYXBwbHkocGF0aCwgYXJndW1lbnRzKTtcbiAgICBta0RpcihkaXJQYXRoKTtcblxuICAgIHRyeSB7XG4gICAgICBmcy5hY2Nlc3NTeW5jKGRpclBhdGgsIGZzLldfT0spO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHJldHVybiB7IG9yOiBwcmVwYXJlRGlyIH07XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBvcjogcHJlcGFyZURpcixcbiAgICByZXN1bHQ6ICh0aGlzID8gdGhpcy5yZXN1bHQgOiBmYWxzZSkgfHwgZGlyUGF0aFxuICB9O1xufVxuXG5mdW5jdGlvbiBta0RpcihkaXJQYXRoLCByb290KSB7XG4gIHZhciBkaXJzID0gZGlyUGF0aC5zcGxpdChwYXRoLnNlcCk7XG4gIHZhciBkaXIgPSBkaXJzLnNoaWZ0KCk7XG4gIHJvb3QgPSAocm9vdCB8fCAnJykgKyBkaXIgKyBwYXRoLnNlcDtcblxuICB0cnkge1xuICAgIGZzLm1rZGlyU3luYyhyb290KTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIGlmICghZnMuc3RhdFN5bmMocm9vdCkuaXNEaXJlY3RvcnkoKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGUpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiAhZGlycy5sZW5ndGggfHwgbWtEaXIoZGlycy5qb2luKHBhdGguc2VwKSwgcm9vdCk7XG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvZWxlY3Ryb24tbG9nL2xpYi90cmFuc3BvcnRzL2ZpbGUvZmluZC1sb2ctcGF0aC5qcyIsIi8vIGpzaGludCAtVzA3NFxuJ3VzZSBzdHJpY3QnO1xuXG4vKiogQG5hbWUgcHJvY2Vzcy5yZXNvdXJjZXNQYXRoICovXG5cbnZhciBmcyAgID0gcmVxdWlyZSgnZnMnKTtcbnZhciBwYXRoID0gcmVxdWlyZSgncGF0aCcpO1xudmFyIGNvbnNvbGVUcmFuc3BvcnQgPSByZXF1aXJlKCcuLi9jb25zb2xlJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZ2V0QXBwTmFtZTtcblxuZnVuY3Rpb24gZ2V0QXBwTmFtZSgpIHtcbiAgdHJ5IHtcbiAgICB2YXIgbmFtZSA9IGxvYWRQYWNrYWdlTmFtZSgpO1xuICAgIGlmIChuYW1lKSB7XG4gICAgICByZXR1cm4gbmFtZTtcbiAgICB9XG4gICAgcmV0dXJuIHdhcm4oJ2VsZWN0cm9uLWxvZzogdW5hYmxlIHRvIGxvYWQgdGhlIGFwcCBuYW1lIGZyb20gcGFja2FnZS5qc29uJyk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICByZXR1cm4gd2FybignZWxlY3Ryb24tbG9nOiAnICsgZS5tZXNzYWdlKTtcbiAgfVxufVxuXG4vKipcbiAqIFRyeSB0byBsb2FkIG1haW4gYXBwIHBhY2thZ2VcbiAqIEB0aHJvd3Mge0Vycm9yfVxuICogQHJldHVybiB7T2JqZWN0fG51bGx9XG4gKi9cbmZ1bmN0aW9uIGxvYWRQYWNrYWdlTmFtZSgpIHtcbiAgdmFyIHBhY2thZ2VGaWxlO1xuXG4gIHRyeSB7XG4gICAgaWYgKHJlcXVpcmUubWFpbi5maWxlbmFtZSkge1xuICAgICAgcGFja2FnZUZpbGUgPSBmaW5kKHBhdGguZGlybmFtZShyZXF1aXJlLm1haW4uZmlsZW5hbWUpKTtcbiAgICB9XG4gIH0gY2F0Y2ggKGUpIHt9XG5cbiAgaWYgKCFwYWNrYWdlRmlsZSAmJiBwcm9jZXNzLnJlc291cmNlc1BhdGgpIHtcbiAgICBwYWNrYWdlRmlsZSA9IGZpbmQocGF0aC5qb2luKHByb2Nlc3MucmVzb3VyY2VzUGF0aCwgJ2FwcC5hc2FyJykpO1xuICAgIHZhciBlbGVjdHJvbk1vZHVsZSA9IHBhdGguam9pbignbm9kZV9tb2R1bGVzJywgJ2VsZWN0cm9uJywgJ3BhY2thZ2UuanNvbicpO1xuICAgIGlmIChwYWNrYWdlRmlsZSAmJiBwYWNrYWdlRmlsZS5pbmRleE9mKGVsZWN0cm9uTW9kdWxlKSAhPT0gLTEpIHtcbiAgICAgIHBhY2thZ2VGaWxlID0gbnVsbDtcbiAgICB9XG4gIH1cblxuICBpZiAoIXBhY2thZ2VGaWxlKSB7XG4gICAgcGFja2FnZUZpbGUgPSBmaW5kKHByb2Nlc3MuY3dkKCkpO1xuICB9XG5cbiAgaWYgKCFwYWNrYWdlRmlsZSkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgdmFyIGNvbnRlbnQgPSBmcy5yZWFkRmlsZVN5bmMocGFja2FnZUZpbGUsICd1dGYtOCcpO1xuICB2YXIgcGFja2FnZURhdGEgPSBKU09OLnBhcnNlKGNvbnRlbnQpO1xuXG4gIC8vbm9pbnNwZWN0aW9uIEpTVW5yZXNvbHZlZFZhcmlhYmxlXG4gIHJldHVybiBwYWNrYWdlRGF0YSA/IHBhY2thZ2VEYXRhLnByb2R1Y3ROYW1lIHx8IHBhY2thZ2VEYXRhLm5hbWUgOiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gZmluZChyb290KSB7XG4gIHZhciBmaWxlO1xuXG4gIHdoaWxlICghZmlsZSkge1xuICAgIHZhciBwYXJlbnQ7XG4gICAgZmlsZSA9IHBhdGguam9pbihyb290LCAncGFja2FnZS5qc29uJyk7XG5cbiAgICB0cnkge1xuICAgICAgZnMuc3RhdFN5bmMoZmlsZSk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgcGFyZW50ID0gcGF0aC5yZXNvbHZlKHJvb3QsICcuLicpO1xuICAgICAgZmlsZSA9IG51bGw7XG4gICAgfVxuXG4gICAgaWYgKHJvb3QgPT09IHBhcmVudCkge1xuICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgcm9vdCA9IHBhcmVudDtcbiAgfVxuXG4gIHJldHVybiBmaWxlO1xufVxuXG5mdW5jdGlvbiB3YXJuKG1lc3NhZ2UpIHtcbiAgY29uc29sZVRyYW5zcG9ydCh7XG4gICAgZGF0YTogW21lc3NhZ2VdLFxuICAgIGRhdGU6IG5ldyBEYXRlKCksXG4gICAgbGV2ZWw6ICd3YXJuJ1xuICB9KTtcbn1cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvZWxlY3Ryb24tbG9nL2xpYi90cmFuc3BvcnRzL2ZpbGUvZ2V0LWFwcC1uYW1lLmpzIiwiLy8ganNoaW50IC1XMDc0LCAtVzA4OVxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgaHR0cCAgPSByZXF1aXJlKCdodHRwJyk7XG52YXIgaHR0cHMgPSByZXF1aXJlKCdodHRwcycpO1xudmFyIHVybCAgID0gcmVxdWlyZSgndXJsJyk7XG5cbnRyYW5zcG9ydC5jbGllbnQgPSB7IG5hbWU6ICdlbGVjdHJvbi1hcHBsaWNhdGlvbicgfTtcbnRyYW5zcG9ydC5kZXB0aCAgPSA2O1xudHJhbnNwb3J0LmxldmVsICA9IGZhbHNlO1xudHJhbnNwb3J0LnVybCAgICA9IG51bGw7XG5cbm1vZHVsZS5leHBvcnRzID0gdHJhbnNwb3J0O1xuXG5mdW5jdGlvbiB0cmFuc3BvcnQobXNnKSB7XG4gIGlmICghdHJhbnNwb3J0LnVybCkgcmV0dXJuO1xuXG4gIHZhciBkYXRhID0ganNvbkRlcHRoKHtcbiAgICBjbGllbnQ6IHRyYW5zcG9ydC5jbGllbnQsXG4gICAgZGF0YTogbXNnLmRhdGEsXG4gICAgZGF0ZTogbXNnLmRhdGUuZ2V0VGltZSgpLFxuICAgIGxldmVsOiBtc2cubGV2ZWxcbiAgfSwgdHJhbnNwb3J0LmRlcHRoICsgMSk7XG5cbiAgcG9zdCh0cmFuc3BvcnQudXJsLCBkYXRhKTtcbn1cblxuZnVuY3Rpb24gcG9zdChzZXJ2ZXJVcmwsIGRhdGEpIHtcbiAgdmFyIHVybE9iamVjdCA9IHVybC5wYXJzZShzZXJ2ZXJVcmwpO1xuICB2YXIgdHJhbnNwb3J0ID0gdXJsT2JqZWN0LnByb3RvY29sID09PSAnaHR0cHM6JyA/IGh0dHBzIDogaHR0cDtcblxuICB2YXIgYm9keSA9IEpTT04uc3RyaW5naWZ5KGRhdGEpO1xuXG4gIHZhciBvcHRpb25zID0ge1xuICAgIGhvc3RuYW1lOiB1cmxPYmplY3QuaG9zdG5hbWUsXG4gICAgcG9ydDogICAgIHVybE9iamVjdC5wb3J0LFxuICAgIHBhdGg6ICAgICB1cmxPYmplY3QucGF0aCxcbiAgICBtZXRob2Q6ICAgJ1BPU1QnLFxuICAgIGhlYWRlcnM6ICB7XG4gICAgICAnQ29udGVudC1UeXBlJzogICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICdDb250ZW50LUxlbmd0aCc6IGJvZHkubGVuZ3RoXG4gICAgfVxuICB9O1xuXG4gIHZhciByZXF1ZXN0ID0gdHJhbnNwb3J0LnJlcXVlc3Qob3B0aW9ucyk7XG4gIHJlcXVlc3Qud3JpdGUoYm9keSk7XG4gIHJlcXVlc3QuZW5kKCk7XG59XG5cbmZ1bmN0aW9uIGpzb25EZXB0aChqc29uLCBkZXB0aCkge1xuICBpZiAoZGVwdGggPCAxKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoanNvbikpICByZXR1cm4gJ1thcnJheV0nO1xuICAgIGlmICh0eXBlb2YganNvbiA9PT0gJ29iamVjdCcpICByZXR1cm4gJ1tvYmplY3RdJztcbiAgICByZXR1cm4ganNvbjtcbiAgfVxuXG4gIGlmIChBcnJheS5pc0FycmF5KGpzb24pKSB7XG4gICAgcmV0dXJuIGpzb24ubWFwKGZ1bmN0aW9uKGNoaWxkKSB7XG4gICAgICByZXR1cm4ganNvbkRlcHRoKGNoaWxkLCBkZXB0aCAtIDEpO1xuICAgIH0pO1xuICB9XG5cbiAgaWYgKGpzb24gJiYgdHlwZW9mIGpzb24uZ2V0TW9udGggPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4ganNvbjtcbiAgfVxuXG4gIGlmIChqc29uID09PSBudWxsKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBpZiAodHlwZW9mIGpzb24gPT09ICdvYmplY3QnKSB7XG4gICAgaWYgKHR5cGVvZiBqc29uLnRvSlNPTiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAganNvbiA9IGpzb24udG9KU09OKCk7XG4gICAgfVxuXG4gICAgdmFyIG5ld0pzb24gPSB7fTtcbiAgICBmb3IgKHZhciBpIGluIGpzb24pIHtcbiAgICAgIC8vbm9pbnNwZWN0aW9uIEpTVW5maWx0ZXJlZEZvckluTG9vcFxuICAgICAgbmV3SnNvbltpXSA9IGpzb25EZXB0aChqc29uW2ldLCBkZXB0aCAtIDEpO1xuICAgIH1cblxuICAgIHJldHVybiBuZXdKc29uO1xuICB9XG5cbiAgcmV0dXJuIGpzb247XG59XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2VsZWN0cm9uLWxvZy9saWIvdHJhbnNwb3J0cy9sb2ctcy5qcyIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcImh0dHBzXCIpO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIGV4dGVybmFsIFwiaHR0cHNcIlxuLy8gbW9kdWxlIGlkID0gMTkxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIid1c2Ugc3RyaWN0JztcblxudmFyIEJyb3dzZXJXaW5kb3c7XG50cnkge1xuICBCcm93c2VyV2luZG93ID0gcmVxdWlyZSgnZWxlY3Ryb24nKS5Ccm93c2VyV2luZG93O1xufSBjYXRjaCAoZSkge1xuICBCcm93c2VyV2luZG93ID0gbnVsbDtcbn1cblxudmFyIGZvcm1hdCA9IHJlcXVpcmUoJy4uL2Zvcm1hdCcpO1xuXG50cmFuc3BvcnQubGV2ZWwgID0gQnJvd3NlcldpbmRvdyA/ICdzaWxseScgOiBmYWxzZTtcbnRyYW5zcG9ydC5mb3JtYXQgPSAnW3tofTp7aX06e3N9Lnttc31dIHt0ZXh0fSc7XG5cbm1vZHVsZS5leHBvcnRzID0gdHJhbnNwb3J0O1xuXG5mdW5jdGlvbiB0cmFuc3BvcnQobXNnKSB7XG4gIGlmICghQnJvd3NlcldpbmRvdykgcmV0dXJuO1xuXG4gIHZhciB0ZXh0ID0gZm9ybWF0LmZvcm1hdChtc2csIHRyYW5zcG9ydC5mb3JtYXQpO1xuICBCcm93c2VyV2luZG93LmdldEFsbFdpbmRvd3MoKS5mb3JFYWNoKGZ1bmN0aW9uKHduZCkge1xuICAgIHduZC53ZWJDb250ZW50cy5zZW5kKCdfX0VMRUNUUk9OX0xPR19SRU5ERVJFUl9fJywgbXNnLmxldmVsLCB0ZXh0KTtcbiAgfSk7XG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvZWxlY3Ryb24tbG9nL2xpYi90cmFuc3BvcnRzL3JlbmRlcmVyLWNvbnNvbGUuanMiLCJtb2R1bGUuZXhwb3J0cyA9IHtcIm5hbWVcIjpcIkVMSVRcIixcInZlcnNpb25cIjpcIjAuMC4xN1wiLFwiZGVzY3JpcHRpb25cIjpcIkVMSVQgLSBFdmUgTG9jYWwgSW50ZWwgVG9vbFwiLFwibWFpblwiOlwiZGlzdC9tYWluLmpzXCIsXCJyZXBvc2l0b3J5XCI6XCJnaXRAZ2l0aHViLmNvbTpTcXVhcmVoZWFkcy9FTElULmdpdFwiLFwiYXV0aG9yXCI6XCJPd2VuIFdvcmxleVwiLFwibGljZW5zZVwiOlwiKGMpIFNxdWFyZWhlYWRzIExURCAyMDE4XCIsXCJkZXZEZXBlbmRlbmNpZXNcIjp7XCJAdHlwZXMvY2hhaVwiOlwiXjQuMC44XCIsXCJAdHlwZXMvZWxlY3Ryb25cIjpcIl4xLjYuMTBcIixcIkB0eXBlcy9lbGVjdHJvbi1pcy1kZXZcIjpcIl4wLjMuMFwiLFwiQHR5cGVzL21hdGVyaWFsLXVpXCI6XCJeMC4xOC41XCIsXCJAdHlwZXMvbW9jaGFcIjpcIl4yLjIuNDRcIixcIkB0eXBlcy9tb2NrZXJ5XCI6XCJeMS40LjI5XCIsXCJAdHlwZXMvbm9kZVwiOlwiXjguMC41M1wiLFwiQHR5cGVzL3JlYWN0XCI6XCJeMTYuMC4yNVwiLFwiQHR5cGVzL3JlYWN0LWRvbVwiOlwiXjE2LjAuM1wiLFwiQHR5cGVzL3JlcXVlc3RcIjpcIl4yLjAuOFwiLFwiQHR5cGVzL3JlcXVlc3QtcHJvbWlzZS1uYXRpdmVcIjpcIl4xLjAuMTBcIixcIkB0eXBlcy9zaW5vblwiOlwiXjQuMS4wXCIsXCJAdHlwZXMvdXJsLXBhcnNlXCI6XCJeMS4xLjBcIixcIkB0eXBlcy94MmpzXCI6XCJeMy4xLjBcIixcImJhYmVsLWNvcmVcIjpcIl42LjI2LjBcIixcImJhYmVsLWxvYWRlclwiOlwiXjcuMS4yXCIsXCJiYWJlbC1wbHVnaW4tYWRkLW1vZHVsZS1leHBvcnRzXCI6XCJeMC4yLjFcIixcImJhYmVsLXBsdWdpbi10cmFuc2Zvcm0tcnVudGltZVwiOlwiXjYuMC4wXCIsXCJiYWJlbC1wcmVzZXQtZW52XCI6XCJeMS42LjFcIixcImJhYmVsLXByZXNldC1lczIwMTVcIjpcIl42LjI0LjFcIixcImJhYmVsLXByZXNldC1lczIwMTUtbm9kZVwiOlwiXjYuMS4xXCIsXCJiYWJlbC1wcmVzZXQtZXMyMDE1LW5vZGU1XCI6XCJeMS4yLjBcIixcImJhYmVsLXByZXNldC1yZWFjdFwiOlwiXjYuMjQuMVwiLFwiYmFiZWwtcHJlc2V0LXN0YWdlLTNcIjpcIl42LjI0LjFcIixcImJhYmVsLXByZXNldC10cy1ub2RlNi1ibHVlYmlyZFwiOlwiXjEuMC4xXCIsXCJjaGFpXCI6XCJeNC4xLjJcIixcImVsZWN0cm9uXCI6XCJeMS43LjlcIixcImVsZWN0cm9uLWJ1aWxkZXJcIjpcIl4xOS40Ni45XCIsXCJodG1sLXdlYnBhY2stcGx1Z2luXCI6XCJeMi4zMC4xXCIsXCJpZ25vcmUtc3R5bGVzXCI6XCJeNS4wLjFcIixcIm1vY2hhXCI6XCJeNC4wLjFcIixcIm1vY2tlcnlcIjpcIl4yLjEuMFwiLFwibm9kZS1ub29wXCI6XCJeMS4wLjBcIixcIm55Y1wiOlwiXjExLjMuMFwiLFwic2lub25cIjpcIl40LjEuM1wiLFwic3RhbmRhcmRcIjpcIl4xMC4wLjNcIixcInN0YW5kYXJkLWxvYWRlclwiOlwiXjYuMC4xXCIsXCJ0cy1sb2FkZXJcIjpcIl4zLjEuMVwiLFwidHMtbW9ja2l0b1wiOlwiXjIuMi43XCIsXCJ0cy1ub2RlXCI6XCJeMy4zLjBcIixcInRzbGludFwiOlwiXjUuOC4wXCIsXCJ0c2xpbnQtY29uZmlnLXN0YW5kYXJkXCI6XCJeNy4wLjBcIixcInRzbGludC1sb2FkZXJcIjpcIl4zLjUuM1wiLFwidHlwZXNjcmlwdFwiOlwiXjIuNi4yXCIsXCJ3ZWJwYWNrXCI6XCJeMy44LjFcIn0sXCJzY3JpcHRzXCI6e1wiYnVpbGRcIjpcIndlYnBhY2sgLS1jb25maWcgd2VicGFjay5jb25maWcuanNcIixcInByZXN0YXJ0XCI6XCJ5YXJuIHJ1biBidWlsZFwiLFwic3RhcnRcIjpcImVsZWN0cm9uIC5cIixcInRlc3RcIjpcInNldCBUU19OT0RFX1BST0pFQ1Q9dHNjb25maWcudGVzdC5qc29uJiZtb2NoYVwiLFwicGFja1wiOlwiZWxlY3Ryb24tYnVpbGRlciAtLWRpclwiLFwiZGlzdFwiOlwiZWxlY3Ryb24tYnVpbGRlclwiLFwiZGlzdC1hbGxcIjpcImVsZWN0cm9uLWJ1aWxkZXIgLW13bFwifSxcImRlcGVuZGVuY2llc1wiOntcImRleGllXCI6XCIyXCIsXCJlbGVjdHJvbi1nb29nbGUtYW5hbHl0aWNzXCI6XCJeMC4wLjI0XCIsXCJlbGVjdHJvbi1pcy1kZXZcIjpcIl4wLjMuMFwiLFwiZWxlY3Ryb24tbG9nXCI6XCJeMi4yLjEzXCIsXCJlbGVjdHJvbi11cGRhdGVyXCI6XCJeMi4xOC4yXCIsXCJldmUtb25saW5lLWVzaVwiOlwiIGh0dHBzOi8vZ2l0aHViLmNvbS9TcXVhcmVoZWFkcy9ldmUtb25saW5lLWVzaS9hcmNoaXZlL2RmNDQwZWZhMzk0ZTM2ZTA2M2E2NTkzYmVkZThkZDhkMjg1ZTExNzkudGFyLmd6XCIsXCJtYXRlcmlhbC11aVwiOlwiXjAuMjAuMFwiLFwibWF0ZXJpYWwtdWktaW1hZ2VcIjpcIl4yLjEuMVwiLFwicXVlcnlzdHJpbmdpZnlcIjpcIl4xLjAuMFwiLFwicmVhY3RcIjpcIl4xNi4yLjBcIixcInJlYWN0LWRvbVwiOlwiXjE2LjIuMFwiLFwicmVhY3QtZWxlY3Ryb24td2ViLXZpZXdcIjpcIl4yLjAuMVwiLFwicmVxdWVzdFwiOlwiXjIuODMuMFwiLFwidHlwZXNjcmlwdC1jb2xsZWN0aW9uc1wiOlwiXjEuMi41XCIsXCJ1cmwtcGFyc2VcIjpcIl4xLjIuMFwiLFwieDJqc1wiOlwiXjMuMS4xXCJ9LFwiYnVpbGRcIjp7XCJhcHBJZFwiOlwiaW8uc3F1YXJlaGVhZHMuZXZlLWludGVsXCIsXCJmaWxlc1wiOlwiLi9kaXN0LyoqLypcIixcImRpcmVjdG9yaWVzXCI6e1wib3V0cHV0XCI6XCJwYWNrYWdlZFwifSxcIm1hY1wiOntcImNhdGVnb3J5XCI6XCJwdWJsaWMuYXBwLWNhdGVnb3J5LnV0aWxpdGllc1wifX0sXCJwZWVyRGVwZW5kZW5jaWVzXCI6e319XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9wYWNrYWdlLmpzb25cbi8vIG1vZHVsZSBpZCA9IDE5M1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9