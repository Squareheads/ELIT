/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 69);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports) {

module.exports = require("path");

/***/ }),
/* 1 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var es5 = __webpack_require__(16);
var canEvaluate = typeof navigator == "undefined";

var errorObj = { e: {} };
var tryCatchTarget;
var globalObject = typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : undefined !== undefined ? undefined : null;

function tryCatcher() {
    try {
        var target = tryCatchTarget;
        tryCatchTarget = null;
        return target.apply(this, arguments);
    } catch (e) {
        errorObj.e = e;
        return errorObj;
    }
}
function tryCatch(fn) {
    tryCatchTarget = fn;
    return tryCatcher;
}

var inherits = function (Child, Parent) {
    var hasProp = {}.hasOwnProperty;

    function T() {
        this.constructor = Child;
        this.constructor$ = Parent;
        for (var propertyName in Parent.prototype) {
            if (hasProp.call(Parent.prototype, propertyName) && propertyName.charAt(propertyName.length - 1) !== "$") {
                this[propertyName + "$"] = Parent.prototype[propertyName];
            }
        }
    }
    T.prototype = Parent.prototype;
    Child.prototype = new T();
    return Child.prototype;
};

function isPrimitive(val) {
    return val == null || val === true || val === false || typeof val === "string" || typeof val === "number";
}

function isObject(value) {
    return typeof value === "function" || typeof value === "object" && value !== null;
}

function maybeWrapAsError(maybeError) {
    if (!isPrimitive(maybeError)) return maybeError;

    return new Error(safeToString(maybeError));
}

function withAppended(target, appendee) {
    var len = target.length;
    var ret = new Array(len + 1);
    var i;
    for (i = 0; i < len; ++i) {
        ret[i] = target[i];
    }
    ret[i] = appendee;
    return ret;
}

function getDataPropertyOrDefault(obj, key, defaultValue) {
    if (es5.isES5) {
        var desc = Object.getOwnPropertyDescriptor(obj, key);

        if (desc != null) {
            return desc.get == null && desc.set == null ? desc.value : defaultValue;
        }
    } else {
        return {}.hasOwnProperty.call(obj, key) ? obj[key] : undefined;
    }
}

function notEnumerableProp(obj, name, value) {
    if (isPrimitive(obj)) return obj;
    var descriptor = {
        value: value,
        configurable: true,
        enumerable: false,
        writable: true
    };
    es5.defineProperty(obj, name, descriptor);
    return obj;
}

function thrower(r) {
    throw r;
}

var inheritedDataKeys = function () {
    var excludedPrototypes = [Array.prototype, Object.prototype, Function.prototype];

    var isExcludedProto = function (val) {
        for (var i = 0; i < excludedPrototypes.length; ++i) {
            if (excludedPrototypes[i] === val) {
                return true;
            }
        }
        return false;
    };

    if (es5.isES5) {
        var getKeys = Object.getOwnPropertyNames;
        return function (obj) {
            var ret = [];
            var visitedKeys = Object.create(null);
            while (obj != null && !isExcludedProto(obj)) {
                var keys;
                try {
                    keys = getKeys(obj);
                } catch (e) {
                    return ret;
                }
                for (var i = 0; i < keys.length; ++i) {
                    var key = keys[i];
                    if (visitedKeys[key]) continue;
                    visitedKeys[key] = true;
                    var desc = Object.getOwnPropertyDescriptor(obj, key);
                    if (desc != null && desc.get == null && desc.set == null) {
                        ret.push(key);
                    }
                }
                obj = es5.getPrototypeOf(obj);
            }
            return ret;
        };
    } else {
        var hasProp = {}.hasOwnProperty;
        return function (obj) {
            if (isExcludedProto(obj)) return [];
            var ret = [];

            /*jshint forin:false */
            enumeration: for (var key in obj) {
                if (hasProp.call(obj, key)) {
                    ret.push(key);
                } else {
                    for (var i = 0; i < excludedPrototypes.length; ++i) {
                        if (hasProp.call(excludedPrototypes[i], key)) {
                            continue enumeration;
                        }
                    }
                    ret.push(key);
                }
            }
            return ret;
        };
    }
}();

var thisAssignmentPattern = /this\s*\.\s*\S+\s*=/;
function isClass(fn) {
    try {
        if (typeof fn === "function") {
            var keys = es5.names(fn.prototype);

            var hasMethods = es5.isES5 && keys.length > 1;
            var hasMethodsOtherThanConstructor = keys.length > 0 && !(keys.length === 1 && keys[0] === "constructor");
            var hasThisAssignmentAndStaticMethods = thisAssignmentPattern.test(fn + "") && es5.names(fn).length > 0;

            if (hasMethods || hasMethodsOtherThanConstructor || hasThisAssignmentAndStaticMethods) {
                return true;
            }
        }
        return false;
    } catch (e) {
        return false;
    }
}

function toFastProperties(obj) {
    /*jshint -W027,-W055,-W031*/
    function FakeConstructor() {}
    FakeConstructor.prototype = obj;
    var l = 8;
    while (l--) new FakeConstructor();
    return obj;
    eval(obj);
}

var rident = /^[a-z$_][a-z$_0-9]*$/i;
function isIdentifier(str) {
    return rident.test(str);
}

function filledRange(count, prefix, suffix) {
    var ret = new Array(count);
    for (var i = 0; i < count; ++i) {
        ret[i] = prefix + i + suffix;
    }
    return ret;
}

function safeToString(obj) {
    try {
        return obj + "";
    } catch (e) {
        return "[no string representation]";
    }
}

function isError(obj) {
    return obj instanceof Error || obj !== null && typeof obj === "object" && typeof obj.message === "string" && typeof obj.name === "string";
}

function markAsOriginatingFromRejection(e) {
    try {
        notEnumerableProp(e, "isOperational", true);
    } catch (ignore) {}
}

function originatesFromRejection(e) {
    if (e == null) return false;
    return e instanceof Error["__BluebirdErrorTypes__"].OperationalError || e["isOperational"] === true;
}

function canAttachTrace(obj) {
    return isError(obj) && es5.propertyIsWritable(obj, "stack");
}

var ensureErrorObject = function () {
    if (!("stack" in new Error())) {
        return function (value) {
            if (canAttachTrace(value)) return value;
            try {
                throw new Error(safeToString(value));
            } catch (err) {
                return err;
            }
        };
    } else {
        return function (value) {
            if (canAttachTrace(value)) return value;
            return new Error(safeToString(value));
        };
    }
}();

function classString(obj) {
    return {}.toString.call(obj);
}

function copyDescriptors(from, to, filter) {
    var keys = es5.names(from);
    for (var i = 0; i < keys.length; ++i) {
        var key = keys[i];
        if (filter(key)) {
            try {
                es5.defineProperty(to, key, es5.getDescriptor(from, key));
            } catch (ignore) {}
        }
    }
}

var asArray = function (v) {
    if (es5.isArray(v)) {
        return v;
    }
    return null;
};

if (typeof Symbol !== "undefined" && Symbol.iterator) {
    var ArrayFrom = typeof Array.from === "function" ? function (v) {
        return Array.from(v);
    } : function (v) {
        var ret = [];
        var it = v[Symbol.iterator]();
        var itResult;
        while (!(itResult = it.next()).done) {
            ret.push(itResult.value);
        }
        return ret;
    };

    asArray = function (v) {
        if (es5.isArray(v)) {
            return v;
        } else if (v != null && typeof v[Symbol.iterator] === "function") {
            return ArrayFrom(v);
        }
        return null;
    };
}

var isNode = typeof process !== "undefined" && classString(process).toLowerCase() === "[object process]";

var hasEnvVariables = typeof process !== "undefined" && typeof process.env !== "undefined";

function env(key) {
    return hasEnvVariables ? process.env[key] : undefined;
}

function getNativePromise() {
    if (typeof Promise === "function") {
        try {
            var promise = new Promise(function () {});
            if ({}.toString.call(promise) === "[object Promise]") {
                return Promise;
            }
        } catch (e) {}
    }
}

function domainBind(self, cb) {
    return self.bind(cb);
}

var ret = {
    isClass: isClass,
    isIdentifier: isIdentifier,
    inheritedDataKeys: inheritedDataKeys,
    getDataPropertyOrDefault: getDataPropertyOrDefault,
    thrower: thrower,
    isArray: es5.isArray,
    asArray: asArray,
    notEnumerableProp: notEnumerableProp,
    isPrimitive: isPrimitive,
    isObject: isObject,
    isError: isError,
    canEvaluate: canEvaluate,
    errorObj: errorObj,
    tryCatch: tryCatch,
    inherits: inherits,
    withAppended: withAppended,
    maybeWrapAsError: maybeWrapAsError,
    toFastProperties: toFastProperties,
    filledRange: filledRange,
    toString: safeToString,
    canAttachTrace: canAttachTrace,
    ensureErrorObject: ensureErrorObject,
    originatesFromRejection: originatesFromRejection,
    markAsOriginatingFromRejection: markAsOriginatingFromRejection,
    classString: classString,
    copyDescriptors: copyDescriptors,
    hasDevTools: typeof chrome !== "undefined" && chrome && typeof chrome.loadTimes === "function",
    isNode: isNode,
    hasEnvVariables: hasEnvVariables,
    env: env,
    global: globalObject,
    getNativePromise: getNativePromise,
    domainBind: domainBind
};
ret.isRecentNode = ret.isNode && function () {
    var version = process.versions.node.split(".").map(Number);
    return version[0] === 0 && version[1] > 10 || version[0] > 0;
}();

if (ret.isNode) ret.toFastProperties(process);

try {
    throw new Error();
} catch (e) {
    ret.lastLineError = e;
}
module.exports = ret;

/***/ }),
/* 2 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const BluebirdPromise = __webpack_require__(70)();
BluebirdPromise.config({
  longStackTraces: true
});
BluebirdPromise.default = BluebirdPromise;
module.exports = BluebirdPromise;

/***/ }),
/* 3 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _CancellationToken;

function _load_CancellationToken() {
    return _CancellationToken = __webpack_require__(40);
}

Object.defineProperty(exports, "CancellationToken", {
    enumerable: true,
    get: function () {
        return (_CancellationToken || _load_CancellationToken()).CancellationToken;
    }
});
Object.defineProperty(exports, "CancellationError", {
    enumerable: true,
    get: function () {
        return (_CancellationToken || _load_CancellationToken()).CancellationError;
    }
});

var _httpExecutor;

function _load_httpExecutor() {
    return _httpExecutor = __webpack_require__(42);
}

Object.defineProperty(exports, "HttpError", {
    enumerable: true,
    get: function () {
        return (_httpExecutor || _load_httpExecutor()).HttpError;
    }
});
Object.defineProperty(exports, "createHttpError", {
    enumerable: true,
    get: function () {
        return (_httpExecutor || _load_httpExecutor()).createHttpError;
    }
});
Object.defineProperty(exports, "HttpExecutor", {
    enumerable: true,
    get: function () {
        return (_httpExecutor || _load_httpExecutor()).HttpExecutor;
    }
});
Object.defineProperty(exports, "DigestTransform", {
    enumerable: true,
    get: function () {
        return (_httpExecutor || _load_httpExecutor()).DigestTransform;
    }
});
Object.defineProperty(exports, "safeGetHeader", {
    enumerable: true,
    get: function () {
        return (_httpExecutor || _load_httpExecutor()).safeGetHeader;
    }
});
Object.defineProperty(exports, "configureRequestOptions", {
    enumerable: true,
    get: function () {
        return (_httpExecutor || _load_httpExecutor()).configureRequestOptions;
    }
});
Object.defineProperty(exports, "configureRequestOptionsFromUrl", {
    enumerable: true,
    get: function () {
        return (_httpExecutor || _load_httpExecutor()).configureRequestOptionsFromUrl;
    }
});
Object.defineProperty(exports, "safeStringifyJson", {
    enumerable: true,
    get: function () {
        return (_httpExecutor || _load_httpExecutor()).safeStringifyJson;
    }
});
Object.defineProperty(exports, "parseJson", {
    enumerable: true,
    get: function () {
        return (_httpExecutor || _load_httpExecutor()).parseJson;
    }
});

var _publishOptions;

function _load_publishOptions() {
    return _publishOptions = __webpack_require__(131);
}

Object.defineProperty(exports, "getS3LikeProviderBaseUrl", {
    enumerable: true,
    get: function () {
        return (_publishOptions || _load_publishOptions()).getS3LikeProviderBaseUrl;
    }
});
Object.defineProperty(exports, "githubUrl", {
    enumerable: true,
    get: function () {
        return (_publishOptions || _load_publishOptions()).githubUrl;
    }
});

var _rfc2253Parser;

function _load_rfc2253Parser() {
    return _rfc2253Parser = __webpack_require__(132);
}

Object.defineProperty(exports, "parseDn", {
    enumerable: true,
    get: function () {
        return (_rfc2253Parser || _load_rfc2253Parser()).parseDn;
    }
});

var _uuid;

function _load_uuid() {
    return _uuid = __webpack_require__(133);
}

Object.defineProperty(exports, "UUID", {
    enumerable: true,
    get: function () {
        return (_uuid || _load_uuid()).UUID;
    }
});

var _ProgressCallbackTransform;

function _load_ProgressCallbackTransform() {
    return _ProgressCallbackTransform = __webpack_require__(52);
}

Object.defineProperty(exports, "ProgressCallbackTransform", {
    enumerable: true,
    get: function () {
        return (_ProgressCallbackTransform || _load_ProgressCallbackTransform()).ProgressCallbackTransform;
    }
});

var _xml;

function _load_xml() {
    return _xml = __webpack_require__(134);
}

Object.defineProperty(exports, "parseXml", {
    enumerable: true,
    get: function () {
        return (_xml || _load_xml()).parseXml;
    }
});
Object.defineProperty(exports, "XElement", {
    enumerable: true,
    get: function () {
        return (_xml || _load_xml()).XElement;
    }
});
exports.asArray = asArray;
exports.newError = newError;
function asArray(v) {
    if (v == null) {
        return [];
    } else if (Array.isArray(v)) {
        return v;
    } else {
        return [v];
    }
}
function newError(message, code) {
    const error = new Error(message);
    error.code = code;
    return error;
}
//# sourceMappingURL=index.js.map

/***/ }),
/* 4 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var YAMLException = __webpack_require__(21);

var TYPE_CONSTRUCTOR_OPTIONS = ['kind', 'resolve', 'construct', 'instanceOf', 'predicate', 'represent', 'defaultStyle', 'styleAliases'];

var YAML_NODE_KINDS = ['scalar', 'sequence', 'mapping'];

function compileStyleAliases(map) {
  var result = {};

  if (map !== null) {
    Object.keys(map).forEach(function (style) {
      map[style].forEach(function (alias) {
        result[String(alias)] = style;
      });
    });
  }

  return result;
}

function Type(tag, options) {
  options = options || {};

  Object.keys(options).forEach(function (name) {
    if (TYPE_CONSTRUCTOR_OPTIONS.indexOf(name) === -1) {
      throw new YAMLException('Unknown option "' + name + '" is met in definition of "' + tag + '" YAML type.');
    }
  });

  // TODO: Add tag format check.
  this.tag = tag;
  this.kind = options['kind'] || null;
  this.resolve = options['resolve'] || function () {
    return true;
  };
  this.construct = options['construct'] || function (data) {
    return data;
  };
  this.instanceOf = options['instanceOf'] || null;
  this.predicate = options['predicate'] || null;
  this.represent = options['represent'] || null;
  this.defaultStyle = options['defaultStyle'] || null;
  this.styleAliases = compileStyleAliases(options['styleAliases'] || null);

  if (YAML_NODE_KINDS.indexOf(this.kind) === -1) {
    throw new YAMLException('Unknown kind "' + this.kind + '" is specified for "' + tag + '" YAML type.');
  }
}

module.exports = Type;

/***/ }),
/* 5 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var fs = __webpack_require__(12);
var polyfills = __webpack_require__(109);
var legacy = __webpack_require__(111);
var queue = [];

var util = __webpack_require__(29);

function noop() {}

var debug = noop;
if (util.debuglog) debug = util.debuglog('gfs4');else if (/\bgfs4\b/i.test(process.env.NODE_DEBUG || '')) debug = function () {
  var m = util.format.apply(util, arguments);
  m = 'GFS4: ' + m.split(/\n/).join('\nGFS4: ');
  console.error(m);
};

if (/\bgfs4\b/i.test(process.env.NODE_DEBUG || '')) {
  process.on('exit', function () {
    debug(queue);
    __webpack_require__(46).equal(queue.length, 0);
  });
}

module.exports = patch(__webpack_require__(45));
if (process.env.TEST_GRACEFUL_FS_GLOBAL_PATCH) {
  module.exports = patch(fs);
}

// Always patch fs.close/closeSync, because we want to
// retry() whenever a close happens *anywhere* in the program.
// This is essential when multiple graceful-fs instances are
// in play at the same time.
module.exports.close = fs.close = function (fs$close) {
  return function (fd, cb) {
    return fs$close.call(fs, fd, function (err) {
      if (!err) retry();

      if (typeof cb === 'function') cb.apply(this, arguments);
    });
  };
}(fs.close);

module.exports.closeSync = fs.closeSync = function (fs$closeSync) {
  return function (fd) {
    // Note that graceful-fs also retries when fs.closeSync() fails.
    // Looks like a bug to me, although it's probably a harmless one.
    var rval = fs$closeSync.apply(fs, arguments);
    retry();
    return rval;
  };
}(fs.closeSync);

function patch(fs) {
  // Everything that references the open() function needs to be in here
  polyfills(fs);
  fs.gracefulify = patch;
  fs.FileReadStream = ReadStream; // Legacy name.
  fs.FileWriteStream = WriteStream; // Legacy name.
  fs.createReadStream = createReadStream;
  fs.createWriteStream = createWriteStream;
  var fs$readFile = fs.readFile;
  fs.readFile = readFile;
  function readFile(path, options, cb) {
    if (typeof options === 'function') cb = options, options = null;

    return go$readFile(path, options, cb);

    function go$readFile(path, options, cb) {
      return fs$readFile(path, options, function (err) {
        if (err && (err.code === 'EMFILE' || err.code === 'ENFILE')) enqueue([go$readFile, [path, options, cb]]);else {
          if (typeof cb === 'function') cb.apply(this, arguments);
          retry();
        }
      });
    }
  }

  var fs$writeFile = fs.writeFile;
  fs.writeFile = writeFile;
  function writeFile(path, data, options, cb) {
    if (typeof options === 'function') cb = options, options = null;

    return go$writeFile(path, data, options, cb);

    function go$writeFile(path, data, options, cb) {
      return fs$writeFile(path, data, options, function (err) {
        if (err && (err.code === 'EMFILE' || err.code === 'ENFILE')) enqueue([go$writeFile, [path, data, options, cb]]);else {
          if (typeof cb === 'function') cb.apply(this, arguments);
          retry();
        }
      });
    }
  }

  var fs$appendFile = fs.appendFile;
  if (fs$appendFile) fs.appendFile = appendFile;
  function appendFile(path, data, options, cb) {
    if (typeof options === 'function') cb = options, options = null;

    return go$appendFile(path, data, options, cb);

    function go$appendFile(path, data, options, cb) {
      return fs$appendFile(path, data, options, function (err) {
        if (err && (err.code === 'EMFILE' || err.code === 'ENFILE')) enqueue([go$appendFile, [path, data, options, cb]]);else {
          if (typeof cb === 'function') cb.apply(this, arguments);
          retry();
        }
      });
    }
  }

  var fs$readdir = fs.readdir;
  fs.readdir = readdir;
  function readdir(path, options, cb) {
    var args = [path];
    if (typeof options !== 'function') {
      args.push(options);
    } else {
      cb = options;
    }
    args.push(go$readdir$cb);

    return go$readdir(args);

    function go$readdir$cb(err, files) {
      if (files && files.sort) files.sort();

      if (err && (err.code === 'EMFILE' || err.code === 'ENFILE')) enqueue([go$readdir, [args]]);else {
        if (typeof cb === 'function') cb.apply(this, arguments);
        retry();
      }
    }
  }

  function go$readdir(args) {
    return fs$readdir.apply(fs, args);
  }

  if (process.version.substr(0, 4) === 'v0.8') {
    var legStreams = legacy(fs);
    ReadStream = legStreams.ReadStream;
    WriteStream = legStreams.WriteStream;
  }

  var fs$ReadStream = fs.ReadStream;
  ReadStream.prototype = Object.create(fs$ReadStream.prototype);
  ReadStream.prototype.open = ReadStream$open;

  var fs$WriteStream = fs.WriteStream;
  WriteStream.prototype = Object.create(fs$WriteStream.prototype);
  WriteStream.prototype.open = WriteStream$open;

  fs.ReadStream = ReadStream;
  fs.WriteStream = WriteStream;

  function ReadStream(path, options) {
    if (this instanceof ReadStream) return fs$ReadStream.apply(this, arguments), this;else return ReadStream.apply(Object.create(ReadStream.prototype), arguments);
  }

  function ReadStream$open() {
    var that = this;
    open(that.path, that.flags, that.mode, function (err, fd) {
      if (err) {
        if (that.autoClose) that.destroy();

        that.emit('error', err);
      } else {
        that.fd = fd;
        that.emit('open', fd);
        that.read();
      }
    });
  }

  function WriteStream(path, options) {
    if (this instanceof WriteStream) return fs$WriteStream.apply(this, arguments), this;else return WriteStream.apply(Object.create(WriteStream.prototype), arguments);
  }

  function WriteStream$open() {
    var that = this;
    open(that.path, that.flags, that.mode, function (err, fd) {
      if (err) {
        that.destroy();
        that.emit('error', err);
      } else {
        that.fd = fd;
        that.emit('open', fd);
      }
    });
  }

  function createReadStream(path, options) {
    return new ReadStream(path, options);
  }

  function createWriteStream(path, options) {
    return new WriteStream(path, options);
  }

  var fs$open = fs.open;
  fs.open = open;
  function open(path, flags, mode, cb) {
    if (typeof mode === 'function') cb = mode, mode = null;

    return go$open(path, flags, mode, cb);

    function go$open(path, flags, mode, cb) {
      return fs$open(path, flags, mode, function (err, fd) {
        if (err && (err.code === 'EMFILE' || err.code === 'ENFILE')) enqueue([go$open, [path, flags, mode, cb]]);else {
          if (typeof cb === 'function') cb.apply(this, arguments);
          retry();
        }
      });
    }
  }

  return fs;
}

function enqueue(elem) {
  debug('ENQUEUE', elem[0].name, elem[1]);
  queue.push(elem);
}

function retry() {
  var elem = queue.shift();
  if (elem) {
    debug('RETRY', elem[0].name, elem[1]);
    elem[0].apply(null, elem[1]);
  }
}

/***/ }),
/* 6 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.fromCallback = function (fn) {
  return Object.defineProperty(function () {
    if (typeof arguments[arguments.length - 1] === 'function') fn.apply(this, arguments);else {
      return new Promise((resolve, reject) => {
        arguments[arguments.length] = (err, res) => {
          if (err) return reject(err);
          resolve(res);
        };
        arguments.length++;
        fn.apply(this, arguments);
      });
    }
  }, 'name', { value: fn.name });
};

exports.fromPromise = function (fn) {
  return Object.defineProperty(function () {
    const cb = arguments[arguments.length - 1];
    if (typeof cb !== 'function') return fn.apply(this, arguments);else fn.apply(this, arguments).then(r => cb(null, r), cb);
  }, 'name', { value: fn.name });
};

/***/ }),
/* 7 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const u = __webpack_require__(6).fromCallback;
const mkdirs = u(__webpack_require__(113));
const mkdirsSync = __webpack_require__(114);

module.exports = {
  mkdirs: mkdirs,
  mkdirsSync: mkdirsSync,
  // alias
  mkdirp: mkdirs,
  mkdirpSync: mkdirsSync,
  ensureDir: mkdirs,
  ensureDirSync: mkdirsSync
};

/***/ }),
/* 8 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.UpdaterSignal = exports.UPDATE_DOWNLOADED = exports.DOWNLOAD_PROGRESS = exports.Provider = exports.CancellationToken = exports.NoOpLogger = exports.AppUpdater = undefined;

var _AppUpdater;

function _load_AppUpdater() {
    return _AppUpdater = __webpack_require__(27);
}

Object.defineProperty(exports, "AppUpdater", {
    enumerable: true,
    get: function () {
        return (_AppUpdater || _load_AppUpdater()).AppUpdater;
    }
});
Object.defineProperty(exports, "NoOpLogger", {
    enumerable: true,
    get: function () {
        return (_AppUpdater || _load_AppUpdater()).NoOpLogger;
    }
});

var _builderUtilRuntime;

function _load_builderUtilRuntime() {
    return _builderUtilRuntime = __webpack_require__(3);
}

Object.defineProperty(exports, "CancellationToken", {
    enumerable: true,
    get: function () {
        return (_builderUtilRuntime || _load_builderUtilRuntime()).CancellationToken;
    }
});

var _Provider;

function _load_Provider() {
    return _Provider = __webpack_require__(14);
}

Object.defineProperty(exports, "Provider", {
    enumerable: true,
    get: function () {
        return (_Provider || _load_Provider()).Provider;
    }
});
exports.getDefaultChannelName = getDefaultChannelName;
exports.getCustomChannelName = getCustomChannelName;
exports.getCurrentPlatform = getCurrentPlatform;
exports.isUseOldMacProvider = isUseOldMacProvider;
exports.getChannelFilename = getChannelFilename;
exports.newBaseUrl = newBaseUrl;
exports.newUrlFromBase = newUrlFromBase;

var _url;

function _load_url() {
    return _url = __webpack_require__(20);
}

// autoUpdater to mimic electron bundled autoUpdater
let _autoUpdater;
function _load_autoUpdater() {
    // tslint:disable:prefer-conditional-expression
    if (process.platform === "win32") {
        _autoUpdater = new (__webpack_require__(174).NsisUpdater)();
    } else if (process.platform === "darwin") {
        _autoUpdater = new (__webpack_require__(181).MacUpdater)();
    } else {
        _autoUpdater = new (__webpack_require__(182).AppImageUpdater)();
    }
    return _autoUpdater;
}
Object.defineProperty(exports, "autoUpdater", {
    enumerable: true,
    get: () => {
        return _autoUpdater || _load_autoUpdater();
    }
});
// due to historical reasons for windows we use channel name without platform specifier
function getDefaultChannelName() {
    return `latest${getChannelFilePrefix()}`;
}
function getChannelFilePrefix() {
    const currentPlatform = getCurrentPlatform();
    if (currentPlatform === "linux") {
        const arch = process.env.TEST_UPDATER_ARCH || process.arch;
        const archSuffix = arch === "x64" ? "" : `-${arch}`;
        return "-linux" + archSuffix;
    } else {
        return currentPlatform === "darwin" ? "-mac" : "";
    }
}
function getCustomChannelName(channel) {
    return `${channel}${getChannelFilePrefix()}`;
}
function getCurrentPlatform() {
    return process.env.TEST_UPDATER_PLATFORM || process.platform;
}
function isUseOldMacProvider() {
    // getCurrentPlatform() === "darwin"
    return false;
}
function getChannelFilename(channel) {
    return `${channel}.yml`;
}
const DOWNLOAD_PROGRESS = exports.DOWNLOAD_PROGRESS = "download-progress";
const UPDATE_DOWNLOADED = exports.UPDATE_DOWNLOADED = "update-downloaded";
class UpdaterSignal {
    constructor(emitter) {
        this.emitter = emitter;
    }
    /**
     * Emitted when an authenticating proxy is [asking for user credentials](https://github.com/electron/electron/blob/master/docs/api/client-request.md#event-login).
     */
    login(handler) {
        addHandler(this.emitter, "login", handler);
    }
    progress(handler) {
        addHandler(this.emitter, DOWNLOAD_PROGRESS, handler);
    }
    updateDownloaded(handler) {
        addHandler(this.emitter, UPDATE_DOWNLOADED, handler);
    }
    updateCancelled(handler) {
        addHandler(this.emitter, "update-cancelled", handler);
    }
}
exports.UpdaterSignal = UpdaterSignal;
const isLogEvent = false;
function addHandler(emitter, event, handler) {
    if (isLogEvent) {
        emitter.on(event, (...args) => {
            console.log("%s %s", event, args);
            handler.apply(null, args);
        });
    } else {
        emitter.on(event, handler);
    }
}
// if baseUrl path doesn't ends with /, this path will be not prepended to passed pathname for new URL(input, base)
/** @internal */
function newBaseUrl(url) {
    const result = new (_url || _load_url()).URL(url);
    if (!result.pathname.endsWith("/")) {
        result.pathname += "/";
    }
    return result;
}
/** @internal */
function newUrlFromBase(pathname, baseUrl) {
    const result = new (_url || _load_url()).URL(pathname, baseUrl);
    // search is not propagated
    if (!result.search && baseUrl.search) {
        result.search = baseUrl.search;
    }
    return result;
}
//# sourceMappingURL=main.js.map

/***/ }),
/* 9 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const fsExtra = __webpack_require__(107);
const Promise = __webpack_require__(2);

function makeFs(Promise) {
  const fs = Object.create(null);

  for (const methodName of Object.keys(fsExtra)) {
    const method = fsExtra[methodName];
    if (methodName === "createFile" || methodName === "mkdirp") {
      continue;
    }

    if (typeof method !== "function" || methodName.endsWith("Sync") || methodName.endsWith("Stream") || methodName.match(/^[A-Z]/) || methodName === "exists" || methodName === "watch" || methodName === "watchFile" || methodName === "unwatchFile") {
      fs[methodName] = method;
    } else {
      fs[methodName] = Promise.promisify(method);
    }
  }

  fs.createFile = fs.ensureFile;
  fs.mkdirp = fs.mkdirs;
  return fs;
}

module.exports = makeFs(Promise);

/***/ }),
/* 10 */
/***/ (function(module, exports) {

module.exports = require("electron");

/***/ }),
/* 11 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var es5 = __webpack_require__(16);
var Objectfreeze = es5.freeze;
var util = __webpack_require__(1);
var inherits = util.inherits;
var notEnumerableProp = util.notEnumerableProp;

function subError(nameProperty, defaultMessage) {
    function SubError(message) {
        if (!(this instanceof SubError)) return new SubError(message);
        notEnumerableProp(this, "message", typeof message === "string" ? message : defaultMessage);
        notEnumerableProp(this, "name", nameProperty);
        if (Error.captureStackTrace) {
            Error.captureStackTrace(this, this.constructor);
        } else {
            Error.call(this);
        }
    }
    inherits(SubError, Error);
    return SubError;
}

var _TypeError, _RangeError;
var Warning = subError("Warning", "warning");
var CancellationError = subError("CancellationError", "cancellation error");
var TimeoutError = subError("TimeoutError", "timeout error");
var AggregateError = subError("AggregateError", "aggregate error");
try {
    _TypeError = TypeError;
    _RangeError = RangeError;
} catch (e) {
    _TypeError = subError("TypeError", "type error");
    _RangeError = subError("RangeError", "range error");
}

var methods = ("join pop push shift unshift slice filter forEach some " + "every map indexOf lastIndexOf reduce reduceRight sort reverse").split(" ");

for (var i = 0; i < methods.length; ++i) {
    if (typeof Array.prototype[methods[i]] === "function") {
        AggregateError.prototype[methods[i]] = Array.prototype[methods[i]];
    }
}

es5.defineProperty(AggregateError.prototype, "length", {
    value: 0,
    configurable: false,
    writable: true,
    enumerable: true
});
AggregateError.prototype["isOperational"] = true;
var level = 0;
AggregateError.prototype.toString = function () {
    var indent = Array(level * 4 + 1).join(" ");
    var ret = "\n" + indent + "AggregateError of:" + "\n";
    level++;
    indent = Array(level * 4 + 1).join(" ");
    for (var i = 0; i < this.length; ++i) {
        var str = this[i] === this ? "[Circular AggregateError]" : this[i] + "";
        var lines = str.split("\n");
        for (var j = 0; j < lines.length; ++j) {
            lines[j] = indent + lines[j];
        }
        str = lines.join("\n");
        ret += str + "\n";
    }
    level--;
    return ret;
};

function OperationalError(message) {
    if (!(this instanceof OperationalError)) return new OperationalError(message);
    notEnumerableProp(this, "name", "OperationalError");
    notEnumerableProp(this, "message", message);
    this.cause = message;
    this["isOperational"] = true;

    if (message instanceof Error) {
        notEnumerableProp(this, "message", message.message);
        notEnumerableProp(this, "stack", message.stack);
    } else if (Error.captureStackTrace) {
        Error.captureStackTrace(this, this.constructor);
    }
}
inherits(OperationalError, Error);

var errorTypes = Error["__BluebirdErrorTypes__"];
if (!errorTypes) {
    errorTypes = Objectfreeze({
        CancellationError: CancellationError,
        TimeoutError: TimeoutError,
        OperationalError: OperationalError,
        RejectionError: OperationalError,
        AggregateError: AggregateError
    });
    es5.defineProperty(Error, "__BluebirdErrorTypes__", {
        value: errorTypes,
        writable: false,
        enumerable: false,
        configurable: false
    });
}

module.exports = {
    Error: Error,
    TypeError: _TypeError,
    RangeError: _RangeError,
    CancellationError: errorTypes.CancellationError,
    OperationalError: errorTypes.OperationalError,
    TimeoutError: errorTypes.TimeoutError,
    AggregateError: errorTypes.AggregateError,
    Warning: Warning
};

/***/ }),
/* 12 */
/***/ (function(module, exports) {

module.exports = require("fs");

/***/ }),
/* 13 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const u = __webpack_require__(6).fromPromise;
const fs = __webpack_require__(44);

function pathExists(path) {
  return fs.access(path).then(() => true).catch(() => false);
}

module.exports = {
  pathExists: u(pathExists),
  pathExistsSync: fs.existsSync
};

/***/ }),
/* 14 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Provider = undefined;
exports.findFile = findFile;
exports.parseUpdateInfo = parseUpdateInfo;
exports.getFileList = getFileList;
exports.resolveFiles = resolveFiles;

var _builderUtilRuntime;

function _load_builderUtilRuntime() {
    return _builderUtilRuntime = __webpack_require__(3);
}

var _jsYaml;

function _load_jsYaml() {
    return _jsYaml = __webpack_require__(31);
}

var _main;

function _load_main() {
    return _main = __webpack_require__(8);
}

class Provider {
    constructor(executor, useMultipleRangeRequest = true) {
        this.executor = executor;
        this.useMultipleRangeRequest = useMultipleRangeRequest;
    }
    get fileExtraDownloadHeaders() {
        return null;
    }
    setRequestHeaders(value) {
        this.requestHeaders = value;
    }
    httpRequest(url, headers, cancellationToken) {
        return this.executor.request(this.createRequestOptions(url, headers), cancellationToken);
    }
    createRequestOptions(url, headers) {
        const result = {};
        if (this.requestHeaders == null) {
            if (headers != null) {
                result.headers = headers;
            }
        } else {
            result.headers = headers == null ? this.requestHeaders : Object.assign({}, this.requestHeaders, headers);
        }
        result.protocol = url.protocol;
        result.hostname = url.hostname;
        if (url.port) {
            result.port = url.port;
        }
        result.path = url.pathname + url.search;
        return result;
    }
}
exports.Provider = Provider;
function findFile(files, extension, not) {
    if (files.length === 0) {
        throw (0, (_builderUtilRuntime || _load_builderUtilRuntime()).newError)("No files provided", "ERR_UPDATER_NO_FILES_PROVIDED");
    }
    const result = files.find(it => it.url.pathname.toLowerCase().endsWith(`.${extension}`));
    if (result != null) {
        return result;
    } else if (not == null) {
        return files[0];
    } else {
        return files.find(fileInfo => !not.some(ext => fileInfo.url.pathname.toLowerCase().endsWith(`.${ext}`)));
    }
}
function parseUpdateInfo(rawData, channelFile, channelFileUrl) {
    if (rawData == null) {
        throw (0, (_builderUtilRuntime || _load_builderUtilRuntime()).newError)(`Cannot parse update info from ${channelFile} in the latest release artifacts (${channelFileUrl}): rawData: null`, "ERR_UPDATER_INVALID_UPDATE_INFO");
    }
    let result;
    try {
        result = (0, (_jsYaml || _load_jsYaml()).safeLoad)(rawData);
    } catch (e) {
        throw (0, (_builderUtilRuntime || _load_builderUtilRuntime()).newError)(`Cannot parse update info from ${channelFile} in the latest release artifacts (${channelFileUrl}): ${e.stack || e.message}, rawData: ${rawData}`, "ERR_UPDATER_INVALID_UPDATE_INFO");
    }
    return result;
}
function getFileList(updateInfo) {
    const files = updateInfo.files;
    if (files != null && files.length > 0) {
        return files;
    }
    if (updateInfo.path != null) {
        return [{
            url: updateInfo.path,
            sha512: updateInfo.sha512
        }];
    } else {
        throw (0, (_builderUtilRuntime || _load_builderUtilRuntime()).newError)(`No files provided: ${(0, (_builderUtilRuntime || _load_builderUtilRuntime()).safeStringifyJson)(updateInfo)}`, "ERR_UPDATER_NO_FILES_PROVIDED");
    }
}
function resolveFiles(updateInfo, baseUrl, pathTransformer = p => p) {
    const files = getFileList(updateInfo);
    const result = files.map(fileInfo => {
        if (fileInfo.sha2 == null && fileInfo.sha512 == null) {
            throw (0, (_builderUtilRuntime || _load_builderUtilRuntime()).newError)(`Update info doesn't contain nor sha256 neither sha512 checksum: ${(0, (_builderUtilRuntime || _load_builderUtilRuntime()).safeStringifyJson)(fileInfo)}`, "ERR_UPDATER_NO_CHECKSUM");
        }
        return {
            url: (0, (_main || _load_main()).newUrlFromBase)(pathTransformer(fileInfo.url), baseUrl),
            info: fileInfo
        };
    });
    const packages = updateInfo.packages;
    const packageInfo = packages == null ? null : packages[process.arch] || packages.ia32;
    if (packageInfo != null) {
        result[0].packageInfo = Object.assign({}, packageInfo, { path: (0, (_main || _load_main()).newUrlFromBase)(pathTransformer(packageInfo.path), baseUrl).href });
    }
    return result;
}
//# sourceMappingURL=Provider.js.map

/***/ }),
/* 15 */
/***/ (function(module, exports) {

module.exports = require("os");

/***/ }),
/* 16 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var isES5 = function () {
    "use strict";

    return this === undefined;
}();

if (isES5) {
    module.exports = {
        freeze: Object.freeze,
        defineProperty: Object.defineProperty,
        getDescriptor: Object.getOwnPropertyDescriptor,
        keys: Object.keys,
        names: Object.getOwnPropertyNames,
        getPrototypeOf: Object.getPrototypeOf,
        isArray: Array.isArray,
        isES5: isES5,
        propertyIsWritable: function (obj, prop) {
            var descriptor = Object.getOwnPropertyDescriptor(obj, prop);
            return !!(!descriptor || descriptor.writable || descriptor.set);
        }
    };
} else {
    var has = {}.hasOwnProperty;
    var str = {}.toString;
    var proto = {}.constructor.prototype;

    var ObjectKeys = function (o) {
        var ret = [];
        for (var key in o) {
            if (has.call(o, key)) {
                ret.push(key);
            }
        }
        return ret;
    };

    var ObjectGetDescriptor = function (o, key) {
        return { value: o[key] };
    };

    var ObjectDefineProperty = function (o, key, desc) {
        o[key] = desc.value;
        return o;
    };

    var ObjectFreeze = function (obj) {
        return obj;
    };

    var ObjectGetPrototypeOf = function (obj) {
        try {
            return Object(obj).constructor.prototype;
        } catch (e) {
            return proto;
        }
    };

    var ArrayIsArray = function (obj) {
        try {
            return str.call(obj) === "[object Array]";
        } catch (e) {
            return false;
        }
    };

    module.exports = {
        isArray: ArrayIsArray,
        keys: ObjectKeys,
        names: ObjectKeys,
        defineProperty: ObjectDefineProperty,
        getDescriptor: ObjectGetDescriptor,
        freeze: ObjectFreeze,
        getPrototypeOf: ObjectGetPrototypeOf,
        isES5: isES5,
        propertyIsWritable: function () {
            return true;
        }
    };
}

/***/ }),
/* 17 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


function isNothing(subject) {
  return typeof subject === 'undefined' || subject === null;
}

function isObject(subject) {
  return typeof subject === 'object' && subject !== null;
}

function toArray(sequence) {
  if (Array.isArray(sequence)) return sequence;else if (isNothing(sequence)) return [];

  return [sequence];
}

function extend(target, source) {
  var index, length, key, sourceKeys;

  if (source) {
    sourceKeys = Object.keys(source);

    for (index = 0, length = sourceKeys.length; index < length; index += 1) {
      key = sourceKeys[index];
      target[key] = source[key];
    }
  }

  return target;
}

function repeat(string, count) {
  var result = '',
      cycle;

  for (cycle = 0; cycle < count; cycle += 1) {
    result += string;
  }

  return result;
}

function isNegativeZero(number) {
  return number === 0 && Number.NEGATIVE_INFINITY === 1 / number;
}

module.exports.isNothing = isNothing;
module.exports.isObject = isObject;
module.exports.toArray = toArray;
module.exports.repeat = repeat;
module.exports.isNegativeZero = isNegativeZero;
module.exports.extend = extend;

/***/ }),
/* 18 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/*eslint-disable max-len*/

var common = __webpack_require__(17);
var YAMLException = __webpack_require__(21);
var Type = __webpack_require__(4);

function compileList(schema, name, result) {
  var exclude = [];

  schema.include.forEach(function (includedSchema) {
    result = compileList(includedSchema, name, result);
  });

  schema[name].forEach(function (currentType) {
    result.forEach(function (previousType, previousIndex) {
      if (previousType.tag === currentType.tag && previousType.kind === currentType.kind) {
        exclude.push(previousIndex);
      }
    });

    result.push(currentType);
  });

  return result.filter(function (type, index) {
    return exclude.indexOf(index) === -1;
  });
}

function compileMap() /* lists... */{
  var result = {
    scalar: {},
    sequence: {},
    mapping: {},
    fallback: {}
  },
      index,
      length;

  function collectType(type) {
    result[type.kind][type.tag] = result['fallback'][type.tag] = type;
  }

  for (index = 0, length = arguments.length; index < length; index += 1) {
    arguments[index].forEach(collectType);
  }
  return result;
}

function Schema(definition) {
  this.include = definition.include || [];
  this.implicit = definition.implicit || [];
  this.explicit = definition.explicit || [];

  this.implicit.forEach(function (type) {
    if (type.loadKind && type.loadKind !== 'scalar') {
      throw new YAMLException('There is a non-scalar type in the implicit list of a schema. Implicit resolving of such types is not supported.');
    }
  });

  this.compiledImplicit = compileList(this, 'implicit', []);
  this.compiledExplicit = compileList(this, 'explicit', []);
  this.compiledTypeMap = compileMap(this.compiledImplicit, this.compiledExplicit);
}

Schema.DEFAULT = null;

Schema.create = function createSchema() {
  var schemas, types;

  switch (arguments.length) {
    case 1:
      schemas = Schema.DEFAULT;
      types = arguments[0];
      break;

    case 2:
      schemas = arguments[0];
      types = arguments[1];
      break;

    default:
      throw new YAMLException('Wrong number of arguments for Schema.create function');
  }

  schemas = common.toArray(schemas);
  types = common.toArray(types);

  if (!schemas.every(function (schema) {
    return schema instanceof Schema;
  })) {
    throw new YAMLException('Specified list of super schemas (or a single Schema object) contains a non-Schema object.');
  }

  if (!types.every(function (type) {
    return type instanceof Type;
  })) {
    throw new YAMLException('Specified list of YAML types (or a single Type object) contains a non-Type object.');
  }

  return new Schema({
    include: schemas,
    explicit: types
  });
};

module.exports = Schema;

/***/ }),
/* 19 */
/***/ (function(module, exports) {

module.exports = require("stream");

/***/ }),
/* 20 */
/***/ (function(module, exports) {

module.exports = require("url");

/***/ }),
/* 21 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// YAML error class. http://stackoverflow.com/questions/8458984
//


function YAMLException(reason, mark) {
  // Super constructor
  Error.call(this);

  this.name = 'YAMLException';
  this.reason = reason;
  this.mark = mark;
  this.message = (this.reason || '(unknown reason)') + (this.mark ? ' ' + this.mark.toString() : '');

  // Include stack trace in error object
  if (Error.captureStackTrace) {
    // Chrome and NodeJS
    Error.captureStackTrace(this, this.constructor);
  } else {
    // FF, IE 10+ and Safari 6+. Fallback for others
    this.stack = new Error().stack || '';
  }
}

// Inherit from Error
YAMLException.prototype = Object.create(Error.prototype);
YAMLException.prototype.constructor = YAMLException;

YAMLException.prototype.toString = function toString(compact) {
  var result = this.name + ': ';

  result += this.reason || '(unknown reason)';

  if (!compact && this.mark) {
    result += ' ' + this.mark.toString();
  }

  return result;
};

module.exports = YAMLException;

/***/ }),
/* 22 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// JS-YAML's default schema for `safeLoad` function.
// It is not described in the YAML specification.
//
// This schema is based on standard YAML's Core schema and includes most of
// extra types described at YAML tag repository. (http://yaml.org/type/)




var Schema = __webpack_require__(18);

module.exports = new Schema({
  include: [__webpack_require__(53)],
  implicit: [__webpack_require__(147), __webpack_require__(148)],
  explicit: [__webpack_require__(149), __webpack_require__(151), __webpack_require__(152), __webpack_require__(153)]
});

/***/ }),
/* 23 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/* -*- Mode: js; js-indent-level: 2; -*- */
/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */

/**
 * This is a helper function for getting values from parameter/options
 * objects.
 *
 * @param args The object we are extracting values from
 * @param name The name of the property we are getting.
 * @param defaultValue An optional value to return if the property is missing
 * from the object. If this is not specified and the property is missing, an
 * error will be thrown.
 */
function getArg(aArgs, aName, aDefaultValue) {
  if (aName in aArgs) {
    return aArgs[aName];
  } else if (arguments.length === 3) {
    return aDefaultValue;
  } else {
    throw new Error('"' + aName + '" is a required argument.');
  }
}
exports.getArg = getArg;

var urlRegexp = /^(?:([\w+\-.]+):)?\/\/(?:(\w+:\w+)@)?([\w.-]*)(?::(\d+))?(.*)$/;
var dataUrlRegexp = /^data:.+\,.+$/;

function urlParse(aUrl) {
  var match = aUrl.match(urlRegexp);
  if (!match) {
    return null;
  }
  return {
    scheme: match[1],
    auth: match[2],
    host: match[3],
    port: match[4],
    path: match[5]
  };
}
exports.urlParse = urlParse;

function urlGenerate(aParsedUrl) {
  var url = '';
  if (aParsedUrl.scheme) {
    url += aParsedUrl.scheme + ':';
  }
  url += '//';
  if (aParsedUrl.auth) {
    url += aParsedUrl.auth + '@';
  }
  if (aParsedUrl.host) {
    url += aParsedUrl.host;
  }
  if (aParsedUrl.port) {
    url += ":" + aParsedUrl.port;
  }
  if (aParsedUrl.path) {
    url += aParsedUrl.path;
  }
  return url;
}
exports.urlGenerate = urlGenerate;

/**
 * Normalizes a path, or the path portion of a URL:
 *
 * - Replaces consecutive slashes with one slash.
 * - Removes unnecessary '.' parts.
 * - Removes unnecessary '<dir>/..' parts.
 *
 * Based on code in the Node.js 'path' core module.
 *
 * @param aPath The path or url to normalize.
 */
function normalize(aPath) {
  var path = aPath;
  var url = urlParse(aPath);
  if (url) {
    if (!url.path) {
      return aPath;
    }
    path = url.path;
  }
  var isAbsolute = exports.isAbsolute(path);

  var parts = path.split(/\/+/);
  for (var part, up = 0, i = parts.length - 1; i >= 0; i--) {
    part = parts[i];
    if (part === '.') {
      parts.splice(i, 1);
    } else if (part === '..') {
      up++;
    } else if (up > 0) {
      if (part === '') {
        // The first part is blank if the path is absolute. Trying to go
        // above the root is a no-op. Therefore we can remove all '..' parts
        // directly after the root.
        parts.splice(i + 1, up);
        up = 0;
      } else {
        parts.splice(i, 2);
        up--;
      }
    }
  }
  path = parts.join('/');

  if (path === '') {
    path = isAbsolute ? '/' : '.';
  }

  if (url) {
    url.path = path;
    return urlGenerate(url);
  }
  return path;
}
exports.normalize = normalize;

/**
 * Joins two paths/URLs.
 *
 * @param aRoot The root path or URL.
 * @param aPath The path or URL to be joined with the root.
 *
 * - If aPath is a URL or a data URI, aPath is returned, unless aPath is a
 *   scheme-relative URL: Then the scheme of aRoot, if any, is prepended
 *   first.
 * - Otherwise aPath is a path. If aRoot is a URL, then its path portion
 *   is updated with the result and aRoot is returned. Otherwise the result
 *   is returned.
 *   - If aPath is absolute, the result is aPath.
 *   - Otherwise the two paths are joined with a slash.
 * - Joining for example 'http://' and 'www.example.com' is also supported.
 */
function join(aRoot, aPath) {
  if (aRoot === "") {
    aRoot = ".";
  }
  if (aPath === "") {
    aPath = ".";
  }
  var aPathUrl = urlParse(aPath);
  var aRootUrl = urlParse(aRoot);
  if (aRootUrl) {
    aRoot = aRootUrl.path || '/';
  }

  // `join(foo, '//www.example.org')`
  if (aPathUrl && !aPathUrl.scheme) {
    if (aRootUrl) {
      aPathUrl.scheme = aRootUrl.scheme;
    }
    return urlGenerate(aPathUrl);
  }

  if (aPathUrl || aPath.match(dataUrlRegexp)) {
    return aPath;
  }

  // `join('http://', 'www.example.com')`
  if (aRootUrl && !aRootUrl.host && !aRootUrl.path) {
    aRootUrl.host = aPath;
    return urlGenerate(aRootUrl);
  }

  var joined = aPath.charAt(0) === '/' ? aPath : normalize(aRoot.replace(/\/+$/, '') + '/' + aPath);

  if (aRootUrl) {
    aRootUrl.path = joined;
    return urlGenerate(aRootUrl);
  }
  return joined;
}
exports.join = join;

exports.isAbsolute = function (aPath) {
  return aPath.charAt(0) === '/' || urlRegexp.test(aPath);
};

/**
 * Make a path relative to a URL or another path.
 *
 * @param aRoot The root path or URL.
 * @param aPath The path or URL to be made relative to aRoot.
 */
function relative(aRoot, aPath) {
  if (aRoot === "") {
    aRoot = ".";
  }

  aRoot = aRoot.replace(/\/$/, '');

  // It is possible for the path to be above the root. In this case, simply
  // checking whether the root is a prefix of the path won't work. Instead, we
  // need to remove components from the root one by one, until either we find
  // a prefix that fits, or we run out of components to remove.
  var level = 0;
  while (aPath.indexOf(aRoot + '/') !== 0) {
    var index = aRoot.lastIndexOf("/");
    if (index < 0) {
      return aPath;
    }

    // If the only part of the root that is left is the scheme (i.e. http://,
    // file:///, etc.), one or more slashes (/), or simply nothing at all, we
    // have exhausted all components, so the path is not relative to the root.
    aRoot = aRoot.slice(0, index);
    if (aRoot.match(/^([^\/]+:\/)?\/*$/)) {
      return aPath;
    }

    ++level;
  }

  // Make sure we add a "../" for each component we removed from the root.
  return Array(level + 1).join("../") + aPath.substr(aRoot.length + 1);
}
exports.relative = relative;

var supportsNullProto = function () {
  var obj = Object.create(null);
  return !('__proto__' in obj);
}();

function identity(s) {
  return s;
}

/**
 * Because behavior goes wacky when you set `__proto__` on objects, we
 * have to prefix all the strings in our set with an arbitrary character.
 *
 * See https://github.com/mozilla/source-map/pull/31 and
 * https://github.com/mozilla/source-map/issues/30
 *
 * @param String aStr
 */
function toSetString(aStr) {
  if (isProtoString(aStr)) {
    return '$' + aStr;
  }

  return aStr;
}
exports.toSetString = supportsNullProto ? identity : toSetString;

function fromSetString(aStr) {
  if (isProtoString(aStr)) {
    return aStr.slice(1);
  }

  return aStr;
}
exports.fromSetString = supportsNullProto ? identity : fromSetString;

function isProtoString(s) {
  if (!s) {
    return false;
  }

  var length = s.length;

  if (length < 9 /* "__proto__".length */) {
      return false;
    }

  if (s.charCodeAt(length - 1) !== 95 /* '_' */ || s.charCodeAt(length - 2) !== 95 /* '_' */ || s.charCodeAt(length - 3) !== 111 /* 'o' */ || s.charCodeAt(length - 4) !== 116 /* 't' */ || s.charCodeAt(length - 5) !== 111 /* 'o' */ || s.charCodeAt(length - 6) !== 114 /* 'r' */ || s.charCodeAt(length - 7) !== 112 /* 'p' */ || s.charCodeAt(length - 8) !== 95 /* '_' */ || s.charCodeAt(length - 9) !== 95 /* '_' */) {
      return false;
    }

  for (var i = length - 10; i >= 0; i--) {
    if (s.charCodeAt(i) !== 36 /* '$' */) {
        return false;
      }
  }

  return true;
}

/**
 * Comparator between two mappings where the original positions are compared.
 *
 * Optionally pass in `true` as `onlyCompareGenerated` to consider two
 * mappings with the same original source/line/column, but different generated
 * line and column the same. Useful when searching for a mapping with a
 * stubbed out mapping.
 */
function compareByOriginalPositions(mappingA, mappingB, onlyCompareOriginal) {
  var cmp = strcmp(mappingA.source, mappingB.source);
  if (cmp !== 0) {
    return cmp;
  }

  cmp = mappingA.originalLine - mappingB.originalLine;
  if (cmp !== 0) {
    return cmp;
  }

  cmp = mappingA.originalColumn - mappingB.originalColumn;
  if (cmp !== 0 || onlyCompareOriginal) {
    return cmp;
  }

  cmp = mappingA.generatedColumn - mappingB.generatedColumn;
  if (cmp !== 0) {
    return cmp;
  }

  cmp = mappingA.generatedLine - mappingB.generatedLine;
  if (cmp !== 0) {
    return cmp;
  }

  return strcmp(mappingA.name, mappingB.name);
}
exports.compareByOriginalPositions = compareByOriginalPositions;

/**
 * Comparator between two mappings with deflated source and name indices where
 * the generated positions are compared.
 *
 * Optionally pass in `true` as `onlyCompareGenerated` to consider two
 * mappings with the same generated line and column, but different
 * source/name/original line and column the same. Useful when searching for a
 * mapping with a stubbed out mapping.
 */
function compareByGeneratedPositionsDeflated(mappingA, mappingB, onlyCompareGenerated) {
  var cmp = mappingA.generatedLine - mappingB.generatedLine;
  if (cmp !== 0) {
    return cmp;
  }

  cmp = mappingA.generatedColumn - mappingB.generatedColumn;
  if (cmp !== 0 || onlyCompareGenerated) {
    return cmp;
  }

  cmp = strcmp(mappingA.source, mappingB.source);
  if (cmp !== 0) {
    return cmp;
  }

  cmp = mappingA.originalLine - mappingB.originalLine;
  if (cmp !== 0) {
    return cmp;
  }

  cmp = mappingA.originalColumn - mappingB.originalColumn;
  if (cmp !== 0) {
    return cmp;
  }

  return strcmp(mappingA.name, mappingB.name);
}
exports.compareByGeneratedPositionsDeflated = compareByGeneratedPositionsDeflated;

function strcmp(aStr1, aStr2) {
  if (aStr1 === aStr2) {
    return 0;
  }

  if (aStr1 === null) {
    return 1; // aStr2 !== null
  }

  if (aStr2 === null) {
    return -1; // aStr1 !== null
  }

  if (aStr1 > aStr2) {
    return 1;
  }

  return -1;
}

/**
 * Comparator between two mappings with inflated source and name strings where
 * the generated positions are compared.
 */
function compareByGeneratedPositionsInflated(mappingA, mappingB) {
  var cmp = mappingA.generatedLine - mappingB.generatedLine;
  if (cmp !== 0) {
    return cmp;
  }

  cmp = mappingA.generatedColumn - mappingB.generatedColumn;
  if (cmp !== 0) {
    return cmp;
  }

  cmp = strcmp(mappingA.source, mappingB.source);
  if (cmp !== 0) {
    return cmp;
  }

  cmp = mappingA.originalLine - mappingB.originalLine;
  if (cmp !== 0) {
    return cmp;
  }

  cmp = mappingA.originalColumn - mappingB.originalColumn;
  if (cmp !== 0) {
    return cmp;
  }

  return strcmp(mappingA.name, mappingB.name);
}
exports.compareByGeneratedPositionsInflated = compareByGeneratedPositionsInflated;

/**
 * Strip any JSON XSSI avoidance prefix from the string (as documented
 * in the source maps specification), and then parse the string as
 * JSON.
 */
function parseSourceMapInput(str) {
  return JSON.parse(str.replace(/^\)]}'[^\n]*\n/, ''));
}
exports.parseSourceMapInput = parseSourceMapInput;

/**
 * Compute the URL of a source given the the source root, the source's
 * URL, and the source map's URL.
 */
function computeSourceURL(sourceRoot, sourceURL, sourceMapURL) {
  sourceURL = sourceURL || '';

  if (sourceRoot) {
    // This follows what Chrome does.
    if (sourceRoot[sourceRoot.length - 1] !== '/' && sourceURL[0] !== '/') {
      sourceRoot += '/';
    }
    // The spec says:
    //   Line 4: An optional source root, useful for relocating source
    //   files on a server or removing repeated values in the
    //   sources entry.  This value is prepended to the individual
    //   entries in the source field.
    sourceURL = sourceRoot + sourceURL;
  }

  // Historically, SourceMapConsumer did not take the sourceMapURL as
  // a parameter.  This mode is still somewhat supported, which is why
  // this code block is conditional.  However, it's preferable to pass
  // the source map URL to SourceMapConsumer, so that this function
  // can implement the source URL resolution algorithm as outlined in
  // the spec.  This block is basically the equivalent of:
  //    new URL(sourceURL, sourceMapURL).toString()
  // ... except it avoids using URL, which wasn't available in the
  // older releases of node still supported by this library.
  //
  // The spec says:
  //   If the sources are not absolute URLs after prepending of the
  //   sourceRoot, the sources are resolved relative to the
  //   SourceMap (like resolving script src in a html document).
  if (sourceMapURL) {
    var parsed = urlParse(sourceMapURL);
    if (!parsed) {
      throw new Error("sourceMapURL could not be parsed");
    }
    if (parsed.path) {
      // Strip the last path component, but keep the "/".
      var index = parsed.path.lastIndexOf('/');
      if (index >= 0) {
        parsed.path = parsed.path.substring(0, index + 1);
      }
    }
    sourceURL = join(urlGenerate(parsed), sourceURL);
  }

  return normalize(sourceURL);
}
exports.computeSourceURL = computeSourceURL;

/***/ }),
/* 24 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const u = __webpack_require__(6).fromCallback;
const rimraf = __webpack_require__(116);

module.exports = {
  remove: u(rimraf),
  removeSync: rimraf.sync
};

/***/ }),
/* 25 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// JS-YAML's default schema for `load` function.
// It is not described in the YAML specification.
//
// This schema is based on JS-YAML's default safe schema and includes
// JavaScript-specific types: !!js/undefined, !!js/regexp and !!js/function.
//
// Also this schema is used as default base schema at `Schema.create` function.




var Schema = __webpack_require__(18);

module.exports = Schema.DEFAULT = new Schema({
  include: [__webpack_require__(22)],
  explicit: [__webpack_require__(154), __webpack_require__(155), __webpack_require__(156)]
});

/***/ }),
/* 26 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const getFromEnv = parseInt(process.env.ELECTRON_IS_DEV, 10) === 1;
const isEnvSet = 'ELECTRON_IS_DEV' in process.env;

module.exports = isEnvSet ? getFromEnv : process.defaultApp || /node_modules[\\/]electron[\\/]/.test(process.execPath);

/***/ }),
/* 27 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.NoOpLogger = exports.AppUpdater = undefined;

var _bluebirdLst;

function _load_bluebirdLst() {
    return _bluebirdLst = __webpack_require__(2);
}

var _bluebirdLst2;

function _load_bluebirdLst2() {
    return _bluebirdLst2 = _interopRequireDefault(__webpack_require__(2));
}

var _builderUtilRuntime;

function _load_builderUtilRuntime() {
    return _builderUtilRuntime = __webpack_require__(3);
}

var _crypto;

function _load_crypto() {
    return _crypto = __webpack_require__(28);
}

var _electron;

function _load_electron() {
    return _electron = __webpack_require__(10);
}

var _electronIsDev;

function _load_electronIsDev() {
    return _electronIsDev = _interopRequireDefault(__webpack_require__(26));
}

var _events;

function _load_events() {
    return _events = __webpack_require__(41);
}

var _fsExtraP;

function _load_fsExtraP() {
    return _fsExtraP = __webpack_require__(9);
}

var _jsYaml;

function _load_jsYaml() {
    return _jsYaml = __webpack_require__(31);
}

var _lazyVal;

function _load_lazyVal() {
    return _lazyVal = __webpack_require__(159);
}

var _path = _interopRequireWildcard(__webpack_require__(0));

var _semver;

function _load_semver() {
    return _semver = __webpack_require__(55);
}

__webpack_require__(33);

var _electronHttpExecutor;

function _load_electronHttpExecutor() {
    return _electronHttpExecutor = __webpack_require__(169);
}

var _GenericProvider;

function _load_GenericProvider() {
    return _GenericProvider = __webpack_require__(59);
}

var _main;

function _load_main() {
    return _main = __webpack_require__(8);
}

var _providerFactory;

function _load_providerFactory() {
    return _providerFactory = __webpack_require__(170);
}

function _interopRequireWildcard(obj) {
    if (obj && obj.__esModule) {
        return obj;
    } else {
        var newObj = {};if (obj != null) {
            for (var key in obj) {
                if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key];
            }
        }newObj.default = obj;return newObj;
    }
}

function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
}

class AppUpdater extends (_events || _load_events()).EventEmitter {
    constructor(options, app) {
        super();
        /**
         * Whether to automatically download an update when it is found.
         */
        this.autoDownload = true;
        /**
         * *GitHub provider only.* Whether to allow update to pre-release versions. Defaults to `true` if application version contains prerelease components (e.g. `0.12.1-alpha.1`, here `alpha` is a prerelease component), otherwise `false`.
         *
         * If `true`, downgrade will be allowed (`allowDowngrade` will be set to `true`).
         */
        this.allowPrerelease = false;
        /**
         * *GitHub provider only.* Get all release notes (from current version to latest), not just the latest.
         * @default false
         */
        this.fullChangelog = false;
        /**
         * Whether to allow version downgrade (when a user from the beta channel wants to go back to the stable channel).
         * @default false
         */
        this.allowDowngrade = false;
        this._channel = null;
        this._logger = console;
        /**
         * For type safety you can use signals, e.g. `autoUpdater.signals.updateDownloaded(() => {})` instead of `autoUpdater.on('update-available', () => {})`
         */
        this.signals = new (_main || _load_main()).UpdaterSignal(this);
        this.updateAvailable = false;
        this.stagingUserIdPromise = new (_lazyVal || _load_lazyVal()).Lazy(() => this.getOrCreateStagingUserId());
        // public, allow to read old config for anyone
        this.configOnDisk = new (_lazyVal || _load_lazyVal()).Lazy(() => this.loadUpdateConfig());
        this.on("error", error => {
            this._logger.error(`Error: ${error.stack || error.message}`);
        });
        if (app != null || global.__test_app != null) {
            this.app = app || global.__test_app;
            this.untilAppReady = (_bluebirdLst2 || _load_bluebirdLst2()).default.resolve();
        } else {
            this.app = __webpack_require__(10).app;
            this.httpExecutor = new (_electronHttpExecutor || _load_electronHttpExecutor()).ElectronHttpExecutor((authInfo, callback) => this.emit("login", authInfo, callback));
            this.untilAppReady = new (_bluebirdLst2 || _load_bluebirdLst2()).default(resolve => {
                if (this.app.isReady()) {
                    resolve();
                } else {
                    this.app.on("ready", resolve);
                }
            });
        }
        const currentVersionString = this.app.getVersion();
        const currentVersion = (0, (_semver || _load_semver()).valid)(currentVersionString);
        if (currentVersion == null) {
            throw (0, (_builderUtilRuntime || _load_builderUtilRuntime()).newError)(`App version is not a valid semver version: "${currentVersionString}`, "ERR_UPDATER_INVALID_VERSION");
        }
        this.currentVersion = currentVersion;
        this.allowPrerelease = hasPrereleaseComponents(this.currentVersion);
        if (options != null) {
            this.setFeedURL(options);
        }
    }
    /**
     * Get the update channel. Not applicable for GitHub. Doesn't return `channel` from the update configuration, only if was previously set.
     */
    get channel() {
        return this._channel;
    }
    /**
     * Set the update channel. Not applicable for GitHub. Overrides `channel` in the update configuration.
     *
     * `allowDowngrade` will be automatically set to `true`. If this behavior is not suitable for you, simple set `allowDowngrade` explicitly after.
     */
    set channel(value) {
        if (this._channel != null) {
            if (typeof value !== "string") {
                throw (0, (_builderUtilRuntime || _load_builderUtilRuntime()).newError)(`Channel must be a string, but got: ${value}`, "ERR_UPDATER_INVALID_CHANNEL");
            } else if (value.length === 0) {
                throw (0, (_builderUtilRuntime || _load_builderUtilRuntime()).newError)(`Channel must be not an empty string`, "ERR_UPDATER_INVALID_CHANNEL");
            }
        }
        this._channel = value;
        this.allowDowngrade = true;
    }
    /**
     * The logger. You can pass [electron-log](https://github.com/megahertz/electron-log), [winston](https://github.com/winstonjs/winston) or another logger with the following interface: `{ info(), warn(), error() }`.
     * Set it to `null` if you would like to disable a logging feature.
     */
    get logger() {
        return this._logger;
    }
    set logger(value) {
        this._logger = value == null ? new NoOpLogger() : value;
    }
    /**
     * test only
     * @private
     */
    set updateConfigPath(value) {
        this.clientPromise = null;
        this._appUpdateConfigPath = value;
        this.configOnDisk = new (_lazyVal || _load_lazyVal()).Lazy(() => this.loadUpdateConfig());
    }
    get provider() {
        return this.clientPromise;
    }
    //noinspection JSMethodCanBeStatic,JSUnusedGlobalSymbols
    getFeedURL() {
        return "Deprecated. Do not use it.";
    }
    /**
     * Configure update provider. If value is `string`, [GenericServerOptions](/configuration/publish.md#genericserveroptions) will be set with value as `url`.
     * @param options If you want to override configuration in the `app-update.yml`.
     */
    setFeedURL(options) {
        // https://github.com/electron-userland/electron-builder/issues/1105
        let provider;
        if (typeof options === "string") {
            provider = new (_GenericProvider || _load_GenericProvider()).GenericProvider({ provider: "generic", url: options }, this);
        } else {
            provider = (0, (_providerFactory || _load_providerFactory()).createClient)(options, this);
        }
        this.clientPromise = Promise.resolve(provider);
    }
    /**
     * Asks the server whether there is an update.
     */
    checkForUpdates() {
        let checkForUpdatesPromise = this.checkForUpdatesPromise;
        if (checkForUpdatesPromise != null) {
            return checkForUpdatesPromise;
        }
        checkForUpdatesPromise = this._checkForUpdates();
        this.checkForUpdatesPromise = checkForUpdatesPromise;
        const nullizePromise = () => this.checkForUpdatesPromise = null;
        checkForUpdatesPromise.then(nullizePromise).catch(nullizePromise);
        return checkForUpdatesPromise;
    }
    checkForUpdatesAndNotify() {
        if ((_electronIsDev || _load_electronIsDev()).default) {
            return (_bluebirdLst2 || _load_bluebirdLst2()).default.resolve(null);
        }
        this.signals.updateDownloaded(it => {
            new (_electron || _load_electron()).Notification({
                title: "A new update is ready to install",
                body: `${this.app.getName()} version ${it.version} is downloaded and will be automatically installed on exit`
            }).show();
        });
        return this.checkForUpdates();
    }
    isStagingMatch(updateInfo) {
        var _this = this;

        return (0, (_bluebirdLst || _load_bluebirdLst()).coroutine)(function* () {
            const rawStagingPercentage = updateInfo.stagingPercentage;
            let stagingPercentage = rawStagingPercentage;
            if (stagingPercentage == null) {
                return true;
            }
            stagingPercentage = parseInt(stagingPercentage, 10);
            if (isNaN(stagingPercentage)) {
                _this._logger.warn(`Staging percentage is NaN: ${rawStagingPercentage}`);
                return true;
            }
            // convert from user 0-100 to internal 0-1
            stagingPercentage = stagingPercentage / 100;
            const stagingUserId = yield _this.stagingUserIdPromise.value;
            const val = (_builderUtilRuntime || _load_builderUtilRuntime()).UUID.parse(stagingUserId).readUInt32BE(12);
            const percentage = val / 0xFFFFFFFF;
            _this._logger.info(`Staging percentage: ${stagingPercentage}, percentage: ${percentage}, user id: ${stagingUserId}`);
            return percentage < stagingPercentage;
        })();
    }
    _checkForUpdates() {
        var _this2 = this;

        return (0, (_bluebirdLst || _load_bluebirdLst()).coroutine)(function* () {
            try {
                yield _this2.untilAppReady;
                _this2._logger.info("Checking for update");
                _this2.emit("checking-for-update");
                return yield _this2.doCheckForUpdates();
            } catch (e) {
                _this2.emit("error", e, `Cannot check for updates: ${(e.stack || e).toString()}`);
                throw e;
            }
        })();
    }
    computeFinalHeaders(headers) {
        if (this.requestHeaders != null) {
            Object.assign(headers, this.requestHeaders);
        }
        return headers;
    }
    doCheckForUpdates() {
        var _this3 = this;

        return (0, (_bluebirdLst || _load_bluebirdLst()).coroutine)(function* () {
            if (_this3.clientPromise == null) {
                _this3.clientPromise = _this3.configOnDisk.value.then(function (it) {
                    return (0, (_providerFactory || _load_providerFactory()).createClient)(it, _this3);
                });
            }
            const client = yield _this3.clientPromise;
            const stagingUserId = yield _this3.stagingUserIdPromise.value;
            client.setRequestHeaders(_this3.computeFinalHeaders({ "X-User-Staging-Id": stagingUserId }));
            const updateInfo = yield client.getLatestVersion();
            const latestVersion = (0, (_semver || _load_semver()).valid)(updateInfo.version);
            if (latestVersion == null) {
                throw (0, (_builderUtilRuntime || _load_builderUtilRuntime()).newError)(`Latest version (from update server) is not valid semver version: "${latestVersion}`, "ERR_UPDATER_INVALID_VERSION");
            }
            const isStagingMatch = yield _this3.isStagingMatch(updateInfo);
            if (!isStagingMatch || (_this3.allowDowngrade && !hasPrereleaseComponents(latestVersion) ? (0, (_semver || _load_semver()).eq)(latestVersion, _this3.currentVersion) : !(0, (_semver || _load_semver()).gt)(latestVersion, _this3.currentVersion))) {
                _this3.updateAvailable = false;
                _this3._logger.info(`Update for version ${_this3.currentVersion} is not available (latest version: ${updateInfo.version}, downgrade is ${_this3.allowDowngrade ? "allowed" : "disallowed"}.`);
                _this3.emit("update-not-available", updateInfo);
                return {
                    versionInfo: updateInfo,
                    updateInfo
                };
            }
            _this3.updateAvailable = true;
            _this3.updateInfo = updateInfo;
            _this3.onUpdateAvailable(updateInfo);
            const cancellationToken = new (_builderUtilRuntime || _load_builderUtilRuntime()).CancellationToken();
            //noinspection ES6MissingAwait
            return {
                versionInfo: updateInfo,
                updateInfo,
                cancellationToken,
                downloadPromise: _this3.autoDownload ? _this3.downloadUpdate(cancellationToken) : null
            };
        })();
    }
    onUpdateAvailable(updateInfo) {
        this._logger.info(`Found version ${updateInfo.version} (url: ${(0, (_builderUtilRuntime || _load_builderUtilRuntime()).asArray)(updateInfo.files).map(it => it.url).join(", ")})`);
        this.emit("update-available", updateInfo);
    }
    /**
     * Start downloading update manually. You can use this method if `autoDownload` option is set to `false`.
     * @returns {Promise<string>} Path to downloaded file.
     */
    downloadUpdate(cancellationToken = new (_builderUtilRuntime || _load_builderUtilRuntime()).CancellationToken()) {
        var _this4 = this;

        return (0, (_bluebirdLst || _load_bluebirdLst()).coroutine)(function* () {
            const updateInfo = _this4.updateInfo;
            if (updateInfo == null) {
                const error = new Error("Please check update first");
                _this4.dispatchError(error);
                throw error;
            }
            _this4._logger.info(`Downloading update from ${(0, (_builderUtilRuntime || _load_builderUtilRuntime()).asArray)(updateInfo.files).map(function (it) {
                return it.url;
            }).join(", ")}`);
            try {
                return yield _this4.doDownloadUpdate(updateInfo, cancellationToken);
            } catch (e) {
                _this4.dispatchError(e);
                throw e;
            }
        })();
    }
    dispatchError(e) {
        this.emit("error", e, (e.stack || e).toString());
    }
    loadUpdateConfig() {
        var _this5 = this;

        return (0, (_bluebirdLst || _load_bluebirdLst()).coroutine)(function* () {
            if (_this5._appUpdateConfigPath == null) {
                _this5._appUpdateConfigPath = (_electronIsDev || _load_electronIsDev()).default ? _path.join(_this5.app.getAppPath(), "dev-app-update.yml") : _path.join(process.resourcesPath, "app-update.yml");
            }
            return (0, (_jsYaml || _load_jsYaml()).safeLoad)((yield (0, (_fsExtraP || _load_fsExtraP()).readFile)(_this5._appUpdateConfigPath, "utf-8")));
        })();
    }
    /*** @private */
    computeRequestHeaders() {
        var _this6 = this;

        return (0, (_bluebirdLst || _load_bluebirdLst()).coroutine)(function* () {
            const fileExtraDownloadHeaders = (yield _this6.provider).fileExtraDownloadHeaders;
            if (fileExtraDownloadHeaders != null) {
                const requestHeaders = _this6.requestHeaders;
                return requestHeaders == null ? fileExtraDownloadHeaders : Object.assign({}, fileExtraDownloadHeaders, requestHeaders);
            }
            return _this6.computeFinalHeaders({ Accept: "*/*" });
        })();
    }
    getOrCreateStagingUserId() {
        var _this7 = this;

        return (0, (_bluebirdLst || _load_bluebirdLst()).coroutine)(function* () {
            const file = _path.join(_this7.app.getPath("userData"), ".updaterId");
            try {
                const id = yield (0, (_fsExtraP || _load_fsExtraP()).readFile)(file, "utf-8");
                if ((_builderUtilRuntime || _load_builderUtilRuntime()).UUID.check(id)) {
                    return id;
                } else {
                    _this7._logger.warn(`Staging user id file exists, but content was invalid: ${id}`);
                }
            } catch (e) {
                if (e.code !== "ENOENT") {
                    _this7._logger.warn(`Couldn't read staging user ID, creating a blank one: ${e}`);
                }
            }
            const id = (_builderUtilRuntime || _load_builderUtilRuntime()).UUID.v5((0, (_crypto || _load_crypto()).randomBytes)(4096), (_builderUtilRuntime || _load_builderUtilRuntime()).UUID.OID);
            _this7._logger.info(`Generated new staging user ID: ${id}`);
            try {
                yield (0, (_fsExtraP || _load_fsExtraP()).outputFile)(file, id);
            } catch (e) {
                _this7._logger.warn(`Couldn't write out staging user ID: ${e}`);
            }
            return id;
        })();
    }
}
exports.AppUpdater = AppUpdater;
function hasPrereleaseComponents(version) {
    const versionPrereleaseComponent = (0, (_semver || _load_semver()).prerelease)(version);
    return versionPrereleaseComponent != null && versionPrereleaseComponent.length > 0;
}
/** @private */
class NoOpLogger {
    info(message) {
        // ignore
    }
    warn(message) {
        // ignore
    }
    error(message) {
        // ignore
    }
}
exports.NoOpLogger = NoOpLogger; //# sourceMappingURL=AppUpdater.js.map

/***/ }),
/* 28 */
/***/ (function(module, exports) {

module.exports = require("crypto");

/***/ }),
/* 29 */
/***/ (function(module, exports) {

module.exports = require("util");

/***/ }),
/* 30 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const u = __webpack_require__(6).fromCallback;
const jsonFile = __webpack_require__(118);

module.exports = {
  // jsonfile exports
  readJson: u(jsonFile.readFile),
  readJsonSync: jsonFile.readFileSync,
  writeJson: u(jsonFile.writeFile),
  writeJsonSync: jsonFile.writeFileSync
};

/***/ }),
/* 31 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var yaml = __webpack_require__(137);

module.exports = yaml;

/***/ }),
/* 32 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Standard YAML's Failsafe schema.
// http://www.yaml.org/spec/1.2/spec.html#id2802346




var Schema = __webpack_require__(18);

module.exports = new Schema({
  explicit: [__webpack_require__(140), __webpack_require__(141), __webpack_require__(142)]
});

/***/ }),
/* 33 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__(160).install();

/***/ }),
/* 34 */
/***/ (function(module, exports) {

module.exports = require("child_process");

/***/ }),
/* 35 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.computeOperations = computeOperations;
var OperationKind = exports.OperationKind = undefined;
(function (OperationKind) {
    OperationKind[OperationKind["COPY"] = 0] = "COPY";
    OperationKind[OperationKind["DOWNLOAD"] = 1] = "DOWNLOAD";
})(OperationKind || (exports.OperationKind = OperationKind = {}));
function computeOperations(oldBlockMap, newBlockMap, logger) {
    const nameToOldBlocks = buildBlockFileMap(oldBlockMap.files);
    const nameToNewBlocks = buildBlockFileMap(newBlockMap.files);
    const oldEntryMap = buildEntryMap(oldBlockMap.files);
    let lastOperation = null;
    const operations = [];
    for (const blockMapFile of newBlockMap.files) {
        const name = blockMapFile.name;
        const oldEntry = oldEntryMap.get(name);
        if (oldEntry == null) {
            // new file
            operations.push({
                kind: OperationKind.DOWNLOAD,
                start: blockMapFile.offset,
                end: blockMapFile.offset + blockMapFile.sizes.reduce((accumulator, currentValue) => accumulator + currentValue)
            });
            continue;
        }
        const newFile = nameToNewBlocks.get(name);
        let changedBlockCount = 0;
        const { checksumToOffset: checksumToOldOffset, checksumToOldSize } = buildChecksumMap(nameToOldBlocks.get(name), oldEntry.offset);
        let newOffset = blockMapFile.offset;
        for (let i = 0; i < newFile.checksums.length; newOffset += newFile.sizes[i], i++) {
            const blockSize = newFile.sizes[i];
            const checksum = newFile.checksums[i];
            let oldOffset = checksumToOldOffset.get(checksum);
            if (oldOffset != null && checksumToOldSize.get(checksum) !== blockSize) {
                logger.warn(`Checksum ("${checksum}") matches, but size differs (old: ${checksumToOldSize.get(checksum)}, new: ${blockSize})`);
                oldOffset = null;
            }
            if (oldOffset == null) {
                changedBlockCount++;
                if (lastOperation == null || lastOperation.kind !== OperationKind.DOWNLOAD || lastOperation.end !== newOffset) {
                    lastOperation = {
                        kind: OperationKind.DOWNLOAD,
                        start: newOffset,
                        end: newOffset + blockSize
                    };
                    operations.push(lastOperation);
                } else {
                    lastOperation.end += blockSize;
                }
            } else if (lastOperation == null || lastOperation.kind !== OperationKind.COPY || lastOperation.end !== oldOffset) {
                lastOperation = {
                    kind: OperationKind.COPY,
                    start: oldOffset,
                    end: oldOffset + blockSize
                };
                operations.push(lastOperation);
            } else {
                lastOperation.end += blockSize;
            }
        }
        if (changedBlockCount > 0) {
            logger.info(`File${blockMapFile.name === "file" ? "" : " " + blockMapFile.name} has ${changedBlockCount} changed blocks`);
        }
    }
    return operations;
}
function buildChecksumMap(file, fileOffset) {
    const checksumToOffset = new Map();
    const checksumToSize = new Map();
    let offset = fileOffset;
    for (let i = 0; i < file.checksums.length; i++) {
        const checksum = file.checksums[i];
        const size = file.sizes[i];
        checksumToOffset.set(checksum, offset);
        checksumToSize.set(checksum, size);
        offset += size;
    }
    return { checksumToOffset, checksumToOldSize: checksumToSize };
}
function buildEntryMap(list) {
    const result = new Map();
    for (const item of list) {
        result.set(item.name, item);
    }
    return result;
}
function buildBlockFileMap(list) {
    const result = new Map();
    for (const item of list) {
        result.set(item.name, item);
    }
    return result;
}
//# sourceMappingURL=downloadPlanBuilder.js.map

/***/ }),
/* 36 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var format = __webpack_require__(37);
var originalConsole = __webpack_require__(68);

transport.level = 'silly';
transport.format = '[{h}:{i}:{s}.{ms}] [{level}] {text}';

module.exports = transport;

function transport(msg) {
  var text = format.format(msg, transport.format);
  if (originalConsole[msg.level]) {
    originalConsole[msg.level](text);
  } else {
    originalConsole.log(text);
  }
}

/***/ }),
/* 37 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var util = __webpack_require__(29);
var EOL = __webpack_require__(15).EOL;

module.exports = {
  format: format,
  formatTimeZone: formatTimeZone,
  pad: pad,
  stringifyArray: stringifyArray
};

function format(msg, formatter) {
  if (typeof formatter === 'function') {
    return formatter(msg);
  }

  var date = msg.date;

  return formatter.replace('{level}', msg.level).replace('{text}', stringifyArray(msg.data)).replace('{y}', date.getFullYear()).replace('{m}', pad(date.getMonth() + 1)).replace('{d}', pad(date.getDate())).replace('{h}', pad(date.getHours())).replace('{i}', pad(date.getMinutes())).replace('{s}', pad(date.getSeconds())).replace('{ms}', pad(date.getMilliseconds(), 3)).replace('{z}', formatTimeZone(date.getTimezoneOffset()));
}

function stringifyArray(data) {
  data = data.map(function formatErrors(arg) {
    return arg instanceof Error ? arg.stack + EOL : arg;
  });
  return util.format.apply(util, data);
}

function pad(number, zeros) {
  zeros = zeros || 2;
  return (new Array(zeros + 1).join('0') + number).substr(-zeros, zeros);
}

function formatTimeZone(minutesOffset) {
  var m = Math.abs(minutesOffset);
  return (minutesOffset >= 0 ? '-' : '+') + pad(Math.floor(m / 60)) + ':' + pad(m % 60);
}

/***/ }),
/* 38 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = function (NEXT_FILTER) {
    var util = __webpack_require__(1);
    var getKeys = __webpack_require__(16).keys;
    var tryCatch = util.tryCatch;
    var errorObj = util.errorObj;

    function catchFilter(instances, cb, promise) {
        return function (e) {
            var boundTo = promise._boundValue();
            predicateLoop: for (var i = 0; i < instances.length; ++i) {
                var item = instances[i];

                if (item === Error || item != null && item.prototype instanceof Error) {
                    if (e instanceof item) {
                        return tryCatch(cb).call(boundTo, e);
                    }
                } else if (typeof item === "function") {
                    var matchesPredicate = tryCatch(item).call(boundTo, e);
                    if (matchesPredicate === errorObj) {
                        return matchesPredicate;
                    } else if (matchesPredicate) {
                        return tryCatch(cb).call(boundTo, e);
                    }
                } else if (util.isObject(e)) {
                    var keys = getKeys(item);
                    for (var j = 0; j < keys.length; ++j) {
                        var key = keys[j];
                        if (item[key] != e[key]) {
                            continue predicateLoop;
                        }
                    }
                    return tryCatch(cb).call(boundTo, e);
                }
            }
            return NEXT_FILTER;
        };
    }

    return catchFilter;
};

/***/ }),
/* 39 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var util = __webpack_require__(1);
var maybeWrapAsError = util.maybeWrapAsError;
var errors = __webpack_require__(11);
var OperationalError = errors.OperationalError;
var es5 = __webpack_require__(16);

function isUntypedError(obj) {
    return obj instanceof Error && es5.getPrototypeOf(obj) === Error.prototype;
}

var rErrorKey = /^(?:name|message|stack|cause)$/;
function wrapAsOperationalError(obj) {
    var ret;
    if (isUntypedError(obj)) {
        ret = new OperationalError(obj);
        ret.name = obj.name;
        ret.message = obj.message;
        ret.stack = obj.stack;
        var keys = es5.keys(obj);
        for (var i = 0; i < keys.length; ++i) {
            var key = keys[i];
            if (!rErrorKey.test(key)) {
                ret[key] = obj[key];
            }
        }
        return ret;
    }
    util.markAsOriginatingFromRejection(obj);
    return obj;
}

function nodebackForPromise(promise, multiArgs) {
    return function (err, value) {
        if (promise === null) return;
        if (err) {
            var wrapped = wrapAsOperationalError(maybeWrapAsError(err));
            promise._attachExtraTrace(wrapped);
            promise._reject(wrapped);
        } else if (!multiArgs) {
            promise._fulfill(value);
        } else {
            var $_len = arguments.length;var args = new Array(Math.max($_len - 1, 0));for (var $_i = 1; $_i < $_len; ++$_i) {
                args[$_i - 1] = arguments[$_i];
            };
            promise._fulfill(args);
        }
        promise = null;
    };
}

module.exports = nodebackForPromise;

/***/ }),
/* 40 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.CancellationError = exports.CancellationToken = undefined;

var _bluebirdLst;

function _load_bluebirdLst() {
    return _bluebirdLst = _interopRequireDefault(__webpack_require__(2));
}

var _events;

function _load_events() {
    return _events = __webpack_require__(41);
}

function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
}

class CancellationToken extends (_events || _load_events()).EventEmitter {
    // babel cannot compile ... correctly for super calls
    constructor(parent) {
        super();
        this.parentCancelHandler = null;
        this._cancelled = false;
        if (parent != null) {
            this.parent = parent;
        }
    }
    get cancelled() {
        return this._cancelled || this._parent != null && this._parent.cancelled;
    }
    set parent(value) {
        this.removeParentCancelHandler();
        this._parent = value;
        this.parentCancelHandler = () => this.cancel();
        this._parent.onCancel(this.parentCancelHandler);
    }
    cancel() {
        this._cancelled = true;
        this.emit("cancel");
    }
    onCancel(handler) {
        if (this.cancelled) {
            handler();
        } else {
            this.once("cancel", handler);
        }
    }
    createPromise(callback) {
        if (this.cancelled) {
            return (_bluebirdLst || _load_bluebirdLst()).default.reject(new CancellationError());
        }
        let cancelHandler = null;
        return new (_bluebirdLst || _load_bluebirdLst()).default((resolve, reject) => {
            let addedCancelHandler = null;
            cancelHandler = () => {
                try {
                    if (addedCancelHandler != null) {
                        addedCancelHandler();
                        addedCancelHandler = null;
                    }
                } finally {
                    reject(new CancellationError());
                }
            };
            if (this.cancelled) {
                cancelHandler();
                return;
            }
            this.onCancel(cancelHandler);
            callback(resolve, reject, callback => {
                addedCancelHandler = callback;
            });
        }).finally(() => {
            if (cancelHandler != null) {
                this.removeListener("cancel", cancelHandler);
                cancelHandler = null;
            }
        });
    }
    removeParentCancelHandler() {
        const parent = this._parent;
        if (parent != null && this.parentCancelHandler != null) {
            parent.removeListener("cancel", this.parentCancelHandler);
            this.parentCancelHandler = null;
        }
    }
    dispose() {
        try {
            this.removeParentCancelHandler();
        } finally {
            this.removeAllListeners();
            this._parent = null;
        }
    }
}
exports.CancellationToken = CancellationToken;
class CancellationError extends Error {
    constructor() {
        super("Cancelled");
    }
}
exports.CancellationError = CancellationError; //# sourceMappingURL=CancellationToken.js.map

/***/ }),
/* 41 */
/***/ (function(module, exports) {

module.exports = require("events");

/***/ }),
/* 42 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.DigestTransform = exports.HttpExecutor = exports.HttpError = undefined;
exports.createHttpError = createHttpError;
exports.parseJson = parseJson;
exports.configureRequestOptionsFromUrl = configureRequestOptionsFromUrl;
exports.safeGetHeader = safeGetHeader;
exports.configureRequestOptions = configureRequestOptions;
exports.safeStringifyJson = safeStringifyJson;

var _crypto;

function _load_crypto() {
    return _crypto = __webpack_require__(28);
}

var _debug2 = _interopRequireDefault(__webpack_require__(100));

var _fsExtraP;

function _load_fsExtraP() {
    return _fsExtraP = __webpack_require__(9);
}

var _stream;

function _load_stream() {
    return _stream = __webpack_require__(19);
}

var _url;

function _load_url() {
    return _url = __webpack_require__(20);
}

var _CancellationToken;

function _load_CancellationToken() {
    return _CancellationToken = __webpack_require__(40);
}

var _index;

function _load_index() {
    return _index = __webpack_require__(3);
}

var _ProgressCallbackTransform;

function _load_ProgressCallbackTransform() {
    return _ProgressCallbackTransform = __webpack_require__(52);
}

function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
}

const debug = (0, _debug2.default)("electron-builder");
function createHttpError(response, description = null) {
    return new HttpError(response.statusCode || -1, `${response.statusCode} ${response.statusMessage}` + (description == null ? "" : "\n" + JSON.stringify(description, null, "  ")) + "\nHeaders: " + safeStringifyJson(response.headers), description);
}
const HTTP_STATUS_CODES = new Map([[429, "Too many requests"], [400, "Bad request"], [403, "Forbidden"], [404, "Not found"], [405, "Method not allowed"], [406, "Not acceptable"], [408, "Request timeout"], [413, "Request entity too large"], [500, "Internal server error"], [502, "Bad gateway"], [503, "Service unavailable"], [504, "Gateway timeout"], [505, "HTTP version not supported"]]);
class HttpError extends Error {
    constructor(statusCode, message = `HTTP error: ${HTTP_STATUS_CODES.get(statusCode) || statusCode}`, description = null) {
        super(message);
        this.statusCode = statusCode;
        this.description = description;
        this.name = "HttpError";
    }
}
exports.HttpError = HttpError;
function parseJson(result) {
    return result.then(it => it == null || it.length === 0 ? null : JSON.parse(it));
}
class HttpExecutor {
    constructor() {
        this.maxRedirects = 10;
    }
    request(options, cancellationToken = new (_CancellationToken || _load_CancellationToken()).CancellationToken(), data) {
        configureRequestOptions(options);
        const encodedData = data == null ? undefined : Buffer.from(JSON.stringify(data));
        if (encodedData != null) {
            options.method = "post";
            options.headers["Content-Type"] = "application/json";
            options.headers["Content-Length"] = encodedData.length;
        }
        return this.doApiRequest(options, cancellationToken, it => it.end(encodedData));
    }
    doApiRequest(options, cancellationToken, requestProcessor, redirectCount = 0) {
        if (debug.enabled) {
            debug(`Request: ${safeStringifyJson(options)}`);
        }
        return cancellationToken.createPromise((resolve, reject, onCancel) => {
            const request = this.doRequest(options, response => {
                try {
                    this.handleResponse(response, options, cancellationToken, resolve, reject, redirectCount, requestProcessor);
                } catch (e) {
                    reject(e);
                }
            });
            this.addErrorAndTimeoutHandlers(request, reject);
            this.addRedirectHandlers(request, options, reject, redirectCount, options => {
                this.doApiRequest(options, cancellationToken, requestProcessor, redirectCount).then(resolve).catch(reject);
            });
            requestProcessor(request, reject);
            onCancel(() => request.abort());
        });
    }
    // noinspection JSUnusedLocalSymbols
    addRedirectHandlers(request, options, reject, redirectCount, handler) {
        // not required for NodeJS
    }
    addErrorAndTimeoutHandlers(request, reject) {
        this.addTimeOutHandler(request, reject);
        request.on("error", reject);
        request.on("aborted", () => {
            reject(new Error("Request has been aborted by the server"));
        });
    }
    handleResponse(response, options, cancellationToken, resolve, reject, redirectCount, requestProcessor) {
        if (debug.enabled) {
            debug(`Response: ${response.statusCode} ${response.statusMessage}, request options: ${safeStringifyJson(options)}`);
        }
        // we handle any other >= 400 error on request end (read detailed message in the response body)
        if (response.statusCode === 404) {
            // error is clear, we don't need to read detailed error description
            reject(createHttpError(response, `method: ${options.method} url: ${options.protocol || "https:"}//${options.hostname}${options.path}

Please double check that your authentication token is correct. Due to security reasons actual status maybe not reported, but 404.
`));
            return;
        } else if (response.statusCode === 204) {
            // on DELETE request
            resolve();
            return;
        }
        const redirectUrl = safeGetHeader(response, "location");
        if (redirectUrl != null) {
            if (redirectCount > 10) {
                reject(new Error("Too many redirects (> 10)"));
                return;
            }
            this.doApiRequest(HttpExecutor.prepareRedirectUrlOptions(redirectUrl, options), cancellationToken, requestProcessor, redirectCount).then(resolve).catch(reject);
            return;
        }
        let data = "";
        response.setEncoding("utf8");
        response.on("data", chunk => data += chunk);
        response.on("end", () => {
            try {
                if (response.statusCode != null && response.statusCode >= 400) {
                    const contentType = safeGetHeader(response, "content-type");
                    const isJson = contentType != null && (Array.isArray(contentType) ? contentType.find(it => it.includes("json")) != null : contentType.includes("json"));
                    reject(createHttpError(response, isJson ? JSON.parse(data) : data));
                } else {
                    resolve(data.length === 0 ? null : data);
                }
            } catch (e) {
                reject(e);
            }
        });
    }
    doDownload(requestOptions, destination, redirectCount, options, callback, onCancel) {
        const request = this.doRequest(requestOptions, response => {
            if (response.statusCode >= 400) {
                callback(new Error(`Cannot download "${requestOptions.protocol || "https:"}//${requestOptions.hostname}${requestOptions.path}", status ${response.statusCode}: ${response.statusMessage}`));
                return;
            }
            const redirectUrl = safeGetHeader(response, "location");
            if (redirectUrl != null) {
                if (redirectCount < this.maxRedirects) {
                    this.doDownload(HttpExecutor.prepareRedirectUrlOptions(redirectUrl, requestOptions), destination, redirectCount++, options, callback, onCancel);
                } else {
                    callback(new Error(`Too many redirects (> ${this.maxRedirects})`));
                }
                return;
            }
            configurePipes(options, response, destination, callback, options.cancellationToken);
        });
        this.addErrorAndTimeoutHandlers(request, callback);
        this.addRedirectHandlers(request, requestOptions, callback, redirectCount, requestOptions => {
            this.doDownload(requestOptions, destination, redirectCount++, options, callback, onCancel);
        });
        onCancel(() => request.abort());
        request.end();
    }
    addTimeOutHandler(request, callback) {
        request.on("socket", socket => {
            socket.setTimeout(60 * 1000, () => {
                callback(new Error("Request timed out"));
                request.abort();
            });
        });
    }
    static prepareRedirectUrlOptions(redirectUrl, options) {
        const newOptions = configureRequestOptionsFromUrl(redirectUrl, Object.assign({}, options));
        if (newOptions.headers != null && newOptions.headers.Authorization != null && newOptions.headers.Authorization.startsWith("token")) {
            const parsedNewUrl = new (_url || _load_url()).URL(redirectUrl);
            if (parsedNewUrl.hostname.endsWith(".amazonaws.com")) {
                delete newOptions.headers.Authorization;
            }
        }
        return newOptions;
    }
}
exports.HttpExecutor = HttpExecutor;
function configureRequestOptionsFromUrl(url, options) {
    const parsedUrl = (0, (_url || _load_url()).parse)(url);
    options.protocol = parsedUrl.protocol;
    options.hostname = parsedUrl.hostname;
    if (parsedUrl.port == null) {
        if (options.port != null) {
            delete options.port;
        }
    } else {
        options.port = parsedUrl.port;
    }
    options.path = parsedUrl.path;
    return configureRequestOptions(options);
}
class DigestTransform extends (_stream || _load_stream()).Transform {
    constructor(expected, algorithm = "sha512", encoding = "base64") {
        super();
        this.expected = expected;
        this.algorithm = algorithm;
        this.encoding = encoding;
        this.isValidateOnEnd = true;
        this.digester = (0, (_crypto || _load_crypto()).createHash)(algorithm);
    }
    // noinspection JSUnusedGlobalSymbols
    get actual() {
        return this._actual;
    }
    // noinspection JSUnusedGlobalSymbols
    _transform(chunk, encoding, callback) {
        this.digester.update(chunk);
        callback(null, chunk);
    }
    // noinspection JSUnusedGlobalSymbols
    _flush(callback) {
        this._actual = this.digester.digest(this.encoding);
        if (this.isValidateOnEnd) {
            try {
                this.validate();
            } catch (e) {
                callback(e);
                return;
            }
        }
        callback(null);
    }
    validate() {
        if (this._actual == null) {
            throw (0, (_index || _load_index()).newError)("Not finished yet", "ERR_STREAM_NOT_FINISHED");
        }
        if (this._actual !== this.expected) {
            throw (0, (_index || _load_index()).newError)(`${this.algorithm} checksum mismatch, expected ${this.expected}, got ${this._actual}`, "ERR_CHECKSUM_MISMATCH");
        }
        return null;
    }
}
exports.DigestTransform = DigestTransform;
function checkSha2(sha2Header, sha2, callback) {
    if (sha2Header != null && sha2 != null) {
        // todo why bintray doesn't send this header always
        if (sha2Header == null) {
            callback(new Error("checksum is required, but server response doesn't contain X-Checksum-Sha2 header"));
            return false;
        } else if (sha2Header !== sha2) {
            callback(new Error(`checksum mismatch: expected ${sha2} but got ${sha2Header} (X-Checksum-Sha2 header)`));
            return false;
        }
    }
    return true;
}
function safeGetHeader(response, headerKey) {
    const value = response.headers[headerKey];
    if (value == null) {
        return null;
    } else if (Array.isArray(value)) {
        // electron API
        return value.length === 0 ? null : value[value.length - 1];
    } else {
        return value;
    }
}
function configurePipes(options, response, destination, callback, cancellationToken) {
    if (!checkSha2(safeGetHeader(response, "X-Checksum-Sha2"), options.sha2, callback)) {
        return;
    }
    const streams = [];
    if (options.onProgress != null) {
        const contentLength = safeGetHeader(response, "content-length");
        if (contentLength != null) {
            streams.push(new (_ProgressCallbackTransform || _load_ProgressCallbackTransform()).ProgressCallbackTransform(parseInt(contentLength, 10), options.cancellationToken, options.onProgress));
        }
    }
    const sha512 = options.sha512;
    if (sha512 != null) {
        streams.push(new DigestTransform(sha512, "sha512", sha512.length === 128 && !sha512.includes("+") && !sha512.includes("Z") && !sha512.includes("=") ? "hex" : "base64"));
    } else if (options.sha2 != null) {
        streams.push(new DigestTransform(options.sha2, "sha256", "hex"));
    }
    const fileOut = (0, (_fsExtraP || _load_fsExtraP()).createWriteStream)(destination);
    streams.push(fileOut);
    let lastStream = response;
    for (const stream of streams) {
        stream.on("error", error => {
            if (!cancellationToken.cancelled) {
                callback(error);
            }
        });
        lastStream = lastStream.pipe(stream);
    }
    fileOut.on("finish", () => {
        fileOut.close(callback);
    });
}
function configureRequestOptions(options, token, method) {
    if (method != null) {
        options.method = method;
    }
    let headers = options.headers;
    if (headers == null) {
        headers = {};
        options.headers = headers;
    }
    if (token != null) {
        headers.authorization = token.startsWith("Basic") ? token : `token ${token}`;
    }
    if (headers["User-Agent"] == null) {
        headers["User-Agent"] = "electron-builder";
    }
    if (method == null || method === "GET" || headers["Cache-Control"] == null) {
        headers["Cache-Control"] = "no-cache";
    }
    // do not specify for node (in any case we use https module)
    if (options.protocol == null && process.versions.electron != null) {
        options.protocol = "https:";
    }
    return options;
}
function safeStringifyJson(data, skippedNames) {
    return JSON.stringify(data, (name, value) => {
        if (name.endsWith("authorization") || name.endsWith("Password") || name.endsWith("PASSWORD") || name.endsWith("Token") || name.includes("password") || name.includes("token") || skippedNames != null && skippedNames.has(name)) {
            return "<stripped sensitive data>";
        }
        return value;
    }, 2);
}
//# sourceMappingURL=httpExecutor.js.map

/***/ }),
/* 43 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * This is the common logic for both the Node.js and web browser
 * implementations of `debug()`.
 *
 * Expose `debug()` as the module.
 */

exports = module.exports = createDebug.debug = createDebug['default'] = createDebug;
exports.coerce = coerce;
exports.disable = disable;
exports.enable = enable;
exports.enabled = enabled;
exports.humanize = __webpack_require__(102);

/**
 * Active `debug` instances.
 */
exports.instances = [];

/**
 * The currently active debug mode names, and names to skip.
 */

exports.names = [];
exports.skips = [];

/**
 * Map of special "%n" handling functions, for the debug "format" argument.
 *
 * Valid key names are a single, lower or upper-case letter, i.e. "n" and "N".
 */

exports.formatters = {};

/**
 * Select a color.
 * @param {String} namespace
 * @return {Number}
 * @api private
 */

function selectColor(namespace) {
  var hash = 0,
      i;

  for (i in namespace) {
    hash = (hash << 5) - hash + namespace.charCodeAt(i);
    hash |= 0; // Convert to 32bit integer
  }

  return exports.colors[Math.abs(hash) % exports.colors.length];
}

/**
 * Create a debugger with the given `namespace`.
 *
 * @param {String} namespace
 * @return {Function}
 * @api public
 */

function createDebug(namespace) {

  var prevTime;

  function debug() {
    // disabled?
    if (!debug.enabled) return;

    var self = debug;

    // set `diff` timestamp
    var curr = +new Date();
    var ms = curr - (prevTime || curr);
    self.diff = ms;
    self.prev = prevTime;
    self.curr = curr;
    prevTime = curr;

    // turn the `arguments` into a proper Array
    var args = new Array(arguments.length);
    for (var i = 0; i < args.length; i++) {
      args[i] = arguments[i];
    }

    args[0] = exports.coerce(args[0]);

    if ('string' !== typeof args[0]) {
      // anything else let's inspect with %O
      args.unshift('%O');
    }

    // apply any `formatters` transformations
    var index = 0;
    args[0] = args[0].replace(/%([a-zA-Z%])/g, function (match, format) {
      // if we encounter an escaped % then don't increase the array index
      if (match === '%%') return match;
      index++;
      var formatter = exports.formatters[format];
      if ('function' === typeof formatter) {
        var val = args[index];
        match = formatter.call(self, val);

        // now we need to remove `args[index]` since it's inlined in the `format`
        args.splice(index, 1);
        index--;
      }
      return match;
    });

    // apply env-specific formatting (colors, etc.)
    exports.formatArgs.call(self, args);

    var logFn = debug.log || exports.log || console.log.bind(console);
    logFn.apply(self, args);
  }

  debug.namespace = namespace;
  debug.enabled = exports.enabled(namespace);
  debug.useColors = exports.useColors();
  debug.color = selectColor(namespace);
  debug.destroy = destroy;

  // env-specific initialization logic for debug instances
  if ('function' === typeof exports.init) {
    exports.init(debug);
  }

  exports.instances.push(debug);

  return debug;
}

function destroy() {
  var index = exports.instances.indexOf(this);
  if (index !== -1) {
    exports.instances.splice(index, 1);
    return true;
  } else {
    return false;
  }
}

/**
 * Enables a debug mode by namespaces. This can include modes
 * separated by a colon and wildcards.
 *
 * @param {String} namespaces
 * @api public
 */

function enable(namespaces) {
  exports.save(namespaces);

  exports.names = [];
  exports.skips = [];

  var i;
  var split = (typeof namespaces === 'string' ? namespaces : '').split(/[\s,]+/);
  var len = split.length;

  for (i = 0; i < len; i++) {
    if (!split[i]) continue; // ignore empty strings
    namespaces = split[i].replace(/\*/g, '.*?');
    if (namespaces[0] === '-') {
      exports.skips.push(new RegExp('^' + namespaces.substr(1) + '$'));
    } else {
      exports.names.push(new RegExp('^' + namespaces + '$'));
    }
  }

  for (i = 0; i < exports.instances.length; i++) {
    var instance = exports.instances[i];
    instance.enabled = exports.enabled(instance.namespace);
  }
}

/**
 * Disable debug output.
 *
 * @api public
 */

function disable() {
  exports.enable('');
}

/**
 * Returns true if the given mode name is enabled, false otherwise.
 *
 * @param {String} name
 * @return {Boolean}
 * @api public
 */

function enabled(name) {
  if (name[name.length - 1] === '*') {
    return true;
  }
  var i, len;
  for (i = 0, len = exports.skips.length; i < len; i++) {
    if (exports.skips[i].test(name)) {
      return false;
    }
  }
  for (i = 0, len = exports.names.length; i < len; i++) {
    if (exports.names[i].test(name)) {
      return true;
    }
  }
  return false;
}

/**
 * Coerce `val`.
 *
 * @param {Mixed} val
 * @return {Mixed}
 * @api private
 */

function coerce(val) {
  if (val instanceof Error) return val.stack || val.message;
  return val;
}

/***/ }),
/* 44 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// This is adapted from https://github.com/normalize/mz
// Copyright (c) 2014-2016 Jonathan Ong me@jongleberry.com and Contributors
const u = __webpack_require__(6).fromCallback;
const fs = __webpack_require__(5);

const api = ['access', 'appendFile', 'chmod', 'chown', 'close', 'copyFile', 'fchmod', 'fchown', 'fdatasync', 'fstat', 'fsync', 'ftruncate', 'futimes', 'lchown', 'link', 'lstat', 'mkdir', 'mkdtemp', 'open', 'readFile', 'readdir', 'readlink', 'realpath', 'rename', 'rmdir', 'stat', 'symlink', 'truncate', 'unlink', 'utimes', 'writeFile'].filter(key => {
  // Some commands are not available on some systems. Ex:
  // fs.copyFile was added in Node.js v8.5.0
  // fs.mkdtemp was added in Node.js v5.10.0
  // fs.lchown is not available on at least some Linux
  return typeof fs[key] === 'function';
});

// Export all keys:
Object.keys(fs).forEach(key => {
  exports[key] = fs[key];
});

// Universalify async methods:
api.forEach(method => {
  exports[method] = u(fs[method]);
});

// We differ from mz/fs in that we still ship the old, broken, fs.exists()
// since we are a drop-in replacement for the native module
exports.exists = function (filename, callback) {
  if (typeof callback === 'function') {
    return fs.exists(filename, callback);
  }
  return new Promise(resolve => {
    return fs.exists(filename, resolve);
  });
};

// fs.read() & fs.write need special treatment due to multiple callback args

exports.read = function (fd, buffer, offset, length, position, callback) {
  if (typeof callback === 'function') {
    return fs.read(fd, buffer, offset, length, position, callback);
  }
  return new Promise((resolve, reject) => {
    fs.read(fd, buffer, offset, length, position, (err, bytesRead, buffer) => {
      if (err) return reject(err);
      resolve({ bytesRead, buffer });
    });
  });
};

// Function signature can be
// fs.write(fd, buffer[, offset[, length[, position]]], callback)
// OR
// fs.write(fd, string[, position[, encoding]], callback)
// so we need to handle both cases
exports.write = function (fd, buffer, a, b, c, callback) {
  if (typeof arguments[arguments.length - 1] === 'function') {
    return fs.write(fd, buffer, a, b, c, callback);
  }

  // Check for old, depricated fs.write(fd, string[, position[, encoding]], callback)
  if (typeof buffer === 'string') {
    return new Promise((resolve, reject) => {
      fs.write(fd, buffer, a, b, (err, bytesWritten, buffer) => {
        if (err) return reject(err);
        resolve({ bytesWritten, buffer });
      });
    });
  }

  return new Promise((resolve, reject) => {
    fs.write(fd, buffer, a, b, c, (err, bytesWritten, buffer) => {
      if (err) return reject(err);
      resolve({ bytesWritten, buffer });
    });
  });
};

/***/ }),
/* 45 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var fs = __webpack_require__(12);

module.exports = clone(fs);

function clone(obj) {
  if (obj === null || typeof obj !== 'object') return obj;

  if (obj instanceof Object) var copy = { __proto__: obj.__proto__ };else var copy = Object.create(null);

  Object.getOwnPropertyNames(obj).forEach(function (key) {
    Object.defineProperty(copy, key, Object.getOwnPropertyDescriptor(obj, key));
  });

  return copy;
}

/***/ }),
/* 46 */
/***/ (function(module, exports) {

module.exports = require("assert");

/***/ }),
/* 47 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const fs = __webpack_require__(5);
const path = __webpack_require__(0);
const mkdirp = __webpack_require__(7).mkdirs;
const pathExists = __webpack_require__(13).pathExists;
const utimes = __webpack_require__(49).utimesMillis;

const notExist = Symbol('notExist');
const existsReg = Symbol('existsReg');

function copy(src, dest, opts, cb) {
  if (typeof opts === 'function' && !cb) {
    cb = opts;
    opts = {};
  } else if (typeof opts === 'function') {
    opts = { filter: opts };
  }

  cb = cb || function () {};
  opts = opts || {};

  opts.clobber = 'clobber' in opts ? !!opts.clobber : true; // default to true for now
  opts.overwrite = 'overwrite' in opts ? !!opts.overwrite : opts.clobber; // overwrite falls back to clobber

  // Warn about using preserveTimestamps on 32-bit node
  if (opts.preserveTimestamps && process.arch === 'ia32') {
    console.warn(`fs-extra: Using the preserveTimestamps option in 32-bit node is not recommended;\n
    see https://github.com/jprichardson/node-fs-extra/issues/269`);
  }

  src = path.resolve(src);
  dest = path.resolve(dest);

  // don't allow src and dest to be the same
  if (src === dest) return cb(new Error('Source and destination must not be the same.'));

  if (opts.filter) return handleFilter(checkParentDir, src, dest, opts, cb);
  return checkParentDir(src, dest, opts, cb);
}

function checkParentDir(src, dest, opts, cb) {
  const destParent = path.dirname(dest);
  pathExists(destParent, (err, dirExists) => {
    if (err) return cb(err);
    if (dirExists) return startCopy(src, dest, opts, cb);
    mkdirp(destParent, err => {
      if (err) return cb(err);
      return startCopy(src, dest, opts, cb);
    });
  });
}

function startCopy(src, dest, opts, cb) {
  if (opts.filter) return handleFilter(getStats, src, dest, opts, cb);
  return getStats(src, dest, opts, cb);
}

function handleFilter(onInclude, src, dest, opts, cb) {
  Promise.resolve(opts.filter(src, dest)).then(include => {
    if (include) return onInclude(src, dest, opts, cb);
    return cb();
  }, error => cb(error));
}

function getStats(src, dest, opts, cb) {
  const stat = opts.dereference ? fs.stat : fs.lstat;
  stat(src, (err, st) => {
    if (err) return cb(err);

    if (st.isDirectory()) return onDir(st, src, dest, opts, cb);else if (st.isFile() || st.isCharacterDevice() || st.isBlockDevice()) return onFile(st, src, dest, opts, cb);else if (st.isSymbolicLink()) return onLink(src, dest, opts, cb);
  });
}

function onFile(srcStat, src, dest, opts, cb) {
  checkDest(dest, (err, resolvedPath) => {
    if (err) return cb(err);
    if (resolvedPath === notExist) {
      return copyFile(srcStat, src, dest, opts, cb);
    } else if (resolvedPath === existsReg) {
      return mayCopyFile(srcStat, src, dest, opts, cb);
    } else {
      if (src === resolvedPath) return cb();
      return mayCopyFile(srcStat, src, dest, opts, cb);
    }
  });
}

function mayCopyFile(srcStat, src, dest, opts, cb) {
  if (opts.overwrite) {
    fs.unlink(dest, err => {
      if (err) return cb(err);
      return copyFile(srcStat, src, dest, opts, cb);
    });
  } else if (opts.errorOnExist) {
    return cb(new Error(`'${dest}' already exists`));
  } else return cb();
}

function copyFile(srcStat, src, dest, opts, cb) {
  if (typeof fs.copyFile === 'function') {
    return fs.copyFile(src, dest, err => {
      if (err) return cb(err);
      return setDestModeAndTimestamps(srcStat, dest, opts, cb);
    });
  }
  return copyFileFallback(srcStat, src, dest, opts, cb);
}

function copyFileFallback(srcStat, src, dest, opts, cb) {
  const rs = fs.createReadStream(src);
  rs.on('error', err => cb(err)).once('open', () => {
    const ws = fs.createWriteStream(dest, { mode: srcStat.mode });
    ws.on('error', err => cb(err)).on('open', () => rs.pipe(ws)).once('close', () => setDestModeAndTimestamps(srcStat, dest, opts, cb));
  });
}

function setDestModeAndTimestamps(srcStat, dest, opts, cb) {
  fs.chmod(dest, srcStat.mode, err => {
    if (err) return cb(err);
    if (opts.preserveTimestamps) {
      return utimes(dest, srcStat.atime, srcStat.mtime, cb);
    }
    return cb();
  });
}

function onDir(srcStat, src, dest, opts, cb) {
  checkDest(dest, (err, resolvedPath) => {
    if (err) return cb(err);
    if (resolvedPath === notExist) {
      if (isSrcSubdir(src, dest)) {
        return cb(new Error(`Cannot copy '${src}' to a subdirectory of itself, '${dest}'.`));
      }
      return mkDirAndCopy(srcStat, src, dest, opts, cb);
    } else if (resolvedPath === existsReg) {
      if (isSrcSubdir(src, dest)) {
        return cb(new Error(`Cannot copy '${src}' to a subdirectory of itself, '${dest}'.`));
      }
      return mayCopyDir(src, dest, opts, cb);
    } else {
      if (src === resolvedPath) return cb();
      return copyDir(src, dest, opts, cb);
    }
  });
}

function mayCopyDir(src, dest, opts, cb) {
  fs.stat(dest, (err, st) => {
    if (err) return cb(err);
    if (!st.isDirectory()) {
      return cb(new Error(`Cannot overwrite non-directory '${dest}' with directory '${src}'.`));
    }
    return copyDir(src, dest, opts, cb);
  });
}

function mkDirAndCopy(srcStat, src, dest, opts, cb) {
  fs.mkdir(dest, srcStat.mode, err => {
    if (err) return cb(err);
    fs.chmod(dest, srcStat.mode, err => {
      if (err) return cb(err);
      return copyDir(src, dest, opts, cb);
    });
  });
}

function copyDir(src, dest, opts, cb) {
  fs.readdir(src, (err, items) => {
    if (err) return cb(err);
    return copyDirItems(items, src, dest, opts, cb);
  });
}

function copyDirItems(items, src, dest, opts, cb) {
  const item = items.pop();
  if (!item) return cb();
  startCopy(path.join(src, item), path.join(dest, item), opts, err => {
    if (err) return cb(err);
    return copyDirItems(items, src, dest, opts, cb);
  });
}

function onLink(src, dest, opts, cb) {
  fs.readlink(src, (err, resolvedSrcPath) => {
    if (err) return cb(err);

    if (opts.dereference) {
      resolvedSrcPath = path.resolve(process.cwd(), resolvedSrcPath);
    }

    checkDest(dest, (err, resolvedDestPath) => {
      if (err) return cb(err);

      if (resolvedDestPath === notExist || resolvedDestPath === existsReg) {
        // if dest already exists, fs throws error anyway,
        // so no need to guard against it here.
        return fs.symlink(resolvedSrcPath, dest, cb);
      } else {
        if (opts.dereference) {
          resolvedDestPath = path.resolve(process.cwd(), resolvedDestPath);
        }
        if (resolvedDestPath === resolvedSrcPath) return cb();

        // prevent copy if src is a subdir of dest since unlinking
        // dest in this case would result in removing src contents
        // and therefore a broken symlink would be created.
        fs.stat(dest, (err, st) => {
          if (err) return cb(err);
          if (st.isDirectory() && isSrcSubdir(resolvedDestPath, resolvedSrcPath)) {
            return cb(new Error(`Cannot overwrite '${resolvedDestPath}' with '${resolvedSrcPath}'.`));
          }
          return copyLink(resolvedSrcPath, dest, cb);
        });
      }
    });
  });
}

function copyLink(resolvedSrcPath, dest, cb) {
  fs.unlink(dest, err => {
    if (err) return cb(err);
    return fs.symlink(resolvedSrcPath, dest, cb);
  });
}

// check if dest exists and/or is a symlink
function checkDest(dest, cb) {
  fs.readlink(dest, (err, resolvedPath) => {
    if (err) {
      if (err.code === 'ENOENT') return cb(null, notExist);

      // dest exists and is a regular file or directory, Windows may throw UNKNOWN error.
      if (err.code === 'EINVAL' || err.code === 'UNKNOWN') return cb(null, existsReg);

      return cb(err);
    }
    return cb(null, resolvedPath); // dest exists and is a symlink
  });
}

// return true if dest is a subdir of src, otherwise false.
// extract dest base dir and check if that is the same as src basename
function isSrcSubdir(src, dest) {
  const baseDir = dest.split(path.dirname(src) + path.sep)[1];
  if (baseDir) {
    const destBasename = baseDir.split(path.sep)[0];
    if (destBasename) {
      return src !== dest && dest.indexOf(src) > -1 && destBasename === path.basename(src);
    }
    return false;
  }
  return false;
}

module.exports = copy;

/***/ }),
/* 48 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const path = __webpack_require__(0);

// get drive on windows
function getRootPath(p) {
  p = path.normalize(path.resolve(p)).split(path.sep);
  if (p.length > 0) return p[0];
  return null;
}

// http://stackoverflow.com/a/62888/10333 contains more accurate
// TODO: expand to include the rest
const INVALID_PATH_CHARS = /[<>:"|?*]/;

function invalidWin32Path(p) {
  const rp = getRootPath(p);
  p = p.replace(rp, '');
  return INVALID_PATH_CHARS.test(p);
}

module.exports = {
  getRootPath,
  invalidWin32Path
};

/***/ }),
/* 49 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const fs = __webpack_require__(5);
const os = __webpack_require__(15);
const path = __webpack_require__(0);

// HFS, ext{2,3}, FAT do not, Node.js v0.10 does not
function hasMillisResSync() {
  let tmpfile = path.join('millis-test-sync' + Date.now().toString() + Math.random().toString().slice(2));
  tmpfile = path.join(os.tmpdir(), tmpfile);

  // 550 millis past UNIX epoch
  const d = new Date(1435410243862);
  fs.writeFileSync(tmpfile, 'https://github.com/jprichardson/node-fs-extra/pull/141');
  const fd = fs.openSync(tmpfile, 'r+');
  fs.futimesSync(fd, d, d);
  fs.closeSync(fd);
  return fs.statSync(tmpfile).mtime > 1435410243000;
}

function hasMillisRes(callback) {
  let tmpfile = path.join('millis-test' + Date.now().toString() + Math.random().toString().slice(2));
  tmpfile = path.join(os.tmpdir(), tmpfile);

  // 550 millis past UNIX epoch
  const d = new Date(1435410243862);
  fs.writeFile(tmpfile, 'https://github.com/jprichardson/node-fs-extra/pull/141', err => {
    if (err) return callback(err);
    fs.open(tmpfile, 'r+', (err, fd) => {
      if (err) return callback(err);
      fs.futimes(fd, d, d, err => {
        if (err) return callback(err);
        fs.close(fd, err => {
          if (err) return callback(err);
          fs.stat(tmpfile, (err, stats) => {
            if (err) return callback(err);
            callback(null, stats.mtime > 1435410243000);
          });
        });
      });
    });
  });
}

function timeRemoveMillis(timestamp) {
  if (typeof timestamp === 'number') {
    return Math.floor(timestamp / 1000) * 1000;
  } else if (timestamp instanceof Date) {
    return new Date(Math.floor(timestamp.getTime() / 1000) * 1000);
  } else {
    throw new Error('fs-extra: timeRemoveMillis() unknown parameter type');
  }
}

function utimesMillis(path, atime, mtime, callback) {
  // if (!HAS_MILLIS_RES) return fs.utimes(path, atime, mtime, callback)
  fs.open(path, 'r+', (err, fd) => {
    if (err) return callback(err);
    fs.futimes(fd, atime, mtime, futimesErr => {
      fs.close(fd, closeErr => {
        if (callback) callback(futimesErr || closeErr);
      });
    });
  });
}

function utimesMillisSync(path, atime, mtime) {
  const fd = fs.openSync(path, 'r+');
  fs.futimesSync(fd, atime, mtime);
  return fs.closeSync(fd);
}

module.exports = {
  hasMillisRes,
  hasMillisResSync,
  timeRemoveMillis,
  utimesMillis,
  utimesMillisSync
};

/***/ }),
/* 50 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = {
  copySync: __webpack_require__(115)
};

/***/ }),
/* 51 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/* eslint-disable node/no-deprecated-api */
module.exports = function (size) {
  if (typeof Buffer.allocUnsafe === 'function') {
    try {
      return Buffer.allocUnsafe(size);
    } catch (e) {
      return new Buffer(size);
    }
  }
  return new Buffer(size);
};

/***/ }),
/* 52 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.ProgressCallbackTransform = undefined;

var _stream;

function _load_stream() {
    return _stream = __webpack_require__(19);
}

class ProgressCallbackTransform extends (_stream || _load_stream()).Transform {
    constructor(total, cancellationToken, onProgress) {
        super();
        this.total = total;
        this.cancellationToken = cancellationToken;
        this.onProgress = onProgress;
        this.start = Date.now();
        this.transferred = 0;
        this.delta = 0;
        this.nextUpdate = this.start + 1000;
    }
    _transform(chunk, encoding, callback) {
        if (this.cancellationToken.cancelled) {
            callback(new Error("Cancelled"), null);
            return;
        }
        this.transferred += chunk.length;
        this.delta += chunk.length;
        const now = Date.now();
        if (now >= this.nextUpdate && this.transferred !== this.total /* will be emitted on _flush */) {
                this.nextUpdate = now + 1000;
                this.onProgress({
                    total: this.total,
                    delta: this.delta,
                    transferred: this.transferred,
                    percent: this.transferred / this.total * 100,
                    bytesPerSecond: Math.round(this.transferred / ((now - this.start) / 1000))
                });
                this.delta = 0;
            }
        callback(null, chunk);
    }
    _flush(callback) {
        if (this.cancellationToken.cancelled) {
            callback(new Error("Cancelled"));
            return;
        }
        this.onProgress({
            total: this.total,
            delta: this.delta,
            transferred: this.total,
            percent: 100,
            bytesPerSecond: Math.round(this.transferred / ((Date.now() - this.start) / 1000))
        });
        this.delta = 0;
        callback(null);
    }
}
exports.ProgressCallbackTransform = ProgressCallbackTransform; //# sourceMappingURL=ProgressCallbackTransform.js.map

/***/ }),
/* 53 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Standard YAML's Core schema.
// http://www.yaml.org/spec/1.2/spec.html#id2804923
//
// NOTE: JS-YAML does not support schema-specific tag resolution restrictions.
// So, Core schema has no distinctions from JSON schema is JS-YAML.




var Schema = __webpack_require__(18);

module.exports = new Schema({
  include: [__webpack_require__(54)]
});

/***/ }),
/* 54 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Standard YAML's JSON schema.
// http://www.yaml.org/spec/1.2/spec.html#id2803231
//
// NOTE: JS-YAML does not support schema-specific tag resolution restrictions.
// So, this schema is not such strict as defined in the YAML specification.
// It allows numbers in binary notaion, use `Null` and `NULL` as `null`, etc.




var Schema = __webpack_require__(18);

module.exports = new Schema({
  include: [__webpack_require__(32)],
  implicit: [__webpack_require__(143), __webpack_require__(144), __webpack_require__(145), __webpack_require__(146)]
});

/***/ }),
/* 55 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports = module.exports = SemVer;

// The debug function is excluded entirely from the minified version.
/* nomin */var debug;
/* nomin */if (typeof process === 'object' &&
/* nomin */process.env &&
/* nomin */process.env.NODE_DEBUG &&
/* nomin *//\bsemver\b/i.test(process.env.NODE_DEBUG))
  /* nomin */debug = function () {
    /* nomin */var args = Array.prototype.slice.call(arguments, 0);
    /* nomin */args.unshift('SEMVER');
    /* nomin */console.log.apply(console, args);
    /* nomin */
  };
  /* nomin */else
  /* nomin */debug = function () {};

// Note: this is the semver.org version of the spec that it implements
// Not necessarily the package version of this code.
exports.SEMVER_SPEC_VERSION = '2.0.0';

var MAX_LENGTH = 256;
var MAX_SAFE_INTEGER = Number.MAX_SAFE_INTEGER || 9007199254740991;

// The actual regexps go on exports.re
var re = exports.re = [];
var src = exports.src = [];
var R = 0;

// The following Regular Expressions can be used for tokenizing,
// validating, and parsing SemVer version strings.

// ## Numeric Identifier
// A single `0`, or a non-zero digit followed by zero or more digits.

var NUMERICIDENTIFIER = R++;
src[NUMERICIDENTIFIER] = '0|[1-9]\\d*';
var NUMERICIDENTIFIERLOOSE = R++;
src[NUMERICIDENTIFIERLOOSE] = '[0-9]+';

// ## Non-numeric Identifier
// Zero or more digits, followed by a letter or hyphen, and then zero or
// more letters, digits, or hyphens.

var NONNUMERICIDENTIFIER = R++;
src[NONNUMERICIDENTIFIER] = '\\d*[a-zA-Z-][a-zA-Z0-9-]*';

// ## Main Version
// Three dot-separated numeric identifiers.

var MAINVERSION = R++;
src[MAINVERSION] = '(' + src[NUMERICIDENTIFIER] + ')\\.' + '(' + src[NUMERICIDENTIFIER] + ')\\.' + '(' + src[NUMERICIDENTIFIER] + ')';

var MAINVERSIONLOOSE = R++;
src[MAINVERSIONLOOSE] = '(' + src[NUMERICIDENTIFIERLOOSE] + ')\\.' + '(' + src[NUMERICIDENTIFIERLOOSE] + ')\\.' + '(' + src[NUMERICIDENTIFIERLOOSE] + ')';

// ## Pre-release Version Identifier
// A numeric identifier, or a non-numeric identifier.

var PRERELEASEIDENTIFIER = R++;
src[PRERELEASEIDENTIFIER] = '(?:' + src[NUMERICIDENTIFIER] + '|' + src[NONNUMERICIDENTIFIER] + ')';

var PRERELEASEIDENTIFIERLOOSE = R++;
src[PRERELEASEIDENTIFIERLOOSE] = '(?:' + src[NUMERICIDENTIFIERLOOSE] + '|' + src[NONNUMERICIDENTIFIER] + ')';

// ## Pre-release Version
// Hyphen, followed by one or more dot-separated pre-release version
// identifiers.

var PRERELEASE = R++;
src[PRERELEASE] = '(?:-(' + src[PRERELEASEIDENTIFIER] + '(?:\\.' + src[PRERELEASEIDENTIFIER] + ')*))';

var PRERELEASELOOSE = R++;
src[PRERELEASELOOSE] = '(?:-?(' + src[PRERELEASEIDENTIFIERLOOSE] + '(?:\\.' + src[PRERELEASEIDENTIFIERLOOSE] + ')*))';

// ## Build Metadata Identifier
// Any combination of digits, letters, or hyphens.

var BUILDIDENTIFIER = R++;
src[BUILDIDENTIFIER] = '[0-9A-Za-z-]+';

// ## Build Metadata
// Plus sign, followed by one or more period-separated build metadata
// identifiers.

var BUILD = R++;
src[BUILD] = '(?:\\+(' + src[BUILDIDENTIFIER] + '(?:\\.' + src[BUILDIDENTIFIER] + ')*))';

// ## Full Version String
// A main version, followed optionally by a pre-release version and
// build metadata.

// Note that the only major, minor, patch, and pre-release sections of
// the version string are capturing groups.  The build metadata is not a
// capturing group, because it should not ever be used in version
// comparison.

var FULL = R++;
var FULLPLAIN = 'v?' + src[MAINVERSION] + src[PRERELEASE] + '?' + src[BUILD] + '?';

src[FULL] = '^' + FULLPLAIN + '$';

// like full, but allows v1.2.3 and =1.2.3, which people do sometimes.
// also, 1.0.0alpha1 (prerelease without the hyphen) which is pretty
// common in the npm registry.
var LOOSEPLAIN = '[v=\\s]*' + src[MAINVERSIONLOOSE] + src[PRERELEASELOOSE] + '?' + src[BUILD] + '?';

var LOOSE = R++;
src[LOOSE] = '^' + LOOSEPLAIN + '$';

var GTLT = R++;
src[GTLT] = '((?:<|>)?=?)';

// Something like "2.*" or "1.2.x".
// Note that "x.x" is a valid xRange identifer, meaning "any version"
// Only the first item is strictly required.
var XRANGEIDENTIFIERLOOSE = R++;
src[XRANGEIDENTIFIERLOOSE] = src[NUMERICIDENTIFIERLOOSE] + '|x|X|\\*';
var XRANGEIDENTIFIER = R++;
src[XRANGEIDENTIFIER] = src[NUMERICIDENTIFIER] + '|x|X|\\*';

var XRANGEPLAIN = R++;
src[XRANGEPLAIN] = '[v=\\s]*(' + src[XRANGEIDENTIFIER] + ')' + '(?:\\.(' + src[XRANGEIDENTIFIER] + ')' + '(?:\\.(' + src[XRANGEIDENTIFIER] + ')' + '(?:' + src[PRERELEASE] + ')?' + src[BUILD] + '?' + ')?)?';

var XRANGEPLAINLOOSE = R++;
src[XRANGEPLAINLOOSE] = '[v=\\s]*(' + src[XRANGEIDENTIFIERLOOSE] + ')' + '(?:\\.(' + src[XRANGEIDENTIFIERLOOSE] + ')' + '(?:\\.(' + src[XRANGEIDENTIFIERLOOSE] + ')' + '(?:' + src[PRERELEASELOOSE] + ')?' + src[BUILD] + '?' + ')?)?';

var XRANGE = R++;
src[XRANGE] = '^' + src[GTLT] + '\\s*' + src[XRANGEPLAIN] + '$';
var XRANGELOOSE = R++;
src[XRANGELOOSE] = '^' + src[GTLT] + '\\s*' + src[XRANGEPLAINLOOSE] + '$';

// Tilde ranges.
// Meaning is "reasonably at or greater than"
var LONETILDE = R++;
src[LONETILDE] = '(?:~>?)';

var TILDETRIM = R++;
src[TILDETRIM] = '(\\s*)' + src[LONETILDE] + '\\s+';
re[TILDETRIM] = new RegExp(src[TILDETRIM], 'g');
var tildeTrimReplace = '$1~';

var TILDE = R++;
src[TILDE] = '^' + src[LONETILDE] + src[XRANGEPLAIN] + '$';
var TILDELOOSE = R++;
src[TILDELOOSE] = '^' + src[LONETILDE] + src[XRANGEPLAINLOOSE] + '$';

// Caret ranges.
// Meaning is "at least and backwards compatible with"
var LONECARET = R++;
src[LONECARET] = '(?:\\^)';

var CARETTRIM = R++;
src[CARETTRIM] = '(\\s*)' + src[LONECARET] + '\\s+';
re[CARETTRIM] = new RegExp(src[CARETTRIM], 'g');
var caretTrimReplace = '$1^';

var CARET = R++;
src[CARET] = '^' + src[LONECARET] + src[XRANGEPLAIN] + '$';
var CARETLOOSE = R++;
src[CARETLOOSE] = '^' + src[LONECARET] + src[XRANGEPLAINLOOSE] + '$';

// A simple gt/lt/eq thing, or just "" to indicate "any version"
var COMPARATORLOOSE = R++;
src[COMPARATORLOOSE] = '^' + src[GTLT] + '\\s*(' + LOOSEPLAIN + ')$|^$';
var COMPARATOR = R++;
src[COMPARATOR] = '^' + src[GTLT] + '\\s*(' + FULLPLAIN + ')$|^$';

// An expression to strip any whitespace between the gtlt and the thing
// it modifies, so that `> 1.2.3` ==> `>1.2.3`
var COMPARATORTRIM = R++;
src[COMPARATORTRIM] = '(\\s*)' + src[GTLT] + '\\s*(' + LOOSEPLAIN + '|' + src[XRANGEPLAIN] + ')';

// this one has to use the /g flag
re[COMPARATORTRIM] = new RegExp(src[COMPARATORTRIM], 'g');
var comparatorTrimReplace = '$1$2$3';

// Something like `1.2.3 - 1.2.4`
// Note that these all use the loose form, because they'll be
// checked against either the strict or loose comparator form
// later.
var HYPHENRANGE = R++;
src[HYPHENRANGE] = '^\\s*(' + src[XRANGEPLAIN] + ')' + '\\s+-\\s+' + '(' + src[XRANGEPLAIN] + ')' + '\\s*$';

var HYPHENRANGELOOSE = R++;
src[HYPHENRANGELOOSE] = '^\\s*(' + src[XRANGEPLAINLOOSE] + ')' + '\\s+-\\s+' + '(' + src[XRANGEPLAINLOOSE] + ')' + '\\s*$';

// Star ranges basically just allow anything at all.
var STAR = R++;
src[STAR] = '(<|>)?=?\\s*\\*';

// Compile to actual regexp objects.
// All are flag-free, unless they were created above with a flag.
for (var i = 0; i < R; i++) {
  debug(i, src[i]);
  if (!re[i]) re[i] = new RegExp(src[i]);
}

exports.parse = parse;
function parse(version, loose) {
  if (version instanceof SemVer) return version;

  if (typeof version !== 'string') return null;

  if (version.length > MAX_LENGTH) return null;

  var r = loose ? re[LOOSE] : re[FULL];
  if (!r.test(version)) return null;

  try {
    return new SemVer(version, loose);
  } catch (er) {
    return null;
  }
}

exports.valid = valid;
function valid(version, loose) {
  var v = parse(version, loose);
  return v ? v.version : null;
}

exports.clean = clean;
function clean(version, loose) {
  var s = parse(version.trim().replace(/^[=v]+/, ''), loose);
  return s ? s.version : null;
}

exports.SemVer = SemVer;

function SemVer(version, loose) {
  if (version instanceof SemVer) {
    if (version.loose === loose) return version;else version = version.version;
  } else if (typeof version !== 'string') {
    throw new TypeError('Invalid Version: ' + version);
  }

  if (version.length > MAX_LENGTH) throw new TypeError('version is longer than ' + MAX_LENGTH + ' characters');

  if (!(this instanceof SemVer)) return new SemVer(version, loose);

  debug('SemVer', version, loose);
  this.loose = loose;
  var m = version.trim().match(loose ? re[LOOSE] : re[FULL]);

  if (!m) throw new TypeError('Invalid Version: ' + version);

  this.raw = version;

  // these are actually numbers
  this.major = +m[1];
  this.minor = +m[2];
  this.patch = +m[3];

  if (this.major > MAX_SAFE_INTEGER || this.major < 0) throw new TypeError('Invalid major version');

  if (this.minor > MAX_SAFE_INTEGER || this.minor < 0) throw new TypeError('Invalid minor version');

  if (this.patch > MAX_SAFE_INTEGER || this.patch < 0) throw new TypeError('Invalid patch version');

  // numberify any prerelease numeric ids
  if (!m[4]) this.prerelease = [];else this.prerelease = m[4].split('.').map(function (id) {
    if (/^[0-9]+$/.test(id)) {
      var num = +id;
      if (num >= 0 && num < MAX_SAFE_INTEGER) return num;
    }
    return id;
  });

  this.build = m[5] ? m[5].split('.') : [];
  this.format();
}

SemVer.prototype.format = function () {
  this.version = this.major + '.' + this.minor + '.' + this.patch;
  if (this.prerelease.length) this.version += '-' + this.prerelease.join('.');
  return this.version;
};

SemVer.prototype.toString = function () {
  return this.version;
};

SemVer.prototype.compare = function (other) {
  debug('SemVer.compare', this.version, this.loose, other);
  if (!(other instanceof SemVer)) other = new SemVer(other, this.loose);

  return this.compareMain(other) || this.comparePre(other);
};

SemVer.prototype.compareMain = function (other) {
  if (!(other instanceof SemVer)) other = new SemVer(other, this.loose);

  return compareIdentifiers(this.major, other.major) || compareIdentifiers(this.minor, other.minor) || compareIdentifiers(this.patch, other.patch);
};

SemVer.prototype.comparePre = function (other) {
  if (!(other instanceof SemVer)) other = new SemVer(other, this.loose);

  // NOT having a prerelease is > having one
  if (this.prerelease.length && !other.prerelease.length) return -1;else if (!this.prerelease.length && other.prerelease.length) return 1;else if (!this.prerelease.length && !other.prerelease.length) return 0;

  var i = 0;
  do {
    var a = this.prerelease[i];
    var b = other.prerelease[i];
    debug('prerelease compare', i, a, b);
    if (a === undefined && b === undefined) return 0;else if (b === undefined) return 1;else if (a === undefined) return -1;else if (a === b) continue;else return compareIdentifiers(a, b);
  } while (++i);
};

// preminor will bump the version up to the next minor release, and immediately
// down to pre-release. premajor and prepatch work the same way.
SemVer.prototype.inc = function (release, identifier) {
  switch (release) {
    case 'premajor':
      this.prerelease.length = 0;
      this.patch = 0;
      this.minor = 0;
      this.major++;
      this.inc('pre', identifier);
      break;
    case 'preminor':
      this.prerelease.length = 0;
      this.patch = 0;
      this.minor++;
      this.inc('pre', identifier);
      break;
    case 'prepatch':
      // If this is already a prerelease, it will bump to the next version
      // drop any prereleases that might already exist, since they are not
      // relevant at this point.
      this.prerelease.length = 0;
      this.inc('patch', identifier);
      this.inc('pre', identifier);
      break;
    // If the input is a non-prerelease version, this acts the same as
    // prepatch.
    case 'prerelease':
      if (this.prerelease.length === 0) this.inc('patch', identifier);
      this.inc('pre', identifier);
      break;

    case 'major':
      // If this is a pre-major version, bump up to the same major version.
      // Otherwise increment major.
      // 1.0.0-5 bumps to 1.0.0
      // 1.1.0 bumps to 2.0.0
      if (this.minor !== 0 || this.patch !== 0 || this.prerelease.length === 0) this.major++;
      this.minor = 0;
      this.patch = 0;
      this.prerelease = [];
      break;
    case 'minor':
      // If this is a pre-minor version, bump up to the same minor version.
      // Otherwise increment minor.
      // 1.2.0-5 bumps to 1.2.0
      // 1.2.1 bumps to 1.3.0
      if (this.patch !== 0 || this.prerelease.length === 0) this.minor++;
      this.patch = 0;
      this.prerelease = [];
      break;
    case 'patch':
      // If this is not a pre-release version, it will increment the patch.
      // If it is a pre-release it will bump up to the same patch version.
      // 1.2.0-5 patches to 1.2.0
      // 1.2.0 patches to 1.2.1
      if (this.prerelease.length === 0) this.patch++;
      this.prerelease = [];
      break;
    // This probably shouldn't be used publicly.
    // 1.0.0 "pre" would become 1.0.0-0 which is the wrong direction.
    case 'pre':
      if (this.prerelease.length === 0) this.prerelease = [0];else {
        var i = this.prerelease.length;
        while (--i >= 0) {
          if (typeof this.prerelease[i] === 'number') {
            this.prerelease[i]++;
            i = -2;
          }
        }
        if (i === -1) // didn't increment anything
          this.prerelease.push(0);
      }
      if (identifier) {
        // 1.2.0-beta.1 bumps to 1.2.0-beta.2,
        // 1.2.0-beta.fooblz or 1.2.0-beta bumps to 1.2.0-beta.0
        if (this.prerelease[0] === identifier) {
          if (isNaN(this.prerelease[1])) this.prerelease = [identifier, 0];
        } else this.prerelease = [identifier, 0];
      }
      break;

    default:
      throw new Error('invalid increment argument: ' + release);
  }
  this.format();
  this.raw = this.version;
  return this;
};

exports.inc = inc;
function inc(version, release, loose, identifier) {
  if (typeof loose === 'string') {
    identifier = loose;
    loose = undefined;
  }

  try {
    return new SemVer(version, loose).inc(release, identifier).version;
  } catch (er) {
    return null;
  }
}

exports.diff = diff;
function diff(version1, version2) {
  if (eq(version1, version2)) {
    return null;
  } else {
    var v1 = parse(version1);
    var v2 = parse(version2);
    if (v1.prerelease.length || v2.prerelease.length) {
      for (var key in v1) {
        if (key === 'major' || key === 'minor' || key === 'patch') {
          if (v1[key] !== v2[key]) {
            return 'pre' + key;
          }
        }
      }
      return 'prerelease';
    }
    for (var key in v1) {
      if (key === 'major' || key === 'minor' || key === 'patch') {
        if (v1[key] !== v2[key]) {
          return key;
        }
      }
    }
  }
}

exports.compareIdentifiers = compareIdentifiers;

var numeric = /^[0-9]+$/;
function compareIdentifiers(a, b) {
  var anum = numeric.test(a);
  var bnum = numeric.test(b);

  if (anum && bnum) {
    a = +a;
    b = +b;
  }

  return anum && !bnum ? -1 : bnum && !anum ? 1 : a < b ? -1 : a > b ? 1 : 0;
}

exports.rcompareIdentifiers = rcompareIdentifiers;
function rcompareIdentifiers(a, b) {
  return compareIdentifiers(b, a);
}

exports.major = major;
function major(a, loose) {
  return new SemVer(a, loose).major;
}

exports.minor = minor;
function minor(a, loose) {
  return new SemVer(a, loose).minor;
}

exports.patch = patch;
function patch(a, loose) {
  return new SemVer(a, loose).patch;
}

exports.compare = compare;
function compare(a, b, loose) {
  return new SemVer(a, loose).compare(new SemVer(b, loose));
}

exports.compareLoose = compareLoose;
function compareLoose(a, b) {
  return compare(a, b, true);
}

exports.rcompare = rcompare;
function rcompare(a, b, loose) {
  return compare(b, a, loose);
}

exports.sort = sort;
function sort(list, loose) {
  return list.sort(function (a, b) {
    return exports.compare(a, b, loose);
  });
}

exports.rsort = rsort;
function rsort(list, loose) {
  return list.sort(function (a, b) {
    return exports.rcompare(a, b, loose);
  });
}

exports.gt = gt;
function gt(a, b, loose) {
  return compare(a, b, loose) > 0;
}

exports.lt = lt;
function lt(a, b, loose) {
  return compare(a, b, loose) < 0;
}

exports.eq = eq;
function eq(a, b, loose) {
  return compare(a, b, loose) === 0;
}

exports.neq = neq;
function neq(a, b, loose) {
  return compare(a, b, loose) !== 0;
}

exports.gte = gte;
function gte(a, b, loose) {
  return compare(a, b, loose) >= 0;
}

exports.lte = lte;
function lte(a, b, loose) {
  return compare(a, b, loose) <= 0;
}

exports.cmp = cmp;
function cmp(a, op, b, loose) {
  var ret;
  switch (op) {
    case '===':
      if (typeof a === 'object') a = a.version;
      if (typeof b === 'object') b = b.version;
      ret = a === b;
      break;
    case '!==':
      if (typeof a === 'object') a = a.version;
      if (typeof b === 'object') b = b.version;
      ret = a !== b;
      break;
    case '':case '=':case '==':
      ret = eq(a, b, loose);break;
    case '!=':
      ret = neq(a, b, loose);break;
    case '>':
      ret = gt(a, b, loose);break;
    case '>=':
      ret = gte(a, b, loose);break;
    case '<':
      ret = lt(a, b, loose);break;
    case '<=':
      ret = lte(a, b, loose);break;
    default:
      throw new TypeError('Invalid operator: ' + op);
  }
  return ret;
}

exports.Comparator = Comparator;
function Comparator(comp, loose) {
  if (comp instanceof Comparator) {
    if (comp.loose === loose) return comp;else comp = comp.value;
  }

  if (!(this instanceof Comparator)) return new Comparator(comp, loose);

  debug('comparator', comp, loose);
  this.loose = loose;
  this.parse(comp);

  if (this.semver === ANY) this.value = '';else this.value = this.operator + this.semver.version;

  debug('comp', this);
}

var ANY = {};
Comparator.prototype.parse = function (comp) {
  var r = this.loose ? re[COMPARATORLOOSE] : re[COMPARATOR];
  var m = comp.match(r);

  if (!m) throw new TypeError('Invalid comparator: ' + comp);

  this.operator = m[1];
  if (this.operator === '=') this.operator = '';

  // if it literally is just '>' or '' then allow anything.
  if (!m[2]) this.semver = ANY;else this.semver = new SemVer(m[2], this.loose);
};

Comparator.prototype.toString = function () {
  return this.value;
};

Comparator.prototype.test = function (version) {
  debug('Comparator.test', version, this.loose);

  if (this.semver === ANY) return true;

  if (typeof version === 'string') version = new SemVer(version, this.loose);

  return cmp(version, this.operator, this.semver, this.loose);
};

Comparator.prototype.intersects = function (comp, loose) {
  if (!(comp instanceof Comparator)) {
    throw new TypeError('a Comparator is required');
  }

  var rangeTmp;

  if (this.operator === '') {
    rangeTmp = new Range(comp.value, loose);
    return satisfies(this.value, rangeTmp, loose);
  } else if (comp.operator === '') {
    rangeTmp = new Range(this.value, loose);
    return satisfies(comp.semver, rangeTmp, loose);
  }

  var sameDirectionIncreasing = (this.operator === '>=' || this.operator === '>') && (comp.operator === '>=' || comp.operator === '>');
  var sameDirectionDecreasing = (this.operator === '<=' || this.operator === '<') && (comp.operator === '<=' || comp.operator === '<');
  var sameSemVer = this.semver.version === comp.semver.version;
  var differentDirectionsInclusive = (this.operator === '>=' || this.operator === '<=') && (comp.operator === '>=' || comp.operator === '<=');
  var oppositeDirectionsLessThan = cmp(this.semver, '<', comp.semver, loose) && (this.operator === '>=' || this.operator === '>') && (comp.operator === '<=' || comp.operator === '<');
  var oppositeDirectionsGreaterThan = cmp(this.semver, '>', comp.semver, loose) && (this.operator === '<=' || this.operator === '<') && (comp.operator === '>=' || comp.operator === '>');

  return sameDirectionIncreasing || sameDirectionDecreasing || sameSemVer && differentDirectionsInclusive || oppositeDirectionsLessThan || oppositeDirectionsGreaterThan;
};

exports.Range = Range;
function Range(range, loose) {
  if (range instanceof Range) {
    if (range.loose === loose) {
      return range;
    } else {
      return new Range(range.raw, loose);
    }
  }

  if (range instanceof Comparator) {
    return new Range(range.value, loose);
  }

  if (!(this instanceof Range)) return new Range(range, loose);

  this.loose = loose;

  // First, split based on boolean or ||
  this.raw = range;
  this.set = range.split(/\s*\|\|\s*/).map(function (range) {
    return this.parseRange(range.trim());
  }, this).filter(function (c) {
    // throw out any that are not relevant for whatever reason
    return c.length;
  });

  if (!this.set.length) {
    throw new TypeError('Invalid SemVer Range: ' + range);
  }

  this.format();
}

Range.prototype.format = function () {
  this.range = this.set.map(function (comps) {
    return comps.join(' ').trim();
  }).join('||').trim();
  return this.range;
};

Range.prototype.toString = function () {
  return this.range;
};

Range.prototype.parseRange = function (range) {
  var loose = this.loose;
  range = range.trim();
  debug('range', range, loose);
  // `1.2.3 - 1.2.4` => `>=1.2.3 <=1.2.4`
  var hr = loose ? re[HYPHENRANGELOOSE] : re[HYPHENRANGE];
  range = range.replace(hr, hyphenReplace);
  debug('hyphen replace', range);
  // `> 1.2.3 < 1.2.5` => `>1.2.3 <1.2.5`
  range = range.replace(re[COMPARATORTRIM], comparatorTrimReplace);
  debug('comparator trim', range, re[COMPARATORTRIM]);

  // `~ 1.2.3` => `~1.2.3`
  range = range.replace(re[TILDETRIM], tildeTrimReplace);

  // `^ 1.2.3` => `^1.2.3`
  range = range.replace(re[CARETTRIM], caretTrimReplace);

  // normalize spaces
  range = range.split(/\s+/).join(' ');

  // At this point, the range is completely trimmed and
  // ready to be split into comparators.

  var compRe = loose ? re[COMPARATORLOOSE] : re[COMPARATOR];
  var set = range.split(' ').map(function (comp) {
    return parseComparator(comp, loose);
  }).join(' ').split(/\s+/);
  if (this.loose) {
    // in loose mode, throw out any that are not valid comparators
    set = set.filter(function (comp) {
      return !!comp.match(compRe);
    });
  }
  set = set.map(function (comp) {
    return new Comparator(comp, loose);
  });

  return set;
};

Range.prototype.intersects = function (range, loose) {
  if (!(range instanceof Range)) {
    throw new TypeError('a Range is required');
  }

  return this.set.some(function (thisComparators) {
    return thisComparators.every(function (thisComparator) {
      return range.set.some(function (rangeComparators) {
        return rangeComparators.every(function (rangeComparator) {
          return thisComparator.intersects(rangeComparator, loose);
        });
      });
    });
  });
};

// Mostly just for testing and legacy API reasons
exports.toComparators = toComparators;
function toComparators(range, loose) {
  return new Range(range, loose).set.map(function (comp) {
    return comp.map(function (c) {
      return c.value;
    }).join(' ').trim().split(' ');
  });
}

// comprised of xranges, tildes, stars, and gtlt's at this point.
// already replaced the hyphen ranges
// turn into a set of JUST comparators.
function parseComparator(comp, loose) {
  debug('comp', comp);
  comp = replaceCarets(comp, loose);
  debug('caret', comp);
  comp = replaceTildes(comp, loose);
  debug('tildes', comp);
  comp = replaceXRanges(comp, loose);
  debug('xrange', comp);
  comp = replaceStars(comp, loose);
  debug('stars', comp);
  return comp;
}

function isX(id) {
  return !id || id.toLowerCase() === 'x' || id === '*';
}

// ~, ~> --> * (any, kinda silly)
// ~2, ~2.x, ~2.x.x, ~>2, ~>2.x ~>2.x.x --> >=2.0.0 <3.0.0
// ~2.0, ~2.0.x, ~>2.0, ~>2.0.x --> >=2.0.0 <2.1.0
// ~1.2, ~1.2.x, ~>1.2, ~>1.2.x --> >=1.2.0 <1.3.0
// ~1.2.3, ~>1.2.3 --> >=1.2.3 <1.3.0
// ~1.2.0, ~>1.2.0 --> >=1.2.0 <1.3.0
function replaceTildes(comp, loose) {
  return comp.trim().split(/\s+/).map(function (comp) {
    return replaceTilde(comp, loose);
  }).join(' ');
}

function replaceTilde(comp, loose) {
  var r = loose ? re[TILDELOOSE] : re[TILDE];
  return comp.replace(r, function (_, M, m, p, pr) {
    debug('tilde', comp, _, M, m, p, pr);
    var ret;

    if (isX(M)) ret = '';else if (isX(m)) ret = '>=' + M + '.0.0 <' + (+M + 1) + '.0.0';else if (isX(p))
      // ~1.2 == >=1.2.0 <1.3.0
      ret = '>=' + M + '.' + m + '.0 <' + M + '.' + (+m + 1) + '.0';else if (pr) {
      debug('replaceTilde pr', pr);
      if (pr.charAt(0) !== '-') pr = '-' + pr;
      ret = '>=' + M + '.' + m + '.' + p + pr + ' <' + M + '.' + (+m + 1) + '.0';
    } else
      // ~1.2.3 == >=1.2.3 <1.3.0
      ret = '>=' + M + '.' + m + '.' + p + ' <' + M + '.' + (+m + 1) + '.0';

    debug('tilde return', ret);
    return ret;
  });
}

// ^ --> * (any, kinda silly)
// ^2, ^2.x, ^2.x.x --> >=2.0.0 <3.0.0
// ^2.0, ^2.0.x --> >=2.0.0 <3.0.0
// ^1.2, ^1.2.x --> >=1.2.0 <2.0.0
// ^1.2.3 --> >=1.2.3 <2.0.0
// ^1.2.0 --> >=1.2.0 <2.0.0
function replaceCarets(comp, loose) {
  return comp.trim().split(/\s+/).map(function (comp) {
    return replaceCaret(comp, loose);
  }).join(' ');
}

function replaceCaret(comp, loose) {
  debug('caret', comp, loose);
  var r = loose ? re[CARETLOOSE] : re[CARET];
  return comp.replace(r, function (_, M, m, p, pr) {
    debug('caret', comp, _, M, m, p, pr);
    var ret;

    if (isX(M)) ret = '';else if (isX(m)) ret = '>=' + M + '.0.0 <' + (+M + 1) + '.0.0';else if (isX(p)) {
      if (M === '0') ret = '>=' + M + '.' + m + '.0 <' + M + '.' + (+m + 1) + '.0';else ret = '>=' + M + '.' + m + '.0 <' + (+M + 1) + '.0.0';
    } else if (pr) {
      debug('replaceCaret pr', pr);
      if (pr.charAt(0) !== '-') pr = '-' + pr;
      if (M === '0') {
        if (m === '0') ret = '>=' + M + '.' + m + '.' + p + pr + ' <' + M + '.' + m + '.' + (+p + 1);else ret = '>=' + M + '.' + m + '.' + p + pr + ' <' + M + '.' + (+m + 1) + '.0';
      } else ret = '>=' + M + '.' + m + '.' + p + pr + ' <' + (+M + 1) + '.0.0';
    } else {
      debug('no pr');
      if (M === '0') {
        if (m === '0') ret = '>=' + M + '.' + m + '.' + p + ' <' + M + '.' + m + '.' + (+p + 1);else ret = '>=' + M + '.' + m + '.' + p + ' <' + M + '.' + (+m + 1) + '.0';
      } else ret = '>=' + M + '.' + m + '.' + p + ' <' + (+M + 1) + '.0.0';
    }

    debug('caret return', ret);
    return ret;
  });
}

function replaceXRanges(comp, loose) {
  debug('replaceXRanges', comp, loose);
  return comp.split(/\s+/).map(function (comp) {
    return replaceXRange(comp, loose);
  }).join(' ');
}

function replaceXRange(comp, loose) {
  comp = comp.trim();
  var r = loose ? re[XRANGELOOSE] : re[XRANGE];
  return comp.replace(r, function (ret, gtlt, M, m, p, pr) {
    debug('xRange', comp, ret, gtlt, M, m, p, pr);
    var xM = isX(M);
    var xm = xM || isX(m);
    var xp = xm || isX(p);
    var anyX = xp;

    if (gtlt === '=' && anyX) gtlt = '';

    if (xM) {
      if (gtlt === '>' || gtlt === '<') {
        // nothing is allowed
        ret = '<0.0.0';
      } else {
        // nothing is forbidden
        ret = '*';
      }
    } else if (gtlt && anyX) {
      // replace X with 0
      if (xm) m = 0;
      if (xp) p = 0;

      if (gtlt === '>') {
        // >1 => >=2.0.0
        // >1.2 => >=1.3.0
        // >1.2.3 => >= 1.2.4
        gtlt = '>=';
        if (xm) {
          M = +M + 1;
          m = 0;
          p = 0;
        } else if (xp) {
          m = +m + 1;
          p = 0;
        }
      } else if (gtlt === '<=') {
        // <=0.7.x is actually <0.8.0, since any 0.7.x should
        // pass.  Similarly, <=7.x is actually <8.0.0, etc.
        gtlt = '<';
        if (xm) M = +M + 1;else m = +m + 1;
      }

      ret = gtlt + M + '.' + m + '.' + p;
    } else if (xm) {
      ret = '>=' + M + '.0.0 <' + (+M + 1) + '.0.0';
    } else if (xp) {
      ret = '>=' + M + '.' + m + '.0 <' + M + '.' + (+m + 1) + '.0';
    }

    debug('xRange return', ret);

    return ret;
  });
}

// Because * is AND-ed with everything else in the comparator,
// and '' means "any version", just remove the *s entirely.
function replaceStars(comp, loose) {
  debug('replaceStars', comp, loose);
  // Looseness is ignored here.  star is always as loose as it gets!
  return comp.trim().replace(re[STAR], '');
}

// This function is passed to string.replace(re[HYPHENRANGE])
// M, m, patch, prerelease, build
// 1.2 - 3.4.5 => >=1.2.0 <=3.4.5
// 1.2.3 - 3.4 => >=1.2.0 <3.5.0 Any 3.4.x will do
// 1.2 - 3.4 => >=1.2.0 <3.5.0
function hyphenReplace($0, from, fM, fm, fp, fpr, fb, to, tM, tm, tp, tpr, tb) {

  if (isX(fM)) from = '';else if (isX(fm)) from = '>=' + fM + '.0.0';else if (isX(fp)) from = '>=' + fM + '.' + fm + '.0';else from = '>=' + from;

  if (isX(tM)) to = '';else if (isX(tm)) to = '<' + (+tM + 1) + '.0.0';else if (isX(tp)) to = '<' + tM + '.' + (+tm + 1) + '.0';else if (tpr) to = '<=' + tM + '.' + tm + '.' + tp + '-' + tpr;else to = '<=' + to;

  return (from + ' ' + to).trim();
}

// if ANY of the sets match ALL of its comparators, then pass
Range.prototype.test = function (version) {
  if (!version) return false;

  if (typeof version === 'string') version = new SemVer(version, this.loose);

  for (var i = 0; i < this.set.length; i++) {
    if (testSet(this.set[i], version)) return true;
  }
  return false;
};

function testSet(set, version) {
  for (var i = 0; i < set.length; i++) {
    if (!set[i].test(version)) return false;
  }

  if (version.prerelease.length) {
    // Find the set of versions that are allowed to have prereleases
    // For example, ^1.2.3-pr.1 desugars to >=1.2.3-pr.1 <2.0.0
    // That should allow `1.2.3-pr.2` to pass.
    // However, `1.2.4-alpha.notready` should NOT be allowed,
    // even though it's within the range set by the comparators.
    for (var i = 0; i < set.length; i++) {
      debug(set[i].semver);
      if (set[i].semver === ANY) continue;

      if (set[i].semver.prerelease.length > 0) {
        var allowed = set[i].semver;
        if (allowed.major === version.major && allowed.minor === version.minor && allowed.patch === version.patch) return true;
      }
    }

    // Version has a -pre, but it's not one of the ones we like.
    return false;
  }

  return true;
}

exports.satisfies = satisfies;
function satisfies(version, range, loose) {
  try {
    range = new Range(range, loose);
  } catch (er) {
    return false;
  }
  return range.test(version);
}

exports.maxSatisfying = maxSatisfying;
function maxSatisfying(versions, range, loose) {
  var max = null;
  var maxSV = null;
  try {
    var rangeObj = new Range(range, loose);
  } catch (er) {
    return null;
  }
  versions.forEach(function (v) {
    if (rangeObj.test(v)) {
      // satisfies(v, range, loose)
      if (!max || maxSV.compare(v) === -1) {
        // compare(max, v, true)
        max = v;
        maxSV = new SemVer(max, loose);
      }
    }
  });
  return max;
}

exports.minSatisfying = minSatisfying;
function minSatisfying(versions, range, loose) {
  var min = null;
  var minSV = null;
  try {
    var rangeObj = new Range(range, loose);
  } catch (er) {
    return null;
  }
  versions.forEach(function (v) {
    if (rangeObj.test(v)) {
      // satisfies(v, range, loose)
      if (!min || minSV.compare(v) === 1) {
        // compare(min, v, true)
        min = v;
        minSV = new SemVer(min, loose);
      }
    }
  });
  return min;
}

exports.validRange = validRange;
function validRange(range, loose) {
  try {
    // Return '*' instead of '' so that truthiness works.
    // This will throw if it's invalid anyway
    return new Range(range, loose).range || '*';
  } catch (er) {
    return null;
  }
}

// Determine if version is less than all the versions possible in the range
exports.ltr = ltr;
function ltr(version, range, loose) {
  return outside(version, range, '<', loose);
}

// Determine if version is greater than all the versions possible in the range.
exports.gtr = gtr;
function gtr(version, range, loose) {
  return outside(version, range, '>', loose);
}

exports.outside = outside;
function outside(version, range, hilo, loose) {
  version = new SemVer(version, loose);
  range = new Range(range, loose);

  var gtfn, ltefn, ltfn, comp, ecomp;
  switch (hilo) {
    case '>':
      gtfn = gt;
      ltefn = lte;
      ltfn = lt;
      comp = '>';
      ecomp = '>=';
      break;
    case '<':
      gtfn = lt;
      ltefn = gte;
      ltfn = gt;
      comp = '<';
      ecomp = '<=';
      break;
    default:
      throw new TypeError('Must provide a hilo val of "<" or ">"');
  }

  // If it satisifes the range it is not outside
  if (satisfies(version, range, loose)) {
    return false;
  }

  // From now on, variable terms are as if we're in "gtr" mode.
  // but note that everything is flipped for the "ltr" function.

  for (var i = 0; i < range.set.length; ++i) {
    var comparators = range.set[i];

    var high = null;
    var low = null;

    comparators.forEach(function (comparator) {
      if (comparator.semver === ANY) {
        comparator = new Comparator('>=0.0.0');
      }
      high = high || comparator;
      low = low || comparator;
      if (gtfn(comparator.semver, high.semver, loose)) {
        high = comparator;
      } else if (ltfn(comparator.semver, low.semver, loose)) {
        low = comparator;
      }
    });

    // If the edge version comparator has a operator then our version
    // isn't outside it
    if (high.operator === comp || high.operator === ecomp) {
      return false;
    }

    // If the lowest version comparator has an operator and our version
    // is less than it then it isn't higher than the range
    if ((!low.operator || low.operator === comp) && ltefn(version, low.semver)) {
      return false;
    } else if (low.operator === ecomp && ltfn(version, low.semver)) {
      return false;
    }
  }
  return true;
}

exports.prerelease = prerelease;
function prerelease(version, loose) {
  var parsed = parse(version, loose);
  return parsed && parsed.prerelease.length ? parsed.prerelease : null;
}

exports.intersects = intersects;
function intersects(r1, r2, loose) {
  r1 = new Range(r1, loose);
  r2 = new Range(r2, loose);
  return r1.intersects(r2);
}

/***/ }),
/* 56 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/* -*- Mode: js; js-indent-level: 2; -*- */
/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */

var base64VLQ = __webpack_require__(57);
var util = __webpack_require__(23);
var ArraySet = __webpack_require__(58).ArraySet;
var MappingList = __webpack_require__(163).MappingList;

/**
 * An instance of the SourceMapGenerator represents a source map which is
 * being built incrementally. You may pass an object with the following
 * properties:
 *
 *   - file: The filename of the generated source.
 *   - sourceRoot: A root for all relative URLs in this source map.
 */
function SourceMapGenerator(aArgs) {
  if (!aArgs) {
    aArgs = {};
  }
  this._file = util.getArg(aArgs, 'file', null);
  this._sourceRoot = util.getArg(aArgs, 'sourceRoot', null);
  this._skipValidation = util.getArg(aArgs, 'skipValidation', false);
  this._sources = new ArraySet();
  this._names = new ArraySet();
  this._mappings = new MappingList();
  this._sourcesContents = null;
}

SourceMapGenerator.prototype._version = 3;

/**
 * Creates a new SourceMapGenerator based on a SourceMapConsumer
 *
 * @param aSourceMapConsumer The SourceMap.
 */
SourceMapGenerator.fromSourceMap = function SourceMapGenerator_fromSourceMap(aSourceMapConsumer) {
  var sourceRoot = aSourceMapConsumer.sourceRoot;
  var generator = new SourceMapGenerator({
    file: aSourceMapConsumer.file,
    sourceRoot: sourceRoot
  });
  aSourceMapConsumer.eachMapping(function (mapping) {
    var newMapping = {
      generated: {
        line: mapping.generatedLine,
        column: mapping.generatedColumn
      }
    };

    if (mapping.source != null) {
      newMapping.source = mapping.source;
      if (sourceRoot != null) {
        newMapping.source = util.relative(sourceRoot, newMapping.source);
      }

      newMapping.original = {
        line: mapping.originalLine,
        column: mapping.originalColumn
      };

      if (mapping.name != null) {
        newMapping.name = mapping.name;
      }
    }

    generator.addMapping(newMapping);
  });
  aSourceMapConsumer.sources.forEach(function (sourceFile) {
    var sourceRelative = sourceFile;
    if (sourceRoot !== null) {
      sourceRelative = util.relative(sourceRoot, sourceFile);
    }

    if (!generator._sources.has(sourceRelative)) {
      generator._sources.add(sourceRelative);
    }

    var content = aSourceMapConsumer.sourceContentFor(sourceFile);
    if (content != null) {
      generator.setSourceContent(sourceFile, content);
    }
  });
  return generator;
};

/**
 * Add a single mapping from original source line and column to the generated
 * source's line and column for this source map being created. The mapping
 * object should have the following properties:
 *
 *   - generated: An object with the generated line and column positions.
 *   - original: An object with the original line and column positions.
 *   - source: The original source file (relative to the sourceRoot).
 *   - name: An optional original token name for this mapping.
 */
SourceMapGenerator.prototype.addMapping = function SourceMapGenerator_addMapping(aArgs) {
  var generated = util.getArg(aArgs, 'generated');
  var original = util.getArg(aArgs, 'original', null);
  var source = util.getArg(aArgs, 'source', null);
  var name = util.getArg(aArgs, 'name', null);

  if (!this._skipValidation) {
    this._validateMapping(generated, original, source, name);
  }

  if (source != null) {
    source = String(source);
    if (!this._sources.has(source)) {
      this._sources.add(source);
    }
  }

  if (name != null) {
    name = String(name);
    if (!this._names.has(name)) {
      this._names.add(name);
    }
  }

  this._mappings.add({
    generatedLine: generated.line,
    generatedColumn: generated.column,
    originalLine: original != null && original.line,
    originalColumn: original != null && original.column,
    source: source,
    name: name
  });
};

/**
 * Set the source content for a source file.
 */
SourceMapGenerator.prototype.setSourceContent = function SourceMapGenerator_setSourceContent(aSourceFile, aSourceContent) {
  var source = aSourceFile;
  if (this._sourceRoot != null) {
    source = util.relative(this._sourceRoot, source);
  }

  if (aSourceContent != null) {
    // Add the source content to the _sourcesContents map.
    // Create a new _sourcesContents map if the property is null.
    if (!this._sourcesContents) {
      this._sourcesContents = Object.create(null);
    }
    this._sourcesContents[util.toSetString(source)] = aSourceContent;
  } else if (this._sourcesContents) {
    // Remove the source file from the _sourcesContents map.
    // If the _sourcesContents map is empty, set the property to null.
    delete this._sourcesContents[util.toSetString(source)];
    if (Object.keys(this._sourcesContents).length === 0) {
      this._sourcesContents = null;
    }
  }
};

/**
 * Applies the mappings of a sub-source-map for a specific source file to the
 * source map being generated. Each mapping to the supplied source file is
 * rewritten using the supplied source map. Note: The resolution for the
 * resulting mappings is the minimium of this map and the supplied map.
 *
 * @param aSourceMapConsumer The source map to be applied.
 * @param aSourceFile Optional. The filename of the source file.
 *        If omitted, SourceMapConsumer's file property will be used.
 * @param aSourceMapPath Optional. The dirname of the path to the source map
 *        to be applied. If relative, it is relative to the SourceMapConsumer.
 *        This parameter is needed when the two source maps aren't in the same
 *        directory, and the source map to be applied contains relative source
 *        paths. If so, those relative source paths need to be rewritten
 *        relative to the SourceMapGenerator.
 */
SourceMapGenerator.prototype.applySourceMap = function SourceMapGenerator_applySourceMap(aSourceMapConsumer, aSourceFile, aSourceMapPath) {
  var sourceFile = aSourceFile;
  // If aSourceFile is omitted, we will use the file property of the SourceMap
  if (aSourceFile == null) {
    if (aSourceMapConsumer.file == null) {
      throw new Error('SourceMapGenerator.prototype.applySourceMap requires either an explicit source file, ' + 'or the source map\'s "file" property. Both were omitted.');
    }
    sourceFile = aSourceMapConsumer.file;
  }
  var sourceRoot = this._sourceRoot;
  // Make "sourceFile" relative if an absolute Url is passed.
  if (sourceRoot != null) {
    sourceFile = util.relative(sourceRoot, sourceFile);
  }
  // Applying the SourceMap can add and remove items from the sources and
  // the names array.
  var newSources = new ArraySet();
  var newNames = new ArraySet();

  // Find mappings for the "sourceFile"
  this._mappings.unsortedForEach(function (mapping) {
    if (mapping.source === sourceFile && mapping.originalLine != null) {
      // Check if it can be mapped by the source map, then update the mapping.
      var original = aSourceMapConsumer.originalPositionFor({
        line: mapping.originalLine,
        column: mapping.originalColumn
      });
      if (original.source != null) {
        // Copy mapping
        mapping.source = original.source;
        if (aSourceMapPath != null) {
          mapping.source = util.join(aSourceMapPath, mapping.source);
        }
        if (sourceRoot != null) {
          mapping.source = util.relative(sourceRoot, mapping.source);
        }
        mapping.originalLine = original.line;
        mapping.originalColumn = original.column;
        if (original.name != null) {
          mapping.name = original.name;
        }
      }
    }

    var source = mapping.source;
    if (source != null && !newSources.has(source)) {
      newSources.add(source);
    }

    var name = mapping.name;
    if (name != null && !newNames.has(name)) {
      newNames.add(name);
    }
  }, this);
  this._sources = newSources;
  this._names = newNames;

  // Copy sourcesContents of applied map.
  aSourceMapConsumer.sources.forEach(function (sourceFile) {
    var content = aSourceMapConsumer.sourceContentFor(sourceFile);
    if (content != null) {
      if (aSourceMapPath != null) {
        sourceFile = util.join(aSourceMapPath, sourceFile);
      }
      if (sourceRoot != null) {
        sourceFile = util.relative(sourceRoot, sourceFile);
      }
      this.setSourceContent(sourceFile, content);
    }
  }, this);
};

/**
 * A mapping can have one of the three levels of data:
 *
 *   1. Just the generated position.
 *   2. The Generated position, original position, and original source.
 *   3. Generated and original position, original source, as well as a name
 *      token.
 *
 * To maintain consistency, we validate that any new mapping being added falls
 * in to one of these categories.
 */
SourceMapGenerator.prototype._validateMapping = function SourceMapGenerator_validateMapping(aGenerated, aOriginal, aSource, aName) {
  // When aOriginal is truthy but has empty values for .line and .column,
  // it is most likely a programmer error. In this case we throw a very
  // specific error message to try to guide them the right way.
  // For example: https://github.com/Polymer/polymer-bundler/pull/519
  if (aOriginal && typeof aOriginal.line !== 'number' && typeof aOriginal.column !== 'number') {
    throw new Error('original.line and original.column are not numbers -- you probably meant to omit ' + 'the original mapping entirely and only map the generated position. If so, pass ' + 'null for the original mapping instead of an object with empty or null values.');
  }

  if (aGenerated && 'line' in aGenerated && 'column' in aGenerated && aGenerated.line > 0 && aGenerated.column >= 0 && !aOriginal && !aSource && !aName) {
    // Case 1.
    return;
  } else if (aGenerated && 'line' in aGenerated && 'column' in aGenerated && aOriginal && 'line' in aOriginal && 'column' in aOriginal && aGenerated.line > 0 && aGenerated.column >= 0 && aOriginal.line > 0 && aOriginal.column >= 0 && aSource) {
    // Cases 2 and 3.
    return;
  } else {
    throw new Error('Invalid mapping: ' + JSON.stringify({
      generated: aGenerated,
      source: aSource,
      original: aOriginal,
      name: aName
    }));
  }
};

/**
 * Serialize the accumulated mappings in to the stream of base 64 VLQs
 * specified by the source map format.
 */
SourceMapGenerator.prototype._serializeMappings = function SourceMapGenerator_serializeMappings() {
  var previousGeneratedColumn = 0;
  var previousGeneratedLine = 1;
  var previousOriginalColumn = 0;
  var previousOriginalLine = 0;
  var previousName = 0;
  var previousSource = 0;
  var result = '';
  var next;
  var mapping;
  var nameIdx;
  var sourceIdx;

  var mappings = this._mappings.toArray();
  for (var i = 0, len = mappings.length; i < len; i++) {
    mapping = mappings[i];
    next = '';

    if (mapping.generatedLine !== previousGeneratedLine) {
      previousGeneratedColumn = 0;
      while (mapping.generatedLine !== previousGeneratedLine) {
        next += ';';
        previousGeneratedLine++;
      }
    } else {
      if (i > 0) {
        if (!util.compareByGeneratedPositionsInflated(mapping, mappings[i - 1])) {
          continue;
        }
        next += ',';
      }
    }

    next += base64VLQ.encode(mapping.generatedColumn - previousGeneratedColumn);
    previousGeneratedColumn = mapping.generatedColumn;

    if (mapping.source != null) {
      sourceIdx = this._sources.indexOf(mapping.source);
      next += base64VLQ.encode(sourceIdx - previousSource);
      previousSource = sourceIdx;

      // lines are stored 0-based in SourceMap spec version 3
      next += base64VLQ.encode(mapping.originalLine - 1 - previousOriginalLine);
      previousOriginalLine = mapping.originalLine - 1;

      next += base64VLQ.encode(mapping.originalColumn - previousOriginalColumn);
      previousOriginalColumn = mapping.originalColumn;

      if (mapping.name != null) {
        nameIdx = this._names.indexOf(mapping.name);
        next += base64VLQ.encode(nameIdx - previousName);
        previousName = nameIdx;
      }
    }

    result += next;
  }

  return result;
};

SourceMapGenerator.prototype._generateSourcesContent = function SourceMapGenerator_generateSourcesContent(aSources, aSourceRoot) {
  return aSources.map(function (source) {
    if (!this._sourcesContents) {
      return null;
    }
    if (aSourceRoot != null) {
      source = util.relative(aSourceRoot, source);
    }
    var key = util.toSetString(source);
    return Object.prototype.hasOwnProperty.call(this._sourcesContents, key) ? this._sourcesContents[key] : null;
  }, this);
};

/**
 * Externalize the source map.
 */
SourceMapGenerator.prototype.toJSON = function SourceMapGenerator_toJSON() {
  var map = {
    version: this._version,
    sources: this._sources.toArray(),
    names: this._names.toArray(),
    mappings: this._serializeMappings()
  };
  if (this._file != null) {
    map.file = this._file;
  }
  if (this._sourceRoot != null) {
    map.sourceRoot = this._sourceRoot;
  }
  if (this._sourcesContents) {
    map.sourcesContent = this._generateSourcesContent(map.sources, map.sourceRoot);
  }

  return map;
};

/**
 * Render the source map being generated to a string.
 */
SourceMapGenerator.prototype.toString = function SourceMapGenerator_toString() {
  return JSON.stringify(this.toJSON());
};

exports.SourceMapGenerator = SourceMapGenerator;

/***/ }),
/* 57 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/* -*- Mode: js; js-indent-level: 2; -*- */
/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 *
 * Based on the Base 64 VLQ implementation in Closure Compiler:
 * https://code.google.com/p/closure-compiler/source/browse/trunk/src/com/google/debugging/sourcemap/Base64VLQ.java
 *
 * Copyright 2011 The Closure Compiler Authors. All rights reserved.
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are
 * met:
 *
 *  * Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *  * Redistributions in binary form must reproduce the above
 *    copyright notice, this list of conditions and the following
 *    disclaimer in the documentation and/or other materials provided
 *    with the distribution.
 *  * Neither the name of Google Inc. nor the names of its
 *    contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

var base64 = __webpack_require__(162);

// A single base 64 digit can contain 6 bits of data. For the base 64 variable
// length quantities we use in the source map spec, the first bit is the sign,
// the next four bits are the actual value, and the 6th bit is the
// continuation bit. The continuation bit tells us whether there are more
// digits in this value following this digit.
//
//   Continuation
//   |    Sign
//   |    |
//   V    V
//   101011

var VLQ_BASE_SHIFT = 5;

// binary: 100000
var VLQ_BASE = 1 << VLQ_BASE_SHIFT;

// binary: 011111
var VLQ_BASE_MASK = VLQ_BASE - 1;

// binary: 100000
var VLQ_CONTINUATION_BIT = VLQ_BASE;

/**
 * Converts from a two-complement value to a value where the sign bit is
 * placed in the least significant bit.  For example, as decimals:
 *   1 becomes 2 (10 binary), -1 becomes 3 (11 binary)
 *   2 becomes 4 (100 binary), -2 becomes 5 (101 binary)
 */
function toVLQSigned(aValue) {
  return aValue < 0 ? (-aValue << 1) + 1 : (aValue << 1) + 0;
}

/**
 * Converts to a two-complement value from a value where the sign bit is
 * placed in the least significant bit.  For example, as decimals:
 *   2 (10 binary) becomes 1, 3 (11 binary) becomes -1
 *   4 (100 binary) becomes 2, 5 (101 binary) becomes -2
 */
function fromVLQSigned(aValue) {
  var isNegative = (aValue & 1) === 1;
  var shifted = aValue >> 1;
  return isNegative ? -shifted : shifted;
}

/**
 * Returns the base 64 VLQ encoded value.
 */
exports.encode = function base64VLQ_encode(aValue) {
  var encoded = "";
  var digit;

  var vlq = toVLQSigned(aValue);

  do {
    digit = vlq & VLQ_BASE_MASK;
    vlq >>>= VLQ_BASE_SHIFT;
    if (vlq > 0) {
      // There are still more digits in this value, so we must make sure the
      // continuation bit is marked.
      digit |= VLQ_CONTINUATION_BIT;
    }
    encoded += base64.encode(digit);
  } while (vlq > 0);

  return encoded;
};

/**
 * Decodes the next base 64 VLQ value from the given string and returns the
 * value and the rest of the string via the out parameter.
 */
exports.decode = function base64VLQ_decode(aStr, aIndex, aOutParam) {
  var strLen = aStr.length;
  var result = 0;
  var shift = 0;
  var continuation, digit;

  do {
    if (aIndex >= strLen) {
      throw new Error("Expected more digits in base 64 VLQ value.");
    }

    digit = base64.decode(aStr.charCodeAt(aIndex++));
    if (digit === -1) {
      throw new Error("Invalid base64 digit: " + aStr.charAt(aIndex - 1));
    }

    continuation = !!(digit & VLQ_CONTINUATION_BIT);
    digit &= VLQ_BASE_MASK;
    result = result + (digit << shift);
    shift += VLQ_BASE_SHIFT;
  } while (continuation);

  aOutParam.value = fromVLQSigned(result);
  aOutParam.rest = aIndex;
};

/***/ }),
/* 58 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/* -*- Mode: js; js-indent-level: 2; -*- */
/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */

var util = __webpack_require__(23);
var has = Object.prototype.hasOwnProperty;
var hasNativeMap = typeof Map !== "undefined";

/**
 * A data structure which is a combination of an array and a set. Adding a new
 * member is O(1), testing for membership is O(1), and finding the index of an
 * element is O(1). Removing elements from the set is not supported. Only
 * strings are supported for membership.
 */
function ArraySet() {
  this._array = [];
  this._set = hasNativeMap ? new Map() : Object.create(null);
}

/**
 * Static method for creating ArraySet instances from an existing array.
 */
ArraySet.fromArray = function ArraySet_fromArray(aArray, aAllowDuplicates) {
  var set = new ArraySet();
  for (var i = 0, len = aArray.length; i < len; i++) {
    set.add(aArray[i], aAllowDuplicates);
  }
  return set;
};

/**
 * Return how many unique items are in this ArraySet. If duplicates have been
 * added, than those do not count towards the size.
 *
 * @returns Number
 */
ArraySet.prototype.size = function ArraySet_size() {
  return hasNativeMap ? this._set.size : Object.getOwnPropertyNames(this._set).length;
};

/**
 * Add the given string to this set.
 *
 * @param String aStr
 */
ArraySet.prototype.add = function ArraySet_add(aStr, aAllowDuplicates) {
  var sStr = hasNativeMap ? aStr : util.toSetString(aStr);
  var isDuplicate = hasNativeMap ? this.has(aStr) : has.call(this._set, sStr);
  var idx = this._array.length;
  if (!isDuplicate || aAllowDuplicates) {
    this._array.push(aStr);
  }
  if (!isDuplicate) {
    if (hasNativeMap) {
      this._set.set(aStr, idx);
    } else {
      this._set[sStr] = idx;
    }
  }
};

/**
 * Is the given string a member of this set?
 *
 * @param String aStr
 */
ArraySet.prototype.has = function ArraySet_has(aStr) {
  if (hasNativeMap) {
    return this._set.has(aStr);
  } else {
    var sStr = util.toSetString(aStr);
    return has.call(this._set, sStr);
  }
};

/**
 * What is the index of the given string in the array?
 *
 * @param String aStr
 */
ArraySet.prototype.indexOf = function ArraySet_indexOf(aStr) {
  if (hasNativeMap) {
    var idx = this._set.get(aStr);
    if (idx >= 0) {
      return idx;
    }
  } else {
    var sStr = util.toSetString(aStr);
    if (has.call(this._set, sStr)) {
      return this._set[sStr];
    }
  }

  throw new Error('"' + aStr + '" is not in the set.');
};

/**
 * What is the element at the given index?
 *
 * @param Number aIdx
 */
ArraySet.prototype.at = function ArraySet_at(aIdx) {
  if (aIdx >= 0 && aIdx < this._array.length) {
    return this._array[aIdx];
  }
  throw new Error('No element indexed by ' + aIdx);
};

/**
 * Returns the array representation of this set (which has the proper indices
 * indicated by indexOf). Note that this is a copy of the internal array used
 * for storing the members so that no one can mess with internal state.
 */
ArraySet.prototype.toArray = function ArraySet_toArray() {
  return this._array.slice();
};

exports.ArraySet = ArraySet;

/***/ }),
/* 59 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.GenericProvider = undefined;

var _bluebirdLst;

function _load_bluebirdLst() {
    return _bluebirdLst = __webpack_require__(2);
}

var _builderUtilRuntime;

function _load_builderUtilRuntime() {
    return _builderUtilRuntime = __webpack_require__(3);
}

var _main;

function _load_main() {
    return _main = __webpack_require__(8);
}

var _Provider;

function _load_Provider() {
    return _Provider = __webpack_require__(14);
}

class GenericProvider extends (_main || _load_main()).Provider {
    constructor(configuration, updater, useMultipleRangeRequest = true) {
        super(updater.httpExecutor, useMultipleRangeRequest);
        this.configuration = configuration;
        this.updater = updater;
        this.baseUrl = (0, (_main || _load_main()).newBaseUrl)(this.configuration.url);
    }
    get channel() {
        const result = this.updater.channel || this.configuration.channel;
        return result == null ? (0, (_main || _load_main()).getDefaultChannelName)() : (0, (_main || _load_main()).getCustomChannelName)(result);
    }
    getLatestVersion() {
        var _this = this;

        return (0, (_bluebirdLst || _load_bluebirdLst()).coroutine)(function* () {
            let result;
            const channelFile = (0, (_main || _load_main()).getChannelFilename)(_this.channel);
            const channelUrl = (0, (_main || _load_main()).newUrlFromBase)(channelFile, _this.baseUrl);
            for (let attemptNumber = 0;; attemptNumber++) {
                try {
                    result = (0, (_Provider || _load_Provider()).parseUpdateInfo)((yield _this.httpRequest(channelUrl)), channelFile, channelUrl);
                    break;
                } catch (e) {
                    if (e instanceof (_builderUtilRuntime || _load_builderUtilRuntime()).HttpError && e.statusCode === 404) {
                        throw (0, (_builderUtilRuntime || _load_builderUtilRuntime()).newError)(`Cannot find channel "${channelFile}" update info: ${e.stack || e.message}`, "ERR_UPDATER_CHANNEL_FILE_NOT_FOUND");
                    } else if (e.code === "ECONNREFUSED") {
                        if (attemptNumber < 3) {
                            yield new Promise(function (resolve, reject) {
                                try {
                                    setTimeout(resolve, 1000 * attemptNumber);
                                } catch (e) {
                                    reject(e);
                                }
                            });
                            continue;
                        }
                    }
                    throw e;
                }
            }
            if ((0, (_main || _load_main()).isUseOldMacProvider)()) {
                result.releaseJsonUrl = channelUrl.href;
            }
            return result;
        })();
    }
    resolveFiles(updateInfo) {
        return (0, (_Provider || _load_Provider()).resolveFiles)(updateInfo, this.baseUrl);
    }
}
exports.GenericProvider = GenericProvider; //# sourceMappingURL=GenericProvider.js.map

/***/ }),
/* 60 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.GitHubProvider = exports.BaseGitHubProvider = undefined;

var _bluebirdLst;

function _load_bluebirdLst() {
    return _bluebirdLst = __webpack_require__(2);
}

exports.computeReleaseNotes = computeReleaseNotes;

var _builderUtilRuntime;

function _load_builderUtilRuntime() {
    return _builderUtilRuntime = __webpack_require__(3);
}

var _semver;

function _load_semver() {
    return _semver = _interopRequireWildcard(__webpack_require__(55));
}

var _main;

function _load_main() {
    return _main = __webpack_require__(8);
}

var _Provider;

function _load_Provider() {
    return _Provider = __webpack_require__(14);
}

function _interopRequireWildcard(obj) {
    if (obj && obj.__esModule) {
        return obj;
    } else {
        var newObj = {};if (obj != null) {
            for (var key in obj) {
                if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key];
            }
        }newObj.default = obj;return newObj;
    }
}

class BaseGitHubProvider extends (_main || _load_main()).Provider {
    constructor(options, defaultHost, executor) {
        super(executor, false /* because GitHib uses S3 */);
        this.options = options;
        this.baseUrl = (0, (_main || _load_main()).newBaseUrl)((0, (_builderUtilRuntime || _load_builderUtilRuntime()).githubUrl)(options, defaultHost));
    }
    computeGithubBasePath(result) {
        // https://github.com/electron-userland/electron-builder/issues/1903#issuecomment-320881211
        const host = this.options.host;
        return host != null && host !== "github.com" && host !== "api.github.com" ? `/api/v3${result}` : result;
    }
}
exports.BaseGitHubProvider = BaseGitHubProvider;
class GitHubProvider extends BaseGitHubProvider {
    constructor(options, updater, executor) {
        super(options, "github.com", executor);
        this.options = options;
        this.updater = updater;
    }
    getLatestVersion() {
        var _this = this;

        return (0, (_bluebirdLst || _load_bluebirdLst()).coroutine)(function* () {
            const basePath = _this.basePath;
            const cancellationToken = new (_builderUtilRuntime || _load_builderUtilRuntime()).CancellationToken();
            const feedXml = yield _this.httpRequest((0, (_main || _load_main()).newUrlFromBase)(`${basePath}.atom`, _this.baseUrl), {
                Accept: "application/xml, application/atom+xml, text/xml, */*"
            }, cancellationToken);
            const feed = (0, (_builderUtilRuntime || _load_builderUtilRuntime()).parseXml)(feedXml);
            const latestRelease = feed.element("entry", false, `No published versions on GitHub`);
            let version;
            try {
                if (_this.updater.allowPrerelease) {
                    // noinspection TypeScriptValidateJSTypes
                    version = latestRelease.element("link").attribute("href").match(/\/tag\/v?([^\/]+)$/)[1];
                } else {
                    version = yield _this.getLatestVersionString(basePath, cancellationToken);
                }
            } catch (e) {
                throw (0, (_builderUtilRuntime || _load_builderUtilRuntime()).newError)(`Cannot parse releases feed: ${e.stack || e.message},\nXML:\n${feedXml}`, "ERR_UPDATER_INVALID_RELEASE_FEED");
            }
            if (version == null) {
                throw (0, (_builderUtilRuntime || _load_builderUtilRuntime()).newError)(`No published versions on GitHub`, "ERR_UPDATER_NO_PUBLISHED_VERSIONS");
            }
            const channelFile = (0, (_main || _load_main()).getChannelFilename)((0, (_main || _load_main()).getDefaultChannelName)());
            const channelFileUrl = (0, (_main || _load_main()).newUrlFromBase)(_this.getBaseDownloadPath(version, channelFile), _this.baseUrl);
            const requestOptions = _this.createRequestOptions(channelFileUrl);
            let rawData;
            try {
                rawData = yield _this.executor.request(requestOptions, cancellationToken);
            } catch (e) {
                if (!_this.updater.allowPrerelease && e instanceof (_builderUtilRuntime || _load_builderUtilRuntime()).HttpError && e.statusCode === 404) {
                    throw (0, (_builderUtilRuntime || _load_builderUtilRuntime()).newError)(`Cannot find ${channelFile} in the latest release artifacts (${channelFileUrl}): ${e.stack || e.message}`, "ERR_UPDATER_CHANNEL_FILE_NOT_FOUND");
                }
                throw e;
            }
            const result = (0, (_Provider || _load_Provider()).parseUpdateInfo)(rawData, channelFile, channelFileUrl);
            if ((0, (_main || _load_main()).isUseOldMacProvider)()) {
                result.releaseJsonUrl = `${(0, (_builderUtilRuntime || _load_builderUtilRuntime()).githubUrl)(_this.options)}/${requestOptions.path}`;
            }
            if (result.releaseName == null) {
                result.releaseName = latestRelease.elementValueOrEmpty("title");
            }
            if (result.releaseNotes == null) {
                result.releaseNotes = computeReleaseNotes(_this.updater.currentVersion, _this.updater.fullChangelog, feed, latestRelease);
            }
            return result;
        })();
    }
    getLatestVersionString(basePath, cancellationToken) {
        var _this2 = this;

        return (0, (_bluebirdLst || _load_bluebirdLst()).coroutine)(function* () {
            const url = (0, (_main || _load_main()).newUrlFromBase)(`${basePath}/latest`, _this2.baseUrl);
            try {
                // do not use API to avoid limit
                const rawData = yield _this2.httpRequest(url, { Accept: "application/json" }, cancellationToken);
                if (rawData == null) {
                    return null;
                }
                const releaseInfo = JSON.parse(rawData);
                return releaseInfo.tag_name.startsWith("v") ? releaseInfo.tag_name.substring(1) : releaseInfo.tag_name;
            } catch (e) {
                throw (0, (_builderUtilRuntime || _load_builderUtilRuntime()).newError)(`Unable to find latest version on GitHub (${url}), please ensure a production release exists: ${e.stack || e.message}`, "ERR_UPDATER_LATEST_VERSION_NOT_FOUND");
            }
        })();
    }
    get basePath() {
        return this.computeGithubBasePath(`/${this.options.owner}/${this.options.repo}/releases`);
    }
    resolveFiles(updateInfo) {
        // still replace space to - due to backward compatibility
        return (0, (_Provider || _load_Provider()).resolveFiles)(updateInfo, this.baseUrl, p => this.getBaseDownloadPath(updateInfo.version, p.replace(/ /g, "-")));
    }
    getBaseDownloadPath(version, fileName) {
        return `${this.basePath}/download/${this.options.vPrefixedTagName === false ? "" : "v"}${version}/${fileName}`;
    }
}
exports.GitHubProvider = GitHubProvider;
function getNoteValue(parent) {
    const result = parent.elementValueOrEmpty("content");
    // GitHub reports empty notes as <content>No content.</content>
    return result === "No content." ? "" : result;
}
function computeReleaseNotes(currentVersion, isFullChangelog, feed, latestRelease) {
    if (!isFullChangelog) {
        return getNoteValue(latestRelease);
    }
    const releaseNotes = [];
    for (const release of feed.getElements("entry")) {
        // noinspection TypeScriptValidateJSTypes
        const versionRelease = release.element("link").attribute("href").match(/\/tag\/v?([^\/]+)$/)[1];
        if ((_semver || _load_semver()).lt(currentVersion, versionRelease)) {
            releaseNotes.push({
                version: versionRelease,
                note: getNoteValue(release)
            });
        }
    }
    return releaseNotes.sort((a, b) => (_semver || _load_semver()).rcompare(a.version, b.version));
}
//# sourceMappingURL=GitHubProvider.js.map

/***/ }),
/* 61 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.BaseUpdater = undefined;

var _bluebirdLst;

function _load_bluebirdLst() {
    return _bluebirdLst = __webpack_require__(2);
}

var _builderUtilRuntime;

function _load_builderUtilRuntime() {
    return _builderUtilRuntime = __webpack_require__(3);
}

var _fsExtraP;

function _load_fsExtraP() {
    return _fsExtraP = __webpack_require__(9);
}

var _os;

function _load_os() {
    return _os = __webpack_require__(15);
}

var _path = _interopRequireWildcard(__webpack_require__(0));

var _AppUpdater;

function _load_AppUpdater() {
    return _AppUpdater = __webpack_require__(27);
}

var _DownloadedUpdateHelper;

function _load_DownloadedUpdateHelper() {
    return _DownloadedUpdateHelper = __webpack_require__(175);
}

var _main;

function _load_main() {
    return _main = __webpack_require__(8);
}

function _interopRequireWildcard(obj) {
    if (obj && obj.__esModule) {
        return obj;
    } else {
        var newObj = {};if (obj != null) {
            for (var key in obj) {
                if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key];
            }
        }newObj.default = obj;return newObj;
    }
}

class BaseUpdater extends (_AppUpdater || _load_AppUpdater()).AppUpdater {
    constructor(options, app) {
        super(options, app);
        this.downloadedUpdateHelper = new (_DownloadedUpdateHelper || _load_DownloadedUpdateHelper()).DownloadedUpdateHelper();
        this.quitAndInstallCalled = false;
        this.quitHandlerAdded = false;
    }
    quitAndInstall(isSilent = false, isForceRunAfter = false) {
        this._logger.info(`Install on explicit quitAndInstall`);
        if (this.install(isSilent, isSilent ? isForceRunAfter : true)) {
            setImmediate(() => {
                this.app.quit();
            });
        }
    }
    executeDownload(downloadOptions, fileInfo, task) {
        var _this = this;

        return (0, (_bluebirdLst || _load_bluebirdLst()).coroutine)(function* () {
            if (_this.listenerCount((_main || _load_main()).DOWNLOAD_PROGRESS) > 0) {
                downloadOptions.onProgress = function (it) {
                    return _this.emit((_main || _load_main()).DOWNLOAD_PROGRESS, it);
                };
            }
            // use TEST_APP_TMP_DIR if defined and developer machine (must be not windows due to security reasons - we must not use env var in the production)
            const tempDir = yield (0, (_fsExtraP || _load_fsExtraP()).mkdtemp)(`${_path.join((process.platform === "darwin" ? process.env.TEST_APP_TMP_DIR : null) || (0, (_os || _load_os()).tmpdir)(), "up")}-`);
            const removeTempDirIfAny = function () {
                _this.downloadedUpdateHelper.clear();
                return (0, (_fsExtraP || _load_fsExtraP()).remove)(tempDir).catch(function () {
                    // ignored
                });
            };
            try {
                const destinationFile = _path.join(tempDir, _path.posix.basename(fileInfo.info.url));
                yield task(tempDir, destinationFile, removeTempDirIfAny);
                _this._logger.info(`New version ${_this.updateInfo.version} has been downloaded to ${destinationFile}`);
            } catch (e) {
                yield removeTempDirIfAny();
                if (e instanceof (_builderUtilRuntime || _load_builderUtilRuntime()).CancellationError) {
                    _this.emit("update-cancelled", _this.updateInfo);
                    _this._logger.info("Cancelled");
                }
                throw e;
            }
        })();
    }
    install(isSilent, isRunAfter) {
        if (this.quitAndInstallCalled) {
            this._logger.warn("install call ignored: quitAndInstallCalled is set to true");
            return false;
        }
        const installerPath = this.downloadedUpdateHelper.file;
        if (!this.updateAvailable || installerPath == null) {
            this.dispatchError(new Error("No update available, can't quit and install"));
            return false;
        }
        // prevent calling several times
        this.quitAndInstallCalled = true;
        try {
            this._logger.info(`Install: isSilent: ${isSilent}, isRunAfter: ${isRunAfter}`);
            return this.doInstall(installerPath, isSilent, isRunAfter);
        } catch (e) {
            this.dispatchError(e);
            return false;
        }
    }
    addQuitHandler() {
        if (this.quitHandlerAdded) {
            return;
        }
        this.quitHandlerAdded = true;
        this.app.once("quit", () => {
            if (!this.quitAndInstallCalled) {
                this._logger.info("Auto install update on quit");
                this.install(true, false);
            }
        });
    }
}
exports.BaseUpdater = BaseUpdater; //# sourceMappingURL=BaseUpdater.js.map

/***/ }),
/* 62 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.FileWithEmbeddedBlockMapDifferentialDownloader = undefined;

var _bluebirdLst;

function _load_bluebirdLst() {
    return _bluebirdLst = __webpack_require__(2);
}

var _blockMapApi;

function _load_blockMapApi() {
    return _blockMapApi = __webpack_require__(63);
}

var _DifferentialDownloader;

function _load_DifferentialDownloader() {
    return _DifferentialDownloader = __webpack_require__(65);
}

class FileWithEmbeddedBlockMapDifferentialDownloader extends (_DifferentialDownloader || _load_DifferentialDownloader()).DifferentialDownloader {
    download() {
        var _this = this;

        return (0, (_bluebirdLst || _load_bluebirdLst()).coroutine)(function* () {
            const packageInfo = _this.blockAwareFileInfo;
            const fileSize = packageInfo.size;
            const offset = fileSize - (packageInfo.blockMapSize + 4);
            _this.fileMetadataBuffer = yield _this.readRemoteBytes(offset, fileSize - 1);
            const newBlockMap = yield (0, (_DifferentialDownloader || _load_DifferentialDownloader()).readBlockMap)(_this.fileMetadataBuffer.slice(0, _this.fileMetadataBuffer.length - 4));
            yield _this.doDownload(JSON.parse((yield (0, (_blockMapApi || _load_blockMapApi()).readEmbeddedBlockMapData)(_this.options.oldFile))), newBlockMap);
        })();
    }
}
exports.FileWithEmbeddedBlockMapDifferentialDownloader = FileWithEmbeddedBlockMapDifferentialDownloader; //# sourceMappingURL=FileWithEmbeddedBlockMapDifferentialDownloader.js.map

/***/ }),
/* 63 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.readEmbeddedBlockMapData = exports.BLOCK_MAP_FILE_NAME = undefined;

var _bluebirdLst;

function _load_bluebirdLst() {
    return _bluebirdLst = __webpack_require__(2);
}

var _bluebirdLst2;

function _load_bluebirdLst2() {
    return _bluebirdLst2 = _interopRequireDefault(__webpack_require__(2));
}

let readEmbeddedBlockMapData = exports.readEmbeddedBlockMapData = (() => {
    var _ref = (0, (_bluebirdLst || _load_bluebirdLst()).coroutine)(function* (file) {
        const fd = yield (0, (_fsExtraP || _load_fsExtraP()).open)(file, "r");
        try {
            const fileSize = (yield (0, (_fsExtraP || _load_fsExtraP()).fstat)(fd)).size;
            const sizeBuffer = Buffer.allocUnsafe(4);
            yield (0, (_fsExtraP || _load_fsExtraP()).read)(fd, sizeBuffer, 0, sizeBuffer.length, fileSize - sizeBuffer.length);
            const dataBuffer = Buffer.allocUnsafe(sizeBuffer.readUInt32BE(0));
            yield (0, (_fsExtraP || _load_fsExtraP()).read)(fd, dataBuffer, 0, dataBuffer.length, fileSize - sizeBuffer.length - dataBuffer.length);
            yield (0, (_fsExtraP || _load_fsExtraP()).close)(fd);
            const inflateRaw = (_bluebirdLst2 || _load_bluebirdLst2()).default.promisify(__webpack_require__(64).inflateRaw);
            return (yield inflateRaw(dataBuffer)).toString();
        } catch (e) {
            yield (0, (_fsExtraP || _load_fsExtraP()).close)(fd);
            throw e;
        }
    });

    return function readEmbeddedBlockMapData(_x) {
        return _ref.apply(this, arguments);
    };
})();
//# sourceMappingURL=blockMapApi.js.map


var _fsExtraP;

function _load_fsExtraP() {
    return _fsExtraP = __webpack_require__(9);
}

function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
}

const BLOCK_MAP_FILE_NAME = exports.BLOCK_MAP_FILE_NAME = "_blockMap.blockmap";

/***/ }),
/* 64 */
/***/ (function(module, exports) {

module.exports = require("zlib");

/***/ }),
/* 65 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.readBlockMap = exports.DifferentialDownloader = exports.DifferentialDownloaderOptions = undefined;

var _bluebirdLst;

function _load_bluebirdLst() {
    return _bluebirdLst = __webpack_require__(2);
}

var _bluebirdLst2;

function _load_bluebirdLst2() {
    return _bluebirdLst2 = _interopRequireDefault(__webpack_require__(2));
}

let readBlockMap = exports.readBlockMap = (() => {
    var _ref = (0, (_bluebirdLst || _load_bluebirdLst()).coroutine)(function* (data) {
        return JSON.parse((yield inflateRaw(data)).toString());
    });

    return function readBlockMap(_x) {
        return _ref.apply(this, arguments);
    };
})();

var _builderUtilRuntime;

function _load_builderUtilRuntime() {
    return _builderUtilRuntime = __webpack_require__(3);
}

var _fsExtraP;

function _load_fsExtraP() {
    return _fsExtraP = __webpack_require__(9);
}

var _DataSplitter;

function _load_DataSplitter() {
    return _DataSplitter = __webpack_require__(66);
}

var _downloadPlanBuilder;

function _load_downloadPlanBuilder() {
    return _downloadPlanBuilder = __webpack_require__(35);
}

var _multipleRangeDownloader;

function _load_multipleRangeDownloader() {
    return _multipleRangeDownloader = __webpack_require__(178);
}

function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
}

const inflateRaw = (_bluebirdLst2 || _load_bluebirdLst2()).default.promisify(__webpack_require__(64).inflateRaw);
class DifferentialDownloaderOptions {}
exports.DifferentialDownloaderOptions = DifferentialDownloaderOptions;
class DifferentialDownloader {
    // noinspection TypeScriptAbstractClassConstructorCanBeMadeProtected
    constructor(blockAwareFileInfo, httpExecutor, options) {
        this.blockAwareFileInfo = blockAwareFileInfo;
        this.httpExecutor = httpExecutor;
        this.options = options;
        this.logger = options.logger;
        this.baseRequestOptions = (0, (_builderUtilRuntime || _load_builderUtilRuntime()).configureRequestOptionsFromUrl)(options.newUrl, {});
    }
    get signatureSize() {
        return 0;
    }
    createRequestOptions(method = "get", newUrl) {
        return Object.assign({}, newUrl == null ? this.baseRequestOptions : (0, (_builderUtilRuntime || _load_builderUtilRuntime()).configureRequestOptionsFromUrl)(newUrl, {}), { method, headers: Object.assign({}, this.options.requestHeaders, { Accept: "*/*" }) });
    }
    doDownload(oldBlockMap, newBlockMap) {
        // we don't check other metadata like compressionMethod - generic check that it is make sense to differentially update is suitable for it
        if (oldBlockMap.version !== newBlockMap.version) {
            throw new Error(`version is different (${oldBlockMap.version} - ${newBlockMap.version}), full download is required`);
        }
        const logger = this.logger;
        const operations = (0, (_downloadPlanBuilder || _load_downloadPlanBuilder()).computeOperations)(oldBlockMap, newBlockMap, logger);
        if (logger.debug != null) {
            logger.debug(JSON.stringify(operations, null, 2));
        }
        let downloadSize = 0;
        let copySize = 0;
        for (const operation of operations) {
            const length = operation.end - operation.start;
            if (operation.kind === (_downloadPlanBuilder || _load_downloadPlanBuilder()).OperationKind.DOWNLOAD) {
                downloadSize += length;
            } else {
                copySize += length;
            }
        }
        const newPackageSize = this.blockAwareFileInfo.size;
        if (downloadSize + copySize + (this.fileMetadataBuffer == null ? 0 : this.fileMetadataBuffer.length) + this.signatureSize !== newPackageSize) {
            throw new Error(`Internal error, size mismatch: downloadSize: ${downloadSize}, copySize: ${copySize}, newPackageSize: ${newPackageSize}`);
        }
        logger.info(`Full: ${formatBytes(newPackageSize)}, To download: ${formatBytes(downloadSize)} (${Math.round(downloadSize / (newPackageSize / 100))}%)`);
        return this.downloadFile(operations);
    }
    downloadFile(tasks) {
        var _this = this;

        return (0, (_bluebirdLst || _load_bluebirdLst()).coroutine)(function* () {
            const signature = _this.signatureSize === 0 ? null : yield _this.readRemoteBytes(0, _this.signatureSize - 1);
            const oldFileFd = yield (0, (_fsExtraP || _load_fsExtraP()).open)(_this.options.oldFile, "r");
            const newFileFd = yield (0, (_fsExtraP || _load_fsExtraP()).open)(_this.options.newFile, "w");
            const fileOut = (0, (_fsExtraP || _load_fsExtraP()).createWriteStream)(_this.options.newFile, { fd: newFileFd });
            yield new (_bluebirdLst2 || _load_bluebirdLst2()).default(function (resolve, reject) {
                const streams = [];
                const digestTransform = new (_builderUtilRuntime || _load_builderUtilRuntime()).DigestTransform(_this.blockAwareFileInfo.sha512);
                // to simply debug, do manual validation to allow file to be fully written
                digestTransform.isValidateOnEnd = false;
                streams.push(digestTransform);
                // noinspection JSArrowFunctionCanBeReplacedWithShorthand
                fileOut.on("finish", function () {
                    fileOut.close(function () {
                        try {
                            digestTransform.validate();
                        } catch (e) {
                            reject(e);
                            return;
                        }
                        resolve();
                    });
                });
                streams.push(fileOut);
                let lastStream = null;
                for (const stream of streams) {
                    stream.on("error", reject);
                    if (lastStream == null) {
                        lastStream = stream;
                    } else {
                        lastStream = lastStream.pipe(stream);
                    }
                }
                const firstStream = streams[0];
                let w;
                if (_this.options.useMultipleRangeRequest) {
                    w = (0, (_multipleRangeDownloader || _load_multipleRangeDownloader()).executeTasks)(_this, tasks, firstStream, oldFileFd, reject);
                } else {
                    let attemptCount = 0;
                    let actualUrl = null;
                    _this.logger.info(`Differential download: ${_this.options.newUrl}`);
                    w = function (index) {
                        if (index >= tasks.length) {
                            if (_this.fileMetadataBuffer != null) {
                                firstStream.write(_this.fileMetadataBuffer);
                            }
                            firstStream.end();
                            return;
                        }
                        const operation = tasks[index++];
                        if (operation.kind === (_downloadPlanBuilder || _load_downloadPlanBuilder()).OperationKind.COPY) {
                            (0, (_DataSplitter || _load_DataSplitter()).copyData)(operation, firstStream, oldFileFd, reject, function () {
                                return w(index);
                            });
                        } else {
                            const requestOptions = _this.createRequestOptions("get", actualUrl);
                            const range = `bytes=${operation.start}-${operation.end - 1}`;
                            requestOptions.headers.Range = range;
                            requestOptions.redirect = "manual";
                            const debug = _this.logger.debug;
                            if (debug != null) {
                                debug(`effective url: ${actualUrl == null ? "" : removeQuery(actualUrl)}, range: ${range}`);
                            }
                            const request = _this.httpExecutor.doRequest(requestOptions, function (response) {
                                // Electron net handles redirects automatically, our NodeJS test server doesn't use redirects - so, we don't check 3xx codes.
                                if (response.statusCode >= 400) {
                                    reject((0, (_builderUtilRuntime || _load_builderUtilRuntime()).createHttpError)(response));
                                }
                                response.pipe(firstStream, {
                                    end: false
                                });
                                response.once("end", function () {
                                    if (++attemptCount === 100) {
                                        attemptCount = 0;
                                        setTimeout(function () {
                                            return w(index);
                                        }, 1000);
                                    } else {
                                        w(index);
                                    }
                                });
                            });
                            request.on("redirect", function (statusCode, method, redirectUrl) {
                                _this.logger.info(`Redirect to ${removeQuery(redirectUrl)}`);
                                actualUrl = redirectUrl;
                                request.followRedirect();
                            });
                            _this.httpExecutor.addErrorAndTimeoutHandlers(request, reject);
                            request.end();
                        }
                    };
                }
                if (signature == null) {
                    w(0);
                } else {
                    firstStream.write(signature, function () {
                        return w(0);
                    });
                }
            }).then(function () {
                return (0, (_fsExtraP || _load_fsExtraP()).close)(oldFileFd);
            }).catch(function (error) {
                (0, (_fsExtraP || _load_fsExtraP()).closeSync)(oldFileFd);
                (0, (_fsExtraP || _load_fsExtraP()).closeSync)(newFileFd);
                throw error;
            });
        })();
    }
    readRemoteBytes(start, endInclusive) {
        var _this2 = this;

        return (0, (_bluebirdLst || _load_bluebirdLst()).coroutine)(function* () {
            const buffer = Buffer.allocUnsafe(endInclusive + 1 - start);
            const requestOptions = _this2.createRequestOptions();
            requestOptions.headers.Range = `bytes=${start}-${endInclusive}`;
            let position = 0;
            yield _this2.request(requestOptions, function (chunk) {
                chunk.copy(buffer, position);
                position += chunk.length;
            });
            return buffer;
        })();
    }
    request(requestOptions, dataHandler) {
        return new (_bluebirdLst2 || _load_bluebirdLst2()).default((resolve, reject) => {
            const request = this.httpExecutor.doRequest(requestOptions, response => {
                if (!(0, (_multipleRangeDownloader || _load_multipleRangeDownloader()).checkIsRangesSupported)(response, reject)) {
                    return;
                }
                response.on("data", dataHandler);
                response.on("end", () => resolve());
            });
            this.httpExecutor.addErrorAndTimeoutHandlers(request, reject);
            request.end();
        });
    }
}
exports.DifferentialDownloader = DifferentialDownloader;

function formatBytes(value, symbol = " KB") {
    return new Intl.NumberFormat("en").format((value / 1024).toFixed(2)) + symbol;
}
// safety
function removeQuery(url) {
    const index = url.indexOf("?");
    return index < 0 ? url : url.substring(0, index);
}
//# sourceMappingURL=DifferentialDownloader.js.map

/***/ }),
/* 66 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.DataSplitter = undefined;

var _bluebirdLst;

function _load_bluebirdLst() {
    return _bluebirdLst = __webpack_require__(2);
}

var _bluebirdLst2;

function _load_bluebirdLst2() {
    return _bluebirdLst2 = _interopRequireDefault(__webpack_require__(2));
}

exports.copyData = copyData;

var _builderUtilRuntime;

function _load_builderUtilRuntime() {
    return _builderUtilRuntime = __webpack_require__(3);
}

var _fsExtraP;

function _load_fsExtraP() {
    return _fsExtraP = __webpack_require__(9);
}

var _stream;

function _load_stream() {
    return _stream = __webpack_require__(19);
}

var _downloadPlanBuilder;

function _load_downloadPlanBuilder() {
    return _downloadPlanBuilder = __webpack_require__(35);
}

function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
}

const DOUBLE_CRLF = Buffer.from("\r\n\r\n");
var ReadState;
(function (ReadState) {
    ReadState[ReadState["INIT"] = 0] = "INIT";
    ReadState[ReadState["HEADER"] = 1] = "HEADER";
    ReadState[ReadState["BODY"] = 2] = "BODY";
})(ReadState || (ReadState = {}));
function copyData(task, out, oldFileFd, reject, resolve) {
    const readStream = (0, (_fsExtraP || _load_fsExtraP()).createReadStream)("", {
        fd: oldFileFd,
        autoClose: false,
        start: task.start,
        // end is inclusive
        end: task.end - 1
    });
    readStream.on("error", reject);
    readStream.once("end", resolve);
    readStream.pipe(out, {
        end: false
    });
}
class DataSplitter extends (_stream || _load_stream()).Writable {
    constructor(out, options, partIndexToTaskIndex, boundary, partIndexToLength, finishHandler) {
        super();
        this.out = out;
        this.options = options;
        this.partIndexToTaskIndex = partIndexToTaskIndex;
        this.partIndexToLength = partIndexToLength;
        this.finishHandler = finishHandler;
        this.partIndex = -1;
        this.headerListBuffer = null;
        this.readState = ReadState.INIT;
        this.ignoreByteCount = 0;
        this.remainingPartDataCount = 0;
        this.actualPartLength = 0;
        this.boundaryLength = boundary.length + 4; /* size of \r\n-- */
        // first chunk doesn't start with \r\n
        this.ignoreByteCount = this.boundaryLength - 2;
    }
    get isFinished() {
        return this.partIndex === this.partIndexToLength.length;
    }
    // noinspection JSUnusedGlobalSymbols
    _write(data, encoding, callback) {
        if (this.isFinished) {
            console.error(`Trailing ignored data: ${data.length} bytes`);
            return;
        }
        this.handleData(data).then(callback).catch(callback);
    }
    handleData(chunk) {
        var _this = this;

        return (0, (_bluebirdLst || _load_bluebirdLst()).coroutine)(function* () {
            let start = 0;
            if (_this.ignoreByteCount !== 0 && _this.remainingPartDataCount !== 0) {
                throw (0, (_builderUtilRuntime || _load_builderUtilRuntime()).newError)("Internal error", "ERR_DATA_SPLITTER_BYTE_COUNT_MISMATCH");
            }
            if (_this.ignoreByteCount > 0) {
                const toIgnore = Math.min(_this.ignoreByteCount, chunk.length);
                _this.ignoreByteCount -= toIgnore;
                start = toIgnore;
            } else if (_this.remainingPartDataCount > 0) {
                const toRead = Math.min(_this.remainingPartDataCount, chunk.length);
                _this.remainingPartDataCount -= toRead;
                yield _this.processPartData(chunk, 0, toRead);
                start = toRead;
            }
            if (start === chunk.length) {
                return;
            }
            if (_this.readState === ReadState.HEADER) {
                const headerListEnd = _this.searchHeaderListEnd(chunk, start);
                if (headerListEnd === -1) {
                    return;
                }
                start = headerListEnd;
                _this.readState = ReadState.BODY;
                // header list is ignored, we don't need it
                _this.headerListBuffer = null;
            }
            while (true) {
                if (_this.readState === ReadState.BODY) {
                    _this.readState = ReadState.INIT;
                } else {
                    _this.partIndex++;
                    let taskIndex = _this.partIndexToTaskIndex.get(_this.partIndex);
                    if (taskIndex == null) {
                        if (_this.isFinished) {
                            taskIndex = _this.options.end;
                        } else {
                            throw (0, (_builderUtilRuntime || _load_builderUtilRuntime()).newError)("taskIndex is null", "ERR_DATA_SPLITTER_TASK_INDEX_IS_NULL");
                        }
                    }
                    const prevTaskIndex = _this.partIndex === 0 ? _this.options.start : _this.partIndexToTaskIndex.get(_this.partIndex - 1) + 1 /* prev part is download, next maybe copy */;
                    if (prevTaskIndex < taskIndex) {
                        yield _this.copyExistingData(prevTaskIndex, taskIndex);
                    } else if (prevTaskIndex > taskIndex) {
                        throw (0, (_builderUtilRuntime || _load_builderUtilRuntime()).newError)("prevTaskIndex must be < taskIndex", "ERR_DATA_SPLITTER_TASK_INDEX_ASSERT_FAILED");
                    }
                    if (_this.isFinished) {
                        _this.onPartEnd();
                        _this.finishHandler();
                        return;
                    }
                    start = _this.searchHeaderListEnd(chunk, start);
                    if (start === -1) {
                        _this.readState = ReadState.HEADER;
                        return;
                    }
                }
                const partLength = _this.partIndexToLength[_this.partIndex];
                const end = start + partLength;
                const effectiveEnd = Math.min(end, chunk.length);
                yield _this.processPartStarted(chunk, start, effectiveEnd);
                _this.remainingPartDataCount = partLength - (effectiveEnd - start);
                if (_this.remainingPartDataCount > 0) {
                    return;
                }
                start = end + _this.boundaryLength;
                if (start >= chunk.length) {
                    _this.ignoreByteCount = _this.boundaryLength - (chunk.length - end);
                    return;
                }
            }
        })();
    }
    copyExistingData(index, end) {
        return new (_bluebirdLst2 || _load_bluebirdLst2()).default((resolve, reject) => {
            const w = () => {
                if (index === end) {
                    resolve();
                    return;
                }
                const task = this.options.tasks[index];
                if (task.kind !== (_downloadPlanBuilder || _load_downloadPlanBuilder()).OperationKind.COPY) {
                    reject(new Error("Task kind must be COPY"));
                    return;
                }
                copyData(task, this.out, this.options.oldFileFd, reject, () => {
                    index++;
                    w();
                });
            };
            w();
        });
    }
    searchHeaderListEnd(chunk, readOffset) {
        const headerListEnd = chunk.indexOf(DOUBLE_CRLF, readOffset);
        if (headerListEnd !== -1) {
            return headerListEnd + DOUBLE_CRLF.length;
        }
        // not all headers data were received, save to buffer
        const partialChunk = readOffset === 0 ? chunk : chunk.slice(readOffset);
        if (this.headerListBuffer == null) {
            this.headerListBuffer = partialChunk;
        } else {
            this.headerListBuffer = Buffer.concat([this.headerListBuffer, partialChunk]);
        }
        return -1;
    }
    onPartEnd() {
        const expectedLength = this.partIndexToLength[this.partIndex - 1];
        if (this.actualPartLength !== expectedLength) {
            throw (0, (_builderUtilRuntime || _load_builderUtilRuntime()).newError)(`Expected length: ${expectedLength} differs from actual: ${this.actualPartLength}`, "ERR_DATA_SPLITTER_LENGTH_MISMATCH");
        }
        this.actualPartLength = 0;
    }
    processPartStarted(data, start, end) {
        if (this.partIndex !== 0) {
            this.onPartEnd();
        }
        return this.processPartData(data, start, end);
    }
    processPartData(data, start, end) {
        this.actualPartLength += end - start;
        const out = this.out;
        if (out.write(start === 0 && data.length === end ? data : data.slice(start, end))) {
            return (_bluebirdLst2 || _load_bluebirdLst2()).default.resolve();
        } else {
            return new (_bluebirdLst2 || _load_bluebirdLst2()).default((resolve, reject) => {
                out.on("error", reject);
                out.once("drain", () => {
                    out.removeListener("error", reject);
                    resolve();
                });
            });
        }
    }
}
exports.DataSplitter = DataSplitter; //# sourceMappingURL=DataSplitter.js.map

/***/ }),
/* 67 */
/***/ (function(module, exports) {

module.exports = require("http");

/***/ }),
/* 68 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * Save console methods for using when originals are overridden
 */

module.exports = {
  context: console,
  error: console.error,
  warn: console.warn,
  info: console.info,
  verbose: console.verbose,
  debug: console.debug,
  silly: console.silly,
  log: console.log
};

/***/ }),
/* 69 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _electron = __webpack_require__(10);

var _electronIsDev = __webpack_require__(26);

var _electronIsDev2 = _interopRequireDefault(_electronIsDev);

var _electronUpdater = __webpack_require__(8);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

let mainWindow;
const log = __webpack_require__(183);
log.transports.file.level = 'debug';
function onReady() {
    mainWindow = new _electron.BrowserWindow({
        width: 800,
        height: 600,
        webPreferences: {
            webSecurity: false
        }
    });
    mainWindow.setTitle(__webpack_require__(193).name);
    const fileName = `file://${__dirname}/index.html`;
    mainWindow.loadURL(fileName);
    mainWindow.on('close', () => _electron.app.quit());
    if (_electronIsDev2.default) {
        mainWindow.webContents.openDevTools();
    }
    if (!_electronIsDev2.default) {
        configureAppUpdate();
        setTimeout(() => {
            performAppUpdate();
        }, 5000);
    }
}
_electron.app.on('ready', () => onReady());
_electron.app.on('window-all-closed', () => _electron.app.quit());
_electron.app.on('browser-window-created', function (_e, window) {
    window.setMenu(null);
});
_electron.ipcMain.on('theme', (_event, arg) => {
    mainWindow.webContents.send('theme', arg);
});
function performAppUpdate() {
    log.debug('sending updater checking-for-update');
    _electronUpdater.autoUpdater.autoDownload = false;
    _electronUpdater.autoUpdater.checkForUpdates();
}
function configureAppUpdate() {
    _electronUpdater.autoUpdater.logger = log;
    _electronUpdater.autoUpdater.on('checking-for-update', () => {
        log.debug('sending updater checking-for-update');
        mainWindow.webContents.send('updater', 'checking-for-update');
    });
    _electronUpdater.autoUpdater.on('update-available', info => {
        log.debug('sending updater update-available');
        mainWindow.webContents.send('updater', 'update-available', info);
    });
    _electronUpdater.autoUpdater.on('update-not-available', info => {
        log.debug('sending updater update-not-available');
        mainWindow.webContents.send('updater', 'update-not-available', info);
    });
    _electronUpdater.autoUpdater.on('error', err => {
        log.debug('sending updater error');
        mainWindow.webContents.send('updater', 'error', err);
    });
    _electronUpdater.autoUpdater.on('download-progress', progressObj => {
        log.debug('sending updater download-progress');
        mainWindow.webContents.send('updater', 'download-progress', progressObj);
    });
    _electronUpdater.autoUpdater.on('update-downloaded', info => {
        log.debug('sending updater update-downloaded');
        mainWindow.webContents.send('updater', 'update-downloaded', info);
    });
    _electron.ipcMain.on('updater', (_event, type) => {
        if (type === 'download') {
            _electronUpdater.autoUpdater.downloadUpdate();
        }
        if (type === 'install') {
            _electronUpdater.autoUpdater.quitAndInstall();
        }
    });
}

/***/ }),
/* 70 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = function () {
    var makeSelfResolutionError = function () {
        return new TypeError("circular promise resolution chain\u000a\u000a    See http://goo.gl/MqrFmX\u000a");
    };
    var reflectHandler = function () {
        return new Promise.PromiseInspection(this._target());
    };
    var apiRejection = function (msg) {
        return Promise.reject(new TypeError(msg));
    };
    function Proxyable() {}
    var UNDEFINED_BINDING = {};
    var util = __webpack_require__(1);

    var getDomain;
    if (util.isNode) {
        getDomain = function () {
            var ret = process.domain;
            if (ret === undefined) ret = null;
            return ret;
        };
    } else {
        getDomain = function () {
            return null;
        };
    }
    util.notEnumerableProp(Promise, "_getDomain", getDomain);

    var es5 = __webpack_require__(16);
    var Async = __webpack_require__(71);
    var async = new Async();
    es5.defineProperty(Promise, "_async", { value: async });
    var errors = __webpack_require__(11);
    var TypeError = Promise.TypeError = errors.TypeError;
    Promise.RangeError = errors.RangeError;
    var CancellationError = Promise.CancellationError = errors.CancellationError;
    Promise.TimeoutError = errors.TimeoutError;
    Promise.OperationalError = errors.OperationalError;
    Promise.RejectionError = errors.OperationalError;
    Promise.AggregateError = errors.AggregateError;
    var INTERNAL = function () {};
    var APPLY = {};
    var NEXT_FILTER = {};
    var tryConvertToPromise = __webpack_require__(74)(Promise, INTERNAL);
    var PromiseArray = __webpack_require__(75)(Promise, INTERNAL, tryConvertToPromise, apiRejection, Proxyable);
    var Context = __webpack_require__(76)(Promise);
    /*jshint unused:false*/
    var createContext = Context.create;
    var debug = __webpack_require__(77)(Promise, Context);
    var CapturedTrace = debug.CapturedTrace;
    var PassThroughHandlerContext = __webpack_require__(78)(Promise, tryConvertToPromise, NEXT_FILTER);
    var catchFilter = __webpack_require__(38)(NEXT_FILTER);
    var nodebackForPromise = __webpack_require__(39);
    var errorObj = util.errorObj;
    var tryCatch = util.tryCatch;
    function check(self, executor) {
        if (self == null || self.constructor !== Promise) {
            throw new TypeError("the promise constructor cannot be invoked directly\u000a\u000a    See http://goo.gl/MqrFmX\u000a");
        }
        if (typeof executor !== "function") {
            throw new TypeError("expecting a function but got " + util.classString(executor));
        }
    }

    function Promise(executor) {
        if (executor !== INTERNAL) {
            check(this, executor);
        }
        this._bitField = 0;
        this._fulfillmentHandler0 = undefined;
        this._rejectionHandler0 = undefined;
        this._promise0 = undefined;
        this._receiver0 = undefined;
        this._resolveFromExecutor(executor);
        this._promiseCreated();
        this._fireEvent("promiseCreated", this);
    }

    Promise.prototype.toString = function () {
        return "[object Promise]";
    };

    Promise.prototype.caught = Promise.prototype["catch"] = function (fn) {
        var len = arguments.length;
        if (len > 1) {
            var catchInstances = new Array(len - 1),
                j = 0,
                i;
            for (i = 0; i < len - 1; ++i) {
                var item = arguments[i];
                if (util.isObject(item)) {
                    catchInstances[j++] = item;
                } else {
                    return apiRejection("Catch statement predicate: " + "expecting an object but got " + util.classString(item));
                }
            }
            catchInstances.length = j;
            fn = arguments[i];
            return this.then(undefined, catchFilter(catchInstances, fn, this));
        }
        return this.then(undefined, fn);
    };

    Promise.prototype.reflect = function () {
        return this._then(reflectHandler, reflectHandler, undefined, this, undefined);
    };

    Promise.prototype.then = function (didFulfill, didReject) {
        if (debug.warnings() && arguments.length > 0 && typeof didFulfill !== "function" && typeof didReject !== "function") {
            var msg = ".then() only accepts functions but was passed: " + util.classString(didFulfill);
            if (arguments.length > 1) {
                msg += ", " + util.classString(didReject);
            }
            this._warn(msg);
        }
        return this._then(didFulfill, didReject, undefined, undefined, undefined);
    };

    Promise.prototype.done = function (didFulfill, didReject) {
        var promise = this._then(didFulfill, didReject, undefined, undefined, undefined);
        promise._setIsFinal();
    };

    Promise.prototype.spread = function (fn) {
        if (typeof fn !== "function") {
            return apiRejection("expecting a function but got " + util.classString(fn));
        }
        return this.all()._then(fn, undefined, undefined, APPLY, undefined);
    };

    Promise.prototype.toJSON = function () {
        var ret = {
            isFulfilled: false,
            isRejected: false,
            fulfillmentValue: undefined,
            rejectionReason: undefined
        };
        if (this.isFulfilled()) {
            ret.fulfillmentValue = this.value();
            ret.isFulfilled = true;
        } else if (this.isRejected()) {
            ret.rejectionReason = this.reason();
            ret.isRejected = true;
        }
        return ret;
    };

    Promise.prototype.all = function () {
        if (arguments.length > 0) {
            this._warn(".all() was passed arguments but it does not take any");
        }
        return new PromiseArray(this).promise();
    };

    Promise.prototype.error = function (fn) {
        return this.caught(util.originatesFromRejection, fn);
    };

    Promise.getNewLibraryCopy = module.exports;

    Promise.is = function (val) {
        return val instanceof Promise;
    };

    Promise.fromNode = Promise.fromCallback = function (fn) {
        var ret = new Promise(INTERNAL);
        ret._captureStackTrace();
        var multiArgs = arguments.length > 1 ? !!Object(arguments[1]).multiArgs : false;
        var result = tryCatch(fn)(nodebackForPromise(ret, multiArgs));
        if (result === errorObj) {
            ret._rejectCallback(result.e, true);
        }
        if (!ret._isFateSealed()) ret._setAsyncGuaranteed();
        return ret;
    };

    Promise.all = function (promises) {
        return new PromiseArray(promises).promise();
    };

    Promise.cast = function (obj) {
        var ret = tryConvertToPromise(obj);
        if (!(ret instanceof Promise)) {
            ret = new Promise(INTERNAL);
            ret._captureStackTrace();
            ret._setFulfilled();
            ret._rejectionHandler0 = obj;
        }
        return ret;
    };

    Promise.resolve = Promise.fulfilled = Promise.cast;

    Promise.reject = Promise.rejected = function (reason) {
        var ret = new Promise(INTERNAL);
        ret._captureStackTrace();
        ret._rejectCallback(reason, true);
        return ret;
    };

    Promise.setScheduler = function (fn) {
        if (typeof fn !== "function") {
            throw new TypeError("expecting a function but got " + util.classString(fn));
        }
        return async.setScheduler(fn);
    };

    Promise.prototype._then = function (didFulfill, didReject, _, receiver, internalData) {
        var haveInternalData = internalData !== undefined;
        var promise = haveInternalData ? internalData : new Promise(INTERNAL);
        var target = this._target();
        var bitField = target._bitField;

        if (!haveInternalData) {
            promise._propagateFrom(this, 3);
            promise._captureStackTrace();
            if (receiver === undefined && (this._bitField & 2097152) !== 0) {
                if (!((bitField & 50397184) === 0)) {
                    receiver = this._boundValue();
                } else {
                    receiver = target === this ? undefined : this._boundTo;
                }
            }
            this._fireEvent("promiseChained", this, promise);
        }

        var domain = getDomain();
        if (!((bitField & 50397184) === 0)) {
            var handler,
                value,
                settler = target._settlePromiseCtx;
            if ((bitField & 33554432) !== 0) {
                value = target._rejectionHandler0;
                handler = didFulfill;
            } else if ((bitField & 16777216) !== 0) {
                value = target._fulfillmentHandler0;
                handler = didReject;
                target._unsetRejectionIsUnhandled();
            } else {
                settler = target._settlePromiseLateCancellationObserver;
                value = new CancellationError("late cancellation observer");
                target._attachExtraTrace(value);
                handler = didReject;
            }

            async.invoke(settler, target, {
                handler: domain === null ? handler : typeof handler === "function" && util.domainBind(domain, handler),
                promise: promise,
                receiver: receiver,
                value: value
            });
        } else {
            target._addCallbacks(didFulfill, didReject, promise, receiver, domain);
        }

        return promise;
    };

    Promise.prototype._length = function () {
        return this._bitField & 65535;
    };

    Promise.prototype._isFateSealed = function () {
        return (this._bitField & 117506048) !== 0;
    };

    Promise.prototype._isFollowing = function () {
        return (this._bitField & 67108864) === 67108864;
    };

    Promise.prototype._setLength = function (len) {
        this._bitField = this._bitField & -65536 | len & 65535;
    };

    Promise.prototype._setFulfilled = function () {
        this._bitField = this._bitField | 33554432;
        this._fireEvent("promiseFulfilled", this);
    };

    Promise.prototype._setRejected = function () {
        this._bitField = this._bitField | 16777216;
        this._fireEvent("promiseRejected", this);
    };

    Promise.prototype._setFollowing = function () {
        this._bitField = this._bitField | 67108864;
        this._fireEvent("promiseResolved", this);
    };

    Promise.prototype._setIsFinal = function () {
        this._bitField = this._bitField | 4194304;
    };

    Promise.prototype._isFinal = function () {
        return (this._bitField & 4194304) > 0;
    };

    Promise.prototype._unsetCancelled = function () {
        this._bitField = this._bitField & ~65536;
    };

    Promise.prototype._setCancelled = function () {
        this._bitField = this._bitField | 65536;
        this._fireEvent("promiseCancelled", this);
    };

    Promise.prototype._setWillBeCancelled = function () {
        this._bitField = this._bitField | 8388608;
    };

    Promise.prototype._setAsyncGuaranteed = function () {
        if (async.hasCustomScheduler()) return;
        this._bitField = this._bitField | 134217728;
    };

    Promise.prototype._receiverAt = function (index) {
        var ret = index === 0 ? this._receiver0 : this[index * 4 - 4 + 3];
        if (ret === UNDEFINED_BINDING) {
            return undefined;
        } else if (ret === undefined && this._isBound()) {
            return this._boundValue();
        }
        return ret;
    };

    Promise.prototype._promiseAt = function (index) {
        return this[index * 4 - 4 + 2];
    };

    Promise.prototype._fulfillmentHandlerAt = function (index) {
        return this[index * 4 - 4 + 0];
    };

    Promise.prototype._rejectionHandlerAt = function (index) {
        return this[index * 4 - 4 + 1];
    };

    Promise.prototype._boundValue = function () {};

    Promise.prototype._migrateCallback0 = function (follower) {
        var bitField = follower._bitField;
        var fulfill = follower._fulfillmentHandler0;
        var reject = follower._rejectionHandler0;
        var promise = follower._promise0;
        var receiver = follower._receiverAt(0);
        if (receiver === undefined) receiver = UNDEFINED_BINDING;
        this._addCallbacks(fulfill, reject, promise, receiver, null);
    };

    Promise.prototype._migrateCallbackAt = function (follower, index) {
        var fulfill = follower._fulfillmentHandlerAt(index);
        var reject = follower._rejectionHandlerAt(index);
        var promise = follower._promiseAt(index);
        var receiver = follower._receiverAt(index);
        if (receiver === undefined) receiver = UNDEFINED_BINDING;
        this._addCallbacks(fulfill, reject, promise, receiver, null);
    };

    Promise.prototype._addCallbacks = function (fulfill, reject, promise, receiver, domain) {
        var index = this._length();

        if (index >= 65535 - 4) {
            index = 0;
            this._setLength(0);
        }

        if (index === 0) {
            this._promise0 = promise;
            this._receiver0 = receiver;
            if (typeof fulfill === "function") {
                this._fulfillmentHandler0 = domain === null ? fulfill : util.domainBind(domain, fulfill);
            }
            if (typeof reject === "function") {
                this._rejectionHandler0 = domain === null ? reject : util.domainBind(domain, reject);
            }
        } else {
            var base = index * 4 - 4;
            this[base + 2] = promise;
            this[base + 3] = receiver;
            if (typeof fulfill === "function") {
                this[base + 0] = domain === null ? fulfill : util.domainBind(domain, fulfill);
            }
            if (typeof reject === "function") {
                this[base + 1] = domain === null ? reject : util.domainBind(domain, reject);
            }
        }
        this._setLength(index + 1);
        return index;
    };

    Promise.prototype._proxy = function (proxyable, arg) {
        this._addCallbacks(undefined, undefined, arg, proxyable, null);
    };

    Promise.prototype._resolveCallback = function (value, shouldBind) {
        if ((this._bitField & 117506048) !== 0) return;
        if (value === this) return this._rejectCallback(makeSelfResolutionError(), false);
        var maybePromise = tryConvertToPromise(value, this);
        if (!(maybePromise instanceof Promise)) return this._fulfill(value);

        if (shouldBind) this._propagateFrom(maybePromise, 2);

        var promise = maybePromise._target();

        if (promise === this) {
            this._reject(makeSelfResolutionError());
            return;
        }

        var bitField = promise._bitField;
        if ((bitField & 50397184) === 0) {
            var len = this._length();
            if (len > 0) promise._migrateCallback0(this);
            for (var i = 1; i < len; ++i) {
                promise._migrateCallbackAt(this, i);
            }
            this._setFollowing();
            this._setLength(0);
            this._setFollowee(promise);
        } else if ((bitField & 33554432) !== 0) {
            this._fulfill(promise._value());
        } else if ((bitField & 16777216) !== 0) {
            this._reject(promise._reason());
        } else {
            var reason = new CancellationError("late cancellation observer");
            promise._attachExtraTrace(reason);
            this._reject(reason);
        }
    };

    Promise.prototype._rejectCallback = function (reason, synchronous, ignoreNonErrorWarnings) {
        var trace = util.ensureErrorObject(reason);
        var hasStack = trace === reason;
        if (!hasStack && !ignoreNonErrorWarnings && debug.warnings()) {
            var message = "a promise was rejected with a non-error: " + util.classString(reason);
            this._warn(message, true);
        }
        this._attachExtraTrace(trace, synchronous ? hasStack : false);
        this._reject(reason);
    };

    Promise.prototype._resolveFromExecutor = function (executor) {
        if (executor === INTERNAL) return;
        var promise = this;
        this._captureStackTrace();
        this._pushContext();
        var synchronous = true;
        var r = this._execute(executor, function (value) {
            promise._resolveCallback(value);
        }, function (reason) {
            promise._rejectCallback(reason, synchronous);
        });
        synchronous = false;
        this._popContext();

        if (r !== undefined) {
            promise._rejectCallback(r, true);
        }
    };

    Promise.prototype._settlePromiseFromHandler = function (handler, receiver, value, promise) {
        var bitField = promise._bitField;
        if ((bitField & 65536) !== 0) return;
        promise._pushContext();
        var x;
        if (receiver === APPLY) {
            if (!value || typeof value.length !== "number") {
                x = errorObj;
                x.e = new TypeError("cannot .spread() a non-array: " + util.classString(value));
            } else {
                x = tryCatch(handler).apply(this._boundValue(), value);
            }
        } else {
            x = tryCatch(handler).call(receiver, value);
        }
        var promiseCreated = promise._popContext();
        bitField = promise._bitField;
        if ((bitField & 65536) !== 0) return;

        if (x === NEXT_FILTER) {
            promise._reject(value);
        } else if (x === errorObj) {
            promise._rejectCallback(x.e, false);
        } else {
            debug.checkForgottenReturns(x, promiseCreated, "", promise, this);
            promise._resolveCallback(x);
        }
    };

    Promise.prototype._target = function () {
        var ret = this;
        while (ret._isFollowing()) ret = ret._followee();
        return ret;
    };

    Promise.prototype._followee = function () {
        return this._rejectionHandler0;
    };

    Promise.prototype._setFollowee = function (promise) {
        this._rejectionHandler0 = promise;
    };

    Promise.prototype._settlePromise = function (promise, handler, receiver, value) {
        var isPromise = promise instanceof Promise;
        var bitField = this._bitField;
        var asyncGuaranteed = (bitField & 134217728) !== 0;
        if ((bitField & 65536) !== 0) {
            if (isPromise) promise._invokeInternalOnCancel();

            if (receiver instanceof PassThroughHandlerContext && receiver.isFinallyHandler()) {
                receiver.cancelPromise = promise;
                if (tryCatch(handler).call(receiver, value) === errorObj) {
                    promise._reject(errorObj.e);
                }
            } else if (handler === reflectHandler) {
                promise._fulfill(reflectHandler.call(receiver));
            } else if (receiver instanceof Proxyable) {
                receiver._promiseCancelled(promise);
            } else if (isPromise || promise instanceof PromiseArray) {
                promise._cancel();
            } else {
                receiver.cancel();
            }
        } else if (typeof handler === "function") {
            if (!isPromise) {
                handler.call(receiver, value, promise);
            } else {
                if (asyncGuaranteed) promise._setAsyncGuaranteed();
                this._settlePromiseFromHandler(handler, receiver, value, promise);
            }
        } else if (receiver instanceof Proxyable) {
            if (!receiver._isResolved()) {
                if ((bitField & 33554432) !== 0) {
                    receiver._promiseFulfilled(value, promise);
                } else {
                    receiver._promiseRejected(value, promise);
                }
            }
        } else if (isPromise) {
            if (asyncGuaranteed) promise._setAsyncGuaranteed();
            if ((bitField & 33554432) !== 0) {
                promise._fulfill(value);
            } else {
                promise._reject(value);
            }
        }
    };

    Promise.prototype._settlePromiseLateCancellationObserver = function (ctx) {
        var handler = ctx.handler;
        var promise = ctx.promise;
        var receiver = ctx.receiver;
        var value = ctx.value;
        if (typeof handler === "function") {
            if (!(promise instanceof Promise)) {
                handler.call(receiver, value, promise);
            } else {
                this._settlePromiseFromHandler(handler, receiver, value, promise);
            }
        } else if (promise instanceof Promise) {
            promise._reject(value);
        }
    };

    Promise.prototype._settlePromiseCtx = function (ctx) {
        this._settlePromise(ctx.promise, ctx.handler, ctx.receiver, ctx.value);
    };

    Promise.prototype._settlePromise0 = function (handler, value, bitField) {
        var promise = this._promise0;
        var receiver = this._receiverAt(0);
        this._promise0 = undefined;
        this._receiver0 = undefined;
        this._settlePromise(promise, handler, receiver, value);
    };

    Promise.prototype._clearCallbackDataAtIndex = function (index) {
        var base = index * 4 - 4;
        this[base + 2] = this[base + 3] = this[base + 0] = this[base + 1] = undefined;
    };

    Promise.prototype._fulfill = function (value) {
        var bitField = this._bitField;
        if ((bitField & 117506048) >>> 16) return;
        if (value === this) {
            var err = makeSelfResolutionError();
            this._attachExtraTrace(err);
            return this._reject(err);
        }
        this._setFulfilled();
        this._rejectionHandler0 = value;

        if ((bitField & 65535) > 0) {
            if ((bitField & 134217728) !== 0) {
                this._settlePromises();
            } else {
                async.settlePromises(this);
            }
        }
    };

    Promise.prototype._reject = function (reason) {
        var bitField = this._bitField;
        if ((bitField & 117506048) >>> 16) return;
        this._setRejected();
        this._fulfillmentHandler0 = reason;

        if (this._isFinal()) {
            return async.fatalError(reason, util.isNode);
        }

        if ((bitField & 65535) > 0) {
            async.settlePromises(this);
        } else {
            this._ensurePossibleRejectionHandled();
        }
    };

    Promise.prototype._fulfillPromises = function (len, value) {
        for (var i = 1; i < len; i++) {
            var handler = this._fulfillmentHandlerAt(i);
            var promise = this._promiseAt(i);
            var receiver = this._receiverAt(i);
            this._clearCallbackDataAtIndex(i);
            this._settlePromise(promise, handler, receiver, value);
        }
    };

    Promise.prototype._rejectPromises = function (len, reason) {
        for (var i = 1; i < len; i++) {
            var handler = this._rejectionHandlerAt(i);
            var promise = this._promiseAt(i);
            var receiver = this._receiverAt(i);
            this._clearCallbackDataAtIndex(i);
            this._settlePromise(promise, handler, receiver, reason);
        }
    };

    Promise.prototype._settlePromises = function () {
        var bitField = this._bitField;
        var len = bitField & 65535;

        if (len > 0) {
            if ((bitField & 16842752) !== 0) {
                var reason = this._fulfillmentHandler0;
                this._settlePromise0(this._rejectionHandler0, reason, bitField);
                this._rejectPromises(len, reason);
            } else {
                var value = this._rejectionHandler0;
                this._settlePromise0(this._fulfillmentHandler0, value, bitField);
                this._fulfillPromises(len, value);
            }
            this._setLength(0);
        }
        this._clearCancellationData();
    };

    Promise.prototype._settledValue = function () {
        var bitField = this._bitField;
        if ((bitField & 33554432) !== 0) {
            return this._rejectionHandler0;
        } else if ((bitField & 16777216) !== 0) {
            return this._fulfillmentHandler0;
        }
    };

    function deferResolve(v) {
        this.promise._resolveCallback(v);
    }
    function deferReject(v) {
        this.promise._rejectCallback(v, false);
    }

    Promise.defer = Promise.pending = function () {
        debug.deprecated("Promise.defer", "new Promise");
        var promise = new Promise(INTERNAL);
        return {
            promise: promise,
            resolve: deferResolve,
            reject: deferReject
        };
    };

    util.notEnumerableProp(Promise, "_makeSelfResolutionError", makeSelfResolutionError);

    __webpack_require__(79)(Promise, INTERNAL, tryConvertToPromise, apiRejection, debug);
    __webpack_require__(80)(Promise, INTERNAL, tryConvertToPromise, debug);
    __webpack_require__(81)(Promise, PromiseArray, apiRejection, debug);
    __webpack_require__(82)(Promise);
    __webpack_require__(83)(Promise);
    __webpack_require__(84)(Promise, PromiseArray, tryConvertToPromise, INTERNAL, async, getDomain);
    Promise.Promise = Promise;
    Promise.version = "3.5.1";
    __webpack_require__(85)(Promise, PromiseArray, apiRejection, tryConvertToPromise, INTERNAL, debug);
    __webpack_require__(86)(Promise);
    __webpack_require__(87)(Promise, apiRejection, tryConvertToPromise, createContext, INTERNAL, debug);
    __webpack_require__(88)(Promise, INTERNAL, debug);
    __webpack_require__(89)(Promise, apiRejection, INTERNAL, tryConvertToPromise, Proxyable, debug);
    __webpack_require__(90)(Promise);
    __webpack_require__(91)(Promise, INTERNAL);
    __webpack_require__(92)(Promise, PromiseArray, tryConvertToPromise, apiRejection);
    __webpack_require__(93)(Promise, INTERNAL, tryConvertToPromise, apiRejection);
    __webpack_require__(94)(Promise, PromiseArray, apiRejection, tryConvertToPromise, INTERNAL, debug);
    __webpack_require__(95)(Promise, PromiseArray, debug);
    __webpack_require__(96)(Promise, PromiseArray, apiRejection);
    __webpack_require__(97)(Promise, INTERNAL);
    __webpack_require__(98)(Promise, INTERNAL);
    __webpack_require__(99)(Promise);

    util.toFastProperties(Promise);
    util.toFastProperties(Promise.prototype);
    function fillTypes(value) {
        var p = new Promise(INTERNAL);
        p._fulfillmentHandler0 = value;
        p._rejectionHandler0 = value;
        p._promise0 = value;
        p._receiver0 = value;
    }
    // Complete slack tracking, opt out of field-type tracking and           
    // stabilize map                                                         
    fillTypes({ a: 1 });
    fillTypes({ b: 2 });
    fillTypes({ c: 3 });
    fillTypes(1);
    fillTypes(function () {});
    fillTypes(undefined);
    fillTypes(false);
    fillTypes(new Promise(INTERNAL));
    debug.setBounds(Async.firstLineError, util.lastLineError);
    return Promise;
};

/***/ }),
/* 71 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var firstLineError;
try {
    throw new Error();
} catch (e) {
    firstLineError = e;
}
var schedule = __webpack_require__(72);
var Queue = __webpack_require__(73);
var util = __webpack_require__(1);

function Async() {
    this._customScheduler = false;
    this._isTickUsed = false;
    this._lateQueue = new Queue(16);
    this._normalQueue = new Queue(16);
    this._haveDrainedQueues = false;
    this._trampolineEnabled = true;
    var self = this;
    this.drainQueues = function () {
        self._drainQueues();
    };
    this._schedule = schedule;
}

Async.prototype.setScheduler = function (fn) {
    var prev = this._schedule;
    this._schedule = fn;
    this._customScheduler = true;
    return prev;
};

Async.prototype.hasCustomScheduler = function () {
    return this._customScheduler;
};

Async.prototype.enableTrampoline = function () {
    this._trampolineEnabled = true;
};

Async.prototype.disableTrampolineIfNecessary = function () {
    if (util.hasDevTools) {
        this._trampolineEnabled = false;
    }
};

Async.prototype.haveItemsQueued = function () {
    return this._isTickUsed || this._haveDrainedQueues;
};

Async.prototype.fatalError = function (e, isNode) {
    if (isNode) {
        process.stderr.write("Fatal " + (e instanceof Error ? e.stack : e) + "\n");
        process.exit(2);
    } else {
        this.throwLater(e);
    }
};

Async.prototype.throwLater = function (fn, arg) {
    if (arguments.length === 1) {
        arg = fn;
        fn = function () {
            throw arg;
        };
    }
    if (typeof setTimeout !== "undefined") {
        setTimeout(function () {
            fn(arg);
        }, 0);
    } else try {
        this._schedule(function () {
            fn(arg);
        });
    } catch (e) {
        throw new Error("No async scheduler available\u000a\u000a    See http://goo.gl/MqrFmX\u000a");
    }
};

function AsyncInvokeLater(fn, receiver, arg) {
    this._lateQueue.push(fn, receiver, arg);
    this._queueTick();
}

function AsyncInvoke(fn, receiver, arg) {
    this._normalQueue.push(fn, receiver, arg);
    this._queueTick();
}

function AsyncSettlePromises(promise) {
    this._normalQueue._pushOne(promise);
    this._queueTick();
}

if (!util.hasDevTools) {
    Async.prototype.invokeLater = AsyncInvokeLater;
    Async.prototype.invoke = AsyncInvoke;
    Async.prototype.settlePromises = AsyncSettlePromises;
} else {
    Async.prototype.invokeLater = function (fn, receiver, arg) {
        if (this._trampolineEnabled) {
            AsyncInvokeLater.call(this, fn, receiver, arg);
        } else {
            this._schedule(function () {
                setTimeout(function () {
                    fn.call(receiver, arg);
                }, 100);
            });
        }
    };

    Async.prototype.invoke = function (fn, receiver, arg) {
        if (this._trampolineEnabled) {
            AsyncInvoke.call(this, fn, receiver, arg);
        } else {
            this._schedule(function () {
                fn.call(receiver, arg);
            });
        }
    };

    Async.prototype.settlePromises = function (promise) {
        if (this._trampolineEnabled) {
            AsyncSettlePromises.call(this, promise);
        } else {
            this._schedule(function () {
                promise._settlePromises();
            });
        }
    };
}

Async.prototype._drainQueue = function (queue) {
    while (queue.length() > 0) {
        var fn = queue.shift();
        if (typeof fn !== "function") {
            fn._settlePromises();
            continue;
        }
        var receiver = queue.shift();
        var arg = queue.shift();
        fn.call(receiver, arg);
    }
};

Async.prototype._drainQueues = function () {
    this._drainQueue(this._normalQueue);
    this._reset();
    this._haveDrainedQueues = true;
    this._drainQueue(this._lateQueue);
};

Async.prototype._queueTick = function () {
    if (!this._isTickUsed) {
        this._isTickUsed = true;
        this._schedule(this.drainQueues);
    }
};

Async.prototype._reset = function () {
    this._isTickUsed = false;
};

module.exports = Async;
module.exports.firstLineError = firstLineError;

/***/ }),
/* 72 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var util = __webpack_require__(1);
var schedule;
var noAsyncScheduler = function () {
    throw new Error("No async scheduler available\u000a\u000a    See http://goo.gl/MqrFmX\u000a");
};
var NativePromise = util.getNativePromise();
if (util.isNode && typeof MutationObserver === "undefined") {
    var GlobalSetImmediate = global.setImmediate;
    var ProcessNextTick = process.nextTick;
    schedule = util.isRecentNode ? function (fn) {
        GlobalSetImmediate.call(global, fn);
    } : function (fn) {
        ProcessNextTick.call(process, fn);
    };
} else if (typeof NativePromise === "function" && typeof NativePromise.resolve === "function") {
    var nativePromise = NativePromise.resolve();
    schedule = function (fn) {
        nativePromise.then(fn);
    };
} else if (typeof MutationObserver !== "undefined" && !(typeof window !== "undefined" && window.navigator && (window.navigator.standalone || window.cordova))) {
    schedule = function () {
        var div = document.createElement("div");
        var opts = { attributes: true };
        var toggleScheduled = false;
        var div2 = document.createElement("div");
        var o2 = new MutationObserver(function () {
            div.classList.toggle("foo");
            toggleScheduled = false;
        });
        o2.observe(div2, opts);

        var scheduleToggle = function () {
            if (toggleScheduled) return;
            toggleScheduled = true;
            div2.classList.toggle("foo");
        };

        return function schedule(fn) {
            var o = new MutationObserver(function () {
                o.disconnect();
                fn();
            });
            o.observe(div, opts);
            scheduleToggle();
        };
    }();
} else if (typeof setImmediate !== "undefined") {
    schedule = function (fn) {
        setImmediate(fn);
    };
} else if (typeof setTimeout !== "undefined") {
    schedule = function (fn) {
        setTimeout(fn, 0);
    };
} else {
    schedule = noAsyncScheduler;
}
module.exports = schedule;

/***/ }),
/* 73 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


function arrayMove(src, srcIndex, dst, dstIndex, len) {
    for (var j = 0; j < len; ++j) {
        dst[j + dstIndex] = src[j + srcIndex];
        src[j + srcIndex] = void 0;
    }
}

function Queue(capacity) {
    this._capacity = capacity;
    this._length = 0;
    this._front = 0;
}

Queue.prototype._willBeOverCapacity = function (size) {
    return this._capacity < size;
};

Queue.prototype._pushOne = function (arg) {
    var length = this.length();
    this._checkCapacity(length + 1);
    var i = this._front + length & this._capacity - 1;
    this[i] = arg;
    this._length = length + 1;
};

Queue.prototype.push = function (fn, receiver, arg) {
    var length = this.length() + 3;
    if (this._willBeOverCapacity(length)) {
        this._pushOne(fn);
        this._pushOne(receiver);
        this._pushOne(arg);
        return;
    }
    var j = this._front + length - 3;
    this._checkCapacity(length);
    var wrapMask = this._capacity - 1;
    this[j + 0 & wrapMask] = fn;
    this[j + 1 & wrapMask] = receiver;
    this[j + 2 & wrapMask] = arg;
    this._length = length;
};

Queue.prototype.shift = function () {
    var front = this._front,
        ret = this[front];

    this[front] = undefined;
    this._front = front + 1 & this._capacity - 1;
    this._length--;
    return ret;
};

Queue.prototype.length = function () {
    return this._length;
};

Queue.prototype._checkCapacity = function (size) {
    if (this._capacity < size) {
        this._resizeTo(this._capacity << 1);
    }
};

Queue.prototype._resizeTo = function (capacity) {
    var oldCapacity = this._capacity;
    this._capacity = capacity;
    var front = this._front;
    var length = this._length;
    var moveItemsCount = front + length & oldCapacity - 1;
    arrayMove(this, 0, this, oldCapacity, moveItemsCount);
};

module.exports = Queue;

/***/ }),
/* 74 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = function (Promise, INTERNAL) {
    var util = __webpack_require__(1);
    var errorObj = util.errorObj;
    var isObject = util.isObject;

    function tryConvertToPromise(obj, context) {
        if (isObject(obj)) {
            if (obj instanceof Promise) return obj;
            var then = getThen(obj);
            if (then === errorObj) {
                if (context) context._pushContext();
                var ret = Promise.reject(then.e);
                if (context) context._popContext();
                return ret;
            } else if (typeof then === "function") {
                if (isAnyBluebirdPromise(obj)) {
                    var ret = new Promise(INTERNAL);
                    obj._then(ret._fulfill, ret._reject, undefined, ret, null);
                    return ret;
                }
                return doThenable(obj, then, context);
            }
        }
        return obj;
    }

    function doGetThen(obj) {
        return obj.then;
    }

    function getThen(obj) {
        try {
            return doGetThen(obj);
        } catch (e) {
            errorObj.e = e;
            return errorObj;
        }
    }

    var hasProp = {}.hasOwnProperty;
    function isAnyBluebirdPromise(obj) {
        try {
            return hasProp.call(obj, "_promise0");
        } catch (e) {
            return false;
        }
    }

    function doThenable(x, then, context) {
        var promise = new Promise(INTERNAL);
        var ret = promise;
        if (context) context._pushContext();
        promise._captureStackTrace();
        if (context) context._popContext();
        var synchronous = true;
        var result = util.tryCatch(then).call(x, resolve, reject);
        synchronous = false;

        if (promise && result === errorObj) {
            promise._rejectCallback(result.e, true, true);
            promise = null;
        }

        function resolve(value) {
            if (!promise) return;
            promise._resolveCallback(value);
            promise = null;
        }

        function reject(reason) {
            if (!promise) return;
            promise._rejectCallback(reason, synchronous, true);
            promise = null;
        }
        return ret;
    }

    return tryConvertToPromise;
};

/***/ }),
/* 75 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = function (Promise, INTERNAL, tryConvertToPromise, apiRejection, Proxyable) {
    var util = __webpack_require__(1);
    var isArray = util.isArray;

    function toResolutionValue(val) {
        switch (val) {
            case -2:
                return [];
            case -3:
                return {};
            case -6:
                return new Map();
        }
    }

    function PromiseArray(values) {
        var promise = this._promise = new Promise(INTERNAL);
        if (values instanceof Promise) {
            promise._propagateFrom(values, 3);
        }
        promise._setOnCancel(this);
        this._values = values;
        this._length = 0;
        this._totalResolved = 0;
        this._init(undefined, -2);
    }
    util.inherits(PromiseArray, Proxyable);

    PromiseArray.prototype.length = function () {
        return this._length;
    };

    PromiseArray.prototype.promise = function () {
        return this._promise;
    };

    PromiseArray.prototype._init = function init(_, resolveValueIfEmpty) {
        var values = tryConvertToPromise(this._values, this._promise);
        if (values instanceof Promise) {
            values = values._target();
            var bitField = values._bitField;
            ;
            this._values = values;

            if ((bitField & 50397184) === 0) {
                this._promise._setAsyncGuaranteed();
                return values._then(init, this._reject, undefined, this, resolveValueIfEmpty);
            } else if ((bitField & 33554432) !== 0) {
                values = values._value();
            } else if ((bitField & 16777216) !== 0) {
                return this._reject(values._reason());
            } else {
                return this._cancel();
            }
        }
        values = util.asArray(values);
        if (values === null) {
            var err = apiRejection("expecting an array or an iterable object but got " + util.classString(values)).reason();
            this._promise._rejectCallback(err, false);
            return;
        }

        if (values.length === 0) {
            if (resolveValueIfEmpty === -5) {
                this._resolveEmptyArray();
            } else {
                this._resolve(toResolutionValue(resolveValueIfEmpty));
            }
            return;
        }
        this._iterate(values);
    };

    PromiseArray.prototype._iterate = function (values) {
        var len = this.getActualLength(values.length);
        this._length = len;
        this._values = this.shouldCopyValues() ? new Array(len) : this._values;
        var result = this._promise;
        var isResolved = false;
        var bitField = null;
        for (var i = 0; i < len; ++i) {
            var maybePromise = tryConvertToPromise(values[i], result);

            if (maybePromise instanceof Promise) {
                maybePromise = maybePromise._target();
                bitField = maybePromise._bitField;
            } else {
                bitField = null;
            }

            if (isResolved) {
                if (bitField !== null) {
                    maybePromise.suppressUnhandledRejections();
                }
            } else if (bitField !== null) {
                if ((bitField & 50397184) === 0) {
                    maybePromise._proxy(this, i);
                    this._values[i] = maybePromise;
                } else if ((bitField & 33554432) !== 0) {
                    isResolved = this._promiseFulfilled(maybePromise._value(), i);
                } else if ((bitField & 16777216) !== 0) {
                    isResolved = this._promiseRejected(maybePromise._reason(), i);
                } else {
                    isResolved = this._promiseCancelled(i);
                }
            } else {
                isResolved = this._promiseFulfilled(maybePromise, i);
            }
        }
        if (!isResolved) result._setAsyncGuaranteed();
    };

    PromiseArray.prototype._isResolved = function () {
        return this._values === null;
    };

    PromiseArray.prototype._resolve = function (value) {
        this._values = null;
        this._promise._fulfill(value);
    };

    PromiseArray.prototype._cancel = function () {
        if (this._isResolved() || !this._promise._isCancellable()) return;
        this._values = null;
        this._promise._cancel();
    };

    PromiseArray.prototype._reject = function (reason) {
        this._values = null;
        this._promise._rejectCallback(reason, false);
    };

    PromiseArray.prototype._promiseFulfilled = function (value, index) {
        this._values[index] = value;
        var totalResolved = ++this._totalResolved;
        if (totalResolved >= this._length) {
            this._resolve(this._values);
            return true;
        }
        return false;
    };

    PromiseArray.prototype._promiseCancelled = function () {
        this._cancel();
        return true;
    };

    PromiseArray.prototype._promiseRejected = function (reason) {
        this._totalResolved++;
        this._reject(reason);
        return true;
    };

    PromiseArray.prototype._resultCancelled = function () {
        if (this._isResolved()) return;
        var values = this._values;
        this._cancel();
        if (values instanceof Promise) {
            values.cancel();
        } else {
            for (var i = 0; i < values.length; ++i) {
                if (values[i] instanceof Promise) {
                    values[i].cancel();
                }
            }
        }
    };

    PromiseArray.prototype.shouldCopyValues = function () {
        return true;
    };

    PromiseArray.prototype.getActualLength = function (len) {
        return len;
    };

    return PromiseArray;
};

/***/ }),
/* 76 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = function (Promise) {
    var longStackTraces = false;
    var contextStack = [];

    Promise.prototype._promiseCreated = function () {};
    Promise.prototype._pushContext = function () {};
    Promise.prototype._popContext = function () {
        return null;
    };
    Promise._peekContext = Promise.prototype._peekContext = function () {};

    function Context() {
        this._trace = new Context.CapturedTrace(peekContext());
    }
    Context.prototype._pushContext = function () {
        if (this._trace !== undefined) {
            this._trace._promiseCreated = null;
            contextStack.push(this._trace);
        }
    };

    Context.prototype._popContext = function () {
        if (this._trace !== undefined) {
            var trace = contextStack.pop();
            var ret = trace._promiseCreated;
            trace._promiseCreated = null;
            return ret;
        }
        return null;
    };

    function createContext() {
        if (longStackTraces) return new Context();
    }

    function peekContext() {
        var lastIndex = contextStack.length - 1;
        if (lastIndex >= 0) {
            return contextStack[lastIndex];
        }
        return undefined;
    }
    Context.CapturedTrace = null;
    Context.create = createContext;
    Context.deactivateLongStackTraces = function () {};
    Context.activateLongStackTraces = function () {
        var Promise_pushContext = Promise.prototype._pushContext;
        var Promise_popContext = Promise.prototype._popContext;
        var Promise_PeekContext = Promise._peekContext;
        var Promise_peekContext = Promise.prototype._peekContext;
        var Promise_promiseCreated = Promise.prototype._promiseCreated;
        Context.deactivateLongStackTraces = function () {
            Promise.prototype._pushContext = Promise_pushContext;
            Promise.prototype._popContext = Promise_popContext;
            Promise._peekContext = Promise_PeekContext;
            Promise.prototype._peekContext = Promise_peekContext;
            Promise.prototype._promiseCreated = Promise_promiseCreated;
            longStackTraces = false;
        };
        longStackTraces = true;
        Promise.prototype._pushContext = Context.prototype._pushContext;
        Promise.prototype._popContext = Context.prototype._popContext;
        Promise._peekContext = Promise.prototype._peekContext = peekContext;
        Promise.prototype._promiseCreated = function () {
            var ctx = this._peekContext();
            if (ctx && ctx._promiseCreated == null) ctx._promiseCreated = this;
        };
    };
    return Context;
};

/***/ }),
/* 77 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = function (Promise, Context) {
    var getDomain = Promise._getDomain;
    var async = Promise._async;
    var Warning = __webpack_require__(11).Warning;
    var util = __webpack_require__(1);
    var canAttachTrace = util.canAttachTrace;
    var unhandledRejectionHandled;
    var possiblyUnhandledRejection;
    var bluebirdFramePattern = /[\\\/]bluebird[\\\/]js[\\\/](release|debug|instrumented)/;
    var nodeFramePattern = /\((?:timers\.js):\d+:\d+\)/;
    var parseLinePattern = /[\/<\(](.+?):(\d+):(\d+)\)?\s*$/;
    var stackFramePattern = null;
    var formatStack = null;
    var indentStackFrames = false;
    var printWarning;
    var debugging = !!(util.env("BLUEBIRD_DEBUG") != 0 && (false || util.env("BLUEBIRD_DEBUG") || util.env("NODE_ENV") === "development"));

    var warnings = !!(util.env("BLUEBIRD_WARNINGS") != 0 && (debugging || util.env("BLUEBIRD_WARNINGS")));

    var longStackTraces = !!(util.env("BLUEBIRD_LONG_STACK_TRACES") != 0 && (debugging || util.env("BLUEBIRD_LONG_STACK_TRACES")));

    var wForgottenReturn = util.env("BLUEBIRD_W_FORGOTTEN_RETURN") != 0 && (warnings || !!util.env("BLUEBIRD_W_FORGOTTEN_RETURN"));

    Promise.prototype.suppressUnhandledRejections = function () {
        var target = this._target();
        target._bitField = target._bitField & ~1048576 | 524288;
    };

    Promise.prototype._ensurePossibleRejectionHandled = function () {
        if ((this._bitField & 524288) !== 0) return;
        this._setRejectionIsUnhandled();
        var self = this;
        setTimeout(function () {
            self._notifyUnhandledRejection();
        }, 1);
    };

    Promise.prototype._notifyUnhandledRejectionIsHandled = function () {
        fireRejectionEvent("rejectionHandled", unhandledRejectionHandled, undefined, this);
    };

    Promise.prototype._setReturnedNonUndefined = function () {
        this._bitField = this._bitField | 268435456;
    };

    Promise.prototype._returnedNonUndefined = function () {
        return (this._bitField & 268435456) !== 0;
    };

    Promise.prototype._notifyUnhandledRejection = function () {
        if (this._isRejectionUnhandled()) {
            var reason = this._settledValue();
            this._setUnhandledRejectionIsNotified();
            fireRejectionEvent("unhandledRejection", possiblyUnhandledRejection, reason, this);
        }
    };

    Promise.prototype._setUnhandledRejectionIsNotified = function () {
        this._bitField = this._bitField | 262144;
    };

    Promise.prototype._unsetUnhandledRejectionIsNotified = function () {
        this._bitField = this._bitField & ~262144;
    };

    Promise.prototype._isUnhandledRejectionNotified = function () {
        return (this._bitField & 262144) > 0;
    };

    Promise.prototype._setRejectionIsUnhandled = function () {
        this._bitField = this._bitField | 1048576;
    };

    Promise.prototype._unsetRejectionIsUnhandled = function () {
        this._bitField = this._bitField & ~1048576;
        if (this._isUnhandledRejectionNotified()) {
            this._unsetUnhandledRejectionIsNotified();
            this._notifyUnhandledRejectionIsHandled();
        }
    };

    Promise.prototype._isRejectionUnhandled = function () {
        return (this._bitField & 1048576) > 0;
    };

    Promise.prototype._warn = function (message, shouldUseOwnTrace, promise) {
        return warn(message, shouldUseOwnTrace, promise || this);
    };

    Promise.onPossiblyUnhandledRejection = function (fn) {
        var domain = getDomain();
        possiblyUnhandledRejection = typeof fn === "function" ? domain === null ? fn : util.domainBind(domain, fn) : undefined;
    };

    Promise.onUnhandledRejectionHandled = function (fn) {
        var domain = getDomain();
        unhandledRejectionHandled = typeof fn === "function" ? domain === null ? fn : util.domainBind(domain, fn) : undefined;
    };

    var disableLongStackTraces = function () {};
    Promise.longStackTraces = function () {
        if (async.haveItemsQueued() && !config.longStackTraces) {
            throw new Error("cannot enable long stack traces after promises have been created\u000a\u000a    See http://goo.gl/MqrFmX\u000a");
        }
        if (!config.longStackTraces && longStackTracesIsSupported()) {
            var Promise_captureStackTrace = Promise.prototype._captureStackTrace;
            var Promise_attachExtraTrace = Promise.prototype._attachExtraTrace;
            config.longStackTraces = true;
            disableLongStackTraces = function () {
                if (async.haveItemsQueued() && !config.longStackTraces) {
                    throw new Error("cannot enable long stack traces after promises have been created\u000a\u000a    See http://goo.gl/MqrFmX\u000a");
                }
                Promise.prototype._captureStackTrace = Promise_captureStackTrace;
                Promise.prototype._attachExtraTrace = Promise_attachExtraTrace;
                Context.deactivateLongStackTraces();
                async.enableTrampoline();
                config.longStackTraces = false;
            };
            Promise.prototype._captureStackTrace = longStackTracesCaptureStackTrace;
            Promise.prototype._attachExtraTrace = longStackTracesAttachExtraTrace;
            Context.activateLongStackTraces();
            async.disableTrampolineIfNecessary();
        }
    };

    Promise.hasLongStackTraces = function () {
        return config.longStackTraces && longStackTracesIsSupported();
    };

    var fireDomEvent = function () {
        try {
            if (typeof CustomEvent === "function") {
                var event = new CustomEvent("CustomEvent");
                util.global.dispatchEvent(event);
                return function (name, event) {
                    var domEvent = new CustomEvent(name.toLowerCase(), {
                        detail: event,
                        cancelable: true
                    });
                    return !util.global.dispatchEvent(domEvent);
                };
            } else if (typeof Event === "function") {
                var event = new Event("CustomEvent");
                util.global.dispatchEvent(event);
                return function (name, event) {
                    var domEvent = new Event(name.toLowerCase(), {
                        cancelable: true
                    });
                    domEvent.detail = event;
                    return !util.global.dispatchEvent(domEvent);
                };
            } else {
                var event = document.createEvent("CustomEvent");
                event.initCustomEvent("testingtheevent", false, true, {});
                util.global.dispatchEvent(event);
                return function (name, event) {
                    var domEvent = document.createEvent("CustomEvent");
                    domEvent.initCustomEvent(name.toLowerCase(), false, true, event);
                    return !util.global.dispatchEvent(domEvent);
                };
            }
        } catch (e) {}
        return function () {
            return false;
        };
    }();

    var fireGlobalEvent = function () {
        if (util.isNode) {
            return function () {
                return process.emit.apply(process, arguments);
            };
        } else {
            if (!util.global) {
                return function () {
                    return false;
                };
            }
            return function (name) {
                var methodName = "on" + name.toLowerCase();
                var method = util.global[methodName];
                if (!method) return false;
                method.apply(util.global, [].slice.call(arguments, 1));
                return true;
            };
        }
    }();

    function generatePromiseLifecycleEventObject(name, promise) {
        return { promise: promise };
    }

    var eventToObjectGenerator = {
        promiseCreated: generatePromiseLifecycleEventObject,
        promiseFulfilled: generatePromiseLifecycleEventObject,
        promiseRejected: generatePromiseLifecycleEventObject,
        promiseResolved: generatePromiseLifecycleEventObject,
        promiseCancelled: generatePromiseLifecycleEventObject,
        promiseChained: function (name, promise, child) {
            return { promise: promise, child: child };
        },
        warning: function (name, warning) {
            return { warning: warning };
        },
        unhandledRejection: function (name, reason, promise) {
            return { reason: reason, promise: promise };
        },
        rejectionHandled: generatePromiseLifecycleEventObject
    };

    var activeFireEvent = function (name) {
        var globalEventFired = false;
        try {
            globalEventFired = fireGlobalEvent.apply(null, arguments);
        } catch (e) {
            async.throwLater(e);
            globalEventFired = true;
        }

        var domEventFired = false;
        try {
            domEventFired = fireDomEvent(name, eventToObjectGenerator[name].apply(null, arguments));
        } catch (e) {
            async.throwLater(e);
            domEventFired = true;
        }

        return domEventFired || globalEventFired;
    };

    Promise.config = function (opts) {
        opts = Object(opts);
        if ("longStackTraces" in opts) {
            if (opts.longStackTraces) {
                Promise.longStackTraces();
            } else if (!opts.longStackTraces && Promise.hasLongStackTraces()) {
                disableLongStackTraces();
            }
        }
        if ("warnings" in opts) {
            var warningsOption = opts.warnings;
            config.warnings = !!warningsOption;
            wForgottenReturn = config.warnings;

            if (util.isObject(warningsOption)) {
                if ("wForgottenReturn" in warningsOption) {
                    wForgottenReturn = !!warningsOption.wForgottenReturn;
                }
            }
        }
        if ("cancellation" in opts && opts.cancellation && !config.cancellation) {
            if (async.haveItemsQueued()) {
                throw new Error("cannot enable cancellation after promises are in use");
            }
            Promise.prototype._clearCancellationData = cancellationClearCancellationData;
            Promise.prototype._propagateFrom = cancellationPropagateFrom;
            Promise.prototype._onCancel = cancellationOnCancel;
            Promise.prototype._setOnCancel = cancellationSetOnCancel;
            Promise.prototype._attachCancellationCallback = cancellationAttachCancellationCallback;
            Promise.prototype._execute = cancellationExecute;
            propagateFromFunction = cancellationPropagateFrom;
            config.cancellation = true;
        }
        if ("monitoring" in opts) {
            if (opts.monitoring && !config.monitoring) {
                config.monitoring = true;
                Promise.prototype._fireEvent = activeFireEvent;
            } else if (!opts.monitoring && config.monitoring) {
                config.monitoring = false;
                Promise.prototype._fireEvent = defaultFireEvent;
            }
        }
        return Promise;
    };

    function defaultFireEvent() {
        return false;
    }

    Promise.prototype._fireEvent = defaultFireEvent;
    Promise.prototype._execute = function (executor, resolve, reject) {
        try {
            executor(resolve, reject);
        } catch (e) {
            return e;
        }
    };
    Promise.prototype._onCancel = function () {};
    Promise.prototype._setOnCancel = function (handler) {
        ;
    };
    Promise.prototype._attachCancellationCallback = function (onCancel) {
        ;
    };
    Promise.prototype._captureStackTrace = function () {};
    Promise.prototype._attachExtraTrace = function () {};
    Promise.prototype._clearCancellationData = function () {};
    Promise.prototype._propagateFrom = function (parent, flags) {
        ;
        ;
    };

    function cancellationExecute(executor, resolve, reject) {
        var promise = this;
        try {
            executor(resolve, reject, function (onCancel) {
                if (typeof onCancel !== "function") {
                    throw new TypeError("onCancel must be a function, got: " + util.toString(onCancel));
                }
                promise._attachCancellationCallback(onCancel);
            });
        } catch (e) {
            return e;
        }
    }

    function cancellationAttachCancellationCallback(onCancel) {
        if (!this._isCancellable()) return this;

        var previousOnCancel = this._onCancel();
        if (previousOnCancel !== undefined) {
            if (util.isArray(previousOnCancel)) {
                previousOnCancel.push(onCancel);
            } else {
                this._setOnCancel([previousOnCancel, onCancel]);
            }
        } else {
            this._setOnCancel(onCancel);
        }
    }

    function cancellationOnCancel() {
        return this._onCancelField;
    }

    function cancellationSetOnCancel(onCancel) {
        this._onCancelField = onCancel;
    }

    function cancellationClearCancellationData() {
        this._cancellationParent = undefined;
        this._onCancelField = undefined;
    }

    function cancellationPropagateFrom(parent, flags) {
        if ((flags & 1) !== 0) {
            this._cancellationParent = parent;
            var branchesRemainingToCancel = parent._branchesRemainingToCancel;
            if (branchesRemainingToCancel === undefined) {
                branchesRemainingToCancel = 0;
            }
            parent._branchesRemainingToCancel = branchesRemainingToCancel + 1;
        }
        if ((flags & 2) !== 0 && parent._isBound()) {
            this._setBoundTo(parent._boundTo);
        }
    }

    function bindingPropagateFrom(parent, flags) {
        if ((flags & 2) !== 0 && parent._isBound()) {
            this._setBoundTo(parent._boundTo);
        }
    }
    var propagateFromFunction = bindingPropagateFrom;

    function boundValueFunction() {
        var ret = this._boundTo;
        if (ret !== undefined) {
            if (ret instanceof Promise) {
                if (ret.isFulfilled()) {
                    return ret.value();
                } else {
                    return undefined;
                }
            }
        }
        return ret;
    }

    function longStackTracesCaptureStackTrace() {
        this._trace = new CapturedTrace(this._peekContext());
    }

    function longStackTracesAttachExtraTrace(error, ignoreSelf) {
        if (canAttachTrace(error)) {
            var trace = this._trace;
            if (trace !== undefined) {
                if (ignoreSelf) trace = trace._parent;
            }
            if (trace !== undefined) {
                trace.attachExtraTrace(error);
            } else if (!error.__stackCleaned__) {
                var parsed = parseStackAndMessage(error);
                util.notEnumerableProp(error, "stack", parsed.message + "\n" + parsed.stack.join("\n"));
                util.notEnumerableProp(error, "__stackCleaned__", true);
            }
        }
    }

    function checkForgottenReturns(returnValue, promiseCreated, name, promise, parent) {
        if (returnValue === undefined && promiseCreated !== null && wForgottenReturn) {
            if (parent !== undefined && parent._returnedNonUndefined()) return;
            if ((promise._bitField & 65535) === 0) return;

            if (name) name = name + " ";
            var handlerLine = "";
            var creatorLine = "";
            if (promiseCreated._trace) {
                var traceLines = promiseCreated._trace.stack.split("\n");
                var stack = cleanStack(traceLines);
                for (var i = stack.length - 1; i >= 0; --i) {
                    var line = stack[i];
                    if (!nodeFramePattern.test(line)) {
                        var lineMatches = line.match(parseLinePattern);
                        if (lineMatches) {
                            handlerLine = "at " + lineMatches[1] + ":" + lineMatches[2] + ":" + lineMatches[3] + " ";
                        }
                        break;
                    }
                }

                if (stack.length > 0) {
                    var firstUserLine = stack[0];
                    for (var i = 0; i < traceLines.length; ++i) {

                        if (traceLines[i] === firstUserLine) {
                            if (i > 0) {
                                creatorLine = "\n" + traceLines[i - 1];
                            }
                            break;
                        }
                    }
                }
            }
            var msg = "a promise was created in a " + name + "handler " + handlerLine + "but was not returned from it, " + "see http://goo.gl/rRqMUw" + creatorLine;
            promise._warn(msg, true, promiseCreated);
        }
    }

    function deprecated(name, replacement) {
        var message = name + " is deprecated and will be removed in a future version.";
        if (replacement) message += " Use " + replacement + " instead.";
        return warn(message);
    }

    function warn(message, shouldUseOwnTrace, promise) {
        if (!config.warnings) return;
        var warning = new Warning(message);
        var ctx;
        if (shouldUseOwnTrace) {
            promise._attachExtraTrace(warning);
        } else if (config.longStackTraces && (ctx = Promise._peekContext())) {
            ctx.attachExtraTrace(warning);
        } else {
            var parsed = parseStackAndMessage(warning);
            warning.stack = parsed.message + "\n" + parsed.stack.join("\n");
        }

        if (!activeFireEvent("warning", warning)) {
            formatAndLogError(warning, "", true);
        }
    }

    function reconstructStack(message, stacks) {
        for (var i = 0; i < stacks.length - 1; ++i) {
            stacks[i].push("From previous event:");
            stacks[i] = stacks[i].join("\n");
        }
        if (i < stacks.length) {
            stacks[i] = stacks[i].join("\n");
        }
        return message + "\n" + stacks.join("\n");
    }

    function removeDuplicateOrEmptyJumps(stacks) {
        for (var i = 0; i < stacks.length; ++i) {
            if (stacks[i].length === 0 || i + 1 < stacks.length && stacks[i][0] === stacks[i + 1][0]) {
                stacks.splice(i, 1);
                i--;
            }
        }
    }

    function removeCommonRoots(stacks) {
        var current = stacks[0];
        for (var i = 1; i < stacks.length; ++i) {
            var prev = stacks[i];
            var currentLastIndex = current.length - 1;
            var currentLastLine = current[currentLastIndex];
            var commonRootMeetPoint = -1;

            for (var j = prev.length - 1; j >= 0; --j) {
                if (prev[j] === currentLastLine) {
                    commonRootMeetPoint = j;
                    break;
                }
            }

            for (var j = commonRootMeetPoint; j >= 0; --j) {
                var line = prev[j];
                if (current[currentLastIndex] === line) {
                    current.pop();
                    currentLastIndex--;
                } else {
                    break;
                }
            }
            current = prev;
        }
    }

    function cleanStack(stack) {
        var ret = [];
        for (var i = 0; i < stack.length; ++i) {
            var line = stack[i];
            var isTraceLine = "    (No stack trace)" === line || stackFramePattern.test(line);
            var isInternalFrame = isTraceLine && shouldIgnore(line);
            if (isTraceLine && !isInternalFrame) {
                if (indentStackFrames && line.charAt(0) !== " ") {
                    line = "    " + line;
                }
                ret.push(line);
            }
        }
        return ret;
    }

    function stackFramesAsArray(error) {
        var stack = error.stack.replace(/\s+$/g, "").split("\n");
        for (var i = 0; i < stack.length; ++i) {
            var line = stack[i];
            if ("    (No stack trace)" === line || stackFramePattern.test(line)) {
                break;
            }
        }
        if (i > 0 && error.name != "SyntaxError") {
            stack = stack.slice(i);
        }
        return stack;
    }

    function parseStackAndMessage(error) {
        var stack = error.stack;
        var message = error.toString();
        stack = typeof stack === "string" && stack.length > 0 ? stackFramesAsArray(error) : ["    (No stack trace)"];
        return {
            message: message,
            stack: error.name == "SyntaxError" ? stack : cleanStack(stack)
        };
    }

    function formatAndLogError(error, title, isSoft) {
        if (typeof console !== "undefined") {
            var message;
            if (util.isObject(error)) {
                var stack = error.stack;
                message = title + formatStack(stack, error);
            } else {
                message = title + String(error);
            }
            if (typeof printWarning === "function") {
                printWarning(message, isSoft);
            } else if (typeof console.log === "function" || typeof console.log === "object") {
                console.log(message);
            }
        }
    }

    function fireRejectionEvent(name, localHandler, reason, promise) {
        var localEventFired = false;
        try {
            if (typeof localHandler === "function") {
                localEventFired = true;
                if (name === "rejectionHandled") {
                    localHandler(promise);
                } else {
                    localHandler(reason, promise);
                }
            }
        } catch (e) {
            async.throwLater(e);
        }

        if (name === "unhandledRejection") {
            if (!activeFireEvent(name, reason, promise) && !localEventFired) {
                formatAndLogError(reason, "Unhandled rejection ");
            }
        } else {
            activeFireEvent(name, promise);
        }
    }

    function formatNonError(obj) {
        var str;
        if (typeof obj === "function") {
            str = "[function " + (obj.name || "anonymous") + "]";
        } else {
            str = obj && typeof obj.toString === "function" ? obj.toString() : util.toString(obj);
            var ruselessToString = /\[object [a-zA-Z0-9$_]+\]/;
            if (ruselessToString.test(str)) {
                try {
                    var newStr = JSON.stringify(obj);
                    str = newStr;
                } catch (e) {}
            }
            if (str.length === 0) {
                str = "(empty array)";
            }
        }
        return "(<" + snip(str) + ">, no stack trace)";
    }

    function snip(str) {
        var maxChars = 41;
        if (str.length < maxChars) {
            return str;
        }
        return str.substr(0, maxChars - 3) + "...";
    }

    function longStackTracesIsSupported() {
        return typeof captureStackTrace === "function";
    }

    var shouldIgnore = function () {
        return false;
    };
    var parseLineInfoRegex = /[\/<\(]([^:\/]+):(\d+):(?:\d+)\)?\s*$/;
    function parseLineInfo(line) {
        var matches = line.match(parseLineInfoRegex);
        if (matches) {
            return {
                fileName: matches[1],
                line: parseInt(matches[2], 10)
            };
        }
    }

    function setBounds(firstLineError, lastLineError) {
        if (!longStackTracesIsSupported()) return;
        var firstStackLines = firstLineError.stack.split("\n");
        var lastStackLines = lastLineError.stack.split("\n");
        var firstIndex = -1;
        var lastIndex = -1;
        var firstFileName;
        var lastFileName;
        for (var i = 0; i < firstStackLines.length; ++i) {
            var result = parseLineInfo(firstStackLines[i]);
            if (result) {
                firstFileName = result.fileName;
                firstIndex = result.line;
                break;
            }
        }
        for (var i = 0; i < lastStackLines.length; ++i) {
            var result = parseLineInfo(lastStackLines[i]);
            if (result) {
                lastFileName = result.fileName;
                lastIndex = result.line;
                break;
            }
        }
        if (firstIndex < 0 || lastIndex < 0 || !firstFileName || !lastFileName || firstFileName !== lastFileName || firstIndex >= lastIndex) {
            return;
        }

        shouldIgnore = function (line) {
            if (bluebirdFramePattern.test(line)) return true;
            var info = parseLineInfo(line);
            if (info) {
                if (info.fileName === firstFileName && firstIndex <= info.line && info.line <= lastIndex) {
                    return true;
                }
            }
            return false;
        };
    }

    function CapturedTrace(parent) {
        this._parent = parent;
        this._promisesCreated = 0;
        var length = this._length = 1 + (parent === undefined ? 0 : parent._length);
        captureStackTrace(this, CapturedTrace);
        if (length > 32) this.uncycle();
    }
    util.inherits(CapturedTrace, Error);
    Context.CapturedTrace = CapturedTrace;

    CapturedTrace.prototype.uncycle = function () {
        var length = this._length;
        if (length < 2) return;
        var nodes = [];
        var stackToIndex = {};

        for (var i = 0, node = this; node !== undefined; ++i) {
            nodes.push(node);
            node = node._parent;
        }
        length = this._length = i;
        for (var i = length - 1; i >= 0; --i) {
            var stack = nodes[i].stack;
            if (stackToIndex[stack] === undefined) {
                stackToIndex[stack] = i;
            }
        }
        for (var i = 0; i < length; ++i) {
            var currentStack = nodes[i].stack;
            var index = stackToIndex[currentStack];
            if (index !== undefined && index !== i) {
                if (index > 0) {
                    nodes[index - 1]._parent = undefined;
                    nodes[index - 1]._length = 1;
                }
                nodes[i]._parent = undefined;
                nodes[i]._length = 1;
                var cycleEdgeNode = i > 0 ? nodes[i - 1] : this;

                if (index < length - 1) {
                    cycleEdgeNode._parent = nodes[index + 1];
                    cycleEdgeNode._parent.uncycle();
                    cycleEdgeNode._length = cycleEdgeNode._parent._length + 1;
                } else {
                    cycleEdgeNode._parent = undefined;
                    cycleEdgeNode._length = 1;
                }
                var currentChildLength = cycleEdgeNode._length + 1;
                for (var j = i - 2; j >= 0; --j) {
                    nodes[j]._length = currentChildLength;
                    currentChildLength++;
                }
                return;
            }
        }
    };

    CapturedTrace.prototype.attachExtraTrace = function (error) {
        if (error.__stackCleaned__) return;
        this.uncycle();
        var parsed = parseStackAndMessage(error);
        var message = parsed.message;
        var stacks = [parsed.stack];

        var trace = this;
        while (trace !== undefined) {
            stacks.push(cleanStack(trace.stack.split("\n")));
            trace = trace._parent;
        }
        removeCommonRoots(stacks);
        removeDuplicateOrEmptyJumps(stacks);
        util.notEnumerableProp(error, "stack", reconstructStack(message, stacks));
        util.notEnumerableProp(error, "__stackCleaned__", true);
    };

    var captureStackTrace = function stackDetection() {
        var v8stackFramePattern = /^\s*at\s*/;
        var v8stackFormatter = function (stack, error) {
            if (typeof stack === "string") return stack;

            if (error.name !== undefined && error.message !== undefined) {
                return error.toString();
            }
            return formatNonError(error);
        };

        if (typeof Error.stackTraceLimit === "number" && typeof Error.captureStackTrace === "function") {
            Error.stackTraceLimit += 6;
            stackFramePattern = v8stackFramePattern;
            formatStack = v8stackFormatter;
            var captureStackTrace = Error.captureStackTrace;

            shouldIgnore = function (line) {
                return bluebirdFramePattern.test(line);
            };
            return function (receiver, ignoreUntil) {
                Error.stackTraceLimit += 6;
                captureStackTrace(receiver, ignoreUntil);
                Error.stackTraceLimit -= 6;
            };
        }
        var err = new Error();

        if (typeof err.stack === "string" && err.stack.split("\n")[0].indexOf("stackDetection@") >= 0) {
            stackFramePattern = /@/;
            formatStack = v8stackFormatter;
            indentStackFrames = true;
            return function captureStackTrace(o) {
                o.stack = new Error().stack;
            };
        }

        var hasStackAfterThrow;
        try {
            throw new Error();
        } catch (e) {
            hasStackAfterThrow = "stack" in e;
        }
        if (!("stack" in err) && hasStackAfterThrow && typeof Error.stackTraceLimit === "number") {
            stackFramePattern = v8stackFramePattern;
            formatStack = v8stackFormatter;
            return function captureStackTrace(o) {
                Error.stackTraceLimit += 6;
                try {
                    throw new Error();
                } catch (e) {
                    o.stack = e.stack;
                }
                Error.stackTraceLimit -= 6;
            };
        }

        formatStack = function (stack, error) {
            if (typeof stack === "string") return stack;

            if ((typeof error === "object" || typeof error === "function") && error.name !== undefined && error.message !== undefined) {
                return error.toString();
            }
            return formatNonError(error);
        };

        return null;
    }([]);

    if (typeof console !== "undefined" && typeof console.warn !== "undefined") {
        printWarning = function (message) {
            console.warn(message);
        };
        if (util.isNode && process.stderr.isTTY) {
            printWarning = function (message, isSoft) {
                var color = isSoft ? "\u001b[33m" : "\u001b[31m";
                console.warn(color + message + "\u001b[0m\n");
            };
        } else if (!util.isNode && typeof new Error().stack === "string") {
            printWarning = function (message, isSoft) {
                console.warn("%c" + message, isSoft ? "color: darkorange" : "color: red");
            };
        }
    }

    var config = {
        warnings: warnings,
        longStackTraces: false,
        cancellation: false,
        monitoring: false
    };

    if (longStackTraces) Promise.longStackTraces();

    return {
        longStackTraces: function () {
            return config.longStackTraces;
        },
        warnings: function () {
            return config.warnings;
        },
        cancellation: function () {
            return config.cancellation;
        },
        monitoring: function () {
            return config.monitoring;
        },
        propagateFromFunction: function () {
            return propagateFromFunction;
        },
        boundValueFunction: function () {
            return boundValueFunction;
        },
        checkForgottenReturns: checkForgottenReturns,
        setBounds: setBounds,
        warn: warn,
        deprecated: deprecated,
        CapturedTrace: CapturedTrace,
        fireDomEvent: fireDomEvent,
        fireGlobalEvent: fireGlobalEvent
    };
};

/***/ }),
/* 78 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = function (Promise, tryConvertToPromise, NEXT_FILTER) {
    var util = __webpack_require__(1);
    var CancellationError = Promise.CancellationError;
    var errorObj = util.errorObj;
    var catchFilter = __webpack_require__(38)(NEXT_FILTER);

    function PassThroughHandlerContext(promise, type, handler) {
        this.promise = promise;
        this.type = type;
        this.handler = handler;
        this.called = false;
        this.cancelPromise = null;
    }

    PassThroughHandlerContext.prototype.isFinallyHandler = function () {
        return this.type === 0;
    };

    function FinallyHandlerCancelReaction(finallyHandler) {
        this.finallyHandler = finallyHandler;
    }

    FinallyHandlerCancelReaction.prototype._resultCancelled = function () {
        checkCancel(this.finallyHandler);
    };

    function checkCancel(ctx, reason) {
        if (ctx.cancelPromise != null) {
            if (arguments.length > 1) {
                ctx.cancelPromise._reject(reason);
            } else {
                ctx.cancelPromise._cancel();
            }
            ctx.cancelPromise = null;
            return true;
        }
        return false;
    }

    function succeed() {
        return finallyHandler.call(this, this.promise._target()._settledValue());
    }
    function fail(reason) {
        if (checkCancel(this, reason)) return;
        errorObj.e = reason;
        return errorObj;
    }
    function finallyHandler(reasonOrValue) {
        var promise = this.promise;
        var handler = this.handler;

        if (!this.called) {
            this.called = true;
            var ret = this.isFinallyHandler() ? handler.call(promise._boundValue()) : handler.call(promise._boundValue(), reasonOrValue);
            if (ret === NEXT_FILTER) {
                return ret;
            } else if (ret !== undefined) {
                promise._setReturnedNonUndefined();
                var maybePromise = tryConvertToPromise(ret, promise);
                if (maybePromise instanceof Promise) {
                    if (this.cancelPromise != null) {
                        if (maybePromise._isCancelled()) {
                            var reason = new CancellationError("late cancellation observer");
                            promise._attachExtraTrace(reason);
                            errorObj.e = reason;
                            return errorObj;
                        } else if (maybePromise.isPending()) {
                            maybePromise._attachCancellationCallback(new FinallyHandlerCancelReaction(this));
                        }
                    }
                    return maybePromise._then(succeed, fail, undefined, this, undefined);
                }
            }
        }

        if (promise.isRejected()) {
            checkCancel(this);
            errorObj.e = reasonOrValue;
            return errorObj;
        } else {
            checkCancel(this);
            return reasonOrValue;
        }
    }

    Promise.prototype._passThrough = function (handler, type, success, fail) {
        if (typeof handler !== "function") return this.then();
        return this._then(success, fail, undefined, new PassThroughHandlerContext(this, type, handler), undefined);
    };

    Promise.prototype.lastly = Promise.prototype["finally"] = function (handler) {
        return this._passThrough(handler, 0, finallyHandler, finallyHandler);
    };

    Promise.prototype.tap = function (handler) {
        return this._passThrough(handler, 1, finallyHandler);
    };

    Promise.prototype.tapCatch = function (handlerOrPredicate) {
        var len = arguments.length;
        if (len === 1) {
            return this._passThrough(handlerOrPredicate, 1, undefined, finallyHandler);
        } else {
            var catchInstances = new Array(len - 1),
                j = 0,
                i;
            for (i = 0; i < len - 1; ++i) {
                var item = arguments[i];
                if (util.isObject(item)) {
                    catchInstances[j++] = item;
                } else {
                    return Promise.reject(new TypeError("tapCatch statement predicate: " + "expecting an object but got " + util.classString(item)));
                }
            }
            catchInstances.length = j;
            var handler = arguments[i];
            return this._passThrough(catchFilter(catchInstances, handler, this), 1, undefined, finallyHandler);
        }
    };

    return PassThroughHandlerContext;
};

/***/ }),
/* 79 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = function (Promise, INTERNAL, tryConvertToPromise, apiRejection, debug) {
    var util = __webpack_require__(1);
    var tryCatch = util.tryCatch;

    Promise.method = function (fn) {
        if (typeof fn !== "function") {
            throw new Promise.TypeError("expecting a function but got " + util.classString(fn));
        }
        return function () {
            var ret = new Promise(INTERNAL);
            ret._captureStackTrace();
            ret._pushContext();
            var value = tryCatch(fn).apply(this, arguments);
            var promiseCreated = ret._popContext();
            debug.checkForgottenReturns(value, promiseCreated, "Promise.method", ret);
            ret._resolveFromSyncValue(value);
            return ret;
        };
    };

    Promise.attempt = Promise["try"] = function (fn) {
        if (typeof fn !== "function") {
            return apiRejection("expecting a function but got " + util.classString(fn));
        }
        var ret = new Promise(INTERNAL);
        ret._captureStackTrace();
        ret._pushContext();
        var value;
        if (arguments.length > 1) {
            debug.deprecated("calling Promise.try with more than 1 argument");
            var arg = arguments[1];
            var ctx = arguments[2];
            value = util.isArray(arg) ? tryCatch(fn).apply(ctx, arg) : tryCatch(fn).call(ctx, arg);
        } else {
            value = tryCatch(fn)();
        }
        var promiseCreated = ret._popContext();
        debug.checkForgottenReturns(value, promiseCreated, "Promise.try", ret);
        ret._resolveFromSyncValue(value);
        return ret;
    };

    Promise.prototype._resolveFromSyncValue = function (value) {
        if (value === util.errorObj) {
            this._rejectCallback(value.e, false);
        } else {
            this._resolveCallback(value, true);
        }
    };
};

/***/ }),
/* 80 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = function (Promise, INTERNAL, tryConvertToPromise, debug) {
    var calledBind = false;
    var rejectThis = function (_, e) {
        this._reject(e);
    };

    var targetRejected = function (e, context) {
        context.promiseRejectionQueued = true;
        context.bindingPromise._then(rejectThis, rejectThis, null, this, e);
    };

    var bindingResolved = function (thisArg, context) {
        if ((this._bitField & 50397184) === 0) {
            this._resolveCallback(context.target);
        }
    };

    var bindingRejected = function (e, context) {
        if (!context.promiseRejectionQueued) this._reject(e);
    };

    Promise.prototype.bind = function (thisArg) {
        if (!calledBind) {
            calledBind = true;
            Promise.prototype._propagateFrom = debug.propagateFromFunction();
            Promise.prototype._boundValue = debug.boundValueFunction();
        }
        var maybePromise = tryConvertToPromise(thisArg);
        var ret = new Promise(INTERNAL);
        ret._propagateFrom(this, 1);
        var target = this._target();
        ret._setBoundTo(maybePromise);
        if (maybePromise instanceof Promise) {
            var context = {
                promiseRejectionQueued: false,
                promise: ret,
                target: target,
                bindingPromise: maybePromise
            };
            target._then(INTERNAL, targetRejected, undefined, ret, context);
            maybePromise._then(bindingResolved, bindingRejected, undefined, ret, context);
            ret._setOnCancel(maybePromise);
        } else {
            ret._resolveCallback(target);
        }
        return ret;
    };

    Promise.prototype._setBoundTo = function (obj) {
        if (obj !== undefined) {
            this._bitField = this._bitField | 2097152;
            this._boundTo = obj;
        } else {
            this._bitField = this._bitField & ~2097152;
        }
    };

    Promise.prototype._isBound = function () {
        return (this._bitField & 2097152) === 2097152;
    };

    Promise.bind = function (thisArg, value) {
        return Promise.resolve(value).bind(thisArg);
    };
};

/***/ }),
/* 81 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = function (Promise, PromiseArray, apiRejection, debug) {
    var util = __webpack_require__(1);
    var tryCatch = util.tryCatch;
    var errorObj = util.errorObj;
    var async = Promise._async;

    Promise.prototype["break"] = Promise.prototype.cancel = function () {
        if (!debug.cancellation()) return this._warn("cancellation is disabled");

        var promise = this;
        var child = promise;
        while (promise._isCancellable()) {
            if (!promise._cancelBy(child)) {
                if (child._isFollowing()) {
                    child._followee().cancel();
                } else {
                    child._cancelBranched();
                }
                break;
            }

            var parent = promise._cancellationParent;
            if (parent == null || !parent._isCancellable()) {
                if (promise._isFollowing()) {
                    promise._followee().cancel();
                } else {
                    promise._cancelBranched();
                }
                break;
            } else {
                if (promise._isFollowing()) promise._followee().cancel();
                promise._setWillBeCancelled();
                child = promise;
                promise = parent;
            }
        }
    };

    Promise.prototype._branchHasCancelled = function () {
        this._branchesRemainingToCancel--;
    };

    Promise.prototype._enoughBranchesHaveCancelled = function () {
        return this._branchesRemainingToCancel === undefined || this._branchesRemainingToCancel <= 0;
    };

    Promise.prototype._cancelBy = function (canceller) {
        if (canceller === this) {
            this._branchesRemainingToCancel = 0;
            this._invokeOnCancel();
            return true;
        } else {
            this._branchHasCancelled();
            if (this._enoughBranchesHaveCancelled()) {
                this._invokeOnCancel();
                return true;
            }
        }
        return false;
    };

    Promise.prototype._cancelBranched = function () {
        if (this._enoughBranchesHaveCancelled()) {
            this._cancel();
        }
    };

    Promise.prototype._cancel = function () {
        if (!this._isCancellable()) return;
        this._setCancelled();
        async.invoke(this._cancelPromises, this, undefined);
    };

    Promise.prototype._cancelPromises = function () {
        if (this._length() > 0) this._settlePromises();
    };

    Promise.prototype._unsetOnCancel = function () {
        this._onCancelField = undefined;
    };

    Promise.prototype._isCancellable = function () {
        return this.isPending() && !this._isCancelled();
    };

    Promise.prototype.isCancellable = function () {
        return this.isPending() && !this.isCancelled();
    };

    Promise.prototype._doInvokeOnCancel = function (onCancelCallback, internalOnly) {
        if (util.isArray(onCancelCallback)) {
            for (var i = 0; i < onCancelCallback.length; ++i) {
                this._doInvokeOnCancel(onCancelCallback[i], internalOnly);
            }
        } else if (onCancelCallback !== undefined) {
            if (typeof onCancelCallback === "function") {
                if (!internalOnly) {
                    var e = tryCatch(onCancelCallback).call(this._boundValue());
                    if (e === errorObj) {
                        this._attachExtraTrace(e.e);
                        async.throwLater(e.e);
                    }
                }
            } else {
                onCancelCallback._resultCancelled(this);
            }
        }
    };

    Promise.prototype._invokeOnCancel = function () {
        var onCancelCallback = this._onCancel();
        this._unsetOnCancel();
        async.invoke(this._doInvokeOnCancel, this, onCancelCallback);
    };

    Promise.prototype._invokeInternalOnCancel = function () {
        if (this._isCancellable()) {
            this._doInvokeOnCancel(this._onCancel(), true);
            this._unsetOnCancel();
        }
    };

    Promise.prototype._resultCancelled = function () {
        this.cancel();
    };
};

/***/ }),
/* 82 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = function (Promise) {
    function returner() {
        return this.value;
    }
    function thrower() {
        throw this.reason;
    }

    Promise.prototype["return"] = Promise.prototype.thenReturn = function (value) {
        if (value instanceof Promise) value.suppressUnhandledRejections();
        return this._then(returner, undefined, undefined, { value: value }, undefined);
    };

    Promise.prototype["throw"] = Promise.prototype.thenThrow = function (reason) {
        return this._then(thrower, undefined, undefined, { reason: reason }, undefined);
    };

    Promise.prototype.catchThrow = function (reason) {
        if (arguments.length <= 1) {
            return this._then(undefined, thrower, undefined, { reason: reason }, undefined);
        } else {
            var _reason = arguments[1];
            var handler = function () {
                throw _reason;
            };
            return this.caught(reason, handler);
        }
    };

    Promise.prototype.catchReturn = function (value) {
        if (arguments.length <= 1) {
            if (value instanceof Promise) value.suppressUnhandledRejections();
            return this._then(undefined, returner, undefined, { value: value }, undefined);
        } else {
            var _value = arguments[1];
            if (_value instanceof Promise) _value.suppressUnhandledRejections();
            var handler = function () {
                return _value;
            };
            return this.caught(value, handler);
        }
    };
};

/***/ }),
/* 83 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = function (Promise) {
    function PromiseInspection(promise) {
        if (promise !== undefined) {
            promise = promise._target();
            this._bitField = promise._bitField;
            this._settledValueField = promise._isFateSealed() ? promise._settledValue() : undefined;
        } else {
            this._bitField = 0;
            this._settledValueField = undefined;
        }
    }

    PromiseInspection.prototype._settledValue = function () {
        return this._settledValueField;
    };

    var value = PromiseInspection.prototype.value = function () {
        if (!this.isFulfilled()) {
            throw new TypeError("cannot get fulfillment value of a non-fulfilled promise\u000a\u000a    See http://goo.gl/MqrFmX\u000a");
        }
        return this._settledValue();
    };

    var reason = PromiseInspection.prototype.error = PromiseInspection.prototype.reason = function () {
        if (!this.isRejected()) {
            throw new TypeError("cannot get rejection reason of a non-rejected promise\u000a\u000a    See http://goo.gl/MqrFmX\u000a");
        }
        return this._settledValue();
    };

    var isFulfilled = PromiseInspection.prototype.isFulfilled = function () {
        return (this._bitField & 33554432) !== 0;
    };

    var isRejected = PromiseInspection.prototype.isRejected = function () {
        return (this._bitField & 16777216) !== 0;
    };

    var isPending = PromiseInspection.prototype.isPending = function () {
        return (this._bitField & 50397184) === 0;
    };

    var isResolved = PromiseInspection.prototype.isResolved = function () {
        return (this._bitField & 50331648) !== 0;
    };

    PromiseInspection.prototype.isCancelled = function () {
        return (this._bitField & 8454144) !== 0;
    };

    Promise.prototype.__isCancelled = function () {
        return (this._bitField & 65536) === 65536;
    };

    Promise.prototype._isCancelled = function () {
        return this._target().__isCancelled();
    };

    Promise.prototype.isCancelled = function () {
        return (this._target()._bitField & 8454144) !== 0;
    };

    Promise.prototype.isPending = function () {
        return isPending.call(this._target());
    };

    Promise.prototype.isRejected = function () {
        return isRejected.call(this._target());
    };

    Promise.prototype.isFulfilled = function () {
        return isFulfilled.call(this._target());
    };

    Promise.prototype.isResolved = function () {
        return isResolved.call(this._target());
    };

    Promise.prototype.value = function () {
        return value.call(this._target());
    };

    Promise.prototype.reason = function () {
        var target = this._target();
        target._unsetRejectionIsUnhandled();
        return reason.call(target);
    };

    Promise.prototype._value = function () {
        return this._settledValue();
    };

    Promise.prototype._reason = function () {
        this._unsetRejectionIsUnhandled();
        return this._settledValue();
    };

    Promise.PromiseInspection = PromiseInspection;
};

/***/ }),
/* 84 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = function (Promise, PromiseArray, tryConvertToPromise, INTERNAL, async, getDomain) {
    var util = __webpack_require__(1);
    var canEvaluate = util.canEvaluate;
    var tryCatch = util.tryCatch;
    var errorObj = util.errorObj;
    var reject;

    if (true) {
        if (canEvaluate) {
            var thenCallback = function (i) {
                return new Function("value", "holder", "                             \n\
            'use strict';                                                    \n\
            holder.pIndex = value;                                           \n\
            holder.checkFulfillment(this);                                   \n\
            ".replace(/Index/g, i));
            };

            var promiseSetter = function (i) {
                return new Function("promise", "holder", "                           \n\
            'use strict';                                                    \n\
            holder.pIndex = promise;                                         \n\
            ".replace(/Index/g, i));
            };

            var generateHolderClass = function (total) {
                var props = new Array(total);
                for (var i = 0; i < props.length; ++i) {
                    props[i] = "this.p" + (i + 1);
                }
                var assignment = props.join(" = ") + " = null;";
                var cancellationCode = "var promise;\n" + props.map(function (prop) {
                    return "                                                         \n\
                promise = " + prop + ";                                      \n\
                if (promise instanceof Promise) {                            \n\
                    promise.cancel();                                        \n\
                }                                                            \n\
            ";
                }).join("\n");
                var passedArguments = props.join(", ");
                var name = "Holder$" + total;

                var code = "return function(tryCatch, errorObj, Promise, async) {    \n\
            'use strict';                                                    \n\
            function [TheName](fn) {                                         \n\
                [TheProperties]                                              \n\
                this.fn = fn;                                                \n\
                this.asyncNeeded = true;                                     \n\
                this.now = 0;                                                \n\
            }                                                                \n\
                                                                             \n\
            [TheName].prototype._callFunction = function(promise) {          \n\
                promise._pushContext();                                      \n\
                var ret = tryCatch(this.fn)([ThePassedArguments]);           \n\
                promise._popContext();                                       \n\
                if (ret === errorObj) {                                      \n\
                    promise._rejectCallback(ret.e, false);                   \n\
                } else {                                                     \n\
                    promise._resolveCallback(ret);                           \n\
                }                                                            \n\
            };                                                               \n\
                                                                             \n\
            [TheName].prototype.checkFulfillment = function(promise) {       \n\
                var now = ++this.now;                                        \n\
                if (now === [TheTotal]) {                                    \n\
                    if (this.asyncNeeded) {                                  \n\
                        async.invoke(this._callFunction, this, promise);     \n\
                    } else {                                                 \n\
                        this._callFunction(promise);                         \n\
                    }                                                        \n\
                                                                             \n\
                }                                                            \n\
            };                                                               \n\
                                                                             \n\
            [TheName].prototype._resultCancelled = function() {              \n\
                [CancellationCode]                                           \n\
            };                                                               \n\
                                                                             \n\
            return [TheName];                                                \n\
        }(tryCatch, errorObj, Promise, async);                               \n\
        ";

                code = code.replace(/\[TheName\]/g, name).replace(/\[TheTotal\]/g, total).replace(/\[ThePassedArguments\]/g, passedArguments).replace(/\[TheProperties\]/g, assignment).replace(/\[CancellationCode\]/g, cancellationCode);

                return new Function("tryCatch", "errorObj", "Promise", "async", code)(tryCatch, errorObj, Promise, async);
            };

            var holderClasses = [];
            var thenCallbacks = [];
            var promiseSetters = [];

            for (var i = 0; i < 8; ++i) {
                holderClasses.push(generateHolderClass(i + 1));
                thenCallbacks.push(thenCallback(i + 1));
                promiseSetters.push(promiseSetter(i + 1));
            }

            reject = function (reason) {
                this._reject(reason);
            };
        }
    }

    Promise.join = function () {
        var last = arguments.length - 1;
        var fn;
        if (last > 0 && typeof arguments[last] === "function") {
            fn = arguments[last];
            if (true) {
                if (last <= 8 && canEvaluate) {
                    var ret = new Promise(INTERNAL);
                    ret._captureStackTrace();
                    var HolderClass = holderClasses[last - 1];
                    var holder = new HolderClass(fn);
                    var callbacks = thenCallbacks;

                    for (var i = 0; i < last; ++i) {
                        var maybePromise = tryConvertToPromise(arguments[i], ret);
                        if (maybePromise instanceof Promise) {
                            maybePromise = maybePromise._target();
                            var bitField = maybePromise._bitField;
                            ;
                            if ((bitField & 50397184) === 0) {
                                maybePromise._then(callbacks[i], reject, undefined, ret, holder);
                                promiseSetters[i](maybePromise, holder);
                                holder.asyncNeeded = false;
                            } else if ((bitField & 33554432) !== 0) {
                                callbacks[i].call(ret, maybePromise._value(), holder);
                            } else if ((bitField & 16777216) !== 0) {
                                ret._reject(maybePromise._reason());
                            } else {
                                ret._cancel();
                            }
                        } else {
                            callbacks[i].call(ret, maybePromise, holder);
                        }
                    }

                    if (!ret._isFateSealed()) {
                        if (holder.asyncNeeded) {
                            var domain = getDomain();
                            if (domain !== null) {
                                holder.fn = util.domainBind(domain, holder.fn);
                            }
                        }
                        ret._setAsyncGuaranteed();
                        ret._setOnCancel(holder);
                    }
                    return ret;
                }
            }
        }
        var $_len = arguments.length;var args = new Array($_len);for (var $_i = 0; $_i < $_len; ++$_i) {
            args[$_i] = arguments[$_i];
        };
        if (fn) args.pop();
        var ret = new PromiseArray(args).promise();
        return fn !== undefined ? ret.spread(fn) : ret;
    };
};

/***/ }),
/* 85 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = function (Promise, PromiseArray, apiRejection, tryConvertToPromise, INTERNAL, debug) {
    var getDomain = Promise._getDomain;
    var util = __webpack_require__(1);
    var tryCatch = util.tryCatch;
    var errorObj = util.errorObj;
    var async = Promise._async;

    function MappingPromiseArray(promises, fn, limit, _filter) {
        this.constructor$(promises);
        this._promise._captureStackTrace();
        var domain = getDomain();
        this._callback = domain === null ? fn : util.domainBind(domain, fn);
        this._preservedValues = _filter === INTERNAL ? new Array(this.length()) : null;
        this._limit = limit;
        this._inFlight = 0;
        this._queue = [];
        async.invoke(this._asyncInit, this, undefined);
    }
    util.inherits(MappingPromiseArray, PromiseArray);

    MappingPromiseArray.prototype._asyncInit = function () {
        this._init$(undefined, -2);
    };

    MappingPromiseArray.prototype._init = function () {};

    MappingPromiseArray.prototype._promiseFulfilled = function (value, index) {
        var values = this._values;
        var length = this.length();
        var preservedValues = this._preservedValues;
        var limit = this._limit;

        if (index < 0) {
            index = index * -1 - 1;
            values[index] = value;
            if (limit >= 1) {
                this._inFlight--;
                this._drainQueue();
                if (this._isResolved()) return true;
            }
        } else {
            if (limit >= 1 && this._inFlight >= limit) {
                values[index] = value;
                this._queue.push(index);
                return false;
            }
            if (preservedValues !== null) preservedValues[index] = value;

            var promise = this._promise;
            var callback = this._callback;
            var receiver = promise._boundValue();
            promise._pushContext();
            var ret = tryCatch(callback).call(receiver, value, index, length);
            var promiseCreated = promise._popContext();
            debug.checkForgottenReturns(ret, promiseCreated, preservedValues !== null ? "Promise.filter" : "Promise.map", promise);
            if (ret === errorObj) {
                this._reject(ret.e);
                return true;
            }

            var maybePromise = tryConvertToPromise(ret, this._promise);
            if (maybePromise instanceof Promise) {
                maybePromise = maybePromise._target();
                var bitField = maybePromise._bitField;
                ;
                if ((bitField & 50397184) === 0) {
                    if (limit >= 1) this._inFlight++;
                    values[index] = maybePromise;
                    maybePromise._proxy(this, (index + 1) * -1);
                    return false;
                } else if ((bitField & 33554432) !== 0) {
                    ret = maybePromise._value();
                } else if ((bitField & 16777216) !== 0) {
                    this._reject(maybePromise._reason());
                    return true;
                } else {
                    this._cancel();
                    return true;
                }
            }
            values[index] = ret;
        }
        var totalResolved = ++this._totalResolved;
        if (totalResolved >= length) {
            if (preservedValues !== null) {
                this._filter(values, preservedValues);
            } else {
                this._resolve(values);
            }
            return true;
        }
        return false;
    };

    MappingPromiseArray.prototype._drainQueue = function () {
        var queue = this._queue;
        var limit = this._limit;
        var values = this._values;
        while (queue.length > 0 && this._inFlight < limit) {
            if (this._isResolved()) return;
            var index = queue.pop();
            this._promiseFulfilled(values[index], index);
        }
    };

    MappingPromiseArray.prototype._filter = function (booleans, values) {
        var len = values.length;
        var ret = new Array(len);
        var j = 0;
        for (var i = 0; i < len; ++i) {
            if (booleans[i]) ret[j++] = values[i];
        }
        ret.length = j;
        this._resolve(ret);
    };

    MappingPromiseArray.prototype.preservedValues = function () {
        return this._preservedValues;
    };

    function map(promises, fn, options, _filter) {
        if (typeof fn !== "function") {
            return apiRejection("expecting a function but got " + util.classString(fn));
        }

        var limit = 0;
        if (options !== undefined) {
            if (typeof options === "object" && options !== null) {
                if (typeof options.concurrency !== "number") {
                    return Promise.reject(new TypeError("'concurrency' must be a number but it is " + util.classString(options.concurrency)));
                }
                limit = options.concurrency;
            } else {
                return Promise.reject(new TypeError("options argument must be an object but it is " + util.classString(options)));
            }
        }
        limit = typeof limit === "number" && isFinite(limit) && limit >= 1 ? limit : 0;
        return new MappingPromiseArray(promises, fn, limit, _filter).promise();
    }

    Promise.prototype.map = function (fn, options) {
        return map(this, fn, options, null);
    };

    Promise.map = function (promises, fn, options, _filter) {
        return map(promises, fn, options, _filter);
    };
};

/***/ }),
/* 86 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var cr = Object.create;
if (cr) {
    var callerCache = cr(null);
    var getterCache = cr(null);
    callerCache[" size"] = getterCache[" size"] = 0;
}

module.exports = function (Promise) {
    var util = __webpack_require__(1);
    var canEvaluate = util.canEvaluate;
    var isIdentifier = util.isIdentifier;

    var getMethodCaller;
    var getGetter;
    if (true) {
        var makeMethodCaller = function (methodName) {
            return new Function("ensureMethod", "                                    \n\
        return function(obj) {                                               \n\
            'use strict'                                                     \n\
            var len = this.length;                                           \n\
            ensureMethod(obj, 'methodName');                                 \n\
            switch(len) {                                                    \n\
                case 1: return obj.methodName(this[0]);                      \n\
                case 2: return obj.methodName(this[0], this[1]);             \n\
                case 3: return obj.methodName(this[0], this[1], this[2]);    \n\
                case 0: return obj.methodName();                             \n\
                default:                                                     \n\
                    return obj.methodName.apply(obj, this);                  \n\
            }                                                                \n\
        };                                                                   \n\
        ".replace(/methodName/g, methodName))(ensureMethod);
        };

        var makeGetter = function (propertyName) {
            return new Function("obj", "                                             \n\
        'use strict';                                                        \n\
        return obj.propertyName;                                             \n\
        ".replace("propertyName", propertyName));
        };

        var getCompiled = function (name, compiler, cache) {
            var ret = cache[name];
            if (typeof ret !== "function") {
                if (!isIdentifier(name)) {
                    return null;
                }
                ret = compiler(name);
                cache[name] = ret;
                cache[" size"]++;
                if (cache[" size"] > 512) {
                    var keys = Object.keys(cache);
                    for (var i = 0; i < 256; ++i) delete cache[keys[i]];
                    cache[" size"] = keys.length - 256;
                }
            }
            return ret;
        };

        getMethodCaller = function (name) {
            return getCompiled(name, makeMethodCaller, callerCache);
        };

        getGetter = function (name) {
            return getCompiled(name, makeGetter, getterCache);
        };
    }

    function ensureMethod(obj, methodName) {
        var fn;
        if (obj != null) fn = obj[methodName];
        if (typeof fn !== "function") {
            var message = "Object " + util.classString(obj) + " has no method '" + util.toString(methodName) + "'";
            throw new Promise.TypeError(message);
        }
        return fn;
    }

    function caller(obj) {
        var methodName = this.pop();
        var fn = ensureMethod(obj, methodName);
        return fn.apply(obj, this);
    }
    Promise.prototype.call = function (methodName) {
        var $_len = arguments.length;var args = new Array(Math.max($_len - 1, 0));for (var $_i = 1; $_i < $_len; ++$_i) {
            args[$_i - 1] = arguments[$_i];
        };
        if (true) {
            if (canEvaluate) {
                var maybeCaller = getMethodCaller(methodName);
                if (maybeCaller !== null) {
                    return this._then(maybeCaller, undefined, undefined, args, undefined);
                }
            }
        }
        args.push(methodName);
        return this._then(caller, undefined, undefined, args, undefined);
    };

    function namedGetter(obj) {
        return obj[this];
    }
    function indexedGetter(obj) {
        var index = +this;
        if (index < 0) index = Math.max(0, index + obj.length);
        return obj[index];
    }
    Promise.prototype.get = function (propertyName) {
        var isIndex = typeof propertyName === "number";
        var getter;
        if (!isIndex) {
            if (canEvaluate) {
                var maybeGetter = getGetter(propertyName);
                getter = maybeGetter !== null ? maybeGetter : namedGetter;
            } else {
                getter = namedGetter;
            }
        } else {
            getter = indexedGetter;
        }
        return this._then(getter, undefined, undefined, propertyName, undefined);
    };
};

/***/ }),
/* 87 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = function (Promise, apiRejection, tryConvertToPromise, createContext, INTERNAL, debug) {
    var util = __webpack_require__(1);
    var TypeError = __webpack_require__(11).TypeError;
    var inherits = __webpack_require__(1).inherits;
    var errorObj = util.errorObj;
    var tryCatch = util.tryCatch;
    var NULL = {};

    function thrower(e) {
        setTimeout(function () {
            throw e;
        }, 0);
    }

    function castPreservingDisposable(thenable) {
        var maybePromise = tryConvertToPromise(thenable);
        if (maybePromise !== thenable && typeof thenable._isDisposable === "function" && typeof thenable._getDisposer === "function" && thenable._isDisposable()) {
            maybePromise._setDisposable(thenable._getDisposer());
        }
        return maybePromise;
    }
    function dispose(resources, inspection) {
        var i = 0;
        var len = resources.length;
        var ret = new Promise(INTERNAL);
        function iterator() {
            if (i >= len) return ret._fulfill();
            var maybePromise = castPreservingDisposable(resources[i++]);
            if (maybePromise instanceof Promise && maybePromise._isDisposable()) {
                try {
                    maybePromise = tryConvertToPromise(maybePromise._getDisposer().tryDispose(inspection), resources.promise);
                } catch (e) {
                    return thrower(e);
                }
                if (maybePromise instanceof Promise) {
                    return maybePromise._then(iterator, thrower, null, null, null);
                }
            }
            iterator();
        }
        iterator();
        return ret;
    }

    function Disposer(data, promise, context) {
        this._data = data;
        this._promise = promise;
        this._context = context;
    }

    Disposer.prototype.data = function () {
        return this._data;
    };

    Disposer.prototype.promise = function () {
        return this._promise;
    };

    Disposer.prototype.resource = function () {
        if (this.promise().isFulfilled()) {
            return this.promise().value();
        }
        return NULL;
    };

    Disposer.prototype.tryDispose = function (inspection) {
        var resource = this.resource();
        var context = this._context;
        if (context !== undefined) context._pushContext();
        var ret = resource !== NULL ? this.doDispose(resource, inspection) : null;
        if (context !== undefined) context._popContext();
        this._promise._unsetDisposable();
        this._data = null;
        return ret;
    };

    Disposer.isDisposer = function (d) {
        return d != null && typeof d.resource === "function" && typeof d.tryDispose === "function";
    };

    function FunctionDisposer(fn, promise, context) {
        this.constructor$(fn, promise, context);
    }
    inherits(FunctionDisposer, Disposer);

    FunctionDisposer.prototype.doDispose = function (resource, inspection) {
        var fn = this.data();
        return fn.call(resource, resource, inspection);
    };

    function maybeUnwrapDisposer(value) {
        if (Disposer.isDisposer(value)) {
            this.resources[this.index]._setDisposable(value);
            return value.promise();
        }
        return value;
    }

    function ResourceList(length) {
        this.length = length;
        this.promise = null;
        this[length - 1] = null;
    }

    ResourceList.prototype._resultCancelled = function () {
        var len = this.length;
        for (var i = 0; i < len; ++i) {
            var item = this[i];
            if (item instanceof Promise) {
                item.cancel();
            }
        }
    };

    Promise.using = function () {
        var len = arguments.length;
        if (len < 2) return apiRejection("you must pass at least 2 arguments to Promise.using");
        var fn = arguments[len - 1];
        if (typeof fn !== "function") {
            return apiRejection("expecting a function but got " + util.classString(fn));
        }
        var input;
        var spreadArgs = true;
        if (len === 2 && Array.isArray(arguments[0])) {
            input = arguments[0];
            len = input.length;
            spreadArgs = false;
        } else {
            input = arguments;
            len--;
        }
        var resources = new ResourceList(len);
        for (var i = 0; i < len; ++i) {
            var resource = input[i];
            if (Disposer.isDisposer(resource)) {
                var disposer = resource;
                resource = resource.promise();
                resource._setDisposable(disposer);
            } else {
                var maybePromise = tryConvertToPromise(resource);
                if (maybePromise instanceof Promise) {
                    resource = maybePromise._then(maybeUnwrapDisposer, null, null, {
                        resources: resources,
                        index: i
                    }, undefined);
                }
            }
            resources[i] = resource;
        }

        var reflectedResources = new Array(resources.length);
        for (var i = 0; i < reflectedResources.length; ++i) {
            reflectedResources[i] = Promise.resolve(resources[i]).reflect();
        }

        var resultPromise = Promise.all(reflectedResources).then(function (inspections) {
            for (var i = 0; i < inspections.length; ++i) {
                var inspection = inspections[i];
                if (inspection.isRejected()) {
                    errorObj.e = inspection.error();
                    return errorObj;
                } else if (!inspection.isFulfilled()) {
                    resultPromise.cancel();
                    return;
                }
                inspections[i] = inspection.value();
            }
            promise._pushContext();

            fn = tryCatch(fn);
            var ret = spreadArgs ? fn.apply(undefined, inspections) : fn(inspections);
            var promiseCreated = promise._popContext();
            debug.checkForgottenReturns(ret, promiseCreated, "Promise.using", promise);
            return ret;
        });

        var promise = resultPromise.lastly(function () {
            var inspection = new Promise.PromiseInspection(resultPromise);
            return dispose(resources, inspection);
        });
        resources.promise = promise;
        promise._setOnCancel(resources);
        return promise;
    };

    Promise.prototype._setDisposable = function (disposer) {
        this._bitField = this._bitField | 131072;
        this._disposer = disposer;
    };

    Promise.prototype._isDisposable = function () {
        return (this._bitField & 131072) > 0;
    };

    Promise.prototype._getDisposer = function () {
        return this._disposer;
    };

    Promise.prototype._unsetDisposable = function () {
        this._bitField = this._bitField & ~131072;
        this._disposer = undefined;
    };

    Promise.prototype.disposer = function (fn) {
        if (typeof fn === "function") {
            return new FunctionDisposer(fn, this, createContext());
        }
        throw new TypeError();
    };
};

/***/ }),
/* 88 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = function (Promise, INTERNAL, debug) {
    var util = __webpack_require__(1);
    var TimeoutError = Promise.TimeoutError;

    function HandleWrapper(handle) {
        this.handle = handle;
    }

    HandleWrapper.prototype._resultCancelled = function () {
        clearTimeout(this.handle);
    };

    var afterValue = function (value) {
        return delay(+this).thenReturn(value);
    };
    var delay = Promise.delay = function (ms, value) {
        var ret;
        var handle;
        if (value !== undefined) {
            ret = Promise.resolve(value)._then(afterValue, null, null, ms, undefined);
            if (debug.cancellation() && value instanceof Promise) {
                ret._setOnCancel(value);
            }
        } else {
            ret = new Promise(INTERNAL);
            handle = setTimeout(function () {
                ret._fulfill();
            }, +ms);
            if (debug.cancellation()) {
                ret._setOnCancel(new HandleWrapper(handle));
            }
            ret._captureStackTrace();
        }
        ret._setAsyncGuaranteed();
        return ret;
    };

    Promise.prototype.delay = function (ms) {
        return delay(ms, this);
    };

    var afterTimeout = function (promise, message, parent) {
        var err;
        if (typeof message !== "string") {
            if (message instanceof Error) {
                err = message;
            } else {
                err = new TimeoutError("operation timed out");
            }
        } else {
            err = new TimeoutError(message);
        }
        util.markAsOriginatingFromRejection(err);
        promise._attachExtraTrace(err);
        promise._reject(err);

        if (parent != null) {
            parent.cancel();
        }
    };

    function successClear(value) {
        clearTimeout(this.handle);
        return value;
    }

    function failureClear(reason) {
        clearTimeout(this.handle);
        throw reason;
    }

    Promise.prototype.timeout = function (ms, message) {
        ms = +ms;
        var ret, parent;

        var handleWrapper = new HandleWrapper(setTimeout(function timeoutTimeout() {
            if (ret.isPending()) {
                afterTimeout(ret, message, parent);
            }
        }, ms));

        if (debug.cancellation()) {
            parent = this.then();
            ret = parent._then(successClear, failureClear, undefined, handleWrapper, undefined);
            ret._setOnCancel(handleWrapper);
        } else {
            ret = this._then(successClear, failureClear, undefined, handleWrapper, undefined);
        }

        return ret;
    };
};

/***/ }),
/* 89 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = function (Promise, apiRejection, INTERNAL, tryConvertToPromise, Proxyable, debug) {
    var errors = __webpack_require__(11);
    var TypeError = errors.TypeError;
    var util = __webpack_require__(1);
    var errorObj = util.errorObj;
    var tryCatch = util.tryCatch;
    var yieldHandlers = [];

    function promiseFromYieldHandler(value, yieldHandlers, traceParent) {
        for (var i = 0; i < yieldHandlers.length; ++i) {
            traceParent._pushContext();
            var result = tryCatch(yieldHandlers[i])(value);
            traceParent._popContext();
            if (result === errorObj) {
                traceParent._pushContext();
                var ret = Promise.reject(errorObj.e);
                traceParent._popContext();
                return ret;
            }
            var maybePromise = tryConvertToPromise(result, traceParent);
            if (maybePromise instanceof Promise) return maybePromise;
        }
        return null;
    }

    function PromiseSpawn(generatorFunction, receiver, yieldHandler, stack) {
        if (debug.cancellation()) {
            var internal = new Promise(INTERNAL);
            var _finallyPromise = this._finallyPromise = new Promise(INTERNAL);
            this._promise = internal.lastly(function () {
                return _finallyPromise;
            });
            internal._captureStackTrace();
            internal._setOnCancel(this);
        } else {
            var promise = this._promise = new Promise(INTERNAL);
            promise._captureStackTrace();
        }
        this._stack = stack;
        this._generatorFunction = generatorFunction;
        this._receiver = receiver;
        this._generator = undefined;
        this._yieldHandlers = typeof yieldHandler === "function" ? [yieldHandler].concat(yieldHandlers) : yieldHandlers;
        this._yieldedPromise = null;
        this._cancellationPhase = false;
    }
    util.inherits(PromiseSpawn, Proxyable);

    PromiseSpawn.prototype._isResolved = function () {
        return this._promise === null;
    };

    PromiseSpawn.prototype._cleanup = function () {
        this._promise = this._generator = null;
        if (debug.cancellation() && this._finallyPromise !== null) {
            this._finallyPromise._fulfill();
            this._finallyPromise = null;
        }
    };

    PromiseSpawn.prototype._promiseCancelled = function () {
        if (this._isResolved()) return;
        var implementsReturn = typeof this._generator["return"] !== "undefined";

        var result;
        if (!implementsReturn) {
            var reason = new Promise.CancellationError("generator .return() sentinel");
            Promise.coroutine.returnSentinel = reason;
            this._promise._attachExtraTrace(reason);
            this._promise._pushContext();
            result = tryCatch(this._generator["throw"]).call(this._generator, reason);
            this._promise._popContext();
        } else {
            this._promise._pushContext();
            result = tryCatch(this._generator["return"]).call(this._generator, undefined);
            this._promise._popContext();
        }
        this._cancellationPhase = true;
        this._yieldedPromise = null;
        this._continue(result);
    };

    PromiseSpawn.prototype._promiseFulfilled = function (value) {
        this._yieldedPromise = null;
        this._promise._pushContext();
        var result = tryCatch(this._generator.next).call(this._generator, value);
        this._promise._popContext();
        this._continue(result);
    };

    PromiseSpawn.prototype._promiseRejected = function (reason) {
        this._yieldedPromise = null;
        this._promise._attachExtraTrace(reason);
        this._promise._pushContext();
        var result = tryCatch(this._generator["throw"]).call(this._generator, reason);
        this._promise._popContext();
        this._continue(result);
    };

    PromiseSpawn.prototype._resultCancelled = function () {
        if (this._yieldedPromise instanceof Promise) {
            var promise = this._yieldedPromise;
            this._yieldedPromise = null;
            promise.cancel();
        }
    };

    PromiseSpawn.prototype.promise = function () {
        return this._promise;
    };

    PromiseSpawn.prototype._run = function () {
        this._generator = this._generatorFunction.call(this._receiver);
        this._receiver = this._generatorFunction = undefined;
        this._promiseFulfilled(undefined);
    };

    PromiseSpawn.prototype._continue = function (result) {
        var promise = this._promise;
        if (result === errorObj) {
            this._cleanup();
            if (this._cancellationPhase) {
                return promise.cancel();
            } else {
                return promise._rejectCallback(result.e, false);
            }
        }

        var value = result.value;
        if (result.done === true) {
            this._cleanup();
            if (this._cancellationPhase) {
                return promise.cancel();
            } else {
                return promise._resolveCallback(value);
            }
        } else {
            var maybePromise = tryConvertToPromise(value, this._promise);
            if (!(maybePromise instanceof Promise)) {
                maybePromise = promiseFromYieldHandler(maybePromise, this._yieldHandlers, this._promise);
                if (maybePromise === null) {
                    this._promiseRejected(new TypeError("A value %s was yielded that could not be treated as a promise\u000a\u000a    See http://goo.gl/MqrFmX\u000a\u000a".replace("%s", String(value)) + "From coroutine:\u000a" + this._stack.split("\n").slice(1, -7).join("\n")));
                    return;
                }
            }
            maybePromise = maybePromise._target();
            var bitField = maybePromise._bitField;
            ;
            if ((bitField & 50397184) === 0) {
                this._yieldedPromise = maybePromise;
                maybePromise._proxy(this, null);
            } else if ((bitField & 33554432) !== 0) {
                Promise._async.invoke(this._promiseFulfilled, this, maybePromise._value());
            } else if ((bitField & 16777216) !== 0) {
                Promise._async.invoke(this._promiseRejected, this, maybePromise._reason());
            } else {
                this._promiseCancelled();
            }
        }
    };

    Promise.coroutine = function (generatorFunction, options) {
        if (typeof generatorFunction !== "function") {
            throw new TypeError("generatorFunction must be a function\u000a\u000a    See http://goo.gl/MqrFmX\u000a");
        }
        var yieldHandler = Object(options).yieldHandler;
        var PromiseSpawn$ = PromiseSpawn;
        var stack = new Error().stack;
        return function () {
            var generator = generatorFunction.apply(this, arguments);
            var spawn = new PromiseSpawn$(undefined, undefined, yieldHandler, stack);
            var ret = spawn.promise();
            spawn._generator = generator;
            spawn._promiseFulfilled(undefined);
            return ret;
        };
    };

    Promise.coroutine.addYieldHandler = function (fn) {
        if (typeof fn !== "function") {
            throw new TypeError("expecting a function but got " + util.classString(fn));
        }
        yieldHandlers.push(fn);
    };

    Promise.spawn = function (generatorFunction) {
        debug.deprecated("Promise.spawn()", "Promise.coroutine()");
        if (typeof generatorFunction !== "function") {
            return apiRejection("generatorFunction must be a function\u000a\u000a    See http://goo.gl/MqrFmX\u000a");
        }
        var spawn = new PromiseSpawn(generatorFunction, this);
        var ret = spawn.promise();
        spawn._run(Promise.spawn);
        return ret;
    };
};

/***/ }),
/* 90 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = function (Promise) {
    var util = __webpack_require__(1);
    var async = Promise._async;
    var tryCatch = util.tryCatch;
    var errorObj = util.errorObj;

    function spreadAdapter(val, nodeback) {
        var promise = this;
        if (!util.isArray(val)) return successAdapter.call(promise, val, nodeback);
        var ret = tryCatch(nodeback).apply(promise._boundValue(), [null].concat(val));
        if (ret === errorObj) {
            async.throwLater(ret.e);
        }
    }

    function successAdapter(val, nodeback) {
        var promise = this;
        var receiver = promise._boundValue();
        var ret = val === undefined ? tryCatch(nodeback).call(receiver, null) : tryCatch(nodeback).call(receiver, null, val);
        if (ret === errorObj) {
            async.throwLater(ret.e);
        }
    }
    function errorAdapter(reason, nodeback) {
        var promise = this;
        if (!reason) {
            var newReason = new Error(reason + "");
            newReason.cause = reason;
            reason = newReason;
        }
        var ret = tryCatch(nodeback).call(promise._boundValue(), reason);
        if (ret === errorObj) {
            async.throwLater(ret.e);
        }
    }

    Promise.prototype.asCallback = Promise.prototype.nodeify = function (nodeback, options) {
        if (typeof nodeback == "function") {
            var adapter = successAdapter;
            if (options !== undefined && Object(options).spread) {
                adapter = spreadAdapter;
            }
            this._then(adapter, errorAdapter, undefined, this, nodeback);
        }
        return this;
    };
};

/***/ }),
/* 91 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = function (Promise, INTERNAL) {
    var THIS = {};
    var util = __webpack_require__(1);
    var nodebackForPromise = __webpack_require__(39);
    var withAppended = util.withAppended;
    var maybeWrapAsError = util.maybeWrapAsError;
    var canEvaluate = util.canEvaluate;
    var TypeError = __webpack_require__(11).TypeError;
    var defaultSuffix = "Async";
    var defaultPromisified = { __isPromisified__: true };
    var noCopyProps = ["arity", "length", "name", "arguments", "caller", "callee", "prototype", "__isPromisified__"];
    var noCopyPropsPattern = new RegExp("^(?:" + noCopyProps.join("|") + ")$");

    var defaultFilter = function (name) {
        return util.isIdentifier(name) && name.charAt(0) !== "_" && name !== "constructor";
    };

    function propsFilter(key) {
        return !noCopyPropsPattern.test(key);
    }

    function isPromisified(fn) {
        try {
            return fn.__isPromisified__ === true;
        } catch (e) {
            return false;
        }
    }

    function hasPromisified(obj, key, suffix) {
        var val = util.getDataPropertyOrDefault(obj, key + suffix, defaultPromisified);
        return val ? isPromisified(val) : false;
    }
    function checkValid(ret, suffix, suffixRegexp) {
        for (var i = 0; i < ret.length; i += 2) {
            var key = ret[i];
            if (suffixRegexp.test(key)) {
                var keyWithoutAsyncSuffix = key.replace(suffixRegexp, "");
                for (var j = 0; j < ret.length; j += 2) {
                    if (ret[j] === keyWithoutAsyncSuffix) {
                        throw new TypeError("Cannot promisify an API that has normal methods with '%s'-suffix\u000a\u000a    See http://goo.gl/MqrFmX\u000a".replace("%s", suffix));
                    }
                }
            }
        }
    }

    function promisifiableMethods(obj, suffix, suffixRegexp, filter) {
        var keys = util.inheritedDataKeys(obj);
        var ret = [];
        for (var i = 0; i < keys.length; ++i) {
            var key = keys[i];
            var value = obj[key];
            var passesDefaultFilter = filter === defaultFilter ? true : defaultFilter(key, value, obj);
            if (typeof value === "function" && !isPromisified(value) && !hasPromisified(obj, key, suffix) && filter(key, value, obj, passesDefaultFilter)) {
                ret.push(key, value);
            }
        }
        checkValid(ret, suffix, suffixRegexp);
        return ret;
    }

    var escapeIdentRegex = function (str) {
        return str.replace(/([$])/, "\\$");
    };

    var makeNodePromisifiedEval;
    if (true) {
        var switchCaseArgumentOrder = function (likelyArgumentCount) {
            var ret = [likelyArgumentCount];
            var min = Math.max(0, likelyArgumentCount - 1 - 3);
            for (var i = likelyArgumentCount - 1; i >= min; --i) {
                ret.push(i);
            }
            for (var i = likelyArgumentCount + 1; i <= 3; ++i) {
                ret.push(i);
            }
            return ret;
        };

        var argumentSequence = function (argumentCount) {
            return util.filledRange(argumentCount, "_arg", "");
        };

        var parameterDeclaration = function (parameterCount) {
            return util.filledRange(Math.max(parameterCount, 3), "_arg", "");
        };

        var parameterCount = function (fn) {
            if (typeof fn.length === "number") {
                return Math.max(Math.min(fn.length, 1023 + 1), 0);
            }
            return 0;
        };

        makeNodePromisifiedEval = function (callback, receiver, originalName, fn, _, multiArgs) {
            var newParameterCount = Math.max(0, parameterCount(fn) - 1);
            var argumentOrder = switchCaseArgumentOrder(newParameterCount);
            var shouldProxyThis = typeof callback === "string" || receiver === THIS;

            function generateCallForArgumentCount(count) {
                var args = argumentSequence(count).join(", ");
                var comma = count > 0 ? ", " : "";
                var ret;
                if (shouldProxyThis) {
                    ret = "ret = callback.call(this, {{args}}, nodeback); break;\n";
                } else {
                    ret = receiver === undefined ? "ret = callback({{args}}, nodeback); break;\n" : "ret = callback.call(receiver, {{args}}, nodeback); break;\n";
                }
                return ret.replace("{{args}}", args).replace(", ", comma);
            }

            function generateArgumentSwitchCase() {
                var ret = "";
                for (var i = 0; i < argumentOrder.length; ++i) {
                    ret += "case " + argumentOrder[i] + ":" + generateCallForArgumentCount(argumentOrder[i]);
                }

                ret += "                                                             \n\
        default:                                                             \n\
            var args = new Array(len + 1);                                   \n\
            var i = 0;                                                       \n\
            for (var i = 0; i < len; ++i) {                                  \n\
               args[i] = arguments[i];                                       \n\
            }                                                                \n\
            args[i] = nodeback;                                              \n\
            [CodeForCall]                                                    \n\
            break;                                                           \n\
        ".replace("[CodeForCall]", shouldProxyThis ? "ret = callback.apply(this, args);\n" : "ret = callback.apply(receiver, args);\n");
                return ret;
            }

            var getFunctionCode = typeof callback === "string" ? "this != null ? this['" + callback + "'] : fn" : "fn";
            var body = "'use strict';                                                \n\
        var ret = function (Parameters) {                                    \n\
            'use strict';                                                    \n\
            var len = arguments.length;                                      \n\
            var promise = new Promise(INTERNAL);                             \n\
            promise._captureStackTrace();                                    \n\
            var nodeback = nodebackForPromise(promise, " + multiArgs + ");   \n\
            var ret;                                                         \n\
            var callback = tryCatch([GetFunctionCode]);                      \n\
            switch(len) {                                                    \n\
                [CodeForSwitchCase]                                          \n\
            }                                                                \n\
            if (ret === errorObj) {                                          \n\
                promise._rejectCallback(maybeWrapAsError(ret.e), true, true);\n\
            }                                                                \n\
            if (!promise._isFateSealed()) promise._setAsyncGuaranteed();     \n\
            return promise;                                                  \n\
        };                                                                   \n\
        notEnumerableProp(ret, '__isPromisified__', true);                   \n\
        return ret;                                                          \n\
    ".replace("[CodeForSwitchCase]", generateArgumentSwitchCase()).replace("[GetFunctionCode]", getFunctionCode);
            body = body.replace("Parameters", parameterDeclaration(newParameterCount));
            return new Function("Promise", "fn", "receiver", "withAppended", "maybeWrapAsError", "nodebackForPromise", "tryCatch", "errorObj", "notEnumerableProp", "INTERNAL", body)(Promise, fn, receiver, withAppended, maybeWrapAsError, nodebackForPromise, util.tryCatch, util.errorObj, util.notEnumerableProp, INTERNAL);
        };
    }

    function makeNodePromisifiedClosure(callback, receiver, _, fn, __, multiArgs) {
        var defaultThis = function () {
            return this;
        }();
        var method = callback;
        if (typeof method === "string") {
            callback = fn;
        }
        function promisified() {
            var _receiver = receiver;
            if (receiver === THIS) _receiver = this;
            var promise = new Promise(INTERNAL);
            promise._captureStackTrace();
            var cb = typeof method === "string" && this !== defaultThis ? this[method] : callback;
            var fn = nodebackForPromise(promise, multiArgs);
            try {
                cb.apply(_receiver, withAppended(arguments, fn));
            } catch (e) {
                promise._rejectCallback(maybeWrapAsError(e), true, true);
            }
            if (!promise._isFateSealed()) promise._setAsyncGuaranteed();
            return promise;
        }
        util.notEnumerableProp(promisified, "__isPromisified__", true);
        return promisified;
    }

    var makeNodePromisified = canEvaluate ? makeNodePromisifiedEval : makeNodePromisifiedClosure;

    function promisifyAll(obj, suffix, filter, promisifier, multiArgs) {
        var suffixRegexp = new RegExp(escapeIdentRegex(suffix) + "$");
        var methods = promisifiableMethods(obj, suffix, suffixRegexp, filter);

        for (var i = 0, len = methods.length; i < len; i += 2) {
            var key = methods[i];
            var fn = methods[i + 1];
            var promisifiedKey = key + suffix;
            if (promisifier === makeNodePromisified) {
                obj[promisifiedKey] = makeNodePromisified(key, THIS, key, fn, suffix, multiArgs);
            } else {
                var promisified = promisifier(fn, function () {
                    return makeNodePromisified(key, THIS, key, fn, suffix, multiArgs);
                });
                util.notEnumerableProp(promisified, "__isPromisified__", true);
                obj[promisifiedKey] = promisified;
            }
        }
        util.toFastProperties(obj);
        return obj;
    }

    function promisify(callback, receiver, multiArgs) {
        return makeNodePromisified(callback, receiver, undefined, callback, null, multiArgs);
    }

    Promise.promisify = function (fn, options) {
        if (typeof fn !== "function") {
            throw new TypeError("expecting a function but got " + util.classString(fn));
        }
        if (isPromisified(fn)) {
            return fn;
        }
        options = Object(options);
        var receiver = options.context === undefined ? THIS : options.context;
        var multiArgs = !!options.multiArgs;
        var ret = promisify(fn, receiver, multiArgs);
        util.copyDescriptors(fn, ret, propsFilter);
        return ret;
    };

    Promise.promisifyAll = function (target, options) {
        if (typeof target !== "function" && typeof target !== "object") {
            throw new TypeError("the target of promisifyAll must be an object or a function\u000a\u000a    See http://goo.gl/MqrFmX\u000a");
        }
        options = Object(options);
        var multiArgs = !!options.multiArgs;
        var suffix = options.suffix;
        if (typeof suffix !== "string") suffix = defaultSuffix;
        var filter = options.filter;
        if (typeof filter !== "function") filter = defaultFilter;
        var promisifier = options.promisifier;
        if (typeof promisifier !== "function") promisifier = makeNodePromisified;

        if (!util.isIdentifier(suffix)) {
            throw new RangeError("suffix must be a valid identifier\u000a\u000a    See http://goo.gl/MqrFmX\u000a");
        }

        var keys = util.inheritedDataKeys(target);
        for (var i = 0; i < keys.length; ++i) {
            var value = target[keys[i]];
            if (keys[i] !== "constructor" && util.isClass(value)) {
                promisifyAll(value.prototype, suffix, filter, promisifier, multiArgs);
                promisifyAll(value, suffix, filter, promisifier, multiArgs);
            }
        }

        return promisifyAll(target, suffix, filter, promisifier, multiArgs);
    };
};

/***/ }),
/* 92 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = function (Promise, PromiseArray, tryConvertToPromise, apiRejection) {
    var util = __webpack_require__(1);
    var isObject = util.isObject;
    var es5 = __webpack_require__(16);
    var Es6Map;
    if (typeof Map === "function") Es6Map = Map;

    var mapToEntries = function () {
        var index = 0;
        var size = 0;

        function extractEntry(value, key) {
            this[index] = value;
            this[index + size] = key;
            index++;
        }

        return function mapToEntries(map) {
            size = map.size;
            index = 0;
            var ret = new Array(map.size * 2);
            map.forEach(extractEntry, ret);
            return ret;
        };
    }();

    var entriesToMap = function (entries) {
        var ret = new Es6Map();
        var length = entries.length / 2 | 0;
        for (var i = 0; i < length; ++i) {
            var key = entries[length + i];
            var value = entries[i];
            ret.set(key, value);
        }
        return ret;
    };

    function PropertiesPromiseArray(obj) {
        var isMap = false;
        var entries;
        if (Es6Map !== undefined && obj instanceof Es6Map) {
            entries = mapToEntries(obj);
            isMap = true;
        } else {
            var keys = es5.keys(obj);
            var len = keys.length;
            entries = new Array(len * 2);
            for (var i = 0; i < len; ++i) {
                var key = keys[i];
                entries[i] = obj[key];
                entries[i + len] = key;
            }
        }
        this.constructor$(entries);
        this._isMap = isMap;
        this._init$(undefined, isMap ? -6 : -3);
    }
    util.inherits(PropertiesPromiseArray, PromiseArray);

    PropertiesPromiseArray.prototype._init = function () {};

    PropertiesPromiseArray.prototype._promiseFulfilled = function (value, index) {
        this._values[index] = value;
        var totalResolved = ++this._totalResolved;
        if (totalResolved >= this._length) {
            var val;
            if (this._isMap) {
                val = entriesToMap(this._values);
            } else {
                val = {};
                var keyOffset = this.length();
                for (var i = 0, len = this.length(); i < len; ++i) {
                    val[this._values[i + keyOffset]] = this._values[i];
                }
            }
            this._resolve(val);
            return true;
        }
        return false;
    };

    PropertiesPromiseArray.prototype.shouldCopyValues = function () {
        return false;
    };

    PropertiesPromiseArray.prototype.getActualLength = function (len) {
        return len >> 1;
    };

    function props(promises) {
        var ret;
        var castValue = tryConvertToPromise(promises);

        if (!isObject(castValue)) {
            return apiRejection("cannot await properties of a non-object\u000a\u000a    See http://goo.gl/MqrFmX\u000a");
        } else if (castValue instanceof Promise) {
            ret = castValue._then(Promise.props, undefined, undefined, undefined, undefined);
        } else {
            ret = new PropertiesPromiseArray(castValue).promise();
        }

        if (castValue instanceof Promise) {
            ret._propagateFrom(castValue, 2);
        }
        return ret;
    }

    Promise.prototype.props = function () {
        return props(this);
    };

    Promise.props = function (promises) {
        return props(promises);
    };
};

/***/ }),
/* 93 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = function (Promise, INTERNAL, tryConvertToPromise, apiRejection) {
    var util = __webpack_require__(1);

    var raceLater = function (promise) {
        return promise.then(function (array) {
            return race(array, promise);
        });
    };

    function race(promises, parent) {
        var maybePromise = tryConvertToPromise(promises);

        if (maybePromise instanceof Promise) {
            return raceLater(maybePromise);
        } else {
            promises = util.asArray(promises);
            if (promises === null) return apiRejection("expecting an array or an iterable object but got " + util.classString(promises));
        }

        var ret = new Promise(INTERNAL);
        if (parent !== undefined) {
            ret._propagateFrom(parent, 3);
        }
        var fulfill = ret._fulfill;
        var reject = ret._reject;
        for (var i = 0, len = promises.length; i < len; ++i) {
            var val = promises[i];

            if (val === undefined && !(i in promises)) {
                continue;
            }

            Promise.cast(val)._then(fulfill, reject, undefined, ret, null);
        }
        return ret;
    }

    Promise.race = function (promises) {
        return race(promises, undefined);
    };

    Promise.prototype.race = function () {
        return race(this, undefined);
    };
};

/***/ }),
/* 94 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = function (Promise, PromiseArray, apiRejection, tryConvertToPromise, INTERNAL, debug) {
    var getDomain = Promise._getDomain;
    var util = __webpack_require__(1);
    var tryCatch = util.tryCatch;

    function ReductionPromiseArray(promises, fn, initialValue, _each) {
        this.constructor$(promises);
        var domain = getDomain();
        this._fn = domain === null ? fn : util.domainBind(domain, fn);
        if (initialValue !== undefined) {
            initialValue = Promise.resolve(initialValue);
            initialValue._attachCancellationCallback(this);
        }
        this._initialValue = initialValue;
        this._currentCancellable = null;
        if (_each === INTERNAL) {
            this._eachValues = Array(this._length);
        } else if (_each === 0) {
            this._eachValues = null;
        } else {
            this._eachValues = undefined;
        }
        this._promise._captureStackTrace();
        this._init$(undefined, -5);
    }
    util.inherits(ReductionPromiseArray, PromiseArray);

    ReductionPromiseArray.prototype._gotAccum = function (accum) {
        if (this._eachValues !== undefined && this._eachValues !== null && accum !== INTERNAL) {
            this._eachValues.push(accum);
        }
    };

    ReductionPromiseArray.prototype._eachComplete = function (value) {
        if (this._eachValues !== null) {
            this._eachValues.push(value);
        }
        return this._eachValues;
    };

    ReductionPromiseArray.prototype._init = function () {};

    ReductionPromiseArray.prototype._resolveEmptyArray = function () {
        this._resolve(this._eachValues !== undefined ? this._eachValues : this._initialValue);
    };

    ReductionPromiseArray.prototype.shouldCopyValues = function () {
        return false;
    };

    ReductionPromiseArray.prototype._resolve = function (value) {
        this._promise._resolveCallback(value);
        this._values = null;
    };

    ReductionPromiseArray.prototype._resultCancelled = function (sender) {
        if (sender === this._initialValue) return this._cancel();
        if (this._isResolved()) return;
        this._resultCancelled$();
        if (this._currentCancellable instanceof Promise) {
            this._currentCancellable.cancel();
        }
        if (this._initialValue instanceof Promise) {
            this._initialValue.cancel();
        }
    };

    ReductionPromiseArray.prototype._iterate = function (values) {
        this._values = values;
        var value;
        var i;
        var length = values.length;
        if (this._initialValue !== undefined) {
            value = this._initialValue;
            i = 0;
        } else {
            value = Promise.resolve(values[0]);
            i = 1;
        }

        this._currentCancellable = value;

        if (!value.isRejected()) {
            for (; i < length; ++i) {
                var ctx = {
                    accum: null,
                    value: values[i],
                    index: i,
                    length: length,
                    array: this
                };
                value = value._then(gotAccum, undefined, undefined, ctx, undefined);
            }
        }

        if (this._eachValues !== undefined) {
            value = value._then(this._eachComplete, undefined, undefined, this, undefined);
        }
        value._then(completed, completed, undefined, value, this);
    };

    Promise.prototype.reduce = function (fn, initialValue) {
        return reduce(this, fn, initialValue, null);
    };

    Promise.reduce = function (promises, fn, initialValue, _each) {
        return reduce(promises, fn, initialValue, _each);
    };

    function completed(valueOrReason, array) {
        if (this.isFulfilled()) {
            array._resolve(valueOrReason);
        } else {
            array._reject(valueOrReason);
        }
    }

    function reduce(promises, fn, initialValue, _each) {
        if (typeof fn !== "function") {
            return apiRejection("expecting a function but got " + util.classString(fn));
        }
        var array = new ReductionPromiseArray(promises, fn, initialValue, _each);
        return array.promise();
    }

    function gotAccum(accum) {
        this.accum = accum;
        this.array._gotAccum(accum);
        var value = tryConvertToPromise(this.value, this.array._promise);
        if (value instanceof Promise) {
            this.array._currentCancellable = value;
            return value._then(gotValue, undefined, undefined, this, undefined);
        } else {
            return gotValue.call(this, value);
        }
    }

    function gotValue(value) {
        var array = this.array;
        var promise = array._promise;
        var fn = tryCatch(array._fn);
        promise._pushContext();
        var ret;
        if (array._eachValues !== undefined) {
            ret = fn.call(promise._boundValue(), value, this.index, this.length);
        } else {
            ret = fn.call(promise._boundValue(), this.accum, value, this.index, this.length);
        }
        if (ret instanceof Promise) {
            array._currentCancellable = ret;
        }
        var promiseCreated = promise._popContext();
        debug.checkForgottenReturns(ret, promiseCreated, array._eachValues !== undefined ? "Promise.each" : "Promise.reduce", promise);
        return ret;
    }
};

/***/ }),
/* 95 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = function (Promise, PromiseArray, debug) {
    var PromiseInspection = Promise.PromiseInspection;
    var util = __webpack_require__(1);

    function SettledPromiseArray(values) {
        this.constructor$(values);
    }
    util.inherits(SettledPromiseArray, PromiseArray);

    SettledPromiseArray.prototype._promiseResolved = function (index, inspection) {
        this._values[index] = inspection;
        var totalResolved = ++this._totalResolved;
        if (totalResolved >= this._length) {
            this._resolve(this._values);
            return true;
        }
        return false;
    };

    SettledPromiseArray.prototype._promiseFulfilled = function (value, index) {
        var ret = new PromiseInspection();
        ret._bitField = 33554432;
        ret._settledValueField = value;
        return this._promiseResolved(index, ret);
    };
    SettledPromiseArray.prototype._promiseRejected = function (reason, index) {
        var ret = new PromiseInspection();
        ret._bitField = 16777216;
        ret._settledValueField = reason;
        return this._promiseResolved(index, ret);
    };

    Promise.settle = function (promises) {
        debug.deprecated(".settle()", ".reflect()");
        return new SettledPromiseArray(promises).promise();
    };

    Promise.prototype.settle = function () {
        return Promise.settle(this);
    };
};

/***/ }),
/* 96 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = function (Promise, PromiseArray, apiRejection) {
    var util = __webpack_require__(1);
    var RangeError = __webpack_require__(11).RangeError;
    var AggregateError = __webpack_require__(11).AggregateError;
    var isArray = util.isArray;
    var CANCELLATION = {};

    function SomePromiseArray(values) {
        this.constructor$(values);
        this._howMany = 0;
        this._unwrap = false;
        this._initialized = false;
    }
    util.inherits(SomePromiseArray, PromiseArray);

    SomePromiseArray.prototype._init = function () {
        if (!this._initialized) {
            return;
        }
        if (this._howMany === 0) {
            this._resolve([]);
            return;
        }
        this._init$(undefined, -5);
        var isArrayResolved = isArray(this._values);
        if (!this._isResolved() && isArrayResolved && this._howMany > this._canPossiblyFulfill()) {
            this._reject(this._getRangeError(this.length()));
        }
    };

    SomePromiseArray.prototype.init = function () {
        this._initialized = true;
        this._init();
    };

    SomePromiseArray.prototype.setUnwrap = function () {
        this._unwrap = true;
    };

    SomePromiseArray.prototype.howMany = function () {
        return this._howMany;
    };

    SomePromiseArray.prototype.setHowMany = function (count) {
        this._howMany = count;
    };

    SomePromiseArray.prototype._promiseFulfilled = function (value) {
        this._addFulfilled(value);
        if (this._fulfilled() === this.howMany()) {
            this._values.length = this.howMany();
            if (this.howMany() === 1 && this._unwrap) {
                this._resolve(this._values[0]);
            } else {
                this._resolve(this._values);
            }
            return true;
        }
        return false;
    };
    SomePromiseArray.prototype._promiseRejected = function (reason) {
        this._addRejected(reason);
        return this._checkOutcome();
    };

    SomePromiseArray.prototype._promiseCancelled = function () {
        if (this._values instanceof Promise || this._values == null) {
            return this._cancel();
        }
        this._addRejected(CANCELLATION);
        return this._checkOutcome();
    };

    SomePromiseArray.prototype._checkOutcome = function () {
        if (this.howMany() > this._canPossiblyFulfill()) {
            var e = new AggregateError();
            for (var i = this.length(); i < this._values.length; ++i) {
                if (this._values[i] !== CANCELLATION) {
                    e.push(this._values[i]);
                }
            }
            if (e.length > 0) {
                this._reject(e);
            } else {
                this._cancel();
            }
            return true;
        }
        return false;
    };

    SomePromiseArray.prototype._fulfilled = function () {
        return this._totalResolved;
    };

    SomePromiseArray.prototype._rejected = function () {
        return this._values.length - this.length();
    };

    SomePromiseArray.prototype._addRejected = function (reason) {
        this._values.push(reason);
    };

    SomePromiseArray.prototype._addFulfilled = function (value) {
        this._values[this._totalResolved++] = value;
    };

    SomePromiseArray.prototype._canPossiblyFulfill = function () {
        return this.length() - this._rejected();
    };

    SomePromiseArray.prototype._getRangeError = function (count) {
        var message = "Input array must contain at least " + this._howMany + " items but contains only " + count + " items";
        return new RangeError(message);
    };

    SomePromiseArray.prototype._resolveEmptyArray = function () {
        this._reject(this._getRangeError(0));
    };

    function some(promises, howMany) {
        if ((howMany | 0) !== howMany || howMany < 0) {
            return apiRejection("expecting a positive integer\u000a\u000a    See http://goo.gl/MqrFmX\u000a");
        }
        var ret = new SomePromiseArray(promises);
        var promise = ret.promise();
        ret.setHowMany(howMany);
        ret.init();
        return promise;
    }

    Promise.some = function (promises, howMany) {
        return some(promises, howMany);
    };

    Promise.prototype.some = function (howMany) {
        return some(this, howMany);
    };

    Promise._SomePromiseArray = SomePromiseArray;
};

/***/ }),
/* 97 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = function (Promise, INTERNAL) {
    var PromiseMap = Promise.map;

    Promise.prototype.filter = function (fn, options) {
        return PromiseMap(this, fn, options, INTERNAL);
    };

    Promise.filter = function (promises, fn, options) {
        return PromiseMap(promises, fn, options, INTERNAL);
    };
};

/***/ }),
/* 98 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = function (Promise, INTERNAL) {
    var PromiseReduce = Promise.reduce;
    var PromiseAll = Promise.all;

    function promiseAllThis() {
        return PromiseAll(this);
    }

    function PromiseMapSeries(promises, fn) {
        return PromiseReduce(promises, fn, INTERNAL, INTERNAL);
    }

    Promise.prototype.each = function (fn) {
        return PromiseReduce(this, fn, INTERNAL, 0)._then(promiseAllThis, undefined, undefined, this, undefined);
    };

    Promise.prototype.mapSeries = function (fn) {
        return PromiseReduce(this, fn, INTERNAL, INTERNAL);
    };

    Promise.each = function (promises, fn) {
        return PromiseReduce(promises, fn, INTERNAL, 0)._then(promiseAllThis, undefined, undefined, promises, undefined);
    };

    Promise.mapSeries = PromiseMapSeries;
};

/***/ }),
/* 99 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = function (Promise) {
    var SomePromiseArray = Promise._SomePromiseArray;
    function any(promises) {
        var ret = new SomePromiseArray(promises);
        var promise = ret.promise();
        ret.setHowMany(1);
        ret.setUnwrap();
        ret.init();
        return promise;
    }

    Promise.any = function (promises) {
        return any(promises);
    };

    Promise.prototype.any = function () {
        return any(this);
    };
};

/***/ }),
/* 100 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * Detect Electron renderer process, which is node, but we should
 * treat as a browser.
 */

if (typeof process === 'undefined' || process.type === 'renderer') {
  module.exports = __webpack_require__(101);
} else {
  module.exports = __webpack_require__(103);
}

/***/ }),
/* 101 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * This is the web browser implementation of `debug()`.
 *
 * Expose `debug()` as the module.
 */

exports = module.exports = __webpack_require__(43);
exports.log = log;
exports.formatArgs = formatArgs;
exports.save = save;
exports.load = load;
exports.useColors = useColors;
exports.storage = 'undefined' != typeof chrome && 'undefined' != typeof chrome.storage ? chrome.storage.local : localstorage();

/**
 * Colors.
 */

exports.colors = ['#0000CC', '#0000FF', '#0033CC', '#0033FF', '#0066CC', '#0066FF', '#0099CC', '#0099FF', '#00CC00', '#00CC33', '#00CC66', '#00CC99', '#00CCCC', '#00CCFF', '#3300CC', '#3300FF', '#3333CC', '#3333FF', '#3366CC', '#3366FF', '#3399CC', '#3399FF', '#33CC00', '#33CC33', '#33CC66', '#33CC99', '#33CCCC', '#33CCFF', '#6600CC', '#6600FF', '#6633CC', '#6633FF', '#66CC00', '#66CC33', '#9900CC', '#9900FF', '#9933CC', '#9933FF', '#99CC00', '#99CC33', '#CC0000', '#CC0033', '#CC0066', '#CC0099', '#CC00CC', '#CC00FF', '#CC3300', '#CC3333', '#CC3366', '#CC3399', '#CC33CC', '#CC33FF', '#CC6600', '#CC6633', '#CC9900', '#CC9933', '#CCCC00', '#CCCC33', '#FF0000', '#FF0033', '#FF0066', '#FF0099', '#FF00CC', '#FF00FF', '#FF3300', '#FF3333', '#FF3366', '#FF3399', '#FF33CC', '#FF33FF', '#FF6600', '#FF6633', '#FF9900', '#FF9933', '#FFCC00', '#FFCC33'];

/**
 * Currently only WebKit-based Web Inspectors, Firefox >= v31,
 * and the Firebug extension (any Firefox version) are known
 * to support "%c" CSS customizations.
 *
 * TODO: add a `localStorage` variable to explicitly enable/disable colors
 */

function useColors() {
  // NB: In an Electron preload script, document will be defined but not fully
  // initialized. Since we know we're in Chrome, we'll just detect this case
  // explicitly
  if (typeof window !== 'undefined' && window.process && window.process.type === 'renderer') {
    return true;
  }

  // Internet Explorer and Edge do not support colors.
  if (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
    return false;
  }

  // is webkit? http://stackoverflow.com/a/16459606/376773
  // document is undefined in react-native: https://github.com/facebook/react-native/pull/1632
  return typeof document !== 'undefined' && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance ||
  // is firebug? http://stackoverflow.com/a/398120/376773
  typeof window !== 'undefined' && window.console && (window.console.firebug || window.console.exception && window.console.table) ||
  // is firefox >= v31?
  // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
  typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31 ||
  // double check webkit in userAgent just in case we are in a worker
  typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
}

/**
 * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.
 */

exports.formatters.j = function (v) {
  try {
    return JSON.stringify(v);
  } catch (err) {
    return '[UnexpectedJSONParseError]: ' + err.message;
  }
};

/**
 * Colorize log arguments if enabled.
 *
 * @api public
 */

function formatArgs(args) {
  var useColors = this.useColors;

  args[0] = (useColors ? '%c' : '') + this.namespace + (useColors ? ' %c' : ' ') + args[0] + (useColors ? '%c ' : ' ') + '+' + exports.humanize(this.diff);

  if (!useColors) return;

  var c = 'color: ' + this.color;
  args.splice(1, 0, c, 'color: inherit');

  // the final "%c" is somewhat tricky, because there could be other
  // arguments passed either before or after the %c, so we need to
  // figure out the correct index to insert the CSS into
  var index = 0;
  var lastC = 0;
  args[0].replace(/%[a-zA-Z%]/g, function (match) {
    if ('%%' === match) return;
    index++;
    if ('%c' === match) {
      // we only are interested in the *last* %c
      // (the user may have provided their own)
      lastC = index;
    }
  });

  args.splice(lastC, 0, c);
}

/**
 * Invokes `console.log()` when available.
 * No-op when `console.log` is not a "function".
 *
 * @api public
 */

function log() {
  // this hackery is required for IE8/9, where
  // the `console.log` function doesn't have 'apply'
  return 'object' === typeof console && console.log && Function.prototype.apply.call(console.log, console, arguments);
}

/**
 * Save `namespaces`.
 *
 * @param {String} namespaces
 * @api private
 */

function save(namespaces) {
  try {
    if (null == namespaces) {
      exports.storage.removeItem('debug');
    } else {
      exports.storage.debug = namespaces;
    }
  } catch (e) {}
}

/**
 * Load `namespaces`.
 *
 * @return {String} returns the previously persisted debug modes
 * @api private
 */

function load() {
  var r;
  try {
    r = exports.storage.debug;
  } catch (e) {}

  // If debug isn't set in LS, and we're in Electron, try to load $DEBUG
  if (!r && typeof process !== 'undefined' && 'env' in process) {
    r = process.env.DEBUG;
  }

  return r;
}

/**
 * Enable namespaces listed in `localStorage.debug` initially.
 */

exports.enable(load());

/**
 * Localstorage attempts to return the localstorage.
 *
 * This is necessary because safari throws
 * when a user disables cookies/localstorage
 * and you attempt to access it.
 *
 * @return {LocalStorage}
 * @api private
 */

function localstorage() {
  try {
    return window.localStorage;
  } catch (e) {}
}

/***/ }),
/* 102 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * Helpers.
 */

var s = 1000;
var m = s * 60;
var h = m * 60;
var d = h * 24;
var y = d * 365.25;

/**
 * Parse or format the given `val`.
 *
 * Options:
 *
 *  - `long` verbose formatting [false]
 *
 * @param {String|Number} val
 * @param {Object} [options]
 * @throws {Error} throw an error if val is not a non-empty string or a number
 * @return {String|Number}
 * @api public
 */

module.exports = function (val, options) {
  options = options || {};
  var type = typeof val;
  if (type === 'string' && val.length > 0) {
    return parse(val);
  } else if (type === 'number' && isNaN(val) === false) {
    return options.long ? fmtLong(val) : fmtShort(val);
  }
  throw new Error('val is not a non-empty string or a valid number. val=' + JSON.stringify(val));
};

/**
 * Parse the given `str` and return milliseconds.
 *
 * @param {String} str
 * @return {Number}
 * @api private
 */

function parse(str) {
  str = String(str);
  if (str.length > 100) {
    return;
  }
  var match = /^((?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|years?|yrs?|y)?$/i.exec(str);
  if (!match) {
    return;
  }
  var n = parseFloat(match[1]);
  var type = (match[2] || 'ms').toLowerCase();
  switch (type) {
    case 'years':
    case 'year':
    case 'yrs':
    case 'yr':
    case 'y':
      return n * y;
    case 'days':
    case 'day':
    case 'd':
      return n * d;
    case 'hours':
    case 'hour':
    case 'hrs':
    case 'hr':
    case 'h':
      return n * h;
    case 'minutes':
    case 'minute':
    case 'mins':
    case 'min':
    case 'm':
      return n * m;
    case 'seconds':
    case 'second':
    case 'secs':
    case 'sec':
    case 's':
      return n * s;
    case 'milliseconds':
    case 'millisecond':
    case 'msecs':
    case 'msec':
    case 'ms':
      return n;
    default:
      return undefined;
  }
}

/**
 * Short format for `ms`.
 *
 * @param {Number} ms
 * @return {String}
 * @api private
 */

function fmtShort(ms) {
  if (ms >= d) {
    return Math.round(ms / d) + 'd';
  }
  if (ms >= h) {
    return Math.round(ms / h) + 'h';
  }
  if (ms >= m) {
    return Math.round(ms / m) + 'm';
  }
  if (ms >= s) {
    return Math.round(ms / s) + 's';
  }
  return ms + 'ms';
}

/**
 * Long format for `ms`.
 *
 * @param {Number} ms
 * @return {String}
 * @api private
 */

function fmtLong(ms) {
  return plural(ms, d, 'day') || plural(ms, h, 'hour') || plural(ms, m, 'minute') || plural(ms, s, 'second') || ms + ' ms';
}

/**
 * Pluralization helper.
 */

function plural(ms, n, name) {
  if (ms < n) {
    return;
  }
  if (ms < n * 1.5) {
    return Math.floor(ms / n) + ' ' + name;
  }
  return Math.ceil(ms / n) + ' ' + name + 's';
}

/***/ }),
/* 103 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * Module dependencies.
 */

var tty = __webpack_require__(104);
var util = __webpack_require__(29);

/**
 * This is the Node.js implementation of `debug()`.
 *
 * Expose `debug()` as the module.
 */

exports = module.exports = __webpack_require__(43);
exports.init = init;
exports.log = log;
exports.formatArgs = formatArgs;
exports.save = save;
exports.load = load;
exports.useColors = useColors;

/**
 * Colors.
 */

exports.colors = [6, 2, 3, 4, 5, 1];

try {
  var supportsColor = __webpack_require__(105);
  if (supportsColor && supportsColor.level >= 2) {
    exports.colors = [20, 21, 26, 27, 32, 33, 38, 39, 40, 41, 42, 43, 44, 45, 56, 57, 62, 63, 68, 69, 74, 75, 76, 77, 78, 79, 80, 81, 92, 93, 98, 99, 112, 113, 128, 129, 134, 135, 148, 149, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 178, 179, 184, 185, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 214, 215, 220, 221];
  }
} catch (err) {}
// swallow - we only care if `supports-color` is available; it doesn't have to be.


/**
 * Build up the default `inspectOpts` object from the environment variables.
 *
 *   $ DEBUG_COLORS=no DEBUG_DEPTH=10 DEBUG_SHOW_HIDDEN=enabled node script.js
 */

exports.inspectOpts = Object.keys(process.env).filter(function (key) {
  return (/^debug_/i.test(key)
  );
}).reduce(function (obj, key) {
  // camel-case
  var prop = key.substring(6).toLowerCase().replace(/_([a-z])/g, function (_, k) {
    return k.toUpperCase();
  });

  // coerce string value into JS value
  var val = process.env[key];
  if (/^(yes|on|true|enabled)$/i.test(val)) val = true;else if (/^(no|off|false|disabled)$/i.test(val)) val = false;else if (val === 'null') val = null;else val = Number(val);

  obj[prop] = val;
  return obj;
}, {});

/**
 * Is stdout a TTY? Colored output is enabled when `true`.
 */

function useColors() {
  return 'colors' in exports.inspectOpts ? Boolean(exports.inspectOpts.colors) : tty.isatty(process.stderr.fd);
}

/**
 * Map %o to `util.inspect()`, all on a single line.
 */

exports.formatters.o = function (v) {
  this.inspectOpts.colors = this.useColors;
  return util.inspect(v, this.inspectOpts).split('\n').map(function (str) {
    return str.trim();
  }).join(' ');
};

/**
 * Map %o to `util.inspect()`, allowing multiple lines if needed.
 */

exports.formatters.O = function (v) {
  this.inspectOpts.colors = this.useColors;
  return util.inspect(v, this.inspectOpts);
};

/**
 * Adds ANSI color escape codes if enabled.
 *
 * @api public
 */

function formatArgs(args) {
  var name = this.namespace;
  var useColors = this.useColors;

  if (useColors) {
    var c = this.color;
    var colorCode = '\u001b[3' + (c < 8 ? c : '8;5;' + c);
    var prefix = '  ' + colorCode + ';1m' + name + ' ' + '\u001b[0m';

    args[0] = prefix + args[0].split('\n').join('\n' + prefix);
    args.push(colorCode + 'm+' + exports.humanize(this.diff) + '\u001b[0m');
  } else {
    args[0] = getDate() + name + ' ' + args[0];
  }
}

function getDate() {
  if (exports.inspectOpts.hideDate) {
    return '';
  } else {
    return new Date().toISOString() + ' ';
  }
}

/**
 * Invokes `util.format()` with the specified arguments and writes to stderr.
 */

function log() {
  return process.stderr.write(util.format.apply(util, arguments) + '\n');
}

/**
 * Save `namespaces`.
 *
 * @param {String} namespaces
 * @api private
 */

function save(namespaces) {
  if (null == namespaces) {
    // If you set a process.env field to null or undefined, it gets cast to the
    // string 'null' or 'undefined'. Just delete instead.
    delete process.env.DEBUG;
  } else {
    process.env.DEBUG = namespaces;
  }
}

/**
 * Load `namespaces`.
 *
 * @return {String} returns the previously persisted debug modes
 * @api private
 */

function load() {
  return process.env.DEBUG;
}

/**
 * Init logic for `debug` instances.
 *
 * Create a new `inspectOpts` object in case `useColors` is set
 * differently for a particular `debug` instance.
 */

function init(debug) {
  debug.inspectOpts = {};

  var keys = Object.keys(exports.inspectOpts);
  for (var i = 0; i < keys.length; i++) {
    debug.inspectOpts[keys[i]] = exports.inspectOpts[keys[i]];
  }
}

/**
 * Enable namespaces listed in `process.env.DEBUG` initially.
 */

exports.enable(load());

/***/ }),
/* 104 */
/***/ (function(module, exports) {

module.exports = require("tty");

/***/ }),
/* 105 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const os = __webpack_require__(15);
const hasFlag = __webpack_require__(106);

const env = process.env;

const support = level => {
	if (level === 0) {
		return false;
	}

	return {
		level,
		hasBasic: true,
		has256: level >= 2,
		has16m: level >= 3
	};
};

let supportLevel = (() => {
	if (hasFlag('no-color') || hasFlag('no-colors') || hasFlag('color=false')) {
		return 0;
	}

	if (hasFlag('color=16m') || hasFlag('color=full') || hasFlag('color=truecolor')) {
		return 3;
	}

	if (hasFlag('color=256')) {
		return 2;
	}

	if (hasFlag('color') || hasFlag('colors') || hasFlag('color=true') || hasFlag('color=always')) {
		return 1;
	}

	if (process.stdout && !process.stdout.isTTY) {
		return 0;
	}

	if (process.platform === 'win32') {
		// Node.js 7.5.0 is the first version of Node.js to include a patch to
		// libuv that enables 256 color output on Windows. Anything earlier and it
		// won't work. However, here we target Node.js 8 at minimum as it is an LTS
		// release, and Node.js 7 is not. Windows 10 build 10586 is the first Windows
		// release that supports 256 colors.
		const osRelease = os.release().split('.');
		if (Number(process.versions.node.split('.')[0]) >= 8 && Number(osRelease[0]) >= 10 && Number(osRelease[2]) >= 10586) {
			return 2;
		}

		return 1;
	}

	if ('CI' in env) {
		if (['TRAVIS', 'CIRCLECI', 'APPVEYOR', 'GITLAB_CI'].some(sign => sign in env) || env.CI_NAME === 'codeship') {
			return 1;
		}

		return 0;
	}

	if ('TEAMCITY_VERSION' in env) {
		return (/^(9\.(0*[1-9]\d*)\.|\d{2,}\.)/.test(env.TEAMCITY_VERSION) ? 1 : 0
		);
	}

	if ('TERM_PROGRAM' in env) {
		const version = parseInt((env.TERM_PROGRAM_VERSION || '').split('.')[0], 10);

		switch (env.TERM_PROGRAM) {
			case 'iTerm.app':
				return version >= 3 ? 3 : 2;
			case 'Hyper':
				return 3;
			case 'Apple_Terminal':
				return 2;
			// No default
		}
	}

	if (/-256(color)?$/i.test(env.TERM)) {
		return 2;
	}

	if (/^screen|^xterm|^vt100|^rxvt|color|ansi|cygwin|linux/i.test(env.TERM)) {
		return 1;
	}

	if ('COLORTERM' in env) {
		return 1;
	}

	if (env.TERM === 'dumb') {
		return 0;
	}

	return 0;
})();

if ('FORCE_COLOR' in env) {
	supportLevel = parseInt(env.FORCE_COLOR, 10) === 0 ? 0 : supportLevel || 1;
}

module.exports = process && support(supportLevel);

/***/ }),
/* 106 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = function (flag, argv) {
	argv = argv || process.argv;

	var terminatorPos = argv.indexOf('--');
	var prefix = /^-{1,2}/.test(flag) ? '' : '--';
	var pos = argv.indexOf(prefix + flag);

	return pos !== -1 && (terminatorPos === -1 ? true : pos < terminatorPos);
};

/***/ }),
/* 107 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const assign = __webpack_require__(108);

const fs = {};

// Export graceful-fs:
assign(fs, __webpack_require__(44));
// Export extra methods:
assign(fs, __webpack_require__(112));
assign(fs, __webpack_require__(50));
assign(fs, __webpack_require__(7));
assign(fs, __webpack_require__(24));
assign(fs, __webpack_require__(117));
assign(fs, __webpack_require__(121));
assign(fs, __webpack_require__(122));
assign(fs, __webpack_require__(123));
assign(fs, __webpack_require__(124));
assign(fs, __webpack_require__(130));
assign(fs, __webpack_require__(13));

module.exports = fs;

/***/ }),
/* 108 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// simple mutable assign

function assign() {
  const args = [].slice.call(arguments).filter(i => i);
  const dest = args.shift();
  args.forEach(src => {
    Object.keys(src).forEach(key => {
      dest[key] = src[key];
    });
  });

  return dest;
}

module.exports = assign;

/***/ }),
/* 109 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var fs = __webpack_require__(45);
var constants = __webpack_require__(110);

var origCwd = process.cwd;
var cwd = null;

var platform = process.env.GRACEFUL_FS_PLATFORM || process.platform;

process.cwd = function () {
  if (!cwd) cwd = origCwd.call(process);
  return cwd;
};
try {
  process.cwd();
} catch (er) {}

var chdir = process.chdir;
process.chdir = function (d) {
  cwd = null;
  chdir.call(process, d);
};

module.exports = patch;

function patch(fs) {
  // (re-)implement some things that are known busted or missing.

  // lchmod, broken prior to 0.6.2
  // back-port the fix here.
  if (constants.hasOwnProperty('O_SYMLINK') && process.version.match(/^v0\.6\.[0-2]|^v0\.5\./)) {
    patchLchmod(fs);
  }

  // lutimes implementation, or no-op
  if (!fs.lutimes) {
    patchLutimes(fs);
  }

  // https://github.com/isaacs/node-graceful-fs/issues/4
  // Chown should not fail on einval or eperm if non-root.
  // It should not fail on enosys ever, as this just indicates
  // that a fs doesn't support the intended operation.

  fs.chown = chownFix(fs.chown);
  fs.fchown = chownFix(fs.fchown);
  fs.lchown = chownFix(fs.lchown);

  fs.chmod = chmodFix(fs.chmod);
  fs.fchmod = chmodFix(fs.fchmod);
  fs.lchmod = chmodFix(fs.lchmod);

  fs.chownSync = chownFixSync(fs.chownSync);
  fs.fchownSync = chownFixSync(fs.fchownSync);
  fs.lchownSync = chownFixSync(fs.lchownSync);

  fs.chmodSync = chmodFixSync(fs.chmodSync);
  fs.fchmodSync = chmodFixSync(fs.fchmodSync);
  fs.lchmodSync = chmodFixSync(fs.lchmodSync);

  fs.stat = statFix(fs.stat);
  fs.fstat = statFix(fs.fstat);
  fs.lstat = statFix(fs.lstat);

  fs.statSync = statFixSync(fs.statSync);
  fs.fstatSync = statFixSync(fs.fstatSync);
  fs.lstatSync = statFixSync(fs.lstatSync);

  // if lchmod/lchown do not exist, then make them no-ops
  if (!fs.lchmod) {
    fs.lchmod = function (path, mode, cb) {
      if (cb) process.nextTick(cb);
    };
    fs.lchmodSync = function () {};
  }
  if (!fs.lchown) {
    fs.lchown = function (path, uid, gid, cb) {
      if (cb) process.nextTick(cb);
    };
    fs.lchownSync = function () {};
  }

  // on Windows, A/V software can lock the directory, causing this
  // to fail with an EACCES or EPERM if the directory contains newly
  // created files.  Try again on failure, for up to 60 seconds.

  // Set the timeout this long because some Windows Anti-Virus, such as Parity
  // bit9, may lock files for up to a minute, causing npm package install
  // failures. Also, take care to yield the scheduler. Windows scheduling gives
  // CPU to a busy looping process, which can cause the program causing the lock
  // contention to be starved of CPU by node, so the contention doesn't resolve.
  if (platform === "win32") {
    fs.rename = function (fs$rename) {
      return function (from, to, cb) {
        var start = Date.now();
        var backoff = 0;
        fs$rename(from, to, function CB(er) {
          if (er && (er.code === "EACCES" || er.code === "EPERM") && Date.now() - start < 60000) {
            setTimeout(function () {
              fs.stat(to, function (stater, st) {
                if (stater && stater.code === "ENOENT") fs$rename(from, to, CB);else cb(er);
              });
            }, backoff);
            if (backoff < 100) backoff += 10;
            return;
          }
          if (cb) cb(er);
        });
      };
    }(fs.rename);
  }

  // if read() returns EAGAIN, then just try it again.
  fs.read = function (fs$read) {
    return function (fd, buffer, offset, length, position, callback_) {
      var callback;
      if (callback_ && typeof callback_ === 'function') {
        var eagCounter = 0;
        callback = function (er, _, __) {
          if (er && er.code === 'EAGAIN' && eagCounter < 10) {
            eagCounter++;
            return fs$read.call(fs, fd, buffer, offset, length, position, callback);
          }
          callback_.apply(this, arguments);
        };
      }
      return fs$read.call(fs, fd, buffer, offset, length, position, callback);
    };
  }(fs.read);

  fs.readSync = function (fs$readSync) {
    return function (fd, buffer, offset, length, position) {
      var eagCounter = 0;
      while (true) {
        try {
          return fs$readSync.call(fs, fd, buffer, offset, length, position);
        } catch (er) {
          if (er.code === 'EAGAIN' && eagCounter < 10) {
            eagCounter++;
            continue;
          }
          throw er;
        }
      }
    };
  }(fs.readSync);
}

function patchLchmod(fs) {
  fs.lchmod = function (path, mode, callback) {
    fs.open(path, constants.O_WRONLY | constants.O_SYMLINK, mode, function (err, fd) {
      if (err) {
        if (callback) callback(err);
        return;
      }
      // prefer to return the chmod error, if one occurs,
      // but still try to close, and report closing errors if they occur.
      fs.fchmod(fd, mode, function (err) {
        fs.close(fd, function (err2) {
          if (callback) callback(err || err2);
        });
      });
    });
  };

  fs.lchmodSync = function (path, mode) {
    var fd = fs.openSync(path, constants.O_WRONLY | constants.O_SYMLINK, mode);

    // prefer to return the chmod error, if one occurs,
    // but still try to close, and report closing errors if they occur.
    var threw = true;
    var ret;
    try {
      ret = fs.fchmodSync(fd, mode);
      threw = false;
    } finally {
      if (threw) {
        try {
          fs.closeSync(fd);
        } catch (er) {}
      } else {
        fs.closeSync(fd);
      }
    }
    return ret;
  };
}

function patchLutimes(fs) {
  if (constants.hasOwnProperty("O_SYMLINK")) {
    fs.lutimes = function (path, at, mt, cb) {
      fs.open(path, constants.O_SYMLINK, function (er, fd) {
        if (er) {
          if (cb) cb(er);
          return;
        }
        fs.futimes(fd, at, mt, function (er) {
          fs.close(fd, function (er2) {
            if (cb) cb(er || er2);
          });
        });
      });
    };

    fs.lutimesSync = function (path, at, mt) {
      var fd = fs.openSync(path, constants.O_SYMLINK);
      var ret;
      var threw = true;
      try {
        ret = fs.futimesSync(fd, at, mt);
        threw = false;
      } finally {
        if (threw) {
          try {
            fs.closeSync(fd);
          } catch (er) {}
        } else {
          fs.closeSync(fd);
        }
      }
      return ret;
    };
  } else {
    fs.lutimes = function (_a, _b, _c, cb) {
      if (cb) process.nextTick(cb);
    };
    fs.lutimesSync = function () {};
  }
}

function chmodFix(orig) {
  if (!orig) return orig;
  return function (target, mode, cb) {
    return orig.call(fs, target, mode, function (er) {
      if (chownErOk(er)) er = null;
      if (cb) cb.apply(this, arguments);
    });
  };
}

function chmodFixSync(orig) {
  if (!orig) return orig;
  return function (target, mode) {
    try {
      return orig.call(fs, target, mode);
    } catch (er) {
      if (!chownErOk(er)) throw er;
    }
  };
}

function chownFix(orig) {
  if (!orig) return orig;
  return function (target, uid, gid, cb) {
    return orig.call(fs, target, uid, gid, function (er) {
      if (chownErOk(er)) er = null;
      if (cb) cb.apply(this, arguments);
    });
  };
}

function chownFixSync(orig) {
  if (!orig) return orig;
  return function (target, uid, gid) {
    try {
      return orig.call(fs, target, uid, gid);
    } catch (er) {
      if (!chownErOk(er)) throw er;
    }
  };
}

function statFix(orig) {
  if (!orig) return orig;
  // Older versions of Node erroneously returned signed integers for
  // uid + gid.
  return function (target, cb) {
    return orig.call(fs, target, function (er, stats) {
      if (!stats) return cb.apply(this, arguments);
      if (stats.uid < 0) stats.uid += 0x100000000;
      if (stats.gid < 0) stats.gid += 0x100000000;
      if (cb) cb.apply(this, arguments);
    });
  };
}

function statFixSync(orig) {
  if (!orig) return orig;
  // Older versions of Node erroneously returned signed integers for
  // uid + gid.
  return function (target) {
    var stats = orig.call(fs, target);
    if (stats.uid < 0) stats.uid += 0x100000000;
    if (stats.gid < 0) stats.gid += 0x100000000;
    return stats;
  };
}

// ENOSYS means that the fs doesn't support the op. Just ignore
// that, because it doesn't matter.
//
// if there's no getuid, or if getuid() is something other
// than 0, and the error is EINVAL or EPERM, then just ignore
// it.
//
// This specific case is a silent failure in cp, install, tar,
// and most other unix tools that manage permissions.
//
// When running as root, or if other types of errors are
// encountered, then it's strict.
function chownErOk(er) {
  if (!er) return true;

  if (er.code === "ENOSYS") return true;

  var nonroot = !process.getuid || process.getuid() !== 0;
  if (nonroot) {
    if (er.code === "EINVAL" || er.code === "EPERM") return true;
  }

  return false;
}

/***/ }),
/* 110 */
/***/ (function(module, exports) {

module.exports = require("constants");

/***/ }),
/* 111 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var Stream = __webpack_require__(19).Stream;

module.exports = legacy;

function legacy(fs) {
  return {
    ReadStream: ReadStream,
    WriteStream: WriteStream
  };

  function ReadStream(path, options) {
    if (!(this instanceof ReadStream)) return new ReadStream(path, options);

    Stream.call(this);

    var self = this;

    this.path = path;
    this.fd = null;
    this.readable = true;
    this.paused = false;

    this.flags = 'r';
    this.mode = 438; /*=0666*/
    this.bufferSize = 64 * 1024;

    options = options || {};

    // Mixin options into this
    var keys = Object.keys(options);
    for (var index = 0, length = keys.length; index < length; index++) {
      var key = keys[index];
      this[key] = options[key];
    }

    if (this.encoding) this.setEncoding(this.encoding);

    if (this.start !== undefined) {
      if ('number' !== typeof this.start) {
        throw TypeError('start must be a Number');
      }
      if (this.end === undefined) {
        this.end = Infinity;
      } else if ('number' !== typeof this.end) {
        throw TypeError('end must be a Number');
      }

      if (this.start > this.end) {
        throw new Error('start must be <= end');
      }

      this.pos = this.start;
    }

    if (this.fd !== null) {
      process.nextTick(function () {
        self._read();
      });
      return;
    }

    fs.open(this.path, this.flags, this.mode, function (err, fd) {
      if (err) {
        self.emit('error', err);
        self.readable = false;
        return;
      }

      self.fd = fd;
      self.emit('open', fd);
      self._read();
    });
  }

  function WriteStream(path, options) {
    if (!(this instanceof WriteStream)) return new WriteStream(path, options);

    Stream.call(this);

    this.path = path;
    this.fd = null;
    this.writable = true;

    this.flags = 'w';
    this.encoding = 'binary';
    this.mode = 438; /*=0666*/
    this.bytesWritten = 0;

    options = options || {};

    // Mixin options into this
    var keys = Object.keys(options);
    for (var index = 0, length = keys.length; index < length; index++) {
      var key = keys[index];
      this[key] = options[key];
    }

    if (this.start !== undefined) {
      if ('number' !== typeof this.start) {
        throw TypeError('start must be a Number');
      }
      if (this.start < 0) {
        throw new Error('start must be >= zero');
      }

      this.pos = this.start;
    }

    this.busy = false;
    this._queue = [];

    if (this.fd === null) {
      this._open = fs.open;
      this._queue.push([this._open, this.path, this.flags, this.mode, undefined]);
      this.flush();
    }
  }
}

/***/ }),
/* 112 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const u = __webpack_require__(6).fromCallback;
module.exports = {
  copy: u(__webpack_require__(47))
};

/***/ }),
/* 113 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const fs = __webpack_require__(5);
const path = __webpack_require__(0);
const invalidWin32Path = __webpack_require__(48).invalidWin32Path;

const o777 = parseInt('0777', 8);

function mkdirs(p, opts, callback, made) {
  if (typeof opts === 'function') {
    callback = opts;
    opts = {};
  } else if (!opts || typeof opts !== 'object') {
    opts = { mode: opts };
  }

  if (process.platform === 'win32' && invalidWin32Path(p)) {
    const errInval = new Error(p + ' contains invalid WIN32 path characters.');
    errInval.code = 'EINVAL';
    return callback(errInval);
  }

  let mode = opts.mode;
  const xfs = opts.fs || fs;

  if (mode === undefined) {
    mode = o777 & ~process.umask();
  }
  if (!made) made = null;

  callback = callback || function () {};
  p = path.resolve(p);

  xfs.mkdir(p, mode, er => {
    if (!er) {
      made = made || p;
      return callback(null, made);
    }
    switch (er.code) {
      case 'ENOENT':
        if (path.dirname(p) === p) return callback(er);
        mkdirs(path.dirname(p), opts, (er, made) => {
          if (er) callback(er, made);else mkdirs(p, opts, callback, made);
        });
        break;

      // In the case of any other error, just see if there's a dir
      // there already.  If so, then hooray!  If not, then something
      // is borked.
      default:
        xfs.stat(p, (er2, stat) => {
          // if the stat fails, then that's super weird.
          // let the original error be the failure reason.
          if (er2 || !stat.isDirectory()) callback(er, made);else callback(null, made);
        });
        break;
    }
  });
}

module.exports = mkdirs;

/***/ }),
/* 114 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const fs = __webpack_require__(5);
const path = __webpack_require__(0);
const invalidWin32Path = __webpack_require__(48).invalidWin32Path;

const o777 = parseInt('0777', 8);

function mkdirsSync(p, opts, made) {
  if (!opts || typeof opts !== 'object') {
    opts = { mode: opts };
  }

  let mode = opts.mode;
  const xfs = opts.fs || fs;

  if (process.platform === 'win32' && invalidWin32Path(p)) {
    const errInval = new Error(p + ' contains invalid WIN32 path characters.');
    errInval.code = 'EINVAL';
    throw errInval;
  }

  if (mode === undefined) {
    mode = o777 & ~process.umask();
  }
  if (!made) made = null;

  p = path.resolve(p);

  try {
    xfs.mkdirSync(p, mode);
    made = made || p;
  } catch (err0) {
    switch (err0.code) {
      case 'ENOENT':
        if (path.dirname(p) === p) throw err0;
        made = mkdirsSync(path.dirname(p), opts, made);
        mkdirsSync(p, opts, made);
        break;

      // In the case of any other error, just see if there's a dir
      // there already.  If so, then hooray!  If not, then something
      // is borked.
      default:
        let stat;
        try {
          stat = xfs.statSync(p);
        } catch (err1) {
          throw err0;
        }
        if (!stat.isDirectory()) throw err0;
        break;
    }
  }

  return made;
}

module.exports = mkdirsSync;

/***/ }),
/* 115 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const fs = __webpack_require__(5);
const path = __webpack_require__(0);
const mkdirpSync = __webpack_require__(7).mkdirsSync;
const utimesSync = __webpack_require__(49).utimesMillisSync;

const notExist = Symbol('notExist');
const existsReg = Symbol('existsReg');

function copySync(src, dest, opts) {
  if (typeof opts === 'function') {
    opts = { filter: opts };
  }

  opts = opts || {};
  opts.clobber = 'clobber' in opts ? !!opts.clobber : true; // default to true for now
  opts.overwrite = 'overwrite' in opts ? !!opts.overwrite : opts.clobber; // overwrite falls back to clobber

  // Warn about using preserveTimestamps on 32-bit node
  if (opts.preserveTimestamps && process.arch === 'ia32') {
    console.warn(`fs-extra: Using the preserveTimestamps option in 32-bit node is not recommended;\n
    see https://github.com/jprichardson/node-fs-extra/issues/269`);
  }

  src = path.resolve(src);
  dest = path.resolve(dest);

  // don't allow src and dest to be the same
  if (src === dest) throw new Error('Source and destination must not be the same.');

  if (opts.filter && !opts.filter(src, dest)) return;

  const destParent = path.dirname(dest);
  if (!fs.existsSync(destParent)) mkdirpSync(destParent);
  return startCopy(src, dest, opts);
}

function startCopy(src, dest, opts) {
  if (opts.filter && !opts.filter(src, dest)) return;
  return getStats(src, dest, opts);
}

function getStats(src, dest, opts) {
  const statSync = opts.dereference ? fs.statSync : fs.lstatSync;
  const st = statSync(src);

  if (st.isDirectory()) return onDir(st, src, dest, opts);else if (st.isFile() || st.isCharacterDevice() || st.isBlockDevice()) return onFile(st, src, dest, opts);else if (st.isSymbolicLink()) return onLink(src, dest, opts);
}

function onFile(srcStat, src, dest, opts) {
  const resolvedPath = checkDest(dest);
  if (resolvedPath === notExist) {
    return copyFile(srcStat, src, dest, opts);
  } else if (resolvedPath === existsReg) {
    return mayCopyFile(srcStat, src, dest, opts);
  } else {
    if (src === resolvedPath) return;
    return mayCopyFile(srcStat, src, dest, opts);
  }
}

function mayCopyFile(srcStat, src, dest, opts) {
  if (opts.overwrite) {
    fs.unlinkSync(dest);
    return copyFile(srcStat, src, dest, opts);
  } else if (opts.errorOnExist) {
    throw new Error(`'${dest}' already exists`);
  }
}

function copyFile(srcStat, src, dest, opts) {
  if (typeof fs.copyFileSync === 'function') {
    fs.copyFileSync(src, dest);
    fs.chmodSync(dest, srcStat.mode);
    if (opts.preserveTimestamps) {
      return utimesSync(dest, srcStat.atime, srcStat.mtime);
    }
    return;
  }
  return copyFileFallback(srcStat, src, dest, opts);
}

function copyFileFallback(srcStat, src, dest, opts) {
  const BUF_LENGTH = 64 * 1024;
  const _buff = __webpack_require__(51)(BUF_LENGTH);

  const fdr = fs.openSync(src, 'r');
  const fdw = fs.openSync(dest, 'w', srcStat.mode);
  let bytesRead = 1;
  let pos = 0;

  while (bytesRead > 0) {
    bytesRead = fs.readSync(fdr, _buff, 0, BUF_LENGTH, pos);
    fs.writeSync(fdw, _buff, 0, bytesRead);
    pos += bytesRead;
  }

  if (opts.preserveTimestamps) fs.futimesSync(fdw, srcStat.atime, srcStat.mtime);

  fs.closeSync(fdr);
  fs.closeSync(fdw);
}

function onDir(srcStat, src, dest, opts) {
  const resolvedPath = checkDest(dest);
  if (resolvedPath === notExist) {
    if (isSrcSubdir(src, dest)) {
      throw new Error(`Cannot copy '${src}' to a subdirectory of itself, '${dest}'.`);
    }
    return mkDirAndCopy(srcStat, src, dest, opts);
  } else if (resolvedPath === existsReg) {
    if (isSrcSubdir(src, dest)) {
      throw new Error(`Cannot copy '${src}' to a subdirectory of itself, '${dest}'.`);
    }
    return mayCopyDir(src, dest, opts);
  } else {
    if (src === resolvedPath) return;
    return copyDir(src, dest, opts);
  }
}

function mayCopyDir(src, dest, opts) {
  if (!fs.statSync(dest).isDirectory()) {
    throw new Error(`Cannot overwrite non-directory '${dest}' with directory '${src}'.`);
  }
  return copyDir(src, dest, opts);
}

function mkDirAndCopy(srcStat, src, dest, opts) {
  fs.mkdirSync(dest, srcStat.mode);
  fs.chmodSync(dest, srcStat.mode);
  return copyDir(src, dest, opts);
}

function copyDir(src, dest, opts) {
  fs.readdirSync(src).forEach(item => {
    startCopy(path.join(src, item), path.join(dest, item), opts);
  });
}

function onLink(src, dest, opts) {
  let resolvedSrcPath = fs.readlinkSync(src);

  if (opts.dereference) {
    resolvedSrcPath = path.resolve(process.cwd(), resolvedSrcPath);
  }

  let resolvedDestPath = checkDest(dest);
  if (resolvedDestPath === notExist || resolvedDestPath === existsReg) {
    // if dest already exists, fs throws error anyway,
    // so no need to guard against it here.
    return fs.symlinkSync(resolvedSrcPath, dest);
  } else {
    if (opts.dereference) {
      resolvedDestPath = path.resolve(process.cwd(), resolvedDestPath);
    }
    if (resolvedDestPath === resolvedSrcPath) return;

    // prevent copy if src is a subdir of dest since unlinking
    // dest in this case would result in removing src contents
    // and therefore a broken symlink would be created.
    if (fs.statSync(dest).isDirectory() && isSrcSubdir(resolvedDestPath, resolvedSrcPath)) {
      throw new Error(`Cannot overwrite '${resolvedDestPath}' with '${resolvedSrcPath}'.`);
    }
    return copyLink(resolvedSrcPath, dest);
  }
}

function copyLink(resolvedSrcPath, dest) {
  fs.unlinkSync(dest);
  return fs.symlinkSync(resolvedSrcPath, dest);
}

// check if dest exists and/or is a symlink
function checkDest(dest) {
  let resolvedPath;
  try {
    resolvedPath = fs.readlinkSync(dest);
  } catch (err) {
    if (err.code === 'ENOENT') return notExist;

    // dest exists and is a regular file or directory, Windows may throw UNKNOWN error
    if (err.code === 'EINVAL' || err.code === 'UNKNOWN') return existsReg;

    throw err;
  }
  return resolvedPath; // dest exists and is a symlink
}

// return true if dest is a subdir of src, otherwise false.
// extract dest base dir and check if that is the same as src basename
function isSrcSubdir(src, dest) {
  const baseDir = dest.split(path.dirname(src) + path.sep)[1];
  if (baseDir) {
    const destBasename = baseDir.split(path.sep)[0];
    if (destBasename) {
      return src !== dest && dest.indexOf(src) > -1 && destBasename === path.basename(src);
    }
    return false;
  }
  return false;
}

module.exports = copySync;

/***/ }),
/* 116 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const fs = __webpack_require__(5);
const path = __webpack_require__(0);
const assert = __webpack_require__(46);

const isWindows = process.platform === 'win32';

function defaults(options) {
  const methods = ['unlink', 'chmod', 'stat', 'lstat', 'rmdir', 'readdir'];
  methods.forEach(m => {
    options[m] = options[m] || fs[m];
    m = m + 'Sync';
    options[m] = options[m] || fs[m];
  });

  options.maxBusyTries = options.maxBusyTries || 3;
}

function rimraf(p, options, cb) {
  let busyTries = 0;

  if (typeof options === 'function') {
    cb = options;
    options = {};
  }

  assert(p, 'rimraf: missing path');
  assert.equal(typeof p, 'string', 'rimraf: path should be a string');
  assert.equal(typeof cb, 'function', 'rimraf: callback function required');
  assert(options, 'rimraf: invalid options argument provided');
  assert.equal(typeof options, 'object', 'rimraf: options should be object');

  defaults(options);

  rimraf_(p, options, function CB(er) {
    if (er) {
      if ((er.code === 'EBUSY' || er.code === 'ENOTEMPTY' || er.code === 'EPERM') && busyTries < options.maxBusyTries) {
        busyTries++;
        let time = busyTries * 100;
        // try again, with the same exact callback as this one.
        return setTimeout(() => rimraf_(p, options, CB), time);
      }

      // already gone
      if (er.code === 'ENOENT') er = null;
    }

    cb(er);
  });
}

// Two possible strategies.
// 1. Assume it's a file.  unlink it, then do the dir stuff on EPERM or EISDIR
// 2. Assume it's a directory.  readdir, then do the file stuff on ENOTDIR
//
// Both result in an extra syscall when you guess wrong.  However, there
// are likely far more normal files in the world than directories.  This
// is based on the assumption that a the average number of files per
// directory is >= 1.
//
// If anyone ever complains about this, then I guess the strategy could
// be made configurable somehow.  But until then, YAGNI.
function rimraf_(p, options, cb) {
  assert(p);
  assert(options);
  assert(typeof cb === 'function');

  // sunos lets the root user unlink directories, which is... weird.
  // so we have to lstat here and make sure it's not a dir.
  options.lstat(p, (er, st) => {
    if (er && er.code === 'ENOENT') {
      return cb(null);
    }

    // Windows can EPERM on stat.  Life is suffering.
    if (er && er.code === 'EPERM' && isWindows) {
      return fixWinEPERM(p, options, er, cb);
    }

    if (st && st.isDirectory()) {
      return rmdir(p, options, er, cb);
    }

    options.unlink(p, er => {
      if (er) {
        if (er.code === 'ENOENT') {
          return cb(null);
        }
        if (er.code === 'EPERM') {
          return isWindows ? fixWinEPERM(p, options, er, cb) : rmdir(p, options, er, cb);
        }
        if (er.code === 'EISDIR') {
          return rmdir(p, options, er, cb);
        }
      }
      return cb(er);
    });
  });
}

function fixWinEPERM(p, options, er, cb) {
  assert(p);
  assert(options);
  assert(typeof cb === 'function');
  if (er) {
    assert(er instanceof Error);
  }

  options.chmod(p, 0o666, er2 => {
    if (er2) {
      cb(er2.code === 'ENOENT' ? null : er);
    } else {
      options.stat(p, (er3, stats) => {
        if (er3) {
          cb(er3.code === 'ENOENT' ? null : er);
        } else if (stats.isDirectory()) {
          rmdir(p, options, er, cb);
        } else {
          options.unlink(p, cb);
        }
      });
    }
  });
}

function fixWinEPERMSync(p, options, er) {
  let stats;

  assert(p);
  assert(options);
  if (er) {
    assert(er instanceof Error);
  }

  try {
    options.chmodSync(p, 0o666);
  } catch (er2) {
    if (er2.code === 'ENOENT') {
      return;
    } else {
      throw er;
    }
  }

  try {
    stats = options.statSync(p);
  } catch (er3) {
    if (er3.code === 'ENOENT') {
      return;
    } else {
      throw er;
    }
  }

  if (stats.isDirectory()) {
    rmdirSync(p, options, er);
  } else {
    options.unlinkSync(p);
  }
}

function rmdir(p, options, originalEr, cb) {
  assert(p);
  assert(options);
  if (originalEr) {
    assert(originalEr instanceof Error);
  }
  assert(typeof cb === 'function');

  // try to rmdir first, and only readdir on ENOTEMPTY or EEXIST (SunOS)
  // if we guessed wrong, and it's not a directory, then
  // raise the original error.
  options.rmdir(p, er => {
    if (er && (er.code === 'ENOTEMPTY' || er.code === 'EEXIST' || er.code === 'EPERM')) {
      rmkids(p, options, cb);
    } else if (er && er.code === 'ENOTDIR') {
      cb(originalEr);
    } else {
      cb(er);
    }
  });
}

function rmkids(p, options, cb) {
  assert(p);
  assert(options);
  assert(typeof cb === 'function');

  options.readdir(p, (er, files) => {
    if (er) return cb(er);

    let n = files.length;
    let errState;

    if (n === 0) return options.rmdir(p, cb);

    files.forEach(f => {
      rimraf(path.join(p, f), options, er => {
        if (errState) {
          return;
        }
        if (er) return cb(errState = er);
        if (--n === 0) {
          options.rmdir(p, cb);
        }
      });
    });
  });
}

// this looks simpler, and is strictly *faster*, but will
// tie up the JavaScript thread and fail on excessively
// deep directory trees.
function rimrafSync(p, options) {
  let st;

  options = options || {};
  defaults(options);

  assert(p, 'rimraf: missing path');
  assert.equal(typeof p, 'string', 'rimraf: path should be a string');
  assert(options, 'rimraf: missing options');
  assert.equal(typeof options, 'object', 'rimraf: options should be object');

  try {
    st = options.lstatSync(p);
  } catch (er) {
    if (er.code === 'ENOENT') {
      return;
    }

    // Windows can EPERM on stat.  Life is suffering.
    if (er.code === 'EPERM' && isWindows) {
      fixWinEPERMSync(p, options, er);
    }
  }

  try {
    // sunos lets the root user unlink directories, which is... weird.
    if (st && st.isDirectory()) {
      rmdirSync(p, options, null);
    } else {
      options.unlinkSync(p);
    }
  } catch (er) {
    if (er.code === 'ENOENT') {
      return;
    } else if (er.code === 'EPERM') {
      return isWindows ? fixWinEPERMSync(p, options, er) : rmdirSync(p, options, er);
    } else if (er.code !== 'EISDIR') {
      throw er;
    }
    rmdirSync(p, options, er);
  }
}

function rmdirSync(p, options, originalEr) {
  assert(p);
  assert(options);
  if (originalEr) {
    assert(originalEr instanceof Error);
  }

  try {
    options.rmdirSync(p);
  } catch (er) {
    if (er.code === 'ENOTDIR') {
      throw originalEr;
    } else if (er.code === 'ENOTEMPTY' || er.code === 'EEXIST' || er.code === 'EPERM') {
      rmkidsSync(p, options);
    } else if (er.code !== 'ENOENT') {
      throw er;
    }
  }
}

function rmkidsSync(p, options) {
  assert(p);
  assert(options);
  options.readdirSync(p).forEach(f => rimrafSync(path.join(p, f), options));

  // We only end up here once we got ENOTEMPTY at least once, and
  // at this point, we are guaranteed to have removed all the kids.
  // So, we know that it won't be ENOENT or ENOTDIR or anything else.
  // try really hard to delete stuff on windows, because it has a
  // PROFOUNDLY annoying habit of not closing handles promptly when
  // files are deleted, resulting in spurious ENOTEMPTY errors.
  const retries = isWindows ? 100 : 1;
  let i = 0;
  do {
    let threw = true;
    try {
      const ret = options.rmdirSync(p, options);
      threw = false;
      return ret;
    } finally {
      if (++i < retries && threw) continue; // eslint-disable-line
    }
  } while (true);
}

module.exports = rimraf;
rimraf.sync = rimrafSync;

/***/ }),
/* 117 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const u = __webpack_require__(6).fromCallback;
const jsonFile = __webpack_require__(30);

jsonFile.outputJson = u(__webpack_require__(119));
jsonFile.outputJsonSync = __webpack_require__(120);
// aliases
jsonFile.outputJSON = jsonFile.outputJson;
jsonFile.outputJSONSync = jsonFile.outputJsonSync;
jsonFile.writeJSON = jsonFile.writeJson;
jsonFile.writeJSONSync = jsonFile.writeJsonSync;
jsonFile.readJSON = jsonFile.readJson;
jsonFile.readJSONSync = jsonFile.readJsonSync;

module.exports = jsonFile;

/***/ }),
/* 118 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _fs;
try {
  _fs = __webpack_require__(5);
} catch (_) {
  _fs = __webpack_require__(12);
}

function readFile(file, options, callback) {
  if (callback == null) {
    callback = options;
    options = {};
  }

  if (typeof options === 'string') {
    options = { encoding: options };
  }

  options = options || {};
  var fs = options.fs || _fs;

  var shouldThrow = true;
  if ('throws' in options) {
    shouldThrow = options.throws;
  }

  fs.readFile(file, options, function (err, data) {
    if (err) return callback(err);

    data = stripBom(data);

    var obj;
    try {
      obj = JSON.parse(data, options ? options.reviver : null);
    } catch (err2) {
      if (shouldThrow) {
        err2.message = file + ': ' + err2.message;
        return callback(err2);
      } else {
        return callback(null, null);
      }
    }

    callback(null, obj);
  });
}

function readFileSync(file, options) {
  options = options || {};
  if (typeof options === 'string') {
    options = { encoding: options };
  }

  var fs = options.fs || _fs;

  var shouldThrow = true;
  if ('throws' in options) {
    shouldThrow = options.throws;
  }

  try {
    var content = fs.readFileSync(file, options);
    content = stripBom(content);
    return JSON.parse(content, options.reviver);
  } catch (err) {
    if (shouldThrow) {
      err.message = file + ': ' + err.message;
      throw err;
    } else {
      return null;
    }
  }
}

function stringify(obj, options) {
  var spaces;
  var EOL = '\n';
  if (typeof options === 'object' && options !== null) {
    if (options.spaces) {
      spaces = options.spaces;
    }
    if (options.EOL) {
      EOL = options.EOL;
    }
  }

  var str = JSON.stringify(obj, options ? options.replacer : null, spaces);

  return str.replace(/\n/g, EOL) + EOL;
}

function writeFile(file, obj, options, callback) {
  if (callback == null) {
    callback = options;
    options = {};
  }
  options = options || {};
  var fs = options.fs || _fs;

  var str = '';
  try {
    str = stringify(obj, options);
  } catch (err) {
    // Need to return whether a callback was passed or not
    if (callback) callback(err, null);
    return;
  }

  fs.writeFile(file, str, options, callback);
}

function writeFileSync(file, obj, options) {
  options = options || {};
  var fs = options.fs || _fs;

  var str = stringify(obj, options);
  // not sure if fs.writeFileSync returns anything, but just in case
  return fs.writeFileSync(file, str, options);
}

function stripBom(content) {
  // we do this because JSON.parse would convert it to a utf8 string if encoding wasn't specified
  if (Buffer.isBuffer(content)) content = content.toString('utf8');
  content = content.replace(/^\uFEFF/, '');
  return content;
}

var jsonfile = {
  readFile: readFile,
  readFileSync: readFileSync,
  writeFile: writeFile,
  writeFileSync: writeFileSync
};

module.exports = jsonfile;

/***/ }),
/* 119 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const path = __webpack_require__(0);
const mkdir = __webpack_require__(7);
const pathExists = __webpack_require__(13).pathExists;
const jsonFile = __webpack_require__(30);

function outputJson(file, data, options, callback) {
  if (typeof options === 'function') {
    callback = options;
    options = {};
  }

  const dir = path.dirname(file);

  pathExists(dir, (err, itDoes) => {
    if (err) return callback(err);
    if (itDoes) return jsonFile.writeJson(file, data, options, callback);

    mkdir.mkdirs(dir, err => {
      if (err) return callback(err);
      jsonFile.writeJson(file, data, options, callback);
    });
  });
}

module.exports = outputJson;

/***/ }),
/* 120 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const fs = __webpack_require__(5);
const path = __webpack_require__(0);
const mkdir = __webpack_require__(7);
const jsonFile = __webpack_require__(30);

function outputJsonSync(file, data, options) {
  const dir = path.dirname(file);

  if (!fs.existsSync(dir)) {
    mkdir.mkdirsSync(dir);
  }

  jsonFile.writeJsonSync(file, data, options);
}

module.exports = outputJsonSync;

/***/ }),
/* 121 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// most of this code was written by Andrew Kelley
// licensed under the BSD license: see
// https://github.com/andrewrk/node-mv/blob/master/package.json

// this needs a cleanup

const u = __webpack_require__(6).fromCallback;
const fs = __webpack_require__(5);
const copy = __webpack_require__(47);
const path = __webpack_require__(0);
const remove = __webpack_require__(24).remove;
const mkdirp = __webpack_require__(7).mkdirs;

function move(src, dest, options, callback) {
  if (typeof options === 'function') {
    callback = options;
    options = {};
  }

  const overwrite = options.overwrite || options.clobber || false;

  isSrcSubdir(src, dest, (err, itIs) => {
    if (err) return callback(err);
    if (itIs) return callback(new Error(`Cannot move '${src}' to a subdirectory of itself, '${dest}'.`));
    mkdirp(path.dirname(dest), err => {
      if (err) return callback(err);
      doRename();
    });
  });

  function doRename() {
    if (path.resolve(src) === path.resolve(dest)) {
      fs.access(src, callback);
    } else if (overwrite) {
      fs.rename(src, dest, err => {
        if (!err) return callback();

        if (err.code === 'ENOTEMPTY' || err.code === 'EEXIST') {
          remove(dest, err => {
            if (err) return callback(err);
            options.overwrite = false; // just overwriteed it, no need to do it again
            move(src, dest, options, callback);
          });
          return;
        }

        // weird Windows shit
        if (err.code === 'EPERM') {
          setTimeout(() => {
            remove(dest, err => {
              if (err) return callback(err);
              options.overwrite = false;
              move(src, dest, options, callback);
            });
          }, 200);
          return;
        }

        if (err.code !== 'EXDEV') return callback(err);
        moveAcrossDevice(src, dest, overwrite, callback);
      });
    } else {
      fs.link(src, dest, err => {
        if (err) {
          if (err.code === 'EXDEV' || err.code === 'EISDIR' || err.code === 'EPERM' || err.code === 'ENOTSUP') {
            return moveAcrossDevice(src, dest, overwrite, callback);
          }
          return callback(err);
        }
        return fs.unlink(src, callback);
      });
    }
  }
}

function moveAcrossDevice(src, dest, overwrite, callback) {
  fs.stat(src, (err, stat) => {
    if (err) return callback(err);

    if (stat.isDirectory()) {
      moveDirAcrossDevice(src, dest, overwrite, callback);
    } else {
      moveFileAcrossDevice(src, dest, overwrite, callback);
    }
  });
}

function moveFileAcrossDevice(src, dest, overwrite, callback) {
  const flags = overwrite ? 'w' : 'wx';
  const ins = fs.createReadStream(src);
  const outs = fs.createWriteStream(dest, { flags });

  ins.on('error', err => {
    ins.destroy();
    outs.destroy();
    outs.removeListener('close', onClose);

    // may want to create a directory but `out` line above
    // creates an empty file for us: See #108
    // don't care about error here
    fs.unlink(dest, () => {
      // note: `err` here is from the input stream errror
      if (err.code === 'EISDIR' || err.code === 'EPERM') {
        moveDirAcrossDevice(src, dest, overwrite, callback);
      } else {
        callback(err);
      }
    });
  });

  outs.on('error', err => {
    ins.destroy();
    outs.destroy();
    outs.removeListener('close', onClose);
    callback(err);
  });

  outs.once('close', onClose);
  ins.pipe(outs);

  function onClose() {
    fs.unlink(src, callback);
  }
}

function moveDirAcrossDevice(src, dest, overwrite, callback) {
  const options = {
    overwrite: false
  };

  if (overwrite) {
    remove(dest, err => {
      if (err) return callback(err);
      startCopy();
    });
  } else {
    startCopy();
  }

  function startCopy() {
    copy(src, dest, options, err => {
      if (err) return callback(err);
      remove(src, callback);
    });
  }
}

// return true if dest is a subdir of src, otherwise false.
// extract dest base dir and check if that is the same as src basename
function isSrcSubdir(src, dest, cb) {
  fs.stat(src, (err, st) => {
    if (err) return cb(err);
    if (st.isDirectory()) {
      const baseDir = dest.split(path.dirname(src) + path.sep)[1];
      if (baseDir) {
        const destBasename = baseDir.split(path.sep)[0];
        if (destBasename) return cb(null, src !== dest && dest.indexOf(src) > -1 && destBasename === path.basename(src));
        return cb(null, false);
      }
      return cb(null, false);
    }
    return cb(null, false);
  });
}

module.exports = {
  move: u(move)
};

/***/ }),
/* 122 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const fs = __webpack_require__(5);
const path = __webpack_require__(0);
const copySync = __webpack_require__(50).copySync;
const removeSync = __webpack_require__(24).removeSync;
const mkdirpSync = __webpack_require__(7).mkdirsSync;
const buffer = __webpack_require__(51);

function moveSync(src, dest, options) {
  options = options || {};
  const overwrite = options.overwrite || options.clobber || false;

  src = path.resolve(src);
  dest = path.resolve(dest);

  if (src === dest) return fs.accessSync(src);

  if (isSrcSubdir(src, dest)) throw new Error(`Cannot move '${src}' into itself '${dest}'.`);

  mkdirpSync(path.dirname(dest));
  tryRenameSync();

  function tryRenameSync() {
    if (overwrite) {
      try {
        return fs.renameSync(src, dest);
      } catch (err) {
        if (err.code === 'ENOTEMPTY' || err.code === 'EEXIST' || err.code === 'EPERM') {
          removeSync(dest);
          options.overwrite = false; // just overwriteed it, no need to do it again
          return moveSync(src, dest, options);
        }

        if (err.code !== 'EXDEV') throw err;
        return moveSyncAcrossDevice(src, dest, overwrite);
      }
    } else {
      try {
        fs.linkSync(src, dest);
        return fs.unlinkSync(src);
      } catch (err) {
        if (err.code === 'EXDEV' || err.code === 'EISDIR' || err.code === 'EPERM' || err.code === 'ENOTSUP') {
          return moveSyncAcrossDevice(src, dest, overwrite);
        }
        throw err;
      }
    }
  }
}

function moveSyncAcrossDevice(src, dest, overwrite) {
  const stat = fs.statSync(src);

  if (stat.isDirectory()) {
    return moveDirSyncAcrossDevice(src, dest, overwrite);
  } else {
    return moveFileSyncAcrossDevice(src, dest, overwrite);
  }
}

function moveFileSyncAcrossDevice(src, dest, overwrite) {
  const BUF_LENGTH = 64 * 1024;
  const _buff = buffer(BUF_LENGTH);

  const flags = overwrite ? 'w' : 'wx';

  const fdr = fs.openSync(src, 'r');
  const stat = fs.fstatSync(fdr);
  const fdw = fs.openSync(dest, flags, stat.mode);
  let bytesRead = 1;
  let pos = 0;

  while (bytesRead > 0) {
    bytesRead = fs.readSync(fdr, _buff, 0, BUF_LENGTH, pos);
    fs.writeSync(fdw, _buff, 0, bytesRead);
    pos += bytesRead;
  }

  fs.closeSync(fdr);
  fs.closeSync(fdw);
  return fs.unlinkSync(src);
}

function moveDirSyncAcrossDevice(src, dest, overwrite) {
  const options = {
    overwrite: false
  };

  if (overwrite) {
    removeSync(dest);
    tryCopySync();
  } else {
    tryCopySync();
  }

  function tryCopySync() {
    copySync(src, dest, options);
    return removeSync(src);
  }
}

// return true if dest is a subdir of src, otherwise false.
// extract dest base dir and check if that is the same as src basename
function isSrcSubdir(src, dest) {
  try {
    return fs.statSync(src).isDirectory() && src !== dest && dest.indexOf(src) > -1 && dest.split(path.dirname(src) + path.sep)[1].split(path.sep)[0] === path.basename(src);
  } catch (e) {
    return false;
  }
}

module.exports = {
  moveSync
};

/***/ }),
/* 123 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const u = __webpack_require__(6).fromCallback;
const fs = __webpack_require__(12);
const path = __webpack_require__(0);
const mkdir = __webpack_require__(7);
const remove = __webpack_require__(24);

const emptyDir = u(function emptyDir(dir, callback) {
  callback = callback || function () {};
  fs.readdir(dir, (err, items) => {
    if (err) return mkdir.mkdirs(dir, callback);

    items = items.map(item => path.join(dir, item));

    deleteItem();

    function deleteItem() {
      const item = items.pop();
      if (!item) return callback();
      remove.remove(item, err => {
        if (err) return callback(err);
        deleteItem();
      });
    }
  });
});

function emptyDirSync(dir) {
  let items;
  try {
    items = fs.readdirSync(dir);
  } catch (err) {
    return mkdir.mkdirsSync(dir);
  }

  items.forEach(item => {
    item = path.join(dir, item);
    remove.removeSync(item);
  });
}

module.exports = {
  emptyDirSync,
  emptydirSync: emptyDirSync,
  emptyDir,
  emptydir: emptyDir
};

/***/ }),
/* 124 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const file = __webpack_require__(125);
const link = __webpack_require__(126);
const symlink = __webpack_require__(127);

module.exports = {
  // file
  createFile: file.createFile,
  createFileSync: file.createFileSync,
  ensureFile: file.createFile,
  ensureFileSync: file.createFileSync,
  // link
  createLink: link.createLink,
  createLinkSync: link.createLinkSync,
  ensureLink: link.createLink,
  ensureLinkSync: link.createLinkSync,
  // symlink
  createSymlink: symlink.createSymlink,
  createSymlinkSync: symlink.createSymlinkSync,
  ensureSymlink: symlink.createSymlink,
  ensureSymlinkSync: symlink.createSymlinkSync
};

/***/ }),
/* 125 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const u = __webpack_require__(6).fromCallback;
const path = __webpack_require__(0);
const fs = __webpack_require__(5);
const mkdir = __webpack_require__(7);
const pathExists = __webpack_require__(13).pathExists;

function createFile(file, callback) {
  function makeFile() {
    fs.writeFile(file, '', err => {
      if (err) return callback(err);
      callback();
    });
  }

  fs.stat(file, (err, stats) => {
    // eslint-disable-line handle-callback-err
    if (!err && stats.isFile()) return callback();
    const dir = path.dirname(file);
    pathExists(dir, (err, dirExists) => {
      if (err) return callback(err);
      if (dirExists) return makeFile();
      mkdir.mkdirs(dir, err => {
        if (err) return callback(err);
        makeFile();
      });
    });
  });
}

function createFileSync(file) {
  let stats;
  try {
    stats = fs.statSync(file);
  } catch (e) {}
  if (stats && stats.isFile()) return;

  const dir = path.dirname(file);
  if (!fs.existsSync(dir)) {
    mkdir.mkdirsSync(dir);
  }

  fs.writeFileSync(file, '');
}

module.exports = {
  createFile: u(createFile),
  createFileSync
};

/***/ }),
/* 126 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const u = __webpack_require__(6).fromCallback;
const path = __webpack_require__(0);
const fs = __webpack_require__(5);
const mkdir = __webpack_require__(7);
const pathExists = __webpack_require__(13).pathExists;

function createLink(srcpath, dstpath, callback) {
  function makeLink(srcpath, dstpath) {
    fs.link(srcpath, dstpath, err => {
      if (err) return callback(err);
      callback(null);
    });
  }

  pathExists(dstpath, (err, destinationExists) => {
    if (err) return callback(err);
    if (destinationExists) return callback(null);
    fs.lstat(srcpath, (err, stat) => {
      if (err) {
        err.message = err.message.replace('lstat', 'ensureLink');
        return callback(err);
      }

      const dir = path.dirname(dstpath);
      pathExists(dir, (err, dirExists) => {
        if (err) return callback(err);
        if (dirExists) return makeLink(srcpath, dstpath);
        mkdir.mkdirs(dir, err => {
          if (err) return callback(err);
          makeLink(srcpath, dstpath);
        });
      });
    });
  });
}

function createLinkSync(srcpath, dstpath, callback) {
  const destinationExists = fs.existsSync(dstpath);
  if (destinationExists) return undefined;

  try {
    fs.lstatSync(srcpath);
  } catch (err) {
    err.message = err.message.replace('lstat', 'ensureLink');
    throw err;
  }

  const dir = path.dirname(dstpath);
  const dirExists = fs.existsSync(dir);
  if (dirExists) return fs.linkSync(srcpath, dstpath);
  mkdir.mkdirsSync(dir);

  return fs.linkSync(srcpath, dstpath);
}

module.exports = {
  createLink: u(createLink),
  createLinkSync
};

/***/ }),
/* 127 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const u = __webpack_require__(6).fromCallback;
const path = __webpack_require__(0);
const fs = __webpack_require__(5);
const _mkdirs = __webpack_require__(7);
const mkdirs = _mkdirs.mkdirs;
const mkdirsSync = _mkdirs.mkdirsSync;

const _symlinkPaths = __webpack_require__(128);
const symlinkPaths = _symlinkPaths.symlinkPaths;
const symlinkPathsSync = _symlinkPaths.symlinkPathsSync;

const _symlinkType = __webpack_require__(129);
const symlinkType = _symlinkType.symlinkType;
const symlinkTypeSync = _symlinkType.symlinkTypeSync;

const pathExists = __webpack_require__(13).pathExists;

function createSymlink(srcpath, dstpath, type, callback) {
  callback = typeof type === 'function' ? type : callback;
  type = typeof type === 'function' ? false : type;

  pathExists(dstpath, (err, destinationExists) => {
    if (err) return callback(err);
    if (destinationExists) return callback(null);
    symlinkPaths(srcpath, dstpath, (err, relative) => {
      if (err) return callback(err);
      srcpath = relative.toDst;
      symlinkType(relative.toCwd, type, (err, type) => {
        if (err) return callback(err);
        const dir = path.dirname(dstpath);
        pathExists(dir, (err, dirExists) => {
          if (err) return callback(err);
          if (dirExists) return fs.symlink(srcpath, dstpath, type, callback);
          mkdirs(dir, err => {
            if (err) return callback(err);
            fs.symlink(srcpath, dstpath, type, callback);
          });
        });
      });
    });
  });
}

function createSymlinkSync(srcpath, dstpath, type, callback) {
  callback = typeof type === 'function' ? type : callback;
  type = typeof type === 'function' ? false : type;

  const destinationExists = fs.existsSync(dstpath);
  if (destinationExists) return undefined;

  const relative = symlinkPathsSync(srcpath, dstpath);
  srcpath = relative.toDst;
  type = symlinkTypeSync(relative.toCwd, type);
  const dir = path.dirname(dstpath);
  const exists = fs.existsSync(dir);
  if (exists) return fs.symlinkSync(srcpath, dstpath, type);
  mkdirsSync(dir);
  return fs.symlinkSync(srcpath, dstpath, type);
}

module.exports = {
  createSymlink: u(createSymlink),
  createSymlinkSync
};

/***/ }),
/* 128 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const path = __webpack_require__(0);
const fs = __webpack_require__(5);
const pathExists = __webpack_require__(13).pathExists;

/**
 * Function that returns two types of paths, one relative to symlink, and one
 * relative to the current working directory. Checks if path is absolute or
 * relative. If the path is relative, this function checks if the path is
 * relative to symlink or relative to current working directory. This is an
 * initiative to find a smarter `srcpath` to supply when building symlinks.
 * This allows you to determine which path to use out of one of three possible
 * types of source paths. The first is an absolute path. This is detected by
 * `path.isAbsolute()`. When an absolute path is provided, it is checked to
 * see if it exists. If it does it's used, if not an error is returned
 * (callback)/ thrown (sync). The other two options for `srcpath` are a
 * relative url. By default Node's `fs.symlink` works by creating a symlink
 * using `dstpath` and expects the `srcpath` to be relative to the newly
 * created symlink. If you provide a `srcpath` that does not exist on the file
 * system it results in a broken symlink. To minimize this, the function
 * checks to see if the 'relative to symlink' source file exists, and if it
 * does it will use it. If it does not, it checks if there's a file that
 * exists that is relative to the current working directory, if does its used.
 * This preserves the expectations of the original fs.symlink spec and adds
 * the ability to pass in `relative to current working direcotry` paths.
 */

function symlinkPaths(srcpath, dstpath, callback) {
  if (path.isAbsolute(srcpath)) {
    return fs.lstat(srcpath, (err, stat) => {
      if (err) {
        err.message = err.message.replace('lstat', 'ensureSymlink');
        return callback(err);
      }
      return callback(null, {
        'toCwd': srcpath,
        'toDst': srcpath
      });
    });
  } else {
    const dstdir = path.dirname(dstpath);
    const relativeToDst = path.join(dstdir, srcpath);
    return pathExists(relativeToDst, (err, exists) => {
      if (err) return callback(err);
      if (exists) {
        return callback(null, {
          'toCwd': relativeToDst,
          'toDst': srcpath
        });
      } else {
        return fs.lstat(srcpath, (err, stat) => {
          if (err) {
            err.message = err.message.replace('lstat', 'ensureSymlink');
            return callback(err);
          }
          return callback(null, {
            'toCwd': srcpath,
            'toDst': path.relative(dstdir, srcpath)
          });
        });
      }
    });
  }
}

function symlinkPathsSync(srcpath, dstpath) {
  let exists;
  if (path.isAbsolute(srcpath)) {
    exists = fs.existsSync(srcpath);
    if (!exists) throw new Error('absolute srcpath does not exist');
    return {
      'toCwd': srcpath,
      'toDst': srcpath
    };
  } else {
    const dstdir = path.dirname(dstpath);
    const relativeToDst = path.join(dstdir, srcpath);
    exists = fs.existsSync(relativeToDst);
    if (exists) {
      return {
        'toCwd': relativeToDst,
        'toDst': srcpath
      };
    } else {
      exists = fs.existsSync(srcpath);
      if (!exists) throw new Error('relative srcpath does not exist');
      return {
        'toCwd': srcpath,
        'toDst': path.relative(dstdir, srcpath)
      };
    }
  }
}

module.exports = {
  symlinkPaths,
  symlinkPathsSync
};

/***/ }),
/* 129 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const fs = __webpack_require__(5);

function symlinkType(srcpath, type, callback) {
  callback = typeof type === 'function' ? type : callback;
  type = typeof type === 'function' ? false : type;
  if (type) return callback(null, type);
  fs.lstat(srcpath, (err, stats) => {
    if (err) return callback(null, 'file');
    type = stats && stats.isDirectory() ? 'dir' : 'file';
    callback(null, type);
  });
}

function symlinkTypeSync(srcpath, type) {
  let stats;

  if (type) return type;
  try {
    stats = fs.lstatSync(srcpath);
  } catch (e) {
    return 'file';
  }
  return stats && stats.isDirectory() ? 'dir' : 'file';
}

module.exports = {
  symlinkType,
  symlinkTypeSync
};

/***/ }),
/* 130 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const u = __webpack_require__(6).fromCallback;
const fs = __webpack_require__(5);
const path = __webpack_require__(0);
const mkdir = __webpack_require__(7);
const pathExists = __webpack_require__(13).pathExists;

function outputFile(file, data, encoding, callback) {
  if (typeof encoding === 'function') {
    callback = encoding;
    encoding = 'utf8';
  }

  const dir = path.dirname(file);
  pathExists(dir, (err, itDoes) => {
    if (err) return callback(err);
    if (itDoes) return fs.writeFile(file, data, encoding, callback);

    mkdir.mkdirs(dir, err => {
      if (err) return callback(err);

      fs.writeFile(file, data, encoding, callback);
    });
  });
}

function outputFileSync(file, data, encoding) {
  const dir = path.dirname(file);
  if (fs.existsSync(dir)) {
    return fs.writeFileSync.apply(fs, arguments);
  }
  mkdir.mkdirsSync(dir);
  fs.writeFileSync.apply(fs, arguments);
}

module.exports = {
  outputFile: u(outputFile),
  outputFileSync
};

/***/ }),
/* 131 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.githubUrl = githubUrl;
exports.getS3LikeProviderBaseUrl = getS3LikeProviderBaseUrl;
/** @private */
function githubUrl(options, defaultHost = "github.com") {
    return `${options.protocol || "https"}://${options.host || defaultHost}`;
}
function getS3LikeProviderBaseUrl(configuration) {
    const provider = configuration.provider;
    if (provider === "s3") {
        return s3Url(configuration);
    }
    if (provider === "spaces") {
        return spacesUrl(configuration);
    }
    throw new Error(`Not supported provider: ${provider}`);
}
function s3Url(options) {
    let url;
    if (options.endpoint != null) {
        url = `${options.endpoint}/${options.bucket}`;
    } else {
        if (!options.bucket.includes(".")) {
            if (options.region === "cn-north-1") {
                url = `https://${options.bucket}.s3.${options.region}.amazonaws.com.cn`;
            } else {
                url = `https://${options.bucket}.s3.amazonaws.com`;
            }
        } else {
            if (options.region == null) {
                throw new Error(`Bucket name "${options.bucket}" includes a dot, but S3 region is missing`);
            }
            // special case, see http://docs.aws.amazon.com/AmazonS3/latest/dev/UsingBucket.html#access-bucket-intro
            url = options.region === "us-east-1" ? `https://s3.amazonaws.com/${options.bucket}` : `https://s3-${options.region}.amazonaws.com/${options.bucket}`;
        }
    }
    if (options.path != null) {
        url += `/${options.path}`;
    }
    return url;
}
function spacesUrl(options) {
    if (options.name == null) {
        throw new Error(`name is missing`);
    }
    if (options.region == null) {
        throw new Error(`region is missing`);
    }
    let url = `https://${options.name}.${options.region}.digitaloceanspaces.com`;
    if (options.path != null) {
        url += `/${options.path}`;
    }
    return url;
}
//# sourceMappingURL=publishOptions.js.map

/***/ }),
/* 132 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.parseDn = parseDn;
function parseDn(seq) {
    let quoted = false;
    let key = null;
    let token = "";
    let nextNonSpace = 0;
    seq = seq.trim();
    const result = new Map();
    for (let i = 0; i <= seq.length; i++) {
        if (i === seq.length) {
            if (key !== null) {
                result.set(key, token);
            }
            break;
        }
        const ch = seq[i];
        if (quoted) {
            if (ch === '"') {
                quoted = false;
                continue;
            }
        } else {
            if (ch === '"') {
                quoted = true;
                continue;
            }
            if (ch === "\\") {
                i++;
                const ord = parseInt(seq.slice(i, i + 2), 16);
                if (Number.isNaN(ord)) {
                    token += seq[i];
                } else {
                    i++;
                    token += String.fromCharCode(ord);
                }
                continue;
            }
            if (key === null && ch === "=") {
                key = token;
                token = "";
                continue;
            }
            if (ch === "," || ch === ";" || ch === "+") {
                if (key !== null) {
                    result.set(key, token);
                }
                key = null;
                token = "";
                continue;
            }
        }
        if (ch === " " && !quoted) {
            if (token.length === 0) {
                continue;
            }
            if (i > nextNonSpace) {
                let j = i;
                while (seq[j] === " ") {
                    j++;
                }
                nextNonSpace = j;
            }
            if (nextNonSpace >= seq.length || seq[nextNonSpace] === "," || seq[nextNonSpace] === ";" || key === null && seq[nextNonSpace] === "=" || key !== null && seq[nextNonSpace] === "+") {
                i = nextNonSpace - 1;
                continue;
            }
        }
        token += ch;
    }
    return result;
}
//# sourceMappingURL=rfc2253Parser.js.map

/***/ }),
/* 133 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.nil = exports.UUID = undefined;

var _crypto;

function _load_crypto() {
    return _crypto = __webpack_require__(28);
}

var _index;

function _load_index() {
    return _index = __webpack_require__(3);
}

const invalidName = "options.name must be either a string or a Buffer";
const moreThan10000 = "can not generate more than 10000 UUIDs per second";
// Node ID according to rfc4122#section-4.5
const randomHost = (0, (_crypto || _load_crypto()).randomBytes)(16);
randomHost[0] = randomHost[0] | 0x01;
// randomize clockSeq initially, as per rfc4122#section-4.1.5
const seed = (0, (_crypto || _load_crypto()).randomBytes)(2);
let clockSeq = (seed[0] | seed[1] << 8) & 0x3fff;
// clock values
let lastMTime = 0;
let lastNTime = 0;
// lookup table hex to byte
const hex2byte = {};
// lookup table byte to hex
const byte2hex = [];
// populate lookup tables
for (let i = 0; i < 256; i++) {
    const hex = (i + 0x100).toString(16).substr(1);
    hex2byte[hex] = i;
    byte2hex[i] = hex;
}
// UUID class
class UUID {
    constructor(uuid) {
        const check = UUID.check(uuid);
        if (!check) {
            throw new Error("not a UUID");
        }
        this.version = check.version;
        if (check.format === "ascii") {
            this.ascii = uuid;
        } else {
            this.binary = uuid;
        }
    }
    static v1() {
        return uuidTimeBased(randomHost);
    }
    static v5(name, namespace) {
        return uuidNamed(name, "sha1", 0x50, namespace);
    }
    toString() {
        if (this.ascii == null) {
            this.ascii = stringify(this.binary);
        }
        return this.ascii;
    }
    toBuffer() {
        if (this.binary == null) {
            this.binary = UUID.parse(this.ascii);
        }
        return Buffer.from(this.binary);
    }
    inspect() {
        return `UUID v${this.version} ${this.toString()}`;
    }
    static check(uuid, offset = 0) {
        if (typeof uuid === "string") {
            uuid = uuid.toLowerCase();
            if (!/^[a-f0-9]{8}(\-[a-f0-9]{4}){3}\-([a-f0-9]{12})$/.test(uuid)) {
                return false;
            }
            if (uuid === "00000000-0000-0000-0000-000000000000") {
                return { version: undefined, variant: "nil", format: "ascii" };
            }
            return {
                version: (hex2byte[uuid[14] + uuid[15]] & 0xf0) >> 4,
                variant: getVariant((hex2byte[uuid[19] + uuid[20]] & 0xe0) >> 5),
                format: "ascii"
            };
        }
        if (Buffer.isBuffer(uuid)) {
            if (uuid.length < offset + 16) {
                return false;
            }
            let i = 0;
            for (; i < 16; i++) {
                if (uuid[offset + i] !== 0) {
                    break;
                }
            }
            if (i === 16) {
                return { version: undefined, variant: "nil", format: "binary" };
            }
            return {
                version: (uuid[offset + 6] & 0xf0) >> 4,
                variant: getVariant((uuid[offset + 8] & 0xe0) >> 5),
                format: "binary"
            };
        }
        throw (0, (_index || _load_index()).newError)("Unknown type of uuid", "ERR_UNKNOWN_UUID_TYPE");
    }
    // read stringified uuid into a Buffer
    static parse(input) {
        const buffer = Buffer.allocUnsafe(16);
        let j = 0;
        for (let i = 0; i < 16; i++) {
            buffer[i] = hex2byte[input[j++] + input[j++]];
            if (i === 3 || i === 5 || i === 7 || i === 9) {
                j += 1;
            }
        }
        return buffer;
    }
}
exports.UUID = UUID; // from rfc4122#appendix-C

UUID.URL = new UUID("6ba7b811-9dad-11d1-80b4-00c04fd430c8");
UUID.OID = UUID.parse("6ba7b812-9dad-11d1-80b4-00c04fd430c8");
// according to rfc4122#section-4.1.1
function getVariant(bits) {
    switch (bits) {
        case 0:
        case 1:
        case 3:
            return "ncs";
        case 4:
        case 5:
            return "rfc4122";
        case 6:
            return "microsoft";
        default:
            return "future";
    }
}
var UuidEncoding;
(function (UuidEncoding) {
    UuidEncoding[UuidEncoding["ASCII"] = 0] = "ASCII";
    UuidEncoding[UuidEncoding["BINARY"] = 1] = "BINARY";
    UuidEncoding[UuidEncoding["OBJECT"] = 2] = "OBJECT";
})(UuidEncoding || (UuidEncoding = {}));
// v1
function uuidTimeBased(nodeId, encoding = UuidEncoding.ASCII) {
    let mTime = Date.now();
    let nTime = lastNTime + 1;
    const delta = mTime - lastMTime + (nTime - lastNTime) / 10000;
    if (delta < 0) {
        clockSeq = clockSeq + 1 & 0x3fff;
        nTime = 0;
    } else if (mTime > lastMTime) {
        nTime = 0;
    } else if (nTime >= 10000) {
        return moreThan10000;
    }
    lastMTime = mTime;
    lastNTime = nTime;
    // unix timestamp to gregorian epoch as per rfc4122#section-4.5
    mTime += 12219292800000;
    const buffer = Buffer.allocUnsafe(16);
    const myClockSeq = clockSeq;
    const timeLow = ((mTime & 0xfffffff) * 10000 + nTime) % 0x100000000;
    const timeHigh = mTime / 0x100000000 * 10000 & 0xfffffff;
    buffer[0] = timeLow >>> 24 & 0xff;
    buffer[1] = timeLow >>> 16 & 0xff;
    buffer[2] = timeLow >>> 8 & 0xff;
    buffer[3] = timeLow & 0xff;
    buffer[4] = timeHigh >>> 8 & 0xff;
    buffer[5] = timeHigh & 0xff;
    buffer[6] = timeHigh >>> 24 & 0x0f | 0x10;
    buffer[7] = timeHigh >>> 16 & 0x3f | 0x80;
    buffer[8] = myClockSeq >>> 8;
    buffer[9] = myClockSeq & 0xff;
    let result;
    switch (encoding) {
        case UuidEncoding.BINARY:
            buffer[10] = nodeId[0];
            buffer[11] = nodeId[1];
            buffer[12] = nodeId[2];
            buffer[13] = nodeId[3];
            buffer[14] = nodeId[4];
            buffer[15] = nodeId[5];
            result = buffer;
            break;
        case UuidEncoding.OBJECT:
            buffer[10] = nodeId[0];
            buffer[11] = nodeId[1];
            buffer[12] = nodeId[2];
            buffer[13] = nodeId[3];
            buffer[14] = nodeId[4];
            buffer[15] = nodeId[5];
            result = new UUID(buffer);
            break;
        default:
            result = byte2hex[buffer[0]] + byte2hex[buffer[1]] + byte2hex[buffer[2]] + byte2hex[buffer[3]] + "-" + byte2hex[buffer[4]] + byte2hex[buffer[5]] + "-" + byte2hex[buffer[6]] + byte2hex[buffer[7]] + "-" + byte2hex[buffer[8]] + byte2hex[buffer[9]] + "-" + byte2hex[nodeId[0]] + byte2hex[nodeId[1]] + byte2hex[nodeId[2]] + byte2hex[nodeId[3]] + byte2hex[nodeId[4]] + byte2hex[nodeId[5]];
            break;
    }
    return result;
}
// v3 + v5
function uuidNamed(name, hashMethod, version, namespace, encoding = UuidEncoding.ASCII) {
    const hash = (0, (_crypto || _load_crypto()).createHash)(hashMethod);
    const nameIsNotAString = typeof name !== "string";
    if (nameIsNotAString && !Buffer.isBuffer(name)) {
        throw (0, (_index || _load_index()).newError)(invalidName, "ERR_INVALID_UUID_NAME");
    }
    hash.update(namespace);
    hash.update(name, nameIsNotAString ? "latin1" : "utf8");
    const buffer = hash.digest();
    let result;
    switch (encoding) {
        case UuidEncoding.BINARY:
            buffer[6] = buffer[6] & 0x0f | version;
            buffer[8] = buffer[8] & 0x3f | 0x80;
            result = buffer;
            break;
        case UuidEncoding.OBJECT:
            buffer[6] = buffer[6] & 0x0f | version;
            buffer[8] = buffer[8] & 0x3f | 0x80;
            result = new UUID(buffer);
            break;
        default:
            result = byte2hex[buffer[0]] + byte2hex[buffer[1]] + byte2hex[buffer[2]] + byte2hex[buffer[3]] + "-" + byte2hex[buffer[4]] + byte2hex[buffer[5]] + "-" + byte2hex[buffer[6] & 0x0f | version] + byte2hex[buffer[7]] + "-" + byte2hex[buffer[8] & 0x3f | 0x80] + byte2hex[buffer[9]] + "-" + byte2hex[buffer[10]] + byte2hex[buffer[11]] + byte2hex[buffer[12]] + byte2hex[buffer[13]] + byte2hex[buffer[14]] + byte2hex[buffer[15]];
            break;
    }
    return result;
}
function stringify(buffer) {
    return byte2hex[buffer[0]] + byte2hex[buffer[1]] + byte2hex[buffer[2]] + byte2hex[buffer[3]] + "-" + byte2hex[buffer[4]] + byte2hex[buffer[5]] + "-" + byte2hex[buffer[6]] + byte2hex[buffer[7]] + "-" + byte2hex[buffer[8]] + byte2hex[buffer[9]] + "-" + byte2hex[buffer[10]] + byte2hex[buffer[11]] + byte2hex[buffer[12]] + byte2hex[buffer[13]] + byte2hex[buffer[14]] + byte2hex[buffer[15]];
}
// according to rfc4122#section-4.1.7
const nil = exports.nil = new UUID("00000000-0000-0000-0000-000000000000");
// UUID.v4 = uuidRandom
// UUID.v4fast = uuidRandomFast
// UUID.v3 = function(options, callback) {
//     return uuidNamed("md5", 0x30, options, callback)
// } 
//# sourceMappingURL=uuid.js.map

/***/ }),
/* 134 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.XElement = undefined;
exports.parseXml = parseXml;

var _sax;

function _load_sax() {
    return _sax = _interopRequireWildcard(__webpack_require__(135));
}

var _index;

function _load_index() {
    return _index = __webpack_require__(3);
}

function _interopRequireWildcard(obj) {
    if (obj && obj.__esModule) {
        return obj;
    } else {
        var newObj = {};if (obj != null) {
            for (var key in obj) {
                if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key];
            }
        }newObj.default = obj;return newObj;
    }
}

class XElement {
    constructor(name) {
        this.name = name;
        this.value = "";
        this.attributes = null;
        this.isCData = false;
        this.elements = null;
        if (!name) {
            throw (0, (_index || _load_index()).newError)("Element name cannot be empty", "ERR_XML_ELEMENT_NAME_EMPTY");
        }
        if (!isValidName(name)) {
            throw (0, (_index || _load_index()).newError)(`Invalid element name: ${name}`, "ERR_XML_ELEMENT_INVALID_NAME");
        }
    }
    attribute(name) {
        const result = this.attributes === null ? null : this.attributes[name];
        if (result == null) {
            throw (0, (_index || _load_index()).newError)(`No attribute "${name}"`, "ERR_XML_MISSED_ATTRIBUTE");
        }
        return result;
    }
    removeAttribute(name) {
        if (this.attributes !== null) {
            delete this.attributes[name];
        }
    }
    element(name, ignoreCase = false, errorIfMissed = null) {
        const result = this.elementOrNull(name, ignoreCase);
        if (result === null) {
            throw (0, (_index || _load_index()).newError)(errorIfMissed || `No element "${name}"`, "ERR_XML_MISSED_ELEMENT");
        }
        return result;
    }
    elementOrNull(name, ignoreCase = false) {
        if (this.elements === null) {
            return null;
        }
        for (const element of this.elements) {
            if (isNameEquals(element, name, ignoreCase)) {
                return element;
            }
        }
        return null;
    }
    getElements(name, ignoreCase = false) {
        if (this.elements === null) {
            return [];
        }
        return this.elements.filter(it => isNameEquals(it, name, ignoreCase));
    }
    elementValueOrEmpty(name, ignoreCase = false) {
        const element = this.elementOrNull(name, ignoreCase);
        return element === null ? "" : element.value;
    }
}
exports.XElement = XElement;
const NAME_REG_EXP = new RegExp(/^[A-Za-z_][:A-Za-z0-9_-]*$/i);
function isValidName(name) {
    return NAME_REG_EXP.test(name);
}
function isNameEquals(element, name, ignoreCase) {
    const elementName = element.name;
    return elementName === name || ignoreCase === true && elementName.length === name.length && elementName.toLowerCase() === name.toLowerCase();
}
function parseXml(data) {
    let rootElement = null;
    const parser = (_sax || _load_sax()).parser(true, {});
    const elements = [];
    parser.onopentag = saxElement => {
        const element = new XElement(saxElement.name);
        element.attributes = saxElement.attributes;
        if (rootElement === null) {
            rootElement = element;
        } else {
            const parent = elements[elements.length - 1];
            if (parent.elements == null) {
                parent.elements = [];
            }
            parent.elements.push(element);
        }
        elements.push(element);
    };
    parser.onclosetag = () => {
        elements.pop();
    };
    parser.ontext = text => {
        if (elements.length > 0) {
            elements[elements.length - 1].value = text;
        }
    };
    parser.oncdata = cdata => {
        const element = elements[elements.length - 1];
        element.value = cdata;
        element.isCData = true;
    };
    parser.onerror = err => {
        throw err;
    };
    parser.write(data);
    return rootElement;
}
//# sourceMappingURL=xml.js.map

/***/ }),
/* 135 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


;(function (sax) {
  // wrapper for non-node envs
  sax.parser = function (strict, opt) {
    return new SAXParser(strict, opt);
  };
  sax.SAXParser = SAXParser;
  sax.SAXStream = SAXStream;
  sax.createStream = createStream;

  // When we pass the MAX_BUFFER_LENGTH position, start checking for buffer overruns.
  // When we check, schedule the next check for MAX_BUFFER_LENGTH - (max(buffer lengths)),
  // since that's the earliest that a buffer overrun could occur.  This way, checks are
  // as rare as required, but as often as necessary to ensure never crossing this bound.
  // Furthermore, buffers are only tested at most once per write(), so passing a very
  // large string into write() might have undesirable effects, but this is manageable by
  // the caller, so it is assumed to be safe.  Thus, a call to write() may, in the extreme
  // edge case, result in creating at most one complete copy of the string passed in.
  // Set to Infinity to have unlimited buffers.
  sax.MAX_BUFFER_LENGTH = 64 * 1024;

  var buffers = ['comment', 'sgmlDecl', 'textNode', 'tagName', 'doctype', 'procInstName', 'procInstBody', 'entity', 'attribName', 'attribValue', 'cdata', 'script'];

  sax.EVENTS = ['text', 'processinginstruction', 'sgmldeclaration', 'doctype', 'comment', 'opentagstart', 'attribute', 'opentag', 'closetag', 'opencdata', 'cdata', 'closecdata', 'error', 'end', 'ready', 'script', 'opennamespace', 'closenamespace'];

  function SAXParser(strict, opt) {
    if (!(this instanceof SAXParser)) {
      return new SAXParser(strict, opt);
    }

    var parser = this;
    clearBuffers(parser);
    parser.q = parser.c = '';
    parser.bufferCheckPosition = sax.MAX_BUFFER_LENGTH;
    parser.opt = opt || {};
    parser.opt.lowercase = parser.opt.lowercase || parser.opt.lowercasetags;
    parser.looseCase = parser.opt.lowercase ? 'toLowerCase' : 'toUpperCase';
    parser.tags = [];
    parser.closed = parser.closedRoot = parser.sawRoot = false;
    parser.tag = parser.error = null;
    parser.strict = !!strict;
    parser.noscript = !!(strict || parser.opt.noscript);
    parser.state = S.BEGIN;
    parser.strictEntities = parser.opt.strictEntities;
    parser.ENTITIES = parser.strictEntities ? Object.create(sax.XML_ENTITIES) : Object.create(sax.ENTITIES);
    parser.attribList = [];

    // namespaces form a prototype chain.
    // it always points at the current tag,
    // which protos to its parent tag.
    if (parser.opt.xmlns) {
      parser.ns = Object.create(rootNS);
    }

    // mostly just for error reporting
    parser.trackPosition = parser.opt.position !== false;
    if (parser.trackPosition) {
      parser.position = parser.line = parser.column = 0;
    }
    emit(parser, 'onready');
  }

  if (!Object.create) {
    Object.create = function (o) {
      function F() {}
      F.prototype = o;
      var newf = new F();
      return newf;
    };
  }

  if (!Object.keys) {
    Object.keys = function (o) {
      var a = [];
      for (var i in o) if (o.hasOwnProperty(i)) a.push(i);
      return a;
    };
  }

  function checkBufferLength(parser) {
    var maxAllowed = Math.max(sax.MAX_BUFFER_LENGTH, 10);
    var maxActual = 0;
    for (var i = 0, l = buffers.length; i < l; i++) {
      var len = parser[buffers[i]].length;
      if (len > maxAllowed) {
        // Text/cdata nodes can get big, and since they're buffered,
        // we can get here under normal conditions.
        // Avoid issues by emitting the text node now,
        // so at least it won't get any bigger.
        switch (buffers[i]) {
          case 'textNode':
            closeText(parser);
            break;

          case 'cdata':
            emitNode(parser, 'oncdata', parser.cdata);
            parser.cdata = '';
            break;

          case 'script':
            emitNode(parser, 'onscript', parser.script);
            parser.script = '';
            break;

          default:
            error(parser, 'Max buffer length exceeded: ' + buffers[i]);
        }
      }
      maxActual = Math.max(maxActual, len);
    }
    // schedule the next check for the earliest possible buffer overrun.
    var m = sax.MAX_BUFFER_LENGTH - maxActual;
    parser.bufferCheckPosition = m + parser.position;
  }

  function clearBuffers(parser) {
    for (var i = 0, l = buffers.length; i < l; i++) {
      parser[buffers[i]] = '';
    }
  }

  function flushBuffers(parser) {
    closeText(parser);
    if (parser.cdata !== '') {
      emitNode(parser, 'oncdata', parser.cdata);
      parser.cdata = '';
    }
    if (parser.script !== '') {
      emitNode(parser, 'onscript', parser.script);
      parser.script = '';
    }
  }

  SAXParser.prototype = {
    end: function () {
      end(this);
    },
    write: write,
    resume: function () {
      this.error = null;return this;
    },
    close: function () {
      return this.write(null);
    },
    flush: function () {
      flushBuffers(this);
    }
  };

  var Stream;
  try {
    Stream = __webpack_require__(19).Stream;
  } catch (ex) {
    Stream = function () {};
  }

  var streamWraps = sax.EVENTS.filter(function (ev) {
    return ev !== 'error' && ev !== 'end';
  });

  function createStream(strict, opt) {
    return new SAXStream(strict, opt);
  }

  function SAXStream(strict, opt) {
    if (!(this instanceof SAXStream)) {
      return new SAXStream(strict, opt);
    }

    Stream.apply(this);

    this._parser = new SAXParser(strict, opt);
    this.writable = true;
    this.readable = true;

    var me = this;

    this._parser.onend = function () {
      me.emit('end');
    };

    this._parser.onerror = function (er) {
      me.emit('error', er);

      // if didn't throw, then means error was handled.
      // go ahead and clear error, so we can write again.
      me._parser.error = null;
    };

    this._decoder = null;

    streamWraps.forEach(function (ev) {
      Object.defineProperty(me, 'on' + ev, {
        get: function () {
          return me._parser['on' + ev];
        },
        set: function (h) {
          if (!h) {
            me.removeAllListeners(ev);
            me._parser['on' + ev] = h;
            return h;
          }
          me.on(ev, h);
        },
        enumerable: true,
        configurable: false
      });
    });
  }

  SAXStream.prototype = Object.create(Stream.prototype, {
    constructor: {
      value: SAXStream
    }
  });

  SAXStream.prototype.write = function (data) {
    if (typeof Buffer === 'function' && typeof Buffer.isBuffer === 'function' && Buffer.isBuffer(data)) {
      if (!this._decoder) {
        var SD = __webpack_require__(136).StringDecoder;
        this._decoder = new SD('utf8');
      }
      data = this._decoder.write(data);
    }

    this._parser.write(data.toString());
    this.emit('data', data);
    return true;
  };

  SAXStream.prototype.end = function (chunk) {
    if (chunk && chunk.length) {
      this.write(chunk);
    }
    this._parser.end();
    return true;
  };

  SAXStream.prototype.on = function (ev, handler) {
    var me = this;
    if (!me._parser['on' + ev] && streamWraps.indexOf(ev) !== -1) {
      me._parser['on' + ev] = function () {
        var args = arguments.length === 1 ? [arguments[0]] : Array.apply(null, arguments);
        args.splice(0, 0, ev);
        me.emit.apply(me, args);
      };
    }

    return Stream.prototype.on.call(me, ev, handler);
  };

  // this really needs to be replaced with character classes.
  // XML allows all manner of ridiculous numbers and digits.
  var CDATA = '[CDATA[';
  var DOCTYPE = 'DOCTYPE';
  var XML_NAMESPACE = 'http://www.w3.org/XML/1998/namespace';
  var XMLNS_NAMESPACE = 'http://www.w3.org/2000/xmlns/';
  var rootNS = { xml: XML_NAMESPACE, xmlns: XMLNS_NAMESPACE

    // http://www.w3.org/TR/REC-xml/#NT-NameStartChar
    // This implementation works on strings, a single character at a time
    // as such, it cannot ever support astral-plane characters (10000-EFFFF)
    // without a significant breaking change to either this  parser, or the
    // JavaScript language.  Implementation of an emoji-capable xml parser
    // is left as an exercise for the reader.
  };var nameStart = /[:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]/;

  var nameBody = /[:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\u00B7\u0300-\u036F\u203F-\u2040.\d-]/;

  var entityStart = /[#:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]/;
  var entityBody = /[#:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\u00B7\u0300-\u036F\u203F-\u2040.\d-]/;

  function isWhitespace(c) {
    return c === ' ' || c === '\n' || c === '\r' || c === '\t';
  }

  function isQuote(c) {
    return c === '"' || c === '\'';
  }

  function isAttribEnd(c) {
    return c === '>' || isWhitespace(c);
  }

  function isMatch(regex, c) {
    return regex.test(c);
  }

  function notMatch(regex, c) {
    return !isMatch(regex, c);
  }

  var S = 0;
  sax.STATE = {
    BEGIN: S++, // leading byte order mark or whitespace
    BEGIN_WHITESPACE: S++, // leading whitespace
    TEXT: S++, // general stuff
    TEXT_ENTITY: S++, // &amp and such.
    OPEN_WAKA: S++, // <
    SGML_DECL: S++, // <!BLARG
    SGML_DECL_QUOTED: S++, // <!BLARG foo "bar
    DOCTYPE: S++, // <!DOCTYPE
    DOCTYPE_QUOTED: S++, // <!DOCTYPE "//blah
    DOCTYPE_DTD: S++, // <!DOCTYPE "//blah" [ ...
    DOCTYPE_DTD_QUOTED: S++, // <!DOCTYPE "//blah" [ "foo
    COMMENT_STARTING: S++, // <!-
    COMMENT: S++, // <!--
    COMMENT_ENDING: S++, // <!-- blah -
    COMMENT_ENDED: S++, // <!-- blah --
    CDATA: S++, // <![CDATA[ something
    CDATA_ENDING: S++, // ]
    CDATA_ENDING_2: S++, // ]]
    PROC_INST: S++, // <?hi
    PROC_INST_BODY: S++, // <?hi there
    PROC_INST_ENDING: S++, // <?hi "there" ?
    OPEN_TAG: S++, // <strong
    OPEN_TAG_SLASH: S++, // <strong /
    ATTRIB: S++, // <a
    ATTRIB_NAME: S++, // <a foo
    ATTRIB_NAME_SAW_WHITE: S++, // <a foo _
    ATTRIB_VALUE: S++, // <a foo=
    ATTRIB_VALUE_QUOTED: S++, // <a foo="bar
    ATTRIB_VALUE_CLOSED: S++, // <a foo="bar"
    ATTRIB_VALUE_UNQUOTED: S++, // <a foo=bar
    ATTRIB_VALUE_ENTITY_Q: S++, // <foo bar="&quot;"
    ATTRIB_VALUE_ENTITY_U: S++, // <foo bar=&quot
    CLOSE_TAG: S++, // </a
    CLOSE_TAG_SAW_WHITE: S++, // </a   >
    SCRIPT: S++, // <script> ...
    SCRIPT_ENDING: S++ // <script> ... <
  };

  sax.XML_ENTITIES = {
    'amp': '&',
    'gt': '>',
    'lt': '<',
    'quot': '"',
    'apos': "'"
  };

  sax.ENTITIES = {
    'amp': '&',
    'gt': '>',
    'lt': '<',
    'quot': '"',
    'apos': "'",
    'AElig': 198,
    'Aacute': 193,
    'Acirc': 194,
    'Agrave': 192,
    'Aring': 197,
    'Atilde': 195,
    'Auml': 196,
    'Ccedil': 199,
    'ETH': 208,
    'Eacute': 201,
    'Ecirc': 202,
    'Egrave': 200,
    'Euml': 203,
    'Iacute': 205,
    'Icirc': 206,
    'Igrave': 204,
    'Iuml': 207,
    'Ntilde': 209,
    'Oacute': 211,
    'Ocirc': 212,
    'Ograve': 210,
    'Oslash': 216,
    'Otilde': 213,
    'Ouml': 214,
    'THORN': 222,
    'Uacute': 218,
    'Ucirc': 219,
    'Ugrave': 217,
    'Uuml': 220,
    'Yacute': 221,
    'aacute': 225,
    'acirc': 226,
    'aelig': 230,
    'agrave': 224,
    'aring': 229,
    'atilde': 227,
    'auml': 228,
    'ccedil': 231,
    'eacute': 233,
    'ecirc': 234,
    'egrave': 232,
    'eth': 240,
    'euml': 235,
    'iacute': 237,
    'icirc': 238,
    'igrave': 236,
    'iuml': 239,
    'ntilde': 241,
    'oacute': 243,
    'ocirc': 244,
    'ograve': 242,
    'oslash': 248,
    'otilde': 245,
    'ouml': 246,
    'szlig': 223,
    'thorn': 254,
    'uacute': 250,
    'ucirc': 251,
    'ugrave': 249,
    'uuml': 252,
    'yacute': 253,
    'yuml': 255,
    'copy': 169,
    'reg': 174,
    'nbsp': 160,
    'iexcl': 161,
    'cent': 162,
    'pound': 163,
    'curren': 164,
    'yen': 165,
    'brvbar': 166,
    'sect': 167,
    'uml': 168,
    'ordf': 170,
    'laquo': 171,
    'not': 172,
    'shy': 173,
    'macr': 175,
    'deg': 176,
    'plusmn': 177,
    'sup1': 185,
    'sup2': 178,
    'sup3': 179,
    'acute': 180,
    'micro': 181,
    'para': 182,
    'middot': 183,
    'cedil': 184,
    'ordm': 186,
    'raquo': 187,
    'frac14': 188,
    'frac12': 189,
    'frac34': 190,
    'iquest': 191,
    'times': 215,
    'divide': 247,
    'OElig': 338,
    'oelig': 339,
    'Scaron': 352,
    'scaron': 353,
    'Yuml': 376,
    'fnof': 402,
    'circ': 710,
    'tilde': 732,
    'Alpha': 913,
    'Beta': 914,
    'Gamma': 915,
    'Delta': 916,
    'Epsilon': 917,
    'Zeta': 918,
    'Eta': 919,
    'Theta': 920,
    'Iota': 921,
    'Kappa': 922,
    'Lambda': 923,
    'Mu': 924,
    'Nu': 925,
    'Xi': 926,
    'Omicron': 927,
    'Pi': 928,
    'Rho': 929,
    'Sigma': 931,
    'Tau': 932,
    'Upsilon': 933,
    'Phi': 934,
    'Chi': 935,
    'Psi': 936,
    'Omega': 937,
    'alpha': 945,
    'beta': 946,
    'gamma': 947,
    'delta': 948,
    'epsilon': 949,
    'zeta': 950,
    'eta': 951,
    'theta': 952,
    'iota': 953,
    'kappa': 954,
    'lambda': 955,
    'mu': 956,
    'nu': 957,
    'xi': 958,
    'omicron': 959,
    'pi': 960,
    'rho': 961,
    'sigmaf': 962,
    'sigma': 963,
    'tau': 964,
    'upsilon': 965,
    'phi': 966,
    'chi': 967,
    'psi': 968,
    'omega': 969,
    'thetasym': 977,
    'upsih': 978,
    'piv': 982,
    'ensp': 8194,
    'emsp': 8195,
    'thinsp': 8201,
    'zwnj': 8204,
    'zwj': 8205,
    'lrm': 8206,
    'rlm': 8207,
    'ndash': 8211,
    'mdash': 8212,
    'lsquo': 8216,
    'rsquo': 8217,
    'sbquo': 8218,
    'ldquo': 8220,
    'rdquo': 8221,
    'bdquo': 8222,
    'dagger': 8224,
    'Dagger': 8225,
    'bull': 8226,
    'hellip': 8230,
    'permil': 8240,
    'prime': 8242,
    'Prime': 8243,
    'lsaquo': 8249,
    'rsaquo': 8250,
    'oline': 8254,
    'frasl': 8260,
    'euro': 8364,
    'image': 8465,
    'weierp': 8472,
    'real': 8476,
    'trade': 8482,
    'alefsym': 8501,
    'larr': 8592,
    'uarr': 8593,
    'rarr': 8594,
    'darr': 8595,
    'harr': 8596,
    'crarr': 8629,
    'lArr': 8656,
    'uArr': 8657,
    'rArr': 8658,
    'dArr': 8659,
    'hArr': 8660,
    'forall': 8704,
    'part': 8706,
    'exist': 8707,
    'empty': 8709,
    'nabla': 8711,
    'isin': 8712,
    'notin': 8713,
    'ni': 8715,
    'prod': 8719,
    'sum': 8721,
    'minus': 8722,
    'lowast': 8727,
    'radic': 8730,
    'prop': 8733,
    'infin': 8734,
    'ang': 8736,
    'and': 8743,
    'or': 8744,
    'cap': 8745,
    'cup': 8746,
    'int': 8747,
    'there4': 8756,
    'sim': 8764,
    'cong': 8773,
    'asymp': 8776,
    'ne': 8800,
    'equiv': 8801,
    'le': 8804,
    'ge': 8805,
    'sub': 8834,
    'sup': 8835,
    'nsub': 8836,
    'sube': 8838,
    'supe': 8839,
    'oplus': 8853,
    'otimes': 8855,
    'perp': 8869,
    'sdot': 8901,
    'lceil': 8968,
    'rceil': 8969,
    'lfloor': 8970,
    'rfloor': 8971,
    'lang': 9001,
    'rang': 9002,
    'loz': 9674,
    'spades': 9824,
    'clubs': 9827,
    'hearts': 9829,
    'diams': 9830
  };

  Object.keys(sax.ENTITIES).forEach(function (key) {
    var e = sax.ENTITIES[key];
    var s = typeof e === 'number' ? String.fromCharCode(e) : e;
    sax.ENTITIES[key] = s;
  });

  for (var s in sax.STATE) {
    sax.STATE[sax.STATE[s]] = s;
  }

  // shorthand
  S = sax.STATE;

  function emit(parser, event, data) {
    parser[event] && parser[event](data);
  }

  function emitNode(parser, nodeType, data) {
    if (parser.textNode) closeText(parser);
    emit(parser, nodeType, data);
  }

  function closeText(parser) {
    parser.textNode = textopts(parser.opt, parser.textNode);
    if (parser.textNode) emit(parser, 'ontext', parser.textNode);
    parser.textNode = '';
  }

  function textopts(opt, text) {
    if (opt.trim) text = text.trim();
    if (opt.normalize) text = text.replace(/\s+/g, ' ');
    return text;
  }

  function error(parser, er) {
    closeText(parser);
    if (parser.trackPosition) {
      er += '\nLine: ' + parser.line + '\nColumn: ' + parser.column + '\nChar: ' + parser.c;
    }
    er = new Error(er);
    parser.error = er;
    emit(parser, 'onerror', er);
    return parser;
  }

  function end(parser) {
    if (parser.sawRoot && !parser.closedRoot) strictFail(parser, 'Unclosed root tag');
    if (parser.state !== S.BEGIN && parser.state !== S.BEGIN_WHITESPACE && parser.state !== S.TEXT) {
      error(parser, 'Unexpected end');
    }
    closeText(parser);
    parser.c = '';
    parser.closed = true;
    emit(parser, 'onend');
    SAXParser.call(parser, parser.strict, parser.opt);
    return parser;
  }

  function strictFail(parser, message) {
    if (typeof parser !== 'object' || !(parser instanceof SAXParser)) {
      throw new Error('bad call to strictFail');
    }
    if (parser.strict) {
      error(parser, message);
    }
  }

  function newTag(parser) {
    if (!parser.strict) parser.tagName = parser.tagName[parser.looseCase]();
    var parent = parser.tags[parser.tags.length - 1] || parser;
    var tag = parser.tag = { name: parser.tagName, attributes: {}

      // will be overridden if tag contails an xmlns="foo" or xmlns:foo="bar"
    };if (parser.opt.xmlns) {
      tag.ns = parent.ns;
    }
    parser.attribList.length = 0;
    emitNode(parser, 'onopentagstart', tag);
  }

  function qname(name, attribute) {
    var i = name.indexOf(':');
    var qualName = i < 0 ? ['', name] : name.split(':');
    var prefix = qualName[0];
    var local = qualName[1];

    // <x "xmlns"="http://foo">
    if (attribute && name === 'xmlns') {
      prefix = 'xmlns';
      local = '';
    }

    return { prefix: prefix, local: local };
  }

  function attrib(parser) {
    if (!parser.strict) {
      parser.attribName = parser.attribName[parser.looseCase]();
    }

    if (parser.attribList.indexOf(parser.attribName) !== -1 || parser.tag.attributes.hasOwnProperty(parser.attribName)) {
      parser.attribName = parser.attribValue = '';
      return;
    }

    if (parser.opt.xmlns) {
      var qn = qname(parser.attribName, true);
      var prefix = qn.prefix;
      var local = qn.local;

      if (prefix === 'xmlns') {
        // namespace binding attribute. push the binding into scope
        if (local === 'xml' && parser.attribValue !== XML_NAMESPACE) {
          strictFail(parser, 'xml: prefix must be bound to ' + XML_NAMESPACE + '\n' + 'Actual: ' + parser.attribValue);
        } else if (local === 'xmlns' && parser.attribValue !== XMLNS_NAMESPACE) {
          strictFail(parser, 'xmlns: prefix must be bound to ' + XMLNS_NAMESPACE + '\n' + 'Actual: ' + parser.attribValue);
        } else {
          var tag = parser.tag;
          var parent = parser.tags[parser.tags.length - 1] || parser;
          if (tag.ns === parent.ns) {
            tag.ns = Object.create(parent.ns);
          }
          tag.ns[local] = parser.attribValue;
        }
      }

      // defer onattribute events until all attributes have been seen
      // so any new bindings can take effect. preserve attribute order
      // so deferred events can be emitted in document order
      parser.attribList.push([parser.attribName, parser.attribValue]);
    } else {
      // in non-xmlns mode, we can emit the event right away
      parser.tag.attributes[parser.attribName] = parser.attribValue;
      emitNode(parser, 'onattribute', {
        name: parser.attribName,
        value: parser.attribValue
      });
    }

    parser.attribName = parser.attribValue = '';
  }

  function openTag(parser, selfClosing) {
    if (parser.opt.xmlns) {
      // emit namespace binding events
      var tag = parser.tag;

      // add namespace info to tag
      var qn = qname(parser.tagName);
      tag.prefix = qn.prefix;
      tag.local = qn.local;
      tag.uri = tag.ns[qn.prefix] || '';

      if (tag.prefix && !tag.uri) {
        strictFail(parser, 'Unbound namespace prefix: ' + JSON.stringify(parser.tagName));
        tag.uri = qn.prefix;
      }

      var parent = parser.tags[parser.tags.length - 1] || parser;
      if (tag.ns && parent.ns !== tag.ns) {
        Object.keys(tag.ns).forEach(function (p) {
          emitNode(parser, 'onopennamespace', {
            prefix: p,
            uri: tag.ns[p]
          });
        });
      }

      // handle deferred onattribute events
      // Note: do not apply default ns to attributes:
      //   http://www.w3.org/TR/REC-xml-names/#defaulting
      for (var i = 0, l = parser.attribList.length; i < l; i++) {
        var nv = parser.attribList[i];
        var name = nv[0];
        var value = nv[1];
        var qualName = qname(name, true);
        var prefix = qualName.prefix;
        var local = qualName.local;
        var uri = prefix === '' ? '' : tag.ns[prefix] || '';
        var a = {
          name: name,
          value: value,
          prefix: prefix,
          local: local,
          uri: uri

          // if there's any attributes with an undefined namespace,
          // then fail on them now.
        };if (prefix && prefix !== 'xmlns' && !uri) {
          strictFail(parser, 'Unbound namespace prefix: ' + JSON.stringify(prefix));
          a.uri = prefix;
        }
        parser.tag.attributes[name] = a;
        emitNode(parser, 'onattribute', a);
      }
      parser.attribList.length = 0;
    }

    parser.tag.isSelfClosing = !!selfClosing;

    // process the tag
    parser.sawRoot = true;
    parser.tags.push(parser.tag);
    emitNode(parser, 'onopentag', parser.tag);
    if (!selfClosing) {
      // special case for <script> in non-strict mode.
      if (!parser.noscript && parser.tagName.toLowerCase() === 'script') {
        parser.state = S.SCRIPT;
      } else {
        parser.state = S.TEXT;
      }
      parser.tag = null;
      parser.tagName = '';
    }
    parser.attribName = parser.attribValue = '';
    parser.attribList.length = 0;
  }

  function closeTag(parser) {
    if (!parser.tagName) {
      strictFail(parser, 'Weird empty close tag.');
      parser.textNode += '</>';
      parser.state = S.TEXT;
      return;
    }

    if (parser.script) {
      if (parser.tagName !== 'script') {
        parser.script += '</' + parser.tagName + '>';
        parser.tagName = '';
        parser.state = S.SCRIPT;
        return;
      }
      emitNode(parser, 'onscript', parser.script);
      parser.script = '';
    }

    // first make sure that the closing tag actually exists.
    // <a><b></c></b></a> will close everything, otherwise.
    var t = parser.tags.length;
    var tagName = parser.tagName;
    if (!parser.strict) {
      tagName = tagName[parser.looseCase]();
    }
    var closeTo = tagName;
    while (t--) {
      var close = parser.tags[t];
      if (close.name !== closeTo) {
        // fail the first time in strict mode
        strictFail(parser, 'Unexpected close tag');
      } else {
        break;
      }
    }

    // didn't find it.  we already failed for strict, so just abort.
    if (t < 0) {
      strictFail(parser, 'Unmatched closing tag: ' + parser.tagName);
      parser.textNode += '</' + parser.tagName + '>';
      parser.state = S.TEXT;
      return;
    }
    parser.tagName = tagName;
    var s = parser.tags.length;
    while (s-- > t) {
      var tag = parser.tag = parser.tags.pop();
      parser.tagName = parser.tag.name;
      emitNode(parser, 'onclosetag', parser.tagName);

      var x = {};
      for (var i in tag.ns) {
        x[i] = tag.ns[i];
      }

      var parent = parser.tags[parser.tags.length - 1] || parser;
      if (parser.opt.xmlns && tag.ns !== parent.ns) {
        // remove namespace bindings introduced by tag
        Object.keys(tag.ns).forEach(function (p) {
          var n = tag.ns[p];
          emitNode(parser, 'onclosenamespace', { prefix: p, uri: n });
        });
      }
    }
    if (t === 0) parser.closedRoot = true;
    parser.tagName = parser.attribValue = parser.attribName = '';
    parser.attribList.length = 0;
    parser.state = S.TEXT;
  }

  function parseEntity(parser) {
    var entity = parser.entity;
    var entityLC = entity.toLowerCase();
    var num;
    var numStr = '';

    if (parser.ENTITIES[entity]) {
      return parser.ENTITIES[entity];
    }
    if (parser.ENTITIES[entityLC]) {
      return parser.ENTITIES[entityLC];
    }
    entity = entityLC;
    if (entity.charAt(0) === '#') {
      if (entity.charAt(1) === 'x') {
        entity = entity.slice(2);
        num = parseInt(entity, 16);
        numStr = num.toString(16);
      } else {
        entity = entity.slice(1);
        num = parseInt(entity, 10);
        numStr = num.toString(10);
      }
    }
    entity = entity.replace(/^0+/, '');
    if (isNaN(num) || numStr.toLowerCase() !== entity) {
      strictFail(parser, 'Invalid character entity');
      return '&' + parser.entity + ';';
    }

    return String.fromCodePoint(num);
  }

  function beginWhiteSpace(parser, c) {
    if (c === '<') {
      parser.state = S.OPEN_WAKA;
      parser.startTagPosition = parser.position;
    } else if (!isWhitespace(c)) {
      // have to process this as a text node.
      // weird, but happens.
      strictFail(parser, 'Non-whitespace before first tag.');
      parser.textNode = c;
      parser.state = S.TEXT;
    }
  }

  function charAt(chunk, i) {
    var result = '';
    if (i < chunk.length) {
      result = chunk.charAt(i);
    }
    return result;
  }

  function write(chunk) {
    var parser = this;
    if (this.error) {
      throw this.error;
    }
    if (parser.closed) {
      return error(parser, 'Cannot write after close. Assign an onready handler.');
    }
    if (chunk === null) {
      return end(parser);
    }
    if (typeof chunk === 'object') {
      chunk = chunk.toString();
    }
    var i = 0;
    var c = '';
    while (true) {
      c = charAt(chunk, i++);
      parser.c = c;

      if (!c) {
        break;
      }

      if (parser.trackPosition) {
        parser.position++;
        if (c === '\n') {
          parser.line++;
          parser.column = 0;
        } else {
          parser.column++;
        }
      }

      switch (parser.state) {
        case S.BEGIN:
          parser.state = S.BEGIN_WHITESPACE;
          if (c === '\uFEFF') {
            continue;
          }
          beginWhiteSpace(parser, c);
          continue;

        case S.BEGIN_WHITESPACE:
          beginWhiteSpace(parser, c);
          continue;

        case S.TEXT:
          if (parser.sawRoot && !parser.closedRoot) {
            var starti = i - 1;
            while (c && c !== '<' && c !== '&') {
              c = charAt(chunk, i++);
              if (c && parser.trackPosition) {
                parser.position++;
                if (c === '\n') {
                  parser.line++;
                  parser.column = 0;
                } else {
                  parser.column++;
                }
              }
            }
            parser.textNode += chunk.substring(starti, i - 1);
          }
          if (c === '<' && !(parser.sawRoot && parser.closedRoot && !parser.strict)) {
            parser.state = S.OPEN_WAKA;
            parser.startTagPosition = parser.position;
          } else {
            if (!isWhitespace(c) && (!parser.sawRoot || parser.closedRoot)) {
              strictFail(parser, 'Text data outside of root node.');
            }
            if (c === '&') {
              parser.state = S.TEXT_ENTITY;
            } else {
              parser.textNode += c;
            }
          }
          continue;

        case S.SCRIPT:
          // only non-strict
          if (c === '<') {
            parser.state = S.SCRIPT_ENDING;
          } else {
            parser.script += c;
          }
          continue;

        case S.SCRIPT_ENDING:
          if (c === '/') {
            parser.state = S.CLOSE_TAG;
          } else {
            parser.script += '<' + c;
            parser.state = S.SCRIPT;
          }
          continue;

        case S.OPEN_WAKA:
          // either a /, ?, !, or text is coming next.
          if (c === '!') {
            parser.state = S.SGML_DECL;
            parser.sgmlDecl = '';
          } else if (isWhitespace(c)) {
            // wait for it...
          } else if (isMatch(nameStart, c)) {
            parser.state = S.OPEN_TAG;
            parser.tagName = c;
          } else if (c === '/') {
            parser.state = S.CLOSE_TAG;
            parser.tagName = '';
          } else if (c === '?') {
            parser.state = S.PROC_INST;
            parser.procInstName = parser.procInstBody = '';
          } else {
            strictFail(parser, 'Unencoded <');
            // if there was some whitespace, then add that in.
            if (parser.startTagPosition + 1 < parser.position) {
              var pad = parser.position - parser.startTagPosition;
              c = new Array(pad).join(' ') + c;
            }
            parser.textNode += '<' + c;
            parser.state = S.TEXT;
          }
          continue;

        case S.SGML_DECL:
          if ((parser.sgmlDecl + c).toUpperCase() === CDATA) {
            emitNode(parser, 'onopencdata');
            parser.state = S.CDATA;
            parser.sgmlDecl = '';
            parser.cdata = '';
          } else if (parser.sgmlDecl + c === '--') {
            parser.state = S.COMMENT;
            parser.comment = '';
            parser.sgmlDecl = '';
          } else if ((parser.sgmlDecl + c).toUpperCase() === DOCTYPE) {
            parser.state = S.DOCTYPE;
            if (parser.doctype || parser.sawRoot) {
              strictFail(parser, 'Inappropriately located doctype declaration');
            }
            parser.doctype = '';
            parser.sgmlDecl = '';
          } else if (c === '>') {
            emitNode(parser, 'onsgmldeclaration', parser.sgmlDecl);
            parser.sgmlDecl = '';
            parser.state = S.TEXT;
          } else if (isQuote(c)) {
            parser.state = S.SGML_DECL_QUOTED;
            parser.sgmlDecl += c;
          } else {
            parser.sgmlDecl += c;
          }
          continue;

        case S.SGML_DECL_QUOTED:
          if (c === parser.q) {
            parser.state = S.SGML_DECL;
            parser.q = '';
          }
          parser.sgmlDecl += c;
          continue;

        case S.DOCTYPE:
          if (c === '>') {
            parser.state = S.TEXT;
            emitNode(parser, 'ondoctype', parser.doctype);
            parser.doctype = true; // just remember that we saw it.
          } else {
            parser.doctype += c;
            if (c === '[') {
              parser.state = S.DOCTYPE_DTD;
            } else if (isQuote(c)) {
              parser.state = S.DOCTYPE_QUOTED;
              parser.q = c;
            }
          }
          continue;

        case S.DOCTYPE_QUOTED:
          parser.doctype += c;
          if (c === parser.q) {
            parser.q = '';
            parser.state = S.DOCTYPE;
          }
          continue;

        case S.DOCTYPE_DTD:
          parser.doctype += c;
          if (c === ']') {
            parser.state = S.DOCTYPE;
          } else if (isQuote(c)) {
            parser.state = S.DOCTYPE_DTD_QUOTED;
            parser.q = c;
          }
          continue;

        case S.DOCTYPE_DTD_QUOTED:
          parser.doctype += c;
          if (c === parser.q) {
            parser.state = S.DOCTYPE_DTD;
            parser.q = '';
          }
          continue;

        case S.COMMENT:
          if (c === '-') {
            parser.state = S.COMMENT_ENDING;
          } else {
            parser.comment += c;
          }
          continue;

        case S.COMMENT_ENDING:
          if (c === '-') {
            parser.state = S.COMMENT_ENDED;
            parser.comment = textopts(parser.opt, parser.comment);
            if (parser.comment) {
              emitNode(parser, 'oncomment', parser.comment);
            }
            parser.comment = '';
          } else {
            parser.comment += '-' + c;
            parser.state = S.COMMENT;
          }
          continue;

        case S.COMMENT_ENDED:
          if (c !== '>') {
            strictFail(parser, 'Malformed comment');
            // allow <!-- blah -- bloo --> in non-strict mode,
            // which is a comment of " blah -- bloo "
            parser.comment += '--' + c;
            parser.state = S.COMMENT;
          } else {
            parser.state = S.TEXT;
          }
          continue;

        case S.CDATA:
          if (c === ']') {
            parser.state = S.CDATA_ENDING;
          } else {
            parser.cdata += c;
          }
          continue;

        case S.CDATA_ENDING:
          if (c === ']') {
            parser.state = S.CDATA_ENDING_2;
          } else {
            parser.cdata += ']' + c;
            parser.state = S.CDATA;
          }
          continue;

        case S.CDATA_ENDING_2:
          if (c === '>') {
            if (parser.cdata) {
              emitNode(parser, 'oncdata', parser.cdata);
            }
            emitNode(parser, 'onclosecdata');
            parser.cdata = '';
            parser.state = S.TEXT;
          } else if (c === ']') {
            parser.cdata += ']';
          } else {
            parser.cdata += ']]' + c;
            parser.state = S.CDATA;
          }
          continue;

        case S.PROC_INST:
          if (c === '?') {
            parser.state = S.PROC_INST_ENDING;
          } else if (isWhitespace(c)) {
            parser.state = S.PROC_INST_BODY;
          } else {
            parser.procInstName += c;
          }
          continue;

        case S.PROC_INST_BODY:
          if (!parser.procInstBody && isWhitespace(c)) {
            continue;
          } else if (c === '?') {
            parser.state = S.PROC_INST_ENDING;
          } else {
            parser.procInstBody += c;
          }
          continue;

        case S.PROC_INST_ENDING:
          if (c === '>') {
            emitNode(parser, 'onprocessinginstruction', {
              name: parser.procInstName,
              body: parser.procInstBody
            });
            parser.procInstName = parser.procInstBody = '';
            parser.state = S.TEXT;
          } else {
            parser.procInstBody += '?' + c;
            parser.state = S.PROC_INST_BODY;
          }
          continue;

        case S.OPEN_TAG:
          if (isMatch(nameBody, c)) {
            parser.tagName += c;
          } else {
            newTag(parser);
            if (c === '>') {
              openTag(parser);
            } else if (c === '/') {
              parser.state = S.OPEN_TAG_SLASH;
            } else {
              if (!isWhitespace(c)) {
                strictFail(parser, 'Invalid character in tag name');
              }
              parser.state = S.ATTRIB;
            }
          }
          continue;

        case S.OPEN_TAG_SLASH:
          if (c === '>') {
            openTag(parser, true);
            closeTag(parser);
          } else {
            strictFail(parser, 'Forward-slash in opening tag not followed by >');
            parser.state = S.ATTRIB;
          }
          continue;

        case S.ATTRIB:
          // haven't read the attribute name yet.
          if (isWhitespace(c)) {
            continue;
          } else if (c === '>') {
            openTag(parser);
          } else if (c === '/') {
            parser.state = S.OPEN_TAG_SLASH;
          } else if (isMatch(nameStart, c)) {
            parser.attribName = c;
            parser.attribValue = '';
            parser.state = S.ATTRIB_NAME;
          } else {
            strictFail(parser, 'Invalid attribute name');
          }
          continue;

        case S.ATTRIB_NAME:
          if (c === '=') {
            parser.state = S.ATTRIB_VALUE;
          } else if (c === '>') {
            strictFail(parser, 'Attribute without value');
            parser.attribValue = parser.attribName;
            attrib(parser);
            openTag(parser);
          } else if (isWhitespace(c)) {
            parser.state = S.ATTRIB_NAME_SAW_WHITE;
          } else if (isMatch(nameBody, c)) {
            parser.attribName += c;
          } else {
            strictFail(parser, 'Invalid attribute name');
          }
          continue;

        case S.ATTRIB_NAME_SAW_WHITE:
          if (c === '=') {
            parser.state = S.ATTRIB_VALUE;
          } else if (isWhitespace(c)) {
            continue;
          } else {
            strictFail(parser, 'Attribute without value');
            parser.tag.attributes[parser.attribName] = '';
            parser.attribValue = '';
            emitNode(parser, 'onattribute', {
              name: parser.attribName,
              value: ''
            });
            parser.attribName = '';
            if (c === '>') {
              openTag(parser);
            } else if (isMatch(nameStart, c)) {
              parser.attribName = c;
              parser.state = S.ATTRIB_NAME;
            } else {
              strictFail(parser, 'Invalid attribute name');
              parser.state = S.ATTRIB;
            }
          }
          continue;

        case S.ATTRIB_VALUE:
          if (isWhitespace(c)) {
            continue;
          } else if (isQuote(c)) {
            parser.q = c;
            parser.state = S.ATTRIB_VALUE_QUOTED;
          } else {
            strictFail(parser, 'Unquoted attribute value');
            parser.state = S.ATTRIB_VALUE_UNQUOTED;
            parser.attribValue = c;
          }
          continue;

        case S.ATTRIB_VALUE_QUOTED:
          if (c !== parser.q) {
            if (c === '&') {
              parser.state = S.ATTRIB_VALUE_ENTITY_Q;
            } else {
              parser.attribValue += c;
            }
            continue;
          }
          attrib(parser);
          parser.q = '';
          parser.state = S.ATTRIB_VALUE_CLOSED;
          continue;

        case S.ATTRIB_VALUE_CLOSED:
          if (isWhitespace(c)) {
            parser.state = S.ATTRIB;
          } else if (c === '>') {
            openTag(parser);
          } else if (c === '/') {
            parser.state = S.OPEN_TAG_SLASH;
          } else if (isMatch(nameStart, c)) {
            strictFail(parser, 'No whitespace between attributes');
            parser.attribName = c;
            parser.attribValue = '';
            parser.state = S.ATTRIB_NAME;
          } else {
            strictFail(parser, 'Invalid attribute name');
          }
          continue;

        case S.ATTRIB_VALUE_UNQUOTED:
          if (!isAttribEnd(c)) {
            if (c === '&') {
              parser.state = S.ATTRIB_VALUE_ENTITY_U;
            } else {
              parser.attribValue += c;
            }
            continue;
          }
          attrib(parser);
          if (c === '>') {
            openTag(parser);
          } else {
            parser.state = S.ATTRIB;
          }
          continue;

        case S.CLOSE_TAG:
          if (!parser.tagName) {
            if (isWhitespace(c)) {
              continue;
            } else if (notMatch(nameStart, c)) {
              if (parser.script) {
                parser.script += '</' + c;
                parser.state = S.SCRIPT;
              } else {
                strictFail(parser, 'Invalid tagname in closing tag.');
              }
            } else {
              parser.tagName = c;
            }
          } else if (c === '>') {
            closeTag(parser);
          } else if (isMatch(nameBody, c)) {
            parser.tagName += c;
          } else if (parser.script) {
            parser.script += '</' + parser.tagName;
            parser.tagName = '';
            parser.state = S.SCRIPT;
          } else {
            if (!isWhitespace(c)) {
              strictFail(parser, 'Invalid tagname in closing tag');
            }
            parser.state = S.CLOSE_TAG_SAW_WHITE;
          }
          continue;

        case S.CLOSE_TAG_SAW_WHITE:
          if (isWhitespace(c)) {
            continue;
          }
          if (c === '>') {
            closeTag(parser);
          } else {
            strictFail(parser, 'Invalid characters in closing tag');
          }
          continue;

        case S.TEXT_ENTITY:
        case S.ATTRIB_VALUE_ENTITY_Q:
        case S.ATTRIB_VALUE_ENTITY_U:
          var returnState;
          var buffer;
          switch (parser.state) {
            case S.TEXT_ENTITY:
              returnState = S.TEXT;
              buffer = 'textNode';
              break;

            case S.ATTRIB_VALUE_ENTITY_Q:
              returnState = S.ATTRIB_VALUE_QUOTED;
              buffer = 'attribValue';
              break;

            case S.ATTRIB_VALUE_ENTITY_U:
              returnState = S.ATTRIB_VALUE_UNQUOTED;
              buffer = 'attribValue';
              break;
          }

          if (c === ';') {
            parser[buffer] += parseEntity(parser);
            parser.entity = '';
            parser.state = returnState;
          } else if (isMatch(parser.entity.length ? entityBody : entityStart, c)) {
            parser.entity += c;
          } else {
            strictFail(parser, 'Invalid character in entity name');
            parser[buffer] += '&' + parser.entity + c;
            parser.entity = '';
            parser.state = returnState;
          }

          continue;

        default:
          throw new Error(parser, 'Unknown state: ' + parser.state);
      }
    } // while

    if (parser.position >= parser.bufferCheckPosition) {
      checkBufferLength(parser);
    }
    return parser;
  }

  /*! http://mths.be/fromcodepoint v0.1.0 by @mathias */
  /* istanbul ignore next */
  if (!String.fromCodePoint) {
    (function () {
      var stringFromCharCode = String.fromCharCode;
      var floor = Math.floor;
      var fromCodePoint = function () {
        var MAX_SIZE = 0x4000;
        var codeUnits = [];
        var highSurrogate;
        var lowSurrogate;
        var index = -1;
        var length = arguments.length;
        if (!length) {
          return '';
        }
        var result = '';
        while (++index < length) {
          var codePoint = Number(arguments[index]);
          if (!isFinite(codePoint) || // `NaN`, `+Infinity`, or `-Infinity`
          codePoint < 0 || // not a valid Unicode code point
          codePoint > 0x10FFFF || // not a valid Unicode code point
          floor(codePoint) !== codePoint // not an integer
          ) {
              throw RangeError('Invalid code point: ' + codePoint);
            }
          if (codePoint <= 0xFFFF) {
            // BMP code point
            codeUnits.push(codePoint);
          } else {
            // Astral code point; split in surrogate halves
            // http://mathiasbynens.be/notes/javascript-encoding#surrogate-formulae
            codePoint -= 0x10000;
            highSurrogate = (codePoint >> 10) + 0xD800;
            lowSurrogate = codePoint % 0x400 + 0xDC00;
            codeUnits.push(highSurrogate, lowSurrogate);
          }
          if (index + 1 === length || codeUnits.length > MAX_SIZE) {
            result += stringFromCharCode.apply(null, codeUnits);
            codeUnits.length = 0;
          }
        }
        return result;
      };
      /* istanbul ignore next */
      if (Object.defineProperty) {
        Object.defineProperty(String, 'fromCodePoint', {
          value: fromCodePoint,
          configurable: true,
          writable: true
        });
      } else {
        String.fromCodePoint = fromCodePoint;
      }
    })();
  }
})( false ? undefined.sax = {} : exports);

/***/ }),
/* 136 */
/***/ (function(module, exports) {

module.exports = require("string_decoder");

/***/ }),
/* 137 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var loader = __webpack_require__(138);
var dumper = __webpack_require__(158);

function deprecated(name) {
  return function () {
    throw new Error('Function ' + name + ' is deprecated and cannot be used.');
  };
}

module.exports.Type = __webpack_require__(4);
module.exports.Schema = __webpack_require__(18);
module.exports.FAILSAFE_SCHEMA = __webpack_require__(32);
module.exports.JSON_SCHEMA = __webpack_require__(54);
module.exports.CORE_SCHEMA = __webpack_require__(53);
module.exports.DEFAULT_SAFE_SCHEMA = __webpack_require__(22);
module.exports.DEFAULT_FULL_SCHEMA = __webpack_require__(25);
module.exports.load = loader.load;
module.exports.loadAll = loader.loadAll;
module.exports.safeLoad = loader.safeLoad;
module.exports.safeLoadAll = loader.safeLoadAll;
module.exports.dump = dumper.dump;
module.exports.safeDump = dumper.safeDump;
module.exports.YAMLException = __webpack_require__(21);

// Deprecated schema names from JS-YAML 2.0.x
module.exports.MINIMAL_SCHEMA = __webpack_require__(32);
module.exports.SAFE_SCHEMA = __webpack_require__(22);
module.exports.DEFAULT_SCHEMA = __webpack_require__(25);

// Deprecated functions from JS-YAML 1.x.x
module.exports.scan = deprecated('scan');
module.exports.parse = deprecated('parse');
module.exports.compose = deprecated('compose');
module.exports.addConstructor = deprecated('addConstructor');

/***/ }),
/* 138 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/*eslint-disable max-len,no-use-before-define*/

var common = __webpack_require__(17);
var YAMLException = __webpack_require__(21);
var Mark = __webpack_require__(139);
var DEFAULT_SAFE_SCHEMA = __webpack_require__(22);
var DEFAULT_FULL_SCHEMA = __webpack_require__(25);

var _hasOwnProperty = Object.prototype.hasOwnProperty;

var CONTEXT_FLOW_IN = 1;
var CONTEXT_FLOW_OUT = 2;
var CONTEXT_BLOCK_IN = 3;
var CONTEXT_BLOCK_OUT = 4;

var CHOMPING_CLIP = 1;
var CHOMPING_STRIP = 2;
var CHOMPING_KEEP = 3;

var PATTERN_NON_PRINTABLE = /[\x00-\x08\x0B\x0C\x0E-\x1F\x7F-\x84\x86-\x9F\uFFFE\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]/;
var PATTERN_NON_ASCII_LINE_BREAKS = /[\x85\u2028\u2029]/;
var PATTERN_FLOW_INDICATORS = /[,\[\]\{\}]/;
var PATTERN_TAG_HANDLE = /^(?:!|!!|![a-z\-]+!)$/i;
var PATTERN_TAG_URI = /^(?:!|[^,\[\]\{\}])(?:%[0-9a-f]{2}|[0-9a-z\-#;\/\?:@&=\+\$,_\.!~\*'\(\)\[\]])*$/i;

function is_EOL(c) {
  return c === 0x0A /* LF */ || c === 0x0D /* CR */;
}

function is_WHITE_SPACE(c) {
  return c === 0x09 /* Tab */ || c === 0x20 /* Space */;
}

function is_WS_OR_EOL(c) {
  return c === 0x09 /* Tab */ || c === 0x20 /* Space */ || c === 0x0A /* LF */ || c === 0x0D /* CR */;
}

function is_FLOW_INDICATOR(c) {
  return c === 0x2C /* , */ || c === 0x5B /* [ */ || c === 0x5D /* ] */ || c === 0x7B /* { */ || c === 0x7D /* } */;
}

function fromHexCode(c) {
  var lc;

  if (0x30 /* 0 */ <= c && c <= 0x39 /* 9 */) {
    return c - 0x30;
  }

  /*eslint-disable no-bitwise*/
  lc = c | 0x20;

  if (0x61 /* a */ <= lc && lc <= 0x66 /* f */) {
    return lc - 0x61 + 10;
  }

  return -1;
}

function escapedHexLen(c) {
  if (c === 0x78 /* x */) {
      return 2;
    }
  if (c === 0x75 /* u */) {
      return 4;
    }
  if (c === 0x55 /* U */) {
      return 8;
    }
  return 0;
}

function fromDecimalCode(c) {
  if (0x30 /* 0 */ <= c && c <= 0x39 /* 9 */) {
    return c - 0x30;
  }

  return -1;
}

function simpleEscapeSequence(c) {
  /* eslint-disable indent */
  return c === 0x30 /* 0 */ ? '\x00' : c === 0x61 /* a */ ? '\x07' : c === 0x62 /* b */ ? '\x08' : c === 0x74 /* t */ ? '\x09' : c === 0x09 /* Tab */ ? '\x09' : c === 0x6E /* n */ ? '\x0A' : c === 0x76 /* v */ ? '\x0B' : c === 0x66 /* f */ ? '\x0C' : c === 0x72 /* r */ ? '\x0D' : c === 0x65 /* e */ ? '\x1B' : c === 0x20 /* Space */ ? ' ' : c === 0x22 /* " */ ? '\x22' : c === 0x2F /* / */ ? '/' : c === 0x5C /* \ */ ? '\x5C' : c === 0x4E /* N */ ? '\x85' : c === 0x5F /* _ */ ? '\xA0' : c === 0x4C /* L */ ? '\u2028' : c === 0x50 /* P */ ? '\u2029' : '';
}

function charFromCodepoint(c) {
  if (c <= 0xFFFF) {
    return String.fromCharCode(c);
  }
  // Encode UTF-16 surrogate pair
  // https://en.wikipedia.org/wiki/UTF-16#Code_points_U.2B010000_to_U.2B10FFFF
  return String.fromCharCode((c - 0x010000 >> 10) + 0xD800, (c - 0x010000 & 0x03FF) + 0xDC00);
}

var simpleEscapeCheck = new Array(256); // integer, for fast access
var simpleEscapeMap = new Array(256);
for (var i = 0; i < 256; i++) {
  simpleEscapeCheck[i] = simpleEscapeSequence(i) ? 1 : 0;
  simpleEscapeMap[i] = simpleEscapeSequence(i);
}

function State(input, options) {
  this.input = input;

  this.filename = options['filename'] || null;
  this.schema = options['schema'] || DEFAULT_FULL_SCHEMA;
  this.onWarning = options['onWarning'] || null;
  this.legacy = options['legacy'] || false;
  this.json = options['json'] || false;
  this.listener = options['listener'] || null;

  this.implicitTypes = this.schema.compiledImplicit;
  this.typeMap = this.schema.compiledTypeMap;

  this.length = input.length;
  this.position = 0;
  this.line = 0;
  this.lineStart = 0;
  this.lineIndent = 0;

  this.documents = [];

  /*
  this.version;
  this.checkLineBreaks;
  this.tagMap;
  this.anchorMap;
  this.tag;
  this.anchor;
  this.kind;
  this.result;*/
}

function generateError(state, message) {
  return new YAMLException(message, new Mark(state.filename, state.input, state.position, state.line, state.position - state.lineStart));
}

function throwError(state, message) {
  throw generateError(state, message);
}

function throwWarning(state, message) {
  if (state.onWarning) {
    state.onWarning.call(null, generateError(state, message));
  }
}

var directiveHandlers = {

  YAML: function handleYamlDirective(state, name, args) {

    var match, major, minor;

    if (state.version !== null) {
      throwError(state, 'duplication of %YAML directive');
    }

    if (args.length !== 1) {
      throwError(state, 'YAML directive accepts exactly one argument');
    }

    match = /^([0-9]+)\.([0-9]+)$/.exec(args[0]);

    if (match === null) {
      throwError(state, 'ill-formed argument of the YAML directive');
    }

    major = parseInt(match[1], 10);
    minor = parseInt(match[2], 10);

    if (major !== 1) {
      throwError(state, 'unacceptable YAML version of the document');
    }

    state.version = args[0];
    state.checkLineBreaks = minor < 2;

    if (minor !== 1 && minor !== 2) {
      throwWarning(state, 'unsupported YAML version of the document');
    }
  },

  TAG: function handleTagDirective(state, name, args) {

    var handle, prefix;

    if (args.length !== 2) {
      throwError(state, 'TAG directive accepts exactly two arguments');
    }

    handle = args[0];
    prefix = args[1];

    if (!PATTERN_TAG_HANDLE.test(handle)) {
      throwError(state, 'ill-formed tag handle (first argument) of the TAG directive');
    }

    if (_hasOwnProperty.call(state.tagMap, handle)) {
      throwError(state, 'there is a previously declared suffix for "' + handle + '" tag handle');
    }

    if (!PATTERN_TAG_URI.test(prefix)) {
      throwError(state, 'ill-formed tag prefix (second argument) of the TAG directive');
    }

    state.tagMap[handle] = prefix;
  }
};

function captureSegment(state, start, end, checkJson) {
  var _position, _length, _character, _result;

  if (start < end) {
    _result = state.input.slice(start, end);

    if (checkJson) {
      for (_position = 0, _length = _result.length; _position < _length; _position += 1) {
        _character = _result.charCodeAt(_position);
        if (!(_character === 0x09 || 0x20 <= _character && _character <= 0x10FFFF)) {
          throwError(state, 'expected valid JSON character');
        }
      }
    } else if (PATTERN_NON_PRINTABLE.test(_result)) {
      throwError(state, 'the stream contains non-printable characters');
    }

    state.result += _result;
  }
}

function mergeMappings(state, destination, source, overridableKeys) {
  var sourceKeys, key, index, quantity;

  if (!common.isObject(source)) {
    throwError(state, 'cannot merge mappings; the provided source object is unacceptable');
  }

  sourceKeys = Object.keys(source);

  for (index = 0, quantity = sourceKeys.length; index < quantity; index += 1) {
    key = sourceKeys[index];

    if (!_hasOwnProperty.call(destination, key)) {
      destination[key] = source[key];
      overridableKeys[key] = true;
    }
  }
}

function storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, valueNode, startLine, startPos) {
  var index, quantity;

  keyNode = String(keyNode);

  if (_result === null) {
    _result = {};
  }

  if (keyTag === 'tag:yaml.org,2002:merge') {
    if (Array.isArray(valueNode)) {
      for (index = 0, quantity = valueNode.length; index < quantity; index += 1) {
        mergeMappings(state, _result, valueNode[index], overridableKeys);
      }
    } else {
      mergeMappings(state, _result, valueNode, overridableKeys);
    }
  } else {
    if (!state.json && !_hasOwnProperty.call(overridableKeys, keyNode) && _hasOwnProperty.call(_result, keyNode)) {
      state.line = startLine || state.line;
      state.position = startPos || state.position;
      throwError(state, 'duplicated mapping key');
    }
    _result[keyNode] = valueNode;
    delete overridableKeys[keyNode];
  }

  return _result;
}

function readLineBreak(state) {
  var ch;

  ch = state.input.charCodeAt(state.position);

  if (ch === 0x0A /* LF */) {
      state.position++;
    } else if (ch === 0x0D /* CR */) {
      state.position++;
      if (state.input.charCodeAt(state.position) === 0x0A /* LF */) {
          state.position++;
        }
    } else {
    throwError(state, 'a line break is expected');
  }

  state.line += 1;
  state.lineStart = state.position;
}

function skipSeparationSpace(state, allowComments, checkIndent) {
  var lineBreaks = 0,
      ch = state.input.charCodeAt(state.position);

  while (ch !== 0) {
    while (is_WHITE_SPACE(ch)) {
      ch = state.input.charCodeAt(++state.position);
    }

    if (allowComments && ch === 0x23 /* # */) {
        do {
          ch = state.input.charCodeAt(++state.position);
        } while (ch !== 0x0A /* LF */ && ch !== 0x0D /* CR */ && ch !== 0);
      }

    if (is_EOL(ch)) {
      readLineBreak(state);

      ch = state.input.charCodeAt(state.position);
      lineBreaks++;
      state.lineIndent = 0;

      while (ch === 0x20 /* Space */) {
        state.lineIndent++;
        ch = state.input.charCodeAt(++state.position);
      }
    } else {
      break;
    }
  }

  if (checkIndent !== -1 && lineBreaks !== 0 && state.lineIndent < checkIndent) {
    throwWarning(state, 'deficient indentation');
  }

  return lineBreaks;
}

function testDocumentSeparator(state) {
  var _position = state.position,
      ch;

  ch = state.input.charCodeAt(_position);

  // Condition state.position === state.lineStart is tested
  // in parent on each call, for efficiency. No needs to test here again.
  if ((ch === 0x2D /* - */ || ch === 0x2E /* . */) && ch === state.input.charCodeAt(_position + 1) && ch === state.input.charCodeAt(_position + 2)) {

    _position += 3;

    ch = state.input.charCodeAt(_position);

    if (ch === 0 || is_WS_OR_EOL(ch)) {
      return true;
    }
  }

  return false;
}

function writeFoldedLines(state, count) {
  if (count === 1) {
    state.result += ' ';
  } else if (count > 1) {
    state.result += common.repeat('\n', count - 1);
  }
}

function readPlainScalar(state, nodeIndent, withinFlowCollection) {
  var preceding,
      following,
      captureStart,
      captureEnd,
      hasPendingContent,
      _line,
      _lineStart,
      _lineIndent,
      _kind = state.kind,
      _result = state.result,
      ch;

  ch = state.input.charCodeAt(state.position);

  if (is_WS_OR_EOL(ch) || is_FLOW_INDICATOR(ch) || ch === 0x23 /* # */ || ch === 0x26 /* & */ || ch === 0x2A /* * */ || ch === 0x21 /* ! */ || ch === 0x7C /* | */ || ch === 0x3E /* > */ || ch === 0x27 /* ' */ || ch === 0x22 /* " */ || ch === 0x25 /* % */ || ch === 0x40 /* @ */ || ch === 0x60 /* ` */) {
      return false;
    }

  if (ch === 0x3F /* ? */ || ch === 0x2D /* - */) {
      following = state.input.charCodeAt(state.position + 1);

      if (is_WS_OR_EOL(following) || withinFlowCollection && is_FLOW_INDICATOR(following)) {
        return false;
      }
    }

  state.kind = 'scalar';
  state.result = '';
  captureStart = captureEnd = state.position;
  hasPendingContent = false;

  while (ch !== 0) {
    if (ch === 0x3A /* : */) {
        following = state.input.charCodeAt(state.position + 1);

        if (is_WS_OR_EOL(following) || withinFlowCollection && is_FLOW_INDICATOR(following)) {
          break;
        }
      } else if (ch === 0x23 /* # */) {
        preceding = state.input.charCodeAt(state.position - 1);

        if (is_WS_OR_EOL(preceding)) {
          break;
        }
      } else if (state.position === state.lineStart && testDocumentSeparator(state) || withinFlowCollection && is_FLOW_INDICATOR(ch)) {
      break;
    } else if (is_EOL(ch)) {
      _line = state.line;
      _lineStart = state.lineStart;
      _lineIndent = state.lineIndent;
      skipSeparationSpace(state, false, -1);

      if (state.lineIndent >= nodeIndent) {
        hasPendingContent = true;
        ch = state.input.charCodeAt(state.position);
        continue;
      } else {
        state.position = captureEnd;
        state.line = _line;
        state.lineStart = _lineStart;
        state.lineIndent = _lineIndent;
        break;
      }
    }

    if (hasPendingContent) {
      captureSegment(state, captureStart, captureEnd, false);
      writeFoldedLines(state, state.line - _line);
      captureStart = captureEnd = state.position;
      hasPendingContent = false;
    }

    if (!is_WHITE_SPACE(ch)) {
      captureEnd = state.position + 1;
    }

    ch = state.input.charCodeAt(++state.position);
  }

  captureSegment(state, captureStart, captureEnd, false);

  if (state.result) {
    return true;
  }

  state.kind = _kind;
  state.result = _result;
  return false;
}

function readSingleQuotedScalar(state, nodeIndent) {
  var ch, captureStart, captureEnd;

  ch = state.input.charCodeAt(state.position);

  if (ch !== 0x27 /* ' */) {
      return false;
    }

  state.kind = 'scalar';
  state.result = '';
  state.position++;
  captureStart = captureEnd = state.position;

  while ((ch = state.input.charCodeAt(state.position)) !== 0) {
    if (ch === 0x27 /* ' */) {
        captureSegment(state, captureStart, state.position, true);
        ch = state.input.charCodeAt(++state.position);

        if (ch === 0x27 /* ' */) {
            captureStart = state.position;
            state.position++;
            captureEnd = state.position;
          } else {
          return true;
        }
      } else if (is_EOL(ch)) {
      captureSegment(state, captureStart, captureEnd, true);
      writeFoldedLines(state, skipSeparationSpace(state, false, nodeIndent));
      captureStart = captureEnd = state.position;
    } else if (state.position === state.lineStart && testDocumentSeparator(state)) {
      throwError(state, 'unexpected end of the document within a single quoted scalar');
    } else {
      state.position++;
      captureEnd = state.position;
    }
  }

  throwError(state, 'unexpected end of the stream within a single quoted scalar');
}

function readDoubleQuotedScalar(state, nodeIndent) {
  var captureStart, captureEnd, hexLength, hexResult, tmp, ch;

  ch = state.input.charCodeAt(state.position);

  if (ch !== 0x22 /* " */) {
      return false;
    }

  state.kind = 'scalar';
  state.result = '';
  state.position++;
  captureStart = captureEnd = state.position;

  while ((ch = state.input.charCodeAt(state.position)) !== 0) {
    if (ch === 0x22 /* " */) {
        captureSegment(state, captureStart, state.position, true);
        state.position++;
        return true;
      } else if (ch === 0x5C /* \ */) {
        captureSegment(state, captureStart, state.position, true);
        ch = state.input.charCodeAt(++state.position);

        if (is_EOL(ch)) {
          skipSeparationSpace(state, false, nodeIndent);

          // TODO: rework to inline fn with no type cast?
        } else if (ch < 256 && simpleEscapeCheck[ch]) {
          state.result += simpleEscapeMap[ch];
          state.position++;
        } else if ((tmp = escapedHexLen(ch)) > 0) {
          hexLength = tmp;
          hexResult = 0;

          for (; hexLength > 0; hexLength--) {
            ch = state.input.charCodeAt(++state.position);

            if ((tmp = fromHexCode(ch)) >= 0) {
              hexResult = (hexResult << 4) + tmp;
            } else {
              throwError(state, 'expected hexadecimal character');
            }
          }

          state.result += charFromCodepoint(hexResult);

          state.position++;
        } else {
          throwError(state, 'unknown escape sequence');
        }

        captureStart = captureEnd = state.position;
      } else if (is_EOL(ch)) {
      captureSegment(state, captureStart, captureEnd, true);
      writeFoldedLines(state, skipSeparationSpace(state, false, nodeIndent));
      captureStart = captureEnd = state.position;
    } else if (state.position === state.lineStart && testDocumentSeparator(state)) {
      throwError(state, 'unexpected end of the document within a double quoted scalar');
    } else {
      state.position++;
      captureEnd = state.position;
    }
  }

  throwError(state, 'unexpected end of the stream within a double quoted scalar');
}

function readFlowCollection(state, nodeIndent) {
  var readNext = true,
      _line,
      _tag = state.tag,
      _result,
      _anchor = state.anchor,
      following,
      terminator,
      isPair,
      isExplicitPair,
      isMapping,
      overridableKeys = {},
      keyNode,
      keyTag,
      valueNode,
      ch;

  ch = state.input.charCodeAt(state.position);

  if (ch === 0x5B /* [ */) {
      terminator = 0x5D; /* ] */
      isMapping = false;
      _result = [];
    } else if (ch === 0x7B /* { */) {
      terminator = 0x7D; /* } */
      isMapping = true;
      _result = {};
    } else {
    return false;
  }

  if (state.anchor !== null) {
    state.anchorMap[state.anchor] = _result;
  }

  ch = state.input.charCodeAt(++state.position);

  while (ch !== 0) {
    skipSeparationSpace(state, true, nodeIndent);

    ch = state.input.charCodeAt(state.position);

    if (ch === terminator) {
      state.position++;
      state.tag = _tag;
      state.anchor = _anchor;
      state.kind = isMapping ? 'mapping' : 'sequence';
      state.result = _result;
      return true;
    } else if (!readNext) {
      throwError(state, 'missed comma between flow collection entries');
    }

    keyTag = keyNode = valueNode = null;
    isPair = isExplicitPair = false;

    if (ch === 0x3F /* ? */) {
        following = state.input.charCodeAt(state.position + 1);

        if (is_WS_OR_EOL(following)) {
          isPair = isExplicitPair = true;
          state.position++;
          skipSeparationSpace(state, true, nodeIndent);
        }
      }

    _line = state.line;
    composeNode(state, nodeIndent, CONTEXT_FLOW_IN, false, true);
    keyTag = state.tag;
    keyNode = state.result;
    skipSeparationSpace(state, true, nodeIndent);

    ch = state.input.charCodeAt(state.position);

    if ((isExplicitPair || state.line === _line) && ch === 0x3A /* : */) {
        isPair = true;
        ch = state.input.charCodeAt(++state.position);
        skipSeparationSpace(state, true, nodeIndent);
        composeNode(state, nodeIndent, CONTEXT_FLOW_IN, false, true);
        valueNode = state.result;
      }

    if (isMapping) {
      storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, valueNode);
    } else if (isPair) {
      _result.push(storeMappingPair(state, null, overridableKeys, keyTag, keyNode, valueNode));
    } else {
      _result.push(keyNode);
    }

    skipSeparationSpace(state, true, nodeIndent);

    ch = state.input.charCodeAt(state.position);

    if (ch === 0x2C /* , */) {
        readNext = true;
        ch = state.input.charCodeAt(++state.position);
      } else {
      readNext = false;
    }
  }

  throwError(state, 'unexpected end of the stream within a flow collection');
}

function readBlockScalar(state, nodeIndent) {
  var captureStart,
      folding,
      chomping = CHOMPING_CLIP,
      didReadContent = false,
      detectedIndent = false,
      textIndent = nodeIndent,
      emptyLines = 0,
      atMoreIndented = false,
      tmp,
      ch;

  ch = state.input.charCodeAt(state.position);

  if (ch === 0x7C /* | */) {
      folding = false;
    } else if (ch === 0x3E /* > */) {
      folding = true;
    } else {
    return false;
  }

  state.kind = 'scalar';
  state.result = '';

  while (ch !== 0) {
    ch = state.input.charCodeAt(++state.position);

    if (ch === 0x2B /* + */ || ch === 0x2D /* - */) {
        if (CHOMPING_CLIP === chomping) {
          chomping = ch === 0x2B /* + */ ? CHOMPING_KEEP : CHOMPING_STRIP;
        } else {
          throwError(state, 'repeat of a chomping mode identifier');
        }
      } else if ((tmp = fromDecimalCode(ch)) >= 0) {
      if (tmp === 0) {
        throwError(state, 'bad explicit indentation width of a block scalar; it cannot be less than one');
      } else if (!detectedIndent) {
        textIndent = nodeIndent + tmp - 1;
        detectedIndent = true;
      } else {
        throwError(state, 'repeat of an indentation width identifier');
      }
    } else {
      break;
    }
  }

  if (is_WHITE_SPACE(ch)) {
    do {
      ch = state.input.charCodeAt(++state.position);
    } while (is_WHITE_SPACE(ch));

    if (ch === 0x23 /* # */) {
        do {
          ch = state.input.charCodeAt(++state.position);
        } while (!is_EOL(ch) && ch !== 0);
      }
  }

  while (ch !== 0) {
    readLineBreak(state);
    state.lineIndent = 0;

    ch = state.input.charCodeAt(state.position);

    while ((!detectedIndent || state.lineIndent < textIndent) && ch === 0x20 /* Space */) {
      state.lineIndent++;
      ch = state.input.charCodeAt(++state.position);
    }

    if (!detectedIndent && state.lineIndent > textIndent) {
      textIndent = state.lineIndent;
    }

    if (is_EOL(ch)) {
      emptyLines++;
      continue;
    }

    // End of the scalar.
    if (state.lineIndent < textIndent) {

      // Perform the chomping.
      if (chomping === CHOMPING_KEEP) {
        state.result += common.repeat('\n', didReadContent ? 1 + emptyLines : emptyLines);
      } else if (chomping === CHOMPING_CLIP) {
        if (didReadContent) {
          // i.e. only if the scalar is not empty.
          state.result += '\n';
        }
      }

      // Break this `while` cycle and go to the funciton's epilogue.
      break;
    }

    // Folded style: use fancy rules to handle line breaks.
    if (folding) {

      // Lines starting with white space characters (more-indented lines) are not folded.
      if (is_WHITE_SPACE(ch)) {
        atMoreIndented = true;
        // except for the first content line (cf. Example 8.1)
        state.result += common.repeat('\n', didReadContent ? 1 + emptyLines : emptyLines);

        // End of more-indented block.
      } else if (atMoreIndented) {
        atMoreIndented = false;
        state.result += common.repeat('\n', emptyLines + 1);

        // Just one line break - perceive as the same line.
      } else if (emptyLines === 0) {
        if (didReadContent) {
          // i.e. only if we have already read some scalar content.
          state.result += ' ';
        }

        // Several line breaks - perceive as different lines.
      } else {
        state.result += common.repeat('\n', emptyLines);
      }

      // Literal style: just add exact number of line breaks between content lines.
    } else {
      // Keep all line breaks except the header line break.
      state.result += common.repeat('\n', didReadContent ? 1 + emptyLines : emptyLines);
    }

    didReadContent = true;
    detectedIndent = true;
    emptyLines = 0;
    captureStart = state.position;

    while (!is_EOL(ch) && ch !== 0) {
      ch = state.input.charCodeAt(++state.position);
    }

    captureSegment(state, captureStart, state.position, false);
  }

  return true;
}

function readBlockSequence(state, nodeIndent) {
  var _line,
      _tag = state.tag,
      _anchor = state.anchor,
      _result = [],
      following,
      detected = false,
      ch;

  if (state.anchor !== null) {
    state.anchorMap[state.anchor] = _result;
  }

  ch = state.input.charCodeAt(state.position);

  while (ch !== 0) {

    if (ch !== 0x2D /* - */) {
        break;
      }

    following = state.input.charCodeAt(state.position + 1);

    if (!is_WS_OR_EOL(following)) {
      break;
    }

    detected = true;
    state.position++;

    if (skipSeparationSpace(state, true, -1)) {
      if (state.lineIndent <= nodeIndent) {
        _result.push(null);
        ch = state.input.charCodeAt(state.position);
        continue;
      }
    }

    _line = state.line;
    composeNode(state, nodeIndent, CONTEXT_BLOCK_IN, false, true);
    _result.push(state.result);
    skipSeparationSpace(state, true, -1);

    ch = state.input.charCodeAt(state.position);

    if ((state.line === _line || state.lineIndent > nodeIndent) && ch !== 0) {
      throwError(state, 'bad indentation of a sequence entry');
    } else if (state.lineIndent < nodeIndent) {
      break;
    }
  }

  if (detected) {
    state.tag = _tag;
    state.anchor = _anchor;
    state.kind = 'sequence';
    state.result = _result;
    return true;
  }
  return false;
}

function readBlockMapping(state, nodeIndent, flowIndent) {
  var following,
      allowCompact,
      _line,
      _pos,
      _tag = state.tag,
      _anchor = state.anchor,
      _result = {},
      overridableKeys = {},
      keyTag = null,
      keyNode = null,
      valueNode = null,
      atExplicitKey = false,
      detected = false,
      ch;

  if (state.anchor !== null) {
    state.anchorMap[state.anchor] = _result;
  }

  ch = state.input.charCodeAt(state.position);

  while (ch !== 0) {
    following = state.input.charCodeAt(state.position + 1);
    _line = state.line; // Save the current line.
    _pos = state.position;

    //
    // Explicit notation case. There are two separate blocks:
    // first for the key (denoted by "?") and second for the value (denoted by ":")
    //
    if ((ch === 0x3F /* ? */ || ch === 0x3A /* : */) && is_WS_OR_EOL(following)) {

      if (ch === 0x3F /* ? */) {
          if (atExplicitKey) {
            storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, null);
            keyTag = keyNode = valueNode = null;
          }

          detected = true;
          atExplicitKey = true;
          allowCompact = true;
        } else if (atExplicitKey) {
        // i.e. 0x3A/* : */ === character after the explicit key.
        atExplicitKey = false;
        allowCompact = true;
      } else {
        throwError(state, 'incomplete explicit mapping pair; a key node is missed; or followed by a non-tabulated empty line');
      }

      state.position += 1;
      ch = following;

      //
      // Implicit notation case. Flow-style node as the key first, then ":", and the value.
      //
    } else if (composeNode(state, flowIndent, CONTEXT_FLOW_OUT, false, true)) {

      if (state.line === _line) {
        ch = state.input.charCodeAt(state.position);

        while (is_WHITE_SPACE(ch)) {
          ch = state.input.charCodeAt(++state.position);
        }

        if (ch === 0x3A /* : */) {
            ch = state.input.charCodeAt(++state.position);

            if (!is_WS_OR_EOL(ch)) {
              throwError(state, 'a whitespace character is expected after the key-value separator within a block mapping');
            }

            if (atExplicitKey) {
              storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, null);
              keyTag = keyNode = valueNode = null;
            }

            detected = true;
            atExplicitKey = false;
            allowCompact = false;
            keyTag = state.tag;
            keyNode = state.result;
          } else if (detected) {
          throwError(state, 'can not read an implicit mapping pair; a colon is missed');
        } else {
          state.tag = _tag;
          state.anchor = _anchor;
          return true; // Keep the result of `composeNode`.
        }
      } else if (detected) {
        throwError(state, 'can not read a block mapping entry; a multiline key may not be an implicit key');
      } else {
        state.tag = _tag;
        state.anchor = _anchor;
        return true; // Keep the result of `composeNode`.
      }
    } else {
        break; // Reading is done. Go to the epilogue.
      }

    //
    // Common reading code for both explicit and implicit notations.
    //
    if (state.line === _line || state.lineIndent > nodeIndent) {
      if (composeNode(state, nodeIndent, CONTEXT_BLOCK_OUT, true, allowCompact)) {
        if (atExplicitKey) {
          keyNode = state.result;
        } else {
          valueNode = state.result;
        }
      }

      if (!atExplicitKey) {
        storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, valueNode, _line, _pos);
        keyTag = keyNode = valueNode = null;
      }

      skipSeparationSpace(state, true, -1);
      ch = state.input.charCodeAt(state.position);
    }

    if (state.lineIndent > nodeIndent && ch !== 0) {
      throwError(state, 'bad indentation of a mapping entry');
    } else if (state.lineIndent < nodeIndent) {
      break;
    }
  }

  //
  // Epilogue.
  //

  // Special case: last mapping's node contains only the key in explicit notation.
  if (atExplicitKey) {
    storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, null);
  }

  // Expose the resulting mapping.
  if (detected) {
    state.tag = _tag;
    state.anchor = _anchor;
    state.kind = 'mapping';
    state.result = _result;
  }

  return detected;
}

function readTagProperty(state) {
  var _position,
      isVerbatim = false,
      isNamed = false,
      tagHandle,
      tagName,
      ch;

  ch = state.input.charCodeAt(state.position);

  if (ch !== 0x21 /* ! */) return false;

  if (state.tag !== null) {
    throwError(state, 'duplication of a tag property');
  }

  ch = state.input.charCodeAt(++state.position);

  if (ch === 0x3C /* < */) {
      isVerbatim = true;
      ch = state.input.charCodeAt(++state.position);
    } else if (ch === 0x21 /* ! */) {
      isNamed = true;
      tagHandle = '!!';
      ch = state.input.charCodeAt(++state.position);
    } else {
    tagHandle = '!';
  }

  _position = state.position;

  if (isVerbatim) {
    do {
      ch = state.input.charCodeAt(++state.position);
    } while (ch !== 0 && ch !== 0x3E /* > */);

    if (state.position < state.length) {
      tagName = state.input.slice(_position, state.position);
      ch = state.input.charCodeAt(++state.position);
    } else {
      throwError(state, 'unexpected end of the stream within a verbatim tag');
    }
  } else {
    while (ch !== 0 && !is_WS_OR_EOL(ch)) {

      if (ch === 0x21 /* ! */) {
          if (!isNamed) {
            tagHandle = state.input.slice(_position - 1, state.position + 1);

            if (!PATTERN_TAG_HANDLE.test(tagHandle)) {
              throwError(state, 'named tag handle cannot contain such characters');
            }

            isNamed = true;
            _position = state.position + 1;
          } else {
            throwError(state, 'tag suffix cannot contain exclamation marks');
          }
        }

      ch = state.input.charCodeAt(++state.position);
    }

    tagName = state.input.slice(_position, state.position);

    if (PATTERN_FLOW_INDICATORS.test(tagName)) {
      throwError(state, 'tag suffix cannot contain flow indicator characters');
    }
  }

  if (tagName && !PATTERN_TAG_URI.test(tagName)) {
    throwError(state, 'tag name cannot contain such characters: ' + tagName);
  }

  if (isVerbatim) {
    state.tag = tagName;
  } else if (_hasOwnProperty.call(state.tagMap, tagHandle)) {
    state.tag = state.tagMap[tagHandle] + tagName;
  } else if (tagHandle === '!') {
    state.tag = '!' + tagName;
  } else if (tagHandle === '!!') {
    state.tag = 'tag:yaml.org,2002:' + tagName;
  } else {
    throwError(state, 'undeclared tag handle "' + tagHandle + '"');
  }

  return true;
}

function readAnchorProperty(state) {
  var _position, ch;

  ch = state.input.charCodeAt(state.position);

  if (ch !== 0x26 /* & */) return false;

  if (state.anchor !== null) {
    throwError(state, 'duplication of an anchor property');
  }

  ch = state.input.charCodeAt(++state.position);
  _position = state.position;

  while (ch !== 0 && !is_WS_OR_EOL(ch) && !is_FLOW_INDICATOR(ch)) {
    ch = state.input.charCodeAt(++state.position);
  }

  if (state.position === _position) {
    throwError(state, 'name of an anchor node must contain at least one character');
  }

  state.anchor = state.input.slice(_position, state.position);
  return true;
}

function readAlias(state) {
  var _position, alias, ch;

  ch = state.input.charCodeAt(state.position);

  if (ch !== 0x2A /* * */) return false;

  ch = state.input.charCodeAt(++state.position);
  _position = state.position;

  while (ch !== 0 && !is_WS_OR_EOL(ch) && !is_FLOW_INDICATOR(ch)) {
    ch = state.input.charCodeAt(++state.position);
  }

  if (state.position === _position) {
    throwError(state, 'name of an alias node must contain at least one character');
  }

  alias = state.input.slice(_position, state.position);

  if (!state.anchorMap.hasOwnProperty(alias)) {
    throwError(state, 'unidentified alias "' + alias + '"');
  }

  state.result = state.anchorMap[alias];
  skipSeparationSpace(state, true, -1);
  return true;
}

function composeNode(state, parentIndent, nodeContext, allowToSeek, allowCompact) {
  var allowBlockStyles,
      allowBlockScalars,
      allowBlockCollections,
      indentStatus = 1,
      // 1: this>parent, 0: this=parent, -1: this<parent
  atNewLine = false,
      hasContent = false,
      typeIndex,
      typeQuantity,
      type,
      flowIndent,
      blockIndent;

  if (state.listener !== null) {
    state.listener('open', state);
  }

  state.tag = null;
  state.anchor = null;
  state.kind = null;
  state.result = null;

  allowBlockStyles = allowBlockScalars = allowBlockCollections = CONTEXT_BLOCK_OUT === nodeContext || CONTEXT_BLOCK_IN === nodeContext;

  if (allowToSeek) {
    if (skipSeparationSpace(state, true, -1)) {
      atNewLine = true;

      if (state.lineIndent > parentIndent) {
        indentStatus = 1;
      } else if (state.lineIndent === parentIndent) {
        indentStatus = 0;
      } else if (state.lineIndent < parentIndent) {
        indentStatus = -1;
      }
    }
  }

  if (indentStatus === 1) {
    while (readTagProperty(state) || readAnchorProperty(state)) {
      if (skipSeparationSpace(state, true, -1)) {
        atNewLine = true;
        allowBlockCollections = allowBlockStyles;

        if (state.lineIndent > parentIndent) {
          indentStatus = 1;
        } else if (state.lineIndent === parentIndent) {
          indentStatus = 0;
        } else if (state.lineIndent < parentIndent) {
          indentStatus = -1;
        }
      } else {
        allowBlockCollections = false;
      }
    }
  }

  if (allowBlockCollections) {
    allowBlockCollections = atNewLine || allowCompact;
  }

  if (indentStatus === 1 || CONTEXT_BLOCK_OUT === nodeContext) {
    if (CONTEXT_FLOW_IN === nodeContext || CONTEXT_FLOW_OUT === nodeContext) {
      flowIndent = parentIndent;
    } else {
      flowIndent = parentIndent + 1;
    }

    blockIndent = state.position - state.lineStart;

    if (indentStatus === 1) {
      if (allowBlockCollections && (readBlockSequence(state, blockIndent) || readBlockMapping(state, blockIndent, flowIndent)) || readFlowCollection(state, flowIndent)) {
        hasContent = true;
      } else {
        if (allowBlockScalars && readBlockScalar(state, flowIndent) || readSingleQuotedScalar(state, flowIndent) || readDoubleQuotedScalar(state, flowIndent)) {
          hasContent = true;
        } else if (readAlias(state)) {
          hasContent = true;

          if (state.tag !== null || state.anchor !== null) {
            throwError(state, 'alias node should not have any properties');
          }
        } else if (readPlainScalar(state, flowIndent, CONTEXT_FLOW_IN === nodeContext)) {
          hasContent = true;

          if (state.tag === null) {
            state.tag = '?';
          }
        }

        if (state.anchor !== null) {
          state.anchorMap[state.anchor] = state.result;
        }
      }
    } else if (indentStatus === 0) {
      // Special case: block sequences are allowed to have same indentation level as the parent.
      // http://www.yaml.org/spec/1.2/spec.html#id2799784
      hasContent = allowBlockCollections && readBlockSequence(state, blockIndent);
    }
  }

  if (state.tag !== null && state.tag !== '!') {
    if (state.tag === '?') {
      for (typeIndex = 0, typeQuantity = state.implicitTypes.length; typeIndex < typeQuantity; typeIndex += 1) {
        type = state.implicitTypes[typeIndex];

        // Implicit resolving is not allowed for non-scalar types, and '?'
        // non-specific tag is only assigned to plain scalars. So, it isn't
        // needed to check for 'kind' conformity.

        if (type.resolve(state.result)) {
          // `state.result` updated in resolver if matched
          state.result = type.construct(state.result);
          state.tag = type.tag;
          if (state.anchor !== null) {
            state.anchorMap[state.anchor] = state.result;
          }
          break;
        }
      }
    } else if (_hasOwnProperty.call(state.typeMap[state.kind || 'fallback'], state.tag)) {
      type = state.typeMap[state.kind || 'fallback'][state.tag];

      if (state.result !== null && type.kind !== state.kind) {
        throwError(state, 'unacceptable node kind for !<' + state.tag + '> tag; it should be "' + type.kind + '", not "' + state.kind + '"');
      }

      if (!type.resolve(state.result)) {
        // `state.result` updated in resolver if matched
        throwError(state, 'cannot resolve a node with !<' + state.tag + '> explicit tag');
      } else {
        state.result = type.construct(state.result);
        if (state.anchor !== null) {
          state.anchorMap[state.anchor] = state.result;
        }
      }
    } else {
      throwError(state, 'unknown tag !<' + state.tag + '>');
    }
  }

  if (state.listener !== null) {
    state.listener('close', state);
  }
  return state.tag !== null || state.anchor !== null || hasContent;
}

function readDocument(state) {
  var documentStart = state.position,
      _position,
      directiveName,
      directiveArgs,
      hasDirectives = false,
      ch;

  state.version = null;
  state.checkLineBreaks = state.legacy;
  state.tagMap = {};
  state.anchorMap = {};

  while ((ch = state.input.charCodeAt(state.position)) !== 0) {
    skipSeparationSpace(state, true, -1);

    ch = state.input.charCodeAt(state.position);

    if (state.lineIndent > 0 || ch !== 0x25 /* % */) {
        break;
      }

    hasDirectives = true;
    ch = state.input.charCodeAt(++state.position);
    _position = state.position;

    while (ch !== 0 && !is_WS_OR_EOL(ch)) {
      ch = state.input.charCodeAt(++state.position);
    }

    directiveName = state.input.slice(_position, state.position);
    directiveArgs = [];

    if (directiveName.length < 1) {
      throwError(state, 'directive name must not be less than one character in length');
    }

    while (ch !== 0) {
      while (is_WHITE_SPACE(ch)) {
        ch = state.input.charCodeAt(++state.position);
      }

      if (ch === 0x23 /* # */) {
          do {
            ch = state.input.charCodeAt(++state.position);
          } while (ch !== 0 && !is_EOL(ch));
          break;
        }

      if (is_EOL(ch)) break;

      _position = state.position;

      while (ch !== 0 && !is_WS_OR_EOL(ch)) {
        ch = state.input.charCodeAt(++state.position);
      }

      directiveArgs.push(state.input.slice(_position, state.position));
    }

    if (ch !== 0) readLineBreak(state);

    if (_hasOwnProperty.call(directiveHandlers, directiveName)) {
      directiveHandlers[directiveName](state, directiveName, directiveArgs);
    } else {
      throwWarning(state, 'unknown document directive "' + directiveName + '"');
    }
  }

  skipSeparationSpace(state, true, -1);

  if (state.lineIndent === 0 && state.input.charCodeAt(state.position) === 0x2D /* - */ && state.input.charCodeAt(state.position + 1) === 0x2D /* - */ && state.input.charCodeAt(state.position + 2) === 0x2D /* - */) {
      state.position += 3;
      skipSeparationSpace(state, true, -1);
    } else if (hasDirectives) {
    throwError(state, 'directives end mark is expected');
  }

  composeNode(state, state.lineIndent - 1, CONTEXT_BLOCK_OUT, false, true);
  skipSeparationSpace(state, true, -1);

  if (state.checkLineBreaks && PATTERN_NON_ASCII_LINE_BREAKS.test(state.input.slice(documentStart, state.position))) {
    throwWarning(state, 'non-ASCII line breaks are interpreted as content');
  }

  state.documents.push(state.result);

  if (state.position === state.lineStart && testDocumentSeparator(state)) {

    if (state.input.charCodeAt(state.position) === 0x2E /* . */) {
        state.position += 3;
        skipSeparationSpace(state, true, -1);
      }
    return;
  }

  if (state.position < state.length - 1) {
    throwError(state, 'end of the stream or a document separator is expected');
  } else {
    return;
  }
}

function loadDocuments(input, options) {
  input = String(input);
  options = options || {};

  if (input.length !== 0) {

    // Add tailing `\n` if not exists
    if (input.charCodeAt(input.length - 1) !== 0x0A /* LF */ && input.charCodeAt(input.length - 1) !== 0x0D /* CR */) {
        input += '\n';
      }

    // Strip BOM
    if (input.charCodeAt(0) === 0xFEFF) {
      input = input.slice(1);
    }
  }

  var state = new State(input, options);

  // Use 0 as string terminator. That significantly simplifies bounds check.
  state.input += '\0';

  while (state.input.charCodeAt(state.position) === 0x20 /* Space */) {
    state.lineIndent += 1;
    state.position += 1;
  }

  while (state.position < state.length - 1) {
    readDocument(state);
  }

  return state.documents;
}

function loadAll(input, iterator, options) {
  var documents = loadDocuments(input, options),
      index,
      length;

  if (typeof iterator !== 'function') {
    return documents;
  }

  for (index = 0, length = documents.length; index < length; index += 1) {
    iterator(documents[index]);
  }
}

function load(input, options) {
  var documents = loadDocuments(input, options);

  if (documents.length === 0) {
    /*eslint-disable no-undefined*/
    return undefined;
  } else if (documents.length === 1) {
    return documents[0];
  }
  throw new YAMLException('expected a single document in the stream, but found more');
}

function safeLoadAll(input, output, options) {
  if (typeof output === 'function') {
    loadAll(input, output, common.extend({ schema: DEFAULT_SAFE_SCHEMA }, options));
  } else {
    return loadAll(input, common.extend({ schema: DEFAULT_SAFE_SCHEMA }, options));
  }
}

function safeLoad(input, options) {
  return load(input, common.extend({ schema: DEFAULT_SAFE_SCHEMA }, options));
}

module.exports.loadAll = loadAll;
module.exports.load = load;
module.exports.safeLoadAll = safeLoadAll;
module.exports.safeLoad = safeLoad;

/***/ }),
/* 139 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var common = __webpack_require__(17);

function Mark(name, buffer, position, line, column) {
  this.name = name;
  this.buffer = buffer;
  this.position = position;
  this.line = line;
  this.column = column;
}

Mark.prototype.getSnippet = function getSnippet(indent, maxLength) {
  var head, start, tail, end, snippet;

  if (!this.buffer) return null;

  indent = indent || 4;
  maxLength = maxLength || 75;

  head = '';
  start = this.position;

  while (start > 0 && '\x00\r\n\x85\u2028\u2029'.indexOf(this.buffer.charAt(start - 1)) === -1) {
    start -= 1;
    if (this.position - start > maxLength / 2 - 1) {
      head = ' ... ';
      start += 5;
      break;
    }
  }

  tail = '';
  end = this.position;

  while (end < this.buffer.length && '\x00\r\n\x85\u2028\u2029'.indexOf(this.buffer.charAt(end)) === -1) {
    end += 1;
    if (end - this.position > maxLength / 2 - 1) {
      tail = ' ... ';
      end -= 5;
      break;
    }
  }

  snippet = this.buffer.slice(start, end);

  return common.repeat(' ', indent) + head + snippet + tail + '\n' + common.repeat(' ', indent + this.position - start + head.length) + '^';
};

Mark.prototype.toString = function toString(compact) {
  var snippet,
      where = '';

  if (this.name) {
    where += 'in "' + this.name + '" ';
  }

  where += 'at line ' + (this.line + 1) + ', column ' + (this.column + 1);

  if (!compact) {
    snippet = this.getSnippet();

    if (snippet) {
      where += ':\n' + snippet;
    }
  }

  return where;
};

module.exports = Mark;

/***/ }),
/* 140 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var Type = __webpack_require__(4);

module.exports = new Type('tag:yaml.org,2002:str', {
  kind: 'scalar',
  construct: function (data) {
    return data !== null ? data : '';
  }
});

/***/ }),
/* 141 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var Type = __webpack_require__(4);

module.exports = new Type('tag:yaml.org,2002:seq', {
  kind: 'sequence',
  construct: function (data) {
    return data !== null ? data : [];
  }
});

/***/ }),
/* 142 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var Type = __webpack_require__(4);

module.exports = new Type('tag:yaml.org,2002:map', {
  kind: 'mapping',
  construct: function (data) {
    return data !== null ? data : {};
  }
});

/***/ }),
/* 143 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var Type = __webpack_require__(4);

function resolveYamlNull(data) {
  if (data === null) return true;

  var max = data.length;

  return max === 1 && data === '~' || max === 4 && (data === 'null' || data === 'Null' || data === 'NULL');
}

function constructYamlNull() {
  return null;
}

function isNull(object) {
  return object === null;
}

module.exports = new Type('tag:yaml.org,2002:null', {
  kind: 'scalar',
  resolve: resolveYamlNull,
  construct: constructYamlNull,
  predicate: isNull,
  represent: {
    canonical: function () {
      return '~';
    },
    lowercase: function () {
      return 'null';
    },
    uppercase: function () {
      return 'NULL';
    },
    camelcase: function () {
      return 'Null';
    }
  },
  defaultStyle: 'lowercase'
});

/***/ }),
/* 144 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var Type = __webpack_require__(4);

function resolveYamlBoolean(data) {
  if (data === null) return false;

  var max = data.length;

  return max === 4 && (data === 'true' || data === 'True' || data === 'TRUE') || max === 5 && (data === 'false' || data === 'False' || data === 'FALSE');
}

function constructYamlBoolean(data) {
  return data === 'true' || data === 'True' || data === 'TRUE';
}

function isBoolean(object) {
  return Object.prototype.toString.call(object) === '[object Boolean]';
}

module.exports = new Type('tag:yaml.org,2002:bool', {
  kind: 'scalar',
  resolve: resolveYamlBoolean,
  construct: constructYamlBoolean,
  predicate: isBoolean,
  represent: {
    lowercase: function (object) {
      return object ? 'true' : 'false';
    },
    uppercase: function (object) {
      return object ? 'TRUE' : 'FALSE';
    },
    camelcase: function (object) {
      return object ? 'True' : 'False';
    }
  },
  defaultStyle: 'lowercase'
});

/***/ }),
/* 145 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var common = __webpack_require__(17);
var Type = __webpack_require__(4);

function isHexCode(c) {
  return 0x30 /* 0 */ <= c && c <= 0x39 /* 9 */ || 0x41 /* A */ <= c && c <= 0x46 /* F */ || 0x61 /* a */ <= c && c <= 0x66 /* f */;
}

function isOctCode(c) {
  return 0x30 /* 0 */ <= c && c <= 0x37 /* 7 */;
}

function isDecCode(c) {
  return 0x30 /* 0 */ <= c && c <= 0x39 /* 9 */;
}

function resolveYamlInteger(data) {
  if (data === null) return false;

  var max = data.length,
      index = 0,
      hasDigits = false,
      ch;

  if (!max) return false;

  ch = data[index];

  // sign
  if (ch === '-' || ch === '+') {
    ch = data[++index];
  }

  if (ch === '0') {
    // 0
    if (index + 1 === max) return true;
    ch = data[++index];

    // base 2, base 8, base 16

    if (ch === 'b') {
      // base 2
      index++;

      for (; index < max; index++) {
        ch = data[index];
        if (ch === '_') continue;
        if (ch !== '0' && ch !== '1') return false;
        hasDigits = true;
      }
      return hasDigits && ch !== '_';
    }

    if (ch === 'x') {
      // base 16
      index++;

      for (; index < max; index++) {
        ch = data[index];
        if (ch === '_') continue;
        if (!isHexCode(data.charCodeAt(index))) return false;
        hasDigits = true;
      }
      return hasDigits && ch !== '_';
    }

    // base 8
    for (; index < max; index++) {
      ch = data[index];
      if (ch === '_') continue;
      if (!isOctCode(data.charCodeAt(index))) return false;
      hasDigits = true;
    }
    return hasDigits && ch !== '_';
  }

  // base 10 (except 0) or base 60

  // value should not start with `_`;
  if (ch === '_') return false;

  for (; index < max; index++) {
    ch = data[index];
    if (ch === '_') continue;
    if (ch === ':') break;
    if (!isDecCode(data.charCodeAt(index))) {
      return false;
    }
    hasDigits = true;
  }

  // Should have digits and should not end with `_`
  if (!hasDigits || ch === '_') return false;

  // if !base60 - done;
  if (ch !== ':') return true;

  // base60 almost not used, no needs to optimize
  return (/^(:[0-5]?[0-9])+$/.test(data.slice(index))
  );
}

function constructYamlInteger(data) {
  var value = data,
      sign = 1,
      ch,
      base,
      digits = [];

  if (value.indexOf('_') !== -1) {
    value = value.replace(/_/g, '');
  }

  ch = value[0];

  if (ch === '-' || ch === '+') {
    if (ch === '-') sign = -1;
    value = value.slice(1);
    ch = value[0];
  }

  if (value === '0') return 0;

  if (ch === '0') {
    if (value[1] === 'b') return sign * parseInt(value.slice(2), 2);
    if (value[1] === 'x') return sign * parseInt(value, 16);
    return sign * parseInt(value, 8);
  }

  if (value.indexOf(':') !== -1) {
    value.split(':').forEach(function (v) {
      digits.unshift(parseInt(v, 10));
    });

    value = 0;
    base = 1;

    digits.forEach(function (d) {
      value += d * base;
      base *= 60;
    });

    return sign * value;
  }

  return sign * parseInt(value, 10);
}

function isInteger(object) {
  return Object.prototype.toString.call(object) === '[object Number]' && object % 1 === 0 && !common.isNegativeZero(object);
}

module.exports = new Type('tag:yaml.org,2002:int', {
  kind: 'scalar',
  resolve: resolveYamlInteger,
  construct: constructYamlInteger,
  predicate: isInteger,
  represent: {
    binary: function (object) {
      return '0b' + object.toString(2);
    },
    octal: function (object) {
      return '0' + object.toString(8);
    },
    decimal: function (object) {
      return object.toString(10);
    },
    hexadecimal: function (object) {
      return '0x' + object.toString(16).toUpperCase();
    }
  },
  defaultStyle: 'decimal',
  styleAliases: {
    binary: [2, 'bin'],
    octal: [8, 'oct'],
    decimal: [10, 'dec'],
    hexadecimal: [16, 'hex']
  }
});

/***/ }),
/* 146 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var common = __webpack_require__(17);
var Type = __webpack_require__(4);

var YAML_FLOAT_PATTERN = new RegExp(
// 2.5e4, 2.5 and integers
'^(?:[-+]?(?:0|[1-9][0-9_]*)(?:\\.[0-9_]*)?(?:[eE][-+]?[0-9]+)?' +
// .2e4, .2
// special case, seems not from spec
'|\\.[0-9_]+(?:[eE][-+]?[0-9]+)?' +
// 20:59
'|[-+]?[0-9][0-9_]*(?::[0-5]?[0-9])+\\.[0-9_]*' +
// .inf
'|[-+]?\\.(?:inf|Inf|INF)' +
// .nan
'|\\.(?:nan|NaN|NAN))$');

function resolveYamlFloat(data) {
  if (data === null) return false;

  if (!YAML_FLOAT_PATTERN.test(data) ||
  // Quick hack to not allow integers end with `_`
  // Probably should update regexp & check speed
  data[data.length - 1] === '_') {
    return false;
  }

  return true;
}

function constructYamlFloat(data) {
  var value, sign, base, digits;

  value = data.replace(/_/g, '').toLowerCase();
  sign = value[0] === '-' ? -1 : 1;
  digits = [];

  if ('+-'.indexOf(value[0]) >= 0) {
    value = value.slice(1);
  }

  if (value === '.inf') {
    return sign === 1 ? Number.POSITIVE_INFINITY : Number.NEGATIVE_INFINITY;
  } else if (value === '.nan') {
    return NaN;
  } else if (value.indexOf(':') >= 0) {
    value.split(':').forEach(function (v) {
      digits.unshift(parseFloat(v, 10));
    });

    value = 0.0;
    base = 1;

    digits.forEach(function (d) {
      value += d * base;
      base *= 60;
    });

    return sign * value;
  }
  return sign * parseFloat(value, 10);
}

var SCIENTIFIC_WITHOUT_DOT = /^[-+]?[0-9]+e/;

function representYamlFloat(object, style) {
  var res;

  if (isNaN(object)) {
    switch (style) {
      case 'lowercase':
        return '.nan';
      case 'uppercase':
        return '.NAN';
      case 'camelcase':
        return '.NaN';
    }
  } else if (Number.POSITIVE_INFINITY === object) {
    switch (style) {
      case 'lowercase':
        return '.inf';
      case 'uppercase':
        return '.INF';
      case 'camelcase':
        return '.Inf';
    }
  } else if (Number.NEGATIVE_INFINITY === object) {
    switch (style) {
      case 'lowercase':
        return '-.inf';
      case 'uppercase':
        return '-.INF';
      case 'camelcase':
        return '-.Inf';
    }
  } else if (common.isNegativeZero(object)) {
    return '-0.0';
  }

  res = object.toString(10);

  // JS stringifier can build scientific format without dots: 5e-100,
  // while YAML requres dot: 5.e-100. Fix it with simple hack

  return SCIENTIFIC_WITHOUT_DOT.test(res) ? res.replace('e', '.e') : res;
}

function isFloat(object) {
  return Object.prototype.toString.call(object) === '[object Number]' && (object % 1 !== 0 || common.isNegativeZero(object));
}

module.exports = new Type('tag:yaml.org,2002:float', {
  kind: 'scalar',
  resolve: resolveYamlFloat,
  construct: constructYamlFloat,
  predicate: isFloat,
  represent: representYamlFloat,
  defaultStyle: 'lowercase'
});

/***/ }),
/* 147 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var Type = __webpack_require__(4);

var YAML_DATE_REGEXP = new RegExp('^([0-9][0-9][0-9][0-9])' + // [1] year
'-([0-9][0-9])' + // [2] month
'-([0-9][0-9])$'); // [3] day

var YAML_TIMESTAMP_REGEXP = new RegExp('^([0-9][0-9][0-9][0-9])' + // [1] year
'-([0-9][0-9]?)' + // [2] month
'-([0-9][0-9]?)' + // [3] day
'(?:[Tt]|[ \\t]+)' + // ...
'([0-9][0-9]?)' + // [4] hour
':([0-9][0-9])' + // [5] minute
':([0-9][0-9])' + // [6] second
'(?:\\.([0-9]*))?' + // [7] fraction
'(?:[ \\t]*(Z|([-+])([0-9][0-9]?)' + // [8] tz [9] tz_sign [10] tz_hour
'(?::([0-9][0-9]))?))?$'); // [11] tz_minute

function resolveYamlTimestamp(data) {
  if (data === null) return false;
  if (YAML_DATE_REGEXP.exec(data) !== null) return true;
  if (YAML_TIMESTAMP_REGEXP.exec(data) !== null) return true;
  return false;
}

function constructYamlTimestamp(data) {
  var match,
      year,
      month,
      day,
      hour,
      minute,
      second,
      fraction = 0,
      delta = null,
      tz_hour,
      tz_minute,
      date;

  match = YAML_DATE_REGEXP.exec(data);
  if (match === null) match = YAML_TIMESTAMP_REGEXP.exec(data);

  if (match === null) throw new Error('Date resolve error');

  // match: [1] year [2] month [3] day

  year = +match[1];
  month = +match[2] - 1; // JS month starts with 0
  day = +match[3];

  if (!match[4]) {
    // no hour
    return new Date(Date.UTC(year, month, day));
  }

  // match: [4] hour [5] minute [6] second [7] fraction

  hour = +match[4];
  minute = +match[5];
  second = +match[6];

  if (match[7]) {
    fraction = match[7].slice(0, 3);
    while (fraction.length < 3) {
      // milli-seconds
      fraction += '0';
    }
    fraction = +fraction;
  }

  // match: [8] tz [9] tz_sign [10] tz_hour [11] tz_minute

  if (match[9]) {
    tz_hour = +match[10];
    tz_minute = +(match[11] || 0);
    delta = (tz_hour * 60 + tz_minute) * 60000; // delta in mili-seconds
    if (match[9] === '-') delta = -delta;
  }

  date = new Date(Date.UTC(year, month, day, hour, minute, second, fraction));

  if (delta) date.setTime(date.getTime() - delta);

  return date;
}

function representYamlTimestamp(object /*, style*/) {
  return object.toISOString();
}

module.exports = new Type('tag:yaml.org,2002:timestamp', {
  kind: 'scalar',
  resolve: resolveYamlTimestamp,
  construct: constructYamlTimestamp,
  instanceOf: Date,
  represent: representYamlTimestamp
});

/***/ }),
/* 148 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var Type = __webpack_require__(4);

function resolveYamlMerge(data) {
  return data === '<<' || data === null;
}

module.exports = new Type('tag:yaml.org,2002:merge', {
  kind: 'scalar',
  resolve: resolveYamlMerge
});

/***/ }),
/* 149 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var require;

/*eslint-disable no-bitwise*/

var NodeBuffer;

try {
  // A trick for browserified version, to not include `Buffer` shim
  var _require = require;
  NodeBuffer = __webpack_require__(150).Buffer;
} catch (__) {}

var Type = __webpack_require__(4);

// [ 64, 65, 66 ] -> [ padding, CR, LF ]
var BASE64_MAP = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\n\r';

function resolveYamlBinary(data) {
  if (data === null) return false;

  var code,
      idx,
      bitlen = 0,
      max = data.length,
      map = BASE64_MAP;

  // Convert one by one.
  for (idx = 0; idx < max; idx++) {
    code = map.indexOf(data.charAt(idx));

    // Skip CR/LF
    if (code > 64) continue;

    // Fail on illegal characters
    if (code < 0) return false;

    bitlen += 6;
  }

  // If there are any bits left, source was corrupted
  return bitlen % 8 === 0;
}

function constructYamlBinary(data) {
  var idx,
      tailbits,
      input = data.replace(/[\r\n=]/g, ''),
      // remove CR/LF & padding to simplify scan
  max = input.length,
      map = BASE64_MAP,
      bits = 0,
      result = [];

  // Collect by 6*4 bits (3 bytes)

  for (idx = 0; idx < max; idx++) {
    if (idx % 4 === 0 && idx) {
      result.push(bits >> 16 & 0xFF);
      result.push(bits >> 8 & 0xFF);
      result.push(bits & 0xFF);
    }

    bits = bits << 6 | map.indexOf(input.charAt(idx));
  }

  // Dump tail

  tailbits = max % 4 * 6;

  if (tailbits === 0) {
    result.push(bits >> 16 & 0xFF);
    result.push(bits >> 8 & 0xFF);
    result.push(bits & 0xFF);
  } else if (tailbits === 18) {
    result.push(bits >> 10 & 0xFF);
    result.push(bits >> 2 & 0xFF);
  } else if (tailbits === 12) {
    result.push(bits >> 4 & 0xFF);
  }

  // Wrap into Buffer for NodeJS and leave Array for browser
  if (NodeBuffer) {
    // Support node 6.+ Buffer API when available
    return NodeBuffer.from ? NodeBuffer.from(result) : new NodeBuffer(result);
  }

  return result;
}

function representYamlBinary(object /*, style*/) {
  var result = '',
      bits = 0,
      idx,
      tail,
      max = object.length,
      map = BASE64_MAP;

  // Convert every three bytes to 4 ASCII characters.

  for (idx = 0; idx < max; idx++) {
    if (idx % 3 === 0 && idx) {
      result += map[bits >> 18 & 0x3F];
      result += map[bits >> 12 & 0x3F];
      result += map[bits >> 6 & 0x3F];
      result += map[bits & 0x3F];
    }

    bits = (bits << 8) + object[idx];
  }

  // Dump tail

  tail = max % 3;

  if (tail === 0) {
    result += map[bits >> 18 & 0x3F];
    result += map[bits >> 12 & 0x3F];
    result += map[bits >> 6 & 0x3F];
    result += map[bits & 0x3F];
  } else if (tail === 2) {
    result += map[bits >> 10 & 0x3F];
    result += map[bits >> 4 & 0x3F];
    result += map[bits << 2 & 0x3F];
    result += map[64];
  } else if (tail === 1) {
    result += map[bits >> 2 & 0x3F];
    result += map[bits << 4 & 0x3F];
    result += map[64];
    result += map[64];
  }

  return result;
}

function isBinary(object) {
  return NodeBuffer && NodeBuffer.isBuffer(object);
}

module.exports = new Type('tag:yaml.org,2002:binary', {
  kind: 'scalar',
  resolve: resolveYamlBinary,
  construct: constructYamlBinary,
  predicate: isBinary,
  represent: representYamlBinary
});

/***/ }),
/* 150 */
/***/ (function(module, exports) {

module.exports = require("buffer");

/***/ }),
/* 151 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var Type = __webpack_require__(4);

var _hasOwnProperty = Object.prototype.hasOwnProperty;
var _toString = Object.prototype.toString;

function resolveYamlOmap(data) {
  if (data === null) return true;

  var objectKeys = [],
      index,
      length,
      pair,
      pairKey,
      pairHasKey,
      object = data;

  for (index = 0, length = object.length; index < length; index += 1) {
    pair = object[index];
    pairHasKey = false;

    if (_toString.call(pair) !== '[object Object]') return false;

    for (pairKey in pair) {
      if (_hasOwnProperty.call(pair, pairKey)) {
        if (!pairHasKey) pairHasKey = true;else return false;
      }
    }

    if (!pairHasKey) return false;

    if (objectKeys.indexOf(pairKey) === -1) objectKeys.push(pairKey);else return false;
  }

  return true;
}

function constructYamlOmap(data) {
  return data !== null ? data : [];
}

module.exports = new Type('tag:yaml.org,2002:omap', {
  kind: 'sequence',
  resolve: resolveYamlOmap,
  construct: constructYamlOmap
});

/***/ }),
/* 152 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var Type = __webpack_require__(4);

var _toString = Object.prototype.toString;

function resolveYamlPairs(data) {
  if (data === null) return true;

  var index,
      length,
      pair,
      keys,
      result,
      object = data;

  result = new Array(object.length);

  for (index = 0, length = object.length; index < length; index += 1) {
    pair = object[index];

    if (_toString.call(pair) !== '[object Object]') return false;

    keys = Object.keys(pair);

    if (keys.length !== 1) return false;

    result[index] = [keys[0], pair[keys[0]]];
  }

  return true;
}

function constructYamlPairs(data) {
  if (data === null) return [];

  var index,
      length,
      pair,
      keys,
      result,
      object = data;

  result = new Array(object.length);

  for (index = 0, length = object.length; index < length; index += 1) {
    pair = object[index];

    keys = Object.keys(pair);

    result[index] = [keys[0], pair[keys[0]]];
  }

  return result;
}

module.exports = new Type('tag:yaml.org,2002:pairs', {
  kind: 'sequence',
  resolve: resolveYamlPairs,
  construct: constructYamlPairs
});

/***/ }),
/* 153 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var Type = __webpack_require__(4);

var _hasOwnProperty = Object.prototype.hasOwnProperty;

function resolveYamlSet(data) {
  if (data === null) return true;

  var key,
      object = data;

  for (key in object) {
    if (_hasOwnProperty.call(object, key)) {
      if (object[key] !== null) return false;
    }
  }

  return true;
}

function constructYamlSet(data) {
  return data !== null ? data : {};
}

module.exports = new Type('tag:yaml.org,2002:set', {
  kind: 'mapping',
  resolve: resolveYamlSet,
  construct: constructYamlSet
});

/***/ }),
/* 154 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var Type = __webpack_require__(4);

function resolveJavascriptUndefined() {
  return true;
}

function constructJavascriptUndefined() {
  /*eslint-disable no-undefined*/
  return undefined;
}

function representJavascriptUndefined() {
  return '';
}

function isUndefined(object) {
  return typeof object === 'undefined';
}

module.exports = new Type('tag:yaml.org,2002:js/undefined', {
  kind: 'scalar',
  resolve: resolveJavascriptUndefined,
  construct: constructJavascriptUndefined,
  predicate: isUndefined,
  represent: representJavascriptUndefined
});

/***/ }),
/* 155 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var Type = __webpack_require__(4);

function resolveJavascriptRegExp(data) {
  if (data === null) return false;
  if (data.length === 0) return false;

  var regexp = data,
      tail = /\/([gim]*)$/.exec(data),
      modifiers = '';

  // if regexp starts with '/' it can have modifiers and must be properly closed
  // `/foo/gim` - modifiers tail can be maximum 3 chars
  if (regexp[0] === '/') {
    if (tail) modifiers = tail[1];

    if (modifiers.length > 3) return false;
    // if expression starts with /, is should be properly terminated
    if (regexp[regexp.length - modifiers.length - 1] !== '/') return false;
  }

  return true;
}

function constructJavascriptRegExp(data) {
  var regexp = data,
      tail = /\/([gim]*)$/.exec(data),
      modifiers = '';

  // `/foo/gim` - tail can be maximum 4 chars
  if (regexp[0] === '/') {
    if (tail) modifiers = tail[1];
    regexp = regexp.slice(1, regexp.length - modifiers.length - 1);
  }

  return new RegExp(regexp, modifiers);
}

function representJavascriptRegExp(object /*, style*/) {
  var result = '/' + object.source + '/';

  if (object.global) result += 'g';
  if (object.multiline) result += 'm';
  if (object.ignoreCase) result += 'i';

  return result;
}

function isRegExp(object) {
  return Object.prototype.toString.call(object) === '[object RegExp]';
}

module.exports = new Type('tag:yaml.org,2002:js/regexp', {
  kind: 'scalar',
  resolve: resolveJavascriptRegExp,
  construct: constructJavascriptRegExp,
  predicate: isRegExp,
  represent: representJavascriptRegExp
});

/***/ }),
/* 156 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var require;

var esprima;

// Browserified version does not have esprima
//
// 1. For node.js just require module as deps
// 2. For browser try to require mudule via external AMD system.
//    If not found - try to fallback to window.esprima. If not
//    found too - then fail to parse.
//
try {
  // workaround to exclude package from browserify list.
  var _require = require;
  esprima = __webpack_require__(157);
} catch (_) {
  /*global window */
  if (typeof window !== 'undefined') esprima = window.esprima;
}

var Type = __webpack_require__(4);

function resolveJavascriptFunction(data) {
  if (data === null) return false;

  try {
    var source = '(' + data + ')',
        ast = esprima.parse(source, { range: true });

    if (ast.type !== 'Program' || ast.body.length !== 1 || ast.body[0].type !== 'ExpressionStatement' || ast.body[0].expression.type !== 'FunctionExpression') {
      return false;
    }

    return true;
  } catch (err) {
    return false;
  }
}

function constructJavascriptFunction(data) {
  /*jslint evil:true*/

  var source = '(' + data + ')',
      ast = esprima.parse(source, { range: true }),
      params = [],
      body;

  if (ast.type !== 'Program' || ast.body.length !== 1 || ast.body[0].type !== 'ExpressionStatement' || ast.body[0].expression.type !== 'FunctionExpression') {
    throw new Error('Failed to resolve function');
  }

  ast.body[0].expression.params.forEach(function (param) {
    params.push(param.name);
  });

  body = ast.body[0].expression.body.range;

  // Esprima's ranges include the first '{' and the last '}' characters on
  // function expressions. So cut them out.
  /*eslint-disable no-new-func*/
  return new Function(params, source.slice(body[0] + 1, body[1] - 1));
}

function representJavascriptFunction(object /*, style*/) {
  return object.toString();
}

function isFunction(object) {
  return Object.prototype.toString.call(object) === '[object Function]';
}

module.exports = new Type('tag:yaml.org,2002:js/function', {
  kind: 'scalar',
  resolve: resolveJavascriptFunction,
  construct: constructJavascriptFunction,
  predicate: isFunction,
  represent: representJavascriptFunction
});

/***/ }),
/* 157 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


(function webpackUniversalModuleDefinition(root, factory) {
	/* istanbul ignore next */
	if (true) module.exports = factory();else if (typeof define === 'function' && define.amd) define([], factory);
	/* istanbul ignore next */
	else if (typeof exports === 'object') exports["esprima"] = factory();else root["esprima"] = factory();
})(undefined, function () {
	return (/******/function (modules) {
			// webpackBootstrap
			/******/ // The module cache
			/******/var installedModules = {};

			/******/ // The require function
			/******/function __webpack_require__(moduleId) {

				/******/ // Check if module is in cache
				/* istanbul ignore if */
				/******/if (installedModules[moduleId])
					/******/return installedModules[moduleId].exports;

				/******/ // Create a new module (and put it into the cache)
				/******/var module = installedModules[moduleId] = {
					/******/exports: {},
					/******/id: moduleId,
					/******/loaded: false
					/******/ };

				/******/ // Execute the module function
				/******/modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);

				/******/ // Flag the module as loaded
				/******/module.loaded = true;

				/******/ // Return the exports of the module
				/******/return module.exports;
				/******/
			}

			/******/ // expose the modules object (__webpack_modules__)
			/******/__webpack_require__.m = modules;

			/******/ // expose the module cache
			/******/__webpack_require__.c = installedModules;

			/******/ // __webpack_public_path__
			/******/__webpack_require__.p = "";

			/******/ // Load entry module and return exports
			/******/return __webpack_require__(0);
			/******/
		}(
		/************************************************************************/
		/******/[
		/* 0 */
		/***/function (module, exports, __webpack_require__) {

			"use strict";
			/*
     Copyright JS Foundation and other contributors, https://js.foundation/
   
     Redistribution and use in source and binary forms, with or without
     modification, are permitted provided that the following conditions are met:
   
       * Redistributions of source code must retain the above copyright
         notice, this list of conditions and the following disclaimer.
       * Redistributions in binary form must reproduce the above copyright
         notice, this list of conditions and the following disclaimer in the
         documentation and/or other materials provided with the distribution.
   
     THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
     AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
     IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
     ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY
     DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
     (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
     LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
     ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
     (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
     THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
   */

			Object.defineProperty(exports, "__esModule", { value: true });
			var comment_handler_1 = __webpack_require__(1);
			var jsx_parser_1 = __webpack_require__(3);
			var parser_1 = __webpack_require__(8);
			var tokenizer_1 = __webpack_require__(15);
			function parse(code, options, delegate) {
				var commentHandler = null;
				var proxyDelegate = function (node, metadata) {
					if (delegate) {
						delegate(node, metadata);
					}
					if (commentHandler) {
						commentHandler.visit(node, metadata);
					}
				};
				var parserDelegate = typeof delegate === 'function' ? proxyDelegate : null;
				var collectComment = false;
				if (options) {
					collectComment = typeof options.comment === 'boolean' && options.comment;
					var attachComment = typeof options.attachComment === 'boolean' && options.attachComment;
					if (collectComment || attachComment) {
						commentHandler = new comment_handler_1.CommentHandler();
						commentHandler.attach = attachComment;
						options.comment = true;
						parserDelegate = proxyDelegate;
					}
				}
				var isModule = false;
				if (options && typeof options.sourceType === 'string') {
					isModule = options.sourceType === 'module';
				}
				var parser;
				if (options && typeof options.jsx === 'boolean' && options.jsx) {
					parser = new jsx_parser_1.JSXParser(code, options, parserDelegate);
				} else {
					parser = new parser_1.Parser(code, options, parserDelegate);
				}
				var program = isModule ? parser.parseModule() : parser.parseScript();
				var ast = program;
				if (collectComment && commentHandler) {
					ast.comments = commentHandler.comments;
				}
				if (parser.config.tokens) {
					ast.tokens = parser.tokens;
				}
				if (parser.config.tolerant) {
					ast.errors = parser.errorHandler.errors;
				}
				return ast;
			}
			exports.parse = parse;
			function parseModule(code, options, delegate) {
				var parsingOptions = options || {};
				parsingOptions.sourceType = 'module';
				return parse(code, parsingOptions, delegate);
			}
			exports.parseModule = parseModule;
			function parseScript(code, options, delegate) {
				var parsingOptions = options || {};
				parsingOptions.sourceType = 'script';
				return parse(code, parsingOptions, delegate);
			}
			exports.parseScript = parseScript;
			function tokenize(code, options, delegate) {
				var tokenizer = new tokenizer_1.Tokenizer(code, options);
				var tokens;
				tokens = [];
				try {
					while (true) {
						var token = tokenizer.getNextToken();
						if (!token) {
							break;
						}
						if (delegate) {
							token = delegate(token);
						}
						tokens.push(token);
					}
				} catch (e) {
					tokenizer.errorHandler.tolerate(e);
				}
				if (tokenizer.errorHandler.tolerant) {
					tokens.errors = tokenizer.errors();
				}
				return tokens;
			}
			exports.tokenize = tokenize;
			var syntax_1 = __webpack_require__(2);
			exports.Syntax = syntax_1.Syntax;
			// Sync with *.json manifests.
			exports.version = '4.0.0';

			/***/
		},
		/* 1 */
		/***/function (module, exports, __webpack_require__) {

			"use strict";

			Object.defineProperty(exports, "__esModule", { value: true });
			var syntax_1 = __webpack_require__(2);
			var CommentHandler = function () {
				function CommentHandler() {
					this.attach = false;
					this.comments = [];
					this.stack = [];
					this.leading = [];
					this.trailing = [];
				}
				CommentHandler.prototype.insertInnerComments = function (node, metadata) {
					//  innnerComments for properties empty block
					//  `function a() {/** comments **\/}`
					if (node.type === syntax_1.Syntax.BlockStatement && node.body.length === 0) {
						var innerComments = [];
						for (var i = this.leading.length - 1; i >= 0; --i) {
							var entry = this.leading[i];
							if (metadata.end.offset >= entry.start) {
								innerComments.unshift(entry.comment);
								this.leading.splice(i, 1);
								this.trailing.splice(i, 1);
							}
						}
						if (innerComments.length) {
							node.innerComments = innerComments;
						}
					}
				};
				CommentHandler.prototype.findTrailingComments = function (metadata) {
					var trailingComments = [];
					if (this.trailing.length > 0) {
						for (var i = this.trailing.length - 1; i >= 0; --i) {
							var entry_1 = this.trailing[i];
							if (entry_1.start >= metadata.end.offset) {
								trailingComments.unshift(entry_1.comment);
							}
						}
						this.trailing.length = 0;
						return trailingComments;
					}
					var entry = this.stack[this.stack.length - 1];
					if (entry && entry.node.trailingComments) {
						var firstComment = entry.node.trailingComments[0];
						if (firstComment && firstComment.range[0] >= metadata.end.offset) {
							trailingComments = entry.node.trailingComments;
							delete entry.node.trailingComments;
						}
					}
					return trailingComments;
				};
				CommentHandler.prototype.findLeadingComments = function (metadata) {
					var leadingComments = [];
					var target;
					while (this.stack.length > 0) {
						var entry = this.stack[this.stack.length - 1];
						if (entry && entry.start >= metadata.start.offset) {
							target = entry.node;
							this.stack.pop();
						} else {
							break;
						}
					}
					if (target) {
						var count = target.leadingComments ? target.leadingComments.length : 0;
						for (var i = count - 1; i >= 0; --i) {
							var comment = target.leadingComments[i];
							if (comment.range[1] <= metadata.start.offset) {
								leadingComments.unshift(comment);
								target.leadingComments.splice(i, 1);
							}
						}
						if (target.leadingComments && target.leadingComments.length === 0) {
							delete target.leadingComments;
						}
						return leadingComments;
					}
					for (var i = this.leading.length - 1; i >= 0; --i) {
						var entry = this.leading[i];
						if (entry.start <= metadata.start.offset) {
							leadingComments.unshift(entry.comment);
							this.leading.splice(i, 1);
						}
					}
					return leadingComments;
				};
				CommentHandler.prototype.visitNode = function (node, metadata) {
					if (node.type === syntax_1.Syntax.Program && node.body.length > 0) {
						return;
					}
					this.insertInnerComments(node, metadata);
					var trailingComments = this.findTrailingComments(metadata);
					var leadingComments = this.findLeadingComments(metadata);
					if (leadingComments.length > 0) {
						node.leadingComments = leadingComments;
					}
					if (trailingComments.length > 0) {
						node.trailingComments = trailingComments;
					}
					this.stack.push({
						node: node,
						start: metadata.start.offset
					});
				};
				CommentHandler.prototype.visitComment = function (node, metadata) {
					var type = node.type[0] === 'L' ? 'Line' : 'Block';
					var comment = {
						type: type,
						value: node.value
					};
					if (node.range) {
						comment.range = node.range;
					}
					if (node.loc) {
						comment.loc = node.loc;
					}
					this.comments.push(comment);
					if (this.attach) {
						var entry = {
							comment: {
								type: type,
								value: node.value,
								range: [metadata.start.offset, metadata.end.offset]
							},
							start: metadata.start.offset
						};
						if (node.loc) {
							entry.comment.loc = node.loc;
						}
						node.type = type;
						this.leading.push(entry);
						this.trailing.push(entry);
					}
				};
				CommentHandler.prototype.visit = function (node, metadata) {
					if (node.type === 'LineComment') {
						this.visitComment(node, metadata);
					} else if (node.type === 'BlockComment') {
						this.visitComment(node, metadata);
					} else if (this.attach) {
						this.visitNode(node, metadata);
					}
				};
				return CommentHandler;
			}();
			exports.CommentHandler = CommentHandler;

			/***/
		},
		/* 2 */
		/***/function (module, exports) {

			"use strict";

			Object.defineProperty(exports, "__esModule", { value: true });
			exports.Syntax = {
				AssignmentExpression: 'AssignmentExpression',
				AssignmentPattern: 'AssignmentPattern',
				ArrayExpression: 'ArrayExpression',
				ArrayPattern: 'ArrayPattern',
				ArrowFunctionExpression: 'ArrowFunctionExpression',
				AwaitExpression: 'AwaitExpression',
				BlockStatement: 'BlockStatement',
				BinaryExpression: 'BinaryExpression',
				BreakStatement: 'BreakStatement',
				CallExpression: 'CallExpression',
				CatchClause: 'CatchClause',
				ClassBody: 'ClassBody',
				ClassDeclaration: 'ClassDeclaration',
				ClassExpression: 'ClassExpression',
				ConditionalExpression: 'ConditionalExpression',
				ContinueStatement: 'ContinueStatement',
				DoWhileStatement: 'DoWhileStatement',
				DebuggerStatement: 'DebuggerStatement',
				EmptyStatement: 'EmptyStatement',
				ExportAllDeclaration: 'ExportAllDeclaration',
				ExportDefaultDeclaration: 'ExportDefaultDeclaration',
				ExportNamedDeclaration: 'ExportNamedDeclaration',
				ExportSpecifier: 'ExportSpecifier',
				ExpressionStatement: 'ExpressionStatement',
				ForStatement: 'ForStatement',
				ForOfStatement: 'ForOfStatement',
				ForInStatement: 'ForInStatement',
				FunctionDeclaration: 'FunctionDeclaration',
				FunctionExpression: 'FunctionExpression',
				Identifier: 'Identifier',
				IfStatement: 'IfStatement',
				ImportDeclaration: 'ImportDeclaration',
				ImportDefaultSpecifier: 'ImportDefaultSpecifier',
				ImportNamespaceSpecifier: 'ImportNamespaceSpecifier',
				ImportSpecifier: 'ImportSpecifier',
				Literal: 'Literal',
				LabeledStatement: 'LabeledStatement',
				LogicalExpression: 'LogicalExpression',
				MemberExpression: 'MemberExpression',
				MetaProperty: 'MetaProperty',
				MethodDefinition: 'MethodDefinition',
				NewExpression: 'NewExpression',
				ObjectExpression: 'ObjectExpression',
				ObjectPattern: 'ObjectPattern',
				Program: 'Program',
				Property: 'Property',
				RestElement: 'RestElement',
				ReturnStatement: 'ReturnStatement',
				SequenceExpression: 'SequenceExpression',
				SpreadElement: 'SpreadElement',
				Super: 'Super',
				SwitchCase: 'SwitchCase',
				SwitchStatement: 'SwitchStatement',
				TaggedTemplateExpression: 'TaggedTemplateExpression',
				TemplateElement: 'TemplateElement',
				TemplateLiteral: 'TemplateLiteral',
				ThisExpression: 'ThisExpression',
				ThrowStatement: 'ThrowStatement',
				TryStatement: 'TryStatement',
				UnaryExpression: 'UnaryExpression',
				UpdateExpression: 'UpdateExpression',
				VariableDeclaration: 'VariableDeclaration',
				VariableDeclarator: 'VariableDeclarator',
				WhileStatement: 'WhileStatement',
				WithStatement: 'WithStatement',
				YieldExpression: 'YieldExpression'
			};

			/***/
		},
		/* 3 */
		/***/function (module, exports, __webpack_require__) {

			"use strict";
			/* istanbul ignore next */

			var __extends = this && this.__extends || function () {
				var extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function (d, b) {
					d.__proto__ = b;
				} || function (d, b) {
					for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
				};
				return function (d, b) {
					extendStatics(d, b);
					function __() {
						this.constructor = d;
					}
					d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
				};
			}();
			Object.defineProperty(exports, "__esModule", { value: true });
			var character_1 = __webpack_require__(4);
			var JSXNode = __webpack_require__(5);
			var jsx_syntax_1 = __webpack_require__(6);
			var Node = __webpack_require__(7);
			var parser_1 = __webpack_require__(8);
			var token_1 = __webpack_require__(13);
			var xhtml_entities_1 = __webpack_require__(14);
			token_1.TokenName[100 /* Identifier */] = 'JSXIdentifier';
			token_1.TokenName[101 /* Text */] = 'JSXText';
			// Fully qualified element name, e.g. <svg:path> returns "svg:path"
			function getQualifiedElementName(elementName) {
				var qualifiedName;
				switch (elementName.type) {
					case jsx_syntax_1.JSXSyntax.JSXIdentifier:
						var id = elementName;
						qualifiedName = id.name;
						break;
					case jsx_syntax_1.JSXSyntax.JSXNamespacedName:
						var ns = elementName;
						qualifiedName = getQualifiedElementName(ns.namespace) + ':' + getQualifiedElementName(ns.name);
						break;
					case jsx_syntax_1.JSXSyntax.JSXMemberExpression:
						var expr = elementName;
						qualifiedName = getQualifiedElementName(expr.object) + '.' + getQualifiedElementName(expr.property);
						break;
					/* istanbul ignore next */
					default:
						break;
				}
				return qualifiedName;
			}
			var JSXParser = function (_super) {
				__extends(JSXParser, _super);
				function JSXParser(code, options, delegate) {
					return _super.call(this, code, options, delegate) || this;
				}
				JSXParser.prototype.parsePrimaryExpression = function () {
					return this.match('<') ? this.parseJSXRoot() : _super.prototype.parsePrimaryExpression.call(this);
				};
				JSXParser.prototype.startJSX = function () {
					// Unwind the scanner before the lookahead token.
					this.scanner.index = this.startMarker.index;
					this.scanner.lineNumber = this.startMarker.line;
					this.scanner.lineStart = this.startMarker.index - this.startMarker.column;
				};
				JSXParser.prototype.finishJSX = function () {
					// Prime the next lookahead.
					this.nextToken();
				};
				JSXParser.prototype.reenterJSX = function () {
					this.startJSX();
					this.expectJSX('}');
					// Pop the closing '}' added from the lookahead.
					if (this.config.tokens) {
						this.tokens.pop();
					}
				};
				JSXParser.prototype.createJSXNode = function () {
					this.collectComments();
					return {
						index: this.scanner.index,
						line: this.scanner.lineNumber,
						column: this.scanner.index - this.scanner.lineStart
					};
				};
				JSXParser.prototype.createJSXChildNode = function () {
					return {
						index: this.scanner.index,
						line: this.scanner.lineNumber,
						column: this.scanner.index - this.scanner.lineStart
					};
				};
				JSXParser.prototype.scanXHTMLEntity = function (quote) {
					var result = '&';
					var valid = true;
					var terminated = false;
					var numeric = false;
					var hex = false;
					while (!this.scanner.eof() && valid && !terminated) {
						var ch = this.scanner.source[this.scanner.index];
						if (ch === quote) {
							break;
						}
						terminated = ch === ';';
						result += ch;
						++this.scanner.index;
						if (!terminated) {
							switch (result.length) {
								case 2:
									// e.g. '&#123;'
									numeric = ch === '#';
									break;
								case 3:
									if (numeric) {
										// e.g. '&#x41;'
										hex = ch === 'x';
										valid = hex || character_1.Character.isDecimalDigit(ch.charCodeAt(0));
										numeric = numeric && !hex;
									}
									break;
								default:
									valid = valid && !(numeric && !character_1.Character.isDecimalDigit(ch.charCodeAt(0)));
									valid = valid && !(hex && !character_1.Character.isHexDigit(ch.charCodeAt(0)));
									break;
							}
						}
					}
					if (valid && terminated && result.length > 2) {
						// e.g. '&#x41;' becomes just '#x41'
						var str = result.substr(1, result.length - 2);
						if (numeric && str.length > 1) {
							result = String.fromCharCode(parseInt(str.substr(1), 10));
						} else if (hex && str.length > 2) {
							result = String.fromCharCode(parseInt('0' + str.substr(1), 16));
						} else if (!numeric && !hex && xhtml_entities_1.XHTMLEntities[str]) {
							result = xhtml_entities_1.XHTMLEntities[str];
						}
					}
					return result;
				};
				// Scan the next JSX token. This replaces Scanner#lex when in JSX mode.
				JSXParser.prototype.lexJSX = function () {
					var cp = this.scanner.source.charCodeAt(this.scanner.index);
					// < > / : = { }
					if (cp === 60 || cp === 62 || cp === 47 || cp === 58 || cp === 61 || cp === 123 || cp === 125) {
						var value = this.scanner.source[this.scanner.index++];
						return {
							type: 7 /* Punctuator */
							, value: value,
							lineNumber: this.scanner.lineNumber,
							lineStart: this.scanner.lineStart,
							start: this.scanner.index - 1,
							end: this.scanner.index
						};
					}
					// " '
					if (cp === 34 || cp === 39) {
						var start = this.scanner.index;
						var quote = this.scanner.source[this.scanner.index++];
						var str = '';
						while (!this.scanner.eof()) {
							var ch = this.scanner.source[this.scanner.index++];
							if (ch === quote) {
								break;
							} else if (ch === '&') {
								str += this.scanXHTMLEntity(quote);
							} else {
								str += ch;
							}
						}
						return {
							type: 8 /* StringLiteral */
							, value: str,
							lineNumber: this.scanner.lineNumber,
							lineStart: this.scanner.lineStart,
							start: start,
							end: this.scanner.index
						};
					}
					// ... or .
					if (cp === 46) {
						var n1 = this.scanner.source.charCodeAt(this.scanner.index + 1);
						var n2 = this.scanner.source.charCodeAt(this.scanner.index + 2);
						var value = n1 === 46 && n2 === 46 ? '...' : '.';
						var start = this.scanner.index;
						this.scanner.index += value.length;
						return {
							type: 7 /* Punctuator */
							, value: value,
							lineNumber: this.scanner.lineNumber,
							lineStart: this.scanner.lineStart,
							start: start,
							end: this.scanner.index
						};
					}
					// `
					if (cp === 96) {
						// Only placeholder, since it will be rescanned as a real assignment expression.
						return {
							type: 10 /* Template */
							, value: '',
							lineNumber: this.scanner.lineNumber,
							lineStart: this.scanner.lineStart,
							start: this.scanner.index,
							end: this.scanner.index
						};
					}
					// Identifer can not contain backslash (char code 92).
					if (character_1.Character.isIdentifierStart(cp) && cp !== 92) {
						var start = this.scanner.index;
						++this.scanner.index;
						while (!this.scanner.eof()) {
							var ch = this.scanner.source.charCodeAt(this.scanner.index);
							if (character_1.Character.isIdentifierPart(ch) && ch !== 92) {
								++this.scanner.index;
							} else if (ch === 45) {
								// Hyphen (char code 45) can be part of an identifier.
								++this.scanner.index;
							} else {
								break;
							}
						}
						var id = this.scanner.source.slice(start, this.scanner.index);
						return {
							type: 100 /* Identifier */
							, value: id,
							lineNumber: this.scanner.lineNumber,
							lineStart: this.scanner.lineStart,
							start: start,
							end: this.scanner.index
						};
					}
					return this.scanner.lex();
				};
				JSXParser.prototype.nextJSXToken = function () {
					this.collectComments();
					this.startMarker.index = this.scanner.index;
					this.startMarker.line = this.scanner.lineNumber;
					this.startMarker.column = this.scanner.index - this.scanner.lineStart;
					var token = this.lexJSX();
					this.lastMarker.index = this.scanner.index;
					this.lastMarker.line = this.scanner.lineNumber;
					this.lastMarker.column = this.scanner.index - this.scanner.lineStart;
					if (this.config.tokens) {
						this.tokens.push(this.convertToken(token));
					}
					return token;
				};
				JSXParser.prototype.nextJSXText = function () {
					this.startMarker.index = this.scanner.index;
					this.startMarker.line = this.scanner.lineNumber;
					this.startMarker.column = this.scanner.index - this.scanner.lineStart;
					var start = this.scanner.index;
					var text = '';
					while (!this.scanner.eof()) {
						var ch = this.scanner.source[this.scanner.index];
						if (ch === '{' || ch === '<') {
							break;
						}
						++this.scanner.index;
						text += ch;
						if (character_1.Character.isLineTerminator(ch.charCodeAt(0))) {
							++this.scanner.lineNumber;
							if (ch === '\r' && this.scanner.source[this.scanner.index] === '\n') {
								++this.scanner.index;
							}
							this.scanner.lineStart = this.scanner.index;
						}
					}
					this.lastMarker.index = this.scanner.index;
					this.lastMarker.line = this.scanner.lineNumber;
					this.lastMarker.column = this.scanner.index - this.scanner.lineStart;
					var token = {
						type: 101 /* Text */
						, value: text,
						lineNumber: this.scanner.lineNumber,
						lineStart: this.scanner.lineStart,
						start: start,
						end: this.scanner.index
					};
					if (text.length > 0 && this.config.tokens) {
						this.tokens.push(this.convertToken(token));
					}
					return token;
				};
				JSXParser.prototype.peekJSXToken = function () {
					var state = this.scanner.saveState();
					this.scanner.scanComments();
					var next = this.lexJSX();
					this.scanner.restoreState(state);
					return next;
				};
				// Expect the next JSX token to match the specified punctuator.
				// If not, an exception will be thrown.
				JSXParser.prototype.expectJSX = function (value) {
					var token = this.nextJSXToken();
					if (token.type !== 7 /* Punctuator */ || token.value !== value) {
						this.throwUnexpectedToken(token);
					}
				};
				// Return true if the next JSX token matches the specified punctuator.
				JSXParser.prototype.matchJSX = function (value) {
					var next = this.peekJSXToken();
					return next.type === 7 /* Punctuator */ && next.value === value;
				};
				JSXParser.prototype.parseJSXIdentifier = function () {
					var node = this.createJSXNode();
					var token = this.nextJSXToken();
					if (token.type !== 100 /* Identifier */) {
							this.throwUnexpectedToken(token);
						}
					return this.finalize(node, new JSXNode.JSXIdentifier(token.value));
				};
				JSXParser.prototype.parseJSXElementName = function () {
					var node = this.createJSXNode();
					var elementName = this.parseJSXIdentifier();
					if (this.matchJSX(':')) {
						var namespace = elementName;
						this.expectJSX(':');
						var name_1 = this.parseJSXIdentifier();
						elementName = this.finalize(node, new JSXNode.JSXNamespacedName(namespace, name_1));
					} else if (this.matchJSX('.')) {
						while (this.matchJSX('.')) {
							var object = elementName;
							this.expectJSX('.');
							var property = this.parseJSXIdentifier();
							elementName = this.finalize(node, new JSXNode.JSXMemberExpression(object, property));
						}
					}
					return elementName;
				};
				JSXParser.prototype.parseJSXAttributeName = function () {
					var node = this.createJSXNode();
					var attributeName;
					var identifier = this.parseJSXIdentifier();
					if (this.matchJSX(':')) {
						var namespace = identifier;
						this.expectJSX(':');
						var name_2 = this.parseJSXIdentifier();
						attributeName = this.finalize(node, new JSXNode.JSXNamespacedName(namespace, name_2));
					} else {
						attributeName = identifier;
					}
					return attributeName;
				};
				JSXParser.prototype.parseJSXStringLiteralAttribute = function () {
					var node = this.createJSXNode();
					var token = this.nextJSXToken();
					if (token.type !== 8 /* StringLiteral */) {
							this.throwUnexpectedToken(token);
						}
					var raw = this.getTokenRaw(token);
					return this.finalize(node, new Node.Literal(token.value, raw));
				};
				JSXParser.prototype.parseJSXExpressionAttribute = function () {
					var node = this.createJSXNode();
					this.expectJSX('{');
					this.finishJSX();
					if (this.match('}')) {
						this.tolerateError('JSX attributes must only be assigned a non-empty expression');
					}
					var expression = this.parseAssignmentExpression();
					this.reenterJSX();
					return this.finalize(node, new JSXNode.JSXExpressionContainer(expression));
				};
				JSXParser.prototype.parseJSXAttributeValue = function () {
					return this.matchJSX('{') ? this.parseJSXExpressionAttribute() : this.matchJSX('<') ? this.parseJSXElement() : this.parseJSXStringLiteralAttribute();
				};
				JSXParser.prototype.parseJSXNameValueAttribute = function () {
					var node = this.createJSXNode();
					var name = this.parseJSXAttributeName();
					var value = null;
					if (this.matchJSX('=')) {
						this.expectJSX('=');
						value = this.parseJSXAttributeValue();
					}
					return this.finalize(node, new JSXNode.JSXAttribute(name, value));
				};
				JSXParser.prototype.parseJSXSpreadAttribute = function () {
					var node = this.createJSXNode();
					this.expectJSX('{');
					this.expectJSX('...');
					this.finishJSX();
					var argument = this.parseAssignmentExpression();
					this.reenterJSX();
					return this.finalize(node, new JSXNode.JSXSpreadAttribute(argument));
				};
				JSXParser.prototype.parseJSXAttributes = function () {
					var attributes = [];
					while (!this.matchJSX('/') && !this.matchJSX('>')) {
						var attribute = this.matchJSX('{') ? this.parseJSXSpreadAttribute() : this.parseJSXNameValueAttribute();
						attributes.push(attribute);
					}
					return attributes;
				};
				JSXParser.prototype.parseJSXOpeningElement = function () {
					var node = this.createJSXNode();
					this.expectJSX('<');
					var name = this.parseJSXElementName();
					var attributes = this.parseJSXAttributes();
					var selfClosing = this.matchJSX('/');
					if (selfClosing) {
						this.expectJSX('/');
					}
					this.expectJSX('>');
					return this.finalize(node, new JSXNode.JSXOpeningElement(name, selfClosing, attributes));
				};
				JSXParser.prototype.parseJSXBoundaryElement = function () {
					var node = this.createJSXNode();
					this.expectJSX('<');
					if (this.matchJSX('/')) {
						this.expectJSX('/');
						var name_3 = this.parseJSXElementName();
						this.expectJSX('>');
						return this.finalize(node, new JSXNode.JSXClosingElement(name_3));
					}
					var name = this.parseJSXElementName();
					var attributes = this.parseJSXAttributes();
					var selfClosing = this.matchJSX('/');
					if (selfClosing) {
						this.expectJSX('/');
					}
					this.expectJSX('>');
					return this.finalize(node, new JSXNode.JSXOpeningElement(name, selfClosing, attributes));
				};
				JSXParser.prototype.parseJSXEmptyExpression = function () {
					var node = this.createJSXChildNode();
					this.collectComments();
					this.lastMarker.index = this.scanner.index;
					this.lastMarker.line = this.scanner.lineNumber;
					this.lastMarker.column = this.scanner.index - this.scanner.lineStart;
					return this.finalize(node, new JSXNode.JSXEmptyExpression());
				};
				JSXParser.prototype.parseJSXExpressionContainer = function () {
					var node = this.createJSXNode();
					this.expectJSX('{');
					var expression;
					if (this.matchJSX('}')) {
						expression = this.parseJSXEmptyExpression();
						this.expectJSX('}');
					} else {
						this.finishJSX();
						expression = this.parseAssignmentExpression();
						this.reenterJSX();
					}
					return this.finalize(node, new JSXNode.JSXExpressionContainer(expression));
				};
				JSXParser.prototype.parseJSXChildren = function () {
					var children = [];
					while (!this.scanner.eof()) {
						var node = this.createJSXChildNode();
						var token = this.nextJSXText();
						if (token.start < token.end) {
							var raw = this.getTokenRaw(token);
							var child = this.finalize(node, new JSXNode.JSXText(token.value, raw));
							children.push(child);
						}
						if (this.scanner.source[this.scanner.index] === '{') {
							var container = this.parseJSXExpressionContainer();
							children.push(container);
						} else {
							break;
						}
					}
					return children;
				};
				JSXParser.prototype.parseComplexJSXElement = function (el) {
					var stack = [];
					while (!this.scanner.eof()) {
						el.children = el.children.concat(this.parseJSXChildren());
						var node = this.createJSXChildNode();
						var element = this.parseJSXBoundaryElement();
						if (element.type === jsx_syntax_1.JSXSyntax.JSXOpeningElement) {
							var opening = element;
							if (opening.selfClosing) {
								var child = this.finalize(node, new JSXNode.JSXElement(opening, [], null));
								el.children.push(child);
							} else {
								stack.push(el);
								el = { node: node, opening: opening, closing: null, children: [] };
							}
						}
						if (element.type === jsx_syntax_1.JSXSyntax.JSXClosingElement) {
							el.closing = element;
							var open_1 = getQualifiedElementName(el.opening.name);
							var close_1 = getQualifiedElementName(el.closing.name);
							if (open_1 !== close_1) {
								this.tolerateError('Expected corresponding JSX closing tag for %0', open_1);
							}
							if (stack.length > 0) {
								var child = this.finalize(el.node, new JSXNode.JSXElement(el.opening, el.children, el.closing));
								el = stack[stack.length - 1];
								el.children.push(child);
								stack.pop();
							} else {
								break;
							}
						}
					}
					return el;
				};
				JSXParser.prototype.parseJSXElement = function () {
					var node = this.createJSXNode();
					var opening = this.parseJSXOpeningElement();
					var children = [];
					var closing = null;
					if (!opening.selfClosing) {
						var el = this.parseComplexJSXElement({ node: node, opening: opening, closing: closing, children: children });
						children = el.children;
						closing = el.closing;
					}
					return this.finalize(node, new JSXNode.JSXElement(opening, children, closing));
				};
				JSXParser.prototype.parseJSXRoot = function () {
					// Pop the opening '<' added from the lookahead.
					if (this.config.tokens) {
						this.tokens.pop();
					}
					this.startJSX();
					var element = this.parseJSXElement();
					this.finishJSX();
					return element;
				};
				JSXParser.prototype.isStartOfExpression = function () {
					return _super.prototype.isStartOfExpression.call(this) || this.match('<');
				};
				return JSXParser;
			}(parser_1.Parser);
			exports.JSXParser = JSXParser;

			/***/
		},
		/* 4 */
		/***/function (module, exports) {

			"use strict";

			Object.defineProperty(exports, "__esModule", { value: true });
			// See also tools/generate-unicode-regex.js.
			var Regex = {
				// Unicode v8.0.0 NonAsciiIdentifierStart:
				NonAsciiIdentifierStart: /[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u05D0-\u05EA\u05F0-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u08A0-\u08B4\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C60\u0C61\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1877\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF5\u1CF6\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309B-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FD5\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AD\uA7B0-\uA7B7\uA7F7-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD40-\uDD74\uDE80-\uDE9C\uDEA0-\uDED0\uDF00-\uDF1F\uDF30-\uDF4A\uDF50-\uDF75\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00\uDE10-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE4\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2]|\uD804[\uDC03-\uDC37\uDC83-\uDCAF\uDCD0-\uDCE8\uDD03-\uDD26\uDD50-\uDD72\uDD76\uDD83-\uDDB2\uDDC1-\uDDC4\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE2B\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEDE\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3D\uDF50\uDF5D-\uDF61]|\uD805[\uDC80-\uDCAF\uDCC4\uDCC5\uDCC7\uDD80-\uDDAE\uDDD8-\uDDDB\uDE00-\uDE2F\uDE44\uDE80-\uDEAA\uDF00-\uDF19]|\uD806[\uDCA0-\uDCDF\uDCFF\uDEC0-\uDEF8]|\uD808[\uDC00-\uDF99]|\uD809[\uDC00-\uDC6E\uDC80-\uDD43]|[\uD80C\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDED0-\uDEED\uDF00-\uDF2F\uDF40-\uDF43\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDF00-\uDF44\uDF50\uDF93-\uDF9F]|\uD82C[\uDC00\uDC01]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB]|\uD83A[\uDC00-\uDCC4]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1]|\uD87E[\uDC00-\uDE1D]/,
				// Unicode v8.0.0 NonAsciiIdentifierPart:
				NonAsciiIdentifierPart: /[\xAA\xB5\xB7\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0300-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u0483-\u0487\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u05D0-\u05EA\u05F0-\u05F2\u0610-\u061A\u0620-\u0669\u066E-\u06D3\u06D5-\u06DC\u06DF-\u06E8\u06EA-\u06FC\u06FF\u0710-\u074A\u074D-\u07B1\u07C0-\u07F5\u07FA\u0800-\u082D\u0840-\u085B\u08A0-\u08B4\u08E3-\u0963\u0966-\u096F\u0971-\u0983\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BC-\u09C4\u09C7\u09C8\u09CB-\u09CE\u09D7\u09DC\u09DD\u09DF-\u09E3\u09E6-\u09F1\u0A01-\u0A03\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A59-\u0A5C\u0A5E\u0A66-\u0A75\u0A81-\u0A83\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABC-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AD0\u0AE0-\u0AE3\u0AE6-\u0AEF\u0AF9\u0B01-\u0B03\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3C-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B56\u0B57\u0B5C\u0B5D\u0B5F-\u0B63\u0B66-\u0B6F\u0B71\u0B82\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD0\u0BD7\u0BE6-\u0BEF\u0C00-\u0C03\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C58-\u0C5A\u0C60-\u0C63\u0C66-\u0C6F\u0C81-\u0C83\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBC-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CDE\u0CE0-\u0CE3\u0CE6-\u0CEF\u0CF1\u0CF2\u0D01-\u0D03\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D-\u0D44\u0D46-\u0D48\u0D4A-\u0D4E\u0D57\u0D5F-\u0D63\u0D66-\u0D6F\u0D7A-\u0D7F\u0D82\u0D83\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E01-\u0E3A\u0E40-\u0E4E\u0E50-\u0E59\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB9\u0EBB-\u0EBD\u0EC0-\u0EC4\u0EC6\u0EC8-\u0ECD\u0ED0-\u0ED9\u0EDC-\u0EDF\u0F00\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E-\u0F47\u0F49-\u0F6C\u0F71-\u0F84\u0F86-\u0F97\u0F99-\u0FBC\u0FC6\u1000-\u1049\u1050-\u109D\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u135D-\u135F\u1369-\u1371\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1714\u1720-\u1734\u1740-\u1753\u1760-\u176C\u176E-\u1770\u1772\u1773\u1780-\u17D3\u17D7\u17DC\u17DD\u17E0-\u17E9\u180B-\u180D\u1810-\u1819\u1820-\u1877\u1880-\u18AA\u18B0-\u18F5\u1900-\u191E\u1920-\u192B\u1930-\u193B\u1946-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u19D0-\u19DA\u1A00-\u1A1B\u1A20-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AA7\u1AB0-\u1ABD\u1B00-\u1B4B\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1BF3\u1C00-\u1C37\u1C40-\u1C49\u1C4D-\u1C7D\u1CD0-\u1CD2\u1CD4-\u1CF6\u1CF8\u1CF9\u1D00-\u1DF5\u1DFC-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u200C\u200D\u203F\u2040\u2054\u2071\u207F\u2090-\u209C\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D7F-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2DE0-\u2DFF\u3005-\u3007\u3021-\u302F\u3031-\u3035\u3038-\u303C\u3041-\u3096\u3099-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FD5\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA62B\uA640-\uA66F\uA674-\uA67D\uA67F-\uA6F1\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AD\uA7B0-\uA7B7\uA7F7-\uA827\uA840-\uA873\uA880-\uA8C4\uA8D0-\uA8D9\uA8E0-\uA8F7\uA8FB\uA8FD\uA900-\uA92D\uA930-\uA953\uA960-\uA97C\uA980-\uA9C0\uA9CF-\uA9D9\uA9E0-\uA9FE\uAA00-\uAA36\uAA40-\uAA4D\uAA50-\uAA59\uAA60-\uAA76\uAA7A-\uAAC2\uAADB-\uAADD\uAAE0-\uAAEF\uAAF2-\uAAF6\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABEA\uABEC\uABED\uABF0-\uABF9\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE00-\uFE0F\uFE20-\uFE2F\uFE33\uFE34\uFE4D-\uFE4F\uFE70-\uFE74\uFE76-\uFEFC\uFF10-\uFF19\uFF21-\uFF3A\uFF3F\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD40-\uDD74\uDDFD\uDE80-\uDE9C\uDEA0-\uDED0\uDEE0\uDF00-\uDF1F\uDF30-\uDF4A\uDF50-\uDF7A\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDCA0-\uDCA9\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00-\uDE03\uDE05\uDE06\uDE0C-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE38-\uDE3A\uDE3F\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE6\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2]|\uD804[\uDC00-\uDC46\uDC66-\uDC6F\uDC7F-\uDCBA\uDCD0-\uDCE8\uDCF0-\uDCF9\uDD00-\uDD34\uDD36-\uDD3F\uDD50-\uDD73\uDD76\uDD80-\uDDC4\uDDCA-\uDDCC\uDDD0-\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE37\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEEA\uDEF0-\uDEF9\uDF00-\uDF03\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3C-\uDF44\uDF47\uDF48\uDF4B-\uDF4D\uDF50\uDF57\uDF5D-\uDF63\uDF66-\uDF6C\uDF70-\uDF74]|\uD805[\uDC80-\uDCC5\uDCC7\uDCD0-\uDCD9\uDD80-\uDDB5\uDDB8-\uDDC0\uDDD8-\uDDDD\uDE00-\uDE40\uDE44\uDE50-\uDE59\uDE80-\uDEB7\uDEC0-\uDEC9\uDF00-\uDF19\uDF1D-\uDF2B\uDF30-\uDF39]|\uD806[\uDCA0-\uDCE9\uDCFF\uDEC0-\uDEF8]|\uD808[\uDC00-\uDF99]|\uD809[\uDC00-\uDC6E\uDC80-\uDD43]|[\uD80C\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDE60-\uDE69\uDED0-\uDEED\uDEF0-\uDEF4\uDF00-\uDF36\uDF40-\uDF43\uDF50-\uDF59\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDF00-\uDF44\uDF50-\uDF7E\uDF8F-\uDF9F]|\uD82C[\uDC00\uDC01]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99\uDC9D\uDC9E]|\uD834[\uDD65-\uDD69\uDD6D-\uDD72\uDD7B-\uDD82\uDD85-\uDD8B\uDDAA-\uDDAD\uDE42-\uDE44]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB\uDFCE-\uDFFF]|\uD836[\uDE00-\uDE36\uDE3B-\uDE6C\uDE75\uDE84\uDE9B-\uDE9F\uDEA1-\uDEAF]|\uD83A[\uDC00-\uDCC4\uDCD0-\uDCD6]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1]|\uD87E[\uDC00-\uDE1D]|\uDB40[\uDD00-\uDDEF]/
			};
			exports.Character = {
				/* tslint:disable:no-bitwise */
				fromCodePoint: function (cp) {
					return cp < 0x10000 ? String.fromCharCode(cp) : String.fromCharCode(0xD800 + (cp - 0x10000 >> 10)) + String.fromCharCode(0xDC00 + (cp - 0x10000 & 1023));
				},
				// https://tc39.github.io/ecma262/#sec-white-space
				isWhiteSpace: function (cp) {
					return cp === 0x20 || cp === 0x09 || cp === 0x0B || cp === 0x0C || cp === 0xA0 || cp >= 0x1680 && [0x1680, 0x2000, 0x2001, 0x2002, 0x2003, 0x2004, 0x2005, 0x2006, 0x2007, 0x2008, 0x2009, 0x200A, 0x202F, 0x205F, 0x3000, 0xFEFF].indexOf(cp) >= 0;
				},
				// https://tc39.github.io/ecma262/#sec-line-terminators
				isLineTerminator: function (cp) {
					return cp === 0x0A || cp === 0x0D || cp === 0x2028 || cp === 0x2029;
				},
				// https://tc39.github.io/ecma262/#sec-names-and-keywords
				isIdentifierStart: function (cp) {
					return cp === 0x24 || cp === 0x5F || cp >= 0x41 && cp <= 0x5A || cp >= 0x61 && cp <= 0x7A || cp === 0x5C || cp >= 0x80 && Regex.NonAsciiIdentifierStart.test(exports.Character.fromCodePoint(cp));
				},
				isIdentifierPart: function (cp) {
					return cp === 0x24 || cp === 0x5F || cp >= 0x41 && cp <= 0x5A || cp >= 0x61 && cp <= 0x7A || cp >= 0x30 && cp <= 0x39 || cp === 0x5C || cp >= 0x80 && Regex.NonAsciiIdentifierPart.test(exports.Character.fromCodePoint(cp));
				},
				// https://tc39.github.io/ecma262/#sec-literals-numeric-literals
				isDecimalDigit: function (cp) {
					return cp >= 0x30 && cp <= 0x39; // 0..9
				},
				isHexDigit: function (cp) {
					return cp >= 0x30 && cp <= 0x39 || cp >= 0x41 && cp <= 0x46 || cp >= 0x61 && cp <= 0x66; // a..f
				},
				isOctalDigit: function (cp) {
					return cp >= 0x30 && cp <= 0x37; // 0..7
				}
			};

			/***/
		},
		/* 5 */
		/***/function (module, exports, __webpack_require__) {

			"use strict";

			Object.defineProperty(exports, "__esModule", { value: true });
			var jsx_syntax_1 = __webpack_require__(6);
			/* tslint:disable:max-classes-per-file */
			var JSXClosingElement = function () {
				function JSXClosingElement(name) {
					this.type = jsx_syntax_1.JSXSyntax.JSXClosingElement;
					this.name = name;
				}
				return JSXClosingElement;
			}();
			exports.JSXClosingElement = JSXClosingElement;
			var JSXElement = function () {
				function JSXElement(openingElement, children, closingElement) {
					this.type = jsx_syntax_1.JSXSyntax.JSXElement;
					this.openingElement = openingElement;
					this.children = children;
					this.closingElement = closingElement;
				}
				return JSXElement;
			}();
			exports.JSXElement = JSXElement;
			var JSXEmptyExpression = function () {
				function JSXEmptyExpression() {
					this.type = jsx_syntax_1.JSXSyntax.JSXEmptyExpression;
				}
				return JSXEmptyExpression;
			}();
			exports.JSXEmptyExpression = JSXEmptyExpression;
			var JSXExpressionContainer = function () {
				function JSXExpressionContainer(expression) {
					this.type = jsx_syntax_1.JSXSyntax.JSXExpressionContainer;
					this.expression = expression;
				}
				return JSXExpressionContainer;
			}();
			exports.JSXExpressionContainer = JSXExpressionContainer;
			var JSXIdentifier = function () {
				function JSXIdentifier(name) {
					this.type = jsx_syntax_1.JSXSyntax.JSXIdentifier;
					this.name = name;
				}
				return JSXIdentifier;
			}();
			exports.JSXIdentifier = JSXIdentifier;
			var JSXMemberExpression = function () {
				function JSXMemberExpression(object, property) {
					this.type = jsx_syntax_1.JSXSyntax.JSXMemberExpression;
					this.object = object;
					this.property = property;
				}
				return JSXMemberExpression;
			}();
			exports.JSXMemberExpression = JSXMemberExpression;
			var JSXAttribute = function () {
				function JSXAttribute(name, value) {
					this.type = jsx_syntax_1.JSXSyntax.JSXAttribute;
					this.name = name;
					this.value = value;
				}
				return JSXAttribute;
			}();
			exports.JSXAttribute = JSXAttribute;
			var JSXNamespacedName = function () {
				function JSXNamespacedName(namespace, name) {
					this.type = jsx_syntax_1.JSXSyntax.JSXNamespacedName;
					this.namespace = namespace;
					this.name = name;
				}
				return JSXNamespacedName;
			}();
			exports.JSXNamespacedName = JSXNamespacedName;
			var JSXOpeningElement = function () {
				function JSXOpeningElement(name, selfClosing, attributes) {
					this.type = jsx_syntax_1.JSXSyntax.JSXOpeningElement;
					this.name = name;
					this.selfClosing = selfClosing;
					this.attributes = attributes;
				}
				return JSXOpeningElement;
			}();
			exports.JSXOpeningElement = JSXOpeningElement;
			var JSXSpreadAttribute = function () {
				function JSXSpreadAttribute(argument) {
					this.type = jsx_syntax_1.JSXSyntax.JSXSpreadAttribute;
					this.argument = argument;
				}
				return JSXSpreadAttribute;
			}();
			exports.JSXSpreadAttribute = JSXSpreadAttribute;
			var JSXText = function () {
				function JSXText(value, raw) {
					this.type = jsx_syntax_1.JSXSyntax.JSXText;
					this.value = value;
					this.raw = raw;
				}
				return JSXText;
			}();
			exports.JSXText = JSXText;

			/***/
		},
		/* 6 */
		/***/function (module, exports) {

			"use strict";

			Object.defineProperty(exports, "__esModule", { value: true });
			exports.JSXSyntax = {
				JSXAttribute: 'JSXAttribute',
				JSXClosingElement: 'JSXClosingElement',
				JSXElement: 'JSXElement',
				JSXEmptyExpression: 'JSXEmptyExpression',
				JSXExpressionContainer: 'JSXExpressionContainer',
				JSXIdentifier: 'JSXIdentifier',
				JSXMemberExpression: 'JSXMemberExpression',
				JSXNamespacedName: 'JSXNamespacedName',
				JSXOpeningElement: 'JSXOpeningElement',
				JSXSpreadAttribute: 'JSXSpreadAttribute',
				JSXText: 'JSXText'
			};

			/***/
		},
		/* 7 */
		/***/function (module, exports, __webpack_require__) {

			"use strict";

			Object.defineProperty(exports, "__esModule", { value: true });
			var syntax_1 = __webpack_require__(2);
			/* tslint:disable:max-classes-per-file */
			var ArrayExpression = function () {
				function ArrayExpression(elements) {
					this.type = syntax_1.Syntax.ArrayExpression;
					this.elements = elements;
				}
				return ArrayExpression;
			}();
			exports.ArrayExpression = ArrayExpression;
			var ArrayPattern = function () {
				function ArrayPattern(elements) {
					this.type = syntax_1.Syntax.ArrayPattern;
					this.elements = elements;
				}
				return ArrayPattern;
			}();
			exports.ArrayPattern = ArrayPattern;
			var ArrowFunctionExpression = function () {
				function ArrowFunctionExpression(params, body, expression) {
					this.type = syntax_1.Syntax.ArrowFunctionExpression;
					this.id = null;
					this.params = params;
					this.body = body;
					this.generator = false;
					this.expression = expression;
					this.async = false;
				}
				return ArrowFunctionExpression;
			}();
			exports.ArrowFunctionExpression = ArrowFunctionExpression;
			var AssignmentExpression = function () {
				function AssignmentExpression(operator, left, right) {
					this.type = syntax_1.Syntax.AssignmentExpression;
					this.operator = operator;
					this.left = left;
					this.right = right;
				}
				return AssignmentExpression;
			}();
			exports.AssignmentExpression = AssignmentExpression;
			var AssignmentPattern = function () {
				function AssignmentPattern(left, right) {
					this.type = syntax_1.Syntax.AssignmentPattern;
					this.left = left;
					this.right = right;
				}
				return AssignmentPattern;
			}();
			exports.AssignmentPattern = AssignmentPattern;
			var AsyncArrowFunctionExpression = function () {
				function AsyncArrowFunctionExpression(params, body, expression) {
					this.type = syntax_1.Syntax.ArrowFunctionExpression;
					this.id = null;
					this.params = params;
					this.body = body;
					this.generator = false;
					this.expression = expression;
					this.async = true;
				}
				return AsyncArrowFunctionExpression;
			}();
			exports.AsyncArrowFunctionExpression = AsyncArrowFunctionExpression;
			var AsyncFunctionDeclaration = function () {
				function AsyncFunctionDeclaration(id, params, body) {
					this.type = syntax_1.Syntax.FunctionDeclaration;
					this.id = id;
					this.params = params;
					this.body = body;
					this.generator = false;
					this.expression = false;
					this.async = true;
				}
				return AsyncFunctionDeclaration;
			}();
			exports.AsyncFunctionDeclaration = AsyncFunctionDeclaration;
			var AsyncFunctionExpression = function () {
				function AsyncFunctionExpression(id, params, body) {
					this.type = syntax_1.Syntax.FunctionExpression;
					this.id = id;
					this.params = params;
					this.body = body;
					this.generator = false;
					this.expression = false;
					this.async = true;
				}
				return AsyncFunctionExpression;
			}();
			exports.AsyncFunctionExpression = AsyncFunctionExpression;
			var AwaitExpression = function () {
				function AwaitExpression(argument) {
					this.type = syntax_1.Syntax.AwaitExpression;
					this.argument = argument;
				}
				return AwaitExpression;
			}();
			exports.AwaitExpression = AwaitExpression;
			var BinaryExpression = function () {
				function BinaryExpression(operator, left, right) {
					var logical = operator === '||' || operator === '&&';
					this.type = logical ? syntax_1.Syntax.LogicalExpression : syntax_1.Syntax.BinaryExpression;
					this.operator = operator;
					this.left = left;
					this.right = right;
				}
				return BinaryExpression;
			}();
			exports.BinaryExpression = BinaryExpression;
			var BlockStatement = function () {
				function BlockStatement(body) {
					this.type = syntax_1.Syntax.BlockStatement;
					this.body = body;
				}
				return BlockStatement;
			}();
			exports.BlockStatement = BlockStatement;
			var BreakStatement = function () {
				function BreakStatement(label) {
					this.type = syntax_1.Syntax.BreakStatement;
					this.label = label;
				}
				return BreakStatement;
			}();
			exports.BreakStatement = BreakStatement;
			var CallExpression = function () {
				function CallExpression(callee, args) {
					this.type = syntax_1.Syntax.CallExpression;
					this.callee = callee;
					this.arguments = args;
				}
				return CallExpression;
			}();
			exports.CallExpression = CallExpression;
			var CatchClause = function () {
				function CatchClause(param, body) {
					this.type = syntax_1.Syntax.CatchClause;
					this.param = param;
					this.body = body;
				}
				return CatchClause;
			}();
			exports.CatchClause = CatchClause;
			var ClassBody = function () {
				function ClassBody(body) {
					this.type = syntax_1.Syntax.ClassBody;
					this.body = body;
				}
				return ClassBody;
			}();
			exports.ClassBody = ClassBody;
			var ClassDeclaration = function () {
				function ClassDeclaration(id, superClass, body) {
					this.type = syntax_1.Syntax.ClassDeclaration;
					this.id = id;
					this.superClass = superClass;
					this.body = body;
				}
				return ClassDeclaration;
			}();
			exports.ClassDeclaration = ClassDeclaration;
			var ClassExpression = function () {
				function ClassExpression(id, superClass, body) {
					this.type = syntax_1.Syntax.ClassExpression;
					this.id = id;
					this.superClass = superClass;
					this.body = body;
				}
				return ClassExpression;
			}();
			exports.ClassExpression = ClassExpression;
			var ComputedMemberExpression = function () {
				function ComputedMemberExpression(object, property) {
					this.type = syntax_1.Syntax.MemberExpression;
					this.computed = true;
					this.object = object;
					this.property = property;
				}
				return ComputedMemberExpression;
			}();
			exports.ComputedMemberExpression = ComputedMemberExpression;
			var ConditionalExpression = function () {
				function ConditionalExpression(test, consequent, alternate) {
					this.type = syntax_1.Syntax.ConditionalExpression;
					this.test = test;
					this.consequent = consequent;
					this.alternate = alternate;
				}
				return ConditionalExpression;
			}();
			exports.ConditionalExpression = ConditionalExpression;
			var ContinueStatement = function () {
				function ContinueStatement(label) {
					this.type = syntax_1.Syntax.ContinueStatement;
					this.label = label;
				}
				return ContinueStatement;
			}();
			exports.ContinueStatement = ContinueStatement;
			var DebuggerStatement = function () {
				function DebuggerStatement() {
					this.type = syntax_1.Syntax.DebuggerStatement;
				}
				return DebuggerStatement;
			}();
			exports.DebuggerStatement = DebuggerStatement;
			var Directive = function () {
				function Directive(expression, directive) {
					this.type = syntax_1.Syntax.ExpressionStatement;
					this.expression = expression;
					this.directive = directive;
				}
				return Directive;
			}();
			exports.Directive = Directive;
			var DoWhileStatement = function () {
				function DoWhileStatement(body, test) {
					this.type = syntax_1.Syntax.DoWhileStatement;
					this.body = body;
					this.test = test;
				}
				return DoWhileStatement;
			}();
			exports.DoWhileStatement = DoWhileStatement;
			var EmptyStatement = function () {
				function EmptyStatement() {
					this.type = syntax_1.Syntax.EmptyStatement;
				}
				return EmptyStatement;
			}();
			exports.EmptyStatement = EmptyStatement;
			var ExportAllDeclaration = function () {
				function ExportAllDeclaration(source) {
					this.type = syntax_1.Syntax.ExportAllDeclaration;
					this.source = source;
				}
				return ExportAllDeclaration;
			}();
			exports.ExportAllDeclaration = ExportAllDeclaration;
			var ExportDefaultDeclaration = function () {
				function ExportDefaultDeclaration(declaration) {
					this.type = syntax_1.Syntax.ExportDefaultDeclaration;
					this.declaration = declaration;
				}
				return ExportDefaultDeclaration;
			}();
			exports.ExportDefaultDeclaration = ExportDefaultDeclaration;
			var ExportNamedDeclaration = function () {
				function ExportNamedDeclaration(declaration, specifiers, source) {
					this.type = syntax_1.Syntax.ExportNamedDeclaration;
					this.declaration = declaration;
					this.specifiers = specifiers;
					this.source = source;
				}
				return ExportNamedDeclaration;
			}();
			exports.ExportNamedDeclaration = ExportNamedDeclaration;
			var ExportSpecifier = function () {
				function ExportSpecifier(local, exported) {
					this.type = syntax_1.Syntax.ExportSpecifier;
					this.exported = exported;
					this.local = local;
				}
				return ExportSpecifier;
			}();
			exports.ExportSpecifier = ExportSpecifier;
			var ExpressionStatement = function () {
				function ExpressionStatement(expression) {
					this.type = syntax_1.Syntax.ExpressionStatement;
					this.expression = expression;
				}
				return ExpressionStatement;
			}();
			exports.ExpressionStatement = ExpressionStatement;
			var ForInStatement = function () {
				function ForInStatement(left, right, body) {
					this.type = syntax_1.Syntax.ForInStatement;
					this.left = left;
					this.right = right;
					this.body = body;
					this.each = false;
				}
				return ForInStatement;
			}();
			exports.ForInStatement = ForInStatement;
			var ForOfStatement = function () {
				function ForOfStatement(left, right, body) {
					this.type = syntax_1.Syntax.ForOfStatement;
					this.left = left;
					this.right = right;
					this.body = body;
				}
				return ForOfStatement;
			}();
			exports.ForOfStatement = ForOfStatement;
			var ForStatement = function () {
				function ForStatement(init, test, update, body) {
					this.type = syntax_1.Syntax.ForStatement;
					this.init = init;
					this.test = test;
					this.update = update;
					this.body = body;
				}
				return ForStatement;
			}();
			exports.ForStatement = ForStatement;
			var FunctionDeclaration = function () {
				function FunctionDeclaration(id, params, body, generator) {
					this.type = syntax_1.Syntax.FunctionDeclaration;
					this.id = id;
					this.params = params;
					this.body = body;
					this.generator = generator;
					this.expression = false;
					this.async = false;
				}
				return FunctionDeclaration;
			}();
			exports.FunctionDeclaration = FunctionDeclaration;
			var FunctionExpression = function () {
				function FunctionExpression(id, params, body, generator) {
					this.type = syntax_1.Syntax.FunctionExpression;
					this.id = id;
					this.params = params;
					this.body = body;
					this.generator = generator;
					this.expression = false;
					this.async = false;
				}
				return FunctionExpression;
			}();
			exports.FunctionExpression = FunctionExpression;
			var Identifier = function () {
				function Identifier(name) {
					this.type = syntax_1.Syntax.Identifier;
					this.name = name;
				}
				return Identifier;
			}();
			exports.Identifier = Identifier;
			var IfStatement = function () {
				function IfStatement(test, consequent, alternate) {
					this.type = syntax_1.Syntax.IfStatement;
					this.test = test;
					this.consequent = consequent;
					this.alternate = alternate;
				}
				return IfStatement;
			}();
			exports.IfStatement = IfStatement;
			var ImportDeclaration = function () {
				function ImportDeclaration(specifiers, source) {
					this.type = syntax_1.Syntax.ImportDeclaration;
					this.specifiers = specifiers;
					this.source = source;
				}
				return ImportDeclaration;
			}();
			exports.ImportDeclaration = ImportDeclaration;
			var ImportDefaultSpecifier = function () {
				function ImportDefaultSpecifier(local) {
					this.type = syntax_1.Syntax.ImportDefaultSpecifier;
					this.local = local;
				}
				return ImportDefaultSpecifier;
			}();
			exports.ImportDefaultSpecifier = ImportDefaultSpecifier;
			var ImportNamespaceSpecifier = function () {
				function ImportNamespaceSpecifier(local) {
					this.type = syntax_1.Syntax.ImportNamespaceSpecifier;
					this.local = local;
				}
				return ImportNamespaceSpecifier;
			}();
			exports.ImportNamespaceSpecifier = ImportNamespaceSpecifier;
			var ImportSpecifier = function () {
				function ImportSpecifier(local, imported) {
					this.type = syntax_1.Syntax.ImportSpecifier;
					this.local = local;
					this.imported = imported;
				}
				return ImportSpecifier;
			}();
			exports.ImportSpecifier = ImportSpecifier;
			var LabeledStatement = function () {
				function LabeledStatement(label, body) {
					this.type = syntax_1.Syntax.LabeledStatement;
					this.label = label;
					this.body = body;
				}
				return LabeledStatement;
			}();
			exports.LabeledStatement = LabeledStatement;
			var Literal = function () {
				function Literal(value, raw) {
					this.type = syntax_1.Syntax.Literal;
					this.value = value;
					this.raw = raw;
				}
				return Literal;
			}();
			exports.Literal = Literal;
			var MetaProperty = function () {
				function MetaProperty(meta, property) {
					this.type = syntax_1.Syntax.MetaProperty;
					this.meta = meta;
					this.property = property;
				}
				return MetaProperty;
			}();
			exports.MetaProperty = MetaProperty;
			var MethodDefinition = function () {
				function MethodDefinition(key, computed, value, kind, isStatic) {
					this.type = syntax_1.Syntax.MethodDefinition;
					this.key = key;
					this.computed = computed;
					this.value = value;
					this.kind = kind;
					this.static = isStatic;
				}
				return MethodDefinition;
			}();
			exports.MethodDefinition = MethodDefinition;
			var Module = function () {
				function Module(body) {
					this.type = syntax_1.Syntax.Program;
					this.body = body;
					this.sourceType = 'module';
				}
				return Module;
			}();
			exports.Module = Module;
			var NewExpression = function () {
				function NewExpression(callee, args) {
					this.type = syntax_1.Syntax.NewExpression;
					this.callee = callee;
					this.arguments = args;
				}
				return NewExpression;
			}();
			exports.NewExpression = NewExpression;
			var ObjectExpression = function () {
				function ObjectExpression(properties) {
					this.type = syntax_1.Syntax.ObjectExpression;
					this.properties = properties;
				}
				return ObjectExpression;
			}();
			exports.ObjectExpression = ObjectExpression;
			var ObjectPattern = function () {
				function ObjectPattern(properties) {
					this.type = syntax_1.Syntax.ObjectPattern;
					this.properties = properties;
				}
				return ObjectPattern;
			}();
			exports.ObjectPattern = ObjectPattern;
			var Property = function () {
				function Property(kind, key, computed, value, method, shorthand) {
					this.type = syntax_1.Syntax.Property;
					this.key = key;
					this.computed = computed;
					this.value = value;
					this.kind = kind;
					this.method = method;
					this.shorthand = shorthand;
				}
				return Property;
			}();
			exports.Property = Property;
			var RegexLiteral = function () {
				function RegexLiteral(value, raw, pattern, flags) {
					this.type = syntax_1.Syntax.Literal;
					this.value = value;
					this.raw = raw;
					this.regex = { pattern: pattern, flags: flags };
				}
				return RegexLiteral;
			}();
			exports.RegexLiteral = RegexLiteral;
			var RestElement = function () {
				function RestElement(argument) {
					this.type = syntax_1.Syntax.RestElement;
					this.argument = argument;
				}
				return RestElement;
			}();
			exports.RestElement = RestElement;
			var ReturnStatement = function () {
				function ReturnStatement(argument) {
					this.type = syntax_1.Syntax.ReturnStatement;
					this.argument = argument;
				}
				return ReturnStatement;
			}();
			exports.ReturnStatement = ReturnStatement;
			var Script = function () {
				function Script(body) {
					this.type = syntax_1.Syntax.Program;
					this.body = body;
					this.sourceType = 'script';
				}
				return Script;
			}();
			exports.Script = Script;
			var SequenceExpression = function () {
				function SequenceExpression(expressions) {
					this.type = syntax_1.Syntax.SequenceExpression;
					this.expressions = expressions;
				}
				return SequenceExpression;
			}();
			exports.SequenceExpression = SequenceExpression;
			var SpreadElement = function () {
				function SpreadElement(argument) {
					this.type = syntax_1.Syntax.SpreadElement;
					this.argument = argument;
				}
				return SpreadElement;
			}();
			exports.SpreadElement = SpreadElement;
			var StaticMemberExpression = function () {
				function StaticMemberExpression(object, property) {
					this.type = syntax_1.Syntax.MemberExpression;
					this.computed = false;
					this.object = object;
					this.property = property;
				}
				return StaticMemberExpression;
			}();
			exports.StaticMemberExpression = StaticMemberExpression;
			var Super = function () {
				function Super() {
					this.type = syntax_1.Syntax.Super;
				}
				return Super;
			}();
			exports.Super = Super;
			var SwitchCase = function () {
				function SwitchCase(test, consequent) {
					this.type = syntax_1.Syntax.SwitchCase;
					this.test = test;
					this.consequent = consequent;
				}
				return SwitchCase;
			}();
			exports.SwitchCase = SwitchCase;
			var SwitchStatement = function () {
				function SwitchStatement(discriminant, cases) {
					this.type = syntax_1.Syntax.SwitchStatement;
					this.discriminant = discriminant;
					this.cases = cases;
				}
				return SwitchStatement;
			}();
			exports.SwitchStatement = SwitchStatement;
			var TaggedTemplateExpression = function () {
				function TaggedTemplateExpression(tag, quasi) {
					this.type = syntax_1.Syntax.TaggedTemplateExpression;
					this.tag = tag;
					this.quasi = quasi;
				}
				return TaggedTemplateExpression;
			}();
			exports.TaggedTemplateExpression = TaggedTemplateExpression;
			var TemplateElement = function () {
				function TemplateElement(value, tail) {
					this.type = syntax_1.Syntax.TemplateElement;
					this.value = value;
					this.tail = tail;
				}
				return TemplateElement;
			}();
			exports.TemplateElement = TemplateElement;
			var TemplateLiteral = function () {
				function TemplateLiteral(quasis, expressions) {
					this.type = syntax_1.Syntax.TemplateLiteral;
					this.quasis = quasis;
					this.expressions = expressions;
				}
				return TemplateLiteral;
			}();
			exports.TemplateLiteral = TemplateLiteral;
			var ThisExpression = function () {
				function ThisExpression() {
					this.type = syntax_1.Syntax.ThisExpression;
				}
				return ThisExpression;
			}();
			exports.ThisExpression = ThisExpression;
			var ThrowStatement = function () {
				function ThrowStatement(argument) {
					this.type = syntax_1.Syntax.ThrowStatement;
					this.argument = argument;
				}
				return ThrowStatement;
			}();
			exports.ThrowStatement = ThrowStatement;
			var TryStatement = function () {
				function TryStatement(block, handler, finalizer) {
					this.type = syntax_1.Syntax.TryStatement;
					this.block = block;
					this.handler = handler;
					this.finalizer = finalizer;
				}
				return TryStatement;
			}();
			exports.TryStatement = TryStatement;
			var UnaryExpression = function () {
				function UnaryExpression(operator, argument) {
					this.type = syntax_1.Syntax.UnaryExpression;
					this.operator = operator;
					this.argument = argument;
					this.prefix = true;
				}
				return UnaryExpression;
			}();
			exports.UnaryExpression = UnaryExpression;
			var UpdateExpression = function () {
				function UpdateExpression(operator, argument, prefix) {
					this.type = syntax_1.Syntax.UpdateExpression;
					this.operator = operator;
					this.argument = argument;
					this.prefix = prefix;
				}
				return UpdateExpression;
			}();
			exports.UpdateExpression = UpdateExpression;
			var VariableDeclaration = function () {
				function VariableDeclaration(declarations, kind) {
					this.type = syntax_1.Syntax.VariableDeclaration;
					this.declarations = declarations;
					this.kind = kind;
				}
				return VariableDeclaration;
			}();
			exports.VariableDeclaration = VariableDeclaration;
			var VariableDeclarator = function () {
				function VariableDeclarator(id, init) {
					this.type = syntax_1.Syntax.VariableDeclarator;
					this.id = id;
					this.init = init;
				}
				return VariableDeclarator;
			}();
			exports.VariableDeclarator = VariableDeclarator;
			var WhileStatement = function () {
				function WhileStatement(test, body) {
					this.type = syntax_1.Syntax.WhileStatement;
					this.test = test;
					this.body = body;
				}
				return WhileStatement;
			}();
			exports.WhileStatement = WhileStatement;
			var WithStatement = function () {
				function WithStatement(object, body) {
					this.type = syntax_1.Syntax.WithStatement;
					this.object = object;
					this.body = body;
				}
				return WithStatement;
			}();
			exports.WithStatement = WithStatement;
			var YieldExpression = function () {
				function YieldExpression(argument, delegate) {
					this.type = syntax_1.Syntax.YieldExpression;
					this.argument = argument;
					this.delegate = delegate;
				}
				return YieldExpression;
			}();
			exports.YieldExpression = YieldExpression;

			/***/
		},
		/* 8 */
		/***/function (module, exports, __webpack_require__) {

			"use strict";

			Object.defineProperty(exports, "__esModule", { value: true });
			var assert_1 = __webpack_require__(9);
			var error_handler_1 = __webpack_require__(10);
			var messages_1 = __webpack_require__(11);
			var Node = __webpack_require__(7);
			var scanner_1 = __webpack_require__(12);
			var syntax_1 = __webpack_require__(2);
			var token_1 = __webpack_require__(13);
			var ArrowParameterPlaceHolder = 'ArrowParameterPlaceHolder';
			var Parser = function () {
				function Parser(code, options, delegate) {
					if (options === void 0) {
						options = {};
					}
					this.config = {
						range: typeof options.range === 'boolean' && options.range,
						loc: typeof options.loc === 'boolean' && options.loc,
						source: null,
						tokens: typeof options.tokens === 'boolean' && options.tokens,
						comment: typeof options.comment === 'boolean' && options.comment,
						tolerant: typeof options.tolerant === 'boolean' && options.tolerant
					};
					if (this.config.loc && options.source && options.source !== null) {
						this.config.source = String(options.source);
					}
					this.delegate = delegate;
					this.errorHandler = new error_handler_1.ErrorHandler();
					this.errorHandler.tolerant = this.config.tolerant;
					this.scanner = new scanner_1.Scanner(code, this.errorHandler);
					this.scanner.trackComment = this.config.comment;
					this.operatorPrecedence = {
						')': 0,
						';': 0,
						',': 0,
						'=': 0,
						']': 0,
						'||': 1,
						'&&': 2,
						'|': 3,
						'^': 4,
						'&': 5,
						'==': 6,
						'!=': 6,
						'===': 6,
						'!==': 6,
						'<': 7,
						'>': 7,
						'<=': 7,
						'>=': 7,
						'<<': 8,
						'>>': 8,
						'>>>': 8,
						'+': 9,
						'-': 9,
						'*': 11,
						'/': 11,
						'%': 11
					};
					this.lookahead = {
						type: 2 /* EOF */
						, value: '',
						lineNumber: this.scanner.lineNumber,
						lineStart: 0,
						start: 0,
						end: 0
					};
					this.hasLineTerminator = false;
					this.context = {
						isModule: false,
						await: false,
						allowIn: true,
						allowStrictDirective: true,
						allowYield: true,
						firstCoverInitializedNameError: null,
						isAssignmentTarget: false,
						isBindingElement: false,
						inFunctionBody: false,
						inIteration: false,
						inSwitch: false,
						labelSet: {},
						strict: false
					};
					this.tokens = [];
					this.startMarker = {
						index: 0,
						line: this.scanner.lineNumber,
						column: 0
					};
					this.lastMarker = {
						index: 0,
						line: this.scanner.lineNumber,
						column: 0
					};
					this.nextToken();
					this.lastMarker = {
						index: this.scanner.index,
						line: this.scanner.lineNumber,
						column: this.scanner.index - this.scanner.lineStart
					};
				}
				Parser.prototype.throwError = function (messageFormat) {
					var values = [];
					for (var _i = 1; _i < arguments.length; _i++) {
						values[_i - 1] = arguments[_i];
					}
					var args = Array.prototype.slice.call(arguments, 1);
					var msg = messageFormat.replace(/%(\d)/g, function (whole, idx) {
						assert_1.assert(idx < args.length, 'Message reference must be in range');
						return args[idx];
					});
					var index = this.lastMarker.index;
					var line = this.lastMarker.line;
					var column = this.lastMarker.column + 1;
					throw this.errorHandler.createError(index, line, column, msg);
				};
				Parser.prototype.tolerateError = function (messageFormat) {
					var values = [];
					for (var _i = 1; _i < arguments.length; _i++) {
						values[_i - 1] = arguments[_i];
					}
					var args = Array.prototype.slice.call(arguments, 1);
					var msg = messageFormat.replace(/%(\d)/g, function (whole, idx) {
						assert_1.assert(idx < args.length, 'Message reference must be in range');
						return args[idx];
					});
					var index = this.lastMarker.index;
					var line = this.scanner.lineNumber;
					var column = this.lastMarker.column + 1;
					this.errorHandler.tolerateError(index, line, column, msg);
				};
				// Throw an exception because of the token.
				Parser.prototype.unexpectedTokenError = function (token, message) {
					var msg = message || messages_1.Messages.UnexpectedToken;
					var value;
					if (token) {
						if (!message) {
							msg = token.type === 2 /* EOF */ ? messages_1.Messages.UnexpectedEOS : token.type === 3 /* Identifier */ ? messages_1.Messages.UnexpectedIdentifier : token.type === 6 /* NumericLiteral */ ? messages_1.Messages.UnexpectedNumber : token.type === 8 /* StringLiteral */ ? messages_1.Messages.UnexpectedString : token.type === 10 /* Template */ ? messages_1.Messages.UnexpectedTemplate : messages_1.Messages.UnexpectedToken;
							if (token.type === 4 /* Keyword */) {
									if (this.scanner.isFutureReservedWord(token.value)) {
										msg = messages_1.Messages.UnexpectedReserved;
									} else if (this.context.strict && this.scanner.isStrictModeReservedWord(token.value)) {
										msg = messages_1.Messages.StrictReservedWord;
									}
								}
						}
						value = token.value;
					} else {
						value = 'ILLEGAL';
					}
					msg = msg.replace('%0', value);
					if (token && typeof token.lineNumber === 'number') {
						var index = token.start;
						var line = token.lineNumber;
						var lastMarkerLineStart = this.lastMarker.index - this.lastMarker.column;
						var column = token.start - lastMarkerLineStart + 1;
						return this.errorHandler.createError(index, line, column, msg);
					} else {
						var index = this.lastMarker.index;
						var line = this.lastMarker.line;
						var column = this.lastMarker.column + 1;
						return this.errorHandler.createError(index, line, column, msg);
					}
				};
				Parser.prototype.throwUnexpectedToken = function (token, message) {
					throw this.unexpectedTokenError(token, message);
				};
				Parser.prototype.tolerateUnexpectedToken = function (token, message) {
					this.errorHandler.tolerate(this.unexpectedTokenError(token, message));
				};
				Parser.prototype.collectComments = function () {
					if (!this.config.comment) {
						this.scanner.scanComments();
					} else {
						var comments = this.scanner.scanComments();
						if (comments.length > 0 && this.delegate) {
							for (var i = 0; i < comments.length; ++i) {
								var e = comments[i];
								var node = void 0;
								node = {
									type: e.multiLine ? 'BlockComment' : 'LineComment',
									value: this.scanner.source.slice(e.slice[0], e.slice[1])
								};
								if (this.config.range) {
									node.range = e.range;
								}
								if (this.config.loc) {
									node.loc = e.loc;
								}
								var metadata = {
									start: {
										line: e.loc.start.line,
										column: e.loc.start.column,
										offset: e.range[0]
									},
									end: {
										line: e.loc.end.line,
										column: e.loc.end.column,
										offset: e.range[1]
									}
								};
								this.delegate(node, metadata);
							}
						}
					}
				};
				// From internal representation to an external structure
				Parser.prototype.getTokenRaw = function (token) {
					return this.scanner.source.slice(token.start, token.end);
				};
				Parser.prototype.convertToken = function (token) {
					var t = {
						type: token_1.TokenName[token.type],
						value: this.getTokenRaw(token)
					};
					if (this.config.range) {
						t.range = [token.start, token.end];
					}
					if (this.config.loc) {
						t.loc = {
							start: {
								line: this.startMarker.line,
								column: this.startMarker.column
							},
							end: {
								line: this.scanner.lineNumber,
								column: this.scanner.index - this.scanner.lineStart
							}
						};
					}
					if (token.type === 9 /* RegularExpression */) {
							var pattern = token.pattern;
							var flags = token.flags;
							t.regex = { pattern: pattern, flags: flags };
						}
					return t;
				};
				Parser.prototype.nextToken = function () {
					var token = this.lookahead;
					this.lastMarker.index = this.scanner.index;
					this.lastMarker.line = this.scanner.lineNumber;
					this.lastMarker.column = this.scanner.index - this.scanner.lineStart;
					this.collectComments();
					if (this.scanner.index !== this.startMarker.index) {
						this.startMarker.index = this.scanner.index;
						this.startMarker.line = this.scanner.lineNumber;
						this.startMarker.column = this.scanner.index - this.scanner.lineStart;
					}
					var next = this.scanner.lex();
					this.hasLineTerminator = token.lineNumber !== next.lineNumber;
					if (next && this.context.strict && next.type === 3 /* Identifier */) {
							if (this.scanner.isStrictModeReservedWord(next.value)) {
								next.type = 4 /* Keyword */;
							}
						}
					this.lookahead = next;
					if (this.config.tokens && next.type !== 2 /* EOF */) {
							this.tokens.push(this.convertToken(next));
						}
					return token;
				};
				Parser.prototype.nextRegexToken = function () {
					this.collectComments();
					var token = this.scanner.scanRegExp();
					if (this.config.tokens) {
						// Pop the previous token, '/' or '/='
						// This is added from the lookahead token.
						this.tokens.pop();
						this.tokens.push(this.convertToken(token));
					}
					// Prime the next lookahead.
					this.lookahead = token;
					this.nextToken();
					return token;
				};
				Parser.prototype.createNode = function () {
					return {
						index: this.startMarker.index,
						line: this.startMarker.line,
						column: this.startMarker.column
					};
				};
				Parser.prototype.startNode = function (token) {
					return {
						index: token.start,
						line: token.lineNumber,
						column: token.start - token.lineStart
					};
				};
				Parser.prototype.finalize = function (marker, node) {
					if (this.config.range) {
						node.range = [marker.index, this.lastMarker.index];
					}
					if (this.config.loc) {
						node.loc = {
							start: {
								line: marker.line,
								column: marker.column
							},
							end: {
								line: this.lastMarker.line,
								column: this.lastMarker.column
							}
						};
						if (this.config.source) {
							node.loc.source = this.config.source;
						}
					}
					if (this.delegate) {
						var metadata = {
							start: {
								line: marker.line,
								column: marker.column,
								offset: marker.index
							},
							end: {
								line: this.lastMarker.line,
								column: this.lastMarker.column,
								offset: this.lastMarker.index
							}
						};
						this.delegate(node, metadata);
					}
					return node;
				};
				// Expect the next token to match the specified punctuator.
				// If not, an exception will be thrown.
				Parser.prototype.expect = function (value) {
					var token = this.nextToken();
					if (token.type !== 7 /* Punctuator */ || token.value !== value) {
						this.throwUnexpectedToken(token);
					}
				};
				// Quietly expect a comma when in tolerant mode, otherwise delegates to expect().
				Parser.prototype.expectCommaSeparator = function () {
					if (this.config.tolerant) {
						var token = this.lookahead;
						if (token.type === 7 /* Punctuator */ && token.value === ',') {
							this.nextToken();
						} else if (token.type === 7 /* Punctuator */ && token.value === ';') {
							this.nextToken();
							this.tolerateUnexpectedToken(token);
						} else {
							this.tolerateUnexpectedToken(token, messages_1.Messages.UnexpectedToken);
						}
					} else {
						this.expect(',');
					}
				};
				// Expect the next token to match the specified keyword.
				// If not, an exception will be thrown.
				Parser.prototype.expectKeyword = function (keyword) {
					var token = this.nextToken();
					if (token.type !== 4 /* Keyword */ || token.value !== keyword) {
						this.throwUnexpectedToken(token);
					}
				};
				// Return true if the next token matches the specified punctuator.
				Parser.prototype.match = function (value) {
					return this.lookahead.type === 7 /* Punctuator */ && this.lookahead.value === value;
				};
				// Return true if the next token matches the specified keyword
				Parser.prototype.matchKeyword = function (keyword) {
					return this.lookahead.type === 4 /* Keyword */ && this.lookahead.value === keyword;
				};
				// Return true if the next token matches the specified contextual keyword
				// (where an identifier is sometimes a keyword depending on the context)
				Parser.prototype.matchContextualKeyword = function (keyword) {
					return this.lookahead.type === 3 /* Identifier */ && this.lookahead.value === keyword;
				};
				// Return true if the next token is an assignment operator
				Parser.prototype.matchAssign = function () {
					if (this.lookahead.type !== 7 /* Punctuator */) {
							return false;
						}
					var op = this.lookahead.value;
					return op === '=' || op === '*=' || op === '**=' || op === '/=' || op === '%=' || op === '+=' || op === '-=' || op === '<<=' || op === '>>=' || op === '>>>=' || op === '&=' || op === '^=' || op === '|=';
				};
				// Cover grammar support.
				//
				// When an assignment expression position starts with an left parenthesis, the determination of the type
				// of the syntax is to be deferred arbitrarily long until the end of the parentheses pair (plus a lookahead)
				// or the first comma. This situation also defers the determination of all the expressions nested in the pair.
				//
				// There are three productions that can be parsed in a parentheses pair that needs to be determined
				// after the outermost pair is closed. They are:
				//
				//   1. AssignmentExpression
				//   2. BindingElements
				//   3. AssignmentTargets
				//
				// In order to avoid exponential backtracking, we use two flags to denote if the production can be
				// binding element or assignment target.
				//
				// The three productions have the relationship:
				//
				//   BindingElements  AssignmentTargets  AssignmentExpression
				//
				// with a single exception that CoverInitializedName when used directly in an Expression, generates
				// an early error. Therefore, we need the third state, firstCoverInitializedNameError, to track the
				// first usage of CoverInitializedName and report it when we reached the end of the parentheses pair.
				//
				// isolateCoverGrammar function runs the given parser function with a new cover grammar context, and it does not
				// effect the current flags. This means the production the parser parses is only used as an expression. Therefore
				// the CoverInitializedName check is conducted.
				//
				// inheritCoverGrammar function runs the given parse function with a new cover grammar context, and it propagates
				// the flags outside of the parser. This means the production the parser parses is used as a part of a potential
				// pattern. The CoverInitializedName check is deferred.
				Parser.prototype.isolateCoverGrammar = function (parseFunction) {
					var previousIsBindingElement = this.context.isBindingElement;
					var previousIsAssignmentTarget = this.context.isAssignmentTarget;
					var previousFirstCoverInitializedNameError = this.context.firstCoverInitializedNameError;
					this.context.isBindingElement = true;
					this.context.isAssignmentTarget = true;
					this.context.firstCoverInitializedNameError = null;
					var result = parseFunction.call(this);
					if (this.context.firstCoverInitializedNameError !== null) {
						this.throwUnexpectedToken(this.context.firstCoverInitializedNameError);
					}
					this.context.isBindingElement = previousIsBindingElement;
					this.context.isAssignmentTarget = previousIsAssignmentTarget;
					this.context.firstCoverInitializedNameError = previousFirstCoverInitializedNameError;
					return result;
				};
				Parser.prototype.inheritCoverGrammar = function (parseFunction) {
					var previousIsBindingElement = this.context.isBindingElement;
					var previousIsAssignmentTarget = this.context.isAssignmentTarget;
					var previousFirstCoverInitializedNameError = this.context.firstCoverInitializedNameError;
					this.context.isBindingElement = true;
					this.context.isAssignmentTarget = true;
					this.context.firstCoverInitializedNameError = null;
					var result = parseFunction.call(this);
					this.context.isBindingElement = this.context.isBindingElement && previousIsBindingElement;
					this.context.isAssignmentTarget = this.context.isAssignmentTarget && previousIsAssignmentTarget;
					this.context.firstCoverInitializedNameError = previousFirstCoverInitializedNameError || this.context.firstCoverInitializedNameError;
					return result;
				};
				Parser.prototype.consumeSemicolon = function () {
					if (this.match(';')) {
						this.nextToken();
					} else if (!this.hasLineTerminator) {
						if (this.lookahead.type !== 2 /* EOF */ && !this.match('}')) {
							this.throwUnexpectedToken(this.lookahead);
						}
						this.lastMarker.index = this.startMarker.index;
						this.lastMarker.line = this.startMarker.line;
						this.lastMarker.column = this.startMarker.column;
					}
				};
				// https://tc39.github.io/ecma262/#sec-primary-expression
				Parser.prototype.parsePrimaryExpression = function () {
					var node = this.createNode();
					var expr;
					var token, raw;
					switch (this.lookahead.type) {
						case 3 /* Identifier */:
							if ((this.context.isModule || this.context.await) && this.lookahead.value === 'await') {
								this.tolerateUnexpectedToken(this.lookahead);
							}
							expr = this.matchAsyncFunction() ? this.parseFunctionExpression() : this.finalize(node, new Node.Identifier(this.nextToken().value));
							break;
						case 6 /* NumericLiteral */:
						case 8 /* StringLiteral */:
							if (this.context.strict && this.lookahead.octal) {
								this.tolerateUnexpectedToken(this.lookahead, messages_1.Messages.StrictOctalLiteral);
							}
							this.context.isAssignmentTarget = false;
							this.context.isBindingElement = false;
							token = this.nextToken();
							raw = this.getTokenRaw(token);
							expr = this.finalize(node, new Node.Literal(token.value, raw));
							break;
						case 1 /* BooleanLiteral */:
							this.context.isAssignmentTarget = false;
							this.context.isBindingElement = false;
							token = this.nextToken();
							raw = this.getTokenRaw(token);
							expr = this.finalize(node, new Node.Literal(token.value === 'true', raw));
							break;
						case 5 /* NullLiteral */:
							this.context.isAssignmentTarget = false;
							this.context.isBindingElement = false;
							token = this.nextToken();
							raw = this.getTokenRaw(token);
							expr = this.finalize(node, new Node.Literal(null, raw));
							break;
						case 10 /* Template */:
							expr = this.parseTemplateLiteral();
							break;
						case 7 /* Punctuator */:
							switch (this.lookahead.value) {
								case '(':
									this.context.isBindingElement = false;
									expr = this.inheritCoverGrammar(this.parseGroupExpression);
									break;
								case '[':
									expr = this.inheritCoverGrammar(this.parseArrayInitializer);
									break;
								case '{':
									expr = this.inheritCoverGrammar(this.parseObjectInitializer);
									break;
								case '/':
								case '/=':
									this.context.isAssignmentTarget = false;
									this.context.isBindingElement = false;
									this.scanner.index = this.startMarker.index;
									token = this.nextRegexToken();
									raw = this.getTokenRaw(token);
									expr = this.finalize(node, new Node.RegexLiteral(token.regex, raw, token.pattern, token.flags));
									break;
								default:
									expr = this.throwUnexpectedToken(this.nextToken());
							}
							break;
						case 4 /* Keyword */:
							if (!this.context.strict && this.context.allowYield && this.matchKeyword('yield')) {
								expr = this.parseIdentifierName();
							} else if (!this.context.strict && this.matchKeyword('let')) {
								expr = this.finalize(node, new Node.Identifier(this.nextToken().value));
							} else {
								this.context.isAssignmentTarget = false;
								this.context.isBindingElement = false;
								if (this.matchKeyword('function')) {
									expr = this.parseFunctionExpression();
								} else if (this.matchKeyword('this')) {
									this.nextToken();
									expr = this.finalize(node, new Node.ThisExpression());
								} else if (this.matchKeyword('class')) {
									expr = this.parseClassExpression();
								} else {
									expr = this.throwUnexpectedToken(this.nextToken());
								}
							}
							break;
						default:
							expr = this.throwUnexpectedToken(this.nextToken());
					}
					return expr;
				};
				// https://tc39.github.io/ecma262/#sec-array-initializer
				Parser.prototype.parseSpreadElement = function () {
					var node = this.createNode();
					this.expect('...');
					var arg = this.inheritCoverGrammar(this.parseAssignmentExpression);
					return this.finalize(node, new Node.SpreadElement(arg));
				};
				Parser.prototype.parseArrayInitializer = function () {
					var node = this.createNode();
					var elements = [];
					this.expect('[');
					while (!this.match(']')) {
						if (this.match(',')) {
							this.nextToken();
							elements.push(null);
						} else if (this.match('...')) {
							var element = this.parseSpreadElement();
							if (!this.match(']')) {
								this.context.isAssignmentTarget = false;
								this.context.isBindingElement = false;
								this.expect(',');
							}
							elements.push(element);
						} else {
							elements.push(this.inheritCoverGrammar(this.parseAssignmentExpression));
							if (!this.match(']')) {
								this.expect(',');
							}
						}
					}
					this.expect(']');
					return this.finalize(node, new Node.ArrayExpression(elements));
				};
				// https://tc39.github.io/ecma262/#sec-object-initializer
				Parser.prototype.parsePropertyMethod = function (params) {
					this.context.isAssignmentTarget = false;
					this.context.isBindingElement = false;
					var previousStrict = this.context.strict;
					var previousAllowStrictDirective = this.context.allowStrictDirective;
					this.context.allowStrictDirective = params.simple;
					var body = this.isolateCoverGrammar(this.parseFunctionSourceElements);
					if (this.context.strict && params.firstRestricted) {
						this.tolerateUnexpectedToken(params.firstRestricted, params.message);
					}
					if (this.context.strict && params.stricted) {
						this.tolerateUnexpectedToken(params.stricted, params.message);
					}
					this.context.strict = previousStrict;
					this.context.allowStrictDirective = previousAllowStrictDirective;
					return body;
				};
				Parser.prototype.parsePropertyMethodFunction = function () {
					var isGenerator = false;
					var node = this.createNode();
					var previousAllowYield = this.context.allowYield;
					this.context.allowYield = false;
					var params = this.parseFormalParameters();
					var method = this.parsePropertyMethod(params);
					this.context.allowYield = previousAllowYield;
					return this.finalize(node, new Node.FunctionExpression(null, params.params, method, isGenerator));
				};
				Parser.prototype.parsePropertyMethodAsyncFunction = function () {
					var node = this.createNode();
					var previousAllowYield = this.context.allowYield;
					var previousAwait = this.context.await;
					this.context.allowYield = false;
					this.context.await = true;
					var params = this.parseFormalParameters();
					var method = this.parsePropertyMethod(params);
					this.context.allowYield = previousAllowYield;
					this.context.await = previousAwait;
					return this.finalize(node, new Node.AsyncFunctionExpression(null, params.params, method));
				};
				Parser.prototype.parseObjectPropertyKey = function () {
					var node = this.createNode();
					var token = this.nextToken();
					var key;
					switch (token.type) {
						case 8 /* StringLiteral */:
						case 6 /* NumericLiteral */:
							if (this.context.strict && token.octal) {
								this.tolerateUnexpectedToken(token, messages_1.Messages.StrictOctalLiteral);
							}
							var raw = this.getTokenRaw(token);
							key = this.finalize(node, new Node.Literal(token.value, raw));
							break;
						case 3 /* Identifier */:
						case 1 /* BooleanLiteral */:
						case 5 /* NullLiteral */:
						case 4 /* Keyword */:
							key = this.finalize(node, new Node.Identifier(token.value));
							break;
						case 7 /* Punctuator */:
							if (token.value === '[') {
								key = this.isolateCoverGrammar(this.parseAssignmentExpression);
								this.expect(']');
							} else {
								key = this.throwUnexpectedToken(token);
							}
							break;
						default:
							key = this.throwUnexpectedToken(token);
					}
					return key;
				};
				Parser.prototype.isPropertyKey = function (key, value) {
					return key.type === syntax_1.Syntax.Identifier && key.name === value || key.type === syntax_1.Syntax.Literal && key.value === value;
				};
				Parser.prototype.parseObjectProperty = function (hasProto) {
					var node = this.createNode();
					var token = this.lookahead;
					var kind;
					var key = null;
					var value = null;
					var computed = false;
					var method = false;
					var shorthand = false;
					var isAsync = false;
					if (token.type === 3 /* Identifier */) {
							var id = token.value;
							this.nextToken();
							computed = this.match('[');
							isAsync = !this.hasLineTerminator && id === 'async' && !this.match(':') && !this.match('(') && !this.match('*');
							key = isAsync ? this.parseObjectPropertyKey() : this.finalize(node, new Node.Identifier(id));
						} else if (this.match('*')) {
						this.nextToken();
					} else {
						computed = this.match('[');
						key = this.parseObjectPropertyKey();
					}
					var lookaheadPropertyKey = this.qualifiedPropertyName(this.lookahead);
					if (token.type === 3 /* Identifier */ && !isAsync && token.value === 'get' && lookaheadPropertyKey) {
						kind = 'get';
						computed = this.match('[');
						key = this.parseObjectPropertyKey();
						this.context.allowYield = false;
						value = this.parseGetterMethod();
					} else if (token.type === 3 /* Identifier */ && !isAsync && token.value === 'set' && lookaheadPropertyKey) {
						kind = 'set';
						computed = this.match('[');
						key = this.parseObjectPropertyKey();
						value = this.parseSetterMethod();
					} else if (token.type === 7 /* Punctuator */ && token.value === '*' && lookaheadPropertyKey) {
						kind = 'init';
						computed = this.match('[');
						key = this.parseObjectPropertyKey();
						value = this.parseGeneratorMethod();
						method = true;
					} else {
						if (!key) {
							this.throwUnexpectedToken(this.lookahead);
						}
						kind = 'init';
						if (this.match(':') && !isAsync) {
							if (!computed && this.isPropertyKey(key, '__proto__')) {
								if (hasProto.value) {
									this.tolerateError(messages_1.Messages.DuplicateProtoProperty);
								}
								hasProto.value = true;
							}
							this.nextToken();
							value = this.inheritCoverGrammar(this.parseAssignmentExpression);
						} else if (this.match('(')) {
							value = isAsync ? this.parsePropertyMethodAsyncFunction() : this.parsePropertyMethodFunction();
							method = true;
						} else if (token.type === 3 /* Identifier */) {
								var id = this.finalize(node, new Node.Identifier(token.value));
								if (this.match('=')) {
									this.context.firstCoverInitializedNameError = this.lookahead;
									this.nextToken();
									shorthand = true;
									var init = this.isolateCoverGrammar(this.parseAssignmentExpression);
									value = this.finalize(node, new Node.AssignmentPattern(id, init));
								} else {
									shorthand = true;
									value = id;
								}
							} else {
							this.throwUnexpectedToken(this.nextToken());
						}
					}
					return this.finalize(node, new Node.Property(kind, key, computed, value, method, shorthand));
				};
				Parser.prototype.parseObjectInitializer = function () {
					var node = this.createNode();
					this.expect('{');
					var properties = [];
					var hasProto = { value: false };
					while (!this.match('}')) {
						properties.push(this.parseObjectProperty(hasProto));
						if (!this.match('}')) {
							this.expectCommaSeparator();
						}
					}
					this.expect('}');
					return this.finalize(node, new Node.ObjectExpression(properties));
				};
				// https://tc39.github.io/ecma262/#sec-template-literals
				Parser.prototype.parseTemplateHead = function () {
					assert_1.assert(this.lookahead.head, 'Template literal must start with a template head');
					var node = this.createNode();
					var token = this.nextToken();
					var raw = token.value;
					var cooked = token.cooked;
					return this.finalize(node, new Node.TemplateElement({ raw: raw, cooked: cooked }, token.tail));
				};
				Parser.prototype.parseTemplateElement = function () {
					if (this.lookahead.type !== 10 /* Template */) {
							this.throwUnexpectedToken();
						}
					var node = this.createNode();
					var token = this.nextToken();
					var raw = token.value;
					var cooked = token.cooked;
					return this.finalize(node, new Node.TemplateElement({ raw: raw, cooked: cooked }, token.tail));
				};
				Parser.prototype.parseTemplateLiteral = function () {
					var node = this.createNode();
					var expressions = [];
					var quasis = [];
					var quasi = this.parseTemplateHead();
					quasis.push(quasi);
					while (!quasi.tail) {
						expressions.push(this.parseExpression());
						quasi = this.parseTemplateElement();
						quasis.push(quasi);
					}
					return this.finalize(node, new Node.TemplateLiteral(quasis, expressions));
				};
				// https://tc39.github.io/ecma262/#sec-grouping-operator
				Parser.prototype.reinterpretExpressionAsPattern = function (expr) {
					switch (expr.type) {
						case syntax_1.Syntax.Identifier:
						case syntax_1.Syntax.MemberExpression:
						case syntax_1.Syntax.RestElement:
						case syntax_1.Syntax.AssignmentPattern:
							break;
						case syntax_1.Syntax.SpreadElement:
							expr.type = syntax_1.Syntax.RestElement;
							this.reinterpretExpressionAsPattern(expr.argument);
							break;
						case syntax_1.Syntax.ArrayExpression:
							expr.type = syntax_1.Syntax.ArrayPattern;
							for (var i = 0; i < expr.elements.length; i++) {
								if (expr.elements[i] !== null) {
									this.reinterpretExpressionAsPattern(expr.elements[i]);
								}
							}
							break;
						case syntax_1.Syntax.ObjectExpression:
							expr.type = syntax_1.Syntax.ObjectPattern;
							for (var i = 0; i < expr.properties.length; i++) {
								this.reinterpretExpressionAsPattern(expr.properties[i].value);
							}
							break;
						case syntax_1.Syntax.AssignmentExpression:
							expr.type = syntax_1.Syntax.AssignmentPattern;
							delete expr.operator;
							this.reinterpretExpressionAsPattern(expr.left);
							break;
						default:
							// Allow other node type for tolerant parsing.
							break;
					}
				};
				Parser.prototype.parseGroupExpression = function () {
					var expr;
					this.expect('(');
					if (this.match(')')) {
						this.nextToken();
						if (!this.match('=>')) {
							this.expect('=>');
						}
						expr = {
							type: ArrowParameterPlaceHolder,
							params: [],
							async: false
						};
					} else {
						var startToken = this.lookahead;
						var params = [];
						if (this.match('...')) {
							expr = this.parseRestElement(params);
							this.expect(')');
							if (!this.match('=>')) {
								this.expect('=>');
							}
							expr = {
								type: ArrowParameterPlaceHolder,
								params: [expr],
								async: false
							};
						} else {
							var arrow = false;
							this.context.isBindingElement = true;
							expr = this.inheritCoverGrammar(this.parseAssignmentExpression);
							if (this.match(',')) {
								var expressions = [];
								this.context.isAssignmentTarget = false;
								expressions.push(expr);
								while (this.lookahead.type !== 2 /* EOF */) {
									if (!this.match(',')) {
										break;
									}
									this.nextToken();
									if (this.match(')')) {
										this.nextToken();
										for (var i = 0; i < expressions.length; i++) {
											this.reinterpretExpressionAsPattern(expressions[i]);
										}
										arrow = true;
										expr = {
											type: ArrowParameterPlaceHolder,
											params: expressions,
											async: false
										};
									} else if (this.match('...')) {
										if (!this.context.isBindingElement) {
											this.throwUnexpectedToken(this.lookahead);
										}
										expressions.push(this.parseRestElement(params));
										this.expect(')');
										if (!this.match('=>')) {
											this.expect('=>');
										}
										this.context.isBindingElement = false;
										for (var i = 0; i < expressions.length; i++) {
											this.reinterpretExpressionAsPattern(expressions[i]);
										}
										arrow = true;
										expr = {
											type: ArrowParameterPlaceHolder,
											params: expressions,
											async: false
										};
									} else {
										expressions.push(this.inheritCoverGrammar(this.parseAssignmentExpression));
									}
									if (arrow) {
										break;
									}
								}
								if (!arrow) {
									expr = this.finalize(this.startNode(startToken), new Node.SequenceExpression(expressions));
								}
							}
							if (!arrow) {
								this.expect(')');
								if (this.match('=>')) {
									if (expr.type === syntax_1.Syntax.Identifier && expr.name === 'yield') {
										arrow = true;
										expr = {
											type: ArrowParameterPlaceHolder,
											params: [expr],
											async: false
										};
									}
									if (!arrow) {
										if (!this.context.isBindingElement) {
											this.throwUnexpectedToken(this.lookahead);
										}
										if (expr.type === syntax_1.Syntax.SequenceExpression) {
											for (var i = 0; i < expr.expressions.length; i++) {
												this.reinterpretExpressionAsPattern(expr.expressions[i]);
											}
										} else {
											this.reinterpretExpressionAsPattern(expr);
										}
										var parameters = expr.type === syntax_1.Syntax.SequenceExpression ? expr.expressions : [expr];
										expr = {
											type: ArrowParameterPlaceHolder,
											params: parameters,
											async: false
										};
									}
								}
								this.context.isBindingElement = false;
							}
						}
					}
					return expr;
				};
				// https://tc39.github.io/ecma262/#sec-left-hand-side-expressions
				Parser.prototype.parseArguments = function () {
					this.expect('(');
					var args = [];
					if (!this.match(')')) {
						while (true) {
							var expr = this.match('...') ? this.parseSpreadElement() : this.isolateCoverGrammar(this.parseAssignmentExpression);
							args.push(expr);
							if (this.match(')')) {
								break;
							}
							this.expectCommaSeparator();
							if (this.match(')')) {
								break;
							}
						}
					}
					this.expect(')');
					return args;
				};
				Parser.prototype.isIdentifierName = function (token) {
					return token.type === 3 /* Identifier */ || token.type === 4 /* Keyword */ || token.type === 1 /* BooleanLiteral */ || token.type === 5 /* NullLiteral */;
				};
				Parser.prototype.parseIdentifierName = function () {
					var node = this.createNode();
					var token = this.nextToken();
					if (!this.isIdentifierName(token)) {
						this.throwUnexpectedToken(token);
					}
					return this.finalize(node, new Node.Identifier(token.value));
				};
				Parser.prototype.parseNewExpression = function () {
					var node = this.createNode();
					var id = this.parseIdentifierName();
					assert_1.assert(id.name === 'new', 'New expression must start with `new`');
					var expr;
					if (this.match('.')) {
						this.nextToken();
						if (this.lookahead.type === 3 /* Identifier */ && this.context.inFunctionBody && this.lookahead.value === 'target') {
							var property = this.parseIdentifierName();
							expr = new Node.MetaProperty(id, property);
						} else {
							this.throwUnexpectedToken(this.lookahead);
						}
					} else {
						var callee = this.isolateCoverGrammar(this.parseLeftHandSideExpression);
						var args = this.match('(') ? this.parseArguments() : [];
						expr = new Node.NewExpression(callee, args);
						this.context.isAssignmentTarget = false;
						this.context.isBindingElement = false;
					}
					return this.finalize(node, expr);
				};
				Parser.prototype.parseAsyncArgument = function () {
					var arg = this.parseAssignmentExpression();
					this.context.firstCoverInitializedNameError = null;
					return arg;
				};
				Parser.prototype.parseAsyncArguments = function () {
					this.expect('(');
					var args = [];
					if (!this.match(')')) {
						while (true) {
							var expr = this.match('...') ? this.parseSpreadElement() : this.isolateCoverGrammar(this.parseAsyncArgument);
							args.push(expr);
							if (this.match(')')) {
								break;
							}
							this.expectCommaSeparator();
							if (this.match(')')) {
								break;
							}
						}
					}
					this.expect(')');
					return args;
				};
				Parser.prototype.parseLeftHandSideExpressionAllowCall = function () {
					var startToken = this.lookahead;
					var maybeAsync = this.matchContextualKeyword('async');
					var previousAllowIn = this.context.allowIn;
					this.context.allowIn = true;
					var expr;
					if (this.matchKeyword('super') && this.context.inFunctionBody) {
						expr = this.createNode();
						this.nextToken();
						expr = this.finalize(expr, new Node.Super());
						if (!this.match('(') && !this.match('.') && !this.match('[')) {
							this.throwUnexpectedToken(this.lookahead);
						}
					} else {
						expr = this.inheritCoverGrammar(this.matchKeyword('new') ? this.parseNewExpression : this.parsePrimaryExpression);
					}
					while (true) {
						if (this.match('.')) {
							this.context.isBindingElement = false;
							this.context.isAssignmentTarget = true;
							this.expect('.');
							var property = this.parseIdentifierName();
							expr = this.finalize(this.startNode(startToken), new Node.StaticMemberExpression(expr, property));
						} else if (this.match('(')) {
							var asyncArrow = maybeAsync && startToken.lineNumber === this.lookahead.lineNumber;
							this.context.isBindingElement = false;
							this.context.isAssignmentTarget = false;
							var args = asyncArrow ? this.parseAsyncArguments() : this.parseArguments();
							expr = this.finalize(this.startNode(startToken), new Node.CallExpression(expr, args));
							if (asyncArrow && this.match('=>')) {
								for (var i = 0; i < args.length; ++i) {
									this.reinterpretExpressionAsPattern(args[i]);
								}
								expr = {
									type: ArrowParameterPlaceHolder,
									params: args,
									async: true
								};
							}
						} else if (this.match('[')) {
							this.context.isBindingElement = false;
							this.context.isAssignmentTarget = true;
							this.expect('[');
							var property = this.isolateCoverGrammar(this.parseExpression);
							this.expect(']');
							expr = this.finalize(this.startNode(startToken), new Node.ComputedMemberExpression(expr, property));
						} else if (this.lookahead.type === 10 /* Template */ && this.lookahead.head) {
							var quasi = this.parseTemplateLiteral();
							expr = this.finalize(this.startNode(startToken), new Node.TaggedTemplateExpression(expr, quasi));
						} else {
							break;
						}
					}
					this.context.allowIn = previousAllowIn;
					return expr;
				};
				Parser.prototype.parseSuper = function () {
					var node = this.createNode();
					this.expectKeyword('super');
					if (!this.match('[') && !this.match('.')) {
						this.throwUnexpectedToken(this.lookahead);
					}
					return this.finalize(node, new Node.Super());
				};
				Parser.prototype.parseLeftHandSideExpression = function () {
					assert_1.assert(this.context.allowIn, 'callee of new expression always allow in keyword.');
					var node = this.startNode(this.lookahead);
					var expr = this.matchKeyword('super') && this.context.inFunctionBody ? this.parseSuper() : this.inheritCoverGrammar(this.matchKeyword('new') ? this.parseNewExpression : this.parsePrimaryExpression);
					while (true) {
						if (this.match('[')) {
							this.context.isBindingElement = false;
							this.context.isAssignmentTarget = true;
							this.expect('[');
							var property = this.isolateCoverGrammar(this.parseExpression);
							this.expect(']');
							expr = this.finalize(node, new Node.ComputedMemberExpression(expr, property));
						} else if (this.match('.')) {
							this.context.isBindingElement = false;
							this.context.isAssignmentTarget = true;
							this.expect('.');
							var property = this.parseIdentifierName();
							expr = this.finalize(node, new Node.StaticMemberExpression(expr, property));
						} else if (this.lookahead.type === 10 /* Template */ && this.lookahead.head) {
							var quasi = this.parseTemplateLiteral();
							expr = this.finalize(node, new Node.TaggedTemplateExpression(expr, quasi));
						} else {
							break;
						}
					}
					return expr;
				};
				// https://tc39.github.io/ecma262/#sec-update-expressions
				Parser.prototype.parseUpdateExpression = function () {
					var expr;
					var startToken = this.lookahead;
					if (this.match('++') || this.match('--')) {
						var node = this.startNode(startToken);
						var token = this.nextToken();
						expr = this.inheritCoverGrammar(this.parseUnaryExpression);
						if (this.context.strict && expr.type === syntax_1.Syntax.Identifier && this.scanner.isRestrictedWord(expr.name)) {
							this.tolerateError(messages_1.Messages.StrictLHSPrefix);
						}
						if (!this.context.isAssignmentTarget) {
							this.tolerateError(messages_1.Messages.InvalidLHSInAssignment);
						}
						var prefix = true;
						expr = this.finalize(node, new Node.UpdateExpression(token.value, expr, prefix));
						this.context.isAssignmentTarget = false;
						this.context.isBindingElement = false;
					} else {
						expr = this.inheritCoverGrammar(this.parseLeftHandSideExpressionAllowCall);
						if (!this.hasLineTerminator && this.lookahead.type === 7 /* Punctuator */) {
								if (this.match('++') || this.match('--')) {
									if (this.context.strict && expr.type === syntax_1.Syntax.Identifier && this.scanner.isRestrictedWord(expr.name)) {
										this.tolerateError(messages_1.Messages.StrictLHSPostfix);
									}
									if (!this.context.isAssignmentTarget) {
										this.tolerateError(messages_1.Messages.InvalidLHSInAssignment);
									}
									this.context.isAssignmentTarget = false;
									this.context.isBindingElement = false;
									var operator = this.nextToken().value;
									var prefix = false;
									expr = this.finalize(this.startNode(startToken), new Node.UpdateExpression(operator, expr, prefix));
								}
							}
					}
					return expr;
				};
				// https://tc39.github.io/ecma262/#sec-unary-operators
				Parser.prototype.parseAwaitExpression = function () {
					var node = this.createNode();
					this.nextToken();
					var argument = this.parseUnaryExpression();
					return this.finalize(node, new Node.AwaitExpression(argument));
				};
				Parser.prototype.parseUnaryExpression = function () {
					var expr;
					if (this.match('+') || this.match('-') || this.match('~') || this.match('!') || this.matchKeyword('delete') || this.matchKeyword('void') || this.matchKeyword('typeof')) {
						var node = this.startNode(this.lookahead);
						var token = this.nextToken();
						expr = this.inheritCoverGrammar(this.parseUnaryExpression);
						expr = this.finalize(node, new Node.UnaryExpression(token.value, expr));
						if (this.context.strict && expr.operator === 'delete' && expr.argument.type === syntax_1.Syntax.Identifier) {
							this.tolerateError(messages_1.Messages.StrictDelete);
						}
						this.context.isAssignmentTarget = false;
						this.context.isBindingElement = false;
					} else if (this.context.await && this.matchContextualKeyword('await')) {
						expr = this.parseAwaitExpression();
					} else {
						expr = this.parseUpdateExpression();
					}
					return expr;
				};
				Parser.prototype.parseExponentiationExpression = function () {
					var startToken = this.lookahead;
					var expr = this.inheritCoverGrammar(this.parseUnaryExpression);
					if (expr.type !== syntax_1.Syntax.UnaryExpression && this.match('**')) {
						this.nextToken();
						this.context.isAssignmentTarget = false;
						this.context.isBindingElement = false;
						var left = expr;
						var right = this.isolateCoverGrammar(this.parseExponentiationExpression);
						expr = this.finalize(this.startNode(startToken), new Node.BinaryExpression('**', left, right));
					}
					return expr;
				};
				// https://tc39.github.io/ecma262/#sec-exp-operator
				// https://tc39.github.io/ecma262/#sec-multiplicative-operators
				// https://tc39.github.io/ecma262/#sec-additive-operators
				// https://tc39.github.io/ecma262/#sec-bitwise-shift-operators
				// https://tc39.github.io/ecma262/#sec-relational-operators
				// https://tc39.github.io/ecma262/#sec-equality-operators
				// https://tc39.github.io/ecma262/#sec-binary-bitwise-operators
				// https://tc39.github.io/ecma262/#sec-binary-logical-operators
				Parser.prototype.binaryPrecedence = function (token) {
					var op = token.value;
					var precedence;
					if (token.type === 7 /* Punctuator */) {
							precedence = this.operatorPrecedence[op] || 0;
						} else if (token.type === 4 /* Keyword */) {
							precedence = op === 'instanceof' || this.context.allowIn && op === 'in' ? 7 : 0;
						} else {
						precedence = 0;
					}
					return precedence;
				};
				Parser.prototype.parseBinaryExpression = function () {
					var startToken = this.lookahead;
					var expr = this.inheritCoverGrammar(this.parseExponentiationExpression);
					var token = this.lookahead;
					var prec = this.binaryPrecedence(token);
					if (prec > 0) {
						this.nextToken();
						this.context.isAssignmentTarget = false;
						this.context.isBindingElement = false;
						var markers = [startToken, this.lookahead];
						var left = expr;
						var right = this.isolateCoverGrammar(this.parseExponentiationExpression);
						var stack = [left, token.value, right];
						var precedences = [prec];
						while (true) {
							prec = this.binaryPrecedence(this.lookahead);
							if (prec <= 0) {
								break;
							}
							// Reduce: make a binary expression from the three topmost entries.
							while (stack.length > 2 && prec <= precedences[precedences.length - 1]) {
								right = stack.pop();
								var operator = stack.pop();
								precedences.pop();
								left = stack.pop();
								markers.pop();
								var node = this.startNode(markers[markers.length - 1]);
								stack.push(this.finalize(node, new Node.BinaryExpression(operator, left, right)));
							}
							// Shift.
							stack.push(this.nextToken().value);
							precedences.push(prec);
							markers.push(this.lookahead);
							stack.push(this.isolateCoverGrammar(this.parseExponentiationExpression));
						}
						// Final reduce to clean-up the stack.
						var i = stack.length - 1;
						expr = stack[i];
						markers.pop();
						while (i > 1) {
							var node = this.startNode(markers.pop());
							var operator = stack[i - 1];
							expr = this.finalize(node, new Node.BinaryExpression(operator, stack[i - 2], expr));
							i -= 2;
						}
					}
					return expr;
				};
				// https://tc39.github.io/ecma262/#sec-conditional-operator
				Parser.prototype.parseConditionalExpression = function () {
					var startToken = this.lookahead;
					var expr = this.inheritCoverGrammar(this.parseBinaryExpression);
					if (this.match('?')) {
						this.nextToken();
						var previousAllowIn = this.context.allowIn;
						this.context.allowIn = true;
						var consequent = this.isolateCoverGrammar(this.parseAssignmentExpression);
						this.context.allowIn = previousAllowIn;
						this.expect(':');
						var alternate = this.isolateCoverGrammar(this.parseAssignmentExpression);
						expr = this.finalize(this.startNode(startToken), new Node.ConditionalExpression(expr, consequent, alternate));
						this.context.isAssignmentTarget = false;
						this.context.isBindingElement = false;
					}
					return expr;
				};
				// https://tc39.github.io/ecma262/#sec-assignment-operators
				Parser.prototype.checkPatternParam = function (options, param) {
					switch (param.type) {
						case syntax_1.Syntax.Identifier:
							this.validateParam(options, param, param.name);
							break;
						case syntax_1.Syntax.RestElement:
							this.checkPatternParam(options, param.argument);
							break;
						case syntax_1.Syntax.AssignmentPattern:
							this.checkPatternParam(options, param.left);
							break;
						case syntax_1.Syntax.ArrayPattern:
							for (var i = 0; i < param.elements.length; i++) {
								if (param.elements[i] !== null) {
									this.checkPatternParam(options, param.elements[i]);
								}
							}
							break;
						case syntax_1.Syntax.ObjectPattern:
							for (var i = 0; i < param.properties.length; i++) {
								this.checkPatternParam(options, param.properties[i].value);
							}
							break;
						default:
							break;
					}
					options.simple = options.simple && param instanceof Node.Identifier;
				};
				Parser.prototype.reinterpretAsCoverFormalsList = function (expr) {
					var params = [expr];
					var options;
					var asyncArrow = false;
					switch (expr.type) {
						case syntax_1.Syntax.Identifier:
							break;
						case ArrowParameterPlaceHolder:
							params = expr.params;
							asyncArrow = expr.async;
							break;
						default:
							return null;
					}
					options = {
						simple: true,
						paramSet: {}
					};
					for (var i = 0; i < params.length; ++i) {
						var param = params[i];
						if (param.type === syntax_1.Syntax.AssignmentPattern) {
							if (param.right.type === syntax_1.Syntax.YieldExpression) {
								if (param.right.argument) {
									this.throwUnexpectedToken(this.lookahead);
								}
								param.right.type = syntax_1.Syntax.Identifier;
								param.right.name = 'yield';
								delete param.right.argument;
								delete param.right.delegate;
							}
						} else if (asyncArrow && param.type === syntax_1.Syntax.Identifier && param.name === 'await') {
							this.throwUnexpectedToken(this.lookahead);
						}
						this.checkPatternParam(options, param);
						params[i] = param;
					}
					if (this.context.strict || !this.context.allowYield) {
						for (var i = 0; i < params.length; ++i) {
							var param = params[i];
							if (param.type === syntax_1.Syntax.YieldExpression) {
								this.throwUnexpectedToken(this.lookahead);
							}
						}
					}
					if (options.message === messages_1.Messages.StrictParamDupe) {
						var token = this.context.strict ? options.stricted : options.firstRestricted;
						this.throwUnexpectedToken(token, options.message);
					}
					return {
						simple: options.simple,
						params: params,
						stricted: options.stricted,
						firstRestricted: options.firstRestricted,
						message: options.message
					};
				};
				Parser.prototype.parseAssignmentExpression = function () {
					var expr;
					if (!this.context.allowYield && this.matchKeyword('yield')) {
						expr = this.parseYieldExpression();
					} else {
						var startToken = this.lookahead;
						var token = startToken;
						expr = this.parseConditionalExpression();
						if (token.type === 3 /* Identifier */ && token.lineNumber === this.lookahead.lineNumber && token.value === 'async') {
							if (this.lookahead.type === 3 /* Identifier */ || this.matchKeyword('yield')) {
								var arg = this.parsePrimaryExpression();
								this.reinterpretExpressionAsPattern(arg);
								expr = {
									type: ArrowParameterPlaceHolder,
									params: [arg],
									async: true
								};
							}
						}
						if (expr.type === ArrowParameterPlaceHolder || this.match('=>')) {
							// https://tc39.github.io/ecma262/#sec-arrow-function-definitions
							this.context.isAssignmentTarget = false;
							this.context.isBindingElement = false;
							var isAsync = expr.async;
							var list = this.reinterpretAsCoverFormalsList(expr);
							if (list) {
								if (this.hasLineTerminator) {
									this.tolerateUnexpectedToken(this.lookahead);
								}
								this.context.firstCoverInitializedNameError = null;
								var previousStrict = this.context.strict;
								var previousAllowStrictDirective = this.context.allowStrictDirective;
								this.context.allowStrictDirective = list.simple;
								var previousAllowYield = this.context.allowYield;
								var previousAwait = this.context.await;
								this.context.allowYield = true;
								this.context.await = isAsync;
								var node = this.startNode(startToken);
								this.expect('=>');
								var body = void 0;
								if (this.match('{')) {
									var previousAllowIn = this.context.allowIn;
									this.context.allowIn = true;
									body = this.parseFunctionSourceElements();
									this.context.allowIn = previousAllowIn;
								} else {
									body = this.isolateCoverGrammar(this.parseAssignmentExpression);
								}
								var expression = body.type !== syntax_1.Syntax.BlockStatement;
								if (this.context.strict && list.firstRestricted) {
									this.throwUnexpectedToken(list.firstRestricted, list.message);
								}
								if (this.context.strict && list.stricted) {
									this.tolerateUnexpectedToken(list.stricted, list.message);
								}
								expr = isAsync ? this.finalize(node, new Node.AsyncArrowFunctionExpression(list.params, body, expression)) : this.finalize(node, new Node.ArrowFunctionExpression(list.params, body, expression));
								this.context.strict = previousStrict;
								this.context.allowStrictDirective = previousAllowStrictDirective;
								this.context.allowYield = previousAllowYield;
								this.context.await = previousAwait;
							}
						} else {
							if (this.matchAssign()) {
								if (!this.context.isAssignmentTarget) {
									this.tolerateError(messages_1.Messages.InvalidLHSInAssignment);
								}
								if (this.context.strict && expr.type === syntax_1.Syntax.Identifier) {
									var id = expr;
									if (this.scanner.isRestrictedWord(id.name)) {
										this.tolerateUnexpectedToken(token, messages_1.Messages.StrictLHSAssignment);
									}
									if (this.scanner.isStrictModeReservedWord(id.name)) {
										this.tolerateUnexpectedToken(token, messages_1.Messages.StrictReservedWord);
									}
								}
								if (!this.match('=')) {
									this.context.isAssignmentTarget = false;
									this.context.isBindingElement = false;
								} else {
									this.reinterpretExpressionAsPattern(expr);
								}
								token = this.nextToken();
								var operator = token.value;
								var right = this.isolateCoverGrammar(this.parseAssignmentExpression);
								expr = this.finalize(this.startNode(startToken), new Node.AssignmentExpression(operator, expr, right));
								this.context.firstCoverInitializedNameError = null;
							}
						}
					}
					return expr;
				};
				// https://tc39.github.io/ecma262/#sec-comma-operator
				Parser.prototype.parseExpression = function () {
					var startToken = this.lookahead;
					var expr = this.isolateCoverGrammar(this.parseAssignmentExpression);
					if (this.match(',')) {
						var expressions = [];
						expressions.push(expr);
						while (this.lookahead.type !== 2 /* EOF */) {
							if (!this.match(',')) {
								break;
							}
							this.nextToken();
							expressions.push(this.isolateCoverGrammar(this.parseAssignmentExpression));
						}
						expr = this.finalize(this.startNode(startToken), new Node.SequenceExpression(expressions));
					}
					return expr;
				};
				// https://tc39.github.io/ecma262/#sec-block
				Parser.prototype.parseStatementListItem = function () {
					var statement;
					this.context.isAssignmentTarget = true;
					this.context.isBindingElement = true;
					if (this.lookahead.type === 4 /* Keyword */) {
							switch (this.lookahead.value) {
								case 'export':
									if (!this.context.isModule) {
										this.tolerateUnexpectedToken(this.lookahead, messages_1.Messages.IllegalExportDeclaration);
									}
									statement = this.parseExportDeclaration();
									break;
								case 'import':
									if (!this.context.isModule) {
										this.tolerateUnexpectedToken(this.lookahead, messages_1.Messages.IllegalImportDeclaration);
									}
									statement = this.parseImportDeclaration();
									break;
								case 'const':
									statement = this.parseLexicalDeclaration({ inFor: false });
									break;
								case 'function':
									statement = this.parseFunctionDeclaration();
									break;
								case 'class':
									statement = this.parseClassDeclaration();
									break;
								case 'let':
									statement = this.isLexicalDeclaration() ? this.parseLexicalDeclaration({ inFor: false }) : this.parseStatement();
									break;
								default:
									statement = this.parseStatement();
									break;
							}
						} else {
						statement = this.parseStatement();
					}
					return statement;
				};
				Parser.prototype.parseBlock = function () {
					var node = this.createNode();
					this.expect('{');
					var block = [];
					while (true) {
						if (this.match('}')) {
							break;
						}
						block.push(this.parseStatementListItem());
					}
					this.expect('}');
					return this.finalize(node, new Node.BlockStatement(block));
				};
				// https://tc39.github.io/ecma262/#sec-let-and-const-declarations
				Parser.prototype.parseLexicalBinding = function (kind, options) {
					var node = this.createNode();
					var params = [];
					var id = this.parsePattern(params, kind);
					if (this.context.strict && id.type === syntax_1.Syntax.Identifier) {
						if (this.scanner.isRestrictedWord(id.name)) {
							this.tolerateError(messages_1.Messages.StrictVarName);
						}
					}
					var init = null;
					if (kind === 'const') {
						if (!this.matchKeyword('in') && !this.matchContextualKeyword('of')) {
							if (this.match('=')) {
								this.nextToken();
								init = this.isolateCoverGrammar(this.parseAssignmentExpression);
							} else {
								this.throwError(messages_1.Messages.DeclarationMissingInitializer, 'const');
							}
						}
					} else if (!options.inFor && id.type !== syntax_1.Syntax.Identifier || this.match('=')) {
						this.expect('=');
						init = this.isolateCoverGrammar(this.parseAssignmentExpression);
					}
					return this.finalize(node, new Node.VariableDeclarator(id, init));
				};
				Parser.prototype.parseBindingList = function (kind, options) {
					var list = [this.parseLexicalBinding(kind, options)];
					while (this.match(',')) {
						this.nextToken();
						list.push(this.parseLexicalBinding(kind, options));
					}
					return list;
				};
				Parser.prototype.isLexicalDeclaration = function () {
					var state = this.scanner.saveState();
					this.scanner.scanComments();
					var next = this.scanner.lex();
					this.scanner.restoreState(state);
					return next.type === 3 /* Identifier */ || next.type === 7 /* Punctuator */ && next.value === '[' || next.type === 7 /* Punctuator */ && next.value === '{' || next.type === 4 /* Keyword */ && next.value === 'let' || next.type === 4 /* Keyword */ && next.value === 'yield';
				};
				Parser.prototype.parseLexicalDeclaration = function (options) {
					var node = this.createNode();
					var kind = this.nextToken().value;
					assert_1.assert(kind === 'let' || kind === 'const', 'Lexical declaration must be either let or const');
					var declarations = this.parseBindingList(kind, options);
					this.consumeSemicolon();
					return this.finalize(node, new Node.VariableDeclaration(declarations, kind));
				};
				// https://tc39.github.io/ecma262/#sec-destructuring-binding-patterns
				Parser.prototype.parseBindingRestElement = function (params, kind) {
					var node = this.createNode();
					this.expect('...');
					var arg = this.parsePattern(params, kind);
					return this.finalize(node, new Node.RestElement(arg));
				};
				Parser.prototype.parseArrayPattern = function (params, kind) {
					var node = this.createNode();
					this.expect('[');
					var elements = [];
					while (!this.match(']')) {
						if (this.match(',')) {
							this.nextToken();
							elements.push(null);
						} else {
							if (this.match('...')) {
								elements.push(this.parseBindingRestElement(params, kind));
								break;
							} else {
								elements.push(this.parsePatternWithDefault(params, kind));
							}
							if (!this.match(']')) {
								this.expect(',');
							}
						}
					}
					this.expect(']');
					return this.finalize(node, new Node.ArrayPattern(elements));
				};
				Parser.prototype.parsePropertyPattern = function (params, kind) {
					var node = this.createNode();
					var computed = false;
					var shorthand = false;
					var method = false;
					var key;
					var value;
					if (this.lookahead.type === 3 /* Identifier */) {
							var keyToken = this.lookahead;
							key = this.parseVariableIdentifier();
							var init = this.finalize(node, new Node.Identifier(keyToken.value));
							if (this.match('=')) {
								params.push(keyToken);
								shorthand = true;
								this.nextToken();
								var expr = this.parseAssignmentExpression();
								value = this.finalize(this.startNode(keyToken), new Node.AssignmentPattern(init, expr));
							} else if (!this.match(':')) {
								params.push(keyToken);
								shorthand = true;
								value = init;
							} else {
								this.expect(':');
								value = this.parsePatternWithDefault(params, kind);
							}
						} else {
						computed = this.match('[');
						key = this.parseObjectPropertyKey();
						this.expect(':');
						value = this.parsePatternWithDefault(params, kind);
					}
					return this.finalize(node, new Node.Property('init', key, computed, value, method, shorthand));
				};
				Parser.prototype.parseObjectPattern = function (params, kind) {
					var node = this.createNode();
					var properties = [];
					this.expect('{');
					while (!this.match('}')) {
						properties.push(this.parsePropertyPattern(params, kind));
						if (!this.match('}')) {
							this.expect(',');
						}
					}
					this.expect('}');
					return this.finalize(node, new Node.ObjectPattern(properties));
				};
				Parser.prototype.parsePattern = function (params, kind) {
					var pattern;
					if (this.match('[')) {
						pattern = this.parseArrayPattern(params, kind);
					} else if (this.match('{')) {
						pattern = this.parseObjectPattern(params, kind);
					} else {
						if (this.matchKeyword('let') && (kind === 'const' || kind === 'let')) {
							this.tolerateUnexpectedToken(this.lookahead, messages_1.Messages.LetInLexicalBinding);
						}
						params.push(this.lookahead);
						pattern = this.parseVariableIdentifier(kind);
					}
					return pattern;
				};
				Parser.prototype.parsePatternWithDefault = function (params, kind) {
					var startToken = this.lookahead;
					var pattern = this.parsePattern(params, kind);
					if (this.match('=')) {
						this.nextToken();
						var previousAllowYield = this.context.allowYield;
						this.context.allowYield = true;
						var right = this.isolateCoverGrammar(this.parseAssignmentExpression);
						this.context.allowYield = previousAllowYield;
						pattern = this.finalize(this.startNode(startToken), new Node.AssignmentPattern(pattern, right));
					}
					return pattern;
				};
				// https://tc39.github.io/ecma262/#sec-variable-statement
				Parser.prototype.parseVariableIdentifier = function (kind) {
					var node = this.createNode();
					var token = this.nextToken();
					if (token.type === 4 /* Keyword */ && token.value === 'yield') {
						if (this.context.strict) {
							this.tolerateUnexpectedToken(token, messages_1.Messages.StrictReservedWord);
						} else if (!this.context.allowYield) {
							this.throwUnexpectedToken(token);
						}
					} else if (token.type !== 3 /* Identifier */) {
							if (this.context.strict && token.type === 4 /* Keyword */ && this.scanner.isStrictModeReservedWord(token.value)) {
								this.tolerateUnexpectedToken(token, messages_1.Messages.StrictReservedWord);
							} else {
								if (this.context.strict || token.value !== 'let' || kind !== 'var') {
									this.throwUnexpectedToken(token);
								}
							}
						} else if ((this.context.isModule || this.context.await) && token.type === 3 /* Identifier */ && token.value === 'await') {
						this.tolerateUnexpectedToken(token);
					}
					return this.finalize(node, new Node.Identifier(token.value));
				};
				Parser.prototype.parseVariableDeclaration = function (options) {
					var node = this.createNode();
					var params = [];
					var id = this.parsePattern(params, 'var');
					if (this.context.strict && id.type === syntax_1.Syntax.Identifier) {
						if (this.scanner.isRestrictedWord(id.name)) {
							this.tolerateError(messages_1.Messages.StrictVarName);
						}
					}
					var init = null;
					if (this.match('=')) {
						this.nextToken();
						init = this.isolateCoverGrammar(this.parseAssignmentExpression);
					} else if (id.type !== syntax_1.Syntax.Identifier && !options.inFor) {
						this.expect('=');
					}
					return this.finalize(node, new Node.VariableDeclarator(id, init));
				};
				Parser.prototype.parseVariableDeclarationList = function (options) {
					var opt = { inFor: options.inFor };
					var list = [];
					list.push(this.parseVariableDeclaration(opt));
					while (this.match(',')) {
						this.nextToken();
						list.push(this.parseVariableDeclaration(opt));
					}
					return list;
				};
				Parser.prototype.parseVariableStatement = function () {
					var node = this.createNode();
					this.expectKeyword('var');
					var declarations = this.parseVariableDeclarationList({ inFor: false });
					this.consumeSemicolon();
					return this.finalize(node, new Node.VariableDeclaration(declarations, 'var'));
				};
				// https://tc39.github.io/ecma262/#sec-empty-statement
				Parser.prototype.parseEmptyStatement = function () {
					var node = this.createNode();
					this.expect(';');
					return this.finalize(node, new Node.EmptyStatement());
				};
				// https://tc39.github.io/ecma262/#sec-expression-statement
				Parser.prototype.parseExpressionStatement = function () {
					var node = this.createNode();
					var expr = this.parseExpression();
					this.consumeSemicolon();
					return this.finalize(node, new Node.ExpressionStatement(expr));
				};
				// https://tc39.github.io/ecma262/#sec-if-statement
				Parser.prototype.parseIfClause = function () {
					if (this.context.strict && this.matchKeyword('function')) {
						this.tolerateError(messages_1.Messages.StrictFunction);
					}
					return this.parseStatement();
				};
				Parser.prototype.parseIfStatement = function () {
					var node = this.createNode();
					var consequent;
					var alternate = null;
					this.expectKeyword('if');
					this.expect('(');
					var test = this.parseExpression();
					if (!this.match(')') && this.config.tolerant) {
						this.tolerateUnexpectedToken(this.nextToken());
						consequent = this.finalize(this.createNode(), new Node.EmptyStatement());
					} else {
						this.expect(')');
						consequent = this.parseIfClause();
						if (this.matchKeyword('else')) {
							this.nextToken();
							alternate = this.parseIfClause();
						}
					}
					return this.finalize(node, new Node.IfStatement(test, consequent, alternate));
				};
				// https://tc39.github.io/ecma262/#sec-do-while-statement
				Parser.prototype.parseDoWhileStatement = function () {
					var node = this.createNode();
					this.expectKeyword('do');
					var previousInIteration = this.context.inIteration;
					this.context.inIteration = true;
					var body = this.parseStatement();
					this.context.inIteration = previousInIteration;
					this.expectKeyword('while');
					this.expect('(');
					var test = this.parseExpression();
					if (!this.match(')') && this.config.tolerant) {
						this.tolerateUnexpectedToken(this.nextToken());
					} else {
						this.expect(')');
						if (this.match(';')) {
							this.nextToken();
						}
					}
					return this.finalize(node, new Node.DoWhileStatement(body, test));
				};
				// https://tc39.github.io/ecma262/#sec-while-statement
				Parser.prototype.parseWhileStatement = function () {
					var node = this.createNode();
					var body;
					this.expectKeyword('while');
					this.expect('(');
					var test = this.parseExpression();
					if (!this.match(')') && this.config.tolerant) {
						this.tolerateUnexpectedToken(this.nextToken());
						body = this.finalize(this.createNode(), new Node.EmptyStatement());
					} else {
						this.expect(')');
						var previousInIteration = this.context.inIteration;
						this.context.inIteration = true;
						body = this.parseStatement();
						this.context.inIteration = previousInIteration;
					}
					return this.finalize(node, new Node.WhileStatement(test, body));
				};
				// https://tc39.github.io/ecma262/#sec-for-statement
				// https://tc39.github.io/ecma262/#sec-for-in-and-for-of-statements
				Parser.prototype.parseForStatement = function () {
					var init = null;
					var test = null;
					var update = null;
					var forIn = true;
					var left, right;
					var node = this.createNode();
					this.expectKeyword('for');
					this.expect('(');
					if (this.match(';')) {
						this.nextToken();
					} else {
						if (this.matchKeyword('var')) {
							init = this.createNode();
							this.nextToken();
							var previousAllowIn = this.context.allowIn;
							this.context.allowIn = false;
							var declarations = this.parseVariableDeclarationList({ inFor: true });
							this.context.allowIn = previousAllowIn;
							if (declarations.length === 1 && this.matchKeyword('in')) {
								var decl = declarations[0];
								if (decl.init && (decl.id.type === syntax_1.Syntax.ArrayPattern || decl.id.type === syntax_1.Syntax.ObjectPattern || this.context.strict)) {
									this.tolerateError(messages_1.Messages.ForInOfLoopInitializer, 'for-in');
								}
								init = this.finalize(init, new Node.VariableDeclaration(declarations, 'var'));
								this.nextToken();
								left = init;
								right = this.parseExpression();
								init = null;
							} else if (declarations.length === 1 && declarations[0].init === null && this.matchContextualKeyword('of')) {
								init = this.finalize(init, new Node.VariableDeclaration(declarations, 'var'));
								this.nextToken();
								left = init;
								right = this.parseAssignmentExpression();
								init = null;
								forIn = false;
							} else {
								init = this.finalize(init, new Node.VariableDeclaration(declarations, 'var'));
								this.expect(';');
							}
						} else if (this.matchKeyword('const') || this.matchKeyword('let')) {
							init = this.createNode();
							var kind = this.nextToken().value;
							if (!this.context.strict && this.lookahead.value === 'in') {
								init = this.finalize(init, new Node.Identifier(kind));
								this.nextToken();
								left = init;
								right = this.parseExpression();
								init = null;
							} else {
								var previousAllowIn = this.context.allowIn;
								this.context.allowIn = false;
								var declarations = this.parseBindingList(kind, { inFor: true });
								this.context.allowIn = previousAllowIn;
								if (declarations.length === 1 && declarations[0].init === null && this.matchKeyword('in')) {
									init = this.finalize(init, new Node.VariableDeclaration(declarations, kind));
									this.nextToken();
									left = init;
									right = this.parseExpression();
									init = null;
								} else if (declarations.length === 1 && declarations[0].init === null && this.matchContextualKeyword('of')) {
									init = this.finalize(init, new Node.VariableDeclaration(declarations, kind));
									this.nextToken();
									left = init;
									right = this.parseAssignmentExpression();
									init = null;
									forIn = false;
								} else {
									this.consumeSemicolon();
									init = this.finalize(init, new Node.VariableDeclaration(declarations, kind));
								}
							}
						} else {
							var initStartToken = this.lookahead;
							var previousAllowIn = this.context.allowIn;
							this.context.allowIn = false;
							init = this.inheritCoverGrammar(this.parseAssignmentExpression);
							this.context.allowIn = previousAllowIn;
							if (this.matchKeyword('in')) {
								if (!this.context.isAssignmentTarget || init.type === syntax_1.Syntax.AssignmentExpression) {
									this.tolerateError(messages_1.Messages.InvalidLHSInForIn);
								}
								this.nextToken();
								this.reinterpretExpressionAsPattern(init);
								left = init;
								right = this.parseExpression();
								init = null;
							} else if (this.matchContextualKeyword('of')) {
								if (!this.context.isAssignmentTarget || init.type === syntax_1.Syntax.AssignmentExpression) {
									this.tolerateError(messages_1.Messages.InvalidLHSInForLoop);
								}
								this.nextToken();
								this.reinterpretExpressionAsPattern(init);
								left = init;
								right = this.parseAssignmentExpression();
								init = null;
								forIn = false;
							} else {
								if (this.match(',')) {
									var initSeq = [init];
									while (this.match(',')) {
										this.nextToken();
										initSeq.push(this.isolateCoverGrammar(this.parseAssignmentExpression));
									}
									init = this.finalize(this.startNode(initStartToken), new Node.SequenceExpression(initSeq));
								}
								this.expect(';');
							}
						}
					}
					if (typeof left === 'undefined') {
						if (!this.match(';')) {
							test = this.parseExpression();
						}
						this.expect(';');
						if (!this.match(')')) {
							update = this.parseExpression();
						}
					}
					var body;
					if (!this.match(')') && this.config.tolerant) {
						this.tolerateUnexpectedToken(this.nextToken());
						body = this.finalize(this.createNode(), new Node.EmptyStatement());
					} else {
						this.expect(')');
						var previousInIteration = this.context.inIteration;
						this.context.inIteration = true;
						body = this.isolateCoverGrammar(this.parseStatement);
						this.context.inIteration = previousInIteration;
					}
					return typeof left === 'undefined' ? this.finalize(node, new Node.ForStatement(init, test, update, body)) : forIn ? this.finalize(node, new Node.ForInStatement(left, right, body)) : this.finalize(node, new Node.ForOfStatement(left, right, body));
				};
				// https://tc39.github.io/ecma262/#sec-continue-statement
				Parser.prototype.parseContinueStatement = function () {
					var node = this.createNode();
					this.expectKeyword('continue');
					var label = null;
					if (this.lookahead.type === 3 /* Identifier */ && !this.hasLineTerminator) {
						var id = this.parseVariableIdentifier();
						label = id;
						var key = '$' + id.name;
						if (!Object.prototype.hasOwnProperty.call(this.context.labelSet, key)) {
							this.throwError(messages_1.Messages.UnknownLabel, id.name);
						}
					}
					this.consumeSemicolon();
					if (label === null && !this.context.inIteration) {
						this.throwError(messages_1.Messages.IllegalContinue);
					}
					return this.finalize(node, new Node.ContinueStatement(label));
				};
				// https://tc39.github.io/ecma262/#sec-break-statement
				Parser.prototype.parseBreakStatement = function () {
					var node = this.createNode();
					this.expectKeyword('break');
					var label = null;
					if (this.lookahead.type === 3 /* Identifier */ && !this.hasLineTerminator) {
						var id = this.parseVariableIdentifier();
						var key = '$' + id.name;
						if (!Object.prototype.hasOwnProperty.call(this.context.labelSet, key)) {
							this.throwError(messages_1.Messages.UnknownLabel, id.name);
						}
						label = id;
					}
					this.consumeSemicolon();
					if (label === null && !this.context.inIteration && !this.context.inSwitch) {
						this.throwError(messages_1.Messages.IllegalBreak);
					}
					return this.finalize(node, new Node.BreakStatement(label));
				};
				// https://tc39.github.io/ecma262/#sec-return-statement
				Parser.prototype.parseReturnStatement = function () {
					if (!this.context.inFunctionBody) {
						this.tolerateError(messages_1.Messages.IllegalReturn);
					}
					var node = this.createNode();
					this.expectKeyword('return');
					var hasArgument = !this.match(';') && !this.match('}') && !this.hasLineTerminator && this.lookahead.type !== 2 /* EOF */;
					var argument = hasArgument ? this.parseExpression() : null;
					this.consumeSemicolon();
					return this.finalize(node, new Node.ReturnStatement(argument));
				};
				// https://tc39.github.io/ecma262/#sec-with-statement
				Parser.prototype.parseWithStatement = function () {
					if (this.context.strict) {
						this.tolerateError(messages_1.Messages.StrictModeWith);
					}
					var node = this.createNode();
					var body;
					this.expectKeyword('with');
					this.expect('(');
					var object = this.parseExpression();
					if (!this.match(')') && this.config.tolerant) {
						this.tolerateUnexpectedToken(this.nextToken());
						body = this.finalize(this.createNode(), new Node.EmptyStatement());
					} else {
						this.expect(')');
						body = this.parseStatement();
					}
					return this.finalize(node, new Node.WithStatement(object, body));
				};
				// https://tc39.github.io/ecma262/#sec-switch-statement
				Parser.prototype.parseSwitchCase = function () {
					var node = this.createNode();
					var test;
					if (this.matchKeyword('default')) {
						this.nextToken();
						test = null;
					} else {
						this.expectKeyword('case');
						test = this.parseExpression();
					}
					this.expect(':');
					var consequent = [];
					while (true) {
						if (this.match('}') || this.matchKeyword('default') || this.matchKeyword('case')) {
							break;
						}
						consequent.push(this.parseStatementListItem());
					}
					return this.finalize(node, new Node.SwitchCase(test, consequent));
				};
				Parser.prototype.parseSwitchStatement = function () {
					var node = this.createNode();
					this.expectKeyword('switch');
					this.expect('(');
					var discriminant = this.parseExpression();
					this.expect(')');
					var previousInSwitch = this.context.inSwitch;
					this.context.inSwitch = true;
					var cases = [];
					var defaultFound = false;
					this.expect('{');
					while (true) {
						if (this.match('}')) {
							break;
						}
						var clause = this.parseSwitchCase();
						if (clause.test === null) {
							if (defaultFound) {
								this.throwError(messages_1.Messages.MultipleDefaultsInSwitch);
							}
							defaultFound = true;
						}
						cases.push(clause);
					}
					this.expect('}');
					this.context.inSwitch = previousInSwitch;
					return this.finalize(node, new Node.SwitchStatement(discriminant, cases));
				};
				// https://tc39.github.io/ecma262/#sec-labelled-statements
				Parser.prototype.parseLabelledStatement = function () {
					var node = this.createNode();
					var expr = this.parseExpression();
					var statement;
					if (expr.type === syntax_1.Syntax.Identifier && this.match(':')) {
						this.nextToken();
						var id = expr;
						var key = '$' + id.name;
						if (Object.prototype.hasOwnProperty.call(this.context.labelSet, key)) {
							this.throwError(messages_1.Messages.Redeclaration, 'Label', id.name);
						}
						this.context.labelSet[key] = true;
						var body = void 0;
						if (this.matchKeyword('class')) {
							this.tolerateUnexpectedToken(this.lookahead);
							body = this.parseClassDeclaration();
						} else if (this.matchKeyword('function')) {
							var token = this.lookahead;
							var declaration = this.parseFunctionDeclaration();
							if (this.context.strict) {
								this.tolerateUnexpectedToken(token, messages_1.Messages.StrictFunction);
							} else if (declaration.generator) {
								this.tolerateUnexpectedToken(token, messages_1.Messages.GeneratorInLegacyContext);
							}
							body = declaration;
						} else {
							body = this.parseStatement();
						}
						delete this.context.labelSet[key];
						statement = new Node.LabeledStatement(id, body);
					} else {
						this.consumeSemicolon();
						statement = new Node.ExpressionStatement(expr);
					}
					return this.finalize(node, statement);
				};
				// https://tc39.github.io/ecma262/#sec-throw-statement
				Parser.prototype.parseThrowStatement = function () {
					var node = this.createNode();
					this.expectKeyword('throw');
					if (this.hasLineTerminator) {
						this.throwError(messages_1.Messages.NewlineAfterThrow);
					}
					var argument = this.parseExpression();
					this.consumeSemicolon();
					return this.finalize(node, new Node.ThrowStatement(argument));
				};
				// https://tc39.github.io/ecma262/#sec-try-statement
				Parser.prototype.parseCatchClause = function () {
					var node = this.createNode();
					this.expectKeyword('catch');
					this.expect('(');
					if (this.match(')')) {
						this.throwUnexpectedToken(this.lookahead);
					}
					var params = [];
					var param = this.parsePattern(params);
					var paramMap = {};
					for (var i = 0; i < params.length; i++) {
						var key = '$' + params[i].value;
						if (Object.prototype.hasOwnProperty.call(paramMap, key)) {
							this.tolerateError(messages_1.Messages.DuplicateBinding, params[i].value);
						}
						paramMap[key] = true;
					}
					if (this.context.strict && param.type === syntax_1.Syntax.Identifier) {
						if (this.scanner.isRestrictedWord(param.name)) {
							this.tolerateError(messages_1.Messages.StrictCatchVariable);
						}
					}
					this.expect(')');
					var body = this.parseBlock();
					return this.finalize(node, new Node.CatchClause(param, body));
				};
				Parser.prototype.parseFinallyClause = function () {
					this.expectKeyword('finally');
					return this.parseBlock();
				};
				Parser.prototype.parseTryStatement = function () {
					var node = this.createNode();
					this.expectKeyword('try');
					var block = this.parseBlock();
					var handler = this.matchKeyword('catch') ? this.parseCatchClause() : null;
					var finalizer = this.matchKeyword('finally') ? this.parseFinallyClause() : null;
					if (!handler && !finalizer) {
						this.throwError(messages_1.Messages.NoCatchOrFinally);
					}
					return this.finalize(node, new Node.TryStatement(block, handler, finalizer));
				};
				// https://tc39.github.io/ecma262/#sec-debugger-statement
				Parser.prototype.parseDebuggerStatement = function () {
					var node = this.createNode();
					this.expectKeyword('debugger');
					this.consumeSemicolon();
					return this.finalize(node, new Node.DebuggerStatement());
				};
				// https://tc39.github.io/ecma262/#sec-ecmascript-language-statements-and-declarations
				Parser.prototype.parseStatement = function () {
					var statement;
					switch (this.lookahead.type) {
						case 1 /* BooleanLiteral */:
						case 5 /* NullLiteral */:
						case 6 /* NumericLiteral */:
						case 8 /* StringLiteral */:
						case 10 /* Template */:
						case 9 /* RegularExpression */:
							statement = this.parseExpressionStatement();
							break;
						case 7 /* Punctuator */:
							var value = this.lookahead.value;
							if (value === '{') {
								statement = this.parseBlock();
							} else if (value === '(') {
								statement = this.parseExpressionStatement();
							} else if (value === ';') {
								statement = this.parseEmptyStatement();
							} else {
								statement = this.parseExpressionStatement();
							}
							break;
						case 3 /* Identifier */:
							statement = this.matchAsyncFunction() ? this.parseFunctionDeclaration() : this.parseLabelledStatement();
							break;
						case 4 /* Keyword */:
							switch (this.lookahead.value) {
								case 'break':
									statement = this.parseBreakStatement();
									break;
								case 'continue':
									statement = this.parseContinueStatement();
									break;
								case 'debugger':
									statement = this.parseDebuggerStatement();
									break;
								case 'do':
									statement = this.parseDoWhileStatement();
									break;
								case 'for':
									statement = this.parseForStatement();
									break;
								case 'function':
									statement = this.parseFunctionDeclaration();
									break;
								case 'if':
									statement = this.parseIfStatement();
									break;
								case 'return':
									statement = this.parseReturnStatement();
									break;
								case 'switch':
									statement = this.parseSwitchStatement();
									break;
								case 'throw':
									statement = this.parseThrowStatement();
									break;
								case 'try':
									statement = this.parseTryStatement();
									break;
								case 'var':
									statement = this.parseVariableStatement();
									break;
								case 'while':
									statement = this.parseWhileStatement();
									break;
								case 'with':
									statement = this.parseWithStatement();
									break;
								default:
									statement = this.parseExpressionStatement();
									break;
							}
							break;
						default:
							statement = this.throwUnexpectedToken(this.lookahead);
					}
					return statement;
				};
				// https://tc39.github.io/ecma262/#sec-function-definitions
				Parser.prototype.parseFunctionSourceElements = function () {
					var node = this.createNode();
					this.expect('{');
					var body = this.parseDirectivePrologues();
					var previousLabelSet = this.context.labelSet;
					var previousInIteration = this.context.inIteration;
					var previousInSwitch = this.context.inSwitch;
					var previousInFunctionBody = this.context.inFunctionBody;
					this.context.labelSet = {};
					this.context.inIteration = false;
					this.context.inSwitch = false;
					this.context.inFunctionBody = true;
					while (this.lookahead.type !== 2 /* EOF */) {
						if (this.match('}')) {
							break;
						}
						body.push(this.parseStatementListItem());
					}
					this.expect('}');
					this.context.labelSet = previousLabelSet;
					this.context.inIteration = previousInIteration;
					this.context.inSwitch = previousInSwitch;
					this.context.inFunctionBody = previousInFunctionBody;
					return this.finalize(node, new Node.BlockStatement(body));
				};
				Parser.prototype.validateParam = function (options, param, name) {
					var key = '$' + name;
					if (this.context.strict) {
						if (this.scanner.isRestrictedWord(name)) {
							options.stricted = param;
							options.message = messages_1.Messages.StrictParamName;
						}
						if (Object.prototype.hasOwnProperty.call(options.paramSet, key)) {
							options.stricted = param;
							options.message = messages_1.Messages.StrictParamDupe;
						}
					} else if (!options.firstRestricted) {
						if (this.scanner.isRestrictedWord(name)) {
							options.firstRestricted = param;
							options.message = messages_1.Messages.StrictParamName;
						} else if (this.scanner.isStrictModeReservedWord(name)) {
							options.firstRestricted = param;
							options.message = messages_1.Messages.StrictReservedWord;
						} else if (Object.prototype.hasOwnProperty.call(options.paramSet, key)) {
							options.stricted = param;
							options.message = messages_1.Messages.StrictParamDupe;
						}
					}
					/* istanbul ignore next */
					if (typeof Object.defineProperty === 'function') {
						Object.defineProperty(options.paramSet, key, { value: true, enumerable: true, writable: true, configurable: true });
					} else {
						options.paramSet[key] = true;
					}
				};
				Parser.prototype.parseRestElement = function (params) {
					var node = this.createNode();
					this.expect('...');
					var arg = this.parsePattern(params);
					if (this.match('=')) {
						this.throwError(messages_1.Messages.DefaultRestParameter);
					}
					if (!this.match(')')) {
						this.throwError(messages_1.Messages.ParameterAfterRestParameter);
					}
					return this.finalize(node, new Node.RestElement(arg));
				};
				Parser.prototype.parseFormalParameter = function (options) {
					var params = [];
					var param = this.match('...') ? this.parseRestElement(params) : this.parsePatternWithDefault(params);
					for (var i = 0; i < params.length; i++) {
						this.validateParam(options, params[i], params[i].value);
					}
					options.simple = options.simple && param instanceof Node.Identifier;
					options.params.push(param);
				};
				Parser.prototype.parseFormalParameters = function (firstRestricted) {
					var options;
					options = {
						simple: true,
						params: [],
						firstRestricted: firstRestricted
					};
					this.expect('(');
					if (!this.match(')')) {
						options.paramSet = {};
						while (this.lookahead.type !== 2 /* EOF */) {
							this.parseFormalParameter(options);
							if (this.match(')')) {
								break;
							}
							this.expect(',');
							if (this.match(')')) {
								break;
							}
						}
					}
					this.expect(')');
					return {
						simple: options.simple,
						params: options.params,
						stricted: options.stricted,
						firstRestricted: options.firstRestricted,
						message: options.message
					};
				};
				Parser.prototype.matchAsyncFunction = function () {
					var match = this.matchContextualKeyword('async');
					if (match) {
						var state = this.scanner.saveState();
						this.scanner.scanComments();
						var next = this.scanner.lex();
						this.scanner.restoreState(state);
						match = state.lineNumber === next.lineNumber && next.type === 4 /* Keyword */ && next.value === 'function';
					}
					return match;
				};
				Parser.prototype.parseFunctionDeclaration = function (identifierIsOptional) {
					var node = this.createNode();
					var isAsync = this.matchContextualKeyword('async');
					if (isAsync) {
						this.nextToken();
					}
					this.expectKeyword('function');
					var isGenerator = isAsync ? false : this.match('*');
					if (isGenerator) {
						this.nextToken();
					}
					var message;
					var id = null;
					var firstRestricted = null;
					if (!identifierIsOptional || !this.match('(')) {
						var token = this.lookahead;
						id = this.parseVariableIdentifier();
						if (this.context.strict) {
							if (this.scanner.isRestrictedWord(token.value)) {
								this.tolerateUnexpectedToken(token, messages_1.Messages.StrictFunctionName);
							}
						} else {
							if (this.scanner.isRestrictedWord(token.value)) {
								firstRestricted = token;
								message = messages_1.Messages.StrictFunctionName;
							} else if (this.scanner.isStrictModeReservedWord(token.value)) {
								firstRestricted = token;
								message = messages_1.Messages.StrictReservedWord;
							}
						}
					}
					var previousAllowAwait = this.context.await;
					var previousAllowYield = this.context.allowYield;
					this.context.await = isAsync;
					this.context.allowYield = !isGenerator;
					var formalParameters = this.parseFormalParameters(firstRestricted);
					var params = formalParameters.params;
					var stricted = formalParameters.stricted;
					firstRestricted = formalParameters.firstRestricted;
					if (formalParameters.message) {
						message = formalParameters.message;
					}
					var previousStrict = this.context.strict;
					var previousAllowStrictDirective = this.context.allowStrictDirective;
					this.context.allowStrictDirective = formalParameters.simple;
					var body = this.parseFunctionSourceElements();
					if (this.context.strict && firstRestricted) {
						this.throwUnexpectedToken(firstRestricted, message);
					}
					if (this.context.strict && stricted) {
						this.tolerateUnexpectedToken(stricted, message);
					}
					this.context.strict = previousStrict;
					this.context.allowStrictDirective = previousAllowStrictDirective;
					this.context.await = previousAllowAwait;
					this.context.allowYield = previousAllowYield;
					return isAsync ? this.finalize(node, new Node.AsyncFunctionDeclaration(id, params, body)) : this.finalize(node, new Node.FunctionDeclaration(id, params, body, isGenerator));
				};
				Parser.prototype.parseFunctionExpression = function () {
					var node = this.createNode();
					var isAsync = this.matchContextualKeyword('async');
					if (isAsync) {
						this.nextToken();
					}
					this.expectKeyword('function');
					var isGenerator = isAsync ? false : this.match('*');
					if (isGenerator) {
						this.nextToken();
					}
					var message;
					var id = null;
					var firstRestricted;
					var previousAllowAwait = this.context.await;
					var previousAllowYield = this.context.allowYield;
					this.context.await = isAsync;
					this.context.allowYield = !isGenerator;
					if (!this.match('(')) {
						var token = this.lookahead;
						id = !this.context.strict && !isGenerator && this.matchKeyword('yield') ? this.parseIdentifierName() : this.parseVariableIdentifier();
						if (this.context.strict) {
							if (this.scanner.isRestrictedWord(token.value)) {
								this.tolerateUnexpectedToken(token, messages_1.Messages.StrictFunctionName);
							}
						} else {
							if (this.scanner.isRestrictedWord(token.value)) {
								firstRestricted = token;
								message = messages_1.Messages.StrictFunctionName;
							} else if (this.scanner.isStrictModeReservedWord(token.value)) {
								firstRestricted = token;
								message = messages_1.Messages.StrictReservedWord;
							}
						}
					}
					var formalParameters = this.parseFormalParameters(firstRestricted);
					var params = formalParameters.params;
					var stricted = formalParameters.stricted;
					firstRestricted = formalParameters.firstRestricted;
					if (formalParameters.message) {
						message = formalParameters.message;
					}
					var previousStrict = this.context.strict;
					var previousAllowStrictDirective = this.context.allowStrictDirective;
					this.context.allowStrictDirective = formalParameters.simple;
					var body = this.parseFunctionSourceElements();
					if (this.context.strict && firstRestricted) {
						this.throwUnexpectedToken(firstRestricted, message);
					}
					if (this.context.strict && stricted) {
						this.tolerateUnexpectedToken(stricted, message);
					}
					this.context.strict = previousStrict;
					this.context.allowStrictDirective = previousAllowStrictDirective;
					this.context.await = previousAllowAwait;
					this.context.allowYield = previousAllowYield;
					return isAsync ? this.finalize(node, new Node.AsyncFunctionExpression(id, params, body)) : this.finalize(node, new Node.FunctionExpression(id, params, body, isGenerator));
				};
				// https://tc39.github.io/ecma262/#sec-directive-prologues-and-the-use-strict-directive
				Parser.prototype.parseDirective = function () {
					var token = this.lookahead;
					var node = this.createNode();
					var expr = this.parseExpression();
					var directive = expr.type === syntax_1.Syntax.Literal ? this.getTokenRaw(token).slice(1, -1) : null;
					this.consumeSemicolon();
					return this.finalize(node, directive ? new Node.Directive(expr, directive) : new Node.ExpressionStatement(expr));
				};
				Parser.prototype.parseDirectivePrologues = function () {
					var firstRestricted = null;
					var body = [];
					while (true) {
						var token = this.lookahead;
						if (token.type !== 8 /* StringLiteral */) {
								break;
							}
						var statement = this.parseDirective();
						body.push(statement);
						var directive = statement.directive;
						if (typeof directive !== 'string') {
							break;
						}
						if (directive === 'use strict') {
							this.context.strict = true;
							if (firstRestricted) {
								this.tolerateUnexpectedToken(firstRestricted, messages_1.Messages.StrictOctalLiteral);
							}
							if (!this.context.allowStrictDirective) {
								this.tolerateUnexpectedToken(token, messages_1.Messages.IllegalLanguageModeDirective);
							}
						} else {
							if (!firstRestricted && token.octal) {
								firstRestricted = token;
							}
						}
					}
					return body;
				};
				// https://tc39.github.io/ecma262/#sec-method-definitions
				Parser.prototype.qualifiedPropertyName = function (token) {
					switch (token.type) {
						case 3 /* Identifier */:
						case 8 /* StringLiteral */:
						case 1 /* BooleanLiteral */:
						case 5 /* NullLiteral */:
						case 6 /* NumericLiteral */:
						case 4 /* Keyword */:
							return true;
						case 7 /* Punctuator */:
							return token.value === '[';
						default:
							break;
					}
					return false;
				};
				Parser.prototype.parseGetterMethod = function () {
					var node = this.createNode();
					var isGenerator = false;
					var previousAllowYield = this.context.allowYield;
					this.context.allowYield = false;
					var formalParameters = this.parseFormalParameters();
					if (formalParameters.params.length > 0) {
						this.tolerateError(messages_1.Messages.BadGetterArity);
					}
					var method = this.parsePropertyMethod(formalParameters);
					this.context.allowYield = previousAllowYield;
					return this.finalize(node, new Node.FunctionExpression(null, formalParameters.params, method, isGenerator));
				};
				Parser.prototype.parseSetterMethod = function () {
					var node = this.createNode();
					var isGenerator = false;
					var previousAllowYield = this.context.allowYield;
					this.context.allowYield = false;
					var formalParameters = this.parseFormalParameters();
					if (formalParameters.params.length !== 1) {
						this.tolerateError(messages_1.Messages.BadSetterArity);
					} else if (formalParameters.params[0] instanceof Node.RestElement) {
						this.tolerateError(messages_1.Messages.BadSetterRestParameter);
					}
					var method = this.parsePropertyMethod(formalParameters);
					this.context.allowYield = previousAllowYield;
					return this.finalize(node, new Node.FunctionExpression(null, formalParameters.params, method, isGenerator));
				};
				Parser.prototype.parseGeneratorMethod = function () {
					var node = this.createNode();
					var isGenerator = true;
					var previousAllowYield = this.context.allowYield;
					this.context.allowYield = true;
					var params = this.parseFormalParameters();
					this.context.allowYield = false;
					var method = this.parsePropertyMethod(params);
					this.context.allowYield = previousAllowYield;
					return this.finalize(node, new Node.FunctionExpression(null, params.params, method, isGenerator));
				};
				// https://tc39.github.io/ecma262/#sec-generator-function-definitions
				Parser.prototype.isStartOfExpression = function () {
					var start = true;
					var value = this.lookahead.value;
					switch (this.lookahead.type) {
						case 7 /* Punctuator */:
							start = value === '[' || value === '(' || value === '{' || value === '+' || value === '-' || value === '!' || value === '~' || value === '++' || value === '--' || value === '/' || value === '/='; // regular expression literal
							break;
						case 4 /* Keyword */:
							start = value === 'class' || value === 'delete' || value === 'function' || value === 'let' || value === 'new' || value === 'super' || value === 'this' || value === 'typeof' || value === 'void' || value === 'yield';
							break;
						default:
							break;
					}
					return start;
				};
				Parser.prototype.parseYieldExpression = function () {
					var node = this.createNode();
					this.expectKeyword('yield');
					var argument = null;
					var delegate = false;
					if (!this.hasLineTerminator) {
						var previousAllowYield = this.context.allowYield;
						this.context.allowYield = false;
						delegate = this.match('*');
						if (delegate) {
							this.nextToken();
							argument = this.parseAssignmentExpression();
						} else if (this.isStartOfExpression()) {
							argument = this.parseAssignmentExpression();
						}
						this.context.allowYield = previousAllowYield;
					}
					return this.finalize(node, new Node.YieldExpression(argument, delegate));
				};
				// https://tc39.github.io/ecma262/#sec-class-definitions
				Parser.prototype.parseClassElement = function (hasConstructor) {
					var token = this.lookahead;
					var node = this.createNode();
					var kind = '';
					var key = null;
					var value = null;
					var computed = false;
					var method = false;
					var isStatic = false;
					var isAsync = false;
					if (this.match('*')) {
						this.nextToken();
					} else {
						computed = this.match('[');
						key = this.parseObjectPropertyKey();
						var id = key;
						if (id.name === 'static' && (this.qualifiedPropertyName(this.lookahead) || this.match('*'))) {
							token = this.lookahead;
							isStatic = true;
							computed = this.match('[');
							if (this.match('*')) {
								this.nextToken();
							} else {
								key = this.parseObjectPropertyKey();
							}
						}
						if (token.type === 3 /* Identifier */ && !this.hasLineTerminator && token.value === 'async') {
							var punctuator = this.lookahead.value;
							if (punctuator !== ':' && punctuator !== '(' && punctuator !== '*') {
								isAsync = true;
								token = this.lookahead;
								key = this.parseObjectPropertyKey();
								if (token.type === 3 /* Identifier */) {
										if (token.value === 'get' || token.value === 'set') {
											this.tolerateUnexpectedToken(token);
										} else if (token.value === 'constructor') {
											this.tolerateUnexpectedToken(token, messages_1.Messages.ConstructorIsAsync);
										}
									}
							}
						}
					}
					var lookaheadPropertyKey = this.qualifiedPropertyName(this.lookahead);
					if (token.type === 3 /* Identifier */) {
							if (token.value === 'get' && lookaheadPropertyKey) {
								kind = 'get';
								computed = this.match('[');
								key = this.parseObjectPropertyKey();
								this.context.allowYield = false;
								value = this.parseGetterMethod();
							} else if (token.value === 'set' && lookaheadPropertyKey) {
								kind = 'set';
								computed = this.match('[');
								key = this.parseObjectPropertyKey();
								value = this.parseSetterMethod();
							}
						} else if (token.type === 7 /* Punctuator */ && token.value === '*' && lookaheadPropertyKey) {
						kind = 'init';
						computed = this.match('[');
						key = this.parseObjectPropertyKey();
						value = this.parseGeneratorMethod();
						method = true;
					}
					if (!kind && key && this.match('(')) {
						kind = 'init';
						value = isAsync ? this.parsePropertyMethodAsyncFunction() : this.parsePropertyMethodFunction();
						method = true;
					}
					if (!kind) {
						this.throwUnexpectedToken(this.lookahead);
					}
					if (kind === 'init') {
						kind = 'method';
					}
					if (!computed) {
						if (isStatic && this.isPropertyKey(key, 'prototype')) {
							this.throwUnexpectedToken(token, messages_1.Messages.StaticPrototype);
						}
						if (!isStatic && this.isPropertyKey(key, 'constructor')) {
							if (kind !== 'method' || !method || value && value.generator) {
								this.throwUnexpectedToken(token, messages_1.Messages.ConstructorSpecialMethod);
							}
							if (hasConstructor.value) {
								this.throwUnexpectedToken(token, messages_1.Messages.DuplicateConstructor);
							} else {
								hasConstructor.value = true;
							}
							kind = 'constructor';
						}
					}
					return this.finalize(node, new Node.MethodDefinition(key, computed, value, kind, isStatic));
				};
				Parser.prototype.parseClassElementList = function () {
					var body = [];
					var hasConstructor = { value: false };
					this.expect('{');
					while (!this.match('}')) {
						if (this.match(';')) {
							this.nextToken();
						} else {
							body.push(this.parseClassElement(hasConstructor));
						}
					}
					this.expect('}');
					return body;
				};
				Parser.prototype.parseClassBody = function () {
					var node = this.createNode();
					var elementList = this.parseClassElementList();
					return this.finalize(node, new Node.ClassBody(elementList));
				};
				Parser.prototype.parseClassDeclaration = function (identifierIsOptional) {
					var node = this.createNode();
					var previousStrict = this.context.strict;
					this.context.strict = true;
					this.expectKeyword('class');
					var id = identifierIsOptional && this.lookahead.type !== 3 /* Identifier */ ? null : this.parseVariableIdentifier();
					var superClass = null;
					if (this.matchKeyword('extends')) {
						this.nextToken();
						superClass = this.isolateCoverGrammar(this.parseLeftHandSideExpressionAllowCall);
					}
					var classBody = this.parseClassBody();
					this.context.strict = previousStrict;
					return this.finalize(node, new Node.ClassDeclaration(id, superClass, classBody));
				};
				Parser.prototype.parseClassExpression = function () {
					var node = this.createNode();
					var previousStrict = this.context.strict;
					this.context.strict = true;
					this.expectKeyword('class');
					var id = this.lookahead.type === 3 /* Identifier */ ? this.parseVariableIdentifier() : null;
					var superClass = null;
					if (this.matchKeyword('extends')) {
						this.nextToken();
						superClass = this.isolateCoverGrammar(this.parseLeftHandSideExpressionAllowCall);
					}
					var classBody = this.parseClassBody();
					this.context.strict = previousStrict;
					return this.finalize(node, new Node.ClassExpression(id, superClass, classBody));
				};
				// https://tc39.github.io/ecma262/#sec-scripts
				// https://tc39.github.io/ecma262/#sec-modules
				Parser.prototype.parseModule = function () {
					this.context.strict = true;
					this.context.isModule = true;
					var node = this.createNode();
					var body = this.parseDirectivePrologues();
					while (this.lookahead.type !== 2 /* EOF */) {
						body.push(this.parseStatementListItem());
					}
					return this.finalize(node, new Node.Module(body));
				};
				Parser.prototype.parseScript = function () {
					var node = this.createNode();
					var body = this.parseDirectivePrologues();
					while (this.lookahead.type !== 2 /* EOF */) {
						body.push(this.parseStatementListItem());
					}
					return this.finalize(node, new Node.Script(body));
				};
				// https://tc39.github.io/ecma262/#sec-imports
				Parser.prototype.parseModuleSpecifier = function () {
					var node = this.createNode();
					if (this.lookahead.type !== 8 /* StringLiteral */) {
							this.throwError(messages_1.Messages.InvalidModuleSpecifier);
						}
					var token = this.nextToken();
					var raw = this.getTokenRaw(token);
					return this.finalize(node, new Node.Literal(token.value, raw));
				};
				// import {<foo as bar>} ...;
				Parser.prototype.parseImportSpecifier = function () {
					var node = this.createNode();
					var imported;
					var local;
					if (this.lookahead.type === 3 /* Identifier */) {
							imported = this.parseVariableIdentifier();
							local = imported;
							if (this.matchContextualKeyword('as')) {
								this.nextToken();
								local = this.parseVariableIdentifier();
							}
						} else {
						imported = this.parseIdentifierName();
						local = imported;
						if (this.matchContextualKeyword('as')) {
							this.nextToken();
							local = this.parseVariableIdentifier();
						} else {
							this.throwUnexpectedToken(this.nextToken());
						}
					}
					return this.finalize(node, new Node.ImportSpecifier(local, imported));
				};
				// {foo, bar as bas}
				Parser.prototype.parseNamedImports = function () {
					this.expect('{');
					var specifiers = [];
					while (!this.match('}')) {
						specifiers.push(this.parseImportSpecifier());
						if (!this.match('}')) {
							this.expect(',');
						}
					}
					this.expect('}');
					return specifiers;
				};
				// import <foo> ...;
				Parser.prototype.parseImportDefaultSpecifier = function () {
					var node = this.createNode();
					var local = this.parseIdentifierName();
					return this.finalize(node, new Node.ImportDefaultSpecifier(local));
				};
				// import <* as foo> ...;
				Parser.prototype.parseImportNamespaceSpecifier = function () {
					var node = this.createNode();
					this.expect('*');
					if (!this.matchContextualKeyword('as')) {
						this.throwError(messages_1.Messages.NoAsAfterImportNamespace);
					}
					this.nextToken();
					var local = this.parseIdentifierName();
					return this.finalize(node, new Node.ImportNamespaceSpecifier(local));
				};
				Parser.prototype.parseImportDeclaration = function () {
					if (this.context.inFunctionBody) {
						this.throwError(messages_1.Messages.IllegalImportDeclaration);
					}
					var node = this.createNode();
					this.expectKeyword('import');
					var src;
					var specifiers = [];
					if (this.lookahead.type === 8 /* StringLiteral */) {
							// import 'foo';
							src = this.parseModuleSpecifier();
						} else {
						if (this.match('{')) {
							// import {bar}
							specifiers = specifiers.concat(this.parseNamedImports());
						} else if (this.match('*')) {
							// import * as foo
							specifiers.push(this.parseImportNamespaceSpecifier());
						} else if (this.isIdentifierName(this.lookahead) && !this.matchKeyword('default')) {
							// import foo
							specifiers.push(this.parseImportDefaultSpecifier());
							if (this.match(',')) {
								this.nextToken();
								if (this.match('*')) {
									// import foo, * as foo
									specifiers.push(this.parseImportNamespaceSpecifier());
								} else if (this.match('{')) {
									// import foo, {bar}
									specifiers = specifiers.concat(this.parseNamedImports());
								} else {
									this.throwUnexpectedToken(this.lookahead);
								}
							}
						} else {
							this.throwUnexpectedToken(this.nextToken());
						}
						if (!this.matchContextualKeyword('from')) {
							var message = this.lookahead.value ? messages_1.Messages.UnexpectedToken : messages_1.Messages.MissingFromClause;
							this.throwError(message, this.lookahead.value);
						}
						this.nextToken();
						src = this.parseModuleSpecifier();
					}
					this.consumeSemicolon();
					return this.finalize(node, new Node.ImportDeclaration(specifiers, src));
				};
				// https://tc39.github.io/ecma262/#sec-exports
				Parser.prototype.parseExportSpecifier = function () {
					var node = this.createNode();
					var local = this.parseIdentifierName();
					var exported = local;
					if (this.matchContextualKeyword('as')) {
						this.nextToken();
						exported = this.parseIdentifierName();
					}
					return this.finalize(node, new Node.ExportSpecifier(local, exported));
				};
				Parser.prototype.parseExportDeclaration = function () {
					if (this.context.inFunctionBody) {
						this.throwError(messages_1.Messages.IllegalExportDeclaration);
					}
					var node = this.createNode();
					this.expectKeyword('export');
					var exportDeclaration;
					if (this.matchKeyword('default')) {
						// export default ...
						this.nextToken();
						if (this.matchKeyword('function')) {
							// export default function foo () {}
							// export default function () {}
							var declaration = this.parseFunctionDeclaration(true);
							exportDeclaration = this.finalize(node, new Node.ExportDefaultDeclaration(declaration));
						} else if (this.matchKeyword('class')) {
							// export default class foo {}
							var declaration = this.parseClassDeclaration(true);
							exportDeclaration = this.finalize(node, new Node.ExportDefaultDeclaration(declaration));
						} else if (this.matchContextualKeyword('async')) {
							// export default async function f () {}
							// export default async function () {}
							// export default async x => x
							var declaration = this.matchAsyncFunction() ? this.parseFunctionDeclaration(true) : this.parseAssignmentExpression();
							exportDeclaration = this.finalize(node, new Node.ExportDefaultDeclaration(declaration));
						} else {
							if (this.matchContextualKeyword('from')) {
								this.throwError(messages_1.Messages.UnexpectedToken, this.lookahead.value);
							}
							// export default {};
							// export default [];
							// export default (1 + 2);
							var declaration = this.match('{') ? this.parseObjectInitializer() : this.match('[') ? this.parseArrayInitializer() : this.parseAssignmentExpression();
							this.consumeSemicolon();
							exportDeclaration = this.finalize(node, new Node.ExportDefaultDeclaration(declaration));
						}
					} else if (this.match('*')) {
						// export * from 'foo';
						this.nextToken();
						if (!this.matchContextualKeyword('from')) {
							var message = this.lookahead.value ? messages_1.Messages.UnexpectedToken : messages_1.Messages.MissingFromClause;
							this.throwError(message, this.lookahead.value);
						}
						this.nextToken();
						var src = this.parseModuleSpecifier();
						this.consumeSemicolon();
						exportDeclaration = this.finalize(node, new Node.ExportAllDeclaration(src));
					} else if (this.lookahead.type === 4 /* Keyword */) {
							// export var f = 1;
							var declaration = void 0;
							switch (this.lookahead.value) {
								case 'let':
								case 'const':
									declaration = this.parseLexicalDeclaration({ inFor: false });
									break;
								case 'var':
								case 'class':
								case 'function':
									declaration = this.parseStatementListItem();
									break;
								default:
									this.throwUnexpectedToken(this.lookahead);
							}
							exportDeclaration = this.finalize(node, new Node.ExportNamedDeclaration(declaration, [], null));
						} else if (this.matchAsyncFunction()) {
						var declaration = this.parseFunctionDeclaration();
						exportDeclaration = this.finalize(node, new Node.ExportNamedDeclaration(declaration, [], null));
					} else {
						var specifiers = [];
						var source = null;
						var isExportFromIdentifier = false;
						this.expect('{');
						while (!this.match('}')) {
							isExportFromIdentifier = isExportFromIdentifier || this.matchKeyword('default');
							specifiers.push(this.parseExportSpecifier());
							if (!this.match('}')) {
								this.expect(',');
							}
						}
						this.expect('}');
						if (this.matchContextualKeyword('from')) {
							// export {default} from 'foo';
							// export {foo} from 'foo';
							this.nextToken();
							source = this.parseModuleSpecifier();
							this.consumeSemicolon();
						} else if (isExportFromIdentifier) {
							// export {default}; // missing fromClause
							var message = this.lookahead.value ? messages_1.Messages.UnexpectedToken : messages_1.Messages.MissingFromClause;
							this.throwError(message, this.lookahead.value);
						} else {
							// export {foo};
							this.consumeSemicolon();
						}
						exportDeclaration = this.finalize(node, new Node.ExportNamedDeclaration(null, specifiers, source));
					}
					return exportDeclaration;
				};
				return Parser;
			}();
			exports.Parser = Parser;

			/***/
		},
		/* 9 */
		/***/function (module, exports) {

			"use strict";
			// Ensure the condition is true, otherwise throw an error.
			// This is only to have a better contract semantic, i.e. another safety net
			// to catch a logic error. The condition shall be fulfilled in normal case.
			// Do NOT use this to enforce a certain condition on any user input.

			Object.defineProperty(exports, "__esModule", { value: true });
			function assert(condition, message) {
				/* istanbul ignore if */
				if (!condition) {
					throw new Error('ASSERT: ' + message);
				}
			}
			exports.assert = assert;

			/***/
		},
		/* 10 */
		/***/function (module, exports) {

			"use strict";
			/* tslint:disable:max-classes-per-file */

			Object.defineProperty(exports, "__esModule", { value: true });
			var ErrorHandler = function () {
				function ErrorHandler() {
					this.errors = [];
					this.tolerant = false;
				}
				ErrorHandler.prototype.recordError = function (error) {
					this.errors.push(error);
				};
				ErrorHandler.prototype.tolerate = function (error) {
					if (this.tolerant) {
						this.recordError(error);
					} else {
						throw error;
					}
				};
				ErrorHandler.prototype.constructError = function (msg, column) {
					var error = new Error(msg);
					try {
						throw error;
					} catch (base) {
						/* istanbul ignore else */
						if (Object.create && Object.defineProperty) {
							error = Object.create(base);
							Object.defineProperty(error, 'column', { value: column });
						}
					}
					/* istanbul ignore next */
					return error;
				};
				ErrorHandler.prototype.createError = function (index, line, col, description) {
					var msg = 'Line ' + line + ': ' + description;
					var error = this.constructError(msg, col);
					error.index = index;
					error.lineNumber = line;
					error.description = description;
					return error;
				};
				ErrorHandler.prototype.throwError = function (index, line, col, description) {
					throw this.createError(index, line, col, description);
				};
				ErrorHandler.prototype.tolerateError = function (index, line, col, description) {
					var error = this.createError(index, line, col, description);
					if (this.tolerant) {
						this.recordError(error);
					} else {
						throw error;
					}
				};
				return ErrorHandler;
			}();
			exports.ErrorHandler = ErrorHandler;

			/***/
		},
		/* 11 */
		/***/function (module, exports) {

			"use strict";

			Object.defineProperty(exports, "__esModule", { value: true });
			// Error messages should be identical to V8.
			exports.Messages = {
				BadGetterArity: 'Getter must not have any formal parameters',
				BadSetterArity: 'Setter must have exactly one formal parameter',
				BadSetterRestParameter: 'Setter function argument must not be a rest parameter',
				ConstructorIsAsync: 'Class constructor may not be an async method',
				ConstructorSpecialMethod: 'Class constructor may not be an accessor',
				DeclarationMissingInitializer: 'Missing initializer in %0 declaration',
				DefaultRestParameter: 'Unexpected token =',
				DuplicateBinding: 'Duplicate binding %0',
				DuplicateConstructor: 'A class may only have one constructor',
				DuplicateProtoProperty: 'Duplicate __proto__ fields are not allowed in object literals',
				ForInOfLoopInitializer: '%0 loop variable declaration may not have an initializer',
				GeneratorInLegacyContext: 'Generator declarations are not allowed in legacy contexts',
				IllegalBreak: 'Illegal break statement',
				IllegalContinue: 'Illegal continue statement',
				IllegalExportDeclaration: 'Unexpected token',
				IllegalImportDeclaration: 'Unexpected token',
				IllegalLanguageModeDirective: 'Illegal \'use strict\' directive in function with non-simple parameter list',
				IllegalReturn: 'Illegal return statement',
				InvalidEscapedReservedWord: 'Keyword must not contain escaped characters',
				InvalidHexEscapeSequence: 'Invalid hexadecimal escape sequence',
				InvalidLHSInAssignment: 'Invalid left-hand side in assignment',
				InvalidLHSInForIn: 'Invalid left-hand side in for-in',
				InvalidLHSInForLoop: 'Invalid left-hand side in for-loop',
				InvalidModuleSpecifier: 'Unexpected token',
				InvalidRegExp: 'Invalid regular expression',
				LetInLexicalBinding: 'let is disallowed as a lexically bound name',
				MissingFromClause: 'Unexpected token',
				MultipleDefaultsInSwitch: 'More than one default clause in switch statement',
				NewlineAfterThrow: 'Illegal newline after throw',
				NoAsAfterImportNamespace: 'Unexpected token',
				NoCatchOrFinally: 'Missing catch or finally after try',
				ParameterAfterRestParameter: 'Rest parameter must be last formal parameter',
				Redeclaration: '%0 \'%1\' has already been declared',
				StaticPrototype: 'Classes may not have static property named prototype',
				StrictCatchVariable: 'Catch variable may not be eval or arguments in strict mode',
				StrictDelete: 'Delete of an unqualified identifier in strict mode.',
				StrictFunction: 'In strict mode code, functions can only be declared at top level or inside a block',
				StrictFunctionName: 'Function name may not be eval or arguments in strict mode',
				StrictLHSAssignment: 'Assignment to eval or arguments is not allowed in strict mode',
				StrictLHSPostfix: 'Postfix increment/decrement may not have eval or arguments operand in strict mode',
				StrictLHSPrefix: 'Prefix increment/decrement may not have eval or arguments operand in strict mode',
				StrictModeWith: 'Strict mode code may not include a with statement',
				StrictOctalLiteral: 'Octal literals are not allowed in strict mode.',
				StrictParamDupe: 'Strict mode function may not have duplicate parameter names',
				StrictParamName: 'Parameter name eval or arguments is not allowed in strict mode',
				StrictReservedWord: 'Use of future reserved word in strict mode',
				StrictVarName: 'Variable name may not be eval or arguments in strict mode',
				TemplateOctalLiteral: 'Octal literals are not allowed in template strings.',
				UnexpectedEOS: 'Unexpected end of input',
				UnexpectedIdentifier: 'Unexpected identifier',
				UnexpectedNumber: 'Unexpected number',
				UnexpectedReserved: 'Unexpected reserved word',
				UnexpectedString: 'Unexpected string',
				UnexpectedTemplate: 'Unexpected quasi %0',
				UnexpectedToken: 'Unexpected token %0',
				UnexpectedTokenIllegal: 'Unexpected token ILLEGAL',
				UnknownLabel: 'Undefined label \'%0\'',
				UnterminatedRegExp: 'Invalid regular expression: missing /'
			};

			/***/
		},
		/* 12 */
		/***/function (module, exports, __webpack_require__) {

			"use strict";

			Object.defineProperty(exports, "__esModule", { value: true });
			var assert_1 = __webpack_require__(9);
			var character_1 = __webpack_require__(4);
			var messages_1 = __webpack_require__(11);
			function hexValue(ch) {
				return '0123456789abcdef'.indexOf(ch.toLowerCase());
			}
			function octalValue(ch) {
				return '01234567'.indexOf(ch);
			}
			var Scanner = function () {
				function Scanner(code, handler) {
					this.source = code;
					this.errorHandler = handler;
					this.trackComment = false;
					this.length = code.length;
					this.index = 0;
					this.lineNumber = code.length > 0 ? 1 : 0;
					this.lineStart = 0;
					this.curlyStack = [];
				}
				Scanner.prototype.saveState = function () {
					return {
						index: this.index,
						lineNumber: this.lineNumber,
						lineStart: this.lineStart
					};
				};
				Scanner.prototype.restoreState = function (state) {
					this.index = state.index;
					this.lineNumber = state.lineNumber;
					this.lineStart = state.lineStart;
				};
				Scanner.prototype.eof = function () {
					return this.index >= this.length;
				};
				Scanner.prototype.throwUnexpectedToken = function (message) {
					if (message === void 0) {
						message = messages_1.Messages.UnexpectedTokenIllegal;
					}
					return this.errorHandler.throwError(this.index, this.lineNumber, this.index - this.lineStart + 1, message);
				};
				Scanner.prototype.tolerateUnexpectedToken = function (message) {
					if (message === void 0) {
						message = messages_1.Messages.UnexpectedTokenIllegal;
					}
					this.errorHandler.tolerateError(this.index, this.lineNumber, this.index - this.lineStart + 1, message);
				};
				// https://tc39.github.io/ecma262/#sec-comments
				Scanner.prototype.skipSingleLineComment = function (offset) {
					var comments = [];
					var start, loc;
					if (this.trackComment) {
						comments = [];
						start = this.index - offset;
						loc = {
							start: {
								line: this.lineNumber,
								column: this.index - this.lineStart - offset
							},
							end: {}
						};
					}
					while (!this.eof()) {
						var ch = this.source.charCodeAt(this.index);
						++this.index;
						if (character_1.Character.isLineTerminator(ch)) {
							if (this.trackComment) {
								loc.end = {
									line: this.lineNumber,
									column: this.index - this.lineStart - 1
								};
								var entry = {
									multiLine: false,
									slice: [start + offset, this.index - 1],
									range: [start, this.index - 1],
									loc: loc
								};
								comments.push(entry);
							}
							if (ch === 13 && this.source.charCodeAt(this.index) === 10) {
								++this.index;
							}
							++this.lineNumber;
							this.lineStart = this.index;
							return comments;
						}
					}
					if (this.trackComment) {
						loc.end = {
							line: this.lineNumber,
							column: this.index - this.lineStart
						};
						var entry = {
							multiLine: false,
							slice: [start + offset, this.index],
							range: [start, this.index],
							loc: loc
						};
						comments.push(entry);
					}
					return comments;
				};
				Scanner.prototype.skipMultiLineComment = function () {
					var comments = [];
					var start, loc;
					if (this.trackComment) {
						comments = [];
						start = this.index - 2;
						loc = {
							start: {
								line: this.lineNumber,
								column: this.index - this.lineStart - 2
							},
							end: {}
						};
					}
					while (!this.eof()) {
						var ch = this.source.charCodeAt(this.index);
						if (character_1.Character.isLineTerminator(ch)) {
							if (ch === 0x0D && this.source.charCodeAt(this.index + 1) === 0x0A) {
								++this.index;
							}
							++this.lineNumber;
							++this.index;
							this.lineStart = this.index;
						} else if (ch === 0x2A) {
							// Block comment ends with '*/'.
							if (this.source.charCodeAt(this.index + 1) === 0x2F) {
								this.index += 2;
								if (this.trackComment) {
									loc.end = {
										line: this.lineNumber,
										column: this.index - this.lineStart
									};
									var entry = {
										multiLine: true,
										slice: [start + 2, this.index - 2],
										range: [start, this.index],
										loc: loc
									};
									comments.push(entry);
								}
								return comments;
							}
							++this.index;
						} else {
							++this.index;
						}
					}
					// Ran off the end of the file - the whole thing is a comment
					if (this.trackComment) {
						loc.end = {
							line: this.lineNumber,
							column: this.index - this.lineStart
						};
						var entry = {
							multiLine: true,
							slice: [start + 2, this.index],
							range: [start, this.index],
							loc: loc
						};
						comments.push(entry);
					}
					this.tolerateUnexpectedToken();
					return comments;
				};
				Scanner.prototype.scanComments = function () {
					var comments;
					if (this.trackComment) {
						comments = [];
					}
					var start = this.index === 0;
					while (!this.eof()) {
						var ch = this.source.charCodeAt(this.index);
						if (character_1.Character.isWhiteSpace(ch)) {
							++this.index;
						} else if (character_1.Character.isLineTerminator(ch)) {
							++this.index;
							if (ch === 0x0D && this.source.charCodeAt(this.index) === 0x0A) {
								++this.index;
							}
							++this.lineNumber;
							this.lineStart = this.index;
							start = true;
						} else if (ch === 0x2F) {
							ch = this.source.charCodeAt(this.index + 1);
							if (ch === 0x2F) {
								this.index += 2;
								var comment = this.skipSingleLineComment(2);
								if (this.trackComment) {
									comments = comments.concat(comment);
								}
								start = true;
							} else if (ch === 0x2A) {
								this.index += 2;
								var comment = this.skipMultiLineComment();
								if (this.trackComment) {
									comments = comments.concat(comment);
								}
							} else {
								break;
							}
						} else if (start && ch === 0x2D) {
							// U+003E is '>'
							if (this.source.charCodeAt(this.index + 1) === 0x2D && this.source.charCodeAt(this.index + 2) === 0x3E) {
								// '-->' is a single-line comment
								this.index += 3;
								var comment = this.skipSingleLineComment(3);
								if (this.trackComment) {
									comments = comments.concat(comment);
								}
							} else {
								break;
							}
						} else if (ch === 0x3C) {
							if (this.source.slice(this.index + 1, this.index + 4) === '!--') {
								this.index += 4; // `<!--`
								var comment = this.skipSingleLineComment(4);
								if (this.trackComment) {
									comments = comments.concat(comment);
								}
							} else {
								break;
							}
						} else {
							break;
						}
					}
					return comments;
				};
				// https://tc39.github.io/ecma262/#sec-future-reserved-words
				Scanner.prototype.isFutureReservedWord = function (id) {
					switch (id) {
						case 'enum':
						case 'export':
						case 'import':
						case 'super':
							return true;
						default:
							return false;
					}
				};
				Scanner.prototype.isStrictModeReservedWord = function (id) {
					switch (id) {
						case 'implements':
						case 'interface':
						case 'package':
						case 'private':
						case 'protected':
						case 'public':
						case 'static':
						case 'yield':
						case 'let':
							return true;
						default:
							return false;
					}
				};
				Scanner.prototype.isRestrictedWord = function (id) {
					return id === 'eval' || id === 'arguments';
				};
				// https://tc39.github.io/ecma262/#sec-keywords
				Scanner.prototype.isKeyword = function (id) {
					switch (id.length) {
						case 2:
							return id === 'if' || id === 'in' || id === 'do';
						case 3:
							return id === 'var' || id === 'for' || id === 'new' || id === 'try' || id === 'let';
						case 4:
							return id === 'this' || id === 'else' || id === 'case' || id === 'void' || id === 'with' || id === 'enum';
						case 5:
							return id === 'while' || id === 'break' || id === 'catch' || id === 'throw' || id === 'const' || id === 'yield' || id === 'class' || id === 'super';
						case 6:
							return id === 'return' || id === 'typeof' || id === 'delete' || id === 'switch' || id === 'export' || id === 'import';
						case 7:
							return id === 'default' || id === 'finally' || id === 'extends';
						case 8:
							return id === 'function' || id === 'continue' || id === 'debugger';
						case 10:
							return id === 'instanceof';
						default:
							return false;
					}
				};
				Scanner.prototype.codePointAt = function (i) {
					var cp = this.source.charCodeAt(i);
					if (cp >= 0xD800 && cp <= 0xDBFF) {
						var second = this.source.charCodeAt(i + 1);
						if (second >= 0xDC00 && second <= 0xDFFF) {
							var first = cp;
							cp = (first - 0xD800) * 0x400 + second - 0xDC00 + 0x10000;
						}
					}
					return cp;
				};
				Scanner.prototype.scanHexEscape = function (prefix) {
					var len = prefix === 'u' ? 4 : 2;
					var code = 0;
					for (var i = 0; i < len; ++i) {
						if (!this.eof() && character_1.Character.isHexDigit(this.source.charCodeAt(this.index))) {
							code = code * 16 + hexValue(this.source[this.index++]);
						} else {
							return null;
						}
					}
					return String.fromCharCode(code);
				};
				Scanner.prototype.scanUnicodeCodePointEscape = function () {
					var ch = this.source[this.index];
					var code = 0;
					// At least, one hex digit is required.
					if (ch === '}') {
						this.throwUnexpectedToken();
					}
					while (!this.eof()) {
						ch = this.source[this.index++];
						if (!character_1.Character.isHexDigit(ch.charCodeAt(0))) {
							break;
						}
						code = code * 16 + hexValue(ch);
					}
					if (code > 0x10FFFF || ch !== '}') {
						this.throwUnexpectedToken();
					}
					return character_1.Character.fromCodePoint(code);
				};
				Scanner.prototype.getIdentifier = function () {
					var start = this.index++;
					while (!this.eof()) {
						var ch = this.source.charCodeAt(this.index);
						if (ch === 0x5C) {
							// Blackslash (U+005C) marks Unicode escape sequence.
							this.index = start;
							return this.getComplexIdentifier();
						} else if (ch >= 0xD800 && ch < 0xDFFF) {
							// Need to handle surrogate pairs.
							this.index = start;
							return this.getComplexIdentifier();
						}
						if (character_1.Character.isIdentifierPart(ch)) {
							++this.index;
						} else {
							break;
						}
					}
					return this.source.slice(start, this.index);
				};
				Scanner.prototype.getComplexIdentifier = function () {
					var cp = this.codePointAt(this.index);
					var id = character_1.Character.fromCodePoint(cp);
					this.index += id.length;
					// '\u' (U+005C, U+0075) denotes an escaped character.
					var ch;
					if (cp === 0x5C) {
						if (this.source.charCodeAt(this.index) !== 0x75) {
							this.throwUnexpectedToken();
						}
						++this.index;
						if (this.source[this.index] === '{') {
							++this.index;
							ch = this.scanUnicodeCodePointEscape();
						} else {
							ch = this.scanHexEscape('u');
							if (ch === null || ch === '\\' || !character_1.Character.isIdentifierStart(ch.charCodeAt(0))) {
								this.throwUnexpectedToken();
							}
						}
						id = ch;
					}
					while (!this.eof()) {
						cp = this.codePointAt(this.index);
						if (!character_1.Character.isIdentifierPart(cp)) {
							break;
						}
						ch = character_1.Character.fromCodePoint(cp);
						id += ch;
						this.index += ch.length;
						// '\u' (U+005C, U+0075) denotes an escaped character.
						if (cp === 0x5C) {
							id = id.substr(0, id.length - 1);
							if (this.source.charCodeAt(this.index) !== 0x75) {
								this.throwUnexpectedToken();
							}
							++this.index;
							if (this.source[this.index] === '{') {
								++this.index;
								ch = this.scanUnicodeCodePointEscape();
							} else {
								ch = this.scanHexEscape('u');
								if (ch === null || ch === '\\' || !character_1.Character.isIdentifierPart(ch.charCodeAt(0))) {
									this.throwUnexpectedToken();
								}
							}
							id += ch;
						}
					}
					return id;
				};
				Scanner.prototype.octalToDecimal = function (ch) {
					// \0 is not octal escape sequence
					var octal = ch !== '0';
					var code = octalValue(ch);
					if (!this.eof() && character_1.Character.isOctalDigit(this.source.charCodeAt(this.index))) {
						octal = true;
						code = code * 8 + octalValue(this.source[this.index++]);
						// 3 digits are only allowed when string starts
						// with 0, 1, 2, 3
						if ('0123'.indexOf(ch) >= 0 && !this.eof() && character_1.Character.isOctalDigit(this.source.charCodeAt(this.index))) {
							code = code * 8 + octalValue(this.source[this.index++]);
						}
					}
					return {
						code: code,
						octal: octal
					};
				};
				// https://tc39.github.io/ecma262/#sec-names-and-keywords
				Scanner.prototype.scanIdentifier = function () {
					var type;
					var start = this.index;
					// Backslash (U+005C) starts an escaped character.
					var id = this.source.charCodeAt(start) === 0x5C ? this.getComplexIdentifier() : this.getIdentifier();
					// There is no keyword or literal with only one character.
					// Thus, it must be an identifier.
					if (id.length === 1) {
						type = 3 /* Identifier */;
					} else if (this.isKeyword(id)) {
						type = 4 /* Keyword */;
					} else if (id === 'null') {
						type = 5 /* NullLiteral */;
					} else if (id === 'true' || id === 'false') {
						type = 1 /* BooleanLiteral */;
					} else {
						type = 3 /* Identifier */;
					}
					if (type !== 3 /* Identifier */ && start + id.length !== this.index) {
						var restore = this.index;
						this.index = start;
						this.tolerateUnexpectedToken(messages_1.Messages.InvalidEscapedReservedWord);
						this.index = restore;
					}
					return {
						type: type,
						value: id,
						lineNumber: this.lineNumber,
						lineStart: this.lineStart,
						start: start,
						end: this.index
					};
				};
				// https://tc39.github.io/ecma262/#sec-punctuators
				Scanner.prototype.scanPunctuator = function () {
					var start = this.index;
					// Check for most common single-character punctuators.
					var str = this.source[this.index];
					switch (str) {
						case '(':
						case '{':
							if (str === '{') {
								this.curlyStack.push('{');
							}
							++this.index;
							break;
						case '.':
							++this.index;
							if (this.source[this.index] === '.' && this.source[this.index + 1] === '.') {
								// Spread operator: ...
								this.index += 2;
								str = '...';
							}
							break;
						case '}':
							++this.index;
							this.curlyStack.pop();
							break;
						case ')':
						case ';':
						case ',':
						case '[':
						case ']':
						case ':':
						case '?':
						case '~':
							++this.index;
							break;
						default:
							// 4-character punctuator.
							str = this.source.substr(this.index, 4);
							if (str === '>>>=') {
								this.index += 4;
							} else {
								// 3-character punctuators.
								str = str.substr(0, 3);
								if (str === '===' || str === '!==' || str === '>>>' || str === '<<=' || str === '>>=' || str === '**=') {
									this.index += 3;
								} else {
									// 2-character punctuators.
									str = str.substr(0, 2);
									if (str === '&&' || str === '||' || str === '==' || str === '!=' || str === '+=' || str === '-=' || str === '*=' || str === '/=' || str === '++' || str === '--' || str === '<<' || str === '>>' || str === '&=' || str === '|=' || str === '^=' || str === '%=' || str === '<=' || str === '>=' || str === '=>' || str === '**') {
										this.index += 2;
									} else {
										// 1-character punctuators.
										str = this.source[this.index];
										if ('<>=!+-*%&|^/'.indexOf(str) >= 0) {
											++this.index;
										}
									}
								}
							}
					}
					if (this.index === start) {
						this.throwUnexpectedToken();
					}
					return {
						type: 7 /* Punctuator */
						, value: str,
						lineNumber: this.lineNumber,
						lineStart: this.lineStart,
						start: start,
						end: this.index
					};
				};
				// https://tc39.github.io/ecma262/#sec-literals-numeric-literals
				Scanner.prototype.scanHexLiteral = function (start) {
					var num = '';
					while (!this.eof()) {
						if (!character_1.Character.isHexDigit(this.source.charCodeAt(this.index))) {
							break;
						}
						num += this.source[this.index++];
					}
					if (num.length === 0) {
						this.throwUnexpectedToken();
					}
					if (character_1.Character.isIdentifierStart(this.source.charCodeAt(this.index))) {
						this.throwUnexpectedToken();
					}
					return {
						type: 6 /* NumericLiteral */
						, value: parseInt('0x' + num, 16),
						lineNumber: this.lineNumber,
						lineStart: this.lineStart,
						start: start,
						end: this.index
					};
				};
				Scanner.prototype.scanBinaryLiteral = function (start) {
					var num = '';
					var ch;
					while (!this.eof()) {
						ch = this.source[this.index];
						if (ch !== '0' && ch !== '1') {
							break;
						}
						num += this.source[this.index++];
					}
					if (num.length === 0) {
						// only 0b or 0B
						this.throwUnexpectedToken();
					}
					if (!this.eof()) {
						ch = this.source.charCodeAt(this.index);
						/* istanbul ignore else */
						if (character_1.Character.isIdentifierStart(ch) || character_1.Character.isDecimalDigit(ch)) {
							this.throwUnexpectedToken();
						}
					}
					return {
						type: 6 /* NumericLiteral */
						, value: parseInt(num, 2),
						lineNumber: this.lineNumber,
						lineStart: this.lineStart,
						start: start,
						end: this.index
					};
				};
				Scanner.prototype.scanOctalLiteral = function (prefix, start) {
					var num = '';
					var octal = false;
					if (character_1.Character.isOctalDigit(prefix.charCodeAt(0))) {
						octal = true;
						num = '0' + this.source[this.index++];
					} else {
						++this.index;
					}
					while (!this.eof()) {
						if (!character_1.Character.isOctalDigit(this.source.charCodeAt(this.index))) {
							break;
						}
						num += this.source[this.index++];
					}
					if (!octal && num.length === 0) {
						// only 0o or 0O
						this.throwUnexpectedToken();
					}
					if (character_1.Character.isIdentifierStart(this.source.charCodeAt(this.index)) || character_1.Character.isDecimalDigit(this.source.charCodeAt(this.index))) {
						this.throwUnexpectedToken();
					}
					return {
						type: 6 /* NumericLiteral */
						, value: parseInt(num, 8),
						octal: octal,
						lineNumber: this.lineNumber,
						lineStart: this.lineStart,
						start: start,
						end: this.index
					};
				};
				Scanner.prototype.isImplicitOctalLiteral = function () {
					// Implicit octal, unless there is a non-octal digit.
					// (Annex B.1.1 on Numeric Literals)
					for (var i = this.index + 1; i < this.length; ++i) {
						var ch = this.source[i];
						if (ch === '8' || ch === '9') {
							return false;
						}
						if (!character_1.Character.isOctalDigit(ch.charCodeAt(0))) {
							return true;
						}
					}
					return true;
				};
				Scanner.prototype.scanNumericLiteral = function () {
					var start = this.index;
					var ch = this.source[start];
					assert_1.assert(character_1.Character.isDecimalDigit(ch.charCodeAt(0)) || ch === '.', 'Numeric literal must start with a decimal digit or a decimal point');
					var num = '';
					if (ch !== '.') {
						num = this.source[this.index++];
						ch = this.source[this.index];
						// Hex number starts with '0x'.
						// Octal number starts with '0'.
						// Octal number in ES6 starts with '0o'.
						// Binary number in ES6 starts with '0b'.
						if (num === '0') {
							if (ch === 'x' || ch === 'X') {
								++this.index;
								return this.scanHexLiteral(start);
							}
							if (ch === 'b' || ch === 'B') {
								++this.index;
								return this.scanBinaryLiteral(start);
							}
							if (ch === 'o' || ch === 'O') {
								return this.scanOctalLiteral(ch, start);
							}
							if (ch && character_1.Character.isOctalDigit(ch.charCodeAt(0))) {
								if (this.isImplicitOctalLiteral()) {
									return this.scanOctalLiteral(ch, start);
								}
							}
						}
						while (character_1.Character.isDecimalDigit(this.source.charCodeAt(this.index))) {
							num += this.source[this.index++];
						}
						ch = this.source[this.index];
					}
					if (ch === '.') {
						num += this.source[this.index++];
						while (character_1.Character.isDecimalDigit(this.source.charCodeAt(this.index))) {
							num += this.source[this.index++];
						}
						ch = this.source[this.index];
					}
					if (ch === 'e' || ch === 'E') {
						num += this.source[this.index++];
						ch = this.source[this.index];
						if (ch === '+' || ch === '-') {
							num += this.source[this.index++];
						}
						if (character_1.Character.isDecimalDigit(this.source.charCodeAt(this.index))) {
							while (character_1.Character.isDecimalDigit(this.source.charCodeAt(this.index))) {
								num += this.source[this.index++];
							}
						} else {
							this.throwUnexpectedToken();
						}
					}
					if (character_1.Character.isIdentifierStart(this.source.charCodeAt(this.index))) {
						this.throwUnexpectedToken();
					}
					return {
						type: 6 /* NumericLiteral */
						, value: parseFloat(num),
						lineNumber: this.lineNumber,
						lineStart: this.lineStart,
						start: start,
						end: this.index
					};
				};
				// https://tc39.github.io/ecma262/#sec-literals-string-literals
				Scanner.prototype.scanStringLiteral = function () {
					var start = this.index;
					var quote = this.source[start];
					assert_1.assert(quote === '\'' || quote === '"', 'String literal must starts with a quote');
					++this.index;
					var octal = false;
					var str = '';
					while (!this.eof()) {
						var ch = this.source[this.index++];
						if (ch === quote) {
							quote = '';
							break;
						} else if (ch === '\\') {
							ch = this.source[this.index++];
							if (!ch || !character_1.Character.isLineTerminator(ch.charCodeAt(0))) {
								switch (ch) {
									case 'u':
										if (this.source[this.index] === '{') {
											++this.index;
											str += this.scanUnicodeCodePointEscape();
										} else {
											var unescaped_1 = this.scanHexEscape(ch);
											if (unescaped_1 === null) {
												this.throwUnexpectedToken();
											}
											str += unescaped_1;
										}
										break;
									case 'x':
										var unescaped = this.scanHexEscape(ch);
										if (unescaped === null) {
											this.throwUnexpectedToken(messages_1.Messages.InvalidHexEscapeSequence);
										}
										str += unescaped;
										break;
									case 'n':
										str += '\n';
										break;
									case 'r':
										str += '\r';
										break;
									case 't':
										str += '\t';
										break;
									case 'b':
										str += '\b';
										break;
									case 'f':
										str += '\f';
										break;
									case 'v':
										str += '\x0B';
										break;
									case '8':
									case '9':
										str += ch;
										this.tolerateUnexpectedToken();
										break;
									default:
										if (ch && character_1.Character.isOctalDigit(ch.charCodeAt(0))) {
											var octToDec = this.octalToDecimal(ch);
											octal = octToDec.octal || octal;
											str += String.fromCharCode(octToDec.code);
										} else {
											str += ch;
										}
										break;
								}
							} else {
								++this.lineNumber;
								if (ch === '\r' && this.source[this.index] === '\n') {
									++this.index;
								}
								this.lineStart = this.index;
							}
						} else if (character_1.Character.isLineTerminator(ch.charCodeAt(0))) {
							break;
						} else {
							str += ch;
						}
					}
					if (quote !== '') {
						this.index = start;
						this.throwUnexpectedToken();
					}
					return {
						type: 8 /* StringLiteral */
						, value: str,
						octal: octal,
						lineNumber: this.lineNumber,
						lineStart: this.lineStart,
						start: start,
						end: this.index
					};
				};
				// https://tc39.github.io/ecma262/#sec-template-literal-lexical-components
				Scanner.prototype.scanTemplate = function () {
					var cooked = '';
					var terminated = false;
					var start = this.index;
					var head = this.source[start] === '`';
					var tail = false;
					var rawOffset = 2;
					++this.index;
					while (!this.eof()) {
						var ch = this.source[this.index++];
						if (ch === '`') {
							rawOffset = 1;
							tail = true;
							terminated = true;
							break;
						} else if (ch === '$') {
							if (this.source[this.index] === '{') {
								this.curlyStack.push('${');
								++this.index;
								terminated = true;
								break;
							}
							cooked += ch;
						} else if (ch === '\\') {
							ch = this.source[this.index++];
							if (!character_1.Character.isLineTerminator(ch.charCodeAt(0))) {
								switch (ch) {
									case 'n':
										cooked += '\n';
										break;
									case 'r':
										cooked += '\r';
										break;
									case 't':
										cooked += '\t';
										break;
									case 'u':
										if (this.source[this.index] === '{') {
											++this.index;
											cooked += this.scanUnicodeCodePointEscape();
										} else {
											var restore = this.index;
											var unescaped_2 = this.scanHexEscape(ch);
											if (unescaped_2 !== null) {
												cooked += unescaped_2;
											} else {
												this.index = restore;
												cooked += ch;
											}
										}
										break;
									case 'x':
										var unescaped = this.scanHexEscape(ch);
										if (unescaped === null) {
											this.throwUnexpectedToken(messages_1.Messages.InvalidHexEscapeSequence);
										}
										cooked += unescaped;
										break;
									case 'b':
										cooked += '\b';
										break;
									case 'f':
										cooked += '\f';
										break;
									case 'v':
										cooked += '\v';
										break;
									default:
										if (ch === '0') {
											if (character_1.Character.isDecimalDigit(this.source.charCodeAt(this.index))) {
												// Illegal: \01 \02 and so on
												this.throwUnexpectedToken(messages_1.Messages.TemplateOctalLiteral);
											}
											cooked += '\0';
										} else if (character_1.Character.isOctalDigit(ch.charCodeAt(0))) {
											// Illegal: \1 \2
											this.throwUnexpectedToken(messages_1.Messages.TemplateOctalLiteral);
										} else {
											cooked += ch;
										}
										break;
								}
							} else {
								++this.lineNumber;
								if (ch === '\r' && this.source[this.index] === '\n') {
									++this.index;
								}
								this.lineStart = this.index;
							}
						} else if (character_1.Character.isLineTerminator(ch.charCodeAt(0))) {
							++this.lineNumber;
							if (ch === '\r' && this.source[this.index] === '\n') {
								++this.index;
							}
							this.lineStart = this.index;
							cooked += '\n';
						} else {
							cooked += ch;
						}
					}
					if (!terminated) {
						this.throwUnexpectedToken();
					}
					if (!head) {
						this.curlyStack.pop();
					}
					return {
						type: 10 /* Template */
						, value: this.source.slice(start + 1, this.index - rawOffset),
						cooked: cooked,
						head: head,
						tail: tail,
						lineNumber: this.lineNumber,
						lineStart: this.lineStart,
						start: start,
						end: this.index
					};
				};
				// https://tc39.github.io/ecma262/#sec-literals-regular-expression-literals
				Scanner.prototype.testRegExp = function (pattern, flags) {
					// The BMP character to use as a replacement for astral symbols when
					// translating an ES6 "u"-flagged pattern to an ES5-compatible
					// approximation.
					// Note: replacing with '\uFFFF' enables false positives in unlikely
					// scenarios. For example, `[\u{1044f}-\u{10440}]` is an invalid
					// pattern that would not be detected by this substitution.
					var astralSubstitute = '\uFFFF';
					var tmp = pattern;
					var self = this;
					if (flags.indexOf('u') >= 0) {
						tmp = tmp.replace(/\\u\{([0-9a-fA-F]+)\}|\\u([a-fA-F0-9]{4})/g, function ($0, $1, $2) {
							var codePoint = parseInt($1 || $2, 16);
							if (codePoint > 0x10FFFF) {
								self.throwUnexpectedToken(messages_1.Messages.InvalidRegExp);
							}
							if (codePoint <= 0xFFFF) {
								return String.fromCharCode(codePoint);
							}
							return astralSubstitute;
						}).replace(/[\uD800-\uDBFF][\uDC00-\uDFFF]/g, astralSubstitute);
					}
					// First, detect invalid regular expressions.
					try {
						RegExp(tmp);
					} catch (e) {
						this.throwUnexpectedToken(messages_1.Messages.InvalidRegExp);
					}
					// Return a regular expression object for this pattern-flag pair, or
					// `null` in case the current environment doesn't support the flags it
					// uses.
					try {
						return new RegExp(pattern, flags);
					} catch (exception) {
						/* istanbul ignore next */
						return null;
					}
				};
				Scanner.prototype.scanRegExpBody = function () {
					var ch = this.source[this.index];
					assert_1.assert(ch === '/', 'Regular expression literal must start with a slash');
					var str = this.source[this.index++];
					var classMarker = false;
					var terminated = false;
					while (!this.eof()) {
						ch = this.source[this.index++];
						str += ch;
						if (ch === '\\') {
							ch = this.source[this.index++];
							// https://tc39.github.io/ecma262/#sec-literals-regular-expression-literals
							if (character_1.Character.isLineTerminator(ch.charCodeAt(0))) {
								this.throwUnexpectedToken(messages_1.Messages.UnterminatedRegExp);
							}
							str += ch;
						} else if (character_1.Character.isLineTerminator(ch.charCodeAt(0))) {
							this.throwUnexpectedToken(messages_1.Messages.UnterminatedRegExp);
						} else if (classMarker) {
							if (ch === ']') {
								classMarker = false;
							}
						} else {
							if (ch === '/') {
								terminated = true;
								break;
							} else if (ch === '[') {
								classMarker = true;
							}
						}
					}
					if (!terminated) {
						this.throwUnexpectedToken(messages_1.Messages.UnterminatedRegExp);
					}
					// Exclude leading and trailing slash.
					return str.substr(1, str.length - 2);
				};
				Scanner.prototype.scanRegExpFlags = function () {
					var str = '';
					var flags = '';
					while (!this.eof()) {
						var ch = this.source[this.index];
						if (!character_1.Character.isIdentifierPart(ch.charCodeAt(0))) {
							break;
						}
						++this.index;
						if (ch === '\\' && !this.eof()) {
							ch = this.source[this.index];
							if (ch === 'u') {
								++this.index;
								var restore = this.index;
								var char = this.scanHexEscape('u');
								if (char !== null) {
									flags += char;
									for (str += '\\u'; restore < this.index; ++restore) {
										str += this.source[restore];
									}
								} else {
									this.index = restore;
									flags += 'u';
									str += '\\u';
								}
								this.tolerateUnexpectedToken();
							} else {
								str += '\\';
								this.tolerateUnexpectedToken();
							}
						} else {
							flags += ch;
							str += ch;
						}
					}
					return flags;
				};
				Scanner.prototype.scanRegExp = function () {
					var start = this.index;
					var pattern = this.scanRegExpBody();
					var flags = this.scanRegExpFlags();
					var value = this.testRegExp(pattern, flags);
					return {
						type: 9 /* RegularExpression */
						, value: '',
						pattern: pattern,
						flags: flags,
						regex: value,
						lineNumber: this.lineNumber,
						lineStart: this.lineStart,
						start: start,
						end: this.index
					};
				};
				Scanner.prototype.lex = function () {
					if (this.eof()) {
						return {
							type: 2 /* EOF */
							, value: '',
							lineNumber: this.lineNumber,
							lineStart: this.lineStart,
							start: this.index,
							end: this.index
						};
					}
					var cp = this.source.charCodeAt(this.index);
					if (character_1.Character.isIdentifierStart(cp)) {
						return this.scanIdentifier();
					}
					// Very common: ( and ) and ;
					if (cp === 0x28 || cp === 0x29 || cp === 0x3B) {
						return this.scanPunctuator();
					}
					// String literal starts with single quote (U+0027) or double quote (U+0022).
					if (cp === 0x27 || cp === 0x22) {
						return this.scanStringLiteral();
					}
					// Dot (.) U+002E can also start a floating-point number, hence the need
					// to check the next character.
					if (cp === 0x2E) {
						if (character_1.Character.isDecimalDigit(this.source.charCodeAt(this.index + 1))) {
							return this.scanNumericLiteral();
						}
						return this.scanPunctuator();
					}
					if (character_1.Character.isDecimalDigit(cp)) {
						return this.scanNumericLiteral();
					}
					// Template literals start with ` (U+0060) for template head
					// or } (U+007D) for template middle or template tail.
					if (cp === 0x60 || cp === 0x7D && this.curlyStack[this.curlyStack.length - 1] === '${') {
						return this.scanTemplate();
					}
					// Possible identifier start in a surrogate pair.
					if (cp >= 0xD800 && cp < 0xDFFF) {
						if (character_1.Character.isIdentifierStart(this.codePointAt(this.index))) {
							return this.scanIdentifier();
						}
					}
					return this.scanPunctuator();
				};
				return Scanner;
			}();
			exports.Scanner = Scanner;

			/***/
		},
		/* 13 */
		/***/function (module, exports) {

			"use strict";

			Object.defineProperty(exports, "__esModule", { value: true });
			exports.TokenName = {};
			exports.TokenName[1 /* BooleanLiteral */] = 'Boolean';
			exports.TokenName[2 /* EOF */] = '<end>';
			exports.TokenName[3 /* Identifier */] = 'Identifier';
			exports.TokenName[4 /* Keyword */] = 'Keyword';
			exports.TokenName[5 /* NullLiteral */] = 'Null';
			exports.TokenName[6 /* NumericLiteral */] = 'Numeric';
			exports.TokenName[7 /* Punctuator */] = 'Punctuator';
			exports.TokenName[8 /* StringLiteral */] = 'String';
			exports.TokenName[9 /* RegularExpression */] = 'RegularExpression';
			exports.TokenName[10 /* Template */] = 'Template';

			/***/
		},
		/* 14 */
		/***/function (module, exports) {

			"use strict";
			// Generated by generate-xhtml-entities.js. DO NOT MODIFY!

			Object.defineProperty(exports, "__esModule", { value: true });
			exports.XHTMLEntities = {
				quot: '\u0022',
				amp: '\u0026',
				apos: '\u0027',
				gt: '\u003E',
				nbsp: '\u00A0',
				iexcl: '\u00A1',
				cent: '\u00A2',
				pound: '\u00A3',
				curren: '\u00A4',
				yen: '\u00A5',
				brvbar: '\u00A6',
				sect: '\u00A7',
				uml: '\u00A8',
				copy: '\u00A9',
				ordf: '\u00AA',
				laquo: '\u00AB',
				not: '\u00AC',
				shy: '\u00AD',
				reg: '\u00AE',
				macr: '\u00AF',
				deg: '\u00B0',
				plusmn: '\u00B1',
				sup2: '\u00B2',
				sup3: '\u00B3',
				acute: '\u00B4',
				micro: '\u00B5',
				para: '\u00B6',
				middot: '\u00B7',
				cedil: '\u00B8',
				sup1: '\u00B9',
				ordm: '\u00BA',
				raquo: '\u00BB',
				frac14: '\u00BC',
				frac12: '\u00BD',
				frac34: '\u00BE',
				iquest: '\u00BF',
				Agrave: '\u00C0',
				Aacute: '\u00C1',
				Acirc: '\u00C2',
				Atilde: '\u00C3',
				Auml: '\u00C4',
				Aring: '\u00C5',
				AElig: '\u00C6',
				Ccedil: '\u00C7',
				Egrave: '\u00C8',
				Eacute: '\u00C9',
				Ecirc: '\u00CA',
				Euml: '\u00CB',
				Igrave: '\u00CC',
				Iacute: '\u00CD',
				Icirc: '\u00CE',
				Iuml: '\u00CF',
				ETH: '\u00D0',
				Ntilde: '\u00D1',
				Ograve: '\u00D2',
				Oacute: '\u00D3',
				Ocirc: '\u00D4',
				Otilde: '\u00D5',
				Ouml: '\u00D6',
				times: '\u00D7',
				Oslash: '\u00D8',
				Ugrave: '\u00D9',
				Uacute: '\u00DA',
				Ucirc: '\u00DB',
				Uuml: '\u00DC',
				Yacute: '\u00DD',
				THORN: '\u00DE',
				szlig: '\u00DF',
				agrave: '\u00E0',
				aacute: '\u00E1',
				acirc: '\u00E2',
				atilde: '\u00E3',
				auml: '\u00E4',
				aring: '\u00E5',
				aelig: '\u00E6',
				ccedil: '\u00E7',
				egrave: '\u00E8',
				eacute: '\u00E9',
				ecirc: '\u00EA',
				euml: '\u00EB',
				igrave: '\u00EC',
				iacute: '\u00ED',
				icirc: '\u00EE',
				iuml: '\u00EF',
				eth: '\u00F0',
				ntilde: '\u00F1',
				ograve: '\u00F2',
				oacute: '\u00F3',
				ocirc: '\u00F4',
				otilde: '\u00F5',
				ouml: '\u00F6',
				divide: '\u00F7',
				oslash: '\u00F8',
				ugrave: '\u00F9',
				uacute: '\u00FA',
				ucirc: '\u00FB',
				uuml: '\u00FC',
				yacute: '\u00FD',
				thorn: '\u00FE',
				yuml: '\u00FF',
				OElig: '\u0152',
				oelig: '\u0153',
				Scaron: '\u0160',
				scaron: '\u0161',
				Yuml: '\u0178',
				fnof: '\u0192',
				circ: '\u02C6',
				tilde: '\u02DC',
				Alpha: '\u0391',
				Beta: '\u0392',
				Gamma: '\u0393',
				Delta: '\u0394',
				Epsilon: '\u0395',
				Zeta: '\u0396',
				Eta: '\u0397',
				Theta: '\u0398',
				Iota: '\u0399',
				Kappa: '\u039A',
				Lambda: '\u039B',
				Mu: '\u039C',
				Nu: '\u039D',
				Xi: '\u039E',
				Omicron: '\u039F',
				Pi: '\u03A0',
				Rho: '\u03A1',
				Sigma: '\u03A3',
				Tau: '\u03A4',
				Upsilon: '\u03A5',
				Phi: '\u03A6',
				Chi: '\u03A7',
				Psi: '\u03A8',
				Omega: '\u03A9',
				alpha: '\u03B1',
				beta: '\u03B2',
				gamma: '\u03B3',
				delta: '\u03B4',
				epsilon: '\u03B5',
				zeta: '\u03B6',
				eta: '\u03B7',
				theta: '\u03B8',
				iota: '\u03B9',
				kappa: '\u03BA',
				lambda: '\u03BB',
				mu: '\u03BC',
				nu: '\u03BD',
				xi: '\u03BE',
				omicron: '\u03BF',
				pi: '\u03C0',
				rho: '\u03C1',
				sigmaf: '\u03C2',
				sigma: '\u03C3',
				tau: '\u03C4',
				upsilon: '\u03C5',
				phi: '\u03C6',
				chi: '\u03C7',
				psi: '\u03C8',
				omega: '\u03C9',
				thetasym: '\u03D1',
				upsih: '\u03D2',
				piv: '\u03D6',
				ensp: '\u2002',
				emsp: '\u2003',
				thinsp: '\u2009',
				zwnj: '\u200C',
				zwj: '\u200D',
				lrm: '\u200E',
				rlm: '\u200F',
				ndash: '\u2013',
				mdash: '\u2014',
				lsquo: '\u2018',
				rsquo: '\u2019',
				sbquo: '\u201A',
				ldquo: '\u201C',
				rdquo: '\u201D',
				bdquo: '\u201E',
				dagger: '\u2020',
				Dagger: '\u2021',
				bull: '\u2022',
				hellip: '\u2026',
				permil: '\u2030',
				prime: '\u2032',
				Prime: '\u2033',
				lsaquo: '\u2039',
				rsaquo: '\u203A',
				oline: '\u203E',
				frasl: '\u2044',
				euro: '\u20AC',
				image: '\u2111',
				weierp: '\u2118',
				real: '\u211C',
				trade: '\u2122',
				alefsym: '\u2135',
				larr: '\u2190',
				uarr: '\u2191',
				rarr: '\u2192',
				darr: '\u2193',
				harr: '\u2194',
				crarr: '\u21B5',
				lArr: '\u21D0',
				uArr: '\u21D1',
				rArr: '\u21D2',
				dArr: '\u21D3',
				hArr: '\u21D4',
				forall: '\u2200',
				part: '\u2202',
				exist: '\u2203',
				empty: '\u2205',
				nabla: '\u2207',
				isin: '\u2208',
				notin: '\u2209',
				ni: '\u220B',
				prod: '\u220F',
				sum: '\u2211',
				minus: '\u2212',
				lowast: '\u2217',
				radic: '\u221A',
				prop: '\u221D',
				infin: '\u221E',
				ang: '\u2220',
				and: '\u2227',
				or: '\u2228',
				cap: '\u2229',
				cup: '\u222A',
				int: '\u222B',
				there4: '\u2234',
				sim: '\u223C',
				cong: '\u2245',
				asymp: '\u2248',
				ne: '\u2260',
				equiv: '\u2261',
				le: '\u2264',
				ge: '\u2265',
				sub: '\u2282',
				sup: '\u2283',
				nsub: '\u2284',
				sube: '\u2286',
				supe: '\u2287',
				oplus: '\u2295',
				otimes: '\u2297',
				perp: '\u22A5',
				sdot: '\u22C5',
				lceil: '\u2308',
				rceil: '\u2309',
				lfloor: '\u230A',
				rfloor: '\u230B',
				loz: '\u25CA',
				spades: '\u2660',
				clubs: '\u2663',
				hearts: '\u2665',
				diams: '\u2666',
				lang: '\u27E8',
				rang: '\u27E9'
			};

			/***/
		},
		/* 15 */
		/***/function (module, exports, __webpack_require__) {

			"use strict";

			Object.defineProperty(exports, "__esModule", { value: true });
			var error_handler_1 = __webpack_require__(10);
			var scanner_1 = __webpack_require__(12);
			var token_1 = __webpack_require__(13);
			var Reader = function () {
				function Reader() {
					this.values = [];
					this.curly = this.paren = -1;
				}
				// A function following one of those tokens is an expression.
				Reader.prototype.beforeFunctionExpression = function (t) {
					return ['(', '{', '[', 'in', 'typeof', 'instanceof', 'new', 'return', 'case', 'delete', 'throw', 'void',
					// assignment operators
					'=', '+=', '-=', '*=', '**=', '/=', '%=', '<<=', '>>=', '>>>=', '&=', '|=', '^=', ',',
					// binary/unary operators
					'+', '-', '*', '**', '/', '%', '++', '--', '<<', '>>', '>>>', '&', '|', '^', '!', '~', '&&', '||', '?', ':', '===', '==', '>=', '<=', '<', '>', '!=', '!=='].indexOf(t) >= 0;
				};
				// Determine if forward slash (/) is an operator or part of a regular expression
				// https://github.com/mozilla/sweet.js/wiki/design
				Reader.prototype.isRegexStart = function () {
					var previous = this.values[this.values.length - 1];
					var regex = previous !== null;
					switch (previous) {
						case 'this':
						case ']':
							regex = false;
							break;
						case ')':
							var keyword = this.values[this.paren - 1];
							regex = keyword === 'if' || keyword === 'while' || keyword === 'for' || keyword === 'with';
							break;
						case '}':
							// Dividing a function by anything makes little sense,
							// but we have to check for that.
							regex = false;
							if (this.values[this.curly - 3] === 'function') {
								// Anonymous function, e.g. function(){} /42
								var check = this.values[this.curly - 4];
								regex = check ? !this.beforeFunctionExpression(check) : false;
							} else if (this.values[this.curly - 4] === 'function') {
								// Named function, e.g. function f(){} /42/
								var check = this.values[this.curly - 5];
								regex = check ? !this.beforeFunctionExpression(check) : true;
							}
							break;
						default:
							break;
					}
					return regex;
				};
				Reader.prototype.push = function (token) {
					if (token.type === 7 /* Punctuator */ || token.type === 4 /* Keyword */) {
							if (token.value === '{') {
								this.curly = this.values.length;
							} else if (token.value === '(') {
								this.paren = this.values.length;
							}
							this.values.push(token.value);
						} else {
						this.values.push(null);
					}
				};
				return Reader;
			}();
			var Tokenizer = function () {
				function Tokenizer(code, config) {
					this.errorHandler = new error_handler_1.ErrorHandler();
					this.errorHandler.tolerant = config ? typeof config.tolerant === 'boolean' && config.tolerant : false;
					this.scanner = new scanner_1.Scanner(code, this.errorHandler);
					this.scanner.trackComment = config ? typeof config.comment === 'boolean' && config.comment : false;
					this.trackRange = config ? typeof config.range === 'boolean' && config.range : false;
					this.trackLoc = config ? typeof config.loc === 'boolean' && config.loc : false;
					this.buffer = [];
					this.reader = new Reader();
				}
				Tokenizer.prototype.errors = function () {
					return this.errorHandler.errors;
				};
				Tokenizer.prototype.getNextToken = function () {
					if (this.buffer.length === 0) {
						var comments = this.scanner.scanComments();
						if (this.scanner.trackComment) {
							for (var i = 0; i < comments.length; ++i) {
								var e = comments[i];
								var value = this.scanner.source.slice(e.slice[0], e.slice[1]);
								var comment = {
									type: e.multiLine ? 'BlockComment' : 'LineComment',
									value: value
								};
								if (this.trackRange) {
									comment.range = e.range;
								}
								if (this.trackLoc) {
									comment.loc = e.loc;
								}
								this.buffer.push(comment);
							}
						}
						if (!this.scanner.eof()) {
							var loc = void 0;
							if (this.trackLoc) {
								loc = {
									start: {
										line: this.scanner.lineNumber,
										column: this.scanner.index - this.scanner.lineStart
									},
									end: {}
								};
							}
							var startRegex = this.scanner.source[this.scanner.index] === '/' && this.reader.isRegexStart();
							var token = startRegex ? this.scanner.scanRegExp() : this.scanner.lex();
							this.reader.push(token);
							var entry = {
								type: token_1.TokenName[token.type],
								value: this.scanner.source.slice(token.start, token.end)
							};
							if (this.trackRange) {
								entry.range = [token.start, token.end];
							}
							if (this.trackLoc) {
								loc.end = {
									line: this.scanner.lineNumber,
									column: this.scanner.index - this.scanner.lineStart
								};
								entry.loc = loc;
							}
							if (token.type === 9 /* RegularExpression */) {
									var pattern = token.pattern;
									var flags = token.flags;
									entry.regex = { pattern: pattern, flags: flags };
								}
							this.buffer.push(entry);
						}
					}
					return this.buffer.shift();
				};
				return Tokenizer;
			}();
			exports.Tokenizer = Tokenizer;

			/***/
		}
		/******/])
	);
});
;

/***/ }),
/* 158 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/*eslint-disable no-use-before-define*/

var common = __webpack_require__(17);
var YAMLException = __webpack_require__(21);
var DEFAULT_FULL_SCHEMA = __webpack_require__(25);
var DEFAULT_SAFE_SCHEMA = __webpack_require__(22);

var _toString = Object.prototype.toString;
var _hasOwnProperty = Object.prototype.hasOwnProperty;

var CHAR_TAB = 0x09; /* Tab */
var CHAR_LINE_FEED = 0x0A; /* LF */
var CHAR_SPACE = 0x20; /* Space */
var CHAR_EXCLAMATION = 0x21; /* ! */
var CHAR_DOUBLE_QUOTE = 0x22; /* " */
var CHAR_SHARP = 0x23; /* # */
var CHAR_PERCENT = 0x25; /* % */
var CHAR_AMPERSAND = 0x26; /* & */
var CHAR_SINGLE_QUOTE = 0x27; /* ' */
var CHAR_ASTERISK = 0x2A; /* * */
var CHAR_COMMA = 0x2C; /* , */
var CHAR_MINUS = 0x2D; /* - */
var CHAR_COLON = 0x3A; /* : */
var CHAR_GREATER_THAN = 0x3E; /* > */
var CHAR_QUESTION = 0x3F; /* ? */
var CHAR_COMMERCIAL_AT = 0x40; /* @ */
var CHAR_LEFT_SQUARE_BRACKET = 0x5B; /* [ */
var CHAR_RIGHT_SQUARE_BRACKET = 0x5D; /* ] */
var CHAR_GRAVE_ACCENT = 0x60; /* ` */
var CHAR_LEFT_CURLY_BRACKET = 0x7B; /* { */
var CHAR_VERTICAL_LINE = 0x7C; /* | */
var CHAR_RIGHT_CURLY_BRACKET = 0x7D; /* } */

var ESCAPE_SEQUENCES = {};

ESCAPE_SEQUENCES[0x00] = '\\0';
ESCAPE_SEQUENCES[0x07] = '\\a';
ESCAPE_SEQUENCES[0x08] = '\\b';
ESCAPE_SEQUENCES[0x09] = '\\t';
ESCAPE_SEQUENCES[0x0A] = '\\n';
ESCAPE_SEQUENCES[0x0B] = '\\v';
ESCAPE_SEQUENCES[0x0C] = '\\f';
ESCAPE_SEQUENCES[0x0D] = '\\r';
ESCAPE_SEQUENCES[0x1B] = '\\e';
ESCAPE_SEQUENCES[0x22] = '\\"';
ESCAPE_SEQUENCES[0x5C] = '\\\\';
ESCAPE_SEQUENCES[0x85] = '\\N';
ESCAPE_SEQUENCES[0xA0] = '\\_';
ESCAPE_SEQUENCES[0x2028] = '\\L';
ESCAPE_SEQUENCES[0x2029] = '\\P';

var DEPRECATED_BOOLEANS_SYNTAX = ['y', 'Y', 'yes', 'Yes', 'YES', 'on', 'On', 'ON', 'n', 'N', 'no', 'No', 'NO', 'off', 'Off', 'OFF'];

function compileStyleMap(schema, map) {
  var result, keys, index, length, tag, style, type;

  if (map === null) return {};

  result = {};
  keys = Object.keys(map);

  for (index = 0, length = keys.length; index < length; index += 1) {
    tag = keys[index];
    style = String(map[tag]);

    if (tag.slice(0, 2) === '!!') {
      tag = 'tag:yaml.org,2002:' + tag.slice(2);
    }
    type = schema.compiledTypeMap['fallback'][tag];

    if (type && _hasOwnProperty.call(type.styleAliases, style)) {
      style = type.styleAliases[style];
    }

    result[tag] = style;
  }

  return result;
}

function encodeHex(character) {
  var string, handle, length;

  string = character.toString(16).toUpperCase();

  if (character <= 0xFF) {
    handle = 'x';
    length = 2;
  } else if (character <= 0xFFFF) {
    handle = 'u';
    length = 4;
  } else if (character <= 0xFFFFFFFF) {
    handle = 'U';
    length = 8;
  } else {
    throw new YAMLException('code point within a string may not be greater than 0xFFFFFFFF');
  }

  return '\\' + handle + common.repeat('0', length - string.length) + string;
}

function State(options) {
  this.schema = options['schema'] || DEFAULT_FULL_SCHEMA;
  this.indent = Math.max(1, options['indent'] || 2);
  this.skipInvalid = options['skipInvalid'] || false;
  this.flowLevel = common.isNothing(options['flowLevel']) ? -1 : options['flowLevel'];
  this.styleMap = compileStyleMap(this.schema, options['styles'] || null);
  this.sortKeys = options['sortKeys'] || false;
  this.lineWidth = options['lineWidth'] || 80;
  this.noRefs = options['noRefs'] || false;
  this.noCompatMode = options['noCompatMode'] || false;
  this.condenseFlow = options['condenseFlow'] || false;

  this.implicitTypes = this.schema.compiledImplicit;
  this.explicitTypes = this.schema.compiledExplicit;

  this.tag = null;
  this.result = '';

  this.duplicates = [];
  this.usedDuplicates = null;
}

// Indents every line in a string. Empty lines (\n only) are not indented.
function indentString(string, spaces) {
  var ind = common.repeat(' ', spaces),
      position = 0,
      next = -1,
      result = '',
      line,
      length = string.length;

  while (position < length) {
    next = string.indexOf('\n', position);
    if (next === -1) {
      line = string.slice(position);
      position = length;
    } else {
      line = string.slice(position, next + 1);
      position = next + 1;
    }

    if (line.length && line !== '\n') result += ind;

    result += line;
  }

  return result;
}

function generateNextLine(state, level) {
  return '\n' + common.repeat(' ', state.indent * level);
}

function testImplicitResolving(state, str) {
  var index, length, type;

  for (index = 0, length = state.implicitTypes.length; index < length; index += 1) {
    type = state.implicitTypes[index];

    if (type.resolve(str)) {
      return true;
    }
  }

  return false;
}

// [33] s-white ::= s-space | s-tab
function isWhitespace(c) {
  return c === CHAR_SPACE || c === CHAR_TAB;
}

// Returns true if the character can be printed without escaping.
// From YAML 1.2: "any allowed characters known to be non-printable
// should also be escaped. [However,] This isnt mandatory"
// Derived from nb-char - \t - #x85 - #xA0 - #x2028 - #x2029.
function isPrintable(c) {
  return 0x00020 <= c && c <= 0x00007E || 0x000A1 <= c && c <= 0x00D7FF && c !== 0x2028 && c !== 0x2029 || 0x0E000 <= c && c <= 0x00FFFD && c !== 0xFEFF /* BOM */ || 0x10000 <= c && c <= 0x10FFFF;
}

// Simplified test for values allowed after the first character in plain style.
function isPlainSafe(c) {
  // Uses a subset of nb-char - c-flow-indicator - ":" - "#"
  // where nb-char ::= c-printable - b-char - c-byte-order-mark.
  return isPrintable(c) && c !== 0xFEFF
  // - c-flow-indicator
  && c !== CHAR_COMMA && c !== CHAR_LEFT_SQUARE_BRACKET && c !== CHAR_RIGHT_SQUARE_BRACKET && c !== CHAR_LEFT_CURLY_BRACKET && c !== CHAR_RIGHT_CURLY_BRACKET
  // - ":" - "#"
  && c !== CHAR_COLON && c !== CHAR_SHARP;
}

// Simplified test for values allowed as the first character in plain style.
function isPlainSafeFirst(c) {
  // Uses a subset of ns-char - c-indicator
  // where ns-char = nb-char - s-white.
  return isPrintable(c) && c !== 0xFEFF && !isWhitespace(c) // - s-white
  // - (c-indicator ::=
  // - | ? | : | , | [ | ] | { | }
  && c !== CHAR_MINUS && c !== CHAR_QUESTION && c !== CHAR_COLON && c !== CHAR_COMMA && c !== CHAR_LEFT_SQUARE_BRACKET && c !== CHAR_RIGHT_SQUARE_BRACKET && c !== CHAR_LEFT_CURLY_BRACKET && c !== CHAR_RIGHT_CURLY_BRACKET
  // | # | & | * | ! | | | > | ' | "
  && c !== CHAR_SHARP && c !== CHAR_AMPERSAND && c !== CHAR_ASTERISK && c !== CHAR_EXCLAMATION && c !== CHAR_VERTICAL_LINE && c !== CHAR_GREATER_THAN && c !== CHAR_SINGLE_QUOTE && c !== CHAR_DOUBLE_QUOTE
  // | % | @ | `)
  && c !== CHAR_PERCENT && c !== CHAR_COMMERCIAL_AT && c !== CHAR_GRAVE_ACCENT;
}

var STYLE_PLAIN = 1,
    STYLE_SINGLE = 2,
    STYLE_LITERAL = 3,
    STYLE_FOLDED = 4,
    STYLE_DOUBLE = 5;

// Determines which scalar styles are possible and returns the preferred style.
// lineWidth = -1 => no limit.
// Pre-conditions: str.length > 0.
// Post-conditions:
//    STYLE_PLAIN or STYLE_SINGLE => no \n are in the string.
//    STYLE_LITERAL => no lines are suitable for folding (or lineWidth is -1).
//    STYLE_FOLDED => a line > lineWidth and can be folded (and lineWidth != -1).
function chooseScalarStyle(string, singleLineOnly, indentPerLevel, lineWidth, testAmbiguousType) {
  var i;
  var char;
  var hasLineBreak = false;
  var hasFoldableLine = false; // only checked if shouldTrackWidth
  var shouldTrackWidth = lineWidth !== -1;
  var previousLineBreak = -1; // count the first line correctly
  var plain = isPlainSafeFirst(string.charCodeAt(0)) && !isWhitespace(string.charCodeAt(string.length - 1));

  if (singleLineOnly) {
    // Case: no block styles.
    // Check for disallowed characters to rule out plain and single.
    for (i = 0; i < string.length; i++) {
      char = string.charCodeAt(i);
      if (!isPrintable(char)) {
        return STYLE_DOUBLE;
      }
      plain = plain && isPlainSafe(char);
    }
  } else {
    // Case: block styles permitted.
    for (i = 0; i < string.length; i++) {
      char = string.charCodeAt(i);
      if (char === CHAR_LINE_FEED) {
        hasLineBreak = true;
        // Check if any line can be folded.
        if (shouldTrackWidth) {
          hasFoldableLine = hasFoldableLine ||
          // Foldable line = too long, and not more-indented.
          i - previousLineBreak - 1 > lineWidth && string[previousLineBreak + 1] !== ' ';
          previousLineBreak = i;
        }
      } else if (!isPrintable(char)) {
        return STYLE_DOUBLE;
      }
      plain = plain && isPlainSafe(char);
    }
    // in case the end is missing a \n
    hasFoldableLine = hasFoldableLine || shouldTrackWidth && i - previousLineBreak - 1 > lineWidth && string[previousLineBreak + 1] !== ' ';
  }
  // Although every style can represent \n without escaping, prefer block styles
  // for multiline, since they're more readable and they don't add empty lines.
  // Also prefer folding a super-long line.
  if (!hasLineBreak && !hasFoldableLine) {
    // Strings interpretable as another type have to be quoted;
    // e.g. the string 'true' vs. the boolean true.
    return plain && !testAmbiguousType(string) ? STYLE_PLAIN : STYLE_SINGLE;
  }
  // Edge case: block indentation indicator can only have one digit.
  if (string[0] === ' ' && indentPerLevel > 9) {
    return STYLE_DOUBLE;
  }
  // At this point we know block styles are valid.
  // Prefer literal style unless we want to fold.
  return hasFoldableLine ? STYLE_FOLDED : STYLE_LITERAL;
}

// Note: line breaking/folding is implemented for only the folded style.
// NB. We drop the last trailing newline (if any) of a returned block scalar
//  since the dumper adds its own newline. This always works:
//     No ending newline => unaffected; already using strip "-" chomping.
//     Ending newline    => removed then restored.
//  Importantly, this keeps the "+" chomp indicator from gaining an extra line.
function writeScalar(state, string, level, iskey) {
  state.dump = function () {
    if (string.length === 0) {
      return "''";
    }
    if (!state.noCompatMode && DEPRECATED_BOOLEANS_SYNTAX.indexOf(string) !== -1) {
      return "'" + string + "'";
    }

    var indent = state.indent * Math.max(1, level); // no 0-indent scalars
    // As indentation gets deeper, let the width decrease monotonically
    // to the lower bound min(state.lineWidth, 40).
    // Note that this implies
    //  state.lineWidth  40 + state.indent: width is fixed at the lower bound.
    //  state.lineWidth > 40 + state.indent: width decreases until the lower bound.
    // This behaves better than a constant minimum width which disallows narrower options,
    // or an indent threshold which causes the width to suddenly increase.
    var lineWidth = state.lineWidth === -1 ? -1 : Math.max(Math.min(state.lineWidth, 40), state.lineWidth - indent);

    // Without knowing if keys are implicit/explicit, assume implicit for safety.
    var singleLineOnly = iskey
    // No block styles in flow mode.
    || state.flowLevel > -1 && level >= state.flowLevel;
    function testAmbiguity(string) {
      return testImplicitResolving(state, string);
    }

    switch (chooseScalarStyle(string, singleLineOnly, state.indent, lineWidth, testAmbiguity)) {
      case STYLE_PLAIN:
        return string;
      case STYLE_SINGLE:
        return "'" + string.replace(/'/g, "''") + "'";
      case STYLE_LITERAL:
        return '|' + blockHeader(string, state.indent) + dropEndingNewline(indentString(string, indent));
      case STYLE_FOLDED:
        return '>' + blockHeader(string, state.indent) + dropEndingNewline(indentString(foldString(string, lineWidth), indent));
      case STYLE_DOUBLE:
        return '"' + escapeString(string, lineWidth) + '"';
      default:
        throw new YAMLException('impossible error: invalid scalar style');
    }
  }();
}

// Pre-conditions: string is valid for a block scalar, 1 <= indentPerLevel <= 9.
function blockHeader(string, indentPerLevel) {
  var indentIndicator = string[0] === ' ' ? String(indentPerLevel) : '';

  // note the special case: the string '\n' counts as a "trailing" empty line.
  var clip = string[string.length - 1] === '\n';
  var keep = clip && (string[string.length - 2] === '\n' || string === '\n');
  var chomp = keep ? '+' : clip ? '' : '-';

  return indentIndicator + chomp + '\n';
}

// (See the note for writeScalar.)
function dropEndingNewline(string) {
  return string[string.length - 1] === '\n' ? string.slice(0, -1) : string;
}

// Note: a long line without a suitable break point will exceed the width limit.
// Pre-conditions: every char in str isPrintable, str.length > 0, width > 0.
function foldString(string, width) {
  // In folded style, $k$ consecutive newlines output as $k+1$ newlines
  // unless they're before or after a more-indented line, or at the very
  // beginning or end, in which case $k$ maps to $k$.
  // Therefore, parse each chunk as newline(s) followed by a content line.
  var lineRe = /(\n+)([^\n]*)/g;

  // first line (possibly an empty line)
  var result = function () {
    var nextLF = string.indexOf('\n');
    nextLF = nextLF !== -1 ? nextLF : string.length;
    lineRe.lastIndex = nextLF;
    return foldLine(string.slice(0, nextLF), width);
  }();
  // If we haven't reached the first content line yet, don't add an extra \n.
  var prevMoreIndented = string[0] === '\n' || string[0] === ' ';
  var moreIndented;

  // rest of the lines
  var match;
  while (match = lineRe.exec(string)) {
    var prefix = match[1],
        line = match[2];
    moreIndented = line[0] === ' ';
    result += prefix + (!prevMoreIndented && !moreIndented && line !== '' ? '\n' : '') + foldLine(line, width);
    prevMoreIndented = moreIndented;
  }

  return result;
}

// Greedy line breaking.
// Picks the longest line under the limit each time,
// otherwise settles for the shortest line over the limit.
// NB. More-indented lines *cannot* be folded, as that would add an extra \n.
function foldLine(line, width) {
  if (line === '' || line[0] === ' ') return line;

  // Since a more-indented line adds a \n, breaks can't be followed by a space.
  var breakRe = / [^ ]/g; // note: the match index will always be <= length-2.
  var match;
  // start is an inclusive index. end, curr, and next are exclusive.
  var start = 0,
      end,
      curr = 0,
      next = 0;
  var result = '';

  // Invariants: 0 <= start <= length-1.
  //   0 <= curr <= next <= max(0, length-2). curr - start <= width.
  // Inside the loop:
  //   A match implies length >= 2, so curr and next are <= length-2.
  while (match = breakRe.exec(line)) {
    next = match.index;
    // maintain invariant: curr - start <= width
    if (next - start > width) {
      end = curr > start ? curr : next; // derive end <= length-2
      result += '\n' + line.slice(start, end);
      // skip the space that was output as \n
      start = end + 1; // derive start <= length-1
    }
    curr = next;
  }

  // By the invariants, start <= length-1, so there is something left over.
  // It is either the whole string or a part starting from non-whitespace.
  result += '\n';
  // Insert a break if the remainder is too long and there is a break available.
  if (line.length - start > width && curr > start) {
    result += line.slice(start, curr) + '\n' + line.slice(curr + 1);
  } else {
    result += line.slice(start);
  }

  return result.slice(1); // drop extra \n joiner
}

// Escapes a double-quoted string.
function escapeString(string) {
  var result = '';
  var char, nextChar;
  var escapeSeq;

  for (var i = 0; i < string.length; i++) {
    char = string.charCodeAt(i);
    // Check for surrogate pairs (reference Unicode 3.0 section "3.7 Surrogates").
    if (char >= 0xD800 && char <= 0xDBFF /* high surrogate */) {
        nextChar = string.charCodeAt(i + 1);
        if (nextChar >= 0xDC00 && nextChar <= 0xDFFF /* low surrogate */) {
            // Combine the surrogate pair and store it escaped.
            result += encodeHex((char - 0xD800) * 0x400 + nextChar - 0xDC00 + 0x10000);
            // Advance index one extra since we already used that char here.
            i++;continue;
          }
      }
    escapeSeq = ESCAPE_SEQUENCES[char];
    result += !escapeSeq && isPrintable(char) ? string[i] : escapeSeq || encodeHex(char);
  }

  return result;
}

function writeFlowSequence(state, level, object) {
  var _result = '',
      _tag = state.tag,
      index,
      length;

  for (index = 0, length = object.length; index < length; index += 1) {
    // Write only valid elements.
    if (writeNode(state, level, object[index], false, false)) {
      if (index !== 0) _result += ',' + (!state.condenseFlow ? ' ' : '');
      _result += state.dump;
    }
  }

  state.tag = _tag;
  state.dump = '[' + _result + ']';
}

function writeBlockSequence(state, level, object, compact) {
  var _result = '',
      _tag = state.tag,
      index,
      length;

  for (index = 0, length = object.length; index < length; index += 1) {
    // Write only valid elements.
    if (writeNode(state, level + 1, object[index], true, true)) {
      if (!compact || index !== 0) {
        _result += generateNextLine(state, level);
      }

      if (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0)) {
        _result += '-';
      } else {
        _result += '- ';
      }

      _result += state.dump;
    }
  }

  state.tag = _tag;
  state.dump = _result || '[]'; // Empty sequence if no valid values.
}

function writeFlowMapping(state, level, object) {
  var _result = '',
      _tag = state.tag,
      objectKeyList = Object.keys(object),
      index,
      length,
      objectKey,
      objectValue,
      pairBuffer;

  for (index = 0, length = objectKeyList.length; index < length; index += 1) {
    pairBuffer = state.condenseFlow ? '"' : '';

    if (index !== 0) pairBuffer += ', ';

    objectKey = objectKeyList[index];
    objectValue = object[objectKey];

    if (!writeNode(state, level, objectKey, false, false)) {
      continue; // Skip this pair because of invalid key;
    }

    if (state.dump.length > 1024) pairBuffer += '? ';

    pairBuffer += state.dump + (state.condenseFlow ? '"' : '') + ':' + (state.condenseFlow ? '' : ' ');

    if (!writeNode(state, level, objectValue, false, false)) {
      continue; // Skip this pair because of invalid value.
    }

    pairBuffer += state.dump;

    // Both key and value are valid.
    _result += pairBuffer;
  }

  state.tag = _tag;
  state.dump = '{' + _result + '}';
}

function writeBlockMapping(state, level, object, compact) {
  var _result = '',
      _tag = state.tag,
      objectKeyList = Object.keys(object),
      index,
      length,
      objectKey,
      objectValue,
      explicitPair,
      pairBuffer;

  // Allow sorting keys so that the output file is deterministic
  if (state.sortKeys === true) {
    // Default sorting
    objectKeyList.sort();
  } else if (typeof state.sortKeys === 'function') {
    // Custom sort function
    objectKeyList.sort(state.sortKeys);
  } else if (state.sortKeys) {
    // Something is wrong
    throw new YAMLException('sortKeys must be a boolean or a function');
  }

  for (index = 0, length = objectKeyList.length; index < length; index += 1) {
    pairBuffer = '';

    if (!compact || index !== 0) {
      pairBuffer += generateNextLine(state, level);
    }

    objectKey = objectKeyList[index];
    objectValue = object[objectKey];

    if (!writeNode(state, level + 1, objectKey, true, true, true)) {
      continue; // Skip this pair because of invalid key.
    }

    explicitPair = state.tag !== null && state.tag !== '?' || state.dump && state.dump.length > 1024;

    if (explicitPair) {
      if (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0)) {
        pairBuffer += '?';
      } else {
        pairBuffer += '? ';
      }
    }

    pairBuffer += state.dump;

    if (explicitPair) {
      pairBuffer += generateNextLine(state, level);
    }

    if (!writeNode(state, level + 1, objectValue, true, explicitPair)) {
      continue; // Skip this pair because of invalid value.
    }

    if (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0)) {
      pairBuffer += ':';
    } else {
      pairBuffer += ': ';
    }

    pairBuffer += state.dump;

    // Both key and value are valid.
    _result += pairBuffer;
  }

  state.tag = _tag;
  state.dump = _result || '{}'; // Empty mapping if no valid pairs.
}

function detectType(state, object, explicit) {
  var _result, typeList, index, length, type, style;

  typeList = explicit ? state.explicitTypes : state.implicitTypes;

  for (index = 0, length = typeList.length; index < length; index += 1) {
    type = typeList[index];

    if ((type.instanceOf || type.predicate) && (!type.instanceOf || typeof object === 'object' && object instanceof type.instanceOf) && (!type.predicate || type.predicate(object))) {

      state.tag = explicit ? type.tag : '?';

      if (type.represent) {
        style = state.styleMap[type.tag] || type.defaultStyle;

        if (_toString.call(type.represent) === '[object Function]') {
          _result = type.represent(object, style);
        } else if (_hasOwnProperty.call(type.represent, style)) {
          _result = type.represent[style](object, style);
        } else {
          throw new YAMLException('!<' + type.tag + '> tag resolver accepts not "' + style + '" style');
        }

        state.dump = _result;
      }

      return true;
    }
  }

  return false;
}

// Serializes `object` and writes it to global `result`.
// Returns true on success, or false on invalid object.
//
function writeNode(state, level, object, block, compact, iskey) {
  state.tag = null;
  state.dump = object;

  if (!detectType(state, object, false)) {
    detectType(state, object, true);
  }

  var type = _toString.call(state.dump);

  if (block) {
    block = state.flowLevel < 0 || state.flowLevel > level;
  }

  var objectOrArray = type === '[object Object]' || type === '[object Array]',
      duplicateIndex,
      duplicate;

  if (objectOrArray) {
    duplicateIndex = state.duplicates.indexOf(object);
    duplicate = duplicateIndex !== -1;
  }

  if (state.tag !== null && state.tag !== '?' || duplicate || state.indent !== 2 && level > 0) {
    compact = false;
  }

  if (duplicate && state.usedDuplicates[duplicateIndex]) {
    state.dump = '*ref_' + duplicateIndex;
  } else {
    if (objectOrArray && duplicate && !state.usedDuplicates[duplicateIndex]) {
      state.usedDuplicates[duplicateIndex] = true;
    }
    if (type === '[object Object]') {
      if (block && Object.keys(state.dump).length !== 0) {
        writeBlockMapping(state, level, state.dump, compact);
        if (duplicate) {
          state.dump = '&ref_' + duplicateIndex + state.dump;
        }
      } else {
        writeFlowMapping(state, level, state.dump);
        if (duplicate) {
          state.dump = '&ref_' + duplicateIndex + ' ' + state.dump;
        }
      }
    } else if (type === '[object Array]') {
      if (block && state.dump.length !== 0) {
        writeBlockSequence(state, level, state.dump, compact);
        if (duplicate) {
          state.dump = '&ref_' + duplicateIndex + state.dump;
        }
      } else {
        writeFlowSequence(state, level, state.dump);
        if (duplicate) {
          state.dump = '&ref_' + duplicateIndex + ' ' + state.dump;
        }
      }
    } else if (type === '[object String]') {
      if (state.tag !== '?') {
        writeScalar(state, state.dump, level, iskey);
      }
    } else {
      if (state.skipInvalid) return false;
      throw new YAMLException('unacceptable kind of an object to dump ' + type);
    }

    if (state.tag !== null && state.tag !== '?') {
      state.dump = '!<' + state.tag + '> ' + state.dump;
    }
  }

  return true;
}

function getDuplicateReferences(object, state) {
  var objects = [],
      duplicatesIndexes = [],
      index,
      length;

  inspectNode(object, objects, duplicatesIndexes);

  for (index = 0, length = duplicatesIndexes.length; index < length; index += 1) {
    state.duplicates.push(objects[duplicatesIndexes[index]]);
  }
  state.usedDuplicates = new Array(length);
}

function inspectNode(object, objects, duplicatesIndexes) {
  var objectKeyList, index, length;

  if (object !== null && typeof object === 'object') {
    index = objects.indexOf(object);
    if (index !== -1) {
      if (duplicatesIndexes.indexOf(index) === -1) {
        duplicatesIndexes.push(index);
      }
    } else {
      objects.push(object);

      if (Array.isArray(object)) {
        for (index = 0, length = object.length; index < length; index += 1) {
          inspectNode(object[index], objects, duplicatesIndexes);
        }
      } else {
        objectKeyList = Object.keys(object);

        for (index = 0, length = objectKeyList.length; index < length; index += 1) {
          inspectNode(object[objectKeyList[index]], objects, duplicatesIndexes);
        }
      }
    }
  }
}

function dump(input, options) {
  options = options || {};

  var state = new State(options);

  if (!state.noRefs) getDuplicateReferences(input, state);

  if (writeNode(state, 0, input, true, true)) return state.dump + '\n';

  return '';
}

function safeDump(input, options) {
  return dump(input, common.extend({ schema: DEFAULT_SAFE_SCHEMA }, options));
}

module.exports.dump = dump;
module.exports.safeDump = safeDump;

/***/ }),
/* 159 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
class Lazy {
    constructor(creator) {
        this.creator = creator;
    }
    get hasValue() {
        return this.creator == null;
    }
    get value() {
        if (this.creator == null) {
            return this._value;
        }
        this.value = this.creator();
        return this._value;
    }
    set value(value) {
        this._value = value;
        this.creator = null;
    }
}
exports.Lazy = Lazy; //# sourceMappingURL=main.js.map

/***/ }),
/* 160 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var SourceMapConsumer = __webpack_require__(161).SourceMapConsumer;
var path = __webpack_require__(0);

var fs;
try {
  fs = __webpack_require__(12);
  if (!fs.existsSync || !fs.readFileSync) {
    // fs doesn't have all methods we need
    fs = null;
  }
} catch (err) {}
/* nop */


// Only install once if called multiple times
var errorFormatterInstalled = false;
var uncaughtShimInstalled = false;

// If true, the caches are reset before a stack trace formatting operation
var emptyCacheBetweenOperations = false;

// Supports {browser, node, auto}
var environment = "auto";

// Maps a file path to a string containing the file contents
var fileContentsCache = {};

// Maps a file path to a source map for that file
var sourceMapCache = {};

// Regex for detecting source maps
var reSourceMap = /^data:application\/json[^,]+base64,/;

// Priority list of retrieve handlers
var retrieveFileHandlers = [];
var retrieveMapHandlers = [];

function isInBrowser() {
  if (environment === "browser") return true;
  if (environment === "node") return false;
  return typeof window !== 'undefined' && typeof XMLHttpRequest === 'function' && !(window.require && window.module && window.process && window.process.type === "renderer");
}

function hasGlobalProcessEventEmitter() {
  return typeof process === 'object' && process !== null && typeof process.on === 'function';
}

function handlerExec(list) {
  return function (arg) {
    for (var i = 0; i < list.length; i++) {
      var ret = list[i](arg);
      if (ret) {
        return ret;
      }
    }
    return null;
  };
}

var retrieveFile = handlerExec(retrieveFileHandlers);

retrieveFileHandlers.push(function (path) {
  // Trim the path to make sure there is no extra whitespace.
  path = path.trim();
  if (path in fileContentsCache) {
    return fileContentsCache[path];
  }

  var contents = null;
  if (!fs) {
    // Use SJAX if we are in the browser
    var xhr = new XMLHttpRequest();
    xhr.open('GET', path, false);
    xhr.send(null);
    var contents = null;
    if (xhr.readyState === 4 && xhr.status === 200) {
      contents = xhr.responseText;
    }
  } else if (fs.existsSync(path)) {
    // Otherwise, use the filesystem
    try {
      contents = fs.readFileSync(path, 'utf8');
    } catch (er) {
      contents = '';
    }
  }

  return fileContentsCache[path] = contents;
});

// Support URLs relative to a directory, but be careful about a protocol prefix
// in case we are in the browser (i.e. directories may start with "http://")
function supportRelativeURL(file, url) {
  if (!file) return url;
  var dir = path.dirname(file);
  var match = /^\w+:\/\/[^\/]*/.exec(dir);
  var protocol = match ? match[0] : '';
  return protocol + path.resolve(dir.slice(protocol.length), url);
}

function retrieveSourceMapURL(source) {
  var fileData;

  if (isInBrowser()) {
    try {
      var xhr = new XMLHttpRequest();
      xhr.open('GET', source, false);
      xhr.send(null);
      fileData = xhr.readyState === 4 ? xhr.responseText : null;

      // Support providing a sourceMappingURL via the SourceMap header
      var sourceMapHeader = xhr.getResponseHeader("SourceMap") || xhr.getResponseHeader("X-SourceMap");
      if (sourceMapHeader) {
        return sourceMapHeader;
      }
    } catch (e) {}
  }

  // Get the URL of the source map
  fileData = retrieveFile(source);
  var re = /(?:\/\/[@#][ \t]+sourceMappingURL=([^\s'"]+?)[ \t]*$)|(?:\/\*[@#][ \t]+sourceMappingURL=([^\*]+?)[ \t]*(?:\*\/)[ \t]*$)/mg;
  // Keep executing the search to find the *last* sourceMappingURL to avoid
  // picking up sourceMappingURLs from comments, strings, etc.
  var lastMatch, match;
  while (match = re.exec(fileData)) lastMatch = match;
  if (!lastMatch) return null;
  return lastMatch[1];
};

// Can be overridden by the retrieveSourceMap option to install. Takes a
// generated source filename; returns a {map, optional url} object, or null if
// there is no source map.  The map field may be either a string or the parsed
// JSON object (ie, it must be a valid argument to the SourceMapConsumer
// constructor).
var retrieveSourceMap = handlerExec(retrieveMapHandlers);
retrieveMapHandlers.push(function (source) {
  var sourceMappingURL = retrieveSourceMapURL(source);
  if (!sourceMappingURL) return null;

  // Read the contents of the source map
  var sourceMapData;
  if (reSourceMap.test(sourceMappingURL)) {
    // Support source map URL as a data url
    var rawData = sourceMappingURL.slice(sourceMappingURL.indexOf(',') + 1);
    sourceMapData = new Buffer(rawData, "base64").toString();
    sourceMappingURL = source;
  } else {
    // Support source map URLs relative to the source URL
    sourceMappingURL = supportRelativeURL(source, sourceMappingURL);
    sourceMapData = retrieveFile(sourceMappingURL);
  }

  if (!sourceMapData) {
    return null;
  }

  return {
    url: sourceMappingURL,
    map: sourceMapData
  };
});

function mapSourcePosition(position) {
  var sourceMap = sourceMapCache[position.source];
  if (!sourceMap) {
    // Call the (overrideable) retrieveSourceMap function to get the source map.
    var urlAndMap = retrieveSourceMap(position.source);
    if (urlAndMap) {
      sourceMap = sourceMapCache[position.source] = {
        url: urlAndMap.url,
        map: new SourceMapConsumer(urlAndMap.map)
      };

      // Load all sources stored inline with the source map into the file cache
      // to pretend like they are already loaded. They may not exist on disk.
      if (sourceMap.map.sourcesContent) {
        sourceMap.map.sources.forEach(function (source, i) {
          var contents = sourceMap.map.sourcesContent[i];
          if (contents) {
            var url = supportRelativeURL(sourceMap.url, source);
            fileContentsCache[url] = contents;
          }
        });
      }
    } else {
      sourceMap = sourceMapCache[position.source] = {
        url: null,
        map: null
      };
    }
  }

  // Resolve the source URL relative to the URL of the source map
  if (sourceMap && sourceMap.map) {
    var originalPosition = sourceMap.map.originalPositionFor(position);

    // Only return the original position if a matching line was found. If no
    // matching line is found then we return position instead, which will cause
    // the stack trace to print the path and line for the compiled file. It is
    // better to give a precise location in the compiled file than a vague
    // location in the original file.
    if (originalPosition.source !== null) {
      originalPosition.source = supportRelativeURL(sourceMap.url, originalPosition.source);
      return originalPosition;
    }
  }

  return position;
}

// Parses code generated by FormatEvalOrigin(), a function inside V8:
// https://code.google.com/p/v8/source/browse/trunk/src/messages.js
function mapEvalOrigin(origin) {
  // Most eval() calls are in this format
  var match = /^eval at ([^(]+) \((.+):(\d+):(\d+)\)$/.exec(origin);
  if (match) {
    var position = mapSourcePosition({
      source: match[2],
      line: +match[3],
      column: match[4] - 1
    });
    return 'eval at ' + match[1] + ' (' + position.source + ':' + position.line + ':' + (position.column + 1) + ')';
  }

  // Parse nested eval() calls using recursion
  match = /^eval at ([^(]+) \((.+)\)$/.exec(origin);
  if (match) {
    return 'eval at ' + match[1] + ' (' + mapEvalOrigin(match[2]) + ')';
  }

  // Make sure we still return useful information if we didn't find anything
  return origin;
}

// This is copied almost verbatim from the V8 source code at
// https://code.google.com/p/v8/source/browse/trunk/src/messages.js. The
// implementation of wrapCallSite() used to just forward to the actual source
// code of CallSite.prototype.toString but unfortunately a new release of V8
// did something to the prototype chain and broke the shim. The only fix I
// could find was copy/paste.
function CallSiteToString() {
  var fileName;
  var fileLocation = "";
  if (this.isNative()) {
    fileLocation = "native";
  } else {
    fileName = this.getScriptNameOrSourceURL();
    if (!fileName && this.isEval()) {
      fileLocation = this.getEvalOrigin();
      fileLocation += ", "; // Expecting source position to follow.
    }

    if (fileName) {
      fileLocation += fileName;
    } else {
      // Source code does not originate from a file and is not native, but we
      // can still get the source position inside the source string, e.g. in
      // an eval string.
      fileLocation += "<anonymous>";
    }
    var lineNumber = this.getLineNumber();
    if (lineNumber != null) {
      fileLocation += ":" + lineNumber;
      var columnNumber = this.getColumnNumber();
      if (columnNumber) {
        fileLocation += ":" + columnNumber;
      }
    }
  }

  var line = "";
  var functionName = this.getFunctionName();
  var addSuffix = true;
  var isConstructor = this.isConstructor();
  var isMethodCall = !(this.isToplevel() || isConstructor);
  if (isMethodCall) {
    var typeName = this.getTypeName();
    // Fixes shim to be backward compatable with Node v0 to v4
    if (typeName === "[object Object]") {
      typeName = "null";
    }
    var methodName = this.getMethodName();
    if (functionName) {
      if (typeName && functionName.indexOf(typeName) != 0) {
        line += typeName + ".";
      }
      line += functionName;
      if (methodName && functionName.indexOf("." + methodName) != functionName.length - methodName.length - 1) {
        line += " [as " + methodName + "]";
      }
    } else {
      line += typeName + "." + (methodName || "<anonymous>");
    }
  } else if (isConstructor) {
    line += "new " + (functionName || "<anonymous>");
  } else if (functionName) {
    line += functionName;
  } else {
    line += fileLocation;
    addSuffix = false;
  }
  if (addSuffix) {
    line += " (" + fileLocation + ")";
  }
  return line;
}

function cloneCallSite(frame) {
  var object = {};
  Object.getOwnPropertyNames(Object.getPrototypeOf(frame)).forEach(function (name) {
    object[name] = /^(?:is|get)/.test(name) ? function () {
      return frame[name].call(frame);
    } : frame[name];
  });
  object.toString = CallSiteToString;
  return object;
}

function wrapCallSite(frame) {
  if (frame.isNative()) {
    return frame;
  }

  // Most call sites will return the source file from getFileName(), but code
  // passed to eval() ending in "//# sourceURL=..." will return the source file
  // from getScriptNameOrSourceURL() instead
  var source = frame.getFileName() || frame.getScriptNameOrSourceURL();
  if (source) {
    var line = frame.getLineNumber();
    var column = frame.getColumnNumber() - 1;

    // Fix position in Node where some (internal) code is prepended.
    // See https://github.com/evanw/node-source-map-support/issues/36
    var headerLength = 62;
    if (line === 1 && column > headerLength && !isInBrowser() && !frame.isEval()) {
      column -= headerLength;
    }

    var position = mapSourcePosition({
      source: source,
      line: line,
      column: column
    });
    frame = cloneCallSite(frame);
    frame.getFileName = function () {
      return position.source;
    };
    frame.getLineNumber = function () {
      return position.line;
    };
    frame.getColumnNumber = function () {
      return position.column + 1;
    };
    frame.getScriptNameOrSourceURL = function () {
      return position.source;
    };
    return frame;
  }

  // Code called using eval() needs special handling
  var origin = frame.isEval() && frame.getEvalOrigin();
  if (origin) {
    origin = mapEvalOrigin(origin);
    frame = cloneCallSite(frame);
    frame.getEvalOrigin = function () {
      return origin;
    };
    return frame;
  }

  // If we get here then we were unable to change the source position
  return frame;
}

// This function is part of the V8 stack trace API, for more info see:
// http://code.google.com/p/v8/wiki/JavaScriptStackTraceApi
function prepareStackTrace(error, stack) {
  if (emptyCacheBetweenOperations) {
    fileContentsCache = {};
    sourceMapCache = {};
  }

  return error + stack.map(function (frame) {
    return '\n    at ' + wrapCallSite(frame);
  }).join('');
}

// Generate position and snippet of original source with pointer
function getErrorSource(error) {
  var match = /\n    at [^(]+ \((.*):(\d+):(\d+)\)/.exec(error.stack);
  if (match) {
    var source = match[1];
    var line = +match[2];
    var column = +match[3];

    // Support the inline sourceContents inside the source map
    var contents = fileContentsCache[source];

    // Support files on disk
    if (!contents && fs && fs.existsSync(source)) {
      try {
        contents = fs.readFileSync(source, 'utf8');
      } catch (er) {
        contents = '';
      }
    }

    // Format the line from the original source code like node does
    if (contents) {
      var code = contents.split(/(?:\r\n|\r|\n)/)[line - 1];
      if (code) {
        return source + ':' + line + '\n' + code + '\n' + new Array(column).join(' ') + '^';
      }
    }
  }
  return null;
}

function printErrorAndExit(error) {
  var source = getErrorSource(error);

  if (source) {
    console.error();
    console.error(source);
  }

  console.error(error.stack);
  process.exit(1);
}

function shimEmitUncaughtException() {
  var origEmit = process.emit;

  process.emit = function (type) {
    if (type === 'uncaughtException') {
      var hasStack = arguments[1] && arguments[1].stack;
      var hasListeners = this.listeners(type).length > 0;

      if (hasStack && !hasListeners) {
        return printErrorAndExit(arguments[1]);
      }
    }

    return origEmit.apply(this, arguments);
  };
}

exports.wrapCallSite = wrapCallSite;
exports.getErrorSource = getErrorSource;
exports.mapSourcePosition = mapSourcePosition;
exports.retrieveSourceMap = retrieveSourceMap;

exports.install = function (options) {
  options = options || {};

  if (options.environment) {
    environment = options.environment;
    if (["node", "browser", "auto"].indexOf(environment) === -1) {
      throw new Error("environment " + environment + " was unknown. Available options are {auto, browser, node}");
    }
  }

  // Allow sources to be found by methods other than reading the files
  // directly from disk.
  if (options.retrieveFile) {
    if (options.overrideRetrieveFile) {
      retrieveFileHandlers.length = 0;
    }

    retrieveFileHandlers.unshift(options.retrieveFile);
  }

  // Allow source maps to be found by methods other than reading the files
  // directly from disk.
  if (options.retrieveSourceMap) {
    if (options.overrideRetrieveSourceMap) {
      retrieveMapHandlers.length = 0;
    }

    retrieveMapHandlers.unshift(options.retrieveSourceMap);
  }

  // Support runtime transpilers that include inline source maps
  if (options.hookRequire && !isInBrowser()) {
    var Module;
    try {
      Module = __webpack_require__(168);
    } catch (err) {
      // NOP: Loading in catch block to convert webpack error to warning.
    }
    var $compile = Module.prototype._compile;

    if (!$compile.__sourceMapSupport) {
      Module.prototype._compile = function (content, filename) {
        fileContentsCache[filename] = content;
        sourceMapCache[filename] = undefined;
        return $compile.call(this, content, filename);
      };

      Module.prototype._compile.__sourceMapSupport = true;
    }
  }

  // Configure options
  if (!emptyCacheBetweenOperations) {
    emptyCacheBetweenOperations = 'emptyCacheBetweenOperations' in options ? options.emptyCacheBetweenOperations : false;
  }

  // Install the error reformatter
  if (!errorFormatterInstalled) {
    errorFormatterInstalled = true;
    Error.prepareStackTrace = prepareStackTrace;
  }

  if (!uncaughtShimInstalled) {
    var installHandler = 'handleUncaughtExceptions' in options ? options.handleUncaughtExceptions : true;

    // Provide the option to not install the uncaught exception handler. This is
    // to support other uncaught exception handlers (in test frameworks, for
    // example). If this handler is not installed and there are no other uncaught
    // exception handlers, uncaught exceptions will be caught by node's built-in
    // exception handler and the process will still be terminated. However, the
    // generated JavaScript code will be shown above the stack trace instead of
    // the original source code.
    if (installHandler && hasGlobalProcessEventEmitter()) {
      uncaughtShimInstalled = true;
      shimEmitUncaughtException();
    }
  }
};

/***/ }),
/* 161 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/*
 * Copyright 2009-2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE.txt or:
 * http://opensource.org/licenses/BSD-3-Clause
 */
exports.SourceMapGenerator = __webpack_require__(56).SourceMapGenerator;
exports.SourceMapConsumer = __webpack_require__(164).SourceMapConsumer;
exports.SourceNode = __webpack_require__(167).SourceNode;

/***/ }),
/* 162 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/* -*- Mode: js; js-indent-level: 2; -*- */
/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */

var intToCharMap = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'.split('');

/**
 * Encode an integer in the range of 0 to 63 to a single base 64 digit.
 */
exports.encode = function (number) {
  if (0 <= number && number < intToCharMap.length) {
    return intToCharMap[number];
  }
  throw new TypeError("Must be between 0 and 63: " + number);
};

/**
 * Decode a single base 64 character code digit to an integer. Returns -1 on
 * failure.
 */
exports.decode = function (charCode) {
  var bigA = 65; // 'A'
  var bigZ = 90; // 'Z'

  var littleA = 97; // 'a'
  var littleZ = 122; // 'z'

  var zero = 48; // '0'
  var nine = 57; // '9'

  var plus = 43; // '+'
  var slash = 47; // '/'

  var littleOffset = 26;
  var numberOffset = 52;

  // 0 - 25: ABCDEFGHIJKLMNOPQRSTUVWXYZ
  if (bigA <= charCode && charCode <= bigZ) {
    return charCode - bigA;
  }

  // 26 - 51: abcdefghijklmnopqrstuvwxyz
  if (littleA <= charCode && charCode <= littleZ) {
    return charCode - littleA + littleOffset;
  }

  // 52 - 61: 0123456789
  if (zero <= charCode && charCode <= nine) {
    return charCode - zero + numberOffset;
  }

  // 62: +
  if (charCode == plus) {
    return 62;
  }

  // 63: /
  if (charCode == slash) {
    return 63;
  }

  // Invalid base64 digit.
  return -1;
};

/***/ }),
/* 163 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/* -*- Mode: js; js-indent-level: 2; -*- */
/*
 * Copyright 2014 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */

var util = __webpack_require__(23);

/**
 * Determine whether mappingB is after mappingA with respect to generated
 * position.
 */
function generatedPositionAfter(mappingA, mappingB) {
  // Optimized for most common case
  var lineA = mappingA.generatedLine;
  var lineB = mappingB.generatedLine;
  var columnA = mappingA.generatedColumn;
  var columnB = mappingB.generatedColumn;
  return lineB > lineA || lineB == lineA && columnB >= columnA || util.compareByGeneratedPositionsInflated(mappingA, mappingB) <= 0;
}

/**
 * A data structure to provide a sorted view of accumulated mappings in a
 * performance conscious manner. It trades a neglibable overhead in general
 * case for a large speedup in case of mappings being added in order.
 */
function MappingList() {
  this._array = [];
  this._sorted = true;
  // Serves as infimum
  this._last = { generatedLine: -1, generatedColumn: 0 };
}

/**
 * Iterate through internal items. This method takes the same arguments that
 * `Array.prototype.forEach` takes.
 *
 * NOTE: The order of the mappings is NOT guaranteed.
 */
MappingList.prototype.unsortedForEach = function MappingList_forEach(aCallback, aThisArg) {
  this._array.forEach(aCallback, aThisArg);
};

/**
 * Add the given source mapping.
 *
 * @param Object aMapping
 */
MappingList.prototype.add = function MappingList_add(aMapping) {
  if (generatedPositionAfter(this._last, aMapping)) {
    this._last = aMapping;
    this._array.push(aMapping);
  } else {
    this._sorted = false;
    this._array.push(aMapping);
  }
};

/**
 * Returns the flat, sorted array of mappings. The mappings are sorted by
 * generated position.
 *
 * WARNING: This method returns internal data without copying, for
 * performance. The return value must NOT be mutated, and should be treated as
 * an immutable borrow. If you want to take ownership, you must make your own
 * copy.
 */
MappingList.prototype.toArray = function MappingList_toArray() {
  if (!this._sorted) {
    this._array.sort(util.compareByGeneratedPositionsInflated);
    this._sorted = true;
  }
  return this._array;
};

exports.MappingList = MappingList;

/***/ }),
/* 164 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/* -*- Mode: js; js-indent-level: 2; -*- */
/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */

var util = __webpack_require__(23);
var binarySearch = __webpack_require__(165);
var ArraySet = __webpack_require__(58).ArraySet;
var base64VLQ = __webpack_require__(57);
var quickSort = __webpack_require__(166).quickSort;

function SourceMapConsumer(aSourceMap, aSourceMapURL) {
  var sourceMap = aSourceMap;
  if (typeof aSourceMap === 'string') {
    sourceMap = util.parseSourceMapInput(aSourceMap);
  }

  return sourceMap.sections != null ? new IndexedSourceMapConsumer(sourceMap, aSourceMapURL) : new BasicSourceMapConsumer(sourceMap, aSourceMapURL);
}

SourceMapConsumer.fromSourceMap = function (aSourceMap, aSourceMapURL) {
  return BasicSourceMapConsumer.fromSourceMap(aSourceMap, aSourceMapURL);
};

/**
 * The version of the source mapping spec that we are consuming.
 */
SourceMapConsumer.prototype._version = 3;

// `__generatedMappings` and `__originalMappings` are arrays that hold the
// parsed mapping coordinates from the source map's "mappings" attribute. They
// are lazily instantiated, accessed via the `_generatedMappings` and
// `_originalMappings` getters respectively, and we only parse the mappings
// and create these arrays once queried for a source location. We jump through
// these hoops because there can be many thousands of mappings, and parsing
// them is expensive, so we only want to do it if we must.
//
// Each object in the arrays is of the form:
//
//     {
//       generatedLine: The line number in the generated code,
//       generatedColumn: The column number in the generated code,
//       source: The path to the original source file that generated this
//               chunk of code,
//       originalLine: The line number in the original source that
//                     corresponds to this chunk of generated code,
//       originalColumn: The column number in the original source that
//                       corresponds to this chunk of generated code,
//       name: The name of the original symbol which generated this chunk of
//             code.
//     }
//
// All properties except for `generatedLine` and `generatedColumn` can be
// `null`.
//
// `_generatedMappings` is ordered by the generated positions.
//
// `_originalMappings` is ordered by the original positions.

SourceMapConsumer.prototype.__generatedMappings = null;
Object.defineProperty(SourceMapConsumer.prototype, '_generatedMappings', {
  configurable: true,
  enumerable: true,
  get: function () {
    if (!this.__generatedMappings) {
      this._parseMappings(this._mappings, this.sourceRoot);
    }

    return this.__generatedMappings;
  }
});

SourceMapConsumer.prototype.__originalMappings = null;
Object.defineProperty(SourceMapConsumer.prototype, '_originalMappings', {
  configurable: true,
  enumerable: true,
  get: function () {
    if (!this.__originalMappings) {
      this._parseMappings(this._mappings, this.sourceRoot);
    }

    return this.__originalMappings;
  }
});

SourceMapConsumer.prototype._charIsMappingSeparator = function SourceMapConsumer_charIsMappingSeparator(aStr, index) {
  var c = aStr.charAt(index);
  return c === ";" || c === ",";
};

/**
 * Parse the mappings in a string in to a data structure which we can easily
 * query (the ordered arrays in the `this.__generatedMappings` and
 * `this.__originalMappings` properties).
 */
SourceMapConsumer.prototype._parseMappings = function SourceMapConsumer_parseMappings(aStr, aSourceRoot) {
  throw new Error("Subclasses must implement _parseMappings");
};

SourceMapConsumer.GENERATED_ORDER = 1;
SourceMapConsumer.ORIGINAL_ORDER = 2;

SourceMapConsumer.GREATEST_LOWER_BOUND = 1;
SourceMapConsumer.LEAST_UPPER_BOUND = 2;

/**
 * Iterate over each mapping between an original source/line/column and a
 * generated line/column in this source map.
 *
 * @param Function aCallback
 *        The function that is called with each mapping.
 * @param Object aContext
 *        Optional. If specified, this object will be the value of `this` every
 *        time that `aCallback` is called.
 * @param aOrder
 *        Either `SourceMapConsumer.GENERATED_ORDER` or
 *        `SourceMapConsumer.ORIGINAL_ORDER`. Specifies whether you want to
 *        iterate over the mappings sorted by the generated file's line/column
 *        order or the original's source/line/column order, respectively. Defaults to
 *        `SourceMapConsumer.GENERATED_ORDER`.
 */
SourceMapConsumer.prototype.eachMapping = function SourceMapConsumer_eachMapping(aCallback, aContext, aOrder) {
  var context = aContext || null;
  var order = aOrder || SourceMapConsumer.GENERATED_ORDER;

  var mappings;
  switch (order) {
    case SourceMapConsumer.GENERATED_ORDER:
      mappings = this._generatedMappings;
      break;
    case SourceMapConsumer.ORIGINAL_ORDER:
      mappings = this._originalMappings;
      break;
    default:
      throw new Error("Unknown order of iteration.");
  }

  var sourceRoot = this.sourceRoot;
  mappings.map(function (mapping) {
    var source = mapping.source === null ? null : this._sources.at(mapping.source);
    source = util.computeSourceURL(sourceRoot, source, this._sourceMapURL);
    return {
      source: source,
      generatedLine: mapping.generatedLine,
      generatedColumn: mapping.generatedColumn,
      originalLine: mapping.originalLine,
      originalColumn: mapping.originalColumn,
      name: mapping.name === null ? null : this._names.at(mapping.name)
    };
  }, this).forEach(aCallback, context);
};

/**
 * Returns all generated line and column information for the original source,
 * line, and column provided. If no column is provided, returns all mappings
 * corresponding to a either the line we are searching for or the next
 * closest line that has any mappings. Otherwise, returns all mappings
 * corresponding to the given line and either the column we are searching for
 * or the next closest column that has any offsets.
 *
 * The only argument is an object with the following properties:
 *
 *   - source: The filename of the original source.
 *   - line: The line number in the original source.  The line number is 1-based.
 *   - column: Optional. the column number in the original source.
 *    The column number is 0-based.
 *
 * and an array of objects is returned, each with the following properties:
 *
 *   - line: The line number in the generated source, or null.  The
 *    line number is 1-based.
 *   - column: The column number in the generated source, or null.
 *    The column number is 0-based.
 */
SourceMapConsumer.prototype.allGeneratedPositionsFor = function SourceMapConsumer_allGeneratedPositionsFor(aArgs) {
  var line = util.getArg(aArgs, 'line');

  // When there is no exact match, BasicSourceMapConsumer.prototype._findMapping
  // returns the index of the closest mapping less than the needle. By
  // setting needle.originalColumn to 0, we thus find the last mapping for
  // the given line, provided such a mapping exists.
  var needle = {
    source: util.getArg(aArgs, 'source'),
    originalLine: line,
    originalColumn: util.getArg(aArgs, 'column', 0)
  };

  needle.source = this._findSourceIndex(needle.source);
  if (needle.source < 0) {
    return [];
  }

  var mappings = [];

  var index = this._findMapping(needle, this._originalMappings, "originalLine", "originalColumn", util.compareByOriginalPositions, binarySearch.LEAST_UPPER_BOUND);
  if (index >= 0) {
    var mapping = this._originalMappings[index];

    if (aArgs.column === undefined) {
      var originalLine = mapping.originalLine;

      // Iterate until either we run out of mappings, or we run into
      // a mapping for a different line than the one we found. Since
      // mappings are sorted, this is guaranteed to find all mappings for
      // the line we found.
      while (mapping && mapping.originalLine === originalLine) {
        mappings.push({
          line: util.getArg(mapping, 'generatedLine', null),
          column: util.getArg(mapping, 'generatedColumn', null),
          lastColumn: util.getArg(mapping, 'lastGeneratedColumn', null)
        });

        mapping = this._originalMappings[++index];
      }
    } else {
      var originalColumn = mapping.originalColumn;

      // Iterate until either we run out of mappings, or we run into
      // a mapping for a different line than the one we were searching for.
      // Since mappings are sorted, this is guaranteed to find all mappings for
      // the line we are searching for.
      while (mapping && mapping.originalLine === line && mapping.originalColumn == originalColumn) {
        mappings.push({
          line: util.getArg(mapping, 'generatedLine', null),
          column: util.getArg(mapping, 'generatedColumn', null),
          lastColumn: util.getArg(mapping, 'lastGeneratedColumn', null)
        });

        mapping = this._originalMappings[++index];
      }
    }
  }

  return mappings;
};

exports.SourceMapConsumer = SourceMapConsumer;

/**
 * A BasicSourceMapConsumer instance represents a parsed source map which we can
 * query for information about the original file positions by giving it a file
 * position in the generated source.
 *
 * The first parameter is the raw source map (either as a JSON string, or
 * already parsed to an object). According to the spec, source maps have the
 * following attributes:
 *
 *   - version: Which version of the source map spec this map is following.
 *   - sources: An array of URLs to the original source files.
 *   - names: An array of identifiers which can be referrenced by individual mappings.
 *   - sourceRoot: Optional. The URL root from which all sources are relative.
 *   - sourcesContent: Optional. An array of contents of the original source files.
 *   - mappings: A string of base64 VLQs which contain the actual mappings.
 *   - file: Optional. The generated file this source map is associated with.
 *
 * Here is an example source map, taken from the source map spec[0]:
 *
 *     {
 *       version : 3,
 *       file: "out.js",
 *       sourceRoot : "",
 *       sources: ["foo.js", "bar.js"],
 *       names: ["src", "maps", "are", "fun"],
 *       mappings: "AA,AB;;ABCDE;"
 *     }
 *
 * The second parameter, if given, is a string whose value is the URL
 * at which the source map was found.  This URL is used to compute the
 * sources array.
 *
 * [0]: https://docs.google.com/document/d/1U1RGAehQwRypUTovF1KRlpiOFze0b-_2gc6fAH0KY0k/edit?pli=1#
 */
function BasicSourceMapConsumer(aSourceMap, aSourceMapURL) {
  var sourceMap = aSourceMap;
  if (typeof aSourceMap === 'string') {
    sourceMap = util.parseSourceMapInput(aSourceMap);
  }

  var version = util.getArg(sourceMap, 'version');
  var sources = util.getArg(sourceMap, 'sources');
  // Sass 3.3 leaves out the 'names' array, so we deviate from the spec (which
  // requires the array) to play nice here.
  var names = util.getArg(sourceMap, 'names', []);
  var sourceRoot = util.getArg(sourceMap, 'sourceRoot', null);
  var sourcesContent = util.getArg(sourceMap, 'sourcesContent', null);
  var mappings = util.getArg(sourceMap, 'mappings');
  var file = util.getArg(sourceMap, 'file', null);

  // Once again, Sass deviates from the spec and supplies the version as a
  // string rather than a number, so we use loose equality checking here.
  if (version != this._version) {
    throw new Error('Unsupported version: ' + version);
  }

  if (sourceRoot) {
    sourceRoot = util.normalize(sourceRoot);
  }

  sources = sources.map(String)
  // Some source maps produce relative source paths like "./foo.js" instead of
  // "foo.js".  Normalize these first so that future comparisons will succeed.
  // See bugzil.la/1090768.
  .map(util.normalize)
  // Always ensure that absolute sources are internally stored relative to
  // the source root, if the source root is absolute. Not doing this would
  // be particularly problematic when the source root is a prefix of the
  // source (valid, but why??). See github issue #199 and bugzil.la/1188982.
  .map(function (source) {
    return sourceRoot && util.isAbsolute(sourceRoot) && util.isAbsolute(source) ? util.relative(sourceRoot, source) : source;
  });

  // Pass `true` below to allow duplicate names and sources. While source maps
  // are intended to be compressed and deduplicated, the TypeScript compiler
  // sometimes generates source maps with duplicates in them. See Github issue
  // #72 and bugzil.la/889492.
  this._names = ArraySet.fromArray(names.map(String), true);
  this._sources = ArraySet.fromArray(sources, true);

  this._absoluteSources = this._sources.toArray().map(function (s) {
    return util.computeSourceURL(sourceRoot, s, aSourceMapURL);
  });

  this.sourceRoot = sourceRoot;
  this.sourcesContent = sourcesContent;
  this._mappings = mappings;
  this._sourceMapURL = aSourceMapURL;
  this.file = file;
}

BasicSourceMapConsumer.prototype = Object.create(SourceMapConsumer.prototype);
BasicSourceMapConsumer.prototype.consumer = SourceMapConsumer;

/**
 * Utility function to find the index of a source.  Returns -1 if not
 * found.
 */
BasicSourceMapConsumer.prototype._findSourceIndex = function (aSource) {
  var relativeSource = aSource;
  if (this.sourceRoot != null) {
    relativeSource = util.relative(this.sourceRoot, relativeSource);
  }

  if (this._sources.has(relativeSource)) {
    return this._sources.indexOf(relativeSource);
  }

  // Maybe aSource is an absolute URL as returned by |sources|.  In
  // this case we can't simply undo the transform.
  var i;
  for (i = 0; i < this._absoluteSources.length; ++i) {
    if (this._absoluteSources[i] == aSource) {
      return i;
    }
  }

  return -1;
};

/**
 * Create a BasicSourceMapConsumer from a SourceMapGenerator.
 *
 * @param SourceMapGenerator aSourceMap
 *        The source map that will be consumed.
 * @param String aSourceMapURL
 *        The URL at which the source map can be found (optional)
 * @returns BasicSourceMapConsumer
 */
BasicSourceMapConsumer.fromSourceMap = function SourceMapConsumer_fromSourceMap(aSourceMap, aSourceMapURL) {
  var smc = Object.create(BasicSourceMapConsumer.prototype);

  var names = smc._names = ArraySet.fromArray(aSourceMap._names.toArray(), true);
  var sources = smc._sources = ArraySet.fromArray(aSourceMap._sources.toArray(), true);
  smc.sourceRoot = aSourceMap._sourceRoot;
  smc.sourcesContent = aSourceMap._generateSourcesContent(smc._sources.toArray(), smc.sourceRoot);
  smc.file = aSourceMap._file;
  smc._sourceMapURL = aSourceMapURL;
  smc._absoluteSources = smc._sources.toArray().map(function (s) {
    return util.computeSourceURL(smc.sourceRoot, s, aSourceMapURL);
  });

  // Because we are modifying the entries (by converting string sources and
  // names to indices into the sources and names ArraySets), we have to make
  // a copy of the entry or else bad things happen. Shared mutable state
  // strikes again! See github issue #191.

  var generatedMappings = aSourceMap._mappings.toArray().slice();
  var destGeneratedMappings = smc.__generatedMappings = [];
  var destOriginalMappings = smc.__originalMappings = [];

  for (var i = 0, length = generatedMappings.length; i < length; i++) {
    var srcMapping = generatedMappings[i];
    var destMapping = new Mapping();
    destMapping.generatedLine = srcMapping.generatedLine;
    destMapping.generatedColumn = srcMapping.generatedColumn;

    if (srcMapping.source) {
      destMapping.source = sources.indexOf(srcMapping.source);
      destMapping.originalLine = srcMapping.originalLine;
      destMapping.originalColumn = srcMapping.originalColumn;

      if (srcMapping.name) {
        destMapping.name = names.indexOf(srcMapping.name);
      }

      destOriginalMappings.push(destMapping);
    }

    destGeneratedMappings.push(destMapping);
  }

  quickSort(smc.__originalMappings, util.compareByOriginalPositions);

  return smc;
};

/**
 * The version of the source mapping spec that we are consuming.
 */
BasicSourceMapConsumer.prototype._version = 3;

/**
 * The list of original sources.
 */
Object.defineProperty(BasicSourceMapConsumer.prototype, 'sources', {
  get: function () {
    return this._absoluteSources.slice();
  }
});

/**
 * Provide the JIT with a nice shape / hidden class.
 */
function Mapping() {
  this.generatedLine = 0;
  this.generatedColumn = 0;
  this.source = null;
  this.originalLine = null;
  this.originalColumn = null;
  this.name = null;
}

/**
 * Parse the mappings in a string in to a data structure which we can easily
 * query (the ordered arrays in the `this.__generatedMappings` and
 * `this.__originalMappings` properties).
 */
BasicSourceMapConsumer.prototype._parseMappings = function SourceMapConsumer_parseMappings(aStr, aSourceRoot) {
  var generatedLine = 1;
  var previousGeneratedColumn = 0;
  var previousOriginalLine = 0;
  var previousOriginalColumn = 0;
  var previousSource = 0;
  var previousName = 0;
  var length = aStr.length;
  var index = 0;
  var cachedSegments = {};
  var temp = {};
  var originalMappings = [];
  var generatedMappings = [];
  var mapping, str, segment, end, value;

  while (index < length) {
    if (aStr.charAt(index) === ';') {
      generatedLine++;
      index++;
      previousGeneratedColumn = 0;
    } else if (aStr.charAt(index) === ',') {
      index++;
    } else {
      mapping = new Mapping();
      mapping.generatedLine = generatedLine;

      // Because each offset is encoded relative to the previous one,
      // many segments often have the same encoding. We can exploit this
      // fact by caching the parsed variable length fields of each segment,
      // allowing us to avoid a second parse if we encounter the same
      // segment again.
      for (end = index; end < length; end++) {
        if (this._charIsMappingSeparator(aStr, end)) {
          break;
        }
      }
      str = aStr.slice(index, end);

      segment = cachedSegments[str];
      if (segment) {
        index += str.length;
      } else {
        segment = [];
        while (index < end) {
          base64VLQ.decode(aStr, index, temp);
          value = temp.value;
          index = temp.rest;
          segment.push(value);
        }

        if (segment.length === 2) {
          throw new Error('Found a source, but no line and column');
        }

        if (segment.length === 3) {
          throw new Error('Found a source and line, but no column');
        }

        cachedSegments[str] = segment;
      }

      // Generated column.
      mapping.generatedColumn = previousGeneratedColumn + segment[0];
      previousGeneratedColumn = mapping.generatedColumn;

      if (segment.length > 1) {
        // Original source.
        mapping.source = previousSource + segment[1];
        previousSource += segment[1];

        // Original line.
        mapping.originalLine = previousOriginalLine + segment[2];
        previousOriginalLine = mapping.originalLine;
        // Lines are stored 0-based
        mapping.originalLine += 1;

        // Original column.
        mapping.originalColumn = previousOriginalColumn + segment[3];
        previousOriginalColumn = mapping.originalColumn;

        if (segment.length > 4) {
          // Original name.
          mapping.name = previousName + segment[4];
          previousName += segment[4];
        }
      }

      generatedMappings.push(mapping);
      if (typeof mapping.originalLine === 'number') {
        originalMappings.push(mapping);
      }
    }
  }

  quickSort(generatedMappings, util.compareByGeneratedPositionsDeflated);
  this.__generatedMappings = generatedMappings;

  quickSort(originalMappings, util.compareByOriginalPositions);
  this.__originalMappings = originalMappings;
};

/**
 * Find the mapping that best matches the hypothetical "needle" mapping that
 * we are searching for in the given "haystack" of mappings.
 */
BasicSourceMapConsumer.prototype._findMapping = function SourceMapConsumer_findMapping(aNeedle, aMappings, aLineName, aColumnName, aComparator, aBias) {
  // To return the position we are searching for, we must first find the
  // mapping for the given position and then return the opposite position it
  // points to. Because the mappings are sorted, we can use binary search to
  // find the best mapping.

  if (aNeedle[aLineName] <= 0) {
    throw new TypeError('Line must be greater than or equal to 1, got ' + aNeedle[aLineName]);
  }
  if (aNeedle[aColumnName] < 0) {
    throw new TypeError('Column must be greater than or equal to 0, got ' + aNeedle[aColumnName]);
  }

  return binarySearch.search(aNeedle, aMappings, aComparator, aBias);
};

/**
 * Compute the last column for each generated mapping. The last column is
 * inclusive.
 */
BasicSourceMapConsumer.prototype.computeColumnSpans = function SourceMapConsumer_computeColumnSpans() {
  for (var index = 0; index < this._generatedMappings.length; ++index) {
    var mapping = this._generatedMappings[index];

    // Mappings do not contain a field for the last generated columnt. We
    // can come up with an optimistic estimate, however, by assuming that
    // mappings are contiguous (i.e. given two consecutive mappings, the
    // first mapping ends where the second one starts).
    if (index + 1 < this._generatedMappings.length) {
      var nextMapping = this._generatedMappings[index + 1];

      if (mapping.generatedLine === nextMapping.generatedLine) {
        mapping.lastGeneratedColumn = nextMapping.generatedColumn - 1;
        continue;
      }
    }

    // The last mapping for each line spans the entire line.
    mapping.lastGeneratedColumn = Infinity;
  }
};

/**
 * Returns the original source, line, and column information for the generated
 * source's line and column positions provided. The only argument is an object
 * with the following properties:
 *
 *   - line: The line number in the generated source.  The line number
 *     is 1-based.
 *   - column: The column number in the generated source.  The column
 *     number is 0-based.
 *   - bias: Either 'SourceMapConsumer.GREATEST_LOWER_BOUND' or
 *     'SourceMapConsumer.LEAST_UPPER_BOUND'. Specifies whether to return the
 *     closest element that is smaller than or greater than the one we are
 *     searching for, respectively, if the exact element cannot be found.
 *     Defaults to 'SourceMapConsumer.GREATEST_LOWER_BOUND'.
 *
 * and an object is returned with the following properties:
 *
 *   - source: The original source file, or null.
 *   - line: The line number in the original source, or null.  The
 *     line number is 1-based.
 *   - column: The column number in the original source, or null.  The
 *     column number is 0-based.
 *   - name: The original identifier, or null.
 */
BasicSourceMapConsumer.prototype.originalPositionFor = function SourceMapConsumer_originalPositionFor(aArgs) {
  var needle = {
    generatedLine: util.getArg(aArgs, 'line'),
    generatedColumn: util.getArg(aArgs, 'column')
  };

  var index = this._findMapping(needle, this._generatedMappings, "generatedLine", "generatedColumn", util.compareByGeneratedPositionsDeflated, util.getArg(aArgs, 'bias', SourceMapConsumer.GREATEST_LOWER_BOUND));

  if (index >= 0) {
    var mapping = this._generatedMappings[index];

    if (mapping.generatedLine === needle.generatedLine) {
      var source = util.getArg(mapping, 'source', null);
      if (source !== null) {
        source = this._sources.at(source);
        source = util.computeSourceURL(this.sourceRoot, source, this._sourceMapURL);
      }
      var name = util.getArg(mapping, 'name', null);
      if (name !== null) {
        name = this._names.at(name);
      }
      return {
        source: source,
        line: util.getArg(mapping, 'originalLine', null),
        column: util.getArg(mapping, 'originalColumn', null),
        name: name
      };
    }
  }

  return {
    source: null,
    line: null,
    column: null,
    name: null
  };
};

/**
 * Return true if we have the source content for every source in the source
 * map, false otherwise.
 */
BasicSourceMapConsumer.prototype.hasContentsOfAllSources = function BasicSourceMapConsumer_hasContentsOfAllSources() {
  if (!this.sourcesContent) {
    return false;
  }
  return this.sourcesContent.length >= this._sources.size() && !this.sourcesContent.some(function (sc) {
    return sc == null;
  });
};

/**
 * Returns the original source content. The only argument is the url of the
 * original source file. Returns null if no original source content is
 * available.
 */
BasicSourceMapConsumer.prototype.sourceContentFor = function SourceMapConsumer_sourceContentFor(aSource, nullOnMissing) {
  if (!this.sourcesContent) {
    return null;
  }

  var index = this._findSourceIndex(aSource);
  if (index >= 0) {
    return this.sourcesContent[index];
  }

  var relativeSource = aSource;
  if (this.sourceRoot != null) {
    relativeSource = util.relative(this.sourceRoot, relativeSource);
  }

  var url;
  if (this.sourceRoot != null && (url = util.urlParse(this.sourceRoot))) {
    // XXX: file:// URIs and absolute paths lead to unexpected behavior for
    // many users. We can help them out when they expect file:// URIs to
    // behave like it would if they were running a local HTTP server. See
    // https://bugzilla.mozilla.org/show_bug.cgi?id=885597.
    var fileUriAbsPath = relativeSource.replace(/^file:\/\//, "");
    if (url.scheme == "file" && this._sources.has(fileUriAbsPath)) {
      return this.sourcesContent[this._sources.indexOf(fileUriAbsPath)];
    }

    if ((!url.path || url.path == "/") && this._sources.has("/" + relativeSource)) {
      return this.sourcesContent[this._sources.indexOf("/" + relativeSource)];
    }
  }

  // This function is used recursively from
  // IndexedSourceMapConsumer.prototype.sourceContentFor. In that case, we
  // don't want to throw if we can't find the source - we just want to
  // return null, so we provide a flag to exit gracefully.
  if (nullOnMissing) {
    return null;
  } else {
    throw new Error('"' + relativeSource + '" is not in the SourceMap.');
  }
};

/**
 * Returns the generated line and column information for the original source,
 * line, and column positions provided. The only argument is an object with
 * the following properties:
 *
 *   - source: The filename of the original source.
 *   - line: The line number in the original source.  The line number
 *     is 1-based.
 *   - column: The column number in the original source.  The column
 *     number is 0-based.
 *   - bias: Either 'SourceMapConsumer.GREATEST_LOWER_BOUND' or
 *     'SourceMapConsumer.LEAST_UPPER_BOUND'. Specifies whether to return the
 *     closest element that is smaller than or greater than the one we are
 *     searching for, respectively, if the exact element cannot be found.
 *     Defaults to 'SourceMapConsumer.GREATEST_LOWER_BOUND'.
 *
 * and an object is returned with the following properties:
 *
 *   - line: The line number in the generated source, or null.  The
 *     line number is 1-based.
 *   - column: The column number in the generated source, or null.
 *     The column number is 0-based.
 */
BasicSourceMapConsumer.prototype.generatedPositionFor = function SourceMapConsumer_generatedPositionFor(aArgs) {
  var source = util.getArg(aArgs, 'source');
  source = this._findSourceIndex(source);
  if (source < 0) {
    return {
      line: null,
      column: null,
      lastColumn: null
    };
  }

  var needle = {
    source: source,
    originalLine: util.getArg(aArgs, 'line'),
    originalColumn: util.getArg(aArgs, 'column')
  };

  var index = this._findMapping(needle, this._originalMappings, "originalLine", "originalColumn", util.compareByOriginalPositions, util.getArg(aArgs, 'bias', SourceMapConsumer.GREATEST_LOWER_BOUND));

  if (index >= 0) {
    var mapping = this._originalMappings[index];

    if (mapping.source === needle.source) {
      return {
        line: util.getArg(mapping, 'generatedLine', null),
        column: util.getArg(mapping, 'generatedColumn', null),
        lastColumn: util.getArg(mapping, 'lastGeneratedColumn', null)
      };
    }
  }

  return {
    line: null,
    column: null,
    lastColumn: null
  };
};

exports.BasicSourceMapConsumer = BasicSourceMapConsumer;

/**
 * An IndexedSourceMapConsumer instance represents a parsed source map which
 * we can query for information. It differs from BasicSourceMapConsumer in
 * that it takes "indexed" source maps (i.e. ones with a "sections" field) as
 * input.
 *
 * The first parameter is a raw source map (either as a JSON string, or already
 * parsed to an object). According to the spec for indexed source maps, they
 * have the following attributes:
 *
 *   - version: Which version of the source map spec this map is following.
 *   - file: Optional. The generated file this source map is associated with.
 *   - sections: A list of section definitions.
 *
 * Each value under the "sections" field has two fields:
 *   - offset: The offset into the original specified at which this section
 *       begins to apply, defined as an object with a "line" and "column"
 *       field.
 *   - map: A source map definition. This source map could also be indexed,
 *       but doesn't have to be.
 *
 * Instead of the "map" field, it's also possible to have a "url" field
 * specifying a URL to retrieve a source map from, but that's currently
 * unsupported.
 *
 * Here's an example source map, taken from the source map spec[0], but
 * modified to omit a section which uses the "url" field.
 *
 *  {
 *    version : 3,
 *    file: "app.js",
 *    sections: [{
 *      offset: {line:100, column:10},
 *      map: {
 *        version : 3,
 *        file: "section.js",
 *        sources: ["foo.js", "bar.js"],
 *        names: ["src", "maps", "are", "fun"],
 *        mappings: "AAAA,E;;ABCDE;"
 *      }
 *    }],
 *  }
 *
 * The second parameter, if given, is a string whose value is the URL
 * at which the source map was found.  This URL is used to compute the
 * sources array.
 *
 * [0]: https://docs.google.com/document/d/1U1RGAehQwRypUTovF1KRlpiOFze0b-_2gc6fAH0KY0k/edit#heading=h.535es3xeprgt
 */
function IndexedSourceMapConsumer(aSourceMap, aSourceMapURL) {
  var sourceMap = aSourceMap;
  if (typeof aSourceMap === 'string') {
    sourceMap = util.parseSourceMapInput(aSourceMap);
  }

  var version = util.getArg(sourceMap, 'version');
  var sections = util.getArg(sourceMap, 'sections');

  if (version != this._version) {
    throw new Error('Unsupported version: ' + version);
  }

  this._sources = new ArraySet();
  this._names = new ArraySet();

  var lastOffset = {
    line: -1,
    column: 0
  };
  this._sections = sections.map(function (s) {
    if (s.url) {
      // The url field will require support for asynchronicity.
      // See https://github.com/mozilla/source-map/issues/16
      throw new Error('Support for url field in sections not implemented.');
    }
    var offset = util.getArg(s, 'offset');
    var offsetLine = util.getArg(offset, 'line');
    var offsetColumn = util.getArg(offset, 'column');

    if (offsetLine < lastOffset.line || offsetLine === lastOffset.line && offsetColumn < lastOffset.column) {
      throw new Error('Section offsets must be ordered and non-overlapping.');
    }
    lastOffset = offset;

    return {
      generatedOffset: {
        // The offset fields are 0-based, but we use 1-based indices when
        // encoding/decoding from VLQ.
        generatedLine: offsetLine + 1,
        generatedColumn: offsetColumn + 1
      },
      consumer: new SourceMapConsumer(util.getArg(s, 'map'), aSourceMapURL)
    };
  });
}

IndexedSourceMapConsumer.prototype = Object.create(SourceMapConsumer.prototype);
IndexedSourceMapConsumer.prototype.constructor = SourceMapConsumer;

/**
 * The version of the source mapping spec that we are consuming.
 */
IndexedSourceMapConsumer.prototype._version = 3;

/**
 * The list of original sources.
 */
Object.defineProperty(IndexedSourceMapConsumer.prototype, 'sources', {
  get: function () {
    var sources = [];
    for (var i = 0; i < this._sections.length; i++) {
      for (var j = 0; j < this._sections[i].consumer.sources.length; j++) {
        sources.push(this._sections[i].consumer.sources[j]);
      }
    }
    return sources;
  }
});

/**
 * Returns the original source, line, and column information for the generated
 * source's line and column positions provided. The only argument is an object
 * with the following properties:
 *
 *   - line: The line number in the generated source.  The line number
 *     is 1-based.
 *   - column: The column number in the generated source.  The column
 *     number is 0-based.
 *
 * and an object is returned with the following properties:
 *
 *   - source: The original source file, or null.
 *   - line: The line number in the original source, or null.  The
 *     line number is 1-based.
 *   - column: The column number in the original source, or null.  The
 *     column number is 0-based.
 *   - name: The original identifier, or null.
 */
IndexedSourceMapConsumer.prototype.originalPositionFor = function IndexedSourceMapConsumer_originalPositionFor(aArgs) {
  var needle = {
    generatedLine: util.getArg(aArgs, 'line'),
    generatedColumn: util.getArg(aArgs, 'column')
  };

  // Find the section containing the generated position we're trying to map
  // to an original position.
  var sectionIndex = binarySearch.search(needle, this._sections, function (needle, section) {
    var cmp = needle.generatedLine - section.generatedOffset.generatedLine;
    if (cmp) {
      return cmp;
    }

    return needle.generatedColumn - section.generatedOffset.generatedColumn;
  });
  var section = this._sections[sectionIndex];

  if (!section) {
    return {
      source: null,
      line: null,
      column: null,
      name: null
    };
  }

  return section.consumer.originalPositionFor({
    line: needle.generatedLine - (section.generatedOffset.generatedLine - 1),
    column: needle.generatedColumn - (section.generatedOffset.generatedLine === needle.generatedLine ? section.generatedOffset.generatedColumn - 1 : 0),
    bias: aArgs.bias
  });
};

/**
 * Return true if we have the source content for every source in the source
 * map, false otherwise.
 */
IndexedSourceMapConsumer.prototype.hasContentsOfAllSources = function IndexedSourceMapConsumer_hasContentsOfAllSources() {
  return this._sections.every(function (s) {
    return s.consumer.hasContentsOfAllSources();
  });
};

/**
 * Returns the original source content. The only argument is the url of the
 * original source file. Returns null if no original source content is
 * available.
 */
IndexedSourceMapConsumer.prototype.sourceContentFor = function IndexedSourceMapConsumer_sourceContentFor(aSource, nullOnMissing) {
  for (var i = 0; i < this._sections.length; i++) {
    var section = this._sections[i];

    var content = section.consumer.sourceContentFor(aSource, true);
    if (content) {
      return content;
    }
  }
  if (nullOnMissing) {
    return null;
  } else {
    throw new Error('"' + aSource + '" is not in the SourceMap.');
  }
};

/**
 * Returns the generated line and column information for the original source,
 * line, and column positions provided. The only argument is an object with
 * the following properties:
 *
 *   - source: The filename of the original source.
 *   - line: The line number in the original source.  The line number
 *     is 1-based.
 *   - column: The column number in the original source.  The column
 *     number is 0-based.
 *
 * and an object is returned with the following properties:
 *
 *   - line: The line number in the generated source, or null.  The
 *     line number is 1-based. 
 *   - column: The column number in the generated source, or null.
 *     The column number is 0-based.
 */
IndexedSourceMapConsumer.prototype.generatedPositionFor = function IndexedSourceMapConsumer_generatedPositionFor(aArgs) {
  for (var i = 0; i < this._sections.length; i++) {
    var section = this._sections[i];

    // Only consider this section if the requested source is in the list of
    // sources of the consumer.
    if (section.consumer._findSourceIndex(util.getArg(aArgs, 'source')) === -1) {
      continue;
    }
    var generatedPosition = section.consumer.generatedPositionFor(aArgs);
    if (generatedPosition) {
      var ret = {
        line: generatedPosition.line + (section.generatedOffset.generatedLine - 1),
        column: generatedPosition.column + (section.generatedOffset.generatedLine === generatedPosition.line ? section.generatedOffset.generatedColumn - 1 : 0)
      };
      return ret;
    }
  }

  return {
    line: null,
    column: null
  };
};

/**
 * Parse the mappings in a string in to a data structure which we can easily
 * query (the ordered arrays in the `this.__generatedMappings` and
 * `this.__originalMappings` properties).
 */
IndexedSourceMapConsumer.prototype._parseMappings = function IndexedSourceMapConsumer_parseMappings(aStr, aSourceRoot) {
  this.__generatedMappings = [];
  this.__originalMappings = [];
  for (var i = 0; i < this._sections.length; i++) {
    var section = this._sections[i];
    var sectionMappings = section.consumer._generatedMappings;
    for (var j = 0; j < sectionMappings.length; j++) {
      var mapping = sectionMappings[j];

      var source = section.consumer._sources.at(mapping.source);
      source = util.computeSourceURL(section.consumer.sourceRoot, source, this._sourceMapURL);
      this._sources.add(source);
      source = this._sources.indexOf(source);

      var name = null;
      if (mapping.name) {
        name = section.consumer._names.at(mapping.name);
        this._names.add(name);
        name = this._names.indexOf(name);
      }

      // The mappings coming from the consumer for the section have
      // generated positions relative to the start of the section, so we
      // need to offset them to be relative to the start of the concatenated
      // generated file.
      var adjustedMapping = {
        source: source,
        generatedLine: mapping.generatedLine + (section.generatedOffset.generatedLine - 1),
        generatedColumn: mapping.generatedColumn + (section.generatedOffset.generatedLine === mapping.generatedLine ? section.generatedOffset.generatedColumn - 1 : 0),
        originalLine: mapping.originalLine,
        originalColumn: mapping.originalColumn,
        name: name
      };

      this.__generatedMappings.push(adjustedMapping);
      if (typeof adjustedMapping.originalLine === 'number') {
        this.__originalMappings.push(adjustedMapping);
      }
    }
  }

  quickSort(this.__generatedMappings, util.compareByGeneratedPositionsDeflated);
  quickSort(this.__originalMappings, util.compareByOriginalPositions);
};

exports.IndexedSourceMapConsumer = IndexedSourceMapConsumer;

/***/ }),
/* 165 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/* -*- Mode: js; js-indent-level: 2; -*- */
/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */

exports.GREATEST_LOWER_BOUND = 1;
exports.LEAST_UPPER_BOUND = 2;

/**
 * Recursive implementation of binary search.
 *
 * @param aLow Indices here and lower do not contain the needle.
 * @param aHigh Indices here and higher do not contain the needle.
 * @param aNeedle The element being searched for.
 * @param aHaystack The non-empty array being searched.
 * @param aCompare Function which takes two elements and returns -1, 0, or 1.
 * @param aBias Either 'binarySearch.GREATEST_LOWER_BOUND' or
 *     'binarySearch.LEAST_UPPER_BOUND'. Specifies whether to return the
 *     closest element that is smaller than or greater than the one we are
 *     searching for, respectively, if the exact element cannot be found.
 */
function recursiveSearch(aLow, aHigh, aNeedle, aHaystack, aCompare, aBias) {
  // This function terminates when one of the following is true:
  //
  //   1. We find the exact element we are looking for.
  //
  //   2. We did not find the exact element, but we can return the index of
  //      the next-closest element.
  //
  //   3. We did not find the exact element, and there is no next-closest
  //      element than the one we are searching for, so we return -1.
  var mid = Math.floor((aHigh - aLow) / 2) + aLow;
  var cmp = aCompare(aNeedle, aHaystack[mid], true);
  if (cmp === 0) {
    // Found the element we are looking for.
    return mid;
  } else if (cmp > 0) {
    // Our needle is greater than aHaystack[mid].
    if (aHigh - mid > 1) {
      // The element is in the upper half.
      return recursiveSearch(mid, aHigh, aNeedle, aHaystack, aCompare, aBias);
    }

    // The exact needle element was not found in this haystack. Determine if
    // we are in termination case (3) or (2) and return the appropriate thing.
    if (aBias == exports.LEAST_UPPER_BOUND) {
      return aHigh < aHaystack.length ? aHigh : -1;
    } else {
      return mid;
    }
  } else {
    // Our needle is less than aHaystack[mid].
    if (mid - aLow > 1) {
      // The element is in the lower half.
      return recursiveSearch(aLow, mid, aNeedle, aHaystack, aCompare, aBias);
    }

    // we are in termination case (3) or (2) and return the appropriate thing.
    if (aBias == exports.LEAST_UPPER_BOUND) {
      return mid;
    } else {
      return aLow < 0 ? -1 : aLow;
    }
  }
}

/**
 * This is an implementation of binary search which will always try and return
 * the index of the closest element if there is no exact hit. This is because
 * mappings between original and generated line/col pairs are single points,
 * and there is an implicit region between each of them, so a miss just means
 * that you aren't on the very start of a region.
 *
 * @param aNeedle The element you are looking for.
 * @param aHaystack The array that is being searched.
 * @param aCompare A function which takes the needle and an element in the
 *     array and returns -1, 0, or 1 depending on whether the needle is less
 *     than, equal to, or greater than the element, respectively.
 * @param aBias Either 'binarySearch.GREATEST_LOWER_BOUND' or
 *     'binarySearch.LEAST_UPPER_BOUND'. Specifies whether to return the
 *     closest element that is smaller than or greater than the one we are
 *     searching for, respectively, if the exact element cannot be found.
 *     Defaults to 'binarySearch.GREATEST_LOWER_BOUND'.
 */
exports.search = function search(aNeedle, aHaystack, aCompare, aBias) {
  if (aHaystack.length === 0) {
    return -1;
  }

  var index = recursiveSearch(-1, aHaystack.length, aNeedle, aHaystack, aCompare, aBias || exports.GREATEST_LOWER_BOUND);
  if (index < 0) {
    return -1;
  }

  // We have found either the exact element, or the next-closest element than
  // the one we are searching for. However, there may be more than one such
  // element. Make sure we always return the smallest of these.
  while (index - 1 >= 0) {
    if (aCompare(aHaystack[index], aHaystack[index - 1], true) !== 0) {
      break;
    }
    --index;
  }

  return index;
};

/***/ }),
/* 166 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/* -*- Mode: js; js-indent-level: 2; -*- */
/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */

// It turns out that some (most?) JavaScript engines don't self-host
// `Array.prototype.sort`. This makes sense because C++ will likely remain
// faster than JS when doing raw CPU-intensive sorting. However, when using a
// custom comparator function, calling back and forth between the VM's C++ and
// JIT'd JS is rather slow *and* loses JIT type information, resulting in
// worse generated code for the comparator function than would be optimal. In
// fact, when sorting with a comparator, these costs outweigh the benefits of
// sorting in C++. By using our own JS-implemented Quick Sort (below), we get
// a ~3500ms mean speed-up in `bench/bench.html`.

/**
 * Swap the elements indexed by `x` and `y` in the array `ary`.
 *
 * @param {Array} ary
 *        The array.
 * @param {Number} x
 *        The index of the first item.
 * @param {Number} y
 *        The index of the second item.
 */
function swap(ary, x, y) {
  var temp = ary[x];
  ary[x] = ary[y];
  ary[y] = temp;
}

/**
 * Returns a random integer within the range `low .. high` inclusive.
 *
 * @param {Number} low
 *        The lower bound on the range.
 * @param {Number} high
 *        The upper bound on the range.
 */
function randomIntInRange(low, high) {
  return Math.round(low + Math.random() * (high - low));
}

/**
 * The Quick Sort algorithm.
 *
 * @param {Array} ary
 *        An array to sort.
 * @param {function} comparator
 *        Function to use to compare two items.
 * @param {Number} p
 *        Start index of the array
 * @param {Number} r
 *        End index of the array
 */
function doQuickSort(ary, comparator, p, r) {
  // If our lower bound is less than our upper bound, we (1) partition the
  // array into two pieces and (2) recurse on each half. If it is not, this is
  // the empty array and our base case.

  if (p < r) {
    // (1) Partitioning.
    //
    // The partitioning chooses a pivot between `p` and `r` and moves all
    // elements that are less than or equal to the pivot to the before it, and
    // all the elements that are greater than it after it. The effect is that
    // once partition is done, the pivot is in the exact place it will be when
    // the array is put in sorted order, and it will not need to be moved
    // again. This runs in O(n) time.

    // Always choose a random pivot so that an input array which is reverse
    // sorted does not cause O(n^2) running time.
    var pivotIndex = randomIntInRange(p, r);
    var i = p - 1;

    swap(ary, pivotIndex, r);
    var pivot = ary[r];

    // Immediately after `j` is incremented in this loop, the following hold
    // true:
    //
    //   * Every element in `ary[p .. i]` is less than or equal to the pivot.
    //
    //   * Every element in `ary[i+1 .. j-1]` is greater than the pivot.
    for (var j = p; j < r; j++) {
      if (comparator(ary[j], pivot) <= 0) {
        i += 1;
        swap(ary, i, j);
      }
    }

    swap(ary, i + 1, j);
    var q = i + 1;

    // (2) Recurse on each half.

    doQuickSort(ary, comparator, p, q - 1);
    doQuickSort(ary, comparator, q + 1, r);
  }
}

/**
 * Sort the given array in-place with the given comparator function.
 *
 * @param {Array} ary
 *        An array to sort.
 * @param {function} comparator
 *        Function to use to compare two items.
 */
exports.quickSort = function (ary, comparator) {
  doQuickSort(ary, comparator, 0, ary.length - 1);
};

/***/ }),
/* 167 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/* -*- Mode: js; js-indent-level: 2; -*- */
/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */

var SourceMapGenerator = __webpack_require__(56).SourceMapGenerator;
var util = __webpack_require__(23);

// Matches a Windows-style `\r\n` newline or a `\n` newline used by all other
// operating systems these days (capturing the result).
var REGEX_NEWLINE = /(\r?\n)/;

// Newline character code for charCodeAt() comparisons
var NEWLINE_CODE = 10;

// Private symbol for identifying `SourceNode`s when multiple versions of
// the source-map library are loaded. This MUST NOT CHANGE across
// versions!
var isSourceNode = "$$$isSourceNode$$$";

/**
 * SourceNodes provide a way to abstract over interpolating/concatenating
 * snippets of generated JavaScript source code while maintaining the line and
 * column information associated with the original source code.
 *
 * @param aLine The original line number.
 * @param aColumn The original column number.
 * @param aSource The original source's filename.
 * @param aChunks Optional. An array of strings which are snippets of
 *        generated JS, or other SourceNodes.
 * @param aName The original identifier.
 */
function SourceNode(aLine, aColumn, aSource, aChunks, aName) {
  this.children = [];
  this.sourceContents = {};
  this.line = aLine == null ? null : aLine;
  this.column = aColumn == null ? null : aColumn;
  this.source = aSource == null ? null : aSource;
  this.name = aName == null ? null : aName;
  this[isSourceNode] = true;
  if (aChunks != null) this.add(aChunks);
}

/**
 * Creates a SourceNode from generated code and a SourceMapConsumer.
 *
 * @param aGeneratedCode The generated code
 * @param aSourceMapConsumer The SourceMap for the generated code
 * @param aRelativePath Optional. The path that relative sources in the
 *        SourceMapConsumer should be relative to.
 */
SourceNode.fromStringWithSourceMap = function SourceNode_fromStringWithSourceMap(aGeneratedCode, aSourceMapConsumer, aRelativePath) {
  // The SourceNode we want to fill with the generated code
  // and the SourceMap
  var node = new SourceNode();

  // All even indices of this array are one line of the generated code,
  // while all odd indices are the newlines between two adjacent lines
  // (since `REGEX_NEWLINE` captures its match).
  // Processed fragments are accessed by calling `shiftNextLine`.
  var remainingLines = aGeneratedCode.split(REGEX_NEWLINE);
  var remainingLinesIndex = 0;
  var shiftNextLine = function () {
    var lineContents = getNextLine();
    // The last line of a file might not have a newline.
    var newLine = getNextLine() || "";
    return lineContents + newLine;

    function getNextLine() {
      return remainingLinesIndex < remainingLines.length ? remainingLines[remainingLinesIndex++] : undefined;
    }
  };

  // We need to remember the position of "remainingLines"
  var lastGeneratedLine = 1,
      lastGeneratedColumn = 0;

  // The generate SourceNodes we need a code range.
  // To extract it current and last mapping is used.
  // Here we store the last mapping.
  var lastMapping = null;

  aSourceMapConsumer.eachMapping(function (mapping) {
    if (lastMapping !== null) {
      // We add the code from "lastMapping" to "mapping":
      // First check if there is a new line in between.
      if (lastGeneratedLine < mapping.generatedLine) {
        // Associate first line with "lastMapping"
        addMappingWithCode(lastMapping, shiftNextLine());
        lastGeneratedLine++;
        lastGeneratedColumn = 0;
        // The remaining code is added without mapping
      } else {
        // There is no new line in between.
        // Associate the code between "lastGeneratedColumn" and
        // "mapping.generatedColumn" with "lastMapping"
        var nextLine = remainingLines[remainingLinesIndex] || '';
        var code = nextLine.substr(0, mapping.generatedColumn - lastGeneratedColumn);
        remainingLines[remainingLinesIndex] = nextLine.substr(mapping.generatedColumn - lastGeneratedColumn);
        lastGeneratedColumn = mapping.generatedColumn;
        addMappingWithCode(lastMapping, code);
        // No more remaining code, continue
        lastMapping = mapping;
        return;
      }
    }
    // We add the generated code until the first mapping
    // to the SourceNode without any mapping.
    // Each line is added as separate string.
    while (lastGeneratedLine < mapping.generatedLine) {
      node.add(shiftNextLine());
      lastGeneratedLine++;
    }
    if (lastGeneratedColumn < mapping.generatedColumn) {
      var nextLine = remainingLines[remainingLinesIndex] || '';
      node.add(nextLine.substr(0, mapping.generatedColumn));
      remainingLines[remainingLinesIndex] = nextLine.substr(mapping.generatedColumn);
      lastGeneratedColumn = mapping.generatedColumn;
    }
    lastMapping = mapping;
  }, this);
  // We have processed all mappings.
  if (remainingLinesIndex < remainingLines.length) {
    if (lastMapping) {
      // Associate the remaining code in the current line with "lastMapping"
      addMappingWithCode(lastMapping, shiftNextLine());
    }
    // and add the remaining lines without any mapping
    node.add(remainingLines.splice(remainingLinesIndex).join(""));
  }

  // Copy sourcesContent into SourceNode
  aSourceMapConsumer.sources.forEach(function (sourceFile) {
    var content = aSourceMapConsumer.sourceContentFor(sourceFile);
    if (content != null) {
      if (aRelativePath != null) {
        sourceFile = util.join(aRelativePath, sourceFile);
      }
      node.setSourceContent(sourceFile, content);
    }
  });

  return node;

  function addMappingWithCode(mapping, code) {
    if (mapping === null || mapping.source === undefined) {
      node.add(code);
    } else {
      var source = aRelativePath ? util.join(aRelativePath, mapping.source) : mapping.source;
      node.add(new SourceNode(mapping.originalLine, mapping.originalColumn, source, code, mapping.name));
    }
  }
};

/**
 * Add a chunk of generated JS to this source node.
 *
 * @param aChunk A string snippet of generated JS code, another instance of
 *        SourceNode, or an array where each member is one of those things.
 */
SourceNode.prototype.add = function SourceNode_add(aChunk) {
  if (Array.isArray(aChunk)) {
    aChunk.forEach(function (chunk) {
      this.add(chunk);
    }, this);
  } else if (aChunk[isSourceNode] || typeof aChunk === "string") {
    if (aChunk) {
      this.children.push(aChunk);
    }
  } else {
    throw new TypeError("Expected a SourceNode, string, or an array of SourceNodes and strings. Got " + aChunk);
  }
  return this;
};

/**
 * Add a chunk of generated JS to the beginning of this source node.
 *
 * @param aChunk A string snippet of generated JS code, another instance of
 *        SourceNode, or an array where each member is one of those things.
 */
SourceNode.prototype.prepend = function SourceNode_prepend(aChunk) {
  if (Array.isArray(aChunk)) {
    for (var i = aChunk.length - 1; i >= 0; i--) {
      this.prepend(aChunk[i]);
    }
  } else if (aChunk[isSourceNode] || typeof aChunk === "string") {
    this.children.unshift(aChunk);
  } else {
    throw new TypeError("Expected a SourceNode, string, or an array of SourceNodes and strings. Got " + aChunk);
  }
  return this;
};

/**
 * Walk over the tree of JS snippets in this node and its children. The
 * walking function is called once for each snippet of JS and is passed that
 * snippet and the its original associated source's line/column location.
 *
 * @param aFn The traversal function.
 */
SourceNode.prototype.walk = function SourceNode_walk(aFn) {
  var chunk;
  for (var i = 0, len = this.children.length; i < len; i++) {
    chunk = this.children[i];
    if (chunk[isSourceNode]) {
      chunk.walk(aFn);
    } else {
      if (chunk !== '') {
        aFn(chunk, { source: this.source,
          line: this.line,
          column: this.column,
          name: this.name });
      }
    }
  }
};

/**
 * Like `String.prototype.join` except for SourceNodes. Inserts `aStr` between
 * each of `this.children`.
 *
 * @param aSep The separator.
 */
SourceNode.prototype.join = function SourceNode_join(aSep) {
  var newChildren;
  var i;
  var len = this.children.length;
  if (len > 0) {
    newChildren = [];
    for (i = 0; i < len - 1; i++) {
      newChildren.push(this.children[i]);
      newChildren.push(aSep);
    }
    newChildren.push(this.children[i]);
    this.children = newChildren;
  }
  return this;
};

/**
 * Call String.prototype.replace on the very right-most source snippet. Useful
 * for trimming whitespace from the end of a source node, etc.
 *
 * @param aPattern The pattern to replace.
 * @param aReplacement The thing to replace the pattern with.
 */
SourceNode.prototype.replaceRight = function SourceNode_replaceRight(aPattern, aReplacement) {
  var lastChild = this.children[this.children.length - 1];
  if (lastChild[isSourceNode]) {
    lastChild.replaceRight(aPattern, aReplacement);
  } else if (typeof lastChild === 'string') {
    this.children[this.children.length - 1] = lastChild.replace(aPattern, aReplacement);
  } else {
    this.children.push(''.replace(aPattern, aReplacement));
  }
  return this;
};

/**
 * Set the source content for a source file. This will be added to the SourceMapGenerator
 * in the sourcesContent field.
 *
 * @param aSourceFile The filename of the source file
 * @param aSourceContent The content of the source file
 */
SourceNode.prototype.setSourceContent = function SourceNode_setSourceContent(aSourceFile, aSourceContent) {
  this.sourceContents[util.toSetString(aSourceFile)] = aSourceContent;
};

/**
 * Walk over the tree of SourceNodes. The walking function is called for each
 * source file content and is passed the filename and source content.
 *
 * @param aFn The traversal function.
 */
SourceNode.prototype.walkSourceContents = function SourceNode_walkSourceContents(aFn) {
  for (var i = 0, len = this.children.length; i < len; i++) {
    if (this.children[i][isSourceNode]) {
      this.children[i].walkSourceContents(aFn);
    }
  }

  var sources = Object.keys(this.sourceContents);
  for (var i = 0, len = sources.length; i < len; i++) {
    aFn(util.fromSetString(sources[i]), this.sourceContents[sources[i]]);
  }
};

/**
 * Return the string representation of this source node. Walks over the tree
 * and concatenates all the various snippets together to one string.
 */
SourceNode.prototype.toString = function SourceNode_toString() {
  var str = "";
  this.walk(function (chunk) {
    str += chunk;
  });
  return str;
};

/**
 * Returns the string representation of this source node along with a source
 * map.
 */
SourceNode.prototype.toStringWithSourceMap = function SourceNode_toStringWithSourceMap(aArgs) {
  var generated = {
    code: "",
    line: 1,
    column: 0
  };
  var map = new SourceMapGenerator(aArgs);
  var sourceMappingActive = false;
  var lastOriginalSource = null;
  var lastOriginalLine = null;
  var lastOriginalColumn = null;
  var lastOriginalName = null;
  this.walk(function (chunk, original) {
    generated.code += chunk;
    if (original.source !== null && original.line !== null && original.column !== null) {
      if (lastOriginalSource !== original.source || lastOriginalLine !== original.line || lastOriginalColumn !== original.column || lastOriginalName !== original.name) {
        map.addMapping({
          source: original.source,
          original: {
            line: original.line,
            column: original.column
          },
          generated: {
            line: generated.line,
            column: generated.column
          },
          name: original.name
        });
      }
      lastOriginalSource = original.source;
      lastOriginalLine = original.line;
      lastOriginalColumn = original.column;
      lastOriginalName = original.name;
      sourceMappingActive = true;
    } else if (sourceMappingActive) {
      map.addMapping({
        generated: {
          line: generated.line,
          column: generated.column
        }
      });
      lastOriginalSource = null;
      sourceMappingActive = false;
    }
    for (var idx = 0, length = chunk.length; idx < length; idx++) {
      if (chunk.charCodeAt(idx) === NEWLINE_CODE) {
        generated.line++;
        generated.column = 0;
        // Mappings end at eol
        if (idx + 1 === length) {
          lastOriginalSource = null;
          sourceMappingActive = false;
        } else if (sourceMappingActive) {
          map.addMapping({
            source: original.source,
            original: {
              line: original.line,
              column: original.column
            },
            generated: {
              line: generated.line,
              column: generated.column
            },
            name: original.name
          });
        }
      } else {
        generated.column++;
      }
    }
  });
  this.walkSourceContents(function (sourceFile, sourceContent) {
    map.setSourceContent(sourceFile, sourceContent);
  });

  return { code: generated.code, map: map };
};

exports.SourceNode = SourceNode;

/***/ }),
/* 168 */
/***/ (function(module, exports) {

module.exports = require("module");

/***/ }),
/* 169 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.ElectronHttpExecutor = undefined;

var _bluebirdLst;

function _load_bluebirdLst() {
    return _bluebirdLst = __webpack_require__(2);
}

var _builderUtilRuntime;

function _load_builderUtilRuntime() {
    return _builderUtilRuntime = __webpack_require__(3);
}

var _electron;

function _load_electron() {
    return _electron = __webpack_require__(10);
}

var _fsExtraP;

function _load_fsExtraP() {
    return _fsExtraP = __webpack_require__(9);
}

var _path = _interopRequireWildcard(__webpack_require__(0));

function _interopRequireWildcard(obj) {
    if (obj && obj.__esModule) {
        return obj;
    } else {
        var newObj = {};if (obj != null) {
            for (var key in obj) {
                if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key];
            }
        }newObj.default = obj;return newObj;
    }
}

class ElectronHttpExecutor extends (_builderUtilRuntime || _load_builderUtilRuntime()).HttpExecutor {
    constructor(proxyLoginCallback) {
        super();
        this.proxyLoginCallback = proxyLoginCallback;
    }
    download(url, destination, options) {
        var _this = this;

        return (0, (_bluebirdLst || _load_bluebirdLst()).coroutine)(function* () {
            if (options == null || !options.skipDirCreation) {
                yield (0, (_fsExtraP || _load_fsExtraP()).ensureDir)(_path.dirname(destination));
            }
            return yield options.cancellationToken.createPromise(function (resolve, reject, onCancel) {
                _this.doDownload(Object.assign({}, (0, (_builderUtilRuntime || _load_builderUtilRuntime()).configureRequestOptionsFromUrl)(url, {
                    headers: options.headers || undefined
                }), { redirect: "manual" }), destination, 0, options, function (error) {
                    if (error == null) {
                        resolve(destination);
                    } else {
                        reject(error);
                    }
                }, onCancel);
            });
        })();
    }
    doRequest(options, callback) {
        const request = (_electron || _load_electron()).net.request(options);
        request.on("response", callback);
        this.addProxyLoginHandler(request);
        return request;
    }
    addProxyLoginHandler(request) {
        if (this.proxyLoginCallback != null) {
            request.on("login", this.proxyLoginCallback);
        }
    }
    addRedirectHandlers(request, options, reject, redirectCount, handler) {
        request.on("redirect", (statusCode, method, redirectUrl) => {
            if (redirectCount > 10) {
                reject(new Error("Too many redirects (> 10)"));
                return;
            }
            handler((_builderUtilRuntime || _load_builderUtilRuntime()).HttpExecutor.prepareRedirectUrlOptions(redirectUrl, options));
        });
    }
}
exports.ElectronHttpExecutor = ElectronHttpExecutor; //# sourceMappingURL=electronHttpExecutor.js.map

/***/ }),
/* 170 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.createClient = createClient;

var _builderUtilRuntime;

function _load_builderUtilRuntime() {
    return _builderUtilRuntime = __webpack_require__(3);
}

var _BintrayProvider;

function _load_BintrayProvider() {
    return _BintrayProvider = __webpack_require__(171);
}

var _GenericProvider;

function _load_GenericProvider() {
    return _GenericProvider = __webpack_require__(59);
}

var _GitHubProvider;

function _load_GitHubProvider() {
    return _GitHubProvider = __webpack_require__(60);
}

var _PrivateGitHubProvider;

function _load_PrivateGitHubProvider() {
    return _PrivateGitHubProvider = __webpack_require__(173);
}

function createClient(data, updater) {
    if (typeof data === "string") {
        throw (0, (_builderUtilRuntime || _load_builderUtilRuntime()).newError)("Please pass PublishConfiguration object", "ERR_UPDATER_INVALID_PROVIDER_CONFIGURATION");
    }
    const httpExecutor = updater.httpExecutor;
    const provider = data.provider;
    switch (provider) {
        case "github":
            const githubOptions = data;
            const token = (githubOptions.private ? process.env.GH_TOKEN : null) || githubOptions.token;
            if (token == null) {
                return new (_GitHubProvider || _load_GitHubProvider()).GitHubProvider(githubOptions, updater, httpExecutor);
            } else {
                return new (_PrivateGitHubProvider || _load_PrivateGitHubProvider()).PrivateGitHubProvider(githubOptions, token, httpExecutor);
            }
        case "s3":
        case "spaces":
            return new (_GenericProvider || _load_GenericProvider()).GenericProvider({
                provider: "generic",
                url: (0, (_builderUtilRuntime || _load_builderUtilRuntime()).getS3LikeProviderBaseUrl)(data),
                channel: data.channel || null
            }, updater, provider === "spaces" /* https://github.com/minio/minio/issues/5285#issuecomment-350428955 */);
        case "generic":
            return new (_GenericProvider || _load_GenericProvider()).GenericProvider(data, updater, true);
        case "bintray":
            return new (_BintrayProvider || _load_BintrayProvider()).BintrayProvider(data, httpExecutor);
        default:
            throw (0, (_builderUtilRuntime || _load_builderUtilRuntime()).newError)(`Unsupported provider: ${provider}`, "ERR_UPDATER_UNSUPPORTED_PROVIDER");
    }
}
//# sourceMappingURL=providerFactory.js.map

/***/ }),
/* 171 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.BintrayProvider = undefined;

var _bluebirdLst;

function _load_bluebirdLst() {
    return _bluebirdLst = __webpack_require__(2);
}

var _builderUtilRuntime;

function _load_builderUtilRuntime() {
    return _builderUtilRuntime = __webpack_require__(3);
}

var _bintray;

function _load_bintray() {
    return _bintray = __webpack_require__(172);
}

var _url;

function _load_url() {
    return _url = __webpack_require__(20);
}

var _main;

function _load_main() {
    return _main = __webpack_require__(8);
}

var _Provider;

function _load_Provider() {
    return _Provider = __webpack_require__(14);
}

class BintrayProvider extends (_main || _load_main()).Provider {
    constructor(configuration, httpExecutor) {
        super(httpExecutor);
        this.client = new (_bintray || _load_bintray()).BintrayClient(configuration, httpExecutor, new (_builderUtilRuntime || _load_builderUtilRuntime()).CancellationToken());
        this.baseUrl = (0, (_main || _load_main()).newBaseUrl)(`https://dl.bintray.com/${this.client.owner}/${this.client.repo}`);
    }
    setRequestHeaders(value) {
        super.setRequestHeaders(value);
        this.client.setRequestHeaders(value);
    }
    getLatestVersion() {
        var _this = this;

        return (0, (_bluebirdLst || _load_bluebirdLst()).coroutine)(function* () {
            try {
                const data = yield _this.client.getVersion("_latest");
                const channelFilename = (0, (_main || _load_main()).getChannelFilename)((0, (_main || _load_main()).getDefaultChannelName)());
                const files = yield _this.client.getVersionFiles(data.name);
                const channelFile = files.find(function (it) {
                    return it.name.endsWith(`_${channelFilename}`) || it.name.endsWith(`-${channelFilename}`);
                });
                if (channelFile == null) {
                    // noinspection ExceptionCaughtLocallyJS
                    throw (0, (_builderUtilRuntime || _load_builderUtilRuntime()).newError)(`Cannot find channel file "${channelFilename}", existing files:\n${files.map(function (it) {
                        return JSON.stringify(it, null, 2);
                    }).join(",\n")}`, "ERR_UPDATER_CHANNEL_FILE_NOT_FOUND");
                }
                const channelFileUrl = new (_url || _load_url()).URL(`https://dl.bintray.com/${_this.client.owner}/${_this.client.repo}/${channelFile.name}`);
                return (0, (_Provider || _load_Provider()).parseUpdateInfo)((yield _this.httpRequest(channelFileUrl)), channelFilename, channelFileUrl);
            } catch (e) {
                if ("statusCode" in e && e.statusCode === 404) {
                    throw (0, (_builderUtilRuntime || _load_builderUtilRuntime()).newError)(`No latest version, please ensure that user, package and repository correctly configured. Or at least one version is published. ${e.stack || e.message}`, "ERR_UPDATER_LATEST_VERSION_NOT_FOUND");
                }
                throw e;
            }
        })();
    }
    resolveFiles(updateInfo) {
        return (0, (_Provider || _load_Provider()).resolveFiles)(updateInfo, this.baseUrl);
    }
}
exports.BintrayProvider = BintrayProvider; //# sourceMappingURL=BintrayProvider.js.map

/***/ }),
/* 172 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.BintrayClient = undefined;

var _httpExecutor;

function _load_httpExecutor() {
    return _httpExecutor = __webpack_require__(42);
}

class BintrayClient {
    constructor(options, httpExecutor, cancellationToken, apiKey) {
        this.httpExecutor = httpExecutor;
        this.cancellationToken = cancellationToken;
        if (options.owner == null) {
            throw new Error("owner is not specified");
        }
        if (options.package == null) {
            throw new Error("package is not specified");
        }
        this.repo = options.repo || "generic";
        this.packageName = options.package;
        this.owner = options.owner;
        this.user = options.user || options.owner;
        this.component = options.component || null;
        this.distribution = options.distribution || "stable";
        this.auth = apiKey == null ? null : `Basic ${Buffer.from(`${this.user}:${apiKey}`).toString("base64")}`;
        this.basePath = `/packages/${this.owner}/${this.repo}/${this.packageName}`;
    }
    setRequestHeaders(value) {
        this.requestHeaders = value;
    }
    bintrayRequest(path, auth, data = null, cancellationToken, method) {
        return (0, (_httpExecutor || _load_httpExecutor()).parseJson)(this.httpExecutor.request((0, (_httpExecutor || _load_httpExecutor()).configureRequestOptions)({ hostname: "api.bintray.com", path, headers: this.requestHeaders || undefined }, auth, method), cancellationToken, data));
    }
    getVersion(version) {
        return this.bintrayRequest(`${this.basePath}/versions/${version}`, this.auth, null, this.cancellationToken);
    }
    getVersionFiles(version) {
        return this.bintrayRequest(`${this.basePath}/versions/${version}/files`, this.auth, null, this.cancellationToken);
    }
    createVersion(version) {
        return this.bintrayRequest(`${this.basePath}/versions`, this.auth, {
            name: version
        }, this.cancellationToken);
    }
    deleteVersion(version) {
        return this.bintrayRequest(`${this.basePath}/versions/${version}`, this.auth, null, this.cancellationToken, "DELETE");
    }
}
exports.BintrayClient = BintrayClient; //# sourceMappingURL=bintray.js.map

/***/ }),
/* 173 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.PrivateGitHubProvider = undefined;

var _bluebirdLst;

function _load_bluebirdLst() {
    return _bluebirdLst = __webpack_require__(2);
}

var _builderUtilRuntime;

function _load_builderUtilRuntime() {
    return _builderUtilRuntime = __webpack_require__(3);
}

var _jsYaml;

function _load_jsYaml() {
    return _jsYaml = __webpack_require__(31);
}

var _path = _interopRequireWildcard(__webpack_require__(0));

var _url;

function _load_url() {
    return _url = __webpack_require__(20);
}

var _GitHubProvider;

function _load_GitHubProvider() {
    return _GitHubProvider = __webpack_require__(60);
}

var _main;

function _load_main() {
    return _main = __webpack_require__(8);
}

var _Provider;

function _load_Provider() {
    return _Provider = __webpack_require__(14);
}

function _interopRequireWildcard(obj) {
    if (obj && obj.__esModule) {
        return obj;
    } else {
        var newObj = {};if (obj != null) {
            for (var key in obj) {
                if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key];
            }
        }newObj.default = obj;return newObj;
    }
}

class PrivateGitHubProvider extends (_GitHubProvider || _load_GitHubProvider()).BaseGitHubProvider {
    constructor(options, token, executor) {
        super(options, "api.github.com", executor);
        this.token = token;
    }
    createRequestOptions(url, headers) {
        const result = super.createRequestOptions(url, headers);
        result.redirect = "manual";
        return result;
    }
    getLatestVersion() {
        var _this = this;

        return (0, (_bluebirdLst || _load_bluebirdLst()).coroutine)(function* () {
            const basePath = _this.basePath;
            const cancellationToken = new (_builderUtilRuntime || _load_builderUtilRuntime()).CancellationToken();
            const channelFile = (0, (_main || _load_main()).getChannelFilename)((0, (_main || _load_main()).getDefaultChannelName)());
            const releaseInfo = yield _this.getLatestVersionInfo(basePath, cancellationToken);
            const asset = releaseInfo.assets.find(function (it) {
                return it.name === channelFile;
            });
            if (asset == null) {
                // html_url must be always, but just to be sure
                throw (0, (_builderUtilRuntime || _load_builderUtilRuntime()).newError)(`Cannot find ${channelFile} in the release ${releaseInfo.html_url || releaseInfo.name}`, "ERR_UPDATER_CHANNEL_FILE_NOT_FOUND");
            }
            const url = new (_url || _load_url()).URL(asset.url);
            let result;
            try {
                result = (0, (_jsYaml || _load_jsYaml()).safeLoad)((yield _this.httpRequest(url, _this.configureHeaders("application/octet-stream"), cancellationToken)));
            } catch (e) {
                if (e instanceof (_builderUtilRuntime || _load_builderUtilRuntime()).HttpError && e.statusCode === 404) {
                    throw (0, (_builderUtilRuntime || _load_builderUtilRuntime()).newError)(`Cannot find ${channelFile} in the latest release artifacts (${url}): ${e.stack || e.message}`, "ERR_UPDATER_CHANNEL_FILE_NOT_FOUND");
                }
                throw e;
            }
            result.assets = releaseInfo.assets;
            return result;
        })();
    }
    get fileExtraDownloadHeaders() {
        return this.configureHeaders("application/octet-stream");
    }
    configureHeaders(accept) {
        return {
            Accept: accept,
            Authorization: `token ${this.token}`
        };
    }
    getLatestVersionInfo(basePath, cancellationToken) {
        var _this2 = this;

        return (0, (_bluebirdLst || _load_bluebirdLst()).coroutine)(function* () {
            const url = (0, (_main || _load_main()).newUrlFromBase)(`${basePath}/latest`, _this2.baseUrl);
            try {
                return JSON.parse((yield _this2.httpRequest(url, _this2.configureHeaders("application/vnd.github.v3+json"), cancellationToken)));
            } catch (e) {
                throw (0, (_builderUtilRuntime || _load_builderUtilRuntime()).newError)(`Unable to find latest version on GitHub (${url}), please ensure a production release exists: ${e.stack || e.message}`, "ERR_UPDATER_LATEST_VERSION_NOT_FOUND");
            }
        })();
    }
    get basePath() {
        return this.computeGithubBasePath(`/repos/${this.options.owner}/${this.options.repo}/releases`);
    }
    resolveFiles(updateInfo) {
        return (0, (_Provider || _load_Provider()).getFileList)(updateInfo).map(it => {
            const name = _path.posix.basename(it.url).replace(/ /g, "-");
            const asset = updateInfo.assets.find(it => it != null && it.name === name);
            if (asset == null) {
                throw (0, (_builderUtilRuntime || _load_builderUtilRuntime()).newError)(`Cannot find asset "${name}" in: ${JSON.stringify(updateInfo.assets, null, 2)}`, "ERR_UPDATER_ASSET_NOT_FOUND");
            }
            return {
                url: new (_url || _load_url()).URL(asset.url),
                info: it
            };
        });
    }
}
exports.PrivateGitHubProvider = PrivateGitHubProvider; //# sourceMappingURL=PrivateGitHubProvider.js.map

/***/ }),
/* 174 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.NsisUpdater = undefined;

var _bluebirdLst;

function _load_bluebirdLst() {
    return _bluebirdLst = __webpack_require__(2);
}

var _builderUtilRuntime;

function _load_builderUtilRuntime() {
    return _builderUtilRuntime = __webpack_require__(3);
}

var _child_process;

function _load_child_process() {
    return _child_process = __webpack_require__(34);
}

var _path = _interopRequireWildcard(__webpack_require__(0));

__webpack_require__(33);

var _BaseUpdater;

function _load_BaseUpdater() {
    return _BaseUpdater = __webpack_require__(61);
}

var _FileWithEmbeddedBlockMapDifferentialDownloader;

function _load_FileWithEmbeddedBlockMapDifferentialDownloader() {
    return _FileWithEmbeddedBlockMapDifferentialDownloader = __webpack_require__(62);
}

var _GenericDifferentialDownloader;

function _load_GenericDifferentialDownloader() {
    return _GenericDifferentialDownloader = __webpack_require__(179);
}

var _main;

function _load_main() {
    return _main = __webpack_require__(8);
}

var _Provider;

function _load_Provider() {
    return _Provider = __webpack_require__(14);
}

var _windowsExecutableCodeSignatureVerifier;

function _load_windowsExecutableCodeSignatureVerifier() {
    return _windowsExecutableCodeSignatureVerifier = __webpack_require__(180);
}

function _interopRequireWildcard(obj) {
    if (obj && obj.__esModule) {
        return obj;
    } else {
        var newObj = {};if (obj != null) {
            for (var key in obj) {
                if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key];
            }
        }newObj.default = obj;return newObj;
    }
}

class NsisUpdater extends (_BaseUpdater || _load_BaseUpdater()).BaseUpdater {
    constructor(options, app) {
        super(options, app);
    }
    /*** @private */
    doDownloadUpdate(updateInfo, cancellationToken) {
        var _this = this;

        return (0, (_bluebirdLst || _load_bluebirdLst()).coroutine)(function* () {
            const provider = yield _this.provider;
            const fileInfo = (0, (_Provider || _load_Provider()).findFile)(provider.resolveFiles(updateInfo), "exe");
            const requestHeaders = yield _this.computeRequestHeaders();
            const downloadOptions = {
                skipDirCreation: true,
                headers: requestHeaders,
                cancellationToken,
                sha512: fileInfo.info.sha512
            };
            let packagePath = _this.downloadedUpdateHelper.packagePath;
            let installerPath = _this.downloadedUpdateHelper.getDownloadedFile(updateInfo, fileInfo);
            if (installerPath != null) {
                return packagePath == null ? [installerPath] : [installerPath, packagePath];
            }
            yield _this.executeDownload(downloadOptions, fileInfo, (() => {
                var _ref = (0, (_bluebirdLst || _load_bluebirdLst()).coroutine)(function* (tempDir, destinationFile, removeTempDirIfAny) {
                    installerPath = destinationFile;
                    if (yield _this.differentialDownloadInstaller(fileInfo, "OLD", installerPath, requestHeaders, provider)) {
                        yield _this.httpExecutor.download(fileInfo.url.href, installerPath, downloadOptions);
                    }
                    const signatureVerificationStatus = yield _this.verifySignature(installerPath);
                    if (signatureVerificationStatus != null) {
                        yield removeTempDirIfAny();
                        // noinspection ThrowInsideFinallyBlockJS
                        throw (0, (_builderUtilRuntime || _load_builderUtilRuntime()).newError)(`New version ${_this.updateInfo.version} is not signed by the application owner: ${signatureVerificationStatus}`, "ERR_UPDATER_INVALID_SIGNATURE");
                    }
                    const packageInfo = fileInfo.packageInfo;
                    if (packageInfo != null) {
                        packagePath = _path.join(tempDir, `package-${updateInfo.version}${_path.extname(packageInfo.path) || ".7z"}`);
                        if (yield _this.differentialDownloadWebPackage(packageInfo, packagePath, provider)) {
                            yield _this.httpExecutor.download(packageInfo.path, packagePath, {
                                skipDirCreation: true,
                                headers: requestHeaders,
                                cancellationToken,
                                sha512: packageInfo.sha512
                            });
                        }
                    }
                });

                return function (_x, _x2, _x3) {
                    return _ref.apply(this, arguments);
                };
            })());
            _this.downloadedUpdateHelper.setDownloadedFile(installerPath, packagePath, updateInfo, fileInfo);
            _this.addQuitHandler();
            _this.emit((_main || _load_main()).UPDATE_DOWNLOADED, _this.updateInfo);
            return packagePath == null ? [installerPath] : [installerPath, packagePath];
        })();
    }
    // $certificateInfo = (Get-AuthenticodeSignature 'xxx\yyy.exe'
    // | where {$_.Status.Equals([System.Management.Automation.SignatureStatus]::Valid) -and $_.SignerCertificate.Subject.Contains("CN=siemens.com")})
    // | Out-String ; if ($certificateInfo) { exit 0 } else { exit 1 }
    verifySignature(tempUpdateFile) {
        var _this2 = this;

        return (0, (_bluebirdLst || _load_bluebirdLst()).coroutine)(function* () {
            let publisherName;
            try {
                publisherName = (yield _this2.configOnDisk.value).publisherName;
                if (publisherName == null) {
                    return null;
                }
            } catch (e) {
                if (e.code === "ENOENT") {
                    // no app-update.yml
                    return null;
                }
                throw e;
            }
            return yield (0, (_windowsExecutableCodeSignatureVerifier || _load_windowsExecutableCodeSignatureVerifier()).verifySignature)(Array.isArray(publisherName) ? publisherName : [publisherName], tempUpdateFile, _this2._logger);
        })();
    }
    doInstall(installerPath, isSilent, isForceRunAfter) {
        const args = ["--updated"];
        if (isSilent) {
            args.push("/S");
        }
        if (isForceRunAfter) {
            args.push("--force-run");
        }
        const packagePath = this.downloadedUpdateHelper.packagePath;
        if (packagePath != null) {
            // only = form is supported
            args.push(`--package-file=${packagePath}`);
        }
        const spawnOptions = {
            detached: true,
            stdio: "ignore"
        };
        try {
            (0, (_child_process || _load_child_process()).spawn)(installerPath, args, spawnOptions).unref();
        } catch (e) {
            // yes, such errors dispatched not as error event
            // https://github.com/electron-userland/electron-builder/issues/1129
            if (e.code === "UNKNOWN" || e.code === "EACCES") {
                this._logger.info("Access denied or UNKNOWN error code on spawn, will be executed again using elevate");
                try {
                    (0, (_child_process || _load_child_process()).spawn)(_path.join(process.resourcesPath, "elevate.exe"), [installerPath].concat(args), spawnOptions).unref();
                } catch (e) {
                    this.dispatchError(e);
                }
            } else {
                this.dispatchError(e);
            }
        }
        return true;
    }
    differentialDownloadInstaller(fileInfo, oldFile, installerPath, requestHeaders, provider) {
        var _this3 = this;

        return (0, (_bluebirdLst || _load_bluebirdLst()).coroutine)(function* () {
            if (process.env.__NSIS_DIFFERENTIAL_UPDATE__ == null) {
                return true;
            }
            try {
                const blockMapData = JSON.parse((yield provider.httpRequest((0, (_main || _load_main()).newUrlFromBase)(`${fileInfo.url.pathname}.blockMap.json`, fileInfo.url))));
                yield new (_GenericDifferentialDownloader || _load_GenericDifferentialDownloader()).GenericDifferentialDownloader(fileInfo.info, _this3.httpExecutor, {
                    newUrl: fileInfo.url.href,
                    oldFile,
                    logger: _this3._logger,
                    newFile: installerPath,
                    useMultipleRangeRequest: provider.useMultipleRangeRequest,
                    requestHeaders
                }).download(blockMapData);
            } catch (e) {
                _this3._logger.error(`Cannot download differentially, fallback to full download: ${e.stack || e}`);
                // during test (developer machine mac) we must throw error
                return process.platform === "win32";
            }
            return false;
        })();
    }
    differentialDownloadWebPackage(packageInfo, packagePath, provider) {
        var _this4 = this;

        return (0, (_bluebirdLst || _load_bluebirdLst()).coroutine)(function* () {
            if (packageInfo.blockMapSize == null) {
                return true;
            }
            try {
                yield new (_FileWithEmbeddedBlockMapDifferentialDownloader || _load_FileWithEmbeddedBlockMapDifferentialDownloader()).FileWithEmbeddedBlockMapDifferentialDownloader(packageInfo, _this4.httpExecutor, {
                    newUrl: packageInfo.path,
                    oldFile: _path.join(process.resourcesPath, "..", "package.7z"),
                    logger: _this4._logger,
                    newFile: packagePath,
                    requestHeaders: _this4.requestHeaders,
                    useMultipleRangeRequest: provider.useMultipleRangeRequest
                }).download();
            } catch (e) {
                _this4._logger.error(`Cannot download differentially, fallback to full download: ${e.stack || e}`);
                // during test (developer machine mac or linux) we must throw error
                return process.platform === "win32";
            }
            return false;
        })();
    }
}
exports.NsisUpdater = NsisUpdater; //# sourceMappingURL=NsisUpdater.js.map

/***/ }),
/* 175 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.DownloadedUpdateHelper = undefined;

var _lodash;

function _load_lodash() {
    return _lodash = _interopRequireDefault(__webpack_require__(176));
}

function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
}

/** @private **/
class DownloadedUpdateHelper {
    get file() {
        return this.setupPath;
    }
    get packagePath() {
        return this._packagePath;
    }
    getDownloadedFile(versionInfo, fileInfo) {
        if (this.setupPath == null) {
            return null;
        }
        return (0, (_lodash || _load_lodash()).default)(this.versionInfo, versionInfo) && (0, (_lodash || _load_lodash()).default)(this.fileInfo, fileInfo) ? this.setupPath : null;
    }
    setDownloadedFile(file, packagePath, versionInfo, fileInfo) {
        this.setupPath = file;
        this._packagePath = packagePath;
        this.versionInfo = versionInfo;
        this.fileInfo = fileInfo;
    }
    clear() {
        this.setupPath = null;
        this._packagePath = null;
        this.versionInfo = null;
        this.fileInfo = null;
    }
}
exports.DownloadedUpdateHelper = DownloadedUpdateHelper; //# sourceMappingURL=DownloadedUpdateHelper.js.map

/***/ }),
/* 176 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(module) {

/**
 * Lodash (Custom Build) <https://lodash.com/>
 * Build: `lodash modularize exports="npm" -o ./`
 * Copyright JS Foundation and other contributors <https://js.foundation/>
 * Released under MIT license <https://lodash.com/license>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 */

/** Used as the size to enable large array optimizations. */
var LARGE_ARRAY_SIZE = 200;

/** Used to stand-in for `undefined` hash values. */
var HASH_UNDEFINED = '__lodash_hash_undefined__';

/** Used to compose bitmasks for value comparisons. */
var COMPARE_PARTIAL_FLAG = 1,
    COMPARE_UNORDERED_FLAG = 2;

/** Used as references for various `Number` constants. */
var MAX_SAFE_INTEGER = 9007199254740991;

/** `Object#toString` result references. */
var argsTag = '[object Arguments]',
    arrayTag = '[object Array]',
    asyncTag = '[object AsyncFunction]',
    boolTag = '[object Boolean]',
    dateTag = '[object Date]',
    errorTag = '[object Error]',
    funcTag = '[object Function]',
    genTag = '[object GeneratorFunction]',
    mapTag = '[object Map]',
    numberTag = '[object Number]',
    nullTag = '[object Null]',
    objectTag = '[object Object]',
    promiseTag = '[object Promise]',
    proxyTag = '[object Proxy]',
    regexpTag = '[object RegExp]',
    setTag = '[object Set]',
    stringTag = '[object String]',
    symbolTag = '[object Symbol]',
    undefinedTag = '[object Undefined]',
    weakMapTag = '[object WeakMap]';

var arrayBufferTag = '[object ArrayBuffer]',
    dataViewTag = '[object DataView]',
    float32Tag = '[object Float32Array]',
    float64Tag = '[object Float64Array]',
    int8Tag = '[object Int8Array]',
    int16Tag = '[object Int16Array]',
    int32Tag = '[object Int32Array]',
    uint8Tag = '[object Uint8Array]',
    uint8ClampedTag = '[object Uint8ClampedArray]',
    uint16Tag = '[object Uint16Array]',
    uint32Tag = '[object Uint32Array]';

/**
 * Used to match `RegExp`
 * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).
 */
var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;

/** Used to detect host constructors (Safari). */
var reIsHostCtor = /^\[object .+?Constructor\]$/;

/** Used to detect unsigned integer values. */
var reIsUint = /^(?:0|[1-9]\d*)$/;

/** Used to identify `toStringTag` values of typed arrays. */
var typedArrayTags = {};
typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;
typedArrayTags[argsTag] = typedArrayTags[arrayTag] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] = typedArrayTags[dataViewTag] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag] = typedArrayTags[mapTag] = typedArrayTags[numberTag] = typedArrayTags[objectTag] = typedArrayTags[regexpTag] = typedArrayTags[setTag] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;

/** Detect free variable `global` from Node.js. */
var freeGlobal = typeof global == 'object' && global && global.Object === Object && global;

/** Detect free variable `self`. */
var freeSelf = typeof self == 'object' && self && self.Object === Object && self;

/** Used as a reference to the global object. */
var root = freeGlobal || freeSelf || Function('return this')();

/** Detect free variable `exports`. */
var freeExports = typeof exports == 'object' && exports && !exports.nodeType && exports;

/** Detect free variable `module`. */
var freeModule = freeExports && typeof module == 'object' && module && !module.nodeType && module;

/** Detect the popular CommonJS extension `module.exports`. */
var moduleExports = freeModule && freeModule.exports === freeExports;

/** Detect free variable `process` from Node.js. */
var freeProcess = moduleExports && freeGlobal.process;

/** Used to access faster Node.js helpers. */
var nodeUtil = function () {
  try {
    return freeProcess && freeProcess.binding && freeProcess.binding('util');
  } catch (e) {}
}();

/* Node.js helper references. */
var nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;

/**
 * A specialized version of `_.filter` for arrays without support for
 * iteratee shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} predicate The function invoked per iteration.
 * @returns {Array} Returns the new filtered array.
 */
function arrayFilter(array, predicate) {
  var index = -1,
      length = array == null ? 0 : array.length,
      resIndex = 0,
      result = [];

  while (++index < length) {
    var value = array[index];
    if (predicate(value, index, array)) {
      result[resIndex++] = value;
    }
  }
  return result;
}

/**
 * Appends the elements of `values` to `array`.
 *
 * @private
 * @param {Array} array The array to modify.
 * @param {Array} values The values to append.
 * @returns {Array} Returns `array`.
 */
function arrayPush(array, values) {
  var index = -1,
      length = values.length,
      offset = array.length;

  while (++index < length) {
    array[offset + index] = values[index];
  }
  return array;
}

/**
 * A specialized version of `_.some` for arrays without support for iteratee
 * shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} predicate The function invoked per iteration.
 * @returns {boolean} Returns `true` if any element passes the predicate check,
 *  else `false`.
 */
function arraySome(array, predicate) {
  var index = -1,
      length = array == null ? 0 : array.length;

  while (++index < length) {
    if (predicate(array[index], index, array)) {
      return true;
    }
  }
  return false;
}

/**
 * The base implementation of `_.times` without support for iteratee shorthands
 * or max array length checks.
 *
 * @private
 * @param {number} n The number of times to invoke `iteratee`.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns the array of results.
 */
function baseTimes(n, iteratee) {
  var index = -1,
      result = Array(n);

  while (++index < n) {
    result[index] = iteratee(index);
  }
  return result;
}

/**
 * The base implementation of `_.unary` without support for storing metadata.
 *
 * @private
 * @param {Function} func The function to cap arguments for.
 * @returns {Function} Returns the new capped function.
 */
function baseUnary(func) {
  return function (value) {
    return func(value);
  };
}

/**
 * Checks if a `cache` value for `key` exists.
 *
 * @private
 * @param {Object} cache The cache to query.
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function cacheHas(cache, key) {
  return cache.has(key);
}

/**
 * Gets the value at `key` of `object`.
 *
 * @private
 * @param {Object} [object] The object to query.
 * @param {string} key The key of the property to get.
 * @returns {*} Returns the property value.
 */
function getValue(object, key) {
  return object == null ? undefined : object[key];
}

/**
 * Converts `map` to its key-value pairs.
 *
 * @private
 * @param {Object} map The map to convert.
 * @returns {Array} Returns the key-value pairs.
 */
function mapToArray(map) {
  var index = -1,
      result = Array(map.size);

  map.forEach(function (value, key) {
    result[++index] = [key, value];
  });
  return result;
}

/**
 * Creates a unary function that invokes `func` with its argument transformed.
 *
 * @private
 * @param {Function} func The function to wrap.
 * @param {Function} transform The argument transform.
 * @returns {Function} Returns the new function.
 */
function overArg(func, transform) {
  return function (arg) {
    return func(transform(arg));
  };
}

/**
 * Converts `set` to an array of its values.
 *
 * @private
 * @param {Object} set The set to convert.
 * @returns {Array} Returns the values.
 */
function setToArray(set) {
  var index = -1,
      result = Array(set.size);

  set.forEach(function (value) {
    result[++index] = value;
  });
  return result;
}

/** Used for built-in method references. */
var arrayProto = Array.prototype,
    funcProto = Function.prototype,
    objectProto = Object.prototype;

/** Used to detect overreaching core-js shims. */
var coreJsData = root['__core-js_shared__'];

/** Used to resolve the decompiled source of functions. */
var funcToString = funcProto.toString;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/** Used to detect methods masquerading as native. */
var maskSrcKey = function () {
  var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');
  return uid ? 'Symbol(src)_1.' + uid : '';
}();

/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */
var nativeObjectToString = objectProto.toString;

/** Used to detect if a method is native. */
var reIsNative = RegExp('^' + funcToString.call(hasOwnProperty).replace(reRegExpChar, '\\$&').replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$');

/** Built-in value references. */
var Buffer = moduleExports ? root.Buffer : undefined,
    Symbol = root.Symbol,
    Uint8Array = root.Uint8Array,
    propertyIsEnumerable = objectProto.propertyIsEnumerable,
    splice = arrayProto.splice,
    symToStringTag = Symbol ? Symbol.toStringTag : undefined;

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeGetSymbols = Object.getOwnPropertySymbols,
    nativeIsBuffer = Buffer ? Buffer.isBuffer : undefined,
    nativeKeys = overArg(Object.keys, Object);

/* Built-in method references that are verified to be native. */
var DataView = getNative(root, 'DataView'),
    Map = getNative(root, 'Map'),
    Promise = getNative(root, 'Promise'),
    Set = getNative(root, 'Set'),
    WeakMap = getNative(root, 'WeakMap'),
    nativeCreate = getNative(Object, 'create');

/** Used to detect maps, sets, and weakmaps. */
var dataViewCtorString = toSource(DataView),
    mapCtorString = toSource(Map),
    promiseCtorString = toSource(Promise),
    setCtorString = toSource(Set),
    weakMapCtorString = toSource(WeakMap);

/** Used to convert symbols to primitives and strings. */
var symbolProto = Symbol ? Symbol.prototype : undefined,
    symbolValueOf = symbolProto ? symbolProto.valueOf : undefined;

/**
 * Creates a hash object.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function Hash(entries) {
  var index = -1,
      length = entries == null ? 0 : entries.length;

  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}

/**
 * Removes all key-value entries from the hash.
 *
 * @private
 * @name clear
 * @memberOf Hash
 */
function hashClear() {
  this.__data__ = nativeCreate ? nativeCreate(null) : {};
  this.size = 0;
}

/**
 * Removes `key` and its value from the hash.
 *
 * @private
 * @name delete
 * @memberOf Hash
 * @param {Object} hash The hash to modify.
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function hashDelete(key) {
  var result = this.has(key) && delete this.__data__[key];
  this.size -= result ? 1 : 0;
  return result;
}

/**
 * Gets the hash value for `key`.
 *
 * @private
 * @name get
 * @memberOf Hash
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function hashGet(key) {
  var data = this.__data__;
  if (nativeCreate) {
    var result = data[key];
    return result === HASH_UNDEFINED ? undefined : result;
  }
  return hasOwnProperty.call(data, key) ? data[key] : undefined;
}

/**
 * Checks if a hash value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf Hash
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function hashHas(key) {
  var data = this.__data__;
  return nativeCreate ? data[key] !== undefined : hasOwnProperty.call(data, key);
}

/**
 * Sets the hash `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf Hash
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the hash instance.
 */
function hashSet(key, value) {
  var data = this.__data__;
  this.size += this.has(key) ? 0 : 1;
  data[key] = nativeCreate && value === undefined ? HASH_UNDEFINED : value;
  return this;
}

// Add methods to `Hash`.
Hash.prototype.clear = hashClear;
Hash.prototype['delete'] = hashDelete;
Hash.prototype.get = hashGet;
Hash.prototype.has = hashHas;
Hash.prototype.set = hashSet;

/**
 * Creates an list cache object.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function ListCache(entries) {
  var index = -1,
      length = entries == null ? 0 : entries.length;

  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}

/**
 * Removes all key-value entries from the list cache.
 *
 * @private
 * @name clear
 * @memberOf ListCache
 */
function listCacheClear() {
  this.__data__ = [];
  this.size = 0;
}

/**
 * Removes `key` and its value from the list cache.
 *
 * @private
 * @name delete
 * @memberOf ListCache
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function listCacheDelete(key) {
  var data = this.__data__,
      index = assocIndexOf(data, key);

  if (index < 0) {
    return false;
  }
  var lastIndex = data.length - 1;
  if (index == lastIndex) {
    data.pop();
  } else {
    splice.call(data, index, 1);
  }
  --this.size;
  return true;
}

/**
 * Gets the list cache value for `key`.
 *
 * @private
 * @name get
 * @memberOf ListCache
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function listCacheGet(key) {
  var data = this.__data__,
      index = assocIndexOf(data, key);

  return index < 0 ? undefined : data[index][1];
}

/**
 * Checks if a list cache value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf ListCache
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function listCacheHas(key) {
  return assocIndexOf(this.__data__, key) > -1;
}

/**
 * Sets the list cache `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf ListCache
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the list cache instance.
 */
function listCacheSet(key, value) {
  var data = this.__data__,
      index = assocIndexOf(data, key);

  if (index < 0) {
    ++this.size;
    data.push([key, value]);
  } else {
    data[index][1] = value;
  }
  return this;
}

// Add methods to `ListCache`.
ListCache.prototype.clear = listCacheClear;
ListCache.prototype['delete'] = listCacheDelete;
ListCache.prototype.get = listCacheGet;
ListCache.prototype.has = listCacheHas;
ListCache.prototype.set = listCacheSet;

/**
 * Creates a map cache object to store key-value pairs.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function MapCache(entries) {
  var index = -1,
      length = entries == null ? 0 : entries.length;

  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}

/**
 * Removes all key-value entries from the map.
 *
 * @private
 * @name clear
 * @memberOf MapCache
 */
function mapCacheClear() {
  this.size = 0;
  this.__data__ = {
    'hash': new Hash(),
    'map': new (Map || ListCache)(),
    'string': new Hash()
  };
}

/**
 * Removes `key` and its value from the map.
 *
 * @private
 * @name delete
 * @memberOf MapCache
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function mapCacheDelete(key) {
  var result = getMapData(this, key)['delete'](key);
  this.size -= result ? 1 : 0;
  return result;
}

/**
 * Gets the map value for `key`.
 *
 * @private
 * @name get
 * @memberOf MapCache
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function mapCacheGet(key) {
  return getMapData(this, key).get(key);
}

/**
 * Checks if a map value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf MapCache
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function mapCacheHas(key) {
  return getMapData(this, key).has(key);
}

/**
 * Sets the map `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf MapCache
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the map cache instance.
 */
function mapCacheSet(key, value) {
  var data = getMapData(this, key),
      size = data.size;

  data.set(key, value);
  this.size += data.size == size ? 0 : 1;
  return this;
}

// Add methods to `MapCache`.
MapCache.prototype.clear = mapCacheClear;
MapCache.prototype['delete'] = mapCacheDelete;
MapCache.prototype.get = mapCacheGet;
MapCache.prototype.has = mapCacheHas;
MapCache.prototype.set = mapCacheSet;

/**
 *
 * Creates an array cache object to store unique values.
 *
 * @private
 * @constructor
 * @param {Array} [values] The values to cache.
 */
function SetCache(values) {
  var index = -1,
      length = values == null ? 0 : values.length;

  this.__data__ = new MapCache();
  while (++index < length) {
    this.add(values[index]);
  }
}

/**
 * Adds `value` to the array cache.
 *
 * @private
 * @name add
 * @memberOf SetCache
 * @alias push
 * @param {*} value The value to cache.
 * @returns {Object} Returns the cache instance.
 */
function setCacheAdd(value) {
  this.__data__.set(value, HASH_UNDEFINED);
  return this;
}

/**
 * Checks if `value` is in the array cache.
 *
 * @private
 * @name has
 * @memberOf SetCache
 * @param {*} value The value to search for.
 * @returns {number} Returns `true` if `value` is found, else `false`.
 */
function setCacheHas(value) {
  return this.__data__.has(value);
}

// Add methods to `SetCache`.
SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
SetCache.prototype.has = setCacheHas;

/**
 * Creates a stack cache object to store key-value pairs.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function Stack(entries) {
  var data = this.__data__ = new ListCache(entries);
  this.size = data.size;
}

/**
 * Removes all key-value entries from the stack.
 *
 * @private
 * @name clear
 * @memberOf Stack
 */
function stackClear() {
  this.__data__ = new ListCache();
  this.size = 0;
}

/**
 * Removes `key` and its value from the stack.
 *
 * @private
 * @name delete
 * @memberOf Stack
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function stackDelete(key) {
  var data = this.__data__,
      result = data['delete'](key);

  this.size = data.size;
  return result;
}

/**
 * Gets the stack value for `key`.
 *
 * @private
 * @name get
 * @memberOf Stack
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function stackGet(key) {
  return this.__data__.get(key);
}

/**
 * Checks if a stack value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf Stack
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function stackHas(key) {
  return this.__data__.has(key);
}

/**
 * Sets the stack `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf Stack
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the stack cache instance.
 */
function stackSet(key, value) {
  var data = this.__data__;
  if (data instanceof ListCache) {
    var pairs = data.__data__;
    if (!Map || pairs.length < LARGE_ARRAY_SIZE - 1) {
      pairs.push([key, value]);
      this.size = ++data.size;
      return this;
    }
    data = this.__data__ = new MapCache(pairs);
  }
  data.set(key, value);
  this.size = data.size;
  return this;
}

// Add methods to `Stack`.
Stack.prototype.clear = stackClear;
Stack.prototype['delete'] = stackDelete;
Stack.prototype.get = stackGet;
Stack.prototype.has = stackHas;
Stack.prototype.set = stackSet;

/**
 * Creates an array of the enumerable property names of the array-like `value`.
 *
 * @private
 * @param {*} value The value to query.
 * @param {boolean} inherited Specify returning inherited property names.
 * @returns {Array} Returns the array of property names.
 */
function arrayLikeKeys(value, inherited) {
  var isArr = isArray(value),
      isArg = !isArr && isArguments(value),
      isBuff = !isArr && !isArg && isBuffer(value),
      isType = !isArr && !isArg && !isBuff && isTypedArray(value),
      skipIndexes = isArr || isArg || isBuff || isType,
      result = skipIndexes ? baseTimes(value.length, String) : [],
      length = result.length;

  for (var key in value) {
    if ((inherited || hasOwnProperty.call(value, key)) && !(skipIndexes && (
    // Safari 9 has enumerable `arguments.length` in strict mode.
    key == 'length' ||
    // Node.js 0.10 has enumerable non-index properties on buffers.
    isBuff && (key == 'offset' || key == 'parent') ||
    // PhantomJS 2 has enumerable non-index properties on typed arrays.
    isType && (key == 'buffer' || key == 'byteLength' || key == 'byteOffset') ||
    // Skip index properties.
    isIndex(key, length)))) {
      result.push(key);
    }
  }
  return result;
}

/**
 * Gets the index at which the `key` is found in `array` of key-value pairs.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {*} key The key to search for.
 * @returns {number} Returns the index of the matched value, else `-1`.
 */
function assocIndexOf(array, key) {
  var length = array.length;
  while (length--) {
    if (eq(array[length][0], key)) {
      return length;
    }
  }
  return -1;
}

/**
 * The base implementation of `getAllKeys` and `getAllKeysIn` which uses
 * `keysFunc` and `symbolsFunc` to get the enumerable property names and
 * symbols of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {Function} keysFunc The function to get the keys of `object`.
 * @param {Function} symbolsFunc The function to get the symbols of `object`.
 * @returns {Array} Returns the array of property names and symbols.
 */
function baseGetAllKeys(object, keysFunc, symbolsFunc) {
  var result = keysFunc(object);
  return isArray(object) ? result : arrayPush(result, symbolsFunc(object));
}

/**
 * The base implementation of `getTag` without fallbacks for buggy environments.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the `toStringTag`.
 */
function baseGetTag(value) {
  if (value == null) {
    return value === undefined ? undefinedTag : nullTag;
  }
  return symToStringTag && symToStringTag in Object(value) ? getRawTag(value) : objectToString(value);
}

/**
 * The base implementation of `_.isArguments`.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an `arguments` object,
 */
function baseIsArguments(value) {
  return isObjectLike(value) && baseGetTag(value) == argsTag;
}

/**
 * The base implementation of `_.isEqual` which supports partial comparisons
 * and tracks traversed objects.
 *
 * @private
 * @param {*} value The value to compare.
 * @param {*} other The other value to compare.
 * @param {boolean} bitmask The bitmask flags.
 *  1 - Unordered comparison
 *  2 - Partial comparison
 * @param {Function} [customizer] The function to customize comparisons.
 * @param {Object} [stack] Tracks traversed `value` and `other` objects.
 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
 */
function baseIsEqual(value, other, bitmask, customizer, stack) {
  if (value === other) {
    return true;
  }
  if (value == null || other == null || !isObjectLike(value) && !isObjectLike(other)) {
    return value !== value && other !== other;
  }
  return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack);
}

/**
 * A specialized version of `baseIsEqual` for arrays and objects which performs
 * deep comparisons and tracks traversed objects enabling objects with circular
 * references to be compared.
 *
 * @private
 * @param {Object} object The object to compare.
 * @param {Object} other The other object to compare.
 * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
 * @param {Function} customizer The function to customize comparisons.
 * @param {Function} equalFunc The function to determine equivalents of values.
 * @param {Object} [stack] Tracks traversed `object` and `other` objects.
 * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
 */
function baseIsEqualDeep(object, other, bitmask, customizer, equalFunc, stack) {
  var objIsArr = isArray(object),
      othIsArr = isArray(other),
      objTag = objIsArr ? arrayTag : getTag(object),
      othTag = othIsArr ? arrayTag : getTag(other);

  objTag = objTag == argsTag ? objectTag : objTag;
  othTag = othTag == argsTag ? objectTag : othTag;

  var objIsObj = objTag == objectTag,
      othIsObj = othTag == objectTag,
      isSameTag = objTag == othTag;

  if (isSameTag && isBuffer(object)) {
    if (!isBuffer(other)) {
      return false;
    }
    objIsArr = true;
    objIsObj = false;
  }
  if (isSameTag && !objIsObj) {
    stack || (stack = new Stack());
    return objIsArr || isTypedArray(object) ? equalArrays(object, other, bitmask, customizer, equalFunc, stack) : equalByTag(object, other, objTag, bitmask, customizer, equalFunc, stack);
  }
  if (!(bitmask & COMPARE_PARTIAL_FLAG)) {
    var objIsWrapped = objIsObj && hasOwnProperty.call(object, '__wrapped__'),
        othIsWrapped = othIsObj && hasOwnProperty.call(other, '__wrapped__');

    if (objIsWrapped || othIsWrapped) {
      var objUnwrapped = objIsWrapped ? object.value() : object,
          othUnwrapped = othIsWrapped ? other.value() : other;

      stack || (stack = new Stack());
      return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);
    }
  }
  if (!isSameTag) {
    return false;
  }
  stack || (stack = new Stack());
  return equalObjects(object, other, bitmask, customizer, equalFunc, stack);
}

/**
 * The base implementation of `_.isNative` without bad shim checks.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a native function,
 *  else `false`.
 */
function baseIsNative(value) {
  if (!isObject(value) || isMasked(value)) {
    return false;
  }
  var pattern = isFunction(value) ? reIsNative : reIsHostCtor;
  return pattern.test(toSource(value));
}

/**
 * The base implementation of `_.isTypedArray` without Node.js optimizations.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
 */
function baseIsTypedArray(value) {
  return isObjectLike(value) && isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
}

/**
 * The base implementation of `_.keys` which doesn't treat sparse arrays as dense.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 */
function baseKeys(object) {
  if (!isPrototype(object)) {
    return nativeKeys(object);
  }
  var result = [];
  for (var key in Object(object)) {
    if (hasOwnProperty.call(object, key) && key != 'constructor') {
      result.push(key);
    }
  }
  return result;
}

/**
 * A specialized version of `baseIsEqualDeep` for arrays with support for
 * partial deep comparisons.
 *
 * @private
 * @param {Array} array The array to compare.
 * @param {Array} other The other array to compare.
 * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
 * @param {Function} customizer The function to customize comparisons.
 * @param {Function} equalFunc The function to determine equivalents of values.
 * @param {Object} stack Tracks traversed `array` and `other` objects.
 * @returns {boolean} Returns `true` if the arrays are equivalent, else `false`.
 */
function equalArrays(array, other, bitmask, customizer, equalFunc, stack) {
  var isPartial = bitmask & COMPARE_PARTIAL_FLAG,
      arrLength = array.length,
      othLength = other.length;

  if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
    return false;
  }
  // Assume cyclic values are equal.
  var stacked = stack.get(array);
  if (stacked && stack.get(other)) {
    return stacked == other;
  }
  var index = -1,
      result = true,
      seen = bitmask & COMPARE_UNORDERED_FLAG ? new SetCache() : undefined;

  stack.set(array, other);
  stack.set(other, array);

  // Ignore non-index properties.
  while (++index < arrLength) {
    var arrValue = array[index],
        othValue = other[index];

    if (customizer) {
      var compared = isPartial ? customizer(othValue, arrValue, index, other, array, stack) : customizer(arrValue, othValue, index, array, other, stack);
    }
    if (compared !== undefined) {
      if (compared) {
        continue;
      }
      result = false;
      break;
    }
    // Recursively compare arrays (susceptible to call stack limits).
    if (seen) {
      if (!arraySome(other, function (othValue, othIndex) {
        if (!cacheHas(seen, othIndex) && (arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
          return seen.push(othIndex);
        }
      })) {
        result = false;
        break;
      }
    } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
      result = false;
      break;
    }
  }
  stack['delete'](array);
  stack['delete'](other);
  return result;
}

/**
 * A specialized version of `baseIsEqualDeep` for comparing objects of
 * the same `toStringTag`.
 *
 * **Note:** This function only supports comparing values with tags of
 * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.
 *
 * @private
 * @param {Object} object The object to compare.
 * @param {Object} other The other object to compare.
 * @param {string} tag The `toStringTag` of the objects to compare.
 * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
 * @param {Function} customizer The function to customize comparisons.
 * @param {Function} equalFunc The function to determine equivalents of values.
 * @param {Object} stack Tracks traversed `object` and `other` objects.
 * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
 */
function equalByTag(object, other, tag, bitmask, customizer, equalFunc, stack) {
  switch (tag) {
    case dataViewTag:
      if (object.byteLength != other.byteLength || object.byteOffset != other.byteOffset) {
        return false;
      }
      object = object.buffer;
      other = other.buffer;

    case arrayBufferTag:
      if (object.byteLength != other.byteLength || !equalFunc(new Uint8Array(object), new Uint8Array(other))) {
        return false;
      }
      return true;

    case boolTag:
    case dateTag:
    case numberTag:
      // Coerce booleans to `1` or `0` and dates to milliseconds.
      // Invalid dates are coerced to `NaN`.
      return eq(+object, +other);

    case errorTag:
      return object.name == other.name && object.message == other.message;

    case regexpTag:
    case stringTag:
      // Coerce regexes to strings and treat strings, primitives and objects,
      // as equal. See http://www.ecma-international.org/ecma-262/7.0/#sec-regexp.prototype.tostring
      // for more details.
      return object == other + '';

    case mapTag:
      var convert = mapToArray;

    case setTag:
      var isPartial = bitmask & COMPARE_PARTIAL_FLAG;
      convert || (convert = setToArray);

      if (object.size != other.size && !isPartial) {
        return false;
      }
      // Assume cyclic values are equal.
      var stacked = stack.get(object);
      if (stacked) {
        return stacked == other;
      }
      bitmask |= COMPARE_UNORDERED_FLAG;

      // Recursively compare objects (susceptible to call stack limits).
      stack.set(object, other);
      var result = equalArrays(convert(object), convert(other), bitmask, customizer, equalFunc, stack);
      stack['delete'](object);
      return result;

    case symbolTag:
      if (symbolValueOf) {
        return symbolValueOf.call(object) == symbolValueOf.call(other);
      }
  }
  return false;
}

/**
 * A specialized version of `baseIsEqualDeep` for objects with support for
 * partial deep comparisons.
 *
 * @private
 * @param {Object} object The object to compare.
 * @param {Object} other The other object to compare.
 * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
 * @param {Function} customizer The function to customize comparisons.
 * @param {Function} equalFunc The function to determine equivalents of values.
 * @param {Object} stack Tracks traversed `object` and `other` objects.
 * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
 */
function equalObjects(object, other, bitmask, customizer, equalFunc, stack) {
  var isPartial = bitmask & COMPARE_PARTIAL_FLAG,
      objProps = getAllKeys(object),
      objLength = objProps.length,
      othProps = getAllKeys(other),
      othLength = othProps.length;

  if (objLength != othLength && !isPartial) {
    return false;
  }
  var index = objLength;
  while (index--) {
    var key = objProps[index];
    if (!(isPartial ? key in other : hasOwnProperty.call(other, key))) {
      return false;
    }
  }
  // Assume cyclic values are equal.
  var stacked = stack.get(object);
  if (stacked && stack.get(other)) {
    return stacked == other;
  }
  var result = true;
  stack.set(object, other);
  stack.set(other, object);

  var skipCtor = isPartial;
  while (++index < objLength) {
    key = objProps[index];
    var objValue = object[key],
        othValue = other[key];

    if (customizer) {
      var compared = isPartial ? customizer(othValue, objValue, key, other, object, stack) : customizer(objValue, othValue, key, object, other, stack);
    }
    // Recursively compare objects (susceptible to call stack limits).
    if (!(compared === undefined ? objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack) : compared)) {
      result = false;
      break;
    }
    skipCtor || (skipCtor = key == 'constructor');
  }
  if (result && !skipCtor) {
    var objCtor = object.constructor,
        othCtor = other.constructor;

    // Non `Object` object instances with different constructors are not equal.
    if (objCtor != othCtor && 'constructor' in object && 'constructor' in other && !(typeof objCtor == 'function' && objCtor instanceof objCtor && typeof othCtor == 'function' && othCtor instanceof othCtor)) {
      result = false;
    }
  }
  stack['delete'](object);
  stack['delete'](other);
  return result;
}

/**
 * Creates an array of own enumerable property names and symbols of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names and symbols.
 */
function getAllKeys(object) {
  return baseGetAllKeys(object, keys, getSymbols);
}

/**
 * Gets the data for `map`.
 *
 * @private
 * @param {Object} map The map to query.
 * @param {string} key The reference key.
 * @returns {*} Returns the map data.
 */
function getMapData(map, key) {
  var data = map.__data__;
  return isKeyable(key) ? data[typeof key == 'string' ? 'string' : 'hash'] : data.map;
}

/**
 * Gets the native function at `key` of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {string} key The key of the method to get.
 * @returns {*} Returns the function if it's native, else `undefined`.
 */
function getNative(object, key) {
  var value = getValue(object, key);
  return baseIsNative(value) ? value : undefined;
}

/**
 * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the raw `toStringTag`.
 */
function getRawTag(value) {
  var isOwn = hasOwnProperty.call(value, symToStringTag),
      tag = value[symToStringTag];

  try {
    value[symToStringTag] = undefined;
    var unmasked = true;
  } catch (e) {}

  var result = nativeObjectToString.call(value);
  if (unmasked) {
    if (isOwn) {
      value[symToStringTag] = tag;
    } else {
      delete value[symToStringTag];
    }
  }
  return result;
}

/**
 * Creates an array of the own enumerable symbols of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of symbols.
 */
var getSymbols = !nativeGetSymbols ? stubArray : function (object) {
  if (object == null) {
    return [];
  }
  object = Object(object);
  return arrayFilter(nativeGetSymbols(object), function (symbol) {
    return propertyIsEnumerable.call(object, symbol);
  });
};

/**
 * Gets the `toStringTag` of `value`.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the `toStringTag`.
 */
var getTag = baseGetTag;

// Fallback for data views, maps, sets, and weak maps in IE 11 and promises in Node.js < 6.
if (DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag || Map && getTag(new Map()) != mapTag || Promise && getTag(Promise.resolve()) != promiseTag || Set && getTag(new Set()) != setTag || WeakMap && getTag(new WeakMap()) != weakMapTag) {
  getTag = function (value) {
    var result = baseGetTag(value),
        Ctor = result == objectTag ? value.constructor : undefined,
        ctorString = Ctor ? toSource(Ctor) : '';

    if (ctorString) {
      switch (ctorString) {
        case dataViewCtorString:
          return dataViewTag;
        case mapCtorString:
          return mapTag;
        case promiseCtorString:
          return promiseTag;
        case setCtorString:
          return setTag;
        case weakMapCtorString:
          return weakMapTag;
      }
    }
    return result;
  };
}

/**
 * Checks if `value` is a valid array-like index.
 *
 * @private
 * @param {*} value The value to check.
 * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
 * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
 */
function isIndex(value, length) {
  length = length == null ? MAX_SAFE_INTEGER : length;
  return !!length && (typeof value == 'number' || reIsUint.test(value)) && value > -1 && value % 1 == 0 && value < length;
}

/**
 * Checks if `value` is suitable for use as unique object key.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is suitable, else `false`.
 */
function isKeyable(value) {
  var type = typeof value;
  return type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean' ? value !== '__proto__' : value === null;
}

/**
 * Checks if `func` has its source masked.
 *
 * @private
 * @param {Function} func The function to check.
 * @returns {boolean} Returns `true` if `func` is masked, else `false`.
 */
function isMasked(func) {
  return !!maskSrcKey && maskSrcKey in func;
}

/**
 * Checks if `value` is likely a prototype object.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.
 */
function isPrototype(value) {
  var Ctor = value && value.constructor,
      proto = typeof Ctor == 'function' && Ctor.prototype || objectProto;

  return value === proto;
}

/**
 * Converts `value` to a string using `Object.prototype.toString`.
 *
 * @private
 * @param {*} value The value to convert.
 * @returns {string} Returns the converted string.
 */
function objectToString(value) {
  return nativeObjectToString.call(value);
}

/**
 * Converts `func` to its source code.
 *
 * @private
 * @param {Function} func The function to convert.
 * @returns {string} Returns the source code.
 */
function toSource(func) {
  if (func != null) {
    try {
      return funcToString.call(func);
    } catch (e) {}
    try {
      return func + '';
    } catch (e) {}
  }
  return '';
}

/**
 * Performs a
 * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * comparison between two values to determine if they are equivalent.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to compare.
 * @param {*} other The other value to compare.
 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
 * @example
 *
 * var object = { 'a': 1 };
 * var other = { 'a': 1 };
 *
 * _.eq(object, object);
 * // => true
 *
 * _.eq(object, other);
 * // => false
 *
 * _.eq('a', 'a');
 * // => true
 *
 * _.eq('a', Object('a'));
 * // => false
 *
 * _.eq(NaN, NaN);
 * // => true
 */
function eq(value, other) {
  return value === other || value !== value && other !== other;
}

/**
 * Checks if `value` is likely an `arguments` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an `arguments` object,
 *  else `false`.
 * @example
 *
 * _.isArguments(function() { return arguments; }());
 * // => true
 *
 * _.isArguments([1, 2, 3]);
 * // => false
 */
var isArguments = baseIsArguments(function () {
  return arguments;
}()) ? baseIsArguments : function (value) {
  return isObjectLike(value) && hasOwnProperty.call(value, 'callee') && !propertyIsEnumerable.call(value, 'callee');
};

/**
 * Checks if `value` is classified as an `Array` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an array, else `false`.
 * @example
 *
 * _.isArray([1, 2, 3]);
 * // => true
 *
 * _.isArray(document.body.children);
 * // => false
 *
 * _.isArray('abc');
 * // => false
 *
 * _.isArray(_.noop);
 * // => false
 */
var isArray = Array.isArray;

/**
 * Checks if `value` is array-like. A value is considered array-like if it's
 * not a function and has a `value.length` that's an integer greater than or
 * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
 * @example
 *
 * _.isArrayLike([1, 2, 3]);
 * // => true
 *
 * _.isArrayLike(document.body.children);
 * // => true
 *
 * _.isArrayLike('abc');
 * // => true
 *
 * _.isArrayLike(_.noop);
 * // => false
 */
function isArrayLike(value) {
  return value != null && isLength(value.length) && !isFunction(value);
}

/**
 * Checks if `value` is a buffer.
 *
 * @static
 * @memberOf _
 * @since 4.3.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a buffer, else `false`.
 * @example
 *
 * _.isBuffer(new Buffer(2));
 * // => true
 *
 * _.isBuffer(new Uint8Array(2));
 * // => false
 */
var isBuffer = nativeIsBuffer || stubFalse;

/**
 * Performs a deep comparison between two values to determine if they are
 * equivalent.
 *
 * **Note:** This method supports comparing arrays, array buffers, booleans,
 * date objects, error objects, maps, numbers, `Object` objects, regexes,
 * sets, strings, symbols, and typed arrays. `Object` objects are compared
 * by their own, not inherited, enumerable properties. Functions and DOM
 * nodes are compared by strict equality, i.e. `===`.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to compare.
 * @param {*} other The other value to compare.
 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
 * @example
 *
 * var object = { 'a': 1 };
 * var other = { 'a': 1 };
 *
 * _.isEqual(object, other);
 * // => true
 *
 * object === other;
 * // => false
 */
function isEqual(value, other) {
  return baseIsEqual(value, other);
}

/**
 * Checks if `value` is classified as a `Function` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a function, else `false`.
 * @example
 *
 * _.isFunction(_);
 * // => true
 *
 * _.isFunction(/abc/);
 * // => false
 */
function isFunction(value) {
  if (!isObject(value)) {
    return false;
  }
  // The use of `Object#toString` avoids issues with the `typeof` operator
  // in Safari 9 which returns 'object' for typed arrays and other constructors.
  var tag = baseGetTag(value);
  return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
}

/**
 * Checks if `value` is a valid array-like length.
 *
 * **Note:** This method is loosely based on
 * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
 * @example
 *
 * _.isLength(3);
 * // => true
 *
 * _.isLength(Number.MIN_VALUE);
 * // => false
 *
 * _.isLength(Infinity);
 * // => false
 *
 * _.isLength('3');
 * // => false
 */
function isLength(value) {
  return typeof value == 'number' && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
}

/**
 * Checks if `value` is the
 * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
 * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
 * @example
 *
 * _.isObject({});
 * // => true
 *
 * _.isObject([1, 2, 3]);
 * // => true
 *
 * _.isObject(_.noop);
 * // => true
 *
 * _.isObject(null);
 * // => false
 */
function isObject(value) {
  var type = typeof value;
  return value != null && (type == 'object' || type == 'function');
}

/**
 * Checks if `value` is object-like. A value is object-like if it's not `null`
 * and has a `typeof` result of "object".
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
 * @example
 *
 * _.isObjectLike({});
 * // => true
 *
 * _.isObjectLike([1, 2, 3]);
 * // => true
 *
 * _.isObjectLike(_.noop);
 * // => false
 *
 * _.isObjectLike(null);
 * // => false
 */
function isObjectLike(value) {
  return value != null && typeof value == 'object';
}

/**
 * Checks if `value` is classified as a typed array.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
 * @example
 *
 * _.isTypedArray(new Uint8Array);
 * // => true
 *
 * _.isTypedArray([]);
 * // => false
 */
var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;

/**
 * Creates an array of the own enumerable property names of `object`.
 *
 * **Note:** Non-object values are coerced to objects. See the
 * [ES spec](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
 * for more details.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Object
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 *   this.b = 2;
 * }
 *
 * Foo.prototype.c = 3;
 *
 * _.keys(new Foo);
 * // => ['a', 'b'] (iteration order is not guaranteed)
 *
 * _.keys('hi');
 * // => ['0', '1']
 */
function keys(object) {
  return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
}

/**
 * This method returns a new empty array.
 *
 * @static
 * @memberOf _
 * @since 4.13.0
 * @category Util
 * @returns {Array} Returns the new empty array.
 * @example
 *
 * var arrays = _.times(2, _.stubArray);
 *
 * console.log(arrays);
 * // => [[], []]
 *
 * console.log(arrays[0] === arrays[1]);
 * // => false
 */
function stubArray() {
  return [];
}

/**
 * This method returns `false`.
 *
 * @static
 * @memberOf _
 * @since 4.13.0
 * @category Util
 * @returns {boolean} Returns `false`.
 * @example
 *
 * _.times(2, _.stubFalse);
 * // => [false, false]
 */
function stubFalse() {
  return false;
}

module.exports = isEqual;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(177)(module)))

/***/ }),
/* 177 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = function (module) {
	if (!module.webpackPolyfill) {
		module.deprecate = function () {};
		module.paths = [];
		// module.parent = undefined by default
		if (!module.children) module.children = [];
		Object.defineProperty(module, "loaded", {
			enumerable: true,
			get: function () {
				return module.l;
			}
		});
		Object.defineProperty(module, "id", {
			enumerable: true,
			get: function () {
				return module.i;
			}
		});
		module.webpackPolyfill = 1;
	}
	return module;
};

/***/ }),
/* 178 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.executeTasks = executeTasks;
exports._executeTasks = _executeTasks;
exports.checkIsRangesSupported = checkIsRangesSupported;

var _builderUtilRuntime;

function _load_builderUtilRuntime() {
    return _builderUtilRuntime = __webpack_require__(3);
}

var _DataSplitter;

function _load_DataSplitter() {
    return _DataSplitter = __webpack_require__(66);
}

var _downloadPlanBuilder;

function _load_downloadPlanBuilder() {
    return _downloadPlanBuilder = __webpack_require__(35);
}

function executeTasks(differentialDownloader, tasks, out, oldFileFd, reject) {
    const w = taskOffset => {
        if (taskOffset >= tasks.length) {
            if (differentialDownloader.fileMetadataBuffer != null) {
                out.write(differentialDownloader.fileMetadataBuffer);
            }
            out.end();
            return;
        }
        const nextOffset = taskOffset + (differentialDownloader.options.useMultipleRangeRequest === false ? 1 : 1000);
        _executeTasks(differentialDownloader, {
            tasks,
            start: taskOffset,
            end: Math.min(tasks.length, nextOffset),
            oldFileFd
        }, out, () => w(nextOffset), reject);
    };
    return w;
}
function _executeTasks(differentialDownloader, options, out, resolve, reject) {
    let ranges = "bytes=";
    let partCount = 0;
    const partIndexToTaskIndex = new Map();
    const partIndexToLength = [];
    for (let i = options.start; i < options.end; i++) {
        const task = options.tasks[i];
        if (task.kind === (_downloadPlanBuilder || _load_downloadPlanBuilder()).OperationKind.DOWNLOAD) {
            ranges += `${task.start}-${task.end - 1}, `;
            partIndexToTaskIndex.set(partCount, i);
            partCount++;
            partIndexToLength.push(task.end - task.start);
        }
    }
    if (partCount <= 1) {
        // the only remote range - copy
        const w = index => {
            if (index >= options.end) {
                resolve();
                return;
            }
            const task = options.tasks[index++];
            if (task.kind === (_downloadPlanBuilder || _load_downloadPlanBuilder()).OperationKind.COPY) {
                (0, (_DataSplitter || _load_DataSplitter()).copyData)(task, out, options.oldFileFd, reject, () => w(index));
            } else {
                const requestOptions = differentialDownloader.createRequestOptions("get");
                requestOptions.headers.Range = `bytes=${task.start}-${task.end - 1}`;
                const request = differentialDownloader.httpExecutor.doRequest(requestOptions, response => {
                    if (!checkIsRangesSupported(response, reject)) {
                        return;
                    }
                    response.pipe(out, {
                        end: false
                    });
                    response.once("end", () => w(index));
                });
                differentialDownloader.httpExecutor.addErrorAndTimeoutHandlers(request, reject);
                request.end();
            }
        };
        w(options.start);
        return;
    }
    const requestOptions = differentialDownloader.createRequestOptions("get");
    requestOptions.headers.Range = ranges.substring(0, ranges.length - 2);
    const request = differentialDownloader.httpExecutor.doRequest(requestOptions, response => {
        if (!checkIsRangesSupported(response, reject)) {
            return;
        }
        const contentType = (0, (_builderUtilRuntime || _load_builderUtilRuntime()).safeGetHeader)(response, "content-type");
        const m = /^multipart\/.+?(?:; boundary=(?:(?:"(.+)")|(?:([^\s]+))))$/i.exec(contentType);
        if (m == null) {
            reject(new Error(`Content-Type "multipart/byteranges" is expected, but got "${contentType}"`));
            return;
        }
        const dicer = new (_DataSplitter || _load_DataSplitter()).DataSplitter(out, options, partIndexToTaskIndex, m[1] || m[2], partIndexToLength, resolve);
        dicer.on("error", reject);
        response.pipe(dicer);
    });
    differentialDownloader.httpExecutor.addErrorAndTimeoutHandlers(request, reject);
    request.end();
}
function checkIsRangesSupported(response, reject) {
    // Electron net handles redirects automatically, our NodeJS test server doesn't use redirects - so, we don't check 3xx codes.
    if (response.statusCode >= 400) {
        reject((0, (_builderUtilRuntime || _load_builderUtilRuntime()).createHttpError)(response));
        return false;
    }
    if (response.statusCode !== 206) {
        const acceptRanges = (0, (_builderUtilRuntime || _load_builderUtilRuntime()).safeGetHeader)(response, "accept-ranges");
        if (acceptRanges == null || acceptRanges === "none") {
            reject(new Error("Server doesn't support Accept-Ranges"));
            return false;
        }
    }
    return true;
}
//# sourceMappingURL=multipleRangeDownloader.js.map

/***/ }),
/* 179 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.GenericDifferentialDownloader = undefined;

var _bluebirdLst;

function _load_bluebirdLst() {
    return _bluebirdLst = __webpack_require__(2);
}

var _blockMapApi;

function _load_blockMapApi() {
    return _blockMapApi = __webpack_require__(63);
}

var _fsExtraP;

function _load_fsExtraP() {
    return _fsExtraP = __webpack_require__(9);
}

var _path = _interopRequireWildcard(__webpack_require__(0));

var _DifferentialDownloader;

function _load_DifferentialDownloader() {
    return _DifferentialDownloader = __webpack_require__(65);
}

function _interopRequireWildcard(obj) {
    if (obj && obj.__esModule) {
        return obj;
    } else {
        var newObj = {};if (obj != null) {
            for (var key in obj) {
                if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key];
            }
        }newObj.default = obj;return newObj;
    }
}

class GenericDifferentialDownloader extends (_DifferentialDownloader || _load_DifferentialDownloader()).DifferentialDownloader {
    download(newBlockMap) {
        var _this = this;

        return (0, (_bluebirdLst || _load_bluebirdLst()).coroutine)(function* () {
            yield _this.doDownload((yield (0, (_fsExtraP || _load_fsExtraP()).readJson)(_path.join(process.resourcesPath, "..", (_blockMapApi || _load_blockMapApi()).BLOCK_MAP_FILE_NAME))), newBlockMap);
        })();
    }
}
exports.GenericDifferentialDownloader = GenericDifferentialDownloader; //# sourceMappingURL=GenericDifferentialDownloader.js.map

/***/ }),
/* 180 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.verifySignature = verifySignature;

var _bluebirdLst;

function _load_bluebirdLst() {
    return _bluebirdLst = _interopRequireDefault(__webpack_require__(2));
}

var _builderUtilRuntime;

function _load_builderUtilRuntime() {
    return _builderUtilRuntime = __webpack_require__(3);
}

var _child_process;

function _load_child_process() {
    return _child_process = __webpack_require__(34);
}

var _os;

function _load_os() {
    return _os = _interopRequireWildcard(__webpack_require__(15));
}

function _interopRequireWildcard(obj) {
    if (obj && obj.__esModule) {
        return obj;
    } else {
        var newObj = {};if (obj != null) {
            for (var key in obj) {
                if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key];
            }
        }newObj.default = obj;return newObj;
    }
}

function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
}

// $certificateInfo = (Get-AuthenticodeSignature 'xxx\yyy.exe'
// | where {$_.Status.Equals([System.Management.Automation.SignatureStatus]::Valid) -and $_.SignerCertificate.Subject.Contains("CN=siemens.com")})
// | Out-String ; if ($certificateInfo) { exit 0 } else { exit 1 }
function verifySignature(publisherNames, tempUpdateFile, logger) {
    return new (_bluebirdLst || _load_bluebirdLst()).default((resolve, reject) => {
        // https://github.com/electron-userland/electron-builder/issues/2421
        (0, (_child_process || _load_child_process()).execFile)("powershell.exe", [`Get-AuthenticodeSignature '${tempUpdateFile}' | ConvertTo-Json -Compress`], {
            timeout: 30 * 1000
        }, (error, stdout, stderr) => {
            if (error != null || stderr) {
                if (isOldWin6()) {
                    logger.warn(`Cannot execute Get-AuthenticodeSignature: ${error || stderr}. Ignoring signature validation due to unsupported powershell version. Please upgrade to powershell 3 or higher.`);
                    resolve(null);
                    return;
                }
                try {
                    (0, (_child_process || _load_child_process()).execFileSync)("powershell.exe", ["ConvertTo-Json test"], { timeout: 10 * 1000 });
                } catch (testError) {
                    logger.warn(`Cannot execute ConvertTo-Json: ${testError.message}. Ignoring signature validation due to unsupported powershell version. Please upgrade to powershell 3 or higher.`);
                    resolve(null);
                    return;
                }
                if (error != null) {
                    reject(error);
                    return;
                }
                if (stderr) {
                    reject(new Error(`Cannot execute Get-AuthenticodeSignature: ${stderr}`));
                    return;
                }
            }
            const data = JSON.parse(stdout);
            delete data.PrivateKey;
            delete data.IsOSBinary;
            delete data.SignatureType;
            const signerCertificate = data.SignerCertificate;
            if (signerCertificate != null) {
                delete signerCertificate.Archived;
                delete signerCertificate.Extensions;
                delete signerCertificate.Handle;
                delete signerCertificate.HasPrivateKey;
                // duplicates data.SignerCertificate (contains RawData)
                delete signerCertificate.SubjectName;
            }
            delete data.Path;
            if (data.Status === 0) {
                const name = (0, (_builderUtilRuntime || _load_builderUtilRuntime()).parseDn)(data.SignerCertificate.Subject).get("CN");
                if (publisherNames.includes(name)) {
                    resolve(null);
                    return;
                }
            }
            const result = `publisherNames: ${publisherNames.join(" | ")}, raw info: ` + JSON.stringify(data, (name, value) => name === "RawData" ? undefined : value, 2);
            logger.info(`Sign verification failed, installer signed with incorrect certificate: ${result}`);
            resolve(result);
        });
    });
}
function isOldWin6() {
    const winVersion = (_os || _load_os()).release();
    return winVersion.startsWith("6.") && !winVersion.startsWith("6.3");
}
//# sourceMappingURL=windowsExecutableCodeSignatureVerifier.js.map

/***/ }),
/* 181 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.MacUpdater = undefined;

var _bluebirdLst;

function _load_bluebirdLst() {
    return _bluebirdLst = __webpack_require__(2);
}

var _bluebirdLst2;

function _load_bluebirdLst2() {
    return _bluebirdLst2 = _interopRequireDefault(__webpack_require__(2));
}

var _builderUtilRuntime;

function _load_builderUtilRuntime() {
    return _builderUtilRuntime = __webpack_require__(3);
}

var _http;

function _load_http() {
    return _http = __webpack_require__(67);
}

var _AppUpdater;

function _load_AppUpdater() {
    return _AppUpdater = __webpack_require__(27);
}

var _main;

function _load_main() {
    return _main = __webpack_require__(8);
}

var _Provider;

function _load_Provider() {
    return _Provider = __webpack_require__(14);
}

function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
}

class MacUpdater extends (_AppUpdater || _load_AppUpdater()).AppUpdater {
    constructor(options) {
        super(options);
        this.nativeUpdater = __webpack_require__(10).autoUpdater;
        this.nativeUpdater.on("error", it => {
            this._logger.warn(it);
            this.emit("error", it);
        });
        this.nativeUpdater.on("update-downloaded", () => {
            this._logger.info(`New version ${this.updateInfo.version} has been downloaded`);
            this.emit((_main || _load_main()).UPDATE_DOWNLOADED, this.updateInfo);
        });
    }
    doDownloadUpdate(updateInfo, cancellationToken) {
        var _this = this;

        return (0, (_bluebirdLst || _load_bluebirdLst()).coroutine)(function* () {
            const files = (yield _this.provider).resolveFiles(updateInfo);
            const zipFileInfo = (0, (_Provider || _load_Provider()).findFile)(files, "zip", ["pkg", "dmg"]);
            if (zipFileInfo == null) {
                throw (0, (_builderUtilRuntime || _load_builderUtilRuntime()).newError)(`ZIP file not provided: ${(0, (_builderUtilRuntime || _load_builderUtilRuntime()).safeStringifyJson)(files)}`, "ERR_UPDATER_ZIP_FILE_NOT_FOUND");
            }
            const server = (0, (_http || _load_http()).createServer)();
            server.on("close", function () {
                _this._logger.info(`Proxy server for native Squirrel.Mac is closed (was started to download ${zipFileInfo.url.href})`);
            });
            function getServerUrl() {
                const address = server.address();
                return `http://${address.address}:${address.port}`;
            }
            const requestHeaders = yield _this.computeRequestHeaders();
            return yield new (_bluebirdLst2 || _load_bluebirdLst2()).default(function (resolve, reject) {
                server.on("request", function (request, response) {
                    const requestUrl = request.url;
                    _this._logger.info(`${requestUrl} requested`);
                    if (requestUrl === "/") {
                        const data = Buffer.from(`{ "url": "${getServerUrl()}/app.zip" }`);
                        response.writeHead(200, { "Content-Type": "application/json", "Content-Length": data.length });
                        response.end(data);
                    } else if (requestUrl.startsWith("/app.zip")) {
                        let errorOccurred = false;
                        response.on("finish", function () {
                            try {
                                setImmediate(function () {
                                    return server.close();
                                });
                            } finally {
                                if (!errorOccurred) {
                                    _this.nativeUpdater.removeListener("error", reject);
                                    resolve([]);
                                }
                            }
                        });
                        _this.doProxyUpdateFile(response, zipFileInfo.url.href, requestHeaders, zipFileInfo.info.sha512, cancellationToken, function (error) {
                            errorOccurred = true;
                            try {
                                response.writeHead(500);
                                response.end();
                            } finally {
                                _this.nativeUpdater.removeListener("error", reject);
                                reject(new Error(`Cannot download "${zipFileInfo.url}": ${error}`));
                            }
                        });
                    } else {
                        _this._logger.warn(`${requestUrl} requested, but not supported`);
                        response.writeHead(404);
                        response.end();
                    }
                });
                server.listen(0, "127.0.0.1", 16, function () {
                    _this.nativeUpdater.setFeedURL(`${getServerUrl()}`, { "Cache-Control": "no-cache" });
                    _this.nativeUpdater.once("error", reject);
                    _this.nativeUpdater.checkForUpdates();
                });
            });
        })();
    }
    doProxyUpdateFile(nativeResponse, url, headers, sha512, cancellationToken, errorHandler) {
        const downloadRequest = this.httpExecutor.doRequest((0, (_builderUtilRuntime || _load_builderUtilRuntime()).configureRequestOptionsFromUrl)(url, { headers }), downloadResponse => {
            if (downloadResponse.statusCode >= 400) {
                try {
                    nativeResponse.writeHead(404);
                    nativeResponse.end();
                } finally {
                    errorHandler(new Error(`Cannot download "${url}", status ${downloadResponse.statusCode}: ${downloadResponse.statusMessage}`));
                }
                return;
            }
            // in tests Electron NET Api is not used, so, we have to handle redirect.
            const redirectUrl = (0, (_builderUtilRuntime || _load_builderUtilRuntime()).safeGetHeader)(downloadResponse, "location");
            if (redirectUrl != null) {
                this.doProxyUpdateFile(nativeResponse, redirectUrl, headers, sha512, cancellationToken, errorHandler);
                return;
            }
            const nativeHeaders = { "Content-Type": "application/zip" };
            const streams = [];
            const downloadListenerCount = this.listenerCount((_main || _load_main()).DOWNLOAD_PROGRESS);
            this._logger.info(`${(_main || _load_main()).DOWNLOAD_PROGRESS} listener count: ${downloadListenerCount}`);
            if (downloadListenerCount > 0) {
                const contentLength = (0, (_builderUtilRuntime || _load_builderUtilRuntime()).safeGetHeader)(downloadResponse, "content-length");
                this._logger.info(`contentLength: ${contentLength}`);
                if (contentLength != null) {
                    nativeHeaders["Content-Length"] = contentLength;
                    streams.push(new (_builderUtilRuntime || _load_builderUtilRuntime()).ProgressCallbackTransform(parseInt(contentLength, 10), cancellationToken, it => this.emit((_main || _load_main()).DOWNLOAD_PROGRESS, it)));
                }
            }
            nativeResponse.writeHead(200, nativeHeaders);
            // for mac only sha512 is produced (sha256 is published for windows only to preserve backward compatibility)
            if (sha512 != null) {
                // "hex" to easy migrate to new base64 encoded hash (we already produces latest-mac.yml with hex encoded hash)
                streams.push(new (_builderUtilRuntime || _load_builderUtilRuntime()).DigestTransform(sha512, "sha512", sha512.length === 128 && !sha512.includes("+") && !sha512.includes("Z") && !sha512.includes("=") ? "hex" : "base64"));
            }
            streams.push(nativeResponse);
            let lastStream = downloadResponse;
            for (const stream of streams) {
                stream.on("error", errorHandler);
                lastStream = lastStream.pipe(stream);
            }
        });
        downloadRequest.on("redirect", (statusCode, method, redirectUrl) => {
            if (headers.Authorization != null && headers.Authorization.startsWith("token")) {
                const parsedNewUrl = new URL(redirectUrl);
                if (parsedNewUrl.hostname.endsWith(".amazonaws.com")) {
                    delete headers.Authorization;
                }
            }
            this.doProxyUpdateFile(nativeResponse, redirectUrl, headers, sha512, cancellationToken, errorHandler);
        });
        downloadRequest.on("error", errorHandler);
        downloadRequest.end();
    }
    quitAndInstall() {
        this.nativeUpdater.quitAndInstall();
    }
}
exports.MacUpdater = MacUpdater; //# sourceMappingURL=MacUpdater.js.map

/***/ }),
/* 182 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.AppImageUpdater = undefined;

var _bluebirdLst;

function _load_bluebirdLst() {
    return _bluebirdLst = __webpack_require__(2);
}

var _bluebirdLst2;

function _load_bluebirdLst2() {
    return _bluebirdLst2 = _interopRequireDefault(__webpack_require__(2));
}

var _builderUtilRuntime;

function _load_builderUtilRuntime() {
    return _builderUtilRuntime = __webpack_require__(3);
}

var _child_process;

function _load_child_process() {
    return _child_process = __webpack_require__(34);
}

var _electronIsDev;

function _load_electronIsDev() {
    return _electronIsDev = _interopRequireDefault(__webpack_require__(26));
}

var _fsExtraP;

function _load_fsExtraP() {
    return _fsExtraP = __webpack_require__(9);
}

var _path = _interopRequireWildcard(__webpack_require__(0));

__webpack_require__(33);

var _BaseUpdater;

function _load_BaseUpdater() {
    return _BaseUpdater = __webpack_require__(61);
}

var _FileWithEmbeddedBlockMapDifferentialDownloader;

function _load_FileWithEmbeddedBlockMapDifferentialDownloader() {
    return _FileWithEmbeddedBlockMapDifferentialDownloader = __webpack_require__(62);
}

var _main;

function _load_main() {
    return _main = __webpack_require__(8);
}

var _Provider;

function _load_Provider() {
    return _Provider = __webpack_require__(14);
}

function _interopRequireWildcard(obj) {
    if (obj && obj.__esModule) {
        return obj;
    } else {
        var newObj = {};if (obj != null) {
            for (var key in obj) {
                if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key];
            }
        }newObj.default = obj;return newObj;
    }
}

function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
}

class AppImageUpdater extends (_BaseUpdater || _load_BaseUpdater()).BaseUpdater {
    constructor(options, app) {
        super(options, app);
    }
    checkForUpdatesAndNotify() {
        if ((_electronIsDev || _load_electronIsDev()).default) {
            return (_bluebirdLst2 || _load_bluebirdLst2()).default.resolve(null);
        }
        if (process.env.APPIMAGE == null) {
            this._logger.warn("APPIMAGE env is not defined, current application is not an AppImage");
            return (_bluebirdLst2 || _load_bluebirdLst2()).default.resolve(null);
        }
        return super.checkForUpdatesAndNotify();
    }
    /*** @private */
    doDownloadUpdate(updateInfo, cancellationToken) {
        var _this = this;

        return (0, (_bluebirdLst || _load_bluebirdLst()).coroutine)(function* () {
            const provider = yield _this.provider;
            const fileInfo = (0, (_Provider || _load_Provider()).findFile)(provider.resolveFiles(updateInfo), "AppImage");
            const requestHeaders = yield _this.computeRequestHeaders();
            const downloadOptions = {
                skipDirCreation: true,
                headers: requestHeaders,
                cancellationToken,
                sha512: fileInfo.info.sha512
            };
            let installerPath = _this.downloadedUpdateHelper.getDownloadedFile(updateInfo, fileInfo);
            if (installerPath != null) {
                return [installerPath];
            }
            yield _this.executeDownload(downloadOptions, fileInfo, (() => {
                var _ref = (0, (_bluebirdLst || _load_bluebirdLst()).coroutine)(function* (tempDir, destinationFile) {
                    installerPath = destinationFile;
                    const oldFile = process.env.APPIMAGE;
                    if (oldFile == null) {
                        throw (0, (_builderUtilRuntime || _load_builderUtilRuntime()).newError)("APPIMAGE env is not defined", "ERR_UPDATER_OLD_FILE_NOT_FOUND");
                    }
                    let isDownloadFull = false;
                    try {
                        yield new (_FileWithEmbeddedBlockMapDifferentialDownloader || _load_FileWithEmbeddedBlockMapDifferentialDownloader()).FileWithEmbeddedBlockMapDifferentialDownloader(fileInfo.info, _this.httpExecutor, {
                            newUrl: fileInfo.url.href,
                            oldFile,
                            logger: _this._logger,
                            newFile: installerPath,
                            useMultipleRangeRequest: provider.useMultipleRangeRequest,
                            requestHeaders
                        }).download();
                    } catch (e) {
                        _this._logger.error(`Cannot download differentially, fallback to full download: ${e.stack || e}`);
                        // during test (developer machine mac) we must throw error
                        isDownloadFull = process.platform === "linux";
                    }
                    if (isDownloadFull) {
                        yield _this.httpExecutor.download(fileInfo.url.href, installerPath, downloadOptions);
                    }
                    yield (0, (_fsExtraP || _load_fsExtraP()).chmod)(installerPath, 0o755);
                });

                return function (_x, _x2) {
                    return _ref.apply(this, arguments);
                };
            })());
            _this.downloadedUpdateHelper.setDownloadedFile(installerPath, null, updateInfo, fileInfo);
            _this.addQuitHandler();
            _this.emit((_main || _load_main()).UPDATE_DOWNLOADED, _this.updateInfo);
            return [installerPath];
        })();
    }
    doInstall(installerPath, isSilent, isRunAfter) {
        const appImageFile = process.env.APPIMAGE;
        if (appImageFile == null) {
            throw (0, (_builderUtilRuntime || _load_builderUtilRuntime()).newError)("APPIMAGE env is not defined", "ERR_UPDATER_OLD_FILE_NOT_FOUND");
        }
        // https://stackoverflow.com/a/1712051/1910191
        (0, (_fsExtraP || _load_fsExtraP()).unlinkSync)(appImageFile);
        let destination;
        if (_path.basename(installerPath) === _path.basename(appImageFile)) {
            // no version in the file name, overwrite existing
            destination = appImageFile;
        } else {
            destination = _path.join(_path.dirname(appImageFile), _path.basename(installerPath));
        }
        (0, (_child_process || _load_child_process()).execFileSync)("mv", ["-f", installerPath, destination]);
        const env = Object.assign({}, process.env, { APPIMAGE_SILENT_INSTALL: "true" });
        if (isRunAfter) {
            (0, (_child_process || _load_child_process()).spawn)(destination, [], {
                detached: true,
                stdio: "ignore",
                env
            }).unref();
        } else {
            env.APPIMAGE_EXIT_AFTER_INSTALL = "true";
            (0, (_child_process || _load_child_process()).execFileSync)(destination, [], { env });
        }
        return true;
    }
}
exports.AppImageUpdater = AppImageUpdater; //# sourceMappingURL=AppImageUpdater.js.map

/***/ }),
/* 183 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


if (process.type === 'renderer') {
  module.exports = __webpack_require__(184);
} else {
  module.exports = __webpack_require__(185);
}

/***/ }),
/* 184 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = null;

var ipcRenderer;
try {
  ipcRenderer = __webpack_require__(10).ipcRenderer;
} catch (e) {
  ipcRenderer = null;
}

var originalConsole = __webpack_require__(68);

if (ipcRenderer) {
  module.exports = {
    error: log.bind(null, 'error'),
    warn: log.bind(null, 'warn'),
    info: log.bind(null, 'info'),
    verbose: log.bind(null, 'verbose'),
    debug: log.bind(null, 'debug'),
    silly: log.bind(null, 'silly'),
    log: log.bind(null, 'info')
  };

  module.exports.default = module.exports;

  ipcRenderer.on('__ELECTRON_LOG_RENDERER__', function (event, level, text) {
    if (level === 'verbose') {
      level = 'log';
    } else if (level === 'silly') {
      level = 'debug';
    }

    originalConsole[level].call(originalConsole.context, text);
  });
}

function log() {
  var data = Array.prototype.slice.call(arguments);

  data = data.map(function (obj) {
    if (obj instanceof Error) {
      obj = obj.stack || obj;
    }

    return obj;
  });

  ipcRenderer.send('__ELECTRON_LOG__', data);
}

/***/ }),
/* 185 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var electron;
try {
  electron = __webpack_require__(10);
} catch (e) {
  electron = null;
}

var log = __webpack_require__(186);
var transportConsole = __webpack_require__(36);
var transportFile = __webpack_require__(187);
var transportLogS = __webpack_require__(190);
var transportRendererConsole = __webpack_require__(192);

var transports = {
  console: transportConsole,
  file: transportFile,
  logS: transportLogS,
  rendererConsole: transportRendererConsole
};

module.exports = {
  transports: transports,

  error: log.bind(null, transports, 'error'),
  warn: log.bind(null, transports, 'warn'),
  info: log.bind(null, transports, 'info'),
  verbose: log.bind(null, transports, 'verbose'),
  debug: log.bind(null, transports, 'debug'),
  silly: log.bind(null, transports, 'silly'),
  log: log.bind(null, transports, 'info')
};

module.exports.default = module.exports;

if (electron && electron.ipcMain) {
  electron.ipcMain.on('__ELECTRON_LOG__', onRendererLog);
  var appName = electron.app.getName();
  if (appName !== 'Electron') {
    transportFile.appName = appName;
  }
}

function onRendererLog(event, data) {
  if (Array.isArray(data)) {
    data.unshift(transports);
    log.apply(null, data);
  }
}

/***/ }),
/* 186 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// jshint -W040


var LEVELS = ['error', 'warn', 'info', 'verbose', 'debug', 'silly'];

module.exports = log;

function log(transports, level, text) {
  var data = Array.prototype.slice.call(arguments, 2);

  var msg = {
    data: data,
    date: new Date(),
    level: level
  };

  for (var i in transports) {
    // jshint -W089
    if (!transports.hasOwnProperty(i) || typeof transports[i] !== 'function') {
      continue;
    }

    var transport = transports[i];

    if (transport === false || !compareLevels(transport.level, level)) {
      continue;
    }

    if (transport.level === false) continue;

    transport.call(null, msg);
  }
}

function compareLevels(passLevel, checkLevel) {
  var pass = LEVELS.indexOf(passLevel);
  var check = LEVELS.indexOf(checkLevel);
  if (check === -1 || pass === -1) {
    return true;
  }
  return check <= pass;
}

/***/ }),
/* 187 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var fs = __webpack_require__(12);
var EOL = __webpack_require__(15).EOL;
var format = __webpack_require__(37);
var consoleTransport = __webpack_require__(36);
var findLogPath = __webpack_require__(188);

transport.findLogPath = findLogPath;
transport.format = '[{y}-{m}-{d} {h}:{i}:{s}.{ms}] [{level}] {text}';
transport.level = 'warn';
transport.maxSize = 1024 * 1024;
transport.streamConfig = undefined;

module.exports = transport;

function transport(msg) {
  var text = format.format(msg, transport.format) + EOL;

  if (transport.stream === undefined) {
    initSteamConfig();
    openStream();
  }

  if (transport.level === false) {
    return;
  }

  var needLogRotation = transport.maxSize > 0 && getStreamSize(transport.stream) > transport.maxSize;

  if (needLogRotation) {
    archiveLog(transport.stream);
    openStream();
  }

  transport.stream.write(text);
}

function initSteamConfig() {
  transport.file = transport.file || findLogPath(transport.appName);

  if (!transport.file) {
    transport.level = false;
    logConsole('Could not set a log file');
  }
}

function openStream() {
  if (transport.level === false) {
    return;
  }

  transport.stream = fs.createWriteStream(transport.file, transport.streamConfig || { flags: 'a' });
}

function getStreamSize(stream) {
  if (!stream) {
    return 0;
  }

  if (stream.logSizeAtStart === undefined) {
    try {
      stream.logSizeAtStart = fs.statSync(stream.path).size;
    } catch (e) {
      stream.logSizeAtStart = 0;
    }
  }

  return stream.logSizeAtStart + stream.bytesWritten;
}

function archiveLog(stream) {
  if (stream.end) {
    stream.end();
  }

  try {
    fs.renameSync(stream.path, stream.path.replace(/log$/, 'old.log'));
  } catch (e) {
    logConsole('Could not rotate log', e);
  }
}

function logConsole(message, error) {
  var data = ['electron-log.transports.file: ' + message];

  if (error) {
    data.push(error);
  }

  consoleTransport({ data: data, date: new Date(), level: 'warn' });
}

/***/ }),
/* 188 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var fs = __webpack_require__(12);
var path = __webpack_require__(0);
var os = __webpack_require__(15);
var getAppName = __webpack_require__(189);

module.exports = findLogPath;

/**
 * Try to determine a platform-specific path where can write logs
 * @param {string} [appName] Used to determine the last part of a log path
 * @return {string|boolean}
 */
function findLogPath(appName) {
  appName = appName || getAppName();
  if (!appName) {
    return false;
  }

  var homeDir = os.homedir ? os.homedir() : process.env['HOME'];

  var dir;
  switch (process.platform) {
    case 'linux':
      {
        dir = prepareDir(process.env['XDG_CONFIG_HOME'], appName).or(homeDir, '.config', appName).or(process.env['XDG_DATA_HOME'], appName).or(homeDir, '.local', 'share', appName).result;
        break;
      }

    case 'darwin':
      {
        dir = prepareDir(homeDir, 'Library', 'Logs', appName).or(homeDir, 'Library', 'Application Support', appName).result;
        break;
      }

    case 'win32':
      {
        dir = prepareDir(process.env['APPDATA'], appName).or(homeDir, 'AppData', 'Roaming', appName).result;
        break;
      }
  }

  if (dir) {
    return path.join(dir, 'log.log');
  } else {
    return false;
  }
}

function prepareDir(dirPath) {
  // jshint -W040
  if (!this || this.or !== prepareDir || !this.result) {
    if (!dirPath) {
      return { or: prepareDir };
    }

    //noinspection JSCheckFunctionSignatures
    dirPath = path.join.apply(path, arguments);
    mkDir(dirPath);

    try {
      fs.accessSync(dirPath, fs.W_OK);
    } catch (e) {
      return { or: prepareDir };
    }
  }

  return {
    or: prepareDir,
    result: (this ? this.result : false) || dirPath
  };
}

function mkDir(dirPath, root) {
  var dirs = dirPath.split(path.sep);
  var dir = dirs.shift();
  root = (root || '') + dir + path.sep;

  try {
    fs.mkdirSync(root);
  } catch (e) {
    if (!fs.statSync(root).isDirectory()) {
      throw new Error(e);
    }
  }

  return !dirs.length || mkDir(dirs.join(path.sep), root);
}

/***/ }),
/* 189 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// jshint -W074


/** @name process.resourcesPath */

var fs = __webpack_require__(12);
var path = __webpack_require__(0);
var consoleTransport = __webpack_require__(36);

module.exports = getAppName;

function getAppName() {
  try {
    var name = loadPackageName();
    if (name) {
      return name;
    }
    return warn('electron-log: unable to load the app name from package.json');
  } catch (e) {
    return warn('electron-log: ' + e.message);
  }
}

/**
 * Try to load main app package
 * @throws {Error}
 * @return {Object|null}
 */
function loadPackageName() {
  var packageFile;

  try {
    if (__webpack_require__.c[__webpack_require__.s].filename) {
      packageFile = find(path.dirname(__webpack_require__.c[__webpack_require__.s].filename));
    }
  } catch (e) {}

  if (!packageFile && process.resourcesPath) {
    packageFile = find(path.join(process.resourcesPath, 'app.asar'));
    var electronModule = path.join('node_modules', 'electron', 'package.json');
    if (packageFile && packageFile.indexOf(electronModule) !== -1) {
      packageFile = null;
    }
  }

  if (!packageFile) {
    packageFile = find(process.cwd());
  }

  if (!packageFile) {
    return null;
  }

  var content = fs.readFileSync(packageFile, 'utf-8');
  var packageData = JSON.parse(content);

  //noinspection JSUnresolvedVariable
  return packageData ? packageData.productName || packageData.name : false;
}

function find(root) {
  var file;

  while (!file) {
    var parent;
    file = path.join(root, 'package.json');

    try {
      fs.statSync(file);
    } catch (e) {
      parent = path.resolve(root, '..');
      file = null;
    }

    if (root === parent) {
      break;
    }

    root = parent;
  }

  return file;
}

function warn(message) {
  consoleTransport({
    data: [message],
    date: new Date(),
    level: 'warn'
  });
}

/***/ }),
/* 190 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// jshint -W074, -W089


var http = __webpack_require__(67);
var https = __webpack_require__(191);
var url = __webpack_require__(20);

transport.client = { name: 'electron-application' };
transport.depth = 6;
transport.level = false;
transport.url = null;

module.exports = transport;

function transport(msg) {
  if (!transport.url) return;

  var data = jsonDepth({
    client: transport.client,
    data: msg.data,
    date: msg.date.getTime(),
    level: msg.level
  }, transport.depth + 1);

  post(transport.url, data);
}

function post(serverUrl, data) {
  var urlObject = url.parse(serverUrl);
  var transport = urlObject.protocol === 'https:' ? https : http;

  var body = JSON.stringify(data);

  var options = {
    hostname: urlObject.hostname,
    port: urlObject.port,
    path: urlObject.path,
    method: 'POST',
    headers: {
      'Content-Type': 'application/json',
      'Content-Length': body.length
    }
  };

  var request = transport.request(options);
  request.write(body);
  request.end();
}

function jsonDepth(json, depth) {
  if (depth < 1) {
    if (Array.isArray(json)) return '[array]';
    if (typeof json === 'object') return '[object]';
    return json;
  }

  if (Array.isArray(json)) {
    return json.map(function (child) {
      return jsonDepth(child, depth - 1);
    });
  }

  if (json && typeof json.getMonth === 'function') {
    return json;
  }

  if (json === null) {
    return null;
  }

  if (typeof json === 'object') {
    if (typeof json.toJSON === 'function') {
      json = json.toJSON();
    }

    var newJson = {};
    for (var i in json) {
      //noinspection JSUnfilteredForInLoop
      newJson[i] = jsonDepth(json[i], depth - 1);
    }

    return newJson;
  }

  return json;
}

/***/ }),
/* 191 */
/***/ (function(module, exports) {

module.exports = require("https");

/***/ }),
/* 192 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var BrowserWindow;
try {
  BrowserWindow = __webpack_require__(10).BrowserWindow;
} catch (e) {
  BrowserWindow = null;
}

var format = __webpack_require__(37);

transport.level = BrowserWindow ? 'silly' : false;
transport.format = '[{h}:{i}:{s}.{ms}] {text}';

module.exports = transport;

function transport(msg) {
  if (!BrowserWindow) return;

  var text = format.format(msg, transport.format);
  BrowserWindow.getAllWindows().forEach(function (wnd) {
    wnd.webContents.send('__ELECTRON_LOG_RENDERER__', msg.level, text);
  });
}

/***/ }),
/* 193 */
/***/ (function(module, exports) {

module.exports = {"name":"ELIT","version":"0.3.0","description":"ELIT - Eve Local Intel Tool","main":"dist/main.js","repository":"git@github.com:Squareheads/ELIT.git","author":"Owen Worley","license":"(c) Squareheads LTD 2018","devDependencies":{"@types/chai":"^4.0.8","@types/electron":"^1.6.10","@types/electron-is-dev":"^0.3.0","@types/material-ui":"^0.18.5","@types/mocha":"^2.2.44","@types/mockery":"^1.4.29","@types/node":"^8.0.53","@types/react":"^16.0.25","@types/react-dom":"^16.0.3","@types/request":"^2.0.8","@types/request-promise-native":"^1.0.10","@types/sinon":"^4.1.0","@types/url-parse":"^1.1.0","@types/x2js":"^3.1.0","babel-core":"^6.26.0","babel-loader":"^7.1.2","babel-plugin-add-module-exports":"^0.2.1","babel-plugin-array-includes":"^2.0.3","babel-plugin-module-resolver":"^3.0.0","babel-plugin-transform-class-properties":"^6.24.1","babel-plugin-transform-decorators-legacy":"^1.3.4","babel-plugin-transform-runtime":"^6.0.0","babel-preset-env":"^1.6.1","babel-preset-es2015":"^6.24.1","babel-preset-es2015-node":"^6.1.1","babel-preset-es2015-node5":"^1.2.0","babel-preset-react":"^6.24.1","babel-preset-stage-3":"^6.24.1","babel-preset-ts-node6-bluebird":"^1.0.1","chai":"^4.1.2","electron":"^1.7.9","electron-builder":"^19.46.9","fake-indexeddb":"^2.0.3","html-webpack-plugin":"^2.30.1","ignore-styles":"^5.0.1","json-to-js":"^1.0.2","mocha":"^4.0.1","mockery":"^2.1.0","node-noop":"^1.0.0","nyc":"^11.3.0","sinon":"^4.1.3","standard":"^10.0.3","standard-loader":"^6.0.1","ts-loader":"^3.1.1","ts-mockito":"^2.2.7","ts-node":"^3.3.0","tslint":"^5.8.0","tslint-config-standard":"^7.0.0","tslint-loader":"^3.5.3","typescript":"^2.6.2","webpack":"^3.8.1"},"scripts":{"build":"webpack --config webpack.config.js","prestart":"yarn run build","start":"electron .","test":"set TS_NODE_PROJECT=tsconfig.test.json&&mocha","pack":"electron-builder --dir","dist":"electron-builder","dist-all":"electron-builder -mwl"},"dependencies":{"dexie":"2","electron-google-analytics":"^0.0.24","electron-is-dev":"^0.3.0","electron-log":"^2.2.13","electron-updater":"^2.18.2","eve-online-esi":" https://github.com/Squareheads/eve-online-esi/archive/df440efa394e36e063a6593bede8dd8d285e1179.tar.gz","machine-uuid":"^1.2.0","material-ui":"^0.20.0","material-ui-image":"^2.1.1","node-machine-id":"^1.1.10","querystringify":"^1.0.0","react":"^16.2.0","react-dom":"^16.2.0","react-electron-web-view":"^2.0.1","request":"^2.83.0","typescript-collections":"^1.2.5","url-parse":"^1.2.0","x2js":"^3.1.1"},"build":{"appId":"io.squareheads.eve-intel","files":"./dist/**/*","directories":{"output":"packaged"},"mac":{"category":"public.app-category.utilities"}},"peerDependencies":{}}

/***/ })
/******/ ]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vd2VicGFjay9ib290c3RyYXAgMDgzNDE2Y2ZjNTMwYWRmOTQ4MDUiLCJ3ZWJwYWNrOi8vL2V4dGVybmFsIFwicGF0aFwiIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9ibHVlYmlyZC9qcy9yZWxlYXNlL3V0aWwuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2JsdWViaXJkLWxzdC9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZWxlY3Ryb24tdXBkYXRlci9ub2RlX21vZHVsZXMvYnVpbGRlci11dGlsLXJ1bnRpbWUvb3V0L2luZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9qcy15YW1sL2xpYi9qcy15YW1sL3R5cGUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2dyYWNlZnVsLWZzL2dyYWNlZnVsLWZzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy91bml2ZXJzYWxpZnkvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2VsZWN0cm9uLXVwZGF0ZXIvbm9kZV9tb2R1bGVzL2ZzLWV4dHJhL2xpYi9ta2RpcnMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2VsZWN0cm9uLXVwZGF0ZXIvb3V0L21haW4uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2VsZWN0cm9uLXVwZGF0ZXIvbm9kZV9tb2R1bGVzL2ZzLWV4dHJhLXAvaW5kZXguanMiLCJ3ZWJwYWNrOi8vL2V4dGVybmFsIFwiZWxlY3Ryb25cIiIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYmx1ZWJpcmQvanMvcmVsZWFzZS9lcnJvcnMuanMiLCJ3ZWJwYWNrOi8vL2V4dGVybmFsIFwiZnNcIiIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZWxlY3Ryb24tdXBkYXRlci9ub2RlX21vZHVsZXMvZnMtZXh0cmEvbGliL3BhdGgtZXhpc3RzL2luZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9lbGVjdHJvbi11cGRhdGVyL291dC9Qcm92aWRlci5qcyIsIndlYnBhY2s6Ly8vZXh0ZXJuYWwgXCJvc1wiIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9ibHVlYmlyZC9qcy9yZWxlYXNlL2VzNS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvanMteWFtbC9saWIvanMteWFtbC9jb21tb24uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2pzLXlhbWwvbGliL2pzLXlhbWwvc2NoZW1hLmpzIiwid2VicGFjazovLy9leHRlcm5hbCBcInN0cmVhbVwiIiwid2VicGFjazovLy9leHRlcm5hbCBcInVybFwiIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9qcy15YW1sL2xpYi9qcy15YW1sL2V4Y2VwdGlvbi5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvanMteWFtbC9saWIvanMteWFtbC9zY2hlbWEvZGVmYXVsdF9zYWZlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9lbGVjdHJvbi11cGRhdGVyL25vZGVfbW9kdWxlcy9zb3VyY2UtbWFwL2xpYi91dGlsLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9lbGVjdHJvbi11cGRhdGVyL25vZGVfbW9kdWxlcy9mcy1leHRyYS9saWIvcmVtb3ZlL2luZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9qcy15YW1sL2xpYi9qcy15YW1sL3NjaGVtYS9kZWZhdWx0X2Z1bGwuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2VsZWN0cm9uLWlzLWRldi9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZWxlY3Ryb24tdXBkYXRlci9vdXQvQXBwVXBkYXRlci5qcyIsIndlYnBhY2s6Ly8vZXh0ZXJuYWwgXCJjcnlwdG9cIiIsIndlYnBhY2s6Ly8vZXh0ZXJuYWwgXCJ1dGlsXCIiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2VsZWN0cm9uLXVwZGF0ZXIvbm9kZV9tb2R1bGVzL2ZzLWV4dHJhL2xpYi9qc29uL2pzb25maWxlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9qcy15YW1sL2luZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9qcy15YW1sL2xpYi9qcy15YW1sL3NjaGVtYS9mYWlsc2FmZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZWxlY3Ryb24tdXBkYXRlci9ub2RlX21vZHVsZXMvc291cmNlLW1hcC1zdXBwb3J0L3JlZ2lzdGVyLmpzIiwid2VicGFjazovLy9leHRlcm5hbCBcImNoaWxkX3Byb2Nlc3NcIiIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZWxlY3Ryb24tdXBkYXRlci9vdXQvZGlmZmVyZW50aWFsRG93bmxvYWRlci9kb3dubG9hZFBsYW5CdWlsZGVyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9lbGVjdHJvbi1sb2cvbGliL3RyYW5zcG9ydHMvY29uc29sZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZWxlY3Ryb24tbG9nL2xpYi9mb3JtYXQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2JsdWViaXJkL2pzL3JlbGVhc2UvY2F0Y2hfZmlsdGVyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9ibHVlYmlyZC9qcy9yZWxlYXNlL25vZGViYWNrLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9lbGVjdHJvbi11cGRhdGVyL25vZGVfbW9kdWxlcy9idWlsZGVyLXV0aWwtcnVudGltZS9vdXQvQ2FuY2VsbGF0aW9uVG9rZW4uanMiLCJ3ZWJwYWNrOi8vL2V4dGVybmFsIFwiZXZlbnRzXCIiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2VsZWN0cm9uLXVwZGF0ZXIvbm9kZV9tb2R1bGVzL2J1aWxkZXItdXRpbC1ydW50aW1lL291dC9odHRwRXhlY3V0b3IuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2VsZWN0cm9uLXVwZGF0ZXIvbm9kZV9tb2R1bGVzL2RlYnVnL3NyYy9kZWJ1Zy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZWxlY3Ryb24tdXBkYXRlci9ub2RlX21vZHVsZXMvZnMtZXh0cmEvbGliL2ZzL2luZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9ncmFjZWZ1bC1mcy9mcy5qcyIsIndlYnBhY2s6Ly8vZXh0ZXJuYWwgXCJhc3NlcnRcIiIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZWxlY3Ryb24tdXBkYXRlci9ub2RlX21vZHVsZXMvZnMtZXh0cmEvbGliL2NvcHkvY29weS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZWxlY3Ryb24tdXBkYXRlci9ub2RlX21vZHVsZXMvZnMtZXh0cmEvbGliL21rZGlycy93aW4zMi5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZWxlY3Ryb24tdXBkYXRlci9ub2RlX21vZHVsZXMvZnMtZXh0cmEvbGliL3V0aWwvdXRpbWVzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9lbGVjdHJvbi11cGRhdGVyL25vZGVfbW9kdWxlcy9mcy1leHRyYS9saWIvY29weS1zeW5jL2luZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9lbGVjdHJvbi11cGRhdGVyL25vZGVfbW9kdWxlcy9mcy1leHRyYS9saWIvdXRpbC9idWZmZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2VsZWN0cm9uLXVwZGF0ZXIvbm9kZV9tb2R1bGVzL2J1aWxkZXItdXRpbC1ydW50aW1lL291dC9Qcm9ncmVzc0NhbGxiYWNrVHJhbnNmb3JtLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9qcy15YW1sL2xpYi9qcy15YW1sL3NjaGVtYS9jb3JlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9qcy15YW1sL2xpYi9qcy15YW1sL3NjaGVtYS9qc29uLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9zZW12ZXIvc2VtdmVyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9lbGVjdHJvbi11cGRhdGVyL25vZGVfbW9kdWxlcy9zb3VyY2UtbWFwL2xpYi9zb3VyY2UtbWFwLWdlbmVyYXRvci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZWxlY3Ryb24tdXBkYXRlci9ub2RlX21vZHVsZXMvc291cmNlLW1hcC9saWIvYmFzZTY0LXZscS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZWxlY3Ryb24tdXBkYXRlci9ub2RlX21vZHVsZXMvc291cmNlLW1hcC9saWIvYXJyYXktc2V0LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9lbGVjdHJvbi11cGRhdGVyL291dC9HZW5lcmljUHJvdmlkZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2VsZWN0cm9uLXVwZGF0ZXIvb3V0L0dpdEh1YlByb3ZpZGVyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9lbGVjdHJvbi11cGRhdGVyL291dC9CYXNlVXBkYXRlci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZWxlY3Ryb24tdXBkYXRlci9vdXQvZGlmZmVyZW50aWFsRG93bmxvYWRlci9GaWxlV2l0aEVtYmVkZGVkQmxvY2tNYXBEaWZmZXJlbnRpYWxEb3dubG9hZGVyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9lbGVjdHJvbi11cGRhdGVyL25vZGVfbW9kdWxlcy9idWlsZGVyLXV0aWwtcnVudGltZS9vdXQvYmxvY2tNYXBBcGkuanMiLCJ3ZWJwYWNrOi8vL2V4dGVybmFsIFwiemxpYlwiIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9lbGVjdHJvbi11cGRhdGVyL291dC9kaWZmZXJlbnRpYWxEb3dubG9hZGVyL0RpZmZlcmVudGlhbERvd25sb2FkZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2VsZWN0cm9uLXVwZGF0ZXIvb3V0L2RpZmZlcmVudGlhbERvd25sb2FkZXIvRGF0YVNwbGl0dGVyLmpzIiwid2VicGFjazovLy9leHRlcm5hbCBcImh0dHBcIiIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZWxlY3Ryb24tbG9nL2xpYi9vcmlnaW5hbC1jb25zb2xlLmpzIiwid2VicGFjazovLy8uL3NyYy9tYWluLnRzeCIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYmx1ZWJpcmQvanMvcmVsZWFzZS9wcm9taXNlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9ibHVlYmlyZC9qcy9yZWxlYXNlL2FzeW5jLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9ibHVlYmlyZC9qcy9yZWxlYXNlL3NjaGVkdWxlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9ibHVlYmlyZC9qcy9yZWxlYXNlL3F1ZXVlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9ibHVlYmlyZC9qcy9yZWxlYXNlL3RoZW5hYmxlcy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYmx1ZWJpcmQvanMvcmVsZWFzZS9wcm9taXNlX2FycmF5LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9ibHVlYmlyZC9qcy9yZWxlYXNlL2NvbnRleHQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2JsdWViaXJkL2pzL3JlbGVhc2UvZGVidWdnYWJpbGl0eS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYmx1ZWJpcmQvanMvcmVsZWFzZS9maW5hbGx5LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9ibHVlYmlyZC9qcy9yZWxlYXNlL21ldGhvZC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYmx1ZWJpcmQvanMvcmVsZWFzZS9iaW5kLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9ibHVlYmlyZC9qcy9yZWxlYXNlL2NhbmNlbC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYmx1ZWJpcmQvanMvcmVsZWFzZS9kaXJlY3RfcmVzb2x2ZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYmx1ZWJpcmQvanMvcmVsZWFzZS9zeW5jaHJvbm91c19pbnNwZWN0aW9uLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9ibHVlYmlyZC9qcy9yZWxlYXNlL2pvaW4uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2JsdWViaXJkL2pzL3JlbGVhc2UvbWFwLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9ibHVlYmlyZC9qcy9yZWxlYXNlL2NhbGxfZ2V0LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9ibHVlYmlyZC9qcy9yZWxlYXNlL3VzaW5nLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9ibHVlYmlyZC9qcy9yZWxlYXNlL3RpbWVycy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYmx1ZWJpcmQvanMvcmVsZWFzZS9nZW5lcmF0b3JzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9ibHVlYmlyZC9qcy9yZWxlYXNlL25vZGVpZnkuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2JsdWViaXJkL2pzL3JlbGVhc2UvcHJvbWlzaWZ5LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9ibHVlYmlyZC9qcy9yZWxlYXNlL3Byb3BzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9ibHVlYmlyZC9qcy9yZWxlYXNlL3JhY2UuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2JsdWViaXJkL2pzL3JlbGVhc2UvcmVkdWNlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9ibHVlYmlyZC9qcy9yZWxlYXNlL3NldHRsZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYmx1ZWJpcmQvanMvcmVsZWFzZS9zb21lLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9ibHVlYmlyZC9qcy9yZWxlYXNlL2ZpbHRlci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYmx1ZWJpcmQvanMvcmVsZWFzZS9lYWNoLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9ibHVlYmlyZC9qcy9yZWxlYXNlL2FueS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZWxlY3Ryb24tdXBkYXRlci9ub2RlX21vZHVsZXMvZGVidWcvc3JjL2luZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9lbGVjdHJvbi11cGRhdGVyL25vZGVfbW9kdWxlcy9kZWJ1Zy9zcmMvYnJvd3Nlci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbXMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2VsZWN0cm9uLXVwZGF0ZXIvbm9kZV9tb2R1bGVzL2RlYnVnL3NyYy9ub2RlLmpzIiwid2VicGFjazovLy9leHRlcm5hbCBcInR0eVwiIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9zdXBwb3J0cy1jb2xvci9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvaGFzLWZsYWcvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2VsZWN0cm9uLXVwZGF0ZXIvbm9kZV9tb2R1bGVzL2ZzLWV4dHJhL2xpYi9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZWxlY3Ryb24tdXBkYXRlci9ub2RlX21vZHVsZXMvZnMtZXh0cmEvbGliL3V0aWwvYXNzaWduLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9ncmFjZWZ1bC1mcy9wb2x5ZmlsbHMuanMiLCJ3ZWJwYWNrOi8vL2V4dGVybmFsIFwiY29uc3RhbnRzXCIiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2dyYWNlZnVsLWZzL2xlZ2FjeS1zdHJlYW1zLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9lbGVjdHJvbi11cGRhdGVyL25vZGVfbW9kdWxlcy9mcy1leHRyYS9saWIvY29weS9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZWxlY3Ryb24tdXBkYXRlci9ub2RlX21vZHVsZXMvZnMtZXh0cmEvbGliL21rZGlycy9ta2RpcnMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2VsZWN0cm9uLXVwZGF0ZXIvbm9kZV9tb2R1bGVzL2ZzLWV4dHJhL2xpYi9ta2RpcnMvbWtkaXJzLXN5bmMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2VsZWN0cm9uLXVwZGF0ZXIvbm9kZV9tb2R1bGVzL2ZzLWV4dHJhL2xpYi9jb3B5LXN5bmMvY29weS1zeW5jLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9lbGVjdHJvbi11cGRhdGVyL25vZGVfbW9kdWxlcy9mcy1leHRyYS9saWIvcmVtb3ZlL3JpbXJhZi5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZWxlY3Ryb24tdXBkYXRlci9ub2RlX21vZHVsZXMvZnMtZXh0cmEvbGliL2pzb24vaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2pzb25maWxlL2luZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9lbGVjdHJvbi11cGRhdGVyL25vZGVfbW9kdWxlcy9mcy1leHRyYS9saWIvanNvbi9vdXRwdXQtanNvbi5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZWxlY3Ryb24tdXBkYXRlci9ub2RlX21vZHVsZXMvZnMtZXh0cmEvbGliL2pzb24vb3V0cHV0LWpzb24tc3luYy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZWxlY3Ryb24tdXBkYXRlci9ub2RlX21vZHVsZXMvZnMtZXh0cmEvbGliL21vdmUvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2VsZWN0cm9uLXVwZGF0ZXIvbm9kZV9tb2R1bGVzL2ZzLWV4dHJhL2xpYi9tb3ZlLXN5bmMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2VsZWN0cm9uLXVwZGF0ZXIvbm9kZV9tb2R1bGVzL2ZzLWV4dHJhL2xpYi9lbXB0eS9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZWxlY3Ryb24tdXBkYXRlci9ub2RlX21vZHVsZXMvZnMtZXh0cmEvbGliL2Vuc3VyZS9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZWxlY3Ryb24tdXBkYXRlci9ub2RlX21vZHVsZXMvZnMtZXh0cmEvbGliL2Vuc3VyZS9maWxlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9lbGVjdHJvbi11cGRhdGVyL25vZGVfbW9kdWxlcy9mcy1leHRyYS9saWIvZW5zdXJlL2xpbmsuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2VsZWN0cm9uLXVwZGF0ZXIvbm9kZV9tb2R1bGVzL2ZzLWV4dHJhL2xpYi9lbnN1cmUvc3ltbGluay5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZWxlY3Ryb24tdXBkYXRlci9ub2RlX21vZHVsZXMvZnMtZXh0cmEvbGliL2Vuc3VyZS9zeW1saW5rLXBhdGhzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9lbGVjdHJvbi11cGRhdGVyL25vZGVfbW9kdWxlcy9mcy1leHRyYS9saWIvZW5zdXJlL3N5bWxpbmstdHlwZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZWxlY3Ryb24tdXBkYXRlci9ub2RlX21vZHVsZXMvZnMtZXh0cmEvbGliL291dHB1dC9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZWxlY3Ryb24tdXBkYXRlci9ub2RlX21vZHVsZXMvYnVpbGRlci11dGlsLXJ1bnRpbWUvb3V0L3B1Ymxpc2hPcHRpb25zLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9lbGVjdHJvbi11cGRhdGVyL25vZGVfbW9kdWxlcy9idWlsZGVyLXV0aWwtcnVudGltZS9vdXQvcmZjMjI1M1BhcnNlci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZWxlY3Ryb24tdXBkYXRlci9ub2RlX21vZHVsZXMvYnVpbGRlci11dGlsLXJ1bnRpbWUvb3V0L3V1aWQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2VsZWN0cm9uLXVwZGF0ZXIvbm9kZV9tb2R1bGVzL2J1aWxkZXItdXRpbC1ydW50aW1lL291dC94bWwuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3NheC9saWIvc2F4LmpzIiwid2VicGFjazovLy9leHRlcm5hbCBcInN0cmluZ19kZWNvZGVyXCIiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2pzLXlhbWwvbGliL2pzLXlhbWwuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2pzLXlhbWwvbGliL2pzLXlhbWwvbG9hZGVyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9qcy15YW1sL2xpYi9qcy15YW1sL21hcmsuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2pzLXlhbWwvbGliL2pzLXlhbWwvdHlwZS9zdHIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2pzLXlhbWwvbGliL2pzLXlhbWwvdHlwZS9zZXEuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2pzLXlhbWwvbGliL2pzLXlhbWwvdHlwZS9tYXAuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2pzLXlhbWwvbGliL2pzLXlhbWwvdHlwZS9udWxsLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9qcy15YW1sL2xpYi9qcy15YW1sL3R5cGUvYm9vbC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvanMteWFtbC9saWIvanMteWFtbC90eXBlL2ludC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvanMteWFtbC9saWIvanMteWFtbC90eXBlL2Zsb2F0LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9qcy15YW1sL2xpYi9qcy15YW1sL3R5cGUvdGltZXN0YW1wLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9qcy15YW1sL2xpYi9qcy15YW1sL3R5cGUvbWVyZ2UuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2pzLXlhbWwvbGliL2pzLXlhbWwvdHlwZS9iaW5hcnkuanMiLCJ3ZWJwYWNrOi8vL2V4dGVybmFsIFwiYnVmZmVyXCIiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2pzLXlhbWwvbGliL2pzLXlhbWwvdHlwZS9vbWFwLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9qcy15YW1sL2xpYi9qcy15YW1sL3R5cGUvcGFpcnMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2pzLXlhbWwvbGliL2pzLXlhbWwvdHlwZS9zZXQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2pzLXlhbWwvbGliL2pzLXlhbWwvdHlwZS9qcy91bmRlZmluZWQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2pzLXlhbWwvbGliL2pzLXlhbWwvdHlwZS9qcy9yZWdleHAuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2pzLXlhbWwvbGliL2pzLXlhbWwvdHlwZS9qcy9mdW5jdGlvbi5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZXNwcmltYS9kaXN0L2VzcHJpbWEuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2pzLXlhbWwvbGliL2pzLXlhbWwvZHVtcGVyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9lbGVjdHJvbi11cGRhdGVyL25vZGVfbW9kdWxlcy9sYXp5LXZhbC9vdXQvbWFpbi5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZWxlY3Ryb24tdXBkYXRlci9ub2RlX21vZHVsZXMvc291cmNlLW1hcC1zdXBwb3J0L3NvdXJjZS1tYXAtc3VwcG9ydC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZWxlY3Ryb24tdXBkYXRlci9ub2RlX21vZHVsZXMvc291cmNlLW1hcC9zb3VyY2UtbWFwLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9lbGVjdHJvbi11cGRhdGVyL25vZGVfbW9kdWxlcy9zb3VyY2UtbWFwL2xpYi9iYXNlNjQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2VsZWN0cm9uLXVwZGF0ZXIvbm9kZV9tb2R1bGVzL3NvdXJjZS1tYXAvbGliL21hcHBpbmctbGlzdC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZWxlY3Ryb24tdXBkYXRlci9ub2RlX21vZHVsZXMvc291cmNlLW1hcC9saWIvc291cmNlLW1hcC1jb25zdW1lci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZWxlY3Ryb24tdXBkYXRlci9ub2RlX21vZHVsZXMvc291cmNlLW1hcC9saWIvYmluYXJ5LXNlYXJjaC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZWxlY3Ryb24tdXBkYXRlci9ub2RlX21vZHVsZXMvc291cmNlLW1hcC9saWIvcXVpY2stc29ydC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZWxlY3Ryb24tdXBkYXRlci9ub2RlX21vZHVsZXMvc291cmNlLW1hcC9saWIvc291cmNlLW5vZGUuanMiLCJ3ZWJwYWNrOi8vL2V4dGVybmFsIFwibW9kdWxlXCIiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2VsZWN0cm9uLXVwZGF0ZXIvb3V0L2VsZWN0cm9uSHR0cEV4ZWN1dG9yLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9lbGVjdHJvbi11cGRhdGVyL291dC9wcm92aWRlckZhY3RvcnkuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2VsZWN0cm9uLXVwZGF0ZXIvb3V0L0JpbnRyYXlQcm92aWRlci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZWxlY3Ryb24tdXBkYXRlci9ub2RlX21vZHVsZXMvYnVpbGRlci11dGlsLXJ1bnRpbWUvb3V0L2JpbnRyYXkuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2VsZWN0cm9uLXVwZGF0ZXIvb3V0L1ByaXZhdGVHaXRIdWJQcm92aWRlci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZWxlY3Ryb24tdXBkYXRlci9vdXQvTnNpc1VwZGF0ZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2VsZWN0cm9uLXVwZGF0ZXIvb3V0L0Rvd25sb2FkZWRVcGRhdGVIZWxwZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC5pc2VxdWFsL2luZGV4LmpzIiwid2VicGFjazovLy8od2VicGFjaykvYnVpbGRpbi9tb2R1bGUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2VsZWN0cm9uLXVwZGF0ZXIvb3V0L2RpZmZlcmVudGlhbERvd25sb2FkZXIvbXVsdGlwbGVSYW5nZURvd25sb2FkZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2VsZWN0cm9uLXVwZGF0ZXIvb3V0L2RpZmZlcmVudGlhbERvd25sb2FkZXIvR2VuZXJpY0RpZmZlcmVudGlhbERvd25sb2FkZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2VsZWN0cm9uLXVwZGF0ZXIvb3V0L3dpbmRvd3NFeGVjdXRhYmxlQ29kZVNpZ25hdHVyZVZlcmlmaWVyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9lbGVjdHJvbi11cGRhdGVyL291dC9NYWNVcGRhdGVyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9lbGVjdHJvbi11cGRhdGVyL291dC9BcHBJbWFnZVVwZGF0ZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2VsZWN0cm9uLWxvZy9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZWxlY3Ryb24tbG9nL3JlbmRlcmVyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9lbGVjdHJvbi1sb2cvbWFpbi5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZWxlY3Ryb24tbG9nL2xpYi9sb2cuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2VsZWN0cm9uLWxvZy9saWIvdHJhbnNwb3J0cy9maWxlL2luZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9lbGVjdHJvbi1sb2cvbGliL3RyYW5zcG9ydHMvZmlsZS9maW5kLWxvZy1wYXRoLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9lbGVjdHJvbi1sb2cvbGliL3RyYW5zcG9ydHMvZmlsZS9nZXQtYXBwLW5hbWUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2VsZWN0cm9uLWxvZy9saWIvdHJhbnNwb3J0cy9sb2ctcy5qcyIsIndlYnBhY2s6Ly8vZXh0ZXJuYWwgXCJodHRwc1wiIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9lbGVjdHJvbi1sb2cvbGliL3RyYW5zcG9ydHMvcmVuZGVyZXItY29uc29sZS5qcyIsIndlYnBhY2s6Ly8vLi9wYWNrYWdlLmpzb24iXSwibmFtZXMiOlsiZXM1IiwicmVxdWlyZSIsImNhbkV2YWx1YXRlIiwibmF2aWdhdG9yIiwiZXJyb3JPYmoiLCJlIiwidHJ5Q2F0Y2hUYXJnZXQiLCJnbG9iYWxPYmplY3QiLCJzZWxmIiwid2luZG93IiwiZ2xvYmFsIiwidW5kZWZpbmVkIiwidHJ5Q2F0Y2hlciIsInRhcmdldCIsImFwcGx5IiwiYXJndW1lbnRzIiwidHJ5Q2F0Y2giLCJmbiIsImluaGVyaXRzIiwiQ2hpbGQiLCJQYXJlbnQiLCJoYXNQcm9wIiwiaGFzT3duUHJvcGVydHkiLCJUIiwiY29uc3RydWN0b3IiLCJjb25zdHJ1Y3RvciQiLCJwcm9wZXJ0eU5hbWUiLCJwcm90b3R5cGUiLCJjYWxsIiwiY2hhckF0IiwibGVuZ3RoIiwiaXNQcmltaXRpdmUiLCJ2YWwiLCJpc09iamVjdCIsInZhbHVlIiwibWF5YmVXcmFwQXNFcnJvciIsIm1heWJlRXJyb3IiLCJFcnJvciIsInNhZmVUb1N0cmluZyIsIndpdGhBcHBlbmRlZCIsImFwcGVuZGVlIiwibGVuIiwicmV0IiwiQXJyYXkiLCJpIiwiZ2V0RGF0YVByb3BlcnR5T3JEZWZhdWx0Iiwib2JqIiwia2V5IiwiZGVmYXVsdFZhbHVlIiwiaXNFUzUiLCJkZXNjIiwiT2JqZWN0IiwiZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yIiwiZ2V0Iiwic2V0Iiwibm90RW51bWVyYWJsZVByb3AiLCJuYW1lIiwiZGVzY3JpcHRvciIsImNvbmZpZ3VyYWJsZSIsImVudW1lcmFibGUiLCJ3cml0YWJsZSIsImRlZmluZVByb3BlcnR5IiwidGhyb3dlciIsInIiLCJpbmhlcml0ZWREYXRhS2V5cyIsImV4Y2x1ZGVkUHJvdG90eXBlcyIsIkZ1bmN0aW9uIiwiaXNFeGNsdWRlZFByb3RvIiwiZ2V0S2V5cyIsImdldE93blByb3BlcnR5TmFtZXMiLCJ2aXNpdGVkS2V5cyIsImNyZWF0ZSIsImtleXMiLCJwdXNoIiwiZ2V0UHJvdG90eXBlT2YiLCJlbnVtZXJhdGlvbiIsInRoaXNBc3NpZ25tZW50UGF0dGVybiIsImlzQ2xhc3MiLCJuYW1lcyIsImhhc01ldGhvZHMiLCJoYXNNZXRob2RzT3RoZXJUaGFuQ29uc3RydWN0b3IiLCJoYXNUaGlzQXNzaWdubWVudEFuZFN0YXRpY01ldGhvZHMiLCJ0ZXN0IiwidG9GYXN0UHJvcGVydGllcyIsIkZha2VDb25zdHJ1Y3RvciIsImwiLCJldmFsIiwicmlkZW50IiwiaXNJZGVudGlmaWVyIiwic3RyIiwiZmlsbGVkUmFuZ2UiLCJjb3VudCIsInByZWZpeCIsInN1ZmZpeCIsImlzRXJyb3IiLCJtZXNzYWdlIiwibWFya0FzT3JpZ2luYXRpbmdGcm9tUmVqZWN0aW9uIiwiaWdub3JlIiwib3JpZ2luYXRlc0Zyb21SZWplY3Rpb24iLCJPcGVyYXRpb25hbEVycm9yIiwiY2FuQXR0YWNoVHJhY2UiLCJwcm9wZXJ0eUlzV3JpdGFibGUiLCJlbnN1cmVFcnJvck9iamVjdCIsImVyciIsImNsYXNzU3RyaW5nIiwidG9TdHJpbmciLCJjb3B5RGVzY3JpcHRvcnMiLCJmcm9tIiwidG8iLCJmaWx0ZXIiLCJnZXREZXNjcmlwdG9yIiwiYXNBcnJheSIsInYiLCJpc0FycmF5IiwiU3ltYm9sIiwiaXRlcmF0b3IiLCJBcnJheUZyb20iLCJpdCIsIml0UmVzdWx0IiwibmV4dCIsImRvbmUiLCJpc05vZGUiLCJwcm9jZXNzIiwidG9Mb3dlckNhc2UiLCJoYXNFbnZWYXJpYWJsZXMiLCJlbnYiLCJnZXROYXRpdmVQcm9taXNlIiwiUHJvbWlzZSIsInByb21pc2UiLCJkb21haW5CaW5kIiwiY2IiLCJiaW5kIiwiaGFzRGV2VG9vbHMiLCJjaHJvbWUiLCJsb2FkVGltZXMiLCJpc1JlY2VudE5vZGUiLCJ2ZXJzaW9uIiwidmVyc2lvbnMiLCJub2RlIiwic3BsaXQiLCJtYXAiLCJOdW1iZXIiLCJsYXN0TGluZUVycm9yIiwibW9kdWxlIiwiZXhwb3J0cyIsIkJsdWViaXJkUHJvbWlzZSIsImNvbmZpZyIsImxvbmdTdGFja1RyYWNlcyIsImRlZmF1bHQiLCJfQ2FuY2VsbGF0aW9uVG9rZW4iLCJfbG9hZF9DYW5jZWxsYXRpb25Ub2tlbiIsIkNhbmNlbGxhdGlvblRva2VuIiwiQ2FuY2VsbGF0aW9uRXJyb3IiLCJfaHR0cEV4ZWN1dG9yIiwiX2xvYWRfaHR0cEV4ZWN1dG9yIiwiSHR0cEVycm9yIiwiY3JlYXRlSHR0cEVycm9yIiwiSHR0cEV4ZWN1dG9yIiwiRGlnZXN0VHJhbnNmb3JtIiwic2FmZUdldEhlYWRlciIsImNvbmZpZ3VyZVJlcXVlc3RPcHRpb25zIiwiY29uZmlndXJlUmVxdWVzdE9wdGlvbnNGcm9tVXJsIiwic2FmZVN0cmluZ2lmeUpzb24iLCJwYXJzZUpzb24iLCJfcHVibGlzaE9wdGlvbnMiLCJfbG9hZF9wdWJsaXNoT3B0aW9ucyIsImdldFMzTGlrZVByb3ZpZGVyQmFzZVVybCIsImdpdGh1YlVybCIsIl9yZmMyMjUzUGFyc2VyIiwiX2xvYWRfcmZjMjI1M1BhcnNlciIsInBhcnNlRG4iLCJfdXVpZCIsIl9sb2FkX3V1aWQiLCJVVUlEIiwiX1Byb2dyZXNzQ2FsbGJhY2tUcmFuc2Zvcm0iLCJfbG9hZF9Qcm9ncmVzc0NhbGxiYWNrVHJhbnNmb3JtIiwiUHJvZ3Jlc3NDYWxsYmFja1RyYW5zZm9ybSIsIl94bWwiLCJfbG9hZF94bWwiLCJwYXJzZVhtbCIsIlhFbGVtZW50IiwibmV3RXJyb3IiLCJjb2RlIiwiZXJyb3IiLCJZQU1MRXhjZXB0aW9uIiwiVFlQRV9DT05TVFJVQ1RPUl9PUFRJT05TIiwiWUFNTF9OT0RFX0tJTkRTIiwiY29tcGlsZVN0eWxlQWxpYXNlcyIsInJlc3VsdCIsImZvckVhY2giLCJzdHlsZSIsImFsaWFzIiwiU3RyaW5nIiwiVHlwZSIsInRhZyIsIm9wdGlvbnMiLCJpbmRleE9mIiwia2luZCIsInJlc29sdmUiLCJjb25zdHJ1Y3QiLCJkYXRhIiwiaW5zdGFuY2VPZiIsInByZWRpY2F0ZSIsInJlcHJlc2VudCIsImRlZmF1bHRTdHlsZSIsInN0eWxlQWxpYXNlcyIsImZzIiwicG9seWZpbGxzIiwibGVnYWN5IiwicXVldWUiLCJ1dGlsIiwibm9vcCIsImRlYnVnIiwiZGVidWdsb2ciLCJOT0RFX0RFQlVHIiwibSIsImZvcm1hdCIsImpvaW4iLCJjb25zb2xlIiwib24iLCJlcXVhbCIsInBhdGNoIiwiVEVTVF9HUkFDRUZVTF9GU19HTE9CQUxfUEFUQ0giLCJjbG9zZSIsImZzJGNsb3NlIiwiZmQiLCJyZXRyeSIsImNsb3NlU3luYyIsImZzJGNsb3NlU3luYyIsInJ2YWwiLCJncmFjZWZ1bGlmeSIsIkZpbGVSZWFkU3RyZWFtIiwiUmVhZFN0cmVhbSIsIkZpbGVXcml0ZVN0cmVhbSIsIldyaXRlU3RyZWFtIiwiY3JlYXRlUmVhZFN0cmVhbSIsImNyZWF0ZVdyaXRlU3RyZWFtIiwiZnMkcmVhZEZpbGUiLCJyZWFkRmlsZSIsInBhdGgiLCJnbyRyZWFkRmlsZSIsImVucXVldWUiLCJmcyR3cml0ZUZpbGUiLCJ3cml0ZUZpbGUiLCJnbyR3cml0ZUZpbGUiLCJmcyRhcHBlbmRGaWxlIiwiYXBwZW5kRmlsZSIsImdvJGFwcGVuZEZpbGUiLCJmcyRyZWFkZGlyIiwicmVhZGRpciIsImFyZ3MiLCJnbyRyZWFkZGlyJGNiIiwiZ28kcmVhZGRpciIsImZpbGVzIiwic29ydCIsInN1YnN0ciIsImxlZ1N0cmVhbXMiLCJmcyRSZWFkU3RyZWFtIiwib3BlbiIsIlJlYWRTdHJlYW0kb3BlbiIsImZzJFdyaXRlU3RyZWFtIiwiV3JpdGVTdHJlYW0kb3BlbiIsInRoYXQiLCJmbGFncyIsIm1vZGUiLCJhdXRvQ2xvc2UiLCJkZXN0cm95IiwiZW1pdCIsInJlYWQiLCJmcyRvcGVuIiwiZ28kb3BlbiIsImVsZW0iLCJzaGlmdCIsImZyb21DYWxsYmFjayIsInJlamVjdCIsInJlcyIsImZyb21Qcm9taXNlIiwidGhlbiIsInUiLCJta2RpcnMiLCJta2RpcnNTeW5jIiwibWtkaXJwIiwibWtkaXJwU3luYyIsImVuc3VyZURpciIsImVuc3VyZURpclN5bmMiLCJVcGRhdGVyU2lnbmFsIiwiVVBEQVRFX0RPV05MT0FERUQiLCJET1dOTE9BRF9QUk9HUkVTUyIsIlByb3ZpZGVyIiwiTm9PcExvZ2dlciIsIkFwcFVwZGF0ZXIiLCJfQXBwVXBkYXRlciIsIl9sb2FkX0FwcFVwZGF0ZXIiLCJfYnVpbGRlclV0aWxSdW50aW1lIiwiX2xvYWRfYnVpbGRlclV0aWxSdW50aW1lIiwiX1Byb3ZpZGVyIiwiX2xvYWRfUHJvdmlkZXIiLCJnZXREZWZhdWx0Q2hhbm5lbE5hbWUiLCJnZXRDdXN0b21DaGFubmVsTmFtZSIsImdldEN1cnJlbnRQbGF0Zm9ybSIsImlzVXNlT2xkTWFjUHJvdmlkZXIiLCJnZXRDaGFubmVsRmlsZW5hbWUiLCJuZXdCYXNlVXJsIiwibmV3VXJsRnJvbUJhc2UiLCJfdXJsIiwiX2xvYWRfdXJsIiwiX2F1dG9VcGRhdGVyIiwiX2xvYWRfYXV0b1VwZGF0ZXIiLCJwbGF0Zm9ybSIsIk5zaXNVcGRhdGVyIiwiTWFjVXBkYXRlciIsIkFwcEltYWdlVXBkYXRlciIsImdldENoYW5uZWxGaWxlUHJlZml4IiwiY3VycmVudFBsYXRmb3JtIiwiYXJjaCIsIlRFU1RfVVBEQVRFUl9BUkNIIiwiYXJjaFN1ZmZpeCIsImNoYW5uZWwiLCJURVNUX1VQREFURVJfUExBVEZPUk0iLCJlbWl0dGVyIiwibG9naW4iLCJoYW5kbGVyIiwiYWRkSGFuZGxlciIsInByb2dyZXNzIiwidXBkYXRlRG93bmxvYWRlZCIsInVwZGF0ZUNhbmNlbGxlZCIsImlzTG9nRXZlbnQiLCJldmVudCIsImxvZyIsInVybCIsIlVSTCIsInBhdGhuYW1lIiwiZW5kc1dpdGgiLCJiYXNlVXJsIiwic2VhcmNoIiwiZnNFeHRyYSIsIm1ha2VGcyIsIm1ldGhvZE5hbWUiLCJtZXRob2QiLCJtYXRjaCIsInByb21pc2lmeSIsImNyZWF0ZUZpbGUiLCJlbnN1cmVGaWxlIiwiT2JqZWN0ZnJlZXplIiwiZnJlZXplIiwic3ViRXJyb3IiLCJuYW1lUHJvcGVydHkiLCJkZWZhdWx0TWVzc2FnZSIsIlN1YkVycm9yIiwiY2FwdHVyZVN0YWNrVHJhY2UiLCJfVHlwZUVycm9yIiwiX1JhbmdlRXJyb3IiLCJXYXJuaW5nIiwiVGltZW91dEVycm9yIiwiQWdncmVnYXRlRXJyb3IiLCJUeXBlRXJyb3IiLCJSYW5nZUVycm9yIiwibWV0aG9kcyIsImxldmVsIiwiaW5kZW50IiwibGluZXMiLCJqIiwiY2F1c2UiLCJzdGFjayIsImVycm9yVHlwZXMiLCJSZWplY3Rpb25FcnJvciIsInBhdGhFeGlzdHMiLCJhY2Nlc3MiLCJjYXRjaCIsInBhdGhFeGlzdHNTeW5jIiwiZXhpc3RzU3luYyIsImZpbmRGaWxlIiwicGFyc2VVcGRhdGVJbmZvIiwiZ2V0RmlsZUxpc3QiLCJyZXNvbHZlRmlsZXMiLCJfanNZYW1sIiwiX2xvYWRfanNZYW1sIiwiX21haW4iLCJfbG9hZF9tYWluIiwiZXhlY3V0b3IiLCJ1c2VNdWx0aXBsZVJhbmdlUmVxdWVzdCIsImZpbGVFeHRyYURvd25sb2FkSGVhZGVycyIsInNldFJlcXVlc3RIZWFkZXJzIiwicmVxdWVzdEhlYWRlcnMiLCJodHRwUmVxdWVzdCIsImhlYWRlcnMiLCJjYW5jZWxsYXRpb25Ub2tlbiIsInJlcXVlc3QiLCJjcmVhdGVSZXF1ZXN0T3B0aW9ucyIsImFzc2lnbiIsInByb3RvY29sIiwiaG9zdG5hbWUiLCJwb3J0IiwiZXh0ZW5zaW9uIiwibm90IiwiZmluZCIsImZpbGVJbmZvIiwic29tZSIsImV4dCIsInJhd0RhdGEiLCJjaGFubmVsRmlsZSIsImNoYW5uZWxGaWxlVXJsIiwic2FmZUxvYWQiLCJ1cGRhdGVJbmZvIiwic2hhNTEyIiwicGF0aFRyYW5zZm9ybWVyIiwicCIsInNoYTIiLCJpbmZvIiwicGFja2FnZXMiLCJwYWNrYWdlSW5mbyIsImlhMzIiLCJocmVmIiwicHJvcCIsImhhcyIsInByb3RvIiwiT2JqZWN0S2V5cyIsIm8iLCJPYmplY3RHZXREZXNjcmlwdG9yIiwiT2JqZWN0RGVmaW5lUHJvcGVydHkiLCJPYmplY3RGcmVlemUiLCJPYmplY3RHZXRQcm90b3R5cGVPZiIsIkFycmF5SXNBcnJheSIsImlzTm90aGluZyIsInN1YmplY3QiLCJ0b0FycmF5Iiwic2VxdWVuY2UiLCJleHRlbmQiLCJzb3VyY2UiLCJpbmRleCIsInNvdXJjZUtleXMiLCJyZXBlYXQiLCJzdHJpbmciLCJjeWNsZSIsImlzTmVnYXRpdmVaZXJvIiwibnVtYmVyIiwiTkVHQVRJVkVfSU5GSU5JVFkiLCJjb21tb24iLCJjb21waWxlTGlzdCIsInNjaGVtYSIsImV4Y2x1ZGUiLCJpbmNsdWRlIiwiaW5jbHVkZWRTY2hlbWEiLCJjdXJyZW50VHlwZSIsInByZXZpb3VzVHlwZSIsInByZXZpb3VzSW5kZXgiLCJ0eXBlIiwiY29tcGlsZU1hcCIsInNjYWxhciIsIm1hcHBpbmciLCJmYWxsYmFjayIsImNvbGxlY3RUeXBlIiwiU2NoZW1hIiwiZGVmaW5pdGlvbiIsImltcGxpY2l0IiwiZXhwbGljaXQiLCJsb2FkS2luZCIsImNvbXBpbGVkSW1wbGljaXQiLCJjb21waWxlZEV4cGxpY2l0IiwiY29tcGlsZWRUeXBlTWFwIiwiREVGQVVMVCIsImNyZWF0ZVNjaGVtYSIsInNjaGVtYXMiLCJ0eXBlcyIsImV2ZXJ5IiwicmVhc29uIiwibWFyayIsImNvbXBhY3QiLCJnZXRBcmciLCJhQXJncyIsImFOYW1lIiwiYURlZmF1bHRWYWx1ZSIsInVybFJlZ2V4cCIsImRhdGFVcmxSZWdleHAiLCJ1cmxQYXJzZSIsImFVcmwiLCJzY2hlbWUiLCJhdXRoIiwiaG9zdCIsInVybEdlbmVyYXRlIiwiYVBhcnNlZFVybCIsIm5vcm1hbGl6ZSIsImFQYXRoIiwiaXNBYnNvbHV0ZSIsInBhcnRzIiwicGFydCIsInVwIiwic3BsaWNlIiwiYVJvb3QiLCJhUGF0aFVybCIsImFSb290VXJsIiwiam9pbmVkIiwicmVwbGFjZSIsInJlbGF0aXZlIiwibGFzdEluZGV4T2YiLCJzbGljZSIsInN1cHBvcnRzTnVsbFByb3RvIiwiaWRlbnRpdHkiLCJzIiwidG9TZXRTdHJpbmciLCJhU3RyIiwiaXNQcm90b1N0cmluZyIsImZyb21TZXRTdHJpbmciLCJjaGFyQ29kZUF0IiwiY29tcGFyZUJ5T3JpZ2luYWxQb3NpdGlvbnMiLCJtYXBwaW5nQSIsIm1hcHBpbmdCIiwib25seUNvbXBhcmVPcmlnaW5hbCIsImNtcCIsInN0cmNtcCIsIm9yaWdpbmFsTGluZSIsIm9yaWdpbmFsQ29sdW1uIiwiZ2VuZXJhdGVkQ29sdW1uIiwiZ2VuZXJhdGVkTGluZSIsImNvbXBhcmVCeUdlbmVyYXRlZFBvc2l0aW9uc0RlZmxhdGVkIiwib25seUNvbXBhcmVHZW5lcmF0ZWQiLCJhU3RyMSIsImFTdHIyIiwiY29tcGFyZUJ5R2VuZXJhdGVkUG9zaXRpb25zSW5mbGF0ZWQiLCJwYXJzZVNvdXJjZU1hcElucHV0IiwiSlNPTiIsInBhcnNlIiwiY29tcHV0ZVNvdXJjZVVSTCIsInNvdXJjZVJvb3QiLCJzb3VyY2VVUkwiLCJzb3VyY2VNYXBVUkwiLCJwYXJzZWQiLCJzdWJzdHJpbmciLCJyaW1yYWYiLCJyZW1vdmUiLCJyZW1vdmVTeW5jIiwic3luYyIsImdldEZyb21FbnYiLCJwYXJzZUludCIsIkVMRUNUUk9OX0lTX0RFViIsImlzRW52U2V0IiwiZGVmYXVsdEFwcCIsImV4ZWNQYXRoIiwiX2JsdWViaXJkTHN0IiwiX2xvYWRfYmx1ZWJpcmRMc3QiLCJfYmx1ZWJpcmRMc3QyIiwiX2xvYWRfYmx1ZWJpcmRMc3QyIiwiX2ludGVyb3BSZXF1aXJlRGVmYXVsdCIsIl9jcnlwdG8iLCJfbG9hZF9jcnlwdG8iLCJfZWxlY3Ryb24iLCJfbG9hZF9lbGVjdHJvbiIsIl9lbGVjdHJvbklzRGV2IiwiX2xvYWRfZWxlY3Ryb25Jc0RldiIsIl9ldmVudHMiLCJfbG9hZF9ldmVudHMiLCJfZnNFeHRyYVAiLCJfbG9hZF9mc0V4dHJhUCIsIl9sYXp5VmFsIiwiX2xvYWRfbGF6eVZhbCIsIl9wYXRoIiwiX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQiLCJfc2VtdmVyIiwiX2xvYWRfc2VtdmVyIiwiX2VsZWN0cm9uSHR0cEV4ZWN1dG9yIiwiX2xvYWRfZWxlY3Ryb25IdHRwRXhlY3V0b3IiLCJfR2VuZXJpY1Byb3ZpZGVyIiwiX2xvYWRfR2VuZXJpY1Byb3ZpZGVyIiwiX3Byb3ZpZGVyRmFjdG9yeSIsIl9sb2FkX3Byb3ZpZGVyRmFjdG9yeSIsIl9fZXNNb2R1bGUiLCJuZXdPYmoiLCJFdmVudEVtaXR0ZXIiLCJhcHAiLCJhdXRvRG93bmxvYWQiLCJhbGxvd1ByZXJlbGVhc2UiLCJmdWxsQ2hhbmdlbG9nIiwiYWxsb3dEb3duZ3JhZGUiLCJfY2hhbm5lbCIsIl9sb2dnZXIiLCJzaWduYWxzIiwidXBkYXRlQXZhaWxhYmxlIiwic3RhZ2luZ1VzZXJJZFByb21pc2UiLCJMYXp5IiwiZ2V0T3JDcmVhdGVTdGFnaW5nVXNlcklkIiwiY29uZmlnT25EaXNrIiwibG9hZFVwZGF0ZUNvbmZpZyIsIl9fdGVzdF9hcHAiLCJ1bnRpbEFwcFJlYWR5IiwiaHR0cEV4ZWN1dG9yIiwiRWxlY3Ryb25IdHRwRXhlY3V0b3IiLCJhdXRoSW5mbyIsImNhbGxiYWNrIiwiaXNSZWFkeSIsImN1cnJlbnRWZXJzaW9uU3RyaW5nIiwiZ2V0VmVyc2lvbiIsImN1cnJlbnRWZXJzaW9uIiwidmFsaWQiLCJoYXNQcmVyZWxlYXNlQ29tcG9uZW50cyIsInNldEZlZWRVUkwiLCJsb2dnZXIiLCJ1cGRhdGVDb25maWdQYXRoIiwiY2xpZW50UHJvbWlzZSIsIl9hcHBVcGRhdGVDb25maWdQYXRoIiwicHJvdmlkZXIiLCJnZXRGZWVkVVJMIiwiR2VuZXJpY1Byb3ZpZGVyIiwiY3JlYXRlQ2xpZW50IiwiY2hlY2tGb3JVcGRhdGVzIiwiY2hlY2tGb3JVcGRhdGVzUHJvbWlzZSIsIl9jaGVja0ZvclVwZGF0ZXMiLCJudWxsaXplUHJvbWlzZSIsImNoZWNrRm9yVXBkYXRlc0FuZE5vdGlmeSIsIk5vdGlmaWNhdGlvbiIsInRpdGxlIiwiYm9keSIsImdldE5hbWUiLCJzaG93IiwiaXNTdGFnaW5nTWF0Y2giLCJfdGhpcyIsImNvcm91dGluZSIsInJhd1N0YWdpbmdQZXJjZW50YWdlIiwic3RhZ2luZ1BlcmNlbnRhZ2UiLCJpc05hTiIsIndhcm4iLCJzdGFnaW5nVXNlcklkIiwicmVhZFVJbnQzMkJFIiwicGVyY2VudGFnZSIsIl90aGlzMiIsImRvQ2hlY2tGb3JVcGRhdGVzIiwiY29tcHV0ZUZpbmFsSGVhZGVycyIsIl90aGlzMyIsImNsaWVudCIsImdldExhdGVzdFZlcnNpb24iLCJsYXRlc3RWZXJzaW9uIiwiZXEiLCJndCIsInZlcnNpb25JbmZvIiwib25VcGRhdGVBdmFpbGFibGUiLCJkb3dubG9hZFByb21pc2UiLCJkb3dubG9hZFVwZGF0ZSIsIl90aGlzNCIsImRpc3BhdGNoRXJyb3IiLCJkb0Rvd25sb2FkVXBkYXRlIiwiX3RoaXM1IiwiZ2V0QXBwUGF0aCIsInJlc291cmNlc1BhdGgiLCJjb21wdXRlUmVxdWVzdEhlYWRlcnMiLCJfdGhpczYiLCJBY2NlcHQiLCJfdGhpczciLCJmaWxlIiwiZ2V0UGF0aCIsImlkIiwiY2hlY2siLCJ2NSIsInJhbmRvbUJ5dGVzIiwiT0lEIiwib3V0cHV0RmlsZSIsInZlcnNpb25QcmVyZWxlYXNlQ29tcG9uZW50IiwicHJlcmVsZWFzZSIsImpzb25GaWxlIiwicmVhZEpzb24iLCJyZWFkSnNvblN5bmMiLCJyZWFkRmlsZVN5bmMiLCJ3cml0ZUpzb24iLCJ3cml0ZUpzb25TeW5jIiwid3JpdGVGaWxlU3luYyIsInlhbWwiLCJpbnN0YWxsIiwiY29tcHV0ZU9wZXJhdGlvbnMiLCJPcGVyYXRpb25LaW5kIiwib2xkQmxvY2tNYXAiLCJuZXdCbG9ja01hcCIsIm5hbWVUb09sZEJsb2NrcyIsImJ1aWxkQmxvY2tGaWxlTWFwIiwibmFtZVRvTmV3QmxvY2tzIiwib2xkRW50cnlNYXAiLCJidWlsZEVudHJ5TWFwIiwibGFzdE9wZXJhdGlvbiIsIm9wZXJhdGlvbnMiLCJibG9ja01hcEZpbGUiLCJvbGRFbnRyeSIsIkRPV05MT0FEIiwic3RhcnQiLCJvZmZzZXQiLCJlbmQiLCJzaXplcyIsInJlZHVjZSIsImFjY3VtdWxhdG9yIiwiY3VycmVudFZhbHVlIiwibmV3RmlsZSIsImNoYW5nZWRCbG9ja0NvdW50IiwiY2hlY2tzdW1Ub09mZnNldCIsImNoZWNrc3VtVG9PbGRPZmZzZXQiLCJjaGVja3N1bVRvT2xkU2l6ZSIsImJ1aWxkQ2hlY2tzdW1NYXAiLCJuZXdPZmZzZXQiLCJjaGVja3N1bXMiLCJibG9ja1NpemUiLCJjaGVja3N1bSIsIm9sZE9mZnNldCIsIkNPUFkiLCJmaWxlT2Zmc2V0IiwiTWFwIiwiY2hlY2tzdW1Ub1NpemUiLCJzaXplIiwibGlzdCIsIml0ZW0iLCJvcmlnaW5hbENvbnNvbGUiLCJ0cmFuc3BvcnQiLCJtc2ciLCJ0ZXh0IiwiRU9MIiwiZm9ybWF0VGltZVpvbmUiLCJwYWQiLCJzdHJpbmdpZnlBcnJheSIsImZvcm1hdHRlciIsImRhdGUiLCJnZXRGdWxsWWVhciIsImdldE1vbnRoIiwiZ2V0RGF0ZSIsImdldEhvdXJzIiwiZ2V0TWludXRlcyIsImdldFNlY29uZHMiLCJnZXRNaWxsaXNlY29uZHMiLCJnZXRUaW1lem9uZU9mZnNldCIsImZvcm1hdEVycm9ycyIsImFyZyIsInplcm9zIiwibWludXRlc09mZnNldCIsIk1hdGgiLCJhYnMiLCJmbG9vciIsIk5FWFRfRklMVEVSIiwiY2F0Y2hGaWx0ZXIiLCJpbnN0YW5jZXMiLCJib3VuZFRvIiwiX2JvdW5kVmFsdWUiLCJwcmVkaWNhdGVMb29wIiwibWF0Y2hlc1ByZWRpY2F0ZSIsImVycm9ycyIsImlzVW50eXBlZEVycm9yIiwickVycm9yS2V5Iiwid3JhcEFzT3BlcmF0aW9uYWxFcnJvciIsIm5vZGViYWNrRm9yUHJvbWlzZSIsIm11bHRpQXJncyIsIndyYXBwZWQiLCJfYXR0YWNoRXh0cmFUcmFjZSIsIl9yZWplY3QiLCJfZnVsZmlsbCIsIiRfbGVuIiwibWF4IiwiJF9pIiwicGFyZW50IiwicGFyZW50Q2FuY2VsSGFuZGxlciIsIl9jYW5jZWxsZWQiLCJjYW5jZWxsZWQiLCJfcGFyZW50IiwicmVtb3ZlUGFyZW50Q2FuY2VsSGFuZGxlciIsImNhbmNlbCIsIm9uQ2FuY2VsIiwib25jZSIsImNyZWF0ZVByb21pc2UiLCJjYW5jZWxIYW5kbGVyIiwiYWRkZWRDYW5jZWxIYW5kbGVyIiwiZmluYWxseSIsInJlbW92ZUxpc3RlbmVyIiwiZGlzcG9zZSIsInJlbW92ZUFsbExpc3RlbmVycyIsIl9kZWJ1ZzIiLCJfc3RyZWFtIiwiX2xvYWRfc3RyZWFtIiwiX2luZGV4IiwiX2xvYWRfaW5kZXgiLCJyZXNwb25zZSIsImRlc2NyaXB0aW9uIiwic3RhdHVzQ29kZSIsInN0YXR1c01lc3NhZ2UiLCJzdHJpbmdpZnkiLCJIVFRQX1NUQVRVU19DT0RFUyIsIm1heFJlZGlyZWN0cyIsImVuY29kZWREYXRhIiwiQnVmZmVyIiwiZG9BcGlSZXF1ZXN0IiwicmVxdWVzdFByb2Nlc3NvciIsInJlZGlyZWN0Q291bnQiLCJlbmFibGVkIiwiZG9SZXF1ZXN0IiwiaGFuZGxlUmVzcG9uc2UiLCJhZGRFcnJvckFuZFRpbWVvdXRIYW5kbGVycyIsImFkZFJlZGlyZWN0SGFuZGxlcnMiLCJhYm9ydCIsImFkZFRpbWVPdXRIYW5kbGVyIiwicmVkaXJlY3RVcmwiLCJwcmVwYXJlUmVkaXJlY3RVcmxPcHRpb25zIiwic2V0RW5jb2RpbmciLCJjaHVuayIsImNvbnRlbnRUeXBlIiwiaXNKc29uIiwiaW5jbHVkZXMiLCJkb0Rvd25sb2FkIiwicmVxdWVzdE9wdGlvbnMiLCJkZXN0aW5hdGlvbiIsImNvbmZpZ3VyZVBpcGVzIiwic29ja2V0Iiwic2V0VGltZW91dCIsIm5ld09wdGlvbnMiLCJBdXRob3JpemF0aW9uIiwic3RhcnRzV2l0aCIsInBhcnNlZE5ld1VybCIsInBhcnNlZFVybCIsIlRyYW5zZm9ybSIsImV4cGVjdGVkIiwiYWxnb3JpdGhtIiwiZW5jb2RpbmciLCJpc1ZhbGlkYXRlT25FbmQiLCJkaWdlc3RlciIsImNyZWF0ZUhhc2giLCJhY3R1YWwiLCJfYWN0dWFsIiwiX3RyYW5zZm9ybSIsInVwZGF0ZSIsIl9mbHVzaCIsImRpZ2VzdCIsInZhbGlkYXRlIiwiY2hlY2tTaGEyIiwic2hhMkhlYWRlciIsImhlYWRlcktleSIsInN0cmVhbXMiLCJvblByb2dyZXNzIiwiY29udGVudExlbmd0aCIsImZpbGVPdXQiLCJsYXN0U3RyZWFtIiwic3RyZWFtIiwicGlwZSIsInRva2VuIiwiYXV0aG9yaXphdGlvbiIsImVsZWN0cm9uIiwic2tpcHBlZE5hbWVzIiwiY3JlYXRlRGVidWciLCJjb2VyY2UiLCJkaXNhYmxlIiwiZW5hYmxlIiwiaHVtYW5pemUiLCJza2lwcyIsImZvcm1hdHRlcnMiLCJzZWxlY3RDb2xvciIsIm5hbWVzcGFjZSIsImhhc2giLCJjb2xvcnMiLCJwcmV2VGltZSIsImN1cnIiLCJEYXRlIiwibXMiLCJkaWZmIiwicHJldiIsInVuc2hpZnQiLCJmb3JtYXRBcmdzIiwibG9nRm4iLCJ1c2VDb2xvcnMiLCJjb2xvciIsImluaXQiLCJuYW1lc3BhY2VzIiwic2F2ZSIsIlJlZ0V4cCIsImluc3RhbmNlIiwiYXBpIiwiZXhpc3RzIiwiZmlsZW5hbWUiLCJidWZmZXIiLCJwb3NpdGlvbiIsImJ5dGVzUmVhZCIsIndyaXRlIiwiYSIsImIiLCJjIiwiYnl0ZXNXcml0dGVuIiwiY2xvbmUiLCJjb3B5IiwiX19wcm90b19fIiwidXRpbWVzIiwidXRpbWVzTWlsbGlzIiwibm90RXhpc3QiLCJleGlzdHNSZWciLCJzcmMiLCJkZXN0Iiwib3B0cyIsImNsb2JiZXIiLCJvdmVyd3JpdGUiLCJwcmVzZXJ2ZVRpbWVzdGFtcHMiLCJoYW5kbGVGaWx0ZXIiLCJjaGVja1BhcmVudERpciIsImRlc3RQYXJlbnQiLCJkaXJuYW1lIiwiZGlyRXhpc3RzIiwic3RhcnRDb3B5IiwiZ2V0U3RhdHMiLCJvbkluY2x1ZGUiLCJzdGF0IiwiZGVyZWZlcmVuY2UiLCJsc3RhdCIsInN0IiwiaXNEaXJlY3RvcnkiLCJvbkRpciIsImlzRmlsZSIsImlzQ2hhcmFjdGVyRGV2aWNlIiwiaXNCbG9ja0RldmljZSIsIm9uRmlsZSIsImlzU3ltYm9saWNMaW5rIiwib25MaW5rIiwic3JjU3RhdCIsImNoZWNrRGVzdCIsInJlc29sdmVkUGF0aCIsImNvcHlGaWxlIiwibWF5Q29weUZpbGUiLCJ1bmxpbmsiLCJlcnJvck9uRXhpc3QiLCJzZXREZXN0TW9kZUFuZFRpbWVzdGFtcHMiLCJjb3B5RmlsZUZhbGxiYWNrIiwicnMiLCJ3cyIsImNobW9kIiwiYXRpbWUiLCJtdGltZSIsImlzU3JjU3ViZGlyIiwibWtEaXJBbmRDb3B5IiwibWF5Q29weURpciIsImNvcHlEaXIiLCJta2RpciIsIml0ZW1zIiwiY29weURpckl0ZW1zIiwicG9wIiwicmVhZGxpbmsiLCJyZXNvbHZlZFNyY1BhdGgiLCJjd2QiLCJyZXNvbHZlZERlc3RQYXRoIiwic3ltbGluayIsImNvcHlMaW5rIiwiYmFzZURpciIsInNlcCIsImRlc3RCYXNlbmFtZSIsImJhc2VuYW1lIiwiZ2V0Um9vdFBhdGgiLCJJTlZBTElEX1BBVEhfQ0hBUlMiLCJpbnZhbGlkV2luMzJQYXRoIiwicnAiLCJvcyIsImhhc01pbGxpc1Jlc1N5bmMiLCJ0bXBmaWxlIiwibm93IiwicmFuZG9tIiwidG1wZGlyIiwiZCIsIm9wZW5TeW5jIiwiZnV0aW1lc1N5bmMiLCJzdGF0U3luYyIsImhhc01pbGxpc1JlcyIsImZ1dGltZXMiLCJzdGF0cyIsInRpbWVSZW1vdmVNaWxsaXMiLCJ0aW1lc3RhbXAiLCJnZXRUaW1lIiwiZnV0aW1lc0VyciIsImNsb3NlRXJyIiwidXRpbWVzTWlsbGlzU3luYyIsImNvcHlTeW5jIiwiYWxsb2NVbnNhZmUiLCJ0b3RhbCIsInRyYW5zZmVycmVkIiwiZGVsdGEiLCJuZXh0VXBkYXRlIiwicGVyY2VudCIsImJ5dGVzUGVyU2Vjb25kIiwicm91bmQiLCJTZW1WZXIiLCJTRU1WRVJfU1BFQ19WRVJTSU9OIiwiTUFYX0xFTkdUSCIsIk1BWF9TQUZFX0lOVEVHRVIiLCJyZSIsIlIiLCJOVU1FUklDSURFTlRJRklFUiIsIk5VTUVSSUNJREVOVElGSUVSTE9PU0UiLCJOT05OVU1FUklDSURFTlRJRklFUiIsIk1BSU5WRVJTSU9OIiwiTUFJTlZFUlNJT05MT09TRSIsIlBSRVJFTEVBU0VJREVOVElGSUVSIiwiUFJFUkVMRUFTRUlERU5USUZJRVJMT09TRSIsIlBSRVJFTEVBU0UiLCJQUkVSRUxFQVNFTE9PU0UiLCJCVUlMRElERU5USUZJRVIiLCJCVUlMRCIsIkZVTEwiLCJGVUxMUExBSU4iLCJMT09TRVBMQUlOIiwiTE9PU0UiLCJHVExUIiwiWFJBTkdFSURFTlRJRklFUkxPT1NFIiwiWFJBTkdFSURFTlRJRklFUiIsIlhSQU5HRVBMQUlOIiwiWFJBTkdFUExBSU5MT09TRSIsIlhSQU5HRSIsIlhSQU5HRUxPT1NFIiwiTE9ORVRJTERFIiwiVElMREVUUklNIiwidGlsZGVUcmltUmVwbGFjZSIsIlRJTERFIiwiVElMREVMT09TRSIsIkxPTkVDQVJFVCIsIkNBUkVUVFJJTSIsImNhcmV0VHJpbVJlcGxhY2UiLCJDQVJFVCIsIkNBUkVUTE9PU0UiLCJDT01QQVJBVE9STE9PU0UiLCJDT01QQVJBVE9SIiwiQ09NUEFSQVRPUlRSSU0iLCJjb21wYXJhdG9yVHJpbVJlcGxhY2UiLCJIWVBIRU5SQU5HRSIsIkhZUEhFTlJBTkdFTE9PU0UiLCJTVEFSIiwibG9vc2UiLCJlciIsImNsZWFuIiwidHJpbSIsInJhdyIsIm1ham9yIiwibWlub3IiLCJudW0iLCJidWlsZCIsImNvbXBhcmUiLCJvdGhlciIsImNvbXBhcmVNYWluIiwiY29tcGFyZVByZSIsImNvbXBhcmVJZGVudGlmaWVycyIsImluYyIsInJlbGVhc2UiLCJpZGVudGlmaWVyIiwidmVyc2lvbjEiLCJ2ZXJzaW9uMiIsInYxIiwidjIiLCJudW1lcmljIiwiYW51bSIsImJudW0iLCJyY29tcGFyZUlkZW50aWZpZXJzIiwiY29tcGFyZUxvb3NlIiwicmNvbXBhcmUiLCJyc29ydCIsImx0IiwibmVxIiwiZ3RlIiwibHRlIiwib3AiLCJDb21wYXJhdG9yIiwiY29tcCIsInNlbXZlciIsIkFOWSIsIm9wZXJhdG9yIiwiaW50ZXJzZWN0cyIsInJhbmdlVG1wIiwiUmFuZ2UiLCJzYXRpc2ZpZXMiLCJzYW1lRGlyZWN0aW9uSW5jcmVhc2luZyIsInNhbWVEaXJlY3Rpb25EZWNyZWFzaW5nIiwic2FtZVNlbVZlciIsImRpZmZlcmVudERpcmVjdGlvbnNJbmNsdXNpdmUiLCJvcHBvc2l0ZURpcmVjdGlvbnNMZXNzVGhhbiIsIm9wcG9zaXRlRGlyZWN0aW9uc0dyZWF0ZXJUaGFuIiwicmFuZ2UiLCJwYXJzZVJhbmdlIiwiY29tcHMiLCJociIsImh5cGhlblJlcGxhY2UiLCJjb21wUmUiLCJwYXJzZUNvbXBhcmF0b3IiLCJ0aGlzQ29tcGFyYXRvcnMiLCJ0aGlzQ29tcGFyYXRvciIsInJhbmdlQ29tcGFyYXRvcnMiLCJyYW5nZUNvbXBhcmF0b3IiLCJ0b0NvbXBhcmF0b3JzIiwicmVwbGFjZUNhcmV0cyIsInJlcGxhY2VUaWxkZXMiLCJyZXBsYWNlWFJhbmdlcyIsInJlcGxhY2VTdGFycyIsImlzWCIsInJlcGxhY2VUaWxkZSIsIl8iLCJNIiwicHIiLCJyZXBsYWNlQ2FyZXQiLCJyZXBsYWNlWFJhbmdlIiwiZ3RsdCIsInhNIiwieG0iLCJ4cCIsImFueVgiLCIkMCIsImZNIiwiZm0iLCJmcCIsImZwciIsImZiIiwidE0iLCJ0bSIsInRwIiwidHByIiwidGIiLCJ0ZXN0U2V0IiwiYWxsb3dlZCIsIm1heFNhdGlzZnlpbmciLCJtYXhTViIsInJhbmdlT2JqIiwibWluU2F0aXNmeWluZyIsIm1pbiIsIm1pblNWIiwidmFsaWRSYW5nZSIsImx0ciIsIm91dHNpZGUiLCJndHIiLCJoaWxvIiwiZ3RmbiIsImx0ZWZuIiwibHRmbiIsImVjb21wIiwiY29tcGFyYXRvcnMiLCJoaWdoIiwibG93IiwiY29tcGFyYXRvciIsInIxIiwicjIiLCJiYXNlNjRWTFEiLCJBcnJheVNldCIsIk1hcHBpbmdMaXN0IiwiU291cmNlTWFwR2VuZXJhdG9yIiwiX2ZpbGUiLCJfc291cmNlUm9vdCIsIl9za2lwVmFsaWRhdGlvbiIsIl9zb3VyY2VzIiwiX25hbWVzIiwiX21hcHBpbmdzIiwiX3NvdXJjZXNDb250ZW50cyIsIl92ZXJzaW9uIiwiZnJvbVNvdXJjZU1hcCIsIlNvdXJjZU1hcEdlbmVyYXRvcl9mcm9tU291cmNlTWFwIiwiYVNvdXJjZU1hcENvbnN1bWVyIiwiZ2VuZXJhdG9yIiwiZWFjaE1hcHBpbmciLCJuZXdNYXBwaW5nIiwiZ2VuZXJhdGVkIiwibGluZSIsImNvbHVtbiIsIm9yaWdpbmFsIiwiYWRkTWFwcGluZyIsInNvdXJjZXMiLCJzb3VyY2VGaWxlIiwic291cmNlUmVsYXRpdmUiLCJhZGQiLCJjb250ZW50Iiwic291cmNlQ29udGVudEZvciIsInNldFNvdXJjZUNvbnRlbnQiLCJTb3VyY2VNYXBHZW5lcmF0b3JfYWRkTWFwcGluZyIsIl92YWxpZGF0ZU1hcHBpbmciLCJTb3VyY2VNYXBHZW5lcmF0b3Jfc2V0U291cmNlQ29udGVudCIsImFTb3VyY2VGaWxlIiwiYVNvdXJjZUNvbnRlbnQiLCJhcHBseVNvdXJjZU1hcCIsIlNvdXJjZU1hcEdlbmVyYXRvcl9hcHBseVNvdXJjZU1hcCIsImFTb3VyY2VNYXBQYXRoIiwibmV3U291cmNlcyIsIm5ld05hbWVzIiwidW5zb3J0ZWRGb3JFYWNoIiwib3JpZ2luYWxQb3NpdGlvbkZvciIsIlNvdXJjZU1hcEdlbmVyYXRvcl92YWxpZGF0ZU1hcHBpbmciLCJhR2VuZXJhdGVkIiwiYU9yaWdpbmFsIiwiYVNvdXJjZSIsIl9zZXJpYWxpemVNYXBwaW5ncyIsIlNvdXJjZU1hcEdlbmVyYXRvcl9zZXJpYWxpemVNYXBwaW5ncyIsInByZXZpb3VzR2VuZXJhdGVkQ29sdW1uIiwicHJldmlvdXNHZW5lcmF0ZWRMaW5lIiwicHJldmlvdXNPcmlnaW5hbENvbHVtbiIsInByZXZpb3VzT3JpZ2luYWxMaW5lIiwicHJldmlvdXNOYW1lIiwicHJldmlvdXNTb3VyY2UiLCJuYW1lSWR4Iiwic291cmNlSWR4IiwibWFwcGluZ3MiLCJlbmNvZGUiLCJfZ2VuZXJhdGVTb3VyY2VzQ29udGVudCIsIlNvdXJjZU1hcEdlbmVyYXRvcl9nZW5lcmF0ZVNvdXJjZXNDb250ZW50IiwiYVNvdXJjZXMiLCJhU291cmNlUm9vdCIsInRvSlNPTiIsIlNvdXJjZU1hcEdlbmVyYXRvcl90b0pTT04iLCJzb3VyY2VzQ29udGVudCIsIlNvdXJjZU1hcEdlbmVyYXRvcl90b1N0cmluZyIsImJhc2U2NCIsIlZMUV9CQVNFX1NISUZUIiwiVkxRX0JBU0UiLCJWTFFfQkFTRV9NQVNLIiwiVkxRX0NPTlRJTlVBVElPTl9CSVQiLCJ0b1ZMUVNpZ25lZCIsImFWYWx1ZSIsImZyb21WTFFTaWduZWQiLCJpc05lZ2F0aXZlIiwic2hpZnRlZCIsImJhc2U2NFZMUV9lbmNvZGUiLCJlbmNvZGVkIiwiZGlnaXQiLCJ2bHEiLCJkZWNvZGUiLCJiYXNlNjRWTFFfZGVjb2RlIiwiYUluZGV4IiwiYU91dFBhcmFtIiwic3RyTGVuIiwiY29udGludWF0aW9uIiwicmVzdCIsImhhc05hdGl2ZU1hcCIsIl9hcnJheSIsIl9zZXQiLCJmcm9tQXJyYXkiLCJBcnJheVNldF9mcm9tQXJyYXkiLCJhQXJyYXkiLCJhQWxsb3dEdXBsaWNhdGVzIiwiQXJyYXlTZXRfc2l6ZSIsIkFycmF5U2V0X2FkZCIsInNTdHIiLCJpc0R1cGxpY2F0ZSIsImlkeCIsIkFycmF5U2V0X2hhcyIsIkFycmF5U2V0X2luZGV4T2YiLCJhdCIsIkFycmF5U2V0X2F0IiwiYUlkeCIsIkFycmF5U2V0X3RvQXJyYXkiLCJjb25maWd1cmF0aW9uIiwidXBkYXRlciIsImNoYW5uZWxVcmwiLCJhdHRlbXB0TnVtYmVyIiwicmVsZWFzZUpzb25VcmwiLCJHaXRIdWJQcm92aWRlciIsIkJhc2VHaXRIdWJQcm92aWRlciIsImNvbXB1dGVSZWxlYXNlTm90ZXMiLCJkZWZhdWx0SG9zdCIsImNvbXB1dGVHaXRodWJCYXNlUGF0aCIsImJhc2VQYXRoIiwiZmVlZFhtbCIsImZlZWQiLCJsYXRlc3RSZWxlYXNlIiwiZWxlbWVudCIsImF0dHJpYnV0ZSIsImdldExhdGVzdFZlcnNpb25TdHJpbmciLCJnZXRCYXNlRG93bmxvYWRQYXRoIiwicmVsZWFzZU5hbWUiLCJlbGVtZW50VmFsdWVPckVtcHR5IiwicmVsZWFzZU5vdGVzIiwicmVsZWFzZUluZm8iLCJ0YWdfbmFtZSIsIm93bmVyIiwicmVwbyIsImZpbGVOYW1lIiwidlByZWZpeGVkVGFnTmFtZSIsImdldE5vdGVWYWx1ZSIsImlzRnVsbENoYW5nZWxvZyIsImdldEVsZW1lbnRzIiwidmVyc2lvblJlbGVhc2UiLCJub3RlIiwiQmFzZVVwZGF0ZXIiLCJfb3MiLCJfbG9hZF9vcyIsIl9Eb3dubG9hZGVkVXBkYXRlSGVscGVyIiwiX2xvYWRfRG93bmxvYWRlZFVwZGF0ZUhlbHBlciIsImRvd25sb2FkZWRVcGRhdGVIZWxwZXIiLCJEb3dubG9hZGVkVXBkYXRlSGVscGVyIiwicXVpdEFuZEluc3RhbGxDYWxsZWQiLCJxdWl0SGFuZGxlckFkZGVkIiwicXVpdEFuZEluc3RhbGwiLCJpc1NpbGVudCIsImlzRm9yY2VSdW5BZnRlciIsInNldEltbWVkaWF0ZSIsInF1aXQiLCJleGVjdXRlRG93bmxvYWQiLCJkb3dubG9hZE9wdGlvbnMiLCJ0YXNrIiwibGlzdGVuZXJDb3VudCIsInRlbXBEaXIiLCJta2R0ZW1wIiwiVEVTVF9BUFBfVE1QX0RJUiIsInJlbW92ZVRlbXBEaXJJZkFueSIsImNsZWFyIiwiZGVzdGluYXRpb25GaWxlIiwicG9zaXgiLCJpc1J1bkFmdGVyIiwiaW5zdGFsbGVyUGF0aCIsImRvSW5zdGFsbCIsImFkZFF1aXRIYW5kbGVyIiwiRmlsZVdpdGhFbWJlZGRlZEJsb2NrTWFwRGlmZmVyZW50aWFsRG93bmxvYWRlciIsIl9ibG9ja01hcEFwaSIsIl9sb2FkX2Jsb2NrTWFwQXBpIiwiX0RpZmZlcmVudGlhbERvd25sb2FkZXIiLCJfbG9hZF9EaWZmZXJlbnRpYWxEb3dubG9hZGVyIiwiRGlmZmVyZW50aWFsRG93bmxvYWRlciIsImRvd25sb2FkIiwiYmxvY2tBd2FyZUZpbGVJbmZvIiwiZmlsZVNpemUiLCJibG9ja01hcFNpemUiLCJmaWxlTWV0YWRhdGFCdWZmZXIiLCJyZWFkUmVtb3RlQnl0ZXMiLCJyZWFkQmxvY2tNYXAiLCJyZWFkRW1iZWRkZWRCbG9ja01hcERhdGEiLCJvbGRGaWxlIiwiQkxPQ0tfTUFQX0ZJTEVfTkFNRSIsIl9yZWYiLCJmc3RhdCIsInNpemVCdWZmZXIiLCJkYXRhQnVmZmVyIiwiaW5mbGF0ZVJhdyIsIl94IiwiRGlmZmVyZW50aWFsRG93bmxvYWRlck9wdGlvbnMiLCJfRGF0YVNwbGl0dGVyIiwiX2xvYWRfRGF0YVNwbGl0dGVyIiwiX2Rvd25sb2FkUGxhbkJ1aWxkZXIiLCJfbG9hZF9kb3dubG9hZFBsYW5CdWlsZGVyIiwiX211bHRpcGxlUmFuZ2VEb3dubG9hZGVyIiwiX2xvYWRfbXVsdGlwbGVSYW5nZURvd25sb2FkZXIiLCJiYXNlUmVxdWVzdE9wdGlvbnMiLCJuZXdVcmwiLCJzaWduYXR1cmVTaXplIiwiZG93bmxvYWRTaXplIiwiY29weVNpemUiLCJvcGVyYXRpb24iLCJuZXdQYWNrYWdlU2l6ZSIsImZvcm1hdEJ5dGVzIiwiZG93bmxvYWRGaWxlIiwidGFza3MiLCJzaWduYXR1cmUiLCJvbGRGaWxlRmQiLCJuZXdGaWxlRmQiLCJkaWdlc3RUcmFuc2Zvcm0iLCJmaXJzdFN0cmVhbSIsInciLCJleGVjdXRlVGFza3MiLCJhdHRlbXB0Q291bnQiLCJhY3R1YWxVcmwiLCJjb3B5RGF0YSIsInJlZGlyZWN0IiwicmVtb3ZlUXVlcnkiLCJmb2xsb3dSZWRpcmVjdCIsImVuZEluY2x1c2l2ZSIsImRhdGFIYW5kbGVyIiwiY2hlY2tJc1Jhbmdlc1N1cHBvcnRlZCIsInN5bWJvbCIsIkludGwiLCJOdW1iZXJGb3JtYXQiLCJ0b0ZpeGVkIiwiRGF0YVNwbGl0dGVyIiwiRE9VQkxFX0NSTEYiLCJSZWFkU3RhdGUiLCJvdXQiLCJyZWFkU3RyZWFtIiwiV3JpdGFibGUiLCJwYXJ0SW5kZXhUb1Rhc2tJbmRleCIsImJvdW5kYXJ5IiwicGFydEluZGV4VG9MZW5ndGgiLCJmaW5pc2hIYW5kbGVyIiwicGFydEluZGV4IiwiaGVhZGVyTGlzdEJ1ZmZlciIsInJlYWRTdGF0ZSIsIklOSVQiLCJpZ25vcmVCeXRlQ291bnQiLCJyZW1haW5pbmdQYXJ0RGF0YUNvdW50IiwiYWN0dWFsUGFydExlbmd0aCIsImJvdW5kYXJ5TGVuZ3RoIiwiaXNGaW5pc2hlZCIsIl93cml0ZSIsImhhbmRsZURhdGEiLCJ0b0lnbm9yZSIsInRvUmVhZCIsInByb2Nlc3NQYXJ0RGF0YSIsIkhFQURFUiIsImhlYWRlckxpc3RFbmQiLCJzZWFyY2hIZWFkZXJMaXN0RW5kIiwiQk9EWSIsInRhc2tJbmRleCIsInByZXZUYXNrSW5kZXgiLCJjb3B5RXhpc3RpbmdEYXRhIiwib25QYXJ0RW5kIiwicGFydExlbmd0aCIsImVmZmVjdGl2ZUVuZCIsInByb2Nlc3NQYXJ0U3RhcnRlZCIsInJlYWRPZmZzZXQiLCJwYXJ0aWFsQ2h1bmsiLCJjb25jYXQiLCJleHBlY3RlZExlbmd0aCIsImNvbnRleHQiLCJ2ZXJib3NlIiwic2lsbHkiLCJtYWtlU2VsZlJlc29sdXRpb25FcnJvciIsInJlZmxlY3RIYW5kbGVyIiwiUHJvbWlzZUluc3BlY3Rpb24iLCJfdGFyZ2V0IiwiYXBpUmVqZWN0aW9uIiwiUHJveHlhYmxlIiwiVU5ERUZJTkVEX0JJTkRJTkciLCJnZXREb21haW4iLCJkb21haW4iLCJBc3luYyIsImFzeW5jIiwiSU5URVJOQUwiLCJBUFBMWSIsInRyeUNvbnZlcnRUb1Byb21pc2UiLCJQcm9taXNlQXJyYXkiLCJDb250ZXh0IiwiY3JlYXRlQ29udGV4dCIsIkNhcHR1cmVkVHJhY2UiLCJQYXNzVGhyb3VnaEhhbmRsZXJDb250ZXh0IiwiX2JpdEZpZWxkIiwiX2Z1bGZpbGxtZW50SGFuZGxlcjAiLCJfcmVqZWN0aW9uSGFuZGxlcjAiLCJfcHJvbWlzZTAiLCJfcmVjZWl2ZXIwIiwiX3Jlc29sdmVGcm9tRXhlY3V0b3IiLCJfcHJvbWlzZUNyZWF0ZWQiLCJfZmlyZUV2ZW50IiwiY2F1Z2h0IiwiY2F0Y2hJbnN0YW5jZXMiLCJyZWZsZWN0IiwiX3RoZW4iLCJkaWRGdWxmaWxsIiwiZGlkUmVqZWN0Iiwid2FybmluZ3MiLCJfd2FybiIsIl9zZXRJc0ZpbmFsIiwic3ByZWFkIiwiYWxsIiwiaXNGdWxmaWxsZWQiLCJpc1JlamVjdGVkIiwiZnVsZmlsbG1lbnRWYWx1ZSIsInJlamVjdGlvblJlYXNvbiIsImdldE5ld0xpYnJhcnlDb3B5IiwiaXMiLCJmcm9tTm9kZSIsIl9jYXB0dXJlU3RhY2tUcmFjZSIsIl9yZWplY3RDYWxsYmFjayIsIl9pc0ZhdGVTZWFsZWQiLCJfc2V0QXN5bmNHdWFyYW50ZWVkIiwicHJvbWlzZXMiLCJjYXN0IiwiX3NldEZ1bGZpbGxlZCIsImZ1bGZpbGxlZCIsInJlamVjdGVkIiwic2V0U2NoZWR1bGVyIiwicmVjZWl2ZXIiLCJpbnRlcm5hbERhdGEiLCJoYXZlSW50ZXJuYWxEYXRhIiwiYml0RmllbGQiLCJfcHJvcGFnYXRlRnJvbSIsIl9ib3VuZFRvIiwic2V0dGxlciIsIl9zZXR0bGVQcm9taXNlQ3R4IiwiX3Vuc2V0UmVqZWN0aW9uSXNVbmhhbmRsZWQiLCJfc2V0dGxlUHJvbWlzZUxhdGVDYW5jZWxsYXRpb25PYnNlcnZlciIsImludm9rZSIsIl9hZGRDYWxsYmFja3MiLCJfbGVuZ3RoIiwiX2lzRm9sbG93aW5nIiwiX3NldExlbmd0aCIsIl9zZXRSZWplY3RlZCIsIl9zZXRGb2xsb3dpbmciLCJfaXNGaW5hbCIsIl91bnNldENhbmNlbGxlZCIsIl9zZXRDYW5jZWxsZWQiLCJfc2V0V2lsbEJlQ2FuY2VsbGVkIiwiaGFzQ3VzdG9tU2NoZWR1bGVyIiwiX3JlY2VpdmVyQXQiLCJfaXNCb3VuZCIsIl9wcm9taXNlQXQiLCJfZnVsZmlsbG1lbnRIYW5kbGVyQXQiLCJfcmVqZWN0aW9uSGFuZGxlckF0IiwiX21pZ3JhdGVDYWxsYmFjazAiLCJmb2xsb3dlciIsImZ1bGZpbGwiLCJfbWlncmF0ZUNhbGxiYWNrQXQiLCJiYXNlIiwiX3Byb3h5IiwicHJveHlhYmxlIiwiX3Jlc29sdmVDYWxsYmFjayIsInNob3VsZEJpbmQiLCJtYXliZVByb21pc2UiLCJfc2V0Rm9sbG93ZWUiLCJfdmFsdWUiLCJfcmVhc29uIiwic3luY2hyb25vdXMiLCJpZ25vcmVOb25FcnJvcldhcm5pbmdzIiwidHJhY2UiLCJoYXNTdGFjayIsIl9wdXNoQ29udGV4dCIsIl9leGVjdXRlIiwiX3BvcENvbnRleHQiLCJfc2V0dGxlUHJvbWlzZUZyb21IYW5kbGVyIiwieCIsInByb21pc2VDcmVhdGVkIiwiY2hlY2tGb3Jnb3R0ZW5SZXR1cm5zIiwiX2ZvbGxvd2VlIiwiX3NldHRsZVByb21pc2UiLCJpc1Byb21pc2UiLCJhc3luY0d1YXJhbnRlZWQiLCJfaW52b2tlSW50ZXJuYWxPbkNhbmNlbCIsImlzRmluYWxseUhhbmRsZXIiLCJjYW5jZWxQcm9taXNlIiwiX3Byb21pc2VDYW5jZWxsZWQiLCJfY2FuY2VsIiwiX2lzUmVzb2x2ZWQiLCJfcHJvbWlzZUZ1bGZpbGxlZCIsIl9wcm9taXNlUmVqZWN0ZWQiLCJjdHgiLCJfc2V0dGxlUHJvbWlzZTAiLCJfY2xlYXJDYWxsYmFja0RhdGFBdEluZGV4IiwiX3NldHRsZVByb21pc2VzIiwic2V0dGxlUHJvbWlzZXMiLCJmYXRhbEVycm9yIiwiX2Vuc3VyZVBvc3NpYmxlUmVqZWN0aW9uSGFuZGxlZCIsIl9mdWxmaWxsUHJvbWlzZXMiLCJfcmVqZWN0UHJvbWlzZXMiLCJfY2xlYXJDYW5jZWxsYXRpb25EYXRhIiwiX3NldHRsZWRWYWx1ZSIsImRlZmVyUmVzb2x2ZSIsImRlZmVyUmVqZWN0IiwiZGVmZXIiLCJwZW5kaW5nIiwiZGVwcmVjYXRlZCIsImZpbGxUeXBlcyIsInNldEJvdW5kcyIsImZpcnN0TGluZUVycm9yIiwic2NoZWR1bGUiLCJRdWV1ZSIsIl9jdXN0b21TY2hlZHVsZXIiLCJfaXNUaWNrVXNlZCIsIl9sYXRlUXVldWUiLCJfbm9ybWFsUXVldWUiLCJfaGF2ZURyYWluZWRRdWV1ZXMiLCJfdHJhbXBvbGluZUVuYWJsZWQiLCJkcmFpblF1ZXVlcyIsIl9kcmFpblF1ZXVlcyIsIl9zY2hlZHVsZSIsImVuYWJsZVRyYW1wb2xpbmUiLCJkaXNhYmxlVHJhbXBvbGluZUlmTmVjZXNzYXJ5IiwiaGF2ZUl0ZW1zUXVldWVkIiwic3RkZXJyIiwiZXhpdCIsInRocm93TGF0ZXIiLCJBc3luY0ludm9rZUxhdGVyIiwiX3F1ZXVlVGljayIsIkFzeW5jSW52b2tlIiwiQXN5bmNTZXR0bGVQcm9taXNlcyIsIl9wdXNoT25lIiwiaW52b2tlTGF0ZXIiLCJfZHJhaW5RdWV1ZSIsIl9yZXNldCIsIm5vQXN5bmNTY2hlZHVsZXIiLCJOYXRpdmVQcm9taXNlIiwiTXV0YXRpb25PYnNlcnZlciIsIkdsb2JhbFNldEltbWVkaWF0ZSIsIlByb2Nlc3NOZXh0VGljayIsIm5leHRUaWNrIiwibmF0aXZlUHJvbWlzZSIsInN0YW5kYWxvbmUiLCJjb3Jkb3ZhIiwiZGl2IiwiZG9jdW1lbnQiLCJjcmVhdGVFbGVtZW50IiwiYXR0cmlidXRlcyIsInRvZ2dsZVNjaGVkdWxlZCIsImRpdjIiLCJvMiIsImNsYXNzTGlzdCIsInRvZ2dsZSIsIm9ic2VydmUiLCJzY2hlZHVsZVRvZ2dsZSIsImRpc2Nvbm5lY3QiLCJhcnJheU1vdmUiLCJzcmNJbmRleCIsImRzdCIsImRzdEluZGV4IiwiY2FwYWNpdHkiLCJfY2FwYWNpdHkiLCJfZnJvbnQiLCJfd2lsbEJlT3ZlckNhcGFjaXR5IiwiX2NoZWNrQ2FwYWNpdHkiLCJ3cmFwTWFzayIsImZyb250IiwiX3Jlc2l6ZVRvIiwib2xkQ2FwYWNpdHkiLCJtb3ZlSXRlbXNDb3VudCIsImdldFRoZW4iLCJpc0FueUJsdWViaXJkUHJvbWlzZSIsImRvVGhlbmFibGUiLCJkb0dldFRoZW4iLCJ0b1Jlc29sdXRpb25WYWx1ZSIsInZhbHVlcyIsIl9wcm9taXNlIiwiX3NldE9uQ2FuY2VsIiwiX3ZhbHVlcyIsIl90b3RhbFJlc29sdmVkIiwiX2luaXQiLCJyZXNvbHZlVmFsdWVJZkVtcHR5IiwiX3Jlc29sdmVFbXB0eUFycmF5IiwiX3Jlc29sdmUiLCJfaXRlcmF0ZSIsImdldEFjdHVhbExlbmd0aCIsInNob3VsZENvcHlWYWx1ZXMiLCJpc1Jlc29sdmVkIiwic3VwcHJlc3NVbmhhbmRsZWRSZWplY3Rpb25zIiwiX2lzQ2FuY2VsbGFibGUiLCJ0b3RhbFJlc29sdmVkIiwiX3Jlc3VsdENhbmNlbGxlZCIsImNvbnRleHRTdGFjayIsIl9wZWVrQ29udGV4dCIsIl90cmFjZSIsInBlZWtDb250ZXh0IiwibGFzdEluZGV4IiwiZGVhY3RpdmF0ZUxvbmdTdGFja1RyYWNlcyIsImFjdGl2YXRlTG9uZ1N0YWNrVHJhY2VzIiwiUHJvbWlzZV9wdXNoQ29udGV4dCIsIlByb21pc2VfcG9wQ29udGV4dCIsIlByb21pc2VfUGVla0NvbnRleHQiLCJQcm9taXNlX3BlZWtDb250ZXh0IiwiUHJvbWlzZV9wcm9taXNlQ3JlYXRlZCIsIl9nZXREb21haW4iLCJfYXN5bmMiLCJ1bmhhbmRsZWRSZWplY3Rpb25IYW5kbGVkIiwicG9zc2libHlVbmhhbmRsZWRSZWplY3Rpb24iLCJibHVlYmlyZEZyYW1lUGF0dGVybiIsIm5vZGVGcmFtZVBhdHRlcm4iLCJwYXJzZUxpbmVQYXR0ZXJuIiwic3RhY2tGcmFtZVBhdHRlcm4iLCJmb3JtYXRTdGFjayIsImluZGVudFN0YWNrRnJhbWVzIiwicHJpbnRXYXJuaW5nIiwiZGVidWdnaW5nIiwid0ZvcmdvdHRlblJldHVybiIsIl9zZXRSZWplY3Rpb25Jc1VuaGFuZGxlZCIsIl9ub3RpZnlVbmhhbmRsZWRSZWplY3Rpb24iLCJfbm90aWZ5VW5oYW5kbGVkUmVqZWN0aW9uSXNIYW5kbGVkIiwiZmlyZVJlamVjdGlvbkV2ZW50IiwiX3NldFJldHVybmVkTm9uVW5kZWZpbmVkIiwiX3JldHVybmVkTm9uVW5kZWZpbmVkIiwiX2lzUmVqZWN0aW9uVW5oYW5kbGVkIiwiX3NldFVuaGFuZGxlZFJlamVjdGlvbklzTm90aWZpZWQiLCJfdW5zZXRVbmhhbmRsZWRSZWplY3Rpb25Jc05vdGlmaWVkIiwiX2lzVW5oYW5kbGVkUmVqZWN0aW9uTm90aWZpZWQiLCJzaG91bGRVc2VPd25UcmFjZSIsIm9uUG9zc2libHlVbmhhbmRsZWRSZWplY3Rpb24iLCJvblVuaGFuZGxlZFJlamVjdGlvbkhhbmRsZWQiLCJkaXNhYmxlTG9uZ1N0YWNrVHJhY2VzIiwibG9uZ1N0YWNrVHJhY2VzSXNTdXBwb3J0ZWQiLCJQcm9taXNlX2NhcHR1cmVTdGFja1RyYWNlIiwiUHJvbWlzZV9hdHRhY2hFeHRyYVRyYWNlIiwibG9uZ1N0YWNrVHJhY2VzQ2FwdHVyZVN0YWNrVHJhY2UiLCJsb25nU3RhY2tUcmFjZXNBdHRhY2hFeHRyYVRyYWNlIiwiaGFzTG9uZ1N0YWNrVHJhY2VzIiwiZmlyZURvbUV2ZW50IiwiQ3VzdG9tRXZlbnQiLCJkaXNwYXRjaEV2ZW50IiwiZG9tRXZlbnQiLCJkZXRhaWwiLCJjYW5jZWxhYmxlIiwiRXZlbnQiLCJjcmVhdGVFdmVudCIsImluaXRDdXN0b21FdmVudCIsImZpcmVHbG9iYWxFdmVudCIsImdlbmVyYXRlUHJvbWlzZUxpZmVjeWNsZUV2ZW50T2JqZWN0IiwiZXZlbnRUb09iamVjdEdlbmVyYXRvciIsInByb21pc2VGdWxmaWxsZWQiLCJwcm9taXNlUmVqZWN0ZWQiLCJwcm9taXNlUmVzb2x2ZWQiLCJwcm9taXNlQ2FuY2VsbGVkIiwicHJvbWlzZUNoYWluZWQiLCJjaGlsZCIsIndhcm5pbmciLCJ1bmhhbmRsZWRSZWplY3Rpb24iLCJyZWplY3Rpb25IYW5kbGVkIiwiYWN0aXZlRmlyZUV2ZW50IiwiZ2xvYmFsRXZlbnRGaXJlZCIsImRvbUV2ZW50RmlyZWQiLCJ3YXJuaW5nc09wdGlvbiIsImNhbmNlbGxhdGlvbiIsImNhbmNlbGxhdGlvbkNsZWFyQ2FuY2VsbGF0aW9uRGF0YSIsImNhbmNlbGxhdGlvblByb3BhZ2F0ZUZyb20iLCJfb25DYW5jZWwiLCJjYW5jZWxsYXRpb25PbkNhbmNlbCIsImNhbmNlbGxhdGlvblNldE9uQ2FuY2VsIiwiX2F0dGFjaENhbmNlbGxhdGlvbkNhbGxiYWNrIiwiY2FuY2VsbGF0aW9uQXR0YWNoQ2FuY2VsbGF0aW9uQ2FsbGJhY2siLCJjYW5jZWxsYXRpb25FeGVjdXRlIiwicHJvcGFnYXRlRnJvbUZ1bmN0aW9uIiwibW9uaXRvcmluZyIsImRlZmF1bHRGaXJlRXZlbnQiLCJwcmV2aW91c09uQ2FuY2VsIiwiX29uQ2FuY2VsRmllbGQiLCJfY2FuY2VsbGF0aW9uUGFyZW50IiwiYnJhbmNoZXNSZW1haW5pbmdUb0NhbmNlbCIsIl9icmFuY2hlc1JlbWFpbmluZ1RvQ2FuY2VsIiwiX3NldEJvdW5kVG8iLCJiaW5kaW5nUHJvcGFnYXRlRnJvbSIsImJvdW5kVmFsdWVGdW5jdGlvbiIsImlnbm9yZVNlbGYiLCJhdHRhY2hFeHRyYVRyYWNlIiwiX19zdGFja0NsZWFuZWRfXyIsInBhcnNlU3RhY2tBbmRNZXNzYWdlIiwicmV0dXJuVmFsdWUiLCJoYW5kbGVyTGluZSIsImNyZWF0b3JMaW5lIiwidHJhY2VMaW5lcyIsImNsZWFuU3RhY2siLCJsaW5lTWF0Y2hlcyIsImZpcnN0VXNlckxpbmUiLCJyZXBsYWNlbWVudCIsImZvcm1hdEFuZExvZ0Vycm9yIiwicmVjb25zdHJ1Y3RTdGFjayIsInN0YWNrcyIsInJlbW92ZUR1cGxpY2F0ZU9yRW1wdHlKdW1wcyIsInJlbW92ZUNvbW1vblJvb3RzIiwiY3VycmVudCIsImN1cnJlbnRMYXN0SW5kZXgiLCJjdXJyZW50TGFzdExpbmUiLCJjb21tb25Sb290TWVldFBvaW50IiwiaXNUcmFjZUxpbmUiLCJpc0ludGVybmFsRnJhbWUiLCJzaG91bGRJZ25vcmUiLCJzdGFja0ZyYW1lc0FzQXJyYXkiLCJpc1NvZnQiLCJsb2NhbEhhbmRsZXIiLCJsb2NhbEV2ZW50RmlyZWQiLCJmb3JtYXROb25FcnJvciIsInJ1c2VsZXNzVG9TdHJpbmciLCJuZXdTdHIiLCJzbmlwIiwibWF4Q2hhcnMiLCJwYXJzZUxpbmVJbmZvUmVnZXgiLCJwYXJzZUxpbmVJbmZvIiwibWF0Y2hlcyIsImZpcnN0U3RhY2tMaW5lcyIsImxhc3RTdGFja0xpbmVzIiwiZmlyc3RJbmRleCIsImZpcnN0RmlsZU5hbWUiLCJsYXN0RmlsZU5hbWUiLCJfcHJvbWlzZXNDcmVhdGVkIiwidW5jeWNsZSIsIm5vZGVzIiwic3RhY2tUb0luZGV4IiwiY3VycmVudFN0YWNrIiwiY3ljbGVFZGdlTm9kZSIsImN1cnJlbnRDaGlsZExlbmd0aCIsInN0YWNrRGV0ZWN0aW9uIiwidjhzdGFja0ZyYW1lUGF0dGVybiIsInY4c3RhY2tGb3JtYXR0ZXIiLCJzdGFja1RyYWNlTGltaXQiLCJpZ25vcmVVbnRpbCIsImhhc1N0YWNrQWZ0ZXJUaHJvdyIsImlzVFRZIiwiY2FsbGVkIiwiRmluYWxseUhhbmRsZXJDYW5jZWxSZWFjdGlvbiIsImZpbmFsbHlIYW5kbGVyIiwiY2hlY2tDYW5jZWwiLCJzdWNjZWVkIiwiZmFpbCIsInJlYXNvbk9yVmFsdWUiLCJfaXNDYW5jZWxsZWQiLCJpc1BlbmRpbmciLCJfcGFzc1Rocm91Z2giLCJzdWNjZXNzIiwibGFzdGx5IiwidGFwIiwidGFwQ2F0Y2giLCJoYW5kbGVyT3JQcmVkaWNhdGUiLCJfcmVzb2x2ZUZyb21TeW5jVmFsdWUiLCJhdHRlbXB0IiwiY2FsbGVkQmluZCIsInJlamVjdFRoaXMiLCJ0YXJnZXRSZWplY3RlZCIsInByb21pc2VSZWplY3Rpb25RdWV1ZWQiLCJiaW5kaW5nUHJvbWlzZSIsImJpbmRpbmdSZXNvbHZlZCIsInRoaXNBcmciLCJiaW5kaW5nUmVqZWN0ZWQiLCJfY2FuY2VsQnkiLCJfY2FuY2VsQnJhbmNoZWQiLCJfYnJhbmNoSGFzQ2FuY2VsbGVkIiwiX2Vub3VnaEJyYW5jaGVzSGF2ZUNhbmNlbGxlZCIsImNhbmNlbGxlciIsIl9pbnZva2VPbkNhbmNlbCIsIl9jYW5jZWxQcm9taXNlcyIsIl91bnNldE9uQ2FuY2VsIiwiaXNDYW5jZWxsYWJsZSIsImlzQ2FuY2VsbGVkIiwiX2RvSW52b2tlT25DYW5jZWwiLCJvbkNhbmNlbENhbGxiYWNrIiwiaW50ZXJuYWxPbmx5IiwicmV0dXJuZXIiLCJ0aGVuUmV0dXJuIiwidGhlblRocm93IiwiY2F0Y2hUaHJvdyIsImNhdGNoUmV0dXJuIiwiX3NldHRsZWRWYWx1ZUZpZWxkIiwiX19pc0NhbmNlbGxlZCIsInRoZW5DYWxsYmFjayIsInByb21pc2VTZXR0ZXIiLCJnZW5lcmF0ZUhvbGRlckNsYXNzIiwicHJvcHMiLCJhc3NpZ25tZW50IiwiY2FuY2VsbGF0aW9uQ29kZSIsInBhc3NlZEFyZ3VtZW50cyIsImhvbGRlckNsYXNzZXMiLCJ0aGVuQ2FsbGJhY2tzIiwicHJvbWlzZVNldHRlcnMiLCJsYXN0IiwiSG9sZGVyQ2xhc3MiLCJob2xkZXIiLCJjYWxsYmFja3MiLCJhc3luY05lZWRlZCIsIk1hcHBpbmdQcm9taXNlQXJyYXkiLCJsaW1pdCIsIl9maWx0ZXIiLCJfY2FsbGJhY2siLCJfcHJlc2VydmVkVmFsdWVzIiwiX2xpbWl0IiwiX2luRmxpZ2h0IiwiX3F1ZXVlIiwiX2FzeW5jSW5pdCIsIl9pbml0JCIsInByZXNlcnZlZFZhbHVlcyIsImJvb2xlYW5zIiwiY29uY3VycmVuY3kiLCJpc0Zpbml0ZSIsImNyIiwiY2FsbGVyQ2FjaGUiLCJnZXR0ZXJDYWNoZSIsImdldE1ldGhvZENhbGxlciIsImdldEdldHRlciIsIm1ha2VNZXRob2RDYWxsZXIiLCJlbnN1cmVNZXRob2QiLCJtYWtlR2V0dGVyIiwiZ2V0Q29tcGlsZWQiLCJjb21waWxlciIsImNhY2hlIiwiY2FsbGVyIiwibWF5YmVDYWxsZXIiLCJuYW1lZEdldHRlciIsImluZGV4ZWRHZXR0ZXIiLCJpc0luZGV4IiwiZ2V0dGVyIiwibWF5YmVHZXR0ZXIiLCJOVUxMIiwiY2FzdFByZXNlcnZpbmdEaXNwb3NhYmxlIiwidGhlbmFibGUiLCJfaXNEaXNwb3NhYmxlIiwiX2dldERpc3Bvc2VyIiwiX3NldERpc3Bvc2FibGUiLCJyZXNvdXJjZXMiLCJpbnNwZWN0aW9uIiwidHJ5RGlzcG9zZSIsIkRpc3Bvc2VyIiwiX2RhdGEiLCJfY29udGV4dCIsInJlc291cmNlIiwiZG9EaXNwb3NlIiwiX3Vuc2V0RGlzcG9zYWJsZSIsImlzRGlzcG9zZXIiLCJGdW5jdGlvbkRpc3Bvc2VyIiwibWF5YmVVbndyYXBEaXNwb3NlciIsIlJlc291cmNlTGlzdCIsInVzaW5nIiwiaW5wdXQiLCJzcHJlYWRBcmdzIiwiZGlzcG9zZXIiLCJyZWZsZWN0ZWRSZXNvdXJjZXMiLCJyZXN1bHRQcm9taXNlIiwiaW5zcGVjdGlvbnMiLCJfZGlzcG9zZXIiLCJIYW5kbGVXcmFwcGVyIiwiaGFuZGxlIiwiY2xlYXJUaW1lb3V0IiwiYWZ0ZXJWYWx1ZSIsImRlbGF5IiwiYWZ0ZXJUaW1lb3V0Iiwic3VjY2Vzc0NsZWFyIiwiZmFpbHVyZUNsZWFyIiwidGltZW91dCIsImhhbmRsZVdyYXBwZXIiLCJ0aW1lb3V0VGltZW91dCIsInlpZWxkSGFuZGxlcnMiLCJwcm9taXNlRnJvbVlpZWxkSGFuZGxlciIsInRyYWNlUGFyZW50IiwiUHJvbWlzZVNwYXduIiwiZ2VuZXJhdG9yRnVuY3Rpb24iLCJ5aWVsZEhhbmRsZXIiLCJpbnRlcm5hbCIsIl9maW5hbGx5UHJvbWlzZSIsIl9zdGFjayIsIl9nZW5lcmF0b3JGdW5jdGlvbiIsIl9yZWNlaXZlciIsIl9nZW5lcmF0b3IiLCJfeWllbGRIYW5kbGVycyIsIl95aWVsZGVkUHJvbWlzZSIsIl9jYW5jZWxsYXRpb25QaGFzZSIsIl9jbGVhbnVwIiwiaW1wbGVtZW50c1JldHVybiIsInJldHVyblNlbnRpbmVsIiwiX2NvbnRpbnVlIiwiX3J1biIsIlByb21pc2VTcGF3biQiLCJzcGF3biIsImFkZFlpZWxkSGFuZGxlciIsInNwcmVhZEFkYXB0ZXIiLCJub2RlYmFjayIsInN1Y2Nlc3NBZGFwdGVyIiwiZXJyb3JBZGFwdGVyIiwibmV3UmVhc29uIiwiYXNDYWxsYmFjayIsIm5vZGVpZnkiLCJhZGFwdGVyIiwiVEhJUyIsImRlZmF1bHRTdWZmaXgiLCJkZWZhdWx0UHJvbWlzaWZpZWQiLCJfX2lzUHJvbWlzaWZpZWRfXyIsIm5vQ29weVByb3BzIiwibm9Db3B5UHJvcHNQYXR0ZXJuIiwiZGVmYXVsdEZpbHRlciIsInByb3BzRmlsdGVyIiwiaXNQcm9taXNpZmllZCIsImhhc1Byb21pc2lmaWVkIiwiY2hlY2tWYWxpZCIsInN1ZmZpeFJlZ2V4cCIsImtleVdpdGhvdXRBc3luY1N1ZmZpeCIsInByb21pc2lmaWFibGVNZXRob2RzIiwicGFzc2VzRGVmYXVsdEZpbHRlciIsImVzY2FwZUlkZW50UmVnZXgiLCJtYWtlTm9kZVByb21pc2lmaWVkRXZhbCIsInN3aXRjaENhc2VBcmd1bWVudE9yZGVyIiwibGlrZWx5QXJndW1lbnRDb3VudCIsImFyZ3VtZW50U2VxdWVuY2UiLCJhcmd1bWVudENvdW50IiwicGFyYW1ldGVyRGVjbGFyYXRpb24iLCJwYXJhbWV0ZXJDb3VudCIsIm9yaWdpbmFsTmFtZSIsIm5ld1BhcmFtZXRlckNvdW50IiwiYXJndW1lbnRPcmRlciIsInNob3VsZFByb3h5VGhpcyIsImdlbmVyYXRlQ2FsbEZvckFyZ3VtZW50Q291bnQiLCJjb21tYSIsImdlbmVyYXRlQXJndW1lbnRTd2l0Y2hDYXNlIiwiZ2V0RnVuY3Rpb25Db2RlIiwibWFrZU5vZGVQcm9taXNpZmllZENsb3N1cmUiLCJfXyIsImRlZmF1bHRUaGlzIiwicHJvbWlzaWZpZWQiLCJtYWtlTm9kZVByb21pc2lmaWVkIiwicHJvbWlzaWZ5QWxsIiwicHJvbWlzaWZpZXIiLCJwcm9taXNpZmllZEtleSIsIkVzNk1hcCIsIm1hcFRvRW50cmllcyIsImV4dHJhY3RFbnRyeSIsImVudHJpZXNUb01hcCIsImVudHJpZXMiLCJQcm9wZXJ0aWVzUHJvbWlzZUFycmF5IiwiaXNNYXAiLCJfaXNNYXAiLCJrZXlPZmZzZXQiLCJjYXN0VmFsdWUiLCJyYWNlTGF0ZXIiLCJhcnJheSIsInJhY2UiLCJSZWR1Y3Rpb25Qcm9taXNlQXJyYXkiLCJpbml0aWFsVmFsdWUiLCJfZWFjaCIsIl9mbiIsIl9pbml0aWFsVmFsdWUiLCJfY3VycmVudENhbmNlbGxhYmxlIiwiX2VhY2hWYWx1ZXMiLCJfZ290QWNjdW0iLCJhY2N1bSIsIl9lYWNoQ29tcGxldGUiLCJzZW5kZXIiLCJfcmVzdWx0Q2FuY2VsbGVkJCIsImdvdEFjY3VtIiwiY29tcGxldGVkIiwidmFsdWVPclJlYXNvbiIsImdvdFZhbHVlIiwiU2V0dGxlZFByb21pc2VBcnJheSIsIl9wcm9taXNlUmVzb2x2ZWQiLCJzZXR0bGUiLCJDQU5DRUxMQVRJT04iLCJTb21lUHJvbWlzZUFycmF5IiwiX2hvd01hbnkiLCJfdW53cmFwIiwiX2luaXRpYWxpemVkIiwiaXNBcnJheVJlc29sdmVkIiwiX2NhblBvc3NpYmx5RnVsZmlsbCIsIl9nZXRSYW5nZUVycm9yIiwic2V0VW53cmFwIiwiaG93TWFueSIsInNldEhvd01hbnkiLCJfYWRkRnVsZmlsbGVkIiwiX2Z1bGZpbGxlZCIsIl9hZGRSZWplY3RlZCIsIl9jaGVja091dGNvbWUiLCJfcmVqZWN0ZWQiLCJfU29tZVByb21pc2VBcnJheSIsIlByb21pc2VNYXAiLCJQcm9taXNlUmVkdWNlIiwiUHJvbWlzZUFsbCIsInByb21pc2VBbGxUaGlzIiwiUHJvbWlzZU1hcFNlcmllcyIsImVhY2giLCJtYXBTZXJpZXMiLCJhbnkiLCJsb2FkIiwic3RvcmFnZSIsImxvY2FsIiwibG9jYWxzdG9yYWdlIiwidXNlckFnZW50IiwiZG9jdW1lbnRFbGVtZW50IiwiV2Via2l0QXBwZWFyYW5jZSIsImZpcmVidWciLCJleGNlcHRpb24iLCJ0YWJsZSIsIiQxIiwibGFzdEMiLCJyZW1vdmVJdGVtIiwiREVCVUciLCJsb2NhbFN0b3JhZ2UiLCJoIiwieSIsImxvbmciLCJmbXRMb25nIiwiZm10U2hvcnQiLCJleGVjIiwibiIsInBhcnNlRmxvYXQiLCJwbHVyYWwiLCJjZWlsIiwidHR5Iiwic3VwcG9ydHNDb2xvciIsImluc3BlY3RPcHRzIiwiayIsInRvVXBwZXJDYXNlIiwiQm9vbGVhbiIsImlzYXR0eSIsImluc3BlY3QiLCJPIiwiY29sb3JDb2RlIiwiaGlkZURhdGUiLCJ0b0lTT1N0cmluZyIsImhhc0ZsYWciLCJzdXBwb3J0IiwiaGFzQmFzaWMiLCJoYXMyNTYiLCJoYXMxNm0iLCJzdXBwb3J0TGV2ZWwiLCJzdGRvdXQiLCJvc1JlbGVhc2UiLCJzaWduIiwiQ0lfTkFNRSIsIlRFQU1DSVRZX1ZFUlNJT04iLCJURVJNX1BST0dSQU1fVkVSU0lPTiIsIlRFUk1fUFJPR1JBTSIsIlRFUk0iLCJGT1JDRV9DT0xPUiIsImZsYWciLCJhcmd2IiwidGVybWluYXRvclBvcyIsInBvcyIsImNvbnN0YW50cyIsIm9yaWdDd2QiLCJHUkFDRUZVTF9GU19QTEFURk9STSIsImNoZGlyIiwicGF0Y2hMY2htb2QiLCJsdXRpbWVzIiwicGF0Y2hMdXRpbWVzIiwiY2hvd24iLCJjaG93bkZpeCIsImZjaG93biIsImxjaG93biIsImNobW9kRml4IiwiZmNobW9kIiwibGNobW9kIiwiY2hvd25TeW5jIiwiY2hvd25GaXhTeW5jIiwiZmNob3duU3luYyIsImxjaG93blN5bmMiLCJjaG1vZFN5bmMiLCJjaG1vZEZpeFN5bmMiLCJmY2htb2RTeW5jIiwibGNobW9kU3luYyIsInN0YXRGaXgiLCJzdGF0Rml4U3luYyIsImZzdGF0U3luYyIsImxzdGF0U3luYyIsInVpZCIsImdpZCIsInJlbmFtZSIsImZzJHJlbmFtZSIsImJhY2tvZmYiLCJDQiIsInN0YXRlciIsImZzJHJlYWQiLCJjYWxsYmFja18iLCJlYWdDb3VudGVyIiwicmVhZFN5bmMiLCJmcyRyZWFkU3luYyIsIk9fV1JPTkxZIiwiT19TWU1MSU5LIiwiZXJyMiIsInRocmV3IiwibXQiLCJlcjIiLCJsdXRpbWVzU3luYyIsIl9hIiwiX2IiLCJfYyIsIm9yaWciLCJjaG93bkVyT2siLCJub25yb290IiwiZ2V0dWlkIiwiU3RyZWFtIiwicmVhZGFibGUiLCJwYXVzZWQiLCJidWZmZXJTaXplIiwiSW5maW5pdHkiLCJfcmVhZCIsImJ1c3kiLCJfb3BlbiIsImZsdXNoIiwibzc3NyIsIm1hZGUiLCJlcnJJbnZhbCIsInhmcyIsInVtYXNrIiwibWtkaXJTeW5jIiwiZXJyMCIsImVycjEiLCJ1dGltZXNTeW5jIiwidW5saW5rU3luYyIsImNvcHlGaWxlU3luYyIsIkJVRl9MRU5HVEgiLCJfYnVmZiIsImZkciIsImZkdyIsIndyaXRlU3luYyIsInJlYWRkaXJTeW5jIiwicmVhZGxpbmtTeW5jIiwic3ltbGlua1N5bmMiLCJhc3NlcnQiLCJpc1dpbmRvd3MiLCJkZWZhdWx0cyIsIm1heEJ1c3lUcmllcyIsImJ1c3lUcmllcyIsInJpbXJhZl8iLCJ0aW1lIiwiZml4V2luRVBFUk0iLCJybWRpciIsImVyMyIsImZpeFdpbkVQRVJNU3luYyIsInJtZGlyU3luYyIsIm9yaWdpbmFsRXIiLCJybWtpZHMiLCJlcnJTdGF0ZSIsImYiLCJyaW1yYWZTeW5jIiwicm1raWRzU3luYyIsInJldHJpZXMiLCJvdXRwdXRKc29uIiwib3V0cHV0SnNvblN5bmMiLCJvdXRwdXRKU09OIiwib3V0cHV0SlNPTlN5bmMiLCJ3cml0ZUpTT04iLCJ3cml0ZUpTT05TeW5jIiwicmVhZEpTT04iLCJyZWFkSlNPTlN5bmMiLCJfZnMiLCJzaG91bGRUaHJvdyIsInRocm93cyIsInN0cmlwQm9tIiwicmV2aXZlciIsInNwYWNlcyIsInJlcGxhY2VyIiwiaXNCdWZmZXIiLCJqc29uZmlsZSIsImRpciIsIml0RG9lcyIsIm1vdmUiLCJpdElzIiwiZG9SZW5hbWUiLCJtb3ZlQWNyb3NzRGV2aWNlIiwibGluayIsIm1vdmVEaXJBY3Jvc3NEZXZpY2UiLCJtb3ZlRmlsZUFjcm9zc0RldmljZSIsImlucyIsIm91dHMiLCJvbkNsb3NlIiwibW92ZVN5bmMiLCJhY2Nlc3NTeW5jIiwidHJ5UmVuYW1lU3luYyIsInJlbmFtZVN5bmMiLCJtb3ZlU3luY0Fjcm9zc0RldmljZSIsImxpbmtTeW5jIiwibW92ZURpclN5bmNBY3Jvc3NEZXZpY2UiLCJtb3ZlRmlsZVN5bmNBY3Jvc3NEZXZpY2UiLCJ0cnlDb3B5U3luYyIsImVtcHR5RGlyIiwiZGVsZXRlSXRlbSIsImVtcHR5RGlyU3luYyIsImVtcHR5ZGlyU3luYyIsImVtcHR5ZGlyIiwiY3JlYXRlRmlsZVN5bmMiLCJlbnN1cmVGaWxlU3luYyIsImNyZWF0ZUxpbmsiLCJjcmVhdGVMaW5rU3luYyIsImVuc3VyZUxpbmsiLCJlbnN1cmVMaW5rU3luYyIsImNyZWF0ZVN5bWxpbmsiLCJjcmVhdGVTeW1saW5rU3luYyIsImVuc3VyZVN5bWxpbmsiLCJlbnN1cmVTeW1saW5rU3luYyIsIm1ha2VGaWxlIiwic3JjcGF0aCIsImRzdHBhdGgiLCJtYWtlTGluayIsImRlc3RpbmF0aW9uRXhpc3RzIiwiX21rZGlycyIsIl9zeW1saW5rUGF0aHMiLCJzeW1saW5rUGF0aHMiLCJzeW1saW5rUGF0aHNTeW5jIiwiX3N5bWxpbmtUeXBlIiwic3ltbGlua1R5cGUiLCJzeW1saW5rVHlwZVN5bmMiLCJ0b0RzdCIsInRvQ3dkIiwiZHN0ZGlyIiwicmVsYXRpdmVUb0RzdCIsIm91dHB1dEZpbGVTeW5jIiwiczNVcmwiLCJzcGFjZXNVcmwiLCJlbmRwb2ludCIsImJ1Y2tldCIsInJlZ2lvbiIsInNlcSIsInF1b3RlZCIsIm5leHROb25TcGFjZSIsImNoIiwib3JkIiwiZnJvbUNoYXJDb2RlIiwibmlsIiwiaW52YWxpZE5hbWUiLCJtb3JlVGhhbjEwMDAwIiwicmFuZG9tSG9zdCIsInNlZWQiLCJjbG9ja1NlcSIsImxhc3RNVGltZSIsImxhc3ROVGltZSIsImhleDJieXRlIiwiYnl0ZTJoZXgiLCJoZXgiLCJ1dWlkIiwiYXNjaWkiLCJiaW5hcnkiLCJ1dWlkVGltZUJhc2VkIiwidXVpZE5hbWVkIiwidG9CdWZmZXIiLCJ2YXJpYW50IiwiZ2V0VmFyaWFudCIsImJpdHMiLCJVdWlkRW5jb2RpbmciLCJub2RlSWQiLCJBU0NJSSIsIm1UaW1lIiwiblRpbWUiLCJteUNsb2NrU2VxIiwidGltZUxvdyIsInRpbWVIaWdoIiwiQklOQVJZIiwiT0JKRUNUIiwiaGFzaE1ldGhvZCIsIm5hbWVJc05vdEFTdHJpbmciLCJfc2F4IiwiX2xvYWRfc2F4IiwiaXNDRGF0YSIsImVsZW1lbnRzIiwiaXNWYWxpZE5hbWUiLCJyZW1vdmVBdHRyaWJ1dGUiLCJpZ25vcmVDYXNlIiwiZXJyb3JJZk1pc3NlZCIsImVsZW1lbnRPck51bGwiLCJpc05hbWVFcXVhbHMiLCJOQU1FX1JFR19FWFAiLCJlbGVtZW50TmFtZSIsInJvb3RFbGVtZW50IiwicGFyc2VyIiwib25vcGVudGFnIiwic2F4RWxlbWVudCIsIm9uY2xvc2V0YWciLCJvbnRleHQiLCJvbmNkYXRhIiwiY2RhdGEiLCJvbmVycm9yIiwic2F4Iiwic3RyaWN0Iiwib3B0IiwiU0FYUGFyc2VyIiwiU0FYU3RyZWFtIiwiY3JlYXRlU3RyZWFtIiwiTUFYX0JVRkZFUl9MRU5HVEgiLCJidWZmZXJzIiwiRVZFTlRTIiwiY2xlYXJCdWZmZXJzIiwicSIsImJ1ZmZlckNoZWNrUG9zaXRpb24iLCJsb3dlcmNhc2UiLCJsb3dlcmNhc2V0YWdzIiwibG9vc2VDYXNlIiwidGFncyIsImNsb3NlZCIsImNsb3NlZFJvb3QiLCJzYXdSb290Iiwibm9zY3JpcHQiLCJzdGF0ZSIsIlMiLCJCRUdJTiIsInN0cmljdEVudGl0aWVzIiwiRU5USVRJRVMiLCJYTUxfRU5USVRJRVMiLCJhdHRyaWJMaXN0IiwieG1sbnMiLCJucyIsInJvb3ROUyIsInRyYWNrUG9zaXRpb24iLCJGIiwibmV3ZiIsImNoZWNrQnVmZmVyTGVuZ3RoIiwibWF4QWxsb3dlZCIsIm1heEFjdHVhbCIsImNsb3NlVGV4dCIsImVtaXROb2RlIiwic2NyaXB0IiwiZmx1c2hCdWZmZXJzIiwicmVzdW1lIiwiZXgiLCJzdHJlYW1XcmFwcyIsImV2IiwiX3BhcnNlciIsIm1lIiwib25lbmQiLCJfZGVjb2RlciIsIlNEIiwiU3RyaW5nRGVjb2RlciIsIkNEQVRBIiwiRE9DVFlQRSIsIlhNTF9OQU1FU1BBQ0UiLCJYTUxOU19OQU1FU1BBQ0UiLCJ4bWwiLCJuYW1lU3RhcnQiLCJuYW1lQm9keSIsImVudGl0eVN0YXJ0IiwiZW50aXR5Qm9keSIsImlzV2hpdGVzcGFjZSIsImlzUXVvdGUiLCJpc0F0dHJpYkVuZCIsImlzTWF0Y2giLCJyZWdleCIsIm5vdE1hdGNoIiwiU1RBVEUiLCJCRUdJTl9XSElURVNQQUNFIiwiVEVYVCIsIlRFWFRfRU5USVRZIiwiT1BFTl9XQUtBIiwiU0dNTF9ERUNMIiwiU0dNTF9ERUNMX1FVT1RFRCIsIkRPQ1RZUEVfUVVPVEVEIiwiRE9DVFlQRV9EVEQiLCJET0NUWVBFX0RURF9RVU9URUQiLCJDT01NRU5UX1NUQVJUSU5HIiwiQ09NTUVOVCIsIkNPTU1FTlRfRU5ESU5HIiwiQ09NTUVOVF9FTkRFRCIsIkNEQVRBX0VORElORyIsIkNEQVRBX0VORElOR18yIiwiUFJPQ19JTlNUIiwiUFJPQ19JTlNUX0JPRFkiLCJQUk9DX0lOU1RfRU5ESU5HIiwiT1BFTl9UQUciLCJPUEVOX1RBR19TTEFTSCIsIkFUVFJJQiIsIkFUVFJJQl9OQU1FIiwiQVRUUklCX05BTUVfU0FXX1dISVRFIiwiQVRUUklCX1ZBTFVFIiwiQVRUUklCX1ZBTFVFX1FVT1RFRCIsIkFUVFJJQl9WQUxVRV9DTE9TRUQiLCJBVFRSSUJfVkFMVUVfVU5RVU9URUQiLCJBVFRSSUJfVkFMVUVfRU5USVRZX1EiLCJBVFRSSUJfVkFMVUVfRU5USVRZX1UiLCJDTE9TRV9UQUciLCJDTE9TRV9UQUdfU0FXX1dISVRFIiwiU0NSSVBUIiwiU0NSSVBUX0VORElORyIsIm5vZGVUeXBlIiwidGV4dE5vZGUiLCJ0ZXh0b3B0cyIsInN0cmljdEZhaWwiLCJuZXdUYWciLCJ0YWdOYW1lIiwicW5hbWUiLCJxdWFsTmFtZSIsImF0dHJpYiIsImF0dHJpYk5hbWUiLCJhdHRyaWJWYWx1ZSIsInFuIiwib3BlblRhZyIsInNlbGZDbG9zaW5nIiwidXJpIiwibnYiLCJpc1NlbGZDbG9zaW5nIiwiY2xvc2VUYWciLCJ0IiwiY2xvc2VUbyIsInBhcnNlRW50aXR5IiwiZW50aXR5IiwiZW50aXR5TEMiLCJudW1TdHIiLCJmcm9tQ29kZVBvaW50IiwiYmVnaW5XaGl0ZVNwYWNlIiwic3RhcnRUYWdQb3NpdGlvbiIsInN0YXJ0aSIsInNnbWxEZWNsIiwicHJvY0luc3ROYW1lIiwicHJvY0luc3RCb2R5IiwiY29tbWVudCIsImRvY3R5cGUiLCJyZXR1cm5TdGF0ZSIsInN0cmluZ0Zyb21DaGFyQ29kZSIsIk1BWF9TSVpFIiwiY29kZVVuaXRzIiwiaGlnaFN1cnJvZ2F0ZSIsImxvd1N1cnJvZ2F0ZSIsImNvZGVQb2ludCIsImxvYWRlciIsImR1bXBlciIsIkZBSUxTQUZFX1NDSEVNQSIsIkpTT05fU0NIRU1BIiwiQ09SRV9TQ0hFTUEiLCJERUZBVUxUX1NBRkVfU0NIRU1BIiwiREVGQVVMVF9GVUxMX1NDSEVNQSIsImxvYWRBbGwiLCJzYWZlTG9hZEFsbCIsImR1bXAiLCJzYWZlRHVtcCIsIk1JTklNQUxfU0NIRU1BIiwiU0FGRV9TQ0hFTUEiLCJERUZBVUxUX1NDSEVNQSIsInNjYW4iLCJjb21wb3NlIiwiYWRkQ29uc3RydWN0b3IiLCJNYXJrIiwiX2hhc093blByb3BlcnR5IiwiQ09OVEVYVF9GTE9XX0lOIiwiQ09OVEVYVF9GTE9XX09VVCIsIkNPTlRFWFRfQkxPQ0tfSU4iLCJDT05URVhUX0JMT0NLX09VVCIsIkNIT01QSU5HX0NMSVAiLCJDSE9NUElOR19TVFJJUCIsIkNIT01QSU5HX0tFRVAiLCJQQVRURVJOX05PTl9QUklOVEFCTEUiLCJQQVRURVJOX05PTl9BU0NJSV9MSU5FX0JSRUFLUyIsIlBBVFRFUk5fRkxPV19JTkRJQ0FUT1JTIiwiUEFUVEVSTl9UQUdfSEFORExFIiwiUEFUVEVSTl9UQUdfVVJJIiwiaXNfRU9MIiwiaXNfV0hJVEVfU1BBQ0UiLCJpc19XU19PUl9FT0wiLCJpc19GTE9XX0lORElDQVRPUiIsImZyb21IZXhDb2RlIiwibGMiLCJlc2NhcGVkSGV4TGVuIiwiZnJvbURlY2ltYWxDb2RlIiwic2ltcGxlRXNjYXBlU2VxdWVuY2UiLCJjaGFyRnJvbUNvZGVwb2ludCIsInNpbXBsZUVzY2FwZUNoZWNrIiwic2ltcGxlRXNjYXBlTWFwIiwiU3RhdGUiLCJvbldhcm5pbmciLCJqc29uIiwibGlzdGVuZXIiLCJpbXBsaWNpdFR5cGVzIiwidHlwZU1hcCIsImxpbmVTdGFydCIsImxpbmVJbmRlbnQiLCJkb2N1bWVudHMiLCJnZW5lcmF0ZUVycm9yIiwidGhyb3dFcnJvciIsInRocm93V2FybmluZyIsImRpcmVjdGl2ZUhhbmRsZXJzIiwiWUFNTCIsImhhbmRsZVlhbWxEaXJlY3RpdmUiLCJjaGVja0xpbmVCcmVha3MiLCJUQUciLCJoYW5kbGVUYWdEaXJlY3RpdmUiLCJ0YWdNYXAiLCJjYXB0dXJlU2VnbWVudCIsImNoZWNrSnNvbiIsIl9wb3NpdGlvbiIsIl9jaGFyYWN0ZXIiLCJfcmVzdWx0IiwibWVyZ2VNYXBwaW5ncyIsIm92ZXJyaWRhYmxlS2V5cyIsInF1YW50aXR5Iiwic3RvcmVNYXBwaW5nUGFpciIsImtleVRhZyIsImtleU5vZGUiLCJ2YWx1ZU5vZGUiLCJzdGFydExpbmUiLCJzdGFydFBvcyIsInJlYWRMaW5lQnJlYWsiLCJza2lwU2VwYXJhdGlvblNwYWNlIiwiYWxsb3dDb21tZW50cyIsImNoZWNrSW5kZW50IiwibGluZUJyZWFrcyIsInRlc3REb2N1bWVudFNlcGFyYXRvciIsIndyaXRlRm9sZGVkTGluZXMiLCJyZWFkUGxhaW5TY2FsYXIiLCJub2RlSW5kZW50Iiwid2l0aGluRmxvd0NvbGxlY3Rpb24iLCJwcmVjZWRpbmciLCJmb2xsb3dpbmciLCJjYXB0dXJlU3RhcnQiLCJjYXB0dXJlRW5kIiwiaGFzUGVuZGluZ0NvbnRlbnQiLCJfbGluZSIsIl9saW5lU3RhcnQiLCJfbGluZUluZGVudCIsIl9raW5kIiwicmVhZFNpbmdsZVF1b3RlZFNjYWxhciIsInJlYWREb3VibGVRdW90ZWRTY2FsYXIiLCJoZXhMZW5ndGgiLCJoZXhSZXN1bHQiLCJ0bXAiLCJyZWFkRmxvd0NvbGxlY3Rpb24iLCJyZWFkTmV4dCIsIl90YWciLCJfYW5jaG9yIiwiYW5jaG9yIiwidGVybWluYXRvciIsImlzUGFpciIsImlzRXhwbGljaXRQYWlyIiwiaXNNYXBwaW5nIiwiYW5jaG9yTWFwIiwiY29tcG9zZU5vZGUiLCJyZWFkQmxvY2tTY2FsYXIiLCJmb2xkaW5nIiwiY2hvbXBpbmciLCJkaWRSZWFkQ29udGVudCIsImRldGVjdGVkSW5kZW50IiwidGV4dEluZGVudCIsImVtcHR5TGluZXMiLCJhdE1vcmVJbmRlbnRlZCIsInJlYWRCbG9ja1NlcXVlbmNlIiwiZGV0ZWN0ZWQiLCJyZWFkQmxvY2tNYXBwaW5nIiwiZmxvd0luZGVudCIsImFsbG93Q29tcGFjdCIsIl9wb3MiLCJhdEV4cGxpY2l0S2V5IiwicmVhZFRhZ1Byb3BlcnR5IiwiaXNWZXJiYXRpbSIsImlzTmFtZWQiLCJ0YWdIYW5kbGUiLCJyZWFkQW5jaG9yUHJvcGVydHkiLCJyZWFkQWxpYXMiLCJwYXJlbnRJbmRlbnQiLCJub2RlQ29udGV4dCIsImFsbG93VG9TZWVrIiwiYWxsb3dCbG9ja1N0eWxlcyIsImFsbG93QmxvY2tTY2FsYXJzIiwiYWxsb3dCbG9ja0NvbGxlY3Rpb25zIiwiaW5kZW50U3RhdHVzIiwiYXROZXdMaW5lIiwiaGFzQ29udGVudCIsInR5cGVJbmRleCIsInR5cGVRdWFudGl0eSIsImJsb2NrSW5kZW50IiwicmVhZERvY3VtZW50IiwiZG9jdW1lbnRTdGFydCIsImRpcmVjdGl2ZU5hbWUiLCJkaXJlY3RpdmVBcmdzIiwiaGFzRGlyZWN0aXZlcyIsImxvYWREb2N1bWVudHMiLCJvdXRwdXQiLCJnZXRTbmlwcGV0IiwibWF4TGVuZ3RoIiwiaGVhZCIsInRhaWwiLCJzbmlwcGV0Iiwid2hlcmUiLCJyZXNvbHZlWWFtbE51bGwiLCJjb25zdHJ1Y3RZYW1sTnVsbCIsImlzTnVsbCIsIm9iamVjdCIsImNhbm9uaWNhbCIsInVwcGVyY2FzZSIsImNhbWVsY2FzZSIsInJlc29sdmVZYW1sQm9vbGVhbiIsImNvbnN0cnVjdFlhbWxCb29sZWFuIiwiaXNCb29sZWFuIiwiaXNIZXhDb2RlIiwiaXNPY3RDb2RlIiwiaXNEZWNDb2RlIiwicmVzb2x2ZVlhbWxJbnRlZ2VyIiwiaGFzRGlnaXRzIiwiY29uc3RydWN0WWFtbEludGVnZXIiLCJkaWdpdHMiLCJpc0ludGVnZXIiLCJvY3RhbCIsImRlY2ltYWwiLCJoZXhhZGVjaW1hbCIsIllBTUxfRkxPQVRfUEFUVEVSTiIsInJlc29sdmVZYW1sRmxvYXQiLCJjb25zdHJ1Y3RZYW1sRmxvYXQiLCJQT1NJVElWRV9JTkZJTklUWSIsIk5hTiIsIlNDSUVOVElGSUNfV0lUSE9VVF9ET1QiLCJyZXByZXNlbnRZYW1sRmxvYXQiLCJpc0Zsb2F0IiwiWUFNTF9EQVRFX1JFR0VYUCIsIllBTUxfVElNRVNUQU1QX1JFR0VYUCIsInJlc29sdmVZYW1sVGltZXN0YW1wIiwiY29uc3RydWN0WWFtbFRpbWVzdGFtcCIsInllYXIiLCJtb250aCIsImRheSIsImhvdXIiLCJtaW51dGUiLCJzZWNvbmQiLCJmcmFjdGlvbiIsInR6X2hvdXIiLCJ0el9taW51dGUiLCJVVEMiLCJzZXRUaW1lIiwicmVwcmVzZW50WWFtbFRpbWVzdGFtcCIsInJlc29sdmVZYW1sTWVyZ2UiLCJOb2RlQnVmZmVyIiwiX3JlcXVpcmUiLCJCQVNFNjRfTUFQIiwicmVzb2x2ZVlhbWxCaW5hcnkiLCJiaXRsZW4iLCJjb25zdHJ1Y3RZYW1sQmluYXJ5IiwidGFpbGJpdHMiLCJyZXByZXNlbnRZYW1sQmluYXJ5IiwiaXNCaW5hcnkiLCJfdG9TdHJpbmciLCJyZXNvbHZlWWFtbE9tYXAiLCJvYmplY3RLZXlzIiwicGFpciIsInBhaXJLZXkiLCJwYWlySGFzS2V5IiwiY29uc3RydWN0WWFtbE9tYXAiLCJyZXNvbHZlWWFtbFBhaXJzIiwiY29uc3RydWN0WWFtbFBhaXJzIiwicmVzb2x2ZVlhbWxTZXQiLCJjb25zdHJ1Y3RZYW1sU2V0IiwicmVzb2x2ZUphdmFzY3JpcHRVbmRlZmluZWQiLCJjb25zdHJ1Y3RKYXZhc2NyaXB0VW5kZWZpbmVkIiwicmVwcmVzZW50SmF2YXNjcmlwdFVuZGVmaW5lZCIsImlzVW5kZWZpbmVkIiwicmVzb2x2ZUphdmFzY3JpcHRSZWdFeHAiLCJyZWdleHAiLCJtb2RpZmllcnMiLCJjb25zdHJ1Y3RKYXZhc2NyaXB0UmVnRXhwIiwicmVwcmVzZW50SmF2YXNjcmlwdFJlZ0V4cCIsIm11bHRpbGluZSIsImlzUmVnRXhwIiwiZXNwcmltYSIsInJlc29sdmVKYXZhc2NyaXB0RnVuY3Rpb24iLCJhc3QiLCJleHByZXNzaW9uIiwiY29uc3RydWN0SmF2YXNjcmlwdEZ1bmN0aW9uIiwicGFyYW1zIiwicGFyYW0iLCJyZXByZXNlbnRKYXZhc2NyaXB0RnVuY3Rpb24iLCJpc0Z1bmN0aW9uIiwid2VicGFja1VuaXZlcnNhbE1vZHVsZURlZmluaXRpb24iLCJyb290IiwiZmFjdG9yeSIsImRlZmluZSIsImFtZCIsIm1vZHVsZXMiLCJpbnN0YWxsZWRNb2R1bGVzIiwiX193ZWJwYWNrX3JlcXVpcmVfXyIsIm1vZHVsZUlkIiwibG9hZGVkIiwiY29tbWVudF9oYW5kbGVyXzEiLCJqc3hfcGFyc2VyXzEiLCJwYXJzZXJfMSIsInRva2VuaXplcl8xIiwiZGVsZWdhdGUiLCJjb21tZW50SGFuZGxlciIsInByb3h5RGVsZWdhdGUiLCJtZXRhZGF0YSIsInZpc2l0IiwicGFyc2VyRGVsZWdhdGUiLCJjb2xsZWN0Q29tbWVudCIsImF0dGFjaENvbW1lbnQiLCJDb21tZW50SGFuZGxlciIsImF0dGFjaCIsImlzTW9kdWxlIiwic291cmNlVHlwZSIsImpzeCIsIkpTWFBhcnNlciIsIlBhcnNlciIsInByb2dyYW0iLCJwYXJzZU1vZHVsZSIsInBhcnNlU2NyaXB0IiwiY29tbWVudHMiLCJ0b2tlbnMiLCJ0b2xlcmFudCIsImVycm9ySGFuZGxlciIsInBhcnNpbmdPcHRpb25zIiwidG9rZW5pemUiLCJ0b2tlbml6ZXIiLCJUb2tlbml6ZXIiLCJnZXROZXh0VG9rZW4iLCJ0b2xlcmF0ZSIsInN5bnRheF8xIiwiU3ludGF4IiwibGVhZGluZyIsInRyYWlsaW5nIiwiaW5zZXJ0SW5uZXJDb21tZW50cyIsIkJsb2NrU3RhdGVtZW50IiwiaW5uZXJDb21tZW50cyIsImVudHJ5IiwiZmluZFRyYWlsaW5nQ29tbWVudHMiLCJ0cmFpbGluZ0NvbW1lbnRzIiwiZW50cnlfMSIsImZpcnN0Q29tbWVudCIsImZpbmRMZWFkaW5nQ29tbWVudHMiLCJsZWFkaW5nQ29tbWVudHMiLCJ2aXNpdE5vZGUiLCJQcm9ncmFtIiwidmlzaXRDb21tZW50IiwibG9jIiwiQXNzaWdubWVudEV4cHJlc3Npb24iLCJBc3NpZ25tZW50UGF0dGVybiIsIkFycmF5RXhwcmVzc2lvbiIsIkFycmF5UGF0dGVybiIsIkFycm93RnVuY3Rpb25FeHByZXNzaW9uIiwiQXdhaXRFeHByZXNzaW9uIiwiQmluYXJ5RXhwcmVzc2lvbiIsIkJyZWFrU3RhdGVtZW50IiwiQ2FsbEV4cHJlc3Npb24iLCJDYXRjaENsYXVzZSIsIkNsYXNzQm9keSIsIkNsYXNzRGVjbGFyYXRpb24iLCJDbGFzc0V4cHJlc3Npb24iLCJDb25kaXRpb25hbEV4cHJlc3Npb24iLCJDb250aW51ZVN0YXRlbWVudCIsIkRvV2hpbGVTdGF0ZW1lbnQiLCJEZWJ1Z2dlclN0YXRlbWVudCIsIkVtcHR5U3RhdGVtZW50IiwiRXhwb3J0QWxsRGVjbGFyYXRpb24iLCJFeHBvcnREZWZhdWx0RGVjbGFyYXRpb24iLCJFeHBvcnROYW1lZERlY2xhcmF0aW9uIiwiRXhwb3J0U3BlY2lmaWVyIiwiRXhwcmVzc2lvblN0YXRlbWVudCIsIkZvclN0YXRlbWVudCIsIkZvck9mU3RhdGVtZW50IiwiRm9ySW5TdGF0ZW1lbnQiLCJGdW5jdGlvbkRlY2xhcmF0aW9uIiwiRnVuY3Rpb25FeHByZXNzaW9uIiwiSWRlbnRpZmllciIsIklmU3RhdGVtZW50IiwiSW1wb3J0RGVjbGFyYXRpb24iLCJJbXBvcnREZWZhdWx0U3BlY2lmaWVyIiwiSW1wb3J0TmFtZXNwYWNlU3BlY2lmaWVyIiwiSW1wb3J0U3BlY2lmaWVyIiwiTGl0ZXJhbCIsIkxhYmVsZWRTdGF0ZW1lbnQiLCJMb2dpY2FsRXhwcmVzc2lvbiIsIk1lbWJlckV4cHJlc3Npb24iLCJNZXRhUHJvcGVydHkiLCJNZXRob2REZWZpbml0aW9uIiwiTmV3RXhwcmVzc2lvbiIsIk9iamVjdEV4cHJlc3Npb24iLCJPYmplY3RQYXR0ZXJuIiwiUHJvcGVydHkiLCJSZXN0RWxlbWVudCIsIlJldHVyblN0YXRlbWVudCIsIlNlcXVlbmNlRXhwcmVzc2lvbiIsIlNwcmVhZEVsZW1lbnQiLCJTdXBlciIsIlN3aXRjaENhc2UiLCJTd2l0Y2hTdGF0ZW1lbnQiLCJUYWdnZWRUZW1wbGF0ZUV4cHJlc3Npb24iLCJUZW1wbGF0ZUVsZW1lbnQiLCJUZW1wbGF0ZUxpdGVyYWwiLCJUaGlzRXhwcmVzc2lvbiIsIlRocm93U3RhdGVtZW50IiwiVHJ5U3RhdGVtZW50IiwiVW5hcnlFeHByZXNzaW9uIiwiVXBkYXRlRXhwcmVzc2lvbiIsIlZhcmlhYmxlRGVjbGFyYXRpb24iLCJWYXJpYWJsZURlY2xhcmF0b3IiLCJXaGlsZVN0YXRlbWVudCIsIldpdGhTdGF0ZW1lbnQiLCJZaWVsZEV4cHJlc3Npb24iLCJfX2V4dGVuZHMiLCJleHRlbmRTdGF0aWNzIiwic2V0UHJvdG90eXBlT2YiLCJjaGFyYWN0ZXJfMSIsIkpTWE5vZGUiLCJqc3hfc3ludGF4XzEiLCJOb2RlIiwidG9rZW5fMSIsInhodG1sX2VudGl0aWVzXzEiLCJUb2tlbk5hbWUiLCJnZXRRdWFsaWZpZWRFbGVtZW50TmFtZSIsInF1YWxpZmllZE5hbWUiLCJKU1hTeW50YXgiLCJKU1hJZGVudGlmaWVyIiwiSlNYTmFtZXNwYWNlZE5hbWUiLCJKU1hNZW1iZXJFeHByZXNzaW9uIiwiZXhwciIsInByb3BlcnR5IiwiX3N1cGVyIiwicGFyc2VQcmltYXJ5RXhwcmVzc2lvbiIsInBhcnNlSlNYUm9vdCIsInN0YXJ0SlNYIiwic2Nhbm5lciIsInN0YXJ0TWFya2VyIiwibGluZU51bWJlciIsImZpbmlzaEpTWCIsIm5leHRUb2tlbiIsInJlZW50ZXJKU1giLCJleHBlY3RKU1giLCJjcmVhdGVKU1hOb2RlIiwiY29sbGVjdENvbW1lbnRzIiwiY3JlYXRlSlNYQ2hpbGROb2RlIiwic2NhblhIVE1MRW50aXR5IiwicXVvdGUiLCJ0ZXJtaW5hdGVkIiwiZW9mIiwiQ2hhcmFjdGVyIiwiaXNEZWNpbWFsRGlnaXQiLCJpc0hleERpZ2l0IiwiWEhUTUxFbnRpdGllcyIsImxleEpTWCIsImNwIiwibjEiLCJuMiIsImlzSWRlbnRpZmllclN0YXJ0IiwiaXNJZGVudGlmaWVyUGFydCIsImxleCIsIm5leHRKU1hUb2tlbiIsImxhc3RNYXJrZXIiLCJjb252ZXJ0VG9rZW4iLCJuZXh0SlNYVGV4dCIsImlzTGluZVRlcm1pbmF0b3IiLCJwZWVrSlNYVG9rZW4iLCJzYXZlU3RhdGUiLCJzY2FuQ29tbWVudHMiLCJyZXN0b3JlU3RhdGUiLCJ0aHJvd1VuZXhwZWN0ZWRUb2tlbiIsIm1hdGNoSlNYIiwicGFyc2VKU1hJZGVudGlmaWVyIiwiZmluYWxpemUiLCJwYXJzZUpTWEVsZW1lbnROYW1lIiwibmFtZV8xIiwicGFyc2VKU1hBdHRyaWJ1dGVOYW1lIiwiYXR0cmlidXRlTmFtZSIsIm5hbWVfMiIsInBhcnNlSlNYU3RyaW5nTGl0ZXJhbEF0dHJpYnV0ZSIsImdldFRva2VuUmF3IiwicGFyc2VKU1hFeHByZXNzaW9uQXR0cmlidXRlIiwidG9sZXJhdGVFcnJvciIsInBhcnNlQXNzaWdubWVudEV4cHJlc3Npb24iLCJKU1hFeHByZXNzaW9uQ29udGFpbmVyIiwicGFyc2VKU1hBdHRyaWJ1dGVWYWx1ZSIsInBhcnNlSlNYRWxlbWVudCIsInBhcnNlSlNYTmFtZVZhbHVlQXR0cmlidXRlIiwiSlNYQXR0cmlidXRlIiwicGFyc2VKU1hTcHJlYWRBdHRyaWJ1dGUiLCJhcmd1bWVudCIsIkpTWFNwcmVhZEF0dHJpYnV0ZSIsInBhcnNlSlNYQXR0cmlidXRlcyIsInBhcnNlSlNYT3BlbmluZ0VsZW1lbnQiLCJKU1hPcGVuaW5nRWxlbWVudCIsInBhcnNlSlNYQm91bmRhcnlFbGVtZW50IiwibmFtZV8zIiwiSlNYQ2xvc2luZ0VsZW1lbnQiLCJwYXJzZUpTWEVtcHR5RXhwcmVzc2lvbiIsIkpTWEVtcHR5RXhwcmVzc2lvbiIsInBhcnNlSlNYRXhwcmVzc2lvbkNvbnRhaW5lciIsInBhcnNlSlNYQ2hpbGRyZW4iLCJjaGlsZHJlbiIsIkpTWFRleHQiLCJjb250YWluZXIiLCJwYXJzZUNvbXBsZXhKU1hFbGVtZW50IiwiZWwiLCJvcGVuaW5nIiwiSlNYRWxlbWVudCIsImNsb3NpbmciLCJvcGVuXzEiLCJjbG9zZV8xIiwiaXNTdGFydE9mRXhwcmVzc2lvbiIsIlJlZ2V4IiwiTm9uQXNjaWlJZGVudGlmaWVyU3RhcnQiLCJOb25Bc2NpaUlkZW50aWZpZXJQYXJ0IiwiaXNXaGl0ZVNwYWNlIiwiaXNPY3RhbERpZ2l0Iiwib3BlbmluZ0VsZW1lbnQiLCJjbG9zaW5nRWxlbWVudCIsImxlZnQiLCJyaWdodCIsIkFzeW5jQXJyb3dGdW5jdGlvbkV4cHJlc3Npb24iLCJBc3luY0Z1bmN0aW9uRGVjbGFyYXRpb24iLCJBc3luY0Z1bmN0aW9uRXhwcmVzc2lvbiIsImxvZ2ljYWwiLCJsYWJlbCIsImNhbGxlZSIsInN1cGVyQ2xhc3MiLCJDb21wdXRlZE1lbWJlckV4cHJlc3Npb24iLCJjb21wdXRlZCIsImNvbnNlcXVlbnQiLCJhbHRlcm5hdGUiLCJEaXJlY3RpdmUiLCJkaXJlY3RpdmUiLCJkZWNsYXJhdGlvbiIsInNwZWNpZmllcnMiLCJleHBvcnRlZCIsImltcG9ydGVkIiwibWV0YSIsImlzU3RhdGljIiwic3RhdGljIiwiTW9kdWxlIiwicHJvcGVydGllcyIsInNob3J0aGFuZCIsIlJlZ2V4TGl0ZXJhbCIsInBhdHRlcm4iLCJTY3JpcHQiLCJleHByZXNzaW9ucyIsIlN0YXRpY01lbWJlckV4cHJlc3Npb24iLCJkaXNjcmltaW5hbnQiLCJjYXNlcyIsInF1YXNpIiwicXVhc2lzIiwiYmxvY2siLCJmaW5hbGl6ZXIiLCJkZWNsYXJhdGlvbnMiLCJhc3NlcnRfMSIsImVycm9yX2hhbmRsZXJfMSIsIm1lc3NhZ2VzXzEiLCJzY2FubmVyXzEiLCJBcnJvd1BhcmFtZXRlclBsYWNlSG9sZGVyIiwiRXJyb3JIYW5kbGVyIiwiU2Nhbm5lciIsInRyYWNrQ29tbWVudCIsIm9wZXJhdG9yUHJlY2VkZW5jZSIsImxvb2thaGVhZCIsImhhc0xpbmVUZXJtaW5hdG9yIiwiYXdhaXQiLCJhbGxvd0luIiwiYWxsb3dTdHJpY3REaXJlY3RpdmUiLCJhbGxvd1lpZWxkIiwiZmlyc3RDb3ZlckluaXRpYWxpemVkTmFtZUVycm9yIiwiaXNBc3NpZ25tZW50VGFyZ2V0IiwiaXNCaW5kaW5nRWxlbWVudCIsImluRnVuY3Rpb25Cb2R5IiwiaW5JdGVyYXRpb24iLCJpblN3aXRjaCIsImxhYmVsU2V0IiwibWVzc2FnZUZvcm1hdCIsIl9pIiwid2hvbGUiLCJjcmVhdGVFcnJvciIsInVuZXhwZWN0ZWRUb2tlbkVycm9yIiwiTWVzc2FnZXMiLCJVbmV4cGVjdGVkVG9rZW4iLCJVbmV4cGVjdGVkRU9TIiwiVW5leHBlY3RlZElkZW50aWZpZXIiLCJVbmV4cGVjdGVkTnVtYmVyIiwiVW5leHBlY3RlZFN0cmluZyIsIlVuZXhwZWN0ZWRUZW1wbGF0ZSIsImlzRnV0dXJlUmVzZXJ2ZWRXb3JkIiwiVW5leHBlY3RlZFJlc2VydmVkIiwiaXNTdHJpY3RNb2RlUmVzZXJ2ZWRXb3JkIiwiU3RyaWN0UmVzZXJ2ZWRXb3JkIiwibGFzdE1hcmtlckxpbmVTdGFydCIsInRvbGVyYXRlVW5leHBlY3RlZFRva2VuIiwibXVsdGlMaW5lIiwibmV4dFJlZ2V4VG9rZW4iLCJzY2FuUmVnRXhwIiwiY3JlYXRlTm9kZSIsInN0YXJ0Tm9kZSIsIm1hcmtlciIsImV4cGVjdCIsImV4cGVjdENvbW1hU2VwYXJhdG9yIiwiZXhwZWN0S2V5d29yZCIsImtleXdvcmQiLCJtYXRjaEtleXdvcmQiLCJtYXRjaENvbnRleHR1YWxLZXl3b3JkIiwibWF0Y2hBc3NpZ24iLCJpc29sYXRlQ292ZXJHcmFtbWFyIiwicGFyc2VGdW5jdGlvbiIsInByZXZpb3VzSXNCaW5kaW5nRWxlbWVudCIsInByZXZpb3VzSXNBc3NpZ25tZW50VGFyZ2V0IiwicHJldmlvdXNGaXJzdENvdmVySW5pdGlhbGl6ZWROYW1lRXJyb3IiLCJpbmhlcml0Q292ZXJHcmFtbWFyIiwiY29uc3VtZVNlbWljb2xvbiIsIm1hdGNoQXN5bmNGdW5jdGlvbiIsInBhcnNlRnVuY3Rpb25FeHByZXNzaW9uIiwiU3RyaWN0T2N0YWxMaXRlcmFsIiwicGFyc2VUZW1wbGF0ZUxpdGVyYWwiLCJwYXJzZUdyb3VwRXhwcmVzc2lvbiIsInBhcnNlQXJyYXlJbml0aWFsaXplciIsInBhcnNlT2JqZWN0SW5pdGlhbGl6ZXIiLCJwYXJzZUlkZW50aWZpZXJOYW1lIiwicGFyc2VDbGFzc0V4cHJlc3Npb24iLCJwYXJzZVNwcmVhZEVsZW1lbnQiLCJwYXJzZVByb3BlcnR5TWV0aG9kIiwicHJldmlvdXNTdHJpY3QiLCJwcmV2aW91c0FsbG93U3RyaWN0RGlyZWN0aXZlIiwic2ltcGxlIiwicGFyc2VGdW5jdGlvblNvdXJjZUVsZW1lbnRzIiwiZmlyc3RSZXN0cmljdGVkIiwic3RyaWN0ZWQiLCJwYXJzZVByb3BlcnR5TWV0aG9kRnVuY3Rpb24iLCJpc0dlbmVyYXRvciIsInByZXZpb3VzQWxsb3dZaWVsZCIsInBhcnNlRm9ybWFsUGFyYW1ldGVycyIsInBhcnNlUHJvcGVydHlNZXRob2RBc3luY0Z1bmN0aW9uIiwicHJldmlvdXNBd2FpdCIsInBhcnNlT2JqZWN0UHJvcGVydHlLZXkiLCJpc1Byb3BlcnR5S2V5IiwicGFyc2VPYmplY3RQcm9wZXJ0eSIsImhhc1Byb3RvIiwiaXNBc3luYyIsImxvb2thaGVhZFByb3BlcnR5S2V5IiwicXVhbGlmaWVkUHJvcGVydHlOYW1lIiwicGFyc2VHZXR0ZXJNZXRob2QiLCJwYXJzZVNldHRlck1ldGhvZCIsInBhcnNlR2VuZXJhdG9yTWV0aG9kIiwiRHVwbGljYXRlUHJvdG9Qcm9wZXJ0eSIsInBhcnNlVGVtcGxhdGVIZWFkIiwiY29va2VkIiwicGFyc2VUZW1wbGF0ZUVsZW1lbnQiLCJwYXJzZUV4cHJlc3Npb24iLCJyZWludGVycHJldEV4cHJlc3Npb25Bc1BhdHRlcm4iLCJzdGFydFRva2VuIiwicGFyc2VSZXN0RWxlbWVudCIsImFycm93IiwicGFyYW1ldGVycyIsInBhcnNlQXJndW1lbnRzIiwiaXNJZGVudGlmaWVyTmFtZSIsInBhcnNlTmV3RXhwcmVzc2lvbiIsInBhcnNlTGVmdEhhbmRTaWRlRXhwcmVzc2lvbiIsInBhcnNlQXN5bmNBcmd1bWVudCIsInBhcnNlQXN5bmNBcmd1bWVudHMiLCJwYXJzZUxlZnRIYW5kU2lkZUV4cHJlc3Npb25BbGxvd0NhbGwiLCJtYXliZUFzeW5jIiwicHJldmlvdXNBbGxvd0luIiwiYXN5bmNBcnJvdyIsInBhcnNlU3VwZXIiLCJwYXJzZVVwZGF0ZUV4cHJlc3Npb24iLCJwYXJzZVVuYXJ5RXhwcmVzc2lvbiIsImlzUmVzdHJpY3RlZFdvcmQiLCJTdHJpY3RMSFNQcmVmaXgiLCJJbnZhbGlkTEhTSW5Bc3NpZ25tZW50IiwiU3RyaWN0TEhTUG9zdGZpeCIsInBhcnNlQXdhaXRFeHByZXNzaW9uIiwiU3RyaWN0RGVsZXRlIiwicGFyc2VFeHBvbmVudGlhdGlvbkV4cHJlc3Npb24iLCJiaW5hcnlQcmVjZWRlbmNlIiwicHJlY2VkZW5jZSIsInBhcnNlQmluYXJ5RXhwcmVzc2lvbiIsInByZWMiLCJtYXJrZXJzIiwicHJlY2VkZW5jZXMiLCJwYXJzZUNvbmRpdGlvbmFsRXhwcmVzc2lvbiIsImNoZWNrUGF0dGVyblBhcmFtIiwidmFsaWRhdGVQYXJhbSIsInJlaW50ZXJwcmV0QXNDb3ZlckZvcm1hbHNMaXN0IiwicGFyYW1TZXQiLCJTdHJpY3RQYXJhbUR1cGUiLCJwYXJzZVlpZWxkRXhwcmVzc2lvbiIsIlN0cmljdExIU0Fzc2lnbm1lbnQiLCJwYXJzZVN0YXRlbWVudExpc3RJdGVtIiwic3RhdGVtZW50IiwiSWxsZWdhbEV4cG9ydERlY2xhcmF0aW9uIiwicGFyc2VFeHBvcnREZWNsYXJhdGlvbiIsIklsbGVnYWxJbXBvcnREZWNsYXJhdGlvbiIsInBhcnNlSW1wb3J0RGVjbGFyYXRpb24iLCJwYXJzZUxleGljYWxEZWNsYXJhdGlvbiIsImluRm9yIiwicGFyc2VGdW5jdGlvbkRlY2xhcmF0aW9uIiwicGFyc2VDbGFzc0RlY2xhcmF0aW9uIiwiaXNMZXhpY2FsRGVjbGFyYXRpb24iLCJwYXJzZVN0YXRlbWVudCIsInBhcnNlQmxvY2siLCJwYXJzZUxleGljYWxCaW5kaW5nIiwicGFyc2VQYXR0ZXJuIiwiU3RyaWN0VmFyTmFtZSIsIkRlY2xhcmF0aW9uTWlzc2luZ0luaXRpYWxpemVyIiwicGFyc2VCaW5kaW5nTGlzdCIsInBhcnNlQmluZGluZ1Jlc3RFbGVtZW50IiwicGFyc2VBcnJheVBhdHRlcm4iLCJwYXJzZVBhdHRlcm5XaXRoRGVmYXVsdCIsInBhcnNlUHJvcGVydHlQYXR0ZXJuIiwia2V5VG9rZW4iLCJwYXJzZVZhcmlhYmxlSWRlbnRpZmllciIsInBhcnNlT2JqZWN0UGF0dGVybiIsIkxldEluTGV4aWNhbEJpbmRpbmciLCJwYXJzZVZhcmlhYmxlRGVjbGFyYXRpb24iLCJwYXJzZVZhcmlhYmxlRGVjbGFyYXRpb25MaXN0IiwicGFyc2VWYXJpYWJsZVN0YXRlbWVudCIsInBhcnNlRW1wdHlTdGF0ZW1lbnQiLCJwYXJzZUV4cHJlc3Npb25TdGF0ZW1lbnQiLCJwYXJzZUlmQ2xhdXNlIiwiU3RyaWN0RnVuY3Rpb24iLCJwYXJzZUlmU3RhdGVtZW50IiwicGFyc2VEb1doaWxlU3RhdGVtZW50IiwicHJldmlvdXNJbkl0ZXJhdGlvbiIsInBhcnNlV2hpbGVTdGF0ZW1lbnQiLCJwYXJzZUZvclN0YXRlbWVudCIsImZvckluIiwiZGVjbCIsIkZvckluT2ZMb29wSW5pdGlhbGl6ZXIiLCJpbml0U3RhcnRUb2tlbiIsIkludmFsaWRMSFNJbkZvckluIiwiSW52YWxpZExIU0luRm9yTG9vcCIsImluaXRTZXEiLCJwYXJzZUNvbnRpbnVlU3RhdGVtZW50IiwiVW5rbm93bkxhYmVsIiwiSWxsZWdhbENvbnRpbnVlIiwicGFyc2VCcmVha1N0YXRlbWVudCIsIklsbGVnYWxCcmVhayIsInBhcnNlUmV0dXJuU3RhdGVtZW50IiwiSWxsZWdhbFJldHVybiIsImhhc0FyZ3VtZW50IiwicGFyc2VXaXRoU3RhdGVtZW50IiwiU3RyaWN0TW9kZVdpdGgiLCJwYXJzZVN3aXRjaENhc2UiLCJwYXJzZVN3aXRjaFN0YXRlbWVudCIsInByZXZpb3VzSW5Td2l0Y2giLCJkZWZhdWx0Rm91bmQiLCJjbGF1c2UiLCJNdWx0aXBsZURlZmF1bHRzSW5Td2l0Y2giLCJwYXJzZUxhYmVsbGVkU3RhdGVtZW50IiwiUmVkZWNsYXJhdGlvbiIsIkdlbmVyYXRvckluTGVnYWN5Q29udGV4dCIsInBhcnNlVGhyb3dTdGF0ZW1lbnQiLCJOZXdsaW5lQWZ0ZXJUaHJvdyIsInBhcnNlQ2F0Y2hDbGF1c2UiLCJwYXJhbU1hcCIsIkR1cGxpY2F0ZUJpbmRpbmciLCJTdHJpY3RDYXRjaFZhcmlhYmxlIiwicGFyc2VGaW5hbGx5Q2xhdXNlIiwicGFyc2VUcnlTdGF0ZW1lbnQiLCJOb0NhdGNoT3JGaW5hbGx5IiwicGFyc2VEZWJ1Z2dlclN0YXRlbWVudCIsInBhcnNlRGlyZWN0aXZlUHJvbG9ndWVzIiwicHJldmlvdXNMYWJlbFNldCIsInByZXZpb3VzSW5GdW5jdGlvbkJvZHkiLCJTdHJpY3RQYXJhbU5hbWUiLCJEZWZhdWx0UmVzdFBhcmFtZXRlciIsIlBhcmFtZXRlckFmdGVyUmVzdFBhcmFtZXRlciIsInBhcnNlRm9ybWFsUGFyYW1ldGVyIiwiaWRlbnRpZmllcklzT3B0aW9uYWwiLCJTdHJpY3RGdW5jdGlvbk5hbWUiLCJwcmV2aW91c0FsbG93QXdhaXQiLCJmb3JtYWxQYXJhbWV0ZXJzIiwicGFyc2VEaXJlY3RpdmUiLCJJbGxlZ2FsTGFuZ3VhZ2VNb2RlRGlyZWN0aXZlIiwiQmFkR2V0dGVyQXJpdHkiLCJCYWRTZXR0ZXJBcml0eSIsIkJhZFNldHRlclJlc3RQYXJhbWV0ZXIiLCJwYXJzZUNsYXNzRWxlbWVudCIsImhhc0NvbnN0cnVjdG9yIiwicHVuY3R1YXRvciIsIkNvbnN0cnVjdG9ySXNBc3luYyIsIlN0YXRpY1Byb3RvdHlwZSIsIkNvbnN0cnVjdG9yU3BlY2lhbE1ldGhvZCIsIkR1cGxpY2F0ZUNvbnN0cnVjdG9yIiwicGFyc2VDbGFzc0VsZW1lbnRMaXN0IiwicGFyc2VDbGFzc0JvZHkiLCJlbGVtZW50TGlzdCIsImNsYXNzQm9keSIsInBhcnNlTW9kdWxlU3BlY2lmaWVyIiwiSW52YWxpZE1vZHVsZVNwZWNpZmllciIsInBhcnNlSW1wb3J0U3BlY2lmaWVyIiwicGFyc2VOYW1lZEltcG9ydHMiLCJwYXJzZUltcG9ydERlZmF1bHRTcGVjaWZpZXIiLCJwYXJzZUltcG9ydE5hbWVzcGFjZVNwZWNpZmllciIsIk5vQXNBZnRlckltcG9ydE5hbWVzcGFjZSIsIk1pc3NpbmdGcm9tQ2xhdXNlIiwicGFyc2VFeHBvcnRTcGVjaWZpZXIiLCJleHBvcnREZWNsYXJhdGlvbiIsImlzRXhwb3J0RnJvbUlkZW50aWZpZXIiLCJjb25kaXRpb24iLCJyZWNvcmRFcnJvciIsImNvbnN0cnVjdEVycm9yIiwiY29sIiwiSW52YWxpZEVzY2FwZWRSZXNlcnZlZFdvcmQiLCJJbnZhbGlkSGV4RXNjYXBlU2VxdWVuY2UiLCJJbnZhbGlkUmVnRXhwIiwiVGVtcGxhdGVPY3RhbExpdGVyYWwiLCJVbmV4cGVjdGVkVG9rZW5JbGxlZ2FsIiwiVW50ZXJtaW5hdGVkUmVnRXhwIiwiaGV4VmFsdWUiLCJvY3RhbFZhbHVlIiwiY3VybHlTdGFjayIsInNraXBTaW5nbGVMaW5lQ29tbWVudCIsInNraXBNdWx0aUxpbmVDb21tZW50IiwiaXNLZXl3b3JkIiwiY29kZVBvaW50QXQiLCJmaXJzdCIsInNjYW5IZXhFc2NhcGUiLCJzY2FuVW5pY29kZUNvZGVQb2ludEVzY2FwZSIsImdldElkZW50aWZpZXIiLCJnZXRDb21wbGV4SWRlbnRpZmllciIsIm9jdGFsVG9EZWNpbWFsIiwic2NhbklkZW50aWZpZXIiLCJyZXN0b3JlIiwic2NhblB1bmN0dWF0b3IiLCJzY2FuSGV4TGl0ZXJhbCIsInNjYW5CaW5hcnlMaXRlcmFsIiwic2Nhbk9jdGFsTGl0ZXJhbCIsImlzSW1wbGljaXRPY3RhbExpdGVyYWwiLCJzY2FuTnVtZXJpY0xpdGVyYWwiLCJzY2FuU3RyaW5nTGl0ZXJhbCIsInVuZXNjYXBlZF8xIiwidW5lc2NhcGVkIiwib2N0VG9EZWMiLCJzY2FuVGVtcGxhdGUiLCJyYXdPZmZzZXQiLCJ1bmVzY2FwZWRfMiIsInRlc3RSZWdFeHAiLCJhc3RyYWxTdWJzdGl0dXRlIiwiJDIiLCJzY2FuUmVnRXhwQm9keSIsImNsYXNzTWFya2VyIiwic2NhblJlZ0V4cEZsYWdzIiwiY2hhciIsInF1b3QiLCJhbXAiLCJhcG9zIiwibmJzcCIsImlleGNsIiwiY2VudCIsInBvdW5kIiwiY3VycmVuIiwieWVuIiwiYnJ2YmFyIiwic2VjdCIsInVtbCIsIm9yZGYiLCJsYXF1byIsInNoeSIsInJlZyIsIm1hY3IiLCJkZWciLCJwbHVzbW4iLCJzdXAyIiwic3VwMyIsImFjdXRlIiwibWljcm8iLCJwYXJhIiwibWlkZG90IiwiY2VkaWwiLCJzdXAxIiwib3JkbSIsInJhcXVvIiwiZnJhYzE0IiwiZnJhYzEyIiwiZnJhYzM0IiwiaXF1ZXN0IiwiQWdyYXZlIiwiQWFjdXRlIiwiQWNpcmMiLCJBdGlsZGUiLCJBdW1sIiwiQXJpbmciLCJBRWxpZyIsIkNjZWRpbCIsIkVncmF2ZSIsIkVhY3V0ZSIsIkVjaXJjIiwiRXVtbCIsIklncmF2ZSIsIklhY3V0ZSIsIkljaXJjIiwiSXVtbCIsIkVUSCIsIk50aWxkZSIsIk9ncmF2ZSIsIk9hY3V0ZSIsIk9jaXJjIiwiT3RpbGRlIiwiT3VtbCIsInRpbWVzIiwiT3NsYXNoIiwiVWdyYXZlIiwiVWFjdXRlIiwiVWNpcmMiLCJVdW1sIiwiWWFjdXRlIiwiVEhPUk4iLCJzemxpZyIsImFncmF2ZSIsImFhY3V0ZSIsImFjaXJjIiwiYXRpbGRlIiwiYXVtbCIsImFyaW5nIiwiYWVsaWciLCJjY2VkaWwiLCJlZ3JhdmUiLCJlYWN1dGUiLCJlY2lyYyIsImV1bWwiLCJpZ3JhdmUiLCJpYWN1dGUiLCJpY2lyYyIsIml1bWwiLCJldGgiLCJudGlsZGUiLCJvZ3JhdmUiLCJvYWN1dGUiLCJvY2lyYyIsIm90aWxkZSIsIm91bWwiLCJkaXZpZGUiLCJvc2xhc2giLCJ1Z3JhdmUiLCJ1YWN1dGUiLCJ1Y2lyYyIsInV1bWwiLCJ5YWN1dGUiLCJ0aG9ybiIsInl1bWwiLCJPRWxpZyIsIm9lbGlnIiwiU2Nhcm9uIiwic2Nhcm9uIiwiWXVtbCIsImZub2YiLCJjaXJjIiwidGlsZGUiLCJBbHBoYSIsIkJldGEiLCJHYW1tYSIsIkRlbHRhIiwiRXBzaWxvbiIsIlpldGEiLCJFdGEiLCJUaGV0YSIsIklvdGEiLCJLYXBwYSIsIkxhbWJkYSIsIk11IiwiTnUiLCJYaSIsIk9taWNyb24iLCJQaSIsIlJobyIsIlNpZ21hIiwiVGF1IiwiVXBzaWxvbiIsIlBoaSIsIkNoaSIsIlBzaSIsIk9tZWdhIiwiYWxwaGEiLCJiZXRhIiwiZ2FtbWEiLCJlcHNpbG9uIiwiemV0YSIsImV0YSIsInRoZXRhIiwiaW90YSIsImthcHBhIiwibGFtYmRhIiwibXUiLCJudSIsInhpIiwib21pY3JvbiIsInBpIiwicmhvIiwic2lnbWFmIiwic2lnbWEiLCJ0YXUiLCJ1cHNpbG9uIiwicGhpIiwiY2hpIiwicHNpIiwib21lZ2EiLCJ0aGV0YXN5bSIsInVwc2loIiwicGl2IiwiZW5zcCIsImVtc3AiLCJ0aGluc3AiLCJ6d25qIiwiendqIiwibHJtIiwicmxtIiwibmRhc2giLCJtZGFzaCIsImxzcXVvIiwicnNxdW8iLCJzYnF1byIsImxkcXVvIiwicmRxdW8iLCJiZHF1byIsImRhZ2dlciIsIkRhZ2dlciIsImJ1bGwiLCJoZWxsaXAiLCJwZXJtaWwiLCJwcmltZSIsIlByaW1lIiwibHNhcXVvIiwicnNhcXVvIiwib2xpbmUiLCJmcmFzbCIsImV1cm8iLCJpbWFnZSIsIndlaWVycCIsInJlYWwiLCJ0cmFkZSIsImFsZWZzeW0iLCJsYXJyIiwidWFyciIsInJhcnIiLCJkYXJyIiwiaGFyciIsImNyYXJyIiwibEFyciIsInVBcnIiLCJyQXJyIiwiZEFyciIsImhBcnIiLCJmb3JhbGwiLCJleGlzdCIsImVtcHR5IiwibmFibGEiLCJpc2luIiwibm90aW4iLCJuaSIsInByb2QiLCJzdW0iLCJtaW51cyIsImxvd2FzdCIsInJhZGljIiwiaW5maW4iLCJhbmciLCJhbmQiLCJvciIsImNhcCIsImN1cCIsImludCIsInRoZXJlNCIsInNpbSIsImNvbmciLCJhc3ltcCIsIm5lIiwiZXF1aXYiLCJsZSIsImdlIiwic3ViIiwic3VwIiwibnN1YiIsInN1YmUiLCJzdXBlIiwib3BsdXMiLCJvdGltZXMiLCJwZXJwIiwic2RvdCIsImxjZWlsIiwicmNlaWwiLCJsZmxvb3IiLCJyZmxvb3IiLCJsb3oiLCJzcGFkZXMiLCJjbHVicyIsImhlYXJ0cyIsImRpYW1zIiwibGFuZyIsInJhbmciLCJSZWFkZXIiLCJjdXJseSIsInBhcmVuIiwiYmVmb3JlRnVuY3Rpb25FeHByZXNzaW9uIiwiaXNSZWdleFN0YXJ0IiwicHJldmlvdXMiLCJ0cmFja1JhbmdlIiwidHJhY2tMb2MiLCJyZWFkZXIiLCJzdGFydFJlZ2V4IiwiQ0hBUl9UQUIiLCJDSEFSX0xJTkVfRkVFRCIsIkNIQVJfU1BBQ0UiLCJDSEFSX0VYQ0xBTUFUSU9OIiwiQ0hBUl9ET1VCTEVfUVVPVEUiLCJDSEFSX1NIQVJQIiwiQ0hBUl9QRVJDRU5UIiwiQ0hBUl9BTVBFUlNBTkQiLCJDSEFSX1NJTkdMRV9RVU9URSIsIkNIQVJfQVNURVJJU0siLCJDSEFSX0NPTU1BIiwiQ0hBUl9NSU5VUyIsIkNIQVJfQ09MT04iLCJDSEFSX0dSRUFURVJfVEhBTiIsIkNIQVJfUVVFU1RJT04iLCJDSEFSX0NPTU1FUkNJQUxfQVQiLCJDSEFSX0xFRlRfU1FVQVJFX0JSQUNLRVQiLCJDSEFSX1JJR0hUX1NRVUFSRV9CUkFDS0VUIiwiQ0hBUl9HUkFWRV9BQ0NFTlQiLCJDSEFSX0xFRlRfQ1VSTFlfQlJBQ0tFVCIsIkNIQVJfVkVSVElDQUxfTElORSIsIkNIQVJfUklHSFRfQ1VSTFlfQlJBQ0tFVCIsIkVTQ0FQRV9TRVFVRU5DRVMiLCJERVBSRUNBVEVEX0JPT0xFQU5TX1NZTlRBWCIsImNvbXBpbGVTdHlsZU1hcCIsImVuY29kZUhleCIsImNoYXJhY3RlciIsInNraXBJbnZhbGlkIiwiZmxvd0xldmVsIiwic3R5bGVNYXAiLCJzb3J0S2V5cyIsImxpbmVXaWR0aCIsIm5vUmVmcyIsIm5vQ29tcGF0TW9kZSIsImNvbmRlbnNlRmxvdyIsImV4cGxpY2l0VHlwZXMiLCJkdXBsaWNhdGVzIiwidXNlZER1cGxpY2F0ZXMiLCJpbmRlbnRTdHJpbmciLCJpbmQiLCJnZW5lcmF0ZU5leHRMaW5lIiwidGVzdEltcGxpY2l0UmVzb2x2aW5nIiwiaXNQcmludGFibGUiLCJpc1BsYWluU2FmZSIsImlzUGxhaW5TYWZlRmlyc3QiLCJTVFlMRV9QTEFJTiIsIlNUWUxFX1NJTkdMRSIsIlNUWUxFX0xJVEVSQUwiLCJTVFlMRV9GT0xERUQiLCJTVFlMRV9ET1VCTEUiLCJjaG9vc2VTY2FsYXJTdHlsZSIsInNpbmdsZUxpbmVPbmx5IiwiaW5kZW50UGVyTGV2ZWwiLCJ0ZXN0QW1iaWd1b3VzVHlwZSIsImhhc0xpbmVCcmVhayIsImhhc0ZvbGRhYmxlTGluZSIsInNob3VsZFRyYWNrV2lkdGgiLCJwcmV2aW91c0xpbmVCcmVhayIsInBsYWluIiwid3JpdGVTY2FsYXIiLCJpc2tleSIsInRlc3RBbWJpZ3VpdHkiLCJibG9ja0hlYWRlciIsImRyb3BFbmRpbmdOZXdsaW5lIiwiZm9sZFN0cmluZyIsImVzY2FwZVN0cmluZyIsImluZGVudEluZGljYXRvciIsImNsaXAiLCJrZWVwIiwiY2hvbXAiLCJ3aWR0aCIsImxpbmVSZSIsIm5leHRMRiIsImZvbGRMaW5lIiwicHJldk1vcmVJbmRlbnRlZCIsIm1vcmVJbmRlbnRlZCIsImJyZWFrUmUiLCJuZXh0Q2hhciIsImVzY2FwZVNlcSIsIndyaXRlRmxvd1NlcXVlbmNlIiwid3JpdGVOb2RlIiwid3JpdGVCbG9ja1NlcXVlbmNlIiwid3JpdGVGbG93TWFwcGluZyIsIm9iamVjdEtleUxpc3QiLCJvYmplY3RLZXkiLCJvYmplY3RWYWx1ZSIsInBhaXJCdWZmZXIiLCJ3cml0ZUJsb2NrTWFwcGluZyIsImV4cGxpY2l0UGFpciIsImRldGVjdFR5cGUiLCJ0eXBlTGlzdCIsIm9iamVjdE9yQXJyYXkiLCJkdXBsaWNhdGVJbmRleCIsImR1cGxpY2F0ZSIsImdldER1cGxpY2F0ZVJlZmVyZW5jZXMiLCJvYmplY3RzIiwiZHVwbGljYXRlc0luZGV4ZXMiLCJpbnNwZWN0Tm9kZSIsImNyZWF0b3IiLCJoYXNWYWx1ZSIsIlNvdXJjZU1hcENvbnN1bWVyIiwiZXJyb3JGb3JtYXR0ZXJJbnN0YWxsZWQiLCJ1bmNhdWdodFNoaW1JbnN0YWxsZWQiLCJlbXB0eUNhY2hlQmV0d2Vlbk9wZXJhdGlvbnMiLCJlbnZpcm9ubWVudCIsImZpbGVDb250ZW50c0NhY2hlIiwic291cmNlTWFwQ2FjaGUiLCJyZVNvdXJjZU1hcCIsInJldHJpZXZlRmlsZUhhbmRsZXJzIiwicmV0cmlldmVNYXBIYW5kbGVycyIsImlzSW5Ccm93c2VyIiwiWE1MSHR0cFJlcXVlc3QiLCJoYXNHbG9iYWxQcm9jZXNzRXZlbnRFbWl0dGVyIiwiaGFuZGxlckV4ZWMiLCJyZXRyaWV2ZUZpbGUiLCJjb250ZW50cyIsInhociIsInNlbmQiLCJyZWFkeVN0YXRlIiwic3RhdHVzIiwicmVzcG9uc2VUZXh0Iiwic3VwcG9ydFJlbGF0aXZlVVJMIiwicmV0cmlldmVTb3VyY2VNYXBVUkwiLCJmaWxlRGF0YSIsInNvdXJjZU1hcEhlYWRlciIsImdldFJlc3BvbnNlSGVhZGVyIiwibGFzdE1hdGNoIiwicmV0cmlldmVTb3VyY2VNYXAiLCJzb3VyY2VNYXBwaW5nVVJMIiwic291cmNlTWFwRGF0YSIsIm1hcFNvdXJjZVBvc2l0aW9uIiwic291cmNlTWFwIiwidXJsQW5kTWFwIiwib3JpZ2luYWxQb3NpdGlvbiIsIm1hcEV2YWxPcmlnaW4iLCJvcmlnaW4iLCJDYWxsU2l0ZVRvU3RyaW5nIiwiZmlsZUxvY2F0aW9uIiwiaXNOYXRpdmUiLCJnZXRTY3JpcHROYW1lT3JTb3VyY2VVUkwiLCJpc0V2YWwiLCJnZXRFdmFsT3JpZ2luIiwiZ2V0TGluZU51bWJlciIsImNvbHVtbk51bWJlciIsImdldENvbHVtbk51bWJlciIsImZ1bmN0aW9uTmFtZSIsImdldEZ1bmN0aW9uTmFtZSIsImFkZFN1ZmZpeCIsImlzQ29uc3RydWN0b3IiLCJpc01ldGhvZENhbGwiLCJpc1RvcGxldmVsIiwidHlwZU5hbWUiLCJnZXRUeXBlTmFtZSIsImdldE1ldGhvZE5hbWUiLCJjbG9uZUNhbGxTaXRlIiwiZnJhbWUiLCJ3cmFwQ2FsbFNpdGUiLCJnZXRGaWxlTmFtZSIsImhlYWRlckxlbmd0aCIsInByZXBhcmVTdGFja1RyYWNlIiwiZ2V0RXJyb3JTb3VyY2UiLCJwcmludEVycm9yQW5kRXhpdCIsInNoaW1FbWl0VW5jYXVnaHRFeGNlcHRpb24iLCJvcmlnRW1pdCIsImhhc0xpc3RlbmVycyIsImxpc3RlbmVycyIsIm92ZXJyaWRlUmV0cmlldmVGaWxlIiwib3ZlcnJpZGVSZXRyaWV2ZVNvdXJjZU1hcCIsImhvb2tSZXF1aXJlIiwiJGNvbXBpbGUiLCJfY29tcGlsZSIsIl9fc291cmNlTWFwU3VwcG9ydCIsImluc3RhbGxIYW5kbGVyIiwiaGFuZGxlVW5jYXVnaHRFeGNlcHRpb25zIiwiU291cmNlTm9kZSIsImludFRvQ2hhck1hcCIsImNoYXJDb2RlIiwiYmlnQSIsImJpZ1oiLCJsaXR0bGVBIiwibGl0dGxlWiIsInplcm8iLCJuaW5lIiwicGx1cyIsInNsYXNoIiwibGl0dGxlT2Zmc2V0IiwibnVtYmVyT2Zmc2V0IiwiZ2VuZXJhdGVkUG9zaXRpb25BZnRlciIsImxpbmVBIiwibGluZUIiLCJjb2x1bW5BIiwiY29sdW1uQiIsIl9zb3J0ZWQiLCJfbGFzdCIsIk1hcHBpbmdMaXN0X2ZvckVhY2giLCJhQ2FsbGJhY2siLCJhVGhpc0FyZyIsIk1hcHBpbmdMaXN0X2FkZCIsImFNYXBwaW5nIiwiTWFwcGluZ0xpc3RfdG9BcnJheSIsImJpbmFyeVNlYXJjaCIsInF1aWNrU29ydCIsImFTb3VyY2VNYXAiLCJhU291cmNlTWFwVVJMIiwic2VjdGlvbnMiLCJJbmRleGVkU291cmNlTWFwQ29uc3VtZXIiLCJCYXNpY1NvdXJjZU1hcENvbnN1bWVyIiwiX19nZW5lcmF0ZWRNYXBwaW5ncyIsIl9wYXJzZU1hcHBpbmdzIiwiX19vcmlnaW5hbE1hcHBpbmdzIiwiX2NoYXJJc01hcHBpbmdTZXBhcmF0b3IiLCJTb3VyY2VNYXBDb25zdW1lcl9jaGFySXNNYXBwaW5nU2VwYXJhdG9yIiwiU291cmNlTWFwQ29uc3VtZXJfcGFyc2VNYXBwaW5ncyIsIkdFTkVSQVRFRF9PUkRFUiIsIk9SSUdJTkFMX09SREVSIiwiR1JFQVRFU1RfTE9XRVJfQk9VTkQiLCJMRUFTVF9VUFBFUl9CT1VORCIsIlNvdXJjZU1hcENvbnN1bWVyX2VhY2hNYXBwaW5nIiwiYUNvbnRleHQiLCJhT3JkZXIiLCJvcmRlciIsIl9nZW5lcmF0ZWRNYXBwaW5ncyIsIl9vcmlnaW5hbE1hcHBpbmdzIiwiX3NvdXJjZU1hcFVSTCIsImFsbEdlbmVyYXRlZFBvc2l0aW9uc0ZvciIsIlNvdXJjZU1hcENvbnN1bWVyX2FsbEdlbmVyYXRlZFBvc2l0aW9uc0ZvciIsIm5lZWRsZSIsIl9maW5kU291cmNlSW5kZXgiLCJfZmluZE1hcHBpbmciLCJsYXN0Q29sdW1uIiwiX2Fic29sdXRlU291cmNlcyIsImNvbnN1bWVyIiwicmVsYXRpdmVTb3VyY2UiLCJTb3VyY2VNYXBDb25zdW1lcl9mcm9tU291cmNlTWFwIiwic21jIiwiZ2VuZXJhdGVkTWFwcGluZ3MiLCJkZXN0R2VuZXJhdGVkTWFwcGluZ3MiLCJkZXN0T3JpZ2luYWxNYXBwaW5ncyIsInNyY01hcHBpbmciLCJkZXN0TWFwcGluZyIsIk1hcHBpbmciLCJjYWNoZWRTZWdtZW50cyIsInRlbXAiLCJvcmlnaW5hbE1hcHBpbmdzIiwic2VnbWVudCIsIlNvdXJjZU1hcENvbnN1bWVyX2ZpbmRNYXBwaW5nIiwiYU5lZWRsZSIsImFNYXBwaW5ncyIsImFMaW5lTmFtZSIsImFDb2x1bW5OYW1lIiwiYUNvbXBhcmF0b3IiLCJhQmlhcyIsImNvbXB1dGVDb2x1bW5TcGFucyIsIlNvdXJjZU1hcENvbnN1bWVyX2NvbXB1dGVDb2x1bW5TcGFucyIsIm5leHRNYXBwaW5nIiwibGFzdEdlbmVyYXRlZENvbHVtbiIsIlNvdXJjZU1hcENvbnN1bWVyX29yaWdpbmFsUG9zaXRpb25Gb3IiLCJoYXNDb250ZW50c09mQWxsU291cmNlcyIsIkJhc2ljU291cmNlTWFwQ29uc3VtZXJfaGFzQ29udGVudHNPZkFsbFNvdXJjZXMiLCJzYyIsIlNvdXJjZU1hcENvbnN1bWVyX3NvdXJjZUNvbnRlbnRGb3IiLCJudWxsT25NaXNzaW5nIiwiZmlsZVVyaUFic1BhdGgiLCJnZW5lcmF0ZWRQb3NpdGlvbkZvciIsIlNvdXJjZU1hcENvbnN1bWVyX2dlbmVyYXRlZFBvc2l0aW9uRm9yIiwibGFzdE9mZnNldCIsIl9zZWN0aW9ucyIsIm9mZnNldExpbmUiLCJvZmZzZXRDb2x1bW4iLCJnZW5lcmF0ZWRPZmZzZXQiLCJJbmRleGVkU291cmNlTWFwQ29uc3VtZXJfb3JpZ2luYWxQb3NpdGlvbkZvciIsInNlY3Rpb25JbmRleCIsInNlY3Rpb24iLCJiaWFzIiwiSW5kZXhlZFNvdXJjZU1hcENvbnN1bWVyX2hhc0NvbnRlbnRzT2ZBbGxTb3VyY2VzIiwiSW5kZXhlZFNvdXJjZU1hcENvbnN1bWVyX3NvdXJjZUNvbnRlbnRGb3IiLCJJbmRleGVkU291cmNlTWFwQ29uc3VtZXJfZ2VuZXJhdGVkUG9zaXRpb25Gb3IiLCJnZW5lcmF0ZWRQb3NpdGlvbiIsIkluZGV4ZWRTb3VyY2VNYXBDb25zdW1lcl9wYXJzZU1hcHBpbmdzIiwic2VjdGlvbk1hcHBpbmdzIiwiYWRqdXN0ZWRNYXBwaW5nIiwicmVjdXJzaXZlU2VhcmNoIiwiYUxvdyIsImFIaWdoIiwiYUhheXN0YWNrIiwiYUNvbXBhcmUiLCJtaWQiLCJzd2FwIiwiYXJ5IiwicmFuZG9tSW50SW5SYW5nZSIsImRvUXVpY2tTb3J0IiwicGl2b3RJbmRleCIsInBpdm90IiwiUkVHRVhfTkVXTElORSIsIk5FV0xJTkVfQ09ERSIsImlzU291cmNlTm9kZSIsImFMaW5lIiwiYUNvbHVtbiIsImFDaHVua3MiLCJzb3VyY2VDb250ZW50cyIsImZyb21TdHJpbmdXaXRoU291cmNlTWFwIiwiU291cmNlTm9kZV9mcm9tU3RyaW5nV2l0aFNvdXJjZU1hcCIsImFHZW5lcmF0ZWRDb2RlIiwiYVJlbGF0aXZlUGF0aCIsInJlbWFpbmluZ0xpbmVzIiwicmVtYWluaW5nTGluZXNJbmRleCIsInNoaWZ0TmV4dExpbmUiLCJsaW5lQ29udGVudHMiLCJnZXROZXh0TGluZSIsIm5ld0xpbmUiLCJsYXN0R2VuZXJhdGVkTGluZSIsImxhc3RNYXBwaW5nIiwiYWRkTWFwcGluZ1dpdGhDb2RlIiwibmV4dExpbmUiLCJTb3VyY2VOb2RlX2FkZCIsImFDaHVuayIsInByZXBlbmQiLCJTb3VyY2VOb2RlX3ByZXBlbmQiLCJ3YWxrIiwiU291cmNlTm9kZV93YWxrIiwiYUZuIiwiU291cmNlTm9kZV9qb2luIiwiYVNlcCIsIm5ld0NoaWxkcmVuIiwicmVwbGFjZVJpZ2h0IiwiU291cmNlTm9kZV9yZXBsYWNlUmlnaHQiLCJhUGF0dGVybiIsImFSZXBsYWNlbWVudCIsImxhc3RDaGlsZCIsIlNvdXJjZU5vZGVfc2V0U291cmNlQ29udGVudCIsIndhbGtTb3VyY2VDb250ZW50cyIsIlNvdXJjZU5vZGVfd2Fsa1NvdXJjZUNvbnRlbnRzIiwiU291cmNlTm9kZV90b1N0cmluZyIsInRvU3RyaW5nV2l0aFNvdXJjZU1hcCIsIlNvdXJjZU5vZGVfdG9TdHJpbmdXaXRoU291cmNlTWFwIiwic291cmNlTWFwcGluZ0FjdGl2ZSIsImxhc3RPcmlnaW5hbFNvdXJjZSIsImxhc3RPcmlnaW5hbExpbmUiLCJsYXN0T3JpZ2luYWxDb2x1bW4iLCJsYXN0T3JpZ2luYWxOYW1lIiwic291cmNlQ29udGVudCIsInByb3h5TG9naW5DYWxsYmFjayIsInNraXBEaXJDcmVhdGlvbiIsIm5ldCIsImFkZFByb3h5TG9naW5IYW5kbGVyIiwiX0JpbnRyYXlQcm92aWRlciIsIl9sb2FkX0JpbnRyYXlQcm92aWRlciIsIl9HaXRIdWJQcm92aWRlciIsIl9sb2FkX0dpdEh1YlByb3ZpZGVyIiwiX1ByaXZhdGVHaXRIdWJQcm92aWRlciIsIl9sb2FkX1ByaXZhdGVHaXRIdWJQcm92aWRlciIsImdpdGh1Yk9wdGlvbnMiLCJwcml2YXRlIiwiR0hfVE9LRU4iLCJQcml2YXRlR2l0SHViUHJvdmlkZXIiLCJCaW50cmF5UHJvdmlkZXIiLCJfYmludHJheSIsIl9sb2FkX2JpbnRyYXkiLCJCaW50cmF5Q2xpZW50IiwiY2hhbm5lbEZpbGVuYW1lIiwiZ2V0VmVyc2lvbkZpbGVzIiwiYXBpS2V5IiwicGFja2FnZSIsInBhY2thZ2VOYW1lIiwidXNlciIsImNvbXBvbmVudCIsImRpc3RyaWJ1dGlvbiIsImJpbnRyYXlSZXF1ZXN0IiwiY3JlYXRlVmVyc2lvbiIsImRlbGV0ZVZlcnNpb24iLCJnZXRMYXRlc3RWZXJzaW9uSW5mbyIsImFzc2V0IiwiYXNzZXRzIiwiaHRtbF91cmwiLCJjb25maWd1cmVIZWFkZXJzIiwiYWNjZXB0IiwiX2NoaWxkX3Byb2Nlc3MiLCJfbG9hZF9jaGlsZF9wcm9jZXNzIiwiX0Jhc2VVcGRhdGVyIiwiX2xvYWRfQmFzZVVwZGF0ZXIiLCJfRmlsZVdpdGhFbWJlZGRlZEJsb2NrTWFwRGlmZmVyZW50aWFsRG93bmxvYWRlciIsIl9sb2FkX0ZpbGVXaXRoRW1iZWRkZWRCbG9ja01hcERpZmZlcmVudGlhbERvd25sb2FkZXIiLCJfR2VuZXJpY0RpZmZlcmVudGlhbERvd25sb2FkZXIiLCJfbG9hZF9HZW5lcmljRGlmZmVyZW50aWFsRG93bmxvYWRlciIsIl93aW5kb3dzRXhlY3V0YWJsZUNvZGVTaWduYXR1cmVWZXJpZmllciIsIl9sb2FkX3dpbmRvd3NFeGVjdXRhYmxlQ29kZVNpZ25hdHVyZVZlcmlmaWVyIiwicGFja2FnZVBhdGgiLCJnZXREb3dubG9hZGVkRmlsZSIsImRpZmZlcmVudGlhbERvd25sb2FkSW5zdGFsbGVyIiwic2lnbmF0dXJlVmVyaWZpY2F0aW9uU3RhdHVzIiwidmVyaWZ5U2lnbmF0dXJlIiwiZXh0bmFtZSIsImRpZmZlcmVudGlhbERvd25sb2FkV2ViUGFja2FnZSIsIl94MiIsIl94MyIsInNldERvd25sb2FkZWRGaWxlIiwidGVtcFVwZGF0ZUZpbGUiLCJwdWJsaXNoZXJOYW1lIiwic3Bhd25PcHRpb25zIiwiZGV0YWNoZWQiLCJzdGRpbyIsInVucmVmIiwiX19OU0lTX0RJRkZFUkVOVElBTF9VUERBVEVfXyIsImJsb2NrTWFwRGF0YSIsIkdlbmVyaWNEaWZmZXJlbnRpYWxEb3dubG9hZGVyIiwiX2xvZGFzaCIsIl9sb2FkX2xvZGFzaCIsInNldHVwUGF0aCIsIl9wYWNrYWdlUGF0aCIsIkxBUkdFX0FSUkFZX1NJWkUiLCJIQVNIX1VOREVGSU5FRCIsIkNPTVBBUkVfUEFSVElBTF9GTEFHIiwiQ09NUEFSRV9VTk9SREVSRURfRkxBRyIsImFyZ3NUYWciLCJhcnJheVRhZyIsImFzeW5jVGFnIiwiYm9vbFRhZyIsImRhdGVUYWciLCJlcnJvclRhZyIsImZ1bmNUYWciLCJnZW5UYWciLCJtYXBUYWciLCJudW1iZXJUYWciLCJudWxsVGFnIiwib2JqZWN0VGFnIiwicHJvbWlzZVRhZyIsInByb3h5VGFnIiwicmVnZXhwVGFnIiwic2V0VGFnIiwic3RyaW5nVGFnIiwic3ltYm9sVGFnIiwidW5kZWZpbmVkVGFnIiwid2Vha01hcFRhZyIsImFycmF5QnVmZmVyVGFnIiwiZGF0YVZpZXdUYWciLCJmbG9hdDMyVGFnIiwiZmxvYXQ2NFRhZyIsImludDhUYWciLCJpbnQxNlRhZyIsImludDMyVGFnIiwidWludDhUYWciLCJ1aW50OENsYW1wZWRUYWciLCJ1aW50MTZUYWciLCJ1aW50MzJUYWciLCJyZVJlZ0V4cENoYXIiLCJyZUlzSG9zdEN0b3IiLCJyZUlzVWludCIsInR5cGVkQXJyYXlUYWdzIiwiZnJlZUdsb2JhbCIsImZyZWVTZWxmIiwiZnJlZUV4cG9ydHMiLCJmcmVlTW9kdWxlIiwibW9kdWxlRXhwb3J0cyIsImZyZWVQcm9jZXNzIiwibm9kZVV0aWwiLCJiaW5kaW5nIiwibm9kZUlzVHlwZWRBcnJheSIsImlzVHlwZWRBcnJheSIsImFycmF5RmlsdGVyIiwicmVzSW5kZXgiLCJhcnJheVB1c2giLCJhcnJheVNvbWUiLCJiYXNlVGltZXMiLCJpdGVyYXRlZSIsImJhc2VVbmFyeSIsImZ1bmMiLCJjYWNoZUhhcyIsImdldFZhbHVlIiwibWFwVG9BcnJheSIsIm92ZXJBcmciLCJ0cmFuc2Zvcm0iLCJzZXRUb0FycmF5IiwiYXJyYXlQcm90byIsImZ1bmNQcm90byIsIm9iamVjdFByb3RvIiwiY29yZUpzRGF0YSIsImZ1bmNUb1N0cmluZyIsIm1hc2tTcmNLZXkiLCJJRV9QUk9UTyIsIm5hdGl2ZU9iamVjdFRvU3RyaW5nIiwicmVJc05hdGl2ZSIsIlVpbnQ4QXJyYXkiLCJwcm9wZXJ0eUlzRW51bWVyYWJsZSIsInN5bVRvU3RyaW5nVGFnIiwidG9TdHJpbmdUYWciLCJuYXRpdmVHZXRTeW1ib2xzIiwiZ2V0T3duUHJvcGVydHlTeW1ib2xzIiwibmF0aXZlSXNCdWZmZXIiLCJuYXRpdmVLZXlzIiwiRGF0YVZpZXciLCJnZXROYXRpdmUiLCJTZXQiLCJXZWFrTWFwIiwibmF0aXZlQ3JlYXRlIiwiZGF0YVZpZXdDdG9yU3RyaW5nIiwidG9Tb3VyY2UiLCJtYXBDdG9yU3RyaW5nIiwicHJvbWlzZUN0b3JTdHJpbmciLCJzZXRDdG9yU3RyaW5nIiwid2Vha01hcEN0b3JTdHJpbmciLCJzeW1ib2xQcm90byIsInN5bWJvbFZhbHVlT2YiLCJ2YWx1ZU9mIiwiSGFzaCIsImhhc2hDbGVhciIsIl9fZGF0YV9fIiwiaGFzaERlbGV0ZSIsImhhc2hHZXQiLCJoYXNoSGFzIiwiaGFzaFNldCIsIkxpc3RDYWNoZSIsImxpc3RDYWNoZUNsZWFyIiwibGlzdENhY2hlRGVsZXRlIiwiYXNzb2NJbmRleE9mIiwibGlzdENhY2hlR2V0IiwibGlzdENhY2hlSGFzIiwibGlzdENhY2hlU2V0IiwiTWFwQ2FjaGUiLCJtYXBDYWNoZUNsZWFyIiwibWFwQ2FjaGVEZWxldGUiLCJnZXRNYXBEYXRhIiwibWFwQ2FjaGVHZXQiLCJtYXBDYWNoZUhhcyIsIm1hcENhY2hlU2V0IiwiU2V0Q2FjaGUiLCJzZXRDYWNoZUFkZCIsInNldENhY2hlSGFzIiwiU3RhY2siLCJzdGFja0NsZWFyIiwic3RhY2tEZWxldGUiLCJzdGFja0dldCIsInN0YWNrSGFzIiwic3RhY2tTZXQiLCJwYWlycyIsImFycmF5TGlrZUtleXMiLCJpbmhlcml0ZWQiLCJpc0FyciIsImlzQXJnIiwiaXNBcmd1bWVudHMiLCJpc0J1ZmYiLCJpc1R5cGUiLCJza2lwSW5kZXhlcyIsImJhc2VHZXRBbGxLZXlzIiwia2V5c0Z1bmMiLCJzeW1ib2xzRnVuYyIsImJhc2VHZXRUYWciLCJnZXRSYXdUYWciLCJvYmplY3RUb1N0cmluZyIsImJhc2VJc0FyZ3VtZW50cyIsImlzT2JqZWN0TGlrZSIsImJhc2VJc0VxdWFsIiwiYml0bWFzayIsImN1c3RvbWl6ZXIiLCJiYXNlSXNFcXVhbERlZXAiLCJlcXVhbEZ1bmMiLCJvYmpJc0FyciIsIm90aElzQXJyIiwib2JqVGFnIiwiZ2V0VGFnIiwib3RoVGFnIiwib2JqSXNPYmoiLCJvdGhJc09iaiIsImlzU2FtZVRhZyIsImVxdWFsQXJyYXlzIiwiZXF1YWxCeVRhZyIsIm9iaklzV3JhcHBlZCIsIm90aElzV3JhcHBlZCIsIm9ialVud3JhcHBlZCIsIm90aFVud3JhcHBlZCIsImVxdWFsT2JqZWN0cyIsImJhc2VJc05hdGl2ZSIsImlzTWFza2VkIiwiYmFzZUlzVHlwZWRBcnJheSIsImlzTGVuZ3RoIiwiYmFzZUtleXMiLCJpc1Byb3RvdHlwZSIsImlzUGFydGlhbCIsImFyckxlbmd0aCIsIm90aExlbmd0aCIsInN0YWNrZWQiLCJzZWVuIiwiYXJyVmFsdWUiLCJvdGhWYWx1ZSIsImNvbXBhcmVkIiwib3RoSW5kZXgiLCJieXRlTGVuZ3RoIiwiYnl0ZU9mZnNldCIsImNvbnZlcnQiLCJvYmpQcm9wcyIsImdldEFsbEtleXMiLCJvYmpMZW5ndGgiLCJvdGhQcm9wcyIsInNraXBDdG9yIiwib2JqVmFsdWUiLCJvYmpDdG9yIiwib3RoQ3RvciIsImdldFN5bWJvbHMiLCJpc0tleWFibGUiLCJpc093biIsInVubWFza2VkIiwic3R1YkFycmF5IiwiQXJyYXlCdWZmZXIiLCJDdG9yIiwiY3RvclN0cmluZyIsImlzQXJyYXlMaWtlIiwic3R1YkZhbHNlIiwiaXNFcXVhbCIsIndlYnBhY2tQb2x5ZmlsbCIsImRlcHJlY2F0ZSIsInBhdGhzIiwiX2V4ZWN1dGVUYXNrcyIsImRpZmZlcmVudGlhbERvd25sb2FkZXIiLCJ0YXNrT2Zmc2V0IiwibmV4dE9mZnNldCIsInJhbmdlcyIsInBhcnRDb3VudCIsImRpY2VyIiwiYWNjZXB0UmFuZ2VzIiwicHVibGlzaGVyTmFtZXMiLCJleGVjRmlsZSIsImlzT2xkV2luNiIsImV4ZWNGaWxlU3luYyIsInRlc3RFcnJvciIsIlByaXZhdGVLZXkiLCJJc09TQmluYXJ5IiwiU2lnbmF0dXJlVHlwZSIsInNpZ25lckNlcnRpZmljYXRlIiwiU2lnbmVyQ2VydGlmaWNhdGUiLCJBcmNoaXZlZCIsIkV4dGVuc2lvbnMiLCJIYW5kbGUiLCJIYXNQcml2YXRlS2V5IiwiU3ViamVjdE5hbWUiLCJQYXRoIiwiU3RhdHVzIiwiU3ViamVjdCIsIndpblZlcnNpb24iLCJfaHR0cCIsIl9sb2FkX2h0dHAiLCJuYXRpdmVVcGRhdGVyIiwiYXV0b1VwZGF0ZXIiLCJ6aXBGaWxlSW5mbyIsInNlcnZlciIsImNyZWF0ZVNlcnZlciIsImdldFNlcnZlclVybCIsImFkZHJlc3MiLCJyZXF1ZXN0VXJsIiwid3JpdGVIZWFkIiwiZXJyb3JPY2N1cnJlZCIsImRvUHJveHlVcGRhdGVGaWxlIiwibGlzdGVuIiwibmF0aXZlUmVzcG9uc2UiLCJkb3dubG9hZFJlcXVlc3QiLCJkb3dubG9hZFJlc3BvbnNlIiwibmF0aXZlSGVhZGVycyIsImRvd25sb2FkTGlzdGVuZXJDb3VudCIsIkFQUElNQUdFIiwiaXNEb3dubG9hZEZ1bGwiLCJhcHBJbWFnZUZpbGUiLCJBUFBJTUFHRV9TSUxFTlRfSU5TVEFMTCIsIkFQUElNQUdFX0VYSVRfQUZURVJfSU5TVEFMTCIsImlwY1JlbmRlcmVyIiwidHJhbnNwb3J0Q29uc29sZSIsInRyYW5zcG9ydEZpbGUiLCJ0cmFuc3BvcnRMb2dTIiwidHJhbnNwb3J0UmVuZGVyZXJDb25zb2xlIiwidHJhbnNwb3J0cyIsImxvZ1MiLCJyZW5kZXJlckNvbnNvbGUiLCJpcGNNYWluIiwib25SZW5kZXJlckxvZyIsImFwcE5hbWUiLCJMRVZFTFMiLCJjb21wYXJlTGV2ZWxzIiwicGFzc0xldmVsIiwiY2hlY2tMZXZlbCIsInBhc3MiLCJjb25zb2xlVHJhbnNwb3J0IiwiZmluZExvZ1BhdGgiLCJtYXhTaXplIiwic3RyZWFtQ29uZmlnIiwiaW5pdFN0ZWFtQ29uZmlnIiwib3BlblN0cmVhbSIsIm5lZWRMb2dSb3RhdGlvbiIsImdldFN0cmVhbVNpemUiLCJhcmNoaXZlTG9nIiwibG9nQ29uc29sZSIsImxvZ1NpemVBdFN0YXJ0IiwiZ2V0QXBwTmFtZSIsImhvbWVEaXIiLCJob21lZGlyIiwicHJlcGFyZURpciIsImRpclBhdGgiLCJta0RpciIsIldfT0siLCJkaXJzIiwibG9hZFBhY2thZ2VOYW1lIiwicGFja2FnZUZpbGUiLCJlbGVjdHJvbk1vZHVsZSIsInBhY2thZ2VEYXRhIiwicHJvZHVjdE5hbWUiLCJodHRwIiwiaHR0cHMiLCJkZXB0aCIsImpzb25EZXB0aCIsInBvc3QiLCJzZXJ2ZXJVcmwiLCJ1cmxPYmplY3QiLCJuZXdKc29uIiwiQnJvd3NlcldpbmRvdyIsImdldEFsbFdpbmRvd3MiLCJ3bmQiLCJ3ZWJDb250ZW50cyJdLCJtYXBwaW5ncyI6IjtBQUFBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFLO0FBQ0w7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QWNDLGFBQWQsR0FBOEJ0N0gsT0FBOUIsQ0FBc0MsVUFBU3U3SCxHQUFULEVBQWM7QUFDbERBLFFBQUlDLFdBQUosQ0FBZ0JubEIsSUFBaEIsQ0FBcUIsMkJBQXJCLEVBQWtEaDJGLElBQUk1VixLQUF0RCxFQUE2RDZWLElBQTdEO0FBQ0QsR0FGRDtBQUdELEM7Ozs7OztBQ3ZCRCxrQkFBa0Isb09BQW9PLHk1Q0FBeTVDLFlBQVksa1BBQWtQLGlCQUFpQixzaUJBQXNpQixVQUFVLHdFQUF3RSxvQkFBb0IsUUFBUSw0Q0FBNEMsdUIiLCJmaWxlIjoibWFpbi5qcyIsInNvdXJjZXNDb250ZW50IjpbIiBcdC8vIFRoZSBtb2R1bGUgY2FjaGVcbiBcdHZhciBpbnN0YWxsZWRNb2R1bGVzID0ge307XG5cbiBcdC8vIFRoZSByZXF1aXJlIGZ1bmN0aW9uXG4gXHRmdW5jdGlvbiBfX3dlYnBhY2tfcmVxdWlyZV9fKG1vZHVsZUlkKSB7XG5cbiBcdFx0Ly8gQ2hlY2sgaWYgbW9kdWxlIGlzIGluIGNhY2hlXG4gXHRcdGlmKGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdKSB7XG4gXHRcdFx0cmV0dXJuIGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdLmV4cG9ydHM7XG4gXHRcdH1cbiBcdFx0Ly8gQ3JlYXRlIGEgbmV3IG1vZHVsZSAoYW5kIHB1dCBpdCBpbnRvIHRoZSBjYWNoZSlcbiBcdFx0dmFyIG1vZHVsZSA9IGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdID0ge1xuIFx0XHRcdGk6IG1vZHVsZUlkLFxuIFx0XHRcdGw6IGZhbHNlLFxuIFx0XHRcdGV4cG9ydHM6IHt9XG4gXHRcdH07XG5cbiBcdFx0Ly8gRXhlY3V0ZSB0aGUgbW9kdWxlIGZ1bmN0aW9uXG4gXHRcdG1vZHVsZXNbbW9kdWxlSWRdLmNhbGwobW9kdWxlLmV4cG9ydHMsIG1vZHVsZSwgbW9kdWxlLmV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pO1xuXG4gXHRcdC8vIEZsYWcgdGhlIG1vZHVsZSBhcyBsb2FkZWRcbiBcdFx0bW9kdWxlLmwgPSB0cnVlO1xuXG4gXHRcdC8vIFJldHVybiB0aGUgZXhwb3J0cyBvZiB0aGUgbW9kdWxlXG4gXHRcdHJldHVybiBtb2R1bGUuZXhwb3J0cztcbiBcdH1cblxuXG4gXHQvLyBleHBvc2UgdGhlIG1vZHVsZXMgb2JqZWN0IChfX3dlYnBhY2tfbW9kdWxlc19fKVxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5tID0gbW9kdWxlcztcblxuIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGUgY2FjaGVcbiBcdF9fd2VicGFja19yZXF1aXJlX18uYyA9IGluc3RhbGxlZE1vZHVsZXM7XG5cbiBcdC8vIGRlZmluZSBnZXR0ZXIgZnVuY3Rpb24gZm9yIGhhcm1vbnkgZXhwb3J0c1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5kID0gZnVuY3Rpb24oZXhwb3J0cywgbmFtZSwgZ2V0dGVyKSB7XG4gXHRcdGlmKCFfX3dlYnBhY2tfcmVxdWlyZV9fLm8oZXhwb3J0cywgbmFtZSkpIHtcbiBcdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgbmFtZSwge1xuIFx0XHRcdFx0Y29uZmlndXJhYmxlOiBmYWxzZSxcbiBcdFx0XHRcdGVudW1lcmFibGU6IHRydWUsXG4gXHRcdFx0XHRnZXQ6IGdldHRlclxuIFx0XHRcdH0pO1xuIFx0XHR9XG4gXHR9O1xuXG4gXHQvLyBnZXREZWZhdWx0RXhwb3J0IGZ1bmN0aW9uIGZvciBjb21wYXRpYmlsaXR5IHdpdGggbm9uLWhhcm1vbnkgbW9kdWxlc1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5uID0gZnVuY3Rpb24obW9kdWxlKSB7XG4gXHRcdHZhciBnZXR0ZXIgPSBtb2R1bGUgJiYgbW9kdWxlLl9fZXNNb2R1bGUgP1xuIFx0XHRcdGZ1bmN0aW9uIGdldERlZmF1bHQoKSB7IHJldHVybiBtb2R1bGVbJ2RlZmF1bHQnXTsgfSA6XG4gXHRcdFx0ZnVuY3Rpb24gZ2V0TW9kdWxlRXhwb3J0cygpIHsgcmV0dXJuIG1vZHVsZTsgfTtcbiBcdFx0X193ZWJwYWNrX3JlcXVpcmVfXy5kKGdldHRlciwgJ2EnLCBnZXR0ZXIpO1xuIFx0XHRyZXR1cm4gZ2V0dGVyO1xuIFx0fTtcblxuIFx0Ly8gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm8gPSBmdW5jdGlvbihvYmplY3QsIHByb3BlcnR5KSB7IHJldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBwcm9wZXJ0eSk7IH07XG5cbiBcdC8vIF9fd2VicGFja19wdWJsaWNfcGF0aF9fXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLnAgPSBcIlwiO1xuXG4gXHQvLyBMb2FkIGVudHJ5IG1vZHVsZSBhbmQgcmV0dXJuIGV4cG9ydHNcbiBcdHJldHVybiBfX3dlYnBhY2tfcmVxdWlyZV9fKF9fd2VicGFja19yZXF1aXJlX18ucyA9IDY5KTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyB3ZWJwYWNrL2Jvb3RzdHJhcCAwODM0MTZjZmM1MzBhZGY5NDgwNSIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcInBhdGhcIik7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gZXh0ZXJuYWwgXCJwYXRoXCJcbi8vIG1vZHVsZSBpZCA9IDBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgZXM1ID0gcmVxdWlyZShcIi4vZXM1XCIpO1xudmFyIGNhbkV2YWx1YXRlID0gdHlwZW9mIG5hdmlnYXRvciA9PSBcInVuZGVmaW5lZFwiO1xuXG52YXIgZXJyb3JPYmogPSB7ZToge319O1xudmFyIHRyeUNhdGNoVGFyZ2V0O1xudmFyIGdsb2JhbE9iamVjdCA9IHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiID8gc2VsZiA6XG4gICAgdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdyA6XG4gICAgdHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiA/IGdsb2JhbCA6XG4gICAgdGhpcyAhPT0gdW5kZWZpbmVkID8gdGhpcyA6IG51bGw7XG5cbmZ1bmN0aW9uIHRyeUNhdGNoZXIoKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgdmFyIHRhcmdldCA9IHRyeUNhdGNoVGFyZ2V0O1xuICAgICAgICB0cnlDYXRjaFRhcmdldCA9IG51bGw7XG4gICAgICAgIHJldHVybiB0YXJnZXQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGVycm9yT2JqLmUgPSBlO1xuICAgICAgICByZXR1cm4gZXJyb3JPYmo7XG4gICAgfVxufVxuZnVuY3Rpb24gdHJ5Q2F0Y2goZm4pIHtcbiAgICB0cnlDYXRjaFRhcmdldCA9IGZuO1xuICAgIHJldHVybiB0cnlDYXRjaGVyO1xufVxuXG52YXIgaW5oZXJpdHMgPSBmdW5jdGlvbihDaGlsZCwgUGFyZW50KSB7XG4gICAgdmFyIGhhc1Byb3AgPSB7fS5oYXNPd25Qcm9wZXJ0eTtcblxuICAgIGZ1bmN0aW9uIFQoKSB7XG4gICAgICAgIHRoaXMuY29uc3RydWN0b3IgPSBDaGlsZDtcbiAgICAgICAgdGhpcy5jb25zdHJ1Y3RvciQgPSBQYXJlbnQ7XG4gICAgICAgIGZvciAodmFyIHByb3BlcnR5TmFtZSBpbiBQYXJlbnQucHJvdG90eXBlKSB7XG4gICAgICAgICAgICBpZiAoaGFzUHJvcC5jYWxsKFBhcmVudC5wcm90b3R5cGUsIHByb3BlcnR5TmFtZSkgJiZcbiAgICAgICAgICAgICAgICBwcm9wZXJ0eU5hbWUuY2hhckF0KHByb3BlcnR5TmFtZS5sZW5ndGgtMSkgIT09IFwiJFwiXG4gICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgIHRoaXNbcHJvcGVydHlOYW1lICsgXCIkXCJdID0gUGFyZW50LnByb3RvdHlwZVtwcm9wZXJ0eU5hbWVdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIFQucHJvdG90eXBlID0gUGFyZW50LnByb3RvdHlwZTtcbiAgICBDaGlsZC5wcm90b3R5cGUgPSBuZXcgVCgpO1xuICAgIHJldHVybiBDaGlsZC5wcm90b3R5cGU7XG59O1xuXG5cbmZ1bmN0aW9uIGlzUHJpbWl0aXZlKHZhbCkge1xuICAgIHJldHVybiB2YWwgPT0gbnVsbCB8fCB2YWwgPT09IHRydWUgfHwgdmFsID09PSBmYWxzZSB8fFxuICAgICAgICB0eXBlb2YgdmFsID09PSBcInN0cmluZ1wiIHx8IHR5cGVvZiB2YWwgPT09IFwibnVtYmVyXCI7XG5cbn1cblxuZnVuY3Rpb24gaXNPYmplY3QodmFsdWUpIHtcbiAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSBcImZ1bmN0aW9uXCIgfHxcbiAgICAgICAgICAgdHlwZW9mIHZhbHVlID09PSBcIm9iamVjdFwiICYmIHZhbHVlICE9PSBudWxsO1xufVxuXG5mdW5jdGlvbiBtYXliZVdyYXBBc0Vycm9yKG1heWJlRXJyb3IpIHtcbiAgICBpZiAoIWlzUHJpbWl0aXZlKG1heWJlRXJyb3IpKSByZXR1cm4gbWF5YmVFcnJvcjtcblxuICAgIHJldHVybiBuZXcgRXJyb3Ioc2FmZVRvU3RyaW5nKG1heWJlRXJyb3IpKTtcbn1cblxuZnVuY3Rpb24gd2l0aEFwcGVuZGVkKHRhcmdldCwgYXBwZW5kZWUpIHtcbiAgICB2YXIgbGVuID0gdGFyZ2V0Lmxlbmd0aDtcbiAgICB2YXIgcmV0ID0gbmV3IEFycmF5KGxlbiArIDEpO1xuICAgIHZhciBpO1xuICAgIGZvciAoaSA9IDA7IGkgPCBsZW47ICsraSkge1xuICAgICAgICByZXRbaV0gPSB0YXJnZXRbaV07XG4gICAgfVxuICAgIHJldFtpXSA9IGFwcGVuZGVlO1xuICAgIHJldHVybiByZXQ7XG59XG5cbmZ1bmN0aW9uIGdldERhdGFQcm9wZXJ0eU9yRGVmYXVsdChvYmosIGtleSwgZGVmYXVsdFZhbHVlKSB7XG4gICAgaWYgKGVzNS5pc0VTNSkge1xuICAgICAgICB2YXIgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqLCBrZXkpO1xuXG4gICAgICAgIGlmIChkZXNjICE9IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBkZXNjLmdldCA9PSBudWxsICYmIGRlc2Muc2V0ID09IG51bGxcbiAgICAgICAgICAgICAgICAgICAgPyBkZXNjLnZhbHVlXG4gICAgICAgICAgICAgICAgICAgIDogZGVmYXVsdFZhbHVlO1xuICAgICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHt9Lmhhc093blByb3BlcnR5LmNhbGwob2JqLCBrZXkpID8gb2JqW2tleV0gOiB1bmRlZmluZWQ7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBub3RFbnVtZXJhYmxlUHJvcChvYmosIG5hbWUsIHZhbHVlKSB7XG4gICAgaWYgKGlzUHJpbWl0aXZlKG9iaikpIHJldHVybiBvYmo7XG4gICAgdmFyIGRlc2NyaXB0b3IgPSB7XG4gICAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgd3JpdGFibGU6IHRydWVcbiAgICB9O1xuICAgIGVzNS5kZWZpbmVQcm9wZXJ0eShvYmosIG5hbWUsIGRlc2NyaXB0b3IpO1xuICAgIHJldHVybiBvYmo7XG59XG5cbmZ1bmN0aW9uIHRocm93ZXIocikge1xuICAgIHRocm93IHI7XG59XG5cbnZhciBpbmhlcml0ZWREYXRhS2V5cyA9IChmdW5jdGlvbigpIHtcbiAgICB2YXIgZXhjbHVkZWRQcm90b3R5cGVzID0gW1xuICAgICAgICBBcnJheS5wcm90b3R5cGUsXG4gICAgICAgIE9iamVjdC5wcm90b3R5cGUsXG4gICAgICAgIEZ1bmN0aW9uLnByb3RvdHlwZVxuICAgIF07XG5cbiAgICB2YXIgaXNFeGNsdWRlZFByb3RvID0gZnVuY3Rpb24odmFsKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZXhjbHVkZWRQcm90b3R5cGVzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICBpZiAoZXhjbHVkZWRQcm90b3R5cGVzW2ldID09PSB2YWwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfTtcblxuICAgIGlmIChlczUuaXNFUzUpIHtcbiAgICAgICAgdmFyIGdldEtleXMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcztcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKG9iaikge1xuICAgICAgICAgICAgdmFyIHJldCA9IFtdO1xuICAgICAgICAgICAgdmFyIHZpc2l0ZWRLZXlzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgICAgICAgIHdoaWxlIChvYmogIT0gbnVsbCAmJiAhaXNFeGNsdWRlZFByb3RvKG9iaikpIHtcbiAgICAgICAgICAgICAgICB2YXIga2V5cztcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBrZXlzID0gZ2V0S2V5cyhvYmopO1xuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJldDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBrZXkgPSBrZXlzW2ldO1xuICAgICAgICAgICAgICAgICAgICBpZiAodmlzaXRlZEtleXNba2V5XSkgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgIHZpc2l0ZWRLZXlzW2tleV0gPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB2YXIgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqLCBrZXkpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZGVzYyAhPSBudWxsICYmIGRlc2MuZ2V0ID09IG51bGwgJiYgZGVzYy5zZXQgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0LnB1c2goa2V5KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBvYmogPSBlczUuZ2V0UHJvdG90eXBlT2Yob2JqKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXQ7XG4gICAgICAgIH07XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIGhhc1Byb3AgPSB7fS5oYXNPd25Qcm9wZXJ0eTtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKG9iaikge1xuICAgICAgICAgICAgaWYgKGlzRXhjbHVkZWRQcm90byhvYmopKSByZXR1cm4gW107XG4gICAgICAgICAgICB2YXIgcmV0ID0gW107XG5cbiAgICAgICAgICAgIC8qanNoaW50IGZvcmluOmZhbHNlICovXG4gICAgICAgICAgICBlbnVtZXJhdGlvbjogZm9yICh2YXIga2V5IGluIG9iaikge1xuICAgICAgICAgICAgICAgIGlmIChoYXNQcm9wLmNhbGwob2JqLCBrZXkpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldC5wdXNoKGtleSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBleGNsdWRlZFByb3RvdHlwZXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChoYXNQcm9wLmNhbGwoZXhjbHVkZWRQcm90b3R5cGVzW2ldLCBrZXkpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWUgZW51bWVyYXRpb247XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0LnB1c2goa2V5KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmV0O1xuICAgICAgICB9O1xuICAgIH1cblxufSkoKTtcblxudmFyIHRoaXNBc3NpZ25tZW50UGF0dGVybiA9IC90aGlzXFxzKlxcLlxccypcXFMrXFxzKj0vO1xuZnVuY3Rpb24gaXNDbGFzcyhmbikge1xuICAgIHRyeSB7XG4gICAgICAgIGlmICh0eXBlb2YgZm4gPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgdmFyIGtleXMgPSBlczUubmFtZXMoZm4ucHJvdG90eXBlKTtcblxuICAgICAgICAgICAgdmFyIGhhc01ldGhvZHMgPSBlczUuaXNFUzUgJiYga2V5cy5sZW5ndGggPiAxO1xuICAgICAgICAgICAgdmFyIGhhc01ldGhvZHNPdGhlclRoYW5Db25zdHJ1Y3RvciA9IGtleXMubGVuZ3RoID4gMCAmJlxuICAgICAgICAgICAgICAgICEoa2V5cy5sZW5ndGggPT09IDEgJiYga2V5c1swXSA9PT0gXCJjb25zdHJ1Y3RvclwiKTtcbiAgICAgICAgICAgIHZhciBoYXNUaGlzQXNzaWdubWVudEFuZFN0YXRpY01ldGhvZHMgPVxuICAgICAgICAgICAgICAgIHRoaXNBc3NpZ25tZW50UGF0dGVybi50ZXN0KGZuICsgXCJcIikgJiYgZXM1Lm5hbWVzKGZuKS5sZW5ndGggPiAwO1xuXG4gICAgICAgICAgICBpZiAoaGFzTWV0aG9kcyB8fCBoYXNNZXRob2RzT3RoZXJUaGFuQ29uc3RydWN0b3IgfHxcbiAgICAgICAgICAgICAgICBoYXNUaGlzQXNzaWdubWVudEFuZFN0YXRpY01ldGhvZHMpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxufVxuXG5mdW5jdGlvbiB0b0Zhc3RQcm9wZXJ0aWVzKG9iaikge1xuICAgIC8qanNoaW50IC1XMDI3LC1XMDU1LC1XMDMxKi9cbiAgICBmdW5jdGlvbiBGYWtlQ29uc3RydWN0b3IoKSB7fVxuICAgIEZha2VDb25zdHJ1Y3Rvci5wcm90b3R5cGUgPSBvYmo7XG4gICAgdmFyIGwgPSA4O1xuICAgIHdoaWxlIChsLS0pIG5ldyBGYWtlQ29uc3RydWN0b3IoKTtcbiAgICByZXR1cm4gb2JqO1xuICAgIGV2YWwob2JqKTtcbn1cblxudmFyIHJpZGVudCA9IC9eW2EteiRfXVthLXokXzAtOV0qJC9pO1xuZnVuY3Rpb24gaXNJZGVudGlmaWVyKHN0cikge1xuICAgIHJldHVybiByaWRlbnQudGVzdChzdHIpO1xufVxuXG5mdW5jdGlvbiBmaWxsZWRSYW5nZShjb3VudCwgcHJlZml4LCBzdWZmaXgpIHtcbiAgICB2YXIgcmV0ID0gbmV3IEFycmF5KGNvdW50KTtcbiAgICBmb3IodmFyIGkgPSAwOyBpIDwgY291bnQ7ICsraSkge1xuICAgICAgICByZXRbaV0gPSBwcmVmaXggKyBpICsgc3VmZml4O1xuICAgIH1cbiAgICByZXR1cm4gcmV0O1xufVxuXG5mdW5jdGlvbiBzYWZlVG9TdHJpbmcob2JqKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIG9iaiArIFwiXCI7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgICByZXR1cm4gXCJbbm8gc3RyaW5nIHJlcHJlc2VudGF0aW9uXVwiO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gaXNFcnJvcihvYmopIHtcbiAgICByZXR1cm4gb2JqIGluc3RhbmNlb2YgRXJyb3IgfHxcbiAgICAgICAgKG9iaiAhPT0gbnVsbCAmJlxuICAgICAgICAgICB0eXBlb2Ygb2JqID09PSBcIm9iamVjdFwiICYmXG4gICAgICAgICAgIHR5cGVvZiBvYmoubWVzc2FnZSA9PT0gXCJzdHJpbmdcIiAmJlxuICAgICAgICAgICB0eXBlb2Ygb2JqLm5hbWUgPT09IFwic3RyaW5nXCIpO1xufVxuXG5mdW5jdGlvbiBtYXJrQXNPcmlnaW5hdGluZ0Zyb21SZWplY3Rpb24oZSkge1xuICAgIHRyeSB7XG4gICAgICAgIG5vdEVudW1lcmFibGVQcm9wKGUsIFwiaXNPcGVyYXRpb25hbFwiLCB0cnVlKTtcbiAgICB9XG4gICAgY2F0Y2goaWdub3JlKSB7fVxufVxuXG5mdW5jdGlvbiBvcmlnaW5hdGVzRnJvbVJlamVjdGlvbihlKSB7XG4gICAgaWYgKGUgPT0gbnVsbCkgcmV0dXJuIGZhbHNlO1xuICAgIHJldHVybiAoKGUgaW5zdGFuY2VvZiBFcnJvcltcIl9fQmx1ZWJpcmRFcnJvclR5cGVzX19cIl0uT3BlcmF0aW9uYWxFcnJvcikgfHxcbiAgICAgICAgZVtcImlzT3BlcmF0aW9uYWxcIl0gPT09IHRydWUpO1xufVxuXG5mdW5jdGlvbiBjYW5BdHRhY2hUcmFjZShvYmopIHtcbiAgICByZXR1cm4gaXNFcnJvcihvYmopICYmIGVzNS5wcm9wZXJ0eUlzV3JpdGFibGUob2JqLCBcInN0YWNrXCIpO1xufVxuXG52YXIgZW5zdXJlRXJyb3JPYmplY3QgPSAoZnVuY3Rpb24oKSB7XG4gICAgaWYgKCEoXCJzdGFja1wiIGluIG5ldyBFcnJvcigpKSkge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgICAgIGlmIChjYW5BdHRhY2hUcmFjZSh2YWx1ZSkpIHJldHVybiB2YWx1ZTtcbiAgICAgICAgICAgIHRyeSB7dGhyb3cgbmV3IEVycm9yKHNhZmVUb1N0cmluZyh2YWx1ZSkpO31cbiAgICAgICAgICAgIGNhdGNoKGVycikge3JldHVybiBlcnI7fVxuICAgICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICAgICAgaWYgKGNhbkF0dGFjaFRyYWNlKHZhbHVlKSkgcmV0dXJuIHZhbHVlO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBFcnJvcihzYWZlVG9TdHJpbmcodmFsdWUpKTtcbiAgICAgICAgfTtcbiAgICB9XG59KSgpO1xuXG5mdW5jdGlvbiBjbGFzc1N0cmluZyhvYmopIHtcbiAgICByZXR1cm4ge30udG9TdHJpbmcuY2FsbChvYmopO1xufVxuXG5mdW5jdGlvbiBjb3B5RGVzY3JpcHRvcnMoZnJvbSwgdG8sIGZpbHRlcikge1xuICAgIHZhciBrZXlzID0gZXM1Lm5hbWVzKGZyb20pO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7ICsraSkge1xuICAgICAgICB2YXIga2V5ID0ga2V5c1tpXTtcbiAgICAgICAgaWYgKGZpbHRlcihrZXkpKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGVzNS5kZWZpbmVQcm9wZXJ0eSh0bywga2V5LCBlczUuZ2V0RGVzY3JpcHRvcihmcm9tLCBrZXkpKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGlnbm9yZSkge31cbiAgICAgICAgfVxuICAgIH1cbn1cblxudmFyIGFzQXJyYXkgPSBmdW5jdGlvbih2KSB7XG4gICAgaWYgKGVzNS5pc0FycmF5KHYpKSB7XG4gICAgICAgIHJldHVybiB2O1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbn07XG5cbmlmICh0eXBlb2YgU3ltYm9sICE9PSBcInVuZGVmaW5lZFwiICYmIFN5bWJvbC5pdGVyYXRvcikge1xuICAgIHZhciBBcnJheUZyb20gPSB0eXBlb2YgQXJyYXkuZnJvbSA9PT0gXCJmdW5jdGlvblwiID8gZnVuY3Rpb24odikge1xuICAgICAgICByZXR1cm4gQXJyYXkuZnJvbSh2KTtcbiAgICB9IDogZnVuY3Rpb24odikge1xuICAgICAgICB2YXIgcmV0ID0gW107XG4gICAgICAgIHZhciBpdCA9IHZbU3ltYm9sLml0ZXJhdG9yXSgpO1xuICAgICAgICB2YXIgaXRSZXN1bHQ7XG4gICAgICAgIHdoaWxlICghKChpdFJlc3VsdCA9IGl0Lm5leHQoKSkuZG9uZSkpIHtcbiAgICAgICAgICAgIHJldC5wdXNoKGl0UmVzdWx0LnZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmV0O1xuICAgIH07XG5cbiAgICBhc0FycmF5ID0gZnVuY3Rpb24odikge1xuICAgICAgICBpZiAoZXM1LmlzQXJyYXkodikpIHtcbiAgICAgICAgICAgIHJldHVybiB2O1xuICAgICAgICB9IGVsc2UgaWYgKHYgIT0gbnVsbCAmJiB0eXBlb2YgdltTeW1ib2wuaXRlcmF0b3JdID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgIHJldHVybiBBcnJheUZyb20odik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfTtcbn1cblxudmFyIGlzTm9kZSA9IHR5cGVvZiBwcm9jZXNzICE9PSBcInVuZGVmaW5lZFwiICYmXG4gICAgICAgIGNsYXNzU3RyaW5nKHByb2Nlc3MpLnRvTG93ZXJDYXNlKCkgPT09IFwiW29iamVjdCBwcm9jZXNzXVwiO1xuXG52YXIgaGFzRW52VmFyaWFibGVzID0gdHlwZW9mIHByb2Nlc3MgIT09IFwidW5kZWZpbmVkXCIgJiZcbiAgICB0eXBlb2YgcHJvY2Vzcy5lbnYgIT09IFwidW5kZWZpbmVkXCI7XG5cbmZ1bmN0aW9uIGVudihrZXkpIHtcbiAgICByZXR1cm4gaGFzRW52VmFyaWFibGVzID8gcHJvY2Vzcy5lbnZba2V5XSA6IHVuZGVmaW5lZDtcbn1cblxuZnVuY3Rpb24gZ2V0TmF0aXZlUHJvbWlzZSgpIHtcbiAgICBpZiAodHlwZW9mIFByb21pc2UgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgdmFyIHByb21pc2UgPSBuZXcgUHJvbWlzZShmdW5jdGlvbigpe30pO1xuICAgICAgICAgICAgaWYgKHt9LnRvU3RyaW5nLmNhbGwocHJvbWlzZSkgPT09IFwiW29iamVjdCBQcm9taXNlXVwiKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gY2F0Y2ggKGUpIHt9XG4gICAgfVxufVxuXG5mdW5jdGlvbiBkb21haW5CaW5kKHNlbGYsIGNiKSB7XG4gICAgcmV0dXJuIHNlbGYuYmluZChjYik7XG59XG5cbnZhciByZXQgPSB7XG4gICAgaXNDbGFzczogaXNDbGFzcyxcbiAgICBpc0lkZW50aWZpZXI6IGlzSWRlbnRpZmllcixcbiAgICBpbmhlcml0ZWREYXRhS2V5czogaW5oZXJpdGVkRGF0YUtleXMsXG4gICAgZ2V0RGF0YVByb3BlcnR5T3JEZWZhdWx0OiBnZXREYXRhUHJvcGVydHlPckRlZmF1bHQsXG4gICAgdGhyb3dlcjogdGhyb3dlcixcbiAgICBpc0FycmF5OiBlczUuaXNBcnJheSxcbiAgICBhc0FycmF5OiBhc0FycmF5LFxuICAgIG5vdEVudW1lcmFibGVQcm9wOiBub3RFbnVtZXJhYmxlUHJvcCxcbiAgICBpc1ByaW1pdGl2ZTogaXNQcmltaXRpdmUsXG4gICAgaXNPYmplY3Q6IGlzT2JqZWN0LFxuICAgIGlzRXJyb3I6IGlzRXJyb3IsXG4gICAgY2FuRXZhbHVhdGU6IGNhbkV2YWx1YXRlLFxuICAgIGVycm9yT2JqOiBlcnJvck9iaixcbiAgICB0cnlDYXRjaDogdHJ5Q2F0Y2gsXG4gICAgaW5oZXJpdHM6IGluaGVyaXRzLFxuICAgIHdpdGhBcHBlbmRlZDogd2l0aEFwcGVuZGVkLFxuICAgIG1heWJlV3JhcEFzRXJyb3I6IG1heWJlV3JhcEFzRXJyb3IsXG4gICAgdG9GYXN0UHJvcGVydGllczogdG9GYXN0UHJvcGVydGllcyxcbiAgICBmaWxsZWRSYW5nZTogZmlsbGVkUmFuZ2UsXG4gICAgdG9TdHJpbmc6IHNhZmVUb1N0cmluZyxcbiAgICBjYW5BdHRhY2hUcmFjZTogY2FuQXR0YWNoVHJhY2UsXG4gICAgZW5zdXJlRXJyb3JPYmplY3Q6IGVuc3VyZUVycm9yT2JqZWN0LFxuICAgIG9yaWdpbmF0ZXNGcm9tUmVqZWN0aW9uOiBvcmlnaW5hdGVzRnJvbVJlamVjdGlvbixcbiAgICBtYXJrQXNPcmlnaW5hdGluZ0Zyb21SZWplY3Rpb246IG1hcmtBc09yaWdpbmF0aW5nRnJvbVJlamVjdGlvbixcbiAgICBjbGFzc1N0cmluZzogY2xhc3NTdHJpbmcsXG4gICAgY29weURlc2NyaXB0b3JzOiBjb3B5RGVzY3JpcHRvcnMsXG4gICAgaGFzRGV2VG9vbHM6IHR5cGVvZiBjaHJvbWUgIT09IFwidW5kZWZpbmVkXCIgJiYgY2hyb21lICYmXG4gICAgICAgICAgICAgICAgIHR5cGVvZiBjaHJvbWUubG9hZFRpbWVzID09PSBcImZ1bmN0aW9uXCIsXG4gICAgaXNOb2RlOiBpc05vZGUsXG4gICAgaGFzRW52VmFyaWFibGVzOiBoYXNFbnZWYXJpYWJsZXMsXG4gICAgZW52OiBlbnYsXG4gICAgZ2xvYmFsOiBnbG9iYWxPYmplY3QsXG4gICAgZ2V0TmF0aXZlUHJvbWlzZTogZ2V0TmF0aXZlUHJvbWlzZSxcbiAgICBkb21haW5CaW5kOiBkb21haW5CaW5kXG59O1xucmV0LmlzUmVjZW50Tm9kZSA9IHJldC5pc05vZGUgJiYgKGZ1bmN0aW9uKCkge1xuICAgIHZhciB2ZXJzaW9uID0gcHJvY2Vzcy52ZXJzaW9ucy5ub2RlLnNwbGl0KFwiLlwiKS5tYXAoTnVtYmVyKTtcbiAgICByZXR1cm4gKHZlcnNpb25bMF0gPT09IDAgJiYgdmVyc2lvblsxXSA+IDEwKSB8fCAodmVyc2lvblswXSA+IDApO1xufSkoKTtcblxuaWYgKHJldC5pc05vZGUpIHJldC50b0Zhc3RQcm9wZXJ0aWVzKHByb2Nlc3MpO1xuXG50cnkge3Rocm93IG5ldyBFcnJvcigpOyB9IGNhdGNoIChlKSB7cmV0Lmxhc3RMaW5lRXJyb3IgPSBlO31cbm1vZHVsZS5leHBvcnRzID0gcmV0O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2JsdWViaXJkL2pzL3JlbGVhc2UvdXRpbC5qcyIsImNvbnN0IEJsdWViaXJkUHJvbWlzZSA9IHJlcXVpcmUoXCJibHVlYmlyZC9qcy9yZWxlYXNlL3Byb21pc2VcIikoKVxuQmx1ZWJpcmRQcm9taXNlLmNvbmZpZyh7XG4gIGxvbmdTdGFja1RyYWNlczogdHJ1ZSxcbn0pXG5CbHVlYmlyZFByb21pc2UuZGVmYXVsdCA9IEJsdWViaXJkUHJvbWlzZVxubW9kdWxlLmV4cG9ydHMgPSBCbHVlYmlyZFByb21pc2VcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvYmx1ZWJpcmQtbHN0L2luZGV4LmpzIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgIHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF9DYW5jZWxsYXRpb25Ub2tlbjtcblxuZnVuY3Rpb24gX2xvYWRfQ2FuY2VsbGF0aW9uVG9rZW4oKSB7XG4gICAgcmV0dXJuIF9DYW5jZWxsYXRpb25Ub2tlbiA9IHJlcXVpcmUoXCIuL0NhbmNlbGxhdGlvblRva2VuXCIpO1xufVxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJDYW5jZWxsYXRpb25Ub2tlblwiLCB7XG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIChfQ2FuY2VsbGF0aW9uVG9rZW4gfHwgX2xvYWRfQ2FuY2VsbGF0aW9uVG9rZW4oKSkuQ2FuY2VsbGF0aW9uVG9rZW47XG4gICAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJDYW5jZWxsYXRpb25FcnJvclwiLCB7XG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIChfQ2FuY2VsbGF0aW9uVG9rZW4gfHwgX2xvYWRfQ2FuY2VsbGF0aW9uVG9rZW4oKSkuQ2FuY2VsbGF0aW9uRXJyb3I7XG4gICAgfVxufSk7XG5cbnZhciBfaHR0cEV4ZWN1dG9yO1xuXG5mdW5jdGlvbiBfbG9hZF9odHRwRXhlY3V0b3IoKSB7XG4gICAgcmV0dXJuIF9odHRwRXhlY3V0b3IgPSByZXF1aXJlKFwiLi9odHRwRXhlY3V0b3JcIik7XG59XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkh0dHBFcnJvclwiLCB7XG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIChfaHR0cEV4ZWN1dG9yIHx8IF9sb2FkX2h0dHBFeGVjdXRvcigpKS5IdHRwRXJyb3I7XG4gICAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJjcmVhdGVIdHRwRXJyb3JcIiwge1xuICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiAoX2h0dHBFeGVjdXRvciB8fCBfbG9hZF9odHRwRXhlY3V0b3IoKSkuY3JlYXRlSHR0cEVycm9yO1xuICAgIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiSHR0cEV4ZWN1dG9yXCIsIHtcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gKF9odHRwRXhlY3V0b3IgfHwgX2xvYWRfaHR0cEV4ZWN1dG9yKCkpLkh0dHBFeGVjdXRvcjtcbiAgICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkRpZ2VzdFRyYW5zZm9ybVwiLCB7XG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIChfaHR0cEV4ZWN1dG9yIHx8IF9sb2FkX2h0dHBFeGVjdXRvcigpKS5EaWdlc3RUcmFuc2Zvcm07XG4gICAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJzYWZlR2V0SGVhZGVyXCIsIHtcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gKF9odHRwRXhlY3V0b3IgfHwgX2xvYWRfaHR0cEV4ZWN1dG9yKCkpLnNhZmVHZXRIZWFkZXI7XG4gICAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJjb25maWd1cmVSZXF1ZXN0T3B0aW9uc1wiLCB7XG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIChfaHR0cEV4ZWN1dG9yIHx8IF9sb2FkX2h0dHBFeGVjdXRvcigpKS5jb25maWd1cmVSZXF1ZXN0T3B0aW9ucztcbiAgICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImNvbmZpZ3VyZVJlcXVlc3RPcHRpb25zRnJvbVVybFwiLCB7XG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIChfaHR0cEV4ZWN1dG9yIHx8IF9sb2FkX2h0dHBFeGVjdXRvcigpKS5jb25maWd1cmVSZXF1ZXN0T3B0aW9uc0Zyb21Vcmw7XG4gICAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJzYWZlU3RyaW5naWZ5SnNvblwiLCB7XG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIChfaHR0cEV4ZWN1dG9yIHx8IF9sb2FkX2h0dHBFeGVjdXRvcigpKS5zYWZlU3RyaW5naWZ5SnNvbjtcbiAgICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcInBhcnNlSnNvblwiLCB7XG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIChfaHR0cEV4ZWN1dG9yIHx8IF9sb2FkX2h0dHBFeGVjdXRvcigpKS5wYXJzZUpzb247XG4gICAgfVxufSk7XG5cbnZhciBfcHVibGlzaE9wdGlvbnM7XG5cbmZ1bmN0aW9uIF9sb2FkX3B1Ymxpc2hPcHRpb25zKCkge1xuICAgIHJldHVybiBfcHVibGlzaE9wdGlvbnMgPSByZXF1aXJlKFwiLi9wdWJsaXNoT3B0aW9uc1wiKTtcbn1cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiZ2V0UzNMaWtlUHJvdmlkZXJCYXNlVXJsXCIsIHtcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gKF9wdWJsaXNoT3B0aW9ucyB8fCBfbG9hZF9wdWJsaXNoT3B0aW9ucygpKS5nZXRTM0xpa2VQcm92aWRlckJhc2VVcmw7XG4gICAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJnaXRodWJVcmxcIiwge1xuICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiAoX3B1Ymxpc2hPcHRpb25zIHx8IF9sb2FkX3B1Ymxpc2hPcHRpb25zKCkpLmdpdGh1YlVybDtcbiAgICB9XG59KTtcblxudmFyIF9yZmMyMjUzUGFyc2VyO1xuXG5mdW5jdGlvbiBfbG9hZF9yZmMyMjUzUGFyc2VyKCkge1xuICAgIHJldHVybiBfcmZjMjI1M1BhcnNlciA9IHJlcXVpcmUoXCIuL3JmYzIyNTNQYXJzZXJcIik7XG59XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcInBhcnNlRG5cIiwge1xuICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiAoX3JmYzIyNTNQYXJzZXIgfHwgX2xvYWRfcmZjMjI1M1BhcnNlcigpKS5wYXJzZURuO1xuICAgIH1cbn0pO1xuXG52YXIgX3V1aWQ7XG5cbmZ1bmN0aW9uIF9sb2FkX3V1aWQoKSB7XG4gICAgcmV0dXJuIF91dWlkID0gcmVxdWlyZShcIi4vdXVpZFwiKTtcbn1cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiVVVJRFwiLCB7XG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIChfdXVpZCB8fCBfbG9hZF91dWlkKCkpLlVVSUQ7XG4gICAgfVxufSk7XG5cbnZhciBfUHJvZ3Jlc3NDYWxsYmFja1RyYW5zZm9ybTtcblxuZnVuY3Rpb24gX2xvYWRfUHJvZ3Jlc3NDYWxsYmFja1RyYW5zZm9ybSgpIHtcbiAgICByZXR1cm4gX1Byb2dyZXNzQ2FsbGJhY2tUcmFuc2Zvcm0gPSByZXF1aXJlKFwiLi9Qcm9ncmVzc0NhbGxiYWNrVHJhbnNmb3JtXCIpO1xufVxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJQcm9ncmVzc0NhbGxiYWNrVHJhbnNmb3JtXCIsIHtcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gKF9Qcm9ncmVzc0NhbGxiYWNrVHJhbnNmb3JtIHx8IF9sb2FkX1Byb2dyZXNzQ2FsbGJhY2tUcmFuc2Zvcm0oKSkuUHJvZ3Jlc3NDYWxsYmFja1RyYW5zZm9ybTtcbiAgICB9XG59KTtcblxudmFyIF94bWw7XG5cbmZ1bmN0aW9uIF9sb2FkX3htbCgpIHtcbiAgICByZXR1cm4gX3htbCA9IHJlcXVpcmUoXCIuL3htbFwiKTtcbn1cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwicGFyc2VYbWxcIiwge1xuICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiAoX3htbCB8fCBfbG9hZF94bWwoKSkucGFyc2VYbWw7XG4gICAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJYRWxlbWVudFwiLCB7XG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIChfeG1sIHx8IF9sb2FkX3htbCgpKS5YRWxlbWVudDtcbiAgICB9XG59KTtcbmV4cG9ydHMuYXNBcnJheSA9IGFzQXJyYXk7XG5leHBvcnRzLm5ld0Vycm9yID0gbmV3RXJyb3I7XG5mdW5jdGlvbiBhc0FycmF5KHYpIHtcbiAgICBpZiAodiA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkodikpIHtcbiAgICAgICAgcmV0dXJuIHY7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIFt2XTtcbiAgICB9XG59XG5mdW5jdGlvbiBuZXdFcnJvcihtZXNzYWdlLCBjb2RlKSB7XG4gICAgY29uc3QgZXJyb3IgPSBuZXcgRXJyb3IobWVzc2FnZSk7XG4gICAgZXJyb3IuY29kZSA9IGNvZGU7XG4gICAgcmV0dXJuIGVycm9yO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2VsZWN0cm9uLXVwZGF0ZXIvbm9kZV9tb2R1bGVzL2J1aWxkZXItdXRpbC1ydW50aW1lL291dC9pbmRleC5qcyIsIid1c2Ugc3RyaWN0JztcblxudmFyIFlBTUxFeGNlcHRpb24gPSByZXF1aXJlKCcuL2V4Y2VwdGlvbicpO1xuXG52YXIgVFlQRV9DT05TVFJVQ1RPUl9PUFRJT05TID0gW1xuICAna2luZCcsXG4gICdyZXNvbHZlJyxcbiAgJ2NvbnN0cnVjdCcsXG4gICdpbnN0YW5jZU9mJyxcbiAgJ3ByZWRpY2F0ZScsXG4gICdyZXByZXNlbnQnLFxuICAnZGVmYXVsdFN0eWxlJyxcbiAgJ3N0eWxlQWxpYXNlcydcbl07XG5cbnZhciBZQU1MX05PREVfS0lORFMgPSBbXG4gICdzY2FsYXInLFxuICAnc2VxdWVuY2UnLFxuICAnbWFwcGluZydcbl07XG5cbmZ1bmN0aW9uIGNvbXBpbGVTdHlsZUFsaWFzZXMobWFwKSB7XG4gIHZhciByZXN1bHQgPSB7fTtcblxuICBpZiAobWFwICE9PSBudWxsKSB7XG4gICAgT2JqZWN0LmtleXMobWFwKS5mb3JFYWNoKGZ1bmN0aW9uIChzdHlsZSkge1xuICAgICAgbWFwW3N0eWxlXS5mb3JFYWNoKGZ1bmN0aW9uIChhbGlhcykge1xuICAgICAgICByZXN1bHRbU3RyaW5nKGFsaWFzKV0gPSBzdHlsZTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuZnVuY3Rpb24gVHlwZSh0YWcsIG9wdGlvbnMpIHtcbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgT2JqZWN0LmtleXMob3B0aW9ucykuZm9yRWFjaChmdW5jdGlvbiAobmFtZSkge1xuICAgIGlmIChUWVBFX0NPTlNUUlVDVE9SX09QVElPTlMuaW5kZXhPZihuYW1lKSA9PT0gLTEpIHtcbiAgICAgIHRocm93IG5ldyBZQU1MRXhjZXB0aW9uKCdVbmtub3duIG9wdGlvbiBcIicgKyBuYW1lICsgJ1wiIGlzIG1ldCBpbiBkZWZpbml0aW9uIG9mIFwiJyArIHRhZyArICdcIiBZQU1MIHR5cGUuJyk7XG4gICAgfVxuICB9KTtcblxuICAvLyBUT0RPOiBBZGQgdGFnIGZvcm1hdCBjaGVjay5cbiAgdGhpcy50YWcgICAgICAgICAgPSB0YWc7XG4gIHRoaXMua2luZCAgICAgICAgID0gb3B0aW9uc1sna2luZCddICAgICAgICAgfHwgbnVsbDtcbiAgdGhpcy5yZXNvbHZlICAgICAgPSBvcHRpb25zWydyZXNvbHZlJ10gICAgICB8fCBmdW5jdGlvbiAoKSB7IHJldHVybiB0cnVlOyB9O1xuICB0aGlzLmNvbnN0cnVjdCAgICA9IG9wdGlvbnNbJ2NvbnN0cnVjdCddICAgIHx8IGZ1bmN0aW9uIChkYXRhKSB7IHJldHVybiBkYXRhOyB9O1xuICB0aGlzLmluc3RhbmNlT2YgICA9IG9wdGlvbnNbJ2luc3RhbmNlT2YnXSAgIHx8IG51bGw7XG4gIHRoaXMucHJlZGljYXRlICAgID0gb3B0aW9uc1sncHJlZGljYXRlJ10gICAgfHwgbnVsbDtcbiAgdGhpcy5yZXByZXNlbnQgICAgPSBvcHRpb25zWydyZXByZXNlbnQnXSAgICB8fCBudWxsO1xuICB0aGlzLmRlZmF1bHRTdHlsZSA9IG9wdGlvbnNbJ2RlZmF1bHRTdHlsZSddIHx8IG51bGw7XG4gIHRoaXMuc3R5bGVBbGlhc2VzID0gY29tcGlsZVN0eWxlQWxpYXNlcyhvcHRpb25zWydzdHlsZUFsaWFzZXMnXSB8fCBudWxsKTtcblxuICBpZiAoWUFNTF9OT0RFX0tJTkRTLmluZGV4T2YodGhpcy5raW5kKSA9PT0gLTEpIHtcbiAgICB0aHJvdyBuZXcgWUFNTEV4Y2VwdGlvbignVW5rbm93biBraW5kIFwiJyArIHRoaXMua2luZCArICdcIiBpcyBzcGVjaWZpZWQgZm9yIFwiJyArIHRhZyArICdcIiBZQU1MIHR5cGUuJyk7XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBUeXBlO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2pzLXlhbWwvbGliL2pzLXlhbWwvdHlwZS5qcyIsInZhciBmcyA9IHJlcXVpcmUoJ2ZzJylcbnZhciBwb2x5ZmlsbHMgPSByZXF1aXJlKCcuL3BvbHlmaWxscy5qcycpXG52YXIgbGVnYWN5ID0gcmVxdWlyZSgnLi9sZWdhY3ktc3RyZWFtcy5qcycpXG52YXIgcXVldWUgPSBbXVxuXG52YXIgdXRpbCA9IHJlcXVpcmUoJ3V0aWwnKVxuXG5mdW5jdGlvbiBub29wICgpIHt9XG5cbnZhciBkZWJ1ZyA9IG5vb3BcbmlmICh1dGlsLmRlYnVnbG9nKVxuICBkZWJ1ZyA9IHV0aWwuZGVidWdsb2coJ2dmczQnKVxuZWxzZSBpZiAoL1xcYmdmczRcXGIvaS50ZXN0KHByb2Nlc3MuZW52Lk5PREVfREVCVUcgfHwgJycpKVxuICBkZWJ1ZyA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBtID0gdXRpbC5mb3JtYXQuYXBwbHkodXRpbCwgYXJndW1lbnRzKVxuICAgIG0gPSAnR0ZTNDogJyArIG0uc3BsaXQoL1xcbi8pLmpvaW4oJ1xcbkdGUzQ6ICcpXG4gICAgY29uc29sZS5lcnJvcihtKVxuICB9XG5cbmlmICgvXFxiZ2ZzNFxcYi9pLnRlc3QocHJvY2Vzcy5lbnYuTk9ERV9ERUJVRyB8fCAnJykpIHtcbiAgcHJvY2Vzcy5vbignZXhpdCcsIGZ1bmN0aW9uKCkge1xuICAgIGRlYnVnKHF1ZXVlKVxuICAgIHJlcXVpcmUoJ2Fzc2VydCcpLmVxdWFsKHF1ZXVlLmxlbmd0aCwgMClcbiAgfSlcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBwYXRjaChyZXF1aXJlKCcuL2ZzLmpzJykpXG5pZiAocHJvY2Vzcy5lbnYuVEVTVF9HUkFDRUZVTF9GU19HTE9CQUxfUEFUQ0gpIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSBwYXRjaChmcylcbn1cblxuLy8gQWx3YXlzIHBhdGNoIGZzLmNsb3NlL2Nsb3NlU3luYywgYmVjYXVzZSB3ZSB3YW50IHRvXG4vLyByZXRyeSgpIHdoZW5ldmVyIGEgY2xvc2UgaGFwcGVucyAqYW55d2hlcmUqIGluIHRoZSBwcm9ncmFtLlxuLy8gVGhpcyBpcyBlc3NlbnRpYWwgd2hlbiBtdWx0aXBsZSBncmFjZWZ1bC1mcyBpbnN0YW5jZXMgYXJlXG4vLyBpbiBwbGF5IGF0IHRoZSBzYW1lIHRpbWUuXG5tb2R1bGUuZXhwb3J0cy5jbG9zZSA9XG5mcy5jbG9zZSA9IChmdW5jdGlvbiAoZnMkY2xvc2UpIHsgcmV0dXJuIGZ1bmN0aW9uIChmZCwgY2IpIHtcbiAgcmV0dXJuIGZzJGNsb3NlLmNhbGwoZnMsIGZkLCBmdW5jdGlvbiAoZXJyKSB7XG4gICAgaWYgKCFlcnIpXG4gICAgICByZXRyeSgpXG5cbiAgICBpZiAodHlwZW9mIGNiID09PSAnZnVuY3Rpb24nKVxuICAgICAgY2IuYXBwbHkodGhpcywgYXJndW1lbnRzKVxuICB9KVxufX0pKGZzLmNsb3NlKVxuXG5tb2R1bGUuZXhwb3J0cy5jbG9zZVN5bmMgPVxuZnMuY2xvc2VTeW5jID0gKGZ1bmN0aW9uIChmcyRjbG9zZVN5bmMpIHsgcmV0dXJuIGZ1bmN0aW9uIChmZCkge1xuICAvLyBOb3RlIHRoYXQgZ3JhY2VmdWwtZnMgYWxzbyByZXRyaWVzIHdoZW4gZnMuY2xvc2VTeW5jKCkgZmFpbHMuXG4gIC8vIExvb2tzIGxpa2UgYSBidWcgdG8gbWUsIGFsdGhvdWdoIGl0J3MgcHJvYmFibHkgYSBoYXJtbGVzcyBvbmUuXG4gIHZhciBydmFsID0gZnMkY2xvc2VTeW5jLmFwcGx5KGZzLCBhcmd1bWVudHMpXG4gIHJldHJ5KClcbiAgcmV0dXJuIHJ2YWxcbn19KShmcy5jbG9zZVN5bmMpXG5cbmZ1bmN0aW9uIHBhdGNoIChmcykge1xuICAvLyBFdmVyeXRoaW5nIHRoYXQgcmVmZXJlbmNlcyB0aGUgb3BlbigpIGZ1bmN0aW9uIG5lZWRzIHRvIGJlIGluIGhlcmVcbiAgcG9seWZpbGxzKGZzKVxuICBmcy5ncmFjZWZ1bGlmeSA9IHBhdGNoXG4gIGZzLkZpbGVSZWFkU3RyZWFtID0gUmVhZFN0cmVhbTsgIC8vIExlZ2FjeSBuYW1lLlxuICBmcy5GaWxlV3JpdGVTdHJlYW0gPSBXcml0ZVN0cmVhbTsgIC8vIExlZ2FjeSBuYW1lLlxuICBmcy5jcmVhdGVSZWFkU3RyZWFtID0gY3JlYXRlUmVhZFN0cmVhbVxuICBmcy5jcmVhdGVXcml0ZVN0cmVhbSA9IGNyZWF0ZVdyaXRlU3RyZWFtXG4gIHZhciBmcyRyZWFkRmlsZSA9IGZzLnJlYWRGaWxlXG4gIGZzLnJlYWRGaWxlID0gcmVhZEZpbGVcbiAgZnVuY3Rpb24gcmVhZEZpbGUgKHBhdGgsIG9wdGlvbnMsIGNiKSB7XG4gICAgaWYgKHR5cGVvZiBvcHRpb25zID09PSAnZnVuY3Rpb24nKVxuICAgICAgY2IgPSBvcHRpb25zLCBvcHRpb25zID0gbnVsbFxuXG4gICAgcmV0dXJuIGdvJHJlYWRGaWxlKHBhdGgsIG9wdGlvbnMsIGNiKVxuXG4gICAgZnVuY3Rpb24gZ28kcmVhZEZpbGUgKHBhdGgsIG9wdGlvbnMsIGNiKSB7XG4gICAgICByZXR1cm4gZnMkcmVhZEZpbGUocGF0aCwgb3B0aW9ucywgZnVuY3Rpb24gKGVycikge1xuICAgICAgICBpZiAoZXJyICYmIChlcnIuY29kZSA9PT0gJ0VNRklMRScgfHwgZXJyLmNvZGUgPT09ICdFTkZJTEUnKSlcbiAgICAgICAgICBlbnF1ZXVlKFtnbyRyZWFkRmlsZSwgW3BhdGgsIG9wdGlvbnMsIGNiXV0pXG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIGlmICh0eXBlb2YgY2IgPT09ICdmdW5jdGlvbicpXG4gICAgICAgICAgICBjYi5hcHBseSh0aGlzLCBhcmd1bWVudHMpXG4gICAgICAgICAgcmV0cnkoKVxuICAgICAgICB9XG4gICAgICB9KVxuICAgIH1cbiAgfVxuXG4gIHZhciBmcyR3cml0ZUZpbGUgPSBmcy53cml0ZUZpbGVcbiAgZnMud3JpdGVGaWxlID0gd3JpdGVGaWxlXG4gIGZ1bmN0aW9uIHdyaXRlRmlsZSAocGF0aCwgZGF0YSwgb3B0aW9ucywgY2IpIHtcbiAgICBpZiAodHlwZW9mIG9wdGlvbnMgPT09ICdmdW5jdGlvbicpXG4gICAgICBjYiA9IG9wdGlvbnMsIG9wdGlvbnMgPSBudWxsXG5cbiAgICByZXR1cm4gZ28kd3JpdGVGaWxlKHBhdGgsIGRhdGEsIG9wdGlvbnMsIGNiKVxuXG4gICAgZnVuY3Rpb24gZ28kd3JpdGVGaWxlIChwYXRoLCBkYXRhLCBvcHRpb25zLCBjYikge1xuICAgICAgcmV0dXJuIGZzJHdyaXRlRmlsZShwYXRoLCBkYXRhLCBvcHRpb25zLCBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgIGlmIChlcnIgJiYgKGVyci5jb2RlID09PSAnRU1GSUxFJyB8fCBlcnIuY29kZSA9PT0gJ0VORklMRScpKVxuICAgICAgICAgIGVucXVldWUoW2dvJHdyaXRlRmlsZSwgW3BhdGgsIGRhdGEsIG9wdGlvbnMsIGNiXV0pXG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIGlmICh0eXBlb2YgY2IgPT09ICdmdW5jdGlvbicpXG4gICAgICAgICAgICBjYi5hcHBseSh0aGlzLCBhcmd1bWVudHMpXG4gICAgICAgICAgcmV0cnkoKVxuICAgICAgICB9XG4gICAgICB9KVxuICAgIH1cbiAgfVxuXG4gIHZhciBmcyRhcHBlbmRGaWxlID0gZnMuYXBwZW5kRmlsZVxuICBpZiAoZnMkYXBwZW5kRmlsZSlcbiAgICBmcy5hcHBlbmRGaWxlID0gYXBwZW5kRmlsZVxuICBmdW5jdGlvbiBhcHBlbmRGaWxlIChwYXRoLCBkYXRhLCBvcHRpb25zLCBjYikge1xuICAgIGlmICh0eXBlb2Ygb3B0aW9ucyA9PT0gJ2Z1bmN0aW9uJylcbiAgICAgIGNiID0gb3B0aW9ucywgb3B0aW9ucyA9IG51bGxcblxuICAgIHJldHVybiBnbyRhcHBlbmRGaWxlKHBhdGgsIGRhdGEsIG9wdGlvbnMsIGNiKVxuXG4gICAgZnVuY3Rpb24gZ28kYXBwZW5kRmlsZSAocGF0aCwgZGF0YSwgb3B0aW9ucywgY2IpIHtcbiAgICAgIHJldHVybiBmcyRhcHBlbmRGaWxlKHBhdGgsIGRhdGEsIG9wdGlvbnMsIGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgaWYgKGVyciAmJiAoZXJyLmNvZGUgPT09ICdFTUZJTEUnIHx8IGVyci5jb2RlID09PSAnRU5GSUxFJykpXG4gICAgICAgICAgZW5xdWV1ZShbZ28kYXBwZW5kRmlsZSwgW3BhdGgsIGRhdGEsIG9wdGlvbnMsIGNiXV0pXG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIGlmICh0eXBlb2YgY2IgPT09ICdmdW5jdGlvbicpXG4gICAgICAgICAgICBjYi5hcHBseSh0aGlzLCBhcmd1bWVudHMpXG4gICAgICAgICAgcmV0cnkoKVxuICAgICAgICB9XG4gICAgICB9KVxuICAgIH1cbiAgfVxuXG4gIHZhciBmcyRyZWFkZGlyID0gZnMucmVhZGRpclxuICBmcy5yZWFkZGlyID0gcmVhZGRpclxuICBmdW5jdGlvbiByZWFkZGlyIChwYXRoLCBvcHRpb25zLCBjYikge1xuICAgIHZhciBhcmdzID0gW3BhdGhdXG4gICAgaWYgKHR5cGVvZiBvcHRpb25zICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICBhcmdzLnB1c2gob3B0aW9ucylcbiAgICB9IGVsc2Uge1xuICAgICAgY2IgPSBvcHRpb25zXG4gICAgfVxuICAgIGFyZ3MucHVzaChnbyRyZWFkZGlyJGNiKVxuXG4gICAgcmV0dXJuIGdvJHJlYWRkaXIoYXJncylcblxuICAgIGZ1bmN0aW9uIGdvJHJlYWRkaXIkY2IgKGVyciwgZmlsZXMpIHtcbiAgICAgIGlmIChmaWxlcyAmJiBmaWxlcy5zb3J0KVxuICAgICAgICBmaWxlcy5zb3J0KClcblxuICAgICAgaWYgKGVyciAmJiAoZXJyLmNvZGUgPT09ICdFTUZJTEUnIHx8IGVyci5jb2RlID09PSAnRU5GSUxFJykpXG4gICAgICAgIGVucXVldWUoW2dvJHJlYWRkaXIsIFthcmdzXV0pXG4gICAgICBlbHNlIHtcbiAgICAgICAgaWYgKHR5cGVvZiBjYiA9PT0gJ2Z1bmN0aW9uJylcbiAgICAgICAgICBjYi5hcHBseSh0aGlzLCBhcmd1bWVudHMpXG4gICAgICAgIHJldHJ5KClcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBnbyRyZWFkZGlyIChhcmdzKSB7XG4gICAgcmV0dXJuIGZzJHJlYWRkaXIuYXBwbHkoZnMsIGFyZ3MpXG4gIH1cblxuICBpZiAocHJvY2Vzcy52ZXJzaW9uLnN1YnN0cigwLCA0KSA9PT0gJ3YwLjgnKSB7XG4gICAgdmFyIGxlZ1N0cmVhbXMgPSBsZWdhY3koZnMpXG4gICAgUmVhZFN0cmVhbSA9IGxlZ1N0cmVhbXMuUmVhZFN0cmVhbVxuICAgIFdyaXRlU3RyZWFtID0gbGVnU3RyZWFtcy5Xcml0ZVN0cmVhbVxuICB9XG5cbiAgdmFyIGZzJFJlYWRTdHJlYW0gPSBmcy5SZWFkU3RyZWFtXG4gIFJlYWRTdHJlYW0ucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShmcyRSZWFkU3RyZWFtLnByb3RvdHlwZSlcbiAgUmVhZFN0cmVhbS5wcm90b3R5cGUub3BlbiA9IFJlYWRTdHJlYW0kb3BlblxuXG4gIHZhciBmcyRXcml0ZVN0cmVhbSA9IGZzLldyaXRlU3RyZWFtXG4gIFdyaXRlU3RyZWFtLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoZnMkV3JpdGVTdHJlYW0ucHJvdG90eXBlKVxuICBXcml0ZVN0cmVhbS5wcm90b3R5cGUub3BlbiA9IFdyaXRlU3RyZWFtJG9wZW5cblxuICBmcy5SZWFkU3RyZWFtID0gUmVhZFN0cmVhbVxuICBmcy5Xcml0ZVN0cmVhbSA9IFdyaXRlU3RyZWFtXG5cbiAgZnVuY3Rpb24gUmVhZFN0cmVhbSAocGF0aCwgb3B0aW9ucykge1xuICAgIGlmICh0aGlzIGluc3RhbmNlb2YgUmVhZFN0cmVhbSlcbiAgICAgIHJldHVybiBmcyRSZWFkU3RyZWFtLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyksIHRoaXNcbiAgICBlbHNlXG4gICAgICByZXR1cm4gUmVhZFN0cmVhbS5hcHBseShPYmplY3QuY3JlYXRlKFJlYWRTdHJlYW0ucHJvdG90eXBlKSwgYXJndW1lbnRzKVxuICB9XG5cbiAgZnVuY3Rpb24gUmVhZFN0cmVhbSRvcGVuICgpIHtcbiAgICB2YXIgdGhhdCA9IHRoaXNcbiAgICBvcGVuKHRoYXQucGF0aCwgdGhhdC5mbGFncywgdGhhdC5tb2RlLCBmdW5jdGlvbiAoZXJyLCBmZCkge1xuICAgICAgaWYgKGVycikge1xuICAgICAgICBpZiAodGhhdC5hdXRvQ2xvc2UpXG4gICAgICAgICAgdGhhdC5kZXN0cm95KClcblxuICAgICAgICB0aGF0LmVtaXQoJ2Vycm9yJywgZXJyKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhhdC5mZCA9IGZkXG4gICAgICAgIHRoYXQuZW1pdCgnb3BlbicsIGZkKVxuICAgICAgICB0aGF0LnJlYWQoKVxuICAgICAgfVxuICAgIH0pXG4gIH1cblxuICBmdW5jdGlvbiBXcml0ZVN0cmVhbSAocGF0aCwgb3B0aW9ucykge1xuICAgIGlmICh0aGlzIGluc3RhbmNlb2YgV3JpdGVTdHJlYW0pXG4gICAgICByZXR1cm4gZnMkV3JpdGVTdHJlYW0uYXBwbHkodGhpcywgYXJndW1lbnRzKSwgdGhpc1xuICAgIGVsc2VcbiAgICAgIHJldHVybiBXcml0ZVN0cmVhbS5hcHBseShPYmplY3QuY3JlYXRlKFdyaXRlU3RyZWFtLnByb3RvdHlwZSksIGFyZ3VtZW50cylcbiAgfVxuXG4gIGZ1bmN0aW9uIFdyaXRlU3RyZWFtJG9wZW4gKCkge1xuICAgIHZhciB0aGF0ID0gdGhpc1xuICAgIG9wZW4odGhhdC5wYXRoLCB0aGF0LmZsYWdzLCB0aGF0Lm1vZGUsIGZ1bmN0aW9uIChlcnIsIGZkKSB7XG4gICAgICBpZiAoZXJyKSB7XG4gICAgICAgIHRoYXQuZGVzdHJveSgpXG4gICAgICAgIHRoYXQuZW1pdCgnZXJyb3InLCBlcnIpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGF0LmZkID0gZmRcbiAgICAgICAgdGhhdC5lbWl0KCdvcGVuJywgZmQpXG4gICAgICB9XG4gICAgfSlcbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZVJlYWRTdHJlYW0gKHBhdGgsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gbmV3IFJlYWRTdHJlYW0ocGF0aCwgb3B0aW9ucylcbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZVdyaXRlU3RyZWFtIChwYXRoLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIG5ldyBXcml0ZVN0cmVhbShwYXRoLCBvcHRpb25zKVxuICB9XG5cbiAgdmFyIGZzJG9wZW4gPSBmcy5vcGVuXG4gIGZzLm9wZW4gPSBvcGVuXG4gIGZ1bmN0aW9uIG9wZW4gKHBhdGgsIGZsYWdzLCBtb2RlLCBjYikge1xuICAgIGlmICh0eXBlb2YgbW9kZSA9PT0gJ2Z1bmN0aW9uJylcbiAgICAgIGNiID0gbW9kZSwgbW9kZSA9IG51bGxcblxuICAgIHJldHVybiBnbyRvcGVuKHBhdGgsIGZsYWdzLCBtb2RlLCBjYilcblxuICAgIGZ1bmN0aW9uIGdvJG9wZW4gKHBhdGgsIGZsYWdzLCBtb2RlLCBjYikge1xuICAgICAgcmV0dXJuIGZzJG9wZW4ocGF0aCwgZmxhZ3MsIG1vZGUsIGZ1bmN0aW9uIChlcnIsIGZkKSB7XG4gICAgICAgIGlmIChlcnIgJiYgKGVyci5jb2RlID09PSAnRU1GSUxFJyB8fCBlcnIuY29kZSA9PT0gJ0VORklMRScpKVxuICAgICAgICAgIGVucXVldWUoW2dvJG9wZW4sIFtwYXRoLCBmbGFncywgbW9kZSwgY2JdXSlcbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgaWYgKHR5cGVvZiBjYiA9PT0gJ2Z1bmN0aW9uJylcbiAgICAgICAgICAgIGNiLmFwcGx5KHRoaXMsIGFyZ3VtZW50cylcbiAgICAgICAgICByZXRyeSgpXG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZzXG59XG5cbmZ1bmN0aW9uIGVucXVldWUgKGVsZW0pIHtcbiAgZGVidWcoJ0VOUVVFVUUnLCBlbGVtWzBdLm5hbWUsIGVsZW1bMV0pXG4gIHF1ZXVlLnB1c2goZWxlbSlcbn1cblxuZnVuY3Rpb24gcmV0cnkgKCkge1xuICB2YXIgZWxlbSA9IHF1ZXVlLnNoaWZ0KClcbiAgaWYgKGVsZW0pIHtcbiAgICBkZWJ1ZygnUkVUUlknLCBlbGVtWzBdLm5hbWUsIGVsZW1bMV0pXG4gICAgZWxlbVswXS5hcHBseShudWxsLCBlbGVtWzFdKVxuICB9XG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvZ3JhY2VmdWwtZnMvZ3JhY2VmdWwtZnMuanMiLCIndXNlIHN0cmljdCdcblxuZXhwb3J0cy5mcm9tQ2FsbGJhY2sgPSBmdW5jdGlvbiAoZm4pIHtcbiAgcmV0dXJuIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHR5cGVvZiBhcmd1bWVudHNbYXJndW1lbnRzLmxlbmd0aCAtIDFdID09PSAnZnVuY3Rpb24nKSBmbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpXG4gICAgZWxzZSB7XG4gICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICBhcmd1bWVudHNbYXJndW1lbnRzLmxlbmd0aF0gPSAoZXJyLCByZXMpID0+IHtcbiAgICAgICAgICBpZiAoZXJyKSByZXR1cm4gcmVqZWN0KGVycilcbiAgICAgICAgICByZXNvbHZlKHJlcylcbiAgICAgICAgfVxuICAgICAgICBhcmd1bWVudHMubGVuZ3RoKytcbiAgICAgICAgZm4uYXBwbHkodGhpcywgYXJndW1lbnRzKVxuICAgICAgfSlcbiAgICB9XG4gIH0sICduYW1lJywgeyB2YWx1ZTogZm4ubmFtZSB9KVxufVxuXG5leHBvcnRzLmZyb21Qcm9taXNlID0gZnVuY3Rpb24gKGZuKSB7XG4gIHJldHVybiBPYmplY3QuZGVmaW5lUHJvcGVydHkoZnVuY3Rpb24gKCkge1xuICAgIGNvbnN0IGNiID0gYXJndW1lbnRzW2FyZ3VtZW50cy5sZW5ndGggLSAxXVxuICAgIGlmICh0eXBlb2YgY2IgIT09ICdmdW5jdGlvbicpIHJldHVybiBmbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpXG4gICAgZWxzZSBmbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpLnRoZW4ociA9PiBjYihudWxsLCByKSwgY2IpXG4gIH0sICduYW1lJywgeyB2YWx1ZTogZm4ubmFtZSB9KVxufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL3VuaXZlcnNhbGlmeS9pbmRleC5qcyIsIid1c2Ugc3RyaWN0J1xuY29uc3QgdSA9IHJlcXVpcmUoJ3VuaXZlcnNhbGlmeScpLmZyb21DYWxsYmFja1xuY29uc3QgbWtkaXJzID0gdShyZXF1aXJlKCcuL21rZGlycycpKVxuY29uc3QgbWtkaXJzU3luYyA9IHJlcXVpcmUoJy4vbWtkaXJzLXN5bmMnKVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgbWtkaXJzOiBta2RpcnMsXG4gIG1rZGlyc1N5bmM6IG1rZGlyc1N5bmMsXG4gIC8vIGFsaWFzXG4gIG1rZGlycDogbWtkaXJzLFxuICBta2RpcnBTeW5jOiBta2RpcnNTeW5jLFxuICBlbnN1cmVEaXI6IG1rZGlycyxcbiAgZW5zdXJlRGlyU3luYzogbWtkaXJzU3luY1xufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2VsZWN0cm9uLXVwZGF0ZXIvbm9kZV9tb2R1bGVzL2ZzLWV4dHJhL2xpYi9ta2RpcnMvaW5kZXguanMiLCJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5VcGRhdGVyU2lnbmFsID0gZXhwb3J0cy5VUERBVEVfRE9XTkxPQURFRCA9IGV4cG9ydHMuRE9XTkxPQURfUFJPR1JFU1MgPSBleHBvcnRzLlByb3ZpZGVyID0gZXhwb3J0cy5DYW5jZWxsYXRpb25Ub2tlbiA9IGV4cG9ydHMuTm9PcExvZ2dlciA9IGV4cG9ydHMuQXBwVXBkYXRlciA9IHVuZGVmaW5lZDtcblxudmFyIF9BcHBVcGRhdGVyO1xuXG5mdW5jdGlvbiBfbG9hZF9BcHBVcGRhdGVyKCkge1xuICAgIHJldHVybiBfQXBwVXBkYXRlciA9IHJlcXVpcmUoXCIuL0FwcFVwZGF0ZXJcIik7XG59XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkFwcFVwZGF0ZXJcIiwge1xuICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiAoX0FwcFVwZGF0ZXIgfHwgX2xvYWRfQXBwVXBkYXRlcigpKS5BcHBVcGRhdGVyO1xuICAgIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiTm9PcExvZ2dlclwiLCB7XG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIChfQXBwVXBkYXRlciB8fCBfbG9hZF9BcHBVcGRhdGVyKCkpLk5vT3BMb2dnZXI7XG4gICAgfVxufSk7XG5cbnZhciBfYnVpbGRlclV0aWxSdW50aW1lO1xuXG5mdW5jdGlvbiBfbG9hZF9idWlsZGVyVXRpbFJ1bnRpbWUoKSB7XG4gICAgcmV0dXJuIF9idWlsZGVyVXRpbFJ1bnRpbWUgPSByZXF1aXJlKFwiYnVpbGRlci11dGlsLXJ1bnRpbWVcIik7XG59XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkNhbmNlbGxhdGlvblRva2VuXCIsIHtcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gKF9idWlsZGVyVXRpbFJ1bnRpbWUgfHwgX2xvYWRfYnVpbGRlclV0aWxSdW50aW1lKCkpLkNhbmNlbGxhdGlvblRva2VuO1xuICAgIH1cbn0pO1xuXG52YXIgX1Byb3ZpZGVyO1xuXG5mdW5jdGlvbiBfbG9hZF9Qcm92aWRlcigpIHtcbiAgICByZXR1cm4gX1Byb3ZpZGVyID0gcmVxdWlyZShcIi4vUHJvdmlkZXJcIik7XG59XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlByb3ZpZGVyXCIsIHtcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gKF9Qcm92aWRlciB8fCBfbG9hZF9Qcm92aWRlcigpKS5Qcm92aWRlcjtcbiAgICB9XG59KTtcbmV4cG9ydHMuZ2V0RGVmYXVsdENoYW5uZWxOYW1lID0gZ2V0RGVmYXVsdENoYW5uZWxOYW1lO1xuZXhwb3J0cy5nZXRDdXN0b21DaGFubmVsTmFtZSA9IGdldEN1c3RvbUNoYW5uZWxOYW1lO1xuZXhwb3J0cy5nZXRDdXJyZW50UGxhdGZvcm0gPSBnZXRDdXJyZW50UGxhdGZvcm07XG5leHBvcnRzLmlzVXNlT2xkTWFjUHJvdmlkZXIgPSBpc1VzZU9sZE1hY1Byb3ZpZGVyO1xuZXhwb3J0cy5nZXRDaGFubmVsRmlsZW5hbWUgPSBnZXRDaGFubmVsRmlsZW5hbWU7XG5leHBvcnRzLm5ld0Jhc2VVcmwgPSBuZXdCYXNlVXJsO1xuZXhwb3J0cy5uZXdVcmxGcm9tQmFzZSA9IG5ld1VybEZyb21CYXNlO1xuXG52YXIgX3VybDtcblxuZnVuY3Rpb24gX2xvYWRfdXJsKCkge1xuICAgIHJldHVybiBfdXJsID0gcmVxdWlyZShcInVybFwiKTtcbn1cblxuLy8gYXV0b1VwZGF0ZXIgdG8gbWltaWMgZWxlY3Ryb24gYnVuZGxlZCBhdXRvVXBkYXRlclxubGV0IF9hdXRvVXBkYXRlcjtcbmZ1bmN0aW9uIF9sb2FkX2F1dG9VcGRhdGVyKCkge1xuICAgIC8vIHRzbGludDpkaXNhYmxlOnByZWZlci1jb25kaXRpb25hbC1leHByZXNzaW9uXG4gICAgaWYgKHByb2Nlc3MucGxhdGZvcm0gPT09IFwid2luMzJcIikge1xuICAgICAgICBfYXV0b1VwZGF0ZXIgPSBuZXcgKHJlcXVpcmUoXCIuL05zaXNVcGRhdGVyXCIpLk5zaXNVcGRhdGVyKSgpO1xuICAgIH0gZWxzZSBpZiAocHJvY2Vzcy5wbGF0Zm9ybSA9PT0gXCJkYXJ3aW5cIikge1xuICAgICAgICBfYXV0b1VwZGF0ZXIgPSBuZXcgKHJlcXVpcmUoXCIuL01hY1VwZGF0ZXJcIikuTWFjVXBkYXRlcikoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBfYXV0b1VwZGF0ZXIgPSBuZXcgKHJlcXVpcmUoXCIuL0FwcEltYWdlVXBkYXRlclwiKS5BcHBJbWFnZVVwZGF0ZXIpKCk7XG4gICAgfVxuICAgIHJldHVybiBfYXV0b1VwZGF0ZXI7XG59XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJhdXRvVXBkYXRlclwiLCB7XG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICBnZXQ6ICgpID0+IHtcbiAgICAgICAgcmV0dXJuIF9hdXRvVXBkYXRlciB8fCBfbG9hZF9hdXRvVXBkYXRlcigpO1xuICAgIH1cbn0pO1xuLy8gZHVlIHRvIGhpc3RvcmljYWwgcmVhc29ucyBmb3Igd2luZG93cyB3ZSB1c2UgY2hhbm5lbCBuYW1lIHdpdGhvdXQgcGxhdGZvcm0gc3BlY2lmaWVyXG5mdW5jdGlvbiBnZXREZWZhdWx0Q2hhbm5lbE5hbWUoKSB7XG4gICAgcmV0dXJuIGBsYXRlc3Qke2dldENoYW5uZWxGaWxlUHJlZml4KCl9YDtcbn1cbmZ1bmN0aW9uIGdldENoYW5uZWxGaWxlUHJlZml4KCkge1xuICAgIGNvbnN0IGN1cnJlbnRQbGF0Zm9ybSA9IGdldEN1cnJlbnRQbGF0Zm9ybSgpO1xuICAgIGlmIChjdXJyZW50UGxhdGZvcm0gPT09IFwibGludXhcIikge1xuICAgICAgICBjb25zdCBhcmNoID0gcHJvY2Vzcy5lbnYuVEVTVF9VUERBVEVSX0FSQ0ggfHwgcHJvY2Vzcy5hcmNoO1xuICAgICAgICBjb25zdCBhcmNoU3VmZml4ID0gYXJjaCA9PT0gXCJ4NjRcIiA/IFwiXCIgOiBgLSR7YXJjaH1gO1xuICAgICAgICByZXR1cm4gXCItbGludXhcIiArIGFyY2hTdWZmaXg7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGN1cnJlbnRQbGF0Zm9ybSA9PT0gXCJkYXJ3aW5cIiA/IFwiLW1hY1wiIDogXCJcIjtcbiAgICB9XG59XG5mdW5jdGlvbiBnZXRDdXN0b21DaGFubmVsTmFtZShjaGFubmVsKSB7XG4gICAgcmV0dXJuIGAke2NoYW5uZWx9JHtnZXRDaGFubmVsRmlsZVByZWZpeCgpfWA7XG59XG5mdW5jdGlvbiBnZXRDdXJyZW50UGxhdGZvcm0oKSB7XG4gICAgcmV0dXJuIHByb2Nlc3MuZW52LlRFU1RfVVBEQVRFUl9QTEFURk9STSB8fCBwcm9jZXNzLnBsYXRmb3JtO1xufVxuZnVuY3Rpb24gaXNVc2VPbGRNYWNQcm92aWRlcigpIHtcbiAgICAvLyBnZXRDdXJyZW50UGxhdGZvcm0oKSA9PT0gXCJkYXJ3aW5cIlxuICAgIHJldHVybiBmYWxzZTtcbn1cbmZ1bmN0aW9uIGdldENoYW5uZWxGaWxlbmFtZShjaGFubmVsKSB7XG4gICAgcmV0dXJuIGAke2NoYW5uZWx9LnltbGA7XG59XG5jb25zdCBET1dOTE9BRF9QUk9HUkVTUyA9IGV4cG9ydHMuRE9XTkxPQURfUFJPR1JFU1MgPSBcImRvd25sb2FkLXByb2dyZXNzXCI7XG5jb25zdCBVUERBVEVfRE9XTkxPQURFRCA9IGV4cG9ydHMuVVBEQVRFX0RPV05MT0FERUQgPSBcInVwZGF0ZS1kb3dubG9hZGVkXCI7XG5jbGFzcyBVcGRhdGVyU2lnbmFsIHtcbiAgICBjb25zdHJ1Y3RvcihlbWl0dGVyKSB7XG4gICAgICAgIHRoaXMuZW1pdHRlciA9IGVtaXR0ZXI7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEVtaXR0ZWQgd2hlbiBhbiBhdXRoZW50aWNhdGluZyBwcm94eSBpcyBbYXNraW5nIGZvciB1c2VyIGNyZWRlbnRpYWxzXShodHRwczovL2dpdGh1Yi5jb20vZWxlY3Ryb24vZWxlY3Ryb24vYmxvYi9tYXN0ZXIvZG9jcy9hcGkvY2xpZW50LXJlcXVlc3QubWQjZXZlbnQtbG9naW4pLlxuICAgICAqL1xuICAgIGxvZ2luKGhhbmRsZXIpIHtcbiAgICAgICAgYWRkSGFuZGxlcih0aGlzLmVtaXR0ZXIsIFwibG9naW5cIiwgaGFuZGxlcik7XG4gICAgfVxuICAgIHByb2dyZXNzKGhhbmRsZXIpIHtcbiAgICAgICAgYWRkSGFuZGxlcih0aGlzLmVtaXR0ZXIsIERPV05MT0FEX1BST0dSRVNTLCBoYW5kbGVyKTtcbiAgICB9XG4gICAgdXBkYXRlRG93bmxvYWRlZChoYW5kbGVyKSB7XG4gICAgICAgIGFkZEhhbmRsZXIodGhpcy5lbWl0dGVyLCBVUERBVEVfRE9XTkxPQURFRCwgaGFuZGxlcik7XG4gICAgfVxuICAgIHVwZGF0ZUNhbmNlbGxlZChoYW5kbGVyKSB7XG4gICAgICAgIGFkZEhhbmRsZXIodGhpcy5lbWl0dGVyLCBcInVwZGF0ZS1jYW5jZWxsZWRcIiwgaGFuZGxlcik7XG4gICAgfVxufVxuZXhwb3J0cy5VcGRhdGVyU2lnbmFsID0gVXBkYXRlclNpZ25hbDtcbmNvbnN0IGlzTG9nRXZlbnQgPSBmYWxzZTtcbmZ1bmN0aW9uIGFkZEhhbmRsZXIoZW1pdHRlciwgZXZlbnQsIGhhbmRsZXIpIHtcbiAgICBpZiAoaXNMb2dFdmVudCkge1xuICAgICAgICBlbWl0dGVyLm9uKGV2ZW50LCAoLi4uYXJncykgPT4ge1xuICAgICAgICAgICAgY29uc29sZS5sb2coXCIlcyAlc1wiLCBldmVudCwgYXJncyk7XG4gICAgICAgICAgICBoYW5kbGVyLmFwcGx5KG51bGwsIGFyZ3MpO1xuICAgICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBlbWl0dGVyLm9uKGV2ZW50LCBoYW5kbGVyKTtcbiAgICB9XG59XG4vLyBpZiBiYXNlVXJsIHBhdGggZG9lc24ndCBlbmRzIHdpdGggLywgdGhpcyBwYXRoIHdpbGwgYmUgbm90IHByZXBlbmRlZCB0byBwYXNzZWQgcGF0aG5hbWUgZm9yIG5ldyBVUkwoaW5wdXQsIGJhc2UpXG4vKiogQGludGVybmFsICovXG5mdW5jdGlvbiBuZXdCYXNlVXJsKHVybCkge1xuICAgIGNvbnN0IHJlc3VsdCA9IG5ldyAoX3VybCB8fCBfbG9hZF91cmwoKSkuVVJMKHVybCk7XG4gICAgaWYgKCFyZXN1bHQucGF0aG5hbWUuZW5kc1dpdGgoXCIvXCIpKSB7XG4gICAgICAgIHJlc3VsdC5wYXRobmFtZSArPSBcIi9cIjtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbi8qKiBAaW50ZXJuYWwgKi9cbmZ1bmN0aW9uIG5ld1VybEZyb21CYXNlKHBhdGhuYW1lLCBiYXNlVXJsKSB7XG4gICAgY29uc3QgcmVzdWx0ID0gbmV3IChfdXJsIHx8IF9sb2FkX3VybCgpKS5VUkwocGF0aG5hbWUsIGJhc2VVcmwpO1xuICAgIC8vIHNlYXJjaCBpcyBub3QgcHJvcGFnYXRlZFxuICAgIGlmICghcmVzdWx0LnNlYXJjaCAmJiBiYXNlVXJsLnNlYXJjaCkge1xuICAgICAgICByZXN1bHQuc2VhcmNoID0gYmFzZVVybC5zZWFyY2g7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1tYWluLmpzLm1hcFxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9lbGVjdHJvbi11cGRhdGVyL291dC9tYWluLmpzIiwiXCJ1c2Ugc3RyaWN0XCJcblxuY29uc3QgZnNFeHRyYSA9IHJlcXVpcmUoXCJmcy1leHRyYVwiKVxuY29uc3QgUHJvbWlzZSA9IHJlcXVpcmUoJ2JsdWViaXJkLWxzdCcpXG5cbmZ1bmN0aW9uIG1ha2VGcyhQcm9taXNlKSB7XG4gIGNvbnN0IGZzID0gT2JqZWN0LmNyZWF0ZShudWxsKVxuXG4gIGZvciAoY29uc3QgbWV0aG9kTmFtZSBvZiBPYmplY3Qua2V5cyhmc0V4dHJhKSkge1xuICAgIGNvbnN0IG1ldGhvZCA9IGZzRXh0cmFbbWV0aG9kTmFtZV1cbiAgICBpZiAobWV0aG9kTmFtZSA9PT0gXCJjcmVhdGVGaWxlXCIgfHwgbWV0aG9kTmFtZSA9PT0gXCJta2RpcnBcIikge1xuICAgICAgY29udGludWVcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIG1ldGhvZCAhPT0gXCJmdW5jdGlvblwiIHx8XG4gICAgICAgIG1ldGhvZE5hbWUuZW5kc1dpdGgoXCJTeW5jXCIpIHx8XG4gICAgICAgIG1ldGhvZE5hbWUuZW5kc1dpdGgoXCJTdHJlYW1cIikgfHxcbiAgICAgICAgbWV0aG9kTmFtZS5tYXRjaCgvXltBLVpdLykgfHxcbiAgICAgICAgbWV0aG9kTmFtZSA9PT0gXCJleGlzdHNcIiB8fFxuICAgICAgICBtZXRob2ROYW1lID09PSBcIndhdGNoXCIgfHxcbiAgICAgICAgbWV0aG9kTmFtZSA9PT0gXCJ3YXRjaEZpbGVcIiB8fFxuICAgICAgICBtZXRob2ROYW1lID09PSBcInVud2F0Y2hGaWxlXCIpIHtcbiAgICAgIGZzW21ldGhvZE5hbWVdID0gbWV0aG9kXG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgZnNbbWV0aG9kTmFtZV0gPSBQcm9taXNlLnByb21pc2lmeShtZXRob2QpXG4gICAgfVxuICB9XG5cbiAgZnMuY3JlYXRlRmlsZSA9IGZzLmVuc3VyZUZpbGVcbiAgZnMubWtkaXJwID0gZnMubWtkaXJzXG4gIHJldHVybiBmc1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IG1ha2VGcyhQcm9taXNlKVxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9lbGVjdHJvbi11cGRhdGVyL25vZGVfbW9kdWxlcy9mcy1leHRyYS1wL2luZGV4LmpzIiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwiZWxlY3Ryb25cIik7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gZXh0ZXJuYWwgXCJlbGVjdHJvblwiXG4vLyBtb2R1bGUgaWQgPSAxMFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBlczUgPSByZXF1aXJlKFwiLi9lczVcIik7XG52YXIgT2JqZWN0ZnJlZXplID0gZXM1LmZyZWV6ZTtcbnZhciB1dGlsID0gcmVxdWlyZShcIi4vdXRpbFwiKTtcbnZhciBpbmhlcml0cyA9IHV0aWwuaW5oZXJpdHM7XG52YXIgbm90RW51bWVyYWJsZVByb3AgPSB1dGlsLm5vdEVudW1lcmFibGVQcm9wO1xuXG5mdW5jdGlvbiBzdWJFcnJvcihuYW1lUHJvcGVydHksIGRlZmF1bHRNZXNzYWdlKSB7XG4gICAgZnVuY3Rpb24gU3ViRXJyb3IobWVzc2FnZSkge1xuICAgICAgICBpZiAoISh0aGlzIGluc3RhbmNlb2YgU3ViRXJyb3IpKSByZXR1cm4gbmV3IFN1YkVycm9yKG1lc3NhZ2UpO1xuICAgICAgICBub3RFbnVtZXJhYmxlUHJvcCh0aGlzLCBcIm1lc3NhZ2VcIixcbiAgICAgICAgICAgIHR5cGVvZiBtZXNzYWdlID09PSBcInN0cmluZ1wiID8gbWVzc2FnZSA6IGRlZmF1bHRNZXNzYWdlKTtcbiAgICAgICAgbm90RW51bWVyYWJsZVByb3AodGhpcywgXCJuYW1lXCIsIG5hbWVQcm9wZXJ0eSk7XG4gICAgICAgIGlmIChFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSkge1xuICAgICAgICAgICAgRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UodGhpcywgdGhpcy5jb25zdHJ1Y3Rvcik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBFcnJvci5jYWxsKHRoaXMpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGluaGVyaXRzKFN1YkVycm9yLCBFcnJvcik7XG4gICAgcmV0dXJuIFN1YkVycm9yO1xufVxuXG52YXIgX1R5cGVFcnJvciwgX1JhbmdlRXJyb3I7XG52YXIgV2FybmluZyA9IHN1YkVycm9yKFwiV2FybmluZ1wiLCBcIndhcm5pbmdcIik7XG52YXIgQ2FuY2VsbGF0aW9uRXJyb3IgPSBzdWJFcnJvcihcIkNhbmNlbGxhdGlvbkVycm9yXCIsIFwiY2FuY2VsbGF0aW9uIGVycm9yXCIpO1xudmFyIFRpbWVvdXRFcnJvciA9IHN1YkVycm9yKFwiVGltZW91dEVycm9yXCIsIFwidGltZW91dCBlcnJvclwiKTtcbnZhciBBZ2dyZWdhdGVFcnJvciA9IHN1YkVycm9yKFwiQWdncmVnYXRlRXJyb3JcIiwgXCJhZ2dyZWdhdGUgZXJyb3JcIik7XG50cnkge1xuICAgIF9UeXBlRXJyb3IgPSBUeXBlRXJyb3I7XG4gICAgX1JhbmdlRXJyb3IgPSBSYW5nZUVycm9yO1xufSBjYXRjaChlKSB7XG4gICAgX1R5cGVFcnJvciA9IHN1YkVycm9yKFwiVHlwZUVycm9yXCIsIFwidHlwZSBlcnJvclwiKTtcbiAgICBfUmFuZ2VFcnJvciA9IHN1YkVycm9yKFwiUmFuZ2VFcnJvclwiLCBcInJhbmdlIGVycm9yXCIpO1xufVxuXG52YXIgbWV0aG9kcyA9IChcImpvaW4gcG9wIHB1c2ggc2hpZnQgdW5zaGlmdCBzbGljZSBmaWx0ZXIgZm9yRWFjaCBzb21lIFwiICtcbiAgICBcImV2ZXJ5IG1hcCBpbmRleE9mIGxhc3RJbmRleE9mIHJlZHVjZSByZWR1Y2VSaWdodCBzb3J0IHJldmVyc2VcIikuc3BsaXQoXCIgXCIpO1xuXG5mb3IgKHZhciBpID0gMDsgaSA8IG1ldGhvZHMubGVuZ3RoOyArK2kpIHtcbiAgICBpZiAodHlwZW9mIEFycmF5LnByb3RvdHlwZVttZXRob2RzW2ldXSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIEFnZ3JlZ2F0ZUVycm9yLnByb3RvdHlwZVttZXRob2RzW2ldXSA9IEFycmF5LnByb3RvdHlwZVttZXRob2RzW2ldXTtcbiAgICB9XG59XG5cbmVzNS5kZWZpbmVQcm9wZXJ0eShBZ2dyZWdhdGVFcnJvci5wcm90b3R5cGUsIFwibGVuZ3RoXCIsIHtcbiAgICB2YWx1ZTogMCxcbiAgICBjb25maWd1cmFibGU6IGZhbHNlLFxuICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgIGVudW1lcmFibGU6IHRydWVcbn0pO1xuQWdncmVnYXRlRXJyb3IucHJvdG90eXBlW1wiaXNPcGVyYXRpb25hbFwiXSA9IHRydWU7XG52YXIgbGV2ZWwgPSAwO1xuQWdncmVnYXRlRXJyb3IucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGluZGVudCA9IEFycmF5KGxldmVsICogNCArIDEpLmpvaW4oXCIgXCIpO1xuICAgIHZhciByZXQgPSBcIlxcblwiICsgaW5kZW50ICsgXCJBZ2dyZWdhdGVFcnJvciBvZjpcIiArIFwiXFxuXCI7XG4gICAgbGV2ZWwrKztcbiAgICBpbmRlbnQgPSBBcnJheShsZXZlbCAqIDQgKyAxKS5qb2luKFwiIFwiKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgdmFyIHN0ciA9IHRoaXNbaV0gPT09IHRoaXMgPyBcIltDaXJjdWxhciBBZ2dyZWdhdGVFcnJvcl1cIiA6IHRoaXNbaV0gKyBcIlwiO1xuICAgICAgICB2YXIgbGluZXMgPSBzdHIuc3BsaXQoXCJcXG5cIik7XG4gICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgbGluZXMubGVuZ3RoOyArK2opIHtcbiAgICAgICAgICAgIGxpbmVzW2pdID0gaW5kZW50ICsgbGluZXNbal07XG4gICAgICAgIH1cbiAgICAgICAgc3RyID0gbGluZXMuam9pbihcIlxcblwiKTtcbiAgICAgICAgcmV0ICs9IHN0ciArIFwiXFxuXCI7XG4gICAgfVxuICAgIGxldmVsLS07XG4gICAgcmV0dXJuIHJldDtcbn07XG5cbmZ1bmN0aW9uIE9wZXJhdGlvbmFsRXJyb3IobWVzc2FnZSkge1xuICAgIGlmICghKHRoaXMgaW5zdGFuY2VvZiBPcGVyYXRpb25hbEVycm9yKSlcbiAgICAgICAgcmV0dXJuIG5ldyBPcGVyYXRpb25hbEVycm9yKG1lc3NhZ2UpO1xuICAgIG5vdEVudW1lcmFibGVQcm9wKHRoaXMsIFwibmFtZVwiLCBcIk9wZXJhdGlvbmFsRXJyb3JcIik7XG4gICAgbm90RW51bWVyYWJsZVByb3AodGhpcywgXCJtZXNzYWdlXCIsIG1lc3NhZ2UpO1xuICAgIHRoaXMuY2F1c2UgPSBtZXNzYWdlO1xuICAgIHRoaXNbXCJpc09wZXJhdGlvbmFsXCJdID0gdHJ1ZTtcblxuICAgIGlmIChtZXNzYWdlIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgICAgbm90RW51bWVyYWJsZVByb3AodGhpcywgXCJtZXNzYWdlXCIsIG1lc3NhZ2UubWVzc2FnZSk7XG4gICAgICAgIG5vdEVudW1lcmFibGVQcm9wKHRoaXMsIFwic3RhY2tcIiwgbWVzc2FnZS5zdGFjayk7XG4gICAgfSBlbHNlIGlmIChFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSkge1xuICAgICAgICBFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSh0aGlzLCB0aGlzLmNvbnN0cnVjdG9yKTtcbiAgICB9XG5cbn1cbmluaGVyaXRzKE9wZXJhdGlvbmFsRXJyb3IsIEVycm9yKTtcblxudmFyIGVycm9yVHlwZXMgPSBFcnJvcltcIl9fQmx1ZWJpcmRFcnJvclR5cGVzX19cIl07XG5pZiAoIWVycm9yVHlwZXMpIHtcbiAgICBlcnJvclR5cGVzID0gT2JqZWN0ZnJlZXplKHtcbiAgICAgICAgQ2FuY2VsbGF0aW9uRXJyb3I6IENhbmNlbGxhdGlvbkVycm9yLFxuICAgICAgICBUaW1lb3V0RXJyb3I6IFRpbWVvdXRFcnJvcixcbiAgICAgICAgT3BlcmF0aW9uYWxFcnJvcjogT3BlcmF0aW9uYWxFcnJvcixcbiAgICAgICAgUmVqZWN0aW9uRXJyb3I6IE9wZXJhdGlvbmFsRXJyb3IsXG4gICAgICAgIEFnZ3JlZ2F0ZUVycm9yOiBBZ2dyZWdhdGVFcnJvclxuICAgIH0pO1xuICAgIGVzNS5kZWZpbmVQcm9wZXJ0eShFcnJvciwgXCJfX0JsdWViaXJkRXJyb3JUeXBlc19fXCIsIHtcbiAgICAgICAgdmFsdWU6IGVycm9yVHlwZXMsXG4gICAgICAgIHdyaXRhYmxlOiBmYWxzZSxcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogZmFsc2VcbiAgICB9KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgRXJyb3I6IEVycm9yLFxuICAgIFR5cGVFcnJvcjogX1R5cGVFcnJvcixcbiAgICBSYW5nZUVycm9yOiBfUmFuZ2VFcnJvcixcbiAgICBDYW5jZWxsYXRpb25FcnJvcjogZXJyb3JUeXBlcy5DYW5jZWxsYXRpb25FcnJvcixcbiAgICBPcGVyYXRpb25hbEVycm9yOiBlcnJvclR5cGVzLk9wZXJhdGlvbmFsRXJyb3IsXG4gICAgVGltZW91dEVycm9yOiBlcnJvclR5cGVzLlRpbWVvdXRFcnJvcixcbiAgICBBZ2dyZWdhdGVFcnJvcjogZXJyb3JUeXBlcy5BZ2dyZWdhdGVFcnJvcixcbiAgICBXYXJuaW5nOiBXYXJuaW5nXG59O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2JsdWViaXJkL2pzL3JlbGVhc2UvZXJyb3JzLmpzIiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwiZnNcIik7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gZXh0ZXJuYWwgXCJmc1wiXG4vLyBtb2R1bGUgaWQgPSAxMlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIndXNlIHN0cmljdCdcbmNvbnN0IHUgPSByZXF1aXJlKCd1bml2ZXJzYWxpZnknKS5mcm9tUHJvbWlzZVxuY29uc3QgZnMgPSByZXF1aXJlKCcuLi9mcycpXG5cbmZ1bmN0aW9uIHBhdGhFeGlzdHMgKHBhdGgpIHtcbiAgcmV0dXJuIGZzLmFjY2VzcyhwYXRoKS50aGVuKCgpID0+IHRydWUpLmNhdGNoKCgpID0+IGZhbHNlKVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgcGF0aEV4aXN0czogdShwYXRoRXhpc3RzKSxcbiAgcGF0aEV4aXN0c1N5bmM6IGZzLmV4aXN0c1N5bmNcbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9lbGVjdHJvbi11cGRhdGVyL25vZGVfbW9kdWxlcy9mcy1leHRyYS9saWIvcGF0aC1leGlzdHMvaW5kZXguanMiLCJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5Qcm92aWRlciA9IHVuZGVmaW5lZDtcbmV4cG9ydHMuZmluZEZpbGUgPSBmaW5kRmlsZTtcbmV4cG9ydHMucGFyc2VVcGRhdGVJbmZvID0gcGFyc2VVcGRhdGVJbmZvO1xuZXhwb3J0cy5nZXRGaWxlTGlzdCA9IGdldEZpbGVMaXN0O1xuZXhwb3J0cy5yZXNvbHZlRmlsZXMgPSByZXNvbHZlRmlsZXM7XG5cbnZhciBfYnVpbGRlclV0aWxSdW50aW1lO1xuXG5mdW5jdGlvbiBfbG9hZF9idWlsZGVyVXRpbFJ1bnRpbWUoKSB7XG4gICAgcmV0dXJuIF9idWlsZGVyVXRpbFJ1bnRpbWUgPSByZXF1aXJlKFwiYnVpbGRlci11dGlsLXJ1bnRpbWVcIik7XG59XG5cbnZhciBfanNZYW1sO1xuXG5mdW5jdGlvbiBfbG9hZF9qc1lhbWwoKSB7XG4gICAgcmV0dXJuIF9qc1lhbWwgPSByZXF1aXJlKFwianMteWFtbFwiKTtcbn1cblxudmFyIF9tYWluO1xuXG5mdW5jdGlvbiBfbG9hZF9tYWluKCkge1xuICAgIHJldHVybiBfbWFpbiA9IHJlcXVpcmUoXCIuL21haW5cIik7XG59XG5cbmNsYXNzIFByb3ZpZGVyIHtcbiAgICBjb25zdHJ1Y3RvcihleGVjdXRvciwgdXNlTXVsdGlwbGVSYW5nZVJlcXVlc3QgPSB0cnVlKSB7XG4gICAgICAgIHRoaXMuZXhlY3V0b3IgPSBleGVjdXRvcjtcbiAgICAgICAgdGhpcy51c2VNdWx0aXBsZVJhbmdlUmVxdWVzdCA9IHVzZU11bHRpcGxlUmFuZ2VSZXF1ZXN0O1xuICAgIH1cbiAgICBnZXQgZmlsZUV4dHJhRG93bmxvYWRIZWFkZXJzKCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgc2V0UmVxdWVzdEhlYWRlcnModmFsdWUpIHtcbiAgICAgICAgdGhpcy5yZXF1ZXN0SGVhZGVycyA9IHZhbHVlO1xuICAgIH1cbiAgICBodHRwUmVxdWVzdCh1cmwsIGhlYWRlcnMsIGNhbmNlbGxhdGlvblRva2VuKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmV4ZWN1dG9yLnJlcXVlc3QodGhpcy5jcmVhdGVSZXF1ZXN0T3B0aW9ucyh1cmwsIGhlYWRlcnMpLCBjYW5jZWxsYXRpb25Ub2tlbik7XG4gICAgfVxuICAgIGNyZWF0ZVJlcXVlc3RPcHRpb25zKHVybCwgaGVhZGVycykge1xuICAgICAgICBjb25zdCByZXN1bHQgPSB7fTtcbiAgICAgICAgaWYgKHRoaXMucmVxdWVzdEhlYWRlcnMgPT0gbnVsbCkge1xuICAgICAgICAgICAgaWYgKGhlYWRlcnMgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJlc3VsdC5oZWFkZXJzID0gaGVhZGVycztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlc3VsdC5oZWFkZXJzID0gaGVhZGVycyA9PSBudWxsID8gdGhpcy5yZXF1ZXN0SGVhZGVycyA6IE9iamVjdC5hc3NpZ24oe30sIHRoaXMucmVxdWVzdEhlYWRlcnMsIGhlYWRlcnMpO1xuICAgICAgICB9XG4gICAgICAgIHJlc3VsdC5wcm90b2NvbCA9IHVybC5wcm90b2NvbDtcbiAgICAgICAgcmVzdWx0Lmhvc3RuYW1lID0gdXJsLmhvc3RuYW1lO1xuICAgICAgICBpZiAodXJsLnBvcnQpIHtcbiAgICAgICAgICAgIHJlc3VsdC5wb3J0ID0gdXJsLnBvcnQ7XG4gICAgICAgIH1cbiAgICAgICAgcmVzdWx0LnBhdGggPSB1cmwucGF0aG5hbWUgKyB1cmwuc2VhcmNoO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbn1cbmV4cG9ydHMuUHJvdmlkZXIgPSBQcm92aWRlcjtcbmZ1bmN0aW9uIGZpbmRGaWxlKGZpbGVzLCBleHRlbnNpb24sIG5vdCkge1xuICAgIGlmIChmaWxlcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgdGhyb3cgKDAsIChfYnVpbGRlclV0aWxSdW50aW1lIHx8IF9sb2FkX2J1aWxkZXJVdGlsUnVudGltZSgpKS5uZXdFcnJvcikoXCJObyBmaWxlcyBwcm92aWRlZFwiLCBcIkVSUl9VUERBVEVSX05PX0ZJTEVTX1BST1ZJREVEXCIpO1xuICAgIH1cbiAgICBjb25zdCByZXN1bHQgPSBmaWxlcy5maW5kKGl0ID0+IGl0LnVybC5wYXRobmFtZS50b0xvd2VyQ2FzZSgpLmVuZHNXaXRoKGAuJHtleHRlbnNpb259YCkpO1xuICAgIGlmIChyZXN1bHQgIT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0gZWxzZSBpZiAobm90ID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIGZpbGVzWzBdO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBmaWxlcy5maW5kKGZpbGVJbmZvID0+ICFub3Quc29tZShleHQgPT4gZmlsZUluZm8udXJsLnBhdGhuYW1lLnRvTG93ZXJDYXNlKCkuZW5kc1dpdGgoYC4ke2V4dH1gKSkpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHBhcnNlVXBkYXRlSW5mbyhyYXdEYXRhLCBjaGFubmVsRmlsZSwgY2hhbm5lbEZpbGVVcmwpIHtcbiAgICBpZiAocmF3RGF0YSA9PSBudWxsKSB7XG4gICAgICAgIHRocm93ICgwLCAoX2J1aWxkZXJVdGlsUnVudGltZSB8fCBfbG9hZF9idWlsZGVyVXRpbFJ1bnRpbWUoKSkubmV3RXJyb3IpKGBDYW5ub3QgcGFyc2UgdXBkYXRlIGluZm8gZnJvbSAke2NoYW5uZWxGaWxlfSBpbiB0aGUgbGF0ZXN0IHJlbGVhc2UgYXJ0aWZhY3RzICgke2NoYW5uZWxGaWxlVXJsfSk6IHJhd0RhdGE6IG51bGxgLCBcIkVSUl9VUERBVEVSX0lOVkFMSURfVVBEQVRFX0lORk9cIik7XG4gICAgfVxuICAgIGxldCByZXN1bHQ7XG4gICAgdHJ5IHtcbiAgICAgICAgcmVzdWx0ID0gKDAsIChfanNZYW1sIHx8IF9sb2FkX2pzWWFtbCgpKS5zYWZlTG9hZCkocmF3RGF0YSk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgICB0aHJvdyAoMCwgKF9idWlsZGVyVXRpbFJ1bnRpbWUgfHwgX2xvYWRfYnVpbGRlclV0aWxSdW50aW1lKCkpLm5ld0Vycm9yKShgQ2Fubm90IHBhcnNlIHVwZGF0ZSBpbmZvIGZyb20gJHtjaGFubmVsRmlsZX0gaW4gdGhlIGxhdGVzdCByZWxlYXNlIGFydGlmYWN0cyAoJHtjaGFubmVsRmlsZVVybH0pOiAke2Uuc3RhY2sgfHwgZS5tZXNzYWdlfSwgcmF3RGF0YTogJHtyYXdEYXRhfWAsIFwiRVJSX1VQREFURVJfSU5WQUxJRF9VUERBVEVfSU5GT1wiKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIGdldEZpbGVMaXN0KHVwZGF0ZUluZm8pIHtcbiAgICBjb25zdCBmaWxlcyA9IHVwZGF0ZUluZm8uZmlsZXM7XG4gICAgaWYgKGZpbGVzICE9IG51bGwgJiYgZmlsZXMubGVuZ3RoID4gMCkge1xuICAgICAgICByZXR1cm4gZmlsZXM7XG4gICAgfVxuICAgIGlmICh1cGRhdGVJbmZvLnBhdGggIT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gW3tcbiAgICAgICAgICAgIHVybDogdXBkYXRlSW5mby5wYXRoLFxuICAgICAgICAgICAgc2hhNTEyOiB1cGRhdGVJbmZvLnNoYTUxMlxuICAgICAgICB9XTtcbiAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyAoMCwgKF9idWlsZGVyVXRpbFJ1bnRpbWUgfHwgX2xvYWRfYnVpbGRlclV0aWxSdW50aW1lKCkpLm5ld0Vycm9yKShgTm8gZmlsZXMgcHJvdmlkZWQ6ICR7KDAsIChfYnVpbGRlclV0aWxSdW50aW1lIHx8IF9sb2FkX2J1aWxkZXJVdGlsUnVudGltZSgpKS5zYWZlU3RyaW5naWZ5SnNvbikodXBkYXRlSW5mbyl9YCwgXCJFUlJfVVBEQVRFUl9OT19GSUxFU19QUk9WSURFRFwiKTtcbiAgICB9XG59XG5mdW5jdGlvbiByZXNvbHZlRmlsZXModXBkYXRlSW5mbywgYmFzZVVybCwgcGF0aFRyYW5zZm9ybWVyID0gcCA9PiBwKSB7XG4gICAgY29uc3QgZmlsZXMgPSBnZXRGaWxlTGlzdCh1cGRhdGVJbmZvKTtcbiAgICBjb25zdCByZXN1bHQgPSBmaWxlcy5tYXAoZmlsZUluZm8gPT4ge1xuICAgICAgICBpZiAoZmlsZUluZm8uc2hhMiA9PSBudWxsICYmIGZpbGVJbmZvLnNoYTUxMiA9PSBudWxsKSB7XG4gICAgICAgICAgICB0aHJvdyAoMCwgKF9idWlsZGVyVXRpbFJ1bnRpbWUgfHwgX2xvYWRfYnVpbGRlclV0aWxSdW50aW1lKCkpLm5ld0Vycm9yKShgVXBkYXRlIGluZm8gZG9lc24ndCBjb250YWluIG5vciBzaGEyNTYgbmVpdGhlciBzaGE1MTIgY2hlY2tzdW06ICR7KDAsIChfYnVpbGRlclV0aWxSdW50aW1lIHx8IF9sb2FkX2J1aWxkZXJVdGlsUnVudGltZSgpKS5zYWZlU3RyaW5naWZ5SnNvbikoZmlsZUluZm8pfWAsIFwiRVJSX1VQREFURVJfTk9fQ0hFQ0tTVU1cIik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHVybDogKDAsIChfbWFpbiB8fCBfbG9hZF9tYWluKCkpLm5ld1VybEZyb21CYXNlKShwYXRoVHJhbnNmb3JtZXIoZmlsZUluZm8udXJsKSwgYmFzZVVybCksXG4gICAgICAgICAgICBpbmZvOiBmaWxlSW5mb1xuICAgICAgICB9O1xuICAgIH0pO1xuICAgIGNvbnN0IHBhY2thZ2VzID0gdXBkYXRlSW5mby5wYWNrYWdlcztcbiAgICBjb25zdCBwYWNrYWdlSW5mbyA9IHBhY2thZ2VzID09IG51bGwgPyBudWxsIDogcGFja2FnZXNbcHJvY2Vzcy5hcmNoXSB8fCBwYWNrYWdlcy5pYTMyO1xuICAgIGlmIChwYWNrYWdlSW5mbyAhPSBudWxsKSB7XG4gICAgICAgIHJlc3VsdFswXS5wYWNrYWdlSW5mbyA9IE9iamVjdC5hc3NpZ24oe30sIHBhY2thZ2VJbmZvLCB7IHBhdGg6ICgwLCAoX21haW4gfHwgX2xvYWRfbWFpbigpKS5uZXdVcmxGcm9tQmFzZSkocGF0aFRyYW5zZm9ybWVyKHBhY2thZ2VJbmZvLnBhdGgpLCBiYXNlVXJsKS5ocmVmIH0pO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9UHJvdmlkZXIuanMubWFwXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2VsZWN0cm9uLXVwZGF0ZXIvb3V0L1Byb3ZpZGVyLmpzIiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwib3NcIik7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gZXh0ZXJuYWwgXCJvc1wiXG4vLyBtb2R1bGUgaWQgPSAxNVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgaXNFUzUgPSAoZnVuY3Rpb24oKXtcbiAgICBcInVzZSBzdHJpY3RcIjtcbiAgICByZXR1cm4gdGhpcyA9PT0gdW5kZWZpbmVkO1xufSkoKTtcblxuaWYgKGlzRVM1KSB7XG4gICAgbW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgICAgIGZyZWV6ZTogT2JqZWN0LmZyZWV6ZSxcbiAgICAgICAgZGVmaW5lUHJvcGVydHk6IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSxcbiAgICAgICAgZ2V0RGVzY3JpcHRvcjogT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcixcbiAgICAgICAga2V5czogT2JqZWN0LmtleXMsXG4gICAgICAgIG5hbWVzOiBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyxcbiAgICAgICAgZ2V0UHJvdG90eXBlT2Y6IE9iamVjdC5nZXRQcm90b3R5cGVPZixcbiAgICAgICAgaXNBcnJheTogQXJyYXkuaXNBcnJheSxcbiAgICAgICAgaXNFUzU6IGlzRVM1LFxuICAgICAgICBwcm9wZXJ0eUlzV3JpdGFibGU6IGZ1bmN0aW9uKG9iaiwgcHJvcCkge1xuICAgICAgICAgICAgdmFyIGRlc2NyaXB0b3IgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iaiwgcHJvcCk7XG4gICAgICAgICAgICByZXR1cm4gISEoIWRlc2NyaXB0b3IgfHwgZGVzY3JpcHRvci53cml0YWJsZSB8fCBkZXNjcmlwdG9yLnNldCk7XG4gICAgICAgIH1cbiAgICB9O1xufSBlbHNlIHtcbiAgICB2YXIgaGFzID0ge30uaGFzT3duUHJvcGVydHk7XG4gICAgdmFyIHN0ciA9IHt9LnRvU3RyaW5nO1xuICAgIHZhciBwcm90byA9IHt9LmNvbnN0cnVjdG9yLnByb3RvdHlwZTtcblxuICAgIHZhciBPYmplY3RLZXlzID0gZnVuY3Rpb24gKG8pIHtcbiAgICAgICAgdmFyIHJldCA9IFtdO1xuICAgICAgICBmb3IgKHZhciBrZXkgaW4gbykge1xuICAgICAgICAgICAgaWYgKGhhcy5jYWxsKG8sIGtleSkpIHtcbiAgICAgICAgICAgICAgICByZXQucHVzaChrZXkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXQ7XG4gICAgfTtcblxuICAgIHZhciBPYmplY3RHZXREZXNjcmlwdG9yID0gZnVuY3Rpb24obywga2V5KSB7XG4gICAgICAgIHJldHVybiB7dmFsdWU6IG9ba2V5XX07XG4gICAgfTtcblxuICAgIHZhciBPYmplY3REZWZpbmVQcm9wZXJ0eSA9IGZ1bmN0aW9uIChvLCBrZXksIGRlc2MpIHtcbiAgICAgICAgb1trZXldID0gZGVzYy52YWx1ZTtcbiAgICAgICAgcmV0dXJuIG87XG4gICAgfTtcblxuICAgIHZhciBPYmplY3RGcmVlemUgPSBmdW5jdGlvbiAob2JqKSB7XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfTtcblxuICAgIHZhciBPYmplY3RHZXRQcm90b3R5cGVPZiA9IGZ1bmN0aW9uIChvYmopIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybiBPYmplY3Qob2JqKS5jb25zdHJ1Y3Rvci5wcm90b3R5cGU7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIHJldHVybiBwcm90bztcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICB2YXIgQXJyYXlJc0FycmF5ID0gZnVuY3Rpb24gKG9iaikge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmV0dXJuIHN0ci5jYWxsKG9iaikgPT09IFwiW29iamVjdCBBcnJheV1cIjtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaChlKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgICAgIGlzQXJyYXk6IEFycmF5SXNBcnJheSxcbiAgICAgICAga2V5czogT2JqZWN0S2V5cyxcbiAgICAgICAgbmFtZXM6IE9iamVjdEtleXMsXG4gICAgICAgIGRlZmluZVByb3BlcnR5OiBPYmplY3REZWZpbmVQcm9wZXJ0eSxcbiAgICAgICAgZ2V0RGVzY3JpcHRvcjogT2JqZWN0R2V0RGVzY3JpcHRvcixcbiAgICAgICAgZnJlZXplOiBPYmplY3RGcmVlemUsXG4gICAgICAgIGdldFByb3RvdHlwZU9mOiBPYmplY3RHZXRQcm90b3R5cGVPZixcbiAgICAgICAgaXNFUzU6IGlzRVM1LFxuICAgICAgICBwcm9wZXJ0eUlzV3JpdGFibGU6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICB9O1xufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2JsdWViaXJkL2pzL3JlbGVhc2UvZXM1LmpzIiwiJ3VzZSBzdHJpY3QnO1xuXG5cbmZ1bmN0aW9uIGlzTm90aGluZyhzdWJqZWN0KSB7XG4gIHJldHVybiAodHlwZW9mIHN1YmplY3QgPT09ICd1bmRlZmluZWQnKSB8fCAoc3ViamVjdCA9PT0gbnVsbCk7XG59XG5cblxuZnVuY3Rpb24gaXNPYmplY3Qoc3ViamVjdCkge1xuICByZXR1cm4gKHR5cGVvZiBzdWJqZWN0ID09PSAnb2JqZWN0JykgJiYgKHN1YmplY3QgIT09IG51bGwpO1xufVxuXG5cbmZ1bmN0aW9uIHRvQXJyYXkoc2VxdWVuY2UpIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkoc2VxdWVuY2UpKSByZXR1cm4gc2VxdWVuY2U7XG4gIGVsc2UgaWYgKGlzTm90aGluZyhzZXF1ZW5jZSkpIHJldHVybiBbXTtcblxuICByZXR1cm4gWyBzZXF1ZW5jZSBdO1xufVxuXG5cbmZ1bmN0aW9uIGV4dGVuZCh0YXJnZXQsIHNvdXJjZSkge1xuICB2YXIgaW5kZXgsIGxlbmd0aCwga2V5LCBzb3VyY2VLZXlzO1xuXG4gIGlmIChzb3VyY2UpIHtcbiAgICBzb3VyY2VLZXlzID0gT2JqZWN0LmtleXMoc291cmNlKTtcblxuICAgIGZvciAoaW5kZXggPSAwLCBsZW5ndGggPSBzb3VyY2VLZXlzLmxlbmd0aDsgaW5kZXggPCBsZW5ndGg7IGluZGV4ICs9IDEpIHtcbiAgICAgIGtleSA9IHNvdXJjZUtleXNbaW5kZXhdO1xuICAgICAgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdGFyZ2V0O1xufVxuXG5cbmZ1bmN0aW9uIHJlcGVhdChzdHJpbmcsIGNvdW50KSB7XG4gIHZhciByZXN1bHQgPSAnJywgY3ljbGU7XG5cbiAgZm9yIChjeWNsZSA9IDA7IGN5Y2xlIDwgY291bnQ7IGN5Y2xlICs9IDEpIHtcbiAgICByZXN1bHQgKz0gc3RyaW5nO1xuICB9XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuXG5mdW5jdGlvbiBpc05lZ2F0aXZlWmVybyhudW1iZXIpIHtcbiAgcmV0dXJuIChudW1iZXIgPT09IDApICYmIChOdW1iZXIuTkVHQVRJVkVfSU5GSU5JVFkgPT09IDEgLyBudW1iZXIpO1xufVxuXG5cbm1vZHVsZS5leHBvcnRzLmlzTm90aGluZyAgICAgID0gaXNOb3RoaW5nO1xubW9kdWxlLmV4cG9ydHMuaXNPYmplY3QgICAgICAgPSBpc09iamVjdDtcbm1vZHVsZS5leHBvcnRzLnRvQXJyYXkgICAgICAgID0gdG9BcnJheTtcbm1vZHVsZS5leHBvcnRzLnJlcGVhdCAgICAgICAgID0gcmVwZWF0O1xubW9kdWxlLmV4cG9ydHMuaXNOZWdhdGl2ZVplcm8gPSBpc05lZ2F0aXZlWmVybztcbm1vZHVsZS5leHBvcnRzLmV4dGVuZCAgICAgICAgID0gZXh0ZW5kO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2pzLXlhbWwvbGliL2pzLXlhbWwvY29tbW9uLmpzIiwiJ3VzZSBzdHJpY3QnO1xuXG4vKmVzbGludC1kaXNhYmxlIG1heC1sZW4qL1xuXG52YXIgY29tbW9uICAgICAgICA9IHJlcXVpcmUoJy4vY29tbW9uJyk7XG52YXIgWUFNTEV4Y2VwdGlvbiA9IHJlcXVpcmUoJy4vZXhjZXB0aW9uJyk7XG52YXIgVHlwZSAgICAgICAgICA9IHJlcXVpcmUoJy4vdHlwZScpO1xuXG5cbmZ1bmN0aW9uIGNvbXBpbGVMaXN0KHNjaGVtYSwgbmFtZSwgcmVzdWx0KSB7XG4gIHZhciBleGNsdWRlID0gW107XG5cbiAgc2NoZW1hLmluY2x1ZGUuZm9yRWFjaChmdW5jdGlvbiAoaW5jbHVkZWRTY2hlbWEpIHtcbiAgICByZXN1bHQgPSBjb21waWxlTGlzdChpbmNsdWRlZFNjaGVtYSwgbmFtZSwgcmVzdWx0KTtcbiAgfSk7XG5cbiAgc2NoZW1hW25hbWVdLmZvckVhY2goZnVuY3Rpb24gKGN1cnJlbnRUeXBlKSB7XG4gICAgcmVzdWx0LmZvckVhY2goZnVuY3Rpb24gKHByZXZpb3VzVHlwZSwgcHJldmlvdXNJbmRleCkge1xuICAgICAgaWYgKHByZXZpb3VzVHlwZS50YWcgPT09IGN1cnJlbnRUeXBlLnRhZyAmJiBwcmV2aW91c1R5cGUua2luZCA9PT0gY3VycmVudFR5cGUua2luZCkge1xuICAgICAgICBleGNsdWRlLnB1c2gocHJldmlvdXNJbmRleCk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICByZXN1bHQucHVzaChjdXJyZW50VHlwZSk7XG4gIH0pO1xuXG4gIHJldHVybiByZXN1bHQuZmlsdGVyKGZ1bmN0aW9uICh0eXBlLCBpbmRleCkge1xuICAgIHJldHVybiBleGNsdWRlLmluZGV4T2YoaW5kZXgpID09PSAtMTtcbiAgfSk7XG59XG5cblxuZnVuY3Rpb24gY29tcGlsZU1hcCgvKiBsaXN0cy4uLiAqLykge1xuICB2YXIgcmVzdWx0ID0ge1xuICAgICAgICBzY2FsYXI6IHt9LFxuICAgICAgICBzZXF1ZW5jZToge30sXG4gICAgICAgIG1hcHBpbmc6IHt9LFxuICAgICAgICBmYWxsYmFjazoge31cbiAgICAgIH0sIGluZGV4LCBsZW5ndGg7XG5cbiAgZnVuY3Rpb24gY29sbGVjdFR5cGUodHlwZSkge1xuICAgIHJlc3VsdFt0eXBlLmtpbmRdW3R5cGUudGFnXSA9IHJlc3VsdFsnZmFsbGJhY2snXVt0eXBlLnRhZ10gPSB0eXBlO1xuICB9XG5cbiAgZm9yIChpbmRleCA9IDAsIGxlbmd0aCA9IGFyZ3VtZW50cy5sZW5ndGg7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCArPSAxKSB7XG4gICAgYXJndW1lbnRzW2luZGV4XS5mb3JFYWNoKGNvbGxlY3RUeXBlKTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5cbmZ1bmN0aW9uIFNjaGVtYShkZWZpbml0aW9uKSB7XG4gIHRoaXMuaW5jbHVkZSAgPSBkZWZpbml0aW9uLmluY2x1ZGUgIHx8IFtdO1xuICB0aGlzLmltcGxpY2l0ID0gZGVmaW5pdGlvbi5pbXBsaWNpdCB8fCBbXTtcbiAgdGhpcy5leHBsaWNpdCA9IGRlZmluaXRpb24uZXhwbGljaXQgfHwgW107XG5cbiAgdGhpcy5pbXBsaWNpdC5mb3JFYWNoKGZ1bmN0aW9uICh0eXBlKSB7XG4gICAgaWYgKHR5cGUubG9hZEtpbmQgJiYgdHlwZS5sb2FkS2luZCAhPT0gJ3NjYWxhcicpIHtcbiAgICAgIHRocm93IG5ldyBZQU1MRXhjZXB0aW9uKCdUaGVyZSBpcyBhIG5vbi1zY2FsYXIgdHlwZSBpbiB0aGUgaW1wbGljaXQgbGlzdCBvZiBhIHNjaGVtYS4gSW1wbGljaXQgcmVzb2x2aW5nIG9mIHN1Y2ggdHlwZXMgaXMgbm90IHN1cHBvcnRlZC4nKTtcbiAgICB9XG4gIH0pO1xuXG4gIHRoaXMuY29tcGlsZWRJbXBsaWNpdCA9IGNvbXBpbGVMaXN0KHRoaXMsICdpbXBsaWNpdCcsIFtdKTtcbiAgdGhpcy5jb21waWxlZEV4cGxpY2l0ID0gY29tcGlsZUxpc3QodGhpcywgJ2V4cGxpY2l0JywgW10pO1xuICB0aGlzLmNvbXBpbGVkVHlwZU1hcCAgPSBjb21waWxlTWFwKHRoaXMuY29tcGlsZWRJbXBsaWNpdCwgdGhpcy5jb21waWxlZEV4cGxpY2l0KTtcbn1cblxuXG5TY2hlbWEuREVGQVVMVCA9IG51bGw7XG5cblxuU2NoZW1hLmNyZWF0ZSA9IGZ1bmN0aW9uIGNyZWF0ZVNjaGVtYSgpIHtcbiAgdmFyIHNjaGVtYXMsIHR5cGVzO1xuXG4gIHN3aXRjaCAoYXJndW1lbnRzLmxlbmd0aCkge1xuICAgIGNhc2UgMTpcbiAgICAgIHNjaGVtYXMgPSBTY2hlbWEuREVGQVVMVDtcbiAgICAgIHR5cGVzID0gYXJndW1lbnRzWzBdO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlIDI6XG4gICAgICBzY2hlbWFzID0gYXJndW1lbnRzWzBdO1xuICAgICAgdHlwZXMgPSBhcmd1bWVudHNbMV07XG4gICAgICBicmVhaztcblxuICAgIGRlZmF1bHQ6XG4gICAgICB0aHJvdyBuZXcgWUFNTEV4Y2VwdGlvbignV3JvbmcgbnVtYmVyIG9mIGFyZ3VtZW50cyBmb3IgU2NoZW1hLmNyZWF0ZSBmdW5jdGlvbicpO1xuICB9XG5cbiAgc2NoZW1hcyA9IGNvbW1vbi50b0FycmF5KHNjaGVtYXMpO1xuICB0eXBlcyA9IGNvbW1vbi50b0FycmF5KHR5cGVzKTtcblxuICBpZiAoIXNjaGVtYXMuZXZlcnkoZnVuY3Rpb24gKHNjaGVtYSkgeyByZXR1cm4gc2NoZW1hIGluc3RhbmNlb2YgU2NoZW1hOyB9KSkge1xuICAgIHRocm93IG5ldyBZQU1MRXhjZXB0aW9uKCdTcGVjaWZpZWQgbGlzdCBvZiBzdXBlciBzY2hlbWFzIChvciBhIHNpbmdsZSBTY2hlbWEgb2JqZWN0KSBjb250YWlucyBhIG5vbi1TY2hlbWEgb2JqZWN0LicpO1xuICB9XG5cbiAgaWYgKCF0eXBlcy5ldmVyeShmdW5jdGlvbiAodHlwZSkgeyByZXR1cm4gdHlwZSBpbnN0YW5jZW9mIFR5cGU7IH0pKSB7XG4gICAgdGhyb3cgbmV3IFlBTUxFeGNlcHRpb24oJ1NwZWNpZmllZCBsaXN0IG9mIFlBTUwgdHlwZXMgKG9yIGEgc2luZ2xlIFR5cGUgb2JqZWN0KSBjb250YWlucyBhIG5vbi1UeXBlIG9iamVjdC4nKTtcbiAgfVxuXG4gIHJldHVybiBuZXcgU2NoZW1hKHtcbiAgICBpbmNsdWRlOiBzY2hlbWFzLFxuICAgIGV4cGxpY2l0OiB0eXBlc1xuICB9KTtcbn07XG5cblxubW9kdWxlLmV4cG9ydHMgPSBTY2hlbWE7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvanMteWFtbC9saWIvanMteWFtbC9zY2hlbWEuanMiLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCJzdHJlYW1cIik7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gZXh0ZXJuYWwgXCJzdHJlYW1cIlxuLy8gbW9kdWxlIGlkID0gMTlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwidXJsXCIpO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIGV4dGVybmFsIFwidXJsXCJcbi8vIG1vZHVsZSBpZCA9IDIwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8vIFlBTUwgZXJyb3IgY2xhc3MuIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvODQ1ODk4NFxuLy9cbid1c2Ugc3RyaWN0JztcblxuZnVuY3Rpb24gWUFNTEV4Y2VwdGlvbihyZWFzb24sIG1hcmspIHtcbiAgLy8gU3VwZXIgY29uc3RydWN0b3JcbiAgRXJyb3IuY2FsbCh0aGlzKTtcblxuICB0aGlzLm5hbWUgPSAnWUFNTEV4Y2VwdGlvbic7XG4gIHRoaXMucmVhc29uID0gcmVhc29uO1xuICB0aGlzLm1hcmsgPSBtYXJrO1xuICB0aGlzLm1lc3NhZ2UgPSAodGhpcy5yZWFzb24gfHwgJyh1bmtub3duIHJlYXNvbiknKSArICh0aGlzLm1hcmsgPyAnICcgKyB0aGlzLm1hcmsudG9TdHJpbmcoKSA6ICcnKTtcblxuICAvLyBJbmNsdWRlIHN0YWNrIHRyYWNlIGluIGVycm9yIG9iamVjdFxuICBpZiAoRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UpIHtcbiAgICAvLyBDaHJvbWUgYW5kIE5vZGVKU1xuICAgIEVycm9yLmNhcHR1cmVTdGFja1RyYWNlKHRoaXMsIHRoaXMuY29uc3RydWN0b3IpO1xuICB9IGVsc2Uge1xuICAgIC8vIEZGLCBJRSAxMCsgYW5kIFNhZmFyaSA2Ky4gRmFsbGJhY2sgZm9yIG90aGVyc1xuICAgIHRoaXMuc3RhY2sgPSAobmV3IEVycm9yKCkpLnN0YWNrIHx8ICcnO1xuICB9XG59XG5cblxuLy8gSW5oZXJpdCBmcm9tIEVycm9yXG5ZQU1MRXhjZXB0aW9uLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoRXJyb3IucHJvdG90eXBlKTtcbllBTUxFeGNlcHRpb24ucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gWUFNTEV4Y2VwdGlvbjtcblxuXG5ZQU1MRXhjZXB0aW9uLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nKGNvbXBhY3QpIHtcbiAgdmFyIHJlc3VsdCA9IHRoaXMubmFtZSArICc6ICc7XG5cbiAgcmVzdWx0ICs9IHRoaXMucmVhc29uIHx8ICcodW5rbm93biByZWFzb24pJztcblxuICBpZiAoIWNvbXBhY3QgJiYgdGhpcy5tYXJrKSB7XG4gICAgcmVzdWx0ICs9ICcgJyArIHRoaXMubWFyay50b1N0cmluZygpO1xuICB9XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cblxubW9kdWxlLmV4cG9ydHMgPSBZQU1MRXhjZXB0aW9uO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2pzLXlhbWwvbGliL2pzLXlhbWwvZXhjZXB0aW9uLmpzIiwiLy8gSlMtWUFNTCdzIGRlZmF1bHQgc2NoZW1hIGZvciBgc2FmZUxvYWRgIGZ1bmN0aW9uLlxuLy8gSXQgaXMgbm90IGRlc2NyaWJlZCBpbiB0aGUgWUFNTCBzcGVjaWZpY2F0aW9uLlxuLy9cbi8vIFRoaXMgc2NoZW1hIGlzIGJhc2VkIG9uIHN0YW5kYXJkIFlBTUwncyBDb3JlIHNjaGVtYSBhbmQgaW5jbHVkZXMgbW9zdCBvZlxuLy8gZXh0cmEgdHlwZXMgZGVzY3JpYmVkIGF0IFlBTUwgdGFnIHJlcG9zaXRvcnkuIChodHRwOi8veWFtbC5vcmcvdHlwZS8pXG5cblxuJ3VzZSBzdHJpY3QnO1xuXG5cbnZhciBTY2hlbWEgPSByZXF1aXJlKCcuLi9zY2hlbWEnKTtcblxuXG5tb2R1bGUuZXhwb3J0cyA9IG5ldyBTY2hlbWEoe1xuICBpbmNsdWRlOiBbXG4gICAgcmVxdWlyZSgnLi9jb3JlJylcbiAgXSxcbiAgaW1wbGljaXQ6IFtcbiAgICByZXF1aXJlKCcuLi90eXBlL3RpbWVzdGFtcCcpLFxuICAgIHJlcXVpcmUoJy4uL3R5cGUvbWVyZ2UnKVxuICBdLFxuICBleHBsaWNpdDogW1xuICAgIHJlcXVpcmUoJy4uL3R5cGUvYmluYXJ5JyksXG4gICAgcmVxdWlyZSgnLi4vdHlwZS9vbWFwJyksXG4gICAgcmVxdWlyZSgnLi4vdHlwZS9wYWlycycpLFxuICAgIHJlcXVpcmUoJy4uL3R5cGUvc2V0JylcbiAgXVxufSk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvanMteWFtbC9saWIvanMteWFtbC9zY2hlbWEvZGVmYXVsdF9zYWZlLmpzIiwiLyogLSotIE1vZGU6IGpzOyBqcy1pbmRlbnQtbGV2ZWw6IDI7IC0qLSAqL1xuLypcbiAqIENvcHlyaWdodCAyMDExIE1vemlsbGEgRm91bmRhdGlvbiBhbmQgY29udHJpYnV0b3JzXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTmV3IEJTRCBsaWNlbnNlLiBTZWUgTElDRU5TRSBvcjpcbiAqIGh0dHA6Ly9vcGVuc291cmNlLm9yZy9saWNlbnNlcy9CU0QtMy1DbGF1c2VcbiAqL1xuXG4vKipcbiAqIFRoaXMgaXMgYSBoZWxwZXIgZnVuY3Rpb24gZm9yIGdldHRpbmcgdmFsdWVzIGZyb20gcGFyYW1ldGVyL29wdGlvbnNcbiAqIG9iamVjdHMuXG4gKlxuICogQHBhcmFtIGFyZ3MgVGhlIG9iamVjdCB3ZSBhcmUgZXh0cmFjdGluZyB2YWx1ZXMgZnJvbVxuICogQHBhcmFtIG5hbWUgVGhlIG5hbWUgb2YgdGhlIHByb3BlcnR5IHdlIGFyZSBnZXR0aW5nLlxuICogQHBhcmFtIGRlZmF1bHRWYWx1ZSBBbiBvcHRpb25hbCB2YWx1ZSB0byByZXR1cm4gaWYgdGhlIHByb3BlcnR5IGlzIG1pc3NpbmdcbiAqIGZyb20gdGhlIG9iamVjdC4gSWYgdGhpcyBpcyBub3Qgc3BlY2lmaWVkIGFuZCB0aGUgcHJvcGVydHkgaXMgbWlzc2luZywgYW5cbiAqIGVycm9yIHdpbGwgYmUgdGhyb3duLlxuICovXG5mdW5jdGlvbiBnZXRBcmcoYUFyZ3MsIGFOYW1lLCBhRGVmYXVsdFZhbHVlKSB7XG4gIGlmIChhTmFtZSBpbiBhQXJncykge1xuICAgIHJldHVybiBhQXJnc1thTmFtZV07XG4gIH0gZWxzZSBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMykge1xuICAgIHJldHVybiBhRGVmYXVsdFZhbHVlO1xuICB9IGVsc2Uge1xuICAgIHRocm93IG5ldyBFcnJvcignXCInICsgYU5hbWUgKyAnXCIgaXMgYSByZXF1aXJlZCBhcmd1bWVudC4nKTtcbiAgfVxufVxuZXhwb3J0cy5nZXRBcmcgPSBnZXRBcmc7XG5cbnZhciB1cmxSZWdleHAgPSAvXig/OihbXFx3K1xcLS5dKyk6KT9cXC9cXC8oPzooXFx3KzpcXHcrKUApPyhbXFx3Li1dKikoPzo6KFxcZCspKT8oLiopJC87XG52YXIgZGF0YVVybFJlZ2V4cCA9IC9eZGF0YTouK1xcLC4rJC87XG5cbmZ1bmN0aW9uIHVybFBhcnNlKGFVcmwpIHtcbiAgdmFyIG1hdGNoID0gYVVybC5tYXRjaCh1cmxSZWdleHApO1xuICBpZiAoIW1hdGNoKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBzY2hlbWU6IG1hdGNoWzFdLFxuICAgIGF1dGg6IG1hdGNoWzJdLFxuICAgIGhvc3Q6IG1hdGNoWzNdLFxuICAgIHBvcnQ6IG1hdGNoWzRdLFxuICAgIHBhdGg6IG1hdGNoWzVdXG4gIH07XG59XG5leHBvcnRzLnVybFBhcnNlID0gdXJsUGFyc2U7XG5cbmZ1bmN0aW9uIHVybEdlbmVyYXRlKGFQYXJzZWRVcmwpIHtcbiAgdmFyIHVybCA9ICcnO1xuICBpZiAoYVBhcnNlZFVybC5zY2hlbWUpIHtcbiAgICB1cmwgKz0gYVBhcnNlZFVybC5zY2hlbWUgKyAnOic7XG4gIH1cbiAgdXJsICs9ICcvLyc7XG4gIGlmIChhUGFyc2VkVXJsLmF1dGgpIHtcbiAgICB1cmwgKz0gYVBhcnNlZFVybC5hdXRoICsgJ0AnO1xuICB9XG4gIGlmIChhUGFyc2VkVXJsLmhvc3QpIHtcbiAgICB1cmwgKz0gYVBhcnNlZFVybC5ob3N0O1xuICB9XG4gIGlmIChhUGFyc2VkVXJsLnBvcnQpIHtcbiAgICB1cmwgKz0gXCI6XCIgKyBhUGFyc2VkVXJsLnBvcnRcbiAgfVxuICBpZiAoYVBhcnNlZFVybC5wYXRoKSB7XG4gICAgdXJsICs9IGFQYXJzZWRVcmwucGF0aDtcbiAgfVxuICByZXR1cm4gdXJsO1xufVxuZXhwb3J0cy51cmxHZW5lcmF0ZSA9IHVybEdlbmVyYXRlO1xuXG4vKipcbiAqIE5vcm1hbGl6ZXMgYSBwYXRoLCBvciB0aGUgcGF0aCBwb3J0aW9uIG9mIGEgVVJMOlxuICpcbiAqIC0gUmVwbGFjZXMgY29uc2VjdXRpdmUgc2xhc2hlcyB3aXRoIG9uZSBzbGFzaC5cbiAqIC0gUmVtb3ZlcyB1bm5lY2Vzc2FyeSAnLicgcGFydHMuXG4gKiAtIFJlbW92ZXMgdW5uZWNlc3NhcnkgJzxkaXI+Ly4uJyBwYXJ0cy5cbiAqXG4gKiBCYXNlZCBvbiBjb2RlIGluIHRoZSBOb2RlLmpzICdwYXRoJyBjb3JlIG1vZHVsZS5cbiAqXG4gKiBAcGFyYW0gYVBhdGggVGhlIHBhdGggb3IgdXJsIHRvIG5vcm1hbGl6ZS5cbiAqL1xuZnVuY3Rpb24gbm9ybWFsaXplKGFQYXRoKSB7XG4gIHZhciBwYXRoID0gYVBhdGg7XG4gIHZhciB1cmwgPSB1cmxQYXJzZShhUGF0aCk7XG4gIGlmICh1cmwpIHtcbiAgICBpZiAoIXVybC5wYXRoKSB7XG4gICAgICByZXR1cm4gYVBhdGg7XG4gICAgfVxuICAgIHBhdGggPSB1cmwucGF0aDtcbiAgfVxuICB2YXIgaXNBYnNvbHV0ZSA9IGV4cG9ydHMuaXNBYnNvbHV0ZShwYXRoKTtcblxuICB2YXIgcGFydHMgPSBwYXRoLnNwbGl0KC9cXC8rLyk7XG4gIGZvciAodmFyIHBhcnQsIHVwID0gMCwgaSA9IHBhcnRzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgcGFydCA9IHBhcnRzW2ldO1xuICAgIGlmIChwYXJ0ID09PSAnLicpIHtcbiAgICAgIHBhcnRzLnNwbGljZShpLCAxKTtcbiAgICB9IGVsc2UgaWYgKHBhcnQgPT09ICcuLicpIHtcbiAgICAgIHVwKys7XG4gICAgfSBlbHNlIGlmICh1cCA+IDApIHtcbiAgICAgIGlmIChwYXJ0ID09PSAnJykge1xuICAgICAgICAvLyBUaGUgZmlyc3QgcGFydCBpcyBibGFuayBpZiB0aGUgcGF0aCBpcyBhYnNvbHV0ZS4gVHJ5aW5nIHRvIGdvXG4gICAgICAgIC8vIGFib3ZlIHRoZSByb290IGlzIGEgbm8tb3AuIFRoZXJlZm9yZSB3ZSBjYW4gcmVtb3ZlIGFsbCAnLi4nIHBhcnRzXG4gICAgICAgIC8vIGRpcmVjdGx5IGFmdGVyIHRoZSByb290LlxuICAgICAgICBwYXJ0cy5zcGxpY2UoaSArIDEsIHVwKTtcbiAgICAgICAgdXAgPSAwO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcGFydHMuc3BsaWNlKGksIDIpO1xuICAgICAgICB1cC0tO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBwYXRoID0gcGFydHMuam9pbignLycpO1xuXG4gIGlmIChwYXRoID09PSAnJykge1xuICAgIHBhdGggPSBpc0Fic29sdXRlID8gJy8nIDogJy4nO1xuICB9XG5cbiAgaWYgKHVybCkge1xuICAgIHVybC5wYXRoID0gcGF0aDtcbiAgICByZXR1cm4gdXJsR2VuZXJhdGUodXJsKTtcbiAgfVxuICByZXR1cm4gcGF0aDtcbn1cbmV4cG9ydHMubm9ybWFsaXplID0gbm9ybWFsaXplO1xuXG4vKipcbiAqIEpvaW5zIHR3byBwYXRocy9VUkxzLlxuICpcbiAqIEBwYXJhbSBhUm9vdCBUaGUgcm9vdCBwYXRoIG9yIFVSTC5cbiAqIEBwYXJhbSBhUGF0aCBUaGUgcGF0aCBvciBVUkwgdG8gYmUgam9pbmVkIHdpdGggdGhlIHJvb3QuXG4gKlxuICogLSBJZiBhUGF0aCBpcyBhIFVSTCBvciBhIGRhdGEgVVJJLCBhUGF0aCBpcyByZXR1cm5lZCwgdW5sZXNzIGFQYXRoIGlzIGFcbiAqICAgc2NoZW1lLXJlbGF0aXZlIFVSTDogVGhlbiB0aGUgc2NoZW1lIG9mIGFSb290LCBpZiBhbnksIGlzIHByZXBlbmRlZFxuICogICBmaXJzdC5cbiAqIC0gT3RoZXJ3aXNlIGFQYXRoIGlzIGEgcGF0aC4gSWYgYVJvb3QgaXMgYSBVUkwsIHRoZW4gaXRzIHBhdGggcG9ydGlvblxuICogICBpcyB1cGRhdGVkIHdpdGggdGhlIHJlc3VsdCBhbmQgYVJvb3QgaXMgcmV0dXJuZWQuIE90aGVyd2lzZSB0aGUgcmVzdWx0XG4gKiAgIGlzIHJldHVybmVkLlxuICogICAtIElmIGFQYXRoIGlzIGFic29sdXRlLCB0aGUgcmVzdWx0IGlzIGFQYXRoLlxuICogICAtIE90aGVyd2lzZSB0aGUgdHdvIHBhdGhzIGFyZSBqb2luZWQgd2l0aCBhIHNsYXNoLlxuICogLSBKb2luaW5nIGZvciBleGFtcGxlICdodHRwOi8vJyBhbmQgJ3d3dy5leGFtcGxlLmNvbScgaXMgYWxzbyBzdXBwb3J0ZWQuXG4gKi9cbmZ1bmN0aW9uIGpvaW4oYVJvb3QsIGFQYXRoKSB7XG4gIGlmIChhUm9vdCA9PT0gXCJcIikge1xuICAgIGFSb290ID0gXCIuXCI7XG4gIH1cbiAgaWYgKGFQYXRoID09PSBcIlwiKSB7XG4gICAgYVBhdGggPSBcIi5cIjtcbiAgfVxuICB2YXIgYVBhdGhVcmwgPSB1cmxQYXJzZShhUGF0aCk7XG4gIHZhciBhUm9vdFVybCA9IHVybFBhcnNlKGFSb290KTtcbiAgaWYgKGFSb290VXJsKSB7XG4gICAgYVJvb3QgPSBhUm9vdFVybC5wYXRoIHx8ICcvJztcbiAgfVxuXG4gIC8vIGBqb2luKGZvbywgJy8vd3d3LmV4YW1wbGUub3JnJylgXG4gIGlmIChhUGF0aFVybCAmJiAhYVBhdGhVcmwuc2NoZW1lKSB7XG4gICAgaWYgKGFSb290VXJsKSB7XG4gICAgICBhUGF0aFVybC5zY2hlbWUgPSBhUm9vdFVybC5zY2hlbWU7XG4gICAgfVxuICAgIHJldHVybiB1cmxHZW5lcmF0ZShhUGF0aFVybCk7XG4gIH1cblxuICBpZiAoYVBhdGhVcmwgfHwgYVBhdGgubWF0Y2goZGF0YVVybFJlZ2V4cCkpIHtcbiAgICByZXR1cm4gYVBhdGg7XG4gIH1cblxuICAvLyBgam9pbignaHR0cDovLycsICd3d3cuZXhhbXBsZS5jb20nKWBcbiAgaWYgKGFSb290VXJsICYmICFhUm9vdFVybC5ob3N0ICYmICFhUm9vdFVybC5wYXRoKSB7XG4gICAgYVJvb3RVcmwuaG9zdCA9IGFQYXRoO1xuICAgIHJldHVybiB1cmxHZW5lcmF0ZShhUm9vdFVybCk7XG4gIH1cblxuICB2YXIgam9pbmVkID0gYVBhdGguY2hhckF0KDApID09PSAnLydcbiAgICA/IGFQYXRoXG4gICAgOiBub3JtYWxpemUoYVJvb3QucmVwbGFjZSgvXFwvKyQvLCAnJykgKyAnLycgKyBhUGF0aCk7XG5cbiAgaWYgKGFSb290VXJsKSB7XG4gICAgYVJvb3RVcmwucGF0aCA9IGpvaW5lZDtcbiAgICByZXR1cm4gdXJsR2VuZXJhdGUoYVJvb3RVcmwpO1xuICB9XG4gIHJldHVybiBqb2luZWQ7XG59XG5leHBvcnRzLmpvaW4gPSBqb2luO1xuXG5leHBvcnRzLmlzQWJzb2x1dGUgPSBmdW5jdGlvbiAoYVBhdGgpIHtcbiAgcmV0dXJuIGFQYXRoLmNoYXJBdCgwKSA9PT0gJy8nIHx8IHVybFJlZ2V4cC50ZXN0KGFQYXRoKTtcbn07XG5cbi8qKlxuICogTWFrZSBhIHBhdGggcmVsYXRpdmUgdG8gYSBVUkwgb3IgYW5vdGhlciBwYXRoLlxuICpcbiAqIEBwYXJhbSBhUm9vdCBUaGUgcm9vdCBwYXRoIG9yIFVSTC5cbiAqIEBwYXJhbSBhUGF0aCBUaGUgcGF0aCBvciBVUkwgdG8gYmUgbWFkZSByZWxhdGl2ZSB0byBhUm9vdC5cbiAqL1xuZnVuY3Rpb24gcmVsYXRpdmUoYVJvb3QsIGFQYXRoKSB7XG4gIGlmIChhUm9vdCA9PT0gXCJcIikge1xuICAgIGFSb290ID0gXCIuXCI7XG4gIH1cblxuICBhUm9vdCA9IGFSb290LnJlcGxhY2UoL1xcLyQvLCAnJyk7XG5cbiAgLy8gSXQgaXMgcG9zc2libGUgZm9yIHRoZSBwYXRoIHRvIGJlIGFib3ZlIHRoZSByb290LiBJbiB0aGlzIGNhc2UsIHNpbXBseVxuICAvLyBjaGVja2luZyB3aGV0aGVyIHRoZSByb290IGlzIGEgcHJlZml4IG9mIHRoZSBwYXRoIHdvbid0IHdvcmsuIEluc3RlYWQsIHdlXG4gIC8vIG5lZWQgdG8gcmVtb3ZlIGNvbXBvbmVudHMgZnJvbSB0aGUgcm9vdCBvbmUgYnkgb25lLCB1bnRpbCBlaXRoZXIgd2UgZmluZFxuICAvLyBhIHByZWZpeCB0aGF0IGZpdHMsIG9yIHdlIHJ1biBvdXQgb2YgY29tcG9uZW50cyB0byByZW1vdmUuXG4gIHZhciBsZXZlbCA9IDA7XG4gIHdoaWxlIChhUGF0aC5pbmRleE9mKGFSb290ICsgJy8nKSAhPT0gMCkge1xuICAgIHZhciBpbmRleCA9IGFSb290Lmxhc3RJbmRleE9mKFwiL1wiKTtcbiAgICBpZiAoaW5kZXggPCAwKSB7XG4gICAgICByZXR1cm4gYVBhdGg7XG4gICAgfVxuXG4gICAgLy8gSWYgdGhlIG9ubHkgcGFydCBvZiB0aGUgcm9vdCB0aGF0IGlzIGxlZnQgaXMgdGhlIHNjaGVtZSAoaS5lLiBodHRwOi8vLFxuICAgIC8vIGZpbGU6Ly8vLCBldGMuKSwgb25lIG9yIG1vcmUgc2xhc2hlcyAoLyksIG9yIHNpbXBseSBub3RoaW5nIGF0IGFsbCwgd2VcbiAgICAvLyBoYXZlIGV4aGF1c3RlZCBhbGwgY29tcG9uZW50cywgc28gdGhlIHBhdGggaXMgbm90IHJlbGF0aXZlIHRvIHRoZSByb290LlxuICAgIGFSb290ID0gYVJvb3Quc2xpY2UoMCwgaW5kZXgpO1xuICAgIGlmIChhUm9vdC5tYXRjaCgvXihbXlxcL10rOlxcLyk/XFwvKiQvKSkge1xuICAgICAgcmV0dXJuIGFQYXRoO1xuICAgIH1cblxuICAgICsrbGV2ZWw7XG4gIH1cblxuICAvLyBNYWtlIHN1cmUgd2UgYWRkIGEgXCIuLi9cIiBmb3IgZWFjaCBjb21wb25lbnQgd2UgcmVtb3ZlZCBmcm9tIHRoZSByb290LlxuICByZXR1cm4gQXJyYXkobGV2ZWwgKyAxKS5qb2luKFwiLi4vXCIpICsgYVBhdGguc3Vic3RyKGFSb290Lmxlbmd0aCArIDEpO1xufVxuZXhwb3J0cy5yZWxhdGl2ZSA9IHJlbGF0aXZlO1xuXG52YXIgc3VwcG9ydHNOdWxsUHJvdG8gPSAoZnVuY3Rpb24gKCkge1xuICB2YXIgb2JqID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgcmV0dXJuICEoJ19fcHJvdG9fXycgaW4gb2JqKTtcbn0oKSk7XG5cbmZ1bmN0aW9uIGlkZW50aXR5IChzKSB7XG4gIHJldHVybiBzO1xufVxuXG4vKipcbiAqIEJlY2F1c2UgYmVoYXZpb3IgZ29lcyB3YWNreSB3aGVuIHlvdSBzZXQgYF9fcHJvdG9fX2Agb24gb2JqZWN0cywgd2VcbiAqIGhhdmUgdG8gcHJlZml4IGFsbCB0aGUgc3RyaW5ncyBpbiBvdXIgc2V0IHdpdGggYW4gYXJiaXRyYXJ5IGNoYXJhY3Rlci5cbiAqXG4gKiBTZWUgaHR0cHM6Ly9naXRodWIuY29tL21vemlsbGEvc291cmNlLW1hcC9wdWxsLzMxIGFuZFxuICogaHR0cHM6Ly9naXRodWIuY29tL21vemlsbGEvc291cmNlLW1hcC9pc3N1ZXMvMzBcbiAqXG4gKiBAcGFyYW0gU3RyaW5nIGFTdHJcbiAqL1xuZnVuY3Rpb24gdG9TZXRTdHJpbmcoYVN0cikge1xuICBpZiAoaXNQcm90b1N0cmluZyhhU3RyKSkge1xuICAgIHJldHVybiAnJCcgKyBhU3RyO1xuICB9XG5cbiAgcmV0dXJuIGFTdHI7XG59XG5leHBvcnRzLnRvU2V0U3RyaW5nID0gc3VwcG9ydHNOdWxsUHJvdG8gPyBpZGVudGl0eSA6IHRvU2V0U3RyaW5nO1xuXG5mdW5jdGlvbiBmcm9tU2V0U3RyaW5nKGFTdHIpIHtcbiAgaWYgKGlzUHJvdG9TdHJpbmcoYVN0cikpIHtcbiAgICByZXR1cm4gYVN0ci5zbGljZSgxKTtcbiAgfVxuXG4gIHJldHVybiBhU3RyO1xufVxuZXhwb3J0cy5mcm9tU2V0U3RyaW5nID0gc3VwcG9ydHNOdWxsUHJvdG8gPyBpZGVudGl0eSA6IGZyb21TZXRTdHJpbmc7XG5cbmZ1bmN0aW9uIGlzUHJvdG9TdHJpbmcocykge1xuICBpZiAoIXMpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICB2YXIgbGVuZ3RoID0gcy5sZW5ndGg7XG5cbiAgaWYgKGxlbmd0aCA8IDkgLyogXCJfX3Byb3RvX19cIi5sZW5ndGggKi8pIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBpZiAocy5jaGFyQ29kZUF0KGxlbmd0aCAtIDEpICE9PSA5NSAgLyogJ18nICovIHx8XG4gICAgICBzLmNoYXJDb2RlQXQobGVuZ3RoIC0gMikgIT09IDk1ICAvKiAnXycgKi8gfHxcbiAgICAgIHMuY2hhckNvZGVBdChsZW5ndGggLSAzKSAhPT0gMTExIC8qICdvJyAqLyB8fFxuICAgICAgcy5jaGFyQ29kZUF0KGxlbmd0aCAtIDQpICE9PSAxMTYgLyogJ3QnICovIHx8XG4gICAgICBzLmNoYXJDb2RlQXQobGVuZ3RoIC0gNSkgIT09IDExMSAvKiAnbycgKi8gfHxcbiAgICAgIHMuY2hhckNvZGVBdChsZW5ndGggLSA2KSAhPT0gMTE0IC8qICdyJyAqLyB8fFxuICAgICAgcy5jaGFyQ29kZUF0KGxlbmd0aCAtIDcpICE9PSAxMTIgLyogJ3AnICovIHx8XG4gICAgICBzLmNoYXJDb2RlQXQobGVuZ3RoIC0gOCkgIT09IDk1ICAvKiAnXycgKi8gfHxcbiAgICAgIHMuY2hhckNvZGVBdChsZW5ndGggLSA5KSAhPT0gOTUgIC8qICdfJyAqLykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGZvciAodmFyIGkgPSBsZW5ndGggLSAxMDsgaSA+PSAwOyBpLS0pIHtcbiAgICBpZiAocy5jaGFyQ29kZUF0KGkpICE9PSAzNiAvKiAnJCcgKi8pIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn1cblxuLyoqXG4gKiBDb21wYXJhdG9yIGJldHdlZW4gdHdvIG1hcHBpbmdzIHdoZXJlIHRoZSBvcmlnaW5hbCBwb3NpdGlvbnMgYXJlIGNvbXBhcmVkLlxuICpcbiAqIE9wdGlvbmFsbHkgcGFzcyBpbiBgdHJ1ZWAgYXMgYG9ubHlDb21wYXJlR2VuZXJhdGVkYCB0byBjb25zaWRlciB0d29cbiAqIG1hcHBpbmdzIHdpdGggdGhlIHNhbWUgb3JpZ2luYWwgc291cmNlL2xpbmUvY29sdW1uLCBidXQgZGlmZmVyZW50IGdlbmVyYXRlZFxuICogbGluZSBhbmQgY29sdW1uIHRoZSBzYW1lLiBVc2VmdWwgd2hlbiBzZWFyY2hpbmcgZm9yIGEgbWFwcGluZyB3aXRoIGFcbiAqIHN0dWJiZWQgb3V0IG1hcHBpbmcuXG4gKi9cbmZ1bmN0aW9uIGNvbXBhcmVCeU9yaWdpbmFsUG9zaXRpb25zKG1hcHBpbmdBLCBtYXBwaW5nQiwgb25seUNvbXBhcmVPcmlnaW5hbCkge1xuICB2YXIgY21wID0gc3RyY21wKG1hcHBpbmdBLnNvdXJjZSwgbWFwcGluZ0Iuc291cmNlKTtcbiAgaWYgKGNtcCAhPT0gMCkge1xuICAgIHJldHVybiBjbXA7XG4gIH1cblxuICBjbXAgPSBtYXBwaW5nQS5vcmlnaW5hbExpbmUgLSBtYXBwaW5nQi5vcmlnaW5hbExpbmU7XG4gIGlmIChjbXAgIT09IDApIHtcbiAgICByZXR1cm4gY21wO1xuICB9XG5cbiAgY21wID0gbWFwcGluZ0Eub3JpZ2luYWxDb2x1bW4gLSBtYXBwaW5nQi5vcmlnaW5hbENvbHVtbjtcbiAgaWYgKGNtcCAhPT0gMCB8fCBvbmx5Q29tcGFyZU9yaWdpbmFsKSB7XG4gICAgcmV0dXJuIGNtcDtcbiAgfVxuXG4gIGNtcCA9IG1hcHBpbmdBLmdlbmVyYXRlZENvbHVtbiAtIG1hcHBpbmdCLmdlbmVyYXRlZENvbHVtbjtcbiAgaWYgKGNtcCAhPT0gMCkge1xuICAgIHJldHVybiBjbXA7XG4gIH1cblxuICBjbXAgPSBtYXBwaW5nQS5nZW5lcmF0ZWRMaW5lIC0gbWFwcGluZ0IuZ2VuZXJhdGVkTGluZTtcbiAgaWYgKGNtcCAhPT0gMCkge1xuICAgIHJldHVybiBjbXA7XG4gIH1cblxuICByZXR1cm4gc3RyY21wKG1hcHBpbmdBLm5hbWUsIG1hcHBpbmdCLm5hbWUpO1xufVxuZXhwb3J0cy5jb21wYXJlQnlPcmlnaW5hbFBvc2l0aW9ucyA9IGNvbXBhcmVCeU9yaWdpbmFsUG9zaXRpb25zO1xuXG4vKipcbiAqIENvbXBhcmF0b3IgYmV0d2VlbiB0d28gbWFwcGluZ3Mgd2l0aCBkZWZsYXRlZCBzb3VyY2UgYW5kIG5hbWUgaW5kaWNlcyB3aGVyZVxuICogdGhlIGdlbmVyYXRlZCBwb3NpdGlvbnMgYXJlIGNvbXBhcmVkLlxuICpcbiAqIE9wdGlvbmFsbHkgcGFzcyBpbiBgdHJ1ZWAgYXMgYG9ubHlDb21wYXJlR2VuZXJhdGVkYCB0byBjb25zaWRlciB0d29cbiAqIG1hcHBpbmdzIHdpdGggdGhlIHNhbWUgZ2VuZXJhdGVkIGxpbmUgYW5kIGNvbHVtbiwgYnV0IGRpZmZlcmVudFxuICogc291cmNlL25hbWUvb3JpZ2luYWwgbGluZSBhbmQgY29sdW1uIHRoZSBzYW1lLiBVc2VmdWwgd2hlbiBzZWFyY2hpbmcgZm9yIGFcbiAqIG1hcHBpbmcgd2l0aCBhIHN0dWJiZWQgb3V0IG1hcHBpbmcuXG4gKi9cbmZ1bmN0aW9uIGNvbXBhcmVCeUdlbmVyYXRlZFBvc2l0aW9uc0RlZmxhdGVkKG1hcHBpbmdBLCBtYXBwaW5nQiwgb25seUNvbXBhcmVHZW5lcmF0ZWQpIHtcbiAgdmFyIGNtcCA9IG1hcHBpbmdBLmdlbmVyYXRlZExpbmUgLSBtYXBwaW5nQi5nZW5lcmF0ZWRMaW5lO1xuICBpZiAoY21wICE9PSAwKSB7XG4gICAgcmV0dXJuIGNtcDtcbiAgfVxuXG4gIGNtcCA9IG1hcHBpbmdBLmdlbmVyYXRlZENvbHVtbiAtIG1hcHBpbmdCLmdlbmVyYXRlZENvbHVtbjtcbiAgaWYgKGNtcCAhPT0gMCB8fCBvbmx5Q29tcGFyZUdlbmVyYXRlZCkge1xuICAgIHJldHVybiBjbXA7XG4gIH1cblxuICBjbXAgPSBzdHJjbXAobWFwcGluZ0Euc291cmNlLCBtYXBwaW5nQi5zb3VyY2UpO1xuICBpZiAoY21wICE9PSAwKSB7XG4gICAgcmV0dXJuIGNtcDtcbiAgfVxuXG4gIGNtcCA9IG1hcHBpbmdBLm9yaWdpbmFsTGluZSAtIG1hcHBpbmdCLm9yaWdpbmFsTGluZTtcbiAgaWYgKGNtcCAhPT0gMCkge1xuICAgIHJldHVybiBjbXA7XG4gIH1cblxuICBjbXAgPSBtYXBwaW5nQS5vcmlnaW5hbENvbHVtbiAtIG1hcHBpbmdCLm9yaWdpbmFsQ29sdW1uO1xuICBpZiAoY21wICE9PSAwKSB7XG4gICAgcmV0dXJuIGNtcDtcbiAgfVxuXG4gIHJldHVybiBzdHJjbXAobWFwcGluZ0EubmFtZSwgbWFwcGluZ0IubmFtZSk7XG59XG5leHBvcnRzLmNvbXBhcmVCeUdlbmVyYXRlZFBvc2l0aW9uc0RlZmxhdGVkID0gY29tcGFyZUJ5R2VuZXJhdGVkUG9zaXRpb25zRGVmbGF0ZWQ7XG5cbmZ1bmN0aW9uIHN0cmNtcChhU3RyMSwgYVN0cjIpIHtcbiAgaWYgKGFTdHIxID09PSBhU3RyMikge1xuICAgIHJldHVybiAwO1xuICB9XG5cbiAgaWYgKGFTdHIxID09PSBudWxsKSB7XG4gICAgcmV0dXJuIDE7IC8vIGFTdHIyICE9PSBudWxsXG4gIH1cblxuICBpZiAoYVN0cjIgPT09IG51bGwpIHtcbiAgICByZXR1cm4gLTE7IC8vIGFTdHIxICE9PSBudWxsXG4gIH1cblxuICBpZiAoYVN0cjEgPiBhU3RyMikge1xuICAgIHJldHVybiAxO1xuICB9XG5cbiAgcmV0dXJuIC0xO1xufVxuXG4vKipcbiAqIENvbXBhcmF0b3IgYmV0d2VlbiB0d28gbWFwcGluZ3Mgd2l0aCBpbmZsYXRlZCBzb3VyY2UgYW5kIG5hbWUgc3RyaW5ncyB3aGVyZVxuICogdGhlIGdlbmVyYXRlZCBwb3NpdGlvbnMgYXJlIGNvbXBhcmVkLlxuICovXG5mdW5jdGlvbiBjb21wYXJlQnlHZW5lcmF0ZWRQb3NpdGlvbnNJbmZsYXRlZChtYXBwaW5nQSwgbWFwcGluZ0IpIHtcbiAgdmFyIGNtcCA9IG1hcHBpbmdBLmdlbmVyYXRlZExpbmUgLSBtYXBwaW5nQi5nZW5lcmF0ZWRMaW5lO1xuICBpZiAoY21wICE9PSAwKSB7XG4gICAgcmV0dXJuIGNtcDtcbiAgfVxuXG4gIGNtcCA9IG1hcHBpbmdBLmdlbmVyYXRlZENvbHVtbiAtIG1hcHBpbmdCLmdlbmVyYXRlZENvbHVtbjtcbiAgaWYgKGNtcCAhPT0gMCkge1xuICAgIHJldHVybiBjbXA7XG4gIH1cblxuICBjbXAgPSBzdHJjbXAobWFwcGluZ0Euc291cmNlLCBtYXBwaW5nQi5zb3VyY2UpO1xuICBpZiAoY21wICE9PSAwKSB7XG4gICAgcmV0dXJuIGNtcDtcbiAgfVxuXG4gIGNtcCA9IG1hcHBpbmdBLm9yaWdpbmFsTGluZSAtIG1hcHBpbmdCLm9yaWdpbmFsTGluZTtcbiAgaWYgKGNtcCAhPT0gMCkge1xuICAgIHJldHVybiBjbXA7XG4gIH1cblxuICBjbXAgPSBtYXBwaW5nQS5vcmlnaW5hbENvbHVtbiAtIG1hcHBpbmdCLm9yaWdpbmFsQ29sdW1uO1xuICBpZiAoY21wICE9PSAwKSB7XG4gICAgcmV0dXJuIGNtcDtcbiAgfVxuXG4gIHJldHVybiBzdHJjbXAobWFwcGluZ0EubmFtZSwgbWFwcGluZ0IubmFtZSk7XG59XG5leHBvcnRzLmNvbXBhcmVCeUdlbmVyYXRlZFBvc2l0aW9uc0luZmxhdGVkID0gY29tcGFyZUJ5R2VuZXJhdGVkUG9zaXRpb25zSW5mbGF0ZWQ7XG5cbi8qKlxuICogU3RyaXAgYW55IEpTT04gWFNTSSBhdm9pZGFuY2UgcHJlZml4IGZyb20gdGhlIHN0cmluZyAoYXMgZG9jdW1lbnRlZFxuICogaW4gdGhlIHNvdXJjZSBtYXBzIHNwZWNpZmljYXRpb24pLCBhbmQgdGhlbiBwYXJzZSB0aGUgc3RyaW5nIGFzXG4gKiBKU09OLlxuICovXG5mdW5jdGlvbiBwYXJzZVNvdXJjZU1hcElucHV0KHN0cikge1xuICByZXR1cm4gSlNPTi5wYXJzZShzdHIucmVwbGFjZSgvXlxcKV19J1teXFxuXSpcXG4vLCAnJykpO1xufVxuZXhwb3J0cy5wYXJzZVNvdXJjZU1hcElucHV0ID0gcGFyc2VTb3VyY2VNYXBJbnB1dDtcblxuLyoqXG4gKiBDb21wdXRlIHRoZSBVUkwgb2YgYSBzb3VyY2UgZ2l2ZW4gdGhlIHRoZSBzb3VyY2Ugcm9vdCwgdGhlIHNvdXJjZSdzXG4gKiBVUkwsIGFuZCB0aGUgc291cmNlIG1hcCdzIFVSTC5cbiAqL1xuZnVuY3Rpb24gY29tcHV0ZVNvdXJjZVVSTChzb3VyY2VSb290LCBzb3VyY2VVUkwsIHNvdXJjZU1hcFVSTCkge1xuICBzb3VyY2VVUkwgPSBzb3VyY2VVUkwgfHwgJyc7XG5cbiAgaWYgKHNvdXJjZVJvb3QpIHtcbiAgICAvLyBUaGlzIGZvbGxvd3Mgd2hhdCBDaHJvbWUgZG9lcy5cbiAgICBpZiAoc291cmNlUm9vdFtzb3VyY2VSb290Lmxlbmd0aCAtIDFdICE9PSAnLycgJiYgc291cmNlVVJMWzBdICE9PSAnLycpIHtcbiAgICAgIHNvdXJjZVJvb3QgKz0gJy8nO1xuICAgIH1cbiAgICAvLyBUaGUgc3BlYyBzYXlzOlxuICAgIC8vICAgTGluZSA0OiBBbiBvcHRpb25hbCBzb3VyY2Ugcm9vdCwgdXNlZnVsIGZvciByZWxvY2F0aW5nIHNvdXJjZVxuICAgIC8vICAgZmlsZXMgb24gYSBzZXJ2ZXIgb3IgcmVtb3ZpbmcgcmVwZWF0ZWQgdmFsdWVzIGluIHRoZVxuICAgIC8vICAg4oCcc291cmNlc+KAnSBlbnRyeS4gIFRoaXMgdmFsdWUgaXMgcHJlcGVuZGVkIHRvIHRoZSBpbmRpdmlkdWFsXG4gICAgLy8gICBlbnRyaWVzIGluIHRoZSDigJxzb3VyY2XigJ0gZmllbGQuXG4gICAgc291cmNlVVJMID0gc291cmNlUm9vdCArIHNvdXJjZVVSTDtcbiAgfVxuXG4gIC8vIEhpc3RvcmljYWxseSwgU291cmNlTWFwQ29uc3VtZXIgZGlkIG5vdCB0YWtlIHRoZSBzb3VyY2VNYXBVUkwgYXNcbiAgLy8gYSBwYXJhbWV0ZXIuICBUaGlzIG1vZGUgaXMgc3RpbGwgc29tZXdoYXQgc3VwcG9ydGVkLCB3aGljaCBpcyB3aHlcbiAgLy8gdGhpcyBjb2RlIGJsb2NrIGlzIGNvbmRpdGlvbmFsLiAgSG93ZXZlciwgaXQncyBwcmVmZXJhYmxlIHRvIHBhc3NcbiAgLy8gdGhlIHNvdXJjZSBtYXAgVVJMIHRvIFNvdXJjZU1hcENvbnN1bWVyLCBzbyB0aGF0IHRoaXMgZnVuY3Rpb25cbiAgLy8gY2FuIGltcGxlbWVudCB0aGUgc291cmNlIFVSTCByZXNvbHV0aW9uIGFsZ29yaXRobSBhcyBvdXRsaW5lZCBpblxuICAvLyB0aGUgc3BlYy4gIFRoaXMgYmxvY2sgaXMgYmFzaWNhbGx5IHRoZSBlcXVpdmFsZW50IG9mOlxuICAvLyAgICBuZXcgVVJMKHNvdXJjZVVSTCwgc291cmNlTWFwVVJMKS50b1N0cmluZygpXG4gIC8vIC4uLiBleGNlcHQgaXQgYXZvaWRzIHVzaW5nIFVSTCwgd2hpY2ggd2Fzbid0IGF2YWlsYWJsZSBpbiB0aGVcbiAgLy8gb2xkZXIgcmVsZWFzZXMgb2Ygbm9kZSBzdGlsbCBzdXBwb3J0ZWQgYnkgdGhpcyBsaWJyYXJ5LlxuICAvL1xuICAvLyBUaGUgc3BlYyBzYXlzOlxuICAvLyAgIElmIHRoZSBzb3VyY2VzIGFyZSBub3QgYWJzb2x1dGUgVVJMcyBhZnRlciBwcmVwZW5kaW5nIG9mIHRoZVxuICAvLyAgIOKAnHNvdXJjZVJvb3TigJ0sIHRoZSBzb3VyY2VzIGFyZSByZXNvbHZlZCByZWxhdGl2ZSB0byB0aGVcbiAgLy8gICBTb3VyY2VNYXAgKGxpa2UgcmVzb2x2aW5nIHNjcmlwdCBzcmMgaW4gYSBodG1sIGRvY3VtZW50KS5cbiAgaWYgKHNvdXJjZU1hcFVSTCkge1xuICAgIHZhciBwYXJzZWQgPSB1cmxQYXJzZShzb3VyY2VNYXBVUkwpO1xuICAgIGlmICghcGFyc2VkKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJzb3VyY2VNYXBVUkwgY291bGQgbm90IGJlIHBhcnNlZFwiKTtcbiAgICB9XG4gICAgaWYgKHBhcnNlZC5wYXRoKSB7XG4gICAgICAvLyBTdHJpcCB0aGUgbGFzdCBwYXRoIGNvbXBvbmVudCwgYnV0IGtlZXAgdGhlIFwiL1wiLlxuICAgICAgdmFyIGluZGV4ID0gcGFyc2VkLnBhdGgubGFzdEluZGV4T2YoJy8nKTtcbiAgICAgIGlmIChpbmRleCA+PSAwKSB7XG4gICAgICAgIHBhcnNlZC5wYXRoID0gcGFyc2VkLnBhdGguc3Vic3RyaW5nKDAsIGluZGV4ICsgMSk7XG4gICAgICB9XG4gICAgfVxuICAgIHNvdXJjZVVSTCA9IGpvaW4odXJsR2VuZXJhdGUocGFyc2VkKSwgc291cmNlVVJMKTtcbiAgfVxuXG4gIHJldHVybiBub3JtYWxpemUoc291cmNlVVJMKTtcbn1cbmV4cG9ydHMuY29tcHV0ZVNvdXJjZVVSTCA9IGNvbXB1dGVTb3VyY2VVUkw7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvZWxlY3Ryb24tdXBkYXRlci9ub2RlX21vZHVsZXMvc291cmNlLW1hcC9saWIvdXRpbC5qcyIsIid1c2Ugc3RyaWN0J1xuXG5jb25zdCB1ID0gcmVxdWlyZSgndW5pdmVyc2FsaWZ5JykuZnJvbUNhbGxiYWNrXG5jb25zdCByaW1yYWYgPSByZXF1aXJlKCcuL3JpbXJhZicpXG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICByZW1vdmU6IHUocmltcmFmKSxcbiAgcmVtb3ZlU3luYzogcmltcmFmLnN5bmNcbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9lbGVjdHJvbi11cGRhdGVyL25vZGVfbW9kdWxlcy9mcy1leHRyYS9saWIvcmVtb3ZlL2luZGV4LmpzIiwiLy8gSlMtWUFNTCdzIGRlZmF1bHQgc2NoZW1hIGZvciBgbG9hZGAgZnVuY3Rpb24uXG4vLyBJdCBpcyBub3QgZGVzY3JpYmVkIGluIHRoZSBZQU1MIHNwZWNpZmljYXRpb24uXG4vL1xuLy8gVGhpcyBzY2hlbWEgaXMgYmFzZWQgb24gSlMtWUFNTCdzIGRlZmF1bHQgc2FmZSBzY2hlbWEgYW5kIGluY2x1ZGVzXG4vLyBKYXZhU2NyaXB0LXNwZWNpZmljIHR5cGVzOiAhIWpzL3VuZGVmaW5lZCwgISFqcy9yZWdleHAgYW5kICEhanMvZnVuY3Rpb24uXG4vL1xuLy8gQWxzbyB0aGlzIHNjaGVtYSBpcyB1c2VkIGFzIGRlZmF1bHQgYmFzZSBzY2hlbWEgYXQgYFNjaGVtYS5jcmVhdGVgIGZ1bmN0aW9uLlxuXG5cbid1c2Ugc3RyaWN0JztcblxuXG52YXIgU2NoZW1hID0gcmVxdWlyZSgnLi4vc2NoZW1hJyk7XG5cblxubW9kdWxlLmV4cG9ydHMgPSBTY2hlbWEuREVGQVVMVCA9IG5ldyBTY2hlbWEoe1xuICBpbmNsdWRlOiBbXG4gICAgcmVxdWlyZSgnLi9kZWZhdWx0X3NhZmUnKVxuICBdLFxuICBleHBsaWNpdDogW1xuICAgIHJlcXVpcmUoJy4uL3R5cGUvanMvdW5kZWZpbmVkJyksXG4gICAgcmVxdWlyZSgnLi4vdHlwZS9qcy9yZWdleHAnKSxcbiAgICByZXF1aXJlKCcuLi90eXBlL2pzL2Z1bmN0aW9uJylcbiAgXVxufSk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvanMteWFtbC9saWIvanMteWFtbC9zY2hlbWEvZGVmYXVsdF9mdWxsLmpzIiwiJ3VzZSBzdHJpY3QnO1xuY29uc3QgZ2V0RnJvbUVudiA9IHBhcnNlSW50KHByb2Nlc3MuZW52LkVMRUNUUk9OX0lTX0RFViwgMTApID09PSAxO1xuY29uc3QgaXNFbnZTZXQgPSAnRUxFQ1RST05fSVNfREVWJyBpbiBwcm9jZXNzLmVudjtcblxubW9kdWxlLmV4cG9ydHMgPSBpc0VudlNldCA/IGdldEZyb21FbnYgOiAocHJvY2Vzcy5kZWZhdWx0QXBwIHx8IC9ub2RlX21vZHVsZXNbXFxcXC9dZWxlY3Ryb25bXFxcXC9dLy50ZXN0KHByb2Nlc3MuZXhlY1BhdGgpKTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9lbGVjdHJvbi1pcy1kZXYvaW5kZXguanMiLCJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5Ob09wTG9nZ2VyID0gZXhwb3J0cy5BcHBVcGRhdGVyID0gdW5kZWZpbmVkO1xuXG52YXIgX2JsdWViaXJkTHN0O1xuXG5mdW5jdGlvbiBfbG9hZF9ibHVlYmlyZExzdCgpIHtcbiAgICByZXR1cm4gX2JsdWViaXJkTHN0ID0gcmVxdWlyZShcImJsdWViaXJkLWxzdFwiKTtcbn1cblxudmFyIF9ibHVlYmlyZExzdDI7XG5cbmZ1bmN0aW9uIF9sb2FkX2JsdWViaXJkTHN0MigpIHtcbiAgICByZXR1cm4gX2JsdWViaXJkTHN0MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcImJsdWViaXJkLWxzdFwiKSk7XG59XG5cbnZhciBfYnVpbGRlclV0aWxSdW50aW1lO1xuXG5mdW5jdGlvbiBfbG9hZF9idWlsZGVyVXRpbFJ1bnRpbWUoKSB7XG4gICAgcmV0dXJuIF9idWlsZGVyVXRpbFJ1bnRpbWUgPSByZXF1aXJlKFwiYnVpbGRlci11dGlsLXJ1bnRpbWVcIik7XG59XG5cbnZhciBfY3J5cHRvO1xuXG5mdW5jdGlvbiBfbG9hZF9jcnlwdG8oKSB7XG4gICAgcmV0dXJuIF9jcnlwdG8gPSByZXF1aXJlKFwiY3J5cHRvXCIpO1xufVxuXG52YXIgX2VsZWN0cm9uO1xuXG5mdW5jdGlvbiBfbG9hZF9lbGVjdHJvbigpIHtcbiAgICByZXR1cm4gX2VsZWN0cm9uID0gcmVxdWlyZShcImVsZWN0cm9uXCIpO1xufVxuXG52YXIgX2VsZWN0cm9uSXNEZXY7XG5cbmZ1bmN0aW9uIF9sb2FkX2VsZWN0cm9uSXNEZXYoKSB7XG4gICAgcmV0dXJuIF9lbGVjdHJvbklzRGV2ID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiZWxlY3Ryb24taXMtZGV2XCIpKTtcbn1cblxudmFyIF9ldmVudHM7XG5cbmZ1bmN0aW9uIF9sb2FkX2V2ZW50cygpIHtcbiAgICByZXR1cm4gX2V2ZW50cyA9IHJlcXVpcmUoXCJldmVudHNcIik7XG59XG5cbnZhciBfZnNFeHRyYVA7XG5cbmZ1bmN0aW9uIF9sb2FkX2ZzRXh0cmFQKCkge1xuICAgIHJldHVybiBfZnNFeHRyYVAgPSByZXF1aXJlKFwiZnMtZXh0cmEtcFwiKTtcbn1cblxudmFyIF9qc1lhbWw7XG5cbmZ1bmN0aW9uIF9sb2FkX2pzWWFtbCgpIHtcbiAgICByZXR1cm4gX2pzWWFtbCA9IHJlcXVpcmUoXCJqcy15YW1sXCIpO1xufVxuXG52YXIgX2xhenlWYWw7XG5cbmZ1bmN0aW9uIF9sb2FkX2xhenlWYWwoKSB7XG4gICAgcmV0dXJuIF9sYXp5VmFsID0gcmVxdWlyZShcImxhenktdmFsXCIpO1xufVxuXG52YXIgX3BhdGggPSBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChyZXF1aXJlKFwicGF0aFwiKSk7XG5cbnZhciBfc2VtdmVyO1xuXG5mdW5jdGlvbiBfbG9hZF9zZW12ZXIoKSB7XG4gICAgcmV0dXJuIF9zZW12ZXIgPSByZXF1aXJlKFwic2VtdmVyXCIpO1xufVxuXG5yZXF1aXJlKFwic291cmNlLW1hcC1zdXBwb3J0L3JlZ2lzdGVyXCIpO1xuXG52YXIgX2VsZWN0cm9uSHR0cEV4ZWN1dG9yO1xuXG5mdW5jdGlvbiBfbG9hZF9lbGVjdHJvbkh0dHBFeGVjdXRvcigpIHtcbiAgICByZXR1cm4gX2VsZWN0cm9uSHR0cEV4ZWN1dG9yID0gcmVxdWlyZShcIi4vZWxlY3Ryb25IdHRwRXhlY3V0b3JcIik7XG59XG5cbnZhciBfR2VuZXJpY1Byb3ZpZGVyO1xuXG5mdW5jdGlvbiBfbG9hZF9HZW5lcmljUHJvdmlkZXIoKSB7XG4gICAgcmV0dXJuIF9HZW5lcmljUHJvdmlkZXIgPSByZXF1aXJlKFwiLi9HZW5lcmljUHJvdmlkZXJcIik7XG59XG5cbnZhciBfbWFpbjtcblxuZnVuY3Rpb24gX2xvYWRfbWFpbigpIHtcbiAgICByZXR1cm4gX21haW4gPSByZXF1aXJlKFwiLi9tYWluXCIpO1xufVxuXG52YXIgX3Byb3ZpZGVyRmFjdG9yeTtcblxuZnVuY3Rpb24gX2xvYWRfcHJvdmlkZXJGYWN0b3J5KCkge1xuICAgIHJldHVybiBfcHJvdmlkZXJGYWN0b3J5ID0gcmVxdWlyZShcIi4vcHJvdmlkZXJGYWN0b3J5XCIpO1xufVxuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChvYmopIHsgaWYgKG9iaiAmJiBvYmouX19lc01vZHVsZSkgeyByZXR1cm4gb2JqOyB9IGVsc2UgeyB2YXIgbmV3T2JqID0ge307IGlmIChvYmogIT0gbnVsbCkgeyBmb3IgKHZhciBrZXkgaW4gb2JqKSB7IGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBrZXkpKSBuZXdPYmpba2V5XSA9IG9ialtrZXldOyB9IH0gbmV3T2JqLmRlZmF1bHQgPSBvYmo7IHJldHVybiBuZXdPYmo7IH0gfVxuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5jbGFzcyBBcHBVcGRhdGVyIGV4dGVuZHMgKF9ldmVudHMgfHwgX2xvYWRfZXZlbnRzKCkpLkV2ZW50RW1pdHRlciB7XG4gICAgY29uc3RydWN0b3Iob3B0aW9ucywgYXBwKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBXaGV0aGVyIHRvIGF1dG9tYXRpY2FsbHkgZG93bmxvYWQgYW4gdXBkYXRlIHdoZW4gaXQgaXMgZm91bmQuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmF1dG9Eb3dubG9hZCA9IHRydWU7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiAqR2l0SHViIHByb3ZpZGVyIG9ubHkuKiBXaGV0aGVyIHRvIGFsbG93IHVwZGF0ZSB0byBwcmUtcmVsZWFzZSB2ZXJzaW9ucy4gRGVmYXVsdHMgdG8gYHRydWVgIGlmIGFwcGxpY2F0aW9uIHZlcnNpb24gY29udGFpbnMgcHJlcmVsZWFzZSBjb21wb25lbnRzIChlLmcuIGAwLjEyLjEtYWxwaGEuMWAsIGhlcmUgYGFscGhhYCBpcyBhIHByZXJlbGVhc2UgY29tcG9uZW50KSwgb3RoZXJ3aXNlIGBmYWxzZWAuXG4gICAgICAgICAqXG4gICAgICAgICAqIElmIGB0cnVlYCwgZG93bmdyYWRlIHdpbGwgYmUgYWxsb3dlZCAoYGFsbG93RG93bmdyYWRlYCB3aWxsIGJlIHNldCB0byBgdHJ1ZWApLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5hbGxvd1ByZXJlbGVhc2UgPSBmYWxzZTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqICpHaXRIdWIgcHJvdmlkZXIgb25seS4qIEdldCBhbGwgcmVsZWFzZSBub3RlcyAoZnJvbSBjdXJyZW50IHZlcnNpb24gdG8gbGF0ZXN0KSwgbm90IGp1c3QgdGhlIGxhdGVzdC5cbiAgICAgICAgICogQGRlZmF1bHQgZmFsc2VcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuZnVsbENoYW5nZWxvZyA9IGZhbHNlO1xuICAgICAgICAvKipcbiAgICAgICAgICogV2hldGhlciB0byBhbGxvdyB2ZXJzaW9uIGRvd25ncmFkZSAod2hlbiBhIHVzZXIgZnJvbSB0aGUgYmV0YSBjaGFubmVsIHdhbnRzIHRvIGdvIGJhY2sgdG8gdGhlIHN0YWJsZSBjaGFubmVsKS5cbiAgICAgICAgICogQGRlZmF1bHQgZmFsc2VcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuYWxsb3dEb3duZ3JhZGUgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5fY2hhbm5lbCA9IG51bGw7XG4gICAgICAgIHRoaXMuX2xvZ2dlciA9IGNvbnNvbGU7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBGb3IgdHlwZSBzYWZldHkgeW91IGNhbiB1c2Ugc2lnbmFscywgZS5nLiBgYXV0b1VwZGF0ZXIuc2lnbmFscy51cGRhdGVEb3dubG9hZGVkKCgpID0+IHt9KWAgaW5zdGVhZCBvZiBgYXV0b1VwZGF0ZXIub24oJ3VwZGF0ZS1hdmFpbGFibGUnLCAoKSA9PiB7fSlgXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnNpZ25hbHMgPSBuZXcgKF9tYWluIHx8IF9sb2FkX21haW4oKSkuVXBkYXRlclNpZ25hbCh0aGlzKTtcbiAgICAgICAgdGhpcy51cGRhdGVBdmFpbGFibGUgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5zdGFnaW5nVXNlcklkUHJvbWlzZSA9IG5ldyAoX2xhenlWYWwgfHwgX2xvYWRfbGF6eVZhbCgpKS5MYXp5KCgpID0+IHRoaXMuZ2V0T3JDcmVhdGVTdGFnaW5nVXNlcklkKCkpO1xuICAgICAgICAvLyBwdWJsaWMsIGFsbG93IHRvIHJlYWQgb2xkIGNvbmZpZyBmb3IgYW55b25lXG4gICAgICAgIHRoaXMuY29uZmlnT25EaXNrID0gbmV3IChfbGF6eVZhbCB8fCBfbG9hZF9sYXp5VmFsKCkpLkxhenkoKCkgPT4gdGhpcy5sb2FkVXBkYXRlQ29uZmlnKCkpO1xuICAgICAgICB0aGlzLm9uKFwiZXJyb3JcIiwgZXJyb3IgPT4ge1xuICAgICAgICAgICAgdGhpcy5fbG9nZ2VyLmVycm9yKGBFcnJvcjogJHtlcnJvci5zdGFjayB8fCBlcnJvci5tZXNzYWdlfWApO1xuICAgICAgICB9KTtcbiAgICAgICAgaWYgKGFwcCAhPSBudWxsIHx8IGdsb2JhbC5fX3Rlc3RfYXBwICE9IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuYXBwID0gYXBwIHx8IGdsb2JhbC5fX3Rlc3RfYXBwO1xuICAgICAgICAgICAgdGhpcy51bnRpbEFwcFJlYWR5ID0gKF9ibHVlYmlyZExzdDIgfHwgX2xvYWRfYmx1ZWJpcmRMc3QyKCkpLmRlZmF1bHQucmVzb2x2ZSgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5hcHAgPSByZXF1aXJlKFwiZWxlY3Ryb25cIikuYXBwO1xuICAgICAgICAgICAgdGhpcy5odHRwRXhlY3V0b3IgPSBuZXcgKF9lbGVjdHJvbkh0dHBFeGVjdXRvciB8fCBfbG9hZF9lbGVjdHJvbkh0dHBFeGVjdXRvcigpKS5FbGVjdHJvbkh0dHBFeGVjdXRvcigoYXV0aEluZm8sIGNhbGxiYWNrKSA9PiB0aGlzLmVtaXQoXCJsb2dpblwiLCBhdXRoSW5mbywgY2FsbGJhY2spKTtcbiAgICAgICAgICAgIHRoaXMudW50aWxBcHBSZWFkeSA9IG5ldyAoX2JsdWViaXJkTHN0MiB8fCBfbG9hZF9ibHVlYmlyZExzdDIoKSkuZGVmYXVsdChyZXNvbHZlID0+IHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5hcHAuaXNSZWFkeSgpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmUoKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmFwcC5vbihcInJlYWR5XCIsIHJlc29sdmUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGN1cnJlbnRWZXJzaW9uU3RyaW5nID0gdGhpcy5hcHAuZ2V0VmVyc2lvbigpO1xuICAgICAgICBjb25zdCBjdXJyZW50VmVyc2lvbiA9ICgwLCAoX3NlbXZlciB8fCBfbG9hZF9zZW12ZXIoKSkudmFsaWQpKGN1cnJlbnRWZXJzaW9uU3RyaW5nKTtcbiAgICAgICAgaWYgKGN1cnJlbnRWZXJzaW9uID09IG51bGwpIHtcbiAgICAgICAgICAgIHRocm93ICgwLCAoX2J1aWxkZXJVdGlsUnVudGltZSB8fCBfbG9hZF9idWlsZGVyVXRpbFJ1bnRpbWUoKSkubmV3RXJyb3IpKGBBcHAgdmVyc2lvbiBpcyBub3QgYSB2YWxpZCBzZW12ZXIgdmVyc2lvbjogXCIke2N1cnJlbnRWZXJzaW9uU3RyaW5nfWAsIFwiRVJSX1VQREFURVJfSU5WQUxJRF9WRVJTSU9OXCIpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuY3VycmVudFZlcnNpb24gPSBjdXJyZW50VmVyc2lvbjtcbiAgICAgICAgdGhpcy5hbGxvd1ByZXJlbGVhc2UgPSBoYXNQcmVyZWxlYXNlQ29tcG9uZW50cyh0aGlzLmN1cnJlbnRWZXJzaW9uKTtcbiAgICAgICAgaWYgKG9wdGlvbnMgIT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5zZXRGZWVkVVJMKG9wdGlvbnMpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgdXBkYXRlIGNoYW5uZWwuIE5vdCBhcHBsaWNhYmxlIGZvciBHaXRIdWIuIERvZXNuJ3QgcmV0dXJuIGBjaGFubmVsYCBmcm9tIHRoZSB1cGRhdGUgY29uZmlndXJhdGlvbiwgb25seSBpZiB3YXMgcHJldmlvdXNseSBzZXQuXG4gICAgICovXG4gICAgZ2V0IGNoYW5uZWwoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9jaGFubmVsO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXQgdGhlIHVwZGF0ZSBjaGFubmVsLiBOb3QgYXBwbGljYWJsZSBmb3IgR2l0SHViLiBPdmVycmlkZXMgYGNoYW5uZWxgIGluIHRoZSB1cGRhdGUgY29uZmlndXJhdGlvbi5cbiAgICAgKlxuICAgICAqIGBhbGxvd0Rvd25ncmFkZWAgd2lsbCBiZSBhdXRvbWF0aWNhbGx5IHNldCB0byBgdHJ1ZWAuIElmIHRoaXMgYmVoYXZpb3IgaXMgbm90IHN1aXRhYmxlIGZvciB5b3UsIHNpbXBsZSBzZXQgYGFsbG93RG93bmdyYWRlYCBleHBsaWNpdGx5IGFmdGVyLlxuICAgICAqL1xuICAgIHNldCBjaGFubmVsKHZhbHVlKSB7XG4gICAgICAgIGlmICh0aGlzLl9jaGFubmVsICE9IG51bGwpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgIT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyAoMCwgKF9idWlsZGVyVXRpbFJ1bnRpbWUgfHwgX2xvYWRfYnVpbGRlclV0aWxSdW50aW1lKCkpLm5ld0Vycm9yKShgQ2hhbm5lbCBtdXN0IGJlIGEgc3RyaW5nLCBidXQgZ290OiAke3ZhbHVlfWAsIFwiRVJSX1VQREFURVJfSU5WQUxJRF9DSEFOTkVMXCIpO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh2YWx1ZS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICB0aHJvdyAoMCwgKF9idWlsZGVyVXRpbFJ1bnRpbWUgfHwgX2xvYWRfYnVpbGRlclV0aWxSdW50aW1lKCkpLm5ld0Vycm9yKShgQ2hhbm5lbCBtdXN0IGJlIG5vdCBhbiBlbXB0eSBzdHJpbmdgLCBcIkVSUl9VUERBVEVSX0lOVkFMSURfQ0hBTk5FTFwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9jaGFubmVsID0gdmFsdWU7XG4gICAgICAgIHRoaXMuYWxsb3dEb3duZ3JhZGUgPSB0cnVlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUaGUgbG9nZ2VyLiBZb3UgY2FuIHBhc3MgW2VsZWN0cm9uLWxvZ10oaHR0cHM6Ly9naXRodWIuY29tL21lZ2FoZXJ0ei9lbGVjdHJvbi1sb2cpLCBbd2luc3Rvbl0oaHR0cHM6Ly9naXRodWIuY29tL3dpbnN0b25qcy93aW5zdG9uKSBvciBhbm90aGVyIGxvZ2dlciB3aXRoIHRoZSBmb2xsb3dpbmcgaW50ZXJmYWNlOiBgeyBpbmZvKCksIHdhcm4oKSwgZXJyb3IoKSB9YC5cbiAgICAgKiBTZXQgaXQgdG8gYG51bGxgIGlmIHlvdSB3b3VsZCBsaWtlIHRvIGRpc2FibGUgYSBsb2dnaW5nIGZlYXR1cmUuXG4gICAgICovXG4gICAgZ2V0IGxvZ2dlcigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2xvZ2dlcjtcbiAgICB9XG4gICAgc2V0IGxvZ2dlcih2YWx1ZSkge1xuICAgICAgICB0aGlzLl9sb2dnZXIgPSB2YWx1ZSA9PSBudWxsID8gbmV3IE5vT3BMb2dnZXIoKSA6IHZhbHVlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiB0ZXN0IG9ubHlcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHNldCB1cGRhdGVDb25maWdQYXRoKHZhbHVlKSB7XG4gICAgICAgIHRoaXMuY2xpZW50UHJvbWlzZSA9IG51bGw7XG4gICAgICAgIHRoaXMuX2FwcFVwZGF0ZUNvbmZpZ1BhdGggPSB2YWx1ZTtcbiAgICAgICAgdGhpcy5jb25maWdPbkRpc2sgPSBuZXcgKF9sYXp5VmFsIHx8IF9sb2FkX2xhenlWYWwoKSkuTGF6eSgoKSA9PiB0aGlzLmxvYWRVcGRhdGVDb25maWcoKSk7XG4gICAgfVxuICAgIGdldCBwcm92aWRlcigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2xpZW50UHJvbWlzZTtcbiAgICB9XG4gICAgLy9ub2luc3BlY3Rpb24gSlNNZXRob2RDYW5CZVN0YXRpYyxKU1VudXNlZEdsb2JhbFN5bWJvbHNcbiAgICBnZXRGZWVkVVJMKCkge1xuICAgICAgICByZXR1cm4gXCJEZXByZWNhdGVkLiBEbyBub3QgdXNlIGl0LlwiO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDb25maWd1cmUgdXBkYXRlIHByb3ZpZGVyLiBJZiB2YWx1ZSBpcyBgc3RyaW5nYCwgW0dlbmVyaWNTZXJ2ZXJPcHRpb25zXSgvY29uZmlndXJhdGlvbi9wdWJsaXNoLm1kI2dlbmVyaWNzZXJ2ZXJvcHRpb25zKSB3aWxsIGJlIHNldCB3aXRoIHZhbHVlIGFzIGB1cmxgLlxuICAgICAqIEBwYXJhbSBvcHRpb25zIElmIHlvdSB3YW50IHRvIG92ZXJyaWRlIGNvbmZpZ3VyYXRpb24gaW4gdGhlIGBhcHAtdXBkYXRlLnltbGAuXG4gICAgICovXG4gICAgc2V0RmVlZFVSTChvcHRpb25zKSB7XG4gICAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9lbGVjdHJvbi11c2VybGFuZC9lbGVjdHJvbi1idWlsZGVyL2lzc3Vlcy8xMTA1XG4gICAgICAgIGxldCBwcm92aWRlcjtcbiAgICAgICAgaWYgKHR5cGVvZiBvcHRpb25zID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICBwcm92aWRlciA9IG5ldyAoX0dlbmVyaWNQcm92aWRlciB8fCBfbG9hZF9HZW5lcmljUHJvdmlkZXIoKSkuR2VuZXJpY1Byb3ZpZGVyKHsgcHJvdmlkZXI6IFwiZ2VuZXJpY1wiLCB1cmw6IG9wdGlvbnMgfSwgdGhpcyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBwcm92aWRlciA9ICgwLCAoX3Byb3ZpZGVyRmFjdG9yeSB8fCBfbG9hZF9wcm92aWRlckZhY3RvcnkoKSkuY3JlYXRlQ2xpZW50KShvcHRpb25zLCB0aGlzKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmNsaWVudFByb21pc2UgPSBQcm9taXNlLnJlc29sdmUocHJvdmlkZXIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBc2tzIHRoZSBzZXJ2ZXIgd2hldGhlciB0aGVyZSBpcyBhbiB1cGRhdGUuXG4gICAgICovXG4gICAgY2hlY2tGb3JVcGRhdGVzKCkge1xuICAgICAgICBsZXQgY2hlY2tGb3JVcGRhdGVzUHJvbWlzZSA9IHRoaXMuY2hlY2tGb3JVcGRhdGVzUHJvbWlzZTtcbiAgICAgICAgaWYgKGNoZWNrRm9yVXBkYXRlc1Byb21pc2UgIT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIGNoZWNrRm9yVXBkYXRlc1Byb21pc2U7XG4gICAgICAgIH1cbiAgICAgICAgY2hlY2tGb3JVcGRhdGVzUHJvbWlzZSA9IHRoaXMuX2NoZWNrRm9yVXBkYXRlcygpO1xuICAgICAgICB0aGlzLmNoZWNrRm9yVXBkYXRlc1Byb21pc2UgPSBjaGVja0ZvclVwZGF0ZXNQcm9taXNlO1xuICAgICAgICBjb25zdCBudWxsaXplUHJvbWlzZSA9ICgpID0+IHRoaXMuY2hlY2tGb3JVcGRhdGVzUHJvbWlzZSA9IG51bGw7XG4gICAgICAgIGNoZWNrRm9yVXBkYXRlc1Byb21pc2UudGhlbihudWxsaXplUHJvbWlzZSkuY2F0Y2gobnVsbGl6ZVByb21pc2UpO1xuICAgICAgICByZXR1cm4gY2hlY2tGb3JVcGRhdGVzUHJvbWlzZTtcbiAgICB9XG4gICAgY2hlY2tGb3JVcGRhdGVzQW5kTm90aWZ5KCkge1xuICAgICAgICBpZiAoKF9lbGVjdHJvbklzRGV2IHx8IF9sb2FkX2VsZWN0cm9uSXNEZXYoKSkuZGVmYXVsdCkge1xuICAgICAgICAgICAgcmV0dXJuIChfYmx1ZWJpcmRMc3QyIHx8IF9sb2FkX2JsdWViaXJkTHN0MigpKS5kZWZhdWx0LnJlc29sdmUobnVsbCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zaWduYWxzLnVwZGF0ZURvd25sb2FkZWQoaXQgPT4ge1xuICAgICAgICAgICAgbmV3IChfZWxlY3Ryb24gfHwgX2xvYWRfZWxlY3Ryb24oKSkuTm90aWZpY2F0aW9uKHtcbiAgICAgICAgICAgICAgICB0aXRsZTogXCJBIG5ldyB1cGRhdGUgaXMgcmVhZHkgdG8gaW5zdGFsbFwiLFxuICAgICAgICAgICAgICAgIGJvZHk6IGAke3RoaXMuYXBwLmdldE5hbWUoKX0gdmVyc2lvbiAke2l0LnZlcnNpb259IGlzIGRvd25sb2FkZWQgYW5kIHdpbGwgYmUgYXV0b21hdGljYWxseSBpbnN0YWxsZWQgb24gZXhpdGBcbiAgICAgICAgICAgIH0pLnNob3coKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB0aGlzLmNoZWNrRm9yVXBkYXRlcygpO1xuICAgIH1cbiAgICBpc1N0YWdpbmdNYXRjaCh1cGRhdGVJbmZvKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICAgICAgcmV0dXJuICgwLCAoX2JsdWViaXJkTHN0IHx8IF9sb2FkX2JsdWViaXJkTHN0KCkpLmNvcm91dGluZSkoZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGNvbnN0IHJhd1N0YWdpbmdQZXJjZW50YWdlID0gdXBkYXRlSW5mby5zdGFnaW5nUGVyY2VudGFnZTtcbiAgICAgICAgICAgIGxldCBzdGFnaW5nUGVyY2VudGFnZSA9IHJhd1N0YWdpbmdQZXJjZW50YWdlO1xuICAgICAgICAgICAgaWYgKHN0YWdpbmdQZXJjZW50YWdlID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHN0YWdpbmdQZXJjZW50YWdlID0gcGFyc2VJbnQoc3RhZ2luZ1BlcmNlbnRhZ2UsIDEwKTtcbiAgICAgICAgICAgIGlmIChpc05hTihzdGFnaW5nUGVyY2VudGFnZSkpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5fbG9nZ2VyLndhcm4oYFN0YWdpbmcgcGVyY2VudGFnZSBpcyBOYU46ICR7cmF3U3RhZ2luZ1BlcmNlbnRhZ2V9YCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBjb252ZXJ0IGZyb20gdXNlciAwLTEwMCB0byBpbnRlcm5hbCAwLTFcbiAgICAgICAgICAgIHN0YWdpbmdQZXJjZW50YWdlID0gc3RhZ2luZ1BlcmNlbnRhZ2UgLyAxMDA7XG4gICAgICAgICAgICBjb25zdCBzdGFnaW5nVXNlcklkID0geWllbGQgX3RoaXMuc3RhZ2luZ1VzZXJJZFByb21pc2UudmFsdWU7XG4gICAgICAgICAgICBjb25zdCB2YWwgPSAoX2J1aWxkZXJVdGlsUnVudGltZSB8fCBfbG9hZF9idWlsZGVyVXRpbFJ1bnRpbWUoKSkuVVVJRC5wYXJzZShzdGFnaW5nVXNlcklkKS5yZWFkVUludDMyQkUoMTIpO1xuICAgICAgICAgICAgY29uc3QgcGVyY2VudGFnZSA9IHZhbCAvIDB4RkZGRkZGRkY7XG4gICAgICAgICAgICBfdGhpcy5fbG9nZ2VyLmluZm8oYFN0YWdpbmcgcGVyY2VudGFnZTogJHtzdGFnaW5nUGVyY2VudGFnZX0sIHBlcmNlbnRhZ2U6ICR7cGVyY2VudGFnZX0sIHVzZXIgaWQ6ICR7c3RhZ2luZ1VzZXJJZH1gKTtcbiAgICAgICAgICAgIHJldHVybiBwZXJjZW50YWdlIDwgc3RhZ2luZ1BlcmNlbnRhZ2U7XG4gICAgICAgIH0pKCk7XG4gICAgfVxuICAgIF9jaGVja0ZvclVwZGF0ZXMoKSB7XG4gICAgICAgIHZhciBfdGhpczIgPSB0aGlzO1xuXG4gICAgICAgIHJldHVybiAoMCwgKF9ibHVlYmlyZExzdCB8fCBfbG9hZF9ibHVlYmlyZExzdCgpKS5jb3JvdXRpbmUpKGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHlpZWxkIF90aGlzMi51bnRpbEFwcFJlYWR5O1xuICAgICAgICAgICAgICAgIF90aGlzMi5fbG9nZ2VyLmluZm8oXCJDaGVja2luZyBmb3IgdXBkYXRlXCIpO1xuICAgICAgICAgICAgICAgIF90aGlzMi5lbWl0KFwiY2hlY2tpbmctZm9yLXVwZGF0ZVwiKTtcbiAgICAgICAgICAgICAgICByZXR1cm4geWllbGQgX3RoaXMyLmRvQ2hlY2tGb3JVcGRhdGVzKCk7XG4gICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMyLmVtaXQoXCJlcnJvclwiLCBlLCBgQ2Fubm90IGNoZWNrIGZvciB1cGRhdGVzOiAkeyhlLnN0YWNrIHx8IGUpLnRvU3RyaW5nKCl9YCk7XG4gICAgICAgICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSkoKTtcbiAgICB9XG4gICAgY29tcHV0ZUZpbmFsSGVhZGVycyhoZWFkZXJzKSB7XG4gICAgICAgIGlmICh0aGlzLnJlcXVlc3RIZWFkZXJzICE9IG51bGwpIHtcbiAgICAgICAgICAgIE9iamVjdC5hc3NpZ24oaGVhZGVycywgdGhpcy5yZXF1ZXN0SGVhZGVycyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGhlYWRlcnM7XG4gICAgfVxuICAgIGRvQ2hlY2tGb3JVcGRhdGVzKCkge1xuICAgICAgICB2YXIgX3RoaXMzID0gdGhpcztcblxuICAgICAgICByZXR1cm4gKDAsIChfYmx1ZWJpcmRMc3QgfHwgX2xvYWRfYmx1ZWJpcmRMc3QoKSkuY29yb3V0aW5lKShmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgaWYgKF90aGlzMy5jbGllbnRQcm9taXNlID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBfdGhpczMuY2xpZW50UHJvbWlzZSA9IF90aGlzMy5jb25maWdPbkRpc2sudmFsdWUudGhlbihmdW5jdGlvbiAoaXQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICgwLCAoX3Byb3ZpZGVyRmFjdG9yeSB8fCBfbG9hZF9wcm92aWRlckZhY3RvcnkoKSkuY3JlYXRlQ2xpZW50KShpdCwgX3RoaXMzKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGNsaWVudCA9IHlpZWxkIF90aGlzMy5jbGllbnRQcm9taXNlO1xuICAgICAgICAgICAgY29uc3Qgc3RhZ2luZ1VzZXJJZCA9IHlpZWxkIF90aGlzMy5zdGFnaW5nVXNlcklkUHJvbWlzZS52YWx1ZTtcbiAgICAgICAgICAgIGNsaWVudC5zZXRSZXF1ZXN0SGVhZGVycyhfdGhpczMuY29tcHV0ZUZpbmFsSGVhZGVycyh7IFwiWC1Vc2VyLVN0YWdpbmctSWRcIjogc3RhZ2luZ1VzZXJJZCB9KSk7XG4gICAgICAgICAgICBjb25zdCB1cGRhdGVJbmZvID0geWllbGQgY2xpZW50LmdldExhdGVzdFZlcnNpb24oKTtcbiAgICAgICAgICAgIGNvbnN0IGxhdGVzdFZlcnNpb24gPSAoMCwgKF9zZW12ZXIgfHwgX2xvYWRfc2VtdmVyKCkpLnZhbGlkKSh1cGRhdGVJbmZvLnZlcnNpb24pO1xuICAgICAgICAgICAgaWYgKGxhdGVzdFZlcnNpb24gPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRocm93ICgwLCAoX2J1aWxkZXJVdGlsUnVudGltZSB8fCBfbG9hZF9idWlsZGVyVXRpbFJ1bnRpbWUoKSkubmV3RXJyb3IpKGBMYXRlc3QgdmVyc2lvbiAoZnJvbSB1cGRhdGUgc2VydmVyKSBpcyBub3QgdmFsaWQgc2VtdmVyIHZlcnNpb246IFwiJHtsYXRlc3RWZXJzaW9ufWAsIFwiRVJSX1VQREFURVJfSU5WQUxJRF9WRVJTSU9OXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgaXNTdGFnaW5nTWF0Y2ggPSB5aWVsZCBfdGhpczMuaXNTdGFnaW5nTWF0Y2godXBkYXRlSW5mbyk7XG4gICAgICAgICAgICBpZiAoIWlzU3RhZ2luZ01hdGNoIHx8IChfdGhpczMuYWxsb3dEb3duZ3JhZGUgJiYgIWhhc1ByZXJlbGVhc2VDb21wb25lbnRzKGxhdGVzdFZlcnNpb24pID8gKDAsIChfc2VtdmVyIHx8IF9sb2FkX3NlbXZlcigpKS5lcSkobGF0ZXN0VmVyc2lvbiwgX3RoaXMzLmN1cnJlbnRWZXJzaW9uKSA6ICEoMCwgKF9zZW12ZXIgfHwgX2xvYWRfc2VtdmVyKCkpLmd0KShsYXRlc3RWZXJzaW9uLCBfdGhpczMuY3VycmVudFZlcnNpb24pKSkge1xuICAgICAgICAgICAgICAgIF90aGlzMy51cGRhdGVBdmFpbGFibGUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBfdGhpczMuX2xvZ2dlci5pbmZvKGBVcGRhdGUgZm9yIHZlcnNpb24gJHtfdGhpczMuY3VycmVudFZlcnNpb259IGlzIG5vdCBhdmFpbGFibGUgKGxhdGVzdCB2ZXJzaW9uOiAke3VwZGF0ZUluZm8udmVyc2lvbn0sIGRvd25ncmFkZSBpcyAke190aGlzMy5hbGxvd0Rvd25ncmFkZSA/IFwiYWxsb3dlZFwiIDogXCJkaXNhbGxvd2VkXCJ9LmApO1xuICAgICAgICAgICAgICAgIF90aGlzMy5lbWl0KFwidXBkYXRlLW5vdC1hdmFpbGFibGVcIiwgdXBkYXRlSW5mbyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgdmVyc2lvbkluZm86IHVwZGF0ZUluZm8sXG4gICAgICAgICAgICAgICAgICAgIHVwZGF0ZUluZm9cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgX3RoaXMzLnVwZGF0ZUF2YWlsYWJsZSA9IHRydWU7XG4gICAgICAgICAgICBfdGhpczMudXBkYXRlSW5mbyA9IHVwZGF0ZUluZm87XG4gICAgICAgICAgICBfdGhpczMub25VcGRhdGVBdmFpbGFibGUodXBkYXRlSW5mbyk7XG4gICAgICAgICAgICBjb25zdCBjYW5jZWxsYXRpb25Ub2tlbiA9IG5ldyAoX2J1aWxkZXJVdGlsUnVudGltZSB8fCBfbG9hZF9idWlsZGVyVXRpbFJ1bnRpbWUoKSkuQ2FuY2VsbGF0aW9uVG9rZW4oKTtcbiAgICAgICAgICAgIC8vbm9pbnNwZWN0aW9uIEVTNk1pc3NpbmdBd2FpdFxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB2ZXJzaW9uSW5mbzogdXBkYXRlSW5mbyxcbiAgICAgICAgICAgICAgICB1cGRhdGVJbmZvLFxuICAgICAgICAgICAgICAgIGNhbmNlbGxhdGlvblRva2VuLFxuICAgICAgICAgICAgICAgIGRvd25sb2FkUHJvbWlzZTogX3RoaXMzLmF1dG9Eb3dubG9hZCA/IF90aGlzMy5kb3dubG9hZFVwZGF0ZShjYW5jZWxsYXRpb25Ub2tlbikgOiBudWxsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9KSgpO1xuICAgIH1cbiAgICBvblVwZGF0ZUF2YWlsYWJsZSh1cGRhdGVJbmZvKSB7XG4gICAgICAgIHRoaXMuX2xvZ2dlci5pbmZvKGBGb3VuZCB2ZXJzaW9uICR7dXBkYXRlSW5mby52ZXJzaW9ufSAodXJsOiAkeygwLCAoX2J1aWxkZXJVdGlsUnVudGltZSB8fCBfbG9hZF9idWlsZGVyVXRpbFJ1bnRpbWUoKSkuYXNBcnJheSkodXBkYXRlSW5mby5maWxlcykubWFwKGl0ID0+IGl0LnVybCkuam9pbihcIiwgXCIpfSlgKTtcbiAgICAgICAgdGhpcy5lbWl0KFwidXBkYXRlLWF2YWlsYWJsZVwiLCB1cGRhdGVJbmZvKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU3RhcnQgZG93bmxvYWRpbmcgdXBkYXRlIG1hbnVhbGx5LiBZb3UgY2FuIHVzZSB0aGlzIG1ldGhvZCBpZiBgYXV0b0Rvd25sb2FkYCBvcHRpb24gaXMgc2V0IHRvIGBmYWxzZWAuXG4gICAgICogQHJldHVybnMge1Byb21pc2U8c3RyaW5nPn0gUGF0aCB0byBkb3dubG9hZGVkIGZpbGUuXG4gICAgICovXG4gICAgZG93bmxvYWRVcGRhdGUoY2FuY2VsbGF0aW9uVG9rZW4gPSBuZXcgKF9idWlsZGVyVXRpbFJ1bnRpbWUgfHwgX2xvYWRfYnVpbGRlclV0aWxSdW50aW1lKCkpLkNhbmNlbGxhdGlvblRva2VuKCkpIHtcbiAgICAgICAgdmFyIF90aGlzNCA9IHRoaXM7XG5cbiAgICAgICAgcmV0dXJuICgwLCAoX2JsdWViaXJkTHN0IHx8IF9sb2FkX2JsdWViaXJkTHN0KCkpLmNvcm91dGluZSkoZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGNvbnN0IHVwZGF0ZUluZm8gPSBfdGhpczQudXBkYXRlSW5mbztcbiAgICAgICAgICAgIGlmICh1cGRhdGVJbmZvID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBlcnJvciA9IG5ldyBFcnJvcihcIlBsZWFzZSBjaGVjayB1cGRhdGUgZmlyc3RcIik7XG4gICAgICAgICAgICAgICAgX3RoaXM0LmRpc3BhdGNoRXJyb3IoZXJyb3IpO1xuICAgICAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgX3RoaXM0Ll9sb2dnZXIuaW5mbyhgRG93bmxvYWRpbmcgdXBkYXRlIGZyb20gJHsoMCwgKF9idWlsZGVyVXRpbFJ1bnRpbWUgfHwgX2xvYWRfYnVpbGRlclV0aWxSdW50aW1lKCkpLmFzQXJyYXkpKHVwZGF0ZUluZm8uZmlsZXMpLm1hcChmdW5jdGlvbiAoaXQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaXQudXJsO1xuICAgICAgICAgICAgfSkuam9pbihcIiwgXCIpfWApO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICByZXR1cm4geWllbGQgX3RoaXM0LmRvRG93bmxvYWRVcGRhdGUodXBkYXRlSW5mbywgY2FuY2VsbGF0aW9uVG9rZW4pO1xuICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIF90aGlzNC5kaXNwYXRjaEVycm9yKGUpO1xuICAgICAgICAgICAgICAgIHRocm93IGU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pKCk7XG4gICAgfVxuICAgIGRpc3BhdGNoRXJyb3IoZSkge1xuICAgICAgICB0aGlzLmVtaXQoXCJlcnJvclwiLCBlLCAoZS5zdGFjayB8fCBlKS50b1N0cmluZygpKTtcbiAgICB9XG4gICAgbG9hZFVwZGF0ZUNvbmZpZygpIHtcbiAgICAgICAgdmFyIF90aGlzNSA9IHRoaXM7XG5cbiAgICAgICAgcmV0dXJuICgwLCAoX2JsdWViaXJkTHN0IHx8IF9sb2FkX2JsdWViaXJkTHN0KCkpLmNvcm91dGluZSkoZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGlmIChfdGhpczUuX2FwcFVwZGF0ZUNvbmZpZ1BhdGggPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIF90aGlzNS5fYXBwVXBkYXRlQ29uZmlnUGF0aCA9IChfZWxlY3Ryb25Jc0RldiB8fCBfbG9hZF9lbGVjdHJvbklzRGV2KCkpLmRlZmF1bHQgPyBfcGF0aC5qb2luKF90aGlzNS5hcHAuZ2V0QXBwUGF0aCgpLCBcImRldi1hcHAtdXBkYXRlLnltbFwiKSA6IF9wYXRoLmpvaW4ocHJvY2Vzcy5yZXNvdXJjZXNQYXRoLCBcImFwcC11cGRhdGUueW1sXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuICgwLCAoX2pzWWFtbCB8fCBfbG9hZF9qc1lhbWwoKSkuc2FmZUxvYWQpKCh5aWVsZCAoMCwgKF9mc0V4dHJhUCB8fCBfbG9hZF9mc0V4dHJhUCgpKS5yZWFkRmlsZSkoX3RoaXM1Ll9hcHBVcGRhdGVDb25maWdQYXRoLCBcInV0Zi04XCIpKSk7XG4gICAgICAgIH0pKCk7XG4gICAgfVxuICAgIC8qKiogQHByaXZhdGUgKi9cbiAgICBjb21wdXRlUmVxdWVzdEhlYWRlcnMoKSB7XG4gICAgICAgIHZhciBfdGhpczYgPSB0aGlzO1xuXG4gICAgICAgIHJldHVybiAoMCwgKF9ibHVlYmlyZExzdCB8fCBfbG9hZF9ibHVlYmlyZExzdCgpKS5jb3JvdXRpbmUpKGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCBmaWxlRXh0cmFEb3dubG9hZEhlYWRlcnMgPSAoeWllbGQgX3RoaXM2LnByb3ZpZGVyKS5maWxlRXh0cmFEb3dubG9hZEhlYWRlcnM7XG4gICAgICAgICAgICBpZiAoZmlsZUV4dHJhRG93bmxvYWRIZWFkZXJzICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBjb25zdCByZXF1ZXN0SGVhZGVycyA9IF90aGlzNi5yZXF1ZXN0SGVhZGVycztcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVxdWVzdEhlYWRlcnMgPT0gbnVsbCA/IGZpbGVFeHRyYURvd25sb2FkSGVhZGVycyA6IE9iamVjdC5hc3NpZ24oe30sIGZpbGVFeHRyYURvd25sb2FkSGVhZGVycywgcmVxdWVzdEhlYWRlcnMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIF90aGlzNi5jb21wdXRlRmluYWxIZWFkZXJzKHsgQWNjZXB0OiBcIiovKlwiIH0pO1xuICAgICAgICB9KSgpO1xuICAgIH1cbiAgICBnZXRPckNyZWF0ZVN0YWdpbmdVc2VySWQoKSB7XG4gICAgICAgIHZhciBfdGhpczcgPSB0aGlzO1xuXG4gICAgICAgIHJldHVybiAoMCwgKF9ibHVlYmlyZExzdCB8fCBfbG9hZF9ibHVlYmlyZExzdCgpKS5jb3JvdXRpbmUpKGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCBmaWxlID0gX3BhdGguam9pbihfdGhpczcuYXBwLmdldFBhdGgoXCJ1c2VyRGF0YVwiKSwgXCIudXBkYXRlcklkXCIpO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBjb25zdCBpZCA9IHlpZWxkICgwLCAoX2ZzRXh0cmFQIHx8IF9sb2FkX2ZzRXh0cmFQKCkpLnJlYWRGaWxlKShmaWxlLCBcInV0Zi04XCIpO1xuICAgICAgICAgICAgICAgIGlmICgoX2J1aWxkZXJVdGlsUnVudGltZSB8fCBfbG9hZF9idWlsZGVyVXRpbFJ1bnRpbWUoKSkuVVVJRC5jaGVjayhpZCkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGlkO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzNy5fbG9nZ2VyLndhcm4oYFN0YWdpbmcgdXNlciBpZCBmaWxlIGV4aXN0cywgYnV0IGNvbnRlbnQgd2FzIGludmFsaWQ6ICR7aWR9YCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIGlmIChlLmNvZGUgIT09IFwiRU5PRU5UXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXM3Ll9sb2dnZXIud2FybihgQ291bGRuJ3QgcmVhZCBzdGFnaW5nIHVzZXIgSUQsIGNyZWF0aW5nIGEgYmxhbmsgb25lOiAke2V9YCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgaWQgPSAoX2J1aWxkZXJVdGlsUnVudGltZSB8fCBfbG9hZF9idWlsZGVyVXRpbFJ1bnRpbWUoKSkuVVVJRC52NSgoMCwgKF9jcnlwdG8gfHwgX2xvYWRfY3J5cHRvKCkpLnJhbmRvbUJ5dGVzKSg0MDk2KSwgKF9idWlsZGVyVXRpbFJ1bnRpbWUgfHwgX2xvYWRfYnVpbGRlclV0aWxSdW50aW1lKCkpLlVVSUQuT0lEKTtcbiAgICAgICAgICAgIF90aGlzNy5fbG9nZ2VyLmluZm8oYEdlbmVyYXRlZCBuZXcgc3RhZ2luZyB1c2VyIElEOiAke2lkfWApO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICB5aWVsZCAoMCwgKF9mc0V4dHJhUCB8fCBfbG9hZF9mc0V4dHJhUCgpKS5vdXRwdXRGaWxlKShmaWxlLCBpZCk7XG4gICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgX3RoaXM3Ll9sb2dnZXIud2FybihgQ291bGRuJ3Qgd3JpdGUgb3V0IHN0YWdpbmcgdXNlciBJRDogJHtlfWApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGlkO1xuICAgICAgICB9KSgpO1xuICAgIH1cbn1cbmV4cG9ydHMuQXBwVXBkYXRlciA9IEFwcFVwZGF0ZXI7XG5mdW5jdGlvbiBoYXNQcmVyZWxlYXNlQ29tcG9uZW50cyh2ZXJzaW9uKSB7XG4gICAgY29uc3QgdmVyc2lvblByZXJlbGVhc2VDb21wb25lbnQgPSAoMCwgKF9zZW12ZXIgfHwgX2xvYWRfc2VtdmVyKCkpLnByZXJlbGVhc2UpKHZlcnNpb24pO1xuICAgIHJldHVybiB2ZXJzaW9uUHJlcmVsZWFzZUNvbXBvbmVudCAhPSBudWxsICYmIHZlcnNpb25QcmVyZWxlYXNlQ29tcG9uZW50Lmxlbmd0aCA+IDA7XG59XG4vKiogQHByaXZhdGUgKi9cbmNsYXNzIE5vT3BMb2dnZXIge1xuICAgIGluZm8obWVzc2FnZSkge1xuICAgICAgICAvLyBpZ25vcmVcbiAgICB9XG4gICAgd2FybihtZXNzYWdlKSB7XG4gICAgICAgIC8vIGlnbm9yZVxuICAgIH1cbiAgICBlcnJvcihtZXNzYWdlKSB7XG4gICAgICAgIC8vIGlnbm9yZVxuICAgIH1cbn1cbmV4cG9ydHMuTm9PcExvZ2dlciA9IE5vT3BMb2dnZXI7IC8vIyBzb3VyY2VNYXBwaW5nVVJMPUFwcFVwZGF0ZXIuanMubWFwXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2VsZWN0cm9uLXVwZGF0ZXIvb3V0L0FwcFVwZGF0ZXIuanMiLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCJjcnlwdG9cIik7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gZXh0ZXJuYWwgXCJjcnlwdG9cIlxuLy8gbW9kdWxlIGlkID0gMjhcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwidXRpbFwiKTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyBleHRlcm5hbCBcInV0aWxcIlxuLy8gbW9kdWxlIGlkID0gMjlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IHUgPSByZXF1aXJlKCd1bml2ZXJzYWxpZnknKS5mcm9tQ2FsbGJhY2tcbmNvbnN0IGpzb25GaWxlID0gcmVxdWlyZSgnanNvbmZpbGUnKVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgLy8ganNvbmZpbGUgZXhwb3J0c1xuICByZWFkSnNvbjogdShqc29uRmlsZS5yZWFkRmlsZSksXG4gIHJlYWRKc29uU3luYzoganNvbkZpbGUucmVhZEZpbGVTeW5jLFxuICB3cml0ZUpzb246IHUoanNvbkZpbGUud3JpdGVGaWxlKSxcbiAgd3JpdGVKc29uU3luYzoganNvbkZpbGUud3JpdGVGaWxlU3luY1xufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2VsZWN0cm9uLXVwZGF0ZXIvbm9kZV9tb2R1bGVzL2ZzLWV4dHJhL2xpYi9qc29uL2pzb25maWxlLmpzIiwiJ3VzZSBzdHJpY3QnO1xuXG5cbnZhciB5YW1sID0gcmVxdWlyZSgnLi9saWIvanMteWFtbC5qcycpO1xuXG5cbm1vZHVsZS5leHBvcnRzID0geWFtbDtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9qcy15YW1sL2luZGV4LmpzIiwiLy8gU3RhbmRhcmQgWUFNTCdzIEZhaWxzYWZlIHNjaGVtYS5cbi8vIGh0dHA6Ly93d3cueWFtbC5vcmcvc3BlYy8xLjIvc3BlYy5odG1sI2lkMjgwMjM0NlxuXG5cbid1c2Ugc3RyaWN0JztcblxuXG52YXIgU2NoZW1hID0gcmVxdWlyZSgnLi4vc2NoZW1hJyk7XG5cblxubW9kdWxlLmV4cG9ydHMgPSBuZXcgU2NoZW1hKHtcbiAgZXhwbGljaXQ6IFtcbiAgICByZXF1aXJlKCcuLi90eXBlL3N0cicpLFxuICAgIHJlcXVpcmUoJy4uL3R5cGUvc2VxJyksXG4gICAgcmVxdWlyZSgnLi4vdHlwZS9tYXAnKVxuICBdXG59KTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9qcy15YW1sL2xpYi9qcy15YW1sL3NjaGVtYS9mYWlsc2FmZS5qcyIsInJlcXVpcmUoJy4vJykuaW5zdGFsbCgpO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2VsZWN0cm9uLXVwZGF0ZXIvbm9kZV9tb2R1bGVzL3NvdXJjZS1tYXAtc3VwcG9ydC9yZWdpc3Rlci5qcyIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcImNoaWxkX3Byb2Nlc3NcIik7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gZXh0ZXJuYWwgXCJjaGlsZF9wcm9jZXNzXCJcbi8vIG1vZHVsZSBpZCA9IDM0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmNvbXB1dGVPcGVyYXRpb25zID0gY29tcHV0ZU9wZXJhdGlvbnM7XG52YXIgT3BlcmF0aW9uS2luZCA9IGV4cG9ydHMuT3BlcmF0aW9uS2luZCA9IHVuZGVmaW5lZDtcbihmdW5jdGlvbiAoT3BlcmF0aW9uS2luZCkge1xuICAgIE9wZXJhdGlvbktpbmRbT3BlcmF0aW9uS2luZFtcIkNPUFlcIl0gPSAwXSA9IFwiQ09QWVwiO1xuICAgIE9wZXJhdGlvbktpbmRbT3BlcmF0aW9uS2luZFtcIkRPV05MT0FEXCJdID0gMV0gPSBcIkRPV05MT0FEXCI7XG59KShPcGVyYXRpb25LaW5kIHx8IChleHBvcnRzLk9wZXJhdGlvbktpbmQgPSBPcGVyYXRpb25LaW5kID0ge30pKTtcbmZ1bmN0aW9uIGNvbXB1dGVPcGVyYXRpb25zKG9sZEJsb2NrTWFwLCBuZXdCbG9ja01hcCwgbG9nZ2VyKSB7XG4gICAgY29uc3QgbmFtZVRvT2xkQmxvY2tzID0gYnVpbGRCbG9ja0ZpbGVNYXAob2xkQmxvY2tNYXAuZmlsZXMpO1xuICAgIGNvbnN0IG5hbWVUb05ld0Jsb2NrcyA9IGJ1aWxkQmxvY2tGaWxlTWFwKG5ld0Jsb2NrTWFwLmZpbGVzKTtcbiAgICBjb25zdCBvbGRFbnRyeU1hcCA9IGJ1aWxkRW50cnlNYXAob2xkQmxvY2tNYXAuZmlsZXMpO1xuICAgIGxldCBsYXN0T3BlcmF0aW9uID0gbnVsbDtcbiAgICBjb25zdCBvcGVyYXRpb25zID0gW107XG4gICAgZm9yIChjb25zdCBibG9ja01hcEZpbGUgb2YgbmV3QmxvY2tNYXAuZmlsZXMpIHtcbiAgICAgICAgY29uc3QgbmFtZSA9IGJsb2NrTWFwRmlsZS5uYW1lO1xuICAgICAgICBjb25zdCBvbGRFbnRyeSA9IG9sZEVudHJ5TWFwLmdldChuYW1lKTtcbiAgICAgICAgaWYgKG9sZEVudHJ5ID09IG51bGwpIHtcbiAgICAgICAgICAgIC8vIG5ldyBmaWxlXG4gICAgICAgICAgICBvcGVyYXRpb25zLnB1c2goe1xuICAgICAgICAgICAgICAgIGtpbmQ6IE9wZXJhdGlvbktpbmQuRE9XTkxPQUQsXG4gICAgICAgICAgICAgICAgc3RhcnQ6IGJsb2NrTWFwRmlsZS5vZmZzZXQsXG4gICAgICAgICAgICAgICAgZW5kOiBibG9ja01hcEZpbGUub2Zmc2V0ICsgYmxvY2tNYXBGaWxlLnNpemVzLnJlZHVjZSgoYWNjdW11bGF0b3IsIGN1cnJlbnRWYWx1ZSkgPT4gYWNjdW11bGF0b3IgKyBjdXJyZW50VmFsdWUpXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG5ld0ZpbGUgPSBuYW1lVG9OZXdCbG9ja3MuZ2V0KG5hbWUpO1xuICAgICAgICBsZXQgY2hhbmdlZEJsb2NrQ291bnQgPSAwO1xuICAgICAgICBjb25zdCB7IGNoZWNrc3VtVG9PZmZzZXQ6IGNoZWNrc3VtVG9PbGRPZmZzZXQsIGNoZWNrc3VtVG9PbGRTaXplIH0gPSBidWlsZENoZWNrc3VtTWFwKG5hbWVUb09sZEJsb2Nrcy5nZXQobmFtZSksIG9sZEVudHJ5Lm9mZnNldCk7XG4gICAgICAgIGxldCBuZXdPZmZzZXQgPSBibG9ja01hcEZpbGUub2Zmc2V0O1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG5ld0ZpbGUuY2hlY2tzdW1zLmxlbmd0aDsgbmV3T2Zmc2V0ICs9IG5ld0ZpbGUuc2l6ZXNbaV0sIGkrKykge1xuICAgICAgICAgICAgY29uc3QgYmxvY2tTaXplID0gbmV3RmlsZS5zaXplc1tpXTtcbiAgICAgICAgICAgIGNvbnN0IGNoZWNrc3VtID0gbmV3RmlsZS5jaGVja3N1bXNbaV07XG4gICAgICAgICAgICBsZXQgb2xkT2Zmc2V0ID0gY2hlY2tzdW1Ub09sZE9mZnNldC5nZXQoY2hlY2tzdW0pO1xuICAgICAgICAgICAgaWYgKG9sZE9mZnNldCAhPSBudWxsICYmIGNoZWNrc3VtVG9PbGRTaXplLmdldChjaGVja3N1bSkgIT09IGJsb2NrU2l6ZSkge1xuICAgICAgICAgICAgICAgIGxvZ2dlci53YXJuKGBDaGVja3N1bSAoXCIke2NoZWNrc3VtfVwiKSBtYXRjaGVzLCBidXQgc2l6ZSBkaWZmZXJzIChvbGQ6ICR7Y2hlY2tzdW1Ub09sZFNpemUuZ2V0KGNoZWNrc3VtKX0sIG5ldzogJHtibG9ja1NpemV9KWApO1xuICAgICAgICAgICAgICAgIG9sZE9mZnNldCA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAob2xkT2Zmc2V0ID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBjaGFuZ2VkQmxvY2tDb3VudCsrO1xuICAgICAgICAgICAgICAgIGlmIChsYXN0T3BlcmF0aW9uID09IG51bGwgfHwgbGFzdE9wZXJhdGlvbi5raW5kICE9PSBPcGVyYXRpb25LaW5kLkRPV05MT0FEIHx8IGxhc3RPcGVyYXRpb24uZW5kICE9PSBuZXdPZmZzZXQpIHtcbiAgICAgICAgICAgICAgICAgICAgbGFzdE9wZXJhdGlvbiA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGtpbmQ6IE9wZXJhdGlvbktpbmQuRE9XTkxPQUQsXG4gICAgICAgICAgICAgICAgICAgICAgICBzdGFydDogbmV3T2Zmc2V0LFxuICAgICAgICAgICAgICAgICAgICAgICAgZW5kOiBuZXdPZmZzZXQgKyBibG9ja1NpemVcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgb3BlcmF0aW9ucy5wdXNoKGxhc3RPcGVyYXRpb24pO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGxhc3RPcGVyYXRpb24uZW5kICs9IGJsb2NrU2l6ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGxhc3RPcGVyYXRpb24gPT0gbnVsbCB8fCBsYXN0T3BlcmF0aW9uLmtpbmQgIT09IE9wZXJhdGlvbktpbmQuQ09QWSB8fCBsYXN0T3BlcmF0aW9uLmVuZCAhPT0gb2xkT2Zmc2V0KSB7XG4gICAgICAgICAgICAgICAgbGFzdE9wZXJhdGlvbiA9IHtcbiAgICAgICAgICAgICAgICAgICAga2luZDogT3BlcmF0aW9uS2luZC5DT1BZLFxuICAgICAgICAgICAgICAgICAgICBzdGFydDogb2xkT2Zmc2V0LFxuICAgICAgICAgICAgICAgICAgICBlbmQ6IG9sZE9mZnNldCArIGJsb2NrU2l6ZVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgb3BlcmF0aW9ucy5wdXNoKGxhc3RPcGVyYXRpb24pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBsYXN0T3BlcmF0aW9uLmVuZCArPSBibG9ja1NpemU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNoYW5nZWRCbG9ja0NvdW50ID4gMCkge1xuICAgICAgICAgICAgbG9nZ2VyLmluZm8oYEZpbGUke2Jsb2NrTWFwRmlsZS5uYW1lID09PSBcImZpbGVcIiA/IFwiXCIgOiBcIiBcIiArIGJsb2NrTWFwRmlsZS5uYW1lfSBoYXMgJHtjaGFuZ2VkQmxvY2tDb3VudH0gY2hhbmdlZCBibG9ja3NgKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gb3BlcmF0aW9ucztcbn1cbmZ1bmN0aW9uIGJ1aWxkQ2hlY2tzdW1NYXAoZmlsZSwgZmlsZU9mZnNldCkge1xuICAgIGNvbnN0IGNoZWNrc3VtVG9PZmZzZXQgPSBuZXcgTWFwKCk7XG4gICAgY29uc3QgY2hlY2tzdW1Ub1NpemUgPSBuZXcgTWFwKCk7XG4gICAgbGV0IG9mZnNldCA9IGZpbGVPZmZzZXQ7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBmaWxlLmNoZWNrc3Vtcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCBjaGVja3N1bSA9IGZpbGUuY2hlY2tzdW1zW2ldO1xuICAgICAgICBjb25zdCBzaXplID0gZmlsZS5zaXplc1tpXTtcbiAgICAgICAgY2hlY2tzdW1Ub09mZnNldC5zZXQoY2hlY2tzdW0sIG9mZnNldCk7XG4gICAgICAgIGNoZWNrc3VtVG9TaXplLnNldChjaGVja3N1bSwgc2l6ZSk7XG4gICAgICAgIG9mZnNldCArPSBzaXplO1xuICAgIH1cbiAgICByZXR1cm4geyBjaGVja3N1bVRvT2Zmc2V0LCBjaGVja3N1bVRvT2xkU2l6ZTogY2hlY2tzdW1Ub1NpemUgfTtcbn1cbmZ1bmN0aW9uIGJ1aWxkRW50cnlNYXAobGlzdCkge1xuICAgIGNvbnN0IHJlc3VsdCA9IG5ldyBNYXAoKTtcbiAgICBmb3IgKGNvbnN0IGl0ZW0gb2YgbGlzdCkge1xuICAgICAgICByZXN1bHQuc2V0KGl0ZW0ubmFtZSwgaXRlbSk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiBidWlsZEJsb2NrRmlsZU1hcChsaXN0KSB7XG4gICAgY29uc3QgcmVzdWx0ID0gbmV3IE1hcCgpO1xuICAgIGZvciAoY29uc3QgaXRlbSBvZiBsaXN0KSB7XG4gICAgICAgIHJlc3VsdC5zZXQoaXRlbS5uYW1lLCBpdGVtKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRvd25sb2FkUGxhbkJ1aWxkZXIuanMubWFwXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2VsZWN0cm9uLXVwZGF0ZXIvb3V0L2RpZmZlcmVudGlhbERvd25sb2FkZXIvZG93bmxvYWRQbGFuQnVpbGRlci5qcyIsIid1c2Ugc3RyaWN0JztcblxudmFyIGZvcm1hdCAgICAgICAgICA9IHJlcXVpcmUoJy4uL2Zvcm1hdCcpO1xudmFyIG9yaWdpbmFsQ29uc29sZSA9IHJlcXVpcmUoJy4uL29yaWdpbmFsLWNvbnNvbGUnKTtcblxudHJhbnNwb3J0LmxldmVsICA9ICdzaWxseSc7XG50cmFuc3BvcnQuZm9ybWF0ID0gJ1t7aH06e2l9OntzfS57bXN9XSBbe2xldmVsfV0ge3RleHR9JztcblxubW9kdWxlLmV4cG9ydHMgPSB0cmFuc3BvcnQ7XG5cbmZ1bmN0aW9uIHRyYW5zcG9ydChtc2cpIHtcbiAgdmFyIHRleHQgPSBmb3JtYXQuZm9ybWF0KG1zZywgdHJhbnNwb3J0LmZvcm1hdCk7XG4gIGlmIChvcmlnaW5hbENvbnNvbGVbbXNnLmxldmVsXSkge1xuICAgIG9yaWdpbmFsQ29uc29sZVttc2cubGV2ZWxdKHRleHQpO1xuICB9IGVsc2Uge1xuICAgIG9yaWdpbmFsQ29uc29sZS5sb2codGV4dCk7XG4gIH1cbn1cblxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2VsZWN0cm9uLWxvZy9saWIvdHJhbnNwb3J0cy9jb25zb2xlLmpzIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgdXRpbCA9IHJlcXVpcmUoJ3V0aWwnKTtcbnZhciBFT0wgID0gcmVxdWlyZSgnb3MnKS5FT0w7XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBmb3JtYXQ6IGZvcm1hdCxcbiAgZm9ybWF0VGltZVpvbmU6IGZvcm1hdFRpbWVab25lLFxuICBwYWQ6IHBhZCxcbiAgc3RyaW5naWZ5QXJyYXk6IHN0cmluZ2lmeUFycmF5XG59O1xuXG5mdW5jdGlvbiBmb3JtYXQobXNnLCBmb3JtYXR0ZXIpIHtcbiAgaWYgKHR5cGVvZiBmb3JtYXR0ZXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gZm9ybWF0dGVyKG1zZyk7XG4gIH1cblxuICB2YXIgZGF0ZSA9IG1zZy5kYXRlO1xuXG4gIHJldHVybiBmb3JtYXR0ZXJcbiAgICAucmVwbGFjZSgne2xldmVsfScsIG1zZy5sZXZlbClcbiAgICAucmVwbGFjZSgne3RleHR9Jywgc3RyaW5naWZ5QXJyYXkobXNnLmRhdGEpKVxuICAgIC5yZXBsYWNlKCd7eX0nLCBkYXRlLmdldEZ1bGxZZWFyKCkpXG4gICAgLnJlcGxhY2UoJ3ttfScsIHBhZChkYXRlLmdldE1vbnRoKCkgKyAxKSlcbiAgICAucmVwbGFjZSgne2R9JywgcGFkKGRhdGUuZ2V0RGF0ZSgpKSlcbiAgICAucmVwbGFjZSgne2h9JywgcGFkKGRhdGUuZ2V0SG91cnMoKSkpXG4gICAgLnJlcGxhY2UoJ3tpfScsIHBhZChkYXRlLmdldE1pbnV0ZXMoKSkpXG4gICAgLnJlcGxhY2UoJ3tzfScsIHBhZChkYXRlLmdldFNlY29uZHMoKSkpXG4gICAgLnJlcGxhY2UoJ3ttc30nLCBwYWQoZGF0ZS5nZXRNaWxsaXNlY29uZHMoKSwgMykpXG4gICAgLnJlcGxhY2UoJ3t6fScsIGZvcm1hdFRpbWVab25lKGRhdGUuZ2V0VGltZXpvbmVPZmZzZXQoKSkpO1xufVxuXG5mdW5jdGlvbiBzdHJpbmdpZnlBcnJheShkYXRhKSB7XG4gIGRhdGEgPSBkYXRhLm1hcChmdW5jdGlvbiBmb3JtYXRFcnJvcnMoYXJnKSB7XG4gICAgcmV0dXJuIGFyZyBpbnN0YW5jZW9mIEVycm9yID8gYXJnLnN0YWNrICsgRU9MIDogYXJnO1xuICB9KTtcbiAgcmV0dXJuIHV0aWwuZm9ybWF0LmFwcGx5KHV0aWwsIGRhdGEpO1xufVxuXG5mdW5jdGlvbiBwYWQobnVtYmVyLCB6ZXJvcykge1xuICB6ZXJvcyA9IHplcm9zIHx8IDI7XG4gIHJldHVybiAobmV3IEFycmF5KHplcm9zICsgMSkuam9pbignMCcpICsgbnVtYmVyKS5zdWJzdHIoLXplcm9zLCB6ZXJvcyk7XG59XG5cbmZ1bmN0aW9uIGZvcm1hdFRpbWVab25lKG1pbnV0ZXNPZmZzZXQpIHtcbiAgdmFyIG0gPSBNYXRoLmFicyhtaW51dGVzT2Zmc2V0KTtcbiAgcmV0dXJuIChtaW51dGVzT2Zmc2V0ID49IDAgPyAnLScgOiAnKycpICtcbiAgICBwYWQoTWF0aC5mbG9vcihtIC8gNjApKSArICc6JyArXG4gICAgcGFkKG0gJSA2MCk7XG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvZWxlY3Ryb24tbG9nL2xpYi9mb3JtYXQuanMiLCJcInVzZSBzdHJpY3RcIjtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oTkVYVF9GSUxURVIpIHtcbnZhciB1dGlsID0gcmVxdWlyZShcIi4vdXRpbFwiKTtcbnZhciBnZXRLZXlzID0gcmVxdWlyZShcIi4vZXM1XCIpLmtleXM7XG52YXIgdHJ5Q2F0Y2ggPSB1dGlsLnRyeUNhdGNoO1xudmFyIGVycm9yT2JqID0gdXRpbC5lcnJvck9iajtcblxuZnVuY3Rpb24gY2F0Y2hGaWx0ZXIoaW5zdGFuY2VzLCBjYiwgcHJvbWlzZSkge1xuICAgIHJldHVybiBmdW5jdGlvbihlKSB7XG4gICAgICAgIHZhciBib3VuZFRvID0gcHJvbWlzZS5fYm91bmRWYWx1ZSgpO1xuICAgICAgICBwcmVkaWNhdGVMb29wOiBmb3IgKHZhciBpID0gMDsgaSA8IGluc3RhbmNlcy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgdmFyIGl0ZW0gPSBpbnN0YW5jZXNbaV07XG5cbiAgICAgICAgICAgIGlmIChpdGVtID09PSBFcnJvciB8fFxuICAgICAgICAgICAgICAgIChpdGVtICE9IG51bGwgJiYgaXRlbS5wcm90b3R5cGUgaW5zdGFuY2VvZiBFcnJvcikpIHtcbiAgICAgICAgICAgICAgICBpZiAoZSBpbnN0YW5jZW9mIGl0ZW0pIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRyeUNhdGNoKGNiKS5jYWxsKGJvdW5kVG8sIGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGl0ZW0gPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgICAgIHZhciBtYXRjaGVzUHJlZGljYXRlID0gdHJ5Q2F0Y2goaXRlbSkuY2FsbChib3VuZFRvLCBlKTtcbiAgICAgICAgICAgICAgICBpZiAobWF0Y2hlc1ByZWRpY2F0ZSA9PT0gZXJyb3JPYmopIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG1hdGNoZXNQcmVkaWNhdGU7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChtYXRjaGVzUHJlZGljYXRlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnlDYXRjaChjYikuY2FsbChib3VuZFRvLCBlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHV0aWwuaXNPYmplY3QoZSkpIHtcbiAgICAgICAgICAgICAgICB2YXIga2V5cyA9IGdldEtleXMoaXRlbSk7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBrZXlzLmxlbmd0aDsgKytqKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBrZXkgPSBrZXlzW2pdO1xuICAgICAgICAgICAgICAgICAgICBpZiAoaXRlbVtrZXldICE9IGVba2V5XSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWUgcHJlZGljYXRlTG9vcDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ5Q2F0Y2goY2IpLmNhbGwoYm91bmRUbywgZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIE5FWFRfRklMVEVSO1xuICAgIH07XG59XG5cbnJldHVybiBjYXRjaEZpbHRlcjtcbn07XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvYmx1ZWJpcmQvanMvcmVsZWFzZS9jYXRjaF9maWx0ZXIuanMiLCJcInVzZSBzdHJpY3RcIjtcbnZhciB1dGlsID0gcmVxdWlyZShcIi4vdXRpbFwiKTtcbnZhciBtYXliZVdyYXBBc0Vycm9yID0gdXRpbC5tYXliZVdyYXBBc0Vycm9yO1xudmFyIGVycm9ycyA9IHJlcXVpcmUoXCIuL2Vycm9yc1wiKTtcbnZhciBPcGVyYXRpb25hbEVycm9yID0gZXJyb3JzLk9wZXJhdGlvbmFsRXJyb3I7XG52YXIgZXM1ID0gcmVxdWlyZShcIi4vZXM1XCIpO1xuXG5mdW5jdGlvbiBpc1VudHlwZWRFcnJvcihvYmopIHtcbiAgICByZXR1cm4gb2JqIGluc3RhbmNlb2YgRXJyb3IgJiZcbiAgICAgICAgZXM1LmdldFByb3RvdHlwZU9mKG9iaikgPT09IEVycm9yLnByb3RvdHlwZTtcbn1cblxudmFyIHJFcnJvcktleSA9IC9eKD86bmFtZXxtZXNzYWdlfHN0YWNrfGNhdXNlKSQvO1xuZnVuY3Rpb24gd3JhcEFzT3BlcmF0aW9uYWxFcnJvcihvYmopIHtcbiAgICB2YXIgcmV0O1xuICAgIGlmIChpc1VudHlwZWRFcnJvcihvYmopKSB7XG4gICAgICAgIHJldCA9IG5ldyBPcGVyYXRpb25hbEVycm9yKG9iaik7XG4gICAgICAgIHJldC5uYW1lID0gb2JqLm5hbWU7XG4gICAgICAgIHJldC5tZXNzYWdlID0gb2JqLm1lc3NhZ2U7XG4gICAgICAgIHJldC5zdGFjayA9IG9iai5zdGFjaztcbiAgICAgICAgdmFyIGtleXMgPSBlczUua2V5cyhvYmopO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIHZhciBrZXkgPSBrZXlzW2ldO1xuICAgICAgICAgICAgaWYgKCFyRXJyb3JLZXkudGVzdChrZXkpKSB7XG4gICAgICAgICAgICAgICAgcmV0W2tleV0gPSBvYmpba2V5XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmV0O1xuICAgIH1cbiAgICB1dGlsLm1hcmtBc09yaWdpbmF0aW5nRnJvbVJlamVjdGlvbihvYmopO1xuICAgIHJldHVybiBvYmo7XG59XG5cbmZ1bmN0aW9uIG5vZGViYWNrRm9yUHJvbWlzZShwcm9taXNlLCBtdWx0aUFyZ3MpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oZXJyLCB2YWx1ZSkge1xuICAgICAgICBpZiAocHJvbWlzZSA9PT0gbnVsbCkgcmV0dXJuO1xuICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICB2YXIgd3JhcHBlZCA9IHdyYXBBc09wZXJhdGlvbmFsRXJyb3IobWF5YmVXcmFwQXNFcnJvcihlcnIpKTtcbiAgICAgICAgICAgIHByb21pc2UuX2F0dGFjaEV4dHJhVHJhY2Uod3JhcHBlZCk7XG4gICAgICAgICAgICBwcm9taXNlLl9yZWplY3Qod3JhcHBlZCk7XG4gICAgICAgIH0gZWxzZSBpZiAoIW11bHRpQXJncykge1xuICAgICAgICAgICAgcHJvbWlzZS5fZnVsZmlsbCh2YWx1ZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YXIgJF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoO3ZhciBhcmdzID0gbmV3IEFycmF5KE1hdGgubWF4KCRfbGVuIC0gMSwgMCkpOyBmb3IodmFyICRfaSA9IDE7ICRfaSA8ICRfbGVuOyArKyRfaSkge2FyZ3NbJF9pIC0gMV0gPSBhcmd1bWVudHNbJF9pXTt9O1xuICAgICAgICAgICAgcHJvbWlzZS5fZnVsZmlsbChhcmdzKTtcbiAgICAgICAgfVxuICAgICAgICBwcm9taXNlID0gbnVsbDtcbiAgICB9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IG5vZGViYWNrRm9yUHJvbWlzZTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9ibHVlYmlyZC9qcy9yZWxlYXNlL25vZGViYWNrLmpzIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuQ2FuY2VsbGF0aW9uRXJyb3IgPSBleHBvcnRzLkNhbmNlbGxhdGlvblRva2VuID0gdW5kZWZpbmVkO1xuXG52YXIgX2JsdWViaXJkTHN0O1xuXG5mdW5jdGlvbiBfbG9hZF9ibHVlYmlyZExzdCgpIHtcbiAgICByZXR1cm4gX2JsdWViaXJkTHN0ID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiYmx1ZWJpcmQtbHN0XCIpKTtcbn1cblxudmFyIF9ldmVudHM7XG5cbmZ1bmN0aW9uIF9sb2FkX2V2ZW50cygpIHtcbiAgICByZXR1cm4gX2V2ZW50cyA9IHJlcXVpcmUoXCJldmVudHNcIik7XG59XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmNsYXNzIENhbmNlbGxhdGlvblRva2VuIGV4dGVuZHMgKF9ldmVudHMgfHwgX2xvYWRfZXZlbnRzKCkpLkV2ZW50RW1pdHRlciB7XG4gICAgLy8gYmFiZWwgY2Fubm90IGNvbXBpbGUgLi4uIGNvcnJlY3RseSBmb3Igc3VwZXIgY2FsbHNcbiAgICBjb25zdHJ1Y3RvcihwYXJlbnQpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5wYXJlbnRDYW5jZWxIYW5kbGVyID0gbnVsbDtcbiAgICAgICAgdGhpcy5fY2FuY2VsbGVkID0gZmFsc2U7XG4gICAgICAgIGlmIChwYXJlbnQgIT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5wYXJlbnQgPSBwYXJlbnQ7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0IGNhbmNlbGxlZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2NhbmNlbGxlZCB8fCB0aGlzLl9wYXJlbnQgIT0gbnVsbCAmJiB0aGlzLl9wYXJlbnQuY2FuY2VsbGVkO1xuICAgIH1cbiAgICBzZXQgcGFyZW50KHZhbHVlKSB7XG4gICAgICAgIHRoaXMucmVtb3ZlUGFyZW50Q2FuY2VsSGFuZGxlcigpO1xuICAgICAgICB0aGlzLl9wYXJlbnQgPSB2YWx1ZTtcbiAgICAgICAgdGhpcy5wYXJlbnRDYW5jZWxIYW5kbGVyID0gKCkgPT4gdGhpcy5jYW5jZWwoKTtcbiAgICAgICAgdGhpcy5fcGFyZW50Lm9uQ2FuY2VsKHRoaXMucGFyZW50Q2FuY2VsSGFuZGxlcik7XG4gICAgfVxuICAgIGNhbmNlbCgpIHtcbiAgICAgICAgdGhpcy5fY2FuY2VsbGVkID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5lbWl0KFwiY2FuY2VsXCIpO1xuICAgIH1cbiAgICBvbkNhbmNlbChoYW5kbGVyKSB7XG4gICAgICAgIGlmICh0aGlzLmNhbmNlbGxlZCkge1xuICAgICAgICAgICAgaGFuZGxlcigpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5vbmNlKFwiY2FuY2VsXCIsIGhhbmRsZXIpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNyZWF0ZVByb21pc2UoY2FsbGJhY2spIHtcbiAgICAgICAgaWYgKHRoaXMuY2FuY2VsbGVkKSB7XG4gICAgICAgICAgICByZXR1cm4gKF9ibHVlYmlyZExzdCB8fCBfbG9hZF9ibHVlYmlyZExzdCgpKS5kZWZhdWx0LnJlamVjdChuZXcgQ2FuY2VsbGF0aW9uRXJyb3IoKSk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGNhbmNlbEhhbmRsZXIgPSBudWxsO1xuICAgICAgICByZXR1cm4gbmV3IChfYmx1ZWJpcmRMc3QgfHwgX2xvYWRfYmx1ZWJpcmRMc3QoKSkuZGVmYXVsdCgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICBsZXQgYWRkZWRDYW5jZWxIYW5kbGVyID0gbnVsbDtcbiAgICAgICAgICAgIGNhbmNlbEhhbmRsZXIgPSAoKSA9PiB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGFkZGVkQ2FuY2VsSGFuZGxlciAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhZGRlZENhbmNlbEhhbmRsZXIoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFkZGVkQ2FuY2VsSGFuZGxlciA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgICAgICAgICByZWplY3QobmV3IENhbmNlbGxhdGlvbkVycm9yKCkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBpZiAodGhpcy5jYW5jZWxsZWQpIHtcbiAgICAgICAgICAgICAgICBjYW5jZWxIYW5kbGVyKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5vbkNhbmNlbChjYW5jZWxIYW5kbGVyKTtcbiAgICAgICAgICAgIGNhbGxiYWNrKHJlc29sdmUsIHJlamVjdCwgY2FsbGJhY2sgPT4ge1xuICAgICAgICAgICAgICAgIGFkZGVkQ2FuY2VsSGFuZGxlciA9IGNhbGxiYWNrO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pLmZpbmFsbHkoKCkgPT4ge1xuICAgICAgICAgICAgaWYgKGNhbmNlbEhhbmRsZXIgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRoaXMucmVtb3ZlTGlzdGVuZXIoXCJjYW5jZWxcIiwgY2FuY2VsSGFuZGxlcik7XG4gICAgICAgICAgICAgICAgY2FuY2VsSGFuZGxlciA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICByZW1vdmVQYXJlbnRDYW5jZWxIYW5kbGVyKCkge1xuICAgICAgICBjb25zdCBwYXJlbnQgPSB0aGlzLl9wYXJlbnQ7XG4gICAgICAgIGlmIChwYXJlbnQgIT0gbnVsbCAmJiB0aGlzLnBhcmVudENhbmNlbEhhbmRsZXIgIT0gbnVsbCkge1xuICAgICAgICAgICAgcGFyZW50LnJlbW92ZUxpc3RlbmVyKFwiY2FuY2VsXCIsIHRoaXMucGFyZW50Q2FuY2VsSGFuZGxlcik7XG4gICAgICAgICAgICB0aGlzLnBhcmVudENhbmNlbEhhbmRsZXIgPSBudWxsO1xuICAgICAgICB9XG4gICAgfVxuICAgIGRpc3Bvc2UoKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICB0aGlzLnJlbW92ZVBhcmVudENhbmNlbEhhbmRsZXIoKTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIHRoaXMucmVtb3ZlQWxsTGlzdGVuZXJzKCk7XG4gICAgICAgICAgICB0aGlzLl9wYXJlbnQgPSBudWxsO1xuICAgICAgICB9XG4gICAgfVxufVxuZXhwb3J0cy5DYW5jZWxsYXRpb25Ub2tlbiA9IENhbmNlbGxhdGlvblRva2VuO1xuY2xhc3MgQ2FuY2VsbGF0aW9uRXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKFwiQ2FuY2VsbGVkXCIpO1xuICAgIH1cbn1cbmV4cG9ydHMuQ2FuY2VsbGF0aW9uRXJyb3IgPSBDYW5jZWxsYXRpb25FcnJvcjsgLy8jIHNvdXJjZU1hcHBpbmdVUkw9Q2FuY2VsbGF0aW9uVG9rZW4uanMubWFwXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2VsZWN0cm9uLXVwZGF0ZXIvbm9kZV9tb2R1bGVzL2J1aWxkZXItdXRpbC1ydW50aW1lL291dC9DYW5jZWxsYXRpb25Ub2tlbi5qcyIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcImV2ZW50c1wiKTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyBleHRlcm5hbCBcImV2ZW50c1wiXG4vLyBtb2R1bGUgaWQgPSA0MVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5EaWdlc3RUcmFuc2Zvcm0gPSBleHBvcnRzLkh0dHBFeGVjdXRvciA9IGV4cG9ydHMuSHR0cEVycm9yID0gdW5kZWZpbmVkO1xuZXhwb3J0cy5jcmVhdGVIdHRwRXJyb3IgPSBjcmVhdGVIdHRwRXJyb3I7XG5leHBvcnRzLnBhcnNlSnNvbiA9IHBhcnNlSnNvbjtcbmV4cG9ydHMuY29uZmlndXJlUmVxdWVzdE9wdGlvbnNGcm9tVXJsID0gY29uZmlndXJlUmVxdWVzdE9wdGlvbnNGcm9tVXJsO1xuZXhwb3J0cy5zYWZlR2V0SGVhZGVyID0gc2FmZUdldEhlYWRlcjtcbmV4cG9ydHMuY29uZmlndXJlUmVxdWVzdE9wdGlvbnMgPSBjb25maWd1cmVSZXF1ZXN0T3B0aW9ucztcbmV4cG9ydHMuc2FmZVN0cmluZ2lmeUpzb24gPSBzYWZlU3RyaW5naWZ5SnNvbjtcblxudmFyIF9jcnlwdG87XG5cbmZ1bmN0aW9uIF9sb2FkX2NyeXB0bygpIHtcbiAgICByZXR1cm4gX2NyeXB0byA9IHJlcXVpcmUoXCJjcnlwdG9cIik7XG59XG5cbnZhciBfZGVidWcyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiZGVidWdcIikpO1xuXG52YXIgX2ZzRXh0cmFQO1xuXG5mdW5jdGlvbiBfbG9hZF9mc0V4dHJhUCgpIHtcbiAgICByZXR1cm4gX2ZzRXh0cmFQID0gcmVxdWlyZShcImZzLWV4dHJhLXBcIik7XG59XG5cbnZhciBfc3RyZWFtO1xuXG5mdW5jdGlvbiBfbG9hZF9zdHJlYW0oKSB7XG4gICAgcmV0dXJuIF9zdHJlYW0gPSByZXF1aXJlKFwic3RyZWFtXCIpO1xufVxuXG52YXIgX3VybDtcblxuZnVuY3Rpb24gX2xvYWRfdXJsKCkge1xuICAgIHJldHVybiBfdXJsID0gcmVxdWlyZShcInVybFwiKTtcbn1cblxudmFyIF9DYW5jZWxsYXRpb25Ub2tlbjtcblxuZnVuY3Rpb24gX2xvYWRfQ2FuY2VsbGF0aW9uVG9rZW4oKSB7XG4gICAgcmV0dXJuIF9DYW5jZWxsYXRpb25Ub2tlbiA9IHJlcXVpcmUoXCIuL0NhbmNlbGxhdGlvblRva2VuXCIpO1xufVxuXG52YXIgX2luZGV4O1xuXG5mdW5jdGlvbiBfbG9hZF9pbmRleCgpIHtcbiAgICByZXR1cm4gX2luZGV4ID0gcmVxdWlyZShcIi4vaW5kZXhcIik7XG59XG5cbnZhciBfUHJvZ3Jlc3NDYWxsYmFja1RyYW5zZm9ybTtcblxuZnVuY3Rpb24gX2xvYWRfUHJvZ3Jlc3NDYWxsYmFja1RyYW5zZm9ybSgpIHtcbiAgICByZXR1cm4gX1Byb2dyZXNzQ2FsbGJhY2tUcmFuc2Zvcm0gPSByZXF1aXJlKFwiLi9Qcm9ncmVzc0NhbGxiYWNrVHJhbnNmb3JtXCIpO1xufVxuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5jb25zdCBkZWJ1ZyA9ICgwLCBfZGVidWcyLmRlZmF1bHQpKFwiZWxlY3Ryb24tYnVpbGRlclwiKTtcbmZ1bmN0aW9uIGNyZWF0ZUh0dHBFcnJvcihyZXNwb25zZSwgZGVzY3JpcHRpb24gPSBudWxsKSB7XG4gICAgcmV0dXJuIG5ldyBIdHRwRXJyb3IocmVzcG9uc2Uuc3RhdHVzQ29kZSB8fCAtMSwgYCR7cmVzcG9uc2Uuc3RhdHVzQ29kZX0gJHtyZXNwb25zZS5zdGF0dXNNZXNzYWdlfWAgKyAoZGVzY3JpcHRpb24gPT0gbnVsbCA/IFwiXCIgOiBcIlxcblwiICsgSlNPTi5zdHJpbmdpZnkoZGVzY3JpcHRpb24sIG51bGwsIFwiICBcIikpICsgXCJcXG5IZWFkZXJzOiBcIiArIHNhZmVTdHJpbmdpZnlKc29uKHJlc3BvbnNlLmhlYWRlcnMpLCBkZXNjcmlwdGlvbik7XG59XG5jb25zdCBIVFRQX1NUQVRVU19DT0RFUyA9IG5ldyBNYXAoW1s0MjksIFwiVG9vIG1hbnkgcmVxdWVzdHNcIl0sIFs0MDAsIFwiQmFkIHJlcXVlc3RcIl0sIFs0MDMsIFwiRm9yYmlkZGVuXCJdLCBbNDA0LCBcIk5vdCBmb3VuZFwiXSwgWzQwNSwgXCJNZXRob2Qgbm90IGFsbG93ZWRcIl0sIFs0MDYsIFwiTm90IGFjY2VwdGFibGVcIl0sIFs0MDgsIFwiUmVxdWVzdCB0aW1lb3V0XCJdLCBbNDEzLCBcIlJlcXVlc3QgZW50aXR5IHRvbyBsYXJnZVwiXSwgWzUwMCwgXCJJbnRlcm5hbCBzZXJ2ZXIgZXJyb3JcIl0sIFs1MDIsIFwiQmFkIGdhdGV3YXlcIl0sIFs1MDMsIFwiU2VydmljZSB1bmF2YWlsYWJsZVwiXSwgWzUwNCwgXCJHYXRld2F5IHRpbWVvdXRcIl0sIFs1MDUsIFwiSFRUUCB2ZXJzaW9uIG5vdCBzdXBwb3J0ZWRcIl1dKTtcbmNsYXNzIEh0dHBFcnJvciBleHRlbmRzIEVycm9yIHtcbiAgICBjb25zdHJ1Y3RvcihzdGF0dXNDb2RlLCBtZXNzYWdlID0gYEhUVFAgZXJyb3I6ICR7SFRUUF9TVEFUVVNfQ09ERVMuZ2V0KHN0YXR1c0NvZGUpIHx8IHN0YXR1c0NvZGV9YCwgZGVzY3JpcHRpb24gPSBudWxsKSB7XG4gICAgICAgIHN1cGVyKG1lc3NhZ2UpO1xuICAgICAgICB0aGlzLnN0YXR1c0NvZGUgPSBzdGF0dXNDb2RlO1xuICAgICAgICB0aGlzLmRlc2NyaXB0aW9uID0gZGVzY3JpcHRpb247XG4gICAgICAgIHRoaXMubmFtZSA9IFwiSHR0cEVycm9yXCI7XG4gICAgfVxufVxuZXhwb3J0cy5IdHRwRXJyb3IgPSBIdHRwRXJyb3I7XG5mdW5jdGlvbiBwYXJzZUpzb24ocmVzdWx0KSB7XG4gICAgcmV0dXJuIHJlc3VsdC50aGVuKGl0ID0+IGl0ID09IG51bGwgfHwgaXQubGVuZ3RoID09PSAwID8gbnVsbCA6IEpTT04ucGFyc2UoaXQpKTtcbn1cbmNsYXNzIEh0dHBFeGVjdXRvciB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMubWF4UmVkaXJlY3RzID0gMTA7XG4gICAgfVxuICAgIHJlcXVlc3Qob3B0aW9ucywgY2FuY2VsbGF0aW9uVG9rZW4gPSBuZXcgKF9DYW5jZWxsYXRpb25Ub2tlbiB8fCBfbG9hZF9DYW5jZWxsYXRpb25Ub2tlbigpKS5DYW5jZWxsYXRpb25Ub2tlbigpLCBkYXRhKSB7XG4gICAgICAgIGNvbmZpZ3VyZVJlcXVlc3RPcHRpb25zKG9wdGlvbnMpO1xuICAgICAgICBjb25zdCBlbmNvZGVkRGF0YSA9IGRhdGEgPT0gbnVsbCA/IHVuZGVmaW5lZCA6IEJ1ZmZlci5mcm9tKEpTT04uc3RyaW5naWZ5KGRhdGEpKTtcbiAgICAgICAgaWYgKGVuY29kZWREYXRhICE9IG51bGwpIHtcbiAgICAgICAgICAgIG9wdGlvbnMubWV0aG9kID0gXCJwb3N0XCI7XG4gICAgICAgICAgICBvcHRpb25zLmhlYWRlcnNbXCJDb250ZW50LVR5cGVcIl0gPSBcImFwcGxpY2F0aW9uL2pzb25cIjtcbiAgICAgICAgICAgIG9wdGlvbnMuaGVhZGVyc1tcIkNvbnRlbnQtTGVuZ3RoXCJdID0gZW5jb2RlZERhdGEubGVuZ3RoO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmRvQXBpUmVxdWVzdChvcHRpb25zLCBjYW5jZWxsYXRpb25Ub2tlbiwgaXQgPT4gaXQuZW5kKGVuY29kZWREYXRhKSk7XG4gICAgfVxuICAgIGRvQXBpUmVxdWVzdChvcHRpb25zLCBjYW5jZWxsYXRpb25Ub2tlbiwgcmVxdWVzdFByb2Nlc3NvciwgcmVkaXJlY3RDb3VudCA9IDApIHtcbiAgICAgICAgaWYgKGRlYnVnLmVuYWJsZWQpIHtcbiAgICAgICAgICAgIGRlYnVnKGBSZXF1ZXN0OiAke3NhZmVTdHJpbmdpZnlKc29uKG9wdGlvbnMpfWApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjYW5jZWxsYXRpb25Ub2tlbi5jcmVhdGVQcm9taXNlKChyZXNvbHZlLCByZWplY3QsIG9uQ2FuY2VsKSA9PiB7XG4gICAgICAgICAgICBjb25zdCByZXF1ZXN0ID0gdGhpcy5kb1JlcXVlc3Qob3B0aW9ucywgcmVzcG9uc2UgPT4ge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaGFuZGxlUmVzcG9uc2UocmVzcG9uc2UsIG9wdGlvbnMsIGNhbmNlbGxhdGlvblRva2VuLCByZXNvbHZlLCByZWplY3QsIHJlZGlyZWN0Q291bnQsIHJlcXVlc3RQcm9jZXNzb3IpO1xuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVqZWN0KGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdGhpcy5hZGRFcnJvckFuZFRpbWVvdXRIYW5kbGVycyhyZXF1ZXN0LCByZWplY3QpO1xuICAgICAgICAgICAgdGhpcy5hZGRSZWRpcmVjdEhhbmRsZXJzKHJlcXVlc3QsIG9wdGlvbnMsIHJlamVjdCwgcmVkaXJlY3RDb3VudCwgb3B0aW9ucyA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5kb0FwaVJlcXVlc3Qob3B0aW9ucywgY2FuY2VsbGF0aW9uVG9rZW4sIHJlcXVlc3RQcm9jZXNzb3IsIHJlZGlyZWN0Q291bnQpLnRoZW4ocmVzb2x2ZSkuY2F0Y2gocmVqZWN0KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmVxdWVzdFByb2Nlc3NvcihyZXF1ZXN0LCByZWplY3QpO1xuICAgICAgICAgICAgb25DYW5jZWwoKCkgPT4gcmVxdWVzdC5hYm9ydCgpKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8vIG5vaW5zcGVjdGlvbiBKU1VudXNlZExvY2FsU3ltYm9sc1xuICAgIGFkZFJlZGlyZWN0SGFuZGxlcnMocmVxdWVzdCwgb3B0aW9ucywgcmVqZWN0LCByZWRpcmVjdENvdW50LCBoYW5kbGVyKSB7XG4gICAgICAgIC8vIG5vdCByZXF1aXJlZCBmb3IgTm9kZUpTXG4gICAgfVxuICAgIGFkZEVycm9yQW5kVGltZW91dEhhbmRsZXJzKHJlcXVlc3QsIHJlamVjdCkge1xuICAgICAgICB0aGlzLmFkZFRpbWVPdXRIYW5kbGVyKHJlcXVlc3QsIHJlamVjdCk7XG4gICAgICAgIHJlcXVlc3Qub24oXCJlcnJvclwiLCByZWplY3QpO1xuICAgICAgICByZXF1ZXN0Lm9uKFwiYWJvcnRlZFwiLCAoKSA9PiB7XG4gICAgICAgICAgICByZWplY3QobmV3IEVycm9yKFwiUmVxdWVzdCBoYXMgYmVlbiBhYm9ydGVkIGJ5IHRoZSBzZXJ2ZXJcIikpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgaGFuZGxlUmVzcG9uc2UocmVzcG9uc2UsIG9wdGlvbnMsIGNhbmNlbGxhdGlvblRva2VuLCByZXNvbHZlLCByZWplY3QsIHJlZGlyZWN0Q291bnQsIHJlcXVlc3RQcm9jZXNzb3IpIHtcbiAgICAgICAgaWYgKGRlYnVnLmVuYWJsZWQpIHtcbiAgICAgICAgICAgIGRlYnVnKGBSZXNwb25zZTogJHtyZXNwb25zZS5zdGF0dXNDb2RlfSAke3Jlc3BvbnNlLnN0YXR1c01lc3NhZ2V9LCByZXF1ZXN0IG9wdGlvbnM6ICR7c2FmZVN0cmluZ2lmeUpzb24ob3B0aW9ucyl9YCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gd2UgaGFuZGxlIGFueSBvdGhlciA+PSA0MDAgZXJyb3Igb24gcmVxdWVzdCBlbmQgKHJlYWQgZGV0YWlsZWQgbWVzc2FnZSBpbiB0aGUgcmVzcG9uc2UgYm9keSlcbiAgICAgICAgaWYgKHJlc3BvbnNlLnN0YXR1c0NvZGUgPT09IDQwNCkge1xuICAgICAgICAgICAgLy8gZXJyb3IgaXMgY2xlYXIsIHdlIGRvbid0IG5lZWQgdG8gcmVhZCBkZXRhaWxlZCBlcnJvciBkZXNjcmlwdGlvblxuICAgICAgICAgICAgcmVqZWN0KGNyZWF0ZUh0dHBFcnJvcihyZXNwb25zZSwgYG1ldGhvZDogJHtvcHRpb25zLm1ldGhvZH0gdXJsOiAke29wdGlvbnMucHJvdG9jb2wgfHwgXCJodHRwczpcIn0vLyR7b3B0aW9ucy5ob3N0bmFtZX0ke29wdGlvbnMucGF0aH1cblxuUGxlYXNlIGRvdWJsZSBjaGVjayB0aGF0IHlvdXIgYXV0aGVudGljYXRpb24gdG9rZW4gaXMgY29ycmVjdC4gRHVlIHRvIHNlY3VyaXR5IHJlYXNvbnMgYWN0dWFsIHN0YXR1cyBtYXliZSBub3QgcmVwb3J0ZWQsIGJ1dCA0MDQuXG5gKSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH0gZWxzZSBpZiAocmVzcG9uc2Uuc3RhdHVzQ29kZSA9PT0gMjA0KSB7XG4gICAgICAgICAgICAvLyBvbiBERUxFVEUgcmVxdWVzdFxuICAgICAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJlZGlyZWN0VXJsID0gc2FmZUdldEhlYWRlcihyZXNwb25zZSwgXCJsb2NhdGlvblwiKTtcbiAgICAgICAgaWYgKHJlZGlyZWN0VXJsICE9IG51bGwpIHtcbiAgICAgICAgICAgIGlmIChyZWRpcmVjdENvdW50ID4gMTApIHtcbiAgICAgICAgICAgICAgICByZWplY3QobmV3IEVycm9yKFwiVG9vIG1hbnkgcmVkaXJlY3RzICg+IDEwKVwiKSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5kb0FwaVJlcXVlc3QoSHR0cEV4ZWN1dG9yLnByZXBhcmVSZWRpcmVjdFVybE9wdGlvbnMocmVkaXJlY3RVcmwsIG9wdGlvbnMpLCBjYW5jZWxsYXRpb25Ub2tlbiwgcmVxdWVzdFByb2Nlc3NvciwgcmVkaXJlY3RDb3VudCkudGhlbihyZXNvbHZlKS5jYXRjaChyZWplY3QpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGxldCBkYXRhID0gXCJcIjtcbiAgICAgICAgcmVzcG9uc2Uuc2V0RW5jb2RpbmcoXCJ1dGY4XCIpO1xuICAgICAgICByZXNwb25zZS5vbihcImRhdGFcIiwgY2h1bmsgPT4gZGF0YSArPSBjaHVuayk7XG4gICAgICAgIHJlc3BvbnNlLm9uKFwiZW5kXCIsICgpID0+IHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgaWYgKHJlc3BvbnNlLnN0YXR1c0NvZGUgIT0gbnVsbCAmJiByZXNwb25zZS5zdGF0dXNDb2RlID49IDQwMCkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBjb250ZW50VHlwZSA9IHNhZmVHZXRIZWFkZXIocmVzcG9uc2UsIFwiY29udGVudC10eXBlXCIpO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBpc0pzb24gPSBjb250ZW50VHlwZSAhPSBudWxsICYmIChBcnJheS5pc0FycmF5KGNvbnRlbnRUeXBlKSA/IGNvbnRlbnRUeXBlLmZpbmQoaXQgPT4gaXQuaW5jbHVkZXMoXCJqc29uXCIpKSAhPSBudWxsIDogY29udGVudFR5cGUuaW5jbHVkZXMoXCJqc29uXCIpKTtcbiAgICAgICAgICAgICAgICAgICAgcmVqZWN0KGNyZWF0ZUh0dHBFcnJvcihyZXNwb25zZSwgaXNKc29uID8gSlNPTi5wYXJzZShkYXRhKSA6IGRhdGEpKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXNvbHZlKGRhdGEubGVuZ3RoID09PSAwID8gbnVsbCA6IGRhdGEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICByZWplY3QoZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBkb0Rvd25sb2FkKHJlcXVlc3RPcHRpb25zLCBkZXN0aW5hdGlvbiwgcmVkaXJlY3RDb3VudCwgb3B0aW9ucywgY2FsbGJhY2ssIG9uQ2FuY2VsKSB7XG4gICAgICAgIGNvbnN0IHJlcXVlc3QgPSB0aGlzLmRvUmVxdWVzdChyZXF1ZXN0T3B0aW9ucywgcmVzcG9uc2UgPT4ge1xuICAgICAgICAgICAgaWYgKHJlc3BvbnNlLnN0YXR1c0NvZGUgPj0gNDAwKSB7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2sobmV3IEVycm9yKGBDYW5ub3QgZG93bmxvYWQgXCIke3JlcXVlc3RPcHRpb25zLnByb3RvY29sIHx8IFwiaHR0cHM6XCJ9Ly8ke3JlcXVlc3RPcHRpb25zLmhvc3RuYW1lfSR7cmVxdWVzdE9wdGlvbnMucGF0aH1cIiwgc3RhdHVzICR7cmVzcG9uc2Uuc3RhdHVzQ29kZX06ICR7cmVzcG9uc2Uuc3RhdHVzTWVzc2FnZX1gKSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcmVkaXJlY3RVcmwgPSBzYWZlR2V0SGVhZGVyKHJlc3BvbnNlLCBcImxvY2F0aW9uXCIpO1xuICAgICAgICAgICAgaWYgKHJlZGlyZWN0VXJsICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBpZiAocmVkaXJlY3RDb3VudCA8IHRoaXMubWF4UmVkaXJlY3RzKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZG9Eb3dubG9hZChIdHRwRXhlY3V0b3IucHJlcGFyZVJlZGlyZWN0VXJsT3B0aW9ucyhyZWRpcmVjdFVybCwgcmVxdWVzdE9wdGlvbnMpLCBkZXN0aW5hdGlvbiwgcmVkaXJlY3RDb3VudCsrLCBvcHRpb25zLCBjYWxsYmFjaywgb25DYW5jZWwpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKG5ldyBFcnJvcihgVG9vIG1hbnkgcmVkaXJlY3RzICg+ICR7dGhpcy5tYXhSZWRpcmVjdHN9KWApKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uZmlndXJlUGlwZXMob3B0aW9ucywgcmVzcG9uc2UsIGRlc3RpbmF0aW9uLCBjYWxsYmFjaywgb3B0aW9ucy5jYW5jZWxsYXRpb25Ub2tlbik7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmFkZEVycm9yQW5kVGltZW91dEhhbmRsZXJzKHJlcXVlc3QsIGNhbGxiYWNrKTtcbiAgICAgICAgdGhpcy5hZGRSZWRpcmVjdEhhbmRsZXJzKHJlcXVlc3QsIHJlcXVlc3RPcHRpb25zLCBjYWxsYmFjaywgcmVkaXJlY3RDb3VudCwgcmVxdWVzdE9wdGlvbnMgPT4ge1xuICAgICAgICAgICAgdGhpcy5kb0Rvd25sb2FkKHJlcXVlc3RPcHRpb25zLCBkZXN0aW5hdGlvbiwgcmVkaXJlY3RDb3VudCsrLCBvcHRpb25zLCBjYWxsYmFjaywgb25DYW5jZWwpO1xuICAgICAgICB9KTtcbiAgICAgICAgb25DYW5jZWwoKCkgPT4gcmVxdWVzdC5hYm9ydCgpKTtcbiAgICAgICAgcmVxdWVzdC5lbmQoKTtcbiAgICB9XG4gICAgYWRkVGltZU91dEhhbmRsZXIocmVxdWVzdCwgY2FsbGJhY2spIHtcbiAgICAgICAgcmVxdWVzdC5vbihcInNvY2tldFwiLCBzb2NrZXQgPT4ge1xuICAgICAgICAgICAgc29ja2V0LnNldFRpbWVvdXQoNjAgKiAxMDAwLCAoKSA9PiB7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2sobmV3IEVycm9yKFwiUmVxdWVzdCB0aW1lZCBvdXRcIikpO1xuICAgICAgICAgICAgICAgIHJlcXVlc3QuYWJvcnQoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgc3RhdGljIHByZXBhcmVSZWRpcmVjdFVybE9wdGlvbnMocmVkaXJlY3RVcmwsIG9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgbmV3T3B0aW9ucyA9IGNvbmZpZ3VyZVJlcXVlc3RPcHRpb25zRnJvbVVybChyZWRpcmVjdFVybCwgT2JqZWN0LmFzc2lnbih7fSwgb3B0aW9ucykpO1xuICAgICAgICBpZiAobmV3T3B0aW9ucy5oZWFkZXJzICE9IG51bGwgJiYgbmV3T3B0aW9ucy5oZWFkZXJzLkF1dGhvcml6YXRpb24gIT0gbnVsbCAmJiBuZXdPcHRpb25zLmhlYWRlcnMuQXV0aG9yaXphdGlvbi5zdGFydHNXaXRoKFwidG9rZW5cIikpIHtcbiAgICAgICAgICAgIGNvbnN0IHBhcnNlZE5ld1VybCA9IG5ldyAoX3VybCB8fCBfbG9hZF91cmwoKSkuVVJMKHJlZGlyZWN0VXJsKTtcbiAgICAgICAgICAgIGlmIChwYXJzZWROZXdVcmwuaG9zdG5hbWUuZW5kc1dpdGgoXCIuYW1hem9uYXdzLmNvbVwiKSkge1xuICAgICAgICAgICAgICAgIGRlbGV0ZSBuZXdPcHRpb25zLmhlYWRlcnMuQXV0aG9yaXphdGlvbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3T3B0aW9ucztcbiAgICB9XG59XG5leHBvcnRzLkh0dHBFeGVjdXRvciA9IEh0dHBFeGVjdXRvcjtcbmZ1bmN0aW9uIGNvbmZpZ3VyZVJlcXVlc3RPcHRpb25zRnJvbVVybCh1cmwsIG9wdGlvbnMpIHtcbiAgICBjb25zdCBwYXJzZWRVcmwgPSAoMCwgKF91cmwgfHwgX2xvYWRfdXJsKCkpLnBhcnNlKSh1cmwpO1xuICAgIG9wdGlvbnMucHJvdG9jb2wgPSBwYXJzZWRVcmwucHJvdG9jb2w7XG4gICAgb3B0aW9ucy5ob3N0bmFtZSA9IHBhcnNlZFVybC5ob3N0bmFtZTtcbiAgICBpZiAocGFyc2VkVXJsLnBvcnQgPT0gbnVsbCkge1xuICAgICAgICBpZiAob3B0aW9ucy5wb3J0ICE9IG51bGwpIHtcbiAgICAgICAgICAgIGRlbGV0ZSBvcHRpb25zLnBvcnQ7XG4gICAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgICBvcHRpb25zLnBvcnQgPSBwYXJzZWRVcmwucG9ydDtcbiAgICB9XG4gICAgb3B0aW9ucy5wYXRoID0gcGFyc2VkVXJsLnBhdGg7XG4gICAgcmV0dXJuIGNvbmZpZ3VyZVJlcXVlc3RPcHRpb25zKG9wdGlvbnMpO1xufVxuY2xhc3MgRGlnZXN0VHJhbnNmb3JtIGV4dGVuZHMgKF9zdHJlYW0gfHwgX2xvYWRfc3RyZWFtKCkpLlRyYW5zZm9ybSB7XG4gICAgY29uc3RydWN0b3IoZXhwZWN0ZWQsIGFsZ29yaXRobSA9IFwic2hhNTEyXCIsIGVuY29kaW5nID0gXCJiYXNlNjRcIikge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLmV4cGVjdGVkID0gZXhwZWN0ZWQ7XG4gICAgICAgIHRoaXMuYWxnb3JpdGhtID0gYWxnb3JpdGhtO1xuICAgICAgICB0aGlzLmVuY29kaW5nID0gZW5jb2Rpbmc7XG4gICAgICAgIHRoaXMuaXNWYWxpZGF0ZU9uRW5kID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5kaWdlc3RlciA9ICgwLCAoX2NyeXB0byB8fCBfbG9hZF9jcnlwdG8oKSkuY3JlYXRlSGFzaCkoYWxnb3JpdGhtKTtcbiAgICB9XG4gICAgLy8gbm9pbnNwZWN0aW9uIEpTVW51c2VkR2xvYmFsU3ltYm9sc1xuICAgIGdldCBhY3R1YWwoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9hY3R1YWw7XG4gICAgfVxuICAgIC8vIG5vaW5zcGVjdGlvbiBKU1VudXNlZEdsb2JhbFN5bWJvbHNcbiAgICBfdHJhbnNmb3JtKGNodW5rLCBlbmNvZGluZywgY2FsbGJhY2spIHtcbiAgICAgICAgdGhpcy5kaWdlc3Rlci51cGRhdGUoY2h1bmspO1xuICAgICAgICBjYWxsYmFjayhudWxsLCBjaHVuayk7XG4gICAgfVxuICAgIC8vIG5vaW5zcGVjdGlvbiBKU1VudXNlZEdsb2JhbFN5bWJvbHNcbiAgICBfZmx1c2goY2FsbGJhY2spIHtcbiAgICAgICAgdGhpcy5fYWN0dWFsID0gdGhpcy5kaWdlc3Rlci5kaWdlc3QodGhpcy5lbmNvZGluZyk7XG4gICAgICAgIGlmICh0aGlzLmlzVmFsaWRhdGVPbkVuZCkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICB0aGlzLnZhbGlkYXRlKCk7XG4gICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2soZSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNhbGxiYWNrKG51bGwpO1xuICAgIH1cbiAgICB2YWxpZGF0ZSgpIHtcbiAgICAgICAgaWYgKHRoaXMuX2FjdHVhbCA9PSBudWxsKSB7XG4gICAgICAgICAgICB0aHJvdyAoMCwgKF9pbmRleCB8fCBfbG9hZF9pbmRleCgpKS5uZXdFcnJvcikoXCJOb3QgZmluaXNoZWQgeWV0XCIsIFwiRVJSX1NUUkVBTV9OT1RfRklOSVNIRURcIik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuX2FjdHVhbCAhPT0gdGhpcy5leHBlY3RlZCkge1xuICAgICAgICAgICAgdGhyb3cgKDAsIChfaW5kZXggfHwgX2xvYWRfaW5kZXgoKSkubmV3RXJyb3IpKGAke3RoaXMuYWxnb3JpdGhtfSBjaGVja3N1bSBtaXNtYXRjaCwgZXhwZWN0ZWQgJHt0aGlzLmV4cGVjdGVkfSwgZ290ICR7dGhpcy5fYWN0dWFsfWAsIFwiRVJSX0NIRUNLU1VNX01JU01BVENIXCIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbn1cbmV4cG9ydHMuRGlnZXN0VHJhbnNmb3JtID0gRGlnZXN0VHJhbnNmb3JtO1xuZnVuY3Rpb24gY2hlY2tTaGEyKHNoYTJIZWFkZXIsIHNoYTIsIGNhbGxiYWNrKSB7XG4gICAgaWYgKHNoYTJIZWFkZXIgIT0gbnVsbCAmJiBzaGEyICE9IG51bGwpIHtcbiAgICAgICAgLy8gdG9kbyB3aHkgYmludHJheSBkb2Vzbid0IHNlbmQgdGhpcyBoZWFkZXIgYWx3YXlzXG4gICAgICAgIGlmIChzaGEySGVhZGVyID09IG51bGwpIHtcbiAgICAgICAgICAgIGNhbGxiYWNrKG5ldyBFcnJvcihcImNoZWNrc3VtIGlzIHJlcXVpcmVkLCBidXQgc2VydmVyIHJlc3BvbnNlIGRvZXNuJ3QgY29udGFpbiBYLUNoZWNrc3VtLVNoYTIgaGVhZGVyXCIpKTtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfSBlbHNlIGlmIChzaGEySGVhZGVyICE9PSBzaGEyKSB7XG4gICAgICAgICAgICBjYWxsYmFjayhuZXcgRXJyb3IoYGNoZWNrc3VtIG1pc21hdGNoOiBleHBlY3RlZCAke3NoYTJ9IGJ1dCBnb3QgJHtzaGEySGVhZGVyfSAoWC1DaGVja3N1bS1TaGEyIGhlYWRlcilgKSk7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG59XG5mdW5jdGlvbiBzYWZlR2V0SGVhZGVyKHJlc3BvbnNlLCBoZWFkZXJLZXkpIHtcbiAgICBjb25zdCB2YWx1ZSA9IHJlc3BvbnNlLmhlYWRlcnNbaGVhZGVyS2V5XTtcbiAgICBpZiAodmFsdWUgPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgIC8vIGVsZWN0cm9uIEFQSVxuICAgICAgICByZXR1cm4gdmFsdWUubGVuZ3RoID09PSAwID8gbnVsbCA6IHZhbHVlW3ZhbHVlLmxlbmd0aCAtIDFdO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG59XG5mdW5jdGlvbiBjb25maWd1cmVQaXBlcyhvcHRpb25zLCByZXNwb25zZSwgZGVzdGluYXRpb24sIGNhbGxiYWNrLCBjYW5jZWxsYXRpb25Ub2tlbikge1xuICAgIGlmICghY2hlY2tTaGEyKHNhZmVHZXRIZWFkZXIocmVzcG9uc2UsIFwiWC1DaGVja3N1bS1TaGEyXCIpLCBvcHRpb25zLnNoYTIsIGNhbGxiYWNrKSkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHN0cmVhbXMgPSBbXTtcbiAgICBpZiAob3B0aW9ucy5vblByb2dyZXNzICE9IG51bGwpIHtcbiAgICAgICAgY29uc3QgY29udGVudExlbmd0aCA9IHNhZmVHZXRIZWFkZXIocmVzcG9uc2UsIFwiY29udGVudC1sZW5ndGhcIik7XG4gICAgICAgIGlmIChjb250ZW50TGVuZ3RoICE9IG51bGwpIHtcbiAgICAgICAgICAgIHN0cmVhbXMucHVzaChuZXcgKF9Qcm9ncmVzc0NhbGxiYWNrVHJhbnNmb3JtIHx8IF9sb2FkX1Byb2dyZXNzQ2FsbGJhY2tUcmFuc2Zvcm0oKSkuUHJvZ3Jlc3NDYWxsYmFja1RyYW5zZm9ybShwYXJzZUludChjb250ZW50TGVuZ3RoLCAxMCksIG9wdGlvbnMuY2FuY2VsbGF0aW9uVG9rZW4sIG9wdGlvbnMub25Qcm9ncmVzcykpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNvbnN0IHNoYTUxMiA9IG9wdGlvbnMuc2hhNTEyO1xuICAgIGlmIChzaGE1MTIgIT0gbnVsbCkge1xuICAgICAgICBzdHJlYW1zLnB1c2gobmV3IERpZ2VzdFRyYW5zZm9ybShzaGE1MTIsIFwic2hhNTEyXCIsIHNoYTUxMi5sZW5ndGggPT09IDEyOCAmJiAhc2hhNTEyLmluY2x1ZGVzKFwiK1wiKSAmJiAhc2hhNTEyLmluY2x1ZGVzKFwiWlwiKSAmJiAhc2hhNTEyLmluY2x1ZGVzKFwiPVwiKSA/IFwiaGV4XCIgOiBcImJhc2U2NFwiKSk7XG4gICAgfSBlbHNlIGlmIChvcHRpb25zLnNoYTIgIT0gbnVsbCkge1xuICAgICAgICBzdHJlYW1zLnB1c2gobmV3IERpZ2VzdFRyYW5zZm9ybShvcHRpb25zLnNoYTIsIFwic2hhMjU2XCIsIFwiaGV4XCIpKTtcbiAgICB9XG4gICAgY29uc3QgZmlsZU91dCA9ICgwLCAoX2ZzRXh0cmFQIHx8IF9sb2FkX2ZzRXh0cmFQKCkpLmNyZWF0ZVdyaXRlU3RyZWFtKShkZXN0aW5hdGlvbik7XG4gICAgc3RyZWFtcy5wdXNoKGZpbGVPdXQpO1xuICAgIGxldCBsYXN0U3RyZWFtID0gcmVzcG9uc2U7XG4gICAgZm9yIChjb25zdCBzdHJlYW0gb2Ygc3RyZWFtcykge1xuICAgICAgICBzdHJlYW0ub24oXCJlcnJvclwiLCBlcnJvciA9PiB7XG4gICAgICAgICAgICBpZiAoIWNhbmNlbGxhdGlvblRva2VuLmNhbmNlbGxlZCkge1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrKGVycm9yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGxhc3RTdHJlYW0gPSBsYXN0U3RyZWFtLnBpcGUoc3RyZWFtKTtcbiAgICB9XG4gICAgZmlsZU91dC5vbihcImZpbmlzaFwiLCAoKSA9PiB7XG4gICAgICAgIGZpbGVPdXQuY2xvc2UoY2FsbGJhY2spO1xuICAgIH0pO1xufVxuZnVuY3Rpb24gY29uZmlndXJlUmVxdWVzdE9wdGlvbnMob3B0aW9ucywgdG9rZW4sIG1ldGhvZCkge1xuICAgIGlmIChtZXRob2QgIT0gbnVsbCkge1xuICAgICAgICBvcHRpb25zLm1ldGhvZCA9IG1ldGhvZDtcbiAgICB9XG4gICAgbGV0IGhlYWRlcnMgPSBvcHRpb25zLmhlYWRlcnM7XG4gICAgaWYgKGhlYWRlcnMgPT0gbnVsbCkge1xuICAgICAgICBoZWFkZXJzID0ge307XG4gICAgICAgIG9wdGlvbnMuaGVhZGVycyA9IGhlYWRlcnM7XG4gICAgfVxuICAgIGlmICh0b2tlbiAhPSBudWxsKSB7XG4gICAgICAgIGhlYWRlcnMuYXV0aG9yaXphdGlvbiA9IHRva2VuLnN0YXJ0c1dpdGgoXCJCYXNpY1wiKSA/IHRva2VuIDogYHRva2VuICR7dG9rZW59YDtcbiAgICB9XG4gICAgaWYgKGhlYWRlcnNbXCJVc2VyLUFnZW50XCJdID09IG51bGwpIHtcbiAgICAgICAgaGVhZGVyc1tcIlVzZXItQWdlbnRcIl0gPSBcImVsZWN0cm9uLWJ1aWxkZXJcIjtcbiAgICB9XG4gICAgaWYgKG1ldGhvZCA9PSBudWxsIHx8IG1ldGhvZCA9PT0gXCJHRVRcIiB8fCBoZWFkZXJzW1wiQ2FjaGUtQ29udHJvbFwiXSA9PSBudWxsKSB7XG4gICAgICAgIGhlYWRlcnNbXCJDYWNoZS1Db250cm9sXCJdID0gXCJuby1jYWNoZVwiO1xuICAgIH1cbiAgICAvLyBkbyBub3Qgc3BlY2lmeSBmb3Igbm9kZSAoaW4gYW55IGNhc2Ugd2UgdXNlIGh0dHBzIG1vZHVsZSlcbiAgICBpZiAob3B0aW9ucy5wcm90b2NvbCA9PSBudWxsICYmIHByb2Nlc3MudmVyc2lvbnMuZWxlY3Ryb24gIT0gbnVsbCkge1xuICAgICAgICBvcHRpb25zLnByb3RvY29sID0gXCJodHRwczpcIjtcbiAgICB9XG4gICAgcmV0dXJuIG9wdGlvbnM7XG59XG5mdW5jdGlvbiBzYWZlU3RyaW5naWZ5SnNvbihkYXRhLCBza2lwcGVkTmFtZXMpIHtcbiAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkoZGF0YSwgKG5hbWUsIHZhbHVlKSA9PiB7XG4gICAgICAgIGlmIChuYW1lLmVuZHNXaXRoKFwiYXV0aG9yaXphdGlvblwiKSB8fCBuYW1lLmVuZHNXaXRoKFwiUGFzc3dvcmRcIikgfHwgbmFtZS5lbmRzV2l0aChcIlBBU1NXT1JEXCIpIHx8IG5hbWUuZW5kc1dpdGgoXCJUb2tlblwiKSB8fCBuYW1lLmluY2x1ZGVzKFwicGFzc3dvcmRcIikgfHwgbmFtZS5pbmNsdWRlcyhcInRva2VuXCIpIHx8IHNraXBwZWROYW1lcyAhPSBudWxsICYmIHNraXBwZWROYW1lcy5oYXMobmFtZSkpIHtcbiAgICAgICAgICAgIHJldHVybiBcIjxzdHJpcHBlZCBzZW5zaXRpdmUgZGF0YT5cIjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfSwgMik7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1odHRwRXhlY3V0b3IuanMubWFwXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2VsZWN0cm9uLXVwZGF0ZXIvbm9kZV9tb2R1bGVzL2J1aWxkZXItdXRpbC1ydW50aW1lL291dC9odHRwRXhlY3V0b3IuanMiLCJcbi8qKlxuICogVGhpcyBpcyB0aGUgY29tbW9uIGxvZ2ljIGZvciBib3RoIHRoZSBOb2RlLmpzIGFuZCB3ZWIgYnJvd3NlclxuICogaW1wbGVtZW50YXRpb25zIG9mIGBkZWJ1ZygpYC5cbiAqXG4gKiBFeHBvc2UgYGRlYnVnKClgIGFzIHRoZSBtb2R1bGUuXG4gKi9cblxuZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gY3JlYXRlRGVidWcuZGVidWcgPSBjcmVhdGVEZWJ1Z1snZGVmYXVsdCddID0gY3JlYXRlRGVidWc7XG5leHBvcnRzLmNvZXJjZSA9IGNvZXJjZTtcbmV4cG9ydHMuZGlzYWJsZSA9IGRpc2FibGU7XG5leHBvcnRzLmVuYWJsZSA9IGVuYWJsZTtcbmV4cG9ydHMuZW5hYmxlZCA9IGVuYWJsZWQ7XG5leHBvcnRzLmh1bWFuaXplID0gcmVxdWlyZSgnbXMnKTtcblxuLyoqXG4gKiBBY3RpdmUgYGRlYnVnYCBpbnN0YW5jZXMuXG4gKi9cbmV4cG9ydHMuaW5zdGFuY2VzID0gW107XG5cbi8qKlxuICogVGhlIGN1cnJlbnRseSBhY3RpdmUgZGVidWcgbW9kZSBuYW1lcywgYW5kIG5hbWVzIHRvIHNraXAuXG4gKi9cblxuZXhwb3J0cy5uYW1lcyA9IFtdO1xuZXhwb3J0cy5za2lwcyA9IFtdO1xuXG4vKipcbiAqIE1hcCBvZiBzcGVjaWFsIFwiJW5cIiBoYW5kbGluZyBmdW5jdGlvbnMsIGZvciB0aGUgZGVidWcgXCJmb3JtYXRcIiBhcmd1bWVudC5cbiAqXG4gKiBWYWxpZCBrZXkgbmFtZXMgYXJlIGEgc2luZ2xlLCBsb3dlciBvciB1cHBlci1jYXNlIGxldHRlciwgaS5lLiBcIm5cIiBhbmQgXCJOXCIuXG4gKi9cblxuZXhwb3J0cy5mb3JtYXR0ZXJzID0ge307XG5cbi8qKlxuICogU2VsZWN0IGEgY29sb3IuXG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZXNwYWNlXG4gKiBAcmV0dXJuIHtOdW1iZXJ9XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBzZWxlY3RDb2xvcihuYW1lc3BhY2UpIHtcbiAgdmFyIGhhc2ggPSAwLCBpO1xuXG4gIGZvciAoaSBpbiBuYW1lc3BhY2UpIHtcbiAgICBoYXNoICA9ICgoaGFzaCA8PCA1KSAtIGhhc2gpICsgbmFtZXNwYWNlLmNoYXJDb2RlQXQoaSk7XG4gICAgaGFzaCB8PSAwOyAvLyBDb252ZXJ0IHRvIDMyYml0IGludGVnZXJcbiAgfVxuXG4gIHJldHVybiBleHBvcnRzLmNvbG9yc1tNYXRoLmFicyhoYXNoKSAlIGV4cG9ydHMuY29sb3JzLmxlbmd0aF07XG59XG5cbi8qKlxuICogQ3JlYXRlIGEgZGVidWdnZXIgd2l0aCB0aGUgZ2l2ZW4gYG5hbWVzcGFjZWAuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IG5hbWVzcGFjZVxuICogQHJldHVybiB7RnVuY3Rpb259XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIGNyZWF0ZURlYnVnKG5hbWVzcGFjZSkge1xuXG4gIHZhciBwcmV2VGltZTtcblxuICBmdW5jdGlvbiBkZWJ1ZygpIHtcbiAgICAvLyBkaXNhYmxlZD9cbiAgICBpZiAoIWRlYnVnLmVuYWJsZWQpIHJldHVybjtcblxuICAgIHZhciBzZWxmID0gZGVidWc7XG5cbiAgICAvLyBzZXQgYGRpZmZgIHRpbWVzdGFtcFxuICAgIHZhciBjdXJyID0gK25ldyBEYXRlKCk7XG4gICAgdmFyIG1zID0gY3VyciAtIChwcmV2VGltZSB8fCBjdXJyKTtcbiAgICBzZWxmLmRpZmYgPSBtcztcbiAgICBzZWxmLnByZXYgPSBwcmV2VGltZTtcbiAgICBzZWxmLmN1cnIgPSBjdXJyO1xuICAgIHByZXZUaW1lID0gY3VycjtcblxuICAgIC8vIHR1cm4gdGhlIGBhcmd1bWVudHNgIGludG8gYSBwcm9wZXIgQXJyYXlcbiAgICB2YXIgYXJncyA9IG5ldyBBcnJheShhcmd1bWVudHMubGVuZ3RoKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFyZ3MubGVuZ3RoOyBpKyspIHtcbiAgICAgIGFyZ3NbaV0gPSBhcmd1bWVudHNbaV07XG4gICAgfVxuXG4gICAgYXJnc1swXSA9IGV4cG9ydHMuY29lcmNlKGFyZ3NbMF0pO1xuXG4gICAgaWYgKCdzdHJpbmcnICE9PSB0eXBlb2YgYXJnc1swXSkge1xuICAgICAgLy8gYW55dGhpbmcgZWxzZSBsZXQncyBpbnNwZWN0IHdpdGggJU9cbiAgICAgIGFyZ3MudW5zaGlmdCgnJU8nKTtcbiAgICB9XG5cbiAgICAvLyBhcHBseSBhbnkgYGZvcm1hdHRlcnNgIHRyYW5zZm9ybWF0aW9uc1xuICAgIHZhciBpbmRleCA9IDA7XG4gICAgYXJnc1swXSA9IGFyZ3NbMF0ucmVwbGFjZSgvJShbYS16QS1aJV0pL2csIGZ1bmN0aW9uKG1hdGNoLCBmb3JtYXQpIHtcbiAgICAgIC8vIGlmIHdlIGVuY291bnRlciBhbiBlc2NhcGVkICUgdGhlbiBkb24ndCBpbmNyZWFzZSB0aGUgYXJyYXkgaW5kZXhcbiAgICAgIGlmIChtYXRjaCA9PT0gJyUlJykgcmV0dXJuIG1hdGNoO1xuICAgICAgaW5kZXgrKztcbiAgICAgIHZhciBmb3JtYXR0ZXIgPSBleHBvcnRzLmZvcm1hdHRlcnNbZm9ybWF0XTtcbiAgICAgIGlmICgnZnVuY3Rpb24nID09PSB0eXBlb2YgZm9ybWF0dGVyKSB7XG4gICAgICAgIHZhciB2YWwgPSBhcmdzW2luZGV4XTtcbiAgICAgICAgbWF0Y2ggPSBmb3JtYXR0ZXIuY2FsbChzZWxmLCB2YWwpO1xuXG4gICAgICAgIC8vIG5vdyB3ZSBuZWVkIHRvIHJlbW92ZSBgYXJnc1tpbmRleF1gIHNpbmNlIGl0J3MgaW5saW5lZCBpbiB0aGUgYGZvcm1hdGBcbiAgICAgICAgYXJncy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICBpbmRleC0tO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG1hdGNoO1xuICAgIH0pO1xuXG4gICAgLy8gYXBwbHkgZW52LXNwZWNpZmljIGZvcm1hdHRpbmcgKGNvbG9ycywgZXRjLilcbiAgICBleHBvcnRzLmZvcm1hdEFyZ3MuY2FsbChzZWxmLCBhcmdzKTtcblxuICAgIHZhciBsb2dGbiA9IGRlYnVnLmxvZyB8fCBleHBvcnRzLmxvZyB8fCBjb25zb2xlLmxvZy5iaW5kKGNvbnNvbGUpO1xuICAgIGxvZ0ZuLmFwcGx5KHNlbGYsIGFyZ3MpO1xuICB9XG5cbiAgZGVidWcubmFtZXNwYWNlID0gbmFtZXNwYWNlO1xuICBkZWJ1Zy5lbmFibGVkID0gZXhwb3J0cy5lbmFibGVkKG5hbWVzcGFjZSk7XG4gIGRlYnVnLnVzZUNvbG9ycyA9IGV4cG9ydHMudXNlQ29sb3JzKCk7XG4gIGRlYnVnLmNvbG9yID0gc2VsZWN0Q29sb3IobmFtZXNwYWNlKTtcbiAgZGVidWcuZGVzdHJveSA9IGRlc3Ryb3k7XG5cbiAgLy8gZW52LXNwZWNpZmljIGluaXRpYWxpemF0aW9uIGxvZ2ljIGZvciBkZWJ1ZyBpbnN0YW5jZXNcbiAgaWYgKCdmdW5jdGlvbicgPT09IHR5cGVvZiBleHBvcnRzLmluaXQpIHtcbiAgICBleHBvcnRzLmluaXQoZGVidWcpO1xuICB9XG5cbiAgZXhwb3J0cy5pbnN0YW5jZXMucHVzaChkZWJ1Zyk7XG5cbiAgcmV0dXJuIGRlYnVnO1xufVxuXG5mdW5jdGlvbiBkZXN0cm95ICgpIHtcbiAgdmFyIGluZGV4ID0gZXhwb3J0cy5pbnN0YW5jZXMuaW5kZXhPZih0aGlzKTtcbiAgaWYgKGluZGV4ICE9PSAtMSkge1xuICAgIGV4cG9ydHMuaW5zdGFuY2VzLnNwbGljZShpbmRleCwgMSk7XG4gICAgcmV0dXJuIHRydWU7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59XG5cbi8qKlxuICogRW5hYmxlcyBhIGRlYnVnIG1vZGUgYnkgbmFtZXNwYWNlcy4gVGhpcyBjYW4gaW5jbHVkZSBtb2Rlc1xuICogc2VwYXJhdGVkIGJ5IGEgY29sb24gYW5kIHdpbGRjYXJkcy5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZXNwYWNlc1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBlbmFibGUobmFtZXNwYWNlcykge1xuICBleHBvcnRzLnNhdmUobmFtZXNwYWNlcyk7XG5cbiAgZXhwb3J0cy5uYW1lcyA9IFtdO1xuICBleHBvcnRzLnNraXBzID0gW107XG5cbiAgdmFyIGk7XG4gIHZhciBzcGxpdCA9ICh0eXBlb2YgbmFtZXNwYWNlcyA9PT0gJ3N0cmluZycgPyBuYW1lc3BhY2VzIDogJycpLnNwbGl0KC9bXFxzLF0rLyk7XG4gIHZhciBsZW4gPSBzcGxpdC5sZW5ndGg7XG5cbiAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgaWYgKCFzcGxpdFtpXSkgY29udGludWU7IC8vIGlnbm9yZSBlbXB0eSBzdHJpbmdzXG4gICAgbmFtZXNwYWNlcyA9IHNwbGl0W2ldLnJlcGxhY2UoL1xcKi9nLCAnLio/Jyk7XG4gICAgaWYgKG5hbWVzcGFjZXNbMF0gPT09ICctJykge1xuICAgICAgZXhwb3J0cy5za2lwcy5wdXNoKG5ldyBSZWdFeHAoJ14nICsgbmFtZXNwYWNlcy5zdWJzdHIoMSkgKyAnJCcpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZXhwb3J0cy5uYW1lcy5wdXNoKG5ldyBSZWdFeHAoJ14nICsgbmFtZXNwYWNlcyArICckJykpO1xuICAgIH1cbiAgfVxuXG4gIGZvciAoaSA9IDA7IGkgPCBleHBvcnRzLmluc3RhbmNlcy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBpbnN0YW5jZSA9IGV4cG9ydHMuaW5zdGFuY2VzW2ldO1xuICAgIGluc3RhbmNlLmVuYWJsZWQgPSBleHBvcnRzLmVuYWJsZWQoaW5zdGFuY2UubmFtZXNwYWNlKTtcbiAgfVxufVxuXG4vKipcbiAqIERpc2FibGUgZGVidWcgb3V0cHV0LlxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gZGlzYWJsZSgpIHtcbiAgZXhwb3J0cy5lbmFibGUoJycpO1xufVxuXG4vKipcbiAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgZ2l2ZW4gbW9kZSBuYW1lIGlzIGVuYWJsZWQsIGZhbHNlIG90aGVyd2lzZS5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZVxuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gZW5hYmxlZChuYW1lKSB7XG4gIGlmIChuYW1lW25hbWUubGVuZ3RoIC0gMV0gPT09ICcqJykge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHZhciBpLCBsZW47XG4gIGZvciAoaSA9IDAsIGxlbiA9IGV4cG9ydHMuc2tpcHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICBpZiAoZXhwb3J0cy5za2lwc1tpXS50ZXN0KG5hbWUpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG4gIGZvciAoaSA9IDAsIGxlbiA9IGV4cG9ydHMubmFtZXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICBpZiAoZXhwb3J0cy5uYW1lc1tpXS50ZXN0KG5hbWUpKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG4vKipcbiAqIENvZXJjZSBgdmFsYC5cbiAqXG4gKiBAcGFyYW0ge01peGVkfSB2YWxcbiAqIEByZXR1cm4ge01peGVkfVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gY29lcmNlKHZhbCkge1xuICBpZiAodmFsIGluc3RhbmNlb2YgRXJyb3IpIHJldHVybiB2YWwuc3RhY2sgfHwgdmFsLm1lc3NhZ2U7XG4gIHJldHVybiB2YWw7XG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvZWxlY3Ryb24tdXBkYXRlci9ub2RlX21vZHVsZXMvZGVidWcvc3JjL2RlYnVnLmpzIiwiLy8gVGhpcyBpcyBhZGFwdGVkIGZyb20gaHR0cHM6Ly9naXRodWIuY29tL25vcm1hbGl6ZS9telxuLy8gQ29weXJpZ2h0IChjKSAyMDE0LTIwMTYgSm9uYXRoYW4gT25nIG1lQGpvbmdsZWJlcnJ5LmNvbSBhbmQgQ29udHJpYnV0b3JzXG5jb25zdCB1ID0gcmVxdWlyZSgndW5pdmVyc2FsaWZ5JykuZnJvbUNhbGxiYWNrXG5jb25zdCBmcyA9IHJlcXVpcmUoJ2dyYWNlZnVsLWZzJylcblxuY29uc3QgYXBpID0gW1xuICAnYWNjZXNzJyxcbiAgJ2FwcGVuZEZpbGUnLFxuICAnY2htb2QnLFxuICAnY2hvd24nLFxuICAnY2xvc2UnLFxuICAnY29weUZpbGUnLFxuICAnZmNobW9kJyxcbiAgJ2ZjaG93bicsXG4gICdmZGF0YXN5bmMnLFxuICAnZnN0YXQnLFxuICAnZnN5bmMnLFxuICAnZnRydW5jYXRlJyxcbiAgJ2Z1dGltZXMnLFxuICAnbGNob3duJyxcbiAgJ2xpbmsnLFxuICAnbHN0YXQnLFxuICAnbWtkaXInLFxuICAnbWtkdGVtcCcsXG4gICdvcGVuJyxcbiAgJ3JlYWRGaWxlJyxcbiAgJ3JlYWRkaXInLFxuICAncmVhZGxpbmsnLFxuICAncmVhbHBhdGgnLFxuICAncmVuYW1lJyxcbiAgJ3JtZGlyJyxcbiAgJ3N0YXQnLFxuICAnc3ltbGluaycsXG4gICd0cnVuY2F0ZScsXG4gICd1bmxpbmsnLFxuICAndXRpbWVzJyxcbiAgJ3dyaXRlRmlsZSdcbl0uZmlsdGVyKGtleSA9PiB7XG4gIC8vIFNvbWUgY29tbWFuZHMgYXJlIG5vdCBhdmFpbGFibGUgb24gc29tZSBzeXN0ZW1zLiBFeDpcbiAgLy8gZnMuY29weUZpbGUgd2FzIGFkZGVkIGluIE5vZGUuanMgdjguNS4wXG4gIC8vIGZzLm1rZHRlbXAgd2FzIGFkZGVkIGluIE5vZGUuanMgdjUuMTAuMFxuICAvLyBmcy5sY2hvd24gaXMgbm90IGF2YWlsYWJsZSBvbiBhdCBsZWFzdCBzb21lIExpbnV4XG4gIHJldHVybiB0eXBlb2YgZnNba2V5XSA9PT0gJ2Z1bmN0aW9uJ1xufSlcblxuLy8gRXhwb3J0IGFsbCBrZXlzOlxuT2JqZWN0LmtleXMoZnMpLmZvckVhY2goa2V5ID0+IHtcbiAgZXhwb3J0c1trZXldID0gZnNba2V5XVxufSlcblxuLy8gVW5pdmVyc2FsaWZ5IGFzeW5jIG1ldGhvZHM6XG5hcGkuZm9yRWFjaChtZXRob2QgPT4ge1xuICBleHBvcnRzW21ldGhvZF0gPSB1KGZzW21ldGhvZF0pXG59KVxuXG4vLyBXZSBkaWZmZXIgZnJvbSBtei9mcyBpbiB0aGF0IHdlIHN0aWxsIHNoaXAgdGhlIG9sZCwgYnJva2VuLCBmcy5leGlzdHMoKVxuLy8gc2luY2Ugd2UgYXJlIGEgZHJvcC1pbiByZXBsYWNlbWVudCBmb3IgdGhlIG5hdGl2ZSBtb2R1bGVcbmV4cG9ydHMuZXhpc3RzID0gZnVuY3Rpb24gKGZpbGVuYW1lLCBjYWxsYmFjaykge1xuICBpZiAodHlwZW9mIGNhbGxiYWNrID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIGZzLmV4aXN0cyhmaWxlbmFtZSwgY2FsbGJhY2spXG4gIH1cbiAgcmV0dXJuIG5ldyBQcm9taXNlKHJlc29sdmUgPT4ge1xuICAgIHJldHVybiBmcy5leGlzdHMoZmlsZW5hbWUsIHJlc29sdmUpXG4gIH0pXG59XG5cbi8vIGZzLnJlYWQoKSAmIGZzLndyaXRlIG5lZWQgc3BlY2lhbCB0cmVhdG1lbnQgZHVlIHRvIG11bHRpcGxlIGNhbGxiYWNrIGFyZ3NcblxuZXhwb3J0cy5yZWFkID0gZnVuY3Rpb24gKGZkLCBidWZmZXIsIG9mZnNldCwgbGVuZ3RoLCBwb3NpdGlvbiwgY2FsbGJhY2spIHtcbiAgaWYgKHR5cGVvZiBjYWxsYmFjayA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiBmcy5yZWFkKGZkLCBidWZmZXIsIG9mZnNldCwgbGVuZ3RoLCBwb3NpdGlvbiwgY2FsbGJhY2spXG4gIH1cbiAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICBmcy5yZWFkKGZkLCBidWZmZXIsIG9mZnNldCwgbGVuZ3RoLCBwb3NpdGlvbiwgKGVyciwgYnl0ZXNSZWFkLCBidWZmZXIpID0+IHtcbiAgICAgIGlmIChlcnIpIHJldHVybiByZWplY3QoZXJyKVxuICAgICAgcmVzb2x2ZSh7IGJ5dGVzUmVhZCwgYnVmZmVyIH0pXG4gICAgfSlcbiAgfSlcbn1cblxuLy8gRnVuY3Rpb24gc2lnbmF0dXJlIGNhbiBiZVxuLy8gZnMud3JpdGUoZmQsIGJ1ZmZlclssIG9mZnNldFssIGxlbmd0aFssIHBvc2l0aW9uXV1dLCBjYWxsYmFjaylcbi8vIE9SXG4vLyBmcy53cml0ZShmZCwgc3RyaW5nWywgcG9zaXRpb25bLCBlbmNvZGluZ11dLCBjYWxsYmFjaylcbi8vIHNvIHdlIG5lZWQgdG8gaGFuZGxlIGJvdGggY2FzZXNcbmV4cG9ydHMud3JpdGUgPSBmdW5jdGlvbiAoZmQsIGJ1ZmZlciwgYSwgYiwgYywgY2FsbGJhY2spIHtcbiAgaWYgKHR5cGVvZiBhcmd1bWVudHNbYXJndW1lbnRzLmxlbmd0aCAtIDFdID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIGZzLndyaXRlKGZkLCBidWZmZXIsIGEsIGIsIGMsIGNhbGxiYWNrKVxuICB9XG5cbiAgLy8gQ2hlY2sgZm9yIG9sZCwgZGVwcmljYXRlZCBmcy53cml0ZShmZCwgc3RyaW5nWywgcG9zaXRpb25bLCBlbmNvZGluZ11dLCBjYWxsYmFjaylcbiAgaWYgKHR5cGVvZiBidWZmZXIgPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIGZzLndyaXRlKGZkLCBidWZmZXIsIGEsIGIsIChlcnIsIGJ5dGVzV3JpdHRlbiwgYnVmZmVyKSA9PiB7XG4gICAgICAgIGlmIChlcnIpIHJldHVybiByZWplY3QoZXJyKVxuICAgICAgICByZXNvbHZlKHsgYnl0ZXNXcml0dGVuLCBidWZmZXIgfSlcbiAgICAgIH0pXG4gICAgfSlcbiAgfVxuXG4gIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgZnMud3JpdGUoZmQsIGJ1ZmZlciwgYSwgYiwgYywgKGVyciwgYnl0ZXNXcml0dGVuLCBidWZmZXIpID0+IHtcbiAgICAgIGlmIChlcnIpIHJldHVybiByZWplY3QoZXJyKVxuICAgICAgcmVzb2x2ZSh7IGJ5dGVzV3JpdHRlbiwgYnVmZmVyIH0pXG4gICAgfSlcbiAgfSlcbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9lbGVjdHJvbi11cGRhdGVyL25vZGVfbW9kdWxlcy9mcy1leHRyYS9saWIvZnMvaW5kZXguanMiLCIndXNlIHN0cmljdCdcblxudmFyIGZzID0gcmVxdWlyZSgnZnMnKVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNsb25lKGZzKVxuXG5mdW5jdGlvbiBjbG9uZSAob2JqKSB7XG4gIGlmIChvYmogPT09IG51bGwgfHwgdHlwZW9mIG9iaiAhPT0gJ29iamVjdCcpXG4gICAgcmV0dXJuIG9ialxuXG4gIGlmIChvYmogaW5zdGFuY2VvZiBPYmplY3QpXG4gICAgdmFyIGNvcHkgPSB7IF9fcHJvdG9fXzogb2JqLl9fcHJvdG9fXyB9XG4gIGVsc2VcbiAgICB2YXIgY29weSA9IE9iamVjdC5jcmVhdGUobnVsbClcblxuICBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhvYmopLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShjb3B5LCBrZXksIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqLCBrZXkpKVxuICB9KVxuXG4gIHJldHVybiBjb3B5XG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvZ3JhY2VmdWwtZnMvZnMuanMiLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCJhc3NlcnRcIik7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gZXh0ZXJuYWwgXCJhc3NlcnRcIlxuLy8gbW9kdWxlIGlkID0gNDZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IGZzID0gcmVxdWlyZSgnZ3JhY2VmdWwtZnMnKVxuY29uc3QgcGF0aCA9IHJlcXVpcmUoJ3BhdGgnKVxuY29uc3QgbWtkaXJwID0gcmVxdWlyZSgnLi4vbWtkaXJzJykubWtkaXJzXG5jb25zdCBwYXRoRXhpc3RzID0gcmVxdWlyZSgnLi4vcGF0aC1leGlzdHMnKS5wYXRoRXhpc3RzXG5jb25zdCB1dGltZXMgPSByZXF1aXJlKCcuLi91dGlsL3V0aW1lcycpLnV0aW1lc01pbGxpc1xuXG5jb25zdCBub3RFeGlzdCA9IFN5bWJvbCgnbm90RXhpc3QnKVxuY29uc3QgZXhpc3RzUmVnID0gU3ltYm9sKCdleGlzdHNSZWcnKVxuXG5mdW5jdGlvbiBjb3B5IChzcmMsIGRlc3QsIG9wdHMsIGNiKSB7XG4gIGlmICh0eXBlb2Ygb3B0cyA9PT0gJ2Z1bmN0aW9uJyAmJiAhY2IpIHtcbiAgICBjYiA9IG9wdHNcbiAgICBvcHRzID0ge31cbiAgfSBlbHNlIGlmICh0eXBlb2Ygb3B0cyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIG9wdHMgPSB7ZmlsdGVyOiBvcHRzfVxuICB9XG5cbiAgY2IgPSBjYiB8fCBmdW5jdGlvbiAoKSB7fVxuICBvcHRzID0gb3B0cyB8fCB7fVxuXG4gIG9wdHMuY2xvYmJlciA9ICdjbG9iYmVyJyBpbiBvcHRzID8gISFvcHRzLmNsb2JiZXIgOiB0cnVlIC8vIGRlZmF1bHQgdG8gdHJ1ZSBmb3Igbm93XG4gIG9wdHMub3ZlcndyaXRlID0gJ292ZXJ3cml0ZScgaW4gb3B0cyA/ICEhb3B0cy5vdmVyd3JpdGUgOiBvcHRzLmNsb2JiZXIgLy8gb3ZlcndyaXRlIGZhbGxzIGJhY2sgdG8gY2xvYmJlclxuXG4gIC8vIFdhcm4gYWJvdXQgdXNpbmcgcHJlc2VydmVUaW1lc3RhbXBzIG9uIDMyLWJpdCBub2RlXG4gIGlmIChvcHRzLnByZXNlcnZlVGltZXN0YW1wcyAmJiBwcm9jZXNzLmFyY2ggPT09ICdpYTMyJykge1xuICAgIGNvbnNvbGUud2FybihgZnMtZXh0cmE6IFVzaW5nIHRoZSBwcmVzZXJ2ZVRpbWVzdGFtcHMgb3B0aW9uIGluIDMyLWJpdCBub2RlIGlzIG5vdCByZWNvbW1lbmRlZDtcXG5cbiAgICBzZWUgaHR0cHM6Ly9naXRodWIuY29tL2pwcmljaGFyZHNvbi9ub2RlLWZzLWV4dHJhL2lzc3Vlcy8yNjlgKVxuICB9XG5cbiAgc3JjID0gcGF0aC5yZXNvbHZlKHNyYylcbiAgZGVzdCA9IHBhdGgucmVzb2x2ZShkZXN0KVxuXG4gIC8vIGRvbid0IGFsbG93IHNyYyBhbmQgZGVzdCB0byBiZSB0aGUgc2FtZVxuICBpZiAoc3JjID09PSBkZXN0KSByZXR1cm4gY2IobmV3IEVycm9yKCdTb3VyY2UgYW5kIGRlc3RpbmF0aW9uIG11c3Qgbm90IGJlIHRoZSBzYW1lLicpKVxuXG4gIGlmIChvcHRzLmZpbHRlcikgcmV0dXJuIGhhbmRsZUZpbHRlcihjaGVja1BhcmVudERpciwgc3JjLCBkZXN0LCBvcHRzLCBjYilcbiAgcmV0dXJuIGNoZWNrUGFyZW50RGlyKHNyYywgZGVzdCwgb3B0cywgY2IpXG59XG5cbmZ1bmN0aW9uIGNoZWNrUGFyZW50RGlyIChzcmMsIGRlc3QsIG9wdHMsIGNiKSB7XG4gIGNvbnN0IGRlc3RQYXJlbnQgPSBwYXRoLmRpcm5hbWUoZGVzdClcbiAgcGF0aEV4aXN0cyhkZXN0UGFyZW50LCAoZXJyLCBkaXJFeGlzdHMpID0+IHtcbiAgICBpZiAoZXJyKSByZXR1cm4gY2IoZXJyKVxuICAgIGlmIChkaXJFeGlzdHMpIHJldHVybiBzdGFydENvcHkoc3JjLCBkZXN0LCBvcHRzLCBjYilcbiAgICBta2RpcnAoZGVzdFBhcmVudCwgZXJyID0+IHtcbiAgICAgIGlmIChlcnIpIHJldHVybiBjYihlcnIpXG4gICAgICByZXR1cm4gc3RhcnRDb3B5KHNyYywgZGVzdCwgb3B0cywgY2IpXG4gICAgfSlcbiAgfSlcbn1cblxuZnVuY3Rpb24gc3RhcnRDb3B5IChzcmMsIGRlc3QsIG9wdHMsIGNiKSB7XG4gIGlmIChvcHRzLmZpbHRlcikgcmV0dXJuIGhhbmRsZUZpbHRlcihnZXRTdGF0cywgc3JjLCBkZXN0LCBvcHRzLCBjYilcbiAgcmV0dXJuIGdldFN0YXRzKHNyYywgZGVzdCwgb3B0cywgY2IpXG59XG5cbmZ1bmN0aW9uIGhhbmRsZUZpbHRlciAob25JbmNsdWRlLCBzcmMsIGRlc3QsIG9wdHMsIGNiKSB7XG4gIFByb21pc2UucmVzb2x2ZShvcHRzLmZpbHRlcihzcmMsIGRlc3QpKVxuICAgIC50aGVuKGluY2x1ZGUgPT4ge1xuICAgICAgaWYgKGluY2x1ZGUpIHJldHVybiBvbkluY2x1ZGUoc3JjLCBkZXN0LCBvcHRzLCBjYilcbiAgICAgIHJldHVybiBjYigpXG4gICAgfSwgZXJyb3IgPT4gY2IoZXJyb3IpKVxufVxuXG5mdW5jdGlvbiBnZXRTdGF0cyAoc3JjLCBkZXN0LCBvcHRzLCBjYikge1xuICBjb25zdCBzdGF0ID0gb3B0cy5kZXJlZmVyZW5jZSA/IGZzLnN0YXQgOiBmcy5sc3RhdFxuICBzdGF0KHNyYywgKGVyciwgc3QpID0+IHtcbiAgICBpZiAoZXJyKSByZXR1cm4gY2IoZXJyKVxuXG4gICAgaWYgKHN0LmlzRGlyZWN0b3J5KCkpIHJldHVybiBvbkRpcihzdCwgc3JjLCBkZXN0LCBvcHRzLCBjYilcbiAgICBlbHNlIGlmIChzdC5pc0ZpbGUoKSB8fFxuICAgICAgICAgICAgIHN0LmlzQ2hhcmFjdGVyRGV2aWNlKCkgfHxcbiAgICAgICAgICAgICBzdC5pc0Jsb2NrRGV2aWNlKCkpIHJldHVybiBvbkZpbGUoc3QsIHNyYywgZGVzdCwgb3B0cywgY2IpXG4gICAgZWxzZSBpZiAoc3QuaXNTeW1ib2xpY0xpbmsoKSkgcmV0dXJuIG9uTGluayhzcmMsIGRlc3QsIG9wdHMsIGNiKVxuICB9KVxufVxuXG5mdW5jdGlvbiBvbkZpbGUgKHNyY1N0YXQsIHNyYywgZGVzdCwgb3B0cywgY2IpIHtcbiAgY2hlY2tEZXN0KGRlc3QsIChlcnIsIHJlc29sdmVkUGF0aCkgPT4ge1xuICAgIGlmIChlcnIpIHJldHVybiBjYihlcnIpXG4gICAgaWYgKHJlc29sdmVkUGF0aCA9PT0gbm90RXhpc3QpIHtcbiAgICAgIHJldHVybiBjb3B5RmlsZShzcmNTdGF0LCBzcmMsIGRlc3QsIG9wdHMsIGNiKVxuICAgIH0gZWxzZSBpZiAocmVzb2x2ZWRQYXRoID09PSBleGlzdHNSZWcpIHtcbiAgICAgIHJldHVybiBtYXlDb3B5RmlsZShzcmNTdGF0LCBzcmMsIGRlc3QsIG9wdHMsIGNiKVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoc3JjID09PSByZXNvbHZlZFBhdGgpIHJldHVybiBjYigpXG4gICAgICByZXR1cm4gbWF5Q29weUZpbGUoc3JjU3RhdCwgc3JjLCBkZXN0LCBvcHRzLCBjYilcbiAgICB9XG4gIH0pXG59XG5cbmZ1bmN0aW9uIG1heUNvcHlGaWxlIChzcmNTdGF0LCBzcmMsIGRlc3QsIG9wdHMsIGNiKSB7XG4gIGlmIChvcHRzLm92ZXJ3cml0ZSkge1xuICAgIGZzLnVubGluayhkZXN0LCBlcnIgPT4ge1xuICAgICAgaWYgKGVycikgcmV0dXJuIGNiKGVycilcbiAgICAgIHJldHVybiBjb3B5RmlsZShzcmNTdGF0LCBzcmMsIGRlc3QsIG9wdHMsIGNiKVxuICAgIH0pXG4gIH0gZWxzZSBpZiAob3B0cy5lcnJvck9uRXhpc3QpIHtcbiAgICByZXR1cm4gY2IobmV3IEVycm9yKGAnJHtkZXN0fScgYWxyZWFkeSBleGlzdHNgKSlcbiAgfSBlbHNlIHJldHVybiBjYigpXG59XG5cbmZ1bmN0aW9uIGNvcHlGaWxlIChzcmNTdGF0LCBzcmMsIGRlc3QsIG9wdHMsIGNiKSB7XG4gIGlmICh0eXBlb2YgZnMuY29weUZpbGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gZnMuY29weUZpbGUoc3JjLCBkZXN0LCBlcnIgPT4ge1xuICAgICAgaWYgKGVycikgcmV0dXJuIGNiKGVycilcbiAgICAgIHJldHVybiBzZXREZXN0TW9kZUFuZFRpbWVzdGFtcHMoc3JjU3RhdCwgZGVzdCwgb3B0cywgY2IpXG4gICAgfSlcbiAgfVxuICByZXR1cm4gY29weUZpbGVGYWxsYmFjayhzcmNTdGF0LCBzcmMsIGRlc3QsIG9wdHMsIGNiKVxufVxuXG5mdW5jdGlvbiBjb3B5RmlsZUZhbGxiYWNrIChzcmNTdGF0LCBzcmMsIGRlc3QsIG9wdHMsIGNiKSB7XG4gIGNvbnN0IHJzID0gZnMuY3JlYXRlUmVhZFN0cmVhbShzcmMpXG4gIHJzLm9uKCdlcnJvcicsIGVyciA9PiBjYihlcnIpKVxuICAgIC5vbmNlKCdvcGVuJywgKCkgPT4ge1xuICAgICAgY29uc3Qgd3MgPSBmcy5jcmVhdGVXcml0ZVN0cmVhbShkZXN0LCB7IG1vZGU6IHNyY1N0YXQubW9kZSB9KVxuICAgICAgd3Mub24oJ2Vycm9yJywgZXJyID0+IGNiKGVycikpXG4gICAgICAgIC5vbignb3BlbicsICgpID0+IHJzLnBpcGUod3MpKVxuICAgICAgICAub25jZSgnY2xvc2UnLCAoKSA9PiBzZXREZXN0TW9kZUFuZFRpbWVzdGFtcHMoc3JjU3RhdCwgZGVzdCwgb3B0cywgY2IpKVxuICAgIH0pXG59XG5cbmZ1bmN0aW9uIHNldERlc3RNb2RlQW5kVGltZXN0YW1wcyAoc3JjU3RhdCwgZGVzdCwgb3B0cywgY2IpIHtcbiAgZnMuY2htb2QoZGVzdCwgc3JjU3RhdC5tb2RlLCBlcnIgPT4ge1xuICAgIGlmIChlcnIpIHJldHVybiBjYihlcnIpXG4gICAgaWYgKG9wdHMucHJlc2VydmVUaW1lc3RhbXBzKSB7XG4gICAgICByZXR1cm4gdXRpbWVzKGRlc3QsIHNyY1N0YXQuYXRpbWUsIHNyY1N0YXQubXRpbWUsIGNiKVxuICAgIH1cbiAgICByZXR1cm4gY2IoKVxuICB9KVxufVxuXG5mdW5jdGlvbiBvbkRpciAoc3JjU3RhdCwgc3JjLCBkZXN0LCBvcHRzLCBjYikge1xuICBjaGVja0Rlc3QoZGVzdCwgKGVyciwgcmVzb2x2ZWRQYXRoKSA9PiB7XG4gICAgaWYgKGVycikgcmV0dXJuIGNiKGVycilcbiAgICBpZiAocmVzb2x2ZWRQYXRoID09PSBub3RFeGlzdCkge1xuICAgICAgaWYgKGlzU3JjU3ViZGlyKHNyYywgZGVzdCkpIHtcbiAgICAgICAgcmV0dXJuIGNiKG5ldyBFcnJvcihgQ2Fubm90IGNvcHkgJyR7c3JjfScgdG8gYSBzdWJkaXJlY3Rvcnkgb2YgaXRzZWxmLCAnJHtkZXN0fScuYCkpXG4gICAgICB9XG4gICAgICByZXR1cm4gbWtEaXJBbmRDb3B5KHNyY1N0YXQsIHNyYywgZGVzdCwgb3B0cywgY2IpXG4gICAgfSBlbHNlIGlmIChyZXNvbHZlZFBhdGggPT09IGV4aXN0c1JlZykge1xuICAgICAgaWYgKGlzU3JjU3ViZGlyKHNyYywgZGVzdCkpIHtcbiAgICAgICAgcmV0dXJuIGNiKG5ldyBFcnJvcihgQ2Fubm90IGNvcHkgJyR7c3JjfScgdG8gYSBzdWJkaXJlY3Rvcnkgb2YgaXRzZWxmLCAnJHtkZXN0fScuYCkpXG4gICAgICB9XG4gICAgICByZXR1cm4gbWF5Q29weURpcihzcmMsIGRlc3QsIG9wdHMsIGNiKVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoc3JjID09PSByZXNvbHZlZFBhdGgpIHJldHVybiBjYigpXG4gICAgICByZXR1cm4gY29weURpcihzcmMsIGRlc3QsIG9wdHMsIGNiKVxuICAgIH1cbiAgfSlcbn1cblxuZnVuY3Rpb24gbWF5Q29weURpciAoc3JjLCBkZXN0LCBvcHRzLCBjYikge1xuICBmcy5zdGF0KGRlc3QsIChlcnIsIHN0KSA9PiB7XG4gICAgaWYgKGVycikgcmV0dXJuIGNiKGVycilcbiAgICBpZiAoIXN0LmlzRGlyZWN0b3J5KCkpIHtcbiAgICAgIHJldHVybiBjYihuZXcgRXJyb3IoYENhbm5vdCBvdmVyd3JpdGUgbm9uLWRpcmVjdG9yeSAnJHtkZXN0fScgd2l0aCBkaXJlY3RvcnkgJyR7c3JjfScuYCkpXG4gICAgfVxuICAgIHJldHVybiBjb3B5RGlyKHNyYywgZGVzdCwgb3B0cywgY2IpXG4gIH0pXG59XG5cbmZ1bmN0aW9uIG1rRGlyQW5kQ29weSAoc3JjU3RhdCwgc3JjLCBkZXN0LCBvcHRzLCBjYikge1xuICBmcy5ta2RpcihkZXN0LCBzcmNTdGF0Lm1vZGUsIGVyciA9PiB7XG4gICAgaWYgKGVycikgcmV0dXJuIGNiKGVycilcbiAgICBmcy5jaG1vZChkZXN0LCBzcmNTdGF0Lm1vZGUsIGVyciA9PiB7XG4gICAgICBpZiAoZXJyKSByZXR1cm4gY2IoZXJyKVxuICAgICAgcmV0dXJuIGNvcHlEaXIoc3JjLCBkZXN0LCBvcHRzLCBjYilcbiAgICB9KVxuICB9KVxufVxuXG5mdW5jdGlvbiBjb3B5RGlyIChzcmMsIGRlc3QsIG9wdHMsIGNiKSB7XG4gIGZzLnJlYWRkaXIoc3JjLCAoZXJyLCBpdGVtcykgPT4ge1xuICAgIGlmIChlcnIpIHJldHVybiBjYihlcnIpXG4gICAgcmV0dXJuIGNvcHlEaXJJdGVtcyhpdGVtcywgc3JjLCBkZXN0LCBvcHRzLCBjYilcbiAgfSlcbn1cblxuZnVuY3Rpb24gY29weURpckl0ZW1zIChpdGVtcywgc3JjLCBkZXN0LCBvcHRzLCBjYikge1xuICBjb25zdCBpdGVtID0gaXRlbXMucG9wKClcbiAgaWYgKCFpdGVtKSByZXR1cm4gY2IoKVxuICBzdGFydENvcHkocGF0aC5qb2luKHNyYywgaXRlbSksIHBhdGguam9pbihkZXN0LCBpdGVtKSwgb3B0cywgZXJyID0+IHtcbiAgICBpZiAoZXJyKSByZXR1cm4gY2IoZXJyKVxuICAgIHJldHVybiBjb3B5RGlySXRlbXMoaXRlbXMsIHNyYywgZGVzdCwgb3B0cywgY2IpXG4gIH0pXG59XG5cbmZ1bmN0aW9uIG9uTGluayAoc3JjLCBkZXN0LCBvcHRzLCBjYikge1xuICBmcy5yZWFkbGluayhzcmMsIChlcnIsIHJlc29sdmVkU3JjUGF0aCkgPT4ge1xuICAgIGlmIChlcnIpIHJldHVybiBjYihlcnIpXG5cbiAgICBpZiAob3B0cy5kZXJlZmVyZW5jZSkge1xuICAgICAgcmVzb2x2ZWRTcmNQYXRoID0gcGF0aC5yZXNvbHZlKHByb2Nlc3MuY3dkKCksIHJlc29sdmVkU3JjUGF0aClcbiAgICB9XG5cbiAgICBjaGVja0Rlc3QoZGVzdCwgKGVyciwgcmVzb2x2ZWREZXN0UGF0aCkgPT4ge1xuICAgICAgaWYgKGVycikgcmV0dXJuIGNiKGVycilcblxuICAgICAgaWYgKHJlc29sdmVkRGVzdFBhdGggPT09IG5vdEV4aXN0IHx8IHJlc29sdmVkRGVzdFBhdGggPT09IGV4aXN0c1JlZykge1xuICAgICAgICAvLyBpZiBkZXN0IGFscmVhZHkgZXhpc3RzLCBmcyB0aHJvd3MgZXJyb3IgYW55d2F5LFxuICAgICAgICAvLyBzbyBubyBuZWVkIHRvIGd1YXJkIGFnYWluc3QgaXQgaGVyZS5cbiAgICAgICAgcmV0dXJuIGZzLnN5bWxpbmsocmVzb2x2ZWRTcmNQYXRoLCBkZXN0LCBjYilcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChvcHRzLmRlcmVmZXJlbmNlKSB7XG4gICAgICAgICAgcmVzb2x2ZWREZXN0UGF0aCA9IHBhdGgucmVzb2x2ZShwcm9jZXNzLmN3ZCgpLCByZXNvbHZlZERlc3RQYXRoKVxuICAgICAgICB9XG4gICAgICAgIGlmIChyZXNvbHZlZERlc3RQYXRoID09PSByZXNvbHZlZFNyY1BhdGgpIHJldHVybiBjYigpXG5cbiAgICAgICAgLy8gcHJldmVudCBjb3B5IGlmIHNyYyBpcyBhIHN1YmRpciBvZiBkZXN0IHNpbmNlIHVubGlua2luZ1xuICAgICAgICAvLyBkZXN0IGluIHRoaXMgY2FzZSB3b3VsZCByZXN1bHQgaW4gcmVtb3Zpbmcgc3JjIGNvbnRlbnRzXG4gICAgICAgIC8vIGFuZCB0aGVyZWZvcmUgYSBicm9rZW4gc3ltbGluayB3b3VsZCBiZSBjcmVhdGVkLlxuICAgICAgICBmcy5zdGF0KGRlc3QsIChlcnIsIHN0KSA9PiB7XG4gICAgICAgICAgaWYgKGVycikgcmV0dXJuIGNiKGVycilcbiAgICAgICAgICBpZiAoc3QuaXNEaXJlY3RvcnkoKSAmJiBpc1NyY1N1YmRpcihyZXNvbHZlZERlc3RQYXRoLCByZXNvbHZlZFNyY1BhdGgpKSB7XG4gICAgICAgICAgICByZXR1cm4gY2IobmV3IEVycm9yKGBDYW5ub3Qgb3ZlcndyaXRlICcke3Jlc29sdmVkRGVzdFBhdGh9JyB3aXRoICcke3Jlc29sdmVkU3JjUGF0aH0nLmApKVxuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gY29weUxpbmsocmVzb2x2ZWRTcmNQYXRoLCBkZXN0LCBjYilcbiAgICAgICAgfSlcbiAgICAgIH1cbiAgICB9KVxuICB9KVxufVxuXG5mdW5jdGlvbiBjb3B5TGluayAocmVzb2x2ZWRTcmNQYXRoLCBkZXN0LCBjYikge1xuICBmcy51bmxpbmsoZGVzdCwgZXJyID0+IHtcbiAgICBpZiAoZXJyKSByZXR1cm4gY2IoZXJyKVxuICAgIHJldHVybiBmcy5zeW1saW5rKHJlc29sdmVkU3JjUGF0aCwgZGVzdCwgY2IpXG4gIH0pXG59XG5cbi8vIGNoZWNrIGlmIGRlc3QgZXhpc3RzIGFuZC9vciBpcyBhIHN5bWxpbmtcbmZ1bmN0aW9uIGNoZWNrRGVzdCAoZGVzdCwgY2IpIHtcbiAgZnMucmVhZGxpbmsoZGVzdCwgKGVyciwgcmVzb2x2ZWRQYXRoKSA9PiB7XG4gICAgaWYgKGVycikge1xuICAgICAgaWYgKGVyci5jb2RlID09PSAnRU5PRU5UJykgcmV0dXJuIGNiKG51bGwsIG5vdEV4aXN0KVxuXG4gICAgICAvLyBkZXN0IGV4aXN0cyBhbmQgaXMgYSByZWd1bGFyIGZpbGUgb3IgZGlyZWN0b3J5LCBXaW5kb3dzIG1heSB0aHJvdyBVTktOT1dOIGVycm9yLlxuICAgICAgaWYgKGVyci5jb2RlID09PSAnRUlOVkFMJyB8fCBlcnIuY29kZSA9PT0gJ1VOS05PV04nKSByZXR1cm4gY2IobnVsbCwgZXhpc3RzUmVnKVxuXG4gICAgICByZXR1cm4gY2IoZXJyKVxuICAgIH1cbiAgICByZXR1cm4gY2IobnVsbCwgcmVzb2x2ZWRQYXRoKSAvLyBkZXN0IGV4aXN0cyBhbmQgaXMgYSBzeW1saW5rXG4gIH0pXG59XG5cbi8vIHJldHVybiB0cnVlIGlmIGRlc3QgaXMgYSBzdWJkaXIgb2Ygc3JjLCBvdGhlcndpc2UgZmFsc2UuXG4vLyBleHRyYWN0IGRlc3QgYmFzZSBkaXIgYW5kIGNoZWNrIGlmIHRoYXQgaXMgdGhlIHNhbWUgYXMgc3JjIGJhc2VuYW1lXG5mdW5jdGlvbiBpc1NyY1N1YmRpciAoc3JjLCBkZXN0KSB7XG4gIGNvbnN0IGJhc2VEaXIgPSBkZXN0LnNwbGl0KHBhdGguZGlybmFtZShzcmMpICsgcGF0aC5zZXApWzFdXG4gIGlmIChiYXNlRGlyKSB7XG4gICAgY29uc3QgZGVzdEJhc2VuYW1lID0gYmFzZURpci5zcGxpdChwYXRoLnNlcClbMF1cbiAgICBpZiAoZGVzdEJhc2VuYW1lKSB7XG4gICAgICByZXR1cm4gc3JjICE9PSBkZXN0ICYmIGRlc3QuaW5kZXhPZihzcmMpID4gLTEgJiYgZGVzdEJhc2VuYW1lID09PSBwYXRoLmJhc2VuYW1lKHNyYylcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cbiAgcmV0dXJuIGZhbHNlXG59XG5cbm1vZHVsZS5leHBvcnRzID0gY29weVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2VsZWN0cm9uLXVwZGF0ZXIvbm9kZV9tb2R1bGVzL2ZzLWV4dHJhL2xpYi9jb3B5L2NvcHkuanMiLCIndXNlIHN0cmljdCdcblxuY29uc3QgcGF0aCA9IHJlcXVpcmUoJ3BhdGgnKVxuXG4vLyBnZXQgZHJpdmUgb24gd2luZG93c1xuZnVuY3Rpb24gZ2V0Um9vdFBhdGggKHApIHtcbiAgcCA9IHBhdGgubm9ybWFsaXplKHBhdGgucmVzb2x2ZShwKSkuc3BsaXQocGF0aC5zZXApXG4gIGlmIChwLmxlbmd0aCA+IDApIHJldHVybiBwWzBdXG4gIHJldHVybiBudWxsXG59XG5cbi8vIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9hLzYyODg4LzEwMzMzIGNvbnRhaW5zIG1vcmUgYWNjdXJhdGVcbi8vIFRPRE86IGV4cGFuZCB0byBpbmNsdWRlIHRoZSByZXN0XG5jb25zdCBJTlZBTElEX1BBVEhfQ0hBUlMgPSAvWzw+OlwifD8qXS9cblxuZnVuY3Rpb24gaW52YWxpZFdpbjMyUGF0aCAocCkge1xuICBjb25zdCBycCA9IGdldFJvb3RQYXRoKHApXG4gIHAgPSBwLnJlcGxhY2UocnAsICcnKVxuICByZXR1cm4gSU5WQUxJRF9QQVRIX0NIQVJTLnRlc3QocClcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGdldFJvb3RQYXRoLFxuICBpbnZhbGlkV2luMzJQYXRoXG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvZWxlY3Ryb24tdXBkYXRlci9ub2RlX21vZHVsZXMvZnMtZXh0cmEvbGliL21rZGlycy93aW4zMi5qcyIsIid1c2Ugc3RyaWN0J1xuXG5jb25zdCBmcyA9IHJlcXVpcmUoJ2dyYWNlZnVsLWZzJylcbmNvbnN0IG9zID0gcmVxdWlyZSgnb3MnKVxuY29uc3QgcGF0aCA9IHJlcXVpcmUoJ3BhdGgnKVxuXG4vLyBIRlMsIGV4dHsyLDN9LCBGQVQgZG8gbm90LCBOb2RlLmpzIHYwLjEwIGRvZXMgbm90XG5mdW5jdGlvbiBoYXNNaWxsaXNSZXNTeW5jICgpIHtcbiAgbGV0IHRtcGZpbGUgPSBwYXRoLmpvaW4oJ21pbGxpcy10ZXN0LXN5bmMnICsgRGF0ZS5ub3coKS50b1N0cmluZygpICsgTWF0aC5yYW5kb20oKS50b1N0cmluZygpLnNsaWNlKDIpKVxuICB0bXBmaWxlID0gcGF0aC5qb2luKG9zLnRtcGRpcigpLCB0bXBmaWxlKVxuXG4gIC8vIDU1MCBtaWxsaXMgcGFzdCBVTklYIGVwb2NoXG4gIGNvbnN0IGQgPSBuZXcgRGF0ZSgxNDM1NDEwMjQzODYyKVxuICBmcy53cml0ZUZpbGVTeW5jKHRtcGZpbGUsICdodHRwczovL2dpdGh1Yi5jb20vanByaWNoYXJkc29uL25vZGUtZnMtZXh0cmEvcHVsbC8xNDEnKVxuICBjb25zdCBmZCA9IGZzLm9wZW5TeW5jKHRtcGZpbGUsICdyKycpXG4gIGZzLmZ1dGltZXNTeW5jKGZkLCBkLCBkKVxuICBmcy5jbG9zZVN5bmMoZmQpXG4gIHJldHVybiBmcy5zdGF0U3luYyh0bXBmaWxlKS5tdGltZSA+IDE0MzU0MTAyNDMwMDBcbn1cblxuZnVuY3Rpb24gaGFzTWlsbGlzUmVzIChjYWxsYmFjaykge1xuICBsZXQgdG1wZmlsZSA9IHBhdGguam9pbignbWlsbGlzLXRlc3QnICsgRGF0ZS5ub3coKS50b1N0cmluZygpICsgTWF0aC5yYW5kb20oKS50b1N0cmluZygpLnNsaWNlKDIpKVxuICB0bXBmaWxlID0gcGF0aC5qb2luKG9zLnRtcGRpcigpLCB0bXBmaWxlKVxuXG4gIC8vIDU1MCBtaWxsaXMgcGFzdCBVTklYIGVwb2NoXG4gIGNvbnN0IGQgPSBuZXcgRGF0ZSgxNDM1NDEwMjQzODYyKVxuICBmcy53cml0ZUZpbGUodG1wZmlsZSwgJ2h0dHBzOi8vZ2l0aHViLmNvbS9qcHJpY2hhcmRzb24vbm9kZS1mcy1leHRyYS9wdWxsLzE0MScsIGVyciA9PiB7XG4gICAgaWYgKGVycikgcmV0dXJuIGNhbGxiYWNrKGVycilcbiAgICBmcy5vcGVuKHRtcGZpbGUsICdyKycsIChlcnIsIGZkKSA9PiB7XG4gICAgICBpZiAoZXJyKSByZXR1cm4gY2FsbGJhY2soZXJyKVxuICAgICAgZnMuZnV0aW1lcyhmZCwgZCwgZCwgZXJyID0+IHtcbiAgICAgICAgaWYgKGVycikgcmV0dXJuIGNhbGxiYWNrKGVycilcbiAgICAgICAgZnMuY2xvc2UoZmQsIGVyciA9PiB7XG4gICAgICAgICAgaWYgKGVycikgcmV0dXJuIGNhbGxiYWNrKGVycilcbiAgICAgICAgICBmcy5zdGF0KHRtcGZpbGUsIChlcnIsIHN0YXRzKSA9PiB7XG4gICAgICAgICAgICBpZiAoZXJyKSByZXR1cm4gY2FsbGJhY2soZXJyKVxuICAgICAgICAgICAgY2FsbGJhY2sobnVsbCwgc3RhdHMubXRpbWUgPiAxNDM1NDEwMjQzMDAwKVxuICAgICAgICAgIH0pXG4gICAgICAgIH0pXG4gICAgICB9KVxuICAgIH0pXG4gIH0pXG59XG5cbmZ1bmN0aW9uIHRpbWVSZW1vdmVNaWxsaXMgKHRpbWVzdGFtcCkge1xuICBpZiAodHlwZW9mIHRpbWVzdGFtcCA9PT0gJ251bWJlcicpIHtcbiAgICByZXR1cm4gTWF0aC5mbG9vcih0aW1lc3RhbXAgLyAxMDAwKSAqIDEwMDBcbiAgfSBlbHNlIGlmICh0aW1lc3RhbXAgaW5zdGFuY2VvZiBEYXRlKSB7XG4gICAgcmV0dXJuIG5ldyBEYXRlKE1hdGguZmxvb3IodGltZXN0YW1wLmdldFRpbWUoKSAvIDEwMDApICogMTAwMClcbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2ZzLWV4dHJhOiB0aW1lUmVtb3ZlTWlsbGlzKCkgdW5rbm93biBwYXJhbWV0ZXIgdHlwZScpXG4gIH1cbn1cblxuZnVuY3Rpb24gdXRpbWVzTWlsbGlzIChwYXRoLCBhdGltZSwgbXRpbWUsIGNhbGxiYWNrKSB7XG4gIC8vIGlmICghSEFTX01JTExJU19SRVMpIHJldHVybiBmcy51dGltZXMocGF0aCwgYXRpbWUsIG10aW1lLCBjYWxsYmFjaylcbiAgZnMub3BlbihwYXRoLCAncisnLCAoZXJyLCBmZCkgPT4ge1xuICAgIGlmIChlcnIpIHJldHVybiBjYWxsYmFjayhlcnIpXG4gICAgZnMuZnV0aW1lcyhmZCwgYXRpbWUsIG10aW1lLCBmdXRpbWVzRXJyID0+IHtcbiAgICAgIGZzLmNsb3NlKGZkLCBjbG9zZUVyciA9PiB7XG4gICAgICAgIGlmIChjYWxsYmFjaykgY2FsbGJhY2soZnV0aW1lc0VyciB8fCBjbG9zZUVycilcbiAgICAgIH0pXG4gICAgfSlcbiAgfSlcbn1cblxuZnVuY3Rpb24gdXRpbWVzTWlsbGlzU3luYyAocGF0aCwgYXRpbWUsIG10aW1lKSB7XG4gIGNvbnN0IGZkID0gZnMub3BlblN5bmMocGF0aCwgJ3IrJylcbiAgZnMuZnV0aW1lc1N5bmMoZmQsIGF0aW1lLCBtdGltZSlcbiAgcmV0dXJuIGZzLmNsb3NlU3luYyhmZClcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGhhc01pbGxpc1JlcyxcbiAgaGFzTWlsbGlzUmVzU3luYyxcbiAgdGltZVJlbW92ZU1pbGxpcyxcbiAgdXRpbWVzTWlsbGlzLFxuICB1dGltZXNNaWxsaXNTeW5jXG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvZWxlY3Ryb24tdXBkYXRlci9ub2RlX21vZHVsZXMvZnMtZXh0cmEvbGliL3V0aWwvdXRpbWVzLmpzIiwibW9kdWxlLmV4cG9ydHMgPSB7XG4gIGNvcHlTeW5jOiByZXF1aXJlKCcuL2NvcHktc3luYycpXG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvZWxlY3Ryb24tdXBkYXRlci9ub2RlX21vZHVsZXMvZnMtZXh0cmEvbGliL2NvcHktc3luYy9pbmRleC5qcyIsIi8qIGVzbGludC1kaXNhYmxlIG5vZGUvbm8tZGVwcmVjYXRlZC1hcGkgKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKHNpemUpIHtcbiAgaWYgKHR5cGVvZiBCdWZmZXIuYWxsb2NVbnNhZmUgPT09ICdmdW5jdGlvbicpIHtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIEJ1ZmZlci5hbGxvY1Vuc2FmZShzaXplKVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHJldHVybiBuZXcgQnVmZmVyKHNpemUpXG4gICAgfVxuICB9XG4gIHJldHVybiBuZXcgQnVmZmVyKHNpemUpXG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvZWxlY3Ryb24tdXBkYXRlci9ub2RlX21vZHVsZXMvZnMtZXh0cmEvbGliL3V0aWwvYnVmZmVyLmpzIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuUHJvZ3Jlc3NDYWxsYmFja1RyYW5zZm9ybSA9IHVuZGVmaW5lZDtcblxudmFyIF9zdHJlYW07XG5cbmZ1bmN0aW9uIF9sb2FkX3N0cmVhbSgpIHtcbiAgICByZXR1cm4gX3N0cmVhbSA9IHJlcXVpcmUoXCJzdHJlYW1cIik7XG59XG5cbmNsYXNzIFByb2dyZXNzQ2FsbGJhY2tUcmFuc2Zvcm0gZXh0ZW5kcyAoX3N0cmVhbSB8fCBfbG9hZF9zdHJlYW0oKSkuVHJhbnNmb3JtIHtcbiAgICBjb25zdHJ1Y3Rvcih0b3RhbCwgY2FuY2VsbGF0aW9uVG9rZW4sIG9uUHJvZ3Jlc3MpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy50b3RhbCA9IHRvdGFsO1xuICAgICAgICB0aGlzLmNhbmNlbGxhdGlvblRva2VuID0gY2FuY2VsbGF0aW9uVG9rZW47XG4gICAgICAgIHRoaXMub25Qcm9ncmVzcyA9IG9uUHJvZ3Jlc3M7XG4gICAgICAgIHRoaXMuc3RhcnQgPSBEYXRlLm5vdygpO1xuICAgICAgICB0aGlzLnRyYW5zZmVycmVkID0gMDtcbiAgICAgICAgdGhpcy5kZWx0YSA9IDA7XG4gICAgICAgIHRoaXMubmV4dFVwZGF0ZSA9IHRoaXMuc3RhcnQgKyAxMDAwO1xuICAgIH1cbiAgICBfdHJhbnNmb3JtKGNodW5rLCBlbmNvZGluZywgY2FsbGJhY2spIHtcbiAgICAgICAgaWYgKHRoaXMuY2FuY2VsbGF0aW9uVG9rZW4uY2FuY2VsbGVkKSB7XG4gICAgICAgICAgICBjYWxsYmFjayhuZXcgRXJyb3IoXCJDYW5jZWxsZWRcIiksIG51bGwpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudHJhbnNmZXJyZWQgKz0gY2h1bmsubGVuZ3RoO1xuICAgICAgICB0aGlzLmRlbHRhICs9IGNodW5rLmxlbmd0aDtcbiAgICAgICAgY29uc3Qgbm93ID0gRGF0ZS5ub3coKTtcbiAgICAgICAgaWYgKG5vdyA+PSB0aGlzLm5leHRVcGRhdGUgJiYgdGhpcy50cmFuc2ZlcnJlZCAhPT0gdGhpcy50b3RhbCAvKiB3aWxsIGJlIGVtaXR0ZWQgb24gX2ZsdXNoICovKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5uZXh0VXBkYXRlID0gbm93ICsgMTAwMDtcbiAgICAgICAgICAgICAgICB0aGlzLm9uUHJvZ3Jlc3Moe1xuICAgICAgICAgICAgICAgICAgICB0b3RhbDogdGhpcy50b3RhbCxcbiAgICAgICAgICAgICAgICAgICAgZGVsdGE6IHRoaXMuZGVsdGEsXG4gICAgICAgICAgICAgICAgICAgIHRyYW5zZmVycmVkOiB0aGlzLnRyYW5zZmVycmVkLFxuICAgICAgICAgICAgICAgICAgICBwZXJjZW50OiB0aGlzLnRyYW5zZmVycmVkIC8gdGhpcy50b3RhbCAqIDEwMCxcbiAgICAgICAgICAgICAgICAgICAgYnl0ZXNQZXJTZWNvbmQ6IE1hdGgucm91bmQodGhpcy50cmFuc2ZlcnJlZCAvICgobm93IC0gdGhpcy5zdGFydCkgLyAxMDAwKSlcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB0aGlzLmRlbHRhID0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgY2FsbGJhY2sobnVsbCwgY2h1bmspO1xuICAgIH1cbiAgICBfZmx1c2goY2FsbGJhY2spIHtcbiAgICAgICAgaWYgKHRoaXMuY2FuY2VsbGF0aW9uVG9rZW4uY2FuY2VsbGVkKSB7XG4gICAgICAgICAgICBjYWxsYmFjayhuZXcgRXJyb3IoXCJDYW5jZWxsZWRcIikpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMub25Qcm9ncmVzcyh7XG4gICAgICAgICAgICB0b3RhbDogdGhpcy50b3RhbCxcbiAgICAgICAgICAgIGRlbHRhOiB0aGlzLmRlbHRhLFxuICAgICAgICAgICAgdHJhbnNmZXJyZWQ6IHRoaXMudG90YWwsXG4gICAgICAgICAgICBwZXJjZW50OiAxMDAsXG4gICAgICAgICAgICBieXRlc1BlclNlY29uZDogTWF0aC5yb3VuZCh0aGlzLnRyYW5zZmVycmVkIC8gKChEYXRlLm5vdygpIC0gdGhpcy5zdGFydCkgLyAxMDAwKSlcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuZGVsdGEgPSAwO1xuICAgICAgICBjYWxsYmFjayhudWxsKTtcbiAgICB9XG59XG5leHBvcnRzLlByb2dyZXNzQ2FsbGJhY2tUcmFuc2Zvcm0gPSBQcm9ncmVzc0NhbGxiYWNrVHJhbnNmb3JtOyAvLyMgc291cmNlTWFwcGluZ1VSTD1Qcm9ncmVzc0NhbGxiYWNrVHJhbnNmb3JtLmpzLm1hcFxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9lbGVjdHJvbi11cGRhdGVyL25vZGVfbW9kdWxlcy9idWlsZGVyLXV0aWwtcnVudGltZS9vdXQvUHJvZ3Jlc3NDYWxsYmFja1RyYW5zZm9ybS5qcyIsIi8vIFN0YW5kYXJkIFlBTUwncyBDb3JlIHNjaGVtYS5cbi8vIGh0dHA6Ly93d3cueWFtbC5vcmcvc3BlYy8xLjIvc3BlYy5odG1sI2lkMjgwNDkyM1xuLy9cbi8vIE5PVEU6IEpTLVlBTUwgZG9lcyBub3Qgc3VwcG9ydCBzY2hlbWEtc3BlY2lmaWMgdGFnIHJlc29sdXRpb24gcmVzdHJpY3Rpb25zLlxuLy8gU28sIENvcmUgc2NoZW1hIGhhcyBubyBkaXN0aW5jdGlvbnMgZnJvbSBKU09OIHNjaGVtYSBpcyBKUy1ZQU1MLlxuXG5cbid1c2Ugc3RyaWN0JztcblxuXG52YXIgU2NoZW1hID0gcmVxdWlyZSgnLi4vc2NoZW1hJyk7XG5cblxubW9kdWxlLmV4cG9ydHMgPSBuZXcgU2NoZW1hKHtcbiAgaW5jbHVkZTogW1xuICAgIHJlcXVpcmUoJy4vanNvbicpXG4gIF1cbn0pO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2pzLXlhbWwvbGliL2pzLXlhbWwvc2NoZW1hL2NvcmUuanMiLCIvLyBTdGFuZGFyZCBZQU1MJ3MgSlNPTiBzY2hlbWEuXG4vLyBodHRwOi8vd3d3LnlhbWwub3JnL3NwZWMvMS4yL3NwZWMuaHRtbCNpZDI4MDMyMzFcbi8vXG4vLyBOT1RFOiBKUy1ZQU1MIGRvZXMgbm90IHN1cHBvcnQgc2NoZW1hLXNwZWNpZmljIHRhZyByZXNvbHV0aW9uIHJlc3RyaWN0aW9ucy5cbi8vIFNvLCB0aGlzIHNjaGVtYSBpcyBub3Qgc3VjaCBzdHJpY3QgYXMgZGVmaW5lZCBpbiB0aGUgWUFNTCBzcGVjaWZpY2F0aW9uLlxuLy8gSXQgYWxsb3dzIG51bWJlcnMgaW4gYmluYXJ5IG5vdGFpb24sIHVzZSBgTnVsbGAgYW5kIGBOVUxMYCBhcyBgbnVsbGAsIGV0Yy5cblxuXG4ndXNlIHN0cmljdCc7XG5cblxudmFyIFNjaGVtYSA9IHJlcXVpcmUoJy4uL3NjaGVtYScpO1xuXG5cbm1vZHVsZS5leHBvcnRzID0gbmV3IFNjaGVtYSh7XG4gIGluY2x1ZGU6IFtcbiAgICByZXF1aXJlKCcuL2ZhaWxzYWZlJylcbiAgXSxcbiAgaW1wbGljaXQ6IFtcbiAgICByZXF1aXJlKCcuLi90eXBlL251bGwnKSxcbiAgICByZXF1aXJlKCcuLi90eXBlL2Jvb2wnKSxcbiAgICByZXF1aXJlKCcuLi90eXBlL2ludCcpLFxuICAgIHJlcXVpcmUoJy4uL3R5cGUvZmxvYXQnKVxuICBdXG59KTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9qcy15YW1sL2xpYi9qcy15YW1sL3NjaGVtYS9qc29uLmpzIiwiZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gU2VtVmVyO1xuXG4vLyBUaGUgZGVidWcgZnVuY3Rpb24gaXMgZXhjbHVkZWQgZW50aXJlbHkgZnJvbSB0aGUgbWluaWZpZWQgdmVyc2lvbi5cbi8qIG5vbWluICovIHZhciBkZWJ1Zztcbi8qIG5vbWluICovIGlmICh0eXBlb2YgcHJvY2VzcyA9PT0gJ29iamVjdCcgJiZcbiAgICAvKiBub21pbiAqLyBwcm9jZXNzLmVudiAmJlxuICAgIC8qIG5vbWluICovIHByb2Nlc3MuZW52Lk5PREVfREVCVUcgJiZcbiAgICAvKiBub21pbiAqLyAvXFxic2VtdmVyXFxiL2kudGVzdChwcm9jZXNzLmVudi5OT0RFX0RFQlVHKSlcbiAgLyogbm9taW4gKi8gZGVidWcgPSBmdW5jdGlvbigpIHtcbiAgICAvKiBub21pbiAqLyB2YXIgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMCk7XG4gICAgLyogbm9taW4gKi8gYXJncy51bnNoaWZ0KCdTRU1WRVInKTtcbiAgICAvKiBub21pbiAqLyBjb25zb2xlLmxvZy5hcHBseShjb25zb2xlLCBhcmdzKTtcbiAgICAvKiBub21pbiAqLyB9O1xuLyogbm9taW4gKi8gZWxzZVxuICAvKiBub21pbiAqLyBkZWJ1ZyA9IGZ1bmN0aW9uKCkge307XG5cbi8vIE5vdGU6IHRoaXMgaXMgdGhlIHNlbXZlci5vcmcgdmVyc2lvbiBvZiB0aGUgc3BlYyB0aGF0IGl0IGltcGxlbWVudHNcbi8vIE5vdCBuZWNlc3NhcmlseSB0aGUgcGFja2FnZSB2ZXJzaW9uIG9mIHRoaXMgY29kZS5cbmV4cG9ydHMuU0VNVkVSX1NQRUNfVkVSU0lPTiA9ICcyLjAuMCc7XG5cbnZhciBNQVhfTEVOR1RIID0gMjU2O1xudmFyIE1BWF9TQUZFX0lOVEVHRVIgPSBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUiB8fCA5MDA3MTk5MjU0NzQwOTkxO1xuXG4vLyBUaGUgYWN0dWFsIHJlZ2V4cHMgZ28gb24gZXhwb3J0cy5yZVxudmFyIHJlID0gZXhwb3J0cy5yZSA9IFtdO1xudmFyIHNyYyA9IGV4cG9ydHMuc3JjID0gW107XG52YXIgUiA9IDA7XG5cbi8vIFRoZSBmb2xsb3dpbmcgUmVndWxhciBFeHByZXNzaW9ucyBjYW4gYmUgdXNlZCBmb3IgdG9rZW5pemluZyxcbi8vIHZhbGlkYXRpbmcsIGFuZCBwYXJzaW5nIFNlbVZlciB2ZXJzaW9uIHN0cmluZ3MuXG5cbi8vICMjIE51bWVyaWMgSWRlbnRpZmllclxuLy8gQSBzaW5nbGUgYDBgLCBvciBhIG5vbi16ZXJvIGRpZ2l0IGZvbGxvd2VkIGJ5IHplcm8gb3IgbW9yZSBkaWdpdHMuXG5cbnZhciBOVU1FUklDSURFTlRJRklFUiA9IFIrKztcbnNyY1tOVU1FUklDSURFTlRJRklFUl0gPSAnMHxbMS05XVxcXFxkKic7XG52YXIgTlVNRVJJQ0lERU5USUZJRVJMT09TRSA9IFIrKztcbnNyY1tOVU1FUklDSURFTlRJRklFUkxPT1NFXSA9ICdbMC05XSsnO1xuXG5cbi8vICMjIE5vbi1udW1lcmljIElkZW50aWZpZXJcbi8vIFplcm8gb3IgbW9yZSBkaWdpdHMsIGZvbGxvd2VkIGJ5IGEgbGV0dGVyIG9yIGh5cGhlbiwgYW5kIHRoZW4gemVybyBvclxuLy8gbW9yZSBsZXR0ZXJzLCBkaWdpdHMsIG9yIGh5cGhlbnMuXG5cbnZhciBOT05OVU1FUklDSURFTlRJRklFUiA9IFIrKztcbnNyY1tOT05OVU1FUklDSURFTlRJRklFUl0gPSAnXFxcXGQqW2EtekEtWi1dW2EtekEtWjAtOS1dKic7XG5cblxuLy8gIyMgTWFpbiBWZXJzaW9uXG4vLyBUaHJlZSBkb3Qtc2VwYXJhdGVkIG51bWVyaWMgaWRlbnRpZmllcnMuXG5cbnZhciBNQUlOVkVSU0lPTiA9IFIrKztcbnNyY1tNQUlOVkVSU0lPTl0gPSAnKCcgKyBzcmNbTlVNRVJJQ0lERU5USUZJRVJdICsgJylcXFxcLicgK1xuICAgICAgICAgICAgICAgICAgICcoJyArIHNyY1tOVU1FUklDSURFTlRJRklFUl0gKyAnKVxcXFwuJyArXG4gICAgICAgICAgICAgICAgICAgJygnICsgc3JjW05VTUVSSUNJREVOVElGSUVSXSArICcpJztcblxudmFyIE1BSU5WRVJTSU9OTE9PU0UgPSBSKys7XG5zcmNbTUFJTlZFUlNJT05MT09TRV0gPSAnKCcgKyBzcmNbTlVNRVJJQ0lERU5USUZJRVJMT09TRV0gKyAnKVxcXFwuJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAnKCcgKyBzcmNbTlVNRVJJQ0lERU5USUZJRVJMT09TRV0gKyAnKVxcXFwuJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAnKCcgKyBzcmNbTlVNRVJJQ0lERU5USUZJRVJMT09TRV0gKyAnKSc7XG5cbi8vICMjIFByZS1yZWxlYXNlIFZlcnNpb24gSWRlbnRpZmllclxuLy8gQSBudW1lcmljIGlkZW50aWZpZXIsIG9yIGEgbm9uLW51bWVyaWMgaWRlbnRpZmllci5cblxudmFyIFBSRVJFTEVBU0VJREVOVElGSUVSID0gUisrO1xuc3JjW1BSRVJFTEVBU0VJREVOVElGSUVSXSA9ICcoPzonICsgc3JjW05VTUVSSUNJREVOVElGSUVSXSArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJ3wnICsgc3JjW05PTk5VTUVSSUNJREVOVElGSUVSXSArICcpJztcblxudmFyIFBSRVJFTEVBU0VJREVOVElGSUVSTE9PU0UgPSBSKys7XG5zcmNbUFJFUkVMRUFTRUlERU5USUZJRVJMT09TRV0gPSAnKD86JyArIHNyY1tOVU1FUklDSURFTlRJRklFUkxPT1NFXSArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnfCcgKyBzcmNbTk9OTlVNRVJJQ0lERU5USUZJRVJdICsgJyknO1xuXG5cbi8vICMjIFByZS1yZWxlYXNlIFZlcnNpb25cbi8vIEh5cGhlbiwgZm9sbG93ZWQgYnkgb25lIG9yIG1vcmUgZG90LXNlcGFyYXRlZCBwcmUtcmVsZWFzZSB2ZXJzaW9uXG4vLyBpZGVudGlmaWVycy5cblxudmFyIFBSRVJFTEVBU0UgPSBSKys7XG5zcmNbUFJFUkVMRUFTRV0gPSAnKD86LSgnICsgc3JjW1BSRVJFTEVBU0VJREVOVElGSUVSXSArXG4gICAgICAgICAgICAgICAgICAnKD86XFxcXC4nICsgc3JjW1BSRVJFTEVBU0VJREVOVElGSUVSXSArICcpKikpJztcblxudmFyIFBSRVJFTEVBU0VMT09TRSA9IFIrKztcbnNyY1tQUkVSRUxFQVNFTE9PU0VdID0gJyg/Oi0/KCcgKyBzcmNbUFJFUkVMRUFTRUlERU5USUZJRVJMT09TRV0gK1xuICAgICAgICAgICAgICAgICAgICAgICAnKD86XFxcXC4nICsgc3JjW1BSRVJFTEVBU0VJREVOVElGSUVSTE9PU0VdICsgJykqKSknO1xuXG4vLyAjIyBCdWlsZCBNZXRhZGF0YSBJZGVudGlmaWVyXG4vLyBBbnkgY29tYmluYXRpb24gb2YgZGlnaXRzLCBsZXR0ZXJzLCBvciBoeXBoZW5zLlxuXG52YXIgQlVJTERJREVOVElGSUVSID0gUisrO1xuc3JjW0JVSUxESURFTlRJRklFUl0gPSAnWzAtOUEtWmEtei1dKyc7XG5cbi8vICMjIEJ1aWxkIE1ldGFkYXRhXG4vLyBQbHVzIHNpZ24sIGZvbGxvd2VkIGJ5IG9uZSBvciBtb3JlIHBlcmlvZC1zZXBhcmF0ZWQgYnVpbGQgbWV0YWRhdGFcbi8vIGlkZW50aWZpZXJzLlxuXG52YXIgQlVJTEQgPSBSKys7XG5zcmNbQlVJTERdID0gJyg/OlxcXFwrKCcgKyBzcmNbQlVJTERJREVOVElGSUVSXSArXG4gICAgICAgICAgICAgJyg/OlxcXFwuJyArIHNyY1tCVUlMRElERU5USUZJRVJdICsgJykqKSknO1xuXG5cbi8vICMjIEZ1bGwgVmVyc2lvbiBTdHJpbmdcbi8vIEEgbWFpbiB2ZXJzaW9uLCBmb2xsb3dlZCBvcHRpb25hbGx5IGJ5IGEgcHJlLXJlbGVhc2UgdmVyc2lvbiBhbmRcbi8vIGJ1aWxkIG1ldGFkYXRhLlxuXG4vLyBOb3RlIHRoYXQgdGhlIG9ubHkgbWFqb3IsIG1pbm9yLCBwYXRjaCwgYW5kIHByZS1yZWxlYXNlIHNlY3Rpb25zIG9mXG4vLyB0aGUgdmVyc2lvbiBzdHJpbmcgYXJlIGNhcHR1cmluZyBncm91cHMuICBUaGUgYnVpbGQgbWV0YWRhdGEgaXMgbm90IGFcbi8vIGNhcHR1cmluZyBncm91cCwgYmVjYXVzZSBpdCBzaG91bGQgbm90IGV2ZXIgYmUgdXNlZCBpbiB2ZXJzaW9uXG4vLyBjb21wYXJpc29uLlxuXG52YXIgRlVMTCA9IFIrKztcbnZhciBGVUxMUExBSU4gPSAndj8nICsgc3JjW01BSU5WRVJTSU9OXSArXG4gICAgICAgICAgICAgICAgc3JjW1BSRVJFTEVBU0VdICsgJz8nICtcbiAgICAgICAgICAgICAgICBzcmNbQlVJTERdICsgJz8nO1xuXG5zcmNbRlVMTF0gPSAnXicgKyBGVUxMUExBSU4gKyAnJCc7XG5cbi8vIGxpa2UgZnVsbCwgYnV0IGFsbG93cyB2MS4yLjMgYW5kID0xLjIuMywgd2hpY2ggcGVvcGxlIGRvIHNvbWV0aW1lcy5cbi8vIGFsc28sIDEuMC4wYWxwaGExIChwcmVyZWxlYXNlIHdpdGhvdXQgdGhlIGh5cGhlbikgd2hpY2ggaXMgcHJldHR5XG4vLyBjb21tb24gaW4gdGhlIG5wbSByZWdpc3RyeS5cbnZhciBMT09TRVBMQUlOID0gJ1t2PVxcXFxzXSonICsgc3JjW01BSU5WRVJTSU9OTE9PU0VdICtcbiAgICAgICAgICAgICAgICAgc3JjW1BSRVJFTEVBU0VMT09TRV0gKyAnPycgK1xuICAgICAgICAgICAgICAgICBzcmNbQlVJTERdICsgJz8nO1xuXG52YXIgTE9PU0UgPSBSKys7XG5zcmNbTE9PU0VdID0gJ14nICsgTE9PU0VQTEFJTiArICckJztcblxudmFyIEdUTFQgPSBSKys7XG5zcmNbR1RMVF0gPSAnKCg/Ojx8Pik/PT8pJztcblxuLy8gU29tZXRoaW5nIGxpa2UgXCIyLipcIiBvciBcIjEuMi54XCIuXG4vLyBOb3RlIHRoYXQgXCJ4LnhcIiBpcyBhIHZhbGlkIHhSYW5nZSBpZGVudGlmZXIsIG1lYW5pbmcgXCJhbnkgdmVyc2lvblwiXG4vLyBPbmx5IHRoZSBmaXJzdCBpdGVtIGlzIHN0cmljdGx5IHJlcXVpcmVkLlxudmFyIFhSQU5HRUlERU5USUZJRVJMT09TRSA9IFIrKztcbnNyY1tYUkFOR0VJREVOVElGSUVSTE9PU0VdID0gc3JjW05VTUVSSUNJREVOVElGSUVSTE9PU0VdICsgJ3x4fFh8XFxcXConO1xudmFyIFhSQU5HRUlERU5USUZJRVIgPSBSKys7XG5zcmNbWFJBTkdFSURFTlRJRklFUl0gPSBzcmNbTlVNRVJJQ0lERU5USUZJRVJdICsgJ3x4fFh8XFxcXConO1xuXG52YXIgWFJBTkdFUExBSU4gPSBSKys7XG5zcmNbWFJBTkdFUExBSU5dID0gJ1t2PVxcXFxzXSooJyArIHNyY1tYUkFOR0VJREVOVElGSUVSXSArICcpJyArXG4gICAgICAgICAgICAgICAgICAgJyg/OlxcXFwuKCcgKyBzcmNbWFJBTkdFSURFTlRJRklFUl0gKyAnKScgK1xuICAgICAgICAgICAgICAgICAgICcoPzpcXFxcLignICsgc3JjW1hSQU5HRUlERU5USUZJRVJdICsgJyknICtcbiAgICAgICAgICAgICAgICAgICAnKD86JyArIHNyY1tQUkVSRUxFQVNFXSArICcpPycgK1xuICAgICAgICAgICAgICAgICAgIHNyY1tCVUlMRF0gKyAnPycgK1xuICAgICAgICAgICAgICAgICAgICcpPyk/JztcblxudmFyIFhSQU5HRVBMQUlOTE9PU0UgPSBSKys7XG5zcmNbWFJBTkdFUExBSU5MT09TRV0gPSAnW3Y9XFxcXHNdKignICsgc3JjW1hSQU5HRUlERU5USUZJRVJMT09TRV0gKyAnKScgK1xuICAgICAgICAgICAgICAgICAgICAgICAgJyg/OlxcXFwuKCcgKyBzcmNbWFJBTkdFSURFTlRJRklFUkxPT1NFXSArICcpJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAnKD86XFxcXC4oJyArIHNyY1tYUkFOR0VJREVOVElGSUVSTE9PU0VdICsgJyknICtcbiAgICAgICAgICAgICAgICAgICAgICAgICcoPzonICsgc3JjW1BSRVJFTEVBU0VMT09TRV0gKyAnKT8nICtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNyY1tCVUlMRF0gKyAnPycgK1xuICAgICAgICAgICAgICAgICAgICAgICAgJyk/KT8nO1xuXG52YXIgWFJBTkdFID0gUisrO1xuc3JjW1hSQU5HRV0gPSAnXicgKyBzcmNbR1RMVF0gKyAnXFxcXHMqJyArIHNyY1tYUkFOR0VQTEFJTl0gKyAnJCc7XG52YXIgWFJBTkdFTE9PU0UgPSBSKys7XG5zcmNbWFJBTkdFTE9PU0VdID0gJ14nICsgc3JjW0dUTFRdICsgJ1xcXFxzKicgKyBzcmNbWFJBTkdFUExBSU5MT09TRV0gKyAnJCc7XG5cbi8vIFRpbGRlIHJhbmdlcy5cbi8vIE1lYW5pbmcgaXMgXCJyZWFzb25hYmx5IGF0IG9yIGdyZWF0ZXIgdGhhblwiXG52YXIgTE9ORVRJTERFID0gUisrO1xuc3JjW0xPTkVUSUxERV0gPSAnKD86fj4/KSc7XG5cbnZhciBUSUxERVRSSU0gPSBSKys7XG5zcmNbVElMREVUUklNXSA9ICcoXFxcXHMqKScgKyBzcmNbTE9ORVRJTERFXSArICdcXFxccysnO1xucmVbVElMREVUUklNXSA9IG5ldyBSZWdFeHAoc3JjW1RJTERFVFJJTV0sICdnJyk7XG52YXIgdGlsZGVUcmltUmVwbGFjZSA9ICckMX4nO1xuXG52YXIgVElMREUgPSBSKys7XG5zcmNbVElMREVdID0gJ14nICsgc3JjW0xPTkVUSUxERV0gKyBzcmNbWFJBTkdFUExBSU5dICsgJyQnO1xudmFyIFRJTERFTE9PU0UgPSBSKys7XG5zcmNbVElMREVMT09TRV0gPSAnXicgKyBzcmNbTE9ORVRJTERFXSArIHNyY1tYUkFOR0VQTEFJTkxPT1NFXSArICckJztcblxuLy8gQ2FyZXQgcmFuZ2VzLlxuLy8gTWVhbmluZyBpcyBcImF0IGxlYXN0IGFuZCBiYWNrd2FyZHMgY29tcGF0aWJsZSB3aXRoXCJcbnZhciBMT05FQ0FSRVQgPSBSKys7XG5zcmNbTE9ORUNBUkVUXSA9ICcoPzpcXFxcXiknO1xuXG52YXIgQ0FSRVRUUklNID0gUisrO1xuc3JjW0NBUkVUVFJJTV0gPSAnKFxcXFxzKiknICsgc3JjW0xPTkVDQVJFVF0gKyAnXFxcXHMrJztcbnJlW0NBUkVUVFJJTV0gPSBuZXcgUmVnRXhwKHNyY1tDQVJFVFRSSU1dLCAnZycpO1xudmFyIGNhcmV0VHJpbVJlcGxhY2UgPSAnJDFeJztcblxudmFyIENBUkVUID0gUisrO1xuc3JjW0NBUkVUXSA9ICdeJyArIHNyY1tMT05FQ0FSRVRdICsgc3JjW1hSQU5HRVBMQUlOXSArICckJztcbnZhciBDQVJFVExPT1NFID0gUisrO1xuc3JjW0NBUkVUTE9PU0VdID0gJ14nICsgc3JjW0xPTkVDQVJFVF0gKyBzcmNbWFJBTkdFUExBSU5MT09TRV0gKyAnJCc7XG5cbi8vIEEgc2ltcGxlIGd0L2x0L2VxIHRoaW5nLCBvciBqdXN0IFwiXCIgdG8gaW5kaWNhdGUgXCJhbnkgdmVyc2lvblwiXG52YXIgQ09NUEFSQVRPUkxPT1NFID0gUisrO1xuc3JjW0NPTVBBUkFUT1JMT09TRV0gPSAnXicgKyBzcmNbR1RMVF0gKyAnXFxcXHMqKCcgKyBMT09TRVBMQUlOICsgJykkfF4kJztcbnZhciBDT01QQVJBVE9SID0gUisrO1xuc3JjW0NPTVBBUkFUT1JdID0gJ14nICsgc3JjW0dUTFRdICsgJ1xcXFxzKignICsgRlVMTFBMQUlOICsgJykkfF4kJztcblxuXG4vLyBBbiBleHByZXNzaW9uIHRvIHN0cmlwIGFueSB3aGl0ZXNwYWNlIGJldHdlZW4gdGhlIGd0bHQgYW5kIHRoZSB0aGluZ1xuLy8gaXQgbW9kaWZpZXMsIHNvIHRoYXQgYD4gMS4yLjNgID09PiBgPjEuMi4zYFxudmFyIENPTVBBUkFUT1JUUklNID0gUisrO1xuc3JjW0NPTVBBUkFUT1JUUklNXSA9ICcoXFxcXHMqKScgKyBzcmNbR1RMVF0gK1xuICAgICAgICAgICAgICAgICAgICAgICdcXFxccyooJyArIExPT1NFUExBSU4gKyAnfCcgKyBzcmNbWFJBTkdFUExBSU5dICsgJyknO1xuXG4vLyB0aGlzIG9uZSBoYXMgdG8gdXNlIHRoZSAvZyBmbGFnXG5yZVtDT01QQVJBVE9SVFJJTV0gPSBuZXcgUmVnRXhwKHNyY1tDT01QQVJBVE9SVFJJTV0sICdnJyk7XG52YXIgY29tcGFyYXRvclRyaW1SZXBsYWNlID0gJyQxJDIkMyc7XG5cblxuLy8gU29tZXRoaW5nIGxpa2UgYDEuMi4zIC0gMS4yLjRgXG4vLyBOb3RlIHRoYXQgdGhlc2UgYWxsIHVzZSB0aGUgbG9vc2UgZm9ybSwgYmVjYXVzZSB0aGV5J2xsIGJlXG4vLyBjaGVja2VkIGFnYWluc3QgZWl0aGVyIHRoZSBzdHJpY3Qgb3IgbG9vc2UgY29tcGFyYXRvciBmb3JtXG4vLyBsYXRlci5cbnZhciBIWVBIRU5SQU5HRSA9IFIrKztcbnNyY1tIWVBIRU5SQU5HRV0gPSAnXlxcXFxzKignICsgc3JjW1hSQU5HRVBMQUlOXSArICcpJyArXG4gICAgICAgICAgICAgICAgICAgJ1xcXFxzKy1cXFxccysnICtcbiAgICAgICAgICAgICAgICAgICAnKCcgKyBzcmNbWFJBTkdFUExBSU5dICsgJyknICtcbiAgICAgICAgICAgICAgICAgICAnXFxcXHMqJCc7XG5cbnZhciBIWVBIRU5SQU5HRUxPT1NFID0gUisrO1xuc3JjW0hZUEhFTlJBTkdFTE9PU0VdID0gJ15cXFxccyooJyArIHNyY1tYUkFOR0VQTEFJTkxPT1NFXSArICcpJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAnXFxcXHMrLVxcXFxzKycgK1xuICAgICAgICAgICAgICAgICAgICAgICAgJygnICsgc3JjW1hSQU5HRVBMQUlOTE9PU0VdICsgJyknICtcbiAgICAgICAgICAgICAgICAgICAgICAgICdcXFxccyokJztcblxuLy8gU3RhciByYW5nZXMgYmFzaWNhbGx5IGp1c3QgYWxsb3cgYW55dGhpbmcgYXQgYWxsLlxudmFyIFNUQVIgPSBSKys7XG5zcmNbU1RBUl0gPSAnKDx8Pik/PT9cXFxccypcXFxcKic7XG5cbi8vIENvbXBpbGUgdG8gYWN0dWFsIHJlZ2V4cCBvYmplY3RzLlxuLy8gQWxsIGFyZSBmbGFnLWZyZWUsIHVubGVzcyB0aGV5IHdlcmUgY3JlYXRlZCBhYm92ZSB3aXRoIGEgZmxhZy5cbmZvciAodmFyIGkgPSAwOyBpIDwgUjsgaSsrKSB7XG4gIGRlYnVnKGksIHNyY1tpXSk7XG4gIGlmICghcmVbaV0pXG4gICAgcmVbaV0gPSBuZXcgUmVnRXhwKHNyY1tpXSk7XG59XG5cbmV4cG9ydHMucGFyc2UgPSBwYXJzZTtcbmZ1bmN0aW9uIHBhcnNlKHZlcnNpb24sIGxvb3NlKSB7XG4gIGlmICh2ZXJzaW9uIGluc3RhbmNlb2YgU2VtVmVyKVxuICAgIHJldHVybiB2ZXJzaW9uO1xuXG4gIGlmICh0eXBlb2YgdmVyc2lvbiAhPT0gJ3N0cmluZycpXG4gICAgcmV0dXJuIG51bGw7XG5cbiAgaWYgKHZlcnNpb24ubGVuZ3RoID4gTUFYX0xFTkdUSClcbiAgICByZXR1cm4gbnVsbDtcblxuICB2YXIgciA9IGxvb3NlID8gcmVbTE9PU0VdIDogcmVbRlVMTF07XG4gIGlmICghci50ZXN0KHZlcnNpb24pKVxuICAgIHJldHVybiBudWxsO1xuXG4gIHRyeSB7XG4gICAgcmV0dXJuIG5ldyBTZW1WZXIodmVyc2lvbiwgbG9vc2UpO1xuICB9IGNhdGNoIChlcikge1xuICAgIHJldHVybiBudWxsO1xuICB9XG59XG5cbmV4cG9ydHMudmFsaWQgPSB2YWxpZDtcbmZ1bmN0aW9uIHZhbGlkKHZlcnNpb24sIGxvb3NlKSB7XG4gIHZhciB2ID0gcGFyc2UodmVyc2lvbiwgbG9vc2UpO1xuICByZXR1cm4gdiA/IHYudmVyc2lvbiA6IG51bGw7XG59XG5cblxuZXhwb3J0cy5jbGVhbiA9IGNsZWFuO1xuZnVuY3Rpb24gY2xlYW4odmVyc2lvbiwgbG9vc2UpIHtcbiAgdmFyIHMgPSBwYXJzZSh2ZXJzaW9uLnRyaW0oKS5yZXBsYWNlKC9eWz12XSsvLCAnJyksIGxvb3NlKTtcbiAgcmV0dXJuIHMgPyBzLnZlcnNpb24gOiBudWxsO1xufVxuXG5leHBvcnRzLlNlbVZlciA9IFNlbVZlcjtcblxuZnVuY3Rpb24gU2VtVmVyKHZlcnNpb24sIGxvb3NlKSB7XG4gIGlmICh2ZXJzaW9uIGluc3RhbmNlb2YgU2VtVmVyKSB7XG4gICAgaWYgKHZlcnNpb24ubG9vc2UgPT09IGxvb3NlKVxuICAgICAgcmV0dXJuIHZlcnNpb247XG4gICAgZWxzZVxuICAgICAgdmVyc2lvbiA9IHZlcnNpb24udmVyc2lvbjtcbiAgfSBlbHNlIGlmICh0eXBlb2YgdmVyc2lvbiAhPT0gJ3N0cmluZycpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdJbnZhbGlkIFZlcnNpb246ICcgKyB2ZXJzaW9uKTtcbiAgfVxuXG4gIGlmICh2ZXJzaW9uLmxlbmd0aCA+IE1BWF9MRU5HVEgpXG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcigndmVyc2lvbiBpcyBsb25nZXIgdGhhbiAnICsgTUFYX0xFTkdUSCArICcgY2hhcmFjdGVycycpXG5cbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIFNlbVZlcikpXG4gICAgcmV0dXJuIG5ldyBTZW1WZXIodmVyc2lvbiwgbG9vc2UpO1xuXG4gIGRlYnVnKCdTZW1WZXInLCB2ZXJzaW9uLCBsb29zZSk7XG4gIHRoaXMubG9vc2UgPSBsb29zZTtcbiAgdmFyIG0gPSB2ZXJzaW9uLnRyaW0oKS5tYXRjaChsb29zZSA/IHJlW0xPT1NFXSA6IHJlW0ZVTExdKTtcblxuICBpZiAoIW0pXG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignSW52YWxpZCBWZXJzaW9uOiAnICsgdmVyc2lvbik7XG5cbiAgdGhpcy5yYXcgPSB2ZXJzaW9uO1xuXG4gIC8vIHRoZXNlIGFyZSBhY3R1YWxseSBudW1iZXJzXG4gIHRoaXMubWFqb3IgPSArbVsxXTtcbiAgdGhpcy5taW5vciA9ICttWzJdO1xuICB0aGlzLnBhdGNoID0gK21bM107XG5cbiAgaWYgKHRoaXMubWFqb3IgPiBNQVhfU0FGRV9JTlRFR0VSIHx8IHRoaXMubWFqb3IgPCAwKVxuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0ludmFsaWQgbWFqb3IgdmVyc2lvbicpXG5cbiAgaWYgKHRoaXMubWlub3IgPiBNQVhfU0FGRV9JTlRFR0VSIHx8IHRoaXMubWlub3IgPCAwKVxuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0ludmFsaWQgbWlub3IgdmVyc2lvbicpXG5cbiAgaWYgKHRoaXMucGF0Y2ggPiBNQVhfU0FGRV9JTlRFR0VSIHx8IHRoaXMucGF0Y2ggPCAwKVxuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0ludmFsaWQgcGF0Y2ggdmVyc2lvbicpXG5cbiAgLy8gbnVtYmVyaWZ5IGFueSBwcmVyZWxlYXNlIG51bWVyaWMgaWRzXG4gIGlmICghbVs0XSlcbiAgICB0aGlzLnByZXJlbGVhc2UgPSBbXTtcbiAgZWxzZVxuICAgIHRoaXMucHJlcmVsZWFzZSA9IG1bNF0uc3BsaXQoJy4nKS5tYXAoZnVuY3Rpb24oaWQpIHtcbiAgICAgIGlmICgvXlswLTldKyQvLnRlc3QoaWQpKSB7XG4gICAgICAgIHZhciBudW0gPSAraWQ7XG4gICAgICAgIGlmIChudW0gPj0gMCAmJiBudW0gPCBNQVhfU0FGRV9JTlRFR0VSKVxuICAgICAgICAgIHJldHVybiBudW07XG4gICAgICB9XG4gICAgICByZXR1cm4gaWQ7XG4gICAgfSk7XG5cbiAgdGhpcy5idWlsZCA9IG1bNV0gPyBtWzVdLnNwbGl0KCcuJykgOiBbXTtcbiAgdGhpcy5mb3JtYXQoKTtcbn1cblxuU2VtVmVyLnByb3RvdHlwZS5mb3JtYXQgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy52ZXJzaW9uID0gdGhpcy5tYWpvciArICcuJyArIHRoaXMubWlub3IgKyAnLicgKyB0aGlzLnBhdGNoO1xuICBpZiAodGhpcy5wcmVyZWxlYXNlLmxlbmd0aClcbiAgICB0aGlzLnZlcnNpb24gKz0gJy0nICsgdGhpcy5wcmVyZWxlYXNlLmpvaW4oJy4nKTtcbiAgcmV0dXJuIHRoaXMudmVyc2lvbjtcbn07XG5cblNlbVZlci5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMudmVyc2lvbjtcbn07XG5cblNlbVZlci5wcm90b3R5cGUuY29tcGFyZSA9IGZ1bmN0aW9uKG90aGVyKSB7XG4gIGRlYnVnKCdTZW1WZXIuY29tcGFyZScsIHRoaXMudmVyc2lvbiwgdGhpcy5sb29zZSwgb3RoZXIpO1xuICBpZiAoIShvdGhlciBpbnN0YW5jZW9mIFNlbVZlcikpXG4gICAgb3RoZXIgPSBuZXcgU2VtVmVyKG90aGVyLCB0aGlzLmxvb3NlKTtcblxuICByZXR1cm4gdGhpcy5jb21wYXJlTWFpbihvdGhlcikgfHwgdGhpcy5jb21wYXJlUHJlKG90aGVyKTtcbn07XG5cblNlbVZlci5wcm90b3R5cGUuY29tcGFyZU1haW4gPSBmdW5jdGlvbihvdGhlcikge1xuICBpZiAoIShvdGhlciBpbnN0YW5jZW9mIFNlbVZlcikpXG4gICAgb3RoZXIgPSBuZXcgU2VtVmVyKG90aGVyLCB0aGlzLmxvb3NlKTtcblxuICByZXR1cm4gY29tcGFyZUlkZW50aWZpZXJzKHRoaXMubWFqb3IsIG90aGVyLm1ham9yKSB8fFxuICAgICAgICAgY29tcGFyZUlkZW50aWZpZXJzKHRoaXMubWlub3IsIG90aGVyLm1pbm9yKSB8fFxuICAgICAgICAgY29tcGFyZUlkZW50aWZpZXJzKHRoaXMucGF0Y2gsIG90aGVyLnBhdGNoKTtcbn07XG5cblNlbVZlci5wcm90b3R5cGUuY29tcGFyZVByZSA9IGZ1bmN0aW9uKG90aGVyKSB7XG4gIGlmICghKG90aGVyIGluc3RhbmNlb2YgU2VtVmVyKSlcbiAgICBvdGhlciA9IG5ldyBTZW1WZXIob3RoZXIsIHRoaXMubG9vc2UpO1xuXG4gIC8vIE5PVCBoYXZpbmcgYSBwcmVyZWxlYXNlIGlzID4gaGF2aW5nIG9uZVxuICBpZiAodGhpcy5wcmVyZWxlYXNlLmxlbmd0aCAmJiAhb3RoZXIucHJlcmVsZWFzZS5sZW5ndGgpXG4gICAgcmV0dXJuIC0xO1xuICBlbHNlIGlmICghdGhpcy5wcmVyZWxlYXNlLmxlbmd0aCAmJiBvdGhlci5wcmVyZWxlYXNlLmxlbmd0aClcbiAgICByZXR1cm4gMTtcbiAgZWxzZSBpZiAoIXRoaXMucHJlcmVsZWFzZS5sZW5ndGggJiYgIW90aGVyLnByZXJlbGVhc2UubGVuZ3RoKVxuICAgIHJldHVybiAwO1xuXG4gIHZhciBpID0gMDtcbiAgZG8ge1xuICAgIHZhciBhID0gdGhpcy5wcmVyZWxlYXNlW2ldO1xuICAgIHZhciBiID0gb3RoZXIucHJlcmVsZWFzZVtpXTtcbiAgICBkZWJ1ZygncHJlcmVsZWFzZSBjb21wYXJlJywgaSwgYSwgYik7XG4gICAgaWYgKGEgPT09IHVuZGVmaW5lZCAmJiBiID09PSB1bmRlZmluZWQpXG4gICAgICByZXR1cm4gMDtcbiAgICBlbHNlIGlmIChiID09PSB1bmRlZmluZWQpXG4gICAgICByZXR1cm4gMTtcbiAgICBlbHNlIGlmIChhID09PSB1bmRlZmluZWQpXG4gICAgICByZXR1cm4gLTE7XG4gICAgZWxzZSBpZiAoYSA9PT0gYilcbiAgICAgIGNvbnRpbnVlO1xuICAgIGVsc2VcbiAgICAgIHJldHVybiBjb21wYXJlSWRlbnRpZmllcnMoYSwgYik7XG4gIH0gd2hpbGUgKCsraSk7XG59O1xuXG4vLyBwcmVtaW5vciB3aWxsIGJ1bXAgdGhlIHZlcnNpb24gdXAgdG8gdGhlIG5leHQgbWlub3IgcmVsZWFzZSwgYW5kIGltbWVkaWF0ZWx5XG4vLyBkb3duIHRvIHByZS1yZWxlYXNlLiBwcmVtYWpvciBhbmQgcHJlcGF0Y2ggd29yayB0aGUgc2FtZSB3YXkuXG5TZW1WZXIucHJvdG90eXBlLmluYyA9IGZ1bmN0aW9uKHJlbGVhc2UsIGlkZW50aWZpZXIpIHtcbiAgc3dpdGNoIChyZWxlYXNlKSB7XG4gICAgY2FzZSAncHJlbWFqb3InOlxuICAgICAgdGhpcy5wcmVyZWxlYXNlLmxlbmd0aCA9IDA7XG4gICAgICB0aGlzLnBhdGNoID0gMDtcbiAgICAgIHRoaXMubWlub3IgPSAwO1xuICAgICAgdGhpcy5tYWpvcisrO1xuICAgICAgdGhpcy5pbmMoJ3ByZScsIGlkZW50aWZpZXIpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAncHJlbWlub3InOlxuICAgICAgdGhpcy5wcmVyZWxlYXNlLmxlbmd0aCA9IDA7XG4gICAgICB0aGlzLnBhdGNoID0gMDtcbiAgICAgIHRoaXMubWlub3IrKztcbiAgICAgIHRoaXMuaW5jKCdwcmUnLCBpZGVudGlmaWVyKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ3ByZXBhdGNoJzpcbiAgICAgIC8vIElmIHRoaXMgaXMgYWxyZWFkeSBhIHByZXJlbGVhc2UsIGl0IHdpbGwgYnVtcCB0byB0aGUgbmV4dCB2ZXJzaW9uXG4gICAgICAvLyBkcm9wIGFueSBwcmVyZWxlYXNlcyB0aGF0IG1pZ2h0IGFscmVhZHkgZXhpc3QsIHNpbmNlIHRoZXkgYXJlIG5vdFxuICAgICAgLy8gcmVsZXZhbnQgYXQgdGhpcyBwb2ludC5cbiAgICAgIHRoaXMucHJlcmVsZWFzZS5sZW5ndGggPSAwO1xuICAgICAgdGhpcy5pbmMoJ3BhdGNoJywgaWRlbnRpZmllcik7XG4gICAgICB0aGlzLmluYygncHJlJywgaWRlbnRpZmllcik7XG4gICAgICBicmVhaztcbiAgICAvLyBJZiB0aGUgaW5wdXQgaXMgYSBub24tcHJlcmVsZWFzZSB2ZXJzaW9uLCB0aGlzIGFjdHMgdGhlIHNhbWUgYXNcbiAgICAvLyBwcmVwYXRjaC5cbiAgICBjYXNlICdwcmVyZWxlYXNlJzpcbiAgICAgIGlmICh0aGlzLnByZXJlbGVhc2UubGVuZ3RoID09PSAwKVxuICAgICAgICB0aGlzLmluYygncGF0Y2gnLCBpZGVudGlmaWVyKTtcbiAgICAgIHRoaXMuaW5jKCdwcmUnLCBpZGVudGlmaWVyKTtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSAnbWFqb3InOlxuICAgICAgLy8gSWYgdGhpcyBpcyBhIHByZS1tYWpvciB2ZXJzaW9uLCBidW1wIHVwIHRvIHRoZSBzYW1lIG1ham9yIHZlcnNpb24uXG4gICAgICAvLyBPdGhlcndpc2UgaW5jcmVtZW50IG1ham9yLlxuICAgICAgLy8gMS4wLjAtNSBidW1wcyB0byAxLjAuMFxuICAgICAgLy8gMS4xLjAgYnVtcHMgdG8gMi4wLjBcbiAgICAgIGlmICh0aGlzLm1pbm9yICE9PSAwIHx8IHRoaXMucGF0Y2ggIT09IDAgfHwgdGhpcy5wcmVyZWxlYXNlLmxlbmd0aCA9PT0gMClcbiAgICAgICAgdGhpcy5tYWpvcisrO1xuICAgICAgdGhpcy5taW5vciA9IDA7XG4gICAgICB0aGlzLnBhdGNoID0gMDtcbiAgICAgIHRoaXMucHJlcmVsZWFzZSA9IFtdO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnbWlub3InOlxuICAgICAgLy8gSWYgdGhpcyBpcyBhIHByZS1taW5vciB2ZXJzaW9uLCBidW1wIHVwIHRvIHRoZSBzYW1lIG1pbm9yIHZlcnNpb24uXG4gICAgICAvLyBPdGhlcndpc2UgaW5jcmVtZW50IG1pbm9yLlxuICAgICAgLy8gMS4yLjAtNSBidW1wcyB0byAxLjIuMFxuICAgICAgLy8gMS4yLjEgYnVtcHMgdG8gMS4zLjBcbiAgICAgIGlmICh0aGlzLnBhdGNoICE9PSAwIHx8IHRoaXMucHJlcmVsZWFzZS5sZW5ndGggPT09IDApXG4gICAgICAgIHRoaXMubWlub3IrKztcbiAgICAgIHRoaXMucGF0Y2ggPSAwO1xuICAgICAgdGhpcy5wcmVyZWxlYXNlID0gW107XG4gICAgICBicmVhaztcbiAgICBjYXNlICdwYXRjaCc6XG4gICAgICAvLyBJZiB0aGlzIGlzIG5vdCBhIHByZS1yZWxlYXNlIHZlcnNpb24sIGl0IHdpbGwgaW5jcmVtZW50IHRoZSBwYXRjaC5cbiAgICAgIC8vIElmIGl0IGlzIGEgcHJlLXJlbGVhc2UgaXQgd2lsbCBidW1wIHVwIHRvIHRoZSBzYW1lIHBhdGNoIHZlcnNpb24uXG4gICAgICAvLyAxLjIuMC01IHBhdGNoZXMgdG8gMS4yLjBcbiAgICAgIC8vIDEuMi4wIHBhdGNoZXMgdG8gMS4yLjFcbiAgICAgIGlmICh0aGlzLnByZXJlbGVhc2UubGVuZ3RoID09PSAwKVxuICAgICAgICB0aGlzLnBhdGNoKys7XG4gICAgICB0aGlzLnByZXJlbGVhc2UgPSBbXTtcbiAgICAgIGJyZWFrO1xuICAgIC8vIFRoaXMgcHJvYmFibHkgc2hvdWxkbid0IGJlIHVzZWQgcHVibGljbHkuXG4gICAgLy8gMS4wLjAgXCJwcmVcIiB3b3VsZCBiZWNvbWUgMS4wLjAtMCB3aGljaCBpcyB0aGUgd3JvbmcgZGlyZWN0aW9uLlxuICAgIGNhc2UgJ3ByZSc6XG4gICAgICBpZiAodGhpcy5wcmVyZWxlYXNlLmxlbmd0aCA9PT0gMClcbiAgICAgICAgdGhpcy5wcmVyZWxlYXNlID0gWzBdO1xuICAgICAgZWxzZSB7XG4gICAgICAgIHZhciBpID0gdGhpcy5wcmVyZWxlYXNlLmxlbmd0aDtcbiAgICAgICAgd2hpbGUgKC0taSA+PSAwKSB7XG4gICAgICAgICAgaWYgKHR5cGVvZiB0aGlzLnByZXJlbGVhc2VbaV0gPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICB0aGlzLnByZXJlbGVhc2VbaV0rKztcbiAgICAgICAgICAgIGkgPSAtMjtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGkgPT09IC0xKSAvLyBkaWRuJ3QgaW5jcmVtZW50IGFueXRoaW5nXG4gICAgICAgICAgdGhpcy5wcmVyZWxlYXNlLnB1c2goMCk7XG4gICAgICB9XG4gICAgICBpZiAoaWRlbnRpZmllcikge1xuICAgICAgICAvLyAxLjIuMC1iZXRhLjEgYnVtcHMgdG8gMS4yLjAtYmV0YS4yLFxuICAgICAgICAvLyAxLjIuMC1iZXRhLmZvb2JseiBvciAxLjIuMC1iZXRhIGJ1bXBzIHRvIDEuMi4wLWJldGEuMFxuICAgICAgICBpZiAodGhpcy5wcmVyZWxlYXNlWzBdID09PSBpZGVudGlmaWVyKSB7XG4gICAgICAgICAgaWYgKGlzTmFOKHRoaXMucHJlcmVsZWFzZVsxXSkpXG4gICAgICAgICAgICB0aGlzLnByZXJlbGVhc2UgPSBbaWRlbnRpZmllciwgMF07XG4gICAgICAgIH0gZWxzZVxuICAgICAgICAgIHRoaXMucHJlcmVsZWFzZSA9IFtpZGVudGlmaWVyLCAwXTtcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuXG4gICAgZGVmYXVsdDpcbiAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBpbmNyZW1lbnQgYXJndW1lbnQ6ICcgKyByZWxlYXNlKTtcbiAgfVxuICB0aGlzLmZvcm1hdCgpO1xuICB0aGlzLnJhdyA9IHRoaXMudmVyc2lvbjtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5leHBvcnRzLmluYyA9IGluYztcbmZ1bmN0aW9uIGluYyh2ZXJzaW9uLCByZWxlYXNlLCBsb29zZSwgaWRlbnRpZmllcikge1xuICBpZiAodHlwZW9mKGxvb3NlKSA9PT0gJ3N0cmluZycpIHtcbiAgICBpZGVudGlmaWVyID0gbG9vc2U7XG4gICAgbG9vc2UgPSB1bmRlZmluZWQ7XG4gIH1cblxuICB0cnkge1xuICAgIHJldHVybiBuZXcgU2VtVmVyKHZlcnNpb24sIGxvb3NlKS5pbmMocmVsZWFzZSwgaWRlbnRpZmllcikudmVyc2lvbjtcbiAgfSBjYXRjaCAoZXIpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxufVxuXG5leHBvcnRzLmRpZmYgPSBkaWZmO1xuZnVuY3Rpb24gZGlmZih2ZXJzaW9uMSwgdmVyc2lvbjIpIHtcbiAgaWYgKGVxKHZlcnNpb24xLCB2ZXJzaW9uMikpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfSBlbHNlIHtcbiAgICB2YXIgdjEgPSBwYXJzZSh2ZXJzaW9uMSk7XG4gICAgdmFyIHYyID0gcGFyc2UodmVyc2lvbjIpO1xuICAgIGlmICh2MS5wcmVyZWxlYXNlLmxlbmd0aCB8fCB2Mi5wcmVyZWxlYXNlLmxlbmd0aCkge1xuICAgICAgZm9yICh2YXIga2V5IGluIHYxKSB7XG4gICAgICAgIGlmIChrZXkgPT09ICdtYWpvcicgfHwga2V5ID09PSAnbWlub3InIHx8IGtleSA9PT0gJ3BhdGNoJykge1xuICAgICAgICAgIGlmICh2MVtrZXldICE9PSB2MltrZXldKSB7XG4gICAgICAgICAgICByZXR1cm4gJ3ByZScra2V5O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuICdwcmVyZWxlYXNlJztcbiAgICB9XG4gICAgZm9yICh2YXIga2V5IGluIHYxKSB7XG4gICAgICBpZiAoa2V5ID09PSAnbWFqb3InIHx8IGtleSA9PT0gJ21pbm9yJyB8fCBrZXkgPT09ICdwYXRjaCcpIHtcbiAgICAgICAgaWYgKHYxW2tleV0gIT09IHYyW2tleV0pIHtcbiAgICAgICAgICByZXR1cm4ga2V5O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmV4cG9ydHMuY29tcGFyZUlkZW50aWZpZXJzID0gY29tcGFyZUlkZW50aWZpZXJzO1xuXG52YXIgbnVtZXJpYyA9IC9eWzAtOV0rJC87XG5mdW5jdGlvbiBjb21wYXJlSWRlbnRpZmllcnMoYSwgYikge1xuICB2YXIgYW51bSA9IG51bWVyaWMudGVzdChhKTtcbiAgdmFyIGJudW0gPSBudW1lcmljLnRlc3QoYik7XG5cbiAgaWYgKGFudW0gJiYgYm51bSkge1xuICAgIGEgPSArYTtcbiAgICBiID0gK2I7XG4gIH1cblxuICByZXR1cm4gKGFudW0gJiYgIWJudW0pID8gLTEgOlxuICAgICAgICAgKGJudW0gJiYgIWFudW0pID8gMSA6XG4gICAgICAgICBhIDwgYiA/IC0xIDpcbiAgICAgICAgIGEgPiBiID8gMSA6XG4gICAgICAgICAwO1xufVxuXG5leHBvcnRzLnJjb21wYXJlSWRlbnRpZmllcnMgPSByY29tcGFyZUlkZW50aWZpZXJzO1xuZnVuY3Rpb24gcmNvbXBhcmVJZGVudGlmaWVycyhhLCBiKSB7XG4gIHJldHVybiBjb21wYXJlSWRlbnRpZmllcnMoYiwgYSk7XG59XG5cbmV4cG9ydHMubWFqb3IgPSBtYWpvcjtcbmZ1bmN0aW9uIG1ham9yKGEsIGxvb3NlKSB7XG4gIHJldHVybiBuZXcgU2VtVmVyKGEsIGxvb3NlKS5tYWpvcjtcbn1cblxuZXhwb3J0cy5taW5vciA9IG1pbm9yO1xuZnVuY3Rpb24gbWlub3IoYSwgbG9vc2UpIHtcbiAgcmV0dXJuIG5ldyBTZW1WZXIoYSwgbG9vc2UpLm1pbm9yO1xufVxuXG5leHBvcnRzLnBhdGNoID0gcGF0Y2g7XG5mdW5jdGlvbiBwYXRjaChhLCBsb29zZSkge1xuICByZXR1cm4gbmV3IFNlbVZlcihhLCBsb29zZSkucGF0Y2g7XG59XG5cbmV4cG9ydHMuY29tcGFyZSA9IGNvbXBhcmU7XG5mdW5jdGlvbiBjb21wYXJlKGEsIGIsIGxvb3NlKSB7XG4gIHJldHVybiBuZXcgU2VtVmVyKGEsIGxvb3NlKS5jb21wYXJlKG5ldyBTZW1WZXIoYiwgbG9vc2UpKTtcbn1cblxuZXhwb3J0cy5jb21wYXJlTG9vc2UgPSBjb21wYXJlTG9vc2U7XG5mdW5jdGlvbiBjb21wYXJlTG9vc2UoYSwgYikge1xuICByZXR1cm4gY29tcGFyZShhLCBiLCB0cnVlKTtcbn1cblxuZXhwb3J0cy5yY29tcGFyZSA9IHJjb21wYXJlO1xuZnVuY3Rpb24gcmNvbXBhcmUoYSwgYiwgbG9vc2UpIHtcbiAgcmV0dXJuIGNvbXBhcmUoYiwgYSwgbG9vc2UpO1xufVxuXG5leHBvcnRzLnNvcnQgPSBzb3J0O1xuZnVuY3Rpb24gc29ydChsaXN0LCBsb29zZSkge1xuICByZXR1cm4gbGlzdC5zb3J0KGZ1bmN0aW9uKGEsIGIpIHtcbiAgICByZXR1cm4gZXhwb3J0cy5jb21wYXJlKGEsIGIsIGxvb3NlKTtcbiAgfSk7XG59XG5cbmV4cG9ydHMucnNvcnQgPSByc29ydDtcbmZ1bmN0aW9uIHJzb3J0KGxpc3QsIGxvb3NlKSB7XG4gIHJldHVybiBsaXN0LnNvcnQoZnVuY3Rpb24oYSwgYikge1xuICAgIHJldHVybiBleHBvcnRzLnJjb21wYXJlKGEsIGIsIGxvb3NlKTtcbiAgfSk7XG59XG5cbmV4cG9ydHMuZ3QgPSBndDtcbmZ1bmN0aW9uIGd0KGEsIGIsIGxvb3NlKSB7XG4gIHJldHVybiBjb21wYXJlKGEsIGIsIGxvb3NlKSA+IDA7XG59XG5cbmV4cG9ydHMubHQgPSBsdDtcbmZ1bmN0aW9uIGx0KGEsIGIsIGxvb3NlKSB7XG4gIHJldHVybiBjb21wYXJlKGEsIGIsIGxvb3NlKSA8IDA7XG59XG5cbmV4cG9ydHMuZXEgPSBlcTtcbmZ1bmN0aW9uIGVxKGEsIGIsIGxvb3NlKSB7XG4gIHJldHVybiBjb21wYXJlKGEsIGIsIGxvb3NlKSA9PT0gMDtcbn1cblxuZXhwb3J0cy5uZXEgPSBuZXE7XG5mdW5jdGlvbiBuZXEoYSwgYiwgbG9vc2UpIHtcbiAgcmV0dXJuIGNvbXBhcmUoYSwgYiwgbG9vc2UpICE9PSAwO1xufVxuXG5leHBvcnRzLmd0ZSA9IGd0ZTtcbmZ1bmN0aW9uIGd0ZShhLCBiLCBsb29zZSkge1xuICByZXR1cm4gY29tcGFyZShhLCBiLCBsb29zZSkgPj0gMDtcbn1cblxuZXhwb3J0cy5sdGUgPSBsdGU7XG5mdW5jdGlvbiBsdGUoYSwgYiwgbG9vc2UpIHtcbiAgcmV0dXJuIGNvbXBhcmUoYSwgYiwgbG9vc2UpIDw9IDA7XG59XG5cbmV4cG9ydHMuY21wID0gY21wO1xuZnVuY3Rpb24gY21wKGEsIG9wLCBiLCBsb29zZSkge1xuICB2YXIgcmV0O1xuICBzd2l0Y2ggKG9wKSB7XG4gICAgY2FzZSAnPT09JzpcbiAgICAgIGlmICh0eXBlb2YgYSA9PT0gJ29iamVjdCcpIGEgPSBhLnZlcnNpb247XG4gICAgICBpZiAodHlwZW9mIGIgPT09ICdvYmplY3QnKSBiID0gYi52ZXJzaW9uO1xuICAgICAgcmV0ID0gYSA9PT0gYjtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJyE9PSc6XG4gICAgICBpZiAodHlwZW9mIGEgPT09ICdvYmplY3QnKSBhID0gYS52ZXJzaW9uO1xuICAgICAgaWYgKHR5cGVvZiBiID09PSAnb2JqZWN0JykgYiA9IGIudmVyc2lvbjtcbiAgICAgIHJldCA9IGEgIT09IGI7XG4gICAgICBicmVhaztcbiAgICBjYXNlICcnOiBjYXNlICc9JzogY2FzZSAnPT0nOiByZXQgPSBlcShhLCBiLCBsb29zZSk7IGJyZWFrO1xuICAgIGNhc2UgJyE9JzogcmV0ID0gbmVxKGEsIGIsIGxvb3NlKTsgYnJlYWs7XG4gICAgY2FzZSAnPic6IHJldCA9IGd0KGEsIGIsIGxvb3NlKTsgYnJlYWs7XG4gICAgY2FzZSAnPj0nOiByZXQgPSBndGUoYSwgYiwgbG9vc2UpOyBicmVhaztcbiAgICBjYXNlICc8JzogcmV0ID0gbHQoYSwgYiwgbG9vc2UpOyBicmVhaztcbiAgICBjYXNlICc8PSc6IHJldCA9IGx0ZShhLCBiLCBsb29zZSk7IGJyZWFrO1xuICAgIGRlZmF1bHQ6IHRocm93IG5ldyBUeXBlRXJyb3IoJ0ludmFsaWQgb3BlcmF0b3I6ICcgKyBvcCk7XG4gIH1cbiAgcmV0dXJuIHJldDtcbn1cblxuZXhwb3J0cy5Db21wYXJhdG9yID0gQ29tcGFyYXRvcjtcbmZ1bmN0aW9uIENvbXBhcmF0b3IoY29tcCwgbG9vc2UpIHtcbiAgaWYgKGNvbXAgaW5zdGFuY2VvZiBDb21wYXJhdG9yKSB7XG4gICAgaWYgKGNvbXAubG9vc2UgPT09IGxvb3NlKVxuICAgICAgcmV0dXJuIGNvbXA7XG4gICAgZWxzZVxuICAgICAgY29tcCA9IGNvbXAudmFsdWU7XG4gIH1cblxuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgQ29tcGFyYXRvcikpXG4gICAgcmV0dXJuIG5ldyBDb21wYXJhdG9yKGNvbXAsIGxvb3NlKTtcblxuICBkZWJ1ZygnY29tcGFyYXRvcicsIGNvbXAsIGxvb3NlKTtcbiAgdGhpcy5sb29zZSA9IGxvb3NlO1xuICB0aGlzLnBhcnNlKGNvbXApO1xuXG4gIGlmICh0aGlzLnNlbXZlciA9PT0gQU5ZKVxuICAgIHRoaXMudmFsdWUgPSAnJztcbiAgZWxzZVxuICAgIHRoaXMudmFsdWUgPSB0aGlzLm9wZXJhdG9yICsgdGhpcy5zZW12ZXIudmVyc2lvbjtcblxuICBkZWJ1ZygnY29tcCcsIHRoaXMpO1xufVxuXG52YXIgQU5ZID0ge307XG5Db21wYXJhdG9yLnByb3RvdHlwZS5wYXJzZSA9IGZ1bmN0aW9uKGNvbXApIHtcbiAgdmFyIHIgPSB0aGlzLmxvb3NlID8gcmVbQ09NUEFSQVRPUkxPT1NFXSA6IHJlW0NPTVBBUkFUT1JdO1xuICB2YXIgbSA9IGNvbXAubWF0Y2gocik7XG5cbiAgaWYgKCFtKVxuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0ludmFsaWQgY29tcGFyYXRvcjogJyArIGNvbXApO1xuXG4gIHRoaXMub3BlcmF0b3IgPSBtWzFdO1xuICBpZiAodGhpcy5vcGVyYXRvciA9PT0gJz0nKVxuICAgIHRoaXMub3BlcmF0b3IgPSAnJztcblxuICAvLyBpZiBpdCBsaXRlcmFsbHkgaXMganVzdCAnPicgb3IgJycgdGhlbiBhbGxvdyBhbnl0aGluZy5cbiAgaWYgKCFtWzJdKVxuICAgIHRoaXMuc2VtdmVyID0gQU5ZO1xuICBlbHNlXG4gICAgdGhpcy5zZW12ZXIgPSBuZXcgU2VtVmVyKG1bMl0sIHRoaXMubG9vc2UpO1xufTtcblxuQ29tcGFyYXRvci5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMudmFsdWU7XG59O1xuXG5Db21wYXJhdG9yLnByb3RvdHlwZS50ZXN0ID0gZnVuY3Rpb24odmVyc2lvbikge1xuICBkZWJ1ZygnQ29tcGFyYXRvci50ZXN0JywgdmVyc2lvbiwgdGhpcy5sb29zZSk7XG5cbiAgaWYgKHRoaXMuc2VtdmVyID09PSBBTlkpXG4gICAgcmV0dXJuIHRydWU7XG5cbiAgaWYgKHR5cGVvZiB2ZXJzaW9uID09PSAnc3RyaW5nJylcbiAgICB2ZXJzaW9uID0gbmV3IFNlbVZlcih2ZXJzaW9uLCB0aGlzLmxvb3NlKTtcblxuICByZXR1cm4gY21wKHZlcnNpb24sIHRoaXMub3BlcmF0b3IsIHRoaXMuc2VtdmVyLCB0aGlzLmxvb3NlKTtcbn07XG5cbkNvbXBhcmF0b3IucHJvdG90eXBlLmludGVyc2VjdHMgPSBmdW5jdGlvbihjb21wLCBsb29zZSkge1xuICBpZiAoIShjb21wIGluc3RhbmNlb2YgQ29tcGFyYXRvcikpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdhIENvbXBhcmF0b3IgaXMgcmVxdWlyZWQnKTtcbiAgfVxuXG4gIHZhciByYW5nZVRtcDtcblxuICBpZiAodGhpcy5vcGVyYXRvciA9PT0gJycpIHtcbiAgICByYW5nZVRtcCA9IG5ldyBSYW5nZShjb21wLnZhbHVlLCBsb29zZSk7XG4gICAgcmV0dXJuIHNhdGlzZmllcyh0aGlzLnZhbHVlLCByYW5nZVRtcCwgbG9vc2UpO1xuICB9IGVsc2UgaWYgKGNvbXAub3BlcmF0b3IgPT09ICcnKSB7XG4gICAgcmFuZ2VUbXAgPSBuZXcgUmFuZ2UodGhpcy52YWx1ZSwgbG9vc2UpO1xuICAgIHJldHVybiBzYXRpc2ZpZXMoY29tcC5zZW12ZXIsIHJhbmdlVG1wLCBsb29zZSk7XG4gIH1cblxuICB2YXIgc2FtZURpcmVjdGlvbkluY3JlYXNpbmcgPVxuICAgICh0aGlzLm9wZXJhdG9yID09PSAnPj0nIHx8IHRoaXMub3BlcmF0b3IgPT09ICc+JykgJiZcbiAgICAoY29tcC5vcGVyYXRvciA9PT0gJz49JyB8fCBjb21wLm9wZXJhdG9yID09PSAnPicpO1xuICB2YXIgc2FtZURpcmVjdGlvbkRlY3JlYXNpbmcgPVxuICAgICh0aGlzLm9wZXJhdG9yID09PSAnPD0nIHx8IHRoaXMub3BlcmF0b3IgPT09ICc8JykgJiZcbiAgICAoY29tcC5vcGVyYXRvciA9PT0gJzw9JyB8fCBjb21wLm9wZXJhdG9yID09PSAnPCcpO1xuICB2YXIgc2FtZVNlbVZlciA9IHRoaXMuc2VtdmVyLnZlcnNpb24gPT09IGNvbXAuc2VtdmVyLnZlcnNpb247XG4gIHZhciBkaWZmZXJlbnREaXJlY3Rpb25zSW5jbHVzaXZlID1cbiAgICAodGhpcy5vcGVyYXRvciA9PT0gJz49JyB8fCB0aGlzLm9wZXJhdG9yID09PSAnPD0nKSAmJlxuICAgIChjb21wLm9wZXJhdG9yID09PSAnPj0nIHx8IGNvbXAub3BlcmF0b3IgPT09ICc8PScpO1xuICB2YXIgb3Bwb3NpdGVEaXJlY3Rpb25zTGVzc1RoYW4gPVxuICAgIGNtcCh0aGlzLnNlbXZlciwgJzwnLCBjb21wLnNlbXZlciwgbG9vc2UpICYmXG4gICAgKCh0aGlzLm9wZXJhdG9yID09PSAnPj0nIHx8IHRoaXMub3BlcmF0b3IgPT09ICc+JykgJiZcbiAgICAoY29tcC5vcGVyYXRvciA9PT0gJzw9JyB8fCBjb21wLm9wZXJhdG9yID09PSAnPCcpKTtcbiAgdmFyIG9wcG9zaXRlRGlyZWN0aW9uc0dyZWF0ZXJUaGFuID1cbiAgICBjbXAodGhpcy5zZW12ZXIsICc+JywgY29tcC5zZW12ZXIsIGxvb3NlKSAmJlxuICAgICgodGhpcy5vcGVyYXRvciA9PT0gJzw9JyB8fCB0aGlzLm9wZXJhdG9yID09PSAnPCcpICYmXG4gICAgKGNvbXAub3BlcmF0b3IgPT09ICc+PScgfHwgY29tcC5vcGVyYXRvciA9PT0gJz4nKSk7XG5cbiAgcmV0dXJuIHNhbWVEaXJlY3Rpb25JbmNyZWFzaW5nIHx8IHNhbWVEaXJlY3Rpb25EZWNyZWFzaW5nIHx8XG4gICAgKHNhbWVTZW1WZXIgJiYgZGlmZmVyZW50RGlyZWN0aW9uc0luY2x1c2l2ZSkgfHxcbiAgICBvcHBvc2l0ZURpcmVjdGlvbnNMZXNzVGhhbiB8fCBvcHBvc2l0ZURpcmVjdGlvbnNHcmVhdGVyVGhhbjtcbn07XG5cblxuZXhwb3J0cy5SYW5nZSA9IFJhbmdlO1xuZnVuY3Rpb24gUmFuZ2UocmFuZ2UsIGxvb3NlKSB7XG4gIGlmIChyYW5nZSBpbnN0YW5jZW9mIFJhbmdlKSB7XG4gICAgaWYgKHJhbmdlLmxvb3NlID09PSBsb29zZSkge1xuICAgICAgcmV0dXJuIHJhbmdlO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gbmV3IFJhbmdlKHJhbmdlLnJhdywgbG9vc2UpO1xuICAgIH1cbiAgfVxuXG4gIGlmIChyYW5nZSBpbnN0YW5jZW9mIENvbXBhcmF0b3IpIHtcbiAgICByZXR1cm4gbmV3IFJhbmdlKHJhbmdlLnZhbHVlLCBsb29zZSk7XG4gIH1cblxuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgUmFuZ2UpKVxuICAgIHJldHVybiBuZXcgUmFuZ2UocmFuZ2UsIGxvb3NlKTtcblxuICB0aGlzLmxvb3NlID0gbG9vc2U7XG5cbiAgLy8gRmlyc3QsIHNwbGl0IGJhc2VkIG9uIGJvb2xlYW4gb3IgfHxcbiAgdGhpcy5yYXcgPSByYW5nZTtcbiAgdGhpcy5zZXQgPSByYW5nZS5zcGxpdCgvXFxzKlxcfFxcfFxccyovKS5tYXAoZnVuY3Rpb24ocmFuZ2UpIHtcbiAgICByZXR1cm4gdGhpcy5wYXJzZVJhbmdlKHJhbmdlLnRyaW0oKSk7XG4gIH0sIHRoaXMpLmZpbHRlcihmdW5jdGlvbihjKSB7XG4gICAgLy8gdGhyb3cgb3V0IGFueSB0aGF0IGFyZSBub3QgcmVsZXZhbnQgZm9yIHdoYXRldmVyIHJlYXNvblxuICAgIHJldHVybiBjLmxlbmd0aDtcbiAgfSk7XG5cbiAgaWYgKCF0aGlzLnNldC5sZW5ndGgpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdJbnZhbGlkIFNlbVZlciBSYW5nZTogJyArIHJhbmdlKTtcbiAgfVxuXG4gIHRoaXMuZm9ybWF0KCk7XG59XG5cblJhbmdlLnByb3RvdHlwZS5mb3JtYXQgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5yYW5nZSA9IHRoaXMuc2V0Lm1hcChmdW5jdGlvbihjb21wcykge1xuICAgIHJldHVybiBjb21wcy5qb2luKCcgJykudHJpbSgpO1xuICB9KS5qb2luKCd8fCcpLnRyaW0oKTtcbiAgcmV0dXJuIHRoaXMucmFuZ2U7XG59O1xuXG5SYW5nZS5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMucmFuZ2U7XG59O1xuXG5SYW5nZS5wcm90b3R5cGUucGFyc2VSYW5nZSA9IGZ1bmN0aW9uKHJhbmdlKSB7XG4gIHZhciBsb29zZSA9IHRoaXMubG9vc2U7XG4gIHJhbmdlID0gcmFuZ2UudHJpbSgpO1xuICBkZWJ1ZygncmFuZ2UnLCByYW5nZSwgbG9vc2UpO1xuICAvLyBgMS4yLjMgLSAxLjIuNGAgPT4gYD49MS4yLjMgPD0xLjIuNGBcbiAgdmFyIGhyID0gbG9vc2UgPyByZVtIWVBIRU5SQU5HRUxPT1NFXSA6IHJlW0hZUEhFTlJBTkdFXTtcbiAgcmFuZ2UgPSByYW5nZS5yZXBsYWNlKGhyLCBoeXBoZW5SZXBsYWNlKTtcbiAgZGVidWcoJ2h5cGhlbiByZXBsYWNlJywgcmFuZ2UpO1xuICAvLyBgPiAxLjIuMyA8IDEuMi41YCA9PiBgPjEuMi4zIDwxLjIuNWBcbiAgcmFuZ2UgPSByYW5nZS5yZXBsYWNlKHJlW0NPTVBBUkFUT1JUUklNXSwgY29tcGFyYXRvclRyaW1SZXBsYWNlKTtcbiAgZGVidWcoJ2NvbXBhcmF0b3IgdHJpbScsIHJhbmdlLCByZVtDT01QQVJBVE9SVFJJTV0pO1xuXG4gIC8vIGB+IDEuMi4zYCA9PiBgfjEuMi4zYFxuICByYW5nZSA9IHJhbmdlLnJlcGxhY2UocmVbVElMREVUUklNXSwgdGlsZGVUcmltUmVwbGFjZSk7XG5cbiAgLy8gYF4gMS4yLjNgID0+IGBeMS4yLjNgXG4gIHJhbmdlID0gcmFuZ2UucmVwbGFjZShyZVtDQVJFVFRSSU1dLCBjYXJldFRyaW1SZXBsYWNlKTtcblxuICAvLyBub3JtYWxpemUgc3BhY2VzXG4gIHJhbmdlID0gcmFuZ2Uuc3BsaXQoL1xccysvKS5qb2luKCcgJyk7XG5cbiAgLy8gQXQgdGhpcyBwb2ludCwgdGhlIHJhbmdlIGlzIGNvbXBsZXRlbHkgdHJpbW1lZCBhbmRcbiAgLy8gcmVhZHkgdG8gYmUgc3BsaXQgaW50byBjb21wYXJhdG9ycy5cblxuICB2YXIgY29tcFJlID0gbG9vc2UgPyByZVtDT01QQVJBVE9STE9PU0VdIDogcmVbQ09NUEFSQVRPUl07XG4gIHZhciBzZXQgPSByYW5nZS5zcGxpdCgnICcpLm1hcChmdW5jdGlvbihjb21wKSB7XG4gICAgcmV0dXJuIHBhcnNlQ29tcGFyYXRvcihjb21wLCBsb29zZSk7XG4gIH0pLmpvaW4oJyAnKS5zcGxpdCgvXFxzKy8pO1xuICBpZiAodGhpcy5sb29zZSkge1xuICAgIC8vIGluIGxvb3NlIG1vZGUsIHRocm93IG91dCBhbnkgdGhhdCBhcmUgbm90IHZhbGlkIGNvbXBhcmF0b3JzXG4gICAgc2V0ID0gc2V0LmZpbHRlcihmdW5jdGlvbihjb21wKSB7XG4gICAgICByZXR1cm4gISFjb21wLm1hdGNoKGNvbXBSZSk7XG4gICAgfSk7XG4gIH1cbiAgc2V0ID0gc2V0Lm1hcChmdW5jdGlvbihjb21wKSB7XG4gICAgcmV0dXJuIG5ldyBDb21wYXJhdG9yKGNvbXAsIGxvb3NlKTtcbiAgfSk7XG5cbiAgcmV0dXJuIHNldDtcbn07XG5cblJhbmdlLnByb3RvdHlwZS5pbnRlcnNlY3RzID0gZnVuY3Rpb24ocmFuZ2UsIGxvb3NlKSB7XG4gIGlmICghKHJhbmdlIGluc3RhbmNlb2YgUmFuZ2UpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignYSBSYW5nZSBpcyByZXF1aXJlZCcpO1xuICB9XG5cbiAgcmV0dXJuIHRoaXMuc2V0LnNvbWUoZnVuY3Rpb24odGhpc0NvbXBhcmF0b3JzKSB7XG4gICAgcmV0dXJuIHRoaXNDb21wYXJhdG9ycy5ldmVyeShmdW5jdGlvbih0aGlzQ29tcGFyYXRvcikge1xuICAgICAgcmV0dXJuIHJhbmdlLnNldC5zb21lKGZ1bmN0aW9uKHJhbmdlQ29tcGFyYXRvcnMpIHtcbiAgICAgICAgcmV0dXJuIHJhbmdlQ29tcGFyYXRvcnMuZXZlcnkoZnVuY3Rpb24ocmFuZ2VDb21wYXJhdG9yKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXNDb21wYXJhdG9yLmludGVyc2VjdHMocmFuZ2VDb21wYXJhdG9yLCBsb29zZSk7XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH0pO1xufTtcblxuLy8gTW9zdGx5IGp1c3QgZm9yIHRlc3RpbmcgYW5kIGxlZ2FjeSBBUEkgcmVhc29uc1xuZXhwb3J0cy50b0NvbXBhcmF0b3JzID0gdG9Db21wYXJhdG9ycztcbmZ1bmN0aW9uIHRvQ29tcGFyYXRvcnMocmFuZ2UsIGxvb3NlKSB7XG4gIHJldHVybiBuZXcgUmFuZ2UocmFuZ2UsIGxvb3NlKS5zZXQubWFwKGZ1bmN0aW9uKGNvbXApIHtcbiAgICByZXR1cm4gY29tcC5tYXAoZnVuY3Rpb24oYykge1xuICAgICAgcmV0dXJuIGMudmFsdWU7XG4gICAgfSkuam9pbignICcpLnRyaW0oKS5zcGxpdCgnICcpO1xuICB9KTtcbn1cblxuLy8gY29tcHJpc2VkIG9mIHhyYW5nZXMsIHRpbGRlcywgc3RhcnMsIGFuZCBndGx0J3MgYXQgdGhpcyBwb2ludC5cbi8vIGFscmVhZHkgcmVwbGFjZWQgdGhlIGh5cGhlbiByYW5nZXNcbi8vIHR1cm4gaW50byBhIHNldCBvZiBKVVNUIGNvbXBhcmF0b3JzLlxuZnVuY3Rpb24gcGFyc2VDb21wYXJhdG9yKGNvbXAsIGxvb3NlKSB7XG4gIGRlYnVnKCdjb21wJywgY29tcCk7XG4gIGNvbXAgPSByZXBsYWNlQ2FyZXRzKGNvbXAsIGxvb3NlKTtcbiAgZGVidWcoJ2NhcmV0JywgY29tcCk7XG4gIGNvbXAgPSByZXBsYWNlVGlsZGVzKGNvbXAsIGxvb3NlKTtcbiAgZGVidWcoJ3RpbGRlcycsIGNvbXApO1xuICBjb21wID0gcmVwbGFjZVhSYW5nZXMoY29tcCwgbG9vc2UpO1xuICBkZWJ1ZygneHJhbmdlJywgY29tcCk7XG4gIGNvbXAgPSByZXBsYWNlU3RhcnMoY29tcCwgbG9vc2UpO1xuICBkZWJ1Zygnc3RhcnMnLCBjb21wKTtcbiAgcmV0dXJuIGNvbXA7XG59XG5cbmZ1bmN0aW9uIGlzWChpZCkge1xuICByZXR1cm4gIWlkIHx8IGlkLnRvTG93ZXJDYXNlKCkgPT09ICd4JyB8fCBpZCA9PT0gJyonO1xufVxuXG4vLyB+LCB+PiAtLT4gKiAoYW55LCBraW5kYSBzaWxseSlcbi8vIH4yLCB+Mi54LCB+Mi54LngsIH4+Miwgfj4yLnggfj4yLngueCAtLT4gPj0yLjAuMCA8My4wLjBcbi8vIH4yLjAsIH4yLjAueCwgfj4yLjAsIH4+Mi4wLnggLS0+ID49Mi4wLjAgPDIuMS4wXG4vLyB+MS4yLCB+MS4yLngsIH4+MS4yLCB+PjEuMi54IC0tPiA+PTEuMi4wIDwxLjMuMFxuLy8gfjEuMi4zLCB+PjEuMi4zIC0tPiA+PTEuMi4zIDwxLjMuMFxuLy8gfjEuMi4wLCB+PjEuMi4wIC0tPiA+PTEuMi4wIDwxLjMuMFxuZnVuY3Rpb24gcmVwbGFjZVRpbGRlcyhjb21wLCBsb29zZSkge1xuICByZXR1cm4gY29tcC50cmltKCkuc3BsaXQoL1xccysvKS5tYXAoZnVuY3Rpb24oY29tcCkge1xuICAgIHJldHVybiByZXBsYWNlVGlsZGUoY29tcCwgbG9vc2UpO1xuICB9KS5qb2luKCcgJyk7XG59XG5cbmZ1bmN0aW9uIHJlcGxhY2VUaWxkZShjb21wLCBsb29zZSkge1xuICB2YXIgciA9IGxvb3NlID8gcmVbVElMREVMT09TRV0gOiByZVtUSUxERV07XG4gIHJldHVybiBjb21wLnJlcGxhY2UociwgZnVuY3Rpb24oXywgTSwgbSwgcCwgcHIpIHtcbiAgICBkZWJ1ZygndGlsZGUnLCBjb21wLCBfLCBNLCBtLCBwLCBwcik7XG4gICAgdmFyIHJldDtcblxuICAgIGlmIChpc1goTSkpXG4gICAgICByZXQgPSAnJztcbiAgICBlbHNlIGlmIChpc1gobSkpXG4gICAgICByZXQgPSAnPj0nICsgTSArICcuMC4wIDwnICsgKCtNICsgMSkgKyAnLjAuMCc7XG4gICAgZWxzZSBpZiAoaXNYKHApKVxuICAgICAgLy8gfjEuMiA9PSA+PTEuMi4wIDwxLjMuMFxuICAgICAgcmV0ID0gJz49JyArIE0gKyAnLicgKyBtICsgJy4wIDwnICsgTSArICcuJyArICgrbSArIDEpICsgJy4wJztcbiAgICBlbHNlIGlmIChwcikge1xuICAgICAgZGVidWcoJ3JlcGxhY2VUaWxkZSBwcicsIHByKTtcbiAgICAgIGlmIChwci5jaGFyQXQoMCkgIT09ICctJylcbiAgICAgICAgcHIgPSAnLScgKyBwcjtcbiAgICAgIHJldCA9ICc+PScgKyBNICsgJy4nICsgbSArICcuJyArIHAgKyBwciArXG4gICAgICAgICAgICAnIDwnICsgTSArICcuJyArICgrbSArIDEpICsgJy4wJztcbiAgICB9IGVsc2VcbiAgICAgIC8vIH4xLjIuMyA9PSA+PTEuMi4zIDwxLjMuMFxuICAgICAgcmV0ID0gJz49JyArIE0gKyAnLicgKyBtICsgJy4nICsgcCArXG4gICAgICAgICAgICAnIDwnICsgTSArICcuJyArICgrbSArIDEpICsgJy4wJztcblxuICAgIGRlYnVnKCd0aWxkZSByZXR1cm4nLCByZXQpO1xuICAgIHJldHVybiByZXQ7XG4gIH0pO1xufVxuXG4vLyBeIC0tPiAqIChhbnksIGtpbmRhIHNpbGx5KVxuLy8gXjIsIF4yLngsIF4yLngueCAtLT4gPj0yLjAuMCA8My4wLjBcbi8vIF4yLjAsIF4yLjAueCAtLT4gPj0yLjAuMCA8My4wLjBcbi8vIF4xLjIsIF4xLjIueCAtLT4gPj0xLjIuMCA8Mi4wLjBcbi8vIF4xLjIuMyAtLT4gPj0xLjIuMyA8Mi4wLjBcbi8vIF4xLjIuMCAtLT4gPj0xLjIuMCA8Mi4wLjBcbmZ1bmN0aW9uIHJlcGxhY2VDYXJldHMoY29tcCwgbG9vc2UpIHtcbiAgcmV0dXJuIGNvbXAudHJpbSgpLnNwbGl0KC9cXHMrLykubWFwKGZ1bmN0aW9uKGNvbXApIHtcbiAgICByZXR1cm4gcmVwbGFjZUNhcmV0KGNvbXAsIGxvb3NlKTtcbiAgfSkuam9pbignICcpO1xufVxuXG5mdW5jdGlvbiByZXBsYWNlQ2FyZXQoY29tcCwgbG9vc2UpIHtcbiAgZGVidWcoJ2NhcmV0JywgY29tcCwgbG9vc2UpO1xuICB2YXIgciA9IGxvb3NlID8gcmVbQ0FSRVRMT09TRV0gOiByZVtDQVJFVF07XG4gIHJldHVybiBjb21wLnJlcGxhY2UociwgZnVuY3Rpb24oXywgTSwgbSwgcCwgcHIpIHtcbiAgICBkZWJ1ZygnY2FyZXQnLCBjb21wLCBfLCBNLCBtLCBwLCBwcik7XG4gICAgdmFyIHJldDtcblxuICAgIGlmIChpc1goTSkpXG4gICAgICByZXQgPSAnJztcbiAgICBlbHNlIGlmIChpc1gobSkpXG4gICAgICByZXQgPSAnPj0nICsgTSArICcuMC4wIDwnICsgKCtNICsgMSkgKyAnLjAuMCc7XG4gICAgZWxzZSBpZiAoaXNYKHApKSB7XG4gICAgICBpZiAoTSA9PT0gJzAnKVxuICAgICAgICByZXQgPSAnPj0nICsgTSArICcuJyArIG0gKyAnLjAgPCcgKyBNICsgJy4nICsgKCttICsgMSkgKyAnLjAnO1xuICAgICAgZWxzZVxuICAgICAgICByZXQgPSAnPj0nICsgTSArICcuJyArIG0gKyAnLjAgPCcgKyAoK00gKyAxKSArICcuMC4wJztcbiAgICB9IGVsc2UgaWYgKHByKSB7XG4gICAgICBkZWJ1ZygncmVwbGFjZUNhcmV0IHByJywgcHIpO1xuICAgICAgaWYgKHByLmNoYXJBdCgwKSAhPT0gJy0nKVxuICAgICAgICBwciA9ICctJyArIHByO1xuICAgICAgaWYgKE0gPT09ICcwJykge1xuICAgICAgICBpZiAobSA9PT0gJzAnKVxuICAgICAgICAgIHJldCA9ICc+PScgKyBNICsgJy4nICsgbSArICcuJyArIHAgKyBwciArXG4gICAgICAgICAgICAgICAgJyA8JyArIE0gKyAnLicgKyBtICsgJy4nICsgKCtwICsgMSk7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICByZXQgPSAnPj0nICsgTSArICcuJyArIG0gKyAnLicgKyBwICsgcHIgK1xuICAgICAgICAgICAgICAgICcgPCcgKyBNICsgJy4nICsgKCttICsgMSkgKyAnLjAnO1xuICAgICAgfSBlbHNlXG4gICAgICAgIHJldCA9ICc+PScgKyBNICsgJy4nICsgbSArICcuJyArIHAgKyBwciArXG4gICAgICAgICAgICAgICcgPCcgKyAoK00gKyAxKSArICcuMC4wJztcbiAgICB9IGVsc2Uge1xuICAgICAgZGVidWcoJ25vIHByJyk7XG4gICAgICBpZiAoTSA9PT0gJzAnKSB7XG4gICAgICAgIGlmIChtID09PSAnMCcpXG4gICAgICAgICAgcmV0ID0gJz49JyArIE0gKyAnLicgKyBtICsgJy4nICsgcCArXG4gICAgICAgICAgICAgICAgJyA8JyArIE0gKyAnLicgKyBtICsgJy4nICsgKCtwICsgMSk7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICByZXQgPSAnPj0nICsgTSArICcuJyArIG0gKyAnLicgKyBwICtcbiAgICAgICAgICAgICAgICAnIDwnICsgTSArICcuJyArICgrbSArIDEpICsgJy4wJztcbiAgICAgIH0gZWxzZVxuICAgICAgICByZXQgPSAnPj0nICsgTSArICcuJyArIG0gKyAnLicgKyBwICtcbiAgICAgICAgICAgICAgJyA8JyArICgrTSArIDEpICsgJy4wLjAnO1xuICAgIH1cblxuICAgIGRlYnVnKCdjYXJldCByZXR1cm4nLCByZXQpO1xuICAgIHJldHVybiByZXQ7XG4gIH0pO1xufVxuXG5mdW5jdGlvbiByZXBsYWNlWFJhbmdlcyhjb21wLCBsb29zZSkge1xuICBkZWJ1ZygncmVwbGFjZVhSYW5nZXMnLCBjb21wLCBsb29zZSk7XG4gIHJldHVybiBjb21wLnNwbGl0KC9cXHMrLykubWFwKGZ1bmN0aW9uKGNvbXApIHtcbiAgICByZXR1cm4gcmVwbGFjZVhSYW5nZShjb21wLCBsb29zZSk7XG4gIH0pLmpvaW4oJyAnKTtcbn1cblxuZnVuY3Rpb24gcmVwbGFjZVhSYW5nZShjb21wLCBsb29zZSkge1xuICBjb21wID0gY29tcC50cmltKCk7XG4gIHZhciByID0gbG9vc2UgPyByZVtYUkFOR0VMT09TRV0gOiByZVtYUkFOR0VdO1xuICByZXR1cm4gY29tcC5yZXBsYWNlKHIsIGZ1bmN0aW9uKHJldCwgZ3RsdCwgTSwgbSwgcCwgcHIpIHtcbiAgICBkZWJ1ZygneFJhbmdlJywgY29tcCwgcmV0LCBndGx0LCBNLCBtLCBwLCBwcik7XG4gICAgdmFyIHhNID0gaXNYKE0pO1xuICAgIHZhciB4bSA9IHhNIHx8IGlzWChtKTtcbiAgICB2YXIgeHAgPSB4bSB8fCBpc1gocCk7XG4gICAgdmFyIGFueVggPSB4cDtcblxuICAgIGlmIChndGx0ID09PSAnPScgJiYgYW55WClcbiAgICAgIGd0bHQgPSAnJztcblxuICAgIGlmICh4TSkge1xuICAgICAgaWYgKGd0bHQgPT09ICc+JyB8fCBndGx0ID09PSAnPCcpIHtcbiAgICAgICAgLy8gbm90aGluZyBpcyBhbGxvd2VkXG4gICAgICAgIHJldCA9ICc8MC4wLjAnO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gbm90aGluZyBpcyBmb3JiaWRkZW5cbiAgICAgICAgcmV0ID0gJyonO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoZ3RsdCAmJiBhbnlYKSB7XG4gICAgICAvLyByZXBsYWNlIFggd2l0aCAwXG4gICAgICBpZiAoeG0pXG4gICAgICAgIG0gPSAwO1xuICAgICAgaWYgKHhwKVxuICAgICAgICBwID0gMDtcblxuICAgICAgaWYgKGd0bHQgPT09ICc+Jykge1xuICAgICAgICAvLyA+MSA9PiA+PTIuMC4wXG4gICAgICAgIC8vID4xLjIgPT4gPj0xLjMuMFxuICAgICAgICAvLyA+MS4yLjMgPT4gPj0gMS4yLjRcbiAgICAgICAgZ3RsdCA9ICc+PSc7XG4gICAgICAgIGlmICh4bSkge1xuICAgICAgICAgIE0gPSArTSArIDE7XG4gICAgICAgICAgbSA9IDA7XG4gICAgICAgICAgcCA9IDA7XG4gICAgICAgIH0gZWxzZSBpZiAoeHApIHtcbiAgICAgICAgICBtID0gK20gKyAxO1xuICAgICAgICAgIHAgPSAwO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGd0bHQgPT09ICc8PScpIHtcbiAgICAgICAgLy8gPD0wLjcueCBpcyBhY3R1YWxseSA8MC44LjAsIHNpbmNlIGFueSAwLjcueCBzaG91bGRcbiAgICAgICAgLy8gcGFzcy4gIFNpbWlsYXJseSwgPD03LnggaXMgYWN0dWFsbHkgPDguMC4wLCBldGMuXG4gICAgICAgIGd0bHQgPSAnPCc7XG4gICAgICAgIGlmICh4bSlcbiAgICAgICAgICBNID0gK00gKyAxO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgbSA9ICttICsgMTtcbiAgICAgIH1cblxuICAgICAgcmV0ID0gZ3RsdCArIE0gKyAnLicgKyBtICsgJy4nICsgcDtcbiAgICB9IGVsc2UgaWYgKHhtKSB7XG4gICAgICByZXQgPSAnPj0nICsgTSArICcuMC4wIDwnICsgKCtNICsgMSkgKyAnLjAuMCc7XG4gICAgfSBlbHNlIGlmICh4cCkge1xuICAgICAgcmV0ID0gJz49JyArIE0gKyAnLicgKyBtICsgJy4wIDwnICsgTSArICcuJyArICgrbSArIDEpICsgJy4wJztcbiAgICB9XG5cbiAgICBkZWJ1ZygneFJhbmdlIHJldHVybicsIHJldCk7XG5cbiAgICByZXR1cm4gcmV0O1xuICB9KTtcbn1cblxuLy8gQmVjYXVzZSAqIGlzIEFORC1lZCB3aXRoIGV2ZXJ5dGhpbmcgZWxzZSBpbiB0aGUgY29tcGFyYXRvcixcbi8vIGFuZCAnJyBtZWFucyBcImFueSB2ZXJzaW9uXCIsIGp1c3QgcmVtb3ZlIHRoZSAqcyBlbnRpcmVseS5cbmZ1bmN0aW9uIHJlcGxhY2VTdGFycyhjb21wLCBsb29zZSkge1xuICBkZWJ1ZygncmVwbGFjZVN0YXJzJywgY29tcCwgbG9vc2UpO1xuICAvLyBMb29zZW5lc3MgaXMgaWdub3JlZCBoZXJlLiAgc3RhciBpcyBhbHdheXMgYXMgbG9vc2UgYXMgaXQgZ2V0cyFcbiAgcmV0dXJuIGNvbXAudHJpbSgpLnJlcGxhY2UocmVbU1RBUl0sICcnKTtcbn1cblxuLy8gVGhpcyBmdW5jdGlvbiBpcyBwYXNzZWQgdG8gc3RyaW5nLnJlcGxhY2UocmVbSFlQSEVOUkFOR0VdKVxuLy8gTSwgbSwgcGF0Y2gsIHByZXJlbGVhc2UsIGJ1aWxkXG4vLyAxLjIgLSAzLjQuNSA9PiA+PTEuMi4wIDw9My40LjVcbi8vIDEuMi4zIC0gMy40ID0+ID49MS4yLjAgPDMuNS4wIEFueSAzLjQueCB3aWxsIGRvXG4vLyAxLjIgLSAzLjQgPT4gPj0xLjIuMCA8My41LjBcbmZ1bmN0aW9uIGh5cGhlblJlcGxhY2UoJDAsXG4gICAgICAgICAgICAgICAgICAgICAgIGZyb20sIGZNLCBmbSwgZnAsIGZwciwgZmIsXG4gICAgICAgICAgICAgICAgICAgICAgIHRvLCB0TSwgdG0sIHRwLCB0cHIsIHRiKSB7XG5cbiAgaWYgKGlzWChmTSkpXG4gICAgZnJvbSA9ICcnO1xuICBlbHNlIGlmIChpc1goZm0pKVxuICAgIGZyb20gPSAnPj0nICsgZk0gKyAnLjAuMCc7XG4gIGVsc2UgaWYgKGlzWChmcCkpXG4gICAgZnJvbSA9ICc+PScgKyBmTSArICcuJyArIGZtICsgJy4wJztcbiAgZWxzZVxuICAgIGZyb20gPSAnPj0nICsgZnJvbTtcblxuICBpZiAoaXNYKHRNKSlcbiAgICB0byA9ICcnO1xuICBlbHNlIGlmIChpc1godG0pKVxuICAgIHRvID0gJzwnICsgKCt0TSArIDEpICsgJy4wLjAnO1xuICBlbHNlIGlmIChpc1godHApKVxuICAgIHRvID0gJzwnICsgdE0gKyAnLicgKyAoK3RtICsgMSkgKyAnLjAnO1xuICBlbHNlIGlmICh0cHIpXG4gICAgdG8gPSAnPD0nICsgdE0gKyAnLicgKyB0bSArICcuJyArIHRwICsgJy0nICsgdHByO1xuICBlbHNlXG4gICAgdG8gPSAnPD0nICsgdG87XG5cbiAgcmV0dXJuIChmcm9tICsgJyAnICsgdG8pLnRyaW0oKTtcbn1cblxuXG4vLyBpZiBBTlkgb2YgdGhlIHNldHMgbWF0Y2ggQUxMIG9mIGl0cyBjb21wYXJhdG9ycywgdGhlbiBwYXNzXG5SYW5nZS5wcm90b3R5cGUudGVzdCA9IGZ1bmN0aW9uKHZlcnNpb24pIHtcbiAgaWYgKCF2ZXJzaW9uKVxuICAgIHJldHVybiBmYWxzZTtcblxuICBpZiAodHlwZW9mIHZlcnNpb24gPT09ICdzdHJpbmcnKVxuICAgIHZlcnNpb24gPSBuZXcgU2VtVmVyKHZlcnNpb24sIHRoaXMubG9vc2UpO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5zZXQubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAodGVzdFNldCh0aGlzLnNldFtpXSwgdmVyc2lvbikpXG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59O1xuXG5mdW5jdGlvbiB0ZXN0U2V0KHNldCwgdmVyc2lvbikge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHNldC5sZW5ndGg7IGkrKykge1xuICAgIGlmICghc2V0W2ldLnRlc3QodmVyc2lvbikpXG4gICAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBpZiAodmVyc2lvbi5wcmVyZWxlYXNlLmxlbmd0aCkge1xuICAgIC8vIEZpbmQgdGhlIHNldCBvZiB2ZXJzaW9ucyB0aGF0IGFyZSBhbGxvd2VkIHRvIGhhdmUgcHJlcmVsZWFzZXNcbiAgICAvLyBGb3IgZXhhbXBsZSwgXjEuMi4zLXByLjEgZGVzdWdhcnMgdG8gPj0xLjIuMy1wci4xIDwyLjAuMFxuICAgIC8vIFRoYXQgc2hvdWxkIGFsbG93IGAxLjIuMy1wci4yYCB0byBwYXNzLlxuICAgIC8vIEhvd2V2ZXIsIGAxLjIuNC1hbHBoYS5ub3RyZWFkeWAgc2hvdWxkIE5PVCBiZSBhbGxvd2VkLFxuICAgIC8vIGV2ZW4gdGhvdWdoIGl0J3Mgd2l0aGluIHRoZSByYW5nZSBzZXQgYnkgdGhlIGNvbXBhcmF0b3JzLlxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2V0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICBkZWJ1ZyhzZXRbaV0uc2VtdmVyKTtcbiAgICAgIGlmIChzZXRbaV0uc2VtdmVyID09PSBBTlkpXG4gICAgICAgIGNvbnRpbnVlO1xuXG4gICAgICBpZiAoc2V0W2ldLnNlbXZlci5wcmVyZWxlYXNlLmxlbmd0aCA+IDApIHtcbiAgICAgICAgdmFyIGFsbG93ZWQgPSBzZXRbaV0uc2VtdmVyO1xuICAgICAgICBpZiAoYWxsb3dlZC5tYWpvciA9PT0gdmVyc2lvbi5tYWpvciAmJlxuICAgICAgICAgICAgYWxsb3dlZC5taW5vciA9PT0gdmVyc2lvbi5taW5vciAmJlxuICAgICAgICAgICAgYWxsb3dlZC5wYXRjaCA9PT0gdmVyc2lvbi5wYXRjaClcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBWZXJzaW9uIGhhcyBhIC1wcmUsIGJ1dCBpdCdzIG5vdCBvbmUgb2YgdGhlIG9uZXMgd2UgbGlrZS5cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn1cblxuZXhwb3J0cy5zYXRpc2ZpZXMgPSBzYXRpc2ZpZXM7XG5mdW5jdGlvbiBzYXRpc2ZpZXModmVyc2lvbiwgcmFuZ2UsIGxvb3NlKSB7XG4gIHRyeSB7XG4gICAgcmFuZ2UgPSBuZXcgUmFuZ2UocmFuZ2UsIGxvb3NlKTtcbiAgfSBjYXRjaCAoZXIpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIHJhbmdlLnRlc3QodmVyc2lvbik7XG59XG5cbmV4cG9ydHMubWF4U2F0aXNmeWluZyA9IG1heFNhdGlzZnlpbmc7XG5mdW5jdGlvbiBtYXhTYXRpc2Z5aW5nKHZlcnNpb25zLCByYW5nZSwgbG9vc2UpIHtcbiAgdmFyIG1heCA9IG51bGw7XG4gIHZhciBtYXhTViA9IG51bGw7XG4gIHRyeSB7XG4gICAgdmFyIHJhbmdlT2JqID0gbmV3IFJhbmdlKHJhbmdlLCBsb29zZSk7XG4gIH0gY2F0Y2ggKGVyKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgdmVyc2lvbnMuZm9yRWFjaChmdW5jdGlvbiAodikge1xuICAgIGlmIChyYW5nZU9iai50ZXN0KHYpKSB7IC8vIHNhdGlzZmllcyh2LCByYW5nZSwgbG9vc2UpXG4gICAgICBpZiAoIW1heCB8fCBtYXhTVi5jb21wYXJlKHYpID09PSAtMSkgeyAvLyBjb21wYXJlKG1heCwgdiwgdHJ1ZSlcbiAgICAgICAgbWF4ID0gdjtcbiAgICAgICAgbWF4U1YgPSBuZXcgU2VtVmVyKG1heCwgbG9vc2UpO1xuICAgICAgfVxuICAgIH1cbiAgfSlcbiAgcmV0dXJuIG1heDtcbn1cblxuZXhwb3J0cy5taW5TYXRpc2Z5aW5nID0gbWluU2F0aXNmeWluZztcbmZ1bmN0aW9uIG1pblNhdGlzZnlpbmcodmVyc2lvbnMsIHJhbmdlLCBsb29zZSkge1xuICB2YXIgbWluID0gbnVsbDtcbiAgdmFyIG1pblNWID0gbnVsbDtcbiAgdHJ5IHtcbiAgICB2YXIgcmFuZ2VPYmogPSBuZXcgUmFuZ2UocmFuZ2UsIGxvb3NlKTtcbiAgfSBjYXRjaCAoZXIpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICB2ZXJzaW9ucy5mb3JFYWNoKGZ1bmN0aW9uICh2KSB7XG4gICAgaWYgKHJhbmdlT2JqLnRlc3QodikpIHsgLy8gc2F0aXNmaWVzKHYsIHJhbmdlLCBsb29zZSlcbiAgICAgIGlmICghbWluIHx8IG1pblNWLmNvbXBhcmUodikgPT09IDEpIHsgLy8gY29tcGFyZShtaW4sIHYsIHRydWUpXG4gICAgICAgIG1pbiA9IHY7XG4gICAgICAgIG1pblNWID0gbmV3IFNlbVZlcihtaW4sIGxvb3NlKTtcbiAgICAgIH1cbiAgICB9XG4gIH0pXG4gIHJldHVybiBtaW47XG59XG5cbmV4cG9ydHMudmFsaWRSYW5nZSA9IHZhbGlkUmFuZ2U7XG5mdW5jdGlvbiB2YWxpZFJhbmdlKHJhbmdlLCBsb29zZSkge1xuICB0cnkge1xuICAgIC8vIFJldHVybiAnKicgaW5zdGVhZCBvZiAnJyBzbyB0aGF0IHRydXRoaW5lc3Mgd29ya3MuXG4gICAgLy8gVGhpcyB3aWxsIHRocm93IGlmIGl0J3MgaW52YWxpZCBhbnl3YXlcbiAgICByZXR1cm4gbmV3IFJhbmdlKHJhbmdlLCBsb29zZSkucmFuZ2UgfHwgJyonO1xuICB9IGNhdGNoIChlcikge1xuICAgIHJldHVybiBudWxsO1xuICB9XG59XG5cbi8vIERldGVybWluZSBpZiB2ZXJzaW9uIGlzIGxlc3MgdGhhbiBhbGwgdGhlIHZlcnNpb25zIHBvc3NpYmxlIGluIHRoZSByYW5nZVxuZXhwb3J0cy5sdHIgPSBsdHI7XG5mdW5jdGlvbiBsdHIodmVyc2lvbiwgcmFuZ2UsIGxvb3NlKSB7XG4gIHJldHVybiBvdXRzaWRlKHZlcnNpb24sIHJhbmdlLCAnPCcsIGxvb3NlKTtcbn1cblxuLy8gRGV0ZXJtaW5lIGlmIHZlcnNpb24gaXMgZ3JlYXRlciB0aGFuIGFsbCB0aGUgdmVyc2lvbnMgcG9zc2libGUgaW4gdGhlIHJhbmdlLlxuZXhwb3J0cy5ndHIgPSBndHI7XG5mdW5jdGlvbiBndHIodmVyc2lvbiwgcmFuZ2UsIGxvb3NlKSB7XG4gIHJldHVybiBvdXRzaWRlKHZlcnNpb24sIHJhbmdlLCAnPicsIGxvb3NlKTtcbn1cblxuZXhwb3J0cy5vdXRzaWRlID0gb3V0c2lkZTtcbmZ1bmN0aW9uIG91dHNpZGUodmVyc2lvbiwgcmFuZ2UsIGhpbG8sIGxvb3NlKSB7XG4gIHZlcnNpb24gPSBuZXcgU2VtVmVyKHZlcnNpb24sIGxvb3NlKTtcbiAgcmFuZ2UgPSBuZXcgUmFuZ2UocmFuZ2UsIGxvb3NlKTtcblxuICB2YXIgZ3RmbiwgbHRlZm4sIGx0Zm4sIGNvbXAsIGVjb21wO1xuICBzd2l0Y2ggKGhpbG8pIHtcbiAgICBjYXNlICc+JzpcbiAgICAgIGd0Zm4gPSBndDtcbiAgICAgIGx0ZWZuID0gbHRlO1xuICAgICAgbHRmbiA9IGx0O1xuICAgICAgY29tcCA9ICc+JztcbiAgICAgIGVjb21wID0gJz49JztcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJzwnOlxuICAgICAgZ3RmbiA9IGx0O1xuICAgICAgbHRlZm4gPSBndGU7XG4gICAgICBsdGZuID0gZ3Q7XG4gICAgICBjb21wID0gJzwnO1xuICAgICAgZWNvbXAgPSAnPD0nO1xuICAgICAgYnJlYWs7XG4gICAgZGVmYXVsdDpcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ011c3QgcHJvdmlkZSBhIGhpbG8gdmFsIG9mIFwiPFwiIG9yIFwiPlwiJyk7XG4gIH1cblxuICAvLyBJZiBpdCBzYXRpc2lmZXMgdGhlIHJhbmdlIGl0IGlzIG5vdCBvdXRzaWRlXG4gIGlmIChzYXRpc2ZpZXModmVyc2lvbiwgcmFuZ2UsIGxvb3NlKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIC8vIEZyb20gbm93IG9uLCB2YXJpYWJsZSB0ZXJtcyBhcmUgYXMgaWYgd2UncmUgaW4gXCJndHJcIiBtb2RlLlxuICAvLyBidXQgbm90ZSB0aGF0IGV2ZXJ5dGhpbmcgaXMgZmxpcHBlZCBmb3IgdGhlIFwibHRyXCIgZnVuY3Rpb24uXG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCByYW5nZS5zZXQubGVuZ3RoOyArK2kpIHtcbiAgICB2YXIgY29tcGFyYXRvcnMgPSByYW5nZS5zZXRbaV07XG5cbiAgICB2YXIgaGlnaCA9IG51bGw7XG4gICAgdmFyIGxvdyA9IG51bGw7XG5cbiAgICBjb21wYXJhdG9ycy5mb3JFYWNoKGZ1bmN0aW9uKGNvbXBhcmF0b3IpIHtcbiAgICAgIGlmIChjb21wYXJhdG9yLnNlbXZlciA9PT0gQU5ZKSB7XG4gICAgICAgIGNvbXBhcmF0b3IgPSBuZXcgQ29tcGFyYXRvcignPj0wLjAuMCcpXG4gICAgICB9XG4gICAgICBoaWdoID0gaGlnaCB8fCBjb21wYXJhdG9yO1xuICAgICAgbG93ID0gbG93IHx8IGNvbXBhcmF0b3I7XG4gICAgICBpZiAoZ3Rmbihjb21wYXJhdG9yLnNlbXZlciwgaGlnaC5zZW12ZXIsIGxvb3NlKSkge1xuICAgICAgICBoaWdoID0gY29tcGFyYXRvcjtcbiAgICAgIH0gZWxzZSBpZiAobHRmbihjb21wYXJhdG9yLnNlbXZlciwgbG93LnNlbXZlciwgbG9vc2UpKSB7XG4gICAgICAgIGxvdyA9IGNvbXBhcmF0b3I7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICAvLyBJZiB0aGUgZWRnZSB2ZXJzaW9uIGNvbXBhcmF0b3IgaGFzIGEgb3BlcmF0b3IgdGhlbiBvdXIgdmVyc2lvblxuICAgIC8vIGlzbid0IG91dHNpZGUgaXRcbiAgICBpZiAoaGlnaC5vcGVyYXRvciA9PT0gY29tcCB8fCBoaWdoLm9wZXJhdG9yID09PSBlY29tcCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIC8vIElmIHRoZSBsb3dlc3QgdmVyc2lvbiBjb21wYXJhdG9yIGhhcyBhbiBvcGVyYXRvciBhbmQgb3VyIHZlcnNpb25cbiAgICAvLyBpcyBsZXNzIHRoYW4gaXQgdGhlbiBpdCBpc24ndCBoaWdoZXIgdGhhbiB0aGUgcmFuZ2VcbiAgICBpZiAoKCFsb3cub3BlcmF0b3IgfHwgbG93Lm9wZXJhdG9yID09PSBjb21wKSAmJlxuICAgICAgICBsdGVmbih2ZXJzaW9uLCBsb3cuc2VtdmVyKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0gZWxzZSBpZiAobG93Lm9wZXJhdG9yID09PSBlY29tcCAmJiBsdGZuKHZlcnNpb24sIGxvdy5zZW12ZXIpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG4gIHJldHVybiB0cnVlO1xufVxuXG5leHBvcnRzLnByZXJlbGVhc2UgPSBwcmVyZWxlYXNlO1xuZnVuY3Rpb24gcHJlcmVsZWFzZSh2ZXJzaW9uLCBsb29zZSkge1xuICB2YXIgcGFyc2VkID0gcGFyc2UodmVyc2lvbiwgbG9vc2UpO1xuICByZXR1cm4gKHBhcnNlZCAmJiBwYXJzZWQucHJlcmVsZWFzZS5sZW5ndGgpID8gcGFyc2VkLnByZXJlbGVhc2UgOiBudWxsO1xufVxuXG5leHBvcnRzLmludGVyc2VjdHMgPSBpbnRlcnNlY3RzO1xuZnVuY3Rpb24gaW50ZXJzZWN0cyhyMSwgcjIsIGxvb3NlKSB7XG4gIHIxID0gbmV3IFJhbmdlKHIxLCBsb29zZSlcbiAgcjIgPSBuZXcgUmFuZ2UocjIsIGxvb3NlKVxuICByZXR1cm4gcjEuaW50ZXJzZWN0cyhyMilcbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9zZW12ZXIvc2VtdmVyLmpzIiwiLyogLSotIE1vZGU6IGpzOyBqcy1pbmRlbnQtbGV2ZWw6IDI7IC0qLSAqL1xuLypcbiAqIENvcHlyaWdodCAyMDExIE1vemlsbGEgRm91bmRhdGlvbiBhbmQgY29udHJpYnV0b3JzXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTmV3IEJTRCBsaWNlbnNlLiBTZWUgTElDRU5TRSBvcjpcbiAqIGh0dHA6Ly9vcGVuc291cmNlLm9yZy9saWNlbnNlcy9CU0QtMy1DbGF1c2VcbiAqL1xuXG52YXIgYmFzZTY0VkxRID0gcmVxdWlyZSgnLi9iYXNlNjQtdmxxJyk7XG52YXIgdXRpbCA9IHJlcXVpcmUoJy4vdXRpbCcpO1xudmFyIEFycmF5U2V0ID0gcmVxdWlyZSgnLi9hcnJheS1zZXQnKS5BcnJheVNldDtcbnZhciBNYXBwaW5nTGlzdCA9IHJlcXVpcmUoJy4vbWFwcGluZy1saXN0JykuTWFwcGluZ0xpc3Q7XG5cbi8qKlxuICogQW4gaW5zdGFuY2Ugb2YgdGhlIFNvdXJjZU1hcEdlbmVyYXRvciByZXByZXNlbnRzIGEgc291cmNlIG1hcCB3aGljaCBpc1xuICogYmVpbmcgYnVpbHQgaW5jcmVtZW50YWxseS4gWW91IG1heSBwYXNzIGFuIG9iamVjdCB3aXRoIHRoZSBmb2xsb3dpbmdcbiAqIHByb3BlcnRpZXM6XG4gKlxuICogICAtIGZpbGU6IFRoZSBmaWxlbmFtZSBvZiB0aGUgZ2VuZXJhdGVkIHNvdXJjZS5cbiAqICAgLSBzb3VyY2VSb290OiBBIHJvb3QgZm9yIGFsbCByZWxhdGl2ZSBVUkxzIGluIHRoaXMgc291cmNlIG1hcC5cbiAqL1xuZnVuY3Rpb24gU291cmNlTWFwR2VuZXJhdG9yKGFBcmdzKSB7XG4gIGlmICghYUFyZ3MpIHtcbiAgICBhQXJncyA9IHt9O1xuICB9XG4gIHRoaXMuX2ZpbGUgPSB1dGlsLmdldEFyZyhhQXJncywgJ2ZpbGUnLCBudWxsKTtcbiAgdGhpcy5fc291cmNlUm9vdCA9IHV0aWwuZ2V0QXJnKGFBcmdzLCAnc291cmNlUm9vdCcsIG51bGwpO1xuICB0aGlzLl9za2lwVmFsaWRhdGlvbiA9IHV0aWwuZ2V0QXJnKGFBcmdzLCAnc2tpcFZhbGlkYXRpb24nLCBmYWxzZSk7XG4gIHRoaXMuX3NvdXJjZXMgPSBuZXcgQXJyYXlTZXQoKTtcbiAgdGhpcy5fbmFtZXMgPSBuZXcgQXJyYXlTZXQoKTtcbiAgdGhpcy5fbWFwcGluZ3MgPSBuZXcgTWFwcGluZ0xpc3QoKTtcbiAgdGhpcy5fc291cmNlc0NvbnRlbnRzID0gbnVsbDtcbn1cblxuU291cmNlTWFwR2VuZXJhdG9yLnByb3RvdHlwZS5fdmVyc2lvbiA9IDM7XG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyBTb3VyY2VNYXBHZW5lcmF0b3IgYmFzZWQgb24gYSBTb3VyY2VNYXBDb25zdW1lclxuICpcbiAqIEBwYXJhbSBhU291cmNlTWFwQ29uc3VtZXIgVGhlIFNvdXJjZU1hcC5cbiAqL1xuU291cmNlTWFwR2VuZXJhdG9yLmZyb21Tb3VyY2VNYXAgPVxuICBmdW5jdGlvbiBTb3VyY2VNYXBHZW5lcmF0b3JfZnJvbVNvdXJjZU1hcChhU291cmNlTWFwQ29uc3VtZXIpIHtcbiAgICB2YXIgc291cmNlUm9vdCA9IGFTb3VyY2VNYXBDb25zdW1lci5zb3VyY2VSb290O1xuICAgIHZhciBnZW5lcmF0b3IgPSBuZXcgU291cmNlTWFwR2VuZXJhdG9yKHtcbiAgICAgIGZpbGU6IGFTb3VyY2VNYXBDb25zdW1lci5maWxlLFxuICAgICAgc291cmNlUm9vdDogc291cmNlUm9vdFxuICAgIH0pO1xuICAgIGFTb3VyY2VNYXBDb25zdW1lci5lYWNoTWFwcGluZyhmdW5jdGlvbiAobWFwcGluZykge1xuICAgICAgdmFyIG5ld01hcHBpbmcgPSB7XG4gICAgICAgIGdlbmVyYXRlZDoge1xuICAgICAgICAgIGxpbmU6IG1hcHBpbmcuZ2VuZXJhdGVkTGluZSxcbiAgICAgICAgICBjb2x1bW46IG1hcHBpbmcuZ2VuZXJhdGVkQ29sdW1uXG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIGlmIChtYXBwaW5nLnNvdXJjZSAhPSBudWxsKSB7XG4gICAgICAgIG5ld01hcHBpbmcuc291cmNlID0gbWFwcGluZy5zb3VyY2U7XG4gICAgICAgIGlmIChzb3VyY2VSb290ICE9IG51bGwpIHtcbiAgICAgICAgICBuZXdNYXBwaW5nLnNvdXJjZSA9IHV0aWwucmVsYXRpdmUoc291cmNlUm9vdCwgbmV3TWFwcGluZy5zb3VyY2UpO1xuICAgICAgICB9XG5cbiAgICAgICAgbmV3TWFwcGluZy5vcmlnaW5hbCA9IHtcbiAgICAgICAgICBsaW5lOiBtYXBwaW5nLm9yaWdpbmFsTGluZSxcbiAgICAgICAgICBjb2x1bW46IG1hcHBpbmcub3JpZ2luYWxDb2x1bW5cbiAgICAgICAgfTtcblxuICAgICAgICBpZiAobWFwcGluZy5uYW1lICE9IG51bGwpIHtcbiAgICAgICAgICBuZXdNYXBwaW5nLm5hbWUgPSBtYXBwaW5nLm5hbWU7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgZ2VuZXJhdG9yLmFkZE1hcHBpbmcobmV3TWFwcGluZyk7XG4gICAgfSk7XG4gICAgYVNvdXJjZU1hcENvbnN1bWVyLnNvdXJjZXMuZm9yRWFjaChmdW5jdGlvbiAoc291cmNlRmlsZSkge1xuICAgICAgdmFyIHNvdXJjZVJlbGF0aXZlID0gc291cmNlRmlsZTtcbiAgICAgIGlmIChzb3VyY2VSb290ICE9PSBudWxsKSB7XG4gICAgICAgIHNvdXJjZVJlbGF0aXZlID0gdXRpbC5yZWxhdGl2ZShzb3VyY2VSb290LCBzb3VyY2VGaWxlKTtcbiAgICAgIH1cblxuICAgICAgaWYgKCFnZW5lcmF0b3IuX3NvdXJjZXMuaGFzKHNvdXJjZVJlbGF0aXZlKSkge1xuICAgICAgICBnZW5lcmF0b3IuX3NvdXJjZXMuYWRkKHNvdXJjZVJlbGF0aXZlKTtcbiAgICAgIH1cblxuICAgICAgdmFyIGNvbnRlbnQgPSBhU291cmNlTWFwQ29uc3VtZXIuc291cmNlQ29udGVudEZvcihzb3VyY2VGaWxlKTtcbiAgICAgIGlmIChjb250ZW50ICE9IG51bGwpIHtcbiAgICAgICAgZ2VuZXJhdG9yLnNldFNvdXJjZUNvbnRlbnQoc291cmNlRmlsZSwgY29udGVudCk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIGdlbmVyYXRvcjtcbiAgfTtcblxuLyoqXG4gKiBBZGQgYSBzaW5nbGUgbWFwcGluZyBmcm9tIG9yaWdpbmFsIHNvdXJjZSBsaW5lIGFuZCBjb2x1bW4gdG8gdGhlIGdlbmVyYXRlZFxuICogc291cmNlJ3MgbGluZSBhbmQgY29sdW1uIGZvciB0aGlzIHNvdXJjZSBtYXAgYmVpbmcgY3JlYXRlZC4gVGhlIG1hcHBpbmdcbiAqIG9iamVjdCBzaG91bGQgaGF2ZSB0aGUgZm9sbG93aW5nIHByb3BlcnRpZXM6XG4gKlxuICogICAtIGdlbmVyYXRlZDogQW4gb2JqZWN0IHdpdGggdGhlIGdlbmVyYXRlZCBsaW5lIGFuZCBjb2x1bW4gcG9zaXRpb25zLlxuICogICAtIG9yaWdpbmFsOiBBbiBvYmplY3Qgd2l0aCB0aGUgb3JpZ2luYWwgbGluZSBhbmQgY29sdW1uIHBvc2l0aW9ucy5cbiAqICAgLSBzb3VyY2U6IFRoZSBvcmlnaW5hbCBzb3VyY2UgZmlsZSAocmVsYXRpdmUgdG8gdGhlIHNvdXJjZVJvb3QpLlxuICogICAtIG5hbWU6IEFuIG9wdGlvbmFsIG9yaWdpbmFsIHRva2VuIG5hbWUgZm9yIHRoaXMgbWFwcGluZy5cbiAqL1xuU291cmNlTWFwR2VuZXJhdG9yLnByb3RvdHlwZS5hZGRNYXBwaW5nID1cbiAgZnVuY3Rpb24gU291cmNlTWFwR2VuZXJhdG9yX2FkZE1hcHBpbmcoYUFyZ3MpIHtcbiAgICB2YXIgZ2VuZXJhdGVkID0gdXRpbC5nZXRBcmcoYUFyZ3MsICdnZW5lcmF0ZWQnKTtcbiAgICB2YXIgb3JpZ2luYWwgPSB1dGlsLmdldEFyZyhhQXJncywgJ29yaWdpbmFsJywgbnVsbCk7XG4gICAgdmFyIHNvdXJjZSA9IHV0aWwuZ2V0QXJnKGFBcmdzLCAnc291cmNlJywgbnVsbCk7XG4gICAgdmFyIG5hbWUgPSB1dGlsLmdldEFyZyhhQXJncywgJ25hbWUnLCBudWxsKTtcblxuICAgIGlmICghdGhpcy5fc2tpcFZhbGlkYXRpb24pIHtcbiAgICAgIHRoaXMuX3ZhbGlkYXRlTWFwcGluZyhnZW5lcmF0ZWQsIG9yaWdpbmFsLCBzb3VyY2UsIG5hbWUpO1xuICAgIH1cblxuICAgIGlmIChzb3VyY2UgIT0gbnVsbCkge1xuICAgICAgc291cmNlID0gU3RyaW5nKHNvdXJjZSk7XG4gICAgICBpZiAoIXRoaXMuX3NvdXJjZXMuaGFzKHNvdXJjZSkpIHtcbiAgICAgICAgdGhpcy5fc291cmNlcy5hZGQoc291cmNlKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAobmFtZSAhPSBudWxsKSB7XG4gICAgICBuYW1lID0gU3RyaW5nKG5hbWUpO1xuICAgICAgaWYgKCF0aGlzLl9uYW1lcy5oYXMobmFtZSkpIHtcbiAgICAgICAgdGhpcy5fbmFtZXMuYWRkKG5hbWUpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMuX21hcHBpbmdzLmFkZCh7XG4gICAgICBnZW5lcmF0ZWRMaW5lOiBnZW5lcmF0ZWQubGluZSxcbiAgICAgIGdlbmVyYXRlZENvbHVtbjogZ2VuZXJhdGVkLmNvbHVtbixcbiAgICAgIG9yaWdpbmFsTGluZTogb3JpZ2luYWwgIT0gbnVsbCAmJiBvcmlnaW5hbC5saW5lLFxuICAgICAgb3JpZ2luYWxDb2x1bW46IG9yaWdpbmFsICE9IG51bGwgJiYgb3JpZ2luYWwuY29sdW1uLFxuICAgICAgc291cmNlOiBzb3VyY2UsXG4gICAgICBuYW1lOiBuYW1lXG4gICAgfSk7XG4gIH07XG5cbi8qKlxuICogU2V0IHRoZSBzb3VyY2UgY29udGVudCBmb3IgYSBzb3VyY2UgZmlsZS5cbiAqL1xuU291cmNlTWFwR2VuZXJhdG9yLnByb3RvdHlwZS5zZXRTb3VyY2VDb250ZW50ID1cbiAgZnVuY3Rpb24gU291cmNlTWFwR2VuZXJhdG9yX3NldFNvdXJjZUNvbnRlbnQoYVNvdXJjZUZpbGUsIGFTb3VyY2VDb250ZW50KSB7XG4gICAgdmFyIHNvdXJjZSA9IGFTb3VyY2VGaWxlO1xuICAgIGlmICh0aGlzLl9zb3VyY2VSb290ICE9IG51bGwpIHtcbiAgICAgIHNvdXJjZSA9IHV0aWwucmVsYXRpdmUodGhpcy5fc291cmNlUm9vdCwgc291cmNlKTtcbiAgICB9XG5cbiAgICBpZiAoYVNvdXJjZUNvbnRlbnQgIT0gbnVsbCkge1xuICAgICAgLy8gQWRkIHRoZSBzb3VyY2UgY29udGVudCB0byB0aGUgX3NvdXJjZXNDb250ZW50cyBtYXAuXG4gICAgICAvLyBDcmVhdGUgYSBuZXcgX3NvdXJjZXNDb250ZW50cyBtYXAgaWYgdGhlIHByb3BlcnR5IGlzIG51bGwuXG4gICAgICBpZiAoIXRoaXMuX3NvdXJjZXNDb250ZW50cykge1xuICAgICAgICB0aGlzLl9zb3VyY2VzQ29udGVudHMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgfVxuICAgICAgdGhpcy5fc291cmNlc0NvbnRlbnRzW3V0aWwudG9TZXRTdHJpbmcoc291cmNlKV0gPSBhU291cmNlQ29udGVudDtcbiAgICB9IGVsc2UgaWYgKHRoaXMuX3NvdXJjZXNDb250ZW50cykge1xuICAgICAgLy8gUmVtb3ZlIHRoZSBzb3VyY2UgZmlsZSBmcm9tIHRoZSBfc291cmNlc0NvbnRlbnRzIG1hcC5cbiAgICAgIC8vIElmIHRoZSBfc291cmNlc0NvbnRlbnRzIG1hcCBpcyBlbXB0eSwgc2V0IHRoZSBwcm9wZXJ0eSB0byBudWxsLlxuICAgICAgZGVsZXRlIHRoaXMuX3NvdXJjZXNDb250ZW50c1t1dGlsLnRvU2V0U3RyaW5nKHNvdXJjZSldO1xuICAgICAgaWYgKE9iamVjdC5rZXlzKHRoaXMuX3NvdXJjZXNDb250ZW50cykubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHRoaXMuX3NvdXJjZXNDb250ZW50cyA9IG51bGw7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4vKipcbiAqIEFwcGxpZXMgdGhlIG1hcHBpbmdzIG9mIGEgc3ViLXNvdXJjZS1tYXAgZm9yIGEgc3BlY2lmaWMgc291cmNlIGZpbGUgdG8gdGhlXG4gKiBzb3VyY2UgbWFwIGJlaW5nIGdlbmVyYXRlZC4gRWFjaCBtYXBwaW5nIHRvIHRoZSBzdXBwbGllZCBzb3VyY2UgZmlsZSBpc1xuICogcmV3cml0dGVuIHVzaW5nIHRoZSBzdXBwbGllZCBzb3VyY2UgbWFwLiBOb3RlOiBUaGUgcmVzb2x1dGlvbiBmb3IgdGhlXG4gKiByZXN1bHRpbmcgbWFwcGluZ3MgaXMgdGhlIG1pbmltaXVtIG9mIHRoaXMgbWFwIGFuZCB0aGUgc3VwcGxpZWQgbWFwLlxuICpcbiAqIEBwYXJhbSBhU291cmNlTWFwQ29uc3VtZXIgVGhlIHNvdXJjZSBtYXAgdG8gYmUgYXBwbGllZC5cbiAqIEBwYXJhbSBhU291cmNlRmlsZSBPcHRpb25hbC4gVGhlIGZpbGVuYW1lIG9mIHRoZSBzb3VyY2UgZmlsZS5cbiAqICAgICAgICBJZiBvbWl0dGVkLCBTb3VyY2VNYXBDb25zdW1lcidzIGZpbGUgcHJvcGVydHkgd2lsbCBiZSB1c2VkLlxuICogQHBhcmFtIGFTb3VyY2VNYXBQYXRoIE9wdGlvbmFsLiBUaGUgZGlybmFtZSBvZiB0aGUgcGF0aCB0byB0aGUgc291cmNlIG1hcFxuICogICAgICAgIHRvIGJlIGFwcGxpZWQuIElmIHJlbGF0aXZlLCBpdCBpcyByZWxhdGl2ZSB0byB0aGUgU291cmNlTWFwQ29uc3VtZXIuXG4gKiAgICAgICAgVGhpcyBwYXJhbWV0ZXIgaXMgbmVlZGVkIHdoZW4gdGhlIHR3byBzb3VyY2UgbWFwcyBhcmVuJ3QgaW4gdGhlIHNhbWVcbiAqICAgICAgICBkaXJlY3RvcnksIGFuZCB0aGUgc291cmNlIG1hcCB0byBiZSBhcHBsaWVkIGNvbnRhaW5zIHJlbGF0aXZlIHNvdXJjZVxuICogICAgICAgIHBhdGhzLiBJZiBzbywgdGhvc2UgcmVsYXRpdmUgc291cmNlIHBhdGhzIG5lZWQgdG8gYmUgcmV3cml0dGVuXG4gKiAgICAgICAgcmVsYXRpdmUgdG8gdGhlIFNvdXJjZU1hcEdlbmVyYXRvci5cbiAqL1xuU291cmNlTWFwR2VuZXJhdG9yLnByb3RvdHlwZS5hcHBseVNvdXJjZU1hcCA9XG4gIGZ1bmN0aW9uIFNvdXJjZU1hcEdlbmVyYXRvcl9hcHBseVNvdXJjZU1hcChhU291cmNlTWFwQ29uc3VtZXIsIGFTb3VyY2VGaWxlLCBhU291cmNlTWFwUGF0aCkge1xuICAgIHZhciBzb3VyY2VGaWxlID0gYVNvdXJjZUZpbGU7XG4gICAgLy8gSWYgYVNvdXJjZUZpbGUgaXMgb21pdHRlZCwgd2Ugd2lsbCB1c2UgdGhlIGZpbGUgcHJvcGVydHkgb2YgdGhlIFNvdXJjZU1hcFxuICAgIGlmIChhU291cmNlRmlsZSA9PSBudWxsKSB7XG4gICAgICBpZiAoYVNvdXJjZU1hcENvbnN1bWVyLmZpbGUgPT0gbnVsbCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgJ1NvdXJjZU1hcEdlbmVyYXRvci5wcm90b3R5cGUuYXBwbHlTb3VyY2VNYXAgcmVxdWlyZXMgZWl0aGVyIGFuIGV4cGxpY2l0IHNvdXJjZSBmaWxlLCAnICtcbiAgICAgICAgICAnb3IgdGhlIHNvdXJjZSBtYXBcXCdzIFwiZmlsZVwiIHByb3BlcnR5LiBCb3RoIHdlcmUgb21pdHRlZC4nXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICBzb3VyY2VGaWxlID0gYVNvdXJjZU1hcENvbnN1bWVyLmZpbGU7XG4gICAgfVxuICAgIHZhciBzb3VyY2VSb290ID0gdGhpcy5fc291cmNlUm9vdDtcbiAgICAvLyBNYWtlIFwic291cmNlRmlsZVwiIHJlbGF0aXZlIGlmIGFuIGFic29sdXRlIFVybCBpcyBwYXNzZWQuXG4gICAgaWYgKHNvdXJjZVJvb3QgIT0gbnVsbCkge1xuICAgICAgc291cmNlRmlsZSA9IHV0aWwucmVsYXRpdmUoc291cmNlUm9vdCwgc291cmNlRmlsZSk7XG4gICAgfVxuICAgIC8vIEFwcGx5aW5nIHRoZSBTb3VyY2VNYXAgY2FuIGFkZCBhbmQgcmVtb3ZlIGl0ZW1zIGZyb20gdGhlIHNvdXJjZXMgYW5kXG4gICAgLy8gdGhlIG5hbWVzIGFycmF5LlxuICAgIHZhciBuZXdTb3VyY2VzID0gbmV3IEFycmF5U2V0KCk7XG4gICAgdmFyIG5ld05hbWVzID0gbmV3IEFycmF5U2V0KCk7XG5cbiAgICAvLyBGaW5kIG1hcHBpbmdzIGZvciB0aGUgXCJzb3VyY2VGaWxlXCJcbiAgICB0aGlzLl9tYXBwaW5ncy51bnNvcnRlZEZvckVhY2goZnVuY3Rpb24gKG1hcHBpbmcpIHtcbiAgICAgIGlmIChtYXBwaW5nLnNvdXJjZSA9PT0gc291cmNlRmlsZSAmJiBtYXBwaW5nLm9yaWdpbmFsTGluZSAhPSBudWxsKSB7XG4gICAgICAgIC8vIENoZWNrIGlmIGl0IGNhbiBiZSBtYXBwZWQgYnkgdGhlIHNvdXJjZSBtYXAsIHRoZW4gdXBkYXRlIHRoZSBtYXBwaW5nLlxuICAgICAgICB2YXIgb3JpZ2luYWwgPSBhU291cmNlTWFwQ29uc3VtZXIub3JpZ2luYWxQb3NpdGlvbkZvcih7XG4gICAgICAgICAgbGluZTogbWFwcGluZy5vcmlnaW5hbExpbmUsXG4gICAgICAgICAgY29sdW1uOiBtYXBwaW5nLm9yaWdpbmFsQ29sdW1uXG4gICAgICAgIH0pO1xuICAgICAgICBpZiAob3JpZ2luYWwuc291cmNlICE9IG51bGwpIHtcbiAgICAgICAgICAvLyBDb3B5IG1hcHBpbmdcbiAgICAgICAgICBtYXBwaW5nLnNvdXJjZSA9IG9yaWdpbmFsLnNvdXJjZTtcbiAgICAgICAgICBpZiAoYVNvdXJjZU1hcFBhdGggIT0gbnVsbCkge1xuICAgICAgICAgICAgbWFwcGluZy5zb3VyY2UgPSB1dGlsLmpvaW4oYVNvdXJjZU1hcFBhdGgsIG1hcHBpbmcuc291cmNlKVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoc291cmNlUm9vdCAhPSBudWxsKSB7XG4gICAgICAgICAgICBtYXBwaW5nLnNvdXJjZSA9IHV0aWwucmVsYXRpdmUoc291cmNlUm9vdCwgbWFwcGluZy5zb3VyY2UpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBtYXBwaW5nLm9yaWdpbmFsTGluZSA9IG9yaWdpbmFsLmxpbmU7XG4gICAgICAgICAgbWFwcGluZy5vcmlnaW5hbENvbHVtbiA9IG9yaWdpbmFsLmNvbHVtbjtcbiAgICAgICAgICBpZiAob3JpZ2luYWwubmFtZSAhPSBudWxsKSB7XG4gICAgICAgICAgICBtYXBwaW5nLm5hbWUgPSBvcmlnaW5hbC5uYW1lO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB2YXIgc291cmNlID0gbWFwcGluZy5zb3VyY2U7XG4gICAgICBpZiAoc291cmNlICE9IG51bGwgJiYgIW5ld1NvdXJjZXMuaGFzKHNvdXJjZSkpIHtcbiAgICAgICAgbmV3U291cmNlcy5hZGQoc291cmNlKTtcbiAgICAgIH1cblxuICAgICAgdmFyIG5hbWUgPSBtYXBwaW5nLm5hbWU7XG4gICAgICBpZiAobmFtZSAhPSBudWxsICYmICFuZXdOYW1lcy5oYXMobmFtZSkpIHtcbiAgICAgICAgbmV3TmFtZXMuYWRkKG5hbWUpO1xuICAgICAgfVxuXG4gICAgfSwgdGhpcyk7XG4gICAgdGhpcy5fc291cmNlcyA9IG5ld1NvdXJjZXM7XG4gICAgdGhpcy5fbmFtZXMgPSBuZXdOYW1lcztcblxuICAgIC8vIENvcHkgc291cmNlc0NvbnRlbnRzIG9mIGFwcGxpZWQgbWFwLlxuICAgIGFTb3VyY2VNYXBDb25zdW1lci5zb3VyY2VzLmZvckVhY2goZnVuY3Rpb24gKHNvdXJjZUZpbGUpIHtcbiAgICAgIHZhciBjb250ZW50ID0gYVNvdXJjZU1hcENvbnN1bWVyLnNvdXJjZUNvbnRlbnRGb3Ioc291cmNlRmlsZSk7XG4gICAgICBpZiAoY29udGVudCAhPSBudWxsKSB7XG4gICAgICAgIGlmIChhU291cmNlTWFwUGF0aCAhPSBudWxsKSB7XG4gICAgICAgICAgc291cmNlRmlsZSA9IHV0aWwuam9pbihhU291cmNlTWFwUGF0aCwgc291cmNlRmlsZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNvdXJjZVJvb3QgIT0gbnVsbCkge1xuICAgICAgICAgIHNvdXJjZUZpbGUgPSB1dGlsLnJlbGF0aXZlKHNvdXJjZVJvb3QsIHNvdXJjZUZpbGUpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc2V0U291cmNlQ29udGVudChzb3VyY2VGaWxlLCBjb250ZW50KTtcbiAgICAgIH1cbiAgICB9LCB0aGlzKTtcbiAgfTtcblxuLyoqXG4gKiBBIG1hcHBpbmcgY2FuIGhhdmUgb25lIG9mIHRoZSB0aHJlZSBsZXZlbHMgb2YgZGF0YTpcbiAqXG4gKiAgIDEuIEp1c3QgdGhlIGdlbmVyYXRlZCBwb3NpdGlvbi5cbiAqICAgMi4gVGhlIEdlbmVyYXRlZCBwb3NpdGlvbiwgb3JpZ2luYWwgcG9zaXRpb24sIGFuZCBvcmlnaW5hbCBzb3VyY2UuXG4gKiAgIDMuIEdlbmVyYXRlZCBhbmQgb3JpZ2luYWwgcG9zaXRpb24sIG9yaWdpbmFsIHNvdXJjZSwgYXMgd2VsbCBhcyBhIG5hbWVcbiAqICAgICAgdG9rZW4uXG4gKlxuICogVG8gbWFpbnRhaW4gY29uc2lzdGVuY3ksIHdlIHZhbGlkYXRlIHRoYXQgYW55IG5ldyBtYXBwaW5nIGJlaW5nIGFkZGVkIGZhbGxzXG4gKiBpbiB0byBvbmUgb2YgdGhlc2UgY2F0ZWdvcmllcy5cbiAqL1xuU291cmNlTWFwR2VuZXJhdG9yLnByb3RvdHlwZS5fdmFsaWRhdGVNYXBwaW5nID1cbiAgZnVuY3Rpb24gU291cmNlTWFwR2VuZXJhdG9yX3ZhbGlkYXRlTWFwcGluZyhhR2VuZXJhdGVkLCBhT3JpZ2luYWwsIGFTb3VyY2UsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYU5hbWUpIHtcbiAgICAvLyBXaGVuIGFPcmlnaW5hbCBpcyB0cnV0aHkgYnV0IGhhcyBlbXB0eSB2YWx1ZXMgZm9yIC5saW5lIGFuZCAuY29sdW1uLFxuICAgIC8vIGl0IGlzIG1vc3QgbGlrZWx5IGEgcHJvZ3JhbW1lciBlcnJvci4gSW4gdGhpcyBjYXNlIHdlIHRocm93IGEgdmVyeVxuICAgIC8vIHNwZWNpZmljIGVycm9yIG1lc3NhZ2UgdG8gdHJ5IHRvIGd1aWRlIHRoZW0gdGhlIHJpZ2h0IHdheS5cbiAgICAvLyBGb3IgZXhhbXBsZTogaHR0cHM6Ly9naXRodWIuY29tL1BvbHltZXIvcG9seW1lci1idW5kbGVyL3B1bGwvNTE5XG4gICAgaWYgKGFPcmlnaW5hbCAmJiB0eXBlb2YgYU9yaWdpbmFsLmxpbmUgIT09ICdudW1iZXInICYmIHR5cGVvZiBhT3JpZ2luYWwuY29sdW1uICE9PSAnbnVtYmVyJykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgICAnb3JpZ2luYWwubGluZSBhbmQgb3JpZ2luYWwuY29sdW1uIGFyZSBub3QgbnVtYmVycyAtLSB5b3UgcHJvYmFibHkgbWVhbnQgdG8gb21pdCAnICtcbiAgICAgICAgICAgICd0aGUgb3JpZ2luYWwgbWFwcGluZyBlbnRpcmVseSBhbmQgb25seSBtYXAgdGhlIGdlbmVyYXRlZCBwb3NpdGlvbi4gSWYgc28sIHBhc3MgJyArXG4gICAgICAgICAgICAnbnVsbCBmb3IgdGhlIG9yaWdpbmFsIG1hcHBpbmcgaW5zdGVhZCBvZiBhbiBvYmplY3Qgd2l0aCBlbXB0eSBvciBudWxsIHZhbHVlcy4nXG4gICAgICAgICk7XG4gICAgfVxuXG4gICAgaWYgKGFHZW5lcmF0ZWQgJiYgJ2xpbmUnIGluIGFHZW5lcmF0ZWQgJiYgJ2NvbHVtbicgaW4gYUdlbmVyYXRlZFxuICAgICAgICAmJiBhR2VuZXJhdGVkLmxpbmUgPiAwICYmIGFHZW5lcmF0ZWQuY29sdW1uID49IDBcbiAgICAgICAgJiYgIWFPcmlnaW5hbCAmJiAhYVNvdXJjZSAmJiAhYU5hbWUpIHtcbiAgICAgIC8vIENhc2UgMS5cbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZWxzZSBpZiAoYUdlbmVyYXRlZCAmJiAnbGluZScgaW4gYUdlbmVyYXRlZCAmJiAnY29sdW1uJyBpbiBhR2VuZXJhdGVkXG4gICAgICAgICAgICAgJiYgYU9yaWdpbmFsICYmICdsaW5lJyBpbiBhT3JpZ2luYWwgJiYgJ2NvbHVtbicgaW4gYU9yaWdpbmFsXG4gICAgICAgICAgICAgJiYgYUdlbmVyYXRlZC5saW5lID4gMCAmJiBhR2VuZXJhdGVkLmNvbHVtbiA+PSAwXG4gICAgICAgICAgICAgJiYgYU9yaWdpbmFsLmxpbmUgPiAwICYmIGFPcmlnaW5hbC5jb2x1bW4gPj0gMFxuICAgICAgICAgICAgICYmIGFTb3VyY2UpIHtcbiAgICAgIC8vIENhc2VzIDIgYW5kIDMuXG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIG1hcHBpbmc6ICcgKyBKU09OLnN0cmluZ2lmeSh7XG4gICAgICAgIGdlbmVyYXRlZDogYUdlbmVyYXRlZCxcbiAgICAgICAgc291cmNlOiBhU291cmNlLFxuICAgICAgICBvcmlnaW5hbDogYU9yaWdpbmFsLFxuICAgICAgICBuYW1lOiBhTmFtZVxuICAgICAgfSkpO1xuICAgIH1cbiAgfTtcblxuLyoqXG4gKiBTZXJpYWxpemUgdGhlIGFjY3VtdWxhdGVkIG1hcHBpbmdzIGluIHRvIHRoZSBzdHJlYW0gb2YgYmFzZSA2NCBWTFFzXG4gKiBzcGVjaWZpZWQgYnkgdGhlIHNvdXJjZSBtYXAgZm9ybWF0LlxuICovXG5Tb3VyY2VNYXBHZW5lcmF0b3IucHJvdG90eXBlLl9zZXJpYWxpemVNYXBwaW5ncyA9XG4gIGZ1bmN0aW9uIFNvdXJjZU1hcEdlbmVyYXRvcl9zZXJpYWxpemVNYXBwaW5ncygpIHtcbiAgICB2YXIgcHJldmlvdXNHZW5lcmF0ZWRDb2x1bW4gPSAwO1xuICAgIHZhciBwcmV2aW91c0dlbmVyYXRlZExpbmUgPSAxO1xuICAgIHZhciBwcmV2aW91c09yaWdpbmFsQ29sdW1uID0gMDtcbiAgICB2YXIgcHJldmlvdXNPcmlnaW5hbExpbmUgPSAwO1xuICAgIHZhciBwcmV2aW91c05hbWUgPSAwO1xuICAgIHZhciBwcmV2aW91c1NvdXJjZSA9IDA7XG4gICAgdmFyIHJlc3VsdCA9ICcnO1xuICAgIHZhciBuZXh0O1xuICAgIHZhciBtYXBwaW5nO1xuICAgIHZhciBuYW1lSWR4O1xuICAgIHZhciBzb3VyY2VJZHg7XG5cbiAgICB2YXIgbWFwcGluZ3MgPSB0aGlzLl9tYXBwaW5ncy50b0FycmF5KCk7XG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IG1hcHBpbmdzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICBtYXBwaW5nID0gbWFwcGluZ3NbaV07XG4gICAgICBuZXh0ID0gJydcblxuICAgICAgaWYgKG1hcHBpbmcuZ2VuZXJhdGVkTGluZSAhPT0gcHJldmlvdXNHZW5lcmF0ZWRMaW5lKSB7XG4gICAgICAgIHByZXZpb3VzR2VuZXJhdGVkQ29sdW1uID0gMDtcbiAgICAgICAgd2hpbGUgKG1hcHBpbmcuZ2VuZXJhdGVkTGluZSAhPT0gcHJldmlvdXNHZW5lcmF0ZWRMaW5lKSB7XG4gICAgICAgICAgbmV4dCArPSAnOyc7XG4gICAgICAgICAgcHJldmlvdXNHZW5lcmF0ZWRMaW5lKys7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICBpZiAoaSA+IDApIHtcbiAgICAgICAgICBpZiAoIXV0aWwuY29tcGFyZUJ5R2VuZXJhdGVkUG9zaXRpb25zSW5mbGF0ZWQobWFwcGluZywgbWFwcGluZ3NbaSAtIDFdKSkge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIG5leHQgKz0gJywnO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIG5leHQgKz0gYmFzZTY0VkxRLmVuY29kZShtYXBwaW5nLmdlbmVyYXRlZENvbHVtblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLSBwcmV2aW91c0dlbmVyYXRlZENvbHVtbik7XG4gICAgICBwcmV2aW91c0dlbmVyYXRlZENvbHVtbiA9IG1hcHBpbmcuZ2VuZXJhdGVkQ29sdW1uO1xuXG4gICAgICBpZiAobWFwcGluZy5zb3VyY2UgIT0gbnVsbCkge1xuICAgICAgICBzb3VyY2VJZHggPSB0aGlzLl9zb3VyY2VzLmluZGV4T2YobWFwcGluZy5zb3VyY2UpO1xuICAgICAgICBuZXh0ICs9IGJhc2U2NFZMUS5lbmNvZGUoc291cmNlSWR4IC0gcHJldmlvdXNTb3VyY2UpO1xuICAgICAgICBwcmV2aW91c1NvdXJjZSA9IHNvdXJjZUlkeDtcblxuICAgICAgICAvLyBsaW5lcyBhcmUgc3RvcmVkIDAtYmFzZWQgaW4gU291cmNlTWFwIHNwZWMgdmVyc2lvbiAzXG4gICAgICAgIG5leHQgKz0gYmFzZTY0VkxRLmVuY29kZShtYXBwaW5nLm9yaWdpbmFsTGluZSAtIDFcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLSBwcmV2aW91c09yaWdpbmFsTGluZSk7XG4gICAgICAgIHByZXZpb3VzT3JpZ2luYWxMaW5lID0gbWFwcGluZy5vcmlnaW5hbExpbmUgLSAxO1xuXG4gICAgICAgIG5leHQgKz0gYmFzZTY0VkxRLmVuY29kZShtYXBwaW5nLm9yaWdpbmFsQ29sdW1uXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC0gcHJldmlvdXNPcmlnaW5hbENvbHVtbik7XG4gICAgICAgIHByZXZpb3VzT3JpZ2luYWxDb2x1bW4gPSBtYXBwaW5nLm9yaWdpbmFsQ29sdW1uO1xuXG4gICAgICAgIGlmIChtYXBwaW5nLm5hbWUgIT0gbnVsbCkge1xuICAgICAgICAgIG5hbWVJZHggPSB0aGlzLl9uYW1lcy5pbmRleE9mKG1hcHBpbmcubmFtZSk7XG4gICAgICAgICAgbmV4dCArPSBiYXNlNjRWTFEuZW5jb2RlKG5hbWVJZHggLSBwcmV2aW91c05hbWUpO1xuICAgICAgICAgIHByZXZpb3VzTmFtZSA9IG5hbWVJZHg7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmVzdWx0ICs9IG5leHQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcblxuU291cmNlTWFwR2VuZXJhdG9yLnByb3RvdHlwZS5fZ2VuZXJhdGVTb3VyY2VzQ29udGVudCA9XG4gIGZ1bmN0aW9uIFNvdXJjZU1hcEdlbmVyYXRvcl9nZW5lcmF0ZVNvdXJjZXNDb250ZW50KGFTb3VyY2VzLCBhU291cmNlUm9vdCkge1xuICAgIHJldHVybiBhU291cmNlcy5tYXAoZnVuY3Rpb24gKHNvdXJjZSkge1xuICAgICAgaWYgKCF0aGlzLl9zb3VyY2VzQ29udGVudHMpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgICBpZiAoYVNvdXJjZVJvb3QgIT0gbnVsbCkge1xuICAgICAgICBzb3VyY2UgPSB1dGlsLnJlbGF0aXZlKGFTb3VyY2VSb290LCBzb3VyY2UpO1xuICAgICAgfVxuICAgICAgdmFyIGtleSA9IHV0aWwudG9TZXRTdHJpbmcoc291cmNlKTtcbiAgICAgIHJldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodGhpcy5fc291cmNlc0NvbnRlbnRzLCBrZXkpXG4gICAgICAgID8gdGhpcy5fc291cmNlc0NvbnRlbnRzW2tleV1cbiAgICAgICAgOiBudWxsO1xuICAgIH0sIHRoaXMpO1xuICB9O1xuXG4vKipcbiAqIEV4dGVybmFsaXplIHRoZSBzb3VyY2UgbWFwLlxuICovXG5Tb3VyY2VNYXBHZW5lcmF0b3IucHJvdG90eXBlLnRvSlNPTiA9XG4gIGZ1bmN0aW9uIFNvdXJjZU1hcEdlbmVyYXRvcl90b0pTT04oKSB7XG4gICAgdmFyIG1hcCA9IHtcbiAgICAgIHZlcnNpb246IHRoaXMuX3ZlcnNpb24sXG4gICAgICBzb3VyY2VzOiB0aGlzLl9zb3VyY2VzLnRvQXJyYXkoKSxcbiAgICAgIG5hbWVzOiB0aGlzLl9uYW1lcy50b0FycmF5KCksXG4gICAgICBtYXBwaW5nczogdGhpcy5fc2VyaWFsaXplTWFwcGluZ3MoKVxuICAgIH07XG4gICAgaWYgKHRoaXMuX2ZpbGUgIT0gbnVsbCkge1xuICAgICAgbWFwLmZpbGUgPSB0aGlzLl9maWxlO1xuICAgIH1cbiAgICBpZiAodGhpcy5fc291cmNlUm9vdCAhPSBudWxsKSB7XG4gICAgICBtYXAuc291cmNlUm9vdCA9IHRoaXMuX3NvdXJjZVJvb3Q7XG4gICAgfVxuICAgIGlmICh0aGlzLl9zb3VyY2VzQ29udGVudHMpIHtcbiAgICAgIG1hcC5zb3VyY2VzQ29udGVudCA9IHRoaXMuX2dlbmVyYXRlU291cmNlc0NvbnRlbnQobWFwLnNvdXJjZXMsIG1hcC5zb3VyY2VSb290KTtcbiAgICB9XG5cbiAgICByZXR1cm4gbWFwO1xuICB9O1xuXG4vKipcbiAqIFJlbmRlciB0aGUgc291cmNlIG1hcCBiZWluZyBnZW5lcmF0ZWQgdG8gYSBzdHJpbmcuXG4gKi9cblNvdXJjZU1hcEdlbmVyYXRvci5wcm90b3R5cGUudG9TdHJpbmcgPVxuICBmdW5jdGlvbiBTb3VyY2VNYXBHZW5lcmF0b3JfdG9TdHJpbmcoKSB7XG4gICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHRoaXMudG9KU09OKCkpO1xuICB9O1xuXG5leHBvcnRzLlNvdXJjZU1hcEdlbmVyYXRvciA9IFNvdXJjZU1hcEdlbmVyYXRvcjtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9lbGVjdHJvbi11cGRhdGVyL25vZGVfbW9kdWxlcy9zb3VyY2UtbWFwL2xpYi9zb3VyY2UtbWFwLWdlbmVyYXRvci5qcyIsIi8qIC0qLSBNb2RlOiBqczsganMtaW5kZW50LWxldmVsOiAyOyAtKi0gKi9cbi8qXG4gKiBDb3B5cmlnaHQgMjAxMSBNb3ppbGxhIEZvdW5kYXRpb24gYW5kIGNvbnRyaWJ1dG9yc1xuICogTGljZW5zZWQgdW5kZXIgdGhlIE5ldyBCU0QgbGljZW5zZS4gU2VlIExJQ0VOU0Ugb3I6XG4gKiBodHRwOi8vb3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvQlNELTMtQ2xhdXNlXG4gKlxuICogQmFzZWQgb24gdGhlIEJhc2UgNjQgVkxRIGltcGxlbWVudGF0aW9uIGluIENsb3N1cmUgQ29tcGlsZXI6XG4gKiBodHRwczovL2NvZGUuZ29vZ2xlLmNvbS9wL2Nsb3N1cmUtY29tcGlsZXIvc291cmNlL2Jyb3dzZS90cnVuay9zcmMvY29tL2dvb2dsZS9kZWJ1Z2dpbmcvc291cmNlbWFwL0Jhc2U2NFZMUS5qYXZhXG4gKlxuICogQ29weXJpZ2h0IDIwMTEgVGhlIENsb3N1cmUgQ29tcGlsZXIgQXV0aG9ycy4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIFJlZGlzdHJpYnV0aW9uIGFuZCB1c2UgaW4gc291cmNlIGFuZCBiaW5hcnkgZm9ybXMsIHdpdGggb3Igd2l0aG91dFxuICogbW9kaWZpY2F0aW9uLCBhcmUgcGVybWl0dGVkIHByb3ZpZGVkIHRoYXQgdGhlIGZvbGxvd2luZyBjb25kaXRpb25zIGFyZVxuICogbWV0OlxuICpcbiAqICAqIFJlZGlzdHJpYnV0aW9ucyBvZiBzb3VyY2UgY29kZSBtdXN0IHJldGFpbiB0aGUgYWJvdmUgY29weXJpZ2h0XG4gKiAgICBub3RpY2UsIHRoaXMgbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nIGRpc2NsYWltZXIuXG4gKiAgKiBSZWRpc3RyaWJ1dGlvbnMgaW4gYmluYXJ5IGZvcm0gbXVzdCByZXByb2R1Y2UgdGhlIGFib3ZlXG4gKiAgICBjb3B5cmlnaHQgbm90aWNlLCB0aGlzIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZ1xuICogICAgZGlzY2xhaW1lciBpbiB0aGUgZG9jdW1lbnRhdGlvbiBhbmQvb3Igb3RoZXIgbWF0ZXJpYWxzIHByb3ZpZGVkXG4gKiAgICB3aXRoIHRoZSBkaXN0cmlidXRpb24uXG4gKiAgKiBOZWl0aGVyIHRoZSBuYW1lIG9mIEdvb2dsZSBJbmMuIG5vciB0aGUgbmFtZXMgb2YgaXRzXG4gKiAgICBjb250cmlidXRvcnMgbWF5IGJlIHVzZWQgdG8gZW5kb3JzZSBvciBwcm9tb3RlIHByb2R1Y3RzIGRlcml2ZWRcbiAqICAgIGZyb20gdGhpcyBzb2Z0d2FyZSB3aXRob3V0IHNwZWNpZmljIHByaW9yIHdyaXR0ZW4gcGVybWlzc2lvbi5cbiAqXG4gKiBUSElTIFNPRlRXQVJFIElTIFBST1ZJREVEIEJZIFRIRSBDT1BZUklHSFQgSE9MREVSUyBBTkQgQ09OVFJJQlVUT1JTXG4gKiBcIkFTIElTXCIgQU5EIEFOWSBFWFBSRVNTIE9SIElNUExJRUQgV0FSUkFOVElFUywgSU5DTFVESU5HLCBCVVQgTk9UXG4gKiBMSU1JVEVEIFRPLCBUSEUgSU1QTElFRCBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSBBTkQgRklUTkVTUyBGT1JcbiAqIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFSRSBESVNDTEFJTUVELiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQ09QWVJJR0hUXG4gKiBPV05FUiBPUiBDT05UUklCVVRPUlMgQkUgTElBQkxFIEZPUiBBTlkgRElSRUNULCBJTkRJUkVDVCwgSU5DSURFTlRBTCxcbiAqIFNQRUNJQUwsIEVYRU1QTEFSWSwgT1IgQ09OU0VRVUVOVElBTCBEQU1BR0VTIChJTkNMVURJTkcsIEJVVCBOT1RcbiAqIExJTUlURUQgVE8sIFBST0NVUkVNRU5UIE9GIFNVQlNUSVRVVEUgR09PRFMgT1IgU0VSVklDRVM7IExPU1MgT0YgVVNFLFxuICogREFUQSwgT1IgUFJPRklUUzsgT1IgQlVTSU5FU1MgSU5URVJSVVBUSU9OKSBIT1dFVkVSIENBVVNFRCBBTkQgT04gQU5ZXG4gKiBUSEVPUlkgT0YgTElBQklMSVRZLCBXSEVUSEVSIElOIENPTlRSQUNULCBTVFJJQ1QgTElBQklMSVRZLCBPUiBUT1JUXG4gKiAoSU5DTFVESU5HIE5FR0xJR0VOQ0UgT1IgT1RIRVJXSVNFKSBBUklTSU5HIElOIEFOWSBXQVkgT1VUIE9GIFRIRSBVU0VcbiAqIE9GIFRISVMgU09GVFdBUkUsIEVWRU4gSUYgQURWSVNFRCBPRiBUSEUgUE9TU0lCSUxJVFkgT0YgU1VDSCBEQU1BR0UuXG4gKi9cblxudmFyIGJhc2U2NCA9IHJlcXVpcmUoJy4vYmFzZTY0Jyk7XG5cbi8vIEEgc2luZ2xlIGJhc2UgNjQgZGlnaXQgY2FuIGNvbnRhaW4gNiBiaXRzIG9mIGRhdGEuIEZvciB0aGUgYmFzZSA2NCB2YXJpYWJsZVxuLy8gbGVuZ3RoIHF1YW50aXRpZXMgd2UgdXNlIGluIHRoZSBzb3VyY2UgbWFwIHNwZWMsIHRoZSBmaXJzdCBiaXQgaXMgdGhlIHNpZ24sXG4vLyB0aGUgbmV4dCBmb3VyIGJpdHMgYXJlIHRoZSBhY3R1YWwgdmFsdWUsIGFuZCB0aGUgNnRoIGJpdCBpcyB0aGVcbi8vIGNvbnRpbnVhdGlvbiBiaXQuIFRoZSBjb250aW51YXRpb24gYml0IHRlbGxzIHVzIHdoZXRoZXIgdGhlcmUgYXJlIG1vcmVcbi8vIGRpZ2l0cyBpbiB0aGlzIHZhbHVlIGZvbGxvd2luZyB0aGlzIGRpZ2l0LlxuLy9cbi8vICAgQ29udGludWF0aW9uXG4vLyAgIHwgICAgU2lnblxuLy8gICB8ICAgIHxcbi8vICAgViAgICBWXG4vLyAgIDEwMTAxMVxuXG52YXIgVkxRX0JBU0VfU0hJRlQgPSA1O1xuXG4vLyBiaW5hcnk6IDEwMDAwMFxudmFyIFZMUV9CQVNFID0gMSA8PCBWTFFfQkFTRV9TSElGVDtcblxuLy8gYmluYXJ5OiAwMTExMTFcbnZhciBWTFFfQkFTRV9NQVNLID0gVkxRX0JBU0UgLSAxO1xuXG4vLyBiaW5hcnk6IDEwMDAwMFxudmFyIFZMUV9DT05USU5VQVRJT05fQklUID0gVkxRX0JBU0U7XG5cbi8qKlxuICogQ29udmVydHMgZnJvbSBhIHR3by1jb21wbGVtZW50IHZhbHVlIHRvIGEgdmFsdWUgd2hlcmUgdGhlIHNpZ24gYml0IGlzXG4gKiBwbGFjZWQgaW4gdGhlIGxlYXN0IHNpZ25pZmljYW50IGJpdC4gIEZvciBleGFtcGxlLCBhcyBkZWNpbWFsczpcbiAqICAgMSBiZWNvbWVzIDIgKDEwIGJpbmFyeSksIC0xIGJlY29tZXMgMyAoMTEgYmluYXJ5KVxuICogICAyIGJlY29tZXMgNCAoMTAwIGJpbmFyeSksIC0yIGJlY29tZXMgNSAoMTAxIGJpbmFyeSlcbiAqL1xuZnVuY3Rpb24gdG9WTFFTaWduZWQoYVZhbHVlKSB7XG4gIHJldHVybiBhVmFsdWUgPCAwXG4gICAgPyAoKC1hVmFsdWUpIDw8IDEpICsgMVxuICAgIDogKGFWYWx1ZSA8PCAxKSArIDA7XG59XG5cbi8qKlxuICogQ29udmVydHMgdG8gYSB0d28tY29tcGxlbWVudCB2YWx1ZSBmcm9tIGEgdmFsdWUgd2hlcmUgdGhlIHNpZ24gYml0IGlzXG4gKiBwbGFjZWQgaW4gdGhlIGxlYXN0IHNpZ25pZmljYW50IGJpdC4gIEZvciBleGFtcGxlLCBhcyBkZWNpbWFsczpcbiAqICAgMiAoMTAgYmluYXJ5KSBiZWNvbWVzIDEsIDMgKDExIGJpbmFyeSkgYmVjb21lcyAtMVxuICogICA0ICgxMDAgYmluYXJ5KSBiZWNvbWVzIDIsIDUgKDEwMSBiaW5hcnkpIGJlY29tZXMgLTJcbiAqL1xuZnVuY3Rpb24gZnJvbVZMUVNpZ25lZChhVmFsdWUpIHtcbiAgdmFyIGlzTmVnYXRpdmUgPSAoYVZhbHVlICYgMSkgPT09IDE7XG4gIHZhciBzaGlmdGVkID0gYVZhbHVlID4+IDE7XG4gIHJldHVybiBpc05lZ2F0aXZlXG4gICAgPyAtc2hpZnRlZFxuICAgIDogc2hpZnRlZDtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBiYXNlIDY0IFZMUSBlbmNvZGVkIHZhbHVlLlxuICovXG5leHBvcnRzLmVuY29kZSA9IGZ1bmN0aW9uIGJhc2U2NFZMUV9lbmNvZGUoYVZhbHVlKSB7XG4gIHZhciBlbmNvZGVkID0gXCJcIjtcbiAgdmFyIGRpZ2l0O1xuXG4gIHZhciB2bHEgPSB0b1ZMUVNpZ25lZChhVmFsdWUpO1xuXG4gIGRvIHtcbiAgICBkaWdpdCA9IHZscSAmIFZMUV9CQVNFX01BU0s7XG4gICAgdmxxID4+Pj0gVkxRX0JBU0VfU0hJRlQ7XG4gICAgaWYgKHZscSA+IDApIHtcbiAgICAgIC8vIFRoZXJlIGFyZSBzdGlsbCBtb3JlIGRpZ2l0cyBpbiB0aGlzIHZhbHVlLCBzbyB3ZSBtdXN0IG1ha2Ugc3VyZSB0aGVcbiAgICAgIC8vIGNvbnRpbnVhdGlvbiBiaXQgaXMgbWFya2VkLlxuICAgICAgZGlnaXQgfD0gVkxRX0NPTlRJTlVBVElPTl9CSVQ7XG4gICAgfVxuICAgIGVuY29kZWQgKz0gYmFzZTY0LmVuY29kZShkaWdpdCk7XG4gIH0gd2hpbGUgKHZscSA+IDApO1xuXG4gIHJldHVybiBlbmNvZGVkO1xufTtcblxuLyoqXG4gKiBEZWNvZGVzIHRoZSBuZXh0IGJhc2UgNjQgVkxRIHZhbHVlIGZyb20gdGhlIGdpdmVuIHN0cmluZyBhbmQgcmV0dXJucyB0aGVcbiAqIHZhbHVlIGFuZCB0aGUgcmVzdCBvZiB0aGUgc3RyaW5nIHZpYSB0aGUgb3V0IHBhcmFtZXRlci5cbiAqL1xuZXhwb3J0cy5kZWNvZGUgPSBmdW5jdGlvbiBiYXNlNjRWTFFfZGVjb2RlKGFTdHIsIGFJbmRleCwgYU91dFBhcmFtKSB7XG4gIHZhciBzdHJMZW4gPSBhU3RyLmxlbmd0aDtcbiAgdmFyIHJlc3VsdCA9IDA7XG4gIHZhciBzaGlmdCA9IDA7XG4gIHZhciBjb250aW51YXRpb24sIGRpZ2l0O1xuXG4gIGRvIHtcbiAgICBpZiAoYUluZGV4ID49IHN0ckxlbikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRXhwZWN0ZWQgbW9yZSBkaWdpdHMgaW4gYmFzZSA2NCBWTFEgdmFsdWUuXCIpO1xuICAgIH1cblxuICAgIGRpZ2l0ID0gYmFzZTY0LmRlY29kZShhU3RyLmNoYXJDb2RlQXQoYUluZGV4KyspKTtcbiAgICBpZiAoZGlnaXQgPT09IC0xKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIGJhc2U2NCBkaWdpdDogXCIgKyBhU3RyLmNoYXJBdChhSW5kZXggLSAxKSk7XG4gICAgfVxuXG4gICAgY29udGludWF0aW9uID0gISEoZGlnaXQgJiBWTFFfQ09OVElOVUFUSU9OX0JJVCk7XG4gICAgZGlnaXQgJj0gVkxRX0JBU0VfTUFTSztcbiAgICByZXN1bHQgPSByZXN1bHQgKyAoZGlnaXQgPDwgc2hpZnQpO1xuICAgIHNoaWZ0ICs9IFZMUV9CQVNFX1NISUZUO1xuICB9IHdoaWxlIChjb250aW51YXRpb24pO1xuXG4gIGFPdXRQYXJhbS52YWx1ZSA9IGZyb21WTFFTaWduZWQocmVzdWx0KTtcbiAgYU91dFBhcmFtLnJlc3QgPSBhSW5kZXg7XG59O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2VsZWN0cm9uLXVwZGF0ZXIvbm9kZV9tb2R1bGVzL3NvdXJjZS1tYXAvbGliL2Jhc2U2NC12bHEuanMiLCIvKiAtKi0gTW9kZToganM7IGpzLWluZGVudC1sZXZlbDogMjsgLSotICovXG4vKlxuICogQ29weXJpZ2h0IDIwMTEgTW96aWxsYSBGb3VuZGF0aW9uIGFuZCBjb250cmlidXRvcnNcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBOZXcgQlNEIGxpY2Vuc2UuIFNlZSBMSUNFTlNFIG9yOlxuICogaHR0cDovL29wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL0JTRC0zLUNsYXVzZVxuICovXG5cbnZhciB1dGlsID0gcmVxdWlyZSgnLi91dGlsJyk7XG52YXIgaGFzID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcbnZhciBoYXNOYXRpdmVNYXAgPSB0eXBlb2YgTWFwICE9PSBcInVuZGVmaW5lZFwiO1xuXG4vKipcbiAqIEEgZGF0YSBzdHJ1Y3R1cmUgd2hpY2ggaXMgYSBjb21iaW5hdGlvbiBvZiBhbiBhcnJheSBhbmQgYSBzZXQuIEFkZGluZyBhIG5ld1xuICogbWVtYmVyIGlzIE8oMSksIHRlc3RpbmcgZm9yIG1lbWJlcnNoaXAgaXMgTygxKSwgYW5kIGZpbmRpbmcgdGhlIGluZGV4IG9mIGFuXG4gKiBlbGVtZW50IGlzIE8oMSkuIFJlbW92aW5nIGVsZW1lbnRzIGZyb20gdGhlIHNldCBpcyBub3Qgc3VwcG9ydGVkLiBPbmx5XG4gKiBzdHJpbmdzIGFyZSBzdXBwb3J0ZWQgZm9yIG1lbWJlcnNoaXAuXG4gKi9cbmZ1bmN0aW9uIEFycmF5U2V0KCkge1xuICB0aGlzLl9hcnJheSA9IFtdO1xuICB0aGlzLl9zZXQgPSBoYXNOYXRpdmVNYXAgPyBuZXcgTWFwKCkgOiBPYmplY3QuY3JlYXRlKG51bGwpO1xufVxuXG4vKipcbiAqIFN0YXRpYyBtZXRob2QgZm9yIGNyZWF0aW5nIEFycmF5U2V0IGluc3RhbmNlcyBmcm9tIGFuIGV4aXN0aW5nIGFycmF5LlxuICovXG5BcnJheVNldC5mcm9tQXJyYXkgPSBmdW5jdGlvbiBBcnJheVNldF9mcm9tQXJyYXkoYUFycmF5LCBhQWxsb3dEdXBsaWNhdGVzKSB7XG4gIHZhciBzZXQgPSBuZXcgQXJyYXlTZXQoKTtcbiAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGFBcnJheS5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgIHNldC5hZGQoYUFycmF5W2ldLCBhQWxsb3dEdXBsaWNhdGVzKTtcbiAgfVxuICByZXR1cm4gc2V0O1xufTtcblxuLyoqXG4gKiBSZXR1cm4gaG93IG1hbnkgdW5pcXVlIGl0ZW1zIGFyZSBpbiB0aGlzIEFycmF5U2V0LiBJZiBkdXBsaWNhdGVzIGhhdmUgYmVlblxuICogYWRkZWQsIHRoYW4gdGhvc2UgZG8gbm90IGNvdW50IHRvd2FyZHMgdGhlIHNpemUuXG4gKlxuICogQHJldHVybnMgTnVtYmVyXG4gKi9cbkFycmF5U2V0LnByb3RvdHlwZS5zaXplID0gZnVuY3Rpb24gQXJyYXlTZXRfc2l6ZSgpIHtcbiAgcmV0dXJuIGhhc05hdGl2ZU1hcCA/IHRoaXMuX3NldC5zaXplIDogT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXModGhpcy5fc2V0KS5sZW5ndGg7XG59O1xuXG4vKipcbiAqIEFkZCB0aGUgZ2l2ZW4gc3RyaW5nIHRvIHRoaXMgc2V0LlxuICpcbiAqIEBwYXJhbSBTdHJpbmcgYVN0clxuICovXG5BcnJheVNldC5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24gQXJyYXlTZXRfYWRkKGFTdHIsIGFBbGxvd0R1cGxpY2F0ZXMpIHtcbiAgdmFyIHNTdHIgPSBoYXNOYXRpdmVNYXAgPyBhU3RyIDogdXRpbC50b1NldFN0cmluZyhhU3RyKTtcbiAgdmFyIGlzRHVwbGljYXRlID0gaGFzTmF0aXZlTWFwID8gdGhpcy5oYXMoYVN0cikgOiBoYXMuY2FsbCh0aGlzLl9zZXQsIHNTdHIpO1xuICB2YXIgaWR4ID0gdGhpcy5fYXJyYXkubGVuZ3RoO1xuICBpZiAoIWlzRHVwbGljYXRlIHx8IGFBbGxvd0R1cGxpY2F0ZXMpIHtcbiAgICB0aGlzLl9hcnJheS5wdXNoKGFTdHIpO1xuICB9XG4gIGlmICghaXNEdXBsaWNhdGUpIHtcbiAgICBpZiAoaGFzTmF0aXZlTWFwKSB7XG4gICAgICB0aGlzLl9zZXQuc2V0KGFTdHIsIGlkeCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX3NldFtzU3RyXSA9IGlkeDtcbiAgICB9XG4gIH1cbn07XG5cbi8qKlxuICogSXMgdGhlIGdpdmVuIHN0cmluZyBhIG1lbWJlciBvZiB0aGlzIHNldD9cbiAqXG4gKiBAcGFyYW0gU3RyaW5nIGFTdHJcbiAqL1xuQXJyYXlTZXQucHJvdG90eXBlLmhhcyA9IGZ1bmN0aW9uIEFycmF5U2V0X2hhcyhhU3RyKSB7XG4gIGlmIChoYXNOYXRpdmVNYXApIHtcbiAgICByZXR1cm4gdGhpcy5fc2V0LmhhcyhhU3RyKTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgc1N0ciA9IHV0aWwudG9TZXRTdHJpbmcoYVN0cik7XG4gICAgcmV0dXJuIGhhcy5jYWxsKHRoaXMuX3NldCwgc1N0cik7XG4gIH1cbn07XG5cbi8qKlxuICogV2hhdCBpcyB0aGUgaW5kZXggb2YgdGhlIGdpdmVuIHN0cmluZyBpbiB0aGUgYXJyYXk/XG4gKlxuICogQHBhcmFtIFN0cmluZyBhU3RyXG4gKi9cbkFycmF5U2V0LnByb3RvdHlwZS5pbmRleE9mID0gZnVuY3Rpb24gQXJyYXlTZXRfaW5kZXhPZihhU3RyKSB7XG4gIGlmIChoYXNOYXRpdmVNYXApIHtcbiAgICB2YXIgaWR4ID0gdGhpcy5fc2V0LmdldChhU3RyKTtcbiAgICBpZiAoaWR4ID49IDApIHtcbiAgICAgICAgcmV0dXJuIGlkeDtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdmFyIHNTdHIgPSB1dGlsLnRvU2V0U3RyaW5nKGFTdHIpO1xuICAgIGlmIChoYXMuY2FsbCh0aGlzLl9zZXQsIHNTdHIpKSB7XG4gICAgICByZXR1cm4gdGhpcy5fc2V0W3NTdHJdO1xuICAgIH1cbiAgfVxuXG4gIHRocm93IG5ldyBFcnJvcignXCInICsgYVN0ciArICdcIiBpcyBub3QgaW4gdGhlIHNldC4nKTtcbn07XG5cbi8qKlxuICogV2hhdCBpcyB0aGUgZWxlbWVudCBhdCB0aGUgZ2l2ZW4gaW5kZXg/XG4gKlxuICogQHBhcmFtIE51bWJlciBhSWR4XG4gKi9cbkFycmF5U2V0LnByb3RvdHlwZS5hdCA9IGZ1bmN0aW9uIEFycmF5U2V0X2F0KGFJZHgpIHtcbiAgaWYgKGFJZHggPj0gMCAmJiBhSWR4IDwgdGhpcy5fYXJyYXkubGVuZ3RoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2FycmF5W2FJZHhdO1xuICB9XG4gIHRocm93IG5ldyBFcnJvcignTm8gZWxlbWVudCBpbmRleGVkIGJ5ICcgKyBhSWR4KTtcbn07XG5cbi8qKlxuICogUmV0dXJucyB0aGUgYXJyYXkgcmVwcmVzZW50YXRpb24gb2YgdGhpcyBzZXQgKHdoaWNoIGhhcyB0aGUgcHJvcGVyIGluZGljZXNcbiAqIGluZGljYXRlZCBieSBpbmRleE9mKS4gTm90ZSB0aGF0IHRoaXMgaXMgYSBjb3B5IG9mIHRoZSBpbnRlcm5hbCBhcnJheSB1c2VkXG4gKiBmb3Igc3RvcmluZyB0aGUgbWVtYmVycyBzbyB0aGF0IG5vIG9uZSBjYW4gbWVzcyB3aXRoIGludGVybmFsIHN0YXRlLlxuICovXG5BcnJheVNldC5wcm90b3R5cGUudG9BcnJheSA9IGZ1bmN0aW9uIEFycmF5U2V0X3RvQXJyYXkoKSB7XG4gIHJldHVybiB0aGlzLl9hcnJheS5zbGljZSgpO1xufTtcblxuZXhwb3J0cy5BcnJheVNldCA9IEFycmF5U2V0O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2VsZWN0cm9uLXVwZGF0ZXIvbm9kZV9tb2R1bGVzL3NvdXJjZS1tYXAvbGliL2FycmF5LXNldC5qcyIsIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLkdlbmVyaWNQcm92aWRlciA9IHVuZGVmaW5lZDtcblxudmFyIF9ibHVlYmlyZExzdDtcblxuZnVuY3Rpb24gX2xvYWRfYmx1ZWJpcmRMc3QoKSB7XG4gICAgcmV0dXJuIF9ibHVlYmlyZExzdCA9IHJlcXVpcmUoXCJibHVlYmlyZC1sc3RcIik7XG59XG5cbnZhciBfYnVpbGRlclV0aWxSdW50aW1lO1xuXG5mdW5jdGlvbiBfbG9hZF9idWlsZGVyVXRpbFJ1bnRpbWUoKSB7XG4gICAgcmV0dXJuIF9idWlsZGVyVXRpbFJ1bnRpbWUgPSByZXF1aXJlKFwiYnVpbGRlci11dGlsLXJ1bnRpbWVcIik7XG59XG5cbnZhciBfbWFpbjtcblxuZnVuY3Rpb24gX2xvYWRfbWFpbigpIHtcbiAgICByZXR1cm4gX21haW4gPSByZXF1aXJlKFwiLi9tYWluXCIpO1xufVxuXG52YXIgX1Byb3ZpZGVyO1xuXG5mdW5jdGlvbiBfbG9hZF9Qcm92aWRlcigpIHtcbiAgICByZXR1cm4gX1Byb3ZpZGVyID0gcmVxdWlyZShcIi4vUHJvdmlkZXJcIik7XG59XG5cbmNsYXNzIEdlbmVyaWNQcm92aWRlciBleHRlbmRzIChfbWFpbiB8fCBfbG9hZF9tYWluKCkpLlByb3ZpZGVyIHtcbiAgICBjb25zdHJ1Y3Rvcihjb25maWd1cmF0aW9uLCB1cGRhdGVyLCB1c2VNdWx0aXBsZVJhbmdlUmVxdWVzdCA9IHRydWUpIHtcbiAgICAgICAgc3VwZXIodXBkYXRlci5odHRwRXhlY3V0b3IsIHVzZU11bHRpcGxlUmFuZ2VSZXF1ZXN0KTtcbiAgICAgICAgdGhpcy5jb25maWd1cmF0aW9uID0gY29uZmlndXJhdGlvbjtcbiAgICAgICAgdGhpcy51cGRhdGVyID0gdXBkYXRlcjtcbiAgICAgICAgdGhpcy5iYXNlVXJsID0gKDAsIChfbWFpbiB8fCBfbG9hZF9tYWluKCkpLm5ld0Jhc2VVcmwpKHRoaXMuY29uZmlndXJhdGlvbi51cmwpO1xuICAgIH1cbiAgICBnZXQgY2hhbm5lbCgpIHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gdGhpcy51cGRhdGVyLmNoYW5uZWwgfHwgdGhpcy5jb25maWd1cmF0aW9uLmNoYW5uZWw7XG4gICAgICAgIHJldHVybiByZXN1bHQgPT0gbnVsbCA/ICgwLCAoX21haW4gfHwgX2xvYWRfbWFpbigpKS5nZXREZWZhdWx0Q2hhbm5lbE5hbWUpKCkgOiAoMCwgKF9tYWluIHx8IF9sb2FkX21haW4oKSkuZ2V0Q3VzdG9tQ2hhbm5lbE5hbWUpKHJlc3VsdCk7XG4gICAgfVxuICAgIGdldExhdGVzdFZlcnNpb24oKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICAgICAgcmV0dXJuICgwLCAoX2JsdWViaXJkTHN0IHx8IF9sb2FkX2JsdWViaXJkTHN0KCkpLmNvcm91dGluZSkoZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGxldCByZXN1bHQ7XG4gICAgICAgICAgICBjb25zdCBjaGFubmVsRmlsZSA9ICgwLCAoX21haW4gfHwgX2xvYWRfbWFpbigpKS5nZXRDaGFubmVsRmlsZW5hbWUpKF90aGlzLmNoYW5uZWwpO1xuICAgICAgICAgICAgY29uc3QgY2hhbm5lbFVybCA9ICgwLCAoX21haW4gfHwgX2xvYWRfbWFpbigpKS5uZXdVcmxGcm9tQmFzZSkoY2hhbm5lbEZpbGUsIF90aGlzLmJhc2VVcmwpO1xuICAgICAgICAgICAgZm9yIChsZXQgYXR0ZW1wdE51bWJlciA9IDA7OyBhdHRlbXB0TnVtYmVyKyspIHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSAoMCwgKF9Qcm92aWRlciB8fCBfbG9hZF9Qcm92aWRlcigpKS5wYXJzZVVwZGF0ZUluZm8pKCh5aWVsZCBfdGhpcy5odHRwUmVxdWVzdChjaGFubmVsVXJsKSksIGNoYW5uZWxGaWxlLCBjaGFubmVsVXJsKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZSBpbnN0YW5jZW9mIChfYnVpbGRlclV0aWxSdW50aW1lIHx8IF9sb2FkX2J1aWxkZXJVdGlsUnVudGltZSgpKS5IdHRwRXJyb3IgJiYgZS5zdGF0dXNDb2RlID09PSA0MDQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93ICgwLCAoX2J1aWxkZXJVdGlsUnVudGltZSB8fCBfbG9hZF9idWlsZGVyVXRpbFJ1bnRpbWUoKSkubmV3RXJyb3IpKGBDYW5ub3QgZmluZCBjaGFubmVsIFwiJHtjaGFubmVsRmlsZX1cIiB1cGRhdGUgaW5mbzogJHtlLnN0YWNrIHx8IGUubWVzc2FnZX1gLCBcIkVSUl9VUERBVEVSX0NIQU5ORUxfRklMRV9OT1RfRk9VTkRcIik7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoZS5jb2RlID09PSBcIkVDT05OUkVGVVNFRFwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoYXR0ZW1wdE51bWJlciA8IDMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB5aWVsZCBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KHJlc29sdmUsIDEwMDAgKiBhdHRlbXB0TnVtYmVyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVqZWN0KGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoKDAsIChfbWFpbiB8fCBfbG9hZF9tYWluKCkpLmlzVXNlT2xkTWFjUHJvdmlkZXIpKCkpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQucmVsZWFzZUpzb25VcmwgPSBjaGFubmVsVXJsLmhyZWY7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9KSgpO1xuICAgIH1cbiAgICByZXNvbHZlRmlsZXModXBkYXRlSW5mbykge1xuICAgICAgICByZXR1cm4gKDAsIChfUHJvdmlkZXIgfHwgX2xvYWRfUHJvdmlkZXIoKSkucmVzb2x2ZUZpbGVzKSh1cGRhdGVJbmZvLCB0aGlzLmJhc2VVcmwpO1xuICAgIH1cbn1cbmV4cG9ydHMuR2VuZXJpY1Byb3ZpZGVyID0gR2VuZXJpY1Byb3ZpZGVyOyAvLyMgc291cmNlTWFwcGluZ1VSTD1HZW5lcmljUHJvdmlkZXIuanMubWFwXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2VsZWN0cm9uLXVwZGF0ZXIvb3V0L0dlbmVyaWNQcm92aWRlci5qcyIsIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLkdpdEh1YlByb3ZpZGVyID0gZXhwb3J0cy5CYXNlR2l0SHViUHJvdmlkZXIgPSB1bmRlZmluZWQ7XG5cbnZhciBfYmx1ZWJpcmRMc3Q7XG5cbmZ1bmN0aW9uIF9sb2FkX2JsdWViaXJkTHN0KCkge1xuICAgIHJldHVybiBfYmx1ZWJpcmRMc3QgPSByZXF1aXJlKFwiYmx1ZWJpcmQtbHN0XCIpO1xufVxuXG5leHBvcnRzLmNvbXB1dGVSZWxlYXNlTm90ZXMgPSBjb21wdXRlUmVsZWFzZU5vdGVzO1xuXG52YXIgX2J1aWxkZXJVdGlsUnVudGltZTtcblxuZnVuY3Rpb24gX2xvYWRfYnVpbGRlclV0aWxSdW50aW1lKCkge1xuICAgIHJldHVybiBfYnVpbGRlclV0aWxSdW50aW1lID0gcmVxdWlyZShcImJ1aWxkZXItdXRpbC1ydW50aW1lXCIpO1xufVxuXG52YXIgX3NlbXZlcjtcblxuZnVuY3Rpb24gX2xvYWRfc2VtdmVyKCkge1xuICAgIHJldHVybiBfc2VtdmVyID0gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQocmVxdWlyZShcInNlbXZlclwiKSk7XG59XG5cbnZhciBfbWFpbjtcblxuZnVuY3Rpb24gX2xvYWRfbWFpbigpIHtcbiAgICByZXR1cm4gX21haW4gPSByZXF1aXJlKFwiLi9tYWluXCIpO1xufVxuXG52YXIgX1Byb3ZpZGVyO1xuXG5mdW5jdGlvbiBfbG9hZF9Qcm92aWRlcigpIHtcbiAgICByZXR1cm4gX1Byb3ZpZGVyID0gcmVxdWlyZShcIi4vUHJvdmlkZXJcIik7XG59XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKG9iaikgeyBpZiAob2JqICYmIG9iai5fX2VzTW9kdWxlKSB7IHJldHVybiBvYmo7IH0gZWxzZSB7IHZhciBuZXdPYmogPSB7fTsgaWYgKG9iaiAhPSBudWxsKSB7IGZvciAodmFyIGtleSBpbiBvYmopIHsgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGtleSkpIG5ld09ialtrZXldID0gb2JqW2tleV07IH0gfSBuZXdPYmouZGVmYXVsdCA9IG9iajsgcmV0dXJuIG5ld09iajsgfSB9XG5cbmNsYXNzIEJhc2VHaXRIdWJQcm92aWRlciBleHRlbmRzIChfbWFpbiB8fCBfbG9hZF9tYWluKCkpLlByb3ZpZGVyIHtcbiAgICBjb25zdHJ1Y3RvcihvcHRpb25zLCBkZWZhdWx0SG9zdCwgZXhlY3V0b3IpIHtcbiAgICAgICAgc3VwZXIoZXhlY3V0b3IsIGZhbHNlIC8qIGJlY2F1c2UgR2l0SGliIHVzZXMgUzMgKi8pO1xuICAgICAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuICAgICAgICB0aGlzLmJhc2VVcmwgPSAoMCwgKF9tYWluIHx8IF9sb2FkX21haW4oKSkubmV3QmFzZVVybCkoKDAsIChfYnVpbGRlclV0aWxSdW50aW1lIHx8IF9sb2FkX2J1aWxkZXJVdGlsUnVudGltZSgpKS5naXRodWJVcmwpKG9wdGlvbnMsIGRlZmF1bHRIb3N0KSk7XG4gICAgfVxuICAgIGNvbXB1dGVHaXRodWJCYXNlUGF0aChyZXN1bHQpIHtcbiAgICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2VsZWN0cm9uLXVzZXJsYW5kL2VsZWN0cm9uLWJ1aWxkZXIvaXNzdWVzLzE5MDMjaXNzdWVjb21tZW50LTMyMDg4MTIxMVxuICAgICAgICBjb25zdCBob3N0ID0gdGhpcy5vcHRpb25zLmhvc3Q7XG4gICAgICAgIHJldHVybiBob3N0ICE9IG51bGwgJiYgaG9zdCAhPT0gXCJnaXRodWIuY29tXCIgJiYgaG9zdCAhPT0gXCJhcGkuZ2l0aHViLmNvbVwiID8gYC9hcGkvdjMke3Jlc3VsdH1gIDogcmVzdWx0O1xuICAgIH1cbn1cbmV4cG9ydHMuQmFzZUdpdEh1YlByb3ZpZGVyID0gQmFzZUdpdEh1YlByb3ZpZGVyO1xuY2xhc3MgR2l0SHViUHJvdmlkZXIgZXh0ZW5kcyBCYXNlR2l0SHViUHJvdmlkZXIge1xuICAgIGNvbnN0cnVjdG9yKG9wdGlvbnMsIHVwZGF0ZXIsIGV4ZWN1dG9yKSB7XG4gICAgICAgIHN1cGVyKG9wdGlvbnMsIFwiZ2l0aHViLmNvbVwiLCBleGVjdXRvcik7XG4gICAgICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgICAgIHRoaXMudXBkYXRlciA9IHVwZGF0ZXI7XG4gICAgfVxuICAgIGdldExhdGVzdFZlcnNpb24oKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICAgICAgcmV0dXJuICgwLCAoX2JsdWViaXJkTHN0IHx8IF9sb2FkX2JsdWViaXJkTHN0KCkpLmNvcm91dGluZSkoZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGNvbnN0IGJhc2VQYXRoID0gX3RoaXMuYmFzZVBhdGg7XG4gICAgICAgICAgICBjb25zdCBjYW5jZWxsYXRpb25Ub2tlbiA9IG5ldyAoX2J1aWxkZXJVdGlsUnVudGltZSB8fCBfbG9hZF9idWlsZGVyVXRpbFJ1bnRpbWUoKSkuQ2FuY2VsbGF0aW9uVG9rZW4oKTtcbiAgICAgICAgICAgIGNvbnN0IGZlZWRYbWwgPSB5aWVsZCBfdGhpcy5odHRwUmVxdWVzdCgoMCwgKF9tYWluIHx8IF9sb2FkX21haW4oKSkubmV3VXJsRnJvbUJhc2UpKGAke2Jhc2VQYXRofS5hdG9tYCwgX3RoaXMuYmFzZVVybCksIHtcbiAgICAgICAgICAgICAgICBBY2NlcHQ6IFwiYXBwbGljYXRpb24veG1sLCBhcHBsaWNhdGlvbi9hdG9tK3htbCwgdGV4dC94bWwsICovKlwiXG4gICAgICAgICAgICB9LCBjYW5jZWxsYXRpb25Ub2tlbik7XG4gICAgICAgICAgICBjb25zdCBmZWVkID0gKDAsIChfYnVpbGRlclV0aWxSdW50aW1lIHx8IF9sb2FkX2J1aWxkZXJVdGlsUnVudGltZSgpKS5wYXJzZVhtbCkoZmVlZFhtbCk7XG4gICAgICAgICAgICBjb25zdCBsYXRlc3RSZWxlYXNlID0gZmVlZC5lbGVtZW50KFwiZW50cnlcIiwgZmFsc2UsIGBObyBwdWJsaXNoZWQgdmVyc2lvbnMgb24gR2l0SHViYCk7XG4gICAgICAgICAgICBsZXQgdmVyc2lvbjtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgaWYgKF90aGlzLnVwZGF0ZXIuYWxsb3dQcmVyZWxlYXNlKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIG5vaW5zcGVjdGlvbiBUeXBlU2NyaXB0VmFsaWRhdGVKU1R5cGVzXG4gICAgICAgICAgICAgICAgICAgIHZlcnNpb24gPSBsYXRlc3RSZWxlYXNlLmVsZW1lbnQoXCJsaW5rXCIpLmF0dHJpYnV0ZShcImhyZWZcIikubWF0Y2goL1xcL3RhZ1xcL3Y/KFteXFwvXSspJC8pWzFdO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHZlcnNpb24gPSB5aWVsZCBfdGhpcy5nZXRMYXRlc3RWZXJzaW9uU3RyaW5nKGJhc2VQYXRoLCBjYW5jZWxsYXRpb25Ub2tlbik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIHRocm93ICgwLCAoX2J1aWxkZXJVdGlsUnVudGltZSB8fCBfbG9hZF9idWlsZGVyVXRpbFJ1bnRpbWUoKSkubmV3RXJyb3IpKGBDYW5ub3QgcGFyc2UgcmVsZWFzZXMgZmVlZDogJHtlLnN0YWNrIHx8IGUubWVzc2FnZX0sXFxuWE1MOlxcbiR7ZmVlZFhtbH1gLCBcIkVSUl9VUERBVEVSX0lOVkFMSURfUkVMRUFTRV9GRUVEXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHZlcnNpb24gPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRocm93ICgwLCAoX2J1aWxkZXJVdGlsUnVudGltZSB8fCBfbG9hZF9idWlsZGVyVXRpbFJ1bnRpbWUoKSkubmV3RXJyb3IpKGBObyBwdWJsaXNoZWQgdmVyc2lvbnMgb24gR2l0SHViYCwgXCJFUlJfVVBEQVRFUl9OT19QVUJMSVNIRURfVkVSU0lPTlNcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBjaGFubmVsRmlsZSA9ICgwLCAoX21haW4gfHwgX2xvYWRfbWFpbigpKS5nZXRDaGFubmVsRmlsZW5hbWUpKCgwLCAoX21haW4gfHwgX2xvYWRfbWFpbigpKS5nZXREZWZhdWx0Q2hhbm5lbE5hbWUpKCkpO1xuICAgICAgICAgICAgY29uc3QgY2hhbm5lbEZpbGVVcmwgPSAoMCwgKF9tYWluIHx8IF9sb2FkX21haW4oKSkubmV3VXJsRnJvbUJhc2UpKF90aGlzLmdldEJhc2VEb3dubG9hZFBhdGgodmVyc2lvbiwgY2hhbm5lbEZpbGUpLCBfdGhpcy5iYXNlVXJsKTtcbiAgICAgICAgICAgIGNvbnN0IHJlcXVlc3RPcHRpb25zID0gX3RoaXMuY3JlYXRlUmVxdWVzdE9wdGlvbnMoY2hhbm5lbEZpbGVVcmwpO1xuICAgICAgICAgICAgbGV0IHJhd0RhdGE7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHJhd0RhdGEgPSB5aWVsZCBfdGhpcy5leGVjdXRvci5yZXF1ZXN0KHJlcXVlc3RPcHRpb25zLCBjYW5jZWxsYXRpb25Ub2tlbik7XG4gICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFfdGhpcy51cGRhdGVyLmFsbG93UHJlcmVsZWFzZSAmJiBlIGluc3RhbmNlb2YgKF9idWlsZGVyVXRpbFJ1bnRpbWUgfHwgX2xvYWRfYnVpbGRlclV0aWxSdW50aW1lKCkpLkh0dHBFcnJvciAmJiBlLnN0YXR1c0NvZGUgPT09IDQwNCkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyAoMCwgKF9idWlsZGVyVXRpbFJ1bnRpbWUgfHwgX2xvYWRfYnVpbGRlclV0aWxSdW50aW1lKCkpLm5ld0Vycm9yKShgQ2Fubm90IGZpbmQgJHtjaGFubmVsRmlsZX0gaW4gdGhlIGxhdGVzdCByZWxlYXNlIGFydGlmYWN0cyAoJHtjaGFubmVsRmlsZVVybH0pOiAke2Uuc3RhY2sgfHwgZS5tZXNzYWdlfWAsIFwiRVJSX1VQREFURVJfQ0hBTk5FTF9GSUxFX05PVF9GT1VORFwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9ICgwLCAoX1Byb3ZpZGVyIHx8IF9sb2FkX1Byb3ZpZGVyKCkpLnBhcnNlVXBkYXRlSW5mbykocmF3RGF0YSwgY2hhbm5lbEZpbGUsIGNoYW5uZWxGaWxlVXJsKTtcbiAgICAgICAgICAgIGlmICgoMCwgKF9tYWluIHx8IF9sb2FkX21haW4oKSkuaXNVc2VPbGRNYWNQcm92aWRlcikoKSkge1xuICAgICAgICAgICAgICAgIHJlc3VsdC5yZWxlYXNlSnNvblVybCA9IGAkeygwLCAoX2J1aWxkZXJVdGlsUnVudGltZSB8fCBfbG9hZF9idWlsZGVyVXRpbFJ1bnRpbWUoKSkuZ2l0aHViVXJsKShfdGhpcy5vcHRpb25zKX0vJHtyZXF1ZXN0T3B0aW9ucy5wYXRofWA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocmVzdWx0LnJlbGVhc2VOYW1lID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQucmVsZWFzZU5hbWUgPSBsYXRlc3RSZWxlYXNlLmVsZW1lbnRWYWx1ZU9yRW1wdHkoXCJ0aXRsZVwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChyZXN1bHQucmVsZWFzZU5vdGVzID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQucmVsZWFzZU5vdGVzID0gY29tcHV0ZVJlbGVhc2VOb3RlcyhfdGhpcy51cGRhdGVyLmN1cnJlbnRWZXJzaW9uLCBfdGhpcy51cGRhdGVyLmZ1bGxDaGFuZ2Vsb2csIGZlZWQsIGxhdGVzdFJlbGVhc2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfSkoKTtcbiAgICB9XG4gICAgZ2V0TGF0ZXN0VmVyc2lvblN0cmluZyhiYXNlUGF0aCwgY2FuY2VsbGF0aW9uVG9rZW4pIHtcbiAgICAgICAgdmFyIF90aGlzMiA9IHRoaXM7XG5cbiAgICAgICAgcmV0dXJuICgwLCAoX2JsdWViaXJkTHN0IHx8IF9sb2FkX2JsdWViaXJkTHN0KCkpLmNvcm91dGluZSkoZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGNvbnN0IHVybCA9ICgwLCAoX21haW4gfHwgX2xvYWRfbWFpbigpKS5uZXdVcmxGcm9tQmFzZSkoYCR7YmFzZVBhdGh9L2xhdGVzdGAsIF90aGlzMi5iYXNlVXJsKTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgLy8gZG8gbm90IHVzZSBBUEkgdG8gYXZvaWQgbGltaXRcbiAgICAgICAgICAgICAgICBjb25zdCByYXdEYXRhID0geWllbGQgX3RoaXMyLmh0dHBSZXF1ZXN0KHVybCwgeyBBY2NlcHQ6IFwiYXBwbGljYXRpb24vanNvblwiIH0sIGNhbmNlbGxhdGlvblRva2VuKTtcbiAgICAgICAgICAgICAgICBpZiAocmF3RGF0YSA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCByZWxlYXNlSW5mbyA9IEpTT04ucGFyc2UocmF3RGF0YSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlbGVhc2VJbmZvLnRhZ19uYW1lLnN0YXJ0c1dpdGgoXCJ2XCIpID8gcmVsZWFzZUluZm8udGFnX25hbWUuc3Vic3RyaW5nKDEpIDogcmVsZWFzZUluZm8udGFnX25hbWU7XG4gICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgKDAsIChfYnVpbGRlclV0aWxSdW50aW1lIHx8IF9sb2FkX2J1aWxkZXJVdGlsUnVudGltZSgpKS5uZXdFcnJvcikoYFVuYWJsZSB0byBmaW5kIGxhdGVzdCB2ZXJzaW9uIG9uIEdpdEh1YiAoJHt1cmx9KSwgcGxlYXNlIGVuc3VyZSBhIHByb2R1Y3Rpb24gcmVsZWFzZSBleGlzdHM6ICR7ZS5zdGFjayB8fCBlLm1lc3NhZ2V9YCwgXCJFUlJfVVBEQVRFUl9MQVRFU1RfVkVSU0lPTl9OT1RfRk9VTkRcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pKCk7XG4gICAgfVxuICAgIGdldCBiYXNlUGF0aCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29tcHV0ZUdpdGh1YkJhc2VQYXRoKGAvJHt0aGlzLm9wdGlvbnMub3duZXJ9LyR7dGhpcy5vcHRpb25zLnJlcG99L3JlbGVhc2VzYCk7XG4gICAgfVxuICAgIHJlc29sdmVGaWxlcyh1cGRhdGVJbmZvKSB7XG4gICAgICAgIC8vIHN0aWxsIHJlcGxhY2Ugc3BhY2UgdG8gLSBkdWUgdG8gYmFja3dhcmQgY29tcGF0aWJpbGl0eVxuICAgICAgICByZXR1cm4gKDAsIChfUHJvdmlkZXIgfHwgX2xvYWRfUHJvdmlkZXIoKSkucmVzb2x2ZUZpbGVzKSh1cGRhdGVJbmZvLCB0aGlzLmJhc2VVcmwsIHAgPT4gdGhpcy5nZXRCYXNlRG93bmxvYWRQYXRoKHVwZGF0ZUluZm8udmVyc2lvbiwgcC5yZXBsYWNlKC8gL2csIFwiLVwiKSkpO1xuICAgIH1cbiAgICBnZXRCYXNlRG93bmxvYWRQYXRoKHZlcnNpb24sIGZpbGVOYW1lKSB7XG4gICAgICAgIHJldHVybiBgJHt0aGlzLmJhc2VQYXRofS9kb3dubG9hZC8ke3RoaXMub3B0aW9ucy52UHJlZml4ZWRUYWdOYW1lID09PSBmYWxzZSA/IFwiXCIgOiBcInZcIn0ke3ZlcnNpb259LyR7ZmlsZU5hbWV9YDtcbiAgICB9XG59XG5leHBvcnRzLkdpdEh1YlByb3ZpZGVyID0gR2l0SHViUHJvdmlkZXI7XG5mdW5jdGlvbiBnZXROb3RlVmFsdWUocGFyZW50KSB7XG4gICAgY29uc3QgcmVzdWx0ID0gcGFyZW50LmVsZW1lbnRWYWx1ZU9yRW1wdHkoXCJjb250ZW50XCIpO1xuICAgIC8vIEdpdEh1YiByZXBvcnRzIGVtcHR5IG5vdGVzIGFzIDxjb250ZW50Pk5vIGNvbnRlbnQuPC9jb250ZW50PlxuICAgIHJldHVybiByZXN1bHQgPT09IFwiTm8gY29udGVudC5cIiA/IFwiXCIgOiByZXN1bHQ7XG59XG5mdW5jdGlvbiBjb21wdXRlUmVsZWFzZU5vdGVzKGN1cnJlbnRWZXJzaW9uLCBpc0Z1bGxDaGFuZ2Vsb2csIGZlZWQsIGxhdGVzdFJlbGVhc2UpIHtcbiAgICBpZiAoIWlzRnVsbENoYW5nZWxvZykge1xuICAgICAgICByZXR1cm4gZ2V0Tm90ZVZhbHVlKGxhdGVzdFJlbGVhc2UpO1xuICAgIH1cbiAgICBjb25zdCByZWxlYXNlTm90ZXMgPSBbXTtcbiAgICBmb3IgKGNvbnN0IHJlbGVhc2Ugb2YgZmVlZC5nZXRFbGVtZW50cyhcImVudHJ5XCIpKSB7XG4gICAgICAgIC8vIG5vaW5zcGVjdGlvbiBUeXBlU2NyaXB0VmFsaWRhdGVKU1R5cGVzXG4gICAgICAgIGNvbnN0IHZlcnNpb25SZWxlYXNlID0gcmVsZWFzZS5lbGVtZW50KFwibGlua1wiKS5hdHRyaWJ1dGUoXCJocmVmXCIpLm1hdGNoKC9cXC90YWdcXC92PyhbXlxcL10rKSQvKVsxXTtcbiAgICAgICAgaWYgKChfc2VtdmVyIHx8IF9sb2FkX3NlbXZlcigpKS5sdChjdXJyZW50VmVyc2lvbiwgdmVyc2lvblJlbGVhc2UpKSB7XG4gICAgICAgICAgICByZWxlYXNlTm90ZXMucHVzaCh7XG4gICAgICAgICAgICAgICAgdmVyc2lvbjogdmVyc2lvblJlbGVhc2UsXG4gICAgICAgICAgICAgICAgbm90ZTogZ2V0Tm90ZVZhbHVlKHJlbGVhc2UpXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVsZWFzZU5vdGVzLnNvcnQoKGEsIGIpID0+IChfc2VtdmVyIHx8IF9sb2FkX3NlbXZlcigpKS5yY29tcGFyZShhLnZlcnNpb24sIGIudmVyc2lvbikpO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9R2l0SHViUHJvdmlkZXIuanMubWFwXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2VsZWN0cm9uLXVwZGF0ZXIvb3V0L0dpdEh1YlByb3ZpZGVyLmpzIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuQmFzZVVwZGF0ZXIgPSB1bmRlZmluZWQ7XG5cbnZhciBfYmx1ZWJpcmRMc3Q7XG5cbmZ1bmN0aW9uIF9sb2FkX2JsdWViaXJkTHN0KCkge1xuICAgIHJldHVybiBfYmx1ZWJpcmRMc3QgPSByZXF1aXJlKFwiYmx1ZWJpcmQtbHN0XCIpO1xufVxuXG52YXIgX2J1aWxkZXJVdGlsUnVudGltZTtcblxuZnVuY3Rpb24gX2xvYWRfYnVpbGRlclV0aWxSdW50aW1lKCkge1xuICAgIHJldHVybiBfYnVpbGRlclV0aWxSdW50aW1lID0gcmVxdWlyZShcImJ1aWxkZXItdXRpbC1ydW50aW1lXCIpO1xufVxuXG52YXIgX2ZzRXh0cmFQO1xuXG5mdW5jdGlvbiBfbG9hZF9mc0V4dHJhUCgpIHtcbiAgICByZXR1cm4gX2ZzRXh0cmFQID0gcmVxdWlyZShcImZzLWV4dHJhLXBcIik7XG59XG5cbnZhciBfb3M7XG5cbmZ1bmN0aW9uIF9sb2FkX29zKCkge1xuICAgIHJldHVybiBfb3MgPSByZXF1aXJlKFwib3NcIik7XG59XG5cbnZhciBfcGF0aCA9IF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKHJlcXVpcmUoXCJwYXRoXCIpKTtcblxudmFyIF9BcHBVcGRhdGVyO1xuXG5mdW5jdGlvbiBfbG9hZF9BcHBVcGRhdGVyKCkge1xuICAgIHJldHVybiBfQXBwVXBkYXRlciA9IHJlcXVpcmUoXCIuL0FwcFVwZGF0ZXJcIik7XG59XG5cbnZhciBfRG93bmxvYWRlZFVwZGF0ZUhlbHBlcjtcblxuZnVuY3Rpb24gX2xvYWRfRG93bmxvYWRlZFVwZGF0ZUhlbHBlcigpIHtcbiAgICByZXR1cm4gX0Rvd25sb2FkZWRVcGRhdGVIZWxwZXIgPSByZXF1aXJlKFwiLi9Eb3dubG9hZGVkVXBkYXRlSGVscGVyXCIpO1xufVxuXG52YXIgX21haW47XG5cbmZ1bmN0aW9uIF9sb2FkX21haW4oKSB7XG4gICAgcmV0dXJuIF9tYWluID0gcmVxdWlyZShcIi4vbWFpblwiKTtcbn1cblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQob2JqKSB7IGlmIChvYmogJiYgb2JqLl9fZXNNb2R1bGUpIHsgcmV0dXJuIG9iajsgfSBlbHNlIHsgdmFyIG5ld09iaiA9IHt9OyBpZiAob2JqICE9IG51bGwpIHsgZm9yICh2YXIga2V5IGluIG9iaikgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwga2V5KSkgbmV3T2JqW2tleV0gPSBvYmpba2V5XTsgfSB9IG5ld09iai5kZWZhdWx0ID0gb2JqOyByZXR1cm4gbmV3T2JqOyB9IH1cblxuY2xhc3MgQmFzZVVwZGF0ZXIgZXh0ZW5kcyAoX0FwcFVwZGF0ZXIgfHwgX2xvYWRfQXBwVXBkYXRlcigpKS5BcHBVcGRhdGVyIHtcbiAgICBjb25zdHJ1Y3RvcihvcHRpb25zLCBhcHApIHtcbiAgICAgICAgc3VwZXIob3B0aW9ucywgYXBwKTtcbiAgICAgICAgdGhpcy5kb3dubG9hZGVkVXBkYXRlSGVscGVyID0gbmV3IChfRG93bmxvYWRlZFVwZGF0ZUhlbHBlciB8fCBfbG9hZF9Eb3dubG9hZGVkVXBkYXRlSGVscGVyKCkpLkRvd25sb2FkZWRVcGRhdGVIZWxwZXIoKTtcbiAgICAgICAgdGhpcy5xdWl0QW5kSW5zdGFsbENhbGxlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLnF1aXRIYW5kbGVyQWRkZWQgPSBmYWxzZTtcbiAgICB9XG4gICAgcXVpdEFuZEluc3RhbGwoaXNTaWxlbnQgPSBmYWxzZSwgaXNGb3JjZVJ1bkFmdGVyID0gZmFsc2UpIHtcbiAgICAgICAgdGhpcy5fbG9nZ2VyLmluZm8oYEluc3RhbGwgb24gZXhwbGljaXQgcXVpdEFuZEluc3RhbGxgKTtcbiAgICAgICAgaWYgKHRoaXMuaW5zdGFsbChpc1NpbGVudCwgaXNTaWxlbnQgPyBpc0ZvcmNlUnVuQWZ0ZXIgOiB0cnVlKSkge1xuICAgICAgICAgICAgc2V0SW1tZWRpYXRlKCgpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLmFwcC5xdWl0KCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBleGVjdXRlRG93bmxvYWQoZG93bmxvYWRPcHRpb25zLCBmaWxlSW5mbywgdGFzaykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgICAgIHJldHVybiAoMCwgKF9ibHVlYmlyZExzdCB8fCBfbG9hZF9ibHVlYmlyZExzdCgpKS5jb3JvdXRpbmUpKGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBpZiAoX3RoaXMubGlzdGVuZXJDb3VudCgoX21haW4gfHwgX2xvYWRfbWFpbigpKS5ET1dOTE9BRF9QUk9HUkVTUykgPiAwKSB7XG4gICAgICAgICAgICAgICAgZG93bmxvYWRPcHRpb25zLm9uUHJvZ3Jlc3MgPSBmdW5jdGlvbiAoaXQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF90aGlzLmVtaXQoKF9tYWluIHx8IF9sb2FkX21haW4oKSkuRE9XTkxPQURfUFJPR1JFU1MsIGl0KTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gdXNlIFRFU1RfQVBQX1RNUF9ESVIgaWYgZGVmaW5lZCBhbmQgZGV2ZWxvcGVyIG1hY2hpbmUgKG11c3QgYmUgbm90IHdpbmRvd3MgZHVlIHRvIHNlY3VyaXR5IHJlYXNvbnMgLSB3ZSBtdXN0IG5vdCB1c2UgZW52IHZhciBpbiB0aGUgcHJvZHVjdGlvbilcbiAgICAgICAgICAgIGNvbnN0IHRlbXBEaXIgPSB5aWVsZCAoMCwgKF9mc0V4dHJhUCB8fCBfbG9hZF9mc0V4dHJhUCgpKS5ta2R0ZW1wKShgJHtfcGF0aC5qb2luKChwcm9jZXNzLnBsYXRmb3JtID09PSBcImRhcndpblwiID8gcHJvY2Vzcy5lbnYuVEVTVF9BUFBfVE1QX0RJUiA6IG51bGwpIHx8ICgwLCAoX29zIHx8IF9sb2FkX29zKCkpLnRtcGRpcikoKSwgXCJ1cFwiKX0tYCk7XG4gICAgICAgICAgICBjb25zdCByZW1vdmVUZW1wRGlySWZBbnkgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMuZG93bmxvYWRlZFVwZGF0ZUhlbHBlci5jbGVhcigpO1xuICAgICAgICAgICAgICAgIHJldHVybiAoMCwgKF9mc0V4dHJhUCB8fCBfbG9hZF9mc0V4dHJhUCgpKS5yZW1vdmUpKHRlbXBEaXIpLmNhdGNoKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gaWdub3JlZFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZGVzdGluYXRpb25GaWxlID0gX3BhdGguam9pbih0ZW1wRGlyLCBfcGF0aC5wb3NpeC5iYXNlbmFtZShmaWxlSW5mby5pbmZvLnVybCkpO1xuICAgICAgICAgICAgICAgIHlpZWxkIHRhc2sodGVtcERpciwgZGVzdGluYXRpb25GaWxlLCByZW1vdmVUZW1wRGlySWZBbnkpO1xuICAgICAgICAgICAgICAgIF90aGlzLl9sb2dnZXIuaW5mbyhgTmV3IHZlcnNpb24gJHtfdGhpcy51cGRhdGVJbmZvLnZlcnNpb259IGhhcyBiZWVuIGRvd25sb2FkZWQgdG8gJHtkZXN0aW5hdGlvbkZpbGV9YCk7XG4gICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgeWllbGQgcmVtb3ZlVGVtcERpcklmQW55KCk7XG4gICAgICAgICAgICAgICAgaWYgKGUgaW5zdGFuY2VvZiAoX2J1aWxkZXJVdGlsUnVudGltZSB8fCBfbG9hZF9idWlsZGVyVXRpbFJ1bnRpbWUoKSkuQ2FuY2VsbGF0aW9uRXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuZW1pdChcInVwZGF0ZS1jYW5jZWxsZWRcIiwgX3RoaXMudXBkYXRlSW5mbyk7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLl9sb2dnZXIuaW5mbyhcIkNhbmNlbGxlZFwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSkoKTtcbiAgICB9XG4gICAgaW5zdGFsbChpc1NpbGVudCwgaXNSdW5BZnRlcikge1xuICAgICAgICBpZiAodGhpcy5xdWl0QW5kSW5zdGFsbENhbGxlZCkge1xuICAgICAgICAgICAgdGhpcy5fbG9nZ2VyLndhcm4oXCJpbnN0YWxsIGNhbGwgaWdub3JlZDogcXVpdEFuZEluc3RhbGxDYWxsZWQgaXMgc2V0IHRvIHRydWVcIik7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgaW5zdGFsbGVyUGF0aCA9IHRoaXMuZG93bmxvYWRlZFVwZGF0ZUhlbHBlci5maWxlO1xuICAgICAgICBpZiAoIXRoaXMudXBkYXRlQXZhaWxhYmxlIHx8IGluc3RhbGxlclBhdGggPT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5kaXNwYXRjaEVycm9yKG5ldyBFcnJvcihcIk5vIHVwZGF0ZSBhdmFpbGFibGUsIGNhbid0IHF1aXQgYW5kIGluc3RhbGxcIikpO1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIC8vIHByZXZlbnQgY2FsbGluZyBzZXZlcmFsIHRpbWVzXG4gICAgICAgIHRoaXMucXVpdEFuZEluc3RhbGxDYWxsZWQgPSB0cnVlO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgdGhpcy5fbG9nZ2VyLmluZm8oYEluc3RhbGw6IGlzU2lsZW50OiAke2lzU2lsZW50fSwgaXNSdW5BZnRlcjogJHtpc1J1bkFmdGVyfWApO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZG9JbnN0YWxsKGluc3RhbGxlclBhdGgsIGlzU2lsZW50LCBpc1J1bkFmdGVyKTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgdGhpcy5kaXNwYXRjaEVycm9yKGUpO1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFkZFF1aXRIYW5kbGVyKCkge1xuICAgICAgICBpZiAodGhpcy5xdWl0SGFuZGxlckFkZGVkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5xdWl0SGFuZGxlckFkZGVkID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5hcHAub25jZShcInF1aXRcIiwgKCkgPT4ge1xuICAgICAgICAgICAgaWYgKCF0aGlzLnF1aXRBbmRJbnN0YWxsQ2FsbGVkKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fbG9nZ2VyLmluZm8oXCJBdXRvIGluc3RhbGwgdXBkYXRlIG9uIHF1aXRcIik7XG4gICAgICAgICAgICAgICAgdGhpcy5pbnN0YWxsKHRydWUsIGZhbHNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxufVxuZXhwb3J0cy5CYXNlVXBkYXRlciA9IEJhc2VVcGRhdGVyOyAvLyMgc291cmNlTWFwcGluZ1VSTD1CYXNlVXBkYXRlci5qcy5tYXBcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvZWxlY3Ryb24tdXBkYXRlci9vdXQvQmFzZVVwZGF0ZXIuanMiLCJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5GaWxlV2l0aEVtYmVkZGVkQmxvY2tNYXBEaWZmZXJlbnRpYWxEb3dubG9hZGVyID0gdW5kZWZpbmVkO1xuXG52YXIgX2JsdWViaXJkTHN0O1xuXG5mdW5jdGlvbiBfbG9hZF9ibHVlYmlyZExzdCgpIHtcbiAgICByZXR1cm4gX2JsdWViaXJkTHN0ID0gcmVxdWlyZShcImJsdWViaXJkLWxzdFwiKTtcbn1cblxudmFyIF9ibG9ja01hcEFwaTtcblxuZnVuY3Rpb24gX2xvYWRfYmxvY2tNYXBBcGkoKSB7XG4gICAgcmV0dXJuIF9ibG9ja01hcEFwaSA9IHJlcXVpcmUoXCJidWlsZGVyLXV0aWwtcnVudGltZS9vdXQvYmxvY2tNYXBBcGlcIik7XG59XG5cbnZhciBfRGlmZmVyZW50aWFsRG93bmxvYWRlcjtcblxuZnVuY3Rpb24gX2xvYWRfRGlmZmVyZW50aWFsRG93bmxvYWRlcigpIHtcbiAgICByZXR1cm4gX0RpZmZlcmVudGlhbERvd25sb2FkZXIgPSByZXF1aXJlKFwiLi9EaWZmZXJlbnRpYWxEb3dubG9hZGVyXCIpO1xufVxuXG5jbGFzcyBGaWxlV2l0aEVtYmVkZGVkQmxvY2tNYXBEaWZmZXJlbnRpYWxEb3dubG9hZGVyIGV4dGVuZHMgKF9EaWZmZXJlbnRpYWxEb3dubG9hZGVyIHx8IF9sb2FkX0RpZmZlcmVudGlhbERvd25sb2FkZXIoKSkuRGlmZmVyZW50aWFsRG93bmxvYWRlciB7XG4gICAgZG93bmxvYWQoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICAgICAgcmV0dXJuICgwLCAoX2JsdWViaXJkTHN0IHx8IF9sb2FkX2JsdWViaXJkTHN0KCkpLmNvcm91dGluZSkoZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGNvbnN0IHBhY2thZ2VJbmZvID0gX3RoaXMuYmxvY2tBd2FyZUZpbGVJbmZvO1xuICAgICAgICAgICAgY29uc3QgZmlsZVNpemUgPSBwYWNrYWdlSW5mby5zaXplO1xuICAgICAgICAgICAgY29uc3Qgb2Zmc2V0ID0gZmlsZVNpemUgLSAocGFja2FnZUluZm8uYmxvY2tNYXBTaXplICsgNCk7XG4gICAgICAgICAgICBfdGhpcy5maWxlTWV0YWRhdGFCdWZmZXIgPSB5aWVsZCBfdGhpcy5yZWFkUmVtb3RlQnl0ZXMob2Zmc2V0LCBmaWxlU2l6ZSAtIDEpO1xuICAgICAgICAgICAgY29uc3QgbmV3QmxvY2tNYXAgPSB5aWVsZCAoMCwgKF9EaWZmZXJlbnRpYWxEb3dubG9hZGVyIHx8IF9sb2FkX0RpZmZlcmVudGlhbERvd25sb2FkZXIoKSkucmVhZEJsb2NrTWFwKShfdGhpcy5maWxlTWV0YWRhdGFCdWZmZXIuc2xpY2UoMCwgX3RoaXMuZmlsZU1ldGFkYXRhQnVmZmVyLmxlbmd0aCAtIDQpKTtcbiAgICAgICAgICAgIHlpZWxkIF90aGlzLmRvRG93bmxvYWQoSlNPTi5wYXJzZSgoeWllbGQgKDAsIChfYmxvY2tNYXBBcGkgfHwgX2xvYWRfYmxvY2tNYXBBcGkoKSkucmVhZEVtYmVkZGVkQmxvY2tNYXBEYXRhKShfdGhpcy5vcHRpb25zLm9sZEZpbGUpKSksIG5ld0Jsb2NrTWFwKTtcbiAgICAgICAgfSkoKTtcbiAgICB9XG59XG5leHBvcnRzLkZpbGVXaXRoRW1iZWRkZWRCbG9ja01hcERpZmZlcmVudGlhbERvd25sb2FkZXIgPSBGaWxlV2l0aEVtYmVkZGVkQmxvY2tNYXBEaWZmZXJlbnRpYWxEb3dubG9hZGVyOyAvLyMgc291cmNlTWFwcGluZ1VSTD1GaWxlV2l0aEVtYmVkZGVkQmxvY2tNYXBEaWZmZXJlbnRpYWxEb3dubG9hZGVyLmpzLm1hcFxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9lbGVjdHJvbi11cGRhdGVyL291dC9kaWZmZXJlbnRpYWxEb3dubG9hZGVyL0ZpbGVXaXRoRW1iZWRkZWRCbG9ja01hcERpZmZlcmVudGlhbERvd25sb2FkZXIuanMiLCJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5yZWFkRW1iZWRkZWRCbG9ja01hcERhdGEgPSBleHBvcnRzLkJMT0NLX01BUF9GSUxFX05BTUUgPSB1bmRlZmluZWQ7XG5cbnZhciBfYmx1ZWJpcmRMc3Q7XG5cbmZ1bmN0aW9uIF9sb2FkX2JsdWViaXJkTHN0KCkge1xuICAgIHJldHVybiBfYmx1ZWJpcmRMc3QgPSByZXF1aXJlKFwiYmx1ZWJpcmQtbHN0XCIpO1xufVxuXG52YXIgX2JsdWViaXJkTHN0MjtcblxuZnVuY3Rpb24gX2xvYWRfYmx1ZWJpcmRMc3QyKCkge1xuICAgIHJldHVybiBfYmx1ZWJpcmRMc3QyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiYmx1ZWJpcmQtbHN0XCIpKTtcbn1cblxubGV0IHJlYWRFbWJlZGRlZEJsb2NrTWFwRGF0YSA9IGV4cG9ydHMucmVhZEVtYmVkZGVkQmxvY2tNYXBEYXRhID0gKCgpID0+IHtcbiAgICB2YXIgX3JlZiA9ICgwLCAoX2JsdWViaXJkTHN0IHx8IF9sb2FkX2JsdWViaXJkTHN0KCkpLmNvcm91dGluZSkoZnVuY3Rpb24qIChmaWxlKSB7XG4gICAgICAgIGNvbnN0IGZkID0geWllbGQgKDAsIChfZnNFeHRyYVAgfHwgX2xvYWRfZnNFeHRyYVAoKSkub3BlbikoZmlsZSwgXCJyXCIpO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgZmlsZVNpemUgPSAoeWllbGQgKDAsIChfZnNFeHRyYVAgfHwgX2xvYWRfZnNFeHRyYVAoKSkuZnN0YXQpKGZkKSkuc2l6ZTtcbiAgICAgICAgICAgIGNvbnN0IHNpemVCdWZmZXIgPSBCdWZmZXIuYWxsb2NVbnNhZmUoNCk7XG4gICAgICAgICAgICB5aWVsZCAoMCwgKF9mc0V4dHJhUCB8fCBfbG9hZF9mc0V4dHJhUCgpKS5yZWFkKShmZCwgc2l6ZUJ1ZmZlciwgMCwgc2l6ZUJ1ZmZlci5sZW5ndGgsIGZpbGVTaXplIC0gc2l6ZUJ1ZmZlci5sZW5ndGgpO1xuICAgICAgICAgICAgY29uc3QgZGF0YUJ1ZmZlciA9IEJ1ZmZlci5hbGxvY1Vuc2FmZShzaXplQnVmZmVyLnJlYWRVSW50MzJCRSgwKSk7XG4gICAgICAgICAgICB5aWVsZCAoMCwgKF9mc0V4dHJhUCB8fCBfbG9hZF9mc0V4dHJhUCgpKS5yZWFkKShmZCwgZGF0YUJ1ZmZlciwgMCwgZGF0YUJ1ZmZlci5sZW5ndGgsIGZpbGVTaXplIC0gc2l6ZUJ1ZmZlci5sZW5ndGggLSBkYXRhQnVmZmVyLmxlbmd0aCk7XG4gICAgICAgICAgICB5aWVsZCAoMCwgKF9mc0V4dHJhUCB8fCBfbG9hZF9mc0V4dHJhUCgpKS5jbG9zZSkoZmQpO1xuICAgICAgICAgICAgY29uc3QgaW5mbGF0ZVJhdyA9IChfYmx1ZWJpcmRMc3QyIHx8IF9sb2FkX2JsdWViaXJkTHN0MigpKS5kZWZhdWx0LnByb21pc2lmeShyZXF1aXJlKFwiemxpYlwiKS5pbmZsYXRlUmF3KTtcbiAgICAgICAgICAgIHJldHVybiAoeWllbGQgaW5mbGF0ZVJhdyhkYXRhQnVmZmVyKSkudG9TdHJpbmcoKTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgeWllbGQgKDAsIChfZnNFeHRyYVAgfHwgX2xvYWRfZnNFeHRyYVAoKSkuY2xvc2UpKGZkKTtcbiAgICAgICAgICAgIHRocm93IGU7XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIHJldHVybiBmdW5jdGlvbiByZWFkRW1iZWRkZWRCbG9ja01hcERhdGEoX3gpIHtcbiAgICAgICAgcmV0dXJuIF9yZWYuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9O1xufSkoKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWJsb2NrTWFwQXBpLmpzLm1hcFxuXG5cbnZhciBfZnNFeHRyYVA7XG5cbmZ1bmN0aW9uIF9sb2FkX2ZzRXh0cmFQKCkge1xuICAgIHJldHVybiBfZnNFeHRyYVAgPSByZXF1aXJlKFwiZnMtZXh0cmEtcFwiKTtcbn1cblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuY29uc3QgQkxPQ0tfTUFQX0ZJTEVfTkFNRSA9IGV4cG9ydHMuQkxPQ0tfTUFQX0ZJTEVfTkFNRSA9IFwiX2Jsb2NrTWFwLmJsb2NrbWFwXCI7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2VsZWN0cm9uLXVwZGF0ZXIvbm9kZV9tb2R1bGVzL2J1aWxkZXItdXRpbC1ydW50aW1lL291dC9ibG9ja01hcEFwaS5qcyIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcInpsaWJcIik7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gZXh0ZXJuYWwgXCJ6bGliXCJcbi8vIG1vZHVsZSBpZCA9IDY0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLnJlYWRCbG9ja01hcCA9IGV4cG9ydHMuRGlmZmVyZW50aWFsRG93bmxvYWRlciA9IGV4cG9ydHMuRGlmZmVyZW50aWFsRG93bmxvYWRlck9wdGlvbnMgPSB1bmRlZmluZWQ7XG5cbnZhciBfYmx1ZWJpcmRMc3Q7XG5cbmZ1bmN0aW9uIF9sb2FkX2JsdWViaXJkTHN0KCkge1xuICAgIHJldHVybiBfYmx1ZWJpcmRMc3QgPSByZXF1aXJlKFwiYmx1ZWJpcmQtbHN0XCIpO1xufVxuXG52YXIgX2JsdWViaXJkTHN0MjtcblxuZnVuY3Rpb24gX2xvYWRfYmx1ZWJpcmRMc3QyKCkge1xuICAgIHJldHVybiBfYmx1ZWJpcmRMc3QyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiYmx1ZWJpcmQtbHN0XCIpKTtcbn1cblxubGV0IHJlYWRCbG9ja01hcCA9IGV4cG9ydHMucmVhZEJsb2NrTWFwID0gKCgpID0+IHtcbiAgICB2YXIgX3JlZiA9ICgwLCAoX2JsdWViaXJkTHN0IHx8IF9sb2FkX2JsdWViaXJkTHN0KCkpLmNvcm91dGluZSkoZnVuY3Rpb24qIChkYXRhKSB7XG4gICAgICAgIHJldHVybiBKU09OLnBhcnNlKCh5aWVsZCBpbmZsYXRlUmF3KGRhdGEpKS50b1N0cmluZygpKTtcbiAgICB9KTtcblxuICAgIHJldHVybiBmdW5jdGlvbiByZWFkQmxvY2tNYXAoX3gpIHtcbiAgICAgICAgcmV0dXJuIF9yZWYuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9O1xufSkoKTtcblxudmFyIF9idWlsZGVyVXRpbFJ1bnRpbWU7XG5cbmZ1bmN0aW9uIF9sb2FkX2J1aWxkZXJVdGlsUnVudGltZSgpIHtcbiAgICByZXR1cm4gX2J1aWxkZXJVdGlsUnVudGltZSA9IHJlcXVpcmUoXCJidWlsZGVyLXV0aWwtcnVudGltZVwiKTtcbn1cblxudmFyIF9mc0V4dHJhUDtcblxuZnVuY3Rpb24gX2xvYWRfZnNFeHRyYVAoKSB7XG4gICAgcmV0dXJuIF9mc0V4dHJhUCA9IHJlcXVpcmUoXCJmcy1leHRyYS1wXCIpO1xufVxuXG52YXIgX0RhdGFTcGxpdHRlcjtcblxuZnVuY3Rpb24gX2xvYWRfRGF0YVNwbGl0dGVyKCkge1xuICAgIHJldHVybiBfRGF0YVNwbGl0dGVyID0gcmVxdWlyZShcIi4vRGF0YVNwbGl0dGVyXCIpO1xufVxuXG52YXIgX2Rvd25sb2FkUGxhbkJ1aWxkZXI7XG5cbmZ1bmN0aW9uIF9sb2FkX2Rvd25sb2FkUGxhbkJ1aWxkZXIoKSB7XG4gICAgcmV0dXJuIF9kb3dubG9hZFBsYW5CdWlsZGVyID0gcmVxdWlyZShcIi4vZG93bmxvYWRQbGFuQnVpbGRlclwiKTtcbn1cblxudmFyIF9tdWx0aXBsZVJhbmdlRG93bmxvYWRlcjtcblxuZnVuY3Rpb24gX2xvYWRfbXVsdGlwbGVSYW5nZURvd25sb2FkZXIoKSB7XG4gICAgcmV0dXJuIF9tdWx0aXBsZVJhbmdlRG93bmxvYWRlciA9IHJlcXVpcmUoXCIuL211bHRpcGxlUmFuZ2VEb3dubG9hZGVyXCIpO1xufVxuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5jb25zdCBpbmZsYXRlUmF3ID0gKF9ibHVlYmlyZExzdDIgfHwgX2xvYWRfYmx1ZWJpcmRMc3QyKCkpLmRlZmF1bHQucHJvbWlzaWZ5KHJlcXVpcmUoXCJ6bGliXCIpLmluZmxhdGVSYXcpO1xuY2xhc3MgRGlmZmVyZW50aWFsRG93bmxvYWRlck9wdGlvbnMge31cbmV4cG9ydHMuRGlmZmVyZW50aWFsRG93bmxvYWRlck9wdGlvbnMgPSBEaWZmZXJlbnRpYWxEb3dubG9hZGVyT3B0aW9ucztcbmNsYXNzIERpZmZlcmVudGlhbERvd25sb2FkZXIge1xuICAgIC8vIG5vaW5zcGVjdGlvbiBUeXBlU2NyaXB0QWJzdHJhY3RDbGFzc0NvbnN0cnVjdG9yQ2FuQmVNYWRlUHJvdGVjdGVkXG4gICAgY29uc3RydWN0b3IoYmxvY2tBd2FyZUZpbGVJbmZvLCBodHRwRXhlY3V0b3IsIG9wdGlvbnMpIHtcbiAgICAgICAgdGhpcy5ibG9ja0F3YXJlRmlsZUluZm8gPSBibG9ja0F3YXJlRmlsZUluZm87XG4gICAgICAgIHRoaXMuaHR0cEV4ZWN1dG9yID0gaHR0cEV4ZWN1dG9yO1xuICAgICAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuICAgICAgICB0aGlzLmxvZ2dlciA9IG9wdGlvbnMubG9nZ2VyO1xuICAgICAgICB0aGlzLmJhc2VSZXF1ZXN0T3B0aW9ucyA9ICgwLCAoX2J1aWxkZXJVdGlsUnVudGltZSB8fCBfbG9hZF9idWlsZGVyVXRpbFJ1bnRpbWUoKSkuY29uZmlndXJlUmVxdWVzdE9wdGlvbnNGcm9tVXJsKShvcHRpb25zLm5ld1VybCwge30pO1xuICAgIH1cbiAgICBnZXQgc2lnbmF0dXJlU2l6ZSgpIHtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgfVxuICAgIGNyZWF0ZVJlcXVlc3RPcHRpb25zKG1ldGhvZCA9IFwiZ2V0XCIsIG5ld1VybCkge1xuICAgICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbih7fSwgbmV3VXJsID09IG51bGwgPyB0aGlzLmJhc2VSZXF1ZXN0T3B0aW9ucyA6ICgwLCAoX2J1aWxkZXJVdGlsUnVudGltZSB8fCBfbG9hZF9idWlsZGVyVXRpbFJ1bnRpbWUoKSkuY29uZmlndXJlUmVxdWVzdE9wdGlvbnNGcm9tVXJsKShuZXdVcmwsIHt9KSwgeyBtZXRob2QsIGhlYWRlcnM6IE9iamVjdC5hc3NpZ24oe30sIHRoaXMub3B0aW9ucy5yZXF1ZXN0SGVhZGVycywgeyBBY2NlcHQ6IFwiKi8qXCIgfSkgfSk7XG4gICAgfVxuICAgIGRvRG93bmxvYWQob2xkQmxvY2tNYXAsIG5ld0Jsb2NrTWFwKSB7XG4gICAgICAgIC8vIHdlIGRvbid0IGNoZWNrIG90aGVyIG1ldGFkYXRhIGxpa2UgY29tcHJlc3Npb25NZXRob2QgLSBnZW5lcmljIGNoZWNrIHRoYXQgaXQgaXMgbWFrZSBzZW5zZSB0byBkaWZmZXJlbnRpYWxseSB1cGRhdGUgaXMgc3VpdGFibGUgZm9yIGl0XG4gICAgICAgIGlmIChvbGRCbG9ja01hcC52ZXJzaW9uICE9PSBuZXdCbG9ja01hcC52ZXJzaW9uKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYHZlcnNpb24gaXMgZGlmZmVyZW50ICgke29sZEJsb2NrTWFwLnZlcnNpb259IC0gJHtuZXdCbG9ja01hcC52ZXJzaW9ufSksIGZ1bGwgZG93bmxvYWQgaXMgcmVxdWlyZWRgKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBsb2dnZXIgPSB0aGlzLmxvZ2dlcjtcbiAgICAgICAgY29uc3Qgb3BlcmF0aW9ucyA9ICgwLCAoX2Rvd25sb2FkUGxhbkJ1aWxkZXIgfHwgX2xvYWRfZG93bmxvYWRQbGFuQnVpbGRlcigpKS5jb21wdXRlT3BlcmF0aW9ucykob2xkQmxvY2tNYXAsIG5ld0Jsb2NrTWFwLCBsb2dnZXIpO1xuICAgICAgICBpZiAobG9nZ2VyLmRlYnVnICE9IG51bGwpIHtcbiAgICAgICAgICAgIGxvZ2dlci5kZWJ1ZyhKU09OLnN0cmluZ2lmeShvcGVyYXRpb25zLCBudWxsLCAyKSk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGRvd25sb2FkU2l6ZSA9IDA7XG4gICAgICAgIGxldCBjb3B5U2l6ZSA9IDA7XG4gICAgICAgIGZvciAoY29uc3Qgb3BlcmF0aW9uIG9mIG9wZXJhdGlvbnMpIHtcbiAgICAgICAgICAgIGNvbnN0IGxlbmd0aCA9IG9wZXJhdGlvbi5lbmQgLSBvcGVyYXRpb24uc3RhcnQ7XG4gICAgICAgICAgICBpZiAob3BlcmF0aW9uLmtpbmQgPT09IChfZG93bmxvYWRQbGFuQnVpbGRlciB8fCBfbG9hZF9kb3dubG9hZFBsYW5CdWlsZGVyKCkpLk9wZXJhdGlvbktpbmQuRE9XTkxPQUQpIHtcbiAgICAgICAgICAgICAgICBkb3dubG9hZFNpemUgKz0gbGVuZ3RoO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb3B5U2l6ZSArPSBsZW5ndGg7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbmV3UGFja2FnZVNpemUgPSB0aGlzLmJsb2NrQXdhcmVGaWxlSW5mby5zaXplO1xuICAgICAgICBpZiAoZG93bmxvYWRTaXplICsgY29weVNpemUgKyAodGhpcy5maWxlTWV0YWRhdGFCdWZmZXIgPT0gbnVsbCA/IDAgOiB0aGlzLmZpbGVNZXRhZGF0YUJ1ZmZlci5sZW5ndGgpICsgdGhpcy5zaWduYXR1cmVTaXplICE9PSBuZXdQYWNrYWdlU2l6ZSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnRlcm5hbCBlcnJvciwgc2l6ZSBtaXNtYXRjaDogZG93bmxvYWRTaXplOiAke2Rvd25sb2FkU2l6ZX0sIGNvcHlTaXplOiAke2NvcHlTaXplfSwgbmV3UGFja2FnZVNpemU6ICR7bmV3UGFja2FnZVNpemV9YCk7XG4gICAgICAgIH1cbiAgICAgICAgbG9nZ2VyLmluZm8oYEZ1bGw6ICR7Zm9ybWF0Qnl0ZXMobmV3UGFja2FnZVNpemUpfSwgVG8gZG93bmxvYWQ6ICR7Zm9ybWF0Qnl0ZXMoZG93bmxvYWRTaXplKX0gKCR7TWF0aC5yb3VuZChkb3dubG9hZFNpemUgLyAobmV3UGFja2FnZVNpemUgLyAxMDApKX0lKWApO1xuICAgICAgICByZXR1cm4gdGhpcy5kb3dubG9hZEZpbGUob3BlcmF0aW9ucyk7XG4gICAgfVxuICAgIGRvd25sb2FkRmlsZSh0YXNrcykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgICAgIHJldHVybiAoMCwgKF9ibHVlYmlyZExzdCB8fCBfbG9hZF9ibHVlYmlyZExzdCgpKS5jb3JvdXRpbmUpKGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCBzaWduYXR1cmUgPSBfdGhpcy5zaWduYXR1cmVTaXplID09PSAwID8gbnVsbCA6IHlpZWxkIF90aGlzLnJlYWRSZW1vdGVCeXRlcygwLCBfdGhpcy5zaWduYXR1cmVTaXplIC0gMSk7XG4gICAgICAgICAgICBjb25zdCBvbGRGaWxlRmQgPSB5aWVsZCAoMCwgKF9mc0V4dHJhUCB8fCBfbG9hZF9mc0V4dHJhUCgpKS5vcGVuKShfdGhpcy5vcHRpb25zLm9sZEZpbGUsIFwiclwiKTtcbiAgICAgICAgICAgIGNvbnN0IG5ld0ZpbGVGZCA9IHlpZWxkICgwLCAoX2ZzRXh0cmFQIHx8IF9sb2FkX2ZzRXh0cmFQKCkpLm9wZW4pKF90aGlzLm9wdGlvbnMubmV3RmlsZSwgXCJ3XCIpO1xuICAgICAgICAgICAgY29uc3QgZmlsZU91dCA9ICgwLCAoX2ZzRXh0cmFQIHx8IF9sb2FkX2ZzRXh0cmFQKCkpLmNyZWF0ZVdyaXRlU3RyZWFtKShfdGhpcy5vcHRpb25zLm5ld0ZpbGUsIHsgZmQ6IG5ld0ZpbGVGZCB9KTtcbiAgICAgICAgICAgIHlpZWxkIG5ldyAoX2JsdWViaXJkTHN0MiB8fCBfbG9hZF9ibHVlYmlyZExzdDIoKSkuZGVmYXVsdChmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgc3RyZWFtcyA9IFtdO1xuICAgICAgICAgICAgICAgIGNvbnN0IGRpZ2VzdFRyYW5zZm9ybSA9IG5ldyAoX2J1aWxkZXJVdGlsUnVudGltZSB8fCBfbG9hZF9idWlsZGVyVXRpbFJ1bnRpbWUoKSkuRGlnZXN0VHJhbnNmb3JtKF90aGlzLmJsb2NrQXdhcmVGaWxlSW5mby5zaGE1MTIpO1xuICAgICAgICAgICAgICAgIC8vIHRvIHNpbXBseSBkZWJ1ZywgZG8gbWFudWFsIHZhbGlkYXRpb24gdG8gYWxsb3cgZmlsZSB0byBiZSBmdWxseSB3cml0dGVuXG4gICAgICAgICAgICAgICAgZGlnZXN0VHJhbnNmb3JtLmlzVmFsaWRhdGVPbkVuZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIHN0cmVhbXMucHVzaChkaWdlc3RUcmFuc2Zvcm0pO1xuICAgICAgICAgICAgICAgIC8vIG5vaW5zcGVjdGlvbiBKU0Fycm93RnVuY3Rpb25DYW5CZVJlcGxhY2VkV2l0aFNob3J0aGFuZFxuICAgICAgICAgICAgICAgIGZpbGVPdXQub24oXCJmaW5pc2hcIiwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICBmaWxlT3V0LmNsb3NlKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGlnZXN0VHJhbnNmb3JtLnZhbGlkYXRlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVqZWN0KGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmUoKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgc3RyZWFtcy5wdXNoKGZpbGVPdXQpO1xuICAgICAgICAgICAgICAgIGxldCBsYXN0U3RyZWFtID0gbnVsbDtcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IHN0cmVhbSBvZiBzdHJlYW1zKSB7XG4gICAgICAgICAgICAgICAgICAgIHN0cmVhbS5vbihcImVycm9yXCIsIHJlamVjdCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChsYXN0U3RyZWFtID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxhc3RTdHJlYW0gPSBzdHJlYW07XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsYXN0U3RyZWFtID0gbGFzdFN0cmVhbS5waXBlKHN0cmVhbSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgZmlyc3RTdHJlYW0gPSBzdHJlYW1zWzBdO1xuICAgICAgICAgICAgICAgIGxldCB3O1xuICAgICAgICAgICAgICAgIGlmIChfdGhpcy5vcHRpb25zLnVzZU11bHRpcGxlUmFuZ2VSZXF1ZXN0KSB7XG4gICAgICAgICAgICAgICAgICAgIHcgPSAoMCwgKF9tdWx0aXBsZVJhbmdlRG93bmxvYWRlciB8fCBfbG9hZF9tdWx0aXBsZVJhbmdlRG93bmxvYWRlcigpKS5leGVjdXRlVGFza3MpKF90aGlzLCB0YXNrcywgZmlyc3RTdHJlYW0sIG9sZEZpbGVGZCwgcmVqZWN0KTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBsZXQgYXR0ZW1wdENvdW50ID0gMDtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGFjdHVhbFVybCA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLmxvZ2dlci5pbmZvKGBEaWZmZXJlbnRpYWwgZG93bmxvYWQ6ICR7X3RoaXMub3B0aW9ucy5uZXdVcmx9YCk7XG4gICAgICAgICAgICAgICAgICAgIHcgPSBmdW5jdGlvbiAoaW5kZXgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpbmRleCA+PSB0YXNrcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoX3RoaXMuZmlsZU1ldGFkYXRhQnVmZmVyICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZmlyc3RTdHJlYW0ud3JpdGUoX3RoaXMuZmlsZU1ldGFkYXRhQnVmZmVyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZmlyc3RTdHJlYW0uZW5kKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3Qgb3BlcmF0aW9uID0gdGFza3NbaW5kZXgrK107XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAob3BlcmF0aW9uLmtpbmQgPT09IChfZG93bmxvYWRQbGFuQnVpbGRlciB8fCBfbG9hZF9kb3dubG9hZFBsYW5CdWlsZGVyKCkpLk9wZXJhdGlvbktpbmQuQ09QWSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICgwLCAoX0RhdGFTcGxpdHRlciB8fCBfbG9hZF9EYXRhU3BsaXR0ZXIoKSkuY29weURhdGEpKG9wZXJhdGlvbiwgZmlyc3RTdHJlYW0sIG9sZEZpbGVGZCwgcmVqZWN0LCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB3KGluZGV4KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVxdWVzdE9wdGlvbnMgPSBfdGhpcy5jcmVhdGVSZXF1ZXN0T3B0aW9ucyhcImdldFwiLCBhY3R1YWxVcmwpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHJhbmdlID0gYGJ5dGVzPSR7b3BlcmF0aW9uLnN0YXJ0fS0ke29wZXJhdGlvbi5lbmQgLSAxfWA7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVxdWVzdE9wdGlvbnMuaGVhZGVycy5SYW5nZSA9IHJhbmdlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlcXVlc3RPcHRpb25zLnJlZGlyZWN0ID0gXCJtYW51YWxcIjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBkZWJ1ZyA9IF90aGlzLmxvZ2dlci5kZWJ1ZztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZGVidWcgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWJ1ZyhgZWZmZWN0aXZlIHVybDogJHthY3R1YWxVcmwgPT0gbnVsbCA/IFwiXCIgOiByZW1vdmVRdWVyeShhY3R1YWxVcmwpfSwgcmFuZ2U6ICR7cmFuZ2V9YCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlcXVlc3QgPSBfdGhpcy5odHRwRXhlY3V0b3IuZG9SZXF1ZXN0KHJlcXVlc3RPcHRpb25zLCBmdW5jdGlvbiAocmVzcG9uc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gRWxlY3Ryb24gbmV0IGhhbmRsZXMgcmVkaXJlY3RzIGF1dG9tYXRpY2FsbHksIG91ciBOb2RlSlMgdGVzdCBzZXJ2ZXIgZG9lc24ndCB1c2UgcmVkaXJlY3RzIC0gc28sIHdlIGRvbid0IGNoZWNrIDN4eCBjb2Rlcy5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJlc3BvbnNlLnN0YXR1c0NvZGUgPj0gNDAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWplY3QoKDAsIChfYnVpbGRlclV0aWxSdW50aW1lIHx8IF9sb2FkX2J1aWxkZXJVdGlsUnVudGltZSgpKS5jcmVhdGVIdHRwRXJyb3IpKHJlc3BvbnNlKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2UucGlwZShmaXJzdFN0cmVhbSwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZW5kOiBmYWxzZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2Uub25jZShcImVuZFwiLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoKythdHRlbXB0Q291bnQgPT09IDEwMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGF0dGVtcHRDb3VudCA9IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB3KGluZGV4KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LCAxMDAwKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdyhpbmRleCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlcXVlc3Qub24oXCJyZWRpcmVjdFwiLCBmdW5jdGlvbiAoc3RhdHVzQ29kZSwgbWV0aG9kLCByZWRpcmVjdFVybCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5sb2dnZXIuaW5mbyhgUmVkaXJlY3QgdG8gJHtyZW1vdmVRdWVyeShyZWRpcmVjdFVybCl9YCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFjdHVhbFVybCA9IHJlZGlyZWN0VXJsO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXF1ZXN0LmZvbGxvd1JlZGlyZWN0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuaHR0cEV4ZWN1dG9yLmFkZEVycm9yQW5kVGltZW91dEhhbmRsZXJzKHJlcXVlc3QsIHJlamVjdCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVxdWVzdC5lbmQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHNpZ25hdHVyZSA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHcoMCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZmlyc3RTdHJlYW0ud3JpdGUoc2lnbmF0dXJlLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdygwKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSkudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICgwLCAoX2ZzRXh0cmFQIHx8IF9sb2FkX2ZzRXh0cmFQKCkpLmNsb3NlKShvbGRGaWxlRmQpO1xuICAgICAgICAgICAgfSkuY2F0Y2goZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgKDAsIChfZnNFeHRyYVAgfHwgX2xvYWRfZnNFeHRyYVAoKSkuY2xvc2VTeW5jKShvbGRGaWxlRmQpO1xuICAgICAgICAgICAgICAgICgwLCAoX2ZzRXh0cmFQIHx8IF9sb2FkX2ZzRXh0cmFQKCkpLmNsb3NlU3luYykobmV3RmlsZUZkKTtcbiAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KSgpO1xuICAgIH1cbiAgICByZWFkUmVtb3RlQnl0ZXMoc3RhcnQsIGVuZEluY2x1c2l2ZSkge1xuICAgICAgICB2YXIgX3RoaXMyID0gdGhpcztcblxuICAgICAgICByZXR1cm4gKDAsIChfYmx1ZWJpcmRMc3QgfHwgX2xvYWRfYmx1ZWJpcmRMc3QoKSkuY29yb3V0aW5lKShmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3QgYnVmZmVyID0gQnVmZmVyLmFsbG9jVW5zYWZlKGVuZEluY2x1c2l2ZSArIDEgLSBzdGFydCk7XG4gICAgICAgICAgICBjb25zdCByZXF1ZXN0T3B0aW9ucyA9IF90aGlzMi5jcmVhdGVSZXF1ZXN0T3B0aW9ucygpO1xuICAgICAgICAgICAgcmVxdWVzdE9wdGlvbnMuaGVhZGVycy5SYW5nZSA9IGBieXRlcz0ke3N0YXJ0fS0ke2VuZEluY2x1c2l2ZX1gO1xuICAgICAgICAgICAgbGV0IHBvc2l0aW9uID0gMDtcbiAgICAgICAgICAgIHlpZWxkIF90aGlzMi5yZXF1ZXN0KHJlcXVlc3RPcHRpb25zLCBmdW5jdGlvbiAoY2h1bmspIHtcbiAgICAgICAgICAgICAgICBjaHVuay5jb3B5KGJ1ZmZlciwgcG9zaXRpb24pO1xuICAgICAgICAgICAgICAgIHBvc2l0aW9uICs9IGNodW5rLmxlbmd0aDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIGJ1ZmZlcjtcbiAgICAgICAgfSkoKTtcbiAgICB9XG4gICAgcmVxdWVzdChyZXF1ZXN0T3B0aW9ucywgZGF0YUhhbmRsZXIpIHtcbiAgICAgICAgcmV0dXJuIG5ldyAoX2JsdWViaXJkTHN0MiB8fCBfbG9hZF9ibHVlYmlyZExzdDIoKSkuZGVmYXVsdCgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICBjb25zdCByZXF1ZXN0ID0gdGhpcy5odHRwRXhlY3V0b3IuZG9SZXF1ZXN0KHJlcXVlc3RPcHRpb25zLCByZXNwb25zZSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKCEoMCwgKF9tdWx0aXBsZVJhbmdlRG93bmxvYWRlciB8fCBfbG9hZF9tdWx0aXBsZVJhbmdlRG93bmxvYWRlcigpKS5jaGVja0lzUmFuZ2VzU3VwcG9ydGVkKShyZXNwb25zZSwgcmVqZWN0KSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJlc3BvbnNlLm9uKFwiZGF0YVwiLCBkYXRhSGFuZGxlcik7XG4gICAgICAgICAgICAgICAgcmVzcG9uc2Uub24oXCJlbmRcIiwgKCkgPT4gcmVzb2x2ZSgpKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdGhpcy5odHRwRXhlY3V0b3IuYWRkRXJyb3JBbmRUaW1lb3V0SGFuZGxlcnMocmVxdWVzdCwgcmVqZWN0KTtcbiAgICAgICAgICAgIHJlcXVlc3QuZW5kKCk7XG4gICAgICAgIH0pO1xuICAgIH1cbn1cbmV4cG9ydHMuRGlmZmVyZW50aWFsRG93bmxvYWRlciA9IERpZmZlcmVudGlhbERvd25sb2FkZXI7XG5cbmZ1bmN0aW9uIGZvcm1hdEJ5dGVzKHZhbHVlLCBzeW1ib2wgPSBcIiBLQlwiKSB7XG4gICAgcmV0dXJuIG5ldyBJbnRsLk51bWJlckZvcm1hdChcImVuXCIpLmZvcm1hdCgodmFsdWUgLyAxMDI0KS50b0ZpeGVkKDIpKSArIHN5bWJvbDtcbn1cbi8vIHNhZmV0eVxuZnVuY3Rpb24gcmVtb3ZlUXVlcnkodXJsKSB7XG4gICAgY29uc3QgaW5kZXggPSB1cmwuaW5kZXhPZihcIj9cIik7XG4gICAgcmV0dXJuIGluZGV4IDwgMCA/IHVybCA6IHVybC5zdWJzdHJpbmcoMCwgaW5kZXgpO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9RGlmZmVyZW50aWFsRG93bmxvYWRlci5qcy5tYXBcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvZWxlY3Ryb24tdXBkYXRlci9vdXQvZGlmZmVyZW50aWFsRG93bmxvYWRlci9EaWZmZXJlbnRpYWxEb3dubG9hZGVyLmpzIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuRGF0YVNwbGl0dGVyID0gdW5kZWZpbmVkO1xuXG52YXIgX2JsdWViaXJkTHN0O1xuXG5mdW5jdGlvbiBfbG9hZF9ibHVlYmlyZExzdCgpIHtcbiAgICByZXR1cm4gX2JsdWViaXJkTHN0ID0gcmVxdWlyZShcImJsdWViaXJkLWxzdFwiKTtcbn1cblxudmFyIF9ibHVlYmlyZExzdDI7XG5cbmZ1bmN0aW9uIF9sb2FkX2JsdWViaXJkTHN0MigpIHtcbiAgICByZXR1cm4gX2JsdWViaXJkTHN0MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcImJsdWViaXJkLWxzdFwiKSk7XG59XG5cbmV4cG9ydHMuY29weURhdGEgPSBjb3B5RGF0YTtcblxudmFyIF9idWlsZGVyVXRpbFJ1bnRpbWU7XG5cbmZ1bmN0aW9uIF9sb2FkX2J1aWxkZXJVdGlsUnVudGltZSgpIHtcbiAgICByZXR1cm4gX2J1aWxkZXJVdGlsUnVudGltZSA9IHJlcXVpcmUoXCJidWlsZGVyLXV0aWwtcnVudGltZVwiKTtcbn1cblxudmFyIF9mc0V4dHJhUDtcblxuZnVuY3Rpb24gX2xvYWRfZnNFeHRyYVAoKSB7XG4gICAgcmV0dXJuIF9mc0V4dHJhUCA9IHJlcXVpcmUoXCJmcy1leHRyYS1wXCIpO1xufVxuXG52YXIgX3N0cmVhbTtcblxuZnVuY3Rpb24gX2xvYWRfc3RyZWFtKCkge1xuICAgIHJldHVybiBfc3RyZWFtID0gcmVxdWlyZShcInN0cmVhbVwiKTtcbn1cblxudmFyIF9kb3dubG9hZFBsYW5CdWlsZGVyO1xuXG5mdW5jdGlvbiBfbG9hZF9kb3dubG9hZFBsYW5CdWlsZGVyKCkge1xuICAgIHJldHVybiBfZG93bmxvYWRQbGFuQnVpbGRlciA9IHJlcXVpcmUoXCIuL2Rvd25sb2FkUGxhbkJ1aWxkZXJcIik7XG59XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmNvbnN0IERPVUJMRV9DUkxGID0gQnVmZmVyLmZyb20oXCJcXHJcXG5cXHJcXG5cIik7XG52YXIgUmVhZFN0YXRlO1xuKGZ1bmN0aW9uIChSZWFkU3RhdGUpIHtcbiAgICBSZWFkU3RhdGVbUmVhZFN0YXRlW1wiSU5JVFwiXSA9IDBdID0gXCJJTklUXCI7XG4gICAgUmVhZFN0YXRlW1JlYWRTdGF0ZVtcIkhFQURFUlwiXSA9IDFdID0gXCJIRUFERVJcIjtcbiAgICBSZWFkU3RhdGVbUmVhZFN0YXRlW1wiQk9EWVwiXSA9IDJdID0gXCJCT0RZXCI7XG59KShSZWFkU3RhdGUgfHwgKFJlYWRTdGF0ZSA9IHt9KSk7XG5mdW5jdGlvbiBjb3B5RGF0YSh0YXNrLCBvdXQsIG9sZEZpbGVGZCwgcmVqZWN0LCByZXNvbHZlKSB7XG4gICAgY29uc3QgcmVhZFN0cmVhbSA9ICgwLCAoX2ZzRXh0cmFQIHx8IF9sb2FkX2ZzRXh0cmFQKCkpLmNyZWF0ZVJlYWRTdHJlYW0pKFwiXCIsIHtcbiAgICAgICAgZmQ6IG9sZEZpbGVGZCxcbiAgICAgICAgYXV0b0Nsb3NlOiBmYWxzZSxcbiAgICAgICAgc3RhcnQ6IHRhc2suc3RhcnQsXG4gICAgICAgIC8vIGVuZCBpcyBpbmNsdXNpdmVcbiAgICAgICAgZW5kOiB0YXNrLmVuZCAtIDFcbiAgICB9KTtcbiAgICByZWFkU3RyZWFtLm9uKFwiZXJyb3JcIiwgcmVqZWN0KTtcbiAgICByZWFkU3RyZWFtLm9uY2UoXCJlbmRcIiwgcmVzb2x2ZSk7XG4gICAgcmVhZFN0cmVhbS5waXBlKG91dCwge1xuICAgICAgICBlbmQ6IGZhbHNlXG4gICAgfSk7XG59XG5jbGFzcyBEYXRhU3BsaXR0ZXIgZXh0ZW5kcyAoX3N0cmVhbSB8fCBfbG9hZF9zdHJlYW0oKSkuV3JpdGFibGUge1xuICAgIGNvbnN0cnVjdG9yKG91dCwgb3B0aW9ucywgcGFydEluZGV4VG9UYXNrSW5kZXgsIGJvdW5kYXJ5LCBwYXJ0SW5kZXhUb0xlbmd0aCwgZmluaXNoSGFuZGxlcikge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLm91dCA9IG91dDtcbiAgICAgICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgICAgICAgdGhpcy5wYXJ0SW5kZXhUb1Rhc2tJbmRleCA9IHBhcnRJbmRleFRvVGFza0luZGV4O1xuICAgICAgICB0aGlzLnBhcnRJbmRleFRvTGVuZ3RoID0gcGFydEluZGV4VG9MZW5ndGg7XG4gICAgICAgIHRoaXMuZmluaXNoSGFuZGxlciA9IGZpbmlzaEhhbmRsZXI7XG4gICAgICAgIHRoaXMucGFydEluZGV4ID0gLTE7XG4gICAgICAgIHRoaXMuaGVhZGVyTGlzdEJ1ZmZlciA9IG51bGw7XG4gICAgICAgIHRoaXMucmVhZFN0YXRlID0gUmVhZFN0YXRlLklOSVQ7XG4gICAgICAgIHRoaXMuaWdub3JlQnl0ZUNvdW50ID0gMDtcbiAgICAgICAgdGhpcy5yZW1haW5pbmdQYXJ0RGF0YUNvdW50ID0gMDtcbiAgICAgICAgdGhpcy5hY3R1YWxQYXJ0TGVuZ3RoID0gMDtcbiAgICAgICAgdGhpcy5ib3VuZGFyeUxlbmd0aCA9IGJvdW5kYXJ5Lmxlbmd0aCArIDQ7IC8qIHNpemUgb2YgXFxyXFxuLS0gKi9cbiAgICAgICAgLy8gZmlyc3QgY2h1bmsgZG9lc24ndCBzdGFydCB3aXRoIFxcclxcblxuICAgICAgICB0aGlzLmlnbm9yZUJ5dGVDb3VudCA9IHRoaXMuYm91bmRhcnlMZW5ndGggLSAyO1xuICAgIH1cbiAgICBnZXQgaXNGaW5pc2hlZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucGFydEluZGV4ID09PSB0aGlzLnBhcnRJbmRleFRvTGVuZ3RoLmxlbmd0aDtcbiAgICB9XG4gICAgLy8gbm9pbnNwZWN0aW9uIEpTVW51c2VkR2xvYmFsU3ltYm9sc1xuICAgIF93cml0ZShkYXRhLCBlbmNvZGluZywgY2FsbGJhY2spIHtcbiAgICAgICAgaWYgKHRoaXMuaXNGaW5pc2hlZCkge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcihgVHJhaWxpbmcgaWdub3JlZCBkYXRhOiAke2RhdGEubGVuZ3RofSBieXRlc2ApO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuaGFuZGxlRGF0YShkYXRhKS50aGVuKGNhbGxiYWNrKS5jYXRjaChjYWxsYmFjayk7XG4gICAgfVxuICAgIGhhbmRsZURhdGEoY2h1bmspIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgICAgICByZXR1cm4gKDAsIChfYmx1ZWJpcmRMc3QgfHwgX2xvYWRfYmx1ZWJpcmRMc3QoKSkuY29yb3V0aW5lKShmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgbGV0IHN0YXJ0ID0gMDtcbiAgICAgICAgICAgIGlmIChfdGhpcy5pZ25vcmVCeXRlQ291bnQgIT09IDAgJiYgX3RoaXMucmVtYWluaW5nUGFydERhdGFDb3VudCAhPT0gMCkge1xuICAgICAgICAgICAgICAgIHRocm93ICgwLCAoX2J1aWxkZXJVdGlsUnVudGltZSB8fCBfbG9hZF9idWlsZGVyVXRpbFJ1bnRpbWUoKSkubmV3RXJyb3IpKFwiSW50ZXJuYWwgZXJyb3JcIiwgXCJFUlJfREFUQV9TUExJVFRFUl9CWVRFX0NPVU5UX01JU01BVENIXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKF90aGlzLmlnbm9yZUJ5dGVDb3VudCA+IDApIHtcbiAgICAgICAgICAgICAgICBjb25zdCB0b0lnbm9yZSA9IE1hdGgubWluKF90aGlzLmlnbm9yZUJ5dGVDb3VudCwgY2h1bmsubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICBfdGhpcy5pZ25vcmVCeXRlQ291bnQgLT0gdG9JZ25vcmU7XG4gICAgICAgICAgICAgICAgc3RhcnQgPSB0b0lnbm9yZTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoX3RoaXMucmVtYWluaW5nUGFydERhdGFDb3VudCA+IDApIHtcbiAgICAgICAgICAgICAgICBjb25zdCB0b1JlYWQgPSBNYXRoLm1pbihfdGhpcy5yZW1haW5pbmdQYXJ0RGF0YUNvdW50LCBjaHVuay5sZW5ndGgpO1xuICAgICAgICAgICAgICAgIF90aGlzLnJlbWFpbmluZ1BhcnREYXRhQ291bnQgLT0gdG9SZWFkO1xuICAgICAgICAgICAgICAgIHlpZWxkIF90aGlzLnByb2Nlc3NQYXJ0RGF0YShjaHVuaywgMCwgdG9SZWFkKTtcbiAgICAgICAgICAgICAgICBzdGFydCA9IHRvUmVhZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzdGFydCA9PT0gY2h1bmsubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKF90aGlzLnJlYWRTdGF0ZSA9PT0gUmVhZFN0YXRlLkhFQURFUikge1xuICAgICAgICAgICAgICAgIGNvbnN0IGhlYWRlckxpc3RFbmQgPSBfdGhpcy5zZWFyY2hIZWFkZXJMaXN0RW5kKGNodW5rLCBzdGFydCk7XG4gICAgICAgICAgICAgICAgaWYgKGhlYWRlckxpc3RFbmQgPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgc3RhcnQgPSBoZWFkZXJMaXN0RW5kO1xuICAgICAgICAgICAgICAgIF90aGlzLnJlYWRTdGF0ZSA9IFJlYWRTdGF0ZS5CT0RZO1xuICAgICAgICAgICAgICAgIC8vIGhlYWRlciBsaXN0IGlzIGlnbm9yZWQsIHdlIGRvbid0IG5lZWQgaXRcbiAgICAgICAgICAgICAgICBfdGhpcy5oZWFkZXJMaXN0QnVmZmVyID0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgICAgICAgICAgaWYgKF90aGlzLnJlYWRTdGF0ZSA9PT0gUmVhZFN0YXRlLkJPRFkpIHtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMucmVhZFN0YXRlID0gUmVhZFN0YXRlLklOSVQ7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMucGFydEluZGV4Kys7XG4gICAgICAgICAgICAgICAgICAgIGxldCB0YXNrSW5kZXggPSBfdGhpcy5wYXJ0SW5kZXhUb1Rhc2tJbmRleC5nZXQoX3RoaXMucGFydEluZGV4KTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRhc2tJbmRleCA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoX3RoaXMuaXNGaW5pc2hlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRhc2tJbmRleCA9IF90aGlzLm9wdGlvbnMuZW5kO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyAoMCwgKF9idWlsZGVyVXRpbFJ1bnRpbWUgfHwgX2xvYWRfYnVpbGRlclV0aWxSdW50aW1lKCkpLm5ld0Vycm9yKShcInRhc2tJbmRleCBpcyBudWxsXCIsIFwiRVJSX0RBVEFfU1BMSVRURVJfVEFTS19JTkRFWF9JU19OVUxMXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHByZXZUYXNrSW5kZXggPSBfdGhpcy5wYXJ0SW5kZXggPT09IDAgPyBfdGhpcy5vcHRpb25zLnN0YXJ0IDogX3RoaXMucGFydEluZGV4VG9UYXNrSW5kZXguZ2V0KF90aGlzLnBhcnRJbmRleCAtIDEpICsgMSAvKiBwcmV2IHBhcnQgaXMgZG93bmxvYWQsIG5leHQgbWF5YmUgY29weSAqLztcbiAgICAgICAgICAgICAgICAgICAgaWYgKHByZXZUYXNrSW5kZXggPCB0YXNrSW5kZXgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHlpZWxkIF90aGlzLmNvcHlFeGlzdGluZ0RhdGEocHJldlRhc2tJbmRleCwgdGFza0luZGV4KTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChwcmV2VGFza0luZGV4ID4gdGFza0luZGV4KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyAoMCwgKF9idWlsZGVyVXRpbFJ1bnRpbWUgfHwgX2xvYWRfYnVpbGRlclV0aWxSdW50aW1lKCkpLm5ld0Vycm9yKShcInByZXZUYXNrSW5kZXggbXVzdCBiZSA8IHRhc2tJbmRleFwiLCBcIkVSUl9EQVRBX1NQTElUVEVSX1RBU0tfSU5ERVhfQVNTRVJUX0ZBSUxFRFwiKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoX3RoaXMuaXNGaW5pc2hlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMub25QYXJ0RW5kKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5maW5pc2hIYW5kbGVyKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgc3RhcnQgPSBfdGhpcy5zZWFyY2hIZWFkZXJMaXN0RW5kKGNodW5rLCBzdGFydCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzdGFydCA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLnJlYWRTdGF0ZSA9IFJlYWRTdGF0ZS5IRUFERVI7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgcGFydExlbmd0aCA9IF90aGlzLnBhcnRJbmRleFRvTGVuZ3RoW190aGlzLnBhcnRJbmRleF07XG4gICAgICAgICAgICAgICAgY29uc3QgZW5kID0gc3RhcnQgKyBwYXJ0TGVuZ3RoO1xuICAgICAgICAgICAgICAgIGNvbnN0IGVmZmVjdGl2ZUVuZCA9IE1hdGgubWluKGVuZCwgY2h1bmsubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICB5aWVsZCBfdGhpcy5wcm9jZXNzUGFydFN0YXJ0ZWQoY2h1bmssIHN0YXJ0LCBlZmZlY3RpdmVFbmQpO1xuICAgICAgICAgICAgICAgIF90aGlzLnJlbWFpbmluZ1BhcnREYXRhQ291bnQgPSBwYXJ0TGVuZ3RoIC0gKGVmZmVjdGl2ZUVuZCAtIHN0YXJ0KTtcbiAgICAgICAgICAgICAgICBpZiAoX3RoaXMucmVtYWluaW5nUGFydERhdGFDb3VudCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBzdGFydCA9IGVuZCArIF90aGlzLmJvdW5kYXJ5TGVuZ3RoO1xuICAgICAgICAgICAgICAgIGlmIChzdGFydCA+PSBjaHVuay5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuaWdub3JlQnl0ZUNvdW50ID0gX3RoaXMuYm91bmRhcnlMZW5ndGggLSAoY2h1bmsubGVuZ3RoIC0gZW5kKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSkoKTtcbiAgICB9XG4gICAgY29weUV4aXN0aW5nRGF0YShpbmRleCwgZW5kKSB7XG4gICAgICAgIHJldHVybiBuZXcgKF9ibHVlYmlyZExzdDIgfHwgX2xvYWRfYmx1ZWJpcmRMc3QyKCkpLmRlZmF1bHQoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgdyA9ICgpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoaW5kZXggPT09IGVuZCkge1xuICAgICAgICAgICAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgdGFzayA9IHRoaXMub3B0aW9ucy50YXNrc1tpbmRleF07XG4gICAgICAgICAgICAgICAgaWYgKHRhc2sua2luZCAhPT0gKF9kb3dubG9hZFBsYW5CdWlsZGVyIHx8IF9sb2FkX2Rvd25sb2FkUGxhbkJ1aWxkZXIoKSkuT3BlcmF0aW9uS2luZC5DT1BZKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlamVjdChuZXcgRXJyb3IoXCJUYXNrIGtpbmQgbXVzdCBiZSBDT1BZXCIpKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb3B5RGF0YSh0YXNrLCB0aGlzLm91dCwgdGhpcy5vcHRpb25zLm9sZEZpbGVGZCwgcmVqZWN0LCAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGluZGV4Kys7XG4gICAgICAgICAgICAgICAgICAgIHcoKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB3KCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBzZWFyY2hIZWFkZXJMaXN0RW5kKGNodW5rLCByZWFkT2Zmc2V0KSB7XG4gICAgICAgIGNvbnN0IGhlYWRlckxpc3RFbmQgPSBjaHVuay5pbmRleE9mKERPVUJMRV9DUkxGLCByZWFkT2Zmc2V0KTtcbiAgICAgICAgaWYgKGhlYWRlckxpc3RFbmQgIT09IC0xKSB7XG4gICAgICAgICAgICByZXR1cm4gaGVhZGVyTGlzdEVuZCArIERPVUJMRV9DUkxGLmxlbmd0aDtcbiAgICAgICAgfVxuICAgICAgICAvLyBub3QgYWxsIGhlYWRlcnMgZGF0YSB3ZXJlIHJlY2VpdmVkLCBzYXZlIHRvIGJ1ZmZlclxuICAgICAgICBjb25zdCBwYXJ0aWFsQ2h1bmsgPSByZWFkT2Zmc2V0ID09PSAwID8gY2h1bmsgOiBjaHVuay5zbGljZShyZWFkT2Zmc2V0KTtcbiAgICAgICAgaWYgKHRoaXMuaGVhZGVyTGlzdEJ1ZmZlciA9PSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLmhlYWRlckxpc3RCdWZmZXIgPSBwYXJ0aWFsQ2h1bms7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmhlYWRlckxpc3RCdWZmZXIgPSBCdWZmZXIuY29uY2F0KFt0aGlzLmhlYWRlckxpc3RCdWZmZXIsIHBhcnRpYWxDaHVua10pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAtMTtcbiAgICB9XG4gICAgb25QYXJ0RW5kKCkge1xuICAgICAgICBjb25zdCBleHBlY3RlZExlbmd0aCA9IHRoaXMucGFydEluZGV4VG9MZW5ndGhbdGhpcy5wYXJ0SW5kZXggLSAxXTtcbiAgICAgICAgaWYgKHRoaXMuYWN0dWFsUGFydExlbmd0aCAhPT0gZXhwZWN0ZWRMZW5ndGgpIHtcbiAgICAgICAgICAgIHRocm93ICgwLCAoX2J1aWxkZXJVdGlsUnVudGltZSB8fCBfbG9hZF9idWlsZGVyVXRpbFJ1bnRpbWUoKSkubmV3RXJyb3IpKGBFeHBlY3RlZCBsZW5ndGg6ICR7ZXhwZWN0ZWRMZW5ndGh9IGRpZmZlcnMgZnJvbSBhY3R1YWw6ICR7dGhpcy5hY3R1YWxQYXJ0TGVuZ3RofWAsIFwiRVJSX0RBVEFfU1BMSVRURVJfTEVOR1RIX01JU01BVENIXCIpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuYWN0dWFsUGFydExlbmd0aCA9IDA7XG4gICAgfVxuICAgIHByb2Nlc3NQYXJ0U3RhcnRlZChkYXRhLCBzdGFydCwgZW5kKSB7XG4gICAgICAgIGlmICh0aGlzLnBhcnRJbmRleCAhPT0gMCkge1xuICAgICAgICAgICAgdGhpcy5vblBhcnRFbmQoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5wcm9jZXNzUGFydERhdGEoZGF0YSwgc3RhcnQsIGVuZCk7XG4gICAgfVxuICAgIHByb2Nlc3NQYXJ0RGF0YShkYXRhLCBzdGFydCwgZW5kKSB7XG4gICAgICAgIHRoaXMuYWN0dWFsUGFydExlbmd0aCArPSBlbmQgLSBzdGFydDtcbiAgICAgICAgY29uc3Qgb3V0ID0gdGhpcy5vdXQ7XG4gICAgICAgIGlmIChvdXQud3JpdGUoc3RhcnQgPT09IDAgJiYgZGF0YS5sZW5ndGggPT09IGVuZCA/IGRhdGEgOiBkYXRhLnNsaWNlKHN0YXJ0LCBlbmQpKSkge1xuICAgICAgICAgICAgcmV0dXJuIChfYmx1ZWJpcmRMc3QyIHx8IF9sb2FkX2JsdWViaXJkTHN0MigpKS5kZWZhdWx0LnJlc29sdmUoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgKF9ibHVlYmlyZExzdDIgfHwgX2xvYWRfYmx1ZWJpcmRMc3QyKCkpLmRlZmF1bHQoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgICAgIG91dC5vbihcImVycm9yXCIsIHJlamVjdCk7XG4gICAgICAgICAgICAgICAgb3V0Lm9uY2UoXCJkcmFpblwiLCAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIG91dC5yZW1vdmVMaXN0ZW5lcihcImVycm9yXCIsIHJlamVjdCk7XG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmUoKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxufVxuZXhwb3J0cy5EYXRhU3BsaXR0ZXIgPSBEYXRhU3BsaXR0ZXI7IC8vIyBzb3VyY2VNYXBwaW5nVVJMPURhdGFTcGxpdHRlci5qcy5tYXBcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvZWxlY3Ryb24tdXBkYXRlci9vdXQvZGlmZmVyZW50aWFsRG93bmxvYWRlci9EYXRhU3BsaXR0ZXIuanMiLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCJodHRwXCIpO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIGV4dGVybmFsIFwiaHR0cFwiXG4vLyBtb2R1bGUgaWQgPSA2N1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIndXNlIHN0cmljdCc7XG5cbi8qKlxuICogU2F2ZSBjb25zb2xlIG1ldGhvZHMgZm9yIHVzaW5nIHdoZW4gb3JpZ2luYWxzIGFyZSBvdmVycmlkZGVuXG4gKi9cbm1vZHVsZS5leHBvcnRzID0ge1xuICBjb250ZXh0OiBjb25zb2xlLFxuICBlcnJvcjogICBjb25zb2xlLmVycm9yLFxuICB3YXJuOiAgICBjb25zb2xlLndhcm4sXG4gIGluZm86ICAgIGNvbnNvbGUuaW5mbyxcbiAgdmVyYm9zZTogY29uc29sZS52ZXJib3NlLFxuICBkZWJ1ZzogICBjb25zb2xlLmRlYnVnLFxuICBzaWxseTogICBjb25zb2xlLnNpbGx5LFxuICBsb2c6ICAgICBjb25zb2xlLmxvZ1xufTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9lbGVjdHJvbi1sb2cvbGliL29yaWdpbmFsLWNvbnNvbGUuanMiLCJpbXBvcnQgeyBhcHAsIEJyb3dzZXJXaW5kb3csIGlwY01haW4gfSBmcm9tICdlbGVjdHJvbidcbmltcG9ydCBpc0RldiBmcm9tICdlbGVjdHJvbi1pcy1kZXYnXG5pbXBvcnQgeyBhdXRvVXBkYXRlciB9IGZyb20gJ2VsZWN0cm9uLXVwZGF0ZXInXG5cbmRlY2xhcmUgdmFyIF9fZGlybmFtZTogc3RyaW5nXG5sZXQgbWFpbldpbmRvdzogRWxlY3Ryb24uQnJvd3NlcldpbmRvd1xuY29uc3QgbG9nID0gcmVxdWlyZSgnZWxlY3Ryb24tbG9nJylcbmxvZy50cmFuc3BvcnRzLmZpbGUubGV2ZWwgPSAnZGVidWcnXG5cbmZ1bmN0aW9uIG9uUmVhZHkoKSB7XG4gIG1haW5XaW5kb3cgPSBuZXcgQnJvd3NlcldpbmRvdyh7XG4gICAgd2lkdGg6IDgwMCxcbiAgICBoZWlnaHQ6IDYwMCxcbiAgICB3ZWJQcmVmZXJlbmNlczoge1xuICAgICAgd2ViU2VjdXJpdHk6IGZhbHNlXG4gICAgfVxuICB9KVxuICBtYWluV2luZG93LnNldFRpdGxlKHJlcXVpcmUoJy4uL3BhY2thZ2UuanNvbicpLm5hbWUpXG5cbiAgY29uc3QgZmlsZU5hbWUgPSBgZmlsZTovLyR7X19kaXJuYW1lfS9pbmRleC5odG1sYFxuICBtYWluV2luZG93LmxvYWRVUkwoZmlsZU5hbWUpXG4gIG1haW5XaW5kb3cub24oJ2Nsb3NlJywgKCkgPT4gYXBwLnF1aXQoKSlcblxuICBpZiAoaXNEZXYpIHtcbiAgICBtYWluV2luZG93LndlYkNvbnRlbnRzLm9wZW5EZXZUb29scygpXG4gIH1cblxuICBpZiAoIWlzRGV2KSB7XG4gICAgY29uZmlndXJlQXBwVXBkYXRlKClcbiAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIHBlcmZvcm1BcHBVcGRhdGUoKVxuICAgIH0sIDUwMDApXG4gIH1cbn1cblxuYXBwLm9uKCdyZWFkeScsICgpID0+IG9uUmVhZHkoKSlcbmFwcC5vbignd2luZG93LWFsbC1jbG9zZWQnLCAoKSA9PiBhcHAucXVpdCgpKVxuYXBwLm9uKCdicm93c2VyLXdpbmRvdy1jcmVhdGVkJyxmdW5jdGlvbihfZSwgd2luZG93KSB7XG4gIHdpbmRvdy5zZXRNZW51KG51bGwpXG59KVxuXG5pcGNNYWluLm9uKCd0aGVtZScgLCAoX2V2ZW50OiBzdHJpbmcsIGFyZzogc3RyaW5nKSA9PiB7XG4gIG1haW5XaW5kb3cud2ViQ29udGVudHMuc2VuZCgndGhlbWUnLCBhcmcpXG59KVxuXG5mdW5jdGlvbiBwZXJmb3JtQXBwVXBkYXRlKCkge1xuICBsb2cuZGVidWcoJ3NlbmRpbmcgdXBkYXRlciBjaGVja2luZy1mb3ItdXBkYXRlJylcbiAgYXV0b1VwZGF0ZXIuYXV0b0Rvd25sb2FkID0gZmFsc2VcbiAgYXV0b1VwZGF0ZXIuY2hlY2tGb3JVcGRhdGVzKClcbn1cblxuZnVuY3Rpb24gY29uZmlndXJlQXBwVXBkYXRlKCkge1xuICBhdXRvVXBkYXRlci5sb2dnZXIgPSBsb2dcblxuICBhdXRvVXBkYXRlci5vbignY2hlY2tpbmctZm9yLXVwZGF0ZScsICgpID0+IHtcbiAgICBsb2cuZGVidWcoJ3NlbmRpbmcgdXBkYXRlciBjaGVja2luZy1mb3ItdXBkYXRlJylcbiAgICBtYWluV2luZG93LndlYkNvbnRlbnRzLnNlbmQoJ3VwZGF0ZXInLCAnY2hlY2tpbmctZm9yLXVwZGF0ZScpXG4gIH0pXG4gIGF1dG9VcGRhdGVyLm9uKCd1cGRhdGUtYXZhaWxhYmxlJywgKGluZm8pID0+IHtcbiAgICBsb2cuZGVidWcoJ3NlbmRpbmcgdXBkYXRlciB1cGRhdGUtYXZhaWxhYmxlJylcbiAgICBtYWluV2luZG93LndlYkNvbnRlbnRzLnNlbmQoJ3VwZGF0ZXInLCAndXBkYXRlLWF2YWlsYWJsZScsIGluZm8pXG4gIH0pXG4gIGF1dG9VcGRhdGVyLm9uKCd1cGRhdGUtbm90LWF2YWlsYWJsZScsIChpbmZvKSA9PiB7XG4gICAgbG9nLmRlYnVnKCdzZW5kaW5nIHVwZGF0ZXIgdXBkYXRlLW5vdC1hdmFpbGFibGUnKVxuICAgIG1haW5XaW5kb3cud2ViQ29udGVudHMuc2VuZCgndXBkYXRlcicsICd1cGRhdGUtbm90LWF2YWlsYWJsZScsIGluZm8pXG4gIH0pXG4gIGF1dG9VcGRhdGVyLm9uKCdlcnJvcicsIChlcnIpID0+IHtcbiAgICBsb2cuZGVidWcoJ3NlbmRpbmcgdXBkYXRlciBlcnJvcicpXG4gICAgbWFpbldpbmRvdy53ZWJDb250ZW50cy5zZW5kKCd1cGRhdGVyJywgJ2Vycm9yJywgZXJyKVxuICB9KVxuICBhdXRvVXBkYXRlci5vbignZG93bmxvYWQtcHJvZ3Jlc3MnLCAocHJvZ3Jlc3NPYmopID0+IHtcbiAgICBsb2cuZGVidWcoJ3NlbmRpbmcgdXBkYXRlciBkb3dubG9hZC1wcm9ncmVzcycpXG4gICAgbWFpbldpbmRvdy53ZWJDb250ZW50cy5zZW5kKCd1cGRhdGVyJywgJ2Rvd25sb2FkLXByb2dyZXNzJywgcHJvZ3Jlc3NPYmopXG4gIH0pXG4gIGF1dG9VcGRhdGVyLm9uKCd1cGRhdGUtZG93bmxvYWRlZCcsIChpbmZvKSA9PiB7XG4gICAgbG9nLmRlYnVnKCdzZW5kaW5nIHVwZGF0ZXIgdXBkYXRlLWRvd25sb2FkZWQnKVxuICAgIG1haW5XaW5kb3cud2ViQ29udGVudHMuc2VuZCgndXBkYXRlcicsICd1cGRhdGUtZG93bmxvYWRlZCcsIGluZm8pXG4gIH0pXG5cbiAgaXBjTWFpbi5vbigndXBkYXRlcicsIChfZXZlbnQ6IGFueSwgdHlwZTogc3RyaW5nKSA9PiB7XG4gICAgaWYgKHR5cGUgPT09ICdkb3dubG9hZCcpIHtcbiAgICAgIGF1dG9VcGRhdGVyLmRvd25sb2FkVXBkYXRlKClcbiAgICB9XG4gICAgaWYgKHR5cGUgPT09ICdpbnN0YWxsJykge1xuICAgICAgYXV0b1VwZGF0ZXIucXVpdEFuZEluc3RhbGwoKVxuICAgIH1cbiAgfSlcbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9tYWluLnRzeCIsIlwidXNlIHN0cmljdFwiO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbigpIHtcbnZhciBtYWtlU2VsZlJlc29sdXRpb25FcnJvciA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gbmV3IFR5cGVFcnJvcihcImNpcmN1bGFyIHByb21pc2UgcmVzb2x1dGlvbiBjaGFpblxcdTAwMGFcXHUwMDBhICAgIFNlZSBodHRwOi8vZ29vLmdsL01xckZtWFxcdTAwMGFcIik7XG59O1xudmFyIHJlZmxlY3RIYW5kbGVyID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlLlByb21pc2VJbnNwZWN0aW9uKHRoaXMuX3RhcmdldCgpKTtcbn07XG52YXIgYXBpUmVqZWN0aW9uID0gZnVuY3Rpb24obXNnKSB7XG4gICAgcmV0dXJuIFByb21pc2UucmVqZWN0KG5ldyBUeXBlRXJyb3IobXNnKSk7XG59O1xuZnVuY3Rpb24gUHJveHlhYmxlKCkge31cbnZhciBVTkRFRklORURfQklORElORyA9IHt9O1xudmFyIHV0aWwgPSByZXF1aXJlKFwiLi91dGlsXCIpO1xuXG52YXIgZ2V0RG9tYWluO1xuaWYgKHV0aWwuaXNOb2RlKSB7XG4gICAgZ2V0RG9tYWluID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciByZXQgPSBwcm9jZXNzLmRvbWFpbjtcbiAgICAgICAgaWYgKHJldCA9PT0gdW5kZWZpbmVkKSByZXQgPSBudWxsO1xuICAgICAgICByZXR1cm4gcmV0O1xuICAgIH07XG59IGVsc2Uge1xuICAgIGdldERvbWFpbiA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9O1xufVxudXRpbC5ub3RFbnVtZXJhYmxlUHJvcChQcm9taXNlLCBcIl9nZXREb21haW5cIiwgZ2V0RG9tYWluKTtcblxudmFyIGVzNSA9IHJlcXVpcmUoXCIuL2VzNVwiKTtcbnZhciBBc3luYyA9IHJlcXVpcmUoXCIuL2FzeW5jXCIpO1xudmFyIGFzeW5jID0gbmV3IEFzeW5jKCk7XG5lczUuZGVmaW5lUHJvcGVydHkoUHJvbWlzZSwgXCJfYXN5bmNcIiwge3ZhbHVlOiBhc3luY30pO1xudmFyIGVycm9ycyA9IHJlcXVpcmUoXCIuL2Vycm9yc1wiKTtcbnZhciBUeXBlRXJyb3IgPSBQcm9taXNlLlR5cGVFcnJvciA9IGVycm9ycy5UeXBlRXJyb3I7XG5Qcm9taXNlLlJhbmdlRXJyb3IgPSBlcnJvcnMuUmFuZ2VFcnJvcjtcbnZhciBDYW5jZWxsYXRpb25FcnJvciA9IFByb21pc2UuQ2FuY2VsbGF0aW9uRXJyb3IgPSBlcnJvcnMuQ2FuY2VsbGF0aW9uRXJyb3I7XG5Qcm9taXNlLlRpbWVvdXRFcnJvciA9IGVycm9ycy5UaW1lb3V0RXJyb3I7XG5Qcm9taXNlLk9wZXJhdGlvbmFsRXJyb3IgPSBlcnJvcnMuT3BlcmF0aW9uYWxFcnJvcjtcblByb21pc2UuUmVqZWN0aW9uRXJyb3IgPSBlcnJvcnMuT3BlcmF0aW9uYWxFcnJvcjtcblByb21pc2UuQWdncmVnYXRlRXJyb3IgPSBlcnJvcnMuQWdncmVnYXRlRXJyb3I7XG52YXIgSU5URVJOQUwgPSBmdW5jdGlvbigpe307XG52YXIgQVBQTFkgPSB7fTtcbnZhciBORVhUX0ZJTFRFUiA9IHt9O1xudmFyIHRyeUNvbnZlcnRUb1Byb21pc2UgPSByZXF1aXJlKFwiLi90aGVuYWJsZXNcIikoUHJvbWlzZSwgSU5URVJOQUwpO1xudmFyIFByb21pc2VBcnJheSA9XG4gICAgcmVxdWlyZShcIi4vcHJvbWlzZV9hcnJheVwiKShQcm9taXNlLCBJTlRFUk5BTCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cnlDb252ZXJ0VG9Qcm9taXNlLCBhcGlSZWplY3Rpb24sIFByb3h5YWJsZSk7XG52YXIgQ29udGV4dCA9IHJlcXVpcmUoXCIuL2NvbnRleHRcIikoUHJvbWlzZSk7XG4gLypqc2hpbnQgdW51c2VkOmZhbHNlKi9cbnZhciBjcmVhdGVDb250ZXh0ID0gQ29udGV4dC5jcmVhdGU7XG52YXIgZGVidWcgPSByZXF1aXJlKFwiLi9kZWJ1Z2dhYmlsaXR5XCIpKFByb21pc2UsIENvbnRleHQpO1xudmFyIENhcHR1cmVkVHJhY2UgPSBkZWJ1Zy5DYXB0dXJlZFRyYWNlO1xudmFyIFBhc3NUaHJvdWdoSGFuZGxlckNvbnRleHQgPVxuICAgIHJlcXVpcmUoXCIuL2ZpbmFsbHlcIikoUHJvbWlzZSwgdHJ5Q29udmVydFRvUHJvbWlzZSwgTkVYVF9GSUxURVIpO1xudmFyIGNhdGNoRmlsdGVyID0gcmVxdWlyZShcIi4vY2F0Y2hfZmlsdGVyXCIpKE5FWFRfRklMVEVSKTtcbnZhciBub2RlYmFja0ZvclByb21pc2UgPSByZXF1aXJlKFwiLi9ub2RlYmFja1wiKTtcbnZhciBlcnJvck9iaiA9IHV0aWwuZXJyb3JPYmo7XG52YXIgdHJ5Q2F0Y2ggPSB1dGlsLnRyeUNhdGNoO1xuZnVuY3Rpb24gY2hlY2soc2VsZiwgZXhlY3V0b3IpIHtcbiAgICBpZiAoc2VsZiA9PSBudWxsIHx8IHNlbGYuY29uc3RydWN0b3IgIT09IFByb21pc2UpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcInRoZSBwcm9taXNlIGNvbnN0cnVjdG9yIGNhbm5vdCBiZSBpbnZva2VkIGRpcmVjdGx5XFx1MDAwYVxcdTAwMGEgICAgU2VlIGh0dHA6Ly9nb28uZ2wvTXFyRm1YXFx1MDAwYVwiKTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBleGVjdXRvciAhPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJleHBlY3RpbmcgYSBmdW5jdGlvbiBidXQgZ290IFwiICsgdXRpbC5jbGFzc1N0cmluZyhleGVjdXRvcikpO1xuICAgIH1cblxufVxuXG5mdW5jdGlvbiBQcm9taXNlKGV4ZWN1dG9yKSB7XG4gICAgaWYgKGV4ZWN1dG9yICE9PSBJTlRFUk5BTCkge1xuICAgICAgICBjaGVjayh0aGlzLCBleGVjdXRvcik7XG4gICAgfVxuICAgIHRoaXMuX2JpdEZpZWxkID0gMDtcbiAgICB0aGlzLl9mdWxmaWxsbWVudEhhbmRsZXIwID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuX3JlamVjdGlvbkhhbmRsZXIwID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuX3Byb21pc2UwID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuX3JlY2VpdmVyMCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLl9yZXNvbHZlRnJvbUV4ZWN1dG9yKGV4ZWN1dG9yKTtcbiAgICB0aGlzLl9wcm9taXNlQ3JlYXRlZCgpO1xuICAgIHRoaXMuX2ZpcmVFdmVudChcInByb21pc2VDcmVhdGVkXCIsIHRoaXMpO1xufVxuXG5Qcm9taXNlLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gXCJbb2JqZWN0IFByb21pc2VdXCI7XG59O1xuXG5Qcm9taXNlLnByb3RvdHlwZS5jYXVnaHQgPSBQcm9taXNlLnByb3RvdHlwZVtcImNhdGNoXCJdID0gZnVuY3Rpb24gKGZuKSB7XG4gICAgdmFyIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgaWYgKGxlbiA+IDEpIHtcbiAgICAgICAgdmFyIGNhdGNoSW5zdGFuY2VzID0gbmV3IEFycmF5KGxlbiAtIDEpLFxuICAgICAgICAgICAgaiA9IDAsIGk7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW4gLSAxOyArK2kpIHtcbiAgICAgICAgICAgIHZhciBpdGVtID0gYXJndW1lbnRzW2ldO1xuICAgICAgICAgICAgaWYgKHV0aWwuaXNPYmplY3QoaXRlbSkpIHtcbiAgICAgICAgICAgICAgICBjYXRjaEluc3RhbmNlc1tqKytdID0gaXRlbTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGFwaVJlamVjdGlvbihcIkNhdGNoIHN0YXRlbWVudCBwcmVkaWNhdGU6IFwiICtcbiAgICAgICAgICAgICAgICAgICAgXCJleHBlY3RpbmcgYW4gb2JqZWN0IGJ1dCBnb3QgXCIgKyB1dGlsLmNsYXNzU3RyaW5nKGl0ZW0pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjYXRjaEluc3RhbmNlcy5sZW5ndGggPSBqO1xuICAgICAgICBmbiA9IGFyZ3VtZW50c1tpXTtcbiAgICAgICAgcmV0dXJuIHRoaXMudGhlbih1bmRlZmluZWQsIGNhdGNoRmlsdGVyKGNhdGNoSW5zdGFuY2VzLCBmbiwgdGhpcykpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy50aGVuKHVuZGVmaW5lZCwgZm4pO1xufTtcblxuUHJvbWlzZS5wcm90b3R5cGUucmVmbGVjdCA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5fdGhlbihyZWZsZWN0SGFuZGxlcixcbiAgICAgICAgcmVmbGVjdEhhbmRsZXIsIHVuZGVmaW5lZCwgdGhpcywgdW5kZWZpbmVkKTtcbn07XG5cblByb21pc2UucHJvdG90eXBlLnRoZW4gPSBmdW5jdGlvbiAoZGlkRnVsZmlsbCwgZGlkUmVqZWN0KSB7XG4gICAgaWYgKGRlYnVnLndhcm5pbmdzKCkgJiYgYXJndW1lbnRzLmxlbmd0aCA+IDAgJiZcbiAgICAgICAgdHlwZW9mIGRpZEZ1bGZpbGwgIT09IFwiZnVuY3Rpb25cIiAmJlxuICAgICAgICB0eXBlb2YgZGlkUmVqZWN0ICE9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgdmFyIG1zZyA9IFwiLnRoZW4oKSBvbmx5IGFjY2VwdHMgZnVuY3Rpb25zIGJ1dCB3YXMgcGFzc2VkOiBcIiArXG4gICAgICAgICAgICAgICAgdXRpbC5jbGFzc1N0cmluZyhkaWRGdWxmaWxsKTtcbiAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICBtc2cgKz0gXCIsIFwiICsgdXRpbC5jbGFzc1N0cmluZyhkaWRSZWplY3QpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3dhcm4obXNnKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX3RoZW4oZGlkRnVsZmlsbCwgZGlkUmVqZWN0LCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgdW5kZWZpbmVkKTtcbn07XG5cblByb21pc2UucHJvdG90eXBlLmRvbmUgPSBmdW5jdGlvbiAoZGlkRnVsZmlsbCwgZGlkUmVqZWN0KSB7XG4gICAgdmFyIHByb21pc2UgPVxuICAgICAgICB0aGlzLl90aGVuKGRpZEZ1bGZpbGwsIGRpZFJlamVjdCwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIHVuZGVmaW5lZCk7XG4gICAgcHJvbWlzZS5fc2V0SXNGaW5hbCgpO1xufTtcblxuUHJvbWlzZS5wcm90b3R5cGUuc3ByZWFkID0gZnVuY3Rpb24gKGZuKSB7XG4gICAgaWYgKHR5cGVvZiBmbiAhPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIHJldHVybiBhcGlSZWplY3Rpb24oXCJleHBlY3RpbmcgYSBmdW5jdGlvbiBidXQgZ290IFwiICsgdXRpbC5jbGFzc1N0cmluZyhmbikpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5hbGwoKS5fdGhlbihmbiwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIEFQUExZLCB1bmRlZmluZWQpO1xufTtcblxuUHJvbWlzZS5wcm90b3R5cGUudG9KU09OID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciByZXQgPSB7XG4gICAgICAgIGlzRnVsZmlsbGVkOiBmYWxzZSxcbiAgICAgICAgaXNSZWplY3RlZDogZmFsc2UsXG4gICAgICAgIGZ1bGZpbGxtZW50VmFsdWU6IHVuZGVmaW5lZCxcbiAgICAgICAgcmVqZWN0aW9uUmVhc29uOiB1bmRlZmluZWRcbiAgICB9O1xuICAgIGlmICh0aGlzLmlzRnVsZmlsbGVkKCkpIHtcbiAgICAgICAgcmV0LmZ1bGZpbGxtZW50VmFsdWUgPSB0aGlzLnZhbHVlKCk7XG4gICAgICAgIHJldC5pc0Z1bGZpbGxlZCA9IHRydWU7XG4gICAgfSBlbHNlIGlmICh0aGlzLmlzUmVqZWN0ZWQoKSkge1xuICAgICAgICByZXQucmVqZWN0aW9uUmVhc29uID0gdGhpcy5yZWFzb24oKTtcbiAgICAgICAgcmV0LmlzUmVqZWN0ZWQgPSB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gcmV0O1xufTtcblxuUHJvbWlzZS5wcm90b3R5cGUuYWxsID0gZnVuY3Rpb24gKCkge1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMCkge1xuICAgICAgICB0aGlzLl93YXJuKFwiLmFsbCgpIHdhcyBwYXNzZWQgYXJndW1lbnRzIGJ1dCBpdCBkb2VzIG5vdCB0YWtlIGFueVwiKTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlQXJyYXkodGhpcykucHJvbWlzZSgpO1xufTtcblxuUHJvbWlzZS5wcm90b3R5cGUuZXJyb3IgPSBmdW5jdGlvbiAoZm4pIHtcbiAgICByZXR1cm4gdGhpcy5jYXVnaHQodXRpbC5vcmlnaW5hdGVzRnJvbVJlamVjdGlvbiwgZm4pO1xufTtcblxuUHJvbWlzZS5nZXROZXdMaWJyYXJ5Q29weSA9IG1vZHVsZS5leHBvcnRzO1xuXG5Qcm9taXNlLmlzID0gZnVuY3Rpb24gKHZhbCkge1xuICAgIHJldHVybiB2YWwgaW5zdGFuY2VvZiBQcm9taXNlO1xufTtcblxuUHJvbWlzZS5mcm9tTm9kZSA9IFByb21pc2UuZnJvbUNhbGxiYWNrID0gZnVuY3Rpb24oZm4pIHtcbiAgICB2YXIgcmV0ID0gbmV3IFByb21pc2UoSU5URVJOQUwpO1xuICAgIHJldC5fY2FwdHVyZVN0YWNrVHJhY2UoKTtcbiAgICB2YXIgbXVsdGlBcmdzID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgPyAhIU9iamVjdChhcmd1bWVudHNbMV0pLm11bHRpQXJnc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IGZhbHNlO1xuICAgIHZhciByZXN1bHQgPSB0cnlDYXRjaChmbikobm9kZWJhY2tGb3JQcm9taXNlKHJldCwgbXVsdGlBcmdzKSk7XG4gICAgaWYgKHJlc3VsdCA9PT0gZXJyb3JPYmopIHtcbiAgICAgICAgcmV0Ll9yZWplY3RDYWxsYmFjayhyZXN1bHQuZSwgdHJ1ZSk7XG4gICAgfVxuICAgIGlmICghcmV0Ll9pc0ZhdGVTZWFsZWQoKSkgcmV0Ll9zZXRBc3luY0d1YXJhbnRlZWQoKTtcbiAgICByZXR1cm4gcmV0O1xufTtcblxuUHJvbWlzZS5hbGwgPSBmdW5jdGlvbiAocHJvbWlzZXMpIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2VBcnJheShwcm9taXNlcykucHJvbWlzZSgpO1xufTtcblxuUHJvbWlzZS5jYXN0ID0gZnVuY3Rpb24gKG9iaikge1xuICAgIHZhciByZXQgPSB0cnlDb252ZXJ0VG9Qcm9taXNlKG9iaik7XG4gICAgaWYgKCEocmV0IGluc3RhbmNlb2YgUHJvbWlzZSkpIHtcbiAgICAgICAgcmV0ID0gbmV3IFByb21pc2UoSU5URVJOQUwpO1xuICAgICAgICByZXQuX2NhcHR1cmVTdGFja1RyYWNlKCk7XG4gICAgICAgIHJldC5fc2V0RnVsZmlsbGVkKCk7XG4gICAgICAgIHJldC5fcmVqZWN0aW9uSGFuZGxlcjAgPSBvYmo7XG4gICAgfVxuICAgIHJldHVybiByZXQ7XG59O1xuXG5Qcm9taXNlLnJlc29sdmUgPSBQcm9taXNlLmZ1bGZpbGxlZCA9IFByb21pc2UuY2FzdDtcblxuUHJvbWlzZS5yZWplY3QgPSBQcm9taXNlLnJlamVjdGVkID0gZnVuY3Rpb24gKHJlYXNvbikge1xuICAgIHZhciByZXQgPSBuZXcgUHJvbWlzZShJTlRFUk5BTCk7XG4gICAgcmV0Ll9jYXB0dXJlU3RhY2tUcmFjZSgpO1xuICAgIHJldC5fcmVqZWN0Q2FsbGJhY2socmVhc29uLCB0cnVlKTtcbiAgICByZXR1cm4gcmV0O1xufTtcblxuUHJvbWlzZS5zZXRTY2hlZHVsZXIgPSBmdW5jdGlvbihmbikge1xuICAgIGlmICh0eXBlb2YgZm4gIT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiZXhwZWN0aW5nIGEgZnVuY3Rpb24gYnV0IGdvdCBcIiArIHV0aWwuY2xhc3NTdHJpbmcoZm4pKTtcbiAgICB9XG4gICAgcmV0dXJuIGFzeW5jLnNldFNjaGVkdWxlcihmbik7XG59O1xuXG5Qcm9taXNlLnByb3RvdHlwZS5fdGhlbiA9IGZ1bmN0aW9uIChcbiAgICBkaWRGdWxmaWxsLFxuICAgIGRpZFJlamVjdCxcbiAgICBfLCAgICByZWNlaXZlcixcbiAgICBpbnRlcm5hbERhdGFcbikge1xuICAgIHZhciBoYXZlSW50ZXJuYWxEYXRhID0gaW50ZXJuYWxEYXRhICE9PSB1bmRlZmluZWQ7XG4gICAgdmFyIHByb21pc2UgPSBoYXZlSW50ZXJuYWxEYXRhID8gaW50ZXJuYWxEYXRhIDogbmV3IFByb21pc2UoSU5URVJOQUwpO1xuICAgIHZhciB0YXJnZXQgPSB0aGlzLl90YXJnZXQoKTtcbiAgICB2YXIgYml0RmllbGQgPSB0YXJnZXQuX2JpdEZpZWxkO1xuXG4gICAgaWYgKCFoYXZlSW50ZXJuYWxEYXRhKSB7XG4gICAgICAgIHByb21pc2UuX3Byb3BhZ2F0ZUZyb20odGhpcywgMyk7XG4gICAgICAgIHByb21pc2UuX2NhcHR1cmVTdGFja1RyYWNlKCk7XG4gICAgICAgIGlmIChyZWNlaXZlciA9PT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICAoKHRoaXMuX2JpdEZpZWxkICYgMjA5NzE1MikgIT09IDApKSB7XG4gICAgICAgICAgICBpZiAoISgoYml0RmllbGQgJiA1MDM5NzE4NCkgPT09IDApKSB7XG4gICAgICAgICAgICAgICAgcmVjZWl2ZXIgPSB0aGlzLl9ib3VuZFZhbHVlKCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJlY2VpdmVyID0gdGFyZ2V0ID09PSB0aGlzID8gdW5kZWZpbmVkIDogdGhpcy5fYm91bmRUbztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9maXJlRXZlbnQoXCJwcm9taXNlQ2hhaW5lZFwiLCB0aGlzLCBwcm9taXNlKTtcbiAgICB9XG5cbiAgICB2YXIgZG9tYWluID0gZ2V0RG9tYWluKCk7XG4gICAgaWYgKCEoKGJpdEZpZWxkICYgNTAzOTcxODQpID09PSAwKSkge1xuICAgICAgICB2YXIgaGFuZGxlciwgdmFsdWUsIHNldHRsZXIgPSB0YXJnZXQuX3NldHRsZVByb21pc2VDdHg7XG4gICAgICAgIGlmICgoKGJpdEZpZWxkICYgMzM1NTQ0MzIpICE9PSAwKSkge1xuICAgICAgICAgICAgdmFsdWUgPSB0YXJnZXQuX3JlamVjdGlvbkhhbmRsZXIwO1xuICAgICAgICAgICAgaGFuZGxlciA9IGRpZEZ1bGZpbGw7XG4gICAgICAgIH0gZWxzZSBpZiAoKChiaXRGaWVsZCAmIDE2Nzc3MjE2KSAhPT0gMCkpIHtcbiAgICAgICAgICAgIHZhbHVlID0gdGFyZ2V0Ll9mdWxmaWxsbWVudEhhbmRsZXIwO1xuICAgICAgICAgICAgaGFuZGxlciA9IGRpZFJlamVjdDtcbiAgICAgICAgICAgIHRhcmdldC5fdW5zZXRSZWplY3Rpb25Jc1VuaGFuZGxlZCgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc2V0dGxlciA9IHRhcmdldC5fc2V0dGxlUHJvbWlzZUxhdGVDYW5jZWxsYXRpb25PYnNlcnZlcjtcbiAgICAgICAgICAgIHZhbHVlID0gbmV3IENhbmNlbGxhdGlvbkVycm9yKFwibGF0ZSBjYW5jZWxsYXRpb24gb2JzZXJ2ZXJcIik7XG4gICAgICAgICAgICB0YXJnZXQuX2F0dGFjaEV4dHJhVHJhY2UodmFsdWUpO1xuICAgICAgICAgICAgaGFuZGxlciA9IGRpZFJlamVjdDtcbiAgICAgICAgfVxuXG4gICAgICAgIGFzeW5jLmludm9rZShzZXR0bGVyLCB0YXJnZXQsIHtcbiAgICAgICAgICAgIGhhbmRsZXI6IGRvbWFpbiA9PT0gbnVsbCA/IGhhbmRsZXJcbiAgICAgICAgICAgICAgICA6ICh0eXBlb2YgaGFuZGxlciA9PT0gXCJmdW5jdGlvblwiICYmXG4gICAgICAgICAgICAgICAgICAgIHV0aWwuZG9tYWluQmluZChkb21haW4sIGhhbmRsZXIpKSxcbiAgICAgICAgICAgIHByb21pc2U6IHByb21pc2UsXG4gICAgICAgICAgICByZWNlaXZlcjogcmVjZWl2ZXIsXG4gICAgICAgICAgICB2YWx1ZTogdmFsdWVcbiAgICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdGFyZ2V0Ll9hZGRDYWxsYmFja3MoZGlkRnVsZmlsbCwgZGlkUmVqZWN0LCBwcm9taXNlLCByZWNlaXZlciwgZG9tYWluKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcHJvbWlzZTtcbn07XG5cblByb21pc2UucHJvdG90eXBlLl9sZW5ndGggPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2JpdEZpZWxkICYgNjU1MzU7XG59O1xuXG5Qcm9taXNlLnByb3RvdHlwZS5faXNGYXRlU2VhbGVkID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiAodGhpcy5fYml0RmllbGQgJiAxMTc1MDYwNDgpICE9PSAwO1xufTtcblxuUHJvbWlzZS5wcm90b3R5cGUuX2lzRm9sbG93aW5nID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiAodGhpcy5fYml0RmllbGQgJiA2NzEwODg2NCkgPT09IDY3MTA4ODY0O1xufTtcblxuUHJvbWlzZS5wcm90b3R5cGUuX3NldExlbmd0aCA9IGZ1bmN0aW9uIChsZW4pIHtcbiAgICB0aGlzLl9iaXRGaWVsZCA9ICh0aGlzLl9iaXRGaWVsZCAmIC02NTUzNikgfFxuICAgICAgICAobGVuICYgNjU1MzUpO1xufTtcblxuUHJvbWlzZS5wcm90b3R5cGUuX3NldEZ1bGZpbGxlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLl9iaXRGaWVsZCA9IHRoaXMuX2JpdEZpZWxkIHwgMzM1NTQ0MzI7XG4gICAgdGhpcy5fZmlyZUV2ZW50KFwicHJvbWlzZUZ1bGZpbGxlZFwiLCB0aGlzKTtcbn07XG5cblByb21pc2UucHJvdG90eXBlLl9zZXRSZWplY3RlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLl9iaXRGaWVsZCA9IHRoaXMuX2JpdEZpZWxkIHwgMTY3NzcyMTY7XG4gICAgdGhpcy5fZmlyZUV2ZW50KFwicHJvbWlzZVJlamVjdGVkXCIsIHRoaXMpO1xufTtcblxuUHJvbWlzZS5wcm90b3R5cGUuX3NldEZvbGxvd2luZyA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLl9iaXRGaWVsZCA9IHRoaXMuX2JpdEZpZWxkIHwgNjcxMDg4NjQ7XG4gICAgdGhpcy5fZmlyZUV2ZW50KFwicHJvbWlzZVJlc29sdmVkXCIsIHRoaXMpO1xufTtcblxuUHJvbWlzZS5wcm90b3R5cGUuX3NldElzRmluYWwgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5fYml0RmllbGQgPSB0aGlzLl9iaXRGaWVsZCB8IDQxOTQzMDQ7XG59O1xuXG5Qcm9taXNlLnByb3RvdHlwZS5faXNGaW5hbCA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gKHRoaXMuX2JpdEZpZWxkICYgNDE5NDMwNCkgPiAwO1xufTtcblxuUHJvbWlzZS5wcm90b3R5cGUuX3Vuc2V0Q2FuY2VsbGVkID0gZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5fYml0RmllbGQgPSB0aGlzLl9iaXRGaWVsZCAmICh+NjU1MzYpO1xufTtcblxuUHJvbWlzZS5wcm90b3R5cGUuX3NldENhbmNlbGxlZCA9IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuX2JpdEZpZWxkID0gdGhpcy5fYml0RmllbGQgfCA2NTUzNjtcbiAgICB0aGlzLl9maXJlRXZlbnQoXCJwcm9taXNlQ2FuY2VsbGVkXCIsIHRoaXMpO1xufTtcblxuUHJvbWlzZS5wcm90b3R5cGUuX3NldFdpbGxCZUNhbmNlbGxlZCA9IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuX2JpdEZpZWxkID0gdGhpcy5fYml0RmllbGQgfCA4Mzg4NjA4O1xufTtcblxuUHJvbWlzZS5wcm90b3R5cGUuX3NldEFzeW5jR3VhcmFudGVlZCA9IGZ1bmN0aW9uKCkge1xuICAgIGlmIChhc3luYy5oYXNDdXN0b21TY2hlZHVsZXIoKSkgcmV0dXJuO1xuICAgIHRoaXMuX2JpdEZpZWxkID0gdGhpcy5fYml0RmllbGQgfCAxMzQyMTc3Mjg7XG59O1xuXG5Qcm9taXNlLnByb3RvdHlwZS5fcmVjZWl2ZXJBdCA9IGZ1bmN0aW9uIChpbmRleCkge1xuICAgIHZhciByZXQgPSBpbmRleCA9PT0gMCA/IHRoaXMuX3JlY2VpdmVyMCA6IHRoaXNbXG4gICAgICAgICAgICBpbmRleCAqIDQgLSA0ICsgM107XG4gICAgaWYgKHJldCA9PT0gVU5ERUZJTkVEX0JJTkRJTkcpIHtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9IGVsc2UgaWYgKHJldCA9PT0gdW5kZWZpbmVkICYmIHRoaXMuX2lzQm91bmQoKSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fYm91bmRWYWx1ZSgpO1xuICAgIH1cbiAgICByZXR1cm4gcmV0O1xufTtcblxuUHJvbWlzZS5wcm90b3R5cGUuX3Byb21pc2VBdCA9IGZ1bmN0aW9uIChpbmRleCkge1xuICAgIHJldHVybiB0aGlzW1xuICAgICAgICAgICAgaW5kZXggKiA0IC0gNCArIDJdO1xufTtcblxuUHJvbWlzZS5wcm90b3R5cGUuX2Z1bGZpbGxtZW50SGFuZGxlckF0ID0gZnVuY3Rpb24gKGluZGV4KSB7XG4gICAgcmV0dXJuIHRoaXNbXG4gICAgICAgICAgICBpbmRleCAqIDQgLSA0ICsgMF07XG59O1xuXG5Qcm9taXNlLnByb3RvdHlwZS5fcmVqZWN0aW9uSGFuZGxlckF0ID0gZnVuY3Rpb24gKGluZGV4KSB7XG4gICAgcmV0dXJuIHRoaXNbXG4gICAgICAgICAgICBpbmRleCAqIDQgLSA0ICsgMV07XG59O1xuXG5Qcm9taXNlLnByb3RvdHlwZS5fYm91bmRWYWx1ZSA9IGZ1bmN0aW9uKCkge307XG5cblByb21pc2UucHJvdG90eXBlLl9taWdyYXRlQ2FsbGJhY2swID0gZnVuY3Rpb24gKGZvbGxvd2VyKSB7XG4gICAgdmFyIGJpdEZpZWxkID0gZm9sbG93ZXIuX2JpdEZpZWxkO1xuICAgIHZhciBmdWxmaWxsID0gZm9sbG93ZXIuX2Z1bGZpbGxtZW50SGFuZGxlcjA7XG4gICAgdmFyIHJlamVjdCA9IGZvbGxvd2VyLl9yZWplY3Rpb25IYW5kbGVyMDtcbiAgICB2YXIgcHJvbWlzZSA9IGZvbGxvd2VyLl9wcm9taXNlMDtcbiAgICB2YXIgcmVjZWl2ZXIgPSBmb2xsb3dlci5fcmVjZWl2ZXJBdCgwKTtcbiAgICBpZiAocmVjZWl2ZXIgPT09IHVuZGVmaW5lZCkgcmVjZWl2ZXIgPSBVTkRFRklORURfQklORElORztcbiAgICB0aGlzLl9hZGRDYWxsYmFja3MoZnVsZmlsbCwgcmVqZWN0LCBwcm9taXNlLCByZWNlaXZlciwgbnVsbCk7XG59O1xuXG5Qcm9taXNlLnByb3RvdHlwZS5fbWlncmF0ZUNhbGxiYWNrQXQgPSBmdW5jdGlvbiAoZm9sbG93ZXIsIGluZGV4KSB7XG4gICAgdmFyIGZ1bGZpbGwgPSBmb2xsb3dlci5fZnVsZmlsbG1lbnRIYW5kbGVyQXQoaW5kZXgpO1xuICAgIHZhciByZWplY3QgPSBmb2xsb3dlci5fcmVqZWN0aW9uSGFuZGxlckF0KGluZGV4KTtcbiAgICB2YXIgcHJvbWlzZSA9IGZvbGxvd2VyLl9wcm9taXNlQXQoaW5kZXgpO1xuICAgIHZhciByZWNlaXZlciA9IGZvbGxvd2VyLl9yZWNlaXZlckF0KGluZGV4KTtcbiAgICBpZiAocmVjZWl2ZXIgPT09IHVuZGVmaW5lZCkgcmVjZWl2ZXIgPSBVTkRFRklORURfQklORElORztcbiAgICB0aGlzLl9hZGRDYWxsYmFja3MoZnVsZmlsbCwgcmVqZWN0LCBwcm9taXNlLCByZWNlaXZlciwgbnVsbCk7XG59O1xuXG5Qcm9taXNlLnByb3RvdHlwZS5fYWRkQ2FsbGJhY2tzID0gZnVuY3Rpb24gKFxuICAgIGZ1bGZpbGwsXG4gICAgcmVqZWN0LFxuICAgIHByb21pc2UsXG4gICAgcmVjZWl2ZXIsXG4gICAgZG9tYWluXG4pIHtcbiAgICB2YXIgaW5kZXggPSB0aGlzLl9sZW5ndGgoKTtcblxuICAgIGlmIChpbmRleCA+PSA2NTUzNSAtIDQpIHtcbiAgICAgICAgaW5kZXggPSAwO1xuICAgICAgICB0aGlzLl9zZXRMZW5ndGgoMCk7XG4gICAgfVxuXG4gICAgaWYgKGluZGV4ID09PSAwKSB7XG4gICAgICAgIHRoaXMuX3Byb21pc2UwID0gcHJvbWlzZTtcbiAgICAgICAgdGhpcy5fcmVjZWl2ZXIwID0gcmVjZWl2ZXI7XG4gICAgICAgIGlmICh0eXBlb2YgZnVsZmlsbCA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICB0aGlzLl9mdWxmaWxsbWVudEhhbmRsZXIwID1cbiAgICAgICAgICAgICAgICBkb21haW4gPT09IG51bGwgPyBmdWxmaWxsIDogdXRpbC5kb21haW5CaW5kKGRvbWFpbiwgZnVsZmlsbCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiByZWplY3QgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgdGhpcy5fcmVqZWN0aW9uSGFuZGxlcjAgPVxuICAgICAgICAgICAgICAgIGRvbWFpbiA9PT0gbnVsbCA/IHJlamVjdCA6IHV0aWwuZG9tYWluQmluZChkb21haW4sIHJlamVjdCk7XG4gICAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgYmFzZSA9IGluZGV4ICogNCAtIDQ7XG4gICAgICAgIHRoaXNbYmFzZSArIDJdID0gcHJvbWlzZTtcbiAgICAgICAgdGhpc1tiYXNlICsgM10gPSByZWNlaXZlcjtcbiAgICAgICAgaWYgKHR5cGVvZiBmdWxmaWxsID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgIHRoaXNbYmFzZSArIDBdID1cbiAgICAgICAgICAgICAgICBkb21haW4gPT09IG51bGwgPyBmdWxmaWxsIDogdXRpbC5kb21haW5CaW5kKGRvbWFpbiwgZnVsZmlsbCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiByZWplY3QgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgdGhpc1tiYXNlICsgMV0gPVxuICAgICAgICAgICAgICAgIGRvbWFpbiA9PT0gbnVsbCA/IHJlamVjdCA6IHV0aWwuZG9tYWluQmluZChkb21haW4sIHJlamVjdCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5fc2V0TGVuZ3RoKGluZGV4ICsgMSk7XG4gICAgcmV0dXJuIGluZGV4O1xufTtcblxuUHJvbWlzZS5wcm90b3R5cGUuX3Byb3h5ID0gZnVuY3Rpb24gKHByb3h5YWJsZSwgYXJnKSB7XG4gICAgdGhpcy5fYWRkQ2FsbGJhY2tzKHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBhcmcsIHByb3h5YWJsZSwgbnVsbCk7XG59O1xuXG5Qcm9taXNlLnByb3RvdHlwZS5fcmVzb2x2ZUNhbGxiYWNrID0gZnVuY3Rpb24odmFsdWUsIHNob3VsZEJpbmQpIHtcbiAgICBpZiAoKCh0aGlzLl9iaXRGaWVsZCAmIDExNzUwNjA0OCkgIT09IDApKSByZXR1cm47XG4gICAgaWYgKHZhbHVlID09PSB0aGlzKVxuICAgICAgICByZXR1cm4gdGhpcy5fcmVqZWN0Q2FsbGJhY2sobWFrZVNlbGZSZXNvbHV0aW9uRXJyb3IoKSwgZmFsc2UpO1xuICAgIHZhciBtYXliZVByb21pc2UgPSB0cnlDb252ZXJ0VG9Qcm9taXNlKHZhbHVlLCB0aGlzKTtcbiAgICBpZiAoIShtYXliZVByb21pc2UgaW5zdGFuY2VvZiBQcm9taXNlKSkgcmV0dXJuIHRoaXMuX2Z1bGZpbGwodmFsdWUpO1xuXG4gICAgaWYgKHNob3VsZEJpbmQpIHRoaXMuX3Byb3BhZ2F0ZUZyb20obWF5YmVQcm9taXNlLCAyKTtcblxuICAgIHZhciBwcm9taXNlID0gbWF5YmVQcm9taXNlLl90YXJnZXQoKTtcblxuICAgIGlmIChwcm9taXNlID09PSB0aGlzKSB7XG4gICAgICAgIHRoaXMuX3JlamVjdChtYWtlU2VsZlJlc29sdXRpb25FcnJvcigpKTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBiaXRGaWVsZCA9IHByb21pc2UuX2JpdEZpZWxkO1xuICAgIGlmICgoKGJpdEZpZWxkICYgNTAzOTcxODQpID09PSAwKSkge1xuICAgICAgICB2YXIgbGVuID0gdGhpcy5fbGVuZ3RoKCk7XG4gICAgICAgIGlmIChsZW4gPiAwKSBwcm9taXNlLl9taWdyYXRlQ2FsbGJhY2swKHRoaXMpO1xuICAgICAgICBmb3IgKHZhciBpID0gMTsgaSA8IGxlbjsgKytpKSB7XG4gICAgICAgICAgICBwcm9taXNlLl9taWdyYXRlQ2FsbGJhY2tBdCh0aGlzLCBpKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9zZXRGb2xsb3dpbmcoKTtcbiAgICAgICAgdGhpcy5fc2V0TGVuZ3RoKDApO1xuICAgICAgICB0aGlzLl9zZXRGb2xsb3dlZShwcm9taXNlKTtcbiAgICB9IGVsc2UgaWYgKCgoYml0RmllbGQgJiAzMzU1NDQzMikgIT09IDApKSB7XG4gICAgICAgIHRoaXMuX2Z1bGZpbGwocHJvbWlzZS5fdmFsdWUoKSk7XG4gICAgfSBlbHNlIGlmICgoKGJpdEZpZWxkICYgMTY3NzcyMTYpICE9PSAwKSkge1xuICAgICAgICB0aGlzLl9yZWplY3QocHJvbWlzZS5fcmVhc29uKCkpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciByZWFzb24gPSBuZXcgQ2FuY2VsbGF0aW9uRXJyb3IoXCJsYXRlIGNhbmNlbGxhdGlvbiBvYnNlcnZlclwiKTtcbiAgICAgICAgcHJvbWlzZS5fYXR0YWNoRXh0cmFUcmFjZShyZWFzb24pO1xuICAgICAgICB0aGlzLl9yZWplY3QocmVhc29uKTtcbiAgICB9XG59O1xuXG5Qcm9taXNlLnByb3RvdHlwZS5fcmVqZWN0Q2FsbGJhY2sgPVxuZnVuY3Rpb24ocmVhc29uLCBzeW5jaHJvbm91cywgaWdub3JlTm9uRXJyb3JXYXJuaW5ncykge1xuICAgIHZhciB0cmFjZSA9IHV0aWwuZW5zdXJlRXJyb3JPYmplY3QocmVhc29uKTtcbiAgICB2YXIgaGFzU3RhY2sgPSB0cmFjZSA9PT0gcmVhc29uO1xuICAgIGlmICghaGFzU3RhY2sgJiYgIWlnbm9yZU5vbkVycm9yV2FybmluZ3MgJiYgZGVidWcud2FybmluZ3MoKSkge1xuICAgICAgICB2YXIgbWVzc2FnZSA9IFwiYSBwcm9taXNlIHdhcyByZWplY3RlZCB3aXRoIGEgbm9uLWVycm9yOiBcIiArXG4gICAgICAgICAgICB1dGlsLmNsYXNzU3RyaW5nKHJlYXNvbik7XG4gICAgICAgIHRoaXMuX3dhcm4obWVzc2FnZSwgdHJ1ZSk7XG4gICAgfVxuICAgIHRoaXMuX2F0dGFjaEV4dHJhVHJhY2UodHJhY2UsIHN5bmNocm9ub3VzID8gaGFzU3RhY2sgOiBmYWxzZSk7XG4gICAgdGhpcy5fcmVqZWN0KHJlYXNvbik7XG59O1xuXG5Qcm9taXNlLnByb3RvdHlwZS5fcmVzb2x2ZUZyb21FeGVjdXRvciA9IGZ1bmN0aW9uIChleGVjdXRvcikge1xuICAgIGlmIChleGVjdXRvciA9PT0gSU5URVJOQUwpIHJldHVybjtcbiAgICB2YXIgcHJvbWlzZSA9IHRoaXM7XG4gICAgdGhpcy5fY2FwdHVyZVN0YWNrVHJhY2UoKTtcbiAgICB0aGlzLl9wdXNoQ29udGV4dCgpO1xuICAgIHZhciBzeW5jaHJvbm91cyA9IHRydWU7XG4gICAgdmFyIHIgPSB0aGlzLl9leGVjdXRlKGV4ZWN1dG9yLCBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICBwcm9taXNlLl9yZXNvbHZlQ2FsbGJhY2sodmFsdWUpO1xuICAgIH0sIGZ1bmN0aW9uIChyZWFzb24pIHtcbiAgICAgICAgcHJvbWlzZS5fcmVqZWN0Q2FsbGJhY2socmVhc29uLCBzeW5jaHJvbm91cyk7XG4gICAgfSk7XG4gICAgc3luY2hyb25vdXMgPSBmYWxzZTtcbiAgICB0aGlzLl9wb3BDb250ZXh0KCk7XG5cbiAgICBpZiAociAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHByb21pc2UuX3JlamVjdENhbGxiYWNrKHIsIHRydWUpO1xuICAgIH1cbn07XG5cblByb21pc2UucHJvdG90eXBlLl9zZXR0bGVQcm9taXNlRnJvbUhhbmRsZXIgPSBmdW5jdGlvbiAoXG4gICAgaGFuZGxlciwgcmVjZWl2ZXIsIHZhbHVlLCBwcm9taXNlXG4pIHtcbiAgICB2YXIgYml0RmllbGQgPSBwcm9taXNlLl9iaXRGaWVsZDtcbiAgICBpZiAoKChiaXRGaWVsZCAmIDY1NTM2KSAhPT0gMCkpIHJldHVybjtcbiAgICBwcm9taXNlLl9wdXNoQ29udGV4dCgpO1xuICAgIHZhciB4O1xuICAgIGlmIChyZWNlaXZlciA9PT0gQVBQTFkpIHtcbiAgICAgICAgaWYgKCF2YWx1ZSB8fCB0eXBlb2YgdmFsdWUubGVuZ3RoICE9PSBcIm51bWJlclwiKSB7XG4gICAgICAgICAgICB4ID0gZXJyb3JPYmo7XG4gICAgICAgICAgICB4LmUgPSBuZXcgVHlwZUVycm9yKFwiY2Fubm90IC5zcHJlYWQoKSBhIG5vbi1hcnJheTogXCIgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdXRpbC5jbGFzc1N0cmluZyh2YWx1ZSkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgeCA9IHRyeUNhdGNoKGhhbmRsZXIpLmFwcGx5KHRoaXMuX2JvdW5kVmFsdWUoKSwgdmFsdWUpO1xuICAgICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgICAgeCA9IHRyeUNhdGNoKGhhbmRsZXIpLmNhbGwocmVjZWl2ZXIsIHZhbHVlKTtcbiAgICB9XG4gICAgdmFyIHByb21pc2VDcmVhdGVkID0gcHJvbWlzZS5fcG9wQ29udGV4dCgpO1xuICAgIGJpdEZpZWxkID0gcHJvbWlzZS5fYml0RmllbGQ7XG4gICAgaWYgKCgoYml0RmllbGQgJiA2NTUzNikgIT09IDApKSByZXR1cm47XG5cbiAgICBpZiAoeCA9PT0gTkVYVF9GSUxURVIpIHtcbiAgICAgICAgcHJvbWlzZS5fcmVqZWN0KHZhbHVlKTtcbiAgICB9IGVsc2UgaWYgKHggPT09IGVycm9yT2JqKSB7XG4gICAgICAgIHByb21pc2UuX3JlamVjdENhbGxiYWNrKHguZSwgZmFsc2UpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGRlYnVnLmNoZWNrRm9yZ290dGVuUmV0dXJucyh4LCBwcm9taXNlQ3JlYXRlZCwgXCJcIiwgIHByb21pc2UsIHRoaXMpO1xuICAgICAgICBwcm9taXNlLl9yZXNvbHZlQ2FsbGJhY2soeCk7XG4gICAgfVxufTtcblxuUHJvbWlzZS5wcm90b3R5cGUuX3RhcmdldCA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciByZXQgPSB0aGlzO1xuICAgIHdoaWxlIChyZXQuX2lzRm9sbG93aW5nKCkpIHJldCA9IHJldC5fZm9sbG93ZWUoKTtcbiAgICByZXR1cm4gcmV0O1xufTtcblxuUHJvbWlzZS5wcm90b3R5cGUuX2ZvbGxvd2VlID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuX3JlamVjdGlvbkhhbmRsZXIwO1xufTtcblxuUHJvbWlzZS5wcm90b3R5cGUuX3NldEZvbGxvd2VlID0gZnVuY3Rpb24ocHJvbWlzZSkge1xuICAgIHRoaXMuX3JlamVjdGlvbkhhbmRsZXIwID0gcHJvbWlzZTtcbn07XG5cblByb21pc2UucHJvdG90eXBlLl9zZXR0bGVQcm9taXNlID0gZnVuY3Rpb24ocHJvbWlzZSwgaGFuZGxlciwgcmVjZWl2ZXIsIHZhbHVlKSB7XG4gICAgdmFyIGlzUHJvbWlzZSA9IHByb21pc2UgaW5zdGFuY2VvZiBQcm9taXNlO1xuICAgIHZhciBiaXRGaWVsZCA9IHRoaXMuX2JpdEZpZWxkO1xuICAgIHZhciBhc3luY0d1YXJhbnRlZWQgPSAoKGJpdEZpZWxkICYgMTM0MjE3NzI4KSAhPT0gMCk7XG4gICAgaWYgKCgoYml0RmllbGQgJiA2NTUzNikgIT09IDApKSB7XG4gICAgICAgIGlmIChpc1Byb21pc2UpIHByb21pc2UuX2ludm9rZUludGVybmFsT25DYW5jZWwoKTtcblxuICAgICAgICBpZiAocmVjZWl2ZXIgaW5zdGFuY2VvZiBQYXNzVGhyb3VnaEhhbmRsZXJDb250ZXh0ICYmXG4gICAgICAgICAgICByZWNlaXZlci5pc0ZpbmFsbHlIYW5kbGVyKCkpIHtcbiAgICAgICAgICAgIHJlY2VpdmVyLmNhbmNlbFByb21pc2UgPSBwcm9taXNlO1xuICAgICAgICAgICAgaWYgKHRyeUNhdGNoKGhhbmRsZXIpLmNhbGwocmVjZWl2ZXIsIHZhbHVlKSA9PT0gZXJyb3JPYmopIHtcbiAgICAgICAgICAgICAgICBwcm9taXNlLl9yZWplY3QoZXJyb3JPYmouZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoaGFuZGxlciA9PT0gcmVmbGVjdEhhbmRsZXIpIHtcbiAgICAgICAgICAgIHByb21pc2UuX2Z1bGZpbGwocmVmbGVjdEhhbmRsZXIuY2FsbChyZWNlaXZlcikpO1xuICAgICAgICB9IGVsc2UgaWYgKHJlY2VpdmVyIGluc3RhbmNlb2YgUHJveHlhYmxlKSB7XG4gICAgICAgICAgICByZWNlaXZlci5fcHJvbWlzZUNhbmNlbGxlZChwcm9taXNlKTtcbiAgICAgICAgfSBlbHNlIGlmIChpc1Byb21pc2UgfHwgcHJvbWlzZSBpbnN0YW5jZW9mIFByb21pc2VBcnJheSkge1xuICAgICAgICAgICAgcHJvbWlzZS5fY2FuY2VsKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZWNlaXZlci5jYW5jZWwoKTtcbiAgICAgICAgfVxuICAgIH0gZWxzZSBpZiAodHlwZW9mIGhhbmRsZXIgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICBpZiAoIWlzUHJvbWlzZSkge1xuICAgICAgICAgICAgaGFuZGxlci5jYWxsKHJlY2VpdmVyLCB2YWx1ZSwgcHJvbWlzZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAoYXN5bmNHdWFyYW50ZWVkKSBwcm9taXNlLl9zZXRBc3luY0d1YXJhbnRlZWQoKTtcbiAgICAgICAgICAgIHRoaXMuX3NldHRsZVByb21pc2VGcm9tSGFuZGxlcihoYW5kbGVyLCByZWNlaXZlciwgdmFsdWUsIHByb21pc2UpO1xuICAgICAgICB9XG4gICAgfSBlbHNlIGlmIChyZWNlaXZlciBpbnN0YW5jZW9mIFByb3h5YWJsZSkge1xuICAgICAgICBpZiAoIXJlY2VpdmVyLl9pc1Jlc29sdmVkKCkpIHtcbiAgICAgICAgICAgIGlmICgoKGJpdEZpZWxkICYgMzM1NTQ0MzIpICE9PSAwKSkge1xuICAgICAgICAgICAgICAgIHJlY2VpdmVyLl9wcm9taXNlRnVsZmlsbGVkKHZhbHVlLCBwcm9taXNlKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmVjZWl2ZXIuX3Byb21pc2VSZWplY3RlZCh2YWx1ZSwgcHJvbWlzZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGlzUHJvbWlzZSkge1xuICAgICAgICBpZiAoYXN5bmNHdWFyYW50ZWVkKSBwcm9taXNlLl9zZXRBc3luY0d1YXJhbnRlZWQoKTtcbiAgICAgICAgaWYgKCgoYml0RmllbGQgJiAzMzU1NDQzMikgIT09IDApKSB7XG4gICAgICAgICAgICBwcm9taXNlLl9mdWxmaWxsKHZhbHVlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHByb21pc2UuX3JlamVjdCh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICB9XG59O1xuXG5Qcm9taXNlLnByb3RvdHlwZS5fc2V0dGxlUHJvbWlzZUxhdGVDYW5jZWxsYXRpb25PYnNlcnZlciA9IGZ1bmN0aW9uKGN0eCkge1xuICAgIHZhciBoYW5kbGVyID0gY3R4LmhhbmRsZXI7XG4gICAgdmFyIHByb21pc2UgPSBjdHgucHJvbWlzZTtcbiAgICB2YXIgcmVjZWl2ZXIgPSBjdHgucmVjZWl2ZXI7XG4gICAgdmFyIHZhbHVlID0gY3R4LnZhbHVlO1xuICAgIGlmICh0eXBlb2YgaGFuZGxlciA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIGlmICghKHByb21pc2UgaW5zdGFuY2VvZiBQcm9taXNlKSkge1xuICAgICAgICAgICAgaGFuZGxlci5jYWxsKHJlY2VpdmVyLCB2YWx1ZSwgcHJvbWlzZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl9zZXR0bGVQcm9taXNlRnJvbUhhbmRsZXIoaGFuZGxlciwgcmVjZWl2ZXIsIHZhbHVlLCBwcm9taXNlKTtcbiAgICAgICAgfVxuICAgIH0gZWxzZSBpZiAocHJvbWlzZSBpbnN0YW5jZW9mIFByb21pc2UpIHtcbiAgICAgICAgcHJvbWlzZS5fcmVqZWN0KHZhbHVlKTtcbiAgICB9XG59O1xuXG5Qcm9taXNlLnByb3RvdHlwZS5fc2V0dGxlUHJvbWlzZUN0eCA9IGZ1bmN0aW9uKGN0eCkge1xuICAgIHRoaXMuX3NldHRsZVByb21pc2UoY3R4LnByb21pc2UsIGN0eC5oYW5kbGVyLCBjdHgucmVjZWl2ZXIsIGN0eC52YWx1ZSk7XG59O1xuXG5Qcm9taXNlLnByb3RvdHlwZS5fc2V0dGxlUHJvbWlzZTAgPSBmdW5jdGlvbihoYW5kbGVyLCB2YWx1ZSwgYml0RmllbGQpIHtcbiAgICB2YXIgcHJvbWlzZSA9IHRoaXMuX3Byb21pc2UwO1xuICAgIHZhciByZWNlaXZlciA9IHRoaXMuX3JlY2VpdmVyQXQoMCk7XG4gICAgdGhpcy5fcHJvbWlzZTAgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5fcmVjZWl2ZXIwID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuX3NldHRsZVByb21pc2UocHJvbWlzZSwgaGFuZGxlciwgcmVjZWl2ZXIsIHZhbHVlKTtcbn07XG5cblByb21pc2UucHJvdG90eXBlLl9jbGVhckNhbGxiYWNrRGF0YUF0SW5kZXggPSBmdW5jdGlvbihpbmRleCkge1xuICAgIHZhciBiYXNlID0gaW5kZXggKiA0IC0gNDtcbiAgICB0aGlzW2Jhc2UgKyAyXSA9XG4gICAgdGhpc1tiYXNlICsgM10gPVxuICAgIHRoaXNbYmFzZSArIDBdID1cbiAgICB0aGlzW2Jhc2UgKyAxXSA9IHVuZGVmaW5lZDtcbn07XG5cblByb21pc2UucHJvdG90eXBlLl9mdWxmaWxsID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgdmFyIGJpdEZpZWxkID0gdGhpcy5fYml0RmllbGQ7XG4gICAgaWYgKCgoYml0RmllbGQgJiAxMTc1MDYwNDgpID4+PiAxNikpIHJldHVybjtcbiAgICBpZiAodmFsdWUgPT09IHRoaXMpIHtcbiAgICAgICAgdmFyIGVyciA9IG1ha2VTZWxmUmVzb2x1dGlvbkVycm9yKCk7XG4gICAgICAgIHRoaXMuX2F0dGFjaEV4dHJhVHJhY2UoZXJyKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3JlamVjdChlcnIpO1xuICAgIH1cbiAgICB0aGlzLl9zZXRGdWxmaWxsZWQoKTtcbiAgICB0aGlzLl9yZWplY3Rpb25IYW5kbGVyMCA9IHZhbHVlO1xuXG4gICAgaWYgKChiaXRGaWVsZCAmIDY1NTM1KSA+IDApIHtcbiAgICAgICAgaWYgKCgoYml0RmllbGQgJiAxMzQyMTc3MjgpICE9PSAwKSkge1xuICAgICAgICAgICAgdGhpcy5fc2V0dGxlUHJvbWlzZXMoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGFzeW5jLnNldHRsZVByb21pc2VzKHRoaXMpO1xuICAgICAgICB9XG4gICAgfVxufTtcblxuUHJvbWlzZS5wcm90b3R5cGUuX3JlamVjdCA9IGZ1bmN0aW9uIChyZWFzb24pIHtcbiAgICB2YXIgYml0RmllbGQgPSB0aGlzLl9iaXRGaWVsZDtcbiAgICBpZiAoKChiaXRGaWVsZCAmIDExNzUwNjA0OCkgPj4+IDE2KSkgcmV0dXJuO1xuICAgIHRoaXMuX3NldFJlamVjdGVkKCk7XG4gICAgdGhpcy5fZnVsZmlsbG1lbnRIYW5kbGVyMCA9IHJlYXNvbjtcblxuICAgIGlmICh0aGlzLl9pc0ZpbmFsKCkpIHtcbiAgICAgICAgcmV0dXJuIGFzeW5jLmZhdGFsRXJyb3IocmVhc29uLCB1dGlsLmlzTm9kZSk7XG4gICAgfVxuXG4gICAgaWYgKChiaXRGaWVsZCAmIDY1NTM1KSA+IDApIHtcbiAgICAgICAgYXN5bmMuc2V0dGxlUHJvbWlzZXModGhpcyk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5fZW5zdXJlUG9zc2libGVSZWplY3Rpb25IYW5kbGVkKCk7XG4gICAgfVxufTtcblxuUHJvbWlzZS5wcm90b3R5cGUuX2Z1bGZpbGxQcm9taXNlcyA9IGZ1bmN0aW9uIChsZW4sIHZhbHVlKSB7XG4gICAgZm9yICh2YXIgaSA9IDE7IGkgPCBsZW47IGkrKykge1xuICAgICAgICB2YXIgaGFuZGxlciA9IHRoaXMuX2Z1bGZpbGxtZW50SGFuZGxlckF0KGkpO1xuICAgICAgICB2YXIgcHJvbWlzZSA9IHRoaXMuX3Byb21pc2VBdChpKTtcbiAgICAgICAgdmFyIHJlY2VpdmVyID0gdGhpcy5fcmVjZWl2ZXJBdChpKTtcbiAgICAgICAgdGhpcy5fY2xlYXJDYWxsYmFja0RhdGFBdEluZGV4KGkpO1xuICAgICAgICB0aGlzLl9zZXR0bGVQcm9taXNlKHByb21pc2UsIGhhbmRsZXIsIHJlY2VpdmVyLCB2YWx1ZSk7XG4gICAgfVxufTtcblxuUHJvbWlzZS5wcm90b3R5cGUuX3JlamVjdFByb21pc2VzID0gZnVuY3Rpb24gKGxlbiwgcmVhc29uKSB7XG4gICAgZm9yICh2YXIgaSA9IDE7IGkgPCBsZW47IGkrKykge1xuICAgICAgICB2YXIgaGFuZGxlciA9IHRoaXMuX3JlamVjdGlvbkhhbmRsZXJBdChpKTtcbiAgICAgICAgdmFyIHByb21pc2UgPSB0aGlzLl9wcm9taXNlQXQoaSk7XG4gICAgICAgIHZhciByZWNlaXZlciA9IHRoaXMuX3JlY2VpdmVyQXQoaSk7XG4gICAgICAgIHRoaXMuX2NsZWFyQ2FsbGJhY2tEYXRhQXRJbmRleChpKTtcbiAgICAgICAgdGhpcy5fc2V0dGxlUHJvbWlzZShwcm9taXNlLCBoYW5kbGVyLCByZWNlaXZlciwgcmVhc29uKTtcbiAgICB9XG59O1xuXG5Qcm9taXNlLnByb3RvdHlwZS5fc2V0dGxlUHJvbWlzZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGJpdEZpZWxkID0gdGhpcy5fYml0RmllbGQ7XG4gICAgdmFyIGxlbiA9IChiaXRGaWVsZCAmIDY1NTM1KTtcblxuICAgIGlmIChsZW4gPiAwKSB7XG4gICAgICAgIGlmICgoKGJpdEZpZWxkICYgMTY4NDI3NTIpICE9PSAwKSkge1xuICAgICAgICAgICAgdmFyIHJlYXNvbiA9IHRoaXMuX2Z1bGZpbGxtZW50SGFuZGxlcjA7XG4gICAgICAgICAgICB0aGlzLl9zZXR0bGVQcm9taXNlMCh0aGlzLl9yZWplY3Rpb25IYW5kbGVyMCwgcmVhc29uLCBiaXRGaWVsZCk7XG4gICAgICAgICAgICB0aGlzLl9yZWplY3RQcm9taXNlcyhsZW4sIHJlYXNvbik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YXIgdmFsdWUgPSB0aGlzLl9yZWplY3Rpb25IYW5kbGVyMDtcbiAgICAgICAgICAgIHRoaXMuX3NldHRsZVByb21pc2UwKHRoaXMuX2Z1bGZpbGxtZW50SGFuZGxlcjAsIHZhbHVlLCBiaXRGaWVsZCk7XG4gICAgICAgICAgICB0aGlzLl9mdWxmaWxsUHJvbWlzZXMobGVuLCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fc2V0TGVuZ3RoKDApO1xuICAgIH1cbiAgICB0aGlzLl9jbGVhckNhbmNlbGxhdGlvbkRhdGEoKTtcbn07XG5cblByb21pc2UucHJvdG90eXBlLl9zZXR0bGVkVmFsdWUgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgYml0RmllbGQgPSB0aGlzLl9iaXRGaWVsZDtcbiAgICBpZiAoKChiaXRGaWVsZCAmIDMzNTU0NDMyKSAhPT0gMCkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3JlamVjdGlvbkhhbmRsZXIwO1xuICAgIH0gZWxzZSBpZiAoKChiaXRGaWVsZCAmIDE2Nzc3MjE2KSAhPT0gMCkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2Z1bGZpbGxtZW50SGFuZGxlcjA7XG4gICAgfVxufTtcblxuZnVuY3Rpb24gZGVmZXJSZXNvbHZlKHYpIHt0aGlzLnByb21pc2UuX3Jlc29sdmVDYWxsYmFjayh2KTt9XG5mdW5jdGlvbiBkZWZlclJlamVjdCh2KSB7dGhpcy5wcm9taXNlLl9yZWplY3RDYWxsYmFjayh2LCBmYWxzZSk7fVxuXG5Qcm9taXNlLmRlZmVyID0gUHJvbWlzZS5wZW5kaW5nID0gZnVuY3Rpb24oKSB7XG4gICAgZGVidWcuZGVwcmVjYXRlZChcIlByb21pc2UuZGVmZXJcIiwgXCJuZXcgUHJvbWlzZVwiKTtcbiAgICB2YXIgcHJvbWlzZSA9IG5ldyBQcm9taXNlKElOVEVSTkFMKTtcbiAgICByZXR1cm4ge1xuICAgICAgICBwcm9taXNlOiBwcm9taXNlLFxuICAgICAgICByZXNvbHZlOiBkZWZlclJlc29sdmUsXG4gICAgICAgIHJlamVjdDogZGVmZXJSZWplY3RcbiAgICB9O1xufTtcblxudXRpbC5ub3RFbnVtZXJhYmxlUHJvcChQcm9taXNlLFxuICAgICAgICAgICAgICAgICAgICAgICBcIl9tYWtlU2VsZlJlc29sdXRpb25FcnJvclwiLFxuICAgICAgICAgICAgICAgICAgICAgICBtYWtlU2VsZlJlc29sdXRpb25FcnJvcik7XG5cbnJlcXVpcmUoXCIuL21ldGhvZFwiKShQcm9taXNlLCBJTlRFUk5BTCwgdHJ5Q29udmVydFRvUHJvbWlzZSwgYXBpUmVqZWN0aW9uLFxuICAgIGRlYnVnKTtcbnJlcXVpcmUoXCIuL2JpbmRcIikoUHJvbWlzZSwgSU5URVJOQUwsIHRyeUNvbnZlcnRUb1Byb21pc2UsIGRlYnVnKTtcbnJlcXVpcmUoXCIuL2NhbmNlbFwiKShQcm9taXNlLCBQcm9taXNlQXJyYXksIGFwaVJlamVjdGlvbiwgZGVidWcpO1xucmVxdWlyZShcIi4vZGlyZWN0X3Jlc29sdmVcIikoUHJvbWlzZSk7XG5yZXF1aXJlKFwiLi9zeW5jaHJvbm91c19pbnNwZWN0aW9uXCIpKFByb21pc2UpO1xucmVxdWlyZShcIi4vam9pblwiKShcbiAgICBQcm9taXNlLCBQcm9taXNlQXJyYXksIHRyeUNvbnZlcnRUb1Byb21pc2UsIElOVEVSTkFMLCBhc3luYywgZ2V0RG9tYWluKTtcblByb21pc2UuUHJvbWlzZSA9IFByb21pc2U7XG5Qcm9taXNlLnZlcnNpb24gPSBcIjMuNS4xXCI7XG5yZXF1aXJlKCcuL21hcC5qcycpKFByb21pc2UsIFByb21pc2VBcnJheSwgYXBpUmVqZWN0aW9uLCB0cnlDb252ZXJ0VG9Qcm9taXNlLCBJTlRFUk5BTCwgZGVidWcpO1xucmVxdWlyZSgnLi9jYWxsX2dldC5qcycpKFByb21pc2UpO1xucmVxdWlyZSgnLi91c2luZy5qcycpKFByb21pc2UsIGFwaVJlamVjdGlvbiwgdHJ5Q29udmVydFRvUHJvbWlzZSwgY3JlYXRlQ29udGV4dCwgSU5URVJOQUwsIGRlYnVnKTtcbnJlcXVpcmUoJy4vdGltZXJzLmpzJykoUHJvbWlzZSwgSU5URVJOQUwsIGRlYnVnKTtcbnJlcXVpcmUoJy4vZ2VuZXJhdG9ycy5qcycpKFByb21pc2UsIGFwaVJlamVjdGlvbiwgSU5URVJOQUwsIHRyeUNvbnZlcnRUb1Byb21pc2UsIFByb3h5YWJsZSwgZGVidWcpO1xucmVxdWlyZSgnLi9ub2RlaWZ5LmpzJykoUHJvbWlzZSk7XG5yZXF1aXJlKCcuL3Byb21pc2lmeS5qcycpKFByb21pc2UsIElOVEVSTkFMKTtcbnJlcXVpcmUoJy4vcHJvcHMuanMnKShQcm9taXNlLCBQcm9taXNlQXJyYXksIHRyeUNvbnZlcnRUb1Byb21pc2UsIGFwaVJlamVjdGlvbik7XG5yZXF1aXJlKCcuL3JhY2UuanMnKShQcm9taXNlLCBJTlRFUk5BTCwgdHJ5Q29udmVydFRvUHJvbWlzZSwgYXBpUmVqZWN0aW9uKTtcbnJlcXVpcmUoJy4vcmVkdWNlLmpzJykoUHJvbWlzZSwgUHJvbWlzZUFycmF5LCBhcGlSZWplY3Rpb24sIHRyeUNvbnZlcnRUb1Byb21pc2UsIElOVEVSTkFMLCBkZWJ1Zyk7XG5yZXF1aXJlKCcuL3NldHRsZS5qcycpKFByb21pc2UsIFByb21pc2VBcnJheSwgZGVidWcpO1xucmVxdWlyZSgnLi9zb21lLmpzJykoUHJvbWlzZSwgUHJvbWlzZUFycmF5LCBhcGlSZWplY3Rpb24pO1xucmVxdWlyZSgnLi9maWx0ZXIuanMnKShQcm9taXNlLCBJTlRFUk5BTCk7XG5yZXF1aXJlKCcuL2VhY2guanMnKShQcm9taXNlLCBJTlRFUk5BTCk7XG5yZXF1aXJlKCcuL2FueS5qcycpKFByb21pc2UpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgdXRpbC50b0Zhc3RQcm9wZXJ0aWVzKFByb21pc2UpOyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgIHV0aWwudG9GYXN0UHJvcGVydGllcyhQcm9taXNlLnByb3RvdHlwZSk7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcbiAgICBmdW5jdGlvbiBmaWxsVHlwZXModmFsdWUpIHsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgIHZhciBwID0gbmV3IFByb21pc2UoSU5URVJOQUwpOyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICBwLl9mdWxmaWxsbWVudEhhbmRsZXIwID0gdmFsdWU7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgcC5fcmVqZWN0aW9uSGFuZGxlcjAgPSB2YWx1ZTsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgIHAuX3Byb21pc2UwID0gdmFsdWU7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICBwLl9yZWNlaXZlcjAgPSB2YWx1ZTsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcbiAgICB9ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgLy8gQ29tcGxldGUgc2xhY2sgdHJhY2tpbmcsIG9wdCBvdXQgb2YgZmllbGQtdHlwZSB0cmFja2luZyBhbmQgICAgICAgICAgIFxuICAgIC8vIHN0YWJpbGl6ZSBtYXAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcbiAgICBmaWxsVHlwZXMoe2E6IDF9KTsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgZmlsbFR5cGVzKHtiOiAyfSk7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgIGZpbGxUeXBlcyh7YzogM30pOyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcbiAgICBmaWxsVHlwZXMoMSk7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgZmlsbFR5cGVzKGZ1bmN0aW9uKCl7fSk7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgIGZpbGxUeXBlcyh1bmRlZmluZWQpOyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcbiAgICBmaWxsVHlwZXMoZmFsc2UpOyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgZmlsbFR5cGVzKG5ldyBQcm9taXNlKElOVEVSTkFMKSk7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgIGRlYnVnLnNldEJvdW5kcyhBc3luYy5maXJzdExpbmVFcnJvciwgdXRpbC5sYXN0TGluZUVycm9yKTsgICAgICAgICAgICAgICBcbiAgICByZXR1cm4gUHJvbWlzZTsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXG5cbn07XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvYmx1ZWJpcmQvanMvcmVsZWFzZS9wcm9taXNlLmpzIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgZmlyc3RMaW5lRXJyb3I7XG50cnkge3Rocm93IG5ldyBFcnJvcigpOyB9IGNhdGNoIChlKSB7Zmlyc3RMaW5lRXJyb3IgPSBlO31cbnZhciBzY2hlZHVsZSA9IHJlcXVpcmUoXCIuL3NjaGVkdWxlXCIpO1xudmFyIFF1ZXVlID0gcmVxdWlyZShcIi4vcXVldWVcIik7XG52YXIgdXRpbCA9IHJlcXVpcmUoXCIuL3V0aWxcIik7XG5cbmZ1bmN0aW9uIEFzeW5jKCkge1xuICAgIHRoaXMuX2N1c3RvbVNjaGVkdWxlciA9IGZhbHNlO1xuICAgIHRoaXMuX2lzVGlja1VzZWQgPSBmYWxzZTtcbiAgICB0aGlzLl9sYXRlUXVldWUgPSBuZXcgUXVldWUoMTYpO1xuICAgIHRoaXMuX25vcm1hbFF1ZXVlID0gbmV3IFF1ZXVlKDE2KTtcbiAgICB0aGlzLl9oYXZlRHJhaW5lZFF1ZXVlcyA9IGZhbHNlO1xuICAgIHRoaXMuX3RyYW1wb2xpbmVFbmFibGVkID0gdHJ1ZTtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgdGhpcy5kcmFpblF1ZXVlcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgc2VsZi5fZHJhaW5RdWV1ZXMoKTtcbiAgICB9O1xuICAgIHRoaXMuX3NjaGVkdWxlID0gc2NoZWR1bGU7XG59XG5cbkFzeW5jLnByb3RvdHlwZS5zZXRTY2hlZHVsZXIgPSBmdW5jdGlvbihmbikge1xuICAgIHZhciBwcmV2ID0gdGhpcy5fc2NoZWR1bGU7XG4gICAgdGhpcy5fc2NoZWR1bGUgPSBmbjtcbiAgICB0aGlzLl9jdXN0b21TY2hlZHVsZXIgPSB0cnVlO1xuICAgIHJldHVybiBwcmV2O1xufTtcblxuQXN5bmMucHJvdG90eXBlLmhhc0N1c3RvbVNjaGVkdWxlciA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLl9jdXN0b21TY2hlZHVsZXI7XG59O1xuXG5Bc3luYy5wcm90b3R5cGUuZW5hYmxlVHJhbXBvbGluZSA9IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuX3RyYW1wb2xpbmVFbmFibGVkID0gdHJ1ZTtcbn07XG5cbkFzeW5jLnByb3RvdHlwZS5kaXNhYmxlVHJhbXBvbGluZUlmTmVjZXNzYXJ5ID0gZnVuY3Rpb24oKSB7XG4gICAgaWYgKHV0aWwuaGFzRGV2VG9vbHMpIHtcbiAgICAgICAgdGhpcy5fdHJhbXBvbGluZUVuYWJsZWQgPSBmYWxzZTtcbiAgICB9XG59O1xuXG5Bc3luYy5wcm90b3R5cGUuaGF2ZUl0ZW1zUXVldWVkID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLl9pc1RpY2tVc2VkIHx8IHRoaXMuX2hhdmVEcmFpbmVkUXVldWVzO1xufTtcblxuXG5Bc3luYy5wcm90b3R5cGUuZmF0YWxFcnJvciA9IGZ1bmN0aW9uKGUsIGlzTm9kZSkge1xuICAgIGlmIChpc05vZGUpIHtcbiAgICAgICAgcHJvY2Vzcy5zdGRlcnIud3JpdGUoXCJGYXRhbCBcIiArIChlIGluc3RhbmNlb2YgRXJyb3IgPyBlLnN0YWNrIDogZSkgK1xuICAgICAgICAgICAgXCJcXG5cIik7XG4gICAgICAgIHByb2Nlc3MuZXhpdCgyKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnRocm93TGF0ZXIoZSk7XG4gICAgfVxufTtcblxuQXN5bmMucHJvdG90eXBlLnRocm93TGF0ZXIgPSBmdW5jdGlvbihmbiwgYXJnKSB7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgYXJnID0gZm47XG4gICAgICAgIGZuID0gZnVuY3Rpb24gKCkgeyB0aHJvdyBhcmc7IH07XG4gICAgfVxuICAgIGlmICh0eXBlb2Ygc2V0VGltZW91dCAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgZm4oYXJnKTtcbiAgICAgICAgfSwgMCk7XG4gICAgfSBlbHNlIHRyeSB7XG4gICAgICAgIHRoaXMuX3NjaGVkdWxlKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgZm4oYXJnKTtcbiAgICAgICAgfSk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJObyBhc3luYyBzY2hlZHVsZXIgYXZhaWxhYmxlXFx1MDAwYVxcdTAwMGEgICAgU2VlIGh0dHA6Ly9nb28uZ2wvTXFyRm1YXFx1MDAwYVwiKTtcbiAgICB9XG59O1xuXG5mdW5jdGlvbiBBc3luY0ludm9rZUxhdGVyKGZuLCByZWNlaXZlciwgYXJnKSB7XG4gICAgdGhpcy5fbGF0ZVF1ZXVlLnB1c2goZm4sIHJlY2VpdmVyLCBhcmcpO1xuICAgIHRoaXMuX3F1ZXVlVGljaygpO1xufVxuXG5mdW5jdGlvbiBBc3luY0ludm9rZShmbiwgcmVjZWl2ZXIsIGFyZykge1xuICAgIHRoaXMuX25vcm1hbFF1ZXVlLnB1c2goZm4sIHJlY2VpdmVyLCBhcmcpO1xuICAgIHRoaXMuX3F1ZXVlVGljaygpO1xufVxuXG5mdW5jdGlvbiBBc3luY1NldHRsZVByb21pc2VzKHByb21pc2UpIHtcbiAgICB0aGlzLl9ub3JtYWxRdWV1ZS5fcHVzaE9uZShwcm9taXNlKTtcbiAgICB0aGlzLl9xdWV1ZVRpY2soKTtcbn1cblxuaWYgKCF1dGlsLmhhc0RldlRvb2xzKSB7XG4gICAgQXN5bmMucHJvdG90eXBlLmludm9rZUxhdGVyID0gQXN5bmNJbnZva2VMYXRlcjtcbiAgICBBc3luYy5wcm90b3R5cGUuaW52b2tlID0gQXN5bmNJbnZva2U7XG4gICAgQXN5bmMucHJvdG90eXBlLnNldHRsZVByb21pc2VzID0gQXN5bmNTZXR0bGVQcm9taXNlcztcbn0gZWxzZSB7XG4gICAgQXN5bmMucHJvdG90eXBlLmludm9rZUxhdGVyID0gZnVuY3Rpb24gKGZuLCByZWNlaXZlciwgYXJnKSB7XG4gICAgICAgIGlmICh0aGlzLl90cmFtcG9saW5lRW5hYmxlZCkge1xuICAgICAgICAgICAgQXN5bmNJbnZva2VMYXRlci5jYWxsKHRoaXMsIGZuLCByZWNlaXZlciwgYXJnKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX3NjaGVkdWxlKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIGZuLmNhbGwocmVjZWl2ZXIsIGFyZyk7XG4gICAgICAgICAgICAgICAgfSwgMTAwKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIEFzeW5jLnByb3RvdHlwZS5pbnZva2UgPSBmdW5jdGlvbiAoZm4sIHJlY2VpdmVyLCBhcmcpIHtcbiAgICAgICAgaWYgKHRoaXMuX3RyYW1wb2xpbmVFbmFibGVkKSB7XG4gICAgICAgICAgICBBc3luY0ludm9rZS5jYWxsKHRoaXMsIGZuLCByZWNlaXZlciwgYXJnKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX3NjaGVkdWxlKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIGZuLmNhbGwocmVjZWl2ZXIsIGFyZyk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBBc3luYy5wcm90b3R5cGUuc2V0dGxlUHJvbWlzZXMgPSBmdW5jdGlvbihwcm9taXNlKSB7XG4gICAgICAgIGlmICh0aGlzLl90cmFtcG9saW5lRW5hYmxlZCkge1xuICAgICAgICAgICAgQXN5bmNTZXR0bGVQcm9taXNlcy5jYWxsKHRoaXMsIHByb21pc2UpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5fc2NoZWR1bGUoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgcHJvbWlzZS5fc2V0dGxlUHJvbWlzZXMoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfTtcbn1cblxuQXN5bmMucHJvdG90eXBlLl9kcmFpblF1ZXVlID0gZnVuY3Rpb24ocXVldWUpIHtcbiAgICB3aGlsZSAocXVldWUubGVuZ3RoKCkgPiAwKSB7XG4gICAgICAgIHZhciBmbiA9IHF1ZXVlLnNoaWZ0KCk7XG4gICAgICAgIGlmICh0eXBlb2YgZm4gIT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgZm4uX3NldHRsZVByb21pc2VzKCk7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgcmVjZWl2ZXIgPSBxdWV1ZS5zaGlmdCgpO1xuICAgICAgICB2YXIgYXJnID0gcXVldWUuc2hpZnQoKTtcbiAgICAgICAgZm4uY2FsbChyZWNlaXZlciwgYXJnKTtcbiAgICB9XG59O1xuXG5Bc3luYy5wcm90b3R5cGUuX2RyYWluUXVldWVzID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuX2RyYWluUXVldWUodGhpcy5fbm9ybWFsUXVldWUpO1xuICAgIHRoaXMuX3Jlc2V0KCk7XG4gICAgdGhpcy5faGF2ZURyYWluZWRRdWV1ZXMgPSB0cnVlO1xuICAgIHRoaXMuX2RyYWluUXVldWUodGhpcy5fbGF0ZVF1ZXVlKTtcbn07XG5cbkFzeW5jLnByb3RvdHlwZS5fcXVldWVUaWNrID0gZnVuY3Rpb24gKCkge1xuICAgIGlmICghdGhpcy5faXNUaWNrVXNlZCkge1xuICAgICAgICB0aGlzLl9pc1RpY2tVc2VkID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5fc2NoZWR1bGUodGhpcy5kcmFpblF1ZXVlcyk7XG4gICAgfVxufTtcblxuQXN5bmMucHJvdG90eXBlLl9yZXNldCA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLl9pc1RpY2tVc2VkID0gZmFsc2U7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEFzeW5jO1xubW9kdWxlLmV4cG9ydHMuZmlyc3RMaW5lRXJyb3IgPSBmaXJzdExpbmVFcnJvcjtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9ibHVlYmlyZC9qcy9yZWxlYXNlL2FzeW5jLmpzIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgdXRpbCA9IHJlcXVpcmUoXCIuL3V0aWxcIik7XG52YXIgc2NoZWR1bGU7XG52YXIgbm9Bc3luY1NjaGVkdWxlciA9IGZ1bmN0aW9uKCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIk5vIGFzeW5jIHNjaGVkdWxlciBhdmFpbGFibGVcXHUwMDBhXFx1MDAwYSAgICBTZWUgaHR0cDovL2dvby5nbC9NcXJGbVhcXHUwMDBhXCIpO1xufTtcbnZhciBOYXRpdmVQcm9taXNlID0gdXRpbC5nZXROYXRpdmVQcm9taXNlKCk7XG5pZiAodXRpbC5pc05vZGUgJiYgdHlwZW9mIE11dGF0aW9uT2JzZXJ2ZXIgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICB2YXIgR2xvYmFsU2V0SW1tZWRpYXRlID0gZ2xvYmFsLnNldEltbWVkaWF0ZTtcbiAgICB2YXIgUHJvY2Vzc05leHRUaWNrID0gcHJvY2Vzcy5uZXh0VGljaztcbiAgICBzY2hlZHVsZSA9IHV0aWwuaXNSZWNlbnROb2RlXG4gICAgICAgICAgICAgICAgPyBmdW5jdGlvbihmbikgeyBHbG9iYWxTZXRJbW1lZGlhdGUuY2FsbChnbG9iYWwsIGZuKTsgfVxuICAgICAgICAgICAgICAgIDogZnVuY3Rpb24oZm4pIHsgUHJvY2Vzc05leHRUaWNrLmNhbGwocHJvY2VzcywgZm4pOyB9O1xufSBlbHNlIGlmICh0eXBlb2YgTmF0aXZlUHJvbWlzZSA9PT0gXCJmdW5jdGlvblwiICYmXG4gICAgICAgICAgIHR5cGVvZiBOYXRpdmVQcm9taXNlLnJlc29sdmUgPT09IFwiZnVuY3Rpb25cIikge1xuICAgIHZhciBuYXRpdmVQcm9taXNlID0gTmF0aXZlUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgc2NoZWR1bGUgPSBmdW5jdGlvbihmbikge1xuICAgICAgICBuYXRpdmVQcm9taXNlLnRoZW4oZm4pO1xuICAgIH07XG59IGVsc2UgaWYgKCh0eXBlb2YgTXV0YXRpb25PYnNlcnZlciAhPT0gXCJ1bmRlZmluZWRcIikgJiZcbiAgICAgICAgICAhKHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgJiZcbiAgICAgICAgICAgIHdpbmRvdy5uYXZpZ2F0b3IgJiZcbiAgICAgICAgICAgICh3aW5kb3cubmF2aWdhdG9yLnN0YW5kYWxvbmUgfHwgd2luZG93LmNvcmRvdmEpKSkge1xuICAgIHNjaGVkdWxlID0gKGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgZGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICAgICAgdmFyIG9wdHMgPSB7YXR0cmlidXRlczogdHJ1ZX07XG4gICAgICAgIHZhciB0b2dnbGVTY2hlZHVsZWQgPSBmYWxzZTtcbiAgICAgICAgdmFyIGRpdjIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgICAgICB2YXIgbzIgPSBuZXcgTXV0YXRpb25PYnNlcnZlcihmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGRpdi5jbGFzc0xpc3QudG9nZ2xlKFwiZm9vXCIpO1xuICAgICAgICAgICAgdG9nZ2xlU2NoZWR1bGVkID0gZmFsc2U7XG4gICAgICAgIH0pO1xuICAgICAgICBvMi5vYnNlcnZlKGRpdjIsIG9wdHMpO1xuXG4gICAgICAgIHZhciBzY2hlZHVsZVRvZ2dsZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgaWYgKHRvZ2dsZVNjaGVkdWxlZCkgcmV0dXJuO1xuICAgICAgICAgICAgdG9nZ2xlU2NoZWR1bGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIGRpdjIuY2xhc3NMaXN0LnRvZ2dsZShcImZvb1wiKTtcbiAgICAgICAgfTtcblxuICAgICAgICByZXR1cm4gZnVuY3Rpb24gc2NoZWR1bGUoZm4pIHtcbiAgICAgICAgICAgIHZhciBvID0gbmV3IE11dGF0aW9uT2JzZXJ2ZXIoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgby5kaXNjb25uZWN0KCk7XG4gICAgICAgICAgICAgICAgZm4oKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgby5vYnNlcnZlKGRpdiwgb3B0cyk7XG4gICAgICAgICAgICBzY2hlZHVsZVRvZ2dsZSgpO1xuICAgICAgICB9O1xuICAgIH0pKCk7XG59IGVsc2UgaWYgKHR5cGVvZiBzZXRJbW1lZGlhdGUgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICBzY2hlZHVsZSA9IGZ1bmN0aW9uIChmbikge1xuICAgICAgICBzZXRJbW1lZGlhdGUoZm4pO1xuICAgIH07XG59IGVsc2UgaWYgKHR5cGVvZiBzZXRUaW1lb3V0ICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgc2NoZWR1bGUgPSBmdW5jdGlvbiAoZm4pIHtcbiAgICAgICAgc2V0VGltZW91dChmbiwgMCk7XG4gICAgfTtcbn0gZWxzZSB7XG4gICAgc2NoZWR1bGUgPSBub0FzeW5jU2NoZWR1bGVyO1xufVxubW9kdWxlLmV4cG9ydHMgPSBzY2hlZHVsZTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9ibHVlYmlyZC9qcy9yZWxlYXNlL3NjaGVkdWxlLmpzIiwiXCJ1c2Ugc3RyaWN0XCI7XG5mdW5jdGlvbiBhcnJheU1vdmUoc3JjLCBzcmNJbmRleCwgZHN0LCBkc3RJbmRleCwgbGVuKSB7XG4gICAgZm9yICh2YXIgaiA9IDA7IGogPCBsZW47ICsraikge1xuICAgICAgICBkc3RbaiArIGRzdEluZGV4XSA9IHNyY1tqICsgc3JjSW5kZXhdO1xuICAgICAgICBzcmNbaiArIHNyY0luZGV4XSA9IHZvaWQgMDtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIFF1ZXVlKGNhcGFjaXR5KSB7XG4gICAgdGhpcy5fY2FwYWNpdHkgPSBjYXBhY2l0eTtcbiAgICB0aGlzLl9sZW5ndGggPSAwO1xuICAgIHRoaXMuX2Zyb250ID0gMDtcbn1cblxuUXVldWUucHJvdG90eXBlLl93aWxsQmVPdmVyQ2FwYWNpdHkgPSBmdW5jdGlvbiAoc2l6ZSkge1xuICAgIHJldHVybiB0aGlzLl9jYXBhY2l0eSA8IHNpemU7XG59O1xuXG5RdWV1ZS5wcm90b3R5cGUuX3B1c2hPbmUgPSBmdW5jdGlvbiAoYXJnKSB7XG4gICAgdmFyIGxlbmd0aCA9IHRoaXMubGVuZ3RoKCk7XG4gICAgdGhpcy5fY2hlY2tDYXBhY2l0eShsZW5ndGggKyAxKTtcbiAgICB2YXIgaSA9ICh0aGlzLl9mcm9udCArIGxlbmd0aCkgJiAodGhpcy5fY2FwYWNpdHkgLSAxKTtcbiAgICB0aGlzW2ldID0gYXJnO1xuICAgIHRoaXMuX2xlbmd0aCA9IGxlbmd0aCArIDE7XG59O1xuXG5RdWV1ZS5wcm90b3R5cGUucHVzaCA9IGZ1bmN0aW9uIChmbiwgcmVjZWl2ZXIsIGFyZykge1xuICAgIHZhciBsZW5ndGggPSB0aGlzLmxlbmd0aCgpICsgMztcbiAgICBpZiAodGhpcy5fd2lsbEJlT3ZlckNhcGFjaXR5KGxlbmd0aCkpIHtcbiAgICAgICAgdGhpcy5fcHVzaE9uZShmbik7XG4gICAgICAgIHRoaXMuX3B1c2hPbmUocmVjZWl2ZXIpO1xuICAgICAgICB0aGlzLl9wdXNoT25lKGFyZyk7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIGogPSB0aGlzLl9mcm9udCArIGxlbmd0aCAtIDM7XG4gICAgdGhpcy5fY2hlY2tDYXBhY2l0eShsZW5ndGgpO1xuICAgIHZhciB3cmFwTWFzayA9IHRoaXMuX2NhcGFjaXR5IC0gMTtcbiAgICB0aGlzWyhqICsgMCkgJiB3cmFwTWFza10gPSBmbjtcbiAgICB0aGlzWyhqICsgMSkgJiB3cmFwTWFza10gPSByZWNlaXZlcjtcbiAgICB0aGlzWyhqICsgMikgJiB3cmFwTWFza10gPSBhcmc7XG4gICAgdGhpcy5fbGVuZ3RoID0gbGVuZ3RoO1xufTtcblxuUXVldWUucHJvdG90eXBlLnNoaWZ0ID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBmcm9udCA9IHRoaXMuX2Zyb250LFxuICAgICAgICByZXQgPSB0aGlzW2Zyb250XTtcblxuICAgIHRoaXNbZnJvbnRdID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuX2Zyb250ID0gKGZyb250ICsgMSkgJiAodGhpcy5fY2FwYWNpdHkgLSAxKTtcbiAgICB0aGlzLl9sZW5ndGgtLTtcbiAgICByZXR1cm4gcmV0O1xufTtcblxuUXVldWUucHJvdG90eXBlLmxlbmd0aCA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5fbGVuZ3RoO1xufTtcblxuUXVldWUucHJvdG90eXBlLl9jaGVja0NhcGFjaXR5ID0gZnVuY3Rpb24gKHNpemUpIHtcbiAgICBpZiAodGhpcy5fY2FwYWNpdHkgPCBzaXplKSB7XG4gICAgICAgIHRoaXMuX3Jlc2l6ZVRvKHRoaXMuX2NhcGFjaXR5IDw8IDEpO1xuICAgIH1cbn07XG5cblF1ZXVlLnByb3RvdHlwZS5fcmVzaXplVG8gPSBmdW5jdGlvbiAoY2FwYWNpdHkpIHtcbiAgICB2YXIgb2xkQ2FwYWNpdHkgPSB0aGlzLl9jYXBhY2l0eTtcbiAgICB0aGlzLl9jYXBhY2l0eSA9IGNhcGFjaXR5O1xuICAgIHZhciBmcm9udCA9IHRoaXMuX2Zyb250O1xuICAgIHZhciBsZW5ndGggPSB0aGlzLl9sZW5ndGg7XG4gICAgdmFyIG1vdmVJdGVtc0NvdW50ID0gKGZyb250ICsgbGVuZ3RoKSAmIChvbGRDYXBhY2l0eSAtIDEpO1xuICAgIGFycmF5TW92ZSh0aGlzLCAwLCB0aGlzLCBvbGRDYXBhY2l0eSwgbW92ZUl0ZW1zQ291bnQpO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBRdWV1ZTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9ibHVlYmlyZC9qcy9yZWxlYXNlL3F1ZXVlLmpzIiwiXCJ1c2Ugc3RyaWN0XCI7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKFByb21pc2UsIElOVEVSTkFMKSB7XG52YXIgdXRpbCA9IHJlcXVpcmUoXCIuL3V0aWxcIik7XG52YXIgZXJyb3JPYmogPSB1dGlsLmVycm9yT2JqO1xudmFyIGlzT2JqZWN0ID0gdXRpbC5pc09iamVjdDtcblxuZnVuY3Rpb24gdHJ5Q29udmVydFRvUHJvbWlzZShvYmosIGNvbnRleHQpIHtcbiAgICBpZiAoaXNPYmplY3Qob2JqKSkge1xuICAgICAgICBpZiAob2JqIGluc3RhbmNlb2YgUHJvbWlzZSkgcmV0dXJuIG9iajtcbiAgICAgICAgdmFyIHRoZW4gPSBnZXRUaGVuKG9iaik7XG4gICAgICAgIGlmICh0aGVuID09PSBlcnJvck9iaikge1xuICAgICAgICAgICAgaWYgKGNvbnRleHQpIGNvbnRleHQuX3B1c2hDb250ZXh0KCk7XG4gICAgICAgICAgICB2YXIgcmV0ID0gUHJvbWlzZS5yZWplY3QodGhlbi5lKTtcbiAgICAgICAgICAgIGlmIChjb250ZXh0KSBjb250ZXh0Ll9wb3BDb250ZXh0KCk7XG4gICAgICAgICAgICByZXR1cm4gcmV0O1xuICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiB0aGVuID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgIGlmIChpc0FueUJsdWViaXJkUHJvbWlzZShvYmopKSB7XG4gICAgICAgICAgICAgICAgdmFyIHJldCA9IG5ldyBQcm9taXNlKElOVEVSTkFMKTtcbiAgICAgICAgICAgICAgICBvYmouX3RoZW4oXG4gICAgICAgICAgICAgICAgICAgIHJldC5fZnVsZmlsbCxcbiAgICAgICAgICAgICAgICAgICAgcmV0Ll9yZWplY3QsXG4gICAgICAgICAgICAgICAgICAgIHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICAgICAgcmV0LFxuICAgICAgICAgICAgICAgICAgICBudWxsXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmV0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGRvVGhlbmFibGUob2JqLCB0aGVuLCBjb250ZXh0KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gb2JqO1xufVxuXG5mdW5jdGlvbiBkb0dldFRoZW4ob2JqKSB7XG4gICAgcmV0dXJuIG9iai50aGVuO1xufVxuXG5mdW5jdGlvbiBnZXRUaGVuKG9iaikge1xuICAgIHRyeSB7XG4gICAgICAgIHJldHVybiBkb0dldFRoZW4ob2JqKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGVycm9yT2JqLmUgPSBlO1xuICAgICAgICByZXR1cm4gZXJyb3JPYmo7XG4gICAgfVxufVxuXG52YXIgaGFzUHJvcCA9IHt9Lmhhc093blByb3BlcnR5O1xuZnVuY3Rpb24gaXNBbnlCbHVlYmlyZFByb21pc2Uob2JqKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIGhhc1Byb3AuY2FsbChvYmosIFwiX3Byb21pc2UwXCIpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gZG9UaGVuYWJsZSh4LCB0aGVuLCBjb250ZXh0KSB7XG4gICAgdmFyIHByb21pc2UgPSBuZXcgUHJvbWlzZShJTlRFUk5BTCk7XG4gICAgdmFyIHJldCA9IHByb21pc2U7XG4gICAgaWYgKGNvbnRleHQpIGNvbnRleHQuX3B1c2hDb250ZXh0KCk7XG4gICAgcHJvbWlzZS5fY2FwdHVyZVN0YWNrVHJhY2UoKTtcbiAgICBpZiAoY29udGV4dCkgY29udGV4dC5fcG9wQ29udGV4dCgpO1xuICAgIHZhciBzeW5jaHJvbm91cyA9IHRydWU7XG4gICAgdmFyIHJlc3VsdCA9IHV0aWwudHJ5Q2F0Y2godGhlbikuY2FsbCh4LCByZXNvbHZlLCByZWplY3QpO1xuICAgIHN5bmNocm9ub3VzID0gZmFsc2U7XG5cbiAgICBpZiAocHJvbWlzZSAmJiByZXN1bHQgPT09IGVycm9yT2JqKSB7XG4gICAgICAgIHByb21pc2UuX3JlamVjdENhbGxiYWNrKHJlc3VsdC5lLCB0cnVlLCB0cnVlKTtcbiAgICAgICAgcHJvbWlzZSA9IG51bGw7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcmVzb2x2ZSh2YWx1ZSkge1xuICAgICAgICBpZiAoIXByb21pc2UpIHJldHVybjtcbiAgICAgICAgcHJvbWlzZS5fcmVzb2x2ZUNhbGxiYWNrKHZhbHVlKTtcbiAgICAgICAgcHJvbWlzZSA9IG51bGw7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcmVqZWN0KHJlYXNvbikge1xuICAgICAgICBpZiAoIXByb21pc2UpIHJldHVybjtcbiAgICAgICAgcHJvbWlzZS5fcmVqZWN0Q2FsbGJhY2socmVhc29uLCBzeW5jaHJvbm91cywgdHJ1ZSk7XG4gICAgICAgIHByb21pc2UgPSBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gcmV0O1xufVxuXG5yZXR1cm4gdHJ5Q29udmVydFRvUHJvbWlzZTtcbn07XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvYmx1ZWJpcmQvanMvcmVsZWFzZS90aGVuYWJsZXMuanMiLCJcInVzZSBzdHJpY3RcIjtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oUHJvbWlzZSwgSU5URVJOQUwsIHRyeUNvbnZlcnRUb1Byb21pc2UsXG4gICAgYXBpUmVqZWN0aW9uLCBQcm94eWFibGUpIHtcbnZhciB1dGlsID0gcmVxdWlyZShcIi4vdXRpbFwiKTtcbnZhciBpc0FycmF5ID0gdXRpbC5pc0FycmF5O1xuXG5mdW5jdGlvbiB0b1Jlc29sdXRpb25WYWx1ZSh2YWwpIHtcbiAgICBzd2l0Y2godmFsKSB7XG4gICAgY2FzZSAtMjogcmV0dXJuIFtdO1xuICAgIGNhc2UgLTM6IHJldHVybiB7fTtcbiAgICBjYXNlIC02OiByZXR1cm4gbmV3IE1hcCgpO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gUHJvbWlzZUFycmF5KHZhbHVlcykge1xuICAgIHZhciBwcm9taXNlID0gdGhpcy5fcHJvbWlzZSA9IG5ldyBQcm9taXNlKElOVEVSTkFMKTtcbiAgICBpZiAodmFsdWVzIGluc3RhbmNlb2YgUHJvbWlzZSkge1xuICAgICAgICBwcm9taXNlLl9wcm9wYWdhdGVGcm9tKHZhbHVlcywgMyk7XG4gICAgfVxuICAgIHByb21pc2UuX3NldE9uQ2FuY2VsKHRoaXMpO1xuICAgIHRoaXMuX3ZhbHVlcyA9IHZhbHVlcztcbiAgICB0aGlzLl9sZW5ndGggPSAwO1xuICAgIHRoaXMuX3RvdGFsUmVzb2x2ZWQgPSAwO1xuICAgIHRoaXMuX2luaXQodW5kZWZpbmVkLCAtMik7XG59XG51dGlsLmluaGVyaXRzKFByb21pc2VBcnJheSwgUHJveHlhYmxlKTtcblxuUHJvbWlzZUFycmF5LnByb3RvdHlwZS5sZW5ndGggPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2xlbmd0aDtcbn07XG5cblByb21pc2VBcnJheS5wcm90b3R5cGUucHJvbWlzZSA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5fcHJvbWlzZTtcbn07XG5cblByb21pc2VBcnJheS5wcm90b3R5cGUuX2luaXQgPSBmdW5jdGlvbiBpbml0KF8sIHJlc29sdmVWYWx1ZUlmRW1wdHkpIHtcbiAgICB2YXIgdmFsdWVzID0gdHJ5Q29udmVydFRvUHJvbWlzZSh0aGlzLl92YWx1ZXMsIHRoaXMuX3Byb21pc2UpO1xuICAgIGlmICh2YWx1ZXMgaW5zdGFuY2VvZiBQcm9taXNlKSB7XG4gICAgICAgIHZhbHVlcyA9IHZhbHVlcy5fdGFyZ2V0KCk7XG4gICAgICAgIHZhciBiaXRGaWVsZCA9IHZhbHVlcy5fYml0RmllbGQ7XG4gICAgICAgIDtcbiAgICAgICAgdGhpcy5fdmFsdWVzID0gdmFsdWVzO1xuXG4gICAgICAgIGlmICgoKGJpdEZpZWxkICYgNTAzOTcxODQpID09PSAwKSkge1xuICAgICAgICAgICAgdGhpcy5fcHJvbWlzZS5fc2V0QXN5bmNHdWFyYW50ZWVkKCk7XG4gICAgICAgICAgICByZXR1cm4gdmFsdWVzLl90aGVuKFxuICAgICAgICAgICAgICAgIGluaXQsXG4gICAgICAgICAgICAgICAgdGhpcy5fcmVqZWN0LFxuICAgICAgICAgICAgICAgIHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICB0aGlzLFxuICAgICAgICAgICAgICAgIHJlc29sdmVWYWx1ZUlmRW1wdHlcbiAgICAgICAgICAgKTtcbiAgICAgICAgfSBlbHNlIGlmICgoKGJpdEZpZWxkICYgMzM1NTQ0MzIpICE9PSAwKSkge1xuICAgICAgICAgICAgdmFsdWVzID0gdmFsdWVzLl92YWx1ZSgpO1xuICAgICAgICB9IGVsc2UgaWYgKCgoYml0RmllbGQgJiAxNjc3NzIxNikgIT09IDApKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fcmVqZWN0KHZhbHVlcy5fcmVhc29uKCkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2NhbmNlbCgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHZhbHVlcyA9IHV0aWwuYXNBcnJheSh2YWx1ZXMpO1xuICAgIGlmICh2YWx1ZXMgPT09IG51bGwpIHtcbiAgICAgICAgdmFyIGVyciA9IGFwaVJlamVjdGlvbihcbiAgICAgICAgICAgIFwiZXhwZWN0aW5nIGFuIGFycmF5IG9yIGFuIGl0ZXJhYmxlIG9iamVjdCBidXQgZ290IFwiICsgdXRpbC5jbGFzc1N0cmluZyh2YWx1ZXMpKS5yZWFzb24oKTtcbiAgICAgICAgdGhpcy5fcHJvbWlzZS5fcmVqZWN0Q2FsbGJhY2soZXJyLCBmYWxzZSk7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAodmFsdWVzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICBpZiAocmVzb2x2ZVZhbHVlSWZFbXB0eSA9PT0gLTUpIHtcbiAgICAgICAgICAgIHRoaXMuX3Jlc29sdmVFbXB0eUFycmF5KCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl9yZXNvbHZlKHRvUmVzb2x1dGlvblZhbHVlKHJlc29sdmVWYWx1ZUlmRW1wdHkpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuX2l0ZXJhdGUodmFsdWVzKTtcbn07XG5cblByb21pc2VBcnJheS5wcm90b3R5cGUuX2l0ZXJhdGUgPSBmdW5jdGlvbih2YWx1ZXMpIHtcbiAgICB2YXIgbGVuID0gdGhpcy5nZXRBY3R1YWxMZW5ndGgodmFsdWVzLmxlbmd0aCk7XG4gICAgdGhpcy5fbGVuZ3RoID0gbGVuO1xuICAgIHRoaXMuX3ZhbHVlcyA9IHRoaXMuc2hvdWxkQ29weVZhbHVlcygpID8gbmV3IEFycmF5KGxlbikgOiB0aGlzLl92YWx1ZXM7XG4gICAgdmFyIHJlc3VsdCA9IHRoaXMuX3Byb21pc2U7XG4gICAgdmFyIGlzUmVzb2x2ZWQgPSBmYWxzZTtcbiAgICB2YXIgYml0RmllbGQgPSBudWxsO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyArK2kpIHtcbiAgICAgICAgdmFyIG1heWJlUHJvbWlzZSA9IHRyeUNvbnZlcnRUb1Byb21pc2UodmFsdWVzW2ldLCByZXN1bHQpO1xuXG4gICAgICAgIGlmIChtYXliZVByb21pc2UgaW5zdGFuY2VvZiBQcm9taXNlKSB7XG4gICAgICAgICAgICBtYXliZVByb21pc2UgPSBtYXliZVByb21pc2UuX3RhcmdldCgpO1xuICAgICAgICAgICAgYml0RmllbGQgPSBtYXliZVByb21pc2UuX2JpdEZpZWxkO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgYml0RmllbGQgPSBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGlzUmVzb2x2ZWQpIHtcbiAgICAgICAgICAgIGlmIChiaXRGaWVsZCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIG1heWJlUHJvbWlzZS5zdXBwcmVzc1VuaGFuZGxlZFJlamVjdGlvbnMoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChiaXRGaWVsZCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgaWYgKCgoYml0RmllbGQgJiA1MDM5NzE4NCkgPT09IDApKSB7XG4gICAgICAgICAgICAgICAgbWF5YmVQcm9taXNlLl9wcm94eSh0aGlzLCBpKTtcbiAgICAgICAgICAgICAgICB0aGlzLl92YWx1ZXNbaV0gPSBtYXliZVByb21pc2U7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKCgoYml0RmllbGQgJiAzMzU1NDQzMikgIT09IDApKSB7XG4gICAgICAgICAgICAgICAgaXNSZXNvbHZlZCA9IHRoaXMuX3Byb21pc2VGdWxmaWxsZWQobWF5YmVQcm9taXNlLl92YWx1ZSgpLCBpKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoKChiaXRGaWVsZCAmIDE2Nzc3MjE2KSAhPT0gMCkpIHtcbiAgICAgICAgICAgICAgICBpc1Jlc29sdmVkID0gdGhpcy5fcHJvbWlzZVJlamVjdGVkKG1heWJlUHJvbWlzZS5fcmVhc29uKCksIGkpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpc1Jlc29sdmVkID0gdGhpcy5fcHJvbWlzZUNhbmNlbGxlZChpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlzUmVzb2x2ZWQgPSB0aGlzLl9wcm9taXNlRnVsZmlsbGVkKG1heWJlUHJvbWlzZSwgaSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKCFpc1Jlc29sdmVkKSByZXN1bHQuX3NldEFzeW5jR3VhcmFudGVlZCgpO1xufTtcblxuUHJvbWlzZUFycmF5LnByb3RvdHlwZS5faXNSZXNvbHZlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5fdmFsdWVzID09PSBudWxsO1xufTtcblxuUHJvbWlzZUFycmF5LnByb3RvdHlwZS5fcmVzb2x2ZSA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgIHRoaXMuX3ZhbHVlcyA9IG51bGw7XG4gICAgdGhpcy5fcHJvbWlzZS5fZnVsZmlsbCh2YWx1ZSk7XG59O1xuXG5Qcm9taXNlQXJyYXkucHJvdG90eXBlLl9jYW5jZWwgPSBmdW5jdGlvbigpIHtcbiAgICBpZiAodGhpcy5faXNSZXNvbHZlZCgpIHx8ICF0aGlzLl9wcm9taXNlLl9pc0NhbmNlbGxhYmxlKCkpIHJldHVybjtcbiAgICB0aGlzLl92YWx1ZXMgPSBudWxsO1xuICAgIHRoaXMuX3Byb21pc2UuX2NhbmNlbCgpO1xufTtcblxuUHJvbWlzZUFycmF5LnByb3RvdHlwZS5fcmVqZWN0ID0gZnVuY3Rpb24gKHJlYXNvbikge1xuICAgIHRoaXMuX3ZhbHVlcyA9IG51bGw7XG4gICAgdGhpcy5fcHJvbWlzZS5fcmVqZWN0Q2FsbGJhY2socmVhc29uLCBmYWxzZSk7XG59O1xuXG5Qcm9taXNlQXJyYXkucHJvdG90eXBlLl9wcm9taXNlRnVsZmlsbGVkID0gZnVuY3Rpb24gKHZhbHVlLCBpbmRleCkge1xuICAgIHRoaXMuX3ZhbHVlc1tpbmRleF0gPSB2YWx1ZTtcbiAgICB2YXIgdG90YWxSZXNvbHZlZCA9ICsrdGhpcy5fdG90YWxSZXNvbHZlZDtcbiAgICBpZiAodG90YWxSZXNvbHZlZCA+PSB0aGlzLl9sZW5ndGgpIHtcbiAgICAgICAgdGhpcy5fcmVzb2x2ZSh0aGlzLl92YWx1ZXMpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufTtcblxuUHJvbWlzZUFycmF5LnByb3RvdHlwZS5fcHJvbWlzZUNhbmNlbGxlZCA9IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuX2NhbmNlbCgpO1xuICAgIHJldHVybiB0cnVlO1xufTtcblxuUHJvbWlzZUFycmF5LnByb3RvdHlwZS5fcHJvbWlzZVJlamVjdGVkID0gZnVuY3Rpb24gKHJlYXNvbikge1xuICAgIHRoaXMuX3RvdGFsUmVzb2x2ZWQrKztcbiAgICB0aGlzLl9yZWplY3QocmVhc29uKTtcbiAgICByZXR1cm4gdHJ1ZTtcbn07XG5cblByb21pc2VBcnJheS5wcm90b3R5cGUuX3Jlc3VsdENhbmNlbGxlZCA9IGZ1bmN0aW9uKCkge1xuICAgIGlmICh0aGlzLl9pc1Jlc29sdmVkKCkpIHJldHVybjtcbiAgICB2YXIgdmFsdWVzID0gdGhpcy5fdmFsdWVzO1xuICAgIHRoaXMuX2NhbmNlbCgpO1xuICAgIGlmICh2YWx1ZXMgaW5zdGFuY2VvZiBQcm9taXNlKSB7XG4gICAgICAgIHZhbHVlcy5jYW5jZWwoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHZhbHVlcy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgaWYgKHZhbHVlc1tpXSBpbnN0YW5jZW9mIFByb21pc2UpIHtcbiAgICAgICAgICAgICAgICB2YWx1ZXNbaV0uY2FuY2VsKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59O1xuXG5Qcm9taXNlQXJyYXkucHJvdG90eXBlLnNob3VsZENvcHlWYWx1ZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRydWU7XG59O1xuXG5Qcm9taXNlQXJyYXkucHJvdG90eXBlLmdldEFjdHVhbExlbmd0aCA9IGZ1bmN0aW9uIChsZW4pIHtcbiAgICByZXR1cm4gbGVuO1xufTtcblxucmV0dXJuIFByb21pc2VBcnJheTtcbn07XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvYmx1ZWJpcmQvanMvcmVsZWFzZS9wcm9taXNlX2FycmF5LmpzIiwiXCJ1c2Ugc3RyaWN0XCI7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKFByb21pc2UpIHtcbnZhciBsb25nU3RhY2tUcmFjZXMgPSBmYWxzZTtcbnZhciBjb250ZXh0U3RhY2sgPSBbXTtcblxuUHJvbWlzZS5wcm90b3R5cGUuX3Byb21pc2VDcmVhdGVkID0gZnVuY3Rpb24oKSB7fTtcblByb21pc2UucHJvdG90eXBlLl9wdXNoQ29udGV4dCA9IGZ1bmN0aW9uKCkge307XG5Qcm9taXNlLnByb3RvdHlwZS5fcG9wQ29udGV4dCA9IGZ1bmN0aW9uKCkge3JldHVybiBudWxsO307XG5Qcm9taXNlLl9wZWVrQ29udGV4dCA9IFByb21pc2UucHJvdG90eXBlLl9wZWVrQ29udGV4dCA9IGZ1bmN0aW9uKCkge307XG5cbmZ1bmN0aW9uIENvbnRleHQoKSB7XG4gICAgdGhpcy5fdHJhY2UgPSBuZXcgQ29udGV4dC5DYXB0dXJlZFRyYWNlKHBlZWtDb250ZXh0KCkpO1xufVxuQ29udGV4dC5wcm90b3R5cGUuX3B1c2hDb250ZXh0ID0gZnVuY3Rpb24gKCkge1xuICAgIGlmICh0aGlzLl90cmFjZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRoaXMuX3RyYWNlLl9wcm9taXNlQ3JlYXRlZCA9IG51bGw7XG4gICAgICAgIGNvbnRleHRTdGFjay5wdXNoKHRoaXMuX3RyYWNlKTtcbiAgICB9XG59O1xuXG5Db250ZXh0LnByb3RvdHlwZS5fcG9wQ29udGV4dCA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAodGhpcy5fdHJhY2UgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB2YXIgdHJhY2UgPSBjb250ZXh0U3RhY2sucG9wKCk7XG4gICAgICAgIHZhciByZXQgPSB0cmFjZS5fcHJvbWlzZUNyZWF0ZWQ7XG4gICAgICAgIHRyYWNlLl9wcm9taXNlQ3JlYXRlZCA9IG51bGw7XG4gICAgICAgIHJldHVybiByZXQ7XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xufTtcblxuZnVuY3Rpb24gY3JlYXRlQ29udGV4dCgpIHtcbiAgICBpZiAobG9uZ1N0YWNrVHJhY2VzKSByZXR1cm4gbmV3IENvbnRleHQoKTtcbn1cblxuZnVuY3Rpb24gcGVla0NvbnRleHQoKSB7XG4gICAgdmFyIGxhc3RJbmRleCA9IGNvbnRleHRTdGFjay5sZW5ndGggLSAxO1xuICAgIGlmIChsYXN0SW5kZXggPj0gMCkge1xuICAgICAgICByZXR1cm4gY29udGV4dFN0YWNrW2xhc3RJbmRleF07XG4gICAgfVxuICAgIHJldHVybiB1bmRlZmluZWQ7XG59XG5Db250ZXh0LkNhcHR1cmVkVHJhY2UgPSBudWxsO1xuQ29udGV4dC5jcmVhdGUgPSBjcmVhdGVDb250ZXh0O1xuQ29udGV4dC5kZWFjdGl2YXRlTG9uZ1N0YWNrVHJhY2VzID0gZnVuY3Rpb24oKSB7fTtcbkNvbnRleHQuYWN0aXZhdGVMb25nU3RhY2tUcmFjZXMgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgUHJvbWlzZV9wdXNoQ29udGV4dCA9IFByb21pc2UucHJvdG90eXBlLl9wdXNoQ29udGV4dDtcbiAgICB2YXIgUHJvbWlzZV9wb3BDb250ZXh0ID0gUHJvbWlzZS5wcm90b3R5cGUuX3BvcENvbnRleHQ7XG4gICAgdmFyIFByb21pc2VfUGVla0NvbnRleHQgPSBQcm9taXNlLl9wZWVrQ29udGV4dDtcbiAgICB2YXIgUHJvbWlzZV9wZWVrQ29udGV4dCA9IFByb21pc2UucHJvdG90eXBlLl9wZWVrQ29udGV4dDtcbiAgICB2YXIgUHJvbWlzZV9wcm9taXNlQ3JlYXRlZCA9IFByb21pc2UucHJvdG90eXBlLl9wcm9taXNlQ3JlYXRlZDtcbiAgICBDb250ZXh0LmRlYWN0aXZhdGVMb25nU3RhY2tUcmFjZXMgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgUHJvbWlzZS5wcm90b3R5cGUuX3B1c2hDb250ZXh0ID0gUHJvbWlzZV9wdXNoQ29udGV4dDtcbiAgICAgICAgUHJvbWlzZS5wcm90b3R5cGUuX3BvcENvbnRleHQgPSBQcm9taXNlX3BvcENvbnRleHQ7XG4gICAgICAgIFByb21pc2UuX3BlZWtDb250ZXh0ID0gUHJvbWlzZV9QZWVrQ29udGV4dDtcbiAgICAgICAgUHJvbWlzZS5wcm90b3R5cGUuX3BlZWtDb250ZXh0ID0gUHJvbWlzZV9wZWVrQ29udGV4dDtcbiAgICAgICAgUHJvbWlzZS5wcm90b3R5cGUuX3Byb21pc2VDcmVhdGVkID0gUHJvbWlzZV9wcm9taXNlQ3JlYXRlZDtcbiAgICAgICAgbG9uZ1N0YWNrVHJhY2VzID0gZmFsc2U7XG4gICAgfTtcbiAgICBsb25nU3RhY2tUcmFjZXMgPSB0cnVlO1xuICAgIFByb21pc2UucHJvdG90eXBlLl9wdXNoQ29udGV4dCA9IENvbnRleHQucHJvdG90eXBlLl9wdXNoQ29udGV4dDtcbiAgICBQcm9taXNlLnByb3RvdHlwZS5fcG9wQ29udGV4dCA9IENvbnRleHQucHJvdG90eXBlLl9wb3BDb250ZXh0O1xuICAgIFByb21pc2UuX3BlZWtDb250ZXh0ID0gUHJvbWlzZS5wcm90b3R5cGUuX3BlZWtDb250ZXh0ID0gcGVla0NvbnRleHQ7XG4gICAgUHJvbWlzZS5wcm90b3R5cGUuX3Byb21pc2VDcmVhdGVkID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBjdHggPSB0aGlzLl9wZWVrQ29udGV4dCgpO1xuICAgICAgICBpZiAoY3R4ICYmIGN0eC5fcHJvbWlzZUNyZWF0ZWQgPT0gbnVsbCkgY3R4Ll9wcm9taXNlQ3JlYXRlZCA9IHRoaXM7XG4gICAgfTtcbn07XG5yZXR1cm4gQ29udGV4dDtcbn07XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvYmx1ZWJpcmQvanMvcmVsZWFzZS9jb250ZXh0LmpzIiwiXCJ1c2Ugc3RyaWN0XCI7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKFByb21pc2UsIENvbnRleHQpIHtcbnZhciBnZXREb21haW4gPSBQcm9taXNlLl9nZXREb21haW47XG52YXIgYXN5bmMgPSBQcm9taXNlLl9hc3luYztcbnZhciBXYXJuaW5nID0gcmVxdWlyZShcIi4vZXJyb3JzXCIpLldhcm5pbmc7XG52YXIgdXRpbCA9IHJlcXVpcmUoXCIuL3V0aWxcIik7XG52YXIgY2FuQXR0YWNoVHJhY2UgPSB1dGlsLmNhbkF0dGFjaFRyYWNlO1xudmFyIHVuaGFuZGxlZFJlamVjdGlvbkhhbmRsZWQ7XG52YXIgcG9zc2libHlVbmhhbmRsZWRSZWplY3Rpb247XG52YXIgYmx1ZWJpcmRGcmFtZVBhdHRlcm4gPVxuICAgIC9bXFxcXFxcL11ibHVlYmlyZFtcXFxcXFwvXWpzW1xcXFxcXC9dKHJlbGVhc2V8ZGVidWd8aW5zdHJ1bWVudGVkKS87XG52YXIgbm9kZUZyYW1lUGF0dGVybiA9IC9cXCgoPzp0aW1lcnNcXC5qcyk6XFxkKzpcXGQrXFwpLztcbnZhciBwYXJzZUxpbmVQYXR0ZXJuID0gL1tcXC88XFwoXSguKz8pOihcXGQrKTooXFxkKylcXCk/XFxzKiQvO1xudmFyIHN0YWNrRnJhbWVQYXR0ZXJuID0gbnVsbDtcbnZhciBmb3JtYXRTdGFjayA9IG51bGw7XG52YXIgaW5kZW50U3RhY2tGcmFtZXMgPSBmYWxzZTtcbnZhciBwcmludFdhcm5pbmc7XG52YXIgZGVidWdnaW5nID0gISEodXRpbC5lbnYoXCJCTFVFQklSRF9ERUJVR1wiKSAhPSAwICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAoZmFsc2UgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICB1dGlsLmVudihcIkJMVUVCSVJEX0RFQlVHXCIpIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgdXRpbC5lbnYoXCJOT0RFX0VOVlwiKSA9PT0gXCJkZXZlbG9wbWVudFwiKSk7XG5cbnZhciB3YXJuaW5ncyA9ICEhKHV0aWwuZW52KFwiQkxVRUJJUkRfV0FSTklOR1NcIikgIT0gMCAmJlxuICAgIChkZWJ1Z2dpbmcgfHwgdXRpbC5lbnYoXCJCTFVFQklSRF9XQVJOSU5HU1wiKSkpO1xuXG52YXIgbG9uZ1N0YWNrVHJhY2VzID0gISEodXRpbC5lbnYoXCJCTFVFQklSRF9MT05HX1NUQUNLX1RSQUNFU1wiKSAhPSAwICYmXG4gICAgKGRlYnVnZ2luZyB8fCB1dGlsLmVudihcIkJMVUVCSVJEX0xPTkdfU1RBQ0tfVFJBQ0VTXCIpKSk7XG5cbnZhciB3Rm9yZ290dGVuUmV0dXJuID0gdXRpbC5lbnYoXCJCTFVFQklSRF9XX0ZPUkdPVFRFTl9SRVRVUk5cIikgIT0gMCAmJlxuICAgICh3YXJuaW5ncyB8fCAhIXV0aWwuZW52KFwiQkxVRUJJUkRfV19GT1JHT1RURU5fUkVUVVJOXCIpKTtcblxuUHJvbWlzZS5wcm90b3R5cGUuc3VwcHJlc3NVbmhhbmRsZWRSZWplY3Rpb25zID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHRhcmdldCA9IHRoaXMuX3RhcmdldCgpO1xuICAgIHRhcmdldC5fYml0RmllbGQgPSAoKHRhcmdldC5fYml0RmllbGQgJiAofjEwNDg1NzYpKSB8XG4gICAgICAgICAgICAgICAgICAgICAgNTI0Mjg4KTtcbn07XG5cblByb21pc2UucHJvdG90eXBlLl9lbnN1cmVQb3NzaWJsZVJlamVjdGlvbkhhbmRsZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKCh0aGlzLl9iaXRGaWVsZCAmIDUyNDI4OCkgIT09IDApIHJldHVybjtcbiAgICB0aGlzLl9zZXRSZWplY3Rpb25Jc1VuaGFuZGxlZCgpO1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICBzZWxmLl9ub3RpZnlVbmhhbmRsZWRSZWplY3Rpb24oKTtcbiAgICB9LCAxKTtcbn07XG5cblByb21pc2UucHJvdG90eXBlLl9ub3RpZnlVbmhhbmRsZWRSZWplY3Rpb25Jc0hhbmRsZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgZmlyZVJlamVjdGlvbkV2ZW50KFwicmVqZWN0aW9uSGFuZGxlZFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVuaGFuZGxlZFJlamVjdGlvbkhhbmRsZWQsIHVuZGVmaW5lZCwgdGhpcyk7XG59O1xuXG5Qcm9taXNlLnByb3RvdHlwZS5fc2V0UmV0dXJuZWROb25VbmRlZmluZWQgPSBmdW5jdGlvbigpIHtcbiAgICB0aGlzLl9iaXRGaWVsZCA9IHRoaXMuX2JpdEZpZWxkIHwgMjY4NDM1NDU2O1xufTtcblxuUHJvbWlzZS5wcm90b3R5cGUuX3JldHVybmVkTm9uVW5kZWZpbmVkID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuICh0aGlzLl9iaXRGaWVsZCAmIDI2ODQzNTQ1NikgIT09IDA7XG59O1xuXG5Qcm9taXNlLnByb3RvdHlwZS5fbm90aWZ5VW5oYW5kbGVkUmVqZWN0aW9uID0gZnVuY3Rpb24gKCkge1xuICAgIGlmICh0aGlzLl9pc1JlamVjdGlvblVuaGFuZGxlZCgpKSB7XG4gICAgICAgIHZhciByZWFzb24gPSB0aGlzLl9zZXR0bGVkVmFsdWUoKTtcbiAgICAgICAgdGhpcy5fc2V0VW5oYW5kbGVkUmVqZWN0aW9uSXNOb3RpZmllZCgpO1xuICAgICAgICBmaXJlUmVqZWN0aW9uRXZlbnQoXCJ1bmhhbmRsZWRSZWplY3Rpb25cIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcG9zc2libHlVbmhhbmRsZWRSZWplY3Rpb24sIHJlYXNvbiwgdGhpcyk7XG4gICAgfVxufTtcblxuUHJvbWlzZS5wcm90b3R5cGUuX3NldFVuaGFuZGxlZFJlamVjdGlvbklzTm90aWZpZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5fYml0RmllbGQgPSB0aGlzLl9iaXRGaWVsZCB8IDI2MjE0NDtcbn07XG5cblByb21pc2UucHJvdG90eXBlLl91bnNldFVuaGFuZGxlZFJlamVjdGlvbklzTm90aWZpZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5fYml0RmllbGQgPSB0aGlzLl9iaXRGaWVsZCAmICh+MjYyMTQ0KTtcbn07XG5cblByb21pc2UucHJvdG90eXBlLl9pc1VuaGFuZGxlZFJlamVjdGlvbk5vdGlmaWVkID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiAodGhpcy5fYml0RmllbGQgJiAyNjIxNDQpID4gMDtcbn07XG5cblByb21pc2UucHJvdG90eXBlLl9zZXRSZWplY3Rpb25Jc1VuaGFuZGxlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLl9iaXRGaWVsZCA9IHRoaXMuX2JpdEZpZWxkIHwgMTA0ODU3Njtcbn07XG5cblByb21pc2UucHJvdG90eXBlLl91bnNldFJlamVjdGlvbklzVW5oYW5kbGVkID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuX2JpdEZpZWxkID0gdGhpcy5fYml0RmllbGQgJiAofjEwNDg1NzYpO1xuICAgIGlmICh0aGlzLl9pc1VuaGFuZGxlZFJlamVjdGlvbk5vdGlmaWVkKCkpIHtcbiAgICAgICAgdGhpcy5fdW5zZXRVbmhhbmRsZWRSZWplY3Rpb25Jc05vdGlmaWVkKCk7XG4gICAgICAgIHRoaXMuX25vdGlmeVVuaGFuZGxlZFJlamVjdGlvbklzSGFuZGxlZCgpO1xuICAgIH1cbn07XG5cblByb21pc2UucHJvdG90eXBlLl9pc1JlamVjdGlvblVuaGFuZGxlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gKHRoaXMuX2JpdEZpZWxkICYgMTA0ODU3NikgPiAwO1xufTtcblxuUHJvbWlzZS5wcm90b3R5cGUuX3dhcm4gPSBmdW5jdGlvbihtZXNzYWdlLCBzaG91bGRVc2VPd25UcmFjZSwgcHJvbWlzZSkge1xuICAgIHJldHVybiB3YXJuKG1lc3NhZ2UsIHNob3VsZFVzZU93blRyYWNlLCBwcm9taXNlIHx8IHRoaXMpO1xufTtcblxuUHJvbWlzZS5vblBvc3NpYmx5VW5oYW5kbGVkUmVqZWN0aW9uID0gZnVuY3Rpb24gKGZuKSB7XG4gICAgdmFyIGRvbWFpbiA9IGdldERvbWFpbigpO1xuICAgIHBvc3NpYmx5VW5oYW5kbGVkUmVqZWN0aW9uID1cbiAgICAgICAgdHlwZW9mIGZuID09PSBcImZ1bmN0aW9uXCIgPyAoZG9tYWluID09PSBudWxsID9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm4gOiB1dGlsLmRvbWFpbkJpbmQoZG9tYWluLCBmbikpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZDtcbn07XG5cblByb21pc2Uub25VbmhhbmRsZWRSZWplY3Rpb25IYW5kbGVkID0gZnVuY3Rpb24gKGZuKSB7XG4gICAgdmFyIGRvbWFpbiA9IGdldERvbWFpbigpO1xuICAgIHVuaGFuZGxlZFJlamVjdGlvbkhhbmRsZWQgPVxuICAgICAgICB0eXBlb2YgZm4gPT09IFwiZnVuY3Rpb25cIiA/IChkb21haW4gPT09IG51bGwgP1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmbiA6IHV0aWwuZG9tYWluQmluZChkb21haW4sIGZuKSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkO1xufTtcblxudmFyIGRpc2FibGVMb25nU3RhY2tUcmFjZXMgPSBmdW5jdGlvbigpIHt9O1xuUHJvbWlzZS5sb25nU3RhY2tUcmFjZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKGFzeW5jLmhhdmVJdGVtc1F1ZXVlZCgpICYmICFjb25maWcubG9uZ1N0YWNrVHJhY2VzKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcImNhbm5vdCBlbmFibGUgbG9uZyBzdGFjayB0cmFjZXMgYWZ0ZXIgcHJvbWlzZXMgaGF2ZSBiZWVuIGNyZWF0ZWRcXHUwMDBhXFx1MDAwYSAgICBTZWUgaHR0cDovL2dvby5nbC9NcXJGbVhcXHUwMDBhXCIpO1xuICAgIH1cbiAgICBpZiAoIWNvbmZpZy5sb25nU3RhY2tUcmFjZXMgJiYgbG9uZ1N0YWNrVHJhY2VzSXNTdXBwb3J0ZWQoKSkge1xuICAgICAgICB2YXIgUHJvbWlzZV9jYXB0dXJlU3RhY2tUcmFjZSA9IFByb21pc2UucHJvdG90eXBlLl9jYXB0dXJlU3RhY2tUcmFjZTtcbiAgICAgICAgdmFyIFByb21pc2VfYXR0YWNoRXh0cmFUcmFjZSA9IFByb21pc2UucHJvdG90eXBlLl9hdHRhY2hFeHRyYVRyYWNlO1xuICAgICAgICBjb25maWcubG9uZ1N0YWNrVHJhY2VzID0gdHJ1ZTtcbiAgICAgICAgZGlzYWJsZUxvbmdTdGFja1RyYWNlcyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgaWYgKGFzeW5jLmhhdmVJdGVtc1F1ZXVlZCgpICYmICFjb25maWcubG9uZ1N0YWNrVHJhY2VzKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiY2Fubm90IGVuYWJsZSBsb25nIHN0YWNrIHRyYWNlcyBhZnRlciBwcm9taXNlcyBoYXZlIGJlZW4gY3JlYXRlZFxcdTAwMGFcXHUwMDBhICAgIFNlZSBodHRwOi8vZ29vLmdsL01xckZtWFxcdTAwMGFcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBQcm9taXNlLnByb3RvdHlwZS5fY2FwdHVyZVN0YWNrVHJhY2UgPSBQcm9taXNlX2NhcHR1cmVTdGFja1RyYWNlO1xuICAgICAgICAgICAgUHJvbWlzZS5wcm90b3R5cGUuX2F0dGFjaEV4dHJhVHJhY2UgPSBQcm9taXNlX2F0dGFjaEV4dHJhVHJhY2U7XG4gICAgICAgICAgICBDb250ZXh0LmRlYWN0aXZhdGVMb25nU3RhY2tUcmFjZXMoKTtcbiAgICAgICAgICAgIGFzeW5jLmVuYWJsZVRyYW1wb2xpbmUoKTtcbiAgICAgICAgICAgIGNvbmZpZy5sb25nU3RhY2tUcmFjZXMgPSBmYWxzZTtcbiAgICAgICAgfTtcbiAgICAgICAgUHJvbWlzZS5wcm90b3R5cGUuX2NhcHR1cmVTdGFja1RyYWNlID0gbG9uZ1N0YWNrVHJhY2VzQ2FwdHVyZVN0YWNrVHJhY2U7XG4gICAgICAgIFByb21pc2UucHJvdG90eXBlLl9hdHRhY2hFeHRyYVRyYWNlID0gbG9uZ1N0YWNrVHJhY2VzQXR0YWNoRXh0cmFUcmFjZTtcbiAgICAgICAgQ29udGV4dC5hY3RpdmF0ZUxvbmdTdGFja1RyYWNlcygpO1xuICAgICAgICBhc3luYy5kaXNhYmxlVHJhbXBvbGluZUlmTmVjZXNzYXJ5KCk7XG4gICAgfVxufTtcblxuUHJvbWlzZS5oYXNMb25nU3RhY2tUcmFjZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIGNvbmZpZy5sb25nU3RhY2tUcmFjZXMgJiYgbG9uZ1N0YWNrVHJhY2VzSXNTdXBwb3J0ZWQoKTtcbn07XG5cbnZhciBmaXJlRG9tRXZlbnQgPSAoZnVuY3Rpb24oKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgaWYgKHR5cGVvZiBDdXN0b21FdmVudCA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICB2YXIgZXZlbnQgPSBuZXcgQ3VzdG9tRXZlbnQoXCJDdXN0b21FdmVudFwiKTtcbiAgICAgICAgICAgIHV0aWwuZ2xvYmFsLmRpc3BhdGNoRXZlbnQoZXZlbnQpO1xuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKG5hbWUsIGV2ZW50KSB7XG4gICAgICAgICAgICAgICAgdmFyIGRvbUV2ZW50ID0gbmV3IEN1c3RvbUV2ZW50KG5hbWUudG9Mb3dlckNhc2UoKSwge1xuICAgICAgICAgICAgICAgICAgICBkZXRhaWw6IGV2ZW50LFxuICAgICAgICAgICAgICAgICAgICBjYW5jZWxhYmxlOiB0cnVlXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuICF1dGlsLmdsb2JhbC5kaXNwYXRjaEV2ZW50KGRvbUV2ZW50KTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIEV2ZW50ID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgIHZhciBldmVudCA9IG5ldyBFdmVudChcIkN1c3RvbUV2ZW50XCIpO1xuICAgICAgICAgICAgdXRpbC5nbG9iYWwuZGlzcGF0Y2hFdmVudChldmVudCk7XG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24obmFtZSwgZXZlbnQpIHtcbiAgICAgICAgICAgICAgICB2YXIgZG9tRXZlbnQgPSBuZXcgRXZlbnQobmFtZS50b0xvd2VyQ2FzZSgpLCB7XG4gICAgICAgICAgICAgICAgICAgIGNhbmNlbGFibGU6IHRydWVcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBkb21FdmVudC5kZXRhaWwgPSBldmVudDtcbiAgICAgICAgICAgICAgICByZXR1cm4gIXV0aWwuZ2xvYmFsLmRpc3BhdGNoRXZlbnQoZG9tRXZlbnQpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhciBldmVudCA9IGRvY3VtZW50LmNyZWF0ZUV2ZW50KFwiQ3VzdG9tRXZlbnRcIik7XG4gICAgICAgICAgICBldmVudC5pbml0Q3VzdG9tRXZlbnQoXCJ0ZXN0aW5ndGhlZXZlbnRcIiwgZmFsc2UsIHRydWUsIHt9KTtcbiAgICAgICAgICAgIHV0aWwuZ2xvYmFsLmRpc3BhdGNoRXZlbnQoZXZlbnQpO1xuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKG5hbWUsIGV2ZW50KSB7XG4gICAgICAgICAgICAgICAgdmFyIGRvbUV2ZW50ID0gZG9jdW1lbnQuY3JlYXRlRXZlbnQoXCJDdXN0b21FdmVudFwiKTtcbiAgICAgICAgICAgICAgICBkb21FdmVudC5pbml0Q3VzdG9tRXZlbnQobmFtZS50b0xvd2VyQ2FzZSgpLCBmYWxzZSwgdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgZXZlbnQpO1xuICAgICAgICAgICAgICAgIHJldHVybiAhdXRpbC5nbG9iYWwuZGlzcGF0Y2hFdmVudChkb21FdmVudCk7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgfSBjYXRjaCAoZSkge31cbiAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9O1xufSkoKTtcblxudmFyIGZpcmVHbG9iYWxFdmVudCA9IChmdW5jdGlvbigpIHtcbiAgICBpZiAodXRpbC5pc05vZGUpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIHByb2Nlc3MuZW1pdC5hcHBseShwcm9jZXNzLCBhcmd1bWVudHMpO1xuICAgICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGlmICghdXRpbC5nbG9iYWwpIHtcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmdW5jdGlvbihuYW1lKSB7XG4gICAgICAgICAgICB2YXIgbWV0aG9kTmFtZSA9IFwib25cIiArIG5hbWUudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICAgIHZhciBtZXRob2QgPSB1dGlsLmdsb2JhbFttZXRob2ROYW1lXTtcbiAgICAgICAgICAgIGlmICghbWV0aG9kKSByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICBtZXRob2QuYXBwbHkodXRpbC5nbG9iYWwsIFtdLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKSk7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfTtcbiAgICB9XG59KSgpO1xuXG5mdW5jdGlvbiBnZW5lcmF0ZVByb21pc2VMaWZlY3ljbGVFdmVudE9iamVjdChuYW1lLCBwcm9taXNlKSB7XG4gICAgcmV0dXJuIHtwcm9taXNlOiBwcm9taXNlfTtcbn1cblxudmFyIGV2ZW50VG9PYmplY3RHZW5lcmF0b3IgPSB7XG4gICAgcHJvbWlzZUNyZWF0ZWQ6IGdlbmVyYXRlUHJvbWlzZUxpZmVjeWNsZUV2ZW50T2JqZWN0LFxuICAgIHByb21pc2VGdWxmaWxsZWQ6IGdlbmVyYXRlUHJvbWlzZUxpZmVjeWNsZUV2ZW50T2JqZWN0LFxuICAgIHByb21pc2VSZWplY3RlZDogZ2VuZXJhdGVQcm9taXNlTGlmZWN5Y2xlRXZlbnRPYmplY3QsXG4gICAgcHJvbWlzZVJlc29sdmVkOiBnZW5lcmF0ZVByb21pc2VMaWZlY3ljbGVFdmVudE9iamVjdCxcbiAgICBwcm9taXNlQ2FuY2VsbGVkOiBnZW5lcmF0ZVByb21pc2VMaWZlY3ljbGVFdmVudE9iamVjdCxcbiAgICBwcm9taXNlQ2hhaW5lZDogZnVuY3Rpb24obmFtZSwgcHJvbWlzZSwgY2hpbGQpIHtcbiAgICAgICAgcmV0dXJuIHtwcm9taXNlOiBwcm9taXNlLCBjaGlsZDogY2hpbGR9O1xuICAgIH0sXG4gICAgd2FybmluZzogZnVuY3Rpb24obmFtZSwgd2FybmluZykge1xuICAgICAgICByZXR1cm4ge3dhcm5pbmc6IHdhcm5pbmd9O1xuICAgIH0sXG4gICAgdW5oYW5kbGVkUmVqZWN0aW9uOiBmdW5jdGlvbiAobmFtZSwgcmVhc29uLCBwcm9taXNlKSB7XG4gICAgICAgIHJldHVybiB7cmVhc29uOiByZWFzb24sIHByb21pc2U6IHByb21pc2V9O1xuICAgIH0sXG4gICAgcmVqZWN0aW9uSGFuZGxlZDogZ2VuZXJhdGVQcm9taXNlTGlmZWN5Y2xlRXZlbnRPYmplY3Rcbn07XG5cbnZhciBhY3RpdmVGaXJlRXZlbnQgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgIHZhciBnbG9iYWxFdmVudEZpcmVkID0gZmFsc2U7XG4gICAgdHJ5IHtcbiAgICAgICAgZ2xvYmFsRXZlbnRGaXJlZCA9IGZpcmVHbG9iYWxFdmVudC5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgYXN5bmMudGhyb3dMYXRlcihlKTtcbiAgICAgICAgZ2xvYmFsRXZlbnRGaXJlZCA9IHRydWU7XG4gICAgfVxuXG4gICAgdmFyIGRvbUV2ZW50RmlyZWQgPSBmYWxzZTtcbiAgICB0cnkge1xuICAgICAgICBkb21FdmVudEZpcmVkID0gZmlyZURvbUV2ZW50KG5hbWUsXG4gICAgICAgICAgICAgICAgICAgIGV2ZW50VG9PYmplY3RHZW5lcmF0b3JbbmFtZV0uYXBwbHkobnVsbCwgYXJndW1lbnRzKSk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBhc3luYy50aHJvd0xhdGVyKGUpO1xuICAgICAgICBkb21FdmVudEZpcmVkID0gdHJ1ZTtcbiAgICB9XG5cbiAgICByZXR1cm4gZG9tRXZlbnRGaXJlZCB8fCBnbG9iYWxFdmVudEZpcmVkO1xufTtcblxuUHJvbWlzZS5jb25maWcgPSBmdW5jdGlvbihvcHRzKSB7XG4gICAgb3B0cyA9IE9iamVjdChvcHRzKTtcbiAgICBpZiAoXCJsb25nU3RhY2tUcmFjZXNcIiBpbiBvcHRzKSB7XG4gICAgICAgIGlmIChvcHRzLmxvbmdTdGFja1RyYWNlcykge1xuICAgICAgICAgICAgUHJvbWlzZS5sb25nU3RhY2tUcmFjZXMoKTtcbiAgICAgICAgfSBlbHNlIGlmICghb3B0cy5sb25nU3RhY2tUcmFjZXMgJiYgUHJvbWlzZS5oYXNMb25nU3RhY2tUcmFjZXMoKSkge1xuICAgICAgICAgICAgZGlzYWJsZUxvbmdTdGFja1RyYWNlcygpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChcIndhcm5pbmdzXCIgaW4gb3B0cykge1xuICAgICAgICB2YXIgd2FybmluZ3NPcHRpb24gPSBvcHRzLndhcm5pbmdzO1xuICAgICAgICBjb25maWcud2FybmluZ3MgPSAhIXdhcm5pbmdzT3B0aW9uO1xuICAgICAgICB3Rm9yZ290dGVuUmV0dXJuID0gY29uZmlnLndhcm5pbmdzO1xuXG4gICAgICAgIGlmICh1dGlsLmlzT2JqZWN0KHdhcm5pbmdzT3B0aW9uKSkge1xuICAgICAgICAgICAgaWYgKFwid0ZvcmdvdHRlblJldHVyblwiIGluIHdhcm5pbmdzT3B0aW9uKSB7XG4gICAgICAgICAgICAgICAgd0ZvcmdvdHRlblJldHVybiA9ICEhd2FybmluZ3NPcHRpb24ud0ZvcmdvdHRlblJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoXCJjYW5jZWxsYXRpb25cIiBpbiBvcHRzICYmIG9wdHMuY2FuY2VsbGF0aW9uICYmICFjb25maWcuY2FuY2VsbGF0aW9uKSB7XG4gICAgICAgIGlmIChhc3luYy5oYXZlSXRlbXNRdWV1ZWQoKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICAgICAgIFwiY2Fubm90IGVuYWJsZSBjYW5jZWxsYXRpb24gYWZ0ZXIgcHJvbWlzZXMgYXJlIGluIHVzZVwiKTtcbiAgICAgICAgfVxuICAgICAgICBQcm9taXNlLnByb3RvdHlwZS5fY2xlYXJDYW5jZWxsYXRpb25EYXRhID1cbiAgICAgICAgICAgIGNhbmNlbGxhdGlvbkNsZWFyQ2FuY2VsbGF0aW9uRGF0YTtcbiAgICAgICAgUHJvbWlzZS5wcm90b3R5cGUuX3Byb3BhZ2F0ZUZyb20gPSBjYW5jZWxsYXRpb25Qcm9wYWdhdGVGcm9tO1xuICAgICAgICBQcm9taXNlLnByb3RvdHlwZS5fb25DYW5jZWwgPSBjYW5jZWxsYXRpb25PbkNhbmNlbDtcbiAgICAgICAgUHJvbWlzZS5wcm90b3R5cGUuX3NldE9uQ2FuY2VsID0gY2FuY2VsbGF0aW9uU2V0T25DYW5jZWw7XG4gICAgICAgIFByb21pc2UucHJvdG90eXBlLl9hdHRhY2hDYW5jZWxsYXRpb25DYWxsYmFjayA9XG4gICAgICAgICAgICBjYW5jZWxsYXRpb25BdHRhY2hDYW5jZWxsYXRpb25DYWxsYmFjaztcbiAgICAgICAgUHJvbWlzZS5wcm90b3R5cGUuX2V4ZWN1dGUgPSBjYW5jZWxsYXRpb25FeGVjdXRlO1xuICAgICAgICBwcm9wYWdhdGVGcm9tRnVuY3Rpb24gPSBjYW5jZWxsYXRpb25Qcm9wYWdhdGVGcm9tO1xuICAgICAgICBjb25maWcuY2FuY2VsbGF0aW9uID0gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKFwibW9uaXRvcmluZ1wiIGluIG9wdHMpIHtcbiAgICAgICAgaWYgKG9wdHMubW9uaXRvcmluZyAmJiAhY29uZmlnLm1vbml0b3JpbmcpIHtcbiAgICAgICAgICAgIGNvbmZpZy5tb25pdG9yaW5nID0gdHJ1ZTtcbiAgICAgICAgICAgIFByb21pc2UucHJvdG90eXBlLl9maXJlRXZlbnQgPSBhY3RpdmVGaXJlRXZlbnQ7XG4gICAgICAgIH0gZWxzZSBpZiAoIW9wdHMubW9uaXRvcmluZyAmJiBjb25maWcubW9uaXRvcmluZykge1xuICAgICAgICAgICAgY29uZmlnLm1vbml0b3JpbmcgPSBmYWxzZTtcbiAgICAgICAgICAgIFByb21pc2UucHJvdG90eXBlLl9maXJlRXZlbnQgPSBkZWZhdWx0RmlyZUV2ZW50O1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBQcm9taXNlO1xufTtcblxuZnVuY3Rpb24gZGVmYXVsdEZpcmVFdmVudCgpIHsgcmV0dXJuIGZhbHNlOyB9XG5cblByb21pc2UucHJvdG90eXBlLl9maXJlRXZlbnQgPSBkZWZhdWx0RmlyZUV2ZW50O1xuUHJvbWlzZS5wcm90b3R5cGUuX2V4ZWN1dGUgPSBmdW5jdGlvbihleGVjdXRvciwgcmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgdHJ5IHtcbiAgICAgICAgZXhlY3V0b3IocmVzb2x2ZSwgcmVqZWN0KTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIHJldHVybiBlO1xuICAgIH1cbn07XG5Qcm9taXNlLnByb3RvdHlwZS5fb25DYW5jZWwgPSBmdW5jdGlvbiAoKSB7fTtcblByb21pc2UucHJvdG90eXBlLl9zZXRPbkNhbmNlbCA9IGZ1bmN0aW9uIChoYW5kbGVyKSB7IDsgfTtcblByb21pc2UucHJvdG90eXBlLl9hdHRhY2hDYW5jZWxsYXRpb25DYWxsYmFjayA9IGZ1bmN0aW9uKG9uQ2FuY2VsKSB7XG4gICAgO1xufTtcblByb21pc2UucHJvdG90eXBlLl9jYXB0dXJlU3RhY2tUcmFjZSA9IGZ1bmN0aW9uICgpIHt9O1xuUHJvbWlzZS5wcm90b3R5cGUuX2F0dGFjaEV4dHJhVHJhY2UgPSBmdW5jdGlvbiAoKSB7fTtcblByb21pc2UucHJvdG90eXBlLl9jbGVhckNhbmNlbGxhdGlvbkRhdGEgPSBmdW5jdGlvbigpIHt9O1xuUHJvbWlzZS5wcm90b3R5cGUuX3Byb3BhZ2F0ZUZyb20gPSBmdW5jdGlvbiAocGFyZW50LCBmbGFncykge1xuICAgIDtcbiAgICA7XG59O1xuXG5mdW5jdGlvbiBjYW5jZWxsYXRpb25FeGVjdXRlKGV4ZWN1dG9yLCByZXNvbHZlLCByZWplY3QpIHtcbiAgICB2YXIgcHJvbWlzZSA9IHRoaXM7XG4gICAgdHJ5IHtcbiAgICAgICAgZXhlY3V0b3IocmVzb2x2ZSwgcmVqZWN0LCBmdW5jdGlvbihvbkNhbmNlbCkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBvbkNhbmNlbCAhPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIm9uQ2FuY2VsIG11c3QgYmUgYSBmdW5jdGlvbiwgZ290OiBcIiArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB1dGlsLnRvU3RyaW5nKG9uQ2FuY2VsKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwcm9taXNlLl9hdHRhY2hDYW5jZWxsYXRpb25DYWxsYmFjayhvbkNhbmNlbCk7XG4gICAgICAgIH0pO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgcmV0dXJuIGU7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBjYW5jZWxsYXRpb25BdHRhY2hDYW5jZWxsYXRpb25DYWxsYmFjayhvbkNhbmNlbCkge1xuICAgIGlmICghdGhpcy5faXNDYW5jZWxsYWJsZSgpKSByZXR1cm4gdGhpcztcblxuICAgIHZhciBwcmV2aW91c09uQ2FuY2VsID0gdGhpcy5fb25DYW5jZWwoKTtcbiAgICBpZiAocHJldmlvdXNPbkNhbmNlbCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGlmICh1dGlsLmlzQXJyYXkocHJldmlvdXNPbkNhbmNlbCkpIHtcbiAgICAgICAgICAgIHByZXZpb3VzT25DYW5jZWwucHVzaChvbkNhbmNlbCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl9zZXRPbkNhbmNlbChbcHJldmlvdXNPbkNhbmNlbCwgb25DYW5jZWxdKTtcbiAgICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuX3NldE9uQ2FuY2VsKG9uQ2FuY2VsKTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGNhbmNlbGxhdGlvbk9uQ2FuY2VsKCkge1xuICAgIHJldHVybiB0aGlzLl9vbkNhbmNlbEZpZWxkO1xufVxuXG5mdW5jdGlvbiBjYW5jZWxsYXRpb25TZXRPbkNhbmNlbChvbkNhbmNlbCkge1xuICAgIHRoaXMuX29uQ2FuY2VsRmllbGQgPSBvbkNhbmNlbDtcbn1cblxuZnVuY3Rpb24gY2FuY2VsbGF0aW9uQ2xlYXJDYW5jZWxsYXRpb25EYXRhKCkge1xuICAgIHRoaXMuX2NhbmNlbGxhdGlvblBhcmVudCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLl9vbkNhbmNlbEZpZWxkID0gdW5kZWZpbmVkO1xufVxuXG5mdW5jdGlvbiBjYW5jZWxsYXRpb25Qcm9wYWdhdGVGcm9tKHBhcmVudCwgZmxhZ3MpIHtcbiAgICBpZiAoKGZsYWdzICYgMSkgIT09IDApIHtcbiAgICAgICAgdGhpcy5fY2FuY2VsbGF0aW9uUGFyZW50ID0gcGFyZW50O1xuICAgICAgICB2YXIgYnJhbmNoZXNSZW1haW5pbmdUb0NhbmNlbCA9IHBhcmVudC5fYnJhbmNoZXNSZW1haW5pbmdUb0NhbmNlbDtcbiAgICAgICAgaWYgKGJyYW5jaGVzUmVtYWluaW5nVG9DYW5jZWwgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgYnJhbmNoZXNSZW1haW5pbmdUb0NhbmNlbCA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgcGFyZW50Ll9icmFuY2hlc1JlbWFpbmluZ1RvQ2FuY2VsID0gYnJhbmNoZXNSZW1haW5pbmdUb0NhbmNlbCArIDE7XG4gICAgfVxuICAgIGlmICgoZmxhZ3MgJiAyKSAhPT0gMCAmJiBwYXJlbnQuX2lzQm91bmQoKSkge1xuICAgICAgICB0aGlzLl9zZXRCb3VuZFRvKHBhcmVudC5fYm91bmRUbyk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBiaW5kaW5nUHJvcGFnYXRlRnJvbShwYXJlbnQsIGZsYWdzKSB7XG4gICAgaWYgKChmbGFncyAmIDIpICE9PSAwICYmIHBhcmVudC5faXNCb3VuZCgpKSB7XG4gICAgICAgIHRoaXMuX3NldEJvdW5kVG8ocGFyZW50Ll9ib3VuZFRvKTtcbiAgICB9XG59XG52YXIgcHJvcGFnYXRlRnJvbUZ1bmN0aW9uID0gYmluZGluZ1Byb3BhZ2F0ZUZyb207XG5cbmZ1bmN0aW9uIGJvdW5kVmFsdWVGdW5jdGlvbigpIHtcbiAgICB2YXIgcmV0ID0gdGhpcy5fYm91bmRUbztcbiAgICBpZiAocmV0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgaWYgKHJldCBpbnN0YW5jZW9mIFByb21pc2UpIHtcbiAgICAgICAgICAgIGlmIChyZXQuaXNGdWxmaWxsZWQoKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiByZXQudmFsdWUoKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmV0O1xufVxuXG5mdW5jdGlvbiBsb25nU3RhY2tUcmFjZXNDYXB0dXJlU3RhY2tUcmFjZSgpIHtcbiAgICB0aGlzLl90cmFjZSA9IG5ldyBDYXB0dXJlZFRyYWNlKHRoaXMuX3BlZWtDb250ZXh0KCkpO1xufVxuXG5mdW5jdGlvbiBsb25nU3RhY2tUcmFjZXNBdHRhY2hFeHRyYVRyYWNlKGVycm9yLCBpZ25vcmVTZWxmKSB7XG4gICAgaWYgKGNhbkF0dGFjaFRyYWNlKGVycm9yKSkge1xuICAgICAgICB2YXIgdHJhY2UgPSB0aGlzLl90cmFjZTtcbiAgICAgICAgaWYgKHRyYWNlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGlmIChpZ25vcmVTZWxmKSB0cmFjZSA9IHRyYWNlLl9wYXJlbnQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRyYWNlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRyYWNlLmF0dGFjaEV4dHJhVHJhY2UoZXJyb3IpO1xuICAgICAgICB9IGVsc2UgaWYgKCFlcnJvci5fX3N0YWNrQ2xlYW5lZF9fKSB7XG4gICAgICAgICAgICB2YXIgcGFyc2VkID0gcGFyc2VTdGFja0FuZE1lc3NhZ2UoZXJyb3IpO1xuICAgICAgICAgICAgdXRpbC5ub3RFbnVtZXJhYmxlUHJvcChlcnJvciwgXCJzdGFja1wiLFxuICAgICAgICAgICAgICAgIHBhcnNlZC5tZXNzYWdlICsgXCJcXG5cIiArIHBhcnNlZC5zdGFjay5qb2luKFwiXFxuXCIpKTtcbiAgICAgICAgICAgIHV0aWwubm90RW51bWVyYWJsZVByb3AoZXJyb3IsIFwiX19zdGFja0NsZWFuZWRfX1wiLCB0cnVlKTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuZnVuY3Rpb24gY2hlY2tGb3Jnb3R0ZW5SZXR1cm5zKHJldHVyblZhbHVlLCBwcm9taXNlQ3JlYXRlZCwgbmFtZSwgcHJvbWlzZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXJlbnQpIHtcbiAgICBpZiAocmV0dXJuVmFsdWUgPT09IHVuZGVmaW5lZCAmJiBwcm9taXNlQ3JlYXRlZCAhPT0gbnVsbCAmJlxuICAgICAgICB3Rm9yZ290dGVuUmV0dXJuKSB7XG4gICAgICAgIGlmIChwYXJlbnQgIT09IHVuZGVmaW5lZCAmJiBwYXJlbnQuX3JldHVybmVkTm9uVW5kZWZpbmVkKCkpIHJldHVybjtcbiAgICAgICAgaWYgKChwcm9taXNlLl9iaXRGaWVsZCAmIDY1NTM1KSA9PT0gMCkgcmV0dXJuO1xuXG4gICAgICAgIGlmIChuYW1lKSBuYW1lID0gbmFtZSArIFwiIFwiO1xuICAgICAgICB2YXIgaGFuZGxlckxpbmUgPSBcIlwiO1xuICAgICAgICB2YXIgY3JlYXRvckxpbmUgPSBcIlwiO1xuICAgICAgICBpZiAocHJvbWlzZUNyZWF0ZWQuX3RyYWNlKSB7XG4gICAgICAgICAgICB2YXIgdHJhY2VMaW5lcyA9IHByb21pc2VDcmVhdGVkLl90cmFjZS5zdGFjay5zcGxpdChcIlxcblwiKTtcbiAgICAgICAgICAgIHZhciBzdGFjayA9IGNsZWFuU3RhY2sodHJhY2VMaW5lcyk7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gc3RhY2subGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgICAgICAgICAgICB2YXIgbGluZSA9IHN0YWNrW2ldO1xuICAgICAgICAgICAgICAgIGlmICghbm9kZUZyYW1lUGF0dGVybi50ZXN0KGxpbmUpKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBsaW5lTWF0Y2hlcyA9IGxpbmUubWF0Y2gocGFyc2VMaW5lUGF0dGVybik7XG4gICAgICAgICAgICAgICAgICAgIGlmIChsaW5lTWF0Y2hlcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgaGFuZGxlckxpbmUgID0gXCJhdCBcIiArIGxpbmVNYXRjaGVzWzFdICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIjpcIiArIGxpbmVNYXRjaGVzWzJdICsgXCI6XCIgKyBsaW5lTWF0Y2hlc1szXSArIFwiIFwiO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHN0YWNrLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICB2YXIgZmlyc3RVc2VyTGluZSA9IHN0YWNrWzBdO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdHJhY2VMaW5lcy5sZW5ndGg7ICsraSkge1xuXG4gICAgICAgICAgICAgICAgICAgIGlmICh0cmFjZUxpbmVzW2ldID09PSBmaXJzdFVzZXJMaW5lKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaSA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjcmVhdG9yTGluZSA9IFwiXFxuXCIgKyB0cmFjZUxpbmVzW2kgLSAxXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG1zZyA9IFwiYSBwcm9taXNlIHdhcyBjcmVhdGVkIGluIGEgXCIgKyBuYW1lICtcbiAgICAgICAgICAgIFwiaGFuZGxlciBcIiArIGhhbmRsZXJMaW5lICsgXCJidXQgd2FzIG5vdCByZXR1cm5lZCBmcm9tIGl0LCBcIiArXG4gICAgICAgICAgICBcInNlZSBodHRwOi8vZ29vLmdsL3JScU1Vd1wiICtcbiAgICAgICAgICAgIGNyZWF0b3JMaW5lO1xuICAgICAgICBwcm9taXNlLl93YXJuKG1zZywgdHJ1ZSwgcHJvbWlzZUNyZWF0ZWQpO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gZGVwcmVjYXRlZChuYW1lLCByZXBsYWNlbWVudCkge1xuICAgIHZhciBtZXNzYWdlID0gbmFtZSArXG4gICAgICAgIFwiIGlzIGRlcHJlY2F0ZWQgYW5kIHdpbGwgYmUgcmVtb3ZlZCBpbiBhIGZ1dHVyZSB2ZXJzaW9uLlwiO1xuICAgIGlmIChyZXBsYWNlbWVudCkgbWVzc2FnZSArPSBcIiBVc2UgXCIgKyByZXBsYWNlbWVudCArIFwiIGluc3RlYWQuXCI7XG4gICAgcmV0dXJuIHdhcm4obWVzc2FnZSk7XG59XG5cbmZ1bmN0aW9uIHdhcm4obWVzc2FnZSwgc2hvdWxkVXNlT3duVHJhY2UsIHByb21pc2UpIHtcbiAgICBpZiAoIWNvbmZpZy53YXJuaW5ncykgcmV0dXJuO1xuICAgIHZhciB3YXJuaW5nID0gbmV3IFdhcm5pbmcobWVzc2FnZSk7XG4gICAgdmFyIGN0eDtcbiAgICBpZiAoc2hvdWxkVXNlT3duVHJhY2UpIHtcbiAgICAgICAgcHJvbWlzZS5fYXR0YWNoRXh0cmFUcmFjZSh3YXJuaW5nKTtcbiAgICB9IGVsc2UgaWYgKGNvbmZpZy5sb25nU3RhY2tUcmFjZXMgJiYgKGN0eCA9IFByb21pc2UuX3BlZWtDb250ZXh0KCkpKSB7XG4gICAgICAgIGN0eC5hdHRhY2hFeHRyYVRyYWNlKHdhcm5pbmcpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBwYXJzZWQgPSBwYXJzZVN0YWNrQW5kTWVzc2FnZSh3YXJuaW5nKTtcbiAgICAgICAgd2FybmluZy5zdGFjayA9IHBhcnNlZC5tZXNzYWdlICsgXCJcXG5cIiArIHBhcnNlZC5zdGFjay5qb2luKFwiXFxuXCIpO1xuICAgIH1cblxuICAgIGlmICghYWN0aXZlRmlyZUV2ZW50KFwid2FybmluZ1wiLCB3YXJuaW5nKSkge1xuICAgICAgICBmb3JtYXRBbmRMb2dFcnJvcih3YXJuaW5nLCBcIlwiLCB0cnVlKTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIHJlY29uc3RydWN0U3RhY2sobWVzc2FnZSwgc3RhY2tzKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdGFja3MubGVuZ3RoIC0gMTsgKytpKSB7XG4gICAgICAgIHN0YWNrc1tpXS5wdXNoKFwiRnJvbSBwcmV2aW91cyBldmVudDpcIik7XG4gICAgICAgIHN0YWNrc1tpXSA9IHN0YWNrc1tpXS5qb2luKFwiXFxuXCIpO1xuICAgIH1cbiAgICBpZiAoaSA8IHN0YWNrcy5sZW5ndGgpIHtcbiAgICAgICAgc3RhY2tzW2ldID0gc3RhY2tzW2ldLmpvaW4oXCJcXG5cIik7XG4gICAgfVxuICAgIHJldHVybiBtZXNzYWdlICsgXCJcXG5cIiArIHN0YWNrcy5qb2luKFwiXFxuXCIpO1xufVxuXG5mdW5jdGlvbiByZW1vdmVEdXBsaWNhdGVPckVtcHR5SnVtcHMoc3RhY2tzKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdGFja3MubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgaWYgKHN0YWNrc1tpXS5sZW5ndGggPT09IDAgfHxcbiAgICAgICAgICAgICgoaSArIDEgPCBzdGFja3MubGVuZ3RoKSAmJiBzdGFja3NbaV1bMF0gPT09IHN0YWNrc1tpKzFdWzBdKSkge1xuICAgICAgICAgICAgc3RhY2tzLnNwbGljZShpLCAxKTtcbiAgICAgICAgICAgIGktLTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuZnVuY3Rpb24gcmVtb3ZlQ29tbW9uUm9vdHMoc3RhY2tzKSB7XG4gICAgdmFyIGN1cnJlbnQgPSBzdGFja3NbMF07XG4gICAgZm9yICh2YXIgaSA9IDE7IGkgPCBzdGFja3MubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgdmFyIHByZXYgPSBzdGFja3NbaV07XG4gICAgICAgIHZhciBjdXJyZW50TGFzdEluZGV4ID0gY3VycmVudC5sZW5ndGggLSAxO1xuICAgICAgICB2YXIgY3VycmVudExhc3RMaW5lID0gY3VycmVudFtjdXJyZW50TGFzdEluZGV4XTtcbiAgICAgICAgdmFyIGNvbW1vblJvb3RNZWV0UG9pbnQgPSAtMTtcblxuICAgICAgICBmb3IgKHZhciBqID0gcHJldi5sZW5ndGggLSAxOyBqID49IDA7IC0taikge1xuICAgICAgICAgICAgaWYgKHByZXZbal0gPT09IGN1cnJlbnRMYXN0TGluZSkge1xuICAgICAgICAgICAgICAgIGNvbW1vblJvb3RNZWV0UG9pbnQgPSBqO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgZm9yICh2YXIgaiA9IGNvbW1vblJvb3RNZWV0UG9pbnQ7IGogPj0gMDsgLS1qKSB7XG4gICAgICAgICAgICB2YXIgbGluZSA9IHByZXZbal07XG4gICAgICAgICAgICBpZiAoY3VycmVudFtjdXJyZW50TGFzdEluZGV4XSA9PT0gbGluZSkge1xuICAgICAgICAgICAgICAgIGN1cnJlbnQucG9wKCk7XG4gICAgICAgICAgICAgICAgY3VycmVudExhc3RJbmRleC0tO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjdXJyZW50ID0gcHJldjtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGNsZWFuU3RhY2soc3RhY2spIHtcbiAgICB2YXIgcmV0ID0gW107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdGFjay5sZW5ndGg7ICsraSkge1xuICAgICAgICB2YXIgbGluZSA9IHN0YWNrW2ldO1xuICAgICAgICB2YXIgaXNUcmFjZUxpbmUgPSBcIiAgICAoTm8gc3RhY2sgdHJhY2UpXCIgPT09IGxpbmUgfHxcbiAgICAgICAgICAgIHN0YWNrRnJhbWVQYXR0ZXJuLnRlc3QobGluZSk7XG4gICAgICAgIHZhciBpc0ludGVybmFsRnJhbWUgPSBpc1RyYWNlTGluZSAmJiBzaG91bGRJZ25vcmUobGluZSk7XG4gICAgICAgIGlmIChpc1RyYWNlTGluZSAmJiAhaXNJbnRlcm5hbEZyYW1lKSB7XG4gICAgICAgICAgICBpZiAoaW5kZW50U3RhY2tGcmFtZXMgJiYgbGluZS5jaGFyQXQoMCkgIT09IFwiIFwiKSB7XG4gICAgICAgICAgICAgICAgbGluZSA9IFwiICAgIFwiICsgbGluZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldC5wdXNoKGxpbmUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXQ7XG59XG5cbmZ1bmN0aW9uIHN0YWNrRnJhbWVzQXNBcnJheShlcnJvcikge1xuICAgIHZhciBzdGFjayA9IGVycm9yLnN0YWNrLnJlcGxhY2UoL1xccyskL2csIFwiXCIpLnNwbGl0KFwiXFxuXCIpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc3RhY2subGVuZ3RoOyArK2kpIHtcbiAgICAgICAgdmFyIGxpbmUgPSBzdGFja1tpXTtcbiAgICAgICAgaWYgKFwiICAgIChObyBzdGFjayB0cmFjZSlcIiA9PT0gbGluZSB8fCBzdGFja0ZyYW1lUGF0dGVybi50ZXN0KGxpbmUpKSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoaSA+IDAgJiYgZXJyb3IubmFtZSAhPSBcIlN5bnRheEVycm9yXCIpIHtcbiAgICAgICAgc3RhY2sgPSBzdGFjay5zbGljZShpKTtcbiAgICB9XG4gICAgcmV0dXJuIHN0YWNrO1xufVxuXG5mdW5jdGlvbiBwYXJzZVN0YWNrQW5kTWVzc2FnZShlcnJvcikge1xuICAgIHZhciBzdGFjayA9IGVycm9yLnN0YWNrO1xuICAgIHZhciBtZXNzYWdlID0gZXJyb3IudG9TdHJpbmcoKTtcbiAgICBzdGFjayA9IHR5cGVvZiBzdGFjayA9PT0gXCJzdHJpbmdcIiAmJiBzdGFjay5sZW5ndGggPiAwXG4gICAgICAgICAgICAgICAgPyBzdGFja0ZyYW1lc0FzQXJyYXkoZXJyb3IpIDogW1wiICAgIChObyBzdGFjayB0cmFjZSlcIl07XG4gICAgcmV0dXJuIHtcbiAgICAgICAgbWVzc2FnZTogbWVzc2FnZSxcbiAgICAgICAgc3RhY2s6IGVycm9yLm5hbWUgPT0gXCJTeW50YXhFcnJvclwiID8gc3RhY2sgOiBjbGVhblN0YWNrKHN0YWNrKVxuICAgIH07XG59XG5cbmZ1bmN0aW9uIGZvcm1hdEFuZExvZ0Vycm9yKGVycm9yLCB0aXRsZSwgaXNTb2Z0KSB7XG4gICAgaWYgKHR5cGVvZiBjb25zb2xlICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgIHZhciBtZXNzYWdlO1xuICAgICAgICBpZiAodXRpbC5pc09iamVjdChlcnJvcikpIHtcbiAgICAgICAgICAgIHZhciBzdGFjayA9IGVycm9yLnN0YWNrO1xuICAgICAgICAgICAgbWVzc2FnZSA9IHRpdGxlICsgZm9ybWF0U3RhY2soc3RhY2ssIGVycm9yKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG1lc3NhZ2UgPSB0aXRsZSArIFN0cmluZyhlcnJvcik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBwcmludFdhcm5pbmcgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgcHJpbnRXYXJuaW5nKG1lc3NhZ2UsIGlzU29mdCk7XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGNvbnNvbGUubG9nID09PSBcImZ1bmN0aW9uXCIgfHxcbiAgICAgICAgICAgIHR5cGVvZiBjb25zb2xlLmxvZyA9PT0gXCJvYmplY3RcIikge1xuICAgICAgICAgICAgY29uc29sZS5sb2cobWVzc2FnZSk7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbmZ1bmN0aW9uIGZpcmVSZWplY3Rpb25FdmVudChuYW1lLCBsb2NhbEhhbmRsZXIsIHJlYXNvbiwgcHJvbWlzZSkge1xuICAgIHZhciBsb2NhbEV2ZW50RmlyZWQgPSBmYWxzZTtcbiAgICB0cnkge1xuICAgICAgICBpZiAodHlwZW9mIGxvY2FsSGFuZGxlciA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICBsb2NhbEV2ZW50RmlyZWQgPSB0cnVlO1xuICAgICAgICAgICAgaWYgKG5hbWUgPT09IFwicmVqZWN0aW9uSGFuZGxlZFwiKSB7XG4gICAgICAgICAgICAgICAgbG9jYWxIYW5kbGVyKHByb21pc2UpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBsb2NhbEhhbmRsZXIocmVhc29uLCBwcm9taXNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgYXN5bmMudGhyb3dMYXRlcihlKTtcbiAgICB9XG5cbiAgICBpZiAobmFtZSA9PT0gXCJ1bmhhbmRsZWRSZWplY3Rpb25cIikge1xuICAgICAgICBpZiAoIWFjdGl2ZUZpcmVFdmVudChuYW1lLCByZWFzb24sIHByb21pc2UpICYmICFsb2NhbEV2ZW50RmlyZWQpIHtcbiAgICAgICAgICAgIGZvcm1hdEFuZExvZ0Vycm9yKHJlYXNvbiwgXCJVbmhhbmRsZWQgcmVqZWN0aW9uIFwiKTtcbiAgICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAgIGFjdGl2ZUZpcmVFdmVudChuYW1lLCBwcm9taXNlKTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGZvcm1hdE5vbkVycm9yKG9iaikge1xuICAgIHZhciBzdHI7XG4gICAgaWYgKHR5cGVvZiBvYmogPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICBzdHIgPSBcIltmdW5jdGlvbiBcIiArXG4gICAgICAgICAgICAob2JqLm5hbWUgfHwgXCJhbm9ueW1vdXNcIikgK1xuICAgICAgICAgICAgXCJdXCI7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgc3RyID0gb2JqICYmIHR5cGVvZiBvYmoudG9TdHJpbmcgPT09IFwiZnVuY3Rpb25cIlxuICAgICAgICAgICAgPyBvYmoudG9TdHJpbmcoKSA6IHV0aWwudG9TdHJpbmcob2JqKTtcbiAgICAgICAgdmFyIHJ1c2VsZXNzVG9TdHJpbmcgPSAvXFxbb2JqZWN0IFthLXpBLVowLTkkX10rXFxdLztcbiAgICAgICAgaWYgKHJ1c2VsZXNzVG9TdHJpbmcudGVzdChzdHIpKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHZhciBuZXdTdHIgPSBKU09OLnN0cmluZ2lmeShvYmopO1xuICAgICAgICAgICAgICAgIHN0ciA9IG5ld1N0cjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoKGUpIHtcblxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChzdHIubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICBzdHIgPSBcIihlbXB0eSBhcnJheSlcIjtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gKFwiKDxcIiArIHNuaXAoc3RyKSArIFwiPiwgbm8gc3RhY2sgdHJhY2UpXCIpO1xufVxuXG5mdW5jdGlvbiBzbmlwKHN0cikge1xuICAgIHZhciBtYXhDaGFycyA9IDQxO1xuICAgIGlmIChzdHIubGVuZ3RoIDwgbWF4Q2hhcnMpIHtcbiAgICAgICAgcmV0dXJuIHN0cjtcbiAgICB9XG4gICAgcmV0dXJuIHN0ci5zdWJzdHIoMCwgbWF4Q2hhcnMgLSAzKSArIFwiLi4uXCI7XG59XG5cbmZ1bmN0aW9uIGxvbmdTdGFja1RyYWNlc0lzU3VwcG9ydGVkKCkge1xuICAgIHJldHVybiB0eXBlb2YgY2FwdHVyZVN0YWNrVHJhY2UgPT09IFwiZnVuY3Rpb25cIjtcbn1cblxudmFyIHNob3VsZElnbm9yZSA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gZmFsc2U7IH07XG52YXIgcGFyc2VMaW5lSW5mb1JlZ2V4ID0gL1tcXC88XFwoXShbXjpcXC9dKyk6KFxcZCspOig/OlxcZCspXFwpP1xccyokLztcbmZ1bmN0aW9uIHBhcnNlTGluZUluZm8obGluZSkge1xuICAgIHZhciBtYXRjaGVzID0gbGluZS5tYXRjaChwYXJzZUxpbmVJbmZvUmVnZXgpO1xuICAgIGlmIChtYXRjaGVzKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBmaWxlTmFtZTogbWF0Y2hlc1sxXSxcbiAgICAgICAgICAgIGxpbmU6IHBhcnNlSW50KG1hdGNoZXNbMl0sIDEwKVxuICAgICAgICB9O1xuICAgIH1cbn1cblxuZnVuY3Rpb24gc2V0Qm91bmRzKGZpcnN0TGluZUVycm9yLCBsYXN0TGluZUVycm9yKSB7XG4gICAgaWYgKCFsb25nU3RhY2tUcmFjZXNJc1N1cHBvcnRlZCgpKSByZXR1cm47XG4gICAgdmFyIGZpcnN0U3RhY2tMaW5lcyA9IGZpcnN0TGluZUVycm9yLnN0YWNrLnNwbGl0KFwiXFxuXCIpO1xuICAgIHZhciBsYXN0U3RhY2tMaW5lcyA9IGxhc3RMaW5lRXJyb3Iuc3RhY2suc3BsaXQoXCJcXG5cIik7XG4gICAgdmFyIGZpcnN0SW5kZXggPSAtMTtcbiAgICB2YXIgbGFzdEluZGV4ID0gLTE7XG4gICAgdmFyIGZpcnN0RmlsZU5hbWU7XG4gICAgdmFyIGxhc3RGaWxlTmFtZTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGZpcnN0U3RhY2tMaW5lcy5sZW5ndGg7ICsraSkge1xuICAgICAgICB2YXIgcmVzdWx0ID0gcGFyc2VMaW5lSW5mbyhmaXJzdFN0YWNrTGluZXNbaV0pO1xuICAgICAgICBpZiAocmVzdWx0KSB7XG4gICAgICAgICAgICBmaXJzdEZpbGVOYW1lID0gcmVzdWx0LmZpbGVOYW1lO1xuICAgICAgICAgICAgZmlyc3RJbmRleCA9IHJlc3VsdC5saW5lO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsYXN0U3RhY2tMaW5lcy5sZW5ndGg7ICsraSkge1xuICAgICAgICB2YXIgcmVzdWx0ID0gcGFyc2VMaW5lSW5mbyhsYXN0U3RhY2tMaW5lc1tpXSk7XG4gICAgICAgIGlmIChyZXN1bHQpIHtcbiAgICAgICAgICAgIGxhc3RGaWxlTmFtZSA9IHJlc3VsdC5maWxlTmFtZTtcbiAgICAgICAgICAgIGxhc3RJbmRleCA9IHJlc3VsdC5saW5lO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKGZpcnN0SW5kZXggPCAwIHx8IGxhc3RJbmRleCA8IDAgfHwgIWZpcnN0RmlsZU5hbWUgfHwgIWxhc3RGaWxlTmFtZSB8fFxuICAgICAgICBmaXJzdEZpbGVOYW1lICE9PSBsYXN0RmlsZU5hbWUgfHwgZmlyc3RJbmRleCA+PSBsYXN0SW5kZXgpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHNob3VsZElnbm9yZSA9IGZ1bmN0aW9uKGxpbmUpIHtcbiAgICAgICAgaWYgKGJsdWViaXJkRnJhbWVQYXR0ZXJuLnRlc3QobGluZSkpIHJldHVybiB0cnVlO1xuICAgICAgICB2YXIgaW5mbyA9IHBhcnNlTGluZUluZm8obGluZSk7XG4gICAgICAgIGlmIChpbmZvKSB7XG4gICAgICAgICAgICBpZiAoaW5mby5maWxlTmFtZSA9PT0gZmlyc3RGaWxlTmFtZSAmJlxuICAgICAgICAgICAgICAgIChmaXJzdEluZGV4IDw9IGluZm8ubGluZSAmJiBpbmZvLmxpbmUgPD0gbGFzdEluZGV4KSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9O1xufVxuXG5mdW5jdGlvbiBDYXB0dXJlZFRyYWNlKHBhcmVudCkge1xuICAgIHRoaXMuX3BhcmVudCA9IHBhcmVudDtcbiAgICB0aGlzLl9wcm9taXNlc0NyZWF0ZWQgPSAwO1xuICAgIHZhciBsZW5ndGggPSB0aGlzLl9sZW5ndGggPSAxICsgKHBhcmVudCA9PT0gdW5kZWZpbmVkID8gMCA6IHBhcmVudC5fbGVuZ3RoKTtcbiAgICBjYXB0dXJlU3RhY2tUcmFjZSh0aGlzLCBDYXB0dXJlZFRyYWNlKTtcbiAgICBpZiAobGVuZ3RoID4gMzIpIHRoaXMudW5jeWNsZSgpO1xufVxudXRpbC5pbmhlcml0cyhDYXB0dXJlZFRyYWNlLCBFcnJvcik7XG5Db250ZXh0LkNhcHR1cmVkVHJhY2UgPSBDYXB0dXJlZFRyYWNlO1xuXG5DYXB0dXJlZFRyYWNlLnByb3RvdHlwZS51bmN5Y2xlID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGxlbmd0aCA9IHRoaXMuX2xlbmd0aDtcbiAgICBpZiAobGVuZ3RoIDwgMikgcmV0dXJuO1xuICAgIHZhciBub2RlcyA9IFtdO1xuICAgIHZhciBzdGFja1RvSW5kZXggPSB7fTtcblxuICAgIGZvciAodmFyIGkgPSAwLCBub2RlID0gdGhpczsgbm9kZSAhPT0gdW5kZWZpbmVkOyArK2kpIHtcbiAgICAgICAgbm9kZXMucHVzaChub2RlKTtcbiAgICAgICAgbm9kZSA9IG5vZGUuX3BhcmVudDtcbiAgICB9XG4gICAgbGVuZ3RoID0gdGhpcy5fbGVuZ3RoID0gaTtcbiAgICBmb3IgKHZhciBpID0gbGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgICAgdmFyIHN0YWNrID0gbm9kZXNbaV0uc3RhY2s7XG4gICAgICAgIGlmIChzdGFja1RvSW5kZXhbc3RhY2tdID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHN0YWNrVG9JbmRleFtzdGFja10gPSBpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyArK2kpIHtcbiAgICAgICAgdmFyIGN1cnJlbnRTdGFjayA9IG5vZGVzW2ldLnN0YWNrO1xuICAgICAgICB2YXIgaW5kZXggPSBzdGFja1RvSW5kZXhbY3VycmVudFN0YWNrXTtcbiAgICAgICAgaWYgKGluZGV4ICE9PSB1bmRlZmluZWQgJiYgaW5kZXggIT09IGkpIHtcbiAgICAgICAgICAgIGlmIChpbmRleCA+IDApIHtcbiAgICAgICAgICAgICAgICBub2Rlc1tpbmRleCAtIDFdLl9wYXJlbnQgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgbm9kZXNbaW5kZXggLSAxXS5fbGVuZ3RoID0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG5vZGVzW2ldLl9wYXJlbnQgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICBub2Rlc1tpXS5fbGVuZ3RoID0gMTtcbiAgICAgICAgICAgIHZhciBjeWNsZUVkZ2VOb2RlID0gaSA+IDAgPyBub2Rlc1tpIC0gMV0gOiB0aGlzO1xuXG4gICAgICAgICAgICBpZiAoaW5kZXggPCBsZW5ndGggLSAxKSB7XG4gICAgICAgICAgICAgICAgY3ljbGVFZGdlTm9kZS5fcGFyZW50ID0gbm9kZXNbaW5kZXggKyAxXTtcbiAgICAgICAgICAgICAgICBjeWNsZUVkZ2VOb2RlLl9wYXJlbnQudW5jeWNsZSgpO1xuICAgICAgICAgICAgICAgIGN5Y2xlRWRnZU5vZGUuX2xlbmd0aCA9XG4gICAgICAgICAgICAgICAgICAgIGN5Y2xlRWRnZU5vZGUuX3BhcmVudC5fbGVuZ3RoICsgMTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgY3ljbGVFZGdlTm9kZS5fcGFyZW50ID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgIGN5Y2xlRWRnZU5vZGUuX2xlbmd0aCA9IDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgY3VycmVudENoaWxkTGVuZ3RoID0gY3ljbGVFZGdlTm9kZS5fbGVuZ3RoICsgMTtcbiAgICAgICAgICAgIGZvciAodmFyIGogPSBpIC0gMjsgaiA+PSAwOyAtLWopIHtcbiAgICAgICAgICAgICAgICBub2Rlc1tqXS5fbGVuZ3RoID0gY3VycmVudENoaWxkTGVuZ3RoO1xuICAgICAgICAgICAgICAgIGN1cnJlbnRDaGlsZExlbmd0aCsrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgfVxufTtcblxuQ2FwdHVyZWRUcmFjZS5wcm90b3R5cGUuYXR0YWNoRXh0cmFUcmFjZSA9IGZ1bmN0aW9uKGVycm9yKSB7XG4gICAgaWYgKGVycm9yLl9fc3RhY2tDbGVhbmVkX18pIHJldHVybjtcbiAgICB0aGlzLnVuY3ljbGUoKTtcbiAgICB2YXIgcGFyc2VkID0gcGFyc2VTdGFja0FuZE1lc3NhZ2UoZXJyb3IpO1xuICAgIHZhciBtZXNzYWdlID0gcGFyc2VkLm1lc3NhZ2U7XG4gICAgdmFyIHN0YWNrcyA9IFtwYXJzZWQuc3RhY2tdO1xuXG4gICAgdmFyIHRyYWNlID0gdGhpcztcbiAgICB3aGlsZSAodHJhY2UgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBzdGFja3MucHVzaChjbGVhblN0YWNrKHRyYWNlLnN0YWNrLnNwbGl0KFwiXFxuXCIpKSk7XG4gICAgICAgIHRyYWNlID0gdHJhY2UuX3BhcmVudDtcbiAgICB9XG4gICAgcmVtb3ZlQ29tbW9uUm9vdHMoc3RhY2tzKTtcbiAgICByZW1vdmVEdXBsaWNhdGVPckVtcHR5SnVtcHMoc3RhY2tzKTtcbiAgICB1dGlsLm5vdEVudW1lcmFibGVQcm9wKGVycm9yLCBcInN0YWNrXCIsIHJlY29uc3RydWN0U3RhY2sobWVzc2FnZSwgc3RhY2tzKSk7XG4gICAgdXRpbC5ub3RFbnVtZXJhYmxlUHJvcChlcnJvciwgXCJfX3N0YWNrQ2xlYW5lZF9fXCIsIHRydWUpO1xufTtcblxudmFyIGNhcHR1cmVTdGFja1RyYWNlID0gKGZ1bmN0aW9uIHN0YWNrRGV0ZWN0aW9uKCkge1xuICAgIHZhciB2OHN0YWNrRnJhbWVQYXR0ZXJuID0gL15cXHMqYXRcXHMqLztcbiAgICB2YXIgdjhzdGFja0Zvcm1hdHRlciA9IGZ1bmN0aW9uKHN0YWNrLCBlcnJvcikge1xuICAgICAgICBpZiAodHlwZW9mIHN0YWNrID09PSBcInN0cmluZ1wiKSByZXR1cm4gc3RhY2s7XG5cbiAgICAgICAgaWYgKGVycm9yLm5hbWUgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgZXJyb3IubWVzc2FnZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gZXJyb3IudG9TdHJpbmcoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZm9ybWF0Tm9uRXJyb3IoZXJyb3IpO1xuICAgIH07XG5cbiAgICBpZiAodHlwZW9mIEVycm9yLnN0YWNrVHJhY2VMaW1pdCA9PT0gXCJudW1iZXJcIiAmJlxuICAgICAgICB0eXBlb2YgRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICBFcnJvci5zdGFja1RyYWNlTGltaXQgKz0gNjtcbiAgICAgICAgc3RhY2tGcmFtZVBhdHRlcm4gPSB2OHN0YWNrRnJhbWVQYXR0ZXJuO1xuICAgICAgICBmb3JtYXRTdGFjayA9IHY4c3RhY2tGb3JtYXR0ZXI7XG4gICAgICAgIHZhciBjYXB0dXJlU3RhY2tUcmFjZSA9IEVycm9yLmNhcHR1cmVTdGFja1RyYWNlO1xuXG4gICAgICAgIHNob3VsZElnbm9yZSA9IGZ1bmN0aW9uKGxpbmUpIHtcbiAgICAgICAgICAgIHJldHVybiBibHVlYmlyZEZyYW1lUGF0dGVybi50ZXN0KGxpbmUpO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24ocmVjZWl2ZXIsIGlnbm9yZVVudGlsKSB7XG4gICAgICAgICAgICBFcnJvci5zdGFja1RyYWNlTGltaXQgKz0gNjtcbiAgICAgICAgICAgIGNhcHR1cmVTdGFja1RyYWNlKHJlY2VpdmVyLCBpZ25vcmVVbnRpbCk7XG4gICAgICAgICAgICBFcnJvci5zdGFja1RyYWNlTGltaXQgLT0gNjtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgdmFyIGVyciA9IG5ldyBFcnJvcigpO1xuXG4gICAgaWYgKHR5cGVvZiBlcnIuc3RhY2sgPT09IFwic3RyaW5nXCIgJiZcbiAgICAgICAgZXJyLnN0YWNrLnNwbGl0KFwiXFxuXCIpWzBdLmluZGV4T2YoXCJzdGFja0RldGVjdGlvbkBcIikgPj0gMCkge1xuICAgICAgICBzdGFja0ZyYW1lUGF0dGVybiA9IC9ALztcbiAgICAgICAgZm9ybWF0U3RhY2sgPSB2OHN0YWNrRm9ybWF0dGVyO1xuICAgICAgICBpbmRlbnRTdGFja0ZyYW1lcyA9IHRydWU7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiBjYXB0dXJlU3RhY2tUcmFjZShvKSB7XG4gICAgICAgICAgICBvLnN0YWNrID0gbmV3IEVycm9yKCkuc3RhY2s7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgdmFyIGhhc1N0YWNrQWZ0ZXJUaHJvdztcbiAgICB0cnkgeyB0aHJvdyBuZXcgRXJyb3IoKTsgfVxuICAgIGNhdGNoKGUpIHtcbiAgICAgICAgaGFzU3RhY2tBZnRlclRocm93ID0gKFwic3RhY2tcIiBpbiBlKTtcbiAgICB9XG4gICAgaWYgKCEoXCJzdGFja1wiIGluIGVycikgJiYgaGFzU3RhY2tBZnRlclRocm93ICYmXG4gICAgICAgIHR5cGVvZiBFcnJvci5zdGFja1RyYWNlTGltaXQgPT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgc3RhY2tGcmFtZVBhdHRlcm4gPSB2OHN0YWNrRnJhbWVQYXR0ZXJuO1xuICAgICAgICBmb3JtYXRTdGFjayA9IHY4c3RhY2tGb3JtYXR0ZXI7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiBjYXB0dXJlU3RhY2tUcmFjZShvKSB7XG4gICAgICAgICAgICBFcnJvci5zdGFja1RyYWNlTGltaXQgKz0gNjtcbiAgICAgICAgICAgIHRyeSB7IHRocm93IG5ldyBFcnJvcigpOyB9XG4gICAgICAgICAgICBjYXRjaChlKSB7IG8uc3RhY2sgPSBlLnN0YWNrOyB9XG4gICAgICAgICAgICBFcnJvci5zdGFja1RyYWNlTGltaXQgLT0gNjtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBmb3JtYXRTdGFjayA9IGZ1bmN0aW9uKHN0YWNrLCBlcnJvcikge1xuICAgICAgICBpZiAodHlwZW9mIHN0YWNrID09PSBcInN0cmluZ1wiKSByZXR1cm4gc3RhY2s7XG5cbiAgICAgICAgaWYgKCh0eXBlb2YgZXJyb3IgPT09IFwib2JqZWN0XCIgfHxcbiAgICAgICAgICAgIHR5cGVvZiBlcnJvciA9PT0gXCJmdW5jdGlvblwiKSAmJlxuICAgICAgICAgICAgZXJyb3IubmFtZSAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICBlcnJvci5tZXNzYWdlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBlcnJvci50b1N0cmluZygpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmb3JtYXROb25FcnJvcihlcnJvcik7XG4gICAgfTtcblxuICAgIHJldHVybiBudWxsO1xuXG59KShbXSk7XG5cbmlmICh0eXBlb2YgY29uc29sZSAhPT0gXCJ1bmRlZmluZWRcIiAmJiB0eXBlb2YgY29uc29sZS53YXJuICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgcHJpbnRXYXJuaW5nID0gZnVuY3Rpb24gKG1lc3NhZ2UpIHtcbiAgICAgICAgY29uc29sZS53YXJuKG1lc3NhZ2UpO1xuICAgIH07XG4gICAgaWYgKHV0aWwuaXNOb2RlICYmIHByb2Nlc3Muc3RkZXJyLmlzVFRZKSB7XG4gICAgICAgIHByaW50V2FybmluZyA9IGZ1bmN0aW9uKG1lc3NhZ2UsIGlzU29mdCkge1xuICAgICAgICAgICAgdmFyIGNvbG9yID0gaXNTb2Z0ID8gXCJcXHUwMDFiWzMzbVwiIDogXCJcXHUwMDFiWzMxbVwiO1xuICAgICAgICAgICAgY29uc29sZS53YXJuKGNvbG9yICsgbWVzc2FnZSArIFwiXFx1MDAxYlswbVxcblwiKTtcbiAgICAgICAgfTtcbiAgICB9IGVsc2UgaWYgKCF1dGlsLmlzTm9kZSAmJiB0eXBlb2YgKG5ldyBFcnJvcigpLnN0YWNrKSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICBwcmludFdhcm5pbmcgPSBmdW5jdGlvbihtZXNzYWdlLCBpc1NvZnQpIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybihcIiVjXCIgKyBtZXNzYWdlLFxuICAgICAgICAgICAgICAgICAgICAgICAgaXNTb2Z0ID8gXCJjb2xvcjogZGFya29yYW5nZVwiIDogXCJjb2xvcjogcmVkXCIpO1xuICAgICAgICB9O1xuICAgIH1cbn1cblxudmFyIGNvbmZpZyA9IHtcbiAgICB3YXJuaW5nczogd2FybmluZ3MsXG4gICAgbG9uZ1N0YWNrVHJhY2VzOiBmYWxzZSxcbiAgICBjYW5jZWxsYXRpb246IGZhbHNlLFxuICAgIG1vbml0b3Jpbmc6IGZhbHNlXG59O1xuXG5pZiAobG9uZ1N0YWNrVHJhY2VzKSBQcm9taXNlLmxvbmdTdGFja1RyYWNlcygpO1xuXG5yZXR1cm4ge1xuICAgIGxvbmdTdGFja1RyYWNlczogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBjb25maWcubG9uZ1N0YWNrVHJhY2VzO1xuICAgIH0sXG4gICAgd2FybmluZ3M6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gY29uZmlnLndhcm5pbmdzO1xuICAgIH0sXG4gICAgY2FuY2VsbGF0aW9uOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIGNvbmZpZy5jYW5jZWxsYXRpb247XG4gICAgfSxcbiAgICBtb25pdG9yaW5nOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIGNvbmZpZy5tb25pdG9yaW5nO1xuICAgIH0sXG4gICAgcHJvcGFnYXRlRnJvbUZ1bmN0aW9uOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHByb3BhZ2F0ZUZyb21GdW5jdGlvbjtcbiAgICB9LFxuICAgIGJvdW5kVmFsdWVGdW5jdGlvbjogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBib3VuZFZhbHVlRnVuY3Rpb247XG4gICAgfSxcbiAgICBjaGVja0ZvcmdvdHRlblJldHVybnM6IGNoZWNrRm9yZ290dGVuUmV0dXJucyxcbiAgICBzZXRCb3VuZHM6IHNldEJvdW5kcyxcbiAgICB3YXJuOiB3YXJuLFxuICAgIGRlcHJlY2F0ZWQ6IGRlcHJlY2F0ZWQsXG4gICAgQ2FwdHVyZWRUcmFjZTogQ2FwdHVyZWRUcmFjZSxcbiAgICBmaXJlRG9tRXZlbnQ6IGZpcmVEb21FdmVudCxcbiAgICBmaXJlR2xvYmFsRXZlbnQ6IGZpcmVHbG9iYWxFdmVudFxufTtcbn07XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvYmx1ZWJpcmQvanMvcmVsZWFzZS9kZWJ1Z2dhYmlsaXR5LmpzIiwiXCJ1c2Ugc3RyaWN0XCI7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKFByb21pc2UsIHRyeUNvbnZlcnRUb1Byb21pc2UsIE5FWFRfRklMVEVSKSB7XG52YXIgdXRpbCA9IHJlcXVpcmUoXCIuL3V0aWxcIik7XG52YXIgQ2FuY2VsbGF0aW9uRXJyb3IgPSBQcm9taXNlLkNhbmNlbGxhdGlvbkVycm9yO1xudmFyIGVycm9yT2JqID0gdXRpbC5lcnJvck9iajtcbnZhciBjYXRjaEZpbHRlciA9IHJlcXVpcmUoXCIuL2NhdGNoX2ZpbHRlclwiKShORVhUX0ZJTFRFUik7XG5cbmZ1bmN0aW9uIFBhc3NUaHJvdWdoSGFuZGxlckNvbnRleHQocHJvbWlzZSwgdHlwZSwgaGFuZGxlcikge1xuICAgIHRoaXMucHJvbWlzZSA9IHByb21pc2U7XG4gICAgdGhpcy50eXBlID0gdHlwZTtcbiAgICB0aGlzLmhhbmRsZXIgPSBoYW5kbGVyO1xuICAgIHRoaXMuY2FsbGVkID0gZmFsc2U7XG4gICAgdGhpcy5jYW5jZWxQcm9taXNlID0gbnVsbDtcbn1cblxuUGFzc1Rocm91Z2hIYW5kbGVyQ29udGV4dC5wcm90b3R5cGUuaXNGaW5hbGx5SGFuZGxlciA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLnR5cGUgPT09IDA7XG59O1xuXG5mdW5jdGlvbiBGaW5hbGx5SGFuZGxlckNhbmNlbFJlYWN0aW9uKGZpbmFsbHlIYW5kbGVyKSB7XG4gICAgdGhpcy5maW5hbGx5SGFuZGxlciA9IGZpbmFsbHlIYW5kbGVyO1xufVxuXG5GaW5hbGx5SGFuZGxlckNhbmNlbFJlYWN0aW9uLnByb3RvdHlwZS5fcmVzdWx0Q2FuY2VsbGVkID0gZnVuY3Rpb24oKSB7XG4gICAgY2hlY2tDYW5jZWwodGhpcy5maW5hbGx5SGFuZGxlcik7XG59O1xuXG5mdW5jdGlvbiBjaGVja0NhbmNlbChjdHgsIHJlYXNvbikge1xuICAgIGlmIChjdHguY2FuY2VsUHJvbWlzZSAhPSBudWxsKSB7XG4gICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgY3R4LmNhbmNlbFByb21pc2UuX3JlamVjdChyZWFzb24pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY3R4LmNhbmNlbFByb21pc2UuX2NhbmNlbCgpO1xuICAgICAgICB9XG4gICAgICAgIGN0eC5jYW5jZWxQcm9taXNlID0gbnVsbDtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gc3VjY2VlZCgpIHtcbiAgICByZXR1cm4gZmluYWxseUhhbmRsZXIuY2FsbCh0aGlzLCB0aGlzLnByb21pc2UuX3RhcmdldCgpLl9zZXR0bGVkVmFsdWUoKSk7XG59XG5mdW5jdGlvbiBmYWlsKHJlYXNvbikge1xuICAgIGlmIChjaGVja0NhbmNlbCh0aGlzLCByZWFzb24pKSByZXR1cm47XG4gICAgZXJyb3JPYmouZSA9IHJlYXNvbjtcbiAgICByZXR1cm4gZXJyb3JPYmo7XG59XG5mdW5jdGlvbiBmaW5hbGx5SGFuZGxlcihyZWFzb25PclZhbHVlKSB7XG4gICAgdmFyIHByb21pc2UgPSB0aGlzLnByb21pc2U7XG4gICAgdmFyIGhhbmRsZXIgPSB0aGlzLmhhbmRsZXI7XG5cbiAgICBpZiAoIXRoaXMuY2FsbGVkKSB7XG4gICAgICAgIHRoaXMuY2FsbGVkID0gdHJ1ZTtcbiAgICAgICAgdmFyIHJldCA9IHRoaXMuaXNGaW5hbGx5SGFuZGxlcigpXG4gICAgICAgICAgICA/IGhhbmRsZXIuY2FsbChwcm9taXNlLl9ib3VuZFZhbHVlKCkpXG4gICAgICAgICAgICA6IGhhbmRsZXIuY2FsbChwcm9taXNlLl9ib3VuZFZhbHVlKCksIHJlYXNvbk9yVmFsdWUpO1xuICAgICAgICBpZiAocmV0ID09PSBORVhUX0ZJTFRFUikge1xuICAgICAgICAgICAgcmV0dXJuIHJldDtcbiAgICAgICAgfSBlbHNlIGlmIChyZXQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcHJvbWlzZS5fc2V0UmV0dXJuZWROb25VbmRlZmluZWQoKTtcbiAgICAgICAgICAgIHZhciBtYXliZVByb21pc2UgPSB0cnlDb252ZXJ0VG9Qcm9taXNlKHJldCwgcHJvbWlzZSk7XG4gICAgICAgICAgICBpZiAobWF5YmVQcm9taXNlIGluc3RhbmNlb2YgUHJvbWlzZSkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmNhbmNlbFByb21pc2UgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAobWF5YmVQcm9taXNlLl9pc0NhbmNlbGxlZCgpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcmVhc29uID1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXcgQ2FuY2VsbGF0aW9uRXJyb3IoXCJsYXRlIGNhbmNlbGxhdGlvbiBvYnNlcnZlclwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb21pc2UuX2F0dGFjaEV4dHJhVHJhY2UocmVhc29uKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yT2JqLmUgPSByZWFzb247XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZXJyb3JPYmo7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAobWF5YmVQcm9taXNlLmlzUGVuZGluZygpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtYXliZVByb21pc2UuX2F0dGFjaENhbmNlbGxhdGlvbkNhbGxiYWNrKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ldyBGaW5hbGx5SGFuZGxlckNhbmNlbFJlYWN0aW9uKHRoaXMpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gbWF5YmVQcm9taXNlLl90aGVuKFxuICAgICAgICAgICAgICAgICAgICBzdWNjZWVkLCBmYWlsLCB1bmRlZmluZWQsIHRoaXMsIHVuZGVmaW5lZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAocHJvbWlzZS5pc1JlamVjdGVkKCkpIHtcbiAgICAgICAgY2hlY2tDYW5jZWwodGhpcyk7XG4gICAgICAgIGVycm9yT2JqLmUgPSByZWFzb25PclZhbHVlO1xuICAgICAgICByZXR1cm4gZXJyb3JPYmo7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgY2hlY2tDYW5jZWwodGhpcyk7XG4gICAgICAgIHJldHVybiByZWFzb25PclZhbHVlO1xuICAgIH1cbn1cblxuUHJvbWlzZS5wcm90b3R5cGUuX3Bhc3NUaHJvdWdoID0gZnVuY3Rpb24oaGFuZGxlciwgdHlwZSwgc3VjY2VzcywgZmFpbCkge1xuICAgIGlmICh0eXBlb2YgaGFuZGxlciAhPT0gXCJmdW5jdGlvblwiKSByZXR1cm4gdGhpcy50aGVuKCk7XG4gICAgcmV0dXJuIHRoaXMuX3RoZW4oc3VjY2VzcyxcbiAgICAgICAgICAgICAgICAgICAgICBmYWlsLFxuICAgICAgICAgICAgICAgICAgICAgIHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICAgICAgICBuZXcgUGFzc1Rocm91Z2hIYW5kbGVyQ29udGV4dCh0aGlzLCB0eXBlLCBoYW5kbGVyKSxcbiAgICAgICAgICAgICAgICAgICAgICB1bmRlZmluZWQpO1xufTtcblxuUHJvbWlzZS5wcm90b3R5cGUubGFzdGx5ID1cblByb21pc2UucHJvdG90eXBlW1wiZmluYWxseVwiXSA9IGZ1bmN0aW9uIChoYW5kbGVyKSB7XG4gICAgcmV0dXJuIHRoaXMuX3Bhc3NUaHJvdWdoKGhhbmRsZXIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZpbmFsbHlIYW5kbGVyLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmaW5hbGx5SGFuZGxlcik7XG59O1xuXG5cblByb21pc2UucHJvdG90eXBlLnRhcCA9IGZ1bmN0aW9uIChoYW5kbGVyKSB7XG4gICAgcmV0dXJuIHRoaXMuX3Bhc3NUaHJvdWdoKGhhbmRsZXIsIDEsIGZpbmFsbHlIYW5kbGVyKTtcbn07XG5cblByb21pc2UucHJvdG90eXBlLnRhcENhdGNoID0gZnVuY3Rpb24gKGhhbmRsZXJPclByZWRpY2F0ZSkge1xuICAgIHZhciBsZW4gPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgIGlmKGxlbiA9PT0gMSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcGFzc1Rocm91Z2goaGFuZGxlck9yUHJlZGljYXRlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgMSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZpbmFsbHlIYW5kbGVyKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICAgdmFyIGNhdGNoSW5zdGFuY2VzID0gbmV3IEFycmF5KGxlbiAtIDEpLFxuICAgICAgICAgICAgaiA9IDAsIGk7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW4gLSAxOyArK2kpIHtcbiAgICAgICAgICAgIHZhciBpdGVtID0gYXJndW1lbnRzW2ldO1xuICAgICAgICAgICAgaWYgKHV0aWwuaXNPYmplY3QoaXRlbSkpIHtcbiAgICAgICAgICAgICAgICBjYXRjaEluc3RhbmNlc1tqKytdID0gaXRlbTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KG5ldyBUeXBlRXJyb3IoXG4gICAgICAgICAgICAgICAgICAgIFwidGFwQ2F0Y2ggc3RhdGVtZW50IHByZWRpY2F0ZTogXCJcbiAgICAgICAgICAgICAgICAgICAgKyBcImV4cGVjdGluZyBhbiBvYmplY3QgYnV0IGdvdCBcIiArIHV0aWwuY2xhc3NTdHJpbmcoaXRlbSlcbiAgICAgICAgICAgICAgICApKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjYXRjaEluc3RhbmNlcy5sZW5ndGggPSBqO1xuICAgICAgICB2YXIgaGFuZGxlciA9IGFyZ3VtZW50c1tpXTtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3Bhc3NUaHJvdWdoKGNhdGNoRmlsdGVyKGNhdGNoSW5zdGFuY2VzLCBoYW5kbGVyLCB0aGlzKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDEsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmaW5hbGx5SGFuZGxlcik7XG4gICAgfVxuXG59O1xuXG5yZXR1cm4gUGFzc1Rocm91Z2hIYW5kbGVyQ29udGV4dDtcbn07XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvYmx1ZWJpcmQvanMvcmVsZWFzZS9maW5hbGx5LmpzIiwiXCJ1c2Ugc3RyaWN0XCI7XG5tb2R1bGUuZXhwb3J0cyA9XG5mdW5jdGlvbihQcm9taXNlLCBJTlRFUk5BTCwgdHJ5Q29udmVydFRvUHJvbWlzZSwgYXBpUmVqZWN0aW9uLCBkZWJ1Zykge1xudmFyIHV0aWwgPSByZXF1aXJlKFwiLi91dGlsXCIpO1xudmFyIHRyeUNhdGNoID0gdXRpbC50cnlDYXRjaDtcblxuUHJvbWlzZS5tZXRob2QgPSBmdW5jdGlvbiAoZm4pIHtcbiAgICBpZiAodHlwZW9mIGZuICE9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgdGhyb3cgbmV3IFByb21pc2UuVHlwZUVycm9yKFwiZXhwZWN0aW5nIGEgZnVuY3Rpb24gYnV0IGdvdCBcIiArIHV0aWwuY2xhc3NTdHJpbmcoZm4pKTtcbiAgICB9XG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHJldCA9IG5ldyBQcm9taXNlKElOVEVSTkFMKTtcbiAgICAgICAgcmV0Ll9jYXB0dXJlU3RhY2tUcmFjZSgpO1xuICAgICAgICByZXQuX3B1c2hDb250ZXh0KCk7XG4gICAgICAgIHZhciB2YWx1ZSA9IHRyeUNhdGNoKGZuKS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICB2YXIgcHJvbWlzZUNyZWF0ZWQgPSByZXQuX3BvcENvbnRleHQoKTtcbiAgICAgICAgZGVidWcuY2hlY2tGb3Jnb3R0ZW5SZXR1cm5zKFxuICAgICAgICAgICAgdmFsdWUsIHByb21pc2VDcmVhdGVkLCBcIlByb21pc2UubWV0aG9kXCIsIHJldCk7XG4gICAgICAgIHJldC5fcmVzb2x2ZUZyb21TeW5jVmFsdWUodmFsdWUpO1xuICAgICAgICByZXR1cm4gcmV0O1xuICAgIH07XG59O1xuXG5Qcm9taXNlLmF0dGVtcHQgPSBQcm9taXNlW1widHJ5XCJdID0gZnVuY3Rpb24gKGZuKSB7XG4gICAgaWYgKHR5cGVvZiBmbiAhPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIHJldHVybiBhcGlSZWplY3Rpb24oXCJleHBlY3RpbmcgYSBmdW5jdGlvbiBidXQgZ290IFwiICsgdXRpbC5jbGFzc1N0cmluZyhmbikpO1xuICAgIH1cbiAgICB2YXIgcmV0ID0gbmV3IFByb21pc2UoSU5URVJOQUwpO1xuICAgIHJldC5fY2FwdHVyZVN0YWNrVHJhY2UoKTtcbiAgICByZXQuX3B1c2hDb250ZXh0KCk7XG4gICAgdmFyIHZhbHVlO1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMSkge1xuICAgICAgICBkZWJ1Zy5kZXByZWNhdGVkKFwiY2FsbGluZyBQcm9taXNlLnRyeSB3aXRoIG1vcmUgdGhhbiAxIGFyZ3VtZW50XCIpO1xuICAgICAgICB2YXIgYXJnID0gYXJndW1lbnRzWzFdO1xuICAgICAgICB2YXIgY3R4ID0gYXJndW1lbnRzWzJdO1xuICAgICAgICB2YWx1ZSA9IHV0aWwuaXNBcnJheShhcmcpID8gdHJ5Q2F0Y2goZm4pLmFwcGx5KGN0eCwgYXJnKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogdHJ5Q2F0Y2goZm4pLmNhbGwoY3R4LCBhcmcpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHZhbHVlID0gdHJ5Q2F0Y2goZm4pKCk7XG4gICAgfVxuICAgIHZhciBwcm9taXNlQ3JlYXRlZCA9IHJldC5fcG9wQ29udGV4dCgpO1xuICAgIGRlYnVnLmNoZWNrRm9yZ290dGVuUmV0dXJucyhcbiAgICAgICAgdmFsdWUsIHByb21pc2VDcmVhdGVkLCBcIlByb21pc2UudHJ5XCIsIHJldCk7XG4gICAgcmV0Ll9yZXNvbHZlRnJvbVN5bmNWYWx1ZSh2YWx1ZSk7XG4gICAgcmV0dXJuIHJldDtcbn07XG5cblByb21pc2UucHJvdG90eXBlLl9yZXNvbHZlRnJvbVN5bmNWYWx1ZSA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgIGlmICh2YWx1ZSA9PT0gdXRpbC5lcnJvck9iaikge1xuICAgICAgICB0aGlzLl9yZWplY3RDYWxsYmFjayh2YWx1ZS5lLCBmYWxzZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5fcmVzb2x2ZUNhbGxiYWNrKHZhbHVlLCB0cnVlKTtcbiAgICB9XG59O1xufTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9ibHVlYmlyZC9qcy9yZWxlYXNlL21ldGhvZC5qcyIsIlwidXNlIHN0cmljdFwiO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihQcm9taXNlLCBJTlRFUk5BTCwgdHJ5Q29udmVydFRvUHJvbWlzZSwgZGVidWcpIHtcbnZhciBjYWxsZWRCaW5kID0gZmFsc2U7XG52YXIgcmVqZWN0VGhpcyA9IGZ1bmN0aW9uKF8sIGUpIHtcbiAgICB0aGlzLl9yZWplY3QoZSk7XG59O1xuXG52YXIgdGFyZ2V0UmVqZWN0ZWQgPSBmdW5jdGlvbihlLCBjb250ZXh0KSB7XG4gICAgY29udGV4dC5wcm9taXNlUmVqZWN0aW9uUXVldWVkID0gdHJ1ZTtcbiAgICBjb250ZXh0LmJpbmRpbmdQcm9taXNlLl90aGVuKHJlamVjdFRoaXMsIHJlamVjdFRoaXMsIG51bGwsIHRoaXMsIGUpO1xufTtcblxudmFyIGJpbmRpbmdSZXNvbHZlZCA9IGZ1bmN0aW9uKHRoaXNBcmcsIGNvbnRleHQpIHtcbiAgICBpZiAoKCh0aGlzLl9iaXRGaWVsZCAmIDUwMzk3MTg0KSA9PT0gMCkpIHtcbiAgICAgICAgdGhpcy5fcmVzb2x2ZUNhbGxiYWNrKGNvbnRleHQudGFyZ2V0KTtcbiAgICB9XG59O1xuXG52YXIgYmluZGluZ1JlamVjdGVkID0gZnVuY3Rpb24oZSwgY29udGV4dCkge1xuICAgIGlmICghY29udGV4dC5wcm9taXNlUmVqZWN0aW9uUXVldWVkKSB0aGlzLl9yZWplY3QoZSk7XG59O1xuXG5Qcm9taXNlLnByb3RvdHlwZS5iaW5kID0gZnVuY3Rpb24gKHRoaXNBcmcpIHtcbiAgICBpZiAoIWNhbGxlZEJpbmQpIHtcbiAgICAgICAgY2FsbGVkQmluZCA9IHRydWU7XG4gICAgICAgIFByb21pc2UucHJvdG90eXBlLl9wcm9wYWdhdGVGcm9tID0gZGVidWcucHJvcGFnYXRlRnJvbUZ1bmN0aW9uKCk7XG4gICAgICAgIFByb21pc2UucHJvdG90eXBlLl9ib3VuZFZhbHVlID0gZGVidWcuYm91bmRWYWx1ZUZ1bmN0aW9uKCk7XG4gICAgfVxuICAgIHZhciBtYXliZVByb21pc2UgPSB0cnlDb252ZXJ0VG9Qcm9taXNlKHRoaXNBcmcpO1xuICAgIHZhciByZXQgPSBuZXcgUHJvbWlzZShJTlRFUk5BTCk7XG4gICAgcmV0Ll9wcm9wYWdhdGVGcm9tKHRoaXMsIDEpO1xuICAgIHZhciB0YXJnZXQgPSB0aGlzLl90YXJnZXQoKTtcbiAgICByZXQuX3NldEJvdW5kVG8obWF5YmVQcm9taXNlKTtcbiAgICBpZiAobWF5YmVQcm9taXNlIGluc3RhbmNlb2YgUHJvbWlzZSkge1xuICAgICAgICB2YXIgY29udGV4dCA9IHtcbiAgICAgICAgICAgIHByb21pc2VSZWplY3Rpb25RdWV1ZWQ6IGZhbHNlLFxuICAgICAgICAgICAgcHJvbWlzZTogcmV0LFxuICAgICAgICAgICAgdGFyZ2V0OiB0YXJnZXQsXG4gICAgICAgICAgICBiaW5kaW5nUHJvbWlzZTogbWF5YmVQcm9taXNlXG4gICAgICAgIH07XG4gICAgICAgIHRhcmdldC5fdGhlbihJTlRFUk5BTCwgdGFyZ2V0UmVqZWN0ZWQsIHVuZGVmaW5lZCwgcmV0LCBjb250ZXh0KTtcbiAgICAgICAgbWF5YmVQcm9taXNlLl90aGVuKFxuICAgICAgICAgICAgYmluZGluZ1Jlc29sdmVkLCBiaW5kaW5nUmVqZWN0ZWQsIHVuZGVmaW5lZCwgcmV0LCBjb250ZXh0KTtcbiAgICAgICAgcmV0Ll9zZXRPbkNhbmNlbChtYXliZVByb21pc2UpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJldC5fcmVzb2x2ZUNhbGxiYWNrKHRhcmdldCk7XG4gICAgfVxuICAgIHJldHVybiByZXQ7XG59O1xuXG5Qcm9taXNlLnByb3RvdHlwZS5fc2V0Qm91bmRUbyA9IGZ1bmN0aW9uIChvYmopIHtcbiAgICBpZiAob2JqICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhpcy5fYml0RmllbGQgPSB0aGlzLl9iaXRGaWVsZCB8IDIwOTcxNTI7XG4gICAgICAgIHRoaXMuX2JvdW5kVG8gPSBvYmo7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5fYml0RmllbGQgPSB0aGlzLl9iaXRGaWVsZCAmICh+MjA5NzE1Mik7XG4gICAgfVxufTtcblxuUHJvbWlzZS5wcm90b3R5cGUuX2lzQm91bmQgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuICh0aGlzLl9iaXRGaWVsZCAmIDIwOTcxNTIpID09PSAyMDk3MTUyO1xufTtcblxuUHJvbWlzZS5iaW5kID0gZnVuY3Rpb24gKHRoaXNBcmcsIHZhbHVlKSB7XG4gICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh2YWx1ZSkuYmluZCh0aGlzQXJnKTtcbn07XG59O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2JsdWViaXJkL2pzL3JlbGVhc2UvYmluZC5qcyIsIlwidXNlIHN0cmljdFwiO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihQcm9taXNlLCBQcm9taXNlQXJyYXksIGFwaVJlamVjdGlvbiwgZGVidWcpIHtcbnZhciB1dGlsID0gcmVxdWlyZShcIi4vdXRpbFwiKTtcbnZhciB0cnlDYXRjaCA9IHV0aWwudHJ5Q2F0Y2g7XG52YXIgZXJyb3JPYmogPSB1dGlsLmVycm9yT2JqO1xudmFyIGFzeW5jID0gUHJvbWlzZS5fYXN5bmM7XG5cblByb21pc2UucHJvdG90eXBlW1wiYnJlYWtcIl0gPSBQcm9taXNlLnByb3RvdHlwZS5jYW5jZWwgPSBmdW5jdGlvbigpIHtcbiAgICBpZiAoIWRlYnVnLmNhbmNlbGxhdGlvbigpKSByZXR1cm4gdGhpcy5fd2FybihcImNhbmNlbGxhdGlvbiBpcyBkaXNhYmxlZFwiKTtcblxuICAgIHZhciBwcm9taXNlID0gdGhpcztcbiAgICB2YXIgY2hpbGQgPSBwcm9taXNlO1xuICAgIHdoaWxlIChwcm9taXNlLl9pc0NhbmNlbGxhYmxlKCkpIHtcbiAgICAgICAgaWYgKCFwcm9taXNlLl9jYW5jZWxCeShjaGlsZCkpIHtcbiAgICAgICAgICAgIGlmIChjaGlsZC5faXNGb2xsb3dpbmcoKSkge1xuICAgICAgICAgICAgICAgIGNoaWxkLl9mb2xsb3dlZSgpLmNhbmNlbCgpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBjaGlsZC5fY2FuY2VsQnJhbmNoZWQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHBhcmVudCA9IHByb21pc2UuX2NhbmNlbGxhdGlvblBhcmVudDtcbiAgICAgICAgaWYgKHBhcmVudCA9PSBudWxsIHx8ICFwYXJlbnQuX2lzQ2FuY2VsbGFibGUoKSkge1xuICAgICAgICAgICAgaWYgKHByb21pc2UuX2lzRm9sbG93aW5nKCkpIHtcbiAgICAgICAgICAgICAgICBwcm9taXNlLl9mb2xsb3dlZSgpLmNhbmNlbCgpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBwcm9taXNlLl9jYW5jZWxCcmFuY2hlZCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAocHJvbWlzZS5faXNGb2xsb3dpbmcoKSkgcHJvbWlzZS5fZm9sbG93ZWUoKS5jYW5jZWwoKTtcbiAgICAgICAgICAgIHByb21pc2UuX3NldFdpbGxCZUNhbmNlbGxlZCgpO1xuICAgICAgICAgICAgY2hpbGQgPSBwcm9taXNlO1xuICAgICAgICAgICAgcHJvbWlzZSA9IHBhcmVudDtcbiAgICAgICAgfVxuICAgIH1cbn07XG5cblByb21pc2UucHJvdG90eXBlLl9icmFuY2hIYXNDYW5jZWxsZWQgPSBmdW5jdGlvbigpIHtcbiAgICB0aGlzLl9icmFuY2hlc1JlbWFpbmluZ1RvQ2FuY2VsLS07XG59O1xuXG5Qcm9taXNlLnByb3RvdHlwZS5fZW5vdWdoQnJhbmNoZXNIYXZlQ2FuY2VsbGVkID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuX2JyYW5jaGVzUmVtYWluaW5nVG9DYW5jZWwgPT09IHVuZGVmaW5lZCB8fFxuICAgICAgICAgICB0aGlzLl9icmFuY2hlc1JlbWFpbmluZ1RvQ2FuY2VsIDw9IDA7XG59O1xuXG5Qcm9taXNlLnByb3RvdHlwZS5fY2FuY2VsQnkgPSBmdW5jdGlvbihjYW5jZWxsZXIpIHtcbiAgICBpZiAoY2FuY2VsbGVyID09PSB0aGlzKSB7XG4gICAgICAgIHRoaXMuX2JyYW5jaGVzUmVtYWluaW5nVG9DYW5jZWwgPSAwO1xuICAgICAgICB0aGlzLl9pbnZva2VPbkNhbmNlbCgpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLl9icmFuY2hIYXNDYW5jZWxsZWQoKTtcbiAgICAgICAgaWYgKHRoaXMuX2Vub3VnaEJyYW5jaGVzSGF2ZUNhbmNlbGxlZCgpKSB7XG4gICAgICAgICAgICB0aGlzLl9pbnZva2VPbkNhbmNlbCgpO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufTtcblxuUHJvbWlzZS5wcm90b3R5cGUuX2NhbmNlbEJyYW5jaGVkID0gZnVuY3Rpb24oKSB7XG4gICAgaWYgKHRoaXMuX2Vub3VnaEJyYW5jaGVzSGF2ZUNhbmNlbGxlZCgpKSB7XG4gICAgICAgIHRoaXMuX2NhbmNlbCgpO1xuICAgIH1cbn07XG5cblByb21pc2UucHJvdG90eXBlLl9jYW5jZWwgPSBmdW5jdGlvbigpIHtcbiAgICBpZiAoIXRoaXMuX2lzQ2FuY2VsbGFibGUoKSkgcmV0dXJuO1xuICAgIHRoaXMuX3NldENhbmNlbGxlZCgpO1xuICAgIGFzeW5jLmludm9rZSh0aGlzLl9jYW5jZWxQcm9taXNlcywgdGhpcywgdW5kZWZpbmVkKTtcbn07XG5cblByb21pc2UucHJvdG90eXBlLl9jYW5jZWxQcm9taXNlcyA9IGZ1bmN0aW9uKCkge1xuICAgIGlmICh0aGlzLl9sZW5ndGgoKSA+IDApIHRoaXMuX3NldHRsZVByb21pc2VzKCk7XG59O1xuXG5Qcm9taXNlLnByb3RvdHlwZS5fdW5zZXRPbkNhbmNlbCA9IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuX29uQ2FuY2VsRmllbGQgPSB1bmRlZmluZWQ7XG59O1xuXG5Qcm9taXNlLnByb3RvdHlwZS5faXNDYW5jZWxsYWJsZSA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLmlzUGVuZGluZygpICYmICF0aGlzLl9pc0NhbmNlbGxlZCgpO1xufTtcblxuUHJvbWlzZS5wcm90b3R5cGUuaXNDYW5jZWxsYWJsZSA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLmlzUGVuZGluZygpICYmICF0aGlzLmlzQ2FuY2VsbGVkKCk7XG59O1xuXG5Qcm9taXNlLnByb3RvdHlwZS5fZG9JbnZva2VPbkNhbmNlbCA9IGZ1bmN0aW9uKG9uQ2FuY2VsQ2FsbGJhY2ssIGludGVybmFsT25seSkge1xuICAgIGlmICh1dGlsLmlzQXJyYXkob25DYW5jZWxDYWxsYmFjaykpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBvbkNhbmNlbENhbGxiYWNrLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICB0aGlzLl9kb0ludm9rZU9uQ2FuY2VsKG9uQ2FuY2VsQ2FsbGJhY2tbaV0sIGludGVybmFsT25seSk7XG4gICAgICAgIH1cbiAgICB9IGVsc2UgaWYgKG9uQ2FuY2VsQ2FsbGJhY2sgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBpZiAodHlwZW9mIG9uQ2FuY2VsQ2FsbGJhY2sgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgaWYgKCFpbnRlcm5hbE9ubHkpIHtcbiAgICAgICAgICAgICAgICB2YXIgZSA9IHRyeUNhdGNoKG9uQ2FuY2VsQ2FsbGJhY2spLmNhbGwodGhpcy5fYm91bmRWYWx1ZSgpKTtcbiAgICAgICAgICAgICAgICBpZiAoZSA9PT0gZXJyb3JPYmopIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fYXR0YWNoRXh0cmFUcmFjZShlLmUpO1xuICAgICAgICAgICAgICAgICAgICBhc3luYy50aHJvd0xhdGVyKGUuZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgb25DYW5jZWxDYWxsYmFjay5fcmVzdWx0Q2FuY2VsbGVkKHRoaXMpO1xuICAgICAgICB9XG4gICAgfVxufTtcblxuUHJvbWlzZS5wcm90b3R5cGUuX2ludm9rZU9uQ2FuY2VsID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIG9uQ2FuY2VsQ2FsbGJhY2sgPSB0aGlzLl9vbkNhbmNlbCgpO1xuICAgIHRoaXMuX3Vuc2V0T25DYW5jZWwoKTtcbiAgICBhc3luYy5pbnZva2UodGhpcy5fZG9JbnZva2VPbkNhbmNlbCwgdGhpcywgb25DYW5jZWxDYWxsYmFjayk7XG59O1xuXG5Qcm9taXNlLnByb3RvdHlwZS5faW52b2tlSW50ZXJuYWxPbkNhbmNlbCA9IGZ1bmN0aW9uKCkge1xuICAgIGlmICh0aGlzLl9pc0NhbmNlbGxhYmxlKCkpIHtcbiAgICAgICAgdGhpcy5fZG9JbnZva2VPbkNhbmNlbCh0aGlzLl9vbkNhbmNlbCgpLCB0cnVlKTtcbiAgICAgICAgdGhpcy5fdW5zZXRPbkNhbmNlbCgpO1xuICAgIH1cbn07XG5cblByb21pc2UucHJvdG90eXBlLl9yZXN1bHRDYW5jZWxsZWQgPSBmdW5jdGlvbigpIHtcbiAgICB0aGlzLmNhbmNlbCgpO1xufTtcblxufTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9ibHVlYmlyZC9qcy9yZWxlYXNlL2NhbmNlbC5qcyIsIlwidXNlIHN0cmljdFwiO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihQcm9taXNlKSB7XG5mdW5jdGlvbiByZXR1cm5lcigpIHtcbiAgICByZXR1cm4gdGhpcy52YWx1ZTtcbn1cbmZ1bmN0aW9uIHRocm93ZXIoKSB7XG4gICAgdGhyb3cgdGhpcy5yZWFzb247XG59XG5cblByb21pc2UucHJvdG90eXBlW1wicmV0dXJuXCJdID1cblByb21pc2UucHJvdG90eXBlLnRoZW5SZXR1cm4gPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBQcm9taXNlKSB2YWx1ZS5zdXBwcmVzc1VuaGFuZGxlZFJlamVjdGlvbnMoKTtcbiAgICByZXR1cm4gdGhpcy5fdGhlbihcbiAgICAgICAgcmV0dXJuZXIsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCB7dmFsdWU6IHZhbHVlfSwgdW5kZWZpbmVkKTtcbn07XG5cblByb21pc2UucHJvdG90eXBlW1widGhyb3dcIl0gPVxuUHJvbWlzZS5wcm90b3R5cGUudGhlblRocm93ID0gZnVuY3Rpb24gKHJlYXNvbikge1xuICAgIHJldHVybiB0aGlzLl90aGVuKFxuICAgICAgICB0aHJvd2VyLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwge3JlYXNvbjogcmVhc29ufSwgdW5kZWZpbmVkKTtcbn07XG5cblByb21pc2UucHJvdG90eXBlLmNhdGNoVGhyb3cgPSBmdW5jdGlvbiAocmVhc29uKSB7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPD0gMSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fdGhlbihcbiAgICAgICAgICAgIHVuZGVmaW5lZCwgdGhyb3dlciwgdW5kZWZpbmVkLCB7cmVhc29uOiByZWFzb259LCB1bmRlZmluZWQpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBfcmVhc29uID0gYXJndW1lbnRzWzFdO1xuICAgICAgICB2YXIgaGFuZGxlciA9IGZ1bmN0aW9uKCkge3Rocm93IF9yZWFzb247fTtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2F1Z2h0KHJlYXNvbiwgaGFuZGxlcik7XG4gICAgfVxufTtcblxuUHJvbWlzZS5wcm90b3R5cGUuY2F0Y2hSZXR1cm4gPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA8PSAxKSB7XG4gICAgICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIFByb21pc2UpIHZhbHVlLnN1cHByZXNzVW5oYW5kbGVkUmVqZWN0aW9ucygpO1xuICAgICAgICByZXR1cm4gdGhpcy5fdGhlbihcbiAgICAgICAgICAgIHVuZGVmaW5lZCwgcmV0dXJuZXIsIHVuZGVmaW5lZCwge3ZhbHVlOiB2YWx1ZX0sIHVuZGVmaW5lZCk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIF92YWx1ZSA9IGFyZ3VtZW50c1sxXTtcbiAgICAgICAgaWYgKF92YWx1ZSBpbnN0YW5jZW9mIFByb21pc2UpIF92YWx1ZS5zdXBwcmVzc1VuaGFuZGxlZFJlamVjdGlvbnMoKTtcbiAgICAgICAgdmFyIGhhbmRsZXIgPSBmdW5jdGlvbigpIHtyZXR1cm4gX3ZhbHVlO307XG4gICAgICAgIHJldHVybiB0aGlzLmNhdWdodCh2YWx1ZSwgaGFuZGxlcik7XG4gICAgfVxufTtcbn07XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvYmx1ZWJpcmQvanMvcmVsZWFzZS9kaXJlY3RfcmVzb2x2ZS5qcyIsIlwidXNlIHN0cmljdFwiO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihQcm9taXNlKSB7XG5mdW5jdGlvbiBQcm9taXNlSW5zcGVjdGlvbihwcm9taXNlKSB7XG4gICAgaWYgKHByb21pc2UgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBwcm9taXNlID0gcHJvbWlzZS5fdGFyZ2V0KCk7XG4gICAgICAgIHRoaXMuX2JpdEZpZWxkID0gcHJvbWlzZS5fYml0RmllbGQ7XG4gICAgICAgIHRoaXMuX3NldHRsZWRWYWx1ZUZpZWxkID0gcHJvbWlzZS5faXNGYXRlU2VhbGVkKClcbiAgICAgICAgICAgID8gcHJvbWlzZS5fc2V0dGxlZFZhbHVlKCkgOiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB0aGlzLl9iaXRGaWVsZCA9IDA7XG4gICAgICAgIHRoaXMuX3NldHRsZWRWYWx1ZUZpZWxkID0gdW5kZWZpbmVkO1xuICAgIH1cbn1cblxuUHJvbWlzZUluc3BlY3Rpb24ucHJvdG90eXBlLl9zZXR0bGVkVmFsdWUgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5fc2V0dGxlZFZhbHVlRmllbGQ7XG59O1xuXG52YXIgdmFsdWUgPSBQcm9taXNlSW5zcGVjdGlvbi5wcm90b3R5cGUudmFsdWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKCF0aGlzLmlzRnVsZmlsbGVkKCkpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcImNhbm5vdCBnZXQgZnVsZmlsbG1lbnQgdmFsdWUgb2YgYSBub24tZnVsZmlsbGVkIHByb21pc2VcXHUwMDBhXFx1MDAwYSAgICBTZWUgaHR0cDovL2dvby5nbC9NcXJGbVhcXHUwMDBhXCIpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fc2V0dGxlZFZhbHVlKCk7XG59O1xuXG52YXIgcmVhc29uID0gUHJvbWlzZUluc3BlY3Rpb24ucHJvdG90eXBlLmVycm9yID1cblByb21pc2VJbnNwZWN0aW9uLnByb3RvdHlwZS5yZWFzb24gPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKCF0aGlzLmlzUmVqZWN0ZWQoKSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiY2Fubm90IGdldCByZWplY3Rpb24gcmVhc29uIG9mIGEgbm9uLXJlamVjdGVkIHByb21pc2VcXHUwMDBhXFx1MDAwYSAgICBTZWUgaHR0cDovL2dvby5nbC9NcXJGbVhcXHUwMDBhXCIpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fc2V0dGxlZFZhbHVlKCk7XG59O1xuXG52YXIgaXNGdWxmaWxsZWQgPSBQcm9taXNlSW5zcGVjdGlvbi5wcm90b3R5cGUuaXNGdWxmaWxsZWQgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gKHRoaXMuX2JpdEZpZWxkICYgMzM1NTQ0MzIpICE9PSAwO1xufTtcblxudmFyIGlzUmVqZWN0ZWQgPSBQcm9taXNlSW5zcGVjdGlvbi5wcm90b3R5cGUuaXNSZWplY3RlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gKHRoaXMuX2JpdEZpZWxkICYgMTY3NzcyMTYpICE9PSAwO1xufTtcblxudmFyIGlzUGVuZGluZyA9IFByb21pc2VJbnNwZWN0aW9uLnByb3RvdHlwZS5pc1BlbmRpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuICh0aGlzLl9iaXRGaWVsZCAmIDUwMzk3MTg0KSA9PT0gMDtcbn07XG5cbnZhciBpc1Jlc29sdmVkID0gUHJvbWlzZUluc3BlY3Rpb24ucHJvdG90eXBlLmlzUmVzb2x2ZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuICh0aGlzLl9iaXRGaWVsZCAmIDUwMzMxNjQ4KSAhPT0gMDtcbn07XG5cblByb21pc2VJbnNwZWN0aW9uLnByb3RvdHlwZS5pc0NhbmNlbGxlZCA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiAodGhpcy5fYml0RmllbGQgJiA4NDU0MTQ0KSAhPT0gMDtcbn07XG5cblByb21pc2UucHJvdG90eXBlLl9faXNDYW5jZWxsZWQgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gKHRoaXMuX2JpdEZpZWxkICYgNjU1MzYpID09PSA2NTUzNjtcbn07XG5cblByb21pc2UucHJvdG90eXBlLl9pc0NhbmNlbGxlZCA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLl90YXJnZXQoKS5fX2lzQ2FuY2VsbGVkKCk7XG59O1xuXG5Qcm9taXNlLnByb3RvdHlwZS5pc0NhbmNlbGxlZCA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiAodGhpcy5fdGFyZ2V0KCkuX2JpdEZpZWxkICYgODQ1NDE0NCkgIT09IDA7XG59O1xuXG5Qcm9taXNlLnByb3RvdHlwZS5pc1BlbmRpbmcgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gaXNQZW5kaW5nLmNhbGwodGhpcy5fdGFyZ2V0KCkpO1xufTtcblxuUHJvbWlzZS5wcm90b3R5cGUuaXNSZWplY3RlZCA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBpc1JlamVjdGVkLmNhbGwodGhpcy5fdGFyZ2V0KCkpO1xufTtcblxuUHJvbWlzZS5wcm90b3R5cGUuaXNGdWxmaWxsZWQgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gaXNGdWxmaWxsZWQuY2FsbCh0aGlzLl90YXJnZXQoKSk7XG59O1xuXG5Qcm9taXNlLnByb3RvdHlwZS5pc1Jlc29sdmVkID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIGlzUmVzb2x2ZWQuY2FsbCh0aGlzLl90YXJnZXQoKSk7XG59O1xuXG5Qcm9taXNlLnByb3RvdHlwZS52YWx1ZSA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB2YWx1ZS5jYWxsKHRoaXMuX3RhcmdldCgpKTtcbn07XG5cblByb21pc2UucHJvdG90eXBlLnJlYXNvbiA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciB0YXJnZXQgPSB0aGlzLl90YXJnZXQoKTtcbiAgICB0YXJnZXQuX3Vuc2V0UmVqZWN0aW9uSXNVbmhhbmRsZWQoKTtcbiAgICByZXR1cm4gcmVhc29uLmNhbGwodGFyZ2V0KTtcbn07XG5cblByb21pc2UucHJvdG90eXBlLl92YWx1ZSA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLl9zZXR0bGVkVmFsdWUoKTtcbn07XG5cblByb21pc2UucHJvdG90eXBlLl9yZWFzb24gPSBmdW5jdGlvbigpIHtcbiAgICB0aGlzLl91bnNldFJlamVjdGlvbklzVW5oYW5kbGVkKCk7XG4gICAgcmV0dXJuIHRoaXMuX3NldHRsZWRWYWx1ZSgpO1xufTtcblxuUHJvbWlzZS5Qcm9taXNlSW5zcGVjdGlvbiA9IFByb21pc2VJbnNwZWN0aW9uO1xufTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9ibHVlYmlyZC9qcy9yZWxlYXNlL3N5bmNocm9ub3VzX2luc3BlY3Rpb24uanMiLCJcInVzZSBzdHJpY3RcIjtcbm1vZHVsZS5leHBvcnRzID1cbmZ1bmN0aW9uKFByb21pc2UsIFByb21pc2VBcnJheSwgdHJ5Q29udmVydFRvUHJvbWlzZSwgSU5URVJOQUwsIGFzeW5jLFxuICAgICAgICAgZ2V0RG9tYWluKSB7XG52YXIgdXRpbCA9IHJlcXVpcmUoXCIuL3V0aWxcIik7XG52YXIgY2FuRXZhbHVhdGUgPSB1dGlsLmNhbkV2YWx1YXRlO1xudmFyIHRyeUNhdGNoID0gdXRpbC50cnlDYXRjaDtcbnZhciBlcnJvck9iaiA9IHV0aWwuZXJyb3JPYmo7XG52YXIgcmVqZWN0O1xuXG5pZiAoIWZhbHNlKSB7XG5pZiAoY2FuRXZhbHVhdGUpIHtcbiAgICB2YXIgdGhlbkNhbGxiYWNrID0gZnVuY3Rpb24oaSkge1xuICAgICAgICByZXR1cm4gbmV3IEZ1bmN0aW9uKFwidmFsdWVcIiwgXCJob2xkZXJcIiwgXCIgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxcblxcXG4gICAgICAgICAgICAndXNlIHN0cmljdCc7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxcblxcXG4gICAgICAgICAgICBob2xkZXIucEluZGV4ID0gdmFsdWU7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxcblxcXG4gICAgICAgICAgICBob2xkZXIuY2hlY2tGdWxmaWxsbWVudCh0aGlzKTsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxcblxcXG4gICAgICAgICAgICBcIi5yZXBsYWNlKC9JbmRleC9nLCBpKSk7XG4gICAgfTtcblxuICAgIHZhciBwcm9taXNlU2V0dGVyID0gZnVuY3Rpb24oaSkge1xuICAgICAgICByZXR1cm4gbmV3IEZ1bmN0aW9uKFwicHJvbWlzZVwiLCBcImhvbGRlclwiLCBcIiAgICAgICAgICAgICAgICAgICAgICAgICAgIFxcblxcXG4gICAgICAgICAgICAndXNlIHN0cmljdCc7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxcblxcXG4gICAgICAgICAgICBob2xkZXIucEluZGV4ID0gcHJvbWlzZTsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxcblxcXG4gICAgICAgICAgICBcIi5yZXBsYWNlKC9JbmRleC9nLCBpKSk7XG4gICAgfTtcblxuICAgIHZhciBnZW5lcmF0ZUhvbGRlckNsYXNzID0gZnVuY3Rpb24odG90YWwpIHtcbiAgICAgICAgdmFyIHByb3BzID0gbmV3IEFycmF5KHRvdGFsKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgcHJvcHNbaV0gPSBcInRoaXMucFwiICsgKGkrMSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGFzc2lnbm1lbnQgPSBwcm9wcy5qb2luKFwiID0gXCIpICsgXCIgPSBudWxsO1wiO1xuICAgICAgICB2YXIgY2FuY2VsbGF0aW9uQ29kZT0gXCJ2YXIgcHJvbWlzZTtcXG5cIiArIHByb3BzLm1hcChmdW5jdGlvbihwcm9wKSB7XG4gICAgICAgICAgICByZXR1cm4gXCIgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcXG5cXFxuICAgICAgICAgICAgICAgIHByb21pc2UgPSBcIiArIHByb3AgKyBcIjsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxcblxcXG4gICAgICAgICAgICAgICAgaWYgKHByb21pc2UgaW5zdGFuY2VvZiBQcm9taXNlKSB7ICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxcblxcXG4gICAgICAgICAgICAgICAgICAgIHByb21pc2UuY2FuY2VsKCk7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxcblxcXG4gICAgICAgICAgICAgICAgfSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxcblxcXG4gICAgICAgICAgICBcIjtcbiAgICAgICAgfSkuam9pbihcIlxcblwiKTtcbiAgICAgICAgdmFyIHBhc3NlZEFyZ3VtZW50cyA9IHByb3BzLmpvaW4oXCIsIFwiKTtcbiAgICAgICAgdmFyIG5hbWUgPSBcIkhvbGRlciRcIiArIHRvdGFsO1xuXG5cbiAgICAgICAgdmFyIGNvZGUgPSBcInJldHVybiBmdW5jdGlvbih0cnlDYXRjaCwgZXJyb3JPYmosIFByb21pc2UsIGFzeW5jKSB7ICAgIFxcblxcXG4gICAgICAgICAgICAndXNlIHN0cmljdCc7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxcblxcXG4gICAgICAgICAgICBmdW5jdGlvbiBbVGhlTmFtZV0oZm4pIHsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxcblxcXG4gICAgICAgICAgICAgICAgW1RoZVByb3BlcnRpZXNdICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxcblxcXG4gICAgICAgICAgICAgICAgdGhpcy5mbiA9IGZuOyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxcblxcXG4gICAgICAgICAgICAgICAgdGhpcy5hc3luY05lZWRlZCA9IHRydWU7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxcblxcXG4gICAgICAgICAgICAgICAgdGhpcy5ub3cgPSAwOyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxcblxcXG4gICAgICAgICAgICB9ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxcblxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxcblxcXG4gICAgICAgICAgICBbVGhlTmFtZV0ucHJvdG90eXBlLl9jYWxsRnVuY3Rpb24gPSBmdW5jdGlvbihwcm9taXNlKSB7ICAgICAgICAgIFxcblxcXG4gICAgICAgICAgICAgICAgcHJvbWlzZS5fcHVzaENvbnRleHQoKTsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxcblxcXG4gICAgICAgICAgICAgICAgdmFyIHJldCA9IHRyeUNhdGNoKHRoaXMuZm4pKFtUaGVQYXNzZWRBcmd1bWVudHNdKTsgICAgICAgICAgIFxcblxcXG4gICAgICAgICAgICAgICAgcHJvbWlzZS5fcG9wQ29udGV4dCgpOyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxcblxcXG4gICAgICAgICAgICAgICAgaWYgKHJldCA9PT0gZXJyb3JPYmopIHsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxcblxcXG4gICAgICAgICAgICAgICAgICAgIHByb21pc2UuX3JlamVjdENhbGxiYWNrKHJldC5lLCBmYWxzZSk7ICAgICAgICAgICAgICAgICAgIFxcblxcXG4gICAgICAgICAgICAgICAgfSBlbHNlIHsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxcblxcXG4gICAgICAgICAgICAgICAgICAgIHByb21pc2UuX3Jlc29sdmVDYWxsYmFjayhyZXQpOyAgICAgICAgICAgICAgICAgICAgICAgICAgIFxcblxcXG4gICAgICAgICAgICAgICAgfSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxcblxcXG4gICAgICAgICAgICB9OyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxcblxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxcblxcXG4gICAgICAgICAgICBbVGhlTmFtZV0ucHJvdG90eXBlLmNoZWNrRnVsZmlsbG1lbnQgPSBmdW5jdGlvbihwcm9taXNlKSB7ICAgICAgIFxcblxcXG4gICAgICAgICAgICAgICAgdmFyIG5vdyA9ICsrdGhpcy5ub3c7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxcblxcXG4gICAgICAgICAgICAgICAgaWYgKG5vdyA9PT0gW1RoZVRvdGFsXSkgeyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxcblxcXG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmFzeW5jTmVlZGVkKSB7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxcblxcXG4gICAgICAgICAgICAgICAgICAgICAgICBhc3luYy5pbnZva2UodGhpcy5fY2FsbEZ1bmN0aW9uLCB0aGlzLCBwcm9taXNlKTsgICAgIFxcblxcXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxcblxcXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9jYWxsRnVuY3Rpb24ocHJvbWlzZSk7ICAgICAgICAgICAgICAgICAgICAgICAgIFxcblxcXG4gICAgICAgICAgICAgICAgICAgIH0gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxcblxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxcblxcXG4gICAgICAgICAgICAgICAgfSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxcblxcXG4gICAgICAgICAgICB9OyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxcblxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxcblxcXG4gICAgICAgICAgICBbVGhlTmFtZV0ucHJvdG90eXBlLl9yZXN1bHRDYW5jZWxsZWQgPSBmdW5jdGlvbigpIHsgICAgICAgICAgICAgIFxcblxcXG4gICAgICAgICAgICAgICAgW0NhbmNlbGxhdGlvbkNvZGVdICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxcblxcXG4gICAgICAgICAgICB9OyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxcblxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxcblxcXG4gICAgICAgICAgICByZXR1cm4gW1RoZU5hbWVdOyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxcblxcXG4gICAgICAgIH0odHJ5Q2F0Y2gsIGVycm9yT2JqLCBQcm9taXNlLCBhc3luYyk7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxcblxcXG4gICAgICAgIFwiO1xuXG4gICAgICAgIGNvZGUgPSBjb2RlLnJlcGxhY2UoL1xcW1RoZU5hbWVcXF0vZywgbmFtZSlcbiAgICAgICAgICAgIC5yZXBsYWNlKC9cXFtUaGVUb3RhbFxcXS9nLCB0b3RhbClcbiAgICAgICAgICAgIC5yZXBsYWNlKC9cXFtUaGVQYXNzZWRBcmd1bWVudHNcXF0vZywgcGFzc2VkQXJndW1lbnRzKVxuICAgICAgICAgICAgLnJlcGxhY2UoL1xcW1RoZVByb3BlcnRpZXNcXF0vZywgYXNzaWdubWVudClcbiAgICAgICAgICAgIC5yZXBsYWNlKC9cXFtDYW5jZWxsYXRpb25Db2RlXFxdL2csIGNhbmNlbGxhdGlvbkNvZGUpO1xuXG4gICAgICAgIHJldHVybiBuZXcgRnVuY3Rpb24oXCJ0cnlDYXRjaFwiLCBcImVycm9yT2JqXCIsIFwiUHJvbWlzZVwiLCBcImFzeW5jXCIsIGNvZGUpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAodHJ5Q2F0Y2gsIGVycm9yT2JqLCBQcm9taXNlLCBhc3luYyk7XG4gICAgfTtcblxuICAgIHZhciBob2xkZXJDbGFzc2VzID0gW107XG4gICAgdmFyIHRoZW5DYWxsYmFja3MgPSBbXTtcbiAgICB2YXIgcHJvbWlzZVNldHRlcnMgPSBbXTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgODsgKytpKSB7XG4gICAgICAgIGhvbGRlckNsYXNzZXMucHVzaChnZW5lcmF0ZUhvbGRlckNsYXNzKGkgKyAxKSk7XG4gICAgICAgIHRoZW5DYWxsYmFja3MucHVzaCh0aGVuQ2FsbGJhY2soaSArIDEpKTtcbiAgICAgICAgcHJvbWlzZVNldHRlcnMucHVzaChwcm9taXNlU2V0dGVyKGkgKyAxKSk7XG4gICAgfVxuXG4gICAgcmVqZWN0ID0gZnVuY3Rpb24gKHJlYXNvbikge1xuICAgICAgICB0aGlzLl9yZWplY3QocmVhc29uKTtcbiAgICB9O1xufX1cblxuUHJvbWlzZS5qb2luID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBsYXN0ID0gYXJndW1lbnRzLmxlbmd0aCAtIDE7XG4gICAgdmFyIGZuO1xuICAgIGlmIChsYXN0ID4gMCAmJiB0eXBlb2YgYXJndW1lbnRzW2xhc3RdID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgZm4gPSBhcmd1bWVudHNbbGFzdF07XG4gICAgICAgIGlmICghZmFsc2UpIHtcbiAgICAgICAgICAgIGlmIChsYXN0IDw9IDggJiYgY2FuRXZhbHVhdGUpIHtcbiAgICAgICAgICAgICAgICB2YXIgcmV0ID0gbmV3IFByb21pc2UoSU5URVJOQUwpO1xuICAgICAgICAgICAgICAgIHJldC5fY2FwdHVyZVN0YWNrVHJhY2UoKTtcbiAgICAgICAgICAgICAgICB2YXIgSG9sZGVyQ2xhc3MgPSBob2xkZXJDbGFzc2VzW2xhc3QgLSAxXTtcbiAgICAgICAgICAgICAgICB2YXIgaG9sZGVyID0gbmV3IEhvbGRlckNsYXNzKGZuKTtcbiAgICAgICAgICAgICAgICB2YXIgY2FsbGJhY2tzID0gdGhlbkNhbGxiYWNrcztcblxuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGFzdDsgKytpKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBtYXliZVByb21pc2UgPSB0cnlDb252ZXJ0VG9Qcm9taXNlKGFyZ3VtZW50c1tpXSwgcmV0KTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG1heWJlUHJvbWlzZSBpbnN0YW5jZW9mIFByb21pc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1heWJlUHJvbWlzZSA9IG1heWJlUHJvbWlzZS5fdGFyZ2V0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgYml0RmllbGQgPSBtYXliZVByb21pc2UuX2JpdEZpZWxkO1xuICAgICAgICAgICAgICAgICAgICAgICAgO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCgoYml0RmllbGQgJiA1MDM5NzE4NCkgPT09IDApKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWF5YmVQcm9taXNlLl90aGVuKGNhbGxiYWNrc1tpXSwgcmVqZWN0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB1bmRlZmluZWQsIHJldCwgaG9sZGVyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcm9taXNlU2V0dGVyc1tpXShtYXliZVByb21pc2UsIGhvbGRlcik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaG9sZGVyLmFzeW5jTmVlZGVkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKCgoYml0RmllbGQgJiAzMzU1NDQzMikgIT09IDApKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2tzW2ldLmNhbGwocmV0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1heWJlUHJvbWlzZS5fdmFsdWUoKSwgaG9sZGVyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoKChiaXRGaWVsZCAmIDE2Nzc3MjE2KSAhPT0gMCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXQuX3JlamVjdChtYXliZVByb21pc2UuX3JlYXNvbigpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0Ll9jYW5jZWwoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrc1tpXS5jYWxsKHJldCwgbWF5YmVQcm9taXNlLCBob2xkZXIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKCFyZXQuX2lzRmF0ZVNlYWxlZCgpKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChob2xkZXIuYXN5bmNOZWVkZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBkb21haW4gPSBnZXREb21haW4oKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkb21haW4gIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBob2xkZXIuZm4gPSB1dGlsLmRvbWFpbkJpbmQoZG9tYWluLCBob2xkZXIuZm4pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldC5fc2V0QXN5bmNHdWFyYW50ZWVkKCk7XG4gICAgICAgICAgICAgICAgICAgIHJldC5fc2V0T25DYW5jZWwoaG9sZGVyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJldDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICB2YXIgJF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoO3ZhciBhcmdzID0gbmV3IEFycmF5KCRfbGVuKTsgZm9yKHZhciAkX2kgPSAwOyAkX2kgPCAkX2xlbjsgKyskX2kpIHthcmdzWyRfaV0gPSBhcmd1bWVudHNbJF9pXTt9O1xuICAgIGlmIChmbikgYXJncy5wb3AoKTtcbiAgICB2YXIgcmV0ID0gbmV3IFByb21pc2VBcnJheShhcmdzKS5wcm9taXNlKCk7XG4gICAgcmV0dXJuIGZuICE9PSB1bmRlZmluZWQgPyByZXQuc3ByZWFkKGZuKSA6IHJldDtcbn07XG5cbn07XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvYmx1ZWJpcmQvanMvcmVsZWFzZS9qb2luLmpzIiwiXCJ1c2Ugc3RyaWN0XCI7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKFByb21pc2UsXG4gICAgICAgICAgICAgICAgICAgICAgICAgIFByb21pc2VBcnJheSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgYXBpUmVqZWN0aW9uLFxuICAgICAgICAgICAgICAgICAgICAgICAgICB0cnlDb252ZXJ0VG9Qcm9taXNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICBJTlRFUk5BTCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgZGVidWcpIHtcbnZhciBnZXREb21haW4gPSBQcm9taXNlLl9nZXREb21haW47XG52YXIgdXRpbCA9IHJlcXVpcmUoXCIuL3V0aWxcIik7XG52YXIgdHJ5Q2F0Y2ggPSB1dGlsLnRyeUNhdGNoO1xudmFyIGVycm9yT2JqID0gdXRpbC5lcnJvck9iajtcbnZhciBhc3luYyA9IFByb21pc2UuX2FzeW5jO1xuXG5mdW5jdGlvbiBNYXBwaW5nUHJvbWlzZUFycmF5KHByb21pc2VzLCBmbiwgbGltaXQsIF9maWx0ZXIpIHtcbiAgICB0aGlzLmNvbnN0cnVjdG9yJChwcm9taXNlcyk7XG4gICAgdGhpcy5fcHJvbWlzZS5fY2FwdHVyZVN0YWNrVHJhY2UoKTtcbiAgICB2YXIgZG9tYWluID0gZ2V0RG9tYWluKCk7XG4gICAgdGhpcy5fY2FsbGJhY2sgPSBkb21haW4gPT09IG51bGwgPyBmbiA6IHV0aWwuZG9tYWluQmluZChkb21haW4sIGZuKTtcbiAgICB0aGlzLl9wcmVzZXJ2ZWRWYWx1ZXMgPSBfZmlsdGVyID09PSBJTlRFUk5BTFxuICAgICAgICA/IG5ldyBBcnJheSh0aGlzLmxlbmd0aCgpKVxuICAgICAgICA6IG51bGw7XG4gICAgdGhpcy5fbGltaXQgPSBsaW1pdDtcbiAgICB0aGlzLl9pbkZsaWdodCA9IDA7XG4gICAgdGhpcy5fcXVldWUgPSBbXTtcbiAgICBhc3luYy5pbnZva2UodGhpcy5fYXN5bmNJbml0LCB0aGlzLCB1bmRlZmluZWQpO1xufVxudXRpbC5pbmhlcml0cyhNYXBwaW5nUHJvbWlzZUFycmF5LCBQcm9taXNlQXJyYXkpO1xuXG5NYXBwaW5nUHJvbWlzZUFycmF5LnByb3RvdHlwZS5fYXN5bmNJbml0ID0gZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5faW5pdCQodW5kZWZpbmVkLCAtMik7XG59O1xuXG5NYXBwaW5nUHJvbWlzZUFycmF5LnByb3RvdHlwZS5faW5pdCA9IGZ1bmN0aW9uICgpIHt9O1xuXG5NYXBwaW5nUHJvbWlzZUFycmF5LnByb3RvdHlwZS5fcHJvbWlzZUZ1bGZpbGxlZCA9IGZ1bmN0aW9uICh2YWx1ZSwgaW5kZXgpIHtcbiAgICB2YXIgdmFsdWVzID0gdGhpcy5fdmFsdWVzO1xuICAgIHZhciBsZW5ndGggPSB0aGlzLmxlbmd0aCgpO1xuICAgIHZhciBwcmVzZXJ2ZWRWYWx1ZXMgPSB0aGlzLl9wcmVzZXJ2ZWRWYWx1ZXM7XG4gICAgdmFyIGxpbWl0ID0gdGhpcy5fbGltaXQ7XG5cbiAgICBpZiAoaW5kZXggPCAwKSB7XG4gICAgICAgIGluZGV4ID0gKGluZGV4ICogLTEpIC0gMTtcbiAgICAgICAgdmFsdWVzW2luZGV4XSA9IHZhbHVlO1xuICAgICAgICBpZiAobGltaXQgPj0gMSkge1xuICAgICAgICAgICAgdGhpcy5faW5GbGlnaHQtLTtcbiAgICAgICAgICAgIHRoaXMuX2RyYWluUXVldWUoKTtcbiAgICAgICAgICAgIGlmICh0aGlzLl9pc1Jlc29sdmVkKCkpIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKGxpbWl0ID49IDEgJiYgdGhpcy5faW5GbGlnaHQgPj0gbGltaXQpIHtcbiAgICAgICAgICAgIHZhbHVlc1tpbmRleF0gPSB2YWx1ZTtcbiAgICAgICAgICAgIHRoaXMuX3F1ZXVlLnB1c2goaW5kZXgpO1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwcmVzZXJ2ZWRWYWx1ZXMgIT09IG51bGwpIHByZXNlcnZlZFZhbHVlc1tpbmRleF0gPSB2YWx1ZTtcblxuICAgICAgICB2YXIgcHJvbWlzZSA9IHRoaXMuX3Byb21pc2U7XG4gICAgICAgIHZhciBjYWxsYmFjayA9IHRoaXMuX2NhbGxiYWNrO1xuICAgICAgICB2YXIgcmVjZWl2ZXIgPSBwcm9taXNlLl9ib3VuZFZhbHVlKCk7XG4gICAgICAgIHByb21pc2UuX3B1c2hDb250ZXh0KCk7XG4gICAgICAgIHZhciByZXQgPSB0cnlDYXRjaChjYWxsYmFjaykuY2FsbChyZWNlaXZlciwgdmFsdWUsIGluZGV4LCBsZW5ndGgpO1xuICAgICAgICB2YXIgcHJvbWlzZUNyZWF0ZWQgPSBwcm9taXNlLl9wb3BDb250ZXh0KCk7XG4gICAgICAgIGRlYnVnLmNoZWNrRm9yZ290dGVuUmV0dXJucyhcbiAgICAgICAgICAgIHJldCxcbiAgICAgICAgICAgIHByb21pc2VDcmVhdGVkLFxuICAgICAgICAgICAgcHJlc2VydmVkVmFsdWVzICE9PSBudWxsID8gXCJQcm9taXNlLmZpbHRlclwiIDogXCJQcm9taXNlLm1hcFwiLFxuICAgICAgICAgICAgcHJvbWlzZVxuICAgICAgICApO1xuICAgICAgICBpZiAocmV0ID09PSBlcnJvck9iaikge1xuICAgICAgICAgICAgdGhpcy5fcmVqZWN0KHJldC5lKTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIG1heWJlUHJvbWlzZSA9IHRyeUNvbnZlcnRUb1Byb21pc2UocmV0LCB0aGlzLl9wcm9taXNlKTtcbiAgICAgICAgaWYgKG1heWJlUHJvbWlzZSBpbnN0YW5jZW9mIFByb21pc2UpIHtcbiAgICAgICAgICAgIG1heWJlUHJvbWlzZSA9IG1heWJlUHJvbWlzZS5fdGFyZ2V0KCk7XG4gICAgICAgICAgICB2YXIgYml0RmllbGQgPSBtYXliZVByb21pc2UuX2JpdEZpZWxkO1xuICAgICAgICAgICAgO1xuICAgICAgICAgICAgaWYgKCgoYml0RmllbGQgJiA1MDM5NzE4NCkgPT09IDApKSB7XG4gICAgICAgICAgICAgICAgaWYgKGxpbWl0ID49IDEpIHRoaXMuX2luRmxpZ2h0Kys7XG4gICAgICAgICAgICAgICAgdmFsdWVzW2luZGV4XSA9IG1heWJlUHJvbWlzZTtcbiAgICAgICAgICAgICAgICBtYXliZVByb21pc2UuX3Byb3h5KHRoaXMsIChpbmRleCArIDEpICogLTEpO1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoKChiaXRGaWVsZCAmIDMzNTU0NDMyKSAhPT0gMCkpIHtcbiAgICAgICAgICAgICAgICByZXQgPSBtYXliZVByb21pc2UuX3ZhbHVlKCk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKCgoYml0RmllbGQgJiAxNjc3NzIxNikgIT09IDApKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fcmVqZWN0KG1heWJlUHJvbWlzZS5fcmVhc29uKCkpO1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9jYW5jZWwoKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB2YWx1ZXNbaW5kZXhdID0gcmV0O1xuICAgIH1cbiAgICB2YXIgdG90YWxSZXNvbHZlZCA9ICsrdGhpcy5fdG90YWxSZXNvbHZlZDtcbiAgICBpZiAodG90YWxSZXNvbHZlZCA+PSBsZW5ndGgpIHtcbiAgICAgICAgaWYgKHByZXNlcnZlZFZhbHVlcyAhPT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5fZmlsdGVyKHZhbHVlcywgcHJlc2VydmVkVmFsdWVzKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX3Jlc29sdmUodmFsdWVzKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufTtcblxuTWFwcGluZ1Byb21pc2VBcnJheS5wcm90b3R5cGUuX2RyYWluUXVldWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHF1ZXVlID0gdGhpcy5fcXVldWU7XG4gICAgdmFyIGxpbWl0ID0gdGhpcy5fbGltaXQ7XG4gICAgdmFyIHZhbHVlcyA9IHRoaXMuX3ZhbHVlcztcbiAgICB3aGlsZSAocXVldWUubGVuZ3RoID4gMCAmJiB0aGlzLl9pbkZsaWdodCA8IGxpbWl0KSB7XG4gICAgICAgIGlmICh0aGlzLl9pc1Jlc29sdmVkKCkpIHJldHVybjtcbiAgICAgICAgdmFyIGluZGV4ID0gcXVldWUucG9wKCk7XG4gICAgICAgIHRoaXMuX3Byb21pc2VGdWxmaWxsZWQodmFsdWVzW2luZGV4XSwgaW5kZXgpO1xuICAgIH1cbn07XG5cbk1hcHBpbmdQcm9taXNlQXJyYXkucHJvdG90eXBlLl9maWx0ZXIgPSBmdW5jdGlvbiAoYm9vbGVhbnMsIHZhbHVlcykge1xuICAgIHZhciBsZW4gPSB2YWx1ZXMubGVuZ3RoO1xuICAgIHZhciByZXQgPSBuZXcgQXJyYXkobGVuKTtcbiAgICB2YXIgaiA9IDA7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47ICsraSkge1xuICAgICAgICBpZiAoYm9vbGVhbnNbaV0pIHJldFtqKytdID0gdmFsdWVzW2ldO1xuICAgIH1cbiAgICByZXQubGVuZ3RoID0gajtcbiAgICB0aGlzLl9yZXNvbHZlKHJldCk7XG59O1xuXG5NYXBwaW5nUHJvbWlzZUFycmF5LnByb3RvdHlwZS5wcmVzZXJ2ZWRWYWx1ZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3ByZXNlcnZlZFZhbHVlcztcbn07XG5cbmZ1bmN0aW9uIG1hcChwcm9taXNlcywgZm4sIG9wdGlvbnMsIF9maWx0ZXIpIHtcbiAgICBpZiAodHlwZW9mIGZuICE9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgcmV0dXJuIGFwaVJlamVjdGlvbihcImV4cGVjdGluZyBhIGZ1bmN0aW9uIGJ1dCBnb3QgXCIgKyB1dGlsLmNsYXNzU3RyaW5nKGZuKSk7XG4gICAgfVxuXG4gICAgdmFyIGxpbWl0ID0gMDtcbiAgICBpZiAob3B0aW9ucyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGlmICh0eXBlb2Ygb3B0aW9ucyA9PT0gXCJvYmplY3RcIiAmJiBvcHRpb25zICE9PSBudWxsKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIG9wdGlvbnMuY29uY3VycmVuY3kgIT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoXG4gICAgICAgICAgICAgICAgICAgIG5ldyBUeXBlRXJyb3IoXCInY29uY3VycmVuY3knIG11c3QgYmUgYSBudW1iZXIgYnV0IGl0IGlzIFwiICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHV0aWwuY2xhc3NTdHJpbmcob3B0aW9ucy5jb25jdXJyZW5jeSkpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxpbWl0ID0gb3B0aW9ucy5jb25jdXJyZW5jeTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChuZXcgVHlwZUVycm9yKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwib3B0aW9ucyBhcmd1bWVudCBtdXN0IGJlIGFuIG9iamVjdCBidXQgaXQgaXMgXCIgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICB1dGlsLmNsYXNzU3RyaW5nKG9wdGlvbnMpKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgbGltaXQgPSB0eXBlb2YgbGltaXQgPT09IFwibnVtYmVyXCIgJiZcbiAgICAgICAgaXNGaW5pdGUobGltaXQpICYmIGxpbWl0ID49IDEgPyBsaW1pdCA6IDA7XG4gICAgcmV0dXJuIG5ldyBNYXBwaW5nUHJvbWlzZUFycmF5KHByb21pc2VzLCBmbiwgbGltaXQsIF9maWx0ZXIpLnByb21pc2UoKTtcbn1cblxuUHJvbWlzZS5wcm90b3R5cGUubWFwID0gZnVuY3Rpb24gKGZuLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIG1hcCh0aGlzLCBmbiwgb3B0aW9ucywgbnVsbCk7XG59O1xuXG5Qcm9taXNlLm1hcCA9IGZ1bmN0aW9uIChwcm9taXNlcywgZm4sIG9wdGlvbnMsIF9maWx0ZXIpIHtcbiAgICByZXR1cm4gbWFwKHByb21pc2VzLCBmbiwgb3B0aW9ucywgX2ZpbHRlcik7XG59O1xuXG5cbn07XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvYmx1ZWJpcmQvanMvcmVsZWFzZS9tYXAuanMiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBjciA9IE9iamVjdC5jcmVhdGU7XG5pZiAoY3IpIHtcbiAgICB2YXIgY2FsbGVyQ2FjaGUgPSBjcihudWxsKTtcbiAgICB2YXIgZ2V0dGVyQ2FjaGUgPSBjcihudWxsKTtcbiAgICBjYWxsZXJDYWNoZVtcIiBzaXplXCJdID0gZ2V0dGVyQ2FjaGVbXCIgc2l6ZVwiXSA9IDA7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oUHJvbWlzZSkge1xudmFyIHV0aWwgPSByZXF1aXJlKFwiLi91dGlsXCIpO1xudmFyIGNhbkV2YWx1YXRlID0gdXRpbC5jYW5FdmFsdWF0ZTtcbnZhciBpc0lkZW50aWZpZXIgPSB1dGlsLmlzSWRlbnRpZmllcjtcblxudmFyIGdldE1ldGhvZENhbGxlcjtcbnZhciBnZXRHZXR0ZXI7XG5pZiAoIWZhbHNlKSB7XG52YXIgbWFrZU1ldGhvZENhbGxlciA9IGZ1bmN0aW9uIChtZXRob2ROYW1lKSB7XG4gICAgcmV0dXJuIG5ldyBGdW5jdGlvbihcImVuc3VyZU1ldGhvZFwiLCBcIiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxcblxcXG4gICAgICAgIHJldHVybiBmdW5jdGlvbihvYmopIHsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxcblxcXG4gICAgICAgICAgICAndXNlIHN0cmljdCcgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxcblxcXG4gICAgICAgICAgICB2YXIgbGVuID0gdGhpcy5sZW5ndGg7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxcblxcXG4gICAgICAgICAgICBlbnN1cmVNZXRob2Qob2JqLCAnbWV0aG9kTmFtZScpOyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxcblxcXG4gICAgICAgICAgICBzd2l0Y2gobGVuKSB7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxcblxcXG4gICAgICAgICAgICAgICAgY2FzZSAxOiByZXR1cm4gb2JqLm1ldGhvZE5hbWUodGhpc1swXSk7ICAgICAgICAgICAgICAgICAgICAgIFxcblxcXG4gICAgICAgICAgICAgICAgY2FzZSAyOiByZXR1cm4gb2JqLm1ldGhvZE5hbWUodGhpc1swXSwgdGhpc1sxXSk7ICAgICAgICAgICAgIFxcblxcXG4gICAgICAgICAgICAgICAgY2FzZSAzOiByZXR1cm4gb2JqLm1ldGhvZE5hbWUodGhpc1swXSwgdGhpc1sxXSwgdGhpc1syXSk7ICAgIFxcblxcXG4gICAgICAgICAgICAgICAgY2FzZSAwOiByZXR1cm4gb2JqLm1ldGhvZE5hbWUoKTsgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxcblxcXG4gICAgICAgICAgICAgICAgZGVmYXVsdDogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxcblxcXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBvYmoubWV0aG9kTmFtZS5hcHBseShvYmosIHRoaXMpOyAgICAgICAgICAgICAgICAgIFxcblxcXG4gICAgICAgICAgICB9ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxcblxcXG4gICAgICAgIH07ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxcblxcXG4gICAgICAgIFwiLnJlcGxhY2UoL21ldGhvZE5hbWUvZywgbWV0aG9kTmFtZSkpKGVuc3VyZU1ldGhvZCk7XG59O1xuXG52YXIgbWFrZUdldHRlciA9IGZ1bmN0aW9uIChwcm9wZXJ0eU5hbWUpIHtcbiAgICByZXR1cm4gbmV3IEZ1bmN0aW9uKFwib2JqXCIsIFwiICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXFxuXFxcbiAgICAgICAgJ3VzZSBzdHJpY3QnOyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXFxuXFxcbiAgICAgICAgcmV0dXJuIG9iai5wcm9wZXJ0eU5hbWU7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXFxuXFxcbiAgICAgICAgXCIucmVwbGFjZShcInByb3BlcnR5TmFtZVwiLCBwcm9wZXJ0eU5hbWUpKTtcbn07XG5cbnZhciBnZXRDb21waWxlZCA9IGZ1bmN0aW9uKG5hbWUsIGNvbXBpbGVyLCBjYWNoZSkge1xuICAgIHZhciByZXQgPSBjYWNoZVtuYW1lXTtcbiAgICBpZiAodHlwZW9mIHJldCAhPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIGlmICghaXNJZGVudGlmaWVyKG5hbWUpKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICByZXQgPSBjb21waWxlcihuYW1lKTtcbiAgICAgICAgY2FjaGVbbmFtZV0gPSByZXQ7XG4gICAgICAgIGNhY2hlW1wiIHNpemVcIl0rKztcbiAgICAgICAgaWYgKGNhY2hlW1wiIHNpemVcIl0gPiA1MTIpIHtcbiAgICAgICAgICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXMoY2FjaGUpO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCAyNTY7ICsraSkgZGVsZXRlIGNhY2hlW2tleXNbaV1dO1xuICAgICAgICAgICAgY2FjaGVbXCIgc2l6ZVwiXSA9IGtleXMubGVuZ3RoIC0gMjU2O1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXQ7XG59O1xuXG5nZXRNZXRob2RDYWxsZXIgPSBmdW5jdGlvbihuYW1lKSB7XG4gICAgcmV0dXJuIGdldENvbXBpbGVkKG5hbWUsIG1ha2VNZXRob2RDYWxsZXIsIGNhbGxlckNhY2hlKTtcbn07XG5cbmdldEdldHRlciA9IGZ1bmN0aW9uKG5hbWUpIHtcbiAgICByZXR1cm4gZ2V0Q29tcGlsZWQobmFtZSwgbWFrZUdldHRlciwgZ2V0dGVyQ2FjaGUpO1xufTtcbn1cblxuZnVuY3Rpb24gZW5zdXJlTWV0aG9kKG9iaiwgbWV0aG9kTmFtZSkge1xuICAgIHZhciBmbjtcbiAgICBpZiAob2JqICE9IG51bGwpIGZuID0gb2JqW21ldGhvZE5hbWVdO1xuICAgIGlmICh0eXBlb2YgZm4gIT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICB2YXIgbWVzc2FnZSA9IFwiT2JqZWN0IFwiICsgdXRpbC5jbGFzc1N0cmluZyhvYmopICsgXCIgaGFzIG5vIG1ldGhvZCAnXCIgK1xuICAgICAgICAgICAgdXRpbC50b1N0cmluZyhtZXRob2ROYW1lKSArIFwiJ1wiO1xuICAgICAgICB0aHJvdyBuZXcgUHJvbWlzZS5UeXBlRXJyb3IobWVzc2FnZSk7XG4gICAgfVxuICAgIHJldHVybiBmbjtcbn1cblxuZnVuY3Rpb24gY2FsbGVyKG9iaikge1xuICAgIHZhciBtZXRob2ROYW1lID0gdGhpcy5wb3AoKTtcbiAgICB2YXIgZm4gPSBlbnN1cmVNZXRob2Qob2JqLCBtZXRob2ROYW1lKTtcbiAgICByZXR1cm4gZm4uYXBwbHkob2JqLCB0aGlzKTtcbn1cblByb21pc2UucHJvdG90eXBlLmNhbGwgPSBmdW5jdGlvbiAobWV0aG9kTmFtZSkge1xuICAgIHZhciAkX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGg7dmFyIGFyZ3MgPSBuZXcgQXJyYXkoTWF0aC5tYXgoJF9sZW4gLSAxLCAwKSk7IGZvcih2YXIgJF9pID0gMTsgJF9pIDwgJF9sZW47ICsrJF9pKSB7YXJnc1skX2kgLSAxXSA9IGFyZ3VtZW50c1skX2ldO307XG4gICAgaWYgKCFmYWxzZSkge1xuICAgICAgICBpZiAoY2FuRXZhbHVhdGUpIHtcbiAgICAgICAgICAgIHZhciBtYXliZUNhbGxlciA9IGdldE1ldGhvZENhbGxlcihtZXRob2ROYW1lKTtcbiAgICAgICAgICAgIGlmIChtYXliZUNhbGxlciAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl90aGVuKFxuICAgICAgICAgICAgICAgICAgICBtYXliZUNhbGxlciwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIGFyZ3MsIHVuZGVmaW5lZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXJncy5wdXNoKG1ldGhvZE5hbWUpO1xuICAgIHJldHVybiB0aGlzLl90aGVuKGNhbGxlciwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIGFyZ3MsIHVuZGVmaW5lZCk7XG59O1xuXG5mdW5jdGlvbiBuYW1lZEdldHRlcihvYmopIHtcbiAgICByZXR1cm4gb2JqW3RoaXNdO1xufVxuZnVuY3Rpb24gaW5kZXhlZEdldHRlcihvYmopIHtcbiAgICB2YXIgaW5kZXggPSArdGhpcztcbiAgICBpZiAoaW5kZXggPCAwKSBpbmRleCA9IE1hdGgubWF4KDAsIGluZGV4ICsgb2JqLmxlbmd0aCk7XG4gICAgcmV0dXJuIG9ialtpbmRleF07XG59XG5Qcm9taXNlLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbiAocHJvcGVydHlOYW1lKSB7XG4gICAgdmFyIGlzSW5kZXggPSAodHlwZW9mIHByb3BlcnR5TmFtZSA9PT0gXCJudW1iZXJcIik7XG4gICAgdmFyIGdldHRlcjtcbiAgICBpZiAoIWlzSW5kZXgpIHtcbiAgICAgICAgaWYgKGNhbkV2YWx1YXRlKSB7XG4gICAgICAgICAgICB2YXIgbWF5YmVHZXR0ZXIgPSBnZXRHZXR0ZXIocHJvcGVydHlOYW1lKTtcbiAgICAgICAgICAgIGdldHRlciA9IG1heWJlR2V0dGVyICE9PSBudWxsID8gbWF5YmVHZXR0ZXIgOiBuYW1lZEdldHRlcjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGdldHRlciA9IG5hbWVkR2V0dGVyO1xuICAgICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgICAgZ2V0dGVyID0gaW5kZXhlZEdldHRlcjtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX3RoZW4oZ2V0dGVyLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgcHJvcGVydHlOYW1lLCB1bmRlZmluZWQpO1xufTtcbn07XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvYmx1ZWJpcmQvanMvcmVsZWFzZS9jYWxsX2dldC5qcyIsIlwidXNlIHN0cmljdFwiO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoUHJvbWlzZSwgYXBpUmVqZWN0aW9uLCB0cnlDb252ZXJ0VG9Qcm9taXNlLFxuICAgIGNyZWF0ZUNvbnRleHQsIElOVEVSTkFMLCBkZWJ1Zykge1xuICAgIHZhciB1dGlsID0gcmVxdWlyZShcIi4vdXRpbFwiKTtcbiAgICB2YXIgVHlwZUVycm9yID0gcmVxdWlyZShcIi4vZXJyb3JzXCIpLlR5cGVFcnJvcjtcbiAgICB2YXIgaW5oZXJpdHMgPSByZXF1aXJlKFwiLi91dGlsXCIpLmluaGVyaXRzO1xuICAgIHZhciBlcnJvck9iaiA9IHV0aWwuZXJyb3JPYmo7XG4gICAgdmFyIHRyeUNhdGNoID0gdXRpbC50cnlDYXRjaDtcbiAgICB2YXIgTlVMTCA9IHt9O1xuXG4gICAgZnVuY3Rpb24gdGhyb3dlcihlKSB7XG4gICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKXt0aHJvdyBlO30sIDApO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNhc3RQcmVzZXJ2aW5nRGlzcG9zYWJsZSh0aGVuYWJsZSkge1xuICAgICAgICB2YXIgbWF5YmVQcm9taXNlID0gdHJ5Q29udmVydFRvUHJvbWlzZSh0aGVuYWJsZSk7XG4gICAgICAgIGlmIChtYXliZVByb21pc2UgIT09IHRoZW5hYmxlICYmXG4gICAgICAgICAgICB0eXBlb2YgdGhlbmFibGUuX2lzRGlzcG9zYWJsZSA9PT0gXCJmdW5jdGlvblwiICYmXG4gICAgICAgICAgICB0eXBlb2YgdGhlbmFibGUuX2dldERpc3Bvc2VyID09PSBcImZ1bmN0aW9uXCIgJiZcbiAgICAgICAgICAgIHRoZW5hYmxlLl9pc0Rpc3Bvc2FibGUoKSkge1xuICAgICAgICAgICAgbWF5YmVQcm9taXNlLl9zZXREaXNwb3NhYmxlKHRoZW5hYmxlLl9nZXREaXNwb3NlcigpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWF5YmVQcm9taXNlO1xuICAgIH1cbiAgICBmdW5jdGlvbiBkaXNwb3NlKHJlc291cmNlcywgaW5zcGVjdGlvbikge1xuICAgICAgICB2YXIgaSA9IDA7XG4gICAgICAgIHZhciBsZW4gPSByZXNvdXJjZXMubGVuZ3RoO1xuICAgICAgICB2YXIgcmV0ID0gbmV3IFByb21pc2UoSU5URVJOQUwpO1xuICAgICAgICBmdW5jdGlvbiBpdGVyYXRvcigpIHtcbiAgICAgICAgICAgIGlmIChpID49IGxlbikgcmV0dXJuIHJldC5fZnVsZmlsbCgpO1xuICAgICAgICAgICAgdmFyIG1heWJlUHJvbWlzZSA9IGNhc3RQcmVzZXJ2aW5nRGlzcG9zYWJsZShyZXNvdXJjZXNbaSsrXSk7XG4gICAgICAgICAgICBpZiAobWF5YmVQcm9taXNlIGluc3RhbmNlb2YgUHJvbWlzZSAmJlxuICAgICAgICAgICAgICAgIG1heWJlUHJvbWlzZS5faXNEaXNwb3NhYmxlKCkpIHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBtYXliZVByb21pc2UgPSB0cnlDb252ZXJ0VG9Qcm9taXNlKFxuICAgICAgICAgICAgICAgICAgICAgICAgbWF5YmVQcm9taXNlLl9nZXREaXNwb3NlcigpLnRyeURpc3Bvc2UoaW5zcGVjdGlvbiksXG4gICAgICAgICAgICAgICAgICAgICAgICByZXNvdXJjZXMucHJvbWlzZSk7XG4gICAgICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhyb3dlcihlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKG1heWJlUHJvbWlzZSBpbnN0YW5jZW9mIFByb21pc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG1heWJlUHJvbWlzZS5fdGhlbihpdGVyYXRvciwgdGhyb3dlcixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBudWxsLCBudWxsLCBudWxsKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpdGVyYXRvcigpO1xuICAgICAgICB9XG4gICAgICAgIGl0ZXJhdG9yKCk7XG4gICAgICAgIHJldHVybiByZXQ7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gRGlzcG9zZXIoZGF0YSwgcHJvbWlzZSwgY29udGV4dCkge1xuICAgICAgICB0aGlzLl9kYXRhID0gZGF0YTtcbiAgICAgICAgdGhpcy5fcHJvbWlzZSA9IHByb21pc2U7XG4gICAgICAgIHRoaXMuX2NvbnRleHQgPSBjb250ZXh0O1xuICAgIH1cblxuICAgIERpc3Bvc2VyLnByb3RvdHlwZS5kYXRhID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZGF0YTtcbiAgICB9O1xuXG4gICAgRGlzcG9zZXIucHJvdG90eXBlLnByb21pc2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9wcm9taXNlO1xuICAgIH07XG5cbiAgICBEaXNwb3Nlci5wcm90b3R5cGUucmVzb3VyY2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLnByb21pc2UoKS5pc0Z1bGZpbGxlZCgpKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5wcm9taXNlKCkudmFsdWUoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gTlVMTDtcbiAgICB9O1xuXG4gICAgRGlzcG9zZXIucHJvdG90eXBlLnRyeURpc3Bvc2UgPSBmdW5jdGlvbihpbnNwZWN0aW9uKSB7XG4gICAgICAgIHZhciByZXNvdXJjZSA9IHRoaXMucmVzb3VyY2UoKTtcbiAgICAgICAgdmFyIGNvbnRleHQgPSB0aGlzLl9jb250ZXh0O1xuICAgICAgICBpZiAoY29udGV4dCAhPT0gdW5kZWZpbmVkKSBjb250ZXh0Ll9wdXNoQ29udGV4dCgpO1xuICAgICAgICB2YXIgcmV0ID0gcmVzb3VyY2UgIT09IE5VTExcbiAgICAgICAgICAgID8gdGhpcy5kb0Rpc3Bvc2UocmVzb3VyY2UsIGluc3BlY3Rpb24pIDogbnVsbDtcbiAgICAgICAgaWYgKGNvbnRleHQgIT09IHVuZGVmaW5lZCkgY29udGV4dC5fcG9wQ29udGV4dCgpO1xuICAgICAgICB0aGlzLl9wcm9taXNlLl91bnNldERpc3Bvc2FibGUoKTtcbiAgICAgICAgdGhpcy5fZGF0YSA9IG51bGw7XG4gICAgICAgIHJldHVybiByZXQ7XG4gICAgfTtcblxuICAgIERpc3Bvc2VyLmlzRGlzcG9zZXIgPSBmdW5jdGlvbiAoZCkge1xuICAgICAgICByZXR1cm4gKGQgIT0gbnVsbCAmJlxuICAgICAgICAgICAgICAgIHR5cGVvZiBkLnJlc291cmNlID09PSBcImZ1bmN0aW9uXCIgJiZcbiAgICAgICAgICAgICAgICB0eXBlb2YgZC50cnlEaXNwb3NlID09PSBcImZ1bmN0aW9uXCIpO1xuICAgIH07XG5cbiAgICBmdW5jdGlvbiBGdW5jdGlvbkRpc3Bvc2VyKGZuLCBwcm9taXNlLCBjb250ZXh0KSB7XG4gICAgICAgIHRoaXMuY29uc3RydWN0b3IkKGZuLCBwcm9taXNlLCBjb250ZXh0KTtcbiAgICB9XG4gICAgaW5oZXJpdHMoRnVuY3Rpb25EaXNwb3NlciwgRGlzcG9zZXIpO1xuXG4gICAgRnVuY3Rpb25EaXNwb3Nlci5wcm90b3R5cGUuZG9EaXNwb3NlID0gZnVuY3Rpb24gKHJlc291cmNlLCBpbnNwZWN0aW9uKSB7XG4gICAgICAgIHZhciBmbiA9IHRoaXMuZGF0YSgpO1xuICAgICAgICByZXR1cm4gZm4uY2FsbChyZXNvdXJjZSwgcmVzb3VyY2UsIGluc3BlY3Rpb24pO1xuICAgIH07XG5cbiAgICBmdW5jdGlvbiBtYXliZVVud3JhcERpc3Bvc2VyKHZhbHVlKSB7XG4gICAgICAgIGlmIChEaXNwb3Nlci5pc0Rpc3Bvc2VyKHZhbHVlKSkge1xuICAgICAgICAgICAgdGhpcy5yZXNvdXJjZXNbdGhpcy5pbmRleF0uX3NldERpc3Bvc2FibGUodmFsdWUpO1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlLnByb21pc2UoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gUmVzb3VyY2VMaXN0KGxlbmd0aCkge1xuICAgICAgICB0aGlzLmxlbmd0aCA9IGxlbmd0aDtcbiAgICAgICAgdGhpcy5wcm9taXNlID0gbnVsbDtcbiAgICAgICAgdGhpc1tsZW5ndGgtMV0gPSBudWxsO1xuICAgIH1cblxuICAgIFJlc291cmNlTGlzdC5wcm90b3R5cGUuX3Jlc3VsdENhbmNlbGxlZCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgbGVuID0gdGhpcy5sZW5ndGg7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyArK2kpIHtcbiAgICAgICAgICAgIHZhciBpdGVtID0gdGhpc1tpXTtcbiAgICAgICAgICAgIGlmIChpdGVtIGluc3RhbmNlb2YgUHJvbWlzZSkge1xuICAgICAgICAgICAgICAgIGl0ZW0uY2FuY2VsKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgUHJvbWlzZS51c2luZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgICAgIGlmIChsZW4gPCAyKSByZXR1cm4gYXBpUmVqZWN0aW9uKFxuICAgICAgICAgICAgICAgICAgICAgICAgXCJ5b3UgbXVzdCBwYXNzIGF0IGxlYXN0IDIgYXJndW1lbnRzIHRvIFByb21pc2UudXNpbmdcIik7XG4gICAgICAgIHZhciBmbiA9IGFyZ3VtZW50c1tsZW4gLSAxXTtcbiAgICAgICAgaWYgKHR5cGVvZiBmbiAhPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICByZXR1cm4gYXBpUmVqZWN0aW9uKFwiZXhwZWN0aW5nIGEgZnVuY3Rpb24gYnV0IGdvdCBcIiArIHV0aWwuY2xhc3NTdHJpbmcoZm4pKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgaW5wdXQ7XG4gICAgICAgIHZhciBzcHJlYWRBcmdzID0gdHJ1ZTtcbiAgICAgICAgaWYgKGxlbiA9PT0gMiAmJiBBcnJheS5pc0FycmF5KGFyZ3VtZW50c1swXSkpIHtcbiAgICAgICAgICAgIGlucHV0ID0gYXJndW1lbnRzWzBdO1xuICAgICAgICAgICAgbGVuID0gaW5wdXQubGVuZ3RoO1xuICAgICAgICAgICAgc3ByZWFkQXJncyA9IGZhbHNlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaW5wdXQgPSBhcmd1bWVudHM7XG4gICAgICAgICAgICBsZW4tLTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgcmVzb3VyY2VzID0gbmV3IFJlc291cmNlTGlzdChsZW4pO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgKytpKSB7XG4gICAgICAgICAgICB2YXIgcmVzb3VyY2UgPSBpbnB1dFtpXTtcbiAgICAgICAgICAgIGlmIChEaXNwb3Nlci5pc0Rpc3Bvc2VyKHJlc291cmNlKSkge1xuICAgICAgICAgICAgICAgIHZhciBkaXNwb3NlciA9IHJlc291cmNlO1xuICAgICAgICAgICAgICAgIHJlc291cmNlID0gcmVzb3VyY2UucHJvbWlzZSgpO1xuICAgICAgICAgICAgICAgIHJlc291cmNlLl9zZXREaXNwb3NhYmxlKGRpc3Bvc2VyKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdmFyIG1heWJlUHJvbWlzZSA9IHRyeUNvbnZlcnRUb1Byb21pc2UocmVzb3VyY2UpO1xuICAgICAgICAgICAgICAgIGlmIChtYXliZVByb21pc2UgaW5zdGFuY2VvZiBQcm9taXNlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc291cmNlID1cbiAgICAgICAgICAgICAgICAgICAgICAgIG1heWJlUHJvbWlzZS5fdGhlbihtYXliZVVud3JhcERpc3Bvc2VyLCBudWxsLCBudWxsLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzb3VyY2VzOiByZXNvdXJjZXMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5kZXg6IGlcbiAgICAgICAgICAgICAgICAgICAgfSwgdW5kZWZpbmVkKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXNvdXJjZXNbaV0gPSByZXNvdXJjZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciByZWZsZWN0ZWRSZXNvdXJjZXMgPSBuZXcgQXJyYXkocmVzb3VyY2VzLmxlbmd0aCk7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcmVmbGVjdGVkUmVzb3VyY2VzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICByZWZsZWN0ZWRSZXNvdXJjZXNbaV0gPSBQcm9taXNlLnJlc29sdmUocmVzb3VyY2VzW2ldKS5yZWZsZWN0KCk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgcmVzdWx0UHJvbWlzZSA9IFByb21pc2UuYWxsKHJlZmxlY3RlZFJlc291cmNlcylcbiAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uKGluc3BlY3Rpb25zKSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBpbnNwZWN0aW9ucy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgaW5zcGVjdGlvbiA9IGluc3BlY3Rpb25zW2ldO1xuICAgICAgICAgICAgICAgICAgICBpZiAoaW5zcGVjdGlvbi5pc1JlamVjdGVkKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yT2JqLmUgPSBpbnNwZWN0aW9uLmVycm9yKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZXJyb3JPYmo7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoIWluc3BlY3Rpb24uaXNGdWxmaWxsZWQoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0UHJvbWlzZS5jYW5jZWwoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpbnNwZWN0aW9uc1tpXSA9IGluc3BlY3Rpb24udmFsdWUoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcHJvbWlzZS5fcHVzaENvbnRleHQoKTtcblxuICAgICAgICAgICAgICAgIGZuID0gdHJ5Q2F0Y2goZm4pO1xuICAgICAgICAgICAgICAgIHZhciByZXQgPSBzcHJlYWRBcmdzXG4gICAgICAgICAgICAgICAgICAgID8gZm4uYXBwbHkodW5kZWZpbmVkLCBpbnNwZWN0aW9ucykgOiBmbihpbnNwZWN0aW9ucyk7XG4gICAgICAgICAgICAgICAgdmFyIHByb21pc2VDcmVhdGVkID0gcHJvbWlzZS5fcG9wQ29udGV4dCgpO1xuICAgICAgICAgICAgICAgIGRlYnVnLmNoZWNrRm9yZ290dGVuUmV0dXJucyhcbiAgICAgICAgICAgICAgICAgICAgcmV0LCBwcm9taXNlQ3JlYXRlZCwgXCJQcm9taXNlLnVzaW5nXCIsIHByb21pc2UpO1xuICAgICAgICAgICAgICAgIHJldHVybiByZXQ7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICB2YXIgcHJvbWlzZSA9IHJlc3VsdFByb21pc2UubGFzdGx5KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIGluc3BlY3Rpb24gPSBuZXcgUHJvbWlzZS5Qcm9taXNlSW5zcGVjdGlvbihyZXN1bHRQcm9taXNlKTtcbiAgICAgICAgICAgIHJldHVybiBkaXNwb3NlKHJlc291cmNlcywgaW5zcGVjdGlvbik7XG4gICAgICAgIH0pO1xuICAgICAgICByZXNvdXJjZXMucHJvbWlzZSA9IHByb21pc2U7XG4gICAgICAgIHByb21pc2UuX3NldE9uQ2FuY2VsKHJlc291cmNlcyk7XG4gICAgICAgIHJldHVybiBwcm9taXNlO1xuICAgIH07XG5cbiAgICBQcm9taXNlLnByb3RvdHlwZS5fc2V0RGlzcG9zYWJsZSA9IGZ1bmN0aW9uIChkaXNwb3Nlcikge1xuICAgICAgICB0aGlzLl9iaXRGaWVsZCA9IHRoaXMuX2JpdEZpZWxkIHwgMTMxMDcyO1xuICAgICAgICB0aGlzLl9kaXNwb3NlciA9IGRpc3Bvc2VyO1xuICAgIH07XG5cbiAgICBQcm9taXNlLnByb3RvdHlwZS5faXNEaXNwb3NhYmxlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gKHRoaXMuX2JpdEZpZWxkICYgMTMxMDcyKSA+IDA7XG4gICAgfTtcblxuICAgIFByb21pc2UucHJvdG90eXBlLl9nZXREaXNwb3NlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2Rpc3Bvc2VyO1xuICAgIH07XG5cbiAgICBQcm9taXNlLnByb3RvdHlwZS5fdW5zZXREaXNwb3NhYmxlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLl9iaXRGaWVsZCA9IHRoaXMuX2JpdEZpZWxkICYgKH4xMzEwNzIpO1xuICAgICAgICB0aGlzLl9kaXNwb3NlciA9IHVuZGVmaW5lZDtcbiAgICB9O1xuXG4gICAgUHJvbWlzZS5wcm90b3R5cGUuZGlzcG9zZXIgPSBmdW5jdGlvbiAoZm4pIHtcbiAgICAgICAgaWYgKHR5cGVvZiBmbiA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEZ1bmN0aW9uRGlzcG9zZXIoZm4sIHRoaXMsIGNyZWF0ZUNvbnRleHQoKSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcigpO1xuICAgIH07XG5cbn07XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvYmx1ZWJpcmQvanMvcmVsZWFzZS91c2luZy5qcyIsIlwidXNlIHN0cmljdFwiO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihQcm9taXNlLCBJTlRFUk5BTCwgZGVidWcpIHtcbnZhciB1dGlsID0gcmVxdWlyZShcIi4vdXRpbFwiKTtcbnZhciBUaW1lb3V0RXJyb3IgPSBQcm9taXNlLlRpbWVvdXRFcnJvcjtcblxuZnVuY3Rpb24gSGFuZGxlV3JhcHBlcihoYW5kbGUpICB7XG4gICAgdGhpcy5oYW5kbGUgPSBoYW5kbGU7XG59XG5cbkhhbmRsZVdyYXBwZXIucHJvdG90eXBlLl9yZXN1bHRDYW5jZWxsZWQgPSBmdW5jdGlvbigpIHtcbiAgICBjbGVhclRpbWVvdXQodGhpcy5oYW5kbGUpO1xufTtcblxudmFyIGFmdGVyVmFsdWUgPSBmdW5jdGlvbih2YWx1ZSkgeyByZXR1cm4gZGVsYXkoK3RoaXMpLnRoZW5SZXR1cm4odmFsdWUpOyB9O1xudmFyIGRlbGF5ID0gUHJvbWlzZS5kZWxheSA9IGZ1bmN0aW9uIChtcywgdmFsdWUpIHtcbiAgICB2YXIgcmV0O1xuICAgIHZhciBoYW5kbGU7XG4gICAgaWYgKHZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0ID0gUHJvbWlzZS5yZXNvbHZlKHZhbHVlKVxuICAgICAgICAgICAgICAgIC5fdGhlbihhZnRlclZhbHVlLCBudWxsLCBudWxsLCBtcywgdW5kZWZpbmVkKTtcbiAgICAgICAgaWYgKGRlYnVnLmNhbmNlbGxhdGlvbigpICYmIHZhbHVlIGluc3RhbmNlb2YgUHJvbWlzZSkge1xuICAgICAgICAgICAgcmV0Ll9zZXRPbkNhbmNlbCh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgICByZXQgPSBuZXcgUHJvbWlzZShJTlRFUk5BTCk7XG4gICAgICAgIGhhbmRsZSA9IHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7IHJldC5fZnVsZmlsbCgpOyB9LCArbXMpO1xuICAgICAgICBpZiAoZGVidWcuY2FuY2VsbGF0aW9uKCkpIHtcbiAgICAgICAgICAgIHJldC5fc2V0T25DYW5jZWwobmV3IEhhbmRsZVdyYXBwZXIoaGFuZGxlKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0Ll9jYXB0dXJlU3RhY2tUcmFjZSgpO1xuICAgIH1cbiAgICByZXQuX3NldEFzeW5jR3VhcmFudGVlZCgpO1xuICAgIHJldHVybiByZXQ7XG59O1xuXG5Qcm9taXNlLnByb3RvdHlwZS5kZWxheSA9IGZ1bmN0aW9uIChtcykge1xuICAgIHJldHVybiBkZWxheShtcywgdGhpcyk7XG59O1xuXG52YXIgYWZ0ZXJUaW1lb3V0ID0gZnVuY3Rpb24gKHByb21pc2UsIG1lc3NhZ2UsIHBhcmVudCkge1xuICAgIHZhciBlcnI7XG4gICAgaWYgKHR5cGVvZiBtZXNzYWdlICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIGlmIChtZXNzYWdlIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgICAgICAgIGVyciA9IG1lc3NhZ2U7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBlcnIgPSBuZXcgVGltZW91dEVycm9yKFwib3BlcmF0aW9uIHRpbWVkIG91dFwiKTtcbiAgICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAgIGVyciA9IG5ldyBUaW1lb3V0RXJyb3IobWVzc2FnZSk7XG4gICAgfVxuICAgIHV0aWwubWFya0FzT3JpZ2luYXRpbmdGcm9tUmVqZWN0aW9uKGVycik7XG4gICAgcHJvbWlzZS5fYXR0YWNoRXh0cmFUcmFjZShlcnIpO1xuICAgIHByb21pc2UuX3JlamVjdChlcnIpO1xuXG4gICAgaWYgKHBhcmVudCAhPSBudWxsKSB7XG4gICAgICAgIHBhcmVudC5jYW5jZWwoKTtcbiAgICB9XG59O1xuXG5mdW5jdGlvbiBzdWNjZXNzQ2xlYXIodmFsdWUpIHtcbiAgICBjbGVhclRpbWVvdXQodGhpcy5oYW5kbGUpO1xuICAgIHJldHVybiB2YWx1ZTtcbn1cblxuZnVuY3Rpb24gZmFpbHVyZUNsZWFyKHJlYXNvbikge1xuICAgIGNsZWFyVGltZW91dCh0aGlzLmhhbmRsZSk7XG4gICAgdGhyb3cgcmVhc29uO1xufVxuXG5Qcm9taXNlLnByb3RvdHlwZS50aW1lb3V0ID0gZnVuY3Rpb24gKG1zLCBtZXNzYWdlKSB7XG4gICAgbXMgPSArbXM7XG4gICAgdmFyIHJldCwgcGFyZW50O1xuXG4gICAgdmFyIGhhbmRsZVdyYXBwZXIgPSBuZXcgSGFuZGxlV3JhcHBlcihzZXRUaW1lb3V0KGZ1bmN0aW9uIHRpbWVvdXRUaW1lb3V0KCkge1xuICAgICAgICBpZiAocmV0LmlzUGVuZGluZygpKSB7XG4gICAgICAgICAgICBhZnRlclRpbWVvdXQocmV0LCBtZXNzYWdlLCBwYXJlbnQpO1xuICAgICAgICB9XG4gICAgfSwgbXMpKTtcblxuICAgIGlmIChkZWJ1Zy5jYW5jZWxsYXRpb24oKSkge1xuICAgICAgICBwYXJlbnQgPSB0aGlzLnRoZW4oKTtcbiAgICAgICAgcmV0ID0gcGFyZW50Ll90aGVuKHN1Y2Nlc3NDbGVhciwgZmFpbHVyZUNsZWFyLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVuZGVmaW5lZCwgaGFuZGxlV3JhcHBlciwgdW5kZWZpbmVkKTtcbiAgICAgICAgcmV0Ll9zZXRPbkNhbmNlbChoYW5kbGVXcmFwcGVyKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXQgPSB0aGlzLl90aGVuKHN1Y2Nlc3NDbGVhciwgZmFpbHVyZUNsZWFyLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVuZGVmaW5lZCwgaGFuZGxlV3JhcHBlciwgdW5kZWZpbmVkKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcmV0O1xufTtcblxufTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9ibHVlYmlyZC9qcy9yZWxlYXNlL3RpbWVycy5qcyIsIlwidXNlIHN0cmljdFwiO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihQcm9taXNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICBhcGlSZWplY3Rpb24sXG4gICAgICAgICAgICAgICAgICAgICAgICAgIElOVEVSTkFMLFxuICAgICAgICAgICAgICAgICAgICAgICAgICB0cnlDb252ZXJ0VG9Qcm9taXNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICBQcm94eWFibGUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGRlYnVnKSB7XG52YXIgZXJyb3JzID0gcmVxdWlyZShcIi4vZXJyb3JzXCIpO1xudmFyIFR5cGVFcnJvciA9IGVycm9ycy5UeXBlRXJyb3I7XG52YXIgdXRpbCA9IHJlcXVpcmUoXCIuL3V0aWxcIik7XG52YXIgZXJyb3JPYmogPSB1dGlsLmVycm9yT2JqO1xudmFyIHRyeUNhdGNoID0gdXRpbC50cnlDYXRjaDtcbnZhciB5aWVsZEhhbmRsZXJzID0gW107XG5cbmZ1bmN0aW9uIHByb21pc2VGcm9tWWllbGRIYW5kbGVyKHZhbHVlLCB5aWVsZEhhbmRsZXJzLCB0cmFjZVBhcmVudCkge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgeWllbGRIYW5kbGVycy5sZW5ndGg7ICsraSkge1xuICAgICAgICB0cmFjZVBhcmVudC5fcHVzaENvbnRleHQoKTtcbiAgICAgICAgdmFyIHJlc3VsdCA9IHRyeUNhdGNoKHlpZWxkSGFuZGxlcnNbaV0pKHZhbHVlKTtcbiAgICAgICAgdHJhY2VQYXJlbnQuX3BvcENvbnRleHQoKTtcbiAgICAgICAgaWYgKHJlc3VsdCA9PT0gZXJyb3JPYmopIHtcbiAgICAgICAgICAgIHRyYWNlUGFyZW50Ll9wdXNoQ29udGV4dCgpO1xuICAgICAgICAgICAgdmFyIHJldCA9IFByb21pc2UucmVqZWN0KGVycm9yT2JqLmUpO1xuICAgICAgICAgICAgdHJhY2VQYXJlbnQuX3BvcENvbnRleHQoKTtcbiAgICAgICAgICAgIHJldHVybiByZXQ7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG1heWJlUHJvbWlzZSA9IHRyeUNvbnZlcnRUb1Byb21pc2UocmVzdWx0LCB0cmFjZVBhcmVudCk7XG4gICAgICAgIGlmIChtYXliZVByb21pc2UgaW5zdGFuY2VvZiBQcm9taXNlKSByZXR1cm4gbWF5YmVQcm9taXNlO1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbn1cblxuZnVuY3Rpb24gUHJvbWlzZVNwYXduKGdlbmVyYXRvckZ1bmN0aW9uLCByZWNlaXZlciwgeWllbGRIYW5kbGVyLCBzdGFjaykge1xuICAgIGlmIChkZWJ1Zy5jYW5jZWxsYXRpb24oKSkge1xuICAgICAgICB2YXIgaW50ZXJuYWwgPSBuZXcgUHJvbWlzZShJTlRFUk5BTCk7XG4gICAgICAgIHZhciBfZmluYWxseVByb21pc2UgPSB0aGlzLl9maW5hbGx5UHJvbWlzZSA9IG5ldyBQcm9taXNlKElOVEVSTkFMKTtcbiAgICAgICAgdGhpcy5fcHJvbWlzZSA9IGludGVybmFsLmxhc3RseShmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiBfZmluYWxseVByb21pc2U7XG4gICAgICAgIH0pO1xuICAgICAgICBpbnRlcm5hbC5fY2FwdHVyZVN0YWNrVHJhY2UoKTtcbiAgICAgICAgaW50ZXJuYWwuX3NldE9uQ2FuY2VsKHRoaXMpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBwcm9taXNlID0gdGhpcy5fcHJvbWlzZSA9IG5ldyBQcm9taXNlKElOVEVSTkFMKTtcbiAgICAgICAgcHJvbWlzZS5fY2FwdHVyZVN0YWNrVHJhY2UoKTtcbiAgICB9XG4gICAgdGhpcy5fc3RhY2sgPSBzdGFjaztcbiAgICB0aGlzLl9nZW5lcmF0b3JGdW5jdGlvbiA9IGdlbmVyYXRvckZ1bmN0aW9uO1xuICAgIHRoaXMuX3JlY2VpdmVyID0gcmVjZWl2ZXI7XG4gICAgdGhpcy5fZ2VuZXJhdG9yID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuX3lpZWxkSGFuZGxlcnMgPSB0eXBlb2YgeWllbGRIYW5kbGVyID09PSBcImZ1bmN0aW9uXCJcbiAgICAgICAgPyBbeWllbGRIYW5kbGVyXS5jb25jYXQoeWllbGRIYW5kbGVycylcbiAgICAgICAgOiB5aWVsZEhhbmRsZXJzO1xuICAgIHRoaXMuX3lpZWxkZWRQcm9taXNlID0gbnVsbDtcbiAgICB0aGlzLl9jYW5jZWxsYXRpb25QaGFzZSA9IGZhbHNlO1xufVxudXRpbC5pbmhlcml0cyhQcm9taXNlU3Bhd24sIFByb3h5YWJsZSk7XG5cblByb21pc2VTcGF3bi5wcm90b3R5cGUuX2lzUmVzb2x2ZWQgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5fcHJvbWlzZSA9PT0gbnVsbDtcbn07XG5cblByb21pc2VTcGF3bi5wcm90b3R5cGUuX2NsZWFudXAgPSBmdW5jdGlvbigpIHtcbiAgICB0aGlzLl9wcm9taXNlID0gdGhpcy5fZ2VuZXJhdG9yID0gbnVsbDtcbiAgICBpZiAoZGVidWcuY2FuY2VsbGF0aW9uKCkgJiYgdGhpcy5fZmluYWxseVByb21pc2UgIT09IG51bGwpIHtcbiAgICAgICAgdGhpcy5fZmluYWxseVByb21pc2UuX2Z1bGZpbGwoKTtcbiAgICAgICAgdGhpcy5fZmluYWxseVByb21pc2UgPSBudWxsO1xuICAgIH1cbn07XG5cblByb21pc2VTcGF3bi5wcm90b3R5cGUuX3Byb21pc2VDYW5jZWxsZWQgPSBmdW5jdGlvbigpIHtcbiAgICBpZiAodGhpcy5faXNSZXNvbHZlZCgpKSByZXR1cm47XG4gICAgdmFyIGltcGxlbWVudHNSZXR1cm4gPSB0eXBlb2YgdGhpcy5fZ2VuZXJhdG9yW1wicmV0dXJuXCJdICE9PSBcInVuZGVmaW5lZFwiO1xuXG4gICAgdmFyIHJlc3VsdDtcbiAgICBpZiAoIWltcGxlbWVudHNSZXR1cm4pIHtcbiAgICAgICAgdmFyIHJlYXNvbiA9IG5ldyBQcm9taXNlLkNhbmNlbGxhdGlvbkVycm9yKFxuICAgICAgICAgICAgXCJnZW5lcmF0b3IgLnJldHVybigpIHNlbnRpbmVsXCIpO1xuICAgICAgICBQcm9taXNlLmNvcm91dGluZS5yZXR1cm5TZW50aW5lbCA9IHJlYXNvbjtcbiAgICAgICAgdGhpcy5fcHJvbWlzZS5fYXR0YWNoRXh0cmFUcmFjZShyZWFzb24pO1xuICAgICAgICB0aGlzLl9wcm9taXNlLl9wdXNoQ29udGV4dCgpO1xuICAgICAgICByZXN1bHQgPSB0cnlDYXRjaCh0aGlzLl9nZW5lcmF0b3JbXCJ0aHJvd1wiXSkuY2FsbCh0aGlzLl9nZW5lcmF0b3IsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWFzb24pO1xuICAgICAgICB0aGlzLl9wcm9taXNlLl9wb3BDb250ZXh0KCk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5fcHJvbWlzZS5fcHVzaENvbnRleHQoKTtcbiAgICAgICAgcmVzdWx0ID0gdHJ5Q2F0Y2godGhpcy5fZ2VuZXJhdG9yW1wicmV0dXJuXCJdKS5jYWxsKHRoaXMuX2dlbmVyYXRvcixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB1bmRlZmluZWQpO1xuICAgICAgICB0aGlzLl9wcm9taXNlLl9wb3BDb250ZXh0KCk7XG4gICAgfVxuICAgIHRoaXMuX2NhbmNlbGxhdGlvblBoYXNlID0gdHJ1ZTtcbiAgICB0aGlzLl95aWVsZGVkUHJvbWlzZSA9IG51bGw7XG4gICAgdGhpcy5fY29udGludWUocmVzdWx0KTtcbn07XG5cblByb21pc2VTcGF3bi5wcm90b3R5cGUuX3Byb21pc2VGdWxmaWxsZWQgPSBmdW5jdGlvbih2YWx1ZSkge1xuICAgIHRoaXMuX3lpZWxkZWRQcm9taXNlID0gbnVsbDtcbiAgICB0aGlzLl9wcm9taXNlLl9wdXNoQ29udGV4dCgpO1xuICAgIHZhciByZXN1bHQgPSB0cnlDYXRjaCh0aGlzLl9nZW5lcmF0b3IubmV4dCkuY2FsbCh0aGlzLl9nZW5lcmF0b3IsIHZhbHVlKTtcbiAgICB0aGlzLl9wcm9taXNlLl9wb3BDb250ZXh0KCk7XG4gICAgdGhpcy5fY29udGludWUocmVzdWx0KTtcbn07XG5cblByb21pc2VTcGF3bi5wcm90b3R5cGUuX3Byb21pc2VSZWplY3RlZCA9IGZ1bmN0aW9uKHJlYXNvbikge1xuICAgIHRoaXMuX3lpZWxkZWRQcm9taXNlID0gbnVsbDtcbiAgICB0aGlzLl9wcm9taXNlLl9hdHRhY2hFeHRyYVRyYWNlKHJlYXNvbik7XG4gICAgdGhpcy5fcHJvbWlzZS5fcHVzaENvbnRleHQoKTtcbiAgICB2YXIgcmVzdWx0ID0gdHJ5Q2F0Y2godGhpcy5fZ2VuZXJhdG9yW1widGhyb3dcIl0pXG4gICAgICAgIC5jYWxsKHRoaXMuX2dlbmVyYXRvciwgcmVhc29uKTtcbiAgICB0aGlzLl9wcm9taXNlLl9wb3BDb250ZXh0KCk7XG4gICAgdGhpcy5fY29udGludWUocmVzdWx0KTtcbn07XG5cblByb21pc2VTcGF3bi5wcm90b3R5cGUuX3Jlc3VsdENhbmNlbGxlZCA9IGZ1bmN0aW9uKCkge1xuICAgIGlmICh0aGlzLl95aWVsZGVkUHJvbWlzZSBpbnN0YW5jZW9mIFByb21pc2UpIHtcbiAgICAgICAgdmFyIHByb21pc2UgPSB0aGlzLl95aWVsZGVkUHJvbWlzZTtcbiAgICAgICAgdGhpcy5feWllbGRlZFByb21pc2UgPSBudWxsO1xuICAgICAgICBwcm9taXNlLmNhbmNlbCgpO1xuICAgIH1cbn07XG5cblByb21pc2VTcGF3bi5wcm90b3R5cGUucHJvbWlzZSA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5fcHJvbWlzZTtcbn07XG5cblByb21pc2VTcGF3bi5wcm90b3R5cGUuX3J1biA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLl9nZW5lcmF0b3IgPSB0aGlzLl9nZW5lcmF0b3JGdW5jdGlvbi5jYWxsKHRoaXMuX3JlY2VpdmVyKTtcbiAgICB0aGlzLl9yZWNlaXZlciA9XG4gICAgICAgIHRoaXMuX2dlbmVyYXRvckZ1bmN0aW9uID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuX3Byb21pc2VGdWxmaWxsZWQodW5kZWZpbmVkKTtcbn07XG5cblByb21pc2VTcGF3bi5wcm90b3R5cGUuX2NvbnRpbnVlID0gZnVuY3Rpb24gKHJlc3VsdCkge1xuICAgIHZhciBwcm9taXNlID0gdGhpcy5fcHJvbWlzZTtcbiAgICBpZiAocmVzdWx0ID09PSBlcnJvck9iaikge1xuICAgICAgICB0aGlzLl9jbGVhbnVwKCk7XG4gICAgICAgIGlmICh0aGlzLl9jYW5jZWxsYXRpb25QaGFzZSkge1xuICAgICAgICAgICAgcmV0dXJuIHByb21pc2UuY2FuY2VsKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gcHJvbWlzZS5fcmVqZWN0Q2FsbGJhY2socmVzdWx0LmUsIGZhbHNlKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHZhciB2YWx1ZSA9IHJlc3VsdC52YWx1ZTtcbiAgICBpZiAocmVzdWx0LmRvbmUgPT09IHRydWUpIHtcbiAgICAgICAgdGhpcy5fY2xlYW51cCgpO1xuICAgICAgICBpZiAodGhpcy5fY2FuY2VsbGF0aW9uUGhhc2UpIHtcbiAgICAgICAgICAgIHJldHVybiBwcm9taXNlLmNhbmNlbCgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHByb21pc2UuX3Jlc29sdmVDYWxsYmFjayh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgbWF5YmVQcm9taXNlID0gdHJ5Q29udmVydFRvUHJvbWlzZSh2YWx1ZSwgdGhpcy5fcHJvbWlzZSk7XG4gICAgICAgIGlmICghKG1heWJlUHJvbWlzZSBpbnN0YW5jZW9mIFByb21pc2UpKSB7XG4gICAgICAgICAgICBtYXliZVByb21pc2UgPVxuICAgICAgICAgICAgICAgIHByb21pc2VGcm9tWWllbGRIYW5kbGVyKG1heWJlUHJvbWlzZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl95aWVsZEhhbmRsZXJzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3Byb21pc2UpO1xuICAgICAgICAgICAgaWYgKG1heWJlUHJvbWlzZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3Byb21pc2VSZWplY3RlZChcbiAgICAgICAgICAgICAgICAgICAgbmV3IFR5cGVFcnJvcihcbiAgICAgICAgICAgICAgICAgICAgICAgIFwiQSB2YWx1ZSAlcyB3YXMgeWllbGRlZCB0aGF0IGNvdWxkIG5vdCBiZSB0cmVhdGVkIGFzIGEgcHJvbWlzZVxcdTAwMGFcXHUwMDBhICAgIFNlZSBodHRwOi8vZ29vLmdsL01xckZtWFxcdTAwMGFcXHUwMDBhXCIucmVwbGFjZShcIiVzXCIsIFN0cmluZyh2YWx1ZSkpICtcbiAgICAgICAgICAgICAgICAgICAgICAgIFwiRnJvbSBjb3JvdXRpbmU6XFx1MDAwYVwiICtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3N0YWNrLnNwbGl0KFwiXFxuXCIpLnNsaWNlKDEsIC03KS5qb2luKFwiXFxuXCIpXG4gICAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBtYXliZVByb21pc2UgPSBtYXliZVByb21pc2UuX3RhcmdldCgpO1xuICAgICAgICB2YXIgYml0RmllbGQgPSBtYXliZVByb21pc2UuX2JpdEZpZWxkO1xuICAgICAgICA7XG4gICAgICAgIGlmICgoKGJpdEZpZWxkICYgNTAzOTcxODQpID09PSAwKSkge1xuICAgICAgICAgICAgdGhpcy5feWllbGRlZFByb21pc2UgPSBtYXliZVByb21pc2U7XG4gICAgICAgICAgICBtYXliZVByb21pc2UuX3Byb3h5KHRoaXMsIG51bGwpO1xuICAgICAgICB9IGVsc2UgaWYgKCgoYml0RmllbGQgJiAzMzU1NDQzMikgIT09IDApKSB7XG4gICAgICAgICAgICBQcm9taXNlLl9hc3luYy5pbnZva2UoXG4gICAgICAgICAgICAgICAgdGhpcy5fcHJvbWlzZUZ1bGZpbGxlZCwgdGhpcywgbWF5YmVQcm9taXNlLl92YWx1ZSgpXG4gICAgICAgICAgICApO1xuICAgICAgICB9IGVsc2UgaWYgKCgoYml0RmllbGQgJiAxNjc3NzIxNikgIT09IDApKSB7XG4gICAgICAgICAgICBQcm9taXNlLl9hc3luYy5pbnZva2UoXG4gICAgICAgICAgICAgICAgdGhpcy5fcHJvbWlzZVJlamVjdGVkLCB0aGlzLCBtYXliZVByb21pc2UuX3JlYXNvbigpXG4gICAgICAgICAgICApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5fcHJvbWlzZUNhbmNlbGxlZCgpO1xuICAgICAgICB9XG4gICAgfVxufTtcblxuUHJvbWlzZS5jb3JvdXRpbmUgPSBmdW5jdGlvbiAoZ2VuZXJhdG9yRnVuY3Rpb24sIG9wdGlvbnMpIHtcbiAgICBpZiAodHlwZW9mIGdlbmVyYXRvckZ1bmN0aW9uICE9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcImdlbmVyYXRvckZ1bmN0aW9uIG11c3QgYmUgYSBmdW5jdGlvblxcdTAwMGFcXHUwMDBhICAgIFNlZSBodHRwOi8vZ29vLmdsL01xckZtWFxcdTAwMGFcIik7XG4gICAgfVxuICAgIHZhciB5aWVsZEhhbmRsZXIgPSBPYmplY3Qob3B0aW9ucykueWllbGRIYW5kbGVyO1xuICAgIHZhciBQcm9taXNlU3Bhd24kID0gUHJvbWlzZVNwYXduO1xuICAgIHZhciBzdGFjayA9IG5ldyBFcnJvcigpLnN0YWNrO1xuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBnZW5lcmF0b3IgPSBnZW5lcmF0b3JGdW5jdGlvbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICB2YXIgc3Bhd24gPSBuZXcgUHJvbWlzZVNwYXduJCh1bmRlZmluZWQsIHVuZGVmaW5lZCwgeWllbGRIYW5kbGVyLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGFjayk7XG4gICAgICAgIHZhciByZXQgPSBzcGF3bi5wcm9taXNlKCk7XG4gICAgICAgIHNwYXduLl9nZW5lcmF0b3IgPSBnZW5lcmF0b3I7XG4gICAgICAgIHNwYXduLl9wcm9taXNlRnVsZmlsbGVkKHVuZGVmaW5lZCk7XG4gICAgICAgIHJldHVybiByZXQ7XG4gICAgfTtcbn07XG5cblByb21pc2UuY29yb3V0aW5lLmFkZFlpZWxkSGFuZGxlciA9IGZ1bmN0aW9uKGZuKSB7XG4gICAgaWYgKHR5cGVvZiBmbiAhPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJleHBlY3RpbmcgYSBmdW5jdGlvbiBidXQgZ290IFwiICsgdXRpbC5jbGFzc1N0cmluZyhmbikpO1xuICAgIH1cbiAgICB5aWVsZEhhbmRsZXJzLnB1c2goZm4pO1xufTtcblxuUHJvbWlzZS5zcGF3biA9IGZ1bmN0aW9uIChnZW5lcmF0b3JGdW5jdGlvbikge1xuICAgIGRlYnVnLmRlcHJlY2F0ZWQoXCJQcm9taXNlLnNwYXduKClcIiwgXCJQcm9taXNlLmNvcm91dGluZSgpXCIpO1xuICAgIGlmICh0eXBlb2YgZ2VuZXJhdG9yRnVuY3Rpb24gIT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICByZXR1cm4gYXBpUmVqZWN0aW9uKFwiZ2VuZXJhdG9yRnVuY3Rpb24gbXVzdCBiZSBhIGZ1bmN0aW9uXFx1MDAwYVxcdTAwMGEgICAgU2VlIGh0dHA6Ly9nb28uZ2wvTXFyRm1YXFx1MDAwYVwiKTtcbiAgICB9XG4gICAgdmFyIHNwYXduID0gbmV3IFByb21pc2VTcGF3bihnZW5lcmF0b3JGdW5jdGlvbiwgdGhpcyk7XG4gICAgdmFyIHJldCA9IHNwYXduLnByb21pc2UoKTtcbiAgICBzcGF3bi5fcnVuKFByb21pc2Uuc3Bhd24pO1xuICAgIHJldHVybiByZXQ7XG59O1xufTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9ibHVlYmlyZC9qcy9yZWxlYXNlL2dlbmVyYXRvcnMuanMiLCJcInVzZSBzdHJpY3RcIjtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oUHJvbWlzZSkge1xudmFyIHV0aWwgPSByZXF1aXJlKFwiLi91dGlsXCIpO1xudmFyIGFzeW5jID0gUHJvbWlzZS5fYXN5bmM7XG52YXIgdHJ5Q2F0Y2ggPSB1dGlsLnRyeUNhdGNoO1xudmFyIGVycm9yT2JqID0gdXRpbC5lcnJvck9iajtcblxuZnVuY3Rpb24gc3ByZWFkQWRhcHRlcih2YWwsIG5vZGViYWNrKSB7XG4gICAgdmFyIHByb21pc2UgPSB0aGlzO1xuICAgIGlmICghdXRpbC5pc0FycmF5KHZhbCkpIHJldHVybiBzdWNjZXNzQWRhcHRlci5jYWxsKHByb21pc2UsIHZhbCwgbm9kZWJhY2spO1xuICAgIHZhciByZXQgPVxuICAgICAgICB0cnlDYXRjaChub2RlYmFjaykuYXBwbHkocHJvbWlzZS5fYm91bmRWYWx1ZSgpLCBbbnVsbF0uY29uY2F0KHZhbCkpO1xuICAgIGlmIChyZXQgPT09IGVycm9yT2JqKSB7XG4gICAgICAgIGFzeW5jLnRocm93TGF0ZXIocmV0LmUpO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gc3VjY2Vzc0FkYXB0ZXIodmFsLCBub2RlYmFjaykge1xuICAgIHZhciBwcm9taXNlID0gdGhpcztcbiAgICB2YXIgcmVjZWl2ZXIgPSBwcm9taXNlLl9ib3VuZFZhbHVlKCk7XG4gICAgdmFyIHJldCA9IHZhbCA9PT0gdW5kZWZpbmVkXG4gICAgICAgID8gdHJ5Q2F0Y2gobm9kZWJhY2spLmNhbGwocmVjZWl2ZXIsIG51bGwpXG4gICAgICAgIDogdHJ5Q2F0Y2gobm9kZWJhY2spLmNhbGwocmVjZWl2ZXIsIG51bGwsIHZhbCk7XG4gICAgaWYgKHJldCA9PT0gZXJyb3JPYmopIHtcbiAgICAgICAgYXN5bmMudGhyb3dMYXRlcihyZXQuZSk7XG4gICAgfVxufVxuZnVuY3Rpb24gZXJyb3JBZGFwdGVyKHJlYXNvbiwgbm9kZWJhY2spIHtcbiAgICB2YXIgcHJvbWlzZSA9IHRoaXM7XG4gICAgaWYgKCFyZWFzb24pIHtcbiAgICAgICAgdmFyIG5ld1JlYXNvbiA9IG5ldyBFcnJvcihyZWFzb24gKyBcIlwiKTtcbiAgICAgICAgbmV3UmVhc29uLmNhdXNlID0gcmVhc29uO1xuICAgICAgICByZWFzb24gPSBuZXdSZWFzb247XG4gICAgfVxuICAgIHZhciByZXQgPSB0cnlDYXRjaChub2RlYmFjaykuY2FsbChwcm9taXNlLl9ib3VuZFZhbHVlKCksIHJlYXNvbik7XG4gICAgaWYgKHJldCA9PT0gZXJyb3JPYmopIHtcbiAgICAgICAgYXN5bmMudGhyb3dMYXRlcihyZXQuZSk7XG4gICAgfVxufVxuXG5Qcm9taXNlLnByb3RvdHlwZS5hc0NhbGxiYWNrID0gUHJvbWlzZS5wcm90b3R5cGUubm9kZWlmeSA9IGZ1bmN0aW9uIChub2RlYmFjayxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnMpIHtcbiAgICBpZiAodHlwZW9mIG5vZGViYWNrID09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICB2YXIgYWRhcHRlciA9IHN1Y2Nlc3NBZGFwdGVyO1xuICAgICAgICBpZiAob3B0aW9ucyAhPT0gdW5kZWZpbmVkICYmIE9iamVjdChvcHRpb25zKS5zcHJlYWQpIHtcbiAgICAgICAgICAgIGFkYXB0ZXIgPSBzcHJlYWRBZGFwdGVyO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3RoZW4oXG4gICAgICAgICAgICBhZGFwdGVyLFxuICAgICAgICAgICAgZXJyb3JBZGFwdGVyLFxuICAgICAgICAgICAgdW5kZWZpbmVkLFxuICAgICAgICAgICAgdGhpcyxcbiAgICAgICAgICAgIG5vZGViYWNrXG4gICAgICAgICk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xufTtcbn07XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvYmx1ZWJpcmQvanMvcmVsZWFzZS9ub2RlaWZ5LmpzIiwiXCJ1c2Ugc3RyaWN0XCI7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKFByb21pc2UsIElOVEVSTkFMKSB7XG52YXIgVEhJUyA9IHt9O1xudmFyIHV0aWwgPSByZXF1aXJlKFwiLi91dGlsXCIpO1xudmFyIG5vZGViYWNrRm9yUHJvbWlzZSA9IHJlcXVpcmUoXCIuL25vZGViYWNrXCIpO1xudmFyIHdpdGhBcHBlbmRlZCA9IHV0aWwud2l0aEFwcGVuZGVkO1xudmFyIG1heWJlV3JhcEFzRXJyb3IgPSB1dGlsLm1heWJlV3JhcEFzRXJyb3I7XG52YXIgY2FuRXZhbHVhdGUgPSB1dGlsLmNhbkV2YWx1YXRlO1xudmFyIFR5cGVFcnJvciA9IHJlcXVpcmUoXCIuL2Vycm9yc1wiKS5UeXBlRXJyb3I7XG52YXIgZGVmYXVsdFN1ZmZpeCA9IFwiQXN5bmNcIjtcbnZhciBkZWZhdWx0UHJvbWlzaWZpZWQgPSB7X19pc1Byb21pc2lmaWVkX186IHRydWV9O1xudmFyIG5vQ29weVByb3BzID0gW1xuICAgIFwiYXJpdHlcIiwgICAgXCJsZW5ndGhcIixcbiAgICBcIm5hbWVcIixcbiAgICBcImFyZ3VtZW50c1wiLFxuICAgIFwiY2FsbGVyXCIsXG4gICAgXCJjYWxsZWVcIixcbiAgICBcInByb3RvdHlwZVwiLFxuICAgIFwiX19pc1Byb21pc2lmaWVkX19cIlxuXTtcbnZhciBub0NvcHlQcm9wc1BhdHRlcm4gPSBuZXcgUmVnRXhwKFwiXig/OlwiICsgbm9Db3B5UHJvcHMuam9pbihcInxcIikgKyBcIikkXCIpO1xuXG52YXIgZGVmYXVsdEZpbHRlciA9IGZ1bmN0aW9uKG5hbWUpIHtcbiAgICByZXR1cm4gdXRpbC5pc0lkZW50aWZpZXIobmFtZSkgJiZcbiAgICAgICAgbmFtZS5jaGFyQXQoMCkgIT09IFwiX1wiICYmXG4gICAgICAgIG5hbWUgIT09IFwiY29uc3RydWN0b3JcIjtcbn07XG5cbmZ1bmN0aW9uIHByb3BzRmlsdGVyKGtleSkge1xuICAgIHJldHVybiAhbm9Db3B5UHJvcHNQYXR0ZXJuLnRlc3Qoa2V5KTtcbn1cblxuZnVuY3Rpb24gaXNQcm9taXNpZmllZChmbikge1xuICAgIHRyeSB7XG4gICAgICAgIHJldHVybiBmbi5fX2lzUHJvbWlzaWZpZWRfXyA9PT0gdHJ1ZTtcbiAgICB9XG4gICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gaGFzUHJvbWlzaWZpZWQob2JqLCBrZXksIHN1ZmZpeCkge1xuICAgIHZhciB2YWwgPSB1dGlsLmdldERhdGFQcm9wZXJ0eU9yRGVmYXVsdChvYmosIGtleSArIHN1ZmZpeCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVmYXVsdFByb21pc2lmaWVkKTtcbiAgICByZXR1cm4gdmFsID8gaXNQcm9taXNpZmllZCh2YWwpIDogZmFsc2U7XG59XG5mdW5jdGlvbiBjaGVja1ZhbGlkKHJldCwgc3VmZml4LCBzdWZmaXhSZWdleHApIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHJldC5sZW5ndGg7IGkgKz0gMikge1xuICAgICAgICB2YXIga2V5ID0gcmV0W2ldO1xuICAgICAgICBpZiAoc3VmZml4UmVnZXhwLnRlc3Qoa2V5KSkge1xuICAgICAgICAgICAgdmFyIGtleVdpdGhvdXRBc3luY1N1ZmZpeCA9IGtleS5yZXBsYWNlKHN1ZmZpeFJlZ2V4cCwgXCJcIik7XG4gICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHJldC5sZW5ndGg7IGogKz0gMikge1xuICAgICAgICAgICAgICAgIGlmIChyZXRbal0gPT09IGtleVdpdGhvdXRBc3luY1N1ZmZpeCkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IHByb21pc2lmeSBhbiBBUEkgdGhhdCBoYXMgbm9ybWFsIG1ldGhvZHMgd2l0aCAnJXMnLXN1ZmZpeFxcdTAwMGFcXHUwMDBhICAgIFNlZSBodHRwOi8vZ29vLmdsL01xckZtWFxcdTAwMGFcIlxuICAgICAgICAgICAgICAgICAgICAgICAgLnJlcGxhY2UoXCIlc1wiLCBzdWZmaXgpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59XG5cbmZ1bmN0aW9uIHByb21pc2lmaWFibGVNZXRob2RzKG9iaiwgc3VmZml4LCBzdWZmaXhSZWdleHAsIGZpbHRlcikge1xuICAgIHZhciBrZXlzID0gdXRpbC5pbmhlcml0ZWREYXRhS2V5cyhvYmopO1xuICAgIHZhciByZXQgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgdmFyIGtleSA9IGtleXNbaV07XG4gICAgICAgIHZhciB2YWx1ZSA9IG9ialtrZXldO1xuICAgICAgICB2YXIgcGFzc2VzRGVmYXVsdEZpbHRlciA9IGZpbHRlciA9PT0gZGVmYXVsdEZpbHRlclxuICAgICAgICAgICAgPyB0cnVlIDogZGVmYXVsdEZpbHRlcihrZXksIHZhbHVlLCBvYmopO1xuICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSBcImZ1bmN0aW9uXCIgJiZcbiAgICAgICAgICAgICFpc1Byb21pc2lmaWVkKHZhbHVlKSAmJlxuICAgICAgICAgICAgIWhhc1Byb21pc2lmaWVkKG9iaiwga2V5LCBzdWZmaXgpICYmXG4gICAgICAgICAgICBmaWx0ZXIoa2V5LCB2YWx1ZSwgb2JqLCBwYXNzZXNEZWZhdWx0RmlsdGVyKSkge1xuICAgICAgICAgICAgcmV0LnB1c2goa2V5LCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY2hlY2tWYWxpZChyZXQsIHN1ZmZpeCwgc3VmZml4UmVnZXhwKTtcbiAgICByZXR1cm4gcmV0O1xufVxuXG52YXIgZXNjYXBlSWRlbnRSZWdleCA9IGZ1bmN0aW9uKHN0cikge1xuICAgIHJldHVybiBzdHIucmVwbGFjZSgvKFskXSkvLCBcIlxcXFwkXCIpO1xufTtcblxudmFyIG1ha2VOb2RlUHJvbWlzaWZpZWRFdmFsO1xuaWYgKCFmYWxzZSkge1xudmFyIHN3aXRjaENhc2VBcmd1bWVudE9yZGVyID0gZnVuY3Rpb24obGlrZWx5QXJndW1lbnRDb3VudCkge1xuICAgIHZhciByZXQgPSBbbGlrZWx5QXJndW1lbnRDb3VudF07XG4gICAgdmFyIG1pbiA9IE1hdGgubWF4KDAsIGxpa2VseUFyZ3VtZW50Q291bnQgLSAxIC0gMyk7XG4gICAgZm9yKHZhciBpID0gbGlrZWx5QXJndW1lbnRDb3VudCAtIDE7IGkgPj0gbWluOyAtLWkpIHtcbiAgICAgICAgcmV0LnB1c2goaSk7XG4gICAgfVxuICAgIGZvcih2YXIgaSA9IGxpa2VseUFyZ3VtZW50Q291bnQgKyAxOyBpIDw9IDM7ICsraSkge1xuICAgICAgICByZXQucHVzaChpKTtcbiAgICB9XG4gICAgcmV0dXJuIHJldDtcbn07XG5cbnZhciBhcmd1bWVudFNlcXVlbmNlID0gZnVuY3Rpb24oYXJndW1lbnRDb3VudCkge1xuICAgIHJldHVybiB1dGlsLmZpbGxlZFJhbmdlKGFyZ3VtZW50Q291bnQsIFwiX2FyZ1wiLCBcIlwiKTtcbn07XG5cbnZhciBwYXJhbWV0ZXJEZWNsYXJhdGlvbiA9IGZ1bmN0aW9uKHBhcmFtZXRlckNvdW50KSB7XG4gICAgcmV0dXJuIHV0aWwuZmlsbGVkUmFuZ2UoXG4gICAgICAgIE1hdGgubWF4KHBhcmFtZXRlckNvdW50LCAzKSwgXCJfYXJnXCIsIFwiXCIpO1xufTtcblxudmFyIHBhcmFtZXRlckNvdW50ID0gZnVuY3Rpb24oZm4pIHtcbiAgICBpZiAodHlwZW9mIGZuLmxlbmd0aCA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICByZXR1cm4gTWF0aC5tYXgoTWF0aC5taW4oZm4ubGVuZ3RoLCAxMDIzICsgMSksIDApO1xuICAgIH1cbiAgICByZXR1cm4gMDtcbn07XG5cbm1ha2VOb2RlUHJvbWlzaWZpZWRFdmFsID1cbmZ1bmN0aW9uKGNhbGxiYWNrLCByZWNlaXZlciwgb3JpZ2luYWxOYW1lLCBmbiwgXywgbXVsdGlBcmdzKSB7XG4gICAgdmFyIG5ld1BhcmFtZXRlckNvdW50ID0gTWF0aC5tYXgoMCwgcGFyYW1ldGVyQ291bnQoZm4pIC0gMSk7XG4gICAgdmFyIGFyZ3VtZW50T3JkZXIgPSBzd2l0Y2hDYXNlQXJndW1lbnRPcmRlcihuZXdQYXJhbWV0ZXJDb3VudCk7XG4gICAgdmFyIHNob3VsZFByb3h5VGhpcyA9IHR5cGVvZiBjYWxsYmFjayA9PT0gXCJzdHJpbmdcIiB8fCByZWNlaXZlciA9PT0gVEhJUztcblxuICAgIGZ1bmN0aW9uIGdlbmVyYXRlQ2FsbEZvckFyZ3VtZW50Q291bnQoY291bnQpIHtcbiAgICAgICAgdmFyIGFyZ3MgPSBhcmd1bWVudFNlcXVlbmNlKGNvdW50KS5qb2luKFwiLCBcIik7XG4gICAgICAgIHZhciBjb21tYSA9IGNvdW50ID4gMCA/IFwiLCBcIiA6IFwiXCI7XG4gICAgICAgIHZhciByZXQ7XG4gICAgICAgIGlmIChzaG91bGRQcm94eVRoaXMpIHtcbiAgICAgICAgICAgIHJldCA9IFwicmV0ID0gY2FsbGJhY2suY2FsbCh0aGlzLCB7e2FyZ3N9fSwgbm9kZWJhY2spOyBicmVhaztcXG5cIjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldCA9IHJlY2VpdmVyID09PSB1bmRlZmluZWRcbiAgICAgICAgICAgICAgICA/IFwicmV0ID0gY2FsbGJhY2soe3thcmdzfX0sIG5vZGViYWNrKTsgYnJlYWs7XFxuXCJcbiAgICAgICAgICAgICAgICA6IFwicmV0ID0gY2FsbGJhY2suY2FsbChyZWNlaXZlciwge3thcmdzfX0sIG5vZGViYWNrKTsgYnJlYWs7XFxuXCI7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJldC5yZXBsYWNlKFwie3thcmdzfX1cIiwgYXJncykucmVwbGFjZShcIiwgXCIsIGNvbW1hKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZW5lcmF0ZUFyZ3VtZW50U3dpdGNoQ2FzZSgpIHtcbiAgICAgICAgdmFyIHJldCA9IFwiXCI7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJndW1lbnRPcmRlci5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgcmV0ICs9IFwiY2FzZSBcIiArIGFyZ3VtZW50T3JkZXJbaV0gK1wiOlwiICtcbiAgICAgICAgICAgICAgICBnZW5lcmF0ZUNhbGxGb3JBcmd1bWVudENvdW50KGFyZ3VtZW50T3JkZXJbaV0pO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0ICs9IFwiICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxcblxcXG4gICAgICAgIGRlZmF1bHQ6ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxcblxcXG4gICAgICAgICAgICB2YXIgYXJncyA9IG5ldyBBcnJheShsZW4gKyAxKTsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxcblxcXG4gICAgICAgICAgICB2YXIgaSA9IDA7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxcblxcXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgKytpKSB7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxcblxcXG4gICAgICAgICAgICAgICBhcmdzW2ldID0gYXJndW1lbnRzW2ldOyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxcblxcXG4gICAgICAgICAgICB9ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxcblxcXG4gICAgICAgICAgICBhcmdzW2ldID0gbm9kZWJhY2s7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxcblxcXG4gICAgICAgICAgICBbQ29kZUZvckNhbGxdICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxcblxcXG4gICAgICAgICAgICBicmVhazsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxcblxcXG4gICAgICAgIFwiLnJlcGxhY2UoXCJbQ29kZUZvckNhbGxdXCIsIChzaG91bGRQcm94eVRoaXNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPyBcInJldCA9IGNhbGxiYWNrLmFwcGx5KHRoaXMsIGFyZ3MpO1xcblwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogXCJyZXQgPSBjYWxsYmFjay5hcHBseShyZWNlaXZlciwgYXJncyk7XFxuXCIpKTtcbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICB9XG5cbiAgICB2YXIgZ2V0RnVuY3Rpb25Db2RlID0gdHlwZW9mIGNhbGxiYWNrID09PSBcInN0cmluZ1wiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gKFwidGhpcyAhPSBudWxsID8gdGhpc1snXCIrY2FsbGJhY2srXCInXSA6IGZuXCIpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogXCJmblwiO1xuICAgIHZhciBib2R5ID0gXCIndXNlIHN0cmljdCc7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXFxuXFxcbiAgICAgICAgdmFyIHJldCA9IGZ1bmN0aW9uIChQYXJhbWV0ZXJzKSB7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXFxuXFxcbiAgICAgICAgICAgICd1c2Ugc3RyaWN0JzsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXFxuXFxcbiAgICAgICAgICAgIHZhciBsZW4gPSBhcmd1bWVudHMubGVuZ3RoOyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXFxuXFxcbiAgICAgICAgICAgIHZhciBwcm9taXNlID0gbmV3IFByb21pc2UoSU5URVJOQUwpOyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXFxuXFxcbiAgICAgICAgICAgIHByb21pc2UuX2NhcHR1cmVTdGFja1RyYWNlKCk7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXFxuXFxcbiAgICAgICAgICAgIHZhciBub2RlYmFjayA9IG5vZGViYWNrRm9yUHJvbWlzZShwcm9taXNlLCBcIiArIG11bHRpQXJncyArIFwiKTsgICBcXG5cXFxuICAgICAgICAgICAgdmFyIHJldDsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcXG5cXFxuICAgICAgICAgICAgdmFyIGNhbGxiYWNrID0gdHJ5Q2F0Y2goW0dldEZ1bmN0aW9uQ29kZV0pOyAgICAgICAgICAgICAgICAgICAgICBcXG5cXFxuICAgICAgICAgICAgc3dpdGNoKGxlbikgeyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcXG5cXFxuICAgICAgICAgICAgICAgIFtDb2RlRm9yU3dpdGNoQ2FzZV0gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcXG5cXFxuICAgICAgICAgICAgfSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcXG5cXFxuICAgICAgICAgICAgaWYgKHJldCA9PT0gZXJyb3JPYmopIHsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcXG5cXFxuICAgICAgICAgICAgICAgIHByb21pc2UuX3JlamVjdENhbGxiYWNrKG1heWJlV3JhcEFzRXJyb3IocmV0LmUpLCB0cnVlLCB0cnVlKTtcXG5cXFxuICAgICAgICAgICAgfSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcXG5cXFxuICAgICAgICAgICAgaWYgKCFwcm9taXNlLl9pc0ZhdGVTZWFsZWQoKSkgcHJvbWlzZS5fc2V0QXN5bmNHdWFyYW50ZWVkKCk7ICAgICBcXG5cXFxuICAgICAgICAgICAgcmV0dXJuIHByb21pc2U7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcXG5cXFxuICAgICAgICB9OyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcXG5cXFxuICAgICAgICBub3RFbnVtZXJhYmxlUHJvcChyZXQsICdfX2lzUHJvbWlzaWZpZWRfXycsIHRydWUpOyAgICAgICAgICAgICAgICAgICBcXG5cXFxuICAgICAgICByZXR1cm4gcmV0OyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcXG5cXFxuICAgIFwiLnJlcGxhY2UoXCJbQ29kZUZvclN3aXRjaENhc2VdXCIsIGdlbmVyYXRlQXJndW1lbnRTd2l0Y2hDYXNlKCkpXG4gICAgICAgIC5yZXBsYWNlKFwiW0dldEZ1bmN0aW9uQ29kZV1cIiwgZ2V0RnVuY3Rpb25Db2RlKTtcbiAgICBib2R5ID0gYm9keS5yZXBsYWNlKFwiUGFyYW1ldGVyc1wiLCBwYXJhbWV0ZXJEZWNsYXJhdGlvbihuZXdQYXJhbWV0ZXJDb3VudCkpO1xuICAgIHJldHVybiBuZXcgRnVuY3Rpb24oXCJQcm9taXNlXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBcImZuXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBcInJlY2VpdmVyXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBcIndpdGhBcHBlbmRlZFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgXCJtYXliZVdyYXBBc0Vycm9yXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBcIm5vZGViYWNrRm9yUHJvbWlzZVwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgXCJ0cnlDYXRjaFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgXCJlcnJvck9ialwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgXCJub3RFbnVtZXJhYmxlUHJvcFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgXCJJTlRFUk5BTFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgYm9keSkoXG4gICAgICAgICAgICAgICAgICAgIFByb21pc2UsXG4gICAgICAgICAgICAgICAgICAgIGZuLFxuICAgICAgICAgICAgICAgICAgICByZWNlaXZlcixcbiAgICAgICAgICAgICAgICAgICAgd2l0aEFwcGVuZGVkLFxuICAgICAgICAgICAgICAgICAgICBtYXliZVdyYXBBc0Vycm9yLFxuICAgICAgICAgICAgICAgICAgICBub2RlYmFja0ZvclByb21pc2UsXG4gICAgICAgICAgICAgICAgICAgIHV0aWwudHJ5Q2F0Y2gsXG4gICAgICAgICAgICAgICAgICAgIHV0aWwuZXJyb3JPYmosXG4gICAgICAgICAgICAgICAgICAgIHV0aWwubm90RW51bWVyYWJsZVByb3AsXG4gICAgICAgICAgICAgICAgICAgIElOVEVSTkFMKTtcbn07XG59XG5cbmZ1bmN0aW9uIG1ha2VOb2RlUHJvbWlzaWZpZWRDbG9zdXJlKGNhbGxiYWNrLCByZWNlaXZlciwgXywgZm4sIF9fLCBtdWx0aUFyZ3MpIHtcbiAgICB2YXIgZGVmYXVsdFRoaXMgPSAoZnVuY3Rpb24oKSB7cmV0dXJuIHRoaXM7fSkoKTtcbiAgICB2YXIgbWV0aG9kID0gY2FsbGJhY2s7XG4gICAgaWYgKHR5cGVvZiBtZXRob2QgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgY2FsbGJhY2sgPSBmbjtcbiAgICB9XG4gICAgZnVuY3Rpb24gcHJvbWlzaWZpZWQoKSB7XG4gICAgICAgIHZhciBfcmVjZWl2ZXIgPSByZWNlaXZlcjtcbiAgICAgICAgaWYgKHJlY2VpdmVyID09PSBUSElTKSBfcmVjZWl2ZXIgPSB0aGlzO1xuICAgICAgICB2YXIgcHJvbWlzZSA9IG5ldyBQcm9taXNlKElOVEVSTkFMKTtcbiAgICAgICAgcHJvbWlzZS5fY2FwdHVyZVN0YWNrVHJhY2UoKTtcbiAgICAgICAgdmFyIGNiID0gdHlwZW9mIG1ldGhvZCA9PT0gXCJzdHJpbmdcIiAmJiB0aGlzICE9PSBkZWZhdWx0VGhpc1xuICAgICAgICAgICAgPyB0aGlzW21ldGhvZF0gOiBjYWxsYmFjaztcbiAgICAgICAgdmFyIGZuID0gbm9kZWJhY2tGb3JQcm9taXNlKHByb21pc2UsIG11bHRpQXJncyk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjYi5hcHBseShfcmVjZWl2ZXIsIHdpdGhBcHBlbmRlZChhcmd1bWVudHMsIGZuKSk7XG4gICAgICAgIH0gY2F0Y2goZSkge1xuICAgICAgICAgICAgcHJvbWlzZS5fcmVqZWN0Q2FsbGJhY2sobWF5YmVXcmFwQXNFcnJvcihlKSwgdHJ1ZSwgdHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFwcm9taXNlLl9pc0ZhdGVTZWFsZWQoKSkgcHJvbWlzZS5fc2V0QXN5bmNHdWFyYW50ZWVkKCk7XG4gICAgICAgIHJldHVybiBwcm9taXNlO1xuICAgIH1cbiAgICB1dGlsLm5vdEVudW1lcmFibGVQcm9wKHByb21pc2lmaWVkLCBcIl9faXNQcm9taXNpZmllZF9fXCIsIHRydWUpO1xuICAgIHJldHVybiBwcm9taXNpZmllZDtcbn1cblxudmFyIG1ha2VOb2RlUHJvbWlzaWZpZWQgPSBjYW5FdmFsdWF0ZVxuICAgID8gbWFrZU5vZGVQcm9taXNpZmllZEV2YWxcbiAgICA6IG1ha2VOb2RlUHJvbWlzaWZpZWRDbG9zdXJlO1xuXG5mdW5jdGlvbiBwcm9taXNpZnlBbGwob2JqLCBzdWZmaXgsIGZpbHRlciwgcHJvbWlzaWZpZXIsIG11bHRpQXJncykge1xuICAgIHZhciBzdWZmaXhSZWdleHAgPSBuZXcgUmVnRXhwKGVzY2FwZUlkZW50UmVnZXgoc3VmZml4KSArIFwiJFwiKTtcbiAgICB2YXIgbWV0aG9kcyA9XG4gICAgICAgIHByb21pc2lmaWFibGVNZXRob2RzKG9iaiwgc3VmZml4LCBzdWZmaXhSZWdleHAsIGZpbHRlcik7XG5cbiAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gbWV0aG9kcy5sZW5ndGg7IGkgPCBsZW47IGkrPSAyKSB7XG4gICAgICAgIHZhciBrZXkgPSBtZXRob2RzW2ldO1xuICAgICAgICB2YXIgZm4gPSBtZXRob2RzW2krMV07XG4gICAgICAgIHZhciBwcm9taXNpZmllZEtleSA9IGtleSArIHN1ZmZpeDtcbiAgICAgICAgaWYgKHByb21pc2lmaWVyID09PSBtYWtlTm9kZVByb21pc2lmaWVkKSB7XG4gICAgICAgICAgICBvYmpbcHJvbWlzaWZpZWRLZXldID1cbiAgICAgICAgICAgICAgICBtYWtlTm9kZVByb21pc2lmaWVkKGtleSwgVEhJUywga2V5LCBmbiwgc3VmZml4LCBtdWx0aUFyZ3MpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFyIHByb21pc2lmaWVkID0gcHJvbWlzaWZpZXIoZm4sIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBtYWtlTm9kZVByb21pc2lmaWVkKGtleSwgVEhJUywga2V5LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZuLCBzdWZmaXgsIG11bHRpQXJncyk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHV0aWwubm90RW51bWVyYWJsZVByb3AocHJvbWlzaWZpZWQsIFwiX19pc1Byb21pc2lmaWVkX19cIiwgdHJ1ZSk7XG4gICAgICAgICAgICBvYmpbcHJvbWlzaWZpZWRLZXldID0gcHJvbWlzaWZpZWQ7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdXRpbC50b0Zhc3RQcm9wZXJ0aWVzKG9iaik7XG4gICAgcmV0dXJuIG9iajtcbn1cblxuZnVuY3Rpb24gcHJvbWlzaWZ5KGNhbGxiYWNrLCByZWNlaXZlciwgbXVsdGlBcmdzKSB7XG4gICAgcmV0dXJuIG1ha2VOb2RlUHJvbWlzaWZpZWQoY2FsbGJhY2ssIHJlY2VpdmVyLCB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrLCBudWxsLCBtdWx0aUFyZ3MpO1xufVxuXG5Qcm9taXNlLnByb21pc2lmeSA9IGZ1bmN0aW9uIChmbiwgb3B0aW9ucykge1xuICAgIGlmICh0eXBlb2YgZm4gIT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiZXhwZWN0aW5nIGEgZnVuY3Rpb24gYnV0IGdvdCBcIiArIHV0aWwuY2xhc3NTdHJpbmcoZm4pKTtcbiAgICB9XG4gICAgaWYgKGlzUHJvbWlzaWZpZWQoZm4pKSB7XG4gICAgICAgIHJldHVybiBmbjtcbiAgICB9XG4gICAgb3B0aW9ucyA9IE9iamVjdChvcHRpb25zKTtcbiAgICB2YXIgcmVjZWl2ZXIgPSBvcHRpb25zLmNvbnRleHQgPT09IHVuZGVmaW5lZCA/IFRISVMgOiBvcHRpb25zLmNvbnRleHQ7XG4gICAgdmFyIG11bHRpQXJncyA9ICEhb3B0aW9ucy5tdWx0aUFyZ3M7XG4gICAgdmFyIHJldCA9IHByb21pc2lmeShmbiwgcmVjZWl2ZXIsIG11bHRpQXJncyk7XG4gICAgdXRpbC5jb3B5RGVzY3JpcHRvcnMoZm4sIHJldCwgcHJvcHNGaWx0ZXIpO1xuICAgIHJldHVybiByZXQ7XG59O1xuXG5Qcm9taXNlLnByb21pc2lmeUFsbCA9IGZ1bmN0aW9uICh0YXJnZXQsIG9wdGlvbnMpIHtcbiAgICBpZiAodHlwZW9mIHRhcmdldCAhPT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiB0YXJnZXQgIT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcInRoZSB0YXJnZXQgb2YgcHJvbWlzaWZ5QWxsIG11c3QgYmUgYW4gb2JqZWN0IG9yIGEgZnVuY3Rpb25cXHUwMDBhXFx1MDAwYSAgICBTZWUgaHR0cDovL2dvby5nbC9NcXJGbVhcXHUwMDBhXCIpO1xuICAgIH1cbiAgICBvcHRpb25zID0gT2JqZWN0KG9wdGlvbnMpO1xuICAgIHZhciBtdWx0aUFyZ3MgPSAhIW9wdGlvbnMubXVsdGlBcmdzO1xuICAgIHZhciBzdWZmaXggPSBvcHRpb25zLnN1ZmZpeDtcbiAgICBpZiAodHlwZW9mIHN1ZmZpeCAhPT0gXCJzdHJpbmdcIikgc3VmZml4ID0gZGVmYXVsdFN1ZmZpeDtcbiAgICB2YXIgZmlsdGVyID0gb3B0aW9ucy5maWx0ZXI7XG4gICAgaWYgKHR5cGVvZiBmaWx0ZXIgIT09IFwiZnVuY3Rpb25cIikgZmlsdGVyID0gZGVmYXVsdEZpbHRlcjtcbiAgICB2YXIgcHJvbWlzaWZpZXIgPSBvcHRpb25zLnByb21pc2lmaWVyO1xuICAgIGlmICh0eXBlb2YgcHJvbWlzaWZpZXIgIT09IFwiZnVuY3Rpb25cIikgcHJvbWlzaWZpZXIgPSBtYWtlTm9kZVByb21pc2lmaWVkO1xuXG4gICAgaWYgKCF1dGlsLmlzSWRlbnRpZmllcihzdWZmaXgpKSB7XG4gICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwic3VmZml4IG11c3QgYmUgYSB2YWxpZCBpZGVudGlmaWVyXFx1MDAwYVxcdTAwMGEgICAgU2VlIGh0dHA6Ly9nb28uZ2wvTXFyRm1YXFx1MDAwYVwiKTtcbiAgICB9XG5cbiAgICB2YXIga2V5cyA9IHV0aWwuaW5oZXJpdGVkRGF0YUtleXModGFyZ2V0KTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgdmFyIHZhbHVlID0gdGFyZ2V0W2tleXNbaV1dO1xuICAgICAgICBpZiAoa2V5c1tpXSAhPT0gXCJjb25zdHJ1Y3RvclwiICYmXG4gICAgICAgICAgICB1dGlsLmlzQ2xhc3ModmFsdWUpKSB7XG4gICAgICAgICAgICBwcm9taXNpZnlBbGwodmFsdWUucHJvdG90eXBlLCBzdWZmaXgsIGZpbHRlciwgcHJvbWlzaWZpZXIsXG4gICAgICAgICAgICAgICAgbXVsdGlBcmdzKTtcbiAgICAgICAgICAgIHByb21pc2lmeUFsbCh2YWx1ZSwgc3VmZml4LCBmaWx0ZXIsIHByb21pc2lmaWVyLCBtdWx0aUFyZ3MpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHByb21pc2lmeUFsbCh0YXJnZXQsIHN1ZmZpeCwgZmlsdGVyLCBwcm9taXNpZmllciwgbXVsdGlBcmdzKTtcbn07XG59O1xuXG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvYmx1ZWJpcmQvanMvcmVsZWFzZS9wcm9taXNpZnkuanMiLCJcInVzZSBzdHJpY3RcIjtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oXG4gICAgUHJvbWlzZSwgUHJvbWlzZUFycmF5LCB0cnlDb252ZXJ0VG9Qcm9taXNlLCBhcGlSZWplY3Rpb24pIHtcbnZhciB1dGlsID0gcmVxdWlyZShcIi4vdXRpbFwiKTtcbnZhciBpc09iamVjdCA9IHV0aWwuaXNPYmplY3Q7XG52YXIgZXM1ID0gcmVxdWlyZShcIi4vZXM1XCIpO1xudmFyIEVzNk1hcDtcbmlmICh0eXBlb2YgTWFwID09PSBcImZ1bmN0aW9uXCIpIEVzNk1hcCA9IE1hcDtcblxudmFyIG1hcFRvRW50cmllcyA9IChmdW5jdGlvbigpIHtcbiAgICB2YXIgaW5kZXggPSAwO1xuICAgIHZhciBzaXplID0gMDtcblxuICAgIGZ1bmN0aW9uIGV4dHJhY3RFbnRyeSh2YWx1ZSwga2V5KSB7XG4gICAgICAgIHRoaXNbaW5kZXhdID0gdmFsdWU7XG4gICAgICAgIHRoaXNbaW5kZXggKyBzaXplXSA9IGtleTtcbiAgICAgICAgaW5kZXgrKztcbiAgICB9XG5cbiAgICByZXR1cm4gZnVuY3Rpb24gbWFwVG9FbnRyaWVzKG1hcCkge1xuICAgICAgICBzaXplID0gbWFwLnNpemU7XG4gICAgICAgIGluZGV4ID0gMDtcbiAgICAgICAgdmFyIHJldCA9IG5ldyBBcnJheShtYXAuc2l6ZSAqIDIpO1xuICAgICAgICBtYXAuZm9yRWFjaChleHRyYWN0RW50cnksIHJldCk7XG4gICAgICAgIHJldHVybiByZXQ7XG4gICAgfTtcbn0pKCk7XG5cbnZhciBlbnRyaWVzVG9NYXAgPSBmdW5jdGlvbihlbnRyaWVzKSB7XG4gICAgdmFyIHJldCA9IG5ldyBFczZNYXAoKTtcbiAgICB2YXIgbGVuZ3RoID0gZW50cmllcy5sZW5ndGggLyAyIHwgMDtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgKytpKSB7XG4gICAgICAgIHZhciBrZXkgPSBlbnRyaWVzW2xlbmd0aCArIGldO1xuICAgICAgICB2YXIgdmFsdWUgPSBlbnRyaWVzW2ldO1xuICAgICAgICByZXQuc2V0KGtleSwgdmFsdWUpO1xuICAgIH1cbiAgICByZXR1cm4gcmV0O1xufTtcblxuZnVuY3Rpb24gUHJvcGVydGllc1Byb21pc2VBcnJheShvYmopIHtcbiAgICB2YXIgaXNNYXAgPSBmYWxzZTtcbiAgICB2YXIgZW50cmllcztcbiAgICBpZiAoRXM2TWFwICE9PSB1bmRlZmluZWQgJiYgb2JqIGluc3RhbmNlb2YgRXM2TWFwKSB7XG4gICAgICAgIGVudHJpZXMgPSBtYXBUb0VudHJpZXMob2JqKTtcbiAgICAgICAgaXNNYXAgPSB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBrZXlzID0gZXM1LmtleXMob2JqKTtcbiAgICAgICAgdmFyIGxlbiA9IGtleXMubGVuZ3RoO1xuICAgICAgICBlbnRyaWVzID0gbmV3IEFycmF5KGxlbiAqIDIpO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgKytpKSB7XG4gICAgICAgICAgICB2YXIga2V5ID0ga2V5c1tpXTtcbiAgICAgICAgICAgIGVudHJpZXNbaV0gPSBvYmpba2V5XTtcbiAgICAgICAgICAgIGVudHJpZXNbaSArIGxlbl0gPSBrZXk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5jb25zdHJ1Y3RvciQoZW50cmllcyk7XG4gICAgdGhpcy5faXNNYXAgPSBpc01hcDtcbiAgICB0aGlzLl9pbml0JCh1bmRlZmluZWQsIGlzTWFwID8gLTYgOiAtMyk7XG59XG51dGlsLmluaGVyaXRzKFByb3BlcnRpZXNQcm9taXNlQXJyYXksIFByb21pc2VBcnJheSk7XG5cblByb3BlcnRpZXNQcm9taXNlQXJyYXkucHJvdG90eXBlLl9pbml0ID0gZnVuY3Rpb24gKCkge307XG5cblByb3BlcnRpZXNQcm9taXNlQXJyYXkucHJvdG90eXBlLl9wcm9taXNlRnVsZmlsbGVkID0gZnVuY3Rpb24gKHZhbHVlLCBpbmRleCkge1xuICAgIHRoaXMuX3ZhbHVlc1tpbmRleF0gPSB2YWx1ZTtcbiAgICB2YXIgdG90YWxSZXNvbHZlZCA9ICsrdGhpcy5fdG90YWxSZXNvbHZlZDtcbiAgICBpZiAodG90YWxSZXNvbHZlZCA+PSB0aGlzLl9sZW5ndGgpIHtcbiAgICAgICAgdmFyIHZhbDtcbiAgICAgICAgaWYgKHRoaXMuX2lzTWFwKSB7XG4gICAgICAgICAgICB2YWwgPSBlbnRyaWVzVG9NYXAodGhpcy5fdmFsdWVzKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhbCA9IHt9O1xuICAgICAgICAgICAgdmFyIGtleU9mZnNldCA9IHRoaXMubGVuZ3RoKCk7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gdGhpcy5sZW5ndGgoKTsgaSA8IGxlbjsgKytpKSB7XG4gICAgICAgICAgICAgICAgdmFsW3RoaXMuX3ZhbHVlc1tpICsga2V5T2Zmc2V0XV0gPSB0aGlzLl92YWx1ZXNbaV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fcmVzb2x2ZSh2YWwpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufTtcblxuUHJvcGVydGllc1Byb21pc2VBcnJheS5wcm90b3R5cGUuc2hvdWxkQ29weVZhbHVlcyA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gZmFsc2U7XG59O1xuXG5Qcm9wZXJ0aWVzUHJvbWlzZUFycmF5LnByb3RvdHlwZS5nZXRBY3R1YWxMZW5ndGggPSBmdW5jdGlvbiAobGVuKSB7XG4gICAgcmV0dXJuIGxlbiA+PiAxO1xufTtcblxuZnVuY3Rpb24gcHJvcHMocHJvbWlzZXMpIHtcbiAgICB2YXIgcmV0O1xuICAgIHZhciBjYXN0VmFsdWUgPSB0cnlDb252ZXJ0VG9Qcm9taXNlKHByb21pc2VzKTtcblxuICAgIGlmICghaXNPYmplY3QoY2FzdFZhbHVlKSkge1xuICAgICAgICByZXR1cm4gYXBpUmVqZWN0aW9uKFwiY2Fubm90IGF3YWl0IHByb3BlcnRpZXMgb2YgYSBub24tb2JqZWN0XFx1MDAwYVxcdTAwMGEgICAgU2VlIGh0dHA6Ly9nb28uZ2wvTXFyRm1YXFx1MDAwYVwiKTtcbiAgICB9IGVsc2UgaWYgKGNhc3RWYWx1ZSBpbnN0YW5jZW9mIFByb21pc2UpIHtcbiAgICAgICAgcmV0ID0gY2FzdFZhbHVlLl90aGVuKFxuICAgICAgICAgICAgUHJvbWlzZS5wcm9wcywgdW5kZWZpbmVkLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgdW5kZWZpbmVkKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXQgPSBuZXcgUHJvcGVydGllc1Byb21pc2VBcnJheShjYXN0VmFsdWUpLnByb21pc2UoKTtcbiAgICB9XG5cbiAgICBpZiAoY2FzdFZhbHVlIGluc3RhbmNlb2YgUHJvbWlzZSkge1xuICAgICAgICByZXQuX3Byb3BhZ2F0ZUZyb20oY2FzdFZhbHVlLCAyKTtcbiAgICB9XG4gICAgcmV0dXJuIHJldDtcbn1cblxuUHJvbWlzZS5wcm90b3R5cGUucHJvcHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHByb3BzKHRoaXMpO1xufTtcblxuUHJvbWlzZS5wcm9wcyA9IGZ1bmN0aW9uIChwcm9taXNlcykge1xuICAgIHJldHVybiBwcm9wcyhwcm9taXNlcyk7XG59O1xufTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9ibHVlYmlyZC9qcy9yZWxlYXNlL3Byb3BzLmpzIiwiXCJ1c2Ugc3RyaWN0XCI7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKFxuICAgIFByb21pc2UsIElOVEVSTkFMLCB0cnlDb252ZXJ0VG9Qcm9taXNlLCBhcGlSZWplY3Rpb24pIHtcbnZhciB1dGlsID0gcmVxdWlyZShcIi4vdXRpbFwiKTtcblxudmFyIHJhY2VMYXRlciA9IGZ1bmN0aW9uIChwcm9taXNlKSB7XG4gICAgcmV0dXJuIHByb21pc2UudGhlbihmdW5jdGlvbihhcnJheSkge1xuICAgICAgICByZXR1cm4gcmFjZShhcnJheSwgcHJvbWlzZSk7XG4gICAgfSk7XG59O1xuXG5mdW5jdGlvbiByYWNlKHByb21pc2VzLCBwYXJlbnQpIHtcbiAgICB2YXIgbWF5YmVQcm9taXNlID0gdHJ5Q29udmVydFRvUHJvbWlzZShwcm9taXNlcyk7XG5cbiAgICBpZiAobWF5YmVQcm9taXNlIGluc3RhbmNlb2YgUHJvbWlzZSkge1xuICAgICAgICByZXR1cm4gcmFjZUxhdGVyKG1heWJlUHJvbWlzZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcHJvbWlzZXMgPSB1dGlsLmFzQXJyYXkocHJvbWlzZXMpO1xuICAgICAgICBpZiAocHJvbWlzZXMgPT09IG51bGwpXG4gICAgICAgICAgICByZXR1cm4gYXBpUmVqZWN0aW9uKFwiZXhwZWN0aW5nIGFuIGFycmF5IG9yIGFuIGl0ZXJhYmxlIG9iamVjdCBidXQgZ290IFwiICsgdXRpbC5jbGFzc1N0cmluZyhwcm9taXNlcykpO1xuICAgIH1cblxuICAgIHZhciByZXQgPSBuZXcgUHJvbWlzZShJTlRFUk5BTCk7XG4gICAgaWYgKHBhcmVudCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldC5fcHJvcGFnYXRlRnJvbShwYXJlbnQsIDMpO1xuICAgIH1cbiAgICB2YXIgZnVsZmlsbCA9IHJldC5fZnVsZmlsbDtcbiAgICB2YXIgcmVqZWN0ID0gcmV0Ll9yZWplY3Q7XG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHByb21pc2VzLmxlbmd0aDsgaSA8IGxlbjsgKytpKSB7XG4gICAgICAgIHZhciB2YWwgPSBwcm9taXNlc1tpXTtcblxuICAgICAgICBpZiAodmFsID09PSB1bmRlZmluZWQgJiYgIShpIGluIHByb21pc2VzKSkge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICBQcm9taXNlLmNhc3QodmFsKS5fdGhlbihmdWxmaWxsLCByZWplY3QsIHVuZGVmaW5lZCwgcmV0LCBudWxsKTtcbiAgICB9XG4gICAgcmV0dXJuIHJldDtcbn1cblxuUHJvbWlzZS5yYWNlID0gZnVuY3Rpb24gKHByb21pc2VzKSB7XG4gICAgcmV0dXJuIHJhY2UocHJvbWlzZXMsIHVuZGVmaW5lZCk7XG59O1xuXG5Qcm9taXNlLnByb3RvdHlwZS5yYWNlID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiByYWNlKHRoaXMsIHVuZGVmaW5lZCk7XG59O1xuXG59O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2JsdWViaXJkL2pzL3JlbGVhc2UvcmFjZS5qcyIsIlwidXNlIHN0cmljdFwiO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihQcm9taXNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICBQcm9taXNlQXJyYXksXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGFwaVJlamVjdGlvbixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgdHJ5Q29udmVydFRvUHJvbWlzZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgSU5URVJOQUwsXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGRlYnVnKSB7XG52YXIgZ2V0RG9tYWluID0gUHJvbWlzZS5fZ2V0RG9tYWluO1xudmFyIHV0aWwgPSByZXF1aXJlKFwiLi91dGlsXCIpO1xudmFyIHRyeUNhdGNoID0gdXRpbC50cnlDYXRjaDtcblxuZnVuY3Rpb24gUmVkdWN0aW9uUHJvbWlzZUFycmF5KHByb21pc2VzLCBmbiwgaW5pdGlhbFZhbHVlLCBfZWFjaCkge1xuICAgIHRoaXMuY29uc3RydWN0b3IkKHByb21pc2VzKTtcbiAgICB2YXIgZG9tYWluID0gZ2V0RG9tYWluKCk7XG4gICAgdGhpcy5fZm4gPSBkb21haW4gPT09IG51bGwgPyBmbiA6IHV0aWwuZG9tYWluQmluZChkb21haW4sIGZuKTtcbiAgICBpZiAoaW5pdGlhbFZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgaW5pdGlhbFZhbHVlID0gUHJvbWlzZS5yZXNvbHZlKGluaXRpYWxWYWx1ZSk7XG4gICAgICAgIGluaXRpYWxWYWx1ZS5fYXR0YWNoQ2FuY2VsbGF0aW9uQ2FsbGJhY2sodGhpcyk7XG4gICAgfVxuICAgIHRoaXMuX2luaXRpYWxWYWx1ZSA9IGluaXRpYWxWYWx1ZTtcbiAgICB0aGlzLl9jdXJyZW50Q2FuY2VsbGFibGUgPSBudWxsO1xuICAgIGlmKF9lYWNoID09PSBJTlRFUk5BTCkge1xuICAgICAgICB0aGlzLl9lYWNoVmFsdWVzID0gQXJyYXkodGhpcy5fbGVuZ3RoKTtcbiAgICB9IGVsc2UgaWYgKF9lYWNoID09PSAwKSB7XG4gICAgICAgIHRoaXMuX2VhY2hWYWx1ZXMgPSBudWxsO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuX2VhY2hWYWx1ZXMgPSB1bmRlZmluZWQ7XG4gICAgfVxuICAgIHRoaXMuX3Byb21pc2UuX2NhcHR1cmVTdGFja1RyYWNlKCk7XG4gICAgdGhpcy5faW5pdCQodW5kZWZpbmVkLCAtNSk7XG59XG51dGlsLmluaGVyaXRzKFJlZHVjdGlvblByb21pc2VBcnJheSwgUHJvbWlzZUFycmF5KTtcblxuUmVkdWN0aW9uUHJvbWlzZUFycmF5LnByb3RvdHlwZS5fZ290QWNjdW0gPSBmdW5jdGlvbihhY2N1bSkge1xuICAgIGlmICh0aGlzLl9lYWNoVmFsdWVzICE9PSB1bmRlZmluZWQgJiYgXG4gICAgICAgIHRoaXMuX2VhY2hWYWx1ZXMgIT09IG51bGwgJiYgXG4gICAgICAgIGFjY3VtICE9PSBJTlRFUk5BTCkge1xuICAgICAgICB0aGlzLl9lYWNoVmFsdWVzLnB1c2goYWNjdW0pO1xuICAgIH1cbn07XG5cblJlZHVjdGlvblByb21pc2VBcnJheS5wcm90b3R5cGUuX2VhY2hDb21wbGV0ZSA9IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgaWYgKHRoaXMuX2VhY2hWYWx1ZXMgIT09IG51bGwpIHtcbiAgICAgICAgdGhpcy5fZWFjaFZhbHVlcy5wdXNoKHZhbHVlKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX2VhY2hWYWx1ZXM7XG59O1xuXG5SZWR1Y3Rpb25Qcm9taXNlQXJyYXkucHJvdG90eXBlLl9pbml0ID0gZnVuY3Rpb24oKSB7fTtcblxuUmVkdWN0aW9uUHJvbWlzZUFycmF5LnByb3RvdHlwZS5fcmVzb2x2ZUVtcHR5QXJyYXkgPSBmdW5jdGlvbigpIHtcbiAgICB0aGlzLl9yZXNvbHZlKHRoaXMuX2VhY2hWYWx1ZXMgIT09IHVuZGVmaW5lZCA/IHRoaXMuX2VhY2hWYWx1ZXNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IHRoaXMuX2luaXRpYWxWYWx1ZSk7XG59O1xuXG5SZWR1Y3Rpb25Qcm9taXNlQXJyYXkucHJvdG90eXBlLnNob3VsZENvcHlWYWx1ZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xufTtcblxuUmVkdWN0aW9uUHJvbWlzZUFycmF5LnByb3RvdHlwZS5fcmVzb2x2ZSA9IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgdGhpcy5fcHJvbWlzZS5fcmVzb2x2ZUNhbGxiYWNrKHZhbHVlKTtcbiAgICB0aGlzLl92YWx1ZXMgPSBudWxsO1xufTtcblxuUmVkdWN0aW9uUHJvbWlzZUFycmF5LnByb3RvdHlwZS5fcmVzdWx0Q2FuY2VsbGVkID0gZnVuY3Rpb24oc2VuZGVyKSB7XG4gICAgaWYgKHNlbmRlciA9PT0gdGhpcy5faW5pdGlhbFZhbHVlKSByZXR1cm4gdGhpcy5fY2FuY2VsKCk7XG4gICAgaWYgKHRoaXMuX2lzUmVzb2x2ZWQoKSkgcmV0dXJuO1xuICAgIHRoaXMuX3Jlc3VsdENhbmNlbGxlZCQoKTtcbiAgICBpZiAodGhpcy5fY3VycmVudENhbmNlbGxhYmxlIGluc3RhbmNlb2YgUHJvbWlzZSkge1xuICAgICAgICB0aGlzLl9jdXJyZW50Q2FuY2VsbGFibGUuY2FuY2VsKCk7XG4gICAgfVxuICAgIGlmICh0aGlzLl9pbml0aWFsVmFsdWUgaW5zdGFuY2VvZiBQcm9taXNlKSB7XG4gICAgICAgIHRoaXMuX2luaXRpYWxWYWx1ZS5jYW5jZWwoKTtcbiAgICB9XG59O1xuXG5SZWR1Y3Rpb25Qcm9taXNlQXJyYXkucHJvdG90eXBlLl9pdGVyYXRlID0gZnVuY3Rpb24gKHZhbHVlcykge1xuICAgIHRoaXMuX3ZhbHVlcyA9IHZhbHVlcztcbiAgICB2YXIgdmFsdWU7XG4gICAgdmFyIGk7XG4gICAgdmFyIGxlbmd0aCA9IHZhbHVlcy5sZW5ndGg7XG4gICAgaWYgKHRoaXMuX2luaXRpYWxWYWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHZhbHVlID0gdGhpcy5faW5pdGlhbFZhbHVlO1xuICAgICAgICBpID0gMDtcbiAgICB9IGVsc2Uge1xuICAgICAgICB2YWx1ZSA9IFByb21pc2UucmVzb2x2ZSh2YWx1ZXNbMF0pO1xuICAgICAgICBpID0gMTtcbiAgICB9XG5cbiAgICB0aGlzLl9jdXJyZW50Q2FuY2VsbGFibGUgPSB2YWx1ZTtcblxuICAgIGlmICghdmFsdWUuaXNSZWplY3RlZCgpKSB7XG4gICAgICAgIGZvciAoOyBpIDwgbGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIHZhciBjdHggPSB7XG4gICAgICAgICAgICAgICAgYWNjdW06IG51bGwsXG4gICAgICAgICAgICAgICAgdmFsdWU6IHZhbHVlc1tpXSxcbiAgICAgICAgICAgICAgICBpbmRleDogaSxcbiAgICAgICAgICAgICAgICBsZW5ndGg6IGxlbmd0aCxcbiAgICAgICAgICAgICAgICBhcnJheTogdGhpc1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHZhbHVlID0gdmFsdWUuX3RoZW4oZ290QWNjdW0sIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBjdHgsIHVuZGVmaW5lZCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAodGhpcy5fZWFjaFZhbHVlcyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHZhbHVlID0gdmFsdWVcbiAgICAgICAgICAgIC5fdGhlbih0aGlzLl9lYWNoQ29tcGxldGUsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCB0aGlzLCB1bmRlZmluZWQpO1xuICAgIH1cbiAgICB2YWx1ZS5fdGhlbihjb21wbGV0ZWQsIGNvbXBsZXRlZCwgdW5kZWZpbmVkLCB2YWx1ZSwgdGhpcyk7XG59O1xuXG5Qcm9taXNlLnByb3RvdHlwZS5yZWR1Y2UgPSBmdW5jdGlvbiAoZm4sIGluaXRpYWxWYWx1ZSkge1xuICAgIHJldHVybiByZWR1Y2UodGhpcywgZm4sIGluaXRpYWxWYWx1ZSwgbnVsbCk7XG59O1xuXG5Qcm9taXNlLnJlZHVjZSA9IGZ1bmN0aW9uIChwcm9taXNlcywgZm4sIGluaXRpYWxWYWx1ZSwgX2VhY2gpIHtcbiAgICByZXR1cm4gcmVkdWNlKHByb21pc2VzLCBmbiwgaW5pdGlhbFZhbHVlLCBfZWFjaCk7XG59O1xuXG5mdW5jdGlvbiBjb21wbGV0ZWQodmFsdWVPclJlYXNvbiwgYXJyYXkpIHtcbiAgICBpZiAodGhpcy5pc0Z1bGZpbGxlZCgpKSB7XG4gICAgICAgIGFycmF5Ll9yZXNvbHZlKHZhbHVlT3JSZWFzb24pO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGFycmF5Ll9yZWplY3QodmFsdWVPclJlYXNvbik7XG4gICAgfVxufVxuXG5mdW5jdGlvbiByZWR1Y2UocHJvbWlzZXMsIGZuLCBpbml0aWFsVmFsdWUsIF9lYWNoKSB7XG4gICAgaWYgKHR5cGVvZiBmbiAhPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIHJldHVybiBhcGlSZWplY3Rpb24oXCJleHBlY3RpbmcgYSBmdW5jdGlvbiBidXQgZ290IFwiICsgdXRpbC5jbGFzc1N0cmluZyhmbikpO1xuICAgIH1cbiAgICB2YXIgYXJyYXkgPSBuZXcgUmVkdWN0aW9uUHJvbWlzZUFycmF5KHByb21pc2VzLCBmbiwgaW5pdGlhbFZhbHVlLCBfZWFjaCk7XG4gICAgcmV0dXJuIGFycmF5LnByb21pc2UoKTtcbn1cblxuZnVuY3Rpb24gZ290QWNjdW0oYWNjdW0pIHtcbiAgICB0aGlzLmFjY3VtID0gYWNjdW07XG4gICAgdGhpcy5hcnJheS5fZ290QWNjdW0oYWNjdW0pO1xuICAgIHZhciB2YWx1ZSA9IHRyeUNvbnZlcnRUb1Byb21pc2UodGhpcy52YWx1ZSwgdGhpcy5hcnJheS5fcHJvbWlzZSk7XG4gICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgUHJvbWlzZSkge1xuICAgICAgICB0aGlzLmFycmF5Ll9jdXJyZW50Q2FuY2VsbGFibGUgPSB2YWx1ZTtcbiAgICAgICAgcmV0dXJuIHZhbHVlLl90aGVuKGdvdFZhbHVlLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgdGhpcywgdW5kZWZpbmVkKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gZ290VmFsdWUuY2FsbCh0aGlzLCB2YWx1ZSk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBnb3RWYWx1ZSh2YWx1ZSkge1xuICAgIHZhciBhcnJheSA9IHRoaXMuYXJyYXk7XG4gICAgdmFyIHByb21pc2UgPSBhcnJheS5fcHJvbWlzZTtcbiAgICB2YXIgZm4gPSB0cnlDYXRjaChhcnJheS5fZm4pO1xuICAgIHByb21pc2UuX3B1c2hDb250ZXh0KCk7XG4gICAgdmFyIHJldDtcbiAgICBpZiAoYXJyYXkuX2VhY2hWYWx1ZXMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXQgPSBmbi5jYWxsKHByb21pc2UuX2JvdW5kVmFsdWUoKSwgdmFsdWUsIHRoaXMuaW5kZXgsIHRoaXMubGVuZ3RoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXQgPSBmbi5jYWxsKHByb21pc2UuX2JvdW5kVmFsdWUoKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuYWNjdW0sIHZhbHVlLCB0aGlzLmluZGV4LCB0aGlzLmxlbmd0aCk7XG4gICAgfVxuICAgIGlmIChyZXQgaW5zdGFuY2VvZiBQcm9taXNlKSB7XG4gICAgICAgIGFycmF5Ll9jdXJyZW50Q2FuY2VsbGFibGUgPSByZXQ7XG4gICAgfVxuICAgIHZhciBwcm9taXNlQ3JlYXRlZCA9IHByb21pc2UuX3BvcENvbnRleHQoKTtcbiAgICBkZWJ1Zy5jaGVja0ZvcmdvdHRlblJldHVybnMoXG4gICAgICAgIHJldCxcbiAgICAgICAgcHJvbWlzZUNyZWF0ZWQsXG4gICAgICAgIGFycmF5Ll9lYWNoVmFsdWVzICE9PSB1bmRlZmluZWQgPyBcIlByb21pc2UuZWFjaFwiIDogXCJQcm9taXNlLnJlZHVjZVwiLFxuICAgICAgICBwcm9taXNlXG4gICAgKTtcbiAgICByZXR1cm4gcmV0O1xufVxufTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9ibHVlYmlyZC9qcy9yZWxlYXNlL3JlZHVjZS5qcyIsIlwidXNlIHN0cmljdFwiO1xubW9kdWxlLmV4cG9ydHMgPVxuICAgIGZ1bmN0aW9uKFByb21pc2UsIFByb21pc2VBcnJheSwgZGVidWcpIHtcbnZhciBQcm9taXNlSW5zcGVjdGlvbiA9IFByb21pc2UuUHJvbWlzZUluc3BlY3Rpb247XG52YXIgdXRpbCA9IHJlcXVpcmUoXCIuL3V0aWxcIik7XG5cbmZ1bmN0aW9uIFNldHRsZWRQcm9taXNlQXJyYXkodmFsdWVzKSB7XG4gICAgdGhpcy5jb25zdHJ1Y3RvciQodmFsdWVzKTtcbn1cbnV0aWwuaW5oZXJpdHMoU2V0dGxlZFByb21pc2VBcnJheSwgUHJvbWlzZUFycmF5KTtcblxuU2V0dGxlZFByb21pc2VBcnJheS5wcm90b3R5cGUuX3Byb21pc2VSZXNvbHZlZCA9IGZ1bmN0aW9uIChpbmRleCwgaW5zcGVjdGlvbikge1xuICAgIHRoaXMuX3ZhbHVlc1tpbmRleF0gPSBpbnNwZWN0aW9uO1xuICAgIHZhciB0b3RhbFJlc29sdmVkID0gKyt0aGlzLl90b3RhbFJlc29sdmVkO1xuICAgIGlmICh0b3RhbFJlc29sdmVkID49IHRoaXMuX2xlbmd0aCkge1xuICAgICAgICB0aGlzLl9yZXNvbHZlKHRoaXMuX3ZhbHVlcyk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59O1xuXG5TZXR0bGVkUHJvbWlzZUFycmF5LnByb3RvdHlwZS5fcHJvbWlzZUZ1bGZpbGxlZCA9IGZ1bmN0aW9uICh2YWx1ZSwgaW5kZXgpIHtcbiAgICB2YXIgcmV0ID0gbmV3IFByb21pc2VJbnNwZWN0aW9uKCk7XG4gICAgcmV0Ll9iaXRGaWVsZCA9IDMzNTU0NDMyO1xuICAgIHJldC5fc2V0dGxlZFZhbHVlRmllbGQgPSB2YWx1ZTtcbiAgICByZXR1cm4gdGhpcy5fcHJvbWlzZVJlc29sdmVkKGluZGV4LCByZXQpO1xufTtcblNldHRsZWRQcm9taXNlQXJyYXkucHJvdG90eXBlLl9wcm9taXNlUmVqZWN0ZWQgPSBmdW5jdGlvbiAocmVhc29uLCBpbmRleCkge1xuICAgIHZhciByZXQgPSBuZXcgUHJvbWlzZUluc3BlY3Rpb24oKTtcbiAgICByZXQuX2JpdEZpZWxkID0gMTY3NzcyMTY7XG4gICAgcmV0Ll9zZXR0bGVkVmFsdWVGaWVsZCA9IHJlYXNvbjtcbiAgICByZXR1cm4gdGhpcy5fcHJvbWlzZVJlc29sdmVkKGluZGV4LCByZXQpO1xufTtcblxuUHJvbWlzZS5zZXR0bGUgPSBmdW5jdGlvbiAocHJvbWlzZXMpIHtcbiAgICBkZWJ1Zy5kZXByZWNhdGVkKFwiLnNldHRsZSgpXCIsIFwiLnJlZmxlY3QoKVwiKTtcbiAgICByZXR1cm4gbmV3IFNldHRsZWRQcm9taXNlQXJyYXkocHJvbWlzZXMpLnByb21pc2UoKTtcbn07XG5cblByb21pc2UucHJvdG90eXBlLnNldHRsZSA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gUHJvbWlzZS5zZXR0bGUodGhpcyk7XG59O1xufTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9ibHVlYmlyZC9qcy9yZWxlYXNlL3NldHRsZS5qcyIsIlwidXNlIHN0cmljdFwiO1xubW9kdWxlLmV4cG9ydHMgPVxuZnVuY3Rpb24oUHJvbWlzZSwgUHJvbWlzZUFycmF5LCBhcGlSZWplY3Rpb24pIHtcbnZhciB1dGlsID0gcmVxdWlyZShcIi4vdXRpbFwiKTtcbnZhciBSYW5nZUVycm9yID0gcmVxdWlyZShcIi4vZXJyb3JzXCIpLlJhbmdlRXJyb3I7XG52YXIgQWdncmVnYXRlRXJyb3IgPSByZXF1aXJlKFwiLi9lcnJvcnNcIikuQWdncmVnYXRlRXJyb3I7XG52YXIgaXNBcnJheSA9IHV0aWwuaXNBcnJheTtcbnZhciBDQU5DRUxMQVRJT04gPSB7fTtcblxuXG5mdW5jdGlvbiBTb21lUHJvbWlzZUFycmF5KHZhbHVlcykge1xuICAgIHRoaXMuY29uc3RydWN0b3IkKHZhbHVlcyk7XG4gICAgdGhpcy5faG93TWFueSA9IDA7XG4gICAgdGhpcy5fdW53cmFwID0gZmFsc2U7XG4gICAgdGhpcy5faW5pdGlhbGl6ZWQgPSBmYWxzZTtcbn1cbnV0aWwuaW5oZXJpdHMoU29tZVByb21pc2VBcnJheSwgUHJvbWlzZUFycmF5KTtcblxuU29tZVByb21pc2VBcnJheS5wcm90b3R5cGUuX2luaXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKCF0aGlzLl9pbml0aWFsaXplZCkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICh0aGlzLl9ob3dNYW55ID09PSAwKSB7XG4gICAgICAgIHRoaXMuX3Jlc29sdmUoW10pO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuX2luaXQkKHVuZGVmaW5lZCwgLTUpO1xuICAgIHZhciBpc0FycmF5UmVzb2x2ZWQgPSBpc0FycmF5KHRoaXMuX3ZhbHVlcyk7XG4gICAgaWYgKCF0aGlzLl9pc1Jlc29sdmVkKCkgJiZcbiAgICAgICAgaXNBcnJheVJlc29sdmVkICYmXG4gICAgICAgIHRoaXMuX2hvd01hbnkgPiB0aGlzLl9jYW5Qb3NzaWJseUZ1bGZpbGwoKSkge1xuICAgICAgICB0aGlzLl9yZWplY3QodGhpcy5fZ2V0UmFuZ2VFcnJvcih0aGlzLmxlbmd0aCgpKSk7XG4gICAgfVxufTtcblxuU29tZVByb21pc2VBcnJheS5wcm90b3R5cGUuaW5pdCA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLl9pbml0aWFsaXplZCA9IHRydWU7XG4gICAgdGhpcy5faW5pdCgpO1xufTtcblxuU29tZVByb21pc2VBcnJheS5wcm90b3R5cGUuc2V0VW53cmFwID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuX3Vud3JhcCA9IHRydWU7XG59O1xuXG5Tb21lUHJvbWlzZUFycmF5LnByb3RvdHlwZS5ob3dNYW55ID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLl9ob3dNYW55O1xufTtcblxuU29tZVByb21pc2VBcnJheS5wcm90b3R5cGUuc2V0SG93TWFueSA9IGZ1bmN0aW9uIChjb3VudCkge1xuICAgIHRoaXMuX2hvd01hbnkgPSBjb3VudDtcbn07XG5cblNvbWVQcm9taXNlQXJyYXkucHJvdG90eXBlLl9wcm9taXNlRnVsZmlsbGVkID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgdGhpcy5fYWRkRnVsZmlsbGVkKHZhbHVlKTtcbiAgICBpZiAodGhpcy5fZnVsZmlsbGVkKCkgPT09IHRoaXMuaG93TWFueSgpKSB7XG4gICAgICAgIHRoaXMuX3ZhbHVlcy5sZW5ndGggPSB0aGlzLmhvd01hbnkoKTtcbiAgICAgICAgaWYgKHRoaXMuaG93TWFueSgpID09PSAxICYmIHRoaXMuX3Vud3JhcCkge1xuICAgICAgICAgICAgdGhpcy5fcmVzb2x2ZSh0aGlzLl92YWx1ZXNbMF0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5fcmVzb2x2ZSh0aGlzLl92YWx1ZXMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG5cbn07XG5Tb21lUHJvbWlzZUFycmF5LnByb3RvdHlwZS5fcHJvbWlzZVJlamVjdGVkID0gZnVuY3Rpb24gKHJlYXNvbikge1xuICAgIHRoaXMuX2FkZFJlamVjdGVkKHJlYXNvbik7XG4gICAgcmV0dXJuIHRoaXMuX2NoZWNrT3V0Y29tZSgpO1xufTtcblxuU29tZVByb21pc2VBcnJheS5wcm90b3R5cGUuX3Byb21pc2VDYW5jZWxsZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHRoaXMuX3ZhbHVlcyBpbnN0YW5jZW9mIFByb21pc2UgfHwgdGhpcy5fdmFsdWVzID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2NhbmNlbCgpO1xuICAgIH1cbiAgICB0aGlzLl9hZGRSZWplY3RlZChDQU5DRUxMQVRJT04pO1xuICAgIHJldHVybiB0aGlzLl9jaGVja091dGNvbWUoKTtcbn07XG5cblNvbWVQcm9taXNlQXJyYXkucHJvdG90eXBlLl9jaGVja091dGNvbWUgPSBmdW5jdGlvbigpIHtcbiAgICBpZiAodGhpcy5ob3dNYW55KCkgPiB0aGlzLl9jYW5Qb3NzaWJseUZ1bGZpbGwoKSkge1xuICAgICAgICB2YXIgZSA9IG5ldyBBZ2dyZWdhdGVFcnJvcigpO1xuICAgICAgICBmb3IgKHZhciBpID0gdGhpcy5sZW5ndGgoKTsgaSA8IHRoaXMuX3ZhbHVlcy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgaWYgKHRoaXMuX3ZhbHVlc1tpXSAhPT0gQ0FOQ0VMTEFUSU9OKSB7XG4gICAgICAgICAgICAgICAgZS5wdXNoKHRoaXMuX3ZhbHVlc1tpXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGUubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgdGhpcy5fcmVqZWN0KGUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5fY2FuY2VsKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn07XG5cblNvbWVQcm9taXNlQXJyYXkucHJvdG90eXBlLl9mdWxmaWxsZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3RvdGFsUmVzb2x2ZWQ7XG59O1xuXG5Tb21lUHJvbWlzZUFycmF5LnByb3RvdHlwZS5fcmVqZWN0ZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3ZhbHVlcy5sZW5ndGggLSB0aGlzLmxlbmd0aCgpO1xufTtcblxuU29tZVByb21pc2VBcnJheS5wcm90b3R5cGUuX2FkZFJlamVjdGVkID0gZnVuY3Rpb24gKHJlYXNvbikge1xuICAgIHRoaXMuX3ZhbHVlcy5wdXNoKHJlYXNvbik7XG59O1xuXG5Tb21lUHJvbWlzZUFycmF5LnByb3RvdHlwZS5fYWRkRnVsZmlsbGVkID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgdGhpcy5fdmFsdWVzW3RoaXMuX3RvdGFsUmVzb2x2ZWQrK10gPSB2YWx1ZTtcbn07XG5cblNvbWVQcm9taXNlQXJyYXkucHJvdG90eXBlLl9jYW5Qb3NzaWJseUZ1bGZpbGwgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMubGVuZ3RoKCkgLSB0aGlzLl9yZWplY3RlZCgpO1xufTtcblxuU29tZVByb21pc2VBcnJheS5wcm90b3R5cGUuX2dldFJhbmdlRXJyb3IgPSBmdW5jdGlvbiAoY291bnQpIHtcbiAgICB2YXIgbWVzc2FnZSA9IFwiSW5wdXQgYXJyYXkgbXVzdCBjb250YWluIGF0IGxlYXN0IFwiICtcbiAgICAgICAgICAgIHRoaXMuX2hvd01hbnkgKyBcIiBpdGVtcyBidXQgY29udGFpbnMgb25seSBcIiArIGNvdW50ICsgXCIgaXRlbXNcIjtcbiAgICByZXR1cm4gbmV3IFJhbmdlRXJyb3IobWVzc2FnZSk7XG59O1xuXG5Tb21lUHJvbWlzZUFycmF5LnByb3RvdHlwZS5fcmVzb2x2ZUVtcHR5QXJyYXkgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5fcmVqZWN0KHRoaXMuX2dldFJhbmdlRXJyb3IoMCkpO1xufTtcblxuZnVuY3Rpb24gc29tZShwcm9taXNlcywgaG93TWFueSkge1xuICAgIGlmICgoaG93TWFueSB8IDApICE9PSBob3dNYW55IHx8IGhvd01hbnkgPCAwKSB7XG4gICAgICAgIHJldHVybiBhcGlSZWplY3Rpb24oXCJleHBlY3RpbmcgYSBwb3NpdGl2ZSBpbnRlZ2VyXFx1MDAwYVxcdTAwMGEgICAgU2VlIGh0dHA6Ly9nb28uZ2wvTXFyRm1YXFx1MDAwYVwiKTtcbiAgICB9XG4gICAgdmFyIHJldCA9IG5ldyBTb21lUHJvbWlzZUFycmF5KHByb21pc2VzKTtcbiAgICB2YXIgcHJvbWlzZSA9IHJldC5wcm9taXNlKCk7XG4gICAgcmV0LnNldEhvd01hbnkoaG93TWFueSk7XG4gICAgcmV0LmluaXQoKTtcbiAgICByZXR1cm4gcHJvbWlzZTtcbn1cblxuUHJvbWlzZS5zb21lID0gZnVuY3Rpb24gKHByb21pc2VzLCBob3dNYW55KSB7XG4gICAgcmV0dXJuIHNvbWUocHJvbWlzZXMsIGhvd01hbnkpO1xufTtcblxuUHJvbWlzZS5wcm90b3R5cGUuc29tZSA9IGZ1bmN0aW9uIChob3dNYW55KSB7XG4gICAgcmV0dXJuIHNvbWUodGhpcywgaG93TWFueSk7XG59O1xuXG5Qcm9taXNlLl9Tb21lUHJvbWlzZUFycmF5ID0gU29tZVByb21pc2VBcnJheTtcbn07XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvYmx1ZWJpcmQvanMvcmVsZWFzZS9zb21lLmpzIiwiXCJ1c2Ugc3RyaWN0XCI7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKFByb21pc2UsIElOVEVSTkFMKSB7XG52YXIgUHJvbWlzZU1hcCA9IFByb21pc2UubWFwO1xuXG5Qcm9taXNlLnByb3RvdHlwZS5maWx0ZXIgPSBmdW5jdGlvbiAoZm4sIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gUHJvbWlzZU1hcCh0aGlzLCBmbiwgb3B0aW9ucywgSU5URVJOQUwpO1xufTtcblxuUHJvbWlzZS5maWx0ZXIgPSBmdW5jdGlvbiAocHJvbWlzZXMsIGZuLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIFByb21pc2VNYXAocHJvbWlzZXMsIGZuLCBvcHRpb25zLCBJTlRFUk5BTCk7XG59O1xufTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9ibHVlYmlyZC9qcy9yZWxlYXNlL2ZpbHRlci5qcyIsIlwidXNlIHN0cmljdFwiO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihQcm9taXNlLCBJTlRFUk5BTCkge1xudmFyIFByb21pc2VSZWR1Y2UgPSBQcm9taXNlLnJlZHVjZTtcbnZhciBQcm9taXNlQWxsID0gUHJvbWlzZS5hbGw7XG5cbmZ1bmN0aW9uIHByb21pc2VBbGxUaGlzKCkge1xuICAgIHJldHVybiBQcm9taXNlQWxsKHRoaXMpO1xufVxuXG5mdW5jdGlvbiBQcm9taXNlTWFwU2VyaWVzKHByb21pc2VzLCBmbikge1xuICAgIHJldHVybiBQcm9taXNlUmVkdWNlKHByb21pc2VzLCBmbiwgSU5URVJOQUwsIElOVEVSTkFMKTtcbn1cblxuUHJvbWlzZS5wcm90b3R5cGUuZWFjaCA9IGZ1bmN0aW9uIChmbikge1xuICAgIHJldHVybiBQcm9taXNlUmVkdWNlKHRoaXMsIGZuLCBJTlRFUk5BTCwgMClcbiAgICAgICAgICAgICAgLl90aGVuKHByb21pc2VBbGxUaGlzLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgdGhpcywgdW5kZWZpbmVkKTtcbn07XG5cblByb21pc2UucHJvdG90eXBlLm1hcFNlcmllcyA9IGZ1bmN0aW9uIChmbikge1xuICAgIHJldHVybiBQcm9taXNlUmVkdWNlKHRoaXMsIGZuLCBJTlRFUk5BTCwgSU5URVJOQUwpO1xufTtcblxuUHJvbWlzZS5lYWNoID0gZnVuY3Rpb24gKHByb21pc2VzLCBmbikge1xuICAgIHJldHVybiBQcm9taXNlUmVkdWNlKHByb21pc2VzLCBmbiwgSU5URVJOQUwsIDApXG4gICAgICAgICAgICAgIC5fdGhlbihwcm9taXNlQWxsVGhpcywgdW5kZWZpbmVkLCB1bmRlZmluZWQsIHByb21pc2VzLCB1bmRlZmluZWQpO1xufTtcblxuUHJvbWlzZS5tYXBTZXJpZXMgPSBQcm9taXNlTWFwU2VyaWVzO1xufTtcblxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2JsdWViaXJkL2pzL3JlbGVhc2UvZWFjaC5qcyIsIlwidXNlIHN0cmljdFwiO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihQcm9taXNlKSB7XG52YXIgU29tZVByb21pc2VBcnJheSA9IFByb21pc2UuX1NvbWVQcm9taXNlQXJyYXk7XG5mdW5jdGlvbiBhbnkocHJvbWlzZXMpIHtcbiAgICB2YXIgcmV0ID0gbmV3IFNvbWVQcm9taXNlQXJyYXkocHJvbWlzZXMpO1xuICAgIHZhciBwcm9taXNlID0gcmV0LnByb21pc2UoKTtcbiAgICByZXQuc2V0SG93TWFueSgxKTtcbiAgICByZXQuc2V0VW53cmFwKCk7XG4gICAgcmV0LmluaXQoKTtcbiAgICByZXR1cm4gcHJvbWlzZTtcbn1cblxuUHJvbWlzZS5hbnkgPSBmdW5jdGlvbiAocHJvbWlzZXMpIHtcbiAgICByZXR1cm4gYW55KHByb21pc2VzKTtcbn07XG5cblByb21pc2UucHJvdG90eXBlLmFueSA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gYW55KHRoaXMpO1xufTtcblxufTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9ibHVlYmlyZC9qcy9yZWxlYXNlL2FueS5qcyIsIi8qKlxuICogRGV0ZWN0IEVsZWN0cm9uIHJlbmRlcmVyIHByb2Nlc3MsIHdoaWNoIGlzIG5vZGUsIGJ1dCB3ZSBzaG91bGRcbiAqIHRyZWF0IGFzIGEgYnJvd3Nlci5cbiAqL1xuXG5pZiAodHlwZW9mIHByb2Nlc3MgPT09ICd1bmRlZmluZWQnIHx8IHByb2Nlc3MudHlwZSA9PT0gJ3JlbmRlcmVyJykge1xuICBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vYnJvd3Nlci5qcycpO1xufSBlbHNlIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL25vZGUuanMnKTtcbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9lbGVjdHJvbi11cGRhdGVyL25vZGVfbW9kdWxlcy9kZWJ1Zy9zcmMvaW5kZXguanMiLCIvKipcbiAqIFRoaXMgaXMgdGhlIHdlYiBicm93c2VyIGltcGxlbWVudGF0aW9uIG9mIGBkZWJ1ZygpYC5cbiAqXG4gKiBFeHBvc2UgYGRlYnVnKClgIGFzIHRoZSBtb2R1bGUuXG4gKi9cblxuZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9kZWJ1ZycpO1xuZXhwb3J0cy5sb2cgPSBsb2c7XG5leHBvcnRzLmZvcm1hdEFyZ3MgPSBmb3JtYXRBcmdzO1xuZXhwb3J0cy5zYXZlID0gc2F2ZTtcbmV4cG9ydHMubG9hZCA9IGxvYWQ7XG5leHBvcnRzLnVzZUNvbG9ycyA9IHVzZUNvbG9ycztcbmV4cG9ydHMuc3RvcmFnZSA9ICd1bmRlZmluZWQnICE9IHR5cGVvZiBjaHJvbWVcbiAgICAgICAgICAgICAgICYmICd1bmRlZmluZWQnICE9IHR5cGVvZiBjaHJvbWUuc3RvcmFnZVxuICAgICAgICAgICAgICAgICAgPyBjaHJvbWUuc3RvcmFnZS5sb2NhbFxuICAgICAgICAgICAgICAgICAgOiBsb2NhbHN0b3JhZ2UoKTtcblxuLyoqXG4gKiBDb2xvcnMuXG4gKi9cblxuZXhwb3J0cy5jb2xvcnMgPSBbXG4gICcjMDAwMENDJywgJyMwMDAwRkYnLCAnIzAwMzNDQycsICcjMDAzM0ZGJywgJyMwMDY2Q0MnLCAnIzAwNjZGRicsICcjMDA5OUNDJyxcbiAgJyMwMDk5RkYnLCAnIzAwQ0MwMCcsICcjMDBDQzMzJywgJyMwMENDNjYnLCAnIzAwQ0M5OScsICcjMDBDQ0NDJywgJyMwMENDRkYnLFxuICAnIzMzMDBDQycsICcjMzMwMEZGJywgJyMzMzMzQ0MnLCAnIzMzMzNGRicsICcjMzM2NkNDJywgJyMzMzY2RkYnLCAnIzMzOTlDQycsXG4gICcjMzM5OUZGJywgJyMzM0NDMDAnLCAnIzMzQ0MzMycsICcjMzNDQzY2JywgJyMzM0NDOTknLCAnIzMzQ0NDQycsICcjMzNDQ0ZGJyxcbiAgJyM2NjAwQ0MnLCAnIzY2MDBGRicsICcjNjYzM0NDJywgJyM2NjMzRkYnLCAnIzY2Q0MwMCcsICcjNjZDQzMzJywgJyM5OTAwQ0MnLFxuICAnIzk5MDBGRicsICcjOTkzM0NDJywgJyM5OTMzRkYnLCAnIzk5Q0MwMCcsICcjOTlDQzMzJywgJyNDQzAwMDAnLCAnI0NDMDAzMycsXG4gICcjQ0MwMDY2JywgJyNDQzAwOTknLCAnI0NDMDBDQycsICcjQ0MwMEZGJywgJyNDQzMzMDAnLCAnI0NDMzMzMycsICcjQ0MzMzY2JyxcbiAgJyNDQzMzOTknLCAnI0NDMzNDQycsICcjQ0MzM0ZGJywgJyNDQzY2MDAnLCAnI0NDNjYzMycsICcjQ0M5OTAwJywgJyNDQzk5MzMnLFxuICAnI0NDQ0MwMCcsICcjQ0NDQzMzJywgJyNGRjAwMDAnLCAnI0ZGMDAzMycsICcjRkYwMDY2JywgJyNGRjAwOTknLCAnI0ZGMDBDQycsXG4gICcjRkYwMEZGJywgJyNGRjMzMDAnLCAnI0ZGMzMzMycsICcjRkYzMzY2JywgJyNGRjMzOTknLCAnI0ZGMzNDQycsICcjRkYzM0ZGJyxcbiAgJyNGRjY2MDAnLCAnI0ZGNjYzMycsICcjRkY5OTAwJywgJyNGRjk5MzMnLCAnI0ZGQ0MwMCcsICcjRkZDQzMzJ1xuXTtcblxuLyoqXG4gKiBDdXJyZW50bHkgb25seSBXZWJLaXQtYmFzZWQgV2ViIEluc3BlY3RvcnMsIEZpcmVmb3ggPj0gdjMxLFxuICogYW5kIHRoZSBGaXJlYnVnIGV4dGVuc2lvbiAoYW55IEZpcmVmb3ggdmVyc2lvbikgYXJlIGtub3duXG4gKiB0byBzdXBwb3J0IFwiJWNcIiBDU1MgY3VzdG9taXphdGlvbnMuXG4gKlxuICogVE9ETzogYWRkIGEgYGxvY2FsU3RvcmFnZWAgdmFyaWFibGUgdG8gZXhwbGljaXRseSBlbmFibGUvZGlzYWJsZSBjb2xvcnNcbiAqL1xuXG5mdW5jdGlvbiB1c2VDb2xvcnMoKSB7XG4gIC8vIE5COiBJbiBhbiBFbGVjdHJvbiBwcmVsb2FkIHNjcmlwdCwgZG9jdW1lbnQgd2lsbCBiZSBkZWZpbmVkIGJ1dCBub3QgZnVsbHlcbiAgLy8gaW5pdGlhbGl6ZWQuIFNpbmNlIHdlIGtub3cgd2UncmUgaW4gQ2hyb21lLCB3ZSdsbCBqdXN0IGRldGVjdCB0aGlzIGNhc2VcbiAgLy8gZXhwbGljaXRseVxuICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgd2luZG93LnByb2Nlc3MgJiYgd2luZG93LnByb2Nlc3MudHlwZSA9PT0gJ3JlbmRlcmVyJykge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgLy8gSW50ZXJuZXQgRXhwbG9yZXIgYW5kIEVkZ2UgZG8gbm90IHN1cHBvcnQgY29sb3JzLlxuICBpZiAodHlwZW9mIG5hdmlnYXRvciAhPT0gJ3VuZGVmaW5lZCcgJiYgbmF2aWdhdG9yLnVzZXJBZ2VudCAmJiBuYXZpZ2F0b3IudXNlckFnZW50LnRvTG93ZXJDYXNlKCkubWF0Y2goLyhlZGdlfHRyaWRlbnQpXFwvKFxcZCspLykpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICAvLyBpcyB3ZWJraXQ/IGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9hLzE2NDU5NjA2LzM3Njc3M1xuICAvLyBkb2N1bWVudCBpcyB1bmRlZmluZWQgaW4gcmVhY3QtbmF0aXZlOiBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QtbmF0aXZlL3B1bGwvMTYzMlxuICByZXR1cm4gKHR5cGVvZiBkb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCcgJiYgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50ICYmIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zdHlsZSAmJiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc3R5bGUuV2Via2l0QXBwZWFyYW5jZSkgfHxcbiAgICAvLyBpcyBmaXJlYnVnPyBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8zOTgxMjAvMzc2NzczXG4gICAgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHdpbmRvdy5jb25zb2xlICYmICh3aW5kb3cuY29uc29sZS5maXJlYnVnIHx8ICh3aW5kb3cuY29uc29sZS5leGNlcHRpb24gJiYgd2luZG93LmNvbnNvbGUudGFibGUpKSkgfHxcbiAgICAvLyBpcyBmaXJlZm94ID49IHYzMT9cbiAgICAvLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1Rvb2xzL1dlYl9Db25zb2xlI1N0eWxpbmdfbWVzc2FnZXNcbiAgICAodHlwZW9mIG5hdmlnYXRvciAhPT0gJ3VuZGVmaW5lZCcgJiYgbmF2aWdhdG9yLnVzZXJBZ2VudCAmJiBuYXZpZ2F0b3IudXNlckFnZW50LnRvTG93ZXJDYXNlKCkubWF0Y2goL2ZpcmVmb3hcXC8oXFxkKykvKSAmJiBwYXJzZUludChSZWdFeHAuJDEsIDEwKSA+PSAzMSkgfHxcbiAgICAvLyBkb3VibGUgY2hlY2sgd2Via2l0IGluIHVzZXJBZ2VudCBqdXN0IGluIGNhc2Ugd2UgYXJlIGluIGEgd29ya2VyXG4gICAgKHR5cGVvZiBuYXZpZ2F0b3IgIT09ICd1bmRlZmluZWQnICYmIG5hdmlnYXRvci51c2VyQWdlbnQgJiYgbmF2aWdhdG9yLnVzZXJBZ2VudC50b0xvd2VyQ2FzZSgpLm1hdGNoKC9hcHBsZXdlYmtpdFxcLyhcXGQrKS8pKTtcbn1cblxuLyoqXG4gKiBNYXAgJWogdG8gYEpTT04uc3RyaW5naWZ5KClgLCBzaW5jZSBubyBXZWIgSW5zcGVjdG9ycyBkbyB0aGF0IGJ5IGRlZmF1bHQuXG4gKi9cblxuZXhwb3J0cy5mb3JtYXR0ZXJzLmogPSBmdW5jdGlvbih2KSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHYpO1xuICB9IGNhdGNoIChlcnIpIHtcbiAgICByZXR1cm4gJ1tVbmV4cGVjdGVkSlNPTlBhcnNlRXJyb3JdOiAnICsgZXJyLm1lc3NhZ2U7XG4gIH1cbn07XG5cblxuLyoqXG4gKiBDb2xvcml6ZSBsb2cgYXJndW1lbnRzIGlmIGVuYWJsZWQuXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBmb3JtYXRBcmdzKGFyZ3MpIHtcbiAgdmFyIHVzZUNvbG9ycyA9IHRoaXMudXNlQ29sb3JzO1xuXG4gIGFyZ3NbMF0gPSAodXNlQ29sb3JzID8gJyVjJyA6ICcnKVxuICAgICsgdGhpcy5uYW1lc3BhY2VcbiAgICArICh1c2VDb2xvcnMgPyAnICVjJyA6ICcgJylcbiAgICArIGFyZ3NbMF1cbiAgICArICh1c2VDb2xvcnMgPyAnJWMgJyA6ICcgJylcbiAgICArICcrJyArIGV4cG9ydHMuaHVtYW5pemUodGhpcy5kaWZmKTtcblxuICBpZiAoIXVzZUNvbG9ycykgcmV0dXJuO1xuXG4gIHZhciBjID0gJ2NvbG9yOiAnICsgdGhpcy5jb2xvcjtcbiAgYXJncy5zcGxpY2UoMSwgMCwgYywgJ2NvbG9yOiBpbmhlcml0JylcblxuICAvLyB0aGUgZmluYWwgXCIlY1wiIGlzIHNvbWV3aGF0IHRyaWNreSwgYmVjYXVzZSB0aGVyZSBjb3VsZCBiZSBvdGhlclxuICAvLyBhcmd1bWVudHMgcGFzc2VkIGVpdGhlciBiZWZvcmUgb3IgYWZ0ZXIgdGhlICVjLCBzbyB3ZSBuZWVkIHRvXG4gIC8vIGZpZ3VyZSBvdXQgdGhlIGNvcnJlY3QgaW5kZXggdG8gaW5zZXJ0IHRoZSBDU1MgaW50b1xuICB2YXIgaW5kZXggPSAwO1xuICB2YXIgbGFzdEMgPSAwO1xuICBhcmdzWzBdLnJlcGxhY2UoLyVbYS16QS1aJV0vZywgZnVuY3Rpb24obWF0Y2gpIHtcbiAgICBpZiAoJyUlJyA9PT0gbWF0Y2gpIHJldHVybjtcbiAgICBpbmRleCsrO1xuICAgIGlmICgnJWMnID09PSBtYXRjaCkge1xuICAgICAgLy8gd2Ugb25seSBhcmUgaW50ZXJlc3RlZCBpbiB0aGUgKmxhc3QqICVjXG4gICAgICAvLyAodGhlIHVzZXIgbWF5IGhhdmUgcHJvdmlkZWQgdGhlaXIgb3duKVxuICAgICAgbGFzdEMgPSBpbmRleDtcbiAgICB9XG4gIH0pO1xuXG4gIGFyZ3Muc3BsaWNlKGxhc3RDLCAwLCBjKTtcbn1cblxuLyoqXG4gKiBJbnZva2VzIGBjb25zb2xlLmxvZygpYCB3aGVuIGF2YWlsYWJsZS5cbiAqIE5vLW9wIHdoZW4gYGNvbnNvbGUubG9nYCBpcyBub3QgYSBcImZ1bmN0aW9uXCIuXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBsb2coKSB7XG4gIC8vIHRoaXMgaGFja2VyeSBpcyByZXF1aXJlZCBmb3IgSUU4LzksIHdoZXJlXG4gIC8vIHRoZSBgY29uc29sZS5sb2dgIGZ1bmN0aW9uIGRvZXNuJ3QgaGF2ZSAnYXBwbHknXG4gIHJldHVybiAnb2JqZWN0JyA9PT0gdHlwZW9mIGNvbnNvbGVcbiAgICAmJiBjb25zb2xlLmxvZ1xuICAgICYmIEZ1bmN0aW9uLnByb3RvdHlwZS5hcHBseS5jYWxsKGNvbnNvbGUubG9nLCBjb25zb2xlLCBhcmd1bWVudHMpO1xufVxuXG4vKipcbiAqIFNhdmUgYG5hbWVzcGFjZXNgLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lc3BhY2VzXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBzYXZlKG5hbWVzcGFjZXMpIHtcbiAgdHJ5IHtcbiAgICBpZiAobnVsbCA9PSBuYW1lc3BhY2VzKSB7XG4gICAgICBleHBvcnRzLnN0b3JhZ2UucmVtb3ZlSXRlbSgnZGVidWcnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZXhwb3J0cy5zdG9yYWdlLmRlYnVnID0gbmFtZXNwYWNlcztcbiAgICB9XG4gIH0gY2F0Y2goZSkge31cbn1cblxuLyoqXG4gKiBMb2FkIGBuYW1lc3BhY2VzYC5cbiAqXG4gKiBAcmV0dXJuIHtTdHJpbmd9IHJldHVybnMgdGhlIHByZXZpb3VzbHkgcGVyc2lzdGVkIGRlYnVnIG1vZGVzXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBsb2FkKCkge1xuICB2YXIgcjtcbiAgdHJ5IHtcbiAgICByID0gZXhwb3J0cy5zdG9yYWdlLmRlYnVnO1xuICB9IGNhdGNoKGUpIHt9XG5cbiAgLy8gSWYgZGVidWcgaXNuJ3Qgc2V0IGluIExTLCBhbmQgd2UncmUgaW4gRWxlY3Ryb24sIHRyeSB0byBsb2FkICRERUJVR1xuICBpZiAoIXIgJiYgdHlwZW9mIHByb2Nlc3MgIT09ICd1bmRlZmluZWQnICYmICdlbnYnIGluIHByb2Nlc3MpIHtcbiAgICByID0gcHJvY2Vzcy5lbnYuREVCVUc7XG4gIH1cblxuICByZXR1cm4gcjtcbn1cblxuLyoqXG4gKiBFbmFibGUgbmFtZXNwYWNlcyBsaXN0ZWQgaW4gYGxvY2FsU3RvcmFnZS5kZWJ1Z2AgaW5pdGlhbGx5LlxuICovXG5cbmV4cG9ydHMuZW5hYmxlKGxvYWQoKSk7XG5cbi8qKlxuICogTG9jYWxzdG9yYWdlIGF0dGVtcHRzIHRvIHJldHVybiB0aGUgbG9jYWxzdG9yYWdlLlxuICpcbiAqIFRoaXMgaXMgbmVjZXNzYXJ5IGJlY2F1c2Ugc2FmYXJpIHRocm93c1xuICogd2hlbiBhIHVzZXIgZGlzYWJsZXMgY29va2llcy9sb2NhbHN0b3JhZ2VcbiAqIGFuZCB5b3UgYXR0ZW1wdCB0byBhY2Nlc3MgaXQuXG4gKlxuICogQHJldHVybiB7TG9jYWxTdG9yYWdlfVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gbG9jYWxzdG9yYWdlKCkge1xuICB0cnkge1xuICAgIHJldHVybiB3aW5kb3cubG9jYWxTdG9yYWdlO1xuICB9IGNhdGNoIChlKSB7fVxufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2VsZWN0cm9uLXVwZGF0ZXIvbm9kZV9tb2R1bGVzL2RlYnVnL3NyYy9icm93c2VyLmpzIiwiLyoqXG4gKiBIZWxwZXJzLlxuICovXG5cbnZhciBzID0gMTAwMDtcbnZhciBtID0gcyAqIDYwO1xudmFyIGggPSBtICogNjA7XG52YXIgZCA9IGggKiAyNDtcbnZhciB5ID0gZCAqIDM2NS4yNTtcblxuLyoqXG4gKiBQYXJzZSBvciBmb3JtYXQgdGhlIGdpdmVuIGB2YWxgLlxuICpcbiAqIE9wdGlvbnM6XG4gKlxuICogIC0gYGxvbmdgIHZlcmJvc2UgZm9ybWF0dGluZyBbZmFsc2VdXG4gKlxuICogQHBhcmFtIHtTdHJpbmd8TnVtYmVyfSB2YWxcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cbiAqIEB0aHJvd3Mge0Vycm9yfSB0aHJvdyBhbiBlcnJvciBpZiB2YWwgaXMgbm90IGEgbm9uLWVtcHR5IHN0cmluZyBvciBhIG51bWJlclxuICogQHJldHVybiB7U3RyaW5nfE51bWJlcn1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbih2YWwsIG9wdGlvbnMpIHtcbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gIHZhciB0eXBlID0gdHlwZW9mIHZhbDtcbiAgaWYgKHR5cGUgPT09ICdzdHJpbmcnICYmIHZhbC5sZW5ndGggPiAwKSB7XG4gICAgcmV0dXJuIHBhcnNlKHZhbCk7XG4gIH0gZWxzZSBpZiAodHlwZSA9PT0gJ251bWJlcicgJiYgaXNOYU4odmFsKSA9PT0gZmFsc2UpIHtcbiAgICByZXR1cm4gb3B0aW9ucy5sb25nID8gZm10TG9uZyh2YWwpIDogZm10U2hvcnQodmFsKTtcbiAgfVxuICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgJ3ZhbCBpcyBub3QgYSBub24tZW1wdHkgc3RyaW5nIG9yIGEgdmFsaWQgbnVtYmVyLiB2YWw9JyArXG4gICAgICBKU09OLnN0cmluZ2lmeSh2YWwpXG4gICk7XG59O1xuXG4vKipcbiAqIFBhcnNlIHRoZSBnaXZlbiBgc3RyYCBhbmQgcmV0dXJuIG1pbGxpc2Vjb25kcy5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyXG4gKiBAcmV0dXJuIHtOdW1iZXJ9XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBwYXJzZShzdHIpIHtcbiAgc3RyID0gU3RyaW5nKHN0cik7XG4gIGlmIChzdHIubGVuZ3RoID4gMTAwKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHZhciBtYXRjaCA9IC9eKCg/OlxcZCspP1xcLj9cXGQrKSAqKG1pbGxpc2Vjb25kcz98bXNlY3M/fG1zfHNlY29uZHM/fHNlY3M/fHN8bWludXRlcz98bWlucz98bXxob3Vycz98aHJzP3xofGRheXM/fGR8eWVhcnM/fHlycz98eSk/JC9pLmV4ZWMoXG4gICAgc3RyXG4gICk7XG4gIGlmICghbWF0Y2gpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgdmFyIG4gPSBwYXJzZUZsb2F0KG1hdGNoWzFdKTtcbiAgdmFyIHR5cGUgPSAobWF0Y2hbMl0gfHwgJ21zJykudG9Mb3dlckNhc2UoKTtcbiAgc3dpdGNoICh0eXBlKSB7XG4gICAgY2FzZSAneWVhcnMnOlxuICAgIGNhc2UgJ3llYXInOlxuICAgIGNhc2UgJ3lycyc6XG4gICAgY2FzZSAneXInOlxuICAgIGNhc2UgJ3knOlxuICAgICAgcmV0dXJuIG4gKiB5O1xuICAgIGNhc2UgJ2RheXMnOlxuICAgIGNhc2UgJ2RheSc6XG4gICAgY2FzZSAnZCc6XG4gICAgICByZXR1cm4gbiAqIGQ7XG4gICAgY2FzZSAnaG91cnMnOlxuICAgIGNhc2UgJ2hvdXInOlxuICAgIGNhc2UgJ2hycyc6XG4gICAgY2FzZSAnaHInOlxuICAgIGNhc2UgJ2gnOlxuICAgICAgcmV0dXJuIG4gKiBoO1xuICAgIGNhc2UgJ21pbnV0ZXMnOlxuICAgIGNhc2UgJ21pbnV0ZSc6XG4gICAgY2FzZSAnbWlucyc6XG4gICAgY2FzZSAnbWluJzpcbiAgICBjYXNlICdtJzpcbiAgICAgIHJldHVybiBuICogbTtcbiAgICBjYXNlICdzZWNvbmRzJzpcbiAgICBjYXNlICdzZWNvbmQnOlxuICAgIGNhc2UgJ3NlY3MnOlxuICAgIGNhc2UgJ3NlYyc6XG4gICAgY2FzZSAncyc6XG4gICAgICByZXR1cm4gbiAqIHM7XG4gICAgY2FzZSAnbWlsbGlzZWNvbmRzJzpcbiAgICBjYXNlICdtaWxsaXNlY29uZCc6XG4gICAgY2FzZSAnbXNlY3MnOlxuICAgIGNhc2UgJ21zZWMnOlxuICAgIGNhc2UgJ21zJzpcbiAgICAgIHJldHVybiBuO1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG59XG5cbi8qKlxuICogU2hvcnQgZm9ybWF0IGZvciBgbXNgLlxuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSBtc1xuICogQHJldHVybiB7U3RyaW5nfVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gZm10U2hvcnQobXMpIHtcbiAgaWYgKG1zID49IGQpIHtcbiAgICByZXR1cm4gTWF0aC5yb3VuZChtcyAvIGQpICsgJ2QnO1xuICB9XG4gIGlmIChtcyA+PSBoKSB7XG4gICAgcmV0dXJuIE1hdGgucm91bmQobXMgLyBoKSArICdoJztcbiAgfVxuICBpZiAobXMgPj0gbSkge1xuICAgIHJldHVybiBNYXRoLnJvdW5kKG1zIC8gbSkgKyAnbSc7XG4gIH1cbiAgaWYgKG1zID49IHMpIHtcbiAgICByZXR1cm4gTWF0aC5yb3VuZChtcyAvIHMpICsgJ3MnO1xuICB9XG4gIHJldHVybiBtcyArICdtcyc7XG59XG5cbi8qKlxuICogTG9uZyBmb3JtYXQgZm9yIGBtc2AuXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IG1zXG4gKiBAcmV0dXJuIHtTdHJpbmd9XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBmbXRMb25nKG1zKSB7XG4gIHJldHVybiBwbHVyYWwobXMsIGQsICdkYXknKSB8fFxuICAgIHBsdXJhbChtcywgaCwgJ2hvdXInKSB8fFxuICAgIHBsdXJhbChtcywgbSwgJ21pbnV0ZScpIHx8XG4gICAgcGx1cmFsKG1zLCBzLCAnc2Vjb25kJykgfHxcbiAgICBtcyArICcgbXMnO1xufVxuXG4vKipcbiAqIFBsdXJhbGl6YXRpb24gaGVscGVyLlxuICovXG5cbmZ1bmN0aW9uIHBsdXJhbChtcywgbiwgbmFtZSkge1xuICBpZiAobXMgPCBuKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGlmIChtcyA8IG4gKiAxLjUpIHtcbiAgICByZXR1cm4gTWF0aC5mbG9vcihtcyAvIG4pICsgJyAnICsgbmFtZTtcbiAgfVxuICByZXR1cm4gTWF0aC5jZWlsKG1zIC8gbikgKyAnICcgKyBuYW1lICsgJ3MnO1xufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL21zL2luZGV4LmpzIiwiLyoqXG4gKiBNb2R1bGUgZGVwZW5kZW5jaWVzLlxuICovXG5cbnZhciB0dHkgPSByZXF1aXJlKCd0dHknKTtcbnZhciB1dGlsID0gcmVxdWlyZSgndXRpbCcpO1xuXG4vKipcbiAqIFRoaXMgaXMgdGhlIE5vZGUuanMgaW1wbGVtZW50YXRpb24gb2YgYGRlYnVnKClgLlxuICpcbiAqIEV4cG9zZSBgZGVidWcoKWAgYXMgdGhlIG1vZHVsZS5cbiAqL1xuXG5leHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2RlYnVnJyk7XG5leHBvcnRzLmluaXQgPSBpbml0O1xuZXhwb3J0cy5sb2cgPSBsb2c7XG5leHBvcnRzLmZvcm1hdEFyZ3MgPSBmb3JtYXRBcmdzO1xuZXhwb3J0cy5zYXZlID0gc2F2ZTtcbmV4cG9ydHMubG9hZCA9IGxvYWQ7XG5leHBvcnRzLnVzZUNvbG9ycyA9IHVzZUNvbG9ycztcblxuLyoqXG4gKiBDb2xvcnMuXG4gKi9cblxuZXhwb3J0cy5jb2xvcnMgPSBbIDYsIDIsIDMsIDQsIDUsIDEgXTtcblxudHJ5IHtcbiAgdmFyIHN1cHBvcnRzQ29sb3IgPSByZXF1aXJlKCdzdXBwb3J0cy1jb2xvcicpO1xuICBpZiAoc3VwcG9ydHNDb2xvciAmJiBzdXBwb3J0c0NvbG9yLmxldmVsID49IDIpIHtcbiAgICBleHBvcnRzLmNvbG9ycyA9IFtcbiAgICAgIDIwLCAyMSwgMjYsIDI3LCAzMiwgMzMsIDM4LCAzOSwgNDAsIDQxLCA0MiwgNDMsIDQ0LCA0NSwgNTYsIDU3LCA2MiwgNjMsIDY4LFxuICAgICAgNjksIDc0LCA3NSwgNzYsIDc3LCA3OCwgNzksIDgwLCA4MSwgOTIsIDkzLCA5OCwgOTksIDExMiwgMTEzLCAxMjgsIDEyOSwgMTM0LFxuICAgICAgMTM1LCAxNDgsIDE0OSwgMTYwLCAxNjEsIDE2MiwgMTYzLCAxNjQsIDE2NSwgMTY2LCAxNjcsIDE2OCwgMTY5LCAxNzAsIDE3MSxcbiAgICAgIDE3MiwgMTczLCAxNzgsIDE3OSwgMTg0LCAxODUsIDE5NiwgMTk3LCAxOTgsIDE5OSwgMjAwLCAyMDEsIDIwMiwgMjAzLCAyMDQsXG4gICAgICAyMDUsIDIwNiwgMjA3LCAyMDgsIDIwOSwgMjE0LCAyMTUsIDIyMCwgMjIxXG4gICAgXTtcbiAgfVxufSBjYXRjaCAoZXJyKSB7XG4gIC8vIHN3YWxsb3cgLSB3ZSBvbmx5IGNhcmUgaWYgYHN1cHBvcnRzLWNvbG9yYCBpcyBhdmFpbGFibGU7IGl0IGRvZXNuJ3QgaGF2ZSB0byBiZS5cbn1cblxuLyoqXG4gKiBCdWlsZCB1cCB0aGUgZGVmYXVsdCBgaW5zcGVjdE9wdHNgIG9iamVjdCBmcm9tIHRoZSBlbnZpcm9ubWVudCB2YXJpYWJsZXMuXG4gKlxuICogICAkIERFQlVHX0NPTE9SUz1ubyBERUJVR19ERVBUSD0xMCBERUJVR19TSE9XX0hJRERFTj1lbmFibGVkIG5vZGUgc2NyaXB0LmpzXG4gKi9cblxuZXhwb3J0cy5pbnNwZWN0T3B0cyA9IE9iamVjdC5rZXlzKHByb2Nlc3MuZW52KS5maWx0ZXIoZnVuY3Rpb24gKGtleSkge1xuICByZXR1cm4gL15kZWJ1Z18vaS50ZXN0KGtleSk7XG59KS5yZWR1Y2UoZnVuY3Rpb24gKG9iaiwga2V5KSB7XG4gIC8vIGNhbWVsLWNhc2VcbiAgdmFyIHByb3AgPSBrZXlcbiAgICAuc3Vic3RyaW5nKDYpXG4gICAgLnRvTG93ZXJDYXNlKClcbiAgICAucmVwbGFjZSgvXyhbYS16XSkvZywgZnVuY3Rpb24gKF8sIGspIHsgcmV0dXJuIGsudG9VcHBlckNhc2UoKSB9KTtcblxuICAvLyBjb2VyY2Ugc3RyaW5nIHZhbHVlIGludG8gSlMgdmFsdWVcbiAgdmFyIHZhbCA9IHByb2Nlc3MuZW52W2tleV07XG4gIGlmICgvXih5ZXN8b258dHJ1ZXxlbmFibGVkKSQvaS50ZXN0KHZhbCkpIHZhbCA9IHRydWU7XG4gIGVsc2UgaWYgKC9eKG5vfG9mZnxmYWxzZXxkaXNhYmxlZCkkL2kudGVzdCh2YWwpKSB2YWwgPSBmYWxzZTtcbiAgZWxzZSBpZiAodmFsID09PSAnbnVsbCcpIHZhbCA9IG51bGw7XG4gIGVsc2UgdmFsID0gTnVtYmVyKHZhbCk7XG5cbiAgb2JqW3Byb3BdID0gdmFsO1xuICByZXR1cm4gb2JqO1xufSwge30pO1xuXG4vKipcbiAqIElzIHN0ZG91dCBhIFRUWT8gQ29sb3JlZCBvdXRwdXQgaXMgZW5hYmxlZCB3aGVuIGB0cnVlYC5cbiAqL1xuXG5mdW5jdGlvbiB1c2VDb2xvcnMoKSB7XG4gIHJldHVybiAnY29sb3JzJyBpbiBleHBvcnRzLmluc3BlY3RPcHRzXG4gICAgPyBCb29sZWFuKGV4cG9ydHMuaW5zcGVjdE9wdHMuY29sb3JzKVxuICAgIDogdHR5LmlzYXR0eShwcm9jZXNzLnN0ZGVyci5mZCk7XG59XG5cbi8qKlxuICogTWFwICVvIHRvIGB1dGlsLmluc3BlY3QoKWAsIGFsbCBvbiBhIHNpbmdsZSBsaW5lLlxuICovXG5cbmV4cG9ydHMuZm9ybWF0dGVycy5vID0gZnVuY3Rpb24odikge1xuICB0aGlzLmluc3BlY3RPcHRzLmNvbG9ycyA9IHRoaXMudXNlQ29sb3JzO1xuICByZXR1cm4gdXRpbC5pbnNwZWN0KHYsIHRoaXMuaW5zcGVjdE9wdHMpXG4gICAgLnNwbGl0KCdcXG4nKS5tYXAoZnVuY3Rpb24oc3RyKSB7XG4gICAgICByZXR1cm4gc3RyLnRyaW0oKVxuICAgIH0pLmpvaW4oJyAnKTtcbn07XG5cbi8qKlxuICogTWFwICVvIHRvIGB1dGlsLmluc3BlY3QoKWAsIGFsbG93aW5nIG11bHRpcGxlIGxpbmVzIGlmIG5lZWRlZC5cbiAqL1xuXG5leHBvcnRzLmZvcm1hdHRlcnMuTyA9IGZ1bmN0aW9uKHYpIHtcbiAgdGhpcy5pbnNwZWN0T3B0cy5jb2xvcnMgPSB0aGlzLnVzZUNvbG9ycztcbiAgcmV0dXJuIHV0aWwuaW5zcGVjdCh2LCB0aGlzLmluc3BlY3RPcHRzKTtcbn07XG5cbi8qKlxuICogQWRkcyBBTlNJIGNvbG9yIGVzY2FwZSBjb2RlcyBpZiBlbmFibGVkLlxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gZm9ybWF0QXJncyhhcmdzKSB7XG4gIHZhciBuYW1lID0gdGhpcy5uYW1lc3BhY2U7XG4gIHZhciB1c2VDb2xvcnMgPSB0aGlzLnVzZUNvbG9ycztcblxuICBpZiAodXNlQ29sb3JzKSB7XG4gICAgdmFyIGMgPSB0aGlzLmNvbG9yO1xuICAgIHZhciBjb2xvckNvZGUgPSAnXFx1MDAxYlszJyArIChjIDwgOCA/IGMgOiAnODs1OycgKyBjKTtcbiAgICB2YXIgcHJlZml4ID0gJyAgJyArIGNvbG9yQ29kZSArICc7MW0nICsgbmFtZSArICcgJyArICdcXHUwMDFiWzBtJztcblxuICAgIGFyZ3NbMF0gPSBwcmVmaXggKyBhcmdzWzBdLnNwbGl0KCdcXG4nKS5qb2luKCdcXG4nICsgcHJlZml4KTtcbiAgICBhcmdzLnB1c2goY29sb3JDb2RlICsgJ20rJyArIGV4cG9ydHMuaHVtYW5pemUodGhpcy5kaWZmKSArICdcXHUwMDFiWzBtJyk7XG4gIH0gZWxzZSB7XG4gICAgYXJnc1swXSA9IGdldERhdGUoKSArIG5hbWUgKyAnICcgKyBhcmdzWzBdO1xuICB9XG59XG5cbmZ1bmN0aW9uIGdldERhdGUoKSB7XG4gIGlmIChleHBvcnRzLmluc3BlY3RPcHRzLmhpZGVEYXRlKSB7XG4gICAgcmV0dXJuICcnO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCkgKyAnICc7XG4gIH1cbn1cblxuLyoqXG4gKiBJbnZva2VzIGB1dGlsLmZvcm1hdCgpYCB3aXRoIHRoZSBzcGVjaWZpZWQgYXJndW1lbnRzIGFuZCB3cml0ZXMgdG8gc3RkZXJyLlxuICovXG5cbmZ1bmN0aW9uIGxvZygpIHtcbiAgcmV0dXJuIHByb2Nlc3Muc3RkZXJyLndyaXRlKHV0aWwuZm9ybWF0LmFwcGx5KHV0aWwsIGFyZ3VtZW50cykgKyAnXFxuJyk7XG59XG5cbi8qKlxuICogU2F2ZSBgbmFtZXNwYWNlc2AuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IG5hbWVzcGFjZXNcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIHNhdmUobmFtZXNwYWNlcykge1xuICBpZiAobnVsbCA9PSBuYW1lc3BhY2VzKSB7XG4gICAgLy8gSWYgeW91IHNldCBhIHByb2Nlc3MuZW52IGZpZWxkIHRvIG51bGwgb3IgdW5kZWZpbmVkLCBpdCBnZXRzIGNhc3QgdG8gdGhlXG4gICAgLy8gc3RyaW5nICdudWxsJyBvciAndW5kZWZpbmVkJy4gSnVzdCBkZWxldGUgaW5zdGVhZC5cbiAgICBkZWxldGUgcHJvY2Vzcy5lbnYuREVCVUc7XG4gIH0gZWxzZSB7XG4gICAgcHJvY2Vzcy5lbnYuREVCVUcgPSBuYW1lc3BhY2VzO1xuICB9XG59XG5cbi8qKlxuICogTG9hZCBgbmFtZXNwYWNlc2AuXG4gKlxuICogQHJldHVybiB7U3RyaW5nfSByZXR1cm5zIHRoZSBwcmV2aW91c2x5IHBlcnNpc3RlZCBkZWJ1ZyBtb2Rlc1xuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gbG9hZCgpIHtcbiAgcmV0dXJuIHByb2Nlc3MuZW52LkRFQlVHO1xufVxuXG4vKipcbiAqIEluaXQgbG9naWMgZm9yIGBkZWJ1Z2AgaW5zdGFuY2VzLlxuICpcbiAqIENyZWF0ZSBhIG5ldyBgaW5zcGVjdE9wdHNgIG9iamVjdCBpbiBjYXNlIGB1c2VDb2xvcnNgIGlzIHNldFxuICogZGlmZmVyZW50bHkgZm9yIGEgcGFydGljdWxhciBgZGVidWdgIGluc3RhbmNlLlxuICovXG5cbmZ1bmN0aW9uIGluaXQgKGRlYnVnKSB7XG4gIGRlYnVnLmluc3BlY3RPcHRzID0ge307XG5cbiAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhleHBvcnRzLmluc3BlY3RPcHRzKTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgZGVidWcuaW5zcGVjdE9wdHNba2V5c1tpXV0gPSBleHBvcnRzLmluc3BlY3RPcHRzW2tleXNbaV1dO1xuICB9XG59XG5cbi8qKlxuICogRW5hYmxlIG5hbWVzcGFjZXMgbGlzdGVkIGluIGBwcm9jZXNzLmVudi5ERUJVR2AgaW5pdGlhbGx5LlxuICovXG5cbmV4cG9ydHMuZW5hYmxlKGxvYWQoKSk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvZWxlY3Ryb24tdXBkYXRlci9ub2RlX21vZHVsZXMvZGVidWcvc3JjL25vZGUuanMiLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCJ0dHlcIik7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gZXh0ZXJuYWwgXCJ0dHlcIlxuLy8gbW9kdWxlIGlkID0gMTA0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIid1c2Ugc3RyaWN0JztcbmNvbnN0IG9zID0gcmVxdWlyZSgnb3MnKTtcbmNvbnN0IGhhc0ZsYWcgPSByZXF1aXJlKCdoYXMtZmxhZycpO1xuXG5jb25zdCBlbnYgPSBwcm9jZXNzLmVudjtcblxuY29uc3Qgc3VwcG9ydCA9IGxldmVsID0+IHtcblx0aWYgKGxldmVsID09PSAwKSB7XG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9XG5cblx0cmV0dXJuIHtcblx0XHRsZXZlbCxcblx0XHRoYXNCYXNpYzogdHJ1ZSxcblx0XHRoYXMyNTY6IGxldmVsID49IDIsXG5cdFx0aGFzMTZtOiBsZXZlbCA+PSAzXG5cdH07XG59O1xuXG5sZXQgc3VwcG9ydExldmVsID0gKCgpID0+IHtcblx0aWYgKGhhc0ZsYWcoJ25vLWNvbG9yJykgfHxcblx0XHRoYXNGbGFnKCduby1jb2xvcnMnKSB8fFxuXHRcdGhhc0ZsYWcoJ2NvbG9yPWZhbHNlJykpIHtcblx0XHRyZXR1cm4gMDtcblx0fVxuXG5cdGlmIChoYXNGbGFnKCdjb2xvcj0xNm0nKSB8fFxuXHRcdGhhc0ZsYWcoJ2NvbG9yPWZ1bGwnKSB8fFxuXHRcdGhhc0ZsYWcoJ2NvbG9yPXRydWVjb2xvcicpKSB7XG5cdFx0cmV0dXJuIDM7XG5cdH1cblxuXHRpZiAoaGFzRmxhZygnY29sb3I9MjU2JykpIHtcblx0XHRyZXR1cm4gMjtcblx0fVxuXG5cdGlmIChoYXNGbGFnKCdjb2xvcicpIHx8XG5cdFx0aGFzRmxhZygnY29sb3JzJykgfHxcblx0XHRoYXNGbGFnKCdjb2xvcj10cnVlJykgfHxcblx0XHRoYXNGbGFnKCdjb2xvcj1hbHdheXMnKSkge1xuXHRcdHJldHVybiAxO1xuXHR9XG5cblx0aWYgKHByb2Nlc3Muc3Rkb3V0ICYmICFwcm9jZXNzLnN0ZG91dC5pc1RUWSkge1xuXHRcdHJldHVybiAwO1xuXHR9XG5cblx0aWYgKHByb2Nlc3MucGxhdGZvcm0gPT09ICd3aW4zMicpIHtcblx0XHQvLyBOb2RlLmpzIDcuNS4wIGlzIHRoZSBmaXJzdCB2ZXJzaW9uIG9mIE5vZGUuanMgdG8gaW5jbHVkZSBhIHBhdGNoIHRvXG5cdFx0Ly8gbGlidXYgdGhhdCBlbmFibGVzIDI1NiBjb2xvciBvdXRwdXQgb24gV2luZG93cy4gQW55dGhpbmcgZWFybGllciBhbmQgaXRcblx0XHQvLyB3b24ndCB3b3JrLiBIb3dldmVyLCBoZXJlIHdlIHRhcmdldCBOb2RlLmpzIDggYXQgbWluaW11bSBhcyBpdCBpcyBhbiBMVFNcblx0XHQvLyByZWxlYXNlLCBhbmQgTm9kZS5qcyA3IGlzIG5vdC4gV2luZG93cyAxMCBidWlsZCAxMDU4NiBpcyB0aGUgZmlyc3QgV2luZG93c1xuXHRcdC8vIHJlbGVhc2UgdGhhdCBzdXBwb3J0cyAyNTYgY29sb3JzLlxuXHRcdGNvbnN0IG9zUmVsZWFzZSA9IG9zLnJlbGVhc2UoKS5zcGxpdCgnLicpO1xuXHRcdGlmIChcblx0XHRcdE51bWJlcihwcm9jZXNzLnZlcnNpb25zLm5vZGUuc3BsaXQoJy4nKVswXSkgPj0gOCAmJlxuXHRcdFx0TnVtYmVyKG9zUmVsZWFzZVswXSkgPj0gMTAgJiZcblx0XHRcdE51bWJlcihvc1JlbGVhc2VbMl0pID49IDEwNTg2XG5cdFx0KSB7XG5cdFx0XHRyZXR1cm4gMjtcblx0XHR9XG5cblx0XHRyZXR1cm4gMTtcblx0fVxuXG5cdGlmICgnQ0knIGluIGVudikge1xuXHRcdGlmIChbJ1RSQVZJUycsICdDSVJDTEVDSScsICdBUFBWRVlPUicsICdHSVRMQUJfQ0knXS5zb21lKHNpZ24gPT4gc2lnbiBpbiBlbnYpIHx8IGVudi5DSV9OQU1FID09PSAnY29kZXNoaXAnKSB7XG5cdFx0XHRyZXR1cm4gMTtcblx0XHR9XG5cblx0XHRyZXR1cm4gMDtcblx0fVxuXG5cdGlmICgnVEVBTUNJVFlfVkVSU0lPTicgaW4gZW52KSB7XG5cdFx0cmV0dXJuIC9eKDlcXC4oMCpbMS05XVxcZCopXFwufFxcZHsyLH1cXC4pLy50ZXN0KGVudi5URUFNQ0lUWV9WRVJTSU9OKSA/IDEgOiAwO1xuXHR9XG5cblx0aWYgKCdURVJNX1BST0dSQU0nIGluIGVudikge1xuXHRcdGNvbnN0IHZlcnNpb24gPSBwYXJzZUludCgoZW52LlRFUk1fUFJPR1JBTV9WRVJTSU9OIHx8ICcnKS5zcGxpdCgnLicpWzBdLCAxMCk7XG5cblx0XHRzd2l0Y2ggKGVudi5URVJNX1BST0dSQU0pIHtcblx0XHRcdGNhc2UgJ2lUZXJtLmFwcCc6XG5cdFx0XHRcdHJldHVybiB2ZXJzaW9uID49IDMgPyAzIDogMjtcblx0XHRcdGNhc2UgJ0h5cGVyJzpcblx0XHRcdFx0cmV0dXJuIDM7XG5cdFx0XHRjYXNlICdBcHBsZV9UZXJtaW5hbCc6XG5cdFx0XHRcdHJldHVybiAyO1xuXHRcdFx0Ly8gTm8gZGVmYXVsdFxuXHRcdH1cblx0fVxuXG5cdGlmICgvLTI1Nihjb2xvcik/JC9pLnRlc3QoZW52LlRFUk0pKSB7XG5cdFx0cmV0dXJuIDI7XG5cdH1cblxuXHRpZiAoL15zY3JlZW58Xnh0ZXJtfF52dDEwMHxecnh2dHxjb2xvcnxhbnNpfGN5Z3dpbnxsaW51eC9pLnRlc3QoZW52LlRFUk0pKSB7XG5cdFx0cmV0dXJuIDE7XG5cdH1cblxuXHRpZiAoJ0NPTE9SVEVSTScgaW4gZW52KSB7XG5cdFx0cmV0dXJuIDE7XG5cdH1cblxuXHRpZiAoZW52LlRFUk0gPT09ICdkdW1iJykge1xuXHRcdHJldHVybiAwO1xuXHR9XG5cblx0cmV0dXJuIDA7XG59KSgpO1xuXG5pZiAoJ0ZPUkNFX0NPTE9SJyBpbiBlbnYpIHtcblx0c3VwcG9ydExldmVsID0gcGFyc2VJbnQoZW52LkZPUkNFX0NPTE9SLCAxMCkgPT09IDAgPyAwIDogKHN1cHBvcnRMZXZlbCB8fCAxKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBwcm9jZXNzICYmIHN1cHBvcnQoc3VwcG9ydExldmVsKTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9zdXBwb3J0cy1jb2xvci9pbmRleC5qcyIsIid1c2Ugc3RyaWN0Jztcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGZsYWcsIGFyZ3YpIHtcblx0YXJndiA9IGFyZ3YgfHwgcHJvY2Vzcy5hcmd2O1xuXG5cdHZhciB0ZXJtaW5hdG9yUG9zID0gYXJndi5pbmRleE9mKCctLScpO1xuXHR2YXIgcHJlZml4ID0gL14tezEsMn0vLnRlc3QoZmxhZykgPyAnJyA6ICctLSc7XG5cdHZhciBwb3MgPSBhcmd2LmluZGV4T2YocHJlZml4ICsgZmxhZyk7XG5cblx0cmV0dXJuIHBvcyAhPT0gLTEgJiYgKHRlcm1pbmF0b3JQb3MgPT09IC0xID8gdHJ1ZSA6IHBvcyA8IHRlcm1pbmF0b3JQb3MpO1xufTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9oYXMtZmxhZy9pbmRleC5qcyIsIid1c2Ugc3RyaWN0J1xuXG5jb25zdCBhc3NpZ24gPSByZXF1aXJlKCcuL3V0aWwvYXNzaWduJylcblxuY29uc3QgZnMgPSB7fVxuXG4vLyBFeHBvcnQgZ3JhY2VmdWwtZnM6XG5hc3NpZ24oZnMsIHJlcXVpcmUoJy4vZnMnKSlcbi8vIEV4cG9ydCBleHRyYSBtZXRob2RzOlxuYXNzaWduKGZzLCByZXF1aXJlKCcuL2NvcHknKSlcbmFzc2lnbihmcywgcmVxdWlyZSgnLi9jb3B5LXN5bmMnKSlcbmFzc2lnbihmcywgcmVxdWlyZSgnLi9ta2RpcnMnKSlcbmFzc2lnbihmcywgcmVxdWlyZSgnLi9yZW1vdmUnKSlcbmFzc2lnbihmcywgcmVxdWlyZSgnLi9qc29uJykpXG5hc3NpZ24oZnMsIHJlcXVpcmUoJy4vbW92ZScpKVxuYXNzaWduKGZzLCByZXF1aXJlKCcuL21vdmUtc3luYycpKVxuYXNzaWduKGZzLCByZXF1aXJlKCcuL2VtcHR5JykpXG5hc3NpZ24oZnMsIHJlcXVpcmUoJy4vZW5zdXJlJykpXG5hc3NpZ24oZnMsIHJlcXVpcmUoJy4vb3V0cHV0JykpXG5hc3NpZ24oZnMsIHJlcXVpcmUoJy4vcGF0aC1leGlzdHMnKSlcblxubW9kdWxlLmV4cG9ydHMgPSBmc1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2VsZWN0cm9uLXVwZGF0ZXIvbm9kZV9tb2R1bGVzL2ZzLWV4dHJhL2xpYi9pbmRleC5qcyIsIid1c2Ugc3RyaWN0J1xuXG4vLyBzaW1wbGUgbXV0YWJsZSBhc3NpZ25cbmZ1bmN0aW9uIGFzc2lnbiAoKSB7XG4gIGNvbnN0IGFyZ3MgPSBbXS5zbGljZS5jYWxsKGFyZ3VtZW50cykuZmlsdGVyKGkgPT4gaSlcbiAgY29uc3QgZGVzdCA9IGFyZ3Muc2hpZnQoKVxuICBhcmdzLmZvckVhY2goc3JjID0+IHtcbiAgICBPYmplY3Qua2V5cyhzcmMpLmZvckVhY2goa2V5ID0+IHtcbiAgICAgIGRlc3Rba2V5XSA9IHNyY1trZXldXG4gICAgfSlcbiAgfSlcblxuICByZXR1cm4gZGVzdFxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGFzc2lnblxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2VsZWN0cm9uLXVwZGF0ZXIvbm9kZV9tb2R1bGVzL2ZzLWV4dHJhL2xpYi91dGlsL2Fzc2lnbi5qcyIsInZhciBmcyA9IHJlcXVpcmUoJy4vZnMuanMnKVxudmFyIGNvbnN0YW50cyA9IHJlcXVpcmUoJ2NvbnN0YW50cycpXG5cbnZhciBvcmlnQ3dkID0gcHJvY2Vzcy5jd2RcbnZhciBjd2QgPSBudWxsXG5cbnZhciBwbGF0Zm9ybSA9IHByb2Nlc3MuZW52LkdSQUNFRlVMX0ZTX1BMQVRGT1JNIHx8IHByb2Nlc3MucGxhdGZvcm1cblxucHJvY2Vzcy5jd2QgPSBmdW5jdGlvbigpIHtcbiAgaWYgKCFjd2QpXG4gICAgY3dkID0gb3JpZ0N3ZC5jYWxsKHByb2Nlc3MpXG4gIHJldHVybiBjd2Rcbn1cbnRyeSB7XG4gIHByb2Nlc3MuY3dkKClcbn0gY2F0Y2ggKGVyKSB7fVxuXG52YXIgY2hkaXIgPSBwcm9jZXNzLmNoZGlyXG5wcm9jZXNzLmNoZGlyID0gZnVuY3Rpb24oZCkge1xuICBjd2QgPSBudWxsXG4gIGNoZGlyLmNhbGwocHJvY2VzcywgZClcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBwYXRjaFxuXG5mdW5jdGlvbiBwYXRjaCAoZnMpIHtcbiAgLy8gKHJlLSlpbXBsZW1lbnQgc29tZSB0aGluZ3MgdGhhdCBhcmUga25vd24gYnVzdGVkIG9yIG1pc3NpbmcuXG5cbiAgLy8gbGNobW9kLCBicm9rZW4gcHJpb3IgdG8gMC42LjJcbiAgLy8gYmFjay1wb3J0IHRoZSBmaXggaGVyZS5cbiAgaWYgKGNvbnN0YW50cy5oYXNPd25Qcm9wZXJ0eSgnT19TWU1MSU5LJykgJiZcbiAgICAgIHByb2Nlc3MudmVyc2lvbi5tYXRjaCgvXnYwXFwuNlxcLlswLTJdfF52MFxcLjVcXC4vKSkge1xuICAgIHBhdGNoTGNobW9kKGZzKVxuICB9XG5cbiAgLy8gbHV0aW1lcyBpbXBsZW1lbnRhdGlvbiwgb3Igbm8tb3BcbiAgaWYgKCFmcy5sdXRpbWVzKSB7XG4gICAgcGF0Y2hMdXRpbWVzKGZzKVxuICB9XG5cbiAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2lzYWFjcy9ub2RlLWdyYWNlZnVsLWZzL2lzc3Vlcy80XG4gIC8vIENob3duIHNob3VsZCBub3QgZmFpbCBvbiBlaW52YWwgb3IgZXBlcm0gaWYgbm9uLXJvb3QuXG4gIC8vIEl0IHNob3VsZCBub3QgZmFpbCBvbiBlbm9zeXMgZXZlciwgYXMgdGhpcyBqdXN0IGluZGljYXRlc1xuICAvLyB0aGF0IGEgZnMgZG9lc24ndCBzdXBwb3J0IHRoZSBpbnRlbmRlZCBvcGVyYXRpb24uXG5cbiAgZnMuY2hvd24gPSBjaG93bkZpeChmcy5jaG93bilcbiAgZnMuZmNob3duID0gY2hvd25GaXgoZnMuZmNob3duKVxuICBmcy5sY2hvd24gPSBjaG93bkZpeChmcy5sY2hvd24pXG5cbiAgZnMuY2htb2QgPSBjaG1vZEZpeChmcy5jaG1vZClcbiAgZnMuZmNobW9kID0gY2htb2RGaXgoZnMuZmNobW9kKVxuICBmcy5sY2htb2QgPSBjaG1vZEZpeChmcy5sY2htb2QpXG5cbiAgZnMuY2hvd25TeW5jID0gY2hvd25GaXhTeW5jKGZzLmNob3duU3luYylcbiAgZnMuZmNob3duU3luYyA9IGNob3duRml4U3luYyhmcy5mY2hvd25TeW5jKVxuICBmcy5sY2hvd25TeW5jID0gY2hvd25GaXhTeW5jKGZzLmxjaG93blN5bmMpXG5cbiAgZnMuY2htb2RTeW5jID0gY2htb2RGaXhTeW5jKGZzLmNobW9kU3luYylcbiAgZnMuZmNobW9kU3luYyA9IGNobW9kRml4U3luYyhmcy5mY2htb2RTeW5jKVxuICBmcy5sY2htb2RTeW5jID0gY2htb2RGaXhTeW5jKGZzLmxjaG1vZFN5bmMpXG5cbiAgZnMuc3RhdCA9IHN0YXRGaXgoZnMuc3RhdClcbiAgZnMuZnN0YXQgPSBzdGF0Rml4KGZzLmZzdGF0KVxuICBmcy5sc3RhdCA9IHN0YXRGaXgoZnMubHN0YXQpXG5cbiAgZnMuc3RhdFN5bmMgPSBzdGF0Rml4U3luYyhmcy5zdGF0U3luYylcbiAgZnMuZnN0YXRTeW5jID0gc3RhdEZpeFN5bmMoZnMuZnN0YXRTeW5jKVxuICBmcy5sc3RhdFN5bmMgPSBzdGF0Rml4U3luYyhmcy5sc3RhdFN5bmMpXG5cbiAgLy8gaWYgbGNobW9kL2xjaG93biBkbyBub3QgZXhpc3QsIHRoZW4gbWFrZSB0aGVtIG5vLW9wc1xuICBpZiAoIWZzLmxjaG1vZCkge1xuICAgIGZzLmxjaG1vZCA9IGZ1bmN0aW9uIChwYXRoLCBtb2RlLCBjYikge1xuICAgICAgaWYgKGNiKSBwcm9jZXNzLm5leHRUaWNrKGNiKVxuICAgIH1cbiAgICBmcy5sY2htb2RTeW5jID0gZnVuY3Rpb24gKCkge31cbiAgfVxuICBpZiAoIWZzLmxjaG93bikge1xuICAgIGZzLmxjaG93biA9IGZ1bmN0aW9uIChwYXRoLCB1aWQsIGdpZCwgY2IpIHtcbiAgICAgIGlmIChjYikgcHJvY2Vzcy5uZXh0VGljayhjYilcbiAgICB9XG4gICAgZnMubGNob3duU3luYyA9IGZ1bmN0aW9uICgpIHt9XG4gIH1cblxuICAvLyBvbiBXaW5kb3dzLCBBL1Ygc29mdHdhcmUgY2FuIGxvY2sgdGhlIGRpcmVjdG9yeSwgY2F1c2luZyB0aGlzXG4gIC8vIHRvIGZhaWwgd2l0aCBhbiBFQUNDRVMgb3IgRVBFUk0gaWYgdGhlIGRpcmVjdG9yeSBjb250YWlucyBuZXdseVxuICAvLyBjcmVhdGVkIGZpbGVzLiAgVHJ5IGFnYWluIG9uIGZhaWx1cmUsIGZvciB1cCB0byA2MCBzZWNvbmRzLlxuXG4gIC8vIFNldCB0aGUgdGltZW91dCB0aGlzIGxvbmcgYmVjYXVzZSBzb21lIFdpbmRvd3MgQW50aS1WaXJ1cywgc3VjaCBhcyBQYXJpdHlcbiAgLy8gYml0OSwgbWF5IGxvY2sgZmlsZXMgZm9yIHVwIHRvIGEgbWludXRlLCBjYXVzaW5nIG5wbSBwYWNrYWdlIGluc3RhbGxcbiAgLy8gZmFpbHVyZXMuIEFsc28sIHRha2UgY2FyZSB0byB5aWVsZCB0aGUgc2NoZWR1bGVyLiBXaW5kb3dzIHNjaGVkdWxpbmcgZ2l2ZXNcbiAgLy8gQ1BVIHRvIGEgYnVzeSBsb29waW5nIHByb2Nlc3MsIHdoaWNoIGNhbiBjYXVzZSB0aGUgcHJvZ3JhbSBjYXVzaW5nIHRoZSBsb2NrXG4gIC8vIGNvbnRlbnRpb24gdG8gYmUgc3RhcnZlZCBvZiBDUFUgYnkgbm9kZSwgc28gdGhlIGNvbnRlbnRpb24gZG9lc24ndCByZXNvbHZlLlxuICBpZiAocGxhdGZvcm0gPT09IFwid2luMzJcIikge1xuICAgIGZzLnJlbmFtZSA9IChmdW5jdGlvbiAoZnMkcmVuYW1lKSB7IHJldHVybiBmdW5jdGlvbiAoZnJvbSwgdG8sIGNiKSB7XG4gICAgICB2YXIgc3RhcnQgPSBEYXRlLm5vdygpXG4gICAgICB2YXIgYmFja29mZiA9IDA7XG4gICAgICBmcyRyZW5hbWUoZnJvbSwgdG8sIGZ1bmN0aW9uIENCIChlcikge1xuICAgICAgICBpZiAoZXJcbiAgICAgICAgICAgICYmIChlci5jb2RlID09PSBcIkVBQ0NFU1wiIHx8IGVyLmNvZGUgPT09IFwiRVBFUk1cIilcbiAgICAgICAgICAgICYmIERhdGUubm93KCkgLSBzdGFydCA8IDYwMDAwKSB7XG4gICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGZzLnN0YXQodG8sIGZ1bmN0aW9uIChzdGF0ZXIsIHN0KSB7XG4gICAgICAgICAgICAgIGlmIChzdGF0ZXIgJiYgc3RhdGVyLmNvZGUgPT09IFwiRU5PRU5UXCIpXG4gICAgICAgICAgICAgICAgZnMkcmVuYW1lKGZyb20sIHRvLCBDQik7XG4gICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICBjYihlcilcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgfSwgYmFja29mZilcbiAgICAgICAgICBpZiAoYmFja29mZiA8IDEwMClcbiAgICAgICAgICAgIGJhY2tvZmYgKz0gMTA7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjYikgY2IoZXIpXG4gICAgICB9KVxuICAgIH19KShmcy5yZW5hbWUpXG4gIH1cblxuICAvLyBpZiByZWFkKCkgcmV0dXJucyBFQUdBSU4sIHRoZW4ganVzdCB0cnkgaXQgYWdhaW4uXG4gIGZzLnJlYWQgPSAoZnVuY3Rpb24gKGZzJHJlYWQpIHsgcmV0dXJuIGZ1bmN0aW9uIChmZCwgYnVmZmVyLCBvZmZzZXQsIGxlbmd0aCwgcG9zaXRpb24sIGNhbGxiYWNrXykge1xuICAgIHZhciBjYWxsYmFja1xuICAgIGlmIChjYWxsYmFja18gJiYgdHlwZW9mIGNhbGxiYWNrXyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdmFyIGVhZ0NvdW50ZXIgPSAwXG4gICAgICBjYWxsYmFjayA9IGZ1bmN0aW9uIChlciwgXywgX18pIHtcbiAgICAgICAgaWYgKGVyICYmIGVyLmNvZGUgPT09ICdFQUdBSU4nICYmIGVhZ0NvdW50ZXIgPCAxMCkge1xuICAgICAgICAgIGVhZ0NvdW50ZXIgKytcbiAgICAgICAgICByZXR1cm4gZnMkcmVhZC5jYWxsKGZzLCBmZCwgYnVmZmVyLCBvZmZzZXQsIGxlbmd0aCwgcG9zaXRpb24sIGNhbGxiYWNrKVxuICAgICAgICB9XG4gICAgICAgIGNhbGxiYWNrXy5hcHBseSh0aGlzLCBhcmd1bWVudHMpXG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmcyRyZWFkLmNhbGwoZnMsIGZkLCBidWZmZXIsIG9mZnNldCwgbGVuZ3RoLCBwb3NpdGlvbiwgY2FsbGJhY2spXG4gIH19KShmcy5yZWFkKVxuXG4gIGZzLnJlYWRTeW5jID0gKGZ1bmN0aW9uIChmcyRyZWFkU3luYykgeyByZXR1cm4gZnVuY3Rpb24gKGZkLCBidWZmZXIsIG9mZnNldCwgbGVuZ3RoLCBwb3NpdGlvbikge1xuICAgIHZhciBlYWdDb3VudGVyID0gMFxuICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICB0cnkge1xuICAgICAgICByZXR1cm4gZnMkcmVhZFN5bmMuY2FsbChmcywgZmQsIGJ1ZmZlciwgb2Zmc2V0LCBsZW5ndGgsIHBvc2l0aW9uKVxuICAgICAgfSBjYXRjaCAoZXIpIHtcbiAgICAgICAgaWYgKGVyLmNvZGUgPT09ICdFQUdBSU4nICYmIGVhZ0NvdW50ZXIgPCAxMCkge1xuICAgICAgICAgIGVhZ0NvdW50ZXIgKytcbiAgICAgICAgICBjb250aW51ZVxuICAgICAgICB9XG4gICAgICAgIHRocm93IGVyXG4gICAgICB9XG4gICAgfVxuICB9fSkoZnMucmVhZFN5bmMpXG59XG5cbmZ1bmN0aW9uIHBhdGNoTGNobW9kIChmcykge1xuICBmcy5sY2htb2QgPSBmdW5jdGlvbiAocGF0aCwgbW9kZSwgY2FsbGJhY2spIHtcbiAgICBmcy5vcGVuKCBwYXRoXG4gICAgICAgICAgICwgY29uc3RhbnRzLk9fV1JPTkxZIHwgY29uc3RhbnRzLk9fU1lNTElOS1xuICAgICAgICAgICAsIG1vZGVcbiAgICAgICAgICAgLCBmdW5jdGlvbiAoZXJyLCBmZCkge1xuICAgICAgaWYgKGVycikge1xuICAgICAgICBpZiAoY2FsbGJhY2spIGNhbGxiYWNrKGVycilcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG4gICAgICAvLyBwcmVmZXIgdG8gcmV0dXJuIHRoZSBjaG1vZCBlcnJvciwgaWYgb25lIG9jY3VycyxcbiAgICAgIC8vIGJ1dCBzdGlsbCB0cnkgdG8gY2xvc2UsIGFuZCByZXBvcnQgY2xvc2luZyBlcnJvcnMgaWYgdGhleSBvY2N1ci5cbiAgICAgIGZzLmZjaG1vZChmZCwgbW9kZSwgZnVuY3Rpb24gKGVycikge1xuICAgICAgICBmcy5jbG9zZShmZCwgZnVuY3Rpb24oZXJyMikge1xuICAgICAgICAgIGlmIChjYWxsYmFjaykgY2FsbGJhY2soZXJyIHx8IGVycjIpXG4gICAgICAgIH0pXG4gICAgICB9KVxuICAgIH0pXG4gIH1cblxuICBmcy5sY2htb2RTeW5jID0gZnVuY3Rpb24gKHBhdGgsIG1vZGUpIHtcbiAgICB2YXIgZmQgPSBmcy5vcGVuU3luYyhwYXRoLCBjb25zdGFudHMuT19XUk9OTFkgfCBjb25zdGFudHMuT19TWU1MSU5LLCBtb2RlKVxuXG4gICAgLy8gcHJlZmVyIHRvIHJldHVybiB0aGUgY2htb2QgZXJyb3IsIGlmIG9uZSBvY2N1cnMsXG4gICAgLy8gYnV0IHN0aWxsIHRyeSB0byBjbG9zZSwgYW5kIHJlcG9ydCBjbG9zaW5nIGVycm9ycyBpZiB0aGV5IG9jY3VyLlxuICAgIHZhciB0aHJldyA9IHRydWVcbiAgICB2YXIgcmV0XG4gICAgdHJ5IHtcbiAgICAgIHJldCA9IGZzLmZjaG1vZFN5bmMoZmQsIG1vZGUpXG4gICAgICB0aHJldyA9IGZhbHNlXG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIGlmICh0aHJldykge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGZzLmNsb3NlU3luYyhmZClcbiAgICAgICAgfSBjYXRjaCAoZXIpIHt9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBmcy5jbG9zZVN5bmMoZmQpXG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXRcbiAgfVxufVxuXG5mdW5jdGlvbiBwYXRjaEx1dGltZXMgKGZzKSB7XG4gIGlmIChjb25zdGFudHMuaGFzT3duUHJvcGVydHkoXCJPX1NZTUxJTktcIikpIHtcbiAgICBmcy5sdXRpbWVzID0gZnVuY3Rpb24gKHBhdGgsIGF0LCBtdCwgY2IpIHtcbiAgICAgIGZzLm9wZW4ocGF0aCwgY29uc3RhbnRzLk9fU1lNTElOSywgZnVuY3Rpb24gKGVyLCBmZCkge1xuICAgICAgICBpZiAoZXIpIHtcbiAgICAgICAgICBpZiAoY2IpIGNiKGVyKVxuICAgICAgICAgIHJldHVyblxuICAgICAgICB9XG4gICAgICAgIGZzLmZ1dGltZXMoZmQsIGF0LCBtdCwgZnVuY3Rpb24gKGVyKSB7XG4gICAgICAgICAgZnMuY2xvc2UoZmQsIGZ1bmN0aW9uIChlcjIpIHtcbiAgICAgICAgICAgIGlmIChjYikgY2IoZXIgfHwgZXIyKVxuICAgICAgICAgIH0pXG4gICAgICAgIH0pXG4gICAgICB9KVxuICAgIH1cblxuICAgIGZzLmx1dGltZXNTeW5jID0gZnVuY3Rpb24gKHBhdGgsIGF0LCBtdCkge1xuICAgICAgdmFyIGZkID0gZnMub3BlblN5bmMocGF0aCwgY29uc3RhbnRzLk9fU1lNTElOSylcbiAgICAgIHZhciByZXRcbiAgICAgIHZhciB0aHJldyA9IHRydWVcbiAgICAgIHRyeSB7XG4gICAgICAgIHJldCA9IGZzLmZ1dGltZXNTeW5jKGZkLCBhdCwgbXQpXG4gICAgICAgIHRocmV3ID0gZmFsc2VcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIGlmICh0aHJldykge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBmcy5jbG9zZVN5bmMoZmQpXG4gICAgICAgICAgfSBjYXRjaCAoZXIpIHt9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZnMuY2xvc2VTeW5jKGZkKVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gcmV0XG4gICAgfVxuXG4gIH0gZWxzZSB7XG4gICAgZnMubHV0aW1lcyA9IGZ1bmN0aW9uIChfYSwgX2IsIF9jLCBjYikgeyBpZiAoY2IpIHByb2Nlc3MubmV4dFRpY2soY2IpIH1cbiAgICBmcy5sdXRpbWVzU3luYyA9IGZ1bmN0aW9uICgpIHt9XG4gIH1cbn1cblxuZnVuY3Rpb24gY2htb2RGaXggKG9yaWcpIHtcbiAgaWYgKCFvcmlnKSByZXR1cm4gb3JpZ1xuICByZXR1cm4gZnVuY3Rpb24gKHRhcmdldCwgbW9kZSwgY2IpIHtcbiAgICByZXR1cm4gb3JpZy5jYWxsKGZzLCB0YXJnZXQsIG1vZGUsIGZ1bmN0aW9uIChlcikge1xuICAgICAgaWYgKGNob3duRXJPayhlcikpIGVyID0gbnVsbFxuICAgICAgaWYgKGNiKSBjYi5hcHBseSh0aGlzLCBhcmd1bWVudHMpXG4gICAgfSlcbiAgfVxufVxuXG5mdW5jdGlvbiBjaG1vZEZpeFN5bmMgKG9yaWcpIHtcbiAgaWYgKCFvcmlnKSByZXR1cm4gb3JpZ1xuICByZXR1cm4gZnVuY3Rpb24gKHRhcmdldCwgbW9kZSkge1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4gb3JpZy5jYWxsKGZzLCB0YXJnZXQsIG1vZGUpXG4gICAgfSBjYXRjaCAoZXIpIHtcbiAgICAgIGlmICghY2hvd25Fck9rKGVyKSkgdGhyb3cgZXJcbiAgICB9XG4gIH1cbn1cblxuXG5mdW5jdGlvbiBjaG93bkZpeCAob3JpZykge1xuICBpZiAoIW9yaWcpIHJldHVybiBvcmlnXG4gIHJldHVybiBmdW5jdGlvbiAodGFyZ2V0LCB1aWQsIGdpZCwgY2IpIHtcbiAgICByZXR1cm4gb3JpZy5jYWxsKGZzLCB0YXJnZXQsIHVpZCwgZ2lkLCBmdW5jdGlvbiAoZXIpIHtcbiAgICAgIGlmIChjaG93bkVyT2soZXIpKSBlciA9IG51bGxcbiAgICAgIGlmIChjYikgY2IuYXBwbHkodGhpcywgYXJndW1lbnRzKVxuICAgIH0pXG4gIH1cbn1cblxuZnVuY3Rpb24gY2hvd25GaXhTeW5jIChvcmlnKSB7XG4gIGlmICghb3JpZykgcmV0dXJuIG9yaWdcbiAgcmV0dXJuIGZ1bmN0aW9uICh0YXJnZXQsIHVpZCwgZ2lkKSB7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBvcmlnLmNhbGwoZnMsIHRhcmdldCwgdWlkLCBnaWQpXG4gICAgfSBjYXRjaCAoZXIpIHtcbiAgICAgIGlmICghY2hvd25Fck9rKGVyKSkgdGhyb3cgZXJcbiAgICB9XG4gIH1cbn1cblxuXG5mdW5jdGlvbiBzdGF0Rml4IChvcmlnKSB7XG4gIGlmICghb3JpZykgcmV0dXJuIG9yaWdcbiAgLy8gT2xkZXIgdmVyc2lvbnMgb2YgTm9kZSBlcnJvbmVvdXNseSByZXR1cm5lZCBzaWduZWQgaW50ZWdlcnMgZm9yXG4gIC8vIHVpZCArIGdpZC5cbiAgcmV0dXJuIGZ1bmN0aW9uICh0YXJnZXQsIGNiKSB7XG4gICAgcmV0dXJuIG9yaWcuY2FsbChmcywgdGFyZ2V0LCBmdW5jdGlvbiAoZXIsIHN0YXRzKSB7XG4gICAgICBpZiAoIXN0YXRzKSByZXR1cm4gY2IuYXBwbHkodGhpcywgYXJndW1lbnRzKVxuICAgICAgaWYgKHN0YXRzLnVpZCA8IDApIHN0YXRzLnVpZCArPSAweDEwMDAwMDAwMFxuICAgICAgaWYgKHN0YXRzLmdpZCA8IDApIHN0YXRzLmdpZCArPSAweDEwMDAwMDAwMFxuICAgICAgaWYgKGNiKSBjYi5hcHBseSh0aGlzLCBhcmd1bWVudHMpXG4gICAgfSlcbiAgfVxufVxuXG5mdW5jdGlvbiBzdGF0Rml4U3luYyAob3JpZykge1xuICBpZiAoIW9yaWcpIHJldHVybiBvcmlnXG4gIC8vIE9sZGVyIHZlcnNpb25zIG9mIE5vZGUgZXJyb25lb3VzbHkgcmV0dXJuZWQgc2lnbmVkIGludGVnZXJzIGZvclxuICAvLyB1aWQgKyBnaWQuXG4gIHJldHVybiBmdW5jdGlvbiAodGFyZ2V0KSB7XG4gICAgdmFyIHN0YXRzID0gb3JpZy5jYWxsKGZzLCB0YXJnZXQpXG4gICAgaWYgKHN0YXRzLnVpZCA8IDApIHN0YXRzLnVpZCArPSAweDEwMDAwMDAwMFxuICAgIGlmIChzdGF0cy5naWQgPCAwKSBzdGF0cy5naWQgKz0gMHgxMDAwMDAwMDBcbiAgICByZXR1cm4gc3RhdHM7XG4gIH1cbn1cblxuLy8gRU5PU1lTIG1lYW5zIHRoYXQgdGhlIGZzIGRvZXNuJ3Qgc3VwcG9ydCB0aGUgb3AuIEp1c3QgaWdub3JlXG4vLyB0aGF0LCBiZWNhdXNlIGl0IGRvZXNuJ3QgbWF0dGVyLlxuLy9cbi8vIGlmIHRoZXJlJ3Mgbm8gZ2V0dWlkLCBvciBpZiBnZXR1aWQoKSBpcyBzb21ldGhpbmcgb3RoZXJcbi8vIHRoYW4gMCwgYW5kIHRoZSBlcnJvciBpcyBFSU5WQUwgb3IgRVBFUk0sIHRoZW4ganVzdCBpZ25vcmVcbi8vIGl0LlxuLy9cbi8vIFRoaXMgc3BlY2lmaWMgY2FzZSBpcyBhIHNpbGVudCBmYWlsdXJlIGluIGNwLCBpbnN0YWxsLCB0YXIsXG4vLyBhbmQgbW9zdCBvdGhlciB1bml4IHRvb2xzIHRoYXQgbWFuYWdlIHBlcm1pc3Npb25zLlxuLy9cbi8vIFdoZW4gcnVubmluZyBhcyByb290LCBvciBpZiBvdGhlciB0eXBlcyBvZiBlcnJvcnMgYXJlXG4vLyBlbmNvdW50ZXJlZCwgdGhlbiBpdCdzIHN0cmljdC5cbmZ1bmN0aW9uIGNob3duRXJPayAoZXIpIHtcbiAgaWYgKCFlcilcbiAgICByZXR1cm4gdHJ1ZVxuXG4gIGlmIChlci5jb2RlID09PSBcIkVOT1NZU1wiKVxuICAgIHJldHVybiB0cnVlXG5cbiAgdmFyIG5vbnJvb3QgPSAhcHJvY2Vzcy5nZXR1aWQgfHwgcHJvY2Vzcy5nZXR1aWQoKSAhPT0gMFxuICBpZiAobm9ucm9vdCkge1xuICAgIGlmIChlci5jb2RlID09PSBcIkVJTlZBTFwiIHx8IGVyLmNvZGUgPT09IFwiRVBFUk1cIilcbiAgICAgIHJldHVybiB0cnVlXG4gIH1cblxuICByZXR1cm4gZmFsc2Vcbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9ncmFjZWZ1bC1mcy9wb2x5ZmlsbHMuanMiLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCJjb25zdGFudHNcIik7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gZXh0ZXJuYWwgXCJjb25zdGFudHNcIlxuLy8gbW9kdWxlIGlkID0gMTEwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBTdHJlYW0gPSByZXF1aXJlKCdzdHJlYW0nKS5TdHJlYW1cblxubW9kdWxlLmV4cG9ydHMgPSBsZWdhY3lcblxuZnVuY3Rpb24gbGVnYWN5IChmcykge1xuICByZXR1cm4ge1xuICAgIFJlYWRTdHJlYW06IFJlYWRTdHJlYW0sXG4gICAgV3JpdGVTdHJlYW06IFdyaXRlU3RyZWFtXG4gIH1cblxuICBmdW5jdGlvbiBSZWFkU3RyZWFtIChwYXRoLCBvcHRpb25zKSB7XG4gICAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIFJlYWRTdHJlYW0pKSByZXR1cm4gbmV3IFJlYWRTdHJlYW0ocGF0aCwgb3B0aW9ucyk7XG5cbiAgICBTdHJlYW0uY2FsbCh0aGlzKTtcblxuICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgIHRoaXMucGF0aCA9IHBhdGg7XG4gICAgdGhpcy5mZCA9IG51bGw7XG4gICAgdGhpcy5yZWFkYWJsZSA9IHRydWU7XG4gICAgdGhpcy5wYXVzZWQgPSBmYWxzZTtcblxuICAgIHRoaXMuZmxhZ3MgPSAncic7XG4gICAgdGhpcy5tb2RlID0gNDM4OyAvKj0wNjY2Ki9cbiAgICB0aGlzLmJ1ZmZlclNpemUgPSA2NCAqIDEwMjQ7XG5cbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICAgIC8vIE1peGluIG9wdGlvbnMgaW50byB0aGlzXG4gICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhvcHRpb25zKTtcbiAgICBmb3IgKHZhciBpbmRleCA9IDAsIGxlbmd0aCA9IGtleXMubGVuZ3RoOyBpbmRleCA8IGxlbmd0aDsgaW5kZXgrKykge1xuICAgICAgdmFyIGtleSA9IGtleXNbaW5kZXhdO1xuICAgICAgdGhpc1trZXldID0gb3B0aW9uc1trZXldO1xuICAgIH1cblxuICAgIGlmICh0aGlzLmVuY29kaW5nKSB0aGlzLnNldEVuY29kaW5nKHRoaXMuZW5jb2RpbmcpO1xuXG4gICAgaWYgKHRoaXMuc3RhcnQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgaWYgKCdudW1iZXInICE9PSB0eXBlb2YgdGhpcy5zdGFydCkge1xuICAgICAgICB0aHJvdyBUeXBlRXJyb3IoJ3N0YXJ0IG11c3QgYmUgYSBOdW1iZXInKTtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLmVuZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRoaXMuZW5kID0gSW5maW5pdHk7XG4gICAgICB9IGVsc2UgaWYgKCdudW1iZXInICE9PSB0eXBlb2YgdGhpcy5lbmQpIHtcbiAgICAgICAgdGhyb3cgVHlwZUVycm9yKCdlbmQgbXVzdCBiZSBhIE51bWJlcicpO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5zdGFydCA+IHRoaXMuZW5kKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignc3RhcnQgbXVzdCBiZSA8PSBlbmQnKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5wb3MgPSB0aGlzLnN0YXJ0O1xuICAgIH1cblxuICAgIGlmICh0aGlzLmZkICE9PSBudWxsKSB7XG4gICAgICBwcm9jZXNzLm5leHRUaWNrKGZ1bmN0aW9uKCkge1xuICAgICAgICBzZWxmLl9yZWFkKCk7XG4gICAgICB9KTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBmcy5vcGVuKHRoaXMucGF0aCwgdGhpcy5mbGFncywgdGhpcy5tb2RlLCBmdW5jdGlvbiAoZXJyLCBmZCkge1xuICAgICAgaWYgKGVycikge1xuICAgICAgICBzZWxmLmVtaXQoJ2Vycm9yJywgZXJyKTtcbiAgICAgICAgc2VsZi5yZWFkYWJsZSA9IGZhbHNlO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHNlbGYuZmQgPSBmZDtcbiAgICAgIHNlbGYuZW1pdCgnb3BlbicsIGZkKTtcbiAgICAgIHNlbGYuX3JlYWQoKTtcbiAgICB9KVxuICB9XG5cbiAgZnVuY3Rpb24gV3JpdGVTdHJlYW0gKHBhdGgsIG9wdGlvbnMpIHtcbiAgICBpZiAoISh0aGlzIGluc3RhbmNlb2YgV3JpdGVTdHJlYW0pKSByZXR1cm4gbmV3IFdyaXRlU3RyZWFtKHBhdGgsIG9wdGlvbnMpO1xuXG4gICAgU3RyZWFtLmNhbGwodGhpcyk7XG5cbiAgICB0aGlzLnBhdGggPSBwYXRoO1xuICAgIHRoaXMuZmQgPSBudWxsO1xuICAgIHRoaXMud3JpdGFibGUgPSB0cnVlO1xuXG4gICAgdGhpcy5mbGFncyA9ICd3JztcbiAgICB0aGlzLmVuY29kaW5nID0gJ2JpbmFyeSc7XG4gICAgdGhpcy5tb2RlID0gNDM4OyAvKj0wNjY2Ki9cbiAgICB0aGlzLmJ5dGVzV3JpdHRlbiA9IDA7XG5cbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICAgIC8vIE1peGluIG9wdGlvbnMgaW50byB0aGlzXG4gICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhvcHRpb25zKTtcbiAgICBmb3IgKHZhciBpbmRleCA9IDAsIGxlbmd0aCA9IGtleXMubGVuZ3RoOyBpbmRleCA8IGxlbmd0aDsgaW5kZXgrKykge1xuICAgICAgdmFyIGtleSA9IGtleXNbaW5kZXhdO1xuICAgICAgdGhpc1trZXldID0gb3B0aW9uc1trZXldO1xuICAgIH1cblxuICAgIGlmICh0aGlzLnN0YXJ0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGlmICgnbnVtYmVyJyAhPT0gdHlwZW9mIHRoaXMuc3RhcnQpIHtcbiAgICAgICAgdGhyb3cgVHlwZUVycm9yKCdzdGFydCBtdXN0IGJlIGEgTnVtYmVyJyk7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5zdGFydCA8IDApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdzdGFydCBtdXN0IGJlID49IHplcm8nKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5wb3MgPSB0aGlzLnN0YXJ0O1xuICAgIH1cblxuICAgIHRoaXMuYnVzeSA9IGZhbHNlO1xuICAgIHRoaXMuX3F1ZXVlID0gW107XG5cbiAgICBpZiAodGhpcy5mZCA9PT0gbnVsbCkge1xuICAgICAgdGhpcy5fb3BlbiA9IGZzLm9wZW47XG4gICAgICB0aGlzLl9xdWV1ZS5wdXNoKFt0aGlzLl9vcGVuLCB0aGlzLnBhdGgsIHRoaXMuZmxhZ3MsIHRoaXMubW9kZSwgdW5kZWZpbmVkXSk7XG4gICAgICB0aGlzLmZsdXNoKCk7XG4gICAgfVxuICB9XG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvZ3JhY2VmdWwtZnMvbGVnYWN5LXN0cmVhbXMuanMiLCJjb25zdCB1ID0gcmVxdWlyZSgndW5pdmVyc2FsaWZ5JykuZnJvbUNhbGxiYWNrXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgY29weTogdShyZXF1aXJlKCcuL2NvcHknKSlcbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9lbGVjdHJvbi11cGRhdGVyL25vZGVfbW9kdWxlcy9mcy1leHRyYS9saWIvY29weS9pbmRleC5qcyIsIid1c2Ugc3RyaWN0J1xuXG5jb25zdCBmcyA9IHJlcXVpcmUoJ2dyYWNlZnVsLWZzJylcbmNvbnN0IHBhdGggPSByZXF1aXJlKCdwYXRoJylcbmNvbnN0IGludmFsaWRXaW4zMlBhdGggPSByZXF1aXJlKCcuL3dpbjMyJykuaW52YWxpZFdpbjMyUGF0aFxuXG5jb25zdCBvNzc3ID0gcGFyc2VJbnQoJzA3NzcnLCA4KVxuXG5mdW5jdGlvbiBta2RpcnMgKHAsIG9wdHMsIGNhbGxiYWNrLCBtYWRlKSB7XG4gIGlmICh0eXBlb2Ygb3B0cyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGNhbGxiYWNrID0gb3B0c1xuICAgIG9wdHMgPSB7fVxuICB9IGVsc2UgaWYgKCFvcHRzIHx8IHR5cGVvZiBvcHRzICE9PSAnb2JqZWN0Jykge1xuICAgIG9wdHMgPSB7IG1vZGU6IG9wdHMgfVxuICB9XG5cbiAgaWYgKHByb2Nlc3MucGxhdGZvcm0gPT09ICd3aW4zMicgJiYgaW52YWxpZFdpbjMyUGF0aChwKSkge1xuICAgIGNvbnN0IGVyckludmFsID0gbmV3IEVycm9yKHAgKyAnIGNvbnRhaW5zIGludmFsaWQgV0lOMzIgcGF0aCBjaGFyYWN0ZXJzLicpXG4gICAgZXJySW52YWwuY29kZSA9ICdFSU5WQUwnXG4gICAgcmV0dXJuIGNhbGxiYWNrKGVyckludmFsKVxuICB9XG5cbiAgbGV0IG1vZGUgPSBvcHRzLm1vZGVcbiAgY29uc3QgeGZzID0gb3B0cy5mcyB8fCBmc1xuXG4gIGlmIChtb2RlID09PSB1bmRlZmluZWQpIHtcbiAgICBtb2RlID0gbzc3NyAmICh+cHJvY2Vzcy51bWFzaygpKVxuICB9XG4gIGlmICghbWFkZSkgbWFkZSA9IG51bGxcblxuICBjYWxsYmFjayA9IGNhbGxiYWNrIHx8IGZ1bmN0aW9uICgpIHt9XG4gIHAgPSBwYXRoLnJlc29sdmUocClcblxuICB4ZnMubWtkaXIocCwgbW9kZSwgZXIgPT4ge1xuICAgIGlmICghZXIpIHtcbiAgICAgIG1hZGUgPSBtYWRlIHx8IHBcbiAgICAgIHJldHVybiBjYWxsYmFjayhudWxsLCBtYWRlKVxuICAgIH1cbiAgICBzd2l0Y2ggKGVyLmNvZGUpIHtcbiAgICAgIGNhc2UgJ0VOT0VOVCc6XG4gICAgICAgIGlmIChwYXRoLmRpcm5hbWUocCkgPT09IHApIHJldHVybiBjYWxsYmFjayhlcilcbiAgICAgICAgbWtkaXJzKHBhdGguZGlybmFtZShwKSwgb3B0cywgKGVyLCBtYWRlKSA9PiB7XG4gICAgICAgICAgaWYgKGVyKSBjYWxsYmFjayhlciwgbWFkZSlcbiAgICAgICAgICBlbHNlIG1rZGlycyhwLCBvcHRzLCBjYWxsYmFjaywgbWFkZSlcbiAgICAgICAgfSlcbiAgICAgICAgYnJlYWtcblxuICAgICAgLy8gSW4gdGhlIGNhc2Ugb2YgYW55IG90aGVyIGVycm9yLCBqdXN0IHNlZSBpZiB0aGVyZSdzIGEgZGlyXG4gICAgICAvLyB0aGVyZSBhbHJlYWR5LiAgSWYgc28sIHRoZW4gaG9vcmF5ISAgSWYgbm90LCB0aGVuIHNvbWV0aGluZ1xuICAgICAgLy8gaXMgYm9ya2VkLlxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgeGZzLnN0YXQocCwgKGVyMiwgc3RhdCkgPT4ge1xuICAgICAgICAgIC8vIGlmIHRoZSBzdGF0IGZhaWxzLCB0aGVuIHRoYXQncyBzdXBlciB3ZWlyZC5cbiAgICAgICAgICAvLyBsZXQgdGhlIG9yaWdpbmFsIGVycm9yIGJlIHRoZSBmYWlsdXJlIHJlYXNvbi5cbiAgICAgICAgICBpZiAoZXIyIHx8ICFzdGF0LmlzRGlyZWN0b3J5KCkpIGNhbGxiYWNrKGVyLCBtYWRlKVxuICAgICAgICAgIGVsc2UgY2FsbGJhY2sobnVsbCwgbWFkZSlcbiAgICAgICAgfSlcbiAgICAgICAgYnJlYWtcbiAgICB9XG4gIH0pXG59XG5cbm1vZHVsZS5leHBvcnRzID0gbWtkaXJzXG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvZWxlY3Ryb24tdXBkYXRlci9ub2RlX21vZHVsZXMvZnMtZXh0cmEvbGliL21rZGlycy9ta2RpcnMuanMiLCIndXNlIHN0cmljdCdcblxuY29uc3QgZnMgPSByZXF1aXJlKCdncmFjZWZ1bC1mcycpXG5jb25zdCBwYXRoID0gcmVxdWlyZSgncGF0aCcpXG5jb25zdCBpbnZhbGlkV2luMzJQYXRoID0gcmVxdWlyZSgnLi93aW4zMicpLmludmFsaWRXaW4zMlBhdGhcblxuY29uc3Qgbzc3NyA9IHBhcnNlSW50KCcwNzc3JywgOClcblxuZnVuY3Rpb24gbWtkaXJzU3luYyAocCwgb3B0cywgbWFkZSkge1xuICBpZiAoIW9wdHMgfHwgdHlwZW9mIG9wdHMgIT09ICdvYmplY3QnKSB7XG4gICAgb3B0cyA9IHsgbW9kZTogb3B0cyB9XG4gIH1cblxuICBsZXQgbW9kZSA9IG9wdHMubW9kZVxuICBjb25zdCB4ZnMgPSBvcHRzLmZzIHx8IGZzXG5cbiAgaWYgKHByb2Nlc3MucGxhdGZvcm0gPT09ICd3aW4zMicgJiYgaW52YWxpZFdpbjMyUGF0aChwKSkge1xuICAgIGNvbnN0IGVyckludmFsID0gbmV3IEVycm9yKHAgKyAnIGNvbnRhaW5zIGludmFsaWQgV0lOMzIgcGF0aCBjaGFyYWN0ZXJzLicpXG4gICAgZXJySW52YWwuY29kZSA9ICdFSU5WQUwnXG4gICAgdGhyb3cgZXJySW52YWxcbiAgfVxuXG4gIGlmIChtb2RlID09PSB1bmRlZmluZWQpIHtcbiAgICBtb2RlID0gbzc3NyAmICh+cHJvY2Vzcy51bWFzaygpKVxuICB9XG4gIGlmICghbWFkZSkgbWFkZSA9IG51bGxcblxuICBwID0gcGF0aC5yZXNvbHZlKHApXG5cbiAgdHJ5IHtcbiAgICB4ZnMubWtkaXJTeW5jKHAsIG1vZGUpXG4gICAgbWFkZSA9IG1hZGUgfHwgcFxuICB9IGNhdGNoIChlcnIwKSB7XG4gICAgc3dpdGNoIChlcnIwLmNvZGUpIHtcbiAgICAgIGNhc2UgJ0VOT0VOVCc6XG4gICAgICAgIGlmIChwYXRoLmRpcm5hbWUocCkgPT09IHApIHRocm93IGVycjBcbiAgICAgICAgbWFkZSA9IG1rZGlyc1N5bmMocGF0aC5kaXJuYW1lKHApLCBvcHRzLCBtYWRlKVxuICAgICAgICBta2RpcnNTeW5jKHAsIG9wdHMsIG1hZGUpXG4gICAgICAgIGJyZWFrXG5cbiAgICAgIC8vIEluIHRoZSBjYXNlIG9mIGFueSBvdGhlciBlcnJvciwganVzdCBzZWUgaWYgdGhlcmUncyBhIGRpclxuICAgICAgLy8gdGhlcmUgYWxyZWFkeS4gIElmIHNvLCB0aGVuIGhvb3JheSEgIElmIG5vdCwgdGhlbiBzb21ldGhpbmdcbiAgICAgIC8vIGlzIGJvcmtlZC5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGxldCBzdGF0XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgc3RhdCA9IHhmcy5zdGF0U3luYyhwKVxuICAgICAgICB9IGNhdGNoIChlcnIxKSB7XG4gICAgICAgICAgdGhyb3cgZXJyMFxuICAgICAgICB9XG4gICAgICAgIGlmICghc3RhdC5pc0RpcmVjdG9yeSgpKSB0aHJvdyBlcnIwXG4gICAgICAgIGJyZWFrXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG1hZGVcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBta2RpcnNTeW5jXG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvZWxlY3Ryb24tdXBkYXRlci9ub2RlX21vZHVsZXMvZnMtZXh0cmEvbGliL21rZGlycy9ta2RpcnMtc3luYy5qcyIsIid1c2Ugc3RyaWN0J1xuXG5jb25zdCBmcyA9IHJlcXVpcmUoJ2dyYWNlZnVsLWZzJylcbmNvbnN0IHBhdGggPSByZXF1aXJlKCdwYXRoJylcbmNvbnN0IG1rZGlycFN5bmMgPSByZXF1aXJlKCcuLi9ta2RpcnMnKS5ta2RpcnNTeW5jXG5jb25zdCB1dGltZXNTeW5jID0gcmVxdWlyZSgnLi4vdXRpbC91dGltZXMuanMnKS51dGltZXNNaWxsaXNTeW5jXG5cbmNvbnN0IG5vdEV4aXN0ID0gU3ltYm9sKCdub3RFeGlzdCcpXG5jb25zdCBleGlzdHNSZWcgPSBTeW1ib2woJ2V4aXN0c1JlZycpXG5cbmZ1bmN0aW9uIGNvcHlTeW5jIChzcmMsIGRlc3QsIG9wdHMpIHtcbiAgaWYgKHR5cGVvZiBvcHRzID09PSAnZnVuY3Rpb24nKSB7XG4gICAgb3B0cyA9IHtmaWx0ZXI6IG9wdHN9XG4gIH1cblxuICBvcHRzID0gb3B0cyB8fCB7fVxuICBvcHRzLmNsb2JiZXIgPSAnY2xvYmJlcicgaW4gb3B0cyA/ICEhb3B0cy5jbG9iYmVyIDogdHJ1ZSAvLyBkZWZhdWx0IHRvIHRydWUgZm9yIG5vd1xuICBvcHRzLm92ZXJ3cml0ZSA9ICdvdmVyd3JpdGUnIGluIG9wdHMgPyAhIW9wdHMub3ZlcndyaXRlIDogb3B0cy5jbG9iYmVyIC8vIG92ZXJ3cml0ZSBmYWxscyBiYWNrIHRvIGNsb2JiZXJcblxuICAvLyBXYXJuIGFib3V0IHVzaW5nIHByZXNlcnZlVGltZXN0YW1wcyBvbiAzMi1iaXQgbm9kZVxuICBpZiAob3B0cy5wcmVzZXJ2ZVRpbWVzdGFtcHMgJiYgcHJvY2Vzcy5hcmNoID09PSAnaWEzMicpIHtcbiAgICBjb25zb2xlLndhcm4oYGZzLWV4dHJhOiBVc2luZyB0aGUgcHJlc2VydmVUaW1lc3RhbXBzIG9wdGlvbiBpbiAzMi1iaXQgbm9kZSBpcyBub3QgcmVjb21tZW5kZWQ7XFxuXG4gICAgc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9qcHJpY2hhcmRzb24vbm9kZS1mcy1leHRyYS9pc3N1ZXMvMjY5YClcbiAgfVxuXG4gIHNyYyA9IHBhdGgucmVzb2x2ZShzcmMpXG4gIGRlc3QgPSBwYXRoLnJlc29sdmUoZGVzdClcblxuICAvLyBkb24ndCBhbGxvdyBzcmMgYW5kIGRlc3QgdG8gYmUgdGhlIHNhbWVcbiAgaWYgKHNyYyA9PT0gZGVzdCkgdGhyb3cgbmV3IEVycm9yKCdTb3VyY2UgYW5kIGRlc3RpbmF0aW9uIG11c3Qgbm90IGJlIHRoZSBzYW1lLicpXG5cbiAgaWYgKG9wdHMuZmlsdGVyICYmICFvcHRzLmZpbHRlcihzcmMsIGRlc3QpKSByZXR1cm5cblxuICBjb25zdCBkZXN0UGFyZW50ID0gcGF0aC5kaXJuYW1lKGRlc3QpXG4gIGlmICghZnMuZXhpc3RzU3luYyhkZXN0UGFyZW50KSkgbWtkaXJwU3luYyhkZXN0UGFyZW50KVxuICByZXR1cm4gc3RhcnRDb3B5KHNyYywgZGVzdCwgb3B0cylcbn1cblxuZnVuY3Rpb24gc3RhcnRDb3B5IChzcmMsIGRlc3QsIG9wdHMpIHtcbiAgaWYgKG9wdHMuZmlsdGVyICYmICFvcHRzLmZpbHRlcihzcmMsIGRlc3QpKSByZXR1cm5cbiAgcmV0dXJuIGdldFN0YXRzKHNyYywgZGVzdCwgb3B0cylcbn1cblxuZnVuY3Rpb24gZ2V0U3RhdHMgKHNyYywgZGVzdCwgb3B0cykge1xuICBjb25zdCBzdGF0U3luYyA9IG9wdHMuZGVyZWZlcmVuY2UgPyBmcy5zdGF0U3luYyA6IGZzLmxzdGF0U3luY1xuICBjb25zdCBzdCA9IHN0YXRTeW5jKHNyYylcblxuICBpZiAoc3QuaXNEaXJlY3RvcnkoKSkgcmV0dXJuIG9uRGlyKHN0LCBzcmMsIGRlc3QsIG9wdHMpXG4gIGVsc2UgaWYgKHN0LmlzRmlsZSgpIHx8XG4gICAgICAgICAgIHN0LmlzQ2hhcmFjdGVyRGV2aWNlKCkgfHxcbiAgICAgICAgICAgc3QuaXNCbG9ja0RldmljZSgpKSByZXR1cm4gb25GaWxlKHN0LCBzcmMsIGRlc3QsIG9wdHMpXG4gIGVsc2UgaWYgKHN0LmlzU3ltYm9saWNMaW5rKCkpIHJldHVybiBvbkxpbmsoc3JjLCBkZXN0LCBvcHRzKVxufVxuXG5mdW5jdGlvbiBvbkZpbGUgKHNyY1N0YXQsIHNyYywgZGVzdCwgb3B0cykge1xuICBjb25zdCByZXNvbHZlZFBhdGggPSBjaGVja0Rlc3QoZGVzdClcbiAgaWYgKHJlc29sdmVkUGF0aCA9PT0gbm90RXhpc3QpIHtcbiAgICByZXR1cm4gY29weUZpbGUoc3JjU3RhdCwgc3JjLCBkZXN0LCBvcHRzKVxuICB9IGVsc2UgaWYgKHJlc29sdmVkUGF0aCA9PT0gZXhpc3RzUmVnKSB7XG4gICAgcmV0dXJuIG1heUNvcHlGaWxlKHNyY1N0YXQsIHNyYywgZGVzdCwgb3B0cylcbiAgfSBlbHNlIHtcbiAgICBpZiAoc3JjID09PSByZXNvbHZlZFBhdGgpIHJldHVyblxuICAgIHJldHVybiBtYXlDb3B5RmlsZShzcmNTdGF0LCBzcmMsIGRlc3QsIG9wdHMpXG4gIH1cbn1cblxuZnVuY3Rpb24gbWF5Q29weUZpbGUgKHNyY1N0YXQsIHNyYywgZGVzdCwgb3B0cykge1xuICBpZiAob3B0cy5vdmVyd3JpdGUpIHtcbiAgICBmcy51bmxpbmtTeW5jKGRlc3QpXG4gICAgcmV0dXJuIGNvcHlGaWxlKHNyY1N0YXQsIHNyYywgZGVzdCwgb3B0cylcbiAgfSBlbHNlIGlmIChvcHRzLmVycm9yT25FeGlzdCkge1xuICAgIHRocm93IG5ldyBFcnJvcihgJyR7ZGVzdH0nIGFscmVhZHkgZXhpc3RzYClcbiAgfVxufVxuXG5mdW5jdGlvbiBjb3B5RmlsZSAoc3JjU3RhdCwgc3JjLCBkZXN0LCBvcHRzKSB7XG4gIGlmICh0eXBlb2YgZnMuY29weUZpbGVTeW5jID09PSAnZnVuY3Rpb24nKSB7XG4gICAgZnMuY29weUZpbGVTeW5jKHNyYywgZGVzdClcbiAgICBmcy5jaG1vZFN5bmMoZGVzdCwgc3JjU3RhdC5tb2RlKVxuICAgIGlmIChvcHRzLnByZXNlcnZlVGltZXN0YW1wcykge1xuICAgICAgcmV0dXJuIHV0aW1lc1N5bmMoZGVzdCwgc3JjU3RhdC5hdGltZSwgc3JjU3RhdC5tdGltZSlcbiAgICB9XG4gICAgcmV0dXJuXG4gIH1cbiAgcmV0dXJuIGNvcHlGaWxlRmFsbGJhY2soc3JjU3RhdCwgc3JjLCBkZXN0LCBvcHRzKVxufVxuXG5mdW5jdGlvbiBjb3B5RmlsZUZhbGxiYWNrIChzcmNTdGF0LCBzcmMsIGRlc3QsIG9wdHMpIHtcbiAgY29uc3QgQlVGX0xFTkdUSCA9IDY0ICogMTAyNFxuICBjb25zdCBfYnVmZiA9IHJlcXVpcmUoJy4uL3V0aWwvYnVmZmVyJykoQlVGX0xFTkdUSClcblxuICBjb25zdCBmZHIgPSBmcy5vcGVuU3luYyhzcmMsICdyJylcbiAgY29uc3QgZmR3ID0gZnMub3BlblN5bmMoZGVzdCwgJ3cnLCBzcmNTdGF0Lm1vZGUpXG4gIGxldCBieXRlc1JlYWQgPSAxXG4gIGxldCBwb3MgPSAwXG5cbiAgd2hpbGUgKGJ5dGVzUmVhZCA+IDApIHtcbiAgICBieXRlc1JlYWQgPSBmcy5yZWFkU3luYyhmZHIsIF9idWZmLCAwLCBCVUZfTEVOR1RILCBwb3MpXG4gICAgZnMud3JpdGVTeW5jKGZkdywgX2J1ZmYsIDAsIGJ5dGVzUmVhZClcbiAgICBwb3MgKz0gYnl0ZXNSZWFkXG4gIH1cblxuICBpZiAob3B0cy5wcmVzZXJ2ZVRpbWVzdGFtcHMpIGZzLmZ1dGltZXNTeW5jKGZkdywgc3JjU3RhdC5hdGltZSwgc3JjU3RhdC5tdGltZSlcblxuICBmcy5jbG9zZVN5bmMoZmRyKVxuICBmcy5jbG9zZVN5bmMoZmR3KVxufVxuXG5mdW5jdGlvbiBvbkRpciAoc3JjU3RhdCwgc3JjLCBkZXN0LCBvcHRzKSB7XG4gIGNvbnN0IHJlc29sdmVkUGF0aCA9IGNoZWNrRGVzdChkZXN0KVxuICBpZiAocmVzb2x2ZWRQYXRoID09PSBub3RFeGlzdCkge1xuICAgIGlmIChpc1NyY1N1YmRpcihzcmMsIGRlc3QpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYENhbm5vdCBjb3B5ICcke3NyY30nIHRvIGEgc3ViZGlyZWN0b3J5IG9mIGl0c2VsZiwgJyR7ZGVzdH0nLmApXG4gICAgfVxuICAgIHJldHVybiBta0RpckFuZENvcHkoc3JjU3RhdCwgc3JjLCBkZXN0LCBvcHRzKVxuICB9IGVsc2UgaWYgKHJlc29sdmVkUGF0aCA9PT0gZXhpc3RzUmVnKSB7XG4gICAgaWYgKGlzU3JjU3ViZGlyKHNyYywgZGVzdCkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgQ2Fubm90IGNvcHkgJyR7c3JjfScgdG8gYSBzdWJkaXJlY3Rvcnkgb2YgaXRzZWxmLCAnJHtkZXN0fScuYClcbiAgICB9XG4gICAgcmV0dXJuIG1heUNvcHlEaXIoc3JjLCBkZXN0LCBvcHRzKVxuICB9IGVsc2Uge1xuICAgIGlmIChzcmMgPT09IHJlc29sdmVkUGF0aCkgcmV0dXJuXG4gICAgcmV0dXJuIGNvcHlEaXIoc3JjLCBkZXN0LCBvcHRzKVxuICB9XG59XG5cbmZ1bmN0aW9uIG1heUNvcHlEaXIgKHNyYywgZGVzdCwgb3B0cykge1xuICBpZiAoIWZzLnN0YXRTeW5jKGRlc3QpLmlzRGlyZWN0b3J5KCkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYENhbm5vdCBvdmVyd3JpdGUgbm9uLWRpcmVjdG9yeSAnJHtkZXN0fScgd2l0aCBkaXJlY3RvcnkgJyR7c3JjfScuYClcbiAgfVxuICByZXR1cm4gY29weURpcihzcmMsIGRlc3QsIG9wdHMpXG59XG5cbmZ1bmN0aW9uIG1rRGlyQW5kQ29weSAoc3JjU3RhdCwgc3JjLCBkZXN0LCBvcHRzKSB7XG4gIGZzLm1rZGlyU3luYyhkZXN0LCBzcmNTdGF0Lm1vZGUpXG4gIGZzLmNobW9kU3luYyhkZXN0LCBzcmNTdGF0Lm1vZGUpXG4gIHJldHVybiBjb3B5RGlyKHNyYywgZGVzdCwgb3B0cylcbn1cblxuZnVuY3Rpb24gY29weURpciAoc3JjLCBkZXN0LCBvcHRzKSB7XG4gIGZzLnJlYWRkaXJTeW5jKHNyYykuZm9yRWFjaChpdGVtID0+IHtcbiAgICBzdGFydENvcHkocGF0aC5qb2luKHNyYywgaXRlbSksIHBhdGguam9pbihkZXN0LCBpdGVtKSwgb3B0cylcbiAgfSlcbn1cblxuZnVuY3Rpb24gb25MaW5rIChzcmMsIGRlc3QsIG9wdHMpIHtcbiAgbGV0IHJlc29sdmVkU3JjUGF0aCA9IGZzLnJlYWRsaW5rU3luYyhzcmMpXG5cbiAgaWYgKG9wdHMuZGVyZWZlcmVuY2UpIHtcbiAgICByZXNvbHZlZFNyY1BhdGggPSBwYXRoLnJlc29sdmUocHJvY2Vzcy5jd2QoKSwgcmVzb2x2ZWRTcmNQYXRoKVxuICB9XG5cbiAgbGV0IHJlc29sdmVkRGVzdFBhdGggPSBjaGVja0Rlc3QoZGVzdClcbiAgaWYgKHJlc29sdmVkRGVzdFBhdGggPT09IG5vdEV4aXN0IHx8IHJlc29sdmVkRGVzdFBhdGggPT09IGV4aXN0c1JlZykge1xuICAgIC8vIGlmIGRlc3QgYWxyZWFkeSBleGlzdHMsIGZzIHRocm93cyBlcnJvciBhbnl3YXksXG4gICAgLy8gc28gbm8gbmVlZCB0byBndWFyZCBhZ2FpbnN0IGl0IGhlcmUuXG4gICAgcmV0dXJuIGZzLnN5bWxpbmtTeW5jKHJlc29sdmVkU3JjUGF0aCwgZGVzdClcbiAgfSBlbHNlIHtcbiAgICBpZiAob3B0cy5kZXJlZmVyZW5jZSkge1xuICAgICAgcmVzb2x2ZWREZXN0UGF0aCA9IHBhdGgucmVzb2x2ZShwcm9jZXNzLmN3ZCgpLCByZXNvbHZlZERlc3RQYXRoKVxuICAgIH1cbiAgICBpZiAocmVzb2x2ZWREZXN0UGF0aCA9PT0gcmVzb2x2ZWRTcmNQYXRoKSByZXR1cm5cblxuICAgIC8vIHByZXZlbnQgY29weSBpZiBzcmMgaXMgYSBzdWJkaXIgb2YgZGVzdCBzaW5jZSB1bmxpbmtpbmdcbiAgICAvLyBkZXN0IGluIHRoaXMgY2FzZSB3b3VsZCByZXN1bHQgaW4gcmVtb3Zpbmcgc3JjIGNvbnRlbnRzXG4gICAgLy8gYW5kIHRoZXJlZm9yZSBhIGJyb2tlbiBzeW1saW5rIHdvdWxkIGJlIGNyZWF0ZWQuXG4gICAgaWYgKGZzLnN0YXRTeW5jKGRlc3QpLmlzRGlyZWN0b3J5KCkgJiYgaXNTcmNTdWJkaXIocmVzb2x2ZWREZXN0UGF0aCwgcmVzb2x2ZWRTcmNQYXRoKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBDYW5ub3Qgb3ZlcndyaXRlICcke3Jlc29sdmVkRGVzdFBhdGh9JyB3aXRoICcke3Jlc29sdmVkU3JjUGF0aH0nLmApXG4gICAgfVxuICAgIHJldHVybiBjb3B5TGluayhyZXNvbHZlZFNyY1BhdGgsIGRlc3QpXG4gIH1cbn1cblxuZnVuY3Rpb24gY29weUxpbmsgKHJlc29sdmVkU3JjUGF0aCwgZGVzdCkge1xuICBmcy51bmxpbmtTeW5jKGRlc3QpXG4gIHJldHVybiBmcy5zeW1saW5rU3luYyhyZXNvbHZlZFNyY1BhdGgsIGRlc3QpXG59XG5cbi8vIGNoZWNrIGlmIGRlc3QgZXhpc3RzIGFuZC9vciBpcyBhIHN5bWxpbmtcbmZ1bmN0aW9uIGNoZWNrRGVzdCAoZGVzdCkge1xuICBsZXQgcmVzb2x2ZWRQYXRoXG4gIHRyeSB7XG4gICAgcmVzb2x2ZWRQYXRoID0gZnMucmVhZGxpbmtTeW5jKGRlc3QpXG4gIH0gY2F0Y2ggKGVycikge1xuICAgIGlmIChlcnIuY29kZSA9PT0gJ0VOT0VOVCcpIHJldHVybiBub3RFeGlzdFxuXG4gICAgLy8gZGVzdCBleGlzdHMgYW5kIGlzIGEgcmVndWxhciBmaWxlIG9yIGRpcmVjdG9yeSwgV2luZG93cyBtYXkgdGhyb3cgVU5LTk9XTiBlcnJvclxuICAgIGlmIChlcnIuY29kZSA9PT0gJ0VJTlZBTCcgfHwgZXJyLmNvZGUgPT09ICdVTktOT1dOJykgcmV0dXJuIGV4aXN0c1JlZ1xuXG4gICAgdGhyb3cgZXJyXG4gIH1cbiAgcmV0dXJuIHJlc29sdmVkUGF0aCAvLyBkZXN0IGV4aXN0cyBhbmQgaXMgYSBzeW1saW5rXG59XG5cbi8vIHJldHVybiB0cnVlIGlmIGRlc3QgaXMgYSBzdWJkaXIgb2Ygc3JjLCBvdGhlcndpc2UgZmFsc2UuXG4vLyBleHRyYWN0IGRlc3QgYmFzZSBkaXIgYW5kIGNoZWNrIGlmIHRoYXQgaXMgdGhlIHNhbWUgYXMgc3JjIGJhc2VuYW1lXG5mdW5jdGlvbiBpc1NyY1N1YmRpciAoc3JjLCBkZXN0KSB7XG4gIGNvbnN0IGJhc2VEaXIgPSBkZXN0LnNwbGl0KHBhdGguZGlybmFtZShzcmMpICsgcGF0aC5zZXApWzFdXG4gIGlmIChiYXNlRGlyKSB7XG4gICAgY29uc3QgZGVzdEJhc2VuYW1lID0gYmFzZURpci5zcGxpdChwYXRoLnNlcClbMF1cbiAgICBpZiAoZGVzdEJhc2VuYW1lKSB7XG4gICAgICByZXR1cm4gc3JjICE9PSBkZXN0ICYmIGRlc3QuaW5kZXhPZihzcmMpID4gLTEgJiYgZGVzdEJhc2VuYW1lID09PSBwYXRoLmJhc2VuYW1lKHNyYylcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cbiAgcmV0dXJuIGZhbHNlXG59XG5cbm1vZHVsZS5leHBvcnRzID0gY29weVN5bmNcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9lbGVjdHJvbi11cGRhdGVyL25vZGVfbW9kdWxlcy9mcy1leHRyYS9saWIvY29weS1zeW5jL2NvcHktc3luYy5qcyIsIid1c2Ugc3RyaWN0J1xuXG5jb25zdCBmcyA9IHJlcXVpcmUoJ2dyYWNlZnVsLWZzJylcbmNvbnN0IHBhdGggPSByZXF1aXJlKCdwYXRoJylcbmNvbnN0IGFzc2VydCA9IHJlcXVpcmUoJ2Fzc2VydCcpXG5cbmNvbnN0IGlzV2luZG93cyA9IChwcm9jZXNzLnBsYXRmb3JtID09PSAnd2luMzInKVxuXG5mdW5jdGlvbiBkZWZhdWx0cyAob3B0aW9ucykge1xuICBjb25zdCBtZXRob2RzID0gW1xuICAgICd1bmxpbmsnLFxuICAgICdjaG1vZCcsXG4gICAgJ3N0YXQnLFxuICAgICdsc3RhdCcsXG4gICAgJ3JtZGlyJyxcbiAgICAncmVhZGRpcidcbiAgXVxuICBtZXRob2RzLmZvckVhY2gobSA9PiB7XG4gICAgb3B0aW9uc1ttXSA9IG9wdGlvbnNbbV0gfHwgZnNbbV1cbiAgICBtID0gbSArICdTeW5jJ1xuICAgIG9wdGlvbnNbbV0gPSBvcHRpb25zW21dIHx8IGZzW21dXG4gIH0pXG5cbiAgb3B0aW9ucy5tYXhCdXN5VHJpZXMgPSBvcHRpb25zLm1heEJ1c3lUcmllcyB8fCAzXG59XG5cbmZ1bmN0aW9uIHJpbXJhZiAocCwgb3B0aW9ucywgY2IpIHtcbiAgbGV0IGJ1c3lUcmllcyA9IDBcblxuICBpZiAodHlwZW9mIG9wdGlvbnMgPT09ICdmdW5jdGlvbicpIHtcbiAgICBjYiA9IG9wdGlvbnNcbiAgICBvcHRpb25zID0ge31cbiAgfVxuXG4gIGFzc2VydChwLCAncmltcmFmOiBtaXNzaW5nIHBhdGgnKVxuICBhc3NlcnQuZXF1YWwodHlwZW9mIHAsICdzdHJpbmcnLCAncmltcmFmOiBwYXRoIHNob3VsZCBiZSBhIHN0cmluZycpXG4gIGFzc2VydC5lcXVhbCh0eXBlb2YgY2IsICdmdW5jdGlvbicsICdyaW1yYWY6IGNhbGxiYWNrIGZ1bmN0aW9uIHJlcXVpcmVkJylcbiAgYXNzZXJ0KG9wdGlvbnMsICdyaW1yYWY6IGludmFsaWQgb3B0aW9ucyBhcmd1bWVudCBwcm92aWRlZCcpXG4gIGFzc2VydC5lcXVhbCh0eXBlb2Ygb3B0aW9ucywgJ29iamVjdCcsICdyaW1yYWY6IG9wdGlvbnMgc2hvdWxkIGJlIG9iamVjdCcpXG5cbiAgZGVmYXVsdHMob3B0aW9ucylcblxuICByaW1yYWZfKHAsIG9wdGlvbnMsIGZ1bmN0aW9uIENCIChlcikge1xuICAgIGlmIChlcikge1xuICAgICAgaWYgKChlci5jb2RlID09PSAnRUJVU1knIHx8IGVyLmNvZGUgPT09ICdFTk9URU1QVFknIHx8IGVyLmNvZGUgPT09ICdFUEVSTScpICYmXG4gICAgICAgICAgYnVzeVRyaWVzIDwgb3B0aW9ucy5tYXhCdXN5VHJpZXMpIHtcbiAgICAgICAgYnVzeVRyaWVzKytcbiAgICAgICAgbGV0IHRpbWUgPSBidXN5VHJpZXMgKiAxMDBcbiAgICAgICAgLy8gdHJ5IGFnYWluLCB3aXRoIHRoZSBzYW1lIGV4YWN0IGNhbGxiYWNrIGFzIHRoaXMgb25lLlxuICAgICAgICByZXR1cm4gc2V0VGltZW91dCgoKSA9PiByaW1yYWZfKHAsIG9wdGlvbnMsIENCKSwgdGltZSlcbiAgICAgIH1cblxuICAgICAgLy8gYWxyZWFkeSBnb25lXG4gICAgICBpZiAoZXIuY29kZSA9PT0gJ0VOT0VOVCcpIGVyID0gbnVsbFxuICAgIH1cblxuICAgIGNiKGVyKVxuICB9KVxufVxuXG4vLyBUd28gcG9zc2libGUgc3RyYXRlZ2llcy5cbi8vIDEuIEFzc3VtZSBpdCdzIGEgZmlsZS4gIHVubGluayBpdCwgdGhlbiBkbyB0aGUgZGlyIHN0dWZmIG9uIEVQRVJNIG9yIEVJU0RJUlxuLy8gMi4gQXNzdW1lIGl0J3MgYSBkaXJlY3RvcnkuICByZWFkZGlyLCB0aGVuIGRvIHRoZSBmaWxlIHN0dWZmIG9uIEVOT1RESVJcbi8vXG4vLyBCb3RoIHJlc3VsdCBpbiBhbiBleHRyYSBzeXNjYWxsIHdoZW4geW91IGd1ZXNzIHdyb25nLiAgSG93ZXZlciwgdGhlcmVcbi8vIGFyZSBsaWtlbHkgZmFyIG1vcmUgbm9ybWFsIGZpbGVzIGluIHRoZSB3b3JsZCB0aGFuIGRpcmVjdG9yaWVzLiAgVGhpc1xuLy8gaXMgYmFzZWQgb24gdGhlIGFzc3VtcHRpb24gdGhhdCBhIHRoZSBhdmVyYWdlIG51bWJlciBvZiBmaWxlcyBwZXJcbi8vIGRpcmVjdG9yeSBpcyA+PSAxLlxuLy9cbi8vIElmIGFueW9uZSBldmVyIGNvbXBsYWlucyBhYm91dCB0aGlzLCB0aGVuIEkgZ3Vlc3MgdGhlIHN0cmF0ZWd5IGNvdWxkXG4vLyBiZSBtYWRlIGNvbmZpZ3VyYWJsZSBzb21laG93LiAgQnV0IHVudGlsIHRoZW4sIFlBR05JLlxuZnVuY3Rpb24gcmltcmFmXyAocCwgb3B0aW9ucywgY2IpIHtcbiAgYXNzZXJ0KHApXG4gIGFzc2VydChvcHRpb25zKVxuICBhc3NlcnQodHlwZW9mIGNiID09PSAnZnVuY3Rpb24nKVxuXG4gIC8vIHN1bm9zIGxldHMgdGhlIHJvb3QgdXNlciB1bmxpbmsgZGlyZWN0b3JpZXMsIHdoaWNoIGlzLi4uIHdlaXJkLlxuICAvLyBzbyB3ZSBoYXZlIHRvIGxzdGF0IGhlcmUgYW5kIG1ha2Ugc3VyZSBpdCdzIG5vdCBhIGRpci5cbiAgb3B0aW9ucy5sc3RhdChwLCAoZXIsIHN0KSA9PiB7XG4gICAgaWYgKGVyICYmIGVyLmNvZGUgPT09ICdFTk9FTlQnKSB7XG4gICAgICByZXR1cm4gY2IobnVsbClcbiAgICB9XG5cbiAgICAvLyBXaW5kb3dzIGNhbiBFUEVSTSBvbiBzdGF0LiAgTGlmZSBpcyBzdWZmZXJpbmcuXG4gICAgaWYgKGVyICYmIGVyLmNvZGUgPT09ICdFUEVSTScgJiYgaXNXaW5kb3dzKSB7XG4gICAgICByZXR1cm4gZml4V2luRVBFUk0ocCwgb3B0aW9ucywgZXIsIGNiKVxuICAgIH1cblxuICAgIGlmIChzdCAmJiBzdC5pc0RpcmVjdG9yeSgpKSB7XG4gICAgICByZXR1cm4gcm1kaXIocCwgb3B0aW9ucywgZXIsIGNiKVxuICAgIH1cblxuICAgIG9wdGlvbnMudW5saW5rKHAsIGVyID0+IHtcbiAgICAgIGlmIChlcikge1xuICAgICAgICBpZiAoZXIuY29kZSA9PT0gJ0VOT0VOVCcpIHtcbiAgICAgICAgICByZXR1cm4gY2IobnVsbClcbiAgICAgICAgfVxuICAgICAgICBpZiAoZXIuY29kZSA9PT0gJ0VQRVJNJykge1xuICAgICAgICAgIHJldHVybiAoaXNXaW5kb3dzKVxuICAgICAgICAgICAgPyBmaXhXaW5FUEVSTShwLCBvcHRpb25zLCBlciwgY2IpXG4gICAgICAgICAgICA6IHJtZGlyKHAsIG9wdGlvbnMsIGVyLCBjYilcbiAgICAgICAgfVxuICAgICAgICBpZiAoZXIuY29kZSA9PT0gJ0VJU0RJUicpIHtcbiAgICAgICAgICByZXR1cm4gcm1kaXIocCwgb3B0aW9ucywgZXIsIGNiKVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gY2IoZXIpXG4gICAgfSlcbiAgfSlcbn1cblxuZnVuY3Rpb24gZml4V2luRVBFUk0gKHAsIG9wdGlvbnMsIGVyLCBjYikge1xuICBhc3NlcnQocClcbiAgYXNzZXJ0KG9wdGlvbnMpXG4gIGFzc2VydCh0eXBlb2YgY2IgPT09ICdmdW5jdGlvbicpXG4gIGlmIChlcikge1xuICAgIGFzc2VydChlciBpbnN0YW5jZW9mIEVycm9yKVxuICB9XG5cbiAgb3B0aW9ucy5jaG1vZChwLCAwbzY2NiwgZXIyID0+IHtcbiAgICBpZiAoZXIyKSB7XG4gICAgICBjYihlcjIuY29kZSA9PT0gJ0VOT0VOVCcgPyBudWxsIDogZXIpXG4gICAgfSBlbHNlIHtcbiAgICAgIG9wdGlvbnMuc3RhdChwLCAoZXIzLCBzdGF0cykgPT4ge1xuICAgICAgICBpZiAoZXIzKSB7XG4gICAgICAgICAgY2IoZXIzLmNvZGUgPT09ICdFTk9FTlQnID8gbnVsbCA6IGVyKVxuICAgICAgICB9IGVsc2UgaWYgKHN0YXRzLmlzRGlyZWN0b3J5KCkpIHtcbiAgICAgICAgICBybWRpcihwLCBvcHRpb25zLCBlciwgY2IpXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgb3B0aW9ucy51bmxpbmsocCwgY2IpXG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgfVxuICB9KVxufVxuXG5mdW5jdGlvbiBmaXhXaW5FUEVSTVN5bmMgKHAsIG9wdGlvbnMsIGVyKSB7XG4gIGxldCBzdGF0c1xuXG4gIGFzc2VydChwKVxuICBhc3NlcnQob3B0aW9ucylcbiAgaWYgKGVyKSB7XG4gICAgYXNzZXJ0KGVyIGluc3RhbmNlb2YgRXJyb3IpXG4gIH1cblxuICB0cnkge1xuICAgIG9wdGlvbnMuY2htb2RTeW5jKHAsIDBvNjY2KVxuICB9IGNhdGNoIChlcjIpIHtcbiAgICBpZiAoZXIyLmNvZGUgPT09ICdFTk9FTlQnKSB7XG4gICAgICByZXR1cm5cbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgZXJcbiAgICB9XG4gIH1cblxuICB0cnkge1xuICAgIHN0YXRzID0gb3B0aW9ucy5zdGF0U3luYyhwKVxuICB9IGNhdGNoIChlcjMpIHtcbiAgICBpZiAoZXIzLmNvZGUgPT09ICdFTk9FTlQnKSB7XG4gICAgICByZXR1cm5cbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgZXJcbiAgICB9XG4gIH1cblxuICBpZiAoc3RhdHMuaXNEaXJlY3RvcnkoKSkge1xuICAgIHJtZGlyU3luYyhwLCBvcHRpb25zLCBlcilcbiAgfSBlbHNlIHtcbiAgICBvcHRpb25zLnVubGlua1N5bmMocClcbiAgfVxufVxuXG5mdW5jdGlvbiBybWRpciAocCwgb3B0aW9ucywgb3JpZ2luYWxFciwgY2IpIHtcbiAgYXNzZXJ0KHApXG4gIGFzc2VydChvcHRpb25zKVxuICBpZiAob3JpZ2luYWxFcikge1xuICAgIGFzc2VydChvcmlnaW5hbEVyIGluc3RhbmNlb2YgRXJyb3IpXG4gIH1cbiAgYXNzZXJ0KHR5cGVvZiBjYiA9PT0gJ2Z1bmN0aW9uJylcblxuICAvLyB0cnkgdG8gcm1kaXIgZmlyc3QsIGFuZCBvbmx5IHJlYWRkaXIgb24gRU5PVEVNUFRZIG9yIEVFWElTVCAoU3VuT1MpXG4gIC8vIGlmIHdlIGd1ZXNzZWQgd3JvbmcsIGFuZCBpdCdzIG5vdCBhIGRpcmVjdG9yeSwgdGhlblxuICAvLyByYWlzZSB0aGUgb3JpZ2luYWwgZXJyb3IuXG4gIG9wdGlvbnMucm1kaXIocCwgZXIgPT4ge1xuICAgIGlmIChlciAmJiAoZXIuY29kZSA9PT0gJ0VOT1RFTVBUWScgfHwgZXIuY29kZSA9PT0gJ0VFWElTVCcgfHwgZXIuY29kZSA9PT0gJ0VQRVJNJykpIHtcbiAgICAgIHJta2lkcyhwLCBvcHRpb25zLCBjYilcbiAgICB9IGVsc2UgaWYgKGVyICYmIGVyLmNvZGUgPT09ICdFTk9URElSJykge1xuICAgICAgY2Iob3JpZ2luYWxFcilcbiAgICB9IGVsc2Uge1xuICAgICAgY2IoZXIpXG4gICAgfVxuICB9KVxufVxuXG5mdW5jdGlvbiBybWtpZHMgKHAsIG9wdGlvbnMsIGNiKSB7XG4gIGFzc2VydChwKVxuICBhc3NlcnQob3B0aW9ucylcbiAgYXNzZXJ0KHR5cGVvZiBjYiA9PT0gJ2Z1bmN0aW9uJylcblxuICBvcHRpb25zLnJlYWRkaXIocCwgKGVyLCBmaWxlcykgPT4ge1xuICAgIGlmIChlcikgcmV0dXJuIGNiKGVyKVxuXG4gICAgbGV0IG4gPSBmaWxlcy5sZW5ndGhcbiAgICBsZXQgZXJyU3RhdGVcblxuICAgIGlmIChuID09PSAwKSByZXR1cm4gb3B0aW9ucy5ybWRpcihwLCBjYilcblxuICAgIGZpbGVzLmZvckVhY2goZiA9PiB7XG4gICAgICByaW1yYWYocGF0aC5qb2luKHAsIGYpLCBvcHRpb25zLCBlciA9PiB7XG4gICAgICAgIGlmIChlcnJTdGF0ZSkge1xuICAgICAgICAgIHJldHVyblxuICAgICAgICB9XG4gICAgICAgIGlmIChlcikgcmV0dXJuIGNiKGVyclN0YXRlID0gZXIpXG4gICAgICAgIGlmICgtLW4gPT09IDApIHtcbiAgICAgICAgICBvcHRpb25zLnJtZGlyKHAsIGNiKVxuICAgICAgICB9XG4gICAgICB9KVxuICAgIH0pXG4gIH0pXG59XG5cbi8vIHRoaXMgbG9va3Mgc2ltcGxlciwgYW5kIGlzIHN0cmljdGx5ICpmYXN0ZXIqLCBidXQgd2lsbFxuLy8gdGllIHVwIHRoZSBKYXZhU2NyaXB0IHRocmVhZCBhbmQgZmFpbCBvbiBleGNlc3NpdmVseVxuLy8gZGVlcCBkaXJlY3RvcnkgdHJlZXMuXG5mdW5jdGlvbiByaW1yYWZTeW5jIChwLCBvcHRpb25zKSB7XG4gIGxldCBzdFxuXG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9XG4gIGRlZmF1bHRzKG9wdGlvbnMpXG5cbiAgYXNzZXJ0KHAsICdyaW1yYWY6IG1pc3NpbmcgcGF0aCcpXG4gIGFzc2VydC5lcXVhbCh0eXBlb2YgcCwgJ3N0cmluZycsICdyaW1yYWY6IHBhdGggc2hvdWxkIGJlIGEgc3RyaW5nJylcbiAgYXNzZXJ0KG9wdGlvbnMsICdyaW1yYWY6IG1pc3Npbmcgb3B0aW9ucycpXG4gIGFzc2VydC5lcXVhbCh0eXBlb2Ygb3B0aW9ucywgJ29iamVjdCcsICdyaW1yYWY6IG9wdGlvbnMgc2hvdWxkIGJlIG9iamVjdCcpXG5cbiAgdHJ5IHtcbiAgICBzdCA9IG9wdGlvbnMubHN0YXRTeW5jKHApXG4gIH0gY2F0Y2ggKGVyKSB7XG4gICAgaWYgKGVyLmNvZGUgPT09ICdFTk9FTlQnKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICAvLyBXaW5kb3dzIGNhbiBFUEVSTSBvbiBzdGF0LiAgTGlmZSBpcyBzdWZmZXJpbmcuXG4gICAgaWYgKGVyLmNvZGUgPT09ICdFUEVSTScgJiYgaXNXaW5kb3dzKSB7XG4gICAgICBmaXhXaW5FUEVSTVN5bmMocCwgb3B0aW9ucywgZXIpXG4gICAgfVxuICB9XG5cbiAgdHJ5IHtcbiAgICAvLyBzdW5vcyBsZXRzIHRoZSByb290IHVzZXIgdW5saW5rIGRpcmVjdG9yaWVzLCB3aGljaCBpcy4uLiB3ZWlyZC5cbiAgICBpZiAoc3QgJiYgc3QuaXNEaXJlY3RvcnkoKSkge1xuICAgICAgcm1kaXJTeW5jKHAsIG9wdGlvbnMsIG51bGwpXG4gICAgfSBlbHNlIHtcbiAgICAgIG9wdGlvbnMudW5saW5rU3luYyhwKVxuICAgIH1cbiAgfSBjYXRjaCAoZXIpIHtcbiAgICBpZiAoZXIuY29kZSA9PT0gJ0VOT0VOVCcpIHtcbiAgICAgIHJldHVyblxuICAgIH0gZWxzZSBpZiAoZXIuY29kZSA9PT0gJ0VQRVJNJykge1xuICAgICAgcmV0dXJuIGlzV2luZG93cyA/IGZpeFdpbkVQRVJNU3luYyhwLCBvcHRpb25zLCBlcikgOiBybWRpclN5bmMocCwgb3B0aW9ucywgZXIpXG4gICAgfSBlbHNlIGlmIChlci5jb2RlICE9PSAnRUlTRElSJykge1xuICAgICAgdGhyb3cgZXJcbiAgICB9XG4gICAgcm1kaXJTeW5jKHAsIG9wdGlvbnMsIGVyKVxuICB9XG59XG5cbmZ1bmN0aW9uIHJtZGlyU3luYyAocCwgb3B0aW9ucywgb3JpZ2luYWxFcikge1xuICBhc3NlcnQocClcbiAgYXNzZXJ0KG9wdGlvbnMpXG4gIGlmIChvcmlnaW5hbEVyKSB7XG4gICAgYXNzZXJ0KG9yaWdpbmFsRXIgaW5zdGFuY2VvZiBFcnJvcilcbiAgfVxuXG4gIHRyeSB7XG4gICAgb3B0aW9ucy5ybWRpclN5bmMocClcbiAgfSBjYXRjaCAoZXIpIHtcbiAgICBpZiAoZXIuY29kZSA9PT0gJ0VOT1RESVInKSB7XG4gICAgICB0aHJvdyBvcmlnaW5hbEVyXG4gICAgfSBlbHNlIGlmIChlci5jb2RlID09PSAnRU5PVEVNUFRZJyB8fCBlci5jb2RlID09PSAnRUVYSVNUJyB8fCBlci5jb2RlID09PSAnRVBFUk0nKSB7XG4gICAgICBybWtpZHNTeW5jKHAsIG9wdGlvbnMpXG4gICAgfSBlbHNlIGlmIChlci5jb2RlICE9PSAnRU5PRU5UJykge1xuICAgICAgdGhyb3cgZXJcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gcm1raWRzU3luYyAocCwgb3B0aW9ucykge1xuICBhc3NlcnQocClcbiAgYXNzZXJ0KG9wdGlvbnMpXG4gIG9wdGlvbnMucmVhZGRpclN5bmMocCkuZm9yRWFjaChmID0+IHJpbXJhZlN5bmMocGF0aC5qb2luKHAsIGYpLCBvcHRpb25zKSlcblxuICAvLyBXZSBvbmx5IGVuZCB1cCBoZXJlIG9uY2Ugd2UgZ290IEVOT1RFTVBUWSBhdCBsZWFzdCBvbmNlLCBhbmRcbiAgLy8gYXQgdGhpcyBwb2ludCwgd2UgYXJlIGd1YXJhbnRlZWQgdG8gaGF2ZSByZW1vdmVkIGFsbCB0aGUga2lkcy5cbiAgLy8gU28sIHdlIGtub3cgdGhhdCBpdCB3b24ndCBiZSBFTk9FTlQgb3IgRU5PVERJUiBvciBhbnl0aGluZyBlbHNlLlxuICAvLyB0cnkgcmVhbGx5IGhhcmQgdG8gZGVsZXRlIHN0dWZmIG9uIHdpbmRvd3MsIGJlY2F1c2UgaXQgaGFzIGFcbiAgLy8gUFJPRk9VTkRMWSBhbm5veWluZyBoYWJpdCBvZiBub3QgY2xvc2luZyBoYW5kbGVzIHByb21wdGx5IHdoZW5cbiAgLy8gZmlsZXMgYXJlIGRlbGV0ZWQsIHJlc3VsdGluZyBpbiBzcHVyaW91cyBFTk9URU1QVFkgZXJyb3JzLlxuICBjb25zdCByZXRyaWVzID0gaXNXaW5kb3dzID8gMTAwIDogMVxuICBsZXQgaSA9IDBcbiAgZG8ge1xuICAgIGxldCB0aHJldyA9IHRydWVcbiAgICB0cnkge1xuICAgICAgY29uc3QgcmV0ID0gb3B0aW9ucy5ybWRpclN5bmMocCwgb3B0aW9ucylcbiAgICAgIHRocmV3ID0gZmFsc2VcbiAgICAgIHJldHVybiByZXRcbiAgICB9IGZpbmFsbHkge1xuICAgICAgaWYgKCsraSA8IHJldHJpZXMgJiYgdGhyZXcpIGNvbnRpbnVlIC8vIGVzbGludC1kaXNhYmxlLWxpbmVcbiAgICB9XG4gIH0gd2hpbGUgKHRydWUpXG59XG5cbm1vZHVsZS5leHBvcnRzID0gcmltcmFmXG5yaW1yYWYuc3luYyA9IHJpbXJhZlN5bmNcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9lbGVjdHJvbi11cGRhdGVyL25vZGVfbW9kdWxlcy9mcy1leHRyYS9saWIvcmVtb3ZlL3JpbXJhZi5qcyIsIid1c2Ugc3RyaWN0J1xuXG5jb25zdCB1ID0gcmVxdWlyZSgndW5pdmVyc2FsaWZ5JykuZnJvbUNhbGxiYWNrXG5jb25zdCBqc29uRmlsZSA9IHJlcXVpcmUoJy4vanNvbmZpbGUnKVxuXG5qc29uRmlsZS5vdXRwdXRKc29uID0gdShyZXF1aXJlKCcuL291dHB1dC1qc29uJykpXG5qc29uRmlsZS5vdXRwdXRKc29uU3luYyA9IHJlcXVpcmUoJy4vb3V0cHV0LWpzb24tc3luYycpXG4vLyBhbGlhc2VzXG5qc29uRmlsZS5vdXRwdXRKU09OID0ganNvbkZpbGUub3V0cHV0SnNvblxuanNvbkZpbGUub3V0cHV0SlNPTlN5bmMgPSBqc29uRmlsZS5vdXRwdXRKc29uU3luY1xuanNvbkZpbGUud3JpdGVKU09OID0ganNvbkZpbGUud3JpdGVKc29uXG5qc29uRmlsZS53cml0ZUpTT05TeW5jID0ganNvbkZpbGUud3JpdGVKc29uU3luY1xuanNvbkZpbGUucmVhZEpTT04gPSBqc29uRmlsZS5yZWFkSnNvblxuanNvbkZpbGUucmVhZEpTT05TeW5jID0ganNvbkZpbGUucmVhZEpzb25TeW5jXG5cbm1vZHVsZS5leHBvcnRzID0ganNvbkZpbGVcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9lbGVjdHJvbi11cGRhdGVyL25vZGVfbW9kdWxlcy9mcy1leHRyYS9saWIvanNvbi9pbmRleC5qcyIsInZhciBfZnNcbnRyeSB7XG4gIF9mcyA9IHJlcXVpcmUoJ2dyYWNlZnVsLWZzJylcbn0gY2F0Y2ggKF8pIHtcbiAgX2ZzID0gcmVxdWlyZSgnZnMnKVxufVxuXG5mdW5jdGlvbiByZWFkRmlsZSAoZmlsZSwgb3B0aW9ucywgY2FsbGJhY2spIHtcbiAgaWYgKGNhbGxiYWNrID09IG51bGwpIHtcbiAgICBjYWxsYmFjayA9IG9wdGlvbnNcbiAgICBvcHRpb25zID0ge31cbiAgfVxuXG4gIGlmICh0eXBlb2Ygb3B0aW9ucyA9PT0gJ3N0cmluZycpIHtcbiAgICBvcHRpb25zID0ge2VuY29kaW5nOiBvcHRpb25zfVxuICB9XG5cbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge31cbiAgdmFyIGZzID0gb3B0aW9ucy5mcyB8fCBfZnNcblxuICB2YXIgc2hvdWxkVGhyb3cgPSB0cnVlXG4gIGlmICgndGhyb3dzJyBpbiBvcHRpb25zKSB7XG4gICAgc2hvdWxkVGhyb3cgPSBvcHRpb25zLnRocm93c1xuICB9XG5cbiAgZnMucmVhZEZpbGUoZmlsZSwgb3B0aW9ucywgZnVuY3Rpb24gKGVyciwgZGF0YSkge1xuICAgIGlmIChlcnIpIHJldHVybiBjYWxsYmFjayhlcnIpXG5cbiAgICBkYXRhID0gc3RyaXBCb20oZGF0YSlcblxuICAgIHZhciBvYmpcbiAgICB0cnkge1xuICAgICAgb2JqID0gSlNPTi5wYXJzZShkYXRhLCBvcHRpb25zID8gb3B0aW9ucy5yZXZpdmVyIDogbnVsbClcbiAgICB9IGNhdGNoIChlcnIyKSB7XG4gICAgICBpZiAoc2hvdWxkVGhyb3cpIHtcbiAgICAgICAgZXJyMi5tZXNzYWdlID0gZmlsZSArICc6ICcgKyBlcnIyLm1lc3NhZ2VcbiAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGVycjIpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gY2FsbGJhY2sobnVsbCwgbnVsbClcbiAgICAgIH1cbiAgICB9XG5cbiAgICBjYWxsYmFjayhudWxsLCBvYmopXG4gIH0pXG59XG5cbmZ1bmN0aW9uIHJlYWRGaWxlU3luYyAoZmlsZSwgb3B0aW9ucykge1xuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fVxuICBpZiAodHlwZW9mIG9wdGlvbnMgPT09ICdzdHJpbmcnKSB7XG4gICAgb3B0aW9ucyA9IHtlbmNvZGluZzogb3B0aW9uc31cbiAgfVxuXG4gIHZhciBmcyA9IG9wdGlvbnMuZnMgfHwgX2ZzXG5cbiAgdmFyIHNob3VsZFRocm93ID0gdHJ1ZVxuICBpZiAoJ3Rocm93cycgaW4gb3B0aW9ucykge1xuICAgIHNob3VsZFRocm93ID0gb3B0aW9ucy50aHJvd3NcbiAgfVxuXG4gIHRyeSB7XG4gICAgdmFyIGNvbnRlbnQgPSBmcy5yZWFkRmlsZVN5bmMoZmlsZSwgb3B0aW9ucylcbiAgICBjb250ZW50ID0gc3RyaXBCb20oY29udGVudClcbiAgICByZXR1cm4gSlNPTi5wYXJzZShjb250ZW50LCBvcHRpb25zLnJldml2ZXIpXG4gIH0gY2F0Y2ggKGVycikge1xuICAgIGlmIChzaG91bGRUaHJvdykge1xuICAgICAgZXJyLm1lc3NhZ2UgPSBmaWxlICsgJzogJyArIGVyci5tZXNzYWdlXG4gICAgICB0aHJvdyBlcnJcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIG51bGxcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gc3RyaW5naWZ5IChvYmosIG9wdGlvbnMpIHtcbiAgdmFyIHNwYWNlc1xuICB2YXIgRU9MID0gJ1xcbidcbiAgaWYgKHR5cGVvZiBvcHRpb25zID09PSAnb2JqZWN0JyAmJiBvcHRpb25zICE9PSBudWxsKSB7XG4gICAgaWYgKG9wdGlvbnMuc3BhY2VzKSB7XG4gICAgICBzcGFjZXMgPSBvcHRpb25zLnNwYWNlc1xuICAgIH1cbiAgICBpZiAob3B0aW9ucy5FT0wpIHtcbiAgICAgIEVPTCA9IG9wdGlvbnMuRU9MXG4gICAgfVxuICB9XG5cbiAgdmFyIHN0ciA9IEpTT04uc3RyaW5naWZ5KG9iaiwgb3B0aW9ucyA/IG9wdGlvbnMucmVwbGFjZXIgOiBudWxsLCBzcGFjZXMpXG5cbiAgcmV0dXJuIHN0ci5yZXBsYWNlKC9cXG4vZywgRU9MKSArIEVPTFxufVxuXG5mdW5jdGlvbiB3cml0ZUZpbGUgKGZpbGUsIG9iaiwgb3B0aW9ucywgY2FsbGJhY2spIHtcbiAgaWYgKGNhbGxiYWNrID09IG51bGwpIHtcbiAgICBjYWxsYmFjayA9IG9wdGlvbnNcbiAgICBvcHRpb25zID0ge31cbiAgfVxuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fVxuICB2YXIgZnMgPSBvcHRpb25zLmZzIHx8IF9mc1xuXG4gIHZhciBzdHIgPSAnJ1xuICB0cnkge1xuICAgIHN0ciA9IHN0cmluZ2lmeShvYmosIG9wdGlvbnMpXG4gIH0gY2F0Y2ggKGVycikge1xuICAgIC8vIE5lZWQgdG8gcmV0dXJuIHdoZXRoZXIgYSBjYWxsYmFjayB3YXMgcGFzc2VkIG9yIG5vdFxuICAgIGlmIChjYWxsYmFjaykgY2FsbGJhY2soZXJyLCBudWxsKVxuICAgIHJldHVyblxuICB9XG5cbiAgZnMud3JpdGVGaWxlKGZpbGUsIHN0ciwgb3B0aW9ucywgY2FsbGJhY2spXG59XG5cbmZ1bmN0aW9uIHdyaXRlRmlsZVN5bmMgKGZpbGUsIG9iaiwgb3B0aW9ucykge1xuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fVxuICB2YXIgZnMgPSBvcHRpb25zLmZzIHx8IF9mc1xuXG4gIHZhciBzdHIgPSBzdHJpbmdpZnkob2JqLCBvcHRpb25zKVxuICAvLyBub3Qgc3VyZSBpZiBmcy53cml0ZUZpbGVTeW5jIHJldHVybnMgYW55dGhpbmcsIGJ1dCBqdXN0IGluIGNhc2VcbiAgcmV0dXJuIGZzLndyaXRlRmlsZVN5bmMoZmlsZSwgc3RyLCBvcHRpb25zKVxufVxuXG5mdW5jdGlvbiBzdHJpcEJvbSAoY29udGVudCkge1xuICAvLyB3ZSBkbyB0aGlzIGJlY2F1c2UgSlNPTi5wYXJzZSB3b3VsZCBjb252ZXJ0IGl0IHRvIGEgdXRmOCBzdHJpbmcgaWYgZW5jb2Rpbmcgd2Fzbid0IHNwZWNpZmllZFxuICBpZiAoQnVmZmVyLmlzQnVmZmVyKGNvbnRlbnQpKSBjb250ZW50ID0gY29udGVudC50b1N0cmluZygndXRmOCcpXG4gIGNvbnRlbnQgPSBjb250ZW50LnJlcGxhY2UoL15cXHVGRUZGLywgJycpXG4gIHJldHVybiBjb250ZW50XG59XG5cbnZhciBqc29uZmlsZSA9IHtcbiAgcmVhZEZpbGU6IHJlYWRGaWxlLFxuICByZWFkRmlsZVN5bmM6IHJlYWRGaWxlU3luYyxcbiAgd3JpdGVGaWxlOiB3cml0ZUZpbGUsXG4gIHdyaXRlRmlsZVN5bmM6IHdyaXRlRmlsZVN5bmNcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBqc29uZmlsZVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2pzb25maWxlL2luZGV4LmpzIiwiJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IHBhdGggPSByZXF1aXJlKCdwYXRoJylcbmNvbnN0IG1rZGlyID0gcmVxdWlyZSgnLi4vbWtkaXJzJylcbmNvbnN0IHBhdGhFeGlzdHMgPSByZXF1aXJlKCcuLi9wYXRoLWV4aXN0cycpLnBhdGhFeGlzdHNcbmNvbnN0IGpzb25GaWxlID0gcmVxdWlyZSgnLi9qc29uZmlsZScpXG5cbmZ1bmN0aW9uIG91dHB1dEpzb24gKGZpbGUsIGRhdGEsIG9wdGlvbnMsIGNhbGxiYWNrKSB7XG4gIGlmICh0eXBlb2Ygb3B0aW9ucyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGNhbGxiYWNrID0gb3B0aW9uc1xuICAgIG9wdGlvbnMgPSB7fVxuICB9XG5cbiAgY29uc3QgZGlyID0gcGF0aC5kaXJuYW1lKGZpbGUpXG5cbiAgcGF0aEV4aXN0cyhkaXIsIChlcnIsIGl0RG9lcykgPT4ge1xuICAgIGlmIChlcnIpIHJldHVybiBjYWxsYmFjayhlcnIpXG4gICAgaWYgKGl0RG9lcykgcmV0dXJuIGpzb25GaWxlLndyaXRlSnNvbihmaWxlLCBkYXRhLCBvcHRpb25zLCBjYWxsYmFjaylcblxuICAgIG1rZGlyLm1rZGlycyhkaXIsIGVyciA9PiB7XG4gICAgICBpZiAoZXJyKSByZXR1cm4gY2FsbGJhY2soZXJyKVxuICAgICAganNvbkZpbGUud3JpdGVKc29uKGZpbGUsIGRhdGEsIG9wdGlvbnMsIGNhbGxiYWNrKVxuICAgIH0pXG4gIH0pXG59XG5cbm1vZHVsZS5leHBvcnRzID0gb3V0cHV0SnNvblxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2VsZWN0cm9uLXVwZGF0ZXIvbm9kZV9tb2R1bGVzL2ZzLWV4dHJhL2xpYi9qc29uL291dHB1dC1qc29uLmpzIiwiJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IGZzID0gcmVxdWlyZSgnZ3JhY2VmdWwtZnMnKVxuY29uc3QgcGF0aCA9IHJlcXVpcmUoJ3BhdGgnKVxuY29uc3QgbWtkaXIgPSByZXF1aXJlKCcuLi9ta2RpcnMnKVxuY29uc3QganNvbkZpbGUgPSByZXF1aXJlKCcuL2pzb25maWxlJylcblxuZnVuY3Rpb24gb3V0cHV0SnNvblN5bmMgKGZpbGUsIGRhdGEsIG9wdGlvbnMpIHtcbiAgY29uc3QgZGlyID0gcGF0aC5kaXJuYW1lKGZpbGUpXG5cbiAgaWYgKCFmcy5leGlzdHNTeW5jKGRpcikpIHtcbiAgICBta2Rpci5ta2RpcnNTeW5jKGRpcilcbiAgfVxuXG4gIGpzb25GaWxlLndyaXRlSnNvblN5bmMoZmlsZSwgZGF0YSwgb3B0aW9ucylcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBvdXRwdXRKc29uU3luY1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2VsZWN0cm9uLXVwZGF0ZXIvbm9kZV9tb2R1bGVzL2ZzLWV4dHJhL2xpYi9qc29uL291dHB1dC1qc29uLXN5bmMuanMiLCIndXNlIHN0cmljdCdcblxuLy8gbW9zdCBvZiB0aGlzIGNvZGUgd2FzIHdyaXR0ZW4gYnkgQW5kcmV3IEtlbGxleVxuLy8gbGljZW5zZWQgdW5kZXIgdGhlIEJTRCBsaWNlbnNlOiBzZWVcbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9hbmRyZXdyay9ub2RlLW12L2Jsb2IvbWFzdGVyL3BhY2thZ2UuanNvblxuXG4vLyB0aGlzIG5lZWRzIGEgY2xlYW51cFxuXG5jb25zdCB1ID0gcmVxdWlyZSgndW5pdmVyc2FsaWZ5JykuZnJvbUNhbGxiYWNrXG5jb25zdCBmcyA9IHJlcXVpcmUoJ2dyYWNlZnVsLWZzJylcbmNvbnN0IGNvcHkgPSByZXF1aXJlKCcuLi9jb3B5L2NvcHknKVxuY29uc3QgcGF0aCA9IHJlcXVpcmUoJ3BhdGgnKVxuY29uc3QgcmVtb3ZlID0gcmVxdWlyZSgnLi4vcmVtb3ZlJykucmVtb3ZlXG5jb25zdCBta2RpcnAgPSByZXF1aXJlKCcuLi9ta2RpcnMnKS5ta2RpcnNcblxuZnVuY3Rpb24gbW92ZSAoc3JjLCBkZXN0LCBvcHRpb25zLCBjYWxsYmFjaykge1xuICBpZiAodHlwZW9mIG9wdGlvbnMgPT09ICdmdW5jdGlvbicpIHtcbiAgICBjYWxsYmFjayA9IG9wdGlvbnNcbiAgICBvcHRpb25zID0ge31cbiAgfVxuXG4gIGNvbnN0IG92ZXJ3cml0ZSA9IG9wdGlvbnMub3ZlcndyaXRlIHx8IG9wdGlvbnMuY2xvYmJlciB8fCBmYWxzZVxuXG4gIGlzU3JjU3ViZGlyKHNyYywgZGVzdCwgKGVyciwgaXRJcykgPT4ge1xuICAgIGlmIChlcnIpIHJldHVybiBjYWxsYmFjayhlcnIpXG4gICAgaWYgKGl0SXMpIHJldHVybiBjYWxsYmFjayhuZXcgRXJyb3IoYENhbm5vdCBtb3ZlICcke3NyY30nIHRvIGEgc3ViZGlyZWN0b3J5IG9mIGl0c2VsZiwgJyR7ZGVzdH0nLmApKVxuICAgIG1rZGlycChwYXRoLmRpcm5hbWUoZGVzdCksIGVyciA9PiB7XG4gICAgICBpZiAoZXJyKSByZXR1cm4gY2FsbGJhY2soZXJyKVxuICAgICAgZG9SZW5hbWUoKVxuICAgIH0pXG4gIH0pXG5cbiAgZnVuY3Rpb24gZG9SZW5hbWUgKCkge1xuICAgIGlmIChwYXRoLnJlc29sdmUoc3JjKSA9PT0gcGF0aC5yZXNvbHZlKGRlc3QpKSB7XG4gICAgICBmcy5hY2Nlc3Moc3JjLCBjYWxsYmFjaylcbiAgICB9IGVsc2UgaWYgKG92ZXJ3cml0ZSkge1xuICAgICAgZnMucmVuYW1lKHNyYywgZGVzdCwgZXJyID0+IHtcbiAgICAgICAgaWYgKCFlcnIpIHJldHVybiBjYWxsYmFjaygpXG5cbiAgICAgICAgaWYgKGVyci5jb2RlID09PSAnRU5PVEVNUFRZJyB8fCBlcnIuY29kZSA9PT0gJ0VFWElTVCcpIHtcbiAgICAgICAgICByZW1vdmUoZGVzdCwgZXJyID0+IHtcbiAgICAgICAgICAgIGlmIChlcnIpIHJldHVybiBjYWxsYmFjayhlcnIpXG4gICAgICAgICAgICBvcHRpb25zLm92ZXJ3cml0ZSA9IGZhbHNlIC8vIGp1c3Qgb3ZlcndyaXRlZWQgaXQsIG5vIG5lZWQgdG8gZG8gaXQgYWdhaW5cbiAgICAgICAgICAgIG1vdmUoc3JjLCBkZXN0LCBvcHRpb25zLCBjYWxsYmFjaylcbiAgICAgICAgICB9KVxuICAgICAgICAgIHJldHVyblxuICAgICAgICB9XG5cbiAgICAgICAgLy8gd2VpcmQgV2luZG93cyBzaGl0XG4gICAgICAgIGlmIChlcnIuY29kZSA9PT0gJ0VQRVJNJykge1xuICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgcmVtb3ZlKGRlc3QsIGVyciA9PiB7XG4gICAgICAgICAgICAgIGlmIChlcnIpIHJldHVybiBjYWxsYmFjayhlcnIpXG4gICAgICAgICAgICAgIG9wdGlvbnMub3ZlcndyaXRlID0gZmFsc2VcbiAgICAgICAgICAgICAgbW92ZShzcmMsIGRlc3QsIG9wdGlvbnMsIGNhbGxiYWNrKVxuICAgICAgICAgICAgfSlcbiAgICAgICAgICB9LCAyMDApXG4gICAgICAgICAgcmV0dXJuXG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZXJyLmNvZGUgIT09ICdFWERFVicpIHJldHVybiBjYWxsYmFjayhlcnIpXG4gICAgICAgIG1vdmVBY3Jvc3NEZXZpY2Uoc3JjLCBkZXN0LCBvdmVyd3JpdGUsIGNhbGxiYWNrKVxuICAgICAgfSlcbiAgICB9IGVsc2Uge1xuICAgICAgZnMubGluayhzcmMsIGRlc3QsIGVyciA9PiB7XG4gICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICBpZiAoZXJyLmNvZGUgPT09ICdFWERFVicgfHwgZXJyLmNvZGUgPT09ICdFSVNESVInIHx8IGVyci5jb2RlID09PSAnRVBFUk0nIHx8IGVyci5jb2RlID09PSAnRU5PVFNVUCcpIHtcbiAgICAgICAgICAgIHJldHVybiBtb3ZlQWNyb3NzRGV2aWNlKHNyYywgZGVzdCwgb3ZlcndyaXRlLCBjYWxsYmFjaylcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGVycilcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZnMudW5saW5rKHNyYywgY2FsbGJhY2spXG4gICAgICB9KVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBtb3ZlQWNyb3NzRGV2aWNlIChzcmMsIGRlc3QsIG92ZXJ3cml0ZSwgY2FsbGJhY2spIHtcbiAgZnMuc3RhdChzcmMsIChlcnIsIHN0YXQpID0+IHtcbiAgICBpZiAoZXJyKSByZXR1cm4gY2FsbGJhY2soZXJyKVxuXG4gICAgaWYgKHN0YXQuaXNEaXJlY3RvcnkoKSkge1xuICAgICAgbW92ZURpckFjcm9zc0RldmljZShzcmMsIGRlc3QsIG92ZXJ3cml0ZSwgY2FsbGJhY2spXG4gICAgfSBlbHNlIHtcbiAgICAgIG1vdmVGaWxlQWNyb3NzRGV2aWNlKHNyYywgZGVzdCwgb3ZlcndyaXRlLCBjYWxsYmFjaylcbiAgICB9XG4gIH0pXG59XG5cbmZ1bmN0aW9uIG1vdmVGaWxlQWNyb3NzRGV2aWNlIChzcmMsIGRlc3QsIG92ZXJ3cml0ZSwgY2FsbGJhY2spIHtcbiAgY29uc3QgZmxhZ3MgPSBvdmVyd3JpdGUgPyAndycgOiAnd3gnXG4gIGNvbnN0IGlucyA9IGZzLmNyZWF0ZVJlYWRTdHJlYW0oc3JjKVxuICBjb25zdCBvdXRzID0gZnMuY3JlYXRlV3JpdGVTdHJlYW0oZGVzdCwgeyBmbGFncyB9KVxuXG4gIGlucy5vbignZXJyb3InLCBlcnIgPT4ge1xuICAgIGlucy5kZXN0cm95KClcbiAgICBvdXRzLmRlc3Ryb3koKVxuICAgIG91dHMucmVtb3ZlTGlzdGVuZXIoJ2Nsb3NlJywgb25DbG9zZSlcblxuICAgIC8vIG1heSB3YW50IHRvIGNyZWF0ZSBhIGRpcmVjdG9yeSBidXQgYG91dGAgbGluZSBhYm92ZVxuICAgIC8vIGNyZWF0ZXMgYW4gZW1wdHkgZmlsZSBmb3IgdXM6IFNlZSAjMTA4XG4gICAgLy8gZG9uJ3QgY2FyZSBhYm91dCBlcnJvciBoZXJlXG4gICAgZnMudW5saW5rKGRlc3QsICgpID0+IHtcbiAgICAgIC8vIG5vdGU6IGBlcnJgIGhlcmUgaXMgZnJvbSB0aGUgaW5wdXQgc3RyZWFtIGVycnJvclxuICAgICAgaWYgKGVyci5jb2RlID09PSAnRUlTRElSJyB8fCBlcnIuY29kZSA9PT0gJ0VQRVJNJykge1xuICAgICAgICBtb3ZlRGlyQWNyb3NzRGV2aWNlKHNyYywgZGVzdCwgb3ZlcndyaXRlLCBjYWxsYmFjaylcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNhbGxiYWNrKGVycilcbiAgICAgIH1cbiAgICB9KVxuICB9KVxuXG4gIG91dHMub24oJ2Vycm9yJywgZXJyID0+IHtcbiAgICBpbnMuZGVzdHJveSgpXG4gICAgb3V0cy5kZXN0cm95KClcbiAgICBvdXRzLnJlbW92ZUxpc3RlbmVyKCdjbG9zZScsIG9uQ2xvc2UpXG4gICAgY2FsbGJhY2soZXJyKVxuICB9KVxuXG4gIG91dHMub25jZSgnY2xvc2UnLCBvbkNsb3NlKVxuICBpbnMucGlwZShvdXRzKVxuXG4gIGZ1bmN0aW9uIG9uQ2xvc2UgKCkge1xuICAgIGZzLnVubGluayhzcmMsIGNhbGxiYWNrKVxuICB9XG59XG5cbmZ1bmN0aW9uIG1vdmVEaXJBY3Jvc3NEZXZpY2UgKHNyYywgZGVzdCwgb3ZlcndyaXRlLCBjYWxsYmFjaykge1xuICBjb25zdCBvcHRpb25zID0ge1xuICAgIG92ZXJ3cml0ZTogZmFsc2VcbiAgfVxuXG4gIGlmIChvdmVyd3JpdGUpIHtcbiAgICByZW1vdmUoZGVzdCwgZXJyID0+IHtcbiAgICAgIGlmIChlcnIpIHJldHVybiBjYWxsYmFjayhlcnIpXG4gICAgICBzdGFydENvcHkoKVxuICAgIH0pXG4gIH0gZWxzZSB7XG4gICAgc3RhcnRDb3B5KClcbiAgfVxuXG4gIGZ1bmN0aW9uIHN0YXJ0Q29weSAoKSB7XG4gICAgY29weShzcmMsIGRlc3QsIG9wdGlvbnMsIGVyciA9PiB7XG4gICAgICBpZiAoZXJyKSByZXR1cm4gY2FsbGJhY2soZXJyKVxuICAgICAgcmVtb3ZlKHNyYywgY2FsbGJhY2spXG4gICAgfSlcbiAgfVxufVxuXG4vLyByZXR1cm4gdHJ1ZSBpZiBkZXN0IGlzIGEgc3ViZGlyIG9mIHNyYywgb3RoZXJ3aXNlIGZhbHNlLlxuLy8gZXh0cmFjdCBkZXN0IGJhc2UgZGlyIGFuZCBjaGVjayBpZiB0aGF0IGlzIHRoZSBzYW1lIGFzIHNyYyBiYXNlbmFtZVxuZnVuY3Rpb24gaXNTcmNTdWJkaXIgKHNyYywgZGVzdCwgY2IpIHtcbiAgZnMuc3RhdChzcmMsIChlcnIsIHN0KSA9PiB7XG4gICAgaWYgKGVycikgcmV0dXJuIGNiKGVycilcbiAgICBpZiAoc3QuaXNEaXJlY3RvcnkoKSkge1xuICAgICAgY29uc3QgYmFzZURpciA9IGRlc3Quc3BsaXQocGF0aC5kaXJuYW1lKHNyYykgKyBwYXRoLnNlcClbMV1cbiAgICAgIGlmIChiYXNlRGlyKSB7XG4gICAgICAgIGNvbnN0IGRlc3RCYXNlbmFtZSA9IGJhc2VEaXIuc3BsaXQocGF0aC5zZXApWzBdXG4gICAgICAgIGlmIChkZXN0QmFzZW5hbWUpIHJldHVybiBjYihudWxsLCBzcmMgIT09IGRlc3QgJiYgZGVzdC5pbmRleE9mKHNyYykgPiAtMSAmJiBkZXN0QmFzZW5hbWUgPT09IHBhdGguYmFzZW5hbWUoc3JjKSlcbiAgICAgICAgcmV0dXJuIGNiKG51bGwsIGZhbHNlKVxuICAgICAgfVxuICAgICAgcmV0dXJuIGNiKG51bGwsIGZhbHNlKVxuICAgIH1cbiAgICByZXR1cm4gY2IobnVsbCwgZmFsc2UpXG4gIH0pXG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBtb3ZlOiB1KG1vdmUpXG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvZWxlY3Ryb24tdXBkYXRlci9ub2RlX21vZHVsZXMvZnMtZXh0cmEvbGliL21vdmUvaW5kZXguanMiLCIndXNlIHN0cmljdCdcblxuY29uc3QgZnMgPSByZXF1aXJlKCdncmFjZWZ1bC1mcycpXG5jb25zdCBwYXRoID0gcmVxdWlyZSgncGF0aCcpXG5jb25zdCBjb3B5U3luYyA9IHJlcXVpcmUoJy4uL2NvcHktc3luYycpLmNvcHlTeW5jXG5jb25zdCByZW1vdmVTeW5jID0gcmVxdWlyZSgnLi4vcmVtb3ZlJykucmVtb3ZlU3luY1xuY29uc3QgbWtkaXJwU3luYyA9IHJlcXVpcmUoJy4uL21rZGlycycpLm1rZGlyc1N5bmNcbmNvbnN0IGJ1ZmZlciA9IHJlcXVpcmUoJy4uL3V0aWwvYnVmZmVyJylcblxuZnVuY3Rpb24gbW92ZVN5bmMgKHNyYywgZGVzdCwgb3B0aW9ucykge1xuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fVxuICBjb25zdCBvdmVyd3JpdGUgPSBvcHRpb25zLm92ZXJ3cml0ZSB8fCBvcHRpb25zLmNsb2JiZXIgfHwgZmFsc2VcblxuICBzcmMgPSBwYXRoLnJlc29sdmUoc3JjKVxuICBkZXN0ID0gcGF0aC5yZXNvbHZlKGRlc3QpXG5cbiAgaWYgKHNyYyA9PT0gZGVzdCkgcmV0dXJuIGZzLmFjY2Vzc1N5bmMoc3JjKVxuXG4gIGlmIChpc1NyY1N1YmRpcihzcmMsIGRlc3QpKSB0aHJvdyBuZXcgRXJyb3IoYENhbm5vdCBtb3ZlICcke3NyY30nIGludG8gaXRzZWxmICcke2Rlc3R9Jy5gKVxuXG4gIG1rZGlycFN5bmMocGF0aC5kaXJuYW1lKGRlc3QpKVxuICB0cnlSZW5hbWVTeW5jKClcblxuICBmdW5jdGlvbiB0cnlSZW5hbWVTeW5jICgpIHtcbiAgICBpZiAob3ZlcndyaXRlKSB7XG4gICAgICB0cnkge1xuICAgICAgICByZXR1cm4gZnMucmVuYW1lU3luYyhzcmMsIGRlc3QpXG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgaWYgKGVyci5jb2RlID09PSAnRU5PVEVNUFRZJyB8fCBlcnIuY29kZSA9PT0gJ0VFWElTVCcgfHwgZXJyLmNvZGUgPT09ICdFUEVSTScpIHtcbiAgICAgICAgICByZW1vdmVTeW5jKGRlc3QpXG4gICAgICAgICAgb3B0aW9ucy5vdmVyd3JpdGUgPSBmYWxzZSAvLyBqdXN0IG92ZXJ3cml0ZWVkIGl0LCBubyBuZWVkIHRvIGRvIGl0IGFnYWluXG4gICAgICAgICAgcmV0dXJuIG1vdmVTeW5jKHNyYywgZGVzdCwgb3B0aW9ucylcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChlcnIuY29kZSAhPT0gJ0VYREVWJykgdGhyb3cgZXJyXG4gICAgICAgIHJldHVybiBtb3ZlU3luY0Fjcm9zc0RldmljZShzcmMsIGRlc3QsIG92ZXJ3cml0ZSlcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdHJ5IHtcbiAgICAgICAgZnMubGlua1N5bmMoc3JjLCBkZXN0KVxuICAgICAgICByZXR1cm4gZnMudW5saW5rU3luYyhzcmMpXG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgaWYgKGVyci5jb2RlID09PSAnRVhERVYnIHx8IGVyci5jb2RlID09PSAnRUlTRElSJyB8fCBlcnIuY29kZSA9PT0gJ0VQRVJNJyB8fCBlcnIuY29kZSA9PT0gJ0VOT1RTVVAnKSB7XG4gICAgICAgICAgcmV0dXJuIG1vdmVTeW5jQWNyb3NzRGV2aWNlKHNyYywgZGVzdCwgb3ZlcndyaXRlKVxuICAgICAgICB9XG4gICAgICAgIHRocm93IGVyclxuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBtb3ZlU3luY0Fjcm9zc0RldmljZSAoc3JjLCBkZXN0LCBvdmVyd3JpdGUpIHtcbiAgY29uc3Qgc3RhdCA9IGZzLnN0YXRTeW5jKHNyYylcblxuICBpZiAoc3RhdC5pc0RpcmVjdG9yeSgpKSB7XG4gICAgcmV0dXJuIG1vdmVEaXJTeW5jQWNyb3NzRGV2aWNlKHNyYywgZGVzdCwgb3ZlcndyaXRlKVxuICB9IGVsc2Uge1xuICAgIHJldHVybiBtb3ZlRmlsZVN5bmNBY3Jvc3NEZXZpY2Uoc3JjLCBkZXN0LCBvdmVyd3JpdGUpXG4gIH1cbn1cblxuZnVuY3Rpb24gbW92ZUZpbGVTeW5jQWNyb3NzRGV2aWNlIChzcmMsIGRlc3QsIG92ZXJ3cml0ZSkge1xuICBjb25zdCBCVUZfTEVOR1RIID0gNjQgKiAxMDI0XG4gIGNvbnN0IF9idWZmID0gYnVmZmVyKEJVRl9MRU5HVEgpXG5cbiAgY29uc3QgZmxhZ3MgPSBvdmVyd3JpdGUgPyAndycgOiAnd3gnXG5cbiAgY29uc3QgZmRyID0gZnMub3BlblN5bmMoc3JjLCAncicpXG4gIGNvbnN0IHN0YXQgPSBmcy5mc3RhdFN5bmMoZmRyKVxuICBjb25zdCBmZHcgPSBmcy5vcGVuU3luYyhkZXN0LCBmbGFncywgc3RhdC5tb2RlKVxuICBsZXQgYnl0ZXNSZWFkID0gMVxuICBsZXQgcG9zID0gMFxuXG4gIHdoaWxlIChieXRlc1JlYWQgPiAwKSB7XG4gICAgYnl0ZXNSZWFkID0gZnMucmVhZFN5bmMoZmRyLCBfYnVmZiwgMCwgQlVGX0xFTkdUSCwgcG9zKVxuICAgIGZzLndyaXRlU3luYyhmZHcsIF9idWZmLCAwLCBieXRlc1JlYWQpXG4gICAgcG9zICs9IGJ5dGVzUmVhZFxuICB9XG5cbiAgZnMuY2xvc2VTeW5jKGZkcilcbiAgZnMuY2xvc2VTeW5jKGZkdylcbiAgcmV0dXJuIGZzLnVubGlua1N5bmMoc3JjKVxufVxuXG5mdW5jdGlvbiBtb3ZlRGlyU3luY0Fjcm9zc0RldmljZSAoc3JjLCBkZXN0LCBvdmVyd3JpdGUpIHtcbiAgY29uc3Qgb3B0aW9ucyA9IHtcbiAgICBvdmVyd3JpdGU6IGZhbHNlXG4gIH1cblxuICBpZiAob3ZlcndyaXRlKSB7XG4gICAgcmVtb3ZlU3luYyhkZXN0KVxuICAgIHRyeUNvcHlTeW5jKClcbiAgfSBlbHNlIHtcbiAgICB0cnlDb3B5U3luYygpXG4gIH1cblxuICBmdW5jdGlvbiB0cnlDb3B5U3luYyAoKSB7XG4gICAgY29weVN5bmMoc3JjLCBkZXN0LCBvcHRpb25zKVxuICAgIHJldHVybiByZW1vdmVTeW5jKHNyYylcbiAgfVxufVxuXG4vLyByZXR1cm4gdHJ1ZSBpZiBkZXN0IGlzIGEgc3ViZGlyIG9mIHNyYywgb3RoZXJ3aXNlIGZhbHNlLlxuLy8gZXh0cmFjdCBkZXN0IGJhc2UgZGlyIGFuZCBjaGVjayBpZiB0aGF0IGlzIHRoZSBzYW1lIGFzIHNyYyBiYXNlbmFtZVxuZnVuY3Rpb24gaXNTcmNTdWJkaXIgKHNyYywgZGVzdCkge1xuICB0cnkge1xuICAgIHJldHVybiBmcy5zdGF0U3luYyhzcmMpLmlzRGlyZWN0b3J5KCkgJiZcbiAgICAgICAgICAgc3JjICE9PSBkZXN0ICYmXG4gICAgICAgICAgIGRlc3QuaW5kZXhPZihzcmMpID4gLTEgJiZcbiAgICAgICAgICAgZGVzdC5zcGxpdChwYXRoLmRpcm5hbWUoc3JjKSArIHBhdGguc2VwKVsxXS5zcGxpdChwYXRoLnNlcClbMF0gPT09IHBhdGguYmFzZW5hbWUoc3JjKVxuICB9IGNhdGNoIChlKSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIG1vdmVTeW5jXG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvZWxlY3Ryb24tdXBkYXRlci9ub2RlX21vZHVsZXMvZnMtZXh0cmEvbGliL21vdmUtc3luYy9pbmRleC5qcyIsIid1c2Ugc3RyaWN0J1xuXG5jb25zdCB1ID0gcmVxdWlyZSgndW5pdmVyc2FsaWZ5JykuZnJvbUNhbGxiYWNrXG5jb25zdCBmcyA9IHJlcXVpcmUoJ2ZzJylcbmNvbnN0IHBhdGggPSByZXF1aXJlKCdwYXRoJylcbmNvbnN0IG1rZGlyID0gcmVxdWlyZSgnLi4vbWtkaXJzJylcbmNvbnN0IHJlbW92ZSA9IHJlcXVpcmUoJy4uL3JlbW92ZScpXG5cbmNvbnN0IGVtcHR5RGlyID0gdShmdW5jdGlvbiBlbXB0eURpciAoZGlyLCBjYWxsYmFjaykge1xuICBjYWxsYmFjayA9IGNhbGxiYWNrIHx8IGZ1bmN0aW9uICgpIHt9XG4gIGZzLnJlYWRkaXIoZGlyLCAoZXJyLCBpdGVtcykgPT4ge1xuICAgIGlmIChlcnIpIHJldHVybiBta2Rpci5ta2RpcnMoZGlyLCBjYWxsYmFjaylcblxuICAgIGl0ZW1zID0gaXRlbXMubWFwKGl0ZW0gPT4gcGF0aC5qb2luKGRpciwgaXRlbSkpXG5cbiAgICBkZWxldGVJdGVtKClcblxuICAgIGZ1bmN0aW9uIGRlbGV0ZUl0ZW0gKCkge1xuICAgICAgY29uc3QgaXRlbSA9IGl0ZW1zLnBvcCgpXG4gICAgICBpZiAoIWl0ZW0pIHJldHVybiBjYWxsYmFjaygpXG4gICAgICByZW1vdmUucmVtb3ZlKGl0ZW0sIGVyciA9PiB7XG4gICAgICAgIGlmIChlcnIpIHJldHVybiBjYWxsYmFjayhlcnIpXG4gICAgICAgIGRlbGV0ZUl0ZW0oKVxuICAgICAgfSlcbiAgICB9XG4gIH0pXG59KVxuXG5mdW5jdGlvbiBlbXB0eURpclN5bmMgKGRpcikge1xuICBsZXQgaXRlbXNcbiAgdHJ5IHtcbiAgICBpdGVtcyA9IGZzLnJlYWRkaXJTeW5jKGRpcilcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgcmV0dXJuIG1rZGlyLm1rZGlyc1N5bmMoZGlyKVxuICB9XG5cbiAgaXRlbXMuZm9yRWFjaChpdGVtID0+IHtcbiAgICBpdGVtID0gcGF0aC5qb2luKGRpciwgaXRlbSlcbiAgICByZW1vdmUucmVtb3ZlU3luYyhpdGVtKVxuICB9KVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgZW1wdHlEaXJTeW5jLFxuICBlbXB0eWRpclN5bmM6IGVtcHR5RGlyU3luYyxcbiAgZW1wdHlEaXIsXG4gIGVtcHR5ZGlyOiBlbXB0eURpclxufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2VsZWN0cm9uLXVwZGF0ZXIvbm9kZV9tb2R1bGVzL2ZzLWV4dHJhL2xpYi9lbXB0eS9pbmRleC5qcyIsIid1c2Ugc3RyaWN0J1xuXG5jb25zdCBmaWxlID0gcmVxdWlyZSgnLi9maWxlJylcbmNvbnN0IGxpbmsgPSByZXF1aXJlKCcuL2xpbmsnKVxuY29uc3Qgc3ltbGluayA9IHJlcXVpcmUoJy4vc3ltbGluaycpXG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICAvLyBmaWxlXG4gIGNyZWF0ZUZpbGU6IGZpbGUuY3JlYXRlRmlsZSxcbiAgY3JlYXRlRmlsZVN5bmM6IGZpbGUuY3JlYXRlRmlsZVN5bmMsXG4gIGVuc3VyZUZpbGU6IGZpbGUuY3JlYXRlRmlsZSxcbiAgZW5zdXJlRmlsZVN5bmM6IGZpbGUuY3JlYXRlRmlsZVN5bmMsXG4gIC8vIGxpbmtcbiAgY3JlYXRlTGluazogbGluay5jcmVhdGVMaW5rLFxuICBjcmVhdGVMaW5rU3luYzogbGluay5jcmVhdGVMaW5rU3luYyxcbiAgZW5zdXJlTGluazogbGluay5jcmVhdGVMaW5rLFxuICBlbnN1cmVMaW5rU3luYzogbGluay5jcmVhdGVMaW5rU3luYyxcbiAgLy8gc3ltbGlua1xuICBjcmVhdGVTeW1saW5rOiBzeW1saW5rLmNyZWF0ZVN5bWxpbmssXG4gIGNyZWF0ZVN5bWxpbmtTeW5jOiBzeW1saW5rLmNyZWF0ZVN5bWxpbmtTeW5jLFxuICBlbnN1cmVTeW1saW5rOiBzeW1saW5rLmNyZWF0ZVN5bWxpbmssXG4gIGVuc3VyZVN5bWxpbmtTeW5jOiBzeW1saW5rLmNyZWF0ZVN5bWxpbmtTeW5jXG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvZWxlY3Ryb24tdXBkYXRlci9ub2RlX21vZHVsZXMvZnMtZXh0cmEvbGliL2Vuc3VyZS9pbmRleC5qcyIsIid1c2Ugc3RyaWN0J1xuXG5jb25zdCB1ID0gcmVxdWlyZSgndW5pdmVyc2FsaWZ5JykuZnJvbUNhbGxiYWNrXG5jb25zdCBwYXRoID0gcmVxdWlyZSgncGF0aCcpXG5jb25zdCBmcyA9IHJlcXVpcmUoJ2dyYWNlZnVsLWZzJylcbmNvbnN0IG1rZGlyID0gcmVxdWlyZSgnLi4vbWtkaXJzJylcbmNvbnN0IHBhdGhFeGlzdHMgPSByZXF1aXJlKCcuLi9wYXRoLWV4aXN0cycpLnBhdGhFeGlzdHNcblxuZnVuY3Rpb24gY3JlYXRlRmlsZSAoZmlsZSwgY2FsbGJhY2spIHtcbiAgZnVuY3Rpb24gbWFrZUZpbGUgKCkge1xuICAgIGZzLndyaXRlRmlsZShmaWxlLCAnJywgZXJyID0+IHtcbiAgICAgIGlmIChlcnIpIHJldHVybiBjYWxsYmFjayhlcnIpXG4gICAgICBjYWxsYmFjaygpXG4gICAgfSlcbiAgfVxuXG4gIGZzLnN0YXQoZmlsZSwgKGVyciwgc3RhdHMpID0+IHsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBoYW5kbGUtY2FsbGJhY2stZXJyXG4gICAgaWYgKCFlcnIgJiYgc3RhdHMuaXNGaWxlKCkpIHJldHVybiBjYWxsYmFjaygpXG4gICAgY29uc3QgZGlyID0gcGF0aC5kaXJuYW1lKGZpbGUpXG4gICAgcGF0aEV4aXN0cyhkaXIsIChlcnIsIGRpckV4aXN0cykgPT4ge1xuICAgICAgaWYgKGVycikgcmV0dXJuIGNhbGxiYWNrKGVycilcbiAgICAgIGlmIChkaXJFeGlzdHMpIHJldHVybiBtYWtlRmlsZSgpXG4gICAgICBta2Rpci5ta2RpcnMoZGlyLCBlcnIgPT4ge1xuICAgICAgICBpZiAoZXJyKSByZXR1cm4gY2FsbGJhY2soZXJyKVxuICAgICAgICBtYWtlRmlsZSgpXG4gICAgICB9KVxuICAgIH0pXG4gIH0pXG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUZpbGVTeW5jIChmaWxlKSB7XG4gIGxldCBzdGF0c1xuICB0cnkge1xuICAgIHN0YXRzID0gZnMuc3RhdFN5bmMoZmlsZSlcbiAgfSBjYXRjaCAoZSkge31cbiAgaWYgKHN0YXRzICYmIHN0YXRzLmlzRmlsZSgpKSByZXR1cm5cblxuICBjb25zdCBkaXIgPSBwYXRoLmRpcm5hbWUoZmlsZSlcbiAgaWYgKCFmcy5leGlzdHNTeW5jKGRpcikpIHtcbiAgICBta2Rpci5ta2RpcnNTeW5jKGRpcilcbiAgfVxuXG4gIGZzLndyaXRlRmlsZVN5bmMoZmlsZSwgJycpXG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBjcmVhdGVGaWxlOiB1KGNyZWF0ZUZpbGUpLFxuICBjcmVhdGVGaWxlU3luY1xufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2VsZWN0cm9uLXVwZGF0ZXIvbm9kZV9tb2R1bGVzL2ZzLWV4dHJhL2xpYi9lbnN1cmUvZmlsZS5qcyIsIid1c2Ugc3RyaWN0J1xuXG5jb25zdCB1ID0gcmVxdWlyZSgndW5pdmVyc2FsaWZ5JykuZnJvbUNhbGxiYWNrXG5jb25zdCBwYXRoID0gcmVxdWlyZSgncGF0aCcpXG5jb25zdCBmcyA9IHJlcXVpcmUoJ2dyYWNlZnVsLWZzJylcbmNvbnN0IG1rZGlyID0gcmVxdWlyZSgnLi4vbWtkaXJzJylcbmNvbnN0IHBhdGhFeGlzdHMgPSByZXF1aXJlKCcuLi9wYXRoLWV4aXN0cycpLnBhdGhFeGlzdHNcblxuZnVuY3Rpb24gY3JlYXRlTGluayAoc3JjcGF0aCwgZHN0cGF0aCwgY2FsbGJhY2spIHtcbiAgZnVuY3Rpb24gbWFrZUxpbmsgKHNyY3BhdGgsIGRzdHBhdGgpIHtcbiAgICBmcy5saW5rKHNyY3BhdGgsIGRzdHBhdGgsIGVyciA9PiB7XG4gICAgICBpZiAoZXJyKSByZXR1cm4gY2FsbGJhY2soZXJyKVxuICAgICAgY2FsbGJhY2sobnVsbClcbiAgICB9KVxuICB9XG5cbiAgcGF0aEV4aXN0cyhkc3RwYXRoLCAoZXJyLCBkZXN0aW5hdGlvbkV4aXN0cykgPT4ge1xuICAgIGlmIChlcnIpIHJldHVybiBjYWxsYmFjayhlcnIpXG4gICAgaWYgKGRlc3RpbmF0aW9uRXhpc3RzKSByZXR1cm4gY2FsbGJhY2sobnVsbClcbiAgICBmcy5sc3RhdChzcmNwYXRoLCAoZXJyLCBzdGF0KSA9PiB7XG4gICAgICBpZiAoZXJyKSB7XG4gICAgICAgIGVyci5tZXNzYWdlID0gZXJyLm1lc3NhZ2UucmVwbGFjZSgnbHN0YXQnLCAnZW5zdXJlTGluaycpXG4gICAgICAgIHJldHVybiBjYWxsYmFjayhlcnIpXG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGRpciA9IHBhdGguZGlybmFtZShkc3RwYXRoKVxuICAgICAgcGF0aEV4aXN0cyhkaXIsIChlcnIsIGRpckV4aXN0cykgPT4ge1xuICAgICAgICBpZiAoZXJyKSByZXR1cm4gY2FsbGJhY2soZXJyKVxuICAgICAgICBpZiAoZGlyRXhpc3RzKSByZXR1cm4gbWFrZUxpbmsoc3JjcGF0aCwgZHN0cGF0aClcbiAgICAgICAgbWtkaXIubWtkaXJzKGRpciwgZXJyID0+IHtcbiAgICAgICAgICBpZiAoZXJyKSByZXR1cm4gY2FsbGJhY2soZXJyKVxuICAgICAgICAgIG1ha2VMaW5rKHNyY3BhdGgsIGRzdHBhdGgpXG4gICAgICAgIH0pXG4gICAgICB9KVxuICAgIH0pXG4gIH0pXG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUxpbmtTeW5jIChzcmNwYXRoLCBkc3RwYXRoLCBjYWxsYmFjaykge1xuICBjb25zdCBkZXN0aW5hdGlvbkV4aXN0cyA9IGZzLmV4aXN0c1N5bmMoZHN0cGF0aClcbiAgaWYgKGRlc3RpbmF0aW9uRXhpc3RzKSByZXR1cm4gdW5kZWZpbmVkXG5cbiAgdHJ5IHtcbiAgICBmcy5sc3RhdFN5bmMoc3JjcGF0aClcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgZXJyLm1lc3NhZ2UgPSBlcnIubWVzc2FnZS5yZXBsYWNlKCdsc3RhdCcsICdlbnN1cmVMaW5rJylcbiAgICB0aHJvdyBlcnJcbiAgfVxuXG4gIGNvbnN0IGRpciA9IHBhdGguZGlybmFtZShkc3RwYXRoKVxuICBjb25zdCBkaXJFeGlzdHMgPSBmcy5leGlzdHNTeW5jKGRpcilcbiAgaWYgKGRpckV4aXN0cykgcmV0dXJuIGZzLmxpbmtTeW5jKHNyY3BhdGgsIGRzdHBhdGgpXG4gIG1rZGlyLm1rZGlyc1N5bmMoZGlyKVxuXG4gIHJldHVybiBmcy5saW5rU3luYyhzcmNwYXRoLCBkc3RwYXRoKVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgY3JlYXRlTGluazogdShjcmVhdGVMaW5rKSxcbiAgY3JlYXRlTGlua1N5bmNcbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9lbGVjdHJvbi11cGRhdGVyL25vZGVfbW9kdWxlcy9mcy1leHRyYS9saWIvZW5zdXJlL2xpbmsuanMiLCIndXNlIHN0cmljdCdcblxuY29uc3QgdSA9IHJlcXVpcmUoJ3VuaXZlcnNhbGlmeScpLmZyb21DYWxsYmFja1xuY29uc3QgcGF0aCA9IHJlcXVpcmUoJ3BhdGgnKVxuY29uc3QgZnMgPSByZXF1aXJlKCdncmFjZWZ1bC1mcycpXG5jb25zdCBfbWtkaXJzID0gcmVxdWlyZSgnLi4vbWtkaXJzJylcbmNvbnN0IG1rZGlycyA9IF9ta2RpcnMubWtkaXJzXG5jb25zdCBta2RpcnNTeW5jID0gX21rZGlycy5ta2RpcnNTeW5jXG5cbmNvbnN0IF9zeW1saW5rUGF0aHMgPSByZXF1aXJlKCcuL3N5bWxpbmstcGF0aHMnKVxuY29uc3Qgc3ltbGlua1BhdGhzID0gX3N5bWxpbmtQYXRocy5zeW1saW5rUGF0aHNcbmNvbnN0IHN5bWxpbmtQYXRoc1N5bmMgPSBfc3ltbGlua1BhdGhzLnN5bWxpbmtQYXRoc1N5bmNcblxuY29uc3QgX3N5bWxpbmtUeXBlID0gcmVxdWlyZSgnLi9zeW1saW5rLXR5cGUnKVxuY29uc3Qgc3ltbGlua1R5cGUgPSBfc3ltbGlua1R5cGUuc3ltbGlua1R5cGVcbmNvbnN0IHN5bWxpbmtUeXBlU3luYyA9IF9zeW1saW5rVHlwZS5zeW1saW5rVHlwZVN5bmNcblxuY29uc3QgcGF0aEV4aXN0cyA9IHJlcXVpcmUoJy4uL3BhdGgtZXhpc3RzJykucGF0aEV4aXN0c1xuXG5mdW5jdGlvbiBjcmVhdGVTeW1saW5rIChzcmNwYXRoLCBkc3RwYXRoLCB0eXBlLCBjYWxsYmFjaykge1xuICBjYWxsYmFjayA9ICh0eXBlb2YgdHlwZSA9PT0gJ2Z1bmN0aW9uJykgPyB0eXBlIDogY2FsbGJhY2tcbiAgdHlwZSA9ICh0eXBlb2YgdHlwZSA9PT0gJ2Z1bmN0aW9uJykgPyBmYWxzZSA6IHR5cGVcblxuICBwYXRoRXhpc3RzKGRzdHBhdGgsIChlcnIsIGRlc3RpbmF0aW9uRXhpc3RzKSA9PiB7XG4gICAgaWYgKGVycikgcmV0dXJuIGNhbGxiYWNrKGVycilcbiAgICBpZiAoZGVzdGluYXRpb25FeGlzdHMpIHJldHVybiBjYWxsYmFjayhudWxsKVxuICAgIHN5bWxpbmtQYXRocyhzcmNwYXRoLCBkc3RwYXRoLCAoZXJyLCByZWxhdGl2ZSkgPT4ge1xuICAgICAgaWYgKGVycikgcmV0dXJuIGNhbGxiYWNrKGVycilcbiAgICAgIHNyY3BhdGggPSByZWxhdGl2ZS50b0RzdFxuICAgICAgc3ltbGlua1R5cGUocmVsYXRpdmUudG9Dd2QsIHR5cGUsIChlcnIsIHR5cGUpID0+IHtcbiAgICAgICAgaWYgKGVycikgcmV0dXJuIGNhbGxiYWNrKGVycilcbiAgICAgICAgY29uc3QgZGlyID0gcGF0aC5kaXJuYW1lKGRzdHBhdGgpXG4gICAgICAgIHBhdGhFeGlzdHMoZGlyLCAoZXJyLCBkaXJFeGlzdHMpID0+IHtcbiAgICAgICAgICBpZiAoZXJyKSByZXR1cm4gY2FsbGJhY2soZXJyKVxuICAgICAgICAgIGlmIChkaXJFeGlzdHMpIHJldHVybiBmcy5zeW1saW5rKHNyY3BhdGgsIGRzdHBhdGgsIHR5cGUsIGNhbGxiYWNrKVxuICAgICAgICAgIG1rZGlycyhkaXIsIGVyciA9PiB7XG4gICAgICAgICAgICBpZiAoZXJyKSByZXR1cm4gY2FsbGJhY2soZXJyKVxuICAgICAgICAgICAgZnMuc3ltbGluayhzcmNwYXRoLCBkc3RwYXRoLCB0eXBlLCBjYWxsYmFjaylcbiAgICAgICAgICB9KVxuICAgICAgICB9KVxuICAgICAgfSlcbiAgICB9KVxuICB9KVxufVxuXG5mdW5jdGlvbiBjcmVhdGVTeW1saW5rU3luYyAoc3JjcGF0aCwgZHN0cGF0aCwgdHlwZSwgY2FsbGJhY2spIHtcbiAgY2FsbGJhY2sgPSAodHlwZW9mIHR5cGUgPT09ICdmdW5jdGlvbicpID8gdHlwZSA6IGNhbGxiYWNrXG4gIHR5cGUgPSAodHlwZW9mIHR5cGUgPT09ICdmdW5jdGlvbicpID8gZmFsc2UgOiB0eXBlXG5cbiAgY29uc3QgZGVzdGluYXRpb25FeGlzdHMgPSBmcy5leGlzdHNTeW5jKGRzdHBhdGgpXG4gIGlmIChkZXN0aW5hdGlvbkV4aXN0cykgcmV0dXJuIHVuZGVmaW5lZFxuXG4gIGNvbnN0IHJlbGF0aXZlID0gc3ltbGlua1BhdGhzU3luYyhzcmNwYXRoLCBkc3RwYXRoKVxuICBzcmNwYXRoID0gcmVsYXRpdmUudG9Ec3RcbiAgdHlwZSA9IHN5bWxpbmtUeXBlU3luYyhyZWxhdGl2ZS50b0N3ZCwgdHlwZSlcbiAgY29uc3QgZGlyID0gcGF0aC5kaXJuYW1lKGRzdHBhdGgpXG4gIGNvbnN0IGV4aXN0cyA9IGZzLmV4aXN0c1N5bmMoZGlyKVxuICBpZiAoZXhpc3RzKSByZXR1cm4gZnMuc3ltbGlua1N5bmMoc3JjcGF0aCwgZHN0cGF0aCwgdHlwZSlcbiAgbWtkaXJzU3luYyhkaXIpXG4gIHJldHVybiBmcy5zeW1saW5rU3luYyhzcmNwYXRoLCBkc3RwYXRoLCB0eXBlKVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgY3JlYXRlU3ltbGluazogdShjcmVhdGVTeW1saW5rKSxcbiAgY3JlYXRlU3ltbGlua1N5bmNcbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9lbGVjdHJvbi11cGRhdGVyL25vZGVfbW9kdWxlcy9mcy1leHRyYS9saWIvZW5zdXJlL3N5bWxpbmsuanMiLCIndXNlIHN0cmljdCdcblxuY29uc3QgcGF0aCA9IHJlcXVpcmUoJ3BhdGgnKVxuY29uc3QgZnMgPSByZXF1aXJlKCdncmFjZWZ1bC1mcycpXG5jb25zdCBwYXRoRXhpc3RzID0gcmVxdWlyZSgnLi4vcGF0aC1leGlzdHMnKS5wYXRoRXhpc3RzXG5cbi8qKlxuICogRnVuY3Rpb24gdGhhdCByZXR1cm5zIHR3byB0eXBlcyBvZiBwYXRocywgb25lIHJlbGF0aXZlIHRvIHN5bWxpbmssIGFuZCBvbmVcbiAqIHJlbGF0aXZlIHRvIHRoZSBjdXJyZW50IHdvcmtpbmcgZGlyZWN0b3J5LiBDaGVja3MgaWYgcGF0aCBpcyBhYnNvbHV0ZSBvclxuICogcmVsYXRpdmUuIElmIHRoZSBwYXRoIGlzIHJlbGF0aXZlLCB0aGlzIGZ1bmN0aW9uIGNoZWNrcyBpZiB0aGUgcGF0aCBpc1xuICogcmVsYXRpdmUgdG8gc3ltbGluayBvciByZWxhdGl2ZSB0byBjdXJyZW50IHdvcmtpbmcgZGlyZWN0b3J5LiBUaGlzIGlzIGFuXG4gKiBpbml0aWF0aXZlIHRvIGZpbmQgYSBzbWFydGVyIGBzcmNwYXRoYCB0byBzdXBwbHkgd2hlbiBidWlsZGluZyBzeW1saW5rcy5cbiAqIFRoaXMgYWxsb3dzIHlvdSB0byBkZXRlcm1pbmUgd2hpY2ggcGF0aCB0byB1c2Ugb3V0IG9mIG9uZSBvZiB0aHJlZSBwb3NzaWJsZVxuICogdHlwZXMgb2Ygc291cmNlIHBhdGhzLiBUaGUgZmlyc3QgaXMgYW4gYWJzb2x1dGUgcGF0aC4gVGhpcyBpcyBkZXRlY3RlZCBieVxuICogYHBhdGguaXNBYnNvbHV0ZSgpYC4gV2hlbiBhbiBhYnNvbHV0ZSBwYXRoIGlzIHByb3ZpZGVkLCBpdCBpcyBjaGVja2VkIHRvXG4gKiBzZWUgaWYgaXQgZXhpc3RzLiBJZiBpdCBkb2VzIGl0J3MgdXNlZCwgaWYgbm90IGFuIGVycm9yIGlzIHJldHVybmVkXG4gKiAoY2FsbGJhY2spLyB0aHJvd24gKHN5bmMpLiBUaGUgb3RoZXIgdHdvIG9wdGlvbnMgZm9yIGBzcmNwYXRoYCBhcmUgYVxuICogcmVsYXRpdmUgdXJsLiBCeSBkZWZhdWx0IE5vZGUncyBgZnMuc3ltbGlua2Agd29ya3MgYnkgY3JlYXRpbmcgYSBzeW1saW5rXG4gKiB1c2luZyBgZHN0cGF0aGAgYW5kIGV4cGVjdHMgdGhlIGBzcmNwYXRoYCB0byBiZSByZWxhdGl2ZSB0byB0aGUgbmV3bHlcbiAqIGNyZWF0ZWQgc3ltbGluay4gSWYgeW91IHByb3ZpZGUgYSBgc3JjcGF0aGAgdGhhdCBkb2VzIG5vdCBleGlzdCBvbiB0aGUgZmlsZVxuICogc3lzdGVtIGl0IHJlc3VsdHMgaW4gYSBicm9rZW4gc3ltbGluay4gVG8gbWluaW1pemUgdGhpcywgdGhlIGZ1bmN0aW9uXG4gKiBjaGVja3MgdG8gc2VlIGlmIHRoZSAncmVsYXRpdmUgdG8gc3ltbGluaycgc291cmNlIGZpbGUgZXhpc3RzLCBhbmQgaWYgaXRcbiAqIGRvZXMgaXQgd2lsbCB1c2UgaXQuIElmIGl0IGRvZXMgbm90LCBpdCBjaGVja3MgaWYgdGhlcmUncyBhIGZpbGUgdGhhdFxuICogZXhpc3RzIHRoYXQgaXMgcmVsYXRpdmUgdG8gdGhlIGN1cnJlbnQgd29ya2luZyBkaXJlY3RvcnksIGlmIGRvZXMgaXRzIHVzZWQuXG4gKiBUaGlzIHByZXNlcnZlcyB0aGUgZXhwZWN0YXRpb25zIG9mIHRoZSBvcmlnaW5hbCBmcy5zeW1saW5rIHNwZWMgYW5kIGFkZHNcbiAqIHRoZSBhYmlsaXR5IHRvIHBhc3MgaW4gYHJlbGF0aXZlIHRvIGN1cnJlbnQgd29ya2luZyBkaXJlY290cnlgIHBhdGhzLlxuICovXG5cbmZ1bmN0aW9uIHN5bWxpbmtQYXRocyAoc3JjcGF0aCwgZHN0cGF0aCwgY2FsbGJhY2spIHtcbiAgaWYgKHBhdGguaXNBYnNvbHV0ZShzcmNwYXRoKSkge1xuICAgIHJldHVybiBmcy5sc3RhdChzcmNwYXRoLCAoZXJyLCBzdGF0KSA9PiB7XG4gICAgICBpZiAoZXJyKSB7XG4gICAgICAgIGVyci5tZXNzYWdlID0gZXJyLm1lc3NhZ2UucmVwbGFjZSgnbHN0YXQnLCAnZW5zdXJlU3ltbGluaycpXG4gICAgICAgIHJldHVybiBjYWxsYmFjayhlcnIpXG4gICAgICB9XG4gICAgICByZXR1cm4gY2FsbGJhY2sobnVsbCwge1xuICAgICAgICAndG9Dd2QnOiBzcmNwYXRoLFxuICAgICAgICAndG9Ec3QnOiBzcmNwYXRoXG4gICAgICB9KVxuICAgIH0pXG4gIH0gZWxzZSB7XG4gICAgY29uc3QgZHN0ZGlyID0gcGF0aC5kaXJuYW1lKGRzdHBhdGgpXG4gICAgY29uc3QgcmVsYXRpdmVUb0RzdCA9IHBhdGguam9pbihkc3RkaXIsIHNyY3BhdGgpXG4gICAgcmV0dXJuIHBhdGhFeGlzdHMocmVsYXRpdmVUb0RzdCwgKGVyciwgZXhpc3RzKSA9PiB7XG4gICAgICBpZiAoZXJyKSByZXR1cm4gY2FsbGJhY2soZXJyKVxuICAgICAgaWYgKGV4aXN0cykge1xuICAgICAgICByZXR1cm4gY2FsbGJhY2sobnVsbCwge1xuICAgICAgICAgICd0b0N3ZCc6IHJlbGF0aXZlVG9Ec3QsXG4gICAgICAgICAgJ3RvRHN0Jzogc3JjcGF0aFxuICAgICAgICB9KVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGZzLmxzdGF0KHNyY3BhdGgsIChlcnIsIHN0YXQpID0+IHtcbiAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICBlcnIubWVzc2FnZSA9IGVyci5tZXNzYWdlLnJlcGxhY2UoJ2xzdGF0JywgJ2Vuc3VyZVN5bWxpbmsnKVxuICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGVycilcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKG51bGwsIHtcbiAgICAgICAgICAgICd0b0N3ZCc6IHNyY3BhdGgsXG4gICAgICAgICAgICAndG9Ec3QnOiBwYXRoLnJlbGF0aXZlKGRzdGRpciwgc3JjcGF0aClcbiAgICAgICAgICB9KVxuICAgICAgICB9KVxuICAgICAgfVxuICAgIH0pXG4gIH1cbn1cblxuZnVuY3Rpb24gc3ltbGlua1BhdGhzU3luYyAoc3JjcGF0aCwgZHN0cGF0aCkge1xuICBsZXQgZXhpc3RzXG4gIGlmIChwYXRoLmlzQWJzb2x1dGUoc3JjcGF0aCkpIHtcbiAgICBleGlzdHMgPSBmcy5leGlzdHNTeW5jKHNyY3BhdGgpXG4gICAgaWYgKCFleGlzdHMpIHRocm93IG5ldyBFcnJvcignYWJzb2x1dGUgc3JjcGF0aCBkb2VzIG5vdCBleGlzdCcpXG4gICAgcmV0dXJuIHtcbiAgICAgICd0b0N3ZCc6IHNyY3BhdGgsXG4gICAgICAndG9Ec3QnOiBzcmNwYXRoXG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGNvbnN0IGRzdGRpciA9IHBhdGguZGlybmFtZShkc3RwYXRoKVxuICAgIGNvbnN0IHJlbGF0aXZlVG9Ec3QgPSBwYXRoLmpvaW4oZHN0ZGlyLCBzcmNwYXRoKVxuICAgIGV4aXN0cyA9IGZzLmV4aXN0c1N5bmMocmVsYXRpdmVUb0RzdClcbiAgICBpZiAoZXhpc3RzKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICAndG9Dd2QnOiByZWxhdGl2ZVRvRHN0LFxuICAgICAgICAndG9Ec3QnOiBzcmNwYXRoXG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGV4aXN0cyA9IGZzLmV4aXN0c1N5bmMoc3JjcGF0aClcbiAgICAgIGlmICghZXhpc3RzKSB0aHJvdyBuZXcgRXJyb3IoJ3JlbGF0aXZlIHNyY3BhdGggZG9lcyBub3QgZXhpc3QnKVxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgJ3RvQ3dkJzogc3JjcGF0aCxcbiAgICAgICAgJ3RvRHN0JzogcGF0aC5yZWxhdGl2ZShkc3RkaXIsIHNyY3BhdGgpXG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBzeW1saW5rUGF0aHMsXG4gIHN5bWxpbmtQYXRoc1N5bmNcbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9lbGVjdHJvbi11cGRhdGVyL25vZGVfbW9kdWxlcy9mcy1leHRyYS9saWIvZW5zdXJlL3N5bWxpbmstcGF0aHMuanMiLCIndXNlIHN0cmljdCdcblxuY29uc3QgZnMgPSByZXF1aXJlKCdncmFjZWZ1bC1mcycpXG5cbmZ1bmN0aW9uIHN5bWxpbmtUeXBlIChzcmNwYXRoLCB0eXBlLCBjYWxsYmFjaykge1xuICBjYWxsYmFjayA9ICh0eXBlb2YgdHlwZSA9PT0gJ2Z1bmN0aW9uJykgPyB0eXBlIDogY2FsbGJhY2tcbiAgdHlwZSA9ICh0eXBlb2YgdHlwZSA9PT0gJ2Z1bmN0aW9uJykgPyBmYWxzZSA6IHR5cGVcbiAgaWYgKHR5cGUpIHJldHVybiBjYWxsYmFjayhudWxsLCB0eXBlKVxuICBmcy5sc3RhdChzcmNwYXRoLCAoZXJyLCBzdGF0cykgPT4ge1xuICAgIGlmIChlcnIpIHJldHVybiBjYWxsYmFjayhudWxsLCAnZmlsZScpXG4gICAgdHlwZSA9IChzdGF0cyAmJiBzdGF0cy5pc0RpcmVjdG9yeSgpKSA/ICdkaXInIDogJ2ZpbGUnXG4gICAgY2FsbGJhY2sobnVsbCwgdHlwZSlcbiAgfSlcbn1cblxuZnVuY3Rpb24gc3ltbGlua1R5cGVTeW5jIChzcmNwYXRoLCB0eXBlKSB7XG4gIGxldCBzdGF0c1xuXG4gIGlmICh0eXBlKSByZXR1cm4gdHlwZVxuICB0cnkge1xuICAgIHN0YXRzID0gZnMubHN0YXRTeW5jKHNyY3BhdGgpXG4gIH0gY2F0Y2ggKGUpIHtcbiAgICByZXR1cm4gJ2ZpbGUnXG4gIH1cbiAgcmV0dXJuIChzdGF0cyAmJiBzdGF0cy5pc0RpcmVjdG9yeSgpKSA/ICdkaXInIDogJ2ZpbGUnXG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBzeW1saW5rVHlwZSxcbiAgc3ltbGlua1R5cGVTeW5jXG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvZWxlY3Ryb24tdXBkYXRlci9ub2RlX21vZHVsZXMvZnMtZXh0cmEvbGliL2Vuc3VyZS9zeW1saW5rLXR5cGUuanMiLCIndXNlIHN0cmljdCdcblxuY29uc3QgdSA9IHJlcXVpcmUoJ3VuaXZlcnNhbGlmeScpLmZyb21DYWxsYmFja1xuY29uc3QgZnMgPSByZXF1aXJlKCdncmFjZWZ1bC1mcycpXG5jb25zdCBwYXRoID0gcmVxdWlyZSgncGF0aCcpXG5jb25zdCBta2RpciA9IHJlcXVpcmUoJy4uL21rZGlycycpXG5jb25zdCBwYXRoRXhpc3RzID0gcmVxdWlyZSgnLi4vcGF0aC1leGlzdHMnKS5wYXRoRXhpc3RzXG5cbmZ1bmN0aW9uIG91dHB1dEZpbGUgKGZpbGUsIGRhdGEsIGVuY29kaW5nLCBjYWxsYmFjaykge1xuICBpZiAodHlwZW9mIGVuY29kaW5nID09PSAnZnVuY3Rpb24nKSB7XG4gICAgY2FsbGJhY2sgPSBlbmNvZGluZ1xuICAgIGVuY29kaW5nID0gJ3V0ZjgnXG4gIH1cblxuICBjb25zdCBkaXIgPSBwYXRoLmRpcm5hbWUoZmlsZSlcbiAgcGF0aEV4aXN0cyhkaXIsIChlcnIsIGl0RG9lcykgPT4ge1xuICAgIGlmIChlcnIpIHJldHVybiBjYWxsYmFjayhlcnIpXG4gICAgaWYgKGl0RG9lcykgcmV0dXJuIGZzLndyaXRlRmlsZShmaWxlLCBkYXRhLCBlbmNvZGluZywgY2FsbGJhY2spXG5cbiAgICBta2Rpci5ta2RpcnMoZGlyLCBlcnIgPT4ge1xuICAgICAgaWYgKGVycikgcmV0dXJuIGNhbGxiYWNrKGVycilcblxuICAgICAgZnMud3JpdGVGaWxlKGZpbGUsIGRhdGEsIGVuY29kaW5nLCBjYWxsYmFjaylcbiAgICB9KVxuICB9KVxufVxuXG5mdW5jdGlvbiBvdXRwdXRGaWxlU3luYyAoZmlsZSwgZGF0YSwgZW5jb2RpbmcpIHtcbiAgY29uc3QgZGlyID0gcGF0aC5kaXJuYW1lKGZpbGUpXG4gIGlmIChmcy5leGlzdHNTeW5jKGRpcikpIHtcbiAgICByZXR1cm4gZnMud3JpdGVGaWxlU3luYy5hcHBseShmcywgYXJndW1lbnRzKVxuICB9XG4gIG1rZGlyLm1rZGlyc1N5bmMoZGlyKVxuICBmcy53cml0ZUZpbGVTeW5jLmFwcGx5KGZzLCBhcmd1bWVudHMpXG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBvdXRwdXRGaWxlOiB1KG91dHB1dEZpbGUpLFxuICBvdXRwdXRGaWxlU3luY1xufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2VsZWN0cm9uLXVwZGF0ZXIvbm9kZV9tb2R1bGVzL2ZzLWV4dHJhL2xpYi9vdXRwdXQvaW5kZXguanMiLCJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5naXRodWJVcmwgPSBnaXRodWJVcmw7XG5leHBvcnRzLmdldFMzTGlrZVByb3ZpZGVyQmFzZVVybCA9IGdldFMzTGlrZVByb3ZpZGVyQmFzZVVybDtcbi8qKiBAcHJpdmF0ZSAqL1xuZnVuY3Rpb24gZ2l0aHViVXJsKG9wdGlvbnMsIGRlZmF1bHRIb3N0ID0gXCJnaXRodWIuY29tXCIpIHtcbiAgICByZXR1cm4gYCR7b3B0aW9ucy5wcm90b2NvbCB8fCBcImh0dHBzXCJ9Oi8vJHtvcHRpb25zLmhvc3QgfHwgZGVmYXVsdEhvc3R9YDtcbn1cbmZ1bmN0aW9uIGdldFMzTGlrZVByb3ZpZGVyQmFzZVVybChjb25maWd1cmF0aW9uKSB7XG4gICAgY29uc3QgcHJvdmlkZXIgPSBjb25maWd1cmF0aW9uLnByb3ZpZGVyO1xuICAgIGlmIChwcm92aWRlciA9PT0gXCJzM1wiKSB7XG4gICAgICAgIHJldHVybiBzM1VybChjb25maWd1cmF0aW9uKTtcbiAgICB9XG4gICAgaWYgKHByb3ZpZGVyID09PSBcInNwYWNlc1wiKSB7XG4gICAgICAgIHJldHVybiBzcGFjZXNVcmwoY29uZmlndXJhdGlvbik7XG4gICAgfVxuICAgIHRocm93IG5ldyBFcnJvcihgTm90IHN1cHBvcnRlZCBwcm92aWRlcjogJHtwcm92aWRlcn1gKTtcbn1cbmZ1bmN0aW9uIHMzVXJsKG9wdGlvbnMpIHtcbiAgICBsZXQgdXJsO1xuICAgIGlmIChvcHRpb25zLmVuZHBvaW50ICE9IG51bGwpIHtcbiAgICAgICAgdXJsID0gYCR7b3B0aW9ucy5lbmRwb2ludH0vJHtvcHRpb25zLmJ1Y2tldH1gO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGlmICghb3B0aW9ucy5idWNrZXQuaW5jbHVkZXMoXCIuXCIpKSB7XG4gICAgICAgICAgICBpZiAob3B0aW9ucy5yZWdpb24gPT09IFwiY24tbm9ydGgtMVwiKSB7XG4gICAgICAgICAgICAgICAgdXJsID0gYGh0dHBzOi8vJHtvcHRpb25zLmJ1Y2tldH0uczMuJHtvcHRpb25zLnJlZ2lvbn0uYW1hem9uYXdzLmNvbS5jbmA7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHVybCA9IGBodHRwczovLyR7b3B0aW9ucy5idWNrZXR9LnMzLmFtYXpvbmF3cy5jb21gO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKG9wdGlvbnMucmVnaW9uID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEJ1Y2tldCBuYW1lIFwiJHtvcHRpb25zLmJ1Y2tldH1cIiBpbmNsdWRlcyBhIGRvdCwgYnV0IFMzIHJlZ2lvbiBpcyBtaXNzaW5nYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBzcGVjaWFsIGNhc2UsIHNlZSBodHRwOi8vZG9jcy5hd3MuYW1hem9uLmNvbS9BbWF6b25TMy9sYXRlc3QvZGV2L1VzaW5nQnVja2V0Lmh0bWwjYWNjZXNzLWJ1Y2tldC1pbnRyb1xuICAgICAgICAgICAgdXJsID0gb3B0aW9ucy5yZWdpb24gPT09IFwidXMtZWFzdC0xXCIgPyBgaHR0cHM6Ly9zMy5hbWF6b25hd3MuY29tLyR7b3B0aW9ucy5idWNrZXR9YCA6IGBodHRwczovL3MzLSR7b3B0aW9ucy5yZWdpb259LmFtYXpvbmF3cy5jb20vJHtvcHRpb25zLmJ1Y2tldH1gO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChvcHRpb25zLnBhdGggIT0gbnVsbCkge1xuICAgICAgICB1cmwgKz0gYC8ke29wdGlvbnMucGF0aH1gO1xuICAgIH1cbiAgICByZXR1cm4gdXJsO1xufVxuZnVuY3Rpb24gc3BhY2VzVXJsKG9wdGlvbnMpIHtcbiAgICBpZiAob3B0aW9ucy5uYW1lID09IG51bGwpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBuYW1lIGlzIG1pc3NpbmdgKTtcbiAgICB9XG4gICAgaWYgKG9wdGlvbnMucmVnaW9uID09IG51bGwpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGByZWdpb24gaXMgbWlzc2luZ2ApO1xuICAgIH1cbiAgICBsZXQgdXJsID0gYGh0dHBzOi8vJHtvcHRpb25zLm5hbWV9LiR7b3B0aW9ucy5yZWdpb259LmRpZ2l0YWxvY2VhbnNwYWNlcy5jb21gO1xuICAgIGlmIChvcHRpb25zLnBhdGggIT0gbnVsbCkge1xuICAgICAgICB1cmwgKz0gYC8ke29wdGlvbnMucGF0aH1gO1xuICAgIH1cbiAgICByZXR1cm4gdXJsO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cHVibGlzaE9wdGlvbnMuanMubWFwXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2VsZWN0cm9uLXVwZGF0ZXIvbm9kZV9tb2R1bGVzL2J1aWxkZXItdXRpbC1ydW50aW1lL291dC9wdWJsaXNoT3B0aW9ucy5qcyIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5wYXJzZURuID0gcGFyc2VEbjtcbmZ1bmN0aW9uIHBhcnNlRG4oc2VxKSB7XG4gICAgbGV0IHF1b3RlZCA9IGZhbHNlO1xuICAgIGxldCBrZXkgPSBudWxsO1xuICAgIGxldCB0b2tlbiA9IFwiXCI7XG4gICAgbGV0IG5leHROb25TcGFjZSA9IDA7XG4gICAgc2VxID0gc2VxLnRyaW0oKTtcbiAgICBjb25zdCByZXN1bHQgPSBuZXcgTWFwKCk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPD0gc2VxLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmIChpID09PSBzZXEubGVuZ3RoKSB7XG4gICAgICAgICAgICBpZiAoa2V5ICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnNldChrZXksIHRva2VuKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGNoID0gc2VxW2ldO1xuICAgICAgICBpZiAocXVvdGVkKSB7XG4gICAgICAgICAgICBpZiAoY2ggPT09ICdcIicpIHtcbiAgICAgICAgICAgICAgICBxdW90ZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmIChjaCA9PT0gJ1wiJykge1xuICAgICAgICAgICAgICAgIHF1b3RlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY2ggPT09IFwiXFxcXFwiKSB7XG4gICAgICAgICAgICAgICAgaSsrO1xuICAgICAgICAgICAgICAgIGNvbnN0IG9yZCA9IHBhcnNlSW50KHNlcS5zbGljZShpLCBpICsgMiksIDE2KTtcbiAgICAgICAgICAgICAgICBpZiAoTnVtYmVyLmlzTmFOKG9yZCkpIHtcbiAgICAgICAgICAgICAgICAgICAgdG9rZW4gKz0gc2VxW2ldO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGkrKztcbiAgICAgICAgICAgICAgICAgICAgdG9rZW4gKz0gU3RyaW5nLmZyb21DaGFyQ29kZShvcmQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChrZXkgPT09IG51bGwgJiYgY2ggPT09IFwiPVwiKSB7XG4gICAgICAgICAgICAgICAga2V5ID0gdG9rZW47XG4gICAgICAgICAgICAgICAgdG9rZW4gPSBcIlwiO1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGNoID09PSBcIixcIiB8fCBjaCA9PT0gXCI7XCIgfHwgY2ggPT09IFwiK1wiKSB7XG4gICAgICAgICAgICAgICAgaWYgKGtleSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQuc2V0KGtleSwgdG9rZW4pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBrZXkgPSBudWxsO1xuICAgICAgICAgICAgICAgIHRva2VuID0gXCJcIjtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoY2ggPT09IFwiIFwiICYmICFxdW90ZWQpIHtcbiAgICAgICAgICAgIGlmICh0b2tlbi5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpID4gbmV4dE5vblNwYWNlKSB7XG4gICAgICAgICAgICAgICAgbGV0IGogPSBpO1xuICAgICAgICAgICAgICAgIHdoaWxlIChzZXFbal0gPT09IFwiIFwiKSB7XG4gICAgICAgICAgICAgICAgICAgIGorKztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbmV4dE5vblNwYWNlID0gajtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChuZXh0Tm9uU3BhY2UgPj0gc2VxLmxlbmd0aCB8fCBzZXFbbmV4dE5vblNwYWNlXSA9PT0gXCIsXCIgfHwgc2VxW25leHROb25TcGFjZV0gPT09IFwiO1wiIHx8IGtleSA9PT0gbnVsbCAmJiBzZXFbbmV4dE5vblNwYWNlXSA9PT0gXCI9XCIgfHwga2V5ICE9PSBudWxsICYmIHNlcVtuZXh0Tm9uU3BhY2VdID09PSBcIitcIikge1xuICAgICAgICAgICAgICAgIGkgPSBuZXh0Tm9uU3BhY2UgLSAxO1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRva2VuICs9IGNoO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cmZjMjI1M1BhcnNlci5qcy5tYXBcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvZWxlY3Ryb24tdXBkYXRlci9ub2RlX21vZHVsZXMvYnVpbGRlci11dGlsLXJ1bnRpbWUvb3V0L3JmYzIyNTNQYXJzZXIuanMiLCJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5uaWwgPSBleHBvcnRzLlVVSUQgPSB1bmRlZmluZWQ7XG5cbnZhciBfY3J5cHRvO1xuXG5mdW5jdGlvbiBfbG9hZF9jcnlwdG8oKSB7XG4gICAgcmV0dXJuIF9jcnlwdG8gPSByZXF1aXJlKFwiY3J5cHRvXCIpO1xufVxuXG52YXIgX2luZGV4O1xuXG5mdW5jdGlvbiBfbG9hZF9pbmRleCgpIHtcbiAgICByZXR1cm4gX2luZGV4ID0gcmVxdWlyZShcIi4vaW5kZXhcIik7XG59XG5cbmNvbnN0IGludmFsaWROYW1lID0gXCJvcHRpb25zLm5hbWUgbXVzdCBiZSBlaXRoZXIgYSBzdHJpbmcgb3IgYSBCdWZmZXJcIjtcbmNvbnN0IG1vcmVUaGFuMTAwMDAgPSBcImNhbiBub3QgZ2VuZXJhdGUgbW9yZSB0aGFuIDEwMDAwIFVVSURzIHBlciBzZWNvbmRcIjtcbi8vIE5vZGUgSUQgYWNjb3JkaW5nIHRvIHJmYzQxMjIjc2VjdGlvbi00LjVcbmNvbnN0IHJhbmRvbUhvc3QgPSAoMCwgKF9jcnlwdG8gfHwgX2xvYWRfY3J5cHRvKCkpLnJhbmRvbUJ5dGVzKSgxNik7XG5yYW5kb21Ib3N0WzBdID0gcmFuZG9tSG9zdFswXSB8IDB4MDE7XG4vLyByYW5kb21pemUgY2xvY2tTZXEgaW5pdGlhbGx5LCBhcyBwZXIgcmZjNDEyMiNzZWN0aW9uLTQuMS41XG5jb25zdCBzZWVkID0gKDAsIChfY3J5cHRvIHx8IF9sb2FkX2NyeXB0bygpKS5yYW5kb21CeXRlcykoMik7XG5sZXQgY2xvY2tTZXEgPSAoc2VlZFswXSB8IHNlZWRbMV0gPDwgOCkgJiAweDNmZmY7XG4vLyBjbG9jayB2YWx1ZXNcbmxldCBsYXN0TVRpbWUgPSAwO1xubGV0IGxhc3ROVGltZSA9IDA7XG4vLyBsb29rdXAgdGFibGUgaGV4IHRvIGJ5dGVcbmNvbnN0IGhleDJieXRlID0ge307XG4vLyBsb29rdXAgdGFibGUgYnl0ZSB0byBoZXhcbmNvbnN0IGJ5dGUyaGV4ID0gW107XG4vLyBwb3B1bGF0ZSBsb29rdXAgdGFibGVzXG5mb3IgKGxldCBpID0gMDsgaSA8IDI1NjsgaSsrKSB7XG4gICAgY29uc3QgaGV4ID0gKGkgKyAweDEwMCkudG9TdHJpbmcoMTYpLnN1YnN0cigxKTtcbiAgICBoZXgyYnl0ZVtoZXhdID0gaTtcbiAgICBieXRlMmhleFtpXSA9IGhleDtcbn1cbi8vIFVVSUQgY2xhc3NcbmNsYXNzIFVVSUQge1xuICAgIGNvbnN0cnVjdG9yKHV1aWQpIHtcbiAgICAgICAgY29uc3QgY2hlY2sgPSBVVUlELmNoZWNrKHV1aWQpO1xuICAgICAgICBpZiAoIWNoZWNrKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJub3QgYSBVVUlEXCIpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudmVyc2lvbiA9IGNoZWNrLnZlcnNpb247XG4gICAgICAgIGlmIChjaGVjay5mb3JtYXQgPT09IFwiYXNjaWlcIikge1xuICAgICAgICAgICAgdGhpcy5hc2NpaSA9IHV1aWQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmJpbmFyeSA9IHV1aWQ7XG4gICAgICAgIH1cbiAgICB9XG4gICAgc3RhdGljIHYxKCkge1xuICAgICAgICByZXR1cm4gdXVpZFRpbWVCYXNlZChyYW5kb21Ib3N0KTtcbiAgICB9XG4gICAgc3RhdGljIHY1KG5hbWUsIG5hbWVzcGFjZSkge1xuICAgICAgICByZXR1cm4gdXVpZE5hbWVkKG5hbWUsIFwic2hhMVwiLCAweDUwLCBuYW1lc3BhY2UpO1xuICAgIH1cbiAgICB0b1N0cmluZygpIHtcbiAgICAgICAgaWYgKHRoaXMuYXNjaWkgPT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5hc2NpaSA9IHN0cmluZ2lmeSh0aGlzLmJpbmFyeSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuYXNjaWk7XG4gICAgfVxuICAgIHRvQnVmZmVyKCkge1xuICAgICAgICBpZiAodGhpcy5iaW5hcnkgPT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5iaW5hcnkgPSBVVUlELnBhcnNlKHRoaXMuYXNjaWkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBCdWZmZXIuZnJvbSh0aGlzLmJpbmFyeSk7XG4gICAgfVxuICAgIGluc3BlY3QoKSB7XG4gICAgICAgIHJldHVybiBgVVVJRCB2JHt0aGlzLnZlcnNpb259ICR7dGhpcy50b1N0cmluZygpfWA7XG4gICAgfVxuICAgIHN0YXRpYyBjaGVjayh1dWlkLCBvZmZzZXQgPSAwKSB7XG4gICAgICAgIGlmICh0eXBlb2YgdXVpZCA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgdXVpZCA9IHV1aWQudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICAgIGlmICghL15bYS1mMC05XXs4fShcXC1bYS1mMC05XXs0fSl7M31cXC0oW2EtZjAtOV17MTJ9KSQvLnRlc3QodXVpZCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodXVpZCA9PT0gXCIwMDAwMDAwMC0wMDAwLTAwMDAtMDAwMC0wMDAwMDAwMDAwMDBcIikge1xuICAgICAgICAgICAgICAgIHJldHVybiB7IHZlcnNpb246IHVuZGVmaW5lZCwgdmFyaWFudDogXCJuaWxcIiwgZm9ybWF0OiBcImFzY2lpXCIgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdmVyc2lvbjogKGhleDJieXRlW3V1aWRbMTRdICsgdXVpZFsxNV1dICYgMHhmMCkgPj4gNCxcbiAgICAgICAgICAgICAgICB2YXJpYW50OiBnZXRWYXJpYW50KChoZXgyYnl0ZVt1dWlkWzE5XSArIHV1aWRbMjBdXSAmIDB4ZTApID4+IDUpLFxuICAgICAgICAgICAgICAgIGZvcm1hdDogXCJhc2NpaVwiXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGlmIChCdWZmZXIuaXNCdWZmZXIodXVpZCkpIHtcbiAgICAgICAgICAgIGlmICh1dWlkLmxlbmd0aCA8IG9mZnNldCArIDE2KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IGkgPSAwO1xuICAgICAgICAgICAgZm9yICg7IGkgPCAxNjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKHV1aWRbb2Zmc2V0ICsgaV0gIT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGkgPT09IDE2KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgdmVyc2lvbjogdW5kZWZpbmVkLCB2YXJpYW50OiBcIm5pbFwiLCBmb3JtYXQ6IFwiYmluYXJ5XCIgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdmVyc2lvbjogKHV1aWRbb2Zmc2V0ICsgNl0gJiAweGYwKSA+PiA0LFxuICAgICAgICAgICAgICAgIHZhcmlhbnQ6IGdldFZhcmlhbnQoKHV1aWRbb2Zmc2V0ICsgOF0gJiAweGUwKSA+PiA1KSxcbiAgICAgICAgICAgICAgICBmb3JtYXQ6IFwiYmluYXJ5XCJcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgKDAsIChfaW5kZXggfHwgX2xvYWRfaW5kZXgoKSkubmV3RXJyb3IpKFwiVW5rbm93biB0eXBlIG9mIHV1aWRcIiwgXCJFUlJfVU5LTk9XTl9VVUlEX1RZUEVcIik7XG4gICAgfVxuICAgIC8vIHJlYWQgc3RyaW5naWZpZWQgdXVpZCBpbnRvIGEgQnVmZmVyXG4gICAgc3RhdGljIHBhcnNlKGlucHV0KSB7XG4gICAgICAgIGNvbnN0IGJ1ZmZlciA9IEJ1ZmZlci5hbGxvY1Vuc2FmZSgxNik7XG4gICAgICAgIGxldCBqID0gMDtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCAxNjsgaSsrKSB7XG4gICAgICAgICAgICBidWZmZXJbaV0gPSBoZXgyYnl0ZVtpbnB1dFtqKytdICsgaW5wdXRbaisrXV07XG4gICAgICAgICAgICBpZiAoaSA9PT0gMyB8fCBpID09PSA1IHx8IGkgPT09IDcgfHwgaSA9PT0gOSkge1xuICAgICAgICAgICAgICAgIGogKz0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYnVmZmVyO1xuICAgIH1cbn1cbmV4cG9ydHMuVVVJRCA9IFVVSUQ7IC8vIGZyb20gcmZjNDEyMiNhcHBlbmRpeC1DXG5cblVVSUQuVVJMID0gbmV3IFVVSUQoXCI2YmE3YjgxMS05ZGFkLTExZDEtODBiNC0wMGMwNGZkNDMwYzhcIik7XG5VVUlELk9JRCA9IFVVSUQucGFyc2UoXCI2YmE3YjgxMi05ZGFkLTExZDEtODBiNC0wMGMwNGZkNDMwYzhcIik7XG4vLyBhY2NvcmRpbmcgdG8gcmZjNDEyMiNzZWN0aW9uLTQuMS4xXG5mdW5jdGlvbiBnZXRWYXJpYW50KGJpdHMpIHtcbiAgICBzd2l0Y2ggKGJpdHMpIHtcbiAgICAgICAgY2FzZSAwOlxuICAgICAgICBjYXNlIDE6XG4gICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgIHJldHVybiBcIm5jc1wiO1xuICAgICAgICBjYXNlIDQ6XG4gICAgICAgIGNhc2UgNTpcbiAgICAgICAgICAgIHJldHVybiBcInJmYzQxMjJcIjtcbiAgICAgICAgY2FzZSA2OlxuICAgICAgICAgICAgcmV0dXJuIFwibWljcm9zb2Z0XCI7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICByZXR1cm4gXCJmdXR1cmVcIjtcbiAgICB9XG59XG52YXIgVXVpZEVuY29kaW5nO1xuKGZ1bmN0aW9uIChVdWlkRW5jb2RpbmcpIHtcbiAgICBVdWlkRW5jb2RpbmdbVXVpZEVuY29kaW5nW1wiQVNDSUlcIl0gPSAwXSA9IFwiQVNDSUlcIjtcbiAgICBVdWlkRW5jb2RpbmdbVXVpZEVuY29kaW5nW1wiQklOQVJZXCJdID0gMV0gPSBcIkJJTkFSWVwiO1xuICAgIFV1aWRFbmNvZGluZ1tVdWlkRW5jb2RpbmdbXCJPQkpFQ1RcIl0gPSAyXSA9IFwiT0JKRUNUXCI7XG59KShVdWlkRW5jb2RpbmcgfHwgKFV1aWRFbmNvZGluZyA9IHt9KSk7XG4vLyB2MVxuZnVuY3Rpb24gdXVpZFRpbWVCYXNlZChub2RlSWQsIGVuY29kaW5nID0gVXVpZEVuY29kaW5nLkFTQ0lJKSB7XG4gICAgbGV0IG1UaW1lID0gRGF0ZS5ub3coKTtcbiAgICBsZXQgblRpbWUgPSBsYXN0TlRpbWUgKyAxO1xuICAgIGNvbnN0IGRlbHRhID0gbVRpbWUgLSBsYXN0TVRpbWUgKyAoblRpbWUgLSBsYXN0TlRpbWUpIC8gMTAwMDA7XG4gICAgaWYgKGRlbHRhIDwgMCkge1xuICAgICAgICBjbG9ja1NlcSA9IGNsb2NrU2VxICsgMSAmIDB4M2ZmZjtcbiAgICAgICAgblRpbWUgPSAwO1xuICAgIH0gZWxzZSBpZiAobVRpbWUgPiBsYXN0TVRpbWUpIHtcbiAgICAgICAgblRpbWUgPSAwO1xuICAgIH0gZWxzZSBpZiAoblRpbWUgPj0gMTAwMDApIHtcbiAgICAgICAgcmV0dXJuIG1vcmVUaGFuMTAwMDA7XG4gICAgfVxuICAgIGxhc3RNVGltZSA9IG1UaW1lO1xuICAgIGxhc3ROVGltZSA9IG5UaW1lO1xuICAgIC8vIHVuaXggdGltZXN0YW1wIHRvIGdyZWdvcmlhbiBlcG9jaCBhcyBwZXIgcmZjNDEyMiNzZWN0aW9uLTQuNVxuICAgIG1UaW1lICs9IDEyMjE5MjkyODAwMDAwO1xuICAgIGNvbnN0IGJ1ZmZlciA9IEJ1ZmZlci5hbGxvY1Vuc2FmZSgxNik7XG4gICAgY29uc3QgbXlDbG9ja1NlcSA9IGNsb2NrU2VxO1xuICAgIGNvbnN0IHRpbWVMb3cgPSAoKG1UaW1lICYgMHhmZmZmZmZmKSAqIDEwMDAwICsgblRpbWUpICUgMHgxMDAwMDAwMDA7XG4gICAgY29uc3QgdGltZUhpZ2ggPSBtVGltZSAvIDB4MTAwMDAwMDAwICogMTAwMDAgJiAweGZmZmZmZmY7XG4gICAgYnVmZmVyWzBdID0gdGltZUxvdyA+Pj4gMjQgJiAweGZmO1xuICAgIGJ1ZmZlclsxXSA9IHRpbWVMb3cgPj4+IDE2ICYgMHhmZjtcbiAgICBidWZmZXJbMl0gPSB0aW1lTG93ID4+PiA4ICYgMHhmZjtcbiAgICBidWZmZXJbM10gPSB0aW1lTG93ICYgMHhmZjtcbiAgICBidWZmZXJbNF0gPSB0aW1lSGlnaCA+Pj4gOCAmIDB4ZmY7XG4gICAgYnVmZmVyWzVdID0gdGltZUhpZ2ggJiAweGZmO1xuICAgIGJ1ZmZlcls2XSA9IHRpbWVIaWdoID4+PiAyNCAmIDB4MGYgfCAweDEwO1xuICAgIGJ1ZmZlcls3XSA9IHRpbWVIaWdoID4+PiAxNiAmIDB4M2YgfCAweDgwO1xuICAgIGJ1ZmZlcls4XSA9IG15Q2xvY2tTZXEgPj4+IDg7XG4gICAgYnVmZmVyWzldID0gbXlDbG9ja1NlcSAmIDB4ZmY7XG4gICAgbGV0IHJlc3VsdDtcbiAgICBzd2l0Y2ggKGVuY29kaW5nKSB7XG4gICAgICAgIGNhc2UgVXVpZEVuY29kaW5nLkJJTkFSWTpcbiAgICAgICAgICAgIGJ1ZmZlclsxMF0gPSBub2RlSWRbMF07XG4gICAgICAgICAgICBidWZmZXJbMTFdID0gbm9kZUlkWzFdO1xuICAgICAgICAgICAgYnVmZmVyWzEyXSA9IG5vZGVJZFsyXTtcbiAgICAgICAgICAgIGJ1ZmZlclsxM10gPSBub2RlSWRbM107XG4gICAgICAgICAgICBidWZmZXJbMTRdID0gbm9kZUlkWzRdO1xuICAgICAgICAgICAgYnVmZmVyWzE1XSA9IG5vZGVJZFs1XTtcbiAgICAgICAgICAgIHJlc3VsdCA9IGJ1ZmZlcjtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFV1aWRFbmNvZGluZy5PQkpFQ1Q6XG4gICAgICAgICAgICBidWZmZXJbMTBdID0gbm9kZUlkWzBdO1xuICAgICAgICAgICAgYnVmZmVyWzExXSA9IG5vZGVJZFsxXTtcbiAgICAgICAgICAgIGJ1ZmZlclsxMl0gPSBub2RlSWRbMl07XG4gICAgICAgICAgICBidWZmZXJbMTNdID0gbm9kZUlkWzNdO1xuICAgICAgICAgICAgYnVmZmVyWzE0XSA9IG5vZGVJZFs0XTtcbiAgICAgICAgICAgIGJ1ZmZlclsxNV0gPSBub2RlSWRbNV07XG4gICAgICAgICAgICByZXN1bHQgPSBuZXcgVVVJRChidWZmZXIpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICByZXN1bHQgPSBieXRlMmhleFtidWZmZXJbMF1dICsgYnl0ZTJoZXhbYnVmZmVyWzFdXSArIGJ5dGUyaGV4W2J1ZmZlclsyXV0gKyBieXRlMmhleFtidWZmZXJbM11dICsgXCItXCIgKyBieXRlMmhleFtidWZmZXJbNF1dICsgYnl0ZTJoZXhbYnVmZmVyWzVdXSArIFwiLVwiICsgYnl0ZTJoZXhbYnVmZmVyWzZdXSArIGJ5dGUyaGV4W2J1ZmZlcls3XV0gKyBcIi1cIiArIGJ5dGUyaGV4W2J1ZmZlcls4XV0gKyBieXRlMmhleFtidWZmZXJbOV1dICsgXCItXCIgKyBieXRlMmhleFtub2RlSWRbMF1dICsgYnl0ZTJoZXhbbm9kZUlkWzFdXSArIGJ5dGUyaGV4W25vZGVJZFsyXV0gKyBieXRlMmhleFtub2RlSWRbM11dICsgYnl0ZTJoZXhbbm9kZUlkWzRdXSArIGJ5dGUyaGV4W25vZGVJZFs1XV07XG4gICAgICAgICAgICBicmVhaztcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbi8vIHYzICsgdjVcbmZ1bmN0aW9uIHV1aWROYW1lZChuYW1lLCBoYXNoTWV0aG9kLCB2ZXJzaW9uLCBuYW1lc3BhY2UsIGVuY29kaW5nID0gVXVpZEVuY29kaW5nLkFTQ0lJKSB7XG4gICAgY29uc3QgaGFzaCA9ICgwLCAoX2NyeXB0byB8fCBfbG9hZF9jcnlwdG8oKSkuY3JlYXRlSGFzaCkoaGFzaE1ldGhvZCk7XG4gICAgY29uc3QgbmFtZUlzTm90QVN0cmluZyA9IHR5cGVvZiBuYW1lICE9PSBcInN0cmluZ1wiO1xuICAgIGlmIChuYW1lSXNOb3RBU3RyaW5nICYmICFCdWZmZXIuaXNCdWZmZXIobmFtZSkpIHtcbiAgICAgICAgdGhyb3cgKDAsIChfaW5kZXggfHwgX2xvYWRfaW5kZXgoKSkubmV3RXJyb3IpKGludmFsaWROYW1lLCBcIkVSUl9JTlZBTElEX1VVSURfTkFNRVwiKTtcbiAgICB9XG4gICAgaGFzaC51cGRhdGUobmFtZXNwYWNlKTtcbiAgICBoYXNoLnVwZGF0ZShuYW1lLCBuYW1lSXNOb3RBU3RyaW5nID8gXCJsYXRpbjFcIiA6IFwidXRmOFwiKTtcbiAgICBjb25zdCBidWZmZXIgPSBoYXNoLmRpZ2VzdCgpO1xuICAgIGxldCByZXN1bHQ7XG4gICAgc3dpdGNoIChlbmNvZGluZykge1xuICAgICAgICBjYXNlIFV1aWRFbmNvZGluZy5CSU5BUlk6XG4gICAgICAgICAgICBidWZmZXJbNl0gPSBidWZmZXJbNl0gJiAweDBmIHwgdmVyc2lvbjtcbiAgICAgICAgICAgIGJ1ZmZlcls4XSA9IGJ1ZmZlcls4XSAmIDB4M2YgfCAweDgwO1xuICAgICAgICAgICAgcmVzdWx0ID0gYnVmZmVyO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgVXVpZEVuY29kaW5nLk9CSkVDVDpcbiAgICAgICAgICAgIGJ1ZmZlcls2XSA9IGJ1ZmZlcls2XSAmIDB4MGYgfCB2ZXJzaW9uO1xuICAgICAgICAgICAgYnVmZmVyWzhdID0gYnVmZmVyWzhdICYgMHgzZiB8IDB4ODA7XG4gICAgICAgICAgICByZXN1bHQgPSBuZXcgVVVJRChidWZmZXIpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICByZXN1bHQgPSBieXRlMmhleFtidWZmZXJbMF1dICsgYnl0ZTJoZXhbYnVmZmVyWzFdXSArIGJ5dGUyaGV4W2J1ZmZlclsyXV0gKyBieXRlMmhleFtidWZmZXJbM11dICsgXCItXCIgKyBieXRlMmhleFtidWZmZXJbNF1dICsgYnl0ZTJoZXhbYnVmZmVyWzVdXSArIFwiLVwiICsgYnl0ZTJoZXhbYnVmZmVyWzZdICYgMHgwZiB8IHZlcnNpb25dICsgYnl0ZTJoZXhbYnVmZmVyWzddXSArIFwiLVwiICsgYnl0ZTJoZXhbYnVmZmVyWzhdICYgMHgzZiB8IDB4ODBdICsgYnl0ZTJoZXhbYnVmZmVyWzldXSArIFwiLVwiICsgYnl0ZTJoZXhbYnVmZmVyWzEwXV0gKyBieXRlMmhleFtidWZmZXJbMTFdXSArIGJ5dGUyaGV4W2J1ZmZlclsxMl1dICsgYnl0ZTJoZXhbYnVmZmVyWzEzXV0gKyBieXRlMmhleFtidWZmZXJbMTRdXSArIGJ5dGUyaGV4W2J1ZmZlclsxNV1dO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiBzdHJpbmdpZnkoYnVmZmVyKSB7XG4gICAgcmV0dXJuIGJ5dGUyaGV4W2J1ZmZlclswXV0gKyBieXRlMmhleFtidWZmZXJbMV1dICsgYnl0ZTJoZXhbYnVmZmVyWzJdXSArIGJ5dGUyaGV4W2J1ZmZlclszXV0gKyBcIi1cIiArIGJ5dGUyaGV4W2J1ZmZlcls0XV0gKyBieXRlMmhleFtidWZmZXJbNV1dICsgXCItXCIgKyBieXRlMmhleFtidWZmZXJbNl1dICsgYnl0ZTJoZXhbYnVmZmVyWzddXSArIFwiLVwiICsgYnl0ZTJoZXhbYnVmZmVyWzhdXSArIGJ5dGUyaGV4W2J1ZmZlcls5XV0gKyBcIi1cIiArIGJ5dGUyaGV4W2J1ZmZlclsxMF1dICsgYnl0ZTJoZXhbYnVmZmVyWzExXV0gKyBieXRlMmhleFtidWZmZXJbMTJdXSArIGJ5dGUyaGV4W2J1ZmZlclsxM11dICsgYnl0ZTJoZXhbYnVmZmVyWzE0XV0gKyBieXRlMmhleFtidWZmZXJbMTVdXTtcbn1cbi8vIGFjY29yZGluZyB0byByZmM0MTIyI3NlY3Rpb24tNC4xLjdcbmNvbnN0IG5pbCA9IGV4cG9ydHMubmlsID0gbmV3IFVVSUQoXCIwMDAwMDAwMC0wMDAwLTAwMDAtMDAwMC0wMDAwMDAwMDAwMDBcIik7XG4vLyBVVUlELnY0ID0gdXVpZFJhbmRvbVxuLy8gVVVJRC52NGZhc3QgPSB1dWlkUmFuZG9tRmFzdFxuLy8gVVVJRC52MyA9IGZ1bmN0aW9uKG9wdGlvbnMsIGNhbGxiYWNrKSB7XG4vLyAgICAgcmV0dXJuIHV1aWROYW1lZChcIm1kNVwiLCAweDMwLCBvcHRpb25zLCBjYWxsYmFjaylcbi8vIH0gXG4vLyMgc291cmNlTWFwcGluZ1VSTD11dWlkLmpzLm1hcFxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9lbGVjdHJvbi11cGRhdGVyL25vZGVfbW9kdWxlcy9idWlsZGVyLXV0aWwtcnVudGltZS9vdXQvdXVpZC5qcyIsIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLlhFbGVtZW50ID0gdW5kZWZpbmVkO1xuZXhwb3J0cy5wYXJzZVhtbCA9IHBhcnNlWG1sO1xuXG52YXIgX3NheDtcblxuZnVuY3Rpb24gX2xvYWRfc2F4KCkge1xuICAgIHJldHVybiBfc2F4ID0gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQocmVxdWlyZShcInNheFwiKSk7XG59XG5cbnZhciBfaW5kZXg7XG5cbmZ1bmN0aW9uIF9sb2FkX2luZGV4KCkge1xuICAgIHJldHVybiBfaW5kZXggPSByZXF1aXJlKFwiLi9pbmRleFwiKTtcbn1cblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQob2JqKSB7IGlmIChvYmogJiYgb2JqLl9fZXNNb2R1bGUpIHsgcmV0dXJuIG9iajsgfSBlbHNlIHsgdmFyIG5ld09iaiA9IHt9OyBpZiAob2JqICE9IG51bGwpIHsgZm9yICh2YXIga2V5IGluIG9iaikgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwga2V5KSkgbmV3T2JqW2tleV0gPSBvYmpba2V5XTsgfSB9IG5ld09iai5kZWZhdWx0ID0gb2JqOyByZXR1cm4gbmV3T2JqOyB9IH1cblxuY2xhc3MgWEVsZW1lbnQge1xuICAgIGNvbnN0cnVjdG9yKG5hbWUpIHtcbiAgICAgICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICAgICAgdGhpcy52YWx1ZSA9IFwiXCI7XG4gICAgICAgIHRoaXMuYXR0cmlidXRlcyA9IG51bGw7XG4gICAgICAgIHRoaXMuaXNDRGF0YSA9IGZhbHNlO1xuICAgICAgICB0aGlzLmVsZW1lbnRzID0gbnVsbDtcbiAgICAgICAgaWYgKCFuYW1lKSB7XG4gICAgICAgICAgICB0aHJvdyAoMCwgKF9pbmRleCB8fCBfbG9hZF9pbmRleCgpKS5uZXdFcnJvcikoXCJFbGVtZW50IG5hbWUgY2Fubm90IGJlIGVtcHR5XCIsIFwiRVJSX1hNTF9FTEVNRU5UX05BTUVfRU1QVFlcIik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFpc1ZhbGlkTmFtZShuYW1lKSkge1xuICAgICAgICAgICAgdGhyb3cgKDAsIChfaW5kZXggfHwgX2xvYWRfaW5kZXgoKSkubmV3RXJyb3IpKGBJbnZhbGlkIGVsZW1lbnQgbmFtZTogJHtuYW1lfWAsIFwiRVJSX1hNTF9FTEVNRU5UX0lOVkFMSURfTkFNRVwiKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhdHRyaWJ1dGUobmFtZSkge1xuICAgICAgICBjb25zdCByZXN1bHQgPSB0aGlzLmF0dHJpYnV0ZXMgPT09IG51bGwgPyBudWxsIDogdGhpcy5hdHRyaWJ1dGVzW25hbWVdO1xuICAgICAgICBpZiAocmVzdWx0ID09IG51bGwpIHtcbiAgICAgICAgICAgIHRocm93ICgwLCAoX2luZGV4IHx8IF9sb2FkX2luZGV4KCkpLm5ld0Vycm9yKShgTm8gYXR0cmlidXRlIFwiJHtuYW1lfVwiYCwgXCJFUlJfWE1MX01JU1NFRF9BVFRSSUJVVEVcIik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgcmVtb3ZlQXR0cmlidXRlKG5hbWUpIHtcbiAgICAgICAgaWYgKHRoaXMuYXR0cmlidXRlcyAhPT0gbnVsbCkge1xuICAgICAgICAgICAgZGVsZXRlIHRoaXMuYXR0cmlidXRlc1tuYW1lXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbGVtZW50KG5hbWUsIGlnbm9yZUNhc2UgPSBmYWxzZSwgZXJyb3JJZk1pc3NlZCA9IG51bGwpIHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gdGhpcy5lbGVtZW50T3JOdWxsKG5hbWUsIGlnbm9yZUNhc2UpO1xuICAgICAgICBpZiAocmVzdWx0ID09PSBudWxsKSB7XG4gICAgICAgICAgICB0aHJvdyAoMCwgKF9pbmRleCB8fCBfbG9hZF9pbmRleCgpKS5uZXdFcnJvcikoZXJyb3JJZk1pc3NlZCB8fCBgTm8gZWxlbWVudCBcIiR7bmFtZX1cImAsIFwiRVJSX1hNTF9NSVNTRURfRUxFTUVOVFwiKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICBlbGVtZW50T3JOdWxsKG5hbWUsIGlnbm9yZUNhc2UgPSBmYWxzZSkge1xuICAgICAgICBpZiAodGhpcy5lbGVtZW50cyA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChjb25zdCBlbGVtZW50IG9mIHRoaXMuZWxlbWVudHMpIHtcbiAgICAgICAgICAgIGlmIChpc05hbWVFcXVhbHMoZWxlbWVudCwgbmFtZSwgaWdub3JlQ2FzZSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZWxlbWVudDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgZ2V0RWxlbWVudHMobmFtZSwgaWdub3JlQ2FzZSA9IGZhbHNlKSB7XG4gICAgICAgIGlmICh0aGlzLmVsZW1lbnRzID09PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuZWxlbWVudHMuZmlsdGVyKGl0ID0+IGlzTmFtZUVxdWFscyhpdCwgbmFtZSwgaWdub3JlQ2FzZSkpO1xuICAgIH1cbiAgICBlbGVtZW50VmFsdWVPckVtcHR5KG5hbWUsIGlnbm9yZUNhc2UgPSBmYWxzZSkge1xuICAgICAgICBjb25zdCBlbGVtZW50ID0gdGhpcy5lbGVtZW50T3JOdWxsKG5hbWUsIGlnbm9yZUNhc2UpO1xuICAgICAgICByZXR1cm4gZWxlbWVudCA9PT0gbnVsbCA/IFwiXCIgOiBlbGVtZW50LnZhbHVlO1xuICAgIH1cbn1cbmV4cG9ydHMuWEVsZW1lbnQgPSBYRWxlbWVudDtcbmNvbnN0IE5BTUVfUkVHX0VYUCA9IG5ldyBSZWdFeHAoL15bQS1aYS16X11bOkEtWmEtejAtOV8tXSokL2kpO1xuZnVuY3Rpb24gaXNWYWxpZE5hbWUobmFtZSkge1xuICAgIHJldHVybiBOQU1FX1JFR19FWFAudGVzdChuYW1lKTtcbn1cbmZ1bmN0aW9uIGlzTmFtZUVxdWFscyhlbGVtZW50LCBuYW1lLCBpZ25vcmVDYXNlKSB7XG4gICAgY29uc3QgZWxlbWVudE5hbWUgPSBlbGVtZW50Lm5hbWU7XG4gICAgcmV0dXJuIGVsZW1lbnROYW1lID09PSBuYW1lIHx8IGlnbm9yZUNhc2UgPT09IHRydWUgJiYgZWxlbWVudE5hbWUubGVuZ3RoID09PSBuYW1lLmxlbmd0aCAmJiBlbGVtZW50TmFtZS50b0xvd2VyQ2FzZSgpID09PSBuYW1lLnRvTG93ZXJDYXNlKCk7XG59XG5mdW5jdGlvbiBwYXJzZVhtbChkYXRhKSB7XG4gICAgbGV0IHJvb3RFbGVtZW50ID0gbnVsbDtcbiAgICBjb25zdCBwYXJzZXIgPSAoX3NheCB8fCBfbG9hZF9zYXgoKSkucGFyc2VyKHRydWUsIHt9KTtcbiAgICBjb25zdCBlbGVtZW50cyA9IFtdO1xuICAgIHBhcnNlci5vbm9wZW50YWcgPSBzYXhFbGVtZW50ID0+IHtcbiAgICAgICAgY29uc3QgZWxlbWVudCA9IG5ldyBYRWxlbWVudChzYXhFbGVtZW50Lm5hbWUpO1xuICAgICAgICBlbGVtZW50LmF0dHJpYnV0ZXMgPSBzYXhFbGVtZW50LmF0dHJpYnV0ZXM7XG4gICAgICAgIGlmIChyb290RWxlbWVudCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcm9vdEVsZW1lbnQgPSBlbGVtZW50O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgcGFyZW50ID0gZWxlbWVudHNbZWxlbWVudHMubGVuZ3RoIC0gMV07XG4gICAgICAgICAgICBpZiAocGFyZW50LmVsZW1lbnRzID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBwYXJlbnQuZWxlbWVudHMgPSBbXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHBhcmVudC5lbGVtZW50cy5wdXNoKGVsZW1lbnQpO1xuICAgICAgICB9XG4gICAgICAgIGVsZW1lbnRzLnB1c2goZWxlbWVudCk7XG4gICAgfTtcbiAgICBwYXJzZXIub25jbG9zZXRhZyA9ICgpID0+IHtcbiAgICAgICAgZWxlbWVudHMucG9wKCk7XG4gICAgfTtcbiAgICBwYXJzZXIub250ZXh0ID0gdGV4dCA9PiB7XG4gICAgICAgIGlmIChlbGVtZW50cy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBlbGVtZW50c1tlbGVtZW50cy5sZW5ndGggLSAxXS52YWx1ZSA9IHRleHQ7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHBhcnNlci5vbmNkYXRhID0gY2RhdGEgPT4ge1xuICAgICAgICBjb25zdCBlbGVtZW50ID0gZWxlbWVudHNbZWxlbWVudHMubGVuZ3RoIC0gMV07XG4gICAgICAgIGVsZW1lbnQudmFsdWUgPSBjZGF0YTtcbiAgICAgICAgZWxlbWVudC5pc0NEYXRhID0gdHJ1ZTtcbiAgICB9O1xuICAgIHBhcnNlci5vbmVycm9yID0gZXJyID0+IHtcbiAgICAgICAgdGhyb3cgZXJyO1xuICAgIH07XG4gICAgcGFyc2VyLndyaXRlKGRhdGEpO1xuICAgIHJldHVybiByb290RWxlbWVudDtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXhtbC5qcy5tYXBcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvZWxlY3Ryb24tdXBkYXRlci9ub2RlX21vZHVsZXMvYnVpbGRlci11dGlsLXJ1bnRpbWUvb3V0L3htbC5qcyIsIjsoZnVuY3Rpb24gKHNheCkgeyAvLyB3cmFwcGVyIGZvciBub24tbm9kZSBlbnZzXG4gIHNheC5wYXJzZXIgPSBmdW5jdGlvbiAoc3RyaWN0LCBvcHQpIHsgcmV0dXJuIG5ldyBTQVhQYXJzZXIoc3RyaWN0LCBvcHQpIH1cbiAgc2F4LlNBWFBhcnNlciA9IFNBWFBhcnNlclxuICBzYXguU0FYU3RyZWFtID0gU0FYU3RyZWFtXG4gIHNheC5jcmVhdGVTdHJlYW0gPSBjcmVhdGVTdHJlYW1cblxuICAvLyBXaGVuIHdlIHBhc3MgdGhlIE1BWF9CVUZGRVJfTEVOR1RIIHBvc2l0aW9uLCBzdGFydCBjaGVja2luZyBmb3IgYnVmZmVyIG92ZXJydW5zLlxuICAvLyBXaGVuIHdlIGNoZWNrLCBzY2hlZHVsZSB0aGUgbmV4dCBjaGVjayBmb3IgTUFYX0JVRkZFUl9MRU5HVEggLSAobWF4KGJ1ZmZlciBsZW5ndGhzKSksXG4gIC8vIHNpbmNlIHRoYXQncyB0aGUgZWFybGllc3QgdGhhdCBhIGJ1ZmZlciBvdmVycnVuIGNvdWxkIG9jY3VyLiAgVGhpcyB3YXksIGNoZWNrcyBhcmVcbiAgLy8gYXMgcmFyZSBhcyByZXF1aXJlZCwgYnV0IGFzIG9mdGVuIGFzIG5lY2Vzc2FyeSB0byBlbnN1cmUgbmV2ZXIgY3Jvc3NpbmcgdGhpcyBib3VuZC5cbiAgLy8gRnVydGhlcm1vcmUsIGJ1ZmZlcnMgYXJlIG9ubHkgdGVzdGVkIGF0IG1vc3Qgb25jZSBwZXIgd3JpdGUoKSwgc28gcGFzc2luZyBhIHZlcnlcbiAgLy8gbGFyZ2Ugc3RyaW5nIGludG8gd3JpdGUoKSBtaWdodCBoYXZlIHVuZGVzaXJhYmxlIGVmZmVjdHMsIGJ1dCB0aGlzIGlzIG1hbmFnZWFibGUgYnlcbiAgLy8gdGhlIGNhbGxlciwgc28gaXQgaXMgYXNzdW1lZCB0byBiZSBzYWZlLiAgVGh1cywgYSBjYWxsIHRvIHdyaXRlKCkgbWF5LCBpbiB0aGUgZXh0cmVtZVxuICAvLyBlZGdlIGNhc2UsIHJlc3VsdCBpbiBjcmVhdGluZyBhdCBtb3N0IG9uZSBjb21wbGV0ZSBjb3B5IG9mIHRoZSBzdHJpbmcgcGFzc2VkIGluLlxuICAvLyBTZXQgdG8gSW5maW5pdHkgdG8gaGF2ZSB1bmxpbWl0ZWQgYnVmZmVycy5cbiAgc2F4Lk1BWF9CVUZGRVJfTEVOR1RIID0gNjQgKiAxMDI0XG5cbiAgdmFyIGJ1ZmZlcnMgPSBbXG4gICAgJ2NvbW1lbnQnLCAnc2dtbERlY2wnLCAndGV4dE5vZGUnLCAndGFnTmFtZScsICdkb2N0eXBlJyxcbiAgICAncHJvY0luc3ROYW1lJywgJ3Byb2NJbnN0Qm9keScsICdlbnRpdHknLCAnYXR0cmliTmFtZScsXG4gICAgJ2F0dHJpYlZhbHVlJywgJ2NkYXRhJywgJ3NjcmlwdCdcbiAgXVxuXG4gIHNheC5FVkVOVFMgPSBbXG4gICAgJ3RleHQnLFxuICAgICdwcm9jZXNzaW5naW5zdHJ1Y3Rpb24nLFxuICAgICdzZ21sZGVjbGFyYXRpb24nLFxuICAgICdkb2N0eXBlJyxcbiAgICAnY29tbWVudCcsXG4gICAgJ29wZW50YWdzdGFydCcsXG4gICAgJ2F0dHJpYnV0ZScsXG4gICAgJ29wZW50YWcnLFxuICAgICdjbG9zZXRhZycsXG4gICAgJ29wZW5jZGF0YScsXG4gICAgJ2NkYXRhJyxcbiAgICAnY2xvc2VjZGF0YScsXG4gICAgJ2Vycm9yJyxcbiAgICAnZW5kJyxcbiAgICAncmVhZHknLFxuICAgICdzY3JpcHQnLFxuICAgICdvcGVubmFtZXNwYWNlJyxcbiAgICAnY2xvc2VuYW1lc3BhY2UnXG4gIF1cblxuICBmdW5jdGlvbiBTQVhQYXJzZXIgKHN0cmljdCwgb3B0KSB7XG4gICAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIFNBWFBhcnNlcikpIHtcbiAgICAgIHJldHVybiBuZXcgU0FYUGFyc2VyKHN0cmljdCwgb3B0KVxuICAgIH1cblxuICAgIHZhciBwYXJzZXIgPSB0aGlzXG4gICAgY2xlYXJCdWZmZXJzKHBhcnNlcilcbiAgICBwYXJzZXIucSA9IHBhcnNlci5jID0gJydcbiAgICBwYXJzZXIuYnVmZmVyQ2hlY2tQb3NpdGlvbiA9IHNheC5NQVhfQlVGRkVSX0xFTkdUSFxuICAgIHBhcnNlci5vcHQgPSBvcHQgfHwge31cbiAgICBwYXJzZXIub3B0Lmxvd2VyY2FzZSA9IHBhcnNlci5vcHQubG93ZXJjYXNlIHx8IHBhcnNlci5vcHQubG93ZXJjYXNldGFnc1xuICAgIHBhcnNlci5sb29zZUNhc2UgPSBwYXJzZXIub3B0Lmxvd2VyY2FzZSA/ICd0b0xvd2VyQ2FzZScgOiAndG9VcHBlckNhc2UnXG4gICAgcGFyc2VyLnRhZ3MgPSBbXVxuICAgIHBhcnNlci5jbG9zZWQgPSBwYXJzZXIuY2xvc2VkUm9vdCA9IHBhcnNlci5zYXdSb290ID0gZmFsc2VcbiAgICBwYXJzZXIudGFnID0gcGFyc2VyLmVycm9yID0gbnVsbFxuICAgIHBhcnNlci5zdHJpY3QgPSAhIXN0cmljdFxuICAgIHBhcnNlci5ub3NjcmlwdCA9ICEhKHN0cmljdCB8fCBwYXJzZXIub3B0Lm5vc2NyaXB0KVxuICAgIHBhcnNlci5zdGF0ZSA9IFMuQkVHSU5cbiAgICBwYXJzZXIuc3RyaWN0RW50aXRpZXMgPSBwYXJzZXIub3B0LnN0cmljdEVudGl0aWVzXG4gICAgcGFyc2VyLkVOVElUSUVTID0gcGFyc2VyLnN0cmljdEVudGl0aWVzID8gT2JqZWN0LmNyZWF0ZShzYXguWE1MX0VOVElUSUVTKSA6IE9iamVjdC5jcmVhdGUoc2F4LkVOVElUSUVTKVxuICAgIHBhcnNlci5hdHRyaWJMaXN0ID0gW11cblxuICAgIC8vIG5hbWVzcGFjZXMgZm9ybSBhIHByb3RvdHlwZSBjaGFpbi5cbiAgICAvLyBpdCBhbHdheXMgcG9pbnRzIGF0IHRoZSBjdXJyZW50IHRhZyxcbiAgICAvLyB3aGljaCBwcm90b3MgdG8gaXRzIHBhcmVudCB0YWcuXG4gICAgaWYgKHBhcnNlci5vcHQueG1sbnMpIHtcbiAgICAgIHBhcnNlci5ucyA9IE9iamVjdC5jcmVhdGUocm9vdE5TKVxuICAgIH1cblxuICAgIC8vIG1vc3RseSBqdXN0IGZvciBlcnJvciByZXBvcnRpbmdcbiAgICBwYXJzZXIudHJhY2tQb3NpdGlvbiA9IHBhcnNlci5vcHQucG9zaXRpb24gIT09IGZhbHNlXG4gICAgaWYgKHBhcnNlci50cmFja1Bvc2l0aW9uKSB7XG4gICAgICBwYXJzZXIucG9zaXRpb24gPSBwYXJzZXIubGluZSA9IHBhcnNlci5jb2x1bW4gPSAwXG4gICAgfVxuICAgIGVtaXQocGFyc2VyLCAnb25yZWFkeScpXG4gIH1cblxuICBpZiAoIU9iamVjdC5jcmVhdGUpIHtcbiAgICBPYmplY3QuY3JlYXRlID0gZnVuY3Rpb24gKG8pIHtcbiAgICAgIGZ1bmN0aW9uIEYgKCkge31cbiAgICAgIEYucHJvdG90eXBlID0gb1xuICAgICAgdmFyIG5ld2YgPSBuZXcgRigpXG4gICAgICByZXR1cm4gbmV3ZlxuICAgIH1cbiAgfVxuXG4gIGlmICghT2JqZWN0LmtleXMpIHtcbiAgICBPYmplY3Qua2V5cyA9IGZ1bmN0aW9uIChvKSB7XG4gICAgICB2YXIgYSA9IFtdXG4gICAgICBmb3IgKHZhciBpIGluIG8pIGlmIChvLmhhc093blByb3BlcnR5KGkpKSBhLnB1c2goaSlcbiAgICAgIHJldHVybiBhXG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gY2hlY2tCdWZmZXJMZW5ndGggKHBhcnNlcikge1xuICAgIHZhciBtYXhBbGxvd2VkID0gTWF0aC5tYXgoc2F4Lk1BWF9CVUZGRVJfTEVOR1RILCAxMClcbiAgICB2YXIgbWF4QWN0dWFsID0gMFxuICAgIGZvciAodmFyIGkgPSAwLCBsID0gYnVmZmVycy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIHZhciBsZW4gPSBwYXJzZXJbYnVmZmVyc1tpXV0ubGVuZ3RoXG4gICAgICBpZiAobGVuID4gbWF4QWxsb3dlZCkge1xuICAgICAgICAvLyBUZXh0L2NkYXRhIG5vZGVzIGNhbiBnZXQgYmlnLCBhbmQgc2luY2UgdGhleSdyZSBidWZmZXJlZCxcbiAgICAgICAgLy8gd2UgY2FuIGdldCBoZXJlIHVuZGVyIG5vcm1hbCBjb25kaXRpb25zLlxuICAgICAgICAvLyBBdm9pZCBpc3N1ZXMgYnkgZW1pdHRpbmcgdGhlIHRleHQgbm9kZSBub3csXG4gICAgICAgIC8vIHNvIGF0IGxlYXN0IGl0IHdvbid0IGdldCBhbnkgYmlnZ2VyLlxuICAgICAgICBzd2l0Y2ggKGJ1ZmZlcnNbaV0pIHtcbiAgICAgICAgICBjYXNlICd0ZXh0Tm9kZSc6XG4gICAgICAgICAgICBjbG9zZVRleHQocGFyc2VyKVxuICAgICAgICAgICAgYnJlYWtcblxuICAgICAgICAgIGNhc2UgJ2NkYXRhJzpcbiAgICAgICAgICAgIGVtaXROb2RlKHBhcnNlciwgJ29uY2RhdGEnLCBwYXJzZXIuY2RhdGEpXG4gICAgICAgICAgICBwYXJzZXIuY2RhdGEgPSAnJ1xuICAgICAgICAgICAgYnJlYWtcblxuICAgICAgICAgIGNhc2UgJ3NjcmlwdCc6XG4gICAgICAgICAgICBlbWl0Tm9kZShwYXJzZXIsICdvbnNjcmlwdCcsIHBhcnNlci5zY3JpcHQpXG4gICAgICAgICAgICBwYXJzZXIuc2NyaXB0ID0gJydcbiAgICAgICAgICAgIGJyZWFrXG5cbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgZXJyb3IocGFyc2VyLCAnTWF4IGJ1ZmZlciBsZW5ndGggZXhjZWVkZWQ6ICcgKyBidWZmZXJzW2ldKVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBtYXhBY3R1YWwgPSBNYXRoLm1heChtYXhBY3R1YWwsIGxlbilcbiAgICB9XG4gICAgLy8gc2NoZWR1bGUgdGhlIG5leHQgY2hlY2sgZm9yIHRoZSBlYXJsaWVzdCBwb3NzaWJsZSBidWZmZXIgb3ZlcnJ1bi5cbiAgICB2YXIgbSA9IHNheC5NQVhfQlVGRkVSX0xFTkdUSCAtIG1heEFjdHVhbFxuICAgIHBhcnNlci5idWZmZXJDaGVja1Bvc2l0aW9uID0gbSArIHBhcnNlci5wb3NpdGlvblxuICB9XG5cbiAgZnVuY3Rpb24gY2xlYXJCdWZmZXJzIChwYXJzZXIpIHtcbiAgICBmb3IgKHZhciBpID0gMCwgbCA9IGJ1ZmZlcnMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICBwYXJzZXJbYnVmZmVyc1tpXV0gPSAnJ1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGZsdXNoQnVmZmVycyAocGFyc2VyKSB7XG4gICAgY2xvc2VUZXh0KHBhcnNlcilcbiAgICBpZiAocGFyc2VyLmNkYXRhICE9PSAnJykge1xuICAgICAgZW1pdE5vZGUocGFyc2VyLCAnb25jZGF0YScsIHBhcnNlci5jZGF0YSlcbiAgICAgIHBhcnNlci5jZGF0YSA9ICcnXG4gICAgfVxuICAgIGlmIChwYXJzZXIuc2NyaXB0ICE9PSAnJykge1xuICAgICAgZW1pdE5vZGUocGFyc2VyLCAnb25zY3JpcHQnLCBwYXJzZXIuc2NyaXB0KVxuICAgICAgcGFyc2VyLnNjcmlwdCA9ICcnXG4gICAgfVxuICB9XG5cbiAgU0FYUGFyc2VyLnByb3RvdHlwZSA9IHtcbiAgICBlbmQ6IGZ1bmN0aW9uICgpIHsgZW5kKHRoaXMpIH0sXG4gICAgd3JpdGU6IHdyaXRlLFxuICAgIHJlc3VtZTogZnVuY3Rpb24gKCkgeyB0aGlzLmVycm9yID0gbnVsbDsgcmV0dXJuIHRoaXMgfSxcbiAgICBjbG9zZTogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy53cml0ZShudWxsKSB9LFxuICAgIGZsdXNoOiBmdW5jdGlvbiAoKSB7IGZsdXNoQnVmZmVycyh0aGlzKSB9XG4gIH1cblxuICB2YXIgU3RyZWFtXG4gIHRyeSB7XG4gICAgU3RyZWFtID0gcmVxdWlyZSgnc3RyZWFtJykuU3RyZWFtXG4gIH0gY2F0Y2ggKGV4KSB7XG4gICAgU3RyZWFtID0gZnVuY3Rpb24gKCkge31cbiAgfVxuXG4gIHZhciBzdHJlYW1XcmFwcyA9IHNheC5FVkVOVFMuZmlsdGVyKGZ1bmN0aW9uIChldikge1xuICAgIHJldHVybiBldiAhPT0gJ2Vycm9yJyAmJiBldiAhPT0gJ2VuZCdcbiAgfSlcblxuICBmdW5jdGlvbiBjcmVhdGVTdHJlYW0gKHN0cmljdCwgb3B0KSB7XG4gICAgcmV0dXJuIG5ldyBTQVhTdHJlYW0oc3RyaWN0LCBvcHQpXG4gIH1cblxuICBmdW5jdGlvbiBTQVhTdHJlYW0gKHN0cmljdCwgb3B0KSB7XG4gICAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIFNBWFN0cmVhbSkpIHtcbiAgICAgIHJldHVybiBuZXcgU0FYU3RyZWFtKHN0cmljdCwgb3B0KVxuICAgIH1cblxuICAgIFN0cmVhbS5hcHBseSh0aGlzKVxuXG4gICAgdGhpcy5fcGFyc2VyID0gbmV3IFNBWFBhcnNlcihzdHJpY3QsIG9wdClcbiAgICB0aGlzLndyaXRhYmxlID0gdHJ1ZVxuICAgIHRoaXMucmVhZGFibGUgPSB0cnVlXG5cbiAgICB2YXIgbWUgPSB0aGlzXG5cbiAgICB0aGlzLl9wYXJzZXIub25lbmQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBtZS5lbWl0KCdlbmQnKVxuICAgIH1cblxuICAgIHRoaXMuX3BhcnNlci5vbmVycm9yID0gZnVuY3Rpb24gKGVyKSB7XG4gICAgICBtZS5lbWl0KCdlcnJvcicsIGVyKVxuXG4gICAgICAvLyBpZiBkaWRuJ3QgdGhyb3csIHRoZW4gbWVhbnMgZXJyb3Igd2FzIGhhbmRsZWQuXG4gICAgICAvLyBnbyBhaGVhZCBhbmQgY2xlYXIgZXJyb3IsIHNvIHdlIGNhbiB3cml0ZSBhZ2Fpbi5cbiAgICAgIG1lLl9wYXJzZXIuZXJyb3IgPSBudWxsXG4gICAgfVxuXG4gICAgdGhpcy5fZGVjb2RlciA9IG51bGxcblxuICAgIHN0cmVhbVdyYXBzLmZvckVhY2goZnVuY3Rpb24gKGV2KSB7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobWUsICdvbicgKyBldiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICByZXR1cm4gbWUuX3BhcnNlclsnb24nICsgZXZdXG4gICAgICAgIH0sXG4gICAgICAgIHNldDogZnVuY3Rpb24gKGgpIHtcbiAgICAgICAgICBpZiAoIWgpIHtcbiAgICAgICAgICAgIG1lLnJlbW92ZUFsbExpc3RlbmVycyhldilcbiAgICAgICAgICAgIG1lLl9wYXJzZXJbJ29uJyArIGV2XSA9IGhcbiAgICAgICAgICAgIHJldHVybiBoXG4gICAgICAgICAgfVxuICAgICAgICAgIG1lLm9uKGV2LCBoKVxuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IGZhbHNlXG4gICAgICB9KVxuICAgIH0pXG4gIH1cblxuICBTQVhTdHJlYW0ucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShTdHJlYW0ucHJvdG90eXBlLCB7XG4gICAgY29uc3RydWN0b3I6IHtcbiAgICAgIHZhbHVlOiBTQVhTdHJlYW1cbiAgICB9XG4gIH0pXG5cbiAgU0FYU3RyZWFtLnByb3RvdHlwZS53cml0ZSA9IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgaWYgKHR5cGVvZiBCdWZmZXIgPT09ICdmdW5jdGlvbicgJiZcbiAgICAgIHR5cGVvZiBCdWZmZXIuaXNCdWZmZXIgPT09ICdmdW5jdGlvbicgJiZcbiAgICAgIEJ1ZmZlci5pc0J1ZmZlcihkYXRhKSkge1xuICAgICAgaWYgKCF0aGlzLl9kZWNvZGVyKSB7XG4gICAgICAgIHZhciBTRCA9IHJlcXVpcmUoJ3N0cmluZ19kZWNvZGVyJykuU3RyaW5nRGVjb2RlclxuICAgICAgICB0aGlzLl9kZWNvZGVyID0gbmV3IFNEKCd1dGY4JylcbiAgICAgIH1cbiAgICAgIGRhdGEgPSB0aGlzLl9kZWNvZGVyLndyaXRlKGRhdGEpXG4gICAgfVxuXG4gICAgdGhpcy5fcGFyc2VyLndyaXRlKGRhdGEudG9TdHJpbmcoKSlcbiAgICB0aGlzLmVtaXQoJ2RhdGEnLCBkYXRhKVxuICAgIHJldHVybiB0cnVlXG4gIH1cblxuICBTQVhTdHJlYW0ucHJvdG90eXBlLmVuZCA9IGZ1bmN0aW9uIChjaHVuaykge1xuICAgIGlmIChjaHVuayAmJiBjaHVuay5sZW5ndGgpIHtcbiAgICAgIHRoaXMud3JpdGUoY2h1bmspXG4gICAgfVxuICAgIHRoaXMuX3BhcnNlci5lbmQoKVxuICAgIHJldHVybiB0cnVlXG4gIH1cblxuICBTQVhTdHJlYW0ucHJvdG90eXBlLm9uID0gZnVuY3Rpb24gKGV2LCBoYW5kbGVyKSB7XG4gICAgdmFyIG1lID0gdGhpc1xuICAgIGlmICghbWUuX3BhcnNlclsnb24nICsgZXZdICYmIHN0cmVhbVdyYXBzLmluZGV4T2YoZXYpICE9PSAtMSkge1xuICAgICAgbWUuX3BhcnNlclsnb24nICsgZXZdID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgYXJncyA9IGFyZ3VtZW50cy5sZW5ndGggPT09IDEgPyBbYXJndW1lbnRzWzBdXSA6IEFycmF5LmFwcGx5KG51bGwsIGFyZ3VtZW50cylcbiAgICAgICAgYXJncy5zcGxpY2UoMCwgMCwgZXYpXG4gICAgICAgIG1lLmVtaXQuYXBwbHkobWUsIGFyZ3MpXG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIFN0cmVhbS5wcm90b3R5cGUub24uY2FsbChtZSwgZXYsIGhhbmRsZXIpXG4gIH1cblxuICAvLyB0aGlzIHJlYWxseSBuZWVkcyB0byBiZSByZXBsYWNlZCB3aXRoIGNoYXJhY3RlciBjbGFzc2VzLlxuICAvLyBYTUwgYWxsb3dzIGFsbCBtYW5uZXIgb2YgcmlkaWN1bG91cyBudW1iZXJzIGFuZCBkaWdpdHMuXG4gIHZhciBDREFUQSA9ICdbQ0RBVEFbJ1xuICB2YXIgRE9DVFlQRSA9ICdET0NUWVBFJ1xuICB2YXIgWE1MX05BTUVTUEFDRSA9ICdodHRwOi8vd3d3LnczLm9yZy9YTUwvMTk5OC9uYW1lc3BhY2UnXG4gIHZhciBYTUxOU19OQU1FU1BBQ0UgPSAnaHR0cDovL3d3dy53My5vcmcvMjAwMC94bWxucy8nXG4gIHZhciByb290TlMgPSB7IHhtbDogWE1MX05BTUVTUEFDRSwgeG1sbnM6IFhNTE5TX05BTUVTUEFDRSB9XG5cbiAgLy8gaHR0cDovL3d3dy53My5vcmcvVFIvUkVDLXhtbC8jTlQtTmFtZVN0YXJ0Q2hhclxuICAvLyBUaGlzIGltcGxlbWVudGF0aW9uIHdvcmtzIG9uIHN0cmluZ3MsIGEgc2luZ2xlIGNoYXJhY3RlciBhdCBhIHRpbWVcbiAgLy8gYXMgc3VjaCwgaXQgY2Fubm90IGV2ZXIgc3VwcG9ydCBhc3RyYWwtcGxhbmUgY2hhcmFjdGVycyAoMTAwMDAtRUZGRkYpXG4gIC8vIHdpdGhvdXQgYSBzaWduaWZpY2FudCBicmVha2luZyBjaGFuZ2UgdG8gZWl0aGVyIHRoaXMgIHBhcnNlciwgb3IgdGhlXG4gIC8vIEphdmFTY3JpcHQgbGFuZ3VhZ2UuICBJbXBsZW1lbnRhdGlvbiBvZiBhbiBlbW9qaS1jYXBhYmxlIHhtbCBwYXJzZXJcbiAgLy8gaXMgbGVmdCBhcyBhbiBleGVyY2lzZSBmb3IgdGhlIHJlYWRlci5cbiAgdmFyIG5hbWVTdGFydCA9IC9bOl9BLVphLXpcXHUwMEMwLVxcdTAwRDZcXHUwMEQ4LVxcdTAwRjZcXHUwMEY4LVxcdTAyRkZcXHUwMzcwLVxcdTAzN0RcXHUwMzdGLVxcdTFGRkZcXHUyMDBDLVxcdTIwMERcXHUyMDcwLVxcdTIxOEZcXHUyQzAwLVxcdTJGRUZcXHUzMDAxLVxcdUQ3RkZcXHVGOTAwLVxcdUZEQ0ZcXHVGREYwLVxcdUZGRkRdL1xuXG4gIHZhciBuYW1lQm9keSA9IC9bOl9BLVphLXpcXHUwMEMwLVxcdTAwRDZcXHUwMEQ4LVxcdTAwRjZcXHUwMEY4LVxcdTAyRkZcXHUwMzcwLVxcdTAzN0RcXHUwMzdGLVxcdTFGRkZcXHUyMDBDLVxcdTIwMERcXHUyMDcwLVxcdTIxOEZcXHUyQzAwLVxcdTJGRUZcXHUzMDAxLVxcdUQ3RkZcXHVGOTAwLVxcdUZEQ0ZcXHVGREYwLVxcdUZGRkRcXHUwMEI3XFx1MDMwMC1cXHUwMzZGXFx1MjAzRi1cXHUyMDQwLlxcZC1dL1xuXG4gIHZhciBlbnRpdHlTdGFydCA9IC9bIzpfQS1aYS16XFx1MDBDMC1cXHUwMEQ2XFx1MDBEOC1cXHUwMEY2XFx1MDBGOC1cXHUwMkZGXFx1MDM3MC1cXHUwMzdEXFx1MDM3Ri1cXHUxRkZGXFx1MjAwQy1cXHUyMDBEXFx1MjA3MC1cXHUyMThGXFx1MkMwMC1cXHUyRkVGXFx1MzAwMS1cXHVEN0ZGXFx1RjkwMC1cXHVGRENGXFx1RkRGMC1cXHVGRkZEXS9cbiAgdmFyIGVudGl0eUJvZHkgPSAvWyM6X0EtWmEtelxcdTAwQzAtXFx1MDBENlxcdTAwRDgtXFx1MDBGNlxcdTAwRjgtXFx1MDJGRlxcdTAzNzAtXFx1MDM3RFxcdTAzN0YtXFx1MUZGRlxcdTIwMEMtXFx1MjAwRFxcdTIwNzAtXFx1MjE4RlxcdTJDMDAtXFx1MkZFRlxcdTMwMDEtXFx1RDdGRlxcdUY5MDAtXFx1RkRDRlxcdUZERjAtXFx1RkZGRFxcdTAwQjdcXHUwMzAwLVxcdTAzNkZcXHUyMDNGLVxcdTIwNDAuXFxkLV0vXG5cbiAgZnVuY3Rpb24gaXNXaGl0ZXNwYWNlIChjKSB7XG4gICAgcmV0dXJuIGMgPT09ICcgJyB8fCBjID09PSAnXFxuJyB8fCBjID09PSAnXFxyJyB8fCBjID09PSAnXFx0J1xuICB9XG5cbiAgZnVuY3Rpb24gaXNRdW90ZSAoYykge1xuICAgIHJldHVybiBjID09PSAnXCInIHx8IGMgPT09ICdcXCcnXG4gIH1cblxuICBmdW5jdGlvbiBpc0F0dHJpYkVuZCAoYykge1xuICAgIHJldHVybiBjID09PSAnPicgfHwgaXNXaGl0ZXNwYWNlKGMpXG4gIH1cblxuICBmdW5jdGlvbiBpc01hdGNoIChyZWdleCwgYykge1xuICAgIHJldHVybiByZWdleC50ZXN0KGMpXG4gIH1cblxuICBmdW5jdGlvbiBub3RNYXRjaCAocmVnZXgsIGMpIHtcbiAgICByZXR1cm4gIWlzTWF0Y2gocmVnZXgsIGMpXG4gIH1cblxuICB2YXIgUyA9IDBcbiAgc2F4LlNUQVRFID0ge1xuICAgIEJFR0lOOiBTKyssIC8vIGxlYWRpbmcgYnl0ZSBvcmRlciBtYXJrIG9yIHdoaXRlc3BhY2VcbiAgICBCRUdJTl9XSElURVNQQUNFOiBTKyssIC8vIGxlYWRpbmcgd2hpdGVzcGFjZVxuICAgIFRFWFQ6IFMrKywgLy8gZ2VuZXJhbCBzdHVmZlxuICAgIFRFWFRfRU5USVRZOiBTKyssIC8vICZhbXAgYW5kIHN1Y2guXG4gICAgT1BFTl9XQUtBOiBTKyssIC8vIDxcbiAgICBTR01MX0RFQ0w6IFMrKywgLy8gPCFCTEFSR1xuICAgIFNHTUxfREVDTF9RVU9URUQ6IFMrKywgLy8gPCFCTEFSRyBmb28gXCJiYXJcbiAgICBET0NUWVBFOiBTKyssIC8vIDwhRE9DVFlQRVxuICAgIERPQ1RZUEVfUVVPVEVEOiBTKyssIC8vIDwhRE9DVFlQRSBcIi8vYmxhaFxuICAgIERPQ1RZUEVfRFREOiBTKyssIC8vIDwhRE9DVFlQRSBcIi8vYmxhaFwiIFsgLi4uXG4gICAgRE9DVFlQRV9EVERfUVVPVEVEOiBTKyssIC8vIDwhRE9DVFlQRSBcIi8vYmxhaFwiIFsgXCJmb29cbiAgICBDT01NRU5UX1NUQVJUSU5HOiBTKyssIC8vIDwhLVxuICAgIENPTU1FTlQ6IFMrKywgLy8gPCEtLVxuICAgIENPTU1FTlRfRU5ESU5HOiBTKyssIC8vIDwhLS0gYmxhaCAtXG4gICAgQ09NTUVOVF9FTkRFRDogUysrLCAvLyA8IS0tIGJsYWggLS1cbiAgICBDREFUQTogUysrLCAvLyA8IVtDREFUQVsgc29tZXRoaW5nXG4gICAgQ0RBVEFfRU5ESU5HOiBTKyssIC8vIF1cbiAgICBDREFUQV9FTkRJTkdfMjogUysrLCAvLyBdXVxuICAgIFBST0NfSU5TVDogUysrLCAvLyA8P2hpXG4gICAgUFJPQ19JTlNUX0JPRFk6IFMrKywgLy8gPD9oaSB0aGVyZVxuICAgIFBST0NfSU5TVF9FTkRJTkc6IFMrKywgLy8gPD9oaSBcInRoZXJlXCIgP1xuICAgIE9QRU5fVEFHOiBTKyssIC8vIDxzdHJvbmdcbiAgICBPUEVOX1RBR19TTEFTSDogUysrLCAvLyA8c3Ryb25nIC9cbiAgICBBVFRSSUI6IFMrKywgLy8gPGFcbiAgICBBVFRSSUJfTkFNRTogUysrLCAvLyA8YSBmb29cbiAgICBBVFRSSUJfTkFNRV9TQVdfV0hJVEU6IFMrKywgLy8gPGEgZm9vIF9cbiAgICBBVFRSSUJfVkFMVUU6IFMrKywgLy8gPGEgZm9vPVxuICAgIEFUVFJJQl9WQUxVRV9RVU9URUQ6IFMrKywgLy8gPGEgZm9vPVwiYmFyXG4gICAgQVRUUklCX1ZBTFVFX0NMT1NFRDogUysrLCAvLyA8YSBmb289XCJiYXJcIlxuICAgIEFUVFJJQl9WQUxVRV9VTlFVT1RFRDogUysrLCAvLyA8YSBmb289YmFyXG4gICAgQVRUUklCX1ZBTFVFX0VOVElUWV9ROiBTKyssIC8vIDxmb28gYmFyPVwiJnF1b3Q7XCJcbiAgICBBVFRSSUJfVkFMVUVfRU5USVRZX1U6IFMrKywgLy8gPGZvbyBiYXI9JnF1b3RcbiAgICBDTE9TRV9UQUc6IFMrKywgLy8gPC9hXG4gICAgQ0xPU0VfVEFHX1NBV19XSElURTogUysrLCAvLyA8L2EgICA+XG4gICAgU0NSSVBUOiBTKyssIC8vIDxzY3JpcHQ+IC4uLlxuICAgIFNDUklQVF9FTkRJTkc6IFMrKyAvLyA8c2NyaXB0PiAuLi4gPFxuICB9XG5cbiAgc2F4LlhNTF9FTlRJVElFUyA9IHtcbiAgICAnYW1wJzogJyYnLFxuICAgICdndCc6ICc+JyxcbiAgICAnbHQnOiAnPCcsXG4gICAgJ3F1b3QnOiAnXCInLFxuICAgICdhcG9zJzogXCInXCJcbiAgfVxuXG4gIHNheC5FTlRJVElFUyA9IHtcbiAgICAnYW1wJzogJyYnLFxuICAgICdndCc6ICc+JyxcbiAgICAnbHQnOiAnPCcsXG4gICAgJ3F1b3QnOiAnXCInLFxuICAgICdhcG9zJzogXCInXCIsXG4gICAgJ0FFbGlnJzogMTk4LFxuICAgICdBYWN1dGUnOiAxOTMsXG4gICAgJ0FjaXJjJzogMTk0LFxuICAgICdBZ3JhdmUnOiAxOTIsXG4gICAgJ0FyaW5nJzogMTk3LFxuICAgICdBdGlsZGUnOiAxOTUsXG4gICAgJ0F1bWwnOiAxOTYsXG4gICAgJ0NjZWRpbCc6IDE5OSxcbiAgICAnRVRIJzogMjA4LFxuICAgICdFYWN1dGUnOiAyMDEsXG4gICAgJ0VjaXJjJzogMjAyLFxuICAgICdFZ3JhdmUnOiAyMDAsXG4gICAgJ0V1bWwnOiAyMDMsXG4gICAgJ0lhY3V0ZSc6IDIwNSxcbiAgICAnSWNpcmMnOiAyMDYsXG4gICAgJ0lncmF2ZSc6IDIwNCxcbiAgICAnSXVtbCc6IDIwNyxcbiAgICAnTnRpbGRlJzogMjA5LFxuICAgICdPYWN1dGUnOiAyMTEsXG4gICAgJ09jaXJjJzogMjEyLFxuICAgICdPZ3JhdmUnOiAyMTAsXG4gICAgJ09zbGFzaCc6IDIxNixcbiAgICAnT3RpbGRlJzogMjEzLFxuICAgICdPdW1sJzogMjE0LFxuICAgICdUSE9STic6IDIyMixcbiAgICAnVWFjdXRlJzogMjE4LFxuICAgICdVY2lyYyc6IDIxOSxcbiAgICAnVWdyYXZlJzogMjE3LFxuICAgICdVdW1sJzogMjIwLFxuICAgICdZYWN1dGUnOiAyMjEsXG4gICAgJ2FhY3V0ZSc6IDIyNSxcbiAgICAnYWNpcmMnOiAyMjYsXG4gICAgJ2FlbGlnJzogMjMwLFxuICAgICdhZ3JhdmUnOiAyMjQsXG4gICAgJ2FyaW5nJzogMjI5LFxuICAgICdhdGlsZGUnOiAyMjcsXG4gICAgJ2F1bWwnOiAyMjgsXG4gICAgJ2NjZWRpbCc6IDIzMSxcbiAgICAnZWFjdXRlJzogMjMzLFxuICAgICdlY2lyYyc6IDIzNCxcbiAgICAnZWdyYXZlJzogMjMyLFxuICAgICdldGgnOiAyNDAsXG4gICAgJ2V1bWwnOiAyMzUsXG4gICAgJ2lhY3V0ZSc6IDIzNyxcbiAgICAnaWNpcmMnOiAyMzgsXG4gICAgJ2lncmF2ZSc6IDIzNixcbiAgICAnaXVtbCc6IDIzOSxcbiAgICAnbnRpbGRlJzogMjQxLFxuICAgICdvYWN1dGUnOiAyNDMsXG4gICAgJ29jaXJjJzogMjQ0LFxuICAgICdvZ3JhdmUnOiAyNDIsXG4gICAgJ29zbGFzaCc6IDI0OCxcbiAgICAnb3RpbGRlJzogMjQ1LFxuICAgICdvdW1sJzogMjQ2LFxuICAgICdzemxpZyc6IDIyMyxcbiAgICAndGhvcm4nOiAyNTQsXG4gICAgJ3VhY3V0ZSc6IDI1MCxcbiAgICAndWNpcmMnOiAyNTEsXG4gICAgJ3VncmF2ZSc6IDI0OSxcbiAgICAndXVtbCc6IDI1MixcbiAgICAneWFjdXRlJzogMjUzLFxuICAgICd5dW1sJzogMjU1LFxuICAgICdjb3B5JzogMTY5LFxuICAgICdyZWcnOiAxNzQsXG4gICAgJ25ic3AnOiAxNjAsXG4gICAgJ2lleGNsJzogMTYxLFxuICAgICdjZW50JzogMTYyLFxuICAgICdwb3VuZCc6IDE2MyxcbiAgICAnY3VycmVuJzogMTY0LFxuICAgICd5ZW4nOiAxNjUsXG4gICAgJ2JydmJhcic6IDE2NixcbiAgICAnc2VjdCc6IDE2NyxcbiAgICAndW1sJzogMTY4LFxuICAgICdvcmRmJzogMTcwLFxuICAgICdsYXF1byc6IDE3MSxcbiAgICAnbm90JzogMTcyLFxuICAgICdzaHknOiAxNzMsXG4gICAgJ21hY3InOiAxNzUsXG4gICAgJ2RlZyc6IDE3NixcbiAgICAncGx1c21uJzogMTc3LFxuICAgICdzdXAxJzogMTg1LFxuICAgICdzdXAyJzogMTc4LFxuICAgICdzdXAzJzogMTc5LFxuICAgICdhY3V0ZSc6IDE4MCxcbiAgICAnbWljcm8nOiAxODEsXG4gICAgJ3BhcmEnOiAxODIsXG4gICAgJ21pZGRvdCc6IDE4MyxcbiAgICAnY2VkaWwnOiAxODQsXG4gICAgJ29yZG0nOiAxODYsXG4gICAgJ3JhcXVvJzogMTg3LFxuICAgICdmcmFjMTQnOiAxODgsXG4gICAgJ2ZyYWMxMic6IDE4OSxcbiAgICAnZnJhYzM0JzogMTkwLFxuICAgICdpcXVlc3QnOiAxOTEsXG4gICAgJ3RpbWVzJzogMjE1LFxuICAgICdkaXZpZGUnOiAyNDcsXG4gICAgJ09FbGlnJzogMzM4LFxuICAgICdvZWxpZyc6IDMzOSxcbiAgICAnU2Nhcm9uJzogMzUyLFxuICAgICdzY2Fyb24nOiAzNTMsXG4gICAgJ1l1bWwnOiAzNzYsXG4gICAgJ2Zub2YnOiA0MDIsXG4gICAgJ2NpcmMnOiA3MTAsXG4gICAgJ3RpbGRlJzogNzMyLFxuICAgICdBbHBoYSc6IDkxMyxcbiAgICAnQmV0YSc6IDkxNCxcbiAgICAnR2FtbWEnOiA5MTUsXG4gICAgJ0RlbHRhJzogOTE2LFxuICAgICdFcHNpbG9uJzogOTE3LFxuICAgICdaZXRhJzogOTE4LFxuICAgICdFdGEnOiA5MTksXG4gICAgJ1RoZXRhJzogOTIwLFxuICAgICdJb3RhJzogOTIxLFxuICAgICdLYXBwYSc6IDkyMixcbiAgICAnTGFtYmRhJzogOTIzLFxuICAgICdNdSc6IDkyNCxcbiAgICAnTnUnOiA5MjUsXG4gICAgJ1hpJzogOTI2LFxuICAgICdPbWljcm9uJzogOTI3LFxuICAgICdQaSc6IDkyOCxcbiAgICAnUmhvJzogOTI5LFxuICAgICdTaWdtYSc6IDkzMSxcbiAgICAnVGF1JzogOTMyLFxuICAgICdVcHNpbG9uJzogOTMzLFxuICAgICdQaGknOiA5MzQsXG4gICAgJ0NoaSc6IDkzNSxcbiAgICAnUHNpJzogOTM2LFxuICAgICdPbWVnYSc6IDkzNyxcbiAgICAnYWxwaGEnOiA5NDUsXG4gICAgJ2JldGEnOiA5NDYsXG4gICAgJ2dhbW1hJzogOTQ3LFxuICAgICdkZWx0YSc6IDk0OCxcbiAgICAnZXBzaWxvbic6IDk0OSxcbiAgICAnemV0YSc6IDk1MCxcbiAgICAnZXRhJzogOTUxLFxuICAgICd0aGV0YSc6IDk1MixcbiAgICAnaW90YSc6IDk1MyxcbiAgICAna2FwcGEnOiA5NTQsXG4gICAgJ2xhbWJkYSc6IDk1NSxcbiAgICAnbXUnOiA5NTYsXG4gICAgJ251JzogOTU3LFxuICAgICd4aSc6IDk1OCxcbiAgICAnb21pY3Jvbic6IDk1OSxcbiAgICAncGknOiA5NjAsXG4gICAgJ3Jobyc6IDk2MSxcbiAgICAnc2lnbWFmJzogOTYyLFxuICAgICdzaWdtYSc6IDk2MyxcbiAgICAndGF1JzogOTY0LFxuICAgICd1cHNpbG9uJzogOTY1LFxuICAgICdwaGknOiA5NjYsXG4gICAgJ2NoaSc6IDk2NyxcbiAgICAncHNpJzogOTY4LFxuICAgICdvbWVnYSc6IDk2OSxcbiAgICAndGhldGFzeW0nOiA5NzcsXG4gICAgJ3Vwc2loJzogOTc4LFxuICAgICdwaXYnOiA5ODIsXG4gICAgJ2Vuc3AnOiA4MTk0LFxuICAgICdlbXNwJzogODE5NSxcbiAgICAndGhpbnNwJzogODIwMSxcbiAgICAnenduaic6IDgyMDQsXG4gICAgJ3p3aic6IDgyMDUsXG4gICAgJ2xybSc6IDgyMDYsXG4gICAgJ3JsbSc6IDgyMDcsXG4gICAgJ25kYXNoJzogODIxMSxcbiAgICAnbWRhc2gnOiA4MjEyLFxuICAgICdsc3F1byc6IDgyMTYsXG4gICAgJ3JzcXVvJzogODIxNyxcbiAgICAnc2JxdW8nOiA4MjE4LFxuICAgICdsZHF1byc6IDgyMjAsXG4gICAgJ3JkcXVvJzogODIyMSxcbiAgICAnYmRxdW8nOiA4MjIyLFxuICAgICdkYWdnZXInOiA4MjI0LFxuICAgICdEYWdnZXInOiA4MjI1LFxuICAgICdidWxsJzogODIyNixcbiAgICAnaGVsbGlwJzogODIzMCxcbiAgICAncGVybWlsJzogODI0MCxcbiAgICAncHJpbWUnOiA4MjQyLFxuICAgICdQcmltZSc6IDgyNDMsXG4gICAgJ2xzYXF1byc6IDgyNDksXG4gICAgJ3JzYXF1byc6IDgyNTAsXG4gICAgJ29saW5lJzogODI1NCxcbiAgICAnZnJhc2wnOiA4MjYwLFxuICAgICdldXJvJzogODM2NCxcbiAgICAnaW1hZ2UnOiA4NDY1LFxuICAgICd3ZWllcnAnOiA4NDcyLFxuICAgICdyZWFsJzogODQ3NixcbiAgICAndHJhZGUnOiA4NDgyLFxuICAgICdhbGVmc3ltJzogODUwMSxcbiAgICAnbGFycic6IDg1OTIsXG4gICAgJ3VhcnInOiA4NTkzLFxuICAgICdyYXJyJzogODU5NCxcbiAgICAnZGFycic6IDg1OTUsXG4gICAgJ2hhcnInOiA4NTk2LFxuICAgICdjcmFycic6IDg2MjksXG4gICAgJ2xBcnInOiA4NjU2LFxuICAgICd1QXJyJzogODY1NyxcbiAgICAnckFycic6IDg2NTgsXG4gICAgJ2RBcnInOiA4NjU5LFxuICAgICdoQXJyJzogODY2MCxcbiAgICAnZm9yYWxsJzogODcwNCxcbiAgICAncGFydCc6IDg3MDYsXG4gICAgJ2V4aXN0JzogODcwNyxcbiAgICAnZW1wdHknOiA4NzA5LFxuICAgICduYWJsYSc6IDg3MTEsXG4gICAgJ2lzaW4nOiA4NzEyLFxuICAgICdub3Rpbic6IDg3MTMsXG4gICAgJ25pJzogODcxNSxcbiAgICAncHJvZCc6IDg3MTksXG4gICAgJ3N1bSc6IDg3MjEsXG4gICAgJ21pbnVzJzogODcyMixcbiAgICAnbG93YXN0JzogODcyNyxcbiAgICAncmFkaWMnOiA4NzMwLFxuICAgICdwcm9wJzogODczMyxcbiAgICAnaW5maW4nOiA4NzM0LFxuICAgICdhbmcnOiA4NzM2LFxuICAgICdhbmQnOiA4NzQzLFxuICAgICdvcic6IDg3NDQsXG4gICAgJ2NhcCc6IDg3NDUsXG4gICAgJ2N1cCc6IDg3NDYsXG4gICAgJ2ludCc6IDg3NDcsXG4gICAgJ3RoZXJlNCc6IDg3NTYsXG4gICAgJ3NpbSc6IDg3NjQsXG4gICAgJ2NvbmcnOiA4NzczLFxuICAgICdhc3ltcCc6IDg3NzYsXG4gICAgJ25lJzogODgwMCxcbiAgICAnZXF1aXYnOiA4ODAxLFxuICAgICdsZSc6IDg4MDQsXG4gICAgJ2dlJzogODgwNSxcbiAgICAnc3ViJzogODgzNCxcbiAgICAnc3VwJzogODgzNSxcbiAgICAnbnN1Yic6IDg4MzYsXG4gICAgJ3N1YmUnOiA4ODM4LFxuICAgICdzdXBlJzogODgzOSxcbiAgICAnb3BsdXMnOiA4ODUzLFxuICAgICdvdGltZXMnOiA4ODU1LFxuICAgICdwZXJwJzogODg2OSxcbiAgICAnc2RvdCc6IDg5MDEsXG4gICAgJ2xjZWlsJzogODk2OCxcbiAgICAncmNlaWwnOiA4OTY5LFxuICAgICdsZmxvb3InOiA4OTcwLFxuICAgICdyZmxvb3InOiA4OTcxLFxuICAgICdsYW5nJzogOTAwMSxcbiAgICAncmFuZyc6IDkwMDIsXG4gICAgJ2xveic6IDk2NzQsXG4gICAgJ3NwYWRlcyc6IDk4MjQsXG4gICAgJ2NsdWJzJzogOTgyNyxcbiAgICAnaGVhcnRzJzogOTgyOSxcbiAgICAnZGlhbXMnOiA5ODMwXG4gIH1cblxuICBPYmplY3Qua2V5cyhzYXguRU5USVRJRVMpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgIHZhciBlID0gc2F4LkVOVElUSUVTW2tleV1cbiAgICB2YXIgcyA9IHR5cGVvZiBlID09PSAnbnVtYmVyJyA/IFN0cmluZy5mcm9tQ2hhckNvZGUoZSkgOiBlXG4gICAgc2F4LkVOVElUSUVTW2tleV0gPSBzXG4gIH0pXG5cbiAgZm9yICh2YXIgcyBpbiBzYXguU1RBVEUpIHtcbiAgICBzYXguU1RBVEVbc2F4LlNUQVRFW3NdXSA9IHNcbiAgfVxuXG4gIC8vIHNob3J0aGFuZFxuICBTID0gc2F4LlNUQVRFXG5cbiAgZnVuY3Rpb24gZW1pdCAocGFyc2VyLCBldmVudCwgZGF0YSkge1xuICAgIHBhcnNlcltldmVudF0gJiYgcGFyc2VyW2V2ZW50XShkYXRhKVxuICB9XG5cbiAgZnVuY3Rpb24gZW1pdE5vZGUgKHBhcnNlciwgbm9kZVR5cGUsIGRhdGEpIHtcbiAgICBpZiAocGFyc2VyLnRleHROb2RlKSBjbG9zZVRleHQocGFyc2VyKVxuICAgIGVtaXQocGFyc2VyLCBub2RlVHlwZSwgZGF0YSlcbiAgfVxuXG4gIGZ1bmN0aW9uIGNsb3NlVGV4dCAocGFyc2VyKSB7XG4gICAgcGFyc2VyLnRleHROb2RlID0gdGV4dG9wdHMocGFyc2VyLm9wdCwgcGFyc2VyLnRleHROb2RlKVxuICAgIGlmIChwYXJzZXIudGV4dE5vZGUpIGVtaXQocGFyc2VyLCAnb250ZXh0JywgcGFyc2VyLnRleHROb2RlKVxuICAgIHBhcnNlci50ZXh0Tm9kZSA9ICcnXG4gIH1cblxuICBmdW5jdGlvbiB0ZXh0b3B0cyAob3B0LCB0ZXh0KSB7XG4gICAgaWYgKG9wdC50cmltKSB0ZXh0ID0gdGV4dC50cmltKClcbiAgICBpZiAob3B0Lm5vcm1hbGl6ZSkgdGV4dCA9IHRleHQucmVwbGFjZSgvXFxzKy9nLCAnICcpXG4gICAgcmV0dXJuIHRleHRcbiAgfVxuXG4gIGZ1bmN0aW9uIGVycm9yIChwYXJzZXIsIGVyKSB7XG4gICAgY2xvc2VUZXh0KHBhcnNlcilcbiAgICBpZiAocGFyc2VyLnRyYWNrUG9zaXRpb24pIHtcbiAgICAgIGVyICs9ICdcXG5MaW5lOiAnICsgcGFyc2VyLmxpbmUgK1xuICAgICAgICAnXFxuQ29sdW1uOiAnICsgcGFyc2VyLmNvbHVtbiArXG4gICAgICAgICdcXG5DaGFyOiAnICsgcGFyc2VyLmNcbiAgICB9XG4gICAgZXIgPSBuZXcgRXJyb3IoZXIpXG4gICAgcGFyc2VyLmVycm9yID0gZXJcbiAgICBlbWl0KHBhcnNlciwgJ29uZXJyb3InLCBlcilcbiAgICByZXR1cm4gcGFyc2VyXG4gIH1cblxuICBmdW5jdGlvbiBlbmQgKHBhcnNlcikge1xuICAgIGlmIChwYXJzZXIuc2F3Um9vdCAmJiAhcGFyc2VyLmNsb3NlZFJvb3QpIHN0cmljdEZhaWwocGFyc2VyLCAnVW5jbG9zZWQgcm9vdCB0YWcnKVxuICAgIGlmICgocGFyc2VyLnN0YXRlICE9PSBTLkJFR0lOKSAmJlxuICAgICAgKHBhcnNlci5zdGF0ZSAhPT0gUy5CRUdJTl9XSElURVNQQUNFKSAmJlxuICAgICAgKHBhcnNlci5zdGF0ZSAhPT0gUy5URVhUKSkge1xuICAgICAgZXJyb3IocGFyc2VyLCAnVW5leHBlY3RlZCBlbmQnKVxuICAgIH1cbiAgICBjbG9zZVRleHQocGFyc2VyKVxuICAgIHBhcnNlci5jID0gJydcbiAgICBwYXJzZXIuY2xvc2VkID0gdHJ1ZVxuICAgIGVtaXQocGFyc2VyLCAnb25lbmQnKVxuICAgIFNBWFBhcnNlci5jYWxsKHBhcnNlciwgcGFyc2VyLnN0cmljdCwgcGFyc2VyLm9wdClcbiAgICByZXR1cm4gcGFyc2VyXG4gIH1cblxuICBmdW5jdGlvbiBzdHJpY3RGYWlsIChwYXJzZXIsIG1lc3NhZ2UpIHtcbiAgICBpZiAodHlwZW9mIHBhcnNlciAhPT0gJ29iamVjdCcgfHwgIShwYXJzZXIgaW5zdGFuY2VvZiBTQVhQYXJzZXIpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2JhZCBjYWxsIHRvIHN0cmljdEZhaWwnKVxuICAgIH1cbiAgICBpZiAocGFyc2VyLnN0cmljdCkge1xuICAgICAgZXJyb3IocGFyc2VyLCBtZXNzYWdlKVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIG5ld1RhZyAocGFyc2VyKSB7XG4gICAgaWYgKCFwYXJzZXIuc3RyaWN0KSBwYXJzZXIudGFnTmFtZSA9IHBhcnNlci50YWdOYW1lW3BhcnNlci5sb29zZUNhc2VdKClcbiAgICB2YXIgcGFyZW50ID0gcGFyc2VyLnRhZ3NbcGFyc2VyLnRhZ3MubGVuZ3RoIC0gMV0gfHwgcGFyc2VyXG4gICAgdmFyIHRhZyA9IHBhcnNlci50YWcgPSB7IG5hbWU6IHBhcnNlci50YWdOYW1lLCBhdHRyaWJ1dGVzOiB7fSB9XG5cbiAgICAvLyB3aWxsIGJlIG92ZXJyaWRkZW4gaWYgdGFnIGNvbnRhaWxzIGFuIHhtbG5zPVwiZm9vXCIgb3IgeG1sbnM6Zm9vPVwiYmFyXCJcbiAgICBpZiAocGFyc2VyLm9wdC54bWxucykge1xuICAgICAgdGFnLm5zID0gcGFyZW50Lm5zXG4gICAgfVxuICAgIHBhcnNlci5hdHRyaWJMaXN0Lmxlbmd0aCA9IDBcbiAgICBlbWl0Tm9kZShwYXJzZXIsICdvbm9wZW50YWdzdGFydCcsIHRhZylcbiAgfVxuXG4gIGZ1bmN0aW9uIHFuYW1lIChuYW1lLCBhdHRyaWJ1dGUpIHtcbiAgICB2YXIgaSA9IG5hbWUuaW5kZXhPZignOicpXG4gICAgdmFyIHF1YWxOYW1lID0gaSA8IDAgPyBbICcnLCBuYW1lIF0gOiBuYW1lLnNwbGl0KCc6JylcbiAgICB2YXIgcHJlZml4ID0gcXVhbE5hbWVbMF1cbiAgICB2YXIgbG9jYWwgPSBxdWFsTmFtZVsxXVxuXG4gICAgLy8gPHggXCJ4bWxuc1wiPVwiaHR0cDovL2Zvb1wiPlxuICAgIGlmIChhdHRyaWJ1dGUgJiYgbmFtZSA9PT0gJ3htbG5zJykge1xuICAgICAgcHJlZml4ID0gJ3htbG5zJ1xuICAgICAgbG9jYWwgPSAnJ1xuICAgIH1cblxuICAgIHJldHVybiB7IHByZWZpeDogcHJlZml4LCBsb2NhbDogbG9jYWwgfVxuICB9XG5cbiAgZnVuY3Rpb24gYXR0cmliIChwYXJzZXIpIHtcbiAgICBpZiAoIXBhcnNlci5zdHJpY3QpIHtcbiAgICAgIHBhcnNlci5hdHRyaWJOYW1lID0gcGFyc2VyLmF0dHJpYk5hbWVbcGFyc2VyLmxvb3NlQ2FzZV0oKVxuICAgIH1cblxuICAgIGlmIChwYXJzZXIuYXR0cmliTGlzdC5pbmRleE9mKHBhcnNlci5hdHRyaWJOYW1lKSAhPT0gLTEgfHxcbiAgICAgIHBhcnNlci50YWcuYXR0cmlidXRlcy5oYXNPd25Qcm9wZXJ0eShwYXJzZXIuYXR0cmliTmFtZSkpIHtcbiAgICAgIHBhcnNlci5hdHRyaWJOYW1lID0gcGFyc2VyLmF0dHJpYlZhbHVlID0gJydcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIGlmIChwYXJzZXIub3B0LnhtbG5zKSB7XG4gICAgICB2YXIgcW4gPSBxbmFtZShwYXJzZXIuYXR0cmliTmFtZSwgdHJ1ZSlcbiAgICAgIHZhciBwcmVmaXggPSBxbi5wcmVmaXhcbiAgICAgIHZhciBsb2NhbCA9IHFuLmxvY2FsXG5cbiAgICAgIGlmIChwcmVmaXggPT09ICd4bWxucycpIHtcbiAgICAgICAgLy8gbmFtZXNwYWNlIGJpbmRpbmcgYXR0cmlidXRlLiBwdXNoIHRoZSBiaW5kaW5nIGludG8gc2NvcGVcbiAgICAgICAgaWYgKGxvY2FsID09PSAneG1sJyAmJiBwYXJzZXIuYXR0cmliVmFsdWUgIT09IFhNTF9OQU1FU1BBQ0UpIHtcbiAgICAgICAgICBzdHJpY3RGYWlsKHBhcnNlcixcbiAgICAgICAgICAgICd4bWw6IHByZWZpeCBtdXN0IGJlIGJvdW5kIHRvICcgKyBYTUxfTkFNRVNQQUNFICsgJ1xcbicgK1xuICAgICAgICAgICAgJ0FjdHVhbDogJyArIHBhcnNlci5hdHRyaWJWYWx1ZSlcbiAgICAgICAgfSBlbHNlIGlmIChsb2NhbCA9PT0gJ3htbG5zJyAmJiBwYXJzZXIuYXR0cmliVmFsdWUgIT09IFhNTE5TX05BTUVTUEFDRSkge1xuICAgICAgICAgIHN0cmljdEZhaWwocGFyc2VyLFxuICAgICAgICAgICAgJ3htbG5zOiBwcmVmaXggbXVzdCBiZSBib3VuZCB0byAnICsgWE1MTlNfTkFNRVNQQUNFICsgJ1xcbicgK1xuICAgICAgICAgICAgJ0FjdHVhbDogJyArIHBhcnNlci5hdHRyaWJWYWx1ZSlcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YXIgdGFnID0gcGFyc2VyLnRhZ1xuICAgICAgICAgIHZhciBwYXJlbnQgPSBwYXJzZXIudGFnc1twYXJzZXIudGFncy5sZW5ndGggLSAxXSB8fCBwYXJzZXJcbiAgICAgICAgICBpZiAodGFnLm5zID09PSBwYXJlbnQubnMpIHtcbiAgICAgICAgICAgIHRhZy5ucyA9IE9iamVjdC5jcmVhdGUocGFyZW50Lm5zKVxuICAgICAgICAgIH1cbiAgICAgICAgICB0YWcubnNbbG9jYWxdID0gcGFyc2VyLmF0dHJpYlZhbHVlXG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gZGVmZXIgb25hdHRyaWJ1dGUgZXZlbnRzIHVudGlsIGFsbCBhdHRyaWJ1dGVzIGhhdmUgYmVlbiBzZWVuXG4gICAgICAvLyBzbyBhbnkgbmV3IGJpbmRpbmdzIGNhbiB0YWtlIGVmZmVjdC4gcHJlc2VydmUgYXR0cmlidXRlIG9yZGVyXG4gICAgICAvLyBzbyBkZWZlcnJlZCBldmVudHMgY2FuIGJlIGVtaXR0ZWQgaW4gZG9jdW1lbnQgb3JkZXJcbiAgICAgIHBhcnNlci5hdHRyaWJMaXN0LnB1c2goW3BhcnNlci5hdHRyaWJOYW1lLCBwYXJzZXIuYXR0cmliVmFsdWVdKVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBpbiBub24teG1sbnMgbW9kZSwgd2UgY2FuIGVtaXQgdGhlIGV2ZW50IHJpZ2h0IGF3YXlcbiAgICAgIHBhcnNlci50YWcuYXR0cmlidXRlc1twYXJzZXIuYXR0cmliTmFtZV0gPSBwYXJzZXIuYXR0cmliVmFsdWVcbiAgICAgIGVtaXROb2RlKHBhcnNlciwgJ29uYXR0cmlidXRlJywge1xuICAgICAgICBuYW1lOiBwYXJzZXIuYXR0cmliTmFtZSxcbiAgICAgICAgdmFsdWU6IHBhcnNlci5hdHRyaWJWYWx1ZVxuICAgICAgfSlcbiAgICB9XG5cbiAgICBwYXJzZXIuYXR0cmliTmFtZSA9IHBhcnNlci5hdHRyaWJWYWx1ZSA9ICcnXG4gIH1cblxuICBmdW5jdGlvbiBvcGVuVGFnIChwYXJzZXIsIHNlbGZDbG9zaW5nKSB7XG4gICAgaWYgKHBhcnNlci5vcHQueG1sbnMpIHtcbiAgICAgIC8vIGVtaXQgbmFtZXNwYWNlIGJpbmRpbmcgZXZlbnRzXG4gICAgICB2YXIgdGFnID0gcGFyc2VyLnRhZ1xuXG4gICAgICAvLyBhZGQgbmFtZXNwYWNlIGluZm8gdG8gdGFnXG4gICAgICB2YXIgcW4gPSBxbmFtZShwYXJzZXIudGFnTmFtZSlcbiAgICAgIHRhZy5wcmVmaXggPSBxbi5wcmVmaXhcbiAgICAgIHRhZy5sb2NhbCA9IHFuLmxvY2FsXG4gICAgICB0YWcudXJpID0gdGFnLm5zW3FuLnByZWZpeF0gfHwgJydcblxuICAgICAgaWYgKHRhZy5wcmVmaXggJiYgIXRhZy51cmkpIHtcbiAgICAgICAgc3RyaWN0RmFpbChwYXJzZXIsICdVbmJvdW5kIG5hbWVzcGFjZSBwcmVmaXg6ICcgK1xuICAgICAgICAgIEpTT04uc3RyaW5naWZ5KHBhcnNlci50YWdOYW1lKSlcbiAgICAgICAgdGFnLnVyaSA9IHFuLnByZWZpeFxuICAgICAgfVxuXG4gICAgICB2YXIgcGFyZW50ID0gcGFyc2VyLnRhZ3NbcGFyc2VyLnRhZ3MubGVuZ3RoIC0gMV0gfHwgcGFyc2VyXG4gICAgICBpZiAodGFnLm5zICYmIHBhcmVudC5ucyAhPT0gdGFnLm5zKSB7XG4gICAgICAgIE9iamVjdC5rZXlzKHRhZy5ucykuZm9yRWFjaChmdW5jdGlvbiAocCkge1xuICAgICAgICAgIGVtaXROb2RlKHBhcnNlciwgJ29ub3Blbm5hbWVzcGFjZScsIHtcbiAgICAgICAgICAgIHByZWZpeDogcCxcbiAgICAgICAgICAgIHVyaTogdGFnLm5zW3BdXG4gICAgICAgICAgfSlcbiAgICAgICAgfSlcbiAgICAgIH1cblxuICAgICAgLy8gaGFuZGxlIGRlZmVycmVkIG9uYXR0cmlidXRlIGV2ZW50c1xuICAgICAgLy8gTm90ZTogZG8gbm90IGFwcGx5IGRlZmF1bHQgbnMgdG8gYXR0cmlidXRlczpcbiAgICAgIC8vICAgaHR0cDovL3d3dy53My5vcmcvVFIvUkVDLXhtbC1uYW1lcy8jZGVmYXVsdGluZ1xuICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBwYXJzZXIuYXR0cmliTGlzdC5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgdmFyIG52ID0gcGFyc2VyLmF0dHJpYkxpc3RbaV1cbiAgICAgICAgdmFyIG5hbWUgPSBudlswXVxuICAgICAgICB2YXIgdmFsdWUgPSBudlsxXVxuICAgICAgICB2YXIgcXVhbE5hbWUgPSBxbmFtZShuYW1lLCB0cnVlKVxuICAgICAgICB2YXIgcHJlZml4ID0gcXVhbE5hbWUucHJlZml4XG4gICAgICAgIHZhciBsb2NhbCA9IHF1YWxOYW1lLmxvY2FsXG4gICAgICAgIHZhciB1cmkgPSBwcmVmaXggPT09ICcnID8gJycgOiAodGFnLm5zW3ByZWZpeF0gfHwgJycpXG4gICAgICAgIHZhciBhID0ge1xuICAgICAgICAgIG5hbWU6IG5hbWUsXG4gICAgICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgICAgIHByZWZpeDogcHJlZml4LFxuICAgICAgICAgIGxvY2FsOiBsb2NhbCxcbiAgICAgICAgICB1cmk6IHVyaVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gaWYgdGhlcmUncyBhbnkgYXR0cmlidXRlcyB3aXRoIGFuIHVuZGVmaW5lZCBuYW1lc3BhY2UsXG4gICAgICAgIC8vIHRoZW4gZmFpbCBvbiB0aGVtIG5vdy5cbiAgICAgICAgaWYgKHByZWZpeCAmJiBwcmVmaXggIT09ICd4bWxucycgJiYgIXVyaSkge1xuICAgICAgICAgIHN0cmljdEZhaWwocGFyc2VyLCAnVW5ib3VuZCBuYW1lc3BhY2UgcHJlZml4OiAnICtcbiAgICAgICAgICAgIEpTT04uc3RyaW5naWZ5KHByZWZpeCkpXG4gICAgICAgICAgYS51cmkgPSBwcmVmaXhcbiAgICAgICAgfVxuICAgICAgICBwYXJzZXIudGFnLmF0dHJpYnV0ZXNbbmFtZV0gPSBhXG4gICAgICAgIGVtaXROb2RlKHBhcnNlciwgJ29uYXR0cmlidXRlJywgYSlcbiAgICAgIH1cbiAgICAgIHBhcnNlci5hdHRyaWJMaXN0Lmxlbmd0aCA9IDBcbiAgICB9XG5cbiAgICBwYXJzZXIudGFnLmlzU2VsZkNsb3NpbmcgPSAhIXNlbGZDbG9zaW5nXG5cbiAgICAvLyBwcm9jZXNzIHRoZSB0YWdcbiAgICBwYXJzZXIuc2F3Um9vdCA9IHRydWVcbiAgICBwYXJzZXIudGFncy5wdXNoKHBhcnNlci50YWcpXG4gICAgZW1pdE5vZGUocGFyc2VyLCAnb25vcGVudGFnJywgcGFyc2VyLnRhZylcbiAgICBpZiAoIXNlbGZDbG9zaW5nKSB7XG4gICAgICAvLyBzcGVjaWFsIGNhc2UgZm9yIDxzY3JpcHQ+IGluIG5vbi1zdHJpY3QgbW9kZS5cbiAgICAgIGlmICghcGFyc2VyLm5vc2NyaXB0ICYmIHBhcnNlci50YWdOYW1lLnRvTG93ZXJDYXNlKCkgPT09ICdzY3JpcHQnKSB7XG4gICAgICAgIHBhcnNlci5zdGF0ZSA9IFMuU0NSSVBUXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwYXJzZXIuc3RhdGUgPSBTLlRFWFRcbiAgICAgIH1cbiAgICAgIHBhcnNlci50YWcgPSBudWxsXG4gICAgICBwYXJzZXIudGFnTmFtZSA9ICcnXG4gICAgfVxuICAgIHBhcnNlci5hdHRyaWJOYW1lID0gcGFyc2VyLmF0dHJpYlZhbHVlID0gJydcbiAgICBwYXJzZXIuYXR0cmliTGlzdC5sZW5ndGggPSAwXG4gIH1cblxuICBmdW5jdGlvbiBjbG9zZVRhZyAocGFyc2VyKSB7XG4gICAgaWYgKCFwYXJzZXIudGFnTmFtZSkge1xuICAgICAgc3RyaWN0RmFpbChwYXJzZXIsICdXZWlyZCBlbXB0eSBjbG9zZSB0YWcuJylcbiAgICAgIHBhcnNlci50ZXh0Tm9kZSArPSAnPC8+J1xuICAgICAgcGFyc2VyLnN0YXRlID0gUy5URVhUXG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICBpZiAocGFyc2VyLnNjcmlwdCkge1xuICAgICAgaWYgKHBhcnNlci50YWdOYW1lICE9PSAnc2NyaXB0Jykge1xuICAgICAgICBwYXJzZXIuc2NyaXB0ICs9ICc8LycgKyBwYXJzZXIudGFnTmFtZSArICc+J1xuICAgICAgICBwYXJzZXIudGFnTmFtZSA9ICcnXG4gICAgICAgIHBhcnNlci5zdGF0ZSA9IFMuU0NSSVBUXG4gICAgICAgIHJldHVyblxuICAgICAgfVxuICAgICAgZW1pdE5vZGUocGFyc2VyLCAnb25zY3JpcHQnLCBwYXJzZXIuc2NyaXB0KVxuICAgICAgcGFyc2VyLnNjcmlwdCA9ICcnXG4gICAgfVxuXG4gICAgLy8gZmlyc3QgbWFrZSBzdXJlIHRoYXQgdGhlIGNsb3NpbmcgdGFnIGFjdHVhbGx5IGV4aXN0cy5cbiAgICAvLyA8YT48Yj48L2M+PC9iPjwvYT4gd2lsbCBjbG9zZSBldmVyeXRoaW5nLCBvdGhlcndpc2UuXG4gICAgdmFyIHQgPSBwYXJzZXIudGFncy5sZW5ndGhcbiAgICB2YXIgdGFnTmFtZSA9IHBhcnNlci50YWdOYW1lXG4gICAgaWYgKCFwYXJzZXIuc3RyaWN0KSB7XG4gICAgICB0YWdOYW1lID0gdGFnTmFtZVtwYXJzZXIubG9vc2VDYXNlXSgpXG4gICAgfVxuICAgIHZhciBjbG9zZVRvID0gdGFnTmFtZVxuICAgIHdoaWxlICh0LS0pIHtcbiAgICAgIHZhciBjbG9zZSA9IHBhcnNlci50YWdzW3RdXG4gICAgICBpZiAoY2xvc2UubmFtZSAhPT0gY2xvc2VUbykge1xuICAgICAgICAvLyBmYWlsIHRoZSBmaXJzdCB0aW1lIGluIHN0cmljdCBtb2RlXG4gICAgICAgIHN0cmljdEZhaWwocGFyc2VyLCAnVW5leHBlY3RlZCBjbG9zZSB0YWcnKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYnJlYWtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBkaWRuJ3QgZmluZCBpdC4gIHdlIGFscmVhZHkgZmFpbGVkIGZvciBzdHJpY3QsIHNvIGp1c3QgYWJvcnQuXG4gICAgaWYgKHQgPCAwKSB7XG4gICAgICBzdHJpY3RGYWlsKHBhcnNlciwgJ1VubWF0Y2hlZCBjbG9zaW5nIHRhZzogJyArIHBhcnNlci50YWdOYW1lKVxuICAgICAgcGFyc2VyLnRleHROb2RlICs9ICc8LycgKyBwYXJzZXIudGFnTmFtZSArICc+J1xuICAgICAgcGFyc2VyLnN0YXRlID0gUy5URVhUXG4gICAgICByZXR1cm5cbiAgICB9XG4gICAgcGFyc2VyLnRhZ05hbWUgPSB0YWdOYW1lXG4gICAgdmFyIHMgPSBwYXJzZXIudGFncy5sZW5ndGhcbiAgICB3aGlsZSAocy0tID4gdCkge1xuICAgICAgdmFyIHRhZyA9IHBhcnNlci50YWcgPSBwYXJzZXIudGFncy5wb3AoKVxuICAgICAgcGFyc2VyLnRhZ05hbWUgPSBwYXJzZXIudGFnLm5hbWVcbiAgICAgIGVtaXROb2RlKHBhcnNlciwgJ29uY2xvc2V0YWcnLCBwYXJzZXIudGFnTmFtZSlcblxuICAgICAgdmFyIHggPSB7fVxuICAgICAgZm9yICh2YXIgaSBpbiB0YWcubnMpIHtcbiAgICAgICAgeFtpXSA9IHRhZy5uc1tpXVxuICAgICAgfVxuXG4gICAgICB2YXIgcGFyZW50ID0gcGFyc2VyLnRhZ3NbcGFyc2VyLnRhZ3MubGVuZ3RoIC0gMV0gfHwgcGFyc2VyXG4gICAgICBpZiAocGFyc2VyLm9wdC54bWxucyAmJiB0YWcubnMgIT09IHBhcmVudC5ucykge1xuICAgICAgICAvLyByZW1vdmUgbmFtZXNwYWNlIGJpbmRpbmdzIGludHJvZHVjZWQgYnkgdGFnXG4gICAgICAgIE9iamVjdC5rZXlzKHRhZy5ucykuZm9yRWFjaChmdW5jdGlvbiAocCkge1xuICAgICAgICAgIHZhciBuID0gdGFnLm5zW3BdXG4gICAgICAgICAgZW1pdE5vZGUocGFyc2VyLCAnb25jbG9zZW5hbWVzcGFjZScsIHsgcHJlZml4OiBwLCB1cmk6IG4gfSlcbiAgICAgICAgfSlcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHQgPT09IDApIHBhcnNlci5jbG9zZWRSb290ID0gdHJ1ZVxuICAgIHBhcnNlci50YWdOYW1lID0gcGFyc2VyLmF0dHJpYlZhbHVlID0gcGFyc2VyLmF0dHJpYk5hbWUgPSAnJ1xuICAgIHBhcnNlci5hdHRyaWJMaXN0Lmxlbmd0aCA9IDBcbiAgICBwYXJzZXIuc3RhdGUgPSBTLlRFWFRcbiAgfVxuXG4gIGZ1bmN0aW9uIHBhcnNlRW50aXR5IChwYXJzZXIpIHtcbiAgICB2YXIgZW50aXR5ID0gcGFyc2VyLmVudGl0eVxuICAgIHZhciBlbnRpdHlMQyA9IGVudGl0eS50b0xvd2VyQ2FzZSgpXG4gICAgdmFyIG51bVxuICAgIHZhciBudW1TdHIgPSAnJ1xuXG4gICAgaWYgKHBhcnNlci5FTlRJVElFU1tlbnRpdHldKSB7XG4gICAgICByZXR1cm4gcGFyc2VyLkVOVElUSUVTW2VudGl0eV1cbiAgICB9XG4gICAgaWYgKHBhcnNlci5FTlRJVElFU1tlbnRpdHlMQ10pIHtcbiAgICAgIHJldHVybiBwYXJzZXIuRU5USVRJRVNbZW50aXR5TENdXG4gICAgfVxuICAgIGVudGl0eSA9IGVudGl0eUxDXG4gICAgaWYgKGVudGl0eS5jaGFyQXQoMCkgPT09ICcjJykge1xuICAgICAgaWYgKGVudGl0eS5jaGFyQXQoMSkgPT09ICd4Jykge1xuICAgICAgICBlbnRpdHkgPSBlbnRpdHkuc2xpY2UoMilcbiAgICAgICAgbnVtID0gcGFyc2VJbnQoZW50aXR5LCAxNilcbiAgICAgICAgbnVtU3RyID0gbnVtLnRvU3RyaW5nKDE2KVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZW50aXR5ID0gZW50aXR5LnNsaWNlKDEpXG4gICAgICAgIG51bSA9IHBhcnNlSW50KGVudGl0eSwgMTApXG4gICAgICAgIG51bVN0ciA9IG51bS50b1N0cmluZygxMClcbiAgICAgIH1cbiAgICB9XG4gICAgZW50aXR5ID0gZW50aXR5LnJlcGxhY2UoL14wKy8sICcnKVxuICAgIGlmIChpc05hTihudW0pIHx8IG51bVN0ci50b0xvd2VyQ2FzZSgpICE9PSBlbnRpdHkpIHtcbiAgICAgIHN0cmljdEZhaWwocGFyc2VyLCAnSW52YWxpZCBjaGFyYWN0ZXIgZW50aXR5JylcbiAgICAgIHJldHVybiAnJicgKyBwYXJzZXIuZW50aXR5ICsgJzsnXG4gICAgfVxuXG4gICAgcmV0dXJuIFN0cmluZy5mcm9tQ29kZVBvaW50KG51bSlcbiAgfVxuXG4gIGZ1bmN0aW9uIGJlZ2luV2hpdGVTcGFjZSAocGFyc2VyLCBjKSB7XG4gICAgaWYgKGMgPT09ICc8Jykge1xuICAgICAgcGFyc2VyLnN0YXRlID0gUy5PUEVOX1dBS0FcbiAgICAgIHBhcnNlci5zdGFydFRhZ1Bvc2l0aW9uID0gcGFyc2VyLnBvc2l0aW9uXG4gICAgfSBlbHNlIGlmICghaXNXaGl0ZXNwYWNlKGMpKSB7XG4gICAgICAvLyBoYXZlIHRvIHByb2Nlc3MgdGhpcyBhcyBhIHRleHQgbm9kZS5cbiAgICAgIC8vIHdlaXJkLCBidXQgaGFwcGVucy5cbiAgICAgIHN0cmljdEZhaWwocGFyc2VyLCAnTm9uLXdoaXRlc3BhY2UgYmVmb3JlIGZpcnN0IHRhZy4nKVxuICAgICAgcGFyc2VyLnRleHROb2RlID0gY1xuICAgICAgcGFyc2VyLnN0YXRlID0gUy5URVhUXG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gY2hhckF0IChjaHVuaywgaSkge1xuICAgIHZhciByZXN1bHQgPSAnJ1xuICAgIGlmIChpIDwgY2h1bmsubGVuZ3RoKSB7XG4gICAgICByZXN1bHQgPSBjaHVuay5jaGFyQXQoaSlcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdFxuICB9XG5cbiAgZnVuY3Rpb24gd3JpdGUgKGNodW5rKSB7XG4gICAgdmFyIHBhcnNlciA9IHRoaXNcbiAgICBpZiAodGhpcy5lcnJvcikge1xuICAgICAgdGhyb3cgdGhpcy5lcnJvclxuICAgIH1cbiAgICBpZiAocGFyc2VyLmNsb3NlZCkge1xuICAgICAgcmV0dXJuIGVycm9yKHBhcnNlcixcbiAgICAgICAgJ0Nhbm5vdCB3cml0ZSBhZnRlciBjbG9zZS4gQXNzaWduIGFuIG9ucmVhZHkgaGFuZGxlci4nKVxuICAgIH1cbiAgICBpZiAoY2h1bmsgPT09IG51bGwpIHtcbiAgICAgIHJldHVybiBlbmQocGFyc2VyKVxuICAgIH1cbiAgICBpZiAodHlwZW9mIGNodW5rID09PSAnb2JqZWN0Jykge1xuICAgICAgY2h1bmsgPSBjaHVuay50b1N0cmluZygpXG4gICAgfVxuICAgIHZhciBpID0gMFxuICAgIHZhciBjID0gJydcbiAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgYyA9IGNoYXJBdChjaHVuaywgaSsrKVxuICAgICAgcGFyc2VyLmMgPSBjXG5cbiAgICAgIGlmICghYykge1xuICAgICAgICBicmVha1xuICAgICAgfVxuXG4gICAgICBpZiAocGFyc2VyLnRyYWNrUG9zaXRpb24pIHtcbiAgICAgICAgcGFyc2VyLnBvc2l0aW9uKytcbiAgICAgICAgaWYgKGMgPT09ICdcXG4nKSB7XG4gICAgICAgICAgcGFyc2VyLmxpbmUrK1xuICAgICAgICAgIHBhcnNlci5jb2x1bW4gPSAwXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcGFyc2VyLmNvbHVtbisrXG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgc3dpdGNoIChwYXJzZXIuc3RhdGUpIHtcbiAgICAgICAgY2FzZSBTLkJFR0lOOlxuICAgICAgICAgIHBhcnNlci5zdGF0ZSA9IFMuQkVHSU5fV0hJVEVTUEFDRVxuICAgICAgICAgIGlmIChjID09PSAnXFx1RkVGRicpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgICAgfVxuICAgICAgICAgIGJlZ2luV2hpdGVTcGFjZShwYXJzZXIsIGMpXG4gICAgICAgICAgY29udGludWVcblxuICAgICAgICBjYXNlIFMuQkVHSU5fV0hJVEVTUEFDRTpcbiAgICAgICAgICBiZWdpbldoaXRlU3BhY2UocGFyc2VyLCBjKVxuICAgICAgICAgIGNvbnRpbnVlXG5cbiAgICAgICAgY2FzZSBTLlRFWFQ6XG4gICAgICAgICAgaWYgKHBhcnNlci5zYXdSb290ICYmICFwYXJzZXIuY2xvc2VkUm9vdCkge1xuICAgICAgICAgICAgdmFyIHN0YXJ0aSA9IGkgLSAxXG4gICAgICAgICAgICB3aGlsZSAoYyAmJiBjICE9PSAnPCcgJiYgYyAhPT0gJyYnKSB7XG4gICAgICAgICAgICAgIGMgPSBjaGFyQXQoY2h1bmssIGkrKylcbiAgICAgICAgICAgICAgaWYgKGMgJiYgcGFyc2VyLnRyYWNrUG9zaXRpb24pIHtcbiAgICAgICAgICAgICAgICBwYXJzZXIucG9zaXRpb24rK1xuICAgICAgICAgICAgICAgIGlmIChjID09PSAnXFxuJykge1xuICAgICAgICAgICAgICAgICAgcGFyc2VyLmxpbmUrK1xuICAgICAgICAgICAgICAgICAgcGFyc2VyLmNvbHVtbiA9IDBcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgcGFyc2VyLmNvbHVtbisrXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwYXJzZXIudGV4dE5vZGUgKz0gY2h1bmsuc3Vic3RyaW5nKHN0YXJ0aSwgaSAtIDEpXG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChjID09PSAnPCcgJiYgIShwYXJzZXIuc2F3Um9vdCAmJiBwYXJzZXIuY2xvc2VkUm9vdCAmJiAhcGFyc2VyLnN0cmljdCkpIHtcbiAgICAgICAgICAgIHBhcnNlci5zdGF0ZSA9IFMuT1BFTl9XQUtBXG4gICAgICAgICAgICBwYXJzZXIuc3RhcnRUYWdQb3NpdGlvbiA9IHBhcnNlci5wb3NpdGlvblxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAoIWlzV2hpdGVzcGFjZShjKSAmJiAoIXBhcnNlci5zYXdSb290IHx8IHBhcnNlci5jbG9zZWRSb290KSkge1xuICAgICAgICAgICAgICBzdHJpY3RGYWlsKHBhcnNlciwgJ1RleHQgZGF0YSBvdXRzaWRlIG9mIHJvb3Qgbm9kZS4nKVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGMgPT09ICcmJykge1xuICAgICAgICAgICAgICBwYXJzZXIuc3RhdGUgPSBTLlRFWFRfRU5USVRZXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBwYXJzZXIudGV4dE5vZGUgKz0gY1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBjb250aW51ZVxuXG4gICAgICAgIGNhc2UgUy5TQ1JJUFQ6XG4gICAgICAgICAgLy8gb25seSBub24tc3RyaWN0XG4gICAgICAgICAgaWYgKGMgPT09ICc8Jykge1xuICAgICAgICAgICAgcGFyc2VyLnN0YXRlID0gUy5TQ1JJUFRfRU5ESU5HXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHBhcnNlci5zY3JpcHQgKz0gY1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb250aW51ZVxuXG4gICAgICAgIGNhc2UgUy5TQ1JJUFRfRU5ESU5HOlxuICAgICAgICAgIGlmIChjID09PSAnLycpIHtcbiAgICAgICAgICAgIHBhcnNlci5zdGF0ZSA9IFMuQ0xPU0VfVEFHXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHBhcnNlci5zY3JpcHQgKz0gJzwnICsgY1xuICAgICAgICAgICAgcGFyc2VyLnN0YXRlID0gUy5TQ1JJUFRcbiAgICAgICAgICB9XG4gICAgICAgICAgY29udGludWVcblxuICAgICAgICBjYXNlIFMuT1BFTl9XQUtBOlxuICAgICAgICAgIC8vIGVpdGhlciBhIC8sID8sICEsIG9yIHRleHQgaXMgY29taW5nIG5leHQuXG4gICAgICAgICAgaWYgKGMgPT09ICchJykge1xuICAgICAgICAgICAgcGFyc2VyLnN0YXRlID0gUy5TR01MX0RFQ0xcbiAgICAgICAgICAgIHBhcnNlci5zZ21sRGVjbCA9ICcnXG4gICAgICAgICAgfSBlbHNlIGlmIChpc1doaXRlc3BhY2UoYykpIHtcbiAgICAgICAgICAgIC8vIHdhaXQgZm9yIGl0Li4uXG4gICAgICAgICAgfSBlbHNlIGlmIChpc01hdGNoKG5hbWVTdGFydCwgYykpIHtcbiAgICAgICAgICAgIHBhcnNlci5zdGF0ZSA9IFMuT1BFTl9UQUdcbiAgICAgICAgICAgIHBhcnNlci50YWdOYW1lID0gY1xuICAgICAgICAgIH0gZWxzZSBpZiAoYyA9PT0gJy8nKSB7XG4gICAgICAgICAgICBwYXJzZXIuc3RhdGUgPSBTLkNMT1NFX1RBR1xuICAgICAgICAgICAgcGFyc2VyLnRhZ05hbWUgPSAnJ1xuICAgICAgICAgIH0gZWxzZSBpZiAoYyA9PT0gJz8nKSB7XG4gICAgICAgICAgICBwYXJzZXIuc3RhdGUgPSBTLlBST0NfSU5TVFxuICAgICAgICAgICAgcGFyc2VyLnByb2NJbnN0TmFtZSA9IHBhcnNlci5wcm9jSW5zdEJvZHkgPSAnJ1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzdHJpY3RGYWlsKHBhcnNlciwgJ1VuZW5jb2RlZCA8JylcbiAgICAgICAgICAgIC8vIGlmIHRoZXJlIHdhcyBzb21lIHdoaXRlc3BhY2UsIHRoZW4gYWRkIHRoYXQgaW4uXG4gICAgICAgICAgICBpZiAocGFyc2VyLnN0YXJ0VGFnUG9zaXRpb24gKyAxIDwgcGFyc2VyLnBvc2l0aW9uKSB7XG4gICAgICAgICAgICAgIHZhciBwYWQgPSBwYXJzZXIucG9zaXRpb24gLSBwYXJzZXIuc3RhcnRUYWdQb3NpdGlvblxuICAgICAgICAgICAgICBjID0gbmV3IEFycmF5KHBhZCkuam9pbignICcpICsgY1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcGFyc2VyLnRleHROb2RlICs9ICc8JyArIGNcbiAgICAgICAgICAgIHBhcnNlci5zdGF0ZSA9IFMuVEVYVFxuICAgICAgICAgIH1cbiAgICAgICAgICBjb250aW51ZVxuXG4gICAgICAgIGNhc2UgUy5TR01MX0RFQ0w6XG4gICAgICAgICAgaWYgKChwYXJzZXIuc2dtbERlY2wgKyBjKS50b1VwcGVyQ2FzZSgpID09PSBDREFUQSkge1xuICAgICAgICAgICAgZW1pdE5vZGUocGFyc2VyLCAnb25vcGVuY2RhdGEnKVxuICAgICAgICAgICAgcGFyc2VyLnN0YXRlID0gUy5DREFUQVxuICAgICAgICAgICAgcGFyc2VyLnNnbWxEZWNsID0gJydcbiAgICAgICAgICAgIHBhcnNlci5jZGF0YSA9ICcnXG4gICAgICAgICAgfSBlbHNlIGlmIChwYXJzZXIuc2dtbERlY2wgKyBjID09PSAnLS0nKSB7XG4gICAgICAgICAgICBwYXJzZXIuc3RhdGUgPSBTLkNPTU1FTlRcbiAgICAgICAgICAgIHBhcnNlci5jb21tZW50ID0gJydcbiAgICAgICAgICAgIHBhcnNlci5zZ21sRGVjbCA9ICcnXG4gICAgICAgICAgfSBlbHNlIGlmICgocGFyc2VyLnNnbWxEZWNsICsgYykudG9VcHBlckNhc2UoKSA9PT0gRE9DVFlQRSkge1xuICAgICAgICAgICAgcGFyc2VyLnN0YXRlID0gUy5ET0NUWVBFXG4gICAgICAgICAgICBpZiAocGFyc2VyLmRvY3R5cGUgfHwgcGFyc2VyLnNhd1Jvb3QpIHtcbiAgICAgICAgICAgICAgc3RyaWN0RmFpbChwYXJzZXIsXG4gICAgICAgICAgICAgICAgJ0luYXBwcm9wcmlhdGVseSBsb2NhdGVkIGRvY3R5cGUgZGVjbGFyYXRpb24nKVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcGFyc2VyLmRvY3R5cGUgPSAnJ1xuICAgICAgICAgICAgcGFyc2VyLnNnbWxEZWNsID0gJydcbiAgICAgICAgICB9IGVsc2UgaWYgKGMgPT09ICc+Jykge1xuICAgICAgICAgICAgZW1pdE5vZGUocGFyc2VyLCAnb25zZ21sZGVjbGFyYXRpb24nLCBwYXJzZXIuc2dtbERlY2wpXG4gICAgICAgICAgICBwYXJzZXIuc2dtbERlY2wgPSAnJ1xuICAgICAgICAgICAgcGFyc2VyLnN0YXRlID0gUy5URVhUXG4gICAgICAgICAgfSBlbHNlIGlmIChpc1F1b3RlKGMpKSB7XG4gICAgICAgICAgICBwYXJzZXIuc3RhdGUgPSBTLlNHTUxfREVDTF9RVU9URURcbiAgICAgICAgICAgIHBhcnNlci5zZ21sRGVjbCArPSBjXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHBhcnNlci5zZ21sRGVjbCArPSBjXG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnRpbnVlXG5cbiAgICAgICAgY2FzZSBTLlNHTUxfREVDTF9RVU9URUQ6XG4gICAgICAgICAgaWYgKGMgPT09IHBhcnNlci5xKSB7XG4gICAgICAgICAgICBwYXJzZXIuc3RhdGUgPSBTLlNHTUxfREVDTFxuICAgICAgICAgICAgcGFyc2VyLnEgPSAnJ1xuICAgICAgICAgIH1cbiAgICAgICAgICBwYXJzZXIuc2dtbERlY2wgKz0gY1xuICAgICAgICAgIGNvbnRpbnVlXG5cbiAgICAgICAgY2FzZSBTLkRPQ1RZUEU6XG4gICAgICAgICAgaWYgKGMgPT09ICc+Jykge1xuICAgICAgICAgICAgcGFyc2VyLnN0YXRlID0gUy5URVhUXG4gICAgICAgICAgICBlbWl0Tm9kZShwYXJzZXIsICdvbmRvY3R5cGUnLCBwYXJzZXIuZG9jdHlwZSlcbiAgICAgICAgICAgIHBhcnNlci5kb2N0eXBlID0gdHJ1ZSAvLyBqdXN0IHJlbWVtYmVyIHRoYXQgd2Ugc2F3IGl0LlxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBwYXJzZXIuZG9jdHlwZSArPSBjXG4gICAgICAgICAgICBpZiAoYyA9PT0gJ1snKSB7XG4gICAgICAgICAgICAgIHBhcnNlci5zdGF0ZSA9IFMuRE9DVFlQRV9EVERcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoaXNRdW90ZShjKSkge1xuICAgICAgICAgICAgICBwYXJzZXIuc3RhdGUgPSBTLkRPQ1RZUEVfUVVPVEVEXG4gICAgICAgICAgICAgIHBhcnNlci5xID0gY1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBjb250aW51ZVxuXG4gICAgICAgIGNhc2UgUy5ET0NUWVBFX1FVT1RFRDpcbiAgICAgICAgICBwYXJzZXIuZG9jdHlwZSArPSBjXG4gICAgICAgICAgaWYgKGMgPT09IHBhcnNlci5xKSB7XG4gICAgICAgICAgICBwYXJzZXIucSA9ICcnXG4gICAgICAgICAgICBwYXJzZXIuc3RhdGUgPSBTLkRPQ1RZUEVcbiAgICAgICAgICB9XG4gICAgICAgICAgY29udGludWVcblxuICAgICAgICBjYXNlIFMuRE9DVFlQRV9EVEQ6XG4gICAgICAgICAgcGFyc2VyLmRvY3R5cGUgKz0gY1xuICAgICAgICAgIGlmIChjID09PSAnXScpIHtcbiAgICAgICAgICAgIHBhcnNlci5zdGF0ZSA9IFMuRE9DVFlQRVxuICAgICAgICAgIH0gZWxzZSBpZiAoaXNRdW90ZShjKSkge1xuICAgICAgICAgICAgcGFyc2VyLnN0YXRlID0gUy5ET0NUWVBFX0RURF9RVU9URURcbiAgICAgICAgICAgIHBhcnNlci5xID0gY1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb250aW51ZVxuXG4gICAgICAgIGNhc2UgUy5ET0NUWVBFX0RURF9RVU9URUQ6XG4gICAgICAgICAgcGFyc2VyLmRvY3R5cGUgKz0gY1xuICAgICAgICAgIGlmIChjID09PSBwYXJzZXIucSkge1xuICAgICAgICAgICAgcGFyc2VyLnN0YXRlID0gUy5ET0NUWVBFX0RURFxuICAgICAgICAgICAgcGFyc2VyLnEgPSAnJ1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb250aW51ZVxuXG4gICAgICAgIGNhc2UgUy5DT01NRU5UOlxuICAgICAgICAgIGlmIChjID09PSAnLScpIHtcbiAgICAgICAgICAgIHBhcnNlci5zdGF0ZSA9IFMuQ09NTUVOVF9FTkRJTkdcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcGFyc2VyLmNvbW1lbnQgKz0gY1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb250aW51ZVxuXG4gICAgICAgIGNhc2UgUy5DT01NRU5UX0VORElORzpcbiAgICAgICAgICBpZiAoYyA9PT0gJy0nKSB7XG4gICAgICAgICAgICBwYXJzZXIuc3RhdGUgPSBTLkNPTU1FTlRfRU5ERURcbiAgICAgICAgICAgIHBhcnNlci5jb21tZW50ID0gdGV4dG9wdHMocGFyc2VyLm9wdCwgcGFyc2VyLmNvbW1lbnQpXG4gICAgICAgICAgICBpZiAocGFyc2VyLmNvbW1lbnQpIHtcbiAgICAgICAgICAgICAgZW1pdE5vZGUocGFyc2VyLCAnb25jb21tZW50JywgcGFyc2VyLmNvbW1lbnQpXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwYXJzZXIuY29tbWVudCA9ICcnXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHBhcnNlci5jb21tZW50ICs9ICctJyArIGNcbiAgICAgICAgICAgIHBhcnNlci5zdGF0ZSA9IFMuQ09NTUVOVFxuICAgICAgICAgIH1cbiAgICAgICAgICBjb250aW51ZVxuXG4gICAgICAgIGNhc2UgUy5DT01NRU5UX0VOREVEOlxuICAgICAgICAgIGlmIChjICE9PSAnPicpIHtcbiAgICAgICAgICAgIHN0cmljdEZhaWwocGFyc2VyLCAnTWFsZm9ybWVkIGNvbW1lbnQnKVxuICAgICAgICAgICAgLy8gYWxsb3cgPCEtLSBibGFoIC0tIGJsb28gLS0+IGluIG5vbi1zdHJpY3QgbW9kZSxcbiAgICAgICAgICAgIC8vIHdoaWNoIGlzIGEgY29tbWVudCBvZiBcIiBibGFoIC0tIGJsb28gXCJcbiAgICAgICAgICAgIHBhcnNlci5jb21tZW50ICs9ICctLScgKyBjXG4gICAgICAgICAgICBwYXJzZXIuc3RhdGUgPSBTLkNPTU1FTlRcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcGFyc2VyLnN0YXRlID0gUy5URVhUXG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnRpbnVlXG5cbiAgICAgICAgY2FzZSBTLkNEQVRBOlxuICAgICAgICAgIGlmIChjID09PSAnXScpIHtcbiAgICAgICAgICAgIHBhcnNlci5zdGF0ZSA9IFMuQ0RBVEFfRU5ESU5HXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHBhcnNlci5jZGF0YSArPSBjXG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnRpbnVlXG5cbiAgICAgICAgY2FzZSBTLkNEQVRBX0VORElORzpcbiAgICAgICAgICBpZiAoYyA9PT0gJ10nKSB7XG4gICAgICAgICAgICBwYXJzZXIuc3RhdGUgPSBTLkNEQVRBX0VORElOR18yXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHBhcnNlci5jZGF0YSArPSAnXScgKyBjXG4gICAgICAgICAgICBwYXJzZXIuc3RhdGUgPSBTLkNEQVRBXG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnRpbnVlXG5cbiAgICAgICAgY2FzZSBTLkNEQVRBX0VORElOR18yOlxuICAgICAgICAgIGlmIChjID09PSAnPicpIHtcbiAgICAgICAgICAgIGlmIChwYXJzZXIuY2RhdGEpIHtcbiAgICAgICAgICAgICAgZW1pdE5vZGUocGFyc2VyLCAnb25jZGF0YScsIHBhcnNlci5jZGF0YSlcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVtaXROb2RlKHBhcnNlciwgJ29uY2xvc2VjZGF0YScpXG4gICAgICAgICAgICBwYXJzZXIuY2RhdGEgPSAnJ1xuICAgICAgICAgICAgcGFyc2VyLnN0YXRlID0gUy5URVhUXG4gICAgICAgICAgfSBlbHNlIGlmIChjID09PSAnXScpIHtcbiAgICAgICAgICAgIHBhcnNlci5jZGF0YSArPSAnXSdcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcGFyc2VyLmNkYXRhICs9ICddXScgKyBjXG4gICAgICAgICAgICBwYXJzZXIuc3RhdGUgPSBTLkNEQVRBXG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnRpbnVlXG5cbiAgICAgICAgY2FzZSBTLlBST0NfSU5TVDpcbiAgICAgICAgICBpZiAoYyA9PT0gJz8nKSB7XG4gICAgICAgICAgICBwYXJzZXIuc3RhdGUgPSBTLlBST0NfSU5TVF9FTkRJTkdcbiAgICAgICAgICB9IGVsc2UgaWYgKGlzV2hpdGVzcGFjZShjKSkge1xuICAgICAgICAgICAgcGFyc2VyLnN0YXRlID0gUy5QUk9DX0lOU1RfQk9EWVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBwYXJzZXIucHJvY0luc3ROYW1lICs9IGNcbiAgICAgICAgICB9XG4gICAgICAgICAgY29udGludWVcblxuICAgICAgICBjYXNlIFMuUFJPQ19JTlNUX0JPRFk6XG4gICAgICAgICAgaWYgKCFwYXJzZXIucHJvY0luc3RCb2R5ICYmIGlzV2hpdGVzcGFjZShjKSkge1xuICAgICAgICAgICAgY29udGludWVcbiAgICAgICAgICB9IGVsc2UgaWYgKGMgPT09ICc/Jykge1xuICAgICAgICAgICAgcGFyc2VyLnN0YXRlID0gUy5QUk9DX0lOU1RfRU5ESU5HXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHBhcnNlci5wcm9jSW5zdEJvZHkgKz0gY1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb250aW51ZVxuXG4gICAgICAgIGNhc2UgUy5QUk9DX0lOU1RfRU5ESU5HOlxuICAgICAgICAgIGlmIChjID09PSAnPicpIHtcbiAgICAgICAgICAgIGVtaXROb2RlKHBhcnNlciwgJ29ucHJvY2Vzc2luZ2luc3RydWN0aW9uJywge1xuICAgICAgICAgICAgICBuYW1lOiBwYXJzZXIucHJvY0luc3ROYW1lLFxuICAgICAgICAgICAgICBib2R5OiBwYXJzZXIucHJvY0luc3RCb2R5XG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgcGFyc2VyLnByb2NJbnN0TmFtZSA9IHBhcnNlci5wcm9jSW5zdEJvZHkgPSAnJ1xuICAgICAgICAgICAgcGFyc2VyLnN0YXRlID0gUy5URVhUXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHBhcnNlci5wcm9jSW5zdEJvZHkgKz0gJz8nICsgY1xuICAgICAgICAgICAgcGFyc2VyLnN0YXRlID0gUy5QUk9DX0lOU1RfQk9EWVxuICAgICAgICAgIH1cbiAgICAgICAgICBjb250aW51ZVxuXG4gICAgICAgIGNhc2UgUy5PUEVOX1RBRzpcbiAgICAgICAgICBpZiAoaXNNYXRjaChuYW1lQm9keSwgYykpIHtcbiAgICAgICAgICAgIHBhcnNlci50YWdOYW1lICs9IGNcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbmV3VGFnKHBhcnNlcilcbiAgICAgICAgICAgIGlmIChjID09PSAnPicpIHtcbiAgICAgICAgICAgICAgb3BlblRhZyhwYXJzZXIpXG4gICAgICAgICAgICB9IGVsc2UgaWYgKGMgPT09ICcvJykge1xuICAgICAgICAgICAgICBwYXJzZXIuc3RhdGUgPSBTLk9QRU5fVEFHX1NMQVNIXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBpZiAoIWlzV2hpdGVzcGFjZShjKSkge1xuICAgICAgICAgICAgICAgIHN0cmljdEZhaWwocGFyc2VyLCAnSW52YWxpZCBjaGFyYWN0ZXIgaW4gdGFnIG5hbWUnKVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHBhcnNlci5zdGF0ZSA9IFMuQVRUUklCXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnRpbnVlXG5cbiAgICAgICAgY2FzZSBTLk9QRU5fVEFHX1NMQVNIOlxuICAgICAgICAgIGlmIChjID09PSAnPicpIHtcbiAgICAgICAgICAgIG9wZW5UYWcocGFyc2VyLCB0cnVlKVxuICAgICAgICAgICAgY2xvc2VUYWcocGFyc2VyKVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzdHJpY3RGYWlsKHBhcnNlciwgJ0ZvcndhcmQtc2xhc2ggaW4gb3BlbmluZyB0YWcgbm90IGZvbGxvd2VkIGJ5ID4nKVxuICAgICAgICAgICAgcGFyc2VyLnN0YXRlID0gUy5BVFRSSUJcbiAgICAgICAgICB9XG4gICAgICAgICAgY29udGludWVcblxuICAgICAgICBjYXNlIFMuQVRUUklCOlxuICAgICAgICAgIC8vIGhhdmVuJ3QgcmVhZCB0aGUgYXR0cmlidXRlIG5hbWUgeWV0LlxuICAgICAgICAgIGlmIChpc1doaXRlc3BhY2UoYykpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgICAgfSBlbHNlIGlmIChjID09PSAnPicpIHtcbiAgICAgICAgICAgIG9wZW5UYWcocGFyc2VyKVxuICAgICAgICAgIH0gZWxzZSBpZiAoYyA9PT0gJy8nKSB7XG4gICAgICAgICAgICBwYXJzZXIuc3RhdGUgPSBTLk9QRU5fVEFHX1NMQVNIXG4gICAgICAgICAgfSBlbHNlIGlmIChpc01hdGNoKG5hbWVTdGFydCwgYykpIHtcbiAgICAgICAgICAgIHBhcnNlci5hdHRyaWJOYW1lID0gY1xuICAgICAgICAgICAgcGFyc2VyLmF0dHJpYlZhbHVlID0gJydcbiAgICAgICAgICAgIHBhcnNlci5zdGF0ZSA9IFMuQVRUUklCX05BTUVcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc3RyaWN0RmFpbChwYXJzZXIsICdJbnZhbGlkIGF0dHJpYnV0ZSBuYW1lJylcbiAgICAgICAgICB9XG4gICAgICAgICAgY29udGludWVcblxuICAgICAgICBjYXNlIFMuQVRUUklCX05BTUU6XG4gICAgICAgICAgaWYgKGMgPT09ICc9Jykge1xuICAgICAgICAgICAgcGFyc2VyLnN0YXRlID0gUy5BVFRSSUJfVkFMVUVcbiAgICAgICAgICB9IGVsc2UgaWYgKGMgPT09ICc+Jykge1xuICAgICAgICAgICAgc3RyaWN0RmFpbChwYXJzZXIsICdBdHRyaWJ1dGUgd2l0aG91dCB2YWx1ZScpXG4gICAgICAgICAgICBwYXJzZXIuYXR0cmliVmFsdWUgPSBwYXJzZXIuYXR0cmliTmFtZVxuICAgICAgICAgICAgYXR0cmliKHBhcnNlcilcbiAgICAgICAgICAgIG9wZW5UYWcocGFyc2VyKVxuICAgICAgICAgIH0gZWxzZSBpZiAoaXNXaGl0ZXNwYWNlKGMpKSB7XG4gICAgICAgICAgICBwYXJzZXIuc3RhdGUgPSBTLkFUVFJJQl9OQU1FX1NBV19XSElURVxuICAgICAgICAgIH0gZWxzZSBpZiAoaXNNYXRjaChuYW1lQm9keSwgYykpIHtcbiAgICAgICAgICAgIHBhcnNlci5hdHRyaWJOYW1lICs9IGNcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc3RyaWN0RmFpbChwYXJzZXIsICdJbnZhbGlkIGF0dHJpYnV0ZSBuYW1lJylcbiAgICAgICAgICB9XG4gICAgICAgICAgY29udGludWVcblxuICAgICAgICBjYXNlIFMuQVRUUklCX05BTUVfU0FXX1dISVRFOlxuICAgICAgICAgIGlmIChjID09PSAnPScpIHtcbiAgICAgICAgICAgIHBhcnNlci5zdGF0ZSA9IFMuQVRUUklCX1ZBTFVFXG4gICAgICAgICAgfSBlbHNlIGlmIChpc1doaXRlc3BhY2UoYykpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHN0cmljdEZhaWwocGFyc2VyLCAnQXR0cmlidXRlIHdpdGhvdXQgdmFsdWUnKVxuICAgICAgICAgICAgcGFyc2VyLnRhZy5hdHRyaWJ1dGVzW3BhcnNlci5hdHRyaWJOYW1lXSA9ICcnXG4gICAgICAgICAgICBwYXJzZXIuYXR0cmliVmFsdWUgPSAnJ1xuICAgICAgICAgICAgZW1pdE5vZGUocGFyc2VyLCAnb25hdHRyaWJ1dGUnLCB7XG4gICAgICAgICAgICAgIG5hbWU6IHBhcnNlci5hdHRyaWJOYW1lLFxuICAgICAgICAgICAgICB2YWx1ZTogJydcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICBwYXJzZXIuYXR0cmliTmFtZSA9ICcnXG4gICAgICAgICAgICBpZiAoYyA9PT0gJz4nKSB7XG4gICAgICAgICAgICAgIG9wZW5UYWcocGFyc2VyKVxuICAgICAgICAgICAgfSBlbHNlIGlmIChpc01hdGNoKG5hbWVTdGFydCwgYykpIHtcbiAgICAgICAgICAgICAgcGFyc2VyLmF0dHJpYk5hbWUgPSBjXG4gICAgICAgICAgICAgIHBhcnNlci5zdGF0ZSA9IFMuQVRUUklCX05BTUVcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHN0cmljdEZhaWwocGFyc2VyLCAnSW52YWxpZCBhdHRyaWJ1dGUgbmFtZScpXG4gICAgICAgICAgICAgIHBhcnNlci5zdGF0ZSA9IFMuQVRUUklCXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnRpbnVlXG5cbiAgICAgICAgY2FzZSBTLkFUVFJJQl9WQUxVRTpcbiAgICAgICAgICBpZiAoaXNXaGl0ZXNwYWNlKGMpKSB7XG4gICAgICAgICAgICBjb250aW51ZVxuICAgICAgICAgIH0gZWxzZSBpZiAoaXNRdW90ZShjKSkge1xuICAgICAgICAgICAgcGFyc2VyLnEgPSBjXG4gICAgICAgICAgICBwYXJzZXIuc3RhdGUgPSBTLkFUVFJJQl9WQUxVRV9RVU9URURcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc3RyaWN0RmFpbChwYXJzZXIsICdVbnF1b3RlZCBhdHRyaWJ1dGUgdmFsdWUnKVxuICAgICAgICAgICAgcGFyc2VyLnN0YXRlID0gUy5BVFRSSUJfVkFMVUVfVU5RVU9URURcbiAgICAgICAgICAgIHBhcnNlci5hdHRyaWJWYWx1ZSA9IGNcbiAgICAgICAgICB9XG4gICAgICAgICAgY29udGludWVcblxuICAgICAgICBjYXNlIFMuQVRUUklCX1ZBTFVFX1FVT1RFRDpcbiAgICAgICAgICBpZiAoYyAhPT0gcGFyc2VyLnEpIHtcbiAgICAgICAgICAgIGlmIChjID09PSAnJicpIHtcbiAgICAgICAgICAgICAgcGFyc2VyLnN0YXRlID0gUy5BVFRSSUJfVkFMVUVfRU5USVRZX1FcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHBhcnNlci5hdHRyaWJWYWx1ZSArPSBjXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb250aW51ZVxuICAgICAgICAgIH1cbiAgICAgICAgICBhdHRyaWIocGFyc2VyKVxuICAgICAgICAgIHBhcnNlci5xID0gJydcbiAgICAgICAgICBwYXJzZXIuc3RhdGUgPSBTLkFUVFJJQl9WQUxVRV9DTE9TRURcbiAgICAgICAgICBjb250aW51ZVxuXG4gICAgICAgIGNhc2UgUy5BVFRSSUJfVkFMVUVfQ0xPU0VEOlxuICAgICAgICAgIGlmIChpc1doaXRlc3BhY2UoYykpIHtcbiAgICAgICAgICAgIHBhcnNlci5zdGF0ZSA9IFMuQVRUUklCXG4gICAgICAgICAgfSBlbHNlIGlmIChjID09PSAnPicpIHtcbiAgICAgICAgICAgIG9wZW5UYWcocGFyc2VyKVxuICAgICAgICAgIH0gZWxzZSBpZiAoYyA9PT0gJy8nKSB7XG4gICAgICAgICAgICBwYXJzZXIuc3RhdGUgPSBTLk9QRU5fVEFHX1NMQVNIXG4gICAgICAgICAgfSBlbHNlIGlmIChpc01hdGNoKG5hbWVTdGFydCwgYykpIHtcbiAgICAgICAgICAgIHN0cmljdEZhaWwocGFyc2VyLCAnTm8gd2hpdGVzcGFjZSBiZXR3ZWVuIGF0dHJpYnV0ZXMnKVxuICAgICAgICAgICAgcGFyc2VyLmF0dHJpYk5hbWUgPSBjXG4gICAgICAgICAgICBwYXJzZXIuYXR0cmliVmFsdWUgPSAnJ1xuICAgICAgICAgICAgcGFyc2VyLnN0YXRlID0gUy5BVFRSSUJfTkFNRVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzdHJpY3RGYWlsKHBhcnNlciwgJ0ludmFsaWQgYXR0cmlidXRlIG5hbWUnKVxuICAgICAgICAgIH1cbiAgICAgICAgICBjb250aW51ZVxuXG4gICAgICAgIGNhc2UgUy5BVFRSSUJfVkFMVUVfVU5RVU9URUQ6XG4gICAgICAgICAgaWYgKCFpc0F0dHJpYkVuZChjKSkge1xuICAgICAgICAgICAgaWYgKGMgPT09ICcmJykge1xuICAgICAgICAgICAgICBwYXJzZXIuc3RhdGUgPSBTLkFUVFJJQl9WQUxVRV9FTlRJVFlfVVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgcGFyc2VyLmF0dHJpYlZhbHVlICs9IGNcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgICAgfVxuICAgICAgICAgIGF0dHJpYihwYXJzZXIpXG4gICAgICAgICAgaWYgKGMgPT09ICc+Jykge1xuICAgICAgICAgICAgb3BlblRhZyhwYXJzZXIpXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHBhcnNlci5zdGF0ZSA9IFMuQVRUUklCXG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnRpbnVlXG5cbiAgICAgICAgY2FzZSBTLkNMT1NFX1RBRzpcbiAgICAgICAgICBpZiAoIXBhcnNlci50YWdOYW1lKSB7XG4gICAgICAgICAgICBpZiAoaXNXaGl0ZXNwYWNlKGMpKSB7XG4gICAgICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgICAgICB9IGVsc2UgaWYgKG5vdE1hdGNoKG5hbWVTdGFydCwgYykpIHtcbiAgICAgICAgICAgICAgaWYgKHBhcnNlci5zY3JpcHQpIHtcbiAgICAgICAgICAgICAgICBwYXJzZXIuc2NyaXB0ICs9ICc8LycgKyBjXG4gICAgICAgICAgICAgICAgcGFyc2VyLnN0YXRlID0gUy5TQ1JJUFRcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBzdHJpY3RGYWlsKHBhcnNlciwgJ0ludmFsaWQgdGFnbmFtZSBpbiBjbG9zaW5nIHRhZy4nKVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBwYXJzZXIudGFnTmFtZSA9IGNcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2UgaWYgKGMgPT09ICc+Jykge1xuICAgICAgICAgICAgY2xvc2VUYWcocGFyc2VyKVxuICAgICAgICAgIH0gZWxzZSBpZiAoaXNNYXRjaChuYW1lQm9keSwgYykpIHtcbiAgICAgICAgICAgIHBhcnNlci50YWdOYW1lICs9IGNcbiAgICAgICAgICB9IGVsc2UgaWYgKHBhcnNlci5zY3JpcHQpIHtcbiAgICAgICAgICAgIHBhcnNlci5zY3JpcHQgKz0gJzwvJyArIHBhcnNlci50YWdOYW1lXG4gICAgICAgICAgICBwYXJzZXIudGFnTmFtZSA9ICcnXG4gICAgICAgICAgICBwYXJzZXIuc3RhdGUgPSBTLlNDUklQVFxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAoIWlzV2hpdGVzcGFjZShjKSkge1xuICAgICAgICAgICAgICBzdHJpY3RGYWlsKHBhcnNlciwgJ0ludmFsaWQgdGFnbmFtZSBpbiBjbG9zaW5nIHRhZycpXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwYXJzZXIuc3RhdGUgPSBTLkNMT1NFX1RBR19TQVdfV0hJVEVcbiAgICAgICAgICB9XG4gICAgICAgICAgY29udGludWVcblxuICAgICAgICBjYXNlIFMuQ0xPU0VfVEFHX1NBV19XSElURTpcbiAgICAgICAgICBpZiAoaXNXaGl0ZXNwYWNlKGMpKSB7XG4gICAgICAgICAgICBjb250aW51ZVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoYyA9PT0gJz4nKSB7XG4gICAgICAgICAgICBjbG9zZVRhZyhwYXJzZXIpXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHN0cmljdEZhaWwocGFyc2VyLCAnSW52YWxpZCBjaGFyYWN0ZXJzIGluIGNsb3NpbmcgdGFnJylcbiAgICAgICAgICB9XG4gICAgICAgICAgY29udGludWVcblxuICAgICAgICBjYXNlIFMuVEVYVF9FTlRJVFk6XG4gICAgICAgIGNhc2UgUy5BVFRSSUJfVkFMVUVfRU5USVRZX1E6XG4gICAgICAgIGNhc2UgUy5BVFRSSUJfVkFMVUVfRU5USVRZX1U6XG4gICAgICAgICAgdmFyIHJldHVyblN0YXRlXG4gICAgICAgICAgdmFyIGJ1ZmZlclxuICAgICAgICAgIHN3aXRjaCAocGFyc2VyLnN0YXRlKSB7XG4gICAgICAgICAgICBjYXNlIFMuVEVYVF9FTlRJVFk6XG4gICAgICAgICAgICAgIHJldHVyblN0YXRlID0gUy5URVhUXG4gICAgICAgICAgICAgIGJ1ZmZlciA9ICd0ZXh0Tm9kZSdcbiAgICAgICAgICAgICAgYnJlYWtcblxuICAgICAgICAgICAgY2FzZSBTLkFUVFJJQl9WQUxVRV9FTlRJVFlfUTpcbiAgICAgICAgICAgICAgcmV0dXJuU3RhdGUgPSBTLkFUVFJJQl9WQUxVRV9RVU9URURcbiAgICAgICAgICAgICAgYnVmZmVyID0gJ2F0dHJpYlZhbHVlJ1xuICAgICAgICAgICAgICBicmVha1xuXG4gICAgICAgICAgICBjYXNlIFMuQVRUUklCX1ZBTFVFX0VOVElUWV9VOlxuICAgICAgICAgICAgICByZXR1cm5TdGF0ZSA9IFMuQVRUUklCX1ZBTFVFX1VOUVVPVEVEXG4gICAgICAgICAgICAgIGJ1ZmZlciA9ICdhdHRyaWJWYWx1ZSdcbiAgICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoYyA9PT0gJzsnKSB7XG4gICAgICAgICAgICBwYXJzZXJbYnVmZmVyXSArPSBwYXJzZUVudGl0eShwYXJzZXIpXG4gICAgICAgICAgICBwYXJzZXIuZW50aXR5ID0gJydcbiAgICAgICAgICAgIHBhcnNlci5zdGF0ZSA9IHJldHVyblN0YXRlXG4gICAgICAgICAgfSBlbHNlIGlmIChpc01hdGNoKHBhcnNlci5lbnRpdHkubGVuZ3RoID8gZW50aXR5Qm9keSA6IGVudGl0eVN0YXJ0LCBjKSkge1xuICAgICAgICAgICAgcGFyc2VyLmVudGl0eSArPSBjXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHN0cmljdEZhaWwocGFyc2VyLCAnSW52YWxpZCBjaGFyYWN0ZXIgaW4gZW50aXR5IG5hbWUnKVxuICAgICAgICAgICAgcGFyc2VyW2J1ZmZlcl0gKz0gJyYnICsgcGFyc2VyLmVudGl0eSArIGNcbiAgICAgICAgICAgIHBhcnNlci5lbnRpdHkgPSAnJ1xuICAgICAgICAgICAgcGFyc2VyLnN0YXRlID0gcmV0dXJuU3RhdGVcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjb250aW51ZVxuXG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKHBhcnNlciwgJ1Vua25vd24gc3RhdGU6ICcgKyBwYXJzZXIuc3RhdGUpXG4gICAgICB9XG4gICAgfSAvLyB3aGlsZVxuXG4gICAgaWYgKHBhcnNlci5wb3NpdGlvbiA+PSBwYXJzZXIuYnVmZmVyQ2hlY2tQb3NpdGlvbikge1xuICAgICAgY2hlY2tCdWZmZXJMZW5ndGgocGFyc2VyKVxuICAgIH1cbiAgICByZXR1cm4gcGFyc2VyXG4gIH1cblxuICAvKiEgaHR0cDovL210aHMuYmUvZnJvbWNvZGVwb2ludCB2MC4xLjAgYnkgQG1hdGhpYXMgKi9cbiAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgaWYgKCFTdHJpbmcuZnJvbUNvZGVQb2ludCkge1xuICAgIChmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgc3RyaW5nRnJvbUNoYXJDb2RlID0gU3RyaW5nLmZyb21DaGFyQ29kZVxuICAgICAgdmFyIGZsb29yID0gTWF0aC5mbG9vclxuICAgICAgdmFyIGZyb21Db2RlUG9pbnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBNQVhfU0laRSA9IDB4NDAwMFxuICAgICAgICB2YXIgY29kZVVuaXRzID0gW11cbiAgICAgICAgdmFyIGhpZ2hTdXJyb2dhdGVcbiAgICAgICAgdmFyIGxvd1N1cnJvZ2F0ZVxuICAgICAgICB2YXIgaW5kZXggPSAtMVxuICAgICAgICB2YXIgbGVuZ3RoID0gYXJndW1lbnRzLmxlbmd0aFxuICAgICAgICBpZiAoIWxlbmd0aCkge1xuICAgICAgICAgIHJldHVybiAnJ1xuICAgICAgICB9XG4gICAgICAgIHZhciByZXN1bHQgPSAnJ1xuICAgICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICAgIHZhciBjb2RlUG9pbnQgPSBOdW1iZXIoYXJndW1lbnRzW2luZGV4XSlcbiAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAhaXNGaW5pdGUoY29kZVBvaW50KSB8fCAvLyBgTmFOYCwgYCtJbmZpbml0eWAsIG9yIGAtSW5maW5pdHlgXG4gICAgICAgICAgICBjb2RlUG9pbnQgPCAwIHx8IC8vIG5vdCBhIHZhbGlkIFVuaWNvZGUgY29kZSBwb2ludFxuICAgICAgICAgICAgY29kZVBvaW50ID4gMHgxMEZGRkYgfHwgLy8gbm90IGEgdmFsaWQgVW5pY29kZSBjb2RlIHBvaW50XG4gICAgICAgICAgICBmbG9vcihjb2RlUG9pbnQpICE9PSBjb2RlUG9pbnQgLy8gbm90IGFuIGludGVnZXJcbiAgICAgICAgICApIHtcbiAgICAgICAgICAgIHRocm93IFJhbmdlRXJyb3IoJ0ludmFsaWQgY29kZSBwb2ludDogJyArIGNvZGVQb2ludClcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGNvZGVQb2ludCA8PSAweEZGRkYpIHsgLy8gQk1QIGNvZGUgcG9pbnRcbiAgICAgICAgICAgIGNvZGVVbml0cy5wdXNoKGNvZGVQb2ludClcbiAgICAgICAgICB9IGVsc2UgeyAvLyBBc3RyYWwgY29kZSBwb2ludDsgc3BsaXQgaW4gc3Vycm9nYXRlIGhhbHZlc1xuICAgICAgICAgICAgLy8gaHR0cDovL21hdGhpYXNieW5lbnMuYmUvbm90ZXMvamF2YXNjcmlwdC1lbmNvZGluZyNzdXJyb2dhdGUtZm9ybXVsYWVcbiAgICAgICAgICAgIGNvZGVQb2ludCAtPSAweDEwMDAwXG4gICAgICAgICAgICBoaWdoU3Vycm9nYXRlID0gKGNvZGVQb2ludCA+PiAxMCkgKyAweEQ4MDBcbiAgICAgICAgICAgIGxvd1N1cnJvZ2F0ZSA9IChjb2RlUG9pbnQgJSAweDQwMCkgKyAweERDMDBcbiAgICAgICAgICAgIGNvZGVVbml0cy5wdXNoKGhpZ2hTdXJyb2dhdGUsIGxvd1N1cnJvZ2F0ZSlcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGluZGV4ICsgMSA9PT0gbGVuZ3RoIHx8IGNvZGVVbml0cy5sZW5ndGggPiBNQVhfU0laRSkge1xuICAgICAgICAgICAgcmVzdWx0ICs9IHN0cmluZ0Zyb21DaGFyQ29kZS5hcHBseShudWxsLCBjb2RlVW5pdHMpXG4gICAgICAgICAgICBjb2RlVW5pdHMubGVuZ3RoID0gMFxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0XG4gICAgICB9XG4gICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgICAgaWYgKE9iamVjdC5kZWZpbmVQcm9wZXJ0eSkge1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoU3RyaW5nLCAnZnJvbUNvZGVQb2ludCcsIHtcbiAgICAgICAgICB2YWx1ZTogZnJvbUNvZGVQb2ludCxcbiAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgd3JpdGFibGU6IHRydWVcbiAgICAgICAgfSlcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIFN0cmluZy5mcm9tQ29kZVBvaW50ID0gZnJvbUNvZGVQb2ludFxuICAgICAgfVxuICAgIH0oKSlcbiAgfVxufSkodHlwZW9mIGV4cG9ydHMgPT09ICd1bmRlZmluZWQnID8gdGhpcy5zYXggPSB7fSA6IGV4cG9ydHMpXG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvc2F4L2xpYi9zYXguanMiLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCJzdHJpbmdfZGVjb2RlclwiKTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyBleHRlcm5hbCBcInN0cmluZ19kZWNvZGVyXCJcbi8vIG1vZHVsZSBpZCA9IDEzNlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIndXNlIHN0cmljdCc7XG5cblxudmFyIGxvYWRlciA9IHJlcXVpcmUoJy4vanMteWFtbC9sb2FkZXInKTtcbnZhciBkdW1wZXIgPSByZXF1aXJlKCcuL2pzLXlhbWwvZHVtcGVyJyk7XG5cblxuZnVuY3Rpb24gZGVwcmVjYXRlZChuYW1lKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdGdW5jdGlvbiAnICsgbmFtZSArICcgaXMgZGVwcmVjYXRlZCBhbmQgY2Fubm90IGJlIHVzZWQuJyk7XG4gIH07XG59XG5cblxubW9kdWxlLmV4cG9ydHMuVHlwZSAgICAgICAgICAgICAgICA9IHJlcXVpcmUoJy4vanMteWFtbC90eXBlJyk7XG5tb2R1bGUuZXhwb3J0cy5TY2hlbWEgICAgICAgICAgICAgID0gcmVxdWlyZSgnLi9qcy15YW1sL3NjaGVtYScpO1xubW9kdWxlLmV4cG9ydHMuRkFJTFNBRkVfU0NIRU1BICAgICA9IHJlcXVpcmUoJy4vanMteWFtbC9zY2hlbWEvZmFpbHNhZmUnKTtcbm1vZHVsZS5leHBvcnRzLkpTT05fU0NIRU1BICAgICAgICAgPSByZXF1aXJlKCcuL2pzLXlhbWwvc2NoZW1hL2pzb24nKTtcbm1vZHVsZS5leHBvcnRzLkNPUkVfU0NIRU1BICAgICAgICAgPSByZXF1aXJlKCcuL2pzLXlhbWwvc2NoZW1hL2NvcmUnKTtcbm1vZHVsZS5leHBvcnRzLkRFRkFVTFRfU0FGRV9TQ0hFTUEgPSByZXF1aXJlKCcuL2pzLXlhbWwvc2NoZW1hL2RlZmF1bHRfc2FmZScpO1xubW9kdWxlLmV4cG9ydHMuREVGQVVMVF9GVUxMX1NDSEVNQSA9IHJlcXVpcmUoJy4vanMteWFtbC9zY2hlbWEvZGVmYXVsdF9mdWxsJyk7XG5tb2R1bGUuZXhwb3J0cy5sb2FkICAgICAgICAgICAgICAgID0gbG9hZGVyLmxvYWQ7XG5tb2R1bGUuZXhwb3J0cy5sb2FkQWxsICAgICAgICAgICAgID0gbG9hZGVyLmxvYWRBbGw7XG5tb2R1bGUuZXhwb3J0cy5zYWZlTG9hZCAgICAgICAgICAgID0gbG9hZGVyLnNhZmVMb2FkO1xubW9kdWxlLmV4cG9ydHMuc2FmZUxvYWRBbGwgICAgICAgICA9IGxvYWRlci5zYWZlTG9hZEFsbDtcbm1vZHVsZS5leHBvcnRzLmR1bXAgICAgICAgICAgICAgICAgPSBkdW1wZXIuZHVtcDtcbm1vZHVsZS5leHBvcnRzLnNhZmVEdW1wICAgICAgICAgICAgPSBkdW1wZXIuc2FmZUR1bXA7XG5tb2R1bGUuZXhwb3J0cy5ZQU1MRXhjZXB0aW9uICAgICAgID0gcmVxdWlyZSgnLi9qcy15YW1sL2V4Y2VwdGlvbicpO1xuXG4vLyBEZXByZWNhdGVkIHNjaGVtYSBuYW1lcyBmcm9tIEpTLVlBTUwgMi4wLnhcbm1vZHVsZS5leHBvcnRzLk1JTklNQUxfU0NIRU1BID0gcmVxdWlyZSgnLi9qcy15YW1sL3NjaGVtYS9mYWlsc2FmZScpO1xubW9kdWxlLmV4cG9ydHMuU0FGRV9TQ0hFTUEgICAgPSByZXF1aXJlKCcuL2pzLXlhbWwvc2NoZW1hL2RlZmF1bHRfc2FmZScpO1xubW9kdWxlLmV4cG9ydHMuREVGQVVMVF9TQ0hFTUEgPSByZXF1aXJlKCcuL2pzLXlhbWwvc2NoZW1hL2RlZmF1bHRfZnVsbCcpO1xuXG4vLyBEZXByZWNhdGVkIGZ1bmN0aW9ucyBmcm9tIEpTLVlBTUwgMS54Lnhcbm1vZHVsZS5leHBvcnRzLnNjYW4gICAgICAgICAgID0gZGVwcmVjYXRlZCgnc2NhbicpO1xubW9kdWxlLmV4cG9ydHMucGFyc2UgICAgICAgICAgPSBkZXByZWNhdGVkKCdwYXJzZScpO1xubW9kdWxlLmV4cG9ydHMuY29tcG9zZSAgICAgICAgPSBkZXByZWNhdGVkKCdjb21wb3NlJyk7XG5tb2R1bGUuZXhwb3J0cy5hZGRDb25zdHJ1Y3RvciA9IGRlcHJlY2F0ZWQoJ2FkZENvbnN0cnVjdG9yJyk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvanMteWFtbC9saWIvanMteWFtbC5qcyIsIid1c2Ugc3RyaWN0JztcblxuLyplc2xpbnQtZGlzYWJsZSBtYXgtbGVuLG5vLXVzZS1iZWZvcmUtZGVmaW5lKi9cblxudmFyIGNvbW1vbiAgICAgICAgICAgICAgPSByZXF1aXJlKCcuL2NvbW1vbicpO1xudmFyIFlBTUxFeGNlcHRpb24gICAgICAgPSByZXF1aXJlKCcuL2V4Y2VwdGlvbicpO1xudmFyIE1hcmsgICAgICAgICAgICAgICAgPSByZXF1aXJlKCcuL21hcmsnKTtcbnZhciBERUZBVUxUX1NBRkVfU0NIRU1BID0gcmVxdWlyZSgnLi9zY2hlbWEvZGVmYXVsdF9zYWZlJyk7XG52YXIgREVGQVVMVF9GVUxMX1NDSEVNQSA9IHJlcXVpcmUoJy4vc2NoZW1hL2RlZmF1bHRfZnVsbCcpO1xuXG5cbnZhciBfaGFzT3duUHJvcGVydHkgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xuXG5cbnZhciBDT05URVhUX0ZMT1dfSU4gICA9IDE7XG52YXIgQ09OVEVYVF9GTE9XX09VVCAgPSAyO1xudmFyIENPTlRFWFRfQkxPQ0tfSU4gID0gMztcbnZhciBDT05URVhUX0JMT0NLX09VVCA9IDQ7XG5cblxudmFyIENIT01QSU5HX0NMSVAgID0gMTtcbnZhciBDSE9NUElOR19TVFJJUCA9IDI7XG52YXIgQ0hPTVBJTkdfS0VFUCAgPSAzO1xuXG5cbnZhciBQQVRURVJOX05PTl9QUklOVEFCTEUgICAgICAgICA9IC9bXFx4MDAtXFx4MDhcXHgwQlxceDBDXFx4MEUtXFx4MUZcXHg3Ri1cXHg4NFxceDg2LVxceDlGXFx1RkZGRVxcdUZGRkZdfFtcXHVEODAwLVxcdURCRkZdKD8hW1xcdURDMDAtXFx1REZGRl0pfCg/OlteXFx1RDgwMC1cXHVEQkZGXXxeKVtcXHVEQzAwLVxcdURGRkZdLztcbnZhciBQQVRURVJOX05PTl9BU0NJSV9MSU5FX0JSRUFLUyA9IC9bXFx4ODVcXHUyMDI4XFx1MjAyOV0vO1xudmFyIFBBVFRFUk5fRkxPV19JTkRJQ0FUT1JTICAgICAgID0gL1ssXFxbXFxdXFx7XFx9XS87XG52YXIgUEFUVEVSTl9UQUdfSEFORExFICAgICAgICAgICAgPSAvXig/OiF8ISF8IVthLXpcXC1dKyEpJC9pO1xudmFyIFBBVFRFUk5fVEFHX1VSSSAgICAgICAgICAgICAgID0gL14oPzohfFteLFxcW1xcXVxce1xcfV0pKD86JVswLTlhLWZdezJ9fFswLTlhLXpcXC0jO1xcL1xcPzpAJj1cXCtcXCQsX1xcLiF+XFwqJ1xcKFxcKVxcW1xcXV0pKiQvaTtcblxuXG5mdW5jdGlvbiBpc19FT0woYykge1xuICByZXR1cm4gKGMgPT09IDB4MEEvKiBMRiAqLykgfHwgKGMgPT09IDB4MEQvKiBDUiAqLyk7XG59XG5cbmZ1bmN0aW9uIGlzX1dISVRFX1NQQUNFKGMpIHtcbiAgcmV0dXJuIChjID09PSAweDA5LyogVGFiICovKSB8fCAoYyA9PT0gMHgyMC8qIFNwYWNlICovKTtcbn1cblxuZnVuY3Rpb24gaXNfV1NfT1JfRU9MKGMpIHtcbiAgcmV0dXJuIChjID09PSAweDA5LyogVGFiICovKSB8fFxuICAgICAgICAgKGMgPT09IDB4MjAvKiBTcGFjZSAqLykgfHxcbiAgICAgICAgIChjID09PSAweDBBLyogTEYgKi8pIHx8XG4gICAgICAgICAoYyA9PT0gMHgwRC8qIENSICovKTtcbn1cblxuZnVuY3Rpb24gaXNfRkxPV19JTkRJQ0FUT1IoYykge1xuICByZXR1cm4gYyA9PT0gMHgyQy8qICwgKi8gfHxcbiAgICAgICAgIGMgPT09IDB4NUIvKiBbICovIHx8XG4gICAgICAgICBjID09PSAweDVELyogXSAqLyB8fFxuICAgICAgICAgYyA9PT0gMHg3Qi8qIHsgKi8gfHxcbiAgICAgICAgIGMgPT09IDB4N0QvKiB9ICovO1xufVxuXG5mdW5jdGlvbiBmcm9tSGV4Q29kZShjKSB7XG4gIHZhciBsYztcblxuICBpZiAoKDB4MzAvKiAwICovIDw9IGMpICYmIChjIDw9IDB4MzkvKiA5ICovKSkge1xuICAgIHJldHVybiBjIC0gMHgzMDtcbiAgfVxuXG4gIC8qZXNsaW50LWRpc2FibGUgbm8tYml0d2lzZSovXG4gIGxjID0gYyB8IDB4MjA7XG5cbiAgaWYgKCgweDYxLyogYSAqLyA8PSBsYykgJiYgKGxjIDw9IDB4NjYvKiBmICovKSkge1xuICAgIHJldHVybiBsYyAtIDB4NjEgKyAxMDtcbiAgfVxuXG4gIHJldHVybiAtMTtcbn1cblxuZnVuY3Rpb24gZXNjYXBlZEhleExlbihjKSB7XG4gIGlmIChjID09PSAweDc4LyogeCAqLykgeyByZXR1cm4gMjsgfVxuICBpZiAoYyA9PT0gMHg3NS8qIHUgKi8pIHsgcmV0dXJuIDQ7IH1cbiAgaWYgKGMgPT09IDB4NTUvKiBVICovKSB7IHJldHVybiA4OyB9XG4gIHJldHVybiAwO1xufVxuXG5mdW5jdGlvbiBmcm9tRGVjaW1hbENvZGUoYykge1xuICBpZiAoKDB4MzAvKiAwICovIDw9IGMpICYmIChjIDw9IDB4MzkvKiA5ICovKSkge1xuICAgIHJldHVybiBjIC0gMHgzMDtcbiAgfVxuXG4gIHJldHVybiAtMTtcbn1cblxuZnVuY3Rpb24gc2ltcGxlRXNjYXBlU2VxdWVuY2UoYykge1xuICAvKiBlc2xpbnQtZGlzYWJsZSBpbmRlbnQgKi9cbiAgcmV0dXJuIChjID09PSAweDMwLyogMCAqLykgPyAnXFx4MDAnIDpcbiAgICAgICAgKGMgPT09IDB4NjEvKiBhICovKSA/ICdcXHgwNycgOlxuICAgICAgICAoYyA9PT0gMHg2Mi8qIGIgKi8pID8gJ1xceDA4JyA6XG4gICAgICAgIChjID09PSAweDc0LyogdCAqLykgPyAnXFx4MDknIDpcbiAgICAgICAgKGMgPT09IDB4MDkvKiBUYWIgKi8pID8gJ1xceDA5JyA6XG4gICAgICAgIChjID09PSAweDZFLyogbiAqLykgPyAnXFx4MEEnIDpcbiAgICAgICAgKGMgPT09IDB4NzYvKiB2ICovKSA/ICdcXHgwQicgOlxuICAgICAgICAoYyA9PT0gMHg2Ni8qIGYgKi8pID8gJ1xceDBDJyA6XG4gICAgICAgIChjID09PSAweDcyLyogciAqLykgPyAnXFx4MEQnIDpcbiAgICAgICAgKGMgPT09IDB4NjUvKiBlICovKSA/ICdcXHgxQicgOlxuICAgICAgICAoYyA9PT0gMHgyMC8qIFNwYWNlICovKSA/ICcgJyA6XG4gICAgICAgIChjID09PSAweDIyLyogXCIgKi8pID8gJ1xceDIyJyA6XG4gICAgICAgIChjID09PSAweDJGLyogLyAqLykgPyAnLycgOlxuICAgICAgICAoYyA9PT0gMHg1Qy8qIFxcICovKSA/ICdcXHg1QycgOlxuICAgICAgICAoYyA9PT0gMHg0RS8qIE4gKi8pID8gJ1xceDg1JyA6XG4gICAgICAgIChjID09PSAweDVGLyogXyAqLykgPyAnXFx4QTAnIDpcbiAgICAgICAgKGMgPT09IDB4NEMvKiBMICovKSA/ICdcXHUyMDI4JyA6XG4gICAgICAgIChjID09PSAweDUwLyogUCAqLykgPyAnXFx1MjAyOScgOiAnJztcbn1cblxuZnVuY3Rpb24gY2hhckZyb21Db2RlcG9pbnQoYykge1xuICBpZiAoYyA8PSAweEZGRkYpIHtcbiAgICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZShjKTtcbiAgfVxuICAvLyBFbmNvZGUgVVRGLTE2IHN1cnJvZ2F0ZSBwYWlyXG4gIC8vIGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL1VURi0xNiNDb2RlX3BvaW50c19VLjJCMDEwMDAwX3RvX1UuMkIxMEZGRkZcbiAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUoXG4gICAgKChjIC0gMHgwMTAwMDApID4+IDEwKSArIDB4RDgwMCxcbiAgICAoKGMgLSAweDAxMDAwMCkgJiAweDAzRkYpICsgMHhEQzAwXG4gICk7XG59XG5cbnZhciBzaW1wbGVFc2NhcGVDaGVjayA9IG5ldyBBcnJheSgyNTYpOyAvLyBpbnRlZ2VyLCBmb3IgZmFzdCBhY2Nlc3NcbnZhciBzaW1wbGVFc2NhcGVNYXAgPSBuZXcgQXJyYXkoMjU2KTtcbmZvciAodmFyIGkgPSAwOyBpIDwgMjU2OyBpKyspIHtcbiAgc2ltcGxlRXNjYXBlQ2hlY2tbaV0gPSBzaW1wbGVFc2NhcGVTZXF1ZW5jZShpKSA/IDEgOiAwO1xuICBzaW1wbGVFc2NhcGVNYXBbaV0gPSBzaW1wbGVFc2NhcGVTZXF1ZW5jZShpKTtcbn1cblxuXG5mdW5jdGlvbiBTdGF0ZShpbnB1dCwgb3B0aW9ucykge1xuICB0aGlzLmlucHV0ID0gaW5wdXQ7XG5cbiAgdGhpcy5maWxlbmFtZSAgPSBvcHRpb25zWydmaWxlbmFtZSddICB8fCBudWxsO1xuICB0aGlzLnNjaGVtYSAgICA9IG9wdGlvbnNbJ3NjaGVtYSddICAgIHx8IERFRkFVTFRfRlVMTF9TQ0hFTUE7XG4gIHRoaXMub25XYXJuaW5nID0gb3B0aW9uc1snb25XYXJuaW5nJ10gfHwgbnVsbDtcbiAgdGhpcy5sZWdhY3kgICAgPSBvcHRpb25zWydsZWdhY3knXSAgICB8fCBmYWxzZTtcbiAgdGhpcy5qc29uICAgICAgPSBvcHRpb25zWydqc29uJ10gICAgICB8fCBmYWxzZTtcbiAgdGhpcy5saXN0ZW5lciAgPSBvcHRpb25zWydsaXN0ZW5lciddICB8fCBudWxsO1xuXG4gIHRoaXMuaW1wbGljaXRUeXBlcyA9IHRoaXMuc2NoZW1hLmNvbXBpbGVkSW1wbGljaXQ7XG4gIHRoaXMudHlwZU1hcCAgICAgICA9IHRoaXMuc2NoZW1hLmNvbXBpbGVkVHlwZU1hcDtcblxuICB0aGlzLmxlbmd0aCAgICAgPSBpbnB1dC5sZW5ndGg7XG4gIHRoaXMucG9zaXRpb24gICA9IDA7XG4gIHRoaXMubGluZSAgICAgICA9IDA7XG4gIHRoaXMubGluZVN0YXJ0ICA9IDA7XG4gIHRoaXMubGluZUluZGVudCA9IDA7XG5cbiAgdGhpcy5kb2N1bWVudHMgPSBbXTtcblxuICAvKlxuICB0aGlzLnZlcnNpb247XG4gIHRoaXMuY2hlY2tMaW5lQnJlYWtzO1xuICB0aGlzLnRhZ01hcDtcbiAgdGhpcy5hbmNob3JNYXA7XG4gIHRoaXMudGFnO1xuICB0aGlzLmFuY2hvcjtcbiAgdGhpcy5raW5kO1xuICB0aGlzLnJlc3VsdDsqL1xuXG59XG5cblxuZnVuY3Rpb24gZ2VuZXJhdGVFcnJvcihzdGF0ZSwgbWVzc2FnZSkge1xuICByZXR1cm4gbmV3IFlBTUxFeGNlcHRpb24oXG4gICAgbWVzc2FnZSxcbiAgICBuZXcgTWFyayhzdGF0ZS5maWxlbmFtZSwgc3RhdGUuaW5wdXQsIHN0YXRlLnBvc2l0aW9uLCBzdGF0ZS5saW5lLCAoc3RhdGUucG9zaXRpb24gLSBzdGF0ZS5saW5lU3RhcnQpKSk7XG59XG5cbmZ1bmN0aW9uIHRocm93RXJyb3Ioc3RhdGUsIG1lc3NhZ2UpIHtcbiAgdGhyb3cgZ2VuZXJhdGVFcnJvcihzdGF0ZSwgbWVzc2FnZSk7XG59XG5cbmZ1bmN0aW9uIHRocm93V2FybmluZyhzdGF0ZSwgbWVzc2FnZSkge1xuICBpZiAoc3RhdGUub25XYXJuaW5nKSB7XG4gICAgc3RhdGUub25XYXJuaW5nLmNhbGwobnVsbCwgZ2VuZXJhdGVFcnJvcihzdGF0ZSwgbWVzc2FnZSkpO1xuICB9XG59XG5cblxudmFyIGRpcmVjdGl2ZUhhbmRsZXJzID0ge1xuXG4gIFlBTUw6IGZ1bmN0aW9uIGhhbmRsZVlhbWxEaXJlY3RpdmUoc3RhdGUsIG5hbWUsIGFyZ3MpIHtcblxuICAgIHZhciBtYXRjaCwgbWFqb3IsIG1pbm9yO1xuXG4gICAgaWYgKHN0YXRlLnZlcnNpb24gIT09IG51bGwpIHtcbiAgICAgIHRocm93RXJyb3Ioc3RhdGUsICdkdXBsaWNhdGlvbiBvZiAlWUFNTCBkaXJlY3RpdmUnKTtcbiAgICB9XG5cbiAgICBpZiAoYXJncy5sZW5ndGggIT09IDEpIHtcbiAgICAgIHRocm93RXJyb3Ioc3RhdGUsICdZQU1MIGRpcmVjdGl2ZSBhY2NlcHRzIGV4YWN0bHkgb25lIGFyZ3VtZW50Jyk7XG4gICAgfVxuXG4gICAgbWF0Y2ggPSAvXihbMC05XSspXFwuKFswLTldKykkLy5leGVjKGFyZ3NbMF0pO1xuXG4gICAgaWYgKG1hdGNoID09PSBudWxsKSB7XG4gICAgICB0aHJvd0Vycm9yKHN0YXRlLCAnaWxsLWZvcm1lZCBhcmd1bWVudCBvZiB0aGUgWUFNTCBkaXJlY3RpdmUnKTtcbiAgICB9XG5cbiAgICBtYWpvciA9IHBhcnNlSW50KG1hdGNoWzFdLCAxMCk7XG4gICAgbWlub3IgPSBwYXJzZUludChtYXRjaFsyXSwgMTApO1xuXG4gICAgaWYgKG1ham9yICE9PSAxKSB7XG4gICAgICB0aHJvd0Vycm9yKHN0YXRlLCAndW5hY2NlcHRhYmxlIFlBTUwgdmVyc2lvbiBvZiB0aGUgZG9jdW1lbnQnKTtcbiAgICB9XG5cbiAgICBzdGF0ZS52ZXJzaW9uID0gYXJnc1swXTtcbiAgICBzdGF0ZS5jaGVja0xpbmVCcmVha3MgPSAobWlub3IgPCAyKTtcblxuICAgIGlmIChtaW5vciAhPT0gMSAmJiBtaW5vciAhPT0gMikge1xuICAgICAgdGhyb3dXYXJuaW5nKHN0YXRlLCAndW5zdXBwb3J0ZWQgWUFNTCB2ZXJzaW9uIG9mIHRoZSBkb2N1bWVudCcpO1xuICAgIH1cbiAgfSxcblxuICBUQUc6IGZ1bmN0aW9uIGhhbmRsZVRhZ0RpcmVjdGl2ZShzdGF0ZSwgbmFtZSwgYXJncykge1xuXG4gICAgdmFyIGhhbmRsZSwgcHJlZml4O1xuXG4gICAgaWYgKGFyZ3MubGVuZ3RoICE9PSAyKSB7XG4gICAgICB0aHJvd0Vycm9yKHN0YXRlLCAnVEFHIGRpcmVjdGl2ZSBhY2NlcHRzIGV4YWN0bHkgdHdvIGFyZ3VtZW50cycpO1xuICAgIH1cblxuICAgIGhhbmRsZSA9IGFyZ3NbMF07XG4gICAgcHJlZml4ID0gYXJnc1sxXTtcblxuICAgIGlmICghUEFUVEVSTl9UQUdfSEFORExFLnRlc3QoaGFuZGxlKSkge1xuICAgICAgdGhyb3dFcnJvcihzdGF0ZSwgJ2lsbC1mb3JtZWQgdGFnIGhhbmRsZSAoZmlyc3QgYXJndW1lbnQpIG9mIHRoZSBUQUcgZGlyZWN0aXZlJyk7XG4gICAgfVxuXG4gICAgaWYgKF9oYXNPd25Qcm9wZXJ0eS5jYWxsKHN0YXRlLnRhZ01hcCwgaGFuZGxlKSkge1xuICAgICAgdGhyb3dFcnJvcihzdGF0ZSwgJ3RoZXJlIGlzIGEgcHJldmlvdXNseSBkZWNsYXJlZCBzdWZmaXggZm9yIFwiJyArIGhhbmRsZSArICdcIiB0YWcgaGFuZGxlJyk7XG4gICAgfVxuXG4gICAgaWYgKCFQQVRURVJOX1RBR19VUkkudGVzdChwcmVmaXgpKSB7XG4gICAgICB0aHJvd0Vycm9yKHN0YXRlLCAnaWxsLWZvcm1lZCB0YWcgcHJlZml4IChzZWNvbmQgYXJndW1lbnQpIG9mIHRoZSBUQUcgZGlyZWN0aXZlJyk7XG4gICAgfVxuXG4gICAgc3RhdGUudGFnTWFwW2hhbmRsZV0gPSBwcmVmaXg7XG4gIH1cbn07XG5cblxuZnVuY3Rpb24gY2FwdHVyZVNlZ21lbnQoc3RhdGUsIHN0YXJ0LCBlbmQsIGNoZWNrSnNvbikge1xuICB2YXIgX3Bvc2l0aW9uLCBfbGVuZ3RoLCBfY2hhcmFjdGVyLCBfcmVzdWx0O1xuXG4gIGlmIChzdGFydCA8IGVuZCkge1xuICAgIF9yZXN1bHQgPSBzdGF0ZS5pbnB1dC5zbGljZShzdGFydCwgZW5kKTtcblxuICAgIGlmIChjaGVja0pzb24pIHtcbiAgICAgIGZvciAoX3Bvc2l0aW9uID0gMCwgX2xlbmd0aCA9IF9yZXN1bHQubGVuZ3RoOyBfcG9zaXRpb24gPCBfbGVuZ3RoOyBfcG9zaXRpb24gKz0gMSkge1xuICAgICAgICBfY2hhcmFjdGVyID0gX3Jlc3VsdC5jaGFyQ29kZUF0KF9wb3NpdGlvbik7XG4gICAgICAgIGlmICghKF9jaGFyYWN0ZXIgPT09IDB4MDkgfHxcbiAgICAgICAgICAgICAgKDB4MjAgPD0gX2NoYXJhY3RlciAmJiBfY2hhcmFjdGVyIDw9IDB4MTBGRkZGKSkpIHtcbiAgICAgICAgICB0aHJvd0Vycm9yKHN0YXRlLCAnZXhwZWN0ZWQgdmFsaWQgSlNPTiBjaGFyYWN0ZXInKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoUEFUVEVSTl9OT05fUFJJTlRBQkxFLnRlc3QoX3Jlc3VsdCkpIHtcbiAgICAgIHRocm93RXJyb3Ioc3RhdGUsICd0aGUgc3RyZWFtIGNvbnRhaW5zIG5vbi1wcmludGFibGUgY2hhcmFjdGVycycpO1xuICAgIH1cblxuICAgIHN0YXRlLnJlc3VsdCArPSBfcmVzdWx0O1xuICB9XG59XG5cbmZ1bmN0aW9uIG1lcmdlTWFwcGluZ3Moc3RhdGUsIGRlc3RpbmF0aW9uLCBzb3VyY2UsIG92ZXJyaWRhYmxlS2V5cykge1xuICB2YXIgc291cmNlS2V5cywga2V5LCBpbmRleCwgcXVhbnRpdHk7XG5cbiAgaWYgKCFjb21tb24uaXNPYmplY3Qoc291cmNlKSkge1xuICAgIHRocm93RXJyb3Ioc3RhdGUsICdjYW5ub3QgbWVyZ2UgbWFwcGluZ3M7IHRoZSBwcm92aWRlZCBzb3VyY2Ugb2JqZWN0IGlzIHVuYWNjZXB0YWJsZScpO1xuICB9XG5cbiAgc291cmNlS2V5cyA9IE9iamVjdC5rZXlzKHNvdXJjZSk7XG5cbiAgZm9yIChpbmRleCA9IDAsIHF1YW50aXR5ID0gc291cmNlS2V5cy5sZW5ndGg7IGluZGV4IDwgcXVhbnRpdHk7IGluZGV4ICs9IDEpIHtcbiAgICBrZXkgPSBzb3VyY2VLZXlzW2luZGV4XTtcblxuICAgIGlmICghX2hhc093blByb3BlcnR5LmNhbGwoZGVzdGluYXRpb24sIGtleSkpIHtcbiAgICAgIGRlc3RpbmF0aW9uW2tleV0gPSBzb3VyY2Vba2V5XTtcbiAgICAgIG92ZXJyaWRhYmxlS2V5c1trZXldID0gdHJ1ZTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gc3RvcmVNYXBwaW5nUGFpcihzdGF0ZSwgX3Jlc3VsdCwgb3ZlcnJpZGFibGVLZXlzLCBrZXlUYWcsIGtleU5vZGUsIHZhbHVlTm9kZSwgc3RhcnRMaW5lLCBzdGFydFBvcykge1xuICB2YXIgaW5kZXgsIHF1YW50aXR5O1xuXG4gIGtleU5vZGUgPSBTdHJpbmcoa2V5Tm9kZSk7XG5cbiAgaWYgKF9yZXN1bHQgPT09IG51bGwpIHtcbiAgICBfcmVzdWx0ID0ge307XG4gIH1cblxuICBpZiAoa2V5VGFnID09PSAndGFnOnlhbWwub3JnLDIwMDI6bWVyZ2UnKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWVOb2RlKSkge1xuICAgICAgZm9yIChpbmRleCA9IDAsIHF1YW50aXR5ID0gdmFsdWVOb2RlLmxlbmd0aDsgaW5kZXggPCBxdWFudGl0eTsgaW5kZXggKz0gMSkge1xuICAgICAgICBtZXJnZU1hcHBpbmdzKHN0YXRlLCBfcmVzdWx0LCB2YWx1ZU5vZGVbaW5kZXhdLCBvdmVycmlkYWJsZUtleXMpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBtZXJnZU1hcHBpbmdzKHN0YXRlLCBfcmVzdWx0LCB2YWx1ZU5vZGUsIG92ZXJyaWRhYmxlS2V5cyk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGlmICghc3RhdGUuanNvbiAmJlxuICAgICAgICAhX2hhc093blByb3BlcnR5LmNhbGwob3ZlcnJpZGFibGVLZXlzLCBrZXlOb2RlKSAmJlxuICAgICAgICBfaGFzT3duUHJvcGVydHkuY2FsbChfcmVzdWx0LCBrZXlOb2RlKSkge1xuICAgICAgc3RhdGUubGluZSA9IHN0YXJ0TGluZSB8fCBzdGF0ZS5saW5lO1xuICAgICAgc3RhdGUucG9zaXRpb24gPSBzdGFydFBvcyB8fCBzdGF0ZS5wb3NpdGlvbjtcbiAgICAgIHRocm93RXJyb3Ioc3RhdGUsICdkdXBsaWNhdGVkIG1hcHBpbmcga2V5Jyk7XG4gICAgfVxuICAgIF9yZXN1bHRba2V5Tm9kZV0gPSB2YWx1ZU5vZGU7XG4gICAgZGVsZXRlIG92ZXJyaWRhYmxlS2V5c1trZXlOb2RlXTtcbiAgfVxuXG4gIHJldHVybiBfcmVzdWx0O1xufVxuXG5mdW5jdGlvbiByZWFkTGluZUJyZWFrKHN0YXRlKSB7XG4gIHZhciBjaDtcblxuICBjaCA9IHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoc3RhdGUucG9zaXRpb24pO1xuXG4gIGlmIChjaCA9PT0gMHgwQS8qIExGICovKSB7XG4gICAgc3RhdGUucG9zaXRpb24rKztcbiAgfSBlbHNlIGlmIChjaCA9PT0gMHgwRC8qIENSICovKSB7XG4gICAgc3RhdGUucG9zaXRpb24rKztcbiAgICBpZiAoc3RhdGUuaW5wdXQuY2hhckNvZGVBdChzdGF0ZS5wb3NpdGlvbikgPT09IDB4MEEvKiBMRiAqLykge1xuICAgICAgc3RhdGUucG9zaXRpb24rKztcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdGhyb3dFcnJvcihzdGF0ZSwgJ2EgbGluZSBicmVhayBpcyBleHBlY3RlZCcpO1xuICB9XG5cbiAgc3RhdGUubGluZSArPSAxO1xuICBzdGF0ZS5saW5lU3RhcnQgPSBzdGF0ZS5wb3NpdGlvbjtcbn1cblxuZnVuY3Rpb24gc2tpcFNlcGFyYXRpb25TcGFjZShzdGF0ZSwgYWxsb3dDb21tZW50cywgY2hlY2tJbmRlbnQpIHtcbiAgdmFyIGxpbmVCcmVha3MgPSAwLFxuICAgICAgY2ggPSBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KHN0YXRlLnBvc2l0aW9uKTtcblxuICB3aGlsZSAoY2ggIT09IDApIHtcbiAgICB3aGlsZSAoaXNfV0hJVEVfU1BBQ0UoY2gpKSB7XG4gICAgICBjaCA9IHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoKytzdGF0ZS5wb3NpdGlvbik7XG4gICAgfVxuXG4gICAgaWYgKGFsbG93Q29tbWVudHMgJiYgY2ggPT09IDB4MjMvKiAjICovKSB7XG4gICAgICBkbyB7XG4gICAgICAgIGNoID0gc3RhdGUuaW5wdXQuY2hhckNvZGVBdCgrK3N0YXRlLnBvc2l0aW9uKTtcbiAgICAgIH0gd2hpbGUgKGNoICE9PSAweDBBLyogTEYgKi8gJiYgY2ggIT09IDB4MEQvKiBDUiAqLyAmJiBjaCAhPT0gMCk7XG4gICAgfVxuXG4gICAgaWYgKGlzX0VPTChjaCkpIHtcbiAgICAgIHJlYWRMaW5lQnJlYWsoc3RhdGUpO1xuXG4gICAgICBjaCA9IHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoc3RhdGUucG9zaXRpb24pO1xuICAgICAgbGluZUJyZWFrcysrO1xuICAgICAgc3RhdGUubGluZUluZGVudCA9IDA7XG5cbiAgICAgIHdoaWxlIChjaCA9PT0gMHgyMC8qIFNwYWNlICovKSB7XG4gICAgICAgIHN0YXRlLmxpbmVJbmRlbnQrKztcbiAgICAgICAgY2ggPSBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KCsrc3RhdGUucG9zaXRpb24pO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cblxuICBpZiAoY2hlY2tJbmRlbnQgIT09IC0xICYmIGxpbmVCcmVha3MgIT09IDAgJiYgc3RhdGUubGluZUluZGVudCA8IGNoZWNrSW5kZW50KSB7XG4gICAgdGhyb3dXYXJuaW5nKHN0YXRlLCAnZGVmaWNpZW50IGluZGVudGF0aW9uJyk7XG4gIH1cblxuICByZXR1cm4gbGluZUJyZWFrcztcbn1cblxuZnVuY3Rpb24gdGVzdERvY3VtZW50U2VwYXJhdG9yKHN0YXRlKSB7XG4gIHZhciBfcG9zaXRpb24gPSBzdGF0ZS5wb3NpdGlvbixcbiAgICAgIGNoO1xuXG4gIGNoID0gc3RhdGUuaW5wdXQuY2hhckNvZGVBdChfcG9zaXRpb24pO1xuXG4gIC8vIENvbmRpdGlvbiBzdGF0ZS5wb3NpdGlvbiA9PT0gc3RhdGUubGluZVN0YXJ0IGlzIHRlc3RlZFxuICAvLyBpbiBwYXJlbnQgb24gZWFjaCBjYWxsLCBmb3IgZWZmaWNpZW5jeS4gTm8gbmVlZHMgdG8gdGVzdCBoZXJlIGFnYWluLlxuICBpZiAoKGNoID09PSAweDJELyogLSAqLyB8fCBjaCA9PT0gMHgyRS8qIC4gKi8pICYmXG4gICAgICBjaCA9PT0gc3RhdGUuaW5wdXQuY2hhckNvZGVBdChfcG9zaXRpb24gKyAxKSAmJlxuICAgICAgY2ggPT09IHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoX3Bvc2l0aW9uICsgMikpIHtcblxuICAgIF9wb3NpdGlvbiArPSAzO1xuXG4gICAgY2ggPSBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KF9wb3NpdGlvbik7XG5cbiAgICBpZiAoY2ggPT09IDAgfHwgaXNfV1NfT1JfRU9MKGNoKSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiB3cml0ZUZvbGRlZExpbmVzKHN0YXRlLCBjb3VudCkge1xuICBpZiAoY291bnQgPT09IDEpIHtcbiAgICBzdGF0ZS5yZXN1bHQgKz0gJyAnO1xuICB9IGVsc2UgaWYgKGNvdW50ID4gMSkge1xuICAgIHN0YXRlLnJlc3VsdCArPSBjb21tb24ucmVwZWF0KCdcXG4nLCBjb3VudCAtIDEpO1xuICB9XG59XG5cblxuZnVuY3Rpb24gcmVhZFBsYWluU2NhbGFyKHN0YXRlLCBub2RlSW5kZW50LCB3aXRoaW5GbG93Q29sbGVjdGlvbikge1xuICB2YXIgcHJlY2VkaW5nLFxuICAgICAgZm9sbG93aW5nLFxuICAgICAgY2FwdHVyZVN0YXJ0LFxuICAgICAgY2FwdHVyZUVuZCxcbiAgICAgIGhhc1BlbmRpbmdDb250ZW50LFxuICAgICAgX2xpbmUsXG4gICAgICBfbGluZVN0YXJ0LFxuICAgICAgX2xpbmVJbmRlbnQsXG4gICAgICBfa2luZCA9IHN0YXRlLmtpbmQsXG4gICAgICBfcmVzdWx0ID0gc3RhdGUucmVzdWx0LFxuICAgICAgY2g7XG5cbiAgY2ggPSBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KHN0YXRlLnBvc2l0aW9uKTtcblxuICBpZiAoaXNfV1NfT1JfRU9MKGNoKSAgICAgIHx8XG4gICAgICBpc19GTE9XX0lORElDQVRPUihjaCkgfHxcbiAgICAgIGNoID09PSAweDIzLyogIyAqLyAgICB8fFxuICAgICAgY2ggPT09IDB4MjYvKiAmICovICAgIHx8XG4gICAgICBjaCA9PT0gMHgyQS8qICogKi8gICAgfHxcbiAgICAgIGNoID09PSAweDIxLyogISAqLyAgICB8fFxuICAgICAgY2ggPT09IDB4N0MvKiB8ICovICAgIHx8XG4gICAgICBjaCA9PT0gMHgzRS8qID4gKi8gICAgfHxcbiAgICAgIGNoID09PSAweDI3LyogJyAqLyAgICB8fFxuICAgICAgY2ggPT09IDB4MjIvKiBcIiAqLyAgICB8fFxuICAgICAgY2ggPT09IDB4MjUvKiAlICovICAgIHx8XG4gICAgICBjaCA9PT0gMHg0MC8qIEAgKi8gICAgfHxcbiAgICAgIGNoID09PSAweDYwLyogYCAqLykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGlmIChjaCA9PT0gMHgzRi8qID8gKi8gfHwgY2ggPT09IDB4MkQvKiAtICovKSB7XG4gICAgZm9sbG93aW5nID0gc3RhdGUuaW5wdXQuY2hhckNvZGVBdChzdGF0ZS5wb3NpdGlvbiArIDEpO1xuXG4gICAgaWYgKGlzX1dTX09SX0VPTChmb2xsb3dpbmcpIHx8XG4gICAgICAgIHdpdGhpbkZsb3dDb2xsZWN0aW9uICYmIGlzX0ZMT1dfSU5ESUNBVE9SKGZvbGxvd2luZykpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cblxuICBzdGF0ZS5raW5kID0gJ3NjYWxhcic7XG4gIHN0YXRlLnJlc3VsdCA9ICcnO1xuICBjYXB0dXJlU3RhcnQgPSBjYXB0dXJlRW5kID0gc3RhdGUucG9zaXRpb247XG4gIGhhc1BlbmRpbmdDb250ZW50ID0gZmFsc2U7XG5cbiAgd2hpbGUgKGNoICE9PSAwKSB7XG4gICAgaWYgKGNoID09PSAweDNBLyogOiAqLykge1xuICAgICAgZm9sbG93aW5nID0gc3RhdGUuaW5wdXQuY2hhckNvZGVBdChzdGF0ZS5wb3NpdGlvbiArIDEpO1xuXG4gICAgICBpZiAoaXNfV1NfT1JfRU9MKGZvbGxvd2luZykgfHxcbiAgICAgICAgICB3aXRoaW5GbG93Q29sbGVjdGlvbiAmJiBpc19GTE9XX0lORElDQVRPUihmb2xsb3dpbmcpKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgfSBlbHNlIGlmIChjaCA9PT0gMHgyMy8qICMgKi8pIHtcbiAgICAgIHByZWNlZGluZyA9IHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoc3RhdGUucG9zaXRpb24gLSAxKTtcblxuICAgICAgaWYgKGlzX1dTX09SX0VPTChwcmVjZWRpbmcpKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgfSBlbHNlIGlmICgoc3RhdGUucG9zaXRpb24gPT09IHN0YXRlLmxpbmVTdGFydCAmJiB0ZXN0RG9jdW1lbnRTZXBhcmF0b3Ioc3RhdGUpKSB8fFxuICAgICAgICAgICAgICAgd2l0aGluRmxvd0NvbGxlY3Rpb24gJiYgaXNfRkxPV19JTkRJQ0FUT1IoY2gpKSB7XG4gICAgICBicmVhaztcblxuICAgIH0gZWxzZSBpZiAoaXNfRU9MKGNoKSkge1xuICAgICAgX2xpbmUgPSBzdGF0ZS5saW5lO1xuICAgICAgX2xpbmVTdGFydCA9IHN0YXRlLmxpbmVTdGFydDtcbiAgICAgIF9saW5lSW5kZW50ID0gc3RhdGUubGluZUluZGVudDtcbiAgICAgIHNraXBTZXBhcmF0aW9uU3BhY2Uoc3RhdGUsIGZhbHNlLCAtMSk7XG5cbiAgICAgIGlmIChzdGF0ZS5saW5lSW5kZW50ID49IG5vZGVJbmRlbnQpIHtcbiAgICAgICAgaGFzUGVuZGluZ0NvbnRlbnQgPSB0cnVlO1xuICAgICAgICBjaCA9IHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoc3RhdGUucG9zaXRpb24pO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN0YXRlLnBvc2l0aW9uID0gY2FwdHVyZUVuZDtcbiAgICAgICAgc3RhdGUubGluZSA9IF9saW5lO1xuICAgICAgICBzdGF0ZS5saW5lU3RhcnQgPSBfbGluZVN0YXJ0O1xuICAgICAgICBzdGF0ZS5saW5lSW5kZW50ID0gX2xpbmVJbmRlbnQ7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChoYXNQZW5kaW5nQ29udGVudCkge1xuICAgICAgY2FwdHVyZVNlZ21lbnQoc3RhdGUsIGNhcHR1cmVTdGFydCwgY2FwdHVyZUVuZCwgZmFsc2UpO1xuICAgICAgd3JpdGVGb2xkZWRMaW5lcyhzdGF0ZSwgc3RhdGUubGluZSAtIF9saW5lKTtcbiAgICAgIGNhcHR1cmVTdGFydCA9IGNhcHR1cmVFbmQgPSBzdGF0ZS5wb3NpdGlvbjtcbiAgICAgIGhhc1BlbmRpbmdDb250ZW50ID0gZmFsc2U7XG4gICAgfVxuXG4gICAgaWYgKCFpc19XSElURV9TUEFDRShjaCkpIHtcbiAgICAgIGNhcHR1cmVFbmQgPSBzdGF0ZS5wb3NpdGlvbiArIDE7XG4gICAgfVxuXG4gICAgY2ggPSBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KCsrc3RhdGUucG9zaXRpb24pO1xuICB9XG5cbiAgY2FwdHVyZVNlZ21lbnQoc3RhdGUsIGNhcHR1cmVTdGFydCwgY2FwdHVyZUVuZCwgZmFsc2UpO1xuXG4gIGlmIChzdGF0ZS5yZXN1bHQpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIHN0YXRlLmtpbmQgPSBfa2luZDtcbiAgc3RhdGUucmVzdWx0ID0gX3Jlc3VsdDtcbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiByZWFkU2luZ2xlUXVvdGVkU2NhbGFyKHN0YXRlLCBub2RlSW5kZW50KSB7XG4gIHZhciBjaCxcbiAgICAgIGNhcHR1cmVTdGFydCwgY2FwdHVyZUVuZDtcblxuICBjaCA9IHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoc3RhdGUucG9zaXRpb24pO1xuXG4gIGlmIChjaCAhPT0gMHgyNy8qICcgKi8pIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBzdGF0ZS5raW5kID0gJ3NjYWxhcic7XG4gIHN0YXRlLnJlc3VsdCA9ICcnO1xuICBzdGF0ZS5wb3NpdGlvbisrO1xuICBjYXB0dXJlU3RhcnQgPSBjYXB0dXJlRW5kID0gc3RhdGUucG9zaXRpb247XG5cbiAgd2hpbGUgKChjaCA9IHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoc3RhdGUucG9zaXRpb24pKSAhPT0gMCkge1xuICAgIGlmIChjaCA9PT0gMHgyNy8qICcgKi8pIHtcbiAgICAgIGNhcHR1cmVTZWdtZW50KHN0YXRlLCBjYXB0dXJlU3RhcnQsIHN0YXRlLnBvc2l0aW9uLCB0cnVlKTtcbiAgICAgIGNoID0gc3RhdGUuaW5wdXQuY2hhckNvZGVBdCgrK3N0YXRlLnBvc2l0aW9uKTtcblxuICAgICAgaWYgKGNoID09PSAweDI3LyogJyAqLykge1xuICAgICAgICBjYXB0dXJlU3RhcnQgPSBzdGF0ZS5wb3NpdGlvbjtcbiAgICAgICAgc3RhdGUucG9zaXRpb24rKztcbiAgICAgICAgY2FwdHVyZUVuZCA9IHN0YXRlLnBvc2l0aW9uO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG5cbiAgICB9IGVsc2UgaWYgKGlzX0VPTChjaCkpIHtcbiAgICAgIGNhcHR1cmVTZWdtZW50KHN0YXRlLCBjYXB0dXJlU3RhcnQsIGNhcHR1cmVFbmQsIHRydWUpO1xuICAgICAgd3JpdGVGb2xkZWRMaW5lcyhzdGF0ZSwgc2tpcFNlcGFyYXRpb25TcGFjZShzdGF0ZSwgZmFsc2UsIG5vZGVJbmRlbnQpKTtcbiAgICAgIGNhcHR1cmVTdGFydCA9IGNhcHR1cmVFbmQgPSBzdGF0ZS5wb3NpdGlvbjtcblxuICAgIH0gZWxzZSBpZiAoc3RhdGUucG9zaXRpb24gPT09IHN0YXRlLmxpbmVTdGFydCAmJiB0ZXN0RG9jdW1lbnRTZXBhcmF0b3Ioc3RhdGUpKSB7XG4gICAgICB0aHJvd0Vycm9yKHN0YXRlLCAndW5leHBlY3RlZCBlbmQgb2YgdGhlIGRvY3VtZW50IHdpdGhpbiBhIHNpbmdsZSBxdW90ZWQgc2NhbGFyJyk7XG5cbiAgICB9IGVsc2Uge1xuICAgICAgc3RhdGUucG9zaXRpb24rKztcbiAgICAgIGNhcHR1cmVFbmQgPSBzdGF0ZS5wb3NpdGlvbjtcbiAgICB9XG4gIH1cblxuICB0aHJvd0Vycm9yKHN0YXRlLCAndW5leHBlY3RlZCBlbmQgb2YgdGhlIHN0cmVhbSB3aXRoaW4gYSBzaW5nbGUgcXVvdGVkIHNjYWxhcicpO1xufVxuXG5mdW5jdGlvbiByZWFkRG91YmxlUXVvdGVkU2NhbGFyKHN0YXRlLCBub2RlSW5kZW50KSB7XG4gIHZhciBjYXB0dXJlU3RhcnQsXG4gICAgICBjYXB0dXJlRW5kLFxuICAgICAgaGV4TGVuZ3RoLFxuICAgICAgaGV4UmVzdWx0LFxuICAgICAgdG1wLFxuICAgICAgY2g7XG5cbiAgY2ggPSBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KHN0YXRlLnBvc2l0aW9uKTtcblxuICBpZiAoY2ggIT09IDB4MjIvKiBcIiAqLykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHN0YXRlLmtpbmQgPSAnc2NhbGFyJztcbiAgc3RhdGUucmVzdWx0ID0gJyc7XG4gIHN0YXRlLnBvc2l0aW9uKys7XG4gIGNhcHR1cmVTdGFydCA9IGNhcHR1cmVFbmQgPSBzdGF0ZS5wb3NpdGlvbjtcblxuICB3aGlsZSAoKGNoID0gc3RhdGUuaW5wdXQuY2hhckNvZGVBdChzdGF0ZS5wb3NpdGlvbikpICE9PSAwKSB7XG4gICAgaWYgKGNoID09PSAweDIyLyogXCIgKi8pIHtcbiAgICAgIGNhcHR1cmVTZWdtZW50KHN0YXRlLCBjYXB0dXJlU3RhcnQsIHN0YXRlLnBvc2l0aW9uLCB0cnVlKTtcbiAgICAgIHN0YXRlLnBvc2l0aW9uKys7XG4gICAgICByZXR1cm4gdHJ1ZTtcblxuICAgIH0gZWxzZSBpZiAoY2ggPT09IDB4NUMvKiBcXCAqLykge1xuICAgICAgY2FwdHVyZVNlZ21lbnQoc3RhdGUsIGNhcHR1cmVTdGFydCwgc3RhdGUucG9zaXRpb24sIHRydWUpO1xuICAgICAgY2ggPSBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KCsrc3RhdGUucG9zaXRpb24pO1xuXG4gICAgICBpZiAoaXNfRU9MKGNoKSkge1xuICAgICAgICBza2lwU2VwYXJhdGlvblNwYWNlKHN0YXRlLCBmYWxzZSwgbm9kZUluZGVudCk7XG5cbiAgICAgICAgLy8gVE9ETzogcmV3b3JrIHRvIGlubGluZSBmbiB3aXRoIG5vIHR5cGUgY2FzdD9cbiAgICAgIH0gZWxzZSBpZiAoY2ggPCAyNTYgJiYgc2ltcGxlRXNjYXBlQ2hlY2tbY2hdKSB7XG4gICAgICAgIHN0YXRlLnJlc3VsdCArPSBzaW1wbGVFc2NhcGVNYXBbY2hdO1xuICAgICAgICBzdGF0ZS5wb3NpdGlvbisrO1xuXG4gICAgICB9IGVsc2UgaWYgKCh0bXAgPSBlc2NhcGVkSGV4TGVuKGNoKSkgPiAwKSB7XG4gICAgICAgIGhleExlbmd0aCA9IHRtcDtcbiAgICAgICAgaGV4UmVzdWx0ID0gMDtcblxuICAgICAgICBmb3IgKDsgaGV4TGVuZ3RoID4gMDsgaGV4TGVuZ3RoLS0pIHtcbiAgICAgICAgICBjaCA9IHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoKytzdGF0ZS5wb3NpdGlvbik7XG5cbiAgICAgICAgICBpZiAoKHRtcCA9IGZyb21IZXhDb2RlKGNoKSkgPj0gMCkge1xuICAgICAgICAgICAgaGV4UmVzdWx0ID0gKGhleFJlc3VsdCA8PCA0KSArIHRtcDtcblxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aHJvd0Vycm9yKHN0YXRlLCAnZXhwZWN0ZWQgaGV4YWRlY2ltYWwgY2hhcmFjdGVyJyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgc3RhdGUucmVzdWx0ICs9IGNoYXJGcm9tQ29kZXBvaW50KGhleFJlc3VsdCk7XG5cbiAgICAgICAgc3RhdGUucG9zaXRpb24rKztcblxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3dFcnJvcihzdGF0ZSwgJ3Vua25vd24gZXNjYXBlIHNlcXVlbmNlJyk7XG4gICAgICB9XG5cbiAgICAgIGNhcHR1cmVTdGFydCA9IGNhcHR1cmVFbmQgPSBzdGF0ZS5wb3NpdGlvbjtcblxuICAgIH0gZWxzZSBpZiAoaXNfRU9MKGNoKSkge1xuICAgICAgY2FwdHVyZVNlZ21lbnQoc3RhdGUsIGNhcHR1cmVTdGFydCwgY2FwdHVyZUVuZCwgdHJ1ZSk7XG4gICAgICB3cml0ZUZvbGRlZExpbmVzKHN0YXRlLCBza2lwU2VwYXJhdGlvblNwYWNlKHN0YXRlLCBmYWxzZSwgbm9kZUluZGVudCkpO1xuICAgICAgY2FwdHVyZVN0YXJ0ID0gY2FwdHVyZUVuZCA9IHN0YXRlLnBvc2l0aW9uO1xuXG4gICAgfSBlbHNlIGlmIChzdGF0ZS5wb3NpdGlvbiA9PT0gc3RhdGUubGluZVN0YXJ0ICYmIHRlc3REb2N1bWVudFNlcGFyYXRvcihzdGF0ZSkpIHtcbiAgICAgIHRocm93RXJyb3Ioc3RhdGUsICd1bmV4cGVjdGVkIGVuZCBvZiB0aGUgZG9jdW1lbnQgd2l0aGluIGEgZG91YmxlIHF1b3RlZCBzY2FsYXInKTtcblxuICAgIH0gZWxzZSB7XG4gICAgICBzdGF0ZS5wb3NpdGlvbisrO1xuICAgICAgY2FwdHVyZUVuZCA9IHN0YXRlLnBvc2l0aW9uO1xuICAgIH1cbiAgfVxuXG4gIHRocm93RXJyb3Ioc3RhdGUsICd1bmV4cGVjdGVkIGVuZCBvZiB0aGUgc3RyZWFtIHdpdGhpbiBhIGRvdWJsZSBxdW90ZWQgc2NhbGFyJyk7XG59XG5cbmZ1bmN0aW9uIHJlYWRGbG93Q29sbGVjdGlvbihzdGF0ZSwgbm9kZUluZGVudCkge1xuICB2YXIgcmVhZE5leHQgPSB0cnVlLFxuICAgICAgX2xpbmUsXG4gICAgICBfdGFnICAgICA9IHN0YXRlLnRhZyxcbiAgICAgIF9yZXN1bHQsXG4gICAgICBfYW5jaG9yICA9IHN0YXRlLmFuY2hvcixcbiAgICAgIGZvbGxvd2luZyxcbiAgICAgIHRlcm1pbmF0b3IsXG4gICAgICBpc1BhaXIsXG4gICAgICBpc0V4cGxpY2l0UGFpcixcbiAgICAgIGlzTWFwcGluZyxcbiAgICAgIG92ZXJyaWRhYmxlS2V5cyA9IHt9LFxuICAgICAga2V5Tm9kZSxcbiAgICAgIGtleVRhZyxcbiAgICAgIHZhbHVlTm9kZSxcbiAgICAgIGNoO1xuXG4gIGNoID0gc3RhdGUuaW5wdXQuY2hhckNvZGVBdChzdGF0ZS5wb3NpdGlvbik7XG5cbiAgaWYgKGNoID09PSAweDVCLyogWyAqLykge1xuICAgIHRlcm1pbmF0b3IgPSAweDVEOy8qIF0gKi9cbiAgICBpc01hcHBpbmcgPSBmYWxzZTtcbiAgICBfcmVzdWx0ID0gW107XG4gIH0gZWxzZSBpZiAoY2ggPT09IDB4N0IvKiB7ICovKSB7XG4gICAgdGVybWluYXRvciA9IDB4N0Q7LyogfSAqL1xuICAgIGlzTWFwcGluZyA9IHRydWU7XG4gICAgX3Jlc3VsdCA9IHt9O1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGlmIChzdGF0ZS5hbmNob3IgIT09IG51bGwpIHtcbiAgICBzdGF0ZS5hbmNob3JNYXBbc3RhdGUuYW5jaG9yXSA9IF9yZXN1bHQ7XG4gIH1cblxuICBjaCA9IHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoKytzdGF0ZS5wb3NpdGlvbik7XG5cbiAgd2hpbGUgKGNoICE9PSAwKSB7XG4gICAgc2tpcFNlcGFyYXRpb25TcGFjZShzdGF0ZSwgdHJ1ZSwgbm9kZUluZGVudCk7XG5cbiAgICBjaCA9IHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoc3RhdGUucG9zaXRpb24pO1xuXG4gICAgaWYgKGNoID09PSB0ZXJtaW5hdG9yKSB7XG4gICAgICBzdGF0ZS5wb3NpdGlvbisrO1xuICAgICAgc3RhdGUudGFnID0gX3RhZztcbiAgICAgIHN0YXRlLmFuY2hvciA9IF9hbmNob3I7XG4gICAgICBzdGF0ZS5raW5kID0gaXNNYXBwaW5nID8gJ21hcHBpbmcnIDogJ3NlcXVlbmNlJztcbiAgICAgIHN0YXRlLnJlc3VsdCA9IF9yZXN1bHQ7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2UgaWYgKCFyZWFkTmV4dCkge1xuICAgICAgdGhyb3dFcnJvcihzdGF0ZSwgJ21pc3NlZCBjb21tYSBiZXR3ZWVuIGZsb3cgY29sbGVjdGlvbiBlbnRyaWVzJyk7XG4gICAgfVxuXG4gICAga2V5VGFnID0ga2V5Tm9kZSA9IHZhbHVlTm9kZSA9IG51bGw7XG4gICAgaXNQYWlyID0gaXNFeHBsaWNpdFBhaXIgPSBmYWxzZTtcblxuICAgIGlmIChjaCA9PT0gMHgzRi8qID8gKi8pIHtcbiAgICAgIGZvbGxvd2luZyA9IHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoc3RhdGUucG9zaXRpb24gKyAxKTtcblxuICAgICAgaWYgKGlzX1dTX09SX0VPTChmb2xsb3dpbmcpKSB7XG4gICAgICAgIGlzUGFpciA9IGlzRXhwbGljaXRQYWlyID0gdHJ1ZTtcbiAgICAgICAgc3RhdGUucG9zaXRpb24rKztcbiAgICAgICAgc2tpcFNlcGFyYXRpb25TcGFjZShzdGF0ZSwgdHJ1ZSwgbm9kZUluZGVudCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgX2xpbmUgPSBzdGF0ZS5saW5lO1xuICAgIGNvbXBvc2VOb2RlKHN0YXRlLCBub2RlSW5kZW50LCBDT05URVhUX0ZMT1dfSU4sIGZhbHNlLCB0cnVlKTtcbiAgICBrZXlUYWcgPSBzdGF0ZS50YWc7XG4gICAga2V5Tm9kZSA9IHN0YXRlLnJlc3VsdDtcbiAgICBza2lwU2VwYXJhdGlvblNwYWNlKHN0YXRlLCB0cnVlLCBub2RlSW5kZW50KTtcblxuICAgIGNoID0gc3RhdGUuaW5wdXQuY2hhckNvZGVBdChzdGF0ZS5wb3NpdGlvbik7XG5cbiAgICBpZiAoKGlzRXhwbGljaXRQYWlyIHx8IHN0YXRlLmxpbmUgPT09IF9saW5lKSAmJiBjaCA9PT0gMHgzQS8qIDogKi8pIHtcbiAgICAgIGlzUGFpciA9IHRydWU7XG4gICAgICBjaCA9IHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoKytzdGF0ZS5wb3NpdGlvbik7XG4gICAgICBza2lwU2VwYXJhdGlvblNwYWNlKHN0YXRlLCB0cnVlLCBub2RlSW5kZW50KTtcbiAgICAgIGNvbXBvc2VOb2RlKHN0YXRlLCBub2RlSW5kZW50LCBDT05URVhUX0ZMT1dfSU4sIGZhbHNlLCB0cnVlKTtcbiAgICAgIHZhbHVlTm9kZSA9IHN0YXRlLnJlc3VsdDtcbiAgICB9XG5cbiAgICBpZiAoaXNNYXBwaW5nKSB7XG4gICAgICBzdG9yZU1hcHBpbmdQYWlyKHN0YXRlLCBfcmVzdWx0LCBvdmVycmlkYWJsZUtleXMsIGtleVRhZywga2V5Tm9kZSwgdmFsdWVOb2RlKTtcbiAgICB9IGVsc2UgaWYgKGlzUGFpcikge1xuICAgICAgX3Jlc3VsdC5wdXNoKHN0b3JlTWFwcGluZ1BhaXIoc3RhdGUsIG51bGwsIG92ZXJyaWRhYmxlS2V5cywga2V5VGFnLCBrZXlOb2RlLCB2YWx1ZU5vZGUpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgX3Jlc3VsdC5wdXNoKGtleU5vZGUpO1xuICAgIH1cblxuICAgIHNraXBTZXBhcmF0aW9uU3BhY2Uoc3RhdGUsIHRydWUsIG5vZGVJbmRlbnQpO1xuXG4gICAgY2ggPSBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KHN0YXRlLnBvc2l0aW9uKTtcblxuICAgIGlmIChjaCA9PT0gMHgyQy8qICwgKi8pIHtcbiAgICAgIHJlYWROZXh0ID0gdHJ1ZTtcbiAgICAgIGNoID0gc3RhdGUuaW5wdXQuY2hhckNvZGVBdCgrK3N0YXRlLnBvc2l0aW9uKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVhZE5leHQgPSBmYWxzZTtcbiAgICB9XG4gIH1cblxuICB0aHJvd0Vycm9yKHN0YXRlLCAndW5leHBlY3RlZCBlbmQgb2YgdGhlIHN0cmVhbSB3aXRoaW4gYSBmbG93IGNvbGxlY3Rpb24nKTtcbn1cblxuZnVuY3Rpb24gcmVhZEJsb2NrU2NhbGFyKHN0YXRlLCBub2RlSW5kZW50KSB7XG4gIHZhciBjYXB0dXJlU3RhcnQsXG4gICAgICBmb2xkaW5nLFxuICAgICAgY2hvbXBpbmcgICAgICAgPSBDSE9NUElOR19DTElQLFxuICAgICAgZGlkUmVhZENvbnRlbnQgPSBmYWxzZSxcbiAgICAgIGRldGVjdGVkSW5kZW50ID0gZmFsc2UsXG4gICAgICB0ZXh0SW5kZW50ICAgICA9IG5vZGVJbmRlbnQsXG4gICAgICBlbXB0eUxpbmVzICAgICA9IDAsXG4gICAgICBhdE1vcmVJbmRlbnRlZCA9IGZhbHNlLFxuICAgICAgdG1wLFxuICAgICAgY2g7XG5cbiAgY2ggPSBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KHN0YXRlLnBvc2l0aW9uKTtcblxuICBpZiAoY2ggPT09IDB4N0MvKiB8ICovKSB7XG4gICAgZm9sZGluZyA9IGZhbHNlO1xuICB9IGVsc2UgaWYgKGNoID09PSAweDNFLyogPiAqLykge1xuICAgIGZvbGRpbmcgPSB0cnVlO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHN0YXRlLmtpbmQgPSAnc2NhbGFyJztcbiAgc3RhdGUucmVzdWx0ID0gJyc7XG5cbiAgd2hpbGUgKGNoICE9PSAwKSB7XG4gICAgY2ggPSBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KCsrc3RhdGUucG9zaXRpb24pO1xuXG4gICAgaWYgKGNoID09PSAweDJCLyogKyAqLyB8fCBjaCA9PT0gMHgyRC8qIC0gKi8pIHtcbiAgICAgIGlmIChDSE9NUElOR19DTElQID09PSBjaG9tcGluZykge1xuICAgICAgICBjaG9tcGluZyA9IChjaCA9PT0gMHgyQi8qICsgKi8pID8gQ0hPTVBJTkdfS0VFUCA6IENIT01QSU5HX1NUUklQO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3dFcnJvcihzdGF0ZSwgJ3JlcGVhdCBvZiBhIGNob21waW5nIG1vZGUgaWRlbnRpZmllcicpO1xuICAgICAgfVxuXG4gICAgfSBlbHNlIGlmICgodG1wID0gZnJvbURlY2ltYWxDb2RlKGNoKSkgPj0gMCkge1xuICAgICAgaWYgKHRtcCA9PT0gMCkge1xuICAgICAgICB0aHJvd0Vycm9yKHN0YXRlLCAnYmFkIGV4cGxpY2l0IGluZGVudGF0aW9uIHdpZHRoIG9mIGEgYmxvY2sgc2NhbGFyOyBpdCBjYW5ub3QgYmUgbGVzcyB0aGFuIG9uZScpO1xuICAgICAgfSBlbHNlIGlmICghZGV0ZWN0ZWRJbmRlbnQpIHtcbiAgICAgICAgdGV4dEluZGVudCA9IG5vZGVJbmRlbnQgKyB0bXAgLSAxO1xuICAgICAgICBkZXRlY3RlZEluZGVudCA9IHRydWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvd0Vycm9yKHN0YXRlLCAncmVwZWF0IG9mIGFuIGluZGVudGF0aW9uIHdpZHRoIGlkZW50aWZpZXInKTtcbiAgICAgIH1cblxuICAgIH0gZWxzZSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cblxuICBpZiAoaXNfV0hJVEVfU1BBQ0UoY2gpKSB7XG4gICAgZG8geyBjaCA9IHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoKytzdGF0ZS5wb3NpdGlvbik7IH1cbiAgICB3aGlsZSAoaXNfV0hJVEVfU1BBQ0UoY2gpKTtcblxuICAgIGlmIChjaCA9PT0gMHgyMy8qICMgKi8pIHtcbiAgICAgIGRvIHsgY2ggPSBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KCsrc3RhdGUucG9zaXRpb24pOyB9XG4gICAgICB3aGlsZSAoIWlzX0VPTChjaCkgJiYgKGNoICE9PSAwKSk7XG4gICAgfVxuICB9XG5cbiAgd2hpbGUgKGNoICE9PSAwKSB7XG4gICAgcmVhZExpbmVCcmVhayhzdGF0ZSk7XG4gICAgc3RhdGUubGluZUluZGVudCA9IDA7XG5cbiAgICBjaCA9IHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoc3RhdGUucG9zaXRpb24pO1xuXG4gICAgd2hpbGUgKCghZGV0ZWN0ZWRJbmRlbnQgfHwgc3RhdGUubGluZUluZGVudCA8IHRleHRJbmRlbnQpICYmXG4gICAgICAgICAgIChjaCA9PT0gMHgyMC8qIFNwYWNlICovKSkge1xuICAgICAgc3RhdGUubGluZUluZGVudCsrO1xuICAgICAgY2ggPSBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KCsrc3RhdGUucG9zaXRpb24pO1xuICAgIH1cblxuICAgIGlmICghZGV0ZWN0ZWRJbmRlbnQgJiYgc3RhdGUubGluZUluZGVudCA+IHRleHRJbmRlbnQpIHtcbiAgICAgIHRleHRJbmRlbnQgPSBzdGF0ZS5saW5lSW5kZW50O1xuICAgIH1cblxuICAgIGlmIChpc19FT0woY2gpKSB7XG4gICAgICBlbXB0eUxpbmVzKys7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICAvLyBFbmQgb2YgdGhlIHNjYWxhci5cbiAgICBpZiAoc3RhdGUubGluZUluZGVudCA8IHRleHRJbmRlbnQpIHtcblxuICAgICAgLy8gUGVyZm9ybSB0aGUgY2hvbXBpbmcuXG4gICAgICBpZiAoY2hvbXBpbmcgPT09IENIT01QSU5HX0tFRVApIHtcbiAgICAgICAgc3RhdGUucmVzdWx0ICs9IGNvbW1vbi5yZXBlYXQoJ1xcbicsIGRpZFJlYWRDb250ZW50ID8gMSArIGVtcHR5TGluZXMgOiBlbXB0eUxpbmVzKTtcbiAgICAgIH0gZWxzZSBpZiAoY2hvbXBpbmcgPT09IENIT01QSU5HX0NMSVApIHtcbiAgICAgICAgaWYgKGRpZFJlYWRDb250ZW50KSB7IC8vIGkuZS4gb25seSBpZiB0aGUgc2NhbGFyIGlzIG5vdCBlbXB0eS5cbiAgICAgICAgICBzdGF0ZS5yZXN1bHQgKz0gJ1xcbic7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gQnJlYWsgdGhpcyBgd2hpbGVgIGN5Y2xlIGFuZCBnbyB0byB0aGUgZnVuY2l0b24ncyBlcGlsb2d1ZS5cbiAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIC8vIEZvbGRlZCBzdHlsZTogdXNlIGZhbmN5IHJ1bGVzIHRvIGhhbmRsZSBsaW5lIGJyZWFrcy5cbiAgICBpZiAoZm9sZGluZykge1xuXG4gICAgICAvLyBMaW5lcyBzdGFydGluZyB3aXRoIHdoaXRlIHNwYWNlIGNoYXJhY3RlcnMgKG1vcmUtaW5kZW50ZWQgbGluZXMpIGFyZSBub3QgZm9sZGVkLlxuICAgICAgaWYgKGlzX1dISVRFX1NQQUNFKGNoKSkge1xuICAgICAgICBhdE1vcmVJbmRlbnRlZCA9IHRydWU7XG4gICAgICAgIC8vIGV4Y2VwdCBmb3IgdGhlIGZpcnN0IGNvbnRlbnQgbGluZSAoY2YuIEV4YW1wbGUgOC4xKVxuICAgICAgICBzdGF0ZS5yZXN1bHQgKz0gY29tbW9uLnJlcGVhdCgnXFxuJywgZGlkUmVhZENvbnRlbnQgPyAxICsgZW1wdHlMaW5lcyA6IGVtcHR5TGluZXMpO1xuXG4gICAgICAvLyBFbmQgb2YgbW9yZS1pbmRlbnRlZCBibG9jay5cbiAgICAgIH0gZWxzZSBpZiAoYXRNb3JlSW5kZW50ZWQpIHtcbiAgICAgICAgYXRNb3JlSW5kZW50ZWQgPSBmYWxzZTtcbiAgICAgICAgc3RhdGUucmVzdWx0ICs9IGNvbW1vbi5yZXBlYXQoJ1xcbicsIGVtcHR5TGluZXMgKyAxKTtcblxuICAgICAgLy8gSnVzdCBvbmUgbGluZSBicmVhayAtIHBlcmNlaXZlIGFzIHRoZSBzYW1lIGxpbmUuXG4gICAgICB9IGVsc2UgaWYgKGVtcHR5TGluZXMgPT09IDApIHtcbiAgICAgICAgaWYgKGRpZFJlYWRDb250ZW50KSB7IC8vIGkuZS4gb25seSBpZiB3ZSBoYXZlIGFscmVhZHkgcmVhZCBzb21lIHNjYWxhciBjb250ZW50LlxuICAgICAgICAgIHN0YXRlLnJlc3VsdCArPSAnICc7XG4gICAgICAgIH1cblxuICAgICAgLy8gU2V2ZXJhbCBsaW5lIGJyZWFrcyAtIHBlcmNlaXZlIGFzIGRpZmZlcmVudCBsaW5lcy5cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN0YXRlLnJlc3VsdCArPSBjb21tb24ucmVwZWF0KCdcXG4nLCBlbXB0eUxpbmVzKTtcbiAgICAgIH1cblxuICAgIC8vIExpdGVyYWwgc3R5bGU6IGp1c3QgYWRkIGV4YWN0IG51bWJlciBvZiBsaW5lIGJyZWFrcyBiZXR3ZWVuIGNvbnRlbnQgbGluZXMuXG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIEtlZXAgYWxsIGxpbmUgYnJlYWtzIGV4Y2VwdCB0aGUgaGVhZGVyIGxpbmUgYnJlYWsuXG4gICAgICBzdGF0ZS5yZXN1bHQgKz0gY29tbW9uLnJlcGVhdCgnXFxuJywgZGlkUmVhZENvbnRlbnQgPyAxICsgZW1wdHlMaW5lcyA6IGVtcHR5TGluZXMpO1xuICAgIH1cblxuICAgIGRpZFJlYWRDb250ZW50ID0gdHJ1ZTtcbiAgICBkZXRlY3RlZEluZGVudCA9IHRydWU7XG4gICAgZW1wdHlMaW5lcyA9IDA7XG4gICAgY2FwdHVyZVN0YXJ0ID0gc3RhdGUucG9zaXRpb247XG5cbiAgICB3aGlsZSAoIWlzX0VPTChjaCkgJiYgKGNoICE9PSAwKSkge1xuICAgICAgY2ggPSBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KCsrc3RhdGUucG9zaXRpb24pO1xuICAgIH1cblxuICAgIGNhcHR1cmVTZWdtZW50KHN0YXRlLCBjYXB0dXJlU3RhcnQsIHN0YXRlLnBvc2l0aW9uLCBmYWxzZSk7XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gcmVhZEJsb2NrU2VxdWVuY2Uoc3RhdGUsIG5vZGVJbmRlbnQpIHtcbiAgdmFyIF9saW5lLFxuICAgICAgX3RhZyAgICAgID0gc3RhdGUudGFnLFxuICAgICAgX2FuY2hvciAgID0gc3RhdGUuYW5jaG9yLFxuICAgICAgX3Jlc3VsdCAgID0gW10sXG4gICAgICBmb2xsb3dpbmcsXG4gICAgICBkZXRlY3RlZCAgPSBmYWxzZSxcbiAgICAgIGNoO1xuXG4gIGlmIChzdGF0ZS5hbmNob3IgIT09IG51bGwpIHtcbiAgICBzdGF0ZS5hbmNob3JNYXBbc3RhdGUuYW5jaG9yXSA9IF9yZXN1bHQ7XG4gIH1cblxuICBjaCA9IHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoc3RhdGUucG9zaXRpb24pO1xuXG4gIHdoaWxlIChjaCAhPT0gMCkge1xuXG4gICAgaWYgKGNoICE9PSAweDJELyogLSAqLykge1xuICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgZm9sbG93aW5nID0gc3RhdGUuaW5wdXQuY2hhckNvZGVBdChzdGF0ZS5wb3NpdGlvbiArIDEpO1xuXG4gICAgaWYgKCFpc19XU19PUl9FT0woZm9sbG93aW5nKSkge1xuICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgZGV0ZWN0ZWQgPSB0cnVlO1xuICAgIHN0YXRlLnBvc2l0aW9uKys7XG5cbiAgICBpZiAoc2tpcFNlcGFyYXRpb25TcGFjZShzdGF0ZSwgdHJ1ZSwgLTEpKSB7XG4gICAgICBpZiAoc3RhdGUubGluZUluZGVudCA8PSBub2RlSW5kZW50KSB7XG4gICAgICAgIF9yZXN1bHQucHVzaChudWxsKTtcbiAgICAgICAgY2ggPSBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KHN0YXRlLnBvc2l0aW9uKTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgX2xpbmUgPSBzdGF0ZS5saW5lO1xuICAgIGNvbXBvc2VOb2RlKHN0YXRlLCBub2RlSW5kZW50LCBDT05URVhUX0JMT0NLX0lOLCBmYWxzZSwgdHJ1ZSk7XG4gICAgX3Jlc3VsdC5wdXNoKHN0YXRlLnJlc3VsdCk7XG4gICAgc2tpcFNlcGFyYXRpb25TcGFjZShzdGF0ZSwgdHJ1ZSwgLTEpO1xuXG4gICAgY2ggPSBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KHN0YXRlLnBvc2l0aW9uKTtcblxuICAgIGlmICgoc3RhdGUubGluZSA9PT0gX2xpbmUgfHwgc3RhdGUubGluZUluZGVudCA+IG5vZGVJbmRlbnQpICYmIChjaCAhPT0gMCkpIHtcbiAgICAgIHRocm93RXJyb3Ioc3RhdGUsICdiYWQgaW5kZW50YXRpb24gb2YgYSBzZXF1ZW5jZSBlbnRyeScpO1xuICAgIH0gZWxzZSBpZiAoc3RhdGUubGluZUluZGVudCA8IG5vZGVJbmRlbnQpIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuXG4gIGlmIChkZXRlY3RlZCkge1xuICAgIHN0YXRlLnRhZyA9IF90YWc7XG4gICAgc3RhdGUuYW5jaG9yID0gX2FuY2hvcjtcbiAgICBzdGF0ZS5raW5kID0gJ3NlcXVlbmNlJztcbiAgICBzdGF0ZS5yZXN1bHQgPSBfcmVzdWx0O1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gcmVhZEJsb2NrTWFwcGluZyhzdGF0ZSwgbm9kZUluZGVudCwgZmxvd0luZGVudCkge1xuICB2YXIgZm9sbG93aW5nLFxuICAgICAgYWxsb3dDb21wYWN0LFxuICAgICAgX2xpbmUsXG4gICAgICBfcG9zLFxuICAgICAgX3RhZyAgICAgICAgICA9IHN0YXRlLnRhZyxcbiAgICAgIF9hbmNob3IgICAgICAgPSBzdGF0ZS5hbmNob3IsXG4gICAgICBfcmVzdWx0ICAgICAgID0ge30sXG4gICAgICBvdmVycmlkYWJsZUtleXMgPSB7fSxcbiAgICAgIGtleVRhZyAgICAgICAgPSBudWxsLFxuICAgICAga2V5Tm9kZSAgICAgICA9IG51bGwsXG4gICAgICB2YWx1ZU5vZGUgICAgID0gbnVsbCxcbiAgICAgIGF0RXhwbGljaXRLZXkgPSBmYWxzZSxcbiAgICAgIGRldGVjdGVkICAgICAgPSBmYWxzZSxcbiAgICAgIGNoO1xuXG4gIGlmIChzdGF0ZS5hbmNob3IgIT09IG51bGwpIHtcbiAgICBzdGF0ZS5hbmNob3JNYXBbc3RhdGUuYW5jaG9yXSA9IF9yZXN1bHQ7XG4gIH1cblxuICBjaCA9IHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoc3RhdGUucG9zaXRpb24pO1xuXG4gIHdoaWxlIChjaCAhPT0gMCkge1xuICAgIGZvbGxvd2luZyA9IHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoc3RhdGUucG9zaXRpb24gKyAxKTtcbiAgICBfbGluZSA9IHN0YXRlLmxpbmU7IC8vIFNhdmUgdGhlIGN1cnJlbnQgbGluZS5cbiAgICBfcG9zID0gc3RhdGUucG9zaXRpb247XG5cbiAgICAvL1xuICAgIC8vIEV4cGxpY2l0IG5vdGF0aW9uIGNhc2UuIFRoZXJlIGFyZSB0d28gc2VwYXJhdGUgYmxvY2tzOlxuICAgIC8vIGZpcnN0IGZvciB0aGUga2V5IChkZW5vdGVkIGJ5IFwiP1wiKSBhbmQgc2Vjb25kIGZvciB0aGUgdmFsdWUgKGRlbm90ZWQgYnkgXCI6XCIpXG4gICAgLy9cbiAgICBpZiAoKGNoID09PSAweDNGLyogPyAqLyB8fCBjaCA9PT0gMHgzQS8qIDogKi8pICYmIGlzX1dTX09SX0VPTChmb2xsb3dpbmcpKSB7XG5cbiAgICAgIGlmIChjaCA9PT0gMHgzRi8qID8gKi8pIHtcbiAgICAgICAgaWYgKGF0RXhwbGljaXRLZXkpIHtcbiAgICAgICAgICBzdG9yZU1hcHBpbmdQYWlyKHN0YXRlLCBfcmVzdWx0LCBvdmVycmlkYWJsZUtleXMsIGtleVRhZywga2V5Tm9kZSwgbnVsbCk7XG4gICAgICAgICAga2V5VGFnID0ga2V5Tm9kZSA9IHZhbHVlTm9kZSA9IG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICBkZXRlY3RlZCA9IHRydWU7XG4gICAgICAgIGF0RXhwbGljaXRLZXkgPSB0cnVlO1xuICAgICAgICBhbGxvd0NvbXBhY3QgPSB0cnVlO1xuXG4gICAgICB9IGVsc2UgaWYgKGF0RXhwbGljaXRLZXkpIHtcbiAgICAgICAgLy8gaS5lLiAweDNBLyogOiAqLyA9PT0gY2hhcmFjdGVyIGFmdGVyIHRoZSBleHBsaWNpdCBrZXkuXG4gICAgICAgIGF0RXhwbGljaXRLZXkgPSBmYWxzZTtcbiAgICAgICAgYWxsb3dDb21wYWN0ID0gdHJ1ZTtcblxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3dFcnJvcihzdGF0ZSwgJ2luY29tcGxldGUgZXhwbGljaXQgbWFwcGluZyBwYWlyOyBhIGtleSBub2RlIGlzIG1pc3NlZDsgb3IgZm9sbG93ZWQgYnkgYSBub24tdGFidWxhdGVkIGVtcHR5IGxpbmUnKTtcbiAgICAgIH1cblxuICAgICAgc3RhdGUucG9zaXRpb24gKz0gMTtcbiAgICAgIGNoID0gZm9sbG93aW5nO1xuXG4gICAgLy9cbiAgICAvLyBJbXBsaWNpdCBub3RhdGlvbiBjYXNlLiBGbG93LXN0eWxlIG5vZGUgYXMgdGhlIGtleSBmaXJzdCwgdGhlbiBcIjpcIiwgYW5kIHRoZSB2YWx1ZS5cbiAgICAvL1xuICAgIH0gZWxzZSBpZiAoY29tcG9zZU5vZGUoc3RhdGUsIGZsb3dJbmRlbnQsIENPTlRFWFRfRkxPV19PVVQsIGZhbHNlLCB0cnVlKSkge1xuXG4gICAgICBpZiAoc3RhdGUubGluZSA9PT0gX2xpbmUpIHtcbiAgICAgICAgY2ggPSBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KHN0YXRlLnBvc2l0aW9uKTtcblxuICAgICAgICB3aGlsZSAoaXNfV0hJVEVfU1BBQ0UoY2gpKSB7XG4gICAgICAgICAgY2ggPSBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KCsrc3RhdGUucG9zaXRpb24pO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGNoID09PSAweDNBLyogOiAqLykge1xuICAgICAgICAgIGNoID0gc3RhdGUuaW5wdXQuY2hhckNvZGVBdCgrK3N0YXRlLnBvc2l0aW9uKTtcblxuICAgICAgICAgIGlmICghaXNfV1NfT1JfRU9MKGNoKSkge1xuICAgICAgICAgICAgdGhyb3dFcnJvcihzdGF0ZSwgJ2Egd2hpdGVzcGFjZSBjaGFyYWN0ZXIgaXMgZXhwZWN0ZWQgYWZ0ZXIgdGhlIGtleS12YWx1ZSBzZXBhcmF0b3Igd2l0aGluIGEgYmxvY2sgbWFwcGluZycpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChhdEV4cGxpY2l0S2V5KSB7XG4gICAgICAgICAgICBzdG9yZU1hcHBpbmdQYWlyKHN0YXRlLCBfcmVzdWx0LCBvdmVycmlkYWJsZUtleXMsIGtleVRhZywga2V5Tm9kZSwgbnVsbCk7XG4gICAgICAgICAgICBrZXlUYWcgPSBrZXlOb2RlID0gdmFsdWVOb2RlID0gbnVsbDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBkZXRlY3RlZCA9IHRydWU7XG4gICAgICAgICAgYXRFeHBsaWNpdEtleSA9IGZhbHNlO1xuICAgICAgICAgIGFsbG93Q29tcGFjdCA9IGZhbHNlO1xuICAgICAgICAgIGtleVRhZyA9IHN0YXRlLnRhZztcbiAgICAgICAgICBrZXlOb2RlID0gc3RhdGUucmVzdWx0O1xuXG4gICAgICAgIH0gZWxzZSBpZiAoZGV0ZWN0ZWQpIHtcbiAgICAgICAgICB0aHJvd0Vycm9yKHN0YXRlLCAnY2FuIG5vdCByZWFkIGFuIGltcGxpY2l0IG1hcHBpbmcgcGFpcjsgYSBjb2xvbiBpcyBtaXNzZWQnKTtcblxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHN0YXRlLnRhZyA9IF90YWc7XG4gICAgICAgICAgc3RhdGUuYW5jaG9yID0gX2FuY2hvcjtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTsgLy8gS2VlcCB0aGUgcmVzdWx0IG9mIGBjb21wb3NlTm9kZWAuXG4gICAgICAgIH1cblxuICAgICAgfSBlbHNlIGlmIChkZXRlY3RlZCkge1xuICAgICAgICB0aHJvd0Vycm9yKHN0YXRlLCAnY2FuIG5vdCByZWFkIGEgYmxvY2sgbWFwcGluZyBlbnRyeTsgYSBtdWx0aWxpbmUga2V5IG1heSBub3QgYmUgYW4gaW1wbGljaXQga2V5Jyk7XG5cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN0YXRlLnRhZyA9IF90YWc7XG4gICAgICAgIHN0YXRlLmFuY2hvciA9IF9hbmNob3I7XG4gICAgICAgIHJldHVybiB0cnVlOyAvLyBLZWVwIHRoZSByZXN1bHQgb2YgYGNvbXBvc2VOb2RlYC5cbiAgICAgIH1cblxuICAgIH0gZWxzZSB7XG4gICAgICBicmVhazsgLy8gUmVhZGluZyBpcyBkb25lLiBHbyB0byB0aGUgZXBpbG9ndWUuXG4gICAgfVxuXG4gICAgLy9cbiAgICAvLyBDb21tb24gcmVhZGluZyBjb2RlIGZvciBib3RoIGV4cGxpY2l0IGFuZCBpbXBsaWNpdCBub3RhdGlvbnMuXG4gICAgLy9cbiAgICBpZiAoc3RhdGUubGluZSA9PT0gX2xpbmUgfHwgc3RhdGUubGluZUluZGVudCA+IG5vZGVJbmRlbnQpIHtcbiAgICAgIGlmIChjb21wb3NlTm9kZShzdGF0ZSwgbm9kZUluZGVudCwgQ09OVEVYVF9CTE9DS19PVVQsIHRydWUsIGFsbG93Q29tcGFjdCkpIHtcbiAgICAgICAgaWYgKGF0RXhwbGljaXRLZXkpIHtcbiAgICAgICAgICBrZXlOb2RlID0gc3RhdGUucmVzdWx0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhbHVlTm9kZSA9IHN0YXRlLnJlc3VsdDtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoIWF0RXhwbGljaXRLZXkpIHtcbiAgICAgICAgc3RvcmVNYXBwaW5nUGFpcihzdGF0ZSwgX3Jlc3VsdCwgb3ZlcnJpZGFibGVLZXlzLCBrZXlUYWcsIGtleU5vZGUsIHZhbHVlTm9kZSwgX2xpbmUsIF9wb3MpO1xuICAgICAgICBrZXlUYWcgPSBrZXlOb2RlID0gdmFsdWVOb2RlID0gbnVsbDtcbiAgICAgIH1cblxuICAgICAgc2tpcFNlcGFyYXRpb25TcGFjZShzdGF0ZSwgdHJ1ZSwgLTEpO1xuICAgICAgY2ggPSBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KHN0YXRlLnBvc2l0aW9uKTtcbiAgICB9XG5cbiAgICBpZiAoc3RhdGUubGluZUluZGVudCA+IG5vZGVJbmRlbnQgJiYgKGNoICE9PSAwKSkge1xuICAgICAgdGhyb3dFcnJvcihzdGF0ZSwgJ2JhZCBpbmRlbnRhdGlvbiBvZiBhIG1hcHBpbmcgZW50cnknKTtcbiAgICB9IGVsc2UgaWYgKHN0YXRlLmxpbmVJbmRlbnQgPCBub2RlSW5kZW50KSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cblxuICAvL1xuICAvLyBFcGlsb2d1ZS5cbiAgLy9cblxuICAvLyBTcGVjaWFsIGNhc2U6IGxhc3QgbWFwcGluZydzIG5vZGUgY29udGFpbnMgb25seSB0aGUga2V5IGluIGV4cGxpY2l0IG5vdGF0aW9uLlxuICBpZiAoYXRFeHBsaWNpdEtleSkge1xuICAgIHN0b3JlTWFwcGluZ1BhaXIoc3RhdGUsIF9yZXN1bHQsIG92ZXJyaWRhYmxlS2V5cywga2V5VGFnLCBrZXlOb2RlLCBudWxsKTtcbiAgfVxuXG4gIC8vIEV4cG9zZSB0aGUgcmVzdWx0aW5nIG1hcHBpbmcuXG4gIGlmIChkZXRlY3RlZCkge1xuICAgIHN0YXRlLnRhZyA9IF90YWc7XG4gICAgc3RhdGUuYW5jaG9yID0gX2FuY2hvcjtcbiAgICBzdGF0ZS5raW5kID0gJ21hcHBpbmcnO1xuICAgIHN0YXRlLnJlc3VsdCA9IF9yZXN1bHQ7XG4gIH1cblxuICByZXR1cm4gZGV0ZWN0ZWQ7XG59XG5cbmZ1bmN0aW9uIHJlYWRUYWdQcm9wZXJ0eShzdGF0ZSkge1xuICB2YXIgX3Bvc2l0aW9uLFxuICAgICAgaXNWZXJiYXRpbSA9IGZhbHNlLFxuICAgICAgaXNOYW1lZCAgICA9IGZhbHNlLFxuICAgICAgdGFnSGFuZGxlLFxuICAgICAgdGFnTmFtZSxcbiAgICAgIGNoO1xuXG4gIGNoID0gc3RhdGUuaW5wdXQuY2hhckNvZGVBdChzdGF0ZS5wb3NpdGlvbik7XG5cbiAgaWYgKGNoICE9PSAweDIxLyogISAqLykgcmV0dXJuIGZhbHNlO1xuXG4gIGlmIChzdGF0ZS50YWcgIT09IG51bGwpIHtcbiAgICB0aHJvd0Vycm9yKHN0YXRlLCAnZHVwbGljYXRpb24gb2YgYSB0YWcgcHJvcGVydHknKTtcbiAgfVxuXG4gIGNoID0gc3RhdGUuaW5wdXQuY2hhckNvZGVBdCgrK3N0YXRlLnBvc2l0aW9uKTtcblxuICBpZiAoY2ggPT09IDB4M0MvKiA8ICovKSB7XG4gICAgaXNWZXJiYXRpbSA9IHRydWU7XG4gICAgY2ggPSBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KCsrc3RhdGUucG9zaXRpb24pO1xuXG4gIH0gZWxzZSBpZiAoY2ggPT09IDB4MjEvKiAhICovKSB7XG4gICAgaXNOYW1lZCA9IHRydWU7XG4gICAgdGFnSGFuZGxlID0gJyEhJztcbiAgICBjaCA9IHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoKytzdGF0ZS5wb3NpdGlvbik7XG5cbiAgfSBlbHNlIHtcbiAgICB0YWdIYW5kbGUgPSAnISc7XG4gIH1cblxuICBfcG9zaXRpb24gPSBzdGF0ZS5wb3NpdGlvbjtcblxuICBpZiAoaXNWZXJiYXRpbSkge1xuICAgIGRvIHsgY2ggPSBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KCsrc3RhdGUucG9zaXRpb24pOyB9XG4gICAgd2hpbGUgKGNoICE9PSAwICYmIGNoICE9PSAweDNFLyogPiAqLyk7XG5cbiAgICBpZiAoc3RhdGUucG9zaXRpb24gPCBzdGF0ZS5sZW5ndGgpIHtcbiAgICAgIHRhZ05hbWUgPSBzdGF0ZS5pbnB1dC5zbGljZShfcG9zaXRpb24sIHN0YXRlLnBvc2l0aW9uKTtcbiAgICAgIGNoID0gc3RhdGUuaW5wdXQuY2hhckNvZGVBdCgrK3N0YXRlLnBvc2l0aW9uKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3dFcnJvcihzdGF0ZSwgJ3VuZXhwZWN0ZWQgZW5kIG9mIHRoZSBzdHJlYW0gd2l0aGluIGEgdmVyYmF0aW0gdGFnJyk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHdoaWxlIChjaCAhPT0gMCAmJiAhaXNfV1NfT1JfRU9MKGNoKSkge1xuXG4gICAgICBpZiAoY2ggPT09IDB4MjEvKiAhICovKSB7XG4gICAgICAgIGlmICghaXNOYW1lZCkge1xuICAgICAgICAgIHRhZ0hhbmRsZSA9IHN0YXRlLmlucHV0LnNsaWNlKF9wb3NpdGlvbiAtIDEsIHN0YXRlLnBvc2l0aW9uICsgMSk7XG5cbiAgICAgICAgICBpZiAoIVBBVFRFUk5fVEFHX0hBTkRMRS50ZXN0KHRhZ0hhbmRsZSkpIHtcbiAgICAgICAgICAgIHRocm93RXJyb3Ioc3RhdGUsICduYW1lZCB0YWcgaGFuZGxlIGNhbm5vdCBjb250YWluIHN1Y2ggY2hhcmFjdGVycycpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlzTmFtZWQgPSB0cnVlO1xuICAgICAgICAgIF9wb3NpdGlvbiA9IHN0YXRlLnBvc2l0aW9uICsgMTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aHJvd0Vycm9yKHN0YXRlLCAndGFnIHN1ZmZpeCBjYW5ub3QgY29udGFpbiBleGNsYW1hdGlvbiBtYXJrcycpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGNoID0gc3RhdGUuaW5wdXQuY2hhckNvZGVBdCgrK3N0YXRlLnBvc2l0aW9uKTtcbiAgICB9XG5cbiAgICB0YWdOYW1lID0gc3RhdGUuaW5wdXQuc2xpY2UoX3Bvc2l0aW9uLCBzdGF0ZS5wb3NpdGlvbik7XG5cbiAgICBpZiAoUEFUVEVSTl9GTE9XX0lORElDQVRPUlMudGVzdCh0YWdOYW1lKSkge1xuICAgICAgdGhyb3dFcnJvcihzdGF0ZSwgJ3RhZyBzdWZmaXggY2Fubm90IGNvbnRhaW4gZmxvdyBpbmRpY2F0b3IgY2hhcmFjdGVycycpO1xuICAgIH1cbiAgfVxuXG4gIGlmICh0YWdOYW1lICYmICFQQVRURVJOX1RBR19VUkkudGVzdCh0YWdOYW1lKSkge1xuICAgIHRocm93RXJyb3Ioc3RhdGUsICd0YWcgbmFtZSBjYW5ub3QgY29udGFpbiBzdWNoIGNoYXJhY3RlcnM6ICcgKyB0YWdOYW1lKTtcbiAgfVxuXG4gIGlmIChpc1ZlcmJhdGltKSB7XG4gICAgc3RhdGUudGFnID0gdGFnTmFtZTtcblxuICB9IGVsc2UgaWYgKF9oYXNPd25Qcm9wZXJ0eS5jYWxsKHN0YXRlLnRhZ01hcCwgdGFnSGFuZGxlKSkge1xuICAgIHN0YXRlLnRhZyA9IHN0YXRlLnRhZ01hcFt0YWdIYW5kbGVdICsgdGFnTmFtZTtcblxuICB9IGVsc2UgaWYgKHRhZ0hhbmRsZSA9PT0gJyEnKSB7XG4gICAgc3RhdGUudGFnID0gJyEnICsgdGFnTmFtZTtcblxuICB9IGVsc2UgaWYgKHRhZ0hhbmRsZSA9PT0gJyEhJykge1xuICAgIHN0YXRlLnRhZyA9ICd0YWc6eWFtbC5vcmcsMjAwMjonICsgdGFnTmFtZTtcblxuICB9IGVsc2Uge1xuICAgIHRocm93RXJyb3Ioc3RhdGUsICd1bmRlY2xhcmVkIHRhZyBoYW5kbGUgXCInICsgdGFnSGFuZGxlICsgJ1wiJyk7XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gcmVhZEFuY2hvclByb3BlcnR5KHN0YXRlKSB7XG4gIHZhciBfcG9zaXRpb24sXG4gICAgICBjaDtcblxuICBjaCA9IHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoc3RhdGUucG9zaXRpb24pO1xuXG4gIGlmIChjaCAhPT0gMHgyNi8qICYgKi8pIHJldHVybiBmYWxzZTtcblxuICBpZiAoc3RhdGUuYW5jaG9yICE9PSBudWxsKSB7XG4gICAgdGhyb3dFcnJvcihzdGF0ZSwgJ2R1cGxpY2F0aW9uIG9mIGFuIGFuY2hvciBwcm9wZXJ0eScpO1xuICB9XG5cbiAgY2ggPSBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KCsrc3RhdGUucG9zaXRpb24pO1xuICBfcG9zaXRpb24gPSBzdGF0ZS5wb3NpdGlvbjtcblxuICB3aGlsZSAoY2ggIT09IDAgJiYgIWlzX1dTX09SX0VPTChjaCkgJiYgIWlzX0ZMT1dfSU5ESUNBVE9SKGNoKSkge1xuICAgIGNoID0gc3RhdGUuaW5wdXQuY2hhckNvZGVBdCgrK3N0YXRlLnBvc2l0aW9uKTtcbiAgfVxuXG4gIGlmIChzdGF0ZS5wb3NpdGlvbiA9PT0gX3Bvc2l0aW9uKSB7XG4gICAgdGhyb3dFcnJvcihzdGF0ZSwgJ25hbWUgb2YgYW4gYW5jaG9yIG5vZGUgbXVzdCBjb250YWluIGF0IGxlYXN0IG9uZSBjaGFyYWN0ZXInKTtcbiAgfVxuXG4gIHN0YXRlLmFuY2hvciA9IHN0YXRlLmlucHV0LnNsaWNlKF9wb3NpdGlvbiwgc3RhdGUucG9zaXRpb24pO1xuICByZXR1cm4gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gcmVhZEFsaWFzKHN0YXRlKSB7XG4gIHZhciBfcG9zaXRpb24sIGFsaWFzLFxuICAgICAgY2g7XG5cbiAgY2ggPSBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KHN0YXRlLnBvc2l0aW9uKTtcblxuICBpZiAoY2ggIT09IDB4MkEvKiAqICovKSByZXR1cm4gZmFsc2U7XG5cbiAgY2ggPSBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KCsrc3RhdGUucG9zaXRpb24pO1xuICBfcG9zaXRpb24gPSBzdGF0ZS5wb3NpdGlvbjtcblxuICB3aGlsZSAoY2ggIT09IDAgJiYgIWlzX1dTX09SX0VPTChjaCkgJiYgIWlzX0ZMT1dfSU5ESUNBVE9SKGNoKSkge1xuICAgIGNoID0gc3RhdGUuaW5wdXQuY2hhckNvZGVBdCgrK3N0YXRlLnBvc2l0aW9uKTtcbiAgfVxuXG4gIGlmIChzdGF0ZS5wb3NpdGlvbiA9PT0gX3Bvc2l0aW9uKSB7XG4gICAgdGhyb3dFcnJvcihzdGF0ZSwgJ25hbWUgb2YgYW4gYWxpYXMgbm9kZSBtdXN0IGNvbnRhaW4gYXQgbGVhc3Qgb25lIGNoYXJhY3RlcicpO1xuICB9XG5cbiAgYWxpYXMgPSBzdGF0ZS5pbnB1dC5zbGljZShfcG9zaXRpb24sIHN0YXRlLnBvc2l0aW9uKTtcblxuICBpZiAoIXN0YXRlLmFuY2hvck1hcC5oYXNPd25Qcm9wZXJ0eShhbGlhcykpIHtcbiAgICB0aHJvd0Vycm9yKHN0YXRlLCAndW5pZGVudGlmaWVkIGFsaWFzIFwiJyArIGFsaWFzICsgJ1wiJyk7XG4gIH1cblxuICBzdGF0ZS5yZXN1bHQgPSBzdGF0ZS5hbmNob3JNYXBbYWxpYXNdO1xuICBza2lwU2VwYXJhdGlvblNwYWNlKHN0YXRlLCB0cnVlLCAtMSk7XG4gIHJldHVybiB0cnVlO1xufVxuXG5mdW5jdGlvbiBjb21wb3NlTm9kZShzdGF0ZSwgcGFyZW50SW5kZW50LCBub2RlQ29udGV4dCwgYWxsb3dUb1NlZWssIGFsbG93Q29tcGFjdCkge1xuICB2YXIgYWxsb3dCbG9ja1N0eWxlcyxcbiAgICAgIGFsbG93QmxvY2tTY2FsYXJzLFxuICAgICAgYWxsb3dCbG9ja0NvbGxlY3Rpb25zLFxuICAgICAgaW5kZW50U3RhdHVzID0gMSwgLy8gMTogdGhpcz5wYXJlbnQsIDA6IHRoaXM9cGFyZW50LCAtMTogdGhpczxwYXJlbnRcbiAgICAgIGF0TmV3TGluZSAgPSBmYWxzZSxcbiAgICAgIGhhc0NvbnRlbnQgPSBmYWxzZSxcbiAgICAgIHR5cGVJbmRleCxcbiAgICAgIHR5cGVRdWFudGl0eSxcbiAgICAgIHR5cGUsXG4gICAgICBmbG93SW5kZW50LFxuICAgICAgYmxvY2tJbmRlbnQ7XG5cbiAgaWYgKHN0YXRlLmxpc3RlbmVyICE9PSBudWxsKSB7XG4gICAgc3RhdGUubGlzdGVuZXIoJ29wZW4nLCBzdGF0ZSk7XG4gIH1cblxuICBzdGF0ZS50YWcgICAgPSBudWxsO1xuICBzdGF0ZS5hbmNob3IgPSBudWxsO1xuICBzdGF0ZS5raW5kICAgPSBudWxsO1xuICBzdGF0ZS5yZXN1bHQgPSBudWxsO1xuXG4gIGFsbG93QmxvY2tTdHlsZXMgPSBhbGxvd0Jsb2NrU2NhbGFycyA9IGFsbG93QmxvY2tDb2xsZWN0aW9ucyA9XG4gICAgQ09OVEVYVF9CTE9DS19PVVQgPT09IG5vZGVDb250ZXh0IHx8XG4gICAgQ09OVEVYVF9CTE9DS19JTiAgPT09IG5vZGVDb250ZXh0O1xuXG4gIGlmIChhbGxvd1RvU2Vlaykge1xuICAgIGlmIChza2lwU2VwYXJhdGlvblNwYWNlKHN0YXRlLCB0cnVlLCAtMSkpIHtcbiAgICAgIGF0TmV3TGluZSA9IHRydWU7XG5cbiAgICAgIGlmIChzdGF0ZS5saW5lSW5kZW50ID4gcGFyZW50SW5kZW50KSB7XG4gICAgICAgIGluZGVudFN0YXR1cyA9IDE7XG4gICAgICB9IGVsc2UgaWYgKHN0YXRlLmxpbmVJbmRlbnQgPT09IHBhcmVudEluZGVudCkge1xuICAgICAgICBpbmRlbnRTdGF0dXMgPSAwO1xuICAgICAgfSBlbHNlIGlmIChzdGF0ZS5saW5lSW5kZW50IDwgcGFyZW50SW5kZW50KSB7XG4gICAgICAgIGluZGVudFN0YXR1cyA9IC0xO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGlmIChpbmRlbnRTdGF0dXMgPT09IDEpIHtcbiAgICB3aGlsZSAocmVhZFRhZ1Byb3BlcnR5KHN0YXRlKSB8fCByZWFkQW5jaG9yUHJvcGVydHkoc3RhdGUpKSB7XG4gICAgICBpZiAoc2tpcFNlcGFyYXRpb25TcGFjZShzdGF0ZSwgdHJ1ZSwgLTEpKSB7XG4gICAgICAgIGF0TmV3TGluZSA9IHRydWU7XG4gICAgICAgIGFsbG93QmxvY2tDb2xsZWN0aW9ucyA9IGFsbG93QmxvY2tTdHlsZXM7XG5cbiAgICAgICAgaWYgKHN0YXRlLmxpbmVJbmRlbnQgPiBwYXJlbnRJbmRlbnQpIHtcbiAgICAgICAgICBpbmRlbnRTdGF0dXMgPSAxO1xuICAgICAgICB9IGVsc2UgaWYgKHN0YXRlLmxpbmVJbmRlbnQgPT09IHBhcmVudEluZGVudCkge1xuICAgICAgICAgIGluZGVudFN0YXR1cyA9IDA7XG4gICAgICAgIH0gZWxzZSBpZiAoc3RhdGUubGluZUluZGVudCA8IHBhcmVudEluZGVudCkge1xuICAgICAgICAgIGluZGVudFN0YXR1cyA9IC0xO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBhbGxvd0Jsb2NrQ29sbGVjdGlvbnMgPSBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBpZiAoYWxsb3dCbG9ja0NvbGxlY3Rpb25zKSB7XG4gICAgYWxsb3dCbG9ja0NvbGxlY3Rpb25zID0gYXROZXdMaW5lIHx8IGFsbG93Q29tcGFjdDtcbiAgfVxuXG4gIGlmIChpbmRlbnRTdGF0dXMgPT09IDEgfHwgQ09OVEVYVF9CTE9DS19PVVQgPT09IG5vZGVDb250ZXh0KSB7XG4gICAgaWYgKENPTlRFWFRfRkxPV19JTiA9PT0gbm9kZUNvbnRleHQgfHwgQ09OVEVYVF9GTE9XX09VVCA9PT0gbm9kZUNvbnRleHQpIHtcbiAgICAgIGZsb3dJbmRlbnQgPSBwYXJlbnRJbmRlbnQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIGZsb3dJbmRlbnQgPSBwYXJlbnRJbmRlbnQgKyAxO1xuICAgIH1cblxuICAgIGJsb2NrSW5kZW50ID0gc3RhdGUucG9zaXRpb24gLSBzdGF0ZS5saW5lU3RhcnQ7XG5cbiAgICBpZiAoaW5kZW50U3RhdHVzID09PSAxKSB7XG4gICAgICBpZiAoYWxsb3dCbG9ja0NvbGxlY3Rpb25zICYmXG4gICAgICAgICAgKHJlYWRCbG9ja1NlcXVlbmNlKHN0YXRlLCBibG9ja0luZGVudCkgfHxcbiAgICAgICAgICAgcmVhZEJsb2NrTWFwcGluZyhzdGF0ZSwgYmxvY2tJbmRlbnQsIGZsb3dJbmRlbnQpKSB8fFxuICAgICAgICAgIHJlYWRGbG93Q29sbGVjdGlvbihzdGF0ZSwgZmxvd0luZGVudCkpIHtcbiAgICAgICAgaGFzQ29udGVudCA9IHRydWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoKGFsbG93QmxvY2tTY2FsYXJzICYmIHJlYWRCbG9ja1NjYWxhcihzdGF0ZSwgZmxvd0luZGVudCkpIHx8XG4gICAgICAgICAgICByZWFkU2luZ2xlUXVvdGVkU2NhbGFyKHN0YXRlLCBmbG93SW5kZW50KSB8fFxuICAgICAgICAgICAgcmVhZERvdWJsZVF1b3RlZFNjYWxhcihzdGF0ZSwgZmxvd0luZGVudCkpIHtcbiAgICAgICAgICBoYXNDb250ZW50ID0gdHJ1ZTtcblxuICAgICAgICB9IGVsc2UgaWYgKHJlYWRBbGlhcyhzdGF0ZSkpIHtcbiAgICAgICAgICBoYXNDb250ZW50ID0gdHJ1ZTtcblxuICAgICAgICAgIGlmIChzdGF0ZS50YWcgIT09IG51bGwgfHwgc3RhdGUuYW5jaG9yICE9PSBudWxsKSB7XG4gICAgICAgICAgICB0aHJvd0Vycm9yKHN0YXRlLCAnYWxpYXMgbm9kZSBzaG91bGQgbm90IGhhdmUgYW55IHByb3BlcnRpZXMnKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgfSBlbHNlIGlmIChyZWFkUGxhaW5TY2FsYXIoc3RhdGUsIGZsb3dJbmRlbnQsIENPTlRFWFRfRkxPV19JTiA9PT0gbm9kZUNvbnRleHQpKSB7XG4gICAgICAgICAgaGFzQ29udGVudCA9IHRydWU7XG5cbiAgICAgICAgICBpZiAoc3RhdGUudGFnID09PSBudWxsKSB7XG4gICAgICAgICAgICBzdGF0ZS50YWcgPSAnPyc7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHN0YXRlLmFuY2hvciAhPT0gbnVsbCkge1xuICAgICAgICAgIHN0YXRlLmFuY2hvck1hcFtzdGF0ZS5hbmNob3JdID0gc3RhdGUucmVzdWx0O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChpbmRlbnRTdGF0dXMgPT09IDApIHtcbiAgICAgIC8vIFNwZWNpYWwgY2FzZTogYmxvY2sgc2VxdWVuY2VzIGFyZSBhbGxvd2VkIHRvIGhhdmUgc2FtZSBpbmRlbnRhdGlvbiBsZXZlbCBhcyB0aGUgcGFyZW50LlxuICAgICAgLy8gaHR0cDovL3d3dy55YW1sLm9yZy9zcGVjLzEuMi9zcGVjLmh0bWwjaWQyNzk5Nzg0XG4gICAgICBoYXNDb250ZW50ID0gYWxsb3dCbG9ja0NvbGxlY3Rpb25zICYmIHJlYWRCbG9ja1NlcXVlbmNlKHN0YXRlLCBibG9ja0luZGVudCk7XG4gICAgfVxuICB9XG5cbiAgaWYgKHN0YXRlLnRhZyAhPT0gbnVsbCAmJiBzdGF0ZS50YWcgIT09ICchJykge1xuICAgIGlmIChzdGF0ZS50YWcgPT09ICc/Jykge1xuICAgICAgZm9yICh0eXBlSW5kZXggPSAwLCB0eXBlUXVhbnRpdHkgPSBzdGF0ZS5pbXBsaWNpdFR5cGVzLmxlbmd0aDsgdHlwZUluZGV4IDwgdHlwZVF1YW50aXR5OyB0eXBlSW5kZXggKz0gMSkge1xuICAgICAgICB0eXBlID0gc3RhdGUuaW1wbGljaXRUeXBlc1t0eXBlSW5kZXhdO1xuXG4gICAgICAgIC8vIEltcGxpY2l0IHJlc29sdmluZyBpcyBub3QgYWxsb3dlZCBmb3Igbm9uLXNjYWxhciB0eXBlcywgYW5kICc/J1xuICAgICAgICAvLyBub24tc3BlY2lmaWMgdGFnIGlzIG9ubHkgYXNzaWduZWQgdG8gcGxhaW4gc2NhbGFycy4gU28sIGl0IGlzbid0XG4gICAgICAgIC8vIG5lZWRlZCB0byBjaGVjayBmb3IgJ2tpbmQnIGNvbmZvcm1pdHkuXG5cbiAgICAgICAgaWYgKHR5cGUucmVzb2x2ZShzdGF0ZS5yZXN1bHQpKSB7IC8vIGBzdGF0ZS5yZXN1bHRgIHVwZGF0ZWQgaW4gcmVzb2x2ZXIgaWYgbWF0Y2hlZFxuICAgICAgICAgIHN0YXRlLnJlc3VsdCA9IHR5cGUuY29uc3RydWN0KHN0YXRlLnJlc3VsdCk7XG4gICAgICAgICAgc3RhdGUudGFnID0gdHlwZS50YWc7XG4gICAgICAgICAgaWYgKHN0YXRlLmFuY2hvciAhPT0gbnVsbCkge1xuICAgICAgICAgICAgc3RhdGUuYW5jaG9yTWFwW3N0YXRlLmFuY2hvcl0gPSBzdGF0ZS5yZXN1bHQ7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChfaGFzT3duUHJvcGVydHkuY2FsbChzdGF0ZS50eXBlTWFwW3N0YXRlLmtpbmQgfHwgJ2ZhbGxiYWNrJ10sIHN0YXRlLnRhZykpIHtcbiAgICAgIHR5cGUgPSBzdGF0ZS50eXBlTWFwW3N0YXRlLmtpbmQgfHwgJ2ZhbGxiYWNrJ11bc3RhdGUudGFnXTtcblxuICAgICAgaWYgKHN0YXRlLnJlc3VsdCAhPT0gbnVsbCAmJiB0eXBlLmtpbmQgIT09IHN0YXRlLmtpbmQpIHtcbiAgICAgICAgdGhyb3dFcnJvcihzdGF0ZSwgJ3VuYWNjZXB0YWJsZSBub2RlIGtpbmQgZm9yICE8JyArIHN0YXRlLnRhZyArICc+IHRhZzsgaXQgc2hvdWxkIGJlIFwiJyArIHR5cGUua2luZCArICdcIiwgbm90IFwiJyArIHN0YXRlLmtpbmQgKyAnXCInKTtcbiAgICAgIH1cblxuICAgICAgaWYgKCF0eXBlLnJlc29sdmUoc3RhdGUucmVzdWx0KSkgeyAvLyBgc3RhdGUucmVzdWx0YCB1cGRhdGVkIGluIHJlc29sdmVyIGlmIG1hdGNoZWRcbiAgICAgICAgdGhyb3dFcnJvcihzdGF0ZSwgJ2Nhbm5vdCByZXNvbHZlIGEgbm9kZSB3aXRoICE8JyArIHN0YXRlLnRhZyArICc+IGV4cGxpY2l0IHRhZycpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3RhdGUucmVzdWx0ID0gdHlwZS5jb25zdHJ1Y3Qoc3RhdGUucmVzdWx0KTtcbiAgICAgICAgaWYgKHN0YXRlLmFuY2hvciAhPT0gbnVsbCkge1xuICAgICAgICAgIHN0YXRlLmFuY2hvck1hcFtzdGF0ZS5hbmNob3JdID0gc3RhdGUucmVzdWx0O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93RXJyb3Ioc3RhdGUsICd1bmtub3duIHRhZyAhPCcgKyBzdGF0ZS50YWcgKyAnPicpO1xuICAgIH1cbiAgfVxuXG4gIGlmIChzdGF0ZS5saXN0ZW5lciAhPT0gbnVsbCkge1xuICAgIHN0YXRlLmxpc3RlbmVyKCdjbG9zZScsIHN0YXRlKTtcbiAgfVxuICByZXR1cm4gc3RhdGUudGFnICE9PSBudWxsIHx8ICBzdGF0ZS5hbmNob3IgIT09IG51bGwgfHwgaGFzQ29udGVudDtcbn1cblxuZnVuY3Rpb24gcmVhZERvY3VtZW50KHN0YXRlKSB7XG4gIHZhciBkb2N1bWVudFN0YXJ0ID0gc3RhdGUucG9zaXRpb24sXG4gICAgICBfcG9zaXRpb24sXG4gICAgICBkaXJlY3RpdmVOYW1lLFxuICAgICAgZGlyZWN0aXZlQXJncyxcbiAgICAgIGhhc0RpcmVjdGl2ZXMgPSBmYWxzZSxcbiAgICAgIGNoO1xuXG4gIHN0YXRlLnZlcnNpb24gPSBudWxsO1xuICBzdGF0ZS5jaGVja0xpbmVCcmVha3MgPSBzdGF0ZS5sZWdhY3k7XG4gIHN0YXRlLnRhZ01hcCA9IHt9O1xuICBzdGF0ZS5hbmNob3JNYXAgPSB7fTtcblxuICB3aGlsZSAoKGNoID0gc3RhdGUuaW5wdXQuY2hhckNvZGVBdChzdGF0ZS5wb3NpdGlvbikpICE9PSAwKSB7XG4gICAgc2tpcFNlcGFyYXRpb25TcGFjZShzdGF0ZSwgdHJ1ZSwgLTEpO1xuXG4gICAgY2ggPSBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KHN0YXRlLnBvc2l0aW9uKTtcblxuICAgIGlmIChzdGF0ZS5saW5lSW5kZW50ID4gMCB8fCBjaCAhPT0gMHgyNS8qICUgKi8pIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIGhhc0RpcmVjdGl2ZXMgPSB0cnVlO1xuICAgIGNoID0gc3RhdGUuaW5wdXQuY2hhckNvZGVBdCgrK3N0YXRlLnBvc2l0aW9uKTtcbiAgICBfcG9zaXRpb24gPSBzdGF0ZS5wb3NpdGlvbjtcblxuICAgIHdoaWxlIChjaCAhPT0gMCAmJiAhaXNfV1NfT1JfRU9MKGNoKSkge1xuICAgICAgY2ggPSBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KCsrc3RhdGUucG9zaXRpb24pO1xuICAgIH1cblxuICAgIGRpcmVjdGl2ZU5hbWUgPSBzdGF0ZS5pbnB1dC5zbGljZShfcG9zaXRpb24sIHN0YXRlLnBvc2l0aW9uKTtcbiAgICBkaXJlY3RpdmVBcmdzID0gW107XG5cbiAgICBpZiAoZGlyZWN0aXZlTmFtZS5sZW5ndGggPCAxKSB7XG4gICAgICB0aHJvd0Vycm9yKHN0YXRlLCAnZGlyZWN0aXZlIG5hbWUgbXVzdCBub3QgYmUgbGVzcyB0aGFuIG9uZSBjaGFyYWN0ZXIgaW4gbGVuZ3RoJyk7XG4gICAgfVxuXG4gICAgd2hpbGUgKGNoICE9PSAwKSB7XG4gICAgICB3aGlsZSAoaXNfV0hJVEVfU1BBQ0UoY2gpKSB7XG4gICAgICAgIGNoID0gc3RhdGUuaW5wdXQuY2hhckNvZGVBdCgrK3N0YXRlLnBvc2l0aW9uKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGNoID09PSAweDIzLyogIyAqLykge1xuICAgICAgICBkbyB7IGNoID0gc3RhdGUuaW5wdXQuY2hhckNvZGVBdCgrK3N0YXRlLnBvc2l0aW9uKTsgfVxuICAgICAgICB3aGlsZSAoY2ggIT09IDAgJiYgIWlzX0VPTChjaCkpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgICAgaWYgKGlzX0VPTChjaCkpIGJyZWFrO1xuXG4gICAgICBfcG9zaXRpb24gPSBzdGF0ZS5wb3NpdGlvbjtcblxuICAgICAgd2hpbGUgKGNoICE9PSAwICYmICFpc19XU19PUl9FT0woY2gpKSB7XG4gICAgICAgIGNoID0gc3RhdGUuaW5wdXQuY2hhckNvZGVBdCgrK3N0YXRlLnBvc2l0aW9uKTtcbiAgICAgIH1cblxuICAgICAgZGlyZWN0aXZlQXJncy5wdXNoKHN0YXRlLmlucHV0LnNsaWNlKF9wb3NpdGlvbiwgc3RhdGUucG9zaXRpb24pKTtcbiAgICB9XG5cbiAgICBpZiAoY2ggIT09IDApIHJlYWRMaW5lQnJlYWsoc3RhdGUpO1xuXG4gICAgaWYgKF9oYXNPd25Qcm9wZXJ0eS5jYWxsKGRpcmVjdGl2ZUhhbmRsZXJzLCBkaXJlY3RpdmVOYW1lKSkge1xuICAgICAgZGlyZWN0aXZlSGFuZGxlcnNbZGlyZWN0aXZlTmFtZV0oc3RhdGUsIGRpcmVjdGl2ZU5hbWUsIGRpcmVjdGl2ZUFyZ3MpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvd1dhcm5pbmcoc3RhdGUsICd1bmtub3duIGRvY3VtZW50IGRpcmVjdGl2ZSBcIicgKyBkaXJlY3RpdmVOYW1lICsgJ1wiJyk7XG4gICAgfVxuICB9XG5cbiAgc2tpcFNlcGFyYXRpb25TcGFjZShzdGF0ZSwgdHJ1ZSwgLTEpO1xuXG4gIGlmIChzdGF0ZS5saW5lSW5kZW50ID09PSAwICYmXG4gICAgICBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KHN0YXRlLnBvc2l0aW9uKSAgICAgPT09IDB4MkQvKiAtICovICYmXG4gICAgICBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KHN0YXRlLnBvc2l0aW9uICsgMSkgPT09IDB4MkQvKiAtICovICYmXG4gICAgICBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KHN0YXRlLnBvc2l0aW9uICsgMikgPT09IDB4MkQvKiAtICovKSB7XG4gICAgc3RhdGUucG9zaXRpb24gKz0gMztcbiAgICBza2lwU2VwYXJhdGlvblNwYWNlKHN0YXRlLCB0cnVlLCAtMSk7XG5cbiAgfSBlbHNlIGlmIChoYXNEaXJlY3RpdmVzKSB7XG4gICAgdGhyb3dFcnJvcihzdGF0ZSwgJ2RpcmVjdGl2ZXMgZW5kIG1hcmsgaXMgZXhwZWN0ZWQnKTtcbiAgfVxuXG4gIGNvbXBvc2VOb2RlKHN0YXRlLCBzdGF0ZS5saW5lSW5kZW50IC0gMSwgQ09OVEVYVF9CTE9DS19PVVQsIGZhbHNlLCB0cnVlKTtcbiAgc2tpcFNlcGFyYXRpb25TcGFjZShzdGF0ZSwgdHJ1ZSwgLTEpO1xuXG4gIGlmIChzdGF0ZS5jaGVja0xpbmVCcmVha3MgJiZcbiAgICAgIFBBVFRFUk5fTk9OX0FTQ0lJX0xJTkVfQlJFQUtTLnRlc3Qoc3RhdGUuaW5wdXQuc2xpY2UoZG9jdW1lbnRTdGFydCwgc3RhdGUucG9zaXRpb24pKSkge1xuICAgIHRocm93V2FybmluZyhzdGF0ZSwgJ25vbi1BU0NJSSBsaW5lIGJyZWFrcyBhcmUgaW50ZXJwcmV0ZWQgYXMgY29udGVudCcpO1xuICB9XG5cbiAgc3RhdGUuZG9jdW1lbnRzLnB1c2goc3RhdGUucmVzdWx0KTtcblxuICBpZiAoc3RhdGUucG9zaXRpb24gPT09IHN0YXRlLmxpbmVTdGFydCAmJiB0ZXN0RG9jdW1lbnRTZXBhcmF0b3Ioc3RhdGUpKSB7XG5cbiAgICBpZiAoc3RhdGUuaW5wdXQuY2hhckNvZGVBdChzdGF0ZS5wb3NpdGlvbikgPT09IDB4MkUvKiAuICovKSB7XG4gICAgICBzdGF0ZS5wb3NpdGlvbiArPSAzO1xuICAgICAgc2tpcFNlcGFyYXRpb25TcGFjZShzdGF0ZSwgdHJ1ZSwgLTEpO1xuICAgIH1cbiAgICByZXR1cm47XG4gIH1cblxuICBpZiAoc3RhdGUucG9zaXRpb24gPCAoc3RhdGUubGVuZ3RoIC0gMSkpIHtcbiAgICB0aHJvd0Vycm9yKHN0YXRlLCAnZW5kIG9mIHRoZSBzdHJlYW0gb3IgYSBkb2N1bWVudCBzZXBhcmF0b3IgaXMgZXhwZWN0ZWQnKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm47XG4gIH1cbn1cblxuXG5mdW5jdGlvbiBsb2FkRG9jdW1lbnRzKGlucHV0LCBvcHRpb25zKSB7XG4gIGlucHV0ID0gU3RyaW5nKGlucHV0KTtcbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgaWYgKGlucHV0Lmxlbmd0aCAhPT0gMCkge1xuXG4gICAgLy8gQWRkIHRhaWxpbmcgYFxcbmAgaWYgbm90IGV4aXN0c1xuICAgIGlmIChpbnB1dC5jaGFyQ29kZUF0KGlucHV0Lmxlbmd0aCAtIDEpICE9PSAweDBBLyogTEYgKi8gJiZcbiAgICAgICAgaW5wdXQuY2hhckNvZGVBdChpbnB1dC5sZW5ndGggLSAxKSAhPT0gMHgwRC8qIENSICovKSB7XG4gICAgICBpbnB1dCArPSAnXFxuJztcbiAgICB9XG5cbiAgICAvLyBTdHJpcCBCT01cbiAgICBpZiAoaW5wdXQuY2hhckNvZGVBdCgwKSA9PT0gMHhGRUZGKSB7XG4gICAgICBpbnB1dCA9IGlucHV0LnNsaWNlKDEpO1xuICAgIH1cbiAgfVxuXG4gIHZhciBzdGF0ZSA9IG5ldyBTdGF0ZShpbnB1dCwgb3B0aW9ucyk7XG5cbiAgLy8gVXNlIDAgYXMgc3RyaW5nIHRlcm1pbmF0b3IuIFRoYXQgc2lnbmlmaWNhbnRseSBzaW1wbGlmaWVzIGJvdW5kcyBjaGVjay5cbiAgc3RhdGUuaW5wdXQgKz0gJ1xcMCc7XG5cbiAgd2hpbGUgKHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoc3RhdGUucG9zaXRpb24pID09PSAweDIwLyogU3BhY2UgKi8pIHtcbiAgICBzdGF0ZS5saW5lSW5kZW50ICs9IDE7XG4gICAgc3RhdGUucG9zaXRpb24gKz0gMTtcbiAgfVxuXG4gIHdoaWxlIChzdGF0ZS5wb3NpdGlvbiA8IChzdGF0ZS5sZW5ndGggLSAxKSkge1xuICAgIHJlYWREb2N1bWVudChzdGF0ZSk7XG4gIH1cblxuICByZXR1cm4gc3RhdGUuZG9jdW1lbnRzO1xufVxuXG5cbmZ1bmN0aW9uIGxvYWRBbGwoaW5wdXQsIGl0ZXJhdG9yLCBvcHRpb25zKSB7XG4gIHZhciBkb2N1bWVudHMgPSBsb2FkRG9jdW1lbnRzKGlucHV0LCBvcHRpb25zKSwgaW5kZXgsIGxlbmd0aDtcblxuICBpZiAodHlwZW9mIGl0ZXJhdG9yICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIGRvY3VtZW50cztcbiAgfVxuXG4gIGZvciAoaW5kZXggPSAwLCBsZW5ndGggPSBkb2N1bWVudHMubGVuZ3RoOyBpbmRleCA8IGxlbmd0aDsgaW5kZXggKz0gMSkge1xuICAgIGl0ZXJhdG9yKGRvY3VtZW50c1tpbmRleF0pO1xuICB9XG59XG5cblxuZnVuY3Rpb24gbG9hZChpbnB1dCwgb3B0aW9ucykge1xuICB2YXIgZG9jdW1lbnRzID0gbG9hZERvY3VtZW50cyhpbnB1dCwgb3B0aW9ucyk7XG5cbiAgaWYgKGRvY3VtZW50cy5sZW5ndGggPT09IDApIHtcbiAgICAvKmVzbGludC1kaXNhYmxlIG5vLXVuZGVmaW5lZCovXG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfSBlbHNlIGlmIChkb2N1bWVudHMubGVuZ3RoID09PSAxKSB7XG4gICAgcmV0dXJuIGRvY3VtZW50c1swXTtcbiAgfVxuICB0aHJvdyBuZXcgWUFNTEV4Y2VwdGlvbignZXhwZWN0ZWQgYSBzaW5nbGUgZG9jdW1lbnQgaW4gdGhlIHN0cmVhbSwgYnV0IGZvdW5kIG1vcmUnKTtcbn1cblxuXG5mdW5jdGlvbiBzYWZlTG9hZEFsbChpbnB1dCwgb3V0cHV0LCBvcHRpb25zKSB7XG4gIGlmICh0eXBlb2Ygb3V0cHV0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgbG9hZEFsbChpbnB1dCwgb3V0cHV0LCBjb21tb24uZXh0ZW5kKHsgc2NoZW1hOiBERUZBVUxUX1NBRkVfU0NIRU1BIH0sIG9wdGlvbnMpKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gbG9hZEFsbChpbnB1dCwgY29tbW9uLmV4dGVuZCh7IHNjaGVtYTogREVGQVVMVF9TQUZFX1NDSEVNQSB9LCBvcHRpb25zKSk7XG4gIH1cbn1cblxuXG5mdW5jdGlvbiBzYWZlTG9hZChpbnB1dCwgb3B0aW9ucykge1xuICByZXR1cm4gbG9hZChpbnB1dCwgY29tbW9uLmV4dGVuZCh7IHNjaGVtYTogREVGQVVMVF9TQUZFX1NDSEVNQSB9LCBvcHRpb25zKSk7XG59XG5cblxubW9kdWxlLmV4cG9ydHMubG9hZEFsbCAgICAgPSBsb2FkQWxsO1xubW9kdWxlLmV4cG9ydHMubG9hZCAgICAgICAgPSBsb2FkO1xubW9kdWxlLmV4cG9ydHMuc2FmZUxvYWRBbGwgPSBzYWZlTG9hZEFsbDtcbm1vZHVsZS5leHBvcnRzLnNhZmVMb2FkICAgID0gc2FmZUxvYWQ7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvanMteWFtbC9saWIvanMteWFtbC9sb2FkZXIuanMiLCIndXNlIHN0cmljdCc7XG5cblxudmFyIGNvbW1vbiA9IHJlcXVpcmUoJy4vY29tbW9uJyk7XG5cblxuZnVuY3Rpb24gTWFyayhuYW1lLCBidWZmZXIsIHBvc2l0aW9uLCBsaW5lLCBjb2x1bW4pIHtcbiAgdGhpcy5uYW1lICAgICA9IG5hbWU7XG4gIHRoaXMuYnVmZmVyICAgPSBidWZmZXI7XG4gIHRoaXMucG9zaXRpb24gPSBwb3NpdGlvbjtcbiAgdGhpcy5saW5lICAgICA9IGxpbmU7XG4gIHRoaXMuY29sdW1uICAgPSBjb2x1bW47XG59XG5cblxuTWFyay5wcm90b3R5cGUuZ2V0U25pcHBldCA9IGZ1bmN0aW9uIGdldFNuaXBwZXQoaW5kZW50LCBtYXhMZW5ndGgpIHtcbiAgdmFyIGhlYWQsIHN0YXJ0LCB0YWlsLCBlbmQsIHNuaXBwZXQ7XG5cbiAgaWYgKCF0aGlzLmJ1ZmZlcikgcmV0dXJuIG51bGw7XG5cbiAgaW5kZW50ID0gaW5kZW50IHx8IDQ7XG4gIG1heExlbmd0aCA9IG1heExlbmd0aCB8fCA3NTtcblxuICBoZWFkID0gJyc7XG4gIHN0YXJ0ID0gdGhpcy5wb3NpdGlvbjtcblxuICB3aGlsZSAoc3RhcnQgPiAwICYmICdcXHgwMFxcclxcblxceDg1XFx1MjAyOFxcdTIwMjknLmluZGV4T2YodGhpcy5idWZmZXIuY2hhckF0KHN0YXJ0IC0gMSkpID09PSAtMSkge1xuICAgIHN0YXJ0IC09IDE7XG4gICAgaWYgKHRoaXMucG9zaXRpb24gLSBzdGFydCA+IChtYXhMZW5ndGggLyAyIC0gMSkpIHtcbiAgICAgIGhlYWQgPSAnIC4uLiAnO1xuICAgICAgc3RhcnQgKz0gNTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuXG4gIHRhaWwgPSAnJztcbiAgZW5kID0gdGhpcy5wb3NpdGlvbjtcblxuICB3aGlsZSAoZW5kIDwgdGhpcy5idWZmZXIubGVuZ3RoICYmICdcXHgwMFxcclxcblxceDg1XFx1MjAyOFxcdTIwMjknLmluZGV4T2YodGhpcy5idWZmZXIuY2hhckF0KGVuZCkpID09PSAtMSkge1xuICAgIGVuZCArPSAxO1xuICAgIGlmIChlbmQgLSB0aGlzLnBvc2l0aW9uID4gKG1heExlbmd0aCAvIDIgLSAxKSkge1xuICAgICAgdGFpbCA9ICcgLi4uICc7XG4gICAgICBlbmQgLT0gNTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuXG4gIHNuaXBwZXQgPSB0aGlzLmJ1ZmZlci5zbGljZShzdGFydCwgZW5kKTtcblxuICByZXR1cm4gY29tbW9uLnJlcGVhdCgnICcsIGluZGVudCkgKyBoZWFkICsgc25pcHBldCArIHRhaWwgKyAnXFxuJyArXG4gICAgICAgICBjb21tb24ucmVwZWF0KCcgJywgaW5kZW50ICsgdGhpcy5wb3NpdGlvbiAtIHN0YXJ0ICsgaGVhZC5sZW5ndGgpICsgJ14nO1xufTtcblxuXG5NYXJrLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nKGNvbXBhY3QpIHtcbiAgdmFyIHNuaXBwZXQsIHdoZXJlID0gJyc7XG5cbiAgaWYgKHRoaXMubmFtZSkge1xuICAgIHdoZXJlICs9ICdpbiBcIicgKyB0aGlzLm5hbWUgKyAnXCIgJztcbiAgfVxuXG4gIHdoZXJlICs9ICdhdCBsaW5lICcgKyAodGhpcy5saW5lICsgMSkgKyAnLCBjb2x1bW4gJyArICh0aGlzLmNvbHVtbiArIDEpO1xuXG4gIGlmICghY29tcGFjdCkge1xuICAgIHNuaXBwZXQgPSB0aGlzLmdldFNuaXBwZXQoKTtcblxuICAgIGlmIChzbmlwcGV0KSB7XG4gICAgICB3aGVyZSArPSAnOlxcbicgKyBzbmlwcGV0O1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB3aGVyZTtcbn07XG5cblxubW9kdWxlLmV4cG9ydHMgPSBNYXJrO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2pzLXlhbWwvbGliL2pzLXlhbWwvbWFyay5qcyIsIid1c2Ugc3RyaWN0JztcblxudmFyIFR5cGUgPSByZXF1aXJlKCcuLi90eXBlJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gbmV3IFR5cGUoJ3RhZzp5YW1sLm9yZywyMDAyOnN0cicsIHtcbiAga2luZDogJ3NjYWxhcicsXG4gIGNvbnN0cnVjdDogZnVuY3Rpb24gKGRhdGEpIHsgcmV0dXJuIGRhdGEgIT09IG51bGwgPyBkYXRhIDogJyc7IH1cbn0pO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2pzLXlhbWwvbGliL2pzLXlhbWwvdHlwZS9zdHIuanMiLCIndXNlIHN0cmljdCc7XG5cbnZhciBUeXBlID0gcmVxdWlyZSgnLi4vdHlwZScpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IG5ldyBUeXBlKCd0YWc6eWFtbC5vcmcsMjAwMjpzZXEnLCB7XG4gIGtpbmQ6ICdzZXF1ZW5jZScsXG4gIGNvbnN0cnVjdDogZnVuY3Rpb24gKGRhdGEpIHsgcmV0dXJuIGRhdGEgIT09IG51bGwgPyBkYXRhIDogW107IH1cbn0pO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2pzLXlhbWwvbGliL2pzLXlhbWwvdHlwZS9zZXEuanMiLCIndXNlIHN0cmljdCc7XG5cbnZhciBUeXBlID0gcmVxdWlyZSgnLi4vdHlwZScpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IG5ldyBUeXBlKCd0YWc6eWFtbC5vcmcsMjAwMjptYXAnLCB7XG4gIGtpbmQ6ICdtYXBwaW5nJyxcbiAgY29uc3RydWN0OiBmdW5jdGlvbiAoZGF0YSkgeyByZXR1cm4gZGF0YSAhPT0gbnVsbCA/IGRhdGEgOiB7fTsgfVxufSk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvanMteWFtbC9saWIvanMteWFtbC90eXBlL21hcC5qcyIsIid1c2Ugc3RyaWN0JztcblxudmFyIFR5cGUgPSByZXF1aXJlKCcuLi90eXBlJyk7XG5cbmZ1bmN0aW9uIHJlc29sdmVZYW1sTnVsbChkYXRhKSB7XG4gIGlmIChkYXRhID09PSBudWxsKSByZXR1cm4gdHJ1ZTtcblxuICB2YXIgbWF4ID0gZGF0YS5sZW5ndGg7XG5cbiAgcmV0dXJuIChtYXggPT09IDEgJiYgZGF0YSA9PT0gJ34nKSB8fFxuICAgICAgICAgKG1heCA9PT0gNCAmJiAoZGF0YSA9PT0gJ251bGwnIHx8IGRhdGEgPT09ICdOdWxsJyB8fCBkYXRhID09PSAnTlVMTCcpKTtcbn1cblxuZnVuY3Rpb24gY29uc3RydWN0WWFtbE51bGwoKSB7XG4gIHJldHVybiBudWxsO1xufVxuXG5mdW5jdGlvbiBpc051bGwob2JqZWN0KSB7XG4gIHJldHVybiBvYmplY3QgPT09IG51bGw7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gbmV3IFR5cGUoJ3RhZzp5YW1sLm9yZywyMDAyOm51bGwnLCB7XG4gIGtpbmQ6ICdzY2FsYXInLFxuICByZXNvbHZlOiByZXNvbHZlWWFtbE51bGwsXG4gIGNvbnN0cnVjdDogY29uc3RydWN0WWFtbE51bGwsXG4gIHByZWRpY2F0ZTogaXNOdWxsLFxuICByZXByZXNlbnQ6IHtcbiAgICBjYW5vbmljYWw6IGZ1bmN0aW9uICgpIHsgcmV0dXJuICd+JzsgICAgfSxcbiAgICBsb3dlcmNhc2U6IGZ1bmN0aW9uICgpIHsgcmV0dXJuICdudWxsJzsgfSxcbiAgICB1cHBlcmNhc2U6IGZ1bmN0aW9uICgpIHsgcmV0dXJuICdOVUxMJzsgfSxcbiAgICBjYW1lbGNhc2U6IGZ1bmN0aW9uICgpIHsgcmV0dXJuICdOdWxsJzsgfVxuICB9LFxuICBkZWZhdWx0U3R5bGU6ICdsb3dlcmNhc2UnXG59KTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9qcy15YW1sL2xpYi9qcy15YW1sL3R5cGUvbnVsbC5qcyIsIid1c2Ugc3RyaWN0JztcblxudmFyIFR5cGUgPSByZXF1aXJlKCcuLi90eXBlJyk7XG5cbmZ1bmN0aW9uIHJlc29sdmVZYW1sQm9vbGVhbihkYXRhKSB7XG4gIGlmIChkYXRhID09PSBudWxsKSByZXR1cm4gZmFsc2U7XG5cbiAgdmFyIG1heCA9IGRhdGEubGVuZ3RoO1xuXG4gIHJldHVybiAobWF4ID09PSA0ICYmIChkYXRhID09PSAndHJ1ZScgfHwgZGF0YSA9PT0gJ1RydWUnIHx8IGRhdGEgPT09ICdUUlVFJykpIHx8XG4gICAgICAgICAobWF4ID09PSA1ICYmIChkYXRhID09PSAnZmFsc2UnIHx8IGRhdGEgPT09ICdGYWxzZScgfHwgZGF0YSA9PT0gJ0ZBTFNFJykpO1xufVxuXG5mdW5jdGlvbiBjb25zdHJ1Y3RZYW1sQm9vbGVhbihkYXRhKSB7XG4gIHJldHVybiBkYXRhID09PSAndHJ1ZScgfHxcbiAgICAgICAgIGRhdGEgPT09ICdUcnVlJyB8fFxuICAgICAgICAgZGF0YSA9PT0gJ1RSVUUnO1xufVxuXG5mdW5jdGlvbiBpc0Jvb2xlYW4ob2JqZWN0KSB7XG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwob2JqZWN0KSA9PT0gJ1tvYmplY3QgQm9vbGVhbl0nO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IG5ldyBUeXBlKCd0YWc6eWFtbC5vcmcsMjAwMjpib29sJywge1xuICBraW5kOiAnc2NhbGFyJyxcbiAgcmVzb2x2ZTogcmVzb2x2ZVlhbWxCb29sZWFuLFxuICBjb25zdHJ1Y3Q6IGNvbnN0cnVjdFlhbWxCb29sZWFuLFxuICBwcmVkaWNhdGU6IGlzQm9vbGVhbixcbiAgcmVwcmVzZW50OiB7XG4gICAgbG93ZXJjYXNlOiBmdW5jdGlvbiAob2JqZWN0KSB7IHJldHVybiBvYmplY3QgPyAndHJ1ZScgOiAnZmFsc2UnOyB9LFxuICAgIHVwcGVyY2FzZTogZnVuY3Rpb24gKG9iamVjdCkgeyByZXR1cm4gb2JqZWN0ID8gJ1RSVUUnIDogJ0ZBTFNFJzsgfSxcbiAgICBjYW1lbGNhc2U6IGZ1bmN0aW9uIChvYmplY3QpIHsgcmV0dXJuIG9iamVjdCA/ICdUcnVlJyA6ICdGYWxzZSc7IH1cbiAgfSxcbiAgZGVmYXVsdFN0eWxlOiAnbG93ZXJjYXNlJ1xufSk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvanMteWFtbC9saWIvanMteWFtbC90eXBlL2Jvb2wuanMiLCIndXNlIHN0cmljdCc7XG5cbnZhciBjb21tb24gPSByZXF1aXJlKCcuLi9jb21tb24nKTtcbnZhciBUeXBlICAgPSByZXF1aXJlKCcuLi90eXBlJyk7XG5cbmZ1bmN0aW9uIGlzSGV4Q29kZShjKSB7XG4gIHJldHVybiAoKDB4MzAvKiAwICovIDw9IGMpICYmIChjIDw9IDB4MzkvKiA5ICovKSkgfHxcbiAgICAgICAgICgoMHg0MS8qIEEgKi8gPD0gYykgJiYgKGMgPD0gMHg0Ni8qIEYgKi8pKSB8fFxuICAgICAgICAgKCgweDYxLyogYSAqLyA8PSBjKSAmJiAoYyA8PSAweDY2LyogZiAqLykpO1xufVxuXG5mdW5jdGlvbiBpc09jdENvZGUoYykge1xuICByZXR1cm4gKCgweDMwLyogMCAqLyA8PSBjKSAmJiAoYyA8PSAweDM3LyogNyAqLykpO1xufVxuXG5mdW5jdGlvbiBpc0RlY0NvZGUoYykge1xuICByZXR1cm4gKCgweDMwLyogMCAqLyA8PSBjKSAmJiAoYyA8PSAweDM5LyogOSAqLykpO1xufVxuXG5mdW5jdGlvbiByZXNvbHZlWWFtbEludGVnZXIoZGF0YSkge1xuICBpZiAoZGF0YSA9PT0gbnVsbCkgcmV0dXJuIGZhbHNlO1xuXG4gIHZhciBtYXggPSBkYXRhLmxlbmd0aCxcbiAgICAgIGluZGV4ID0gMCxcbiAgICAgIGhhc0RpZ2l0cyA9IGZhbHNlLFxuICAgICAgY2g7XG5cbiAgaWYgKCFtYXgpIHJldHVybiBmYWxzZTtcblxuICBjaCA9IGRhdGFbaW5kZXhdO1xuXG4gIC8vIHNpZ25cbiAgaWYgKGNoID09PSAnLScgfHwgY2ggPT09ICcrJykge1xuICAgIGNoID0gZGF0YVsrK2luZGV4XTtcbiAgfVxuXG4gIGlmIChjaCA9PT0gJzAnKSB7XG4gICAgLy8gMFxuICAgIGlmIChpbmRleCArIDEgPT09IG1heCkgcmV0dXJuIHRydWU7XG4gICAgY2ggPSBkYXRhWysraW5kZXhdO1xuXG4gICAgLy8gYmFzZSAyLCBiYXNlIDgsIGJhc2UgMTZcblxuICAgIGlmIChjaCA9PT0gJ2InKSB7XG4gICAgICAvLyBiYXNlIDJcbiAgICAgIGluZGV4Kys7XG5cbiAgICAgIGZvciAoOyBpbmRleCA8IG1heDsgaW5kZXgrKykge1xuICAgICAgICBjaCA9IGRhdGFbaW5kZXhdO1xuICAgICAgICBpZiAoY2ggPT09ICdfJykgY29udGludWU7XG4gICAgICAgIGlmIChjaCAhPT0gJzAnICYmIGNoICE9PSAnMScpIHJldHVybiBmYWxzZTtcbiAgICAgICAgaGFzRGlnaXRzID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBoYXNEaWdpdHMgJiYgY2ggIT09ICdfJztcbiAgICB9XG5cblxuICAgIGlmIChjaCA9PT0gJ3gnKSB7XG4gICAgICAvLyBiYXNlIDE2XG4gICAgICBpbmRleCsrO1xuXG4gICAgICBmb3IgKDsgaW5kZXggPCBtYXg7IGluZGV4KyspIHtcbiAgICAgICAgY2ggPSBkYXRhW2luZGV4XTtcbiAgICAgICAgaWYgKGNoID09PSAnXycpIGNvbnRpbnVlO1xuICAgICAgICBpZiAoIWlzSGV4Q29kZShkYXRhLmNoYXJDb2RlQXQoaW5kZXgpKSkgcmV0dXJuIGZhbHNlO1xuICAgICAgICBoYXNEaWdpdHMgPSB0cnVlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGhhc0RpZ2l0cyAmJiBjaCAhPT0gJ18nO1xuICAgIH1cblxuICAgIC8vIGJhc2UgOFxuICAgIGZvciAoOyBpbmRleCA8IG1heDsgaW5kZXgrKykge1xuICAgICAgY2ggPSBkYXRhW2luZGV4XTtcbiAgICAgIGlmIChjaCA9PT0gJ18nKSBjb250aW51ZTtcbiAgICAgIGlmICghaXNPY3RDb2RlKGRhdGEuY2hhckNvZGVBdChpbmRleCkpKSByZXR1cm4gZmFsc2U7XG4gICAgICBoYXNEaWdpdHMgPSB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gaGFzRGlnaXRzICYmIGNoICE9PSAnXyc7XG4gIH1cblxuICAvLyBiYXNlIDEwIChleGNlcHQgMCkgb3IgYmFzZSA2MFxuXG4gIC8vIHZhbHVlIHNob3VsZCBub3Qgc3RhcnQgd2l0aCBgX2A7XG4gIGlmIChjaCA9PT0gJ18nKSByZXR1cm4gZmFsc2U7XG5cbiAgZm9yICg7IGluZGV4IDwgbWF4OyBpbmRleCsrKSB7XG4gICAgY2ggPSBkYXRhW2luZGV4XTtcbiAgICBpZiAoY2ggPT09ICdfJykgY29udGludWU7XG4gICAgaWYgKGNoID09PSAnOicpIGJyZWFrO1xuICAgIGlmICghaXNEZWNDb2RlKGRhdGEuY2hhckNvZGVBdChpbmRleCkpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGhhc0RpZ2l0cyA9IHRydWU7XG4gIH1cblxuICAvLyBTaG91bGQgaGF2ZSBkaWdpdHMgYW5kIHNob3VsZCBub3QgZW5kIHdpdGggYF9gXG4gIGlmICghaGFzRGlnaXRzIHx8IGNoID09PSAnXycpIHJldHVybiBmYWxzZTtcblxuICAvLyBpZiAhYmFzZTYwIC0gZG9uZTtcbiAgaWYgKGNoICE9PSAnOicpIHJldHVybiB0cnVlO1xuXG4gIC8vIGJhc2U2MCBhbG1vc3Qgbm90IHVzZWQsIG5vIG5lZWRzIHRvIG9wdGltaXplXG4gIHJldHVybiAvXig6WzAtNV0/WzAtOV0pKyQvLnRlc3QoZGF0YS5zbGljZShpbmRleCkpO1xufVxuXG5mdW5jdGlvbiBjb25zdHJ1Y3RZYW1sSW50ZWdlcihkYXRhKSB7XG4gIHZhciB2YWx1ZSA9IGRhdGEsIHNpZ24gPSAxLCBjaCwgYmFzZSwgZGlnaXRzID0gW107XG5cbiAgaWYgKHZhbHVlLmluZGV4T2YoJ18nKSAhPT0gLTEpIHtcbiAgICB2YWx1ZSA9IHZhbHVlLnJlcGxhY2UoL18vZywgJycpO1xuICB9XG5cbiAgY2ggPSB2YWx1ZVswXTtcblxuICBpZiAoY2ggPT09ICctJyB8fCBjaCA9PT0gJysnKSB7XG4gICAgaWYgKGNoID09PSAnLScpIHNpZ24gPSAtMTtcbiAgICB2YWx1ZSA9IHZhbHVlLnNsaWNlKDEpO1xuICAgIGNoID0gdmFsdWVbMF07XG4gIH1cblxuICBpZiAodmFsdWUgPT09ICcwJykgcmV0dXJuIDA7XG5cbiAgaWYgKGNoID09PSAnMCcpIHtcbiAgICBpZiAodmFsdWVbMV0gPT09ICdiJykgcmV0dXJuIHNpZ24gKiBwYXJzZUludCh2YWx1ZS5zbGljZSgyKSwgMik7XG4gICAgaWYgKHZhbHVlWzFdID09PSAneCcpIHJldHVybiBzaWduICogcGFyc2VJbnQodmFsdWUsIDE2KTtcbiAgICByZXR1cm4gc2lnbiAqIHBhcnNlSW50KHZhbHVlLCA4KTtcbiAgfVxuXG4gIGlmICh2YWx1ZS5pbmRleE9mKCc6JykgIT09IC0xKSB7XG4gICAgdmFsdWUuc3BsaXQoJzonKS5mb3JFYWNoKGZ1bmN0aW9uICh2KSB7XG4gICAgICBkaWdpdHMudW5zaGlmdChwYXJzZUludCh2LCAxMCkpO1xuICAgIH0pO1xuXG4gICAgdmFsdWUgPSAwO1xuICAgIGJhc2UgPSAxO1xuXG4gICAgZGlnaXRzLmZvckVhY2goZnVuY3Rpb24gKGQpIHtcbiAgICAgIHZhbHVlICs9IChkICogYmFzZSk7XG4gICAgICBiYXNlICo9IDYwO1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIHNpZ24gKiB2YWx1ZTtcblxuICB9XG5cbiAgcmV0dXJuIHNpZ24gKiBwYXJzZUludCh2YWx1ZSwgMTApO1xufVxuXG5mdW5jdGlvbiBpc0ludGVnZXIob2JqZWN0KSB7XG4gIHJldHVybiAoT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG9iamVjdCkpID09PSAnW29iamVjdCBOdW1iZXJdJyAmJlxuICAgICAgICAgKG9iamVjdCAlIDEgPT09IDAgJiYgIWNvbW1vbi5pc05lZ2F0aXZlWmVybyhvYmplY3QpKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBuZXcgVHlwZSgndGFnOnlhbWwub3JnLDIwMDI6aW50Jywge1xuICBraW5kOiAnc2NhbGFyJyxcbiAgcmVzb2x2ZTogcmVzb2x2ZVlhbWxJbnRlZ2VyLFxuICBjb25zdHJ1Y3Q6IGNvbnN0cnVjdFlhbWxJbnRlZ2VyLFxuICBwcmVkaWNhdGU6IGlzSW50ZWdlcixcbiAgcmVwcmVzZW50OiB7XG4gICAgYmluYXJ5OiAgICAgIGZ1bmN0aW9uIChvYmplY3QpIHsgcmV0dXJuICcwYicgKyBvYmplY3QudG9TdHJpbmcoMik7IH0sXG4gICAgb2N0YWw6ICAgICAgIGZ1bmN0aW9uIChvYmplY3QpIHsgcmV0dXJuICcwJyAgKyBvYmplY3QudG9TdHJpbmcoOCk7IH0sXG4gICAgZGVjaW1hbDogICAgIGZ1bmN0aW9uIChvYmplY3QpIHsgcmV0dXJuICAgICAgICBvYmplY3QudG9TdHJpbmcoMTApOyB9LFxuICAgIGhleGFkZWNpbWFsOiBmdW5jdGlvbiAob2JqZWN0KSB7IHJldHVybiAnMHgnICsgb2JqZWN0LnRvU3RyaW5nKDE2KS50b1VwcGVyQ2FzZSgpOyB9XG4gIH0sXG4gIGRlZmF1bHRTdHlsZTogJ2RlY2ltYWwnLFxuICBzdHlsZUFsaWFzZXM6IHtcbiAgICBiaW5hcnk6ICAgICAgWyAyLCAgJ2JpbicgXSxcbiAgICBvY3RhbDogICAgICAgWyA4LCAgJ29jdCcgXSxcbiAgICBkZWNpbWFsOiAgICAgWyAxMCwgJ2RlYycgXSxcbiAgICBoZXhhZGVjaW1hbDogWyAxNiwgJ2hleCcgXVxuICB9XG59KTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9qcy15YW1sL2xpYi9qcy15YW1sL3R5cGUvaW50LmpzIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgY29tbW9uID0gcmVxdWlyZSgnLi4vY29tbW9uJyk7XG52YXIgVHlwZSAgID0gcmVxdWlyZSgnLi4vdHlwZScpO1xuXG52YXIgWUFNTF9GTE9BVF9QQVRURVJOID0gbmV3IFJlZ0V4cChcbiAgLy8gMi41ZTQsIDIuNSBhbmQgaW50ZWdlcnNcbiAgJ14oPzpbLStdPyg/OjB8WzEtOV1bMC05X10qKSg/OlxcXFwuWzAtOV9dKik/KD86W2VFXVstK10/WzAtOV0rKT8nICtcbiAgLy8gLjJlNCwgLjJcbiAgLy8gc3BlY2lhbCBjYXNlLCBzZWVtcyBub3QgZnJvbSBzcGVjXG4gICd8XFxcXC5bMC05X10rKD86W2VFXVstK10/WzAtOV0rKT8nICtcbiAgLy8gMjA6NTlcbiAgJ3xbLStdP1swLTldWzAtOV9dKig/OjpbMC01XT9bMC05XSkrXFxcXC5bMC05X10qJyArXG4gIC8vIC5pbmZcbiAgJ3xbLStdP1xcXFwuKD86aW5mfEluZnxJTkYpJyArXG4gIC8vIC5uYW5cbiAgJ3xcXFxcLig/Om5hbnxOYU58TkFOKSkkJyk7XG5cbmZ1bmN0aW9uIHJlc29sdmVZYW1sRmxvYXQoZGF0YSkge1xuICBpZiAoZGF0YSA9PT0gbnVsbCkgcmV0dXJuIGZhbHNlO1xuXG4gIGlmICghWUFNTF9GTE9BVF9QQVRURVJOLnRlc3QoZGF0YSkgfHxcbiAgICAgIC8vIFF1aWNrIGhhY2sgdG8gbm90IGFsbG93IGludGVnZXJzIGVuZCB3aXRoIGBfYFxuICAgICAgLy8gUHJvYmFibHkgc2hvdWxkIHVwZGF0ZSByZWdleHAgJiBjaGVjayBzcGVlZFxuICAgICAgZGF0YVtkYXRhLmxlbmd0aCAtIDFdID09PSAnXycpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gY29uc3RydWN0WWFtbEZsb2F0KGRhdGEpIHtcbiAgdmFyIHZhbHVlLCBzaWduLCBiYXNlLCBkaWdpdHM7XG5cbiAgdmFsdWUgID0gZGF0YS5yZXBsYWNlKC9fL2csICcnKS50b0xvd2VyQ2FzZSgpO1xuICBzaWduICAgPSB2YWx1ZVswXSA9PT0gJy0nID8gLTEgOiAxO1xuICBkaWdpdHMgPSBbXTtcblxuICBpZiAoJystJy5pbmRleE9mKHZhbHVlWzBdKSA+PSAwKSB7XG4gICAgdmFsdWUgPSB2YWx1ZS5zbGljZSgxKTtcbiAgfVxuXG4gIGlmICh2YWx1ZSA9PT0gJy5pbmYnKSB7XG4gICAgcmV0dXJuIChzaWduID09PSAxKSA/IE51bWJlci5QT1NJVElWRV9JTkZJTklUWSA6IE51bWJlci5ORUdBVElWRV9JTkZJTklUWTtcblxuICB9IGVsc2UgaWYgKHZhbHVlID09PSAnLm5hbicpIHtcbiAgICByZXR1cm4gTmFOO1xuXG4gIH0gZWxzZSBpZiAodmFsdWUuaW5kZXhPZignOicpID49IDApIHtcbiAgICB2YWx1ZS5zcGxpdCgnOicpLmZvckVhY2goZnVuY3Rpb24gKHYpIHtcbiAgICAgIGRpZ2l0cy51bnNoaWZ0KHBhcnNlRmxvYXQodiwgMTApKTtcbiAgICB9KTtcblxuICAgIHZhbHVlID0gMC4wO1xuICAgIGJhc2UgPSAxO1xuXG4gICAgZGlnaXRzLmZvckVhY2goZnVuY3Rpb24gKGQpIHtcbiAgICAgIHZhbHVlICs9IGQgKiBiYXNlO1xuICAgICAgYmFzZSAqPSA2MDtcbiAgICB9KTtcblxuICAgIHJldHVybiBzaWduICogdmFsdWU7XG5cbiAgfVxuICByZXR1cm4gc2lnbiAqIHBhcnNlRmxvYXQodmFsdWUsIDEwKTtcbn1cblxuXG52YXIgU0NJRU5USUZJQ19XSVRIT1VUX0RPVCA9IC9eWy0rXT9bMC05XStlLztcblxuZnVuY3Rpb24gcmVwcmVzZW50WWFtbEZsb2F0KG9iamVjdCwgc3R5bGUpIHtcbiAgdmFyIHJlcztcblxuICBpZiAoaXNOYU4ob2JqZWN0KSkge1xuICAgIHN3aXRjaCAoc3R5bGUpIHtcbiAgICAgIGNhc2UgJ2xvd2VyY2FzZSc6IHJldHVybiAnLm5hbic7XG4gICAgICBjYXNlICd1cHBlcmNhc2UnOiByZXR1cm4gJy5OQU4nO1xuICAgICAgY2FzZSAnY2FtZWxjYXNlJzogcmV0dXJuICcuTmFOJztcbiAgICB9XG4gIH0gZWxzZSBpZiAoTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZID09PSBvYmplY3QpIHtcbiAgICBzd2l0Y2ggKHN0eWxlKSB7XG4gICAgICBjYXNlICdsb3dlcmNhc2UnOiByZXR1cm4gJy5pbmYnO1xuICAgICAgY2FzZSAndXBwZXJjYXNlJzogcmV0dXJuICcuSU5GJztcbiAgICAgIGNhc2UgJ2NhbWVsY2FzZSc6IHJldHVybiAnLkluZic7XG4gICAgfVxuICB9IGVsc2UgaWYgKE51bWJlci5ORUdBVElWRV9JTkZJTklUWSA9PT0gb2JqZWN0KSB7XG4gICAgc3dpdGNoIChzdHlsZSkge1xuICAgICAgY2FzZSAnbG93ZXJjYXNlJzogcmV0dXJuICctLmluZic7XG4gICAgICBjYXNlICd1cHBlcmNhc2UnOiByZXR1cm4gJy0uSU5GJztcbiAgICAgIGNhc2UgJ2NhbWVsY2FzZSc6IHJldHVybiAnLS5JbmYnO1xuICAgIH1cbiAgfSBlbHNlIGlmIChjb21tb24uaXNOZWdhdGl2ZVplcm8ob2JqZWN0KSkge1xuICAgIHJldHVybiAnLTAuMCc7XG4gIH1cblxuICByZXMgPSBvYmplY3QudG9TdHJpbmcoMTApO1xuXG4gIC8vIEpTIHN0cmluZ2lmaWVyIGNhbiBidWlsZCBzY2llbnRpZmljIGZvcm1hdCB3aXRob3V0IGRvdHM6IDVlLTEwMCxcbiAgLy8gd2hpbGUgWUFNTCByZXF1cmVzIGRvdDogNS5lLTEwMC4gRml4IGl0IHdpdGggc2ltcGxlIGhhY2tcblxuICByZXR1cm4gU0NJRU5USUZJQ19XSVRIT1VUX0RPVC50ZXN0KHJlcykgPyByZXMucmVwbGFjZSgnZScsICcuZScpIDogcmVzO1xufVxuXG5mdW5jdGlvbiBpc0Zsb2F0KG9iamVjdCkge1xuICByZXR1cm4gKE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvYmplY3QpID09PSAnW29iamVjdCBOdW1iZXJdJykgJiZcbiAgICAgICAgIChvYmplY3QgJSAxICE9PSAwIHx8IGNvbW1vbi5pc05lZ2F0aXZlWmVybyhvYmplY3QpKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBuZXcgVHlwZSgndGFnOnlhbWwub3JnLDIwMDI6ZmxvYXQnLCB7XG4gIGtpbmQ6ICdzY2FsYXInLFxuICByZXNvbHZlOiByZXNvbHZlWWFtbEZsb2F0LFxuICBjb25zdHJ1Y3Q6IGNvbnN0cnVjdFlhbWxGbG9hdCxcbiAgcHJlZGljYXRlOiBpc0Zsb2F0LFxuICByZXByZXNlbnQ6IHJlcHJlc2VudFlhbWxGbG9hdCxcbiAgZGVmYXVsdFN0eWxlOiAnbG93ZXJjYXNlJ1xufSk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvanMteWFtbC9saWIvanMteWFtbC90eXBlL2Zsb2F0LmpzIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgVHlwZSA9IHJlcXVpcmUoJy4uL3R5cGUnKTtcblxudmFyIFlBTUxfREFURV9SRUdFWFAgPSBuZXcgUmVnRXhwKFxuICAnXihbMC05XVswLTldWzAtOV1bMC05XSknICAgICAgICAgICsgLy8gWzFdIHllYXJcbiAgJy0oWzAtOV1bMC05XSknICAgICAgICAgICAgICAgICAgICArIC8vIFsyXSBtb250aFxuICAnLShbMC05XVswLTldKSQnKTsgICAgICAgICAgICAgICAgICAgLy8gWzNdIGRheVxuXG52YXIgWUFNTF9USU1FU1RBTVBfUkVHRVhQID0gbmV3IFJlZ0V4cChcbiAgJ14oWzAtOV1bMC05XVswLTldWzAtOV0pJyAgICAgICAgICArIC8vIFsxXSB5ZWFyXG4gICctKFswLTldWzAtOV0/KScgICAgICAgICAgICAgICAgICAgKyAvLyBbMl0gbW9udGhcbiAgJy0oWzAtOV1bMC05XT8pJyAgICAgICAgICAgICAgICAgICArIC8vIFszXSBkYXlcbiAgJyg/OltUdF18WyBcXFxcdF0rKScgICAgICAgICAgICAgICAgICsgLy8gLi4uXG4gICcoWzAtOV1bMC05XT8pJyAgICAgICAgICAgICAgICAgICAgKyAvLyBbNF0gaG91clxuICAnOihbMC05XVswLTldKScgICAgICAgICAgICAgICAgICAgICsgLy8gWzVdIG1pbnV0ZVxuICAnOihbMC05XVswLTldKScgICAgICAgICAgICAgICAgICAgICsgLy8gWzZdIHNlY29uZFxuICAnKD86XFxcXC4oWzAtOV0qKSk/JyAgICAgICAgICAgICAgICAgKyAvLyBbN10gZnJhY3Rpb25cbiAgJyg/OlsgXFxcXHRdKihafChbLStdKShbMC05XVswLTldPyknICsgLy8gWzhdIHR6IFs5XSB0el9zaWduIFsxMF0gdHpfaG91clxuICAnKD86OihbMC05XVswLTldKSk/KSk/JCcpOyAgICAgICAgICAgLy8gWzExXSB0el9taW51dGVcblxuZnVuY3Rpb24gcmVzb2x2ZVlhbWxUaW1lc3RhbXAoZGF0YSkge1xuICBpZiAoZGF0YSA9PT0gbnVsbCkgcmV0dXJuIGZhbHNlO1xuICBpZiAoWUFNTF9EQVRFX1JFR0VYUC5leGVjKGRhdGEpICE9PSBudWxsKSByZXR1cm4gdHJ1ZTtcbiAgaWYgKFlBTUxfVElNRVNUQU1QX1JFR0VYUC5leGVjKGRhdGEpICE9PSBudWxsKSByZXR1cm4gdHJ1ZTtcbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBjb25zdHJ1Y3RZYW1sVGltZXN0YW1wKGRhdGEpIHtcbiAgdmFyIG1hdGNoLCB5ZWFyLCBtb250aCwgZGF5LCBob3VyLCBtaW51dGUsIHNlY29uZCwgZnJhY3Rpb24gPSAwLFxuICAgICAgZGVsdGEgPSBudWxsLCB0el9ob3VyLCB0el9taW51dGUsIGRhdGU7XG5cbiAgbWF0Y2ggPSBZQU1MX0RBVEVfUkVHRVhQLmV4ZWMoZGF0YSk7XG4gIGlmIChtYXRjaCA9PT0gbnVsbCkgbWF0Y2ggPSBZQU1MX1RJTUVTVEFNUF9SRUdFWFAuZXhlYyhkYXRhKTtcblxuICBpZiAobWF0Y2ggPT09IG51bGwpIHRocm93IG5ldyBFcnJvcignRGF0ZSByZXNvbHZlIGVycm9yJyk7XG5cbiAgLy8gbWF0Y2g6IFsxXSB5ZWFyIFsyXSBtb250aCBbM10gZGF5XG5cbiAgeWVhciA9ICsobWF0Y2hbMV0pO1xuICBtb250aCA9ICsobWF0Y2hbMl0pIC0gMTsgLy8gSlMgbW9udGggc3RhcnRzIHdpdGggMFxuICBkYXkgPSArKG1hdGNoWzNdKTtcblxuICBpZiAoIW1hdGNoWzRdKSB7IC8vIG5vIGhvdXJcbiAgICByZXR1cm4gbmV3IERhdGUoRGF0ZS5VVEMoeWVhciwgbW9udGgsIGRheSkpO1xuICB9XG5cbiAgLy8gbWF0Y2g6IFs0XSBob3VyIFs1XSBtaW51dGUgWzZdIHNlY29uZCBbN10gZnJhY3Rpb25cblxuICBob3VyID0gKyhtYXRjaFs0XSk7XG4gIG1pbnV0ZSA9ICsobWF0Y2hbNV0pO1xuICBzZWNvbmQgPSArKG1hdGNoWzZdKTtcblxuICBpZiAobWF0Y2hbN10pIHtcbiAgICBmcmFjdGlvbiA9IG1hdGNoWzddLnNsaWNlKDAsIDMpO1xuICAgIHdoaWxlIChmcmFjdGlvbi5sZW5ndGggPCAzKSB7IC8vIG1pbGxpLXNlY29uZHNcbiAgICAgIGZyYWN0aW9uICs9ICcwJztcbiAgICB9XG4gICAgZnJhY3Rpb24gPSArZnJhY3Rpb247XG4gIH1cblxuICAvLyBtYXRjaDogWzhdIHR6IFs5XSB0el9zaWduIFsxMF0gdHpfaG91ciBbMTFdIHR6X21pbnV0ZVxuXG4gIGlmIChtYXRjaFs5XSkge1xuICAgIHR6X2hvdXIgPSArKG1hdGNoWzEwXSk7XG4gICAgdHpfbWludXRlID0gKyhtYXRjaFsxMV0gfHwgMCk7XG4gICAgZGVsdGEgPSAodHpfaG91ciAqIDYwICsgdHpfbWludXRlKSAqIDYwMDAwOyAvLyBkZWx0YSBpbiBtaWxpLXNlY29uZHNcbiAgICBpZiAobWF0Y2hbOV0gPT09ICctJykgZGVsdGEgPSAtZGVsdGE7XG4gIH1cblxuICBkYXRlID0gbmV3IERhdGUoRGF0ZS5VVEMoeWVhciwgbW9udGgsIGRheSwgaG91ciwgbWludXRlLCBzZWNvbmQsIGZyYWN0aW9uKSk7XG5cbiAgaWYgKGRlbHRhKSBkYXRlLnNldFRpbWUoZGF0ZS5nZXRUaW1lKCkgLSBkZWx0YSk7XG5cbiAgcmV0dXJuIGRhdGU7XG59XG5cbmZ1bmN0aW9uIHJlcHJlc2VudFlhbWxUaW1lc3RhbXAob2JqZWN0IC8qLCBzdHlsZSovKSB7XG4gIHJldHVybiBvYmplY3QudG9JU09TdHJpbmcoKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBuZXcgVHlwZSgndGFnOnlhbWwub3JnLDIwMDI6dGltZXN0YW1wJywge1xuICBraW5kOiAnc2NhbGFyJyxcbiAgcmVzb2x2ZTogcmVzb2x2ZVlhbWxUaW1lc3RhbXAsXG4gIGNvbnN0cnVjdDogY29uc3RydWN0WWFtbFRpbWVzdGFtcCxcbiAgaW5zdGFuY2VPZjogRGF0ZSxcbiAgcmVwcmVzZW50OiByZXByZXNlbnRZYW1sVGltZXN0YW1wXG59KTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9qcy15YW1sL2xpYi9qcy15YW1sL3R5cGUvdGltZXN0YW1wLmpzIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgVHlwZSA9IHJlcXVpcmUoJy4uL3R5cGUnKTtcblxuZnVuY3Rpb24gcmVzb2x2ZVlhbWxNZXJnZShkYXRhKSB7XG4gIHJldHVybiBkYXRhID09PSAnPDwnIHx8IGRhdGEgPT09IG51bGw7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gbmV3IFR5cGUoJ3RhZzp5YW1sLm9yZywyMDAyOm1lcmdlJywge1xuICBraW5kOiAnc2NhbGFyJyxcbiAgcmVzb2x2ZTogcmVzb2x2ZVlhbWxNZXJnZVxufSk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvanMteWFtbC9saWIvanMteWFtbC90eXBlL21lcmdlLmpzIiwiJ3VzZSBzdHJpY3QnO1xuXG4vKmVzbGludC1kaXNhYmxlIG5vLWJpdHdpc2UqL1xuXG52YXIgTm9kZUJ1ZmZlcjtcblxudHJ5IHtcbiAgLy8gQSB0cmljayBmb3IgYnJvd3NlcmlmaWVkIHZlcnNpb24sIHRvIG5vdCBpbmNsdWRlIGBCdWZmZXJgIHNoaW1cbiAgdmFyIF9yZXF1aXJlID0gcmVxdWlyZTtcbiAgTm9kZUJ1ZmZlciA9IF9yZXF1aXJlKCdidWZmZXInKS5CdWZmZXI7XG59IGNhdGNoIChfXykge31cblxudmFyIFR5cGUgICAgICAgPSByZXF1aXJlKCcuLi90eXBlJyk7XG5cblxuLy8gWyA2NCwgNjUsIDY2IF0gLT4gWyBwYWRkaW5nLCBDUiwgTEYgXVxudmFyIEJBU0U2NF9NQVAgPSAnQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejAxMjM0NTY3ODkrLz1cXG5cXHInO1xuXG5cbmZ1bmN0aW9uIHJlc29sdmVZYW1sQmluYXJ5KGRhdGEpIHtcbiAgaWYgKGRhdGEgPT09IG51bGwpIHJldHVybiBmYWxzZTtcblxuICB2YXIgY29kZSwgaWR4LCBiaXRsZW4gPSAwLCBtYXggPSBkYXRhLmxlbmd0aCwgbWFwID0gQkFTRTY0X01BUDtcblxuICAvLyBDb252ZXJ0IG9uZSBieSBvbmUuXG4gIGZvciAoaWR4ID0gMDsgaWR4IDwgbWF4OyBpZHgrKykge1xuICAgIGNvZGUgPSBtYXAuaW5kZXhPZihkYXRhLmNoYXJBdChpZHgpKTtcblxuICAgIC8vIFNraXAgQ1IvTEZcbiAgICBpZiAoY29kZSA+IDY0KSBjb250aW51ZTtcblxuICAgIC8vIEZhaWwgb24gaWxsZWdhbCBjaGFyYWN0ZXJzXG4gICAgaWYgKGNvZGUgPCAwKSByZXR1cm4gZmFsc2U7XG5cbiAgICBiaXRsZW4gKz0gNjtcbiAgfVxuXG4gIC8vIElmIHRoZXJlIGFyZSBhbnkgYml0cyBsZWZ0LCBzb3VyY2Ugd2FzIGNvcnJ1cHRlZFxuICByZXR1cm4gKGJpdGxlbiAlIDgpID09PSAwO1xufVxuXG5mdW5jdGlvbiBjb25zdHJ1Y3RZYW1sQmluYXJ5KGRhdGEpIHtcbiAgdmFyIGlkeCwgdGFpbGJpdHMsXG4gICAgICBpbnB1dCA9IGRhdGEucmVwbGFjZSgvW1xcclxcbj1dL2csICcnKSwgLy8gcmVtb3ZlIENSL0xGICYgcGFkZGluZyB0byBzaW1wbGlmeSBzY2FuXG4gICAgICBtYXggPSBpbnB1dC5sZW5ndGgsXG4gICAgICBtYXAgPSBCQVNFNjRfTUFQLFxuICAgICAgYml0cyA9IDAsXG4gICAgICByZXN1bHQgPSBbXTtcblxuICAvLyBDb2xsZWN0IGJ5IDYqNCBiaXRzICgzIGJ5dGVzKVxuXG4gIGZvciAoaWR4ID0gMDsgaWR4IDwgbWF4OyBpZHgrKykge1xuICAgIGlmICgoaWR4ICUgNCA9PT0gMCkgJiYgaWR4KSB7XG4gICAgICByZXN1bHQucHVzaCgoYml0cyA+PiAxNikgJiAweEZGKTtcbiAgICAgIHJlc3VsdC5wdXNoKChiaXRzID4+IDgpICYgMHhGRik7XG4gICAgICByZXN1bHQucHVzaChiaXRzICYgMHhGRik7XG4gICAgfVxuXG4gICAgYml0cyA9IChiaXRzIDw8IDYpIHwgbWFwLmluZGV4T2YoaW5wdXQuY2hhckF0KGlkeCkpO1xuICB9XG5cbiAgLy8gRHVtcCB0YWlsXG5cbiAgdGFpbGJpdHMgPSAobWF4ICUgNCkgKiA2O1xuXG4gIGlmICh0YWlsYml0cyA9PT0gMCkge1xuICAgIHJlc3VsdC5wdXNoKChiaXRzID4+IDE2KSAmIDB4RkYpO1xuICAgIHJlc3VsdC5wdXNoKChiaXRzID4+IDgpICYgMHhGRik7XG4gICAgcmVzdWx0LnB1c2goYml0cyAmIDB4RkYpO1xuICB9IGVsc2UgaWYgKHRhaWxiaXRzID09PSAxOCkge1xuICAgIHJlc3VsdC5wdXNoKChiaXRzID4+IDEwKSAmIDB4RkYpO1xuICAgIHJlc3VsdC5wdXNoKChiaXRzID4+IDIpICYgMHhGRik7XG4gIH0gZWxzZSBpZiAodGFpbGJpdHMgPT09IDEyKSB7XG4gICAgcmVzdWx0LnB1c2goKGJpdHMgPj4gNCkgJiAweEZGKTtcbiAgfVxuXG4gIC8vIFdyYXAgaW50byBCdWZmZXIgZm9yIE5vZGVKUyBhbmQgbGVhdmUgQXJyYXkgZm9yIGJyb3dzZXJcbiAgaWYgKE5vZGVCdWZmZXIpIHtcbiAgICAvLyBTdXBwb3J0IG5vZGUgNi4rIEJ1ZmZlciBBUEkgd2hlbiBhdmFpbGFibGVcbiAgICByZXR1cm4gTm9kZUJ1ZmZlci5mcm9tID8gTm9kZUJ1ZmZlci5mcm9tKHJlc3VsdCkgOiBuZXcgTm9kZUJ1ZmZlcihyZXN1bHQpO1xuICB9XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuZnVuY3Rpb24gcmVwcmVzZW50WWFtbEJpbmFyeShvYmplY3QgLyosIHN0eWxlKi8pIHtcbiAgdmFyIHJlc3VsdCA9ICcnLCBiaXRzID0gMCwgaWR4LCB0YWlsLFxuICAgICAgbWF4ID0gb2JqZWN0Lmxlbmd0aCxcbiAgICAgIG1hcCA9IEJBU0U2NF9NQVA7XG5cbiAgLy8gQ29udmVydCBldmVyeSB0aHJlZSBieXRlcyB0byA0IEFTQ0lJIGNoYXJhY3RlcnMuXG5cbiAgZm9yIChpZHggPSAwOyBpZHggPCBtYXg7IGlkeCsrKSB7XG4gICAgaWYgKChpZHggJSAzID09PSAwKSAmJiBpZHgpIHtcbiAgICAgIHJlc3VsdCArPSBtYXBbKGJpdHMgPj4gMTgpICYgMHgzRl07XG4gICAgICByZXN1bHQgKz0gbWFwWyhiaXRzID4+IDEyKSAmIDB4M0ZdO1xuICAgICAgcmVzdWx0ICs9IG1hcFsoYml0cyA+PiA2KSAmIDB4M0ZdO1xuICAgICAgcmVzdWx0ICs9IG1hcFtiaXRzICYgMHgzRl07XG4gICAgfVxuXG4gICAgYml0cyA9IChiaXRzIDw8IDgpICsgb2JqZWN0W2lkeF07XG4gIH1cblxuICAvLyBEdW1wIHRhaWxcblxuICB0YWlsID0gbWF4ICUgMztcblxuICBpZiAodGFpbCA9PT0gMCkge1xuICAgIHJlc3VsdCArPSBtYXBbKGJpdHMgPj4gMTgpICYgMHgzRl07XG4gICAgcmVzdWx0ICs9IG1hcFsoYml0cyA+PiAxMikgJiAweDNGXTtcbiAgICByZXN1bHQgKz0gbWFwWyhiaXRzID4+IDYpICYgMHgzRl07XG4gICAgcmVzdWx0ICs9IG1hcFtiaXRzICYgMHgzRl07XG4gIH0gZWxzZSBpZiAodGFpbCA9PT0gMikge1xuICAgIHJlc3VsdCArPSBtYXBbKGJpdHMgPj4gMTApICYgMHgzRl07XG4gICAgcmVzdWx0ICs9IG1hcFsoYml0cyA+PiA0KSAmIDB4M0ZdO1xuICAgIHJlc3VsdCArPSBtYXBbKGJpdHMgPDwgMikgJiAweDNGXTtcbiAgICByZXN1bHQgKz0gbWFwWzY0XTtcbiAgfSBlbHNlIGlmICh0YWlsID09PSAxKSB7XG4gICAgcmVzdWx0ICs9IG1hcFsoYml0cyA+PiAyKSAmIDB4M0ZdO1xuICAgIHJlc3VsdCArPSBtYXBbKGJpdHMgPDwgNCkgJiAweDNGXTtcbiAgICByZXN1bHQgKz0gbWFwWzY0XTtcbiAgICByZXN1bHQgKz0gbWFwWzY0XTtcbiAgfVxuXG4gIHJldHVybiByZXN1bHQ7XG59XG5cbmZ1bmN0aW9uIGlzQmluYXJ5KG9iamVjdCkge1xuICByZXR1cm4gTm9kZUJ1ZmZlciAmJiBOb2RlQnVmZmVyLmlzQnVmZmVyKG9iamVjdCk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gbmV3IFR5cGUoJ3RhZzp5YW1sLm9yZywyMDAyOmJpbmFyeScsIHtcbiAga2luZDogJ3NjYWxhcicsXG4gIHJlc29sdmU6IHJlc29sdmVZYW1sQmluYXJ5LFxuICBjb25zdHJ1Y3Q6IGNvbnN0cnVjdFlhbWxCaW5hcnksXG4gIHByZWRpY2F0ZTogaXNCaW5hcnksXG4gIHJlcHJlc2VudDogcmVwcmVzZW50WWFtbEJpbmFyeVxufSk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvanMteWFtbC9saWIvanMteWFtbC90eXBlL2JpbmFyeS5qcyIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcImJ1ZmZlclwiKTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyBleHRlcm5hbCBcImJ1ZmZlclwiXG4vLyBtb2R1bGUgaWQgPSAxNTBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgVHlwZSA9IHJlcXVpcmUoJy4uL3R5cGUnKTtcblxudmFyIF9oYXNPd25Qcm9wZXJ0eSA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG52YXIgX3RvU3RyaW5nICAgICAgID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZztcblxuZnVuY3Rpb24gcmVzb2x2ZVlhbWxPbWFwKGRhdGEpIHtcbiAgaWYgKGRhdGEgPT09IG51bGwpIHJldHVybiB0cnVlO1xuXG4gIHZhciBvYmplY3RLZXlzID0gW10sIGluZGV4LCBsZW5ndGgsIHBhaXIsIHBhaXJLZXksIHBhaXJIYXNLZXksXG4gICAgICBvYmplY3QgPSBkYXRhO1xuXG4gIGZvciAoaW5kZXggPSAwLCBsZW5ndGggPSBvYmplY3QubGVuZ3RoOyBpbmRleCA8IGxlbmd0aDsgaW5kZXggKz0gMSkge1xuICAgIHBhaXIgPSBvYmplY3RbaW5kZXhdO1xuICAgIHBhaXJIYXNLZXkgPSBmYWxzZTtcblxuICAgIGlmIChfdG9TdHJpbmcuY2FsbChwYWlyKSAhPT0gJ1tvYmplY3QgT2JqZWN0XScpIHJldHVybiBmYWxzZTtcblxuICAgIGZvciAocGFpcktleSBpbiBwYWlyKSB7XG4gICAgICBpZiAoX2hhc093blByb3BlcnR5LmNhbGwocGFpciwgcGFpcktleSkpIHtcbiAgICAgICAgaWYgKCFwYWlySGFzS2V5KSBwYWlySGFzS2V5ID0gdHJ1ZTtcbiAgICAgICAgZWxzZSByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKCFwYWlySGFzS2V5KSByZXR1cm4gZmFsc2U7XG5cbiAgICBpZiAob2JqZWN0S2V5cy5pbmRleE9mKHBhaXJLZXkpID09PSAtMSkgb2JqZWN0S2V5cy5wdXNoKHBhaXJLZXkpO1xuICAgIGVsc2UgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59XG5cbmZ1bmN0aW9uIGNvbnN0cnVjdFlhbWxPbWFwKGRhdGEpIHtcbiAgcmV0dXJuIGRhdGEgIT09IG51bGwgPyBkYXRhIDogW107XG59XG5cbm1vZHVsZS5leHBvcnRzID0gbmV3IFR5cGUoJ3RhZzp5YW1sLm9yZywyMDAyOm9tYXAnLCB7XG4gIGtpbmQ6ICdzZXF1ZW5jZScsXG4gIHJlc29sdmU6IHJlc29sdmVZYW1sT21hcCxcbiAgY29uc3RydWN0OiBjb25zdHJ1Y3RZYW1sT21hcFxufSk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvanMteWFtbC9saWIvanMteWFtbC90eXBlL29tYXAuanMiLCIndXNlIHN0cmljdCc7XG5cbnZhciBUeXBlID0gcmVxdWlyZSgnLi4vdHlwZScpO1xuXG52YXIgX3RvU3RyaW5nID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZztcblxuZnVuY3Rpb24gcmVzb2x2ZVlhbWxQYWlycyhkYXRhKSB7XG4gIGlmIChkYXRhID09PSBudWxsKSByZXR1cm4gdHJ1ZTtcblxuICB2YXIgaW5kZXgsIGxlbmd0aCwgcGFpciwga2V5cywgcmVzdWx0LFxuICAgICAgb2JqZWN0ID0gZGF0YTtcblxuICByZXN1bHQgPSBuZXcgQXJyYXkob2JqZWN0Lmxlbmd0aCk7XG5cbiAgZm9yIChpbmRleCA9IDAsIGxlbmd0aCA9IG9iamVjdC5sZW5ndGg7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCArPSAxKSB7XG4gICAgcGFpciA9IG9iamVjdFtpbmRleF07XG5cbiAgICBpZiAoX3RvU3RyaW5nLmNhbGwocGFpcikgIT09ICdbb2JqZWN0IE9iamVjdF0nKSByZXR1cm4gZmFsc2U7XG5cbiAgICBrZXlzID0gT2JqZWN0LmtleXMocGFpcik7XG5cbiAgICBpZiAoa2V5cy5sZW5ndGggIT09IDEpIHJldHVybiBmYWxzZTtcblxuICAgIHJlc3VsdFtpbmRleF0gPSBbIGtleXNbMF0sIHBhaXJba2V5c1swXV0gXTtcbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufVxuXG5mdW5jdGlvbiBjb25zdHJ1Y3RZYW1sUGFpcnMoZGF0YSkge1xuICBpZiAoZGF0YSA9PT0gbnVsbCkgcmV0dXJuIFtdO1xuXG4gIHZhciBpbmRleCwgbGVuZ3RoLCBwYWlyLCBrZXlzLCByZXN1bHQsXG4gICAgICBvYmplY3QgPSBkYXRhO1xuXG4gIHJlc3VsdCA9IG5ldyBBcnJheShvYmplY3QubGVuZ3RoKTtcblxuICBmb3IgKGluZGV4ID0gMCwgbGVuZ3RoID0gb2JqZWN0Lmxlbmd0aDsgaW5kZXggPCBsZW5ndGg7IGluZGV4ICs9IDEpIHtcbiAgICBwYWlyID0gb2JqZWN0W2luZGV4XTtcblxuICAgIGtleXMgPSBPYmplY3Qua2V5cyhwYWlyKTtcblxuICAgIHJlc3VsdFtpbmRleF0gPSBbIGtleXNbMF0sIHBhaXJba2V5c1swXV0gXTtcbiAgfVxuXG4gIHJldHVybiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gbmV3IFR5cGUoJ3RhZzp5YW1sLm9yZywyMDAyOnBhaXJzJywge1xuICBraW5kOiAnc2VxdWVuY2UnLFxuICByZXNvbHZlOiByZXNvbHZlWWFtbFBhaXJzLFxuICBjb25zdHJ1Y3Q6IGNvbnN0cnVjdFlhbWxQYWlyc1xufSk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvanMteWFtbC9saWIvanMteWFtbC90eXBlL3BhaXJzLmpzIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgVHlwZSA9IHJlcXVpcmUoJy4uL3R5cGUnKTtcblxudmFyIF9oYXNPd25Qcm9wZXJ0eSA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG5cbmZ1bmN0aW9uIHJlc29sdmVZYW1sU2V0KGRhdGEpIHtcbiAgaWYgKGRhdGEgPT09IG51bGwpIHJldHVybiB0cnVlO1xuXG4gIHZhciBrZXksIG9iamVjdCA9IGRhdGE7XG5cbiAgZm9yIChrZXkgaW4gb2JqZWN0KSB7XG4gICAgaWYgKF9oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwga2V5KSkge1xuICAgICAgaWYgKG9iamVjdFtrZXldICE9PSBudWxsKSByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59XG5cbmZ1bmN0aW9uIGNvbnN0cnVjdFlhbWxTZXQoZGF0YSkge1xuICByZXR1cm4gZGF0YSAhPT0gbnVsbCA/IGRhdGEgOiB7fTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBuZXcgVHlwZSgndGFnOnlhbWwub3JnLDIwMDI6c2V0Jywge1xuICBraW5kOiAnbWFwcGluZycsXG4gIHJlc29sdmU6IHJlc29sdmVZYW1sU2V0LFxuICBjb25zdHJ1Y3Q6IGNvbnN0cnVjdFlhbWxTZXRcbn0pO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2pzLXlhbWwvbGliL2pzLXlhbWwvdHlwZS9zZXQuanMiLCIndXNlIHN0cmljdCc7XG5cbnZhciBUeXBlID0gcmVxdWlyZSgnLi4vLi4vdHlwZScpO1xuXG5mdW5jdGlvbiByZXNvbHZlSmF2YXNjcmlwdFVuZGVmaW5lZCgpIHtcbiAgcmV0dXJuIHRydWU7XG59XG5cbmZ1bmN0aW9uIGNvbnN0cnVjdEphdmFzY3JpcHRVbmRlZmluZWQoKSB7XG4gIC8qZXNsaW50LWRpc2FibGUgbm8tdW5kZWZpbmVkKi9cbiAgcmV0dXJuIHVuZGVmaW5lZDtcbn1cblxuZnVuY3Rpb24gcmVwcmVzZW50SmF2YXNjcmlwdFVuZGVmaW5lZCgpIHtcbiAgcmV0dXJuICcnO1xufVxuXG5mdW5jdGlvbiBpc1VuZGVmaW5lZChvYmplY3QpIHtcbiAgcmV0dXJuIHR5cGVvZiBvYmplY3QgPT09ICd1bmRlZmluZWQnO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IG5ldyBUeXBlKCd0YWc6eWFtbC5vcmcsMjAwMjpqcy91bmRlZmluZWQnLCB7XG4gIGtpbmQ6ICdzY2FsYXInLFxuICByZXNvbHZlOiByZXNvbHZlSmF2YXNjcmlwdFVuZGVmaW5lZCxcbiAgY29uc3RydWN0OiBjb25zdHJ1Y3RKYXZhc2NyaXB0VW5kZWZpbmVkLFxuICBwcmVkaWNhdGU6IGlzVW5kZWZpbmVkLFxuICByZXByZXNlbnQ6IHJlcHJlc2VudEphdmFzY3JpcHRVbmRlZmluZWRcbn0pO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2pzLXlhbWwvbGliL2pzLXlhbWwvdHlwZS9qcy91bmRlZmluZWQuanMiLCIndXNlIHN0cmljdCc7XG5cbnZhciBUeXBlID0gcmVxdWlyZSgnLi4vLi4vdHlwZScpO1xuXG5mdW5jdGlvbiByZXNvbHZlSmF2YXNjcmlwdFJlZ0V4cChkYXRhKSB7XG4gIGlmIChkYXRhID09PSBudWxsKSByZXR1cm4gZmFsc2U7XG4gIGlmIChkYXRhLmxlbmd0aCA9PT0gMCkgcmV0dXJuIGZhbHNlO1xuXG4gIHZhciByZWdleHAgPSBkYXRhLFxuICAgICAgdGFpbCAgID0gL1xcLyhbZ2ltXSopJC8uZXhlYyhkYXRhKSxcbiAgICAgIG1vZGlmaWVycyA9ICcnO1xuXG4gIC8vIGlmIHJlZ2V4cCBzdGFydHMgd2l0aCAnLycgaXQgY2FuIGhhdmUgbW9kaWZpZXJzIGFuZCBtdXN0IGJlIHByb3Blcmx5IGNsb3NlZFxuICAvLyBgL2Zvby9naW1gIC0gbW9kaWZpZXJzIHRhaWwgY2FuIGJlIG1heGltdW0gMyBjaGFyc1xuICBpZiAocmVnZXhwWzBdID09PSAnLycpIHtcbiAgICBpZiAodGFpbCkgbW9kaWZpZXJzID0gdGFpbFsxXTtcblxuICAgIGlmIChtb2RpZmllcnMubGVuZ3RoID4gMykgcmV0dXJuIGZhbHNlO1xuICAgIC8vIGlmIGV4cHJlc3Npb24gc3RhcnRzIHdpdGggLywgaXMgc2hvdWxkIGJlIHByb3Blcmx5IHRlcm1pbmF0ZWRcbiAgICBpZiAocmVnZXhwW3JlZ2V4cC5sZW5ndGggLSBtb2RpZmllcnMubGVuZ3RoIC0gMV0gIT09ICcvJykgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59XG5cbmZ1bmN0aW9uIGNvbnN0cnVjdEphdmFzY3JpcHRSZWdFeHAoZGF0YSkge1xuICB2YXIgcmVnZXhwID0gZGF0YSxcbiAgICAgIHRhaWwgICA9IC9cXC8oW2dpbV0qKSQvLmV4ZWMoZGF0YSksXG4gICAgICBtb2RpZmllcnMgPSAnJztcblxuICAvLyBgL2Zvby9naW1gIC0gdGFpbCBjYW4gYmUgbWF4aW11bSA0IGNoYXJzXG4gIGlmIChyZWdleHBbMF0gPT09ICcvJykge1xuICAgIGlmICh0YWlsKSBtb2RpZmllcnMgPSB0YWlsWzFdO1xuICAgIHJlZ2V4cCA9IHJlZ2V4cC5zbGljZSgxLCByZWdleHAubGVuZ3RoIC0gbW9kaWZpZXJzLmxlbmd0aCAtIDEpO1xuICB9XG5cbiAgcmV0dXJuIG5ldyBSZWdFeHAocmVnZXhwLCBtb2RpZmllcnMpO1xufVxuXG5mdW5jdGlvbiByZXByZXNlbnRKYXZhc2NyaXB0UmVnRXhwKG9iamVjdCAvKiwgc3R5bGUqLykge1xuICB2YXIgcmVzdWx0ID0gJy8nICsgb2JqZWN0LnNvdXJjZSArICcvJztcblxuICBpZiAob2JqZWN0Lmdsb2JhbCkgcmVzdWx0ICs9ICdnJztcbiAgaWYgKG9iamVjdC5tdWx0aWxpbmUpIHJlc3VsdCArPSAnbSc7XG4gIGlmIChvYmplY3QuaWdub3JlQ2FzZSkgcmVzdWx0ICs9ICdpJztcblxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5mdW5jdGlvbiBpc1JlZ0V4cChvYmplY3QpIHtcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvYmplY3QpID09PSAnW29iamVjdCBSZWdFeHBdJztcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBuZXcgVHlwZSgndGFnOnlhbWwub3JnLDIwMDI6anMvcmVnZXhwJywge1xuICBraW5kOiAnc2NhbGFyJyxcbiAgcmVzb2x2ZTogcmVzb2x2ZUphdmFzY3JpcHRSZWdFeHAsXG4gIGNvbnN0cnVjdDogY29uc3RydWN0SmF2YXNjcmlwdFJlZ0V4cCxcbiAgcHJlZGljYXRlOiBpc1JlZ0V4cCxcbiAgcmVwcmVzZW50OiByZXByZXNlbnRKYXZhc2NyaXB0UmVnRXhwXG59KTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9qcy15YW1sL2xpYi9qcy15YW1sL3R5cGUvanMvcmVnZXhwLmpzIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgZXNwcmltYTtcblxuLy8gQnJvd3NlcmlmaWVkIHZlcnNpb24gZG9lcyBub3QgaGF2ZSBlc3ByaW1hXG4vL1xuLy8gMS4gRm9yIG5vZGUuanMganVzdCByZXF1aXJlIG1vZHVsZSBhcyBkZXBzXG4vLyAyLiBGb3IgYnJvd3NlciB0cnkgdG8gcmVxdWlyZSBtdWR1bGUgdmlhIGV4dGVybmFsIEFNRCBzeXN0ZW0uXG4vLyAgICBJZiBub3QgZm91bmQgLSB0cnkgdG8gZmFsbGJhY2sgdG8gd2luZG93LmVzcHJpbWEuIElmIG5vdFxuLy8gICAgZm91bmQgdG9vIC0gdGhlbiBmYWlsIHRvIHBhcnNlLlxuLy9cbnRyeSB7XG4gIC8vIHdvcmthcm91bmQgdG8gZXhjbHVkZSBwYWNrYWdlIGZyb20gYnJvd3NlcmlmeSBsaXN0LlxuICB2YXIgX3JlcXVpcmUgPSByZXF1aXJlO1xuICBlc3ByaW1hID0gX3JlcXVpcmUoJ2VzcHJpbWEnKTtcbn0gY2F0Y2ggKF8pIHtcbiAgLypnbG9iYWwgd2luZG93ICovXG4gIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJykgZXNwcmltYSA9IHdpbmRvdy5lc3ByaW1hO1xufVxuXG52YXIgVHlwZSA9IHJlcXVpcmUoJy4uLy4uL3R5cGUnKTtcblxuZnVuY3Rpb24gcmVzb2x2ZUphdmFzY3JpcHRGdW5jdGlvbihkYXRhKSB7XG4gIGlmIChkYXRhID09PSBudWxsKSByZXR1cm4gZmFsc2U7XG5cbiAgdHJ5IHtcbiAgICB2YXIgc291cmNlID0gJygnICsgZGF0YSArICcpJyxcbiAgICAgICAgYXN0ICAgID0gZXNwcmltYS5wYXJzZShzb3VyY2UsIHsgcmFuZ2U6IHRydWUgfSk7XG5cbiAgICBpZiAoYXN0LnR5cGUgICAgICAgICAgICAgICAgICAgICE9PSAnUHJvZ3JhbScgICAgICAgICAgICAgfHxcbiAgICAgICAgYXN0LmJvZHkubGVuZ3RoICAgICAgICAgICAgICE9PSAxICAgICAgICAgICAgICAgICAgICAgfHxcbiAgICAgICAgYXN0LmJvZHlbMF0udHlwZSAgICAgICAgICAgICE9PSAnRXhwcmVzc2lvblN0YXRlbWVudCcgfHxcbiAgICAgICAgYXN0LmJvZHlbMF0uZXhwcmVzc2lvbi50eXBlICE9PSAnRnVuY3Rpb25FeHByZXNzaW9uJykge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHJldHVybiB0cnVlO1xuICB9IGNhdGNoIChlcnIpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn1cblxuZnVuY3Rpb24gY29uc3RydWN0SmF2YXNjcmlwdEZ1bmN0aW9uKGRhdGEpIHtcbiAgLypqc2xpbnQgZXZpbDp0cnVlKi9cblxuICB2YXIgc291cmNlID0gJygnICsgZGF0YSArICcpJyxcbiAgICAgIGFzdCAgICA9IGVzcHJpbWEucGFyc2Uoc291cmNlLCB7IHJhbmdlOiB0cnVlIH0pLFxuICAgICAgcGFyYW1zID0gW10sXG4gICAgICBib2R5O1xuXG4gIGlmIChhc3QudHlwZSAgICAgICAgICAgICAgICAgICAgIT09ICdQcm9ncmFtJyAgICAgICAgICAgICB8fFxuICAgICAgYXN0LmJvZHkubGVuZ3RoICAgICAgICAgICAgICE9PSAxICAgICAgICAgICAgICAgICAgICAgfHxcbiAgICAgIGFzdC5ib2R5WzBdLnR5cGUgICAgICAgICAgICAhPT0gJ0V4cHJlc3Npb25TdGF0ZW1lbnQnIHx8XG4gICAgICBhc3QuYm9keVswXS5leHByZXNzaW9uLnR5cGUgIT09ICdGdW5jdGlvbkV4cHJlc3Npb24nKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdGYWlsZWQgdG8gcmVzb2x2ZSBmdW5jdGlvbicpO1xuICB9XG5cbiAgYXN0LmJvZHlbMF0uZXhwcmVzc2lvbi5wYXJhbXMuZm9yRWFjaChmdW5jdGlvbiAocGFyYW0pIHtcbiAgICBwYXJhbXMucHVzaChwYXJhbS5uYW1lKTtcbiAgfSk7XG5cbiAgYm9keSA9IGFzdC5ib2R5WzBdLmV4cHJlc3Npb24uYm9keS5yYW5nZTtcblxuICAvLyBFc3ByaW1hJ3MgcmFuZ2VzIGluY2x1ZGUgdGhlIGZpcnN0ICd7JyBhbmQgdGhlIGxhc3QgJ30nIGNoYXJhY3RlcnMgb25cbiAgLy8gZnVuY3Rpb24gZXhwcmVzc2lvbnMuIFNvIGN1dCB0aGVtIG91dC5cbiAgLyplc2xpbnQtZGlzYWJsZSBuby1uZXctZnVuYyovXG4gIHJldHVybiBuZXcgRnVuY3Rpb24ocGFyYW1zLCBzb3VyY2Uuc2xpY2UoYm9keVswXSArIDEsIGJvZHlbMV0gLSAxKSk7XG59XG5cbmZ1bmN0aW9uIHJlcHJlc2VudEphdmFzY3JpcHRGdW5jdGlvbihvYmplY3QgLyosIHN0eWxlKi8pIHtcbiAgcmV0dXJuIG9iamVjdC50b1N0cmluZygpO1xufVxuXG5mdW5jdGlvbiBpc0Z1bmN0aW9uKG9iamVjdCkge1xuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG9iamVjdCkgPT09ICdbb2JqZWN0IEZ1bmN0aW9uXSc7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gbmV3IFR5cGUoJ3RhZzp5YW1sLm9yZywyMDAyOmpzL2Z1bmN0aW9uJywge1xuICBraW5kOiAnc2NhbGFyJyxcbiAgcmVzb2x2ZTogcmVzb2x2ZUphdmFzY3JpcHRGdW5jdGlvbixcbiAgY29uc3RydWN0OiBjb25zdHJ1Y3RKYXZhc2NyaXB0RnVuY3Rpb24sXG4gIHByZWRpY2F0ZTogaXNGdW5jdGlvbixcbiAgcmVwcmVzZW50OiByZXByZXNlbnRKYXZhc2NyaXB0RnVuY3Rpb25cbn0pO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2pzLXlhbWwvbGliL2pzLXlhbWwvdHlwZS9qcy9mdW5jdGlvbi5qcyIsIihmdW5jdGlvbiB3ZWJwYWNrVW5pdmVyc2FsTW9kdWxlRGVmaW5pdGlvbihyb290LCBmYWN0b3J5KSB7XG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuXHRpZih0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSA9PT0gJ29iamVjdCcpXG5cdFx0bW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KCk7XG5cdGVsc2UgaWYodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKVxuXHRcdGRlZmluZShbXSwgZmFjdG9yeSk7XG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuXHRlbHNlIGlmKHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0Jylcblx0XHRleHBvcnRzW1wiZXNwcmltYVwiXSA9IGZhY3RvcnkoKTtcblx0ZWxzZVxuXHRcdHJvb3RbXCJlc3ByaW1hXCJdID0gZmFjdG9yeSgpO1xufSkodGhpcywgZnVuY3Rpb24oKSB7XG5yZXR1cm4gLyoqKioqKi8gKGZ1bmN0aW9uKG1vZHVsZXMpIHsgLy8gd2VicGFja0Jvb3RzdHJhcFxuLyoqKioqKi8gXHQvLyBUaGUgbW9kdWxlIGNhY2hlXG4vKioqKioqLyBcdHZhciBpbnN0YWxsZWRNb2R1bGVzID0ge307XG5cbi8qKioqKiovIFx0Ly8gVGhlIHJlcXVpcmUgZnVuY3Rpb25cbi8qKioqKiovIFx0ZnVuY3Rpb24gX193ZWJwYWNrX3JlcXVpcmVfXyhtb2R1bGVJZCkge1xuXG4vKioqKioqLyBcdFx0Ly8gQ2hlY2sgaWYgbW9kdWxlIGlzIGluIGNhY2hlXG4vKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbi8qKioqKiovIFx0XHRpZihpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSlcbi8qKioqKiovIFx0XHRcdHJldHVybiBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXS5leHBvcnRzO1xuXG4vKioqKioqLyBcdFx0Ly8gQ3JlYXRlIGEgbmV3IG1vZHVsZSAoYW5kIHB1dCBpdCBpbnRvIHRoZSBjYWNoZSlcbi8qKioqKiovIFx0XHR2YXIgbW9kdWxlID0gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0gPSB7XG4vKioqKioqLyBcdFx0XHRleHBvcnRzOiB7fSxcbi8qKioqKiovIFx0XHRcdGlkOiBtb2R1bGVJZCxcbi8qKioqKiovIFx0XHRcdGxvYWRlZDogZmFsc2Vcbi8qKioqKiovIFx0XHR9O1xuXG4vKioqKioqLyBcdFx0Ly8gRXhlY3V0ZSB0aGUgbW9kdWxlIGZ1bmN0aW9uXG4vKioqKioqLyBcdFx0bW9kdWxlc1ttb2R1bGVJZF0uY2FsbChtb2R1bGUuZXhwb3J0cywgbW9kdWxlLCBtb2R1bGUuZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXyk7XG5cbi8qKioqKiovIFx0XHQvLyBGbGFnIHRoZSBtb2R1bGUgYXMgbG9hZGVkXG4vKioqKioqLyBcdFx0bW9kdWxlLmxvYWRlZCA9IHRydWU7XG5cbi8qKioqKiovIFx0XHQvLyBSZXR1cm4gdGhlIGV4cG9ydHMgb2YgdGhlIG1vZHVsZVxuLyoqKioqKi8gXHRcdHJldHVybiBtb2R1bGUuZXhwb3J0cztcbi8qKioqKiovIFx0fVxuXG5cbi8qKioqKiovIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGVzIG9iamVjdCAoX193ZWJwYWNrX21vZHVsZXNfXylcbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5tID0gbW9kdWxlcztcblxuLyoqKioqKi8gXHQvLyBleHBvc2UgdGhlIG1vZHVsZSBjYWNoZVxuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmMgPSBpbnN0YWxsZWRNb2R1bGVzO1xuXG4vKioqKioqLyBcdC8vIF9fd2VicGFja19wdWJsaWNfcGF0aF9fXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18ucCA9IFwiXCI7XG5cbi8qKioqKiovIFx0Ly8gTG9hZCBlbnRyeSBtb2R1bGUgYW5kIHJldHVybiBleHBvcnRzXG4vKioqKioqLyBcdHJldHVybiBfX3dlYnBhY2tfcmVxdWlyZV9fKDApO1xuLyoqKioqKi8gfSlcbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqKioqLyAoW1xuLyogMCAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblx0XCJ1c2Ugc3RyaWN0XCI7XHJcblx0LypcclxuXHQgIENvcHlyaWdodCBKUyBGb3VuZGF0aW9uIGFuZCBvdGhlciBjb250cmlidXRvcnMsIGh0dHBzOi8vanMuZm91bmRhdGlvbi9cclxuXHJcblx0ICBSZWRpc3RyaWJ1dGlvbiBhbmQgdXNlIGluIHNvdXJjZSBhbmQgYmluYXJ5IGZvcm1zLCB3aXRoIG9yIHdpdGhvdXRcclxuXHQgIG1vZGlmaWNhdGlvbiwgYXJlIHBlcm1pdHRlZCBwcm92aWRlZCB0aGF0IHRoZSBmb2xsb3dpbmcgY29uZGl0aW9ucyBhcmUgbWV0OlxyXG5cclxuXHQgICAgKiBSZWRpc3RyaWJ1dGlvbnMgb2Ygc291cmNlIGNvZGUgbXVzdCByZXRhaW4gdGhlIGFib3ZlIGNvcHlyaWdodFxyXG5cdCAgICAgIG5vdGljZSwgdGhpcyBsaXN0IG9mIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmcgZGlzY2xhaW1lci5cclxuXHQgICAgKiBSZWRpc3RyaWJ1dGlvbnMgaW4gYmluYXJ5IGZvcm0gbXVzdCByZXByb2R1Y2UgdGhlIGFib3ZlIGNvcHlyaWdodFxyXG5cdCAgICAgIG5vdGljZSwgdGhpcyBsaXN0IG9mIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmcgZGlzY2xhaW1lciBpbiB0aGVcclxuXHQgICAgICBkb2N1bWVudGF0aW9uIGFuZC9vciBvdGhlciBtYXRlcmlhbHMgcHJvdmlkZWQgd2l0aCB0aGUgZGlzdHJpYnV0aW9uLlxyXG5cclxuXHQgIFRISVMgU09GVFdBUkUgSVMgUFJPVklERUQgQlkgVEhFIENPUFlSSUdIVCBIT0xERVJTIEFORCBDT05UUklCVVRPUlMgXCJBUyBJU1wiXHJcblx0ICBBTkQgQU5ZIEVYUFJFU1MgT1IgSU1QTElFRCBXQVJSQU5USUVTLCBJTkNMVURJTkcsIEJVVCBOT1QgTElNSVRFRCBUTywgVEhFXHJcblx0ICBJTVBMSUVEIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZIEFORCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRVxyXG5cdCAgQVJFIERJU0NMQUlNRUQuIElOIE5PIEVWRU5UIFNIQUxMIDxDT1BZUklHSFQgSE9MREVSPiBCRSBMSUFCTEUgRk9SIEFOWVxyXG5cdCAgRElSRUNULCBJTkRJUkVDVCwgSU5DSURFTlRBTCwgU1BFQ0lBTCwgRVhFTVBMQVJZLCBPUiBDT05TRVFVRU5USUFMIERBTUFHRVNcclxuXHQgIChJTkNMVURJTkcsIEJVVCBOT1QgTElNSVRFRCBUTywgUFJPQ1VSRU1FTlQgT0YgU1VCU1RJVFVURSBHT09EUyBPUiBTRVJWSUNFUztcclxuXHQgIExPU1MgT0YgVVNFLCBEQVRBLCBPUiBQUk9GSVRTOyBPUiBCVVNJTkVTUyBJTlRFUlJVUFRJT04pIEhPV0VWRVIgQ0FVU0VEIEFORFxyXG5cdCAgT04gQU5ZIFRIRU9SWSBPRiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQ09OVFJBQ1QsIFNUUklDVCBMSUFCSUxJVFksIE9SIFRPUlRcclxuXHQgIChJTkNMVURJTkcgTkVHTElHRU5DRSBPUiBPVEhFUldJU0UpIEFSSVNJTkcgSU4gQU5ZIFdBWSBPVVQgT0YgVEhFIFVTRSBPRlxyXG5cdCAgVEhJUyBTT0ZUV0FSRSwgRVZFTiBJRiBBRFZJU0VEIE9GIFRIRSBQT1NTSUJJTElUWSBPRiBTVUNIIERBTUFHRS5cclxuXHQqL1xyXG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuXHR2YXIgY29tbWVudF9oYW5kbGVyXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEpO1xyXG5cdHZhciBqc3hfcGFyc2VyXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMpO1xyXG5cdHZhciBwYXJzZXJfMSA9IF9fd2VicGFja19yZXF1aXJlX18oOCk7XHJcblx0dmFyIHRva2VuaXplcl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygxNSk7XHJcblx0ZnVuY3Rpb24gcGFyc2UoY29kZSwgb3B0aW9ucywgZGVsZWdhdGUpIHtcclxuXHQgICAgdmFyIGNvbW1lbnRIYW5kbGVyID0gbnVsbDtcclxuXHQgICAgdmFyIHByb3h5RGVsZWdhdGUgPSBmdW5jdGlvbiAobm9kZSwgbWV0YWRhdGEpIHtcclxuXHQgICAgICAgIGlmIChkZWxlZ2F0ZSkge1xyXG5cdCAgICAgICAgICAgIGRlbGVnYXRlKG5vZGUsIG1ldGFkYXRhKTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIGlmIChjb21tZW50SGFuZGxlcikge1xyXG5cdCAgICAgICAgICAgIGNvbW1lbnRIYW5kbGVyLnZpc2l0KG5vZGUsIG1ldGFkYXRhKTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgfTtcclxuXHQgICAgdmFyIHBhcnNlckRlbGVnYXRlID0gKHR5cGVvZiBkZWxlZ2F0ZSA9PT0gJ2Z1bmN0aW9uJykgPyBwcm94eURlbGVnYXRlIDogbnVsbDtcclxuXHQgICAgdmFyIGNvbGxlY3RDb21tZW50ID0gZmFsc2U7XHJcblx0ICAgIGlmIChvcHRpb25zKSB7XHJcblx0ICAgICAgICBjb2xsZWN0Q29tbWVudCA9ICh0eXBlb2Ygb3B0aW9ucy5jb21tZW50ID09PSAnYm9vbGVhbicgJiYgb3B0aW9ucy5jb21tZW50KTtcclxuXHQgICAgICAgIHZhciBhdHRhY2hDb21tZW50ID0gKHR5cGVvZiBvcHRpb25zLmF0dGFjaENvbW1lbnQgPT09ICdib29sZWFuJyAmJiBvcHRpb25zLmF0dGFjaENvbW1lbnQpO1xyXG5cdCAgICAgICAgaWYgKGNvbGxlY3RDb21tZW50IHx8IGF0dGFjaENvbW1lbnQpIHtcclxuXHQgICAgICAgICAgICBjb21tZW50SGFuZGxlciA9IG5ldyBjb21tZW50X2hhbmRsZXJfMS5Db21tZW50SGFuZGxlcigpO1xyXG5cdCAgICAgICAgICAgIGNvbW1lbnRIYW5kbGVyLmF0dGFjaCA9IGF0dGFjaENvbW1lbnQ7XHJcblx0ICAgICAgICAgICAgb3B0aW9ucy5jb21tZW50ID0gdHJ1ZTtcclxuXHQgICAgICAgICAgICBwYXJzZXJEZWxlZ2F0ZSA9IHByb3h5RGVsZWdhdGU7XHJcblx0ICAgICAgICB9XHJcblx0ICAgIH1cclxuXHQgICAgdmFyIGlzTW9kdWxlID0gZmFsc2U7XHJcblx0ICAgIGlmIChvcHRpb25zICYmIHR5cGVvZiBvcHRpb25zLnNvdXJjZVR5cGUgPT09ICdzdHJpbmcnKSB7XHJcblx0ICAgICAgICBpc01vZHVsZSA9IChvcHRpb25zLnNvdXJjZVR5cGUgPT09ICdtb2R1bGUnKTtcclxuXHQgICAgfVxyXG5cdCAgICB2YXIgcGFyc2VyO1xyXG5cdCAgICBpZiAob3B0aW9ucyAmJiB0eXBlb2Ygb3B0aW9ucy5qc3ggPT09ICdib29sZWFuJyAmJiBvcHRpb25zLmpzeCkge1xyXG5cdCAgICAgICAgcGFyc2VyID0gbmV3IGpzeF9wYXJzZXJfMS5KU1hQYXJzZXIoY29kZSwgb3B0aW9ucywgcGFyc2VyRGVsZWdhdGUpO1xyXG5cdCAgICB9XHJcblx0ICAgIGVsc2Uge1xyXG5cdCAgICAgICAgcGFyc2VyID0gbmV3IHBhcnNlcl8xLlBhcnNlcihjb2RlLCBvcHRpb25zLCBwYXJzZXJEZWxlZ2F0ZSk7XHJcblx0ICAgIH1cclxuXHQgICAgdmFyIHByb2dyYW0gPSBpc01vZHVsZSA/IHBhcnNlci5wYXJzZU1vZHVsZSgpIDogcGFyc2VyLnBhcnNlU2NyaXB0KCk7XHJcblx0ICAgIHZhciBhc3QgPSBwcm9ncmFtO1xyXG5cdCAgICBpZiAoY29sbGVjdENvbW1lbnQgJiYgY29tbWVudEhhbmRsZXIpIHtcclxuXHQgICAgICAgIGFzdC5jb21tZW50cyA9IGNvbW1lbnRIYW5kbGVyLmNvbW1lbnRzO1xyXG5cdCAgICB9XHJcblx0ICAgIGlmIChwYXJzZXIuY29uZmlnLnRva2Vucykge1xyXG5cdCAgICAgICAgYXN0LnRva2VucyA9IHBhcnNlci50b2tlbnM7XHJcblx0ICAgIH1cclxuXHQgICAgaWYgKHBhcnNlci5jb25maWcudG9sZXJhbnQpIHtcclxuXHQgICAgICAgIGFzdC5lcnJvcnMgPSBwYXJzZXIuZXJyb3JIYW5kbGVyLmVycm9ycztcclxuXHQgICAgfVxyXG5cdCAgICByZXR1cm4gYXN0O1xyXG5cdH1cclxuXHRleHBvcnRzLnBhcnNlID0gcGFyc2U7XHJcblx0ZnVuY3Rpb24gcGFyc2VNb2R1bGUoY29kZSwgb3B0aW9ucywgZGVsZWdhdGUpIHtcclxuXHQgICAgdmFyIHBhcnNpbmdPcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcclxuXHQgICAgcGFyc2luZ09wdGlvbnMuc291cmNlVHlwZSA9ICdtb2R1bGUnO1xyXG5cdCAgICByZXR1cm4gcGFyc2UoY29kZSwgcGFyc2luZ09wdGlvbnMsIGRlbGVnYXRlKTtcclxuXHR9XHJcblx0ZXhwb3J0cy5wYXJzZU1vZHVsZSA9IHBhcnNlTW9kdWxlO1xyXG5cdGZ1bmN0aW9uIHBhcnNlU2NyaXB0KGNvZGUsIG9wdGlvbnMsIGRlbGVnYXRlKSB7XHJcblx0ICAgIHZhciBwYXJzaW5nT3B0aW9ucyA9IG9wdGlvbnMgfHwge307XHJcblx0ICAgIHBhcnNpbmdPcHRpb25zLnNvdXJjZVR5cGUgPSAnc2NyaXB0JztcclxuXHQgICAgcmV0dXJuIHBhcnNlKGNvZGUsIHBhcnNpbmdPcHRpb25zLCBkZWxlZ2F0ZSk7XHJcblx0fVxyXG5cdGV4cG9ydHMucGFyc2VTY3JpcHQgPSBwYXJzZVNjcmlwdDtcclxuXHRmdW5jdGlvbiB0b2tlbml6ZShjb2RlLCBvcHRpb25zLCBkZWxlZ2F0ZSkge1xyXG5cdCAgICB2YXIgdG9rZW5pemVyID0gbmV3IHRva2VuaXplcl8xLlRva2VuaXplcihjb2RlLCBvcHRpb25zKTtcclxuXHQgICAgdmFyIHRva2VucztcclxuXHQgICAgdG9rZW5zID0gW107XHJcblx0ICAgIHRyeSB7XHJcblx0ICAgICAgICB3aGlsZSAodHJ1ZSkge1xyXG5cdCAgICAgICAgICAgIHZhciB0b2tlbiA9IHRva2VuaXplci5nZXROZXh0VG9rZW4oKTtcclxuXHQgICAgICAgICAgICBpZiAoIXRva2VuKSB7XHJcblx0ICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICBpZiAoZGVsZWdhdGUpIHtcclxuXHQgICAgICAgICAgICAgICAgdG9rZW4gPSBkZWxlZ2F0ZSh0b2tlbik7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgIHRva2Vucy5wdXNoKHRva2VuKTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgfVxyXG5cdCAgICBjYXRjaCAoZSkge1xyXG5cdCAgICAgICAgdG9rZW5pemVyLmVycm9ySGFuZGxlci50b2xlcmF0ZShlKTtcclxuXHQgICAgfVxyXG5cdCAgICBpZiAodG9rZW5pemVyLmVycm9ySGFuZGxlci50b2xlcmFudCkge1xyXG5cdCAgICAgICAgdG9rZW5zLmVycm9ycyA9IHRva2VuaXplci5lcnJvcnMoKTtcclxuXHQgICAgfVxyXG5cdCAgICByZXR1cm4gdG9rZW5zO1xyXG5cdH1cclxuXHRleHBvcnRzLnRva2VuaXplID0gdG9rZW5pemU7XHJcblx0dmFyIHN5bnRheF8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygyKTtcclxuXHRleHBvcnRzLlN5bnRheCA9IHN5bnRheF8xLlN5bnRheDtcclxuXHQvLyBTeW5jIHdpdGggKi5qc29uIG1hbmlmZXN0cy5cclxuXHRleHBvcnRzLnZlcnNpb24gPSAnNC4wLjAnO1xyXG5cblxuLyoqKi8gfSxcbi8qIDEgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cdFwidXNlIHN0cmljdFwiO1xyXG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuXHR2YXIgc3ludGF4XzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIpO1xyXG5cdHZhciBDb21tZW50SGFuZGxlciA9IChmdW5jdGlvbiAoKSB7XHJcblx0ICAgIGZ1bmN0aW9uIENvbW1lbnRIYW5kbGVyKCkge1xyXG5cdCAgICAgICAgdGhpcy5hdHRhY2ggPSBmYWxzZTtcclxuXHQgICAgICAgIHRoaXMuY29tbWVudHMgPSBbXTtcclxuXHQgICAgICAgIHRoaXMuc3RhY2sgPSBbXTtcclxuXHQgICAgICAgIHRoaXMubGVhZGluZyA9IFtdO1xyXG5cdCAgICAgICAgdGhpcy50cmFpbGluZyA9IFtdO1xyXG5cdCAgICB9XHJcblx0ICAgIENvbW1lbnRIYW5kbGVyLnByb3RvdHlwZS5pbnNlcnRJbm5lckNvbW1lbnRzID0gZnVuY3Rpb24gKG5vZGUsIG1ldGFkYXRhKSB7XHJcblx0ICAgICAgICAvLyAgaW5ubmVyQ29tbWVudHMgZm9yIHByb3BlcnRpZXMgZW1wdHkgYmxvY2tcclxuXHQgICAgICAgIC8vICBgZnVuY3Rpb24gYSgpIHsvKiogY29tbWVudHMgKipcXC99YFxyXG5cdCAgICAgICAgaWYgKG5vZGUudHlwZSA9PT0gc3ludGF4XzEuU3ludGF4LkJsb2NrU3RhdGVtZW50ICYmIG5vZGUuYm9keS5sZW5ndGggPT09IDApIHtcclxuXHQgICAgICAgICAgICB2YXIgaW5uZXJDb21tZW50cyA9IFtdO1xyXG5cdCAgICAgICAgICAgIGZvciAodmFyIGkgPSB0aGlzLmxlYWRpbmcubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcclxuXHQgICAgICAgICAgICAgICAgdmFyIGVudHJ5ID0gdGhpcy5sZWFkaW5nW2ldO1xyXG5cdCAgICAgICAgICAgICAgICBpZiAobWV0YWRhdGEuZW5kLm9mZnNldCA+PSBlbnRyeS5zdGFydCkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgaW5uZXJDb21tZW50cy51bnNoaWZ0KGVudHJ5LmNvbW1lbnQpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgdGhpcy5sZWFkaW5nLnNwbGljZShpLCAxKTtcclxuXHQgICAgICAgICAgICAgICAgICAgIHRoaXMudHJhaWxpbmcuc3BsaWNlKGksIDEpO1xyXG5cdCAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgIGlmIChpbm5lckNvbW1lbnRzLmxlbmd0aCkge1xyXG5cdCAgICAgICAgICAgICAgICBub2RlLmlubmVyQ29tbWVudHMgPSBpbm5lckNvbW1lbnRzO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgIH1cclxuXHQgICAgfTtcclxuXHQgICAgQ29tbWVudEhhbmRsZXIucHJvdG90eXBlLmZpbmRUcmFpbGluZ0NvbW1lbnRzID0gZnVuY3Rpb24gKG1ldGFkYXRhKSB7XHJcblx0ICAgICAgICB2YXIgdHJhaWxpbmdDb21tZW50cyA9IFtdO1xyXG5cdCAgICAgICAgaWYgKHRoaXMudHJhaWxpbmcubGVuZ3RoID4gMCkge1xyXG5cdCAgICAgICAgICAgIGZvciAodmFyIGkgPSB0aGlzLnRyYWlsaW5nLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XHJcblx0ICAgICAgICAgICAgICAgIHZhciBlbnRyeV8xID0gdGhpcy50cmFpbGluZ1tpXTtcclxuXHQgICAgICAgICAgICAgICAgaWYgKGVudHJ5XzEuc3RhcnQgPj0gbWV0YWRhdGEuZW5kLm9mZnNldCkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgdHJhaWxpbmdDb21tZW50cy51bnNoaWZ0KGVudHJ5XzEuY29tbWVudCk7XHJcblx0ICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgdGhpcy50cmFpbGluZy5sZW5ndGggPSAwO1xyXG5cdCAgICAgICAgICAgIHJldHVybiB0cmFpbGluZ0NvbW1lbnRzO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgdmFyIGVudHJ5ID0gdGhpcy5zdGFja1t0aGlzLnN0YWNrLmxlbmd0aCAtIDFdO1xyXG5cdCAgICAgICAgaWYgKGVudHJ5ICYmIGVudHJ5Lm5vZGUudHJhaWxpbmdDb21tZW50cykge1xyXG5cdCAgICAgICAgICAgIHZhciBmaXJzdENvbW1lbnQgPSBlbnRyeS5ub2RlLnRyYWlsaW5nQ29tbWVudHNbMF07XHJcblx0ICAgICAgICAgICAgaWYgKGZpcnN0Q29tbWVudCAmJiBmaXJzdENvbW1lbnQucmFuZ2VbMF0gPj0gbWV0YWRhdGEuZW5kLm9mZnNldCkge1xyXG5cdCAgICAgICAgICAgICAgICB0cmFpbGluZ0NvbW1lbnRzID0gZW50cnkubm9kZS50cmFpbGluZ0NvbW1lbnRzO1xyXG5cdCAgICAgICAgICAgICAgICBkZWxldGUgZW50cnkubm9kZS50cmFpbGluZ0NvbW1lbnRzO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIHJldHVybiB0cmFpbGluZ0NvbW1lbnRzO1xyXG5cdCAgICB9O1xyXG5cdCAgICBDb21tZW50SGFuZGxlci5wcm90b3R5cGUuZmluZExlYWRpbmdDb21tZW50cyA9IGZ1bmN0aW9uIChtZXRhZGF0YSkge1xyXG5cdCAgICAgICAgdmFyIGxlYWRpbmdDb21tZW50cyA9IFtdO1xyXG5cdCAgICAgICAgdmFyIHRhcmdldDtcclxuXHQgICAgICAgIHdoaWxlICh0aGlzLnN0YWNrLmxlbmd0aCA+IDApIHtcclxuXHQgICAgICAgICAgICB2YXIgZW50cnkgPSB0aGlzLnN0YWNrW3RoaXMuc3RhY2subGVuZ3RoIC0gMV07XHJcblx0ICAgICAgICAgICAgaWYgKGVudHJ5ICYmIGVudHJ5LnN0YXJ0ID49IG1ldGFkYXRhLnN0YXJ0Lm9mZnNldCkge1xyXG5cdCAgICAgICAgICAgICAgICB0YXJnZXQgPSBlbnRyeS5ub2RlO1xyXG5cdCAgICAgICAgICAgICAgICB0aGlzLnN0YWNrLnBvcCgpO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICBlbHNlIHtcclxuXHQgICAgICAgICAgICAgICAgYnJlYWs7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgaWYgKHRhcmdldCkge1xyXG5cdCAgICAgICAgICAgIHZhciBjb3VudCA9IHRhcmdldC5sZWFkaW5nQ29tbWVudHMgPyB0YXJnZXQubGVhZGluZ0NvbW1lbnRzLmxlbmd0aCA6IDA7XHJcblx0ICAgICAgICAgICAgZm9yICh2YXIgaSA9IGNvdW50IC0gMTsgaSA+PSAwOyAtLWkpIHtcclxuXHQgICAgICAgICAgICAgICAgdmFyIGNvbW1lbnQgPSB0YXJnZXQubGVhZGluZ0NvbW1lbnRzW2ldO1xyXG5cdCAgICAgICAgICAgICAgICBpZiAoY29tbWVudC5yYW5nZVsxXSA8PSBtZXRhZGF0YS5zdGFydC5vZmZzZXQpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgIGxlYWRpbmdDb21tZW50cy51bnNoaWZ0KGNvbW1lbnQpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgdGFyZ2V0LmxlYWRpbmdDb21tZW50cy5zcGxpY2UoaSwgMSk7XHJcblx0ICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgaWYgKHRhcmdldC5sZWFkaW5nQ29tbWVudHMgJiYgdGFyZ2V0LmxlYWRpbmdDb21tZW50cy5sZW5ndGggPT09IDApIHtcclxuXHQgICAgICAgICAgICAgICAgZGVsZXRlIHRhcmdldC5sZWFkaW5nQ29tbWVudHM7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgIHJldHVybiBsZWFkaW5nQ29tbWVudHM7XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICBmb3IgKHZhciBpID0gdGhpcy5sZWFkaW5nLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XHJcblx0ICAgICAgICAgICAgdmFyIGVudHJ5ID0gdGhpcy5sZWFkaW5nW2ldO1xyXG5cdCAgICAgICAgICAgIGlmIChlbnRyeS5zdGFydCA8PSBtZXRhZGF0YS5zdGFydC5vZmZzZXQpIHtcclxuXHQgICAgICAgICAgICAgICAgbGVhZGluZ0NvbW1lbnRzLnVuc2hpZnQoZW50cnkuY29tbWVudCk7XHJcblx0ICAgICAgICAgICAgICAgIHRoaXMubGVhZGluZy5zcGxpY2UoaSwgMSk7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgcmV0dXJuIGxlYWRpbmdDb21tZW50cztcclxuXHQgICAgfTtcclxuXHQgICAgQ29tbWVudEhhbmRsZXIucHJvdG90eXBlLnZpc2l0Tm9kZSA9IGZ1bmN0aW9uIChub2RlLCBtZXRhZGF0YSkge1xyXG5cdCAgICAgICAgaWYgKG5vZGUudHlwZSA9PT0gc3ludGF4XzEuU3ludGF4LlByb2dyYW0gJiYgbm9kZS5ib2R5Lmxlbmd0aCA+IDApIHtcclxuXHQgICAgICAgICAgICByZXR1cm47XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICB0aGlzLmluc2VydElubmVyQ29tbWVudHMobm9kZSwgbWV0YWRhdGEpO1xyXG5cdCAgICAgICAgdmFyIHRyYWlsaW5nQ29tbWVudHMgPSB0aGlzLmZpbmRUcmFpbGluZ0NvbW1lbnRzKG1ldGFkYXRhKTtcclxuXHQgICAgICAgIHZhciBsZWFkaW5nQ29tbWVudHMgPSB0aGlzLmZpbmRMZWFkaW5nQ29tbWVudHMobWV0YWRhdGEpO1xyXG5cdCAgICAgICAgaWYgKGxlYWRpbmdDb21tZW50cy5sZW5ndGggPiAwKSB7XHJcblx0ICAgICAgICAgICAgbm9kZS5sZWFkaW5nQ29tbWVudHMgPSBsZWFkaW5nQ29tbWVudHM7XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICBpZiAodHJhaWxpbmdDb21tZW50cy5sZW5ndGggPiAwKSB7XHJcblx0ICAgICAgICAgICAgbm9kZS50cmFpbGluZ0NvbW1lbnRzID0gdHJhaWxpbmdDb21tZW50cztcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIHRoaXMuc3RhY2sucHVzaCh7XHJcblx0ICAgICAgICAgICAgbm9kZTogbm9kZSxcclxuXHQgICAgICAgICAgICBzdGFydDogbWV0YWRhdGEuc3RhcnQub2Zmc2V0XHJcblx0ICAgICAgICB9KTtcclxuXHQgICAgfTtcclxuXHQgICAgQ29tbWVudEhhbmRsZXIucHJvdG90eXBlLnZpc2l0Q29tbWVudCA9IGZ1bmN0aW9uIChub2RlLCBtZXRhZGF0YSkge1xyXG5cdCAgICAgICAgdmFyIHR5cGUgPSAobm9kZS50eXBlWzBdID09PSAnTCcpID8gJ0xpbmUnIDogJ0Jsb2NrJztcclxuXHQgICAgICAgIHZhciBjb21tZW50ID0ge1xyXG5cdCAgICAgICAgICAgIHR5cGU6IHR5cGUsXHJcblx0ICAgICAgICAgICAgdmFsdWU6IG5vZGUudmFsdWVcclxuXHQgICAgICAgIH07XHJcblx0ICAgICAgICBpZiAobm9kZS5yYW5nZSkge1xyXG5cdCAgICAgICAgICAgIGNvbW1lbnQucmFuZ2UgPSBub2RlLnJhbmdlO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgaWYgKG5vZGUubG9jKSB7XHJcblx0ICAgICAgICAgICAgY29tbWVudC5sb2MgPSBub2RlLmxvYztcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIHRoaXMuY29tbWVudHMucHVzaChjb21tZW50KTtcclxuXHQgICAgICAgIGlmICh0aGlzLmF0dGFjaCkge1xyXG5cdCAgICAgICAgICAgIHZhciBlbnRyeSA9IHtcclxuXHQgICAgICAgICAgICAgICAgY29tbWVudDoge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgdHlwZTogdHlwZSxcclxuXHQgICAgICAgICAgICAgICAgICAgIHZhbHVlOiBub2RlLnZhbHVlLFxyXG5cdCAgICAgICAgICAgICAgICAgICAgcmFuZ2U6IFttZXRhZGF0YS5zdGFydC5vZmZzZXQsIG1ldGFkYXRhLmVuZC5vZmZzZXRdXHJcblx0ICAgICAgICAgICAgICAgIH0sXHJcblx0ICAgICAgICAgICAgICAgIHN0YXJ0OiBtZXRhZGF0YS5zdGFydC5vZmZzZXRcclxuXHQgICAgICAgICAgICB9O1xyXG5cdCAgICAgICAgICAgIGlmIChub2RlLmxvYykge1xyXG5cdCAgICAgICAgICAgICAgICBlbnRyeS5jb21tZW50LmxvYyA9IG5vZGUubG9jO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICBub2RlLnR5cGUgPSB0eXBlO1xyXG5cdCAgICAgICAgICAgIHRoaXMubGVhZGluZy5wdXNoKGVudHJ5KTtcclxuXHQgICAgICAgICAgICB0aGlzLnRyYWlsaW5nLnB1c2goZW50cnkpO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICB9O1xyXG5cdCAgICBDb21tZW50SGFuZGxlci5wcm90b3R5cGUudmlzaXQgPSBmdW5jdGlvbiAobm9kZSwgbWV0YWRhdGEpIHtcclxuXHQgICAgICAgIGlmIChub2RlLnR5cGUgPT09ICdMaW5lQ29tbWVudCcpIHtcclxuXHQgICAgICAgICAgICB0aGlzLnZpc2l0Q29tbWVudChub2RlLCBtZXRhZGF0YSk7XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICBlbHNlIGlmIChub2RlLnR5cGUgPT09ICdCbG9ja0NvbW1lbnQnKSB7XHJcblx0ICAgICAgICAgICAgdGhpcy52aXNpdENvbW1lbnQobm9kZSwgbWV0YWRhdGEpO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgZWxzZSBpZiAodGhpcy5hdHRhY2gpIHtcclxuXHQgICAgICAgICAgICB0aGlzLnZpc2l0Tm9kZShub2RlLCBtZXRhZGF0YSk7XHJcblx0ICAgICAgICB9XHJcblx0ICAgIH07XHJcblx0ICAgIHJldHVybiBDb21tZW50SGFuZGxlcjtcclxuXHR9KCkpO1xyXG5cdGV4cG9ydHMuQ29tbWVudEhhbmRsZXIgPSBDb21tZW50SGFuZGxlcjtcclxuXG5cbi8qKiovIH0sXG4vKiAyICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxuXHRcInVzZSBzdHJpY3RcIjtcclxuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcblx0ZXhwb3J0cy5TeW50YXggPSB7XHJcblx0ICAgIEFzc2lnbm1lbnRFeHByZXNzaW9uOiAnQXNzaWdubWVudEV4cHJlc3Npb24nLFxyXG5cdCAgICBBc3NpZ25tZW50UGF0dGVybjogJ0Fzc2lnbm1lbnRQYXR0ZXJuJyxcclxuXHQgICAgQXJyYXlFeHByZXNzaW9uOiAnQXJyYXlFeHByZXNzaW9uJyxcclxuXHQgICAgQXJyYXlQYXR0ZXJuOiAnQXJyYXlQYXR0ZXJuJyxcclxuXHQgICAgQXJyb3dGdW5jdGlvbkV4cHJlc3Npb246ICdBcnJvd0Z1bmN0aW9uRXhwcmVzc2lvbicsXHJcblx0ICAgIEF3YWl0RXhwcmVzc2lvbjogJ0F3YWl0RXhwcmVzc2lvbicsXHJcblx0ICAgIEJsb2NrU3RhdGVtZW50OiAnQmxvY2tTdGF0ZW1lbnQnLFxyXG5cdCAgICBCaW5hcnlFeHByZXNzaW9uOiAnQmluYXJ5RXhwcmVzc2lvbicsXHJcblx0ICAgIEJyZWFrU3RhdGVtZW50OiAnQnJlYWtTdGF0ZW1lbnQnLFxyXG5cdCAgICBDYWxsRXhwcmVzc2lvbjogJ0NhbGxFeHByZXNzaW9uJyxcclxuXHQgICAgQ2F0Y2hDbGF1c2U6ICdDYXRjaENsYXVzZScsXHJcblx0ICAgIENsYXNzQm9keTogJ0NsYXNzQm9keScsXHJcblx0ICAgIENsYXNzRGVjbGFyYXRpb246ICdDbGFzc0RlY2xhcmF0aW9uJyxcclxuXHQgICAgQ2xhc3NFeHByZXNzaW9uOiAnQ2xhc3NFeHByZXNzaW9uJyxcclxuXHQgICAgQ29uZGl0aW9uYWxFeHByZXNzaW9uOiAnQ29uZGl0aW9uYWxFeHByZXNzaW9uJyxcclxuXHQgICAgQ29udGludWVTdGF0ZW1lbnQ6ICdDb250aW51ZVN0YXRlbWVudCcsXHJcblx0ICAgIERvV2hpbGVTdGF0ZW1lbnQ6ICdEb1doaWxlU3RhdGVtZW50JyxcclxuXHQgICAgRGVidWdnZXJTdGF0ZW1lbnQ6ICdEZWJ1Z2dlclN0YXRlbWVudCcsXHJcblx0ICAgIEVtcHR5U3RhdGVtZW50OiAnRW1wdHlTdGF0ZW1lbnQnLFxyXG5cdCAgICBFeHBvcnRBbGxEZWNsYXJhdGlvbjogJ0V4cG9ydEFsbERlY2xhcmF0aW9uJyxcclxuXHQgICAgRXhwb3J0RGVmYXVsdERlY2xhcmF0aW9uOiAnRXhwb3J0RGVmYXVsdERlY2xhcmF0aW9uJyxcclxuXHQgICAgRXhwb3J0TmFtZWREZWNsYXJhdGlvbjogJ0V4cG9ydE5hbWVkRGVjbGFyYXRpb24nLFxyXG5cdCAgICBFeHBvcnRTcGVjaWZpZXI6ICdFeHBvcnRTcGVjaWZpZXInLFxyXG5cdCAgICBFeHByZXNzaW9uU3RhdGVtZW50OiAnRXhwcmVzc2lvblN0YXRlbWVudCcsXHJcblx0ICAgIEZvclN0YXRlbWVudDogJ0ZvclN0YXRlbWVudCcsXHJcblx0ICAgIEZvck9mU3RhdGVtZW50OiAnRm9yT2ZTdGF0ZW1lbnQnLFxyXG5cdCAgICBGb3JJblN0YXRlbWVudDogJ0ZvckluU3RhdGVtZW50JyxcclxuXHQgICAgRnVuY3Rpb25EZWNsYXJhdGlvbjogJ0Z1bmN0aW9uRGVjbGFyYXRpb24nLFxyXG5cdCAgICBGdW5jdGlvbkV4cHJlc3Npb246ICdGdW5jdGlvbkV4cHJlc3Npb24nLFxyXG5cdCAgICBJZGVudGlmaWVyOiAnSWRlbnRpZmllcicsXHJcblx0ICAgIElmU3RhdGVtZW50OiAnSWZTdGF0ZW1lbnQnLFxyXG5cdCAgICBJbXBvcnREZWNsYXJhdGlvbjogJ0ltcG9ydERlY2xhcmF0aW9uJyxcclxuXHQgICAgSW1wb3J0RGVmYXVsdFNwZWNpZmllcjogJ0ltcG9ydERlZmF1bHRTcGVjaWZpZXInLFxyXG5cdCAgICBJbXBvcnROYW1lc3BhY2VTcGVjaWZpZXI6ICdJbXBvcnROYW1lc3BhY2VTcGVjaWZpZXInLFxyXG5cdCAgICBJbXBvcnRTcGVjaWZpZXI6ICdJbXBvcnRTcGVjaWZpZXInLFxyXG5cdCAgICBMaXRlcmFsOiAnTGl0ZXJhbCcsXHJcblx0ICAgIExhYmVsZWRTdGF0ZW1lbnQ6ICdMYWJlbGVkU3RhdGVtZW50JyxcclxuXHQgICAgTG9naWNhbEV4cHJlc3Npb246ICdMb2dpY2FsRXhwcmVzc2lvbicsXHJcblx0ICAgIE1lbWJlckV4cHJlc3Npb246ICdNZW1iZXJFeHByZXNzaW9uJyxcclxuXHQgICAgTWV0YVByb3BlcnR5OiAnTWV0YVByb3BlcnR5JyxcclxuXHQgICAgTWV0aG9kRGVmaW5pdGlvbjogJ01ldGhvZERlZmluaXRpb24nLFxyXG5cdCAgICBOZXdFeHByZXNzaW9uOiAnTmV3RXhwcmVzc2lvbicsXHJcblx0ICAgIE9iamVjdEV4cHJlc3Npb246ICdPYmplY3RFeHByZXNzaW9uJyxcclxuXHQgICAgT2JqZWN0UGF0dGVybjogJ09iamVjdFBhdHRlcm4nLFxyXG5cdCAgICBQcm9ncmFtOiAnUHJvZ3JhbScsXHJcblx0ICAgIFByb3BlcnR5OiAnUHJvcGVydHknLFxyXG5cdCAgICBSZXN0RWxlbWVudDogJ1Jlc3RFbGVtZW50JyxcclxuXHQgICAgUmV0dXJuU3RhdGVtZW50OiAnUmV0dXJuU3RhdGVtZW50JyxcclxuXHQgICAgU2VxdWVuY2VFeHByZXNzaW9uOiAnU2VxdWVuY2VFeHByZXNzaW9uJyxcclxuXHQgICAgU3ByZWFkRWxlbWVudDogJ1NwcmVhZEVsZW1lbnQnLFxyXG5cdCAgICBTdXBlcjogJ1N1cGVyJyxcclxuXHQgICAgU3dpdGNoQ2FzZTogJ1N3aXRjaENhc2UnLFxyXG5cdCAgICBTd2l0Y2hTdGF0ZW1lbnQ6ICdTd2l0Y2hTdGF0ZW1lbnQnLFxyXG5cdCAgICBUYWdnZWRUZW1wbGF0ZUV4cHJlc3Npb246ICdUYWdnZWRUZW1wbGF0ZUV4cHJlc3Npb24nLFxyXG5cdCAgICBUZW1wbGF0ZUVsZW1lbnQ6ICdUZW1wbGF0ZUVsZW1lbnQnLFxyXG5cdCAgICBUZW1wbGF0ZUxpdGVyYWw6ICdUZW1wbGF0ZUxpdGVyYWwnLFxyXG5cdCAgICBUaGlzRXhwcmVzc2lvbjogJ1RoaXNFeHByZXNzaW9uJyxcclxuXHQgICAgVGhyb3dTdGF0ZW1lbnQ6ICdUaHJvd1N0YXRlbWVudCcsXHJcblx0ICAgIFRyeVN0YXRlbWVudDogJ1RyeVN0YXRlbWVudCcsXHJcblx0ICAgIFVuYXJ5RXhwcmVzc2lvbjogJ1VuYXJ5RXhwcmVzc2lvbicsXHJcblx0ICAgIFVwZGF0ZUV4cHJlc3Npb246ICdVcGRhdGVFeHByZXNzaW9uJyxcclxuXHQgICAgVmFyaWFibGVEZWNsYXJhdGlvbjogJ1ZhcmlhYmxlRGVjbGFyYXRpb24nLFxyXG5cdCAgICBWYXJpYWJsZURlY2xhcmF0b3I6ICdWYXJpYWJsZURlY2xhcmF0b3InLFxyXG5cdCAgICBXaGlsZVN0YXRlbWVudDogJ1doaWxlU3RhdGVtZW50JyxcclxuXHQgICAgV2l0aFN0YXRlbWVudDogJ1dpdGhTdGF0ZW1lbnQnLFxyXG5cdCAgICBZaWVsZEV4cHJlc3Npb246ICdZaWVsZEV4cHJlc3Npb24nXHJcblx0fTtcclxuXG5cbi8qKiovIH0sXG4vKiAzICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXHRcInVzZSBzdHJpY3RcIjtcclxuLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cblx0dmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xyXG5cdCAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxyXG5cdCAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxyXG5cdCAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07XHJcblx0ICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xyXG5cdCAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcclxuXHQgICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxyXG5cdCAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xyXG5cdCAgICB9O1xyXG5cdH0pKCk7XHJcblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG5cdHZhciBjaGFyYWN0ZXJfMSA9IF9fd2VicGFja19yZXF1aXJlX18oNCk7XHJcblx0dmFyIEpTWE5vZGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDUpO1xyXG5cdHZhciBqc3hfc3ludGF4XzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDYpO1xyXG5cdHZhciBOb2RlID0gX193ZWJwYWNrX3JlcXVpcmVfXyg3KTtcclxuXHR2YXIgcGFyc2VyXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDgpO1xyXG5cdHZhciB0b2tlbl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMyk7XHJcblx0dmFyIHhodG1sX2VudGl0aWVzXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE0KTtcclxuXHR0b2tlbl8xLlRva2VuTmFtZVsxMDAgLyogSWRlbnRpZmllciAqL10gPSAnSlNYSWRlbnRpZmllcic7XHJcblx0dG9rZW5fMS5Ub2tlbk5hbWVbMTAxIC8qIFRleHQgKi9dID0gJ0pTWFRleHQnO1xyXG5cdC8vIEZ1bGx5IHF1YWxpZmllZCBlbGVtZW50IG5hbWUsIGUuZy4gPHN2ZzpwYXRoPiByZXR1cm5zIFwic3ZnOnBhdGhcIlxyXG5cdGZ1bmN0aW9uIGdldFF1YWxpZmllZEVsZW1lbnROYW1lKGVsZW1lbnROYW1lKSB7XHJcblx0ICAgIHZhciBxdWFsaWZpZWROYW1lO1xyXG5cdCAgICBzd2l0Y2ggKGVsZW1lbnROYW1lLnR5cGUpIHtcclxuXHQgICAgICAgIGNhc2UganN4X3N5bnRheF8xLkpTWFN5bnRheC5KU1hJZGVudGlmaWVyOlxyXG5cdCAgICAgICAgICAgIHZhciBpZCA9IGVsZW1lbnROYW1lO1xyXG5cdCAgICAgICAgICAgIHF1YWxpZmllZE5hbWUgPSBpZC5uYW1lO1xyXG5cdCAgICAgICAgICAgIGJyZWFrO1xyXG5cdCAgICAgICAgY2FzZSBqc3hfc3ludGF4XzEuSlNYU3ludGF4LkpTWE5hbWVzcGFjZWROYW1lOlxyXG5cdCAgICAgICAgICAgIHZhciBucyA9IGVsZW1lbnROYW1lO1xyXG5cdCAgICAgICAgICAgIHF1YWxpZmllZE5hbWUgPSBnZXRRdWFsaWZpZWRFbGVtZW50TmFtZShucy5uYW1lc3BhY2UpICsgJzonICtcclxuXHQgICAgICAgICAgICAgICAgZ2V0UXVhbGlmaWVkRWxlbWVudE5hbWUobnMubmFtZSk7XHJcblx0ICAgICAgICAgICAgYnJlYWs7XHJcblx0ICAgICAgICBjYXNlIGpzeF9zeW50YXhfMS5KU1hTeW50YXguSlNYTWVtYmVyRXhwcmVzc2lvbjpcclxuXHQgICAgICAgICAgICB2YXIgZXhwciA9IGVsZW1lbnROYW1lO1xyXG5cdCAgICAgICAgICAgIHF1YWxpZmllZE5hbWUgPSBnZXRRdWFsaWZpZWRFbGVtZW50TmFtZShleHByLm9iamVjdCkgKyAnLicgK1xyXG5cdCAgICAgICAgICAgICAgICBnZXRRdWFsaWZpZWRFbGVtZW50TmFtZShleHByLnByb3BlcnR5KTtcclxuXHQgICAgICAgICAgICBicmVhaztcclxuXHQgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXHJcblx0ICAgICAgICBkZWZhdWx0OlxyXG5cdCAgICAgICAgICAgIGJyZWFrO1xyXG5cdCAgICB9XHJcblx0ICAgIHJldHVybiBxdWFsaWZpZWROYW1lO1xyXG5cdH1cclxuXHR2YXIgSlNYUGFyc2VyID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuXHQgICAgX19leHRlbmRzKEpTWFBhcnNlciwgX3N1cGVyKTtcclxuXHQgICAgZnVuY3Rpb24gSlNYUGFyc2VyKGNvZGUsIG9wdGlvbnMsIGRlbGVnYXRlKSB7XHJcblx0ICAgICAgICByZXR1cm4gX3N1cGVyLmNhbGwodGhpcywgY29kZSwgb3B0aW9ucywgZGVsZWdhdGUpIHx8IHRoaXM7XHJcblx0ICAgIH1cclxuXHQgICAgSlNYUGFyc2VyLnByb3RvdHlwZS5wYXJzZVByaW1hcnlFeHByZXNzaW9uID0gZnVuY3Rpb24gKCkge1xyXG5cdCAgICAgICAgcmV0dXJuIHRoaXMubWF0Y2goJzwnKSA/IHRoaXMucGFyc2VKU1hSb290KCkgOiBfc3VwZXIucHJvdG90eXBlLnBhcnNlUHJpbWFyeUV4cHJlc3Npb24uY2FsbCh0aGlzKTtcclxuXHQgICAgfTtcclxuXHQgICAgSlNYUGFyc2VyLnByb3RvdHlwZS5zdGFydEpTWCA9IGZ1bmN0aW9uICgpIHtcclxuXHQgICAgICAgIC8vIFVud2luZCB0aGUgc2Nhbm5lciBiZWZvcmUgdGhlIGxvb2thaGVhZCB0b2tlbi5cclxuXHQgICAgICAgIHRoaXMuc2Nhbm5lci5pbmRleCA9IHRoaXMuc3RhcnRNYXJrZXIuaW5kZXg7XHJcblx0ICAgICAgICB0aGlzLnNjYW5uZXIubGluZU51bWJlciA9IHRoaXMuc3RhcnRNYXJrZXIubGluZTtcclxuXHQgICAgICAgIHRoaXMuc2Nhbm5lci5saW5lU3RhcnQgPSB0aGlzLnN0YXJ0TWFya2VyLmluZGV4IC0gdGhpcy5zdGFydE1hcmtlci5jb2x1bW47XHJcblx0ICAgIH07XHJcblx0ICAgIEpTWFBhcnNlci5wcm90b3R5cGUuZmluaXNoSlNYID0gZnVuY3Rpb24gKCkge1xyXG5cdCAgICAgICAgLy8gUHJpbWUgdGhlIG5leHQgbG9va2FoZWFkLlxyXG5cdCAgICAgICAgdGhpcy5uZXh0VG9rZW4oKTtcclxuXHQgICAgfTtcclxuXHQgICAgSlNYUGFyc2VyLnByb3RvdHlwZS5yZWVudGVySlNYID0gZnVuY3Rpb24gKCkge1xyXG5cdCAgICAgICAgdGhpcy5zdGFydEpTWCgpO1xyXG5cdCAgICAgICAgdGhpcy5leHBlY3RKU1goJ30nKTtcclxuXHQgICAgICAgIC8vIFBvcCB0aGUgY2xvc2luZyAnfScgYWRkZWQgZnJvbSB0aGUgbG9va2FoZWFkLlxyXG5cdCAgICAgICAgaWYgKHRoaXMuY29uZmlnLnRva2Vucykge1xyXG5cdCAgICAgICAgICAgIHRoaXMudG9rZW5zLnBvcCgpO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICB9O1xyXG5cdCAgICBKU1hQYXJzZXIucHJvdG90eXBlLmNyZWF0ZUpTWE5vZGUgPSBmdW5jdGlvbiAoKSB7XHJcblx0ICAgICAgICB0aGlzLmNvbGxlY3RDb21tZW50cygpO1xyXG5cdCAgICAgICAgcmV0dXJuIHtcclxuXHQgICAgICAgICAgICBpbmRleDogdGhpcy5zY2FubmVyLmluZGV4LFxyXG5cdCAgICAgICAgICAgIGxpbmU6IHRoaXMuc2Nhbm5lci5saW5lTnVtYmVyLFxyXG5cdCAgICAgICAgICAgIGNvbHVtbjogdGhpcy5zY2FubmVyLmluZGV4IC0gdGhpcy5zY2FubmVyLmxpbmVTdGFydFxyXG5cdCAgICAgICAgfTtcclxuXHQgICAgfTtcclxuXHQgICAgSlNYUGFyc2VyLnByb3RvdHlwZS5jcmVhdGVKU1hDaGlsZE5vZGUgPSBmdW5jdGlvbiAoKSB7XHJcblx0ICAgICAgICByZXR1cm4ge1xyXG5cdCAgICAgICAgICAgIGluZGV4OiB0aGlzLnNjYW5uZXIuaW5kZXgsXHJcblx0ICAgICAgICAgICAgbGluZTogdGhpcy5zY2FubmVyLmxpbmVOdW1iZXIsXHJcblx0ICAgICAgICAgICAgY29sdW1uOiB0aGlzLnNjYW5uZXIuaW5kZXggLSB0aGlzLnNjYW5uZXIubGluZVN0YXJ0XHJcblx0ICAgICAgICB9O1xyXG5cdCAgICB9O1xyXG5cdCAgICBKU1hQYXJzZXIucHJvdG90eXBlLnNjYW5YSFRNTEVudGl0eSA9IGZ1bmN0aW9uIChxdW90ZSkge1xyXG5cdCAgICAgICAgdmFyIHJlc3VsdCA9ICcmJztcclxuXHQgICAgICAgIHZhciB2YWxpZCA9IHRydWU7XHJcblx0ICAgICAgICB2YXIgdGVybWluYXRlZCA9IGZhbHNlO1xyXG5cdCAgICAgICAgdmFyIG51bWVyaWMgPSBmYWxzZTtcclxuXHQgICAgICAgIHZhciBoZXggPSBmYWxzZTtcclxuXHQgICAgICAgIHdoaWxlICghdGhpcy5zY2FubmVyLmVvZigpICYmIHZhbGlkICYmICF0ZXJtaW5hdGVkKSB7XHJcblx0ICAgICAgICAgICAgdmFyIGNoID0gdGhpcy5zY2FubmVyLnNvdXJjZVt0aGlzLnNjYW5uZXIuaW5kZXhdO1xyXG5cdCAgICAgICAgICAgIGlmIChjaCA9PT0gcXVvdGUpIHtcclxuXHQgICAgICAgICAgICAgICAgYnJlYWs7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgIHRlcm1pbmF0ZWQgPSAoY2ggPT09ICc7Jyk7XHJcblx0ICAgICAgICAgICAgcmVzdWx0ICs9IGNoO1xyXG5cdCAgICAgICAgICAgICsrdGhpcy5zY2FubmVyLmluZGV4O1xyXG5cdCAgICAgICAgICAgIGlmICghdGVybWluYXRlZCkge1xyXG5cdCAgICAgICAgICAgICAgICBzd2l0Y2ggKHJlc3VsdC5sZW5ndGgpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgIGNhc2UgMjpcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAvLyBlLmcuICcmIzEyMzsnXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgbnVtZXJpYyA9IChjaCA9PT0gJyMnKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuXHQgICAgICAgICAgICAgICAgICAgIGNhc2UgMzpcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBpZiAobnVtZXJpYykge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBlLmcuICcmI3g0MTsnXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhleCA9IChjaCA9PT0gJ3gnKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsaWQgPSBoZXggfHwgY2hhcmFjdGVyXzEuQ2hhcmFjdGVyLmlzRGVjaW1hbERpZ2l0KGNoLmNoYXJDb2RlQXQoMCkpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBudW1lcmljID0gbnVtZXJpYyAmJiAhaGV4O1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuXHQgICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdmFsaWQgPSB2YWxpZCAmJiAhKG51bWVyaWMgJiYgIWNoYXJhY3Rlcl8xLkNoYXJhY3Rlci5pc0RlY2ltYWxEaWdpdChjaC5jaGFyQ29kZUF0KDApKSk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdmFsaWQgPSB2YWxpZCAmJiAhKGhleCAmJiAhY2hhcmFjdGVyXzEuQ2hhcmFjdGVyLmlzSGV4RGlnaXQoY2guY2hhckNvZGVBdCgwKSkpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cdCAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgaWYgKHZhbGlkICYmIHRlcm1pbmF0ZWQgJiYgcmVzdWx0Lmxlbmd0aCA+IDIpIHtcclxuXHQgICAgICAgICAgICAvLyBlLmcuICcmI3g0MTsnIGJlY29tZXMganVzdCAnI3g0MSdcclxuXHQgICAgICAgICAgICB2YXIgc3RyID0gcmVzdWx0LnN1YnN0cigxLCByZXN1bHQubGVuZ3RoIC0gMik7XHJcblx0ICAgICAgICAgICAgaWYgKG51bWVyaWMgJiYgc3RyLmxlbmd0aCA+IDEpIHtcclxuXHQgICAgICAgICAgICAgICAgcmVzdWx0ID0gU3RyaW5nLmZyb21DaGFyQ29kZShwYXJzZUludChzdHIuc3Vic3RyKDEpLCAxMCkpO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICBlbHNlIGlmIChoZXggJiYgc3RyLmxlbmd0aCA+IDIpIHtcclxuXHQgICAgICAgICAgICAgICAgcmVzdWx0ID0gU3RyaW5nLmZyb21DaGFyQ29kZShwYXJzZUludCgnMCcgKyBzdHIuc3Vic3RyKDEpLCAxNikpO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICBlbHNlIGlmICghbnVtZXJpYyAmJiAhaGV4ICYmIHhodG1sX2VudGl0aWVzXzEuWEhUTUxFbnRpdGllc1tzdHJdKSB7XHJcblx0ICAgICAgICAgICAgICAgIHJlc3VsdCA9IHhodG1sX2VudGl0aWVzXzEuWEhUTUxFbnRpdGllc1tzdHJdO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIHJldHVybiByZXN1bHQ7XHJcblx0ICAgIH07XHJcblx0ICAgIC8vIFNjYW4gdGhlIG5leHQgSlNYIHRva2VuLiBUaGlzIHJlcGxhY2VzIFNjYW5uZXIjbGV4IHdoZW4gaW4gSlNYIG1vZGUuXHJcblx0ICAgIEpTWFBhcnNlci5wcm90b3R5cGUubGV4SlNYID0gZnVuY3Rpb24gKCkge1xyXG5cdCAgICAgICAgdmFyIGNwID0gdGhpcy5zY2FubmVyLnNvdXJjZS5jaGFyQ29kZUF0KHRoaXMuc2Nhbm5lci5pbmRleCk7XHJcblx0ICAgICAgICAvLyA8ID4gLyA6ID0geyB9XHJcblx0ICAgICAgICBpZiAoY3AgPT09IDYwIHx8IGNwID09PSA2MiB8fCBjcCA9PT0gNDcgfHwgY3AgPT09IDU4IHx8IGNwID09PSA2MSB8fCBjcCA9PT0gMTIzIHx8IGNwID09PSAxMjUpIHtcclxuXHQgICAgICAgICAgICB2YXIgdmFsdWUgPSB0aGlzLnNjYW5uZXIuc291cmNlW3RoaXMuc2Nhbm5lci5pbmRleCsrXTtcclxuXHQgICAgICAgICAgICByZXR1cm4ge1xyXG5cdCAgICAgICAgICAgICAgICB0eXBlOiA3IC8qIFB1bmN0dWF0b3IgKi8sXHJcblx0ICAgICAgICAgICAgICAgIHZhbHVlOiB2YWx1ZSxcclxuXHQgICAgICAgICAgICAgICAgbGluZU51bWJlcjogdGhpcy5zY2FubmVyLmxpbmVOdW1iZXIsXHJcblx0ICAgICAgICAgICAgICAgIGxpbmVTdGFydDogdGhpcy5zY2FubmVyLmxpbmVTdGFydCxcclxuXHQgICAgICAgICAgICAgICAgc3RhcnQ6IHRoaXMuc2Nhbm5lci5pbmRleCAtIDEsXHJcblx0ICAgICAgICAgICAgICAgIGVuZDogdGhpcy5zY2FubmVyLmluZGV4XHJcblx0ICAgICAgICAgICAgfTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIC8vIFwiICdcclxuXHQgICAgICAgIGlmIChjcCA9PT0gMzQgfHwgY3AgPT09IDM5KSB7XHJcblx0ICAgICAgICAgICAgdmFyIHN0YXJ0ID0gdGhpcy5zY2FubmVyLmluZGV4O1xyXG5cdCAgICAgICAgICAgIHZhciBxdW90ZSA9IHRoaXMuc2Nhbm5lci5zb3VyY2VbdGhpcy5zY2FubmVyLmluZGV4KytdO1xyXG5cdCAgICAgICAgICAgIHZhciBzdHIgPSAnJztcclxuXHQgICAgICAgICAgICB3aGlsZSAoIXRoaXMuc2Nhbm5lci5lb2YoKSkge1xyXG5cdCAgICAgICAgICAgICAgICB2YXIgY2ggPSB0aGlzLnNjYW5uZXIuc291cmNlW3RoaXMuc2Nhbm5lci5pbmRleCsrXTtcclxuXHQgICAgICAgICAgICAgICAgaWYgKGNoID09PSBxdW90ZSkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcblx0ICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgZWxzZSBpZiAoY2ggPT09ICcmJykge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgc3RyICs9IHRoaXMuc2NhblhIVE1MRW50aXR5KHF1b3RlKTtcclxuXHQgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICBlbHNlIHtcclxuXHQgICAgICAgICAgICAgICAgICAgIHN0ciArPSBjaDtcclxuXHQgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICByZXR1cm4ge1xyXG5cdCAgICAgICAgICAgICAgICB0eXBlOiA4IC8qIFN0cmluZ0xpdGVyYWwgKi8sXHJcblx0ICAgICAgICAgICAgICAgIHZhbHVlOiBzdHIsXHJcblx0ICAgICAgICAgICAgICAgIGxpbmVOdW1iZXI6IHRoaXMuc2Nhbm5lci5saW5lTnVtYmVyLFxyXG5cdCAgICAgICAgICAgICAgICBsaW5lU3RhcnQ6IHRoaXMuc2Nhbm5lci5saW5lU3RhcnQsXHJcblx0ICAgICAgICAgICAgICAgIHN0YXJ0OiBzdGFydCxcclxuXHQgICAgICAgICAgICAgICAgZW5kOiB0aGlzLnNjYW5uZXIuaW5kZXhcclxuXHQgICAgICAgICAgICB9O1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgLy8gLi4uIG9yIC5cclxuXHQgICAgICAgIGlmIChjcCA9PT0gNDYpIHtcclxuXHQgICAgICAgICAgICB2YXIgbjEgPSB0aGlzLnNjYW5uZXIuc291cmNlLmNoYXJDb2RlQXQodGhpcy5zY2FubmVyLmluZGV4ICsgMSk7XHJcblx0ICAgICAgICAgICAgdmFyIG4yID0gdGhpcy5zY2FubmVyLnNvdXJjZS5jaGFyQ29kZUF0KHRoaXMuc2Nhbm5lci5pbmRleCArIDIpO1xyXG5cdCAgICAgICAgICAgIHZhciB2YWx1ZSA9IChuMSA9PT0gNDYgJiYgbjIgPT09IDQ2KSA/ICcuLi4nIDogJy4nO1xyXG5cdCAgICAgICAgICAgIHZhciBzdGFydCA9IHRoaXMuc2Nhbm5lci5pbmRleDtcclxuXHQgICAgICAgICAgICB0aGlzLnNjYW5uZXIuaW5kZXggKz0gdmFsdWUubGVuZ3RoO1xyXG5cdCAgICAgICAgICAgIHJldHVybiB7XHJcblx0ICAgICAgICAgICAgICAgIHR5cGU6IDcgLyogUHVuY3R1YXRvciAqLyxcclxuXHQgICAgICAgICAgICAgICAgdmFsdWU6IHZhbHVlLFxyXG5cdCAgICAgICAgICAgICAgICBsaW5lTnVtYmVyOiB0aGlzLnNjYW5uZXIubGluZU51bWJlcixcclxuXHQgICAgICAgICAgICAgICAgbGluZVN0YXJ0OiB0aGlzLnNjYW5uZXIubGluZVN0YXJ0LFxyXG5cdCAgICAgICAgICAgICAgICBzdGFydDogc3RhcnQsXHJcblx0ICAgICAgICAgICAgICAgIGVuZDogdGhpcy5zY2FubmVyLmluZGV4XHJcblx0ICAgICAgICAgICAgfTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIC8vIGBcclxuXHQgICAgICAgIGlmIChjcCA9PT0gOTYpIHtcclxuXHQgICAgICAgICAgICAvLyBPbmx5IHBsYWNlaG9sZGVyLCBzaW5jZSBpdCB3aWxsIGJlIHJlc2Nhbm5lZCBhcyBhIHJlYWwgYXNzaWdubWVudCBleHByZXNzaW9uLlxyXG5cdCAgICAgICAgICAgIHJldHVybiB7XHJcblx0ICAgICAgICAgICAgICAgIHR5cGU6IDEwIC8qIFRlbXBsYXRlICovLFxyXG5cdCAgICAgICAgICAgICAgICB2YWx1ZTogJycsXHJcblx0ICAgICAgICAgICAgICAgIGxpbmVOdW1iZXI6IHRoaXMuc2Nhbm5lci5saW5lTnVtYmVyLFxyXG5cdCAgICAgICAgICAgICAgICBsaW5lU3RhcnQ6IHRoaXMuc2Nhbm5lci5saW5lU3RhcnQsXHJcblx0ICAgICAgICAgICAgICAgIHN0YXJ0OiB0aGlzLnNjYW5uZXIuaW5kZXgsXHJcblx0ICAgICAgICAgICAgICAgIGVuZDogdGhpcy5zY2FubmVyLmluZGV4XHJcblx0ICAgICAgICAgICAgfTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIC8vIElkZW50aWZlciBjYW4gbm90IGNvbnRhaW4gYmFja3NsYXNoIChjaGFyIGNvZGUgOTIpLlxyXG5cdCAgICAgICAgaWYgKGNoYXJhY3Rlcl8xLkNoYXJhY3Rlci5pc0lkZW50aWZpZXJTdGFydChjcCkgJiYgKGNwICE9PSA5MikpIHtcclxuXHQgICAgICAgICAgICB2YXIgc3RhcnQgPSB0aGlzLnNjYW5uZXIuaW5kZXg7XHJcblx0ICAgICAgICAgICAgKyt0aGlzLnNjYW5uZXIuaW5kZXg7XHJcblx0ICAgICAgICAgICAgd2hpbGUgKCF0aGlzLnNjYW5uZXIuZW9mKCkpIHtcclxuXHQgICAgICAgICAgICAgICAgdmFyIGNoID0gdGhpcy5zY2FubmVyLnNvdXJjZS5jaGFyQ29kZUF0KHRoaXMuc2Nhbm5lci5pbmRleCk7XHJcblx0ICAgICAgICAgICAgICAgIGlmIChjaGFyYWN0ZXJfMS5DaGFyYWN0ZXIuaXNJZGVudGlmaWVyUGFydChjaCkgJiYgKGNoICE9PSA5MikpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICsrdGhpcy5zY2FubmVyLmluZGV4O1xyXG5cdCAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgIGVsc2UgaWYgKGNoID09PSA0NSkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgLy8gSHlwaGVuIChjaGFyIGNvZGUgNDUpIGNhbiBiZSBwYXJ0IG9mIGFuIGlkZW50aWZpZXIuXHJcblx0ICAgICAgICAgICAgICAgICAgICArK3RoaXMuc2Nhbm5lci5pbmRleDtcclxuXHQgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICBlbHNlIHtcclxuXHQgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cdCAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgIHZhciBpZCA9IHRoaXMuc2Nhbm5lci5zb3VyY2Uuc2xpY2Uoc3RhcnQsIHRoaXMuc2Nhbm5lci5pbmRleCk7XHJcblx0ICAgICAgICAgICAgcmV0dXJuIHtcclxuXHQgICAgICAgICAgICAgICAgdHlwZTogMTAwIC8qIElkZW50aWZpZXIgKi8sXHJcblx0ICAgICAgICAgICAgICAgIHZhbHVlOiBpZCxcclxuXHQgICAgICAgICAgICAgICAgbGluZU51bWJlcjogdGhpcy5zY2FubmVyLmxpbmVOdW1iZXIsXHJcblx0ICAgICAgICAgICAgICAgIGxpbmVTdGFydDogdGhpcy5zY2FubmVyLmxpbmVTdGFydCxcclxuXHQgICAgICAgICAgICAgICAgc3RhcnQ6IHN0YXJ0LFxyXG5cdCAgICAgICAgICAgICAgICBlbmQ6IHRoaXMuc2Nhbm5lci5pbmRleFxyXG5cdCAgICAgICAgICAgIH07XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICByZXR1cm4gdGhpcy5zY2FubmVyLmxleCgpO1xyXG5cdCAgICB9O1xyXG5cdCAgICBKU1hQYXJzZXIucHJvdG90eXBlLm5leHRKU1hUb2tlbiA9IGZ1bmN0aW9uICgpIHtcclxuXHQgICAgICAgIHRoaXMuY29sbGVjdENvbW1lbnRzKCk7XHJcblx0ICAgICAgICB0aGlzLnN0YXJ0TWFya2VyLmluZGV4ID0gdGhpcy5zY2FubmVyLmluZGV4O1xyXG5cdCAgICAgICAgdGhpcy5zdGFydE1hcmtlci5saW5lID0gdGhpcy5zY2FubmVyLmxpbmVOdW1iZXI7XHJcblx0ICAgICAgICB0aGlzLnN0YXJ0TWFya2VyLmNvbHVtbiA9IHRoaXMuc2Nhbm5lci5pbmRleCAtIHRoaXMuc2Nhbm5lci5saW5lU3RhcnQ7XHJcblx0ICAgICAgICB2YXIgdG9rZW4gPSB0aGlzLmxleEpTWCgpO1xyXG5cdCAgICAgICAgdGhpcy5sYXN0TWFya2VyLmluZGV4ID0gdGhpcy5zY2FubmVyLmluZGV4O1xyXG5cdCAgICAgICAgdGhpcy5sYXN0TWFya2VyLmxpbmUgPSB0aGlzLnNjYW5uZXIubGluZU51bWJlcjtcclxuXHQgICAgICAgIHRoaXMubGFzdE1hcmtlci5jb2x1bW4gPSB0aGlzLnNjYW5uZXIuaW5kZXggLSB0aGlzLnNjYW5uZXIubGluZVN0YXJ0O1xyXG5cdCAgICAgICAgaWYgKHRoaXMuY29uZmlnLnRva2Vucykge1xyXG5cdCAgICAgICAgICAgIHRoaXMudG9rZW5zLnB1c2godGhpcy5jb252ZXJ0VG9rZW4odG9rZW4pKTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIHJldHVybiB0b2tlbjtcclxuXHQgICAgfTtcclxuXHQgICAgSlNYUGFyc2VyLnByb3RvdHlwZS5uZXh0SlNYVGV4dCA9IGZ1bmN0aW9uICgpIHtcclxuXHQgICAgICAgIHRoaXMuc3RhcnRNYXJrZXIuaW5kZXggPSB0aGlzLnNjYW5uZXIuaW5kZXg7XHJcblx0ICAgICAgICB0aGlzLnN0YXJ0TWFya2VyLmxpbmUgPSB0aGlzLnNjYW5uZXIubGluZU51bWJlcjtcclxuXHQgICAgICAgIHRoaXMuc3RhcnRNYXJrZXIuY29sdW1uID0gdGhpcy5zY2FubmVyLmluZGV4IC0gdGhpcy5zY2FubmVyLmxpbmVTdGFydDtcclxuXHQgICAgICAgIHZhciBzdGFydCA9IHRoaXMuc2Nhbm5lci5pbmRleDtcclxuXHQgICAgICAgIHZhciB0ZXh0ID0gJyc7XHJcblx0ICAgICAgICB3aGlsZSAoIXRoaXMuc2Nhbm5lci5lb2YoKSkge1xyXG5cdCAgICAgICAgICAgIHZhciBjaCA9IHRoaXMuc2Nhbm5lci5zb3VyY2VbdGhpcy5zY2FubmVyLmluZGV4XTtcclxuXHQgICAgICAgICAgICBpZiAoY2ggPT09ICd7JyB8fCBjaCA9PT0gJzwnKSB7XHJcblx0ICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICArK3RoaXMuc2Nhbm5lci5pbmRleDtcclxuXHQgICAgICAgICAgICB0ZXh0ICs9IGNoO1xyXG5cdCAgICAgICAgICAgIGlmIChjaGFyYWN0ZXJfMS5DaGFyYWN0ZXIuaXNMaW5lVGVybWluYXRvcihjaC5jaGFyQ29kZUF0KDApKSkge1xyXG5cdCAgICAgICAgICAgICAgICArK3RoaXMuc2Nhbm5lci5saW5lTnVtYmVyO1xyXG5cdCAgICAgICAgICAgICAgICBpZiAoY2ggPT09ICdcXHInICYmIHRoaXMuc2Nhbm5lci5zb3VyY2VbdGhpcy5zY2FubmVyLmluZGV4XSA9PT0gJ1xcbicpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICsrdGhpcy5zY2FubmVyLmluZGV4O1xyXG5cdCAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgIHRoaXMuc2Nhbm5lci5saW5lU3RhcnQgPSB0aGlzLnNjYW5uZXIuaW5kZXg7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgdGhpcy5sYXN0TWFya2VyLmluZGV4ID0gdGhpcy5zY2FubmVyLmluZGV4O1xyXG5cdCAgICAgICAgdGhpcy5sYXN0TWFya2VyLmxpbmUgPSB0aGlzLnNjYW5uZXIubGluZU51bWJlcjtcclxuXHQgICAgICAgIHRoaXMubGFzdE1hcmtlci5jb2x1bW4gPSB0aGlzLnNjYW5uZXIuaW5kZXggLSB0aGlzLnNjYW5uZXIubGluZVN0YXJ0O1xyXG5cdCAgICAgICAgdmFyIHRva2VuID0ge1xyXG5cdCAgICAgICAgICAgIHR5cGU6IDEwMSAvKiBUZXh0ICovLFxyXG5cdCAgICAgICAgICAgIHZhbHVlOiB0ZXh0LFxyXG5cdCAgICAgICAgICAgIGxpbmVOdW1iZXI6IHRoaXMuc2Nhbm5lci5saW5lTnVtYmVyLFxyXG5cdCAgICAgICAgICAgIGxpbmVTdGFydDogdGhpcy5zY2FubmVyLmxpbmVTdGFydCxcclxuXHQgICAgICAgICAgICBzdGFydDogc3RhcnQsXHJcblx0ICAgICAgICAgICAgZW5kOiB0aGlzLnNjYW5uZXIuaW5kZXhcclxuXHQgICAgICAgIH07XHJcblx0ICAgICAgICBpZiAoKHRleHQubGVuZ3RoID4gMCkgJiYgdGhpcy5jb25maWcudG9rZW5zKSB7XHJcblx0ICAgICAgICAgICAgdGhpcy50b2tlbnMucHVzaCh0aGlzLmNvbnZlcnRUb2tlbih0b2tlbikpO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgcmV0dXJuIHRva2VuO1xyXG5cdCAgICB9O1xyXG5cdCAgICBKU1hQYXJzZXIucHJvdG90eXBlLnBlZWtKU1hUb2tlbiA9IGZ1bmN0aW9uICgpIHtcclxuXHQgICAgICAgIHZhciBzdGF0ZSA9IHRoaXMuc2Nhbm5lci5zYXZlU3RhdGUoKTtcclxuXHQgICAgICAgIHRoaXMuc2Nhbm5lci5zY2FuQ29tbWVudHMoKTtcclxuXHQgICAgICAgIHZhciBuZXh0ID0gdGhpcy5sZXhKU1goKTtcclxuXHQgICAgICAgIHRoaXMuc2Nhbm5lci5yZXN0b3JlU3RhdGUoc3RhdGUpO1xyXG5cdCAgICAgICAgcmV0dXJuIG5leHQ7XHJcblx0ICAgIH07XHJcblx0ICAgIC8vIEV4cGVjdCB0aGUgbmV4dCBKU1ggdG9rZW4gdG8gbWF0Y2ggdGhlIHNwZWNpZmllZCBwdW5jdHVhdG9yLlxyXG5cdCAgICAvLyBJZiBub3QsIGFuIGV4Y2VwdGlvbiB3aWxsIGJlIHRocm93bi5cclxuXHQgICAgSlNYUGFyc2VyLnByb3RvdHlwZS5leHBlY3RKU1ggPSBmdW5jdGlvbiAodmFsdWUpIHtcclxuXHQgICAgICAgIHZhciB0b2tlbiA9IHRoaXMubmV4dEpTWFRva2VuKCk7XHJcblx0ICAgICAgICBpZiAodG9rZW4udHlwZSAhPT0gNyAvKiBQdW5jdHVhdG9yICovIHx8IHRva2VuLnZhbHVlICE9PSB2YWx1ZSkge1xyXG5cdCAgICAgICAgICAgIHRoaXMudGhyb3dVbmV4cGVjdGVkVG9rZW4odG9rZW4pO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICB9O1xyXG5cdCAgICAvLyBSZXR1cm4gdHJ1ZSBpZiB0aGUgbmV4dCBKU1ggdG9rZW4gbWF0Y2hlcyB0aGUgc3BlY2lmaWVkIHB1bmN0dWF0b3IuXHJcblx0ICAgIEpTWFBhcnNlci5wcm90b3R5cGUubWF0Y2hKU1ggPSBmdW5jdGlvbiAodmFsdWUpIHtcclxuXHQgICAgICAgIHZhciBuZXh0ID0gdGhpcy5wZWVrSlNYVG9rZW4oKTtcclxuXHQgICAgICAgIHJldHVybiBuZXh0LnR5cGUgPT09IDcgLyogUHVuY3R1YXRvciAqLyAmJiBuZXh0LnZhbHVlID09PSB2YWx1ZTtcclxuXHQgICAgfTtcclxuXHQgICAgSlNYUGFyc2VyLnByb3RvdHlwZS5wYXJzZUpTWElkZW50aWZpZXIgPSBmdW5jdGlvbiAoKSB7XHJcblx0ICAgICAgICB2YXIgbm9kZSA9IHRoaXMuY3JlYXRlSlNYTm9kZSgpO1xyXG5cdCAgICAgICAgdmFyIHRva2VuID0gdGhpcy5uZXh0SlNYVG9rZW4oKTtcclxuXHQgICAgICAgIGlmICh0b2tlbi50eXBlICE9PSAxMDAgLyogSWRlbnRpZmllciAqLykge1xyXG5cdCAgICAgICAgICAgIHRoaXMudGhyb3dVbmV4cGVjdGVkVG9rZW4odG9rZW4pO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgcmV0dXJuIHRoaXMuZmluYWxpemUobm9kZSwgbmV3IEpTWE5vZGUuSlNYSWRlbnRpZmllcih0b2tlbi52YWx1ZSkpO1xyXG5cdCAgICB9O1xyXG5cdCAgICBKU1hQYXJzZXIucHJvdG90eXBlLnBhcnNlSlNYRWxlbWVudE5hbWUgPSBmdW5jdGlvbiAoKSB7XHJcblx0ICAgICAgICB2YXIgbm9kZSA9IHRoaXMuY3JlYXRlSlNYTm9kZSgpO1xyXG5cdCAgICAgICAgdmFyIGVsZW1lbnROYW1lID0gdGhpcy5wYXJzZUpTWElkZW50aWZpZXIoKTtcclxuXHQgICAgICAgIGlmICh0aGlzLm1hdGNoSlNYKCc6JykpIHtcclxuXHQgICAgICAgICAgICB2YXIgbmFtZXNwYWNlID0gZWxlbWVudE5hbWU7XHJcblx0ICAgICAgICAgICAgdGhpcy5leHBlY3RKU1goJzonKTtcclxuXHQgICAgICAgICAgICB2YXIgbmFtZV8xID0gdGhpcy5wYXJzZUpTWElkZW50aWZpZXIoKTtcclxuXHQgICAgICAgICAgICBlbGVtZW50TmFtZSA9IHRoaXMuZmluYWxpemUobm9kZSwgbmV3IEpTWE5vZGUuSlNYTmFtZXNwYWNlZE5hbWUobmFtZXNwYWNlLCBuYW1lXzEpKTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIGVsc2UgaWYgKHRoaXMubWF0Y2hKU1goJy4nKSkge1xyXG5cdCAgICAgICAgICAgIHdoaWxlICh0aGlzLm1hdGNoSlNYKCcuJykpIHtcclxuXHQgICAgICAgICAgICAgICAgdmFyIG9iamVjdCA9IGVsZW1lbnROYW1lO1xyXG5cdCAgICAgICAgICAgICAgICB0aGlzLmV4cGVjdEpTWCgnLicpO1xyXG5cdCAgICAgICAgICAgICAgICB2YXIgcHJvcGVydHkgPSB0aGlzLnBhcnNlSlNYSWRlbnRpZmllcigpO1xyXG5cdCAgICAgICAgICAgICAgICBlbGVtZW50TmFtZSA9IHRoaXMuZmluYWxpemUobm9kZSwgbmV3IEpTWE5vZGUuSlNYTWVtYmVyRXhwcmVzc2lvbihvYmplY3QsIHByb3BlcnR5KSk7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgcmV0dXJuIGVsZW1lbnROYW1lO1xyXG5cdCAgICB9O1xyXG5cdCAgICBKU1hQYXJzZXIucHJvdG90eXBlLnBhcnNlSlNYQXR0cmlidXRlTmFtZSA9IGZ1bmN0aW9uICgpIHtcclxuXHQgICAgICAgIHZhciBub2RlID0gdGhpcy5jcmVhdGVKU1hOb2RlKCk7XHJcblx0ICAgICAgICB2YXIgYXR0cmlidXRlTmFtZTtcclxuXHQgICAgICAgIHZhciBpZGVudGlmaWVyID0gdGhpcy5wYXJzZUpTWElkZW50aWZpZXIoKTtcclxuXHQgICAgICAgIGlmICh0aGlzLm1hdGNoSlNYKCc6JykpIHtcclxuXHQgICAgICAgICAgICB2YXIgbmFtZXNwYWNlID0gaWRlbnRpZmllcjtcclxuXHQgICAgICAgICAgICB0aGlzLmV4cGVjdEpTWCgnOicpO1xyXG5cdCAgICAgICAgICAgIHZhciBuYW1lXzIgPSB0aGlzLnBhcnNlSlNYSWRlbnRpZmllcigpO1xyXG5cdCAgICAgICAgICAgIGF0dHJpYnV0ZU5hbWUgPSB0aGlzLmZpbmFsaXplKG5vZGUsIG5ldyBKU1hOb2RlLkpTWE5hbWVzcGFjZWROYW1lKG5hbWVzcGFjZSwgbmFtZV8yKSk7XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICBlbHNlIHtcclxuXHQgICAgICAgICAgICBhdHRyaWJ1dGVOYW1lID0gaWRlbnRpZmllcjtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIHJldHVybiBhdHRyaWJ1dGVOYW1lO1xyXG5cdCAgICB9O1xyXG5cdCAgICBKU1hQYXJzZXIucHJvdG90eXBlLnBhcnNlSlNYU3RyaW5nTGl0ZXJhbEF0dHJpYnV0ZSA9IGZ1bmN0aW9uICgpIHtcclxuXHQgICAgICAgIHZhciBub2RlID0gdGhpcy5jcmVhdGVKU1hOb2RlKCk7XHJcblx0ICAgICAgICB2YXIgdG9rZW4gPSB0aGlzLm5leHRKU1hUb2tlbigpO1xyXG5cdCAgICAgICAgaWYgKHRva2VuLnR5cGUgIT09IDggLyogU3RyaW5nTGl0ZXJhbCAqLykge1xyXG5cdCAgICAgICAgICAgIHRoaXMudGhyb3dVbmV4cGVjdGVkVG9rZW4odG9rZW4pO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgdmFyIHJhdyA9IHRoaXMuZ2V0VG9rZW5SYXcodG9rZW4pO1xyXG5cdCAgICAgICAgcmV0dXJuIHRoaXMuZmluYWxpemUobm9kZSwgbmV3IE5vZGUuTGl0ZXJhbCh0b2tlbi52YWx1ZSwgcmF3KSk7XHJcblx0ICAgIH07XHJcblx0ICAgIEpTWFBhcnNlci5wcm90b3R5cGUucGFyc2VKU1hFeHByZXNzaW9uQXR0cmlidXRlID0gZnVuY3Rpb24gKCkge1xyXG5cdCAgICAgICAgdmFyIG5vZGUgPSB0aGlzLmNyZWF0ZUpTWE5vZGUoKTtcclxuXHQgICAgICAgIHRoaXMuZXhwZWN0SlNYKCd7Jyk7XHJcblx0ICAgICAgICB0aGlzLmZpbmlzaEpTWCgpO1xyXG5cdCAgICAgICAgaWYgKHRoaXMubWF0Y2goJ30nKSkge1xyXG5cdCAgICAgICAgICAgIHRoaXMudG9sZXJhdGVFcnJvcignSlNYIGF0dHJpYnV0ZXMgbXVzdCBvbmx5IGJlIGFzc2lnbmVkIGEgbm9uLWVtcHR5IGV4cHJlc3Npb24nKTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIHZhciBleHByZXNzaW9uID0gdGhpcy5wYXJzZUFzc2lnbm1lbnRFeHByZXNzaW9uKCk7XHJcblx0ICAgICAgICB0aGlzLnJlZW50ZXJKU1goKTtcclxuXHQgICAgICAgIHJldHVybiB0aGlzLmZpbmFsaXplKG5vZGUsIG5ldyBKU1hOb2RlLkpTWEV4cHJlc3Npb25Db250YWluZXIoZXhwcmVzc2lvbikpO1xyXG5cdCAgICB9O1xyXG5cdCAgICBKU1hQYXJzZXIucHJvdG90eXBlLnBhcnNlSlNYQXR0cmlidXRlVmFsdWUgPSBmdW5jdGlvbiAoKSB7XHJcblx0ICAgICAgICByZXR1cm4gdGhpcy5tYXRjaEpTWCgneycpID8gdGhpcy5wYXJzZUpTWEV4cHJlc3Npb25BdHRyaWJ1dGUoKSA6XHJcblx0ICAgICAgICAgICAgdGhpcy5tYXRjaEpTWCgnPCcpID8gdGhpcy5wYXJzZUpTWEVsZW1lbnQoKSA6IHRoaXMucGFyc2VKU1hTdHJpbmdMaXRlcmFsQXR0cmlidXRlKCk7XHJcblx0ICAgIH07XHJcblx0ICAgIEpTWFBhcnNlci5wcm90b3R5cGUucGFyc2VKU1hOYW1lVmFsdWVBdHRyaWJ1dGUgPSBmdW5jdGlvbiAoKSB7XHJcblx0ICAgICAgICB2YXIgbm9kZSA9IHRoaXMuY3JlYXRlSlNYTm9kZSgpO1xyXG5cdCAgICAgICAgdmFyIG5hbWUgPSB0aGlzLnBhcnNlSlNYQXR0cmlidXRlTmFtZSgpO1xyXG5cdCAgICAgICAgdmFyIHZhbHVlID0gbnVsbDtcclxuXHQgICAgICAgIGlmICh0aGlzLm1hdGNoSlNYKCc9JykpIHtcclxuXHQgICAgICAgICAgICB0aGlzLmV4cGVjdEpTWCgnPScpO1xyXG5cdCAgICAgICAgICAgIHZhbHVlID0gdGhpcy5wYXJzZUpTWEF0dHJpYnV0ZVZhbHVlKCk7XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICByZXR1cm4gdGhpcy5maW5hbGl6ZShub2RlLCBuZXcgSlNYTm9kZS5KU1hBdHRyaWJ1dGUobmFtZSwgdmFsdWUpKTtcclxuXHQgICAgfTtcclxuXHQgICAgSlNYUGFyc2VyLnByb3RvdHlwZS5wYXJzZUpTWFNwcmVhZEF0dHJpYnV0ZSA9IGZ1bmN0aW9uICgpIHtcclxuXHQgICAgICAgIHZhciBub2RlID0gdGhpcy5jcmVhdGVKU1hOb2RlKCk7XHJcblx0ICAgICAgICB0aGlzLmV4cGVjdEpTWCgneycpO1xyXG5cdCAgICAgICAgdGhpcy5leHBlY3RKU1goJy4uLicpO1xyXG5cdCAgICAgICAgdGhpcy5maW5pc2hKU1goKTtcclxuXHQgICAgICAgIHZhciBhcmd1bWVudCA9IHRoaXMucGFyc2VBc3NpZ25tZW50RXhwcmVzc2lvbigpO1xyXG5cdCAgICAgICAgdGhpcy5yZWVudGVySlNYKCk7XHJcblx0ICAgICAgICByZXR1cm4gdGhpcy5maW5hbGl6ZShub2RlLCBuZXcgSlNYTm9kZS5KU1hTcHJlYWRBdHRyaWJ1dGUoYXJndW1lbnQpKTtcclxuXHQgICAgfTtcclxuXHQgICAgSlNYUGFyc2VyLnByb3RvdHlwZS5wYXJzZUpTWEF0dHJpYnV0ZXMgPSBmdW5jdGlvbiAoKSB7XHJcblx0ICAgICAgICB2YXIgYXR0cmlidXRlcyA9IFtdO1xyXG5cdCAgICAgICAgd2hpbGUgKCF0aGlzLm1hdGNoSlNYKCcvJykgJiYgIXRoaXMubWF0Y2hKU1goJz4nKSkge1xyXG5cdCAgICAgICAgICAgIHZhciBhdHRyaWJ1dGUgPSB0aGlzLm1hdGNoSlNYKCd7JykgPyB0aGlzLnBhcnNlSlNYU3ByZWFkQXR0cmlidXRlKCkgOlxyXG5cdCAgICAgICAgICAgICAgICB0aGlzLnBhcnNlSlNYTmFtZVZhbHVlQXR0cmlidXRlKCk7XHJcblx0ICAgICAgICAgICAgYXR0cmlidXRlcy5wdXNoKGF0dHJpYnV0ZSk7XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICByZXR1cm4gYXR0cmlidXRlcztcclxuXHQgICAgfTtcclxuXHQgICAgSlNYUGFyc2VyLnByb3RvdHlwZS5wYXJzZUpTWE9wZW5pbmdFbGVtZW50ID0gZnVuY3Rpb24gKCkge1xyXG5cdCAgICAgICAgdmFyIG5vZGUgPSB0aGlzLmNyZWF0ZUpTWE5vZGUoKTtcclxuXHQgICAgICAgIHRoaXMuZXhwZWN0SlNYKCc8Jyk7XHJcblx0ICAgICAgICB2YXIgbmFtZSA9IHRoaXMucGFyc2VKU1hFbGVtZW50TmFtZSgpO1xyXG5cdCAgICAgICAgdmFyIGF0dHJpYnV0ZXMgPSB0aGlzLnBhcnNlSlNYQXR0cmlidXRlcygpO1xyXG5cdCAgICAgICAgdmFyIHNlbGZDbG9zaW5nID0gdGhpcy5tYXRjaEpTWCgnLycpO1xyXG5cdCAgICAgICAgaWYgKHNlbGZDbG9zaW5nKSB7XHJcblx0ICAgICAgICAgICAgdGhpcy5leHBlY3RKU1goJy8nKTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIHRoaXMuZXhwZWN0SlNYKCc+Jyk7XHJcblx0ICAgICAgICByZXR1cm4gdGhpcy5maW5hbGl6ZShub2RlLCBuZXcgSlNYTm9kZS5KU1hPcGVuaW5nRWxlbWVudChuYW1lLCBzZWxmQ2xvc2luZywgYXR0cmlidXRlcykpO1xyXG5cdCAgICB9O1xyXG5cdCAgICBKU1hQYXJzZXIucHJvdG90eXBlLnBhcnNlSlNYQm91bmRhcnlFbGVtZW50ID0gZnVuY3Rpb24gKCkge1xyXG5cdCAgICAgICAgdmFyIG5vZGUgPSB0aGlzLmNyZWF0ZUpTWE5vZGUoKTtcclxuXHQgICAgICAgIHRoaXMuZXhwZWN0SlNYKCc8Jyk7XHJcblx0ICAgICAgICBpZiAodGhpcy5tYXRjaEpTWCgnLycpKSB7XHJcblx0ICAgICAgICAgICAgdGhpcy5leHBlY3RKU1goJy8nKTtcclxuXHQgICAgICAgICAgICB2YXIgbmFtZV8zID0gdGhpcy5wYXJzZUpTWEVsZW1lbnROYW1lKCk7XHJcblx0ICAgICAgICAgICAgdGhpcy5leHBlY3RKU1goJz4nKTtcclxuXHQgICAgICAgICAgICByZXR1cm4gdGhpcy5maW5hbGl6ZShub2RlLCBuZXcgSlNYTm9kZS5KU1hDbG9zaW5nRWxlbWVudChuYW1lXzMpKTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIHZhciBuYW1lID0gdGhpcy5wYXJzZUpTWEVsZW1lbnROYW1lKCk7XHJcblx0ICAgICAgICB2YXIgYXR0cmlidXRlcyA9IHRoaXMucGFyc2VKU1hBdHRyaWJ1dGVzKCk7XHJcblx0ICAgICAgICB2YXIgc2VsZkNsb3NpbmcgPSB0aGlzLm1hdGNoSlNYKCcvJyk7XHJcblx0ICAgICAgICBpZiAoc2VsZkNsb3NpbmcpIHtcclxuXHQgICAgICAgICAgICB0aGlzLmV4cGVjdEpTWCgnLycpO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgdGhpcy5leHBlY3RKU1goJz4nKTtcclxuXHQgICAgICAgIHJldHVybiB0aGlzLmZpbmFsaXplKG5vZGUsIG5ldyBKU1hOb2RlLkpTWE9wZW5pbmdFbGVtZW50KG5hbWUsIHNlbGZDbG9zaW5nLCBhdHRyaWJ1dGVzKSk7XHJcblx0ICAgIH07XHJcblx0ICAgIEpTWFBhcnNlci5wcm90b3R5cGUucGFyc2VKU1hFbXB0eUV4cHJlc3Npb24gPSBmdW5jdGlvbiAoKSB7XHJcblx0ICAgICAgICB2YXIgbm9kZSA9IHRoaXMuY3JlYXRlSlNYQ2hpbGROb2RlKCk7XHJcblx0ICAgICAgICB0aGlzLmNvbGxlY3RDb21tZW50cygpO1xyXG5cdCAgICAgICAgdGhpcy5sYXN0TWFya2VyLmluZGV4ID0gdGhpcy5zY2FubmVyLmluZGV4O1xyXG5cdCAgICAgICAgdGhpcy5sYXN0TWFya2VyLmxpbmUgPSB0aGlzLnNjYW5uZXIubGluZU51bWJlcjtcclxuXHQgICAgICAgIHRoaXMubGFzdE1hcmtlci5jb2x1bW4gPSB0aGlzLnNjYW5uZXIuaW5kZXggLSB0aGlzLnNjYW5uZXIubGluZVN0YXJ0O1xyXG5cdCAgICAgICAgcmV0dXJuIHRoaXMuZmluYWxpemUobm9kZSwgbmV3IEpTWE5vZGUuSlNYRW1wdHlFeHByZXNzaW9uKCkpO1xyXG5cdCAgICB9O1xyXG5cdCAgICBKU1hQYXJzZXIucHJvdG90eXBlLnBhcnNlSlNYRXhwcmVzc2lvbkNvbnRhaW5lciA9IGZ1bmN0aW9uICgpIHtcclxuXHQgICAgICAgIHZhciBub2RlID0gdGhpcy5jcmVhdGVKU1hOb2RlKCk7XHJcblx0ICAgICAgICB0aGlzLmV4cGVjdEpTWCgneycpO1xyXG5cdCAgICAgICAgdmFyIGV4cHJlc3Npb247XHJcblx0ICAgICAgICBpZiAodGhpcy5tYXRjaEpTWCgnfScpKSB7XHJcblx0ICAgICAgICAgICAgZXhwcmVzc2lvbiA9IHRoaXMucGFyc2VKU1hFbXB0eUV4cHJlc3Npb24oKTtcclxuXHQgICAgICAgICAgICB0aGlzLmV4cGVjdEpTWCgnfScpO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgZWxzZSB7XHJcblx0ICAgICAgICAgICAgdGhpcy5maW5pc2hKU1goKTtcclxuXHQgICAgICAgICAgICBleHByZXNzaW9uID0gdGhpcy5wYXJzZUFzc2lnbm1lbnRFeHByZXNzaW9uKCk7XHJcblx0ICAgICAgICAgICAgdGhpcy5yZWVudGVySlNYKCk7XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICByZXR1cm4gdGhpcy5maW5hbGl6ZShub2RlLCBuZXcgSlNYTm9kZS5KU1hFeHByZXNzaW9uQ29udGFpbmVyKGV4cHJlc3Npb24pKTtcclxuXHQgICAgfTtcclxuXHQgICAgSlNYUGFyc2VyLnByb3RvdHlwZS5wYXJzZUpTWENoaWxkcmVuID0gZnVuY3Rpb24gKCkge1xyXG5cdCAgICAgICAgdmFyIGNoaWxkcmVuID0gW107XHJcblx0ICAgICAgICB3aGlsZSAoIXRoaXMuc2Nhbm5lci5lb2YoKSkge1xyXG5cdCAgICAgICAgICAgIHZhciBub2RlID0gdGhpcy5jcmVhdGVKU1hDaGlsZE5vZGUoKTtcclxuXHQgICAgICAgICAgICB2YXIgdG9rZW4gPSB0aGlzLm5leHRKU1hUZXh0KCk7XHJcblx0ICAgICAgICAgICAgaWYgKHRva2VuLnN0YXJ0IDwgdG9rZW4uZW5kKSB7XHJcblx0ICAgICAgICAgICAgICAgIHZhciByYXcgPSB0aGlzLmdldFRva2VuUmF3KHRva2VuKTtcclxuXHQgICAgICAgICAgICAgICAgdmFyIGNoaWxkID0gdGhpcy5maW5hbGl6ZShub2RlLCBuZXcgSlNYTm9kZS5KU1hUZXh0KHRva2VuLnZhbHVlLCByYXcpKTtcclxuXHQgICAgICAgICAgICAgICAgY2hpbGRyZW4ucHVzaChjaGlsZCk7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgIGlmICh0aGlzLnNjYW5uZXIuc291cmNlW3RoaXMuc2Nhbm5lci5pbmRleF0gPT09ICd7Jykge1xyXG5cdCAgICAgICAgICAgICAgICB2YXIgY29udGFpbmVyID0gdGhpcy5wYXJzZUpTWEV4cHJlc3Npb25Db250YWluZXIoKTtcclxuXHQgICAgICAgICAgICAgICAgY2hpbGRyZW4ucHVzaChjb250YWluZXIpO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICBlbHNlIHtcclxuXHQgICAgICAgICAgICAgICAgYnJlYWs7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgcmV0dXJuIGNoaWxkcmVuO1xyXG5cdCAgICB9O1xyXG5cdCAgICBKU1hQYXJzZXIucHJvdG90eXBlLnBhcnNlQ29tcGxleEpTWEVsZW1lbnQgPSBmdW5jdGlvbiAoZWwpIHtcclxuXHQgICAgICAgIHZhciBzdGFjayA9IFtdO1xyXG5cdCAgICAgICAgd2hpbGUgKCF0aGlzLnNjYW5uZXIuZW9mKCkpIHtcclxuXHQgICAgICAgICAgICBlbC5jaGlsZHJlbiA9IGVsLmNoaWxkcmVuLmNvbmNhdCh0aGlzLnBhcnNlSlNYQ2hpbGRyZW4oKSk7XHJcblx0ICAgICAgICAgICAgdmFyIG5vZGUgPSB0aGlzLmNyZWF0ZUpTWENoaWxkTm9kZSgpO1xyXG5cdCAgICAgICAgICAgIHZhciBlbGVtZW50ID0gdGhpcy5wYXJzZUpTWEJvdW5kYXJ5RWxlbWVudCgpO1xyXG5cdCAgICAgICAgICAgIGlmIChlbGVtZW50LnR5cGUgPT09IGpzeF9zeW50YXhfMS5KU1hTeW50YXguSlNYT3BlbmluZ0VsZW1lbnQpIHtcclxuXHQgICAgICAgICAgICAgICAgdmFyIG9wZW5pbmcgPSBlbGVtZW50O1xyXG5cdCAgICAgICAgICAgICAgICBpZiAob3BlbmluZy5zZWxmQ2xvc2luZykge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIGNoaWxkID0gdGhpcy5maW5hbGl6ZShub2RlLCBuZXcgSlNYTm9kZS5KU1hFbGVtZW50KG9wZW5pbmcsIFtdLCBudWxsKSk7XHJcblx0ICAgICAgICAgICAgICAgICAgICBlbC5jaGlsZHJlbi5wdXNoKGNoaWxkKTtcclxuXHQgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICBlbHNlIHtcclxuXHQgICAgICAgICAgICAgICAgICAgIHN0YWNrLnB1c2goZWwpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgZWwgPSB7IG5vZGU6IG5vZGUsIG9wZW5pbmc6IG9wZW5pbmcsIGNsb3Npbmc6IG51bGwsIGNoaWxkcmVuOiBbXSB9O1xyXG5cdCAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgIGlmIChlbGVtZW50LnR5cGUgPT09IGpzeF9zeW50YXhfMS5KU1hTeW50YXguSlNYQ2xvc2luZ0VsZW1lbnQpIHtcclxuXHQgICAgICAgICAgICAgICAgZWwuY2xvc2luZyA9IGVsZW1lbnQ7XHJcblx0ICAgICAgICAgICAgICAgIHZhciBvcGVuXzEgPSBnZXRRdWFsaWZpZWRFbGVtZW50TmFtZShlbC5vcGVuaW5nLm5hbWUpO1xyXG5cdCAgICAgICAgICAgICAgICB2YXIgY2xvc2VfMSA9IGdldFF1YWxpZmllZEVsZW1lbnROYW1lKGVsLmNsb3NpbmcubmFtZSk7XHJcblx0ICAgICAgICAgICAgICAgIGlmIChvcGVuXzEgIT09IGNsb3NlXzEpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgIHRoaXMudG9sZXJhdGVFcnJvcignRXhwZWN0ZWQgY29ycmVzcG9uZGluZyBKU1ggY2xvc2luZyB0YWcgZm9yICUwJywgb3Blbl8xKTtcclxuXHQgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICBpZiAoc3RhY2subGVuZ3RoID4gMCkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIGNoaWxkID0gdGhpcy5maW5hbGl6ZShlbC5ub2RlLCBuZXcgSlNYTm9kZS5KU1hFbGVtZW50KGVsLm9wZW5pbmcsIGVsLmNoaWxkcmVuLCBlbC5jbG9zaW5nKSk7XHJcblx0ICAgICAgICAgICAgICAgICAgICBlbCA9IHN0YWNrW3N0YWNrLmxlbmd0aCAtIDFdO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgZWwuY2hpbGRyZW4ucHVzaChjaGlsZCk7XHJcblx0ICAgICAgICAgICAgICAgICAgICBzdGFjay5wb3AoKTtcclxuXHQgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICBlbHNlIHtcclxuXHQgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cdCAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgcmV0dXJuIGVsO1xyXG5cdCAgICB9O1xyXG5cdCAgICBKU1hQYXJzZXIucHJvdG90eXBlLnBhcnNlSlNYRWxlbWVudCA9IGZ1bmN0aW9uICgpIHtcclxuXHQgICAgICAgIHZhciBub2RlID0gdGhpcy5jcmVhdGVKU1hOb2RlKCk7XHJcblx0ICAgICAgICB2YXIgb3BlbmluZyA9IHRoaXMucGFyc2VKU1hPcGVuaW5nRWxlbWVudCgpO1xyXG5cdCAgICAgICAgdmFyIGNoaWxkcmVuID0gW107XHJcblx0ICAgICAgICB2YXIgY2xvc2luZyA9IG51bGw7XHJcblx0ICAgICAgICBpZiAoIW9wZW5pbmcuc2VsZkNsb3NpbmcpIHtcclxuXHQgICAgICAgICAgICB2YXIgZWwgPSB0aGlzLnBhcnNlQ29tcGxleEpTWEVsZW1lbnQoeyBub2RlOiBub2RlLCBvcGVuaW5nOiBvcGVuaW5nLCBjbG9zaW5nOiBjbG9zaW5nLCBjaGlsZHJlbjogY2hpbGRyZW4gfSk7XHJcblx0ICAgICAgICAgICAgY2hpbGRyZW4gPSBlbC5jaGlsZHJlbjtcclxuXHQgICAgICAgICAgICBjbG9zaW5nID0gZWwuY2xvc2luZztcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIHJldHVybiB0aGlzLmZpbmFsaXplKG5vZGUsIG5ldyBKU1hOb2RlLkpTWEVsZW1lbnQob3BlbmluZywgY2hpbGRyZW4sIGNsb3NpbmcpKTtcclxuXHQgICAgfTtcclxuXHQgICAgSlNYUGFyc2VyLnByb3RvdHlwZS5wYXJzZUpTWFJvb3QgPSBmdW5jdGlvbiAoKSB7XHJcblx0ICAgICAgICAvLyBQb3AgdGhlIG9wZW5pbmcgJzwnIGFkZGVkIGZyb20gdGhlIGxvb2thaGVhZC5cclxuXHQgICAgICAgIGlmICh0aGlzLmNvbmZpZy50b2tlbnMpIHtcclxuXHQgICAgICAgICAgICB0aGlzLnRva2Vucy5wb3AoKTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIHRoaXMuc3RhcnRKU1goKTtcclxuXHQgICAgICAgIHZhciBlbGVtZW50ID0gdGhpcy5wYXJzZUpTWEVsZW1lbnQoKTtcclxuXHQgICAgICAgIHRoaXMuZmluaXNoSlNYKCk7XHJcblx0ICAgICAgICByZXR1cm4gZWxlbWVudDtcclxuXHQgICAgfTtcclxuXHQgICAgSlNYUGFyc2VyLnByb3RvdHlwZS5pc1N0YXJ0T2ZFeHByZXNzaW9uID0gZnVuY3Rpb24gKCkge1xyXG5cdCAgICAgICAgcmV0dXJuIF9zdXBlci5wcm90b3R5cGUuaXNTdGFydE9mRXhwcmVzc2lvbi5jYWxsKHRoaXMpIHx8IHRoaXMubWF0Y2goJzwnKTtcclxuXHQgICAgfTtcclxuXHQgICAgcmV0dXJuIEpTWFBhcnNlcjtcclxuXHR9KHBhcnNlcl8xLlBhcnNlcikpO1xyXG5cdGV4cG9ydHMuSlNYUGFyc2VyID0gSlNYUGFyc2VyO1xyXG5cblxuLyoqKi8gfSxcbi8qIDQgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG5cdFwidXNlIHN0cmljdFwiO1xyXG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuXHQvLyBTZWUgYWxzbyB0b29scy9nZW5lcmF0ZS11bmljb2RlLXJlZ2V4LmpzLlxyXG5cdHZhciBSZWdleCA9IHtcclxuXHQgICAgLy8gVW5pY29kZSB2OC4wLjAgTm9uQXNjaWlJZGVudGlmaWVyU3RhcnQ6XHJcblx0ICAgIE5vbkFzY2lpSWRlbnRpZmllclN0YXJ0OiAvW1xceEFBXFx4QjVcXHhCQVxceEMwLVxceEQ2XFx4RDgtXFx4RjZcXHhGOC1cXHUwMkMxXFx1MDJDNi1cXHUwMkQxXFx1MDJFMC1cXHUwMkU0XFx1MDJFQ1xcdTAyRUVcXHUwMzcwLVxcdTAzNzRcXHUwMzc2XFx1MDM3N1xcdTAzN0EtXFx1MDM3RFxcdTAzN0ZcXHUwMzg2XFx1MDM4OC1cXHUwMzhBXFx1MDM4Q1xcdTAzOEUtXFx1MDNBMVxcdTAzQTMtXFx1MDNGNVxcdTAzRjctXFx1MDQ4MVxcdTA0OEEtXFx1MDUyRlxcdTA1MzEtXFx1MDU1NlxcdTA1NTlcXHUwNTYxLVxcdTA1ODdcXHUwNUQwLVxcdTA1RUFcXHUwNUYwLVxcdTA1RjJcXHUwNjIwLVxcdTA2NEFcXHUwNjZFXFx1MDY2RlxcdTA2NzEtXFx1MDZEM1xcdTA2RDVcXHUwNkU1XFx1MDZFNlxcdTA2RUVcXHUwNkVGXFx1MDZGQS1cXHUwNkZDXFx1MDZGRlxcdTA3MTBcXHUwNzEyLVxcdTA3MkZcXHUwNzRELVxcdTA3QTVcXHUwN0IxXFx1MDdDQS1cXHUwN0VBXFx1MDdGNFxcdTA3RjVcXHUwN0ZBXFx1MDgwMC1cXHUwODE1XFx1MDgxQVxcdTA4MjRcXHUwODI4XFx1MDg0MC1cXHUwODU4XFx1MDhBMC1cXHUwOEI0XFx1MDkwNC1cXHUwOTM5XFx1MDkzRFxcdTA5NTBcXHUwOTU4LVxcdTA5NjFcXHUwOTcxLVxcdTA5ODBcXHUwOTg1LVxcdTA5OENcXHUwOThGXFx1MDk5MFxcdTA5OTMtXFx1MDlBOFxcdTA5QUEtXFx1MDlCMFxcdTA5QjJcXHUwOUI2LVxcdTA5QjlcXHUwOUJEXFx1MDlDRVxcdTA5RENcXHUwOUREXFx1MDlERi1cXHUwOUUxXFx1MDlGMFxcdTA5RjFcXHUwQTA1LVxcdTBBMEFcXHUwQTBGXFx1MEExMFxcdTBBMTMtXFx1MEEyOFxcdTBBMkEtXFx1MEEzMFxcdTBBMzJcXHUwQTMzXFx1MEEzNVxcdTBBMzZcXHUwQTM4XFx1MEEzOVxcdTBBNTktXFx1MEE1Q1xcdTBBNUVcXHUwQTcyLVxcdTBBNzRcXHUwQTg1LVxcdTBBOERcXHUwQThGLVxcdTBBOTFcXHUwQTkzLVxcdTBBQThcXHUwQUFBLVxcdTBBQjBcXHUwQUIyXFx1MEFCM1xcdTBBQjUtXFx1MEFCOVxcdTBBQkRcXHUwQUQwXFx1MEFFMFxcdTBBRTFcXHUwQUY5XFx1MEIwNS1cXHUwQjBDXFx1MEIwRlxcdTBCMTBcXHUwQjEzLVxcdTBCMjhcXHUwQjJBLVxcdTBCMzBcXHUwQjMyXFx1MEIzM1xcdTBCMzUtXFx1MEIzOVxcdTBCM0RcXHUwQjVDXFx1MEI1RFxcdTBCNUYtXFx1MEI2MVxcdTBCNzFcXHUwQjgzXFx1MEI4NS1cXHUwQjhBXFx1MEI4RS1cXHUwQjkwXFx1MEI5Mi1cXHUwQjk1XFx1MEI5OVxcdTBCOUFcXHUwQjlDXFx1MEI5RVxcdTBCOUZcXHUwQkEzXFx1MEJBNFxcdTBCQTgtXFx1MEJBQVxcdTBCQUUtXFx1MEJCOVxcdTBCRDBcXHUwQzA1LVxcdTBDMENcXHUwQzBFLVxcdTBDMTBcXHUwQzEyLVxcdTBDMjhcXHUwQzJBLVxcdTBDMzlcXHUwQzNEXFx1MEM1OC1cXHUwQzVBXFx1MEM2MFxcdTBDNjFcXHUwQzg1LVxcdTBDOENcXHUwQzhFLVxcdTBDOTBcXHUwQzkyLVxcdTBDQThcXHUwQ0FBLVxcdTBDQjNcXHUwQ0I1LVxcdTBDQjlcXHUwQ0JEXFx1MENERVxcdTBDRTBcXHUwQ0UxXFx1MENGMVxcdTBDRjJcXHUwRDA1LVxcdTBEMENcXHUwRDBFLVxcdTBEMTBcXHUwRDEyLVxcdTBEM0FcXHUwRDNEXFx1MEQ0RVxcdTBENUYtXFx1MEQ2MVxcdTBEN0EtXFx1MEQ3RlxcdTBEODUtXFx1MEQ5NlxcdTBEOUEtXFx1MERCMVxcdTBEQjMtXFx1MERCQlxcdTBEQkRcXHUwREMwLVxcdTBEQzZcXHUwRTAxLVxcdTBFMzBcXHUwRTMyXFx1MEUzM1xcdTBFNDAtXFx1MEU0NlxcdTBFODFcXHUwRTgyXFx1MEU4NFxcdTBFODdcXHUwRTg4XFx1MEU4QVxcdTBFOERcXHUwRTk0LVxcdTBFOTdcXHUwRTk5LVxcdTBFOUZcXHUwRUExLVxcdTBFQTNcXHUwRUE1XFx1MEVBN1xcdTBFQUFcXHUwRUFCXFx1MEVBRC1cXHUwRUIwXFx1MEVCMlxcdTBFQjNcXHUwRUJEXFx1MEVDMC1cXHUwRUM0XFx1MEVDNlxcdTBFREMtXFx1MEVERlxcdTBGMDBcXHUwRjQwLVxcdTBGNDdcXHUwRjQ5LVxcdTBGNkNcXHUwRjg4LVxcdTBGOENcXHUxMDAwLVxcdTEwMkFcXHUxMDNGXFx1MTA1MC1cXHUxMDU1XFx1MTA1QS1cXHUxMDVEXFx1MTA2MVxcdTEwNjVcXHUxMDY2XFx1MTA2RS1cXHUxMDcwXFx1MTA3NS1cXHUxMDgxXFx1MTA4RVxcdTEwQTAtXFx1MTBDNVxcdTEwQzdcXHUxMENEXFx1MTBEMC1cXHUxMEZBXFx1MTBGQy1cXHUxMjQ4XFx1MTI0QS1cXHUxMjREXFx1MTI1MC1cXHUxMjU2XFx1MTI1OFxcdTEyNUEtXFx1MTI1RFxcdTEyNjAtXFx1MTI4OFxcdTEyOEEtXFx1MTI4RFxcdTEyOTAtXFx1MTJCMFxcdTEyQjItXFx1MTJCNVxcdTEyQjgtXFx1MTJCRVxcdTEyQzBcXHUxMkMyLVxcdTEyQzVcXHUxMkM4LVxcdTEyRDZcXHUxMkQ4LVxcdTEzMTBcXHUxMzEyLVxcdTEzMTVcXHUxMzE4LVxcdTEzNUFcXHUxMzgwLVxcdTEzOEZcXHUxM0EwLVxcdTEzRjVcXHUxM0Y4LVxcdTEzRkRcXHUxNDAxLVxcdTE2NkNcXHUxNjZGLVxcdTE2N0ZcXHUxNjgxLVxcdTE2OUFcXHUxNkEwLVxcdTE2RUFcXHUxNkVFLVxcdTE2RjhcXHUxNzAwLVxcdTE3MENcXHUxNzBFLVxcdTE3MTFcXHUxNzIwLVxcdTE3MzFcXHUxNzQwLVxcdTE3NTFcXHUxNzYwLVxcdTE3NkNcXHUxNzZFLVxcdTE3NzBcXHUxNzgwLVxcdTE3QjNcXHUxN0Q3XFx1MTdEQ1xcdTE4MjAtXFx1MTg3N1xcdTE4ODAtXFx1MThBOFxcdTE4QUFcXHUxOEIwLVxcdTE4RjVcXHUxOTAwLVxcdTE5MUVcXHUxOTUwLVxcdTE5NkRcXHUxOTcwLVxcdTE5NzRcXHUxOTgwLVxcdTE5QUJcXHUxOUIwLVxcdTE5QzlcXHUxQTAwLVxcdTFBMTZcXHUxQTIwLVxcdTFBNTRcXHUxQUE3XFx1MUIwNS1cXHUxQjMzXFx1MUI0NS1cXHUxQjRCXFx1MUI4My1cXHUxQkEwXFx1MUJBRVxcdTFCQUZcXHUxQkJBLVxcdTFCRTVcXHUxQzAwLVxcdTFDMjNcXHUxQzRELVxcdTFDNEZcXHUxQzVBLVxcdTFDN0RcXHUxQ0U5LVxcdTFDRUNcXHUxQ0VFLVxcdTFDRjFcXHUxQ0Y1XFx1MUNGNlxcdTFEMDAtXFx1MURCRlxcdTFFMDAtXFx1MUYxNVxcdTFGMTgtXFx1MUYxRFxcdTFGMjAtXFx1MUY0NVxcdTFGNDgtXFx1MUY0RFxcdTFGNTAtXFx1MUY1N1xcdTFGNTlcXHUxRjVCXFx1MUY1RFxcdTFGNUYtXFx1MUY3RFxcdTFGODAtXFx1MUZCNFxcdTFGQjYtXFx1MUZCQ1xcdTFGQkVcXHUxRkMyLVxcdTFGQzRcXHUxRkM2LVxcdTFGQ0NcXHUxRkQwLVxcdTFGRDNcXHUxRkQ2LVxcdTFGREJcXHUxRkUwLVxcdTFGRUNcXHUxRkYyLVxcdTFGRjRcXHUxRkY2LVxcdTFGRkNcXHUyMDcxXFx1MjA3RlxcdTIwOTAtXFx1MjA5Q1xcdTIxMDJcXHUyMTA3XFx1MjEwQS1cXHUyMTEzXFx1MjExNVxcdTIxMTgtXFx1MjExRFxcdTIxMjRcXHUyMTI2XFx1MjEyOFxcdTIxMkEtXFx1MjEzOVxcdTIxM0MtXFx1MjEzRlxcdTIxNDUtXFx1MjE0OVxcdTIxNEVcXHUyMTYwLVxcdTIxODhcXHUyQzAwLVxcdTJDMkVcXHUyQzMwLVxcdTJDNUVcXHUyQzYwLVxcdTJDRTRcXHUyQ0VCLVxcdTJDRUVcXHUyQ0YyXFx1MkNGM1xcdTJEMDAtXFx1MkQyNVxcdTJEMjdcXHUyRDJEXFx1MkQzMC1cXHUyRDY3XFx1MkQ2RlxcdTJEODAtXFx1MkQ5NlxcdTJEQTAtXFx1MkRBNlxcdTJEQTgtXFx1MkRBRVxcdTJEQjAtXFx1MkRCNlxcdTJEQjgtXFx1MkRCRVxcdTJEQzAtXFx1MkRDNlxcdTJEQzgtXFx1MkRDRVxcdTJERDAtXFx1MkRENlxcdTJERDgtXFx1MkRERVxcdTMwMDUtXFx1MzAwN1xcdTMwMjEtXFx1MzAyOVxcdTMwMzEtXFx1MzAzNVxcdTMwMzgtXFx1MzAzQ1xcdTMwNDEtXFx1MzA5NlxcdTMwOUItXFx1MzA5RlxcdTMwQTEtXFx1MzBGQVxcdTMwRkMtXFx1MzBGRlxcdTMxMDUtXFx1MzEyRFxcdTMxMzEtXFx1MzE4RVxcdTMxQTAtXFx1MzFCQVxcdTMxRjAtXFx1MzFGRlxcdTM0MDAtXFx1NERCNVxcdTRFMDAtXFx1OUZENVxcdUEwMDAtXFx1QTQ4Q1xcdUE0RDAtXFx1QTRGRFxcdUE1MDAtXFx1QTYwQ1xcdUE2MTAtXFx1QTYxRlxcdUE2MkFcXHVBNjJCXFx1QTY0MC1cXHVBNjZFXFx1QTY3Ri1cXHVBNjlEXFx1QTZBMC1cXHVBNkVGXFx1QTcxNy1cXHVBNzFGXFx1QTcyMi1cXHVBNzg4XFx1QTc4Qi1cXHVBN0FEXFx1QTdCMC1cXHVBN0I3XFx1QTdGNy1cXHVBODAxXFx1QTgwMy1cXHVBODA1XFx1QTgwNy1cXHVBODBBXFx1QTgwQy1cXHVBODIyXFx1QTg0MC1cXHVBODczXFx1QTg4Mi1cXHVBOEIzXFx1QThGMi1cXHVBOEY3XFx1QThGQlxcdUE4RkRcXHVBOTBBLVxcdUE5MjVcXHVBOTMwLVxcdUE5NDZcXHVBOTYwLVxcdUE5N0NcXHVBOTg0LVxcdUE5QjJcXHVBOUNGXFx1QTlFMC1cXHVBOUU0XFx1QTlFNi1cXHVBOUVGXFx1QTlGQS1cXHVBOUZFXFx1QUEwMC1cXHVBQTI4XFx1QUE0MC1cXHVBQTQyXFx1QUE0NC1cXHVBQTRCXFx1QUE2MC1cXHVBQTc2XFx1QUE3QVxcdUFBN0UtXFx1QUFBRlxcdUFBQjFcXHVBQUI1XFx1QUFCNlxcdUFBQjktXFx1QUFCRFxcdUFBQzBcXHVBQUMyXFx1QUFEQi1cXHVBQUREXFx1QUFFMC1cXHVBQUVBXFx1QUFGMi1cXHVBQUY0XFx1QUIwMS1cXHVBQjA2XFx1QUIwOS1cXHVBQjBFXFx1QUIxMS1cXHVBQjE2XFx1QUIyMC1cXHVBQjI2XFx1QUIyOC1cXHVBQjJFXFx1QUIzMC1cXHVBQjVBXFx1QUI1Qy1cXHVBQjY1XFx1QUI3MC1cXHVBQkUyXFx1QUMwMC1cXHVEN0EzXFx1RDdCMC1cXHVEN0M2XFx1RDdDQi1cXHVEN0ZCXFx1RjkwMC1cXHVGQTZEXFx1RkE3MC1cXHVGQUQ5XFx1RkIwMC1cXHVGQjA2XFx1RkIxMy1cXHVGQjE3XFx1RkIxRFxcdUZCMUYtXFx1RkIyOFxcdUZCMkEtXFx1RkIzNlxcdUZCMzgtXFx1RkIzQ1xcdUZCM0VcXHVGQjQwXFx1RkI0MVxcdUZCNDNcXHVGQjQ0XFx1RkI0Ni1cXHVGQkIxXFx1RkJEMy1cXHVGRDNEXFx1RkQ1MC1cXHVGRDhGXFx1RkQ5Mi1cXHVGREM3XFx1RkRGMC1cXHVGREZCXFx1RkU3MC1cXHVGRTc0XFx1RkU3Ni1cXHVGRUZDXFx1RkYyMS1cXHVGRjNBXFx1RkY0MS1cXHVGRjVBXFx1RkY2Ni1cXHVGRkJFXFx1RkZDMi1cXHVGRkM3XFx1RkZDQS1cXHVGRkNGXFx1RkZEMi1cXHVGRkQ3XFx1RkZEQS1cXHVGRkRDXXxcXHVEODAwW1xcdURDMDAtXFx1REMwQlxcdURDMEQtXFx1REMyNlxcdURDMjgtXFx1REMzQVxcdURDM0NcXHVEQzNEXFx1REMzRi1cXHVEQzREXFx1REM1MC1cXHVEQzVEXFx1REM4MC1cXHVEQ0ZBXFx1REQ0MC1cXHVERDc0XFx1REU4MC1cXHVERTlDXFx1REVBMC1cXHVERUQwXFx1REYwMC1cXHVERjFGXFx1REYzMC1cXHVERjRBXFx1REY1MC1cXHVERjc1XFx1REY4MC1cXHVERjlEXFx1REZBMC1cXHVERkMzXFx1REZDOC1cXHVERkNGXFx1REZEMS1cXHVERkQ1XXxcXHVEODAxW1xcdURDMDAtXFx1REM5RFxcdUREMDAtXFx1REQyN1xcdUREMzAtXFx1REQ2M1xcdURFMDAtXFx1REYzNlxcdURGNDAtXFx1REY1NVxcdURGNjAtXFx1REY2N118XFx1RDgwMltcXHVEQzAwLVxcdURDMDVcXHVEQzA4XFx1REMwQS1cXHVEQzM1XFx1REMzN1xcdURDMzhcXHVEQzNDXFx1REMzRi1cXHVEQzU1XFx1REM2MC1cXHVEQzc2XFx1REM4MC1cXHVEQzlFXFx1RENFMC1cXHVEQ0YyXFx1RENGNFxcdURDRjVcXHVERDAwLVxcdUREMTVcXHVERDIwLVxcdUREMzlcXHVERDgwLVxcdUREQjdcXHVEREJFXFx1RERCRlxcdURFMDBcXHVERTEwLVxcdURFMTNcXHVERTE1LVxcdURFMTdcXHVERTE5LVxcdURFMzNcXHVERTYwLVxcdURFN0NcXHVERTgwLVxcdURFOUNcXHVERUMwLVxcdURFQzdcXHVERUM5LVxcdURFRTRcXHVERjAwLVxcdURGMzVcXHVERjQwLVxcdURGNTVcXHVERjYwLVxcdURGNzJcXHVERjgwLVxcdURGOTFdfFxcdUQ4MDNbXFx1REMwMC1cXHVEQzQ4XFx1REM4MC1cXHVEQ0IyXFx1RENDMC1cXHVEQ0YyXXxcXHVEODA0W1xcdURDMDMtXFx1REMzN1xcdURDODMtXFx1RENBRlxcdURDRDAtXFx1RENFOFxcdUREMDMtXFx1REQyNlxcdURENTAtXFx1REQ3MlxcdURENzZcXHVERDgzLVxcdUREQjJcXHVEREMxLVxcdUREQzRcXHVERERBXFx1REREQ1xcdURFMDAtXFx1REUxMVxcdURFMTMtXFx1REUyQlxcdURFODAtXFx1REU4NlxcdURFODhcXHVERThBLVxcdURFOERcXHVERThGLVxcdURFOURcXHVERTlGLVxcdURFQThcXHVERUIwLVxcdURFREVcXHVERjA1LVxcdURGMENcXHVERjBGXFx1REYxMFxcdURGMTMtXFx1REYyOFxcdURGMkEtXFx1REYzMFxcdURGMzJcXHVERjMzXFx1REYzNS1cXHVERjM5XFx1REYzRFxcdURGNTBcXHVERjVELVxcdURGNjFdfFxcdUQ4MDVbXFx1REM4MC1cXHVEQ0FGXFx1RENDNFxcdURDQzVcXHVEQ0M3XFx1REQ4MC1cXHVEREFFXFx1REREOC1cXHVERERCXFx1REUwMC1cXHVERTJGXFx1REU0NFxcdURFODAtXFx1REVBQVxcdURGMDAtXFx1REYxOV18XFx1RDgwNltcXHVEQ0EwLVxcdURDREZcXHVEQ0ZGXFx1REVDMC1cXHVERUY4XXxcXHVEODA4W1xcdURDMDAtXFx1REY5OV18XFx1RDgwOVtcXHVEQzAwLVxcdURDNkVcXHVEQzgwLVxcdURENDNdfFtcXHVEODBDXFx1RDg0MC1cXHVEODY4XFx1RDg2QS1cXHVEODZDXFx1RDg2Ri1cXHVEODcyXVtcXHVEQzAwLVxcdURGRkZdfFxcdUQ4MERbXFx1REMwMC1cXHVEQzJFXXxcXHVEODExW1xcdURDMDAtXFx1REU0Nl18XFx1RDgxQVtcXHVEQzAwLVxcdURFMzhcXHVERTQwLVxcdURFNUVcXHVERUQwLVxcdURFRURcXHVERjAwLVxcdURGMkZcXHVERjQwLVxcdURGNDNcXHVERjYzLVxcdURGNzdcXHVERjdELVxcdURGOEZdfFxcdUQ4MUJbXFx1REYwMC1cXHVERjQ0XFx1REY1MFxcdURGOTMtXFx1REY5Rl18XFx1RDgyQ1tcXHVEQzAwXFx1REMwMV18XFx1RDgyRltcXHVEQzAwLVxcdURDNkFcXHVEQzcwLVxcdURDN0NcXHVEQzgwLVxcdURDODhcXHVEQzkwLVxcdURDOTldfFxcdUQ4MzVbXFx1REMwMC1cXHVEQzU0XFx1REM1Ni1cXHVEQzlDXFx1REM5RVxcdURDOUZcXHVEQ0EyXFx1RENBNVxcdURDQTZcXHVEQ0E5LVxcdURDQUNcXHVEQ0FFLVxcdURDQjlcXHVEQ0JCXFx1RENCRC1cXHVEQ0MzXFx1RENDNS1cXHVERDA1XFx1REQwNy1cXHVERDBBXFx1REQwRC1cXHVERDE0XFx1REQxNi1cXHVERDFDXFx1REQxRS1cXHVERDM5XFx1REQzQi1cXHVERDNFXFx1REQ0MC1cXHVERDQ0XFx1REQ0NlxcdURENEEtXFx1REQ1MFxcdURENTItXFx1REVBNVxcdURFQTgtXFx1REVDMFxcdURFQzItXFx1REVEQVxcdURFREMtXFx1REVGQVxcdURFRkMtXFx1REYxNFxcdURGMTYtXFx1REYzNFxcdURGMzYtXFx1REY0RVxcdURGNTAtXFx1REY2RVxcdURGNzAtXFx1REY4OFxcdURGOEEtXFx1REZBOFxcdURGQUEtXFx1REZDMlxcdURGQzQtXFx1REZDQl18XFx1RDgzQVtcXHVEQzAwLVxcdURDQzRdfFxcdUQ4M0JbXFx1REUwMC1cXHVERTAzXFx1REUwNS1cXHVERTFGXFx1REUyMVxcdURFMjJcXHVERTI0XFx1REUyN1xcdURFMjktXFx1REUzMlxcdURFMzQtXFx1REUzN1xcdURFMzlcXHVERTNCXFx1REU0MlxcdURFNDdcXHVERTQ5XFx1REU0QlxcdURFNEQtXFx1REU0RlxcdURFNTFcXHVERTUyXFx1REU1NFxcdURFNTdcXHVERTU5XFx1REU1QlxcdURFNURcXHVERTVGXFx1REU2MVxcdURFNjJcXHVERTY0XFx1REU2Ny1cXHVERTZBXFx1REU2Qy1cXHVERTcyXFx1REU3NC1cXHVERTc3XFx1REU3OS1cXHVERTdDXFx1REU3RVxcdURFODAtXFx1REU4OVxcdURFOEItXFx1REU5QlxcdURFQTEtXFx1REVBM1xcdURFQTUtXFx1REVBOVxcdURFQUItXFx1REVCQl18XFx1RDg2OVtcXHVEQzAwLVxcdURFRDZcXHVERjAwLVxcdURGRkZdfFxcdUQ4NkRbXFx1REMwMC1cXHVERjM0XFx1REY0MC1cXHVERkZGXXxcXHVEODZFW1xcdURDMDAtXFx1REMxRFxcdURDMjAtXFx1REZGRl18XFx1RDg3M1tcXHVEQzAwLVxcdURFQTFdfFxcdUQ4N0VbXFx1REMwMC1cXHVERTFEXS8sXHJcblx0ICAgIC8vIFVuaWNvZGUgdjguMC4wIE5vbkFzY2lpSWRlbnRpZmllclBhcnQ6XHJcblx0ICAgIE5vbkFzY2lpSWRlbnRpZmllclBhcnQ6IC9bXFx4QUFcXHhCNVxceEI3XFx4QkFcXHhDMC1cXHhENlxceEQ4LVxceEY2XFx4RjgtXFx1MDJDMVxcdTAyQzYtXFx1MDJEMVxcdTAyRTAtXFx1MDJFNFxcdTAyRUNcXHUwMkVFXFx1MDMwMC1cXHUwMzc0XFx1MDM3NlxcdTAzNzdcXHUwMzdBLVxcdTAzN0RcXHUwMzdGXFx1MDM4Ni1cXHUwMzhBXFx1MDM4Q1xcdTAzOEUtXFx1MDNBMVxcdTAzQTMtXFx1MDNGNVxcdTAzRjctXFx1MDQ4MVxcdTA0ODMtXFx1MDQ4N1xcdTA0OEEtXFx1MDUyRlxcdTA1MzEtXFx1MDU1NlxcdTA1NTlcXHUwNTYxLVxcdTA1ODdcXHUwNTkxLVxcdTA1QkRcXHUwNUJGXFx1MDVDMVxcdTA1QzJcXHUwNUM0XFx1MDVDNVxcdTA1QzdcXHUwNUQwLVxcdTA1RUFcXHUwNUYwLVxcdTA1RjJcXHUwNjEwLVxcdTA2MUFcXHUwNjIwLVxcdTA2NjlcXHUwNjZFLVxcdTA2RDNcXHUwNkQ1LVxcdTA2RENcXHUwNkRGLVxcdTA2RThcXHUwNkVBLVxcdTA2RkNcXHUwNkZGXFx1MDcxMC1cXHUwNzRBXFx1MDc0RC1cXHUwN0IxXFx1MDdDMC1cXHUwN0Y1XFx1MDdGQVxcdTA4MDAtXFx1MDgyRFxcdTA4NDAtXFx1MDg1QlxcdTA4QTAtXFx1MDhCNFxcdTA4RTMtXFx1MDk2M1xcdTA5NjYtXFx1MDk2RlxcdTA5NzEtXFx1MDk4M1xcdTA5ODUtXFx1MDk4Q1xcdTA5OEZcXHUwOTkwXFx1MDk5My1cXHUwOUE4XFx1MDlBQS1cXHUwOUIwXFx1MDlCMlxcdTA5QjYtXFx1MDlCOVxcdTA5QkMtXFx1MDlDNFxcdTA5QzdcXHUwOUM4XFx1MDlDQi1cXHUwOUNFXFx1MDlEN1xcdTA5RENcXHUwOUREXFx1MDlERi1cXHUwOUUzXFx1MDlFNi1cXHUwOUYxXFx1MEEwMS1cXHUwQTAzXFx1MEEwNS1cXHUwQTBBXFx1MEEwRlxcdTBBMTBcXHUwQTEzLVxcdTBBMjhcXHUwQTJBLVxcdTBBMzBcXHUwQTMyXFx1MEEzM1xcdTBBMzVcXHUwQTM2XFx1MEEzOFxcdTBBMzlcXHUwQTNDXFx1MEEzRS1cXHUwQTQyXFx1MEE0N1xcdTBBNDhcXHUwQTRCLVxcdTBBNERcXHUwQTUxXFx1MEE1OS1cXHUwQTVDXFx1MEE1RVxcdTBBNjYtXFx1MEE3NVxcdTBBODEtXFx1MEE4M1xcdTBBODUtXFx1MEE4RFxcdTBBOEYtXFx1MEE5MVxcdTBBOTMtXFx1MEFBOFxcdTBBQUEtXFx1MEFCMFxcdTBBQjJcXHUwQUIzXFx1MEFCNS1cXHUwQUI5XFx1MEFCQy1cXHUwQUM1XFx1MEFDNy1cXHUwQUM5XFx1MEFDQi1cXHUwQUNEXFx1MEFEMFxcdTBBRTAtXFx1MEFFM1xcdTBBRTYtXFx1MEFFRlxcdTBBRjlcXHUwQjAxLVxcdTBCMDNcXHUwQjA1LVxcdTBCMENcXHUwQjBGXFx1MEIxMFxcdTBCMTMtXFx1MEIyOFxcdTBCMkEtXFx1MEIzMFxcdTBCMzJcXHUwQjMzXFx1MEIzNS1cXHUwQjM5XFx1MEIzQy1cXHUwQjQ0XFx1MEI0N1xcdTBCNDhcXHUwQjRCLVxcdTBCNERcXHUwQjU2XFx1MEI1N1xcdTBCNUNcXHUwQjVEXFx1MEI1Ri1cXHUwQjYzXFx1MEI2Ni1cXHUwQjZGXFx1MEI3MVxcdTBCODJcXHUwQjgzXFx1MEI4NS1cXHUwQjhBXFx1MEI4RS1cXHUwQjkwXFx1MEI5Mi1cXHUwQjk1XFx1MEI5OVxcdTBCOUFcXHUwQjlDXFx1MEI5RVxcdTBCOUZcXHUwQkEzXFx1MEJBNFxcdTBCQTgtXFx1MEJBQVxcdTBCQUUtXFx1MEJCOVxcdTBCQkUtXFx1MEJDMlxcdTBCQzYtXFx1MEJDOFxcdTBCQ0EtXFx1MEJDRFxcdTBCRDBcXHUwQkQ3XFx1MEJFNi1cXHUwQkVGXFx1MEMwMC1cXHUwQzAzXFx1MEMwNS1cXHUwQzBDXFx1MEMwRS1cXHUwQzEwXFx1MEMxMi1cXHUwQzI4XFx1MEMyQS1cXHUwQzM5XFx1MEMzRC1cXHUwQzQ0XFx1MEM0Ni1cXHUwQzQ4XFx1MEM0QS1cXHUwQzREXFx1MEM1NVxcdTBDNTZcXHUwQzU4LVxcdTBDNUFcXHUwQzYwLVxcdTBDNjNcXHUwQzY2LVxcdTBDNkZcXHUwQzgxLVxcdTBDODNcXHUwQzg1LVxcdTBDOENcXHUwQzhFLVxcdTBDOTBcXHUwQzkyLVxcdTBDQThcXHUwQ0FBLVxcdTBDQjNcXHUwQ0I1LVxcdTBDQjlcXHUwQ0JDLVxcdTBDQzRcXHUwQ0M2LVxcdTBDQzhcXHUwQ0NBLVxcdTBDQ0RcXHUwQ0Q1XFx1MENENlxcdTBDREVcXHUwQ0UwLVxcdTBDRTNcXHUwQ0U2LVxcdTBDRUZcXHUwQ0YxXFx1MENGMlxcdTBEMDEtXFx1MEQwM1xcdTBEMDUtXFx1MEQwQ1xcdTBEMEUtXFx1MEQxMFxcdTBEMTItXFx1MEQzQVxcdTBEM0QtXFx1MEQ0NFxcdTBENDYtXFx1MEQ0OFxcdTBENEEtXFx1MEQ0RVxcdTBENTdcXHUwRDVGLVxcdTBENjNcXHUwRDY2LVxcdTBENkZcXHUwRDdBLVxcdTBEN0ZcXHUwRDgyXFx1MEQ4M1xcdTBEODUtXFx1MEQ5NlxcdTBEOUEtXFx1MERCMVxcdTBEQjMtXFx1MERCQlxcdTBEQkRcXHUwREMwLVxcdTBEQzZcXHUwRENBXFx1MERDRi1cXHUwREQ0XFx1MERENlxcdTBERDgtXFx1MERERlxcdTBERTYtXFx1MERFRlxcdTBERjJcXHUwREYzXFx1MEUwMS1cXHUwRTNBXFx1MEU0MC1cXHUwRTRFXFx1MEU1MC1cXHUwRTU5XFx1MEU4MVxcdTBFODJcXHUwRTg0XFx1MEU4N1xcdTBFODhcXHUwRThBXFx1MEU4RFxcdTBFOTQtXFx1MEU5N1xcdTBFOTktXFx1MEU5RlxcdTBFQTEtXFx1MEVBM1xcdTBFQTVcXHUwRUE3XFx1MEVBQVxcdTBFQUJcXHUwRUFELVxcdTBFQjlcXHUwRUJCLVxcdTBFQkRcXHUwRUMwLVxcdTBFQzRcXHUwRUM2XFx1MEVDOC1cXHUwRUNEXFx1MEVEMC1cXHUwRUQ5XFx1MEVEQy1cXHUwRURGXFx1MEYwMFxcdTBGMThcXHUwRjE5XFx1MEYyMC1cXHUwRjI5XFx1MEYzNVxcdTBGMzdcXHUwRjM5XFx1MEYzRS1cXHUwRjQ3XFx1MEY0OS1cXHUwRjZDXFx1MEY3MS1cXHUwRjg0XFx1MEY4Ni1cXHUwRjk3XFx1MEY5OS1cXHUwRkJDXFx1MEZDNlxcdTEwMDAtXFx1MTA0OVxcdTEwNTAtXFx1MTA5RFxcdTEwQTAtXFx1MTBDNVxcdTEwQzdcXHUxMENEXFx1MTBEMC1cXHUxMEZBXFx1MTBGQy1cXHUxMjQ4XFx1MTI0QS1cXHUxMjREXFx1MTI1MC1cXHUxMjU2XFx1MTI1OFxcdTEyNUEtXFx1MTI1RFxcdTEyNjAtXFx1MTI4OFxcdTEyOEEtXFx1MTI4RFxcdTEyOTAtXFx1MTJCMFxcdTEyQjItXFx1MTJCNVxcdTEyQjgtXFx1MTJCRVxcdTEyQzBcXHUxMkMyLVxcdTEyQzVcXHUxMkM4LVxcdTEyRDZcXHUxMkQ4LVxcdTEzMTBcXHUxMzEyLVxcdTEzMTVcXHUxMzE4LVxcdTEzNUFcXHUxMzVELVxcdTEzNUZcXHUxMzY5LVxcdTEzNzFcXHUxMzgwLVxcdTEzOEZcXHUxM0EwLVxcdTEzRjVcXHUxM0Y4LVxcdTEzRkRcXHUxNDAxLVxcdTE2NkNcXHUxNjZGLVxcdTE2N0ZcXHUxNjgxLVxcdTE2OUFcXHUxNkEwLVxcdTE2RUFcXHUxNkVFLVxcdTE2RjhcXHUxNzAwLVxcdTE3MENcXHUxNzBFLVxcdTE3MTRcXHUxNzIwLVxcdTE3MzRcXHUxNzQwLVxcdTE3NTNcXHUxNzYwLVxcdTE3NkNcXHUxNzZFLVxcdTE3NzBcXHUxNzcyXFx1MTc3M1xcdTE3ODAtXFx1MTdEM1xcdTE3RDdcXHUxN0RDXFx1MTdERFxcdTE3RTAtXFx1MTdFOVxcdTE4MEItXFx1MTgwRFxcdTE4MTAtXFx1MTgxOVxcdTE4MjAtXFx1MTg3N1xcdTE4ODAtXFx1MThBQVxcdTE4QjAtXFx1MThGNVxcdTE5MDAtXFx1MTkxRVxcdTE5MjAtXFx1MTkyQlxcdTE5MzAtXFx1MTkzQlxcdTE5NDYtXFx1MTk2RFxcdTE5NzAtXFx1MTk3NFxcdTE5ODAtXFx1MTlBQlxcdTE5QjAtXFx1MTlDOVxcdTE5RDAtXFx1MTlEQVxcdTFBMDAtXFx1MUExQlxcdTFBMjAtXFx1MUE1RVxcdTFBNjAtXFx1MUE3Q1xcdTFBN0YtXFx1MUE4OVxcdTFBOTAtXFx1MUE5OVxcdTFBQTdcXHUxQUIwLVxcdTFBQkRcXHUxQjAwLVxcdTFCNEJcXHUxQjUwLVxcdTFCNTlcXHUxQjZCLVxcdTFCNzNcXHUxQjgwLVxcdTFCRjNcXHUxQzAwLVxcdTFDMzdcXHUxQzQwLVxcdTFDNDlcXHUxQzRELVxcdTFDN0RcXHUxQ0QwLVxcdTFDRDJcXHUxQ0Q0LVxcdTFDRjZcXHUxQ0Y4XFx1MUNGOVxcdTFEMDAtXFx1MURGNVxcdTFERkMtXFx1MUYxNVxcdTFGMTgtXFx1MUYxRFxcdTFGMjAtXFx1MUY0NVxcdTFGNDgtXFx1MUY0RFxcdTFGNTAtXFx1MUY1N1xcdTFGNTlcXHUxRjVCXFx1MUY1RFxcdTFGNUYtXFx1MUY3RFxcdTFGODAtXFx1MUZCNFxcdTFGQjYtXFx1MUZCQ1xcdTFGQkVcXHUxRkMyLVxcdTFGQzRcXHUxRkM2LVxcdTFGQ0NcXHUxRkQwLVxcdTFGRDNcXHUxRkQ2LVxcdTFGREJcXHUxRkUwLVxcdTFGRUNcXHUxRkYyLVxcdTFGRjRcXHUxRkY2LVxcdTFGRkNcXHUyMDBDXFx1MjAwRFxcdTIwM0ZcXHUyMDQwXFx1MjA1NFxcdTIwNzFcXHUyMDdGXFx1MjA5MC1cXHUyMDlDXFx1MjBEMC1cXHUyMERDXFx1MjBFMVxcdTIwRTUtXFx1MjBGMFxcdTIxMDJcXHUyMTA3XFx1MjEwQS1cXHUyMTEzXFx1MjExNVxcdTIxMTgtXFx1MjExRFxcdTIxMjRcXHUyMTI2XFx1MjEyOFxcdTIxMkEtXFx1MjEzOVxcdTIxM0MtXFx1MjEzRlxcdTIxNDUtXFx1MjE0OVxcdTIxNEVcXHUyMTYwLVxcdTIxODhcXHUyQzAwLVxcdTJDMkVcXHUyQzMwLVxcdTJDNUVcXHUyQzYwLVxcdTJDRTRcXHUyQ0VCLVxcdTJDRjNcXHUyRDAwLVxcdTJEMjVcXHUyRDI3XFx1MkQyRFxcdTJEMzAtXFx1MkQ2N1xcdTJENkZcXHUyRDdGLVxcdTJEOTZcXHUyREEwLVxcdTJEQTZcXHUyREE4LVxcdTJEQUVcXHUyREIwLVxcdTJEQjZcXHUyREI4LVxcdTJEQkVcXHUyREMwLVxcdTJEQzZcXHUyREM4LVxcdTJEQ0VcXHUyREQwLVxcdTJERDZcXHUyREQ4LVxcdTJEREVcXHUyREUwLVxcdTJERkZcXHUzMDA1LVxcdTMwMDdcXHUzMDIxLVxcdTMwMkZcXHUzMDMxLVxcdTMwMzVcXHUzMDM4LVxcdTMwM0NcXHUzMDQxLVxcdTMwOTZcXHUzMDk5LVxcdTMwOUZcXHUzMEExLVxcdTMwRkFcXHUzMEZDLVxcdTMwRkZcXHUzMTA1LVxcdTMxMkRcXHUzMTMxLVxcdTMxOEVcXHUzMUEwLVxcdTMxQkFcXHUzMUYwLVxcdTMxRkZcXHUzNDAwLVxcdTREQjVcXHU0RTAwLVxcdTlGRDVcXHVBMDAwLVxcdUE0OENcXHVBNEQwLVxcdUE0RkRcXHVBNTAwLVxcdUE2MENcXHVBNjEwLVxcdUE2MkJcXHVBNjQwLVxcdUE2NkZcXHVBNjc0LVxcdUE2N0RcXHVBNjdGLVxcdUE2RjFcXHVBNzE3LVxcdUE3MUZcXHVBNzIyLVxcdUE3ODhcXHVBNzhCLVxcdUE3QURcXHVBN0IwLVxcdUE3QjdcXHVBN0Y3LVxcdUE4MjdcXHVBODQwLVxcdUE4NzNcXHVBODgwLVxcdUE4QzRcXHVBOEQwLVxcdUE4RDlcXHVBOEUwLVxcdUE4RjdcXHVBOEZCXFx1QThGRFxcdUE5MDAtXFx1QTkyRFxcdUE5MzAtXFx1QTk1M1xcdUE5NjAtXFx1QTk3Q1xcdUE5ODAtXFx1QTlDMFxcdUE5Q0YtXFx1QTlEOVxcdUE5RTAtXFx1QTlGRVxcdUFBMDAtXFx1QUEzNlxcdUFBNDAtXFx1QUE0RFxcdUFBNTAtXFx1QUE1OVxcdUFBNjAtXFx1QUE3NlxcdUFBN0EtXFx1QUFDMlxcdUFBREItXFx1QUFERFxcdUFBRTAtXFx1QUFFRlxcdUFBRjItXFx1QUFGNlxcdUFCMDEtXFx1QUIwNlxcdUFCMDktXFx1QUIwRVxcdUFCMTEtXFx1QUIxNlxcdUFCMjAtXFx1QUIyNlxcdUFCMjgtXFx1QUIyRVxcdUFCMzAtXFx1QUI1QVxcdUFCNUMtXFx1QUI2NVxcdUFCNzAtXFx1QUJFQVxcdUFCRUNcXHVBQkVEXFx1QUJGMC1cXHVBQkY5XFx1QUMwMC1cXHVEN0EzXFx1RDdCMC1cXHVEN0M2XFx1RDdDQi1cXHVEN0ZCXFx1RjkwMC1cXHVGQTZEXFx1RkE3MC1cXHVGQUQ5XFx1RkIwMC1cXHVGQjA2XFx1RkIxMy1cXHVGQjE3XFx1RkIxRC1cXHVGQjI4XFx1RkIyQS1cXHVGQjM2XFx1RkIzOC1cXHVGQjNDXFx1RkIzRVxcdUZCNDBcXHVGQjQxXFx1RkI0M1xcdUZCNDRcXHVGQjQ2LVxcdUZCQjFcXHVGQkQzLVxcdUZEM0RcXHVGRDUwLVxcdUZEOEZcXHVGRDkyLVxcdUZEQzdcXHVGREYwLVxcdUZERkJcXHVGRTAwLVxcdUZFMEZcXHVGRTIwLVxcdUZFMkZcXHVGRTMzXFx1RkUzNFxcdUZFNEQtXFx1RkU0RlxcdUZFNzAtXFx1RkU3NFxcdUZFNzYtXFx1RkVGQ1xcdUZGMTAtXFx1RkYxOVxcdUZGMjEtXFx1RkYzQVxcdUZGM0ZcXHVGRjQxLVxcdUZGNUFcXHVGRjY2LVxcdUZGQkVcXHVGRkMyLVxcdUZGQzdcXHVGRkNBLVxcdUZGQ0ZcXHVGRkQyLVxcdUZGRDdcXHVGRkRBLVxcdUZGRENdfFxcdUQ4MDBbXFx1REMwMC1cXHVEQzBCXFx1REMwRC1cXHVEQzI2XFx1REMyOC1cXHVEQzNBXFx1REMzQ1xcdURDM0RcXHVEQzNGLVxcdURDNERcXHVEQzUwLVxcdURDNURcXHVEQzgwLVxcdURDRkFcXHVERDQwLVxcdURENzRcXHVEREZEXFx1REU4MC1cXHVERTlDXFx1REVBMC1cXHVERUQwXFx1REVFMFxcdURGMDAtXFx1REYxRlxcdURGMzAtXFx1REY0QVxcdURGNTAtXFx1REY3QVxcdURGODAtXFx1REY5RFxcdURGQTAtXFx1REZDM1xcdURGQzgtXFx1REZDRlxcdURGRDEtXFx1REZENV18XFx1RDgwMVtcXHVEQzAwLVxcdURDOURcXHVEQ0EwLVxcdURDQTlcXHVERDAwLVxcdUREMjdcXHVERDMwLVxcdURENjNcXHVERTAwLVxcdURGMzZcXHVERjQwLVxcdURGNTVcXHVERjYwLVxcdURGNjddfFxcdUQ4MDJbXFx1REMwMC1cXHVEQzA1XFx1REMwOFxcdURDMEEtXFx1REMzNVxcdURDMzdcXHVEQzM4XFx1REMzQ1xcdURDM0YtXFx1REM1NVxcdURDNjAtXFx1REM3NlxcdURDODAtXFx1REM5RVxcdURDRTAtXFx1RENGMlxcdURDRjRcXHVEQ0Y1XFx1REQwMC1cXHVERDE1XFx1REQyMC1cXHVERDM5XFx1REQ4MC1cXHVEREI3XFx1RERCRVxcdUREQkZcXHVERTAwLVxcdURFMDNcXHVERTA1XFx1REUwNlxcdURFMEMtXFx1REUxM1xcdURFMTUtXFx1REUxN1xcdURFMTktXFx1REUzM1xcdURFMzgtXFx1REUzQVxcdURFM0ZcXHVERTYwLVxcdURFN0NcXHVERTgwLVxcdURFOUNcXHVERUMwLVxcdURFQzdcXHVERUM5LVxcdURFRTZcXHVERjAwLVxcdURGMzVcXHVERjQwLVxcdURGNTVcXHVERjYwLVxcdURGNzJcXHVERjgwLVxcdURGOTFdfFxcdUQ4MDNbXFx1REMwMC1cXHVEQzQ4XFx1REM4MC1cXHVEQ0IyXFx1RENDMC1cXHVEQ0YyXXxcXHVEODA0W1xcdURDMDAtXFx1REM0NlxcdURDNjYtXFx1REM2RlxcdURDN0YtXFx1RENCQVxcdURDRDAtXFx1RENFOFxcdURDRjAtXFx1RENGOVxcdUREMDAtXFx1REQzNFxcdUREMzYtXFx1REQzRlxcdURENTAtXFx1REQ3M1xcdURENzZcXHVERDgwLVxcdUREQzRcXHVERENBLVxcdUREQ0NcXHVEREQwLVxcdUREREFcXHVERERDXFx1REUwMC1cXHVERTExXFx1REUxMy1cXHVERTM3XFx1REU4MC1cXHVERTg2XFx1REU4OFxcdURFOEEtXFx1REU4RFxcdURFOEYtXFx1REU5RFxcdURFOUYtXFx1REVBOFxcdURFQjAtXFx1REVFQVxcdURFRjAtXFx1REVGOVxcdURGMDAtXFx1REYwM1xcdURGMDUtXFx1REYwQ1xcdURGMEZcXHVERjEwXFx1REYxMy1cXHVERjI4XFx1REYyQS1cXHVERjMwXFx1REYzMlxcdURGMzNcXHVERjM1LVxcdURGMzlcXHVERjNDLVxcdURGNDRcXHVERjQ3XFx1REY0OFxcdURGNEItXFx1REY0RFxcdURGNTBcXHVERjU3XFx1REY1RC1cXHVERjYzXFx1REY2Ni1cXHVERjZDXFx1REY3MC1cXHVERjc0XXxcXHVEODA1W1xcdURDODAtXFx1RENDNVxcdURDQzdcXHVEQ0QwLVxcdURDRDlcXHVERDgwLVxcdUREQjVcXHVEREI4LVxcdUREQzBcXHVEREQ4LVxcdURERERcXHVERTAwLVxcdURFNDBcXHVERTQ0XFx1REU1MC1cXHVERTU5XFx1REU4MC1cXHVERUI3XFx1REVDMC1cXHVERUM5XFx1REYwMC1cXHVERjE5XFx1REYxRC1cXHVERjJCXFx1REYzMC1cXHVERjM5XXxcXHVEODA2W1xcdURDQTAtXFx1RENFOVxcdURDRkZcXHVERUMwLVxcdURFRjhdfFxcdUQ4MDhbXFx1REMwMC1cXHVERjk5XXxcXHVEODA5W1xcdURDMDAtXFx1REM2RVxcdURDODAtXFx1REQ0M118W1xcdUQ4MENcXHVEODQwLVxcdUQ4NjhcXHVEODZBLVxcdUQ4NkNcXHVEODZGLVxcdUQ4NzJdW1xcdURDMDAtXFx1REZGRl18XFx1RDgwRFtcXHVEQzAwLVxcdURDMkVdfFxcdUQ4MTFbXFx1REMwMC1cXHVERTQ2XXxcXHVEODFBW1xcdURDMDAtXFx1REUzOFxcdURFNDAtXFx1REU1RVxcdURFNjAtXFx1REU2OVxcdURFRDAtXFx1REVFRFxcdURFRjAtXFx1REVGNFxcdURGMDAtXFx1REYzNlxcdURGNDAtXFx1REY0M1xcdURGNTAtXFx1REY1OVxcdURGNjMtXFx1REY3N1xcdURGN0QtXFx1REY4Rl18XFx1RDgxQltcXHVERjAwLVxcdURGNDRcXHVERjUwLVxcdURGN0VcXHVERjhGLVxcdURGOUZdfFxcdUQ4MkNbXFx1REMwMFxcdURDMDFdfFxcdUQ4MkZbXFx1REMwMC1cXHVEQzZBXFx1REM3MC1cXHVEQzdDXFx1REM4MC1cXHVEQzg4XFx1REM5MC1cXHVEQzk5XFx1REM5RFxcdURDOUVdfFxcdUQ4MzRbXFx1REQ2NS1cXHVERDY5XFx1REQ2RC1cXHVERDcyXFx1REQ3Qi1cXHVERDgyXFx1REQ4NS1cXHVERDhCXFx1RERBQS1cXHVEREFEXFx1REU0Mi1cXHVERTQ0XXxcXHVEODM1W1xcdURDMDAtXFx1REM1NFxcdURDNTYtXFx1REM5Q1xcdURDOUVcXHVEQzlGXFx1RENBMlxcdURDQTVcXHVEQ0E2XFx1RENBOS1cXHVEQ0FDXFx1RENBRS1cXHVEQ0I5XFx1RENCQlxcdURDQkQtXFx1RENDM1xcdURDQzUtXFx1REQwNVxcdUREMDctXFx1REQwQVxcdUREMEQtXFx1REQxNFxcdUREMTYtXFx1REQxQ1xcdUREMUUtXFx1REQzOVxcdUREM0ItXFx1REQzRVxcdURENDAtXFx1REQ0NFxcdURENDZcXHVERDRBLVxcdURENTBcXHVERDUyLVxcdURFQTVcXHVERUE4LVxcdURFQzBcXHVERUMyLVxcdURFREFcXHVERURDLVxcdURFRkFcXHVERUZDLVxcdURGMTRcXHVERjE2LVxcdURGMzRcXHVERjM2LVxcdURGNEVcXHVERjUwLVxcdURGNkVcXHVERjcwLVxcdURGODhcXHVERjhBLVxcdURGQThcXHVERkFBLVxcdURGQzJcXHVERkM0LVxcdURGQ0JcXHVERkNFLVxcdURGRkZdfFxcdUQ4MzZbXFx1REUwMC1cXHVERTM2XFx1REUzQi1cXHVERTZDXFx1REU3NVxcdURFODRcXHVERTlCLVxcdURFOUZcXHVERUExLVxcdURFQUZdfFxcdUQ4M0FbXFx1REMwMC1cXHVEQ0M0XFx1RENEMC1cXHVEQ0Q2XXxcXHVEODNCW1xcdURFMDAtXFx1REUwM1xcdURFMDUtXFx1REUxRlxcdURFMjFcXHVERTIyXFx1REUyNFxcdURFMjdcXHVERTI5LVxcdURFMzJcXHVERTM0LVxcdURFMzdcXHVERTM5XFx1REUzQlxcdURFNDJcXHVERTQ3XFx1REU0OVxcdURFNEJcXHVERTRELVxcdURFNEZcXHVERTUxXFx1REU1MlxcdURFNTRcXHVERTU3XFx1REU1OVxcdURFNUJcXHVERTVEXFx1REU1RlxcdURFNjFcXHVERTYyXFx1REU2NFxcdURFNjctXFx1REU2QVxcdURFNkMtXFx1REU3MlxcdURFNzQtXFx1REU3N1xcdURFNzktXFx1REU3Q1xcdURFN0VcXHVERTgwLVxcdURFODlcXHVERThCLVxcdURFOUJcXHVERUExLVxcdURFQTNcXHVERUE1LVxcdURFQTlcXHVERUFCLVxcdURFQkJdfFxcdUQ4NjlbXFx1REMwMC1cXHVERUQ2XFx1REYwMC1cXHVERkZGXXxcXHVEODZEW1xcdURDMDAtXFx1REYzNFxcdURGNDAtXFx1REZGRl18XFx1RDg2RVtcXHVEQzAwLVxcdURDMURcXHVEQzIwLVxcdURGRkZdfFxcdUQ4NzNbXFx1REMwMC1cXHVERUExXXxcXHVEODdFW1xcdURDMDAtXFx1REUxRF18XFx1REI0MFtcXHVERDAwLVxcdURERUZdL1xyXG5cdH07XHJcblx0ZXhwb3J0cy5DaGFyYWN0ZXIgPSB7XHJcblx0ICAgIC8qIHRzbGludDpkaXNhYmxlOm5vLWJpdHdpc2UgKi9cclxuXHQgICAgZnJvbUNvZGVQb2ludDogZnVuY3Rpb24gKGNwKSB7XHJcblx0ICAgICAgICByZXR1cm4gKGNwIDwgMHgxMDAwMCkgPyBTdHJpbmcuZnJvbUNoYXJDb2RlKGNwKSA6XHJcblx0ICAgICAgICAgICAgU3RyaW5nLmZyb21DaGFyQ29kZSgweEQ4MDAgKyAoKGNwIC0gMHgxMDAwMCkgPj4gMTApKSArXHJcblx0ICAgICAgICAgICAgICAgIFN0cmluZy5mcm9tQ2hhckNvZGUoMHhEQzAwICsgKChjcCAtIDB4MTAwMDApICYgMTAyMykpO1xyXG5cdCAgICB9LFxyXG5cdCAgICAvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy13aGl0ZS1zcGFjZVxyXG5cdCAgICBpc1doaXRlU3BhY2U6IGZ1bmN0aW9uIChjcCkge1xyXG5cdCAgICAgICAgcmV0dXJuIChjcCA9PT0gMHgyMCkgfHwgKGNwID09PSAweDA5KSB8fCAoY3AgPT09IDB4MEIpIHx8IChjcCA9PT0gMHgwQykgfHwgKGNwID09PSAweEEwKSB8fFxyXG5cdCAgICAgICAgICAgIChjcCA+PSAweDE2ODAgJiYgWzB4MTY4MCwgMHgyMDAwLCAweDIwMDEsIDB4MjAwMiwgMHgyMDAzLCAweDIwMDQsIDB4MjAwNSwgMHgyMDA2LCAweDIwMDcsIDB4MjAwOCwgMHgyMDA5LCAweDIwMEEsIDB4MjAyRiwgMHgyMDVGLCAweDMwMDAsIDB4RkVGRl0uaW5kZXhPZihjcCkgPj0gMCk7XHJcblx0ICAgIH0sXHJcblx0ICAgIC8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLWxpbmUtdGVybWluYXRvcnNcclxuXHQgICAgaXNMaW5lVGVybWluYXRvcjogZnVuY3Rpb24gKGNwKSB7XHJcblx0ICAgICAgICByZXR1cm4gKGNwID09PSAweDBBKSB8fCAoY3AgPT09IDB4MEQpIHx8IChjcCA9PT0gMHgyMDI4KSB8fCAoY3AgPT09IDB4MjAyOSk7XHJcblx0ICAgIH0sXHJcblx0ICAgIC8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLW5hbWVzLWFuZC1rZXl3b3Jkc1xyXG5cdCAgICBpc0lkZW50aWZpZXJTdGFydDogZnVuY3Rpb24gKGNwKSB7XHJcblx0ICAgICAgICByZXR1cm4gKGNwID09PSAweDI0KSB8fCAoY3AgPT09IDB4NUYpIHx8XHJcblx0ICAgICAgICAgICAgKGNwID49IDB4NDEgJiYgY3AgPD0gMHg1QSkgfHxcclxuXHQgICAgICAgICAgICAoY3AgPj0gMHg2MSAmJiBjcCA8PSAweDdBKSB8fFxyXG5cdCAgICAgICAgICAgIChjcCA9PT0gMHg1QykgfHxcclxuXHQgICAgICAgICAgICAoKGNwID49IDB4ODApICYmIFJlZ2V4Lk5vbkFzY2lpSWRlbnRpZmllclN0YXJ0LnRlc3QoZXhwb3J0cy5DaGFyYWN0ZXIuZnJvbUNvZGVQb2ludChjcCkpKTtcclxuXHQgICAgfSxcclxuXHQgICAgaXNJZGVudGlmaWVyUGFydDogZnVuY3Rpb24gKGNwKSB7XHJcblx0ICAgICAgICByZXR1cm4gKGNwID09PSAweDI0KSB8fCAoY3AgPT09IDB4NUYpIHx8XHJcblx0ICAgICAgICAgICAgKGNwID49IDB4NDEgJiYgY3AgPD0gMHg1QSkgfHxcclxuXHQgICAgICAgICAgICAoY3AgPj0gMHg2MSAmJiBjcCA8PSAweDdBKSB8fFxyXG5cdCAgICAgICAgICAgIChjcCA+PSAweDMwICYmIGNwIDw9IDB4MzkpIHx8XHJcblx0ICAgICAgICAgICAgKGNwID09PSAweDVDKSB8fFxyXG5cdCAgICAgICAgICAgICgoY3AgPj0gMHg4MCkgJiYgUmVnZXguTm9uQXNjaWlJZGVudGlmaWVyUGFydC50ZXN0KGV4cG9ydHMuQ2hhcmFjdGVyLmZyb21Db2RlUG9pbnQoY3ApKSk7XHJcblx0ICAgIH0sXHJcblx0ICAgIC8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLWxpdGVyYWxzLW51bWVyaWMtbGl0ZXJhbHNcclxuXHQgICAgaXNEZWNpbWFsRGlnaXQ6IGZ1bmN0aW9uIChjcCkge1xyXG5cdCAgICAgICAgcmV0dXJuIChjcCA+PSAweDMwICYmIGNwIDw9IDB4MzkpOyAvLyAwLi45XHJcblx0ICAgIH0sXHJcblx0ICAgIGlzSGV4RGlnaXQ6IGZ1bmN0aW9uIChjcCkge1xyXG5cdCAgICAgICAgcmV0dXJuIChjcCA+PSAweDMwICYmIGNwIDw9IDB4MzkpIHx8XHJcblx0ICAgICAgICAgICAgKGNwID49IDB4NDEgJiYgY3AgPD0gMHg0NikgfHxcclxuXHQgICAgICAgICAgICAoY3AgPj0gMHg2MSAmJiBjcCA8PSAweDY2KTsgLy8gYS4uZlxyXG5cdCAgICB9LFxyXG5cdCAgICBpc09jdGFsRGlnaXQ6IGZ1bmN0aW9uIChjcCkge1xyXG5cdCAgICAgICAgcmV0dXJuIChjcCA+PSAweDMwICYmIGNwIDw9IDB4MzcpOyAvLyAwLi43XHJcblx0ICAgIH1cclxuXHR9O1xyXG5cblxuLyoqKi8gfSxcbi8qIDUgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cdFwidXNlIHN0cmljdFwiO1xyXG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuXHR2YXIganN4X3N5bnRheF8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2KTtcclxuXHQvKiB0c2xpbnQ6ZGlzYWJsZTptYXgtY2xhc3Nlcy1wZXItZmlsZSAqL1xyXG5cdHZhciBKU1hDbG9zaW5nRWxlbWVudCA9IChmdW5jdGlvbiAoKSB7XHJcblx0ICAgIGZ1bmN0aW9uIEpTWENsb3NpbmdFbGVtZW50KG5hbWUpIHtcclxuXHQgICAgICAgIHRoaXMudHlwZSA9IGpzeF9zeW50YXhfMS5KU1hTeW50YXguSlNYQ2xvc2luZ0VsZW1lbnQ7XHJcblx0ICAgICAgICB0aGlzLm5hbWUgPSBuYW1lO1xyXG5cdCAgICB9XHJcblx0ICAgIHJldHVybiBKU1hDbG9zaW5nRWxlbWVudDtcclxuXHR9KCkpO1xyXG5cdGV4cG9ydHMuSlNYQ2xvc2luZ0VsZW1lbnQgPSBKU1hDbG9zaW5nRWxlbWVudDtcclxuXHR2YXIgSlNYRWxlbWVudCA9IChmdW5jdGlvbiAoKSB7XHJcblx0ICAgIGZ1bmN0aW9uIEpTWEVsZW1lbnQob3BlbmluZ0VsZW1lbnQsIGNoaWxkcmVuLCBjbG9zaW5nRWxlbWVudCkge1xyXG5cdCAgICAgICAgdGhpcy50eXBlID0ganN4X3N5bnRheF8xLkpTWFN5bnRheC5KU1hFbGVtZW50O1xyXG5cdCAgICAgICAgdGhpcy5vcGVuaW5nRWxlbWVudCA9IG9wZW5pbmdFbGVtZW50O1xyXG5cdCAgICAgICAgdGhpcy5jaGlsZHJlbiA9IGNoaWxkcmVuO1xyXG5cdCAgICAgICAgdGhpcy5jbG9zaW5nRWxlbWVudCA9IGNsb3NpbmdFbGVtZW50O1xyXG5cdCAgICB9XHJcblx0ICAgIHJldHVybiBKU1hFbGVtZW50O1xyXG5cdH0oKSk7XHJcblx0ZXhwb3J0cy5KU1hFbGVtZW50ID0gSlNYRWxlbWVudDtcclxuXHR2YXIgSlNYRW1wdHlFeHByZXNzaW9uID0gKGZ1bmN0aW9uICgpIHtcclxuXHQgICAgZnVuY3Rpb24gSlNYRW1wdHlFeHByZXNzaW9uKCkge1xyXG5cdCAgICAgICAgdGhpcy50eXBlID0ganN4X3N5bnRheF8xLkpTWFN5bnRheC5KU1hFbXB0eUV4cHJlc3Npb247XHJcblx0ICAgIH1cclxuXHQgICAgcmV0dXJuIEpTWEVtcHR5RXhwcmVzc2lvbjtcclxuXHR9KCkpO1xyXG5cdGV4cG9ydHMuSlNYRW1wdHlFeHByZXNzaW9uID0gSlNYRW1wdHlFeHByZXNzaW9uO1xyXG5cdHZhciBKU1hFeHByZXNzaW9uQ29udGFpbmVyID0gKGZ1bmN0aW9uICgpIHtcclxuXHQgICAgZnVuY3Rpb24gSlNYRXhwcmVzc2lvbkNvbnRhaW5lcihleHByZXNzaW9uKSB7XHJcblx0ICAgICAgICB0aGlzLnR5cGUgPSBqc3hfc3ludGF4XzEuSlNYU3ludGF4LkpTWEV4cHJlc3Npb25Db250YWluZXI7XHJcblx0ICAgICAgICB0aGlzLmV4cHJlc3Npb24gPSBleHByZXNzaW9uO1xyXG5cdCAgICB9XHJcblx0ICAgIHJldHVybiBKU1hFeHByZXNzaW9uQ29udGFpbmVyO1xyXG5cdH0oKSk7XHJcblx0ZXhwb3J0cy5KU1hFeHByZXNzaW9uQ29udGFpbmVyID0gSlNYRXhwcmVzc2lvbkNvbnRhaW5lcjtcclxuXHR2YXIgSlNYSWRlbnRpZmllciA9IChmdW5jdGlvbiAoKSB7XHJcblx0ICAgIGZ1bmN0aW9uIEpTWElkZW50aWZpZXIobmFtZSkge1xyXG5cdCAgICAgICAgdGhpcy50eXBlID0ganN4X3N5bnRheF8xLkpTWFN5bnRheC5KU1hJZGVudGlmaWVyO1xyXG5cdCAgICAgICAgdGhpcy5uYW1lID0gbmFtZTtcclxuXHQgICAgfVxyXG5cdCAgICByZXR1cm4gSlNYSWRlbnRpZmllcjtcclxuXHR9KCkpO1xyXG5cdGV4cG9ydHMuSlNYSWRlbnRpZmllciA9IEpTWElkZW50aWZpZXI7XHJcblx0dmFyIEpTWE1lbWJlckV4cHJlc3Npb24gPSAoZnVuY3Rpb24gKCkge1xyXG5cdCAgICBmdW5jdGlvbiBKU1hNZW1iZXJFeHByZXNzaW9uKG9iamVjdCwgcHJvcGVydHkpIHtcclxuXHQgICAgICAgIHRoaXMudHlwZSA9IGpzeF9zeW50YXhfMS5KU1hTeW50YXguSlNYTWVtYmVyRXhwcmVzc2lvbjtcclxuXHQgICAgICAgIHRoaXMub2JqZWN0ID0gb2JqZWN0O1xyXG5cdCAgICAgICAgdGhpcy5wcm9wZXJ0eSA9IHByb3BlcnR5O1xyXG5cdCAgICB9XHJcblx0ICAgIHJldHVybiBKU1hNZW1iZXJFeHByZXNzaW9uO1xyXG5cdH0oKSk7XHJcblx0ZXhwb3J0cy5KU1hNZW1iZXJFeHByZXNzaW9uID0gSlNYTWVtYmVyRXhwcmVzc2lvbjtcclxuXHR2YXIgSlNYQXR0cmlidXRlID0gKGZ1bmN0aW9uICgpIHtcclxuXHQgICAgZnVuY3Rpb24gSlNYQXR0cmlidXRlKG5hbWUsIHZhbHVlKSB7XHJcblx0ICAgICAgICB0aGlzLnR5cGUgPSBqc3hfc3ludGF4XzEuSlNYU3ludGF4LkpTWEF0dHJpYnV0ZTtcclxuXHQgICAgICAgIHRoaXMubmFtZSA9IG5hbWU7XHJcblx0ICAgICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XHJcblx0ICAgIH1cclxuXHQgICAgcmV0dXJuIEpTWEF0dHJpYnV0ZTtcclxuXHR9KCkpO1xyXG5cdGV4cG9ydHMuSlNYQXR0cmlidXRlID0gSlNYQXR0cmlidXRlO1xyXG5cdHZhciBKU1hOYW1lc3BhY2VkTmFtZSA9IChmdW5jdGlvbiAoKSB7XHJcblx0ICAgIGZ1bmN0aW9uIEpTWE5hbWVzcGFjZWROYW1lKG5hbWVzcGFjZSwgbmFtZSkge1xyXG5cdCAgICAgICAgdGhpcy50eXBlID0ganN4X3N5bnRheF8xLkpTWFN5bnRheC5KU1hOYW1lc3BhY2VkTmFtZTtcclxuXHQgICAgICAgIHRoaXMubmFtZXNwYWNlID0gbmFtZXNwYWNlO1xyXG5cdCAgICAgICAgdGhpcy5uYW1lID0gbmFtZTtcclxuXHQgICAgfVxyXG5cdCAgICByZXR1cm4gSlNYTmFtZXNwYWNlZE5hbWU7XHJcblx0fSgpKTtcclxuXHRleHBvcnRzLkpTWE5hbWVzcGFjZWROYW1lID0gSlNYTmFtZXNwYWNlZE5hbWU7XHJcblx0dmFyIEpTWE9wZW5pbmdFbGVtZW50ID0gKGZ1bmN0aW9uICgpIHtcclxuXHQgICAgZnVuY3Rpb24gSlNYT3BlbmluZ0VsZW1lbnQobmFtZSwgc2VsZkNsb3NpbmcsIGF0dHJpYnV0ZXMpIHtcclxuXHQgICAgICAgIHRoaXMudHlwZSA9IGpzeF9zeW50YXhfMS5KU1hTeW50YXguSlNYT3BlbmluZ0VsZW1lbnQ7XHJcblx0ICAgICAgICB0aGlzLm5hbWUgPSBuYW1lO1xyXG5cdCAgICAgICAgdGhpcy5zZWxmQ2xvc2luZyA9IHNlbGZDbG9zaW5nO1xyXG5cdCAgICAgICAgdGhpcy5hdHRyaWJ1dGVzID0gYXR0cmlidXRlcztcclxuXHQgICAgfVxyXG5cdCAgICByZXR1cm4gSlNYT3BlbmluZ0VsZW1lbnQ7XHJcblx0fSgpKTtcclxuXHRleHBvcnRzLkpTWE9wZW5pbmdFbGVtZW50ID0gSlNYT3BlbmluZ0VsZW1lbnQ7XHJcblx0dmFyIEpTWFNwcmVhZEF0dHJpYnV0ZSA9IChmdW5jdGlvbiAoKSB7XHJcblx0ICAgIGZ1bmN0aW9uIEpTWFNwcmVhZEF0dHJpYnV0ZShhcmd1bWVudCkge1xyXG5cdCAgICAgICAgdGhpcy50eXBlID0ganN4X3N5bnRheF8xLkpTWFN5bnRheC5KU1hTcHJlYWRBdHRyaWJ1dGU7XHJcblx0ICAgICAgICB0aGlzLmFyZ3VtZW50ID0gYXJndW1lbnQ7XHJcblx0ICAgIH1cclxuXHQgICAgcmV0dXJuIEpTWFNwcmVhZEF0dHJpYnV0ZTtcclxuXHR9KCkpO1xyXG5cdGV4cG9ydHMuSlNYU3ByZWFkQXR0cmlidXRlID0gSlNYU3ByZWFkQXR0cmlidXRlO1xyXG5cdHZhciBKU1hUZXh0ID0gKGZ1bmN0aW9uICgpIHtcclxuXHQgICAgZnVuY3Rpb24gSlNYVGV4dCh2YWx1ZSwgcmF3KSB7XHJcblx0ICAgICAgICB0aGlzLnR5cGUgPSBqc3hfc3ludGF4XzEuSlNYU3ludGF4LkpTWFRleHQ7XHJcblx0ICAgICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XHJcblx0ICAgICAgICB0aGlzLnJhdyA9IHJhdztcclxuXHQgICAgfVxyXG5cdCAgICByZXR1cm4gSlNYVGV4dDtcclxuXHR9KCkpO1xyXG5cdGV4cG9ydHMuSlNYVGV4dCA9IEpTWFRleHQ7XHJcblxuXG4vKioqLyB9LFxuLyogNiAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cblx0XCJ1c2Ugc3RyaWN0XCI7XHJcblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG5cdGV4cG9ydHMuSlNYU3ludGF4ID0ge1xyXG5cdCAgICBKU1hBdHRyaWJ1dGU6ICdKU1hBdHRyaWJ1dGUnLFxyXG5cdCAgICBKU1hDbG9zaW5nRWxlbWVudDogJ0pTWENsb3NpbmdFbGVtZW50JyxcclxuXHQgICAgSlNYRWxlbWVudDogJ0pTWEVsZW1lbnQnLFxyXG5cdCAgICBKU1hFbXB0eUV4cHJlc3Npb246ICdKU1hFbXB0eUV4cHJlc3Npb24nLFxyXG5cdCAgICBKU1hFeHByZXNzaW9uQ29udGFpbmVyOiAnSlNYRXhwcmVzc2lvbkNvbnRhaW5lcicsXHJcblx0ICAgIEpTWElkZW50aWZpZXI6ICdKU1hJZGVudGlmaWVyJyxcclxuXHQgICAgSlNYTWVtYmVyRXhwcmVzc2lvbjogJ0pTWE1lbWJlckV4cHJlc3Npb24nLFxyXG5cdCAgICBKU1hOYW1lc3BhY2VkTmFtZTogJ0pTWE5hbWVzcGFjZWROYW1lJyxcclxuXHQgICAgSlNYT3BlbmluZ0VsZW1lbnQ6ICdKU1hPcGVuaW5nRWxlbWVudCcsXHJcblx0ICAgIEpTWFNwcmVhZEF0dHJpYnV0ZTogJ0pTWFNwcmVhZEF0dHJpYnV0ZScsXHJcblx0ICAgIEpTWFRleHQ6ICdKU1hUZXh0J1xyXG5cdH07XHJcblxuXG4vKioqLyB9LFxuLyogNyAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblx0XCJ1c2Ugc3RyaWN0XCI7XHJcblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG5cdHZhciBzeW50YXhfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMik7XHJcblx0LyogdHNsaW50OmRpc2FibGU6bWF4LWNsYXNzZXMtcGVyLWZpbGUgKi9cclxuXHR2YXIgQXJyYXlFeHByZXNzaW9uID0gKGZ1bmN0aW9uICgpIHtcclxuXHQgICAgZnVuY3Rpb24gQXJyYXlFeHByZXNzaW9uKGVsZW1lbnRzKSB7XHJcblx0ICAgICAgICB0aGlzLnR5cGUgPSBzeW50YXhfMS5TeW50YXguQXJyYXlFeHByZXNzaW9uO1xyXG5cdCAgICAgICAgdGhpcy5lbGVtZW50cyA9IGVsZW1lbnRzO1xyXG5cdCAgICB9XHJcblx0ICAgIHJldHVybiBBcnJheUV4cHJlc3Npb247XHJcblx0fSgpKTtcclxuXHRleHBvcnRzLkFycmF5RXhwcmVzc2lvbiA9IEFycmF5RXhwcmVzc2lvbjtcclxuXHR2YXIgQXJyYXlQYXR0ZXJuID0gKGZ1bmN0aW9uICgpIHtcclxuXHQgICAgZnVuY3Rpb24gQXJyYXlQYXR0ZXJuKGVsZW1lbnRzKSB7XHJcblx0ICAgICAgICB0aGlzLnR5cGUgPSBzeW50YXhfMS5TeW50YXguQXJyYXlQYXR0ZXJuO1xyXG5cdCAgICAgICAgdGhpcy5lbGVtZW50cyA9IGVsZW1lbnRzO1xyXG5cdCAgICB9XHJcblx0ICAgIHJldHVybiBBcnJheVBhdHRlcm47XHJcblx0fSgpKTtcclxuXHRleHBvcnRzLkFycmF5UGF0dGVybiA9IEFycmF5UGF0dGVybjtcclxuXHR2YXIgQXJyb3dGdW5jdGlvbkV4cHJlc3Npb24gPSAoZnVuY3Rpb24gKCkge1xyXG5cdCAgICBmdW5jdGlvbiBBcnJvd0Z1bmN0aW9uRXhwcmVzc2lvbihwYXJhbXMsIGJvZHksIGV4cHJlc3Npb24pIHtcclxuXHQgICAgICAgIHRoaXMudHlwZSA9IHN5bnRheF8xLlN5bnRheC5BcnJvd0Z1bmN0aW9uRXhwcmVzc2lvbjtcclxuXHQgICAgICAgIHRoaXMuaWQgPSBudWxsO1xyXG5cdCAgICAgICAgdGhpcy5wYXJhbXMgPSBwYXJhbXM7XHJcblx0ICAgICAgICB0aGlzLmJvZHkgPSBib2R5O1xyXG5cdCAgICAgICAgdGhpcy5nZW5lcmF0b3IgPSBmYWxzZTtcclxuXHQgICAgICAgIHRoaXMuZXhwcmVzc2lvbiA9IGV4cHJlc3Npb247XHJcblx0ICAgICAgICB0aGlzLmFzeW5jID0gZmFsc2U7XHJcblx0ICAgIH1cclxuXHQgICAgcmV0dXJuIEFycm93RnVuY3Rpb25FeHByZXNzaW9uO1xyXG5cdH0oKSk7XHJcblx0ZXhwb3J0cy5BcnJvd0Z1bmN0aW9uRXhwcmVzc2lvbiA9IEFycm93RnVuY3Rpb25FeHByZXNzaW9uO1xyXG5cdHZhciBBc3NpZ25tZW50RXhwcmVzc2lvbiA9IChmdW5jdGlvbiAoKSB7XHJcblx0ICAgIGZ1bmN0aW9uIEFzc2lnbm1lbnRFeHByZXNzaW9uKG9wZXJhdG9yLCBsZWZ0LCByaWdodCkge1xyXG5cdCAgICAgICAgdGhpcy50eXBlID0gc3ludGF4XzEuU3ludGF4LkFzc2lnbm1lbnRFeHByZXNzaW9uO1xyXG5cdCAgICAgICAgdGhpcy5vcGVyYXRvciA9IG9wZXJhdG9yO1xyXG5cdCAgICAgICAgdGhpcy5sZWZ0ID0gbGVmdDtcclxuXHQgICAgICAgIHRoaXMucmlnaHQgPSByaWdodDtcclxuXHQgICAgfVxyXG5cdCAgICByZXR1cm4gQXNzaWdubWVudEV4cHJlc3Npb247XHJcblx0fSgpKTtcclxuXHRleHBvcnRzLkFzc2lnbm1lbnRFeHByZXNzaW9uID0gQXNzaWdubWVudEV4cHJlc3Npb247XHJcblx0dmFyIEFzc2lnbm1lbnRQYXR0ZXJuID0gKGZ1bmN0aW9uICgpIHtcclxuXHQgICAgZnVuY3Rpb24gQXNzaWdubWVudFBhdHRlcm4obGVmdCwgcmlnaHQpIHtcclxuXHQgICAgICAgIHRoaXMudHlwZSA9IHN5bnRheF8xLlN5bnRheC5Bc3NpZ25tZW50UGF0dGVybjtcclxuXHQgICAgICAgIHRoaXMubGVmdCA9IGxlZnQ7XHJcblx0ICAgICAgICB0aGlzLnJpZ2h0ID0gcmlnaHQ7XHJcblx0ICAgIH1cclxuXHQgICAgcmV0dXJuIEFzc2lnbm1lbnRQYXR0ZXJuO1xyXG5cdH0oKSk7XHJcblx0ZXhwb3J0cy5Bc3NpZ25tZW50UGF0dGVybiA9IEFzc2lnbm1lbnRQYXR0ZXJuO1xyXG5cdHZhciBBc3luY0Fycm93RnVuY3Rpb25FeHByZXNzaW9uID0gKGZ1bmN0aW9uICgpIHtcclxuXHQgICAgZnVuY3Rpb24gQXN5bmNBcnJvd0Z1bmN0aW9uRXhwcmVzc2lvbihwYXJhbXMsIGJvZHksIGV4cHJlc3Npb24pIHtcclxuXHQgICAgICAgIHRoaXMudHlwZSA9IHN5bnRheF8xLlN5bnRheC5BcnJvd0Z1bmN0aW9uRXhwcmVzc2lvbjtcclxuXHQgICAgICAgIHRoaXMuaWQgPSBudWxsO1xyXG5cdCAgICAgICAgdGhpcy5wYXJhbXMgPSBwYXJhbXM7XHJcblx0ICAgICAgICB0aGlzLmJvZHkgPSBib2R5O1xyXG5cdCAgICAgICAgdGhpcy5nZW5lcmF0b3IgPSBmYWxzZTtcclxuXHQgICAgICAgIHRoaXMuZXhwcmVzc2lvbiA9IGV4cHJlc3Npb247XHJcblx0ICAgICAgICB0aGlzLmFzeW5jID0gdHJ1ZTtcclxuXHQgICAgfVxyXG5cdCAgICByZXR1cm4gQXN5bmNBcnJvd0Z1bmN0aW9uRXhwcmVzc2lvbjtcclxuXHR9KCkpO1xyXG5cdGV4cG9ydHMuQXN5bmNBcnJvd0Z1bmN0aW9uRXhwcmVzc2lvbiA9IEFzeW5jQXJyb3dGdW5jdGlvbkV4cHJlc3Npb247XHJcblx0dmFyIEFzeW5jRnVuY3Rpb25EZWNsYXJhdGlvbiA9IChmdW5jdGlvbiAoKSB7XHJcblx0ICAgIGZ1bmN0aW9uIEFzeW5jRnVuY3Rpb25EZWNsYXJhdGlvbihpZCwgcGFyYW1zLCBib2R5KSB7XHJcblx0ICAgICAgICB0aGlzLnR5cGUgPSBzeW50YXhfMS5TeW50YXguRnVuY3Rpb25EZWNsYXJhdGlvbjtcclxuXHQgICAgICAgIHRoaXMuaWQgPSBpZDtcclxuXHQgICAgICAgIHRoaXMucGFyYW1zID0gcGFyYW1zO1xyXG5cdCAgICAgICAgdGhpcy5ib2R5ID0gYm9keTtcclxuXHQgICAgICAgIHRoaXMuZ2VuZXJhdG9yID0gZmFsc2U7XHJcblx0ICAgICAgICB0aGlzLmV4cHJlc3Npb24gPSBmYWxzZTtcclxuXHQgICAgICAgIHRoaXMuYXN5bmMgPSB0cnVlO1xyXG5cdCAgICB9XHJcblx0ICAgIHJldHVybiBBc3luY0Z1bmN0aW9uRGVjbGFyYXRpb247XHJcblx0fSgpKTtcclxuXHRleHBvcnRzLkFzeW5jRnVuY3Rpb25EZWNsYXJhdGlvbiA9IEFzeW5jRnVuY3Rpb25EZWNsYXJhdGlvbjtcclxuXHR2YXIgQXN5bmNGdW5jdGlvbkV4cHJlc3Npb24gPSAoZnVuY3Rpb24gKCkge1xyXG5cdCAgICBmdW5jdGlvbiBBc3luY0Z1bmN0aW9uRXhwcmVzc2lvbihpZCwgcGFyYW1zLCBib2R5KSB7XHJcblx0ICAgICAgICB0aGlzLnR5cGUgPSBzeW50YXhfMS5TeW50YXguRnVuY3Rpb25FeHByZXNzaW9uO1xyXG5cdCAgICAgICAgdGhpcy5pZCA9IGlkO1xyXG5cdCAgICAgICAgdGhpcy5wYXJhbXMgPSBwYXJhbXM7XHJcblx0ICAgICAgICB0aGlzLmJvZHkgPSBib2R5O1xyXG5cdCAgICAgICAgdGhpcy5nZW5lcmF0b3IgPSBmYWxzZTtcclxuXHQgICAgICAgIHRoaXMuZXhwcmVzc2lvbiA9IGZhbHNlO1xyXG5cdCAgICAgICAgdGhpcy5hc3luYyA9IHRydWU7XHJcblx0ICAgIH1cclxuXHQgICAgcmV0dXJuIEFzeW5jRnVuY3Rpb25FeHByZXNzaW9uO1xyXG5cdH0oKSk7XHJcblx0ZXhwb3J0cy5Bc3luY0Z1bmN0aW9uRXhwcmVzc2lvbiA9IEFzeW5jRnVuY3Rpb25FeHByZXNzaW9uO1xyXG5cdHZhciBBd2FpdEV4cHJlc3Npb24gPSAoZnVuY3Rpb24gKCkge1xyXG5cdCAgICBmdW5jdGlvbiBBd2FpdEV4cHJlc3Npb24oYXJndW1lbnQpIHtcclxuXHQgICAgICAgIHRoaXMudHlwZSA9IHN5bnRheF8xLlN5bnRheC5Bd2FpdEV4cHJlc3Npb247XHJcblx0ICAgICAgICB0aGlzLmFyZ3VtZW50ID0gYXJndW1lbnQ7XHJcblx0ICAgIH1cclxuXHQgICAgcmV0dXJuIEF3YWl0RXhwcmVzc2lvbjtcclxuXHR9KCkpO1xyXG5cdGV4cG9ydHMuQXdhaXRFeHByZXNzaW9uID0gQXdhaXRFeHByZXNzaW9uO1xyXG5cdHZhciBCaW5hcnlFeHByZXNzaW9uID0gKGZ1bmN0aW9uICgpIHtcclxuXHQgICAgZnVuY3Rpb24gQmluYXJ5RXhwcmVzc2lvbihvcGVyYXRvciwgbGVmdCwgcmlnaHQpIHtcclxuXHQgICAgICAgIHZhciBsb2dpY2FsID0gKG9wZXJhdG9yID09PSAnfHwnIHx8IG9wZXJhdG9yID09PSAnJiYnKTtcclxuXHQgICAgICAgIHRoaXMudHlwZSA9IGxvZ2ljYWwgPyBzeW50YXhfMS5TeW50YXguTG9naWNhbEV4cHJlc3Npb24gOiBzeW50YXhfMS5TeW50YXguQmluYXJ5RXhwcmVzc2lvbjtcclxuXHQgICAgICAgIHRoaXMub3BlcmF0b3IgPSBvcGVyYXRvcjtcclxuXHQgICAgICAgIHRoaXMubGVmdCA9IGxlZnQ7XHJcblx0ICAgICAgICB0aGlzLnJpZ2h0ID0gcmlnaHQ7XHJcblx0ICAgIH1cclxuXHQgICAgcmV0dXJuIEJpbmFyeUV4cHJlc3Npb247XHJcblx0fSgpKTtcclxuXHRleHBvcnRzLkJpbmFyeUV4cHJlc3Npb24gPSBCaW5hcnlFeHByZXNzaW9uO1xyXG5cdHZhciBCbG9ja1N0YXRlbWVudCA9IChmdW5jdGlvbiAoKSB7XHJcblx0ICAgIGZ1bmN0aW9uIEJsb2NrU3RhdGVtZW50KGJvZHkpIHtcclxuXHQgICAgICAgIHRoaXMudHlwZSA9IHN5bnRheF8xLlN5bnRheC5CbG9ja1N0YXRlbWVudDtcclxuXHQgICAgICAgIHRoaXMuYm9keSA9IGJvZHk7XHJcblx0ICAgIH1cclxuXHQgICAgcmV0dXJuIEJsb2NrU3RhdGVtZW50O1xyXG5cdH0oKSk7XHJcblx0ZXhwb3J0cy5CbG9ja1N0YXRlbWVudCA9IEJsb2NrU3RhdGVtZW50O1xyXG5cdHZhciBCcmVha1N0YXRlbWVudCA9IChmdW5jdGlvbiAoKSB7XHJcblx0ICAgIGZ1bmN0aW9uIEJyZWFrU3RhdGVtZW50KGxhYmVsKSB7XHJcblx0ICAgICAgICB0aGlzLnR5cGUgPSBzeW50YXhfMS5TeW50YXguQnJlYWtTdGF0ZW1lbnQ7XHJcblx0ICAgICAgICB0aGlzLmxhYmVsID0gbGFiZWw7XHJcblx0ICAgIH1cclxuXHQgICAgcmV0dXJuIEJyZWFrU3RhdGVtZW50O1xyXG5cdH0oKSk7XHJcblx0ZXhwb3J0cy5CcmVha1N0YXRlbWVudCA9IEJyZWFrU3RhdGVtZW50O1xyXG5cdHZhciBDYWxsRXhwcmVzc2lvbiA9IChmdW5jdGlvbiAoKSB7XHJcblx0ICAgIGZ1bmN0aW9uIENhbGxFeHByZXNzaW9uKGNhbGxlZSwgYXJncykge1xyXG5cdCAgICAgICAgdGhpcy50eXBlID0gc3ludGF4XzEuU3ludGF4LkNhbGxFeHByZXNzaW9uO1xyXG5cdCAgICAgICAgdGhpcy5jYWxsZWUgPSBjYWxsZWU7XHJcblx0ICAgICAgICB0aGlzLmFyZ3VtZW50cyA9IGFyZ3M7XHJcblx0ICAgIH1cclxuXHQgICAgcmV0dXJuIENhbGxFeHByZXNzaW9uO1xyXG5cdH0oKSk7XHJcblx0ZXhwb3J0cy5DYWxsRXhwcmVzc2lvbiA9IENhbGxFeHByZXNzaW9uO1xyXG5cdHZhciBDYXRjaENsYXVzZSA9IChmdW5jdGlvbiAoKSB7XHJcblx0ICAgIGZ1bmN0aW9uIENhdGNoQ2xhdXNlKHBhcmFtLCBib2R5KSB7XHJcblx0ICAgICAgICB0aGlzLnR5cGUgPSBzeW50YXhfMS5TeW50YXguQ2F0Y2hDbGF1c2U7XHJcblx0ICAgICAgICB0aGlzLnBhcmFtID0gcGFyYW07XHJcblx0ICAgICAgICB0aGlzLmJvZHkgPSBib2R5O1xyXG5cdCAgICB9XHJcblx0ICAgIHJldHVybiBDYXRjaENsYXVzZTtcclxuXHR9KCkpO1xyXG5cdGV4cG9ydHMuQ2F0Y2hDbGF1c2UgPSBDYXRjaENsYXVzZTtcclxuXHR2YXIgQ2xhc3NCb2R5ID0gKGZ1bmN0aW9uICgpIHtcclxuXHQgICAgZnVuY3Rpb24gQ2xhc3NCb2R5KGJvZHkpIHtcclxuXHQgICAgICAgIHRoaXMudHlwZSA9IHN5bnRheF8xLlN5bnRheC5DbGFzc0JvZHk7XHJcblx0ICAgICAgICB0aGlzLmJvZHkgPSBib2R5O1xyXG5cdCAgICB9XHJcblx0ICAgIHJldHVybiBDbGFzc0JvZHk7XHJcblx0fSgpKTtcclxuXHRleHBvcnRzLkNsYXNzQm9keSA9IENsYXNzQm9keTtcclxuXHR2YXIgQ2xhc3NEZWNsYXJhdGlvbiA9IChmdW5jdGlvbiAoKSB7XHJcblx0ICAgIGZ1bmN0aW9uIENsYXNzRGVjbGFyYXRpb24oaWQsIHN1cGVyQ2xhc3MsIGJvZHkpIHtcclxuXHQgICAgICAgIHRoaXMudHlwZSA9IHN5bnRheF8xLlN5bnRheC5DbGFzc0RlY2xhcmF0aW9uO1xyXG5cdCAgICAgICAgdGhpcy5pZCA9IGlkO1xyXG5cdCAgICAgICAgdGhpcy5zdXBlckNsYXNzID0gc3VwZXJDbGFzcztcclxuXHQgICAgICAgIHRoaXMuYm9keSA9IGJvZHk7XHJcblx0ICAgIH1cclxuXHQgICAgcmV0dXJuIENsYXNzRGVjbGFyYXRpb247XHJcblx0fSgpKTtcclxuXHRleHBvcnRzLkNsYXNzRGVjbGFyYXRpb24gPSBDbGFzc0RlY2xhcmF0aW9uO1xyXG5cdHZhciBDbGFzc0V4cHJlc3Npb24gPSAoZnVuY3Rpb24gKCkge1xyXG5cdCAgICBmdW5jdGlvbiBDbGFzc0V4cHJlc3Npb24oaWQsIHN1cGVyQ2xhc3MsIGJvZHkpIHtcclxuXHQgICAgICAgIHRoaXMudHlwZSA9IHN5bnRheF8xLlN5bnRheC5DbGFzc0V4cHJlc3Npb247XHJcblx0ICAgICAgICB0aGlzLmlkID0gaWQ7XHJcblx0ICAgICAgICB0aGlzLnN1cGVyQ2xhc3MgPSBzdXBlckNsYXNzO1xyXG5cdCAgICAgICAgdGhpcy5ib2R5ID0gYm9keTtcclxuXHQgICAgfVxyXG5cdCAgICByZXR1cm4gQ2xhc3NFeHByZXNzaW9uO1xyXG5cdH0oKSk7XHJcblx0ZXhwb3J0cy5DbGFzc0V4cHJlc3Npb24gPSBDbGFzc0V4cHJlc3Npb247XHJcblx0dmFyIENvbXB1dGVkTWVtYmVyRXhwcmVzc2lvbiA9IChmdW5jdGlvbiAoKSB7XHJcblx0ICAgIGZ1bmN0aW9uIENvbXB1dGVkTWVtYmVyRXhwcmVzc2lvbihvYmplY3QsIHByb3BlcnR5KSB7XHJcblx0ICAgICAgICB0aGlzLnR5cGUgPSBzeW50YXhfMS5TeW50YXguTWVtYmVyRXhwcmVzc2lvbjtcclxuXHQgICAgICAgIHRoaXMuY29tcHV0ZWQgPSB0cnVlO1xyXG5cdCAgICAgICAgdGhpcy5vYmplY3QgPSBvYmplY3Q7XHJcblx0ICAgICAgICB0aGlzLnByb3BlcnR5ID0gcHJvcGVydHk7XHJcblx0ICAgIH1cclxuXHQgICAgcmV0dXJuIENvbXB1dGVkTWVtYmVyRXhwcmVzc2lvbjtcclxuXHR9KCkpO1xyXG5cdGV4cG9ydHMuQ29tcHV0ZWRNZW1iZXJFeHByZXNzaW9uID0gQ29tcHV0ZWRNZW1iZXJFeHByZXNzaW9uO1xyXG5cdHZhciBDb25kaXRpb25hbEV4cHJlc3Npb24gPSAoZnVuY3Rpb24gKCkge1xyXG5cdCAgICBmdW5jdGlvbiBDb25kaXRpb25hbEV4cHJlc3Npb24odGVzdCwgY29uc2VxdWVudCwgYWx0ZXJuYXRlKSB7XHJcblx0ICAgICAgICB0aGlzLnR5cGUgPSBzeW50YXhfMS5TeW50YXguQ29uZGl0aW9uYWxFeHByZXNzaW9uO1xyXG5cdCAgICAgICAgdGhpcy50ZXN0ID0gdGVzdDtcclxuXHQgICAgICAgIHRoaXMuY29uc2VxdWVudCA9IGNvbnNlcXVlbnQ7XHJcblx0ICAgICAgICB0aGlzLmFsdGVybmF0ZSA9IGFsdGVybmF0ZTtcclxuXHQgICAgfVxyXG5cdCAgICByZXR1cm4gQ29uZGl0aW9uYWxFeHByZXNzaW9uO1xyXG5cdH0oKSk7XHJcblx0ZXhwb3J0cy5Db25kaXRpb25hbEV4cHJlc3Npb24gPSBDb25kaXRpb25hbEV4cHJlc3Npb247XHJcblx0dmFyIENvbnRpbnVlU3RhdGVtZW50ID0gKGZ1bmN0aW9uICgpIHtcclxuXHQgICAgZnVuY3Rpb24gQ29udGludWVTdGF0ZW1lbnQobGFiZWwpIHtcclxuXHQgICAgICAgIHRoaXMudHlwZSA9IHN5bnRheF8xLlN5bnRheC5Db250aW51ZVN0YXRlbWVudDtcclxuXHQgICAgICAgIHRoaXMubGFiZWwgPSBsYWJlbDtcclxuXHQgICAgfVxyXG5cdCAgICByZXR1cm4gQ29udGludWVTdGF0ZW1lbnQ7XHJcblx0fSgpKTtcclxuXHRleHBvcnRzLkNvbnRpbnVlU3RhdGVtZW50ID0gQ29udGludWVTdGF0ZW1lbnQ7XHJcblx0dmFyIERlYnVnZ2VyU3RhdGVtZW50ID0gKGZ1bmN0aW9uICgpIHtcclxuXHQgICAgZnVuY3Rpb24gRGVidWdnZXJTdGF0ZW1lbnQoKSB7XHJcblx0ICAgICAgICB0aGlzLnR5cGUgPSBzeW50YXhfMS5TeW50YXguRGVidWdnZXJTdGF0ZW1lbnQ7XHJcblx0ICAgIH1cclxuXHQgICAgcmV0dXJuIERlYnVnZ2VyU3RhdGVtZW50O1xyXG5cdH0oKSk7XHJcblx0ZXhwb3J0cy5EZWJ1Z2dlclN0YXRlbWVudCA9IERlYnVnZ2VyU3RhdGVtZW50O1xyXG5cdHZhciBEaXJlY3RpdmUgPSAoZnVuY3Rpb24gKCkge1xyXG5cdCAgICBmdW5jdGlvbiBEaXJlY3RpdmUoZXhwcmVzc2lvbiwgZGlyZWN0aXZlKSB7XHJcblx0ICAgICAgICB0aGlzLnR5cGUgPSBzeW50YXhfMS5TeW50YXguRXhwcmVzc2lvblN0YXRlbWVudDtcclxuXHQgICAgICAgIHRoaXMuZXhwcmVzc2lvbiA9IGV4cHJlc3Npb247XHJcblx0ICAgICAgICB0aGlzLmRpcmVjdGl2ZSA9IGRpcmVjdGl2ZTtcclxuXHQgICAgfVxyXG5cdCAgICByZXR1cm4gRGlyZWN0aXZlO1xyXG5cdH0oKSk7XHJcblx0ZXhwb3J0cy5EaXJlY3RpdmUgPSBEaXJlY3RpdmU7XHJcblx0dmFyIERvV2hpbGVTdGF0ZW1lbnQgPSAoZnVuY3Rpb24gKCkge1xyXG5cdCAgICBmdW5jdGlvbiBEb1doaWxlU3RhdGVtZW50KGJvZHksIHRlc3QpIHtcclxuXHQgICAgICAgIHRoaXMudHlwZSA9IHN5bnRheF8xLlN5bnRheC5Eb1doaWxlU3RhdGVtZW50O1xyXG5cdCAgICAgICAgdGhpcy5ib2R5ID0gYm9keTtcclxuXHQgICAgICAgIHRoaXMudGVzdCA9IHRlc3Q7XHJcblx0ICAgIH1cclxuXHQgICAgcmV0dXJuIERvV2hpbGVTdGF0ZW1lbnQ7XHJcblx0fSgpKTtcclxuXHRleHBvcnRzLkRvV2hpbGVTdGF0ZW1lbnQgPSBEb1doaWxlU3RhdGVtZW50O1xyXG5cdHZhciBFbXB0eVN0YXRlbWVudCA9IChmdW5jdGlvbiAoKSB7XHJcblx0ICAgIGZ1bmN0aW9uIEVtcHR5U3RhdGVtZW50KCkge1xyXG5cdCAgICAgICAgdGhpcy50eXBlID0gc3ludGF4XzEuU3ludGF4LkVtcHR5U3RhdGVtZW50O1xyXG5cdCAgICB9XHJcblx0ICAgIHJldHVybiBFbXB0eVN0YXRlbWVudDtcclxuXHR9KCkpO1xyXG5cdGV4cG9ydHMuRW1wdHlTdGF0ZW1lbnQgPSBFbXB0eVN0YXRlbWVudDtcclxuXHR2YXIgRXhwb3J0QWxsRGVjbGFyYXRpb24gPSAoZnVuY3Rpb24gKCkge1xyXG5cdCAgICBmdW5jdGlvbiBFeHBvcnRBbGxEZWNsYXJhdGlvbihzb3VyY2UpIHtcclxuXHQgICAgICAgIHRoaXMudHlwZSA9IHN5bnRheF8xLlN5bnRheC5FeHBvcnRBbGxEZWNsYXJhdGlvbjtcclxuXHQgICAgICAgIHRoaXMuc291cmNlID0gc291cmNlO1xyXG5cdCAgICB9XHJcblx0ICAgIHJldHVybiBFeHBvcnRBbGxEZWNsYXJhdGlvbjtcclxuXHR9KCkpO1xyXG5cdGV4cG9ydHMuRXhwb3J0QWxsRGVjbGFyYXRpb24gPSBFeHBvcnRBbGxEZWNsYXJhdGlvbjtcclxuXHR2YXIgRXhwb3J0RGVmYXVsdERlY2xhcmF0aW9uID0gKGZ1bmN0aW9uICgpIHtcclxuXHQgICAgZnVuY3Rpb24gRXhwb3J0RGVmYXVsdERlY2xhcmF0aW9uKGRlY2xhcmF0aW9uKSB7XHJcblx0ICAgICAgICB0aGlzLnR5cGUgPSBzeW50YXhfMS5TeW50YXguRXhwb3J0RGVmYXVsdERlY2xhcmF0aW9uO1xyXG5cdCAgICAgICAgdGhpcy5kZWNsYXJhdGlvbiA9IGRlY2xhcmF0aW9uO1xyXG5cdCAgICB9XHJcblx0ICAgIHJldHVybiBFeHBvcnREZWZhdWx0RGVjbGFyYXRpb247XHJcblx0fSgpKTtcclxuXHRleHBvcnRzLkV4cG9ydERlZmF1bHREZWNsYXJhdGlvbiA9IEV4cG9ydERlZmF1bHREZWNsYXJhdGlvbjtcclxuXHR2YXIgRXhwb3J0TmFtZWREZWNsYXJhdGlvbiA9IChmdW5jdGlvbiAoKSB7XHJcblx0ICAgIGZ1bmN0aW9uIEV4cG9ydE5hbWVkRGVjbGFyYXRpb24oZGVjbGFyYXRpb24sIHNwZWNpZmllcnMsIHNvdXJjZSkge1xyXG5cdCAgICAgICAgdGhpcy50eXBlID0gc3ludGF4XzEuU3ludGF4LkV4cG9ydE5hbWVkRGVjbGFyYXRpb247XHJcblx0ICAgICAgICB0aGlzLmRlY2xhcmF0aW9uID0gZGVjbGFyYXRpb247XHJcblx0ICAgICAgICB0aGlzLnNwZWNpZmllcnMgPSBzcGVjaWZpZXJzO1xyXG5cdCAgICAgICAgdGhpcy5zb3VyY2UgPSBzb3VyY2U7XHJcblx0ICAgIH1cclxuXHQgICAgcmV0dXJuIEV4cG9ydE5hbWVkRGVjbGFyYXRpb247XHJcblx0fSgpKTtcclxuXHRleHBvcnRzLkV4cG9ydE5hbWVkRGVjbGFyYXRpb24gPSBFeHBvcnROYW1lZERlY2xhcmF0aW9uO1xyXG5cdHZhciBFeHBvcnRTcGVjaWZpZXIgPSAoZnVuY3Rpb24gKCkge1xyXG5cdCAgICBmdW5jdGlvbiBFeHBvcnRTcGVjaWZpZXIobG9jYWwsIGV4cG9ydGVkKSB7XHJcblx0ICAgICAgICB0aGlzLnR5cGUgPSBzeW50YXhfMS5TeW50YXguRXhwb3J0U3BlY2lmaWVyO1xyXG5cdCAgICAgICAgdGhpcy5leHBvcnRlZCA9IGV4cG9ydGVkO1xyXG5cdCAgICAgICAgdGhpcy5sb2NhbCA9IGxvY2FsO1xyXG5cdCAgICB9XHJcblx0ICAgIHJldHVybiBFeHBvcnRTcGVjaWZpZXI7XHJcblx0fSgpKTtcclxuXHRleHBvcnRzLkV4cG9ydFNwZWNpZmllciA9IEV4cG9ydFNwZWNpZmllcjtcclxuXHR2YXIgRXhwcmVzc2lvblN0YXRlbWVudCA9IChmdW5jdGlvbiAoKSB7XHJcblx0ICAgIGZ1bmN0aW9uIEV4cHJlc3Npb25TdGF0ZW1lbnQoZXhwcmVzc2lvbikge1xyXG5cdCAgICAgICAgdGhpcy50eXBlID0gc3ludGF4XzEuU3ludGF4LkV4cHJlc3Npb25TdGF0ZW1lbnQ7XHJcblx0ICAgICAgICB0aGlzLmV4cHJlc3Npb24gPSBleHByZXNzaW9uO1xyXG5cdCAgICB9XHJcblx0ICAgIHJldHVybiBFeHByZXNzaW9uU3RhdGVtZW50O1xyXG5cdH0oKSk7XHJcblx0ZXhwb3J0cy5FeHByZXNzaW9uU3RhdGVtZW50ID0gRXhwcmVzc2lvblN0YXRlbWVudDtcclxuXHR2YXIgRm9ySW5TdGF0ZW1lbnQgPSAoZnVuY3Rpb24gKCkge1xyXG5cdCAgICBmdW5jdGlvbiBGb3JJblN0YXRlbWVudChsZWZ0LCByaWdodCwgYm9keSkge1xyXG5cdCAgICAgICAgdGhpcy50eXBlID0gc3ludGF4XzEuU3ludGF4LkZvckluU3RhdGVtZW50O1xyXG5cdCAgICAgICAgdGhpcy5sZWZ0ID0gbGVmdDtcclxuXHQgICAgICAgIHRoaXMucmlnaHQgPSByaWdodDtcclxuXHQgICAgICAgIHRoaXMuYm9keSA9IGJvZHk7XHJcblx0ICAgICAgICB0aGlzLmVhY2ggPSBmYWxzZTtcclxuXHQgICAgfVxyXG5cdCAgICByZXR1cm4gRm9ySW5TdGF0ZW1lbnQ7XHJcblx0fSgpKTtcclxuXHRleHBvcnRzLkZvckluU3RhdGVtZW50ID0gRm9ySW5TdGF0ZW1lbnQ7XHJcblx0dmFyIEZvck9mU3RhdGVtZW50ID0gKGZ1bmN0aW9uICgpIHtcclxuXHQgICAgZnVuY3Rpb24gRm9yT2ZTdGF0ZW1lbnQobGVmdCwgcmlnaHQsIGJvZHkpIHtcclxuXHQgICAgICAgIHRoaXMudHlwZSA9IHN5bnRheF8xLlN5bnRheC5Gb3JPZlN0YXRlbWVudDtcclxuXHQgICAgICAgIHRoaXMubGVmdCA9IGxlZnQ7XHJcblx0ICAgICAgICB0aGlzLnJpZ2h0ID0gcmlnaHQ7XHJcblx0ICAgICAgICB0aGlzLmJvZHkgPSBib2R5O1xyXG5cdCAgICB9XHJcblx0ICAgIHJldHVybiBGb3JPZlN0YXRlbWVudDtcclxuXHR9KCkpO1xyXG5cdGV4cG9ydHMuRm9yT2ZTdGF0ZW1lbnQgPSBGb3JPZlN0YXRlbWVudDtcclxuXHR2YXIgRm9yU3RhdGVtZW50ID0gKGZ1bmN0aW9uICgpIHtcclxuXHQgICAgZnVuY3Rpb24gRm9yU3RhdGVtZW50KGluaXQsIHRlc3QsIHVwZGF0ZSwgYm9keSkge1xyXG5cdCAgICAgICAgdGhpcy50eXBlID0gc3ludGF4XzEuU3ludGF4LkZvclN0YXRlbWVudDtcclxuXHQgICAgICAgIHRoaXMuaW5pdCA9IGluaXQ7XHJcblx0ICAgICAgICB0aGlzLnRlc3QgPSB0ZXN0O1xyXG5cdCAgICAgICAgdGhpcy51cGRhdGUgPSB1cGRhdGU7XHJcblx0ICAgICAgICB0aGlzLmJvZHkgPSBib2R5O1xyXG5cdCAgICB9XHJcblx0ICAgIHJldHVybiBGb3JTdGF0ZW1lbnQ7XHJcblx0fSgpKTtcclxuXHRleHBvcnRzLkZvclN0YXRlbWVudCA9IEZvclN0YXRlbWVudDtcclxuXHR2YXIgRnVuY3Rpb25EZWNsYXJhdGlvbiA9IChmdW5jdGlvbiAoKSB7XHJcblx0ICAgIGZ1bmN0aW9uIEZ1bmN0aW9uRGVjbGFyYXRpb24oaWQsIHBhcmFtcywgYm9keSwgZ2VuZXJhdG9yKSB7XHJcblx0ICAgICAgICB0aGlzLnR5cGUgPSBzeW50YXhfMS5TeW50YXguRnVuY3Rpb25EZWNsYXJhdGlvbjtcclxuXHQgICAgICAgIHRoaXMuaWQgPSBpZDtcclxuXHQgICAgICAgIHRoaXMucGFyYW1zID0gcGFyYW1zO1xyXG5cdCAgICAgICAgdGhpcy5ib2R5ID0gYm9keTtcclxuXHQgICAgICAgIHRoaXMuZ2VuZXJhdG9yID0gZ2VuZXJhdG9yO1xyXG5cdCAgICAgICAgdGhpcy5leHByZXNzaW9uID0gZmFsc2U7XHJcblx0ICAgICAgICB0aGlzLmFzeW5jID0gZmFsc2U7XHJcblx0ICAgIH1cclxuXHQgICAgcmV0dXJuIEZ1bmN0aW9uRGVjbGFyYXRpb247XHJcblx0fSgpKTtcclxuXHRleHBvcnRzLkZ1bmN0aW9uRGVjbGFyYXRpb24gPSBGdW5jdGlvbkRlY2xhcmF0aW9uO1xyXG5cdHZhciBGdW5jdGlvbkV4cHJlc3Npb24gPSAoZnVuY3Rpb24gKCkge1xyXG5cdCAgICBmdW5jdGlvbiBGdW5jdGlvbkV4cHJlc3Npb24oaWQsIHBhcmFtcywgYm9keSwgZ2VuZXJhdG9yKSB7XHJcblx0ICAgICAgICB0aGlzLnR5cGUgPSBzeW50YXhfMS5TeW50YXguRnVuY3Rpb25FeHByZXNzaW9uO1xyXG5cdCAgICAgICAgdGhpcy5pZCA9IGlkO1xyXG5cdCAgICAgICAgdGhpcy5wYXJhbXMgPSBwYXJhbXM7XHJcblx0ICAgICAgICB0aGlzLmJvZHkgPSBib2R5O1xyXG5cdCAgICAgICAgdGhpcy5nZW5lcmF0b3IgPSBnZW5lcmF0b3I7XHJcblx0ICAgICAgICB0aGlzLmV4cHJlc3Npb24gPSBmYWxzZTtcclxuXHQgICAgICAgIHRoaXMuYXN5bmMgPSBmYWxzZTtcclxuXHQgICAgfVxyXG5cdCAgICByZXR1cm4gRnVuY3Rpb25FeHByZXNzaW9uO1xyXG5cdH0oKSk7XHJcblx0ZXhwb3J0cy5GdW5jdGlvbkV4cHJlc3Npb24gPSBGdW5jdGlvbkV4cHJlc3Npb247XHJcblx0dmFyIElkZW50aWZpZXIgPSAoZnVuY3Rpb24gKCkge1xyXG5cdCAgICBmdW5jdGlvbiBJZGVudGlmaWVyKG5hbWUpIHtcclxuXHQgICAgICAgIHRoaXMudHlwZSA9IHN5bnRheF8xLlN5bnRheC5JZGVudGlmaWVyO1xyXG5cdCAgICAgICAgdGhpcy5uYW1lID0gbmFtZTtcclxuXHQgICAgfVxyXG5cdCAgICByZXR1cm4gSWRlbnRpZmllcjtcclxuXHR9KCkpO1xyXG5cdGV4cG9ydHMuSWRlbnRpZmllciA9IElkZW50aWZpZXI7XHJcblx0dmFyIElmU3RhdGVtZW50ID0gKGZ1bmN0aW9uICgpIHtcclxuXHQgICAgZnVuY3Rpb24gSWZTdGF0ZW1lbnQodGVzdCwgY29uc2VxdWVudCwgYWx0ZXJuYXRlKSB7XHJcblx0ICAgICAgICB0aGlzLnR5cGUgPSBzeW50YXhfMS5TeW50YXguSWZTdGF0ZW1lbnQ7XHJcblx0ICAgICAgICB0aGlzLnRlc3QgPSB0ZXN0O1xyXG5cdCAgICAgICAgdGhpcy5jb25zZXF1ZW50ID0gY29uc2VxdWVudDtcclxuXHQgICAgICAgIHRoaXMuYWx0ZXJuYXRlID0gYWx0ZXJuYXRlO1xyXG5cdCAgICB9XHJcblx0ICAgIHJldHVybiBJZlN0YXRlbWVudDtcclxuXHR9KCkpO1xyXG5cdGV4cG9ydHMuSWZTdGF0ZW1lbnQgPSBJZlN0YXRlbWVudDtcclxuXHR2YXIgSW1wb3J0RGVjbGFyYXRpb24gPSAoZnVuY3Rpb24gKCkge1xyXG5cdCAgICBmdW5jdGlvbiBJbXBvcnREZWNsYXJhdGlvbihzcGVjaWZpZXJzLCBzb3VyY2UpIHtcclxuXHQgICAgICAgIHRoaXMudHlwZSA9IHN5bnRheF8xLlN5bnRheC5JbXBvcnREZWNsYXJhdGlvbjtcclxuXHQgICAgICAgIHRoaXMuc3BlY2lmaWVycyA9IHNwZWNpZmllcnM7XHJcblx0ICAgICAgICB0aGlzLnNvdXJjZSA9IHNvdXJjZTtcclxuXHQgICAgfVxyXG5cdCAgICByZXR1cm4gSW1wb3J0RGVjbGFyYXRpb247XHJcblx0fSgpKTtcclxuXHRleHBvcnRzLkltcG9ydERlY2xhcmF0aW9uID0gSW1wb3J0RGVjbGFyYXRpb247XHJcblx0dmFyIEltcG9ydERlZmF1bHRTcGVjaWZpZXIgPSAoZnVuY3Rpb24gKCkge1xyXG5cdCAgICBmdW5jdGlvbiBJbXBvcnREZWZhdWx0U3BlY2lmaWVyKGxvY2FsKSB7XHJcblx0ICAgICAgICB0aGlzLnR5cGUgPSBzeW50YXhfMS5TeW50YXguSW1wb3J0RGVmYXVsdFNwZWNpZmllcjtcclxuXHQgICAgICAgIHRoaXMubG9jYWwgPSBsb2NhbDtcclxuXHQgICAgfVxyXG5cdCAgICByZXR1cm4gSW1wb3J0RGVmYXVsdFNwZWNpZmllcjtcclxuXHR9KCkpO1xyXG5cdGV4cG9ydHMuSW1wb3J0RGVmYXVsdFNwZWNpZmllciA9IEltcG9ydERlZmF1bHRTcGVjaWZpZXI7XHJcblx0dmFyIEltcG9ydE5hbWVzcGFjZVNwZWNpZmllciA9IChmdW5jdGlvbiAoKSB7XHJcblx0ICAgIGZ1bmN0aW9uIEltcG9ydE5hbWVzcGFjZVNwZWNpZmllcihsb2NhbCkge1xyXG5cdCAgICAgICAgdGhpcy50eXBlID0gc3ludGF4XzEuU3ludGF4LkltcG9ydE5hbWVzcGFjZVNwZWNpZmllcjtcclxuXHQgICAgICAgIHRoaXMubG9jYWwgPSBsb2NhbDtcclxuXHQgICAgfVxyXG5cdCAgICByZXR1cm4gSW1wb3J0TmFtZXNwYWNlU3BlY2lmaWVyO1xyXG5cdH0oKSk7XHJcblx0ZXhwb3J0cy5JbXBvcnROYW1lc3BhY2VTcGVjaWZpZXIgPSBJbXBvcnROYW1lc3BhY2VTcGVjaWZpZXI7XHJcblx0dmFyIEltcG9ydFNwZWNpZmllciA9IChmdW5jdGlvbiAoKSB7XHJcblx0ICAgIGZ1bmN0aW9uIEltcG9ydFNwZWNpZmllcihsb2NhbCwgaW1wb3J0ZWQpIHtcclxuXHQgICAgICAgIHRoaXMudHlwZSA9IHN5bnRheF8xLlN5bnRheC5JbXBvcnRTcGVjaWZpZXI7XHJcblx0ICAgICAgICB0aGlzLmxvY2FsID0gbG9jYWw7XHJcblx0ICAgICAgICB0aGlzLmltcG9ydGVkID0gaW1wb3J0ZWQ7XHJcblx0ICAgIH1cclxuXHQgICAgcmV0dXJuIEltcG9ydFNwZWNpZmllcjtcclxuXHR9KCkpO1xyXG5cdGV4cG9ydHMuSW1wb3J0U3BlY2lmaWVyID0gSW1wb3J0U3BlY2lmaWVyO1xyXG5cdHZhciBMYWJlbGVkU3RhdGVtZW50ID0gKGZ1bmN0aW9uICgpIHtcclxuXHQgICAgZnVuY3Rpb24gTGFiZWxlZFN0YXRlbWVudChsYWJlbCwgYm9keSkge1xyXG5cdCAgICAgICAgdGhpcy50eXBlID0gc3ludGF4XzEuU3ludGF4LkxhYmVsZWRTdGF0ZW1lbnQ7XHJcblx0ICAgICAgICB0aGlzLmxhYmVsID0gbGFiZWw7XHJcblx0ICAgICAgICB0aGlzLmJvZHkgPSBib2R5O1xyXG5cdCAgICB9XHJcblx0ICAgIHJldHVybiBMYWJlbGVkU3RhdGVtZW50O1xyXG5cdH0oKSk7XHJcblx0ZXhwb3J0cy5MYWJlbGVkU3RhdGVtZW50ID0gTGFiZWxlZFN0YXRlbWVudDtcclxuXHR2YXIgTGl0ZXJhbCA9IChmdW5jdGlvbiAoKSB7XHJcblx0ICAgIGZ1bmN0aW9uIExpdGVyYWwodmFsdWUsIHJhdykge1xyXG5cdCAgICAgICAgdGhpcy50eXBlID0gc3ludGF4XzEuU3ludGF4LkxpdGVyYWw7XHJcblx0ICAgICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XHJcblx0ICAgICAgICB0aGlzLnJhdyA9IHJhdztcclxuXHQgICAgfVxyXG5cdCAgICByZXR1cm4gTGl0ZXJhbDtcclxuXHR9KCkpO1xyXG5cdGV4cG9ydHMuTGl0ZXJhbCA9IExpdGVyYWw7XHJcblx0dmFyIE1ldGFQcm9wZXJ0eSA9IChmdW5jdGlvbiAoKSB7XHJcblx0ICAgIGZ1bmN0aW9uIE1ldGFQcm9wZXJ0eShtZXRhLCBwcm9wZXJ0eSkge1xyXG5cdCAgICAgICAgdGhpcy50eXBlID0gc3ludGF4XzEuU3ludGF4Lk1ldGFQcm9wZXJ0eTtcclxuXHQgICAgICAgIHRoaXMubWV0YSA9IG1ldGE7XHJcblx0ICAgICAgICB0aGlzLnByb3BlcnR5ID0gcHJvcGVydHk7XHJcblx0ICAgIH1cclxuXHQgICAgcmV0dXJuIE1ldGFQcm9wZXJ0eTtcclxuXHR9KCkpO1xyXG5cdGV4cG9ydHMuTWV0YVByb3BlcnR5ID0gTWV0YVByb3BlcnR5O1xyXG5cdHZhciBNZXRob2REZWZpbml0aW9uID0gKGZ1bmN0aW9uICgpIHtcclxuXHQgICAgZnVuY3Rpb24gTWV0aG9kRGVmaW5pdGlvbihrZXksIGNvbXB1dGVkLCB2YWx1ZSwga2luZCwgaXNTdGF0aWMpIHtcclxuXHQgICAgICAgIHRoaXMudHlwZSA9IHN5bnRheF8xLlN5bnRheC5NZXRob2REZWZpbml0aW9uO1xyXG5cdCAgICAgICAgdGhpcy5rZXkgPSBrZXk7XHJcblx0ICAgICAgICB0aGlzLmNvbXB1dGVkID0gY29tcHV0ZWQ7XHJcblx0ICAgICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XHJcblx0ICAgICAgICB0aGlzLmtpbmQgPSBraW5kO1xyXG5cdCAgICAgICAgdGhpcy5zdGF0aWMgPSBpc1N0YXRpYztcclxuXHQgICAgfVxyXG5cdCAgICByZXR1cm4gTWV0aG9kRGVmaW5pdGlvbjtcclxuXHR9KCkpO1xyXG5cdGV4cG9ydHMuTWV0aG9kRGVmaW5pdGlvbiA9IE1ldGhvZERlZmluaXRpb247XHJcblx0dmFyIE1vZHVsZSA9IChmdW5jdGlvbiAoKSB7XHJcblx0ICAgIGZ1bmN0aW9uIE1vZHVsZShib2R5KSB7XHJcblx0ICAgICAgICB0aGlzLnR5cGUgPSBzeW50YXhfMS5TeW50YXguUHJvZ3JhbTtcclxuXHQgICAgICAgIHRoaXMuYm9keSA9IGJvZHk7XHJcblx0ICAgICAgICB0aGlzLnNvdXJjZVR5cGUgPSAnbW9kdWxlJztcclxuXHQgICAgfVxyXG5cdCAgICByZXR1cm4gTW9kdWxlO1xyXG5cdH0oKSk7XHJcblx0ZXhwb3J0cy5Nb2R1bGUgPSBNb2R1bGU7XHJcblx0dmFyIE5ld0V4cHJlc3Npb24gPSAoZnVuY3Rpb24gKCkge1xyXG5cdCAgICBmdW5jdGlvbiBOZXdFeHByZXNzaW9uKGNhbGxlZSwgYXJncykge1xyXG5cdCAgICAgICAgdGhpcy50eXBlID0gc3ludGF4XzEuU3ludGF4Lk5ld0V4cHJlc3Npb247XHJcblx0ICAgICAgICB0aGlzLmNhbGxlZSA9IGNhbGxlZTtcclxuXHQgICAgICAgIHRoaXMuYXJndW1lbnRzID0gYXJncztcclxuXHQgICAgfVxyXG5cdCAgICByZXR1cm4gTmV3RXhwcmVzc2lvbjtcclxuXHR9KCkpO1xyXG5cdGV4cG9ydHMuTmV3RXhwcmVzc2lvbiA9IE5ld0V4cHJlc3Npb247XHJcblx0dmFyIE9iamVjdEV4cHJlc3Npb24gPSAoZnVuY3Rpb24gKCkge1xyXG5cdCAgICBmdW5jdGlvbiBPYmplY3RFeHByZXNzaW9uKHByb3BlcnRpZXMpIHtcclxuXHQgICAgICAgIHRoaXMudHlwZSA9IHN5bnRheF8xLlN5bnRheC5PYmplY3RFeHByZXNzaW9uO1xyXG5cdCAgICAgICAgdGhpcy5wcm9wZXJ0aWVzID0gcHJvcGVydGllcztcclxuXHQgICAgfVxyXG5cdCAgICByZXR1cm4gT2JqZWN0RXhwcmVzc2lvbjtcclxuXHR9KCkpO1xyXG5cdGV4cG9ydHMuT2JqZWN0RXhwcmVzc2lvbiA9IE9iamVjdEV4cHJlc3Npb247XHJcblx0dmFyIE9iamVjdFBhdHRlcm4gPSAoZnVuY3Rpb24gKCkge1xyXG5cdCAgICBmdW5jdGlvbiBPYmplY3RQYXR0ZXJuKHByb3BlcnRpZXMpIHtcclxuXHQgICAgICAgIHRoaXMudHlwZSA9IHN5bnRheF8xLlN5bnRheC5PYmplY3RQYXR0ZXJuO1xyXG5cdCAgICAgICAgdGhpcy5wcm9wZXJ0aWVzID0gcHJvcGVydGllcztcclxuXHQgICAgfVxyXG5cdCAgICByZXR1cm4gT2JqZWN0UGF0dGVybjtcclxuXHR9KCkpO1xyXG5cdGV4cG9ydHMuT2JqZWN0UGF0dGVybiA9IE9iamVjdFBhdHRlcm47XHJcblx0dmFyIFByb3BlcnR5ID0gKGZ1bmN0aW9uICgpIHtcclxuXHQgICAgZnVuY3Rpb24gUHJvcGVydHkoa2luZCwga2V5LCBjb21wdXRlZCwgdmFsdWUsIG1ldGhvZCwgc2hvcnRoYW5kKSB7XHJcblx0ICAgICAgICB0aGlzLnR5cGUgPSBzeW50YXhfMS5TeW50YXguUHJvcGVydHk7XHJcblx0ICAgICAgICB0aGlzLmtleSA9IGtleTtcclxuXHQgICAgICAgIHRoaXMuY29tcHV0ZWQgPSBjb21wdXRlZDtcclxuXHQgICAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcclxuXHQgICAgICAgIHRoaXMua2luZCA9IGtpbmQ7XHJcblx0ICAgICAgICB0aGlzLm1ldGhvZCA9IG1ldGhvZDtcclxuXHQgICAgICAgIHRoaXMuc2hvcnRoYW5kID0gc2hvcnRoYW5kO1xyXG5cdCAgICB9XHJcblx0ICAgIHJldHVybiBQcm9wZXJ0eTtcclxuXHR9KCkpO1xyXG5cdGV4cG9ydHMuUHJvcGVydHkgPSBQcm9wZXJ0eTtcclxuXHR2YXIgUmVnZXhMaXRlcmFsID0gKGZ1bmN0aW9uICgpIHtcclxuXHQgICAgZnVuY3Rpb24gUmVnZXhMaXRlcmFsKHZhbHVlLCByYXcsIHBhdHRlcm4sIGZsYWdzKSB7XHJcblx0ICAgICAgICB0aGlzLnR5cGUgPSBzeW50YXhfMS5TeW50YXguTGl0ZXJhbDtcclxuXHQgICAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcclxuXHQgICAgICAgIHRoaXMucmF3ID0gcmF3O1xyXG5cdCAgICAgICAgdGhpcy5yZWdleCA9IHsgcGF0dGVybjogcGF0dGVybiwgZmxhZ3M6IGZsYWdzIH07XHJcblx0ICAgIH1cclxuXHQgICAgcmV0dXJuIFJlZ2V4TGl0ZXJhbDtcclxuXHR9KCkpO1xyXG5cdGV4cG9ydHMuUmVnZXhMaXRlcmFsID0gUmVnZXhMaXRlcmFsO1xyXG5cdHZhciBSZXN0RWxlbWVudCA9IChmdW5jdGlvbiAoKSB7XHJcblx0ICAgIGZ1bmN0aW9uIFJlc3RFbGVtZW50KGFyZ3VtZW50KSB7XHJcblx0ICAgICAgICB0aGlzLnR5cGUgPSBzeW50YXhfMS5TeW50YXguUmVzdEVsZW1lbnQ7XHJcblx0ICAgICAgICB0aGlzLmFyZ3VtZW50ID0gYXJndW1lbnQ7XHJcblx0ICAgIH1cclxuXHQgICAgcmV0dXJuIFJlc3RFbGVtZW50O1xyXG5cdH0oKSk7XHJcblx0ZXhwb3J0cy5SZXN0RWxlbWVudCA9IFJlc3RFbGVtZW50O1xyXG5cdHZhciBSZXR1cm5TdGF0ZW1lbnQgPSAoZnVuY3Rpb24gKCkge1xyXG5cdCAgICBmdW5jdGlvbiBSZXR1cm5TdGF0ZW1lbnQoYXJndW1lbnQpIHtcclxuXHQgICAgICAgIHRoaXMudHlwZSA9IHN5bnRheF8xLlN5bnRheC5SZXR1cm5TdGF0ZW1lbnQ7XHJcblx0ICAgICAgICB0aGlzLmFyZ3VtZW50ID0gYXJndW1lbnQ7XHJcblx0ICAgIH1cclxuXHQgICAgcmV0dXJuIFJldHVyblN0YXRlbWVudDtcclxuXHR9KCkpO1xyXG5cdGV4cG9ydHMuUmV0dXJuU3RhdGVtZW50ID0gUmV0dXJuU3RhdGVtZW50O1xyXG5cdHZhciBTY3JpcHQgPSAoZnVuY3Rpb24gKCkge1xyXG5cdCAgICBmdW5jdGlvbiBTY3JpcHQoYm9keSkge1xyXG5cdCAgICAgICAgdGhpcy50eXBlID0gc3ludGF4XzEuU3ludGF4LlByb2dyYW07XHJcblx0ICAgICAgICB0aGlzLmJvZHkgPSBib2R5O1xyXG5cdCAgICAgICAgdGhpcy5zb3VyY2VUeXBlID0gJ3NjcmlwdCc7XHJcblx0ICAgIH1cclxuXHQgICAgcmV0dXJuIFNjcmlwdDtcclxuXHR9KCkpO1xyXG5cdGV4cG9ydHMuU2NyaXB0ID0gU2NyaXB0O1xyXG5cdHZhciBTZXF1ZW5jZUV4cHJlc3Npb24gPSAoZnVuY3Rpb24gKCkge1xyXG5cdCAgICBmdW5jdGlvbiBTZXF1ZW5jZUV4cHJlc3Npb24oZXhwcmVzc2lvbnMpIHtcclxuXHQgICAgICAgIHRoaXMudHlwZSA9IHN5bnRheF8xLlN5bnRheC5TZXF1ZW5jZUV4cHJlc3Npb247XHJcblx0ICAgICAgICB0aGlzLmV4cHJlc3Npb25zID0gZXhwcmVzc2lvbnM7XHJcblx0ICAgIH1cclxuXHQgICAgcmV0dXJuIFNlcXVlbmNlRXhwcmVzc2lvbjtcclxuXHR9KCkpO1xyXG5cdGV4cG9ydHMuU2VxdWVuY2VFeHByZXNzaW9uID0gU2VxdWVuY2VFeHByZXNzaW9uO1xyXG5cdHZhciBTcHJlYWRFbGVtZW50ID0gKGZ1bmN0aW9uICgpIHtcclxuXHQgICAgZnVuY3Rpb24gU3ByZWFkRWxlbWVudChhcmd1bWVudCkge1xyXG5cdCAgICAgICAgdGhpcy50eXBlID0gc3ludGF4XzEuU3ludGF4LlNwcmVhZEVsZW1lbnQ7XHJcblx0ICAgICAgICB0aGlzLmFyZ3VtZW50ID0gYXJndW1lbnQ7XHJcblx0ICAgIH1cclxuXHQgICAgcmV0dXJuIFNwcmVhZEVsZW1lbnQ7XHJcblx0fSgpKTtcclxuXHRleHBvcnRzLlNwcmVhZEVsZW1lbnQgPSBTcHJlYWRFbGVtZW50O1xyXG5cdHZhciBTdGF0aWNNZW1iZXJFeHByZXNzaW9uID0gKGZ1bmN0aW9uICgpIHtcclxuXHQgICAgZnVuY3Rpb24gU3RhdGljTWVtYmVyRXhwcmVzc2lvbihvYmplY3QsIHByb3BlcnR5KSB7XHJcblx0ICAgICAgICB0aGlzLnR5cGUgPSBzeW50YXhfMS5TeW50YXguTWVtYmVyRXhwcmVzc2lvbjtcclxuXHQgICAgICAgIHRoaXMuY29tcHV0ZWQgPSBmYWxzZTtcclxuXHQgICAgICAgIHRoaXMub2JqZWN0ID0gb2JqZWN0O1xyXG5cdCAgICAgICAgdGhpcy5wcm9wZXJ0eSA9IHByb3BlcnR5O1xyXG5cdCAgICB9XHJcblx0ICAgIHJldHVybiBTdGF0aWNNZW1iZXJFeHByZXNzaW9uO1xyXG5cdH0oKSk7XHJcblx0ZXhwb3J0cy5TdGF0aWNNZW1iZXJFeHByZXNzaW9uID0gU3RhdGljTWVtYmVyRXhwcmVzc2lvbjtcclxuXHR2YXIgU3VwZXIgPSAoZnVuY3Rpb24gKCkge1xyXG5cdCAgICBmdW5jdGlvbiBTdXBlcigpIHtcclxuXHQgICAgICAgIHRoaXMudHlwZSA9IHN5bnRheF8xLlN5bnRheC5TdXBlcjtcclxuXHQgICAgfVxyXG5cdCAgICByZXR1cm4gU3VwZXI7XHJcblx0fSgpKTtcclxuXHRleHBvcnRzLlN1cGVyID0gU3VwZXI7XHJcblx0dmFyIFN3aXRjaENhc2UgPSAoZnVuY3Rpb24gKCkge1xyXG5cdCAgICBmdW5jdGlvbiBTd2l0Y2hDYXNlKHRlc3QsIGNvbnNlcXVlbnQpIHtcclxuXHQgICAgICAgIHRoaXMudHlwZSA9IHN5bnRheF8xLlN5bnRheC5Td2l0Y2hDYXNlO1xyXG5cdCAgICAgICAgdGhpcy50ZXN0ID0gdGVzdDtcclxuXHQgICAgICAgIHRoaXMuY29uc2VxdWVudCA9IGNvbnNlcXVlbnQ7XHJcblx0ICAgIH1cclxuXHQgICAgcmV0dXJuIFN3aXRjaENhc2U7XHJcblx0fSgpKTtcclxuXHRleHBvcnRzLlN3aXRjaENhc2UgPSBTd2l0Y2hDYXNlO1xyXG5cdHZhciBTd2l0Y2hTdGF0ZW1lbnQgPSAoZnVuY3Rpb24gKCkge1xyXG5cdCAgICBmdW5jdGlvbiBTd2l0Y2hTdGF0ZW1lbnQoZGlzY3JpbWluYW50LCBjYXNlcykge1xyXG5cdCAgICAgICAgdGhpcy50eXBlID0gc3ludGF4XzEuU3ludGF4LlN3aXRjaFN0YXRlbWVudDtcclxuXHQgICAgICAgIHRoaXMuZGlzY3JpbWluYW50ID0gZGlzY3JpbWluYW50O1xyXG5cdCAgICAgICAgdGhpcy5jYXNlcyA9IGNhc2VzO1xyXG5cdCAgICB9XHJcblx0ICAgIHJldHVybiBTd2l0Y2hTdGF0ZW1lbnQ7XHJcblx0fSgpKTtcclxuXHRleHBvcnRzLlN3aXRjaFN0YXRlbWVudCA9IFN3aXRjaFN0YXRlbWVudDtcclxuXHR2YXIgVGFnZ2VkVGVtcGxhdGVFeHByZXNzaW9uID0gKGZ1bmN0aW9uICgpIHtcclxuXHQgICAgZnVuY3Rpb24gVGFnZ2VkVGVtcGxhdGVFeHByZXNzaW9uKHRhZywgcXVhc2kpIHtcclxuXHQgICAgICAgIHRoaXMudHlwZSA9IHN5bnRheF8xLlN5bnRheC5UYWdnZWRUZW1wbGF0ZUV4cHJlc3Npb247XHJcblx0ICAgICAgICB0aGlzLnRhZyA9IHRhZztcclxuXHQgICAgICAgIHRoaXMucXVhc2kgPSBxdWFzaTtcclxuXHQgICAgfVxyXG5cdCAgICByZXR1cm4gVGFnZ2VkVGVtcGxhdGVFeHByZXNzaW9uO1xyXG5cdH0oKSk7XHJcblx0ZXhwb3J0cy5UYWdnZWRUZW1wbGF0ZUV4cHJlc3Npb24gPSBUYWdnZWRUZW1wbGF0ZUV4cHJlc3Npb247XHJcblx0dmFyIFRlbXBsYXRlRWxlbWVudCA9IChmdW5jdGlvbiAoKSB7XHJcblx0ICAgIGZ1bmN0aW9uIFRlbXBsYXRlRWxlbWVudCh2YWx1ZSwgdGFpbCkge1xyXG5cdCAgICAgICAgdGhpcy50eXBlID0gc3ludGF4XzEuU3ludGF4LlRlbXBsYXRlRWxlbWVudDtcclxuXHQgICAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcclxuXHQgICAgICAgIHRoaXMudGFpbCA9IHRhaWw7XHJcblx0ICAgIH1cclxuXHQgICAgcmV0dXJuIFRlbXBsYXRlRWxlbWVudDtcclxuXHR9KCkpO1xyXG5cdGV4cG9ydHMuVGVtcGxhdGVFbGVtZW50ID0gVGVtcGxhdGVFbGVtZW50O1xyXG5cdHZhciBUZW1wbGF0ZUxpdGVyYWwgPSAoZnVuY3Rpb24gKCkge1xyXG5cdCAgICBmdW5jdGlvbiBUZW1wbGF0ZUxpdGVyYWwocXVhc2lzLCBleHByZXNzaW9ucykge1xyXG5cdCAgICAgICAgdGhpcy50eXBlID0gc3ludGF4XzEuU3ludGF4LlRlbXBsYXRlTGl0ZXJhbDtcclxuXHQgICAgICAgIHRoaXMucXVhc2lzID0gcXVhc2lzO1xyXG5cdCAgICAgICAgdGhpcy5leHByZXNzaW9ucyA9IGV4cHJlc3Npb25zO1xyXG5cdCAgICB9XHJcblx0ICAgIHJldHVybiBUZW1wbGF0ZUxpdGVyYWw7XHJcblx0fSgpKTtcclxuXHRleHBvcnRzLlRlbXBsYXRlTGl0ZXJhbCA9IFRlbXBsYXRlTGl0ZXJhbDtcclxuXHR2YXIgVGhpc0V4cHJlc3Npb24gPSAoZnVuY3Rpb24gKCkge1xyXG5cdCAgICBmdW5jdGlvbiBUaGlzRXhwcmVzc2lvbigpIHtcclxuXHQgICAgICAgIHRoaXMudHlwZSA9IHN5bnRheF8xLlN5bnRheC5UaGlzRXhwcmVzc2lvbjtcclxuXHQgICAgfVxyXG5cdCAgICByZXR1cm4gVGhpc0V4cHJlc3Npb247XHJcblx0fSgpKTtcclxuXHRleHBvcnRzLlRoaXNFeHByZXNzaW9uID0gVGhpc0V4cHJlc3Npb247XHJcblx0dmFyIFRocm93U3RhdGVtZW50ID0gKGZ1bmN0aW9uICgpIHtcclxuXHQgICAgZnVuY3Rpb24gVGhyb3dTdGF0ZW1lbnQoYXJndW1lbnQpIHtcclxuXHQgICAgICAgIHRoaXMudHlwZSA9IHN5bnRheF8xLlN5bnRheC5UaHJvd1N0YXRlbWVudDtcclxuXHQgICAgICAgIHRoaXMuYXJndW1lbnQgPSBhcmd1bWVudDtcclxuXHQgICAgfVxyXG5cdCAgICByZXR1cm4gVGhyb3dTdGF0ZW1lbnQ7XHJcblx0fSgpKTtcclxuXHRleHBvcnRzLlRocm93U3RhdGVtZW50ID0gVGhyb3dTdGF0ZW1lbnQ7XHJcblx0dmFyIFRyeVN0YXRlbWVudCA9IChmdW5jdGlvbiAoKSB7XHJcblx0ICAgIGZ1bmN0aW9uIFRyeVN0YXRlbWVudChibG9jaywgaGFuZGxlciwgZmluYWxpemVyKSB7XHJcblx0ICAgICAgICB0aGlzLnR5cGUgPSBzeW50YXhfMS5TeW50YXguVHJ5U3RhdGVtZW50O1xyXG5cdCAgICAgICAgdGhpcy5ibG9jayA9IGJsb2NrO1xyXG5cdCAgICAgICAgdGhpcy5oYW5kbGVyID0gaGFuZGxlcjtcclxuXHQgICAgICAgIHRoaXMuZmluYWxpemVyID0gZmluYWxpemVyO1xyXG5cdCAgICB9XHJcblx0ICAgIHJldHVybiBUcnlTdGF0ZW1lbnQ7XHJcblx0fSgpKTtcclxuXHRleHBvcnRzLlRyeVN0YXRlbWVudCA9IFRyeVN0YXRlbWVudDtcclxuXHR2YXIgVW5hcnlFeHByZXNzaW9uID0gKGZ1bmN0aW9uICgpIHtcclxuXHQgICAgZnVuY3Rpb24gVW5hcnlFeHByZXNzaW9uKG9wZXJhdG9yLCBhcmd1bWVudCkge1xyXG5cdCAgICAgICAgdGhpcy50eXBlID0gc3ludGF4XzEuU3ludGF4LlVuYXJ5RXhwcmVzc2lvbjtcclxuXHQgICAgICAgIHRoaXMub3BlcmF0b3IgPSBvcGVyYXRvcjtcclxuXHQgICAgICAgIHRoaXMuYXJndW1lbnQgPSBhcmd1bWVudDtcclxuXHQgICAgICAgIHRoaXMucHJlZml4ID0gdHJ1ZTtcclxuXHQgICAgfVxyXG5cdCAgICByZXR1cm4gVW5hcnlFeHByZXNzaW9uO1xyXG5cdH0oKSk7XHJcblx0ZXhwb3J0cy5VbmFyeUV4cHJlc3Npb24gPSBVbmFyeUV4cHJlc3Npb247XHJcblx0dmFyIFVwZGF0ZUV4cHJlc3Npb24gPSAoZnVuY3Rpb24gKCkge1xyXG5cdCAgICBmdW5jdGlvbiBVcGRhdGVFeHByZXNzaW9uKG9wZXJhdG9yLCBhcmd1bWVudCwgcHJlZml4KSB7XHJcblx0ICAgICAgICB0aGlzLnR5cGUgPSBzeW50YXhfMS5TeW50YXguVXBkYXRlRXhwcmVzc2lvbjtcclxuXHQgICAgICAgIHRoaXMub3BlcmF0b3IgPSBvcGVyYXRvcjtcclxuXHQgICAgICAgIHRoaXMuYXJndW1lbnQgPSBhcmd1bWVudDtcclxuXHQgICAgICAgIHRoaXMucHJlZml4ID0gcHJlZml4O1xyXG5cdCAgICB9XHJcblx0ICAgIHJldHVybiBVcGRhdGVFeHByZXNzaW9uO1xyXG5cdH0oKSk7XHJcblx0ZXhwb3J0cy5VcGRhdGVFeHByZXNzaW9uID0gVXBkYXRlRXhwcmVzc2lvbjtcclxuXHR2YXIgVmFyaWFibGVEZWNsYXJhdGlvbiA9IChmdW5jdGlvbiAoKSB7XHJcblx0ICAgIGZ1bmN0aW9uIFZhcmlhYmxlRGVjbGFyYXRpb24oZGVjbGFyYXRpb25zLCBraW5kKSB7XHJcblx0ICAgICAgICB0aGlzLnR5cGUgPSBzeW50YXhfMS5TeW50YXguVmFyaWFibGVEZWNsYXJhdGlvbjtcclxuXHQgICAgICAgIHRoaXMuZGVjbGFyYXRpb25zID0gZGVjbGFyYXRpb25zO1xyXG5cdCAgICAgICAgdGhpcy5raW5kID0ga2luZDtcclxuXHQgICAgfVxyXG5cdCAgICByZXR1cm4gVmFyaWFibGVEZWNsYXJhdGlvbjtcclxuXHR9KCkpO1xyXG5cdGV4cG9ydHMuVmFyaWFibGVEZWNsYXJhdGlvbiA9IFZhcmlhYmxlRGVjbGFyYXRpb247XHJcblx0dmFyIFZhcmlhYmxlRGVjbGFyYXRvciA9IChmdW5jdGlvbiAoKSB7XHJcblx0ICAgIGZ1bmN0aW9uIFZhcmlhYmxlRGVjbGFyYXRvcihpZCwgaW5pdCkge1xyXG5cdCAgICAgICAgdGhpcy50eXBlID0gc3ludGF4XzEuU3ludGF4LlZhcmlhYmxlRGVjbGFyYXRvcjtcclxuXHQgICAgICAgIHRoaXMuaWQgPSBpZDtcclxuXHQgICAgICAgIHRoaXMuaW5pdCA9IGluaXQ7XHJcblx0ICAgIH1cclxuXHQgICAgcmV0dXJuIFZhcmlhYmxlRGVjbGFyYXRvcjtcclxuXHR9KCkpO1xyXG5cdGV4cG9ydHMuVmFyaWFibGVEZWNsYXJhdG9yID0gVmFyaWFibGVEZWNsYXJhdG9yO1xyXG5cdHZhciBXaGlsZVN0YXRlbWVudCA9IChmdW5jdGlvbiAoKSB7XHJcblx0ICAgIGZ1bmN0aW9uIFdoaWxlU3RhdGVtZW50KHRlc3QsIGJvZHkpIHtcclxuXHQgICAgICAgIHRoaXMudHlwZSA9IHN5bnRheF8xLlN5bnRheC5XaGlsZVN0YXRlbWVudDtcclxuXHQgICAgICAgIHRoaXMudGVzdCA9IHRlc3Q7XHJcblx0ICAgICAgICB0aGlzLmJvZHkgPSBib2R5O1xyXG5cdCAgICB9XHJcblx0ICAgIHJldHVybiBXaGlsZVN0YXRlbWVudDtcclxuXHR9KCkpO1xyXG5cdGV4cG9ydHMuV2hpbGVTdGF0ZW1lbnQgPSBXaGlsZVN0YXRlbWVudDtcclxuXHR2YXIgV2l0aFN0YXRlbWVudCA9IChmdW5jdGlvbiAoKSB7XHJcblx0ICAgIGZ1bmN0aW9uIFdpdGhTdGF0ZW1lbnQob2JqZWN0LCBib2R5KSB7XHJcblx0ICAgICAgICB0aGlzLnR5cGUgPSBzeW50YXhfMS5TeW50YXguV2l0aFN0YXRlbWVudDtcclxuXHQgICAgICAgIHRoaXMub2JqZWN0ID0gb2JqZWN0O1xyXG5cdCAgICAgICAgdGhpcy5ib2R5ID0gYm9keTtcclxuXHQgICAgfVxyXG5cdCAgICByZXR1cm4gV2l0aFN0YXRlbWVudDtcclxuXHR9KCkpO1xyXG5cdGV4cG9ydHMuV2l0aFN0YXRlbWVudCA9IFdpdGhTdGF0ZW1lbnQ7XHJcblx0dmFyIFlpZWxkRXhwcmVzc2lvbiA9IChmdW5jdGlvbiAoKSB7XHJcblx0ICAgIGZ1bmN0aW9uIFlpZWxkRXhwcmVzc2lvbihhcmd1bWVudCwgZGVsZWdhdGUpIHtcclxuXHQgICAgICAgIHRoaXMudHlwZSA9IHN5bnRheF8xLlN5bnRheC5ZaWVsZEV4cHJlc3Npb247XHJcblx0ICAgICAgICB0aGlzLmFyZ3VtZW50ID0gYXJndW1lbnQ7XHJcblx0ICAgICAgICB0aGlzLmRlbGVnYXRlID0gZGVsZWdhdGU7XHJcblx0ICAgIH1cclxuXHQgICAgcmV0dXJuIFlpZWxkRXhwcmVzc2lvbjtcclxuXHR9KCkpO1xyXG5cdGV4cG9ydHMuWWllbGRFeHByZXNzaW9uID0gWWllbGRFeHByZXNzaW9uO1xyXG5cblxuLyoqKi8gfSxcbi8qIDggKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cdFwidXNlIHN0cmljdFwiO1xyXG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuXHR2YXIgYXNzZXJ0XzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDkpO1xyXG5cdHZhciBlcnJvcl9oYW5kbGVyXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEwKTtcclxuXHR2YXIgbWVzc2FnZXNfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMTEpO1xyXG5cdHZhciBOb2RlID0gX193ZWJwYWNrX3JlcXVpcmVfXyg3KTtcclxuXHR2YXIgc2Nhbm5lcl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMik7XHJcblx0dmFyIHN5bnRheF8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygyKTtcclxuXHR2YXIgdG9rZW5fMSA9IF9fd2VicGFja19yZXF1aXJlX18oMTMpO1xyXG5cdHZhciBBcnJvd1BhcmFtZXRlclBsYWNlSG9sZGVyID0gJ0Fycm93UGFyYW1ldGVyUGxhY2VIb2xkZXInO1xyXG5cdHZhciBQYXJzZXIgPSAoZnVuY3Rpb24gKCkge1xyXG5cdCAgICBmdW5jdGlvbiBQYXJzZXIoY29kZSwgb3B0aW9ucywgZGVsZWdhdGUpIHtcclxuXHQgICAgICAgIGlmIChvcHRpb25zID09PSB2b2lkIDApIHsgb3B0aW9ucyA9IHt9OyB9XHJcblx0ICAgICAgICB0aGlzLmNvbmZpZyA9IHtcclxuXHQgICAgICAgICAgICByYW5nZTogKHR5cGVvZiBvcHRpb25zLnJhbmdlID09PSAnYm9vbGVhbicpICYmIG9wdGlvbnMucmFuZ2UsXHJcblx0ICAgICAgICAgICAgbG9jOiAodHlwZW9mIG9wdGlvbnMubG9jID09PSAnYm9vbGVhbicpICYmIG9wdGlvbnMubG9jLFxyXG5cdCAgICAgICAgICAgIHNvdXJjZTogbnVsbCxcclxuXHQgICAgICAgICAgICB0b2tlbnM6ICh0eXBlb2Ygb3B0aW9ucy50b2tlbnMgPT09ICdib29sZWFuJykgJiYgb3B0aW9ucy50b2tlbnMsXHJcblx0ICAgICAgICAgICAgY29tbWVudDogKHR5cGVvZiBvcHRpb25zLmNvbW1lbnQgPT09ICdib29sZWFuJykgJiYgb3B0aW9ucy5jb21tZW50LFxyXG5cdCAgICAgICAgICAgIHRvbGVyYW50OiAodHlwZW9mIG9wdGlvbnMudG9sZXJhbnQgPT09ICdib29sZWFuJykgJiYgb3B0aW9ucy50b2xlcmFudFxyXG5cdCAgICAgICAgfTtcclxuXHQgICAgICAgIGlmICh0aGlzLmNvbmZpZy5sb2MgJiYgb3B0aW9ucy5zb3VyY2UgJiYgb3B0aW9ucy5zb3VyY2UgIT09IG51bGwpIHtcclxuXHQgICAgICAgICAgICB0aGlzLmNvbmZpZy5zb3VyY2UgPSBTdHJpbmcob3B0aW9ucy5zb3VyY2UpO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgdGhpcy5kZWxlZ2F0ZSA9IGRlbGVnYXRlO1xyXG5cdCAgICAgICAgdGhpcy5lcnJvckhhbmRsZXIgPSBuZXcgZXJyb3JfaGFuZGxlcl8xLkVycm9ySGFuZGxlcigpO1xyXG5cdCAgICAgICAgdGhpcy5lcnJvckhhbmRsZXIudG9sZXJhbnQgPSB0aGlzLmNvbmZpZy50b2xlcmFudDtcclxuXHQgICAgICAgIHRoaXMuc2Nhbm5lciA9IG5ldyBzY2FubmVyXzEuU2Nhbm5lcihjb2RlLCB0aGlzLmVycm9ySGFuZGxlcik7XHJcblx0ICAgICAgICB0aGlzLnNjYW5uZXIudHJhY2tDb21tZW50ID0gdGhpcy5jb25maWcuY29tbWVudDtcclxuXHQgICAgICAgIHRoaXMub3BlcmF0b3JQcmVjZWRlbmNlID0ge1xyXG5cdCAgICAgICAgICAgICcpJzogMCxcclxuXHQgICAgICAgICAgICAnOyc6IDAsXHJcblx0ICAgICAgICAgICAgJywnOiAwLFxyXG5cdCAgICAgICAgICAgICc9JzogMCxcclxuXHQgICAgICAgICAgICAnXSc6IDAsXHJcblx0ICAgICAgICAgICAgJ3x8JzogMSxcclxuXHQgICAgICAgICAgICAnJiYnOiAyLFxyXG5cdCAgICAgICAgICAgICd8JzogMyxcclxuXHQgICAgICAgICAgICAnXic6IDQsXHJcblx0ICAgICAgICAgICAgJyYnOiA1LFxyXG5cdCAgICAgICAgICAgICc9PSc6IDYsXHJcblx0ICAgICAgICAgICAgJyE9JzogNixcclxuXHQgICAgICAgICAgICAnPT09JzogNixcclxuXHQgICAgICAgICAgICAnIT09JzogNixcclxuXHQgICAgICAgICAgICAnPCc6IDcsXHJcblx0ICAgICAgICAgICAgJz4nOiA3LFxyXG5cdCAgICAgICAgICAgICc8PSc6IDcsXHJcblx0ICAgICAgICAgICAgJz49JzogNyxcclxuXHQgICAgICAgICAgICAnPDwnOiA4LFxyXG5cdCAgICAgICAgICAgICc+Pic6IDgsXHJcblx0ICAgICAgICAgICAgJz4+Pic6IDgsXHJcblx0ICAgICAgICAgICAgJysnOiA5LFxyXG5cdCAgICAgICAgICAgICctJzogOSxcclxuXHQgICAgICAgICAgICAnKic6IDExLFxyXG5cdCAgICAgICAgICAgICcvJzogMTEsXHJcblx0ICAgICAgICAgICAgJyUnOiAxMVxyXG5cdCAgICAgICAgfTtcclxuXHQgICAgICAgIHRoaXMubG9va2FoZWFkID0ge1xyXG5cdCAgICAgICAgICAgIHR5cGU6IDIgLyogRU9GICovLFxyXG5cdCAgICAgICAgICAgIHZhbHVlOiAnJyxcclxuXHQgICAgICAgICAgICBsaW5lTnVtYmVyOiB0aGlzLnNjYW5uZXIubGluZU51bWJlcixcclxuXHQgICAgICAgICAgICBsaW5lU3RhcnQ6IDAsXHJcblx0ICAgICAgICAgICAgc3RhcnQ6IDAsXHJcblx0ICAgICAgICAgICAgZW5kOiAwXHJcblx0ICAgICAgICB9O1xyXG5cdCAgICAgICAgdGhpcy5oYXNMaW5lVGVybWluYXRvciA9IGZhbHNlO1xyXG5cdCAgICAgICAgdGhpcy5jb250ZXh0ID0ge1xyXG5cdCAgICAgICAgICAgIGlzTW9kdWxlOiBmYWxzZSxcclxuXHQgICAgICAgICAgICBhd2FpdDogZmFsc2UsXHJcblx0ICAgICAgICAgICAgYWxsb3dJbjogdHJ1ZSxcclxuXHQgICAgICAgICAgICBhbGxvd1N0cmljdERpcmVjdGl2ZTogdHJ1ZSxcclxuXHQgICAgICAgICAgICBhbGxvd1lpZWxkOiB0cnVlLFxyXG5cdCAgICAgICAgICAgIGZpcnN0Q292ZXJJbml0aWFsaXplZE5hbWVFcnJvcjogbnVsbCxcclxuXHQgICAgICAgICAgICBpc0Fzc2lnbm1lbnRUYXJnZXQ6IGZhbHNlLFxyXG5cdCAgICAgICAgICAgIGlzQmluZGluZ0VsZW1lbnQ6IGZhbHNlLFxyXG5cdCAgICAgICAgICAgIGluRnVuY3Rpb25Cb2R5OiBmYWxzZSxcclxuXHQgICAgICAgICAgICBpbkl0ZXJhdGlvbjogZmFsc2UsXHJcblx0ICAgICAgICAgICAgaW5Td2l0Y2g6IGZhbHNlLFxyXG5cdCAgICAgICAgICAgIGxhYmVsU2V0OiB7fSxcclxuXHQgICAgICAgICAgICBzdHJpY3Q6IGZhbHNlXHJcblx0ICAgICAgICB9O1xyXG5cdCAgICAgICAgdGhpcy50b2tlbnMgPSBbXTtcclxuXHQgICAgICAgIHRoaXMuc3RhcnRNYXJrZXIgPSB7XHJcblx0ICAgICAgICAgICAgaW5kZXg6IDAsXHJcblx0ICAgICAgICAgICAgbGluZTogdGhpcy5zY2FubmVyLmxpbmVOdW1iZXIsXHJcblx0ICAgICAgICAgICAgY29sdW1uOiAwXHJcblx0ICAgICAgICB9O1xyXG5cdCAgICAgICAgdGhpcy5sYXN0TWFya2VyID0ge1xyXG5cdCAgICAgICAgICAgIGluZGV4OiAwLFxyXG5cdCAgICAgICAgICAgIGxpbmU6IHRoaXMuc2Nhbm5lci5saW5lTnVtYmVyLFxyXG5cdCAgICAgICAgICAgIGNvbHVtbjogMFxyXG5cdCAgICAgICAgfTtcclxuXHQgICAgICAgIHRoaXMubmV4dFRva2VuKCk7XHJcblx0ICAgICAgICB0aGlzLmxhc3RNYXJrZXIgPSB7XHJcblx0ICAgICAgICAgICAgaW5kZXg6IHRoaXMuc2Nhbm5lci5pbmRleCxcclxuXHQgICAgICAgICAgICBsaW5lOiB0aGlzLnNjYW5uZXIubGluZU51bWJlcixcclxuXHQgICAgICAgICAgICBjb2x1bW46IHRoaXMuc2Nhbm5lci5pbmRleCAtIHRoaXMuc2Nhbm5lci5saW5lU3RhcnRcclxuXHQgICAgICAgIH07XHJcblx0ICAgIH1cclxuXHQgICAgUGFyc2VyLnByb3RvdHlwZS50aHJvd0Vycm9yID0gZnVuY3Rpb24gKG1lc3NhZ2VGb3JtYXQpIHtcclxuXHQgICAgICAgIHZhciB2YWx1ZXMgPSBbXTtcclxuXHQgICAgICAgIGZvciAodmFyIF9pID0gMTsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XHJcblx0ICAgICAgICAgICAgdmFsdWVzW19pIC0gMV0gPSBhcmd1bWVudHNbX2ldO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgdmFyIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpO1xyXG5cdCAgICAgICAgdmFyIG1zZyA9IG1lc3NhZ2VGb3JtYXQucmVwbGFjZSgvJShcXGQpL2csIGZ1bmN0aW9uICh3aG9sZSwgaWR4KSB7XHJcblx0ICAgICAgICAgICAgYXNzZXJ0XzEuYXNzZXJ0KGlkeCA8IGFyZ3MubGVuZ3RoLCAnTWVzc2FnZSByZWZlcmVuY2UgbXVzdCBiZSBpbiByYW5nZScpO1xyXG5cdCAgICAgICAgICAgIHJldHVybiBhcmdzW2lkeF07XHJcblx0ICAgICAgICB9KTtcclxuXHQgICAgICAgIHZhciBpbmRleCA9IHRoaXMubGFzdE1hcmtlci5pbmRleDtcclxuXHQgICAgICAgIHZhciBsaW5lID0gdGhpcy5sYXN0TWFya2VyLmxpbmU7XHJcblx0ICAgICAgICB2YXIgY29sdW1uID0gdGhpcy5sYXN0TWFya2VyLmNvbHVtbiArIDE7XHJcblx0ICAgICAgICB0aHJvdyB0aGlzLmVycm9ySGFuZGxlci5jcmVhdGVFcnJvcihpbmRleCwgbGluZSwgY29sdW1uLCBtc2cpO1xyXG5cdCAgICB9O1xyXG5cdCAgICBQYXJzZXIucHJvdG90eXBlLnRvbGVyYXRlRXJyb3IgPSBmdW5jdGlvbiAobWVzc2FnZUZvcm1hdCkge1xyXG5cdCAgICAgICAgdmFyIHZhbHVlcyA9IFtdO1xyXG5cdCAgICAgICAgZm9yICh2YXIgX2kgPSAxOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcclxuXHQgICAgICAgICAgICB2YWx1ZXNbX2kgLSAxXSA9IGFyZ3VtZW50c1tfaV07XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICB2YXIgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSk7XHJcblx0ICAgICAgICB2YXIgbXNnID0gbWVzc2FnZUZvcm1hdC5yZXBsYWNlKC8lKFxcZCkvZywgZnVuY3Rpb24gKHdob2xlLCBpZHgpIHtcclxuXHQgICAgICAgICAgICBhc3NlcnRfMS5hc3NlcnQoaWR4IDwgYXJncy5sZW5ndGgsICdNZXNzYWdlIHJlZmVyZW5jZSBtdXN0IGJlIGluIHJhbmdlJyk7XHJcblx0ICAgICAgICAgICAgcmV0dXJuIGFyZ3NbaWR4XTtcclxuXHQgICAgICAgIH0pO1xyXG5cdCAgICAgICAgdmFyIGluZGV4ID0gdGhpcy5sYXN0TWFya2VyLmluZGV4O1xyXG5cdCAgICAgICAgdmFyIGxpbmUgPSB0aGlzLnNjYW5uZXIubGluZU51bWJlcjtcclxuXHQgICAgICAgIHZhciBjb2x1bW4gPSB0aGlzLmxhc3RNYXJrZXIuY29sdW1uICsgMTtcclxuXHQgICAgICAgIHRoaXMuZXJyb3JIYW5kbGVyLnRvbGVyYXRlRXJyb3IoaW5kZXgsIGxpbmUsIGNvbHVtbiwgbXNnKTtcclxuXHQgICAgfTtcclxuXHQgICAgLy8gVGhyb3cgYW4gZXhjZXB0aW9uIGJlY2F1c2Ugb2YgdGhlIHRva2VuLlxyXG5cdCAgICBQYXJzZXIucHJvdG90eXBlLnVuZXhwZWN0ZWRUb2tlbkVycm9yID0gZnVuY3Rpb24gKHRva2VuLCBtZXNzYWdlKSB7XHJcblx0ICAgICAgICB2YXIgbXNnID0gbWVzc2FnZSB8fCBtZXNzYWdlc18xLk1lc3NhZ2VzLlVuZXhwZWN0ZWRUb2tlbjtcclxuXHQgICAgICAgIHZhciB2YWx1ZTtcclxuXHQgICAgICAgIGlmICh0b2tlbikge1xyXG5cdCAgICAgICAgICAgIGlmICghbWVzc2FnZSkge1xyXG5cdCAgICAgICAgICAgICAgICBtc2cgPSAodG9rZW4udHlwZSA9PT0gMiAvKiBFT0YgKi8pID8gbWVzc2FnZXNfMS5NZXNzYWdlcy5VbmV4cGVjdGVkRU9TIDpcclxuXHQgICAgICAgICAgICAgICAgICAgICh0b2tlbi50eXBlID09PSAzIC8qIElkZW50aWZpZXIgKi8pID8gbWVzc2FnZXNfMS5NZXNzYWdlcy5VbmV4cGVjdGVkSWRlbnRpZmllciA6XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgKHRva2VuLnR5cGUgPT09IDYgLyogTnVtZXJpY0xpdGVyYWwgKi8pID8gbWVzc2FnZXNfMS5NZXNzYWdlcy5VbmV4cGVjdGVkTnVtYmVyIDpcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgKHRva2VuLnR5cGUgPT09IDggLyogU3RyaW5nTGl0ZXJhbCAqLykgPyBtZXNzYWdlc18xLk1lc3NhZ2VzLlVuZXhwZWN0ZWRTdHJpbmcgOlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKHRva2VuLnR5cGUgPT09IDEwIC8qIFRlbXBsYXRlICovKSA/IG1lc3NhZ2VzXzEuTWVzc2FnZXMuVW5leHBlY3RlZFRlbXBsYXRlIDpcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlc18xLk1lc3NhZ2VzLlVuZXhwZWN0ZWRUb2tlbjtcclxuXHQgICAgICAgICAgICAgICAgaWYgKHRva2VuLnR5cGUgPT09IDQgLyogS2V5d29yZCAqLykge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuc2Nhbm5lci5pc0Z1dHVyZVJlc2VydmVkV29yZCh0b2tlbi52YWx1ZSkpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBtc2cgPSBtZXNzYWdlc18xLk1lc3NhZ2VzLlVuZXhwZWN0ZWRSZXNlcnZlZDtcclxuXHQgICAgICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMuY29udGV4dC5zdHJpY3QgJiYgdGhpcy5zY2FubmVyLmlzU3RyaWN0TW9kZVJlc2VydmVkV29yZCh0b2tlbi52YWx1ZSkpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBtc2cgPSBtZXNzYWdlc18xLk1lc3NhZ2VzLlN0cmljdFJlc2VydmVkV29yZDtcclxuXHQgICAgICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICB2YWx1ZSA9IHRva2VuLnZhbHVlO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgZWxzZSB7XHJcblx0ICAgICAgICAgICAgdmFsdWUgPSAnSUxMRUdBTCc7XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICBtc2cgPSBtc2cucmVwbGFjZSgnJTAnLCB2YWx1ZSk7XHJcblx0ICAgICAgICBpZiAodG9rZW4gJiYgdHlwZW9mIHRva2VuLmxpbmVOdW1iZXIgPT09ICdudW1iZXInKSB7XHJcblx0ICAgICAgICAgICAgdmFyIGluZGV4ID0gdG9rZW4uc3RhcnQ7XHJcblx0ICAgICAgICAgICAgdmFyIGxpbmUgPSB0b2tlbi5saW5lTnVtYmVyO1xyXG5cdCAgICAgICAgICAgIHZhciBsYXN0TWFya2VyTGluZVN0YXJ0ID0gdGhpcy5sYXN0TWFya2VyLmluZGV4IC0gdGhpcy5sYXN0TWFya2VyLmNvbHVtbjtcclxuXHQgICAgICAgICAgICB2YXIgY29sdW1uID0gdG9rZW4uc3RhcnQgLSBsYXN0TWFya2VyTGluZVN0YXJ0ICsgMTtcclxuXHQgICAgICAgICAgICByZXR1cm4gdGhpcy5lcnJvckhhbmRsZXIuY3JlYXRlRXJyb3IoaW5kZXgsIGxpbmUsIGNvbHVtbiwgbXNnKTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIGVsc2Uge1xyXG5cdCAgICAgICAgICAgIHZhciBpbmRleCA9IHRoaXMubGFzdE1hcmtlci5pbmRleDtcclxuXHQgICAgICAgICAgICB2YXIgbGluZSA9IHRoaXMubGFzdE1hcmtlci5saW5lO1xyXG5cdCAgICAgICAgICAgIHZhciBjb2x1bW4gPSB0aGlzLmxhc3RNYXJrZXIuY29sdW1uICsgMTtcclxuXHQgICAgICAgICAgICByZXR1cm4gdGhpcy5lcnJvckhhbmRsZXIuY3JlYXRlRXJyb3IoaW5kZXgsIGxpbmUsIGNvbHVtbiwgbXNnKTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgfTtcclxuXHQgICAgUGFyc2VyLnByb3RvdHlwZS50aHJvd1VuZXhwZWN0ZWRUb2tlbiA9IGZ1bmN0aW9uICh0b2tlbiwgbWVzc2FnZSkge1xyXG5cdCAgICAgICAgdGhyb3cgdGhpcy51bmV4cGVjdGVkVG9rZW5FcnJvcih0b2tlbiwgbWVzc2FnZSk7XHJcblx0ICAgIH07XHJcblx0ICAgIFBhcnNlci5wcm90b3R5cGUudG9sZXJhdGVVbmV4cGVjdGVkVG9rZW4gPSBmdW5jdGlvbiAodG9rZW4sIG1lc3NhZ2UpIHtcclxuXHQgICAgICAgIHRoaXMuZXJyb3JIYW5kbGVyLnRvbGVyYXRlKHRoaXMudW5leHBlY3RlZFRva2VuRXJyb3IodG9rZW4sIG1lc3NhZ2UpKTtcclxuXHQgICAgfTtcclxuXHQgICAgUGFyc2VyLnByb3RvdHlwZS5jb2xsZWN0Q29tbWVudHMgPSBmdW5jdGlvbiAoKSB7XHJcblx0ICAgICAgICBpZiAoIXRoaXMuY29uZmlnLmNvbW1lbnQpIHtcclxuXHQgICAgICAgICAgICB0aGlzLnNjYW5uZXIuc2NhbkNvbW1lbnRzKCk7XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICBlbHNlIHtcclxuXHQgICAgICAgICAgICB2YXIgY29tbWVudHMgPSB0aGlzLnNjYW5uZXIuc2NhbkNvbW1lbnRzKCk7XHJcblx0ICAgICAgICAgICAgaWYgKGNvbW1lbnRzLmxlbmd0aCA+IDAgJiYgdGhpcy5kZWxlZ2F0ZSkge1xyXG5cdCAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNvbW1lbnRzLmxlbmd0aDsgKytpKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgZSA9IGNvbW1lbnRzW2ldO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIG5vZGUgPSB2b2lkIDA7XHJcblx0ICAgICAgICAgICAgICAgICAgICBub2RlID0ge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IGUubXVsdGlMaW5lID8gJ0Jsb2NrQ29tbWVudCcgOiAnTGluZUNvbW1lbnQnLFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiB0aGlzLnNjYW5uZXIuc291cmNlLnNsaWNlKGUuc2xpY2VbMF0sIGUuc2xpY2VbMV0pXHJcblx0ICAgICAgICAgICAgICAgICAgICB9O1xyXG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlnLnJhbmdlKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgbm9kZS5yYW5nZSA9IGUucmFuZ2U7XHJcblx0ICAgICAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5jb25maWcubG9jKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgbm9kZS5sb2MgPSBlLmxvYztcclxuXHQgICAgICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgICAgIHZhciBtZXRhZGF0YSA9IHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBzdGFydDoge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBsaW5lOiBlLmxvYy5zdGFydC5saW5lLFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2x1bW46IGUubG9jLnN0YXJ0LmNvbHVtbixcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgb2Zmc2V0OiBlLnJhbmdlWzBdXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfSxcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBlbmQ6IHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGluZTogZS5sb2MuZW5kLmxpbmUsXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbHVtbjogZS5sb2MuZW5kLmNvbHVtbixcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgb2Zmc2V0OiBlLnJhbmdlWzFdXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICAgICAgfTtcclxuXHQgICAgICAgICAgICAgICAgICAgIHRoaXMuZGVsZWdhdGUobm9kZSwgbWV0YWRhdGEpO1xyXG5cdCAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgfVxyXG5cdCAgICB9O1xyXG5cdCAgICAvLyBGcm9tIGludGVybmFsIHJlcHJlc2VudGF0aW9uIHRvIGFuIGV4dGVybmFsIHN0cnVjdHVyZVxyXG5cdCAgICBQYXJzZXIucHJvdG90eXBlLmdldFRva2VuUmF3ID0gZnVuY3Rpb24gKHRva2VuKSB7XHJcblx0ICAgICAgICByZXR1cm4gdGhpcy5zY2FubmVyLnNvdXJjZS5zbGljZSh0b2tlbi5zdGFydCwgdG9rZW4uZW5kKTtcclxuXHQgICAgfTtcclxuXHQgICAgUGFyc2VyLnByb3RvdHlwZS5jb252ZXJ0VG9rZW4gPSBmdW5jdGlvbiAodG9rZW4pIHtcclxuXHQgICAgICAgIHZhciB0ID0ge1xyXG5cdCAgICAgICAgICAgIHR5cGU6IHRva2VuXzEuVG9rZW5OYW1lW3Rva2VuLnR5cGVdLFxyXG5cdCAgICAgICAgICAgIHZhbHVlOiB0aGlzLmdldFRva2VuUmF3KHRva2VuKVxyXG5cdCAgICAgICAgfTtcclxuXHQgICAgICAgIGlmICh0aGlzLmNvbmZpZy5yYW5nZSkge1xyXG5cdCAgICAgICAgICAgIHQucmFuZ2UgPSBbdG9rZW4uc3RhcnQsIHRva2VuLmVuZF07XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICBpZiAodGhpcy5jb25maWcubG9jKSB7XHJcblx0ICAgICAgICAgICAgdC5sb2MgPSB7XHJcblx0ICAgICAgICAgICAgICAgIHN0YXJ0OiB7XHJcblx0ICAgICAgICAgICAgICAgICAgICBsaW5lOiB0aGlzLnN0YXJ0TWFya2VyLmxpbmUsXHJcblx0ICAgICAgICAgICAgICAgICAgICBjb2x1bW46IHRoaXMuc3RhcnRNYXJrZXIuY29sdW1uXHJcblx0ICAgICAgICAgICAgICAgIH0sXHJcblx0ICAgICAgICAgICAgICAgIGVuZDoge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgbGluZTogdGhpcy5zY2FubmVyLmxpbmVOdW1iZXIsXHJcblx0ICAgICAgICAgICAgICAgICAgICBjb2x1bW46IHRoaXMuc2Nhbm5lci5pbmRleCAtIHRoaXMuc2Nhbm5lci5saW5lU3RhcnRcclxuXHQgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgIH07XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICBpZiAodG9rZW4udHlwZSA9PT0gOSAvKiBSZWd1bGFyRXhwcmVzc2lvbiAqLykge1xyXG5cdCAgICAgICAgICAgIHZhciBwYXR0ZXJuID0gdG9rZW4ucGF0dGVybjtcclxuXHQgICAgICAgICAgICB2YXIgZmxhZ3MgPSB0b2tlbi5mbGFncztcclxuXHQgICAgICAgICAgICB0LnJlZ2V4ID0geyBwYXR0ZXJuOiBwYXR0ZXJuLCBmbGFnczogZmxhZ3MgfTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIHJldHVybiB0O1xyXG5cdCAgICB9O1xyXG5cdCAgICBQYXJzZXIucHJvdG90eXBlLm5leHRUb2tlbiA9IGZ1bmN0aW9uICgpIHtcclxuXHQgICAgICAgIHZhciB0b2tlbiA9IHRoaXMubG9va2FoZWFkO1xyXG5cdCAgICAgICAgdGhpcy5sYXN0TWFya2VyLmluZGV4ID0gdGhpcy5zY2FubmVyLmluZGV4O1xyXG5cdCAgICAgICAgdGhpcy5sYXN0TWFya2VyLmxpbmUgPSB0aGlzLnNjYW5uZXIubGluZU51bWJlcjtcclxuXHQgICAgICAgIHRoaXMubGFzdE1hcmtlci5jb2x1bW4gPSB0aGlzLnNjYW5uZXIuaW5kZXggLSB0aGlzLnNjYW5uZXIubGluZVN0YXJ0O1xyXG5cdCAgICAgICAgdGhpcy5jb2xsZWN0Q29tbWVudHMoKTtcclxuXHQgICAgICAgIGlmICh0aGlzLnNjYW5uZXIuaW5kZXggIT09IHRoaXMuc3RhcnRNYXJrZXIuaW5kZXgpIHtcclxuXHQgICAgICAgICAgICB0aGlzLnN0YXJ0TWFya2VyLmluZGV4ID0gdGhpcy5zY2FubmVyLmluZGV4O1xyXG5cdCAgICAgICAgICAgIHRoaXMuc3RhcnRNYXJrZXIubGluZSA9IHRoaXMuc2Nhbm5lci5saW5lTnVtYmVyO1xyXG5cdCAgICAgICAgICAgIHRoaXMuc3RhcnRNYXJrZXIuY29sdW1uID0gdGhpcy5zY2FubmVyLmluZGV4IC0gdGhpcy5zY2FubmVyLmxpbmVTdGFydDtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIHZhciBuZXh0ID0gdGhpcy5zY2FubmVyLmxleCgpO1xyXG5cdCAgICAgICAgdGhpcy5oYXNMaW5lVGVybWluYXRvciA9ICh0b2tlbi5saW5lTnVtYmVyICE9PSBuZXh0LmxpbmVOdW1iZXIpO1xyXG5cdCAgICAgICAgaWYgKG5leHQgJiYgdGhpcy5jb250ZXh0LnN0cmljdCAmJiBuZXh0LnR5cGUgPT09IDMgLyogSWRlbnRpZmllciAqLykge1xyXG5cdCAgICAgICAgICAgIGlmICh0aGlzLnNjYW5uZXIuaXNTdHJpY3RNb2RlUmVzZXJ2ZWRXb3JkKG5leHQudmFsdWUpKSB7XHJcblx0ICAgICAgICAgICAgICAgIG5leHQudHlwZSA9IDQgLyogS2V5d29yZCAqLztcclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICB0aGlzLmxvb2thaGVhZCA9IG5leHQ7XHJcblx0ICAgICAgICBpZiAodGhpcy5jb25maWcudG9rZW5zICYmIG5leHQudHlwZSAhPT0gMiAvKiBFT0YgKi8pIHtcclxuXHQgICAgICAgICAgICB0aGlzLnRva2Vucy5wdXNoKHRoaXMuY29udmVydFRva2VuKG5leHQpKTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIHJldHVybiB0b2tlbjtcclxuXHQgICAgfTtcclxuXHQgICAgUGFyc2VyLnByb3RvdHlwZS5uZXh0UmVnZXhUb2tlbiA9IGZ1bmN0aW9uICgpIHtcclxuXHQgICAgICAgIHRoaXMuY29sbGVjdENvbW1lbnRzKCk7XHJcblx0ICAgICAgICB2YXIgdG9rZW4gPSB0aGlzLnNjYW5uZXIuc2NhblJlZ0V4cCgpO1xyXG5cdCAgICAgICAgaWYgKHRoaXMuY29uZmlnLnRva2Vucykge1xyXG5cdCAgICAgICAgICAgIC8vIFBvcCB0aGUgcHJldmlvdXMgdG9rZW4sICcvJyBvciAnLz0nXHJcblx0ICAgICAgICAgICAgLy8gVGhpcyBpcyBhZGRlZCBmcm9tIHRoZSBsb29rYWhlYWQgdG9rZW4uXHJcblx0ICAgICAgICAgICAgdGhpcy50b2tlbnMucG9wKCk7XHJcblx0ICAgICAgICAgICAgdGhpcy50b2tlbnMucHVzaCh0aGlzLmNvbnZlcnRUb2tlbih0b2tlbikpO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgLy8gUHJpbWUgdGhlIG5leHQgbG9va2FoZWFkLlxyXG5cdCAgICAgICAgdGhpcy5sb29rYWhlYWQgPSB0b2tlbjtcclxuXHQgICAgICAgIHRoaXMubmV4dFRva2VuKCk7XHJcblx0ICAgICAgICByZXR1cm4gdG9rZW47XHJcblx0ICAgIH07XHJcblx0ICAgIFBhcnNlci5wcm90b3R5cGUuY3JlYXRlTm9kZSA9IGZ1bmN0aW9uICgpIHtcclxuXHQgICAgICAgIHJldHVybiB7XHJcblx0ICAgICAgICAgICAgaW5kZXg6IHRoaXMuc3RhcnRNYXJrZXIuaW5kZXgsXHJcblx0ICAgICAgICAgICAgbGluZTogdGhpcy5zdGFydE1hcmtlci5saW5lLFxyXG5cdCAgICAgICAgICAgIGNvbHVtbjogdGhpcy5zdGFydE1hcmtlci5jb2x1bW5cclxuXHQgICAgICAgIH07XHJcblx0ICAgIH07XHJcblx0ICAgIFBhcnNlci5wcm90b3R5cGUuc3RhcnROb2RlID0gZnVuY3Rpb24gKHRva2VuKSB7XHJcblx0ICAgICAgICByZXR1cm4ge1xyXG5cdCAgICAgICAgICAgIGluZGV4OiB0b2tlbi5zdGFydCxcclxuXHQgICAgICAgICAgICBsaW5lOiB0b2tlbi5saW5lTnVtYmVyLFxyXG5cdCAgICAgICAgICAgIGNvbHVtbjogdG9rZW4uc3RhcnQgLSB0b2tlbi5saW5lU3RhcnRcclxuXHQgICAgICAgIH07XHJcblx0ICAgIH07XHJcblx0ICAgIFBhcnNlci5wcm90b3R5cGUuZmluYWxpemUgPSBmdW5jdGlvbiAobWFya2VyLCBub2RlKSB7XHJcblx0ICAgICAgICBpZiAodGhpcy5jb25maWcucmFuZ2UpIHtcclxuXHQgICAgICAgICAgICBub2RlLnJhbmdlID0gW21hcmtlci5pbmRleCwgdGhpcy5sYXN0TWFya2VyLmluZGV4XTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIGlmICh0aGlzLmNvbmZpZy5sb2MpIHtcclxuXHQgICAgICAgICAgICBub2RlLmxvYyA9IHtcclxuXHQgICAgICAgICAgICAgICAgc3RhcnQ6IHtcclxuXHQgICAgICAgICAgICAgICAgICAgIGxpbmU6IG1hcmtlci5saW5lLFxyXG5cdCAgICAgICAgICAgICAgICAgICAgY29sdW1uOiBtYXJrZXIuY29sdW1uLFxyXG5cdCAgICAgICAgICAgICAgICB9LFxyXG5cdCAgICAgICAgICAgICAgICBlbmQ6IHtcclxuXHQgICAgICAgICAgICAgICAgICAgIGxpbmU6IHRoaXMubGFzdE1hcmtlci5saW5lLFxyXG5cdCAgICAgICAgICAgICAgICAgICAgY29sdW1uOiB0aGlzLmxhc3RNYXJrZXIuY29sdW1uXHJcblx0ICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICB9O1xyXG5cdCAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZy5zb3VyY2UpIHtcclxuXHQgICAgICAgICAgICAgICAgbm9kZS5sb2Muc291cmNlID0gdGhpcy5jb25maWcuc291cmNlO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIGlmICh0aGlzLmRlbGVnYXRlKSB7XHJcblx0ICAgICAgICAgICAgdmFyIG1ldGFkYXRhID0ge1xyXG5cdCAgICAgICAgICAgICAgICBzdGFydDoge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgbGluZTogbWFya2VyLmxpbmUsXHJcblx0ICAgICAgICAgICAgICAgICAgICBjb2x1bW46IG1hcmtlci5jb2x1bW4sXHJcblx0ICAgICAgICAgICAgICAgICAgICBvZmZzZXQ6IG1hcmtlci5pbmRleFxyXG5cdCAgICAgICAgICAgICAgICB9LFxyXG5cdCAgICAgICAgICAgICAgICBlbmQ6IHtcclxuXHQgICAgICAgICAgICAgICAgICAgIGxpbmU6IHRoaXMubGFzdE1hcmtlci5saW5lLFxyXG5cdCAgICAgICAgICAgICAgICAgICAgY29sdW1uOiB0aGlzLmxhc3RNYXJrZXIuY29sdW1uLFxyXG5cdCAgICAgICAgICAgICAgICAgICAgb2Zmc2V0OiB0aGlzLmxhc3RNYXJrZXIuaW5kZXhcclxuXHQgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgIH07XHJcblx0ICAgICAgICAgICAgdGhpcy5kZWxlZ2F0ZShub2RlLCBtZXRhZGF0YSk7XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICByZXR1cm4gbm9kZTtcclxuXHQgICAgfTtcclxuXHQgICAgLy8gRXhwZWN0IHRoZSBuZXh0IHRva2VuIHRvIG1hdGNoIHRoZSBzcGVjaWZpZWQgcHVuY3R1YXRvci5cclxuXHQgICAgLy8gSWYgbm90LCBhbiBleGNlcHRpb24gd2lsbCBiZSB0aHJvd24uXHJcblx0ICAgIFBhcnNlci5wcm90b3R5cGUuZXhwZWN0ID0gZnVuY3Rpb24gKHZhbHVlKSB7XHJcblx0ICAgICAgICB2YXIgdG9rZW4gPSB0aGlzLm5leHRUb2tlbigpO1xyXG5cdCAgICAgICAgaWYgKHRva2VuLnR5cGUgIT09IDcgLyogUHVuY3R1YXRvciAqLyB8fCB0b2tlbi52YWx1ZSAhPT0gdmFsdWUpIHtcclxuXHQgICAgICAgICAgICB0aGlzLnRocm93VW5leHBlY3RlZFRva2VuKHRva2VuKTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgfTtcclxuXHQgICAgLy8gUXVpZXRseSBleHBlY3QgYSBjb21tYSB3aGVuIGluIHRvbGVyYW50IG1vZGUsIG90aGVyd2lzZSBkZWxlZ2F0ZXMgdG8gZXhwZWN0KCkuXHJcblx0ICAgIFBhcnNlci5wcm90b3R5cGUuZXhwZWN0Q29tbWFTZXBhcmF0b3IgPSBmdW5jdGlvbiAoKSB7XHJcblx0ICAgICAgICBpZiAodGhpcy5jb25maWcudG9sZXJhbnQpIHtcclxuXHQgICAgICAgICAgICB2YXIgdG9rZW4gPSB0aGlzLmxvb2thaGVhZDtcclxuXHQgICAgICAgICAgICBpZiAodG9rZW4udHlwZSA9PT0gNyAvKiBQdW5jdHVhdG9yICovICYmIHRva2VuLnZhbHVlID09PSAnLCcpIHtcclxuXHQgICAgICAgICAgICAgICAgdGhpcy5uZXh0VG9rZW4oKTtcclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgZWxzZSBpZiAodG9rZW4udHlwZSA9PT0gNyAvKiBQdW5jdHVhdG9yICovICYmIHRva2VuLnZhbHVlID09PSAnOycpIHtcclxuXHQgICAgICAgICAgICAgICAgdGhpcy5uZXh0VG9rZW4oKTtcclxuXHQgICAgICAgICAgICAgICAgdGhpcy50b2xlcmF0ZVVuZXhwZWN0ZWRUb2tlbih0b2tlbik7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgIGVsc2Uge1xyXG5cdCAgICAgICAgICAgICAgICB0aGlzLnRvbGVyYXRlVW5leHBlY3RlZFRva2VuKHRva2VuLCBtZXNzYWdlc18xLk1lc3NhZ2VzLlVuZXhwZWN0ZWRUb2tlbik7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgZWxzZSB7XHJcblx0ICAgICAgICAgICAgdGhpcy5leHBlY3QoJywnKTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgfTtcclxuXHQgICAgLy8gRXhwZWN0IHRoZSBuZXh0IHRva2VuIHRvIG1hdGNoIHRoZSBzcGVjaWZpZWQga2V5d29yZC5cclxuXHQgICAgLy8gSWYgbm90LCBhbiBleGNlcHRpb24gd2lsbCBiZSB0aHJvd24uXHJcblx0ICAgIFBhcnNlci5wcm90b3R5cGUuZXhwZWN0S2V5d29yZCA9IGZ1bmN0aW9uIChrZXl3b3JkKSB7XHJcblx0ICAgICAgICB2YXIgdG9rZW4gPSB0aGlzLm5leHRUb2tlbigpO1xyXG5cdCAgICAgICAgaWYgKHRva2VuLnR5cGUgIT09IDQgLyogS2V5d29yZCAqLyB8fCB0b2tlbi52YWx1ZSAhPT0ga2V5d29yZCkge1xyXG5cdCAgICAgICAgICAgIHRoaXMudGhyb3dVbmV4cGVjdGVkVG9rZW4odG9rZW4pO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICB9O1xyXG5cdCAgICAvLyBSZXR1cm4gdHJ1ZSBpZiB0aGUgbmV4dCB0b2tlbiBtYXRjaGVzIHRoZSBzcGVjaWZpZWQgcHVuY3R1YXRvci5cclxuXHQgICAgUGFyc2VyLnByb3RvdHlwZS5tYXRjaCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xyXG5cdCAgICAgICAgcmV0dXJuIHRoaXMubG9va2FoZWFkLnR5cGUgPT09IDcgLyogUHVuY3R1YXRvciAqLyAmJiB0aGlzLmxvb2thaGVhZC52YWx1ZSA9PT0gdmFsdWU7XHJcblx0ICAgIH07XHJcblx0ICAgIC8vIFJldHVybiB0cnVlIGlmIHRoZSBuZXh0IHRva2VuIG1hdGNoZXMgdGhlIHNwZWNpZmllZCBrZXl3b3JkXHJcblx0ICAgIFBhcnNlci5wcm90b3R5cGUubWF0Y2hLZXl3b3JkID0gZnVuY3Rpb24gKGtleXdvcmQpIHtcclxuXHQgICAgICAgIHJldHVybiB0aGlzLmxvb2thaGVhZC50eXBlID09PSA0IC8qIEtleXdvcmQgKi8gJiYgdGhpcy5sb29rYWhlYWQudmFsdWUgPT09IGtleXdvcmQ7XHJcblx0ICAgIH07XHJcblx0ICAgIC8vIFJldHVybiB0cnVlIGlmIHRoZSBuZXh0IHRva2VuIG1hdGNoZXMgdGhlIHNwZWNpZmllZCBjb250ZXh0dWFsIGtleXdvcmRcclxuXHQgICAgLy8gKHdoZXJlIGFuIGlkZW50aWZpZXIgaXMgc29tZXRpbWVzIGEga2V5d29yZCBkZXBlbmRpbmcgb24gdGhlIGNvbnRleHQpXHJcblx0ICAgIFBhcnNlci5wcm90b3R5cGUubWF0Y2hDb250ZXh0dWFsS2V5d29yZCA9IGZ1bmN0aW9uIChrZXl3b3JkKSB7XHJcblx0ICAgICAgICByZXR1cm4gdGhpcy5sb29rYWhlYWQudHlwZSA9PT0gMyAvKiBJZGVudGlmaWVyICovICYmIHRoaXMubG9va2FoZWFkLnZhbHVlID09PSBrZXl3b3JkO1xyXG5cdCAgICB9O1xyXG5cdCAgICAvLyBSZXR1cm4gdHJ1ZSBpZiB0aGUgbmV4dCB0b2tlbiBpcyBhbiBhc3NpZ25tZW50IG9wZXJhdG9yXHJcblx0ICAgIFBhcnNlci5wcm90b3R5cGUubWF0Y2hBc3NpZ24gPSBmdW5jdGlvbiAoKSB7XHJcblx0ICAgICAgICBpZiAodGhpcy5sb29rYWhlYWQudHlwZSAhPT0gNyAvKiBQdW5jdHVhdG9yICovKSB7XHJcblx0ICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgdmFyIG9wID0gdGhpcy5sb29rYWhlYWQudmFsdWU7XHJcblx0ICAgICAgICByZXR1cm4gb3AgPT09ICc9JyB8fFxyXG5cdCAgICAgICAgICAgIG9wID09PSAnKj0nIHx8XHJcblx0ICAgICAgICAgICAgb3AgPT09ICcqKj0nIHx8XHJcblx0ICAgICAgICAgICAgb3AgPT09ICcvPScgfHxcclxuXHQgICAgICAgICAgICBvcCA9PT0gJyU9JyB8fFxyXG5cdCAgICAgICAgICAgIG9wID09PSAnKz0nIHx8XHJcblx0ICAgICAgICAgICAgb3AgPT09ICctPScgfHxcclxuXHQgICAgICAgICAgICBvcCA9PT0gJzw8PScgfHxcclxuXHQgICAgICAgICAgICBvcCA9PT0gJz4+PScgfHxcclxuXHQgICAgICAgICAgICBvcCA9PT0gJz4+Pj0nIHx8XHJcblx0ICAgICAgICAgICAgb3AgPT09ICcmPScgfHxcclxuXHQgICAgICAgICAgICBvcCA9PT0gJ149JyB8fFxyXG5cdCAgICAgICAgICAgIG9wID09PSAnfD0nO1xyXG5cdCAgICB9O1xyXG5cdCAgICAvLyBDb3ZlciBncmFtbWFyIHN1cHBvcnQuXHJcblx0ICAgIC8vXHJcblx0ICAgIC8vIFdoZW4gYW4gYXNzaWdubWVudCBleHByZXNzaW9uIHBvc2l0aW9uIHN0YXJ0cyB3aXRoIGFuIGxlZnQgcGFyZW50aGVzaXMsIHRoZSBkZXRlcm1pbmF0aW9uIG9mIHRoZSB0eXBlXHJcblx0ICAgIC8vIG9mIHRoZSBzeW50YXggaXMgdG8gYmUgZGVmZXJyZWQgYXJiaXRyYXJpbHkgbG9uZyB1bnRpbCB0aGUgZW5kIG9mIHRoZSBwYXJlbnRoZXNlcyBwYWlyIChwbHVzIGEgbG9va2FoZWFkKVxyXG5cdCAgICAvLyBvciB0aGUgZmlyc3QgY29tbWEuIFRoaXMgc2l0dWF0aW9uIGFsc28gZGVmZXJzIHRoZSBkZXRlcm1pbmF0aW9uIG9mIGFsbCB0aGUgZXhwcmVzc2lvbnMgbmVzdGVkIGluIHRoZSBwYWlyLlxyXG5cdCAgICAvL1xyXG5cdCAgICAvLyBUaGVyZSBhcmUgdGhyZWUgcHJvZHVjdGlvbnMgdGhhdCBjYW4gYmUgcGFyc2VkIGluIGEgcGFyZW50aGVzZXMgcGFpciB0aGF0IG5lZWRzIHRvIGJlIGRldGVybWluZWRcclxuXHQgICAgLy8gYWZ0ZXIgdGhlIG91dGVybW9zdCBwYWlyIGlzIGNsb3NlZC4gVGhleSBhcmU6XHJcblx0ICAgIC8vXHJcblx0ICAgIC8vICAgMS4gQXNzaWdubWVudEV4cHJlc3Npb25cclxuXHQgICAgLy8gICAyLiBCaW5kaW5nRWxlbWVudHNcclxuXHQgICAgLy8gICAzLiBBc3NpZ25tZW50VGFyZ2V0c1xyXG5cdCAgICAvL1xyXG5cdCAgICAvLyBJbiBvcmRlciB0byBhdm9pZCBleHBvbmVudGlhbCBiYWNrdHJhY2tpbmcsIHdlIHVzZSB0d28gZmxhZ3MgdG8gZGVub3RlIGlmIHRoZSBwcm9kdWN0aW9uIGNhbiBiZVxyXG5cdCAgICAvLyBiaW5kaW5nIGVsZW1lbnQgb3IgYXNzaWdubWVudCB0YXJnZXQuXHJcblx0ICAgIC8vXHJcblx0ICAgIC8vIFRoZSB0aHJlZSBwcm9kdWN0aW9ucyBoYXZlIHRoZSByZWxhdGlvbnNoaXA6XHJcblx0ICAgIC8vXHJcblx0ICAgIC8vICAgQmluZGluZ0VsZW1lbnRzIOKKhiBBc3NpZ25tZW50VGFyZ2V0cyDiioYgQXNzaWdubWVudEV4cHJlc3Npb25cclxuXHQgICAgLy9cclxuXHQgICAgLy8gd2l0aCBhIHNpbmdsZSBleGNlcHRpb24gdGhhdCBDb3ZlckluaXRpYWxpemVkTmFtZSB3aGVuIHVzZWQgZGlyZWN0bHkgaW4gYW4gRXhwcmVzc2lvbiwgZ2VuZXJhdGVzXHJcblx0ICAgIC8vIGFuIGVhcmx5IGVycm9yLiBUaGVyZWZvcmUsIHdlIG5lZWQgdGhlIHRoaXJkIHN0YXRlLCBmaXJzdENvdmVySW5pdGlhbGl6ZWROYW1lRXJyb3IsIHRvIHRyYWNrIHRoZVxyXG5cdCAgICAvLyBmaXJzdCB1c2FnZSBvZiBDb3ZlckluaXRpYWxpemVkTmFtZSBhbmQgcmVwb3J0IGl0IHdoZW4gd2UgcmVhY2hlZCB0aGUgZW5kIG9mIHRoZSBwYXJlbnRoZXNlcyBwYWlyLlxyXG5cdCAgICAvL1xyXG5cdCAgICAvLyBpc29sYXRlQ292ZXJHcmFtbWFyIGZ1bmN0aW9uIHJ1bnMgdGhlIGdpdmVuIHBhcnNlciBmdW5jdGlvbiB3aXRoIGEgbmV3IGNvdmVyIGdyYW1tYXIgY29udGV4dCwgYW5kIGl0IGRvZXMgbm90XHJcblx0ICAgIC8vIGVmZmVjdCB0aGUgY3VycmVudCBmbGFncy4gVGhpcyBtZWFucyB0aGUgcHJvZHVjdGlvbiB0aGUgcGFyc2VyIHBhcnNlcyBpcyBvbmx5IHVzZWQgYXMgYW4gZXhwcmVzc2lvbi4gVGhlcmVmb3JlXHJcblx0ICAgIC8vIHRoZSBDb3ZlckluaXRpYWxpemVkTmFtZSBjaGVjayBpcyBjb25kdWN0ZWQuXHJcblx0ICAgIC8vXHJcblx0ICAgIC8vIGluaGVyaXRDb3ZlckdyYW1tYXIgZnVuY3Rpb24gcnVucyB0aGUgZ2l2ZW4gcGFyc2UgZnVuY3Rpb24gd2l0aCBhIG5ldyBjb3ZlciBncmFtbWFyIGNvbnRleHQsIGFuZCBpdCBwcm9wYWdhdGVzXHJcblx0ICAgIC8vIHRoZSBmbGFncyBvdXRzaWRlIG9mIHRoZSBwYXJzZXIuIFRoaXMgbWVhbnMgdGhlIHByb2R1Y3Rpb24gdGhlIHBhcnNlciBwYXJzZXMgaXMgdXNlZCBhcyBhIHBhcnQgb2YgYSBwb3RlbnRpYWxcclxuXHQgICAgLy8gcGF0dGVybi4gVGhlIENvdmVySW5pdGlhbGl6ZWROYW1lIGNoZWNrIGlzIGRlZmVycmVkLlxyXG5cdCAgICBQYXJzZXIucHJvdG90eXBlLmlzb2xhdGVDb3ZlckdyYW1tYXIgPSBmdW5jdGlvbiAocGFyc2VGdW5jdGlvbikge1xyXG5cdCAgICAgICAgdmFyIHByZXZpb3VzSXNCaW5kaW5nRWxlbWVudCA9IHRoaXMuY29udGV4dC5pc0JpbmRpbmdFbGVtZW50O1xyXG5cdCAgICAgICAgdmFyIHByZXZpb3VzSXNBc3NpZ25tZW50VGFyZ2V0ID0gdGhpcy5jb250ZXh0LmlzQXNzaWdubWVudFRhcmdldDtcclxuXHQgICAgICAgIHZhciBwcmV2aW91c0ZpcnN0Q292ZXJJbml0aWFsaXplZE5hbWVFcnJvciA9IHRoaXMuY29udGV4dC5maXJzdENvdmVySW5pdGlhbGl6ZWROYW1lRXJyb3I7XHJcblx0ICAgICAgICB0aGlzLmNvbnRleHQuaXNCaW5kaW5nRWxlbWVudCA9IHRydWU7XHJcblx0ICAgICAgICB0aGlzLmNvbnRleHQuaXNBc3NpZ25tZW50VGFyZ2V0ID0gdHJ1ZTtcclxuXHQgICAgICAgIHRoaXMuY29udGV4dC5maXJzdENvdmVySW5pdGlhbGl6ZWROYW1lRXJyb3IgPSBudWxsO1xyXG5cdCAgICAgICAgdmFyIHJlc3VsdCA9IHBhcnNlRnVuY3Rpb24uY2FsbCh0aGlzKTtcclxuXHQgICAgICAgIGlmICh0aGlzLmNvbnRleHQuZmlyc3RDb3ZlckluaXRpYWxpemVkTmFtZUVycm9yICE9PSBudWxsKSB7XHJcblx0ICAgICAgICAgICAgdGhpcy50aHJvd1VuZXhwZWN0ZWRUb2tlbih0aGlzLmNvbnRleHQuZmlyc3RDb3ZlckluaXRpYWxpemVkTmFtZUVycm9yKTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIHRoaXMuY29udGV4dC5pc0JpbmRpbmdFbGVtZW50ID0gcHJldmlvdXNJc0JpbmRpbmdFbGVtZW50O1xyXG5cdCAgICAgICAgdGhpcy5jb250ZXh0LmlzQXNzaWdubWVudFRhcmdldCA9IHByZXZpb3VzSXNBc3NpZ25tZW50VGFyZ2V0O1xyXG5cdCAgICAgICAgdGhpcy5jb250ZXh0LmZpcnN0Q292ZXJJbml0aWFsaXplZE5hbWVFcnJvciA9IHByZXZpb3VzRmlyc3RDb3ZlckluaXRpYWxpemVkTmFtZUVycm9yO1xyXG5cdCAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuXHQgICAgfTtcclxuXHQgICAgUGFyc2VyLnByb3RvdHlwZS5pbmhlcml0Q292ZXJHcmFtbWFyID0gZnVuY3Rpb24gKHBhcnNlRnVuY3Rpb24pIHtcclxuXHQgICAgICAgIHZhciBwcmV2aW91c0lzQmluZGluZ0VsZW1lbnQgPSB0aGlzLmNvbnRleHQuaXNCaW5kaW5nRWxlbWVudDtcclxuXHQgICAgICAgIHZhciBwcmV2aW91c0lzQXNzaWdubWVudFRhcmdldCA9IHRoaXMuY29udGV4dC5pc0Fzc2lnbm1lbnRUYXJnZXQ7XHJcblx0ICAgICAgICB2YXIgcHJldmlvdXNGaXJzdENvdmVySW5pdGlhbGl6ZWROYW1lRXJyb3IgPSB0aGlzLmNvbnRleHQuZmlyc3RDb3ZlckluaXRpYWxpemVkTmFtZUVycm9yO1xyXG5cdCAgICAgICAgdGhpcy5jb250ZXh0LmlzQmluZGluZ0VsZW1lbnQgPSB0cnVlO1xyXG5cdCAgICAgICAgdGhpcy5jb250ZXh0LmlzQXNzaWdubWVudFRhcmdldCA9IHRydWU7XHJcblx0ICAgICAgICB0aGlzLmNvbnRleHQuZmlyc3RDb3ZlckluaXRpYWxpemVkTmFtZUVycm9yID0gbnVsbDtcclxuXHQgICAgICAgIHZhciByZXN1bHQgPSBwYXJzZUZ1bmN0aW9uLmNhbGwodGhpcyk7XHJcblx0ICAgICAgICB0aGlzLmNvbnRleHQuaXNCaW5kaW5nRWxlbWVudCA9IHRoaXMuY29udGV4dC5pc0JpbmRpbmdFbGVtZW50ICYmIHByZXZpb3VzSXNCaW5kaW5nRWxlbWVudDtcclxuXHQgICAgICAgIHRoaXMuY29udGV4dC5pc0Fzc2lnbm1lbnRUYXJnZXQgPSB0aGlzLmNvbnRleHQuaXNBc3NpZ25tZW50VGFyZ2V0ICYmIHByZXZpb3VzSXNBc3NpZ25tZW50VGFyZ2V0O1xyXG5cdCAgICAgICAgdGhpcy5jb250ZXh0LmZpcnN0Q292ZXJJbml0aWFsaXplZE5hbWVFcnJvciA9IHByZXZpb3VzRmlyc3RDb3ZlckluaXRpYWxpemVkTmFtZUVycm9yIHx8IHRoaXMuY29udGV4dC5maXJzdENvdmVySW5pdGlhbGl6ZWROYW1lRXJyb3I7XHJcblx0ICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG5cdCAgICB9O1xyXG5cdCAgICBQYXJzZXIucHJvdG90eXBlLmNvbnN1bWVTZW1pY29sb24gPSBmdW5jdGlvbiAoKSB7XHJcblx0ICAgICAgICBpZiAodGhpcy5tYXRjaCgnOycpKSB7XHJcblx0ICAgICAgICAgICAgdGhpcy5uZXh0VG9rZW4oKTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIGVsc2UgaWYgKCF0aGlzLmhhc0xpbmVUZXJtaW5hdG9yKSB7XHJcblx0ICAgICAgICAgICAgaWYgKHRoaXMubG9va2FoZWFkLnR5cGUgIT09IDIgLyogRU9GICovICYmICF0aGlzLm1hdGNoKCd9JykpIHtcclxuXHQgICAgICAgICAgICAgICAgdGhpcy50aHJvd1VuZXhwZWN0ZWRUb2tlbih0aGlzLmxvb2thaGVhZCk7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgIHRoaXMubGFzdE1hcmtlci5pbmRleCA9IHRoaXMuc3RhcnRNYXJrZXIuaW5kZXg7XHJcblx0ICAgICAgICAgICAgdGhpcy5sYXN0TWFya2VyLmxpbmUgPSB0aGlzLnN0YXJ0TWFya2VyLmxpbmU7XHJcblx0ICAgICAgICAgICAgdGhpcy5sYXN0TWFya2VyLmNvbHVtbiA9IHRoaXMuc3RhcnRNYXJrZXIuY29sdW1uO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICB9O1xyXG5cdCAgICAvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1wcmltYXJ5LWV4cHJlc3Npb25cclxuXHQgICAgUGFyc2VyLnByb3RvdHlwZS5wYXJzZVByaW1hcnlFeHByZXNzaW9uID0gZnVuY3Rpb24gKCkge1xyXG5cdCAgICAgICAgdmFyIG5vZGUgPSB0aGlzLmNyZWF0ZU5vZGUoKTtcclxuXHQgICAgICAgIHZhciBleHByO1xyXG5cdCAgICAgICAgdmFyIHRva2VuLCByYXc7XHJcblx0ICAgICAgICBzd2l0Y2ggKHRoaXMubG9va2FoZWFkLnR5cGUpIHtcclxuXHQgICAgICAgICAgICBjYXNlIDMgLyogSWRlbnRpZmllciAqLzpcclxuXHQgICAgICAgICAgICAgICAgaWYgKCh0aGlzLmNvbnRleHQuaXNNb2R1bGUgfHwgdGhpcy5jb250ZXh0LmF3YWl0KSAmJiB0aGlzLmxvb2thaGVhZC52YWx1ZSA9PT0gJ2F3YWl0Jykge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgdGhpcy50b2xlcmF0ZVVuZXhwZWN0ZWRUb2tlbih0aGlzLmxvb2thaGVhZCk7XHJcblx0ICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgZXhwciA9IHRoaXMubWF0Y2hBc3luY0Z1bmN0aW9uKCkgPyB0aGlzLnBhcnNlRnVuY3Rpb25FeHByZXNzaW9uKCkgOiB0aGlzLmZpbmFsaXplKG5vZGUsIG5ldyBOb2RlLklkZW50aWZpZXIodGhpcy5uZXh0VG9rZW4oKS52YWx1ZSkpO1xyXG5cdCAgICAgICAgICAgICAgICBicmVhaztcclxuXHQgICAgICAgICAgICBjYXNlIDYgLyogTnVtZXJpY0xpdGVyYWwgKi86XHJcblx0ICAgICAgICAgICAgY2FzZSA4IC8qIFN0cmluZ0xpdGVyYWwgKi86XHJcblx0ICAgICAgICAgICAgICAgIGlmICh0aGlzLmNvbnRleHQuc3RyaWN0ICYmIHRoaXMubG9va2FoZWFkLm9jdGFsKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICB0aGlzLnRvbGVyYXRlVW5leHBlY3RlZFRva2VuKHRoaXMubG9va2FoZWFkLCBtZXNzYWdlc18xLk1lc3NhZ2VzLlN0cmljdE9jdGFsTGl0ZXJhbCk7XHJcblx0ICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgdGhpcy5jb250ZXh0LmlzQXNzaWdubWVudFRhcmdldCA9IGZhbHNlO1xyXG5cdCAgICAgICAgICAgICAgICB0aGlzLmNvbnRleHQuaXNCaW5kaW5nRWxlbWVudCA9IGZhbHNlO1xyXG5cdCAgICAgICAgICAgICAgICB0b2tlbiA9IHRoaXMubmV4dFRva2VuKCk7XHJcblx0ICAgICAgICAgICAgICAgIHJhdyA9IHRoaXMuZ2V0VG9rZW5SYXcodG9rZW4pO1xyXG5cdCAgICAgICAgICAgICAgICBleHByID0gdGhpcy5maW5hbGl6ZShub2RlLCBuZXcgTm9kZS5MaXRlcmFsKHRva2VuLnZhbHVlLCByYXcpKTtcclxuXHQgICAgICAgICAgICAgICAgYnJlYWs7XHJcblx0ICAgICAgICAgICAgY2FzZSAxIC8qIEJvb2xlYW5MaXRlcmFsICovOlxyXG5cdCAgICAgICAgICAgICAgICB0aGlzLmNvbnRleHQuaXNBc3NpZ25tZW50VGFyZ2V0ID0gZmFsc2U7XHJcblx0ICAgICAgICAgICAgICAgIHRoaXMuY29udGV4dC5pc0JpbmRpbmdFbGVtZW50ID0gZmFsc2U7XHJcblx0ICAgICAgICAgICAgICAgIHRva2VuID0gdGhpcy5uZXh0VG9rZW4oKTtcclxuXHQgICAgICAgICAgICAgICAgcmF3ID0gdGhpcy5nZXRUb2tlblJhdyh0b2tlbik7XHJcblx0ICAgICAgICAgICAgICAgIGV4cHIgPSB0aGlzLmZpbmFsaXplKG5vZGUsIG5ldyBOb2RlLkxpdGVyYWwodG9rZW4udmFsdWUgPT09ICd0cnVlJywgcmF3KSk7XHJcblx0ICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cdCAgICAgICAgICAgIGNhc2UgNSAvKiBOdWxsTGl0ZXJhbCAqLzpcclxuXHQgICAgICAgICAgICAgICAgdGhpcy5jb250ZXh0LmlzQXNzaWdubWVudFRhcmdldCA9IGZhbHNlO1xyXG5cdCAgICAgICAgICAgICAgICB0aGlzLmNvbnRleHQuaXNCaW5kaW5nRWxlbWVudCA9IGZhbHNlO1xyXG5cdCAgICAgICAgICAgICAgICB0b2tlbiA9IHRoaXMubmV4dFRva2VuKCk7XHJcblx0ICAgICAgICAgICAgICAgIHJhdyA9IHRoaXMuZ2V0VG9rZW5SYXcodG9rZW4pO1xyXG5cdCAgICAgICAgICAgICAgICBleHByID0gdGhpcy5maW5hbGl6ZShub2RlLCBuZXcgTm9kZS5MaXRlcmFsKG51bGwsIHJhdykpO1xyXG5cdCAgICAgICAgICAgICAgICBicmVhaztcclxuXHQgICAgICAgICAgICBjYXNlIDEwIC8qIFRlbXBsYXRlICovOlxyXG5cdCAgICAgICAgICAgICAgICBleHByID0gdGhpcy5wYXJzZVRlbXBsYXRlTGl0ZXJhbCgpO1xyXG5cdCAgICAgICAgICAgICAgICBicmVhaztcclxuXHQgICAgICAgICAgICBjYXNlIDcgLyogUHVuY3R1YXRvciAqLzpcclxuXHQgICAgICAgICAgICAgICAgc3dpdGNoICh0aGlzLmxvb2thaGVhZC52YWx1ZSkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgY2FzZSAnKCc6XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jb250ZXh0LmlzQmluZGluZ0VsZW1lbnQgPSBmYWxzZTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBleHByID0gdGhpcy5pbmhlcml0Q292ZXJHcmFtbWFyKHRoaXMucGFyc2VHcm91cEV4cHJlc3Npb24pO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgY2FzZSAnWyc6XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgZXhwciA9IHRoaXMuaW5oZXJpdENvdmVyR3JhbW1hcih0aGlzLnBhcnNlQXJyYXlJbml0aWFsaXplcik7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcblx0ICAgICAgICAgICAgICAgICAgICBjYXNlICd7JzpcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBleHByID0gdGhpcy5pbmhlcml0Q292ZXJHcmFtbWFyKHRoaXMucGFyc2VPYmplY3RJbml0aWFsaXplcik7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcblx0ICAgICAgICAgICAgICAgICAgICBjYXNlICcvJzpcclxuXHQgICAgICAgICAgICAgICAgICAgIGNhc2UgJy89JzpcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbnRleHQuaXNBc3NpZ25tZW50VGFyZ2V0ID0gZmFsc2U7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jb250ZXh0LmlzQmluZGluZ0VsZW1lbnQgPSBmYWxzZTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnNjYW5uZXIuaW5kZXggPSB0aGlzLnN0YXJ0TWFya2VyLmluZGV4O1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHRva2VuID0gdGhpcy5uZXh0UmVnZXhUb2tlbigpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJhdyA9IHRoaXMuZ2V0VG9rZW5SYXcodG9rZW4pO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGV4cHIgPSB0aGlzLmZpbmFsaXplKG5vZGUsIG5ldyBOb2RlLlJlZ2V4TGl0ZXJhbCh0b2tlbi5yZWdleCwgcmF3LCB0b2tlbi5wYXR0ZXJuLCB0b2tlbi5mbGFncykpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBleHByID0gdGhpcy50aHJvd1VuZXhwZWN0ZWRUb2tlbih0aGlzLm5leHRUb2tlbigpKTtcclxuXHQgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICBicmVhaztcclxuXHQgICAgICAgICAgICBjYXNlIDQgLyogS2V5d29yZCAqLzpcclxuXHQgICAgICAgICAgICAgICAgaWYgKCF0aGlzLmNvbnRleHQuc3RyaWN0ICYmIHRoaXMuY29udGV4dC5hbGxvd1lpZWxkICYmIHRoaXMubWF0Y2hLZXl3b3JkKCd5aWVsZCcpKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICBleHByID0gdGhpcy5wYXJzZUlkZW50aWZpZXJOYW1lKCk7XHJcblx0ICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgZWxzZSBpZiAoIXRoaXMuY29udGV4dC5zdHJpY3QgJiYgdGhpcy5tYXRjaEtleXdvcmQoJ2xldCcpKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICBleHByID0gdGhpcy5maW5hbGl6ZShub2RlLCBuZXcgTm9kZS5JZGVudGlmaWVyKHRoaXMubmV4dFRva2VuKCkudmFsdWUpKTtcclxuXHQgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICBlbHNlIHtcclxuXHQgICAgICAgICAgICAgICAgICAgIHRoaXMuY29udGV4dC5pc0Fzc2lnbm1lbnRUYXJnZXQgPSBmYWxzZTtcclxuXHQgICAgICAgICAgICAgICAgICAgIHRoaXMuY29udGV4dC5pc0JpbmRpbmdFbGVtZW50ID0gZmFsc2U7XHJcblx0ICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5tYXRjaEtleXdvcmQoJ2Z1bmN0aW9uJykpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBleHByID0gdGhpcy5wYXJzZUZ1bmN0aW9uRXhwcmVzc2lvbigpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5tYXRjaEtleXdvcmQoJ3RoaXMnKSkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubmV4dFRva2VuKCk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgZXhwciA9IHRoaXMuZmluYWxpemUobm9kZSwgbmV3IE5vZGUuVGhpc0V4cHJlc3Npb24oKSk7XHJcblx0ICAgICAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICh0aGlzLm1hdGNoS2V5d29yZCgnY2xhc3MnKSkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGV4cHIgPSB0aGlzLnBhcnNlQ2xhc3NFeHByZXNzaW9uKCk7XHJcblx0ICAgICAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBleHByID0gdGhpcy50aHJvd1VuZXhwZWN0ZWRUb2tlbih0aGlzLm5leHRUb2tlbigpKTtcclxuXHQgICAgICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICBicmVhaztcclxuXHQgICAgICAgICAgICBkZWZhdWx0OlxyXG5cdCAgICAgICAgICAgICAgICBleHByID0gdGhpcy50aHJvd1VuZXhwZWN0ZWRUb2tlbih0aGlzLm5leHRUb2tlbigpKTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIHJldHVybiBleHByO1xyXG5cdCAgICB9O1xyXG5cdCAgICAvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1hcnJheS1pbml0aWFsaXplclxyXG5cdCAgICBQYXJzZXIucHJvdG90eXBlLnBhcnNlU3ByZWFkRWxlbWVudCA9IGZ1bmN0aW9uICgpIHtcclxuXHQgICAgICAgIHZhciBub2RlID0gdGhpcy5jcmVhdGVOb2RlKCk7XHJcblx0ICAgICAgICB0aGlzLmV4cGVjdCgnLi4uJyk7XHJcblx0ICAgICAgICB2YXIgYXJnID0gdGhpcy5pbmhlcml0Q292ZXJHcmFtbWFyKHRoaXMucGFyc2VBc3NpZ25tZW50RXhwcmVzc2lvbik7XHJcblx0ICAgICAgICByZXR1cm4gdGhpcy5maW5hbGl6ZShub2RlLCBuZXcgTm9kZS5TcHJlYWRFbGVtZW50KGFyZykpO1xyXG5cdCAgICB9O1xyXG5cdCAgICBQYXJzZXIucHJvdG90eXBlLnBhcnNlQXJyYXlJbml0aWFsaXplciA9IGZ1bmN0aW9uICgpIHtcclxuXHQgICAgICAgIHZhciBub2RlID0gdGhpcy5jcmVhdGVOb2RlKCk7XHJcblx0ICAgICAgICB2YXIgZWxlbWVudHMgPSBbXTtcclxuXHQgICAgICAgIHRoaXMuZXhwZWN0KCdbJyk7XHJcblx0ICAgICAgICB3aGlsZSAoIXRoaXMubWF0Y2goJ10nKSkge1xyXG5cdCAgICAgICAgICAgIGlmICh0aGlzLm1hdGNoKCcsJykpIHtcclxuXHQgICAgICAgICAgICAgICAgdGhpcy5uZXh0VG9rZW4oKTtcclxuXHQgICAgICAgICAgICAgICAgZWxlbWVudHMucHVzaChudWxsKTtcclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5tYXRjaCgnLi4uJykpIHtcclxuXHQgICAgICAgICAgICAgICAgdmFyIGVsZW1lbnQgPSB0aGlzLnBhcnNlU3ByZWFkRWxlbWVudCgpO1xyXG5cdCAgICAgICAgICAgICAgICBpZiAoIXRoaXMubWF0Y2goJ10nKSkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgdGhpcy5jb250ZXh0LmlzQXNzaWdubWVudFRhcmdldCA9IGZhbHNlO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgdGhpcy5jb250ZXh0LmlzQmluZGluZ0VsZW1lbnQgPSBmYWxzZTtcclxuXHQgICAgICAgICAgICAgICAgICAgIHRoaXMuZXhwZWN0KCcsJyk7XHJcblx0ICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgZWxlbWVudHMucHVzaChlbGVtZW50KTtcclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgZWxzZSB7XHJcblx0ICAgICAgICAgICAgICAgIGVsZW1lbnRzLnB1c2godGhpcy5pbmhlcml0Q292ZXJHcmFtbWFyKHRoaXMucGFyc2VBc3NpZ25tZW50RXhwcmVzc2lvbikpO1xyXG5cdCAgICAgICAgICAgICAgICBpZiAoIXRoaXMubWF0Y2goJ10nKSkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgdGhpcy5leHBlY3QoJywnKTtcclxuXHQgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIHRoaXMuZXhwZWN0KCddJyk7XHJcblx0ICAgICAgICByZXR1cm4gdGhpcy5maW5hbGl6ZShub2RlLCBuZXcgTm9kZS5BcnJheUV4cHJlc3Npb24oZWxlbWVudHMpKTtcclxuXHQgICAgfTtcclxuXHQgICAgLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtb2JqZWN0LWluaXRpYWxpemVyXHJcblx0ICAgIFBhcnNlci5wcm90b3R5cGUucGFyc2VQcm9wZXJ0eU1ldGhvZCA9IGZ1bmN0aW9uIChwYXJhbXMpIHtcclxuXHQgICAgICAgIHRoaXMuY29udGV4dC5pc0Fzc2lnbm1lbnRUYXJnZXQgPSBmYWxzZTtcclxuXHQgICAgICAgIHRoaXMuY29udGV4dC5pc0JpbmRpbmdFbGVtZW50ID0gZmFsc2U7XHJcblx0ICAgICAgICB2YXIgcHJldmlvdXNTdHJpY3QgPSB0aGlzLmNvbnRleHQuc3RyaWN0O1xyXG5cdCAgICAgICAgdmFyIHByZXZpb3VzQWxsb3dTdHJpY3REaXJlY3RpdmUgPSB0aGlzLmNvbnRleHQuYWxsb3dTdHJpY3REaXJlY3RpdmU7XHJcblx0ICAgICAgICB0aGlzLmNvbnRleHQuYWxsb3dTdHJpY3REaXJlY3RpdmUgPSBwYXJhbXMuc2ltcGxlO1xyXG5cdCAgICAgICAgdmFyIGJvZHkgPSB0aGlzLmlzb2xhdGVDb3ZlckdyYW1tYXIodGhpcy5wYXJzZUZ1bmN0aW9uU291cmNlRWxlbWVudHMpO1xyXG5cdCAgICAgICAgaWYgKHRoaXMuY29udGV4dC5zdHJpY3QgJiYgcGFyYW1zLmZpcnN0UmVzdHJpY3RlZCkge1xyXG5cdCAgICAgICAgICAgIHRoaXMudG9sZXJhdGVVbmV4cGVjdGVkVG9rZW4ocGFyYW1zLmZpcnN0UmVzdHJpY3RlZCwgcGFyYW1zLm1lc3NhZ2UpO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgaWYgKHRoaXMuY29udGV4dC5zdHJpY3QgJiYgcGFyYW1zLnN0cmljdGVkKSB7XHJcblx0ICAgICAgICAgICAgdGhpcy50b2xlcmF0ZVVuZXhwZWN0ZWRUb2tlbihwYXJhbXMuc3RyaWN0ZWQsIHBhcmFtcy5tZXNzYWdlKTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIHRoaXMuY29udGV4dC5zdHJpY3QgPSBwcmV2aW91c1N0cmljdDtcclxuXHQgICAgICAgIHRoaXMuY29udGV4dC5hbGxvd1N0cmljdERpcmVjdGl2ZSA9IHByZXZpb3VzQWxsb3dTdHJpY3REaXJlY3RpdmU7XHJcblx0ICAgICAgICByZXR1cm4gYm9keTtcclxuXHQgICAgfTtcclxuXHQgICAgUGFyc2VyLnByb3RvdHlwZS5wYXJzZVByb3BlcnR5TWV0aG9kRnVuY3Rpb24gPSBmdW5jdGlvbiAoKSB7XHJcblx0ICAgICAgICB2YXIgaXNHZW5lcmF0b3IgPSBmYWxzZTtcclxuXHQgICAgICAgIHZhciBub2RlID0gdGhpcy5jcmVhdGVOb2RlKCk7XHJcblx0ICAgICAgICB2YXIgcHJldmlvdXNBbGxvd1lpZWxkID0gdGhpcy5jb250ZXh0LmFsbG93WWllbGQ7XHJcblx0ICAgICAgICB0aGlzLmNvbnRleHQuYWxsb3dZaWVsZCA9IGZhbHNlO1xyXG5cdCAgICAgICAgdmFyIHBhcmFtcyA9IHRoaXMucGFyc2VGb3JtYWxQYXJhbWV0ZXJzKCk7XHJcblx0ICAgICAgICB2YXIgbWV0aG9kID0gdGhpcy5wYXJzZVByb3BlcnR5TWV0aG9kKHBhcmFtcyk7XHJcblx0ICAgICAgICB0aGlzLmNvbnRleHQuYWxsb3dZaWVsZCA9IHByZXZpb3VzQWxsb3dZaWVsZDtcclxuXHQgICAgICAgIHJldHVybiB0aGlzLmZpbmFsaXplKG5vZGUsIG5ldyBOb2RlLkZ1bmN0aW9uRXhwcmVzc2lvbihudWxsLCBwYXJhbXMucGFyYW1zLCBtZXRob2QsIGlzR2VuZXJhdG9yKSk7XHJcblx0ICAgIH07XHJcblx0ICAgIFBhcnNlci5wcm90b3R5cGUucGFyc2VQcm9wZXJ0eU1ldGhvZEFzeW5jRnVuY3Rpb24gPSBmdW5jdGlvbiAoKSB7XHJcblx0ICAgICAgICB2YXIgbm9kZSA9IHRoaXMuY3JlYXRlTm9kZSgpO1xyXG5cdCAgICAgICAgdmFyIHByZXZpb3VzQWxsb3dZaWVsZCA9IHRoaXMuY29udGV4dC5hbGxvd1lpZWxkO1xyXG5cdCAgICAgICAgdmFyIHByZXZpb3VzQXdhaXQgPSB0aGlzLmNvbnRleHQuYXdhaXQ7XHJcblx0ICAgICAgICB0aGlzLmNvbnRleHQuYWxsb3dZaWVsZCA9IGZhbHNlO1xyXG5cdCAgICAgICAgdGhpcy5jb250ZXh0LmF3YWl0ID0gdHJ1ZTtcclxuXHQgICAgICAgIHZhciBwYXJhbXMgPSB0aGlzLnBhcnNlRm9ybWFsUGFyYW1ldGVycygpO1xyXG5cdCAgICAgICAgdmFyIG1ldGhvZCA9IHRoaXMucGFyc2VQcm9wZXJ0eU1ldGhvZChwYXJhbXMpO1xyXG5cdCAgICAgICAgdGhpcy5jb250ZXh0LmFsbG93WWllbGQgPSBwcmV2aW91c0FsbG93WWllbGQ7XHJcblx0ICAgICAgICB0aGlzLmNvbnRleHQuYXdhaXQgPSBwcmV2aW91c0F3YWl0O1xyXG5cdCAgICAgICAgcmV0dXJuIHRoaXMuZmluYWxpemUobm9kZSwgbmV3IE5vZGUuQXN5bmNGdW5jdGlvbkV4cHJlc3Npb24obnVsbCwgcGFyYW1zLnBhcmFtcywgbWV0aG9kKSk7XHJcblx0ICAgIH07XHJcblx0ICAgIFBhcnNlci5wcm90b3R5cGUucGFyc2VPYmplY3RQcm9wZXJ0eUtleSA9IGZ1bmN0aW9uICgpIHtcclxuXHQgICAgICAgIHZhciBub2RlID0gdGhpcy5jcmVhdGVOb2RlKCk7XHJcblx0ICAgICAgICB2YXIgdG9rZW4gPSB0aGlzLm5leHRUb2tlbigpO1xyXG5cdCAgICAgICAgdmFyIGtleTtcclxuXHQgICAgICAgIHN3aXRjaCAodG9rZW4udHlwZSkge1xyXG5cdCAgICAgICAgICAgIGNhc2UgOCAvKiBTdHJpbmdMaXRlcmFsICovOlxyXG5cdCAgICAgICAgICAgIGNhc2UgNiAvKiBOdW1lcmljTGl0ZXJhbCAqLzpcclxuXHQgICAgICAgICAgICAgICAgaWYgKHRoaXMuY29udGV4dC5zdHJpY3QgJiYgdG9rZW4ub2N0YWwpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgIHRoaXMudG9sZXJhdGVVbmV4cGVjdGVkVG9rZW4odG9rZW4sIG1lc3NhZ2VzXzEuTWVzc2FnZXMuU3RyaWN0T2N0YWxMaXRlcmFsKTtcclxuXHQgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICB2YXIgcmF3ID0gdGhpcy5nZXRUb2tlblJhdyh0b2tlbik7XHJcblx0ICAgICAgICAgICAgICAgIGtleSA9IHRoaXMuZmluYWxpemUobm9kZSwgbmV3IE5vZGUuTGl0ZXJhbCh0b2tlbi52YWx1ZSwgcmF3KSk7XHJcblx0ICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cdCAgICAgICAgICAgIGNhc2UgMyAvKiBJZGVudGlmaWVyICovOlxyXG5cdCAgICAgICAgICAgIGNhc2UgMSAvKiBCb29sZWFuTGl0ZXJhbCAqLzpcclxuXHQgICAgICAgICAgICBjYXNlIDUgLyogTnVsbExpdGVyYWwgKi86XHJcblx0ICAgICAgICAgICAgY2FzZSA0IC8qIEtleXdvcmQgKi86XHJcblx0ICAgICAgICAgICAgICAgIGtleSA9IHRoaXMuZmluYWxpemUobm9kZSwgbmV3IE5vZGUuSWRlbnRpZmllcih0b2tlbi52YWx1ZSkpO1xyXG5cdCAgICAgICAgICAgICAgICBicmVhaztcclxuXHQgICAgICAgICAgICBjYXNlIDcgLyogUHVuY3R1YXRvciAqLzpcclxuXHQgICAgICAgICAgICAgICAgaWYgKHRva2VuLnZhbHVlID09PSAnWycpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgIGtleSA9IHRoaXMuaXNvbGF0ZUNvdmVyR3JhbW1hcih0aGlzLnBhcnNlQXNzaWdubWVudEV4cHJlc3Npb24pO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgdGhpcy5leHBlY3QoJ10nKTtcclxuXHQgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICBlbHNlIHtcclxuXHQgICAgICAgICAgICAgICAgICAgIGtleSA9IHRoaXMudGhyb3dVbmV4cGVjdGVkVG9rZW4odG9rZW4pO1xyXG5cdCAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cdCAgICAgICAgICAgIGRlZmF1bHQ6XHJcblx0ICAgICAgICAgICAgICAgIGtleSA9IHRoaXMudGhyb3dVbmV4cGVjdGVkVG9rZW4odG9rZW4pO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgcmV0dXJuIGtleTtcclxuXHQgICAgfTtcclxuXHQgICAgUGFyc2VyLnByb3RvdHlwZS5pc1Byb3BlcnR5S2V5ID0gZnVuY3Rpb24gKGtleSwgdmFsdWUpIHtcclxuXHQgICAgICAgIHJldHVybiAoa2V5LnR5cGUgPT09IHN5bnRheF8xLlN5bnRheC5JZGVudGlmaWVyICYmIGtleS5uYW1lID09PSB2YWx1ZSkgfHxcclxuXHQgICAgICAgICAgICAoa2V5LnR5cGUgPT09IHN5bnRheF8xLlN5bnRheC5MaXRlcmFsICYmIGtleS52YWx1ZSA9PT0gdmFsdWUpO1xyXG5cdCAgICB9O1xyXG5cdCAgICBQYXJzZXIucHJvdG90eXBlLnBhcnNlT2JqZWN0UHJvcGVydHkgPSBmdW5jdGlvbiAoaGFzUHJvdG8pIHtcclxuXHQgICAgICAgIHZhciBub2RlID0gdGhpcy5jcmVhdGVOb2RlKCk7XHJcblx0ICAgICAgICB2YXIgdG9rZW4gPSB0aGlzLmxvb2thaGVhZDtcclxuXHQgICAgICAgIHZhciBraW5kO1xyXG5cdCAgICAgICAgdmFyIGtleSA9IG51bGw7XHJcblx0ICAgICAgICB2YXIgdmFsdWUgPSBudWxsO1xyXG5cdCAgICAgICAgdmFyIGNvbXB1dGVkID0gZmFsc2U7XHJcblx0ICAgICAgICB2YXIgbWV0aG9kID0gZmFsc2U7XHJcblx0ICAgICAgICB2YXIgc2hvcnRoYW5kID0gZmFsc2U7XHJcblx0ICAgICAgICB2YXIgaXNBc3luYyA9IGZhbHNlO1xyXG5cdCAgICAgICAgaWYgKHRva2VuLnR5cGUgPT09IDMgLyogSWRlbnRpZmllciAqLykge1xyXG5cdCAgICAgICAgICAgIHZhciBpZCA9IHRva2VuLnZhbHVlO1xyXG5cdCAgICAgICAgICAgIHRoaXMubmV4dFRva2VuKCk7XHJcblx0ICAgICAgICAgICAgY29tcHV0ZWQgPSB0aGlzLm1hdGNoKCdbJyk7XHJcblx0ICAgICAgICAgICAgaXNBc3luYyA9ICF0aGlzLmhhc0xpbmVUZXJtaW5hdG9yICYmIChpZCA9PT0gJ2FzeW5jJykgJiZcclxuXHQgICAgICAgICAgICAgICAgIXRoaXMubWF0Y2goJzonKSAmJiAhdGhpcy5tYXRjaCgnKCcpICYmICF0aGlzLm1hdGNoKCcqJyk7XHJcblx0ICAgICAgICAgICAga2V5ID0gaXNBc3luYyA/IHRoaXMucGFyc2VPYmplY3RQcm9wZXJ0eUtleSgpIDogdGhpcy5maW5hbGl6ZShub2RlLCBuZXcgTm9kZS5JZGVudGlmaWVyKGlkKSk7XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICBlbHNlIGlmICh0aGlzLm1hdGNoKCcqJykpIHtcclxuXHQgICAgICAgICAgICB0aGlzLm5leHRUb2tlbigpO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgZWxzZSB7XHJcblx0ICAgICAgICAgICAgY29tcHV0ZWQgPSB0aGlzLm1hdGNoKCdbJyk7XHJcblx0ICAgICAgICAgICAga2V5ID0gdGhpcy5wYXJzZU9iamVjdFByb3BlcnR5S2V5KCk7XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICB2YXIgbG9va2FoZWFkUHJvcGVydHlLZXkgPSB0aGlzLnF1YWxpZmllZFByb3BlcnR5TmFtZSh0aGlzLmxvb2thaGVhZCk7XHJcblx0ICAgICAgICBpZiAodG9rZW4udHlwZSA9PT0gMyAvKiBJZGVudGlmaWVyICovICYmICFpc0FzeW5jICYmIHRva2VuLnZhbHVlID09PSAnZ2V0JyAmJiBsb29rYWhlYWRQcm9wZXJ0eUtleSkge1xyXG5cdCAgICAgICAgICAgIGtpbmQgPSAnZ2V0JztcclxuXHQgICAgICAgICAgICBjb21wdXRlZCA9IHRoaXMubWF0Y2goJ1snKTtcclxuXHQgICAgICAgICAgICBrZXkgPSB0aGlzLnBhcnNlT2JqZWN0UHJvcGVydHlLZXkoKTtcclxuXHQgICAgICAgICAgICB0aGlzLmNvbnRleHQuYWxsb3dZaWVsZCA9IGZhbHNlO1xyXG5cdCAgICAgICAgICAgIHZhbHVlID0gdGhpcy5wYXJzZUdldHRlck1ldGhvZCgpO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgZWxzZSBpZiAodG9rZW4udHlwZSA9PT0gMyAvKiBJZGVudGlmaWVyICovICYmICFpc0FzeW5jICYmIHRva2VuLnZhbHVlID09PSAnc2V0JyAmJiBsb29rYWhlYWRQcm9wZXJ0eUtleSkge1xyXG5cdCAgICAgICAgICAgIGtpbmQgPSAnc2V0JztcclxuXHQgICAgICAgICAgICBjb21wdXRlZCA9IHRoaXMubWF0Y2goJ1snKTtcclxuXHQgICAgICAgICAgICBrZXkgPSB0aGlzLnBhcnNlT2JqZWN0UHJvcGVydHlLZXkoKTtcclxuXHQgICAgICAgICAgICB2YWx1ZSA9IHRoaXMucGFyc2VTZXR0ZXJNZXRob2QoKTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIGVsc2UgaWYgKHRva2VuLnR5cGUgPT09IDcgLyogUHVuY3R1YXRvciAqLyAmJiB0b2tlbi52YWx1ZSA9PT0gJyonICYmIGxvb2thaGVhZFByb3BlcnR5S2V5KSB7XHJcblx0ICAgICAgICAgICAga2luZCA9ICdpbml0JztcclxuXHQgICAgICAgICAgICBjb21wdXRlZCA9IHRoaXMubWF0Y2goJ1snKTtcclxuXHQgICAgICAgICAgICBrZXkgPSB0aGlzLnBhcnNlT2JqZWN0UHJvcGVydHlLZXkoKTtcclxuXHQgICAgICAgICAgICB2YWx1ZSA9IHRoaXMucGFyc2VHZW5lcmF0b3JNZXRob2QoKTtcclxuXHQgICAgICAgICAgICBtZXRob2QgPSB0cnVlO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgZWxzZSB7XHJcblx0ICAgICAgICAgICAgaWYgKCFrZXkpIHtcclxuXHQgICAgICAgICAgICAgICAgdGhpcy50aHJvd1VuZXhwZWN0ZWRUb2tlbih0aGlzLmxvb2thaGVhZCk7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgIGtpbmQgPSAnaW5pdCc7XHJcblx0ICAgICAgICAgICAgaWYgKHRoaXMubWF0Y2goJzonKSAmJiAhaXNBc3luYykge1xyXG5cdCAgICAgICAgICAgICAgICBpZiAoIWNvbXB1dGVkICYmIHRoaXMuaXNQcm9wZXJ0eUtleShrZXksICdfX3Byb3RvX18nKSkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKGhhc1Byb3RvLnZhbHVlKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy50b2xlcmF0ZUVycm9yKG1lc3NhZ2VzXzEuTWVzc2FnZXMuRHVwbGljYXRlUHJvdG9Qcm9wZXJ0eSk7XHJcblx0ICAgICAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgICAgICBoYXNQcm90by52YWx1ZSA9IHRydWU7XHJcblx0ICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgdGhpcy5uZXh0VG9rZW4oKTtcclxuXHQgICAgICAgICAgICAgICAgdmFsdWUgPSB0aGlzLmluaGVyaXRDb3ZlckdyYW1tYXIodGhpcy5wYXJzZUFzc2lnbm1lbnRFeHByZXNzaW9uKTtcclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5tYXRjaCgnKCcpKSB7XHJcblx0ICAgICAgICAgICAgICAgIHZhbHVlID0gaXNBc3luYyA/IHRoaXMucGFyc2VQcm9wZXJ0eU1ldGhvZEFzeW5jRnVuY3Rpb24oKSA6IHRoaXMucGFyc2VQcm9wZXJ0eU1ldGhvZEZ1bmN0aW9uKCk7XHJcblx0ICAgICAgICAgICAgICAgIG1ldGhvZCA9IHRydWU7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgIGVsc2UgaWYgKHRva2VuLnR5cGUgPT09IDMgLyogSWRlbnRpZmllciAqLykge1xyXG5cdCAgICAgICAgICAgICAgICB2YXIgaWQgPSB0aGlzLmZpbmFsaXplKG5vZGUsIG5ldyBOb2RlLklkZW50aWZpZXIodG9rZW4udmFsdWUpKTtcclxuXHQgICAgICAgICAgICAgICAgaWYgKHRoaXMubWF0Y2goJz0nKSkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgdGhpcy5jb250ZXh0LmZpcnN0Q292ZXJJbml0aWFsaXplZE5hbWVFcnJvciA9IHRoaXMubG9va2FoZWFkO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgdGhpcy5uZXh0VG9rZW4oKTtcclxuXHQgICAgICAgICAgICAgICAgICAgIHNob3J0aGFuZCA9IHRydWU7XHJcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgaW5pdCA9IHRoaXMuaXNvbGF0ZUNvdmVyR3JhbW1hcih0aGlzLnBhcnNlQXNzaWdubWVudEV4cHJlc3Npb24pO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSB0aGlzLmZpbmFsaXplKG5vZGUsIG5ldyBOb2RlLkFzc2lnbm1lbnRQYXR0ZXJuKGlkLCBpbml0KSk7XHJcblx0ICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgZWxzZSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICBzaG9ydGhhbmQgPSB0cnVlO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBpZDtcclxuXHQgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICBlbHNlIHtcclxuXHQgICAgICAgICAgICAgICAgdGhpcy50aHJvd1VuZXhwZWN0ZWRUb2tlbih0aGlzLm5leHRUb2tlbigpKTtcclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICByZXR1cm4gdGhpcy5maW5hbGl6ZShub2RlLCBuZXcgTm9kZS5Qcm9wZXJ0eShraW5kLCBrZXksIGNvbXB1dGVkLCB2YWx1ZSwgbWV0aG9kLCBzaG9ydGhhbmQpKTtcclxuXHQgICAgfTtcclxuXHQgICAgUGFyc2VyLnByb3RvdHlwZS5wYXJzZU9iamVjdEluaXRpYWxpemVyID0gZnVuY3Rpb24gKCkge1xyXG5cdCAgICAgICAgdmFyIG5vZGUgPSB0aGlzLmNyZWF0ZU5vZGUoKTtcclxuXHQgICAgICAgIHRoaXMuZXhwZWN0KCd7Jyk7XHJcblx0ICAgICAgICB2YXIgcHJvcGVydGllcyA9IFtdO1xyXG5cdCAgICAgICAgdmFyIGhhc1Byb3RvID0geyB2YWx1ZTogZmFsc2UgfTtcclxuXHQgICAgICAgIHdoaWxlICghdGhpcy5tYXRjaCgnfScpKSB7XHJcblx0ICAgICAgICAgICAgcHJvcGVydGllcy5wdXNoKHRoaXMucGFyc2VPYmplY3RQcm9wZXJ0eShoYXNQcm90bykpO1xyXG5cdCAgICAgICAgICAgIGlmICghdGhpcy5tYXRjaCgnfScpKSB7XHJcblx0ICAgICAgICAgICAgICAgIHRoaXMuZXhwZWN0Q29tbWFTZXBhcmF0b3IoKTtcclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICB0aGlzLmV4cGVjdCgnfScpO1xyXG5cdCAgICAgICAgcmV0dXJuIHRoaXMuZmluYWxpemUobm9kZSwgbmV3IE5vZGUuT2JqZWN0RXhwcmVzc2lvbihwcm9wZXJ0aWVzKSk7XHJcblx0ICAgIH07XHJcblx0ICAgIC8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLXRlbXBsYXRlLWxpdGVyYWxzXHJcblx0ICAgIFBhcnNlci5wcm90b3R5cGUucGFyc2VUZW1wbGF0ZUhlYWQgPSBmdW5jdGlvbiAoKSB7XHJcblx0ICAgICAgICBhc3NlcnRfMS5hc3NlcnQodGhpcy5sb29rYWhlYWQuaGVhZCwgJ1RlbXBsYXRlIGxpdGVyYWwgbXVzdCBzdGFydCB3aXRoIGEgdGVtcGxhdGUgaGVhZCcpO1xyXG5cdCAgICAgICAgdmFyIG5vZGUgPSB0aGlzLmNyZWF0ZU5vZGUoKTtcclxuXHQgICAgICAgIHZhciB0b2tlbiA9IHRoaXMubmV4dFRva2VuKCk7XHJcblx0ICAgICAgICB2YXIgcmF3ID0gdG9rZW4udmFsdWU7XHJcblx0ICAgICAgICB2YXIgY29va2VkID0gdG9rZW4uY29va2VkO1xyXG5cdCAgICAgICAgcmV0dXJuIHRoaXMuZmluYWxpemUobm9kZSwgbmV3IE5vZGUuVGVtcGxhdGVFbGVtZW50KHsgcmF3OiByYXcsIGNvb2tlZDogY29va2VkIH0sIHRva2VuLnRhaWwpKTtcclxuXHQgICAgfTtcclxuXHQgICAgUGFyc2VyLnByb3RvdHlwZS5wYXJzZVRlbXBsYXRlRWxlbWVudCA9IGZ1bmN0aW9uICgpIHtcclxuXHQgICAgICAgIGlmICh0aGlzLmxvb2thaGVhZC50eXBlICE9PSAxMCAvKiBUZW1wbGF0ZSAqLykge1xyXG5cdCAgICAgICAgICAgIHRoaXMudGhyb3dVbmV4cGVjdGVkVG9rZW4oKTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIHZhciBub2RlID0gdGhpcy5jcmVhdGVOb2RlKCk7XHJcblx0ICAgICAgICB2YXIgdG9rZW4gPSB0aGlzLm5leHRUb2tlbigpO1xyXG5cdCAgICAgICAgdmFyIHJhdyA9IHRva2VuLnZhbHVlO1xyXG5cdCAgICAgICAgdmFyIGNvb2tlZCA9IHRva2VuLmNvb2tlZDtcclxuXHQgICAgICAgIHJldHVybiB0aGlzLmZpbmFsaXplKG5vZGUsIG5ldyBOb2RlLlRlbXBsYXRlRWxlbWVudCh7IHJhdzogcmF3LCBjb29rZWQ6IGNvb2tlZCB9LCB0b2tlbi50YWlsKSk7XHJcblx0ICAgIH07XHJcblx0ICAgIFBhcnNlci5wcm90b3R5cGUucGFyc2VUZW1wbGF0ZUxpdGVyYWwgPSBmdW5jdGlvbiAoKSB7XHJcblx0ICAgICAgICB2YXIgbm9kZSA9IHRoaXMuY3JlYXRlTm9kZSgpO1xyXG5cdCAgICAgICAgdmFyIGV4cHJlc3Npb25zID0gW107XHJcblx0ICAgICAgICB2YXIgcXVhc2lzID0gW107XHJcblx0ICAgICAgICB2YXIgcXVhc2kgPSB0aGlzLnBhcnNlVGVtcGxhdGVIZWFkKCk7XHJcblx0ICAgICAgICBxdWFzaXMucHVzaChxdWFzaSk7XHJcblx0ICAgICAgICB3aGlsZSAoIXF1YXNpLnRhaWwpIHtcclxuXHQgICAgICAgICAgICBleHByZXNzaW9ucy5wdXNoKHRoaXMucGFyc2VFeHByZXNzaW9uKCkpO1xyXG5cdCAgICAgICAgICAgIHF1YXNpID0gdGhpcy5wYXJzZVRlbXBsYXRlRWxlbWVudCgpO1xyXG5cdCAgICAgICAgICAgIHF1YXNpcy5wdXNoKHF1YXNpKTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIHJldHVybiB0aGlzLmZpbmFsaXplKG5vZGUsIG5ldyBOb2RlLlRlbXBsYXRlTGl0ZXJhbChxdWFzaXMsIGV4cHJlc3Npb25zKSk7XHJcblx0ICAgIH07XHJcblx0ICAgIC8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLWdyb3VwaW5nLW9wZXJhdG9yXHJcblx0ICAgIFBhcnNlci5wcm90b3R5cGUucmVpbnRlcnByZXRFeHByZXNzaW9uQXNQYXR0ZXJuID0gZnVuY3Rpb24gKGV4cHIpIHtcclxuXHQgICAgICAgIHN3aXRjaCAoZXhwci50eXBlKSB7XHJcblx0ICAgICAgICAgICAgY2FzZSBzeW50YXhfMS5TeW50YXguSWRlbnRpZmllcjpcclxuXHQgICAgICAgICAgICBjYXNlIHN5bnRheF8xLlN5bnRheC5NZW1iZXJFeHByZXNzaW9uOlxyXG5cdCAgICAgICAgICAgIGNhc2Ugc3ludGF4XzEuU3ludGF4LlJlc3RFbGVtZW50OlxyXG5cdCAgICAgICAgICAgIGNhc2Ugc3ludGF4XzEuU3ludGF4LkFzc2lnbm1lbnRQYXR0ZXJuOlxyXG5cdCAgICAgICAgICAgICAgICBicmVhaztcclxuXHQgICAgICAgICAgICBjYXNlIHN5bnRheF8xLlN5bnRheC5TcHJlYWRFbGVtZW50OlxyXG5cdCAgICAgICAgICAgICAgICBleHByLnR5cGUgPSBzeW50YXhfMS5TeW50YXguUmVzdEVsZW1lbnQ7XHJcblx0ICAgICAgICAgICAgICAgIHRoaXMucmVpbnRlcnByZXRFeHByZXNzaW9uQXNQYXR0ZXJuKGV4cHIuYXJndW1lbnQpO1xyXG5cdCAgICAgICAgICAgICAgICBicmVhaztcclxuXHQgICAgICAgICAgICBjYXNlIHN5bnRheF8xLlN5bnRheC5BcnJheUV4cHJlc3Npb246XHJcblx0ICAgICAgICAgICAgICAgIGV4cHIudHlwZSA9IHN5bnRheF8xLlN5bnRheC5BcnJheVBhdHRlcm47XHJcblx0ICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZXhwci5lbGVtZW50cy5sZW5ndGg7IGkrKykge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKGV4cHIuZWxlbWVudHNbaV0gIT09IG51bGwpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnJlaW50ZXJwcmV0RXhwcmVzc2lvbkFzUGF0dGVybihleHByLmVsZW1lbnRzW2ldKTtcclxuXHQgICAgICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICBicmVhaztcclxuXHQgICAgICAgICAgICBjYXNlIHN5bnRheF8xLlN5bnRheC5PYmplY3RFeHByZXNzaW9uOlxyXG5cdCAgICAgICAgICAgICAgICBleHByLnR5cGUgPSBzeW50YXhfMS5TeW50YXguT2JqZWN0UGF0dGVybjtcclxuXHQgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBleHByLnByb3BlcnRpZXMubGVuZ3RoOyBpKyspIHtcclxuXHQgICAgICAgICAgICAgICAgICAgIHRoaXMucmVpbnRlcnByZXRFeHByZXNzaW9uQXNQYXR0ZXJuKGV4cHIucHJvcGVydGllc1tpXS52YWx1ZSk7XHJcblx0ICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgYnJlYWs7XHJcblx0ICAgICAgICAgICAgY2FzZSBzeW50YXhfMS5TeW50YXguQXNzaWdubWVudEV4cHJlc3Npb246XHJcblx0ICAgICAgICAgICAgICAgIGV4cHIudHlwZSA9IHN5bnRheF8xLlN5bnRheC5Bc3NpZ25tZW50UGF0dGVybjtcclxuXHQgICAgICAgICAgICAgICAgZGVsZXRlIGV4cHIub3BlcmF0b3I7XHJcblx0ICAgICAgICAgICAgICAgIHRoaXMucmVpbnRlcnByZXRFeHByZXNzaW9uQXNQYXR0ZXJuKGV4cHIubGVmdCk7XHJcblx0ICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cdCAgICAgICAgICAgIGRlZmF1bHQ6XHJcblx0ICAgICAgICAgICAgICAgIC8vIEFsbG93IG90aGVyIG5vZGUgdHlwZSBmb3IgdG9sZXJhbnQgcGFyc2luZy5cclxuXHQgICAgICAgICAgICAgICAgYnJlYWs7XHJcblx0ICAgICAgICB9XHJcblx0ICAgIH07XHJcblx0ICAgIFBhcnNlci5wcm90b3R5cGUucGFyc2VHcm91cEV4cHJlc3Npb24gPSBmdW5jdGlvbiAoKSB7XHJcblx0ICAgICAgICB2YXIgZXhwcjtcclxuXHQgICAgICAgIHRoaXMuZXhwZWN0KCcoJyk7XHJcblx0ICAgICAgICBpZiAodGhpcy5tYXRjaCgnKScpKSB7XHJcblx0ICAgICAgICAgICAgdGhpcy5uZXh0VG9rZW4oKTtcclxuXHQgICAgICAgICAgICBpZiAoIXRoaXMubWF0Y2goJz0+JykpIHtcclxuXHQgICAgICAgICAgICAgICAgdGhpcy5leHBlY3QoJz0+Jyk7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgIGV4cHIgPSB7XHJcblx0ICAgICAgICAgICAgICAgIHR5cGU6IEFycm93UGFyYW1ldGVyUGxhY2VIb2xkZXIsXHJcblx0ICAgICAgICAgICAgICAgIHBhcmFtczogW10sXHJcblx0ICAgICAgICAgICAgICAgIGFzeW5jOiBmYWxzZVxyXG5cdCAgICAgICAgICAgIH07XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICBlbHNlIHtcclxuXHQgICAgICAgICAgICB2YXIgc3RhcnRUb2tlbiA9IHRoaXMubG9va2FoZWFkO1xyXG5cdCAgICAgICAgICAgIHZhciBwYXJhbXMgPSBbXTtcclxuXHQgICAgICAgICAgICBpZiAodGhpcy5tYXRjaCgnLi4uJykpIHtcclxuXHQgICAgICAgICAgICAgICAgZXhwciA9IHRoaXMucGFyc2VSZXN0RWxlbWVudChwYXJhbXMpO1xyXG5cdCAgICAgICAgICAgICAgICB0aGlzLmV4cGVjdCgnKScpO1xyXG5cdCAgICAgICAgICAgICAgICBpZiAoIXRoaXMubWF0Y2goJz0+JykpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgIHRoaXMuZXhwZWN0KCc9PicpO1xyXG5cdCAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgIGV4cHIgPSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICB0eXBlOiBBcnJvd1BhcmFtZXRlclBsYWNlSG9sZGVyLFxyXG5cdCAgICAgICAgICAgICAgICAgICAgcGFyYW1zOiBbZXhwcl0sXHJcblx0ICAgICAgICAgICAgICAgICAgICBhc3luYzogZmFsc2VcclxuXHQgICAgICAgICAgICAgICAgfTtcclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgZWxzZSB7XHJcblx0ICAgICAgICAgICAgICAgIHZhciBhcnJvdyA9IGZhbHNlO1xyXG5cdCAgICAgICAgICAgICAgICB0aGlzLmNvbnRleHQuaXNCaW5kaW5nRWxlbWVudCA9IHRydWU7XHJcblx0ICAgICAgICAgICAgICAgIGV4cHIgPSB0aGlzLmluaGVyaXRDb3ZlckdyYW1tYXIodGhpcy5wYXJzZUFzc2lnbm1lbnRFeHByZXNzaW9uKTtcclxuXHQgICAgICAgICAgICAgICAgaWYgKHRoaXMubWF0Y2goJywnKSkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIGV4cHJlc3Npb25zID0gW107XHJcblx0ICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbnRleHQuaXNBc3NpZ25tZW50VGFyZ2V0ID0gZmFsc2U7XHJcblx0ICAgICAgICAgICAgICAgICAgICBleHByZXNzaW9ucy5wdXNoKGV4cHIpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgd2hpbGUgKHRoaXMubG9va2FoZWFkLnR5cGUgIT09IDIgLyogRU9GICovKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCF0aGlzLm1hdGNoKCcsJykpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubmV4dFRva2VuKCk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMubWF0Y2goJyknKSkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm5leHRUb2tlbigpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGV4cHJlc3Npb25zLmxlbmd0aDsgaSsrKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnJlaW50ZXJwcmV0RXhwcmVzc2lvbkFzUGF0dGVybihleHByZXNzaW9uc1tpXSk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXJyb3cgPSB0cnVlO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBleHByID0ge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogQXJyb3dQYXJhbWV0ZXJQbGFjZUhvbGRlcixcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcmFtczogZXhwcmVzc2lvbnMsXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhc3luYzogZmFsc2VcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgfTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5tYXRjaCgnLi4uJykpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCF0aGlzLmNvbnRleHQuaXNCaW5kaW5nRWxlbWVudCkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy50aHJvd1VuZXhwZWN0ZWRUb2tlbih0aGlzLmxvb2thaGVhZCk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXhwcmVzc2lvbnMucHVzaCh0aGlzLnBhcnNlUmVzdEVsZW1lbnQocGFyYW1zKSk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZXhwZWN0KCcpJyk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghdGhpcy5tYXRjaCgnPT4nKSkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5leHBlY3QoJz0+Jyk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jb250ZXh0LmlzQmluZGluZ0VsZW1lbnQgPSBmYWxzZTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBleHByZXNzaW9ucy5sZW5ndGg7IGkrKykge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5yZWludGVycHJldEV4cHJlc3Npb25Bc1BhdHRlcm4oZXhwcmVzc2lvbnNbaV0pO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFycm93ID0gdHJ1ZTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXhwciA9IHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IEFycm93UGFyYW1ldGVyUGxhY2VIb2xkZXIsXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXJhbXM6IGV4cHJlc3Npb25zLFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXN5bmM6IGZhbHNlXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIH07XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBleHByZXNzaW9ucy5wdXNoKHRoaXMuaW5oZXJpdENvdmVyR3JhbW1hcih0aGlzLnBhcnNlQXNzaWdubWVudEV4cHJlc3Npb24pKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGFycm93KSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgICAgIGlmICghYXJyb3cpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBleHByID0gdGhpcy5maW5hbGl6ZSh0aGlzLnN0YXJ0Tm9kZShzdGFydFRva2VuKSwgbmV3IE5vZGUuU2VxdWVuY2VFeHByZXNzaW9uKGV4cHJlc3Npb25zKSk7XHJcblx0ICAgICAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgaWYgKCFhcnJvdykge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgdGhpcy5leHBlY3QoJyknKTtcclxuXHQgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLm1hdGNoKCc9PicpKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGV4cHIudHlwZSA9PT0gc3ludGF4XzEuU3ludGF4LklkZW50aWZpZXIgJiYgZXhwci5uYW1lID09PSAneWllbGQnKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFycm93ID0gdHJ1ZTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXhwciA9IHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IEFycm93UGFyYW1ldGVyUGxhY2VIb2xkZXIsXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXJhbXM6IFtleHByXSxcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFzeW5jOiBmYWxzZVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWFycm93KSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghdGhpcy5jb250ZXh0LmlzQmluZGluZ0VsZW1lbnQpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMudGhyb3dVbmV4cGVjdGVkVG9rZW4odGhpcy5sb29rYWhlYWQpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChleHByLnR5cGUgPT09IHN5bnRheF8xLlN5bnRheC5TZXF1ZW5jZUV4cHJlc3Npb24pIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZXhwci5leHByZXNzaW9ucy5sZW5ndGg7IGkrKykge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucmVpbnRlcnByZXRFeHByZXNzaW9uQXNQYXR0ZXJuKGV4cHIuZXhwcmVzc2lvbnNbaV0pO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5yZWludGVycHJldEV4cHJlc3Npb25Bc1BhdHRlcm4oZXhwcik7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHBhcmFtZXRlcnMgPSAoZXhwci50eXBlID09PSBzeW50YXhfMS5TeW50YXguU2VxdWVuY2VFeHByZXNzaW9uID8gZXhwci5leHByZXNzaW9ucyA6IFtleHByXSk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV4cHIgPSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBBcnJvd1BhcmFtZXRlclBsYWNlSG9sZGVyLFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFyYW1zOiBwYXJhbWV0ZXJzLFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXN5bmM6IGZhbHNlXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIH07XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICAgICAgdGhpcy5jb250ZXh0LmlzQmluZGluZ0VsZW1lbnQgPSBmYWxzZTtcclxuXHQgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIHJldHVybiBleHByO1xyXG5cdCAgICB9O1xyXG5cdCAgICAvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1sZWZ0LWhhbmQtc2lkZS1leHByZXNzaW9uc1xyXG5cdCAgICBQYXJzZXIucHJvdG90eXBlLnBhcnNlQXJndW1lbnRzID0gZnVuY3Rpb24gKCkge1xyXG5cdCAgICAgICAgdGhpcy5leHBlY3QoJygnKTtcclxuXHQgICAgICAgIHZhciBhcmdzID0gW107XHJcblx0ICAgICAgICBpZiAoIXRoaXMubWF0Y2goJyknKSkge1xyXG5cdCAgICAgICAgICAgIHdoaWxlICh0cnVlKSB7XHJcblx0ICAgICAgICAgICAgICAgIHZhciBleHByID0gdGhpcy5tYXRjaCgnLi4uJykgPyB0aGlzLnBhcnNlU3ByZWFkRWxlbWVudCgpIDpcclxuXHQgICAgICAgICAgICAgICAgICAgIHRoaXMuaXNvbGF0ZUNvdmVyR3JhbW1hcih0aGlzLnBhcnNlQXNzaWdubWVudEV4cHJlc3Npb24pO1xyXG5cdCAgICAgICAgICAgICAgICBhcmdzLnB1c2goZXhwcik7XHJcblx0ICAgICAgICAgICAgICAgIGlmICh0aGlzLm1hdGNoKCcpJykpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cdCAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgIHRoaXMuZXhwZWN0Q29tbWFTZXBhcmF0b3IoKTtcclxuXHQgICAgICAgICAgICAgICAgaWYgKHRoaXMubWF0Y2goJyknKSkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcblx0ICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICB0aGlzLmV4cGVjdCgnKScpO1xyXG5cdCAgICAgICAgcmV0dXJuIGFyZ3M7XHJcblx0ICAgIH07XHJcblx0ICAgIFBhcnNlci5wcm90b3R5cGUuaXNJZGVudGlmaWVyTmFtZSA9IGZ1bmN0aW9uICh0b2tlbikge1xyXG5cdCAgICAgICAgcmV0dXJuIHRva2VuLnR5cGUgPT09IDMgLyogSWRlbnRpZmllciAqLyB8fFxyXG5cdCAgICAgICAgICAgIHRva2VuLnR5cGUgPT09IDQgLyogS2V5d29yZCAqLyB8fFxyXG5cdCAgICAgICAgICAgIHRva2VuLnR5cGUgPT09IDEgLyogQm9vbGVhbkxpdGVyYWwgKi8gfHxcclxuXHQgICAgICAgICAgICB0b2tlbi50eXBlID09PSA1IC8qIE51bGxMaXRlcmFsICovO1xyXG5cdCAgICB9O1xyXG5cdCAgICBQYXJzZXIucHJvdG90eXBlLnBhcnNlSWRlbnRpZmllck5hbWUgPSBmdW5jdGlvbiAoKSB7XHJcblx0ICAgICAgICB2YXIgbm9kZSA9IHRoaXMuY3JlYXRlTm9kZSgpO1xyXG5cdCAgICAgICAgdmFyIHRva2VuID0gdGhpcy5uZXh0VG9rZW4oKTtcclxuXHQgICAgICAgIGlmICghdGhpcy5pc0lkZW50aWZpZXJOYW1lKHRva2VuKSkge1xyXG5cdCAgICAgICAgICAgIHRoaXMudGhyb3dVbmV4cGVjdGVkVG9rZW4odG9rZW4pO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgcmV0dXJuIHRoaXMuZmluYWxpemUobm9kZSwgbmV3IE5vZGUuSWRlbnRpZmllcih0b2tlbi52YWx1ZSkpO1xyXG5cdCAgICB9O1xyXG5cdCAgICBQYXJzZXIucHJvdG90eXBlLnBhcnNlTmV3RXhwcmVzc2lvbiA9IGZ1bmN0aW9uICgpIHtcclxuXHQgICAgICAgIHZhciBub2RlID0gdGhpcy5jcmVhdGVOb2RlKCk7XHJcblx0ICAgICAgICB2YXIgaWQgPSB0aGlzLnBhcnNlSWRlbnRpZmllck5hbWUoKTtcclxuXHQgICAgICAgIGFzc2VydF8xLmFzc2VydChpZC5uYW1lID09PSAnbmV3JywgJ05ldyBleHByZXNzaW9uIG11c3Qgc3RhcnQgd2l0aCBgbmV3YCcpO1xyXG5cdCAgICAgICAgdmFyIGV4cHI7XHJcblx0ICAgICAgICBpZiAodGhpcy5tYXRjaCgnLicpKSB7XHJcblx0ICAgICAgICAgICAgdGhpcy5uZXh0VG9rZW4oKTtcclxuXHQgICAgICAgICAgICBpZiAodGhpcy5sb29rYWhlYWQudHlwZSA9PT0gMyAvKiBJZGVudGlmaWVyICovICYmIHRoaXMuY29udGV4dC5pbkZ1bmN0aW9uQm9keSAmJiB0aGlzLmxvb2thaGVhZC52YWx1ZSA9PT0gJ3RhcmdldCcpIHtcclxuXHQgICAgICAgICAgICAgICAgdmFyIHByb3BlcnR5ID0gdGhpcy5wYXJzZUlkZW50aWZpZXJOYW1lKCk7XHJcblx0ICAgICAgICAgICAgICAgIGV4cHIgPSBuZXcgTm9kZS5NZXRhUHJvcGVydHkoaWQsIHByb3BlcnR5KTtcclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgZWxzZSB7XHJcblx0ICAgICAgICAgICAgICAgIHRoaXMudGhyb3dVbmV4cGVjdGVkVG9rZW4odGhpcy5sb29rYWhlYWQpO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIGVsc2Uge1xyXG5cdCAgICAgICAgICAgIHZhciBjYWxsZWUgPSB0aGlzLmlzb2xhdGVDb3ZlckdyYW1tYXIodGhpcy5wYXJzZUxlZnRIYW5kU2lkZUV4cHJlc3Npb24pO1xyXG5cdCAgICAgICAgICAgIHZhciBhcmdzID0gdGhpcy5tYXRjaCgnKCcpID8gdGhpcy5wYXJzZUFyZ3VtZW50cygpIDogW107XHJcblx0ICAgICAgICAgICAgZXhwciA9IG5ldyBOb2RlLk5ld0V4cHJlc3Npb24oY2FsbGVlLCBhcmdzKTtcclxuXHQgICAgICAgICAgICB0aGlzLmNvbnRleHQuaXNBc3NpZ25tZW50VGFyZ2V0ID0gZmFsc2U7XHJcblx0ICAgICAgICAgICAgdGhpcy5jb250ZXh0LmlzQmluZGluZ0VsZW1lbnQgPSBmYWxzZTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIHJldHVybiB0aGlzLmZpbmFsaXplKG5vZGUsIGV4cHIpO1xyXG5cdCAgICB9O1xyXG5cdCAgICBQYXJzZXIucHJvdG90eXBlLnBhcnNlQXN5bmNBcmd1bWVudCA9IGZ1bmN0aW9uICgpIHtcclxuXHQgICAgICAgIHZhciBhcmcgPSB0aGlzLnBhcnNlQXNzaWdubWVudEV4cHJlc3Npb24oKTtcclxuXHQgICAgICAgIHRoaXMuY29udGV4dC5maXJzdENvdmVySW5pdGlhbGl6ZWROYW1lRXJyb3IgPSBudWxsO1xyXG5cdCAgICAgICAgcmV0dXJuIGFyZztcclxuXHQgICAgfTtcclxuXHQgICAgUGFyc2VyLnByb3RvdHlwZS5wYXJzZUFzeW5jQXJndW1lbnRzID0gZnVuY3Rpb24gKCkge1xyXG5cdCAgICAgICAgdGhpcy5leHBlY3QoJygnKTtcclxuXHQgICAgICAgIHZhciBhcmdzID0gW107XHJcblx0ICAgICAgICBpZiAoIXRoaXMubWF0Y2goJyknKSkge1xyXG5cdCAgICAgICAgICAgIHdoaWxlICh0cnVlKSB7XHJcblx0ICAgICAgICAgICAgICAgIHZhciBleHByID0gdGhpcy5tYXRjaCgnLi4uJykgPyB0aGlzLnBhcnNlU3ByZWFkRWxlbWVudCgpIDpcclxuXHQgICAgICAgICAgICAgICAgICAgIHRoaXMuaXNvbGF0ZUNvdmVyR3JhbW1hcih0aGlzLnBhcnNlQXN5bmNBcmd1bWVudCk7XHJcblx0ICAgICAgICAgICAgICAgIGFyZ3MucHVzaChleHByKTtcclxuXHQgICAgICAgICAgICAgICAgaWYgKHRoaXMubWF0Y2goJyknKSkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcblx0ICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgdGhpcy5leHBlY3RDb21tYVNlcGFyYXRvcigpO1xyXG5cdCAgICAgICAgICAgICAgICBpZiAodGhpcy5tYXRjaCgnKScpKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuXHQgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIHRoaXMuZXhwZWN0KCcpJyk7XHJcblx0ICAgICAgICByZXR1cm4gYXJncztcclxuXHQgICAgfTtcclxuXHQgICAgUGFyc2VyLnByb3RvdHlwZS5wYXJzZUxlZnRIYW5kU2lkZUV4cHJlc3Npb25BbGxvd0NhbGwgPSBmdW5jdGlvbiAoKSB7XHJcblx0ICAgICAgICB2YXIgc3RhcnRUb2tlbiA9IHRoaXMubG9va2FoZWFkO1xyXG5cdCAgICAgICAgdmFyIG1heWJlQXN5bmMgPSB0aGlzLm1hdGNoQ29udGV4dHVhbEtleXdvcmQoJ2FzeW5jJyk7XHJcblx0ICAgICAgICB2YXIgcHJldmlvdXNBbGxvd0luID0gdGhpcy5jb250ZXh0LmFsbG93SW47XHJcblx0ICAgICAgICB0aGlzLmNvbnRleHQuYWxsb3dJbiA9IHRydWU7XHJcblx0ICAgICAgICB2YXIgZXhwcjtcclxuXHQgICAgICAgIGlmICh0aGlzLm1hdGNoS2V5d29yZCgnc3VwZXInKSAmJiB0aGlzLmNvbnRleHQuaW5GdW5jdGlvbkJvZHkpIHtcclxuXHQgICAgICAgICAgICBleHByID0gdGhpcy5jcmVhdGVOb2RlKCk7XHJcblx0ICAgICAgICAgICAgdGhpcy5uZXh0VG9rZW4oKTtcclxuXHQgICAgICAgICAgICBleHByID0gdGhpcy5maW5hbGl6ZShleHByLCBuZXcgTm9kZS5TdXBlcigpKTtcclxuXHQgICAgICAgICAgICBpZiAoIXRoaXMubWF0Y2goJygnKSAmJiAhdGhpcy5tYXRjaCgnLicpICYmICF0aGlzLm1hdGNoKCdbJykpIHtcclxuXHQgICAgICAgICAgICAgICAgdGhpcy50aHJvd1VuZXhwZWN0ZWRUb2tlbih0aGlzLmxvb2thaGVhZCk7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgZWxzZSB7XHJcblx0ICAgICAgICAgICAgZXhwciA9IHRoaXMuaW5oZXJpdENvdmVyR3JhbW1hcih0aGlzLm1hdGNoS2V5d29yZCgnbmV3JykgPyB0aGlzLnBhcnNlTmV3RXhwcmVzc2lvbiA6IHRoaXMucGFyc2VQcmltYXJ5RXhwcmVzc2lvbik7XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICB3aGlsZSAodHJ1ZSkge1xyXG5cdCAgICAgICAgICAgIGlmICh0aGlzLm1hdGNoKCcuJykpIHtcclxuXHQgICAgICAgICAgICAgICAgdGhpcy5jb250ZXh0LmlzQmluZGluZ0VsZW1lbnQgPSBmYWxzZTtcclxuXHQgICAgICAgICAgICAgICAgdGhpcy5jb250ZXh0LmlzQXNzaWdubWVudFRhcmdldCA9IHRydWU7XHJcblx0ICAgICAgICAgICAgICAgIHRoaXMuZXhwZWN0KCcuJyk7XHJcblx0ICAgICAgICAgICAgICAgIHZhciBwcm9wZXJ0eSA9IHRoaXMucGFyc2VJZGVudGlmaWVyTmFtZSgpO1xyXG5cdCAgICAgICAgICAgICAgICBleHByID0gdGhpcy5maW5hbGl6ZSh0aGlzLnN0YXJ0Tm9kZShzdGFydFRva2VuKSwgbmV3IE5vZGUuU3RhdGljTWVtYmVyRXhwcmVzc2lvbihleHByLCBwcm9wZXJ0eSkpO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICBlbHNlIGlmICh0aGlzLm1hdGNoKCcoJykpIHtcclxuXHQgICAgICAgICAgICAgICAgdmFyIGFzeW5jQXJyb3cgPSBtYXliZUFzeW5jICYmIChzdGFydFRva2VuLmxpbmVOdW1iZXIgPT09IHRoaXMubG9va2FoZWFkLmxpbmVOdW1iZXIpO1xyXG5cdCAgICAgICAgICAgICAgICB0aGlzLmNvbnRleHQuaXNCaW5kaW5nRWxlbWVudCA9IGZhbHNlO1xyXG5cdCAgICAgICAgICAgICAgICB0aGlzLmNvbnRleHQuaXNBc3NpZ25tZW50VGFyZ2V0ID0gZmFsc2U7XHJcblx0ICAgICAgICAgICAgICAgIHZhciBhcmdzID0gYXN5bmNBcnJvdyA/IHRoaXMucGFyc2VBc3luY0FyZ3VtZW50cygpIDogdGhpcy5wYXJzZUFyZ3VtZW50cygpO1xyXG5cdCAgICAgICAgICAgICAgICBleHByID0gdGhpcy5maW5hbGl6ZSh0aGlzLnN0YXJ0Tm9kZShzdGFydFRva2VuKSwgbmV3IE5vZGUuQ2FsbEV4cHJlc3Npb24oZXhwciwgYXJncykpO1xyXG5cdCAgICAgICAgICAgICAgICBpZiAoYXN5bmNBcnJvdyAmJiB0aGlzLm1hdGNoKCc9PicpKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFyZ3MubGVuZ3RoOyArK2kpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnJlaW50ZXJwcmV0RXhwcmVzc2lvbkFzUGF0dGVybihhcmdzW2ldKTtcclxuXHQgICAgICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgICAgIGV4cHIgPSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogQXJyb3dQYXJhbWV0ZXJQbGFjZUhvbGRlcixcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBwYXJhbXM6IGFyZ3MsXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgYXN5bmM6IHRydWVcclxuXHQgICAgICAgICAgICAgICAgICAgIH07XHJcblx0ICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5tYXRjaCgnWycpKSB7XHJcblx0ICAgICAgICAgICAgICAgIHRoaXMuY29udGV4dC5pc0JpbmRpbmdFbGVtZW50ID0gZmFsc2U7XHJcblx0ICAgICAgICAgICAgICAgIHRoaXMuY29udGV4dC5pc0Fzc2lnbm1lbnRUYXJnZXQgPSB0cnVlO1xyXG5cdCAgICAgICAgICAgICAgICB0aGlzLmV4cGVjdCgnWycpO1xyXG5cdCAgICAgICAgICAgICAgICB2YXIgcHJvcGVydHkgPSB0aGlzLmlzb2xhdGVDb3ZlckdyYW1tYXIodGhpcy5wYXJzZUV4cHJlc3Npb24pO1xyXG5cdCAgICAgICAgICAgICAgICB0aGlzLmV4cGVjdCgnXScpO1xyXG5cdCAgICAgICAgICAgICAgICBleHByID0gdGhpcy5maW5hbGl6ZSh0aGlzLnN0YXJ0Tm9kZShzdGFydFRva2VuKSwgbmV3IE5vZGUuQ29tcHV0ZWRNZW1iZXJFeHByZXNzaW9uKGV4cHIsIHByb3BlcnR5KSk7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMubG9va2FoZWFkLnR5cGUgPT09IDEwIC8qIFRlbXBsYXRlICovICYmIHRoaXMubG9va2FoZWFkLmhlYWQpIHtcclxuXHQgICAgICAgICAgICAgICAgdmFyIHF1YXNpID0gdGhpcy5wYXJzZVRlbXBsYXRlTGl0ZXJhbCgpO1xyXG5cdCAgICAgICAgICAgICAgICBleHByID0gdGhpcy5maW5hbGl6ZSh0aGlzLnN0YXJ0Tm9kZShzdGFydFRva2VuKSwgbmV3IE5vZGUuVGFnZ2VkVGVtcGxhdGVFeHByZXNzaW9uKGV4cHIsIHF1YXNpKSk7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgIGVsc2Uge1xyXG5cdCAgICAgICAgICAgICAgICBicmVhaztcclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICB0aGlzLmNvbnRleHQuYWxsb3dJbiA9IHByZXZpb3VzQWxsb3dJbjtcclxuXHQgICAgICAgIHJldHVybiBleHByO1xyXG5cdCAgICB9O1xyXG5cdCAgICBQYXJzZXIucHJvdG90eXBlLnBhcnNlU3VwZXIgPSBmdW5jdGlvbiAoKSB7XHJcblx0ICAgICAgICB2YXIgbm9kZSA9IHRoaXMuY3JlYXRlTm9kZSgpO1xyXG5cdCAgICAgICAgdGhpcy5leHBlY3RLZXl3b3JkKCdzdXBlcicpO1xyXG5cdCAgICAgICAgaWYgKCF0aGlzLm1hdGNoKCdbJykgJiYgIXRoaXMubWF0Y2goJy4nKSkge1xyXG5cdCAgICAgICAgICAgIHRoaXMudGhyb3dVbmV4cGVjdGVkVG9rZW4odGhpcy5sb29rYWhlYWQpO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgcmV0dXJuIHRoaXMuZmluYWxpemUobm9kZSwgbmV3IE5vZGUuU3VwZXIoKSk7XHJcblx0ICAgIH07XHJcblx0ICAgIFBhcnNlci5wcm90b3R5cGUucGFyc2VMZWZ0SGFuZFNpZGVFeHByZXNzaW9uID0gZnVuY3Rpb24gKCkge1xyXG5cdCAgICAgICAgYXNzZXJ0XzEuYXNzZXJ0KHRoaXMuY29udGV4dC5hbGxvd0luLCAnY2FsbGVlIG9mIG5ldyBleHByZXNzaW9uIGFsd2F5cyBhbGxvdyBpbiBrZXl3b3JkLicpO1xyXG5cdCAgICAgICAgdmFyIG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZSh0aGlzLmxvb2thaGVhZCk7XHJcblx0ICAgICAgICB2YXIgZXhwciA9ICh0aGlzLm1hdGNoS2V5d29yZCgnc3VwZXInKSAmJiB0aGlzLmNvbnRleHQuaW5GdW5jdGlvbkJvZHkpID8gdGhpcy5wYXJzZVN1cGVyKCkgOlxyXG5cdCAgICAgICAgICAgIHRoaXMuaW5oZXJpdENvdmVyR3JhbW1hcih0aGlzLm1hdGNoS2V5d29yZCgnbmV3JykgPyB0aGlzLnBhcnNlTmV3RXhwcmVzc2lvbiA6IHRoaXMucGFyc2VQcmltYXJ5RXhwcmVzc2lvbik7XHJcblx0ICAgICAgICB3aGlsZSAodHJ1ZSkge1xyXG5cdCAgICAgICAgICAgIGlmICh0aGlzLm1hdGNoKCdbJykpIHtcclxuXHQgICAgICAgICAgICAgICAgdGhpcy5jb250ZXh0LmlzQmluZGluZ0VsZW1lbnQgPSBmYWxzZTtcclxuXHQgICAgICAgICAgICAgICAgdGhpcy5jb250ZXh0LmlzQXNzaWdubWVudFRhcmdldCA9IHRydWU7XHJcblx0ICAgICAgICAgICAgICAgIHRoaXMuZXhwZWN0KCdbJyk7XHJcblx0ICAgICAgICAgICAgICAgIHZhciBwcm9wZXJ0eSA9IHRoaXMuaXNvbGF0ZUNvdmVyR3JhbW1hcih0aGlzLnBhcnNlRXhwcmVzc2lvbik7XHJcblx0ICAgICAgICAgICAgICAgIHRoaXMuZXhwZWN0KCddJyk7XHJcblx0ICAgICAgICAgICAgICAgIGV4cHIgPSB0aGlzLmZpbmFsaXplKG5vZGUsIG5ldyBOb2RlLkNvbXB1dGVkTWVtYmVyRXhwcmVzc2lvbihleHByLCBwcm9wZXJ0eSkpO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICBlbHNlIGlmICh0aGlzLm1hdGNoKCcuJykpIHtcclxuXHQgICAgICAgICAgICAgICAgdGhpcy5jb250ZXh0LmlzQmluZGluZ0VsZW1lbnQgPSBmYWxzZTtcclxuXHQgICAgICAgICAgICAgICAgdGhpcy5jb250ZXh0LmlzQXNzaWdubWVudFRhcmdldCA9IHRydWU7XHJcblx0ICAgICAgICAgICAgICAgIHRoaXMuZXhwZWN0KCcuJyk7XHJcblx0ICAgICAgICAgICAgICAgIHZhciBwcm9wZXJ0eSA9IHRoaXMucGFyc2VJZGVudGlmaWVyTmFtZSgpO1xyXG5cdCAgICAgICAgICAgICAgICBleHByID0gdGhpcy5maW5hbGl6ZShub2RlLCBuZXcgTm9kZS5TdGF0aWNNZW1iZXJFeHByZXNzaW9uKGV4cHIsIHByb3BlcnR5KSk7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMubG9va2FoZWFkLnR5cGUgPT09IDEwIC8qIFRlbXBsYXRlICovICYmIHRoaXMubG9va2FoZWFkLmhlYWQpIHtcclxuXHQgICAgICAgICAgICAgICAgdmFyIHF1YXNpID0gdGhpcy5wYXJzZVRlbXBsYXRlTGl0ZXJhbCgpO1xyXG5cdCAgICAgICAgICAgICAgICBleHByID0gdGhpcy5maW5hbGl6ZShub2RlLCBuZXcgTm9kZS5UYWdnZWRUZW1wbGF0ZUV4cHJlc3Npb24oZXhwciwgcXVhc2kpKTtcclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgZWxzZSB7XHJcblx0ICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIHJldHVybiBleHByO1xyXG5cdCAgICB9O1xyXG5cdCAgICAvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy11cGRhdGUtZXhwcmVzc2lvbnNcclxuXHQgICAgUGFyc2VyLnByb3RvdHlwZS5wYXJzZVVwZGF0ZUV4cHJlc3Npb24gPSBmdW5jdGlvbiAoKSB7XHJcblx0ICAgICAgICB2YXIgZXhwcjtcclxuXHQgICAgICAgIHZhciBzdGFydFRva2VuID0gdGhpcy5sb29rYWhlYWQ7XHJcblx0ICAgICAgICBpZiAodGhpcy5tYXRjaCgnKysnKSB8fCB0aGlzLm1hdGNoKCctLScpKSB7XHJcblx0ICAgICAgICAgICAgdmFyIG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZShzdGFydFRva2VuKTtcclxuXHQgICAgICAgICAgICB2YXIgdG9rZW4gPSB0aGlzLm5leHRUb2tlbigpO1xyXG5cdCAgICAgICAgICAgIGV4cHIgPSB0aGlzLmluaGVyaXRDb3ZlckdyYW1tYXIodGhpcy5wYXJzZVVuYXJ5RXhwcmVzc2lvbik7XHJcblx0ICAgICAgICAgICAgaWYgKHRoaXMuY29udGV4dC5zdHJpY3QgJiYgZXhwci50eXBlID09PSBzeW50YXhfMS5TeW50YXguSWRlbnRpZmllciAmJiB0aGlzLnNjYW5uZXIuaXNSZXN0cmljdGVkV29yZChleHByLm5hbWUpKSB7XHJcblx0ICAgICAgICAgICAgICAgIHRoaXMudG9sZXJhdGVFcnJvcihtZXNzYWdlc18xLk1lc3NhZ2VzLlN0cmljdExIU1ByZWZpeCk7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgIGlmICghdGhpcy5jb250ZXh0LmlzQXNzaWdubWVudFRhcmdldCkge1xyXG5cdCAgICAgICAgICAgICAgICB0aGlzLnRvbGVyYXRlRXJyb3IobWVzc2FnZXNfMS5NZXNzYWdlcy5JbnZhbGlkTEhTSW5Bc3NpZ25tZW50KTtcclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgdmFyIHByZWZpeCA9IHRydWU7XHJcblx0ICAgICAgICAgICAgZXhwciA9IHRoaXMuZmluYWxpemUobm9kZSwgbmV3IE5vZGUuVXBkYXRlRXhwcmVzc2lvbih0b2tlbi52YWx1ZSwgZXhwciwgcHJlZml4KSk7XHJcblx0ICAgICAgICAgICAgdGhpcy5jb250ZXh0LmlzQXNzaWdubWVudFRhcmdldCA9IGZhbHNlO1xyXG5cdCAgICAgICAgICAgIHRoaXMuY29udGV4dC5pc0JpbmRpbmdFbGVtZW50ID0gZmFsc2U7XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICBlbHNlIHtcclxuXHQgICAgICAgICAgICBleHByID0gdGhpcy5pbmhlcml0Q292ZXJHcmFtbWFyKHRoaXMucGFyc2VMZWZ0SGFuZFNpZGVFeHByZXNzaW9uQWxsb3dDYWxsKTtcclxuXHQgICAgICAgICAgICBpZiAoIXRoaXMuaGFzTGluZVRlcm1pbmF0b3IgJiYgdGhpcy5sb29rYWhlYWQudHlwZSA9PT0gNyAvKiBQdW5jdHVhdG9yICovKSB7XHJcblx0ICAgICAgICAgICAgICAgIGlmICh0aGlzLm1hdGNoKCcrKycpIHx8IHRoaXMubWF0Y2goJy0tJykpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmNvbnRleHQuc3RyaWN0ICYmIGV4cHIudHlwZSA9PT0gc3ludGF4XzEuU3ludGF4LklkZW50aWZpZXIgJiYgdGhpcy5zY2FubmVyLmlzUmVzdHJpY3RlZFdvcmQoZXhwci5uYW1lKSkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMudG9sZXJhdGVFcnJvcihtZXNzYWdlc18xLk1lc3NhZ2VzLlN0cmljdExIU1Bvc3RmaXgpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKCF0aGlzLmNvbnRleHQuaXNBc3NpZ25tZW50VGFyZ2V0KSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy50b2xlcmF0ZUVycm9yKG1lc3NhZ2VzXzEuTWVzc2FnZXMuSW52YWxpZExIU0luQXNzaWdubWVudCk7XHJcblx0ICAgICAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbnRleHQuaXNBc3NpZ25tZW50VGFyZ2V0ID0gZmFsc2U7XHJcblx0ICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbnRleHQuaXNCaW5kaW5nRWxlbWVudCA9IGZhbHNlO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIG9wZXJhdG9yID0gdGhpcy5uZXh0VG9rZW4oKS52YWx1ZTtcclxuXHQgICAgICAgICAgICAgICAgICAgIHZhciBwcmVmaXggPSBmYWxzZTtcclxuXHQgICAgICAgICAgICAgICAgICAgIGV4cHIgPSB0aGlzLmZpbmFsaXplKHRoaXMuc3RhcnROb2RlKHN0YXJ0VG9rZW4pLCBuZXcgTm9kZS5VcGRhdGVFeHByZXNzaW9uKG9wZXJhdG9yLCBleHByLCBwcmVmaXgpKTtcclxuXHQgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIHJldHVybiBleHByO1xyXG5cdCAgICB9O1xyXG5cdCAgICAvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy11bmFyeS1vcGVyYXRvcnNcclxuXHQgICAgUGFyc2VyLnByb3RvdHlwZS5wYXJzZUF3YWl0RXhwcmVzc2lvbiA9IGZ1bmN0aW9uICgpIHtcclxuXHQgICAgICAgIHZhciBub2RlID0gdGhpcy5jcmVhdGVOb2RlKCk7XHJcblx0ICAgICAgICB0aGlzLm5leHRUb2tlbigpO1xyXG5cdCAgICAgICAgdmFyIGFyZ3VtZW50ID0gdGhpcy5wYXJzZVVuYXJ5RXhwcmVzc2lvbigpO1xyXG5cdCAgICAgICAgcmV0dXJuIHRoaXMuZmluYWxpemUobm9kZSwgbmV3IE5vZGUuQXdhaXRFeHByZXNzaW9uKGFyZ3VtZW50KSk7XHJcblx0ICAgIH07XHJcblx0ICAgIFBhcnNlci5wcm90b3R5cGUucGFyc2VVbmFyeUV4cHJlc3Npb24gPSBmdW5jdGlvbiAoKSB7XHJcblx0ICAgICAgICB2YXIgZXhwcjtcclxuXHQgICAgICAgIGlmICh0aGlzLm1hdGNoKCcrJykgfHwgdGhpcy5tYXRjaCgnLScpIHx8IHRoaXMubWF0Y2goJ34nKSB8fCB0aGlzLm1hdGNoKCchJykgfHxcclxuXHQgICAgICAgICAgICB0aGlzLm1hdGNoS2V5d29yZCgnZGVsZXRlJykgfHwgdGhpcy5tYXRjaEtleXdvcmQoJ3ZvaWQnKSB8fCB0aGlzLm1hdGNoS2V5d29yZCgndHlwZW9mJykpIHtcclxuXHQgICAgICAgICAgICB2YXIgbm9kZSA9IHRoaXMuc3RhcnROb2RlKHRoaXMubG9va2FoZWFkKTtcclxuXHQgICAgICAgICAgICB2YXIgdG9rZW4gPSB0aGlzLm5leHRUb2tlbigpO1xyXG5cdCAgICAgICAgICAgIGV4cHIgPSB0aGlzLmluaGVyaXRDb3ZlckdyYW1tYXIodGhpcy5wYXJzZVVuYXJ5RXhwcmVzc2lvbik7XHJcblx0ICAgICAgICAgICAgZXhwciA9IHRoaXMuZmluYWxpemUobm9kZSwgbmV3IE5vZGUuVW5hcnlFeHByZXNzaW9uKHRva2VuLnZhbHVlLCBleHByKSk7XHJcblx0ICAgICAgICAgICAgaWYgKHRoaXMuY29udGV4dC5zdHJpY3QgJiYgZXhwci5vcGVyYXRvciA9PT0gJ2RlbGV0ZScgJiYgZXhwci5hcmd1bWVudC50eXBlID09PSBzeW50YXhfMS5TeW50YXguSWRlbnRpZmllcikge1xyXG5cdCAgICAgICAgICAgICAgICB0aGlzLnRvbGVyYXRlRXJyb3IobWVzc2FnZXNfMS5NZXNzYWdlcy5TdHJpY3REZWxldGUpO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICB0aGlzLmNvbnRleHQuaXNBc3NpZ25tZW50VGFyZ2V0ID0gZmFsc2U7XHJcblx0ICAgICAgICAgICAgdGhpcy5jb250ZXh0LmlzQmluZGluZ0VsZW1lbnQgPSBmYWxzZTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIGVsc2UgaWYgKHRoaXMuY29udGV4dC5hd2FpdCAmJiB0aGlzLm1hdGNoQ29udGV4dHVhbEtleXdvcmQoJ2F3YWl0JykpIHtcclxuXHQgICAgICAgICAgICBleHByID0gdGhpcy5wYXJzZUF3YWl0RXhwcmVzc2lvbigpO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgZWxzZSB7XHJcblx0ICAgICAgICAgICAgZXhwciA9IHRoaXMucGFyc2VVcGRhdGVFeHByZXNzaW9uKCk7XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICByZXR1cm4gZXhwcjtcclxuXHQgICAgfTtcclxuXHQgICAgUGFyc2VyLnByb3RvdHlwZS5wYXJzZUV4cG9uZW50aWF0aW9uRXhwcmVzc2lvbiA9IGZ1bmN0aW9uICgpIHtcclxuXHQgICAgICAgIHZhciBzdGFydFRva2VuID0gdGhpcy5sb29rYWhlYWQ7XHJcblx0ICAgICAgICB2YXIgZXhwciA9IHRoaXMuaW5oZXJpdENvdmVyR3JhbW1hcih0aGlzLnBhcnNlVW5hcnlFeHByZXNzaW9uKTtcclxuXHQgICAgICAgIGlmIChleHByLnR5cGUgIT09IHN5bnRheF8xLlN5bnRheC5VbmFyeUV4cHJlc3Npb24gJiYgdGhpcy5tYXRjaCgnKionKSkge1xyXG5cdCAgICAgICAgICAgIHRoaXMubmV4dFRva2VuKCk7XHJcblx0ICAgICAgICAgICAgdGhpcy5jb250ZXh0LmlzQXNzaWdubWVudFRhcmdldCA9IGZhbHNlO1xyXG5cdCAgICAgICAgICAgIHRoaXMuY29udGV4dC5pc0JpbmRpbmdFbGVtZW50ID0gZmFsc2U7XHJcblx0ICAgICAgICAgICAgdmFyIGxlZnQgPSBleHByO1xyXG5cdCAgICAgICAgICAgIHZhciByaWdodCA9IHRoaXMuaXNvbGF0ZUNvdmVyR3JhbW1hcih0aGlzLnBhcnNlRXhwb25lbnRpYXRpb25FeHByZXNzaW9uKTtcclxuXHQgICAgICAgICAgICBleHByID0gdGhpcy5maW5hbGl6ZSh0aGlzLnN0YXJ0Tm9kZShzdGFydFRva2VuKSwgbmV3IE5vZGUuQmluYXJ5RXhwcmVzc2lvbignKionLCBsZWZ0LCByaWdodCkpO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgcmV0dXJuIGV4cHI7XHJcblx0ICAgIH07XHJcblx0ICAgIC8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLWV4cC1vcGVyYXRvclxyXG5cdCAgICAvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1tdWx0aXBsaWNhdGl2ZS1vcGVyYXRvcnNcclxuXHQgICAgLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtYWRkaXRpdmUtb3BlcmF0b3JzXHJcblx0ICAgIC8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLWJpdHdpc2Utc2hpZnQtb3BlcmF0b3JzXHJcblx0ICAgIC8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLXJlbGF0aW9uYWwtb3BlcmF0b3JzXHJcblx0ICAgIC8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLWVxdWFsaXR5LW9wZXJhdG9yc1xyXG5cdCAgICAvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1iaW5hcnktYml0d2lzZS1vcGVyYXRvcnNcclxuXHQgICAgLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtYmluYXJ5LWxvZ2ljYWwtb3BlcmF0b3JzXHJcblx0ICAgIFBhcnNlci5wcm90b3R5cGUuYmluYXJ5UHJlY2VkZW5jZSA9IGZ1bmN0aW9uICh0b2tlbikge1xyXG5cdCAgICAgICAgdmFyIG9wID0gdG9rZW4udmFsdWU7XHJcblx0ICAgICAgICB2YXIgcHJlY2VkZW5jZTtcclxuXHQgICAgICAgIGlmICh0b2tlbi50eXBlID09PSA3IC8qIFB1bmN0dWF0b3IgKi8pIHtcclxuXHQgICAgICAgICAgICBwcmVjZWRlbmNlID0gdGhpcy5vcGVyYXRvclByZWNlZGVuY2Vbb3BdIHx8IDA7XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICBlbHNlIGlmICh0b2tlbi50eXBlID09PSA0IC8qIEtleXdvcmQgKi8pIHtcclxuXHQgICAgICAgICAgICBwcmVjZWRlbmNlID0gKG9wID09PSAnaW5zdGFuY2VvZicgfHwgKHRoaXMuY29udGV4dC5hbGxvd0luICYmIG9wID09PSAnaW4nKSkgPyA3IDogMDtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIGVsc2Uge1xyXG5cdCAgICAgICAgICAgIHByZWNlZGVuY2UgPSAwO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgcmV0dXJuIHByZWNlZGVuY2U7XHJcblx0ICAgIH07XHJcblx0ICAgIFBhcnNlci5wcm90b3R5cGUucGFyc2VCaW5hcnlFeHByZXNzaW9uID0gZnVuY3Rpb24gKCkge1xyXG5cdCAgICAgICAgdmFyIHN0YXJ0VG9rZW4gPSB0aGlzLmxvb2thaGVhZDtcclxuXHQgICAgICAgIHZhciBleHByID0gdGhpcy5pbmhlcml0Q292ZXJHcmFtbWFyKHRoaXMucGFyc2VFeHBvbmVudGlhdGlvbkV4cHJlc3Npb24pO1xyXG5cdCAgICAgICAgdmFyIHRva2VuID0gdGhpcy5sb29rYWhlYWQ7XHJcblx0ICAgICAgICB2YXIgcHJlYyA9IHRoaXMuYmluYXJ5UHJlY2VkZW5jZSh0b2tlbik7XHJcblx0ICAgICAgICBpZiAocHJlYyA+IDApIHtcclxuXHQgICAgICAgICAgICB0aGlzLm5leHRUb2tlbigpO1xyXG5cdCAgICAgICAgICAgIHRoaXMuY29udGV4dC5pc0Fzc2lnbm1lbnRUYXJnZXQgPSBmYWxzZTtcclxuXHQgICAgICAgICAgICB0aGlzLmNvbnRleHQuaXNCaW5kaW5nRWxlbWVudCA9IGZhbHNlO1xyXG5cdCAgICAgICAgICAgIHZhciBtYXJrZXJzID0gW3N0YXJ0VG9rZW4sIHRoaXMubG9va2FoZWFkXTtcclxuXHQgICAgICAgICAgICB2YXIgbGVmdCA9IGV4cHI7XHJcblx0ICAgICAgICAgICAgdmFyIHJpZ2h0ID0gdGhpcy5pc29sYXRlQ292ZXJHcmFtbWFyKHRoaXMucGFyc2VFeHBvbmVudGlhdGlvbkV4cHJlc3Npb24pO1xyXG5cdCAgICAgICAgICAgIHZhciBzdGFjayA9IFtsZWZ0LCB0b2tlbi52YWx1ZSwgcmlnaHRdO1xyXG5cdCAgICAgICAgICAgIHZhciBwcmVjZWRlbmNlcyA9IFtwcmVjXTtcclxuXHQgICAgICAgICAgICB3aGlsZSAodHJ1ZSkge1xyXG5cdCAgICAgICAgICAgICAgICBwcmVjID0gdGhpcy5iaW5hcnlQcmVjZWRlbmNlKHRoaXMubG9va2FoZWFkKTtcclxuXHQgICAgICAgICAgICAgICAgaWYgKHByZWMgPD0gMCkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcblx0ICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgLy8gUmVkdWNlOiBtYWtlIGEgYmluYXJ5IGV4cHJlc3Npb24gZnJvbSB0aGUgdGhyZWUgdG9wbW9zdCBlbnRyaWVzLlxyXG5cdCAgICAgICAgICAgICAgICB3aGlsZSAoKHN0YWNrLmxlbmd0aCA+IDIpICYmIChwcmVjIDw9IHByZWNlZGVuY2VzW3ByZWNlZGVuY2VzLmxlbmd0aCAtIDFdKSkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgcmlnaHQgPSBzdGFjay5wb3AoKTtcclxuXHQgICAgICAgICAgICAgICAgICAgIHZhciBvcGVyYXRvciA9IHN0YWNrLnBvcCgpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgcHJlY2VkZW5jZXMucG9wKCk7XHJcblx0ICAgICAgICAgICAgICAgICAgICBsZWZ0ID0gc3RhY2sucG9wKCk7XHJcblx0ICAgICAgICAgICAgICAgICAgICBtYXJrZXJzLnBvcCgpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZShtYXJrZXJzW21hcmtlcnMubGVuZ3RoIC0gMV0pO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgc3RhY2sucHVzaCh0aGlzLmZpbmFsaXplKG5vZGUsIG5ldyBOb2RlLkJpbmFyeUV4cHJlc3Npb24ob3BlcmF0b3IsIGxlZnQsIHJpZ2h0KSkpO1xyXG5cdCAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgIC8vIFNoaWZ0LlxyXG5cdCAgICAgICAgICAgICAgICBzdGFjay5wdXNoKHRoaXMubmV4dFRva2VuKCkudmFsdWUpO1xyXG5cdCAgICAgICAgICAgICAgICBwcmVjZWRlbmNlcy5wdXNoKHByZWMpO1xyXG5cdCAgICAgICAgICAgICAgICBtYXJrZXJzLnB1c2godGhpcy5sb29rYWhlYWQpO1xyXG5cdCAgICAgICAgICAgICAgICBzdGFjay5wdXNoKHRoaXMuaXNvbGF0ZUNvdmVyR3JhbW1hcih0aGlzLnBhcnNlRXhwb25lbnRpYXRpb25FeHByZXNzaW9uKSk7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgIC8vIEZpbmFsIHJlZHVjZSB0byBjbGVhbi11cCB0aGUgc3RhY2suXHJcblx0ICAgICAgICAgICAgdmFyIGkgPSBzdGFjay5sZW5ndGggLSAxO1xyXG5cdCAgICAgICAgICAgIGV4cHIgPSBzdGFja1tpXTtcclxuXHQgICAgICAgICAgICBtYXJrZXJzLnBvcCgpO1xyXG5cdCAgICAgICAgICAgIHdoaWxlIChpID4gMSkge1xyXG5cdCAgICAgICAgICAgICAgICB2YXIgbm9kZSA9IHRoaXMuc3RhcnROb2RlKG1hcmtlcnMucG9wKCkpO1xyXG5cdCAgICAgICAgICAgICAgICB2YXIgb3BlcmF0b3IgPSBzdGFja1tpIC0gMV07XHJcblx0ICAgICAgICAgICAgICAgIGV4cHIgPSB0aGlzLmZpbmFsaXplKG5vZGUsIG5ldyBOb2RlLkJpbmFyeUV4cHJlc3Npb24ob3BlcmF0b3IsIHN0YWNrW2kgLSAyXSwgZXhwcikpO1xyXG5cdCAgICAgICAgICAgICAgICBpIC09IDI7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgcmV0dXJuIGV4cHI7XHJcblx0ICAgIH07XHJcblx0ICAgIC8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLWNvbmRpdGlvbmFsLW9wZXJhdG9yXHJcblx0ICAgIFBhcnNlci5wcm90b3R5cGUucGFyc2VDb25kaXRpb25hbEV4cHJlc3Npb24gPSBmdW5jdGlvbiAoKSB7XHJcblx0ICAgICAgICB2YXIgc3RhcnRUb2tlbiA9IHRoaXMubG9va2FoZWFkO1xyXG5cdCAgICAgICAgdmFyIGV4cHIgPSB0aGlzLmluaGVyaXRDb3ZlckdyYW1tYXIodGhpcy5wYXJzZUJpbmFyeUV4cHJlc3Npb24pO1xyXG5cdCAgICAgICAgaWYgKHRoaXMubWF0Y2goJz8nKSkge1xyXG5cdCAgICAgICAgICAgIHRoaXMubmV4dFRva2VuKCk7XHJcblx0ICAgICAgICAgICAgdmFyIHByZXZpb3VzQWxsb3dJbiA9IHRoaXMuY29udGV4dC5hbGxvd0luO1xyXG5cdCAgICAgICAgICAgIHRoaXMuY29udGV4dC5hbGxvd0luID0gdHJ1ZTtcclxuXHQgICAgICAgICAgICB2YXIgY29uc2VxdWVudCA9IHRoaXMuaXNvbGF0ZUNvdmVyR3JhbW1hcih0aGlzLnBhcnNlQXNzaWdubWVudEV4cHJlc3Npb24pO1xyXG5cdCAgICAgICAgICAgIHRoaXMuY29udGV4dC5hbGxvd0luID0gcHJldmlvdXNBbGxvd0luO1xyXG5cdCAgICAgICAgICAgIHRoaXMuZXhwZWN0KCc6Jyk7XHJcblx0ICAgICAgICAgICAgdmFyIGFsdGVybmF0ZSA9IHRoaXMuaXNvbGF0ZUNvdmVyR3JhbW1hcih0aGlzLnBhcnNlQXNzaWdubWVudEV4cHJlc3Npb24pO1xyXG5cdCAgICAgICAgICAgIGV4cHIgPSB0aGlzLmZpbmFsaXplKHRoaXMuc3RhcnROb2RlKHN0YXJ0VG9rZW4pLCBuZXcgTm9kZS5Db25kaXRpb25hbEV4cHJlc3Npb24oZXhwciwgY29uc2VxdWVudCwgYWx0ZXJuYXRlKSk7XHJcblx0ICAgICAgICAgICAgdGhpcy5jb250ZXh0LmlzQXNzaWdubWVudFRhcmdldCA9IGZhbHNlO1xyXG5cdCAgICAgICAgICAgIHRoaXMuY29udGV4dC5pc0JpbmRpbmdFbGVtZW50ID0gZmFsc2U7XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICByZXR1cm4gZXhwcjtcclxuXHQgICAgfTtcclxuXHQgICAgLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtYXNzaWdubWVudC1vcGVyYXRvcnNcclxuXHQgICAgUGFyc2VyLnByb3RvdHlwZS5jaGVja1BhdHRlcm5QYXJhbSA9IGZ1bmN0aW9uIChvcHRpb25zLCBwYXJhbSkge1xyXG5cdCAgICAgICAgc3dpdGNoIChwYXJhbS50eXBlKSB7XHJcblx0ICAgICAgICAgICAgY2FzZSBzeW50YXhfMS5TeW50YXguSWRlbnRpZmllcjpcclxuXHQgICAgICAgICAgICAgICAgdGhpcy52YWxpZGF0ZVBhcmFtKG9wdGlvbnMsIHBhcmFtLCBwYXJhbS5uYW1lKTtcclxuXHQgICAgICAgICAgICAgICAgYnJlYWs7XHJcblx0ICAgICAgICAgICAgY2FzZSBzeW50YXhfMS5TeW50YXguUmVzdEVsZW1lbnQ6XHJcblx0ICAgICAgICAgICAgICAgIHRoaXMuY2hlY2tQYXR0ZXJuUGFyYW0ob3B0aW9ucywgcGFyYW0uYXJndW1lbnQpO1xyXG5cdCAgICAgICAgICAgICAgICBicmVhaztcclxuXHQgICAgICAgICAgICBjYXNlIHN5bnRheF8xLlN5bnRheC5Bc3NpZ25tZW50UGF0dGVybjpcclxuXHQgICAgICAgICAgICAgICAgdGhpcy5jaGVja1BhdHRlcm5QYXJhbShvcHRpb25zLCBwYXJhbS5sZWZ0KTtcclxuXHQgICAgICAgICAgICAgICAgYnJlYWs7XHJcblx0ICAgICAgICAgICAgY2FzZSBzeW50YXhfMS5TeW50YXguQXJyYXlQYXR0ZXJuOlxyXG5cdCAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBhcmFtLmVsZW1lbnRzLmxlbmd0aDsgaSsrKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICBpZiAocGFyYW0uZWxlbWVudHNbaV0gIT09IG51bGwpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmNoZWNrUGF0dGVyblBhcmFtKG9wdGlvbnMsIHBhcmFtLmVsZW1lbnRzW2ldKTtcclxuXHQgICAgICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICBicmVhaztcclxuXHQgICAgICAgICAgICBjYXNlIHN5bnRheF8xLlN5bnRheC5PYmplY3RQYXR0ZXJuOlxyXG5cdCAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBhcmFtLnByb3BlcnRpZXMubGVuZ3RoOyBpKyspIHtcclxuXHQgICAgICAgICAgICAgICAgICAgIHRoaXMuY2hlY2tQYXR0ZXJuUGFyYW0ob3B0aW9ucywgcGFyYW0ucHJvcGVydGllc1tpXS52YWx1ZSk7XHJcblx0ICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgYnJlYWs7XHJcblx0ICAgICAgICAgICAgZGVmYXVsdDpcclxuXHQgICAgICAgICAgICAgICAgYnJlYWs7XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICBvcHRpb25zLnNpbXBsZSA9IG9wdGlvbnMuc2ltcGxlICYmIChwYXJhbSBpbnN0YW5jZW9mIE5vZGUuSWRlbnRpZmllcik7XHJcblx0ICAgIH07XHJcblx0ICAgIFBhcnNlci5wcm90b3R5cGUucmVpbnRlcnByZXRBc0NvdmVyRm9ybWFsc0xpc3QgPSBmdW5jdGlvbiAoZXhwcikge1xyXG5cdCAgICAgICAgdmFyIHBhcmFtcyA9IFtleHByXTtcclxuXHQgICAgICAgIHZhciBvcHRpb25zO1xyXG5cdCAgICAgICAgdmFyIGFzeW5jQXJyb3cgPSBmYWxzZTtcclxuXHQgICAgICAgIHN3aXRjaCAoZXhwci50eXBlKSB7XHJcblx0ICAgICAgICAgICAgY2FzZSBzeW50YXhfMS5TeW50YXguSWRlbnRpZmllcjpcclxuXHQgICAgICAgICAgICAgICAgYnJlYWs7XHJcblx0ICAgICAgICAgICAgY2FzZSBBcnJvd1BhcmFtZXRlclBsYWNlSG9sZGVyOlxyXG5cdCAgICAgICAgICAgICAgICBwYXJhbXMgPSBleHByLnBhcmFtcztcclxuXHQgICAgICAgICAgICAgICAgYXN5bmNBcnJvdyA9IGV4cHIuYXN5bmM7XHJcblx0ICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cdCAgICAgICAgICAgIGRlZmF1bHQ6XHJcblx0ICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgb3B0aW9ucyA9IHtcclxuXHQgICAgICAgICAgICBzaW1wbGU6IHRydWUsXHJcblx0ICAgICAgICAgICAgcGFyYW1TZXQ6IHt9XHJcblx0ICAgICAgICB9O1xyXG5cdCAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwYXJhbXMubGVuZ3RoOyArK2kpIHtcclxuXHQgICAgICAgICAgICB2YXIgcGFyYW0gPSBwYXJhbXNbaV07XHJcblx0ICAgICAgICAgICAgaWYgKHBhcmFtLnR5cGUgPT09IHN5bnRheF8xLlN5bnRheC5Bc3NpZ25tZW50UGF0dGVybikge1xyXG5cdCAgICAgICAgICAgICAgICBpZiAocGFyYW0ucmlnaHQudHlwZSA9PT0gc3ludGF4XzEuU3ludGF4LllpZWxkRXhwcmVzc2lvbikge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKHBhcmFtLnJpZ2h0LmFyZ3VtZW50KSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy50aHJvd1VuZXhwZWN0ZWRUb2tlbih0aGlzLmxvb2thaGVhZCk7XHJcblx0ICAgICAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgICAgICBwYXJhbS5yaWdodC50eXBlID0gc3ludGF4XzEuU3ludGF4LklkZW50aWZpZXI7XHJcblx0ICAgICAgICAgICAgICAgICAgICBwYXJhbS5yaWdodC5uYW1lID0gJ3lpZWxkJztcclxuXHQgICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBwYXJhbS5yaWdodC5hcmd1bWVudDtcclxuXHQgICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBwYXJhbS5yaWdodC5kZWxlZ2F0ZTtcclxuXHQgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICBlbHNlIGlmIChhc3luY0Fycm93ICYmIHBhcmFtLnR5cGUgPT09IHN5bnRheF8xLlN5bnRheC5JZGVudGlmaWVyICYmIHBhcmFtLm5hbWUgPT09ICdhd2FpdCcpIHtcclxuXHQgICAgICAgICAgICAgICAgdGhpcy50aHJvd1VuZXhwZWN0ZWRUb2tlbih0aGlzLmxvb2thaGVhZCk7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgIHRoaXMuY2hlY2tQYXR0ZXJuUGFyYW0ob3B0aW9ucywgcGFyYW0pO1xyXG5cdCAgICAgICAgICAgIHBhcmFtc1tpXSA9IHBhcmFtO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgaWYgKHRoaXMuY29udGV4dC5zdHJpY3QgfHwgIXRoaXMuY29udGV4dC5hbGxvd1lpZWxkKSB7XHJcblx0ICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwYXJhbXMubGVuZ3RoOyArK2kpIHtcclxuXHQgICAgICAgICAgICAgICAgdmFyIHBhcmFtID0gcGFyYW1zW2ldO1xyXG5cdCAgICAgICAgICAgICAgICBpZiAocGFyYW0udHlwZSA9PT0gc3ludGF4XzEuU3ludGF4LllpZWxkRXhwcmVzc2lvbikge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgdGhpcy50aHJvd1VuZXhwZWN0ZWRUb2tlbih0aGlzLmxvb2thaGVhZCk7XHJcblx0ICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICBpZiAob3B0aW9ucy5tZXNzYWdlID09PSBtZXNzYWdlc18xLk1lc3NhZ2VzLlN0cmljdFBhcmFtRHVwZSkge1xyXG5cdCAgICAgICAgICAgIHZhciB0b2tlbiA9IHRoaXMuY29udGV4dC5zdHJpY3QgPyBvcHRpb25zLnN0cmljdGVkIDogb3B0aW9ucy5maXJzdFJlc3RyaWN0ZWQ7XHJcblx0ICAgICAgICAgICAgdGhpcy50aHJvd1VuZXhwZWN0ZWRUb2tlbih0b2tlbiwgb3B0aW9ucy5tZXNzYWdlKTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIHJldHVybiB7XHJcblx0ICAgICAgICAgICAgc2ltcGxlOiBvcHRpb25zLnNpbXBsZSxcclxuXHQgICAgICAgICAgICBwYXJhbXM6IHBhcmFtcyxcclxuXHQgICAgICAgICAgICBzdHJpY3RlZDogb3B0aW9ucy5zdHJpY3RlZCxcclxuXHQgICAgICAgICAgICBmaXJzdFJlc3RyaWN0ZWQ6IG9wdGlvbnMuZmlyc3RSZXN0cmljdGVkLFxyXG5cdCAgICAgICAgICAgIG1lc3NhZ2U6IG9wdGlvbnMubWVzc2FnZVxyXG5cdCAgICAgICAgfTtcclxuXHQgICAgfTtcclxuXHQgICAgUGFyc2VyLnByb3RvdHlwZS5wYXJzZUFzc2lnbm1lbnRFeHByZXNzaW9uID0gZnVuY3Rpb24gKCkge1xyXG5cdCAgICAgICAgdmFyIGV4cHI7XHJcblx0ICAgICAgICBpZiAoIXRoaXMuY29udGV4dC5hbGxvd1lpZWxkICYmIHRoaXMubWF0Y2hLZXl3b3JkKCd5aWVsZCcpKSB7XHJcblx0ICAgICAgICAgICAgZXhwciA9IHRoaXMucGFyc2VZaWVsZEV4cHJlc3Npb24oKTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIGVsc2Uge1xyXG5cdCAgICAgICAgICAgIHZhciBzdGFydFRva2VuID0gdGhpcy5sb29rYWhlYWQ7XHJcblx0ICAgICAgICAgICAgdmFyIHRva2VuID0gc3RhcnRUb2tlbjtcclxuXHQgICAgICAgICAgICBleHByID0gdGhpcy5wYXJzZUNvbmRpdGlvbmFsRXhwcmVzc2lvbigpO1xyXG5cdCAgICAgICAgICAgIGlmICh0b2tlbi50eXBlID09PSAzIC8qIElkZW50aWZpZXIgKi8gJiYgKHRva2VuLmxpbmVOdW1iZXIgPT09IHRoaXMubG9va2FoZWFkLmxpbmVOdW1iZXIpICYmIHRva2VuLnZhbHVlID09PSAnYXN5bmMnKSB7XHJcblx0ICAgICAgICAgICAgICAgIGlmICh0aGlzLmxvb2thaGVhZC50eXBlID09PSAzIC8qIElkZW50aWZpZXIgKi8gfHwgdGhpcy5tYXRjaEtleXdvcmQoJ3lpZWxkJykpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgIHZhciBhcmcgPSB0aGlzLnBhcnNlUHJpbWFyeUV4cHJlc3Npb24oKTtcclxuXHQgICAgICAgICAgICAgICAgICAgIHRoaXMucmVpbnRlcnByZXRFeHByZXNzaW9uQXNQYXR0ZXJuKGFyZyk7XHJcblx0ICAgICAgICAgICAgICAgICAgICBleHByID0ge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IEFycm93UGFyYW1ldGVyUGxhY2VIb2xkZXIsXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcGFyYW1zOiBbYXJnXSxcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBhc3luYzogdHJ1ZVxyXG5cdCAgICAgICAgICAgICAgICAgICAgfTtcclxuXHQgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICBpZiAoZXhwci50eXBlID09PSBBcnJvd1BhcmFtZXRlclBsYWNlSG9sZGVyIHx8IHRoaXMubWF0Y2goJz0+JykpIHtcclxuXHQgICAgICAgICAgICAgICAgLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtYXJyb3ctZnVuY3Rpb24tZGVmaW5pdGlvbnNcclxuXHQgICAgICAgICAgICAgICAgdGhpcy5jb250ZXh0LmlzQXNzaWdubWVudFRhcmdldCA9IGZhbHNlO1xyXG5cdCAgICAgICAgICAgICAgICB0aGlzLmNvbnRleHQuaXNCaW5kaW5nRWxlbWVudCA9IGZhbHNlO1xyXG5cdCAgICAgICAgICAgICAgICB2YXIgaXNBc3luYyA9IGV4cHIuYXN5bmM7XHJcblx0ICAgICAgICAgICAgICAgIHZhciBsaXN0ID0gdGhpcy5yZWludGVycHJldEFzQ292ZXJGb3JtYWxzTGlzdChleHByKTtcclxuXHQgICAgICAgICAgICAgICAgaWYgKGxpc3QpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmhhc0xpbmVUZXJtaW5hdG9yKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy50b2xlcmF0ZVVuZXhwZWN0ZWRUb2tlbih0aGlzLmxvb2thaGVhZCk7XHJcblx0ICAgICAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbnRleHQuZmlyc3RDb3ZlckluaXRpYWxpemVkTmFtZUVycm9yID0gbnVsbDtcclxuXHQgICAgICAgICAgICAgICAgICAgIHZhciBwcmV2aW91c1N0cmljdCA9IHRoaXMuY29udGV4dC5zdHJpY3Q7XHJcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgcHJldmlvdXNBbGxvd1N0cmljdERpcmVjdGl2ZSA9IHRoaXMuY29udGV4dC5hbGxvd1N0cmljdERpcmVjdGl2ZTtcclxuXHQgICAgICAgICAgICAgICAgICAgIHRoaXMuY29udGV4dC5hbGxvd1N0cmljdERpcmVjdGl2ZSA9IGxpc3Quc2ltcGxlO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIHByZXZpb3VzQWxsb3dZaWVsZCA9IHRoaXMuY29udGV4dC5hbGxvd1lpZWxkO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIHByZXZpb3VzQXdhaXQgPSB0aGlzLmNvbnRleHQuYXdhaXQ7XHJcblx0ICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbnRleHQuYWxsb3dZaWVsZCA9IHRydWU7XHJcblx0ICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbnRleHQuYXdhaXQgPSBpc0FzeW5jO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZShzdGFydFRva2VuKTtcclxuXHQgICAgICAgICAgICAgICAgICAgIHRoaXMuZXhwZWN0KCc9PicpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIGJvZHkgPSB2b2lkIDA7XHJcblx0ICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5tYXRjaCgneycpKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHByZXZpb3VzQWxsb3dJbiA9IHRoaXMuY29udGV4dC5hbGxvd0luO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY29udGV4dC5hbGxvd0luID0gdHJ1ZTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBib2R5ID0gdGhpcy5wYXJzZUZ1bmN0aW9uU291cmNlRWxlbWVudHMoKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbnRleHQuYWxsb3dJbiA9IHByZXZpb3VzQWxsb3dJbjtcclxuXHQgICAgICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGJvZHkgPSB0aGlzLmlzb2xhdGVDb3ZlckdyYW1tYXIodGhpcy5wYXJzZUFzc2lnbm1lbnRFeHByZXNzaW9uKTtcclxuXHQgICAgICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgICAgIHZhciBleHByZXNzaW9uID0gYm9keS50eXBlICE9PSBzeW50YXhfMS5TeW50YXguQmxvY2tTdGF0ZW1lbnQ7XHJcblx0ICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5jb250ZXh0LnN0cmljdCAmJiBsaXN0LmZpcnN0UmVzdHJpY3RlZCkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMudGhyb3dVbmV4cGVjdGVkVG9rZW4obGlzdC5maXJzdFJlc3RyaWN0ZWQsIGxpc3QubWVzc2FnZSk7XHJcblx0ICAgICAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5jb250ZXh0LnN0cmljdCAmJiBsaXN0LnN0cmljdGVkKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy50b2xlcmF0ZVVuZXhwZWN0ZWRUb2tlbihsaXN0LnN0cmljdGVkLCBsaXN0Lm1lc3NhZ2UpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICAgICAgZXhwciA9IGlzQXN5bmMgPyB0aGlzLmZpbmFsaXplKG5vZGUsIG5ldyBOb2RlLkFzeW5jQXJyb3dGdW5jdGlvbkV4cHJlc3Npb24obGlzdC5wYXJhbXMsIGJvZHksIGV4cHJlc3Npb24pKSA6XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5maW5hbGl6ZShub2RlLCBuZXcgTm9kZS5BcnJvd0Z1bmN0aW9uRXhwcmVzc2lvbihsaXN0LnBhcmFtcywgYm9keSwgZXhwcmVzc2lvbikpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgdGhpcy5jb250ZXh0LnN0cmljdCA9IHByZXZpb3VzU3RyaWN0O1xyXG5cdCAgICAgICAgICAgICAgICAgICAgdGhpcy5jb250ZXh0LmFsbG93U3RyaWN0RGlyZWN0aXZlID0gcHJldmlvdXNBbGxvd1N0cmljdERpcmVjdGl2ZTtcclxuXHQgICAgICAgICAgICAgICAgICAgIHRoaXMuY29udGV4dC5hbGxvd1lpZWxkID0gcHJldmlvdXNBbGxvd1lpZWxkO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgdGhpcy5jb250ZXh0LmF3YWl0ID0gcHJldmlvdXNBd2FpdDtcclxuXHQgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICBlbHNlIHtcclxuXHQgICAgICAgICAgICAgICAgaWYgKHRoaXMubWF0Y2hBc3NpZ24oKSkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKCF0aGlzLmNvbnRleHQuaXNBc3NpZ25tZW50VGFyZ2V0KSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy50b2xlcmF0ZUVycm9yKG1lc3NhZ2VzXzEuTWVzc2FnZXMuSW52YWxpZExIU0luQXNzaWdubWVudCk7XHJcblx0ICAgICAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5jb250ZXh0LnN0cmljdCAmJiBleHByLnR5cGUgPT09IHN5bnRheF8xLlN5bnRheC5JZGVudGlmaWVyKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGlkID0gZXhwcjtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5zY2FubmVyLmlzUmVzdHJpY3RlZFdvcmQoaWQubmFtZSkpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy50b2xlcmF0ZVVuZXhwZWN0ZWRUb2tlbih0b2tlbiwgbWVzc2FnZXNfMS5NZXNzYWdlcy5TdHJpY3RMSFNBc3NpZ25tZW50KTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuc2Nhbm5lci5pc1N0cmljdE1vZGVSZXNlcnZlZFdvcmQoaWQubmFtZSkpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy50b2xlcmF0ZVVuZXhwZWN0ZWRUb2tlbih0b2tlbiwgbWVzc2FnZXNfMS5NZXNzYWdlcy5TdHJpY3RSZXNlcnZlZFdvcmQpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgICAgIGlmICghdGhpcy5tYXRjaCgnPScpKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jb250ZXh0LmlzQXNzaWdubWVudFRhcmdldCA9IGZhbHNlO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY29udGV4dC5pc0JpbmRpbmdFbGVtZW50ID0gZmFsc2U7XHJcblx0ICAgICAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnJlaW50ZXJwcmV0RXhwcmVzc2lvbkFzUGF0dGVybihleHByKTtcclxuXHQgICAgICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgICAgIHRva2VuID0gdGhpcy5uZXh0VG9rZW4oKTtcclxuXHQgICAgICAgICAgICAgICAgICAgIHZhciBvcGVyYXRvciA9IHRva2VuLnZhbHVlO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIHJpZ2h0ID0gdGhpcy5pc29sYXRlQ292ZXJHcmFtbWFyKHRoaXMucGFyc2VBc3NpZ25tZW50RXhwcmVzc2lvbik7XHJcblx0ICAgICAgICAgICAgICAgICAgICBleHByID0gdGhpcy5maW5hbGl6ZSh0aGlzLnN0YXJ0Tm9kZShzdGFydFRva2VuKSwgbmV3IE5vZGUuQXNzaWdubWVudEV4cHJlc3Npb24ob3BlcmF0b3IsIGV4cHIsIHJpZ2h0KSk7XHJcblx0ICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbnRleHQuZmlyc3RDb3ZlckluaXRpYWxpemVkTmFtZUVycm9yID0gbnVsbDtcclxuXHQgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIHJldHVybiBleHByO1xyXG5cdCAgICB9O1xyXG5cdCAgICAvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1jb21tYS1vcGVyYXRvclxyXG5cdCAgICBQYXJzZXIucHJvdG90eXBlLnBhcnNlRXhwcmVzc2lvbiA9IGZ1bmN0aW9uICgpIHtcclxuXHQgICAgICAgIHZhciBzdGFydFRva2VuID0gdGhpcy5sb29rYWhlYWQ7XHJcblx0ICAgICAgICB2YXIgZXhwciA9IHRoaXMuaXNvbGF0ZUNvdmVyR3JhbW1hcih0aGlzLnBhcnNlQXNzaWdubWVudEV4cHJlc3Npb24pO1xyXG5cdCAgICAgICAgaWYgKHRoaXMubWF0Y2goJywnKSkge1xyXG5cdCAgICAgICAgICAgIHZhciBleHByZXNzaW9ucyA9IFtdO1xyXG5cdCAgICAgICAgICAgIGV4cHJlc3Npb25zLnB1c2goZXhwcik7XHJcblx0ICAgICAgICAgICAgd2hpbGUgKHRoaXMubG9va2FoZWFkLnR5cGUgIT09IDIgLyogRU9GICovKSB7XHJcblx0ICAgICAgICAgICAgICAgIGlmICghdGhpcy5tYXRjaCgnLCcpKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuXHQgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICB0aGlzLm5leHRUb2tlbigpO1xyXG5cdCAgICAgICAgICAgICAgICBleHByZXNzaW9ucy5wdXNoKHRoaXMuaXNvbGF0ZUNvdmVyR3JhbW1hcih0aGlzLnBhcnNlQXNzaWdubWVudEV4cHJlc3Npb24pKTtcclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgZXhwciA9IHRoaXMuZmluYWxpemUodGhpcy5zdGFydE5vZGUoc3RhcnRUb2tlbiksIG5ldyBOb2RlLlNlcXVlbmNlRXhwcmVzc2lvbihleHByZXNzaW9ucykpO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgcmV0dXJuIGV4cHI7XHJcblx0ICAgIH07XHJcblx0ICAgIC8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLWJsb2NrXHJcblx0ICAgIFBhcnNlci5wcm90b3R5cGUucGFyc2VTdGF0ZW1lbnRMaXN0SXRlbSA9IGZ1bmN0aW9uICgpIHtcclxuXHQgICAgICAgIHZhciBzdGF0ZW1lbnQ7XHJcblx0ICAgICAgICB0aGlzLmNvbnRleHQuaXNBc3NpZ25tZW50VGFyZ2V0ID0gdHJ1ZTtcclxuXHQgICAgICAgIHRoaXMuY29udGV4dC5pc0JpbmRpbmdFbGVtZW50ID0gdHJ1ZTtcclxuXHQgICAgICAgIGlmICh0aGlzLmxvb2thaGVhZC50eXBlID09PSA0IC8qIEtleXdvcmQgKi8pIHtcclxuXHQgICAgICAgICAgICBzd2l0Y2ggKHRoaXMubG9va2FoZWFkLnZhbHVlKSB7XHJcblx0ICAgICAgICAgICAgICAgIGNhc2UgJ2V4cG9ydCc6XHJcblx0ICAgICAgICAgICAgICAgICAgICBpZiAoIXRoaXMuY29udGV4dC5pc01vZHVsZSkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMudG9sZXJhdGVVbmV4cGVjdGVkVG9rZW4odGhpcy5sb29rYWhlYWQsIG1lc3NhZ2VzXzEuTWVzc2FnZXMuSWxsZWdhbEV4cG9ydERlY2xhcmF0aW9uKTtcclxuXHQgICAgICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgICAgIHN0YXRlbWVudCA9IHRoaXMucGFyc2VFeHBvcnREZWNsYXJhdGlvbigpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcblx0ICAgICAgICAgICAgICAgIGNhc2UgJ2ltcG9ydCc6XHJcblx0ICAgICAgICAgICAgICAgICAgICBpZiAoIXRoaXMuY29udGV4dC5pc01vZHVsZSkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMudG9sZXJhdGVVbmV4cGVjdGVkVG9rZW4odGhpcy5sb29rYWhlYWQsIG1lc3NhZ2VzXzEuTWVzc2FnZXMuSWxsZWdhbEltcG9ydERlY2xhcmF0aW9uKTtcclxuXHQgICAgICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgICAgIHN0YXRlbWVudCA9IHRoaXMucGFyc2VJbXBvcnREZWNsYXJhdGlvbigpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcblx0ICAgICAgICAgICAgICAgIGNhc2UgJ2NvbnN0JzpcclxuXHQgICAgICAgICAgICAgICAgICAgIHN0YXRlbWVudCA9IHRoaXMucGFyc2VMZXhpY2FsRGVjbGFyYXRpb24oeyBpbkZvcjogZmFsc2UgfSk7XHJcblx0ICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuXHQgICAgICAgICAgICAgICAgY2FzZSAnZnVuY3Rpb24nOlxyXG5cdCAgICAgICAgICAgICAgICAgICAgc3RhdGVtZW50ID0gdGhpcy5wYXJzZUZ1bmN0aW9uRGVjbGFyYXRpb24oKTtcclxuXHQgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cdCAgICAgICAgICAgICAgICBjYXNlICdjbGFzcyc6XHJcblx0ICAgICAgICAgICAgICAgICAgICBzdGF0ZW1lbnQgPSB0aGlzLnBhcnNlQ2xhc3NEZWNsYXJhdGlvbigpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcblx0ICAgICAgICAgICAgICAgIGNhc2UgJ2xldCc6XHJcblx0ICAgICAgICAgICAgICAgICAgICBzdGF0ZW1lbnQgPSB0aGlzLmlzTGV4aWNhbERlY2xhcmF0aW9uKCkgPyB0aGlzLnBhcnNlTGV4aWNhbERlY2xhcmF0aW9uKHsgaW5Gb3I6IGZhbHNlIH0pIDogdGhpcy5wYXJzZVN0YXRlbWVudCgpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcblx0ICAgICAgICAgICAgICAgIGRlZmF1bHQ6XHJcblx0ICAgICAgICAgICAgICAgICAgICBzdGF0ZW1lbnQgPSB0aGlzLnBhcnNlU3RhdGVtZW50KCk7XHJcblx0ICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICBlbHNlIHtcclxuXHQgICAgICAgICAgICBzdGF0ZW1lbnQgPSB0aGlzLnBhcnNlU3RhdGVtZW50KCk7XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICByZXR1cm4gc3RhdGVtZW50O1xyXG5cdCAgICB9O1xyXG5cdCAgICBQYXJzZXIucHJvdG90eXBlLnBhcnNlQmxvY2sgPSBmdW5jdGlvbiAoKSB7XHJcblx0ICAgICAgICB2YXIgbm9kZSA9IHRoaXMuY3JlYXRlTm9kZSgpO1xyXG5cdCAgICAgICAgdGhpcy5leHBlY3QoJ3snKTtcclxuXHQgICAgICAgIHZhciBibG9jayA9IFtdO1xyXG5cdCAgICAgICAgd2hpbGUgKHRydWUpIHtcclxuXHQgICAgICAgICAgICBpZiAodGhpcy5tYXRjaCgnfScpKSB7XHJcblx0ICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICBibG9jay5wdXNoKHRoaXMucGFyc2VTdGF0ZW1lbnRMaXN0SXRlbSgpKTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIHRoaXMuZXhwZWN0KCd9Jyk7XHJcblx0ICAgICAgICByZXR1cm4gdGhpcy5maW5hbGl6ZShub2RlLCBuZXcgTm9kZS5CbG9ja1N0YXRlbWVudChibG9jaykpO1xyXG5cdCAgICB9O1xyXG5cdCAgICAvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1sZXQtYW5kLWNvbnN0LWRlY2xhcmF0aW9uc1xyXG5cdCAgICBQYXJzZXIucHJvdG90eXBlLnBhcnNlTGV4aWNhbEJpbmRpbmcgPSBmdW5jdGlvbiAoa2luZCwgb3B0aW9ucykge1xyXG5cdCAgICAgICAgdmFyIG5vZGUgPSB0aGlzLmNyZWF0ZU5vZGUoKTtcclxuXHQgICAgICAgIHZhciBwYXJhbXMgPSBbXTtcclxuXHQgICAgICAgIHZhciBpZCA9IHRoaXMucGFyc2VQYXR0ZXJuKHBhcmFtcywga2luZCk7XHJcblx0ICAgICAgICBpZiAodGhpcy5jb250ZXh0LnN0cmljdCAmJiBpZC50eXBlID09PSBzeW50YXhfMS5TeW50YXguSWRlbnRpZmllcikge1xyXG5cdCAgICAgICAgICAgIGlmICh0aGlzLnNjYW5uZXIuaXNSZXN0cmljdGVkV29yZChpZC5uYW1lKSkge1xyXG5cdCAgICAgICAgICAgICAgICB0aGlzLnRvbGVyYXRlRXJyb3IobWVzc2FnZXNfMS5NZXNzYWdlcy5TdHJpY3RWYXJOYW1lKTtcclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICB2YXIgaW5pdCA9IG51bGw7XHJcblx0ICAgICAgICBpZiAoa2luZCA9PT0gJ2NvbnN0Jykge1xyXG5cdCAgICAgICAgICAgIGlmICghdGhpcy5tYXRjaEtleXdvcmQoJ2luJykgJiYgIXRoaXMubWF0Y2hDb250ZXh0dWFsS2V5d29yZCgnb2YnKSkge1xyXG5cdCAgICAgICAgICAgICAgICBpZiAodGhpcy5tYXRjaCgnPScpKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICB0aGlzLm5leHRUb2tlbigpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgaW5pdCA9IHRoaXMuaXNvbGF0ZUNvdmVyR3JhbW1hcih0aGlzLnBhcnNlQXNzaWdubWVudEV4cHJlc3Npb24pO1xyXG5cdCAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgIGVsc2Uge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgdGhpcy50aHJvd0Vycm9yKG1lc3NhZ2VzXzEuTWVzc2FnZXMuRGVjbGFyYXRpb25NaXNzaW5nSW5pdGlhbGl6ZXIsICdjb25zdCcpO1xyXG5cdCAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgZWxzZSBpZiAoKCFvcHRpb25zLmluRm9yICYmIGlkLnR5cGUgIT09IHN5bnRheF8xLlN5bnRheC5JZGVudGlmaWVyKSB8fCB0aGlzLm1hdGNoKCc9JykpIHtcclxuXHQgICAgICAgICAgICB0aGlzLmV4cGVjdCgnPScpO1xyXG5cdCAgICAgICAgICAgIGluaXQgPSB0aGlzLmlzb2xhdGVDb3ZlckdyYW1tYXIodGhpcy5wYXJzZUFzc2lnbm1lbnRFeHByZXNzaW9uKTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIHJldHVybiB0aGlzLmZpbmFsaXplKG5vZGUsIG5ldyBOb2RlLlZhcmlhYmxlRGVjbGFyYXRvcihpZCwgaW5pdCkpO1xyXG5cdCAgICB9O1xyXG5cdCAgICBQYXJzZXIucHJvdG90eXBlLnBhcnNlQmluZGluZ0xpc3QgPSBmdW5jdGlvbiAoa2luZCwgb3B0aW9ucykge1xyXG5cdCAgICAgICAgdmFyIGxpc3QgPSBbdGhpcy5wYXJzZUxleGljYWxCaW5kaW5nKGtpbmQsIG9wdGlvbnMpXTtcclxuXHQgICAgICAgIHdoaWxlICh0aGlzLm1hdGNoKCcsJykpIHtcclxuXHQgICAgICAgICAgICB0aGlzLm5leHRUb2tlbigpO1xyXG5cdCAgICAgICAgICAgIGxpc3QucHVzaCh0aGlzLnBhcnNlTGV4aWNhbEJpbmRpbmcoa2luZCwgb3B0aW9ucykpO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgcmV0dXJuIGxpc3Q7XHJcblx0ICAgIH07XHJcblx0ICAgIFBhcnNlci5wcm90b3R5cGUuaXNMZXhpY2FsRGVjbGFyYXRpb24gPSBmdW5jdGlvbiAoKSB7XHJcblx0ICAgICAgICB2YXIgc3RhdGUgPSB0aGlzLnNjYW5uZXIuc2F2ZVN0YXRlKCk7XHJcblx0ICAgICAgICB0aGlzLnNjYW5uZXIuc2NhbkNvbW1lbnRzKCk7XHJcblx0ICAgICAgICB2YXIgbmV4dCA9IHRoaXMuc2Nhbm5lci5sZXgoKTtcclxuXHQgICAgICAgIHRoaXMuc2Nhbm5lci5yZXN0b3JlU3RhdGUoc3RhdGUpO1xyXG5cdCAgICAgICAgcmV0dXJuIChuZXh0LnR5cGUgPT09IDMgLyogSWRlbnRpZmllciAqLykgfHxcclxuXHQgICAgICAgICAgICAobmV4dC50eXBlID09PSA3IC8qIFB1bmN0dWF0b3IgKi8gJiYgbmV4dC52YWx1ZSA9PT0gJ1snKSB8fFxyXG5cdCAgICAgICAgICAgIChuZXh0LnR5cGUgPT09IDcgLyogUHVuY3R1YXRvciAqLyAmJiBuZXh0LnZhbHVlID09PSAneycpIHx8XHJcblx0ICAgICAgICAgICAgKG5leHQudHlwZSA9PT0gNCAvKiBLZXl3b3JkICovICYmIG5leHQudmFsdWUgPT09ICdsZXQnKSB8fFxyXG5cdCAgICAgICAgICAgIChuZXh0LnR5cGUgPT09IDQgLyogS2V5d29yZCAqLyAmJiBuZXh0LnZhbHVlID09PSAneWllbGQnKTtcclxuXHQgICAgfTtcclxuXHQgICAgUGFyc2VyLnByb3RvdHlwZS5wYXJzZUxleGljYWxEZWNsYXJhdGlvbiA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XHJcblx0ICAgICAgICB2YXIgbm9kZSA9IHRoaXMuY3JlYXRlTm9kZSgpO1xyXG5cdCAgICAgICAgdmFyIGtpbmQgPSB0aGlzLm5leHRUb2tlbigpLnZhbHVlO1xyXG5cdCAgICAgICAgYXNzZXJ0XzEuYXNzZXJ0KGtpbmQgPT09ICdsZXQnIHx8IGtpbmQgPT09ICdjb25zdCcsICdMZXhpY2FsIGRlY2xhcmF0aW9uIG11c3QgYmUgZWl0aGVyIGxldCBvciBjb25zdCcpO1xyXG5cdCAgICAgICAgdmFyIGRlY2xhcmF0aW9ucyA9IHRoaXMucGFyc2VCaW5kaW5nTGlzdChraW5kLCBvcHRpb25zKTtcclxuXHQgICAgICAgIHRoaXMuY29uc3VtZVNlbWljb2xvbigpO1xyXG5cdCAgICAgICAgcmV0dXJuIHRoaXMuZmluYWxpemUobm9kZSwgbmV3IE5vZGUuVmFyaWFibGVEZWNsYXJhdGlvbihkZWNsYXJhdGlvbnMsIGtpbmQpKTtcclxuXHQgICAgfTtcclxuXHQgICAgLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtZGVzdHJ1Y3R1cmluZy1iaW5kaW5nLXBhdHRlcm5zXHJcblx0ICAgIFBhcnNlci5wcm90b3R5cGUucGFyc2VCaW5kaW5nUmVzdEVsZW1lbnQgPSBmdW5jdGlvbiAocGFyYW1zLCBraW5kKSB7XHJcblx0ICAgICAgICB2YXIgbm9kZSA9IHRoaXMuY3JlYXRlTm9kZSgpO1xyXG5cdCAgICAgICAgdGhpcy5leHBlY3QoJy4uLicpO1xyXG5cdCAgICAgICAgdmFyIGFyZyA9IHRoaXMucGFyc2VQYXR0ZXJuKHBhcmFtcywga2luZCk7XHJcblx0ICAgICAgICByZXR1cm4gdGhpcy5maW5hbGl6ZShub2RlLCBuZXcgTm9kZS5SZXN0RWxlbWVudChhcmcpKTtcclxuXHQgICAgfTtcclxuXHQgICAgUGFyc2VyLnByb3RvdHlwZS5wYXJzZUFycmF5UGF0dGVybiA9IGZ1bmN0aW9uIChwYXJhbXMsIGtpbmQpIHtcclxuXHQgICAgICAgIHZhciBub2RlID0gdGhpcy5jcmVhdGVOb2RlKCk7XHJcblx0ICAgICAgICB0aGlzLmV4cGVjdCgnWycpO1xyXG5cdCAgICAgICAgdmFyIGVsZW1lbnRzID0gW107XHJcblx0ICAgICAgICB3aGlsZSAoIXRoaXMubWF0Y2goJ10nKSkge1xyXG5cdCAgICAgICAgICAgIGlmICh0aGlzLm1hdGNoKCcsJykpIHtcclxuXHQgICAgICAgICAgICAgICAgdGhpcy5uZXh0VG9rZW4oKTtcclxuXHQgICAgICAgICAgICAgICAgZWxlbWVudHMucHVzaChudWxsKTtcclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgZWxzZSB7XHJcblx0ICAgICAgICAgICAgICAgIGlmICh0aGlzLm1hdGNoKCcuLi4nKSkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgZWxlbWVudHMucHVzaCh0aGlzLnBhcnNlQmluZGluZ1Jlc3RFbGVtZW50KHBhcmFtcywga2luZCkpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcblx0ICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgZWxzZSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICBlbGVtZW50cy5wdXNoKHRoaXMucGFyc2VQYXR0ZXJuV2l0aERlZmF1bHQocGFyYW1zLCBraW5kKSk7XHJcblx0ICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgaWYgKCF0aGlzLm1hdGNoKCddJykpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgIHRoaXMuZXhwZWN0KCcsJyk7XHJcblx0ICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICB0aGlzLmV4cGVjdCgnXScpO1xyXG5cdCAgICAgICAgcmV0dXJuIHRoaXMuZmluYWxpemUobm9kZSwgbmV3IE5vZGUuQXJyYXlQYXR0ZXJuKGVsZW1lbnRzKSk7XHJcblx0ICAgIH07XHJcblx0ICAgIFBhcnNlci5wcm90b3R5cGUucGFyc2VQcm9wZXJ0eVBhdHRlcm4gPSBmdW5jdGlvbiAocGFyYW1zLCBraW5kKSB7XHJcblx0ICAgICAgICB2YXIgbm9kZSA9IHRoaXMuY3JlYXRlTm9kZSgpO1xyXG5cdCAgICAgICAgdmFyIGNvbXB1dGVkID0gZmFsc2U7XHJcblx0ICAgICAgICB2YXIgc2hvcnRoYW5kID0gZmFsc2U7XHJcblx0ICAgICAgICB2YXIgbWV0aG9kID0gZmFsc2U7XHJcblx0ICAgICAgICB2YXIga2V5O1xyXG5cdCAgICAgICAgdmFyIHZhbHVlO1xyXG5cdCAgICAgICAgaWYgKHRoaXMubG9va2FoZWFkLnR5cGUgPT09IDMgLyogSWRlbnRpZmllciAqLykge1xyXG5cdCAgICAgICAgICAgIHZhciBrZXlUb2tlbiA9IHRoaXMubG9va2FoZWFkO1xyXG5cdCAgICAgICAgICAgIGtleSA9IHRoaXMucGFyc2VWYXJpYWJsZUlkZW50aWZpZXIoKTtcclxuXHQgICAgICAgICAgICB2YXIgaW5pdCA9IHRoaXMuZmluYWxpemUobm9kZSwgbmV3IE5vZGUuSWRlbnRpZmllcihrZXlUb2tlbi52YWx1ZSkpO1xyXG5cdCAgICAgICAgICAgIGlmICh0aGlzLm1hdGNoKCc9JykpIHtcclxuXHQgICAgICAgICAgICAgICAgcGFyYW1zLnB1c2goa2V5VG9rZW4pO1xyXG5cdCAgICAgICAgICAgICAgICBzaG9ydGhhbmQgPSB0cnVlO1xyXG5cdCAgICAgICAgICAgICAgICB0aGlzLm5leHRUb2tlbigpO1xyXG5cdCAgICAgICAgICAgICAgICB2YXIgZXhwciA9IHRoaXMucGFyc2VBc3NpZ25tZW50RXhwcmVzc2lvbigpO1xyXG5cdCAgICAgICAgICAgICAgICB2YWx1ZSA9IHRoaXMuZmluYWxpemUodGhpcy5zdGFydE5vZGUoa2V5VG9rZW4pLCBuZXcgTm9kZS5Bc3NpZ25tZW50UGF0dGVybihpbml0LCBleHByKSk7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgIGVsc2UgaWYgKCF0aGlzLm1hdGNoKCc6JykpIHtcclxuXHQgICAgICAgICAgICAgICAgcGFyYW1zLnB1c2goa2V5VG9rZW4pO1xyXG5cdCAgICAgICAgICAgICAgICBzaG9ydGhhbmQgPSB0cnVlO1xyXG5cdCAgICAgICAgICAgICAgICB2YWx1ZSA9IGluaXQ7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgIGVsc2Uge1xyXG5cdCAgICAgICAgICAgICAgICB0aGlzLmV4cGVjdCgnOicpO1xyXG5cdCAgICAgICAgICAgICAgICB2YWx1ZSA9IHRoaXMucGFyc2VQYXR0ZXJuV2l0aERlZmF1bHQocGFyYW1zLCBraW5kKTtcclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICBlbHNlIHtcclxuXHQgICAgICAgICAgICBjb21wdXRlZCA9IHRoaXMubWF0Y2goJ1snKTtcclxuXHQgICAgICAgICAgICBrZXkgPSB0aGlzLnBhcnNlT2JqZWN0UHJvcGVydHlLZXkoKTtcclxuXHQgICAgICAgICAgICB0aGlzLmV4cGVjdCgnOicpO1xyXG5cdCAgICAgICAgICAgIHZhbHVlID0gdGhpcy5wYXJzZVBhdHRlcm5XaXRoRGVmYXVsdChwYXJhbXMsIGtpbmQpO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgcmV0dXJuIHRoaXMuZmluYWxpemUobm9kZSwgbmV3IE5vZGUuUHJvcGVydHkoJ2luaXQnLCBrZXksIGNvbXB1dGVkLCB2YWx1ZSwgbWV0aG9kLCBzaG9ydGhhbmQpKTtcclxuXHQgICAgfTtcclxuXHQgICAgUGFyc2VyLnByb3RvdHlwZS5wYXJzZU9iamVjdFBhdHRlcm4gPSBmdW5jdGlvbiAocGFyYW1zLCBraW5kKSB7XHJcblx0ICAgICAgICB2YXIgbm9kZSA9IHRoaXMuY3JlYXRlTm9kZSgpO1xyXG5cdCAgICAgICAgdmFyIHByb3BlcnRpZXMgPSBbXTtcclxuXHQgICAgICAgIHRoaXMuZXhwZWN0KCd7Jyk7XHJcblx0ICAgICAgICB3aGlsZSAoIXRoaXMubWF0Y2goJ30nKSkge1xyXG5cdCAgICAgICAgICAgIHByb3BlcnRpZXMucHVzaCh0aGlzLnBhcnNlUHJvcGVydHlQYXR0ZXJuKHBhcmFtcywga2luZCkpO1xyXG5cdCAgICAgICAgICAgIGlmICghdGhpcy5tYXRjaCgnfScpKSB7XHJcblx0ICAgICAgICAgICAgICAgIHRoaXMuZXhwZWN0KCcsJyk7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgdGhpcy5leHBlY3QoJ30nKTtcclxuXHQgICAgICAgIHJldHVybiB0aGlzLmZpbmFsaXplKG5vZGUsIG5ldyBOb2RlLk9iamVjdFBhdHRlcm4ocHJvcGVydGllcykpO1xyXG5cdCAgICB9O1xyXG5cdCAgICBQYXJzZXIucHJvdG90eXBlLnBhcnNlUGF0dGVybiA9IGZ1bmN0aW9uIChwYXJhbXMsIGtpbmQpIHtcclxuXHQgICAgICAgIHZhciBwYXR0ZXJuO1xyXG5cdCAgICAgICAgaWYgKHRoaXMubWF0Y2goJ1snKSkge1xyXG5cdCAgICAgICAgICAgIHBhdHRlcm4gPSB0aGlzLnBhcnNlQXJyYXlQYXR0ZXJuKHBhcmFtcywga2luZCk7XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICBlbHNlIGlmICh0aGlzLm1hdGNoKCd7JykpIHtcclxuXHQgICAgICAgICAgICBwYXR0ZXJuID0gdGhpcy5wYXJzZU9iamVjdFBhdHRlcm4ocGFyYW1zLCBraW5kKTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIGVsc2Uge1xyXG5cdCAgICAgICAgICAgIGlmICh0aGlzLm1hdGNoS2V5d29yZCgnbGV0JykgJiYgKGtpbmQgPT09ICdjb25zdCcgfHwga2luZCA9PT0gJ2xldCcpKSB7XHJcblx0ICAgICAgICAgICAgICAgIHRoaXMudG9sZXJhdGVVbmV4cGVjdGVkVG9rZW4odGhpcy5sb29rYWhlYWQsIG1lc3NhZ2VzXzEuTWVzc2FnZXMuTGV0SW5MZXhpY2FsQmluZGluZyk7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgIHBhcmFtcy5wdXNoKHRoaXMubG9va2FoZWFkKTtcclxuXHQgICAgICAgICAgICBwYXR0ZXJuID0gdGhpcy5wYXJzZVZhcmlhYmxlSWRlbnRpZmllcihraW5kKTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIHJldHVybiBwYXR0ZXJuO1xyXG5cdCAgICB9O1xyXG5cdCAgICBQYXJzZXIucHJvdG90eXBlLnBhcnNlUGF0dGVybldpdGhEZWZhdWx0ID0gZnVuY3Rpb24gKHBhcmFtcywga2luZCkge1xyXG5cdCAgICAgICAgdmFyIHN0YXJ0VG9rZW4gPSB0aGlzLmxvb2thaGVhZDtcclxuXHQgICAgICAgIHZhciBwYXR0ZXJuID0gdGhpcy5wYXJzZVBhdHRlcm4ocGFyYW1zLCBraW5kKTtcclxuXHQgICAgICAgIGlmICh0aGlzLm1hdGNoKCc9JykpIHtcclxuXHQgICAgICAgICAgICB0aGlzLm5leHRUb2tlbigpO1xyXG5cdCAgICAgICAgICAgIHZhciBwcmV2aW91c0FsbG93WWllbGQgPSB0aGlzLmNvbnRleHQuYWxsb3dZaWVsZDtcclxuXHQgICAgICAgICAgICB0aGlzLmNvbnRleHQuYWxsb3dZaWVsZCA9IHRydWU7XHJcblx0ICAgICAgICAgICAgdmFyIHJpZ2h0ID0gdGhpcy5pc29sYXRlQ292ZXJHcmFtbWFyKHRoaXMucGFyc2VBc3NpZ25tZW50RXhwcmVzc2lvbik7XHJcblx0ICAgICAgICAgICAgdGhpcy5jb250ZXh0LmFsbG93WWllbGQgPSBwcmV2aW91c0FsbG93WWllbGQ7XHJcblx0ICAgICAgICAgICAgcGF0dGVybiA9IHRoaXMuZmluYWxpemUodGhpcy5zdGFydE5vZGUoc3RhcnRUb2tlbiksIG5ldyBOb2RlLkFzc2lnbm1lbnRQYXR0ZXJuKHBhdHRlcm4sIHJpZ2h0KSk7XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICByZXR1cm4gcGF0dGVybjtcclxuXHQgICAgfTtcclxuXHQgICAgLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtdmFyaWFibGUtc3RhdGVtZW50XHJcblx0ICAgIFBhcnNlci5wcm90b3R5cGUucGFyc2VWYXJpYWJsZUlkZW50aWZpZXIgPSBmdW5jdGlvbiAoa2luZCkge1xyXG5cdCAgICAgICAgdmFyIG5vZGUgPSB0aGlzLmNyZWF0ZU5vZGUoKTtcclxuXHQgICAgICAgIHZhciB0b2tlbiA9IHRoaXMubmV4dFRva2VuKCk7XHJcblx0ICAgICAgICBpZiAodG9rZW4udHlwZSA9PT0gNCAvKiBLZXl3b3JkICovICYmIHRva2VuLnZhbHVlID09PSAneWllbGQnKSB7XHJcblx0ICAgICAgICAgICAgaWYgKHRoaXMuY29udGV4dC5zdHJpY3QpIHtcclxuXHQgICAgICAgICAgICAgICAgdGhpcy50b2xlcmF0ZVVuZXhwZWN0ZWRUb2tlbih0b2tlbiwgbWVzc2FnZXNfMS5NZXNzYWdlcy5TdHJpY3RSZXNlcnZlZFdvcmQpO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICBlbHNlIGlmICghdGhpcy5jb250ZXh0LmFsbG93WWllbGQpIHtcclxuXHQgICAgICAgICAgICAgICAgdGhpcy50aHJvd1VuZXhwZWN0ZWRUb2tlbih0b2tlbik7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgZWxzZSBpZiAodG9rZW4udHlwZSAhPT0gMyAvKiBJZGVudGlmaWVyICovKSB7XHJcblx0ICAgICAgICAgICAgaWYgKHRoaXMuY29udGV4dC5zdHJpY3QgJiYgdG9rZW4udHlwZSA9PT0gNCAvKiBLZXl3b3JkICovICYmIHRoaXMuc2Nhbm5lci5pc1N0cmljdE1vZGVSZXNlcnZlZFdvcmQodG9rZW4udmFsdWUpKSB7XHJcblx0ICAgICAgICAgICAgICAgIHRoaXMudG9sZXJhdGVVbmV4cGVjdGVkVG9rZW4odG9rZW4sIG1lc3NhZ2VzXzEuTWVzc2FnZXMuU3RyaWN0UmVzZXJ2ZWRXb3JkKTtcclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgZWxzZSB7XHJcblx0ICAgICAgICAgICAgICAgIGlmICh0aGlzLmNvbnRleHQuc3RyaWN0IHx8IHRva2VuLnZhbHVlICE9PSAnbGV0JyB8fCBraW5kICE9PSAndmFyJykge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgdGhpcy50aHJvd1VuZXhwZWN0ZWRUb2tlbih0b2tlbik7XHJcblx0ICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICBlbHNlIGlmICgodGhpcy5jb250ZXh0LmlzTW9kdWxlIHx8IHRoaXMuY29udGV4dC5hd2FpdCkgJiYgdG9rZW4udHlwZSA9PT0gMyAvKiBJZGVudGlmaWVyICovICYmIHRva2VuLnZhbHVlID09PSAnYXdhaXQnKSB7XHJcblx0ICAgICAgICAgICAgdGhpcy50b2xlcmF0ZVVuZXhwZWN0ZWRUb2tlbih0b2tlbik7XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICByZXR1cm4gdGhpcy5maW5hbGl6ZShub2RlLCBuZXcgTm9kZS5JZGVudGlmaWVyKHRva2VuLnZhbHVlKSk7XHJcblx0ICAgIH07XHJcblx0ICAgIFBhcnNlci5wcm90b3R5cGUucGFyc2VWYXJpYWJsZURlY2xhcmF0aW9uID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcclxuXHQgICAgICAgIHZhciBub2RlID0gdGhpcy5jcmVhdGVOb2RlKCk7XHJcblx0ICAgICAgICB2YXIgcGFyYW1zID0gW107XHJcblx0ICAgICAgICB2YXIgaWQgPSB0aGlzLnBhcnNlUGF0dGVybihwYXJhbXMsICd2YXInKTtcclxuXHQgICAgICAgIGlmICh0aGlzLmNvbnRleHQuc3RyaWN0ICYmIGlkLnR5cGUgPT09IHN5bnRheF8xLlN5bnRheC5JZGVudGlmaWVyKSB7XHJcblx0ICAgICAgICAgICAgaWYgKHRoaXMuc2Nhbm5lci5pc1Jlc3RyaWN0ZWRXb3JkKGlkLm5hbWUpKSB7XHJcblx0ICAgICAgICAgICAgICAgIHRoaXMudG9sZXJhdGVFcnJvcihtZXNzYWdlc18xLk1lc3NhZ2VzLlN0cmljdFZhck5hbWUpO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIHZhciBpbml0ID0gbnVsbDtcclxuXHQgICAgICAgIGlmICh0aGlzLm1hdGNoKCc9JykpIHtcclxuXHQgICAgICAgICAgICB0aGlzLm5leHRUb2tlbigpO1xyXG5cdCAgICAgICAgICAgIGluaXQgPSB0aGlzLmlzb2xhdGVDb3ZlckdyYW1tYXIodGhpcy5wYXJzZUFzc2lnbm1lbnRFeHByZXNzaW9uKTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIGVsc2UgaWYgKGlkLnR5cGUgIT09IHN5bnRheF8xLlN5bnRheC5JZGVudGlmaWVyICYmICFvcHRpb25zLmluRm9yKSB7XHJcblx0ICAgICAgICAgICAgdGhpcy5leHBlY3QoJz0nKTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIHJldHVybiB0aGlzLmZpbmFsaXplKG5vZGUsIG5ldyBOb2RlLlZhcmlhYmxlRGVjbGFyYXRvcihpZCwgaW5pdCkpO1xyXG5cdCAgICB9O1xyXG5cdCAgICBQYXJzZXIucHJvdG90eXBlLnBhcnNlVmFyaWFibGVEZWNsYXJhdGlvbkxpc3QgPSBmdW5jdGlvbiAob3B0aW9ucykge1xyXG5cdCAgICAgICAgdmFyIG9wdCA9IHsgaW5Gb3I6IG9wdGlvbnMuaW5Gb3IgfTtcclxuXHQgICAgICAgIHZhciBsaXN0ID0gW107XHJcblx0ICAgICAgICBsaXN0LnB1c2godGhpcy5wYXJzZVZhcmlhYmxlRGVjbGFyYXRpb24ob3B0KSk7XHJcblx0ICAgICAgICB3aGlsZSAodGhpcy5tYXRjaCgnLCcpKSB7XHJcblx0ICAgICAgICAgICAgdGhpcy5uZXh0VG9rZW4oKTtcclxuXHQgICAgICAgICAgICBsaXN0LnB1c2godGhpcy5wYXJzZVZhcmlhYmxlRGVjbGFyYXRpb24ob3B0KSk7XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICByZXR1cm4gbGlzdDtcclxuXHQgICAgfTtcclxuXHQgICAgUGFyc2VyLnByb3RvdHlwZS5wYXJzZVZhcmlhYmxlU3RhdGVtZW50ID0gZnVuY3Rpb24gKCkge1xyXG5cdCAgICAgICAgdmFyIG5vZGUgPSB0aGlzLmNyZWF0ZU5vZGUoKTtcclxuXHQgICAgICAgIHRoaXMuZXhwZWN0S2V5d29yZCgndmFyJyk7XHJcblx0ICAgICAgICB2YXIgZGVjbGFyYXRpb25zID0gdGhpcy5wYXJzZVZhcmlhYmxlRGVjbGFyYXRpb25MaXN0KHsgaW5Gb3I6IGZhbHNlIH0pO1xyXG5cdCAgICAgICAgdGhpcy5jb25zdW1lU2VtaWNvbG9uKCk7XHJcblx0ICAgICAgICByZXR1cm4gdGhpcy5maW5hbGl6ZShub2RlLCBuZXcgTm9kZS5WYXJpYWJsZURlY2xhcmF0aW9uKGRlY2xhcmF0aW9ucywgJ3ZhcicpKTtcclxuXHQgICAgfTtcclxuXHQgICAgLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtZW1wdHktc3RhdGVtZW50XHJcblx0ICAgIFBhcnNlci5wcm90b3R5cGUucGFyc2VFbXB0eVN0YXRlbWVudCA9IGZ1bmN0aW9uICgpIHtcclxuXHQgICAgICAgIHZhciBub2RlID0gdGhpcy5jcmVhdGVOb2RlKCk7XHJcblx0ICAgICAgICB0aGlzLmV4cGVjdCgnOycpO1xyXG5cdCAgICAgICAgcmV0dXJuIHRoaXMuZmluYWxpemUobm9kZSwgbmV3IE5vZGUuRW1wdHlTdGF0ZW1lbnQoKSk7XHJcblx0ICAgIH07XHJcblx0ICAgIC8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLWV4cHJlc3Npb24tc3RhdGVtZW50XHJcblx0ICAgIFBhcnNlci5wcm90b3R5cGUucGFyc2VFeHByZXNzaW9uU3RhdGVtZW50ID0gZnVuY3Rpb24gKCkge1xyXG5cdCAgICAgICAgdmFyIG5vZGUgPSB0aGlzLmNyZWF0ZU5vZGUoKTtcclxuXHQgICAgICAgIHZhciBleHByID0gdGhpcy5wYXJzZUV4cHJlc3Npb24oKTtcclxuXHQgICAgICAgIHRoaXMuY29uc3VtZVNlbWljb2xvbigpO1xyXG5cdCAgICAgICAgcmV0dXJuIHRoaXMuZmluYWxpemUobm9kZSwgbmV3IE5vZGUuRXhwcmVzc2lvblN0YXRlbWVudChleHByKSk7XHJcblx0ICAgIH07XHJcblx0ICAgIC8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLWlmLXN0YXRlbWVudFxyXG5cdCAgICBQYXJzZXIucHJvdG90eXBlLnBhcnNlSWZDbGF1c2UgPSBmdW5jdGlvbiAoKSB7XHJcblx0ICAgICAgICBpZiAodGhpcy5jb250ZXh0LnN0cmljdCAmJiB0aGlzLm1hdGNoS2V5d29yZCgnZnVuY3Rpb24nKSkge1xyXG5cdCAgICAgICAgICAgIHRoaXMudG9sZXJhdGVFcnJvcihtZXNzYWdlc18xLk1lc3NhZ2VzLlN0cmljdEZ1bmN0aW9uKTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIHJldHVybiB0aGlzLnBhcnNlU3RhdGVtZW50KCk7XHJcblx0ICAgIH07XHJcblx0ICAgIFBhcnNlci5wcm90b3R5cGUucGFyc2VJZlN0YXRlbWVudCA9IGZ1bmN0aW9uICgpIHtcclxuXHQgICAgICAgIHZhciBub2RlID0gdGhpcy5jcmVhdGVOb2RlKCk7XHJcblx0ICAgICAgICB2YXIgY29uc2VxdWVudDtcclxuXHQgICAgICAgIHZhciBhbHRlcm5hdGUgPSBudWxsO1xyXG5cdCAgICAgICAgdGhpcy5leHBlY3RLZXl3b3JkKCdpZicpO1xyXG5cdCAgICAgICAgdGhpcy5leHBlY3QoJygnKTtcclxuXHQgICAgICAgIHZhciB0ZXN0ID0gdGhpcy5wYXJzZUV4cHJlc3Npb24oKTtcclxuXHQgICAgICAgIGlmICghdGhpcy5tYXRjaCgnKScpICYmIHRoaXMuY29uZmlnLnRvbGVyYW50KSB7XHJcblx0ICAgICAgICAgICAgdGhpcy50b2xlcmF0ZVVuZXhwZWN0ZWRUb2tlbih0aGlzLm5leHRUb2tlbigpKTtcclxuXHQgICAgICAgICAgICBjb25zZXF1ZW50ID0gdGhpcy5maW5hbGl6ZSh0aGlzLmNyZWF0ZU5vZGUoKSwgbmV3IE5vZGUuRW1wdHlTdGF0ZW1lbnQoKSk7XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICBlbHNlIHtcclxuXHQgICAgICAgICAgICB0aGlzLmV4cGVjdCgnKScpO1xyXG5cdCAgICAgICAgICAgIGNvbnNlcXVlbnQgPSB0aGlzLnBhcnNlSWZDbGF1c2UoKTtcclxuXHQgICAgICAgICAgICBpZiAodGhpcy5tYXRjaEtleXdvcmQoJ2Vsc2UnKSkge1xyXG5cdCAgICAgICAgICAgICAgICB0aGlzLm5leHRUb2tlbigpO1xyXG5cdCAgICAgICAgICAgICAgICBhbHRlcm5hdGUgPSB0aGlzLnBhcnNlSWZDbGF1c2UoKTtcclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICByZXR1cm4gdGhpcy5maW5hbGl6ZShub2RlLCBuZXcgTm9kZS5JZlN0YXRlbWVudCh0ZXN0LCBjb25zZXF1ZW50LCBhbHRlcm5hdGUpKTtcclxuXHQgICAgfTtcclxuXHQgICAgLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtZG8td2hpbGUtc3RhdGVtZW50XHJcblx0ICAgIFBhcnNlci5wcm90b3R5cGUucGFyc2VEb1doaWxlU3RhdGVtZW50ID0gZnVuY3Rpb24gKCkge1xyXG5cdCAgICAgICAgdmFyIG5vZGUgPSB0aGlzLmNyZWF0ZU5vZGUoKTtcclxuXHQgICAgICAgIHRoaXMuZXhwZWN0S2V5d29yZCgnZG8nKTtcclxuXHQgICAgICAgIHZhciBwcmV2aW91c0luSXRlcmF0aW9uID0gdGhpcy5jb250ZXh0LmluSXRlcmF0aW9uO1xyXG5cdCAgICAgICAgdGhpcy5jb250ZXh0LmluSXRlcmF0aW9uID0gdHJ1ZTtcclxuXHQgICAgICAgIHZhciBib2R5ID0gdGhpcy5wYXJzZVN0YXRlbWVudCgpO1xyXG5cdCAgICAgICAgdGhpcy5jb250ZXh0LmluSXRlcmF0aW9uID0gcHJldmlvdXNJbkl0ZXJhdGlvbjtcclxuXHQgICAgICAgIHRoaXMuZXhwZWN0S2V5d29yZCgnd2hpbGUnKTtcclxuXHQgICAgICAgIHRoaXMuZXhwZWN0KCcoJyk7XHJcblx0ICAgICAgICB2YXIgdGVzdCA9IHRoaXMucGFyc2VFeHByZXNzaW9uKCk7XHJcblx0ICAgICAgICBpZiAoIXRoaXMubWF0Y2goJyknKSAmJiB0aGlzLmNvbmZpZy50b2xlcmFudCkge1xyXG5cdCAgICAgICAgICAgIHRoaXMudG9sZXJhdGVVbmV4cGVjdGVkVG9rZW4odGhpcy5uZXh0VG9rZW4oKSk7XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICBlbHNlIHtcclxuXHQgICAgICAgICAgICB0aGlzLmV4cGVjdCgnKScpO1xyXG5cdCAgICAgICAgICAgIGlmICh0aGlzLm1hdGNoKCc7JykpIHtcclxuXHQgICAgICAgICAgICAgICAgdGhpcy5uZXh0VG9rZW4oKTtcclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICByZXR1cm4gdGhpcy5maW5hbGl6ZShub2RlLCBuZXcgTm9kZS5Eb1doaWxlU3RhdGVtZW50KGJvZHksIHRlc3QpKTtcclxuXHQgICAgfTtcclxuXHQgICAgLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtd2hpbGUtc3RhdGVtZW50XHJcblx0ICAgIFBhcnNlci5wcm90b3R5cGUucGFyc2VXaGlsZVN0YXRlbWVudCA9IGZ1bmN0aW9uICgpIHtcclxuXHQgICAgICAgIHZhciBub2RlID0gdGhpcy5jcmVhdGVOb2RlKCk7XHJcblx0ICAgICAgICB2YXIgYm9keTtcclxuXHQgICAgICAgIHRoaXMuZXhwZWN0S2V5d29yZCgnd2hpbGUnKTtcclxuXHQgICAgICAgIHRoaXMuZXhwZWN0KCcoJyk7XHJcblx0ICAgICAgICB2YXIgdGVzdCA9IHRoaXMucGFyc2VFeHByZXNzaW9uKCk7XHJcblx0ICAgICAgICBpZiAoIXRoaXMubWF0Y2goJyknKSAmJiB0aGlzLmNvbmZpZy50b2xlcmFudCkge1xyXG5cdCAgICAgICAgICAgIHRoaXMudG9sZXJhdGVVbmV4cGVjdGVkVG9rZW4odGhpcy5uZXh0VG9rZW4oKSk7XHJcblx0ICAgICAgICAgICAgYm9keSA9IHRoaXMuZmluYWxpemUodGhpcy5jcmVhdGVOb2RlKCksIG5ldyBOb2RlLkVtcHR5U3RhdGVtZW50KCkpO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgZWxzZSB7XHJcblx0ICAgICAgICAgICAgdGhpcy5leHBlY3QoJyknKTtcclxuXHQgICAgICAgICAgICB2YXIgcHJldmlvdXNJbkl0ZXJhdGlvbiA9IHRoaXMuY29udGV4dC5pbkl0ZXJhdGlvbjtcclxuXHQgICAgICAgICAgICB0aGlzLmNvbnRleHQuaW5JdGVyYXRpb24gPSB0cnVlO1xyXG5cdCAgICAgICAgICAgIGJvZHkgPSB0aGlzLnBhcnNlU3RhdGVtZW50KCk7XHJcblx0ICAgICAgICAgICAgdGhpcy5jb250ZXh0LmluSXRlcmF0aW9uID0gcHJldmlvdXNJbkl0ZXJhdGlvbjtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIHJldHVybiB0aGlzLmZpbmFsaXplKG5vZGUsIG5ldyBOb2RlLldoaWxlU3RhdGVtZW50KHRlc3QsIGJvZHkpKTtcclxuXHQgICAgfTtcclxuXHQgICAgLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtZm9yLXN0YXRlbWVudFxyXG5cdCAgICAvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1mb3ItaW4tYW5kLWZvci1vZi1zdGF0ZW1lbnRzXHJcblx0ICAgIFBhcnNlci5wcm90b3R5cGUucGFyc2VGb3JTdGF0ZW1lbnQgPSBmdW5jdGlvbiAoKSB7XHJcblx0ICAgICAgICB2YXIgaW5pdCA9IG51bGw7XHJcblx0ICAgICAgICB2YXIgdGVzdCA9IG51bGw7XHJcblx0ICAgICAgICB2YXIgdXBkYXRlID0gbnVsbDtcclxuXHQgICAgICAgIHZhciBmb3JJbiA9IHRydWU7XHJcblx0ICAgICAgICB2YXIgbGVmdCwgcmlnaHQ7XHJcblx0ICAgICAgICB2YXIgbm9kZSA9IHRoaXMuY3JlYXRlTm9kZSgpO1xyXG5cdCAgICAgICAgdGhpcy5leHBlY3RLZXl3b3JkKCdmb3InKTtcclxuXHQgICAgICAgIHRoaXMuZXhwZWN0KCcoJyk7XHJcblx0ICAgICAgICBpZiAodGhpcy5tYXRjaCgnOycpKSB7XHJcblx0ICAgICAgICAgICAgdGhpcy5uZXh0VG9rZW4oKTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIGVsc2Uge1xyXG5cdCAgICAgICAgICAgIGlmICh0aGlzLm1hdGNoS2V5d29yZCgndmFyJykpIHtcclxuXHQgICAgICAgICAgICAgICAgaW5pdCA9IHRoaXMuY3JlYXRlTm9kZSgpO1xyXG5cdCAgICAgICAgICAgICAgICB0aGlzLm5leHRUb2tlbigpO1xyXG5cdCAgICAgICAgICAgICAgICB2YXIgcHJldmlvdXNBbGxvd0luID0gdGhpcy5jb250ZXh0LmFsbG93SW47XHJcblx0ICAgICAgICAgICAgICAgIHRoaXMuY29udGV4dC5hbGxvd0luID0gZmFsc2U7XHJcblx0ICAgICAgICAgICAgICAgIHZhciBkZWNsYXJhdGlvbnMgPSB0aGlzLnBhcnNlVmFyaWFibGVEZWNsYXJhdGlvbkxpc3QoeyBpbkZvcjogdHJ1ZSB9KTtcclxuXHQgICAgICAgICAgICAgICAgdGhpcy5jb250ZXh0LmFsbG93SW4gPSBwcmV2aW91c0FsbG93SW47XHJcblx0ICAgICAgICAgICAgICAgIGlmIChkZWNsYXJhdGlvbnMubGVuZ3RoID09PSAxICYmIHRoaXMubWF0Y2hLZXl3b3JkKCdpbicpKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgZGVjbCA9IGRlY2xhcmF0aW9uc1swXTtcclxuXHQgICAgICAgICAgICAgICAgICAgIGlmIChkZWNsLmluaXQgJiYgKGRlY2wuaWQudHlwZSA9PT0gc3ludGF4XzEuU3ludGF4LkFycmF5UGF0dGVybiB8fCBkZWNsLmlkLnR5cGUgPT09IHN5bnRheF8xLlN5bnRheC5PYmplY3RQYXR0ZXJuIHx8IHRoaXMuY29udGV4dC5zdHJpY3QpKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy50b2xlcmF0ZUVycm9yKG1lc3NhZ2VzXzEuTWVzc2FnZXMuRm9ySW5PZkxvb3BJbml0aWFsaXplciwgJ2Zvci1pbicpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICAgICAgaW5pdCA9IHRoaXMuZmluYWxpemUoaW5pdCwgbmV3IE5vZGUuVmFyaWFibGVEZWNsYXJhdGlvbihkZWNsYXJhdGlvbnMsICd2YXInKSk7XHJcblx0ICAgICAgICAgICAgICAgICAgICB0aGlzLm5leHRUb2tlbigpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgbGVmdCA9IGluaXQ7XHJcblx0ICAgICAgICAgICAgICAgICAgICByaWdodCA9IHRoaXMucGFyc2VFeHByZXNzaW9uKCk7XHJcblx0ICAgICAgICAgICAgICAgICAgICBpbml0ID0gbnVsbDtcclxuXHQgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICBlbHNlIGlmIChkZWNsYXJhdGlvbnMubGVuZ3RoID09PSAxICYmIGRlY2xhcmF0aW9uc1swXS5pbml0ID09PSBudWxsICYmIHRoaXMubWF0Y2hDb250ZXh0dWFsS2V5d29yZCgnb2YnKSkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgaW5pdCA9IHRoaXMuZmluYWxpemUoaW5pdCwgbmV3IE5vZGUuVmFyaWFibGVEZWNsYXJhdGlvbihkZWNsYXJhdGlvbnMsICd2YXInKSk7XHJcblx0ICAgICAgICAgICAgICAgICAgICB0aGlzLm5leHRUb2tlbigpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgbGVmdCA9IGluaXQ7XHJcblx0ICAgICAgICAgICAgICAgICAgICByaWdodCA9IHRoaXMucGFyc2VBc3NpZ25tZW50RXhwcmVzc2lvbigpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgaW5pdCA9IG51bGw7XHJcblx0ICAgICAgICAgICAgICAgICAgICBmb3JJbiA9IGZhbHNlO1xyXG5cdCAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgIGVsc2Uge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgaW5pdCA9IHRoaXMuZmluYWxpemUoaW5pdCwgbmV3IE5vZGUuVmFyaWFibGVEZWNsYXJhdGlvbihkZWNsYXJhdGlvbnMsICd2YXInKSk7XHJcblx0ICAgICAgICAgICAgICAgICAgICB0aGlzLmV4cGVjdCgnOycpO1xyXG5cdCAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMubWF0Y2hLZXl3b3JkKCdjb25zdCcpIHx8IHRoaXMubWF0Y2hLZXl3b3JkKCdsZXQnKSkge1xyXG5cdCAgICAgICAgICAgICAgICBpbml0ID0gdGhpcy5jcmVhdGVOb2RlKCk7XHJcblx0ICAgICAgICAgICAgICAgIHZhciBraW5kID0gdGhpcy5uZXh0VG9rZW4oKS52YWx1ZTtcclxuXHQgICAgICAgICAgICAgICAgaWYgKCF0aGlzLmNvbnRleHQuc3RyaWN0ICYmIHRoaXMubG9va2FoZWFkLnZhbHVlID09PSAnaW4nKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICBpbml0ID0gdGhpcy5maW5hbGl6ZShpbml0LCBuZXcgTm9kZS5JZGVudGlmaWVyKGtpbmQpKTtcclxuXHQgICAgICAgICAgICAgICAgICAgIHRoaXMubmV4dFRva2VuKCk7XHJcblx0ICAgICAgICAgICAgICAgICAgICBsZWZ0ID0gaW5pdDtcclxuXHQgICAgICAgICAgICAgICAgICAgIHJpZ2h0ID0gdGhpcy5wYXJzZUV4cHJlc3Npb24oKTtcclxuXHQgICAgICAgICAgICAgICAgICAgIGluaXQgPSBudWxsO1xyXG5cdCAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgIGVsc2Uge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIHByZXZpb3VzQWxsb3dJbiA9IHRoaXMuY29udGV4dC5hbGxvd0luO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgdGhpcy5jb250ZXh0LmFsbG93SW4gPSBmYWxzZTtcclxuXHQgICAgICAgICAgICAgICAgICAgIHZhciBkZWNsYXJhdGlvbnMgPSB0aGlzLnBhcnNlQmluZGluZ0xpc3Qoa2luZCwgeyBpbkZvcjogdHJ1ZSB9KTtcclxuXHQgICAgICAgICAgICAgICAgICAgIHRoaXMuY29udGV4dC5hbGxvd0luID0gcHJldmlvdXNBbGxvd0luO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKGRlY2xhcmF0aW9ucy5sZW5ndGggPT09IDEgJiYgZGVjbGFyYXRpb25zWzBdLmluaXQgPT09IG51bGwgJiYgdGhpcy5tYXRjaEtleXdvcmQoJ2luJykpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBpbml0ID0gdGhpcy5maW5hbGl6ZShpbml0LCBuZXcgTm9kZS5WYXJpYWJsZURlY2xhcmF0aW9uKGRlY2xhcmF0aW9ucywga2luZCkpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubmV4dFRva2VuKCk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgbGVmdCA9IGluaXQ7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcmlnaHQgPSB0aGlzLnBhcnNlRXhwcmVzc2lvbigpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGluaXQgPSBudWxsO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoZGVjbGFyYXRpb25zLmxlbmd0aCA9PT0gMSAmJiBkZWNsYXJhdGlvbnNbMF0uaW5pdCA9PT0gbnVsbCAmJiB0aGlzLm1hdGNoQ29udGV4dHVhbEtleXdvcmQoJ29mJykpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBpbml0ID0gdGhpcy5maW5hbGl6ZShpbml0LCBuZXcgTm9kZS5WYXJpYWJsZURlY2xhcmF0aW9uKGRlY2xhcmF0aW9ucywga2luZCkpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubmV4dFRva2VuKCk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgbGVmdCA9IGluaXQ7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcmlnaHQgPSB0aGlzLnBhcnNlQXNzaWdubWVudEV4cHJlc3Npb24oKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBpbml0ID0gbnVsbDtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBmb3JJbiA9IGZhbHNlO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jb25zdW1lU2VtaWNvbG9uKCk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgaW5pdCA9IHRoaXMuZmluYWxpemUoaW5pdCwgbmV3IE5vZGUuVmFyaWFibGVEZWNsYXJhdGlvbihkZWNsYXJhdGlvbnMsIGtpbmQpKTtcclxuXHQgICAgICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICBlbHNlIHtcclxuXHQgICAgICAgICAgICAgICAgdmFyIGluaXRTdGFydFRva2VuID0gdGhpcy5sb29rYWhlYWQ7XHJcblx0ICAgICAgICAgICAgICAgIHZhciBwcmV2aW91c0FsbG93SW4gPSB0aGlzLmNvbnRleHQuYWxsb3dJbjtcclxuXHQgICAgICAgICAgICAgICAgdGhpcy5jb250ZXh0LmFsbG93SW4gPSBmYWxzZTtcclxuXHQgICAgICAgICAgICAgICAgaW5pdCA9IHRoaXMuaW5oZXJpdENvdmVyR3JhbW1hcih0aGlzLnBhcnNlQXNzaWdubWVudEV4cHJlc3Npb24pO1xyXG5cdCAgICAgICAgICAgICAgICB0aGlzLmNvbnRleHQuYWxsb3dJbiA9IHByZXZpb3VzQWxsb3dJbjtcclxuXHQgICAgICAgICAgICAgICAgaWYgKHRoaXMubWF0Y2hLZXl3b3JkKCdpbicpKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICBpZiAoIXRoaXMuY29udGV4dC5pc0Fzc2lnbm1lbnRUYXJnZXQgfHwgaW5pdC50eXBlID09PSBzeW50YXhfMS5TeW50YXguQXNzaWdubWVudEV4cHJlc3Npb24pIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnRvbGVyYXRlRXJyb3IobWVzc2FnZXNfMS5NZXNzYWdlcy5JbnZhbGlkTEhTSW5Gb3JJbik7XHJcblx0ICAgICAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgICAgICB0aGlzLm5leHRUb2tlbigpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgdGhpcy5yZWludGVycHJldEV4cHJlc3Npb25Bc1BhdHRlcm4oaW5pdCk7XHJcblx0ICAgICAgICAgICAgICAgICAgICBsZWZ0ID0gaW5pdDtcclxuXHQgICAgICAgICAgICAgICAgICAgIHJpZ2h0ID0gdGhpcy5wYXJzZUV4cHJlc3Npb24oKTtcclxuXHQgICAgICAgICAgICAgICAgICAgIGluaXQgPSBudWxsO1xyXG5cdCAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMubWF0Y2hDb250ZXh0dWFsS2V5d29yZCgnb2YnKSkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKCF0aGlzLmNvbnRleHQuaXNBc3NpZ25tZW50VGFyZ2V0IHx8IGluaXQudHlwZSA9PT0gc3ludGF4XzEuU3ludGF4LkFzc2lnbm1lbnRFeHByZXNzaW9uKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy50b2xlcmF0ZUVycm9yKG1lc3NhZ2VzXzEuTWVzc2FnZXMuSW52YWxpZExIU0luRm9yTG9vcCk7XHJcblx0ICAgICAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgICAgICB0aGlzLm5leHRUb2tlbigpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgdGhpcy5yZWludGVycHJldEV4cHJlc3Npb25Bc1BhdHRlcm4oaW5pdCk7XHJcblx0ICAgICAgICAgICAgICAgICAgICBsZWZ0ID0gaW5pdDtcclxuXHQgICAgICAgICAgICAgICAgICAgIHJpZ2h0ID0gdGhpcy5wYXJzZUFzc2lnbm1lbnRFeHByZXNzaW9uKCk7XHJcblx0ICAgICAgICAgICAgICAgICAgICBpbml0ID0gbnVsbDtcclxuXHQgICAgICAgICAgICAgICAgICAgIGZvckluID0gZmFsc2U7XHJcblx0ICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgZWxzZSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5tYXRjaCgnLCcpKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGluaXRTZXEgPSBbaW5pdF07XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgd2hpbGUgKHRoaXMubWF0Y2goJywnKSkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm5leHRUb2tlbigpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbml0U2VxLnB1c2godGhpcy5pc29sYXRlQ292ZXJHcmFtbWFyKHRoaXMucGFyc2VBc3NpZ25tZW50RXhwcmVzc2lvbikpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBpbml0ID0gdGhpcy5maW5hbGl6ZSh0aGlzLnN0YXJ0Tm9kZShpbml0U3RhcnRUb2tlbiksIG5ldyBOb2RlLlNlcXVlbmNlRXhwcmVzc2lvbihpbml0U2VxKSk7XHJcblx0ICAgICAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgICAgICB0aGlzLmV4cGVjdCgnOycpO1xyXG5cdCAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgaWYgKHR5cGVvZiBsZWZ0ID09PSAndW5kZWZpbmVkJykge1xyXG5cdCAgICAgICAgICAgIGlmICghdGhpcy5tYXRjaCgnOycpKSB7XHJcblx0ICAgICAgICAgICAgICAgIHRlc3QgPSB0aGlzLnBhcnNlRXhwcmVzc2lvbigpO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICB0aGlzLmV4cGVjdCgnOycpO1xyXG5cdCAgICAgICAgICAgIGlmICghdGhpcy5tYXRjaCgnKScpKSB7XHJcblx0ICAgICAgICAgICAgICAgIHVwZGF0ZSA9IHRoaXMucGFyc2VFeHByZXNzaW9uKCk7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgdmFyIGJvZHk7XHJcblx0ICAgICAgICBpZiAoIXRoaXMubWF0Y2goJyknKSAmJiB0aGlzLmNvbmZpZy50b2xlcmFudCkge1xyXG5cdCAgICAgICAgICAgIHRoaXMudG9sZXJhdGVVbmV4cGVjdGVkVG9rZW4odGhpcy5uZXh0VG9rZW4oKSk7XHJcblx0ICAgICAgICAgICAgYm9keSA9IHRoaXMuZmluYWxpemUodGhpcy5jcmVhdGVOb2RlKCksIG5ldyBOb2RlLkVtcHR5U3RhdGVtZW50KCkpO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgZWxzZSB7XHJcblx0ICAgICAgICAgICAgdGhpcy5leHBlY3QoJyknKTtcclxuXHQgICAgICAgICAgICB2YXIgcHJldmlvdXNJbkl0ZXJhdGlvbiA9IHRoaXMuY29udGV4dC5pbkl0ZXJhdGlvbjtcclxuXHQgICAgICAgICAgICB0aGlzLmNvbnRleHQuaW5JdGVyYXRpb24gPSB0cnVlO1xyXG5cdCAgICAgICAgICAgIGJvZHkgPSB0aGlzLmlzb2xhdGVDb3ZlckdyYW1tYXIodGhpcy5wYXJzZVN0YXRlbWVudCk7XHJcblx0ICAgICAgICAgICAgdGhpcy5jb250ZXh0LmluSXRlcmF0aW9uID0gcHJldmlvdXNJbkl0ZXJhdGlvbjtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIHJldHVybiAodHlwZW9mIGxlZnQgPT09ICd1bmRlZmluZWQnKSA/XHJcblx0ICAgICAgICAgICAgdGhpcy5maW5hbGl6ZShub2RlLCBuZXcgTm9kZS5Gb3JTdGF0ZW1lbnQoaW5pdCwgdGVzdCwgdXBkYXRlLCBib2R5KSkgOlxyXG5cdCAgICAgICAgICAgIGZvckluID8gdGhpcy5maW5hbGl6ZShub2RlLCBuZXcgTm9kZS5Gb3JJblN0YXRlbWVudChsZWZ0LCByaWdodCwgYm9keSkpIDpcclxuXHQgICAgICAgICAgICAgICAgdGhpcy5maW5hbGl6ZShub2RlLCBuZXcgTm9kZS5Gb3JPZlN0YXRlbWVudChsZWZ0LCByaWdodCwgYm9keSkpO1xyXG5cdCAgICB9O1xyXG5cdCAgICAvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1jb250aW51ZS1zdGF0ZW1lbnRcclxuXHQgICAgUGFyc2VyLnByb3RvdHlwZS5wYXJzZUNvbnRpbnVlU3RhdGVtZW50ID0gZnVuY3Rpb24gKCkge1xyXG5cdCAgICAgICAgdmFyIG5vZGUgPSB0aGlzLmNyZWF0ZU5vZGUoKTtcclxuXHQgICAgICAgIHRoaXMuZXhwZWN0S2V5d29yZCgnY29udGludWUnKTtcclxuXHQgICAgICAgIHZhciBsYWJlbCA9IG51bGw7XHJcblx0ICAgICAgICBpZiAodGhpcy5sb29rYWhlYWQudHlwZSA9PT0gMyAvKiBJZGVudGlmaWVyICovICYmICF0aGlzLmhhc0xpbmVUZXJtaW5hdG9yKSB7XHJcblx0ICAgICAgICAgICAgdmFyIGlkID0gdGhpcy5wYXJzZVZhcmlhYmxlSWRlbnRpZmllcigpO1xyXG5cdCAgICAgICAgICAgIGxhYmVsID0gaWQ7XHJcblx0ICAgICAgICAgICAgdmFyIGtleSA9ICckJyArIGlkLm5hbWU7XHJcblx0ICAgICAgICAgICAgaWYgKCFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodGhpcy5jb250ZXh0LmxhYmVsU2V0LCBrZXkpKSB7XHJcblx0ICAgICAgICAgICAgICAgIHRoaXMudGhyb3dFcnJvcihtZXNzYWdlc18xLk1lc3NhZ2VzLlVua25vd25MYWJlbCwgaWQubmFtZSk7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgdGhpcy5jb25zdW1lU2VtaWNvbG9uKCk7XHJcblx0ICAgICAgICBpZiAobGFiZWwgPT09IG51bGwgJiYgIXRoaXMuY29udGV4dC5pbkl0ZXJhdGlvbikge1xyXG5cdCAgICAgICAgICAgIHRoaXMudGhyb3dFcnJvcihtZXNzYWdlc18xLk1lc3NhZ2VzLklsbGVnYWxDb250aW51ZSk7XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICByZXR1cm4gdGhpcy5maW5hbGl6ZShub2RlLCBuZXcgTm9kZS5Db250aW51ZVN0YXRlbWVudChsYWJlbCkpO1xyXG5cdCAgICB9O1xyXG5cdCAgICAvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1icmVhay1zdGF0ZW1lbnRcclxuXHQgICAgUGFyc2VyLnByb3RvdHlwZS5wYXJzZUJyZWFrU3RhdGVtZW50ID0gZnVuY3Rpb24gKCkge1xyXG5cdCAgICAgICAgdmFyIG5vZGUgPSB0aGlzLmNyZWF0ZU5vZGUoKTtcclxuXHQgICAgICAgIHRoaXMuZXhwZWN0S2V5d29yZCgnYnJlYWsnKTtcclxuXHQgICAgICAgIHZhciBsYWJlbCA9IG51bGw7XHJcblx0ICAgICAgICBpZiAodGhpcy5sb29rYWhlYWQudHlwZSA9PT0gMyAvKiBJZGVudGlmaWVyICovICYmICF0aGlzLmhhc0xpbmVUZXJtaW5hdG9yKSB7XHJcblx0ICAgICAgICAgICAgdmFyIGlkID0gdGhpcy5wYXJzZVZhcmlhYmxlSWRlbnRpZmllcigpO1xyXG5cdCAgICAgICAgICAgIHZhciBrZXkgPSAnJCcgKyBpZC5uYW1lO1xyXG5cdCAgICAgICAgICAgIGlmICghT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHRoaXMuY29udGV4dC5sYWJlbFNldCwga2V5KSkge1xyXG5cdCAgICAgICAgICAgICAgICB0aGlzLnRocm93RXJyb3IobWVzc2FnZXNfMS5NZXNzYWdlcy5Vbmtub3duTGFiZWwsIGlkLm5hbWUpO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICBsYWJlbCA9IGlkO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgdGhpcy5jb25zdW1lU2VtaWNvbG9uKCk7XHJcblx0ICAgICAgICBpZiAobGFiZWwgPT09IG51bGwgJiYgIXRoaXMuY29udGV4dC5pbkl0ZXJhdGlvbiAmJiAhdGhpcy5jb250ZXh0LmluU3dpdGNoKSB7XHJcblx0ICAgICAgICAgICAgdGhpcy50aHJvd0Vycm9yKG1lc3NhZ2VzXzEuTWVzc2FnZXMuSWxsZWdhbEJyZWFrKTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIHJldHVybiB0aGlzLmZpbmFsaXplKG5vZGUsIG5ldyBOb2RlLkJyZWFrU3RhdGVtZW50KGxhYmVsKSk7XHJcblx0ICAgIH07XHJcblx0ICAgIC8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLXJldHVybi1zdGF0ZW1lbnRcclxuXHQgICAgUGFyc2VyLnByb3RvdHlwZS5wYXJzZVJldHVyblN0YXRlbWVudCA9IGZ1bmN0aW9uICgpIHtcclxuXHQgICAgICAgIGlmICghdGhpcy5jb250ZXh0LmluRnVuY3Rpb25Cb2R5KSB7XHJcblx0ICAgICAgICAgICAgdGhpcy50b2xlcmF0ZUVycm9yKG1lc3NhZ2VzXzEuTWVzc2FnZXMuSWxsZWdhbFJldHVybik7XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICB2YXIgbm9kZSA9IHRoaXMuY3JlYXRlTm9kZSgpO1xyXG5cdCAgICAgICAgdGhpcy5leHBlY3RLZXl3b3JkKCdyZXR1cm4nKTtcclxuXHQgICAgICAgIHZhciBoYXNBcmd1bWVudCA9ICF0aGlzLm1hdGNoKCc7JykgJiYgIXRoaXMubWF0Y2goJ30nKSAmJlxyXG5cdCAgICAgICAgICAgICF0aGlzLmhhc0xpbmVUZXJtaW5hdG9yICYmIHRoaXMubG9va2FoZWFkLnR5cGUgIT09IDIgLyogRU9GICovO1xyXG5cdCAgICAgICAgdmFyIGFyZ3VtZW50ID0gaGFzQXJndW1lbnQgPyB0aGlzLnBhcnNlRXhwcmVzc2lvbigpIDogbnVsbDtcclxuXHQgICAgICAgIHRoaXMuY29uc3VtZVNlbWljb2xvbigpO1xyXG5cdCAgICAgICAgcmV0dXJuIHRoaXMuZmluYWxpemUobm9kZSwgbmV3IE5vZGUuUmV0dXJuU3RhdGVtZW50KGFyZ3VtZW50KSk7XHJcblx0ICAgIH07XHJcblx0ICAgIC8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLXdpdGgtc3RhdGVtZW50XHJcblx0ICAgIFBhcnNlci5wcm90b3R5cGUucGFyc2VXaXRoU3RhdGVtZW50ID0gZnVuY3Rpb24gKCkge1xyXG5cdCAgICAgICAgaWYgKHRoaXMuY29udGV4dC5zdHJpY3QpIHtcclxuXHQgICAgICAgICAgICB0aGlzLnRvbGVyYXRlRXJyb3IobWVzc2FnZXNfMS5NZXNzYWdlcy5TdHJpY3RNb2RlV2l0aCk7XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICB2YXIgbm9kZSA9IHRoaXMuY3JlYXRlTm9kZSgpO1xyXG5cdCAgICAgICAgdmFyIGJvZHk7XHJcblx0ICAgICAgICB0aGlzLmV4cGVjdEtleXdvcmQoJ3dpdGgnKTtcclxuXHQgICAgICAgIHRoaXMuZXhwZWN0KCcoJyk7XHJcblx0ICAgICAgICB2YXIgb2JqZWN0ID0gdGhpcy5wYXJzZUV4cHJlc3Npb24oKTtcclxuXHQgICAgICAgIGlmICghdGhpcy5tYXRjaCgnKScpICYmIHRoaXMuY29uZmlnLnRvbGVyYW50KSB7XHJcblx0ICAgICAgICAgICAgdGhpcy50b2xlcmF0ZVVuZXhwZWN0ZWRUb2tlbih0aGlzLm5leHRUb2tlbigpKTtcclxuXHQgICAgICAgICAgICBib2R5ID0gdGhpcy5maW5hbGl6ZSh0aGlzLmNyZWF0ZU5vZGUoKSwgbmV3IE5vZGUuRW1wdHlTdGF0ZW1lbnQoKSk7XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICBlbHNlIHtcclxuXHQgICAgICAgICAgICB0aGlzLmV4cGVjdCgnKScpO1xyXG5cdCAgICAgICAgICAgIGJvZHkgPSB0aGlzLnBhcnNlU3RhdGVtZW50KCk7XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICByZXR1cm4gdGhpcy5maW5hbGl6ZShub2RlLCBuZXcgTm9kZS5XaXRoU3RhdGVtZW50KG9iamVjdCwgYm9keSkpO1xyXG5cdCAgICB9O1xyXG5cdCAgICAvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1zd2l0Y2gtc3RhdGVtZW50XHJcblx0ICAgIFBhcnNlci5wcm90b3R5cGUucGFyc2VTd2l0Y2hDYXNlID0gZnVuY3Rpb24gKCkge1xyXG5cdCAgICAgICAgdmFyIG5vZGUgPSB0aGlzLmNyZWF0ZU5vZGUoKTtcclxuXHQgICAgICAgIHZhciB0ZXN0O1xyXG5cdCAgICAgICAgaWYgKHRoaXMubWF0Y2hLZXl3b3JkKCdkZWZhdWx0JykpIHtcclxuXHQgICAgICAgICAgICB0aGlzLm5leHRUb2tlbigpO1xyXG5cdCAgICAgICAgICAgIHRlc3QgPSBudWxsO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgZWxzZSB7XHJcblx0ICAgICAgICAgICAgdGhpcy5leHBlY3RLZXl3b3JkKCdjYXNlJyk7XHJcblx0ICAgICAgICAgICAgdGVzdCA9IHRoaXMucGFyc2VFeHByZXNzaW9uKCk7XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICB0aGlzLmV4cGVjdCgnOicpO1xyXG5cdCAgICAgICAgdmFyIGNvbnNlcXVlbnQgPSBbXTtcclxuXHQgICAgICAgIHdoaWxlICh0cnVlKSB7XHJcblx0ICAgICAgICAgICAgaWYgKHRoaXMubWF0Y2goJ30nKSB8fCB0aGlzLm1hdGNoS2V5d29yZCgnZGVmYXVsdCcpIHx8IHRoaXMubWF0Y2hLZXl3b3JkKCdjYXNlJykpIHtcclxuXHQgICAgICAgICAgICAgICAgYnJlYWs7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgIGNvbnNlcXVlbnQucHVzaCh0aGlzLnBhcnNlU3RhdGVtZW50TGlzdEl0ZW0oKSk7XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICByZXR1cm4gdGhpcy5maW5hbGl6ZShub2RlLCBuZXcgTm9kZS5Td2l0Y2hDYXNlKHRlc3QsIGNvbnNlcXVlbnQpKTtcclxuXHQgICAgfTtcclxuXHQgICAgUGFyc2VyLnByb3RvdHlwZS5wYXJzZVN3aXRjaFN0YXRlbWVudCA9IGZ1bmN0aW9uICgpIHtcclxuXHQgICAgICAgIHZhciBub2RlID0gdGhpcy5jcmVhdGVOb2RlKCk7XHJcblx0ICAgICAgICB0aGlzLmV4cGVjdEtleXdvcmQoJ3N3aXRjaCcpO1xyXG5cdCAgICAgICAgdGhpcy5leHBlY3QoJygnKTtcclxuXHQgICAgICAgIHZhciBkaXNjcmltaW5hbnQgPSB0aGlzLnBhcnNlRXhwcmVzc2lvbigpO1xyXG5cdCAgICAgICAgdGhpcy5leHBlY3QoJyknKTtcclxuXHQgICAgICAgIHZhciBwcmV2aW91c0luU3dpdGNoID0gdGhpcy5jb250ZXh0LmluU3dpdGNoO1xyXG5cdCAgICAgICAgdGhpcy5jb250ZXh0LmluU3dpdGNoID0gdHJ1ZTtcclxuXHQgICAgICAgIHZhciBjYXNlcyA9IFtdO1xyXG5cdCAgICAgICAgdmFyIGRlZmF1bHRGb3VuZCA9IGZhbHNlO1xyXG5cdCAgICAgICAgdGhpcy5leHBlY3QoJ3snKTtcclxuXHQgICAgICAgIHdoaWxlICh0cnVlKSB7XHJcblx0ICAgICAgICAgICAgaWYgKHRoaXMubWF0Y2goJ30nKSkge1xyXG5cdCAgICAgICAgICAgICAgICBicmVhaztcclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgdmFyIGNsYXVzZSA9IHRoaXMucGFyc2VTd2l0Y2hDYXNlKCk7XHJcblx0ICAgICAgICAgICAgaWYgKGNsYXVzZS50ZXN0ID09PSBudWxsKSB7XHJcblx0ICAgICAgICAgICAgICAgIGlmIChkZWZhdWx0Rm91bmQpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgIHRoaXMudGhyb3dFcnJvcihtZXNzYWdlc18xLk1lc3NhZ2VzLk11bHRpcGxlRGVmYXVsdHNJblN3aXRjaCk7XHJcblx0ICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgZGVmYXVsdEZvdW5kID0gdHJ1ZTtcclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgY2FzZXMucHVzaChjbGF1c2UpO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgdGhpcy5leHBlY3QoJ30nKTtcclxuXHQgICAgICAgIHRoaXMuY29udGV4dC5pblN3aXRjaCA9IHByZXZpb3VzSW5Td2l0Y2g7XHJcblx0ICAgICAgICByZXR1cm4gdGhpcy5maW5hbGl6ZShub2RlLCBuZXcgTm9kZS5Td2l0Y2hTdGF0ZW1lbnQoZGlzY3JpbWluYW50LCBjYXNlcykpO1xyXG5cdCAgICB9O1xyXG5cdCAgICAvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1sYWJlbGxlZC1zdGF0ZW1lbnRzXHJcblx0ICAgIFBhcnNlci5wcm90b3R5cGUucGFyc2VMYWJlbGxlZFN0YXRlbWVudCA9IGZ1bmN0aW9uICgpIHtcclxuXHQgICAgICAgIHZhciBub2RlID0gdGhpcy5jcmVhdGVOb2RlKCk7XHJcblx0ICAgICAgICB2YXIgZXhwciA9IHRoaXMucGFyc2VFeHByZXNzaW9uKCk7XHJcblx0ICAgICAgICB2YXIgc3RhdGVtZW50O1xyXG5cdCAgICAgICAgaWYgKChleHByLnR5cGUgPT09IHN5bnRheF8xLlN5bnRheC5JZGVudGlmaWVyKSAmJiB0aGlzLm1hdGNoKCc6JykpIHtcclxuXHQgICAgICAgICAgICB0aGlzLm5leHRUb2tlbigpO1xyXG5cdCAgICAgICAgICAgIHZhciBpZCA9IGV4cHI7XHJcblx0ICAgICAgICAgICAgdmFyIGtleSA9ICckJyArIGlkLm5hbWU7XHJcblx0ICAgICAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh0aGlzLmNvbnRleHQubGFiZWxTZXQsIGtleSkpIHtcclxuXHQgICAgICAgICAgICAgICAgdGhpcy50aHJvd0Vycm9yKG1lc3NhZ2VzXzEuTWVzc2FnZXMuUmVkZWNsYXJhdGlvbiwgJ0xhYmVsJywgaWQubmFtZSk7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgIHRoaXMuY29udGV4dC5sYWJlbFNldFtrZXldID0gdHJ1ZTtcclxuXHQgICAgICAgICAgICB2YXIgYm9keSA9IHZvaWQgMDtcclxuXHQgICAgICAgICAgICBpZiAodGhpcy5tYXRjaEtleXdvcmQoJ2NsYXNzJykpIHtcclxuXHQgICAgICAgICAgICAgICAgdGhpcy50b2xlcmF0ZVVuZXhwZWN0ZWRUb2tlbih0aGlzLmxvb2thaGVhZCk7XHJcblx0ICAgICAgICAgICAgICAgIGJvZHkgPSB0aGlzLnBhcnNlQ2xhc3NEZWNsYXJhdGlvbigpO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICBlbHNlIGlmICh0aGlzLm1hdGNoS2V5d29yZCgnZnVuY3Rpb24nKSkge1xyXG5cdCAgICAgICAgICAgICAgICB2YXIgdG9rZW4gPSB0aGlzLmxvb2thaGVhZDtcclxuXHQgICAgICAgICAgICAgICAgdmFyIGRlY2xhcmF0aW9uID0gdGhpcy5wYXJzZUZ1bmN0aW9uRGVjbGFyYXRpb24oKTtcclxuXHQgICAgICAgICAgICAgICAgaWYgKHRoaXMuY29udGV4dC5zdHJpY3QpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgIHRoaXMudG9sZXJhdGVVbmV4cGVjdGVkVG9rZW4odG9rZW4sIG1lc3NhZ2VzXzEuTWVzc2FnZXMuU3RyaWN0RnVuY3Rpb24pO1xyXG5cdCAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgIGVsc2UgaWYgKGRlY2xhcmF0aW9uLmdlbmVyYXRvcikge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgdGhpcy50b2xlcmF0ZVVuZXhwZWN0ZWRUb2tlbih0b2tlbiwgbWVzc2FnZXNfMS5NZXNzYWdlcy5HZW5lcmF0b3JJbkxlZ2FjeUNvbnRleHQpO1xyXG5cdCAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgIGJvZHkgPSBkZWNsYXJhdGlvbjtcclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgZWxzZSB7XHJcblx0ICAgICAgICAgICAgICAgIGJvZHkgPSB0aGlzLnBhcnNlU3RhdGVtZW50KCk7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgIGRlbGV0ZSB0aGlzLmNvbnRleHQubGFiZWxTZXRba2V5XTtcclxuXHQgICAgICAgICAgICBzdGF0ZW1lbnQgPSBuZXcgTm9kZS5MYWJlbGVkU3RhdGVtZW50KGlkLCBib2R5KTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIGVsc2Uge1xyXG5cdCAgICAgICAgICAgIHRoaXMuY29uc3VtZVNlbWljb2xvbigpO1xyXG5cdCAgICAgICAgICAgIHN0YXRlbWVudCA9IG5ldyBOb2RlLkV4cHJlc3Npb25TdGF0ZW1lbnQoZXhwcik7XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICByZXR1cm4gdGhpcy5maW5hbGl6ZShub2RlLCBzdGF0ZW1lbnQpO1xyXG5cdCAgICB9O1xyXG5cdCAgICAvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy10aHJvdy1zdGF0ZW1lbnRcclxuXHQgICAgUGFyc2VyLnByb3RvdHlwZS5wYXJzZVRocm93U3RhdGVtZW50ID0gZnVuY3Rpb24gKCkge1xyXG5cdCAgICAgICAgdmFyIG5vZGUgPSB0aGlzLmNyZWF0ZU5vZGUoKTtcclxuXHQgICAgICAgIHRoaXMuZXhwZWN0S2V5d29yZCgndGhyb3cnKTtcclxuXHQgICAgICAgIGlmICh0aGlzLmhhc0xpbmVUZXJtaW5hdG9yKSB7XHJcblx0ICAgICAgICAgICAgdGhpcy50aHJvd0Vycm9yKG1lc3NhZ2VzXzEuTWVzc2FnZXMuTmV3bGluZUFmdGVyVGhyb3cpO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgdmFyIGFyZ3VtZW50ID0gdGhpcy5wYXJzZUV4cHJlc3Npb24oKTtcclxuXHQgICAgICAgIHRoaXMuY29uc3VtZVNlbWljb2xvbigpO1xyXG5cdCAgICAgICAgcmV0dXJuIHRoaXMuZmluYWxpemUobm9kZSwgbmV3IE5vZGUuVGhyb3dTdGF0ZW1lbnQoYXJndW1lbnQpKTtcclxuXHQgICAgfTtcclxuXHQgICAgLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtdHJ5LXN0YXRlbWVudFxyXG5cdCAgICBQYXJzZXIucHJvdG90eXBlLnBhcnNlQ2F0Y2hDbGF1c2UgPSBmdW5jdGlvbiAoKSB7XHJcblx0ICAgICAgICB2YXIgbm9kZSA9IHRoaXMuY3JlYXRlTm9kZSgpO1xyXG5cdCAgICAgICAgdGhpcy5leHBlY3RLZXl3b3JkKCdjYXRjaCcpO1xyXG5cdCAgICAgICAgdGhpcy5leHBlY3QoJygnKTtcclxuXHQgICAgICAgIGlmICh0aGlzLm1hdGNoKCcpJykpIHtcclxuXHQgICAgICAgICAgICB0aGlzLnRocm93VW5leHBlY3RlZFRva2VuKHRoaXMubG9va2FoZWFkKTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIHZhciBwYXJhbXMgPSBbXTtcclxuXHQgICAgICAgIHZhciBwYXJhbSA9IHRoaXMucGFyc2VQYXR0ZXJuKHBhcmFtcyk7XHJcblx0ICAgICAgICB2YXIgcGFyYW1NYXAgPSB7fTtcclxuXHQgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcGFyYW1zLmxlbmd0aDsgaSsrKSB7XHJcblx0ICAgICAgICAgICAgdmFyIGtleSA9ICckJyArIHBhcmFtc1tpXS52YWx1ZTtcclxuXHQgICAgICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHBhcmFtTWFwLCBrZXkpKSB7XHJcblx0ICAgICAgICAgICAgICAgIHRoaXMudG9sZXJhdGVFcnJvcihtZXNzYWdlc18xLk1lc3NhZ2VzLkR1cGxpY2F0ZUJpbmRpbmcsIHBhcmFtc1tpXS52YWx1ZSk7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgIHBhcmFtTWFwW2tleV0gPSB0cnVlO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgaWYgKHRoaXMuY29udGV4dC5zdHJpY3QgJiYgcGFyYW0udHlwZSA9PT0gc3ludGF4XzEuU3ludGF4LklkZW50aWZpZXIpIHtcclxuXHQgICAgICAgICAgICBpZiAodGhpcy5zY2FubmVyLmlzUmVzdHJpY3RlZFdvcmQocGFyYW0ubmFtZSkpIHtcclxuXHQgICAgICAgICAgICAgICAgdGhpcy50b2xlcmF0ZUVycm9yKG1lc3NhZ2VzXzEuTWVzc2FnZXMuU3RyaWN0Q2F0Y2hWYXJpYWJsZSk7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgdGhpcy5leHBlY3QoJyknKTtcclxuXHQgICAgICAgIHZhciBib2R5ID0gdGhpcy5wYXJzZUJsb2NrKCk7XHJcblx0ICAgICAgICByZXR1cm4gdGhpcy5maW5hbGl6ZShub2RlLCBuZXcgTm9kZS5DYXRjaENsYXVzZShwYXJhbSwgYm9keSkpO1xyXG5cdCAgICB9O1xyXG5cdCAgICBQYXJzZXIucHJvdG90eXBlLnBhcnNlRmluYWxseUNsYXVzZSA9IGZ1bmN0aW9uICgpIHtcclxuXHQgICAgICAgIHRoaXMuZXhwZWN0S2V5d29yZCgnZmluYWxseScpO1xyXG5cdCAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VCbG9jaygpO1xyXG5cdCAgICB9O1xyXG5cdCAgICBQYXJzZXIucHJvdG90eXBlLnBhcnNlVHJ5U3RhdGVtZW50ID0gZnVuY3Rpb24gKCkge1xyXG5cdCAgICAgICAgdmFyIG5vZGUgPSB0aGlzLmNyZWF0ZU5vZGUoKTtcclxuXHQgICAgICAgIHRoaXMuZXhwZWN0S2V5d29yZCgndHJ5Jyk7XHJcblx0ICAgICAgICB2YXIgYmxvY2sgPSB0aGlzLnBhcnNlQmxvY2soKTtcclxuXHQgICAgICAgIHZhciBoYW5kbGVyID0gdGhpcy5tYXRjaEtleXdvcmQoJ2NhdGNoJykgPyB0aGlzLnBhcnNlQ2F0Y2hDbGF1c2UoKSA6IG51bGw7XHJcblx0ICAgICAgICB2YXIgZmluYWxpemVyID0gdGhpcy5tYXRjaEtleXdvcmQoJ2ZpbmFsbHknKSA/IHRoaXMucGFyc2VGaW5hbGx5Q2xhdXNlKCkgOiBudWxsO1xyXG5cdCAgICAgICAgaWYgKCFoYW5kbGVyICYmICFmaW5hbGl6ZXIpIHtcclxuXHQgICAgICAgICAgICB0aGlzLnRocm93RXJyb3IobWVzc2FnZXNfMS5NZXNzYWdlcy5Ob0NhdGNoT3JGaW5hbGx5KTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIHJldHVybiB0aGlzLmZpbmFsaXplKG5vZGUsIG5ldyBOb2RlLlRyeVN0YXRlbWVudChibG9jaywgaGFuZGxlciwgZmluYWxpemVyKSk7XHJcblx0ICAgIH07XHJcblx0ICAgIC8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLWRlYnVnZ2VyLXN0YXRlbWVudFxyXG5cdCAgICBQYXJzZXIucHJvdG90eXBlLnBhcnNlRGVidWdnZXJTdGF0ZW1lbnQgPSBmdW5jdGlvbiAoKSB7XHJcblx0ICAgICAgICB2YXIgbm9kZSA9IHRoaXMuY3JlYXRlTm9kZSgpO1xyXG5cdCAgICAgICAgdGhpcy5leHBlY3RLZXl3b3JkKCdkZWJ1Z2dlcicpO1xyXG5cdCAgICAgICAgdGhpcy5jb25zdW1lU2VtaWNvbG9uKCk7XHJcblx0ICAgICAgICByZXR1cm4gdGhpcy5maW5hbGl6ZShub2RlLCBuZXcgTm9kZS5EZWJ1Z2dlclN0YXRlbWVudCgpKTtcclxuXHQgICAgfTtcclxuXHQgICAgLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtZWNtYXNjcmlwdC1sYW5ndWFnZS1zdGF0ZW1lbnRzLWFuZC1kZWNsYXJhdGlvbnNcclxuXHQgICAgUGFyc2VyLnByb3RvdHlwZS5wYXJzZVN0YXRlbWVudCA9IGZ1bmN0aW9uICgpIHtcclxuXHQgICAgICAgIHZhciBzdGF0ZW1lbnQ7XHJcblx0ICAgICAgICBzd2l0Y2ggKHRoaXMubG9va2FoZWFkLnR5cGUpIHtcclxuXHQgICAgICAgICAgICBjYXNlIDEgLyogQm9vbGVhbkxpdGVyYWwgKi86XHJcblx0ICAgICAgICAgICAgY2FzZSA1IC8qIE51bGxMaXRlcmFsICovOlxyXG5cdCAgICAgICAgICAgIGNhc2UgNiAvKiBOdW1lcmljTGl0ZXJhbCAqLzpcclxuXHQgICAgICAgICAgICBjYXNlIDggLyogU3RyaW5nTGl0ZXJhbCAqLzpcclxuXHQgICAgICAgICAgICBjYXNlIDEwIC8qIFRlbXBsYXRlICovOlxyXG5cdCAgICAgICAgICAgIGNhc2UgOSAvKiBSZWd1bGFyRXhwcmVzc2lvbiAqLzpcclxuXHQgICAgICAgICAgICAgICAgc3RhdGVtZW50ID0gdGhpcy5wYXJzZUV4cHJlc3Npb25TdGF0ZW1lbnQoKTtcclxuXHQgICAgICAgICAgICAgICAgYnJlYWs7XHJcblx0ICAgICAgICAgICAgY2FzZSA3IC8qIFB1bmN0dWF0b3IgKi86XHJcblx0ICAgICAgICAgICAgICAgIHZhciB2YWx1ZSA9IHRoaXMubG9va2FoZWFkLnZhbHVlO1xyXG5cdCAgICAgICAgICAgICAgICBpZiAodmFsdWUgPT09ICd7Jykge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgc3RhdGVtZW50ID0gdGhpcy5wYXJzZUJsb2NrKCk7XHJcblx0ICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgZWxzZSBpZiAodmFsdWUgPT09ICcoJykge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgc3RhdGVtZW50ID0gdGhpcy5wYXJzZUV4cHJlc3Npb25TdGF0ZW1lbnQoKTtcclxuXHQgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICBlbHNlIGlmICh2YWx1ZSA9PT0gJzsnKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICBzdGF0ZW1lbnQgPSB0aGlzLnBhcnNlRW1wdHlTdGF0ZW1lbnQoKTtcclxuXHQgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICBlbHNlIHtcclxuXHQgICAgICAgICAgICAgICAgICAgIHN0YXRlbWVudCA9IHRoaXMucGFyc2VFeHByZXNzaW9uU3RhdGVtZW50KCk7XHJcblx0ICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgYnJlYWs7XHJcblx0ICAgICAgICAgICAgY2FzZSAzIC8qIElkZW50aWZpZXIgKi86XHJcblx0ICAgICAgICAgICAgICAgIHN0YXRlbWVudCA9IHRoaXMubWF0Y2hBc3luY0Z1bmN0aW9uKCkgPyB0aGlzLnBhcnNlRnVuY3Rpb25EZWNsYXJhdGlvbigpIDogdGhpcy5wYXJzZUxhYmVsbGVkU3RhdGVtZW50KCk7XHJcblx0ICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cdCAgICAgICAgICAgIGNhc2UgNCAvKiBLZXl3b3JkICovOlxyXG5cdCAgICAgICAgICAgICAgICBzd2l0Y2ggKHRoaXMubG9va2FoZWFkLnZhbHVlKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICBjYXNlICdicmVhayc6XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGVtZW50ID0gdGhpcy5wYXJzZUJyZWFrU3RhdGVtZW50KCk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcblx0ICAgICAgICAgICAgICAgICAgICBjYXNlICdjb250aW51ZSc6XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGVtZW50ID0gdGhpcy5wYXJzZUNvbnRpbnVlU3RhdGVtZW50KCk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcblx0ICAgICAgICAgICAgICAgICAgICBjYXNlICdkZWJ1Z2dlcic6XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGVtZW50ID0gdGhpcy5wYXJzZURlYnVnZ2VyU3RhdGVtZW50KCk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcblx0ICAgICAgICAgICAgICAgICAgICBjYXNlICdkbyc6XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGVtZW50ID0gdGhpcy5wYXJzZURvV2hpbGVTdGF0ZW1lbnQoKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuXHQgICAgICAgICAgICAgICAgICAgIGNhc2UgJ2Zvcic6XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGVtZW50ID0gdGhpcy5wYXJzZUZvclN0YXRlbWVudCgpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgY2FzZSAnZnVuY3Rpb24nOlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRlbWVudCA9IHRoaXMucGFyc2VGdW5jdGlvbkRlY2xhcmF0aW9uKCk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcblx0ICAgICAgICAgICAgICAgICAgICBjYXNlICdpZic6XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGVtZW50ID0gdGhpcy5wYXJzZUlmU3RhdGVtZW50KCk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcblx0ICAgICAgICAgICAgICAgICAgICBjYXNlICdyZXR1cm4nOlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRlbWVudCA9IHRoaXMucGFyc2VSZXR1cm5TdGF0ZW1lbnQoKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuXHQgICAgICAgICAgICAgICAgICAgIGNhc2UgJ3N3aXRjaCc6XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGVtZW50ID0gdGhpcy5wYXJzZVN3aXRjaFN0YXRlbWVudCgpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgY2FzZSAndGhyb3cnOlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRlbWVudCA9IHRoaXMucGFyc2VUaHJvd1N0YXRlbWVudCgpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgY2FzZSAndHJ5JzpcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBzdGF0ZW1lbnQgPSB0aGlzLnBhcnNlVHJ5U3RhdGVtZW50KCk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcblx0ICAgICAgICAgICAgICAgICAgICBjYXNlICd2YXInOlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRlbWVudCA9IHRoaXMucGFyc2VWYXJpYWJsZVN0YXRlbWVudCgpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgY2FzZSAnd2hpbGUnOlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRlbWVudCA9IHRoaXMucGFyc2VXaGlsZVN0YXRlbWVudCgpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgY2FzZSAnd2l0aCc6XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGVtZW50ID0gdGhpcy5wYXJzZVdpdGhTdGF0ZW1lbnQoKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuXHQgICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGVtZW50ID0gdGhpcy5wYXJzZUV4cHJlc3Npb25TdGF0ZW1lbnQoKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuXHQgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICBicmVhaztcclxuXHQgICAgICAgICAgICBkZWZhdWx0OlxyXG5cdCAgICAgICAgICAgICAgICBzdGF0ZW1lbnQgPSB0aGlzLnRocm93VW5leHBlY3RlZFRva2VuKHRoaXMubG9va2FoZWFkKTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIHJldHVybiBzdGF0ZW1lbnQ7XHJcblx0ICAgIH07XHJcblx0ICAgIC8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLWZ1bmN0aW9uLWRlZmluaXRpb25zXHJcblx0ICAgIFBhcnNlci5wcm90b3R5cGUucGFyc2VGdW5jdGlvblNvdXJjZUVsZW1lbnRzID0gZnVuY3Rpb24gKCkge1xyXG5cdCAgICAgICAgdmFyIG5vZGUgPSB0aGlzLmNyZWF0ZU5vZGUoKTtcclxuXHQgICAgICAgIHRoaXMuZXhwZWN0KCd7Jyk7XHJcblx0ICAgICAgICB2YXIgYm9keSA9IHRoaXMucGFyc2VEaXJlY3RpdmVQcm9sb2d1ZXMoKTtcclxuXHQgICAgICAgIHZhciBwcmV2aW91c0xhYmVsU2V0ID0gdGhpcy5jb250ZXh0LmxhYmVsU2V0O1xyXG5cdCAgICAgICAgdmFyIHByZXZpb3VzSW5JdGVyYXRpb24gPSB0aGlzLmNvbnRleHQuaW5JdGVyYXRpb247XHJcblx0ICAgICAgICB2YXIgcHJldmlvdXNJblN3aXRjaCA9IHRoaXMuY29udGV4dC5pblN3aXRjaDtcclxuXHQgICAgICAgIHZhciBwcmV2aW91c0luRnVuY3Rpb25Cb2R5ID0gdGhpcy5jb250ZXh0LmluRnVuY3Rpb25Cb2R5O1xyXG5cdCAgICAgICAgdGhpcy5jb250ZXh0LmxhYmVsU2V0ID0ge307XHJcblx0ICAgICAgICB0aGlzLmNvbnRleHQuaW5JdGVyYXRpb24gPSBmYWxzZTtcclxuXHQgICAgICAgIHRoaXMuY29udGV4dC5pblN3aXRjaCA9IGZhbHNlO1xyXG5cdCAgICAgICAgdGhpcy5jb250ZXh0LmluRnVuY3Rpb25Cb2R5ID0gdHJ1ZTtcclxuXHQgICAgICAgIHdoaWxlICh0aGlzLmxvb2thaGVhZC50eXBlICE9PSAyIC8qIEVPRiAqLykge1xyXG5cdCAgICAgICAgICAgIGlmICh0aGlzLm1hdGNoKCd9JykpIHtcclxuXHQgICAgICAgICAgICAgICAgYnJlYWs7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgIGJvZHkucHVzaCh0aGlzLnBhcnNlU3RhdGVtZW50TGlzdEl0ZW0oKSk7XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICB0aGlzLmV4cGVjdCgnfScpO1xyXG5cdCAgICAgICAgdGhpcy5jb250ZXh0LmxhYmVsU2V0ID0gcHJldmlvdXNMYWJlbFNldDtcclxuXHQgICAgICAgIHRoaXMuY29udGV4dC5pbkl0ZXJhdGlvbiA9IHByZXZpb3VzSW5JdGVyYXRpb247XHJcblx0ICAgICAgICB0aGlzLmNvbnRleHQuaW5Td2l0Y2ggPSBwcmV2aW91c0luU3dpdGNoO1xyXG5cdCAgICAgICAgdGhpcy5jb250ZXh0LmluRnVuY3Rpb25Cb2R5ID0gcHJldmlvdXNJbkZ1bmN0aW9uQm9keTtcclxuXHQgICAgICAgIHJldHVybiB0aGlzLmZpbmFsaXplKG5vZGUsIG5ldyBOb2RlLkJsb2NrU3RhdGVtZW50KGJvZHkpKTtcclxuXHQgICAgfTtcclxuXHQgICAgUGFyc2VyLnByb3RvdHlwZS52YWxpZGF0ZVBhcmFtID0gZnVuY3Rpb24gKG9wdGlvbnMsIHBhcmFtLCBuYW1lKSB7XHJcblx0ICAgICAgICB2YXIga2V5ID0gJyQnICsgbmFtZTtcclxuXHQgICAgICAgIGlmICh0aGlzLmNvbnRleHQuc3RyaWN0KSB7XHJcblx0ICAgICAgICAgICAgaWYgKHRoaXMuc2Nhbm5lci5pc1Jlc3RyaWN0ZWRXb3JkKG5hbWUpKSB7XHJcblx0ICAgICAgICAgICAgICAgIG9wdGlvbnMuc3RyaWN0ZWQgPSBwYXJhbTtcclxuXHQgICAgICAgICAgICAgICAgb3B0aW9ucy5tZXNzYWdlID0gbWVzc2FnZXNfMS5NZXNzYWdlcy5TdHJpY3RQYXJhbU5hbWU7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob3B0aW9ucy5wYXJhbVNldCwga2V5KSkge1xyXG5cdCAgICAgICAgICAgICAgICBvcHRpb25zLnN0cmljdGVkID0gcGFyYW07XHJcblx0ICAgICAgICAgICAgICAgIG9wdGlvbnMubWVzc2FnZSA9IG1lc3NhZ2VzXzEuTWVzc2FnZXMuU3RyaWN0UGFyYW1EdXBlO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIGVsc2UgaWYgKCFvcHRpb25zLmZpcnN0UmVzdHJpY3RlZCkge1xyXG5cdCAgICAgICAgICAgIGlmICh0aGlzLnNjYW5uZXIuaXNSZXN0cmljdGVkV29yZChuYW1lKSkge1xyXG5cdCAgICAgICAgICAgICAgICBvcHRpb25zLmZpcnN0UmVzdHJpY3RlZCA9IHBhcmFtO1xyXG5cdCAgICAgICAgICAgICAgICBvcHRpb25zLm1lc3NhZ2UgPSBtZXNzYWdlc18xLk1lc3NhZ2VzLlN0cmljdFBhcmFtTmFtZTtcclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5zY2FubmVyLmlzU3RyaWN0TW9kZVJlc2VydmVkV29yZChuYW1lKSkge1xyXG5cdCAgICAgICAgICAgICAgICBvcHRpb25zLmZpcnN0UmVzdHJpY3RlZCA9IHBhcmFtO1xyXG5cdCAgICAgICAgICAgICAgICBvcHRpb25zLm1lc3NhZ2UgPSBtZXNzYWdlc18xLk1lc3NhZ2VzLlN0cmljdFJlc2VydmVkV29yZDtcclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgZWxzZSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9wdGlvbnMucGFyYW1TZXQsIGtleSkpIHtcclxuXHQgICAgICAgICAgICAgICAgb3B0aW9ucy5zdHJpY3RlZCA9IHBhcmFtO1xyXG5cdCAgICAgICAgICAgICAgICBvcHRpb25zLm1lc3NhZ2UgPSBtZXNzYWdlc18xLk1lc3NhZ2VzLlN0cmljdFBhcmFtRHVwZTtcclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xyXG5cdCAgICAgICAgaWYgKHR5cGVvZiBPYmplY3QuZGVmaW5lUHJvcGVydHkgPT09ICdmdW5jdGlvbicpIHtcclxuXHQgICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkob3B0aW9ucy5wYXJhbVNldCwga2V5LCB7IHZhbHVlOiB0cnVlLCBlbnVtZXJhYmxlOiB0cnVlLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0pO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgZWxzZSB7XHJcblx0ICAgICAgICAgICAgb3B0aW9ucy5wYXJhbVNldFtrZXldID0gdHJ1ZTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgfTtcclxuXHQgICAgUGFyc2VyLnByb3RvdHlwZS5wYXJzZVJlc3RFbGVtZW50ID0gZnVuY3Rpb24gKHBhcmFtcykge1xyXG5cdCAgICAgICAgdmFyIG5vZGUgPSB0aGlzLmNyZWF0ZU5vZGUoKTtcclxuXHQgICAgICAgIHRoaXMuZXhwZWN0KCcuLi4nKTtcclxuXHQgICAgICAgIHZhciBhcmcgPSB0aGlzLnBhcnNlUGF0dGVybihwYXJhbXMpO1xyXG5cdCAgICAgICAgaWYgKHRoaXMubWF0Y2goJz0nKSkge1xyXG5cdCAgICAgICAgICAgIHRoaXMudGhyb3dFcnJvcihtZXNzYWdlc18xLk1lc3NhZ2VzLkRlZmF1bHRSZXN0UGFyYW1ldGVyKTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIGlmICghdGhpcy5tYXRjaCgnKScpKSB7XHJcblx0ICAgICAgICAgICAgdGhpcy50aHJvd0Vycm9yKG1lc3NhZ2VzXzEuTWVzc2FnZXMuUGFyYW1ldGVyQWZ0ZXJSZXN0UGFyYW1ldGVyKTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIHJldHVybiB0aGlzLmZpbmFsaXplKG5vZGUsIG5ldyBOb2RlLlJlc3RFbGVtZW50KGFyZykpO1xyXG5cdCAgICB9O1xyXG5cdCAgICBQYXJzZXIucHJvdG90eXBlLnBhcnNlRm9ybWFsUGFyYW1ldGVyID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcclxuXHQgICAgICAgIHZhciBwYXJhbXMgPSBbXTtcclxuXHQgICAgICAgIHZhciBwYXJhbSA9IHRoaXMubWF0Y2goJy4uLicpID8gdGhpcy5wYXJzZVJlc3RFbGVtZW50KHBhcmFtcykgOiB0aGlzLnBhcnNlUGF0dGVybldpdGhEZWZhdWx0KHBhcmFtcyk7XHJcblx0ICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBhcmFtcy5sZW5ndGg7IGkrKykge1xyXG5cdCAgICAgICAgICAgIHRoaXMudmFsaWRhdGVQYXJhbShvcHRpb25zLCBwYXJhbXNbaV0sIHBhcmFtc1tpXS52YWx1ZSk7XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICBvcHRpb25zLnNpbXBsZSA9IG9wdGlvbnMuc2ltcGxlICYmIChwYXJhbSBpbnN0YW5jZW9mIE5vZGUuSWRlbnRpZmllcik7XHJcblx0ICAgICAgICBvcHRpb25zLnBhcmFtcy5wdXNoKHBhcmFtKTtcclxuXHQgICAgfTtcclxuXHQgICAgUGFyc2VyLnByb3RvdHlwZS5wYXJzZUZvcm1hbFBhcmFtZXRlcnMgPSBmdW5jdGlvbiAoZmlyc3RSZXN0cmljdGVkKSB7XHJcblx0ICAgICAgICB2YXIgb3B0aW9ucztcclxuXHQgICAgICAgIG9wdGlvbnMgPSB7XHJcblx0ICAgICAgICAgICAgc2ltcGxlOiB0cnVlLFxyXG5cdCAgICAgICAgICAgIHBhcmFtczogW10sXHJcblx0ICAgICAgICAgICAgZmlyc3RSZXN0cmljdGVkOiBmaXJzdFJlc3RyaWN0ZWRcclxuXHQgICAgICAgIH07XHJcblx0ICAgICAgICB0aGlzLmV4cGVjdCgnKCcpO1xyXG5cdCAgICAgICAgaWYgKCF0aGlzLm1hdGNoKCcpJykpIHtcclxuXHQgICAgICAgICAgICBvcHRpb25zLnBhcmFtU2V0ID0ge307XHJcblx0ICAgICAgICAgICAgd2hpbGUgKHRoaXMubG9va2FoZWFkLnR5cGUgIT09IDIgLyogRU9GICovKSB7XHJcblx0ICAgICAgICAgICAgICAgIHRoaXMucGFyc2VGb3JtYWxQYXJhbWV0ZXIob3B0aW9ucyk7XHJcblx0ICAgICAgICAgICAgICAgIGlmICh0aGlzLm1hdGNoKCcpJykpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cdCAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgIHRoaXMuZXhwZWN0KCcsJyk7XHJcblx0ICAgICAgICAgICAgICAgIGlmICh0aGlzLm1hdGNoKCcpJykpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cdCAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgdGhpcy5leHBlY3QoJyknKTtcclxuXHQgICAgICAgIHJldHVybiB7XHJcblx0ICAgICAgICAgICAgc2ltcGxlOiBvcHRpb25zLnNpbXBsZSxcclxuXHQgICAgICAgICAgICBwYXJhbXM6IG9wdGlvbnMucGFyYW1zLFxyXG5cdCAgICAgICAgICAgIHN0cmljdGVkOiBvcHRpb25zLnN0cmljdGVkLFxyXG5cdCAgICAgICAgICAgIGZpcnN0UmVzdHJpY3RlZDogb3B0aW9ucy5maXJzdFJlc3RyaWN0ZWQsXHJcblx0ICAgICAgICAgICAgbWVzc2FnZTogb3B0aW9ucy5tZXNzYWdlXHJcblx0ICAgICAgICB9O1xyXG5cdCAgICB9O1xyXG5cdCAgICBQYXJzZXIucHJvdG90eXBlLm1hdGNoQXN5bmNGdW5jdGlvbiA9IGZ1bmN0aW9uICgpIHtcclxuXHQgICAgICAgIHZhciBtYXRjaCA9IHRoaXMubWF0Y2hDb250ZXh0dWFsS2V5d29yZCgnYXN5bmMnKTtcclxuXHQgICAgICAgIGlmIChtYXRjaCkge1xyXG5cdCAgICAgICAgICAgIHZhciBzdGF0ZSA9IHRoaXMuc2Nhbm5lci5zYXZlU3RhdGUoKTtcclxuXHQgICAgICAgICAgICB0aGlzLnNjYW5uZXIuc2NhbkNvbW1lbnRzKCk7XHJcblx0ICAgICAgICAgICAgdmFyIG5leHQgPSB0aGlzLnNjYW5uZXIubGV4KCk7XHJcblx0ICAgICAgICAgICAgdGhpcy5zY2FubmVyLnJlc3RvcmVTdGF0ZShzdGF0ZSk7XHJcblx0ICAgICAgICAgICAgbWF0Y2ggPSAoc3RhdGUubGluZU51bWJlciA9PT0gbmV4dC5saW5lTnVtYmVyKSAmJiAobmV4dC50eXBlID09PSA0IC8qIEtleXdvcmQgKi8pICYmIChuZXh0LnZhbHVlID09PSAnZnVuY3Rpb24nKTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIHJldHVybiBtYXRjaDtcclxuXHQgICAgfTtcclxuXHQgICAgUGFyc2VyLnByb3RvdHlwZS5wYXJzZUZ1bmN0aW9uRGVjbGFyYXRpb24gPSBmdW5jdGlvbiAoaWRlbnRpZmllcklzT3B0aW9uYWwpIHtcclxuXHQgICAgICAgIHZhciBub2RlID0gdGhpcy5jcmVhdGVOb2RlKCk7XHJcblx0ICAgICAgICB2YXIgaXNBc3luYyA9IHRoaXMubWF0Y2hDb250ZXh0dWFsS2V5d29yZCgnYXN5bmMnKTtcclxuXHQgICAgICAgIGlmIChpc0FzeW5jKSB7XHJcblx0ICAgICAgICAgICAgdGhpcy5uZXh0VG9rZW4oKTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIHRoaXMuZXhwZWN0S2V5d29yZCgnZnVuY3Rpb24nKTtcclxuXHQgICAgICAgIHZhciBpc0dlbmVyYXRvciA9IGlzQXN5bmMgPyBmYWxzZSA6IHRoaXMubWF0Y2goJyonKTtcclxuXHQgICAgICAgIGlmIChpc0dlbmVyYXRvcikge1xyXG5cdCAgICAgICAgICAgIHRoaXMubmV4dFRva2VuKCk7XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICB2YXIgbWVzc2FnZTtcclxuXHQgICAgICAgIHZhciBpZCA9IG51bGw7XHJcblx0ICAgICAgICB2YXIgZmlyc3RSZXN0cmljdGVkID0gbnVsbDtcclxuXHQgICAgICAgIGlmICghaWRlbnRpZmllcklzT3B0aW9uYWwgfHwgIXRoaXMubWF0Y2goJygnKSkge1xyXG5cdCAgICAgICAgICAgIHZhciB0b2tlbiA9IHRoaXMubG9va2FoZWFkO1xyXG5cdCAgICAgICAgICAgIGlkID0gdGhpcy5wYXJzZVZhcmlhYmxlSWRlbnRpZmllcigpO1xyXG5cdCAgICAgICAgICAgIGlmICh0aGlzLmNvbnRleHQuc3RyaWN0KSB7XHJcblx0ICAgICAgICAgICAgICAgIGlmICh0aGlzLnNjYW5uZXIuaXNSZXN0cmljdGVkV29yZCh0b2tlbi52YWx1ZSkpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgIHRoaXMudG9sZXJhdGVVbmV4cGVjdGVkVG9rZW4odG9rZW4sIG1lc3NhZ2VzXzEuTWVzc2FnZXMuU3RyaWN0RnVuY3Rpb25OYW1lKTtcclxuXHQgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICBlbHNlIHtcclxuXHQgICAgICAgICAgICAgICAgaWYgKHRoaXMuc2Nhbm5lci5pc1Jlc3RyaWN0ZWRXb3JkKHRva2VuLnZhbHVlKSkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgZmlyc3RSZXN0cmljdGVkID0gdG9rZW47XHJcblx0ICAgICAgICAgICAgICAgICAgICBtZXNzYWdlID0gbWVzc2FnZXNfMS5NZXNzYWdlcy5TdHJpY3RGdW5jdGlvbk5hbWU7XHJcblx0ICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5zY2FubmVyLmlzU3RyaWN0TW9kZVJlc2VydmVkV29yZCh0b2tlbi52YWx1ZSkpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgIGZpcnN0UmVzdHJpY3RlZCA9IHRva2VuO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgbWVzc2FnZSA9IG1lc3NhZ2VzXzEuTWVzc2FnZXMuU3RyaWN0UmVzZXJ2ZWRXb3JkO1xyXG5cdCAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgdmFyIHByZXZpb3VzQWxsb3dBd2FpdCA9IHRoaXMuY29udGV4dC5hd2FpdDtcclxuXHQgICAgICAgIHZhciBwcmV2aW91c0FsbG93WWllbGQgPSB0aGlzLmNvbnRleHQuYWxsb3dZaWVsZDtcclxuXHQgICAgICAgIHRoaXMuY29udGV4dC5hd2FpdCA9IGlzQXN5bmM7XHJcblx0ICAgICAgICB0aGlzLmNvbnRleHQuYWxsb3dZaWVsZCA9ICFpc0dlbmVyYXRvcjtcclxuXHQgICAgICAgIHZhciBmb3JtYWxQYXJhbWV0ZXJzID0gdGhpcy5wYXJzZUZvcm1hbFBhcmFtZXRlcnMoZmlyc3RSZXN0cmljdGVkKTtcclxuXHQgICAgICAgIHZhciBwYXJhbXMgPSBmb3JtYWxQYXJhbWV0ZXJzLnBhcmFtcztcclxuXHQgICAgICAgIHZhciBzdHJpY3RlZCA9IGZvcm1hbFBhcmFtZXRlcnMuc3RyaWN0ZWQ7XHJcblx0ICAgICAgICBmaXJzdFJlc3RyaWN0ZWQgPSBmb3JtYWxQYXJhbWV0ZXJzLmZpcnN0UmVzdHJpY3RlZDtcclxuXHQgICAgICAgIGlmIChmb3JtYWxQYXJhbWV0ZXJzLm1lc3NhZ2UpIHtcclxuXHQgICAgICAgICAgICBtZXNzYWdlID0gZm9ybWFsUGFyYW1ldGVycy5tZXNzYWdlO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgdmFyIHByZXZpb3VzU3RyaWN0ID0gdGhpcy5jb250ZXh0LnN0cmljdDtcclxuXHQgICAgICAgIHZhciBwcmV2aW91c0FsbG93U3RyaWN0RGlyZWN0aXZlID0gdGhpcy5jb250ZXh0LmFsbG93U3RyaWN0RGlyZWN0aXZlO1xyXG5cdCAgICAgICAgdGhpcy5jb250ZXh0LmFsbG93U3RyaWN0RGlyZWN0aXZlID0gZm9ybWFsUGFyYW1ldGVycy5zaW1wbGU7XHJcblx0ICAgICAgICB2YXIgYm9keSA9IHRoaXMucGFyc2VGdW5jdGlvblNvdXJjZUVsZW1lbnRzKCk7XHJcblx0ICAgICAgICBpZiAodGhpcy5jb250ZXh0LnN0cmljdCAmJiBmaXJzdFJlc3RyaWN0ZWQpIHtcclxuXHQgICAgICAgICAgICB0aGlzLnRocm93VW5leHBlY3RlZFRva2VuKGZpcnN0UmVzdHJpY3RlZCwgbWVzc2FnZSk7XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICBpZiAodGhpcy5jb250ZXh0LnN0cmljdCAmJiBzdHJpY3RlZCkge1xyXG5cdCAgICAgICAgICAgIHRoaXMudG9sZXJhdGVVbmV4cGVjdGVkVG9rZW4oc3RyaWN0ZWQsIG1lc3NhZ2UpO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgdGhpcy5jb250ZXh0LnN0cmljdCA9IHByZXZpb3VzU3RyaWN0O1xyXG5cdCAgICAgICAgdGhpcy5jb250ZXh0LmFsbG93U3RyaWN0RGlyZWN0aXZlID0gcHJldmlvdXNBbGxvd1N0cmljdERpcmVjdGl2ZTtcclxuXHQgICAgICAgIHRoaXMuY29udGV4dC5hd2FpdCA9IHByZXZpb3VzQWxsb3dBd2FpdDtcclxuXHQgICAgICAgIHRoaXMuY29udGV4dC5hbGxvd1lpZWxkID0gcHJldmlvdXNBbGxvd1lpZWxkO1xyXG5cdCAgICAgICAgcmV0dXJuIGlzQXN5bmMgPyB0aGlzLmZpbmFsaXplKG5vZGUsIG5ldyBOb2RlLkFzeW5jRnVuY3Rpb25EZWNsYXJhdGlvbihpZCwgcGFyYW1zLCBib2R5KSkgOlxyXG5cdCAgICAgICAgICAgIHRoaXMuZmluYWxpemUobm9kZSwgbmV3IE5vZGUuRnVuY3Rpb25EZWNsYXJhdGlvbihpZCwgcGFyYW1zLCBib2R5LCBpc0dlbmVyYXRvcikpO1xyXG5cdCAgICB9O1xyXG5cdCAgICBQYXJzZXIucHJvdG90eXBlLnBhcnNlRnVuY3Rpb25FeHByZXNzaW9uID0gZnVuY3Rpb24gKCkge1xyXG5cdCAgICAgICAgdmFyIG5vZGUgPSB0aGlzLmNyZWF0ZU5vZGUoKTtcclxuXHQgICAgICAgIHZhciBpc0FzeW5jID0gdGhpcy5tYXRjaENvbnRleHR1YWxLZXl3b3JkKCdhc3luYycpO1xyXG5cdCAgICAgICAgaWYgKGlzQXN5bmMpIHtcclxuXHQgICAgICAgICAgICB0aGlzLm5leHRUb2tlbigpO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgdGhpcy5leHBlY3RLZXl3b3JkKCdmdW5jdGlvbicpO1xyXG5cdCAgICAgICAgdmFyIGlzR2VuZXJhdG9yID0gaXNBc3luYyA/IGZhbHNlIDogdGhpcy5tYXRjaCgnKicpO1xyXG5cdCAgICAgICAgaWYgKGlzR2VuZXJhdG9yKSB7XHJcblx0ICAgICAgICAgICAgdGhpcy5uZXh0VG9rZW4oKTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIHZhciBtZXNzYWdlO1xyXG5cdCAgICAgICAgdmFyIGlkID0gbnVsbDtcclxuXHQgICAgICAgIHZhciBmaXJzdFJlc3RyaWN0ZWQ7XHJcblx0ICAgICAgICB2YXIgcHJldmlvdXNBbGxvd0F3YWl0ID0gdGhpcy5jb250ZXh0LmF3YWl0O1xyXG5cdCAgICAgICAgdmFyIHByZXZpb3VzQWxsb3dZaWVsZCA9IHRoaXMuY29udGV4dC5hbGxvd1lpZWxkO1xyXG5cdCAgICAgICAgdGhpcy5jb250ZXh0LmF3YWl0ID0gaXNBc3luYztcclxuXHQgICAgICAgIHRoaXMuY29udGV4dC5hbGxvd1lpZWxkID0gIWlzR2VuZXJhdG9yO1xyXG5cdCAgICAgICAgaWYgKCF0aGlzLm1hdGNoKCcoJykpIHtcclxuXHQgICAgICAgICAgICB2YXIgdG9rZW4gPSB0aGlzLmxvb2thaGVhZDtcclxuXHQgICAgICAgICAgICBpZCA9ICghdGhpcy5jb250ZXh0LnN0cmljdCAmJiAhaXNHZW5lcmF0b3IgJiYgdGhpcy5tYXRjaEtleXdvcmQoJ3lpZWxkJykpID8gdGhpcy5wYXJzZUlkZW50aWZpZXJOYW1lKCkgOiB0aGlzLnBhcnNlVmFyaWFibGVJZGVudGlmaWVyKCk7XHJcblx0ICAgICAgICAgICAgaWYgKHRoaXMuY29udGV4dC5zdHJpY3QpIHtcclxuXHQgICAgICAgICAgICAgICAgaWYgKHRoaXMuc2Nhbm5lci5pc1Jlc3RyaWN0ZWRXb3JkKHRva2VuLnZhbHVlKSkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgdGhpcy50b2xlcmF0ZVVuZXhwZWN0ZWRUb2tlbih0b2tlbiwgbWVzc2FnZXNfMS5NZXNzYWdlcy5TdHJpY3RGdW5jdGlvbk5hbWUpO1xyXG5cdCAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgIGVsc2Uge1xyXG5cdCAgICAgICAgICAgICAgICBpZiAodGhpcy5zY2FubmVyLmlzUmVzdHJpY3RlZFdvcmQodG9rZW4udmFsdWUpKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICBmaXJzdFJlc3RyaWN0ZWQgPSB0b2tlbjtcclxuXHQgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UgPSBtZXNzYWdlc18xLk1lc3NhZ2VzLlN0cmljdEZ1bmN0aW9uTmFtZTtcclxuXHQgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICBlbHNlIGlmICh0aGlzLnNjYW5uZXIuaXNTdHJpY3RNb2RlUmVzZXJ2ZWRXb3JkKHRva2VuLnZhbHVlKSkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgZmlyc3RSZXN0cmljdGVkID0gdG9rZW47XHJcblx0ICAgICAgICAgICAgICAgICAgICBtZXNzYWdlID0gbWVzc2FnZXNfMS5NZXNzYWdlcy5TdHJpY3RSZXNlcnZlZFdvcmQ7XHJcblx0ICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICB2YXIgZm9ybWFsUGFyYW1ldGVycyA9IHRoaXMucGFyc2VGb3JtYWxQYXJhbWV0ZXJzKGZpcnN0UmVzdHJpY3RlZCk7XHJcblx0ICAgICAgICB2YXIgcGFyYW1zID0gZm9ybWFsUGFyYW1ldGVycy5wYXJhbXM7XHJcblx0ICAgICAgICB2YXIgc3RyaWN0ZWQgPSBmb3JtYWxQYXJhbWV0ZXJzLnN0cmljdGVkO1xyXG5cdCAgICAgICAgZmlyc3RSZXN0cmljdGVkID0gZm9ybWFsUGFyYW1ldGVycy5maXJzdFJlc3RyaWN0ZWQ7XHJcblx0ICAgICAgICBpZiAoZm9ybWFsUGFyYW1ldGVycy5tZXNzYWdlKSB7XHJcblx0ICAgICAgICAgICAgbWVzc2FnZSA9IGZvcm1hbFBhcmFtZXRlcnMubWVzc2FnZTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIHZhciBwcmV2aW91c1N0cmljdCA9IHRoaXMuY29udGV4dC5zdHJpY3Q7XHJcblx0ICAgICAgICB2YXIgcHJldmlvdXNBbGxvd1N0cmljdERpcmVjdGl2ZSA9IHRoaXMuY29udGV4dC5hbGxvd1N0cmljdERpcmVjdGl2ZTtcclxuXHQgICAgICAgIHRoaXMuY29udGV4dC5hbGxvd1N0cmljdERpcmVjdGl2ZSA9IGZvcm1hbFBhcmFtZXRlcnMuc2ltcGxlO1xyXG5cdCAgICAgICAgdmFyIGJvZHkgPSB0aGlzLnBhcnNlRnVuY3Rpb25Tb3VyY2VFbGVtZW50cygpO1xyXG5cdCAgICAgICAgaWYgKHRoaXMuY29udGV4dC5zdHJpY3QgJiYgZmlyc3RSZXN0cmljdGVkKSB7XHJcblx0ICAgICAgICAgICAgdGhpcy50aHJvd1VuZXhwZWN0ZWRUb2tlbihmaXJzdFJlc3RyaWN0ZWQsIG1lc3NhZ2UpO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgaWYgKHRoaXMuY29udGV4dC5zdHJpY3QgJiYgc3RyaWN0ZWQpIHtcclxuXHQgICAgICAgICAgICB0aGlzLnRvbGVyYXRlVW5leHBlY3RlZFRva2VuKHN0cmljdGVkLCBtZXNzYWdlKTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIHRoaXMuY29udGV4dC5zdHJpY3QgPSBwcmV2aW91c1N0cmljdDtcclxuXHQgICAgICAgIHRoaXMuY29udGV4dC5hbGxvd1N0cmljdERpcmVjdGl2ZSA9IHByZXZpb3VzQWxsb3dTdHJpY3REaXJlY3RpdmU7XHJcblx0ICAgICAgICB0aGlzLmNvbnRleHQuYXdhaXQgPSBwcmV2aW91c0FsbG93QXdhaXQ7XHJcblx0ICAgICAgICB0aGlzLmNvbnRleHQuYWxsb3dZaWVsZCA9IHByZXZpb3VzQWxsb3dZaWVsZDtcclxuXHQgICAgICAgIHJldHVybiBpc0FzeW5jID8gdGhpcy5maW5hbGl6ZShub2RlLCBuZXcgTm9kZS5Bc3luY0Z1bmN0aW9uRXhwcmVzc2lvbihpZCwgcGFyYW1zLCBib2R5KSkgOlxyXG5cdCAgICAgICAgICAgIHRoaXMuZmluYWxpemUobm9kZSwgbmV3IE5vZGUuRnVuY3Rpb25FeHByZXNzaW9uKGlkLCBwYXJhbXMsIGJvZHksIGlzR2VuZXJhdG9yKSk7XHJcblx0ICAgIH07XHJcblx0ICAgIC8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLWRpcmVjdGl2ZS1wcm9sb2d1ZXMtYW5kLXRoZS11c2Utc3RyaWN0LWRpcmVjdGl2ZVxyXG5cdCAgICBQYXJzZXIucHJvdG90eXBlLnBhcnNlRGlyZWN0aXZlID0gZnVuY3Rpb24gKCkge1xyXG5cdCAgICAgICAgdmFyIHRva2VuID0gdGhpcy5sb29rYWhlYWQ7XHJcblx0ICAgICAgICB2YXIgbm9kZSA9IHRoaXMuY3JlYXRlTm9kZSgpO1xyXG5cdCAgICAgICAgdmFyIGV4cHIgPSB0aGlzLnBhcnNlRXhwcmVzc2lvbigpO1xyXG5cdCAgICAgICAgdmFyIGRpcmVjdGl2ZSA9IChleHByLnR5cGUgPT09IHN5bnRheF8xLlN5bnRheC5MaXRlcmFsKSA/IHRoaXMuZ2V0VG9rZW5SYXcodG9rZW4pLnNsaWNlKDEsIC0xKSA6IG51bGw7XHJcblx0ICAgICAgICB0aGlzLmNvbnN1bWVTZW1pY29sb24oKTtcclxuXHQgICAgICAgIHJldHVybiB0aGlzLmZpbmFsaXplKG5vZGUsIGRpcmVjdGl2ZSA/IG5ldyBOb2RlLkRpcmVjdGl2ZShleHByLCBkaXJlY3RpdmUpIDogbmV3IE5vZGUuRXhwcmVzc2lvblN0YXRlbWVudChleHByKSk7XHJcblx0ICAgIH07XHJcblx0ICAgIFBhcnNlci5wcm90b3R5cGUucGFyc2VEaXJlY3RpdmVQcm9sb2d1ZXMgPSBmdW5jdGlvbiAoKSB7XHJcblx0ICAgICAgICB2YXIgZmlyc3RSZXN0cmljdGVkID0gbnVsbDtcclxuXHQgICAgICAgIHZhciBib2R5ID0gW107XHJcblx0ICAgICAgICB3aGlsZSAodHJ1ZSkge1xyXG5cdCAgICAgICAgICAgIHZhciB0b2tlbiA9IHRoaXMubG9va2FoZWFkO1xyXG5cdCAgICAgICAgICAgIGlmICh0b2tlbi50eXBlICE9PSA4IC8qIFN0cmluZ0xpdGVyYWwgKi8pIHtcclxuXHQgICAgICAgICAgICAgICAgYnJlYWs7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgIHZhciBzdGF0ZW1lbnQgPSB0aGlzLnBhcnNlRGlyZWN0aXZlKCk7XHJcblx0ICAgICAgICAgICAgYm9keS5wdXNoKHN0YXRlbWVudCk7XHJcblx0ICAgICAgICAgICAgdmFyIGRpcmVjdGl2ZSA9IHN0YXRlbWVudC5kaXJlY3RpdmU7XHJcblx0ICAgICAgICAgICAgaWYgKHR5cGVvZiBkaXJlY3RpdmUgIT09ICdzdHJpbmcnKSB7XHJcblx0ICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICBpZiAoZGlyZWN0aXZlID09PSAndXNlIHN0cmljdCcpIHtcclxuXHQgICAgICAgICAgICAgICAgdGhpcy5jb250ZXh0LnN0cmljdCA9IHRydWU7XHJcblx0ICAgICAgICAgICAgICAgIGlmIChmaXJzdFJlc3RyaWN0ZWQpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgIHRoaXMudG9sZXJhdGVVbmV4cGVjdGVkVG9rZW4oZmlyc3RSZXN0cmljdGVkLCBtZXNzYWdlc18xLk1lc3NhZ2VzLlN0cmljdE9jdGFsTGl0ZXJhbCk7XHJcblx0ICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgaWYgKCF0aGlzLmNvbnRleHQuYWxsb3dTdHJpY3REaXJlY3RpdmUpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgIHRoaXMudG9sZXJhdGVVbmV4cGVjdGVkVG9rZW4odG9rZW4sIG1lc3NhZ2VzXzEuTWVzc2FnZXMuSWxsZWdhbExhbmd1YWdlTW9kZURpcmVjdGl2ZSk7XHJcblx0ICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgZWxzZSB7XHJcblx0ICAgICAgICAgICAgICAgIGlmICghZmlyc3RSZXN0cmljdGVkICYmIHRva2VuLm9jdGFsKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICBmaXJzdFJlc3RyaWN0ZWQgPSB0b2tlbjtcclxuXHQgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIHJldHVybiBib2R5O1xyXG5cdCAgICB9O1xyXG5cdCAgICAvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1tZXRob2QtZGVmaW5pdGlvbnNcclxuXHQgICAgUGFyc2VyLnByb3RvdHlwZS5xdWFsaWZpZWRQcm9wZXJ0eU5hbWUgPSBmdW5jdGlvbiAodG9rZW4pIHtcclxuXHQgICAgICAgIHN3aXRjaCAodG9rZW4udHlwZSkge1xyXG5cdCAgICAgICAgICAgIGNhc2UgMyAvKiBJZGVudGlmaWVyICovOlxyXG5cdCAgICAgICAgICAgIGNhc2UgOCAvKiBTdHJpbmdMaXRlcmFsICovOlxyXG5cdCAgICAgICAgICAgIGNhc2UgMSAvKiBCb29sZWFuTGl0ZXJhbCAqLzpcclxuXHQgICAgICAgICAgICBjYXNlIDUgLyogTnVsbExpdGVyYWwgKi86XHJcblx0ICAgICAgICAgICAgY2FzZSA2IC8qIE51bWVyaWNMaXRlcmFsICovOlxyXG5cdCAgICAgICAgICAgIGNhc2UgNCAvKiBLZXl3b3JkICovOlxyXG5cdCAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuXHQgICAgICAgICAgICBjYXNlIDcgLyogUHVuY3R1YXRvciAqLzpcclxuXHQgICAgICAgICAgICAgICAgcmV0dXJuIHRva2VuLnZhbHVlID09PSAnWyc7XHJcblx0ICAgICAgICAgICAgZGVmYXVsdDpcclxuXHQgICAgICAgICAgICAgICAgYnJlYWs7XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICByZXR1cm4gZmFsc2U7XHJcblx0ICAgIH07XHJcblx0ICAgIFBhcnNlci5wcm90b3R5cGUucGFyc2VHZXR0ZXJNZXRob2QgPSBmdW5jdGlvbiAoKSB7XHJcblx0ICAgICAgICB2YXIgbm9kZSA9IHRoaXMuY3JlYXRlTm9kZSgpO1xyXG5cdCAgICAgICAgdmFyIGlzR2VuZXJhdG9yID0gZmFsc2U7XHJcblx0ICAgICAgICB2YXIgcHJldmlvdXNBbGxvd1lpZWxkID0gdGhpcy5jb250ZXh0LmFsbG93WWllbGQ7XHJcblx0ICAgICAgICB0aGlzLmNvbnRleHQuYWxsb3dZaWVsZCA9IGZhbHNlO1xyXG5cdCAgICAgICAgdmFyIGZvcm1hbFBhcmFtZXRlcnMgPSB0aGlzLnBhcnNlRm9ybWFsUGFyYW1ldGVycygpO1xyXG5cdCAgICAgICAgaWYgKGZvcm1hbFBhcmFtZXRlcnMucGFyYW1zLmxlbmd0aCA+IDApIHtcclxuXHQgICAgICAgICAgICB0aGlzLnRvbGVyYXRlRXJyb3IobWVzc2FnZXNfMS5NZXNzYWdlcy5CYWRHZXR0ZXJBcml0eSk7XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICB2YXIgbWV0aG9kID0gdGhpcy5wYXJzZVByb3BlcnR5TWV0aG9kKGZvcm1hbFBhcmFtZXRlcnMpO1xyXG5cdCAgICAgICAgdGhpcy5jb250ZXh0LmFsbG93WWllbGQgPSBwcmV2aW91c0FsbG93WWllbGQ7XHJcblx0ICAgICAgICByZXR1cm4gdGhpcy5maW5hbGl6ZShub2RlLCBuZXcgTm9kZS5GdW5jdGlvbkV4cHJlc3Npb24obnVsbCwgZm9ybWFsUGFyYW1ldGVycy5wYXJhbXMsIG1ldGhvZCwgaXNHZW5lcmF0b3IpKTtcclxuXHQgICAgfTtcclxuXHQgICAgUGFyc2VyLnByb3RvdHlwZS5wYXJzZVNldHRlck1ldGhvZCA9IGZ1bmN0aW9uICgpIHtcclxuXHQgICAgICAgIHZhciBub2RlID0gdGhpcy5jcmVhdGVOb2RlKCk7XHJcblx0ICAgICAgICB2YXIgaXNHZW5lcmF0b3IgPSBmYWxzZTtcclxuXHQgICAgICAgIHZhciBwcmV2aW91c0FsbG93WWllbGQgPSB0aGlzLmNvbnRleHQuYWxsb3dZaWVsZDtcclxuXHQgICAgICAgIHRoaXMuY29udGV4dC5hbGxvd1lpZWxkID0gZmFsc2U7XHJcblx0ICAgICAgICB2YXIgZm9ybWFsUGFyYW1ldGVycyA9IHRoaXMucGFyc2VGb3JtYWxQYXJhbWV0ZXJzKCk7XHJcblx0ICAgICAgICBpZiAoZm9ybWFsUGFyYW1ldGVycy5wYXJhbXMubGVuZ3RoICE9PSAxKSB7XHJcblx0ICAgICAgICAgICAgdGhpcy50b2xlcmF0ZUVycm9yKG1lc3NhZ2VzXzEuTWVzc2FnZXMuQmFkU2V0dGVyQXJpdHkpO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgZWxzZSBpZiAoZm9ybWFsUGFyYW1ldGVycy5wYXJhbXNbMF0gaW5zdGFuY2VvZiBOb2RlLlJlc3RFbGVtZW50KSB7XHJcblx0ICAgICAgICAgICAgdGhpcy50b2xlcmF0ZUVycm9yKG1lc3NhZ2VzXzEuTWVzc2FnZXMuQmFkU2V0dGVyUmVzdFBhcmFtZXRlcik7XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICB2YXIgbWV0aG9kID0gdGhpcy5wYXJzZVByb3BlcnR5TWV0aG9kKGZvcm1hbFBhcmFtZXRlcnMpO1xyXG5cdCAgICAgICAgdGhpcy5jb250ZXh0LmFsbG93WWllbGQgPSBwcmV2aW91c0FsbG93WWllbGQ7XHJcblx0ICAgICAgICByZXR1cm4gdGhpcy5maW5hbGl6ZShub2RlLCBuZXcgTm9kZS5GdW5jdGlvbkV4cHJlc3Npb24obnVsbCwgZm9ybWFsUGFyYW1ldGVycy5wYXJhbXMsIG1ldGhvZCwgaXNHZW5lcmF0b3IpKTtcclxuXHQgICAgfTtcclxuXHQgICAgUGFyc2VyLnByb3RvdHlwZS5wYXJzZUdlbmVyYXRvck1ldGhvZCA9IGZ1bmN0aW9uICgpIHtcclxuXHQgICAgICAgIHZhciBub2RlID0gdGhpcy5jcmVhdGVOb2RlKCk7XHJcblx0ICAgICAgICB2YXIgaXNHZW5lcmF0b3IgPSB0cnVlO1xyXG5cdCAgICAgICAgdmFyIHByZXZpb3VzQWxsb3dZaWVsZCA9IHRoaXMuY29udGV4dC5hbGxvd1lpZWxkO1xyXG5cdCAgICAgICAgdGhpcy5jb250ZXh0LmFsbG93WWllbGQgPSB0cnVlO1xyXG5cdCAgICAgICAgdmFyIHBhcmFtcyA9IHRoaXMucGFyc2VGb3JtYWxQYXJhbWV0ZXJzKCk7XHJcblx0ICAgICAgICB0aGlzLmNvbnRleHQuYWxsb3dZaWVsZCA9IGZhbHNlO1xyXG5cdCAgICAgICAgdmFyIG1ldGhvZCA9IHRoaXMucGFyc2VQcm9wZXJ0eU1ldGhvZChwYXJhbXMpO1xyXG5cdCAgICAgICAgdGhpcy5jb250ZXh0LmFsbG93WWllbGQgPSBwcmV2aW91c0FsbG93WWllbGQ7XHJcblx0ICAgICAgICByZXR1cm4gdGhpcy5maW5hbGl6ZShub2RlLCBuZXcgTm9kZS5GdW5jdGlvbkV4cHJlc3Npb24obnVsbCwgcGFyYW1zLnBhcmFtcywgbWV0aG9kLCBpc0dlbmVyYXRvcikpO1xyXG5cdCAgICB9O1xyXG5cdCAgICAvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1nZW5lcmF0b3ItZnVuY3Rpb24tZGVmaW5pdGlvbnNcclxuXHQgICAgUGFyc2VyLnByb3RvdHlwZS5pc1N0YXJ0T2ZFeHByZXNzaW9uID0gZnVuY3Rpb24gKCkge1xyXG5cdCAgICAgICAgdmFyIHN0YXJ0ID0gdHJ1ZTtcclxuXHQgICAgICAgIHZhciB2YWx1ZSA9IHRoaXMubG9va2FoZWFkLnZhbHVlO1xyXG5cdCAgICAgICAgc3dpdGNoICh0aGlzLmxvb2thaGVhZC50eXBlKSB7XHJcblx0ICAgICAgICAgICAgY2FzZSA3IC8qIFB1bmN0dWF0b3IgKi86XHJcblx0ICAgICAgICAgICAgICAgIHN0YXJ0ID0gKHZhbHVlID09PSAnWycpIHx8ICh2YWx1ZSA9PT0gJygnKSB8fCAodmFsdWUgPT09ICd7JykgfHxcclxuXHQgICAgICAgICAgICAgICAgICAgICh2YWx1ZSA9PT0gJysnKSB8fCAodmFsdWUgPT09ICctJykgfHxcclxuXHQgICAgICAgICAgICAgICAgICAgICh2YWx1ZSA9PT0gJyEnKSB8fCAodmFsdWUgPT09ICd+JykgfHxcclxuXHQgICAgICAgICAgICAgICAgICAgICh2YWx1ZSA9PT0gJysrJykgfHwgKHZhbHVlID09PSAnLS0nKSB8fFxyXG5cdCAgICAgICAgICAgICAgICAgICAgKHZhbHVlID09PSAnLycpIHx8ICh2YWx1ZSA9PT0gJy89Jyk7IC8vIHJlZ3VsYXIgZXhwcmVzc2lvbiBsaXRlcmFsXHJcblx0ICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cdCAgICAgICAgICAgIGNhc2UgNCAvKiBLZXl3b3JkICovOlxyXG5cdCAgICAgICAgICAgICAgICBzdGFydCA9ICh2YWx1ZSA9PT0gJ2NsYXNzJykgfHwgKHZhbHVlID09PSAnZGVsZXRlJykgfHxcclxuXHQgICAgICAgICAgICAgICAgICAgICh2YWx1ZSA9PT0gJ2Z1bmN0aW9uJykgfHwgKHZhbHVlID09PSAnbGV0JykgfHwgKHZhbHVlID09PSAnbmV3JykgfHxcclxuXHQgICAgICAgICAgICAgICAgICAgICh2YWx1ZSA9PT0gJ3N1cGVyJykgfHwgKHZhbHVlID09PSAndGhpcycpIHx8ICh2YWx1ZSA9PT0gJ3R5cGVvZicpIHx8XHJcblx0ICAgICAgICAgICAgICAgICAgICAodmFsdWUgPT09ICd2b2lkJykgfHwgKHZhbHVlID09PSAneWllbGQnKTtcclxuXHQgICAgICAgICAgICAgICAgYnJlYWs7XHJcblx0ICAgICAgICAgICAgZGVmYXVsdDpcclxuXHQgICAgICAgICAgICAgICAgYnJlYWs7XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICByZXR1cm4gc3RhcnQ7XHJcblx0ICAgIH07XHJcblx0ICAgIFBhcnNlci5wcm90b3R5cGUucGFyc2VZaWVsZEV4cHJlc3Npb24gPSBmdW5jdGlvbiAoKSB7XHJcblx0ICAgICAgICB2YXIgbm9kZSA9IHRoaXMuY3JlYXRlTm9kZSgpO1xyXG5cdCAgICAgICAgdGhpcy5leHBlY3RLZXl3b3JkKCd5aWVsZCcpO1xyXG5cdCAgICAgICAgdmFyIGFyZ3VtZW50ID0gbnVsbDtcclxuXHQgICAgICAgIHZhciBkZWxlZ2F0ZSA9IGZhbHNlO1xyXG5cdCAgICAgICAgaWYgKCF0aGlzLmhhc0xpbmVUZXJtaW5hdG9yKSB7XHJcblx0ICAgICAgICAgICAgdmFyIHByZXZpb3VzQWxsb3dZaWVsZCA9IHRoaXMuY29udGV4dC5hbGxvd1lpZWxkO1xyXG5cdCAgICAgICAgICAgIHRoaXMuY29udGV4dC5hbGxvd1lpZWxkID0gZmFsc2U7XHJcblx0ICAgICAgICAgICAgZGVsZWdhdGUgPSB0aGlzLm1hdGNoKCcqJyk7XHJcblx0ICAgICAgICAgICAgaWYgKGRlbGVnYXRlKSB7XHJcblx0ICAgICAgICAgICAgICAgIHRoaXMubmV4dFRva2VuKCk7XHJcblx0ICAgICAgICAgICAgICAgIGFyZ3VtZW50ID0gdGhpcy5wYXJzZUFzc2lnbm1lbnRFeHByZXNzaW9uKCk7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMuaXNTdGFydE9mRXhwcmVzc2lvbigpKSB7XHJcblx0ICAgICAgICAgICAgICAgIGFyZ3VtZW50ID0gdGhpcy5wYXJzZUFzc2lnbm1lbnRFeHByZXNzaW9uKCk7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgIHRoaXMuY29udGV4dC5hbGxvd1lpZWxkID0gcHJldmlvdXNBbGxvd1lpZWxkO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgcmV0dXJuIHRoaXMuZmluYWxpemUobm9kZSwgbmV3IE5vZGUuWWllbGRFeHByZXNzaW9uKGFyZ3VtZW50LCBkZWxlZ2F0ZSkpO1xyXG5cdCAgICB9O1xyXG5cdCAgICAvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1jbGFzcy1kZWZpbml0aW9uc1xyXG5cdCAgICBQYXJzZXIucHJvdG90eXBlLnBhcnNlQ2xhc3NFbGVtZW50ID0gZnVuY3Rpb24gKGhhc0NvbnN0cnVjdG9yKSB7XHJcblx0ICAgICAgICB2YXIgdG9rZW4gPSB0aGlzLmxvb2thaGVhZDtcclxuXHQgICAgICAgIHZhciBub2RlID0gdGhpcy5jcmVhdGVOb2RlKCk7XHJcblx0ICAgICAgICB2YXIga2luZCA9ICcnO1xyXG5cdCAgICAgICAgdmFyIGtleSA9IG51bGw7XHJcblx0ICAgICAgICB2YXIgdmFsdWUgPSBudWxsO1xyXG5cdCAgICAgICAgdmFyIGNvbXB1dGVkID0gZmFsc2U7XHJcblx0ICAgICAgICB2YXIgbWV0aG9kID0gZmFsc2U7XHJcblx0ICAgICAgICB2YXIgaXNTdGF0aWMgPSBmYWxzZTtcclxuXHQgICAgICAgIHZhciBpc0FzeW5jID0gZmFsc2U7XHJcblx0ICAgICAgICBpZiAodGhpcy5tYXRjaCgnKicpKSB7XHJcblx0ICAgICAgICAgICAgdGhpcy5uZXh0VG9rZW4oKTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIGVsc2Uge1xyXG5cdCAgICAgICAgICAgIGNvbXB1dGVkID0gdGhpcy5tYXRjaCgnWycpO1xyXG5cdCAgICAgICAgICAgIGtleSA9IHRoaXMucGFyc2VPYmplY3RQcm9wZXJ0eUtleSgpO1xyXG5cdCAgICAgICAgICAgIHZhciBpZCA9IGtleTtcclxuXHQgICAgICAgICAgICBpZiAoaWQubmFtZSA9PT0gJ3N0YXRpYycgJiYgKHRoaXMucXVhbGlmaWVkUHJvcGVydHlOYW1lKHRoaXMubG9va2FoZWFkKSB8fCB0aGlzLm1hdGNoKCcqJykpKSB7XHJcblx0ICAgICAgICAgICAgICAgIHRva2VuID0gdGhpcy5sb29rYWhlYWQ7XHJcblx0ICAgICAgICAgICAgICAgIGlzU3RhdGljID0gdHJ1ZTtcclxuXHQgICAgICAgICAgICAgICAgY29tcHV0ZWQgPSB0aGlzLm1hdGNoKCdbJyk7XHJcblx0ICAgICAgICAgICAgICAgIGlmICh0aGlzLm1hdGNoKCcqJykpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgIHRoaXMubmV4dFRva2VuKCk7XHJcblx0ICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgZWxzZSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICBrZXkgPSB0aGlzLnBhcnNlT2JqZWN0UHJvcGVydHlLZXkoKTtcclxuXHQgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICBpZiAoKHRva2VuLnR5cGUgPT09IDMgLyogSWRlbnRpZmllciAqLykgJiYgIXRoaXMuaGFzTGluZVRlcm1pbmF0b3IgJiYgKHRva2VuLnZhbHVlID09PSAnYXN5bmMnKSkge1xyXG5cdCAgICAgICAgICAgICAgICB2YXIgcHVuY3R1YXRvciA9IHRoaXMubG9va2FoZWFkLnZhbHVlO1xyXG5cdCAgICAgICAgICAgICAgICBpZiAocHVuY3R1YXRvciAhPT0gJzonICYmIHB1bmN0dWF0b3IgIT09ICcoJyAmJiBwdW5jdHVhdG9yICE9PSAnKicpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgIGlzQXN5bmMgPSB0cnVlO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgdG9rZW4gPSB0aGlzLmxvb2thaGVhZDtcclxuXHQgICAgICAgICAgICAgICAgICAgIGtleSA9IHRoaXMucGFyc2VPYmplY3RQcm9wZXJ0eUtleSgpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKHRva2VuLnR5cGUgPT09IDMgLyogSWRlbnRpZmllciAqLykge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0b2tlbi52YWx1ZSA9PT0gJ2dldCcgfHwgdG9rZW4udmFsdWUgPT09ICdzZXQnKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMudG9sZXJhdGVVbmV4cGVjdGVkVG9rZW4odG9rZW4pO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICh0b2tlbi52YWx1ZSA9PT0gJ2NvbnN0cnVjdG9yJykge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnRvbGVyYXRlVW5leHBlY3RlZFRva2VuKHRva2VuLCBtZXNzYWdlc18xLk1lc3NhZ2VzLkNvbnN0cnVjdG9ySXNBc3luYyk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgdmFyIGxvb2thaGVhZFByb3BlcnR5S2V5ID0gdGhpcy5xdWFsaWZpZWRQcm9wZXJ0eU5hbWUodGhpcy5sb29rYWhlYWQpO1xyXG5cdCAgICAgICAgaWYgKHRva2VuLnR5cGUgPT09IDMgLyogSWRlbnRpZmllciAqLykge1xyXG5cdCAgICAgICAgICAgIGlmICh0b2tlbi52YWx1ZSA9PT0gJ2dldCcgJiYgbG9va2FoZWFkUHJvcGVydHlLZXkpIHtcclxuXHQgICAgICAgICAgICAgICAga2luZCA9ICdnZXQnO1xyXG5cdCAgICAgICAgICAgICAgICBjb21wdXRlZCA9IHRoaXMubWF0Y2goJ1snKTtcclxuXHQgICAgICAgICAgICAgICAga2V5ID0gdGhpcy5wYXJzZU9iamVjdFByb3BlcnR5S2V5KCk7XHJcblx0ICAgICAgICAgICAgICAgIHRoaXMuY29udGV4dC5hbGxvd1lpZWxkID0gZmFsc2U7XHJcblx0ICAgICAgICAgICAgICAgIHZhbHVlID0gdGhpcy5wYXJzZUdldHRlck1ldGhvZCgpO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICBlbHNlIGlmICh0b2tlbi52YWx1ZSA9PT0gJ3NldCcgJiYgbG9va2FoZWFkUHJvcGVydHlLZXkpIHtcclxuXHQgICAgICAgICAgICAgICAga2luZCA9ICdzZXQnO1xyXG5cdCAgICAgICAgICAgICAgICBjb21wdXRlZCA9IHRoaXMubWF0Y2goJ1snKTtcclxuXHQgICAgICAgICAgICAgICAga2V5ID0gdGhpcy5wYXJzZU9iamVjdFByb3BlcnR5S2V5KCk7XHJcblx0ICAgICAgICAgICAgICAgIHZhbHVlID0gdGhpcy5wYXJzZVNldHRlck1ldGhvZCgpO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIGVsc2UgaWYgKHRva2VuLnR5cGUgPT09IDcgLyogUHVuY3R1YXRvciAqLyAmJiB0b2tlbi52YWx1ZSA9PT0gJyonICYmIGxvb2thaGVhZFByb3BlcnR5S2V5KSB7XHJcblx0ICAgICAgICAgICAga2luZCA9ICdpbml0JztcclxuXHQgICAgICAgICAgICBjb21wdXRlZCA9IHRoaXMubWF0Y2goJ1snKTtcclxuXHQgICAgICAgICAgICBrZXkgPSB0aGlzLnBhcnNlT2JqZWN0UHJvcGVydHlLZXkoKTtcclxuXHQgICAgICAgICAgICB2YWx1ZSA9IHRoaXMucGFyc2VHZW5lcmF0b3JNZXRob2QoKTtcclxuXHQgICAgICAgICAgICBtZXRob2QgPSB0cnVlO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgaWYgKCFraW5kICYmIGtleSAmJiB0aGlzLm1hdGNoKCcoJykpIHtcclxuXHQgICAgICAgICAgICBraW5kID0gJ2luaXQnO1xyXG5cdCAgICAgICAgICAgIHZhbHVlID0gaXNBc3luYyA/IHRoaXMucGFyc2VQcm9wZXJ0eU1ldGhvZEFzeW5jRnVuY3Rpb24oKSA6IHRoaXMucGFyc2VQcm9wZXJ0eU1ldGhvZEZ1bmN0aW9uKCk7XHJcblx0ICAgICAgICAgICAgbWV0aG9kID0gdHJ1ZTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIGlmICgha2luZCkge1xyXG5cdCAgICAgICAgICAgIHRoaXMudGhyb3dVbmV4cGVjdGVkVG9rZW4odGhpcy5sb29rYWhlYWQpO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgaWYgKGtpbmQgPT09ICdpbml0Jykge1xyXG5cdCAgICAgICAgICAgIGtpbmQgPSAnbWV0aG9kJztcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIGlmICghY29tcHV0ZWQpIHtcclxuXHQgICAgICAgICAgICBpZiAoaXNTdGF0aWMgJiYgdGhpcy5pc1Byb3BlcnR5S2V5KGtleSwgJ3Byb3RvdHlwZScpKSB7XHJcblx0ICAgICAgICAgICAgICAgIHRoaXMudGhyb3dVbmV4cGVjdGVkVG9rZW4odG9rZW4sIG1lc3NhZ2VzXzEuTWVzc2FnZXMuU3RhdGljUHJvdG90eXBlKTtcclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgaWYgKCFpc1N0YXRpYyAmJiB0aGlzLmlzUHJvcGVydHlLZXkoa2V5LCAnY29uc3RydWN0b3InKSkge1xyXG5cdCAgICAgICAgICAgICAgICBpZiAoa2luZCAhPT0gJ21ldGhvZCcgfHwgIW1ldGhvZCB8fCAodmFsdWUgJiYgdmFsdWUuZ2VuZXJhdG9yKSkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgdGhpcy50aHJvd1VuZXhwZWN0ZWRUb2tlbih0b2tlbiwgbWVzc2FnZXNfMS5NZXNzYWdlcy5Db25zdHJ1Y3RvclNwZWNpYWxNZXRob2QpO1xyXG5cdCAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgIGlmIChoYXNDb25zdHJ1Y3Rvci52YWx1ZSkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgdGhpcy50aHJvd1VuZXhwZWN0ZWRUb2tlbih0b2tlbiwgbWVzc2FnZXNfMS5NZXNzYWdlcy5EdXBsaWNhdGVDb25zdHJ1Y3Rvcik7XHJcblx0ICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgZWxzZSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICBoYXNDb25zdHJ1Y3Rvci52YWx1ZSA9IHRydWU7XHJcblx0ICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAga2luZCA9ICdjb25zdHJ1Y3Rvcic7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgcmV0dXJuIHRoaXMuZmluYWxpemUobm9kZSwgbmV3IE5vZGUuTWV0aG9kRGVmaW5pdGlvbihrZXksIGNvbXB1dGVkLCB2YWx1ZSwga2luZCwgaXNTdGF0aWMpKTtcclxuXHQgICAgfTtcclxuXHQgICAgUGFyc2VyLnByb3RvdHlwZS5wYXJzZUNsYXNzRWxlbWVudExpc3QgPSBmdW5jdGlvbiAoKSB7XHJcblx0ICAgICAgICB2YXIgYm9keSA9IFtdO1xyXG5cdCAgICAgICAgdmFyIGhhc0NvbnN0cnVjdG9yID0geyB2YWx1ZTogZmFsc2UgfTtcclxuXHQgICAgICAgIHRoaXMuZXhwZWN0KCd7Jyk7XHJcblx0ICAgICAgICB3aGlsZSAoIXRoaXMubWF0Y2goJ30nKSkge1xyXG5cdCAgICAgICAgICAgIGlmICh0aGlzLm1hdGNoKCc7JykpIHtcclxuXHQgICAgICAgICAgICAgICAgdGhpcy5uZXh0VG9rZW4oKTtcclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgZWxzZSB7XHJcblx0ICAgICAgICAgICAgICAgIGJvZHkucHVzaCh0aGlzLnBhcnNlQ2xhc3NFbGVtZW50KGhhc0NvbnN0cnVjdG9yKSk7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgdGhpcy5leHBlY3QoJ30nKTtcclxuXHQgICAgICAgIHJldHVybiBib2R5O1xyXG5cdCAgICB9O1xyXG5cdCAgICBQYXJzZXIucHJvdG90eXBlLnBhcnNlQ2xhc3NCb2R5ID0gZnVuY3Rpb24gKCkge1xyXG5cdCAgICAgICAgdmFyIG5vZGUgPSB0aGlzLmNyZWF0ZU5vZGUoKTtcclxuXHQgICAgICAgIHZhciBlbGVtZW50TGlzdCA9IHRoaXMucGFyc2VDbGFzc0VsZW1lbnRMaXN0KCk7XHJcblx0ICAgICAgICByZXR1cm4gdGhpcy5maW5hbGl6ZShub2RlLCBuZXcgTm9kZS5DbGFzc0JvZHkoZWxlbWVudExpc3QpKTtcclxuXHQgICAgfTtcclxuXHQgICAgUGFyc2VyLnByb3RvdHlwZS5wYXJzZUNsYXNzRGVjbGFyYXRpb24gPSBmdW5jdGlvbiAoaWRlbnRpZmllcklzT3B0aW9uYWwpIHtcclxuXHQgICAgICAgIHZhciBub2RlID0gdGhpcy5jcmVhdGVOb2RlKCk7XHJcblx0ICAgICAgICB2YXIgcHJldmlvdXNTdHJpY3QgPSB0aGlzLmNvbnRleHQuc3RyaWN0O1xyXG5cdCAgICAgICAgdGhpcy5jb250ZXh0LnN0cmljdCA9IHRydWU7XHJcblx0ICAgICAgICB0aGlzLmV4cGVjdEtleXdvcmQoJ2NsYXNzJyk7XHJcblx0ICAgICAgICB2YXIgaWQgPSAoaWRlbnRpZmllcklzT3B0aW9uYWwgJiYgKHRoaXMubG9va2FoZWFkLnR5cGUgIT09IDMgLyogSWRlbnRpZmllciAqLykpID8gbnVsbCA6IHRoaXMucGFyc2VWYXJpYWJsZUlkZW50aWZpZXIoKTtcclxuXHQgICAgICAgIHZhciBzdXBlckNsYXNzID0gbnVsbDtcclxuXHQgICAgICAgIGlmICh0aGlzLm1hdGNoS2V5d29yZCgnZXh0ZW5kcycpKSB7XHJcblx0ICAgICAgICAgICAgdGhpcy5uZXh0VG9rZW4oKTtcclxuXHQgICAgICAgICAgICBzdXBlckNsYXNzID0gdGhpcy5pc29sYXRlQ292ZXJHcmFtbWFyKHRoaXMucGFyc2VMZWZ0SGFuZFNpZGVFeHByZXNzaW9uQWxsb3dDYWxsKTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIHZhciBjbGFzc0JvZHkgPSB0aGlzLnBhcnNlQ2xhc3NCb2R5KCk7XHJcblx0ICAgICAgICB0aGlzLmNvbnRleHQuc3RyaWN0ID0gcHJldmlvdXNTdHJpY3Q7XHJcblx0ICAgICAgICByZXR1cm4gdGhpcy5maW5hbGl6ZShub2RlLCBuZXcgTm9kZS5DbGFzc0RlY2xhcmF0aW9uKGlkLCBzdXBlckNsYXNzLCBjbGFzc0JvZHkpKTtcclxuXHQgICAgfTtcclxuXHQgICAgUGFyc2VyLnByb3RvdHlwZS5wYXJzZUNsYXNzRXhwcmVzc2lvbiA9IGZ1bmN0aW9uICgpIHtcclxuXHQgICAgICAgIHZhciBub2RlID0gdGhpcy5jcmVhdGVOb2RlKCk7XHJcblx0ICAgICAgICB2YXIgcHJldmlvdXNTdHJpY3QgPSB0aGlzLmNvbnRleHQuc3RyaWN0O1xyXG5cdCAgICAgICAgdGhpcy5jb250ZXh0LnN0cmljdCA9IHRydWU7XHJcblx0ICAgICAgICB0aGlzLmV4cGVjdEtleXdvcmQoJ2NsYXNzJyk7XHJcblx0ICAgICAgICB2YXIgaWQgPSAodGhpcy5sb29rYWhlYWQudHlwZSA9PT0gMyAvKiBJZGVudGlmaWVyICovKSA/IHRoaXMucGFyc2VWYXJpYWJsZUlkZW50aWZpZXIoKSA6IG51bGw7XHJcblx0ICAgICAgICB2YXIgc3VwZXJDbGFzcyA9IG51bGw7XHJcblx0ICAgICAgICBpZiAodGhpcy5tYXRjaEtleXdvcmQoJ2V4dGVuZHMnKSkge1xyXG5cdCAgICAgICAgICAgIHRoaXMubmV4dFRva2VuKCk7XHJcblx0ICAgICAgICAgICAgc3VwZXJDbGFzcyA9IHRoaXMuaXNvbGF0ZUNvdmVyR3JhbW1hcih0aGlzLnBhcnNlTGVmdEhhbmRTaWRlRXhwcmVzc2lvbkFsbG93Q2FsbCk7XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICB2YXIgY2xhc3NCb2R5ID0gdGhpcy5wYXJzZUNsYXNzQm9keSgpO1xyXG5cdCAgICAgICAgdGhpcy5jb250ZXh0LnN0cmljdCA9IHByZXZpb3VzU3RyaWN0O1xyXG5cdCAgICAgICAgcmV0dXJuIHRoaXMuZmluYWxpemUobm9kZSwgbmV3IE5vZGUuQ2xhc3NFeHByZXNzaW9uKGlkLCBzdXBlckNsYXNzLCBjbGFzc0JvZHkpKTtcclxuXHQgICAgfTtcclxuXHQgICAgLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtc2NyaXB0c1xyXG5cdCAgICAvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1tb2R1bGVzXHJcblx0ICAgIFBhcnNlci5wcm90b3R5cGUucGFyc2VNb2R1bGUgPSBmdW5jdGlvbiAoKSB7XHJcblx0ICAgICAgICB0aGlzLmNvbnRleHQuc3RyaWN0ID0gdHJ1ZTtcclxuXHQgICAgICAgIHRoaXMuY29udGV4dC5pc01vZHVsZSA9IHRydWU7XHJcblx0ICAgICAgICB2YXIgbm9kZSA9IHRoaXMuY3JlYXRlTm9kZSgpO1xyXG5cdCAgICAgICAgdmFyIGJvZHkgPSB0aGlzLnBhcnNlRGlyZWN0aXZlUHJvbG9ndWVzKCk7XHJcblx0ICAgICAgICB3aGlsZSAodGhpcy5sb29rYWhlYWQudHlwZSAhPT0gMiAvKiBFT0YgKi8pIHtcclxuXHQgICAgICAgICAgICBib2R5LnB1c2godGhpcy5wYXJzZVN0YXRlbWVudExpc3RJdGVtKCkpO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgcmV0dXJuIHRoaXMuZmluYWxpemUobm9kZSwgbmV3IE5vZGUuTW9kdWxlKGJvZHkpKTtcclxuXHQgICAgfTtcclxuXHQgICAgUGFyc2VyLnByb3RvdHlwZS5wYXJzZVNjcmlwdCA9IGZ1bmN0aW9uICgpIHtcclxuXHQgICAgICAgIHZhciBub2RlID0gdGhpcy5jcmVhdGVOb2RlKCk7XHJcblx0ICAgICAgICB2YXIgYm9keSA9IHRoaXMucGFyc2VEaXJlY3RpdmVQcm9sb2d1ZXMoKTtcclxuXHQgICAgICAgIHdoaWxlICh0aGlzLmxvb2thaGVhZC50eXBlICE9PSAyIC8qIEVPRiAqLykge1xyXG5cdCAgICAgICAgICAgIGJvZHkucHVzaCh0aGlzLnBhcnNlU3RhdGVtZW50TGlzdEl0ZW0oKSk7XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICByZXR1cm4gdGhpcy5maW5hbGl6ZShub2RlLCBuZXcgTm9kZS5TY3JpcHQoYm9keSkpO1xyXG5cdCAgICB9O1xyXG5cdCAgICAvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1pbXBvcnRzXHJcblx0ICAgIFBhcnNlci5wcm90b3R5cGUucGFyc2VNb2R1bGVTcGVjaWZpZXIgPSBmdW5jdGlvbiAoKSB7XHJcblx0ICAgICAgICB2YXIgbm9kZSA9IHRoaXMuY3JlYXRlTm9kZSgpO1xyXG5cdCAgICAgICAgaWYgKHRoaXMubG9va2FoZWFkLnR5cGUgIT09IDggLyogU3RyaW5nTGl0ZXJhbCAqLykge1xyXG5cdCAgICAgICAgICAgIHRoaXMudGhyb3dFcnJvcihtZXNzYWdlc18xLk1lc3NhZ2VzLkludmFsaWRNb2R1bGVTcGVjaWZpZXIpO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgdmFyIHRva2VuID0gdGhpcy5uZXh0VG9rZW4oKTtcclxuXHQgICAgICAgIHZhciByYXcgPSB0aGlzLmdldFRva2VuUmF3KHRva2VuKTtcclxuXHQgICAgICAgIHJldHVybiB0aGlzLmZpbmFsaXplKG5vZGUsIG5ldyBOb2RlLkxpdGVyYWwodG9rZW4udmFsdWUsIHJhdykpO1xyXG5cdCAgICB9O1xyXG5cdCAgICAvLyBpbXBvcnQgezxmb28gYXMgYmFyPn0gLi4uO1xyXG5cdCAgICBQYXJzZXIucHJvdG90eXBlLnBhcnNlSW1wb3J0U3BlY2lmaWVyID0gZnVuY3Rpb24gKCkge1xyXG5cdCAgICAgICAgdmFyIG5vZGUgPSB0aGlzLmNyZWF0ZU5vZGUoKTtcclxuXHQgICAgICAgIHZhciBpbXBvcnRlZDtcclxuXHQgICAgICAgIHZhciBsb2NhbDtcclxuXHQgICAgICAgIGlmICh0aGlzLmxvb2thaGVhZC50eXBlID09PSAzIC8qIElkZW50aWZpZXIgKi8pIHtcclxuXHQgICAgICAgICAgICBpbXBvcnRlZCA9IHRoaXMucGFyc2VWYXJpYWJsZUlkZW50aWZpZXIoKTtcclxuXHQgICAgICAgICAgICBsb2NhbCA9IGltcG9ydGVkO1xyXG5cdCAgICAgICAgICAgIGlmICh0aGlzLm1hdGNoQ29udGV4dHVhbEtleXdvcmQoJ2FzJykpIHtcclxuXHQgICAgICAgICAgICAgICAgdGhpcy5uZXh0VG9rZW4oKTtcclxuXHQgICAgICAgICAgICAgICAgbG9jYWwgPSB0aGlzLnBhcnNlVmFyaWFibGVJZGVudGlmaWVyKCk7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgZWxzZSB7XHJcblx0ICAgICAgICAgICAgaW1wb3J0ZWQgPSB0aGlzLnBhcnNlSWRlbnRpZmllck5hbWUoKTtcclxuXHQgICAgICAgICAgICBsb2NhbCA9IGltcG9ydGVkO1xyXG5cdCAgICAgICAgICAgIGlmICh0aGlzLm1hdGNoQ29udGV4dHVhbEtleXdvcmQoJ2FzJykpIHtcclxuXHQgICAgICAgICAgICAgICAgdGhpcy5uZXh0VG9rZW4oKTtcclxuXHQgICAgICAgICAgICAgICAgbG9jYWwgPSB0aGlzLnBhcnNlVmFyaWFibGVJZGVudGlmaWVyKCk7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgIGVsc2Uge1xyXG5cdCAgICAgICAgICAgICAgICB0aGlzLnRocm93VW5leHBlY3RlZFRva2VuKHRoaXMubmV4dFRva2VuKCkpO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIHJldHVybiB0aGlzLmZpbmFsaXplKG5vZGUsIG5ldyBOb2RlLkltcG9ydFNwZWNpZmllcihsb2NhbCwgaW1wb3J0ZWQpKTtcclxuXHQgICAgfTtcclxuXHQgICAgLy8ge2ZvbywgYmFyIGFzIGJhc31cclxuXHQgICAgUGFyc2VyLnByb3RvdHlwZS5wYXJzZU5hbWVkSW1wb3J0cyA9IGZ1bmN0aW9uICgpIHtcclxuXHQgICAgICAgIHRoaXMuZXhwZWN0KCd7Jyk7XHJcblx0ICAgICAgICB2YXIgc3BlY2lmaWVycyA9IFtdO1xyXG5cdCAgICAgICAgd2hpbGUgKCF0aGlzLm1hdGNoKCd9JykpIHtcclxuXHQgICAgICAgICAgICBzcGVjaWZpZXJzLnB1c2godGhpcy5wYXJzZUltcG9ydFNwZWNpZmllcigpKTtcclxuXHQgICAgICAgICAgICBpZiAoIXRoaXMubWF0Y2goJ30nKSkge1xyXG5cdCAgICAgICAgICAgICAgICB0aGlzLmV4cGVjdCgnLCcpO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIHRoaXMuZXhwZWN0KCd9Jyk7XHJcblx0ICAgICAgICByZXR1cm4gc3BlY2lmaWVycztcclxuXHQgICAgfTtcclxuXHQgICAgLy8gaW1wb3J0IDxmb28+IC4uLjtcclxuXHQgICAgUGFyc2VyLnByb3RvdHlwZS5wYXJzZUltcG9ydERlZmF1bHRTcGVjaWZpZXIgPSBmdW5jdGlvbiAoKSB7XHJcblx0ICAgICAgICB2YXIgbm9kZSA9IHRoaXMuY3JlYXRlTm9kZSgpO1xyXG5cdCAgICAgICAgdmFyIGxvY2FsID0gdGhpcy5wYXJzZUlkZW50aWZpZXJOYW1lKCk7XHJcblx0ICAgICAgICByZXR1cm4gdGhpcy5maW5hbGl6ZShub2RlLCBuZXcgTm9kZS5JbXBvcnREZWZhdWx0U3BlY2lmaWVyKGxvY2FsKSk7XHJcblx0ICAgIH07XHJcblx0ICAgIC8vIGltcG9ydCA8KiBhcyBmb28+IC4uLjtcclxuXHQgICAgUGFyc2VyLnByb3RvdHlwZS5wYXJzZUltcG9ydE5hbWVzcGFjZVNwZWNpZmllciA9IGZ1bmN0aW9uICgpIHtcclxuXHQgICAgICAgIHZhciBub2RlID0gdGhpcy5jcmVhdGVOb2RlKCk7XHJcblx0ICAgICAgICB0aGlzLmV4cGVjdCgnKicpO1xyXG5cdCAgICAgICAgaWYgKCF0aGlzLm1hdGNoQ29udGV4dHVhbEtleXdvcmQoJ2FzJykpIHtcclxuXHQgICAgICAgICAgICB0aGlzLnRocm93RXJyb3IobWVzc2FnZXNfMS5NZXNzYWdlcy5Ob0FzQWZ0ZXJJbXBvcnROYW1lc3BhY2UpO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgdGhpcy5uZXh0VG9rZW4oKTtcclxuXHQgICAgICAgIHZhciBsb2NhbCA9IHRoaXMucGFyc2VJZGVudGlmaWVyTmFtZSgpO1xyXG5cdCAgICAgICAgcmV0dXJuIHRoaXMuZmluYWxpemUobm9kZSwgbmV3IE5vZGUuSW1wb3J0TmFtZXNwYWNlU3BlY2lmaWVyKGxvY2FsKSk7XHJcblx0ICAgIH07XHJcblx0ICAgIFBhcnNlci5wcm90b3R5cGUucGFyc2VJbXBvcnREZWNsYXJhdGlvbiA9IGZ1bmN0aW9uICgpIHtcclxuXHQgICAgICAgIGlmICh0aGlzLmNvbnRleHQuaW5GdW5jdGlvbkJvZHkpIHtcclxuXHQgICAgICAgICAgICB0aGlzLnRocm93RXJyb3IobWVzc2FnZXNfMS5NZXNzYWdlcy5JbGxlZ2FsSW1wb3J0RGVjbGFyYXRpb24pO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgdmFyIG5vZGUgPSB0aGlzLmNyZWF0ZU5vZGUoKTtcclxuXHQgICAgICAgIHRoaXMuZXhwZWN0S2V5d29yZCgnaW1wb3J0Jyk7XHJcblx0ICAgICAgICB2YXIgc3JjO1xyXG5cdCAgICAgICAgdmFyIHNwZWNpZmllcnMgPSBbXTtcclxuXHQgICAgICAgIGlmICh0aGlzLmxvb2thaGVhZC50eXBlID09PSA4IC8qIFN0cmluZ0xpdGVyYWwgKi8pIHtcclxuXHQgICAgICAgICAgICAvLyBpbXBvcnQgJ2Zvbyc7XHJcblx0ICAgICAgICAgICAgc3JjID0gdGhpcy5wYXJzZU1vZHVsZVNwZWNpZmllcigpO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgZWxzZSB7XHJcblx0ICAgICAgICAgICAgaWYgKHRoaXMubWF0Y2goJ3snKSkge1xyXG5cdCAgICAgICAgICAgICAgICAvLyBpbXBvcnQge2Jhcn1cclxuXHQgICAgICAgICAgICAgICAgc3BlY2lmaWVycyA9IHNwZWNpZmllcnMuY29uY2F0KHRoaXMucGFyc2VOYW1lZEltcG9ydHMoKSk7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMubWF0Y2goJyonKSkge1xyXG5cdCAgICAgICAgICAgICAgICAvLyBpbXBvcnQgKiBhcyBmb29cclxuXHQgICAgICAgICAgICAgICAgc3BlY2lmaWVycy5wdXNoKHRoaXMucGFyc2VJbXBvcnROYW1lc3BhY2VTcGVjaWZpZXIoKSk7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMuaXNJZGVudGlmaWVyTmFtZSh0aGlzLmxvb2thaGVhZCkgJiYgIXRoaXMubWF0Y2hLZXl3b3JkKCdkZWZhdWx0JykpIHtcclxuXHQgICAgICAgICAgICAgICAgLy8gaW1wb3J0IGZvb1xyXG5cdCAgICAgICAgICAgICAgICBzcGVjaWZpZXJzLnB1c2godGhpcy5wYXJzZUltcG9ydERlZmF1bHRTcGVjaWZpZXIoKSk7XHJcblx0ICAgICAgICAgICAgICAgIGlmICh0aGlzLm1hdGNoKCcsJykpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgIHRoaXMubmV4dFRva2VuKCk7XHJcblx0ICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5tYXRjaCgnKicpKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgLy8gaW1wb3J0IGZvbywgKiBhcyBmb29cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBzcGVjaWZpZXJzLnB1c2godGhpcy5wYXJzZUltcG9ydE5hbWVzcGFjZVNwZWNpZmllcigpKTtcclxuXHQgICAgICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMubWF0Y2goJ3snKSkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIC8vIGltcG9ydCBmb28sIHtiYXJ9XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgc3BlY2lmaWVycyA9IHNwZWNpZmllcnMuY29uY2F0KHRoaXMucGFyc2VOYW1lZEltcG9ydHMoKSk7XHJcblx0ICAgICAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnRocm93VW5leHBlY3RlZFRva2VuKHRoaXMubG9va2FoZWFkKTtcclxuXHQgICAgICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICBlbHNlIHtcclxuXHQgICAgICAgICAgICAgICAgdGhpcy50aHJvd1VuZXhwZWN0ZWRUb2tlbih0aGlzLm5leHRUb2tlbigpKTtcclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgaWYgKCF0aGlzLm1hdGNoQ29udGV4dHVhbEtleXdvcmQoJ2Zyb20nKSkge1xyXG5cdCAgICAgICAgICAgICAgICB2YXIgbWVzc2FnZSA9IHRoaXMubG9va2FoZWFkLnZhbHVlID8gbWVzc2FnZXNfMS5NZXNzYWdlcy5VbmV4cGVjdGVkVG9rZW4gOiBtZXNzYWdlc18xLk1lc3NhZ2VzLk1pc3NpbmdGcm9tQ2xhdXNlO1xyXG5cdCAgICAgICAgICAgICAgICB0aGlzLnRocm93RXJyb3IobWVzc2FnZSwgdGhpcy5sb29rYWhlYWQudmFsdWUpO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICB0aGlzLm5leHRUb2tlbigpO1xyXG5cdCAgICAgICAgICAgIHNyYyA9IHRoaXMucGFyc2VNb2R1bGVTcGVjaWZpZXIoKTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIHRoaXMuY29uc3VtZVNlbWljb2xvbigpO1xyXG5cdCAgICAgICAgcmV0dXJuIHRoaXMuZmluYWxpemUobm9kZSwgbmV3IE5vZGUuSW1wb3J0RGVjbGFyYXRpb24oc3BlY2lmaWVycywgc3JjKSk7XHJcblx0ICAgIH07XHJcblx0ICAgIC8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLWV4cG9ydHNcclxuXHQgICAgUGFyc2VyLnByb3RvdHlwZS5wYXJzZUV4cG9ydFNwZWNpZmllciA9IGZ1bmN0aW9uICgpIHtcclxuXHQgICAgICAgIHZhciBub2RlID0gdGhpcy5jcmVhdGVOb2RlKCk7XHJcblx0ICAgICAgICB2YXIgbG9jYWwgPSB0aGlzLnBhcnNlSWRlbnRpZmllck5hbWUoKTtcclxuXHQgICAgICAgIHZhciBleHBvcnRlZCA9IGxvY2FsO1xyXG5cdCAgICAgICAgaWYgKHRoaXMubWF0Y2hDb250ZXh0dWFsS2V5d29yZCgnYXMnKSkge1xyXG5cdCAgICAgICAgICAgIHRoaXMubmV4dFRva2VuKCk7XHJcblx0ICAgICAgICAgICAgZXhwb3J0ZWQgPSB0aGlzLnBhcnNlSWRlbnRpZmllck5hbWUoKTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIHJldHVybiB0aGlzLmZpbmFsaXplKG5vZGUsIG5ldyBOb2RlLkV4cG9ydFNwZWNpZmllcihsb2NhbCwgZXhwb3J0ZWQpKTtcclxuXHQgICAgfTtcclxuXHQgICAgUGFyc2VyLnByb3RvdHlwZS5wYXJzZUV4cG9ydERlY2xhcmF0aW9uID0gZnVuY3Rpb24gKCkge1xyXG5cdCAgICAgICAgaWYgKHRoaXMuY29udGV4dC5pbkZ1bmN0aW9uQm9keSkge1xyXG5cdCAgICAgICAgICAgIHRoaXMudGhyb3dFcnJvcihtZXNzYWdlc18xLk1lc3NhZ2VzLklsbGVnYWxFeHBvcnREZWNsYXJhdGlvbik7XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICB2YXIgbm9kZSA9IHRoaXMuY3JlYXRlTm9kZSgpO1xyXG5cdCAgICAgICAgdGhpcy5leHBlY3RLZXl3b3JkKCdleHBvcnQnKTtcclxuXHQgICAgICAgIHZhciBleHBvcnREZWNsYXJhdGlvbjtcclxuXHQgICAgICAgIGlmICh0aGlzLm1hdGNoS2V5d29yZCgnZGVmYXVsdCcpKSB7XHJcblx0ICAgICAgICAgICAgLy8gZXhwb3J0IGRlZmF1bHQgLi4uXHJcblx0ICAgICAgICAgICAgdGhpcy5uZXh0VG9rZW4oKTtcclxuXHQgICAgICAgICAgICBpZiAodGhpcy5tYXRjaEtleXdvcmQoJ2Z1bmN0aW9uJykpIHtcclxuXHQgICAgICAgICAgICAgICAgLy8gZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZm9vICgpIHt9XHJcblx0ICAgICAgICAgICAgICAgIC8vIGV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uICgpIHt9XHJcblx0ICAgICAgICAgICAgICAgIHZhciBkZWNsYXJhdGlvbiA9IHRoaXMucGFyc2VGdW5jdGlvbkRlY2xhcmF0aW9uKHRydWUpO1xyXG5cdCAgICAgICAgICAgICAgICBleHBvcnREZWNsYXJhdGlvbiA9IHRoaXMuZmluYWxpemUobm9kZSwgbmV3IE5vZGUuRXhwb3J0RGVmYXVsdERlY2xhcmF0aW9uKGRlY2xhcmF0aW9uKSk7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMubWF0Y2hLZXl3b3JkKCdjbGFzcycpKSB7XHJcblx0ICAgICAgICAgICAgICAgIC8vIGV4cG9ydCBkZWZhdWx0IGNsYXNzIGZvbyB7fVxyXG5cdCAgICAgICAgICAgICAgICB2YXIgZGVjbGFyYXRpb24gPSB0aGlzLnBhcnNlQ2xhc3NEZWNsYXJhdGlvbih0cnVlKTtcclxuXHQgICAgICAgICAgICAgICAgZXhwb3J0RGVjbGFyYXRpb24gPSB0aGlzLmZpbmFsaXplKG5vZGUsIG5ldyBOb2RlLkV4cG9ydERlZmF1bHREZWNsYXJhdGlvbihkZWNsYXJhdGlvbikpO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICBlbHNlIGlmICh0aGlzLm1hdGNoQ29udGV4dHVhbEtleXdvcmQoJ2FzeW5jJykpIHtcclxuXHQgICAgICAgICAgICAgICAgLy8gZXhwb3J0IGRlZmF1bHQgYXN5bmMgZnVuY3Rpb24gZiAoKSB7fVxyXG5cdCAgICAgICAgICAgICAgICAvLyBleHBvcnQgZGVmYXVsdCBhc3luYyBmdW5jdGlvbiAoKSB7fVxyXG5cdCAgICAgICAgICAgICAgICAvLyBleHBvcnQgZGVmYXVsdCBhc3luYyB4ID0+IHhcclxuXHQgICAgICAgICAgICAgICAgdmFyIGRlY2xhcmF0aW9uID0gdGhpcy5tYXRjaEFzeW5jRnVuY3Rpb24oKSA/IHRoaXMucGFyc2VGdW5jdGlvbkRlY2xhcmF0aW9uKHRydWUpIDogdGhpcy5wYXJzZUFzc2lnbm1lbnRFeHByZXNzaW9uKCk7XHJcblx0ICAgICAgICAgICAgICAgIGV4cG9ydERlY2xhcmF0aW9uID0gdGhpcy5maW5hbGl6ZShub2RlLCBuZXcgTm9kZS5FeHBvcnREZWZhdWx0RGVjbGFyYXRpb24oZGVjbGFyYXRpb24pKTtcclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgZWxzZSB7XHJcblx0ICAgICAgICAgICAgICAgIGlmICh0aGlzLm1hdGNoQ29udGV4dHVhbEtleXdvcmQoJ2Zyb20nKSkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgdGhpcy50aHJvd0Vycm9yKG1lc3NhZ2VzXzEuTWVzc2FnZXMuVW5leHBlY3RlZFRva2VuLCB0aGlzLmxvb2thaGVhZC52YWx1ZSk7XHJcblx0ICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgLy8gZXhwb3J0IGRlZmF1bHQge307XHJcblx0ICAgICAgICAgICAgICAgIC8vIGV4cG9ydCBkZWZhdWx0IFtdO1xyXG5cdCAgICAgICAgICAgICAgICAvLyBleHBvcnQgZGVmYXVsdCAoMSArIDIpO1xyXG5cdCAgICAgICAgICAgICAgICB2YXIgZGVjbGFyYXRpb24gPSB0aGlzLm1hdGNoKCd7JykgPyB0aGlzLnBhcnNlT2JqZWN0SW5pdGlhbGl6ZXIoKSA6XHJcblx0ICAgICAgICAgICAgICAgICAgICB0aGlzLm1hdGNoKCdbJykgPyB0aGlzLnBhcnNlQXJyYXlJbml0aWFsaXplcigpIDogdGhpcy5wYXJzZUFzc2lnbm1lbnRFeHByZXNzaW9uKCk7XHJcblx0ICAgICAgICAgICAgICAgIHRoaXMuY29uc3VtZVNlbWljb2xvbigpO1xyXG5cdCAgICAgICAgICAgICAgICBleHBvcnREZWNsYXJhdGlvbiA9IHRoaXMuZmluYWxpemUobm9kZSwgbmV3IE5vZGUuRXhwb3J0RGVmYXVsdERlY2xhcmF0aW9uKGRlY2xhcmF0aW9uKSk7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgZWxzZSBpZiAodGhpcy5tYXRjaCgnKicpKSB7XHJcblx0ICAgICAgICAgICAgLy8gZXhwb3J0ICogZnJvbSAnZm9vJztcclxuXHQgICAgICAgICAgICB0aGlzLm5leHRUb2tlbigpO1xyXG5cdCAgICAgICAgICAgIGlmICghdGhpcy5tYXRjaENvbnRleHR1YWxLZXl3b3JkKCdmcm9tJykpIHtcclxuXHQgICAgICAgICAgICAgICAgdmFyIG1lc3NhZ2UgPSB0aGlzLmxvb2thaGVhZC52YWx1ZSA/IG1lc3NhZ2VzXzEuTWVzc2FnZXMuVW5leHBlY3RlZFRva2VuIDogbWVzc2FnZXNfMS5NZXNzYWdlcy5NaXNzaW5nRnJvbUNsYXVzZTtcclxuXHQgICAgICAgICAgICAgICAgdGhpcy50aHJvd0Vycm9yKG1lc3NhZ2UsIHRoaXMubG9va2FoZWFkLnZhbHVlKTtcclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgdGhpcy5uZXh0VG9rZW4oKTtcclxuXHQgICAgICAgICAgICB2YXIgc3JjID0gdGhpcy5wYXJzZU1vZHVsZVNwZWNpZmllcigpO1xyXG5cdCAgICAgICAgICAgIHRoaXMuY29uc3VtZVNlbWljb2xvbigpO1xyXG5cdCAgICAgICAgICAgIGV4cG9ydERlY2xhcmF0aW9uID0gdGhpcy5maW5hbGl6ZShub2RlLCBuZXcgTm9kZS5FeHBvcnRBbGxEZWNsYXJhdGlvbihzcmMpKTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIGVsc2UgaWYgKHRoaXMubG9va2FoZWFkLnR5cGUgPT09IDQgLyogS2V5d29yZCAqLykge1xyXG5cdCAgICAgICAgICAgIC8vIGV4cG9ydCB2YXIgZiA9IDE7XHJcblx0ICAgICAgICAgICAgdmFyIGRlY2xhcmF0aW9uID0gdm9pZCAwO1xyXG5cdCAgICAgICAgICAgIHN3aXRjaCAodGhpcy5sb29rYWhlYWQudmFsdWUpIHtcclxuXHQgICAgICAgICAgICAgICAgY2FzZSAnbGV0JzpcclxuXHQgICAgICAgICAgICAgICAgY2FzZSAnY29uc3QnOlxyXG5cdCAgICAgICAgICAgICAgICAgICAgZGVjbGFyYXRpb24gPSB0aGlzLnBhcnNlTGV4aWNhbERlY2xhcmF0aW9uKHsgaW5Gb3I6IGZhbHNlIH0pO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcblx0ICAgICAgICAgICAgICAgIGNhc2UgJ3Zhcic6XHJcblx0ICAgICAgICAgICAgICAgIGNhc2UgJ2NsYXNzJzpcclxuXHQgICAgICAgICAgICAgICAgY2FzZSAnZnVuY3Rpb24nOlxyXG5cdCAgICAgICAgICAgICAgICAgICAgZGVjbGFyYXRpb24gPSB0aGlzLnBhcnNlU3RhdGVtZW50TGlzdEl0ZW0oKTtcclxuXHQgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cdCAgICAgICAgICAgICAgICBkZWZhdWx0OlxyXG5cdCAgICAgICAgICAgICAgICAgICAgdGhpcy50aHJvd1VuZXhwZWN0ZWRUb2tlbih0aGlzLmxvb2thaGVhZCk7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgIGV4cG9ydERlY2xhcmF0aW9uID0gdGhpcy5maW5hbGl6ZShub2RlLCBuZXcgTm9kZS5FeHBvcnROYW1lZERlY2xhcmF0aW9uKGRlY2xhcmF0aW9uLCBbXSwgbnVsbCkpO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgZWxzZSBpZiAodGhpcy5tYXRjaEFzeW5jRnVuY3Rpb24oKSkge1xyXG5cdCAgICAgICAgICAgIHZhciBkZWNsYXJhdGlvbiA9IHRoaXMucGFyc2VGdW5jdGlvbkRlY2xhcmF0aW9uKCk7XHJcblx0ICAgICAgICAgICAgZXhwb3J0RGVjbGFyYXRpb24gPSB0aGlzLmZpbmFsaXplKG5vZGUsIG5ldyBOb2RlLkV4cG9ydE5hbWVkRGVjbGFyYXRpb24oZGVjbGFyYXRpb24sIFtdLCBudWxsKSk7XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICBlbHNlIHtcclxuXHQgICAgICAgICAgICB2YXIgc3BlY2lmaWVycyA9IFtdO1xyXG5cdCAgICAgICAgICAgIHZhciBzb3VyY2UgPSBudWxsO1xyXG5cdCAgICAgICAgICAgIHZhciBpc0V4cG9ydEZyb21JZGVudGlmaWVyID0gZmFsc2U7XHJcblx0ICAgICAgICAgICAgdGhpcy5leHBlY3QoJ3snKTtcclxuXHQgICAgICAgICAgICB3aGlsZSAoIXRoaXMubWF0Y2goJ30nKSkge1xyXG5cdCAgICAgICAgICAgICAgICBpc0V4cG9ydEZyb21JZGVudGlmaWVyID0gaXNFeHBvcnRGcm9tSWRlbnRpZmllciB8fCB0aGlzLm1hdGNoS2V5d29yZCgnZGVmYXVsdCcpO1xyXG5cdCAgICAgICAgICAgICAgICBzcGVjaWZpZXJzLnB1c2godGhpcy5wYXJzZUV4cG9ydFNwZWNpZmllcigpKTtcclxuXHQgICAgICAgICAgICAgICAgaWYgKCF0aGlzLm1hdGNoKCd9JykpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgIHRoaXMuZXhwZWN0KCcsJyk7XHJcblx0ICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgdGhpcy5leHBlY3QoJ30nKTtcclxuXHQgICAgICAgICAgICBpZiAodGhpcy5tYXRjaENvbnRleHR1YWxLZXl3b3JkKCdmcm9tJykpIHtcclxuXHQgICAgICAgICAgICAgICAgLy8gZXhwb3J0IHtkZWZhdWx0fSBmcm9tICdmb28nO1xyXG5cdCAgICAgICAgICAgICAgICAvLyBleHBvcnQge2Zvb30gZnJvbSAnZm9vJztcclxuXHQgICAgICAgICAgICAgICAgdGhpcy5uZXh0VG9rZW4oKTtcclxuXHQgICAgICAgICAgICAgICAgc291cmNlID0gdGhpcy5wYXJzZU1vZHVsZVNwZWNpZmllcigpO1xyXG5cdCAgICAgICAgICAgICAgICB0aGlzLmNvbnN1bWVTZW1pY29sb24oKTtcclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgZWxzZSBpZiAoaXNFeHBvcnRGcm9tSWRlbnRpZmllcikge1xyXG5cdCAgICAgICAgICAgICAgICAvLyBleHBvcnQge2RlZmF1bHR9OyAvLyBtaXNzaW5nIGZyb21DbGF1c2VcclxuXHQgICAgICAgICAgICAgICAgdmFyIG1lc3NhZ2UgPSB0aGlzLmxvb2thaGVhZC52YWx1ZSA/IG1lc3NhZ2VzXzEuTWVzc2FnZXMuVW5leHBlY3RlZFRva2VuIDogbWVzc2FnZXNfMS5NZXNzYWdlcy5NaXNzaW5nRnJvbUNsYXVzZTtcclxuXHQgICAgICAgICAgICAgICAgdGhpcy50aHJvd0Vycm9yKG1lc3NhZ2UsIHRoaXMubG9va2FoZWFkLnZhbHVlKTtcclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgZWxzZSB7XHJcblx0ICAgICAgICAgICAgICAgIC8vIGV4cG9ydCB7Zm9vfTtcclxuXHQgICAgICAgICAgICAgICAgdGhpcy5jb25zdW1lU2VtaWNvbG9uKCk7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgIGV4cG9ydERlY2xhcmF0aW9uID0gdGhpcy5maW5hbGl6ZShub2RlLCBuZXcgTm9kZS5FeHBvcnROYW1lZERlY2xhcmF0aW9uKG51bGwsIHNwZWNpZmllcnMsIHNvdXJjZSkpO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgcmV0dXJuIGV4cG9ydERlY2xhcmF0aW9uO1xyXG5cdCAgICB9O1xyXG5cdCAgICByZXR1cm4gUGFyc2VyO1xyXG5cdH0oKSk7XHJcblx0ZXhwb3J0cy5QYXJzZXIgPSBQYXJzZXI7XHJcblxuXG4vKioqLyB9LFxuLyogOSAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cblx0XCJ1c2Ugc3RyaWN0XCI7XHJcblx0Ly8gRW5zdXJlIHRoZSBjb25kaXRpb24gaXMgdHJ1ZSwgb3RoZXJ3aXNlIHRocm93IGFuIGVycm9yLlxyXG5cdC8vIFRoaXMgaXMgb25seSB0byBoYXZlIGEgYmV0dGVyIGNvbnRyYWN0IHNlbWFudGljLCBpLmUuIGFub3RoZXIgc2FmZXR5IG5ldFxyXG5cdC8vIHRvIGNhdGNoIGEgbG9naWMgZXJyb3IuIFRoZSBjb25kaXRpb24gc2hhbGwgYmUgZnVsZmlsbGVkIGluIG5vcm1hbCBjYXNlLlxyXG5cdC8vIERvIE5PVCB1c2UgdGhpcyB0byBlbmZvcmNlIGEgY2VydGFpbiBjb25kaXRpb24gb24gYW55IHVzZXIgaW5wdXQuXHJcblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG5cdGZ1bmN0aW9uIGFzc2VydChjb25kaXRpb24sIG1lc3NhZ2UpIHtcclxuXHQgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXHJcblx0ICAgIGlmICghY29uZGl0aW9uKSB7XHJcblx0ICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0FTU0VSVDogJyArIG1lc3NhZ2UpO1xyXG5cdCAgICB9XHJcblx0fVxyXG5cdGV4cG9ydHMuYXNzZXJ0ID0gYXNzZXJ0O1xyXG5cblxuLyoqKi8gfSxcbi8qIDEwICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxuXHRcInVzZSBzdHJpY3RcIjtcclxuXHQvKiB0c2xpbnQ6ZGlzYWJsZTptYXgtY2xhc3Nlcy1wZXItZmlsZSAqL1xyXG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuXHR2YXIgRXJyb3JIYW5kbGVyID0gKGZ1bmN0aW9uICgpIHtcclxuXHQgICAgZnVuY3Rpb24gRXJyb3JIYW5kbGVyKCkge1xyXG5cdCAgICAgICAgdGhpcy5lcnJvcnMgPSBbXTtcclxuXHQgICAgICAgIHRoaXMudG9sZXJhbnQgPSBmYWxzZTtcclxuXHQgICAgfVxyXG5cdCAgICBFcnJvckhhbmRsZXIucHJvdG90eXBlLnJlY29yZEVycm9yID0gZnVuY3Rpb24gKGVycm9yKSB7XHJcblx0ICAgICAgICB0aGlzLmVycm9ycy5wdXNoKGVycm9yKTtcclxuXHQgICAgfTtcclxuXHQgICAgRXJyb3JIYW5kbGVyLnByb3RvdHlwZS50b2xlcmF0ZSA9IGZ1bmN0aW9uIChlcnJvcikge1xyXG5cdCAgICAgICAgaWYgKHRoaXMudG9sZXJhbnQpIHtcclxuXHQgICAgICAgICAgICB0aGlzLnJlY29yZEVycm9yKGVycm9yKTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIGVsc2Uge1xyXG5cdCAgICAgICAgICAgIHRocm93IGVycm9yO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICB9O1xyXG5cdCAgICBFcnJvckhhbmRsZXIucHJvdG90eXBlLmNvbnN0cnVjdEVycm9yID0gZnVuY3Rpb24gKG1zZywgY29sdW1uKSB7XHJcblx0ICAgICAgICB2YXIgZXJyb3IgPSBuZXcgRXJyb3IobXNnKTtcclxuXHQgICAgICAgIHRyeSB7XHJcblx0ICAgICAgICAgICAgdGhyb3cgZXJyb3I7XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICBjYXRjaCAoYmFzZSkge1xyXG5cdCAgICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXHJcblx0ICAgICAgICAgICAgaWYgKE9iamVjdC5jcmVhdGUgJiYgT2JqZWN0LmRlZmluZVByb3BlcnR5KSB7XHJcblx0ICAgICAgICAgICAgICAgIGVycm9yID0gT2JqZWN0LmNyZWF0ZShiYXNlKTtcclxuXHQgICAgICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGVycm9yLCAnY29sdW1uJywgeyB2YWx1ZTogY29sdW1uIH0pO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXHJcblx0ICAgICAgICByZXR1cm4gZXJyb3I7XHJcblx0ICAgIH07XHJcblx0ICAgIEVycm9ySGFuZGxlci5wcm90b3R5cGUuY3JlYXRlRXJyb3IgPSBmdW5jdGlvbiAoaW5kZXgsIGxpbmUsIGNvbCwgZGVzY3JpcHRpb24pIHtcclxuXHQgICAgICAgIHZhciBtc2cgPSAnTGluZSAnICsgbGluZSArICc6ICcgKyBkZXNjcmlwdGlvbjtcclxuXHQgICAgICAgIHZhciBlcnJvciA9IHRoaXMuY29uc3RydWN0RXJyb3IobXNnLCBjb2wpO1xyXG5cdCAgICAgICAgZXJyb3IuaW5kZXggPSBpbmRleDtcclxuXHQgICAgICAgIGVycm9yLmxpbmVOdW1iZXIgPSBsaW5lO1xyXG5cdCAgICAgICAgZXJyb3IuZGVzY3JpcHRpb24gPSBkZXNjcmlwdGlvbjtcclxuXHQgICAgICAgIHJldHVybiBlcnJvcjtcclxuXHQgICAgfTtcclxuXHQgICAgRXJyb3JIYW5kbGVyLnByb3RvdHlwZS50aHJvd0Vycm9yID0gZnVuY3Rpb24gKGluZGV4LCBsaW5lLCBjb2wsIGRlc2NyaXB0aW9uKSB7XHJcblx0ICAgICAgICB0aHJvdyB0aGlzLmNyZWF0ZUVycm9yKGluZGV4LCBsaW5lLCBjb2wsIGRlc2NyaXB0aW9uKTtcclxuXHQgICAgfTtcclxuXHQgICAgRXJyb3JIYW5kbGVyLnByb3RvdHlwZS50b2xlcmF0ZUVycm9yID0gZnVuY3Rpb24gKGluZGV4LCBsaW5lLCBjb2wsIGRlc2NyaXB0aW9uKSB7XHJcblx0ICAgICAgICB2YXIgZXJyb3IgPSB0aGlzLmNyZWF0ZUVycm9yKGluZGV4LCBsaW5lLCBjb2wsIGRlc2NyaXB0aW9uKTtcclxuXHQgICAgICAgIGlmICh0aGlzLnRvbGVyYW50KSB7XHJcblx0ICAgICAgICAgICAgdGhpcy5yZWNvcmRFcnJvcihlcnJvcik7XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICBlbHNlIHtcclxuXHQgICAgICAgICAgICB0aHJvdyBlcnJvcjtcclxuXHQgICAgICAgIH1cclxuXHQgICAgfTtcclxuXHQgICAgcmV0dXJuIEVycm9ySGFuZGxlcjtcclxuXHR9KCkpO1xyXG5cdGV4cG9ydHMuRXJyb3JIYW5kbGVyID0gRXJyb3JIYW5kbGVyO1xyXG5cblxuLyoqKi8gfSxcbi8qIDExICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxuXHRcInVzZSBzdHJpY3RcIjtcclxuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcblx0Ly8gRXJyb3IgbWVzc2FnZXMgc2hvdWxkIGJlIGlkZW50aWNhbCB0byBWOC5cclxuXHRleHBvcnRzLk1lc3NhZ2VzID0ge1xyXG5cdCAgICBCYWRHZXR0ZXJBcml0eTogJ0dldHRlciBtdXN0IG5vdCBoYXZlIGFueSBmb3JtYWwgcGFyYW1ldGVycycsXHJcblx0ICAgIEJhZFNldHRlckFyaXR5OiAnU2V0dGVyIG11c3QgaGF2ZSBleGFjdGx5IG9uZSBmb3JtYWwgcGFyYW1ldGVyJyxcclxuXHQgICAgQmFkU2V0dGVyUmVzdFBhcmFtZXRlcjogJ1NldHRlciBmdW5jdGlvbiBhcmd1bWVudCBtdXN0IG5vdCBiZSBhIHJlc3QgcGFyYW1ldGVyJyxcclxuXHQgICAgQ29uc3RydWN0b3JJc0FzeW5jOiAnQ2xhc3MgY29uc3RydWN0b3IgbWF5IG5vdCBiZSBhbiBhc3luYyBtZXRob2QnLFxyXG5cdCAgICBDb25zdHJ1Y3RvclNwZWNpYWxNZXRob2Q6ICdDbGFzcyBjb25zdHJ1Y3RvciBtYXkgbm90IGJlIGFuIGFjY2Vzc29yJyxcclxuXHQgICAgRGVjbGFyYXRpb25NaXNzaW5nSW5pdGlhbGl6ZXI6ICdNaXNzaW5nIGluaXRpYWxpemVyIGluICUwIGRlY2xhcmF0aW9uJyxcclxuXHQgICAgRGVmYXVsdFJlc3RQYXJhbWV0ZXI6ICdVbmV4cGVjdGVkIHRva2VuID0nLFxyXG5cdCAgICBEdXBsaWNhdGVCaW5kaW5nOiAnRHVwbGljYXRlIGJpbmRpbmcgJTAnLFxyXG5cdCAgICBEdXBsaWNhdGVDb25zdHJ1Y3RvcjogJ0EgY2xhc3MgbWF5IG9ubHkgaGF2ZSBvbmUgY29uc3RydWN0b3InLFxyXG5cdCAgICBEdXBsaWNhdGVQcm90b1Byb3BlcnR5OiAnRHVwbGljYXRlIF9fcHJvdG9fXyBmaWVsZHMgYXJlIG5vdCBhbGxvd2VkIGluIG9iamVjdCBsaXRlcmFscycsXHJcblx0ICAgIEZvckluT2ZMb29wSW5pdGlhbGl6ZXI6ICclMCBsb29wIHZhcmlhYmxlIGRlY2xhcmF0aW9uIG1heSBub3QgaGF2ZSBhbiBpbml0aWFsaXplcicsXHJcblx0ICAgIEdlbmVyYXRvckluTGVnYWN5Q29udGV4dDogJ0dlbmVyYXRvciBkZWNsYXJhdGlvbnMgYXJlIG5vdCBhbGxvd2VkIGluIGxlZ2FjeSBjb250ZXh0cycsXHJcblx0ICAgIElsbGVnYWxCcmVhazogJ0lsbGVnYWwgYnJlYWsgc3RhdGVtZW50JyxcclxuXHQgICAgSWxsZWdhbENvbnRpbnVlOiAnSWxsZWdhbCBjb250aW51ZSBzdGF0ZW1lbnQnLFxyXG5cdCAgICBJbGxlZ2FsRXhwb3J0RGVjbGFyYXRpb246ICdVbmV4cGVjdGVkIHRva2VuJyxcclxuXHQgICAgSWxsZWdhbEltcG9ydERlY2xhcmF0aW9uOiAnVW5leHBlY3RlZCB0b2tlbicsXHJcblx0ICAgIElsbGVnYWxMYW5ndWFnZU1vZGVEaXJlY3RpdmU6ICdJbGxlZ2FsIFxcJ3VzZSBzdHJpY3RcXCcgZGlyZWN0aXZlIGluIGZ1bmN0aW9uIHdpdGggbm9uLXNpbXBsZSBwYXJhbWV0ZXIgbGlzdCcsXHJcblx0ICAgIElsbGVnYWxSZXR1cm46ICdJbGxlZ2FsIHJldHVybiBzdGF0ZW1lbnQnLFxyXG5cdCAgICBJbnZhbGlkRXNjYXBlZFJlc2VydmVkV29yZDogJ0tleXdvcmQgbXVzdCBub3QgY29udGFpbiBlc2NhcGVkIGNoYXJhY3RlcnMnLFxyXG5cdCAgICBJbnZhbGlkSGV4RXNjYXBlU2VxdWVuY2U6ICdJbnZhbGlkIGhleGFkZWNpbWFsIGVzY2FwZSBzZXF1ZW5jZScsXHJcblx0ICAgIEludmFsaWRMSFNJbkFzc2lnbm1lbnQ6ICdJbnZhbGlkIGxlZnQtaGFuZCBzaWRlIGluIGFzc2lnbm1lbnQnLFxyXG5cdCAgICBJbnZhbGlkTEhTSW5Gb3JJbjogJ0ludmFsaWQgbGVmdC1oYW5kIHNpZGUgaW4gZm9yLWluJyxcclxuXHQgICAgSW52YWxpZExIU0luRm9yTG9vcDogJ0ludmFsaWQgbGVmdC1oYW5kIHNpZGUgaW4gZm9yLWxvb3AnLFxyXG5cdCAgICBJbnZhbGlkTW9kdWxlU3BlY2lmaWVyOiAnVW5leHBlY3RlZCB0b2tlbicsXHJcblx0ICAgIEludmFsaWRSZWdFeHA6ICdJbnZhbGlkIHJlZ3VsYXIgZXhwcmVzc2lvbicsXHJcblx0ICAgIExldEluTGV4aWNhbEJpbmRpbmc6ICdsZXQgaXMgZGlzYWxsb3dlZCBhcyBhIGxleGljYWxseSBib3VuZCBuYW1lJyxcclxuXHQgICAgTWlzc2luZ0Zyb21DbGF1c2U6ICdVbmV4cGVjdGVkIHRva2VuJyxcclxuXHQgICAgTXVsdGlwbGVEZWZhdWx0c0luU3dpdGNoOiAnTW9yZSB0aGFuIG9uZSBkZWZhdWx0IGNsYXVzZSBpbiBzd2l0Y2ggc3RhdGVtZW50JyxcclxuXHQgICAgTmV3bGluZUFmdGVyVGhyb3c6ICdJbGxlZ2FsIG5ld2xpbmUgYWZ0ZXIgdGhyb3cnLFxyXG5cdCAgICBOb0FzQWZ0ZXJJbXBvcnROYW1lc3BhY2U6ICdVbmV4cGVjdGVkIHRva2VuJyxcclxuXHQgICAgTm9DYXRjaE9yRmluYWxseTogJ01pc3NpbmcgY2F0Y2ggb3IgZmluYWxseSBhZnRlciB0cnknLFxyXG5cdCAgICBQYXJhbWV0ZXJBZnRlclJlc3RQYXJhbWV0ZXI6ICdSZXN0IHBhcmFtZXRlciBtdXN0IGJlIGxhc3QgZm9ybWFsIHBhcmFtZXRlcicsXHJcblx0ICAgIFJlZGVjbGFyYXRpb246ICclMCBcXCclMVxcJyBoYXMgYWxyZWFkeSBiZWVuIGRlY2xhcmVkJyxcclxuXHQgICAgU3RhdGljUHJvdG90eXBlOiAnQ2xhc3NlcyBtYXkgbm90IGhhdmUgc3RhdGljIHByb3BlcnR5IG5hbWVkIHByb3RvdHlwZScsXHJcblx0ICAgIFN0cmljdENhdGNoVmFyaWFibGU6ICdDYXRjaCB2YXJpYWJsZSBtYXkgbm90IGJlIGV2YWwgb3IgYXJndW1lbnRzIGluIHN0cmljdCBtb2RlJyxcclxuXHQgICAgU3RyaWN0RGVsZXRlOiAnRGVsZXRlIG9mIGFuIHVucXVhbGlmaWVkIGlkZW50aWZpZXIgaW4gc3RyaWN0IG1vZGUuJyxcclxuXHQgICAgU3RyaWN0RnVuY3Rpb246ICdJbiBzdHJpY3QgbW9kZSBjb2RlLCBmdW5jdGlvbnMgY2FuIG9ubHkgYmUgZGVjbGFyZWQgYXQgdG9wIGxldmVsIG9yIGluc2lkZSBhIGJsb2NrJyxcclxuXHQgICAgU3RyaWN0RnVuY3Rpb25OYW1lOiAnRnVuY3Rpb24gbmFtZSBtYXkgbm90IGJlIGV2YWwgb3IgYXJndW1lbnRzIGluIHN0cmljdCBtb2RlJyxcclxuXHQgICAgU3RyaWN0TEhTQXNzaWdubWVudDogJ0Fzc2lnbm1lbnQgdG8gZXZhbCBvciBhcmd1bWVudHMgaXMgbm90IGFsbG93ZWQgaW4gc3RyaWN0IG1vZGUnLFxyXG5cdCAgICBTdHJpY3RMSFNQb3N0Zml4OiAnUG9zdGZpeCBpbmNyZW1lbnQvZGVjcmVtZW50IG1heSBub3QgaGF2ZSBldmFsIG9yIGFyZ3VtZW50cyBvcGVyYW5kIGluIHN0cmljdCBtb2RlJyxcclxuXHQgICAgU3RyaWN0TEhTUHJlZml4OiAnUHJlZml4IGluY3JlbWVudC9kZWNyZW1lbnQgbWF5IG5vdCBoYXZlIGV2YWwgb3IgYXJndW1lbnRzIG9wZXJhbmQgaW4gc3RyaWN0IG1vZGUnLFxyXG5cdCAgICBTdHJpY3RNb2RlV2l0aDogJ1N0cmljdCBtb2RlIGNvZGUgbWF5IG5vdCBpbmNsdWRlIGEgd2l0aCBzdGF0ZW1lbnQnLFxyXG5cdCAgICBTdHJpY3RPY3RhbExpdGVyYWw6ICdPY3RhbCBsaXRlcmFscyBhcmUgbm90IGFsbG93ZWQgaW4gc3RyaWN0IG1vZGUuJyxcclxuXHQgICAgU3RyaWN0UGFyYW1EdXBlOiAnU3RyaWN0IG1vZGUgZnVuY3Rpb24gbWF5IG5vdCBoYXZlIGR1cGxpY2F0ZSBwYXJhbWV0ZXIgbmFtZXMnLFxyXG5cdCAgICBTdHJpY3RQYXJhbU5hbWU6ICdQYXJhbWV0ZXIgbmFtZSBldmFsIG9yIGFyZ3VtZW50cyBpcyBub3QgYWxsb3dlZCBpbiBzdHJpY3QgbW9kZScsXHJcblx0ICAgIFN0cmljdFJlc2VydmVkV29yZDogJ1VzZSBvZiBmdXR1cmUgcmVzZXJ2ZWQgd29yZCBpbiBzdHJpY3QgbW9kZScsXHJcblx0ICAgIFN0cmljdFZhck5hbWU6ICdWYXJpYWJsZSBuYW1lIG1heSBub3QgYmUgZXZhbCBvciBhcmd1bWVudHMgaW4gc3RyaWN0IG1vZGUnLFxyXG5cdCAgICBUZW1wbGF0ZU9jdGFsTGl0ZXJhbDogJ09jdGFsIGxpdGVyYWxzIGFyZSBub3QgYWxsb3dlZCBpbiB0ZW1wbGF0ZSBzdHJpbmdzLicsXHJcblx0ICAgIFVuZXhwZWN0ZWRFT1M6ICdVbmV4cGVjdGVkIGVuZCBvZiBpbnB1dCcsXHJcblx0ICAgIFVuZXhwZWN0ZWRJZGVudGlmaWVyOiAnVW5leHBlY3RlZCBpZGVudGlmaWVyJyxcclxuXHQgICAgVW5leHBlY3RlZE51bWJlcjogJ1VuZXhwZWN0ZWQgbnVtYmVyJyxcclxuXHQgICAgVW5leHBlY3RlZFJlc2VydmVkOiAnVW5leHBlY3RlZCByZXNlcnZlZCB3b3JkJyxcclxuXHQgICAgVW5leHBlY3RlZFN0cmluZzogJ1VuZXhwZWN0ZWQgc3RyaW5nJyxcclxuXHQgICAgVW5leHBlY3RlZFRlbXBsYXRlOiAnVW5leHBlY3RlZCBxdWFzaSAlMCcsXHJcblx0ICAgIFVuZXhwZWN0ZWRUb2tlbjogJ1VuZXhwZWN0ZWQgdG9rZW4gJTAnLFxyXG5cdCAgICBVbmV4cGVjdGVkVG9rZW5JbGxlZ2FsOiAnVW5leHBlY3RlZCB0b2tlbiBJTExFR0FMJyxcclxuXHQgICAgVW5rbm93bkxhYmVsOiAnVW5kZWZpbmVkIGxhYmVsIFxcJyUwXFwnJyxcclxuXHQgICAgVW50ZXJtaW5hdGVkUmVnRXhwOiAnSW52YWxpZCByZWd1bGFyIGV4cHJlc3Npb246IG1pc3NpbmcgLydcclxuXHR9O1xyXG5cblxuLyoqKi8gfSxcbi8qIDEyICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXHRcInVzZSBzdHJpY3RcIjtcclxuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcblx0dmFyIGFzc2VydF8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg5KTtcclxuXHR2YXIgY2hhcmFjdGVyXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQpO1xyXG5cdHZhciBtZXNzYWdlc18xID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMSk7XHJcblx0ZnVuY3Rpb24gaGV4VmFsdWUoY2gpIHtcclxuXHQgICAgcmV0dXJuICcwMTIzNDU2Nzg5YWJjZGVmJy5pbmRleE9mKGNoLnRvTG93ZXJDYXNlKCkpO1xyXG5cdH1cclxuXHRmdW5jdGlvbiBvY3RhbFZhbHVlKGNoKSB7XHJcblx0ICAgIHJldHVybiAnMDEyMzQ1NjcnLmluZGV4T2YoY2gpO1xyXG5cdH1cclxuXHR2YXIgU2Nhbm5lciA9IChmdW5jdGlvbiAoKSB7XHJcblx0ICAgIGZ1bmN0aW9uIFNjYW5uZXIoY29kZSwgaGFuZGxlcikge1xyXG5cdCAgICAgICAgdGhpcy5zb3VyY2UgPSBjb2RlO1xyXG5cdCAgICAgICAgdGhpcy5lcnJvckhhbmRsZXIgPSBoYW5kbGVyO1xyXG5cdCAgICAgICAgdGhpcy50cmFja0NvbW1lbnQgPSBmYWxzZTtcclxuXHQgICAgICAgIHRoaXMubGVuZ3RoID0gY29kZS5sZW5ndGg7XHJcblx0ICAgICAgICB0aGlzLmluZGV4ID0gMDtcclxuXHQgICAgICAgIHRoaXMubGluZU51bWJlciA9IChjb2RlLmxlbmd0aCA+IDApID8gMSA6IDA7XHJcblx0ICAgICAgICB0aGlzLmxpbmVTdGFydCA9IDA7XHJcblx0ICAgICAgICB0aGlzLmN1cmx5U3RhY2sgPSBbXTtcclxuXHQgICAgfVxyXG5cdCAgICBTY2FubmVyLnByb3RvdHlwZS5zYXZlU3RhdGUgPSBmdW5jdGlvbiAoKSB7XHJcblx0ICAgICAgICByZXR1cm4ge1xyXG5cdCAgICAgICAgICAgIGluZGV4OiB0aGlzLmluZGV4LFxyXG5cdCAgICAgICAgICAgIGxpbmVOdW1iZXI6IHRoaXMubGluZU51bWJlcixcclxuXHQgICAgICAgICAgICBsaW5lU3RhcnQ6IHRoaXMubGluZVN0YXJ0XHJcblx0ICAgICAgICB9O1xyXG5cdCAgICB9O1xyXG5cdCAgICBTY2FubmVyLnByb3RvdHlwZS5yZXN0b3JlU3RhdGUgPSBmdW5jdGlvbiAoc3RhdGUpIHtcclxuXHQgICAgICAgIHRoaXMuaW5kZXggPSBzdGF0ZS5pbmRleDtcclxuXHQgICAgICAgIHRoaXMubGluZU51bWJlciA9IHN0YXRlLmxpbmVOdW1iZXI7XHJcblx0ICAgICAgICB0aGlzLmxpbmVTdGFydCA9IHN0YXRlLmxpbmVTdGFydDtcclxuXHQgICAgfTtcclxuXHQgICAgU2Nhbm5lci5wcm90b3R5cGUuZW9mID0gZnVuY3Rpb24gKCkge1xyXG5cdCAgICAgICAgcmV0dXJuIHRoaXMuaW5kZXggPj0gdGhpcy5sZW5ndGg7XHJcblx0ICAgIH07XHJcblx0ICAgIFNjYW5uZXIucHJvdG90eXBlLnRocm93VW5leHBlY3RlZFRva2VuID0gZnVuY3Rpb24gKG1lc3NhZ2UpIHtcclxuXHQgICAgICAgIGlmIChtZXNzYWdlID09PSB2b2lkIDApIHsgbWVzc2FnZSA9IG1lc3NhZ2VzXzEuTWVzc2FnZXMuVW5leHBlY3RlZFRva2VuSWxsZWdhbDsgfVxyXG5cdCAgICAgICAgcmV0dXJuIHRoaXMuZXJyb3JIYW5kbGVyLnRocm93RXJyb3IodGhpcy5pbmRleCwgdGhpcy5saW5lTnVtYmVyLCB0aGlzLmluZGV4IC0gdGhpcy5saW5lU3RhcnQgKyAxLCBtZXNzYWdlKTtcclxuXHQgICAgfTtcclxuXHQgICAgU2Nhbm5lci5wcm90b3R5cGUudG9sZXJhdGVVbmV4cGVjdGVkVG9rZW4gPSBmdW5jdGlvbiAobWVzc2FnZSkge1xyXG5cdCAgICAgICAgaWYgKG1lc3NhZ2UgPT09IHZvaWQgMCkgeyBtZXNzYWdlID0gbWVzc2FnZXNfMS5NZXNzYWdlcy5VbmV4cGVjdGVkVG9rZW5JbGxlZ2FsOyB9XHJcblx0ICAgICAgICB0aGlzLmVycm9ySGFuZGxlci50b2xlcmF0ZUVycm9yKHRoaXMuaW5kZXgsIHRoaXMubGluZU51bWJlciwgdGhpcy5pbmRleCAtIHRoaXMubGluZVN0YXJ0ICsgMSwgbWVzc2FnZSk7XHJcblx0ICAgIH07XHJcblx0ICAgIC8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLWNvbW1lbnRzXHJcblx0ICAgIFNjYW5uZXIucHJvdG90eXBlLnNraXBTaW5nbGVMaW5lQ29tbWVudCA9IGZ1bmN0aW9uIChvZmZzZXQpIHtcclxuXHQgICAgICAgIHZhciBjb21tZW50cyA9IFtdO1xyXG5cdCAgICAgICAgdmFyIHN0YXJ0LCBsb2M7XHJcblx0ICAgICAgICBpZiAodGhpcy50cmFja0NvbW1lbnQpIHtcclxuXHQgICAgICAgICAgICBjb21tZW50cyA9IFtdO1xyXG5cdCAgICAgICAgICAgIHN0YXJ0ID0gdGhpcy5pbmRleCAtIG9mZnNldDtcclxuXHQgICAgICAgICAgICBsb2MgPSB7XHJcblx0ICAgICAgICAgICAgICAgIHN0YXJ0OiB7XHJcblx0ICAgICAgICAgICAgICAgICAgICBsaW5lOiB0aGlzLmxpbmVOdW1iZXIsXHJcblx0ICAgICAgICAgICAgICAgICAgICBjb2x1bW46IHRoaXMuaW5kZXggLSB0aGlzLmxpbmVTdGFydCAtIG9mZnNldFxyXG5cdCAgICAgICAgICAgICAgICB9LFxyXG5cdCAgICAgICAgICAgICAgICBlbmQ6IHt9XHJcblx0ICAgICAgICAgICAgfTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIHdoaWxlICghdGhpcy5lb2YoKSkge1xyXG5cdCAgICAgICAgICAgIHZhciBjaCA9IHRoaXMuc291cmNlLmNoYXJDb2RlQXQodGhpcy5pbmRleCk7XHJcblx0ICAgICAgICAgICAgKyt0aGlzLmluZGV4O1xyXG5cdCAgICAgICAgICAgIGlmIChjaGFyYWN0ZXJfMS5DaGFyYWN0ZXIuaXNMaW5lVGVybWluYXRvcihjaCkpIHtcclxuXHQgICAgICAgICAgICAgICAgaWYgKHRoaXMudHJhY2tDb21tZW50KSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICBsb2MuZW5kID0ge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGxpbmU6IHRoaXMubGluZU51bWJlcixcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBjb2x1bW46IHRoaXMuaW5kZXggLSB0aGlzLmxpbmVTdGFydCAtIDFcclxuXHQgICAgICAgICAgICAgICAgICAgIH07XHJcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgZW50cnkgPSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgbXVsdGlMaW5lOiBmYWxzZSxcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBzbGljZTogW3N0YXJ0ICsgb2Zmc2V0LCB0aGlzLmluZGV4IC0gMV0sXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcmFuZ2U6IFtzdGFydCwgdGhpcy5pbmRleCAtIDFdLFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGxvYzogbG9jXHJcblx0ICAgICAgICAgICAgICAgICAgICB9O1xyXG5cdCAgICAgICAgICAgICAgICAgICAgY29tbWVudHMucHVzaChlbnRyeSk7XHJcblx0ICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgaWYgKGNoID09PSAxMyAmJiB0aGlzLnNvdXJjZS5jaGFyQ29kZUF0KHRoaXMuaW5kZXgpID09PSAxMCkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgKyt0aGlzLmluZGV4O1xyXG5cdCAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgICsrdGhpcy5saW5lTnVtYmVyO1xyXG5cdCAgICAgICAgICAgICAgICB0aGlzLmxpbmVTdGFydCA9IHRoaXMuaW5kZXg7XHJcblx0ICAgICAgICAgICAgICAgIHJldHVybiBjb21tZW50cztcclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICBpZiAodGhpcy50cmFja0NvbW1lbnQpIHtcclxuXHQgICAgICAgICAgICBsb2MuZW5kID0ge1xyXG5cdCAgICAgICAgICAgICAgICBsaW5lOiB0aGlzLmxpbmVOdW1iZXIsXHJcblx0ICAgICAgICAgICAgICAgIGNvbHVtbjogdGhpcy5pbmRleCAtIHRoaXMubGluZVN0YXJ0XHJcblx0ICAgICAgICAgICAgfTtcclxuXHQgICAgICAgICAgICB2YXIgZW50cnkgPSB7XHJcblx0ICAgICAgICAgICAgICAgIG11bHRpTGluZTogZmFsc2UsXHJcblx0ICAgICAgICAgICAgICAgIHNsaWNlOiBbc3RhcnQgKyBvZmZzZXQsIHRoaXMuaW5kZXhdLFxyXG5cdCAgICAgICAgICAgICAgICByYW5nZTogW3N0YXJ0LCB0aGlzLmluZGV4XSxcclxuXHQgICAgICAgICAgICAgICAgbG9jOiBsb2NcclxuXHQgICAgICAgICAgICB9O1xyXG5cdCAgICAgICAgICAgIGNvbW1lbnRzLnB1c2goZW50cnkpO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgcmV0dXJuIGNvbW1lbnRzO1xyXG5cdCAgICB9O1xyXG5cdCAgICBTY2FubmVyLnByb3RvdHlwZS5za2lwTXVsdGlMaW5lQ29tbWVudCA9IGZ1bmN0aW9uICgpIHtcclxuXHQgICAgICAgIHZhciBjb21tZW50cyA9IFtdO1xyXG5cdCAgICAgICAgdmFyIHN0YXJ0LCBsb2M7XHJcblx0ICAgICAgICBpZiAodGhpcy50cmFja0NvbW1lbnQpIHtcclxuXHQgICAgICAgICAgICBjb21tZW50cyA9IFtdO1xyXG5cdCAgICAgICAgICAgIHN0YXJ0ID0gdGhpcy5pbmRleCAtIDI7XHJcblx0ICAgICAgICAgICAgbG9jID0ge1xyXG5cdCAgICAgICAgICAgICAgICBzdGFydDoge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgbGluZTogdGhpcy5saW5lTnVtYmVyLFxyXG5cdCAgICAgICAgICAgICAgICAgICAgY29sdW1uOiB0aGlzLmluZGV4IC0gdGhpcy5saW5lU3RhcnQgLSAyXHJcblx0ICAgICAgICAgICAgICAgIH0sXHJcblx0ICAgICAgICAgICAgICAgIGVuZDoge31cclxuXHQgICAgICAgICAgICB9O1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgd2hpbGUgKCF0aGlzLmVvZigpKSB7XHJcblx0ICAgICAgICAgICAgdmFyIGNoID0gdGhpcy5zb3VyY2UuY2hhckNvZGVBdCh0aGlzLmluZGV4KTtcclxuXHQgICAgICAgICAgICBpZiAoY2hhcmFjdGVyXzEuQ2hhcmFjdGVyLmlzTGluZVRlcm1pbmF0b3IoY2gpKSB7XHJcblx0ICAgICAgICAgICAgICAgIGlmIChjaCA9PT0gMHgwRCAmJiB0aGlzLnNvdXJjZS5jaGFyQ29kZUF0KHRoaXMuaW5kZXggKyAxKSA9PT0gMHgwQSkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgKyt0aGlzLmluZGV4O1xyXG5cdCAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgICsrdGhpcy5saW5lTnVtYmVyO1xyXG5cdCAgICAgICAgICAgICAgICArK3RoaXMuaW5kZXg7XHJcblx0ICAgICAgICAgICAgICAgIHRoaXMubGluZVN0YXJ0ID0gdGhpcy5pbmRleDtcclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgZWxzZSBpZiAoY2ggPT09IDB4MkEpIHtcclxuXHQgICAgICAgICAgICAgICAgLy8gQmxvY2sgY29tbWVudCBlbmRzIHdpdGggJyovJy5cclxuXHQgICAgICAgICAgICAgICAgaWYgKHRoaXMuc291cmNlLmNoYXJDb2RlQXQodGhpcy5pbmRleCArIDEpID09PSAweDJGKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICB0aGlzLmluZGV4ICs9IDI7XHJcblx0ICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy50cmFja0NvbW1lbnQpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBsb2MuZW5kID0ge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBsaW5lOiB0aGlzLmxpbmVOdW1iZXIsXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbHVtbjogdGhpcy5pbmRleCAtIHRoaXMubGluZVN0YXJ0XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZW50cnkgPSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIG11bHRpTGluZTogdHJ1ZSxcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2xpY2U6IFtzdGFydCArIDIsIHRoaXMuaW5kZXggLSAyXSxcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmFuZ2U6IFtzdGFydCwgdGhpcy5pbmRleF0sXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxvYzogbG9jXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBjb21tZW50cy5wdXNoKGVudHJ5KTtcclxuXHQgICAgICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgICAgIHJldHVybiBjb21tZW50cztcclxuXHQgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICArK3RoaXMuaW5kZXg7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgIGVsc2Uge1xyXG5cdCAgICAgICAgICAgICAgICArK3RoaXMuaW5kZXg7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgLy8gUmFuIG9mZiB0aGUgZW5kIG9mIHRoZSBmaWxlIC0gdGhlIHdob2xlIHRoaW5nIGlzIGEgY29tbWVudFxyXG5cdCAgICAgICAgaWYgKHRoaXMudHJhY2tDb21tZW50KSB7XHJcblx0ICAgICAgICAgICAgbG9jLmVuZCA9IHtcclxuXHQgICAgICAgICAgICAgICAgbGluZTogdGhpcy5saW5lTnVtYmVyLFxyXG5cdCAgICAgICAgICAgICAgICBjb2x1bW46IHRoaXMuaW5kZXggLSB0aGlzLmxpbmVTdGFydFxyXG5cdCAgICAgICAgICAgIH07XHJcblx0ICAgICAgICAgICAgdmFyIGVudHJ5ID0ge1xyXG5cdCAgICAgICAgICAgICAgICBtdWx0aUxpbmU6IHRydWUsXHJcblx0ICAgICAgICAgICAgICAgIHNsaWNlOiBbc3RhcnQgKyAyLCB0aGlzLmluZGV4XSxcclxuXHQgICAgICAgICAgICAgICAgcmFuZ2U6IFtzdGFydCwgdGhpcy5pbmRleF0sXHJcblx0ICAgICAgICAgICAgICAgIGxvYzogbG9jXHJcblx0ICAgICAgICAgICAgfTtcclxuXHQgICAgICAgICAgICBjb21tZW50cy5wdXNoKGVudHJ5KTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIHRoaXMudG9sZXJhdGVVbmV4cGVjdGVkVG9rZW4oKTtcclxuXHQgICAgICAgIHJldHVybiBjb21tZW50cztcclxuXHQgICAgfTtcclxuXHQgICAgU2Nhbm5lci5wcm90b3R5cGUuc2NhbkNvbW1lbnRzID0gZnVuY3Rpb24gKCkge1xyXG5cdCAgICAgICAgdmFyIGNvbW1lbnRzO1xyXG5cdCAgICAgICAgaWYgKHRoaXMudHJhY2tDb21tZW50KSB7XHJcblx0ICAgICAgICAgICAgY29tbWVudHMgPSBbXTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIHZhciBzdGFydCA9ICh0aGlzLmluZGV4ID09PSAwKTtcclxuXHQgICAgICAgIHdoaWxlICghdGhpcy5lb2YoKSkge1xyXG5cdCAgICAgICAgICAgIHZhciBjaCA9IHRoaXMuc291cmNlLmNoYXJDb2RlQXQodGhpcy5pbmRleCk7XHJcblx0ICAgICAgICAgICAgaWYgKGNoYXJhY3Rlcl8xLkNoYXJhY3Rlci5pc1doaXRlU3BhY2UoY2gpKSB7XHJcblx0ICAgICAgICAgICAgICAgICsrdGhpcy5pbmRleDtcclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgZWxzZSBpZiAoY2hhcmFjdGVyXzEuQ2hhcmFjdGVyLmlzTGluZVRlcm1pbmF0b3IoY2gpKSB7XHJcblx0ICAgICAgICAgICAgICAgICsrdGhpcy5pbmRleDtcclxuXHQgICAgICAgICAgICAgICAgaWYgKGNoID09PSAweDBEICYmIHRoaXMuc291cmNlLmNoYXJDb2RlQXQodGhpcy5pbmRleCkgPT09IDB4MEEpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICsrdGhpcy5pbmRleDtcclxuXHQgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICArK3RoaXMubGluZU51bWJlcjtcclxuXHQgICAgICAgICAgICAgICAgdGhpcy5saW5lU3RhcnQgPSB0aGlzLmluZGV4O1xyXG5cdCAgICAgICAgICAgICAgICBzdGFydCA9IHRydWU7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgIGVsc2UgaWYgKGNoID09PSAweDJGKSB7XHJcblx0ICAgICAgICAgICAgICAgIGNoID0gdGhpcy5zb3VyY2UuY2hhckNvZGVBdCh0aGlzLmluZGV4ICsgMSk7XHJcblx0ICAgICAgICAgICAgICAgIGlmIChjaCA9PT0gMHgyRikge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgdGhpcy5pbmRleCArPSAyO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIGNvbW1lbnQgPSB0aGlzLnNraXBTaW5nbGVMaW5lQ29tbWVudCgyKTtcclxuXHQgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLnRyYWNrQ29tbWVudCkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGNvbW1lbnRzID0gY29tbWVudHMuY29uY2F0KGNvbW1lbnQpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICAgICAgc3RhcnQgPSB0cnVlO1xyXG5cdCAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgIGVsc2UgaWYgKGNoID09PSAweDJBKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICB0aGlzLmluZGV4ICs9IDI7XHJcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgY29tbWVudCA9IHRoaXMuc2tpcE11bHRpTGluZUNvbW1lbnQoKTtcclxuXHQgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLnRyYWNrQ29tbWVudCkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGNvbW1lbnRzID0gY29tbWVudHMuY29uY2F0KGNvbW1lbnQpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgIGVsc2Uge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcblx0ICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgZWxzZSBpZiAoc3RhcnQgJiYgY2ggPT09IDB4MkQpIHtcclxuXHQgICAgICAgICAgICAgICAgLy8gVSswMDNFIGlzICc+J1xyXG5cdCAgICAgICAgICAgICAgICBpZiAoKHRoaXMuc291cmNlLmNoYXJDb2RlQXQodGhpcy5pbmRleCArIDEpID09PSAweDJEKSAmJiAodGhpcy5zb3VyY2UuY2hhckNvZGVBdCh0aGlzLmluZGV4ICsgMikgPT09IDB4M0UpKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAvLyAnLS0+JyBpcyBhIHNpbmdsZS1saW5lIGNvbW1lbnRcclxuXHQgICAgICAgICAgICAgICAgICAgIHRoaXMuaW5kZXggKz0gMztcclxuXHQgICAgICAgICAgICAgICAgICAgIHZhciBjb21tZW50ID0gdGhpcy5za2lwU2luZ2xlTGluZUNvbW1lbnQoMyk7XHJcblx0ICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy50cmFja0NvbW1lbnQpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBjb21tZW50cyA9IGNvbW1lbnRzLmNvbmNhdChjb21tZW50KTtcclxuXHQgICAgICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICBlbHNlIHtcclxuXHQgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cdCAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgIGVsc2UgaWYgKGNoID09PSAweDNDKSB7XHJcblx0ICAgICAgICAgICAgICAgIGlmICh0aGlzLnNvdXJjZS5zbGljZSh0aGlzLmluZGV4ICsgMSwgdGhpcy5pbmRleCArIDQpID09PSAnIS0tJykge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgdGhpcy5pbmRleCArPSA0OyAvLyBgPCEtLWBcclxuXHQgICAgICAgICAgICAgICAgICAgIHZhciBjb21tZW50ID0gdGhpcy5za2lwU2luZ2xlTGluZUNvbW1lbnQoNCk7XHJcblx0ICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy50cmFja0NvbW1lbnQpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBjb21tZW50cyA9IGNvbW1lbnRzLmNvbmNhdChjb21tZW50KTtcclxuXHQgICAgICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICBlbHNlIHtcclxuXHQgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cdCAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgIGVsc2Uge1xyXG5cdCAgICAgICAgICAgICAgICBicmVhaztcclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICByZXR1cm4gY29tbWVudHM7XHJcblx0ICAgIH07XHJcblx0ICAgIC8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLWZ1dHVyZS1yZXNlcnZlZC13b3Jkc1xyXG5cdCAgICBTY2FubmVyLnByb3RvdHlwZS5pc0Z1dHVyZVJlc2VydmVkV29yZCA9IGZ1bmN0aW9uIChpZCkge1xyXG5cdCAgICAgICAgc3dpdGNoIChpZCkge1xyXG5cdCAgICAgICAgICAgIGNhc2UgJ2VudW0nOlxyXG5cdCAgICAgICAgICAgIGNhc2UgJ2V4cG9ydCc6XHJcblx0ICAgICAgICAgICAgY2FzZSAnaW1wb3J0JzpcclxuXHQgICAgICAgICAgICBjYXNlICdzdXBlcic6XHJcblx0ICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG5cdCAgICAgICAgICAgIGRlZmF1bHQ6XHJcblx0ICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgfTtcclxuXHQgICAgU2Nhbm5lci5wcm90b3R5cGUuaXNTdHJpY3RNb2RlUmVzZXJ2ZWRXb3JkID0gZnVuY3Rpb24gKGlkKSB7XHJcblx0ICAgICAgICBzd2l0Y2ggKGlkKSB7XHJcblx0ICAgICAgICAgICAgY2FzZSAnaW1wbGVtZW50cyc6XHJcblx0ICAgICAgICAgICAgY2FzZSAnaW50ZXJmYWNlJzpcclxuXHQgICAgICAgICAgICBjYXNlICdwYWNrYWdlJzpcclxuXHQgICAgICAgICAgICBjYXNlICdwcml2YXRlJzpcclxuXHQgICAgICAgICAgICBjYXNlICdwcm90ZWN0ZWQnOlxyXG5cdCAgICAgICAgICAgIGNhc2UgJ3B1YmxpYyc6XHJcblx0ICAgICAgICAgICAgY2FzZSAnc3RhdGljJzpcclxuXHQgICAgICAgICAgICBjYXNlICd5aWVsZCc6XHJcblx0ICAgICAgICAgICAgY2FzZSAnbGV0JzpcclxuXHQgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcblx0ICAgICAgICAgICAgZGVmYXVsdDpcclxuXHQgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICB9O1xyXG5cdCAgICBTY2FubmVyLnByb3RvdHlwZS5pc1Jlc3RyaWN0ZWRXb3JkID0gZnVuY3Rpb24gKGlkKSB7XHJcblx0ICAgICAgICByZXR1cm4gaWQgPT09ICdldmFsJyB8fCBpZCA9PT0gJ2FyZ3VtZW50cyc7XHJcblx0ICAgIH07XHJcblx0ICAgIC8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLWtleXdvcmRzXHJcblx0ICAgIFNjYW5uZXIucHJvdG90eXBlLmlzS2V5d29yZCA9IGZ1bmN0aW9uIChpZCkge1xyXG5cdCAgICAgICAgc3dpdGNoIChpZC5sZW5ndGgpIHtcclxuXHQgICAgICAgICAgICBjYXNlIDI6XHJcblx0ICAgICAgICAgICAgICAgIHJldHVybiAoaWQgPT09ICdpZicpIHx8IChpZCA9PT0gJ2luJykgfHwgKGlkID09PSAnZG8nKTtcclxuXHQgICAgICAgICAgICBjYXNlIDM6XHJcblx0ICAgICAgICAgICAgICAgIHJldHVybiAoaWQgPT09ICd2YXInKSB8fCAoaWQgPT09ICdmb3InKSB8fCAoaWQgPT09ICduZXcnKSB8fFxyXG5cdCAgICAgICAgICAgICAgICAgICAgKGlkID09PSAndHJ5JykgfHwgKGlkID09PSAnbGV0Jyk7XHJcblx0ICAgICAgICAgICAgY2FzZSA0OlxyXG5cdCAgICAgICAgICAgICAgICByZXR1cm4gKGlkID09PSAndGhpcycpIHx8IChpZCA9PT0gJ2Vsc2UnKSB8fCAoaWQgPT09ICdjYXNlJykgfHxcclxuXHQgICAgICAgICAgICAgICAgICAgIChpZCA9PT0gJ3ZvaWQnKSB8fCAoaWQgPT09ICd3aXRoJykgfHwgKGlkID09PSAnZW51bScpO1xyXG5cdCAgICAgICAgICAgIGNhc2UgNTpcclxuXHQgICAgICAgICAgICAgICAgcmV0dXJuIChpZCA9PT0gJ3doaWxlJykgfHwgKGlkID09PSAnYnJlYWsnKSB8fCAoaWQgPT09ICdjYXRjaCcpIHx8XHJcblx0ICAgICAgICAgICAgICAgICAgICAoaWQgPT09ICd0aHJvdycpIHx8IChpZCA9PT0gJ2NvbnN0JykgfHwgKGlkID09PSAneWllbGQnKSB8fFxyXG5cdCAgICAgICAgICAgICAgICAgICAgKGlkID09PSAnY2xhc3MnKSB8fCAoaWQgPT09ICdzdXBlcicpO1xyXG5cdCAgICAgICAgICAgIGNhc2UgNjpcclxuXHQgICAgICAgICAgICAgICAgcmV0dXJuIChpZCA9PT0gJ3JldHVybicpIHx8IChpZCA9PT0gJ3R5cGVvZicpIHx8IChpZCA9PT0gJ2RlbGV0ZScpIHx8XHJcblx0ICAgICAgICAgICAgICAgICAgICAoaWQgPT09ICdzd2l0Y2gnKSB8fCAoaWQgPT09ICdleHBvcnQnKSB8fCAoaWQgPT09ICdpbXBvcnQnKTtcclxuXHQgICAgICAgICAgICBjYXNlIDc6XHJcblx0ICAgICAgICAgICAgICAgIHJldHVybiAoaWQgPT09ICdkZWZhdWx0JykgfHwgKGlkID09PSAnZmluYWxseScpIHx8IChpZCA9PT0gJ2V4dGVuZHMnKTtcclxuXHQgICAgICAgICAgICBjYXNlIDg6XHJcblx0ICAgICAgICAgICAgICAgIHJldHVybiAoaWQgPT09ICdmdW5jdGlvbicpIHx8IChpZCA9PT0gJ2NvbnRpbnVlJykgfHwgKGlkID09PSAnZGVidWdnZXInKTtcclxuXHQgICAgICAgICAgICBjYXNlIDEwOlxyXG5cdCAgICAgICAgICAgICAgICByZXR1cm4gKGlkID09PSAnaW5zdGFuY2VvZicpO1xyXG5cdCAgICAgICAgICAgIGRlZmF1bHQ6XHJcblx0ICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgfTtcclxuXHQgICAgU2Nhbm5lci5wcm90b3R5cGUuY29kZVBvaW50QXQgPSBmdW5jdGlvbiAoaSkge1xyXG5cdCAgICAgICAgdmFyIGNwID0gdGhpcy5zb3VyY2UuY2hhckNvZGVBdChpKTtcclxuXHQgICAgICAgIGlmIChjcCA+PSAweEQ4MDAgJiYgY3AgPD0gMHhEQkZGKSB7XHJcblx0ICAgICAgICAgICAgdmFyIHNlY29uZCA9IHRoaXMuc291cmNlLmNoYXJDb2RlQXQoaSArIDEpO1xyXG5cdCAgICAgICAgICAgIGlmIChzZWNvbmQgPj0gMHhEQzAwICYmIHNlY29uZCA8PSAweERGRkYpIHtcclxuXHQgICAgICAgICAgICAgICAgdmFyIGZpcnN0ID0gY3A7XHJcblx0ICAgICAgICAgICAgICAgIGNwID0gKGZpcnN0IC0gMHhEODAwKSAqIDB4NDAwICsgc2Vjb25kIC0gMHhEQzAwICsgMHgxMDAwMDtcclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICByZXR1cm4gY3A7XHJcblx0ICAgIH07XHJcblx0ICAgIFNjYW5uZXIucHJvdG90eXBlLnNjYW5IZXhFc2NhcGUgPSBmdW5jdGlvbiAocHJlZml4KSB7XHJcblx0ICAgICAgICB2YXIgbGVuID0gKHByZWZpeCA9PT0gJ3UnKSA/IDQgOiAyO1xyXG5cdCAgICAgICAgdmFyIGNvZGUgPSAwO1xyXG5cdCAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47ICsraSkge1xyXG5cdCAgICAgICAgICAgIGlmICghdGhpcy5lb2YoKSAmJiBjaGFyYWN0ZXJfMS5DaGFyYWN0ZXIuaXNIZXhEaWdpdCh0aGlzLnNvdXJjZS5jaGFyQ29kZUF0KHRoaXMuaW5kZXgpKSkge1xyXG5cdCAgICAgICAgICAgICAgICBjb2RlID0gY29kZSAqIDE2ICsgaGV4VmFsdWUodGhpcy5zb3VyY2VbdGhpcy5pbmRleCsrXSk7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgIGVsc2Uge1xyXG5cdCAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZShjb2RlKTtcclxuXHQgICAgfTtcclxuXHQgICAgU2Nhbm5lci5wcm90b3R5cGUuc2NhblVuaWNvZGVDb2RlUG9pbnRFc2NhcGUgPSBmdW5jdGlvbiAoKSB7XHJcblx0ICAgICAgICB2YXIgY2ggPSB0aGlzLnNvdXJjZVt0aGlzLmluZGV4XTtcclxuXHQgICAgICAgIHZhciBjb2RlID0gMDtcclxuXHQgICAgICAgIC8vIEF0IGxlYXN0LCBvbmUgaGV4IGRpZ2l0IGlzIHJlcXVpcmVkLlxyXG5cdCAgICAgICAgaWYgKGNoID09PSAnfScpIHtcclxuXHQgICAgICAgICAgICB0aGlzLnRocm93VW5leHBlY3RlZFRva2VuKCk7XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICB3aGlsZSAoIXRoaXMuZW9mKCkpIHtcclxuXHQgICAgICAgICAgICBjaCA9IHRoaXMuc291cmNlW3RoaXMuaW5kZXgrK107XHJcblx0ICAgICAgICAgICAgaWYgKCFjaGFyYWN0ZXJfMS5DaGFyYWN0ZXIuaXNIZXhEaWdpdChjaC5jaGFyQ29kZUF0KDApKSkge1xyXG5cdCAgICAgICAgICAgICAgICBicmVhaztcclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgY29kZSA9IGNvZGUgKiAxNiArIGhleFZhbHVlKGNoKTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIGlmIChjb2RlID4gMHgxMEZGRkYgfHwgY2ggIT09ICd9Jykge1xyXG5cdCAgICAgICAgICAgIHRoaXMudGhyb3dVbmV4cGVjdGVkVG9rZW4oKTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIHJldHVybiBjaGFyYWN0ZXJfMS5DaGFyYWN0ZXIuZnJvbUNvZGVQb2ludChjb2RlKTtcclxuXHQgICAgfTtcclxuXHQgICAgU2Nhbm5lci5wcm90b3R5cGUuZ2V0SWRlbnRpZmllciA9IGZ1bmN0aW9uICgpIHtcclxuXHQgICAgICAgIHZhciBzdGFydCA9IHRoaXMuaW5kZXgrKztcclxuXHQgICAgICAgIHdoaWxlICghdGhpcy5lb2YoKSkge1xyXG5cdCAgICAgICAgICAgIHZhciBjaCA9IHRoaXMuc291cmNlLmNoYXJDb2RlQXQodGhpcy5pbmRleCk7XHJcblx0ICAgICAgICAgICAgaWYgKGNoID09PSAweDVDKSB7XHJcblx0ICAgICAgICAgICAgICAgIC8vIEJsYWNrc2xhc2ggKFUrMDA1QykgbWFya3MgVW5pY29kZSBlc2NhcGUgc2VxdWVuY2UuXHJcblx0ICAgICAgICAgICAgICAgIHRoaXMuaW5kZXggPSBzdGFydDtcclxuXHQgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0Q29tcGxleElkZW50aWZpZXIoKTtcclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgZWxzZSBpZiAoY2ggPj0gMHhEODAwICYmIGNoIDwgMHhERkZGKSB7XHJcblx0ICAgICAgICAgICAgICAgIC8vIE5lZWQgdG8gaGFuZGxlIHN1cnJvZ2F0ZSBwYWlycy5cclxuXHQgICAgICAgICAgICAgICAgdGhpcy5pbmRleCA9IHN0YXJ0O1xyXG5cdCAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5nZXRDb21wbGV4SWRlbnRpZmllcigpO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICBpZiAoY2hhcmFjdGVyXzEuQ2hhcmFjdGVyLmlzSWRlbnRpZmllclBhcnQoY2gpKSB7XHJcblx0ICAgICAgICAgICAgICAgICsrdGhpcy5pbmRleDtcclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgZWxzZSB7XHJcblx0ICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIHJldHVybiB0aGlzLnNvdXJjZS5zbGljZShzdGFydCwgdGhpcy5pbmRleCk7XHJcblx0ICAgIH07XHJcblx0ICAgIFNjYW5uZXIucHJvdG90eXBlLmdldENvbXBsZXhJZGVudGlmaWVyID0gZnVuY3Rpb24gKCkge1xyXG5cdCAgICAgICAgdmFyIGNwID0gdGhpcy5jb2RlUG9pbnRBdCh0aGlzLmluZGV4KTtcclxuXHQgICAgICAgIHZhciBpZCA9IGNoYXJhY3Rlcl8xLkNoYXJhY3Rlci5mcm9tQ29kZVBvaW50KGNwKTtcclxuXHQgICAgICAgIHRoaXMuaW5kZXggKz0gaWQubGVuZ3RoO1xyXG5cdCAgICAgICAgLy8gJ1xcdScgKFUrMDA1QywgVSswMDc1KSBkZW5vdGVzIGFuIGVzY2FwZWQgY2hhcmFjdGVyLlxyXG5cdCAgICAgICAgdmFyIGNoO1xyXG5cdCAgICAgICAgaWYgKGNwID09PSAweDVDKSB7XHJcblx0ICAgICAgICAgICAgaWYgKHRoaXMuc291cmNlLmNoYXJDb2RlQXQodGhpcy5pbmRleCkgIT09IDB4NzUpIHtcclxuXHQgICAgICAgICAgICAgICAgdGhpcy50aHJvd1VuZXhwZWN0ZWRUb2tlbigpO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICArK3RoaXMuaW5kZXg7XHJcblx0ICAgICAgICAgICAgaWYgKHRoaXMuc291cmNlW3RoaXMuaW5kZXhdID09PSAneycpIHtcclxuXHQgICAgICAgICAgICAgICAgKyt0aGlzLmluZGV4O1xyXG5cdCAgICAgICAgICAgICAgICBjaCA9IHRoaXMuc2NhblVuaWNvZGVDb2RlUG9pbnRFc2NhcGUoKTtcclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgZWxzZSB7XHJcblx0ICAgICAgICAgICAgICAgIGNoID0gdGhpcy5zY2FuSGV4RXNjYXBlKCd1Jyk7XHJcblx0ICAgICAgICAgICAgICAgIGlmIChjaCA9PT0gbnVsbCB8fCBjaCA9PT0gJ1xcXFwnIHx8ICFjaGFyYWN0ZXJfMS5DaGFyYWN0ZXIuaXNJZGVudGlmaWVyU3RhcnQoY2guY2hhckNvZGVBdCgwKSkpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgIHRoaXMudGhyb3dVbmV4cGVjdGVkVG9rZW4oKTtcclxuXHQgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICBpZCA9IGNoO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgd2hpbGUgKCF0aGlzLmVvZigpKSB7XHJcblx0ICAgICAgICAgICAgY3AgPSB0aGlzLmNvZGVQb2ludEF0KHRoaXMuaW5kZXgpO1xyXG5cdCAgICAgICAgICAgIGlmICghY2hhcmFjdGVyXzEuQ2hhcmFjdGVyLmlzSWRlbnRpZmllclBhcnQoY3ApKSB7XHJcblx0ICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICBjaCA9IGNoYXJhY3Rlcl8xLkNoYXJhY3Rlci5mcm9tQ29kZVBvaW50KGNwKTtcclxuXHQgICAgICAgICAgICBpZCArPSBjaDtcclxuXHQgICAgICAgICAgICB0aGlzLmluZGV4ICs9IGNoLmxlbmd0aDtcclxuXHQgICAgICAgICAgICAvLyAnXFx1JyAoVSswMDVDLCBVKzAwNzUpIGRlbm90ZXMgYW4gZXNjYXBlZCBjaGFyYWN0ZXIuXHJcblx0ICAgICAgICAgICAgaWYgKGNwID09PSAweDVDKSB7XHJcblx0ICAgICAgICAgICAgICAgIGlkID0gaWQuc3Vic3RyKDAsIGlkLmxlbmd0aCAtIDEpO1xyXG5cdCAgICAgICAgICAgICAgICBpZiAodGhpcy5zb3VyY2UuY2hhckNvZGVBdCh0aGlzLmluZGV4KSAhPT0gMHg3NSkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgdGhpcy50aHJvd1VuZXhwZWN0ZWRUb2tlbigpO1xyXG5cdCAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgICsrdGhpcy5pbmRleDtcclxuXHQgICAgICAgICAgICAgICAgaWYgKHRoaXMuc291cmNlW3RoaXMuaW5kZXhdID09PSAneycpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICsrdGhpcy5pbmRleDtcclxuXHQgICAgICAgICAgICAgICAgICAgIGNoID0gdGhpcy5zY2FuVW5pY29kZUNvZGVQb2ludEVzY2FwZSgpO1xyXG5cdCAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgIGVsc2Uge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgY2ggPSB0aGlzLnNjYW5IZXhFc2NhcGUoJ3UnKTtcclxuXHQgICAgICAgICAgICAgICAgICAgIGlmIChjaCA9PT0gbnVsbCB8fCBjaCA9PT0gJ1xcXFwnIHx8ICFjaGFyYWN0ZXJfMS5DaGFyYWN0ZXIuaXNJZGVudGlmaWVyUGFydChjaC5jaGFyQ29kZUF0KDApKSkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMudGhyb3dVbmV4cGVjdGVkVG9rZW4oKTtcclxuXHQgICAgICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICBpZCArPSBjaDtcclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICByZXR1cm4gaWQ7XHJcblx0ICAgIH07XHJcblx0ICAgIFNjYW5uZXIucHJvdG90eXBlLm9jdGFsVG9EZWNpbWFsID0gZnVuY3Rpb24gKGNoKSB7XHJcblx0ICAgICAgICAvLyBcXDAgaXMgbm90IG9jdGFsIGVzY2FwZSBzZXF1ZW5jZVxyXG5cdCAgICAgICAgdmFyIG9jdGFsID0gKGNoICE9PSAnMCcpO1xyXG5cdCAgICAgICAgdmFyIGNvZGUgPSBvY3RhbFZhbHVlKGNoKTtcclxuXHQgICAgICAgIGlmICghdGhpcy5lb2YoKSAmJiBjaGFyYWN0ZXJfMS5DaGFyYWN0ZXIuaXNPY3RhbERpZ2l0KHRoaXMuc291cmNlLmNoYXJDb2RlQXQodGhpcy5pbmRleCkpKSB7XHJcblx0ICAgICAgICAgICAgb2N0YWwgPSB0cnVlO1xyXG5cdCAgICAgICAgICAgIGNvZGUgPSBjb2RlICogOCArIG9jdGFsVmFsdWUodGhpcy5zb3VyY2VbdGhpcy5pbmRleCsrXSk7XHJcblx0ICAgICAgICAgICAgLy8gMyBkaWdpdHMgYXJlIG9ubHkgYWxsb3dlZCB3aGVuIHN0cmluZyBzdGFydHNcclxuXHQgICAgICAgICAgICAvLyB3aXRoIDAsIDEsIDIsIDNcclxuXHQgICAgICAgICAgICBpZiAoJzAxMjMnLmluZGV4T2YoY2gpID49IDAgJiYgIXRoaXMuZW9mKCkgJiYgY2hhcmFjdGVyXzEuQ2hhcmFjdGVyLmlzT2N0YWxEaWdpdCh0aGlzLnNvdXJjZS5jaGFyQ29kZUF0KHRoaXMuaW5kZXgpKSkge1xyXG5cdCAgICAgICAgICAgICAgICBjb2RlID0gY29kZSAqIDggKyBvY3RhbFZhbHVlKHRoaXMuc291cmNlW3RoaXMuaW5kZXgrK10pO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIHJldHVybiB7XHJcblx0ICAgICAgICAgICAgY29kZTogY29kZSxcclxuXHQgICAgICAgICAgICBvY3RhbDogb2N0YWxcclxuXHQgICAgICAgIH07XHJcblx0ICAgIH07XHJcblx0ICAgIC8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLW5hbWVzLWFuZC1rZXl3b3Jkc1xyXG5cdCAgICBTY2FubmVyLnByb3RvdHlwZS5zY2FuSWRlbnRpZmllciA9IGZ1bmN0aW9uICgpIHtcclxuXHQgICAgICAgIHZhciB0eXBlO1xyXG5cdCAgICAgICAgdmFyIHN0YXJ0ID0gdGhpcy5pbmRleDtcclxuXHQgICAgICAgIC8vIEJhY2tzbGFzaCAoVSswMDVDKSBzdGFydHMgYW4gZXNjYXBlZCBjaGFyYWN0ZXIuXHJcblx0ICAgICAgICB2YXIgaWQgPSAodGhpcy5zb3VyY2UuY2hhckNvZGVBdChzdGFydCkgPT09IDB4NUMpID8gdGhpcy5nZXRDb21wbGV4SWRlbnRpZmllcigpIDogdGhpcy5nZXRJZGVudGlmaWVyKCk7XHJcblx0ICAgICAgICAvLyBUaGVyZSBpcyBubyBrZXl3b3JkIG9yIGxpdGVyYWwgd2l0aCBvbmx5IG9uZSBjaGFyYWN0ZXIuXHJcblx0ICAgICAgICAvLyBUaHVzLCBpdCBtdXN0IGJlIGFuIGlkZW50aWZpZXIuXHJcblx0ICAgICAgICBpZiAoaWQubGVuZ3RoID09PSAxKSB7XHJcblx0ICAgICAgICAgICAgdHlwZSA9IDMgLyogSWRlbnRpZmllciAqLztcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIGVsc2UgaWYgKHRoaXMuaXNLZXl3b3JkKGlkKSkge1xyXG5cdCAgICAgICAgICAgIHR5cGUgPSA0IC8qIEtleXdvcmQgKi87XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICBlbHNlIGlmIChpZCA9PT0gJ251bGwnKSB7XHJcblx0ICAgICAgICAgICAgdHlwZSA9IDUgLyogTnVsbExpdGVyYWwgKi87XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICBlbHNlIGlmIChpZCA9PT0gJ3RydWUnIHx8IGlkID09PSAnZmFsc2UnKSB7XHJcblx0ICAgICAgICAgICAgdHlwZSA9IDEgLyogQm9vbGVhbkxpdGVyYWwgKi87XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICBlbHNlIHtcclxuXHQgICAgICAgICAgICB0eXBlID0gMyAvKiBJZGVudGlmaWVyICovO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgaWYgKHR5cGUgIT09IDMgLyogSWRlbnRpZmllciAqLyAmJiAoc3RhcnQgKyBpZC5sZW5ndGggIT09IHRoaXMuaW5kZXgpKSB7XHJcblx0ICAgICAgICAgICAgdmFyIHJlc3RvcmUgPSB0aGlzLmluZGV4O1xyXG5cdCAgICAgICAgICAgIHRoaXMuaW5kZXggPSBzdGFydDtcclxuXHQgICAgICAgICAgICB0aGlzLnRvbGVyYXRlVW5leHBlY3RlZFRva2VuKG1lc3NhZ2VzXzEuTWVzc2FnZXMuSW52YWxpZEVzY2FwZWRSZXNlcnZlZFdvcmQpO1xyXG5cdCAgICAgICAgICAgIHRoaXMuaW5kZXggPSByZXN0b3JlO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgcmV0dXJuIHtcclxuXHQgICAgICAgICAgICB0eXBlOiB0eXBlLFxyXG5cdCAgICAgICAgICAgIHZhbHVlOiBpZCxcclxuXHQgICAgICAgICAgICBsaW5lTnVtYmVyOiB0aGlzLmxpbmVOdW1iZXIsXHJcblx0ICAgICAgICAgICAgbGluZVN0YXJ0OiB0aGlzLmxpbmVTdGFydCxcclxuXHQgICAgICAgICAgICBzdGFydDogc3RhcnQsXHJcblx0ICAgICAgICAgICAgZW5kOiB0aGlzLmluZGV4XHJcblx0ICAgICAgICB9O1xyXG5cdCAgICB9O1xyXG5cdCAgICAvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1wdW5jdHVhdG9yc1xyXG5cdCAgICBTY2FubmVyLnByb3RvdHlwZS5zY2FuUHVuY3R1YXRvciA9IGZ1bmN0aW9uICgpIHtcclxuXHQgICAgICAgIHZhciBzdGFydCA9IHRoaXMuaW5kZXg7XHJcblx0ICAgICAgICAvLyBDaGVjayBmb3IgbW9zdCBjb21tb24gc2luZ2xlLWNoYXJhY3RlciBwdW5jdHVhdG9ycy5cclxuXHQgICAgICAgIHZhciBzdHIgPSB0aGlzLnNvdXJjZVt0aGlzLmluZGV4XTtcclxuXHQgICAgICAgIHN3aXRjaCAoc3RyKSB7XHJcblx0ICAgICAgICAgICAgY2FzZSAnKCc6XHJcblx0ICAgICAgICAgICAgY2FzZSAneyc6XHJcblx0ICAgICAgICAgICAgICAgIGlmIChzdHIgPT09ICd7Jykge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgdGhpcy5jdXJseVN0YWNrLnB1c2goJ3snKTtcclxuXHQgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICArK3RoaXMuaW5kZXg7XHJcblx0ICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cdCAgICAgICAgICAgIGNhc2UgJy4nOlxyXG5cdCAgICAgICAgICAgICAgICArK3RoaXMuaW5kZXg7XHJcblx0ICAgICAgICAgICAgICAgIGlmICh0aGlzLnNvdXJjZVt0aGlzLmluZGV4XSA9PT0gJy4nICYmIHRoaXMuc291cmNlW3RoaXMuaW5kZXggKyAxXSA9PT0gJy4nKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAvLyBTcHJlYWQgb3BlcmF0b3I6IC4uLlxyXG5cdCAgICAgICAgICAgICAgICAgICAgdGhpcy5pbmRleCArPSAyO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgc3RyID0gJy4uLic7XHJcblx0ICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgYnJlYWs7XHJcblx0ICAgICAgICAgICAgY2FzZSAnfSc6XHJcblx0ICAgICAgICAgICAgICAgICsrdGhpcy5pbmRleDtcclxuXHQgICAgICAgICAgICAgICAgdGhpcy5jdXJseVN0YWNrLnBvcCgpO1xyXG5cdCAgICAgICAgICAgICAgICBicmVhaztcclxuXHQgICAgICAgICAgICBjYXNlICcpJzpcclxuXHQgICAgICAgICAgICBjYXNlICc7JzpcclxuXHQgICAgICAgICAgICBjYXNlICcsJzpcclxuXHQgICAgICAgICAgICBjYXNlICdbJzpcclxuXHQgICAgICAgICAgICBjYXNlICddJzpcclxuXHQgICAgICAgICAgICBjYXNlICc6JzpcclxuXHQgICAgICAgICAgICBjYXNlICc/JzpcclxuXHQgICAgICAgICAgICBjYXNlICd+JzpcclxuXHQgICAgICAgICAgICAgICAgKyt0aGlzLmluZGV4O1xyXG5cdCAgICAgICAgICAgICAgICBicmVhaztcclxuXHQgICAgICAgICAgICBkZWZhdWx0OlxyXG5cdCAgICAgICAgICAgICAgICAvLyA0LWNoYXJhY3RlciBwdW5jdHVhdG9yLlxyXG5cdCAgICAgICAgICAgICAgICBzdHIgPSB0aGlzLnNvdXJjZS5zdWJzdHIodGhpcy5pbmRleCwgNCk7XHJcblx0ICAgICAgICAgICAgICAgIGlmIChzdHIgPT09ICc+Pj49Jykge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgdGhpcy5pbmRleCArPSA0O1xyXG5cdCAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgIGVsc2Uge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgLy8gMy1jaGFyYWN0ZXIgcHVuY3R1YXRvcnMuXHJcblx0ICAgICAgICAgICAgICAgICAgICBzdHIgPSBzdHIuc3Vic3RyKDAsIDMpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKHN0ciA9PT0gJz09PScgfHwgc3RyID09PSAnIT09JyB8fCBzdHIgPT09ICc+Pj4nIHx8XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgc3RyID09PSAnPDw9JyB8fCBzdHIgPT09ICc+Pj0nIHx8IHN0ciA9PT0gJyoqPScpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmluZGV4ICs9IDM7XHJcblx0ICAgICAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAvLyAyLWNoYXJhY3RlciBwdW5jdHVhdG9ycy5cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBzdHIgPSBzdHIuc3Vic3RyKDAsIDIpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzdHIgPT09ICcmJicgfHwgc3RyID09PSAnfHwnIHx8IHN0ciA9PT0gJz09JyB8fCBzdHIgPT09ICchPScgfHxcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RyID09PSAnKz0nIHx8IHN0ciA9PT0gJy09JyB8fCBzdHIgPT09ICcqPScgfHwgc3RyID09PSAnLz0nIHx8XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0ciA9PT0gJysrJyB8fCBzdHIgPT09ICctLScgfHwgc3RyID09PSAnPDwnIHx8IHN0ciA9PT0gJz4+JyB8fFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHIgPT09ICcmPScgfHwgc3RyID09PSAnfD0nIHx8IHN0ciA9PT0gJ149JyB8fCBzdHIgPT09ICclPScgfHxcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RyID09PSAnPD0nIHx8IHN0ciA9PT0gJz49JyB8fCBzdHIgPT09ICc9PicgfHwgc3RyID09PSAnKionKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuaW5kZXggKz0gMjtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIDEtY2hhcmFjdGVyIHB1bmN0dWF0b3JzLlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHIgPSB0aGlzLnNvdXJjZVt0aGlzLmluZGV4XTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCc8Pj0hKy0qJSZ8Xi8nLmluZGV4T2Yoc3RyKSA+PSAwKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICArK3RoaXMuaW5kZXg7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIGlmICh0aGlzLmluZGV4ID09PSBzdGFydCkge1xyXG5cdCAgICAgICAgICAgIHRoaXMudGhyb3dVbmV4cGVjdGVkVG9rZW4oKTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIHJldHVybiB7XHJcblx0ICAgICAgICAgICAgdHlwZTogNyAvKiBQdW5jdHVhdG9yICovLFxyXG5cdCAgICAgICAgICAgIHZhbHVlOiBzdHIsXHJcblx0ICAgICAgICAgICAgbGluZU51bWJlcjogdGhpcy5saW5lTnVtYmVyLFxyXG5cdCAgICAgICAgICAgIGxpbmVTdGFydDogdGhpcy5saW5lU3RhcnQsXHJcblx0ICAgICAgICAgICAgc3RhcnQ6IHN0YXJ0LFxyXG5cdCAgICAgICAgICAgIGVuZDogdGhpcy5pbmRleFxyXG5cdCAgICAgICAgfTtcclxuXHQgICAgfTtcclxuXHQgICAgLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtbGl0ZXJhbHMtbnVtZXJpYy1saXRlcmFsc1xyXG5cdCAgICBTY2FubmVyLnByb3RvdHlwZS5zY2FuSGV4TGl0ZXJhbCA9IGZ1bmN0aW9uIChzdGFydCkge1xyXG5cdCAgICAgICAgdmFyIG51bSA9ICcnO1xyXG5cdCAgICAgICAgd2hpbGUgKCF0aGlzLmVvZigpKSB7XHJcblx0ICAgICAgICAgICAgaWYgKCFjaGFyYWN0ZXJfMS5DaGFyYWN0ZXIuaXNIZXhEaWdpdCh0aGlzLnNvdXJjZS5jaGFyQ29kZUF0KHRoaXMuaW5kZXgpKSkge1xyXG5cdCAgICAgICAgICAgICAgICBicmVhaztcclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgbnVtICs9IHRoaXMuc291cmNlW3RoaXMuaW5kZXgrK107XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICBpZiAobnVtLmxlbmd0aCA9PT0gMCkge1xyXG5cdCAgICAgICAgICAgIHRoaXMudGhyb3dVbmV4cGVjdGVkVG9rZW4oKTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIGlmIChjaGFyYWN0ZXJfMS5DaGFyYWN0ZXIuaXNJZGVudGlmaWVyU3RhcnQodGhpcy5zb3VyY2UuY2hhckNvZGVBdCh0aGlzLmluZGV4KSkpIHtcclxuXHQgICAgICAgICAgICB0aGlzLnRocm93VW5leHBlY3RlZFRva2VuKCk7XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICByZXR1cm4ge1xyXG5cdCAgICAgICAgICAgIHR5cGU6IDYgLyogTnVtZXJpY0xpdGVyYWwgKi8sXHJcblx0ICAgICAgICAgICAgdmFsdWU6IHBhcnNlSW50KCcweCcgKyBudW0sIDE2KSxcclxuXHQgICAgICAgICAgICBsaW5lTnVtYmVyOiB0aGlzLmxpbmVOdW1iZXIsXHJcblx0ICAgICAgICAgICAgbGluZVN0YXJ0OiB0aGlzLmxpbmVTdGFydCxcclxuXHQgICAgICAgICAgICBzdGFydDogc3RhcnQsXHJcblx0ICAgICAgICAgICAgZW5kOiB0aGlzLmluZGV4XHJcblx0ICAgICAgICB9O1xyXG5cdCAgICB9O1xyXG5cdCAgICBTY2FubmVyLnByb3RvdHlwZS5zY2FuQmluYXJ5TGl0ZXJhbCA9IGZ1bmN0aW9uIChzdGFydCkge1xyXG5cdCAgICAgICAgdmFyIG51bSA9ICcnO1xyXG5cdCAgICAgICAgdmFyIGNoO1xyXG5cdCAgICAgICAgd2hpbGUgKCF0aGlzLmVvZigpKSB7XHJcblx0ICAgICAgICAgICAgY2ggPSB0aGlzLnNvdXJjZVt0aGlzLmluZGV4XTtcclxuXHQgICAgICAgICAgICBpZiAoY2ggIT09ICcwJyAmJiBjaCAhPT0gJzEnKSB7XHJcblx0ICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICBudW0gKz0gdGhpcy5zb3VyY2VbdGhpcy5pbmRleCsrXTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIGlmIChudW0ubGVuZ3RoID09PSAwKSB7XHJcblx0ICAgICAgICAgICAgLy8gb25seSAwYiBvciAwQlxyXG5cdCAgICAgICAgICAgIHRoaXMudGhyb3dVbmV4cGVjdGVkVG9rZW4oKTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIGlmICghdGhpcy5lb2YoKSkge1xyXG5cdCAgICAgICAgICAgIGNoID0gdGhpcy5zb3VyY2UuY2hhckNvZGVBdCh0aGlzLmluZGV4KTtcclxuXHQgICAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xyXG5cdCAgICAgICAgICAgIGlmIChjaGFyYWN0ZXJfMS5DaGFyYWN0ZXIuaXNJZGVudGlmaWVyU3RhcnQoY2gpIHx8IGNoYXJhY3Rlcl8xLkNoYXJhY3Rlci5pc0RlY2ltYWxEaWdpdChjaCkpIHtcclxuXHQgICAgICAgICAgICAgICAgdGhpcy50aHJvd1VuZXhwZWN0ZWRUb2tlbigpO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIHJldHVybiB7XHJcblx0ICAgICAgICAgICAgdHlwZTogNiAvKiBOdW1lcmljTGl0ZXJhbCAqLyxcclxuXHQgICAgICAgICAgICB2YWx1ZTogcGFyc2VJbnQobnVtLCAyKSxcclxuXHQgICAgICAgICAgICBsaW5lTnVtYmVyOiB0aGlzLmxpbmVOdW1iZXIsXHJcblx0ICAgICAgICAgICAgbGluZVN0YXJ0OiB0aGlzLmxpbmVTdGFydCxcclxuXHQgICAgICAgICAgICBzdGFydDogc3RhcnQsXHJcblx0ICAgICAgICAgICAgZW5kOiB0aGlzLmluZGV4XHJcblx0ICAgICAgICB9O1xyXG5cdCAgICB9O1xyXG5cdCAgICBTY2FubmVyLnByb3RvdHlwZS5zY2FuT2N0YWxMaXRlcmFsID0gZnVuY3Rpb24gKHByZWZpeCwgc3RhcnQpIHtcclxuXHQgICAgICAgIHZhciBudW0gPSAnJztcclxuXHQgICAgICAgIHZhciBvY3RhbCA9IGZhbHNlO1xyXG5cdCAgICAgICAgaWYgKGNoYXJhY3Rlcl8xLkNoYXJhY3Rlci5pc09jdGFsRGlnaXQocHJlZml4LmNoYXJDb2RlQXQoMCkpKSB7XHJcblx0ICAgICAgICAgICAgb2N0YWwgPSB0cnVlO1xyXG5cdCAgICAgICAgICAgIG51bSA9ICcwJyArIHRoaXMuc291cmNlW3RoaXMuaW5kZXgrK107XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICBlbHNlIHtcclxuXHQgICAgICAgICAgICArK3RoaXMuaW5kZXg7XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICB3aGlsZSAoIXRoaXMuZW9mKCkpIHtcclxuXHQgICAgICAgICAgICBpZiAoIWNoYXJhY3Rlcl8xLkNoYXJhY3Rlci5pc09jdGFsRGlnaXQodGhpcy5zb3VyY2UuY2hhckNvZGVBdCh0aGlzLmluZGV4KSkpIHtcclxuXHQgICAgICAgICAgICAgICAgYnJlYWs7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgIG51bSArPSB0aGlzLnNvdXJjZVt0aGlzLmluZGV4KytdO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgaWYgKCFvY3RhbCAmJiBudW0ubGVuZ3RoID09PSAwKSB7XHJcblx0ICAgICAgICAgICAgLy8gb25seSAwbyBvciAwT1xyXG5cdCAgICAgICAgICAgIHRoaXMudGhyb3dVbmV4cGVjdGVkVG9rZW4oKTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIGlmIChjaGFyYWN0ZXJfMS5DaGFyYWN0ZXIuaXNJZGVudGlmaWVyU3RhcnQodGhpcy5zb3VyY2UuY2hhckNvZGVBdCh0aGlzLmluZGV4KSkgfHwgY2hhcmFjdGVyXzEuQ2hhcmFjdGVyLmlzRGVjaW1hbERpZ2l0KHRoaXMuc291cmNlLmNoYXJDb2RlQXQodGhpcy5pbmRleCkpKSB7XHJcblx0ICAgICAgICAgICAgdGhpcy50aHJvd1VuZXhwZWN0ZWRUb2tlbigpO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgcmV0dXJuIHtcclxuXHQgICAgICAgICAgICB0eXBlOiA2IC8qIE51bWVyaWNMaXRlcmFsICovLFxyXG5cdCAgICAgICAgICAgIHZhbHVlOiBwYXJzZUludChudW0sIDgpLFxyXG5cdCAgICAgICAgICAgIG9jdGFsOiBvY3RhbCxcclxuXHQgICAgICAgICAgICBsaW5lTnVtYmVyOiB0aGlzLmxpbmVOdW1iZXIsXHJcblx0ICAgICAgICAgICAgbGluZVN0YXJ0OiB0aGlzLmxpbmVTdGFydCxcclxuXHQgICAgICAgICAgICBzdGFydDogc3RhcnQsXHJcblx0ICAgICAgICAgICAgZW5kOiB0aGlzLmluZGV4XHJcblx0ICAgICAgICB9O1xyXG5cdCAgICB9O1xyXG5cdCAgICBTY2FubmVyLnByb3RvdHlwZS5pc0ltcGxpY2l0T2N0YWxMaXRlcmFsID0gZnVuY3Rpb24gKCkge1xyXG5cdCAgICAgICAgLy8gSW1wbGljaXQgb2N0YWwsIHVubGVzcyB0aGVyZSBpcyBhIG5vbi1vY3RhbCBkaWdpdC5cclxuXHQgICAgICAgIC8vIChBbm5leCBCLjEuMSBvbiBOdW1lcmljIExpdGVyYWxzKVxyXG5cdCAgICAgICAgZm9yICh2YXIgaSA9IHRoaXMuaW5kZXggKyAxOyBpIDwgdGhpcy5sZW5ndGg7ICsraSkge1xyXG5cdCAgICAgICAgICAgIHZhciBjaCA9IHRoaXMuc291cmNlW2ldO1xyXG5cdCAgICAgICAgICAgIGlmIChjaCA9PT0gJzgnIHx8IGNoID09PSAnOScpIHtcclxuXHQgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICBpZiAoIWNoYXJhY3Rlcl8xLkNoYXJhY3Rlci5pc09jdGFsRGlnaXQoY2guY2hhckNvZGVBdCgwKSkpIHtcclxuXHQgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgcmV0dXJuIHRydWU7XHJcblx0ICAgIH07XHJcblx0ICAgIFNjYW5uZXIucHJvdG90eXBlLnNjYW5OdW1lcmljTGl0ZXJhbCA9IGZ1bmN0aW9uICgpIHtcclxuXHQgICAgICAgIHZhciBzdGFydCA9IHRoaXMuaW5kZXg7XHJcblx0ICAgICAgICB2YXIgY2ggPSB0aGlzLnNvdXJjZVtzdGFydF07XHJcblx0ICAgICAgICBhc3NlcnRfMS5hc3NlcnQoY2hhcmFjdGVyXzEuQ2hhcmFjdGVyLmlzRGVjaW1hbERpZ2l0KGNoLmNoYXJDb2RlQXQoMCkpIHx8IChjaCA9PT0gJy4nKSwgJ051bWVyaWMgbGl0ZXJhbCBtdXN0IHN0YXJ0IHdpdGggYSBkZWNpbWFsIGRpZ2l0IG9yIGEgZGVjaW1hbCBwb2ludCcpO1xyXG5cdCAgICAgICAgdmFyIG51bSA9ICcnO1xyXG5cdCAgICAgICAgaWYgKGNoICE9PSAnLicpIHtcclxuXHQgICAgICAgICAgICBudW0gPSB0aGlzLnNvdXJjZVt0aGlzLmluZGV4KytdO1xyXG5cdCAgICAgICAgICAgIGNoID0gdGhpcy5zb3VyY2VbdGhpcy5pbmRleF07XHJcblx0ICAgICAgICAgICAgLy8gSGV4IG51bWJlciBzdGFydHMgd2l0aCAnMHgnLlxyXG5cdCAgICAgICAgICAgIC8vIE9jdGFsIG51bWJlciBzdGFydHMgd2l0aCAnMCcuXHJcblx0ICAgICAgICAgICAgLy8gT2N0YWwgbnVtYmVyIGluIEVTNiBzdGFydHMgd2l0aCAnMG8nLlxyXG5cdCAgICAgICAgICAgIC8vIEJpbmFyeSBudW1iZXIgaW4gRVM2IHN0YXJ0cyB3aXRoICcwYicuXHJcblx0ICAgICAgICAgICAgaWYgKG51bSA9PT0gJzAnKSB7XHJcblx0ICAgICAgICAgICAgICAgIGlmIChjaCA9PT0gJ3gnIHx8IGNoID09PSAnWCcpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICsrdGhpcy5pbmRleDtcclxuXHQgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnNjYW5IZXhMaXRlcmFsKHN0YXJ0KTtcclxuXHQgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICBpZiAoY2ggPT09ICdiJyB8fCBjaCA9PT0gJ0InKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICArK3RoaXMuaW5kZXg7XHJcblx0ICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5zY2FuQmluYXJ5TGl0ZXJhbChzdGFydCk7XHJcblx0ICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgaWYgKGNoID09PSAnbycgfHwgY2ggPT09ICdPJykge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2Nhbk9jdGFsTGl0ZXJhbChjaCwgc3RhcnQpO1xyXG5cdCAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgIGlmIChjaCAmJiBjaGFyYWN0ZXJfMS5DaGFyYWN0ZXIuaXNPY3RhbERpZ2l0KGNoLmNoYXJDb2RlQXQoMCkpKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5pc0ltcGxpY2l0T2N0YWxMaXRlcmFsKCkpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5zY2FuT2N0YWxMaXRlcmFsKGNoLCBzdGFydCk7XHJcblx0ICAgICAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgd2hpbGUgKGNoYXJhY3Rlcl8xLkNoYXJhY3Rlci5pc0RlY2ltYWxEaWdpdCh0aGlzLnNvdXJjZS5jaGFyQ29kZUF0KHRoaXMuaW5kZXgpKSkge1xyXG5cdCAgICAgICAgICAgICAgICBudW0gKz0gdGhpcy5zb3VyY2VbdGhpcy5pbmRleCsrXTtcclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgY2ggPSB0aGlzLnNvdXJjZVt0aGlzLmluZGV4XTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIGlmIChjaCA9PT0gJy4nKSB7XHJcblx0ICAgICAgICAgICAgbnVtICs9IHRoaXMuc291cmNlW3RoaXMuaW5kZXgrK107XHJcblx0ICAgICAgICAgICAgd2hpbGUgKGNoYXJhY3Rlcl8xLkNoYXJhY3Rlci5pc0RlY2ltYWxEaWdpdCh0aGlzLnNvdXJjZS5jaGFyQ29kZUF0KHRoaXMuaW5kZXgpKSkge1xyXG5cdCAgICAgICAgICAgICAgICBudW0gKz0gdGhpcy5zb3VyY2VbdGhpcy5pbmRleCsrXTtcclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgY2ggPSB0aGlzLnNvdXJjZVt0aGlzLmluZGV4XTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIGlmIChjaCA9PT0gJ2UnIHx8IGNoID09PSAnRScpIHtcclxuXHQgICAgICAgICAgICBudW0gKz0gdGhpcy5zb3VyY2VbdGhpcy5pbmRleCsrXTtcclxuXHQgICAgICAgICAgICBjaCA9IHRoaXMuc291cmNlW3RoaXMuaW5kZXhdO1xyXG5cdCAgICAgICAgICAgIGlmIChjaCA9PT0gJysnIHx8IGNoID09PSAnLScpIHtcclxuXHQgICAgICAgICAgICAgICAgbnVtICs9IHRoaXMuc291cmNlW3RoaXMuaW5kZXgrK107XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgIGlmIChjaGFyYWN0ZXJfMS5DaGFyYWN0ZXIuaXNEZWNpbWFsRGlnaXQodGhpcy5zb3VyY2UuY2hhckNvZGVBdCh0aGlzLmluZGV4KSkpIHtcclxuXHQgICAgICAgICAgICAgICAgd2hpbGUgKGNoYXJhY3Rlcl8xLkNoYXJhY3Rlci5pc0RlY2ltYWxEaWdpdCh0aGlzLnNvdXJjZS5jaGFyQ29kZUF0KHRoaXMuaW5kZXgpKSkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgbnVtICs9IHRoaXMuc291cmNlW3RoaXMuaW5kZXgrK107XHJcblx0ICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgZWxzZSB7XHJcblx0ICAgICAgICAgICAgICAgIHRoaXMudGhyb3dVbmV4cGVjdGVkVG9rZW4oKTtcclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICBpZiAoY2hhcmFjdGVyXzEuQ2hhcmFjdGVyLmlzSWRlbnRpZmllclN0YXJ0KHRoaXMuc291cmNlLmNoYXJDb2RlQXQodGhpcy5pbmRleCkpKSB7XHJcblx0ICAgICAgICAgICAgdGhpcy50aHJvd1VuZXhwZWN0ZWRUb2tlbigpO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgcmV0dXJuIHtcclxuXHQgICAgICAgICAgICB0eXBlOiA2IC8qIE51bWVyaWNMaXRlcmFsICovLFxyXG5cdCAgICAgICAgICAgIHZhbHVlOiBwYXJzZUZsb2F0KG51bSksXHJcblx0ICAgICAgICAgICAgbGluZU51bWJlcjogdGhpcy5saW5lTnVtYmVyLFxyXG5cdCAgICAgICAgICAgIGxpbmVTdGFydDogdGhpcy5saW5lU3RhcnQsXHJcblx0ICAgICAgICAgICAgc3RhcnQ6IHN0YXJ0LFxyXG5cdCAgICAgICAgICAgIGVuZDogdGhpcy5pbmRleFxyXG5cdCAgICAgICAgfTtcclxuXHQgICAgfTtcclxuXHQgICAgLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtbGl0ZXJhbHMtc3RyaW5nLWxpdGVyYWxzXHJcblx0ICAgIFNjYW5uZXIucHJvdG90eXBlLnNjYW5TdHJpbmdMaXRlcmFsID0gZnVuY3Rpb24gKCkge1xyXG5cdCAgICAgICAgdmFyIHN0YXJ0ID0gdGhpcy5pbmRleDtcclxuXHQgICAgICAgIHZhciBxdW90ZSA9IHRoaXMuc291cmNlW3N0YXJ0XTtcclxuXHQgICAgICAgIGFzc2VydF8xLmFzc2VydCgocXVvdGUgPT09ICdcXCcnIHx8IHF1b3RlID09PSAnXCInKSwgJ1N0cmluZyBsaXRlcmFsIG11c3Qgc3RhcnRzIHdpdGggYSBxdW90ZScpO1xyXG5cdCAgICAgICAgKyt0aGlzLmluZGV4O1xyXG5cdCAgICAgICAgdmFyIG9jdGFsID0gZmFsc2U7XHJcblx0ICAgICAgICB2YXIgc3RyID0gJyc7XHJcblx0ICAgICAgICB3aGlsZSAoIXRoaXMuZW9mKCkpIHtcclxuXHQgICAgICAgICAgICB2YXIgY2ggPSB0aGlzLnNvdXJjZVt0aGlzLmluZGV4KytdO1xyXG5cdCAgICAgICAgICAgIGlmIChjaCA9PT0gcXVvdGUpIHtcclxuXHQgICAgICAgICAgICAgICAgcXVvdGUgPSAnJztcclxuXHQgICAgICAgICAgICAgICAgYnJlYWs7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgIGVsc2UgaWYgKGNoID09PSAnXFxcXCcpIHtcclxuXHQgICAgICAgICAgICAgICAgY2ggPSB0aGlzLnNvdXJjZVt0aGlzLmluZGV4KytdO1xyXG5cdCAgICAgICAgICAgICAgICBpZiAoIWNoIHx8ICFjaGFyYWN0ZXJfMS5DaGFyYWN0ZXIuaXNMaW5lVGVybWluYXRvcihjaC5jaGFyQ29kZUF0KDApKSkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChjaCkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ3UnOlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5zb3VyY2VbdGhpcy5pbmRleF0gPT09ICd7Jykge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKyt0aGlzLmluZGV4O1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RyICs9IHRoaXMuc2NhblVuaWNvZGVDb2RlUG9pbnRFc2NhcGUoKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB1bmVzY2FwZWRfMSA9IHRoaXMuc2NhbkhleEVzY2FwZShjaCk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodW5lc2NhcGVkXzEgPT09IG51bGwpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnRocm93VW5leHBlY3RlZFRva2VuKCk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHIgKz0gdW5lc2NhcGVkXzE7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAneCc6XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB1bmVzY2FwZWQgPSB0aGlzLnNjYW5IZXhFc2NhcGUoY2gpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodW5lc2NhcGVkID09PSBudWxsKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnRocm93VW5leHBlY3RlZFRva2VuKG1lc3NhZ2VzXzEuTWVzc2FnZXMuSW52YWxpZEhleEVzY2FwZVNlcXVlbmNlKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHIgKz0gdW5lc2NhcGVkO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBjYXNlICduJzpcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RyICs9ICdcXG4nO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBjYXNlICdyJzpcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RyICs9ICdcXHInO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBjYXNlICd0JzpcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RyICs9ICdcXHQnO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBjYXNlICdiJzpcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RyICs9ICdcXGInO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBjYXNlICdmJzpcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RyICs9ICdcXGYnO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBjYXNlICd2JzpcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RyICs9ICdcXHgwQic7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJzgnOlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJzknOlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHIgKz0gY2g7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMudG9sZXJhdGVVbmV4cGVjdGVkVG9rZW4oKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNoICYmIGNoYXJhY3Rlcl8xLkNoYXJhY3Rlci5pc09jdGFsRGlnaXQoY2guY2hhckNvZGVBdCgwKSkpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBvY3RUb0RlYyA9IHRoaXMub2N0YWxUb0RlY2ltYWwoY2gpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb2N0YWwgPSBvY3RUb0RlYy5vY3RhbCB8fCBvY3RhbDtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0ciArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKG9jdFRvRGVjLmNvZGUpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RyICs9IGNoO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgIGVsc2Uge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgKyt0aGlzLmxpbmVOdW1iZXI7XHJcblx0ICAgICAgICAgICAgICAgICAgICBpZiAoY2ggPT09ICdcXHInICYmIHRoaXMuc291cmNlW3RoaXMuaW5kZXhdID09PSAnXFxuJykge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICsrdGhpcy5pbmRleDtcclxuXHQgICAgICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgICAgIHRoaXMubGluZVN0YXJ0ID0gdGhpcy5pbmRleDtcclxuXHQgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICBlbHNlIGlmIChjaGFyYWN0ZXJfMS5DaGFyYWN0ZXIuaXNMaW5lVGVybWluYXRvcihjaC5jaGFyQ29kZUF0KDApKSkge1xyXG5cdCAgICAgICAgICAgICAgICBicmVhaztcclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgZWxzZSB7XHJcblx0ICAgICAgICAgICAgICAgIHN0ciArPSBjaDtcclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICBpZiAocXVvdGUgIT09ICcnKSB7XHJcblx0ICAgICAgICAgICAgdGhpcy5pbmRleCA9IHN0YXJ0O1xyXG5cdCAgICAgICAgICAgIHRoaXMudGhyb3dVbmV4cGVjdGVkVG9rZW4oKTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIHJldHVybiB7XHJcblx0ICAgICAgICAgICAgdHlwZTogOCAvKiBTdHJpbmdMaXRlcmFsICovLFxyXG5cdCAgICAgICAgICAgIHZhbHVlOiBzdHIsXHJcblx0ICAgICAgICAgICAgb2N0YWw6IG9jdGFsLFxyXG5cdCAgICAgICAgICAgIGxpbmVOdW1iZXI6IHRoaXMubGluZU51bWJlcixcclxuXHQgICAgICAgICAgICBsaW5lU3RhcnQ6IHRoaXMubGluZVN0YXJ0LFxyXG5cdCAgICAgICAgICAgIHN0YXJ0OiBzdGFydCxcclxuXHQgICAgICAgICAgICBlbmQ6IHRoaXMuaW5kZXhcclxuXHQgICAgICAgIH07XHJcblx0ICAgIH07XHJcblx0ICAgIC8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLXRlbXBsYXRlLWxpdGVyYWwtbGV4aWNhbC1jb21wb25lbnRzXHJcblx0ICAgIFNjYW5uZXIucHJvdG90eXBlLnNjYW5UZW1wbGF0ZSA9IGZ1bmN0aW9uICgpIHtcclxuXHQgICAgICAgIHZhciBjb29rZWQgPSAnJztcclxuXHQgICAgICAgIHZhciB0ZXJtaW5hdGVkID0gZmFsc2U7XHJcblx0ICAgICAgICB2YXIgc3RhcnQgPSB0aGlzLmluZGV4O1xyXG5cdCAgICAgICAgdmFyIGhlYWQgPSAodGhpcy5zb3VyY2Vbc3RhcnRdID09PSAnYCcpO1xyXG5cdCAgICAgICAgdmFyIHRhaWwgPSBmYWxzZTtcclxuXHQgICAgICAgIHZhciByYXdPZmZzZXQgPSAyO1xyXG5cdCAgICAgICAgKyt0aGlzLmluZGV4O1xyXG5cdCAgICAgICAgd2hpbGUgKCF0aGlzLmVvZigpKSB7XHJcblx0ICAgICAgICAgICAgdmFyIGNoID0gdGhpcy5zb3VyY2VbdGhpcy5pbmRleCsrXTtcclxuXHQgICAgICAgICAgICBpZiAoY2ggPT09ICdgJykge1xyXG5cdCAgICAgICAgICAgICAgICByYXdPZmZzZXQgPSAxO1xyXG5cdCAgICAgICAgICAgICAgICB0YWlsID0gdHJ1ZTtcclxuXHQgICAgICAgICAgICAgICAgdGVybWluYXRlZCA9IHRydWU7XHJcblx0ICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICBlbHNlIGlmIChjaCA9PT0gJyQnKSB7XHJcblx0ICAgICAgICAgICAgICAgIGlmICh0aGlzLnNvdXJjZVt0aGlzLmluZGV4XSA9PT0gJ3snKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICB0aGlzLmN1cmx5U3RhY2sucHVzaCgnJHsnKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICsrdGhpcy5pbmRleDtcclxuXHQgICAgICAgICAgICAgICAgICAgIHRlcm1pbmF0ZWQgPSB0cnVlO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcblx0ICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgY29va2VkICs9IGNoO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICBlbHNlIGlmIChjaCA9PT0gJ1xcXFwnKSB7XHJcblx0ICAgICAgICAgICAgICAgIGNoID0gdGhpcy5zb3VyY2VbdGhpcy5pbmRleCsrXTtcclxuXHQgICAgICAgICAgICAgICAgaWYgKCFjaGFyYWN0ZXJfMS5DaGFyYWN0ZXIuaXNMaW5lVGVybWluYXRvcihjaC5jaGFyQ29kZUF0KDApKSkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChjaCkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ24nOlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb29rZWQgKz0gJ1xcbic7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ3InOlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb29rZWQgKz0gJ1xccic7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ3QnOlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb29rZWQgKz0gJ1xcdCc7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ3UnOlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5zb3VyY2VbdGhpcy5pbmRleF0gPT09ICd7Jykge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKyt0aGlzLmluZGV4O1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29va2VkICs9IHRoaXMuc2NhblVuaWNvZGVDb2RlUG9pbnRFc2NhcGUoKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciByZXN0b3JlID0gdGhpcy5pbmRleDtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB1bmVzY2FwZWRfMiA9IHRoaXMuc2NhbkhleEVzY2FwZShjaCk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodW5lc2NhcGVkXzIgIT09IG51bGwpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb29rZWQgKz0gdW5lc2NhcGVkXzI7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmluZGV4ID0gcmVzdG9yZTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb29rZWQgKz0gY2g7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAneCc6XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB1bmVzY2FwZWQgPSB0aGlzLnNjYW5IZXhFc2NhcGUoY2gpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodW5lc2NhcGVkID09PSBudWxsKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnRocm93VW5leHBlY3RlZFRva2VuKG1lc3NhZ2VzXzEuTWVzc2FnZXMuSW52YWxpZEhleEVzY2FwZVNlcXVlbmNlKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb29rZWQgKz0gdW5lc2NhcGVkO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBjYXNlICdiJzpcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29va2VkICs9ICdcXGInO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBjYXNlICdmJzpcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29va2VkICs9ICdcXGYnO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBjYXNlICd2JzpcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29va2VkICs9ICdcXHYnO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoY2ggPT09ICcwJykge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNoYXJhY3Rlcl8xLkNoYXJhY3Rlci5pc0RlY2ltYWxEaWdpdCh0aGlzLnNvdXJjZS5jaGFyQ29kZUF0KHRoaXMuaW5kZXgpKSkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIElsbGVnYWw6IFxcMDEgXFwwMiBhbmQgc28gb25cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnRocm93VW5leHBlY3RlZFRva2VuKG1lc3NhZ2VzXzEuTWVzc2FnZXMuVGVtcGxhdGVPY3RhbExpdGVyYWwpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29va2VkICs9ICdcXDAnO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGNoYXJhY3Rlcl8xLkNoYXJhY3Rlci5pc09jdGFsRGlnaXQoY2guY2hhckNvZGVBdCgwKSkpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIElsbGVnYWw6IFxcMSBcXDJcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMudGhyb3dVbmV4cGVjdGVkVG9rZW4obWVzc2FnZXNfMS5NZXNzYWdlcy5UZW1wbGF0ZU9jdGFsTGl0ZXJhbCk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb29rZWQgKz0gY2g7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcblx0ICAgICAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgZWxzZSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICArK3RoaXMubGluZU51bWJlcjtcclxuXHQgICAgICAgICAgICAgICAgICAgIGlmIChjaCA9PT0gJ1xccicgJiYgdGhpcy5zb3VyY2VbdGhpcy5pbmRleF0gPT09ICdcXG4nKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgKyt0aGlzLmluZGV4O1xyXG5cdCAgICAgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICAgICAgdGhpcy5saW5lU3RhcnQgPSB0aGlzLmluZGV4O1xyXG5cdCAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgIGVsc2UgaWYgKGNoYXJhY3Rlcl8xLkNoYXJhY3Rlci5pc0xpbmVUZXJtaW5hdG9yKGNoLmNoYXJDb2RlQXQoMCkpKSB7XHJcblx0ICAgICAgICAgICAgICAgICsrdGhpcy5saW5lTnVtYmVyO1xyXG5cdCAgICAgICAgICAgICAgICBpZiAoY2ggPT09ICdcXHInICYmIHRoaXMuc291cmNlW3RoaXMuaW5kZXhdID09PSAnXFxuJykge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgKyt0aGlzLmluZGV4O1xyXG5cdCAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgIHRoaXMubGluZVN0YXJ0ID0gdGhpcy5pbmRleDtcclxuXHQgICAgICAgICAgICAgICAgY29va2VkICs9ICdcXG4nO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICBlbHNlIHtcclxuXHQgICAgICAgICAgICAgICAgY29va2VkICs9IGNoO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIGlmICghdGVybWluYXRlZCkge1xyXG5cdCAgICAgICAgICAgIHRoaXMudGhyb3dVbmV4cGVjdGVkVG9rZW4oKTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIGlmICghaGVhZCkge1xyXG5cdCAgICAgICAgICAgIHRoaXMuY3VybHlTdGFjay5wb3AoKTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIHJldHVybiB7XHJcblx0ICAgICAgICAgICAgdHlwZTogMTAgLyogVGVtcGxhdGUgKi8sXHJcblx0ICAgICAgICAgICAgdmFsdWU6IHRoaXMuc291cmNlLnNsaWNlKHN0YXJ0ICsgMSwgdGhpcy5pbmRleCAtIHJhd09mZnNldCksXHJcblx0ICAgICAgICAgICAgY29va2VkOiBjb29rZWQsXHJcblx0ICAgICAgICAgICAgaGVhZDogaGVhZCxcclxuXHQgICAgICAgICAgICB0YWlsOiB0YWlsLFxyXG5cdCAgICAgICAgICAgIGxpbmVOdW1iZXI6IHRoaXMubGluZU51bWJlcixcclxuXHQgICAgICAgICAgICBsaW5lU3RhcnQ6IHRoaXMubGluZVN0YXJ0LFxyXG5cdCAgICAgICAgICAgIHN0YXJ0OiBzdGFydCxcclxuXHQgICAgICAgICAgICBlbmQ6IHRoaXMuaW5kZXhcclxuXHQgICAgICAgIH07XHJcblx0ICAgIH07XHJcblx0ICAgIC8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLWxpdGVyYWxzLXJlZ3VsYXItZXhwcmVzc2lvbi1saXRlcmFsc1xyXG5cdCAgICBTY2FubmVyLnByb3RvdHlwZS50ZXN0UmVnRXhwID0gZnVuY3Rpb24gKHBhdHRlcm4sIGZsYWdzKSB7XHJcblx0ICAgICAgICAvLyBUaGUgQk1QIGNoYXJhY3RlciB0byB1c2UgYXMgYSByZXBsYWNlbWVudCBmb3IgYXN0cmFsIHN5bWJvbHMgd2hlblxyXG5cdCAgICAgICAgLy8gdHJhbnNsYXRpbmcgYW4gRVM2IFwidVwiLWZsYWdnZWQgcGF0dGVybiB0byBhbiBFUzUtY29tcGF0aWJsZVxyXG5cdCAgICAgICAgLy8gYXBwcm94aW1hdGlvbi5cclxuXHQgICAgICAgIC8vIE5vdGU6IHJlcGxhY2luZyB3aXRoICdcXHVGRkZGJyBlbmFibGVzIGZhbHNlIHBvc2l0aXZlcyBpbiB1bmxpa2VseVxyXG5cdCAgICAgICAgLy8gc2NlbmFyaW9zLiBGb3IgZXhhbXBsZSwgYFtcXHV7MTA0NGZ9LVxcdXsxMDQ0MH1dYCBpcyBhbiBpbnZhbGlkXHJcblx0ICAgICAgICAvLyBwYXR0ZXJuIHRoYXQgd291bGQgbm90IGJlIGRldGVjdGVkIGJ5IHRoaXMgc3Vic3RpdHV0aW9uLlxyXG5cdCAgICAgICAgdmFyIGFzdHJhbFN1YnN0aXR1dGUgPSAnXFx1RkZGRic7XHJcblx0ICAgICAgICB2YXIgdG1wID0gcGF0dGVybjtcclxuXHQgICAgICAgIHZhciBzZWxmID0gdGhpcztcclxuXHQgICAgICAgIGlmIChmbGFncy5pbmRleE9mKCd1JykgPj0gMCkge1xyXG5cdCAgICAgICAgICAgIHRtcCA9IHRtcFxyXG5cdCAgICAgICAgICAgICAgICAucmVwbGFjZSgvXFxcXHVcXHsoWzAtOWEtZkEtRl0rKVxcfXxcXFxcdShbYS1mQS1GMC05XXs0fSkvZywgZnVuY3Rpb24gKCQwLCAkMSwgJDIpIHtcclxuXHQgICAgICAgICAgICAgICAgdmFyIGNvZGVQb2ludCA9IHBhcnNlSW50KCQxIHx8ICQyLCAxNik7XHJcblx0ICAgICAgICAgICAgICAgIGlmIChjb2RlUG9pbnQgPiAweDEwRkZGRikge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgc2VsZi50aHJvd1VuZXhwZWN0ZWRUb2tlbihtZXNzYWdlc18xLk1lc3NhZ2VzLkludmFsaWRSZWdFeHApO1xyXG5cdCAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgIGlmIChjb2RlUG9pbnQgPD0gMHhGRkZGKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZShjb2RlUG9pbnQpO1xyXG5cdCAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgIHJldHVybiBhc3RyYWxTdWJzdGl0dXRlO1xyXG5cdCAgICAgICAgICAgIH0pXHJcblx0ICAgICAgICAgICAgICAgIC5yZXBsYWNlKC9bXFx1RDgwMC1cXHVEQkZGXVtcXHVEQzAwLVxcdURGRkZdL2csIGFzdHJhbFN1YnN0aXR1dGUpO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgLy8gRmlyc3QsIGRldGVjdCBpbnZhbGlkIHJlZ3VsYXIgZXhwcmVzc2lvbnMuXHJcblx0ICAgICAgICB0cnkge1xyXG5cdCAgICAgICAgICAgIFJlZ0V4cCh0bXApO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgY2F0Y2ggKGUpIHtcclxuXHQgICAgICAgICAgICB0aGlzLnRocm93VW5leHBlY3RlZFRva2VuKG1lc3NhZ2VzXzEuTWVzc2FnZXMuSW52YWxpZFJlZ0V4cCk7XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICAvLyBSZXR1cm4gYSByZWd1bGFyIGV4cHJlc3Npb24gb2JqZWN0IGZvciB0aGlzIHBhdHRlcm4tZmxhZyBwYWlyLCBvclxyXG5cdCAgICAgICAgLy8gYG51bGxgIGluIGNhc2UgdGhlIGN1cnJlbnQgZW52aXJvbm1lbnQgZG9lc24ndCBzdXBwb3J0IHRoZSBmbGFncyBpdFxyXG5cdCAgICAgICAgLy8gdXNlcy5cclxuXHQgICAgICAgIHRyeSB7XHJcblx0ICAgICAgICAgICAgcmV0dXJuIG5ldyBSZWdFeHAocGF0dGVybiwgZmxhZ3MpO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgY2F0Y2ggKGV4Y2VwdGlvbikge1xyXG5cdCAgICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXHJcblx0ICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcblx0ICAgICAgICB9XHJcblx0ICAgIH07XHJcblx0ICAgIFNjYW5uZXIucHJvdG90eXBlLnNjYW5SZWdFeHBCb2R5ID0gZnVuY3Rpb24gKCkge1xyXG5cdCAgICAgICAgdmFyIGNoID0gdGhpcy5zb3VyY2VbdGhpcy5pbmRleF07XHJcblx0ICAgICAgICBhc3NlcnRfMS5hc3NlcnQoY2ggPT09ICcvJywgJ1JlZ3VsYXIgZXhwcmVzc2lvbiBsaXRlcmFsIG11c3Qgc3RhcnQgd2l0aCBhIHNsYXNoJyk7XHJcblx0ICAgICAgICB2YXIgc3RyID0gdGhpcy5zb3VyY2VbdGhpcy5pbmRleCsrXTtcclxuXHQgICAgICAgIHZhciBjbGFzc01hcmtlciA9IGZhbHNlO1xyXG5cdCAgICAgICAgdmFyIHRlcm1pbmF0ZWQgPSBmYWxzZTtcclxuXHQgICAgICAgIHdoaWxlICghdGhpcy5lb2YoKSkge1xyXG5cdCAgICAgICAgICAgIGNoID0gdGhpcy5zb3VyY2VbdGhpcy5pbmRleCsrXTtcclxuXHQgICAgICAgICAgICBzdHIgKz0gY2g7XHJcblx0ICAgICAgICAgICAgaWYgKGNoID09PSAnXFxcXCcpIHtcclxuXHQgICAgICAgICAgICAgICAgY2ggPSB0aGlzLnNvdXJjZVt0aGlzLmluZGV4KytdO1xyXG5cdCAgICAgICAgICAgICAgICAvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1saXRlcmFscy1yZWd1bGFyLWV4cHJlc3Npb24tbGl0ZXJhbHNcclxuXHQgICAgICAgICAgICAgICAgaWYgKGNoYXJhY3Rlcl8xLkNoYXJhY3Rlci5pc0xpbmVUZXJtaW5hdG9yKGNoLmNoYXJDb2RlQXQoMCkpKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICB0aGlzLnRocm93VW5leHBlY3RlZFRva2VuKG1lc3NhZ2VzXzEuTWVzc2FnZXMuVW50ZXJtaW5hdGVkUmVnRXhwKTtcclxuXHQgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICBzdHIgKz0gY2g7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgIGVsc2UgaWYgKGNoYXJhY3Rlcl8xLkNoYXJhY3Rlci5pc0xpbmVUZXJtaW5hdG9yKGNoLmNoYXJDb2RlQXQoMCkpKSB7XHJcblx0ICAgICAgICAgICAgICAgIHRoaXMudGhyb3dVbmV4cGVjdGVkVG9rZW4obWVzc2FnZXNfMS5NZXNzYWdlcy5VbnRlcm1pbmF0ZWRSZWdFeHApO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICBlbHNlIGlmIChjbGFzc01hcmtlcikge1xyXG5cdCAgICAgICAgICAgICAgICBpZiAoY2ggPT09ICddJykge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgY2xhc3NNYXJrZXIgPSBmYWxzZTtcclxuXHQgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICBlbHNlIHtcclxuXHQgICAgICAgICAgICAgICAgaWYgKGNoID09PSAnLycpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgIHRlcm1pbmF0ZWQgPSB0cnVlO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcblx0ICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgZWxzZSBpZiAoY2ggPT09ICdbJykge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgY2xhc3NNYXJrZXIgPSB0cnVlO1xyXG5cdCAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgaWYgKCF0ZXJtaW5hdGVkKSB7XHJcblx0ICAgICAgICAgICAgdGhpcy50aHJvd1VuZXhwZWN0ZWRUb2tlbihtZXNzYWdlc18xLk1lc3NhZ2VzLlVudGVybWluYXRlZFJlZ0V4cCk7XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICAvLyBFeGNsdWRlIGxlYWRpbmcgYW5kIHRyYWlsaW5nIHNsYXNoLlxyXG5cdCAgICAgICAgcmV0dXJuIHN0ci5zdWJzdHIoMSwgc3RyLmxlbmd0aCAtIDIpO1xyXG5cdCAgICB9O1xyXG5cdCAgICBTY2FubmVyLnByb3RvdHlwZS5zY2FuUmVnRXhwRmxhZ3MgPSBmdW5jdGlvbiAoKSB7XHJcblx0ICAgICAgICB2YXIgc3RyID0gJyc7XHJcblx0ICAgICAgICB2YXIgZmxhZ3MgPSAnJztcclxuXHQgICAgICAgIHdoaWxlICghdGhpcy5lb2YoKSkge1xyXG5cdCAgICAgICAgICAgIHZhciBjaCA9IHRoaXMuc291cmNlW3RoaXMuaW5kZXhdO1xyXG5cdCAgICAgICAgICAgIGlmICghY2hhcmFjdGVyXzEuQ2hhcmFjdGVyLmlzSWRlbnRpZmllclBhcnQoY2guY2hhckNvZGVBdCgwKSkpIHtcclxuXHQgICAgICAgICAgICAgICAgYnJlYWs7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICsrdGhpcy5pbmRleDtcclxuXHQgICAgICAgICAgICBpZiAoY2ggPT09ICdcXFxcJyAmJiAhdGhpcy5lb2YoKSkge1xyXG5cdCAgICAgICAgICAgICAgICBjaCA9IHRoaXMuc291cmNlW3RoaXMuaW5kZXhdO1xyXG5cdCAgICAgICAgICAgICAgICBpZiAoY2ggPT09ICd1Jykge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgKyt0aGlzLmluZGV4O1xyXG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIHJlc3RvcmUgPSB0aGlzLmluZGV4O1xyXG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIGNoYXIgPSB0aGlzLnNjYW5IZXhFc2NhcGUoJ3UnKTtcclxuXHQgICAgICAgICAgICAgICAgICAgIGlmIChjaGFyICE9PSBudWxsKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgZmxhZ3MgKz0gY2hhcjtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHN0ciArPSAnXFxcXHUnOyByZXN0b3JlIDwgdGhpcy5pbmRleDsgKytyZXN0b3JlKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0ciArPSB0aGlzLnNvdXJjZVtyZXN0b3JlXTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmluZGV4ID0gcmVzdG9yZTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBmbGFncyArPSAndSc7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgc3RyICs9ICdcXFxcdSc7XHJcblx0ICAgICAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgICAgICB0aGlzLnRvbGVyYXRlVW5leHBlY3RlZFRva2VuKCk7XHJcblx0ICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgZWxzZSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICBzdHIgKz0gJ1xcXFwnO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgdGhpcy50b2xlcmF0ZVVuZXhwZWN0ZWRUb2tlbigpO1xyXG5cdCAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgIGVsc2Uge1xyXG5cdCAgICAgICAgICAgICAgICBmbGFncyArPSBjaDtcclxuXHQgICAgICAgICAgICAgICAgc3RyICs9IGNoO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIHJldHVybiBmbGFncztcclxuXHQgICAgfTtcclxuXHQgICAgU2Nhbm5lci5wcm90b3R5cGUuc2NhblJlZ0V4cCA9IGZ1bmN0aW9uICgpIHtcclxuXHQgICAgICAgIHZhciBzdGFydCA9IHRoaXMuaW5kZXg7XHJcblx0ICAgICAgICB2YXIgcGF0dGVybiA9IHRoaXMuc2NhblJlZ0V4cEJvZHkoKTtcclxuXHQgICAgICAgIHZhciBmbGFncyA9IHRoaXMuc2NhblJlZ0V4cEZsYWdzKCk7XHJcblx0ICAgICAgICB2YXIgdmFsdWUgPSB0aGlzLnRlc3RSZWdFeHAocGF0dGVybiwgZmxhZ3MpO1xyXG5cdCAgICAgICAgcmV0dXJuIHtcclxuXHQgICAgICAgICAgICB0eXBlOiA5IC8qIFJlZ3VsYXJFeHByZXNzaW9uICovLFxyXG5cdCAgICAgICAgICAgIHZhbHVlOiAnJyxcclxuXHQgICAgICAgICAgICBwYXR0ZXJuOiBwYXR0ZXJuLFxyXG5cdCAgICAgICAgICAgIGZsYWdzOiBmbGFncyxcclxuXHQgICAgICAgICAgICByZWdleDogdmFsdWUsXHJcblx0ICAgICAgICAgICAgbGluZU51bWJlcjogdGhpcy5saW5lTnVtYmVyLFxyXG5cdCAgICAgICAgICAgIGxpbmVTdGFydDogdGhpcy5saW5lU3RhcnQsXHJcblx0ICAgICAgICAgICAgc3RhcnQ6IHN0YXJ0LFxyXG5cdCAgICAgICAgICAgIGVuZDogdGhpcy5pbmRleFxyXG5cdCAgICAgICAgfTtcclxuXHQgICAgfTtcclxuXHQgICAgU2Nhbm5lci5wcm90b3R5cGUubGV4ID0gZnVuY3Rpb24gKCkge1xyXG5cdCAgICAgICAgaWYgKHRoaXMuZW9mKCkpIHtcclxuXHQgICAgICAgICAgICByZXR1cm4ge1xyXG5cdCAgICAgICAgICAgICAgICB0eXBlOiAyIC8qIEVPRiAqLyxcclxuXHQgICAgICAgICAgICAgICAgdmFsdWU6ICcnLFxyXG5cdCAgICAgICAgICAgICAgICBsaW5lTnVtYmVyOiB0aGlzLmxpbmVOdW1iZXIsXHJcblx0ICAgICAgICAgICAgICAgIGxpbmVTdGFydDogdGhpcy5saW5lU3RhcnQsXHJcblx0ICAgICAgICAgICAgICAgIHN0YXJ0OiB0aGlzLmluZGV4LFxyXG5cdCAgICAgICAgICAgICAgICBlbmQ6IHRoaXMuaW5kZXhcclxuXHQgICAgICAgICAgICB9O1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgdmFyIGNwID0gdGhpcy5zb3VyY2UuY2hhckNvZGVBdCh0aGlzLmluZGV4KTtcclxuXHQgICAgICAgIGlmIChjaGFyYWN0ZXJfMS5DaGFyYWN0ZXIuaXNJZGVudGlmaWVyU3RhcnQoY3ApKSB7XHJcblx0ICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2NhbklkZW50aWZpZXIoKTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIC8vIFZlcnkgY29tbW9uOiAoIGFuZCApIGFuZCA7XHJcblx0ICAgICAgICBpZiAoY3AgPT09IDB4MjggfHwgY3AgPT09IDB4MjkgfHwgY3AgPT09IDB4M0IpIHtcclxuXHQgICAgICAgICAgICByZXR1cm4gdGhpcy5zY2FuUHVuY3R1YXRvcigpO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgLy8gU3RyaW5nIGxpdGVyYWwgc3RhcnRzIHdpdGggc2luZ2xlIHF1b3RlIChVKzAwMjcpIG9yIGRvdWJsZSBxdW90ZSAoVSswMDIyKS5cclxuXHQgICAgICAgIGlmIChjcCA9PT0gMHgyNyB8fCBjcCA9PT0gMHgyMikge1xyXG5cdCAgICAgICAgICAgIHJldHVybiB0aGlzLnNjYW5TdHJpbmdMaXRlcmFsKCk7XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICAvLyBEb3QgKC4pIFUrMDAyRSBjYW4gYWxzbyBzdGFydCBhIGZsb2F0aW5nLXBvaW50IG51bWJlciwgaGVuY2UgdGhlIG5lZWRcclxuXHQgICAgICAgIC8vIHRvIGNoZWNrIHRoZSBuZXh0IGNoYXJhY3Rlci5cclxuXHQgICAgICAgIGlmIChjcCA9PT0gMHgyRSkge1xyXG5cdCAgICAgICAgICAgIGlmIChjaGFyYWN0ZXJfMS5DaGFyYWN0ZXIuaXNEZWNpbWFsRGlnaXQodGhpcy5zb3VyY2UuY2hhckNvZGVBdCh0aGlzLmluZGV4ICsgMSkpKSB7XHJcblx0ICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnNjYW5OdW1lcmljTGl0ZXJhbCgpO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICByZXR1cm4gdGhpcy5zY2FuUHVuY3R1YXRvcigpO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgaWYgKGNoYXJhY3Rlcl8xLkNoYXJhY3Rlci5pc0RlY2ltYWxEaWdpdChjcCkpIHtcclxuXHQgICAgICAgICAgICByZXR1cm4gdGhpcy5zY2FuTnVtZXJpY0xpdGVyYWwoKTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIC8vIFRlbXBsYXRlIGxpdGVyYWxzIHN0YXJ0IHdpdGggYCAoVSswMDYwKSBmb3IgdGVtcGxhdGUgaGVhZFxyXG5cdCAgICAgICAgLy8gb3IgfSAoVSswMDdEKSBmb3IgdGVtcGxhdGUgbWlkZGxlIG9yIHRlbXBsYXRlIHRhaWwuXHJcblx0ICAgICAgICBpZiAoY3AgPT09IDB4NjAgfHwgKGNwID09PSAweDdEICYmIHRoaXMuY3VybHlTdGFja1t0aGlzLmN1cmx5U3RhY2subGVuZ3RoIC0gMV0gPT09ICckeycpKSB7XHJcblx0ICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2NhblRlbXBsYXRlKCk7XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICAvLyBQb3NzaWJsZSBpZGVudGlmaWVyIHN0YXJ0IGluIGEgc3Vycm9nYXRlIHBhaXIuXHJcblx0ICAgICAgICBpZiAoY3AgPj0gMHhEODAwICYmIGNwIDwgMHhERkZGKSB7XHJcblx0ICAgICAgICAgICAgaWYgKGNoYXJhY3Rlcl8xLkNoYXJhY3Rlci5pc0lkZW50aWZpZXJTdGFydCh0aGlzLmNvZGVQb2ludEF0KHRoaXMuaW5kZXgpKSkge1xyXG5cdCAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5zY2FuSWRlbnRpZmllcigpO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIHJldHVybiB0aGlzLnNjYW5QdW5jdHVhdG9yKCk7XHJcblx0ICAgIH07XHJcblx0ICAgIHJldHVybiBTY2FubmVyO1xyXG5cdH0oKSk7XHJcblx0ZXhwb3J0cy5TY2FubmVyID0gU2Nhbm5lcjtcclxuXG5cbi8qKiovIH0sXG4vKiAxMyAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cblx0XCJ1c2Ugc3RyaWN0XCI7XHJcblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG5cdGV4cG9ydHMuVG9rZW5OYW1lID0ge307XHJcblx0ZXhwb3J0cy5Ub2tlbk5hbWVbMSAvKiBCb29sZWFuTGl0ZXJhbCAqL10gPSAnQm9vbGVhbic7XHJcblx0ZXhwb3J0cy5Ub2tlbk5hbWVbMiAvKiBFT0YgKi9dID0gJzxlbmQ+JztcclxuXHRleHBvcnRzLlRva2VuTmFtZVszIC8qIElkZW50aWZpZXIgKi9dID0gJ0lkZW50aWZpZXInO1xyXG5cdGV4cG9ydHMuVG9rZW5OYW1lWzQgLyogS2V5d29yZCAqL10gPSAnS2V5d29yZCc7XHJcblx0ZXhwb3J0cy5Ub2tlbk5hbWVbNSAvKiBOdWxsTGl0ZXJhbCAqL10gPSAnTnVsbCc7XHJcblx0ZXhwb3J0cy5Ub2tlbk5hbWVbNiAvKiBOdW1lcmljTGl0ZXJhbCAqL10gPSAnTnVtZXJpYyc7XHJcblx0ZXhwb3J0cy5Ub2tlbk5hbWVbNyAvKiBQdW5jdHVhdG9yICovXSA9ICdQdW5jdHVhdG9yJztcclxuXHRleHBvcnRzLlRva2VuTmFtZVs4IC8qIFN0cmluZ0xpdGVyYWwgKi9dID0gJ1N0cmluZyc7XHJcblx0ZXhwb3J0cy5Ub2tlbk5hbWVbOSAvKiBSZWd1bGFyRXhwcmVzc2lvbiAqL10gPSAnUmVndWxhckV4cHJlc3Npb24nO1xyXG5cdGV4cG9ydHMuVG9rZW5OYW1lWzEwIC8qIFRlbXBsYXRlICovXSA9ICdUZW1wbGF0ZSc7XHJcblxuXG4vKioqLyB9LFxuLyogMTQgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG5cdFwidXNlIHN0cmljdFwiO1xyXG5cdC8vIEdlbmVyYXRlZCBieSBnZW5lcmF0ZS14aHRtbC1lbnRpdGllcy5qcy4gRE8gTk9UIE1PRElGWSFcclxuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcblx0ZXhwb3J0cy5YSFRNTEVudGl0aWVzID0ge1xyXG5cdCAgICBxdW90OiAnXFx1MDAyMicsXHJcblx0ICAgIGFtcDogJ1xcdTAwMjYnLFxyXG5cdCAgICBhcG9zOiAnXFx1MDAyNycsXHJcblx0ICAgIGd0OiAnXFx1MDAzRScsXHJcblx0ICAgIG5ic3A6ICdcXHUwMEEwJyxcclxuXHQgICAgaWV4Y2w6ICdcXHUwMEExJyxcclxuXHQgICAgY2VudDogJ1xcdTAwQTInLFxyXG5cdCAgICBwb3VuZDogJ1xcdTAwQTMnLFxyXG5cdCAgICBjdXJyZW46ICdcXHUwMEE0JyxcclxuXHQgICAgeWVuOiAnXFx1MDBBNScsXHJcblx0ICAgIGJydmJhcjogJ1xcdTAwQTYnLFxyXG5cdCAgICBzZWN0OiAnXFx1MDBBNycsXHJcblx0ICAgIHVtbDogJ1xcdTAwQTgnLFxyXG5cdCAgICBjb3B5OiAnXFx1MDBBOScsXHJcblx0ICAgIG9yZGY6ICdcXHUwMEFBJyxcclxuXHQgICAgbGFxdW86ICdcXHUwMEFCJyxcclxuXHQgICAgbm90OiAnXFx1MDBBQycsXHJcblx0ICAgIHNoeTogJ1xcdTAwQUQnLFxyXG5cdCAgICByZWc6ICdcXHUwMEFFJyxcclxuXHQgICAgbWFjcjogJ1xcdTAwQUYnLFxyXG5cdCAgICBkZWc6ICdcXHUwMEIwJyxcclxuXHQgICAgcGx1c21uOiAnXFx1MDBCMScsXHJcblx0ICAgIHN1cDI6ICdcXHUwMEIyJyxcclxuXHQgICAgc3VwMzogJ1xcdTAwQjMnLFxyXG5cdCAgICBhY3V0ZTogJ1xcdTAwQjQnLFxyXG5cdCAgICBtaWNybzogJ1xcdTAwQjUnLFxyXG5cdCAgICBwYXJhOiAnXFx1MDBCNicsXHJcblx0ICAgIG1pZGRvdDogJ1xcdTAwQjcnLFxyXG5cdCAgICBjZWRpbDogJ1xcdTAwQjgnLFxyXG5cdCAgICBzdXAxOiAnXFx1MDBCOScsXHJcblx0ICAgIG9yZG06ICdcXHUwMEJBJyxcclxuXHQgICAgcmFxdW86ICdcXHUwMEJCJyxcclxuXHQgICAgZnJhYzE0OiAnXFx1MDBCQycsXHJcblx0ICAgIGZyYWMxMjogJ1xcdTAwQkQnLFxyXG5cdCAgICBmcmFjMzQ6ICdcXHUwMEJFJyxcclxuXHQgICAgaXF1ZXN0OiAnXFx1MDBCRicsXHJcblx0ICAgIEFncmF2ZTogJ1xcdTAwQzAnLFxyXG5cdCAgICBBYWN1dGU6ICdcXHUwMEMxJyxcclxuXHQgICAgQWNpcmM6ICdcXHUwMEMyJyxcclxuXHQgICAgQXRpbGRlOiAnXFx1MDBDMycsXHJcblx0ICAgIEF1bWw6ICdcXHUwMEM0JyxcclxuXHQgICAgQXJpbmc6ICdcXHUwMEM1JyxcclxuXHQgICAgQUVsaWc6ICdcXHUwMEM2JyxcclxuXHQgICAgQ2NlZGlsOiAnXFx1MDBDNycsXHJcblx0ICAgIEVncmF2ZTogJ1xcdTAwQzgnLFxyXG5cdCAgICBFYWN1dGU6ICdcXHUwMEM5JyxcclxuXHQgICAgRWNpcmM6ICdcXHUwMENBJyxcclxuXHQgICAgRXVtbDogJ1xcdTAwQ0InLFxyXG5cdCAgICBJZ3JhdmU6ICdcXHUwMENDJyxcclxuXHQgICAgSWFjdXRlOiAnXFx1MDBDRCcsXHJcblx0ICAgIEljaXJjOiAnXFx1MDBDRScsXHJcblx0ICAgIEl1bWw6ICdcXHUwMENGJyxcclxuXHQgICAgRVRIOiAnXFx1MDBEMCcsXHJcblx0ICAgIE50aWxkZTogJ1xcdTAwRDEnLFxyXG5cdCAgICBPZ3JhdmU6ICdcXHUwMEQyJyxcclxuXHQgICAgT2FjdXRlOiAnXFx1MDBEMycsXHJcblx0ICAgIE9jaXJjOiAnXFx1MDBENCcsXHJcblx0ICAgIE90aWxkZTogJ1xcdTAwRDUnLFxyXG5cdCAgICBPdW1sOiAnXFx1MDBENicsXHJcblx0ICAgIHRpbWVzOiAnXFx1MDBENycsXHJcblx0ICAgIE9zbGFzaDogJ1xcdTAwRDgnLFxyXG5cdCAgICBVZ3JhdmU6ICdcXHUwMEQ5JyxcclxuXHQgICAgVWFjdXRlOiAnXFx1MDBEQScsXHJcblx0ICAgIFVjaXJjOiAnXFx1MDBEQicsXHJcblx0ICAgIFV1bWw6ICdcXHUwMERDJyxcclxuXHQgICAgWWFjdXRlOiAnXFx1MDBERCcsXHJcblx0ICAgIFRIT1JOOiAnXFx1MDBERScsXHJcblx0ICAgIHN6bGlnOiAnXFx1MDBERicsXHJcblx0ICAgIGFncmF2ZTogJ1xcdTAwRTAnLFxyXG5cdCAgICBhYWN1dGU6ICdcXHUwMEUxJyxcclxuXHQgICAgYWNpcmM6ICdcXHUwMEUyJyxcclxuXHQgICAgYXRpbGRlOiAnXFx1MDBFMycsXHJcblx0ICAgIGF1bWw6ICdcXHUwMEU0JyxcclxuXHQgICAgYXJpbmc6ICdcXHUwMEU1JyxcclxuXHQgICAgYWVsaWc6ICdcXHUwMEU2JyxcclxuXHQgICAgY2NlZGlsOiAnXFx1MDBFNycsXHJcblx0ICAgIGVncmF2ZTogJ1xcdTAwRTgnLFxyXG5cdCAgICBlYWN1dGU6ICdcXHUwMEU5JyxcclxuXHQgICAgZWNpcmM6ICdcXHUwMEVBJyxcclxuXHQgICAgZXVtbDogJ1xcdTAwRUInLFxyXG5cdCAgICBpZ3JhdmU6ICdcXHUwMEVDJyxcclxuXHQgICAgaWFjdXRlOiAnXFx1MDBFRCcsXHJcblx0ICAgIGljaXJjOiAnXFx1MDBFRScsXHJcblx0ICAgIGl1bWw6ICdcXHUwMEVGJyxcclxuXHQgICAgZXRoOiAnXFx1MDBGMCcsXHJcblx0ICAgIG50aWxkZTogJ1xcdTAwRjEnLFxyXG5cdCAgICBvZ3JhdmU6ICdcXHUwMEYyJyxcclxuXHQgICAgb2FjdXRlOiAnXFx1MDBGMycsXHJcblx0ICAgIG9jaXJjOiAnXFx1MDBGNCcsXHJcblx0ICAgIG90aWxkZTogJ1xcdTAwRjUnLFxyXG5cdCAgICBvdW1sOiAnXFx1MDBGNicsXHJcblx0ICAgIGRpdmlkZTogJ1xcdTAwRjcnLFxyXG5cdCAgICBvc2xhc2g6ICdcXHUwMEY4JyxcclxuXHQgICAgdWdyYXZlOiAnXFx1MDBGOScsXHJcblx0ICAgIHVhY3V0ZTogJ1xcdTAwRkEnLFxyXG5cdCAgICB1Y2lyYzogJ1xcdTAwRkInLFxyXG5cdCAgICB1dW1sOiAnXFx1MDBGQycsXHJcblx0ICAgIHlhY3V0ZTogJ1xcdTAwRkQnLFxyXG5cdCAgICB0aG9ybjogJ1xcdTAwRkUnLFxyXG5cdCAgICB5dW1sOiAnXFx1MDBGRicsXHJcblx0ICAgIE9FbGlnOiAnXFx1MDE1MicsXHJcblx0ICAgIG9lbGlnOiAnXFx1MDE1MycsXHJcblx0ICAgIFNjYXJvbjogJ1xcdTAxNjAnLFxyXG5cdCAgICBzY2Fyb246ICdcXHUwMTYxJyxcclxuXHQgICAgWXVtbDogJ1xcdTAxNzgnLFxyXG5cdCAgICBmbm9mOiAnXFx1MDE5MicsXHJcblx0ICAgIGNpcmM6ICdcXHUwMkM2JyxcclxuXHQgICAgdGlsZGU6ICdcXHUwMkRDJyxcclxuXHQgICAgQWxwaGE6ICdcXHUwMzkxJyxcclxuXHQgICAgQmV0YTogJ1xcdTAzOTInLFxyXG5cdCAgICBHYW1tYTogJ1xcdTAzOTMnLFxyXG5cdCAgICBEZWx0YTogJ1xcdTAzOTQnLFxyXG5cdCAgICBFcHNpbG9uOiAnXFx1MDM5NScsXHJcblx0ICAgIFpldGE6ICdcXHUwMzk2JyxcclxuXHQgICAgRXRhOiAnXFx1MDM5NycsXHJcblx0ICAgIFRoZXRhOiAnXFx1MDM5OCcsXHJcblx0ICAgIElvdGE6ICdcXHUwMzk5JyxcclxuXHQgICAgS2FwcGE6ICdcXHUwMzlBJyxcclxuXHQgICAgTGFtYmRhOiAnXFx1MDM5QicsXHJcblx0ICAgIE11OiAnXFx1MDM5QycsXHJcblx0ICAgIE51OiAnXFx1MDM5RCcsXHJcblx0ICAgIFhpOiAnXFx1MDM5RScsXHJcblx0ICAgIE9taWNyb246ICdcXHUwMzlGJyxcclxuXHQgICAgUGk6ICdcXHUwM0EwJyxcclxuXHQgICAgUmhvOiAnXFx1MDNBMScsXHJcblx0ICAgIFNpZ21hOiAnXFx1MDNBMycsXHJcblx0ICAgIFRhdTogJ1xcdTAzQTQnLFxyXG5cdCAgICBVcHNpbG9uOiAnXFx1MDNBNScsXHJcblx0ICAgIFBoaTogJ1xcdTAzQTYnLFxyXG5cdCAgICBDaGk6ICdcXHUwM0E3JyxcclxuXHQgICAgUHNpOiAnXFx1MDNBOCcsXHJcblx0ICAgIE9tZWdhOiAnXFx1MDNBOScsXHJcblx0ICAgIGFscGhhOiAnXFx1MDNCMScsXHJcblx0ICAgIGJldGE6ICdcXHUwM0IyJyxcclxuXHQgICAgZ2FtbWE6ICdcXHUwM0IzJyxcclxuXHQgICAgZGVsdGE6ICdcXHUwM0I0JyxcclxuXHQgICAgZXBzaWxvbjogJ1xcdTAzQjUnLFxyXG5cdCAgICB6ZXRhOiAnXFx1MDNCNicsXHJcblx0ICAgIGV0YTogJ1xcdTAzQjcnLFxyXG5cdCAgICB0aGV0YTogJ1xcdTAzQjgnLFxyXG5cdCAgICBpb3RhOiAnXFx1MDNCOScsXHJcblx0ICAgIGthcHBhOiAnXFx1MDNCQScsXHJcblx0ICAgIGxhbWJkYTogJ1xcdTAzQkInLFxyXG5cdCAgICBtdTogJ1xcdTAzQkMnLFxyXG5cdCAgICBudTogJ1xcdTAzQkQnLFxyXG5cdCAgICB4aTogJ1xcdTAzQkUnLFxyXG5cdCAgICBvbWljcm9uOiAnXFx1MDNCRicsXHJcblx0ICAgIHBpOiAnXFx1MDNDMCcsXHJcblx0ICAgIHJobzogJ1xcdTAzQzEnLFxyXG5cdCAgICBzaWdtYWY6ICdcXHUwM0MyJyxcclxuXHQgICAgc2lnbWE6ICdcXHUwM0MzJyxcclxuXHQgICAgdGF1OiAnXFx1MDNDNCcsXHJcblx0ICAgIHVwc2lsb246ICdcXHUwM0M1JyxcclxuXHQgICAgcGhpOiAnXFx1MDNDNicsXHJcblx0ICAgIGNoaTogJ1xcdTAzQzcnLFxyXG5cdCAgICBwc2k6ICdcXHUwM0M4JyxcclxuXHQgICAgb21lZ2E6ICdcXHUwM0M5JyxcclxuXHQgICAgdGhldGFzeW06ICdcXHUwM0QxJyxcclxuXHQgICAgdXBzaWg6ICdcXHUwM0QyJyxcclxuXHQgICAgcGl2OiAnXFx1MDNENicsXHJcblx0ICAgIGVuc3A6ICdcXHUyMDAyJyxcclxuXHQgICAgZW1zcDogJ1xcdTIwMDMnLFxyXG5cdCAgICB0aGluc3A6ICdcXHUyMDA5JyxcclxuXHQgICAgenduajogJ1xcdTIwMEMnLFxyXG5cdCAgICB6d2o6ICdcXHUyMDBEJyxcclxuXHQgICAgbHJtOiAnXFx1MjAwRScsXHJcblx0ICAgIHJsbTogJ1xcdTIwMEYnLFxyXG5cdCAgICBuZGFzaDogJ1xcdTIwMTMnLFxyXG5cdCAgICBtZGFzaDogJ1xcdTIwMTQnLFxyXG5cdCAgICBsc3F1bzogJ1xcdTIwMTgnLFxyXG5cdCAgICByc3F1bzogJ1xcdTIwMTknLFxyXG5cdCAgICBzYnF1bzogJ1xcdTIwMUEnLFxyXG5cdCAgICBsZHF1bzogJ1xcdTIwMUMnLFxyXG5cdCAgICByZHF1bzogJ1xcdTIwMUQnLFxyXG5cdCAgICBiZHF1bzogJ1xcdTIwMUUnLFxyXG5cdCAgICBkYWdnZXI6ICdcXHUyMDIwJyxcclxuXHQgICAgRGFnZ2VyOiAnXFx1MjAyMScsXHJcblx0ICAgIGJ1bGw6ICdcXHUyMDIyJyxcclxuXHQgICAgaGVsbGlwOiAnXFx1MjAyNicsXHJcblx0ICAgIHBlcm1pbDogJ1xcdTIwMzAnLFxyXG5cdCAgICBwcmltZTogJ1xcdTIwMzInLFxyXG5cdCAgICBQcmltZTogJ1xcdTIwMzMnLFxyXG5cdCAgICBsc2FxdW86ICdcXHUyMDM5JyxcclxuXHQgICAgcnNhcXVvOiAnXFx1MjAzQScsXHJcblx0ICAgIG9saW5lOiAnXFx1MjAzRScsXHJcblx0ICAgIGZyYXNsOiAnXFx1MjA0NCcsXHJcblx0ICAgIGV1cm86ICdcXHUyMEFDJyxcclxuXHQgICAgaW1hZ2U6ICdcXHUyMTExJyxcclxuXHQgICAgd2VpZXJwOiAnXFx1MjExOCcsXHJcblx0ICAgIHJlYWw6ICdcXHUyMTFDJyxcclxuXHQgICAgdHJhZGU6ICdcXHUyMTIyJyxcclxuXHQgICAgYWxlZnN5bTogJ1xcdTIxMzUnLFxyXG5cdCAgICBsYXJyOiAnXFx1MjE5MCcsXHJcblx0ICAgIHVhcnI6ICdcXHUyMTkxJyxcclxuXHQgICAgcmFycjogJ1xcdTIxOTInLFxyXG5cdCAgICBkYXJyOiAnXFx1MjE5MycsXHJcblx0ICAgIGhhcnI6ICdcXHUyMTk0JyxcclxuXHQgICAgY3JhcnI6ICdcXHUyMUI1JyxcclxuXHQgICAgbEFycjogJ1xcdTIxRDAnLFxyXG5cdCAgICB1QXJyOiAnXFx1MjFEMScsXHJcblx0ICAgIHJBcnI6ICdcXHUyMUQyJyxcclxuXHQgICAgZEFycjogJ1xcdTIxRDMnLFxyXG5cdCAgICBoQXJyOiAnXFx1MjFENCcsXHJcblx0ICAgIGZvcmFsbDogJ1xcdTIyMDAnLFxyXG5cdCAgICBwYXJ0OiAnXFx1MjIwMicsXHJcblx0ICAgIGV4aXN0OiAnXFx1MjIwMycsXHJcblx0ICAgIGVtcHR5OiAnXFx1MjIwNScsXHJcblx0ICAgIG5hYmxhOiAnXFx1MjIwNycsXHJcblx0ICAgIGlzaW46ICdcXHUyMjA4JyxcclxuXHQgICAgbm90aW46ICdcXHUyMjA5JyxcclxuXHQgICAgbmk6ICdcXHUyMjBCJyxcclxuXHQgICAgcHJvZDogJ1xcdTIyMEYnLFxyXG5cdCAgICBzdW06ICdcXHUyMjExJyxcclxuXHQgICAgbWludXM6ICdcXHUyMjEyJyxcclxuXHQgICAgbG93YXN0OiAnXFx1MjIxNycsXHJcblx0ICAgIHJhZGljOiAnXFx1MjIxQScsXHJcblx0ICAgIHByb3A6ICdcXHUyMjFEJyxcclxuXHQgICAgaW5maW46ICdcXHUyMjFFJyxcclxuXHQgICAgYW5nOiAnXFx1MjIyMCcsXHJcblx0ICAgIGFuZDogJ1xcdTIyMjcnLFxyXG5cdCAgICBvcjogJ1xcdTIyMjgnLFxyXG5cdCAgICBjYXA6ICdcXHUyMjI5JyxcclxuXHQgICAgY3VwOiAnXFx1MjIyQScsXHJcblx0ICAgIGludDogJ1xcdTIyMkInLFxyXG5cdCAgICB0aGVyZTQ6ICdcXHUyMjM0JyxcclxuXHQgICAgc2ltOiAnXFx1MjIzQycsXHJcblx0ICAgIGNvbmc6ICdcXHUyMjQ1JyxcclxuXHQgICAgYXN5bXA6ICdcXHUyMjQ4JyxcclxuXHQgICAgbmU6ICdcXHUyMjYwJyxcclxuXHQgICAgZXF1aXY6ICdcXHUyMjYxJyxcclxuXHQgICAgbGU6ICdcXHUyMjY0JyxcclxuXHQgICAgZ2U6ICdcXHUyMjY1JyxcclxuXHQgICAgc3ViOiAnXFx1MjI4MicsXHJcblx0ICAgIHN1cDogJ1xcdTIyODMnLFxyXG5cdCAgICBuc3ViOiAnXFx1MjI4NCcsXHJcblx0ICAgIHN1YmU6ICdcXHUyMjg2JyxcclxuXHQgICAgc3VwZTogJ1xcdTIyODcnLFxyXG5cdCAgICBvcGx1czogJ1xcdTIyOTUnLFxyXG5cdCAgICBvdGltZXM6ICdcXHUyMjk3JyxcclxuXHQgICAgcGVycDogJ1xcdTIyQTUnLFxyXG5cdCAgICBzZG90OiAnXFx1MjJDNScsXHJcblx0ICAgIGxjZWlsOiAnXFx1MjMwOCcsXHJcblx0ICAgIHJjZWlsOiAnXFx1MjMwOScsXHJcblx0ICAgIGxmbG9vcjogJ1xcdTIzMEEnLFxyXG5cdCAgICByZmxvb3I6ICdcXHUyMzBCJyxcclxuXHQgICAgbG96OiAnXFx1MjVDQScsXHJcblx0ICAgIHNwYWRlczogJ1xcdTI2NjAnLFxyXG5cdCAgICBjbHViczogJ1xcdTI2NjMnLFxyXG5cdCAgICBoZWFydHM6ICdcXHUyNjY1JyxcclxuXHQgICAgZGlhbXM6ICdcXHUyNjY2JyxcclxuXHQgICAgbGFuZzogJ1xcdTI3RTgnLFxyXG5cdCAgICByYW5nOiAnXFx1MjdFOSdcclxuXHR9O1xyXG5cblxuLyoqKi8gfSxcbi8qIDE1ICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXHRcInVzZSBzdHJpY3RcIjtcclxuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcblx0dmFyIGVycm9yX2hhbmRsZXJfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMTApO1xyXG5cdHZhciBzY2FubmVyXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEyKTtcclxuXHR2YXIgdG9rZW5fMSA9IF9fd2VicGFja19yZXF1aXJlX18oMTMpO1xyXG5cdHZhciBSZWFkZXIgPSAoZnVuY3Rpb24gKCkge1xyXG5cdCAgICBmdW5jdGlvbiBSZWFkZXIoKSB7XHJcblx0ICAgICAgICB0aGlzLnZhbHVlcyA9IFtdO1xyXG5cdCAgICAgICAgdGhpcy5jdXJseSA9IHRoaXMucGFyZW4gPSAtMTtcclxuXHQgICAgfVxyXG5cdCAgICAvLyBBIGZ1bmN0aW9uIGZvbGxvd2luZyBvbmUgb2YgdGhvc2UgdG9rZW5zIGlzIGFuIGV4cHJlc3Npb24uXHJcblx0ICAgIFJlYWRlci5wcm90b3R5cGUuYmVmb3JlRnVuY3Rpb25FeHByZXNzaW9uID0gZnVuY3Rpb24gKHQpIHtcclxuXHQgICAgICAgIHJldHVybiBbJygnLCAneycsICdbJywgJ2luJywgJ3R5cGVvZicsICdpbnN0YW5jZW9mJywgJ25ldycsXHJcblx0ICAgICAgICAgICAgJ3JldHVybicsICdjYXNlJywgJ2RlbGV0ZScsICd0aHJvdycsICd2b2lkJyxcclxuXHQgICAgICAgICAgICAvLyBhc3NpZ25tZW50IG9wZXJhdG9yc1xyXG5cdCAgICAgICAgICAgICc9JywgJys9JywgJy09JywgJyo9JywgJyoqPScsICcvPScsICclPScsICc8PD0nLCAnPj49JywgJz4+Pj0nLFxyXG5cdCAgICAgICAgICAgICcmPScsICd8PScsICdePScsICcsJyxcclxuXHQgICAgICAgICAgICAvLyBiaW5hcnkvdW5hcnkgb3BlcmF0b3JzXHJcblx0ICAgICAgICAgICAgJysnLCAnLScsICcqJywgJyoqJywgJy8nLCAnJScsICcrKycsICctLScsICc8PCcsICc+PicsICc+Pj4nLCAnJicsXHJcblx0ICAgICAgICAgICAgJ3wnLCAnXicsICchJywgJ34nLCAnJiYnLCAnfHwnLCAnPycsICc6JywgJz09PScsICc9PScsICc+PScsXHJcblx0ICAgICAgICAgICAgJzw9JywgJzwnLCAnPicsICchPScsICchPT0nXS5pbmRleE9mKHQpID49IDA7XHJcblx0ICAgIH07XHJcblx0ICAgIC8vIERldGVybWluZSBpZiBmb3J3YXJkIHNsYXNoICgvKSBpcyBhbiBvcGVyYXRvciBvciBwYXJ0IG9mIGEgcmVndWxhciBleHByZXNzaW9uXHJcblx0ICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9tb3ppbGxhL3N3ZWV0LmpzL3dpa2kvZGVzaWduXHJcblx0ICAgIFJlYWRlci5wcm90b3R5cGUuaXNSZWdleFN0YXJ0ID0gZnVuY3Rpb24gKCkge1xyXG5cdCAgICAgICAgdmFyIHByZXZpb3VzID0gdGhpcy52YWx1ZXNbdGhpcy52YWx1ZXMubGVuZ3RoIC0gMV07XHJcblx0ICAgICAgICB2YXIgcmVnZXggPSAocHJldmlvdXMgIT09IG51bGwpO1xyXG5cdCAgICAgICAgc3dpdGNoIChwcmV2aW91cykge1xyXG5cdCAgICAgICAgICAgIGNhc2UgJ3RoaXMnOlxyXG5cdCAgICAgICAgICAgIGNhc2UgJ10nOlxyXG5cdCAgICAgICAgICAgICAgICByZWdleCA9IGZhbHNlO1xyXG5cdCAgICAgICAgICAgICAgICBicmVhaztcclxuXHQgICAgICAgICAgICBjYXNlICcpJzpcclxuXHQgICAgICAgICAgICAgICAgdmFyIGtleXdvcmQgPSB0aGlzLnZhbHVlc1t0aGlzLnBhcmVuIC0gMV07XHJcblx0ICAgICAgICAgICAgICAgIHJlZ2V4ID0gKGtleXdvcmQgPT09ICdpZicgfHwga2V5d29yZCA9PT0gJ3doaWxlJyB8fCBrZXl3b3JkID09PSAnZm9yJyB8fCBrZXl3b3JkID09PSAnd2l0aCcpO1xyXG5cdCAgICAgICAgICAgICAgICBicmVhaztcclxuXHQgICAgICAgICAgICBjYXNlICd9JzpcclxuXHQgICAgICAgICAgICAgICAgLy8gRGl2aWRpbmcgYSBmdW5jdGlvbiBieSBhbnl0aGluZyBtYWtlcyBsaXR0bGUgc2Vuc2UsXHJcblx0ICAgICAgICAgICAgICAgIC8vIGJ1dCB3ZSBoYXZlIHRvIGNoZWNrIGZvciB0aGF0LlxyXG5cdCAgICAgICAgICAgICAgICByZWdleCA9IGZhbHNlO1xyXG5cdCAgICAgICAgICAgICAgICBpZiAodGhpcy52YWx1ZXNbdGhpcy5jdXJseSAtIDNdID09PSAnZnVuY3Rpb24nKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAvLyBBbm9ueW1vdXMgZnVuY3Rpb24sIGUuZy4gZnVuY3Rpb24oKXt9IC80MlxyXG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIGNoZWNrID0gdGhpcy52YWx1ZXNbdGhpcy5jdXJseSAtIDRdO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgcmVnZXggPSBjaGVjayA/ICF0aGlzLmJlZm9yZUZ1bmN0aW9uRXhwcmVzc2lvbihjaGVjaykgOiBmYWxzZTtcclxuXHQgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICBlbHNlIGlmICh0aGlzLnZhbHVlc1t0aGlzLmN1cmx5IC0gNF0gPT09ICdmdW5jdGlvbicpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgIC8vIE5hbWVkIGZ1bmN0aW9uLCBlLmcuIGZ1bmN0aW9uIGYoKXt9IC80Mi9cclxuXHQgICAgICAgICAgICAgICAgICAgIHZhciBjaGVjayA9IHRoaXMudmFsdWVzW3RoaXMuY3VybHkgLSA1XTtcclxuXHQgICAgICAgICAgICAgICAgICAgIHJlZ2V4ID0gY2hlY2sgPyAhdGhpcy5iZWZvcmVGdW5jdGlvbkV4cHJlc3Npb24oY2hlY2spIDogdHJ1ZTtcclxuXHQgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICBicmVhaztcclxuXHQgICAgICAgICAgICBkZWZhdWx0OlxyXG5cdCAgICAgICAgICAgICAgICBicmVhaztcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIHJldHVybiByZWdleDtcclxuXHQgICAgfTtcclxuXHQgICAgUmVhZGVyLnByb3RvdHlwZS5wdXNoID0gZnVuY3Rpb24gKHRva2VuKSB7XHJcblx0ICAgICAgICBpZiAodG9rZW4udHlwZSA9PT0gNyAvKiBQdW5jdHVhdG9yICovIHx8IHRva2VuLnR5cGUgPT09IDQgLyogS2V5d29yZCAqLykge1xyXG5cdCAgICAgICAgICAgIGlmICh0b2tlbi52YWx1ZSA9PT0gJ3snKSB7XHJcblx0ICAgICAgICAgICAgICAgIHRoaXMuY3VybHkgPSB0aGlzLnZhbHVlcy5sZW5ndGg7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgIGVsc2UgaWYgKHRva2VuLnZhbHVlID09PSAnKCcpIHtcclxuXHQgICAgICAgICAgICAgICAgdGhpcy5wYXJlbiA9IHRoaXMudmFsdWVzLmxlbmd0aDtcclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgdGhpcy52YWx1ZXMucHVzaCh0b2tlbi52YWx1ZSk7XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICBlbHNlIHtcclxuXHQgICAgICAgICAgICB0aGlzLnZhbHVlcy5wdXNoKG51bGwpO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICB9O1xyXG5cdCAgICByZXR1cm4gUmVhZGVyO1xyXG5cdH0oKSk7XHJcblx0dmFyIFRva2VuaXplciA9IChmdW5jdGlvbiAoKSB7XHJcblx0ICAgIGZ1bmN0aW9uIFRva2VuaXplcihjb2RlLCBjb25maWcpIHtcclxuXHQgICAgICAgIHRoaXMuZXJyb3JIYW5kbGVyID0gbmV3IGVycm9yX2hhbmRsZXJfMS5FcnJvckhhbmRsZXIoKTtcclxuXHQgICAgICAgIHRoaXMuZXJyb3JIYW5kbGVyLnRvbGVyYW50ID0gY29uZmlnID8gKHR5cGVvZiBjb25maWcudG9sZXJhbnQgPT09ICdib29sZWFuJyAmJiBjb25maWcudG9sZXJhbnQpIDogZmFsc2U7XHJcblx0ICAgICAgICB0aGlzLnNjYW5uZXIgPSBuZXcgc2Nhbm5lcl8xLlNjYW5uZXIoY29kZSwgdGhpcy5lcnJvckhhbmRsZXIpO1xyXG5cdCAgICAgICAgdGhpcy5zY2FubmVyLnRyYWNrQ29tbWVudCA9IGNvbmZpZyA/ICh0eXBlb2YgY29uZmlnLmNvbW1lbnQgPT09ICdib29sZWFuJyAmJiBjb25maWcuY29tbWVudCkgOiBmYWxzZTtcclxuXHQgICAgICAgIHRoaXMudHJhY2tSYW5nZSA9IGNvbmZpZyA/ICh0eXBlb2YgY29uZmlnLnJhbmdlID09PSAnYm9vbGVhbicgJiYgY29uZmlnLnJhbmdlKSA6IGZhbHNlO1xyXG5cdCAgICAgICAgdGhpcy50cmFja0xvYyA9IGNvbmZpZyA/ICh0eXBlb2YgY29uZmlnLmxvYyA9PT0gJ2Jvb2xlYW4nICYmIGNvbmZpZy5sb2MpIDogZmFsc2U7XHJcblx0ICAgICAgICB0aGlzLmJ1ZmZlciA9IFtdO1xyXG5cdCAgICAgICAgdGhpcy5yZWFkZXIgPSBuZXcgUmVhZGVyKCk7XHJcblx0ICAgIH1cclxuXHQgICAgVG9rZW5pemVyLnByb3RvdHlwZS5lcnJvcnMgPSBmdW5jdGlvbiAoKSB7XHJcblx0ICAgICAgICByZXR1cm4gdGhpcy5lcnJvckhhbmRsZXIuZXJyb3JzO1xyXG5cdCAgICB9O1xyXG5cdCAgICBUb2tlbml6ZXIucHJvdG90eXBlLmdldE5leHRUb2tlbiA9IGZ1bmN0aW9uICgpIHtcclxuXHQgICAgICAgIGlmICh0aGlzLmJ1ZmZlci5sZW5ndGggPT09IDApIHtcclxuXHQgICAgICAgICAgICB2YXIgY29tbWVudHMgPSB0aGlzLnNjYW5uZXIuc2NhbkNvbW1lbnRzKCk7XHJcblx0ICAgICAgICAgICAgaWYgKHRoaXMuc2Nhbm5lci50cmFja0NvbW1lbnQpIHtcclxuXHQgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb21tZW50cy5sZW5ndGg7ICsraSkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIGUgPSBjb21tZW50c1tpXTtcclxuXHQgICAgICAgICAgICAgICAgICAgIHZhciB2YWx1ZSA9IHRoaXMuc2Nhbm5lci5zb3VyY2Uuc2xpY2UoZS5zbGljZVswXSwgZS5zbGljZVsxXSk7XHJcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgY29tbWVudCA9IHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBlLm11bHRpTGluZSA/ICdCbG9ja0NvbW1lbnQnIDogJ0xpbmVDb21tZW50JyxcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogdmFsdWVcclxuXHQgICAgICAgICAgICAgICAgICAgIH07XHJcblx0ICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy50cmFja1JhbmdlKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgY29tbWVudC5yYW5nZSA9IGUucmFuZ2U7XHJcblx0ICAgICAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy50cmFja0xvYykge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGNvbW1lbnQubG9jID0gZS5sb2M7XHJcblx0ICAgICAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgICAgICB0aGlzLmJ1ZmZlci5wdXNoKGNvbW1lbnQpO1xyXG5cdCAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgIGlmICghdGhpcy5zY2FubmVyLmVvZigpKSB7XHJcblx0ICAgICAgICAgICAgICAgIHZhciBsb2MgPSB2b2lkIDA7XHJcblx0ICAgICAgICAgICAgICAgIGlmICh0aGlzLnRyYWNrTG9jKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICBsb2MgPSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgc3RhcnQ6IHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGluZTogdGhpcy5zY2FubmVyLmxpbmVOdW1iZXIsXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbHVtbjogdGhpcy5zY2FubmVyLmluZGV4IC0gdGhpcy5zY2FubmVyLmxpbmVTdGFydFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH0sXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgZW5kOiB7fVxyXG5cdCAgICAgICAgICAgICAgICAgICAgfTtcclxuXHQgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICB2YXIgc3RhcnRSZWdleCA9ICh0aGlzLnNjYW5uZXIuc291cmNlW3RoaXMuc2Nhbm5lci5pbmRleF0gPT09ICcvJykgJiYgdGhpcy5yZWFkZXIuaXNSZWdleFN0YXJ0KCk7XHJcblx0ICAgICAgICAgICAgICAgIHZhciB0b2tlbiA9IHN0YXJ0UmVnZXggPyB0aGlzLnNjYW5uZXIuc2NhblJlZ0V4cCgpIDogdGhpcy5zY2FubmVyLmxleCgpO1xyXG5cdCAgICAgICAgICAgICAgICB0aGlzLnJlYWRlci5wdXNoKHRva2VuKTtcclxuXHQgICAgICAgICAgICAgICAgdmFyIGVudHJ5ID0ge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgdHlwZTogdG9rZW5fMS5Ub2tlbk5hbWVbdG9rZW4udHlwZV0sXHJcblx0ICAgICAgICAgICAgICAgICAgICB2YWx1ZTogdGhpcy5zY2FubmVyLnNvdXJjZS5zbGljZSh0b2tlbi5zdGFydCwgdG9rZW4uZW5kKVxyXG5cdCAgICAgICAgICAgICAgICB9O1xyXG5cdCAgICAgICAgICAgICAgICBpZiAodGhpcy50cmFja1JhbmdlKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICBlbnRyeS5yYW5nZSA9IFt0b2tlbi5zdGFydCwgdG9rZW4uZW5kXTtcclxuXHQgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICBpZiAodGhpcy50cmFja0xvYykge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgbG9jLmVuZCA9IHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBsaW5lOiB0aGlzLnNjYW5uZXIubGluZU51bWJlcixcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBjb2x1bW46IHRoaXMuc2Nhbm5lci5pbmRleCAtIHRoaXMuc2Nhbm5lci5saW5lU3RhcnRcclxuXHQgICAgICAgICAgICAgICAgICAgIH07XHJcblx0ICAgICAgICAgICAgICAgICAgICBlbnRyeS5sb2MgPSBsb2M7XHJcblx0ICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgaWYgKHRva2VuLnR5cGUgPT09IDkgLyogUmVndWxhckV4cHJlc3Npb24gKi8pIHtcclxuXHQgICAgICAgICAgICAgICAgICAgIHZhciBwYXR0ZXJuID0gdG9rZW4ucGF0dGVybjtcclxuXHQgICAgICAgICAgICAgICAgICAgIHZhciBmbGFncyA9IHRva2VuLmZsYWdzO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgZW50cnkucmVnZXggPSB7IHBhdHRlcm46IHBhdHRlcm4sIGZsYWdzOiBmbGFncyB9O1xyXG5cdCAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgIHRoaXMuYnVmZmVyLnB1c2goZW50cnkpO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIHJldHVybiB0aGlzLmJ1ZmZlci5zaGlmdCgpO1xyXG5cdCAgICB9O1xyXG5cdCAgICByZXR1cm4gVG9rZW5pemVyO1xyXG5cdH0oKSk7XHJcblx0ZXhwb3J0cy5Ub2tlbml6ZXIgPSBUb2tlbml6ZXI7XHJcblxuXG4vKioqLyB9XG4vKioqKioqLyBdKVxufSk7XG47XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2VzcHJpbWEvZGlzdC9lc3ByaW1hLmpzIiwiJ3VzZSBzdHJpY3QnO1xuXG4vKmVzbGludC1kaXNhYmxlIG5vLXVzZS1iZWZvcmUtZGVmaW5lKi9cblxudmFyIGNvbW1vbiAgICAgICAgICAgICAgPSByZXF1aXJlKCcuL2NvbW1vbicpO1xudmFyIFlBTUxFeGNlcHRpb24gICAgICAgPSByZXF1aXJlKCcuL2V4Y2VwdGlvbicpO1xudmFyIERFRkFVTFRfRlVMTF9TQ0hFTUEgPSByZXF1aXJlKCcuL3NjaGVtYS9kZWZhdWx0X2Z1bGwnKTtcbnZhciBERUZBVUxUX1NBRkVfU0NIRU1BID0gcmVxdWlyZSgnLi9zY2hlbWEvZGVmYXVsdF9zYWZlJyk7XG5cbnZhciBfdG9TdHJpbmcgICAgICAgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nO1xudmFyIF9oYXNPd25Qcm9wZXJ0eSA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG5cbnZhciBDSEFSX1RBQiAgICAgICAgICAgICAgICAgID0gMHgwOTsgLyogVGFiICovXG52YXIgQ0hBUl9MSU5FX0ZFRUQgICAgICAgICAgICA9IDB4MEE7IC8qIExGICovXG52YXIgQ0hBUl9TUEFDRSAgICAgICAgICAgICAgICA9IDB4MjA7IC8qIFNwYWNlICovXG52YXIgQ0hBUl9FWENMQU1BVElPTiAgICAgICAgICA9IDB4MjE7IC8qICEgKi9cbnZhciBDSEFSX0RPVUJMRV9RVU9URSAgICAgICAgID0gMHgyMjsgLyogXCIgKi9cbnZhciBDSEFSX1NIQVJQICAgICAgICAgICAgICAgID0gMHgyMzsgLyogIyAqL1xudmFyIENIQVJfUEVSQ0VOVCAgICAgICAgICAgICAgPSAweDI1OyAvKiAlICovXG52YXIgQ0hBUl9BTVBFUlNBTkQgICAgICAgICAgICA9IDB4MjY7IC8qICYgKi9cbnZhciBDSEFSX1NJTkdMRV9RVU9URSAgICAgICAgID0gMHgyNzsgLyogJyAqL1xudmFyIENIQVJfQVNURVJJU0sgICAgICAgICAgICAgPSAweDJBOyAvKiAqICovXG52YXIgQ0hBUl9DT01NQSAgICAgICAgICAgICAgICA9IDB4MkM7IC8qICwgKi9cbnZhciBDSEFSX01JTlVTICAgICAgICAgICAgICAgID0gMHgyRDsgLyogLSAqL1xudmFyIENIQVJfQ09MT04gICAgICAgICAgICAgICAgPSAweDNBOyAvKiA6ICovXG52YXIgQ0hBUl9HUkVBVEVSX1RIQU4gICAgICAgICA9IDB4M0U7IC8qID4gKi9cbnZhciBDSEFSX1FVRVNUSU9OICAgICAgICAgICAgID0gMHgzRjsgLyogPyAqL1xudmFyIENIQVJfQ09NTUVSQ0lBTF9BVCAgICAgICAgPSAweDQwOyAvKiBAICovXG52YXIgQ0hBUl9MRUZUX1NRVUFSRV9CUkFDS0VUICA9IDB4NUI7IC8qIFsgKi9cbnZhciBDSEFSX1JJR0hUX1NRVUFSRV9CUkFDS0VUID0gMHg1RDsgLyogXSAqL1xudmFyIENIQVJfR1JBVkVfQUNDRU5UICAgICAgICAgPSAweDYwOyAvKiBgICovXG52YXIgQ0hBUl9MRUZUX0NVUkxZX0JSQUNLRVQgICA9IDB4N0I7IC8qIHsgKi9cbnZhciBDSEFSX1ZFUlRJQ0FMX0xJTkUgICAgICAgID0gMHg3QzsgLyogfCAqL1xudmFyIENIQVJfUklHSFRfQ1VSTFlfQlJBQ0tFVCAgPSAweDdEOyAvKiB9ICovXG5cbnZhciBFU0NBUEVfU0VRVUVOQ0VTID0ge307XG5cbkVTQ0FQRV9TRVFVRU5DRVNbMHgwMF0gICA9ICdcXFxcMCc7XG5FU0NBUEVfU0VRVUVOQ0VTWzB4MDddICAgPSAnXFxcXGEnO1xuRVNDQVBFX1NFUVVFTkNFU1sweDA4XSAgID0gJ1xcXFxiJztcbkVTQ0FQRV9TRVFVRU5DRVNbMHgwOV0gICA9ICdcXFxcdCc7XG5FU0NBUEVfU0VRVUVOQ0VTWzB4MEFdICAgPSAnXFxcXG4nO1xuRVNDQVBFX1NFUVVFTkNFU1sweDBCXSAgID0gJ1xcXFx2JztcbkVTQ0FQRV9TRVFVRU5DRVNbMHgwQ10gICA9ICdcXFxcZic7XG5FU0NBUEVfU0VRVUVOQ0VTWzB4MERdICAgPSAnXFxcXHInO1xuRVNDQVBFX1NFUVVFTkNFU1sweDFCXSAgID0gJ1xcXFxlJztcbkVTQ0FQRV9TRVFVRU5DRVNbMHgyMl0gICA9ICdcXFxcXCInO1xuRVNDQVBFX1NFUVVFTkNFU1sweDVDXSAgID0gJ1xcXFxcXFxcJztcbkVTQ0FQRV9TRVFVRU5DRVNbMHg4NV0gICA9ICdcXFxcTic7XG5FU0NBUEVfU0VRVUVOQ0VTWzB4QTBdICAgPSAnXFxcXF8nO1xuRVNDQVBFX1NFUVVFTkNFU1sweDIwMjhdID0gJ1xcXFxMJztcbkVTQ0FQRV9TRVFVRU5DRVNbMHgyMDI5XSA9ICdcXFxcUCc7XG5cbnZhciBERVBSRUNBVEVEX0JPT0xFQU5TX1NZTlRBWCA9IFtcbiAgJ3knLCAnWScsICd5ZXMnLCAnWWVzJywgJ1lFUycsICdvbicsICdPbicsICdPTicsXG4gICduJywgJ04nLCAnbm8nLCAnTm8nLCAnTk8nLCAnb2ZmJywgJ09mZicsICdPRkYnXG5dO1xuXG5mdW5jdGlvbiBjb21waWxlU3R5bGVNYXAoc2NoZW1hLCBtYXApIHtcbiAgdmFyIHJlc3VsdCwga2V5cywgaW5kZXgsIGxlbmd0aCwgdGFnLCBzdHlsZSwgdHlwZTtcblxuICBpZiAobWFwID09PSBudWxsKSByZXR1cm4ge307XG5cbiAgcmVzdWx0ID0ge307XG4gIGtleXMgPSBPYmplY3Qua2V5cyhtYXApO1xuXG4gIGZvciAoaW5kZXggPSAwLCBsZW5ndGggPSBrZXlzLmxlbmd0aDsgaW5kZXggPCBsZW5ndGg7IGluZGV4ICs9IDEpIHtcbiAgICB0YWcgPSBrZXlzW2luZGV4XTtcbiAgICBzdHlsZSA9IFN0cmluZyhtYXBbdGFnXSk7XG5cbiAgICBpZiAodGFnLnNsaWNlKDAsIDIpID09PSAnISEnKSB7XG4gICAgICB0YWcgPSAndGFnOnlhbWwub3JnLDIwMDI6JyArIHRhZy5zbGljZSgyKTtcbiAgICB9XG4gICAgdHlwZSA9IHNjaGVtYS5jb21waWxlZFR5cGVNYXBbJ2ZhbGxiYWNrJ11bdGFnXTtcblxuICAgIGlmICh0eXBlICYmIF9oYXNPd25Qcm9wZXJ0eS5jYWxsKHR5cGUuc3R5bGVBbGlhc2VzLCBzdHlsZSkpIHtcbiAgICAgIHN0eWxlID0gdHlwZS5zdHlsZUFsaWFzZXNbc3R5bGVdO1xuICAgIH1cblxuICAgIHJlc3VsdFt0YWddID0gc3R5bGU7XG4gIH1cblxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5mdW5jdGlvbiBlbmNvZGVIZXgoY2hhcmFjdGVyKSB7XG4gIHZhciBzdHJpbmcsIGhhbmRsZSwgbGVuZ3RoO1xuXG4gIHN0cmluZyA9IGNoYXJhY3Rlci50b1N0cmluZygxNikudG9VcHBlckNhc2UoKTtcblxuICBpZiAoY2hhcmFjdGVyIDw9IDB4RkYpIHtcbiAgICBoYW5kbGUgPSAneCc7XG4gICAgbGVuZ3RoID0gMjtcbiAgfSBlbHNlIGlmIChjaGFyYWN0ZXIgPD0gMHhGRkZGKSB7XG4gICAgaGFuZGxlID0gJ3UnO1xuICAgIGxlbmd0aCA9IDQ7XG4gIH0gZWxzZSBpZiAoY2hhcmFjdGVyIDw9IDB4RkZGRkZGRkYpIHtcbiAgICBoYW5kbGUgPSAnVSc7XG4gICAgbGVuZ3RoID0gODtcbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBuZXcgWUFNTEV4Y2VwdGlvbignY29kZSBwb2ludCB3aXRoaW4gYSBzdHJpbmcgbWF5IG5vdCBiZSBncmVhdGVyIHRoYW4gMHhGRkZGRkZGRicpO1xuICB9XG5cbiAgcmV0dXJuICdcXFxcJyArIGhhbmRsZSArIGNvbW1vbi5yZXBlYXQoJzAnLCBsZW5ndGggLSBzdHJpbmcubGVuZ3RoKSArIHN0cmluZztcbn1cblxuZnVuY3Rpb24gU3RhdGUob3B0aW9ucykge1xuICB0aGlzLnNjaGVtYSAgICAgICA9IG9wdGlvbnNbJ3NjaGVtYSddIHx8IERFRkFVTFRfRlVMTF9TQ0hFTUE7XG4gIHRoaXMuaW5kZW50ICAgICAgID0gTWF0aC5tYXgoMSwgKG9wdGlvbnNbJ2luZGVudCddIHx8IDIpKTtcbiAgdGhpcy5za2lwSW52YWxpZCAgPSBvcHRpb25zWydza2lwSW52YWxpZCddIHx8IGZhbHNlO1xuICB0aGlzLmZsb3dMZXZlbCAgICA9IChjb21tb24uaXNOb3RoaW5nKG9wdGlvbnNbJ2Zsb3dMZXZlbCddKSA/IC0xIDogb3B0aW9uc1snZmxvd0xldmVsJ10pO1xuICB0aGlzLnN0eWxlTWFwICAgICA9IGNvbXBpbGVTdHlsZU1hcCh0aGlzLnNjaGVtYSwgb3B0aW9uc1snc3R5bGVzJ10gfHwgbnVsbCk7XG4gIHRoaXMuc29ydEtleXMgICAgID0gb3B0aW9uc1snc29ydEtleXMnXSB8fCBmYWxzZTtcbiAgdGhpcy5saW5lV2lkdGggICAgPSBvcHRpb25zWydsaW5lV2lkdGgnXSB8fCA4MDtcbiAgdGhpcy5ub1JlZnMgICAgICAgPSBvcHRpb25zWydub1JlZnMnXSB8fCBmYWxzZTtcbiAgdGhpcy5ub0NvbXBhdE1vZGUgPSBvcHRpb25zWydub0NvbXBhdE1vZGUnXSB8fCBmYWxzZTtcbiAgdGhpcy5jb25kZW5zZUZsb3cgPSBvcHRpb25zWydjb25kZW5zZUZsb3cnXSB8fCBmYWxzZTtcblxuICB0aGlzLmltcGxpY2l0VHlwZXMgPSB0aGlzLnNjaGVtYS5jb21waWxlZEltcGxpY2l0O1xuICB0aGlzLmV4cGxpY2l0VHlwZXMgPSB0aGlzLnNjaGVtYS5jb21waWxlZEV4cGxpY2l0O1xuXG4gIHRoaXMudGFnID0gbnVsbDtcbiAgdGhpcy5yZXN1bHQgPSAnJztcblxuICB0aGlzLmR1cGxpY2F0ZXMgPSBbXTtcbiAgdGhpcy51c2VkRHVwbGljYXRlcyA9IG51bGw7XG59XG5cbi8vIEluZGVudHMgZXZlcnkgbGluZSBpbiBhIHN0cmluZy4gRW1wdHkgbGluZXMgKFxcbiBvbmx5KSBhcmUgbm90IGluZGVudGVkLlxuZnVuY3Rpb24gaW5kZW50U3RyaW5nKHN0cmluZywgc3BhY2VzKSB7XG4gIHZhciBpbmQgPSBjb21tb24ucmVwZWF0KCcgJywgc3BhY2VzKSxcbiAgICAgIHBvc2l0aW9uID0gMCxcbiAgICAgIG5leHQgPSAtMSxcbiAgICAgIHJlc3VsdCA9ICcnLFxuICAgICAgbGluZSxcbiAgICAgIGxlbmd0aCA9IHN0cmluZy5sZW5ndGg7XG5cbiAgd2hpbGUgKHBvc2l0aW9uIDwgbGVuZ3RoKSB7XG4gICAgbmV4dCA9IHN0cmluZy5pbmRleE9mKCdcXG4nLCBwb3NpdGlvbik7XG4gICAgaWYgKG5leHQgPT09IC0xKSB7XG4gICAgICBsaW5lID0gc3RyaW5nLnNsaWNlKHBvc2l0aW9uKTtcbiAgICAgIHBvc2l0aW9uID0gbGVuZ3RoO1xuICAgIH0gZWxzZSB7XG4gICAgICBsaW5lID0gc3RyaW5nLnNsaWNlKHBvc2l0aW9uLCBuZXh0ICsgMSk7XG4gICAgICBwb3NpdGlvbiA9IG5leHQgKyAxO1xuICAgIH1cblxuICAgIGlmIChsaW5lLmxlbmd0aCAmJiBsaW5lICE9PSAnXFxuJykgcmVzdWx0ICs9IGluZDtcblxuICAgIHJlc3VsdCArPSBsaW5lO1xuICB9XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuZnVuY3Rpb24gZ2VuZXJhdGVOZXh0TGluZShzdGF0ZSwgbGV2ZWwpIHtcbiAgcmV0dXJuICdcXG4nICsgY29tbW9uLnJlcGVhdCgnICcsIHN0YXRlLmluZGVudCAqIGxldmVsKTtcbn1cblxuZnVuY3Rpb24gdGVzdEltcGxpY2l0UmVzb2x2aW5nKHN0YXRlLCBzdHIpIHtcbiAgdmFyIGluZGV4LCBsZW5ndGgsIHR5cGU7XG5cbiAgZm9yIChpbmRleCA9IDAsIGxlbmd0aCA9IHN0YXRlLmltcGxpY2l0VHlwZXMubGVuZ3RoOyBpbmRleCA8IGxlbmd0aDsgaW5kZXggKz0gMSkge1xuICAgIHR5cGUgPSBzdGF0ZS5pbXBsaWNpdFR5cGVzW2luZGV4XTtcblxuICAgIGlmICh0eXBlLnJlc29sdmUoc3RyKSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG4vLyBbMzNdIHMtd2hpdGUgOjo9IHMtc3BhY2UgfCBzLXRhYlxuZnVuY3Rpb24gaXNXaGl0ZXNwYWNlKGMpIHtcbiAgcmV0dXJuIGMgPT09IENIQVJfU1BBQ0UgfHwgYyA9PT0gQ0hBUl9UQUI7XG59XG5cbi8vIFJldHVybnMgdHJ1ZSBpZiB0aGUgY2hhcmFjdGVyIGNhbiBiZSBwcmludGVkIHdpdGhvdXQgZXNjYXBpbmcuXG4vLyBGcm9tIFlBTUwgMS4yOiBcImFueSBhbGxvd2VkIGNoYXJhY3RlcnMga25vd24gdG8gYmUgbm9uLXByaW50YWJsZVxuLy8gc2hvdWxkIGFsc28gYmUgZXNjYXBlZC4gW0hvd2V2ZXIsXSBUaGlzIGlzbuKAmXQgbWFuZGF0b3J5XCJcbi8vIERlcml2ZWQgZnJvbSBuYi1jaGFyIC0gXFx0IC0gI3g4NSAtICN4QTAgLSAjeDIwMjggLSAjeDIwMjkuXG5mdW5jdGlvbiBpc1ByaW50YWJsZShjKSB7XG4gIHJldHVybiAgKDB4MDAwMjAgPD0gYyAmJiBjIDw9IDB4MDAwMDdFKVxuICAgICAgfHwgKCgweDAwMEExIDw9IGMgJiYgYyA8PSAweDAwRDdGRikgJiYgYyAhPT0gMHgyMDI4ICYmIGMgIT09IDB4MjAyOSlcbiAgICAgIHx8ICgoMHgwRTAwMCA8PSBjICYmIGMgPD0gMHgwMEZGRkQpICYmIGMgIT09IDB4RkVGRiAvKiBCT00gKi8pXG4gICAgICB8fCAgKDB4MTAwMDAgPD0gYyAmJiBjIDw9IDB4MTBGRkZGKTtcbn1cblxuLy8gU2ltcGxpZmllZCB0ZXN0IGZvciB2YWx1ZXMgYWxsb3dlZCBhZnRlciB0aGUgZmlyc3QgY2hhcmFjdGVyIGluIHBsYWluIHN0eWxlLlxuZnVuY3Rpb24gaXNQbGFpblNhZmUoYykge1xuICAvLyBVc2VzIGEgc3Vic2V0IG9mIG5iLWNoYXIgLSBjLWZsb3ctaW5kaWNhdG9yIC0gXCI6XCIgLSBcIiNcIlxuICAvLyB3aGVyZSBuYi1jaGFyIDo6PSBjLXByaW50YWJsZSAtIGItY2hhciAtIGMtYnl0ZS1vcmRlci1tYXJrLlxuICByZXR1cm4gaXNQcmludGFibGUoYykgJiYgYyAhPT0gMHhGRUZGXG4gICAgLy8gLSBjLWZsb3ctaW5kaWNhdG9yXG4gICAgJiYgYyAhPT0gQ0hBUl9DT01NQVxuICAgICYmIGMgIT09IENIQVJfTEVGVF9TUVVBUkVfQlJBQ0tFVFxuICAgICYmIGMgIT09IENIQVJfUklHSFRfU1FVQVJFX0JSQUNLRVRcbiAgICAmJiBjICE9PSBDSEFSX0xFRlRfQ1VSTFlfQlJBQ0tFVFxuICAgICYmIGMgIT09IENIQVJfUklHSFRfQ1VSTFlfQlJBQ0tFVFxuICAgIC8vIC0gXCI6XCIgLSBcIiNcIlxuICAgICYmIGMgIT09IENIQVJfQ09MT05cbiAgICAmJiBjICE9PSBDSEFSX1NIQVJQO1xufVxuXG4vLyBTaW1wbGlmaWVkIHRlc3QgZm9yIHZhbHVlcyBhbGxvd2VkIGFzIHRoZSBmaXJzdCBjaGFyYWN0ZXIgaW4gcGxhaW4gc3R5bGUuXG5mdW5jdGlvbiBpc1BsYWluU2FmZUZpcnN0KGMpIHtcbiAgLy8gVXNlcyBhIHN1YnNldCBvZiBucy1jaGFyIC0gYy1pbmRpY2F0b3JcbiAgLy8gd2hlcmUgbnMtY2hhciA9IG5iLWNoYXIgLSBzLXdoaXRlLlxuICByZXR1cm4gaXNQcmludGFibGUoYykgJiYgYyAhPT0gMHhGRUZGXG4gICAgJiYgIWlzV2hpdGVzcGFjZShjKSAvLyAtIHMtd2hpdGVcbiAgICAvLyAtIChjLWluZGljYXRvciA6Oj1cbiAgICAvLyDigJwt4oCdIHwg4oCcP+KAnSB8IOKAnDrigJ0gfCDigJws4oCdIHwg4oCcW+KAnSB8IOKAnF3igJ0gfCDigJx74oCdIHwg4oCcfeKAnVxuICAgICYmIGMgIT09IENIQVJfTUlOVVNcbiAgICAmJiBjICE9PSBDSEFSX1FVRVNUSU9OXG4gICAgJiYgYyAhPT0gQ0hBUl9DT0xPTlxuICAgICYmIGMgIT09IENIQVJfQ09NTUFcbiAgICAmJiBjICE9PSBDSEFSX0xFRlRfU1FVQVJFX0JSQUNLRVRcbiAgICAmJiBjICE9PSBDSEFSX1JJR0hUX1NRVUFSRV9CUkFDS0VUXG4gICAgJiYgYyAhPT0gQ0hBUl9MRUZUX0NVUkxZX0JSQUNLRVRcbiAgICAmJiBjICE9PSBDSEFSX1JJR0hUX0NVUkxZX0JSQUNLRVRcbiAgICAvLyB8IOKAnCPigJ0gfCDigJwm4oCdIHwg4oCcKuKAnSB8IOKAnCHigJ0gfCDigJx84oCdIHwg4oCcPuKAnSB8IOKAnCfigJ0gfCDigJxcIuKAnVxuICAgICYmIGMgIT09IENIQVJfU0hBUlBcbiAgICAmJiBjICE9PSBDSEFSX0FNUEVSU0FORFxuICAgICYmIGMgIT09IENIQVJfQVNURVJJU0tcbiAgICAmJiBjICE9PSBDSEFSX0VYQ0xBTUFUSU9OXG4gICAgJiYgYyAhPT0gQ0hBUl9WRVJUSUNBTF9MSU5FXG4gICAgJiYgYyAhPT0gQ0hBUl9HUkVBVEVSX1RIQU5cbiAgICAmJiBjICE9PSBDSEFSX1NJTkdMRV9RVU9URVxuICAgICYmIGMgIT09IENIQVJfRE9VQkxFX1FVT1RFXG4gICAgLy8gfCDigJwl4oCdIHwg4oCcQOKAnSB8IOKAnGDigJ0pXG4gICAgJiYgYyAhPT0gQ0hBUl9QRVJDRU5UXG4gICAgJiYgYyAhPT0gQ0hBUl9DT01NRVJDSUFMX0FUXG4gICAgJiYgYyAhPT0gQ0hBUl9HUkFWRV9BQ0NFTlQ7XG59XG5cbnZhciBTVFlMRV9QTEFJTiAgID0gMSxcbiAgICBTVFlMRV9TSU5HTEUgID0gMixcbiAgICBTVFlMRV9MSVRFUkFMID0gMyxcbiAgICBTVFlMRV9GT0xERUQgID0gNCxcbiAgICBTVFlMRV9ET1VCTEUgID0gNTtcblxuLy8gRGV0ZXJtaW5lcyB3aGljaCBzY2FsYXIgc3R5bGVzIGFyZSBwb3NzaWJsZSBhbmQgcmV0dXJucyB0aGUgcHJlZmVycmVkIHN0eWxlLlxuLy8gbGluZVdpZHRoID0gLTEgPT4gbm8gbGltaXQuXG4vLyBQcmUtY29uZGl0aW9uczogc3RyLmxlbmd0aCA+IDAuXG4vLyBQb3N0LWNvbmRpdGlvbnM6XG4vLyAgICBTVFlMRV9QTEFJTiBvciBTVFlMRV9TSU5HTEUgPT4gbm8gXFxuIGFyZSBpbiB0aGUgc3RyaW5nLlxuLy8gICAgU1RZTEVfTElURVJBTCA9PiBubyBsaW5lcyBhcmUgc3VpdGFibGUgZm9yIGZvbGRpbmcgKG9yIGxpbmVXaWR0aCBpcyAtMSkuXG4vLyAgICBTVFlMRV9GT0xERUQgPT4gYSBsaW5lID4gbGluZVdpZHRoIGFuZCBjYW4gYmUgZm9sZGVkIChhbmQgbGluZVdpZHRoICE9IC0xKS5cbmZ1bmN0aW9uIGNob29zZVNjYWxhclN0eWxlKHN0cmluZywgc2luZ2xlTGluZU9ubHksIGluZGVudFBlckxldmVsLCBsaW5lV2lkdGgsIHRlc3RBbWJpZ3VvdXNUeXBlKSB7XG4gIHZhciBpO1xuICB2YXIgY2hhcjtcbiAgdmFyIGhhc0xpbmVCcmVhayA9IGZhbHNlO1xuICB2YXIgaGFzRm9sZGFibGVMaW5lID0gZmFsc2U7IC8vIG9ubHkgY2hlY2tlZCBpZiBzaG91bGRUcmFja1dpZHRoXG4gIHZhciBzaG91bGRUcmFja1dpZHRoID0gbGluZVdpZHRoICE9PSAtMTtcbiAgdmFyIHByZXZpb3VzTGluZUJyZWFrID0gLTE7IC8vIGNvdW50IHRoZSBmaXJzdCBsaW5lIGNvcnJlY3RseVxuICB2YXIgcGxhaW4gPSBpc1BsYWluU2FmZUZpcnN0KHN0cmluZy5jaGFyQ29kZUF0KDApKVxuICAgICAgICAgICYmICFpc1doaXRlc3BhY2Uoc3RyaW5nLmNoYXJDb2RlQXQoc3RyaW5nLmxlbmd0aCAtIDEpKTtcblxuICBpZiAoc2luZ2xlTGluZU9ubHkpIHtcbiAgICAvLyBDYXNlOiBubyBibG9jayBzdHlsZXMuXG4gICAgLy8gQ2hlY2sgZm9yIGRpc2FsbG93ZWQgY2hhcmFjdGVycyB0byBydWxlIG91dCBwbGFpbiBhbmQgc2luZ2xlLlxuICAgIGZvciAoaSA9IDA7IGkgPCBzdHJpbmcubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNoYXIgPSBzdHJpbmcuY2hhckNvZGVBdChpKTtcbiAgICAgIGlmICghaXNQcmludGFibGUoY2hhcikpIHtcbiAgICAgICAgcmV0dXJuIFNUWUxFX0RPVUJMRTtcbiAgICAgIH1cbiAgICAgIHBsYWluID0gcGxhaW4gJiYgaXNQbGFpblNhZmUoY2hhcik7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIC8vIENhc2U6IGJsb2NrIHN0eWxlcyBwZXJtaXR0ZWQuXG4gICAgZm9yIChpID0gMDsgaSA8IHN0cmluZy5sZW5ndGg7IGkrKykge1xuICAgICAgY2hhciA9IHN0cmluZy5jaGFyQ29kZUF0KGkpO1xuICAgICAgaWYgKGNoYXIgPT09IENIQVJfTElORV9GRUVEKSB7XG4gICAgICAgIGhhc0xpbmVCcmVhayA9IHRydWU7XG4gICAgICAgIC8vIENoZWNrIGlmIGFueSBsaW5lIGNhbiBiZSBmb2xkZWQuXG4gICAgICAgIGlmIChzaG91bGRUcmFja1dpZHRoKSB7XG4gICAgICAgICAgaGFzRm9sZGFibGVMaW5lID0gaGFzRm9sZGFibGVMaW5lIHx8XG4gICAgICAgICAgICAvLyBGb2xkYWJsZSBsaW5lID0gdG9vIGxvbmcsIGFuZCBub3QgbW9yZS1pbmRlbnRlZC5cbiAgICAgICAgICAgIChpIC0gcHJldmlvdXNMaW5lQnJlYWsgLSAxID4gbGluZVdpZHRoICYmXG4gICAgICAgICAgICAgc3RyaW5nW3ByZXZpb3VzTGluZUJyZWFrICsgMV0gIT09ICcgJyk7XG4gICAgICAgICAgcHJldmlvdXNMaW5lQnJlYWsgPSBpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKCFpc1ByaW50YWJsZShjaGFyKSkge1xuICAgICAgICByZXR1cm4gU1RZTEVfRE9VQkxFO1xuICAgICAgfVxuICAgICAgcGxhaW4gPSBwbGFpbiAmJiBpc1BsYWluU2FmZShjaGFyKTtcbiAgICB9XG4gICAgLy8gaW4gY2FzZSB0aGUgZW5kIGlzIG1pc3NpbmcgYSBcXG5cbiAgICBoYXNGb2xkYWJsZUxpbmUgPSBoYXNGb2xkYWJsZUxpbmUgfHwgKHNob3VsZFRyYWNrV2lkdGggJiZcbiAgICAgIChpIC0gcHJldmlvdXNMaW5lQnJlYWsgLSAxID4gbGluZVdpZHRoICYmXG4gICAgICAgc3RyaW5nW3ByZXZpb3VzTGluZUJyZWFrICsgMV0gIT09ICcgJykpO1xuICB9XG4gIC8vIEFsdGhvdWdoIGV2ZXJ5IHN0eWxlIGNhbiByZXByZXNlbnQgXFxuIHdpdGhvdXQgZXNjYXBpbmcsIHByZWZlciBibG9jayBzdHlsZXNcbiAgLy8gZm9yIG11bHRpbGluZSwgc2luY2UgdGhleSdyZSBtb3JlIHJlYWRhYmxlIGFuZCB0aGV5IGRvbid0IGFkZCBlbXB0eSBsaW5lcy5cbiAgLy8gQWxzbyBwcmVmZXIgZm9sZGluZyBhIHN1cGVyLWxvbmcgbGluZS5cbiAgaWYgKCFoYXNMaW5lQnJlYWsgJiYgIWhhc0ZvbGRhYmxlTGluZSkge1xuICAgIC8vIFN0cmluZ3MgaW50ZXJwcmV0YWJsZSBhcyBhbm90aGVyIHR5cGUgaGF2ZSB0byBiZSBxdW90ZWQ7XG4gICAgLy8gZS5nLiB0aGUgc3RyaW5nICd0cnVlJyB2cy4gdGhlIGJvb2xlYW4gdHJ1ZS5cbiAgICByZXR1cm4gcGxhaW4gJiYgIXRlc3RBbWJpZ3VvdXNUeXBlKHN0cmluZylcbiAgICAgID8gU1RZTEVfUExBSU4gOiBTVFlMRV9TSU5HTEU7XG4gIH1cbiAgLy8gRWRnZSBjYXNlOiBibG9jayBpbmRlbnRhdGlvbiBpbmRpY2F0b3IgY2FuIG9ubHkgaGF2ZSBvbmUgZGlnaXQuXG4gIGlmIChzdHJpbmdbMF0gPT09ICcgJyAmJiBpbmRlbnRQZXJMZXZlbCA+IDkpIHtcbiAgICByZXR1cm4gU1RZTEVfRE9VQkxFO1xuICB9XG4gIC8vIEF0IHRoaXMgcG9pbnQgd2Uga25vdyBibG9jayBzdHlsZXMgYXJlIHZhbGlkLlxuICAvLyBQcmVmZXIgbGl0ZXJhbCBzdHlsZSB1bmxlc3Mgd2Ugd2FudCB0byBmb2xkLlxuICByZXR1cm4gaGFzRm9sZGFibGVMaW5lID8gU1RZTEVfRk9MREVEIDogU1RZTEVfTElURVJBTDtcbn1cblxuLy8gTm90ZTogbGluZSBicmVha2luZy9mb2xkaW5nIGlzIGltcGxlbWVudGVkIGZvciBvbmx5IHRoZSBmb2xkZWQgc3R5bGUuXG4vLyBOQi4gV2UgZHJvcCB0aGUgbGFzdCB0cmFpbGluZyBuZXdsaW5lIChpZiBhbnkpIG9mIGEgcmV0dXJuZWQgYmxvY2sgc2NhbGFyXG4vLyAgc2luY2UgdGhlIGR1bXBlciBhZGRzIGl0cyBvd24gbmV3bGluZS4gVGhpcyBhbHdheXMgd29ya3M6XG4vLyAgICDigKIgTm8gZW5kaW5nIG5ld2xpbmUgPT4gdW5hZmZlY3RlZDsgYWxyZWFkeSB1c2luZyBzdHJpcCBcIi1cIiBjaG9tcGluZy5cbi8vICAgIOKAoiBFbmRpbmcgbmV3bGluZSAgICA9PiByZW1vdmVkIHRoZW4gcmVzdG9yZWQuXG4vLyAgSW1wb3J0YW50bHksIHRoaXMga2VlcHMgdGhlIFwiK1wiIGNob21wIGluZGljYXRvciBmcm9tIGdhaW5pbmcgYW4gZXh0cmEgbGluZS5cbmZ1bmN0aW9uIHdyaXRlU2NhbGFyKHN0YXRlLCBzdHJpbmcsIGxldmVsLCBpc2tleSkge1xuICBzdGF0ZS5kdW1wID0gKGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoc3RyaW5nLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuIFwiJydcIjtcbiAgICB9XG4gICAgaWYgKCFzdGF0ZS5ub0NvbXBhdE1vZGUgJiZcbiAgICAgICAgREVQUkVDQVRFRF9CT09MRUFOU19TWU5UQVguaW5kZXhPZihzdHJpbmcpICE9PSAtMSkge1xuICAgICAgcmV0dXJuIFwiJ1wiICsgc3RyaW5nICsgXCInXCI7XG4gICAgfVxuXG4gICAgdmFyIGluZGVudCA9IHN0YXRlLmluZGVudCAqIE1hdGgubWF4KDEsIGxldmVsKTsgLy8gbm8gMC1pbmRlbnQgc2NhbGFyc1xuICAgIC8vIEFzIGluZGVudGF0aW9uIGdldHMgZGVlcGVyLCBsZXQgdGhlIHdpZHRoIGRlY3JlYXNlIG1vbm90b25pY2FsbHlcbiAgICAvLyB0byB0aGUgbG93ZXIgYm91bmQgbWluKHN0YXRlLmxpbmVXaWR0aCwgNDApLlxuICAgIC8vIE5vdGUgdGhhdCB0aGlzIGltcGxpZXNcbiAgICAvLyAgc3RhdGUubGluZVdpZHRoIOKJpCA0MCArIHN0YXRlLmluZGVudDogd2lkdGggaXMgZml4ZWQgYXQgdGhlIGxvd2VyIGJvdW5kLlxuICAgIC8vICBzdGF0ZS5saW5lV2lkdGggPiA0MCArIHN0YXRlLmluZGVudDogd2lkdGggZGVjcmVhc2VzIHVudGlsIHRoZSBsb3dlciBib3VuZC5cbiAgICAvLyBUaGlzIGJlaGF2ZXMgYmV0dGVyIHRoYW4gYSBjb25zdGFudCBtaW5pbXVtIHdpZHRoIHdoaWNoIGRpc2FsbG93cyBuYXJyb3dlciBvcHRpb25zLFxuICAgIC8vIG9yIGFuIGluZGVudCB0aHJlc2hvbGQgd2hpY2ggY2F1c2VzIHRoZSB3aWR0aCB0byBzdWRkZW5seSBpbmNyZWFzZS5cbiAgICB2YXIgbGluZVdpZHRoID0gc3RhdGUubGluZVdpZHRoID09PSAtMVxuICAgICAgPyAtMSA6IE1hdGgubWF4KE1hdGgubWluKHN0YXRlLmxpbmVXaWR0aCwgNDApLCBzdGF0ZS5saW5lV2lkdGggLSBpbmRlbnQpO1xuXG4gICAgLy8gV2l0aG91dCBrbm93aW5nIGlmIGtleXMgYXJlIGltcGxpY2l0L2V4cGxpY2l0LCBhc3N1bWUgaW1wbGljaXQgZm9yIHNhZmV0eS5cbiAgICB2YXIgc2luZ2xlTGluZU9ubHkgPSBpc2tleVxuICAgICAgLy8gTm8gYmxvY2sgc3R5bGVzIGluIGZsb3cgbW9kZS5cbiAgICAgIHx8IChzdGF0ZS5mbG93TGV2ZWwgPiAtMSAmJiBsZXZlbCA+PSBzdGF0ZS5mbG93TGV2ZWwpO1xuICAgIGZ1bmN0aW9uIHRlc3RBbWJpZ3VpdHkoc3RyaW5nKSB7XG4gICAgICByZXR1cm4gdGVzdEltcGxpY2l0UmVzb2x2aW5nKHN0YXRlLCBzdHJpbmcpO1xuICAgIH1cblxuICAgIHN3aXRjaCAoY2hvb3NlU2NhbGFyU3R5bGUoc3RyaW5nLCBzaW5nbGVMaW5lT25seSwgc3RhdGUuaW5kZW50LCBsaW5lV2lkdGgsIHRlc3RBbWJpZ3VpdHkpKSB7XG4gICAgICBjYXNlIFNUWUxFX1BMQUlOOlxuICAgICAgICByZXR1cm4gc3RyaW5nO1xuICAgICAgY2FzZSBTVFlMRV9TSU5HTEU6XG4gICAgICAgIHJldHVybiBcIidcIiArIHN0cmluZy5yZXBsYWNlKC8nL2csIFwiJydcIikgKyBcIidcIjtcbiAgICAgIGNhc2UgU1RZTEVfTElURVJBTDpcbiAgICAgICAgcmV0dXJuICd8JyArIGJsb2NrSGVhZGVyKHN0cmluZywgc3RhdGUuaW5kZW50KVxuICAgICAgICAgICsgZHJvcEVuZGluZ05ld2xpbmUoaW5kZW50U3RyaW5nKHN0cmluZywgaW5kZW50KSk7XG4gICAgICBjYXNlIFNUWUxFX0ZPTERFRDpcbiAgICAgICAgcmV0dXJuICc+JyArIGJsb2NrSGVhZGVyKHN0cmluZywgc3RhdGUuaW5kZW50KVxuICAgICAgICAgICsgZHJvcEVuZGluZ05ld2xpbmUoaW5kZW50U3RyaW5nKGZvbGRTdHJpbmcoc3RyaW5nLCBsaW5lV2lkdGgpLCBpbmRlbnQpKTtcbiAgICAgIGNhc2UgU1RZTEVfRE9VQkxFOlxuICAgICAgICByZXR1cm4gJ1wiJyArIGVzY2FwZVN0cmluZyhzdHJpbmcsIGxpbmVXaWR0aCkgKyAnXCInO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhyb3cgbmV3IFlBTUxFeGNlcHRpb24oJ2ltcG9zc2libGUgZXJyb3I6IGludmFsaWQgc2NhbGFyIHN0eWxlJyk7XG4gICAgfVxuICB9KCkpO1xufVxuXG4vLyBQcmUtY29uZGl0aW9uczogc3RyaW5nIGlzIHZhbGlkIGZvciBhIGJsb2NrIHNjYWxhciwgMSA8PSBpbmRlbnRQZXJMZXZlbCA8PSA5LlxuZnVuY3Rpb24gYmxvY2tIZWFkZXIoc3RyaW5nLCBpbmRlbnRQZXJMZXZlbCkge1xuICB2YXIgaW5kZW50SW5kaWNhdG9yID0gKHN0cmluZ1swXSA9PT0gJyAnKSA/IFN0cmluZyhpbmRlbnRQZXJMZXZlbCkgOiAnJztcblxuICAvLyBub3RlIHRoZSBzcGVjaWFsIGNhc2U6IHRoZSBzdHJpbmcgJ1xcbicgY291bnRzIGFzIGEgXCJ0cmFpbGluZ1wiIGVtcHR5IGxpbmUuXG4gIHZhciBjbGlwID0gICAgICAgICAgc3RyaW5nW3N0cmluZy5sZW5ndGggLSAxXSA9PT0gJ1xcbic7XG4gIHZhciBrZWVwID0gY2xpcCAmJiAoc3RyaW5nW3N0cmluZy5sZW5ndGggLSAyXSA9PT0gJ1xcbicgfHwgc3RyaW5nID09PSAnXFxuJyk7XG4gIHZhciBjaG9tcCA9IGtlZXAgPyAnKycgOiAoY2xpcCA/ICcnIDogJy0nKTtcblxuICByZXR1cm4gaW5kZW50SW5kaWNhdG9yICsgY2hvbXAgKyAnXFxuJztcbn1cblxuLy8gKFNlZSB0aGUgbm90ZSBmb3Igd3JpdGVTY2FsYXIuKVxuZnVuY3Rpb24gZHJvcEVuZGluZ05ld2xpbmUoc3RyaW5nKSB7XG4gIHJldHVybiBzdHJpbmdbc3RyaW5nLmxlbmd0aCAtIDFdID09PSAnXFxuJyA/IHN0cmluZy5zbGljZSgwLCAtMSkgOiBzdHJpbmc7XG59XG5cbi8vIE5vdGU6IGEgbG9uZyBsaW5lIHdpdGhvdXQgYSBzdWl0YWJsZSBicmVhayBwb2ludCB3aWxsIGV4Y2VlZCB0aGUgd2lkdGggbGltaXQuXG4vLyBQcmUtY29uZGl0aW9uczogZXZlcnkgY2hhciBpbiBzdHIgaXNQcmludGFibGUsIHN0ci5sZW5ndGggPiAwLCB3aWR0aCA+IDAuXG5mdW5jdGlvbiBmb2xkU3RyaW5nKHN0cmluZywgd2lkdGgpIHtcbiAgLy8gSW4gZm9sZGVkIHN0eWxlLCAkayQgY29uc2VjdXRpdmUgbmV3bGluZXMgb3V0cHV0IGFzICRrKzEkIG5ld2xpbmVz4oCUXG4gIC8vIHVubGVzcyB0aGV5J3JlIGJlZm9yZSBvciBhZnRlciBhIG1vcmUtaW5kZW50ZWQgbGluZSwgb3IgYXQgdGhlIHZlcnlcbiAgLy8gYmVnaW5uaW5nIG9yIGVuZCwgaW4gd2hpY2ggY2FzZSAkayQgbWFwcyB0byAkayQuXG4gIC8vIFRoZXJlZm9yZSwgcGFyc2UgZWFjaCBjaHVuayBhcyBuZXdsaW5lKHMpIGZvbGxvd2VkIGJ5IGEgY29udGVudCBsaW5lLlxuICB2YXIgbGluZVJlID0gLyhcXG4rKShbXlxcbl0qKS9nO1xuXG4gIC8vIGZpcnN0IGxpbmUgKHBvc3NpYmx5IGFuIGVtcHR5IGxpbmUpXG4gIHZhciByZXN1bHQgPSAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBuZXh0TEYgPSBzdHJpbmcuaW5kZXhPZignXFxuJyk7XG4gICAgbmV4dExGID0gbmV4dExGICE9PSAtMSA/IG5leHRMRiA6IHN0cmluZy5sZW5ndGg7XG4gICAgbGluZVJlLmxhc3RJbmRleCA9IG5leHRMRjtcbiAgICByZXR1cm4gZm9sZExpbmUoc3RyaW5nLnNsaWNlKDAsIG5leHRMRiksIHdpZHRoKTtcbiAgfSgpKTtcbiAgLy8gSWYgd2UgaGF2ZW4ndCByZWFjaGVkIHRoZSBmaXJzdCBjb250ZW50IGxpbmUgeWV0LCBkb24ndCBhZGQgYW4gZXh0cmEgXFxuLlxuICB2YXIgcHJldk1vcmVJbmRlbnRlZCA9IHN0cmluZ1swXSA9PT0gJ1xcbicgfHwgc3RyaW5nWzBdID09PSAnICc7XG4gIHZhciBtb3JlSW5kZW50ZWQ7XG5cbiAgLy8gcmVzdCBvZiB0aGUgbGluZXNcbiAgdmFyIG1hdGNoO1xuICB3aGlsZSAoKG1hdGNoID0gbGluZVJlLmV4ZWMoc3RyaW5nKSkpIHtcbiAgICB2YXIgcHJlZml4ID0gbWF0Y2hbMV0sIGxpbmUgPSBtYXRjaFsyXTtcbiAgICBtb3JlSW5kZW50ZWQgPSAobGluZVswXSA9PT0gJyAnKTtcbiAgICByZXN1bHQgKz0gcHJlZml4XG4gICAgICArICghcHJldk1vcmVJbmRlbnRlZCAmJiAhbW9yZUluZGVudGVkICYmIGxpbmUgIT09ICcnXG4gICAgICAgID8gJ1xcbicgOiAnJylcbiAgICAgICsgZm9sZExpbmUobGluZSwgd2lkdGgpO1xuICAgIHByZXZNb3JlSW5kZW50ZWQgPSBtb3JlSW5kZW50ZWQ7XG4gIH1cblxuICByZXR1cm4gcmVzdWx0O1xufVxuXG4vLyBHcmVlZHkgbGluZSBicmVha2luZy5cbi8vIFBpY2tzIHRoZSBsb25nZXN0IGxpbmUgdW5kZXIgdGhlIGxpbWl0IGVhY2ggdGltZSxcbi8vIG90aGVyd2lzZSBzZXR0bGVzIGZvciB0aGUgc2hvcnRlc3QgbGluZSBvdmVyIHRoZSBsaW1pdC5cbi8vIE5CLiBNb3JlLWluZGVudGVkIGxpbmVzICpjYW5ub3QqIGJlIGZvbGRlZCwgYXMgdGhhdCB3b3VsZCBhZGQgYW4gZXh0cmEgXFxuLlxuZnVuY3Rpb24gZm9sZExpbmUobGluZSwgd2lkdGgpIHtcbiAgaWYgKGxpbmUgPT09ICcnIHx8IGxpbmVbMF0gPT09ICcgJykgcmV0dXJuIGxpbmU7XG5cbiAgLy8gU2luY2UgYSBtb3JlLWluZGVudGVkIGxpbmUgYWRkcyBhIFxcbiwgYnJlYWtzIGNhbid0IGJlIGZvbGxvd2VkIGJ5IGEgc3BhY2UuXG4gIHZhciBicmVha1JlID0gLyBbXiBdL2c7IC8vIG5vdGU6IHRoZSBtYXRjaCBpbmRleCB3aWxsIGFsd2F5cyBiZSA8PSBsZW5ndGgtMi5cbiAgdmFyIG1hdGNoO1xuICAvLyBzdGFydCBpcyBhbiBpbmNsdXNpdmUgaW5kZXguIGVuZCwgY3VyciwgYW5kIG5leHQgYXJlIGV4Y2x1c2l2ZS5cbiAgdmFyIHN0YXJ0ID0gMCwgZW5kLCBjdXJyID0gMCwgbmV4dCA9IDA7XG4gIHZhciByZXN1bHQgPSAnJztcblxuICAvLyBJbnZhcmlhbnRzOiAwIDw9IHN0YXJ0IDw9IGxlbmd0aC0xLlxuICAvLyAgIDAgPD0gY3VyciA8PSBuZXh0IDw9IG1heCgwLCBsZW5ndGgtMikuIGN1cnIgLSBzdGFydCA8PSB3aWR0aC5cbiAgLy8gSW5zaWRlIHRoZSBsb29wOlxuICAvLyAgIEEgbWF0Y2ggaW1wbGllcyBsZW5ndGggPj0gMiwgc28gY3VyciBhbmQgbmV4dCBhcmUgPD0gbGVuZ3RoLTIuXG4gIHdoaWxlICgobWF0Y2ggPSBicmVha1JlLmV4ZWMobGluZSkpKSB7XG4gICAgbmV4dCA9IG1hdGNoLmluZGV4O1xuICAgIC8vIG1haW50YWluIGludmFyaWFudDogY3VyciAtIHN0YXJ0IDw9IHdpZHRoXG4gICAgaWYgKG5leHQgLSBzdGFydCA+IHdpZHRoKSB7XG4gICAgICBlbmQgPSAoY3VyciA+IHN0YXJ0KSA/IGN1cnIgOiBuZXh0OyAvLyBkZXJpdmUgZW5kIDw9IGxlbmd0aC0yXG4gICAgICByZXN1bHQgKz0gJ1xcbicgKyBsaW5lLnNsaWNlKHN0YXJ0LCBlbmQpO1xuICAgICAgLy8gc2tpcCB0aGUgc3BhY2UgdGhhdCB3YXMgb3V0cHV0IGFzIFxcblxuICAgICAgc3RhcnQgPSBlbmQgKyAxOyAgICAgICAgICAgICAgICAgICAgLy8gZGVyaXZlIHN0YXJ0IDw9IGxlbmd0aC0xXG4gICAgfVxuICAgIGN1cnIgPSBuZXh0O1xuICB9XG5cbiAgLy8gQnkgdGhlIGludmFyaWFudHMsIHN0YXJ0IDw9IGxlbmd0aC0xLCBzbyB0aGVyZSBpcyBzb21ldGhpbmcgbGVmdCBvdmVyLlxuICAvLyBJdCBpcyBlaXRoZXIgdGhlIHdob2xlIHN0cmluZyBvciBhIHBhcnQgc3RhcnRpbmcgZnJvbSBub24td2hpdGVzcGFjZS5cbiAgcmVzdWx0ICs9ICdcXG4nO1xuICAvLyBJbnNlcnQgYSBicmVhayBpZiB0aGUgcmVtYWluZGVyIGlzIHRvbyBsb25nIGFuZCB0aGVyZSBpcyBhIGJyZWFrIGF2YWlsYWJsZS5cbiAgaWYgKGxpbmUubGVuZ3RoIC0gc3RhcnQgPiB3aWR0aCAmJiBjdXJyID4gc3RhcnQpIHtcbiAgICByZXN1bHQgKz0gbGluZS5zbGljZShzdGFydCwgY3VycikgKyAnXFxuJyArIGxpbmUuc2xpY2UoY3VyciArIDEpO1xuICB9IGVsc2Uge1xuICAgIHJlc3VsdCArPSBsaW5lLnNsaWNlKHN0YXJ0KTtcbiAgfVxuXG4gIHJldHVybiByZXN1bHQuc2xpY2UoMSk7IC8vIGRyb3AgZXh0cmEgXFxuIGpvaW5lclxufVxuXG4vLyBFc2NhcGVzIGEgZG91YmxlLXF1b3RlZCBzdHJpbmcuXG5mdW5jdGlvbiBlc2NhcGVTdHJpbmcoc3RyaW5nKSB7XG4gIHZhciByZXN1bHQgPSAnJztcbiAgdmFyIGNoYXIsIG5leHRDaGFyO1xuICB2YXIgZXNjYXBlU2VxO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgc3RyaW5nLmxlbmd0aDsgaSsrKSB7XG4gICAgY2hhciA9IHN0cmluZy5jaGFyQ29kZUF0KGkpO1xuICAgIC8vIENoZWNrIGZvciBzdXJyb2dhdGUgcGFpcnMgKHJlZmVyZW5jZSBVbmljb2RlIDMuMCBzZWN0aW9uIFwiMy43IFN1cnJvZ2F0ZXNcIikuXG4gICAgaWYgKGNoYXIgPj0gMHhEODAwICYmIGNoYXIgPD0gMHhEQkZGLyogaGlnaCBzdXJyb2dhdGUgKi8pIHtcbiAgICAgIG5leHRDaGFyID0gc3RyaW5nLmNoYXJDb2RlQXQoaSArIDEpO1xuICAgICAgaWYgKG5leHRDaGFyID49IDB4REMwMCAmJiBuZXh0Q2hhciA8PSAweERGRkYvKiBsb3cgc3Vycm9nYXRlICovKSB7XG4gICAgICAgIC8vIENvbWJpbmUgdGhlIHN1cnJvZ2F0ZSBwYWlyIGFuZCBzdG9yZSBpdCBlc2NhcGVkLlxuICAgICAgICByZXN1bHQgKz0gZW5jb2RlSGV4KChjaGFyIC0gMHhEODAwKSAqIDB4NDAwICsgbmV4dENoYXIgLSAweERDMDAgKyAweDEwMDAwKTtcbiAgICAgICAgLy8gQWR2YW5jZSBpbmRleCBvbmUgZXh0cmEgc2luY2Ugd2UgYWxyZWFkeSB1c2VkIHRoYXQgY2hhciBoZXJlLlxuICAgICAgICBpKys7IGNvbnRpbnVlO1xuICAgICAgfVxuICAgIH1cbiAgICBlc2NhcGVTZXEgPSBFU0NBUEVfU0VRVUVOQ0VTW2NoYXJdO1xuICAgIHJlc3VsdCArPSAhZXNjYXBlU2VxICYmIGlzUHJpbnRhYmxlKGNoYXIpXG4gICAgICA/IHN0cmluZ1tpXVxuICAgICAgOiBlc2NhcGVTZXEgfHwgZW5jb2RlSGV4KGNoYXIpO1xuICB9XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuZnVuY3Rpb24gd3JpdGVGbG93U2VxdWVuY2Uoc3RhdGUsIGxldmVsLCBvYmplY3QpIHtcbiAgdmFyIF9yZXN1bHQgPSAnJyxcbiAgICAgIF90YWcgICAgPSBzdGF0ZS50YWcsXG4gICAgICBpbmRleCxcbiAgICAgIGxlbmd0aDtcblxuICBmb3IgKGluZGV4ID0gMCwgbGVuZ3RoID0gb2JqZWN0Lmxlbmd0aDsgaW5kZXggPCBsZW5ndGg7IGluZGV4ICs9IDEpIHtcbiAgICAvLyBXcml0ZSBvbmx5IHZhbGlkIGVsZW1lbnRzLlxuICAgIGlmICh3cml0ZU5vZGUoc3RhdGUsIGxldmVsLCBvYmplY3RbaW5kZXhdLCBmYWxzZSwgZmFsc2UpKSB7XG4gICAgICBpZiAoaW5kZXggIT09IDApIF9yZXN1bHQgKz0gJywnICsgKCFzdGF0ZS5jb25kZW5zZUZsb3cgPyAnICcgOiAnJyk7XG4gICAgICBfcmVzdWx0ICs9IHN0YXRlLmR1bXA7XG4gICAgfVxuICB9XG5cbiAgc3RhdGUudGFnID0gX3RhZztcbiAgc3RhdGUuZHVtcCA9ICdbJyArIF9yZXN1bHQgKyAnXSc7XG59XG5cbmZ1bmN0aW9uIHdyaXRlQmxvY2tTZXF1ZW5jZShzdGF0ZSwgbGV2ZWwsIG9iamVjdCwgY29tcGFjdCkge1xuICB2YXIgX3Jlc3VsdCA9ICcnLFxuICAgICAgX3RhZyAgICA9IHN0YXRlLnRhZyxcbiAgICAgIGluZGV4LFxuICAgICAgbGVuZ3RoO1xuXG4gIGZvciAoaW5kZXggPSAwLCBsZW5ndGggPSBvYmplY3QubGVuZ3RoOyBpbmRleCA8IGxlbmd0aDsgaW5kZXggKz0gMSkge1xuICAgIC8vIFdyaXRlIG9ubHkgdmFsaWQgZWxlbWVudHMuXG4gICAgaWYgKHdyaXRlTm9kZShzdGF0ZSwgbGV2ZWwgKyAxLCBvYmplY3RbaW5kZXhdLCB0cnVlLCB0cnVlKSkge1xuICAgICAgaWYgKCFjb21wYWN0IHx8IGluZGV4ICE9PSAwKSB7XG4gICAgICAgIF9yZXN1bHQgKz0gZ2VuZXJhdGVOZXh0TGluZShzdGF0ZSwgbGV2ZWwpO1xuICAgICAgfVxuXG4gICAgICBpZiAoc3RhdGUuZHVtcCAmJiBDSEFSX0xJTkVfRkVFRCA9PT0gc3RhdGUuZHVtcC5jaGFyQ29kZUF0KDApKSB7XG4gICAgICAgIF9yZXN1bHQgKz0gJy0nO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgX3Jlc3VsdCArPSAnLSAnO1xuICAgICAgfVxuXG4gICAgICBfcmVzdWx0ICs9IHN0YXRlLmR1bXA7XG4gICAgfVxuICB9XG5cbiAgc3RhdGUudGFnID0gX3RhZztcbiAgc3RhdGUuZHVtcCA9IF9yZXN1bHQgfHwgJ1tdJzsgLy8gRW1wdHkgc2VxdWVuY2UgaWYgbm8gdmFsaWQgdmFsdWVzLlxufVxuXG5mdW5jdGlvbiB3cml0ZUZsb3dNYXBwaW5nKHN0YXRlLCBsZXZlbCwgb2JqZWN0KSB7XG4gIHZhciBfcmVzdWx0ICAgICAgID0gJycsXG4gICAgICBfdGFnICAgICAgICAgID0gc3RhdGUudGFnLFxuICAgICAgb2JqZWN0S2V5TGlzdCA9IE9iamVjdC5rZXlzKG9iamVjdCksXG4gICAgICBpbmRleCxcbiAgICAgIGxlbmd0aCxcbiAgICAgIG9iamVjdEtleSxcbiAgICAgIG9iamVjdFZhbHVlLFxuICAgICAgcGFpckJ1ZmZlcjtcblxuICBmb3IgKGluZGV4ID0gMCwgbGVuZ3RoID0gb2JqZWN0S2V5TGlzdC5sZW5ndGg7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCArPSAxKSB7XG4gICAgcGFpckJ1ZmZlciA9IHN0YXRlLmNvbmRlbnNlRmxvdyA/ICdcIicgOiAnJztcblxuICAgIGlmIChpbmRleCAhPT0gMCkgcGFpckJ1ZmZlciArPSAnLCAnO1xuXG4gICAgb2JqZWN0S2V5ID0gb2JqZWN0S2V5TGlzdFtpbmRleF07XG4gICAgb2JqZWN0VmFsdWUgPSBvYmplY3Rbb2JqZWN0S2V5XTtcblxuICAgIGlmICghd3JpdGVOb2RlKHN0YXRlLCBsZXZlbCwgb2JqZWN0S2V5LCBmYWxzZSwgZmFsc2UpKSB7XG4gICAgICBjb250aW51ZTsgLy8gU2tpcCB0aGlzIHBhaXIgYmVjYXVzZSBvZiBpbnZhbGlkIGtleTtcbiAgICB9XG5cbiAgICBpZiAoc3RhdGUuZHVtcC5sZW5ndGggPiAxMDI0KSBwYWlyQnVmZmVyICs9ICc/ICc7XG5cbiAgICBwYWlyQnVmZmVyICs9IHN0YXRlLmR1bXAgKyAoc3RhdGUuY29uZGVuc2VGbG93ID8gJ1wiJyA6ICcnKSArICc6JyArIChzdGF0ZS5jb25kZW5zZUZsb3cgPyAnJyA6ICcgJyk7XG5cbiAgICBpZiAoIXdyaXRlTm9kZShzdGF0ZSwgbGV2ZWwsIG9iamVjdFZhbHVlLCBmYWxzZSwgZmFsc2UpKSB7XG4gICAgICBjb250aW51ZTsgLy8gU2tpcCB0aGlzIHBhaXIgYmVjYXVzZSBvZiBpbnZhbGlkIHZhbHVlLlxuICAgIH1cblxuICAgIHBhaXJCdWZmZXIgKz0gc3RhdGUuZHVtcDtcblxuICAgIC8vIEJvdGgga2V5IGFuZCB2YWx1ZSBhcmUgdmFsaWQuXG4gICAgX3Jlc3VsdCArPSBwYWlyQnVmZmVyO1xuICB9XG5cbiAgc3RhdGUudGFnID0gX3RhZztcbiAgc3RhdGUuZHVtcCA9ICd7JyArIF9yZXN1bHQgKyAnfSc7XG59XG5cbmZ1bmN0aW9uIHdyaXRlQmxvY2tNYXBwaW5nKHN0YXRlLCBsZXZlbCwgb2JqZWN0LCBjb21wYWN0KSB7XG4gIHZhciBfcmVzdWx0ICAgICAgID0gJycsXG4gICAgICBfdGFnICAgICAgICAgID0gc3RhdGUudGFnLFxuICAgICAgb2JqZWN0S2V5TGlzdCA9IE9iamVjdC5rZXlzKG9iamVjdCksXG4gICAgICBpbmRleCxcbiAgICAgIGxlbmd0aCxcbiAgICAgIG9iamVjdEtleSxcbiAgICAgIG9iamVjdFZhbHVlLFxuICAgICAgZXhwbGljaXRQYWlyLFxuICAgICAgcGFpckJ1ZmZlcjtcblxuICAvLyBBbGxvdyBzb3J0aW5nIGtleXMgc28gdGhhdCB0aGUgb3V0cHV0IGZpbGUgaXMgZGV0ZXJtaW5pc3RpY1xuICBpZiAoc3RhdGUuc29ydEtleXMgPT09IHRydWUpIHtcbiAgICAvLyBEZWZhdWx0IHNvcnRpbmdcbiAgICBvYmplY3RLZXlMaXN0LnNvcnQoKTtcbiAgfSBlbHNlIGlmICh0eXBlb2Ygc3RhdGUuc29ydEtleXMgPT09ICdmdW5jdGlvbicpIHtcbiAgICAvLyBDdXN0b20gc29ydCBmdW5jdGlvblxuICAgIG9iamVjdEtleUxpc3Quc29ydChzdGF0ZS5zb3J0S2V5cyk7XG4gIH0gZWxzZSBpZiAoc3RhdGUuc29ydEtleXMpIHtcbiAgICAvLyBTb21ldGhpbmcgaXMgd3JvbmdcbiAgICB0aHJvdyBuZXcgWUFNTEV4Y2VwdGlvbignc29ydEtleXMgbXVzdCBiZSBhIGJvb2xlYW4gb3IgYSBmdW5jdGlvbicpO1xuICB9XG5cbiAgZm9yIChpbmRleCA9IDAsIGxlbmd0aCA9IG9iamVjdEtleUxpc3QubGVuZ3RoOyBpbmRleCA8IGxlbmd0aDsgaW5kZXggKz0gMSkge1xuICAgIHBhaXJCdWZmZXIgPSAnJztcblxuICAgIGlmICghY29tcGFjdCB8fCBpbmRleCAhPT0gMCkge1xuICAgICAgcGFpckJ1ZmZlciArPSBnZW5lcmF0ZU5leHRMaW5lKHN0YXRlLCBsZXZlbCk7XG4gICAgfVxuXG4gICAgb2JqZWN0S2V5ID0gb2JqZWN0S2V5TGlzdFtpbmRleF07XG4gICAgb2JqZWN0VmFsdWUgPSBvYmplY3Rbb2JqZWN0S2V5XTtcblxuICAgIGlmICghd3JpdGVOb2RlKHN0YXRlLCBsZXZlbCArIDEsIG9iamVjdEtleSwgdHJ1ZSwgdHJ1ZSwgdHJ1ZSkpIHtcbiAgICAgIGNvbnRpbnVlOyAvLyBTa2lwIHRoaXMgcGFpciBiZWNhdXNlIG9mIGludmFsaWQga2V5LlxuICAgIH1cblxuICAgIGV4cGxpY2l0UGFpciA9IChzdGF0ZS50YWcgIT09IG51bGwgJiYgc3RhdGUudGFnICE9PSAnPycpIHx8XG4gICAgICAgICAgICAgICAgICAgKHN0YXRlLmR1bXAgJiYgc3RhdGUuZHVtcC5sZW5ndGggPiAxMDI0KTtcblxuICAgIGlmIChleHBsaWNpdFBhaXIpIHtcbiAgICAgIGlmIChzdGF0ZS5kdW1wICYmIENIQVJfTElORV9GRUVEID09PSBzdGF0ZS5kdW1wLmNoYXJDb2RlQXQoMCkpIHtcbiAgICAgICAgcGFpckJ1ZmZlciArPSAnPyc7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwYWlyQnVmZmVyICs9ICc/ICc7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcGFpckJ1ZmZlciArPSBzdGF0ZS5kdW1wO1xuXG4gICAgaWYgKGV4cGxpY2l0UGFpcikge1xuICAgICAgcGFpckJ1ZmZlciArPSBnZW5lcmF0ZU5leHRMaW5lKHN0YXRlLCBsZXZlbCk7XG4gICAgfVxuXG4gICAgaWYgKCF3cml0ZU5vZGUoc3RhdGUsIGxldmVsICsgMSwgb2JqZWN0VmFsdWUsIHRydWUsIGV4cGxpY2l0UGFpcikpIHtcbiAgICAgIGNvbnRpbnVlOyAvLyBTa2lwIHRoaXMgcGFpciBiZWNhdXNlIG9mIGludmFsaWQgdmFsdWUuXG4gICAgfVxuXG4gICAgaWYgKHN0YXRlLmR1bXAgJiYgQ0hBUl9MSU5FX0ZFRUQgPT09IHN0YXRlLmR1bXAuY2hhckNvZGVBdCgwKSkge1xuICAgICAgcGFpckJ1ZmZlciArPSAnOic7XG4gICAgfSBlbHNlIHtcbiAgICAgIHBhaXJCdWZmZXIgKz0gJzogJztcbiAgICB9XG5cbiAgICBwYWlyQnVmZmVyICs9IHN0YXRlLmR1bXA7XG5cbiAgICAvLyBCb3RoIGtleSBhbmQgdmFsdWUgYXJlIHZhbGlkLlxuICAgIF9yZXN1bHQgKz0gcGFpckJ1ZmZlcjtcbiAgfVxuXG4gIHN0YXRlLnRhZyA9IF90YWc7XG4gIHN0YXRlLmR1bXAgPSBfcmVzdWx0IHx8ICd7fSc7IC8vIEVtcHR5IG1hcHBpbmcgaWYgbm8gdmFsaWQgcGFpcnMuXG59XG5cbmZ1bmN0aW9uIGRldGVjdFR5cGUoc3RhdGUsIG9iamVjdCwgZXhwbGljaXQpIHtcbiAgdmFyIF9yZXN1bHQsIHR5cGVMaXN0LCBpbmRleCwgbGVuZ3RoLCB0eXBlLCBzdHlsZTtcblxuICB0eXBlTGlzdCA9IGV4cGxpY2l0ID8gc3RhdGUuZXhwbGljaXRUeXBlcyA6IHN0YXRlLmltcGxpY2l0VHlwZXM7XG5cbiAgZm9yIChpbmRleCA9IDAsIGxlbmd0aCA9IHR5cGVMaXN0Lmxlbmd0aDsgaW5kZXggPCBsZW5ndGg7IGluZGV4ICs9IDEpIHtcbiAgICB0eXBlID0gdHlwZUxpc3RbaW5kZXhdO1xuXG4gICAgaWYgKCh0eXBlLmluc3RhbmNlT2YgIHx8IHR5cGUucHJlZGljYXRlKSAmJlxuICAgICAgICAoIXR5cGUuaW5zdGFuY2VPZiB8fCAoKHR5cGVvZiBvYmplY3QgPT09ICdvYmplY3QnKSAmJiAob2JqZWN0IGluc3RhbmNlb2YgdHlwZS5pbnN0YW5jZU9mKSkpICYmXG4gICAgICAgICghdHlwZS5wcmVkaWNhdGUgIHx8IHR5cGUucHJlZGljYXRlKG9iamVjdCkpKSB7XG5cbiAgICAgIHN0YXRlLnRhZyA9IGV4cGxpY2l0ID8gdHlwZS50YWcgOiAnPyc7XG5cbiAgICAgIGlmICh0eXBlLnJlcHJlc2VudCkge1xuICAgICAgICBzdHlsZSA9IHN0YXRlLnN0eWxlTWFwW3R5cGUudGFnXSB8fCB0eXBlLmRlZmF1bHRTdHlsZTtcblxuICAgICAgICBpZiAoX3RvU3RyaW5nLmNhbGwodHlwZS5yZXByZXNlbnQpID09PSAnW29iamVjdCBGdW5jdGlvbl0nKSB7XG4gICAgICAgICAgX3Jlc3VsdCA9IHR5cGUucmVwcmVzZW50KG9iamVjdCwgc3R5bGUpO1xuICAgICAgICB9IGVsc2UgaWYgKF9oYXNPd25Qcm9wZXJ0eS5jYWxsKHR5cGUucmVwcmVzZW50LCBzdHlsZSkpIHtcbiAgICAgICAgICBfcmVzdWx0ID0gdHlwZS5yZXByZXNlbnRbc3R5bGVdKG9iamVjdCwgc3R5bGUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRocm93IG5ldyBZQU1MRXhjZXB0aW9uKCchPCcgKyB0eXBlLnRhZyArICc+IHRhZyByZXNvbHZlciBhY2NlcHRzIG5vdCBcIicgKyBzdHlsZSArICdcIiBzdHlsZScpO1xuICAgICAgICB9XG5cbiAgICAgICAgc3RhdGUuZHVtcCA9IF9yZXN1bHQ7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxuLy8gU2VyaWFsaXplcyBgb2JqZWN0YCBhbmQgd3JpdGVzIGl0IHRvIGdsb2JhbCBgcmVzdWx0YC5cbi8vIFJldHVybnMgdHJ1ZSBvbiBzdWNjZXNzLCBvciBmYWxzZSBvbiBpbnZhbGlkIG9iamVjdC5cbi8vXG5mdW5jdGlvbiB3cml0ZU5vZGUoc3RhdGUsIGxldmVsLCBvYmplY3QsIGJsb2NrLCBjb21wYWN0LCBpc2tleSkge1xuICBzdGF0ZS50YWcgPSBudWxsO1xuICBzdGF0ZS5kdW1wID0gb2JqZWN0O1xuXG4gIGlmICghZGV0ZWN0VHlwZShzdGF0ZSwgb2JqZWN0LCBmYWxzZSkpIHtcbiAgICBkZXRlY3RUeXBlKHN0YXRlLCBvYmplY3QsIHRydWUpO1xuICB9XG5cbiAgdmFyIHR5cGUgPSBfdG9TdHJpbmcuY2FsbChzdGF0ZS5kdW1wKTtcblxuICBpZiAoYmxvY2spIHtcbiAgICBibG9jayA9IChzdGF0ZS5mbG93TGV2ZWwgPCAwIHx8IHN0YXRlLmZsb3dMZXZlbCA+IGxldmVsKTtcbiAgfVxuXG4gIHZhciBvYmplY3RPckFycmF5ID0gdHlwZSA9PT0gJ1tvYmplY3QgT2JqZWN0XScgfHwgdHlwZSA9PT0gJ1tvYmplY3QgQXJyYXldJyxcbiAgICAgIGR1cGxpY2F0ZUluZGV4LFxuICAgICAgZHVwbGljYXRlO1xuXG4gIGlmIChvYmplY3RPckFycmF5KSB7XG4gICAgZHVwbGljYXRlSW5kZXggPSBzdGF0ZS5kdXBsaWNhdGVzLmluZGV4T2Yob2JqZWN0KTtcbiAgICBkdXBsaWNhdGUgPSBkdXBsaWNhdGVJbmRleCAhPT0gLTE7XG4gIH1cblxuICBpZiAoKHN0YXRlLnRhZyAhPT0gbnVsbCAmJiBzdGF0ZS50YWcgIT09ICc/JykgfHwgZHVwbGljYXRlIHx8IChzdGF0ZS5pbmRlbnQgIT09IDIgJiYgbGV2ZWwgPiAwKSkge1xuICAgIGNvbXBhY3QgPSBmYWxzZTtcbiAgfVxuXG4gIGlmIChkdXBsaWNhdGUgJiYgc3RhdGUudXNlZER1cGxpY2F0ZXNbZHVwbGljYXRlSW5kZXhdKSB7XG4gICAgc3RhdGUuZHVtcCA9ICcqcmVmXycgKyBkdXBsaWNhdGVJbmRleDtcbiAgfSBlbHNlIHtcbiAgICBpZiAob2JqZWN0T3JBcnJheSAmJiBkdXBsaWNhdGUgJiYgIXN0YXRlLnVzZWREdXBsaWNhdGVzW2R1cGxpY2F0ZUluZGV4XSkge1xuICAgICAgc3RhdGUudXNlZER1cGxpY2F0ZXNbZHVwbGljYXRlSW5kZXhdID0gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKHR5cGUgPT09ICdbb2JqZWN0IE9iamVjdF0nKSB7XG4gICAgICBpZiAoYmxvY2sgJiYgKE9iamVjdC5rZXlzKHN0YXRlLmR1bXApLmxlbmd0aCAhPT0gMCkpIHtcbiAgICAgICAgd3JpdGVCbG9ja01hcHBpbmcoc3RhdGUsIGxldmVsLCBzdGF0ZS5kdW1wLCBjb21wYWN0KTtcbiAgICAgICAgaWYgKGR1cGxpY2F0ZSkge1xuICAgICAgICAgIHN0YXRlLmR1bXAgPSAnJnJlZl8nICsgZHVwbGljYXRlSW5kZXggKyBzdGF0ZS5kdW1wO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB3cml0ZUZsb3dNYXBwaW5nKHN0YXRlLCBsZXZlbCwgc3RhdGUuZHVtcCk7XG4gICAgICAgIGlmIChkdXBsaWNhdGUpIHtcbiAgICAgICAgICBzdGF0ZS5kdW1wID0gJyZyZWZfJyArIGR1cGxpY2F0ZUluZGV4ICsgJyAnICsgc3RhdGUuZHVtcDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gJ1tvYmplY3QgQXJyYXldJykge1xuICAgICAgaWYgKGJsb2NrICYmIChzdGF0ZS5kdW1wLmxlbmd0aCAhPT0gMCkpIHtcbiAgICAgICAgd3JpdGVCbG9ja1NlcXVlbmNlKHN0YXRlLCBsZXZlbCwgc3RhdGUuZHVtcCwgY29tcGFjdCk7XG4gICAgICAgIGlmIChkdXBsaWNhdGUpIHtcbiAgICAgICAgICBzdGF0ZS5kdW1wID0gJyZyZWZfJyArIGR1cGxpY2F0ZUluZGV4ICsgc3RhdGUuZHVtcDtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgd3JpdGVGbG93U2VxdWVuY2Uoc3RhdGUsIGxldmVsLCBzdGF0ZS5kdW1wKTtcbiAgICAgICAgaWYgKGR1cGxpY2F0ZSkge1xuICAgICAgICAgIHN0YXRlLmR1bXAgPSAnJnJlZl8nICsgZHVwbGljYXRlSW5kZXggKyAnICcgKyBzdGF0ZS5kdW1wO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICh0eXBlID09PSAnW29iamVjdCBTdHJpbmddJykge1xuICAgICAgaWYgKHN0YXRlLnRhZyAhPT0gJz8nKSB7XG4gICAgICAgIHdyaXRlU2NhbGFyKHN0YXRlLCBzdGF0ZS5kdW1wLCBsZXZlbCwgaXNrZXkpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoc3RhdGUuc2tpcEludmFsaWQpIHJldHVybiBmYWxzZTtcbiAgICAgIHRocm93IG5ldyBZQU1MRXhjZXB0aW9uKCd1bmFjY2VwdGFibGUga2luZCBvZiBhbiBvYmplY3QgdG8gZHVtcCAnICsgdHlwZSk7XG4gICAgfVxuXG4gICAgaWYgKHN0YXRlLnRhZyAhPT0gbnVsbCAmJiBzdGF0ZS50YWcgIT09ICc/Jykge1xuICAgICAgc3RhdGUuZHVtcCA9ICchPCcgKyBzdGF0ZS50YWcgKyAnPiAnICsgc3RhdGUuZHVtcDtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gZ2V0RHVwbGljYXRlUmVmZXJlbmNlcyhvYmplY3QsIHN0YXRlKSB7XG4gIHZhciBvYmplY3RzID0gW10sXG4gICAgICBkdXBsaWNhdGVzSW5kZXhlcyA9IFtdLFxuICAgICAgaW5kZXgsXG4gICAgICBsZW5ndGg7XG5cbiAgaW5zcGVjdE5vZGUob2JqZWN0LCBvYmplY3RzLCBkdXBsaWNhdGVzSW5kZXhlcyk7XG5cbiAgZm9yIChpbmRleCA9IDAsIGxlbmd0aCA9IGR1cGxpY2F0ZXNJbmRleGVzLmxlbmd0aDsgaW5kZXggPCBsZW5ndGg7IGluZGV4ICs9IDEpIHtcbiAgICBzdGF0ZS5kdXBsaWNhdGVzLnB1c2gob2JqZWN0c1tkdXBsaWNhdGVzSW5kZXhlc1tpbmRleF1dKTtcbiAgfVxuICBzdGF0ZS51c2VkRHVwbGljYXRlcyA9IG5ldyBBcnJheShsZW5ndGgpO1xufVxuXG5mdW5jdGlvbiBpbnNwZWN0Tm9kZShvYmplY3QsIG9iamVjdHMsIGR1cGxpY2F0ZXNJbmRleGVzKSB7XG4gIHZhciBvYmplY3RLZXlMaXN0LFxuICAgICAgaW5kZXgsXG4gICAgICBsZW5ndGg7XG5cbiAgaWYgKG9iamVjdCAhPT0gbnVsbCAmJiB0eXBlb2Ygb2JqZWN0ID09PSAnb2JqZWN0Jykge1xuICAgIGluZGV4ID0gb2JqZWN0cy5pbmRleE9mKG9iamVjdCk7XG4gICAgaWYgKGluZGV4ICE9PSAtMSkge1xuICAgICAgaWYgKGR1cGxpY2F0ZXNJbmRleGVzLmluZGV4T2YoaW5kZXgpID09PSAtMSkge1xuICAgICAgICBkdXBsaWNhdGVzSW5kZXhlcy5wdXNoKGluZGV4KTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgb2JqZWN0cy5wdXNoKG9iamVjdCk7XG5cbiAgICAgIGlmIChBcnJheS5pc0FycmF5KG9iamVjdCkpIHtcbiAgICAgICAgZm9yIChpbmRleCA9IDAsIGxlbmd0aCA9IG9iamVjdC5sZW5ndGg7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCArPSAxKSB7XG4gICAgICAgICAgaW5zcGVjdE5vZGUob2JqZWN0W2luZGV4XSwgb2JqZWN0cywgZHVwbGljYXRlc0luZGV4ZXMpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBvYmplY3RLZXlMaXN0ID0gT2JqZWN0LmtleXMob2JqZWN0KTtcblxuICAgICAgICBmb3IgKGluZGV4ID0gMCwgbGVuZ3RoID0gb2JqZWN0S2V5TGlzdC5sZW5ndGg7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCArPSAxKSB7XG4gICAgICAgICAgaW5zcGVjdE5vZGUob2JqZWN0W29iamVjdEtleUxpc3RbaW5kZXhdXSwgb2JqZWN0cywgZHVwbGljYXRlc0luZGV4ZXMpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGR1bXAoaW5wdXQsIG9wdGlvbnMpIHtcbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgdmFyIHN0YXRlID0gbmV3IFN0YXRlKG9wdGlvbnMpO1xuXG4gIGlmICghc3RhdGUubm9SZWZzKSBnZXREdXBsaWNhdGVSZWZlcmVuY2VzKGlucHV0LCBzdGF0ZSk7XG5cbiAgaWYgKHdyaXRlTm9kZShzdGF0ZSwgMCwgaW5wdXQsIHRydWUsIHRydWUpKSByZXR1cm4gc3RhdGUuZHVtcCArICdcXG4nO1xuXG4gIHJldHVybiAnJztcbn1cblxuZnVuY3Rpb24gc2FmZUR1bXAoaW5wdXQsIG9wdGlvbnMpIHtcbiAgcmV0dXJuIGR1bXAoaW5wdXQsIGNvbW1vbi5leHRlbmQoeyBzY2hlbWE6IERFRkFVTFRfU0FGRV9TQ0hFTUEgfSwgb3B0aW9ucykpO1xufVxuXG5tb2R1bGUuZXhwb3J0cy5kdW1wICAgICA9IGR1bXA7XG5tb2R1bGUuZXhwb3J0cy5zYWZlRHVtcCA9IHNhZmVEdW1wO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2pzLXlhbWwvbGliL2pzLXlhbWwvZHVtcGVyLmpzIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgIHZhbHVlOiB0cnVlXG59KTtcbmNsYXNzIExhenkge1xuICAgIGNvbnN0cnVjdG9yKGNyZWF0b3IpIHtcbiAgICAgICAgdGhpcy5jcmVhdG9yID0gY3JlYXRvcjtcbiAgICB9XG4gICAgZ2V0IGhhc1ZhbHVlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jcmVhdG9yID09IG51bGw7XG4gICAgfVxuICAgIGdldCB2YWx1ZSgpIHtcbiAgICAgICAgaWYgKHRoaXMuY3JlYXRvciA9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fdmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy52YWx1ZSA9IHRoaXMuY3JlYXRvcigpO1xuICAgICAgICByZXR1cm4gdGhpcy5fdmFsdWU7XG4gICAgfVxuICAgIHNldCB2YWx1ZSh2YWx1ZSkge1xuICAgICAgICB0aGlzLl92YWx1ZSA9IHZhbHVlO1xuICAgICAgICB0aGlzLmNyZWF0b3IgPSBudWxsO1xuICAgIH1cbn1cbmV4cG9ydHMuTGF6eSA9IExhenk7IC8vIyBzb3VyY2VNYXBwaW5nVVJMPW1haW4uanMubWFwXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2VsZWN0cm9uLXVwZGF0ZXIvbm9kZV9tb2R1bGVzL2xhenktdmFsL291dC9tYWluLmpzIiwidmFyIFNvdXJjZU1hcENvbnN1bWVyID0gcmVxdWlyZSgnc291cmNlLW1hcCcpLlNvdXJjZU1hcENvbnN1bWVyO1xudmFyIHBhdGggPSByZXF1aXJlKCdwYXRoJyk7XG5cbnZhciBmcztcbnRyeSB7XG4gIGZzID0gcmVxdWlyZSgnZnMnKTtcbiAgaWYgKCFmcy5leGlzdHNTeW5jIHx8ICFmcy5yZWFkRmlsZVN5bmMpIHtcbiAgICAvLyBmcyBkb2Vzbid0IGhhdmUgYWxsIG1ldGhvZHMgd2UgbmVlZFxuICAgIGZzID0gbnVsbDtcbiAgfVxufSBjYXRjaCAoZXJyKSB7XG4gIC8qIG5vcCAqL1xufVxuXG4vLyBPbmx5IGluc3RhbGwgb25jZSBpZiBjYWxsZWQgbXVsdGlwbGUgdGltZXNcbnZhciBlcnJvckZvcm1hdHRlckluc3RhbGxlZCA9IGZhbHNlO1xudmFyIHVuY2F1Z2h0U2hpbUluc3RhbGxlZCA9IGZhbHNlO1xuXG4vLyBJZiB0cnVlLCB0aGUgY2FjaGVzIGFyZSByZXNldCBiZWZvcmUgYSBzdGFjayB0cmFjZSBmb3JtYXR0aW5nIG9wZXJhdGlvblxudmFyIGVtcHR5Q2FjaGVCZXR3ZWVuT3BlcmF0aW9ucyA9IGZhbHNlO1xuXG4vLyBTdXBwb3J0cyB7YnJvd3Nlciwgbm9kZSwgYXV0b31cbnZhciBlbnZpcm9ubWVudCA9IFwiYXV0b1wiO1xuXG4vLyBNYXBzIGEgZmlsZSBwYXRoIHRvIGEgc3RyaW5nIGNvbnRhaW5pbmcgdGhlIGZpbGUgY29udGVudHNcbnZhciBmaWxlQ29udGVudHNDYWNoZSA9IHt9O1xuXG4vLyBNYXBzIGEgZmlsZSBwYXRoIHRvIGEgc291cmNlIG1hcCBmb3IgdGhhdCBmaWxlXG52YXIgc291cmNlTWFwQ2FjaGUgPSB7fTtcblxuLy8gUmVnZXggZm9yIGRldGVjdGluZyBzb3VyY2UgbWFwc1xudmFyIHJlU291cmNlTWFwID0gL15kYXRhOmFwcGxpY2F0aW9uXFwvanNvblteLF0rYmFzZTY0LC87XG5cbi8vIFByaW9yaXR5IGxpc3Qgb2YgcmV0cmlldmUgaGFuZGxlcnNcbnZhciByZXRyaWV2ZUZpbGVIYW5kbGVycyA9IFtdO1xudmFyIHJldHJpZXZlTWFwSGFuZGxlcnMgPSBbXTtcblxuZnVuY3Rpb24gaXNJbkJyb3dzZXIoKSB7XG4gIGlmIChlbnZpcm9ubWVudCA9PT0gXCJicm93c2VyXCIpXG4gICAgcmV0dXJuIHRydWU7XG4gIGlmIChlbnZpcm9ubWVudCA9PT0gXCJub2RlXCIpXG4gICAgcmV0dXJuIGZhbHNlO1xuICByZXR1cm4gKCh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJykgJiYgKHR5cGVvZiBYTUxIdHRwUmVxdWVzdCA9PT0gJ2Z1bmN0aW9uJykgJiYgISh3aW5kb3cucmVxdWlyZSAmJiB3aW5kb3cubW9kdWxlICYmIHdpbmRvdy5wcm9jZXNzICYmIHdpbmRvdy5wcm9jZXNzLnR5cGUgPT09IFwicmVuZGVyZXJcIikpO1xufVxuXG5mdW5jdGlvbiBoYXNHbG9iYWxQcm9jZXNzRXZlbnRFbWl0dGVyKCkge1xuICByZXR1cm4gKCh0eXBlb2YgcHJvY2VzcyA9PT0gJ29iamVjdCcpICYmIChwcm9jZXNzICE9PSBudWxsKSAmJiAodHlwZW9mIHByb2Nlc3Mub24gPT09ICdmdW5jdGlvbicpKTtcbn1cblxuZnVuY3Rpb24gaGFuZGxlckV4ZWMobGlzdCkge1xuICByZXR1cm4gZnVuY3Rpb24oYXJnKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgcmV0ID0gbGlzdFtpXShhcmcpO1xuICAgICAgaWYgKHJldCkge1xuICAgICAgICByZXR1cm4gcmV0O1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbiAgfTtcbn1cblxudmFyIHJldHJpZXZlRmlsZSA9IGhhbmRsZXJFeGVjKHJldHJpZXZlRmlsZUhhbmRsZXJzKTtcblxucmV0cmlldmVGaWxlSGFuZGxlcnMucHVzaChmdW5jdGlvbihwYXRoKSB7XG4gIC8vIFRyaW0gdGhlIHBhdGggdG8gbWFrZSBzdXJlIHRoZXJlIGlzIG5vIGV4dHJhIHdoaXRlc3BhY2UuXG4gIHBhdGggPSBwYXRoLnRyaW0oKTtcbiAgaWYgKHBhdGggaW4gZmlsZUNvbnRlbnRzQ2FjaGUpIHtcbiAgICByZXR1cm4gZmlsZUNvbnRlbnRzQ2FjaGVbcGF0aF07XG4gIH1cblxuICB2YXIgY29udGVudHMgPSBudWxsO1xuICBpZiAoIWZzKSB7XG4gICAgLy8gVXNlIFNKQVggaWYgd2UgYXJlIGluIHRoZSBicm93c2VyXG4gICAgdmFyIHhociA9IG5ldyBYTUxIdHRwUmVxdWVzdCgpO1xuICAgIHhoci5vcGVuKCdHRVQnLCBwYXRoLCBmYWxzZSk7XG4gICAgeGhyLnNlbmQobnVsbCk7XG4gICAgdmFyIGNvbnRlbnRzID0gbnVsbFxuICAgIGlmICh4aHIucmVhZHlTdGF0ZSA9PT0gNCAmJiB4aHIuc3RhdHVzID09PSAyMDApIHtcbiAgICAgIGNvbnRlbnRzID0geGhyLnJlc3BvbnNlVGV4dFxuICAgIH1cbiAgfSBlbHNlIGlmIChmcy5leGlzdHNTeW5jKHBhdGgpKSB7XG4gICAgLy8gT3RoZXJ3aXNlLCB1c2UgdGhlIGZpbGVzeXN0ZW1cbiAgICB0cnkge1xuICAgICAgY29udGVudHMgPSBmcy5yZWFkRmlsZVN5bmMocGF0aCwgJ3V0ZjgnKTtcbiAgICB9IGNhdGNoIChlcikge1xuICAgICAgY29udGVudHMgPSAnJztcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZmlsZUNvbnRlbnRzQ2FjaGVbcGF0aF0gPSBjb250ZW50cztcbn0pO1xuXG4vLyBTdXBwb3J0IFVSTHMgcmVsYXRpdmUgdG8gYSBkaXJlY3RvcnksIGJ1dCBiZSBjYXJlZnVsIGFib3V0IGEgcHJvdG9jb2wgcHJlZml4XG4vLyBpbiBjYXNlIHdlIGFyZSBpbiB0aGUgYnJvd3NlciAoaS5lLiBkaXJlY3RvcmllcyBtYXkgc3RhcnQgd2l0aCBcImh0dHA6Ly9cIilcbmZ1bmN0aW9uIHN1cHBvcnRSZWxhdGl2ZVVSTChmaWxlLCB1cmwpIHtcbiAgaWYgKCFmaWxlKSByZXR1cm4gdXJsO1xuICB2YXIgZGlyID0gcGF0aC5kaXJuYW1lKGZpbGUpO1xuICB2YXIgbWF0Y2ggPSAvXlxcdys6XFwvXFwvW15cXC9dKi8uZXhlYyhkaXIpO1xuICB2YXIgcHJvdG9jb2wgPSBtYXRjaCA/IG1hdGNoWzBdIDogJyc7XG4gIHJldHVybiBwcm90b2NvbCArIHBhdGgucmVzb2x2ZShkaXIuc2xpY2UocHJvdG9jb2wubGVuZ3RoKSwgdXJsKTtcbn1cblxuZnVuY3Rpb24gcmV0cmlldmVTb3VyY2VNYXBVUkwoc291cmNlKSB7XG4gIHZhciBmaWxlRGF0YTtcblxuICBpZiAoaXNJbkJyb3dzZXIoKSkge1xuICAgICB0cnkge1xuICAgICAgIHZhciB4aHIgPSBuZXcgWE1MSHR0cFJlcXVlc3QoKTtcbiAgICAgICB4aHIub3BlbignR0VUJywgc291cmNlLCBmYWxzZSk7XG4gICAgICAgeGhyLnNlbmQobnVsbCk7XG4gICAgICAgZmlsZURhdGEgPSB4aHIucmVhZHlTdGF0ZSA9PT0gNCA/IHhoci5yZXNwb25zZVRleHQgOiBudWxsO1xuXG4gICAgICAgLy8gU3VwcG9ydCBwcm92aWRpbmcgYSBzb3VyY2VNYXBwaW5nVVJMIHZpYSB0aGUgU291cmNlTWFwIGhlYWRlclxuICAgICAgIHZhciBzb3VyY2VNYXBIZWFkZXIgPSB4aHIuZ2V0UmVzcG9uc2VIZWFkZXIoXCJTb3VyY2VNYXBcIikgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeGhyLmdldFJlc3BvbnNlSGVhZGVyKFwiWC1Tb3VyY2VNYXBcIik7XG4gICAgICAgaWYgKHNvdXJjZU1hcEhlYWRlcikge1xuICAgICAgICAgcmV0dXJuIHNvdXJjZU1hcEhlYWRlcjtcbiAgICAgICB9XG4gICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgfVxuICB9XG5cbiAgLy8gR2V0IHRoZSBVUkwgb2YgdGhlIHNvdXJjZSBtYXBcbiAgZmlsZURhdGEgPSByZXRyaWV2ZUZpbGUoc291cmNlKTtcbiAgdmFyIHJlID0gLyg/OlxcL1xcL1tAI11bIFxcdF0rc291cmNlTWFwcGluZ1VSTD0oW15cXHMnXCJdKz8pWyBcXHRdKiQpfCg/OlxcL1xcKltAI11bIFxcdF0rc291cmNlTWFwcGluZ1VSTD0oW15cXCpdKz8pWyBcXHRdKig/OlxcKlxcLylbIFxcdF0qJCkvbWc7XG4gIC8vIEtlZXAgZXhlY3V0aW5nIHRoZSBzZWFyY2ggdG8gZmluZCB0aGUgKmxhc3QqIHNvdXJjZU1hcHBpbmdVUkwgdG8gYXZvaWRcbiAgLy8gcGlja2luZyB1cCBzb3VyY2VNYXBwaW5nVVJMcyBmcm9tIGNvbW1lbnRzLCBzdHJpbmdzLCBldGMuXG4gIHZhciBsYXN0TWF0Y2gsIG1hdGNoO1xuICB3aGlsZSAobWF0Y2ggPSByZS5leGVjKGZpbGVEYXRhKSkgbGFzdE1hdGNoID0gbWF0Y2g7XG4gIGlmICghbGFzdE1hdGNoKSByZXR1cm4gbnVsbDtcbiAgcmV0dXJuIGxhc3RNYXRjaFsxXTtcbn07XG5cbi8vIENhbiBiZSBvdmVycmlkZGVuIGJ5IHRoZSByZXRyaWV2ZVNvdXJjZU1hcCBvcHRpb24gdG8gaW5zdGFsbC4gVGFrZXMgYVxuLy8gZ2VuZXJhdGVkIHNvdXJjZSBmaWxlbmFtZTsgcmV0dXJucyBhIHttYXAsIG9wdGlvbmFsIHVybH0gb2JqZWN0LCBvciBudWxsIGlmXG4vLyB0aGVyZSBpcyBubyBzb3VyY2UgbWFwLiAgVGhlIG1hcCBmaWVsZCBtYXkgYmUgZWl0aGVyIGEgc3RyaW5nIG9yIHRoZSBwYXJzZWRcbi8vIEpTT04gb2JqZWN0IChpZSwgaXQgbXVzdCBiZSBhIHZhbGlkIGFyZ3VtZW50IHRvIHRoZSBTb3VyY2VNYXBDb25zdW1lclxuLy8gY29uc3RydWN0b3IpLlxudmFyIHJldHJpZXZlU291cmNlTWFwID0gaGFuZGxlckV4ZWMocmV0cmlldmVNYXBIYW5kbGVycyk7XG5yZXRyaWV2ZU1hcEhhbmRsZXJzLnB1c2goZnVuY3Rpb24oc291cmNlKSB7XG4gIHZhciBzb3VyY2VNYXBwaW5nVVJMID0gcmV0cmlldmVTb3VyY2VNYXBVUkwoc291cmNlKTtcbiAgaWYgKCFzb3VyY2VNYXBwaW5nVVJMKSByZXR1cm4gbnVsbDtcblxuICAvLyBSZWFkIHRoZSBjb250ZW50cyBvZiB0aGUgc291cmNlIG1hcFxuICB2YXIgc291cmNlTWFwRGF0YTtcbiAgaWYgKHJlU291cmNlTWFwLnRlc3Qoc291cmNlTWFwcGluZ1VSTCkpIHtcbiAgICAvLyBTdXBwb3J0IHNvdXJjZSBtYXAgVVJMIGFzIGEgZGF0YSB1cmxcbiAgICB2YXIgcmF3RGF0YSA9IHNvdXJjZU1hcHBpbmdVUkwuc2xpY2Uoc291cmNlTWFwcGluZ1VSTC5pbmRleE9mKCcsJykgKyAxKTtcbiAgICBzb3VyY2VNYXBEYXRhID0gbmV3IEJ1ZmZlcihyYXdEYXRhLCBcImJhc2U2NFwiKS50b1N0cmluZygpO1xuICAgIHNvdXJjZU1hcHBpbmdVUkwgPSBzb3VyY2U7XG4gIH0gZWxzZSB7XG4gICAgLy8gU3VwcG9ydCBzb3VyY2UgbWFwIFVSTHMgcmVsYXRpdmUgdG8gdGhlIHNvdXJjZSBVUkxcbiAgICBzb3VyY2VNYXBwaW5nVVJMID0gc3VwcG9ydFJlbGF0aXZlVVJMKHNvdXJjZSwgc291cmNlTWFwcGluZ1VSTCk7XG4gICAgc291cmNlTWFwRGF0YSA9IHJldHJpZXZlRmlsZShzb3VyY2VNYXBwaW5nVVJMKTtcbiAgfVxuXG4gIGlmICghc291cmNlTWFwRGF0YSkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICB1cmw6IHNvdXJjZU1hcHBpbmdVUkwsXG4gICAgbWFwOiBzb3VyY2VNYXBEYXRhXG4gIH07XG59KTtcblxuZnVuY3Rpb24gbWFwU291cmNlUG9zaXRpb24ocG9zaXRpb24pIHtcbiAgdmFyIHNvdXJjZU1hcCA9IHNvdXJjZU1hcENhY2hlW3Bvc2l0aW9uLnNvdXJjZV07XG4gIGlmICghc291cmNlTWFwKSB7XG4gICAgLy8gQ2FsbCB0aGUgKG92ZXJyaWRlYWJsZSkgcmV0cmlldmVTb3VyY2VNYXAgZnVuY3Rpb24gdG8gZ2V0IHRoZSBzb3VyY2UgbWFwLlxuICAgIHZhciB1cmxBbmRNYXAgPSByZXRyaWV2ZVNvdXJjZU1hcChwb3NpdGlvbi5zb3VyY2UpO1xuICAgIGlmICh1cmxBbmRNYXApIHtcbiAgICAgIHNvdXJjZU1hcCA9IHNvdXJjZU1hcENhY2hlW3Bvc2l0aW9uLnNvdXJjZV0gPSB7XG4gICAgICAgIHVybDogdXJsQW5kTWFwLnVybCxcbiAgICAgICAgbWFwOiBuZXcgU291cmNlTWFwQ29uc3VtZXIodXJsQW5kTWFwLm1hcClcbiAgICAgIH07XG5cbiAgICAgIC8vIExvYWQgYWxsIHNvdXJjZXMgc3RvcmVkIGlubGluZSB3aXRoIHRoZSBzb3VyY2UgbWFwIGludG8gdGhlIGZpbGUgY2FjaGVcbiAgICAgIC8vIHRvIHByZXRlbmQgbGlrZSB0aGV5IGFyZSBhbHJlYWR5IGxvYWRlZC4gVGhleSBtYXkgbm90IGV4aXN0IG9uIGRpc2suXG4gICAgICBpZiAoc291cmNlTWFwLm1hcC5zb3VyY2VzQ29udGVudCkge1xuICAgICAgICBzb3VyY2VNYXAubWFwLnNvdXJjZXMuZm9yRWFjaChmdW5jdGlvbihzb3VyY2UsIGkpIHtcbiAgICAgICAgICB2YXIgY29udGVudHMgPSBzb3VyY2VNYXAubWFwLnNvdXJjZXNDb250ZW50W2ldO1xuICAgICAgICAgIGlmIChjb250ZW50cykge1xuICAgICAgICAgICAgdmFyIHVybCA9IHN1cHBvcnRSZWxhdGl2ZVVSTChzb3VyY2VNYXAudXJsLCBzb3VyY2UpO1xuICAgICAgICAgICAgZmlsZUNvbnRlbnRzQ2FjaGVbdXJsXSA9IGNvbnRlbnRzO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHNvdXJjZU1hcCA9IHNvdXJjZU1hcENhY2hlW3Bvc2l0aW9uLnNvdXJjZV0gPSB7XG4gICAgICAgIHVybDogbnVsbCxcbiAgICAgICAgbWFwOiBudWxsXG4gICAgICB9O1xuICAgIH1cbiAgfVxuXG4gIC8vIFJlc29sdmUgdGhlIHNvdXJjZSBVUkwgcmVsYXRpdmUgdG8gdGhlIFVSTCBvZiB0aGUgc291cmNlIG1hcFxuICBpZiAoc291cmNlTWFwICYmIHNvdXJjZU1hcC5tYXApIHtcbiAgICB2YXIgb3JpZ2luYWxQb3NpdGlvbiA9IHNvdXJjZU1hcC5tYXAub3JpZ2luYWxQb3NpdGlvbkZvcihwb3NpdGlvbik7XG5cbiAgICAvLyBPbmx5IHJldHVybiB0aGUgb3JpZ2luYWwgcG9zaXRpb24gaWYgYSBtYXRjaGluZyBsaW5lIHdhcyBmb3VuZC4gSWYgbm9cbiAgICAvLyBtYXRjaGluZyBsaW5lIGlzIGZvdW5kIHRoZW4gd2UgcmV0dXJuIHBvc2l0aW9uIGluc3RlYWQsIHdoaWNoIHdpbGwgY2F1c2VcbiAgICAvLyB0aGUgc3RhY2sgdHJhY2UgdG8gcHJpbnQgdGhlIHBhdGggYW5kIGxpbmUgZm9yIHRoZSBjb21waWxlZCBmaWxlLiBJdCBpc1xuICAgIC8vIGJldHRlciB0byBnaXZlIGEgcHJlY2lzZSBsb2NhdGlvbiBpbiB0aGUgY29tcGlsZWQgZmlsZSB0aGFuIGEgdmFndWVcbiAgICAvLyBsb2NhdGlvbiBpbiB0aGUgb3JpZ2luYWwgZmlsZS5cbiAgICBpZiAob3JpZ2luYWxQb3NpdGlvbi5zb3VyY2UgIT09IG51bGwpIHtcbiAgICAgIG9yaWdpbmFsUG9zaXRpb24uc291cmNlID0gc3VwcG9ydFJlbGF0aXZlVVJMKFxuICAgICAgICBzb3VyY2VNYXAudXJsLCBvcmlnaW5hbFBvc2l0aW9uLnNvdXJjZSk7XG4gICAgICByZXR1cm4gb3JpZ2luYWxQb3NpdGlvbjtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gcG9zaXRpb247XG59XG5cbi8vIFBhcnNlcyBjb2RlIGdlbmVyYXRlZCBieSBGb3JtYXRFdmFsT3JpZ2luKCksIGEgZnVuY3Rpb24gaW5zaWRlIFY4OlxuLy8gaHR0cHM6Ly9jb2RlLmdvb2dsZS5jb20vcC92OC9zb3VyY2UvYnJvd3NlL3RydW5rL3NyYy9tZXNzYWdlcy5qc1xuZnVuY3Rpb24gbWFwRXZhbE9yaWdpbihvcmlnaW4pIHtcbiAgLy8gTW9zdCBldmFsKCkgY2FsbHMgYXJlIGluIHRoaXMgZm9ybWF0XG4gIHZhciBtYXRjaCA9IC9eZXZhbCBhdCAoW14oXSspIFxcKCguKyk6KFxcZCspOihcXGQrKVxcKSQvLmV4ZWMob3JpZ2luKTtcbiAgaWYgKG1hdGNoKSB7XG4gICAgdmFyIHBvc2l0aW9uID0gbWFwU291cmNlUG9zaXRpb24oe1xuICAgICAgc291cmNlOiBtYXRjaFsyXSxcbiAgICAgIGxpbmU6ICttYXRjaFszXSxcbiAgICAgIGNvbHVtbjogbWF0Y2hbNF0gLSAxXG4gICAgfSk7XG4gICAgcmV0dXJuICdldmFsIGF0ICcgKyBtYXRjaFsxXSArICcgKCcgKyBwb3NpdGlvbi5zb3VyY2UgKyAnOicgK1xuICAgICAgcG9zaXRpb24ubGluZSArICc6JyArIChwb3NpdGlvbi5jb2x1bW4gKyAxKSArICcpJztcbiAgfVxuXG4gIC8vIFBhcnNlIG5lc3RlZCBldmFsKCkgY2FsbHMgdXNpbmcgcmVjdXJzaW9uXG4gIG1hdGNoID0gL15ldmFsIGF0IChbXihdKykgXFwoKC4rKVxcKSQvLmV4ZWMob3JpZ2luKTtcbiAgaWYgKG1hdGNoKSB7XG4gICAgcmV0dXJuICdldmFsIGF0ICcgKyBtYXRjaFsxXSArICcgKCcgKyBtYXBFdmFsT3JpZ2luKG1hdGNoWzJdKSArICcpJztcbiAgfVxuXG4gIC8vIE1ha2Ugc3VyZSB3ZSBzdGlsbCByZXR1cm4gdXNlZnVsIGluZm9ybWF0aW9uIGlmIHdlIGRpZG4ndCBmaW5kIGFueXRoaW5nXG4gIHJldHVybiBvcmlnaW47XG59XG5cbi8vIFRoaXMgaXMgY29waWVkIGFsbW9zdCB2ZXJiYXRpbSBmcm9tIHRoZSBWOCBzb3VyY2UgY29kZSBhdFxuLy8gaHR0cHM6Ly9jb2RlLmdvb2dsZS5jb20vcC92OC9zb3VyY2UvYnJvd3NlL3RydW5rL3NyYy9tZXNzYWdlcy5qcy4gVGhlXG4vLyBpbXBsZW1lbnRhdGlvbiBvZiB3cmFwQ2FsbFNpdGUoKSB1c2VkIHRvIGp1c3QgZm9yd2FyZCB0byB0aGUgYWN0dWFsIHNvdXJjZVxuLy8gY29kZSBvZiBDYWxsU2l0ZS5wcm90b3R5cGUudG9TdHJpbmcgYnV0IHVuZm9ydHVuYXRlbHkgYSBuZXcgcmVsZWFzZSBvZiBWOFxuLy8gZGlkIHNvbWV0aGluZyB0byB0aGUgcHJvdG90eXBlIGNoYWluIGFuZCBicm9rZSB0aGUgc2hpbS4gVGhlIG9ubHkgZml4IElcbi8vIGNvdWxkIGZpbmQgd2FzIGNvcHkvcGFzdGUuXG5mdW5jdGlvbiBDYWxsU2l0ZVRvU3RyaW5nKCkge1xuICB2YXIgZmlsZU5hbWU7XG4gIHZhciBmaWxlTG9jYXRpb24gPSBcIlwiO1xuICBpZiAodGhpcy5pc05hdGl2ZSgpKSB7XG4gICAgZmlsZUxvY2F0aW9uID0gXCJuYXRpdmVcIjtcbiAgfSBlbHNlIHtcbiAgICBmaWxlTmFtZSA9IHRoaXMuZ2V0U2NyaXB0TmFtZU9yU291cmNlVVJMKCk7XG4gICAgaWYgKCFmaWxlTmFtZSAmJiB0aGlzLmlzRXZhbCgpKSB7XG4gICAgICBmaWxlTG9jYXRpb24gPSB0aGlzLmdldEV2YWxPcmlnaW4oKTtcbiAgICAgIGZpbGVMb2NhdGlvbiArPSBcIiwgXCI7ICAvLyBFeHBlY3Rpbmcgc291cmNlIHBvc2l0aW9uIHRvIGZvbGxvdy5cbiAgICB9XG5cbiAgICBpZiAoZmlsZU5hbWUpIHtcbiAgICAgIGZpbGVMb2NhdGlvbiArPSBmaWxlTmFtZTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gU291cmNlIGNvZGUgZG9lcyBub3Qgb3JpZ2luYXRlIGZyb20gYSBmaWxlIGFuZCBpcyBub3QgbmF0aXZlLCBidXQgd2VcbiAgICAgIC8vIGNhbiBzdGlsbCBnZXQgdGhlIHNvdXJjZSBwb3NpdGlvbiBpbnNpZGUgdGhlIHNvdXJjZSBzdHJpbmcsIGUuZy4gaW5cbiAgICAgIC8vIGFuIGV2YWwgc3RyaW5nLlxuICAgICAgZmlsZUxvY2F0aW9uICs9IFwiPGFub255bW91cz5cIjtcbiAgICB9XG4gICAgdmFyIGxpbmVOdW1iZXIgPSB0aGlzLmdldExpbmVOdW1iZXIoKTtcbiAgICBpZiAobGluZU51bWJlciAhPSBudWxsKSB7XG4gICAgICBmaWxlTG9jYXRpb24gKz0gXCI6XCIgKyBsaW5lTnVtYmVyO1xuICAgICAgdmFyIGNvbHVtbk51bWJlciA9IHRoaXMuZ2V0Q29sdW1uTnVtYmVyKCk7XG4gICAgICBpZiAoY29sdW1uTnVtYmVyKSB7XG4gICAgICAgIGZpbGVMb2NhdGlvbiArPSBcIjpcIiArIGNvbHVtbk51bWJlcjtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICB2YXIgbGluZSA9IFwiXCI7XG4gIHZhciBmdW5jdGlvbk5hbWUgPSB0aGlzLmdldEZ1bmN0aW9uTmFtZSgpO1xuICB2YXIgYWRkU3VmZml4ID0gdHJ1ZTtcbiAgdmFyIGlzQ29uc3RydWN0b3IgPSB0aGlzLmlzQ29uc3RydWN0b3IoKTtcbiAgdmFyIGlzTWV0aG9kQ2FsbCA9ICEodGhpcy5pc1RvcGxldmVsKCkgfHwgaXNDb25zdHJ1Y3Rvcik7XG4gIGlmIChpc01ldGhvZENhbGwpIHtcbiAgICB2YXIgdHlwZU5hbWUgPSB0aGlzLmdldFR5cGVOYW1lKCk7XG4gICAgLy8gRml4ZXMgc2hpbSB0byBiZSBiYWNrd2FyZCBjb21wYXRhYmxlIHdpdGggTm9kZSB2MCB0byB2NFxuICAgIGlmICh0eXBlTmFtZSA9PT0gXCJbb2JqZWN0IE9iamVjdF1cIikge1xuICAgICAgdHlwZU5hbWUgPSBcIm51bGxcIjtcbiAgICB9XG4gICAgdmFyIG1ldGhvZE5hbWUgPSB0aGlzLmdldE1ldGhvZE5hbWUoKTtcbiAgICBpZiAoZnVuY3Rpb25OYW1lKSB7XG4gICAgICBpZiAodHlwZU5hbWUgJiYgZnVuY3Rpb25OYW1lLmluZGV4T2YodHlwZU5hbWUpICE9IDApIHtcbiAgICAgICAgbGluZSArPSB0eXBlTmFtZSArIFwiLlwiO1xuICAgICAgfVxuICAgICAgbGluZSArPSBmdW5jdGlvbk5hbWU7XG4gICAgICBpZiAobWV0aG9kTmFtZSAmJiBmdW5jdGlvbk5hbWUuaW5kZXhPZihcIi5cIiArIG1ldGhvZE5hbWUpICE9IGZ1bmN0aW9uTmFtZS5sZW5ndGggLSBtZXRob2ROYW1lLmxlbmd0aCAtIDEpIHtcbiAgICAgICAgbGluZSArPSBcIiBbYXMgXCIgKyBtZXRob2ROYW1lICsgXCJdXCI7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGxpbmUgKz0gdHlwZU5hbWUgKyBcIi5cIiArIChtZXRob2ROYW1lIHx8IFwiPGFub255bW91cz5cIik7XG4gICAgfVxuICB9IGVsc2UgaWYgKGlzQ29uc3RydWN0b3IpIHtcbiAgICBsaW5lICs9IFwibmV3IFwiICsgKGZ1bmN0aW9uTmFtZSB8fCBcIjxhbm9ueW1vdXM+XCIpO1xuICB9IGVsc2UgaWYgKGZ1bmN0aW9uTmFtZSkge1xuICAgIGxpbmUgKz0gZnVuY3Rpb25OYW1lO1xuICB9IGVsc2Uge1xuICAgIGxpbmUgKz0gZmlsZUxvY2F0aW9uO1xuICAgIGFkZFN1ZmZpeCA9IGZhbHNlO1xuICB9XG4gIGlmIChhZGRTdWZmaXgpIHtcbiAgICBsaW5lICs9IFwiIChcIiArIGZpbGVMb2NhdGlvbiArIFwiKVwiO1xuICB9XG4gIHJldHVybiBsaW5lO1xufVxuXG5mdW5jdGlvbiBjbG9uZUNhbGxTaXRlKGZyYW1lKSB7XG4gIHZhciBvYmplY3QgPSB7fTtcbiAgT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoT2JqZWN0LmdldFByb3RvdHlwZU9mKGZyYW1lKSkuZm9yRWFjaChmdW5jdGlvbihuYW1lKSB7XG4gICAgb2JqZWN0W25hbWVdID0gL14oPzppc3xnZXQpLy50ZXN0KG5hbWUpID8gZnVuY3Rpb24oKSB7IHJldHVybiBmcmFtZVtuYW1lXS5jYWxsKGZyYW1lKTsgfSA6IGZyYW1lW25hbWVdO1xuICB9KTtcbiAgb2JqZWN0LnRvU3RyaW5nID0gQ2FsbFNpdGVUb1N0cmluZztcbiAgcmV0dXJuIG9iamVjdDtcbn1cblxuZnVuY3Rpb24gd3JhcENhbGxTaXRlKGZyYW1lKSB7XG4gIGlmKGZyYW1lLmlzTmF0aXZlKCkpIHtcbiAgICByZXR1cm4gZnJhbWU7XG4gIH1cblxuICAvLyBNb3N0IGNhbGwgc2l0ZXMgd2lsbCByZXR1cm4gdGhlIHNvdXJjZSBmaWxlIGZyb20gZ2V0RmlsZU5hbWUoKSwgYnV0IGNvZGVcbiAgLy8gcGFzc2VkIHRvIGV2YWwoKSBlbmRpbmcgaW4gXCIvLyMgc291cmNlVVJMPS4uLlwiIHdpbGwgcmV0dXJuIHRoZSBzb3VyY2UgZmlsZVxuICAvLyBmcm9tIGdldFNjcmlwdE5hbWVPclNvdXJjZVVSTCgpIGluc3RlYWRcbiAgdmFyIHNvdXJjZSA9IGZyYW1lLmdldEZpbGVOYW1lKCkgfHwgZnJhbWUuZ2V0U2NyaXB0TmFtZU9yU291cmNlVVJMKCk7XG4gIGlmIChzb3VyY2UpIHtcbiAgICB2YXIgbGluZSA9IGZyYW1lLmdldExpbmVOdW1iZXIoKTtcbiAgICB2YXIgY29sdW1uID0gZnJhbWUuZ2V0Q29sdW1uTnVtYmVyKCkgLSAxO1xuXG4gICAgLy8gRml4IHBvc2l0aW9uIGluIE5vZGUgd2hlcmUgc29tZSAoaW50ZXJuYWwpIGNvZGUgaXMgcHJlcGVuZGVkLlxuICAgIC8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vZXZhbncvbm9kZS1zb3VyY2UtbWFwLXN1cHBvcnQvaXNzdWVzLzM2XG4gICAgdmFyIGhlYWRlckxlbmd0aCA9IDYyO1xuICAgIGlmIChsaW5lID09PSAxICYmIGNvbHVtbiA+IGhlYWRlckxlbmd0aCAmJiAhaXNJbkJyb3dzZXIoKSAmJiAhZnJhbWUuaXNFdmFsKCkpIHtcbiAgICAgIGNvbHVtbiAtPSBoZWFkZXJMZW5ndGg7XG4gICAgfVxuXG4gICAgdmFyIHBvc2l0aW9uID0gbWFwU291cmNlUG9zaXRpb24oe1xuICAgICAgc291cmNlOiBzb3VyY2UsXG4gICAgICBsaW5lOiBsaW5lLFxuICAgICAgY29sdW1uOiBjb2x1bW5cbiAgICB9KTtcbiAgICBmcmFtZSA9IGNsb25lQ2FsbFNpdGUoZnJhbWUpO1xuICAgIGZyYW1lLmdldEZpbGVOYW1lID0gZnVuY3Rpb24oKSB7IHJldHVybiBwb3NpdGlvbi5zb3VyY2U7IH07XG4gICAgZnJhbWUuZ2V0TGluZU51bWJlciA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gcG9zaXRpb24ubGluZTsgfTtcbiAgICBmcmFtZS5nZXRDb2x1bW5OdW1iZXIgPSBmdW5jdGlvbigpIHsgcmV0dXJuIHBvc2l0aW9uLmNvbHVtbiArIDE7IH07XG4gICAgZnJhbWUuZ2V0U2NyaXB0TmFtZU9yU291cmNlVVJMID0gZnVuY3Rpb24oKSB7IHJldHVybiBwb3NpdGlvbi5zb3VyY2U7IH07XG4gICAgcmV0dXJuIGZyYW1lO1xuICB9XG5cbiAgLy8gQ29kZSBjYWxsZWQgdXNpbmcgZXZhbCgpIG5lZWRzIHNwZWNpYWwgaGFuZGxpbmdcbiAgdmFyIG9yaWdpbiA9IGZyYW1lLmlzRXZhbCgpICYmIGZyYW1lLmdldEV2YWxPcmlnaW4oKTtcbiAgaWYgKG9yaWdpbikge1xuICAgIG9yaWdpbiA9IG1hcEV2YWxPcmlnaW4ob3JpZ2luKTtcbiAgICBmcmFtZSA9IGNsb25lQ2FsbFNpdGUoZnJhbWUpO1xuICAgIGZyYW1lLmdldEV2YWxPcmlnaW4gPSBmdW5jdGlvbigpIHsgcmV0dXJuIG9yaWdpbjsgfTtcbiAgICByZXR1cm4gZnJhbWU7XG4gIH1cblxuICAvLyBJZiB3ZSBnZXQgaGVyZSB0aGVuIHdlIHdlcmUgdW5hYmxlIHRvIGNoYW5nZSB0aGUgc291cmNlIHBvc2l0aW9uXG4gIHJldHVybiBmcmFtZTtcbn1cblxuLy8gVGhpcyBmdW5jdGlvbiBpcyBwYXJ0IG9mIHRoZSBWOCBzdGFjayB0cmFjZSBBUEksIGZvciBtb3JlIGluZm8gc2VlOlxuLy8gaHR0cDovL2NvZGUuZ29vZ2xlLmNvbS9wL3Y4L3dpa2kvSmF2YVNjcmlwdFN0YWNrVHJhY2VBcGlcbmZ1bmN0aW9uIHByZXBhcmVTdGFja1RyYWNlKGVycm9yLCBzdGFjaykge1xuICBpZiAoZW1wdHlDYWNoZUJldHdlZW5PcGVyYXRpb25zKSB7XG4gICAgZmlsZUNvbnRlbnRzQ2FjaGUgPSB7fTtcbiAgICBzb3VyY2VNYXBDYWNoZSA9IHt9O1xuICB9XG5cbiAgcmV0dXJuIGVycm9yICsgc3RhY2subWFwKGZ1bmN0aW9uKGZyYW1lKSB7XG4gICAgcmV0dXJuICdcXG4gICAgYXQgJyArIHdyYXBDYWxsU2l0ZShmcmFtZSk7XG4gIH0pLmpvaW4oJycpO1xufVxuXG4vLyBHZW5lcmF0ZSBwb3NpdGlvbiBhbmQgc25pcHBldCBvZiBvcmlnaW5hbCBzb3VyY2Ugd2l0aCBwb2ludGVyXG5mdW5jdGlvbiBnZXRFcnJvclNvdXJjZShlcnJvcikge1xuICB2YXIgbWF0Y2ggPSAvXFxuICAgIGF0IFteKF0rIFxcKCguKik6KFxcZCspOihcXGQrKVxcKS8uZXhlYyhlcnJvci5zdGFjayk7XG4gIGlmIChtYXRjaCkge1xuICAgIHZhciBzb3VyY2UgPSBtYXRjaFsxXTtcbiAgICB2YXIgbGluZSA9ICttYXRjaFsyXTtcbiAgICB2YXIgY29sdW1uID0gK21hdGNoWzNdO1xuXG4gICAgLy8gU3VwcG9ydCB0aGUgaW5saW5lIHNvdXJjZUNvbnRlbnRzIGluc2lkZSB0aGUgc291cmNlIG1hcFxuICAgIHZhciBjb250ZW50cyA9IGZpbGVDb250ZW50c0NhY2hlW3NvdXJjZV07XG5cbiAgICAvLyBTdXBwb3J0IGZpbGVzIG9uIGRpc2tcbiAgICBpZiAoIWNvbnRlbnRzICYmIGZzICYmIGZzLmV4aXN0c1N5bmMoc291cmNlKSkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgY29udGVudHMgPSBmcy5yZWFkRmlsZVN5bmMoc291cmNlLCAndXRmOCcpO1xuICAgICAgfSBjYXRjaCAoZXIpIHtcbiAgICAgICAgY29udGVudHMgPSAnJztcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBGb3JtYXQgdGhlIGxpbmUgZnJvbSB0aGUgb3JpZ2luYWwgc291cmNlIGNvZGUgbGlrZSBub2RlIGRvZXNcbiAgICBpZiAoY29udGVudHMpIHtcbiAgICAgIHZhciBjb2RlID0gY29udGVudHMuc3BsaXQoLyg/OlxcclxcbnxcXHJ8XFxuKS8pW2xpbmUgLSAxXTtcbiAgICAgIGlmIChjb2RlKSB7XG4gICAgICAgIHJldHVybiBzb3VyY2UgKyAnOicgKyBsaW5lICsgJ1xcbicgKyBjb2RlICsgJ1xcbicgK1xuICAgICAgICAgIG5ldyBBcnJheShjb2x1bW4pLmpvaW4oJyAnKSArICdeJztcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59XG5cbmZ1bmN0aW9uIHByaW50RXJyb3JBbmRFeGl0IChlcnJvcikge1xuICB2YXIgc291cmNlID0gZ2V0RXJyb3JTb3VyY2UoZXJyb3IpO1xuXG4gIGlmIChzb3VyY2UpIHtcbiAgICBjb25zb2xlLmVycm9yKCk7XG4gICAgY29uc29sZS5lcnJvcihzb3VyY2UpO1xuICB9XG5cbiAgY29uc29sZS5lcnJvcihlcnJvci5zdGFjayk7XG4gIHByb2Nlc3MuZXhpdCgxKTtcbn1cblxuZnVuY3Rpb24gc2hpbUVtaXRVbmNhdWdodEV4Y2VwdGlvbiAoKSB7XG4gIHZhciBvcmlnRW1pdCA9IHByb2Nlc3MuZW1pdDtcblxuICBwcm9jZXNzLmVtaXQgPSBmdW5jdGlvbiAodHlwZSkge1xuICAgIGlmICh0eXBlID09PSAndW5jYXVnaHRFeGNlcHRpb24nKSB7XG4gICAgICB2YXIgaGFzU3RhY2sgPSAoYXJndW1lbnRzWzFdICYmIGFyZ3VtZW50c1sxXS5zdGFjayk7XG4gICAgICB2YXIgaGFzTGlzdGVuZXJzID0gKHRoaXMubGlzdGVuZXJzKHR5cGUpLmxlbmd0aCA+IDApO1xuXG4gICAgICBpZiAoaGFzU3RhY2sgJiYgIWhhc0xpc3RlbmVycykge1xuICAgICAgICByZXR1cm4gcHJpbnRFcnJvckFuZEV4aXQoYXJndW1lbnRzWzFdKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gb3JpZ0VtaXQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgfTtcbn1cblxuZXhwb3J0cy53cmFwQ2FsbFNpdGUgPSB3cmFwQ2FsbFNpdGU7XG5leHBvcnRzLmdldEVycm9yU291cmNlID0gZ2V0RXJyb3JTb3VyY2U7XG5leHBvcnRzLm1hcFNvdXJjZVBvc2l0aW9uID0gbWFwU291cmNlUG9zaXRpb247XG5leHBvcnRzLnJldHJpZXZlU291cmNlTWFwID0gcmV0cmlldmVTb3VyY2VNYXA7XG5cbmV4cG9ydHMuaW5zdGFsbCA9IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgaWYgKG9wdGlvbnMuZW52aXJvbm1lbnQpIHtcbiAgICBlbnZpcm9ubWVudCA9IG9wdGlvbnMuZW52aXJvbm1lbnQ7XG4gICAgaWYgKFtcIm5vZGVcIiwgXCJicm93c2VyXCIsIFwiYXV0b1wiXS5pbmRleE9mKGVudmlyb25tZW50KSA9PT0gLTEpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcImVudmlyb25tZW50IFwiICsgZW52aXJvbm1lbnQgKyBcIiB3YXMgdW5rbm93bi4gQXZhaWxhYmxlIG9wdGlvbnMgYXJlIHthdXRvLCBicm93c2VyLCBub2RlfVwiKVxuICAgIH1cbiAgfVxuXG4gIC8vIEFsbG93IHNvdXJjZXMgdG8gYmUgZm91bmQgYnkgbWV0aG9kcyBvdGhlciB0aGFuIHJlYWRpbmcgdGhlIGZpbGVzXG4gIC8vIGRpcmVjdGx5IGZyb20gZGlzay5cbiAgaWYgKG9wdGlvbnMucmV0cmlldmVGaWxlKSB7XG4gICAgaWYgKG9wdGlvbnMub3ZlcnJpZGVSZXRyaWV2ZUZpbGUpIHtcbiAgICAgIHJldHJpZXZlRmlsZUhhbmRsZXJzLmxlbmd0aCA9IDA7XG4gICAgfVxuXG4gICAgcmV0cmlldmVGaWxlSGFuZGxlcnMudW5zaGlmdChvcHRpb25zLnJldHJpZXZlRmlsZSk7XG4gIH1cblxuICAvLyBBbGxvdyBzb3VyY2UgbWFwcyB0byBiZSBmb3VuZCBieSBtZXRob2RzIG90aGVyIHRoYW4gcmVhZGluZyB0aGUgZmlsZXNcbiAgLy8gZGlyZWN0bHkgZnJvbSBkaXNrLlxuICBpZiAob3B0aW9ucy5yZXRyaWV2ZVNvdXJjZU1hcCkge1xuICAgIGlmIChvcHRpb25zLm92ZXJyaWRlUmV0cmlldmVTb3VyY2VNYXApIHtcbiAgICAgIHJldHJpZXZlTWFwSGFuZGxlcnMubGVuZ3RoID0gMDtcbiAgICB9XG5cbiAgICByZXRyaWV2ZU1hcEhhbmRsZXJzLnVuc2hpZnQob3B0aW9ucy5yZXRyaWV2ZVNvdXJjZU1hcCk7XG4gIH1cblxuICAvLyBTdXBwb3J0IHJ1bnRpbWUgdHJhbnNwaWxlcnMgdGhhdCBpbmNsdWRlIGlubGluZSBzb3VyY2UgbWFwc1xuICBpZiAob3B0aW9ucy5ob29rUmVxdWlyZSAmJiAhaXNJbkJyb3dzZXIoKSkge1xuICAgIHZhciBNb2R1bGU7XG4gICAgdHJ5IHtcbiAgICAgIE1vZHVsZSA9IHJlcXVpcmUoJ21vZHVsZScpO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgLy8gTk9QOiBMb2FkaW5nIGluIGNhdGNoIGJsb2NrIHRvIGNvbnZlcnQgd2VicGFjayBlcnJvciB0byB3YXJuaW5nLlxuICAgIH1cbiAgICB2YXIgJGNvbXBpbGUgPSBNb2R1bGUucHJvdG90eXBlLl9jb21waWxlO1xuXG4gICAgaWYgKCEkY29tcGlsZS5fX3NvdXJjZU1hcFN1cHBvcnQpIHtcbiAgICAgIE1vZHVsZS5wcm90b3R5cGUuX2NvbXBpbGUgPSBmdW5jdGlvbihjb250ZW50LCBmaWxlbmFtZSkge1xuICAgICAgICBmaWxlQ29udGVudHNDYWNoZVtmaWxlbmFtZV0gPSBjb250ZW50O1xuICAgICAgICBzb3VyY2VNYXBDYWNoZVtmaWxlbmFtZV0gPSB1bmRlZmluZWQ7XG4gICAgICAgIHJldHVybiAkY29tcGlsZS5jYWxsKHRoaXMsIGNvbnRlbnQsIGZpbGVuYW1lKTtcbiAgICAgIH07XG5cbiAgICAgIE1vZHVsZS5wcm90b3R5cGUuX2NvbXBpbGUuX19zb3VyY2VNYXBTdXBwb3J0ID0gdHJ1ZTtcbiAgICB9XG4gIH1cblxuICAvLyBDb25maWd1cmUgb3B0aW9uc1xuICBpZiAoIWVtcHR5Q2FjaGVCZXR3ZWVuT3BlcmF0aW9ucykge1xuICAgIGVtcHR5Q2FjaGVCZXR3ZWVuT3BlcmF0aW9ucyA9ICdlbXB0eUNhY2hlQmV0d2Vlbk9wZXJhdGlvbnMnIGluIG9wdGlvbnMgP1xuICAgICAgb3B0aW9ucy5lbXB0eUNhY2hlQmV0d2Vlbk9wZXJhdGlvbnMgOiBmYWxzZTtcbiAgfVxuXG4gIC8vIEluc3RhbGwgdGhlIGVycm9yIHJlZm9ybWF0dGVyXG4gIGlmICghZXJyb3JGb3JtYXR0ZXJJbnN0YWxsZWQpIHtcbiAgICBlcnJvckZvcm1hdHRlckluc3RhbGxlZCA9IHRydWU7XG4gICAgRXJyb3IucHJlcGFyZVN0YWNrVHJhY2UgPSBwcmVwYXJlU3RhY2tUcmFjZTtcbiAgfVxuXG4gIGlmICghdW5jYXVnaHRTaGltSW5zdGFsbGVkKSB7XG4gICAgdmFyIGluc3RhbGxIYW5kbGVyID0gJ2hhbmRsZVVuY2F1Z2h0RXhjZXB0aW9ucycgaW4gb3B0aW9ucyA/XG4gICAgICBvcHRpb25zLmhhbmRsZVVuY2F1Z2h0RXhjZXB0aW9ucyA6IHRydWU7XG5cbiAgICAvLyBQcm92aWRlIHRoZSBvcHRpb24gdG8gbm90IGluc3RhbGwgdGhlIHVuY2F1Z2h0IGV4Y2VwdGlvbiBoYW5kbGVyLiBUaGlzIGlzXG4gICAgLy8gdG8gc3VwcG9ydCBvdGhlciB1bmNhdWdodCBleGNlcHRpb24gaGFuZGxlcnMgKGluIHRlc3QgZnJhbWV3b3JrcywgZm9yXG4gICAgLy8gZXhhbXBsZSkuIElmIHRoaXMgaGFuZGxlciBpcyBub3QgaW5zdGFsbGVkIGFuZCB0aGVyZSBhcmUgbm8gb3RoZXIgdW5jYXVnaHRcbiAgICAvLyBleGNlcHRpb24gaGFuZGxlcnMsIHVuY2F1Z2h0IGV4Y2VwdGlvbnMgd2lsbCBiZSBjYXVnaHQgYnkgbm9kZSdzIGJ1aWx0LWluXG4gICAgLy8gZXhjZXB0aW9uIGhhbmRsZXIgYW5kIHRoZSBwcm9jZXNzIHdpbGwgc3RpbGwgYmUgdGVybWluYXRlZC4gSG93ZXZlciwgdGhlXG4gICAgLy8gZ2VuZXJhdGVkIEphdmFTY3JpcHQgY29kZSB3aWxsIGJlIHNob3duIGFib3ZlIHRoZSBzdGFjayB0cmFjZSBpbnN0ZWFkIG9mXG4gICAgLy8gdGhlIG9yaWdpbmFsIHNvdXJjZSBjb2RlLlxuICAgIGlmIChpbnN0YWxsSGFuZGxlciAmJiBoYXNHbG9iYWxQcm9jZXNzRXZlbnRFbWl0dGVyKCkpIHtcbiAgICAgIHVuY2F1Z2h0U2hpbUluc3RhbGxlZCA9IHRydWU7XG4gICAgICBzaGltRW1pdFVuY2F1Z2h0RXhjZXB0aW9uKCk7XG4gICAgfVxuICB9XG59O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2VsZWN0cm9uLXVwZGF0ZXIvbm9kZV9tb2R1bGVzL3NvdXJjZS1tYXAtc3VwcG9ydC9zb3VyY2UtbWFwLXN1cHBvcnQuanMiLCIvKlxuICogQ29weXJpZ2h0IDIwMDktMjAxMSBNb3ppbGxhIEZvdW5kYXRpb24gYW5kIGNvbnRyaWJ1dG9yc1xuICogTGljZW5zZWQgdW5kZXIgdGhlIE5ldyBCU0QgbGljZW5zZS4gU2VlIExJQ0VOU0UudHh0IG9yOlxuICogaHR0cDovL29wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL0JTRC0zLUNsYXVzZVxuICovXG5leHBvcnRzLlNvdXJjZU1hcEdlbmVyYXRvciA9IHJlcXVpcmUoJy4vbGliL3NvdXJjZS1tYXAtZ2VuZXJhdG9yJykuU291cmNlTWFwR2VuZXJhdG9yO1xuZXhwb3J0cy5Tb3VyY2VNYXBDb25zdW1lciA9IHJlcXVpcmUoJy4vbGliL3NvdXJjZS1tYXAtY29uc3VtZXInKS5Tb3VyY2VNYXBDb25zdW1lcjtcbmV4cG9ydHMuU291cmNlTm9kZSA9IHJlcXVpcmUoJy4vbGliL3NvdXJjZS1ub2RlJykuU291cmNlTm9kZTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9lbGVjdHJvbi11cGRhdGVyL25vZGVfbW9kdWxlcy9zb3VyY2UtbWFwL3NvdXJjZS1tYXAuanMiLCIvKiAtKi0gTW9kZToganM7IGpzLWluZGVudC1sZXZlbDogMjsgLSotICovXG4vKlxuICogQ29weXJpZ2h0IDIwMTEgTW96aWxsYSBGb3VuZGF0aW9uIGFuZCBjb250cmlidXRvcnNcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBOZXcgQlNEIGxpY2Vuc2UuIFNlZSBMSUNFTlNFIG9yOlxuICogaHR0cDovL29wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL0JTRC0zLUNsYXVzZVxuICovXG5cbnZhciBpbnRUb0NoYXJNYXAgPSAnQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejAxMjM0NTY3ODkrLycuc3BsaXQoJycpO1xuXG4vKipcbiAqIEVuY29kZSBhbiBpbnRlZ2VyIGluIHRoZSByYW5nZSBvZiAwIHRvIDYzIHRvIGEgc2luZ2xlIGJhc2UgNjQgZGlnaXQuXG4gKi9cbmV4cG9ydHMuZW5jb2RlID0gZnVuY3Rpb24gKG51bWJlcikge1xuICBpZiAoMCA8PSBudW1iZXIgJiYgbnVtYmVyIDwgaW50VG9DaGFyTWFwLmxlbmd0aCkge1xuICAgIHJldHVybiBpbnRUb0NoYXJNYXBbbnVtYmVyXTtcbiAgfVxuICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiTXVzdCBiZSBiZXR3ZWVuIDAgYW5kIDYzOiBcIiArIG51bWJlcik7XG59O1xuXG4vKipcbiAqIERlY29kZSBhIHNpbmdsZSBiYXNlIDY0IGNoYXJhY3RlciBjb2RlIGRpZ2l0IHRvIGFuIGludGVnZXIuIFJldHVybnMgLTEgb25cbiAqIGZhaWx1cmUuXG4gKi9cbmV4cG9ydHMuZGVjb2RlID0gZnVuY3Rpb24gKGNoYXJDb2RlKSB7XG4gIHZhciBiaWdBID0gNjU7ICAgICAvLyAnQSdcbiAgdmFyIGJpZ1ogPSA5MDsgICAgIC8vICdaJ1xuXG4gIHZhciBsaXR0bGVBID0gOTc7ICAvLyAnYSdcbiAgdmFyIGxpdHRsZVogPSAxMjI7IC8vICd6J1xuXG4gIHZhciB6ZXJvID0gNDg7ICAgICAvLyAnMCdcbiAgdmFyIG5pbmUgPSA1NzsgICAgIC8vICc5J1xuXG4gIHZhciBwbHVzID0gNDM7ICAgICAvLyAnKydcbiAgdmFyIHNsYXNoID0gNDc7ICAgIC8vICcvJ1xuXG4gIHZhciBsaXR0bGVPZmZzZXQgPSAyNjtcbiAgdmFyIG51bWJlck9mZnNldCA9IDUyO1xuXG4gIC8vIDAgLSAyNTogQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVpcbiAgaWYgKGJpZ0EgPD0gY2hhckNvZGUgJiYgY2hhckNvZGUgPD0gYmlnWikge1xuICAgIHJldHVybiAoY2hhckNvZGUgLSBiaWdBKTtcbiAgfVxuXG4gIC8vIDI2IC0gNTE6IGFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6XG4gIGlmIChsaXR0bGVBIDw9IGNoYXJDb2RlICYmIGNoYXJDb2RlIDw9IGxpdHRsZVopIHtcbiAgICByZXR1cm4gKGNoYXJDb2RlIC0gbGl0dGxlQSArIGxpdHRsZU9mZnNldCk7XG4gIH1cblxuICAvLyA1MiAtIDYxOiAwMTIzNDU2Nzg5XG4gIGlmICh6ZXJvIDw9IGNoYXJDb2RlICYmIGNoYXJDb2RlIDw9IG5pbmUpIHtcbiAgICByZXR1cm4gKGNoYXJDb2RlIC0gemVybyArIG51bWJlck9mZnNldCk7XG4gIH1cblxuICAvLyA2MjogK1xuICBpZiAoY2hhckNvZGUgPT0gcGx1cykge1xuICAgIHJldHVybiA2MjtcbiAgfVxuXG4gIC8vIDYzOiAvXG4gIGlmIChjaGFyQ29kZSA9PSBzbGFzaCkge1xuICAgIHJldHVybiA2MztcbiAgfVxuXG4gIC8vIEludmFsaWQgYmFzZTY0IGRpZ2l0LlxuICByZXR1cm4gLTE7XG59O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2VsZWN0cm9uLXVwZGF0ZXIvbm9kZV9tb2R1bGVzL3NvdXJjZS1tYXAvbGliL2Jhc2U2NC5qcyIsIi8qIC0qLSBNb2RlOiBqczsganMtaW5kZW50LWxldmVsOiAyOyAtKi0gKi9cbi8qXG4gKiBDb3B5cmlnaHQgMjAxNCBNb3ppbGxhIEZvdW5kYXRpb24gYW5kIGNvbnRyaWJ1dG9yc1xuICogTGljZW5zZWQgdW5kZXIgdGhlIE5ldyBCU0QgbGljZW5zZS4gU2VlIExJQ0VOU0Ugb3I6XG4gKiBodHRwOi8vb3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvQlNELTMtQ2xhdXNlXG4gKi9cblxudmFyIHV0aWwgPSByZXF1aXJlKCcuL3V0aWwnKTtcblxuLyoqXG4gKiBEZXRlcm1pbmUgd2hldGhlciBtYXBwaW5nQiBpcyBhZnRlciBtYXBwaW5nQSB3aXRoIHJlc3BlY3QgdG8gZ2VuZXJhdGVkXG4gKiBwb3NpdGlvbi5cbiAqL1xuZnVuY3Rpb24gZ2VuZXJhdGVkUG9zaXRpb25BZnRlcihtYXBwaW5nQSwgbWFwcGluZ0IpIHtcbiAgLy8gT3B0aW1pemVkIGZvciBtb3N0IGNvbW1vbiBjYXNlXG4gIHZhciBsaW5lQSA9IG1hcHBpbmdBLmdlbmVyYXRlZExpbmU7XG4gIHZhciBsaW5lQiA9IG1hcHBpbmdCLmdlbmVyYXRlZExpbmU7XG4gIHZhciBjb2x1bW5BID0gbWFwcGluZ0EuZ2VuZXJhdGVkQ29sdW1uO1xuICB2YXIgY29sdW1uQiA9IG1hcHBpbmdCLmdlbmVyYXRlZENvbHVtbjtcbiAgcmV0dXJuIGxpbmVCID4gbGluZUEgfHwgbGluZUIgPT0gbGluZUEgJiYgY29sdW1uQiA+PSBjb2x1bW5BIHx8XG4gICAgICAgICB1dGlsLmNvbXBhcmVCeUdlbmVyYXRlZFBvc2l0aW9uc0luZmxhdGVkKG1hcHBpbmdBLCBtYXBwaW5nQikgPD0gMDtcbn1cblxuLyoqXG4gKiBBIGRhdGEgc3RydWN0dXJlIHRvIHByb3ZpZGUgYSBzb3J0ZWQgdmlldyBvZiBhY2N1bXVsYXRlZCBtYXBwaW5ncyBpbiBhXG4gKiBwZXJmb3JtYW5jZSBjb25zY2lvdXMgbWFubmVyLiBJdCB0cmFkZXMgYSBuZWdsaWJhYmxlIG92ZXJoZWFkIGluIGdlbmVyYWxcbiAqIGNhc2UgZm9yIGEgbGFyZ2Ugc3BlZWR1cCBpbiBjYXNlIG9mIG1hcHBpbmdzIGJlaW5nIGFkZGVkIGluIG9yZGVyLlxuICovXG5mdW5jdGlvbiBNYXBwaW5nTGlzdCgpIHtcbiAgdGhpcy5fYXJyYXkgPSBbXTtcbiAgdGhpcy5fc29ydGVkID0gdHJ1ZTtcbiAgLy8gU2VydmVzIGFzIGluZmltdW1cbiAgdGhpcy5fbGFzdCA9IHtnZW5lcmF0ZWRMaW5lOiAtMSwgZ2VuZXJhdGVkQ29sdW1uOiAwfTtcbn1cblxuLyoqXG4gKiBJdGVyYXRlIHRocm91Z2ggaW50ZXJuYWwgaXRlbXMuIFRoaXMgbWV0aG9kIHRha2VzIHRoZSBzYW1lIGFyZ3VtZW50cyB0aGF0XG4gKiBgQXJyYXkucHJvdG90eXBlLmZvckVhY2hgIHRha2VzLlxuICpcbiAqIE5PVEU6IFRoZSBvcmRlciBvZiB0aGUgbWFwcGluZ3MgaXMgTk9UIGd1YXJhbnRlZWQuXG4gKi9cbk1hcHBpbmdMaXN0LnByb3RvdHlwZS51bnNvcnRlZEZvckVhY2ggPVxuICBmdW5jdGlvbiBNYXBwaW5nTGlzdF9mb3JFYWNoKGFDYWxsYmFjaywgYVRoaXNBcmcpIHtcbiAgICB0aGlzLl9hcnJheS5mb3JFYWNoKGFDYWxsYmFjaywgYVRoaXNBcmcpO1xuICB9O1xuXG4vKipcbiAqIEFkZCB0aGUgZ2l2ZW4gc291cmNlIG1hcHBpbmcuXG4gKlxuICogQHBhcmFtIE9iamVjdCBhTWFwcGluZ1xuICovXG5NYXBwaW5nTGlzdC5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24gTWFwcGluZ0xpc3RfYWRkKGFNYXBwaW5nKSB7XG4gIGlmIChnZW5lcmF0ZWRQb3NpdGlvbkFmdGVyKHRoaXMuX2xhc3QsIGFNYXBwaW5nKSkge1xuICAgIHRoaXMuX2xhc3QgPSBhTWFwcGluZztcbiAgICB0aGlzLl9hcnJheS5wdXNoKGFNYXBwaW5nKTtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLl9zb3J0ZWQgPSBmYWxzZTtcbiAgICB0aGlzLl9hcnJheS5wdXNoKGFNYXBwaW5nKTtcbiAgfVxufTtcblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBmbGF0LCBzb3J0ZWQgYXJyYXkgb2YgbWFwcGluZ3MuIFRoZSBtYXBwaW5ncyBhcmUgc29ydGVkIGJ5XG4gKiBnZW5lcmF0ZWQgcG9zaXRpb24uXG4gKlxuICogV0FSTklORzogVGhpcyBtZXRob2QgcmV0dXJucyBpbnRlcm5hbCBkYXRhIHdpdGhvdXQgY29weWluZywgZm9yXG4gKiBwZXJmb3JtYW5jZS4gVGhlIHJldHVybiB2YWx1ZSBtdXN0IE5PVCBiZSBtdXRhdGVkLCBhbmQgc2hvdWxkIGJlIHRyZWF0ZWQgYXNcbiAqIGFuIGltbXV0YWJsZSBib3Jyb3cuIElmIHlvdSB3YW50IHRvIHRha2Ugb3duZXJzaGlwLCB5b3UgbXVzdCBtYWtlIHlvdXIgb3duXG4gKiBjb3B5LlxuICovXG5NYXBwaW5nTGlzdC5wcm90b3R5cGUudG9BcnJheSA9IGZ1bmN0aW9uIE1hcHBpbmdMaXN0X3RvQXJyYXkoKSB7XG4gIGlmICghdGhpcy5fc29ydGVkKSB7XG4gICAgdGhpcy5fYXJyYXkuc29ydCh1dGlsLmNvbXBhcmVCeUdlbmVyYXRlZFBvc2l0aW9uc0luZmxhdGVkKTtcbiAgICB0aGlzLl9zb3J0ZWQgPSB0cnVlO1xuICB9XG4gIHJldHVybiB0aGlzLl9hcnJheTtcbn07XG5cbmV4cG9ydHMuTWFwcGluZ0xpc3QgPSBNYXBwaW5nTGlzdDtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9lbGVjdHJvbi11cGRhdGVyL25vZGVfbW9kdWxlcy9zb3VyY2UtbWFwL2xpYi9tYXBwaW5nLWxpc3QuanMiLCIvKiAtKi0gTW9kZToganM7IGpzLWluZGVudC1sZXZlbDogMjsgLSotICovXG4vKlxuICogQ29weXJpZ2h0IDIwMTEgTW96aWxsYSBGb3VuZGF0aW9uIGFuZCBjb250cmlidXRvcnNcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBOZXcgQlNEIGxpY2Vuc2UuIFNlZSBMSUNFTlNFIG9yOlxuICogaHR0cDovL29wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL0JTRC0zLUNsYXVzZVxuICovXG5cbnZhciB1dGlsID0gcmVxdWlyZSgnLi91dGlsJyk7XG52YXIgYmluYXJ5U2VhcmNoID0gcmVxdWlyZSgnLi9iaW5hcnktc2VhcmNoJyk7XG52YXIgQXJyYXlTZXQgPSByZXF1aXJlKCcuL2FycmF5LXNldCcpLkFycmF5U2V0O1xudmFyIGJhc2U2NFZMUSA9IHJlcXVpcmUoJy4vYmFzZTY0LXZscScpO1xudmFyIHF1aWNrU29ydCA9IHJlcXVpcmUoJy4vcXVpY2stc29ydCcpLnF1aWNrU29ydDtcblxuZnVuY3Rpb24gU291cmNlTWFwQ29uc3VtZXIoYVNvdXJjZU1hcCwgYVNvdXJjZU1hcFVSTCkge1xuICB2YXIgc291cmNlTWFwID0gYVNvdXJjZU1hcDtcbiAgaWYgKHR5cGVvZiBhU291cmNlTWFwID09PSAnc3RyaW5nJykge1xuICAgIHNvdXJjZU1hcCA9IHV0aWwucGFyc2VTb3VyY2VNYXBJbnB1dChhU291cmNlTWFwKTtcbiAgfVxuXG4gIHJldHVybiBzb3VyY2VNYXAuc2VjdGlvbnMgIT0gbnVsbFxuICAgID8gbmV3IEluZGV4ZWRTb3VyY2VNYXBDb25zdW1lcihzb3VyY2VNYXAsIGFTb3VyY2VNYXBVUkwpXG4gICAgOiBuZXcgQmFzaWNTb3VyY2VNYXBDb25zdW1lcihzb3VyY2VNYXAsIGFTb3VyY2VNYXBVUkwpO1xufVxuXG5Tb3VyY2VNYXBDb25zdW1lci5mcm9tU291cmNlTWFwID0gZnVuY3Rpb24oYVNvdXJjZU1hcCwgYVNvdXJjZU1hcFVSTCkge1xuICByZXR1cm4gQmFzaWNTb3VyY2VNYXBDb25zdW1lci5mcm9tU291cmNlTWFwKGFTb3VyY2VNYXAsIGFTb3VyY2VNYXBVUkwpO1xufVxuXG4vKipcbiAqIFRoZSB2ZXJzaW9uIG9mIHRoZSBzb3VyY2UgbWFwcGluZyBzcGVjIHRoYXQgd2UgYXJlIGNvbnN1bWluZy5cbiAqL1xuU291cmNlTWFwQ29uc3VtZXIucHJvdG90eXBlLl92ZXJzaW9uID0gMztcblxuLy8gYF9fZ2VuZXJhdGVkTWFwcGluZ3NgIGFuZCBgX19vcmlnaW5hbE1hcHBpbmdzYCBhcmUgYXJyYXlzIHRoYXQgaG9sZCB0aGVcbi8vIHBhcnNlZCBtYXBwaW5nIGNvb3JkaW5hdGVzIGZyb20gdGhlIHNvdXJjZSBtYXAncyBcIm1hcHBpbmdzXCIgYXR0cmlidXRlLiBUaGV5XG4vLyBhcmUgbGF6aWx5IGluc3RhbnRpYXRlZCwgYWNjZXNzZWQgdmlhIHRoZSBgX2dlbmVyYXRlZE1hcHBpbmdzYCBhbmRcbi8vIGBfb3JpZ2luYWxNYXBwaW5nc2AgZ2V0dGVycyByZXNwZWN0aXZlbHksIGFuZCB3ZSBvbmx5IHBhcnNlIHRoZSBtYXBwaW5nc1xuLy8gYW5kIGNyZWF0ZSB0aGVzZSBhcnJheXMgb25jZSBxdWVyaWVkIGZvciBhIHNvdXJjZSBsb2NhdGlvbi4gV2UganVtcCB0aHJvdWdoXG4vLyB0aGVzZSBob29wcyBiZWNhdXNlIHRoZXJlIGNhbiBiZSBtYW55IHRob3VzYW5kcyBvZiBtYXBwaW5ncywgYW5kIHBhcnNpbmdcbi8vIHRoZW0gaXMgZXhwZW5zaXZlLCBzbyB3ZSBvbmx5IHdhbnQgdG8gZG8gaXQgaWYgd2UgbXVzdC5cbi8vXG4vLyBFYWNoIG9iamVjdCBpbiB0aGUgYXJyYXlzIGlzIG9mIHRoZSBmb3JtOlxuLy9cbi8vICAgICB7XG4vLyAgICAgICBnZW5lcmF0ZWRMaW5lOiBUaGUgbGluZSBudW1iZXIgaW4gdGhlIGdlbmVyYXRlZCBjb2RlLFxuLy8gICAgICAgZ2VuZXJhdGVkQ29sdW1uOiBUaGUgY29sdW1uIG51bWJlciBpbiB0aGUgZ2VuZXJhdGVkIGNvZGUsXG4vLyAgICAgICBzb3VyY2U6IFRoZSBwYXRoIHRvIHRoZSBvcmlnaW5hbCBzb3VyY2UgZmlsZSB0aGF0IGdlbmVyYXRlZCB0aGlzXG4vLyAgICAgICAgICAgICAgIGNodW5rIG9mIGNvZGUsXG4vLyAgICAgICBvcmlnaW5hbExpbmU6IFRoZSBsaW5lIG51bWJlciBpbiB0aGUgb3JpZ2luYWwgc291cmNlIHRoYXRcbi8vICAgICAgICAgICAgICAgICAgICAgY29ycmVzcG9uZHMgdG8gdGhpcyBjaHVuayBvZiBnZW5lcmF0ZWQgY29kZSxcbi8vICAgICAgIG9yaWdpbmFsQ29sdW1uOiBUaGUgY29sdW1uIG51bWJlciBpbiB0aGUgb3JpZ2luYWwgc291cmNlIHRoYXRcbi8vICAgICAgICAgICAgICAgICAgICAgICBjb3JyZXNwb25kcyB0byB0aGlzIGNodW5rIG9mIGdlbmVyYXRlZCBjb2RlLFxuLy8gICAgICAgbmFtZTogVGhlIG5hbWUgb2YgdGhlIG9yaWdpbmFsIHN5bWJvbCB3aGljaCBnZW5lcmF0ZWQgdGhpcyBjaHVuayBvZlxuLy8gICAgICAgICAgICAgY29kZS5cbi8vICAgICB9XG4vL1xuLy8gQWxsIHByb3BlcnRpZXMgZXhjZXB0IGZvciBgZ2VuZXJhdGVkTGluZWAgYW5kIGBnZW5lcmF0ZWRDb2x1bW5gIGNhbiBiZVxuLy8gYG51bGxgLlxuLy9cbi8vIGBfZ2VuZXJhdGVkTWFwcGluZ3NgIGlzIG9yZGVyZWQgYnkgdGhlIGdlbmVyYXRlZCBwb3NpdGlvbnMuXG4vL1xuLy8gYF9vcmlnaW5hbE1hcHBpbmdzYCBpcyBvcmRlcmVkIGJ5IHRoZSBvcmlnaW5hbCBwb3NpdGlvbnMuXG5cblNvdXJjZU1hcENvbnN1bWVyLnByb3RvdHlwZS5fX2dlbmVyYXRlZE1hcHBpbmdzID0gbnVsbDtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShTb3VyY2VNYXBDb25zdW1lci5wcm90b3R5cGUsICdfZ2VuZXJhdGVkTWFwcGluZ3MnLCB7XG4gIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKCF0aGlzLl9fZ2VuZXJhdGVkTWFwcGluZ3MpIHtcbiAgICAgIHRoaXMuX3BhcnNlTWFwcGluZ3ModGhpcy5fbWFwcGluZ3MsIHRoaXMuc291cmNlUm9vdCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuX19nZW5lcmF0ZWRNYXBwaW5ncztcbiAgfVxufSk7XG5cblNvdXJjZU1hcENvbnN1bWVyLnByb3RvdHlwZS5fX29yaWdpbmFsTWFwcGluZ3MgPSBudWxsO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KFNvdXJjZU1hcENvbnN1bWVyLnByb3RvdHlwZSwgJ19vcmlnaW5hbE1hcHBpbmdzJywge1xuICBjb25maWd1cmFibGU6IHRydWUsXG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIGlmICghdGhpcy5fX29yaWdpbmFsTWFwcGluZ3MpIHtcbiAgICAgIHRoaXMuX3BhcnNlTWFwcGluZ3ModGhpcy5fbWFwcGluZ3MsIHRoaXMuc291cmNlUm9vdCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuX19vcmlnaW5hbE1hcHBpbmdzO1xuICB9XG59KTtcblxuU291cmNlTWFwQ29uc3VtZXIucHJvdG90eXBlLl9jaGFySXNNYXBwaW5nU2VwYXJhdG9yID1cbiAgZnVuY3Rpb24gU291cmNlTWFwQ29uc3VtZXJfY2hhcklzTWFwcGluZ1NlcGFyYXRvcihhU3RyLCBpbmRleCkge1xuICAgIHZhciBjID0gYVN0ci5jaGFyQXQoaW5kZXgpO1xuICAgIHJldHVybiBjID09PSBcIjtcIiB8fCBjID09PSBcIixcIjtcbiAgfTtcblxuLyoqXG4gKiBQYXJzZSB0aGUgbWFwcGluZ3MgaW4gYSBzdHJpbmcgaW4gdG8gYSBkYXRhIHN0cnVjdHVyZSB3aGljaCB3ZSBjYW4gZWFzaWx5XG4gKiBxdWVyeSAodGhlIG9yZGVyZWQgYXJyYXlzIGluIHRoZSBgdGhpcy5fX2dlbmVyYXRlZE1hcHBpbmdzYCBhbmRcbiAqIGB0aGlzLl9fb3JpZ2luYWxNYXBwaW5nc2AgcHJvcGVydGllcykuXG4gKi9cblNvdXJjZU1hcENvbnN1bWVyLnByb3RvdHlwZS5fcGFyc2VNYXBwaW5ncyA9XG4gIGZ1bmN0aW9uIFNvdXJjZU1hcENvbnN1bWVyX3BhcnNlTWFwcGluZ3MoYVN0ciwgYVNvdXJjZVJvb3QpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJTdWJjbGFzc2VzIG11c3QgaW1wbGVtZW50IF9wYXJzZU1hcHBpbmdzXCIpO1xuICB9O1xuXG5Tb3VyY2VNYXBDb25zdW1lci5HRU5FUkFURURfT1JERVIgPSAxO1xuU291cmNlTWFwQ29uc3VtZXIuT1JJR0lOQUxfT1JERVIgPSAyO1xuXG5Tb3VyY2VNYXBDb25zdW1lci5HUkVBVEVTVF9MT1dFUl9CT1VORCA9IDE7XG5Tb3VyY2VNYXBDb25zdW1lci5MRUFTVF9VUFBFUl9CT1VORCA9IDI7XG5cbi8qKlxuICogSXRlcmF0ZSBvdmVyIGVhY2ggbWFwcGluZyBiZXR3ZWVuIGFuIG9yaWdpbmFsIHNvdXJjZS9saW5lL2NvbHVtbiBhbmQgYVxuICogZ2VuZXJhdGVkIGxpbmUvY29sdW1uIGluIHRoaXMgc291cmNlIG1hcC5cbiAqXG4gKiBAcGFyYW0gRnVuY3Rpb24gYUNhbGxiYWNrXG4gKiAgICAgICAgVGhlIGZ1bmN0aW9uIHRoYXQgaXMgY2FsbGVkIHdpdGggZWFjaCBtYXBwaW5nLlxuICogQHBhcmFtIE9iamVjdCBhQ29udGV4dFxuICogICAgICAgIE9wdGlvbmFsLiBJZiBzcGVjaWZpZWQsIHRoaXMgb2JqZWN0IHdpbGwgYmUgdGhlIHZhbHVlIG9mIGB0aGlzYCBldmVyeVxuICogICAgICAgIHRpbWUgdGhhdCBgYUNhbGxiYWNrYCBpcyBjYWxsZWQuXG4gKiBAcGFyYW0gYU9yZGVyXG4gKiAgICAgICAgRWl0aGVyIGBTb3VyY2VNYXBDb25zdW1lci5HRU5FUkFURURfT1JERVJgIG9yXG4gKiAgICAgICAgYFNvdXJjZU1hcENvbnN1bWVyLk9SSUdJTkFMX09SREVSYC4gU3BlY2lmaWVzIHdoZXRoZXIgeW91IHdhbnQgdG9cbiAqICAgICAgICBpdGVyYXRlIG92ZXIgdGhlIG1hcHBpbmdzIHNvcnRlZCBieSB0aGUgZ2VuZXJhdGVkIGZpbGUncyBsaW5lL2NvbHVtblxuICogICAgICAgIG9yZGVyIG9yIHRoZSBvcmlnaW5hbCdzIHNvdXJjZS9saW5lL2NvbHVtbiBvcmRlciwgcmVzcGVjdGl2ZWx5LiBEZWZhdWx0cyB0b1xuICogICAgICAgIGBTb3VyY2VNYXBDb25zdW1lci5HRU5FUkFURURfT1JERVJgLlxuICovXG5Tb3VyY2VNYXBDb25zdW1lci5wcm90b3R5cGUuZWFjaE1hcHBpbmcgPVxuICBmdW5jdGlvbiBTb3VyY2VNYXBDb25zdW1lcl9lYWNoTWFwcGluZyhhQ2FsbGJhY2ssIGFDb250ZXh0LCBhT3JkZXIpIHtcbiAgICB2YXIgY29udGV4dCA9IGFDb250ZXh0IHx8IG51bGw7XG4gICAgdmFyIG9yZGVyID0gYU9yZGVyIHx8IFNvdXJjZU1hcENvbnN1bWVyLkdFTkVSQVRFRF9PUkRFUjtcblxuICAgIHZhciBtYXBwaW5ncztcbiAgICBzd2l0Y2ggKG9yZGVyKSB7XG4gICAgY2FzZSBTb3VyY2VNYXBDb25zdW1lci5HRU5FUkFURURfT1JERVI6XG4gICAgICBtYXBwaW5ncyA9IHRoaXMuX2dlbmVyYXRlZE1hcHBpbmdzO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBTb3VyY2VNYXBDb25zdW1lci5PUklHSU5BTF9PUkRFUjpcbiAgICAgIG1hcHBpbmdzID0gdGhpcy5fb3JpZ2luYWxNYXBwaW5ncztcbiAgICAgIGJyZWFrO1xuICAgIGRlZmF1bHQ6XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmtub3duIG9yZGVyIG9mIGl0ZXJhdGlvbi5cIik7XG4gICAgfVxuXG4gICAgdmFyIHNvdXJjZVJvb3QgPSB0aGlzLnNvdXJjZVJvb3Q7XG4gICAgbWFwcGluZ3MubWFwKGZ1bmN0aW9uIChtYXBwaW5nKSB7XG4gICAgICB2YXIgc291cmNlID0gbWFwcGluZy5zb3VyY2UgPT09IG51bGwgPyBudWxsIDogdGhpcy5fc291cmNlcy5hdChtYXBwaW5nLnNvdXJjZSk7XG4gICAgICBzb3VyY2UgPSB1dGlsLmNvbXB1dGVTb3VyY2VVUkwoc291cmNlUm9vdCwgc291cmNlLCB0aGlzLl9zb3VyY2VNYXBVUkwpO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgc291cmNlOiBzb3VyY2UsXG4gICAgICAgIGdlbmVyYXRlZExpbmU6IG1hcHBpbmcuZ2VuZXJhdGVkTGluZSxcbiAgICAgICAgZ2VuZXJhdGVkQ29sdW1uOiBtYXBwaW5nLmdlbmVyYXRlZENvbHVtbixcbiAgICAgICAgb3JpZ2luYWxMaW5lOiBtYXBwaW5nLm9yaWdpbmFsTGluZSxcbiAgICAgICAgb3JpZ2luYWxDb2x1bW46IG1hcHBpbmcub3JpZ2luYWxDb2x1bW4sXG4gICAgICAgIG5hbWU6IG1hcHBpbmcubmFtZSA9PT0gbnVsbCA/IG51bGwgOiB0aGlzLl9uYW1lcy5hdChtYXBwaW5nLm5hbWUpXG4gICAgICB9O1xuICAgIH0sIHRoaXMpLmZvckVhY2goYUNhbGxiYWNrLCBjb250ZXh0KTtcbiAgfTtcblxuLyoqXG4gKiBSZXR1cm5zIGFsbCBnZW5lcmF0ZWQgbGluZSBhbmQgY29sdW1uIGluZm9ybWF0aW9uIGZvciB0aGUgb3JpZ2luYWwgc291cmNlLFxuICogbGluZSwgYW5kIGNvbHVtbiBwcm92aWRlZC4gSWYgbm8gY29sdW1uIGlzIHByb3ZpZGVkLCByZXR1cm5zIGFsbCBtYXBwaW5nc1xuICogY29ycmVzcG9uZGluZyB0byBhIGVpdGhlciB0aGUgbGluZSB3ZSBhcmUgc2VhcmNoaW5nIGZvciBvciB0aGUgbmV4dFxuICogY2xvc2VzdCBsaW5lIHRoYXQgaGFzIGFueSBtYXBwaW5ncy4gT3RoZXJ3aXNlLCByZXR1cm5zIGFsbCBtYXBwaW5nc1xuICogY29ycmVzcG9uZGluZyB0byB0aGUgZ2l2ZW4gbGluZSBhbmQgZWl0aGVyIHRoZSBjb2x1bW4gd2UgYXJlIHNlYXJjaGluZyBmb3JcbiAqIG9yIHRoZSBuZXh0IGNsb3Nlc3QgY29sdW1uIHRoYXQgaGFzIGFueSBvZmZzZXRzLlxuICpcbiAqIFRoZSBvbmx5IGFyZ3VtZW50IGlzIGFuIG9iamVjdCB3aXRoIHRoZSBmb2xsb3dpbmcgcHJvcGVydGllczpcbiAqXG4gKiAgIC0gc291cmNlOiBUaGUgZmlsZW5hbWUgb2YgdGhlIG9yaWdpbmFsIHNvdXJjZS5cbiAqICAgLSBsaW5lOiBUaGUgbGluZSBudW1iZXIgaW4gdGhlIG9yaWdpbmFsIHNvdXJjZS4gIFRoZSBsaW5lIG51bWJlciBpcyAxLWJhc2VkLlxuICogICAtIGNvbHVtbjogT3B0aW9uYWwuIHRoZSBjb2x1bW4gbnVtYmVyIGluIHRoZSBvcmlnaW5hbCBzb3VyY2UuXG4gKiAgICBUaGUgY29sdW1uIG51bWJlciBpcyAwLWJhc2VkLlxuICpcbiAqIGFuZCBhbiBhcnJheSBvZiBvYmplY3RzIGlzIHJldHVybmVkLCBlYWNoIHdpdGggdGhlIGZvbGxvd2luZyBwcm9wZXJ0aWVzOlxuICpcbiAqICAgLSBsaW5lOiBUaGUgbGluZSBudW1iZXIgaW4gdGhlIGdlbmVyYXRlZCBzb3VyY2UsIG9yIG51bGwuICBUaGVcbiAqICAgIGxpbmUgbnVtYmVyIGlzIDEtYmFzZWQuXG4gKiAgIC0gY29sdW1uOiBUaGUgY29sdW1uIG51bWJlciBpbiB0aGUgZ2VuZXJhdGVkIHNvdXJjZSwgb3IgbnVsbC5cbiAqICAgIFRoZSBjb2x1bW4gbnVtYmVyIGlzIDAtYmFzZWQuXG4gKi9cblNvdXJjZU1hcENvbnN1bWVyLnByb3RvdHlwZS5hbGxHZW5lcmF0ZWRQb3NpdGlvbnNGb3IgPVxuICBmdW5jdGlvbiBTb3VyY2VNYXBDb25zdW1lcl9hbGxHZW5lcmF0ZWRQb3NpdGlvbnNGb3IoYUFyZ3MpIHtcbiAgICB2YXIgbGluZSA9IHV0aWwuZ2V0QXJnKGFBcmdzLCAnbGluZScpO1xuXG4gICAgLy8gV2hlbiB0aGVyZSBpcyBubyBleGFjdCBtYXRjaCwgQmFzaWNTb3VyY2VNYXBDb25zdW1lci5wcm90b3R5cGUuX2ZpbmRNYXBwaW5nXG4gICAgLy8gcmV0dXJucyB0aGUgaW5kZXggb2YgdGhlIGNsb3Nlc3QgbWFwcGluZyBsZXNzIHRoYW4gdGhlIG5lZWRsZS4gQnlcbiAgICAvLyBzZXR0aW5nIG5lZWRsZS5vcmlnaW5hbENvbHVtbiB0byAwLCB3ZSB0aHVzIGZpbmQgdGhlIGxhc3QgbWFwcGluZyBmb3JcbiAgICAvLyB0aGUgZ2l2ZW4gbGluZSwgcHJvdmlkZWQgc3VjaCBhIG1hcHBpbmcgZXhpc3RzLlxuICAgIHZhciBuZWVkbGUgPSB7XG4gICAgICBzb3VyY2U6IHV0aWwuZ2V0QXJnKGFBcmdzLCAnc291cmNlJyksXG4gICAgICBvcmlnaW5hbExpbmU6IGxpbmUsXG4gICAgICBvcmlnaW5hbENvbHVtbjogdXRpbC5nZXRBcmcoYUFyZ3MsICdjb2x1bW4nLCAwKVxuICAgIH07XG5cbiAgICBuZWVkbGUuc291cmNlID0gdGhpcy5fZmluZFNvdXJjZUluZGV4KG5lZWRsZS5zb3VyY2UpO1xuICAgIGlmIChuZWVkbGUuc291cmNlIDwgMCkge1xuICAgICAgcmV0dXJuIFtdO1xuICAgIH1cblxuICAgIHZhciBtYXBwaW5ncyA9IFtdO1xuXG4gICAgdmFyIGluZGV4ID0gdGhpcy5fZmluZE1hcHBpbmcobmVlZGxlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX29yaWdpbmFsTWFwcGluZ3MsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJvcmlnaW5hbExpbmVcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIm9yaWdpbmFsQ29sdW1uXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdXRpbC5jb21wYXJlQnlPcmlnaW5hbFBvc2l0aW9ucyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBiaW5hcnlTZWFyY2guTEVBU1RfVVBQRVJfQk9VTkQpO1xuICAgIGlmIChpbmRleCA+PSAwKSB7XG4gICAgICB2YXIgbWFwcGluZyA9IHRoaXMuX29yaWdpbmFsTWFwcGluZ3NbaW5kZXhdO1xuXG4gICAgICBpZiAoYUFyZ3MuY29sdW1uID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdmFyIG9yaWdpbmFsTGluZSA9IG1hcHBpbmcub3JpZ2luYWxMaW5lO1xuXG4gICAgICAgIC8vIEl0ZXJhdGUgdW50aWwgZWl0aGVyIHdlIHJ1biBvdXQgb2YgbWFwcGluZ3MsIG9yIHdlIHJ1biBpbnRvXG4gICAgICAgIC8vIGEgbWFwcGluZyBmb3IgYSBkaWZmZXJlbnQgbGluZSB0aGFuIHRoZSBvbmUgd2UgZm91bmQuIFNpbmNlXG4gICAgICAgIC8vIG1hcHBpbmdzIGFyZSBzb3J0ZWQsIHRoaXMgaXMgZ3VhcmFudGVlZCB0byBmaW5kIGFsbCBtYXBwaW5ncyBmb3JcbiAgICAgICAgLy8gdGhlIGxpbmUgd2UgZm91bmQuXG4gICAgICAgIHdoaWxlIChtYXBwaW5nICYmIG1hcHBpbmcub3JpZ2luYWxMaW5lID09PSBvcmlnaW5hbExpbmUpIHtcbiAgICAgICAgICBtYXBwaW5ncy5wdXNoKHtcbiAgICAgICAgICAgIGxpbmU6IHV0aWwuZ2V0QXJnKG1hcHBpbmcsICdnZW5lcmF0ZWRMaW5lJywgbnVsbCksXG4gICAgICAgICAgICBjb2x1bW46IHV0aWwuZ2V0QXJnKG1hcHBpbmcsICdnZW5lcmF0ZWRDb2x1bW4nLCBudWxsKSxcbiAgICAgICAgICAgIGxhc3RDb2x1bW46IHV0aWwuZ2V0QXJnKG1hcHBpbmcsICdsYXN0R2VuZXJhdGVkQ29sdW1uJywgbnVsbClcbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIG1hcHBpbmcgPSB0aGlzLl9vcmlnaW5hbE1hcHBpbmdzWysraW5kZXhdO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgb3JpZ2luYWxDb2x1bW4gPSBtYXBwaW5nLm9yaWdpbmFsQ29sdW1uO1xuXG4gICAgICAgIC8vIEl0ZXJhdGUgdW50aWwgZWl0aGVyIHdlIHJ1biBvdXQgb2YgbWFwcGluZ3MsIG9yIHdlIHJ1biBpbnRvXG4gICAgICAgIC8vIGEgbWFwcGluZyBmb3IgYSBkaWZmZXJlbnQgbGluZSB0aGFuIHRoZSBvbmUgd2Ugd2VyZSBzZWFyY2hpbmcgZm9yLlxuICAgICAgICAvLyBTaW5jZSBtYXBwaW5ncyBhcmUgc29ydGVkLCB0aGlzIGlzIGd1YXJhbnRlZWQgdG8gZmluZCBhbGwgbWFwcGluZ3MgZm9yXG4gICAgICAgIC8vIHRoZSBsaW5lIHdlIGFyZSBzZWFyY2hpbmcgZm9yLlxuICAgICAgICB3aGlsZSAobWFwcGluZyAmJlxuICAgICAgICAgICAgICAgbWFwcGluZy5vcmlnaW5hbExpbmUgPT09IGxpbmUgJiZcbiAgICAgICAgICAgICAgIG1hcHBpbmcub3JpZ2luYWxDb2x1bW4gPT0gb3JpZ2luYWxDb2x1bW4pIHtcbiAgICAgICAgICBtYXBwaW5ncy5wdXNoKHtcbiAgICAgICAgICAgIGxpbmU6IHV0aWwuZ2V0QXJnKG1hcHBpbmcsICdnZW5lcmF0ZWRMaW5lJywgbnVsbCksXG4gICAgICAgICAgICBjb2x1bW46IHV0aWwuZ2V0QXJnKG1hcHBpbmcsICdnZW5lcmF0ZWRDb2x1bW4nLCBudWxsKSxcbiAgICAgICAgICAgIGxhc3RDb2x1bW46IHV0aWwuZ2V0QXJnKG1hcHBpbmcsICdsYXN0R2VuZXJhdGVkQ29sdW1uJywgbnVsbClcbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIG1hcHBpbmcgPSB0aGlzLl9vcmlnaW5hbE1hcHBpbmdzWysraW5kZXhdO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIG1hcHBpbmdzO1xuICB9O1xuXG5leHBvcnRzLlNvdXJjZU1hcENvbnN1bWVyID0gU291cmNlTWFwQ29uc3VtZXI7XG5cbi8qKlxuICogQSBCYXNpY1NvdXJjZU1hcENvbnN1bWVyIGluc3RhbmNlIHJlcHJlc2VudHMgYSBwYXJzZWQgc291cmNlIG1hcCB3aGljaCB3ZSBjYW5cbiAqIHF1ZXJ5IGZvciBpbmZvcm1hdGlvbiBhYm91dCB0aGUgb3JpZ2luYWwgZmlsZSBwb3NpdGlvbnMgYnkgZ2l2aW5nIGl0IGEgZmlsZVxuICogcG9zaXRpb24gaW4gdGhlIGdlbmVyYXRlZCBzb3VyY2UuXG4gKlxuICogVGhlIGZpcnN0IHBhcmFtZXRlciBpcyB0aGUgcmF3IHNvdXJjZSBtYXAgKGVpdGhlciBhcyBhIEpTT04gc3RyaW5nLCBvclxuICogYWxyZWFkeSBwYXJzZWQgdG8gYW4gb2JqZWN0KS4gQWNjb3JkaW5nIHRvIHRoZSBzcGVjLCBzb3VyY2UgbWFwcyBoYXZlIHRoZVxuICogZm9sbG93aW5nIGF0dHJpYnV0ZXM6XG4gKlxuICogICAtIHZlcnNpb246IFdoaWNoIHZlcnNpb24gb2YgdGhlIHNvdXJjZSBtYXAgc3BlYyB0aGlzIG1hcCBpcyBmb2xsb3dpbmcuXG4gKiAgIC0gc291cmNlczogQW4gYXJyYXkgb2YgVVJMcyB0byB0aGUgb3JpZ2luYWwgc291cmNlIGZpbGVzLlxuICogICAtIG5hbWVzOiBBbiBhcnJheSBvZiBpZGVudGlmaWVycyB3aGljaCBjYW4gYmUgcmVmZXJyZW5jZWQgYnkgaW5kaXZpZHVhbCBtYXBwaW5ncy5cbiAqICAgLSBzb3VyY2VSb290OiBPcHRpb25hbC4gVGhlIFVSTCByb290IGZyb20gd2hpY2ggYWxsIHNvdXJjZXMgYXJlIHJlbGF0aXZlLlxuICogICAtIHNvdXJjZXNDb250ZW50OiBPcHRpb25hbC4gQW4gYXJyYXkgb2YgY29udGVudHMgb2YgdGhlIG9yaWdpbmFsIHNvdXJjZSBmaWxlcy5cbiAqICAgLSBtYXBwaW5nczogQSBzdHJpbmcgb2YgYmFzZTY0IFZMUXMgd2hpY2ggY29udGFpbiB0aGUgYWN0dWFsIG1hcHBpbmdzLlxuICogICAtIGZpbGU6IE9wdGlvbmFsLiBUaGUgZ2VuZXJhdGVkIGZpbGUgdGhpcyBzb3VyY2UgbWFwIGlzIGFzc29jaWF0ZWQgd2l0aC5cbiAqXG4gKiBIZXJlIGlzIGFuIGV4YW1wbGUgc291cmNlIG1hcCwgdGFrZW4gZnJvbSB0aGUgc291cmNlIG1hcCBzcGVjWzBdOlxuICpcbiAqICAgICB7XG4gKiAgICAgICB2ZXJzaW9uIDogMyxcbiAqICAgICAgIGZpbGU6IFwib3V0LmpzXCIsXG4gKiAgICAgICBzb3VyY2VSb290IDogXCJcIixcbiAqICAgICAgIHNvdXJjZXM6IFtcImZvby5qc1wiLCBcImJhci5qc1wiXSxcbiAqICAgICAgIG5hbWVzOiBbXCJzcmNcIiwgXCJtYXBzXCIsIFwiYXJlXCIsIFwiZnVuXCJdLFxuICogICAgICAgbWFwcGluZ3M6IFwiQUEsQUI7O0FCQ0RFO1wiXG4gKiAgICAgfVxuICpcbiAqIFRoZSBzZWNvbmQgcGFyYW1ldGVyLCBpZiBnaXZlbiwgaXMgYSBzdHJpbmcgd2hvc2UgdmFsdWUgaXMgdGhlIFVSTFxuICogYXQgd2hpY2ggdGhlIHNvdXJjZSBtYXAgd2FzIGZvdW5kLiAgVGhpcyBVUkwgaXMgdXNlZCB0byBjb21wdXRlIHRoZVxuICogc291cmNlcyBhcnJheS5cbiAqXG4gKiBbMF06IGh0dHBzOi8vZG9jcy5nb29nbGUuY29tL2RvY3VtZW50L2QvMVUxUkdBZWhRd1J5cFVUb3ZGMUtSbHBpT0Z6ZTBiLV8yZ2M2ZkFIMEtZMGsvZWRpdD9wbGk9MSNcbiAqL1xuZnVuY3Rpb24gQmFzaWNTb3VyY2VNYXBDb25zdW1lcihhU291cmNlTWFwLCBhU291cmNlTWFwVVJMKSB7XG4gIHZhciBzb3VyY2VNYXAgPSBhU291cmNlTWFwO1xuICBpZiAodHlwZW9mIGFTb3VyY2VNYXAgPT09ICdzdHJpbmcnKSB7XG4gICAgc291cmNlTWFwID0gdXRpbC5wYXJzZVNvdXJjZU1hcElucHV0KGFTb3VyY2VNYXApO1xuICB9XG5cbiAgdmFyIHZlcnNpb24gPSB1dGlsLmdldEFyZyhzb3VyY2VNYXAsICd2ZXJzaW9uJyk7XG4gIHZhciBzb3VyY2VzID0gdXRpbC5nZXRBcmcoc291cmNlTWFwLCAnc291cmNlcycpO1xuICAvLyBTYXNzIDMuMyBsZWF2ZXMgb3V0IHRoZSAnbmFtZXMnIGFycmF5LCBzbyB3ZSBkZXZpYXRlIGZyb20gdGhlIHNwZWMgKHdoaWNoXG4gIC8vIHJlcXVpcmVzIHRoZSBhcnJheSkgdG8gcGxheSBuaWNlIGhlcmUuXG4gIHZhciBuYW1lcyA9IHV0aWwuZ2V0QXJnKHNvdXJjZU1hcCwgJ25hbWVzJywgW10pO1xuICB2YXIgc291cmNlUm9vdCA9IHV0aWwuZ2V0QXJnKHNvdXJjZU1hcCwgJ3NvdXJjZVJvb3QnLCBudWxsKTtcbiAgdmFyIHNvdXJjZXNDb250ZW50ID0gdXRpbC5nZXRBcmcoc291cmNlTWFwLCAnc291cmNlc0NvbnRlbnQnLCBudWxsKTtcbiAgdmFyIG1hcHBpbmdzID0gdXRpbC5nZXRBcmcoc291cmNlTWFwLCAnbWFwcGluZ3MnKTtcbiAgdmFyIGZpbGUgPSB1dGlsLmdldEFyZyhzb3VyY2VNYXAsICdmaWxlJywgbnVsbCk7XG5cbiAgLy8gT25jZSBhZ2FpbiwgU2FzcyBkZXZpYXRlcyBmcm9tIHRoZSBzcGVjIGFuZCBzdXBwbGllcyB0aGUgdmVyc2lvbiBhcyBhXG4gIC8vIHN0cmluZyByYXRoZXIgdGhhbiBhIG51bWJlciwgc28gd2UgdXNlIGxvb3NlIGVxdWFsaXR5IGNoZWNraW5nIGhlcmUuXG4gIGlmICh2ZXJzaW9uICE9IHRoaXMuX3ZlcnNpb24pIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vuc3VwcG9ydGVkIHZlcnNpb246ICcgKyB2ZXJzaW9uKTtcbiAgfVxuXG4gIGlmIChzb3VyY2VSb290KSB7XG4gICAgc291cmNlUm9vdCA9IHV0aWwubm9ybWFsaXplKHNvdXJjZVJvb3QpO1xuICB9XG5cbiAgc291cmNlcyA9IHNvdXJjZXNcbiAgICAubWFwKFN0cmluZylcbiAgICAvLyBTb21lIHNvdXJjZSBtYXBzIHByb2R1Y2UgcmVsYXRpdmUgc291cmNlIHBhdGhzIGxpa2UgXCIuL2Zvby5qc1wiIGluc3RlYWQgb2ZcbiAgICAvLyBcImZvby5qc1wiLiAgTm9ybWFsaXplIHRoZXNlIGZpcnN0IHNvIHRoYXQgZnV0dXJlIGNvbXBhcmlzb25zIHdpbGwgc3VjY2VlZC5cbiAgICAvLyBTZWUgYnVnemlsLmxhLzEwOTA3NjguXG4gICAgLm1hcCh1dGlsLm5vcm1hbGl6ZSlcbiAgICAvLyBBbHdheXMgZW5zdXJlIHRoYXQgYWJzb2x1dGUgc291cmNlcyBhcmUgaW50ZXJuYWxseSBzdG9yZWQgcmVsYXRpdmUgdG9cbiAgICAvLyB0aGUgc291cmNlIHJvb3QsIGlmIHRoZSBzb3VyY2Ugcm9vdCBpcyBhYnNvbHV0ZS4gTm90IGRvaW5nIHRoaXMgd291bGRcbiAgICAvLyBiZSBwYXJ0aWN1bGFybHkgcHJvYmxlbWF0aWMgd2hlbiB0aGUgc291cmNlIHJvb3QgaXMgYSBwcmVmaXggb2YgdGhlXG4gICAgLy8gc291cmNlICh2YWxpZCwgYnV0IHdoeT8/KS4gU2VlIGdpdGh1YiBpc3N1ZSAjMTk5IGFuZCBidWd6aWwubGEvMTE4ODk4Mi5cbiAgICAubWFwKGZ1bmN0aW9uIChzb3VyY2UpIHtcbiAgICAgIHJldHVybiBzb3VyY2VSb290ICYmIHV0aWwuaXNBYnNvbHV0ZShzb3VyY2VSb290KSAmJiB1dGlsLmlzQWJzb2x1dGUoc291cmNlKVxuICAgICAgICA/IHV0aWwucmVsYXRpdmUoc291cmNlUm9vdCwgc291cmNlKVxuICAgICAgICA6IHNvdXJjZTtcbiAgICB9KTtcblxuICAvLyBQYXNzIGB0cnVlYCBiZWxvdyB0byBhbGxvdyBkdXBsaWNhdGUgbmFtZXMgYW5kIHNvdXJjZXMuIFdoaWxlIHNvdXJjZSBtYXBzXG4gIC8vIGFyZSBpbnRlbmRlZCB0byBiZSBjb21wcmVzc2VkIGFuZCBkZWR1cGxpY2F0ZWQsIHRoZSBUeXBlU2NyaXB0IGNvbXBpbGVyXG4gIC8vIHNvbWV0aW1lcyBnZW5lcmF0ZXMgc291cmNlIG1hcHMgd2l0aCBkdXBsaWNhdGVzIGluIHRoZW0uIFNlZSBHaXRodWIgaXNzdWVcbiAgLy8gIzcyIGFuZCBidWd6aWwubGEvODg5NDkyLlxuICB0aGlzLl9uYW1lcyA9IEFycmF5U2V0LmZyb21BcnJheShuYW1lcy5tYXAoU3RyaW5nKSwgdHJ1ZSk7XG4gIHRoaXMuX3NvdXJjZXMgPSBBcnJheVNldC5mcm9tQXJyYXkoc291cmNlcywgdHJ1ZSk7XG5cbiAgdGhpcy5fYWJzb2x1dGVTb3VyY2VzID0gdGhpcy5fc291cmNlcy50b0FycmF5KCkubWFwKGZ1bmN0aW9uIChzKSB7XG4gICAgcmV0dXJuIHV0aWwuY29tcHV0ZVNvdXJjZVVSTChzb3VyY2VSb290LCBzLCBhU291cmNlTWFwVVJMKTtcbiAgfSk7XG5cbiAgdGhpcy5zb3VyY2VSb290ID0gc291cmNlUm9vdDtcbiAgdGhpcy5zb3VyY2VzQ29udGVudCA9IHNvdXJjZXNDb250ZW50O1xuICB0aGlzLl9tYXBwaW5ncyA9IG1hcHBpbmdzO1xuICB0aGlzLl9zb3VyY2VNYXBVUkwgPSBhU291cmNlTWFwVVJMO1xuICB0aGlzLmZpbGUgPSBmaWxlO1xufVxuXG5CYXNpY1NvdXJjZU1hcENvbnN1bWVyLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoU291cmNlTWFwQ29uc3VtZXIucHJvdG90eXBlKTtcbkJhc2ljU291cmNlTWFwQ29uc3VtZXIucHJvdG90eXBlLmNvbnN1bWVyID0gU291cmNlTWFwQ29uc3VtZXI7XG5cbi8qKlxuICogVXRpbGl0eSBmdW5jdGlvbiB0byBmaW5kIHRoZSBpbmRleCBvZiBhIHNvdXJjZS4gIFJldHVybnMgLTEgaWYgbm90XG4gKiBmb3VuZC5cbiAqL1xuQmFzaWNTb3VyY2VNYXBDb25zdW1lci5wcm90b3R5cGUuX2ZpbmRTb3VyY2VJbmRleCA9IGZ1bmN0aW9uKGFTb3VyY2UpIHtcbiAgdmFyIHJlbGF0aXZlU291cmNlID0gYVNvdXJjZTtcbiAgaWYgKHRoaXMuc291cmNlUm9vdCAhPSBudWxsKSB7XG4gICAgcmVsYXRpdmVTb3VyY2UgPSB1dGlsLnJlbGF0aXZlKHRoaXMuc291cmNlUm9vdCwgcmVsYXRpdmVTb3VyY2UpO1xuICB9XG5cbiAgaWYgKHRoaXMuX3NvdXJjZXMuaGFzKHJlbGF0aXZlU291cmNlKSkge1xuICAgIHJldHVybiB0aGlzLl9zb3VyY2VzLmluZGV4T2YocmVsYXRpdmVTb3VyY2UpO1xuICB9XG5cbiAgLy8gTWF5YmUgYVNvdXJjZSBpcyBhbiBhYnNvbHV0ZSBVUkwgYXMgcmV0dXJuZWQgYnkgfHNvdXJjZXN8LiAgSW5cbiAgLy8gdGhpcyBjYXNlIHdlIGNhbid0IHNpbXBseSB1bmRvIHRoZSB0cmFuc2Zvcm0uXG4gIHZhciBpO1xuICBmb3IgKGkgPSAwOyBpIDwgdGhpcy5fYWJzb2x1dGVTb3VyY2VzLmxlbmd0aDsgKytpKSB7XG4gICAgaWYgKHRoaXMuX2Fic29sdXRlU291cmNlc1tpXSA9PSBhU291cmNlKSB7XG4gICAgICByZXR1cm4gaTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gLTE7XG59O1xuXG4vKipcbiAqIENyZWF0ZSBhIEJhc2ljU291cmNlTWFwQ29uc3VtZXIgZnJvbSBhIFNvdXJjZU1hcEdlbmVyYXRvci5cbiAqXG4gKiBAcGFyYW0gU291cmNlTWFwR2VuZXJhdG9yIGFTb3VyY2VNYXBcbiAqICAgICAgICBUaGUgc291cmNlIG1hcCB0aGF0IHdpbGwgYmUgY29uc3VtZWQuXG4gKiBAcGFyYW0gU3RyaW5nIGFTb3VyY2VNYXBVUkxcbiAqICAgICAgICBUaGUgVVJMIGF0IHdoaWNoIHRoZSBzb3VyY2UgbWFwIGNhbiBiZSBmb3VuZCAob3B0aW9uYWwpXG4gKiBAcmV0dXJucyBCYXNpY1NvdXJjZU1hcENvbnN1bWVyXG4gKi9cbkJhc2ljU291cmNlTWFwQ29uc3VtZXIuZnJvbVNvdXJjZU1hcCA9XG4gIGZ1bmN0aW9uIFNvdXJjZU1hcENvbnN1bWVyX2Zyb21Tb3VyY2VNYXAoYVNvdXJjZU1hcCwgYVNvdXJjZU1hcFVSTCkge1xuICAgIHZhciBzbWMgPSBPYmplY3QuY3JlYXRlKEJhc2ljU291cmNlTWFwQ29uc3VtZXIucHJvdG90eXBlKTtcblxuICAgIHZhciBuYW1lcyA9IHNtYy5fbmFtZXMgPSBBcnJheVNldC5mcm9tQXJyYXkoYVNvdXJjZU1hcC5fbmFtZXMudG9BcnJheSgpLCB0cnVlKTtcbiAgICB2YXIgc291cmNlcyA9IHNtYy5fc291cmNlcyA9IEFycmF5U2V0LmZyb21BcnJheShhU291cmNlTWFwLl9zb3VyY2VzLnRvQXJyYXkoKSwgdHJ1ZSk7XG4gICAgc21jLnNvdXJjZVJvb3QgPSBhU291cmNlTWFwLl9zb3VyY2VSb290O1xuICAgIHNtYy5zb3VyY2VzQ29udGVudCA9IGFTb3VyY2VNYXAuX2dlbmVyYXRlU291cmNlc0NvbnRlbnQoc21jLl9zb3VyY2VzLnRvQXJyYXkoKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNtYy5zb3VyY2VSb290KTtcbiAgICBzbWMuZmlsZSA9IGFTb3VyY2VNYXAuX2ZpbGU7XG4gICAgc21jLl9zb3VyY2VNYXBVUkwgPSBhU291cmNlTWFwVVJMO1xuICAgIHNtYy5fYWJzb2x1dGVTb3VyY2VzID0gc21jLl9zb3VyY2VzLnRvQXJyYXkoKS5tYXAoZnVuY3Rpb24gKHMpIHtcbiAgICAgIHJldHVybiB1dGlsLmNvbXB1dGVTb3VyY2VVUkwoc21jLnNvdXJjZVJvb3QsIHMsIGFTb3VyY2VNYXBVUkwpO1xuICAgIH0pO1xuXG4gICAgLy8gQmVjYXVzZSB3ZSBhcmUgbW9kaWZ5aW5nIHRoZSBlbnRyaWVzIChieSBjb252ZXJ0aW5nIHN0cmluZyBzb3VyY2VzIGFuZFxuICAgIC8vIG5hbWVzIHRvIGluZGljZXMgaW50byB0aGUgc291cmNlcyBhbmQgbmFtZXMgQXJyYXlTZXRzKSwgd2UgaGF2ZSB0byBtYWtlXG4gICAgLy8gYSBjb3B5IG9mIHRoZSBlbnRyeSBvciBlbHNlIGJhZCB0aGluZ3MgaGFwcGVuLiBTaGFyZWQgbXV0YWJsZSBzdGF0ZVxuICAgIC8vIHN0cmlrZXMgYWdhaW4hIFNlZSBnaXRodWIgaXNzdWUgIzE5MS5cblxuICAgIHZhciBnZW5lcmF0ZWRNYXBwaW5ncyA9IGFTb3VyY2VNYXAuX21hcHBpbmdzLnRvQXJyYXkoKS5zbGljZSgpO1xuICAgIHZhciBkZXN0R2VuZXJhdGVkTWFwcGluZ3MgPSBzbWMuX19nZW5lcmF0ZWRNYXBwaW5ncyA9IFtdO1xuICAgIHZhciBkZXN0T3JpZ2luYWxNYXBwaW5ncyA9IHNtYy5fX29yaWdpbmFsTWFwcGluZ3MgPSBbXTtcblxuICAgIGZvciAodmFyIGkgPSAwLCBsZW5ndGggPSBnZW5lcmF0ZWRNYXBwaW5ncy5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHNyY01hcHBpbmcgPSBnZW5lcmF0ZWRNYXBwaW5nc1tpXTtcbiAgICAgIHZhciBkZXN0TWFwcGluZyA9IG5ldyBNYXBwaW5nO1xuICAgICAgZGVzdE1hcHBpbmcuZ2VuZXJhdGVkTGluZSA9IHNyY01hcHBpbmcuZ2VuZXJhdGVkTGluZTtcbiAgICAgIGRlc3RNYXBwaW5nLmdlbmVyYXRlZENvbHVtbiA9IHNyY01hcHBpbmcuZ2VuZXJhdGVkQ29sdW1uO1xuXG4gICAgICBpZiAoc3JjTWFwcGluZy5zb3VyY2UpIHtcbiAgICAgICAgZGVzdE1hcHBpbmcuc291cmNlID0gc291cmNlcy5pbmRleE9mKHNyY01hcHBpbmcuc291cmNlKTtcbiAgICAgICAgZGVzdE1hcHBpbmcub3JpZ2luYWxMaW5lID0gc3JjTWFwcGluZy5vcmlnaW5hbExpbmU7XG4gICAgICAgIGRlc3RNYXBwaW5nLm9yaWdpbmFsQ29sdW1uID0gc3JjTWFwcGluZy5vcmlnaW5hbENvbHVtbjtcblxuICAgICAgICBpZiAoc3JjTWFwcGluZy5uYW1lKSB7XG4gICAgICAgICAgZGVzdE1hcHBpbmcubmFtZSA9IG5hbWVzLmluZGV4T2Yoc3JjTWFwcGluZy5uYW1lKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGRlc3RPcmlnaW5hbE1hcHBpbmdzLnB1c2goZGVzdE1hcHBpbmcpO1xuICAgICAgfVxuXG4gICAgICBkZXN0R2VuZXJhdGVkTWFwcGluZ3MucHVzaChkZXN0TWFwcGluZyk7XG4gICAgfVxuXG4gICAgcXVpY2tTb3J0KHNtYy5fX29yaWdpbmFsTWFwcGluZ3MsIHV0aWwuY29tcGFyZUJ5T3JpZ2luYWxQb3NpdGlvbnMpO1xuXG4gICAgcmV0dXJuIHNtYztcbiAgfTtcblxuLyoqXG4gKiBUaGUgdmVyc2lvbiBvZiB0aGUgc291cmNlIG1hcHBpbmcgc3BlYyB0aGF0IHdlIGFyZSBjb25zdW1pbmcuXG4gKi9cbkJhc2ljU291cmNlTWFwQ29uc3VtZXIucHJvdG90eXBlLl92ZXJzaW9uID0gMztcblxuLyoqXG4gKiBUaGUgbGlzdCBvZiBvcmlnaW5hbCBzb3VyY2VzLlxuICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoQmFzaWNTb3VyY2VNYXBDb25zdW1lci5wcm90b3R5cGUsICdzb3VyY2VzJywge1xuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5fYWJzb2x1dGVTb3VyY2VzLnNsaWNlKCk7XG4gIH1cbn0pO1xuXG4vKipcbiAqIFByb3ZpZGUgdGhlIEpJVCB3aXRoIGEgbmljZSBzaGFwZSAvIGhpZGRlbiBjbGFzcy5cbiAqL1xuZnVuY3Rpb24gTWFwcGluZygpIHtcbiAgdGhpcy5nZW5lcmF0ZWRMaW5lID0gMDtcbiAgdGhpcy5nZW5lcmF0ZWRDb2x1bW4gPSAwO1xuICB0aGlzLnNvdXJjZSA9IG51bGw7XG4gIHRoaXMub3JpZ2luYWxMaW5lID0gbnVsbDtcbiAgdGhpcy5vcmlnaW5hbENvbHVtbiA9IG51bGw7XG4gIHRoaXMubmFtZSA9IG51bGw7XG59XG5cbi8qKlxuICogUGFyc2UgdGhlIG1hcHBpbmdzIGluIGEgc3RyaW5nIGluIHRvIGEgZGF0YSBzdHJ1Y3R1cmUgd2hpY2ggd2UgY2FuIGVhc2lseVxuICogcXVlcnkgKHRoZSBvcmRlcmVkIGFycmF5cyBpbiB0aGUgYHRoaXMuX19nZW5lcmF0ZWRNYXBwaW5nc2AgYW5kXG4gKiBgdGhpcy5fX29yaWdpbmFsTWFwcGluZ3NgIHByb3BlcnRpZXMpLlxuICovXG5CYXNpY1NvdXJjZU1hcENvbnN1bWVyLnByb3RvdHlwZS5fcGFyc2VNYXBwaW5ncyA9XG4gIGZ1bmN0aW9uIFNvdXJjZU1hcENvbnN1bWVyX3BhcnNlTWFwcGluZ3MoYVN0ciwgYVNvdXJjZVJvb3QpIHtcbiAgICB2YXIgZ2VuZXJhdGVkTGluZSA9IDE7XG4gICAgdmFyIHByZXZpb3VzR2VuZXJhdGVkQ29sdW1uID0gMDtcbiAgICB2YXIgcHJldmlvdXNPcmlnaW5hbExpbmUgPSAwO1xuICAgIHZhciBwcmV2aW91c09yaWdpbmFsQ29sdW1uID0gMDtcbiAgICB2YXIgcHJldmlvdXNTb3VyY2UgPSAwO1xuICAgIHZhciBwcmV2aW91c05hbWUgPSAwO1xuICAgIHZhciBsZW5ndGggPSBhU3RyLmxlbmd0aDtcbiAgICB2YXIgaW5kZXggPSAwO1xuICAgIHZhciBjYWNoZWRTZWdtZW50cyA9IHt9O1xuICAgIHZhciB0ZW1wID0ge307XG4gICAgdmFyIG9yaWdpbmFsTWFwcGluZ3MgPSBbXTtcbiAgICB2YXIgZ2VuZXJhdGVkTWFwcGluZ3MgPSBbXTtcbiAgICB2YXIgbWFwcGluZywgc3RyLCBzZWdtZW50LCBlbmQsIHZhbHVlO1xuXG4gICAgd2hpbGUgKGluZGV4IDwgbGVuZ3RoKSB7XG4gICAgICBpZiAoYVN0ci5jaGFyQXQoaW5kZXgpID09PSAnOycpIHtcbiAgICAgICAgZ2VuZXJhdGVkTGluZSsrO1xuICAgICAgICBpbmRleCsrO1xuICAgICAgICBwcmV2aW91c0dlbmVyYXRlZENvbHVtbiA9IDA7XG4gICAgICB9XG4gICAgICBlbHNlIGlmIChhU3RyLmNoYXJBdChpbmRleCkgPT09ICcsJykge1xuICAgICAgICBpbmRleCsrO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIG1hcHBpbmcgPSBuZXcgTWFwcGluZygpO1xuICAgICAgICBtYXBwaW5nLmdlbmVyYXRlZExpbmUgPSBnZW5lcmF0ZWRMaW5lO1xuXG4gICAgICAgIC8vIEJlY2F1c2UgZWFjaCBvZmZzZXQgaXMgZW5jb2RlZCByZWxhdGl2ZSB0byB0aGUgcHJldmlvdXMgb25lLFxuICAgICAgICAvLyBtYW55IHNlZ21lbnRzIG9mdGVuIGhhdmUgdGhlIHNhbWUgZW5jb2RpbmcuIFdlIGNhbiBleHBsb2l0IHRoaXNcbiAgICAgICAgLy8gZmFjdCBieSBjYWNoaW5nIHRoZSBwYXJzZWQgdmFyaWFibGUgbGVuZ3RoIGZpZWxkcyBvZiBlYWNoIHNlZ21lbnQsXG4gICAgICAgIC8vIGFsbG93aW5nIHVzIHRvIGF2b2lkIGEgc2Vjb25kIHBhcnNlIGlmIHdlIGVuY291bnRlciB0aGUgc2FtZVxuICAgICAgICAvLyBzZWdtZW50IGFnYWluLlxuICAgICAgICBmb3IgKGVuZCA9IGluZGV4OyBlbmQgPCBsZW5ndGg7IGVuZCsrKSB7XG4gICAgICAgICAgaWYgKHRoaXMuX2NoYXJJc01hcHBpbmdTZXBhcmF0b3IoYVN0ciwgZW5kKSkge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHN0ciA9IGFTdHIuc2xpY2UoaW5kZXgsIGVuZCk7XG5cbiAgICAgICAgc2VnbWVudCA9IGNhY2hlZFNlZ21lbnRzW3N0cl07XG4gICAgICAgIGlmIChzZWdtZW50KSB7XG4gICAgICAgICAgaW5kZXggKz0gc3RyLmxlbmd0aDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzZWdtZW50ID0gW107XG4gICAgICAgICAgd2hpbGUgKGluZGV4IDwgZW5kKSB7XG4gICAgICAgICAgICBiYXNlNjRWTFEuZGVjb2RlKGFTdHIsIGluZGV4LCB0ZW1wKTtcbiAgICAgICAgICAgIHZhbHVlID0gdGVtcC52YWx1ZTtcbiAgICAgICAgICAgIGluZGV4ID0gdGVtcC5yZXN0O1xuICAgICAgICAgICAgc2VnbWVudC5wdXNoKHZhbHVlKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoc2VnbWVudC5sZW5ndGggPT09IDIpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRm91bmQgYSBzb3VyY2UsIGJ1dCBubyBsaW5lIGFuZCBjb2x1bW4nKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoc2VnbWVudC5sZW5ndGggPT09IDMpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRm91bmQgYSBzb3VyY2UgYW5kIGxpbmUsIGJ1dCBubyBjb2x1bW4nKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjYWNoZWRTZWdtZW50c1tzdHJdID0gc2VnbWVudDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEdlbmVyYXRlZCBjb2x1bW4uXG4gICAgICAgIG1hcHBpbmcuZ2VuZXJhdGVkQ29sdW1uID0gcHJldmlvdXNHZW5lcmF0ZWRDb2x1bW4gKyBzZWdtZW50WzBdO1xuICAgICAgICBwcmV2aW91c0dlbmVyYXRlZENvbHVtbiA9IG1hcHBpbmcuZ2VuZXJhdGVkQ29sdW1uO1xuXG4gICAgICAgIGlmIChzZWdtZW50Lmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAvLyBPcmlnaW5hbCBzb3VyY2UuXG4gICAgICAgICAgbWFwcGluZy5zb3VyY2UgPSBwcmV2aW91c1NvdXJjZSArIHNlZ21lbnRbMV07XG4gICAgICAgICAgcHJldmlvdXNTb3VyY2UgKz0gc2VnbWVudFsxXTtcblxuICAgICAgICAgIC8vIE9yaWdpbmFsIGxpbmUuXG4gICAgICAgICAgbWFwcGluZy5vcmlnaW5hbExpbmUgPSBwcmV2aW91c09yaWdpbmFsTGluZSArIHNlZ21lbnRbMl07XG4gICAgICAgICAgcHJldmlvdXNPcmlnaW5hbExpbmUgPSBtYXBwaW5nLm9yaWdpbmFsTGluZTtcbiAgICAgICAgICAvLyBMaW5lcyBhcmUgc3RvcmVkIDAtYmFzZWRcbiAgICAgICAgICBtYXBwaW5nLm9yaWdpbmFsTGluZSArPSAxO1xuXG4gICAgICAgICAgLy8gT3JpZ2luYWwgY29sdW1uLlxuICAgICAgICAgIG1hcHBpbmcub3JpZ2luYWxDb2x1bW4gPSBwcmV2aW91c09yaWdpbmFsQ29sdW1uICsgc2VnbWVudFszXTtcbiAgICAgICAgICBwcmV2aW91c09yaWdpbmFsQ29sdW1uID0gbWFwcGluZy5vcmlnaW5hbENvbHVtbjtcblxuICAgICAgICAgIGlmIChzZWdtZW50Lmxlbmd0aCA+IDQpIHtcbiAgICAgICAgICAgIC8vIE9yaWdpbmFsIG5hbWUuXG4gICAgICAgICAgICBtYXBwaW5nLm5hbWUgPSBwcmV2aW91c05hbWUgKyBzZWdtZW50WzRdO1xuICAgICAgICAgICAgcHJldmlvdXNOYW1lICs9IHNlZ21lbnRbNF07XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgZ2VuZXJhdGVkTWFwcGluZ3MucHVzaChtYXBwaW5nKTtcbiAgICAgICAgaWYgKHR5cGVvZiBtYXBwaW5nLm9yaWdpbmFsTGluZSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICBvcmlnaW5hbE1hcHBpbmdzLnB1c2gobWFwcGluZyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBxdWlja1NvcnQoZ2VuZXJhdGVkTWFwcGluZ3MsIHV0aWwuY29tcGFyZUJ5R2VuZXJhdGVkUG9zaXRpb25zRGVmbGF0ZWQpO1xuICAgIHRoaXMuX19nZW5lcmF0ZWRNYXBwaW5ncyA9IGdlbmVyYXRlZE1hcHBpbmdzO1xuXG4gICAgcXVpY2tTb3J0KG9yaWdpbmFsTWFwcGluZ3MsIHV0aWwuY29tcGFyZUJ5T3JpZ2luYWxQb3NpdGlvbnMpO1xuICAgIHRoaXMuX19vcmlnaW5hbE1hcHBpbmdzID0gb3JpZ2luYWxNYXBwaW5ncztcbiAgfTtcblxuLyoqXG4gKiBGaW5kIHRoZSBtYXBwaW5nIHRoYXQgYmVzdCBtYXRjaGVzIHRoZSBoeXBvdGhldGljYWwgXCJuZWVkbGVcIiBtYXBwaW5nIHRoYXRcbiAqIHdlIGFyZSBzZWFyY2hpbmcgZm9yIGluIHRoZSBnaXZlbiBcImhheXN0YWNrXCIgb2YgbWFwcGluZ3MuXG4gKi9cbkJhc2ljU291cmNlTWFwQ29uc3VtZXIucHJvdG90eXBlLl9maW5kTWFwcGluZyA9XG4gIGZ1bmN0aW9uIFNvdXJjZU1hcENvbnN1bWVyX2ZpbmRNYXBwaW5nKGFOZWVkbGUsIGFNYXBwaW5ncywgYUxpbmVOYW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhQ29sdW1uTmFtZSwgYUNvbXBhcmF0b3IsIGFCaWFzKSB7XG4gICAgLy8gVG8gcmV0dXJuIHRoZSBwb3NpdGlvbiB3ZSBhcmUgc2VhcmNoaW5nIGZvciwgd2UgbXVzdCBmaXJzdCBmaW5kIHRoZVxuICAgIC8vIG1hcHBpbmcgZm9yIHRoZSBnaXZlbiBwb3NpdGlvbiBhbmQgdGhlbiByZXR1cm4gdGhlIG9wcG9zaXRlIHBvc2l0aW9uIGl0XG4gICAgLy8gcG9pbnRzIHRvLiBCZWNhdXNlIHRoZSBtYXBwaW5ncyBhcmUgc29ydGVkLCB3ZSBjYW4gdXNlIGJpbmFyeSBzZWFyY2ggdG9cbiAgICAvLyBmaW5kIHRoZSBiZXN0IG1hcHBpbmcuXG5cbiAgICBpZiAoYU5lZWRsZVthTGluZU5hbWVdIDw9IDApIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0xpbmUgbXVzdCBiZSBncmVhdGVyIHRoYW4gb3IgZXF1YWwgdG8gMSwgZ290ICdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgKyBhTmVlZGxlW2FMaW5lTmFtZV0pO1xuICAgIH1cbiAgICBpZiAoYU5lZWRsZVthQ29sdW1uTmFtZV0gPCAwKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdDb2x1bW4gbXVzdCBiZSBncmVhdGVyIHRoYW4gb3IgZXF1YWwgdG8gMCwgZ290ICdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgKyBhTmVlZGxlW2FDb2x1bW5OYW1lXSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGJpbmFyeVNlYXJjaC5zZWFyY2goYU5lZWRsZSwgYU1hcHBpbmdzLCBhQ29tcGFyYXRvciwgYUJpYXMpO1xuICB9O1xuXG4vKipcbiAqIENvbXB1dGUgdGhlIGxhc3QgY29sdW1uIGZvciBlYWNoIGdlbmVyYXRlZCBtYXBwaW5nLiBUaGUgbGFzdCBjb2x1bW4gaXNcbiAqIGluY2x1c2l2ZS5cbiAqL1xuQmFzaWNTb3VyY2VNYXBDb25zdW1lci5wcm90b3R5cGUuY29tcHV0ZUNvbHVtblNwYW5zID1cbiAgZnVuY3Rpb24gU291cmNlTWFwQ29uc3VtZXJfY29tcHV0ZUNvbHVtblNwYW5zKCkge1xuICAgIGZvciAodmFyIGluZGV4ID0gMDsgaW5kZXggPCB0aGlzLl9nZW5lcmF0ZWRNYXBwaW5ncy5sZW5ndGg7ICsraW5kZXgpIHtcbiAgICAgIHZhciBtYXBwaW5nID0gdGhpcy5fZ2VuZXJhdGVkTWFwcGluZ3NbaW5kZXhdO1xuXG4gICAgICAvLyBNYXBwaW5ncyBkbyBub3QgY29udGFpbiBhIGZpZWxkIGZvciB0aGUgbGFzdCBnZW5lcmF0ZWQgY29sdW1udC4gV2VcbiAgICAgIC8vIGNhbiBjb21lIHVwIHdpdGggYW4gb3B0aW1pc3RpYyBlc3RpbWF0ZSwgaG93ZXZlciwgYnkgYXNzdW1pbmcgdGhhdFxuICAgICAgLy8gbWFwcGluZ3MgYXJlIGNvbnRpZ3VvdXMgKGkuZS4gZ2l2ZW4gdHdvIGNvbnNlY3V0aXZlIG1hcHBpbmdzLCB0aGVcbiAgICAgIC8vIGZpcnN0IG1hcHBpbmcgZW5kcyB3aGVyZSB0aGUgc2Vjb25kIG9uZSBzdGFydHMpLlxuICAgICAgaWYgKGluZGV4ICsgMSA8IHRoaXMuX2dlbmVyYXRlZE1hcHBpbmdzLmxlbmd0aCkge1xuICAgICAgICB2YXIgbmV4dE1hcHBpbmcgPSB0aGlzLl9nZW5lcmF0ZWRNYXBwaW5nc1tpbmRleCArIDFdO1xuXG4gICAgICAgIGlmIChtYXBwaW5nLmdlbmVyYXRlZExpbmUgPT09IG5leHRNYXBwaW5nLmdlbmVyYXRlZExpbmUpIHtcbiAgICAgICAgICBtYXBwaW5nLmxhc3RHZW5lcmF0ZWRDb2x1bW4gPSBuZXh0TWFwcGluZy5nZW5lcmF0ZWRDb2x1bW4gLSAxO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIFRoZSBsYXN0IG1hcHBpbmcgZm9yIGVhY2ggbGluZSBzcGFucyB0aGUgZW50aXJlIGxpbmUuXG4gICAgICBtYXBwaW5nLmxhc3RHZW5lcmF0ZWRDb2x1bW4gPSBJbmZpbml0eTtcbiAgICB9XG4gIH07XG5cbi8qKlxuICogUmV0dXJucyB0aGUgb3JpZ2luYWwgc291cmNlLCBsaW5lLCBhbmQgY29sdW1uIGluZm9ybWF0aW9uIGZvciB0aGUgZ2VuZXJhdGVkXG4gKiBzb3VyY2UncyBsaW5lIGFuZCBjb2x1bW4gcG9zaXRpb25zIHByb3ZpZGVkLiBUaGUgb25seSBhcmd1bWVudCBpcyBhbiBvYmplY3RcbiAqIHdpdGggdGhlIGZvbGxvd2luZyBwcm9wZXJ0aWVzOlxuICpcbiAqICAgLSBsaW5lOiBUaGUgbGluZSBudW1iZXIgaW4gdGhlIGdlbmVyYXRlZCBzb3VyY2UuICBUaGUgbGluZSBudW1iZXJcbiAqICAgICBpcyAxLWJhc2VkLlxuICogICAtIGNvbHVtbjogVGhlIGNvbHVtbiBudW1iZXIgaW4gdGhlIGdlbmVyYXRlZCBzb3VyY2UuICBUaGUgY29sdW1uXG4gKiAgICAgbnVtYmVyIGlzIDAtYmFzZWQuXG4gKiAgIC0gYmlhczogRWl0aGVyICdTb3VyY2VNYXBDb25zdW1lci5HUkVBVEVTVF9MT1dFUl9CT1VORCcgb3JcbiAqICAgICAnU291cmNlTWFwQ29uc3VtZXIuTEVBU1RfVVBQRVJfQk9VTkQnLiBTcGVjaWZpZXMgd2hldGhlciB0byByZXR1cm4gdGhlXG4gKiAgICAgY2xvc2VzdCBlbGVtZW50IHRoYXQgaXMgc21hbGxlciB0aGFuIG9yIGdyZWF0ZXIgdGhhbiB0aGUgb25lIHdlIGFyZVxuICogICAgIHNlYXJjaGluZyBmb3IsIHJlc3BlY3RpdmVseSwgaWYgdGhlIGV4YWN0IGVsZW1lbnQgY2Fubm90IGJlIGZvdW5kLlxuICogICAgIERlZmF1bHRzIHRvICdTb3VyY2VNYXBDb25zdW1lci5HUkVBVEVTVF9MT1dFUl9CT1VORCcuXG4gKlxuICogYW5kIGFuIG9iamVjdCBpcyByZXR1cm5lZCB3aXRoIHRoZSBmb2xsb3dpbmcgcHJvcGVydGllczpcbiAqXG4gKiAgIC0gc291cmNlOiBUaGUgb3JpZ2luYWwgc291cmNlIGZpbGUsIG9yIG51bGwuXG4gKiAgIC0gbGluZTogVGhlIGxpbmUgbnVtYmVyIGluIHRoZSBvcmlnaW5hbCBzb3VyY2UsIG9yIG51bGwuICBUaGVcbiAqICAgICBsaW5lIG51bWJlciBpcyAxLWJhc2VkLlxuICogICAtIGNvbHVtbjogVGhlIGNvbHVtbiBudW1iZXIgaW4gdGhlIG9yaWdpbmFsIHNvdXJjZSwgb3IgbnVsbC4gIFRoZVxuICogICAgIGNvbHVtbiBudW1iZXIgaXMgMC1iYXNlZC5cbiAqICAgLSBuYW1lOiBUaGUgb3JpZ2luYWwgaWRlbnRpZmllciwgb3IgbnVsbC5cbiAqL1xuQmFzaWNTb3VyY2VNYXBDb25zdW1lci5wcm90b3R5cGUub3JpZ2luYWxQb3NpdGlvbkZvciA9XG4gIGZ1bmN0aW9uIFNvdXJjZU1hcENvbnN1bWVyX29yaWdpbmFsUG9zaXRpb25Gb3IoYUFyZ3MpIHtcbiAgICB2YXIgbmVlZGxlID0ge1xuICAgICAgZ2VuZXJhdGVkTGluZTogdXRpbC5nZXRBcmcoYUFyZ3MsICdsaW5lJyksXG4gICAgICBnZW5lcmF0ZWRDb2x1bW46IHV0aWwuZ2V0QXJnKGFBcmdzLCAnY29sdW1uJylcbiAgICB9O1xuXG4gICAgdmFyIGluZGV4ID0gdGhpcy5fZmluZE1hcHBpbmcoXG4gICAgICBuZWVkbGUsXG4gICAgICB0aGlzLl9nZW5lcmF0ZWRNYXBwaW5ncyxcbiAgICAgIFwiZ2VuZXJhdGVkTGluZVwiLFxuICAgICAgXCJnZW5lcmF0ZWRDb2x1bW5cIixcbiAgICAgIHV0aWwuY29tcGFyZUJ5R2VuZXJhdGVkUG9zaXRpb25zRGVmbGF0ZWQsXG4gICAgICB1dGlsLmdldEFyZyhhQXJncywgJ2JpYXMnLCBTb3VyY2VNYXBDb25zdW1lci5HUkVBVEVTVF9MT1dFUl9CT1VORClcbiAgICApO1xuXG4gICAgaWYgKGluZGV4ID49IDApIHtcbiAgICAgIHZhciBtYXBwaW5nID0gdGhpcy5fZ2VuZXJhdGVkTWFwcGluZ3NbaW5kZXhdO1xuXG4gICAgICBpZiAobWFwcGluZy5nZW5lcmF0ZWRMaW5lID09PSBuZWVkbGUuZ2VuZXJhdGVkTGluZSkge1xuICAgICAgICB2YXIgc291cmNlID0gdXRpbC5nZXRBcmcobWFwcGluZywgJ3NvdXJjZScsIG51bGwpO1xuICAgICAgICBpZiAoc291cmNlICE9PSBudWxsKSB7XG4gICAgICAgICAgc291cmNlID0gdGhpcy5fc291cmNlcy5hdChzb3VyY2UpO1xuICAgICAgICAgIHNvdXJjZSA9IHV0aWwuY29tcHV0ZVNvdXJjZVVSTCh0aGlzLnNvdXJjZVJvb3QsIHNvdXJjZSwgdGhpcy5fc291cmNlTWFwVVJMKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgbmFtZSA9IHV0aWwuZ2V0QXJnKG1hcHBpbmcsICduYW1lJywgbnVsbCk7XG4gICAgICAgIGlmIChuYW1lICE9PSBudWxsKSB7XG4gICAgICAgICAgbmFtZSA9IHRoaXMuX25hbWVzLmF0KG5hbWUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgc291cmNlOiBzb3VyY2UsXG4gICAgICAgICAgbGluZTogdXRpbC5nZXRBcmcobWFwcGluZywgJ29yaWdpbmFsTGluZScsIG51bGwpLFxuICAgICAgICAgIGNvbHVtbjogdXRpbC5nZXRBcmcobWFwcGluZywgJ29yaWdpbmFsQ29sdW1uJywgbnVsbCksXG4gICAgICAgICAgbmFtZTogbmFtZVxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICBzb3VyY2U6IG51bGwsXG4gICAgICBsaW5lOiBudWxsLFxuICAgICAgY29sdW1uOiBudWxsLFxuICAgICAgbmFtZTogbnVsbFxuICAgIH07XG4gIH07XG5cbi8qKlxuICogUmV0dXJuIHRydWUgaWYgd2UgaGF2ZSB0aGUgc291cmNlIGNvbnRlbnQgZm9yIGV2ZXJ5IHNvdXJjZSBpbiB0aGUgc291cmNlXG4gKiBtYXAsIGZhbHNlIG90aGVyd2lzZS5cbiAqL1xuQmFzaWNTb3VyY2VNYXBDb25zdW1lci5wcm90b3R5cGUuaGFzQ29udGVudHNPZkFsbFNvdXJjZXMgPVxuICBmdW5jdGlvbiBCYXNpY1NvdXJjZU1hcENvbnN1bWVyX2hhc0NvbnRlbnRzT2ZBbGxTb3VyY2VzKCkge1xuICAgIGlmICghdGhpcy5zb3VyY2VzQ29udGVudCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5zb3VyY2VzQ29udGVudC5sZW5ndGggPj0gdGhpcy5fc291cmNlcy5zaXplKCkgJiZcbiAgICAgICF0aGlzLnNvdXJjZXNDb250ZW50LnNvbWUoZnVuY3Rpb24gKHNjKSB7IHJldHVybiBzYyA9PSBudWxsOyB9KTtcbiAgfTtcblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBvcmlnaW5hbCBzb3VyY2UgY29udGVudC4gVGhlIG9ubHkgYXJndW1lbnQgaXMgdGhlIHVybCBvZiB0aGVcbiAqIG9yaWdpbmFsIHNvdXJjZSBmaWxlLiBSZXR1cm5zIG51bGwgaWYgbm8gb3JpZ2luYWwgc291cmNlIGNvbnRlbnQgaXNcbiAqIGF2YWlsYWJsZS5cbiAqL1xuQmFzaWNTb3VyY2VNYXBDb25zdW1lci5wcm90b3R5cGUuc291cmNlQ29udGVudEZvciA9XG4gIGZ1bmN0aW9uIFNvdXJjZU1hcENvbnN1bWVyX3NvdXJjZUNvbnRlbnRGb3IoYVNvdXJjZSwgbnVsbE9uTWlzc2luZykge1xuICAgIGlmICghdGhpcy5zb3VyY2VzQ29udGVudCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgdmFyIGluZGV4ID0gdGhpcy5fZmluZFNvdXJjZUluZGV4KGFTb3VyY2UpO1xuICAgIGlmIChpbmRleCA+PSAwKSB7XG4gICAgICByZXR1cm4gdGhpcy5zb3VyY2VzQ29udGVudFtpbmRleF07XG4gICAgfVxuXG4gICAgdmFyIHJlbGF0aXZlU291cmNlID0gYVNvdXJjZTtcbiAgICBpZiAodGhpcy5zb3VyY2VSb290ICE9IG51bGwpIHtcbiAgICAgIHJlbGF0aXZlU291cmNlID0gdXRpbC5yZWxhdGl2ZSh0aGlzLnNvdXJjZVJvb3QsIHJlbGF0aXZlU291cmNlKTtcbiAgICB9XG5cbiAgICB2YXIgdXJsO1xuICAgIGlmICh0aGlzLnNvdXJjZVJvb3QgIT0gbnVsbFxuICAgICAgICAmJiAodXJsID0gdXRpbC51cmxQYXJzZSh0aGlzLnNvdXJjZVJvb3QpKSkge1xuICAgICAgLy8gWFhYOiBmaWxlOi8vIFVSSXMgYW5kIGFic29sdXRlIHBhdGhzIGxlYWQgdG8gdW5leHBlY3RlZCBiZWhhdmlvciBmb3JcbiAgICAgIC8vIG1hbnkgdXNlcnMuIFdlIGNhbiBoZWxwIHRoZW0gb3V0IHdoZW4gdGhleSBleHBlY3QgZmlsZTovLyBVUklzIHRvXG4gICAgICAvLyBiZWhhdmUgbGlrZSBpdCB3b3VsZCBpZiB0aGV5IHdlcmUgcnVubmluZyBhIGxvY2FsIEhUVFAgc2VydmVyLiBTZWVcbiAgICAgIC8vIGh0dHBzOi8vYnVnemlsbGEubW96aWxsYS5vcmcvc2hvd19idWcuY2dpP2lkPTg4NTU5Ny5cbiAgICAgIHZhciBmaWxlVXJpQWJzUGF0aCA9IHJlbGF0aXZlU291cmNlLnJlcGxhY2UoL15maWxlOlxcL1xcLy8sIFwiXCIpO1xuICAgICAgaWYgKHVybC5zY2hlbWUgPT0gXCJmaWxlXCJcbiAgICAgICAgICAmJiB0aGlzLl9zb3VyY2VzLmhhcyhmaWxlVXJpQWJzUGF0aCkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc291cmNlc0NvbnRlbnRbdGhpcy5fc291cmNlcy5pbmRleE9mKGZpbGVVcmlBYnNQYXRoKV1cbiAgICAgIH1cblxuICAgICAgaWYgKCghdXJsLnBhdGggfHwgdXJsLnBhdGggPT0gXCIvXCIpXG4gICAgICAgICAgJiYgdGhpcy5fc291cmNlcy5oYXMoXCIvXCIgKyByZWxhdGl2ZVNvdXJjZSkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc291cmNlc0NvbnRlbnRbdGhpcy5fc291cmNlcy5pbmRleE9mKFwiL1wiICsgcmVsYXRpdmVTb3VyY2UpXTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBUaGlzIGZ1bmN0aW9uIGlzIHVzZWQgcmVjdXJzaXZlbHkgZnJvbVxuICAgIC8vIEluZGV4ZWRTb3VyY2VNYXBDb25zdW1lci5wcm90b3R5cGUuc291cmNlQ29udGVudEZvci4gSW4gdGhhdCBjYXNlLCB3ZVxuICAgIC8vIGRvbid0IHdhbnQgdG8gdGhyb3cgaWYgd2UgY2FuJ3QgZmluZCB0aGUgc291cmNlIC0gd2UganVzdCB3YW50IHRvXG4gICAgLy8gcmV0dXJuIG51bGwsIHNvIHdlIHByb3ZpZGUgYSBmbGFnIHRvIGV4aXQgZ3JhY2VmdWxseS5cbiAgICBpZiAobnVsbE9uTWlzc2luZykge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdcIicgKyByZWxhdGl2ZVNvdXJjZSArICdcIiBpcyBub3QgaW4gdGhlIFNvdXJjZU1hcC4nKTtcbiAgICB9XG4gIH07XG5cbi8qKlxuICogUmV0dXJucyB0aGUgZ2VuZXJhdGVkIGxpbmUgYW5kIGNvbHVtbiBpbmZvcm1hdGlvbiBmb3IgdGhlIG9yaWdpbmFsIHNvdXJjZSxcbiAqIGxpbmUsIGFuZCBjb2x1bW4gcG9zaXRpb25zIHByb3ZpZGVkLiBUaGUgb25seSBhcmd1bWVudCBpcyBhbiBvYmplY3Qgd2l0aFxuICogdGhlIGZvbGxvd2luZyBwcm9wZXJ0aWVzOlxuICpcbiAqICAgLSBzb3VyY2U6IFRoZSBmaWxlbmFtZSBvZiB0aGUgb3JpZ2luYWwgc291cmNlLlxuICogICAtIGxpbmU6IFRoZSBsaW5lIG51bWJlciBpbiB0aGUgb3JpZ2luYWwgc291cmNlLiAgVGhlIGxpbmUgbnVtYmVyXG4gKiAgICAgaXMgMS1iYXNlZC5cbiAqICAgLSBjb2x1bW46IFRoZSBjb2x1bW4gbnVtYmVyIGluIHRoZSBvcmlnaW5hbCBzb3VyY2UuICBUaGUgY29sdW1uXG4gKiAgICAgbnVtYmVyIGlzIDAtYmFzZWQuXG4gKiAgIC0gYmlhczogRWl0aGVyICdTb3VyY2VNYXBDb25zdW1lci5HUkVBVEVTVF9MT1dFUl9CT1VORCcgb3JcbiAqICAgICAnU291cmNlTWFwQ29uc3VtZXIuTEVBU1RfVVBQRVJfQk9VTkQnLiBTcGVjaWZpZXMgd2hldGhlciB0byByZXR1cm4gdGhlXG4gKiAgICAgY2xvc2VzdCBlbGVtZW50IHRoYXQgaXMgc21hbGxlciB0aGFuIG9yIGdyZWF0ZXIgdGhhbiB0aGUgb25lIHdlIGFyZVxuICogICAgIHNlYXJjaGluZyBmb3IsIHJlc3BlY3RpdmVseSwgaWYgdGhlIGV4YWN0IGVsZW1lbnQgY2Fubm90IGJlIGZvdW5kLlxuICogICAgIERlZmF1bHRzIHRvICdTb3VyY2VNYXBDb25zdW1lci5HUkVBVEVTVF9MT1dFUl9CT1VORCcuXG4gKlxuICogYW5kIGFuIG9iamVjdCBpcyByZXR1cm5lZCB3aXRoIHRoZSBmb2xsb3dpbmcgcHJvcGVydGllczpcbiAqXG4gKiAgIC0gbGluZTogVGhlIGxpbmUgbnVtYmVyIGluIHRoZSBnZW5lcmF0ZWQgc291cmNlLCBvciBudWxsLiAgVGhlXG4gKiAgICAgbGluZSBudW1iZXIgaXMgMS1iYXNlZC5cbiAqICAgLSBjb2x1bW46IFRoZSBjb2x1bW4gbnVtYmVyIGluIHRoZSBnZW5lcmF0ZWQgc291cmNlLCBvciBudWxsLlxuICogICAgIFRoZSBjb2x1bW4gbnVtYmVyIGlzIDAtYmFzZWQuXG4gKi9cbkJhc2ljU291cmNlTWFwQ29uc3VtZXIucHJvdG90eXBlLmdlbmVyYXRlZFBvc2l0aW9uRm9yID1cbiAgZnVuY3Rpb24gU291cmNlTWFwQ29uc3VtZXJfZ2VuZXJhdGVkUG9zaXRpb25Gb3IoYUFyZ3MpIHtcbiAgICB2YXIgc291cmNlID0gdXRpbC5nZXRBcmcoYUFyZ3MsICdzb3VyY2UnKTtcbiAgICBzb3VyY2UgPSB0aGlzLl9maW5kU291cmNlSW5kZXgoc291cmNlKTtcbiAgICBpZiAoc291cmNlIDwgMCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgbGluZTogbnVsbCxcbiAgICAgICAgY29sdW1uOiBudWxsLFxuICAgICAgICBsYXN0Q29sdW1uOiBudWxsXG4gICAgICB9O1xuICAgIH1cblxuICAgIHZhciBuZWVkbGUgPSB7XG4gICAgICBzb3VyY2U6IHNvdXJjZSxcbiAgICAgIG9yaWdpbmFsTGluZTogdXRpbC5nZXRBcmcoYUFyZ3MsICdsaW5lJyksXG4gICAgICBvcmlnaW5hbENvbHVtbjogdXRpbC5nZXRBcmcoYUFyZ3MsICdjb2x1bW4nKVxuICAgIH07XG5cbiAgICB2YXIgaW5kZXggPSB0aGlzLl9maW5kTWFwcGluZyhcbiAgICAgIG5lZWRsZSxcbiAgICAgIHRoaXMuX29yaWdpbmFsTWFwcGluZ3MsXG4gICAgICBcIm9yaWdpbmFsTGluZVwiLFxuICAgICAgXCJvcmlnaW5hbENvbHVtblwiLFxuICAgICAgdXRpbC5jb21wYXJlQnlPcmlnaW5hbFBvc2l0aW9ucyxcbiAgICAgIHV0aWwuZ2V0QXJnKGFBcmdzLCAnYmlhcycsIFNvdXJjZU1hcENvbnN1bWVyLkdSRUFURVNUX0xPV0VSX0JPVU5EKVxuICAgICk7XG5cbiAgICBpZiAoaW5kZXggPj0gMCkge1xuICAgICAgdmFyIG1hcHBpbmcgPSB0aGlzLl9vcmlnaW5hbE1hcHBpbmdzW2luZGV4XTtcblxuICAgICAgaWYgKG1hcHBpbmcuc291cmNlID09PSBuZWVkbGUuc291cmNlKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgbGluZTogdXRpbC5nZXRBcmcobWFwcGluZywgJ2dlbmVyYXRlZExpbmUnLCBudWxsKSxcbiAgICAgICAgICBjb2x1bW46IHV0aWwuZ2V0QXJnKG1hcHBpbmcsICdnZW5lcmF0ZWRDb2x1bW4nLCBudWxsKSxcbiAgICAgICAgICBsYXN0Q29sdW1uOiB1dGlsLmdldEFyZyhtYXBwaW5nLCAnbGFzdEdlbmVyYXRlZENvbHVtbicsIG51bGwpXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIGxpbmU6IG51bGwsXG4gICAgICBjb2x1bW46IG51bGwsXG4gICAgICBsYXN0Q29sdW1uOiBudWxsXG4gICAgfTtcbiAgfTtcblxuZXhwb3J0cy5CYXNpY1NvdXJjZU1hcENvbnN1bWVyID0gQmFzaWNTb3VyY2VNYXBDb25zdW1lcjtcblxuLyoqXG4gKiBBbiBJbmRleGVkU291cmNlTWFwQ29uc3VtZXIgaW5zdGFuY2UgcmVwcmVzZW50cyBhIHBhcnNlZCBzb3VyY2UgbWFwIHdoaWNoXG4gKiB3ZSBjYW4gcXVlcnkgZm9yIGluZm9ybWF0aW9uLiBJdCBkaWZmZXJzIGZyb20gQmFzaWNTb3VyY2VNYXBDb25zdW1lciBpblxuICogdGhhdCBpdCB0YWtlcyBcImluZGV4ZWRcIiBzb3VyY2UgbWFwcyAoaS5lLiBvbmVzIHdpdGggYSBcInNlY3Rpb25zXCIgZmllbGQpIGFzXG4gKiBpbnB1dC5cbiAqXG4gKiBUaGUgZmlyc3QgcGFyYW1ldGVyIGlzIGEgcmF3IHNvdXJjZSBtYXAgKGVpdGhlciBhcyBhIEpTT04gc3RyaW5nLCBvciBhbHJlYWR5XG4gKiBwYXJzZWQgdG8gYW4gb2JqZWN0KS4gQWNjb3JkaW5nIHRvIHRoZSBzcGVjIGZvciBpbmRleGVkIHNvdXJjZSBtYXBzLCB0aGV5XG4gKiBoYXZlIHRoZSBmb2xsb3dpbmcgYXR0cmlidXRlczpcbiAqXG4gKiAgIC0gdmVyc2lvbjogV2hpY2ggdmVyc2lvbiBvZiB0aGUgc291cmNlIG1hcCBzcGVjIHRoaXMgbWFwIGlzIGZvbGxvd2luZy5cbiAqICAgLSBmaWxlOiBPcHRpb25hbC4gVGhlIGdlbmVyYXRlZCBmaWxlIHRoaXMgc291cmNlIG1hcCBpcyBhc3NvY2lhdGVkIHdpdGguXG4gKiAgIC0gc2VjdGlvbnM6IEEgbGlzdCBvZiBzZWN0aW9uIGRlZmluaXRpb25zLlxuICpcbiAqIEVhY2ggdmFsdWUgdW5kZXIgdGhlIFwic2VjdGlvbnNcIiBmaWVsZCBoYXMgdHdvIGZpZWxkczpcbiAqICAgLSBvZmZzZXQ6IFRoZSBvZmZzZXQgaW50byB0aGUgb3JpZ2luYWwgc3BlY2lmaWVkIGF0IHdoaWNoIHRoaXMgc2VjdGlvblxuICogICAgICAgYmVnaW5zIHRvIGFwcGx5LCBkZWZpbmVkIGFzIGFuIG9iamVjdCB3aXRoIGEgXCJsaW5lXCIgYW5kIFwiY29sdW1uXCJcbiAqICAgICAgIGZpZWxkLlxuICogICAtIG1hcDogQSBzb3VyY2UgbWFwIGRlZmluaXRpb24uIFRoaXMgc291cmNlIG1hcCBjb3VsZCBhbHNvIGJlIGluZGV4ZWQsXG4gKiAgICAgICBidXQgZG9lc24ndCBoYXZlIHRvIGJlLlxuICpcbiAqIEluc3RlYWQgb2YgdGhlIFwibWFwXCIgZmllbGQsIGl0J3MgYWxzbyBwb3NzaWJsZSB0byBoYXZlIGEgXCJ1cmxcIiBmaWVsZFxuICogc3BlY2lmeWluZyBhIFVSTCB0byByZXRyaWV2ZSBhIHNvdXJjZSBtYXAgZnJvbSwgYnV0IHRoYXQncyBjdXJyZW50bHlcbiAqIHVuc3VwcG9ydGVkLlxuICpcbiAqIEhlcmUncyBhbiBleGFtcGxlIHNvdXJjZSBtYXAsIHRha2VuIGZyb20gdGhlIHNvdXJjZSBtYXAgc3BlY1swXSwgYnV0XG4gKiBtb2RpZmllZCB0byBvbWl0IGEgc2VjdGlvbiB3aGljaCB1c2VzIHRoZSBcInVybFwiIGZpZWxkLlxuICpcbiAqICB7XG4gKiAgICB2ZXJzaW9uIDogMyxcbiAqICAgIGZpbGU6IFwiYXBwLmpzXCIsXG4gKiAgICBzZWN0aW9uczogW3tcbiAqICAgICAgb2Zmc2V0OiB7bGluZToxMDAsIGNvbHVtbjoxMH0sXG4gKiAgICAgIG1hcDoge1xuICogICAgICAgIHZlcnNpb24gOiAzLFxuICogICAgICAgIGZpbGU6IFwic2VjdGlvbi5qc1wiLFxuICogICAgICAgIHNvdXJjZXM6IFtcImZvby5qc1wiLCBcImJhci5qc1wiXSxcbiAqICAgICAgICBuYW1lczogW1wic3JjXCIsIFwibWFwc1wiLCBcImFyZVwiLCBcImZ1blwiXSxcbiAqICAgICAgICBtYXBwaW5nczogXCJBQUFBLEU7O0FCQ0RFO1wiXG4gKiAgICAgIH1cbiAqICAgIH1dLFxuICogIH1cbiAqXG4gKiBUaGUgc2Vjb25kIHBhcmFtZXRlciwgaWYgZ2l2ZW4sIGlzIGEgc3RyaW5nIHdob3NlIHZhbHVlIGlzIHRoZSBVUkxcbiAqIGF0IHdoaWNoIHRoZSBzb3VyY2UgbWFwIHdhcyBmb3VuZC4gIFRoaXMgVVJMIGlzIHVzZWQgdG8gY29tcHV0ZSB0aGVcbiAqIHNvdXJjZXMgYXJyYXkuXG4gKlxuICogWzBdOiBodHRwczovL2RvY3MuZ29vZ2xlLmNvbS9kb2N1bWVudC9kLzFVMVJHQWVoUXdSeXBVVG92RjFLUmxwaU9GemUwYi1fMmdjNmZBSDBLWTBrL2VkaXQjaGVhZGluZz1oLjUzNWVzM3hlcHJndFxuICovXG5mdW5jdGlvbiBJbmRleGVkU291cmNlTWFwQ29uc3VtZXIoYVNvdXJjZU1hcCwgYVNvdXJjZU1hcFVSTCkge1xuICB2YXIgc291cmNlTWFwID0gYVNvdXJjZU1hcDtcbiAgaWYgKHR5cGVvZiBhU291cmNlTWFwID09PSAnc3RyaW5nJykge1xuICAgIHNvdXJjZU1hcCA9IHV0aWwucGFyc2VTb3VyY2VNYXBJbnB1dChhU291cmNlTWFwKTtcbiAgfVxuXG4gIHZhciB2ZXJzaW9uID0gdXRpbC5nZXRBcmcoc291cmNlTWFwLCAndmVyc2lvbicpO1xuICB2YXIgc2VjdGlvbnMgPSB1dGlsLmdldEFyZyhzb3VyY2VNYXAsICdzZWN0aW9ucycpO1xuXG4gIGlmICh2ZXJzaW9uICE9IHRoaXMuX3ZlcnNpb24pIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vuc3VwcG9ydGVkIHZlcnNpb246ICcgKyB2ZXJzaW9uKTtcbiAgfVxuXG4gIHRoaXMuX3NvdXJjZXMgPSBuZXcgQXJyYXlTZXQoKTtcbiAgdGhpcy5fbmFtZXMgPSBuZXcgQXJyYXlTZXQoKTtcblxuICB2YXIgbGFzdE9mZnNldCA9IHtcbiAgICBsaW5lOiAtMSxcbiAgICBjb2x1bW46IDBcbiAgfTtcbiAgdGhpcy5fc2VjdGlvbnMgPSBzZWN0aW9ucy5tYXAoZnVuY3Rpb24gKHMpIHtcbiAgICBpZiAocy51cmwpIHtcbiAgICAgIC8vIFRoZSB1cmwgZmllbGQgd2lsbCByZXF1aXJlIHN1cHBvcnQgZm9yIGFzeW5jaHJvbmljaXR5LlxuICAgICAgLy8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9tb3ppbGxhL3NvdXJjZS1tYXAvaXNzdWVzLzE2XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1N1cHBvcnQgZm9yIHVybCBmaWVsZCBpbiBzZWN0aW9ucyBub3QgaW1wbGVtZW50ZWQuJyk7XG4gICAgfVxuICAgIHZhciBvZmZzZXQgPSB1dGlsLmdldEFyZyhzLCAnb2Zmc2V0Jyk7XG4gICAgdmFyIG9mZnNldExpbmUgPSB1dGlsLmdldEFyZyhvZmZzZXQsICdsaW5lJyk7XG4gICAgdmFyIG9mZnNldENvbHVtbiA9IHV0aWwuZ2V0QXJnKG9mZnNldCwgJ2NvbHVtbicpO1xuXG4gICAgaWYgKG9mZnNldExpbmUgPCBsYXN0T2Zmc2V0LmxpbmUgfHxcbiAgICAgICAgKG9mZnNldExpbmUgPT09IGxhc3RPZmZzZXQubGluZSAmJiBvZmZzZXRDb2x1bW4gPCBsYXN0T2Zmc2V0LmNvbHVtbikpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignU2VjdGlvbiBvZmZzZXRzIG11c3QgYmUgb3JkZXJlZCBhbmQgbm9uLW92ZXJsYXBwaW5nLicpO1xuICAgIH1cbiAgICBsYXN0T2Zmc2V0ID0gb2Zmc2V0O1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIGdlbmVyYXRlZE9mZnNldDoge1xuICAgICAgICAvLyBUaGUgb2Zmc2V0IGZpZWxkcyBhcmUgMC1iYXNlZCwgYnV0IHdlIHVzZSAxLWJhc2VkIGluZGljZXMgd2hlblxuICAgICAgICAvLyBlbmNvZGluZy9kZWNvZGluZyBmcm9tIFZMUS5cbiAgICAgICAgZ2VuZXJhdGVkTGluZTogb2Zmc2V0TGluZSArIDEsXG4gICAgICAgIGdlbmVyYXRlZENvbHVtbjogb2Zmc2V0Q29sdW1uICsgMVxuICAgICAgfSxcbiAgICAgIGNvbnN1bWVyOiBuZXcgU291cmNlTWFwQ29uc3VtZXIodXRpbC5nZXRBcmcocywgJ21hcCcpLCBhU291cmNlTWFwVVJMKVxuICAgIH1cbiAgfSk7XG59XG5cbkluZGV4ZWRTb3VyY2VNYXBDb25zdW1lci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKFNvdXJjZU1hcENvbnN1bWVyLnByb3RvdHlwZSk7XG5JbmRleGVkU291cmNlTWFwQ29uc3VtZXIucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gU291cmNlTWFwQ29uc3VtZXI7XG5cbi8qKlxuICogVGhlIHZlcnNpb24gb2YgdGhlIHNvdXJjZSBtYXBwaW5nIHNwZWMgdGhhdCB3ZSBhcmUgY29uc3VtaW5nLlxuICovXG5JbmRleGVkU291cmNlTWFwQ29uc3VtZXIucHJvdG90eXBlLl92ZXJzaW9uID0gMztcblxuLyoqXG4gKiBUaGUgbGlzdCBvZiBvcmlnaW5hbCBzb3VyY2VzLlxuICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoSW5kZXhlZFNvdXJjZU1hcENvbnN1bWVyLnByb3RvdHlwZSwgJ3NvdXJjZXMnLCB7XG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIHZhciBzb3VyY2VzID0gW107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLl9zZWN0aW9ucy5sZW5ndGg7IGkrKykge1xuICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCB0aGlzLl9zZWN0aW9uc1tpXS5jb25zdW1lci5zb3VyY2VzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgIHNvdXJjZXMucHVzaCh0aGlzLl9zZWN0aW9uc1tpXS5jb25zdW1lci5zb3VyY2VzW2pdKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHNvdXJjZXM7XG4gIH1cbn0pO1xuXG4vKipcbiAqIFJldHVybnMgdGhlIG9yaWdpbmFsIHNvdXJjZSwgbGluZSwgYW5kIGNvbHVtbiBpbmZvcm1hdGlvbiBmb3IgdGhlIGdlbmVyYXRlZFxuICogc291cmNlJ3MgbGluZSBhbmQgY29sdW1uIHBvc2l0aW9ucyBwcm92aWRlZC4gVGhlIG9ubHkgYXJndW1lbnQgaXMgYW4gb2JqZWN0XG4gKiB3aXRoIHRoZSBmb2xsb3dpbmcgcHJvcGVydGllczpcbiAqXG4gKiAgIC0gbGluZTogVGhlIGxpbmUgbnVtYmVyIGluIHRoZSBnZW5lcmF0ZWQgc291cmNlLiAgVGhlIGxpbmUgbnVtYmVyXG4gKiAgICAgaXMgMS1iYXNlZC5cbiAqICAgLSBjb2x1bW46IFRoZSBjb2x1bW4gbnVtYmVyIGluIHRoZSBnZW5lcmF0ZWQgc291cmNlLiAgVGhlIGNvbHVtblxuICogICAgIG51bWJlciBpcyAwLWJhc2VkLlxuICpcbiAqIGFuZCBhbiBvYmplY3QgaXMgcmV0dXJuZWQgd2l0aCB0aGUgZm9sbG93aW5nIHByb3BlcnRpZXM6XG4gKlxuICogICAtIHNvdXJjZTogVGhlIG9yaWdpbmFsIHNvdXJjZSBmaWxlLCBvciBudWxsLlxuICogICAtIGxpbmU6IFRoZSBsaW5lIG51bWJlciBpbiB0aGUgb3JpZ2luYWwgc291cmNlLCBvciBudWxsLiAgVGhlXG4gKiAgICAgbGluZSBudW1iZXIgaXMgMS1iYXNlZC5cbiAqICAgLSBjb2x1bW46IFRoZSBjb2x1bW4gbnVtYmVyIGluIHRoZSBvcmlnaW5hbCBzb3VyY2UsIG9yIG51bGwuICBUaGVcbiAqICAgICBjb2x1bW4gbnVtYmVyIGlzIDAtYmFzZWQuXG4gKiAgIC0gbmFtZTogVGhlIG9yaWdpbmFsIGlkZW50aWZpZXIsIG9yIG51bGwuXG4gKi9cbkluZGV4ZWRTb3VyY2VNYXBDb25zdW1lci5wcm90b3R5cGUub3JpZ2luYWxQb3NpdGlvbkZvciA9XG4gIGZ1bmN0aW9uIEluZGV4ZWRTb3VyY2VNYXBDb25zdW1lcl9vcmlnaW5hbFBvc2l0aW9uRm9yKGFBcmdzKSB7XG4gICAgdmFyIG5lZWRsZSA9IHtcbiAgICAgIGdlbmVyYXRlZExpbmU6IHV0aWwuZ2V0QXJnKGFBcmdzLCAnbGluZScpLFxuICAgICAgZ2VuZXJhdGVkQ29sdW1uOiB1dGlsLmdldEFyZyhhQXJncywgJ2NvbHVtbicpXG4gICAgfTtcblxuICAgIC8vIEZpbmQgdGhlIHNlY3Rpb24gY29udGFpbmluZyB0aGUgZ2VuZXJhdGVkIHBvc2l0aW9uIHdlJ3JlIHRyeWluZyB0byBtYXBcbiAgICAvLyB0byBhbiBvcmlnaW5hbCBwb3NpdGlvbi5cbiAgICB2YXIgc2VjdGlvbkluZGV4ID0gYmluYXJ5U2VhcmNoLnNlYXJjaChuZWVkbGUsIHRoaXMuX3NlY3Rpb25zLFxuICAgICAgZnVuY3Rpb24obmVlZGxlLCBzZWN0aW9uKSB7XG4gICAgICAgIHZhciBjbXAgPSBuZWVkbGUuZ2VuZXJhdGVkTGluZSAtIHNlY3Rpb24uZ2VuZXJhdGVkT2Zmc2V0LmdlbmVyYXRlZExpbmU7XG4gICAgICAgIGlmIChjbXApIHtcbiAgICAgICAgICByZXR1cm4gY21wO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIChuZWVkbGUuZ2VuZXJhdGVkQ29sdW1uIC1cbiAgICAgICAgICAgICAgICBzZWN0aW9uLmdlbmVyYXRlZE9mZnNldC5nZW5lcmF0ZWRDb2x1bW4pO1xuICAgICAgfSk7XG4gICAgdmFyIHNlY3Rpb24gPSB0aGlzLl9zZWN0aW9uc1tzZWN0aW9uSW5kZXhdO1xuXG4gICAgaWYgKCFzZWN0aW9uKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBzb3VyY2U6IG51bGwsXG4gICAgICAgIGxpbmU6IG51bGwsXG4gICAgICAgIGNvbHVtbjogbnVsbCxcbiAgICAgICAgbmFtZTogbnVsbFxuICAgICAgfTtcbiAgICB9XG5cbiAgICByZXR1cm4gc2VjdGlvbi5jb25zdW1lci5vcmlnaW5hbFBvc2l0aW9uRm9yKHtcbiAgICAgIGxpbmU6IG5lZWRsZS5nZW5lcmF0ZWRMaW5lIC1cbiAgICAgICAgKHNlY3Rpb24uZ2VuZXJhdGVkT2Zmc2V0LmdlbmVyYXRlZExpbmUgLSAxKSxcbiAgICAgIGNvbHVtbjogbmVlZGxlLmdlbmVyYXRlZENvbHVtbiAtXG4gICAgICAgIChzZWN0aW9uLmdlbmVyYXRlZE9mZnNldC5nZW5lcmF0ZWRMaW5lID09PSBuZWVkbGUuZ2VuZXJhdGVkTGluZVxuICAgICAgICAgPyBzZWN0aW9uLmdlbmVyYXRlZE9mZnNldC5nZW5lcmF0ZWRDb2x1bW4gLSAxXG4gICAgICAgICA6IDApLFxuICAgICAgYmlhczogYUFyZ3MuYmlhc1xuICAgIH0pO1xuICB9O1xuXG4vKipcbiAqIFJldHVybiB0cnVlIGlmIHdlIGhhdmUgdGhlIHNvdXJjZSBjb250ZW50IGZvciBldmVyeSBzb3VyY2UgaW4gdGhlIHNvdXJjZVxuICogbWFwLCBmYWxzZSBvdGhlcndpc2UuXG4gKi9cbkluZGV4ZWRTb3VyY2VNYXBDb25zdW1lci5wcm90b3R5cGUuaGFzQ29udGVudHNPZkFsbFNvdXJjZXMgPVxuICBmdW5jdGlvbiBJbmRleGVkU291cmNlTWFwQ29uc3VtZXJfaGFzQ29udGVudHNPZkFsbFNvdXJjZXMoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3NlY3Rpb25zLmV2ZXJ5KGZ1bmN0aW9uIChzKSB7XG4gICAgICByZXR1cm4gcy5jb25zdW1lci5oYXNDb250ZW50c09mQWxsU291cmNlcygpO1xuICAgIH0pO1xuICB9O1xuXG4vKipcbiAqIFJldHVybnMgdGhlIG9yaWdpbmFsIHNvdXJjZSBjb250ZW50LiBUaGUgb25seSBhcmd1bWVudCBpcyB0aGUgdXJsIG9mIHRoZVxuICogb3JpZ2luYWwgc291cmNlIGZpbGUuIFJldHVybnMgbnVsbCBpZiBubyBvcmlnaW5hbCBzb3VyY2UgY29udGVudCBpc1xuICogYXZhaWxhYmxlLlxuICovXG5JbmRleGVkU291cmNlTWFwQ29uc3VtZXIucHJvdG90eXBlLnNvdXJjZUNvbnRlbnRGb3IgPVxuICBmdW5jdGlvbiBJbmRleGVkU291cmNlTWFwQ29uc3VtZXJfc291cmNlQ29udGVudEZvcihhU291cmNlLCBudWxsT25NaXNzaW5nKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLl9zZWN0aW9ucy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHNlY3Rpb24gPSB0aGlzLl9zZWN0aW9uc1tpXTtcblxuICAgICAgdmFyIGNvbnRlbnQgPSBzZWN0aW9uLmNvbnN1bWVyLnNvdXJjZUNvbnRlbnRGb3IoYVNvdXJjZSwgdHJ1ZSk7XG4gICAgICBpZiAoY29udGVudCkge1xuICAgICAgICByZXR1cm4gY29udGVudDtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKG51bGxPbk1pc3NpbmcpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignXCInICsgYVNvdXJjZSArICdcIiBpcyBub3QgaW4gdGhlIFNvdXJjZU1hcC4nKTtcbiAgICB9XG4gIH07XG5cbi8qKlxuICogUmV0dXJucyB0aGUgZ2VuZXJhdGVkIGxpbmUgYW5kIGNvbHVtbiBpbmZvcm1hdGlvbiBmb3IgdGhlIG9yaWdpbmFsIHNvdXJjZSxcbiAqIGxpbmUsIGFuZCBjb2x1bW4gcG9zaXRpb25zIHByb3ZpZGVkLiBUaGUgb25seSBhcmd1bWVudCBpcyBhbiBvYmplY3Qgd2l0aFxuICogdGhlIGZvbGxvd2luZyBwcm9wZXJ0aWVzOlxuICpcbiAqICAgLSBzb3VyY2U6IFRoZSBmaWxlbmFtZSBvZiB0aGUgb3JpZ2luYWwgc291cmNlLlxuICogICAtIGxpbmU6IFRoZSBsaW5lIG51bWJlciBpbiB0aGUgb3JpZ2luYWwgc291cmNlLiAgVGhlIGxpbmUgbnVtYmVyXG4gKiAgICAgaXMgMS1iYXNlZC5cbiAqICAgLSBjb2x1bW46IFRoZSBjb2x1bW4gbnVtYmVyIGluIHRoZSBvcmlnaW5hbCBzb3VyY2UuICBUaGUgY29sdW1uXG4gKiAgICAgbnVtYmVyIGlzIDAtYmFzZWQuXG4gKlxuICogYW5kIGFuIG9iamVjdCBpcyByZXR1cm5lZCB3aXRoIHRoZSBmb2xsb3dpbmcgcHJvcGVydGllczpcbiAqXG4gKiAgIC0gbGluZTogVGhlIGxpbmUgbnVtYmVyIGluIHRoZSBnZW5lcmF0ZWQgc291cmNlLCBvciBudWxsLiAgVGhlXG4gKiAgICAgbGluZSBudW1iZXIgaXMgMS1iYXNlZC4gXG4gKiAgIC0gY29sdW1uOiBUaGUgY29sdW1uIG51bWJlciBpbiB0aGUgZ2VuZXJhdGVkIHNvdXJjZSwgb3IgbnVsbC5cbiAqICAgICBUaGUgY29sdW1uIG51bWJlciBpcyAwLWJhc2VkLlxuICovXG5JbmRleGVkU291cmNlTWFwQ29uc3VtZXIucHJvdG90eXBlLmdlbmVyYXRlZFBvc2l0aW9uRm9yID1cbiAgZnVuY3Rpb24gSW5kZXhlZFNvdXJjZU1hcENvbnN1bWVyX2dlbmVyYXRlZFBvc2l0aW9uRm9yKGFBcmdzKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLl9zZWN0aW9ucy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHNlY3Rpb24gPSB0aGlzLl9zZWN0aW9uc1tpXTtcblxuICAgICAgLy8gT25seSBjb25zaWRlciB0aGlzIHNlY3Rpb24gaWYgdGhlIHJlcXVlc3RlZCBzb3VyY2UgaXMgaW4gdGhlIGxpc3Qgb2ZcbiAgICAgIC8vIHNvdXJjZXMgb2YgdGhlIGNvbnN1bWVyLlxuICAgICAgaWYgKHNlY3Rpb24uY29uc3VtZXIuX2ZpbmRTb3VyY2VJbmRleCh1dGlsLmdldEFyZyhhQXJncywgJ3NvdXJjZScpKSA9PT0gLTEpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICB2YXIgZ2VuZXJhdGVkUG9zaXRpb24gPSBzZWN0aW9uLmNvbnN1bWVyLmdlbmVyYXRlZFBvc2l0aW9uRm9yKGFBcmdzKTtcbiAgICAgIGlmIChnZW5lcmF0ZWRQb3NpdGlvbikge1xuICAgICAgICB2YXIgcmV0ID0ge1xuICAgICAgICAgIGxpbmU6IGdlbmVyYXRlZFBvc2l0aW9uLmxpbmUgK1xuICAgICAgICAgICAgKHNlY3Rpb24uZ2VuZXJhdGVkT2Zmc2V0LmdlbmVyYXRlZExpbmUgLSAxKSxcbiAgICAgICAgICBjb2x1bW46IGdlbmVyYXRlZFBvc2l0aW9uLmNvbHVtbiArXG4gICAgICAgICAgICAoc2VjdGlvbi5nZW5lcmF0ZWRPZmZzZXQuZ2VuZXJhdGVkTGluZSA9PT0gZ2VuZXJhdGVkUG9zaXRpb24ubGluZVxuICAgICAgICAgICAgID8gc2VjdGlvbi5nZW5lcmF0ZWRPZmZzZXQuZ2VuZXJhdGVkQ29sdW1uIC0gMVxuICAgICAgICAgICAgIDogMClcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgbGluZTogbnVsbCxcbiAgICAgIGNvbHVtbjogbnVsbFxuICAgIH07XG4gIH07XG5cbi8qKlxuICogUGFyc2UgdGhlIG1hcHBpbmdzIGluIGEgc3RyaW5nIGluIHRvIGEgZGF0YSBzdHJ1Y3R1cmUgd2hpY2ggd2UgY2FuIGVhc2lseVxuICogcXVlcnkgKHRoZSBvcmRlcmVkIGFycmF5cyBpbiB0aGUgYHRoaXMuX19nZW5lcmF0ZWRNYXBwaW5nc2AgYW5kXG4gKiBgdGhpcy5fX29yaWdpbmFsTWFwcGluZ3NgIHByb3BlcnRpZXMpLlxuICovXG5JbmRleGVkU291cmNlTWFwQ29uc3VtZXIucHJvdG90eXBlLl9wYXJzZU1hcHBpbmdzID1cbiAgZnVuY3Rpb24gSW5kZXhlZFNvdXJjZU1hcENvbnN1bWVyX3BhcnNlTWFwcGluZ3MoYVN0ciwgYVNvdXJjZVJvb3QpIHtcbiAgICB0aGlzLl9fZ2VuZXJhdGVkTWFwcGluZ3MgPSBbXTtcbiAgICB0aGlzLl9fb3JpZ2luYWxNYXBwaW5ncyA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5fc2VjdGlvbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBzZWN0aW9uID0gdGhpcy5fc2VjdGlvbnNbaV07XG4gICAgICB2YXIgc2VjdGlvbk1hcHBpbmdzID0gc2VjdGlvbi5jb25zdW1lci5fZ2VuZXJhdGVkTWFwcGluZ3M7XG4gICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHNlY3Rpb25NYXBwaW5ncy5sZW5ndGg7IGorKykge1xuICAgICAgICB2YXIgbWFwcGluZyA9IHNlY3Rpb25NYXBwaW5nc1tqXTtcblxuICAgICAgICB2YXIgc291cmNlID0gc2VjdGlvbi5jb25zdW1lci5fc291cmNlcy5hdChtYXBwaW5nLnNvdXJjZSk7XG4gICAgICAgIHNvdXJjZSA9IHV0aWwuY29tcHV0ZVNvdXJjZVVSTChzZWN0aW9uLmNvbnN1bWVyLnNvdXJjZVJvb3QsIHNvdXJjZSwgdGhpcy5fc291cmNlTWFwVVJMKTtcbiAgICAgICAgdGhpcy5fc291cmNlcy5hZGQoc291cmNlKTtcbiAgICAgICAgc291cmNlID0gdGhpcy5fc291cmNlcy5pbmRleE9mKHNvdXJjZSk7XG5cbiAgICAgICAgdmFyIG5hbWUgPSBudWxsO1xuICAgICAgICBpZiAobWFwcGluZy5uYW1lKSB7XG4gICAgICAgICAgbmFtZSA9IHNlY3Rpb24uY29uc3VtZXIuX25hbWVzLmF0KG1hcHBpbmcubmFtZSk7XG4gICAgICAgICAgdGhpcy5fbmFtZXMuYWRkKG5hbWUpO1xuICAgICAgICAgIG5hbWUgPSB0aGlzLl9uYW1lcy5pbmRleE9mKG5hbWUpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gVGhlIG1hcHBpbmdzIGNvbWluZyBmcm9tIHRoZSBjb25zdW1lciBmb3IgdGhlIHNlY3Rpb24gaGF2ZVxuICAgICAgICAvLyBnZW5lcmF0ZWQgcG9zaXRpb25zIHJlbGF0aXZlIHRvIHRoZSBzdGFydCBvZiB0aGUgc2VjdGlvbiwgc28gd2VcbiAgICAgICAgLy8gbmVlZCB0byBvZmZzZXQgdGhlbSB0byBiZSByZWxhdGl2ZSB0byB0aGUgc3RhcnQgb2YgdGhlIGNvbmNhdGVuYXRlZFxuICAgICAgICAvLyBnZW5lcmF0ZWQgZmlsZS5cbiAgICAgICAgdmFyIGFkanVzdGVkTWFwcGluZyA9IHtcbiAgICAgICAgICBzb3VyY2U6IHNvdXJjZSxcbiAgICAgICAgICBnZW5lcmF0ZWRMaW5lOiBtYXBwaW5nLmdlbmVyYXRlZExpbmUgK1xuICAgICAgICAgICAgKHNlY3Rpb24uZ2VuZXJhdGVkT2Zmc2V0LmdlbmVyYXRlZExpbmUgLSAxKSxcbiAgICAgICAgICBnZW5lcmF0ZWRDb2x1bW46IG1hcHBpbmcuZ2VuZXJhdGVkQ29sdW1uICtcbiAgICAgICAgICAgIChzZWN0aW9uLmdlbmVyYXRlZE9mZnNldC5nZW5lcmF0ZWRMaW5lID09PSBtYXBwaW5nLmdlbmVyYXRlZExpbmVcbiAgICAgICAgICAgID8gc2VjdGlvbi5nZW5lcmF0ZWRPZmZzZXQuZ2VuZXJhdGVkQ29sdW1uIC0gMVxuICAgICAgICAgICAgOiAwKSxcbiAgICAgICAgICBvcmlnaW5hbExpbmU6IG1hcHBpbmcub3JpZ2luYWxMaW5lLFxuICAgICAgICAgIG9yaWdpbmFsQ29sdW1uOiBtYXBwaW5nLm9yaWdpbmFsQ29sdW1uLFxuICAgICAgICAgIG5hbWU6IG5hbWVcbiAgICAgICAgfTtcblxuICAgICAgICB0aGlzLl9fZ2VuZXJhdGVkTWFwcGluZ3MucHVzaChhZGp1c3RlZE1hcHBpbmcpO1xuICAgICAgICBpZiAodHlwZW9mIGFkanVzdGVkTWFwcGluZy5vcmlnaW5hbExpbmUgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgdGhpcy5fX29yaWdpbmFsTWFwcGluZ3MucHVzaChhZGp1c3RlZE1hcHBpbmcpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcXVpY2tTb3J0KHRoaXMuX19nZW5lcmF0ZWRNYXBwaW5ncywgdXRpbC5jb21wYXJlQnlHZW5lcmF0ZWRQb3NpdGlvbnNEZWZsYXRlZCk7XG4gICAgcXVpY2tTb3J0KHRoaXMuX19vcmlnaW5hbE1hcHBpbmdzLCB1dGlsLmNvbXBhcmVCeU9yaWdpbmFsUG9zaXRpb25zKTtcbiAgfTtcblxuZXhwb3J0cy5JbmRleGVkU291cmNlTWFwQ29uc3VtZXIgPSBJbmRleGVkU291cmNlTWFwQ29uc3VtZXI7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvZWxlY3Ryb24tdXBkYXRlci9ub2RlX21vZHVsZXMvc291cmNlLW1hcC9saWIvc291cmNlLW1hcC1jb25zdW1lci5qcyIsIi8qIC0qLSBNb2RlOiBqczsganMtaW5kZW50LWxldmVsOiAyOyAtKi0gKi9cbi8qXG4gKiBDb3B5cmlnaHQgMjAxMSBNb3ppbGxhIEZvdW5kYXRpb24gYW5kIGNvbnRyaWJ1dG9yc1xuICogTGljZW5zZWQgdW5kZXIgdGhlIE5ldyBCU0QgbGljZW5zZS4gU2VlIExJQ0VOU0Ugb3I6XG4gKiBodHRwOi8vb3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvQlNELTMtQ2xhdXNlXG4gKi9cblxuZXhwb3J0cy5HUkVBVEVTVF9MT1dFUl9CT1VORCA9IDE7XG5leHBvcnRzLkxFQVNUX1VQUEVSX0JPVU5EID0gMjtcblxuLyoqXG4gKiBSZWN1cnNpdmUgaW1wbGVtZW50YXRpb24gb2YgYmluYXJ5IHNlYXJjaC5cbiAqXG4gKiBAcGFyYW0gYUxvdyBJbmRpY2VzIGhlcmUgYW5kIGxvd2VyIGRvIG5vdCBjb250YWluIHRoZSBuZWVkbGUuXG4gKiBAcGFyYW0gYUhpZ2ggSW5kaWNlcyBoZXJlIGFuZCBoaWdoZXIgZG8gbm90IGNvbnRhaW4gdGhlIG5lZWRsZS5cbiAqIEBwYXJhbSBhTmVlZGxlIFRoZSBlbGVtZW50IGJlaW5nIHNlYXJjaGVkIGZvci5cbiAqIEBwYXJhbSBhSGF5c3RhY2sgVGhlIG5vbi1lbXB0eSBhcnJheSBiZWluZyBzZWFyY2hlZC5cbiAqIEBwYXJhbSBhQ29tcGFyZSBGdW5jdGlvbiB3aGljaCB0YWtlcyB0d28gZWxlbWVudHMgYW5kIHJldHVybnMgLTEsIDAsIG9yIDEuXG4gKiBAcGFyYW0gYUJpYXMgRWl0aGVyICdiaW5hcnlTZWFyY2guR1JFQVRFU1RfTE9XRVJfQk9VTkQnIG9yXG4gKiAgICAgJ2JpbmFyeVNlYXJjaC5MRUFTVF9VUFBFUl9CT1VORCcuIFNwZWNpZmllcyB3aGV0aGVyIHRvIHJldHVybiB0aGVcbiAqICAgICBjbG9zZXN0IGVsZW1lbnQgdGhhdCBpcyBzbWFsbGVyIHRoYW4gb3IgZ3JlYXRlciB0aGFuIHRoZSBvbmUgd2UgYXJlXG4gKiAgICAgc2VhcmNoaW5nIGZvciwgcmVzcGVjdGl2ZWx5LCBpZiB0aGUgZXhhY3QgZWxlbWVudCBjYW5ub3QgYmUgZm91bmQuXG4gKi9cbmZ1bmN0aW9uIHJlY3Vyc2l2ZVNlYXJjaChhTG93LCBhSGlnaCwgYU5lZWRsZSwgYUhheXN0YWNrLCBhQ29tcGFyZSwgYUJpYXMpIHtcbiAgLy8gVGhpcyBmdW5jdGlvbiB0ZXJtaW5hdGVzIHdoZW4gb25lIG9mIHRoZSBmb2xsb3dpbmcgaXMgdHJ1ZTpcbiAgLy9cbiAgLy8gICAxLiBXZSBmaW5kIHRoZSBleGFjdCBlbGVtZW50IHdlIGFyZSBsb29raW5nIGZvci5cbiAgLy9cbiAgLy8gICAyLiBXZSBkaWQgbm90IGZpbmQgdGhlIGV4YWN0IGVsZW1lbnQsIGJ1dCB3ZSBjYW4gcmV0dXJuIHRoZSBpbmRleCBvZlxuICAvLyAgICAgIHRoZSBuZXh0LWNsb3Nlc3QgZWxlbWVudC5cbiAgLy9cbiAgLy8gICAzLiBXZSBkaWQgbm90IGZpbmQgdGhlIGV4YWN0IGVsZW1lbnQsIGFuZCB0aGVyZSBpcyBubyBuZXh0LWNsb3Nlc3RcbiAgLy8gICAgICBlbGVtZW50IHRoYW4gdGhlIG9uZSB3ZSBhcmUgc2VhcmNoaW5nIGZvciwgc28gd2UgcmV0dXJuIC0xLlxuICB2YXIgbWlkID0gTWF0aC5mbG9vcigoYUhpZ2ggLSBhTG93KSAvIDIpICsgYUxvdztcbiAgdmFyIGNtcCA9IGFDb21wYXJlKGFOZWVkbGUsIGFIYXlzdGFja1ttaWRdLCB0cnVlKTtcbiAgaWYgKGNtcCA9PT0gMCkge1xuICAgIC8vIEZvdW5kIHRoZSBlbGVtZW50IHdlIGFyZSBsb29raW5nIGZvci5cbiAgICByZXR1cm4gbWlkO1xuICB9XG4gIGVsc2UgaWYgKGNtcCA+IDApIHtcbiAgICAvLyBPdXIgbmVlZGxlIGlzIGdyZWF0ZXIgdGhhbiBhSGF5c3RhY2tbbWlkXS5cbiAgICBpZiAoYUhpZ2ggLSBtaWQgPiAxKSB7XG4gICAgICAvLyBUaGUgZWxlbWVudCBpcyBpbiB0aGUgdXBwZXIgaGFsZi5cbiAgICAgIHJldHVybiByZWN1cnNpdmVTZWFyY2gobWlkLCBhSGlnaCwgYU5lZWRsZSwgYUhheXN0YWNrLCBhQ29tcGFyZSwgYUJpYXMpO1xuICAgIH1cblxuICAgIC8vIFRoZSBleGFjdCBuZWVkbGUgZWxlbWVudCB3YXMgbm90IGZvdW5kIGluIHRoaXMgaGF5c3RhY2suIERldGVybWluZSBpZlxuICAgIC8vIHdlIGFyZSBpbiB0ZXJtaW5hdGlvbiBjYXNlICgzKSBvciAoMikgYW5kIHJldHVybiB0aGUgYXBwcm9wcmlhdGUgdGhpbmcuXG4gICAgaWYgKGFCaWFzID09IGV4cG9ydHMuTEVBU1RfVVBQRVJfQk9VTkQpIHtcbiAgICAgIHJldHVybiBhSGlnaCA8IGFIYXlzdGFjay5sZW5ndGggPyBhSGlnaCA6IC0xO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gbWlkO1xuICAgIH1cbiAgfVxuICBlbHNlIHtcbiAgICAvLyBPdXIgbmVlZGxlIGlzIGxlc3MgdGhhbiBhSGF5c3RhY2tbbWlkXS5cbiAgICBpZiAobWlkIC0gYUxvdyA+IDEpIHtcbiAgICAgIC8vIFRoZSBlbGVtZW50IGlzIGluIHRoZSBsb3dlciBoYWxmLlxuICAgICAgcmV0dXJuIHJlY3Vyc2l2ZVNlYXJjaChhTG93LCBtaWQsIGFOZWVkbGUsIGFIYXlzdGFjaywgYUNvbXBhcmUsIGFCaWFzKTtcbiAgICB9XG5cbiAgICAvLyB3ZSBhcmUgaW4gdGVybWluYXRpb24gY2FzZSAoMykgb3IgKDIpIGFuZCByZXR1cm4gdGhlIGFwcHJvcHJpYXRlIHRoaW5nLlxuICAgIGlmIChhQmlhcyA9PSBleHBvcnRzLkxFQVNUX1VQUEVSX0JPVU5EKSB7XG4gICAgICByZXR1cm4gbWlkO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gYUxvdyA8IDAgPyAtMSA6IGFMb3c7XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogVGhpcyBpcyBhbiBpbXBsZW1lbnRhdGlvbiBvZiBiaW5hcnkgc2VhcmNoIHdoaWNoIHdpbGwgYWx3YXlzIHRyeSBhbmQgcmV0dXJuXG4gKiB0aGUgaW5kZXggb2YgdGhlIGNsb3Nlc3QgZWxlbWVudCBpZiB0aGVyZSBpcyBubyBleGFjdCBoaXQuIFRoaXMgaXMgYmVjYXVzZVxuICogbWFwcGluZ3MgYmV0d2VlbiBvcmlnaW5hbCBhbmQgZ2VuZXJhdGVkIGxpbmUvY29sIHBhaXJzIGFyZSBzaW5nbGUgcG9pbnRzLFxuICogYW5kIHRoZXJlIGlzIGFuIGltcGxpY2l0IHJlZ2lvbiBiZXR3ZWVuIGVhY2ggb2YgdGhlbSwgc28gYSBtaXNzIGp1c3QgbWVhbnNcbiAqIHRoYXQgeW91IGFyZW4ndCBvbiB0aGUgdmVyeSBzdGFydCBvZiBhIHJlZ2lvbi5cbiAqXG4gKiBAcGFyYW0gYU5lZWRsZSBUaGUgZWxlbWVudCB5b3UgYXJlIGxvb2tpbmcgZm9yLlxuICogQHBhcmFtIGFIYXlzdGFjayBUaGUgYXJyYXkgdGhhdCBpcyBiZWluZyBzZWFyY2hlZC5cbiAqIEBwYXJhbSBhQ29tcGFyZSBBIGZ1bmN0aW9uIHdoaWNoIHRha2VzIHRoZSBuZWVkbGUgYW5kIGFuIGVsZW1lbnQgaW4gdGhlXG4gKiAgICAgYXJyYXkgYW5kIHJldHVybnMgLTEsIDAsIG9yIDEgZGVwZW5kaW5nIG9uIHdoZXRoZXIgdGhlIG5lZWRsZSBpcyBsZXNzXG4gKiAgICAgdGhhbiwgZXF1YWwgdG8sIG9yIGdyZWF0ZXIgdGhhbiB0aGUgZWxlbWVudCwgcmVzcGVjdGl2ZWx5LlxuICogQHBhcmFtIGFCaWFzIEVpdGhlciAnYmluYXJ5U2VhcmNoLkdSRUFURVNUX0xPV0VSX0JPVU5EJyBvclxuICogICAgICdiaW5hcnlTZWFyY2guTEVBU1RfVVBQRVJfQk9VTkQnLiBTcGVjaWZpZXMgd2hldGhlciB0byByZXR1cm4gdGhlXG4gKiAgICAgY2xvc2VzdCBlbGVtZW50IHRoYXQgaXMgc21hbGxlciB0aGFuIG9yIGdyZWF0ZXIgdGhhbiB0aGUgb25lIHdlIGFyZVxuICogICAgIHNlYXJjaGluZyBmb3IsIHJlc3BlY3RpdmVseSwgaWYgdGhlIGV4YWN0IGVsZW1lbnQgY2Fubm90IGJlIGZvdW5kLlxuICogICAgIERlZmF1bHRzIHRvICdiaW5hcnlTZWFyY2guR1JFQVRFU1RfTE9XRVJfQk9VTkQnLlxuICovXG5leHBvcnRzLnNlYXJjaCA9IGZ1bmN0aW9uIHNlYXJjaChhTmVlZGxlLCBhSGF5c3RhY2ssIGFDb21wYXJlLCBhQmlhcykge1xuICBpZiAoYUhheXN0YWNrLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiAtMTtcbiAgfVxuXG4gIHZhciBpbmRleCA9IHJlY3Vyc2l2ZVNlYXJjaCgtMSwgYUhheXN0YWNrLmxlbmd0aCwgYU5lZWRsZSwgYUhheXN0YWNrLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYUNvbXBhcmUsIGFCaWFzIHx8IGV4cG9ydHMuR1JFQVRFU1RfTE9XRVJfQk9VTkQpO1xuICBpZiAoaW5kZXggPCAwKSB7XG4gICAgcmV0dXJuIC0xO1xuICB9XG5cbiAgLy8gV2UgaGF2ZSBmb3VuZCBlaXRoZXIgdGhlIGV4YWN0IGVsZW1lbnQsIG9yIHRoZSBuZXh0LWNsb3Nlc3QgZWxlbWVudCB0aGFuXG4gIC8vIHRoZSBvbmUgd2UgYXJlIHNlYXJjaGluZyBmb3IuIEhvd2V2ZXIsIHRoZXJlIG1heSBiZSBtb3JlIHRoYW4gb25lIHN1Y2hcbiAgLy8gZWxlbWVudC4gTWFrZSBzdXJlIHdlIGFsd2F5cyByZXR1cm4gdGhlIHNtYWxsZXN0IG9mIHRoZXNlLlxuICB3aGlsZSAoaW5kZXggLSAxID49IDApIHtcbiAgICBpZiAoYUNvbXBhcmUoYUhheXN0YWNrW2luZGV4XSwgYUhheXN0YWNrW2luZGV4IC0gMV0sIHRydWUpICE9PSAwKSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgLS1pbmRleDtcbiAgfVxuXG4gIHJldHVybiBpbmRleDtcbn07XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvZWxlY3Ryb24tdXBkYXRlci9ub2RlX21vZHVsZXMvc291cmNlLW1hcC9saWIvYmluYXJ5LXNlYXJjaC5qcyIsIi8qIC0qLSBNb2RlOiBqczsganMtaW5kZW50LWxldmVsOiAyOyAtKi0gKi9cbi8qXG4gKiBDb3B5cmlnaHQgMjAxMSBNb3ppbGxhIEZvdW5kYXRpb24gYW5kIGNvbnRyaWJ1dG9yc1xuICogTGljZW5zZWQgdW5kZXIgdGhlIE5ldyBCU0QgbGljZW5zZS4gU2VlIExJQ0VOU0Ugb3I6XG4gKiBodHRwOi8vb3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvQlNELTMtQ2xhdXNlXG4gKi9cblxuLy8gSXQgdHVybnMgb3V0IHRoYXQgc29tZSAobW9zdD8pIEphdmFTY3JpcHQgZW5naW5lcyBkb24ndCBzZWxmLWhvc3Rcbi8vIGBBcnJheS5wcm90b3R5cGUuc29ydGAuIFRoaXMgbWFrZXMgc2Vuc2UgYmVjYXVzZSBDKysgd2lsbCBsaWtlbHkgcmVtYWluXG4vLyBmYXN0ZXIgdGhhbiBKUyB3aGVuIGRvaW5nIHJhdyBDUFUtaW50ZW5zaXZlIHNvcnRpbmcuIEhvd2V2ZXIsIHdoZW4gdXNpbmcgYVxuLy8gY3VzdG9tIGNvbXBhcmF0b3IgZnVuY3Rpb24sIGNhbGxpbmcgYmFjayBhbmQgZm9ydGggYmV0d2VlbiB0aGUgVk0ncyBDKysgYW5kXG4vLyBKSVQnZCBKUyBpcyByYXRoZXIgc2xvdyAqYW5kKiBsb3NlcyBKSVQgdHlwZSBpbmZvcm1hdGlvbiwgcmVzdWx0aW5nIGluXG4vLyB3b3JzZSBnZW5lcmF0ZWQgY29kZSBmb3IgdGhlIGNvbXBhcmF0b3IgZnVuY3Rpb24gdGhhbiB3b3VsZCBiZSBvcHRpbWFsLiBJblxuLy8gZmFjdCwgd2hlbiBzb3J0aW5nIHdpdGggYSBjb21wYXJhdG9yLCB0aGVzZSBjb3N0cyBvdXR3ZWlnaCB0aGUgYmVuZWZpdHMgb2Zcbi8vIHNvcnRpbmcgaW4gQysrLiBCeSB1c2luZyBvdXIgb3duIEpTLWltcGxlbWVudGVkIFF1aWNrIFNvcnQgKGJlbG93KSwgd2UgZ2V0XG4vLyBhIH4zNTAwbXMgbWVhbiBzcGVlZC11cCBpbiBgYmVuY2gvYmVuY2guaHRtbGAuXG5cbi8qKlxuICogU3dhcCB0aGUgZWxlbWVudHMgaW5kZXhlZCBieSBgeGAgYW5kIGB5YCBpbiB0aGUgYXJyYXkgYGFyeWAuXG4gKlxuICogQHBhcmFtIHtBcnJheX0gYXJ5XG4gKiAgICAgICAgVGhlIGFycmF5LlxuICogQHBhcmFtIHtOdW1iZXJ9IHhcbiAqICAgICAgICBUaGUgaW5kZXggb2YgdGhlIGZpcnN0IGl0ZW0uXG4gKiBAcGFyYW0ge051bWJlcn0geVxuICogICAgICAgIFRoZSBpbmRleCBvZiB0aGUgc2Vjb25kIGl0ZW0uXG4gKi9cbmZ1bmN0aW9uIHN3YXAoYXJ5LCB4LCB5KSB7XG4gIHZhciB0ZW1wID0gYXJ5W3hdO1xuICBhcnlbeF0gPSBhcnlbeV07XG4gIGFyeVt5XSA9IHRlbXA7XG59XG5cbi8qKlxuICogUmV0dXJucyBhIHJhbmRvbSBpbnRlZ2VyIHdpdGhpbiB0aGUgcmFuZ2UgYGxvdyAuLiBoaWdoYCBpbmNsdXNpdmUuXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IGxvd1xuICogICAgICAgIFRoZSBsb3dlciBib3VuZCBvbiB0aGUgcmFuZ2UuXG4gKiBAcGFyYW0ge051bWJlcn0gaGlnaFxuICogICAgICAgIFRoZSB1cHBlciBib3VuZCBvbiB0aGUgcmFuZ2UuXG4gKi9cbmZ1bmN0aW9uIHJhbmRvbUludEluUmFuZ2UobG93LCBoaWdoKSB7XG4gIHJldHVybiBNYXRoLnJvdW5kKGxvdyArIChNYXRoLnJhbmRvbSgpICogKGhpZ2ggLSBsb3cpKSk7XG59XG5cbi8qKlxuICogVGhlIFF1aWNrIFNvcnQgYWxnb3JpdGhtLlxuICpcbiAqIEBwYXJhbSB7QXJyYXl9IGFyeVxuICogICAgICAgIEFuIGFycmF5IHRvIHNvcnQuXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBjb21wYXJhdG9yXG4gKiAgICAgICAgRnVuY3Rpb24gdG8gdXNlIHRvIGNvbXBhcmUgdHdvIGl0ZW1zLlxuICogQHBhcmFtIHtOdW1iZXJ9IHBcbiAqICAgICAgICBTdGFydCBpbmRleCBvZiB0aGUgYXJyYXlcbiAqIEBwYXJhbSB7TnVtYmVyfSByXG4gKiAgICAgICAgRW5kIGluZGV4IG9mIHRoZSBhcnJheVxuICovXG5mdW5jdGlvbiBkb1F1aWNrU29ydChhcnksIGNvbXBhcmF0b3IsIHAsIHIpIHtcbiAgLy8gSWYgb3VyIGxvd2VyIGJvdW5kIGlzIGxlc3MgdGhhbiBvdXIgdXBwZXIgYm91bmQsIHdlICgxKSBwYXJ0aXRpb24gdGhlXG4gIC8vIGFycmF5IGludG8gdHdvIHBpZWNlcyBhbmQgKDIpIHJlY3Vyc2Ugb24gZWFjaCBoYWxmLiBJZiBpdCBpcyBub3QsIHRoaXMgaXNcbiAgLy8gdGhlIGVtcHR5IGFycmF5IGFuZCBvdXIgYmFzZSBjYXNlLlxuXG4gIGlmIChwIDwgcikge1xuICAgIC8vICgxKSBQYXJ0aXRpb25pbmcuXG4gICAgLy9cbiAgICAvLyBUaGUgcGFydGl0aW9uaW5nIGNob29zZXMgYSBwaXZvdCBiZXR3ZWVuIGBwYCBhbmQgYHJgIGFuZCBtb3ZlcyBhbGxcbiAgICAvLyBlbGVtZW50cyB0aGF0IGFyZSBsZXNzIHRoYW4gb3IgZXF1YWwgdG8gdGhlIHBpdm90IHRvIHRoZSBiZWZvcmUgaXQsIGFuZFxuICAgIC8vIGFsbCB0aGUgZWxlbWVudHMgdGhhdCBhcmUgZ3JlYXRlciB0aGFuIGl0IGFmdGVyIGl0LiBUaGUgZWZmZWN0IGlzIHRoYXRcbiAgICAvLyBvbmNlIHBhcnRpdGlvbiBpcyBkb25lLCB0aGUgcGl2b3QgaXMgaW4gdGhlIGV4YWN0IHBsYWNlIGl0IHdpbGwgYmUgd2hlblxuICAgIC8vIHRoZSBhcnJheSBpcyBwdXQgaW4gc29ydGVkIG9yZGVyLCBhbmQgaXQgd2lsbCBub3QgbmVlZCB0byBiZSBtb3ZlZFxuICAgIC8vIGFnYWluLiBUaGlzIHJ1bnMgaW4gTyhuKSB0aW1lLlxuXG4gICAgLy8gQWx3YXlzIGNob29zZSBhIHJhbmRvbSBwaXZvdCBzbyB0aGF0IGFuIGlucHV0IGFycmF5IHdoaWNoIGlzIHJldmVyc2VcbiAgICAvLyBzb3J0ZWQgZG9lcyBub3QgY2F1c2UgTyhuXjIpIHJ1bm5pbmcgdGltZS5cbiAgICB2YXIgcGl2b3RJbmRleCA9IHJhbmRvbUludEluUmFuZ2UocCwgcik7XG4gICAgdmFyIGkgPSBwIC0gMTtcblxuICAgIHN3YXAoYXJ5LCBwaXZvdEluZGV4LCByKTtcbiAgICB2YXIgcGl2b3QgPSBhcnlbcl07XG5cbiAgICAvLyBJbW1lZGlhdGVseSBhZnRlciBgamAgaXMgaW5jcmVtZW50ZWQgaW4gdGhpcyBsb29wLCB0aGUgZm9sbG93aW5nIGhvbGRcbiAgICAvLyB0cnVlOlxuICAgIC8vXG4gICAgLy8gICAqIEV2ZXJ5IGVsZW1lbnQgaW4gYGFyeVtwIC4uIGldYCBpcyBsZXNzIHRoYW4gb3IgZXF1YWwgdG8gdGhlIHBpdm90LlxuICAgIC8vXG4gICAgLy8gICAqIEV2ZXJ5IGVsZW1lbnQgaW4gYGFyeVtpKzEgLi4gai0xXWAgaXMgZ3JlYXRlciB0aGFuIHRoZSBwaXZvdC5cbiAgICBmb3IgKHZhciBqID0gcDsgaiA8IHI7IGorKykge1xuICAgICAgaWYgKGNvbXBhcmF0b3IoYXJ5W2pdLCBwaXZvdCkgPD0gMCkge1xuICAgICAgICBpICs9IDE7XG4gICAgICAgIHN3YXAoYXJ5LCBpLCBqKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBzd2FwKGFyeSwgaSArIDEsIGopO1xuICAgIHZhciBxID0gaSArIDE7XG5cbiAgICAvLyAoMikgUmVjdXJzZSBvbiBlYWNoIGhhbGYuXG5cbiAgICBkb1F1aWNrU29ydChhcnksIGNvbXBhcmF0b3IsIHAsIHEgLSAxKTtcbiAgICBkb1F1aWNrU29ydChhcnksIGNvbXBhcmF0b3IsIHEgKyAxLCByKTtcbiAgfVxufVxuXG4vKipcbiAqIFNvcnQgdGhlIGdpdmVuIGFycmF5IGluLXBsYWNlIHdpdGggdGhlIGdpdmVuIGNvbXBhcmF0b3IgZnVuY3Rpb24uXG4gKlxuICogQHBhcmFtIHtBcnJheX0gYXJ5XG4gKiAgICAgICAgQW4gYXJyYXkgdG8gc29ydC5cbiAqIEBwYXJhbSB7ZnVuY3Rpb259IGNvbXBhcmF0b3JcbiAqICAgICAgICBGdW5jdGlvbiB0byB1c2UgdG8gY29tcGFyZSB0d28gaXRlbXMuXG4gKi9cbmV4cG9ydHMucXVpY2tTb3J0ID0gZnVuY3Rpb24gKGFyeSwgY29tcGFyYXRvcikge1xuICBkb1F1aWNrU29ydChhcnksIGNvbXBhcmF0b3IsIDAsIGFyeS5sZW5ndGggLSAxKTtcbn07XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvZWxlY3Ryb24tdXBkYXRlci9ub2RlX21vZHVsZXMvc291cmNlLW1hcC9saWIvcXVpY2stc29ydC5qcyIsIi8qIC0qLSBNb2RlOiBqczsganMtaW5kZW50LWxldmVsOiAyOyAtKi0gKi9cbi8qXG4gKiBDb3B5cmlnaHQgMjAxMSBNb3ppbGxhIEZvdW5kYXRpb24gYW5kIGNvbnRyaWJ1dG9yc1xuICogTGljZW5zZWQgdW5kZXIgdGhlIE5ldyBCU0QgbGljZW5zZS4gU2VlIExJQ0VOU0Ugb3I6XG4gKiBodHRwOi8vb3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvQlNELTMtQ2xhdXNlXG4gKi9cblxudmFyIFNvdXJjZU1hcEdlbmVyYXRvciA9IHJlcXVpcmUoJy4vc291cmNlLW1hcC1nZW5lcmF0b3InKS5Tb3VyY2VNYXBHZW5lcmF0b3I7XG52YXIgdXRpbCA9IHJlcXVpcmUoJy4vdXRpbCcpO1xuXG4vLyBNYXRjaGVzIGEgV2luZG93cy1zdHlsZSBgXFxyXFxuYCBuZXdsaW5lIG9yIGEgYFxcbmAgbmV3bGluZSB1c2VkIGJ5IGFsbCBvdGhlclxuLy8gb3BlcmF0aW5nIHN5c3RlbXMgdGhlc2UgZGF5cyAoY2FwdHVyaW5nIHRoZSByZXN1bHQpLlxudmFyIFJFR0VYX05FV0xJTkUgPSAvKFxccj9cXG4pLztcblxuLy8gTmV3bGluZSBjaGFyYWN0ZXIgY29kZSBmb3IgY2hhckNvZGVBdCgpIGNvbXBhcmlzb25zXG52YXIgTkVXTElORV9DT0RFID0gMTA7XG5cbi8vIFByaXZhdGUgc3ltYm9sIGZvciBpZGVudGlmeWluZyBgU291cmNlTm9kZWBzIHdoZW4gbXVsdGlwbGUgdmVyc2lvbnMgb2Zcbi8vIHRoZSBzb3VyY2UtbWFwIGxpYnJhcnkgYXJlIGxvYWRlZC4gVGhpcyBNVVNUIE5PVCBDSEFOR0UgYWNyb3NzXG4vLyB2ZXJzaW9ucyFcbnZhciBpc1NvdXJjZU5vZGUgPSBcIiQkJGlzU291cmNlTm9kZSQkJFwiO1xuXG4vKipcbiAqIFNvdXJjZU5vZGVzIHByb3ZpZGUgYSB3YXkgdG8gYWJzdHJhY3Qgb3ZlciBpbnRlcnBvbGF0aW5nL2NvbmNhdGVuYXRpbmdcbiAqIHNuaXBwZXRzIG9mIGdlbmVyYXRlZCBKYXZhU2NyaXB0IHNvdXJjZSBjb2RlIHdoaWxlIG1haW50YWluaW5nIHRoZSBsaW5lIGFuZFxuICogY29sdW1uIGluZm9ybWF0aW9uIGFzc29jaWF0ZWQgd2l0aCB0aGUgb3JpZ2luYWwgc291cmNlIGNvZGUuXG4gKlxuICogQHBhcmFtIGFMaW5lIFRoZSBvcmlnaW5hbCBsaW5lIG51bWJlci5cbiAqIEBwYXJhbSBhQ29sdW1uIFRoZSBvcmlnaW5hbCBjb2x1bW4gbnVtYmVyLlxuICogQHBhcmFtIGFTb3VyY2UgVGhlIG9yaWdpbmFsIHNvdXJjZSdzIGZpbGVuYW1lLlxuICogQHBhcmFtIGFDaHVua3MgT3B0aW9uYWwuIEFuIGFycmF5IG9mIHN0cmluZ3Mgd2hpY2ggYXJlIHNuaXBwZXRzIG9mXG4gKiAgICAgICAgZ2VuZXJhdGVkIEpTLCBvciBvdGhlciBTb3VyY2VOb2Rlcy5cbiAqIEBwYXJhbSBhTmFtZSBUaGUgb3JpZ2luYWwgaWRlbnRpZmllci5cbiAqL1xuZnVuY3Rpb24gU291cmNlTm9kZShhTGluZSwgYUNvbHVtbiwgYVNvdXJjZSwgYUNodW5rcywgYU5hbWUpIHtcbiAgdGhpcy5jaGlsZHJlbiA9IFtdO1xuICB0aGlzLnNvdXJjZUNvbnRlbnRzID0ge307XG4gIHRoaXMubGluZSA9IGFMaW5lID09IG51bGwgPyBudWxsIDogYUxpbmU7XG4gIHRoaXMuY29sdW1uID0gYUNvbHVtbiA9PSBudWxsID8gbnVsbCA6IGFDb2x1bW47XG4gIHRoaXMuc291cmNlID0gYVNvdXJjZSA9PSBudWxsID8gbnVsbCA6IGFTb3VyY2U7XG4gIHRoaXMubmFtZSA9IGFOYW1lID09IG51bGwgPyBudWxsIDogYU5hbWU7XG4gIHRoaXNbaXNTb3VyY2VOb2RlXSA9IHRydWU7XG4gIGlmIChhQ2h1bmtzICE9IG51bGwpIHRoaXMuYWRkKGFDaHVua3MpO1xufVxuXG4vKipcbiAqIENyZWF0ZXMgYSBTb3VyY2VOb2RlIGZyb20gZ2VuZXJhdGVkIGNvZGUgYW5kIGEgU291cmNlTWFwQ29uc3VtZXIuXG4gKlxuICogQHBhcmFtIGFHZW5lcmF0ZWRDb2RlIFRoZSBnZW5lcmF0ZWQgY29kZVxuICogQHBhcmFtIGFTb3VyY2VNYXBDb25zdW1lciBUaGUgU291cmNlTWFwIGZvciB0aGUgZ2VuZXJhdGVkIGNvZGVcbiAqIEBwYXJhbSBhUmVsYXRpdmVQYXRoIE9wdGlvbmFsLiBUaGUgcGF0aCB0aGF0IHJlbGF0aXZlIHNvdXJjZXMgaW4gdGhlXG4gKiAgICAgICAgU291cmNlTWFwQ29uc3VtZXIgc2hvdWxkIGJlIHJlbGF0aXZlIHRvLlxuICovXG5Tb3VyY2VOb2RlLmZyb21TdHJpbmdXaXRoU291cmNlTWFwID1cbiAgZnVuY3Rpb24gU291cmNlTm9kZV9mcm9tU3RyaW5nV2l0aFNvdXJjZU1hcChhR2VuZXJhdGVkQ29kZSwgYVNvdXJjZU1hcENvbnN1bWVyLCBhUmVsYXRpdmVQYXRoKSB7XG4gICAgLy8gVGhlIFNvdXJjZU5vZGUgd2Ugd2FudCB0byBmaWxsIHdpdGggdGhlIGdlbmVyYXRlZCBjb2RlXG4gICAgLy8gYW5kIHRoZSBTb3VyY2VNYXBcbiAgICB2YXIgbm9kZSA9IG5ldyBTb3VyY2VOb2RlKCk7XG5cbiAgICAvLyBBbGwgZXZlbiBpbmRpY2VzIG9mIHRoaXMgYXJyYXkgYXJlIG9uZSBsaW5lIG9mIHRoZSBnZW5lcmF0ZWQgY29kZSxcbiAgICAvLyB3aGlsZSBhbGwgb2RkIGluZGljZXMgYXJlIHRoZSBuZXdsaW5lcyBiZXR3ZWVuIHR3byBhZGphY2VudCBsaW5lc1xuICAgIC8vIChzaW5jZSBgUkVHRVhfTkVXTElORWAgY2FwdHVyZXMgaXRzIG1hdGNoKS5cbiAgICAvLyBQcm9jZXNzZWQgZnJhZ21lbnRzIGFyZSBhY2Nlc3NlZCBieSBjYWxsaW5nIGBzaGlmdE5leHRMaW5lYC5cbiAgICB2YXIgcmVtYWluaW5nTGluZXMgPSBhR2VuZXJhdGVkQ29kZS5zcGxpdChSRUdFWF9ORVdMSU5FKTtcbiAgICB2YXIgcmVtYWluaW5nTGluZXNJbmRleCA9IDA7XG4gICAgdmFyIHNoaWZ0TmV4dExpbmUgPSBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBsaW5lQ29udGVudHMgPSBnZXROZXh0TGluZSgpO1xuICAgICAgLy8gVGhlIGxhc3QgbGluZSBvZiBhIGZpbGUgbWlnaHQgbm90IGhhdmUgYSBuZXdsaW5lLlxuICAgICAgdmFyIG5ld0xpbmUgPSBnZXROZXh0TGluZSgpIHx8IFwiXCI7XG4gICAgICByZXR1cm4gbGluZUNvbnRlbnRzICsgbmV3TGluZTtcblxuICAgICAgZnVuY3Rpb24gZ2V0TmV4dExpbmUoKSB7XG4gICAgICAgIHJldHVybiByZW1haW5pbmdMaW5lc0luZGV4IDwgcmVtYWluaW5nTGluZXMubGVuZ3RoID9cbiAgICAgICAgICAgIHJlbWFpbmluZ0xpbmVzW3JlbWFpbmluZ0xpbmVzSW5kZXgrK10gOiB1bmRlZmluZWQ7XG4gICAgICB9XG4gICAgfTtcblxuICAgIC8vIFdlIG5lZWQgdG8gcmVtZW1iZXIgdGhlIHBvc2l0aW9uIG9mIFwicmVtYWluaW5nTGluZXNcIlxuICAgIHZhciBsYXN0R2VuZXJhdGVkTGluZSA9IDEsIGxhc3RHZW5lcmF0ZWRDb2x1bW4gPSAwO1xuXG4gICAgLy8gVGhlIGdlbmVyYXRlIFNvdXJjZU5vZGVzIHdlIG5lZWQgYSBjb2RlIHJhbmdlLlxuICAgIC8vIFRvIGV4dHJhY3QgaXQgY3VycmVudCBhbmQgbGFzdCBtYXBwaW5nIGlzIHVzZWQuXG4gICAgLy8gSGVyZSB3ZSBzdG9yZSB0aGUgbGFzdCBtYXBwaW5nLlxuICAgIHZhciBsYXN0TWFwcGluZyA9IG51bGw7XG5cbiAgICBhU291cmNlTWFwQ29uc3VtZXIuZWFjaE1hcHBpbmcoZnVuY3Rpb24gKG1hcHBpbmcpIHtcbiAgICAgIGlmIChsYXN0TWFwcGluZyAhPT0gbnVsbCkge1xuICAgICAgICAvLyBXZSBhZGQgdGhlIGNvZGUgZnJvbSBcImxhc3RNYXBwaW5nXCIgdG8gXCJtYXBwaW5nXCI6XG4gICAgICAgIC8vIEZpcnN0IGNoZWNrIGlmIHRoZXJlIGlzIGEgbmV3IGxpbmUgaW4gYmV0d2Vlbi5cbiAgICAgICAgaWYgKGxhc3RHZW5lcmF0ZWRMaW5lIDwgbWFwcGluZy5nZW5lcmF0ZWRMaW5lKSB7XG4gICAgICAgICAgLy8gQXNzb2NpYXRlIGZpcnN0IGxpbmUgd2l0aCBcImxhc3RNYXBwaW5nXCJcbiAgICAgICAgICBhZGRNYXBwaW5nV2l0aENvZGUobGFzdE1hcHBpbmcsIHNoaWZ0TmV4dExpbmUoKSk7XG4gICAgICAgICAgbGFzdEdlbmVyYXRlZExpbmUrKztcbiAgICAgICAgICBsYXN0R2VuZXJhdGVkQ29sdW1uID0gMDtcbiAgICAgICAgICAvLyBUaGUgcmVtYWluaW5nIGNvZGUgaXMgYWRkZWQgd2l0aG91dCBtYXBwaW5nXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gVGhlcmUgaXMgbm8gbmV3IGxpbmUgaW4gYmV0d2Vlbi5cbiAgICAgICAgICAvLyBBc3NvY2lhdGUgdGhlIGNvZGUgYmV0d2VlbiBcImxhc3RHZW5lcmF0ZWRDb2x1bW5cIiBhbmRcbiAgICAgICAgICAvLyBcIm1hcHBpbmcuZ2VuZXJhdGVkQ29sdW1uXCIgd2l0aCBcImxhc3RNYXBwaW5nXCJcbiAgICAgICAgICB2YXIgbmV4dExpbmUgPSByZW1haW5pbmdMaW5lc1tyZW1haW5pbmdMaW5lc0luZGV4XSB8fCAnJztcbiAgICAgICAgICB2YXIgY29kZSA9IG5leHRMaW5lLnN1YnN0cigwLCBtYXBwaW5nLmdlbmVyYXRlZENvbHVtbiAtXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGFzdEdlbmVyYXRlZENvbHVtbik7XG4gICAgICAgICAgcmVtYWluaW5nTGluZXNbcmVtYWluaW5nTGluZXNJbmRleF0gPSBuZXh0TGluZS5zdWJzdHIobWFwcGluZy5nZW5lcmF0ZWRDb2x1bW4gLVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxhc3RHZW5lcmF0ZWRDb2x1bW4pO1xuICAgICAgICAgIGxhc3RHZW5lcmF0ZWRDb2x1bW4gPSBtYXBwaW5nLmdlbmVyYXRlZENvbHVtbjtcbiAgICAgICAgICBhZGRNYXBwaW5nV2l0aENvZGUobGFzdE1hcHBpbmcsIGNvZGUpO1xuICAgICAgICAgIC8vIE5vIG1vcmUgcmVtYWluaW5nIGNvZGUsIGNvbnRpbnVlXG4gICAgICAgICAgbGFzdE1hcHBpbmcgPSBtYXBwaW5nO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgLy8gV2UgYWRkIHRoZSBnZW5lcmF0ZWQgY29kZSB1bnRpbCB0aGUgZmlyc3QgbWFwcGluZ1xuICAgICAgLy8gdG8gdGhlIFNvdXJjZU5vZGUgd2l0aG91dCBhbnkgbWFwcGluZy5cbiAgICAgIC8vIEVhY2ggbGluZSBpcyBhZGRlZCBhcyBzZXBhcmF0ZSBzdHJpbmcuXG4gICAgICB3aGlsZSAobGFzdEdlbmVyYXRlZExpbmUgPCBtYXBwaW5nLmdlbmVyYXRlZExpbmUpIHtcbiAgICAgICAgbm9kZS5hZGQoc2hpZnROZXh0TGluZSgpKTtcbiAgICAgICAgbGFzdEdlbmVyYXRlZExpbmUrKztcbiAgICAgIH1cbiAgICAgIGlmIChsYXN0R2VuZXJhdGVkQ29sdW1uIDwgbWFwcGluZy5nZW5lcmF0ZWRDb2x1bW4pIHtcbiAgICAgICAgdmFyIG5leHRMaW5lID0gcmVtYWluaW5nTGluZXNbcmVtYWluaW5nTGluZXNJbmRleF0gfHwgJyc7XG4gICAgICAgIG5vZGUuYWRkKG5leHRMaW5lLnN1YnN0cigwLCBtYXBwaW5nLmdlbmVyYXRlZENvbHVtbikpO1xuICAgICAgICByZW1haW5pbmdMaW5lc1tyZW1haW5pbmdMaW5lc0luZGV4XSA9IG5leHRMaW5lLnN1YnN0cihtYXBwaW5nLmdlbmVyYXRlZENvbHVtbik7XG4gICAgICAgIGxhc3RHZW5lcmF0ZWRDb2x1bW4gPSBtYXBwaW5nLmdlbmVyYXRlZENvbHVtbjtcbiAgICAgIH1cbiAgICAgIGxhc3RNYXBwaW5nID0gbWFwcGluZztcbiAgICB9LCB0aGlzKTtcbiAgICAvLyBXZSBoYXZlIHByb2Nlc3NlZCBhbGwgbWFwcGluZ3MuXG4gICAgaWYgKHJlbWFpbmluZ0xpbmVzSW5kZXggPCByZW1haW5pbmdMaW5lcy5sZW5ndGgpIHtcbiAgICAgIGlmIChsYXN0TWFwcGluZykge1xuICAgICAgICAvLyBBc3NvY2lhdGUgdGhlIHJlbWFpbmluZyBjb2RlIGluIHRoZSBjdXJyZW50IGxpbmUgd2l0aCBcImxhc3RNYXBwaW5nXCJcbiAgICAgICAgYWRkTWFwcGluZ1dpdGhDb2RlKGxhc3RNYXBwaW5nLCBzaGlmdE5leHRMaW5lKCkpO1xuICAgICAgfVxuICAgICAgLy8gYW5kIGFkZCB0aGUgcmVtYWluaW5nIGxpbmVzIHdpdGhvdXQgYW55IG1hcHBpbmdcbiAgICAgIG5vZGUuYWRkKHJlbWFpbmluZ0xpbmVzLnNwbGljZShyZW1haW5pbmdMaW5lc0luZGV4KS5qb2luKFwiXCIpKTtcbiAgICB9XG5cbiAgICAvLyBDb3B5IHNvdXJjZXNDb250ZW50IGludG8gU291cmNlTm9kZVxuICAgIGFTb3VyY2VNYXBDb25zdW1lci5zb3VyY2VzLmZvckVhY2goZnVuY3Rpb24gKHNvdXJjZUZpbGUpIHtcbiAgICAgIHZhciBjb250ZW50ID0gYVNvdXJjZU1hcENvbnN1bWVyLnNvdXJjZUNvbnRlbnRGb3Ioc291cmNlRmlsZSk7XG4gICAgICBpZiAoY29udGVudCAhPSBudWxsKSB7XG4gICAgICAgIGlmIChhUmVsYXRpdmVQYXRoICE9IG51bGwpIHtcbiAgICAgICAgICBzb3VyY2VGaWxlID0gdXRpbC5qb2luKGFSZWxhdGl2ZVBhdGgsIHNvdXJjZUZpbGUpO1xuICAgICAgICB9XG4gICAgICAgIG5vZGUuc2V0U291cmNlQ29udGVudChzb3VyY2VGaWxlLCBjb250ZW50KTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIHJldHVybiBub2RlO1xuXG4gICAgZnVuY3Rpb24gYWRkTWFwcGluZ1dpdGhDb2RlKG1hcHBpbmcsIGNvZGUpIHtcbiAgICAgIGlmIChtYXBwaW5nID09PSBudWxsIHx8IG1hcHBpbmcuc291cmNlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgbm9kZS5hZGQoY29kZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgc291cmNlID0gYVJlbGF0aXZlUGF0aFxuICAgICAgICAgID8gdXRpbC5qb2luKGFSZWxhdGl2ZVBhdGgsIG1hcHBpbmcuc291cmNlKVxuICAgICAgICAgIDogbWFwcGluZy5zb3VyY2U7XG4gICAgICAgIG5vZGUuYWRkKG5ldyBTb3VyY2VOb2RlKG1hcHBpbmcub3JpZ2luYWxMaW5lLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXBwaW5nLm9yaWdpbmFsQ29sdW1uLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzb3VyY2UsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvZGUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1hcHBpbmcubmFtZSkpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuLyoqXG4gKiBBZGQgYSBjaHVuayBvZiBnZW5lcmF0ZWQgSlMgdG8gdGhpcyBzb3VyY2Ugbm9kZS5cbiAqXG4gKiBAcGFyYW0gYUNodW5rIEEgc3RyaW5nIHNuaXBwZXQgb2YgZ2VuZXJhdGVkIEpTIGNvZGUsIGFub3RoZXIgaW5zdGFuY2Ugb2ZcbiAqICAgICAgICBTb3VyY2VOb2RlLCBvciBhbiBhcnJheSB3aGVyZSBlYWNoIG1lbWJlciBpcyBvbmUgb2YgdGhvc2UgdGhpbmdzLlxuICovXG5Tb3VyY2VOb2RlLnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbiBTb3VyY2VOb2RlX2FkZChhQ2h1bmspIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkoYUNodW5rKSkge1xuICAgIGFDaHVuay5mb3JFYWNoKGZ1bmN0aW9uIChjaHVuaykge1xuICAgICAgdGhpcy5hZGQoY2h1bmspO1xuICAgIH0sIHRoaXMpO1xuICB9XG4gIGVsc2UgaWYgKGFDaHVua1tpc1NvdXJjZU5vZGVdIHx8IHR5cGVvZiBhQ2h1bmsgPT09IFwic3RyaW5nXCIpIHtcbiAgICBpZiAoYUNodW5rKSB7XG4gICAgICB0aGlzLmNoaWxkcmVuLnB1c2goYUNodW5rKTtcbiAgICB9XG4gIH1cbiAgZWxzZSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgIFwiRXhwZWN0ZWQgYSBTb3VyY2VOb2RlLCBzdHJpbmcsIG9yIGFuIGFycmF5IG9mIFNvdXJjZU5vZGVzIGFuZCBzdHJpbmdzLiBHb3QgXCIgKyBhQ2h1bmtcbiAgICApO1xuICB9XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBBZGQgYSBjaHVuayBvZiBnZW5lcmF0ZWQgSlMgdG8gdGhlIGJlZ2lubmluZyBvZiB0aGlzIHNvdXJjZSBub2RlLlxuICpcbiAqIEBwYXJhbSBhQ2h1bmsgQSBzdHJpbmcgc25pcHBldCBvZiBnZW5lcmF0ZWQgSlMgY29kZSwgYW5vdGhlciBpbnN0YW5jZSBvZlxuICogICAgICAgIFNvdXJjZU5vZGUsIG9yIGFuIGFycmF5IHdoZXJlIGVhY2ggbWVtYmVyIGlzIG9uZSBvZiB0aG9zZSB0aGluZ3MuXG4gKi9cblNvdXJjZU5vZGUucHJvdG90eXBlLnByZXBlbmQgPSBmdW5jdGlvbiBTb3VyY2VOb2RlX3ByZXBlbmQoYUNodW5rKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KGFDaHVuaykpIHtcbiAgICBmb3IgKHZhciBpID0gYUNodW5rLmxlbmd0aC0xOyBpID49IDA7IGktLSkge1xuICAgICAgdGhpcy5wcmVwZW5kKGFDaHVua1tpXSk7XG4gICAgfVxuICB9XG4gIGVsc2UgaWYgKGFDaHVua1tpc1NvdXJjZU5vZGVdIHx8IHR5cGVvZiBhQ2h1bmsgPT09IFwic3RyaW5nXCIpIHtcbiAgICB0aGlzLmNoaWxkcmVuLnVuc2hpZnQoYUNodW5rKTtcbiAgfVxuICBlbHNlIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgXCJFeHBlY3RlZCBhIFNvdXJjZU5vZGUsIHN0cmluZywgb3IgYW4gYXJyYXkgb2YgU291cmNlTm9kZXMgYW5kIHN0cmluZ3MuIEdvdCBcIiArIGFDaHVua1xuICAgICk7XG4gIH1cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFdhbGsgb3ZlciB0aGUgdHJlZSBvZiBKUyBzbmlwcGV0cyBpbiB0aGlzIG5vZGUgYW5kIGl0cyBjaGlsZHJlbi4gVGhlXG4gKiB3YWxraW5nIGZ1bmN0aW9uIGlzIGNhbGxlZCBvbmNlIGZvciBlYWNoIHNuaXBwZXQgb2YgSlMgYW5kIGlzIHBhc3NlZCB0aGF0XG4gKiBzbmlwcGV0IGFuZCB0aGUgaXRzIG9yaWdpbmFsIGFzc29jaWF0ZWQgc291cmNlJ3MgbGluZS9jb2x1bW4gbG9jYXRpb24uXG4gKlxuICogQHBhcmFtIGFGbiBUaGUgdHJhdmVyc2FsIGZ1bmN0aW9uLlxuICovXG5Tb3VyY2VOb2RlLnByb3RvdHlwZS53YWxrID0gZnVuY3Rpb24gU291cmNlTm9kZV93YWxrKGFGbikge1xuICB2YXIgY2h1bms7XG4gIGZvciAodmFyIGkgPSAwLCBsZW4gPSB0aGlzLmNoaWxkcmVuLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgY2h1bmsgPSB0aGlzLmNoaWxkcmVuW2ldO1xuICAgIGlmIChjaHVua1tpc1NvdXJjZU5vZGVdKSB7XG4gICAgICBjaHVuay53YWxrKGFGbik7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgaWYgKGNodW5rICE9PSAnJykge1xuICAgICAgICBhRm4oY2h1bmssIHsgc291cmNlOiB0aGlzLnNvdXJjZSxcbiAgICAgICAgICAgICAgICAgICAgIGxpbmU6IHRoaXMubGluZSxcbiAgICAgICAgICAgICAgICAgICAgIGNvbHVtbjogdGhpcy5jb2x1bW4sXG4gICAgICAgICAgICAgICAgICAgICBuYW1lOiB0aGlzLm5hbWUgfSk7XG4gICAgICB9XG4gICAgfVxuICB9XG59O1xuXG4vKipcbiAqIExpa2UgYFN0cmluZy5wcm90b3R5cGUuam9pbmAgZXhjZXB0IGZvciBTb3VyY2VOb2Rlcy4gSW5zZXJ0cyBgYVN0cmAgYmV0d2VlblxuICogZWFjaCBvZiBgdGhpcy5jaGlsZHJlbmAuXG4gKlxuICogQHBhcmFtIGFTZXAgVGhlIHNlcGFyYXRvci5cbiAqL1xuU291cmNlTm9kZS5wcm90b3R5cGUuam9pbiA9IGZ1bmN0aW9uIFNvdXJjZU5vZGVfam9pbihhU2VwKSB7XG4gIHZhciBuZXdDaGlsZHJlbjtcbiAgdmFyIGk7XG4gIHZhciBsZW4gPSB0aGlzLmNoaWxkcmVuLmxlbmd0aDtcbiAgaWYgKGxlbiA+IDApIHtcbiAgICBuZXdDaGlsZHJlbiA9IFtdO1xuICAgIGZvciAoaSA9IDA7IGkgPCBsZW4tMTsgaSsrKSB7XG4gICAgICBuZXdDaGlsZHJlbi5wdXNoKHRoaXMuY2hpbGRyZW5baV0pO1xuICAgICAgbmV3Q2hpbGRyZW4ucHVzaChhU2VwKTtcbiAgICB9XG4gICAgbmV3Q2hpbGRyZW4ucHVzaCh0aGlzLmNoaWxkcmVuW2ldKTtcbiAgICB0aGlzLmNoaWxkcmVuID0gbmV3Q2hpbGRyZW47XG4gIH1cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIENhbGwgU3RyaW5nLnByb3RvdHlwZS5yZXBsYWNlIG9uIHRoZSB2ZXJ5IHJpZ2h0LW1vc3Qgc291cmNlIHNuaXBwZXQuIFVzZWZ1bFxuICogZm9yIHRyaW1taW5nIHdoaXRlc3BhY2UgZnJvbSB0aGUgZW5kIG9mIGEgc291cmNlIG5vZGUsIGV0Yy5cbiAqXG4gKiBAcGFyYW0gYVBhdHRlcm4gVGhlIHBhdHRlcm4gdG8gcmVwbGFjZS5cbiAqIEBwYXJhbSBhUmVwbGFjZW1lbnQgVGhlIHRoaW5nIHRvIHJlcGxhY2UgdGhlIHBhdHRlcm4gd2l0aC5cbiAqL1xuU291cmNlTm9kZS5wcm90b3R5cGUucmVwbGFjZVJpZ2h0ID0gZnVuY3Rpb24gU291cmNlTm9kZV9yZXBsYWNlUmlnaHQoYVBhdHRlcm4sIGFSZXBsYWNlbWVudCkge1xuICB2YXIgbGFzdENoaWxkID0gdGhpcy5jaGlsZHJlblt0aGlzLmNoaWxkcmVuLmxlbmd0aCAtIDFdO1xuICBpZiAobGFzdENoaWxkW2lzU291cmNlTm9kZV0pIHtcbiAgICBsYXN0Q2hpbGQucmVwbGFjZVJpZ2h0KGFQYXR0ZXJuLCBhUmVwbGFjZW1lbnQpO1xuICB9XG4gIGVsc2UgaWYgKHR5cGVvZiBsYXN0Q2hpbGQgPT09ICdzdHJpbmcnKSB7XG4gICAgdGhpcy5jaGlsZHJlblt0aGlzLmNoaWxkcmVuLmxlbmd0aCAtIDFdID0gbGFzdENoaWxkLnJlcGxhY2UoYVBhdHRlcm4sIGFSZXBsYWNlbWVudCk7XG4gIH1cbiAgZWxzZSB7XG4gICAgdGhpcy5jaGlsZHJlbi5wdXNoKCcnLnJlcGxhY2UoYVBhdHRlcm4sIGFSZXBsYWNlbWVudCkpO1xuICB9XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBTZXQgdGhlIHNvdXJjZSBjb250ZW50IGZvciBhIHNvdXJjZSBmaWxlLiBUaGlzIHdpbGwgYmUgYWRkZWQgdG8gdGhlIFNvdXJjZU1hcEdlbmVyYXRvclxuICogaW4gdGhlIHNvdXJjZXNDb250ZW50IGZpZWxkLlxuICpcbiAqIEBwYXJhbSBhU291cmNlRmlsZSBUaGUgZmlsZW5hbWUgb2YgdGhlIHNvdXJjZSBmaWxlXG4gKiBAcGFyYW0gYVNvdXJjZUNvbnRlbnQgVGhlIGNvbnRlbnQgb2YgdGhlIHNvdXJjZSBmaWxlXG4gKi9cblNvdXJjZU5vZGUucHJvdG90eXBlLnNldFNvdXJjZUNvbnRlbnQgPVxuICBmdW5jdGlvbiBTb3VyY2VOb2RlX3NldFNvdXJjZUNvbnRlbnQoYVNvdXJjZUZpbGUsIGFTb3VyY2VDb250ZW50KSB7XG4gICAgdGhpcy5zb3VyY2VDb250ZW50c1t1dGlsLnRvU2V0U3RyaW5nKGFTb3VyY2VGaWxlKV0gPSBhU291cmNlQ29udGVudDtcbiAgfTtcblxuLyoqXG4gKiBXYWxrIG92ZXIgdGhlIHRyZWUgb2YgU291cmNlTm9kZXMuIFRoZSB3YWxraW5nIGZ1bmN0aW9uIGlzIGNhbGxlZCBmb3IgZWFjaFxuICogc291cmNlIGZpbGUgY29udGVudCBhbmQgaXMgcGFzc2VkIHRoZSBmaWxlbmFtZSBhbmQgc291cmNlIGNvbnRlbnQuXG4gKlxuICogQHBhcmFtIGFGbiBUaGUgdHJhdmVyc2FsIGZ1bmN0aW9uLlxuICovXG5Tb3VyY2VOb2RlLnByb3RvdHlwZS53YWxrU291cmNlQ29udGVudHMgPVxuICBmdW5jdGlvbiBTb3VyY2VOb2RlX3dhbGtTb3VyY2VDb250ZW50cyhhRm4pIHtcbiAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gdGhpcy5jaGlsZHJlbi5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgaWYgKHRoaXMuY2hpbGRyZW5baV1baXNTb3VyY2VOb2RlXSkge1xuICAgICAgICB0aGlzLmNoaWxkcmVuW2ldLndhbGtTb3VyY2VDb250ZW50cyhhRm4pO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBzb3VyY2VzID0gT2JqZWN0LmtleXModGhpcy5zb3VyY2VDb250ZW50cyk7XG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHNvdXJjZXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIGFGbih1dGlsLmZyb21TZXRTdHJpbmcoc291cmNlc1tpXSksIHRoaXMuc291cmNlQ29udGVudHNbc291cmNlc1tpXV0pO1xuICAgIH1cbiAgfTtcblxuLyoqXG4gKiBSZXR1cm4gdGhlIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGlzIHNvdXJjZSBub2RlLiBXYWxrcyBvdmVyIHRoZSB0cmVlXG4gKiBhbmQgY29uY2F0ZW5hdGVzIGFsbCB0aGUgdmFyaW91cyBzbmlwcGV0cyB0b2dldGhlciB0byBvbmUgc3RyaW5nLlxuICovXG5Tb3VyY2VOb2RlLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uIFNvdXJjZU5vZGVfdG9TdHJpbmcoKSB7XG4gIHZhciBzdHIgPSBcIlwiO1xuICB0aGlzLndhbGsoZnVuY3Rpb24gKGNodW5rKSB7XG4gICAgc3RyICs9IGNodW5rO1xuICB9KTtcbiAgcmV0dXJuIHN0cjtcbn07XG5cbi8qKlxuICogUmV0dXJucyB0aGUgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoaXMgc291cmNlIG5vZGUgYWxvbmcgd2l0aCBhIHNvdXJjZVxuICogbWFwLlxuICovXG5Tb3VyY2VOb2RlLnByb3RvdHlwZS50b1N0cmluZ1dpdGhTb3VyY2VNYXAgPSBmdW5jdGlvbiBTb3VyY2VOb2RlX3RvU3RyaW5nV2l0aFNvdXJjZU1hcChhQXJncykge1xuICB2YXIgZ2VuZXJhdGVkID0ge1xuICAgIGNvZGU6IFwiXCIsXG4gICAgbGluZTogMSxcbiAgICBjb2x1bW46IDBcbiAgfTtcbiAgdmFyIG1hcCA9IG5ldyBTb3VyY2VNYXBHZW5lcmF0b3IoYUFyZ3MpO1xuICB2YXIgc291cmNlTWFwcGluZ0FjdGl2ZSA9IGZhbHNlO1xuICB2YXIgbGFzdE9yaWdpbmFsU291cmNlID0gbnVsbDtcbiAgdmFyIGxhc3RPcmlnaW5hbExpbmUgPSBudWxsO1xuICB2YXIgbGFzdE9yaWdpbmFsQ29sdW1uID0gbnVsbDtcbiAgdmFyIGxhc3RPcmlnaW5hbE5hbWUgPSBudWxsO1xuICB0aGlzLndhbGsoZnVuY3Rpb24gKGNodW5rLCBvcmlnaW5hbCkge1xuICAgIGdlbmVyYXRlZC5jb2RlICs9IGNodW5rO1xuICAgIGlmIChvcmlnaW5hbC5zb3VyY2UgIT09IG51bGxcbiAgICAgICAgJiYgb3JpZ2luYWwubGluZSAhPT0gbnVsbFxuICAgICAgICAmJiBvcmlnaW5hbC5jb2x1bW4gIT09IG51bGwpIHtcbiAgICAgIGlmKGxhc3RPcmlnaW5hbFNvdXJjZSAhPT0gb3JpZ2luYWwuc291cmNlXG4gICAgICAgICB8fCBsYXN0T3JpZ2luYWxMaW5lICE9PSBvcmlnaW5hbC5saW5lXG4gICAgICAgICB8fCBsYXN0T3JpZ2luYWxDb2x1bW4gIT09IG9yaWdpbmFsLmNvbHVtblxuICAgICAgICAgfHwgbGFzdE9yaWdpbmFsTmFtZSAhPT0gb3JpZ2luYWwubmFtZSkge1xuICAgICAgICBtYXAuYWRkTWFwcGluZyh7XG4gICAgICAgICAgc291cmNlOiBvcmlnaW5hbC5zb3VyY2UsXG4gICAgICAgICAgb3JpZ2luYWw6IHtcbiAgICAgICAgICAgIGxpbmU6IG9yaWdpbmFsLmxpbmUsXG4gICAgICAgICAgICBjb2x1bW46IG9yaWdpbmFsLmNvbHVtblxuICAgICAgICAgIH0sXG4gICAgICAgICAgZ2VuZXJhdGVkOiB7XG4gICAgICAgICAgICBsaW5lOiBnZW5lcmF0ZWQubGluZSxcbiAgICAgICAgICAgIGNvbHVtbjogZ2VuZXJhdGVkLmNvbHVtblxuICAgICAgICAgIH0sXG4gICAgICAgICAgbmFtZTogb3JpZ2luYWwubmFtZVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIGxhc3RPcmlnaW5hbFNvdXJjZSA9IG9yaWdpbmFsLnNvdXJjZTtcbiAgICAgIGxhc3RPcmlnaW5hbExpbmUgPSBvcmlnaW5hbC5saW5lO1xuICAgICAgbGFzdE9yaWdpbmFsQ29sdW1uID0gb3JpZ2luYWwuY29sdW1uO1xuICAgICAgbGFzdE9yaWdpbmFsTmFtZSA9IG9yaWdpbmFsLm5hbWU7XG4gICAgICBzb3VyY2VNYXBwaW5nQWN0aXZlID0gdHJ1ZTtcbiAgICB9IGVsc2UgaWYgKHNvdXJjZU1hcHBpbmdBY3RpdmUpIHtcbiAgICAgIG1hcC5hZGRNYXBwaW5nKHtcbiAgICAgICAgZ2VuZXJhdGVkOiB7XG4gICAgICAgICAgbGluZTogZ2VuZXJhdGVkLmxpbmUsXG4gICAgICAgICAgY29sdW1uOiBnZW5lcmF0ZWQuY29sdW1uXG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgbGFzdE9yaWdpbmFsU291cmNlID0gbnVsbDtcbiAgICAgIHNvdXJjZU1hcHBpbmdBY3RpdmUgPSBmYWxzZTtcbiAgICB9XG4gICAgZm9yICh2YXIgaWR4ID0gMCwgbGVuZ3RoID0gY2h1bmsubGVuZ3RoOyBpZHggPCBsZW5ndGg7IGlkeCsrKSB7XG4gICAgICBpZiAoY2h1bmsuY2hhckNvZGVBdChpZHgpID09PSBORVdMSU5FX0NPREUpIHtcbiAgICAgICAgZ2VuZXJhdGVkLmxpbmUrKztcbiAgICAgICAgZ2VuZXJhdGVkLmNvbHVtbiA9IDA7XG4gICAgICAgIC8vIE1hcHBpbmdzIGVuZCBhdCBlb2xcbiAgICAgICAgaWYgKGlkeCArIDEgPT09IGxlbmd0aCkge1xuICAgICAgICAgIGxhc3RPcmlnaW5hbFNvdXJjZSA9IG51bGw7XG4gICAgICAgICAgc291cmNlTWFwcGluZ0FjdGl2ZSA9IGZhbHNlO1xuICAgICAgICB9IGVsc2UgaWYgKHNvdXJjZU1hcHBpbmdBY3RpdmUpIHtcbiAgICAgICAgICBtYXAuYWRkTWFwcGluZyh7XG4gICAgICAgICAgICBzb3VyY2U6IG9yaWdpbmFsLnNvdXJjZSxcbiAgICAgICAgICAgIG9yaWdpbmFsOiB7XG4gICAgICAgICAgICAgIGxpbmU6IG9yaWdpbmFsLmxpbmUsXG4gICAgICAgICAgICAgIGNvbHVtbjogb3JpZ2luYWwuY29sdW1uXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZ2VuZXJhdGVkOiB7XG4gICAgICAgICAgICAgIGxpbmU6IGdlbmVyYXRlZC5saW5lLFxuICAgICAgICAgICAgICBjb2x1bW46IGdlbmVyYXRlZC5jb2x1bW5cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBuYW1lOiBvcmlnaW5hbC5uYW1lXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGdlbmVyYXRlZC5jb2x1bW4rKztcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xuICB0aGlzLndhbGtTb3VyY2VDb250ZW50cyhmdW5jdGlvbiAoc291cmNlRmlsZSwgc291cmNlQ29udGVudCkge1xuICAgIG1hcC5zZXRTb3VyY2VDb250ZW50KHNvdXJjZUZpbGUsIHNvdXJjZUNvbnRlbnQpO1xuICB9KTtcblxuICByZXR1cm4geyBjb2RlOiBnZW5lcmF0ZWQuY29kZSwgbWFwOiBtYXAgfTtcbn07XG5cbmV4cG9ydHMuU291cmNlTm9kZSA9IFNvdXJjZU5vZGU7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvZWxlY3Ryb24tdXBkYXRlci9ub2RlX21vZHVsZXMvc291cmNlLW1hcC9saWIvc291cmNlLW5vZGUuanMiLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCJtb2R1bGVcIik7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gZXh0ZXJuYWwgXCJtb2R1bGVcIlxuLy8gbW9kdWxlIGlkID0gMTY4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLkVsZWN0cm9uSHR0cEV4ZWN1dG9yID0gdW5kZWZpbmVkO1xuXG52YXIgX2JsdWViaXJkTHN0O1xuXG5mdW5jdGlvbiBfbG9hZF9ibHVlYmlyZExzdCgpIHtcbiAgICByZXR1cm4gX2JsdWViaXJkTHN0ID0gcmVxdWlyZShcImJsdWViaXJkLWxzdFwiKTtcbn1cblxudmFyIF9idWlsZGVyVXRpbFJ1bnRpbWU7XG5cbmZ1bmN0aW9uIF9sb2FkX2J1aWxkZXJVdGlsUnVudGltZSgpIHtcbiAgICByZXR1cm4gX2J1aWxkZXJVdGlsUnVudGltZSA9IHJlcXVpcmUoXCJidWlsZGVyLXV0aWwtcnVudGltZVwiKTtcbn1cblxudmFyIF9lbGVjdHJvbjtcblxuZnVuY3Rpb24gX2xvYWRfZWxlY3Ryb24oKSB7XG4gICAgcmV0dXJuIF9lbGVjdHJvbiA9IHJlcXVpcmUoXCJlbGVjdHJvblwiKTtcbn1cblxudmFyIF9mc0V4dHJhUDtcblxuZnVuY3Rpb24gX2xvYWRfZnNFeHRyYVAoKSB7XG4gICAgcmV0dXJuIF9mc0V4dHJhUCA9IHJlcXVpcmUoXCJmcy1leHRyYS1wXCIpO1xufVxuXG52YXIgX3BhdGggPSBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChyZXF1aXJlKFwicGF0aFwiKSk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKG9iaikgeyBpZiAob2JqICYmIG9iai5fX2VzTW9kdWxlKSB7IHJldHVybiBvYmo7IH0gZWxzZSB7IHZhciBuZXdPYmogPSB7fTsgaWYgKG9iaiAhPSBudWxsKSB7IGZvciAodmFyIGtleSBpbiBvYmopIHsgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGtleSkpIG5ld09ialtrZXldID0gb2JqW2tleV07IH0gfSBuZXdPYmouZGVmYXVsdCA9IG9iajsgcmV0dXJuIG5ld09iajsgfSB9XG5cbmNsYXNzIEVsZWN0cm9uSHR0cEV4ZWN1dG9yIGV4dGVuZHMgKF9idWlsZGVyVXRpbFJ1bnRpbWUgfHwgX2xvYWRfYnVpbGRlclV0aWxSdW50aW1lKCkpLkh0dHBFeGVjdXRvciB7XG4gICAgY29uc3RydWN0b3IocHJveHlMb2dpbkNhbGxiYWNrKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMucHJveHlMb2dpbkNhbGxiYWNrID0gcHJveHlMb2dpbkNhbGxiYWNrO1xuICAgIH1cbiAgICBkb3dubG9hZCh1cmwsIGRlc3RpbmF0aW9uLCBvcHRpb25zKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICAgICAgcmV0dXJuICgwLCAoX2JsdWViaXJkTHN0IHx8IF9sb2FkX2JsdWViaXJkTHN0KCkpLmNvcm91dGluZSkoZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGlmIChvcHRpb25zID09IG51bGwgfHwgIW9wdGlvbnMuc2tpcERpckNyZWF0aW9uKSB7XG4gICAgICAgICAgICAgICAgeWllbGQgKDAsIChfZnNFeHRyYVAgfHwgX2xvYWRfZnNFeHRyYVAoKSkuZW5zdXJlRGlyKShfcGF0aC5kaXJuYW1lKGRlc3RpbmF0aW9uKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4geWllbGQgb3B0aW9ucy5jYW5jZWxsYXRpb25Ub2tlbi5jcmVhdGVQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QsIG9uQ2FuY2VsKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMuZG9Eb3dubG9hZChPYmplY3QuYXNzaWduKHt9LCAoMCwgKF9idWlsZGVyVXRpbFJ1bnRpbWUgfHwgX2xvYWRfYnVpbGRlclV0aWxSdW50aW1lKCkpLmNvbmZpZ3VyZVJlcXVlc3RPcHRpb25zRnJvbVVybCkodXJsLCB7XG4gICAgICAgICAgICAgICAgICAgIGhlYWRlcnM6IG9wdGlvbnMuaGVhZGVycyB8fCB1bmRlZmluZWRcbiAgICAgICAgICAgICAgICB9KSwgeyByZWRpcmVjdDogXCJtYW51YWxcIiB9KSwgZGVzdGluYXRpb24sIDAsIG9wdGlvbnMsIGZ1bmN0aW9uIChlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZXJyb3IgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShkZXN0aW5hdGlvbik7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZWplY3QoZXJyb3IpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSwgb25DYW5jZWwpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pKCk7XG4gICAgfVxuICAgIGRvUmVxdWVzdChvcHRpb25zLCBjYWxsYmFjaykge1xuICAgICAgICBjb25zdCByZXF1ZXN0ID0gKF9lbGVjdHJvbiB8fCBfbG9hZF9lbGVjdHJvbigpKS5uZXQucmVxdWVzdChvcHRpb25zKTtcbiAgICAgICAgcmVxdWVzdC5vbihcInJlc3BvbnNlXCIsIGNhbGxiYWNrKTtcbiAgICAgICAgdGhpcy5hZGRQcm94eUxvZ2luSGFuZGxlcihyZXF1ZXN0KTtcbiAgICAgICAgcmV0dXJuIHJlcXVlc3Q7XG4gICAgfVxuICAgIGFkZFByb3h5TG9naW5IYW5kbGVyKHJlcXVlc3QpIHtcbiAgICAgICAgaWYgKHRoaXMucHJveHlMb2dpbkNhbGxiYWNrICE9IG51bGwpIHtcbiAgICAgICAgICAgIHJlcXVlc3Qub24oXCJsb2dpblwiLCB0aGlzLnByb3h5TG9naW5DYWxsYmFjayk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYWRkUmVkaXJlY3RIYW5kbGVycyhyZXF1ZXN0LCBvcHRpb25zLCByZWplY3QsIHJlZGlyZWN0Q291bnQsIGhhbmRsZXIpIHtcbiAgICAgICAgcmVxdWVzdC5vbihcInJlZGlyZWN0XCIsIChzdGF0dXNDb2RlLCBtZXRob2QsIHJlZGlyZWN0VXJsKSA9PiB7XG4gICAgICAgICAgICBpZiAocmVkaXJlY3RDb3VudCA+IDEwKSB7XG4gICAgICAgICAgICAgICAgcmVqZWN0KG5ldyBFcnJvcihcIlRvbyBtYW55IHJlZGlyZWN0cyAoPiAxMClcIikpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGhhbmRsZXIoKF9idWlsZGVyVXRpbFJ1bnRpbWUgfHwgX2xvYWRfYnVpbGRlclV0aWxSdW50aW1lKCkpLkh0dHBFeGVjdXRvci5wcmVwYXJlUmVkaXJlY3RVcmxPcHRpb25zKHJlZGlyZWN0VXJsLCBvcHRpb25zKSk7XG4gICAgICAgIH0pO1xuICAgIH1cbn1cbmV4cG9ydHMuRWxlY3Ryb25IdHRwRXhlY3V0b3IgPSBFbGVjdHJvbkh0dHBFeGVjdXRvcjsgLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZWxlY3Ryb25IdHRwRXhlY3V0b3IuanMubWFwXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2VsZWN0cm9uLXVwZGF0ZXIvb3V0L2VsZWN0cm9uSHR0cEV4ZWN1dG9yLmpzIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuY3JlYXRlQ2xpZW50ID0gY3JlYXRlQ2xpZW50O1xuXG52YXIgX2J1aWxkZXJVdGlsUnVudGltZTtcblxuZnVuY3Rpb24gX2xvYWRfYnVpbGRlclV0aWxSdW50aW1lKCkge1xuICAgIHJldHVybiBfYnVpbGRlclV0aWxSdW50aW1lID0gcmVxdWlyZShcImJ1aWxkZXItdXRpbC1ydW50aW1lXCIpO1xufVxuXG52YXIgX0JpbnRyYXlQcm92aWRlcjtcblxuZnVuY3Rpb24gX2xvYWRfQmludHJheVByb3ZpZGVyKCkge1xuICAgIHJldHVybiBfQmludHJheVByb3ZpZGVyID0gcmVxdWlyZShcIi4vQmludHJheVByb3ZpZGVyXCIpO1xufVxuXG52YXIgX0dlbmVyaWNQcm92aWRlcjtcblxuZnVuY3Rpb24gX2xvYWRfR2VuZXJpY1Byb3ZpZGVyKCkge1xuICAgIHJldHVybiBfR2VuZXJpY1Byb3ZpZGVyID0gcmVxdWlyZShcIi4vR2VuZXJpY1Byb3ZpZGVyXCIpO1xufVxuXG52YXIgX0dpdEh1YlByb3ZpZGVyO1xuXG5mdW5jdGlvbiBfbG9hZF9HaXRIdWJQcm92aWRlcigpIHtcbiAgICByZXR1cm4gX0dpdEh1YlByb3ZpZGVyID0gcmVxdWlyZShcIi4vR2l0SHViUHJvdmlkZXJcIik7XG59XG5cbnZhciBfUHJpdmF0ZUdpdEh1YlByb3ZpZGVyO1xuXG5mdW5jdGlvbiBfbG9hZF9Qcml2YXRlR2l0SHViUHJvdmlkZXIoKSB7XG4gICAgcmV0dXJuIF9Qcml2YXRlR2l0SHViUHJvdmlkZXIgPSByZXF1aXJlKFwiLi9Qcml2YXRlR2l0SHViUHJvdmlkZXJcIik7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUNsaWVudChkYXRhLCB1cGRhdGVyKSB7XG4gICAgaWYgKHR5cGVvZiBkYXRhID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIHRocm93ICgwLCAoX2J1aWxkZXJVdGlsUnVudGltZSB8fCBfbG9hZF9idWlsZGVyVXRpbFJ1bnRpbWUoKSkubmV3RXJyb3IpKFwiUGxlYXNlIHBhc3MgUHVibGlzaENvbmZpZ3VyYXRpb24gb2JqZWN0XCIsIFwiRVJSX1VQREFURVJfSU5WQUxJRF9QUk9WSURFUl9DT05GSUdVUkFUSU9OXCIpO1xuICAgIH1cbiAgICBjb25zdCBodHRwRXhlY3V0b3IgPSB1cGRhdGVyLmh0dHBFeGVjdXRvcjtcbiAgICBjb25zdCBwcm92aWRlciA9IGRhdGEucHJvdmlkZXI7XG4gICAgc3dpdGNoIChwcm92aWRlcikge1xuICAgICAgICBjYXNlIFwiZ2l0aHViXCI6XG4gICAgICAgICAgICBjb25zdCBnaXRodWJPcHRpb25zID0gZGF0YTtcbiAgICAgICAgICAgIGNvbnN0IHRva2VuID0gKGdpdGh1Yk9wdGlvbnMucHJpdmF0ZSA/IHByb2Nlc3MuZW52LkdIX1RPS0VOIDogbnVsbCkgfHwgZ2l0aHViT3B0aW9ucy50b2tlbjtcbiAgICAgICAgICAgIGlmICh0b2tlbiA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyAoX0dpdEh1YlByb3ZpZGVyIHx8IF9sb2FkX0dpdEh1YlByb3ZpZGVyKCkpLkdpdEh1YlByb3ZpZGVyKGdpdGh1Yk9wdGlvbnMsIHVwZGF0ZXIsIGh0dHBFeGVjdXRvcik7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgKF9Qcml2YXRlR2l0SHViUHJvdmlkZXIgfHwgX2xvYWRfUHJpdmF0ZUdpdEh1YlByb3ZpZGVyKCkpLlByaXZhdGVHaXRIdWJQcm92aWRlcihnaXRodWJPcHRpb25zLCB0b2tlbiwgaHR0cEV4ZWN1dG9yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgY2FzZSBcInMzXCI6XG4gICAgICAgIGNhc2UgXCJzcGFjZXNcIjpcbiAgICAgICAgICAgIHJldHVybiBuZXcgKF9HZW5lcmljUHJvdmlkZXIgfHwgX2xvYWRfR2VuZXJpY1Byb3ZpZGVyKCkpLkdlbmVyaWNQcm92aWRlcih7XG4gICAgICAgICAgICAgICAgcHJvdmlkZXI6IFwiZ2VuZXJpY1wiLFxuICAgICAgICAgICAgICAgIHVybDogKDAsIChfYnVpbGRlclV0aWxSdW50aW1lIHx8IF9sb2FkX2J1aWxkZXJVdGlsUnVudGltZSgpKS5nZXRTM0xpa2VQcm92aWRlckJhc2VVcmwpKGRhdGEpLFxuICAgICAgICAgICAgICAgIGNoYW5uZWw6IGRhdGEuY2hhbm5lbCB8fCBudWxsXG4gICAgICAgICAgICB9LCB1cGRhdGVyLCBwcm92aWRlciA9PT0gXCJzcGFjZXNcIiAvKiBodHRwczovL2dpdGh1Yi5jb20vbWluaW8vbWluaW8vaXNzdWVzLzUyODUjaXNzdWVjb21tZW50LTM1MDQyODk1NSAqLyk7XG4gICAgICAgIGNhc2UgXCJnZW5lcmljXCI6XG4gICAgICAgICAgICByZXR1cm4gbmV3IChfR2VuZXJpY1Byb3ZpZGVyIHx8IF9sb2FkX0dlbmVyaWNQcm92aWRlcigpKS5HZW5lcmljUHJvdmlkZXIoZGF0YSwgdXBkYXRlciwgdHJ1ZSk7XG4gICAgICAgIGNhc2UgXCJiaW50cmF5XCI6XG4gICAgICAgICAgICByZXR1cm4gbmV3IChfQmludHJheVByb3ZpZGVyIHx8IF9sb2FkX0JpbnRyYXlQcm92aWRlcigpKS5CaW50cmF5UHJvdmlkZXIoZGF0YSwgaHR0cEV4ZWN1dG9yKTtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHRocm93ICgwLCAoX2J1aWxkZXJVdGlsUnVudGltZSB8fCBfbG9hZF9idWlsZGVyVXRpbFJ1bnRpbWUoKSkubmV3RXJyb3IpKGBVbnN1cHBvcnRlZCBwcm92aWRlcjogJHtwcm92aWRlcn1gLCBcIkVSUl9VUERBVEVSX1VOU1VQUE9SVEVEX1BST1ZJREVSXCIpO1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXByb3ZpZGVyRmFjdG9yeS5qcy5tYXBcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvZWxlY3Ryb24tdXBkYXRlci9vdXQvcHJvdmlkZXJGYWN0b3J5LmpzIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuQmludHJheVByb3ZpZGVyID0gdW5kZWZpbmVkO1xuXG52YXIgX2JsdWViaXJkTHN0O1xuXG5mdW5jdGlvbiBfbG9hZF9ibHVlYmlyZExzdCgpIHtcbiAgICByZXR1cm4gX2JsdWViaXJkTHN0ID0gcmVxdWlyZShcImJsdWViaXJkLWxzdFwiKTtcbn1cblxudmFyIF9idWlsZGVyVXRpbFJ1bnRpbWU7XG5cbmZ1bmN0aW9uIF9sb2FkX2J1aWxkZXJVdGlsUnVudGltZSgpIHtcbiAgICByZXR1cm4gX2J1aWxkZXJVdGlsUnVudGltZSA9IHJlcXVpcmUoXCJidWlsZGVyLXV0aWwtcnVudGltZVwiKTtcbn1cblxudmFyIF9iaW50cmF5O1xuXG5mdW5jdGlvbiBfbG9hZF9iaW50cmF5KCkge1xuICAgIHJldHVybiBfYmludHJheSA9IHJlcXVpcmUoXCJidWlsZGVyLXV0aWwtcnVudGltZS9vdXQvYmludHJheVwiKTtcbn1cblxudmFyIF91cmw7XG5cbmZ1bmN0aW9uIF9sb2FkX3VybCgpIHtcbiAgICByZXR1cm4gX3VybCA9IHJlcXVpcmUoXCJ1cmxcIik7XG59XG5cbnZhciBfbWFpbjtcblxuZnVuY3Rpb24gX2xvYWRfbWFpbigpIHtcbiAgICByZXR1cm4gX21haW4gPSByZXF1aXJlKFwiLi9tYWluXCIpO1xufVxuXG52YXIgX1Byb3ZpZGVyO1xuXG5mdW5jdGlvbiBfbG9hZF9Qcm92aWRlcigpIHtcbiAgICByZXR1cm4gX1Byb3ZpZGVyID0gcmVxdWlyZShcIi4vUHJvdmlkZXJcIik7XG59XG5cbmNsYXNzIEJpbnRyYXlQcm92aWRlciBleHRlbmRzIChfbWFpbiB8fCBfbG9hZF9tYWluKCkpLlByb3ZpZGVyIHtcbiAgICBjb25zdHJ1Y3Rvcihjb25maWd1cmF0aW9uLCBodHRwRXhlY3V0b3IpIHtcbiAgICAgICAgc3VwZXIoaHR0cEV4ZWN1dG9yKTtcbiAgICAgICAgdGhpcy5jbGllbnQgPSBuZXcgKF9iaW50cmF5IHx8IF9sb2FkX2JpbnRyYXkoKSkuQmludHJheUNsaWVudChjb25maWd1cmF0aW9uLCBodHRwRXhlY3V0b3IsIG5ldyAoX2J1aWxkZXJVdGlsUnVudGltZSB8fCBfbG9hZF9idWlsZGVyVXRpbFJ1bnRpbWUoKSkuQ2FuY2VsbGF0aW9uVG9rZW4oKSk7XG4gICAgICAgIHRoaXMuYmFzZVVybCA9ICgwLCAoX21haW4gfHwgX2xvYWRfbWFpbigpKS5uZXdCYXNlVXJsKShgaHR0cHM6Ly9kbC5iaW50cmF5LmNvbS8ke3RoaXMuY2xpZW50Lm93bmVyfS8ke3RoaXMuY2xpZW50LnJlcG99YCk7XG4gICAgfVxuICAgIHNldFJlcXVlc3RIZWFkZXJzKHZhbHVlKSB7XG4gICAgICAgIHN1cGVyLnNldFJlcXVlc3RIZWFkZXJzKHZhbHVlKTtcbiAgICAgICAgdGhpcy5jbGllbnQuc2V0UmVxdWVzdEhlYWRlcnModmFsdWUpO1xuICAgIH1cbiAgICBnZXRMYXRlc3RWZXJzaW9uKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgICAgIHJldHVybiAoMCwgKF9ibHVlYmlyZExzdCB8fCBfbG9hZF9ibHVlYmlyZExzdCgpKS5jb3JvdXRpbmUpKGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGRhdGEgPSB5aWVsZCBfdGhpcy5jbGllbnQuZ2V0VmVyc2lvbihcIl9sYXRlc3RcIik7XG4gICAgICAgICAgICAgICAgY29uc3QgY2hhbm5lbEZpbGVuYW1lID0gKDAsIChfbWFpbiB8fCBfbG9hZF9tYWluKCkpLmdldENoYW5uZWxGaWxlbmFtZSkoKDAsIChfbWFpbiB8fCBfbG9hZF9tYWluKCkpLmdldERlZmF1bHRDaGFubmVsTmFtZSkoKSk7XG4gICAgICAgICAgICAgICAgY29uc3QgZmlsZXMgPSB5aWVsZCBfdGhpcy5jbGllbnQuZ2V0VmVyc2lvbkZpbGVzKGRhdGEubmFtZSk7XG4gICAgICAgICAgICAgICAgY29uc3QgY2hhbm5lbEZpbGUgPSBmaWxlcy5maW5kKGZ1bmN0aW9uIChpdCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaXQubmFtZS5lbmRzV2l0aChgXyR7Y2hhbm5lbEZpbGVuYW1lfWApIHx8IGl0Lm5hbWUuZW5kc1dpdGgoYC0ke2NoYW5uZWxGaWxlbmFtZX1gKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBpZiAoY2hhbm5lbEZpbGUgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBub2luc3BlY3Rpb24gRXhjZXB0aW9uQ2F1Z2h0TG9jYWxseUpTXG4gICAgICAgICAgICAgICAgICAgIHRocm93ICgwLCAoX2J1aWxkZXJVdGlsUnVudGltZSB8fCBfbG9hZF9idWlsZGVyVXRpbFJ1bnRpbWUoKSkubmV3RXJyb3IpKGBDYW5ub3QgZmluZCBjaGFubmVsIGZpbGUgXCIke2NoYW5uZWxGaWxlbmFtZX1cIiwgZXhpc3RpbmcgZmlsZXM6XFxuJHtmaWxlcy5tYXAoZnVuY3Rpb24gKGl0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkoaXQsIG51bGwsIDIpO1xuICAgICAgICAgICAgICAgICAgICB9KS5qb2luKFwiLFxcblwiKX1gLCBcIkVSUl9VUERBVEVSX0NIQU5ORUxfRklMRV9OT1RfRk9VTkRcIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IGNoYW5uZWxGaWxlVXJsID0gbmV3IChfdXJsIHx8IF9sb2FkX3VybCgpKS5VUkwoYGh0dHBzOi8vZGwuYmludHJheS5jb20vJHtfdGhpcy5jbGllbnQub3duZXJ9LyR7X3RoaXMuY2xpZW50LnJlcG99LyR7Y2hhbm5lbEZpbGUubmFtZX1gKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gKDAsIChfUHJvdmlkZXIgfHwgX2xvYWRfUHJvdmlkZXIoKSkucGFyc2VVcGRhdGVJbmZvKSgoeWllbGQgX3RoaXMuaHR0cFJlcXVlc3QoY2hhbm5lbEZpbGVVcmwpKSwgY2hhbm5lbEZpbGVuYW1lLCBjaGFubmVsRmlsZVVybCk7XG4gICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgaWYgKFwic3RhdHVzQ29kZVwiIGluIGUgJiYgZS5zdGF0dXNDb2RlID09PSA0MDQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgKDAsIChfYnVpbGRlclV0aWxSdW50aW1lIHx8IF9sb2FkX2J1aWxkZXJVdGlsUnVudGltZSgpKS5uZXdFcnJvcikoYE5vIGxhdGVzdCB2ZXJzaW9uLCBwbGVhc2UgZW5zdXJlIHRoYXQgdXNlciwgcGFja2FnZSBhbmQgcmVwb3NpdG9yeSBjb3JyZWN0bHkgY29uZmlndXJlZC4gT3IgYXQgbGVhc3Qgb25lIHZlcnNpb24gaXMgcHVibGlzaGVkLiAke2Uuc3RhY2sgfHwgZS5tZXNzYWdlfWAsIFwiRVJSX1VQREFURVJfTEFURVNUX1ZFUlNJT05fTk9UX0ZPVU5EXCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KSgpO1xuICAgIH1cbiAgICByZXNvbHZlRmlsZXModXBkYXRlSW5mbykge1xuICAgICAgICByZXR1cm4gKDAsIChfUHJvdmlkZXIgfHwgX2xvYWRfUHJvdmlkZXIoKSkucmVzb2x2ZUZpbGVzKSh1cGRhdGVJbmZvLCB0aGlzLmJhc2VVcmwpO1xuICAgIH1cbn1cbmV4cG9ydHMuQmludHJheVByb3ZpZGVyID0gQmludHJheVByb3ZpZGVyOyAvLyMgc291cmNlTWFwcGluZ1VSTD1CaW50cmF5UHJvdmlkZXIuanMubWFwXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2VsZWN0cm9uLXVwZGF0ZXIvb3V0L0JpbnRyYXlQcm92aWRlci5qcyIsIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLkJpbnRyYXlDbGllbnQgPSB1bmRlZmluZWQ7XG5cbnZhciBfaHR0cEV4ZWN1dG9yO1xuXG5mdW5jdGlvbiBfbG9hZF9odHRwRXhlY3V0b3IoKSB7XG4gICAgcmV0dXJuIF9odHRwRXhlY3V0b3IgPSByZXF1aXJlKFwiLi9odHRwRXhlY3V0b3JcIik7XG59XG5cbmNsYXNzIEJpbnRyYXlDbGllbnQge1xuICAgIGNvbnN0cnVjdG9yKG9wdGlvbnMsIGh0dHBFeGVjdXRvciwgY2FuY2VsbGF0aW9uVG9rZW4sIGFwaUtleSkge1xuICAgICAgICB0aGlzLmh0dHBFeGVjdXRvciA9IGh0dHBFeGVjdXRvcjtcbiAgICAgICAgdGhpcy5jYW5jZWxsYXRpb25Ub2tlbiA9IGNhbmNlbGxhdGlvblRva2VuO1xuICAgICAgICBpZiAob3B0aW9ucy5vd25lciA9PSBudWxsKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJvd25lciBpcyBub3Qgc3BlY2lmaWVkXCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvcHRpb25zLnBhY2thZ2UgPT0gbnVsbCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwicGFja2FnZSBpcyBub3Qgc3BlY2lmaWVkXCIpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucmVwbyA9IG9wdGlvbnMucmVwbyB8fCBcImdlbmVyaWNcIjtcbiAgICAgICAgdGhpcy5wYWNrYWdlTmFtZSA9IG9wdGlvbnMucGFja2FnZTtcbiAgICAgICAgdGhpcy5vd25lciA9IG9wdGlvbnMub3duZXI7XG4gICAgICAgIHRoaXMudXNlciA9IG9wdGlvbnMudXNlciB8fCBvcHRpb25zLm93bmVyO1xuICAgICAgICB0aGlzLmNvbXBvbmVudCA9IG9wdGlvbnMuY29tcG9uZW50IHx8IG51bGw7XG4gICAgICAgIHRoaXMuZGlzdHJpYnV0aW9uID0gb3B0aW9ucy5kaXN0cmlidXRpb24gfHwgXCJzdGFibGVcIjtcbiAgICAgICAgdGhpcy5hdXRoID0gYXBpS2V5ID09IG51bGwgPyBudWxsIDogYEJhc2ljICR7QnVmZmVyLmZyb20oYCR7dGhpcy51c2VyfToke2FwaUtleX1gKS50b1N0cmluZyhcImJhc2U2NFwiKX1gO1xuICAgICAgICB0aGlzLmJhc2VQYXRoID0gYC9wYWNrYWdlcy8ke3RoaXMub3duZXJ9LyR7dGhpcy5yZXBvfS8ke3RoaXMucGFja2FnZU5hbWV9YDtcbiAgICB9XG4gICAgc2V0UmVxdWVzdEhlYWRlcnModmFsdWUpIHtcbiAgICAgICAgdGhpcy5yZXF1ZXN0SGVhZGVycyA9IHZhbHVlO1xuICAgIH1cbiAgICBiaW50cmF5UmVxdWVzdChwYXRoLCBhdXRoLCBkYXRhID0gbnVsbCwgY2FuY2VsbGF0aW9uVG9rZW4sIG1ldGhvZCkge1xuICAgICAgICByZXR1cm4gKDAsIChfaHR0cEV4ZWN1dG9yIHx8IF9sb2FkX2h0dHBFeGVjdXRvcigpKS5wYXJzZUpzb24pKHRoaXMuaHR0cEV4ZWN1dG9yLnJlcXVlc3QoKDAsIChfaHR0cEV4ZWN1dG9yIHx8IF9sb2FkX2h0dHBFeGVjdXRvcigpKS5jb25maWd1cmVSZXF1ZXN0T3B0aW9ucykoeyBob3N0bmFtZTogXCJhcGkuYmludHJheS5jb21cIiwgcGF0aCwgaGVhZGVyczogdGhpcy5yZXF1ZXN0SGVhZGVycyB8fCB1bmRlZmluZWQgfSwgYXV0aCwgbWV0aG9kKSwgY2FuY2VsbGF0aW9uVG9rZW4sIGRhdGEpKTtcbiAgICB9XG4gICAgZ2V0VmVyc2lvbih2ZXJzaW9uKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmJpbnRyYXlSZXF1ZXN0KGAke3RoaXMuYmFzZVBhdGh9L3ZlcnNpb25zLyR7dmVyc2lvbn1gLCB0aGlzLmF1dGgsIG51bGwsIHRoaXMuY2FuY2VsbGF0aW9uVG9rZW4pO1xuICAgIH1cbiAgICBnZXRWZXJzaW9uRmlsZXModmVyc2lvbikge1xuICAgICAgICByZXR1cm4gdGhpcy5iaW50cmF5UmVxdWVzdChgJHt0aGlzLmJhc2VQYXRofS92ZXJzaW9ucy8ke3ZlcnNpb259L2ZpbGVzYCwgdGhpcy5hdXRoLCBudWxsLCB0aGlzLmNhbmNlbGxhdGlvblRva2VuKTtcbiAgICB9XG4gICAgY3JlYXRlVmVyc2lvbih2ZXJzaW9uKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmJpbnRyYXlSZXF1ZXN0KGAke3RoaXMuYmFzZVBhdGh9L3ZlcnNpb25zYCwgdGhpcy5hdXRoLCB7XG4gICAgICAgICAgICBuYW1lOiB2ZXJzaW9uXG4gICAgICAgIH0sIHRoaXMuY2FuY2VsbGF0aW9uVG9rZW4pO1xuICAgIH1cbiAgICBkZWxldGVWZXJzaW9uKHZlcnNpb24pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYmludHJheVJlcXVlc3QoYCR7dGhpcy5iYXNlUGF0aH0vdmVyc2lvbnMvJHt2ZXJzaW9ufWAsIHRoaXMuYXV0aCwgbnVsbCwgdGhpcy5jYW5jZWxsYXRpb25Ub2tlbiwgXCJERUxFVEVcIik7XG4gICAgfVxufVxuZXhwb3J0cy5CaW50cmF5Q2xpZW50ID0gQmludHJheUNsaWVudDsgLy8jIHNvdXJjZU1hcHBpbmdVUkw9YmludHJheS5qcy5tYXBcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvZWxlY3Ryb24tdXBkYXRlci9ub2RlX21vZHVsZXMvYnVpbGRlci11dGlsLXJ1bnRpbWUvb3V0L2JpbnRyYXkuanMiLCJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5Qcml2YXRlR2l0SHViUHJvdmlkZXIgPSB1bmRlZmluZWQ7XG5cbnZhciBfYmx1ZWJpcmRMc3Q7XG5cbmZ1bmN0aW9uIF9sb2FkX2JsdWViaXJkTHN0KCkge1xuICAgIHJldHVybiBfYmx1ZWJpcmRMc3QgPSByZXF1aXJlKFwiYmx1ZWJpcmQtbHN0XCIpO1xufVxuXG52YXIgX2J1aWxkZXJVdGlsUnVudGltZTtcblxuZnVuY3Rpb24gX2xvYWRfYnVpbGRlclV0aWxSdW50aW1lKCkge1xuICAgIHJldHVybiBfYnVpbGRlclV0aWxSdW50aW1lID0gcmVxdWlyZShcImJ1aWxkZXItdXRpbC1ydW50aW1lXCIpO1xufVxuXG52YXIgX2pzWWFtbDtcblxuZnVuY3Rpb24gX2xvYWRfanNZYW1sKCkge1xuICAgIHJldHVybiBfanNZYW1sID0gcmVxdWlyZShcImpzLXlhbWxcIik7XG59XG5cbnZhciBfcGF0aCA9IF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKHJlcXVpcmUoXCJwYXRoXCIpKTtcblxudmFyIF91cmw7XG5cbmZ1bmN0aW9uIF9sb2FkX3VybCgpIHtcbiAgICByZXR1cm4gX3VybCA9IHJlcXVpcmUoXCJ1cmxcIik7XG59XG5cbnZhciBfR2l0SHViUHJvdmlkZXI7XG5cbmZ1bmN0aW9uIF9sb2FkX0dpdEh1YlByb3ZpZGVyKCkge1xuICAgIHJldHVybiBfR2l0SHViUHJvdmlkZXIgPSByZXF1aXJlKFwiLi9HaXRIdWJQcm92aWRlclwiKTtcbn1cblxudmFyIF9tYWluO1xuXG5mdW5jdGlvbiBfbG9hZF9tYWluKCkge1xuICAgIHJldHVybiBfbWFpbiA9IHJlcXVpcmUoXCIuL21haW5cIik7XG59XG5cbnZhciBfUHJvdmlkZXI7XG5cbmZ1bmN0aW9uIF9sb2FkX1Byb3ZpZGVyKCkge1xuICAgIHJldHVybiBfUHJvdmlkZXIgPSByZXF1aXJlKFwiLi9Qcm92aWRlclwiKTtcbn1cblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQob2JqKSB7IGlmIChvYmogJiYgb2JqLl9fZXNNb2R1bGUpIHsgcmV0dXJuIG9iajsgfSBlbHNlIHsgdmFyIG5ld09iaiA9IHt9OyBpZiAob2JqICE9IG51bGwpIHsgZm9yICh2YXIga2V5IGluIG9iaikgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwga2V5KSkgbmV3T2JqW2tleV0gPSBvYmpba2V5XTsgfSB9IG5ld09iai5kZWZhdWx0ID0gb2JqOyByZXR1cm4gbmV3T2JqOyB9IH1cblxuY2xhc3MgUHJpdmF0ZUdpdEh1YlByb3ZpZGVyIGV4dGVuZHMgKF9HaXRIdWJQcm92aWRlciB8fCBfbG9hZF9HaXRIdWJQcm92aWRlcigpKS5CYXNlR2l0SHViUHJvdmlkZXIge1xuICAgIGNvbnN0cnVjdG9yKG9wdGlvbnMsIHRva2VuLCBleGVjdXRvcikge1xuICAgICAgICBzdXBlcihvcHRpb25zLCBcImFwaS5naXRodWIuY29tXCIsIGV4ZWN1dG9yKTtcbiAgICAgICAgdGhpcy50b2tlbiA9IHRva2VuO1xuICAgIH1cbiAgICBjcmVhdGVSZXF1ZXN0T3B0aW9ucyh1cmwsIGhlYWRlcnMpIHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gc3VwZXIuY3JlYXRlUmVxdWVzdE9wdGlvbnModXJsLCBoZWFkZXJzKTtcbiAgICAgICAgcmVzdWx0LnJlZGlyZWN0ID0gXCJtYW51YWxcIjtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgZ2V0TGF0ZXN0VmVyc2lvbigpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgICAgICByZXR1cm4gKDAsIChfYmx1ZWJpcmRMc3QgfHwgX2xvYWRfYmx1ZWJpcmRMc3QoKSkuY29yb3V0aW5lKShmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3QgYmFzZVBhdGggPSBfdGhpcy5iYXNlUGF0aDtcbiAgICAgICAgICAgIGNvbnN0IGNhbmNlbGxhdGlvblRva2VuID0gbmV3IChfYnVpbGRlclV0aWxSdW50aW1lIHx8IF9sb2FkX2J1aWxkZXJVdGlsUnVudGltZSgpKS5DYW5jZWxsYXRpb25Ub2tlbigpO1xuICAgICAgICAgICAgY29uc3QgY2hhbm5lbEZpbGUgPSAoMCwgKF9tYWluIHx8IF9sb2FkX21haW4oKSkuZ2V0Q2hhbm5lbEZpbGVuYW1lKSgoMCwgKF9tYWluIHx8IF9sb2FkX21haW4oKSkuZ2V0RGVmYXVsdENoYW5uZWxOYW1lKSgpKTtcbiAgICAgICAgICAgIGNvbnN0IHJlbGVhc2VJbmZvID0geWllbGQgX3RoaXMuZ2V0TGF0ZXN0VmVyc2lvbkluZm8oYmFzZVBhdGgsIGNhbmNlbGxhdGlvblRva2VuKTtcbiAgICAgICAgICAgIGNvbnN0IGFzc2V0ID0gcmVsZWFzZUluZm8uYXNzZXRzLmZpbmQoZnVuY3Rpb24gKGl0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGl0Lm5hbWUgPT09IGNoYW5uZWxGaWxlO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpZiAoYXNzZXQgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIC8vIGh0bWxfdXJsIG11c3QgYmUgYWx3YXlzLCBidXQganVzdCB0byBiZSBzdXJlXG4gICAgICAgICAgICAgICAgdGhyb3cgKDAsIChfYnVpbGRlclV0aWxSdW50aW1lIHx8IF9sb2FkX2J1aWxkZXJVdGlsUnVudGltZSgpKS5uZXdFcnJvcikoYENhbm5vdCBmaW5kICR7Y2hhbm5lbEZpbGV9IGluIHRoZSByZWxlYXNlICR7cmVsZWFzZUluZm8uaHRtbF91cmwgfHwgcmVsZWFzZUluZm8ubmFtZX1gLCBcIkVSUl9VUERBVEVSX0NIQU5ORUxfRklMRV9OT1RfRk9VTkRcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCB1cmwgPSBuZXcgKF91cmwgfHwgX2xvYWRfdXJsKCkpLlVSTChhc3NldC51cmwpO1xuICAgICAgICAgICAgbGV0IHJlc3VsdDtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gKDAsIChfanNZYW1sIHx8IF9sb2FkX2pzWWFtbCgpKS5zYWZlTG9hZCkoKHlpZWxkIF90aGlzLmh0dHBSZXF1ZXN0KHVybCwgX3RoaXMuY29uZmlndXJlSGVhZGVycyhcImFwcGxpY2F0aW9uL29jdGV0LXN0cmVhbVwiKSwgY2FuY2VsbGF0aW9uVG9rZW4pKSk7XG4gICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgaWYgKGUgaW5zdGFuY2VvZiAoX2J1aWxkZXJVdGlsUnVudGltZSB8fCBfbG9hZF9idWlsZGVyVXRpbFJ1bnRpbWUoKSkuSHR0cEVycm9yICYmIGUuc3RhdHVzQ29kZSA9PT0gNDA0KSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93ICgwLCAoX2J1aWxkZXJVdGlsUnVudGltZSB8fCBfbG9hZF9idWlsZGVyVXRpbFJ1bnRpbWUoKSkubmV3RXJyb3IpKGBDYW5ub3QgZmluZCAke2NoYW5uZWxGaWxlfSBpbiB0aGUgbGF0ZXN0IHJlbGVhc2UgYXJ0aWZhY3RzICgke3VybH0pOiAke2Uuc3RhY2sgfHwgZS5tZXNzYWdlfWAsIFwiRVJSX1VQREFURVJfQ0hBTk5FTF9GSUxFX05PVF9GT1VORFwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlc3VsdC5hc3NldHMgPSByZWxlYXNlSW5mby5hc3NldHM7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9KSgpO1xuICAgIH1cbiAgICBnZXQgZmlsZUV4dHJhRG93bmxvYWRIZWFkZXJzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jb25maWd1cmVIZWFkZXJzKFwiYXBwbGljYXRpb24vb2N0ZXQtc3RyZWFtXCIpO1xuICAgIH1cbiAgICBjb25maWd1cmVIZWFkZXJzKGFjY2VwdCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgQWNjZXB0OiBhY2NlcHQsXG4gICAgICAgICAgICBBdXRob3JpemF0aW9uOiBgdG9rZW4gJHt0aGlzLnRva2VufWBcbiAgICAgICAgfTtcbiAgICB9XG4gICAgZ2V0TGF0ZXN0VmVyc2lvbkluZm8oYmFzZVBhdGgsIGNhbmNlbGxhdGlvblRva2VuKSB7XG4gICAgICAgIHZhciBfdGhpczIgPSB0aGlzO1xuXG4gICAgICAgIHJldHVybiAoMCwgKF9ibHVlYmlyZExzdCB8fCBfbG9hZF9ibHVlYmlyZExzdCgpKS5jb3JvdXRpbmUpKGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCB1cmwgPSAoMCwgKF9tYWluIHx8IF9sb2FkX21haW4oKSkubmV3VXJsRnJvbUJhc2UpKGAke2Jhc2VQYXRofS9sYXRlc3RgLCBfdGhpczIuYmFzZVVybCk7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHJldHVybiBKU09OLnBhcnNlKCh5aWVsZCBfdGhpczIuaHR0cFJlcXVlc3QodXJsLCBfdGhpczIuY29uZmlndXJlSGVhZGVycyhcImFwcGxpY2F0aW9uL3ZuZC5naXRodWIudjMranNvblwiKSwgY2FuY2VsbGF0aW9uVG9rZW4pKSk7XG4gICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgKDAsIChfYnVpbGRlclV0aWxSdW50aW1lIHx8IF9sb2FkX2J1aWxkZXJVdGlsUnVudGltZSgpKS5uZXdFcnJvcikoYFVuYWJsZSB0byBmaW5kIGxhdGVzdCB2ZXJzaW9uIG9uIEdpdEh1YiAoJHt1cmx9KSwgcGxlYXNlIGVuc3VyZSBhIHByb2R1Y3Rpb24gcmVsZWFzZSBleGlzdHM6ICR7ZS5zdGFjayB8fCBlLm1lc3NhZ2V9YCwgXCJFUlJfVVBEQVRFUl9MQVRFU1RfVkVSU0lPTl9OT1RfRk9VTkRcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pKCk7XG4gICAgfVxuICAgIGdldCBiYXNlUGF0aCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29tcHV0ZUdpdGh1YkJhc2VQYXRoKGAvcmVwb3MvJHt0aGlzLm9wdGlvbnMub3duZXJ9LyR7dGhpcy5vcHRpb25zLnJlcG99L3JlbGVhc2VzYCk7XG4gICAgfVxuICAgIHJlc29sdmVGaWxlcyh1cGRhdGVJbmZvKSB7XG4gICAgICAgIHJldHVybiAoMCwgKF9Qcm92aWRlciB8fCBfbG9hZF9Qcm92aWRlcigpKS5nZXRGaWxlTGlzdCkodXBkYXRlSW5mbykubWFwKGl0ID0+IHtcbiAgICAgICAgICAgIGNvbnN0IG5hbWUgPSBfcGF0aC5wb3NpeC5iYXNlbmFtZShpdC51cmwpLnJlcGxhY2UoLyAvZywgXCItXCIpO1xuICAgICAgICAgICAgY29uc3QgYXNzZXQgPSB1cGRhdGVJbmZvLmFzc2V0cy5maW5kKGl0ID0+IGl0ICE9IG51bGwgJiYgaXQubmFtZSA9PT0gbmFtZSk7XG4gICAgICAgICAgICBpZiAoYXNzZXQgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRocm93ICgwLCAoX2J1aWxkZXJVdGlsUnVudGltZSB8fCBfbG9hZF9idWlsZGVyVXRpbFJ1bnRpbWUoKSkubmV3RXJyb3IpKGBDYW5ub3QgZmluZCBhc3NldCBcIiR7bmFtZX1cIiBpbjogJHtKU09OLnN0cmluZ2lmeSh1cGRhdGVJbmZvLmFzc2V0cywgbnVsbCwgMil9YCwgXCJFUlJfVVBEQVRFUl9BU1NFVF9OT1RfRk9VTkRcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHVybDogbmV3IChfdXJsIHx8IF9sb2FkX3VybCgpKS5VUkwoYXNzZXQudXJsKSxcbiAgICAgICAgICAgICAgICBpbmZvOiBpdFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSk7XG4gICAgfVxufVxuZXhwb3J0cy5Qcml2YXRlR2l0SHViUHJvdmlkZXIgPSBQcml2YXRlR2l0SHViUHJvdmlkZXI7IC8vIyBzb3VyY2VNYXBwaW5nVVJMPVByaXZhdGVHaXRIdWJQcm92aWRlci5qcy5tYXBcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvZWxlY3Ryb24tdXBkYXRlci9vdXQvUHJpdmF0ZUdpdEh1YlByb3ZpZGVyLmpzIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuTnNpc1VwZGF0ZXIgPSB1bmRlZmluZWQ7XG5cbnZhciBfYmx1ZWJpcmRMc3Q7XG5cbmZ1bmN0aW9uIF9sb2FkX2JsdWViaXJkTHN0KCkge1xuICAgIHJldHVybiBfYmx1ZWJpcmRMc3QgPSByZXF1aXJlKFwiYmx1ZWJpcmQtbHN0XCIpO1xufVxuXG52YXIgX2J1aWxkZXJVdGlsUnVudGltZTtcblxuZnVuY3Rpb24gX2xvYWRfYnVpbGRlclV0aWxSdW50aW1lKCkge1xuICAgIHJldHVybiBfYnVpbGRlclV0aWxSdW50aW1lID0gcmVxdWlyZShcImJ1aWxkZXItdXRpbC1ydW50aW1lXCIpO1xufVxuXG52YXIgX2NoaWxkX3Byb2Nlc3M7XG5cbmZ1bmN0aW9uIF9sb2FkX2NoaWxkX3Byb2Nlc3MoKSB7XG4gICAgcmV0dXJuIF9jaGlsZF9wcm9jZXNzID0gcmVxdWlyZShcImNoaWxkX3Byb2Nlc3NcIik7XG59XG5cbnZhciBfcGF0aCA9IF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKHJlcXVpcmUoXCJwYXRoXCIpKTtcblxucmVxdWlyZShcInNvdXJjZS1tYXAtc3VwcG9ydC9yZWdpc3RlclwiKTtcblxudmFyIF9CYXNlVXBkYXRlcjtcblxuZnVuY3Rpb24gX2xvYWRfQmFzZVVwZGF0ZXIoKSB7XG4gICAgcmV0dXJuIF9CYXNlVXBkYXRlciA9IHJlcXVpcmUoXCIuL0Jhc2VVcGRhdGVyXCIpO1xufVxuXG52YXIgX0ZpbGVXaXRoRW1iZWRkZWRCbG9ja01hcERpZmZlcmVudGlhbERvd25sb2FkZXI7XG5cbmZ1bmN0aW9uIF9sb2FkX0ZpbGVXaXRoRW1iZWRkZWRCbG9ja01hcERpZmZlcmVudGlhbERvd25sb2FkZXIoKSB7XG4gICAgcmV0dXJuIF9GaWxlV2l0aEVtYmVkZGVkQmxvY2tNYXBEaWZmZXJlbnRpYWxEb3dubG9hZGVyID0gcmVxdWlyZShcIi4vZGlmZmVyZW50aWFsRG93bmxvYWRlci9GaWxlV2l0aEVtYmVkZGVkQmxvY2tNYXBEaWZmZXJlbnRpYWxEb3dubG9hZGVyXCIpO1xufVxuXG52YXIgX0dlbmVyaWNEaWZmZXJlbnRpYWxEb3dubG9hZGVyO1xuXG5mdW5jdGlvbiBfbG9hZF9HZW5lcmljRGlmZmVyZW50aWFsRG93bmxvYWRlcigpIHtcbiAgICByZXR1cm4gX0dlbmVyaWNEaWZmZXJlbnRpYWxEb3dubG9hZGVyID0gcmVxdWlyZShcIi4vZGlmZmVyZW50aWFsRG93bmxvYWRlci9HZW5lcmljRGlmZmVyZW50aWFsRG93bmxvYWRlclwiKTtcbn1cblxudmFyIF9tYWluO1xuXG5mdW5jdGlvbiBfbG9hZF9tYWluKCkge1xuICAgIHJldHVybiBfbWFpbiA9IHJlcXVpcmUoXCIuL21haW5cIik7XG59XG5cbnZhciBfUHJvdmlkZXI7XG5cbmZ1bmN0aW9uIF9sb2FkX1Byb3ZpZGVyKCkge1xuICAgIHJldHVybiBfUHJvdmlkZXIgPSByZXF1aXJlKFwiLi9Qcm92aWRlclwiKTtcbn1cblxudmFyIF93aW5kb3dzRXhlY3V0YWJsZUNvZGVTaWduYXR1cmVWZXJpZmllcjtcblxuZnVuY3Rpb24gX2xvYWRfd2luZG93c0V4ZWN1dGFibGVDb2RlU2lnbmF0dXJlVmVyaWZpZXIoKSB7XG4gICAgcmV0dXJuIF93aW5kb3dzRXhlY3V0YWJsZUNvZGVTaWduYXR1cmVWZXJpZmllciA9IHJlcXVpcmUoXCIuL3dpbmRvd3NFeGVjdXRhYmxlQ29kZVNpZ25hdHVyZVZlcmlmaWVyXCIpO1xufVxuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChvYmopIHsgaWYgKG9iaiAmJiBvYmouX19lc01vZHVsZSkgeyByZXR1cm4gb2JqOyB9IGVsc2UgeyB2YXIgbmV3T2JqID0ge307IGlmIChvYmogIT0gbnVsbCkgeyBmb3IgKHZhciBrZXkgaW4gb2JqKSB7IGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBrZXkpKSBuZXdPYmpba2V5XSA9IG9ialtrZXldOyB9IH0gbmV3T2JqLmRlZmF1bHQgPSBvYmo7IHJldHVybiBuZXdPYmo7IH0gfVxuXG5jbGFzcyBOc2lzVXBkYXRlciBleHRlbmRzIChfQmFzZVVwZGF0ZXIgfHwgX2xvYWRfQmFzZVVwZGF0ZXIoKSkuQmFzZVVwZGF0ZXIge1xuICAgIGNvbnN0cnVjdG9yKG9wdGlvbnMsIGFwcCkge1xuICAgICAgICBzdXBlcihvcHRpb25zLCBhcHApO1xuICAgIH1cbiAgICAvKioqIEBwcml2YXRlICovXG4gICAgZG9Eb3dubG9hZFVwZGF0ZSh1cGRhdGVJbmZvLCBjYW5jZWxsYXRpb25Ub2tlbikge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgICAgIHJldHVybiAoMCwgKF9ibHVlYmlyZExzdCB8fCBfbG9hZF9ibHVlYmlyZExzdCgpKS5jb3JvdXRpbmUpKGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCBwcm92aWRlciA9IHlpZWxkIF90aGlzLnByb3ZpZGVyO1xuICAgICAgICAgICAgY29uc3QgZmlsZUluZm8gPSAoMCwgKF9Qcm92aWRlciB8fCBfbG9hZF9Qcm92aWRlcigpKS5maW5kRmlsZSkocHJvdmlkZXIucmVzb2x2ZUZpbGVzKHVwZGF0ZUluZm8pLCBcImV4ZVwiKTtcbiAgICAgICAgICAgIGNvbnN0IHJlcXVlc3RIZWFkZXJzID0geWllbGQgX3RoaXMuY29tcHV0ZVJlcXVlc3RIZWFkZXJzKCk7XG4gICAgICAgICAgICBjb25zdCBkb3dubG9hZE9wdGlvbnMgPSB7XG4gICAgICAgICAgICAgICAgc2tpcERpckNyZWF0aW9uOiB0cnVlLFxuICAgICAgICAgICAgICAgIGhlYWRlcnM6IHJlcXVlc3RIZWFkZXJzLFxuICAgICAgICAgICAgICAgIGNhbmNlbGxhdGlvblRva2VuLFxuICAgICAgICAgICAgICAgIHNoYTUxMjogZmlsZUluZm8uaW5mby5zaGE1MTJcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBsZXQgcGFja2FnZVBhdGggPSBfdGhpcy5kb3dubG9hZGVkVXBkYXRlSGVscGVyLnBhY2thZ2VQYXRoO1xuICAgICAgICAgICAgbGV0IGluc3RhbGxlclBhdGggPSBfdGhpcy5kb3dubG9hZGVkVXBkYXRlSGVscGVyLmdldERvd25sb2FkZWRGaWxlKHVwZGF0ZUluZm8sIGZpbGVJbmZvKTtcbiAgICAgICAgICAgIGlmIChpbnN0YWxsZXJQYXRoICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcGFja2FnZVBhdGggPT0gbnVsbCA/IFtpbnN0YWxsZXJQYXRoXSA6IFtpbnN0YWxsZXJQYXRoLCBwYWNrYWdlUGF0aF07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB5aWVsZCBfdGhpcy5leGVjdXRlRG93bmxvYWQoZG93bmxvYWRPcHRpb25zLCBmaWxlSW5mbywgKCgpID0+IHtcbiAgICAgICAgICAgICAgICB2YXIgX3JlZiA9ICgwLCAoX2JsdWViaXJkTHN0IHx8IF9sb2FkX2JsdWViaXJkTHN0KCkpLmNvcm91dGluZSkoZnVuY3Rpb24qICh0ZW1wRGlyLCBkZXN0aW5hdGlvbkZpbGUsIHJlbW92ZVRlbXBEaXJJZkFueSkge1xuICAgICAgICAgICAgICAgICAgICBpbnN0YWxsZXJQYXRoID0gZGVzdGluYXRpb25GaWxlO1xuICAgICAgICAgICAgICAgICAgICBpZiAoeWllbGQgX3RoaXMuZGlmZmVyZW50aWFsRG93bmxvYWRJbnN0YWxsZXIoZmlsZUluZm8sIFwiT0xEXCIsIGluc3RhbGxlclBhdGgsIHJlcXVlc3RIZWFkZXJzLCBwcm92aWRlcikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHlpZWxkIF90aGlzLmh0dHBFeGVjdXRvci5kb3dubG9hZChmaWxlSW5mby51cmwuaHJlZiwgaW5zdGFsbGVyUGF0aCwgZG93bmxvYWRPcHRpb25zKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjb25zdCBzaWduYXR1cmVWZXJpZmljYXRpb25TdGF0dXMgPSB5aWVsZCBfdGhpcy52ZXJpZnlTaWduYXR1cmUoaW5zdGFsbGVyUGF0aCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzaWduYXR1cmVWZXJpZmljYXRpb25TdGF0dXMgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgeWllbGQgcmVtb3ZlVGVtcERpcklmQW55KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBub2luc3BlY3Rpb24gVGhyb3dJbnNpZGVGaW5hbGx5QmxvY2tKU1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgKDAsIChfYnVpbGRlclV0aWxSdW50aW1lIHx8IF9sb2FkX2J1aWxkZXJVdGlsUnVudGltZSgpKS5uZXdFcnJvcikoYE5ldyB2ZXJzaW9uICR7X3RoaXMudXBkYXRlSW5mby52ZXJzaW9ufSBpcyBub3Qgc2lnbmVkIGJ5IHRoZSBhcHBsaWNhdGlvbiBvd25lcjogJHtzaWduYXR1cmVWZXJpZmljYXRpb25TdGF0dXN9YCwgXCJFUlJfVVBEQVRFUl9JTlZBTElEX1NJR05BVFVSRVwiKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjb25zdCBwYWNrYWdlSW5mbyA9IGZpbGVJbmZvLnBhY2thZ2VJbmZvO1xuICAgICAgICAgICAgICAgICAgICBpZiAocGFja2FnZUluZm8gIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcGFja2FnZVBhdGggPSBfcGF0aC5qb2luKHRlbXBEaXIsIGBwYWNrYWdlLSR7dXBkYXRlSW5mby52ZXJzaW9ufSR7X3BhdGguZXh0bmFtZShwYWNrYWdlSW5mby5wYXRoKSB8fCBcIi43elwifWApO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHlpZWxkIF90aGlzLmRpZmZlcmVudGlhbERvd25sb2FkV2ViUGFja2FnZShwYWNrYWdlSW5mbywgcGFja2FnZVBhdGgsIHByb3ZpZGVyKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHlpZWxkIF90aGlzLmh0dHBFeGVjdXRvci5kb3dubG9hZChwYWNrYWdlSW5mby5wYXRoLCBwYWNrYWdlUGF0aCwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBza2lwRGlyQ3JlYXRpb246IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhlYWRlcnM6IHJlcXVlc3RIZWFkZXJzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYW5jZWxsYXRpb25Ub2tlbixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2hhNTEyOiBwYWNrYWdlSW5mby5zaGE1MTJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChfeCwgX3gyLCBfeDMpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9yZWYuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSkoKSk7XG4gICAgICAgICAgICBfdGhpcy5kb3dubG9hZGVkVXBkYXRlSGVscGVyLnNldERvd25sb2FkZWRGaWxlKGluc3RhbGxlclBhdGgsIHBhY2thZ2VQYXRoLCB1cGRhdGVJbmZvLCBmaWxlSW5mbyk7XG4gICAgICAgICAgICBfdGhpcy5hZGRRdWl0SGFuZGxlcigpO1xuICAgICAgICAgICAgX3RoaXMuZW1pdCgoX21haW4gfHwgX2xvYWRfbWFpbigpKS5VUERBVEVfRE9XTkxPQURFRCwgX3RoaXMudXBkYXRlSW5mbyk7XG4gICAgICAgICAgICByZXR1cm4gcGFja2FnZVBhdGggPT0gbnVsbCA/IFtpbnN0YWxsZXJQYXRoXSA6IFtpbnN0YWxsZXJQYXRoLCBwYWNrYWdlUGF0aF07XG4gICAgICAgIH0pKCk7XG4gICAgfVxuICAgIC8vICRjZXJ0aWZpY2F0ZUluZm8gPSAoR2V0LUF1dGhlbnRpY29kZVNpZ25hdHVyZSAneHh4XFx5eXkuZXhlJ1xuICAgIC8vIHwgd2hlcmUgeyRfLlN0YXR1cy5FcXVhbHMoW1N5c3RlbS5NYW5hZ2VtZW50LkF1dG9tYXRpb24uU2lnbmF0dXJlU3RhdHVzXTo6VmFsaWQpIC1hbmQgJF8uU2lnbmVyQ2VydGlmaWNhdGUuU3ViamVjdC5Db250YWlucyhcIkNOPXNpZW1lbnMuY29tXCIpfSlcbiAgICAvLyB8IE91dC1TdHJpbmcgOyBpZiAoJGNlcnRpZmljYXRlSW5mbykgeyBleGl0IDAgfSBlbHNlIHsgZXhpdCAxIH1cbiAgICB2ZXJpZnlTaWduYXR1cmUodGVtcFVwZGF0ZUZpbGUpIHtcbiAgICAgICAgdmFyIF90aGlzMiA9IHRoaXM7XG5cbiAgICAgICAgcmV0dXJuICgwLCAoX2JsdWViaXJkTHN0IHx8IF9sb2FkX2JsdWViaXJkTHN0KCkpLmNvcm91dGluZSkoZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGxldCBwdWJsaXNoZXJOYW1lO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBwdWJsaXNoZXJOYW1lID0gKHlpZWxkIF90aGlzMi5jb25maWdPbkRpc2sudmFsdWUpLnB1Ymxpc2hlck5hbWU7XG4gICAgICAgICAgICAgICAgaWYgKHB1Ymxpc2hlck5hbWUgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgaWYgKGUuY29kZSA9PT0gXCJFTk9FTlRcIikge1xuICAgICAgICAgICAgICAgICAgICAvLyBubyBhcHAtdXBkYXRlLnltbFxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB5aWVsZCAoMCwgKF93aW5kb3dzRXhlY3V0YWJsZUNvZGVTaWduYXR1cmVWZXJpZmllciB8fCBfbG9hZF93aW5kb3dzRXhlY3V0YWJsZUNvZGVTaWduYXR1cmVWZXJpZmllcigpKS52ZXJpZnlTaWduYXR1cmUpKEFycmF5LmlzQXJyYXkocHVibGlzaGVyTmFtZSkgPyBwdWJsaXNoZXJOYW1lIDogW3B1Ymxpc2hlck5hbWVdLCB0ZW1wVXBkYXRlRmlsZSwgX3RoaXMyLl9sb2dnZXIpO1xuICAgICAgICB9KSgpO1xuICAgIH1cbiAgICBkb0luc3RhbGwoaW5zdGFsbGVyUGF0aCwgaXNTaWxlbnQsIGlzRm9yY2VSdW5BZnRlcikge1xuICAgICAgICBjb25zdCBhcmdzID0gW1wiLS11cGRhdGVkXCJdO1xuICAgICAgICBpZiAoaXNTaWxlbnQpIHtcbiAgICAgICAgICAgIGFyZ3MucHVzaChcIi9TXCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc0ZvcmNlUnVuQWZ0ZXIpIHtcbiAgICAgICAgICAgIGFyZ3MucHVzaChcIi0tZm9yY2UtcnVuXCIpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHBhY2thZ2VQYXRoID0gdGhpcy5kb3dubG9hZGVkVXBkYXRlSGVscGVyLnBhY2thZ2VQYXRoO1xuICAgICAgICBpZiAocGFja2FnZVBhdGggIT0gbnVsbCkge1xuICAgICAgICAgICAgLy8gb25seSA9IGZvcm0gaXMgc3VwcG9ydGVkXG4gICAgICAgICAgICBhcmdzLnB1c2goYC0tcGFja2FnZS1maWxlPSR7cGFja2FnZVBhdGh9YCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgc3Bhd25PcHRpb25zID0ge1xuICAgICAgICAgICAgZGV0YWNoZWQ6IHRydWUsXG4gICAgICAgICAgICBzdGRpbzogXCJpZ25vcmVcIlxuICAgICAgICB9O1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgKDAsIChfY2hpbGRfcHJvY2VzcyB8fCBfbG9hZF9jaGlsZF9wcm9jZXNzKCkpLnNwYXduKShpbnN0YWxsZXJQYXRoLCBhcmdzLCBzcGF3bk9wdGlvbnMpLnVucmVmKCk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIC8vIHllcywgc3VjaCBlcnJvcnMgZGlzcGF0Y2hlZCBub3QgYXMgZXJyb3IgZXZlbnRcbiAgICAgICAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9lbGVjdHJvbi11c2VybGFuZC9lbGVjdHJvbi1idWlsZGVyL2lzc3Vlcy8xMTI5XG4gICAgICAgICAgICBpZiAoZS5jb2RlID09PSBcIlVOS05PV05cIiB8fCBlLmNvZGUgPT09IFwiRUFDQ0VTXCIpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9sb2dnZXIuaW5mbyhcIkFjY2VzcyBkZW5pZWQgb3IgVU5LTk9XTiBlcnJvciBjb2RlIG9uIHNwYXduLCB3aWxsIGJlIGV4ZWN1dGVkIGFnYWluIHVzaW5nIGVsZXZhdGVcIik7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgKDAsIChfY2hpbGRfcHJvY2VzcyB8fCBfbG9hZF9jaGlsZF9wcm9jZXNzKCkpLnNwYXduKShfcGF0aC5qb2luKHByb2Nlc3MucmVzb3VyY2VzUGF0aCwgXCJlbGV2YXRlLmV4ZVwiKSwgW2luc3RhbGxlclBhdGhdLmNvbmNhdChhcmdzKSwgc3Bhd25PcHRpb25zKS51bnJlZigpO1xuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kaXNwYXRjaEVycm9yKGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5kaXNwYXRjaEVycm9yKGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBkaWZmZXJlbnRpYWxEb3dubG9hZEluc3RhbGxlcihmaWxlSW5mbywgb2xkRmlsZSwgaW5zdGFsbGVyUGF0aCwgcmVxdWVzdEhlYWRlcnMsIHByb3ZpZGVyKSB7XG4gICAgICAgIHZhciBfdGhpczMgPSB0aGlzO1xuXG4gICAgICAgIHJldHVybiAoMCwgKF9ibHVlYmlyZExzdCB8fCBfbG9hZF9ibHVlYmlyZExzdCgpKS5jb3JvdXRpbmUpKGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBpZiAocHJvY2Vzcy5lbnYuX19OU0lTX0RJRkZFUkVOVElBTF9VUERBVEVfXyA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGJsb2NrTWFwRGF0YSA9IEpTT04ucGFyc2UoKHlpZWxkIHByb3ZpZGVyLmh0dHBSZXF1ZXN0KCgwLCAoX21haW4gfHwgX2xvYWRfbWFpbigpKS5uZXdVcmxGcm9tQmFzZSkoYCR7ZmlsZUluZm8udXJsLnBhdGhuYW1lfS5ibG9ja01hcC5qc29uYCwgZmlsZUluZm8udXJsKSkpKTtcbiAgICAgICAgICAgICAgICB5aWVsZCBuZXcgKF9HZW5lcmljRGlmZmVyZW50aWFsRG93bmxvYWRlciB8fCBfbG9hZF9HZW5lcmljRGlmZmVyZW50aWFsRG93bmxvYWRlcigpKS5HZW5lcmljRGlmZmVyZW50aWFsRG93bmxvYWRlcihmaWxlSW5mby5pbmZvLCBfdGhpczMuaHR0cEV4ZWN1dG9yLCB7XG4gICAgICAgICAgICAgICAgICAgIG5ld1VybDogZmlsZUluZm8udXJsLmhyZWYsXG4gICAgICAgICAgICAgICAgICAgIG9sZEZpbGUsXG4gICAgICAgICAgICAgICAgICAgIGxvZ2dlcjogX3RoaXMzLl9sb2dnZXIsXG4gICAgICAgICAgICAgICAgICAgIG5ld0ZpbGU6IGluc3RhbGxlclBhdGgsXG4gICAgICAgICAgICAgICAgICAgIHVzZU11bHRpcGxlUmFuZ2VSZXF1ZXN0OiBwcm92aWRlci51c2VNdWx0aXBsZVJhbmdlUmVxdWVzdCxcbiAgICAgICAgICAgICAgICAgICAgcmVxdWVzdEhlYWRlcnNcbiAgICAgICAgICAgICAgICB9KS5kb3dubG9hZChibG9ja01hcERhdGEpO1xuICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIF90aGlzMy5fbG9nZ2VyLmVycm9yKGBDYW5ub3QgZG93bmxvYWQgZGlmZmVyZW50aWFsbHksIGZhbGxiYWNrIHRvIGZ1bGwgZG93bmxvYWQ6ICR7ZS5zdGFjayB8fCBlfWApO1xuICAgICAgICAgICAgICAgIC8vIGR1cmluZyB0ZXN0IChkZXZlbG9wZXIgbWFjaGluZSBtYWMpIHdlIG11c3QgdGhyb3cgZXJyb3JcbiAgICAgICAgICAgICAgICByZXR1cm4gcHJvY2Vzcy5wbGF0Zm9ybSA9PT0gXCJ3aW4zMlwiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9KSgpO1xuICAgIH1cbiAgICBkaWZmZXJlbnRpYWxEb3dubG9hZFdlYlBhY2thZ2UocGFja2FnZUluZm8sIHBhY2thZ2VQYXRoLCBwcm92aWRlcikge1xuICAgICAgICB2YXIgX3RoaXM0ID0gdGhpcztcblxuICAgICAgICByZXR1cm4gKDAsIChfYmx1ZWJpcmRMc3QgfHwgX2xvYWRfYmx1ZWJpcmRMc3QoKSkuY29yb3V0aW5lKShmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgaWYgKHBhY2thZ2VJbmZvLmJsb2NrTWFwU2l6ZSA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHlpZWxkIG5ldyAoX0ZpbGVXaXRoRW1iZWRkZWRCbG9ja01hcERpZmZlcmVudGlhbERvd25sb2FkZXIgfHwgX2xvYWRfRmlsZVdpdGhFbWJlZGRlZEJsb2NrTWFwRGlmZmVyZW50aWFsRG93bmxvYWRlcigpKS5GaWxlV2l0aEVtYmVkZGVkQmxvY2tNYXBEaWZmZXJlbnRpYWxEb3dubG9hZGVyKHBhY2thZ2VJbmZvLCBfdGhpczQuaHR0cEV4ZWN1dG9yLCB7XG4gICAgICAgICAgICAgICAgICAgIG5ld1VybDogcGFja2FnZUluZm8ucGF0aCxcbiAgICAgICAgICAgICAgICAgICAgb2xkRmlsZTogX3BhdGguam9pbihwcm9jZXNzLnJlc291cmNlc1BhdGgsIFwiLi5cIiwgXCJwYWNrYWdlLjd6XCIpLFxuICAgICAgICAgICAgICAgICAgICBsb2dnZXI6IF90aGlzNC5fbG9nZ2VyLFxuICAgICAgICAgICAgICAgICAgICBuZXdGaWxlOiBwYWNrYWdlUGF0aCxcbiAgICAgICAgICAgICAgICAgICAgcmVxdWVzdEhlYWRlcnM6IF90aGlzNC5yZXF1ZXN0SGVhZGVycyxcbiAgICAgICAgICAgICAgICAgICAgdXNlTXVsdGlwbGVSYW5nZVJlcXVlc3Q6IHByb3ZpZGVyLnVzZU11bHRpcGxlUmFuZ2VSZXF1ZXN0XG4gICAgICAgICAgICAgICAgfSkuZG93bmxvYWQoKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICBfdGhpczQuX2xvZ2dlci5lcnJvcihgQ2Fubm90IGRvd25sb2FkIGRpZmZlcmVudGlhbGx5LCBmYWxsYmFjayB0byBmdWxsIGRvd25sb2FkOiAke2Uuc3RhY2sgfHwgZX1gKTtcbiAgICAgICAgICAgICAgICAvLyBkdXJpbmcgdGVzdCAoZGV2ZWxvcGVyIG1hY2hpbmUgbWFjIG9yIGxpbnV4KSB3ZSBtdXN0IHRocm93IGVycm9yXG4gICAgICAgICAgICAgICAgcmV0dXJuIHByb2Nlc3MucGxhdGZvcm0gPT09IFwid2luMzJcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfSkoKTtcbiAgICB9XG59XG5leHBvcnRzLk5zaXNVcGRhdGVyID0gTnNpc1VwZGF0ZXI7IC8vIyBzb3VyY2VNYXBwaW5nVVJMPU5zaXNVcGRhdGVyLmpzLm1hcFxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9lbGVjdHJvbi11cGRhdGVyL291dC9Oc2lzVXBkYXRlci5qcyIsIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLkRvd25sb2FkZWRVcGRhdGVIZWxwZXIgPSB1bmRlZmluZWQ7XG5cbnZhciBfbG9kYXNoO1xuXG5mdW5jdGlvbiBfbG9hZF9sb2Rhc2goKSB7XG4gICAgcmV0dXJuIF9sb2Rhc2ggPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJsb2Rhc2guaXNlcXVhbFwiKSk7XG59XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbi8qKiBAcHJpdmF0ZSAqKi9cbmNsYXNzIERvd25sb2FkZWRVcGRhdGVIZWxwZXIge1xuICAgIGdldCBmaWxlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zZXR1cFBhdGg7XG4gICAgfVxuICAgIGdldCBwYWNrYWdlUGF0aCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3BhY2thZ2VQYXRoO1xuICAgIH1cbiAgICBnZXREb3dubG9hZGVkRmlsZSh2ZXJzaW9uSW5mbywgZmlsZUluZm8pIHtcbiAgICAgICAgaWYgKHRoaXMuc2V0dXBQYXRoID09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAoMCwgKF9sb2Rhc2ggfHwgX2xvYWRfbG9kYXNoKCkpLmRlZmF1bHQpKHRoaXMudmVyc2lvbkluZm8sIHZlcnNpb25JbmZvKSAmJiAoMCwgKF9sb2Rhc2ggfHwgX2xvYWRfbG9kYXNoKCkpLmRlZmF1bHQpKHRoaXMuZmlsZUluZm8sIGZpbGVJbmZvKSA/IHRoaXMuc2V0dXBQYXRoIDogbnVsbDtcbiAgICB9XG4gICAgc2V0RG93bmxvYWRlZEZpbGUoZmlsZSwgcGFja2FnZVBhdGgsIHZlcnNpb25JbmZvLCBmaWxlSW5mbykge1xuICAgICAgICB0aGlzLnNldHVwUGF0aCA9IGZpbGU7XG4gICAgICAgIHRoaXMuX3BhY2thZ2VQYXRoID0gcGFja2FnZVBhdGg7XG4gICAgICAgIHRoaXMudmVyc2lvbkluZm8gPSB2ZXJzaW9uSW5mbztcbiAgICAgICAgdGhpcy5maWxlSW5mbyA9IGZpbGVJbmZvO1xuICAgIH1cbiAgICBjbGVhcigpIHtcbiAgICAgICAgdGhpcy5zZXR1cFBhdGggPSBudWxsO1xuICAgICAgICB0aGlzLl9wYWNrYWdlUGF0aCA9IG51bGw7XG4gICAgICAgIHRoaXMudmVyc2lvbkluZm8gPSBudWxsO1xuICAgICAgICB0aGlzLmZpbGVJbmZvID0gbnVsbDtcbiAgICB9XG59XG5leHBvcnRzLkRvd25sb2FkZWRVcGRhdGVIZWxwZXIgPSBEb3dubG9hZGVkVXBkYXRlSGVscGVyOyAvLyMgc291cmNlTWFwcGluZ1VSTD1Eb3dubG9hZGVkVXBkYXRlSGVscGVyLmpzLm1hcFxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9lbGVjdHJvbi11cGRhdGVyL291dC9Eb3dubG9hZGVkVXBkYXRlSGVscGVyLmpzIiwiLyoqXG4gKiBMb2Rhc2ggKEN1c3RvbSBCdWlsZCkgPGh0dHBzOi8vbG9kYXNoLmNvbS8+XG4gKiBCdWlsZDogYGxvZGFzaCBtb2R1bGFyaXplIGV4cG9ydHM9XCJucG1cIiAtbyAuL2BcbiAqIENvcHlyaWdodCBKUyBGb3VuZGF0aW9uIGFuZCBvdGhlciBjb250cmlidXRvcnMgPGh0dHBzOi8vanMuZm91bmRhdGlvbi8+XG4gKiBSZWxlYXNlZCB1bmRlciBNSVQgbGljZW5zZSA8aHR0cHM6Ly9sb2Rhc2guY29tL2xpY2Vuc2U+XG4gKiBCYXNlZCBvbiBVbmRlcnNjb3JlLmpzIDEuOC4zIDxodHRwOi8vdW5kZXJzY29yZWpzLm9yZy9MSUNFTlNFPlxuICogQ29weXJpZ2h0IEplcmVteSBBc2hrZW5hcywgRG9jdW1lbnRDbG91ZCBhbmQgSW52ZXN0aWdhdGl2ZSBSZXBvcnRlcnMgJiBFZGl0b3JzXG4gKi9cblxuLyoqIFVzZWQgYXMgdGhlIHNpemUgdG8gZW5hYmxlIGxhcmdlIGFycmF5IG9wdGltaXphdGlvbnMuICovXG52YXIgTEFSR0VfQVJSQVlfU0laRSA9IDIwMDtcblxuLyoqIFVzZWQgdG8gc3RhbmQtaW4gZm9yIGB1bmRlZmluZWRgIGhhc2ggdmFsdWVzLiAqL1xudmFyIEhBU0hfVU5ERUZJTkVEID0gJ19fbG9kYXNoX2hhc2hfdW5kZWZpbmVkX18nO1xuXG4vKiogVXNlZCB0byBjb21wb3NlIGJpdG1hc2tzIGZvciB2YWx1ZSBjb21wYXJpc29ucy4gKi9cbnZhciBDT01QQVJFX1BBUlRJQUxfRkxBRyA9IDEsXG4gICAgQ09NUEFSRV9VTk9SREVSRURfRkxBRyA9IDI7XG5cbi8qKiBVc2VkIGFzIHJlZmVyZW5jZXMgZm9yIHZhcmlvdXMgYE51bWJlcmAgY29uc3RhbnRzLiAqL1xudmFyIE1BWF9TQUZFX0lOVEVHRVIgPSA5MDA3MTk5MjU0NzQwOTkxO1xuXG4vKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHJlZmVyZW5jZXMuICovXG52YXIgYXJnc1RhZyA9ICdbb2JqZWN0IEFyZ3VtZW50c10nLFxuICAgIGFycmF5VGFnID0gJ1tvYmplY3QgQXJyYXldJyxcbiAgICBhc3luY1RhZyA9ICdbb2JqZWN0IEFzeW5jRnVuY3Rpb25dJyxcbiAgICBib29sVGFnID0gJ1tvYmplY3QgQm9vbGVhbl0nLFxuICAgIGRhdGVUYWcgPSAnW29iamVjdCBEYXRlXScsXG4gICAgZXJyb3JUYWcgPSAnW29iamVjdCBFcnJvcl0nLFxuICAgIGZ1bmNUYWcgPSAnW29iamVjdCBGdW5jdGlvbl0nLFxuICAgIGdlblRhZyA9ICdbb2JqZWN0IEdlbmVyYXRvckZ1bmN0aW9uXScsXG4gICAgbWFwVGFnID0gJ1tvYmplY3QgTWFwXScsXG4gICAgbnVtYmVyVGFnID0gJ1tvYmplY3QgTnVtYmVyXScsXG4gICAgbnVsbFRhZyA9ICdbb2JqZWN0IE51bGxdJyxcbiAgICBvYmplY3RUYWcgPSAnW29iamVjdCBPYmplY3RdJyxcbiAgICBwcm9taXNlVGFnID0gJ1tvYmplY3QgUHJvbWlzZV0nLFxuICAgIHByb3h5VGFnID0gJ1tvYmplY3QgUHJveHldJyxcbiAgICByZWdleHBUYWcgPSAnW29iamVjdCBSZWdFeHBdJyxcbiAgICBzZXRUYWcgPSAnW29iamVjdCBTZXRdJyxcbiAgICBzdHJpbmdUYWcgPSAnW29iamVjdCBTdHJpbmddJyxcbiAgICBzeW1ib2xUYWcgPSAnW29iamVjdCBTeW1ib2xdJyxcbiAgICB1bmRlZmluZWRUYWcgPSAnW29iamVjdCBVbmRlZmluZWRdJyxcbiAgICB3ZWFrTWFwVGFnID0gJ1tvYmplY3QgV2Vha01hcF0nO1xuXG52YXIgYXJyYXlCdWZmZXJUYWcgPSAnW29iamVjdCBBcnJheUJ1ZmZlcl0nLFxuICAgIGRhdGFWaWV3VGFnID0gJ1tvYmplY3QgRGF0YVZpZXddJyxcbiAgICBmbG9hdDMyVGFnID0gJ1tvYmplY3QgRmxvYXQzMkFycmF5XScsXG4gICAgZmxvYXQ2NFRhZyA9ICdbb2JqZWN0IEZsb2F0NjRBcnJheV0nLFxuICAgIGludDhUYWcgPSAnW29iamVjdCBJbnQ4QXJyYXldJyxcbiAgICBpbnQxNlRhZyA9ICdbb2JqZWN0IEludDE2QXJyYXldJyxcbiAgICBpbnQzMlRhZyA9ICdbb2JqZWN0IEludDMyQXJyYXldJyxcbiAgICB1aW50OFRhZyA9ICdbb2JqZWN0IFVpbnQ4QXJyYXldJyxcbiAgICB1aW50OENsYW1wZWRUYWcgPSAnW29iamVjdCBVaW50OENsYW1wZWRBcnJheV0nLFxuICAgIHVpbnQxNlRhZyA9ICdbb2JqZWN0IFVpbnQxNkFycmF5XScsXG4gICAgdWludDMyVGFnID0gJ1tvYmplY3QgVWludDMyQXJyYXldJztcblxuLyoqXG4gKiBVc2VkIHRvIG1hdGNoIGBSZWdFeHBgXG4gKiBbc3ludGF4IGNoYXJhY3RlcnNdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLXBhdHRlcm5zKS5cbiAqL1xudmFyIHJlUmVnRXhwQ2hhciA9IC9bXFxcXF4kLiorPygpW1xcXXt9fF0vZztcblxuLyoqIFVzZWQgdG8gZGV0ZWN0IGhvc3QgY29uc3RydWN0b3JzIChTYWZhcmkpLiAqL1xudmFyIHJlSXNIb3N0Q3RvciA9IC9eXFxbb2JqZWN0IC4rP0NvbnN0cnVjdG9yXFxdJC87XG5cbi8qKiBVc2VkIHRvIGRldGVjdCB1bnNpZ25lZCBpbnRlZ2VyIHZhbHVlcy4gKi9cbnZhciByZUlzVWludCA9IC9eKD86MHxbMS05XVxcZCopJC87XG5cbi8qKiBVc2VkIHRvIGlkZW50aWZ5IGB0b1N0cmluZ1RhZ2AgdmFsdWVzIG9mIHR5cGVkIGFycmF5cy4gKi9cbnZhciB0eXBlZEFycmF5VGFncyA9IHt9O1xudHlwZWRBcnJheVRhZ3NbZmxvYXQzMlRhZ10gPSB0eXBlZEFycmF5VGFnc1tmbG9hdDY0VGFnXSA9XG50eXBlZEFycmF5VGFnc1tpbnQ4VGFnXSA9IHR5cGVkQXJyYXlUYWdzW2ludDE2VGFnXSA9XG50eXBlZEFycmF5VGFnc1tpbnQzMlRhZ10gPSB0eXBlZEFycmF5VGFnc1t1aW50OFRhZ10gPVxudHlwZWRBcnJheVRhZ3NbdWludDhDbGFtcGVkVGFnXSA9IHR5cGVkQXJyYXlUYWdzW3VpbnQxNlRhZ10gPVxudHlwZWRBcnJheVRhZ3NbdWludDMyVGFnXSA9IHRydWU7XG50eXBlZEFycmF5VGFnc1thcmdzVGFnXSA9IHR5cGVkQXJyYXlUYWdzW2FycmF5VGFnXSA9XG50eXBlZEFycmF5VGFnc1thcnJheUJ1ZmZlclRhZ10gPSB0eXBlZEFycmF5VGFnc1tib29sVGFnXSA9XG50eXBlZEFycmF5VGFnc1tkYXRhVmlld1RhZ10gPSB0eXBlZEFycmF5VGFnc1tkYXRlVGFnXSA9XG50eXBlZEFycmF5VGFnc1tlcnJvclRhZ10gPSB0eXBlZEFycmF5VGFnc1tmdW5jVGFnXSA9XG50eXBlZEFycmF5VGFnc1ttYXBUYWddID0gdHlwZWRBcnJheVRhZ3NbbnVtYmVyVGFnXSA9XG50eXBlZEFycmF5VGFnc1tvYmplY3RUYWddID0gdHlwZWRBcnJheVRhZ3NbcmVnZXhwVGFnXSA9XG50eXBlZEFycmF5VGFnc1tzZXRUYWddID0gdHlwZWRBcnJheVRhZ3Nbc3RyaW5nVGFnXSA9XG50eXBlZEFycmF5VGFnc1t3ZWFrTWFwVGFnXSA9IGZhbHNlO1xuXG4vKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYGdsb2JhbGAgZnJvbSBOb2RlLmpzLiAqL1xudmFyIGZyZWVHbG9iYWwgPSB0eXBlb2YgZ2xvYmFsID09ICdvYmplY3QnICYmIGdsb2JhbCAmJiBnbG9iYWwuT2JqZWN0ID09PSBPYmplY3QgJiYgZ2xvYmFsO1xuXG4vKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYHNlbGZgLiAqL1xudmFyIGZyZWVTZWxmID0gdHlwZW9mIHNlbGYgPT0gJ29iamVjdCcgJiYgc2VsZiAmJiBzZWxmLk9iamVjdCA9PT0gT2JqZWN0ICYmIHNlbGY7XG5cbi8qKiBVc2VkIGFzIGEgcmVmZXJlbmNlIHRvIHRoZSBnbG9iYWwgb2JqZWN0LiAqL1xudmFyIHJvb3QgPSBmcmVlR2xvYmFsIHx8IGZyZWVTZWxmIHx8IEZ1bmN0aW9uKCdyZXR1cm4gdGhpcycpKCk7XG5cbi8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgZXhwb3J0c2AuICovXG52YXIgZnJlZUV4cG9ydHMgPSB0eXBlb2YgZXhwb3J0cyA9PSAnb2JqZWN0JyAmJiBleHBvcnRzICYmICFleHBvcnRzLm5vZGVUeXBlICYmIGV4cG9ydHM7XG5cbi8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgbW9kdWxlYC4gKi9cbnZhciBmcmVlTW9kdWxlID0gZnJlZUV4cG9ydHMgJiYgdHlwZW9mIG1vZHVsZSA9PSAnb2JqZWN0JyAmJiBtb2R1bGUgJiYgIW1vZHVsZS5ub2RlVHlwZSAmJiBtb2R1bGU7XG5cbi8qKiBEZXRlY3QgdGhlIHBvcHVsYXIgQ29tbW9uSlMgZXh0ZW5zaW9uIGBtb2R1bGUuZXhwb3J0c2AuICovXG52YXIgbW9kdWxlRXhwb3J0cyA9IGZyZWVNb2R1bGUgJiYgZnJlZU1vZHVsZS5leHBvcnRzID09PSBmcmVlRXhwb3J0cztcblxuLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBwcm9jZXNzYCBmcm9tIE5vZGUuanMuICovXG52YXIgZnJlZVByb2Nlc3MgPSBtb2R1bGVFeHBvcnRzICYmIGZyZWVHbG9iYWwucHJvY2VzcztcblxuLyoqIFVzZWQgdG8gYWNjZXNzIGZhc3RlciBOb2RlLmpzIGhlbHBlcnMuICovXG52YXIgbm9kZVV0aWwgPSAoZnVuY3Rpb24oKSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIGZyZWVQcm9jZXNzICYmIGZyZWVQcm9jZXNzLmJpbmRpbmcgJiYgZnJlZVByb2Nlc3MuYmluZGluZygndXRpbCcpO1xuICB9IGNhdGNoIChlKSB7fVxufSgpKTtcblxuLyogTm9kZS5qcyBoZWxwZXIgcmVmZXJlbmNlcy4gKi9cbnZhciBub2RlSXNUeXBlZEFycmF5ID0gbm9kZVV0aWwgJiYgbm9kZVV0aWwuaXNUeXBlZEFycmF5O1xuXG4vKipcbiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgXy5maWx0ZXJgIGZvciBhcnJheXMgd2l0aG91dCBzdXBwb3J0IGZvclxuICogaXRlcmF0ZWUgc2hvcnRoYW5kcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gW2FycmF5XSBUaGUgYXJyYXkgdG8gaXRlcmF0ZSBvdmVyLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gcHJlZGljYXRlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBmaWx0ZXJlZCBhcnJheS5cbiAqL1xuZnVuY3Rpb24gYXJyYXlGaWx0ZXIoYXJyYXksIHByZWRpY2F0ZSkge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IGFycmF5ID09IG51bGwgPyAwIDogYXJyYXkubGVuZ3RoLFxuICAgICAgcmVzSW5kZXggPSAwLFxuICAgICAgcmVzdWx0ID0gW107XG5cbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICB2YXIgdmFsdWUgPSBhcnJheVtpbmRleF07XG4gICAgaWYgKHByZWRpY2F0ZSh2YWx1ZSwgaW5kZXgsIGFycmF5KSkge1xuICAgICAgcmVzdWx0W3Jlc0luZGV4KytdID0gdmFsdWU7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbi8qKlxuICogQXBwZW5kcyB0aGUgZWxlbWVudHMgb2YgYHZhbHVlc2AgdG8gYGFycmF5YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIG1vZGlmeS5cbiAqIEBwYXJhbSB7QXJyYXl9IHZhbHVlcyBUaGUgdmFsdWVzIHRvIGFwcGVuZC5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyBgYXJyYXlgLlxuICovXG5mdW5jdGlvbiBhcnJheVB1c2goYXJyYXksIHZhbHVlcykge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IHZhbHVlcy5sZW5ndGgsXG4gICAgICBvZmZzZXQgPSBhcnJheS5sZW5ndGg7XG5cbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICBhcnJheVtvZmZzZXQgKyBpbmRleF0gPSB2YWx1ZXNbaW5kZXhdO1xuICB9XG4gIHJldHVybiBhcnJheTtcbn1cblxuLyoqXG4gKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYF8uc29tZWAgZm9yIGFycmF5cyB3aXRob3V0IHN1cHBvcnQgZm9yIGl0ZXJhdGVlXG4gKiBzaG9ydGhhbmRzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fSBbYXJyYXldIFRoZSBhcnJheSB0byBpdGVyYXRlIG92ZXIuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBwcmVkaWNhdGUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBhbnkgZWxlbWVudCBwYXNzZXMgdGhlIHByZWRpY2F0ZSBjaGVjayxcbiAqICBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGFycmF5U29tZShhcnJheSwgcHJlZGljYXRlKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gYXJyYXkgPT0gbnVsbCA/IDAgOiBhcnJheS5sZW5ndGg7XG5cbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICBpZiAocHJlZGljYXRlKGFycmF5W2luZGV4XSwgaW5kZXgsIGFycmF5KSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy50aW1lc2Agd2l0aG91dCBzdXBwb3J0IGZvciBpdGVyYXRlZSBzaG9ydGhhbmRzXG4gKiBvciBtYXggYXJyYXkgbGVuZ3RoIGNoZWNrcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtudW1iZXJ9IG4gVGhlIG51bWJlciBvZiB0aW1lcyB0byBpbnZva2UgYGl0ZXJhdGVlYC5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdGVlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHJlc3VsdHMuXG4gKi9cbmZ1bmN0aW9uIGJhc2VUaW1lcyhuLCBpdGVyYXRlZSkge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIHJlc3VsdCA9IEFycmF5KG4pO1xuXG4gIHdoaWxlICgrK2luZGV4IDwgbikge1xuICAgIHJlc3VsdFtpbmRleF0gPSBpdGVyYXRlZShpbmRleCk7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy51bmFyeWAgd2l0aG91dCBzdXBwb3J0IGZvciBzdG9yaW5nIG1ldGFkYXRhLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBjYXAgYXJndW1lbnRzIGZvci5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGNhcHBlZCBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gYmFzZVVuYXJ5KGZ1bmMpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgcmV0dXJuIGZ1bmModmFsdWUpO1xuICB9O1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBhIGBjYWNoZWAgdmFsdWUgZm9yIGBrZXlgIGV4aXN0cy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IGNhY2hlIFRoZSBjYWNoZSB0byBxdWVyeS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgZW50cnkgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYW4gZW50cnkgZm9yIGBrZXlgIGV4aXN0cywgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBjYWNoZUhhcyhjYWNoZSwga2V5KSB7XG4gIHJldHVybiBjYWNoZS5oYXMoa2V5KTtcbn1cblxuLyoqXG4gKiBHZXRzIHRoZSB2YWx1ZSBhdCBga2V5YCBvZiBgb2JqZWN0YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IFtvYmplY3RdIFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHByb3BlcnR5IHRvIGdldC5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBwcm9wZXJ0eSB2YWx1ZS5cbiAqL1xuZnVuY3Rpb24gZ2V0VmFsdWUob2JqZWN0LCBrZXkpIHtcbiAgcmV0dXJuIG9iamVjdCA9PSBudWxsID8gdW5kZWZpbmVkIDogb2JqZWN0W2tleV07XG59XG5cbi8qKlxuICogQ29udmVydHMgYG1hcGAgdG8gaXRzIGtleS12YWx1ZSBwYWlycy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG1hcCBUaGUgbWFwIHRvIGNvbnZlcnQuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGtleS12YWx1ZSBwYWlycy5cbiAqL1xuZnVuY3Rpb24gbWFwVG9BcnJheShtYXApIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICByZXN1bHQgPSBBcnJheShtYXAuc2l6ZSk7XG5cbiAgbWFwLmZvckVhY2goZnVuY3Rpb24odmFsdWUsIGtleSkge1xuICAgIHJlc3VsdFsrK2luZGV4XSA9IFtrZXksIHZhbHVlXTtcbiAgfSk7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIHVuYXJ5IGZ1bmN0aW9uIHRoYXQgaW52b2tlcyBgZnVuY2Agd2l0aCBpdHMgYXJndW1lbnQgdHJhbnNmb3JtZWQuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIHdyYXAuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSB0cmFuc2Zvcm0gVGhlIGFyZ3VtZW50IHRyYW5zZm9ybS5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBvdmVyQXJnKGZ1bmMsIHRyYW5zZm9ybSkge1xuICByZXR1cm4gZnVuY3Rpb24oYXJnKSB7XG4gICAgcmV0dXJuIGZ1bmModHJhbnNmb3JtKGFyZykpO1xuICB9O1xufVxuXG4vKipcbiAqIENvbnZlcnRzIGBzZXRgIHRvIGFuIGFycmF5IG9mIGl0cyB2YWx1ZXMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBzZXQgVGhlIHNldCB0byBjb252ZXJ0LlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSB2YWx1ZXMuXG4gKi9cbmZ1bmN0aW9uIHNldFRvQXJyYXkoc2V0KSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgcmVzdWx0ID0gQXJyYXkoc2V0LnNpemUpO1xuXG4gIHNldC5mb3JFYWNoKGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgcmVzdWx0WysraW5kZXhdID0gdmFsdWU7XG4gIH0pO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG4vKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgYXJyYXlQcm90byA9IEFycmF5LnByb3RvdHlwZSxcbiAgICBmdW5jUHJvdG8gPSBGdW5jdGlvbi5wcm90b3R5cGUsXG4gICAgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKiogVXNlZCB0byBkZXRlY3Qgb3ZlcnJlYWNoaW5nIGNvcmUtanMgc2hpbXMuICovXG52YXIgY29yZUpzRGF0YSA9IHJvb3RbJ19fY29yZS1qc19zaGFyZWRfXyddO1xuXG4vKiogVXNlZCB0byByZXNvbHZlIHRoZSBkZWNvbXBpbGVkIHNvdXJjZSBvZiBmdW5jdGlvbnMuICovXG52YXIgZnVuY1RvU3RyaW5nID0gZnVuY1Byb3RvLnRvU3RyaW5nO1xuXG4vKiogVXNlZCB0byBjaGVjayBvYmplY3RzIGZvciBvd24gcHJvcGVydGllcy4gKi9cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IG9iamVjdFByb3RvLmhhc093blByb3BlcnR5O1xuXG4vKiogVXNlZCB0byBkZXRlY3QgbWV0aG9kcyBtYXNxdWVyYWRpbmcgYXMgbmF0aXZlLiAqL1xudmFyIG1hc2tTcmNLZXkgPSAoZnVuY3Rpb24oKSB7XG4gIHZhciB1aWQgPSAvW14uXSskLy5leGVjKGNvcmVKc0RhdGEgJiYgY29yZUpzRGF0YS5rZXlzICYmIGNvcmVKc0RhdGEua2V5cy5JRV9QUk9UTyB8fCAnJyk7XG4gIHJldHVybiB1aWQgPyAoJ1N5bWJvbChzcmMpXzEuJyArIHVpZCkgOiAnJztcbn0oKSk7XG5cbi8qKlxuICogVXNlZCB0byByZXNvbHZlIHRoZVxuICogW2B0b1N0cmluZ1RhZ2BdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLW9iamVjdC5wcm90b3R5cGUudG9zdHJpbmcpXG4gKiBvZiB2YWx1ZXMuXG4gKi9cbnZhciBuYXRpdmVPYmplY3RUb1N0cmluZyA9IG9iamVjdFByb3RvLnRvU3RyaW5nO1xuXG4vKiogVXNlZCB0byBkZXRlY3QgaWYgYSBtZXRob2QgaXMgbmF0aXZlLiAqL1xudmFyIHJlSXNOYXRpdmUgPSBSZWdFeHAoJ14nICtcbiAgZnVuY1RvU3RyaW5nLmNhbGwoaGFzT3duUHJvcGVydHkpLnJlcGxhY2UocmVSZWdFeHBDaGFyLCAnXFxcXCQmJylcbiAgLnJlcGxhY2UoL2hhc093blByb3BlcnR5fChmdW5jdGlvbikuKj8oPz1cXFxcXFwoKXwgZm9yIC4rPyg/PVxcXFxcXF0pL2csICckMS4qPycpICsgJyQnXG4pO1xuXG4vKiogQnVpbHQtaW4gdmFsdWUgcmVmZXJlbmNlcy4gKi9cbnZhciBCdWZmZXIgPSBtb2R1bGVFeHBvcnRzID8gcm9vdC5CdWZmZXIgOiB1bmRlZmluZWQsXG4gICAgU3ltYm9sID0gcm9vdC5TeW1ib2wsXG4gICAgVWludDhBcnJheSA9IHJvb3QuVWludDhBcnJheSxcbiAgICBwcm9wZXJ0eUlzRW51bWVyYWJsZSA9IG9iamVjdFByb3RvLnByb3BlcnR5SXNFbnVtZXJhYmxlLFxuICAgIHNwbGljZSA9IGFycmF5UHJvdG8uc3BsaWNlLFxuICAgIHN5bVRvU3RyaW5nVGFnID0gU3ltYm9sID8gU3ltYm9sLnRvU3RyaW5nVGFnIDogdW5kZWZpbmVkO1xuXG4vKiBCdWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcyBmb3IgdGhvc2Ugd2l0aCB0aGUgc2FtZSBuYW1lIGFzIG90aGVyIGBsb2Rhc2hgIG1ldGhvZHMuICovXG52YXIgbmF0aXZlR2V0U3ltYm9scyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMsXG4gICAgbmF0aXZlSXNCdWZmZXIgPSBCdWZmZXIgPyBCdWZmZXIuaXNCdWZmZXIgOiB1bmRlZmluZWQsXG4gICAgbmF0aXZlS2V5cyA9IG92ZXJBcmcoT2JqZWN0LmtleXMsIE9iamVjdCk7XG5cbi8qIEJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzIHRoYXQgYXJlIHZlcmlmaWVkIHRvIGJlIG5hdGl2ZS4gKi9cbnZhciBEYXRhVmlldyA9IGdldE5hdGl2ZShyb290LCAnRGF0YVZpZXcnKSxcbiAgICBNYXAgPSBnZXROYXRpdmUocm9vdCwgJ01hcCcpLFxuICAgIFByb21pc2UgPSBnZXROYXRpdmUocm9vdCwgJ1Byb21pc2UnKSxcbiAgICBTZXQgPSBnZXROYXRpdmUocm9vdCwgJ1NldCcpLFxuICAgIFdlYWtNYXAgPSBnZXROYXRpdmUocm9vdCwgJ1dlYWtNYXAnKSxcbiAgICBuYXRpdmVDcmVhdGUgPSBnZXROYXRpdmUoT2JqZWN0LCAnY3JlYXRlJyk7XG5cbi8qKiBVc2VkIHRvIGRldGVjdCBtYXBzLCBzZXRzLCBhbmQgd2Vha21hcHMuICovXG52YXIgZGF0YVZpZXdDdG9yU3RyaW5nID0gdG9Tb3VyY2UoRGF0YVZpZXcpLFxuICAgIG1hcEN0b3JTdHJpbmcgPSB0b1NvdXJjZShNYXApLFxuICAgIHByb21pc2VDdG9yU3RyaW5nID0gdG9Tb3VyY2UoUHJvbWlzZSksXG4gICAgc2V0Q3RvclN0cmluZyA9IHRvU291cmNlKFNldCksXG4gICAgd2Vha01hcEN0b3JTdHJpbmcgPSB0b1NvdXJjZShXZWFrTWFwKTtcblxuLyoqIFVzZWQgdG8gY29udmVydCBzeW1ib2xzIHRvIHByaW1pdGl2ZXMgYW5kIHN0cmluZ3MuICovXG52YXIgc3ltYm9sUHJvdG8gPSBTeW1ib2wgPyBTeW1ib2wucHJvdG90eXBlIDogdW5kZWZpbmVkLFxuICAgIHN5bWJvbFZhbHVlT2YgPSBzeW1ib2xQcm90byA/IHN5bWJvbFByb3RvLnZhbHVlT2YgOiB1bmRlZmluZWQ7XG5cbi8qKlxuICogQ3JlYXRlcyBhIGhhc2ggb2JqZWN0LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7QXJyYXl9IFtlbnRyaWVzXSBUaGUga2V5LXZhbHVlIHBhaXJzIHRvIGNhY2hlLlxuICovXG5mdW5jdGlvbiBIYXNoKGVudHJpZXMpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSBlbnRyaWVzID09IG51bGwgPyAwIDogZW50cmllcy5sZW5ndGg7XG5cbiAgdGhpcy5jbGVhcigpO1xuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIHZhciBlbnRyeSA9IGVudHJpZXNbaW5kZXhdO1xuICAgIHRoaXMuc2V0KGVudHJ5WzBdLCBlbnRyeVsxXSk7XG4gIH1cbn1cblxuLyoqXG4gKiBSZW1vdmVzIGFsbCBrZXktdmFsdWUgZW50cmllcyBmcm9tIHRoZSBoYXNoLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBjbGVhclxuICogQG1lbWJlck9mIEhhc2hcbiAqL1xuZnVuY3Rpb24gaGFzaENsZWFyKCkge1xuICB0aGlzLl9fZGF0YV9fID0gbmF0aXZlQ3JlYXRlID8gbmF0aXZlQ3JlYXRlKG51bGwpIDoge307XG4gIHRoaXMuc2l6ZSA9IDA7XG59XG5cbi8qKlxuICogUmVtb3ZlcyBga2V5YCBhbmQgaXRzIHZhbHVlIGZyb20gdGhlIGhhc2guXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGRlbGV0ZVxuICogQG1lbWJlck9mIEhhc2hcbiAqIEBwYXJhbSB7T2JqZWN0fSBoYXNoIFRoZSBoYXNoIHRvIG1vZGlmeS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gcmVtb3ZlLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBlbnRyeSB3YXMgcmVtb3ZlZCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBoYXNoRGVsZXRlKGtleSkge1xuICB2YXIgcmVzdWx0ID0gdGhpcy5oYXMoa2V5KSAmJiBkZWxldGUgdGhpcy5fX2RhdGFfX1trZXldO1xuICB0aGlzLnNpemUgLT0gcmVzdWx0ID8gMSA6IDA7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbi8qKlxuICogR2V0cyB0aGUgaGFzaCB2YWx1ZSBmb3IgYGtleWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGdldFxuICogQG1lbWJlck9mIEhhc2hcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gZ2V0LlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGVudHJ5IHZhbHVlLlxuICovXG5mdW5jdGlvbiBoYXNoR2V0KGtleSkge1xuICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX187XG4gIGlmIChuYXRpdmVDcmVhdGUpIHtcbiAgICB2YXIgcmVzdWx0ID0gZGF0YVtrZXldO1xuICAgIHJldHVybiByZXN1bHQgPT09IEhBU0hfVU5ERUZJTkVEID8gdW5kZWZpbmVkIDogcmVzdWx0O1xuICB9XG4gIHJldHVybiBoYXNPd25Qcm9wZXJ0eS5jYWxsKGRhdGEsIGtleSkgPyBkYXRhW2tleV0gOiB1bmRlZmluZWQ7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGEgaGFzaCB2YWx1ZSBmb3IgYGtleWAgZXhpc3RzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBoYXNcbiAqIEBtZW1iZXJPZiBIYXNoXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIGVudHJ5IHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGFuIGVudHJ5IGZvciBga2V5YCBleGlzdHMsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaGFzaEhhcyhrZXkpIHtcbiAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fO1xuICByZXR1cm4gbmF0aXZlQ3JlYXRlID8gKGRhdGFba2V5XSAhPT0gdW5kZWZpbmVkKSA6IGhhc093blByb3BlcnR5LmNhbGwoZGF0YSwga2V5KTtcbn1cblxuLyoqXG4gKiBTZXRzIHRoZSBoYXNoIGBrZXlgIHRvIGB2YWx1ZWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIHNldFxuICogQG1lbWJlck9mIEhhc2hcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gc2V0LlxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gc2V0LlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgaGFzaCBpbnN0YW5jZS5cbiAqL1xuZnVuY3Rpb24gaGFzaFNldChrZXksIHZhbHVlKSB7XG4gIHZhciBkYXRhID0gdGhpcy5fX2RhdGFfXztcbiAgdGhpcy5zaXplICs9IHRoaXMuaGFzKGtleSkgPyAwIDogMTtcbiAgZGF0YVtrZXldID0gKG5hdGl2ZUNyZWF0ZSAmJiB2YWx1ZSA9PT0gdW5kZWZpbmVkKSA/IEhBU0hfVU5ERUZJTkVEIDogdmFsdWU7XG4gIHJldHVybiB0aGlzO1xufVxuXG4vLyBBZGQgbWV0aG9kcyB0byBgSGFzaGAuXG5IYXNoLnByb3RvdHlwZS5jbGVhciA9IGhhc2hDbGVhcjtcbkhhc2gucHJvdG90eXBlWydkZWxldGUnXSA9IGhhc2hEZWxldGU7XG5IYXNoLnByb3RvdHlwZS5nZXQgPSBoYXNoR2V0O1xuSGFzaC5wcm90b3R5cGUuaGFzID0gaGFzaEhhcztcbkhhc2gucHJvdG90eXBlLnNldCA9IGhhc2hTZXQ7XG5cbi8qKlxuICogQ3JlYXRlcyBhbiBsaXN0IGNhY2hlIG9iamVjdC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge0FycmF5fSBbZW50cmllc10gVGhlIGtleS12YWx1ZSBwYWlycyB0byBjYWNoZS5cbiAqL1xuZnVuY3Rpb24gTGlzdENhY2hlKGVudHJpZXMpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSBlbnRyaWVzID09IG51bGwgPyAwIDogZW50cmllcy5sZW5ndGg7XG5cbiAgdGhpcy5jbGVhcigpO1xuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIHZhciBlbnRyeSA9IGVudHJpZXNbaW5kZXhdO1xuICAgIHRoaXMuc2V0KGVudHJ5WzBdLCBlbnRyeVsxXSk7XG4gIH1cbn1cblxuLyoqXG4gKiBSZW1vdmVzIGFsbCBrZXktdmFsdWUgZW50cmllcyBmcm9tIHRoZSBsaXN0IGNhY2hlLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBjbGVhclxuICogQG1lbWJlck9mIExpc3RDYWNoZVxuICovXG5mdW5jdGlvbiBsaXN0Q2FjaGVDbGVhcigpIHtcbiAgdGhpcy5fX2RhdGFfXyA9IFtdO1xuICB0aGlzLnNpemUgPSAwO1xufVxuXG4vKipcbiAqIFJlbW92ZXMgYGtleWAgYW5kIGl0cyB2YWx1ZSBmcm9tIHRoZSBsaXN0IGNhY2hlLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBkZWxldGVcbiAqIEBtZW1iZXJPZiBMaXN0Q2FjaGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gcmVtb3ZlLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBlbnRyeSB3YXMgcmVtb3ZlZCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBsaXN0Q2FjaGVEZWxldGUoa2V5KSB7XG4gIHZhciBkYXRhID0gdGhpcy5fX2RhdGFfXyxcbiAgICAgIGluZGV4ID0gYXNzb2NJbmRleE9mKGRhdGEsIGtleSk7XG5cbiAgaWYgKGluZGV4IDwgMCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICB2YXIgbGFzdEluZGV4ID0gZGF0YS5sZW5ndGggLSAxO1xuICBpZiAoaW5kZXggPT0gbGFzdEluZGV4KSB7XG4gICAgZGF0YS5wb3AoKTtcbiAgfSBlbHNlIHtcbiAgICBzcGxpY2UuY2FsbChkYXRhLCBpbmRleCwgMSk7XG4gIH1cbiAgLS10aGlzLnNpemU7XG4gIHJldHVybiB0cnVlO1xufVxuXG4vKipcbiAqIEdldHMgdGhlIGxpc3QgY2FjaGUgdmFsdWUgZm9yIGBrZXlgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBnZXRcbiAqIEBtZW1iZXJPZiBMaXN0Q2FjaGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gZ2V0LlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGVudHJ5IHZhbHVlLlxuICovXG5mdW5jdGlvbiBsaXN0Q2FjaGVHZXQoa2V5KSB7XG4gIHZhciBkYXRhID0gdGhpcy5fX2RhdGFfXyxcbiAgICAgIGluZGV4ID0gYXNzb2NJbmRleE9mKGRhdGEsIGtleSk7XG5cbiAgcmV0dXJuIGluZGV4IDwgMCA/IHVuZGVmaW5lZCA6IGRhdGFbaW5kZXhdWzFdO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBhIGxpc3QgY2FjaGUgdmFsdWUgZm9yIGBrZXlgIGV4aXN0cy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgaGFzXG4gKiBAbWVtYmVyT2YgTGlzdENhY2hlXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIGVudHJ5IHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGFuIGVudHJ5IGZvciBga2V5YCBleGlzdHMsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gbGlzdENhY2hlSGFzKGtleSkge1xuICByZXR1cm4gYXNzb2NJbmRleE9mKHRoaXMuX19kYXRhX18sIGtleSkgPiAtMTtcbn1cblxuLyoqXG4gKiBTZXRzIHRoZSBsaXN0IGNhY2hlIGBrZXlgIHRvIGB2YWx1ZWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIHNldFxuICogQG1lbWJlck9mIExpc3RDYWNoZVxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBzZXQuXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBzZXQuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBsaXN0IGNhY2hlIGluc3RhbmNlLlxuICovXG5mdW5jdGlvbiBsaXN0Q2FjaGVTZXQoa2V5LCB2YWx1ZSkge1xuICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX18sXG4gICAgICBpbmRleCA9IGFzc29jSW5kZXhPZihkYXRhLCBrZXkpO1xuXG4gIGlmIChpbmRleCA8IDApIHtcbiAgICArK3RoaXMuc2l6ZTtcbiAgICBkYXRhLnB1c2goW2tleSwgdmFsdWVdKTtcbiAgfSBlbHNlIHtcbiAgICBkYXRhW2luZGV4XVsxXSA9IHZhbHVlO1xuICB9XG4gIHJldHVybiB0aGlzO1xufVxuXG4vLyBBZGQgbWV0aG9kcyB0byBgTGlzdENhY2hlYC5cbkxpc3RDYWNoZS5wcm90b3R5cGUuY2xlYXIgPSBsaXN0Q2FjaGVDbGVhcjtcbkxpc3RDYWNoZS5wcm90b3R5cGVbJ2RlbGV0ZSddID0gbGlzdENhY2hlRGVsZXRlO1xuTGlzdENhY2hlLnByb3RvdHlwZS5nZXQgPSBsaXN0Q2FjaGVHZXQ7XG5MaXN0Q2FjaGUucHJvdG90eXBlLmhhcyA9IGxpc3RDYWNoZUhhcztcbkxpc3RDYWNoZS5wcm90b3R5cGUuc2V0ID0gbGlzdENhY2hlU2V0O1xuXG4vKipcbiAqIENyZWF0ZXMgYSBtYXAgY2FjaGUgb2JqZWN0IHRvIHN0b3JlIGtleS12YWx1ZSBwYWlycy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge0FycmF5fSBbZW50cmllc10gVGhlIGtleS12YWx1ZSBwYWlycyB0byBjYWNoZS5cbiAqL1xuZnVuY3Rpb24gTWFwQ2FjaGUoZW50cmllcykge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IGVudHJpZXMgPT0gbnVsbCA/IDAgOiBlbnRyaWVzLmxlbmd0aDtcblxuICB0aGlzLmNsZWFyKCk7XG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgdmFyIGVudHJ5ID0gZW50cmllc1tpbmRleF07XG4gICAgdGhpcy5zZXQoZW50cnlbMF0sIGVudHJ5WzFdKTtcbiAgfVxufVxuXG4vKipcbiAqIFJlbW92ZXMgYWxsIGtleS12YWx1ZSBlbnRyaWVzIGZyb20gdGhlIG1hcC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgY2xlYXJcbiAqIEBtZW1iZXJPZiBNYXBDYWNoZVxuICovXG5mdW5jdGlvbiBtYXBDYWNoZUNsZWFyKCkge1xuICB0aGlzLnNpemUgPSAwO1xuICB0aGlzLl9fZGF0YV9fID0ge1xuICAgICdoYXNoJzogbmV3IEhhc2gsXG4gICAgJ21hcCc6IG5ldyAoTWFwIHx8IExpc3RDYWNoZSksXG4gICAgJ3N0cmluZyc6IG5ldyBIYXNoXG4gIH07XG59XG5cbi8qKlxuICogUmVtb3ZlcyBga2V5YCBhbmQgaXRzIHZhbHVlIGZyb20gdGhlIG1hcC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgZGVsZXRlXG4gKiBAbWVtYmVyT2YgTWFwQ2FjaGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gcmVtb3ZlLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBlbnRyeSB3YXMgcmVtb3ZlZCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBtYXBDYWNoZURlbGV0ZShrZXkpIHtcbiAgdmFyIHJlc3VsdCA9IGdldE1hcERhdGEodGhpcywga2V5KVsnZGVsZXRlJ10oa2V5KTtcbiAgdGhpcy5zaXplIC09IHJlc3VsdCA/IDEgOiAwO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG4vKipcbiAqIEdldHMgdGhlIG1hcCB2YWx1ZSBmb3IgYGtleWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGdldFxuICogQG1lbWJlck9mIE1hcENhY2hlXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIGdldC5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBlbnRyeSB2YWx1ZS5cbiAqL1xuZnVuY3Rpb24gbWFwQ2FjaGVHZXQoa2V5KSB7XG4gIHJldHVybiBnZXRNYXBEYXRhKHRoaXMsIGtleSkuZ2V0KGtleSk7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGEgbWFwIHZhbHVlIGZvciBga2V5YCBleGlzdHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGhhc1xuICogQG1lbWJlck9mIE1hcENhY2hlXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIGVudHJ5IHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGFuIGVudHJ5IGZvciBga2V5YCBleGlzdHMsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gbWFwQ2FjaGVIYXMoa2V5KSB7XG4gIHJldHVybiBnZXRNYXBEYXRhKHRoaXMsIGtleSkuaGFzKGtleSk7XG59XG5cbi8qKlxuICogU2V0cyB0aGUgbWFwIGBrZXlgIHRvIGB2YWx1ZWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIHNldFxuICogQG1lbWJlck9mIE1hcENhY2hlXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIHNldC5cbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHNldC5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIG1hcCBjYWNoZSBpbnN0YW5jZS5cbiAqL1xuZnVuY3Rpb24gbWFwQ2FjaGVTZXQoa2V5LCB2YWx1ZSkge1xuICB2YXIgZGF0YSA9IGdldE1hcERhdGEodGhpcywga2V5KSxcbiAgICAgIHNpemUgPSBkYXRhLnNpemU7XG5cbiAgZGF0YS5zZXQoa2V5LCB2YWx1ZSk7XG4gIHRoaXMuc2l6ZSArPSBkYXRhLnNpemUgPT0gc2l6ZSA/IDAgOiAxO1xuICByZXR1cm4gdGhpcztcbn1cblxuLy8gQWRkIG1ldGhvZHMgdG8gYE1hcENhY2hlYC5cbk1hcENhY2hlLnByb3RvdHlwZS5jbGVhciA9IG1hcENhY2hlQ2xlYXI7XG5NYXBDYWNoZS5wcm90b3R5cGVbJ2RlbGV0ZSddID0gbWFwQ2FjaGVEZWxldGU7XG5NYXBDYWNoZS5wcm90b3R5cGUuZ2V0ID0gbWFwQ2FjaGVHZXQ7XG5NYXBDYWNoZS5wcm90b3R5cGUuaGFzID0gbWFwQ2FjaGVIYXM7XG5NYXBDYWNoZS5wcm90b3R5cGUuc2V0ID0gbWFwQ2FjaGVTZXQ7XG5cbi8qKlxuICpcbiAqIENyZWF0ZXMgYW4gYXJyYXkgY2FjaGUgb2JqZWN0IHRvIHN0b3JlIHVuaXF1ZSB2YWx1ZXMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtBcnJheX0gW3ZhbHVlc10gVGhlIHZhbHVlcyB0byBjYWNoZS5cbiAqL1xuZnVuY3Rpb24gU2V0Q2FjaGUodmFsdWVzKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gdmFsdWVzID09IG51bGwgPyAwIDogdmFsdWVzLmxlbmd0aDtcblxuICB0aGlzLl9fZGF0YV9fID0gbmV3IE1hcENhY2hlO1xuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIHRoaXMuYWRkKHZhbHVlc1tpbmRleF0pO1xuICB9XG59XG5cbi8qKlxuICogQWRkcyBgdmFsdWVgIHRvIHRoZSBhcnJheSBjYWNoZS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgYWRkXG4gKiBAbWVtYmVyT2YgU2V0Q2FjaGVcbiAqIEBhbGlhcyBwdXNoXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjYWNoZS5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGNhY2hlIGluc3RhbmNlLlxuICovXG5mdW5jdGlvbiBzZXRDYWNoZUFkZCh2YWx1ZSkge1xuICB0aGlzLl9fZGF0YV9fLnNldCh2YWx1ZSwgSEFTSF9VTkRFRklORUQpO1xuICByZXR1cm4gdGhpcztcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBpbiB0aGUgYXJyYXkgY2FjaGUuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGhhc1xuICogQG1lbWJlck9mIFNldENhY2hlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBzZWFyY2ggZm9yLlxuICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBmb3VuZCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBzZXRDYWNoZUhhcyh2YWx1ZSkge1xuICByZXR1cm4gdGhpcy5fX2RhdGFfXy5oYXModmFsdWUpO1xufVxuXG4vLyBBZGQgbWV0aG9kcyB0byBgU2V0Q2FjaGVgLlxuU2V0Q2FjaGUucHJvdG90eXBlLmFkZCA9IFNldENhY2hlLnByb3RvdHlwZS5wdXNoID0gc2V0Q2FjaGVBZGQ7XG5TZXRDYWNoZS5wcm90b3R5cGUuaGFzID0gc2V0Q2FjaGVIYXM7XG5cbi8qKlxuICogQ3JlYXRlcyBhIHN0YWNrIGNhY2hlIG9iamVjdCB0byBzdG9yZSBrZXktdmFsdWUgcGFpcnMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtBcnJheX0gW2VudHJpZXNdIFRoZSBrZXktdmFsdWUgcGFpcnMgdG8gY2FjaGUuXG4gKi9cbmZ1bmN0aW9uIFN0YWNrKGVudHJpZXMpIHtcbiAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fID0gbmV3IExpc3RDYWNoZShlbnRyaWVzKTtcbiAgdGhpcy5zaXplID0gZGF0YS5zaXplO1xufVxuXG4vKipcbiAqIFJlbW92ZXMgYWxsIGtleS12YWx1ZSBlbnRyaWVzIGZyb20gdGhlIHN0YWNrLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBjbGVhclxuICogQG1lbWJlck9mIFN0YWNrXG4gKi9cbmZ1bmN0aW9uIHN0YWNrQ2xlYXIoKSB7XG4gIHRoaXMuX19kYXRhX18gPSBuZXcgTGlzdENhY2hlO1xuICB0aGlzLnNpemUgPSAwO1xufVxuXG4vKipcbiAqIFJlbW92ZXMgYGtleWAgYW5kIGl0cyB2YWx1ZSBmcm9tIHRoZSBzdGFjay5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgZGVsZXRlXG4gKiBAbWVtYmVyT2YgU3RhY2tcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gcmVtb3ZlLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBlbnRyeSB3YXMgcmVtb3ZlZCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBzdGFja0RlbGV0ZShrZXkpIHtcbiAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fLFxuICAgICAgcmVzdWx0ID0gZGF0YVsnZGVsZXRlJ10oa2V5KTtcblxuICB0aGlzLnNpemUgPSBkYXRhLnNpemU7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbi8qKlxuICogR2V0cyB0aGUgc3RhY2sgdmFsdWUgZm9yIGBrZXlgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBnZXRcbiAqIEBtZW1iZXJPZiBTdGFja1xuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBnZXQuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgZW50cnkgdmFsdWUuXG4gKi9cbmZ1bmN0aW9uIHN0YWNrR2V0KGtleSkge1xuICByZXR1cm4gdGhpcy5fX2RhdGFfXy5nZXQoa2V5KTtcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYSBzdGFjayB2YWx1ZSBmb3IgYGtleWAgZXhpc3RzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBoYXNcbiAqIEBtZW1iZXJPZiBTdGFja1xuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBlbnRyeSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBhbiBlbnRyeSBmb3IgYGtleWAgZXhpc3RzLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIHN0YWNrSGFzKGtleSkge1xuICByZXR1cm4gdGhpcy5fX2RhdGFfXy5oYXMoa2V5KTtcbn1cblxuLyoqXG4gKiBTZXRzIHRoZSBzdGFjayBga2V5YCB0byBgdmFsdWVgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBzZXRcbiAqIEBtZW1iZXJPZiBTdGFja1xuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBzZXQuXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBzZXQuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBzdGFjayBjYWNoZSBpbnN0YW5jZS5cbiAqL1xuZnVuY3Rpb24gc3RhY2tTZXQoa2V5LCB2YWx1ZSkge1xuICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX187XG4gIGlmIChkYXRhIGluc3RhbmNlb2YgTGlzdENhY2hlKSB7XG4gICAgdmFyIHBhaXJzID0gZGF0YS5fX2RhdGFfXztcbiAgICBpZiAoIU1hcCB8fCAocGFpcnMubGVuZ3RoIDwgTEFSR0VfQVJSQVlfU0laRSAtIDEpKSB7XG4gICAgICBwYWlycy5wdXNoKFtrZXksIHZhbHVlXSk7XG4gICAgICB0aGlzLnNpemUgPSArK2RhdGEuc2l6ZTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBkYXRhID0gdGhpcy5fX2RhdGFfXyA9IG5ldyBNYXBDYWNoZShwYWlycyk7XG4gIH1cbiAgZGF0YS5zZXQoa2V5LCB2YWx1ZSk7XG4gIHRoaXMuc2l6ZSA9IGRhdGEuc2l6ZTtcbiAgcmV0dXJuIHRoaXM7XG59XG5cbi8vIEFkZCBtZXRob2RzIHRvIGBTdGFja2AuXG5TdGFjay5wcm90b3R5cGUuY2xlYXIgPSBzdGFja0NsZWFyO1xuU3RhY2sucHJvdG90eXBlWydkZWxldGUnXSA9IHN0YWNrRGVsZXRlO1xuU3RhY2sucHJvdG90eXBlLmdldCA9IHN0YWNrR2V0O1xuU3RhY2sucHJvdG90eXBlLmhhcyA9IHN0YWNrSGFzO1xuU3RhY2sucHJvdG90eXBlLnNldCA9IHN0YWNrU2V0O1xuXG4vKipcbiAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgdGhlIGVudW1lcmFibGUgcHJvcGVydHkgbmFtZXMgb2YgdGhlIGFycmF5LWxpa2UgYHZhbHVlYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcXVlcnkuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IGluaGVyaXRlZCBTcGVjaWZ5IHJldHVybmluZyBpbmhlcml0ZWQgcHJvcGVydHkgbmFtZXMuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHByb3BlcnR5IG5hbWVzLlxuICovXG5mdW5jdGlvbiBhcnJheUxpa2VLZXlzKHZhbHVlLCBpbmhlcml0ZWQpIHtcbiAgdmFyIGlzQXJyID0gaXNBcnJheSh2YWx1ZSksXG4gICAgICBpc0FyZyA9ICFpc0FyciAmJiBpc0FyZ3VtZW50cyh2YWx1ZSksXG4gICAgICBpc0J1ZmYgPSAhaXNBcnIgJiYgIWlzQXJnICYmIGlzQnVmZmVyKHZhbHVlKSxcbiAgICAgIGlzVHlwZSA9ICFpc0FyciAmJiAhaXNBcmcgJiYgIWlzQnVmZiAmJiBpc1R5cGVkQXJyYXkodmFsdWUpLFxuICAgICAgc2tpcEluZGV4ZXMgPSBpc0FyciB8fCBpc0FyZyB8fCBpc0J1ZmYgfHwgaXNUeXBlLFxuICAgICAgcmVzdWx0ID0gc2tpcEluZGV4ZXMgPyBiYXNlVGltZXModmFsdWUubGVuZ3RoLCBTdHJpbmcpIDogW10sXG4gICAgICBsZW5ndGggPSByZXN1bHQubGVuZ3RoO1xuXG4gIGZvciAodmFyIGtleSBpbiB2YWx1ZSkge1xuICAgIGlmICgoaW5oZXJpdGVkIHx8IGhhc093blByb3BlcnR5LmNhbGwodmFsdWUsIGtleSkpICYmXG4gICAgICAgICEoc2tpcEluZGV4ZXMgJiYgKFxuICAgICAgICAgICAvLyBTYWZhcmkgOSBoYXMgZW51bWVyYWJsZSBgYXJndW1lbnRzLmxlbmd0aGAgaW4gc3RyaWN0IG1vZGUuXG4gICAgICAgICAgIGtleSA9PSAnbGVuZ3RoJyB8fFxuICAgICAgICAgICAvLyBOb2RlLmpzIDAuMTAgaGFzIGVudW1lcmFibGUgbm9uLWluZGV4IHByb3BlcnRpZXMgb24gYnVmZmVycy5cbiAgICAgICAgICAgKGlzQnVmZiAmJiAoa2V5ID09ICdvZmZzZXQnIHx8IGtleSA9PSAncGFyZW50JykpIHx8XG4gICAgICAgICAgIC8vIFBoYW50b21KUyAyIGhhcyBlbnVtZXJhYmxlIG5vbi1pbmRleCBwcm9wZXJ0aWVzIG9uIHR5cGVkIGFycmF5cy5cbiAgICAgICAgICAgKGlzVHlwZSAmJiAoa2V5ID09ICdidWZmZXInIHx8IGtleSA9PSAnYnl0ZUxlbmd0aCcgfHwga2V5ID09ICdieXRlT2Zmc2V0JykpIHx8XG4gICAgICAgICAgIC8vIFNraXAgaW5kZXggcHJvcGVydGllcy5cbiAgICAgICAgICAgaXNJbmRleChrZXksIGxlbmd0aClcbiAgICAgICAgKSkpIHtcbiAgICAgIHJlc3VsdC5wdXNoKGtleSk7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbi8qKlxuICogR2V0cyB0aGUgaW5kZXggYXQgd2hpY2ggdGhlIGBrZXlgIGlzIGZvdW5kIGluIGBhcnJheWAgb2Yga2V5LXZhbHVlIHBhaXJzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaW5zcGVjdC5cbiAqIEBwYXJhbSB7Kn0ga2V5IFRoZSBrZXkgdG8gc2VhcmNoIGZvci5cbiAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIGluZGV4IG9mIHRoZSBtYXRjaGVkIHZhbHVlLCBlbHNlIGAtMWAuXG4gKi9cbmZ1bmN0aW9uIGFzc29jSW5kZXhPZihhcnJheSwga2V5KSB7XG4gIHZhciBsZW5ndGggPSBhcnJheS5sZW5ndGg7XG4gIHdoaWxlIChsZW5ndGgtLSkge1xuICAgIGlmIChlcShhcnJheVtsZW5ndGhdWzBdLCBrZXkpKSB7XG4gICAgICByZXR1cm4gbGVuZ3RoO1xuICAgIH1cbiAgfVxuICByZXR1cm4gLTE7XG59XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYGdldEFsbEtleXNgIGFuZCBgZ2V0QWxsS2V5c0luYCB3aGljaCB1c2VzXG4gKiBga2V5c0Z1bmNgIGFuZCBgc3ltYm9sc0Z1bmNgIHRvIGdldCB0aGUgZW51bWVyYWJsZSBwcm9wZXJ0eSBuYW1lcyBhbmRcbiAqIHN5bWJvbHMgb2YgYG9iamVjdGAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGtleXNGdW5jIFRoZSBmdW5jdGlvbiB0byBnZXQgdGhlIGtleXMgb2YgYG9iamVjdGAuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBzeW1ib2xzRnVuYyBUaGUgZnVuY3Rpb24gdG8gZ2V0IHRoZSBzeW1ib2xzIG9mIGBvYmplY3RgLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBwcm9wZXJ0eSBuYW1lcyBhbmQgc3ltYm9scy5cbiAqL1xuZnVuY3Rpb24gYmFzZUdldEFsbEtleXMob2JqZWN0LCBrZXlzRnVuYywgc3ltYm9sc0Z1bmMpIHtcbiAgdmFyIHJlc3VsdCA9IGtleXNGdW5jKG9iamVjdCk7XG4gIHJldHVybiBpc0FycmF5KG9iamVjdCkgPyByZXN1bHQgOiBhcnJheVB1c2gocmVzdWx0LCBzeW1ib2xzRnVuYyhvYmplY3QpKTtcbn1cblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgZ2V0VGFnYCB3aXRob3V0IGZhbGxiYWNrcyBmb3IgYnVnZ3kgZW52aXJvbm1lbnRzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIGB0b1N0cmluZ1RhZ2AuXG4gKi9cbmZ1bmN0aW9uIGJhc2VHZXRUYWcodmFsdWUpIHtcbiAgaWYgKHZhbHVlID09IG51bGwpIHtcbiAgICByZXR1cm4gdmFsdWUgPT09IHVuZGVmaW5lZCA/IHVuZGVmaW5lZFRhZyA6IG51bGxUYWc7XG4gIH1cbiAgcmV0dXJuIChzeW1Ub1N0cmluZ1RhZyAmJiBzeW1Ub1N0cmluZ1RhZyBpbiBPYmplY3QodmFsdWUpKVxuICAgID8gZ2V0UmF3VGFnKHZhbHVlKVxuICAgIDogb2JqZWN0VG9TdHJpbmcodmFsdWUpO1xufVxuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmlzQXJndW1lbnRzYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhbiBgYXJndW1lbnRzYCBvYmplY3QsXG4gKi9cbmZ1bmN0aW9uIGJhc2VJc0FyZ3VtZW50cyh2YWx1ZSkge1xuICByZXR1cm4gaXNPYmplY3RMaWtlKHZhbHVlKSAmJiBiYXNlR2V0VGFnKHZhbHVlKSA9PSBhcmdzVGFnO1xufVxuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmlzRXF1YWxgIHdoaWNoIHN1cHBvcnRzIHBhcnRpYWwgY29tcGFyaXNvbnNcbiAqIGFuZCB0cmFja3MgdHJhdmVyc2VkIG9iamVjdHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNvbXBhcmUuXG4gKiBAcGFyYW0geyp9IG90aGVyIFRoZSBvdGhlciB2YWx1ZSB0byBjb21wYXJlLlxuICogQHBhcmFtIHtib29sZWFufSBiaXRtYXNrIFRoZSBiaXRtYXNrIGZsYWdzLlxuICogIDEgLSBVbm9yZGVyZWQgY29tcGFyaXNvblxuICogIDIgLSBQYXJ0aWFsIGNvbXBhcmlzb25cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjdXN0b21pemVyXSBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIGNvbXBhcmlzb25zLlxuICogQHBhcmFtIHtPYmplY3R9IFtzdGFja10gVHJhY2tzIHRyYXZlcnNlZCBgdmFsdWVgIGFuZCBgb3RoZXJgIG9iamVjdHMuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIHZhbHVlcyBhcmUgZXF1aXZhbGVudCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBiYXNlSXNFcXVhbCh2YWx1ZSwgb3RoZXIsIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIHN0YWNrKSB7XG4gIGlmICh2YWx1ZSA9PT0gb3RoZXIpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBpZiAodmFsdWUgPT0gbnVsbCB8fCBvdGhlciA9PSBudWxsIHx8ICghaXNPYmplY3RMaWtlKHZhbHVlKSAmJiAhaXNPYmplY3RMaWtlKG90aGVyKSkpIHtcbiAgICByZXR1cm4gdmFsdWUgIT09IHZhbHVlICYmIG90aGVyICE9PSBvdGhlcjtcbiAgfVxuICByZXR1cm4gYmFzZUlzRXF1YWxEZWVwKHZhbHVlLCBvdGhlciwgYml0bWFzaywgY3VzdG9taXplciwgYmFzZUlzRXF1YWwsIHN0YWNrKTtcbn1cblxuLyoqXG4gKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYGJhc2VJc0VxdWFsYCBmb3IgYXJyYXlzIGFuZCBvYmplY3RzIHdoaWNoIHBlcmZvcm1zXG4gKiBkZWVwIGNvbXBhcmlzb25zIGFuZCB0cmFja3MgdHJhdmVyc2VkIG9iamVjdHMgZW5hYmxpbmcgb2JqZWN0cyB3aXRoIGNpcmN1bGFyXG4gKiByZWZlcmVuY2VzIHRvIGJlIGNvbXBhcmVkLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gY29tcGFyZS5cbiAqIEBwYXJhbSB7T2JqZWN0fSBvdGhlciBUaGUgb3RoZXIgb2JqZWN0IHRvIGNvbXBhcmUuXG4gKiBAcGFyYW0ge251bWJlcn0gYml0bWFzayBUaGUgYml0bWFzayBmbGFncy4gU2VlIGBiYXNlSXNFcXVhbGAgZm9yIG1vcmUgZGV0YWlscy5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGN1c3RvbWl6ZXIgVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBjb21wYXJpc29ucy5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGVxdWFsRnVuYyBUaGUgZnVuY3Rpb24gdG8gZGV0ZXJtaW5lIGVxdWl2YWxlbnRzIG9mIHZhbHVlcy5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbc3RhY2tdIFRyYWNrcyB0cmF2ZXJzZWQgYG9iamVjdGAgYW5kIGBvdGhlcmAgb2JqZWN0cy5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgb2JqZWN0cyBhcmUgZXF1aXZhbGVudCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBiYXNlSXNFcXVhbERlZXAob2JqZWN0LCBvdGhlciwgYml0bWFzaywgY3VzdG9taXplciwgZXF1YWxGdW5jLCBzdGFjaykge1xuICB2YXIgb2JqSXNBcnIgPSBpc0FycmF5KG9iamVjdCksXG4gICAgICBvdGhJc0FyciA9IGlzQXJyYXkob3RoZXIpLFxuICAgICAgb2JqVGFnID0gb2JqSXNBcnIgPyBhcnJheVRhZyA6IGdldFRhZyhvYmplY3QpLFxuICAgICAgb3RoVGFnID0gb3RoSXNBcnIgPyBhcnJheVRhZyA6IGdldFRhZyhvdGhlcik7XG5cbiAgb2JqVGFnID0gb2JqVGFnID09IGFyZ3NUYWcgPyBvYmplY3RUYWcgOiBvYmpUYWc7XG4gIG90aFRhZyA9IG90aFRhZyA9PSBhcmdzVGFnID8gb2JqZWN0VGFnIDogb3RoVGFnO1xuXG4gIHZhciBvYmpJc09iaiA9IG9ialRhZyA9PSBvYmplY3RUYWcsXG4gICAgICBvdGhJc09iaiA9IG90aFRhZyA9PSBvYmplY3RUYWcsXG4gICAgICBpc1NhbWVUYWcgPSBvYmpUYWcgPT0gb3RoVGFnO1xuXG4gIGlmIChpc1NhbWVUYWcgJiYgaXNCdWZmZXIob2JqZWN0KSkge1xuICAgIGlmICghaXNCdWZmZXIob3RoZXIpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIG9iaklzQXJyID0gdHJ1ZTtcbiAgICBvYmpJc09iaiA9IGZhbHNlO1xuICB9XG4gIGlmIChpc1NhbWVUYWcgJiYgIW9iaklzT2JqKSB7XG4gICAgc3RhY2sgfHwgKHN0YWNrID0gbmV3IFN0YWNrKTtcbiAgICByZXR1cm4gKG9iaklzQXJyIHx8IGlzVHlwZWRBcnJheShvYmplY3QpKVxuICAgICAgPyBlcXVhbEFycmF5cyhvYmplY3QsIG90aGVyLCBiaXRtYXNrLCBjdXN0b21pemVyLCBlcXVhbEZ1bmMsIHN0YWNrKVxuICAgICAgOiBlcXVhbEJ5VGFnKG9iamVjdCwgb3RoZXIsIG9ialRhZywgYml0bWFzaywgY3VzdG9taXplciwgZXF1YWxGdW5jLCBzdGFjayk7XG4gIH1cbiAgaWYgKCEoYml0bWFzayAmIENPTVBBUkVfUEFSVElBTF9GTEFHKSkge1xuICAgIHZhciBvYmpJc1dyYXBwZWQgPSBvYmpJc09iaiAmJiBoYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwgJ19fd3JhcHBlZF9fJyksXG4gICAgICAgIG90aElzV3JhcHBlZCA9IG90aElzT2JqICYmIGhhc093blByb3BlcnR5LmNhbGwob3RoZXIsICdfX3dyYXBwZWRfXycpO1xuXG4gICAgaWYgKG9iaklzV3JhcHBlZCB8fCBvdGhJc1dyYXBwZWQpIHtcbiAgICAgIHZhciBvYmpVbndyYXBwZWQgPSBvYmpJc1dyYXBwZWQgPyBvYmplY3QudmFsdWUoKSA6IG9iamVjdCxcbiAgICAgICAgICBvdGhVbndyYXBwZWQgPSBvdGhJc1dyYXBwZWQgPyBvdGhlci52YWx1ZSgpIDogb3RoZXI7XG5cbiAgICAgIHN0YWNrIHx8IChzdGFjayA9IG5ldyBTdGFjayk7XG4gICAgICByZXR1cm4gZXF1YWxGdW5jKG9ialVud3JhcHBlZCwgb3RoVW53cmFwcGVkLCBiaXRtYXNrLCBjdXN0b21pemVyLCBzdGFjayk7XG4gICAgfVxuICB9XG4gIGlmICghaXNTYW1lVGFnKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHN0YWNrIHx8IChzdGFjayA9IG5ldyBTdGFjayk7XG4gIHJldHVybiBlcXVhbE9iamVjdHMob2JqZWN0LCBvdGhlciwgYml0bWFzaywgY3VzdG9taXplciwgZXF1YWxGdW5jLCBzdGFjayk7XG59XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uaXNOYXRpdmVgIHdpdGhvdXQgYmFkIHNoaW0gY2hlY2tzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgbmF0aXZlIGZ1bmN0aW9uLFxuICogIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gYmFzZUlzTmF0aXZlKHZhbHVlKSB7XG4gIGlmICghaXNPYmplY3QodmFsdWUpIHx8IGlzTWFza2VkKHZhbHVlKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICB2YXIgcGF0dGVybiA9IGlzRnVuY3Rpb24odmFsdWUpID8gcmVJc05hdGl2ZSA6IHJlSXNIb3N0Q3RvcjtcbiAgcmV0dXJuIHBhdHRlcm4udGVzdCh0b1NvdXJjZSh2YWx1ZSkpO1xufVxuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmlzVHlwZWRBcnJheWAgd2l0aG91dCBOb2RlLmpzIG9wdGltaXphdGlvbnMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSB0eXBlZCBhcnJheSwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBiYXNlSXNUeXBlZEFycmF5KHZhbHVlKSB7XG4gIHJldHVybiBpc09iamVjdExpa2UodmFsdWUpICYmXG4gICAgaXNMZW5ndGgodmFsdWUubGVuZ3RoKSAmJiAhIXR5cGVkQXJyYXlUYWdzW2Jhc2VHZXRUYWcodmFsdWUpXTtcbn1cblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5rZXlzYCB3aGljaCBkb2Vzbid0IHRyZWF0IHNwYXJzZSBhcnJheXMgYXMgZGVuc2UuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgbmFtZXMuXG4gKi9cbmZ1bmN0aW9uIGJhc2VLZXlzKG9iamVjdCkge1xuICBpZiAoIWlzUHJvdG90eXBlKG9iamVjdCkpIHtcbiAgICByZXR1cm4gbmF0aXZlS2V5cyhvYmplY3QpO1xuICB9XG4gIHZhciByZXN1bHQgPSBbXTtcbiAgZm9yICh2YXIga2V5IGluIE9iamVjdChvYmplY3QpKSB7XG4gICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBrZXkpICYmIGtleSAhPSAnY29uc3RydWN0b3InKSB7XG4gICAgICByZXN1bHQucHVzaChrZXkpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG4vKipcbiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgYmFzZUlzRXF1YWxEZWVwYCBmb3IgYXJyYXlzIHdpdGggc3VwcG9ydCBmb3JcbiAqIHBhcnRpYWwgZGVlcCBjb21wYXJpc29ucy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGNvbXBhcmUuXG4gKiBAcGFyYW0ge0FycmF5fSBvdGhlciBUaGUgb3RoZXIgYXJyYXkgdG8gY29tcGFyZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBiaXRtYXNrIFRoZSBiaXRtYXNrIGZsYWdzLiBTZWUgYGJhc2VJc0VxdWFsYCBmb3IgbW9yZSBkZXRhaWxzLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gY3VzdG9taXplciBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIGNvbXBhcmlzb25zLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZXF1YWxGdW5jIFRoZSBmdW5jdGlvbiB0byBkZXRlcm1pbmUgZXF1aXZhbGVudHMgb2YgdmFsdWVzLlxuICogQHBhcmFtIHtPYmplY3R9IHN0YWNrIFRyYWNrcyB0cmF2ZXJzZWQgYGFycmF5YCBhbmQgYG90aGVyYCBvYmplY3RzLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBhcnJheXMgYXJlIGVxdWl2YWxlbnQsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gZXF1YWxBcnJheXMoYXJyYXksIG90aGVyLCBiaXRtYXNrLCBjdXN0b21pemVyLCBlcXVhbEZ1bmMsIHN0YWNrKSB7XG4gIHZhciBpc1BhcnRpYWwgPSBiaXRtYXNrICYgQ09NUEFSRV9QQVJUSUFMX0ZMQUcsXG4gICAgICBhcnJMZW5ndGggPSBhcnJheS5sZW5ndGgsXG4gICAgICBvdGhMZW5ndGggPSBvdGhlci5sZW5ndGg7XG5cbiAgaWYgKGFyckxlbmd0aCAhPSBvdGhMZW5ndGggJiYgIShpc1BhcnRpYWwgJiYgb3RoTGVuZ3RoID4gYXJyTGVuZ3RoKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICAvLyBBc3N1bWUgY3ljbGljIHZhbHVlcyBhcmUgZXF1YWwuXG4gIHZhciBzdGFja2VkID0gc3RhY2suZ2V0KGFycmF5KTtcbiAgaWYgKHN0YWNrZWQgJiYgc3RhY2suZ2V0KG90aGVyKSkge1xuICAgIHJldHVybiBzdGFja2VkID09IG90aGVyO1xuICB9XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgcmVzdWx0ID0gdHJ1ZSxcbiAgICAgIHNlZW4gPSAoYml0bWFzayAmIENPTVBBUkVfVU5PUkRFUkVEX0ZMQUcpID8gbmV3IFNldENhY2hlIDogdW5kZWZpbmVkO1xuXG4gIHN0YWNrLnNldChhcnJheSwgb3RoZXIpO1xuICBzdGFjay5zZXQob3RoZXIsIGFycmF5KTtcblxuICAvLyBJZ25vcmUgbm9uLWluZGV4IHByb3BlcnRpZXMuXG4gIHdoaWxlICgrK2luZGV4IDwgYXJyTGVuZ3RoKSB7XG4gICAgdmFyIGFyclZhbHVlID0gYXJyYXlbaW5kZXhdLFxuICAgICAgICBvdGhWYWx1ZSA9IG90aGVyW2luZGV4XTtcblxuICAgIGlmIChjdXN0b21pemVyKSB7XG4gICAgICB2YXIgY29tcGFyZWQgPSBpc1BhcnRpYWxcbiAgICAgICAgPyBjdXN0b21pemVyKG90aFZhbHVlLCBhcnJWYWx1ZSwgaW5kZXgsIG90aGVyLCBhcnJheSwgc3RhY2spXG4gICAgICAgIDogY3VzdG9taXplcihhcnJWYWx1ZSwgb3RoVmFsdWUsIGluZGV4LCBhcnJheSwgb3RoZXIsIHN0YWNrKTtcbiAgICB9XG4gICAgaWYgKGNvbXBhcmVkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGlmIChjb21wYXJlZCkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIHJlc3VsdCA9IGZhbHNlO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIC8vIFJlY3Vyc2l2ZWx5IGNvbXBhcmUgYXJyYXlzIChzdXNjZXB0aWJsZSB0byBjYWxsIHN0YWNrIGxpbWl0cykuXG4gICAgaWYgKHNlZW4pIHtcbiAgICAgIGlmICghYXJyYXlTb21lKG90aGVyLCBmdW5jdGlvbihvdGhWYWx1ZSwgb3RoSW5kZXgpIHtcbiAgICAgICAgICAgIGlmICghY2FjaGVIYXMoc2Vlbiwgb3RoSW5kZXgpICYmXG4gICAgICAgICAgICAgICAgKGFyclZhbHVlID09PSBvdGhWYWx1ZSB8fCBlcXVhbEZ1bmMoYXJyVmFsdWUsIG90aFZhbHVlLCBiaXRtYXNrLCBjdXN0b21pemVyLCBzdGFjaykpKSB7XG4gICAgICAgICAgICAgIHJldHVybiBzZWVuLnB1c2gob3RoSW5kZXgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pKSB7XG4gICAgICAgIHJlc3VsdCA9IGZhbHNlO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKCEoXG4gICAgICAgICAgYXJyVmFsdWUgPT09IG90aFZhbHVlIHx8XG4gICAgICAgICAgICBlcXVhbEZ1bmMoYXJyVmFsdWUsIG90aFZhbHVlLCBiaXRtYXNrLCBjdXN0b21pemVyLCBzdGFjaylcbiAgICAgICAgKSkge1xuICAgICAgcmVzdWx0ID0gZmFsc2U7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cbiAgc3RhY2tbJ2RlbGV0ZSddKGFycmF5KTtcbiAgc3RhY2tbJ2RlbGV0ZSddKG90aGVyKTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqXG4gKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYGJhc2VJc0VxdWFsRGVlcGAgZm9yIGNvbXBhcmluZyBvYmplY3RzIG9mXG4gKiB0aGUgc2FtZSBgdG9TdHJpbmdUYWdgLlxuICpcbiAqICoqTm90ZToqKiBUaGlzIGZ1bmN0aW9uIG9ubHkgc3VwcG9ydHMgY29tcGFyaW5nIHZhbHVlcyB3aXRoIHRhZ3Mgb2ZcbiAqIGBCb29sZWFuYCwgYERhdGVgLCBgRXJyb3JgLCBgTnVtYmVyYCwgYFJlZ0V4cGAsIG9yIGBTdHJpbmdgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gY29tcGFyZS5cbiAqIEBwYXJhbSB7T2JqZWN0fSBvdGhlciBUaGUgb3RoZXIgb2JqZWN0IHRvIGNvbXBhcmUuXG4gKiBAcGFyYW0ge3N0cmluZ30gdGFnIFRoZSBgdG9TdHJpbmdUYWdgIG9mIHRoZSBvYmplY3RzIHRvIGNvbXBhcmUuXG4gKiBAcGFyYW0ge251bWJlcn0gYml0bWFzayBUaGUgYml0bWFzayBmbGFncy4gU2VlIGBiYXNlSXNFcXVhbGAgZm9yIG1vcmUgZGV0YWlscy5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGN1c3RvbWl6ZXIgVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBjb21wYXJpc29ucy5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGVxdWFsRnVuYyBUaGUgZnVuY3Rpb24gdG8gZGV0ZXJtaW5lIGVxdWl2YWxlbnRzIG9mIHZhbHVlcy5cbiAqIEBwYXJhbSB7T2JqZWN0fSBzdGFjayBUcmFja3MgdHJhdmVyc2VkIGBvYmplY3RgIGFuZCBgb3RoZXJgIG9iamVjdHMuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIG9iamVjdHMgYXJlIGVxdWl2YWxlbnQsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gZXF1YWxCeVRhZyhvYmplY3QsIG90aGVyLCB0YWcsIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIGVxdWFsRnVuYywgc3RhY2spIHtcbiAgc3dpdGNoICh0YWcpIHtcbiAgICBjYXNlIGRhdGFWaWV3VGFnOlxuICAgICAgaWYgKChvYmplY3QuYnl0ZUxlbmd0aCAhPSBvdGhlci5ieXRlTGVuZ3RoKSB8fFxuICAgICAgICAgIChvYmplY3QuYnl0ZU9mZnNldCAhPSBvdGhlci5ieXRlT2Zmc2V0KSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICBvYmplY3QgPSBvYmplY3QuYnVmZmVyO1xuICAgICAgb3RoZXIgPSBvdGhlci5idWZmZXI7XG5cbiAgICBjYXNlIGFycmF5QnVmZmVyVGFnOlxuICAgICAgaWYgKChvYmplY3QuYnl0ZUxlbmd0aCAhPSBvdGhlci5ieXRlTGVuZ3RoKSB8fFxuICAgICAgICAgICFlcXVhbEZ1bmMobmV3IFVpbnQ4QXJyYXkob2JqZWN0KSwgbmV3IFVpbnQ4QXJyYXkob3RoZXIpKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICByZXR1cm4gdHJ1ZTtcblxuICAgIGNhc2UgYm9vbFRhZzpcbiAgICBjYXNlIGRhdGVUYWc6XG4gICAgY2FzZSBudW1iZXJUYWc6XG4gICAgICAvLyBDb2VyY2UgYm9vbGVhbnMgdG8gYDFgIG9yIGAwYCBhbmQgZGF0ZXMgdG8gbWlsbGlzZWNvbmRzLlxuICAgICAgLy8gSW52YWxpZCBkYXRlcyBhcmUgY29lcmNlZCB0byBgTmFOYC5cbiAgICAgIHJldHVybiBlcSgrb2JqZWN0LCArb3RoZXIpO1xuXG4gICAgY2FzZSBlcnJvclRhZzpcbiAgICAgIHJldHVybiBvYmplY3QubmFtZSA9PSBvdGhlci5uYW1lICYmIG9iamVjdC5tZXNzYWdlID09IG90aGVyLm1lc3NhZ2U7XG5cbiAgICBjYXNlIHJlZ2V4cFRhZzpcbiAgICBjYXNlIHN0cmluZ1RhZzpcbiAgICAgIC8vIENvZXJjZSByZWdleGVzIHRvIHN0cmluZ3MgYW5kIHRyZWF0IHN0cmluZ3MsIHByaW1pdGl2ZXMgYW5kIG9iamVjdHMsXG4gICAgICAvLyBhcyBlcXVhbC4gU2VlIGh0dHA6Ly93d3cuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1yZWdleHAucHJvdG90eXBlLnRvc3RyaW5nXG4gICAgICAvLyBmb3IgbW9yZSBkZXRhaWxzLlxuICAgICAgcmV0dXJuIG9iamVjdCA9PSAob3RoZXIgKyAnJyk7XG5cbiAgICBjYXNlIG1hcFRhZzpcbiAgICAgIHZhciBjb252ZXJ0ID0gbWFwVG9BcnJheTtcblxuICAgIGNhc2Ugc2V0VGFnOlxuICAgICAgdmFyIGlzUGFydGlhbCA9IGJpdG1hc2sgJiBDT01QQVJFX1BBUlRJQUxfRkxBRztcbiAgICAgIGNvbnZlcnQgfHwgKGNvbnZlcnQgPSBzZXRUb0FycmF5KTtcblxuICAgICAgaWYgKG9iamVjdC5zaXplICE9IG90aGVyLnNpemUgJiYgIWlzUGFydGlhbCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICAvLyBBc3N1bWUgY3ljbGljIHZhbHVlcyBhcmUgZXF1YWwuXG4gICAgICB2YXIgc3RhY2tlZCA9IHN0YWNrLmdldChvYmplY3QpO1xuICAgICAgaWYgKHN0YWNrZWQpIHtcbiAgICAgICAgcmV0dXJuIHN0YWNrZWQgPT0gb3RoZXI7XG4gICAgICB9XG4gICAgICBiaXRtYXNrIHw9IENPTVBBUkVfVU5PUkRFUkVEX0ZMQUc7XG5cbiAgICAgIC8vIFJlY3Vyc2l2ZWx5IGNvbXBhcmUgb2JqZWN0cyAoc3VzY2VwdGlibGUgdG8gY2FsbCBzdGFjayBsaW1pdHMpLlxuICAgICAgc3RhY2suc2V0KG9iamVjdCwgb3RoZXIpO1xuICAgICAgdmFyIHJlc3VsdCA9IGVxdWFsQXJyYXlzKGNvbnZlcnQob2JqZWN0KSwgY29udmVydChvdGhlciksIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIGVxdWFsRnVuYywgc3RhY2spO1xuICAgICAgc3RhY2tbJ2RlbGV0ZSddKG9iamVjdCk7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuXG4gICAgY2FzZSBzeW1ib2xUYWc6XG4gICAgICBpZiAoc3ltYm9sVmFsdWVPZikge1xuICAgICAgICByZXR1cm4gc3ltYm9sVmFsdWVPZi5jYWxsKG9iamVjdCkgPT0gc3ltYm9sVmFsdWVPZi5jYWxsKG90aGVyKTtcbiAgICAgIH1cbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5cbi8qKlxuICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBiYXNlSXNFcXVhbERlZXBgIGZvciBvYmplY3RzIHdpdGggc3VwcG9ydCBmb3JcbiAqIHBhcnRpYWwgZGVlcCBjb21wYXJpc29ucy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGNvbXBhcmUuXG4gKiBAcGFyYW0ge09iamVjdH0gb3RoZXIgVGhlIG90aGVyIG9iamVjdCB0byBjb21wYXJlLlxuICogQHBhcmFtIHtudW1iZXJ9IGJpdG1hc2sgVGhlIGJpdG1hc2sgZmxhZ3MuIFNlZSBgYmFzZUlzRXF1YWxgIGZvciBtb3JlIGRldGFpbHMuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjdXN0b21pemVyIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgY29tcGFyaXNvbnMuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBlcXVhbEZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGRldGVybWluZSBlcXVpdmFsZW50cyBvZiB2YWx1ZXMuXG4gKiBAcGFyYW0ge09iamVjdH0gc3RhY2sgVHJhY2tzIHRyYXZlcnNlZCBgb2JqZWN0YCBhbmQgYG90aGVyYCBvYmplY3RzLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBvYmplY3RzIGFyZSBlcXVpdmFsZW50LCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGVxdWFsT2JqZWN0cyhvYmplY3QsIG90aGVyLCBiaXRtYXNrLCBjdXN0b21pemVyLCBlcXVhbEZ1bmMsIHN0YWNrKSB7XG4gIHZhciBpc1BhcnRpYWwgPSBiaXRtYXNrICYgQ09NUEFSRV9QQVJUSUFMX0ZMQUcsXG4gICAgICBvYmpQcm9wcyA9IGdldEFsbEtleXMob2JqZWN0KSxcbiAgICAgIG9iakxlbmd0aCA9IG9ialByb3BzLmxlbmd0aCxcbiAgICAgIG90aFByb3BzID0gZ2V0QWxsS2V5cyhvdGhlciksXG4gICAgICBvdGhMZW5ndGggPSBvdGhQcm9wcy5sZW5ndGg7XG5cbiAgaWYgKG9iakxlbmd0aCAhPSBvdGhMZW5ndGggJiYgIWlzUGFydGlhbCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICB2YXIgaW5kZXggPSBvYmpMZW5ndGg7XG4gIHdoaWxlIChpbmRleC0tKSB7XG4gICAgdmFyIGtleSA9IG9ialByb3BzW2luZGV4XTtcbiAgICBpZiAoIShpc1BhcnRpYWwgPyBrZXkgaW4gb3RoZXIgOiBoYXNPd25Qcm9wZXJ0eS5jYWxsKG90aGVyLCBrZXkpKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuICAvLyBBc3N1bWUgY3ljbGljIHZhbHVlcyBhcmUgZXF1YWwuXG4gIHZhciBzdGFja2VkID0gc3RhY2suZ2V0KG9iamVjdCk7XG4gIGlmIChzdGFja2VkICYmIHN0YWNrLmdldChvdGhlcikpIHtcbiAgICByZXR1cm4gc3RhY2tlZCA9PSBvdGhlcjtcbiAgfVxuICB2YXIgcmVzdWx0ID0gdHJ1ZTtcbiAgc3RhY2suc2V0KG9iamVjdCwgb3RoZXIpO1xuICBzdGFjay5zZXQob3RoZXIsIG9iamVjdCk7XG5cbiAgdmFyIHNraXBDdG9yID0gaXNQYXJ0aWFsO1xuICB3aGlsZSAoKytpbmRleCA8IG9iakxlbmd0aCkge1xuICAgIGtleSA9IG9ialByb3BzW2luZGV4XTtcbiAgICB2YXIgb2JqVmFsdWUgPSBvYmplY3Rba2V5XSxcbiAgICAgICAgb3RoVmFsdWUgPSBvdGhlcltrZXldO1xuXG4gICAgaWYgKGN1c3RvbWl6ZXIpIHtcbiAgICAgIHZhciBjb21wYXJlZCA9IGlzUGFydGlhbFxuICAgICAgICA/IGN1c3RvbWl6ZXIob3RoVmFsdWUsIG9ialZhbHVlLCBrZXksIG90aGVyLCBvYmplY3QsIHN0YWNrKVxuICAgICAgICA6IGN1c3RvbWl6ZXIob2JqVmFsdWUsIG90aFZhbHVlLCBrZXksIG9iamVjdCwgb3RoZXIsIHN0YWNrKTtcbiAgICB9XG4gICAgLy8gUmVjdXJzaXZlbHkgY29tcGFyZSBvYmplY3RzIChzdXNjZXB0aWJsZSB0byBjYWxsIHN0YWNrIGxpbWl0cykuXG4gICAgaWYgKCEoY29tcGFyZWQgPT09IHVuZGVmaW5lZFxuICAgICAgICAgID8gKG9ialZhbHVlID09PSBvdGhWYWx1ZSB8fCBlcXVhbEZ1bmMob2JqVmFsdWUsIG90aFZhbHVlLCBiaXRtYXNrLCBjdXN0b21pemVyLCBzdGFjaykpXG4gICAgICAgICAgOiBjb21wYXJlZFxuICAgICAgICApKSB7XG4gICAgICByZXN1bHQgPSBmYWxzZTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBza2lwQ3RvciB8fCAoc2tpcEN0b3IgPSBrZXkgPT0gJ2NvbnN0cnVjdG9yJyk7XG4gIH1cbiAgaWYgKHJlc3VsdCAmJiAhc2tpcEN0b3IpIHtcbiAgICB2YXIgb2JqQ3RvciA9IG9iamVjdC5jb25zdHJ1Y3RvcixcbiAgICAgICAgb3RoQ3RvciA9IG90aGVyLmNvbnN0cnVjdG9yO1xuXG4gICAgLy8gTm9uIGBPYmplY3RgIG9iamVjdCBpbnN0YW5jZXMgd2l0aCBkaWZmZXJlbnQgY29uc3RydWN0b3JzIGFyZSBub3QgZXF1YWwuXG4gICAgaWYgKG9iakN0b3IgIT0gb3RoQ3RvciAmJlxuICAgICAgICAoJ2NvbnN0cnVjdG9yJyBpbiBvYmplY3QgJiYgJ2NvbnN0cnVjdG9yJyBpbiBvdGhlcikgJiZcbiAgICAgICAgISh0eXBlb2Ygb2JqQ3RvciA9PSAnZnVuY3Rpb24nICYmIG9iakN0b3IgaW5zdGFuY2VvZiBvYmpDdG9yICYmXG4gICAgICAgICAgdHlwZW9mIG90aEN0b3IgPT0gJ2Z1bmN0aW9uJyAmJiBvdGhDdG9yIGluc3RhbmNlb2Ygb3RoQ3RvcikpIHtcbiAgICAgIHJlc3VsdCA9IGZhbHNlO1xuICAgIH1cbiAgfVxuICBzdGFja1snZGVsZXRlJ10ob2JqZWN0KTtcbiAgc3RhY2tbJ2RlbGV0ZSddKG90aGVyKTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGFuIGFycmF5IG9mIG93biBlbnVtZXJhYmxlIHByb3BlcnR5IG5hbWVzIGFuZCBzeW1ib2xzIG9mIGBvYmplY3RgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHByb3BlcnR5IG5hbWVzIGFuZCBzeW1ib2xzLlxuICovXG5mdW5jdGlvbiBnZXRBbGxLZXlzKG9iamVjdCkge1xuICByZXR1cm4gYmFzZUdldEFsbEtleXMob2JqZWN0LCBrZXlzLCBnZXRTeW1ib2xzKTtcbn1cblxuLyoqXG4gKiBHZXRzIHRoZSBkYXRhIGZvciBgbWFwYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG1hcCBUaGUgbWFwIHRvIHF1ZXJ5LlxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUgcmVmZXJlbmNlIGtleS5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBtYXAgZGF0YS5cbiAqL1xuZnVuY3Rpb24gZ2V0TWFwRGF0YShtYXAsIGtleSkge1xuICB2YXIgZGF0YSA9IG1hcC5fX2RhdGFfXztcbiAgcmV0dXJuIGlzS2V5YWJsZShrZXkpXG4gICAgPyBkYXRhW3R5cGVvZiBrZXkgPT0gJ3N0cmluZycgPyAnc3RyaW5nJyA6ICdoYXNoJ11cbiAgICA6IGRhdGEubWFwO1xufVxuXG4vKipcbiAqIEdldHMgdGhlIG5hdGl2ZSBmdW5jdGlvbiBhdCBga2V5YCBvZiBgb2JqZWN0YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBtZXRob2QgdG8gZ2V0LlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGZ1bmN0aW9uIGlmIGl0J3MgbmF0aXZlLCBlbHNlIGB1bmRlZmluZWRgLlxuICovXG5mdW5jdGlvbiBnZXROYXRpdmUob2JqZWN0LCBrZXkpIHtcbiAgdmFyIHZhbHVlID0gZ2V0VmFsdWUob2JqZWN0LCBrZXkpO1xuICByZXR1cm4gYmFzZUlzTmF0aXZlKHZhbHVlKSA/IHZhbHVlIDogdW5kZWZpbmVkO1xufVxuXG4vKipcbiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgYmFzZUdldFRhZ2Agd2hpY2ggaWdub3JlcyBgU3ltYm9sLnRvU3RyaW5nVGFnYCB2YWx1ZXMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHF1ZXJ5LlxuICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgcmF3IGB0b1N0cmluZ1RhZ2AuXG4gKi9cbmZ1bmN0aW9uIGdldFJhd1RhZyh2YWx1ZSkge1xuICB2YXIgaXNPd24gPSBoYXNPd25Qcm9wZXJ0eS5jYWxsKHZhbHVlLCBzeW1Ub1N0cmluZ1RhZyksXG4gICAgICB0YWcgPSB2YWx1ZVtzeW1Ub1N0cmluZ1RhZ107XG5cbiAgdHJ5IHtcbiAgICB2YWx1ZVtzeW1Ub1N0cmluZ1RhZ10gPSB1bmRlZmluZWQ7XG4gICAgdmFyIHVubWFza2VkID0gdHJ1ZTtcbiAgfSBjYXRjaCAoZSkge31cblxuICB2YXIgcmVzdWx0ID0gbmF0aXZlT2JqZWN0VG9TdHJpbmcuY2FsbCh2YWx1ZSk7XG4gIGlmICh1bm1hc2tlZCkge1xuICAgIGlmIChpc093bikge1xuICAgICAgdmFsdWVbc3ltVG9TdHJpbmdUYWddID0gdGFnO1xuICAgIH0gZWxzZSB7XG4gICAgICBkZWxldGUgdmFsdWVbc3ltVG9TdHJpbmdUYWddO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG4vKipcbiAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgdGhlIG93biBlbnVtZXJhYmxlIHN5bWJvbHMgb2YgYG9iamVjdGAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2Ygc3ltYm9scy5cbiAqL1xudmFyIGdldFN5bWJvbHMgPSAhbmF0aXZlR2V0U3ltYm9scyA/IHN0dWJBcnJheSA6IGZ1bmN0aW9uKG9iamVjdCkge1xuICBpZiAob2JqZWN0ID09IG51bGwpIHtcbiAgICByZXR1cm4gW107XG4gIH1cbiAgb2JqZWN0ID0gT2JqZWN0KG9iamVjdCk7XG4gIHJldHVybiBhcnJheUZpbHRlcihuYXRpdmVHZXRTeW1ib2xzKG9iamVjdCksIGZ1bmN0aW9uKHN5bWJvbCkge1xuICAgIHJldHVybiBwcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKG9iamVjdCwgc3ltYm9sKTtcbiAgfSk7XG59O1xuXG4vKipcbiAqIEdldHMgdGhlIGB0b1N0cmluZ1RhZ2Agb2YgYHZhbHVlYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBgdG9TdHJpbmdUYWdgLlxuICovXG52YXIgZ2V0VGFnID0gYmFzZUdldFRhZztcblxuLy8gRmFsbGJhY2sgZm9yIGRhdGEgdmlld3MsIG1hcHMsIHNldHMsIGFuZCB3ZWFrIG1hcHMgaW4gSUUgMTEgYW5kIHByb21pc2VzIGluIE5vZGUuanMgPCA2LlxuaWYgKChEYXRhVmlldyAmJiBnZXRUYWcobmV3IERhdGFWaWV3KG5ldyBBcnJheUJ1ZmZlcigxKSkpICE9IGRhdGFWaWV3VGFnKSB8fFxuICAgIChNYXAgJiYgZ2V0VGFnKG5ldyBNYXApICE9IG1hcFRhZykgfHxcbiAgICAoUHJvbWlzZSAmJiBnZXRUYWcoUHJvbWlzZS5yZXNvbHZlKCkpICE9IHByb21pc2VUYWcpIHx8XG4gICAgKFNldCAmJiBnZXRUYWcobmV3IFNldCkgIT0gc2V0VGFnKSB8fFxuICAgIChXZWFrTWFwICYmIGdldFRhZyhuZXcgV2Vha01hcCkgIT0gd2Vha01hcFRhZykpIHtcbiAgZ2V0VGFnID0gZnVuY3Rpb24odmFsdWUpIHtcbiAgICB2YXIgcmVzdWx0ID0gYmFzZUdldFRhZyh2YWx1ZSksXG4gICAgICAgIEN0b3IgPSByZXN1bHQgPT0gb2JqZWN0VGFnID8gdmFsdWUuY29uc3RydWN0b3IgOiB1bmRlZmluZWQsXG4gICAgICAgIGN0b3JTdHJpbmcgPSBDdG9yID8gdG9Tb3VyY2UoQ3RvcikgOiAnJztcblxuICAgIGlmIChjdG9yU3RyaW5nKSB7XG4gICAgICBzd2l0Y2ggKGN0b3JTdHJpbmcpIHtcbiAgICAgICAgY2FzZSBkYXRhVmlld0N0b3JTdHJpbmc6IHJldHVybiBkYXRhVmlld1RhZztcbiAgICAgICAgY2FzZSBtYXBDdG9yU3RyaW5nOiByZXR1cm4gbWFwVGFnO1xuICAgICAgICBjYXNlIHByb21pc2VDdG9yU3RyaW5nOiByZXR1cm4gcHJvbWlzZVRhZztcbiAgICAgICAgY2FzZSBzZXRDdG9yU3RyaW5nOiByZXR1cm4gc2V0VGFnO1xuICAgICAgICBjYXNlIHdlYWtNYXBDdG9yU3RyaW5nOiByZXR1cm4gd2Vha01hcFRhZztcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhIHZhbGlkIGFycmF5LWxpa2UgaW5kZXguXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHBhcmFtIHtudW1iZXJ9IFtsZW5ndGg9TUFYX1NBRkVfSU5URUdFUl0gVGhlIHVwcGVyIGJvdW5kcyBvZiBhIHZhbGlkIGluZGV4LlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSB2YWxpZCBpbmRleCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBpc0luZGV4KHZhbHVlLCBsZW5ndGgpIHtcbiAgbGVuZ3RoID0gbGVuZ3RoID09IG51bGwgPyBNQVhfU0FGRV9JTlRFR0VSIDogbGVuZ3RoO1xuICByZXR1cm4gISFsZW5ndGggJiZcbiAgICAodHlwZW9mIHZhbHVlID09ICdudW1iZXInIHx8IHJlSXNVaW50LnRlc3QodmFsdWUpKSAmJlxuICAgICh2YWx1ZSA+IC0xICYmIHZhbHVlICUgMSA9PSAwICYmIHZhbHVlIDwgbGVuZ3RoKTtcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBzdWl0YWJsZSBmb3IgdXNlIGFzIHVuaXF1ZSBvYmplY3Qga2V5LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIHN1aXRhYmxlLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGlzS2V5YWJsZSh2YWx1ZSkge1xuICB2YXIgdHlwZSA9IHR5cGVvZiB2YWx1ZTtcbiAgcmV0dXJuICh0eXBlID09ICdzdHJpbmcnIHx8IHR5cGUgPT0gJ251bWJlcicgfHwgdHlwZSA9PSAnc3ltYm9sJyB8fCB0eXBlID09ICdib29sZWFuJylcbiAgICA/ICh2YWx1ZSAhPT0gJ19fcHJvdG9fXycpXG4gICAgOiAodmFsdWUgPT09IG51bGwpO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBgZnVuY2AgaGFzIGl0cyBzb3VyY2UgbWFza2VkLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgZnVuY2AgaXMgbWFza2VkLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGlzTWFza2VkKGZ1bmMpIHtcbiAgcmV0dXJuICEhbWFza1NyY0tleSAmJiAobWFza1NyY0tleSBpbiBmdW5jKTtcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBsaWtlbHkgYSBwcm90b3R5cGUgb2JqZWN0LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgcHJvdG90eXBlLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGlzUHJvdG90eXBlKHZhbHVlKSB7XG4gIHZhciBDdG9yID0gdmFsdWUgJiYgdmFsdWUuY29uc3RydWN0b3IsXG4gICAgICBwcm90byA9ICh0eXBlb2YgQ3RvciA9PSAnZnVuY3Rpb24nICYmIEN0b3IucHJvdG90eXBlKSB8fCBvYmplY3RQcm90bztcblxuICByZXR1cm4gdmFsdWUgPT09IHByb3RvO1xufVxuXG4vKipcbiAqIENvbnZlcnRzIGB2YWx1ZWAgdG8gYSBzdHJpbmcgdXNpbmcgYE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmdgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjb252ZXJ0LlxuICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgY29udmVydGVkIHN0cmluZy5cbiAqL1xuZnVuY3Rpb24gb2JqZWN0VG9TdHJpbmcodmFsdWUpIHtcbiAgcmV0dXJuIG5hdGl2ZU9iamVjdFRvU3RyaW5nLmNhbGwodmFsdWUpO1xufVxuXG4vKipcbiAqIENvbnZlcnRzIGBmdW5jYCB0byBpdHMgc291cmNlIGNvZGUuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGNvbnZlcnQuXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBzb3VyY2UgY29kZS5cbiAqL1xuZnVuY3Rpb24gdG9Tb3VyY2UoZnVuYykge1xuICBpZiAoZnVuYyAhPSBudWxsKSB7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBmdW5jVG9TdHJpbmcuY2FsbChmdW5jKTtcbiAgICB9IGNhdGNoIChlKSB7fVxuICAgIHRyeSB7XG4gICAgICByZXR1cm4gKGZ1bmMgKyAnJyk7XG4gICAgfSBjYXRjaCAoZSkge31cbiAgfVxuICByZXR1cm4gJyc7XG59XG5cbi8qKlxuICogUGVyZm9ybXMgYVxuICogW2BTYW1lVmFsdWVaZXJvYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtc2FtZXZhbHVlemVybylcbiAqIGNvbXBhcmlzb24gYmV0d2VlbiB0d28gdmFsdWVzIHRvIGRldGVybWluZSBpZiB0aGV5IGFyZSBlcXVpdmFsZW50LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjb21wYXJlLlxuICogQHBhcmFtIHsqfSBvdGhlciBUaGUgb3RoZXIgdmFsdWUgdG8gY29tcGFyZS5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgdmFsdWVzIGFyZSBlcXVpdmFsZW50LCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIHZhciBvYmplY3QgPSB7ICdhJzogMSB9O1xuICogdmFyIG90aGVyID0geyAnYSc6IDEgfTtcbiAqXG4gKiBfLmVxKG9iamVjdCwgb2JqZWN0KTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmVxKG9iamVjdCwgb3RoZXIpO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmVxKCdhJywgJ2EnKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmVxKCdhJywgT2JqZWN0KCdhJykpO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmVxKE5hTiwgTmFOKTtcbiAqIC8vID0+IHRydWVcbiAqL1xuZnVuY3Rpb24gZXEodmFsdWUsIG90aGVyKSB7XG4gIHJldHVybiB2YWx1ZSA9PT0gb3RoZXIgfHwgKHZhbHVlICE9PSB2YWx1ZSAmJiBvdGhlciAhPT0gb3RoZXIpO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGxpa2VseSBhbiBgYXJndW1lbnRzYCBvYmplY3QuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjEuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYW4gYGFyZ3VtZW50c2Agb2JqZWN0LFxuICogIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc0FyZ3VtZW50cyhmdW5jdGlvbigpIHsgcmV0dXJuIGFyZ3VtZW50czsgfSgpKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzQXJndW1lbnRzKFsxLCAyLCAzXSk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG52YXIgaXNBcmd1bWVudHMgPSBiYXNlSXNBcmd1bWVudHMoZnVuY3Rpb24oKSB7IHJldHVybiBhcmd1bWVudHM7IH0oKSkgPyBiYXNlSXNBcmd1bWVudHMgOiBmdW5jdGlvbih2YWx1ZSkge1xuICByZXR1cm4gaXNPYmplY3RMaWtlKHZhbHVlKSAmJiBoYXNPd25Qcm9wZXJ0eS5jYWxsKHZhbHVlLCAnY2FsbGVlJykgJiZcbiAgICAhcHJvcGVydHlJc0VudW1lcmFibGUuY2FsbCh2YWx1ZSwgJ2NhbGxlZScpO1xufTtcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBjbGFzc2lmaWVkIGFzIGFuIGBBcnJheWAgb2JqZWN0LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGFuIGFycmF5LCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNBcnJheShbMSwgMiwgM10pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNBcnJheShkb2N1bWVudC5ib2R5LmNoaWxkcmVuKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5pc0FycmF5KCdhYmMnKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5pc0FycmF5KF8ubm9vcCk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG52YXIgaXNBcnJheSA9IEFycmF5LmlzQXJyYXk7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYXJyYXktbGlrZS4gQSB2YWx1ZSBpcyBjb25zaWRlcmVkIGFycmF5LWxpa2UgaWYgaXQnc1xuICogbm90IGEgZnVuY3Rpb24gYW5kIGhhcyBhIGB2YWx1ZS5sZW5ndGhgIHRoYXQncyBhbiBpbnRlZ2VyIGdyZWF0ZXIgdGhhbiBvclxuICogZXF1YWwgdG8gYDBgIGFuZCBsZXNzIHRoYW4gb3IgZXF1YWwgdG8gYE51bWJlci5NQVhfU0FGRV9JTlRFR0VSYC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhcnJheS1saWtlLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNBcnJheUxpa2UoWzEsIDIsIDNdKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzQXJyYXlMaWtlKGRvY3VtZW50LmJvZHkuY2hpbGRyZW4pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNBcnJheUxpa2UoJ2FiYycpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNBcnJheUxpa2UoXy5ub29wKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzQXJyYXlMaWtlKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSAhPSBudWxsICYmIGlzTGVuZ3RoKHZhbHVlLmxlbmd0aCkgJiYgIWlzRnVuY3Rpb24odmFsdWUpO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGEgYnVmZmVyLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4zLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgYnVmZmVyLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNCdWZmZXIobmV3IEJ1ZmZlcigyKSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0J1ZmZlcihuZXcgVWludDhBcnJheSgyKSk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG52YXIgaXNCdWZmZXIgPSBuYXRpdmVJc0J1ZmZlciB8fCBzdHViRmFsc2U7XG5cbi8qKlxuICogUGVyZm9ybXMgYSBkZWVwIGNvbXBhcmlzb24gYmV0d2VlbiB0d28gdmFsdWVzIHRvIGRldGVybWluZSBpZiB0aGV5IGFyZVxuICogZXF1aXZhbGVudC5cbiAqXG4gKiAqKk5vdGU6KiogVGhpcyBtZXRob2Qgc3VwcG9ydHMgY29tcGFyaW5nIGFycmF5cywgYXJyYXkgYnVmZmVycywgYm9vbGVhbnMsXG4gKiBkYXRlIG9iamVjdHMsIGVycm9yIG9iamVjdHMsIG1hcHMsIG51bWJlcnMsIGBPYmplY3RgIG9iamVjdHMsIHJlZ2V4ZXMsXG4gKiBzZXRzLCBzdHJpbmdzLCBzeW1ib2xzLCBhbmQgdHlwZWQgYXJyYXlzLiBgT2JqZWN0YCBvYmplY3RzIGFyZSBjb21wYXJlZFxuICogYnkgdGhlaXIgb3duLCBub3QgaW5oZXJpdGVkLCBlbnVtZXJhYmxlIHByb3BlcnRpZXMuIEZ1bmN0aW9ucyBhbmQgRE9NXG4gKiBub2RlcyBhcmUgY29tcGFyZWQgYnkgc3RyaWN0IGVxdWFsaXR5LCBpLmUuIGA9PT1gLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjb21wYXJlLlxuICogQHBhcmFtIHsqfSBvdGhlciBUaGUgb3RoZXIgdmFsdWUgdG8gY29tcGFyZS5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgdmFsdWVzIGFyZSBlcXVpdmFsZW50LCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIHZhciBvYmplY3QgPSB7ICdhJzogMSB9O1xuICogdmFyIG90aGVyID0geyAnYSc6IDEgfTtcbiAqXG4gKiBfLmlzRXF1YWwob2JqZWN0LCBvdGhlcik7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogb2JqZWN0ID09PSBvdGhlcjtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzRXF1YWwodmFsdWUsIG90aGVyKSB7XG4gIHJldHVybiBiYXNlSXNFcXVhbCh2YWx1ZSwgb3RoZXIpO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGNsYXNzaWZpZWQgYXMgYSBgRnVuY3Rpb25gIG9iamVjdC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuMS4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIGZ1bmN0aW9uLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNGdW5jdGlvbihfKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzRnVuY3Rpb24oL2FiYy8pO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNGdW5jdGlvbih2YWx1ZSkge1xuICBpZiAoIWlzT2JqZWN0KHZhbHVlKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICAvLyBUaGUgdXNlIG9mIGBPYmplY3QjdG9TdHJpbmdgIGF2b2lkcyBpc3N1ZXMgd2l0aCB0aGUgYHR5cGVvZmAgb3BlcmF0b3JcbiAgLy8gaW4gU2FmYXJpIDkgd2hpY2ggcmV0dXJucyAnb2JqZWN0JyBmb3IgdHlwZWQgYXJyYXlzIGFuZCBvdGhlciBjb25zdHJ1Y3RvcnMuXG4gIHZhciB0YWcgPSBiYXNlR2V0VGFnKHZhbHVlKTtcbiAgcmV0dXJuIHRhZyA9PSBmdW5jVGFnIHx8IHRhZyA9PSBnZW5UYWcgfHwgdGFnID09IGFzeW5jVGFnIHx8IHRhZyA9PSBwcm94eVRhZztcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhIHZhbGlkIGFycmF5LWxpa2UgbGVuZ3RoLlxuICpcbiAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBpcyBsb29zZWx5IGJhc2VkIG9uXG4gKiBbYFRvTGVuZ3RoYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtdG9sZW5ndGgpLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgdmFsaWQgbGVuZ3RoLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNMZW5ndGgoMyk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0xlbmd0aChOdW1iZXIuTUlOX1ZBTFVFKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5pc0xlbmd0aChJbmZpbml0eSk7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uaXNMZW5ndGgoJzMnKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzTGVuZ3RoKHZhbHVlKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsdWUgPT0gJ251bWJlcicgJiZcbiAgICB2YWx1ZSA+IC0xICYmIHZhbHVlICUgMSA9PSAwICYmIHZhbHVlIDw9IE1BWF9TQUZFX0lOVEVHRVI7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgdGhlXG4gKiBbbGFuZ3VhZ2UgdHlwZV0oaHR0cDovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLWVjbWFzY3JpcHQtbGFuZ3VhZ2UtdHlwZXMpXG4gKiBvZiBgT2JqZWN0YC4gKGUuZy4gYXJyYXlzLCBmdW5jdGlvbnMsIG9iamVjdHMsIHJlZ2V4ZXMsIGBuZXcgTnVtYmVyKDApYCwgYW5kIGBuZXcgU3RyaW5nKCcnKWApXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjEuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYW4gb2JqZWN0LCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNPYmplY3Qoe30pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNPYmplY3QoWzEsIDIsIDNdKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzT2JqZWN0KF8ubm9vcCk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc09iamVjdChudWxsKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzT2JqZWN0KHZhbHVlKSB7XG4gIHZhciB0eXBlID0gdHlwZW9mIHZhbHVlO1xuICByZXR1cm4gdmFsdWUgIT0gbnVsbCAmJiAodHlwZSA9PSAnb2JqZWN0JyB8fCB0eXBlID09ICdmdW5jdGlvbicpO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIG9iamVjdC1saWtlLiBBIHZhbHVlIGlzIG9iamVjdC1saWtlIGlmIGl0J3Mgbm90IGBudWxsYFxuICogYW5kIGhhcyBhIGB0eXBlb2ZgIHJlc3VsdCBvZiBcIm9iamVjdFwiLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIG9iamVjdC1saWtlLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNPYmplY3RMaWtlKHt9KTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzT2JqZWN0TGlrZShbMSwgMiwgM10pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNPYmplY3RMaWtlKF8ubm9vcCk7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uaXNPYmplY3RMaWtlKG51bGwpO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNPYmplY3RMaWtlKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSAhPSBudWxsICYmIHR5cGVvZiB2YWx1ZSA9PSAnb2JqZWN0Jztcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBjbGFzc2lmaWVkIGFzIGEgdHlwZWQgYXJyYXkuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAzLjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSB0eXBlZCBhcnJheSwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzVHlwZWRBcnJheShuZXcgVWludDhBcnJheSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc1R5cGVkQXJyYXkoW10pO1xuICogLy8gPT4gZmFsc2VcbiAqL1xudmFyIGlzVHlwZWRBcnJheSA9IG5vZGVJc1R5cGVkQXJyYXkgPyBiYXNlVW5hcnkobm9kZUlzVHlwZWRBcnJheSkgOiBiYXNlSXNUeXBlZEFycmF5O1xuXG4vKipcbiAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgdGhlIG93biBlbnVtZXJhYmxlIHByb3BlcnR5IG5hbWVzIG9mIGBvYmplY3RgLlxuICpcbiAqICoqTm90ZToqKiBOb24tb2JqZWN0IHZhbHVlcyBhcmUgY29lcmNlZCB0byBvYmplY3RzLiBTZWUgdGhlXG4gKiBbRVMgc3BlY10oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtb2JqZWN0LmtleXMpXG4gKiBmb3IgbW9yZSBkZXRhaWxzLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBzaW5jZSAwLjEuMFxuICogQG1lbWJlck9mIF9cbiAqIEBjYXRlZ29yeSBPYmplY3RcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgbmFtZXMuXG4gKiBAZXhhbXBsZVxuICpcbiAqIGZ1bmN0aW9uIEZvbygpIHtcbiAqICAgdGhpcy5hID0gMTtcbiAqICAgdGhpcy5iID0gMjtcbiAqIH1cbiAqXG4gKiBGb28ucHJvdG90eXBlLmMgPSAzO1xuICpcbiAqIF8ua2V5cyhuZXcgRm9vKTtcbiAqIC8vID0+IFsnYScsICdiJ10gKGl0ZXJhdGlvbiBvcmRlciBpcyBub3QgZ3VhcmFudGVlZClcbiAqXG4gKiBfLmtleXMoJ2hpJyk7XG4gKiAvLyA9PiBbJzAnLCAnMSddXG4gKi9cbmZ1bmN0aW9uIGtleXMob2JqZWN0KSB7XG4gIHJldHVybiBpc0FycmF5TGlrZShvYmplY3QpID8gYXJyYXlMaWtlS2V5cyhvYmplY3QpIDogYmFzZUtleXMob2JqZWN0KTtcbn1cblxuLyoqXG4gKiBUaGlzIG1ldGhvZCByZXR1cm5zIGEgbmV3IGVtcHR5IGFycmF5LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4xMy4wXG4gKiBAY2F0ZWdvcnkgVXRpbFxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgZW1wdHkgYXJyYXkuXG4gKiBAZXhhbXBsZVxuICpcbiAqIHZhciBhcnJheXMgPSBfLnRpbWVzKDIsIF8uc3R1YkFycmF5KTtcbiAqXG4gKiBjb25zb2xlLmxvZyhhcnJheXMpO1xuICogLy8gPT4gW1tdLCBbXV1cbiAqXG4gKiBjb25zb2xlLmxvZyhhcnJheXNbMF0gPT09IGFycmF5c1sxXSk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBzdHViQXJyYXkoKSB7XG4gIHJldHVybiBbXTtcbn1cblxuLyoqXG4gKiBUaGlzIG1ldGhvZCByZXR1cm5zIGBmYWxzZWAuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjEzLjBcbiAqIEBjYXRlZ29yeSBVdGlsXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLnRpbWVzKDIsIF8uc3R1YkZhbHNlKTtcbiAqIC8vID0+IFtmYWxzZSwgZmFsc2VdXG4gKi9cbmZ1bmN0aW9uIHN0dWJGYWxzZSgpIHtcbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzRXF1YWw7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvbG9kYXNoLmlzZXF1YWwvaW5kZXguanMiLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKG1vZHVsZSkge1xyXG5cdGlmKCFtb2R1bGUud2VicGFja1BvbHlmaWxsKSB7XHJcblx0XHRtb2R1bGUuZGVwcmVjYXRlID0gZnVuY3Rpb24oKSB7fTtcclxuXHRcdG1vZHVsZS5wYXRocyA9IFtdO1xyXG5cdFx0Ly8gbW9kdWxlLnBhcmVudCA9IHVuZGVmaW5lZCBieSBkZWZhdWx0XHJcblx0XHRpZighbW9kdWxlLmNoaWxkcmVuKSBtb2R1bGUuY2hpbGRyZW4gPSBbXTtcclxuXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShtb2R1bGUsIFwibG9hZGVkXCIsIHtcclxuXHRcdFx0ZW51bWVyYWJsZTogdHJ1ZSxcclxuXHRcdFx0Z2V0OiBmdW5jdGlvbigpIHtcclxuXHRcdFx0XHRyZXR1cm4gbW9kdWxlLmw7XHJcblx0XHRcdH1cclxuXHRcdH0pO1xyXG5cdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KG1vZHVsZSwgXCJpZFwiLCB7XHJcblx0XHRcdGVudW1lcmFibGU6IHRydWUsXHJcblx0XHRcdGdldDogZnVuY3Rpb24oKSB7XHJcblx0XHRcdFx0cmV0dXJuIG1vZHVsZS5pO1xyXG5cdFx0XHR9XHJcblx0XHR9KTtcclxuXHRcdG1vZHVsZS53ZWJwYWNrUG9seWZpbGwgPSAxO1xyXG5cdH1cclxuXHRyZXR1cm4gbW9kdWxlO1xyXG59O1xyXG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gKHdlYnBhY2spL2J1aWxkaW4vbW9kdWxlLmpzIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZXhlY3V0ZVRhc2tzID0gZXhlY3V0ZVRhc2tzO1xuZXhwb3J0cy5fZXhlY3V0ZVRhc2tzID0gX2V4ZWN1dGVUYXNrcztcbmV4cG9ydHMuY2hlY2tJc1Jhbmdlc1N1cHBvcnRlZCA9IGNoZWNrSXNSYW5nZXNTdXBwb3J0ZWQ7XG5cbnZhciBfYnVpbGRlclV0aWxSdW50aW1lO1xuXG5mdW5jdGlvbiBfbG9hZF9idWlsZGVyVXRpbFJ1bnRpbWUoKSB7XG4gICAgcmV0dXJuIF9idWlsZGVyVXRpbFJ1bnRpbWUgPSByZXF1aXJlKFwiYnVpbGRlci11dGlsLXJ1bnRpbWVcIik7XG59XG5cbnZhciBfRGF0YVNwbGl0dGVyO1xuXG5mdW5jdGlvbiBfbG9hZF9EYXRhU3BsaXR0ZXIoKSB7XG4gICAgcmV0dXJuIF9EYXRhU3BsaXR0ZXIgPSByZXF1aXJlKFwiLi9EYXRhU3BsaXR0ZXJcIik7XG59XG5cbnZhciBfZG93bmxvYWRQbGFuQnVpbGRlcjtcblxuZnVuY3Rpb24gX2xvYWRfZG93bmxvYWRQbGFuQnVpbGRlcigpIHtcbiAgICByZXR1cm4gX2Rvd25sb2FkUGxhbkJ1aWxkZXIgPSByZXF1aXJlKFwiLi9kb3dubG9hZFBsYW5CdWlsZGVyXCIpO1xufVxuXG5mdW5jdGlvbiBleGVjdXRlVGFza3MoZGlmZmVyZW50aWFsRG93bmxvYWRlciwgdGFza3MsIG91dCwgb2xkRmlsZUZkLCByZWplY3QpIHtcbiAgICBjb25zdCB3ID0gdGFza09mZnNldCA9PiB7XG4gICAgICAgIGlmICh0YXNrT2Zmc2V0ID49IHRhc2tzLmxlbmd0aCkge1xuICAgICAgICAgICAgaWYgKGRpZmZlcmVudGlhbERvd25sb2FkZXIuZmlsZU1ldGFkYXRhQnVmZmVyICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBvdXQud3JpdGUoZGlmZmVyZW50aWFsRG93bmxvYWRlci5maWxlTWV0YWRhdGFCdWZmZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgb3V0LmVuZCgpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG5leHRPZmZzZXQgPSB0YXNrT2Zmc2V0ICsgKGRpZmZlcmVudGlhbERvd25sb2FkZXIub3B0aW9ucy51c2VNdWx0aXBsZVJhbmdlUmVxdWVzdCA9PT0gZmFsc2UgPyAxIDogMTAwMCk7XG4gICAgICAgIF9leGVjdXRlVGFza3MoZGlmZmVyZW50aWFsRG93bmxvYWRlciwge1xuICAgICAgICAgICAgdGFza3MsXG4gICAgICAgICAgICBzdGFydDogdGFza09mZnNldCxcbiAgICAgICAgICAgIGVuZDogTWF0aC5taW4odGFza3MubGVuZ3RoLCBuZXh0T2Zmc2V0KSxcbiAgICAgICAgICAgIG9sZEZpbGVGZFxuICAgICAgICB9LCBvdXQsICgpID0+IHcobmV4dE9mZnNldCksIHJlamVjdCk7XG4gICAgfTtcbiAgICByZXR1cm4gdztcbn1cbmZ1bmN0aW9uIF9leGVjdXRlVGFza3MoZGlmZmVyZW50aWFsRG93bmxvYWRlciwgb3B0aW9ucywgb3V0LCByZXNvbHZlLCByZWplY3QpIHtcbiAgICBsZXQgcmFuZ2VzID0gXCJieXRlcz1cIjtcbiAgICBsZXQgcGFydENvdW50ID0gMDtcbiAgICBjb25zdCBwYXJ0SW5kZXhUb1Rhc2tJbmRleCA9IG5ldyBNYXAoKTtcbiAgICBjb25zdCBwYXJ0SW5kZXhUb0xlbmd0aCA9IFtdO1xuICAgIGZvciAobGV0IGkgPSBvcHRpb25zLnN0YXJ0OyBpIDwgb3B0aW9ucy5lbmQ7IGkrKykge1xuICAgICAgICBjb25zdCB0YXNrID0gb3B0aW9ucy50YXNrc1tpXTtcbiAgICAgICAgaWYgKHRhc2sua2luZCA9PT0gKF9kb3dubG9hZFBsYW5CdWlsZGVyIHx8IF9sb2FkX2Rvd25sb2FkUGxhbkJ1aWxkZXIoKSkuT3BlcmF0aW9uS2luZC5ET1dOTE9BRCkge1xuICAgICAgICAgICAgcmFuZ2VzICs9IGAke3Rhc2suc3RhcnR9LSR7dGFzay5lbmQgLSAxfSwgYDtcbiAgICAgICAgICAgIHBhcnRJbmRleFRvVGFza0luZGV4LnNldChwYXJ0Q291bnQsIGkpO1xuICAgICAgICAgICAgcGFydENvdW50Kys7XG4gICAgICAgICAgICBwYXJ0SW5kZXhUb0xlbmd0aC5wdXNoKHRhc2suZW5kIC0gdGFzay5zdGFydCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKHBhcnRDb3VudCA8PSAxKSB7XG4gICAgICAgIC8vIHRoZSBvbmx5IHJlbW90ZSByYW5nZSAtIGNvcHlcbiAgICAgICAgY29uc3QgdyA9IGluZGV4ID0+IHtcbiAgICAgICAgICAgIGlmIChpbmRleCA+PSBvcHRpb25zLmVuZCkge1xuICAgICAgICAgICAgICAgIHJlc29sdmUoKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCB0YXNrID0gb3B0aW9ucy50YXNrc1tpbmRleCsrXTtcbiAgICAgICAgICAgIGlmICh0YXNrLmtpbmQgPT09IChfZG93bmxvYWRQbGFuQnVpbGRlciB8fCBfbG9hZF9kb3dubG9hZFBsYW5CdWlsZGVyKCkpLk9wZXJhdGlvbktpbmQuQ09QWSkge1xuICAgICAgICAgICAgICAgICgwLCAoX0RhdGFTcGxpdHRlciB8fCBfbG9hZF9EYXRhU3BsaXR0ZXIoKSkuY29weURhdGEpKHRhc2ssIG91dCwgb3B0aW9ucy5vbGRGaWxlRmQsIHJlamVjdCwgKCkgPT4gdyhpbmRleCkpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb25zdCByZXF1ZXN0T3B0aW9ucyA9IGRpZmZlcmVudGlhbERvd25sb2FkZXIuY3JlYXRlUmVxdWVzdE9wdGlvbnMoXCJnZXRcIik7XG4gICAgICAgICAgICAgICAgcmVxdWVzdE9wdGlvbnMuaGVhZGVycy5SYW5nZSA9IGBieXRlcz0ke3Rhc2suc3RhcnR9LSR7dGFzay5lbmQgLSAxfWA7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVxdWVzdCA9IGRpZmZlcmVudGlhbERvd25sb2FkZXIuaHR0cEV4ZWN1dG9yLmRvUmVxdWVzdChyZXF1ZXN0T3B0aW9ucywgcmVzcG9uc2UgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWNoZWNrSXNSYW5nZXNTdXBwb3J0ZWQocmVzcG9uc2UsIHJlamVjdCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXNwb25zZS5waXBlKG91dCwge1xuICAgICAgICAgICAgICAgICAgICAgICAgZW5kOiBmYWxzZVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2Uub25jZShcImVuZFwiLCAoKSA9PiB3KGluZGV4KSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgZGlmZmVyZW50aWFsRG93bmxvYWRlci5odHRwRXhlY3V0b3IuYWRkRXJyb3JBbmRUaW1lb3V0SGFuZGxlcnMocmVxdWVzdCwgcmVqZWN0KTtcbiAgICAgICAgICAgICAgICByZXF1ZXN0LmVuZCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICB3KG9wdGlvbnMuc3RhcnQpO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHJlcXVlc3RPcHRpb25zID0gZGlmZmVyZW50aWFsRG93bmxvYWRlci5jcmVhdGVSZXF1ZXN0T3B0aW9ucyhcImdldFwiKTtcbiAgICByZXF1ZXN0T3B0aW9ucy5oZWFkZXJzLlJhbmdlID0gcmFuZ2VzLnN1YnN0cmluZygwLCByYW5nZXMubGVuZ3RoIC0gMik7XG4gICAgY29uc3QgcmVxdWVzdCA9IGRpZmZlcmVudGlhbERvd25sb2FkZXIuaHR0cEV4ZWN1dG9yLmRvUmVxdWVzdChyZXF1ZXN0T3B0aW9ucywgcmVzcG9uc2UgPT4ge1xuICAgICAgICBpZiAoIWNoZWNrSXNSYW5nZXNTdXBwb3J0ZWQocmVzcG9uc2UsIHJlamVjdCkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBjb250ZW50VHlwZSA9ICgwLCAoX2J1aWxkZXJVdGlsUnVudGltZSB8fCBfbG9hZF9idWlsZGVyVXRpbFJ1bnRpbWUoKSkuc2FmZUdldEhlYWRlcikocmVzcG9uc2UsIFwiY29udGVudC10eXBlXCIpO1xuICAgICAgICBjb25zdCBtID0gL15tdWx0aXBhcnRcXC8uKz8oPzo7IGJvdW5kYXJ5PSg/Oig/OlwiKC4rKVwiKXwoPzooW15cXHNdKykpKSkkL2kuZXhlYyhjb250ZW50VHlwZSk7XG4gICAgICAgIGlmIChtID09IG51bGwpIHtcbiAgICAgICAgICAgIHJlamVjdChuZXcgRXJyb3IoYENvbnRlbnQtVHlwZSBcIm11bHRpcGFydC9ieXRlcmFuZ2VzXCIgaXMgZXhwZWN0ZWQsIGJ1dCBnb3QgXCIke2NvbnRlbnRUeXBlfVwiYCkpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGRpY2VyID0gbmV3IChfRGF0YVNwbGl0dGVyIHx8IF9sb2FkX0RhdGFTcGxpdHRlcigpKS5EYXRhU3BsaXR0ZXIob3V0LCBvcHRpb25zLCBwYXJ0SW5kZXhUb1Rhc2tJbmRleCwgbVsxXSB8fCBtWzJdLCBwYXJ0SW5kZXhUb0xlbmd0aCwgcmVzb2x2ZSk7XG4gICAgICAgIGRpY2VyLm9uKFwiZXJyb3JcIiwgcmVqZWN0KTtcbiAgICAgICAgcmVzcG9uc2UucGlwZShkaWNlcik7XG4gICAgfSk7XG4gICAgZGlmZmVyZW50aWFsRG93bmxvYWRlci5odHRwRXhlY3V0b3IuYWRkRXJyb3JBbmRUaW1lb3V0SGFuZGxlcnMocmVxdWVzdCwgcmVqZWN0KTtcbiAgICByZXF1ZXN0LmVuZCgpO1xufVxuZnVuY3Rpb24gY2hlY2tJc1Jhbmdlc1N1cHBvcnRlZChyZXNwb25zZSwgcmVqZWN0KSB7XG4gICAgLy8gRWxlY3Ryb24gbmV0IGhhbmRsZXMgcmVkaXJlY3RzIGF1dG9tYXRpY2FsbHksIG91ciBOb2RlSlMgdGVzdCBzZXJ2ZXIgZG9lc24ndCB1c2UgcmVkaXJlY3RzIC0gc28sIHdlIGRvbid0IGNoZWNrIDN4eCBjb2Rlcy5cbiAgICBpZiAocmVzcG9uc2Uuc3RhdHVzQ29kZSA+PSA0MDApIHtcbiAgICAgICAgcmVqZWN0KCgwLCAoX2J1aWxkZXJVdGlsUnVudGltZSB8fCBfbG9hZF9idWlsZGVyVXRpbFJ1bnRpbWUoKSkuY3JlYXRlSHR0cEVycm9yKShyZXNwb25zZSkpO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmIChyZXNwb25zZS5zdGF0dXNDb2RlICE9PSAyMDYpIHtcbiAgICAgICAgY29uc3QgYWNjZXB0UmFuZ2VzID0gKDAsIChfYnVpbGRlclV0aWxSdW50aW1lIHx8IF9sb2FkX2J1aWxkZXJVdGlsUnVudGltZSgpKS5zYWZlR2V0SGVhZGVyKShyZXNwb25zZSwgXCJhY2NlcHQtcmFuZ2VzXCIpO1xuICAgICAgICBpZiAoYWNjZXB0UmFuZ2VzID09IG51bGwgfHwgYWNjZXB0UmFuZ2VzID09PSBcIm5vbmVcIikge1xuICAgICAgICAgICAgcmVqZWN0KG5ldyBFcnJvcihcIlNlcnZlciBkb2Vzbid0IHN1cHBvcnQgQWNjZXB0LVJhbmdlc1wiKSk7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1tdWx0aXBsZVJhbmdlRG93bmxvYWRlci5qcy5tYXBcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvZWxlY3Ryb24tdXBkYXRlci9vdXQvZGlmZmVyZW50aWFsRG93bmxvYWRlci9tdWx0aXBsZVJhbmdlRG93bmxvYWRlci5qcyIsIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLkdlbmVyaWNEaWZmZXJlbnRpYWxEb3dubG9hZGVyID0gdW5kZWZpbmVkO1xuXG52YXIgX2JsdWViaXJkTHN0O1xuXG5mdW5jdGlvbiBfbG9hZF9ibHVlYmlyZExzdCgpIHtcbiAgICByZXR1cm4gX2JsdWViaXJkTHN0ID0gcmVxdWlyZShcImJsdWViaXJkLWxzdFwiKTtcbn1cblxudmFyIF9ibG9ja01hcEFwaTtcblxuZnVuY3Rpb24gX2xvYWRfYmxvY2tNYXBBcGkoKSB7XG4gICAgcmV0dXJuIF9ibG9ja01hcEFwaSA9IHJlcXVpcmUoXCJidWlsZGVyLXV0aWwtcnVudGltZS9vdXQvYmxvY2tNYXBBcGlcIik7XG59XG5cbnZhciBfZnNFeHRyYVA7XG5cbmZ1bmN0aW9uIF9sb2FkX2ZzRXh0cmFQKCkge1xuICAgIHJldHVybiBfZnNFeHRyYVAgPSByZXF1aXJlKFwiZnMtZXh0cmEtcFwiKTtcbn1cblxudmFyIF9wYXRoID0gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQocmVxdWlyZShcInBhdGhcIikpO1xuXG52YXIgX0RpZmZlcmVudGlhbERvd25sb2FkZXI7XG5cbmZ1bmN0aW9uIF9sb2FkX0RpZmZlcmVudGlhbERvd25sb2FkZXIoKSB7XG4gICAgcmV0dXJuIF9EaWZmZXJlbnRpYWxEb3dubG9hZGVyID0gcmVxdWlyZShcIi4vRGlmZmVyZW50aWFsRG93bmxvYWRlclwiKTtcbn1cblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQob2JqKSB7IGlmIChvYmogJiYgb2JqLl9fZXNNb2R1bGUpIHsgcmV0dXJuIG9iajsgfSBlbHNlIHsgdmFyIG5ld09iaiA9IHt9OyBpZiAob2JqICE9IG51bGwpIHsgZm9yICh2YXIga2V5IGluIG9iaikgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwga2V5KSkgbmV3T2JqW2tleV0gPSBvYmpba2V5XTsgfSB9IG5ld09iai5kZWZhdWx0ID0gb2JqOyByZXR1cm4gbmV3T2JqOyB9IH1cblxuY2xhc3MgR2VuZXJpY0RpZmZlcmVudGlhbERvd25sb2FkZXIgZXh0ZW5kcyAoX0RpZmZlcmVudGlhbERvd25sb2FkZXIgfHwgX2xvYWRfRGlmZmVyZW50aWFsRG93bmxvYWRlcigpKS5EaWZmZXJlbnRpYWxEb3dubG9hZGVyIHtcbiAgICBkb3dubG9hZChuZXdCbG9ja01hcCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgICAgIHJldHVybiAoMCwgKF9ibHVlYmlyZExzdCB8fCBfbG9hZF9ibHVlYmlyZExzdCgpKS5jb3JvdXRpbmUpKGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICB5aWVsZCBfdGhpcy5kb0Rvd25sb2FkKCh5aWVsZCAoMCwgKF9mc0V4dHJhUCB8fCBfbG9hZF9mc0V4dHJhUCgpKS5yZWFkSnNvbikoX3BhdGguam9pbihwcm9jZXNzLnJlc291cmNlc1BhdGgsIFwiLi5cIiwgKF9ibG9ja01hcEFwaSB8fCBfbG9hZF9ibG9ja01hcEFwaSgpKS5CTE9DS19NQVBfRklMRV9OQU1FKSkpLCBuZXdCbG9ja01hcCk7XG4gICAgICAgIH0pKCk7XG4gICAgfVxufVxuZXhwb3J0cy5HZW5lcmljRGlmZmVyZW50aWFsRG93bmxvYWRlciA9IEdlbmVyaWNEaWZmZXJlbnRpYWxEb3dubG9hZGVyOyAvLyMgc291cmNlTWFwcGluZ1VSTD1HZW5lcmljRGlmZmVyZW50aWFsRG93bmxvYWRlci5qcy5tYXBcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvZWxlY3Ryb24tdXBkYXRlci9vdXQvZGlmZmVyZW50aWFsRG93bmxvYWRlci9HZW5lcmljRGlmZmVyZW50aWFsRG93bmxvYWRlci5qcyIsIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLnZlcmlmeVNpZ25hdHVyZSA9IHZlcmlmeVNpZ25hdHVyZTtcblxudmFyIF9ibHVlYmlyZExzdDtcblxuZnVuY3Rpb24gX2xvYWRfYmx1ZWJpcmRMc3QoKSB7XG4gICAgcmV0dXJuIF9ibHVlYmlyZExzdCA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcImJsdWViaXJkLWxzdFwiKSk7XG59XG5cbnZhciBfYnVpbGRlclV0aWxSdW50aW1lO1xuXG5mdW5jdGlvbiBfbG9hZF9idWlsZGVyVXRpbFJ1bnRpbWUoKSB7XG4gICAgcmV0dXJuIF9idWlsZGVyVXRpbFJ1bnRpbWUgPSByZXF1aXJlKFwiYnVpbGRlci11dGlsLXJ1bnRpbWVcIik7XG59XG5cbnZhciBfY2hpbGRfcHJvY2VzcztcblxuZnVuY3Rpb24gX2xvYWRfY2hpbGRfcHJvY2VzcygpIHtcbiAgICByZXR1cm4gX2NoaWxkX3Byb2Nlc3MgPSByZXF1aXJlKFwiY2hpbGRfcHJvY2Vzc1wiKTtcbn1cblxudmFyIF9vcztcblxuZnVuY3Rpb24gX2xvYWRfb3MoKSB7XG4gICAgcmV0dXJuIF9vcyA9IF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKHJlcXVpcmUoXCJvc1wiKSk7XG59XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKG9iaikgeyBpZiAob2JqICYmIG9iai5fX2VzTW9kdWxlKSB7IHJldHVybiBvYmo7IH0gZWxzZSB7IHZhciBuZXdPYmogPSB7fTsgaWYgKG9iaiAhPSBudWxsKSB7IGZvciAodmFyIGtleSBpbiBvYmopIHsgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGtleSkpIG5ld09ialtrZXldID0gb2JqW2tleV07IH0gfSBuZXdPYmouZGVmYXVsdCA9IG9iajsgcmV0dXJuIG5ld09iajsgfSB9XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbi8vICRjZXJ0aWZpY2F0ZUluZm8gPSAoR2V0LUF1dGhlbnRpY29kZVNpZ25hdHVyZSAneHh4XFx5eXkuZXhlJ1xuLy8gfCB3aGVyZSB7JF8uU3RhdHVzLkVxdWFscyhbU3lzdGVtLk1hbmFnZW1lbnQuQXV0b21hdGlvbi5TaWduYXR1cmVTdGF0dXNdOjpWYWxpZCkgLWFuZCAkXy5TaWduZXJDZXJ0aWZpY2F0ZS5TdWJqZWN0LkNvbnRhaW5zKFwiQ049c2llbWVucy5jb21cIil9KVxuLy8gfCBPdXQtU3RyaW5nIDsgaWYgKCRjZXJ0aWZpY2F0ZUluZm8pIHsgZXhpdCAwIH0gZWxzZSB7IGV4aXQgMSB9XG5mdW5jdGlvbiB2ZXJpZnlTaWduYXR1cmUocHVibGlzaGVyTmFtZXMsIHRlbXBVcGRhdGVGaWxlLCBsb2dnZXIpIHtcbiAgICByZXR1cm4gbmV3IChfYmx1ZWJpcmRMc3QgfHwgX2xvYWRfYmx1ZWJpcmRMc3QoKSkuZGVmYXVsdCgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9lbGVjdHJvbi11c2VybGFuZC9lbGVjdHJvbi1idWlsZGVyL2lzc3Vlcy8yNDIxXG4gICAgICAgICgwLCAoX2NoaWxkX3Byb2Nlc3MgfHwgX2xvYWRfY2hpbGRfcHJvY2VzcygpKS5leGVjRmlsZSkoXCJwb3dlcnNoZWxsLmV4ZVwiLCBbYEdldC1BdXRoZW50aWNvZGVTaWduYXR1cmUgJyR7dGVtcFVwZGF0ZUZpbGV9JyB8IENvbnZlcnRUby1Kc29uIC1Db21wcmVzc2BdLCB7XG4gICAgICAgICAgICB0aW1lb3V0OiAzMCAqIDEwMDBcbiAgICAgICAgfSwgKGVycm9yLCBzdGRvdXQsIHN0ZGVycikgPT4ge1xuICAgICAgICAgICAgaWYgKGVycm9yICE9IG51bGwgfHwgc3RkZXJyKSB7XG4gICAgICAgICAgICAgICAgaWYgKGlzT2xkV2luNigpKSB7XG4gICAgICAgICAgICAgICAgICAgIGxvZ2dlci53YXJuKGBDYW5ub3QgZXhlY3V0ZSBHZXQtQXV0aGVudGljb2RlU2lnbmF0dXJlOiAke2Vycm9yIHx8IHN0ZGVycn0uIElnbm9yaW5nIHNpZ25hdHVyZSB2YWxpZGF0aW9uIGR1ZSB0byB1bnN1cHBvcnRlZCBwb3dlcnNoZWxsIHZlcnNpb24uIFBsZWFzZSB1cGdyYWRlIHRvIHBvd2Vyc2hlbGwgMyBvciBoaWdoZXIuYCk7XG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmUobnVsbCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgKDAsIChfY2hpbGRfcHJvY2VzcyB8fCBfbG9hZF9jaGlsZF9wcm9jZXNzKCkpLmV4ZWNGaWxlU3luYykoXCJwb3dlcnNoZWxsLmV4ZVwiLCBbXCJDb252ZXJ0VG8tSnNvbiB0ZXN0XCJdLCB7IHRpbWVvdXQ6IDEwICogMTAwMCB9KTtcbiAgICAgICAgICAgICAgICB9IGNhdGNoICh0ZXN0RXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgbG9nZ2VyLndhcm4oYENhbm5vdCBleGVjdXRlIENvbnZlcnRUby1Kc29uOiAke3Rlc3RFcnJvci5tZXNzYWdlfS4gSWdub3Jpbmcgc2lnbmF0dXJlIHZhbGlkYXRpb24gZHVlIHRvIHVuc3VwcG9ydGVkIHBvd2Vyc2hlbGwgdmVyc2lvbi4gUGxlYXNlIHVwZ3JhZGUgdG8gcG93ZXJzaGVsbCAzIG9yIGhpZ2hlci5gKTtcbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShudWxsKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoZXJyb3IgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICByZWplY3QoZXJyb3IpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChzdGRlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVqZWN0KG5ldyBFcnJvcihgQ2Fubm90IGV4ZWN1dGUgR2V0LUF1dGhlbnRpY29kZVNpZ25hdHVyZTogJHtzdGRlcnJ9YCkpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgZGF0YSA9IEpTT04ucGFyc2Uoc3Rkb3V0KTtcbiAgICAgICAgICAgIGRlbGV0ZSBkYXRhLlByaXZhdGVLZXk7XG4gICAgICAgICAgICBkZWxldGUgZGF0YS5Jc09TQmluYXJ5O1xuICAgICAgICAgICAgZGVsZXRlIGRhdGEuU2lnbmF0dXJlVHlwZTtcbiAgICAgICAgICAgIGNvbnN0IHNpZ25lckNlcnRpZmljYXRlID0gZGF0YS5TaWduZXJDZXJ0aWZpY2F0ZTtcbiAgICAgICAgICAgIGlmIChzaWduZXJDZXJ0aWZpY2F0ZSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgZGVsZXRlIHNpZ25lckNlcnRpZmljYXRlLkFyY2hpdmVkO1xuICAgICAgICAgICAgICAgIGRlbGV0ZSBzaWduZXJDZXJ0aWZpY2F0ZS5FeHRlbnNpb25zO1xuICAgICAgICAgICAgICAgIGRlbGV0ZSBzaWduZXJDZXJ0aWZpY2F0ZS5IYW5kbGU7XG4gICAgICAgICAgICAgICAgZGVsZXRlIHNpZ25lckNlcnRpZmljYXRlLkhhc1ByaXZhdGVLZXk7XG4gICAgICAgICAgICAgICAgLy8gZHVwbGljYXRlcyBkYXRhLlNpZ25lckNlcnRpZmljYXRlIChjb250YWlucyBSYXdEYXRhKVxuICAgICAgICAgICAgICAgIGRlbGV0ZSBzaWduZXJDZXJ0aWZpY2F0ZS5TdWJqZWN0TmFtZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRlbGV0ZSBkYXRhLlBhdGg7XG4gICAgICAgICAgICBpZiAoZGF0YS5TdGF0dXMgPT09IDApIHtcbiAgICAgICAgICAgICAgICBjb25zdCBuYW1lID0gKDAsIChfYnVpbGRlclV0aWxSdW50aW1lIHx8IF9sb2FkX2J1aWxkZXJVdGlsUnVudGltZSgpKS5wYXJzZURuKShkYXRhLlNpZ25lckNlcnRpZmljYXRlLlN1YmplY3QpLmdldChcIkNOXCIpO1xuICAgICAgICAgICAgICAgIGlmIChwdWJsaXNoZXJOYW1lcy5pbmNsdWRlcyhuYW1lKSkge1xuICAgICAgICAgICAgICAgICAgICByZXNvbHZlKG51bGwpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gYHB1Ymxpc2hlck5hbWVzOiAke3B1Ymxpc2hlck5hbWVzLmpvaW4oXCIgfCBcIil9LCByYXcgaW5mbzogYCArIEpTT04uc3RyaW5naWZ5KGRhdGEsIChuYW1lLCB2YWx1ZSkgPT4gbmFtZSA9PT0gXCJSYXdEYXRhXCIgPyB1bmRlZmluZWQgOiB2YWx1ZSwgMik7XG4gICAgICAgICAgICBsb2dnZXIuaW5mbyhgU2lnbiB2ZXJpZmljYXRpb24gZmFpbGVkLCBpbnN0YWxsZXIgc2lnbmVkIHdpdGggaW5jb3JyZWN0IGNlcnRpZmljYXRlOiAke3Jlc3VsdH1gKTtcbiAgICAgICAgICAgIHJlc29sdmUocmVzdWx0KTtcbiAgICAgICAgfSk7XG4gICAgfSk7XG59XG5mdW5jdGlvbiBpc09sZFdpbjYoKSB7XG4gICAgY29uc3Qgd2luVmVyc2lvbiA9IChfb3MgfHwgX2xvYWRfb3MoKSkucmVsZWFzZSgpO1xuICAgIHJldHVybiB3aW5WZXJzaW9uLnN0YXJ0c1dpdGgoXCI2LlwiKSAmJiAhd2luVmVyc2lvbi5zdGFydHNXaXRoKFwiNi4zXCIpO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9d2luZG93c0V4ZWN1dGFibGVDb2RlU2lnbmF0dXJlVmVyaWZpZXIuanMubWFwXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2VsZWN0cm9uLXVwZGF0ZXIvb3V0L3dpbmRvd3NFeGVjdXRhYmxlQ29kZVNpZ25hdHVyZVZlcmlmaWVyLmpzIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuTWFjVXBkYXRlciA9IHVuZGVmaW5lZDtcblxudmFyIF9ibHVlYmlyZExzdDtcblxuZnVuY3Rpb24gX2xvYWRfYmx1ZWJpcmRMc3QoKSB7XG4gICAgcmV0dXJuIF9ibHVlYmlyZExzdCA9IHJlcXVpcmUoXCJibHVlYmlyZC1sc3RcIik7XG59XG5cbnZhciBfYmx1ZWJpcmRMc3QyO1xuXG5mdW5jdGlvbiBfbG9hZF9ibHVlYmlyZExzdDIoKSB7XG4gICAgcmV0dXJuIF9ibHVlYmlyZExzdDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJibHVlYmlyZC1sc3RcIikpO1xufVxuXG52YXIgX2J1aWxkZXJVdGlsUnVudGltZTtcblxuZnVuY3Rpb24gX2xvYWRfYnVpbGRlclV0aWxSdW50aW1lKCkge1xuICAgIHJldHVybiBfYnVpbGRlclV0aWxSdW50aW1lID0gcmVxdWlyZShcImJ1aWxkZXItdXRpbC1ydW50aW1lXCIpO1xufVxuXG52YXIgX2h0dHA7XG5cbmZ1bmN0aW9uIF9sb2FkX2h0dHAoKSB7XG4gICAgcmV0dXJuIF9odHRwID0gcmVxdWlyZShcImh0dHBcIik7XG59XG5cbnZhciBfQXBwVXBkYXRlcjtcblxuZnVuY3Rpb24gX2xvYWRfQXBwVXBkYXRlcigpIHtcbiAgICByZXR1cm4gX0FwcFVwZGF0ZXIgPSByZXF1aXJlKFwiLi9BcHBVcGRhdGVyXCIpO1xufVxuXG52YXIgX21haW47XG5cbmZ1bmN0aW9uIF9sb2FkX21haW4oKSB7XG4gICAgcmV0dXJuIF9tYWluID0gcmVxdWlyZShcIi4vbWFpblwiKTtcbn1cblxudmFyIF9Qcm92aWRlcjtcblxuZnVuY3Rpb24gX2xvYWRfUHJvdmlkZXIoKSB7XG4gICAgcmV0dXJuIF9Qcm92aWRlciA9IHJlcXVpcmUoXCIuL1Byb3ZpZGVyXCIpO1xufVxuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5jbGFzcyBNYWNVcGRhdGVyIGV4dGVuZHMgKF9BcHBVcGRhdGVyIHx8IF9sb2FkX0FwcFVwZGF0ZXIoKSkuQXBwVXBkYXRlciB7XG4gICAgY29uc3RydWN0b3Iob3B0aW9ucykge1xuICAgICAgICBzdXBlcihvcHRpb25zKTtcbiAgICAgICAgdGhpcy5uYXRpdmVVcGRhdGVyID0gcmVxdWlyZShcImVsZWN0cm9uXCIpLmF1dG9VcGRhdGVyO1xuICAgICAgICB0aGlzLm5hdGl2ZVVwZGF0ZXIub24oXCJlcnJvclwiLCBpdCA9PiB7XG4gICAgICAgICAgICB0aGlzLl9sb2dnZXIud2FybihpdCk7XG4gICAgICAgICAgICB0aGlzLmVtaXQoXCJlcnJvclwiLCBpdCk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLm5hdGl2ZVVwZGF0ZXIub24oXCJ1cGRhdGUtZG93bmxvYWRlZFwiLCAoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLl9sb2dnZXIuaW5mbyhgTmV3IHZlcnNpb24gJHt0aGlzLnVwZGF0ZUluZm8udmVyc2lvbn0gaGFzIGJlZW4gZG93bmxvYWRlZGApO1xuICAgICAgICAgICAgdGhpcy5lbWl0KChfbWFpbiB8fCBfbG9hZF9tYWluKCkpLlVQREFURV9ET1dOTE9BREVELCB0aGlzLnVwZGF0ZUluZm8pO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgZG9Eb3dubG9hZFVwZGF0ZSh1cGRhdGVJbmZvLCBjYW5jZWxsYXRpb25Ub2tlbikge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgICAgIHJldHVybiAoMCwgKF9ibHVlYmlyZExzdCB8fCBfbG9hZF9ibHVlYmlyZExzdCgpKS5jb3JvdXRpbmUpKGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCBmaWxlcyA9ICh5aWVsZCBfdGhpcy5wcm92aWRlcikucmVzb2x2ZUZpbGVzKHVwZGF0ZUluZm8pO1xuICAgICAgICAgICAgY29uc3QgemlwRmlsZUluZm8gPSAoMCwgKF9Qcm92aWRlciB8fCBfbG9hZF9Qcm92aWRlcigpKS5maW5kRmlsZSkoZmlsZXMsIFwiemlwXCIsIFtcInBrZ1wiLCBcImRtZ1wiXSk7XG4gICAgICAgICAgICBpZiAoemlwRmlsZUluZm8gPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRocm93ICgwLCAoX2J1aWxkZXJVdGlsUnVudGltZSB8fCBfbG9hZF9idWlsZGVyVXRpbFJ1bnRpbWUoKSkubmV3RXJyb3IpKGBaSVAgZmlsZSBub3QgcHJvdmlkZWQ6ICR7KDAsIChfYnVpbGRlclV0aWxSdW50aW1lIHx8IF9sb2FkX2J1aWxkZXJVdGlsUnVudGltZSgpKS5zYWZlU3RyaW5naWZ5SnNvbikoZmlsZXMpfWAsIFwiRVJSX1VQREFURVJfWklQX0ZJTEVfTk9UX0ZPVU5EXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3Qgc2VydmVyID0gKDAsIChfaHR0cCB8fCBfbG9hZF9odHRwKCkpLmNyZWF0ZVNlcnZlcikoKTtcbiAgICAgICAgICAgIHNlcnZlci5vbihcImNsb3NlXCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5fbG9nZ2VyLmluZm8oYFByb3h5IHNlcnZlciBmb3IgbmF0aXZlIFNxdWlycmVsLk1hYyBpcyBjbG9zZWQgKHdhcyBzdGFydGVkIHRvIGRvd25sb2FkICR7emlwRmlsZUluZm8udXJsLmhyZWZ9KWApO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBmdW5jdGlvbiBnZXRTZXJ2ZXJVcmwoKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgYWRkcmVzcyA9IHNlcnZlci5hZGRyZXNzKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGBodHRwOi8vJHthZGRyZXNzLmFkZHJlc3N9OiR7YWRkcmVzcy5wb3J0fWA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCByZXF1ZXN0SGVhZGVycyA9IHlpZWxkIF90aGlzLmNvbXB1dGVSZXF1ZXN0SGVhZGVycygpO1xuICAgICAgICAgICAgcmV0dXJuIHlpZWxkIG5ldyAoX2JsdWViaXJkTHN0MiB8fCBfbG9hZF9ibHVlYmlyZExzdDIoKSkuZGVmYXVsdChmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgICAgICAgICAgc2VydmVyLm9uKFwicmVxdWVzdFwiLCBmdW5jdGlvbiAocmVxdWVzdCwgcmVzcG9uc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVxdWVzdFVybCA9IHJlcXVlc3QudXJsO1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5fbG9nZ2VyLmluZm8oYCR7cmVxdWVzdFVybH0gcmVxdWVzdGVkYCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChyZXF1ZXN0VXJsID09PSBcIi9cIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZGF0YSA9IEJ1ZmZlci5mcm9tKGB7IFwidXJsXCI6IFwiJHtnZXRTZXJ2ZXJVcmwoKX0vYXBwLnppcFwiIH1gKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlLndyaXRlSGVhZCgyMDAsIHsgXCJDb250ZW50LVR5cGVcIjogXCJhcHBsaWNhdGlvbi9qc29uXCIsIFwiQ29udGVudC1MZW5ndGhcIjogZGF0YS5sZW5ndGggfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXNwb25zZS5lbmQoZGF0YSk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAocmVxdWVzdFVybC5zdGFydHNXaXRoKFwiL2FwcC56aXBcIikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBlcnJvck9jY3VycmVkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXNwb25zZS5vbihcImZpbmlzaFwiLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2V0SW1tZWRpYXRlKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBzZXJ2ZXIuY2xvc2UoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFlcnJvck9jY3VycmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5uYXRpdmVVcGRhdGVyLnJlbW92ZUxpc3RlbmVyKFwiZXJyb3JcIiwgcmVqZWN0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmUoW10pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5kb1Byb3h5VXBkYXRlRmlsZShyZXNwb25zZSwgemlwRmlsZUluZm8udXJsLmhyZWYsIHJlcXVlc3RIZWFkZXJzLCB6aXBGaWxlSW5mby5pbmZvLnNoYTUxMiwgY2FuY2VsbGF0aW9uVG9rZW4sIGZ1bmN0aW9uIChlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yT2NjdXJyZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlLndyaXRlSGVhZCg1MDApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXNwb25zZS5lbmQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5uYXRpdmVVcGRhdGVyLnJlbW92ZUxpc3RlbmVyKFwiZXJyb3JcIiwgcmVqZWN0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVqZWN0KG5ldyBFcnJvcihgQ2Fubm90IGRvd25sb2FkIFwiJHt6aXBGaWxlSW5mby51cmx9XCI6ICR7ZXJyb3J9YCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuX2xvZ2dlci53YXJuKGAke3JlcXVlc3RVcmx9IHJlcXVlc3RlZCwgYnV0IG5vdCBzdXBwb3J0ZWRgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlLndyaXRlSGVhZCg0MDQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2UuZW5kKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBzZXJ2ZXIubGlzdGVuKDAsIFwiMTI3LjAuMC4xXCIsIDE2LCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLm5hdGl2ZVVwZGF0ZXIuc2V0RmVlZFVSTChgJHtnZXRTZXJ2ZXJVcmwoKX1gLCB7IFwiQ2FjaGUtQ29udHJvbFwiOiBcIm5vLWNhY2hlXCIgfSk7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLm5hdGl2ZVVwZGF0ZXIub25jZShcImVycm9yXCIsIHJlamVjdCk7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLm5hdGl2ZVVwZGF0ZXIuY2hlY2tGb3JVcGRhdGVzKCk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSkoKTtcbiAgICB9XG4gICAgZG9Qcm94eVVwZGF0ZUZpbGUobmF0aXZlUmVzcG9uc2UsIHVybCwgaGVhZGVycywgc2hhNTEyLCBjYW5jZWxsYXRpb25Ub2tlbiwgZXJyb3JIYW5kbGVyKSB7XG4gICAgICAgIGNvbnN0IGRvd25sb2FkUmVxdWVzdCA9IHRoaXMuaHR0cEV4ZWN1dG9yLmRvUmVxdWVzdCgoMCwgKF9idWlsZGVyVXRpbFJ1bnRpbWUgfHwgX2xvYWRfYnVpbGRlclV0aWxSdW50aW1lKCkpLmNvbmZpZ3VyZVJlcXVlc3RPcHRpb25zRnJvbVVybCkodXJsLCB7IGhlYWRlcnMgfSksIGRvd25sb2FkUmVzcG9uc2UgPT4ge1xuICAgICAgICAgICAgaWYgKGRvd25sb2FkUmVzcG9uc2Uuc3RhdHVzQ29kZSA+PSA0MDApIHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBuYXRpdmVSZXNwb25zZS53cml0ZUhlYWQoNDA0KTtcbiAgICAgICAgICAgICAgICAgICAgbmF0aXZlUmVzcG9uc2UuZW5kKCk7XG4gICAgICAgICAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgICAgICAgZXJyb3JIYW5kbGVyKG5ldyBFcnJvcihgQ2Fubm90IGRvd25sb2FkIFwiJHt1cmx9XCIsIHN0YXR1cyAke2Rvd25sb2FkUmVzcG9uc2Uuc3RhdHVzQ29kZX06ICR7ZG93bmxvYWRSZXNwb25zZS5zdGF0dXNNZXNzYWdlfWApKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gaW4gdGVzdHMgRWxlY3Ryb24gTkVUIEFwaSBpcyBub3QgdXNlZCwgc28sIHdlIGhhdmUgdG8gaGFuZGxlIHJlZGlyZWN0LlxuICAgICAgICAgICAgY29uc3QgcmVkaXJlY3RVcmwgPSAoMCwgKF9idWlsZGVyVXRpbFJ1bnRpbWUgfHwgX2xvYWRfYnVpbGRlclV0aWxSdW50aW1lKCkpLnNhZmVHZXRIZWFkZXIpKGRvd25sb2FkUmVzcG9uc2UsIFwibG9jYXRpb25cIik7XG4gICAgICAgICAgICBpZiAocmVkaXJlY3RVcmwgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRoaXMuZG9Qcm94eVVwZGF0ZUZpbGUobmF0aXZlUmVzcG9uc2UsIHJlZGlyZWN0VXJsLCBoZWFkZXJzLCBzaGE1MTIsIGNhbmNlbGxhdGlvblRva2VuLCBlcnJvckhhbmRsZXIpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IG5hdGl2ZUhlYWRlcnMgPSB7IFwiQ29udGVudC1UeXBlXCI6IFwiYXBwbGljYXRpb24vemlwXCIgfTtcbiAgICAgICAgICAgIGNvbnN0IHN0cmVhbXMgPSBbXTtcbiAgICAgICAgICAgIGNvbnN0IGRvd25sb2FkTGlzdGVuZXJDb3VudCA9IHRoaXMubGlzdGVuZXJDb3VudCgoX21haW4gfHwgX2xvYWRfbWFpbigpKS5ET1dOTE9BRF9QUk9HUkVTUyk7XG4gICAgICAgICAgICB0aGlzLl9sb2dnZXIuaW5mbyhgJHsoX21haW4gfHwgX2xvYWRfbWFpbigpKS5ET1dOTE9BRF9QUk9HUkVTU30gbGlzdGVuZXIgY291bnQ6ICR7ZG93bmxvYWRMaXN0ZW5lckNvdW50fWApO1xuICAgICAgICAgICAgaWYgKGRvd25sb2FkTGlzdGVuZXJDb3VudCA+IDApIHtcbiAgICAgICAgICAgICAgICBjb25zdCBjb250ZW50TGVuZ3RoID0gKDAsIChfYnVpbGRlclV0aWxSdW50aW1lIHx8IF9sb2FkX2J1aWxkZXJVdGlsUnVudGltZSgpKS5zYWZlR2V0SGVhZGVyKShkb3dubG9hZFJlc3BvbnNlLCBcImNvbnRlbnQtbGVuZ3RoXCIpO1xuICAgICAgICAgICAgICAgIHRoaXMuX2xvZ2dlci5pbmZvKGBjb250ZW50TGVuZ3RoOiAke2NvbnRlbnRMZW5ndGh9YCk7XG4gICAgICAgICAgICAgICAgaWYgKGNvbnRlbnRMZW5ndGggIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBuYXRpdmVIZWFkZXJzW1wiQ29udGVudC1MZW5ndGhcIl0gPSBjb250ZW50TGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICBzdHJlYW1zLnB1c2gobmV3IChfYnVpbGRlclV0aWxSdW50aW1lIHx8IF9sb2FkX2J1aWxkZXJVdGlsUnVudGltZSgpKS5Qcm9ncmVzc0NhbGxiYWNrVHJhbnNmb3JtKHBhcnNlSW50KGNvbnRlbnRMZW5ndGgsIDEwKSwgY2FuY2VsbGF0aW9uVG9rZW4sIGl0ID0+IHRoaXMuZW1pdCgoX21haW4gfHwgX2xvYWRfbWFpbigpKS5ET1dOTE9BRF9QUk9HUkVTUywgaXQpKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbmF0aXZlUmVzcG9uc2Uud3JpdGVIZWFkKDIwMCwgbmF0aXZlSGVhZGVycyk7XG4gICAgICAgICAgICAvLyBmb3IgbWFjIG9ubHkgc2hhNTEyIGlzIHByb2R1Y2VkIChzaGEyNTYgaXMgcHVibGlzaGVkIGZvciB3aW5kb3dzIG9ubHkgdG8gcHJlc2VydmUgYmFja3dhcmQgY29tcGF0aWJpbGl0eSlcbiAgICAgICAgICAgIGlmIChzaGE1MTIgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIC8vIFwiaGV4XCIgdG8gZWFzeSBtaWdyYXRlIHRvIG5ldyBiYXNlNjQgZW5jb2RlZCBoYXNoICh3ZSBhbHJlYWR5IHByb2R1Y2VzIGxhdGVzdC1tYWMueW1sIHdpdGggaGV4IGVuY29kZWQgaGFzaClcbiAgICAgICAgICAgICAgICBzdHJlYW1zLnB1c2gobmV3IChfYnVpbGRlclV0aWxSdW50aW1lIHx8IF9sb2FkX2J1aWxkZXJVdGlsUnVudGltZSgpKS5EaWdlc3RUcmFuc2Zvcm0oc2hhNTEyLCBcInNoYTUxMlwiLCBzaGE1MTIubGVuZ3RoID09PSAxMjggJiYgIXNoYTUxMi5pbmNsdWRlcyhcIitcIikgJiYgIXNoYTUxMi5pbmNsdWRlcyhcIlpcIikgJiYgIXNoYTUxMi5pbmNsdWRlcyhcIj1cIikgPyBcImhleFwiIDogXCJiYXNlNjRcIikpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc3RyZWFtcy5wdXNoKG5hdGl2ZVJlc3BvbnNlKTtcbiAgICAgICAgICAgIGxldCBsYXN0U3RyZWFtID0gZG93bmxvYWRSZXNwb25zZTtcbiAgICAgICAgICAgIGZvciAoY29uc3Qgc3RyZWFtIG9mIHN0cmVhbXMpIHtcbiAgICAgICAgICAgICAgICBzdHJlYW0ub24oXCJlcnJvclwiLCBlcnJvckhhbmRsZXIpO1xuICAgICAgICAgICAgICAgIGxhc3RTdHJlYW0gPSBsYXN0U3RyZWFtLnBpcGUoc3RyZWFtKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGRvd25sb2FkUmVxdWVzdC5vbihcInJlZGlyZWN0XCIsIChzdGF0dXNDb2RlLCBtZXRob2QsIHJlZGlyZWN0VXJsKSA9PiB7XG4gICAgICAgICAgICBpZiAoaGVhZGVycy5BdXRob3JpemF0aW9uICE9IG51bGwgJiYgaGVhZGVycy5BdXRob3JpemF0aW9uLnN0YXJ0c1dpdGgoXCJ0b2tlblwiKSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHBhcnNlZE5ld1VybCA9IG5ldyBVUkwocmVkaXJlY3RVcmwpO1xuICAgICAgICAgICAgICAgIGlmIChwYXJzZWROZXdVcmwuaG9zdG5hbWUuZW5kc1dpdGgoXCIuYW1hem9uYXdzLmNvbVwiKSkge1xuICAgICAgICAgICAgICAgICAgICBkZWxldGUgaGVhZGVycy5BdXRob3JpemF0aW9uO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuZG9Qcm94eVVwZGF0ZUZpbGUobmF0aXZlUmVzcG9uc2UsIHJlZGlyZWN0VXJsLCBoZWFkZXJzLCBzaGE1MTIsIGNhbmNlbGxhdGlvblRva2VuLCBlcnJvckhhbmRsZXIpO1xuICAgICAgICB9KTtcbiAgICAgICAgZG93bmxvYWRSZXF1ZXN0Lm9uKFwiZXJyb3JcIiwgZXJyb3JIYW5kbGVyKTtcbiAgICAgICAgZG93bmxvYWRSZXF1ZXN0LmVuZCgpO1xuICAgIH1cbiAgICBxdWl0QW5kSW5zdGFsbCgpIHtcbiAgICAgICAgdGhpcy5uYXRpdmVVcGRhdGVyLnF1aXRBbmRJbnN0YWxsKCk7XG4gICAgfVxufVxuZXhwb3J0cy5NYWNVcGRhdGVyID0gTWFjVXBkYXRlcjsgLy8jIHNvdXJjZU1hcHBpbmdVUkw9TWFjVXBkYXRlci5qcy5tYXBcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvZWxlY3Ryb24tdXBkYXRlci9vdXQvTWFjVXBkYXRlci5qcyIsIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLkFwcEltYWdlVXBkYXRlciA9IHVuZGVmaW5lZDtcblxudmFyIF9ibHVlYmlyZExzdDtcblxuZnVuY3Rpb24gX2xvYWRfYmx1ZWJpcmRMc3QoKSB7XG4gICAgcmV0dXJuIF9ibHVlYmlyZExzdCA9IHJlcXVpcmUoXCJibHVlYmlyZC1sc3RcIik7XG59XG5cbnZhciBfYmx1ZWJpcmRMc3QyO1xuXG5mdW5jdGlvbiBfbG9hZF9ibHVlYmlyZExzdDIoKSB7XG4gICAgcmV0dXJuIF9ibHVlYmlyZExzdDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJibHVlYmlyZC1sc3RcIikpO1xufVxuXG52YXIgX2J1aWxkZXJVdGlsUnVudGltZTtcblxuZnVuY3Rpb24gX2xvYWRfYnVpbGRlclV0aWxSdW50aW1lKCkge1xuICAgIHJldHVybiBfYnVpbGRlclV0aWxSdW50aW1lID0gcmVxdWlyZShcImJ1aWxkZXItdXRpbC1ydW50aW1lXCIpO1xufVxuXG52YXIgX2NoaWxkX3Byb2Nlc3M7XG5cbmZ1bmN0aW9uIF9sb2FkX2NoaWxkX3Byb2Nlc3MoKSB7XG4gICAgcmV0dXJuIF9jaGlsZF9wcm9jZXNzID0gcmVxdWlyZShcImNoaWxkX3Byb2Nlc3NcIik7XG59XG5cbnZhciBfZWxlY3Ryb25Jc0RldjtcblxuZnVuY3Rpb24gX2xvYWRfZWxlY3Ryb25Jc0RldigpIHtcbiAgICByZXR1cm4gX2VsZWN0cm9uSXNEZXYgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJlbGVjdHJvbi1pcy1kZXZcIikpO1xufVxuXG52YXIgX2ZzRXh0cmFQO1xuXG5mdW5jdGlvbiBfbG9hZF9mc0V4dHJhUCgpIHtcbiAgICByZXR1cm4gX2ZzRXh0cmFQID0gcmVxdWlyZShcImZzLWV4dHJhLXBcIik7XG59XG5cbnZhciBfcGF0aCA9IF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKHJlcXVpcmUoXCJwYXRoXCIpKTtcblxucmVxdWlyZShcInNvdXJjZS1tYXAtc3VwcG9ydC9yZWdpc3RlclwiKTtcblxudmFyIF9CYXNlVXBkYXRlcjtcblxuZnVuY3Rpb24gX2xvYWRfQmFzZVVwZGF0ZXIoKSB7XG4gICAgcmV0dXJuIF9CYXNlVXBkYXRlciA9IHJlcXVpcmUoXCIuL0Jhc2VVcGRhdGVyXCIpO1xufVxuXG52YXIgX0ZpbGVXaXRoRW1iZWRkZWRCbG9ja01hcERpZmZlcmVudGlhbERvd25sb2FkZXI7XG5cbmZ1bmN0aW9uIF9sb2FkX0ZpbGVXaXRoRW1iZWRkZWRCbG9ja01hcERpZmZlcmVudGlhbERvd25sb2FkZXIoKSB7XG4gICAgcmV0dXJuIF9GaWxlV2l0aEVtYmVkZGVkQmxvY2tNYXBEaWZmZXJlbnRpYWxEb3dubG9hZGVyID0gcmVxdWlyZShcIi4vZGlmZmVyZW50aWFsRG93bmxvYWRlci9GaWxlV2l0aEVtYmVkZGVkQmxvY2tNYXBEaWZmZXJlbnRpYWxEb3dubG9hZGVyXCIpO1xufVxuXG52YXIgX21haW47XG5cbmZ1bmN0aW9uIF9sb2FkX21haW4oKSB7XG4gICAgcmV0dXJuIF9tYWluID0gcmVxdWlyZShcIi4vbWFpblwiKTtcbn1cblxudmFyIF9Qcm92aWRlcjtcblxuZnVuY3Rpb24gX2xvYWRfUHJvdmlkZXIoKSB7XG4gICAgcmV0dXJuIF9Qcm92aWRlciA9IHJlcXVpcmUoXCIuL1Byb3ZpZGVyXCIpO1xufVxuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChvYmopIHsgaWYgKG9iaiAmJiBvYmouX19lc01vZHVsZSkgeyByZXR1cm4gb2JqOyB9IGVsc2UgeyB2YXIgbmV3T2JqID0ge307IGlmIChvYmogIT0gbnVsbCkgeyBmb3IgKHZhciBrZXkgaW4gb2JqKSB7IGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBrZXkpKSBuZXdPYmpba2V5XSA9IG9ialtrZXldOyB9IH0gbmV3T2JqLmRlZmF1bHQgPSBvYmo7IHJldHVybiBuZXdPYmo7IH0gfVxuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5jbGFzcyBBcHBJbWFnZVVwZGF0ZXIgZXh0ZW5kcyAoX0Jhc2VVcGRhdGVyIHx8IF9sb2FkX0Jhc2VVcGRhdGVyKCkpLkJhc2VVcGRhdGVyIHtcbiAgICBjb25zdHJ1Y3RvcihvcHRpb25zLCBhcHApIHtcbiAgICAgICAgc3VwZXIob3B0aW9ucywgYXBwKTtcbiAgICB9XG4gICAgY2hlY2tGb3JVcGRhdGVzQW5kTm90aWZ5KCkge1xuICAgICAgICBpZiAoKF9lbGVjdHJvbklzRGV2IHx8IF9sb2FkX2VsZWN0cm9uSXNEZXYoKSkuZGVmYXVsdCkge1xuICAgICAgICAgICAgcmV0dXJuIChfYmx1ZWJpcmRMc3QyIHx8IF9sb2FkX2JsdWViaXJkTHN0MigpKS5kZWZhdWx0LnJlc29sdmUobnVsbCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHByb2Nlc3MuZW52LkFQUElNQUdFID09IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuX2xvZ2dlci53YXJuKFwiQVBQSU1BR0UgZW52IGlzIG5vdCBkZWZpbmVkLCBjdXJyZW50IGFwcGxpY2F0aW9uIGlzIG5vdCBhbiBBcHBJbWFnZVwiKTtcbiAgICAgICAgICAgIHJldHVybiAoX2JsdWViaXJkTHN0MiB8fCBfbG9hZF9ibHVlYmlyZExzdDIoKSkuZGVmYXVsdC5yZXNvbHZlKG51bGwpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzdXBlci5jaGVja0ZvclVwZGF0ZXNBbmROb3RpZnkoKTtcbiAgICB9XG4gICAgLyoqKiBAcHJpdmF0ZSAqL1xuICAgIGRvRG93bmxvYWRVcGRhdGUodXBkYXRlSW5mbywgY2FuY2VsbGF0aW9uVG9rZW4pIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgICAgICByZXR1cm4gKDAsIChfYmx1ZWJpcmRMc3QgfHwgX2xvYWRfYmx1ZWJpcmRMc3QoKSkuY29yb3V0aW5lKShmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3QgcHJvdmlkZXIgPSB5aWVsZCBfdGhpcy5wcm92aWRlcjtcbiAgICAgICAgICAgIGNvbnN0IGZpbGVJbmZvID0gKDAsIChfUHJvdmlkZXIgfHwgX2xvYWRfUHJvdmlkZXIoKSkuZmluZEZpbGUpKHByb3ZpZGVyLnJlc29sdmVGaWxlcyh1cGRhdGVJbmZvKSwgXCJBcHBJbWFnZVwiKTtcbiAgICAgICAgICAgIGNvbnN0IHJlcXVlc3RIZWFkZXJzID0geWllbGQgX3RoaXMuY29tcHV0ZVJlcXVlc3RIZWFkZXJzKCk7XG4gICAgICAgICAgICBjb25zdCBkb3dubG9hZE9wdGlvbnMgPSB7XG4gICAgICAgICAgICAgICAgc2tpcERpckNyZWF0aW9uOiB0cnVlLFxuICAgICAgICAgICAgICAgIGhlYWRlcnM6IHJlcXVlc3RIZWFkZXJzLFxuICAgICAgICAgICAgICAgIGNhbmNlbGxhdGlvblRva2VuLFxuICAgICAgICAgICAgICAgIHNoYTUxMjogZmlsZUluZm8uaW5mby5zaGE1MTJcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBsZXQgaW5zdGFsbGVyUGF0aCA9IF90aGlzLmRvd25sb2FkZWRVcGRhdGVIZWxwZXIuZ2V0RG93bmxvYWRlZEZpbGUodXBkYXRlSW5mbywgZmlsZUluZm8pO1xuICAgICAgICAgICAgaWYgKGluc3RhbGxlclBhdGggIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBbaW5zdGFsbGVyUGF0aF07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB5aWVsZCBfdGhpcy5leGVjdXRlRG93bmxvYWQoZG93bmxvYWRPcHRpb25zLCBmaWxlSW5mbywgKCgpID0+IHtcbiAgICAgICAgICAgICAgICB2YXIgX3JlZiA9ICgwLCAoX2JsdWViaXJkTHN0IHx8IF9sb2FkX2JsdWViaXJkTHN0KCkpLmNvcm91dGluZSkoZnVuY3Rpb24qICh0ZW1wRGlyLCBkZXN0aW5hdGlvbkZpbGUpIHtcbiAgICAgICAgICAgICAgICAgICAgaW5zdGFsbGVyUGF0aCA9IGRlc3RpbmF0aW9uRmlsZTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgb2xkRmlsZSA9IHByb2Nlc3MuZW52LkFQUElNQUdFO1xuICAgICAgICAgICAgICAgICAgICBpZiAob2xkRmlsZSA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyAoMCwgKF9idWlsZGVyVXRpbFJ1bnRpbWUgfHwgX2xvYWRfYnVpbGRlclV0aWxSdW50aW1lKCkpLm5ld0Vycm9yKShcIkFQUElNQUdFIGVudiBpcyBub3QgZGVmaW5lZFwiLCBcIkVSUl9VUERBVEVSX09MRF9GSUxFX05PVF9GT1VORFwiKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBsZXQgaXNEb3dubG9hZEZ1bGwgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHlpZWxkIG5ldyAoX0ZpbGVXaXRoRW1iZWRkZWRCbG9ja01hcERpZmZlcmVudGlhbERvd25sb2FkZXIgfHwgX2xvYWRfRmlsZVdpdGhFbWJlZGRlZEJsb2NrTWFwRGlmZmVyZW50aWFsRG93bmxvYWRlcigpKS5GaWxlV2l0aEVtYmVkZGVkQmxvY2tNYXBEaWZmZXJlbnRpYWxEb3dubG9hZGVyKGZpbGVJbmZvLmluZm8sIF90aGlzLmh0dHBFeGVjdXRvciwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ld1VybDogZmlsZUluZm8udXJsLmhyZWYsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb2xkRmlsZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsb2dnZXI6IF90aGlzLl9sb2dnZXIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV3RmlsZTogaW5zdGFsbGVyUGF0aCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB1c2VNdWx0aXBsZVJhbmdlUmVxdWVzdDogcHJvdmlkZXIudXNlTXVsdGlwbGVSYW5nZVJlcXVlc3QsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVxdWVzdEhlYWRlcnNcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pLmRvd25sb2FkKCk7XG4gICAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLl9sb2dnZXIuZXJyb3IoYENhbm5vdCBkb3dubG9hZCBkaWZmZXJlbnRpYWxseSwgZmFsbGJhY2sgdG8gZnVsbCBkb3dubG9hZDogJHtlLnN0YWNrIHx8IGV9YCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBkdXJpbmcgdGVzdCAoZGV2ZWxvcGVyIG1hY2hpbmUgbWFjKSB3ZSBtdXN0IHRocm93IGVycm9yXG4gICAgICAgICAgICAgICAgICAgICAgICBpc0Rvd25sb2FkRnVsbCA9IHByb2Nlc3MucGxhdGZvcm0gPT09IFwibGludXhcIjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoaXNEb3dubG9hZEZ1bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHlpZWxkIF90aGlzLmh0dHBFeGVjdXRvci5kb3dubG9hZChmaWxlSW5mby51cmwuaHJlZiwgaW5zdGFsbGVyUGF0aCwgZG93bmxvYWRPcHRpb25zKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB5aWVsZCAoMCwgKF9mc0V4dHJhUCB8fCBfbG9hZF9mc0V4dHJhUCgpKS5jaG1vZCkoaW5zdGFsbGVyUGF0aCwgMG83NTUpO1xuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChfeCwgX3gyKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBfcmVmLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0pKCkpO1xuICAgICAgICAgICAgX3RoaXMuZG93bmxvYWRlZFVwZGF0ZUhlbHBlci5zZXREb3dubG9hZGVkRmlsZShpbnN0YWxsZXJQYXRoLCBudWxsLCB1cGRhdGVJbmZvLCBmaWxlSW5mbyk7XG4gICAgICAgICAgICBfdGhpcy5hZGRRdWl0SGFuZGxlcigpO1xuICAgICAgICAgICAgX3RoaXMuZW1pdCgoX21haW4gfHwgX2xvYWRfbWFpbigpKS5VUERBVEVfRE9XTkxPQURFRCwgX3RoaXMudXBkYXRlSW5mbyk7XG4gICAgICAgICAgICByZXR1cm4gW2luc3RhbGxlclBhdGhdO1xuICAgICAgICB9KSgpO1xuICAgIH1cbiAgICBkb0luc3RhbGwoaW5zdGFsbGVyUGF0aCwgaXNTaWxlbnQsIGlzUnVuQWZ0ZXIpIHtcbiAgICAgICAgY29uc3QgYXBwSW1hZ2VGaWxlID0gcHJvY2Vzcy5lbnYuQVBQSU1BR0U7XG4gICAgICAgIGlmIChhcHBJbWFnZUZpbGUgPT0gbnVsbCkge1xuICAgICAgICAgICAgdGhyb3cgKDAsIChfYnVpbGRlclV0aWxSdW50aW1lIHx8IF9sb2FkX2J1aWxkZXJVdGlsUnVudGltZSgpKS5uZXdFcnJvcikoXCJBUFBJTUFHRSBlbnYgaXMgbm90IGRlZmluZWRcIiwgXCJFUlJfVVBEQVRFUl9PTERfRklMRV9OT1RfRk9VTkRcIik7XG4gICAgICAgIH1cbiAgICAgICAgLy8gaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9hLzE3MTIwNTEvMTkxMDE5MVxuICAgICAgICAoMCwgKF9mc0V4dHJhUCB8fCBfbG9hZF9mc0V4dHJhUCgpKS51bmxpbmtTeW5jKShhcHBJbWFnZUZpbGUpO1xuICAgICAgICBsZXQgZGVzdGluYXRpb247XG4gICAgICAgIGlmIChfcGF0aC5iYXNlbmFtZShpbnN0YWxsZXJQYXRoKSA9PT0gX3BhdGguYmFzZW5hbWUoYXBwSW1hZ2VGaWxlKSkge1xuICAgICAgICAgICAgLy8gbm8gdmVyc2lvbiBpbiB0aGUgZmlsZSBuYW1lLCBvdmVyd3JpdGUgZXhpc3RpbmdcbiAgICAgICAgICAgIGRlc3RpbmF0aW9uID0gYXBwSW1hZ2VGaWxlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZGVzdGluYXRpb24gPSBfcGF0aC5qb2luKF9wYXRoLmRpcm5hbWUoYXBwSW1hZ2VGaWxlKSwgX3BhdGguYmFzZW5hbWUoaW5zdGFsbGVyUGF0aCkpO1xuICAgICAgICB9XG4gICAgICAgICgwLCAoX2NoaWxkX3Byb2Nlc3MgfHwgX2xvYWRfY2hpbGRfcHJvY2VzcygpKS5leGVjRmlsZVN5bmMpKFwibXZcIiwgW1wiLWZcIiwgaW5zdGFsbGVyUGF0aCwgZGVzdGluYXRpb25dKTtcbiAgICAgICAgY29uc3QgZW52ID0gT2JqZWN0LmFzc2lnbih7fSwgcHJvY2Vzcy5lbnYsIHsgQVBQSU1BR0VfU0lMRU5UX0lOU1RBTEw6IFwidHJ1ZVwiIH0pO1xuICAgICAgICBpZiAoaXNSdW5BZnRlcikge1xuICAgICAgICAgICAgKDAsIChfY2hpbGRfcHJvY2VzcyB8fCBfbG9hZF9jaGlsZF9wcm9jZXNzKCkpLnNwYXduKShkZXN0aW5hdGlvbiwgW10sIHtcbiAgICAgICAgICAgICAgICBkZXRhY2hlZDogdHJ1ZSxcbiAgICAgICAgICAgICAgICBzdGRpbzogXCJpZ25vcmVcIixcbiAgICAgICAgICAgICAgICBlbnZcbiAgICAgICAgICAgIH0pLnVucmVmKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBlbnYuQVBQSU1BR0VfRVhJVF9BRlRFUl9JTlNUQUxMID0gXCJ0cnVlXCI7XG4gICAgICAgICAgICAoMCwgKF9jaGlsZF9wcm9jZXNzIHx8IF9sb2FkX2NoaWxkX3Byb2Nlc3MoKSkuZXhlY0ZpbGVTeW5jKShkZXN0aW5hdGlvbiwgW10sIHsgZW52IH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbn1cbmV4cG9ydHMuQXBwSW1hZ2VVcGRhdGVyID0gQXBwSW1hZ2VVcGRhdGVyOyAvLyMgc291cmNlTWFwcGluZ1VSTD1BcHBJbWFnZVVwZGF0ZXIuanMubWFwXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2VsZWN0cm9uLXVwZGF0ZXIvb3V0L0FwcEltYWdlVXBkYXRlci5qcyIsIid1c2Ugc3RyaWN0JztcblxuaWYgKHByb2Nlc3MudHlwZSA9PT0gJ3JlbmRlcmVyJykge1xuICBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vcmVuZGVyZXInKTtcbn0gZWxzZSB7XG4gIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9tYWluJyk7XG59XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2VsZWN0cm9uLWxvZy9pbmRleC5qcyIsIid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSBudWxsO1xuXG52YXIgaXBjUmVuZGVyZXI7XG50cnkge1xuICBpcGNSZW5kZXJlciA9IHJlcXVpcmUoJ2VsZWN0cm9uJykuaXBjUmVuZGVyZXI7XG59IGNhdGNoIChlKSB7XG4gIGlwY1JlbmRlcmVyID0gbnVsbDtcbn1cblxudmFyIG9yaWdpbmFsQ29uc29sZSA9IHJlcXVpcmUoJy4vbGliL29yaWdpbmFsLWNvbnNvbGUnKTtcblxuaWYgKGlwY1JlbmRlcmVyKSB7XG4gIG1vZHVsZS5leHBvcnRzID0ge1xuICAgIGVycm9yOiAgIGxvZy5iaW5kKG51bGwsICdlcnJvcicpLFxuICAgIHdhcm46ICAgIGxvZy5iaW5kKG51bGwsICd3YXJuJyksXG4gICAgaW5mbzogICAgbG9nLmJpbmQobnVsbCwgJ2luZm8nKSxcbiAgICB2ZXJib3NlOiBsb2cuYmluZChudWxsLCAndmVyYm9zZScpLFxuICAgIGRlYnVnOiAgIGxvZy5iaW5kKG51bGwsICdkZWJ1ZycpLFxuICAgIHNpbGx5OiAgIGxvZy5iaW5kKG51bGwsICdzaWxseScpLFxuICAgIGxvZzogICAgIGxvZy5iaW5kKG51bGwsICdpbmZvJylcbiAgfTtcblxuICBtb2R1bGUuZXhwb3J0cy5kZWZhdWx0ID0gbW9kdWxlLmV4cG9ydHM7XG5cbiAgaXBjUmVuZGVyZXIub24oJ19fRUxFQ1RST05fTE9HX1JFTkRFUkVSX18nLCBmdW5jdGlvbihldmVudCwgbGV2ZWwsIHRleHQpIHtcbiAgICBpZiAobGV2ZWwgPT09ICd2ZXJib3NlJykge1xuICAgICAgbGV2ZWwgPSAnbG9nJztcbiAgICB9IGVsc2UgaWYgKGxldmVsID09PSAnc2lsbHknKSB7XG4gICAgICBsZXZlbCA9ICdkZWJ1Zyc7XG4gICAgfVxuXG4gICAgb3JpZ2luYWxDb25zb2xlW2xldmVsXS5jYWxsKG9yaWdpbmFsQ29uc29sZS5jb250ZXh0LCB0ZXh0KTtcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIGxvZygpIHtcbiAgdmFyIGRhdGEgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpO1xuXG4gIGRhdGEgPSBkYXRhLm1hcChmdW5jdGlvbihvYmopIHtcbiAgICBpZiAob2JqIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgIG9iaiA9IG9iai5zdGFjayB8fCBvYmo7XG4gICAgfVxuXG4gICAgcmV0dXJuIG9iajtcbiAgfSk7XG5cbiAgaXBjUmVuZGVyZXIuc2VuZCgnX19FTEVDVFJPTl9MT0dfXycsIGRhdGEpO1xufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2VsZWN0cm9uLWxvZy9yZW5kZXJlci5qcyIsIid1c2Ugc3RyaWN0JztcblxudmFyIGVsZWN0cm9uO1xudHJ5IHtcbiAgZWxlY3Ryb24gPSByZXF1aXJlKCdlbGVjdHJvbicpO1xufSBjYXRjaCAoZSkge1xuICBlbGVjdHJvbiA9IG51bGw7XG59XG5cbnZhciBsb2cgICAgICAgICAgICAgICAgICAgICAgPSByZXF1aXJlKCcuL2xpYi9sb2cnKTtcbnZhciB0cmFuc3BvcnRDb25zb2xlICAgICAgICAgPSByZXF1aXJlKCcuL2xpYi90cmFuc3BvcnRzL2NvbnNvbGUnKTtcbnZhciB0cmFuc3BvcnRGaWxlICAgICAgICAgICAgPSByZXF1aXJlKCcuL2xpYi90cmFuc3BvcnRzL2ZpbGUnKTtcbnZhciB0cmFuc3BvcnRMb2dTICAgICAgICAgICAgPSByZXF1aXJlKCcuL2xpYi90cmFuc3BvcnRzL2xvZy1zJyk7XG52YXIgdHJhbnNwb3J0UmVuZGVyZXJDb25zb2xlID0gcmVxdWlyZSgnLi9saWIvdHJhbnNwb3J0cy9yZW5kZXJlci1jb25zb2xlJyk7XG5cbnZhciB0cmFuc3BvcnRzID0ge1xuICBjb25zb2xlOiB0cmFuc3BvcnRDb25zb2xlLFxuICBmaWxlOiB0cmFuc3BvcnRGaWxlLFxuICBsb2dTOiB0cmFuc3BvcnRMb2dTLFxuICByZW5kZXJlckNvbnNvbGU6IHRyYW5zcG9ydFJlbmRlcmVyQ29uc29sZVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIHRyYW5zcG9ydHM6IHRyYW5zcG9ydHMsXG5cbiAgZXJyb3I6ICAgbG9nLmJpbmQobnVsbCwgdHJhbnNwb3J0cywgJ2Vycm9yJyksXG4gIHdhcm46ICAgIGxvZy5iaW5kKG51bGwsIHRyYW5zcG9ydHMsICd3YXJuJyksXG4gIGluZm86ICAgIGxvZy5iaW5kKG51bGwsIHRyYW5zcG9ydHMsICdpbmZvJyksXG4gIHZlcmJvc2U6IGxvZy5iaW5kKG51bGwsIHRyYW5zcG9ydHMsICd2ZXJib3NlJyksXG4gIGRlYnVnOiAgIGxvZy5iaW5kKG51bGwsIHRyYW5zcG9ydHMsICdkZWJ1ZycpLFxuICBzaWxseTogICBsb2cuYmluZChudWxsLCB0cmFuc3BvcnRzLCAnc2lsbHknKSxcbiAgbG9nOiAgICAgbG9nLmJpbmQobnVsbCwgdHJhbnNwb3J0cywgJ2luZm8nKVxufTtcblxubW9kdWxlLmV4cG9ydHMuZGVmYXVsdCA9IG1vZHVsZS5leHBvcnRzO1xuXG5pZiAoZWxlY3Ryb24gJiYgZWxlY3Ryb24uaXBjTWFpbikge1xuICBlbGVjdHJvbi5pcGNNYWluLm9uKCdfX0VMRUNUUk9OX0xPR19fJywgb25SZW5kZXJlckxvZyk7XG4gIHZhciBhcHBOYW1lID0gZWxlY3Ryb24uYXBwLmdldE5hbWUoKTtcbiAgaWYgKGFwcE5hbWUgIT09ICdFbGVjdHJvbicpIHtcbiAgICB0cmFuc3BvcnRGaWxlLmFwcE5hbWUgPSBhcHBOYW1lO1xuICB9XG59XG5cbmZ1bmN0aW9uIG9uUmVuZGVyZXJMb2coZXZlbnQsIGRhdGEpIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkoZGF0YSkpIHtcbiAgICBkYXRhLnVuc2hpZnQodHJhbnNwb3J0cyk7XG4gICAgbG9nLmFwcGx5KG51bGwsIGRhdGEpO1xuICB9XG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvZWxlY3Ryb24tbG9nL21haW4uanMiLCIvLyBqc2hpbnQgLVcwNDBcbid1c2Ugc3RyaWN0JztcblxudmFyIExFVkVMUyA9IFsnZXJyb3InLCAnd2FybicsICdpbmZvJywgJ3ZlcmJvc2UnLCAnZGVidWcnLCAnc2lsbHknXTtcblxubW9kdWxlLmV4cG9ydHMgPSBsb2c7XG5cbmZ1bmN0aW9uIGxvZyh0cmFuc3BvcnRzLCBsZXZlbCwgdGV4dCkge1xuICB2YXIgZGF0YSA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMik7XG5cbiAgdmFyIG1zZyA9IHtcbiAgICBkYXRhOiBkYXRhLFxuICAgIGRhdGU6IG5ldyBEYXRlKCksXG4gICAgbGV2ZWw6IGxldmVsXG4gIH07XG5cbiAgZm9yICh2YXIgaSBpbiB0cmFuc3BvcnRzKSB7XG4gICAgLy8ganNoaW50IC1XMDg5XG4gICAgaWYgKCF0cmFuc3BvcnRzLmhhc093blByb3BlcnR5KGkpIHx8IHR5cGVvZiB0cmFuc3BvcnRzW2ldICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICB2YXIgdHJhbnNwb3J0ID0gdHJhbnNwb3J0c1tpXTtcblxuICAgIGlmICh0cmFuc3BvcnQgPT09IGZhbHNlIHx8ICFjb21wYXJlTGV2ZWxzKHRyYW5zcG9ydC5sZXZlbCwgbGV2ZWwpKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICBpZiAodHJhbnNwb3J0LmxldmVsID09PSBmYWxzZSkgY29udGludWU7XG5cbiAgICB0cmFuc3BvcnQuY2FsbChudWxsLCBtc2cpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGNvbXBhcmVMZXZlbHMocGFzc0xldmVsLCBjaGVja0xldmVsKSB7XG4gIHZhciBwYXNzID0gTEVWRUxTLmluZGV4T2YocGFzc0xldmVsKTtcbiAgdmFyIGNoZWNrID0gTEVWRUxTLmluZGV4T2YoY2hlY2tMZXZlbCk7XG4gIGlmIChjaGVjayA9PT0gLTEgfHwgcGFzcyA9PT0gLTEpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICByZXR1cm4gY2hlY2sgPD0gcGFzcztcbn1cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvZWxlY3Ryb24tbG9nL2xpYi9sb2cuanMiLCIndXNlIHN0cmljdCc7XG5cbnZhciBmcyAgICAgICAgICAgICAgID0gcmVxdWlyZSgnZnMnKTtcbnZhciBFT0wgICAgICAgICAgICAgID0gcmVxdWlyZSgnb3MnKS5FT0w7XG52YXIgZm9ybWF0ICAgICAgICAgICA9IHJlcXVpcmUoJy4uLy4uL2Zvcm1hdCcpO1xudmFyIGNvbnNvbGVUcmFuc3BvcnQgPSByZXF1aXJlKCcuLi9jb25zb2xlJyk7XG52YXIgZmluZExvZ1BhdGggICAgICA9IHJlcXVpcmUoJy4vZmluZC1sb2ctcGF0aCcpO1xuXG50cmFuc3BvcnQuZmluZExvZ1BhdGggID0gZmluZExvZ1BhdGg7XG50cmFuc3BvcnQuZm9ybWF0ICAgICAgID0gJ1t7eX0te219LXtkfSB7aH06e2l9OntzfS57bXN9XSBbe2xldmVsfV0ge3RleHR9JztcbnRyYW5zcG9ydC5sZXZlbCAgICAgICAgPSAnd2Fybic7XG50cmFuc3BvcnQubWF4U2l6ZSAgICAgID0gMTAyNCAqIDEwMjQ7XG50cmFuc3BvcnQuc3RyZWFtQ29uZmlnID0gdW5kZWZpbmVkO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHRyYW5zcG9ydDtcblxuZnVuY3Rpb24gdHJhbnNwb3J0KG1zZykge1xuICB2YXIgdGV4dCA9IGZvcm1hdC5mb3JtYXQobXNnLCB0cmFuc3BvcnQuZm9ybWF0KSArIEVPTDtcblxuICBpZiAodHJhbnNwb3J0LnN0cmVhbSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgaW5pdFN0ZWFtQ29uZmlnKCk7XG4gICAgb3BlblN0cmVhbSgpO1xuICB9XG5cbiAgaWYgKHRyYW5zcG9ydC5sZXZlbCA9PT0gZmFsc2UpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgbmVlZExvZ1JvdGF0aW9uID0gdHJhbnNwb3J0Lm1heFNpemUgPiAwICYmXG4gICAgZ2V0U3RyZWFtU2l6ZSh0cmFuc3BvcnQuc3RyZWFtKSA+IHRyYW5zcG9ydC5tYXhTaXplO1xuXG4gIGlmIChuZWVkTG9nUm90YXRpb24pIHtcbiAgICBhcmNoaXZlTG9nKHRyYW5zcG9ydC5zdHJlYW0pO1xuICAgIG9wZW5TdHJlYW0oKTtcbiAgfVxuXG4gIHRyYW5zcG9ydC5zdHJlYW0ud3JpdGUodGV4dCk7XG59XG5cbmZ1bmN0aW9uIGluaXRTdGVhbUNvbmZpZygpIHtcbiAgdHJhbnNwb3J0LmZpbGUgPSB0cmFuc3BvcnQuZmlsZSB8fCBmaW5kTG9nUGF0aCh0cmFuc3BvcnQuYXBwTmFtZSk7XG5cbiAgaWYgKCF0cmFuc3BvcnQuZmlsZSkge1xuICAgIHRyYW5zcG9ydC5sZXZlbCA9IGZhbHNlO1xuICAgIGxvZ0NvbnNvbGUoJ0NvdWxkIG5vdCBzZXQgYSBsb2cgZmlsZScpO1xuICB9XG59XG5cbmZ1bmN0aW9uIG9wZW5TdHJlYW0oKSB7XG4gIGlmICh0cmFuc3BvcnQubGV2ZWwgPT09IGZhbHNlKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdHJhbnNwb3J0LnN0cmVhbSA9IGZzLmNyZWF0ZVdyaXRlU3RyZWFtKFxuICAgIHRyYW5zcG9ydC5maWxlLFxuICAgIHRyYW5zcG9ydC5zdHJlYW1Db25maWcgfHwgeyBmbGFnczogJ2EnIH1cbiAgKTtcbn1cblxuZnVuY3Rpb24gZ2V0U3RyZWFtU2l6ZShzdHJlYW0pIHtcbiAgaWYgKCFzdHJlYW0pIHtcbiAgICByZXR1cm4gMDtcbiAgfVxuXG4gIGlmIChzdHJlYW0ubG9nU2l6ZUF0U3RhcnQgPT09IHVuZGVmaW5lZCkge1xuICAgIHRyeSB7XG4gICAgICBzdHJlYW0ubG9nU2l6ZUF0U3RhcnQgPSBmcy5zdGF0U3luYyhzdHJlYW0ucGF0aCkuc2l6ZTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBzdHJlYW0ubG9nU2l6ZUF0U3RhcnQgPSAwO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBzdHJlYW0ubG9nU2l6ZUF0U3RhcnQgKyBzdHJlYW0uYnl0ZXNXcml0dGVuO1xufVxuXG5mdW5jdGlvbiBhcmNoaXZlTG9nKHN0cmVhbSkge1xuICBpZiAoc3RyZWFtLmVuZCkge1xuICAgIHN0cmVhbS5lbmQoKTtcbiAgfVxuXG4gIHRyeSB7XG4gICAgZnMucmVuYW1lU3luYyhzdHJlYW0ucGF0aCwgc3RyZWFtLnBhdGgucmVwbGFjZSgvbG9nJC8sICdvbGQubG9nJykpO1xuICB9IGNhdGNoIChlKSB7XG4gICAgbG9nQ29uc29sZSgnQ291bGQgbm90IHJvdGF0ZSBsb2cnLCBlKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBsb2dDb25zb2xlKG1lc3NhZ2UsIGVycm9yKSB7XG4gIHZhciBkYXRhID0gWydlbGVjdHJvbi1sb2cudHJhbnNwb3J0cy5maWxlOiAnICsgbWVzc2FnZV07XG5cbiAgaWYgKGVycm9yKSB7XG4gICAgZGF0YS5wdXNoKGVycm9yKTtcbiAgfVxuXG4gIGNvbnNvbGVUcmFuc3BvcnQoeyBkYXRhOiBkYXRhLCBkYXRlOiBuZXcgRGF0ZSgpLCBsZXZlbDogJ3dhcm4nIH0pO1xufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2VsZWN0cm9uLWxvZy9saWIvdHJhbnNwb3J0cy9maWxlL2luZGV4LmpzIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgZnMgICA9IHJlcXVpcmUoJ2ZzJyk7XG52YXIgcGF0aCA9IHJlcXVpcmUoJ3BhdGgnKTtcbnZhciBvcyAgID0gcmVxdWlyZSgnb3MnKTtcbnZhciBnZXRBcHBOYW1lID0gcmVxdWlyZSgnLi9nZXQtYXBwLW5hbWUnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmaW5kTG9nUGF0aDtcblxuLyoqXG4gKiBUcnkgdG8gZGV0ZXJtaW5lIGEgcGxhdGZvcm0tc3BlY2lmaWMgcGF0aCB3aGVyZSBjYW4gd3JpdGUgbG9nc1xuICogQHBhcmFtIHtzdHJpbmd9IFthcHBOYW1lXSBVc2VkIHRvIGRldGVybWluZSB0aGUgbGFzdCBwYXJ0IG9mIGEgbG9nIHBhdGhcbiAqIEByZXR1cm4ge3N0cmluZ3xib29sZWFufVxuICovXG5mdW5jdGlvbiBmaW5kTG9nUGF0aChhcHBOYW1lKSB7XG4gIGFwcE5hbWUgPSBhcHBOYW1lIHx8IGdldEFwcE5hbWUoKTtcbiAgaWYgKCFhcHBOYW1lKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgdmFyIGhvbWVEaXIgPSBvcy5ob21lZGlyID8gb3MuaG9tZWRpcigpIDogcHJvY2Vzcy5lbnZbJ0hPTUUnXTtcbiAgXG4gIHZhciBkaXI7XG4gIHN3aXRjaCAocHJvY2Vzcy5wbGF0Zm9ybSkge1xuICAgIGNhc2UgJ2xpbnV4Jzoge1xuICAgICAgZGlyID0gcHJlcGFyZURpcihwcm9jZXNzLmVudlsnWERHX0NPTkZJR19IT01FJ10sIGFwcE5hbWUpXG4gICAgICAgIC5vcihob21lRGlyLCAnLmNvbmZpZycsIGFwcE5hbWUpXG4gICAgICAgIC5vcihwcm9jZXNzLmVudlsnWERHX0RBVEFfSE9NRSddLCBhcHBOYW1lKVxuICAgICAgICAub3IoaG9tZURpciwgJy5sb2NhbCcsICdzaGFyZScsIGFwcE5hbWUpXG4gICAgICAgIC5yZXN1bHQ7XG4gICAgICBicmVhaztcbiAgICB9XG5cbiAgICBjYXNlICdkYXJ3aW4nOiB7XG4gICAgICBkaXIgPSBwcmVwYXJlRGlyKGhvbWVEaXIsICdMaWJyYXJ5JywgJ0xvZ3MnLCBhcHBOYW1lKVxuICAgICAgICAub3IoaG9tZURpciwgJ0xpYnJhcnknLCAnQXBwbGljYXRpb24gU3VwcG9ydCcsIGFwcE5hbWUpXG4gICAgICAgIC5yZXN1bHQ7XG4gICAgICBicmVhaztcbiAgICB9XG5cbiAgICBjYXNlICd3aW4zMic6IHtcbiAgICAgIGRpciA9IHByZXBhcmVEaXIocHJvY2Vzcy5lbnZbJ0FQUERBVEEnXSwgYXBwTmFtZSlcbiAgICAgICAgLm9yKGhvbWVEaXIsICdBcHBEYXRhJywgJ1JvYW1pbmcnLCBhcHBOYW1lKVxuICAgICAgICAucmVzdWx0O1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG5cbiAgaWYgKGRpcikge1xuICAgIHJldHVybiBwYXRoLmpvaW4oZGlyLCAnbG9nLmxvZycpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufVxuXG5cblxuZnVuY3Rpb24gcHJlcGFyZURpcihkaXJQYXRoKSB7XG4gIC8vIGpzaGludCAtVzA0MFxuICBpZiAoIXRoaXMgfHwgdGhpcy5vciAhPT0gcHJlcGFyZURpciB8fCAhdGhpcy5yZXN1bHQpIHtcbiAgICBpZiAoIWRpclBhdGgpIHtcbiAgICAgIHJldHVybiB7IG9yOiBwcmVwYXJlRGlyIH07XG4gICAgfVxuXG4gICAgLy9ub2luc3BlY3Rpb24gSlNDaGVja0Z1bmN0aW9uU2lnbmF0dXJlc1xuICAgIGRpclBhdGggPSBwYXRoLmpvaW4uYXBwbHkocGF0aCwgYXJndW1lbnRzKTtcbiAgICBta0RpcihkaXJQYXRoKTtcblxuICAgIHRyeSB7XG4gICAgICBmcy5hY2Nlc3NTeW5jKGRpclBhdGgsIGZzLldfT0spO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHJldHVybiB7IG9yOiBwcmVwYXJlRGlyIH07XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBvcjogcHJlcGFyZURpcixcbiAgICByZXN1bHQ6ICh0aGlzID8gdGhpcy5yZXN1bHQgOiBmYWxzZSkgfHwgZGlyUGF0aFxuICB9O1xufVxuXG5mdW5jdGlvbiBta0RpcihkaXJQYXRoLCByb290KSB7XG4gIHZhciBkaXJzID0gZGlyUGF0aC5zcGxpdChwYXRoLnNlcCk7XG4gIHZhciBkaXIgPSBkaXJzLnNoaWZ0KCk7XG4gIHJvb3QgPSAocm9vdCB8fCAnJykgKyBkaXIgKyBwYXRoLnNlcDtcblxuICB0cnkge1xuICAgIGZzLm1rZGlyU3luYyhyb290KTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIGlmICghZnMuc3RhdFN5bmMocm9vdCkuaXNEaXJlY3RvcnkoKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGUpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiAhZGlycy5sZW5ndGggfHwgbWtEaXIoZGlycy5qb2luKHBhdGguc2VwKSwgcm9vdCk7XG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvZWxlY3Ryb24tbG9nL2xpYi90cmFuc3BvcnRzL2ZpbGUvZmluZC1sb2ctcGF0aC5qcyIsIi8vIGpzaGludCAtVzA3NFxuJ3VzZSBzdHJpY3QnO1xuXG4vKiogQG5hbWUgcHJvY2Vzcy5yZXNvdXJjZXNQYXRoICovXG5cbnZhciBmcyAgID0gcmVxdWlyZSgnZnMnKTtcbnZhciBwYXRoID0gcmVxdWlyZSgncGF0aCcpO1xudmFyIGNvbnNvbGVUcmFuc3BvcnQgPSByZXF1aXJlKCcuLi9jb25zb2xlJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZ2V0QXBwTmFtZTtcblxuZnVuY3Rpb24gZ2V0QXBwTmFtZSgpIHtcbiAgdHJ5IHtcbiAgICB2YXIgbmFtZSA9IGxvYWRQYWNrYWdlTmFtZSgpO1xuICAgIGlmIChuYW1lKSB7XG4gICAgICByZXR1cm4gbmFtZTtcbiAgICB9XG4gICAgcmV0dXJuIHdhcm4oJ2VsZWN0cm9uLWxvZzogdW5hYmxlIHRvIGxvYWQgdGhlIGFwcCBuYW1lIGZyb20gcGFja2FnZS5qc29uJyk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICByZXR1cm4gd2FybignZWxlY3Ryb24tbG9nOiAnICsgZS5tZXNzYWdlKTtcbiAgfVxufVxuXG4vKipcbiAqIFRyeSB0byBsb2FkIG1haW4gYXBwIHBhY2thZ2VcbiAqIEB0aHJvd3Mge0Vycm9yfVxuICogQHJldHVybiB7T2JqZWN0fG51bGx9XG4gKi9cbmZ1bmN0aW9uIGxvYWRQYWNrYWdlTmFtZSgpIHtcbiAgdmFyIHBhY2thZ2VGaWxlO1xuXG4gIHRyeSB7XG4gICAgaWYgKHJlcXVpcmUubWFpbi5maWxlbmFtZSkge1xuICAgICAgcGFja2FnZUZpbGUgPSBmaW5kKHBhdGguZGlybmFtZShyZXF1aXJlLm1haW4uZmlsZW5hbWUpKTtcbiAgICB9XG4gIH0gY2F0Y2ggKGUpIHt9XG5cbiAgaWYgKCFwYWNrYWdlRmlsZSAmJiBwcm9jZXNzLnJlc291cmNlc1BhdGgpIHtcbiAgICBwYWNrYWdlRmlsZSA9IGZpbmQocGF0aC5qb2luKHByb2Nlc3MucmVzb3VyY2VzUGF0aCwgJ2FwcC5hc2FyJykpO1xuICAgIHZhciBlbGVjdHJvbk1vZHVsZSA9IHBhdGguam9pbignbm9kZV9tb2R1bGVzJywgJ2VsZWN0cm9uJywgJ3BhY2thZ2UuanNvbicpO1xuICAgIGlmIChwYWNrYWdlRmlsZSAmJiBwYWNrYWdlRmlsZS5pbmRleE9mKGVsZWN0cm9uTW9kdWxlKSAhPT0gLTEpIHtcbiAgICAgIHBhY2thZ2VGaWxlID0gbnVsbDtcbiAgICB9XG4gIH1cblxuICBpZiAoIXBhY2thZ2VGaWxlKSB7XG4gICAgcGFja2FnZUZpbGUgPSBmaW5kKHByb2Nlc3MuY3dkKCkpO1xuICB9XG5cbiAgaWYgKCFwYWNrYWdlRmlsZSkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgdmFyIGNvbnRlbnQgPSBmcy5yZWFkRmlsZVN5bmMocGFja2FnZUZpbGUsICd1dGYtOCcpO1xuICB2YXIgcGFja2FnZURhdGEgPSBKU09OLnBhcnNlKGNvbnRlbnQpO1xuXG4gIC8vbm9pbnNwZWN0aW9uIEpTVW5yZXNvbHZlZFZhcmlhYmxlXG4gIHJldHVybiBwYWNrYWdlRGF0YSA/IHBhY2thZ2VEYXRhLnByb2R1Y3ROYW1lIHx8IHBhY2thZ2VEYXRhLm5hbWUgOiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gZmluZChyb290KSB7XG4gIHZhciBmaWxlO1xuXG4gIHdoaWxlICghZmlsZSkge1xuICAgIHZhciBwYXJlbnQ7XG4gICAgZmlsZSA9IHBhdGguam9pbihyb290LCAncGFja2FnZS5qc29uJyk7XG5cbiAgICB0cnkge1xuICAgICAgZnMuc3RhdFN5bmMoZmlsZSk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgcGFyZW50ID0gcGF0aC5yZXNvbHZlKHJvb3QsICcuLicpO1xuICAgICAgZmlsZSA9IG51bGw7XG4gICAgfVxuXG4gICAgaWYgKHJvb3QgPT09IHBhcmVudCkge1xuICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgcm9vdCA9IHBhcmVudDtcbiAgfVxuXG4gIHJldHVybiBmaWxlO1xufVxuXG5mdW5jdGlvbiB3YXJuKG1lc3NhZ2UpIHtcbiAgY29uc29sZVRyYW5zcG9ydCh7XG4gICAgZGF0YTogW21lc3NhZ2VdLFxuICAgIGRhdGU6IG5ldyBEYXRlKCksXG4gICAgbGV2ZWw6ICd3YXJuJ1xuICB9KTtcbn1cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvZWxlY3Ryb24tbG9nL2xpYi90cmFuc3BvcnRzL2ZpbGUvZ2V0LWFwcC1uYW1lLmpzIiwiLy8ganNoaW50IC1XMDc0LCAtVzA4OVxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgaHR0cCAgPSByZXF1aXJlKCdodHRwJyk7XG52YXIgaHR0cHMgPSByZXF1aXJlKCdodHRwcycpO1xudmFyIHVybCAgID0gcmVxdWlyZSgndXJsJyk7XG5cbnRyYW5zcG9ydC5jbGllbnQgPSB7IG5hbWU6ICdlbGVjdHJvbi1hcHBsaWNhdGlvbicgfTtcbnRyYW5zcG9ydC5kZXB0aCAgPSA2O1xudHJhbnNwb3J0LmxldmVsICA9IGZhbHNlO1xudHJhbnNwb3J0LnVybCAgICA9IG51bGw7XG5cbm1vZHVsZS5leHBvcnRzID0gdHJhbnNwb3J0O1xuXG5mdW5jdGlvbiB0cmFuc3BvcnQobXNnKSB7XG4gIGlmICghdHJhbnNwb3J0LnVybCkgcmV0dXJuO1xuXG4gIHZhciBkYXRhID0ganNvbkRlcHRoKHtcbiAgICBjbGllbnQ6IHRyYW5zcG9ydC5jbGllbnQsXG4gICAgZGF0YTogbXNnLmRhdGEsXG4gICAgZGF0ZTogbXNnLmRhdGUuZ2V0VGltZSgpLFxuICAgIGxldmVsOiBtc2cubGV2ZWxcbiAgfSwgdHJhbnNwb3J0LmRlcHRoICsgMSk7XG5cbiAgcG9zdCh0cmFuc3BvcnQudXJsLCBkYXRhKTtcbn1cblxuZnVuY3Rpb24gcG9zdChzZXJ2ZXJVcmwsIGRhdGEpIHtcbiAgdmFyIHVybE9iamVjdCA9IHVybC5wYXJzZShzZXJ2ZXJVcmwpO1xuICB2YXIgdHJhbnNwb3J0ID0gdXJsT2JqZWN0LnByb3RvY29sID09PSAnaHR0cHM6JyA/IGh0dHBzIDogaHR0cDtcblxuICB2YXIgYm9keSA9IEpTT04uc3RyaW5naWZ5KGRhdGEpO1xuXG4gIHZhciBvcHRpb25zID0ge1xuICAgIGhvc3RuYW1lOiB1cmxPYmplY3QuaG9zdG5hbWUsXG4gICAgcG9ydDogICAgIHVybE9iamVjdC5wb3J0LFxuICAgIHBhdGg6ICAgICB1cmxPYmplY3QucGF0aCxcbiAgICBtZXRob2Q6ICAgJ1BPU1QnLFxuICAgIGhlYWRlcnM6ICB7XG4gICAgICAnQ29udGVudC1UeXBlJzogICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICdDb250ZW50LUxlbmd0aCc6IGJvZHkubGVuZ3RoXG4gICAgfVxuICB9O1xuXG4gIHZhciByZXF1ZXN0ID0gdHJhbnNwb3J0LnJlcXVlc3Qob3B0aW9ucyk7XG4gIHJlcXVlc3Qud3JpdGUoYm9keSk7XG4gIHJlcXVlc3QuZW5kKCk7XG59XG5cbmZ1bmN0aW9uIGpzb25EZXB0aChqc29uLCBkZXB0aCkge1xuICBpZiAoZGVwdGggPCAxKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoanNvbikpICByZXR1cm4gJ1thcnJheV0nO1xuICAgIGlmICh0eXBlb2YganNvbiA9PT0gJ29iamVjdCcpICByZXR1cm4gJ1tvYmplY3RdJztcbiAgICByZXR1cm4ganNvbjtcbiAgfVxuXG4gIGlmIChBcnJheS5pc0FycmF5KGpzb24pKSB7XG4gICAgcmV0dXJuIGpzb24ubWFwKGZ1bmN0aW9uKGNoaWxkKSB7XG4gICAgICByZXR1cm4ganNvbkRlcHRoKGNoaWxkLCBkZXB0aCAtIDEpO1xuICAgIH0pO1xuICB9XG5cbiAgaWYgKGpzb24gJiYgdHlwZW9mIGpzb24uZ2V0TW9udGggPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4ganNvbjtcbiAgfVxuXG4gIGlmIChqc29uID09PSBudWxsKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBpZiAodHlwZW9mIGpzb24gPT09ICdvYmplY3QnKSB7XG4gICAgaWYgKHR5cGVvZiBqc29uLnRvSlNPTiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAganNvbiA9IGpzb24udG9KU09OKCk7XG4gICAgfVxuXG4gICAgdmFyIG5ld0pzb24gPSB7fTtcbiAgICBmb3IgKHZhciBpIGluIGpzb24pIHtcbiAgICAgIC8vbm9pbnNwZWN0aW9uIEpTVW5maWx0ZXJlZEZvckluTG9vcFxuICAgICAgbmV3SnNvbltpXSA9IGpzb25EZXB0aChqc29uW2ldLCBkZXB0aCAtIDEpO1xuICAgIH1cblxuICAgIHJldHVybiBuZXdKc29uO1xuICB9XG5cbiAgcmV0dXJuIGpzb247XG59XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2VsZWN0cm9uLWxvZy9saWIvdHJhbnNwb3J0cy9sb2ctcy5qcyIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcImh0dHBzXCIpO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIGV4dGVybmFsIFwiaHR0cHNcIlxuLy8gbW9kdWxlIGlkID0gMTkxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIid1c2Ugc3RyaWN0JztcblxudmFyIEJyb3dzZXJXaW5kb3c7XG50cnkge1xuICBCcm93c2VyV2luZG93ID0gcmVxdWlyZSgnZWxlY3Ryb24nKS5Ccm93c2VyV2luZG93O1xufSBjYXRjaCAoZSkge1xuICBCcm93c2VyV2luZG93ID0gbnVsbDtcbn1cblxudmFyIGZvcm1hdCA9IHJlcXVpcmUoJy4uL2Zvcm1hdCcpO1xuXG50cmFuc3BvcnQubGV2ZWwgID0gQnJvd3NlcldpbmRvdyA/ICdzaWxseScgOiBmYWxzZTtcbnRyYW5zcG9ydC5mb3JtYXQgPSAnW3tofTp7aX06e3N9Lnttc31dIHt0ZXh0fSc7XG5cbm1vZHVsZS5leHBvcnRzID0gdHJhbnNwb3J0O1xuXG5mdW5jdGlvbiB0cmFuc3BvcnQobXNnKSB7XG4gIGlmICghQnJvd3NlcldpbmRvdykgcmV0dXJuO1xuXG4gIHZhciB0ZXh0ID0gZm9ybWF0LmZvcm1hdChtc2csIHRyYW5zcG9ydC5mb3JtYXQpO1xuICBCcm93c2VyV2luZG93LmdldEFsbFdpbmRvd3MoKS5mb3JFYWNoKGZ1bmN0aW9uKHduZCkge1xuICAgIHduZC53ZWJDb250ZW50cy5zZW5kKCdfX0VMRUNUUk9OX0xPR19SRU5ERVJFUl9fJywgbXNnLmxldmVsLCB0ZXh0KTtcbiAgfSk7XG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvZWxlY3Ryb24tbG9nL2xpYi90cmFuc3BvcnRzL3JlbmRlcmVyLWNvbnNvbGUuanMiLCJtb2R1bGUuZXhwb3J0cyA9IHtcIm5hbWVcIjpcIkVMSVRcIixcInZlcnNpb25cIjpcIjAuMy4wXCIsXCJkZXNjcmlwdGlvblwiOlwiRUxJVCAtIEV2ZSBMb2NhbCBJbnRlbCBUb29sXCIsXCJtYWluXCI6XCJkaXN0L21haW4uanNcIixcInJlcG9zaXRvcnlcIjpcImdpdEBnaXRodWIuY29tOlNxdWFyZWhlYWRzL0VMSVQuZ2l0XCIsXCJhdXRob3JcIjpcIk93ZW4gV29ybGV5XCIsXCJsaWNlbnNlXCI6XCIoYykgU3F1YXJlaGVhZHMgTFREIDIwMThcIixcImRldkRlcGVuZGVuY2llc1wiOntcIkB0eXBlcy9jaGFpXCI6XCJeNC4wLjhcIixcIkB0eXBlcy9lbGVjdHJvblwiOlwiXjEuNi4xMFwiLFwiQHR5cGVzL2VsZWN0cm9uLWlzLWRldlwiOlwiXjAuMy4wXCIsXCJAdHlwZXMvbWF0ZXJpYWwtdWlcIjpcIl4wLjE4LjVcIixcIkB0eXBlcy9tb2NoYVwiOlwiXjIuMi40NFwiLFwiQHR5cGVzL21vY2tlcnlcIjpcIl4xLjQuMjlcIixcIkB0eXBlcy9ub2RlXCI6XCJeOC4wLjUzXCIsXCJAdHlwZXMvcmVhY3RcIjpcIl4xNi4wLjI1XCIsXCJAdHlwZXMvcmVhY3QtZG9tXCI6XCJeMTYuMC4zXCIsXCJAdHlwZXMvcmVxdWVzdFwiOlwiXjIuMC44XCIsXCJAdHlwZXMvcmVxdWVzdC1wcm9taXNlLW5hdGl2ZVwiOlwiXjEuMC4xMFwiLFwiQHR5cGVzL3Npbm9uXCI6XCJeNC4xLjBcIixcIkB0eXBlcy91cmwtcGFyc2VcIjpcIl4xLjEuMFwiLFwiQHR5cGVzL3gyanNcIjpcIl4zLjEuMFwiLFwiYmFiZWwtY29yZVwiOlwiXjYuMjYuMFwiLFwiYmFiZWwtbG9hZGVyXCI6XCJeNy4xLjJcIixcImJhYmVsLXBsdWdpbi1hZGQtbW9kdWxlLWV4cG9ydHNcIjpcIl4wLjIuMVwiLFwiYmFiZWwtcGx1Z2luLWFycmF5LWluY2x1ZGVzXCI6XCJeMi4wLjNcIixcImJhYmVsLXBsdWdpbi1tb2R1bGUtcmVzb2x2ZXJcIjpcIl4zLjAuMFwiLFwiYmFiZWwtcGx1Z2luLXRyYW5zZm9ybS1jbGFzcy1wcm9wZXJ0aWVzXCI6XCJeNi4yNC4xXCIsXCJiYWJlbC1wbHVnaW4tdHJhbnNmb3JtLWRlY29yYXRvcnMtbGVnYWN5XCI6XCJeMS4zLjRcIixcImJhYmVsLXBsdWdpbi10cmFuc2Zvcm0tcnVudGltZVwiOlwiXjYuMC4wXCIsXCJiYWJlbC1wcmVzZXQtZW52XCI6XCJeMS42LjFcIixcImJhYmVsLXByZXNldC1lczIwMTVcIjpcIl42LjI0LjFcIixcImJhYmVsLXByZXNldC1lczIwMTUtbm9kZVwiOlwiXjYuMS4xXCIsXCJiYWJlbC1wcmVzZXQtZXMyMDE1LW5vZGU1XCI6XCJeMS4yLjBcIixcImJhYmVsLXByZXNldC1yZWFjdFwiOlwiXjYuMjQuMVwiLFwiYmFiZWwtcHJlc2V0LXN0YWdlLTNcIjpcIl42LjI0LjFcIixcImJhYmVsLXByZXNldC10cy1ub2RlNi1ibHVlYmlyZFwiOlwiXjEuMC4xXCIsXCJjaGFpXCI6XCJeNC4xLjJcIixcImVsZWN0cm9uXCI6XCJeMS43LjlcIixcImVsZWN0cm9uLWJ1aWxkZXJcIjpcIl4xOS40Ni45XCIsXCJmYWtlLWluZGV4ZWRkYlwiOlwiXjIuMC4zXCIsXCJodG1sLXdlYnBhY2stcGx1Z2luXCI6XCJeMi4zMC4xXCIsXCJpZ25vcmUtc3R5bGVzXCI6XCJeNS4wLjFcIixcImpzb24tdG8tanNcIjpcIl4xLjAuMlwiLFwibW9jaGFcIjpcIl40LjAuMVwiLFwibW9ja2VyeVwiOlwiXjIuMS4wXCIsXCJub2RlLW5vb3BcIjpcIl4xLjAuMFwiLFwibnljXCI6XCJeMTEuMy4wXCIsXCJzaW5vblwiOlwiXjQuMS4zXCIsXCJzdGFuZGFyZFwiOlwiXjEwLjAuM1wiLFwic3RhbmRhcmQtbG9hZGVyXCI6XCJeNi4wLjFcIixcInRzLWxvYWRlclwiOlwiXjMuMS4xXCIsXCJ0cy1tb2NraXRvXCI6XCJeMi4yLjdcIixcInRzLW5vZGVcIjpcIl4zLjMuMFwiLFwidHNsaW50XCI6XCJeNS44LjBcIixcInRzbGludC1jb25maWctc3RhbmRhcmRcIjpcIl43LjAuMFwiLFwidHNsaW50LWxvYWRlclwiOlwiXjMuNS4zXCIsXCJ0eXBlc2NyaXB0XCI6XCJeMi42LjJcIixcIndlYnBhY2tcIjpcIl4zLjguMVwifSxcInNjcmlwdHNcIjp7XCJidWlsZFwiOlwid2VicGFjayAtLWNvbmZpZyB3ZWJwYWNrLmNvbmZpZy5qc1wiLFwicHJlc3RhcnRcIjpcInlhcm4gcnVuIGJ1aWxkXCIsXCJzdGFydFwiOlwiZWxlY3Ryb24gLlwiLFwidGVzdFwiOlwic2V0IFRTX05PREVfUFJPSkVDVD10c2NvbmZpZy50ZXN0Lmpzb24mJm1vY2hhXCIsXCJwYWNrXCI6XCJlbGVjdHJvbi1idWlsZGVyIC0tZGlyXCIsXCJkaXN0XCI6XCJlbGVjdHJvbi1idWlsZGVyXCIsXCJkaXN0LWFsbFwiOlwiZWxlY3Ryb24tYnVpbGRlciAtbXdsXCJ9LFwiZGVwZW5kZW5jaWVzXCI6e1wiZGV4aWVcIjpcIjJcIixcImVsZWN0cm9uLWdvb2dsZS1hbmFseXRpY3NcIjpcIl4wLjAuMjRcIixcImVsZWN0cm9uLWlzLWRldlwiOlwiXjAuMy4wXCIsXCJlbGVjdHJvbi1sb2dcIjpcIl4yLjIuMTNcIixcImVsZWN0cm9uLXVwZGF0ZXJcIjpcIl4yLjE4LjJcIixcImV2ZS1vbmxpbmUtZXNpXCI6XCIgaHR0cHM6Ly9naXRodWIuY29tL1NxdWFyZWhlYWRzL2V2ZS1vbmxpbmUtZXNpL2FyY2hpdmUvZGY0NDBlZmEzOTRlMzZlMDYzYTY1OTNiZWRlOGRkOGQyODVlMTE3OS50YXIuZ3pcIixcIm1hY2hpbmUtdXVpZFwiOlwiXjEuMi4wXCIsXCJtYXRlcmlhbC11aVwiOlwiXjAuMjAuMFwiLFwibWF0ZXJpYWwtdWktaW1hZ2VcIjpcIl4yLjEuMVwiLFwibm9kZS1tYWNoaW5lLWlkXCI6XCJeMS4xLjEwXCIsXCJxdWVyeXN0cmluZ2lmeVwiOlwiXjEuMC4wXCIsXCJyZWFjdFwiOlwiXjE2LjIuMFwiLFwicmVhY3QtZG9tXCI6XCJeMTYuMi4wXCIsXCJyZWFjdC1lbGVjdHJvbi13ZWItdmlld1wiOlwiXjIuMC4xXCIsXCJyZXF1ZXN0XCI6XCJeMi44My4wXCIsXCJ0eXBlc2NyaXB0LWNvbGxlY3Rpb25zXCI6XCJeMS4yLjVcIixcInVybC1wYXJzZVwiOlwiXjEuMi4wXCIsXCJ4MmpzXCI6XCJeMy4xLjFcIn0sXCJidWlsZFwiOntcImFwcElkXCI6XCJpby5zcXVhcmVoZWFkcy5ldmUtaW50ZWxcIixcImZpbGVzXCI6XCIuL2Rpc3QvKiovKlwiLFwiZGlyZWN0b3JpZXNcIjp7XCJvdXRwdXRcIjpcInBhY2thZ2VkXCJ9LFwibWFjXCI6e1wiY2F0ZWdvcnlcIjpcInB1YmxpYy5hcHAtY2F0ZWdvcnkudXRpbGl0aWVzXCJ9fSxcInBlZXJEZXBlbmRlbmNpZXNcIjp7fX1cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3BhY2thZ2UuanNvblxuLy8gbW9kdWxlIGlkID0gMTkzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=